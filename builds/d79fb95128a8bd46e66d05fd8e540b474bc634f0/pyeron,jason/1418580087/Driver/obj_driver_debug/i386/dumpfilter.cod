; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\home\public\desktop\projects\ciphershed.build\src\driver\dumpfilter.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
_BootDriveFilterExtension DD 01H DUP (?)
_WriteFilterBuffer DD 01H DUP (?)
_BSS	ENDS
PUBLIC	??_C@_0BK@MPDBPBLL@DumpFilterEntry?5error?5?$CFx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BM@NIHDEFIH@Dump?5filter?5loaded?5type?$DN?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BJ@DKEIHACK@DumpFilterEntry?5type?$DN?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_DumpFilterEntry@8
EXTRN	__imp__MmAllocateContiguousMemory@12:PROC
EXTRN	_SendDeviceIoControlRequest@24:PROC
EXTRN	_AutoTestAlgorithms@0:PROC
EXTRN	_EnableHwEncryption@4:PROC
EXTRN	_TCDeviceIoControl@24:PROC
EXTRN	_DbgPrint:PROC
_BSS	SEGMENT
_WriteFilterBufferSize DD 01H DUP (?)
	ALIGN	8

_DumpPartitionOffset DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BK@MPDBPBLL@DumpFilterEntry?5error?5?$CFx?6?$AA@FNODOBFM@
; File c:\home\public\desktop\projects\ciphershed.build\src\driver\dumpfilter.c
text$s	SEGMENT
??_C@_0BK@MPDBPBLL@DumpFilterEntry?5error?5?$CFx?6?$AA@FNODOBFM@ DB 'Dump'
	DB	'FilterEntry error %x', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BM@NIHDEFIH@Dump?5filter?5loaded?5type?$DN?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BM@NIHDEFIH@Dump?5filter?5loaded?5type?$DN?$CFd?6?$AA@FNODOBFM@ DB 'D'
	DB	'ump filter loaded type=%d', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'T', 00H, 'r', 00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r'
	DB	00H, 'y', 00H, 'p', 00H, 't', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BJ@DKEIHACK@DumpFilterEntry?5type?$DN?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BJ@DKEIHACK@DumpFilterEntry?5type?$DN?$CFd?6?$AA@FNODOBFM@ DB 'Dum'
	DB	'pFilterEntry type=%d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _DumpFilterEntry@8
_TEXT	SEGMENT
tv209 = -84						; size = 4
tv201 = -80						; size = 4
tv180 = -76						; size = 4
_status$ = -72						; size = 4
_version$ = -68						; size = 4
_highestAcceptableWriteBufferAddr$ = -64		; size = 8
_partitionInfo$ = -56					; size = 32
_storageDeviceNumber$ = -20				; size = 12
_dumpConfig$ = -8					; size = 8
_filterExtension$ = 8					; size = 4
_filterInitData$ = 12					; size = 4
_DumpFilterEntry@8 PROC					; COMDAT

; 21   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 54	 sub	 esp, 84			; 00000054H

; 22   : 	GetSystemDriveDumpConfigRequest dumpConfig;
; 23   : 	PHYSICAL_ADDRESS highestAcceptableWriteBufferAddr;
; 24   : 	STORAGE_DEVICE_NUMBER storageDeviceNumber;
; 25   : 	PARTITION_INFORMATION partitionInfo;
; 26   : 	LONG version;
; 27   : 	NTSTATUS status;
; 28   : 
; 29   : 	Dump ("DumpFilterEntry type=%d\n", filterExtension->DumpType);

  00008	8b 45 08	 mov	 eax, DWORD PTR _filterExtension$[ebp]
  0000b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DKEIHACK@DumpFilterEntry?5type?$DN?$CFd?6?$AA@FNODOBFM@
  00013	e8 00 00 00 00	 call	 _DbgPrint
  00018	83 c4 08	 add	 esp, 8

; 30   : 
; 31   : 	filterInitData->MajorVersion = DUMP_FILTER_MAJOR_VERSION;

  0001b	8b 55 0c	 mov	 edx, DWORD PTR _filterInitData$[ebp]
  0001e	c7 02 01 00 00
	00		 mov	 DWORD PTR [edx], 1

; 32   : 	filterInitData->MinorVersion = DUMP_FILTER_MINOR_VERSION;

  00024	8b 45 0c	 mov	 eax, DWORD PTR _filterInitData$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 33   : 	filterInitData->Flags |= DUMP_FILTER_CRITICAL;

  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _filterInitData$[ebp]
  00031	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00034	83 ca 01	 or	 edx, 1
  00037	8b 45 0c	 mov	 eax, DWORD PTR _filterInitData$[ebp]
  0003a	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 34   : 
; 35   : 	// Check driver version of the main device
; 36   : 	status = TCDeviceIoControl (NT_ROOT_PREFIX, TC_IOCTL_GET_DRIVER_VERSION, NULL, 0, &version, sizeof (version));

  0003d	6a 04		 push	 4
  0003f	8d 4d bc	 lea	 ecx, DWORD PTR _version$[ebp]
  00042	51		 push	 ecx
  00043	6a 00		 push	 0
  00045	6a 00		 push	 0
  00047	68 04 20 22 00	 push	 2236420			; 00222004H
  0004c	68 00 00 00 00	 push	 OFFSET ??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
  00051	e8 00 00 00 00	 call	 _TCDeviceIoControl@24
  00056	89 45 b8	 mov	 DWORD PTR _status$[ebp], eax

; 37   : 	if (!NT_SUCCESS (status))

  00059	83 7d b8 00	 cmp	 DWORD PTR _status$[ebp], 0
  0005d	7d 05		 jge	 SHORT $LN14@DumpFilter

; 38   : 		goto err;

  0005f	e9 27 02 00 00	 jmp	 $err$27801
$LN14@DumpFilter:

; 39   : 
; 40   : 	if (version != VERSION_NUM)

  00064	81 7d bc 30 07
	00 00		 cmp	 DWORD PTR _version$[ebp], 1840 ; 00000730H
  0006b	74 0c		 je	 SHORT $LN13@DumpFilter

; 41   : 	{
; 42   : 		status = STATUS_INVALID_PARAMETER;

  0006d	c7 45 b8 0d 00
	00 c0		 mov	 DWORD PTR _status$[ebp], -1073741811 ; c000000dH

; 43   : 		goto err;

  00074	e9 12 02 00 00	 jmp	 $err$27801
$LN13@DumpFilter:

; 44   : 	}
; 45   : 
; 46   : 	// Get dump configuration from the main device
; 47   : 	status = TCDeviceIoControl (NT_ROOT_PREFIX, TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG, NULL, 0, &dumpConfig, sizeof (dumpConfig));

  00079	6a 08		 push	 8
  0007b	8d 55 f8	 lea	 edx, DWORD PTR _dumpConfig$[ebp]
  0007e	52		 push	 edx
  0007f	6a 00		 push	 0
  00081	6a 00		 push	 0
  00083	68 98 20 22 00	 push	 2236568			; 00222098H
  00088	68 00 00 00 00	 push	 OFFSET ??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
  0008d	e8 00 00 00 00	 call	 _TCDeviceIoControl@24
  00092	89 45 b8	 mov	 DWORD PTR _status$[ebp], eax

; 48   : 	if (!NT_SUCCESS (status))

  00095	83 7d b8 00	 cmp	 DWORD PTR _status$[ebp], 0
  00099	7d 05		 jge	 SHORT $LN12@DumpFilter

; 49   : 		goto err;

  0009b	e9 eb 01 00 00	 jmp	 $err$27801
$LN12@DumpFilter:

; 50   : 
; 51   : 	BootDriveFilterExtension = dumpConfig.BootDriveFilterExtension;

  000a0	8b 45 f8	 mov	 eax, DWORD PTR _dumpConfig$[ebp]
  000a3	a3 00 00 00 00	 mov	 DWORD PTR _BootDriveFilterExtension, eax

; 52   : 
; 53   : 	if (BootDriveFilterExtension->MagicNumber != TC_BOOT_DRIVE_FILTER_EXTENSION_MAGIC_NUMBER)

  000a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _BootDriveFilterExtension
  000ae	89 4d b4	 mov	 DWORD PTR tv180[ebp], ecx
  000b1	8b 55 b4	 mov	 edx, DWORD PTR tv180[ebp]
  000b4	81 7a 10 54 58
	45 42		 cmp	 DWORD PTR [edx+16], 1111840852 ; 42455854H
  000bb	75 0c		 jne	 SHORT $LN17@DumpFilter
  000bd	8b 45 b4	 mov	 eax, DWORD PTR tv180[ebp]
  000c0	81 78 14 45 55
	52 54		 cmp	 DWORD PTR [eax+20], 1414681925 ; 54525545H
  000c7	74 0c		 je	 SHORT $LN11@DumpFilter
$LN17@DumpFilter:

; 54   : 	{
; 55   : 		status = STATUS_CRC_ERROR;

  000c9	c7 45 b8 3f 00
	00 c0		 mov	 DWORD PTR _status$[ebp], -1073741761 ; c000003fH

; 56   : 		goto err;

  000d0	e9 b6 01 00 00	 jmp	 $err$27801
$LN11@DumpFilter:

; 57   : 	}
; 58   : 
; 59   : 	// KeSaveFloatingPointState() may generate a bug check during crash dump
; 60   : #if !defined (_WIN64)
; 61   : 	if (filterExtension->DumpType == DumpTypeCrashdump)

  000d5	8b 4d 08	 mov	 ecx, DWORD PTR _filterExtension$[ebp]
  000d8	83 39 01	 cmp	 DWORD PTR [ecx], 1
  000db	75 07		 jne	 SHORT $LN10@DumpFilter

; 62   : 		dumpConfig.HwEncryptionEnabled = FALSE;

  000dd	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dumpConfig$[ebp+4], 0
$LN10@DumpFilter:

; 63   : #endif
; 64   : 
; 65   : 	EnableHwEncryption (dumpConfig.HwEncryptionEnabled);

  000e4	8b 55 fc	 mov	 edx, DWORD PTR _dumpConfig$[ebp+4]
  000e7	52		 push	 edx
  000e8	e8 00 00 00 00	 call	 _EnableHwEncryption@4

; 66   : 
; 67   : 	if (!AutoTestAlgorithms())

  000ed	e8 00 00 00 00	 call	 _AutoTestAlgorithms@0
  000f2	85 c0		 test	 eax, eax
  000f4	75 0c		 jne	 SHORT $LN9@DumpFilter

; 68   : 	{
; 69   : 		status = STATUS_INVALID_PARAMETER;

  000f6	c7 45 b8 0d 00
	00 c0		 mov	 DWORD PTR _status$[ebp], -1073741811 ; c000000dH

; 70   : 		goto err;

  000fd	e9 89 01 00 00	 jmp	 $err$27801
$LN9@DumpFilter:

; 71   : 	}
; 72   : 
; 73   : 	// Check dump volume is located on the system drive
; 74   : 	status = SendDeviceIoControlRequest (filterExtension->DeviceObject, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0, &storageDeviceNumber, sizeof (storageDeviceNumber));

  00102	6a 0c		 push	 12			; 0000000cH
  00104	8d 45 ec	 lea	 eax, DWORD PTR _storageDeviceNumber$[ebp]
  00107	50		 push	 eax
  00108	6a 00		 push	 0
  0010a	6a 00		 push	 0
  0010c	68 80 10 2d 00	 push	 2953344			; 002d1080H
  00111	8b 4d 08	 mov	 ecx, DWORD PTR _filterExtension$[ebp]
  00114	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00117	52		 push	 edx
  00118	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  0011d	89 45 b8	 mov	 DWORD PTR _status$[ebp], eax

; 75   : 	if (!NT_SUCCESS (status))

  00120	83 7d b8 00	 cmp	 DWORD PTR _status$[ebp], 0
  00124	7d 05		 jge	 SHORT $LN8@DumpFilter

; 76   : 		goto err;

  00126	e9 60 01 00 00	 jmp	 $err$27801
$LN8@DumpFilter:

; 77   : 
; 78   : 	if (!BootDriveFilterExtension->SystemStorageDeviceNumberValid)

  0012b	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  00130	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  00134	75 0c		 jne	 SHORT $LN7@DumpFilter

; 79   : 	{
; 80   : 		status = STATUS_INVALID_PARAMETER;

  00136	c7 45 b8 0d 00
	00 c0		 mov	 DWORD PTR _status$[ebp], -1073741811 ; c000000dH

; 81   : 		goto err;

  0013d	e9 49 01 00 00	 jmp	 $err$27801
$LN7@DumpFilter:

; 82   : 	}
; 83   : 
; 84   : 	if (storageDeviceNumber.DeviceNumber != BootDriveFilterExtension->SystemStorageDeviceNumber)

  00142	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _BootDriveFilterExtension
  00148	8b 55 f0	 mov	 edx, DWORD PTR _storageDeviceNumber$[ebp+4]
  0014b	3b 51 24	 cmp	 edx, DWORD PTR [ecx+36]
  0014e	74 0c		 je	 SHORT $LN6@DumpFilter

; 85   : 	{
; 86   : 		status = STATUS_ACCESS_DENIED;

  00150	c7 45 b8 22 00
	00 c0		 mov	 DWORD PTR _status$[ebp], -1073741790 ; c0000022H

; 87   : 		goto err;

  00157	e9 2f 01 00 00	 jmp	 $err$27801
$LN6@DumpFilter:

; 88   : 	}
; 89   : 
; 90   : 	// Check dump volume is located within the scope of system encryption
; 91   : 	status = SendDeviceIoControlRequest (filterExtension->DeviceObject, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0, &partitionInfo, sizeof (partitionInfo));

  0015c	6a 20		 push	 32			; 00000020H
  0015e	8d 45 c8	 lea	 eax, DWORD PTR _partitionInfo$[ebp]
  00161	50		 push	 eax
  00162	6a 00		 push	 0
  00164	6a 00		 push	 0
  00166	68 04 40 07 00	 push	 475140			; 00074004H
  0016b	8b 4d 08	 mov	 ecx, DWORD PTR _filterExtension$[ebp]
  0016e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00171	52		 push	 edx
  00172	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  00177	89 45 b8	 mov	 DWORD PTR _status$[ebp], eax

; 92   : 	if (!NT_SUCCESS (status))

  0017a	83 7d b8 00	 cmp	 DWORD PTR _status$[ebp], 0
  0017e	7d 05		 jge	 SHORT $LN5@DumpFilter

; 93   : 		goto err;

  00180	e9 06 01 00 00	 jmp	 $err$27801
$LN5@DumpFilter:

; 94   : 
; 95   : 	DumpPartitionOffset = partitionInfo.StartingOffset;

  00185	8b 45 c8	 mov	 eax, DWORD PTR _partitionInfo$[ebp]
  00188	a3 00 00 00 00	 mov	 DWORD PTR _DumpPartitionOffset, eax
  0018d	8b 4d cc	 mov	 ecx, DWORD PTR _partitionInfo$[ebp+4]
  00190	89 0d 04 00 00
	00		 mov	 DWORD PTR _DumpPartitionOffset+4, ecx

; 96   : 
; 97   : 	if (DumpPartitionOffset.QuadPart < BootDriveFilterExtension->ConfiguredEncryptedAreaStart
; 98   : 		|| DumpPartitionOffset.QuadPart > BootDriveFilterExtension->ConfiguredEncryptedAreaEnd)

  00196	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _BootDriveFilterExtension
  0019c	89 55 b0	 mov	 DWORD PTR tv201[ebp], edx
  0019f	8b 45 b0	 mov	 eax, DWORD PTR tv201[ebp]
  001a2	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _DumpPartitionOffset+4
  001a8	3b 48 34	 cmp	 ecx, DWORD PTR [eax+52]
  001ab	7c 35		 jl	 SHORT $LN3@DumpFilter
  001ad	7f 0d		 jg	 SHORT $LN18@DumpFilter
  001af	8b 55 b0	 mov	 edx, DWORD PTR tv201[ebp]
  001b2	a1 00 00 00 00	 mov	 eax, DWORD PTR _DumpPartitionOffset
  001b7	3b 42 30	 cmp	 eax, DWORD PTR [edx+48]
  001ba	72 26		 jb	 SHORT $LN3@DumpFilter
$LN18@DumpFilter:
  001bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _BootDriveFilterExtension
  001c2	89 4d ac	 mov	 DWORD PTR tv209[ebp], ecx
  001c5	8b 55 ac	 mov	 edx, DWORD PTR tv209[ebp]
  001c8	a1 04 00 00 00	 mov	 eax, DWORD PTR _DumpPartitionOffset+4
  001cd	3b 42 3c	 cmp	 eax, DWORD PTR [edx+60]
  001d0	7c 1c		 jl	 SHORT $LN4@DumpFilter
  001d2	7f 0e		 jg	 SHORT $LN3@DumpFilter
  001d4	8b 4d ac	 mov	 ecx, DWORD PTR tv209[ebp]
  001d7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _DumpPartitionOffset
  001dd	3b 51 38	 cmp	 edx, DWORD PTR [ecx+56]
  001e0	76 0c		 jbe	 SHORT $LN4@DumpFilter
$LN3@DumpFilter:

; 99   : 	{
; 100  : 		status = STATUS_ACCESS_DENIED;

  001e2	c7 45 b8 22 00
	00 c0		 mov	 DWORD PTR _status$[ebp], -1073741790 ; c0000022H

; 101  : 		goto err;

  001e9	e9 9d 00 00 00	 jmp	 $err$27801
$LN4@DumpFilter:

; 102  : 	}
; 103  : 
; 104  : 	// Allocate buffer for encryption
; 105  : 	if (filterInitData->MaxPagesPerWrite == 0)

  001ee	8b 45 0c	 mov	 eax, DWORD PTR _filterInitData$[ebp]
  001f1	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  001f5	75 0c		 jne	 SHORT $LN2@DumpFilter

; 106  : 	{
; 107  : 		status = STATUS_INVALID_PARAMETER;

  001f7	c7 45 b8 0d 00
	00 c0		 mov	 DWORD PTR _status$[ebp], -1073741811 ; c000000dH

; 108  : 		goto err;

  001fe	e9 88 00 00 00	 jmp	 $err$27801
$LN2@DumpFilter:

; 109  : 	}
; 110  : 
; 111  : 	WriteFilterBufferSize = filterInitData->MaxPagesPerWrite * PAGE_SIZE;

  00203	8b 4d 0c	 mov	 ecx, DWORD PTR _filterInitData$[ebp]
  00206	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00209	c1 e2 0c	 shl	 edx, 12			; 0000000cH
  0020c	89 15 00 00 00
	00		 mov	 DWORD PTR _WriteFilterBufferSize, edx

; 112  : 
; 113  : #ifdef _WIN64
; 114  : 	highestAcceptableWriteBufferAddr.QuadPart = 0x7FFffffFFFFLL;
; 115  : #else
; 116  : 	highestAcceptableWriteBufferAddr.QuadPart = 0xffffFFFFLL;

  00212	c7 45 c0 ff ff
	ff ff		 mov	 DWORD PTR _highestAcceptableWriteBufferAddr$[ebp], -1
  00219	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _highestAcceptableWriteBufferAddr$[ebp+4], 0

; 117  : #endif
; 118  : 
; 119  : 	WriteFilterBuffer = MmAllocateContiguousMemory (WriteFilterBufferSize, highestAcceptableWriteBufferAddr);

  00220	8b 45 c4	 mov	 eax, DWORD PTR _highestAcceptableWriteBufferAddr$[ebp+4]
  00223	50		 push	 eax
  00224	8b 4d c0	 mov	 ecx, DWORD PTR _highestAcceptableWriteBufferAddr$[ebp]
  00227	51		 push	 ecx
  00228	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WriteFilterBufferSize
  0022e	52		 push	 edx
  0022f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmAllocateContiguousMemory@12
  00235	a3 00 00 00 00	 mov	 DWORD PTR _WriteFilterBuffer, eax

; 120  : 	if (!WriteFilterBuffer)

  0023a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _WriteFilterBuffer, 0
  00241	75 09		 jne	 SHORT $LN1@DumpFilter

; 121  : 	{
; 122  : 		status = STATUS_INSUFFICIENT_RESOURCES;

  00243	c7 45 b8 9a 00
	00 c0		 mov	 DWORD PTR _status$[ebp], -1073741670 ; c000009aH

; 123  : 		goto err;

  0024a	eb 3f		 jmp	 SHORT $err$27801
$LN1@DumpFilter:

; 124  : 	}
; 125  : 
; 126  : 	filterInitData->DumpStart = DumpFilterStart;

  0024c	8b 45 0c	 mov	 eax, DWORD PTR _filterInitData$[ebp]
  0024f	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _DumpFilterStart@4

; 127  : 	filterInitData->DumpWrite = DumpFilterWrite;

  00256	8b 4d 0c	 mov	 ecx, DWORD PTR _filterInitData$[ebp]
  00259	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], OFFSET _DumpFilterWrite@12

; 128  : 	filterInitData->DumpFinish = DumpFilterFinish;

  00260	8b 55 0c	 mov	 edx, DWORD PTR _filterInitData$[ebp]
  00263	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], OFFSET _DumpFilterFinish@4

; 129  : 	filterInitData->DumpUnload = DumpFilterUnload;

  0026a	8b 45 0c	 mov	 eax, DWORD PTR _filterInitData$[ebp]
  0026d	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], OFFSET _DumpFilterUnload@4

; 130  : 
; 131  : 	Dump ("Dump filter loaded type=%d\n", filterExtension->DumpType);

  00274	8b 4d 08	 mov	 ecx, DWORD PTR _filterExtension$[ebp]
  00277	8b 11		 mov	 edx, DWORD PTR [ecx]
  00279	52		 push	 edx
  0027a	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@NIHDEFIH@Dump?5filter?5loaded?5type?$DN?$CFd?6?$AA@FNODOBFM@
  0027f	e8 00 00 00 00	 call	 _DbgPrint
  00284	83 c4 08	 add	 esp, 8

; 132  : 	return STATUS_SUCCESS;

  00287	33 c0		 xor	 eax, eax
  00289	eb 14		 jmp	 SHORT $LN15@DumpFilter
$err$27801:

; 133  : 
; 134  : err:
; 135  : 	Dump ("DumpFilterEntry error %x\n", status);

  0028b	8b 45 b8	 mov	 eax, DWORD PTR _status$[ebp]
  0028e	50		 push	 eax
  0028f	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@MPDBPBLL@DumpFilterEntry?5error?5?$CFx?6?$AA@FNODOBFM@
  00294	e8 00 00 00 00	 call	 _DbgPrint
  00299	83 c4 08	 add	 esp, 8

; 136  : 	return status;

  0029c	8b 45 b8	 mov	 eax, DWORD PTR _status$[ebp]
$LN15@DumpFilter:

; 137  : }

  0029f	8b e5		 mov	 esp, ebp
  002a1	5d		 pop	 ebp
  002a2	c2 08 00	 ret	 8
_DumpFilterEntry@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@IKOJIFKO@DumpFilterStart?5type?$DN?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp__KeBugCheckEx@20:PROC
;	COMDAT ??_C@_0BJ@IKOJIFKO@DumpFilterStart?5type?$DN?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BJ@IKOJIFKO@DumpFilterStart?5type?$DN?$CFd?6?$AA@FNODOBFM@ DB 'Dum'
	DB	'pFilterStart type=%d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _DumpFilterStart@4
_TEXT	SEGMENT
tv79 = -4						; size = 4
_filterExtension$ = 8					; size = 4
_DumpFilterStart@4 PROC					; COMDAT

; 141  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 142  : 	Dump ("DumpFilterStart type=%d\n", filterExtension->DumpType);

  00006	8b 45 08	 mov	 eax, DWORD PTR _filterExtension$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	51		 push	 ecx
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@IKOJIFKO@DumpFilterStart?5type?$DN?$CFd?6?$AA@FNODOBFM@
  00011	e8 00 00 00 00	 call	 _DbgPrint
  00016	83 c4 08	 add	 esp, 8

; 143  : 
; 144  : 	if (BootDriveFilterExtension->MagicNumber != TC_BOOT_DRIVE_FILTER_EXTENSION_MAGIC_NUMBER)

  00019	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _BootDriveFilterExtension
  0001f	89 55 fc	 mov	 DWORD PTR tv79[ebp], edx
  00022	8b 45 fc	 mov	 eax, DWORD PTR tv79[ebp]
  00025	81 78 10 54 58
	45 42		 cmp	 DWORD PTR [eax+16], 1111840852 ; 42455854H
  0002c	75 0c		 jne	 SHORT $LN4@DumpFilter@2
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR tv79[ebp]
  00031	81 79 14 45 55
	52 54		 cmp	 DWORD PTR [ecx+20], 1414681925 ; 54525545H
  00038	74 19		 je	 SHORT $LN1@DumpFilter@2
$LN4@DumpFilter@2:

; 145  : 		TC_BUG_CHECK (STATUS_CRC_ERROR);

  0003a	68 43 54 00 00	 push	 21571			; 00005443H
  0003f	6a 00		 push	 0
  00041	68 3f 00 00 c0	 push	 -1073741761		; c000003fH
  00046	68 91 00 00 00	 push	 145			; 00000091H
  0004b	6a 29		 push	 41			; 00000029H
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN1@DumpFilter@2:

; 146  : 
; 147  : 	return BootDriveFilterExtension->DriveMounted ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;

  00053	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _BootDriveFilterExtension
  00059	8b 82 30 02 00
	00		 mov	 eax, DWORD PTR [edx+560]
  0005f	f7 d8		 neg	 eax
  00061	1b c0		 sbb	 eax, eax
  00063	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  00068	05 01 00 00 c0	 add	 eax, -1073741823	; c0000001H
$LN3@DumpFilter@2:

; 148  : }

  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
_DumpFilterStart@4 ENDP
_TEXT	ENDS
EXTRN	__imp__MmBuildMdlForNonPagedPool@4:PROC
EXTRN	_EncryptDataUnitsCurrentThread@20:PROC
EXTRN	_GetIntersection@36:PROC
EXTRN	__imp__MmMapLockedPagesSpecifyCache@24:PROC
EXTRN	__aulldiv:PROC
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
;	COMDAT _DumpFilterWrite@12
_TEXT	SEGMENT
tv150 = -76						; size = 4
tv247 = -72						; size = 8
tv234 = -64						; size = 8
tv224 = -56						; size = 4
tv218 = -52						; size = 4
_dataUnit$27885 = -48					; size = 8
_writeBuffer$ = -36					; size = 4
_offset$ = -32						; size = 8
_dataLength$ = -20					; size = 4
_intersectStart$ = -16					; size = 8
_origMdlFlags$ = -8					; size = 2
_intersectLength$ = -4					; size = 4
_filterExtension$ = 8					; size = 4
_diskWriteOffset$ = 12					; size = 4
_writeMdl$ = 16						; size = 4
_DumpFilterWrite@12 PROC				; COMDAT

; 152  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 4c	 sub	 esp, 76			; 0000004cH

; 153  : 	ULONG dataLength = MmGetMdlByteCount (writeMdl);

  00008	8b 45 10	 mov	 eax, DWORD PTR _writeMdl$[ebp]
  0000b	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0000e	89 4d ec	 mov	 DWORD PTR _dataLength$[ebp], ecx

; 154  : 	uint64 offset = DumpPartitionOffset.QuadPart + diskWriteOffset->QuadPart;

  00011	8b 55 0c	 mov	 edx, DWORD PTR _diskWriteOffset$[ebp]
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR _DumpPartitionOffset
  00019	03 02		 add	 eax, DWORD PTR [edx]
  0001b	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _DumpPartitionOffset+4
  00021	13 4a 04	 adc	 ecx, DWORD PTR [edx+4]
  00024	89 45 e0	 mov	 DWORD PTR _offset$[ebp], eax
  00027	89 4d e4	 mov	 DWORD PTR _offset$[ebp+4], ecx

; 155  : 	uint64 intersectStart;
; 156  : 	uint32 intersectLength;
; 157  : 	PVOID writeBuffer;
; 158  : 	CSHORT origMdlFlags;
; 159  : 
; 160  : 	if (BootDriveFilterExtension->MagicNumber != TC_BOOT_DRIVE_FILTER_EXTENSION_MAGIC_NUMBER)

  0002a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _BootDriveFilterExtension
  00030	89 55 cc	 mov	 DWORD PTR tv218[ebp], edx
  00033	8b 45 cc	 mov	 eax, DWORD PTR tv218[ebp]
  00036	81 78 10 54 58
	45 42		 cmp	 DWORD PTR [eax+16], 1111840852 ; 42455854H
  0003d	75 0c		 jne	 SHORT $LN15@DumpFilter@3
  0003f	8b 4d cc	 mov	 ecx, DWORD PTR tv218[ebp]
  00042	81 79 14 45 55
	52 54		 cmp	 DWORD PTR [ecx+20], 1414681925 ; 54525545H
  00049	74 19		 je	 SHORT $LN10@DumpFilter@3
$LN15@DumpFilter@3:

; 161  : 		TC_BUG_CHECK (STATUS_CRC_ERROR);

  0004b	68 43 54 00 00	 push	 21571			; 00005443H
  00050	6a 00		 push	 0
  00052	68 3f 00 00 c0	 push	 -1073741761		; c000003fH
  00057	68 a1 00 00 00	 push	 161			; 000000a1H
  0005c	6a 29		 push	 41			; 00000029H
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN10@DumpFilter@3:

; 162  : 
; 163  : 	if (BootDriveFilterExtension->Queue.EncryptedAreaEndUpdatePending)	// Hibernation should always abort the setup thread

  00064	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _BootDriveFilterExtension
  0006a	83 ba a0 00 00
	00 00		 cmp	 DWORD PTR [edx+160], 0
  00071	74 19		 je	 SHORT $LN9@DumpFilter@3

; 164  : 		TC_BUG_CHECK (STATUS_INVALID_PARAMETER);

  00073	68 43 54 00 00	 push	 21571			; 00005443H
  00078	6a 00		 push	 0
  0007a	68 0d 00 00 c0	 push	 -1073741811		; c000000dH
  0007f	68 a4 00 00 00	 push	 164			; 000000a4H
  00084	6a 29		 push	 41			; 00000029H
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN9@DumpFilter@3:

; 165  : 
; 166  : 	if (BootDriveFilterExtension->Queue.EncryptedAreaStart == -1 || BootDriveFilterExtension->Queue.EncryptedAreaEnd == -1)

  0008c	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  00091	89 45 c8	 mov	 DWORD PTR tv224[ebp], eax
  00094	8b 4d c8	 mov	 ecx, DWORD PTR tv224[ebp]
  00097	8b 55 c8	 mov	 edx, DWORD PTR tv224[ebp]
  0009a	8b 81 90 00 00
	00		 mov	 eax, DWORD PTR [ecx+144]
  000a0	23 82 94 00 00
	00		 and	 eax, DWORD PTR [edx+148]
  000a6	83 f8 ff	 cmp	 eax, -1
  000a9	74 23		 je	 SHORT $LN7@DumpFilter@3
  000ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _BootDriveFilterExtension
  000b1	8b 91 98 00 00
	00		 mov	 edx, DWORD PTR [ecx+152]
  000b7	8b 81 9c 00 00
	00		 mov	 eax, DWORD PTR [ecx+156]
  000bd	89 55 c0	 mov	 DWORD PTR tv234[ebp], edx
  000c0	89 45 c4	 mov	 DWORD PTR tv234[ebp+4], eax
  000c3	8b 4d c0	 mov	 ecx, DWORD PTR tv234[ebp]
  000c6	23 4d c4	 and	 ecx, DWORD PTR tv234[ebp+4]
  000c9	83 f9 ff	 cmp	 ecx, -1
  000cc	75 07		 jne	 SHORT $LN8@DumpFilter@3
$LN7@DumpFilter@3:

; 167  : 		return STATUS_SUCCESS;

  000ce	33 c0		 xor	 eax, eax
  000d0	e9 5c 02 00 00	 jmp	 $LN12@DumpFilter@3
$LN8@DumpFilter@3:

; 168  : 
; 169  : 	if (dataLength > WriteFilterBufferSize)

  000d5	8b 55 ec	 mov	 edx, DWORD PTR _dataLength$[ebp]
  000d8	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WriteFilterBufferSize
  000de	76 19		 jbe	 SHORT $LN6@DumpFilter@3

; 170  : 		TC_BUG_CHECK (STATUS_BUFFER_OVERFLOW);	// Bug check is required as returning an error does not prevent data from being written to disk

  000e0	68 43 54 00 00	 push	 21571			; 00005443H
  000e5	6a 00		 push	 0
  000e7	68 05 00 00 80	 push	 -2147483643		; 80000005H
  000ec	68 aa 00 00 00	 push	 170			; 000000aaH
  000f1	6a 29		 push	 41			; 00000029H
  000f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN6@DumpFilter@3:

; 171  : 
; 172  : 	if ((dataLength & (ENCRYPTION_DATA_UNIT_SIZE - 1)) != 0)

  000f9	8b 45 ec	 mov	 eax, DWORD PTR _dataLength$[ebp]
  000fc	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  00101	74 19		 je	 SHORT $LN5@DumpFilter@3

; 173  : 		TC_BUG_CHECK (STATUS_INVALID_PARAMETER);

  00103	68 43 54 00 00	 push	 21571			; 00005443H
  00108	6a 00		 push	 0
  0010a	68 0d 00 00 c0	 push	 -1073741811		; c000000dH
  0010f	68 ad 00 00 00	 push	 173			; 000000adH
  00114	6a 29		 push	 41			; 00000029H
  00116	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN5@DumpFilter@3:

; 174  : 
; 175  : 	if ((offset & (ENCRYPTION_DATA_UNIT_SIZE - 1)) != 0)

  0011c	8b 4d e0	 mov	 ecx, DWORD PTR _offset$[ebp]
  0011f	81 e1 ff 01 00
	00		 and	 ecx, 511		; 000001ffH
  00125	8b 55 e4	 mov	 edx, DWORD PTR _offset$[ebp+4]
  00128	83 e2 00	 and	 edx, 0
  0012b	89 4d b8	 mov	 DWORD PTR tv247[ebp], ecx
  0012e	89 55 bc	 mov	 DWORD PTR tv247[ebp+4], edx
  00131	8b 45 b8	 mov	 eax, DWORD PTR tv247[ebp]
  00134	0b 45 bc	 or	 eax, DWORD PTR tv247[ebp+4]
  00137	74 19		 je	 SHORT $LN4@DumpFilter@3

; 176  : 		TC_BUG_CHECK (STATUS_INVALID_PARAMETER);

  00139	68 43 54 00 00	 push	 21571			; 00005443H
  0013e	6a 00		 push	 0
  00140	68 0d 00 00 c0	 push	 -1073741811		; c000000dH
  00145	68 b0 00 00 00	 push	 176			; 000000b0H
  0014a	6a 29		 push	 41			; 00000029H
  0014c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN4@DumpFilter@3:

; 177  : 
; 178  : 	writeBuffer = MmGetSystemAddressForMdlSafe (writeMdl, HighPagePriority);

  00152	8b 4d 10	 mov	 ecx, DWORD PTR _writeMdl$[ebp]
  00155	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00159	83 e2 05	 and	 edx, 5
  0015c	74 0b		 je	 SHORT $LN13@DumpFilter@3
  0015e	8b 45 10	 mov	 eax, DWORD PTR _writeMdl$[ebp]
  00161	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00164	89 4d b4	 mov	 DWORD PTR tv150[ebp], ecx
  00167	eb 17		 jmp	 SHORT $LN14@DumpFilter@3
$LN13@DumpFilter@3:
  00169	6a 20		 push	 32			; 00000020H
  0016b	6a 00		 push	 0
  0016d	6a 00		 push	 0
  0016f	6a 01		 push	 1
  00171	6a 00		 push	 0
  00173	8b 55 10	 mov	 edx, DWORD PTR _writeMdl$[ebp]
  00176	52		 push	 edx
  00177	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmMapLockedPagesSpecifyCache@24
  0017d	89 45 b4	 mov	 DWORD PTR tv150[ebp], eax
$LN14@DumpFilter@3:
  00180	8b 45 b4	 mov	 eax, DWORD PTR tv150[ebp]
  00183	89 45 dc	 mov	 DWORD PTR _writeBuffer$[ebp], eax

; 179  : 	if (!writeBuffer)

  00186	83 7d dc 00	 cmp	 DWORD PTR _writeBuffer$[ebp], 0
  0018a	75 19		 jne	 SHORT $LN3@DumpFilter@3

; 180  : 		TC_BUG_CHECK (STATUS_INSUFFICIENT_RESOURCES);

  0018c	68 43 54 00 00	 push	 21571			; 00005443H
  00191	6a 00		 push	 0
  00193	68 9a 00 00 c0	 push	 -1073741670		; c000009aH
  00198	68 b4 00 00 00	 push	 180			; 000000b4H
  0019d	6a 29		 push	 41			; 00000029H
  0019f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN3@DumpFilter@3:

; 181  : 
; 182  : 	memcpy (WriteFilterBuffer, writeBuffer, dataLength);

  001a5	8b 4d ec	 mov	 ecx, DWORD PTR _dataLength$[ebp]
  001a8	51		 push	 ecx
  001a9	8b 55 dc	 mov	 edx, DWORD PTR _writeBuffer$[ebp]
  001ac	52		 push	 edx
  001ad	a1 00 00 00 00	 mov	 eax, DWORD PTR _WriteFilterBuffer
  001b2	50		 push	 eax
  001b3	e8 00 00 00 00	 call	 _memcpy
  001b8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 183  : 
; 184  : 	GetIntersection (offset,
; 185  : 		dataLength,
; 186  : 		BootDriveFilterExtension->Queue.EncryptedAreaStart,
; 187  : 		BootDriveFilterExtension->Queue.EncryptedAreaEnd,
; 188  : 		&intersectStart,
; 189  : 		&intersectLength);

  001bb	8d 4d fc	 lea	 ecx, DWORD PTR _intersectLength$[ebp]
  001be	51		 push	 ecx
  001bf	8d 55 f0	 lea	 edx, DWORD PTR _intersectStart$[ebp]
  001c2	52		 push	 edx
  001c3	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  001c8	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [eax+156]
  001ce	51		 push	 ecx
  001cf	8b 90 98 00 00
	00		 mov	 edx, DWORD PTR [eax+152]
  001d5	52		 push	 edx
  001d6	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  001db	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [eax+148]
  001e1	51		 push	 ecx
  001e2	8b 90 90 00 00
	00		 mov	 edx, DWORD PTR [eax+144]
  001e8	52		 push	 edx
  001e9	8b 45 ec	 mov	 eax, DWORD PTR _dataLength$[ebp]
  001ec	50		 push	 eax
  001ed	8b 4d e4	 mov	 ecx, DWORD PTR _offset$[ebp+4]
  001f0	51		 push	 ecx
  001f1	8b 55 e0	 mov	 edx, DWORD PTR _offset$[ebp]
  001f4	52		 push	 edx
  001f5	e8 00 00 00 00	 call	 _GetIntersection@36

; 190  : 
; 191  : 	if (intersectLength > 0)

  001fa	83 7d fc 00	 cmp	 DWORD PTR _intersectLength$[ebp], 0
  001fe	0f 86 99 00 00
	00		 jbe	 $LN2@DumpFilter@3

; 192  : 	{
; 193  : 		UINT64_STRUCT dataUnit;
; 194  : 		dataUnit.Value = intersectStart / ENCRYPTION_DATA_UNIT_SIZE;

  00204	6a 00		 push	 0
  00206	68 00 02 00 00	 push	 512			; 00000200H
  0020b	8b 45 f4	 mov	 eax, DWORD PTR _intersectStart$[ebp+4]
  0020e	50		 push	 eax
  0020f	8b 4d f0	 mov	 ecx, DWORD PTR _intersectStart$[ebp]
  00212	51		 push	 ecx
  00213	e8 00 00 00 00	 call	 __aulldiv
  00218	89 45 d0	 mov	 DWORD PTR _dataUnit$27885[ebp], eax
  0021b	89 55 d4	 mov	 DWORD PTR _dataUnit$27885[ebp+4], edx

; 195  : 
; 196  : 		if (BootDriveFilterExtension->Queue.RemapEncryptedArea)

  0021e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _BootDriveFilterExtension
  00224	83 ba a4 00 00
	00 00		 cmp	 DWORD PTR [edx+164], 0
  0022b	74 40		 je	 SHORT $LN1@DumpFilter@3

; 197  : 		{
; 198  : 			diskWriteOffset->QuadPart += BootDriveFilterExtension->Queue.RemappedAreaOffset;

  0022d	8b 45 0c	 mov	 eax, DWORD PTR _diskWriteOffset$[ebp]
  00230	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _BootDriveFilterExtension
  00236	8b 10		 mov	 edx, DWORD PTR [eax]
  00238	03 91 a8 00 00
	00		 add	 edx, DWORD PTR [ecx+168]
  0023e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00241	13 81 ac 00 00
	00		 adc	 eax, DWORD PTR [ecx+172]
  00247	8b 4d 0c	 mov	 ecx, DWORD PTR _diskWriteOffset$[ebp]
  0024a	89 11		 mov	 DWORD PTR [ecx], edx
  0024c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 199  : 			dataUnit.Value += BootDriveFilterExtension->Queue.RemappedAreaDataUnitOffset;

  0024f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _BootDriveFilterExtension
  00255	8b 45 d0	 mov	 eax, DWORD PTR _dataUnit$27885[ebp]
  00258	03 82 b0 00 00
	00		 add	 eax, DWORD PTR [edx+176]
  0025e	8b 4d d4	 mov	 ecx, DWORD PTR _dataUnit$27885[ebp+4]
  00261	13 8a b4 00 00
	00		 adc	 ecx, DWORD PTR [edx+180]
  00267	89 45 d0	 mov	 DWORD PTR _dataUnit$27885[ebp], eax
  0026a	89 4d d4	 mov	 DWORD PTR _dataUnit$27885[ebp+4], ecx
$LN1@DumpFilter@3:

; 200  : 		}
; 201  : 
; 202  : 		EncryptDataUnitsCurrentThread (WriteFilterBuffer + (intersectStart - offset),
; 203  : 			&dataUnit,
; 204  : 			intersectLength / ENCRYPTION_DATA_UNIT_SIZE,
; 205  : 			BootDriveFilterExtension->Queue.CryptoInfo);

  0026d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _BootDriveFilterExtension
  00273	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  00276	50		 push	 eax
  00277	8b 4d fc	 mov	 ecx, DWORD PTR _intersectLength$[ebp]
  0027a	c1 e9 09	 shr	 ecx, 9
  0027d	33 d2		 xor	 edx, edx
  0027f	52		 push	 edx
  00280	51		 push	 ecx
  00281	8d 45 d0	 lea	 eax, DWORD PTR _dataUnit$27885[ebp]
  00284	50		 push	 eax
  00285	8b 4d f0	 mov	 ecx, DWORD PTR _intersectStart$[ebp]
  00288	2b 4d e0	 sub	 ecx, DWORD PTR _offset$[ebp]
  0028b	8b 55 f4	 mov	 edx, DWORD PTR _intersectStart$[ebp+4]
  0028e	1b 55 e4	 sbb	 edx, DWORD PTR _offset$[ebp+4]
  00291	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _WriteFilterBuffer
  00297	51		 push	 ecx
  00298	e8 00 00 00 00	 call	 _EncryptDataUnitsCurrentThread@20
$LN2@DumpFilter@3:

; 206  : 	}
; 207  : 
; 208  : 	origMdlFlags = writeMdl->MdlFlags;

  0029d	8b 45 10	 mov	 eax, DWORD PTR _writeMdl$[ebp]
  002a0	66 8b 48 06	 mov	 cx, WORD PTR [eax+6]
  002a4	66 89 4d f8	 mov	 WORD PTR _origMdlFlags$[ebp], cx

; 209  : 
; 210  : 	MmInitializeMdl (writeMdl, WriteFilterBuffer, dataLength);

  002a8	8b 55 10	 mov	 edx, DWORD PTR _writeMdl$[ebp]
  002ab	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  002b1	8b 45 ec	 mov	 eax, DWORD PTR _dataLength$[ebp]
  002b4	c1 e8 0c	 shr	 eax, 12			; 0000000cH
  002b7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WriteFilterBuffer
  002bd	81 e1 ff 0f 00
	00		 and	 ecx, 4095		; 00000fffH
  002c3	8b 55 ec	 mov	 edx, DWORD PTR _dataLength$[ebp]
  002c6	81 e2 ff 0f 00
	00		 and	 edx, 4095		; 00000fffH
  002cc	8d 8c 11 ff 0f
	00 00		 lea	 ecx, DWORD PTR [ecx+edx+4095]
  002d3	c1 e9 0c	 shr	 ecx, 12			; 0000000cH
  002d6	03 c1		 add	 eax, ecx
  002d8	8d 14 85 1c 00
	00 00		 lea	 edx, DWORD PTR [eax*4+28]
  002df	8b 45 10	 mov	 eax, DWORD PTR _writeMdl$[ebp]
  002e2	66 89 50 04	 mov	 WORD PTR [eax+4], dx
  002e6	33 c9		 xor	 ecx, ecx
  002e8	8b 55 10	 mov	 edx, DWORD PTR _writeMdl$[ebp]
  002eb	66 89 4a 06	 mov	 WORD PTR [edx+6], cx
  002ef	a1 00 00 00 00	 mov	 eax, DWORD PTR _WriteFilterBuffer
  002f4	25 00 f0 ff ff	 and	 eax, -4096		; fffff000H
  002f9	8b 4d 10	 mov	 ecx, DWORD PTR _writeMdl$[ebp]
  002fc	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  002ff	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WriteFilterBuffer
  00305	81 e2 ff 0f 00
	00		 and	 edx, 4095		; 00000fffH
  0030b	8b 45 10	 mov	 eax, DWORD PTR _writeMdl$[ebp]
  0030e	89 50 18	 mov	 DWORD PTR [eax+24], edx
  00311	8b 4d 10	 mov	 ecx, DWORD PTR _writeMdl$[ebp]
  00314	8b 55 ec	 mov	 edx, DWORD PTR _dataLength$[ebp]
  00317	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 211  : 	MmBuildMdlForNonPagedPool (writeMdl);

  0031a	8b 45 10	 mov	 eax, DWORD PTR _writeMdl$[ebp]
  0031d	50		 push	 eax
  0031e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmBuildMdlForNonPagedPool@4

; 212  : 
; 213  : 	// Instead of using MmGetSystemAddressForMdlSafe(), some buggy custom storage drivers may directly test MDL_MAPPED_TO_SYSTEM_VA flag,
; 214  : 	// disregarding the fact that other MDL flags may be set by the system or a dump filter (e.g. MDL_SOURCE_IS_NONPAGED_POOL flag only).
; 215  : 	// Therefore, to work around this issue, the original flags will be restored even if they do not match the new MDL.
; 216  : 	// MS BitLocker also uses this hack/workaround (it should be safe to use until the MDL structure is changed).
; 217  : 
; 218  : 	writeMdl->MdlFlags = origMdlFlags;

  00324	8b 4d 10	 mov	 ecx, DWORD PTR _writeMdl$[ebp]
  00327	66 8b 55 f8	 mov	 dx, WORD PTR _origMdlFlags$[ebp]
  0032b	66 89 51 06	 mov	 WORD PTR [ecx+6], dx

; 219  : 
; 220  : 	return STATUS_SUCCESS;

  0032f	33 c0		 xor	 eax, eax
$LN12@DumpFilter@3:

; 221  : }

  00331	8b e5		 mov	 esp, ebp
  00333	5d		 pop	 ebp
  00334	c2 0c 00	 ret	 12			; 0000000cH
_DumpFilterWrite@12 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@EIOFNLAN@DumpFilterFinish?5type?$DN?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0BK@EIOFNLAN@DumpFilterFinish?5type?$DN?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BK@EIOFNLAN@DumpFilterFinish?5type?$DN?$CFd?6?$AA@FNODOBFM@ DB 'Du'
	DB	'mpFilterFinish type=%d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _DumpFilterFinish@4
_TEXT	SEGMENT
_filterExtension$ = 8					; size = 4
_DumpFilterFinish@4 PROC				; COMDAT

; 225  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 226  : 	Dump ("DumpFilterFinish type=%d\n", filterExtension->DumpType);

  00005	8b 45 08	 mov	 eax, DWORD PTR _filterExtension$[ebp]
  00008	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000a	51		 push	 ecx
  0000b	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@EIOFNLAN@DumpFilterFinish?5type?$DN?$CFd?6?$AA@FNODOBFM@
  00010	e8 00 00 00 00	 call	 _DbgPrint
  00015	83 c4 08	 add	 esp, 8

; 227  : 
; 228  : 	return STATUS_SUCCESS;

  00018	33 c0		 xor	 eax, eax

; 229  : }

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
_DumpFilterFinish@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@LHLJKEKP@DumpFilterUnload?5type?$DN?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp__MmFreeContiguousMemory@4:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_0BK@LHLJKEKP@DumpFilterUnload?5type?$DN?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BK@LHLJKEKP@DumpFilterUnload?5type?$DN?$CFd?6?$AA@FNODOBFM@ DB 'Du'
	DB	'mpFilterUnload type=%d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _DumpFilterUnload@4
_TEXT	SEGMENT
_filterExtension$ = 8					; size = 4
_DumpFilterUnload@4 PROC				; COMDAT

; 233  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 234  : 	Dump ("DumpFilterUnload type=%d\n", filterExtension->DumpType);

  00005	8b 45 08	 mov	 eax, DWORD PTR _filterExtension$[ebp]
  00008	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000a	51		 push	 ecx
  0000b	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@LHLJKEKP@DumpFilterUnload?5type?$DN?$CFd?6?$AA@FNODOBFM@
  00010	e8 00 00 00 00	 call	 _DbgPrint
  00015	83 c4 08	 add	 esp, 8

; 235  : 
; 236  : 	if (WriteFilterBuffer)

  00018	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _WriteFilterBuffer, 0
  0001f	74 2e		 je	 SHORT $LN1@DumpFilter@4

; 237  : 	{
; 238  : 		memset (WriteFilterBuffer, 0, WriteFilterBufferSize);

  00021	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WriteFilterBufferSize
  00027	52		 push	 edx
  00028	6a 00		 push	 0
  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR _WriteFilterBuffer
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 _memset
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH

; 239  : 		MmFreeContiguousMemory (WriteFilterBuffer);

  00038	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WriteFilterBuffer
  0003e	51		 push	 ecx
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmFreeContiguousMemory@4

; 240  : 		WriteFilterBuffer = NULL;

  00045	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _WriteFilterBuffer, 0
$LN1@DumpFilter@4:

; 241  : 	}
; 242  : 
; 243  : 	return STATUS_SUCCESS;

  0004f	33 c0		 xor	 eax, eax

; 244  : }

  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
_DumpFilterUnload@4 ENDP
_TEXT	ENDS
END
