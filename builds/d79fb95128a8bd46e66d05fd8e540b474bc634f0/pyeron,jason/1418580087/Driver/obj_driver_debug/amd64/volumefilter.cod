; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	HiddenSysLeakProtectionCount
PUBLIC	??_C@_0BO@INEJHKOL@VolumeFilterAddDevice?5pdo?$DN?$CFp?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EL@KFIMJNPM@c?3?2home?2public?2desktop?2projects?2@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CC@FPKIEKIL@TC_IOCTL_DISK_IS_WRITABLE?5pdo?$DN?$CFp@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CD@BENKCDLN@IRP_MN_START_DEVICE?5volume?5pdo?$DN?$CF@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CE@GJODMOBD@IRP_MN_REMOVE_DEVICE?5volume?5pdo?$DN@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DL@GNELLIFI@?$CBExtension?9?$DObRootDevice?5?$CG?$CG?5Exten@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
HiddenSysLeakProtectionCount DD 01H DUP (?)
;	COMDAT ??_C@_0DL@GNELLIFI@?$CBExtension?9?$DObRootDevice?5?$CG?$CG?5Exten@FNODOBFM@
text$s	SEGMENT
??_C@_0DL@GNELLIFI@?$CBExtension?9?$DObRootDevice?5?$CG?$CG?5Exten@FNODOBFM@ DB '!'
	DB	'Extension->bRootDevice && Extension->IsVolumeFilterDevice', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CE@GJODMOBD@IRP_MN_REMOVE_DEVICE?5volume?5pdo?$DN@FNODOBFM@
text$s	SEGMENT
??_C@_0CE@GJODMOBD@IRP_MN_REMOVE_DEVICE?5volume?5pdo?$DN@FNODOBFM@ DB 'IR'
	DB	'P_MN_REMOVE_DEVICE volume pdo=%p', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CD@BENKCDLN@IRP_MN_START_DEVICE?5volume?5pdo?$DN?$CF@FNODOBFM@
text$s	SEGMENT
??_C@_0CD@BENKCDLN@IRP_MN_START_DEVICE?5volume?5pdo?$DN?$CF@FNODOBFM@ DB 'I'
	DB	'RP_MN_START_DEVICE volume pdo=%p', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CC@FPKIEKIL@TC_IOCTL_DISK_IS_WRITABLE?5pdo?$DN?$CFp@FNODOBFM@
text$s	SEGMENT
??_C@_0CC@FPKIEKIL@TC_IOCTL_DISK_IS_WRITABLE?5pdo?$DN?$CFp@FNODOBFM@ DB 'T'
	DB	'C_IOCTL_DISK_IS_WRITABLE pdo=%p', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EL@KFIMJNPM@c?3?2home?2public?2desktop?2projects?2@FNODOBFM@
text$s	SEGMENT
??_C@_0EL@KFIMJNPM@c?3?2home?2public?2desktop?2projects?2@FNODOBFM@ DB 'c'
	DB	':\home\public\desktop\projects\ciphershed.build\src\driver\vo'
	DB	'lumefilter.c', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BO@INEJHKOL@VolumeFilterAddDevice?5pdo?$DN?$CFp?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BO@INEJHKOL@VolumeFilterAddDevice?5pdo?$DN?$CFp?6?$AA@FNODOBFM@ DB 'V'
	DB	'olumeFilterAddDevice pdo=%p', 0aH, 00H	;  ?? ::FNODOBFM::`string'
PUBLIC	VolumeFilterAddDevice
;	COMDAT pdata
; File c:\home\public\desktop\projects\ciphershed.build\src\driver\volumefilter.c
pdata	SEGMENT
$pdata$VolumeFilterAddDevice DD imagerel $LN7
	DD	imagerel $LN7+422
	DD	imagerel $unwind$VolumeFilterAddDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$VolumeFilterAddDevice DD 020f01H
	DD	0700bb20fH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT VolumeFilterAddDevice
_TEXT	SEGMENT
Extension$ = 64
attachedDeviceObject$ = 72
status$ = 80
filterDeviceObject$ = 88
driverObject$ = 112
pdo$ = 120
VolumeFilterAddDevice PROC				; COMDAT

; 23   : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 24   : 	VolumeFilterExtension *Extension;
; 25   : 	NTSTATUS status;
; 26   : 	PDEVICE_OBJECT filterDeviceObject = NULL;

  0000f	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR filterDeviceObject$[rsp], 0

; 27   : 	PDEVICE_OBJECT attachedDeviceObject;
; 28   : 
; 29   : 	Dump ("VolumeFilterAddDevice pdo=%p\n", pdo);

  00018	48 8b 54 24 78	 mov	 rdx, QWORD PTR pdo$[rsp]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@INEJHKOL@VolumeFilterAddDevice?5pdo?$DN?$CFp?6?$AA@FNODOBFM@
  00024	e8 00 00 00 00	 call	 DbgPrint

; 30   : 
; 31   : 	attachedDeviceObject = IoGetAttachedDeviceReference (pdo);

  00029	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pdo$[rsp]
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetAttachedDeviceReference
  00034	48 89 44 24 48	 mov	 QWORD PTR attachedDeviceObject$[rsp], rax

; 32   : 	status = IoCreateDevice (driverObject, sizeof (VolumeFilterExtension), NULL, attachedDeviceObject->DeviceType, 0, FALSE, &filterDeviceObject);

  00039	48 8d 44 24 58	 lea	 rax, QWORD PTR filterDeviceObject$[rsp]
  0003e	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00043	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00048	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00050	48 8b 44 24 48	 mov	 rax, QWORD PTR attachedDeviceObject$[rsp]
  00055	44 8b 48 48	 mov	 r9d, DWORD PTR [rax+72]
  00059	45 33 c0	 xor	 r8d, r8d
  0005c	ba 40 03 00 00	 mov	 edx, 832		; 00000340H
  00061	48 8b 4c 24 70	 mov	 rcx, QWORD PTR driverObject$[rsp]
  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateDevice
  0006c	89 44 24 50	 mov	 DWORD PTR status$[rsp], eax

; 33   : 
; 34   : 	ObDereferenceObject (attachedDeviceObject);

  00070	48 8b 4c 24 48	 mov	 rcx, QWORD PTR attachedDeviceObject$[rsp]
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 35   : 
; 36   : 	if (!NT_SUCCESS (status))

  0007b	83 7c 24 50 00	 cmp	 DWORD PTR status$[rsp], 0
  00080	7d 0e		 jge	 SHORT $LN4@VolumeFilt

; 37   : 	{
; 38   : 		filterDeviceObject = NULL;

  00082	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR filterDeviceObject$[rsp], 0

; 39   : 		goto err;

  0008b	e9 de 00 00 00	 jmp	 $err$29390
$LN4@VolumeFilt:

; 40   : 	}
; 41   : 
; 42   : 	Extension = (VolumeFilterExtension *) filterDeviceObject->DeviceExtension;

  00090	48 8b 44 24 58	 mov	 rax, QWORD PTR filterDeviceObject$[rsp]
  00095	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00099	48 89 44 24 40	 mov	 QWORD PTR Extension$[rsp], rax

; 43   : 	memset (Extension, 0, sizeof (VolumeFilterExtension));

  0009e	48 8b 7c 24 40	 mov	 rdi, QWORD PTR Extension$[rsp]
  000a3	33 c0		 xor	 eax, eax
  000a5	b9 40 03 00 00	 mov	 ecx, 832		; 00000340H
  000aa	f3 aa		 rep stosb

; 44   : 
; 45   : 	Extension->LowerDeviceObject = IoAttachDeviceToDeviceStack (filterDeviceObject, pdo);  // IoAttachDeviceToDeviceStackSafe() is not required in AddDevice routine and is also unavailable on Windows 2000 SP4

  000ac	48 8b 54 24 78	 mov	 rdx, QWORD PTR pdo$[rsp]
  000b1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR filterDeviceObject$[rsp]
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAttachDeviceToDeviceStack
  000bc	48 8b d0	 mov	 rdx, rax
  000bf	48 8b 44 24 40	 mov	 rax, QWORD PTR Extension$[rsp]
  000c4	48 89 50 20	 mov	 QWORD PTR [rax+32], rdx

; 46   : 	if (!Extension->LowerDeviceObject)

  000c8	48 8b 44 24 40	 mov	 rax, QWORD PTR Extension$[rsp]
  000cd	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  000d2	75 0d		 jne	 SHORT $LN3@VolumeFilt

; 47   : 	{
; 48   : 		status = STATUS_DEVICE_REMOVED;

  000d4	c7 44 24 50 b6
	02 00 c0	 mov	 DWORD PTR status$[rsp], -1073741130 ; ffffffffc00002b6H

; 49   : 		goto err;

  000dc	e9 8d 00 00 00	 jmp	 $err$29390
$LN3@VolumeFilt:

; 50   : 	}
; 51   : 	
; 52   : 	Extension->IsVolumeFilterDevice = TRUE;

  000e1	48 8b 44 24 40	 mov	 rax, QWORD PTR Extension$[rsp]
  000e6	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [rax+12], 1

; 53   : 	Extension->DeviceObject = filterDeviceObject;

  000ed	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Extension$[rsp]
  000f2	48 8b 44 24 58	 mov	 rax, QWORD PTR filterDeviceObject$[rsp]
  000f7	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 54   : 	Extension->Pdo = pdo;

  000fb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Extension$[rsp]
  00100	48 8b 44 24 78	 mov	 rax, QWORD PTR pdo$[rsp]
  00105	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 55   : 
; 56   : 	IoInitializeRemoveLock (&Extension->Queue.RemoveLock, 'LRCT', 0, 0);

  00109	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Extension$[rsp]
  0010e	48 81 c1 f0 00
	00 00		 add	 rcx, 240		; 000000f0H
  00115	c7 44 24 20 78
	00 00 00	 mov	 DWORD PTR [rsp+32], 120	; 00000078H
  0011d	45 33 c9	 xor	 r9d, r9d
  00120	45 33 c0	 xor	 r8d, r8d
  00123	ba 54 43 52 4c	 mov	 edx, 1280459604		; 4c524354H
  00128	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoInitializeRemoveLockEx

; 57   : 
; 58   : 	filterDeviceObject->Flags |= Extension->LowerDeviceObject->Flags & (DO_DIRECT_IO | DO_BUFFERED_IO | DO_POWER_PAGABLE);

  0012e	48 8b 44 24 40	 mov	 rax, QWORD PTR Extension$[rsp]
  00133	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00137	8b 50 30	 mov	 edx, DWORD PTR [rax+48]
  0013a	81 e2 14 20 00
	00		 and	 edx, 8212		; 00002014H
  00140	48 8b 44 24 58	 mov	 rax, QWORD PTR filterDeviceObject$[rsp]
  00145	8b 48 30	 mov	 ecx, DWORD PTR [rax+48]
  00148	0b ca		 or	 ecx, edx
  0014a	48 8b 44 24 58	 mov	 rax, QWORD PTR filterDeviceObject$[rsp]
  0014f	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 59   : 	filterDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

  00152	48 8b 44 24 58	 mov	 rax, QWORD PTR filterDeviceObject$[rsp]
  00157	8b 48 30	 mov	 ecx, DWORD PTR [rax+48]
  0015a	81 e1 7f ff ff
	ff		 and	 ecx, -129		; ffffff7fH
  00160	48 8b 44 24 58	 mov	 rax, QWORD PTR filterDeviceObject$[rsp]
  00165	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 60   : 
; 61   : 	return status;

  00168	8b 44 24 50	 mov	 eax, DWORD PTR status$[rsp]
  0016c	eb 32		 jmp	 SHORT $LN5@VolumeFilt
$err$29390:

; 62   : 
; 63   : err:
; 64   : 	if (filterDeviceObject)

  0016e	48 83 7c 24 58
	00		 cmp	 QWORD PTR filterDeviceObject$[rsp], 0
  00174	74 26		 je	 SHORT $LN2@VolumeFilt

; 65   : 	{
; 66   : 		if (Extension->LowerDeviceObject)

  00176	48 8b 44 24 40	 mov	 rax, QWORD PTR Extension$[rsp]
  0017b	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00180	74 0f		 je	 SHORT $LN1@VolumeFilt

; 67   : 			IoDetachDevice (Extension->LowerDeviceObject);

  00182	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Extension$[rsp]
  00187	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0018b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDetachDevice
$LN1@VolumeFilt:

; 68   : 
; 69   : 		IoDeleteDevice (filterDeviceObject);

  00191	48 8b 4c 24 58	 mov	 rcx, QWORD PTR filterDeviceObject$[rsp]
  00196	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteDevice
$LN2@VolumeFilt:

; 70   : 	}
; 71   : 
; 72   : 	return status;

  0019c	8b 44 24 50	 mov	 eax, DWORD PTR status$[rsp]
$LN5@VolumeFilt:

; 73   : }

  001a0	48 83 c4 60	 add	 rsp, 96			; 00000060H
  001a4	5f		 pop	 rdi
  001a5	c3		 ret	 0
VolumeFilterAddDevice ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$DispatchPower DD imagerel DispatchPower
	DD	imagerel DispatchPower+181
	DD	imagerel $unwind$DispatchPower
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DispatchPower DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DispatchPower
_TEXT	SEGMENT
status$ = 48
DeviceObject$ = 80
Irp$ = 88
Extension$ = 96
irpSp$ = 104
DispatchPower PROC					; COMDAT

; 245  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 246  : 	NTSTATUS status;
; 247  : 	PoStartNextPowerIrp (Irp);

  00018	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Irp$[rsp]
  0001d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PoStartNextPowerIrp

; 248  : 
; 249  : 	status = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00023	48 8b 4c 24 60	 mov	 rcx, QWORD PTR Extension$[rsp]
  00028	48 81 c1 f0 00
	00 00		 add	 rcx, 240		; 000000f0H
  0002f	c7 44 24 20 78
	00 00 00	 mov	 DWORD PTR [rsp+32], 120	; 00000078H
  00037	41 b9 f9 00 00
	00		 mov	 r9d, 249		; 000000f9H
  0003d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0EL@KFIMJNPM@c?3?2home?2public?2desktop?2projects?2@FNODOBFM@
  00044	48 8b 54 24 58	 mov	 rdx, QWORD PTR Irp$[rsp]
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAcquireRemoveLockEx
  0004f	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax

; 250  : 	if (!NT_SUCCESS (status))

  00053	83 7c 24 30 00	 cmp	 DWORD PTR status$[rsp], 0
  00058	7d 13		 jge	 SHORT $LN1@DispatchPo

; 251  : 		return TCCompleteIrp (Irp, status, 0);

  0005a	45 33 c0	 xor	 r8d, r8d
  0005d	8b 54 24 30	 mov	 edx, DWORD PTR status$[rsp]
  00061	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Irp$[rsp]
  00066	e8 00 00 00 00	 call	 TCCompleteIrp
  0006b	eb 43		 jmp	 SHORT $LN2@DispatchPo
$LN1@DispatchPo:

; 252  : 
; 253  : 	IoSkipCurrentIrpStackLocation (Irp);

  0006d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Irp$[rsp]
  00072	e8 00 00 00 00	 call	 IoSkipCurrentIrpStackLocation

; 254  : 	status = PoCallDriver (Extension->LowerDeviceObject, Irp);

  00077	48 8b 54 24 58	 mov	 rdx, QWORD PTR Irp$[rsp]
  0007c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR Extension$[rsp]
  00081	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PoCallDriver
  0008b	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax

; 255  : 
; 256  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  0008f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR Extension$[rsp]
  00094	48 81 c1 f0 00
	00 00		 add	 rcx, 240		; 000000f0H
  0009b	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  000a1	48 8b 54 24 58	 mov	 rdx, QWORD PTR Irp$[rsp]
  000a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 257  : 	return status;

  000ac	8b 44 24 30	 mov	 eax, DWORD PTR status$[rsp]
$LN2@DispatchPo:

; 258  : }

  000b0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b4	c3		 ret	 0
DispatchPower ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PassIrp DD imagerel PassIrp
	DD	imagerel PassIrp+45
	DD	imagerel $unwind$PassIrp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PassIrp DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PassIrp
_TEXT	SEGMENT
deviceObject$ = 48
irp$ = 56
PassIrp	PROC						; COMDAT

; 77   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 78   : 	IoSkipCurrentIrpStackLocation (irp);

  0000e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR irp$[rsp]
  00013	e8 00 00 00 00	 call	 IoSkipCurrentIrpStackLocation

; 79   : 	return IoCallDriver (deviceObject, irp);

  00018	48 8b 54 24 38	 mov	 rdx, QWORD PTR irp$[rsp]
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCallDriver

; 80   : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
PassIrp	ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$DispatchControl DD imagerel DispatchControl
	DD	imagerel DispatchControl+942
	DD	imagerel $unwind$DispatchControl
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DispatchControl DD 021b01H
	DD	01f011bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DispatchControl
_TEXT	SEGMENT
status$ = 48
bootDriveExtension$29460 = 56
storageDeviceNumber$29461 = 64
partition$29469 = 80
tv79 = 224
DeviceObject$ = 256
Irp$ = 264
Extension$ = 272
irpSp$ = 280
DispatchControl PROC					; COMDAT

; 121  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H

; 122  : 	NTSTATUS status = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  0001b	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00023	48 81 c1 f0 00
	00 00		 add	 rcx, 240		; 000000f0H
  0002a	c7 44 24 20 78
	00 00 00	 mov	 DWORD PTR [rsp+32], 120	; 00000078H
  00032	41 b9 7a 00 00
	00		 mov	 r9d, 122		; 0000007aH
  00038	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0EL@KFIMJNPM@c?3?2home?2public?2desktop?2projects?2@FNODOBFM@
  0003f	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAcquireRemoveLockEx
  0004d	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax

; 123  : 	if (!NT_SUCCESS (status))

  00051	83 7c 24 30 00	 cmp	 DWORD PTR status$[rsp], 0
  00056	7d 19		 jge	 SHORT $LN13@DispatchCo

; 124  : 		return TCCompleteIrp (Irp, status, 0);

  00058	45 33 c0	 xor	 r8d, r8d
  0005b	8b 54 24 30	 mov	 edx, DWORD PTR status$[rsp]
  0005f	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00067	e8 00 00 00 00	 call	 TCCompleteIrp
  0006c	e9 35 03 00 00	 jmp	 $LN14@DispatchCo
$LN13@DispatchCo:

; 125  : 
; 126  : 	if (IsHiddenSystemRunning())

  00071	e8 00 00 00 00	 call	 IsHiddenSystemRunning
  00076	85 c0		 test	 eax, eax
  00078	0f 84 e4 02 00
	00		 je	 $LN12@DispatchCo

; 127  : 	{
; 128  : 		switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  0007e	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR irpSp$[rsp]
  00086	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00089	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv79[rsp], eax
  00090	81 bc 24 e0 00
	00 00 24 00 07
	00		 cmp	 DWORD PTR tv79[rsp], 458788 ; 00070024H
  0009b	74 27		 je	 SHORT $LN9@DispatchCo
  0009d	81 bc 24 e0 00
	00 00 74 20 22
	00		 cmp	 DWORD PTR tv79[rsp], 2236532 ; 00222074H
  000a8	0f 84 6c 01 00
	00		 je	 $LN5@DispatchCo
  000ae	81 bc 24 e0 00
	00 00 04 94 2d
	00		 cmp	 DWORD PTR tv79[rsp], 2987012 ; 002d9404H
  000b9	0f 84 6c 02 00
	00		 je	 $LN1@DispatchCo
  000bf	e9 9e 02 00 00	 jmp	 $LN10@DispatchCo
$LN9@DispatchCo:

; 129  : 		{
; 130  : 		case IOCTL_DISK_IS_WRITABLE:
; 131  : 			{
; 132  : 				// All volumes except the system volume must be read-only
; 133  : 
; 134  : 				DriveFilterExtension *bootDriveExtension = GetBootDriveFilterExtension();

  000c4	e8 00 00 00 00	 call	 GetBootDriveFilterExtension
  000c9	48 89 44 24 38	 mov	 QWORD PTR bootDriveExtension$29460[rsp], rax

; 135  : 				STORAGE_DEVICE_NUMBER storageDeviceNumber;
; 136  : 
; 137  : 				if (!bootDriveExtension->SystemStorageDeviceNumberValid)

  000ce	48 8b 44 24 38	 mov	 rax, QWORD PTR bootDriveExtension$29460[rsp]
  000d3	83 78 34 00	 cmp	 DWORD PTR [rax+52], 0
  000d7	75 23		 jne	 SHORT $LN8@DispatchCo

; 138  : 					TC_BUG_CHECK (STATUS_INVALID_PARAMETER);

  000d9	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  000e2	45 33 c9	 xor	 r9d, r9d
  000e5	49 c7 c0 0d 00
	00 c0		 mov	 r8, -1073741811		; ffffffffc000000dH
  000ec	ba 8a 00 00 00	 mov	 edx, 138		; 0000008aH
  000f1	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  000f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN8@DispatchCo:

; 139  : 
; 140  : 				status = SendDeviceIoControlRequest (Extension->LowerDeviceObject, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0, &storageDeviceNumber, sizeof (storageDeviceNumber));

  000fc	c7 44 24 28 0c
	00 00 00	 mov	 DWORD PTR [rsp+40], 12
  00104	48 8d 44 24 40	 lea	 rax, QWORD PTR storageDeviceNumber$29461[rsp]
  00109	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0010e	45 33 c9	 xor	 r9d, r9d
  00111	45 33 c0	 xor	 r8d, r8d
  00114	ba 80 10 2d 00	 mov	 edx, 2953344		; 002d1080H
  00119	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00121	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00125	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  0012a	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax

; 141  : 
; 142  : 				if (NT_SUCCESS (status) && bootDriveExtension->SystemStorageDeviceNumber == storageDeviceNumber.DeviceNumber)

  0012e	83 7c 24 30 00	 cmp	 DWORD PTR status$[rsp], 0
  00133	0f 8c 95 00 00
	00		 jl	 $LN7@DispatchCo
  00139	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bootDriveExtension$29460[rsp]
  0013e	8b 44 24 44	 mov	 eax, DWORD PTR storageDeviceNumber$29461[rsp+4]
  00142	39 41 30	 cmp	 DWORD PTR [rcx+48], eax
  00145	0f 85 83 00 00
	00		 jne	 $LN7@DispatchCo

; 143  : 				{
; 144  : 					PARTITION_INFORMATION_EX partition;
; 145  : 					status = SendDeviceIoControlRequest (Extension->LowerDeviceObject, IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0, &partition, sizeof (partition));

  0014b	c7 44 24 28 90
	00 00 00	 mov	 DWORD PTR [rsp+40], 144	; 00000090H
  00153	48 8d 44 24 50	 lea	 rax, QWORD PTR partition$29469[rsp]
  00158	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0015d	45 33 c9	 xor	 r9d, r9d
  00160	45 33 c0	 xor	 r8d, r8d
  00163	ba 48 00 07 00	 mov	 edx, 458824		; 00070048H
  00168	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00170	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00174	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  00179	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax

; 146  : 
; 147  : 					if (NT_SUCCESS (status) && partition.StartingOffset.QuadPart == bootDriveExtension->ConfiguredEncryptedAreaStart)

  0017d	83 7c 24 30 00	 cmp	 DWORD PTR status$[rsp], 0
  00182	7c 4a		 jl	 SHORT $LN6@DispatchCo
  00184	48 8b 44 24 38	 mov	 rax, QWORD PTR bootDriveExtension$29460[rsp]
  00189	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0018d	48 39 44 24 58	 cmp	 QWORD PTR partition$29469[rsp+8], rax
  00192	75 3a		 jne	 SHORT $LN6@DispatchCo

; 148  : 					{
; 149  : 						IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00194	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  0019c	48 81 c1 f0 00
	00 00		 add	 rcx, 240		; 000000f0H
  001a3	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  001a9	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  001b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 150  : 						return TCCompleteDiskIrp (Irp, STATUS_SUCCESS, 0);

  001b7	45 33 c0	 xor	 r8d, r8d
  001ba	33 d2		 xor	 edx, edx
  001bc	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  001c4	e8 00 00 00 00	 call	 TCCompleteDiskIrp
  001c9	e9 d8 01 00 00	 jmp	 $LN14@DispatchCo
$LN6@DispatchCo:
$LN7@DispatchCo:

; 151  : 					}
; 152  : 				}
; 153  : 
; 154  : 				IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  001ce	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  001d6	48 81 c1 f0 00
	00 00		 add	 rcx, 240		; 000000f0H
  001dd	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  001e3	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  001eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 155  : 
; 156  : 				++HiddenSysLeakProtectionCount;

  001f1	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR HiddenSysLeakProtectionCount
  001f7	83 c0 01	 add	 eax, 1
  001fa	89 05 00 00 00
	00		 mov	 DWORD PTR HiddenSysLeakProtectionCount, eax

; 157  : 				return TCCompleteDiskIrp (Irp, STATUS_MEDIA_WRITE_PROTECTED, 0);

  00200	45 33 c0	 xor	 r8d, r8d
  00203	ba a2 00 00 c0	 mov	 edx, -1073741662	; ffffffffc00000a2H
  00208	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00210	e8 00 00 00 00	 call	 TCCompleteDiskIrp
  00215	e9 8c 01 00 00	 jmp	 $LN14@DispatchCo
$LN5@DispatchCo:

; 158  : 			}
; 159  : 
; 160  : 		case TC_IOCTL_DISK_IS_WRITABLE:
; 161  : 			Dump ("TC_IOCTL_DISK_IS_WRITABLE pdo=%p\n", Extension->Pdo);

  0021a	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR Extension$[rsp]
  00222	48 8b 52 28	 mov	 rdx, QWORD PTR [rdx+40]
  00226	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@FPKIEKIL@TC_IOCTL_DISK_IS_WRITABLE?5pdo?$DN?$CFp@FNODOBFM@
  0022d	e8 00 00 00 00	 call	 DbgPrint

; 162  : 
; 163  : 			if (!ProbingHostDeviceForWrite)

  00232	44 8b 1d 00 00
	00 00		 mov	 r11d, DWORD PTR ProbingHostDeviceForWrite
  00239	45 85 db	 test	 r11d, r11d
  0023c	75 05		 jne	 SHORT $LN4@DispatchCo

; 164  : 				break;

  0023e	e9 1f 01 00 00	 jmp	 $LN10@DispatchCo
$LN4@DispatchCo:

; 165  : 
; 166  : 			// Probe the real state of the device as the user is mounting a CipherShed volume.
; 167  : 
; 168  : 			// Volume filter may be attached to a merged drive+volume PDO. First test if TC_IOCTL_DISK_IS_WRITABLE works for the underlying device.
; 169  : 			status = SendDeviceIoControlRequest (Extension->LowerDeviceObject, TC_IOCTL_DISK_IS_WRITABLE, NULL, 0, NULL, 0);

  00243	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0024b	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00254	45 33 c9	 xor	 r9d, r9d
  00257	45 33 c0	 xor	 r8d, r8d
  0025a	ba 74 20 22 00	 mov	 edx, 2236532		; 00222074H
  0025f	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00267	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0026b	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  00270	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax

; 170  : 
; 171  : 			if (NT_SUCCESS (status) || status == STATUS_MEDIA_WRITE_PROTECTED)

  00274	83 7c 24 30 00	 cmp	 DWORD PTR status$[rsp], 0
  00279	7d 0a		 jge	 SHORT $LN2@DispatchCo
  0027b	81 7c 24 30 a2
	00 00 c0	 cmp	 DWORD PTR status$[rsp], -1073741662 ; ffffffffc00000a2H
  00283	75 3c		 jne	 SHORT $LN3@DispatchCo
$LN2@DispatchCo:

; 172  : 			{
; 173  : 				IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00285	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  0028d	48 81 c1 f0 00
	00 00		 add	 rcx, 240		; 000000f0H
  00294	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  0029a	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  002a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 174  : 				return TCCompleteDiskIrp (Irp, status, 0);

  002a8	45 33 c0	 xor	 r8d, r8d
  002ab	8b 54 24 30	 mov	 edx, DWORD PTR status$[rsp]
  002af	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  002b7	e8 00 00 00 00	 call	 TCCompleteDiskIrp
  002bc	e9 e5 00 00 00	 jmp	 $LN14@DispatchCo
$LN3@DispatchCo:

; 175  : 			}
; 176  : 
; 177  : 			status = SendDeviceIoControlRequest (Extension->LowerDeviceObject, IOCTL_DISK_IS_WRITABLE, NULL, 0, NULL, 0);

  002c1	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  002c9	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  002d2	45 33 c9	 xor	 r9d, r9d
  002d5	45 33 c0	 xor	 r8d, r8d
  002d8	ba 24 00 07 00	 mov	 edx, 458788		; 00070024H
  002dd	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  002e5	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  002e9	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  002ee	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax

; 178  : 
; 179  : 			IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  002f2	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  002fa	48 81 c1 f0 00
	00 00		 add	 rcx, 240		; 000000f0H
  00301	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  00307	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  0030f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 180  : 			return TCCompleteDiskIrp (Irp, status, 0);

  00315	45 33 c0	 xor	 r8d, r8d
  00318	8b 54 24 30	 mov	 edx, DWORD PTR status$[rsp]
  0031c	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00324	e8 00 00 00 00	 call	 TCCompleteDiskIrp
  00329	eb 7b		 jmp	 SHORT $LN14@DispatchCo
$LN1@DispatchCo:

; 181  : 
; 182  : 		case IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES:
; 183  : 
; 184  : 			// Filter IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES to enable potential future use of hidden systems on drives that use the trim operation but not wear-leveling (if any appear in future). The documentation forbids users to create hidden volumes/systems on drives that use wear-leveling and consequently also on drives that use trim (as trim is used only by drives that use wear-leveling, as of 2010).
; 185  : 
; 186  : 			IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  0032b	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00333	48 81 c1 f0 00
	00 00		 add	 rcx, 240		; 000000f0H
  0033a	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  00340	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  00348	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 187  : 			return TCCompleteDiskIrp (Irp, STATUS_SUCCESS, 0);

  0034e	45 33 c0	 xor	 r8d, r8d
  00351	33 d2		 xor	 edx, edx
  00353	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  0035b	e8 00 00 00 00	 call	 TCCompleteDiskIrp
  00360	eb 44		 jmp	 SHORT $LN14@DispatchCo
$LN10@DispatchCo:
$LN12@DispatchCo:

; 188  : 		}
; 189  : 	}
; 190  : 
; 191  : 	status = PassIrp (Extension->LowerDeviceObject, Irp);

  00362	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  0036a	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00372	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00376	e8 00 00 00 00	 call	 PassIrp
  0037b	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax

; 192  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  0037f	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00387	48 81 c1 f0 00
	00 00		 add	 rcx, 240		; 000000f0H
  0038e	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  00394	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  0039c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 193  : 	return status;

  003a2	8b 44 24 30	 mov	 eax, DWORD PTR status$[rsp]
$LN14@DispatchCo:
$LN15@DispatchCo:

; 194  : }

  003a6	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  003ad	c3		 ret	 0
DispatchControl ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$OnStartDeviceCompleted DD imagerel OnStartDeviceCompleted
	DD	imagerel OnStartDeviceCompleted+116
	DD	imagerel $unwind$OnStartDeviceCompleted
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$OnStartDeviceCompleted DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT OnStartDeviceCompleted
_TEXT	SEGMENT
filterDeviceObject$ = 48
Irp$ = 56
Extension$ = 64
OnStartDeviceCompleted PROC				; COMDAT

; 108  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 109  : 	if (Irp->PendingReturned)

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Irp$[rsp]
  00018	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  0001c	85 c0		 test	 eax, eax
  0001e	74 0a		 je	 SHORT $LN2@OnStartDev

; 110  : 		IoMarkIrpPending (Irp);

  00020	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Irp$[rsp]
  00025	e8 00 00 00 00	 call	 IoMarkIrpPending
$LN2@OnStartDev:

; 111  : 
; 112  : 	if (Extension->LowerDeviceObject->Characteristics & FILE_REMOVABLE_MEDIA)

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR Extension$[rsp]
  0002f	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00033	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  00036	83 e0 01	 and	 eax, 1
  00039	85 c0		 test	 eax, eax
  0003b	74 13		 je	 SHORT $LN1@OnStartDev

; 113  : 		filterDeviceObject->Characteristics |= FILE_REMOVABLE_MEDIA;

  0003d	48 8b 44 24 30	 mov	 rax, QWORD PTR filterDeviceObject$[rsp]
  00042	8b 48 34	 mov	 ecx, DWORD PTR [rax+52]
  00045	83 c9 01	 or	 ecx, 1
  00048	48 8b 44 24 30	 mov	 rax, QWORD PTR filterDeviceObject$[rsp]
  0004d	89 48 34	 mov	 DWORD PTR [rax+52], ecx
$LN1@OnStartDev:

; 114  : 
; 115  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00050	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Extension$[rsp]
  00055	48 81 c1 f0 00
	00 00		 add	 rcx, 240		; 000000f0H
  0005c	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  00062	48 8b 54 24 38	 mov	 rdx, QWORD PTR Irp$[rsp]
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 116  : 	return STATUS_CONTINUE_COMPLETION;

  0006d	33 c0		 xor	 eax, eax

; 117  : }

  0006f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00073	c3		 ret	 0
OnStartDeviceCompleted ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$OnDeviceUsageNotificationCompleted DD imagerel OnDeviceUsageNotificationCompleted
	DD	imagerel OnDeviceUsageNotificationCompleted+121
	DD	imagerel $unwind$OnDeviceUsageNotificationCompleted
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$OnDeviceUsageNotificationCompleted DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT OnDeviceUsageNotificationCompleted
_TEXT	SEGMENT
filterDeviceObject$ = 48
Irp$ = 56
Extension$ = 64
OnDeviceUsageNotificationCompleted PROC			; COMDAT

; 95   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 96   : 	if (Irp->PendingReturned)

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Irp$[rsp]
  00018	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  0001c	85 c0		 test	 eax, eax
  0001e	74 0a		 je	 SHORT $LN2@OnDeviceUs

; 97   : 		IoMarkIrpPending (Irp);

  00020	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Irp$[rsp]
  00025	e8 00 00 00 00	 call	 IoMarkIrpPending
$LN2@OnDeviceUs:

; 98   : 
; 99   : 	if (!(Extension->LowerDeviceObject->Flags & DO_POWER_PAGABLE))

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR Extension$[rsp]
  0002f	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00033	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00036	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  0003b	85 c0		 test	 eax, eax
  0003d	75 16		 jne	 SHORT $LN1@OnDeviceUs

; 100  : 		filterDeviceObject->Flags &= ~DO_POWER_PAGABLE;

  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR filterDeviceObject$[rsp]
  00044	8b 48 30	 mov	 ecx, DWORD PTR [rax+48]
  00047	81 e1 ff df ff
	ff		 and	 ecx, -8193		; ffffdfffH
  0004d	48 8b 44 24 30	 mov	 rax, QWORD PTR filterDeviceObject$[rsp]
  00052	89 48 30	 mov	 DWORD PTR [rax+48], ecx
$LN1@OnDeviceUs:

; 101  : 
; 102  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00055	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Extension$[rsp]
  0005a	48 81 c1 f0 00
	00 00		 add	 rcx, 240		; 000000f0H
  00061	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  00067	48 8b 54 24 38	 mov	 rdx, QWORD PTR Irp$[rsp]
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 103  : 	return STATUS_CONTINUE_COMPLETION;

  00072	33 c0		 xor	 eax, eax

; 104  : }

  00074	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00078	c3		 ret	 0
OnDeviceUsageNotificationCompleted ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PassFilteredIrp DD imagerel PassFilteredIrp
	DD	imagerel PassFilteredIrp+96
	DD	imagerel $unwind$PassFilteredIrp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PassFilteredIrp DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PassFilteredIrp
_TEXT	SEGMENT
deviceObject$ = 64
irp$ = 72
completionRoutine$ = 80
completionRoutineArg$ = 88
PassFilteredIrp PROC					; COMDAT

; 84   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 85   : 	IoCopyCurrentIrpStackLocationToNext (irp);

  00018	48 8b 4c 24 48	 mov	 rcx, QWORD PTR irp$[rsp]
  0001d	e8 00 00 00 00	 call	 IoCopyCurrentIrpStackLocationToNext

; 86   : 
; 87   : 	if (completionRoutine)

  00022	48 83 7c 24 50
	00		 cmp	 QWORD PTR completionRoutine$[rsp], 0
  00028	74 21		 je	 SHORT $LN1@PassFilter

; 88   : 		IoSetCompletionRoutine (irp, completionRoutine, completionRoutineArg, TRUE, TRUE, TRUE);

  0002a	c6 44 24 28 01	 mov	 BYTE PTR [rsp+40], 1
  0002f	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  00034	41 b1 01	 mov	 r9b, 1
  00037	4c 8b 44 24 58	 mov	 r8, QWORD PTR completionRoutineArg$[rsp]
  0003c	48 8b 54 24 50	 mov	 rdx, QWORD PTR completionRoutine$[rsp]
  00041	48 8b 4c 24 48	 mov	 rcx, QWORD PTR irp$[rsp]
  00046	e8 00 00 00 00	 call	 IoSetCompletionRoutine
$LN1@PassFilter:

; 89   : 
; 90   : 	return IoCallDriver (deviceObject, irp);

  0004b	48 8b 54 24 48	 mov	 rdx, QWORD PTR irp$[rsp]
  00050	48 8b 4c 24 40	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCallDriver

; 91   : }

  0005b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005f	c3		 ret	 0
PassFilteredIrp ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$DispatchPnp DD imagerel DispatchPnp
	DD	imagerel DispatchPnp+480
	DD	imagerel $unwind$DispatchPnp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DispatchPnp DD 011801H
	DD	0a218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DispatchPnp
_TEXT	SEGMENT
status$ = 48
attachedDevice$29515 = 56
tv78 = 64
DeviceObject$ = 96
Irp$ = 104
Extension$ = 112
irpSp$ = 120
DispatchPnp PROC					; COMDAT

; 198  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 199  : 	NTSTATUS status;
; 200  : 
; 201  : 	status = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00018	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Extension$[rsp]
  0001d	48 81 c1 f0 00
	00 00		 add	 rcx, 240		; 000000f0H
  00024	c7 44 24 20 78
	00 00 00	 mov	 DWORD PTR [rsp+32], 120	; 00000078H
  0002c	41 b9 c9 00 00
	00		 mov	 r9d, 201		; 000000c9H
  00032	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0EL@KFIMJNPM@c?3?2home?2public?2desktop?2projects?2@FNODOBFM@
  00039	48 8b 54 24 68	 mov	 rdx, QWORD PTR Irp$[rsp]
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAcquireRemoveLockEx
  00044	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax

; 202  : 	if (!NT_SUCCESS (status))

  00048	83 7c 24 30 00	 cmp	 DWORD PTR status$[rsp], 0
  0004d	7d 16		 jge	 SHORT $LN9@DispatchPn

; 203  : 		return TCCompleteIrp (Irp, status, 0);

  0004f	45 33 c0	 xor	 r8d, r8d
  00052	8b 54 24 30	 mov	 edx, DWORD PTR status$[rsp]
  00056	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Irp$[rsp]
  0005b	e8 00 00 00 00	 call	 TCCompleteIrp
  00060	e9 76 01 00 00	 jmp	 $LN10@DispatchPn
$LN9@DispatchPn:

; 204  : 
; 205  : 	switch (irpSp->MinorFunction)

  00065	48 8b 44 24 78	 mov	 rax, QWORD PTR irpSp$[rsp]
  0006a	8a 40 01	 mov	 al, BYTE PTR [rax+1]
  0006d	88 44 24 40	 mov	 BYTE PTR tv78[rsp], al
  00071	80 7c 24 40 00	 cmp	 BYTE PTR tv78[rsp], 0
  00076	74 17		 je	 SHORT $LN6@DispatchPn
  00078	80 7c 24 40 02	 cmp	 BYTE PTR tv78[rsp], 2
  0007d	0f 84 b7 00 00
	00		 je	 $LN2@DispatchPn
  00083	80 7c 24 40 16	 cmp	 BYTE PTR tv78[rsp], 22
  00088	74 3e		 je	 SHORT $LN5@DispatchPn
  0008a	e9 14 01 00 00	 jmp	 $LN1@DispatchPn
$LN6@DispatchPn:

; 206  : 	{
; 207  : 	case IRP_MN_START_DEVICE:
; 208  : 		Dump ("IRP_MN_START_DEVICE volume pdo=%p\n", Extension->Pdo);

  0008f	48 8b 54 24 70	 mov	 rdx, QWORD PTR Extension$[rsp]
  00094	48 8b 52 28	 mov	 rdx, QWORD PTR [rdx+40]
  00098	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@BENKCDLN@IRP_MN_START_DEVICE?5volume?5pdo?$DN?$CF@FNODOBFM@
  0009f	e8 00 00 00 00	 call	 DbgPrint

; 209  : 		return PassFilteredIrp (Extension->LowerDeviceObject, Irp, OnStartDeviceCompleted, Extension);

  000a4	4c 8b 4c 24 70	 mov	 r9, QWORD PTR Extension$[rsp]
  000a9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:OnStartDeviceCompleted
  000b0	48 8b 54 24 68	 mov	 rdx, QWORD PTR Irp$[rsp]
  000b5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Extension$[rsp]
  000ba	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  000be	e8 00 00 00 00	 call	 PassFilteredIrp
  000c3	e9 13 01 00 00	 jmp	 $LN10@DispatchPn
$LN5@DispatchPn:

; 210  : 
; 211  : 	case IRP_MN_DEVICE_USAGE_NOTIFICATION:
; 212  : 		{
; 213  : 			PDEVICE_OBJECT attachedDevice = IoGetAttachedDeviceReference (DeviceObject);

  000c8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  000cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetAttachedDeviceReference
  000d3	48 89 44 24 38	 mov	 QWORD PTR attachedDevice$29515[rsp], rax

; 214  : 
; 215  : 			if (attachedDevice == DeviceObject || (attachedDevice->Flags & DO_POWER_PAGABLE))

  000d8	48 8b 44 24 60	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  000dd	48 39 44 24 38	 cmp	 QWORD PTR attachedDevice$29515[rsp], rax
  000e2	74 11		 je	 SHORT $LN3@DispatchPn
  000e4	48 8b 44 24 38	 mov	 rax, QWORD PTR attachedDevice$29515[rsp]
  000e9	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  000ec	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  000f1	85 c0		 test	 eax, eax
  000f3	74 16		 je	 SHORT $LN4@DispatchPn
$LN3@DispatchPn:

; 216  : 				DeviceObject->Flags |= DO_POWER_PAGABLE;

  000f5	48 8b 44 24 60	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  000fa	8b 48 30	 mov	 ecx, DWORD PTR [rax+48]
  000fd	81 c9 00 20 00
	00		 or	 ecx, 8192		; 00002000H
  00103	48 8b 44 24 60	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  00108	89 48 30	 mov	 DWORD PTR [rax+48], ecx
$LN4@DispatchPn:

; 217  : 
; 218  : 			ObDereferenceObject (attachedDevice);

  0010b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR attachedDevice$29515[rsp]
  00110	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 219  : 		}
; 220  : 
; 221  : 		return PassFilteredIrp (Extension->LowerDeviceObject, Irp, OnDeviceUsageNotificationCompleted, Extension);

  00116	4c 8b 4c 24 70	 mov	 r9, QWORD PTR Extension$[rsp]
  0011b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:OnDeviceUsageNotificationCompleted
  00122	48 8b 54 24 68	 mov	 rdx, QWORD PTR Irp$[rsp]
  00127	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Extension$[rsp]
  0012c	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00130	e8 00 00 00 00	 call	 PassFilteredIrp
  00135	e9 a1 00 00 00	 jmp	 $LN10@DispatchPn
$LN2@DispatchPn:

; 222  : 
; 223  : 
; 224  : 	case IRP_MN_REMOVE_DEVICE:
; 225  : 		Dump ("IRP_MN_REMOVE_DEVICE volume pdo=%p\n", Extension->Pdo);

  0013a	48 8b 54 24 70	 mov	 rdx, QWORD PTR Extension$[rsp]
  0013f	48 8b 52 28	 mov	 rdx, QWORD PTR [rdx+40]
  00143	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@GJODMOBD@IRP_MN_REMOVE_DEVICE?5volume?5pdo?$DN@FNODOBFM@
  0014a	e8 00 00 00 00	 call	 DbgPrint

; 226  : 
; 227  : 		IoReleaseRemoveLockAndWait (&Extension->Queue.RemoveLock, Irp);

  0014f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Extension$[rsp]
  00154	48 81 c1 f0 00
	00 00		 add	 rcx, 240		; 000000f0H
  0015b	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  00161	48 8b 54 24 68	 mov	 rdx, QWORD PTR Irp$[rsp]
  00166	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockAndWaitEx

; 228  : 		status = PassIrp (Extension->LowerDeviceObject, Irp);

  0016c	48 8b 54 24 68	 mov	 rdx, QWORD PTR Irp$[rsp]
  00171	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Extension$[rsp]
  00176	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0017a	e8 00 00 00 00	 call	 PassIrp
  0017f	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax

; 229  : 
; 230  : 		IoDetachDevice (Extension->LowerDeviceObject);

  00183	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Extension$[rsp]
  00188	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0018c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDetachDevice

; 231  : 
; 232  : 		IoDeleteDevice (DeviceObject);

  00192	48 8b 4c 24 60	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  00197	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteDevice

; 233  : 		return status;

  0019d	8b 44 24 30	 mov	 eax, DWORD PTR status$[rsp]
  001a1	eb 38		 jmp	 SHORT $LN10@DispatchPn
$LN1@DispatchPn:

; 234  : 
; 235  : 	default:
; 236  : 		status = PassIrp (Extension->LowerDeviceObject, Irp);

  001a3	48 8b 54 24 68	 mov	 rdx, QWORD PTR Irp$[rsp]
  001a8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Extension$[rsp]
  001ad	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  001b1	e8 00 00 00 00	 call	 PassIrp
  001b6	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax

; 237  : 		IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  001ba	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Extension$[rsp]
  001bf	48 81 c1 f0 00
	00 00		 add	 rcx, 240		; 000000f0H
  001c6	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  001cc	48 8b 54 24 68	 mov	 rdx, QWORD PTR Irp$[rsp]
  001d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 238  : 	}
; 239  : 
; 240  : 	return status;

  001d7	8b 44 24 30	 mov	 eax, DWORD PTR status$[rsp]
$LN10@DispatchPn:

; 241  : }

  001db	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001df	c3		 ret	 0
DispatchPnp ENDP
PUBLIC	VolumeFilterDispatchIrp
;	COMDAT pdata
pdata	SEGMENT
$pdata$VolumeFilterDispatchIrp DD imagerel $LN12
	DD	imagerel $LN12+370
	DD	imagerel $unwind$VolumeFilterDispatchIrp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$VolumeFilterDispatchIrp DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT VolumeFilterDispatchIrp
_TEXT	SEGMENT
Extension$ = 48
status$ = 56
irpSp$ = 64
tv74 = 72
tv76 = 76
DeviceObject$ = 96
Irp$ = 104
VolumeFilterDispatchIrp PROC				; COMDAT

; 262  : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 263  : 	VolumeFilterExtension *Extension = (VolumeFilterExtension *) DeviceObject->DeviceExtension;

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  00013	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00017	48 89 44 24 30	 mov	 QWORD PTR Extension$[rsp], rax

; 264  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);

  0001c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Irp$[rsp]
  00021	e8 00 00 00 00	 call	 IoGetCurrentIrpStackLocation
  00026	48 89 44 24 40	 mov	 QWORD PTR irpSp$[rsp], rax

; 265  : 	NTSTATUS status;
; 266  : 
; 267  : 	ASSERT (!Extension->bRootDevice && Extension->IsVolumeFilterDevice);

  0002b	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  00030	83 38 00	 cmp	 DWORD PTR [rax], 0
  00033	75 15		 jne	 SHORT $LN10@VolumeFilt@2
  00035	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  0003a	83 78 0c 00	 cmp	 DWORD PTR [rax+12], 0
  0003e	74 0a		 je	 SHORT $LN10@VolumeFilt@2
  00040	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  00048	eb 25		 jmp	 SHORT $LN11@VolumeFilt@2
$LN10@VolumeFilt@2:
  0004a	45 33 c9	 xor	 r9d, r9d
  0004d	41 b8 0b 01 00
	00		 mov	 r8d, 267		; 0000010bH
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EL@KFIMJNPM@c?3?2home?2public?2desktop?2projects?2@FNODOBFM@
  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DL@GNELLIFI@?$CBExtension?9?$DObRootDevice?5?$CG?$CG?5Exten@FNODOBFM@
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  00067	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN11@VolumeFilt@2:

; 268  : 
; 269  : 	switch (irpSp->MajorFunction)

  0006f	48 8b 44 24 40	 mov	 rax, QWORD PTR irpSp$[rsp]
  00074	8a 00		 mov	 al, BYTE PTR [rax]
  00076	88 44 24 4c	 mov	 BYTE PTR tv76[rsp], al
  0007a	80 7c 24 4c 0e	 cmp	 BYTE PTR tv76[rsp], 14
  0007f	74 10		 je	 SHORT $LN5@VolumeFilt@2
  00081	80 7c 24 4c 16	 cmp	 BYTE PTR tv76[rsp], 22
  00086	74 45		 je	 SHORT $LN3@VolumeFilt@2
  00088	80 7c 24 4c 1b	 cmp	 BYTE PTR tv76[rsp], 27
  0008d	74 20		 je	 SHORT $LN4@VolumeFilt@2
  0008f	eb 5a		 jmp	 SHORT $LN2@VolumeFilt@2
$LN5@VolumeFilt@2:

; 270  : 	{
; 271  : 	case IRP_MJ_DEVICE_CONTROL:
; 272  : 		return DispatchControl (DeviceObject, Irp, Extension, irpSp);

  00091	4c 8b 4c 24 40	 mov	 r9, QWORD PTR irpSp$[rsp]
  00096	4c 8b 44 24 30	 mov	 r8, QWORD PTR Extension$[rsp]
  0009b	48 8b 54 24 68	 mov	 rdx, QWORD PTR Irp$[rsp]
  000a0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  000a5	e8 00 00 00 00	 call	 DispatchControl
  000aa	e9 be 00 00 00	 jmp	 $LN8@VolumeFilt@2
$LN4@VolumeFilt@2:

; 273  : 
; 274  : 	case IRP_MJ_PNP:
; 275  : 		return DispatchPnp (DeviceObject, Irp, Extension, irpSp);

  000af	4c 8b 4c 24 40	 mov	 r9, QWORD PTR irpSp$[rsp]
  000b4	4c 8b 44 24 30	 mov	 r8, QWORD PTR Extension$[rsp]
  000b9	48 8b 54 24 68	 mov	 rdx, QWORD PTR Irp$[rsp]
  000be	48 8b 4c 24 60	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  000c3	e8 00 00 00 00	 call	 DispatchPnp
  000c8	e9 a0 00 00 00	 jmp	 $LN8@VolumeFilt@2
$LN3@VolumeFilt@2:

; 276  : 
; 277  : 	case IRP_MJ_POWER:
; 278  : 		return DispatchPower (DeviceObject, Irp, Extension, irpSp);

  000cd	4c 8b 4c 24 40	 mov	 r9, QWORD PTR irpSp$[rsp]
  000d2	4c 8b 44 24 30	 mov	 r8, QWORD PTR Extension$[rsp]
  000d7	48 8b 54 24 68	 mov	 rdx, QWORD PTR Irp$[rsp]
  000dc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  000e1	e8 00 00 00 00	 call	 DispatchPower
  000e6	e9 82 00 00 00	 jmp	 $LN8@VolumeFilt@2
$LN2@VolumeFilt@2:

; 279  : 
; 280  : 	default:
; 281  : 		status = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  000eb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Extension$[rsp]
  000f0	48 81 c1 f0 00
	00 00		 add	 rcx, 240		; 000000f0H
  000f7	c7 44 24 20 78
	00 00 00	 mov	 DWORD PTR [rsp+32], 120	; 00000078H
  000ff	41 b9 19 01 00
	00		 mov	 r9d, 281		; 00000119H
  00105	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0EL@KFIMJNPM@c?3?2home?2public?2desktop?2projects?2@FNODOBFM@
  0010c	48 8b 54 24 68	 mov	 rdx, QWORD PTR Irp$[rsp]
  00111	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAcquireRemoveLockEx
  00117	89 44 24 38	 mov	 DWORD PTR status$[rsp], eax

; 282  : 		if (!NT_SUCCESS (status))

  0011b	83 7c 24 38 00	 cmp	 DWORD PTR status$[rsp], 0
  00120	7d 13		 jge	 SHORT $LN1@VolumeFilt@2

; 283  : 			return TCCompleteIrp (Irp, status, 0);

  00122	45 33 c0	 xor	 r8d, r8d
  00125	8b 54 24 38	 mov	 edx, DWORD PTR status$[rsp]
  00129	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Irp$[rsp]
  0012e	e8 00 00 00 00	 call	 TCCompleteIrp
  00133	eb 38		 jmp	 SHORT $LN8@VolumeFilt@2
$LN1@VolumeFilt@2:

; 284  : 
; 285  : 		status = PassIrp (Extension->LowerDeviceObject, Irp);

  00135	48 8b 54 24 68	 mov	 rdx, QWORD PTR Irp$[rsp]
  0013a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Extension$[rsp]
  0013f	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00143	e8 00 00 00 00	 call	 PassIrp
  00148	89 44 24 38	 mov	 DWORD PTR status$[rsp], eax

; 286  : 
; 287  : 		IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  0014c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Extension$[rsp]
  00151	48 81 c1 f0 00
	00 00		 add	 rcx, 240		; 000000f0H
  00158	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  0015e	48 8b 54 24 68	 mov	 rdx, QWORD PTR Irp$[rsp]
  00163	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 288  : 		return status;

  00169	8b 44 24 38	 mov	 eax, DWORD PTR status$[rsp]
$LN8@VolumeFilt@2:

; 289  : 	}
; 290  : }

  0016d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00171	c3		 ret	 0
VolumeFilterDispatchIrp ENDP
END
