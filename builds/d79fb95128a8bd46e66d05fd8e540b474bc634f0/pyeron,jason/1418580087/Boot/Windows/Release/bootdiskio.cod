;	Static Name Aliases
;
;	$S1391_?CachedDrive@?1??IsLbaSupported@@YADE@Z@4EA	EQU	?CachedDrive@?1??IsLbaSupported@@YADE@Z@4EA
;	$S1393_?CachedStatus@?1??IsLbaSupported@@YADE@Z@4DA	EQU	?CachedStatus@?1??IsLbaSupported@@YADE@Z@4DA
	TITLE   ..\bootdiskio.cpp
	.MODEL  SMALL
	.386p
	.387
_TEXT	SEGMENT  WORD USE16 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT  WORD USE16 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT  WORD USE16 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT  WORD USE16 PUBLIC 'BSS'
_BSS	ENDS
DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME DS: DGROUP, SS: DGROUP
PUBLIC  ??_C@_07JBEK@?5Drive?3?$AA@
PUBLIC  ??_C@_08NNOK@?5Sector?3?$AA@
PUBLIC  ??_C@_05CLDD@?5CHS?3?$AA@
PUBLIC  ??_C@_06OLBI@Drive?5?$AA@
PUBLIC  ??_C@_0N@JJKN@?5not?5found?3?5?$AA@
PUBLIC  ??_C@_00A@?$AA@
PUBLIC  ??_C@_04HAAB@?5MB?5?$AA@
PUBLIC  ??_C@_0BM@IDKA@No?5bootable?5partition?5found?$AA@
PUBLIC  ??_C@_05DHHK@Write?$AA@
PUBLIC  ??_C@_04KCBC@Read?$AA@
PUBLIC  ??_C@_07EIJM@?5error?3?$AA@
EXTRN	?PrintErrorNoEndl@@YAXPBD@Z:NEAR
EXTRN	?Beep@@YAXXZ:NEAR
EXTRN	_memcpy:NEAR
EXTRN	??5@YA?ATUINT64_STRUCT@@ABT0@H@Z:NEAR
EXTRN	__aNulmul:NEAR
EXTRN	__aNulrem:NEAR
EXTRN	__aNuldiv:NEAR
EXTRN	?Print@@YAXPBD@Z:NEAR
EXTRN	?Print@@YAXK@Z:NEAR
EXTRN	?Print@@YAXABTUINT64_STRUCT@@@Z:NEAR
EXTRN	?PrintChar@@YAXD@Z:NEAR
EXTRN	?PrintEndl@@YAXXZ:NEAR
EXTRN	?CopyMemory@@YAXIIPAXI@Z:NEAR
EXTRN	?PrintError@@YAXPBD@Z:NEAR
EXTRN	?BootStarted@@3DA:BYTE
EXTRN	?ActivePartition@@3UPartition@@A:BYTE
_DATA      SEGMENT
$S1391_?CachedDrive@?1??IsLbaSupported@@YADE@Z@4EA	DB	07fH
	ORG	$-1
??_C@_05DHHK@Write?$AA@	DB	'Write',  00H
	ORG	$-6
??_C@_04KCBC@Read?$AA@	DB	'Read',  00H
	ORG	$-5
??_C@_07EIJM@?5error?3?$AA@	DB	' error:',  00H
	ORG	$-8
??_C@_07JBEK@?5Drive?3?$AA@	DB	' Drive:',  00H
	ORG	$-8
??_C@_08NNOK@?5Sector?3?$AA@	DB	' Sector:',  00H
	ORG	$-9
??_C@_05CLDD@?5CHS?3?$AA@	DB	' CHS:',  00H
	ORG	$-6
??_C@_04HAAB@?5MB?5?$AA@	DB	' MB ',  00H
	ORG	$-5
??_C@_06OLBI@Drive?5?$AA@	DB	'Drive ',  00H
	ORG	$-7
??_C@_0N@JJKN@?5not?5found?3?5?$AA@	DB	' not found: ',  00H
	ORG	$-13
??_C@_00A@?$AA@	DB	00H
	ORG	$-1
??_C@_0BM@IDKA@No?5bootable?5partition?5found?$AA@	DB	'No bootable partition found',  00H
_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?SectorBuffer@@3QAEA
?SectorBuffer@@3QAEA	DW 0100H DUP (?)
$S1393_?CachedStatus@?1??IsLbaSupported@@YADE@Z@4DA	DB 01H DUP (?)
_BSS      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	PUBLIC	?IsLbaSupported@@YADE@Z	; IsLbaSupported
?IsLbaSupported@@YADE@Z	PROC NEAR	; IsLbaSupported COMDAT
;|*** /*
;|***  Copyright (c) 2008-2011 TrueCrypt Developers Association. All rights reserved.
;|*** 
;|***  Governed by the TrueCrypt License 3.0 the full text of which is contained in
;|***  the file License.txt included in TrueCrypt binary and source code distribution
;|***  packages.
;|*** */
;|*** 
;|*** #include "Bios.h"
;|*** #include "BootConsoleIo.h"
;|*** #include "BootConfig.h"
;|*** #include "BootDebug.h"
;|*** #include "BootDefs.h"
;|*** #include "BootDiskIo.h"
;|*** #include "BootStrings.h"
;|*** 
;|*** 
;|*** byte SectorBuffer[TC_LB_SIZE];
;|*** 
;|*** #ifdef TC_BOOT_DEBUG_ENABLED
;|*** static bool SectorBufferInUse = false;
;|*** 
;|*** void AcquireSectorBuffer ()
;|*** {
;|*** 	if (SectorBufferInUse)
;|*** 		TC_THROW_FATAL_EXCEPTION;
;|*** 
;|*** 	SectorBufferInUse = true;
;|*** }
;|*** 
;|*** 
;|*** void ReleaseSectorBuffer ()
;|*** {
;|*** 	SectorBufferInUse = false;
;|*** }
;|*** 
;|*** #endif
;|*** 
;|*** 
;|*** bool IsLbaSupported (byte drive)
;|*** {
; Line 41
	*** 000000	c8 02 00 00 		enter	2,0
;	result = -2
;	drive = 4
;|*** 	static byte CachedDrive = TC_INVALID_BIOS_DRIVE;
;|*** 	static bool CachedStatus;
;|*** 	uint16 result = 0;
; Line 44
	*** 000004	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;result
;|*** 
;|*** 	if (CachedDrive == drive)
; Line 46
	*** 000009	8a 46 04 		mov	al,BYTE PTR [bp+4]	;drive
	*** 00000c	38 06 00 00 		cmp	BYTE PTR $S1391_?CachedDrive@?1??IsLbaSupported@@YADE@Z@4EA,al
	*** 000010	74 25 			je	SHORT $ret1396
;|*** 		goto ret;
;|*** 
;|*** 	__asm
;|*** 	{
;|*** 		mov bx, 0x55aa
; Line 51
	*** 000012	bb aa 55 		mov	bx,21930	;55aaH
;|*** 		mov dl, drive
; Line 52
	*** 000015	8a 56 04 		mov	dl,BYTE PTR [bp+4]	;drive
;|*** 		mov ah, 0x41
; Line 53
	*** 000018	b4 41 			mov	ah,65	;0041H
;|*** 		int 0x13
; Line 54
	*** 00001a	cd 13 			int	19	;0013H
;|*** 		jc err
; Line 55
	*** 00001c	72 03 			jb	SHORT $err1398
;|*** 		mov result, bx
; Line 56
	*** 00001e	89 5e fe 		mov	WORD PTR [bp-2],bx	;result
;|*** 	err:
; Line 57
					$err1398:
;|*** 	}
; Line 58
;|*** 
;|*** 	CachedDrive = drive;
; Line 60
	*** 000021	8a 46 04 		mov	al,BYTE PTR [bp+4]	;drive
	*** 000024	a2 00 00 		mov	BYTE PTR $S1391_?CachedDrive@?1??IsLbaSupported@@YADE@Z@4EA,al
;|*** 	CachedStatus = (result == 0xaa55);
; Line 61
	*** 000027	81 7e fe 55 aa 		cmp	WORD PTR [bp-2],-21931	;aa55H	;result
	*** 00002c	75 04 			jne	SHORT $L1623
	*** 00002e	b0 01 			mov	al,1
	*** 000030	eb 02 			jmp	SHORT $L1624
					$L1623:
	*** 000032	32 c0 			xor	al,al
					$L1624:
	*** 000034	a2 00 00 		mov	BYTE PTR $S1393_?CachedStatus@?1??IsLbaSupported@@YADE@Z@4DA,al
;|*** ret:
; Line 62
					$ret1396:
;|*** 	return CachedStatus;
; Line 63
	*** 000037	a0 00 00 		mov	al,BYTE PTR $S1393_?CachedStatus@?1??IsLbaSupported@@YADE@Z@4DA
;|*** }
; Line 64
	*** 00003a	c9 			leave	
	*** 00003b	c3 			ret	

?IsLbaSupported@@YADE@Z	ENDP
	PUBLIC	?PrintDiskError@@YAXEDEPBTUINT64_STRUCT@@PBUChsAddress@@@Z	; PrintDiskError
?PrintDiskError@@YAXEDEPBTUINT64_STRUCT@@PBUChsAddress@@@Z	PROC NEAR	; PrintDiskError COMDAT
;|*** 
;|*** 
;|*** void PrintDiskError (BiosResult error, bool write, byte drive, const uint64 *sector, const ChsAddress *chs)
;|*** {
; Line 68
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
	*** 000003	56 			push	si
;	error = 4
;	write = 6
;	drive = 8
;	sector = 10
;	chs = 12
	*** 000004	8b 76 0a 		mov	si,WORD PTR [bp+10]	;sector
;|*** 	PrintEndl();
; Line 69
	*** 000007	e8 00 00 		call	?PrintEndl@@YAXXZ	; PrintEndl
;|*** 	Print (write ? "Write" : "Read"); Print (" error:");
; Line 70
	*** 00000a	80 7e 06 00 		cmp	BYTE PTR [bp+6],0	;write
	*** 00000e	74 05 			je	SHORT $L1625
	*** 000010	b8 00 00 		mov	ax,OFFSET DGROUP:??_C@_05DHHK@Write?$AA@
	*** 000013	eb 03 			jmp	SHORT $L1626
					$L1625:
	*** 000015	b8 00 00 		mov	ax,OFFSET DGROUP:??_C@_04KCBC@Read?$AA@
					$L1626:
	*** 000018	50 			push	ax
	*** 000019	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 00001c	5b 			pop	bx
	*** 00001d	68 00 00 		push	OFFSET DGROUP:??_C@_07EIJM@?5error?3?$AA@
	*** 000020	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000023	5b 			pop	bx
;|*** 	Print (error);
; Line 71
	*** 000024	8a 46 04 		mov	al,BYTE PTR [bp+4]	;error
	*** 000027	2a e4 			sub	ah,ah
	*** 000029	6a 00 			push	0
	*** 00002b	50 			push	ax
	*** 00002c	e8 00 00 		call	?Print@@YAXK@Z	; Print
	*** 00002f	83 c4 04 		add	sp,4
;|*** 	Print (" Drive:");
; Line 72
	*** 000032	68 00 00 		push	OFFSET DGROUP:??_C@_07JBEK@?5Drive?3?$AA@
	*** 000035	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000038	5b 			pop	bx
;|*** 	Print (drive ^ 0x80);
; Line 73
	*** 000039	8a 46 08 		mov	al,BYTE PTR [bp+8]	;drive
	*** 00003c	34 80 			xor	al,128	;0080H
	*** 00003e	2a e4 			sub	ah,ah
	*** 000040	6a 00 			push	0
	*** 000042	50 			push	ax
	*** 000043	e8 00 00 		call	?Print@@YAXK@Z	; Print
	*** 000046	83 c4 04 		add	sp,4
;|*** 
;|*** 	if (sector)
; Line 75
	*** 000049	0b f6 			or	si,si
	*** 00004b	74 0c 			je	SHORT $I1409
;|*** 	{
;|*** 		Print (" Sector:");
; Line 77
	*** 00004d	68 00 00 		push	OFFSET DGROUP:??_C@_08NNOK@?5Sector?3?$AA@
	*** 000050	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000053	5b 			pop	bx
;|*** 		Print (*sector);
; Line 78
	*** 000054	56 			push	si
	*** 000055	e8 00 00 		call	?Print@@YAXABTUINT64_STRUCT@@@Z	; Print
	*** 000058	5b 			pop	bx
;|*** 	}
;|*** 
;|*** 	if (chs)
; Line 81
					$I1409:
	*** 000059	83 7e 0c 00 		cmp	WORD PTR [bp+12],0	;chs
	*** 00005d	74 0e 			je	SHORT $I1411
;|*** 	{
;|*** 		Print (" CHS:");
; Line 83
	*** 00005f	68 00 00 		push	OFFSET DGROUP:??_C@_05CLDD@?5CHS?3?$AA@
	*** 000062	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000065	5b 			pop	bx
;|*** 		Print (*chs);
; Line 84
	*** 000066	ff 76 0c 		push	WORD PTR [bp+12]	;chs
	*** 000069	e8 00 00 		call	?Print@@YAXABUChsAddress@@@Z	; Print
	*** 00006c	5b 			pop	bx
;|*** 	}
;|*** 
;|*** 	PrintEndl();
; Line 87
					$I1411:
	*** 00006d	e8 00 00 		call	?PrintEndl@@YAXXZ	; PrintEndl
;|*** 	Beep();
; Line 88
	*** 000070	e8 00 00 		call	?Beep@@YAXXZ	; Beep
;|*** }
; Line 89
	*** 000073	5e 			pop	si
	*** 000074	c9 			leave	
	*** 000075	c3 			ret	

?PrintDiskError@@YAXEDEPBTUINT64_STRUCT@@PBUChsAddress@@@Z	ENDP
	PUBLIC	?Print@@YAXABUChsAddress@@@Z	; Print
?Print@@YAXABUChsAddress@@@Z	PROC NEAR	; Print COMDAT
;|*** 
;|*** 
;|*** void Print (const ChsAddress &chs)
;|*** {
; Line 93
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
	*** 000003	56 			push	si
;	chs = 4
	*** 000004	8b 76 04 		mov	si,WORD PTR [bp+4]	;chs
;|*** 	Print (chs.Cylinder);
; Line 94
	*** 000007	6a 00 			push	0
	*** 000009	ff 34 			push	WORD PTR [si]
	*** 00000b	e8 00 00 		call	?Print@@YAXK@Z	; Print
	*** 00000e	83 c4 04 		add	sp,4
;|*** 	PrintChar ('/');
; Line 95
	*** 000011	6a 2f 			push	47	;002fH
	*** 000013	e8 00 00 		call	?PrintChar@@YAXD@Z	; PrintChar
	*** 000016	5b 			pop	bx
;|*** 	Print (chs.Head);
; Line 96
	*** 000017	8a 44 02 		mov	al,BYTE PTR [si+2]
	*** 00001a	2a e4 			sub	ah,ah
	*** 00001c	6a 00 			push	0
	*** 00001e	50 			push	ax
	*** 00001f	e8 00 00 		call	?Print@@YAXK@Z	; Print
	*** 000022	83 c4 04 		add	sp,4
;|*** 	PrintChar ('/');
; Line 97
	*** 000025	6a 2f 			push	47	;002fH
	*** 000027	e8 00 00 		call	?PrintChar@@YAXD@Z	; PrintChar
	*** 00002a	5b 			pop	bx
;|*** 	Print (chs.Sector);
; Line 98
	*** 00002b	8a 44 03 		mov	al,BYTE PTR [si+3]
	*** 00002e	2a e4 			sub	ah,ah
	*** 000030	6a 00 			push	0
	*** 000032	50 			push	ax
	*** 000033	e8 00 00 		call	?Print@@YAXK@Z	; Print
	*** 000036	83 c4 04 		add	sp,4
;|*** }
; Line 99
	*** 000039	5e 			pop	si
	*** 00003a	c9 			leave	
	*** 00003b	c3 			ret	

?Print@@YAXABUChsAddress@@@Z	ENDP
	PUBLIC	?PrintSectorCountInMB@@YAXABTUINT64_STRUCT@@@Z	; PrintSectorCountInMB
?PrintSectorCountInMB@@YAXABTUINT64_STRUCT@@@Z	PROC NEAR	; PrintSectorCountInMB COMDAT
;|*** 
;|*** 
;|*** void PrintSectorCountInMB (const uint64 &sectorCount)
;|*** {
; Line 103
	*** 000000	c8 08 00 00 		enter	8,0
;	sectorCount = 4
;|*** 	Print (sectorCount >> (TC_LB_SIZE_BIT_SHIFT_DIVISOR + 2)); Print (" MB ");
; Line 104
	*** 000004	6a 0b 			push	11	;000bH
	*** 000006	ff 76 04 		push	WORD PTR [bp+4]	;sectorCount
	*** 000009	8d 46 f8 		lea	ax,WORD PTR [bp-8]
	*** 00000c	50 			push	ax
	*** 00000d	e8 00 00 		call	??5@YA?ATUINT64_STRUCT@@ABT0@H@Z	; operator>>
	*** 000010	83 c4 06 		add	sp,6
	*** 000013	50 			push	ax
	*** 000014	e8 00 00 		call	?Print@@YAXABTUINT64_STRUCT@@@Z	; Print
	*** 000017	5b 			pop	bx
	*** 000018	68 00 00 		push	OFFSET DGROUP:??_C@_04HAAB@?5MB?5?$AA@
	*** 00001b	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 00001e	5b 			pop	bx
;|*** }
; Line 105
	*** 00001f	c9 			leave	
	*** 000020	c3 			ret	

?PrintSectorCountInMB@@YAXABTUINT64_STRUCT@@@Z	ENDP
	PUBLIC	?ReadWriteSectors@@YAEDIIEABUChsAddress@@ED@Z	; ReadWriteSectors
?ReadWriteSectors@@YAEDIIEABUChsAddress@@ED@Z	PROC NEAR	; ReadWriteSectors COMDAT
;|*** 
;|*** 
;|*** BiosResult ReadWriteSectors (bool write, uint16 bufferSegment, uint16 bufferOffset, byte drive, const ChsAddress &chs, byte sectorCount, bool silent)
;|*** {
; Line 109
	*** 000000	c8 0a 00 00 		enter	10,0
	*** 000004	56 			push	si
;	cylinderLow = -2
;	sector = -4
;	function = -6
;	result = -8
;	tryCount = -10
;	silent = 16
;	sectorCount = 14
;	chs = 12
;	drive = 10
;	bufferOffset = 8
;	bufferSegment = 6
;	write = 4
;|*** 	CheckStack();
;|*** 
;|*** 	byte cylinderLow = (byte) chs.Cylinder;
; Line 112
	*** 000005	8b 5e 0c 		mov	bx,WORD PTR [bp+12]	;chs
	*** 000008	8a 07 			mov	al,BYTE PTR [bx]
	*** 00000a	88 46 fe 		mov	BYTE PTR [bp-2],al	;cylinderLow
;|*** 	byte sector = chs.Sector;
;|*** 	sector |= byte (chs.Cylinder >> 2) & 0xc0;
; Line 114
	*** 00000d	8b 07 			mov	ax,WORD PTR [bx]
	*** 00000f	c1 e8 02 		shr	ax,2
	*** 000012	24 c0 			and	al,192	;00c0H
	*** 000014	0a 47 03 		or	al,BYTE PTR [bx+3]
	*** 000017	88 46 fc 		mov	BYTE PTR [bp-4],al	;sector
;|*** 	byte function = write ? 0x03 : 0x02;
; Line 115
	*** 00001a	80 7e 04 01 		cmp	BYTE PTR [bp+4],1	;write
	*** 00001e	1a c0 			sbb	al,al
	*** 000020	24 ff 			and	al,255	;00ffH
	*** 000022	04 03 			add	al,3
	*** 000024	88 46 fa 		mov	BYTE PTR [bp-6],al	;function
;|*** 
;|*** 	BiosResult result;
;|*** 	byte tryCount = TC_MAX_BIOS_DISK_IO_RETRIES;
; Line 118
	*** 000027	c6 46 f6 05 		mov	BYTE PTR [bp-10],5	;tryCount
;|*** 
;|*** 	do
; Line 120
					$D1434:
;|*** 	{
;|*** 		result = BiosResultSuccess;
; Line 122
	*** 00002b	c6 46 f8 00 		mov	BYTE PTR [bp-8],0	;result
;|*** 
;|*** 		__asm
;|*** 		{
;|*** 			push es
; Line 126
	*** 00002f	06 			push	es
;|*** 			mov ax, bufferSegment
; Line 127
	*** 000030	8b 46 06 		mov	ax,WORD PTR [bp+6]	;bufferSegment
;|*** 			mov	es, ax
; Line 128
	*** 000033	8e c0 			mov	es,ax
;|*** 			mov	bx, bufferOffset
; Line 129
	*** 000035	8b 5e 08 		mov	bx,WORD PTR [bp+8]	;bufferOffset
;|*** 			mov dl, drive
; Line 130
	*** 000038	8a 56 0a 		mov	dl,BYTE PTR [bp+10]	;drive
;|*** 			mov ch, cylinderLow
; Line 131
	*** 00003b	8a 6e fe 		mov	ch,BYTE PTR [bp-2]	;cylinderLow
;|*** 			mov si, chs
; Line 132
	*** 00003e	8b 76 0c 		mov	si,WORD PTR [bp+12]	;chs
;|*** 			mov dh, [si].Head
; Line 133
	*** 000041	8a 74 02 		mov	dh,BYTE PTR [si+2]
;|*** 			mov cl, sector
; Line 134
	*** 000044	8a 4e fc 		mov	cl,BYTE PTR [bp-4]	;sector
;|*** 			mov	al, sectorCount
; Line 135
	*** 000047	8a 46 0e 		mov	al,BYTE PTR [bp+14]	;sectorCount
;|*** 			mov	ah, function
; Line 136
	*** 00004a	8a 66 fa 		mov	ah,BYTE PTR [bp-6]	;function
;|*** 			int	0x13
; Line 137
	*** 00004d	cd 13 			int	19	;0013H
;|*** 			jnc ok				// If CF=0, ignore AH to prevent issues caused by potential bugs in BIOSes
; Line 138
	*** 00004f	73 03 			jae	SHORT $ok1437
;|*** 			mov	result, ah
; Line 139
	*** 000051	88 66 f8 		mov	BYTE PTR [bp-8],ah	;result
;|*** 		ok:
; Line 140
					$ok1437:
;|*** 			pop es
; Line 141
	*** 000054	07 			pop	es
;|*** 		}
; Line 142
;|*** 
;|*** 		if (result == BiosResultEccCorrected)
; Line 144
	*** 000055	80 7e f8 11 		cmp	BYTE PTR [bp-8],17	;0011H	;result
	*** 000059	75 04 			jne	SHORT $I1438
;|*** 			result = BiosResultSuccess;
; Line 145
	*** 00005b	c6 46 f8 00 		mov	BYTE PTR [bp-8],0	;result
;|*** 
;|*** 	// Some BIOSes report I/O errors prematurely in some cases
;|*** 	} while (result != BiosResultSuccess && --tryCount != 0);
; Line 148
					$I1438:
	*** 00005f	80 7e f8 00 		cmp	BYTE PTR [bp-8],0	;result
	*** 000063	74 05 			je	SHORT $D1439
	*** 000065	fe 4e f6 		dec	BYTE PTR [bp-10]	;tryCount
	*** 000068	75 c1 			jne	SHORT $D1434
					$D1439:
;|*** 
;|*** 	if (!silent && result != BiosResultSuccess)
; Line 150
	*** 00006a	80 7e 10 00 		cmp	BYTE PTR [bp+16],0	;silent
	*** 00006e	75 1d 			jne	SHORT $I1440
	*** 000070	80 7e f8 00 		cmp	BYTE PTR [bp-8],0	;result
	*** 000074	74 17 			je	SHORT $I1440
;|*** 		PrintDiskError (result, write, drive, nullptr, &chs);
; Line 151
	*** 000076	ff 76 0c 		push	WORD PTR [bp+12]	;chs
	*** 000079	6a 00 			push	0
	*** 00007b	8a 46 0a 		mov	al,BYTE PTR [bp+10]	;drive
	*** 00007e	50 			push	ax
	*** 00007f	8a 46 04 		mov	al,BYTE PTR [bp+4]	;write
	*** 000082	50 			push	ax
	*** 000083	8a 46 f8 		mov	al,BYTE PTR [bp-8]	;result
	*** 000086	50 			push	ax
	*** 000087	e8 00 00 		call	?PrintDiskError@@YAXEDEPBTUINT64_STRUCT@@PBUChsAddress@@@Z	; PrintDiskError
	*** 00008a	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|*** 	return result;
; Line 153
					$I1440:
	*** 00008d	8a 46 f8 		mov	al,BYTE PTR [bp-8]	;result
;|*** }
; Line 154
	*** 000090	5e 			pop	si
	*** 000091	c9 			leave	
	*** 000092	c3 			ret	

?ReadWriteSectors@@YAEDIIEABUChsAddress@@ED@Z	ENDP
	PUBLIC	?ReadWriteSectors@@YAEDPAEEABUChsAddress@@ED@Z	; ReadWriteSectors
?ReadWriteSectors@@YAEDPAEEABUChsAddress@@ED@Z	PROC NEAR	; ReadWriteSectors COMDAT
;|*** 
;|*** 
;|*** BiosResult ReadWriteSectors (bool write, byte *buffer, byte drive, const ChsAddress &chs, byte sectorCount, bool silent)
;|*** {
; Line 158
	*** 000000	c8 02 00 00 		enter	2,0
;	codeSeg = -2
;	silent = 14
;	sectorCount = 12
;	chs = 10
;	drive = 8
;	buffer = 6
;	write = 4
;|*** 	uint16 codeSeg;
;|*** 	__asm mov codeSeg, cs
; Line 160
	*** 000004	8c 4e fe 		mov	WORD PTR [bp-2],cs	;codeSeg
;|*** 	return ReadWriteSectors (write, codeSeg, (uint16) buffer, drive, chs, sectorCount, silent);
; Line 161
	*** 000007	8a 46 0e 		mov	al,BYTE PTR [bp+14]	;silent
	*** 00000a	50 			push	ax
	*** 00000b	8a 46 0c 		mov	al,BYTE PTR [bp+12]	;sectorCount
	*** 00000e	50 			push	ax
	*** 00000f	ff 76 0a 		push	WORD PTR [bp+10]	;chs
	*** 000012	8a 46 08 		mov	al,BYTE PTR [bp+8]	;drive
	*** 000015	50 			push	ax
	*** 000016	ff 76 06 		push	WORD PTR [bp+6]	;buffer
	*** 000019	ff 76 fe 		push	WORD PTR [bp-2]	;codeSeg
	*** 00001c	8a 46 04 		mov	al,BYTE PTR [bp+4]	;write
	*** 00001f	50 			push	ax
	*** 000020	e8 00 00 		call	?ReadWriteSectors@@YAEDIIEABUChsAddress@@ED@Z	; ReadWriteSectors
;|*** }
; Line 162
	*** 000023	c9 			leave	
	*** 000024	c3 			ret	

?ReadWriteSectors@@YAEDPAEEABUChsAddress@@ED@Z	ENDP
	PUBLIC	?ReadSectors@@YAEPAEEABUChsAddress@@ED@Z	; ReadSectors
?ReadSectors@@YAEPAEEABUChsAddress@@ED@Z	PROC NEAR	; ReadSectors COMDAT
;|*** 
;|*** 
;|*** BiosResult ReadSectors (byte *buffer, byte drive, const ChsAddress &chs, byte sectorCount, bool silent)
;|*** {
; Line 166
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;	buffer = 4
;	drive = 6
;	chs = 8
;	sectorCount = 10
;	silent = 12
;|*** 	return ReadWriteSectors (false, buffer, drive, chs, sectorCount, silent);
; Line 167
	*** 000003	8a 46 0c 		mov	al,BYTE PTR [bp+12]	;silent
	*** 000006	50 			push	ax
	*** 000007	8a 46 0a 		mov	al,BYTE PTR [bp+10]	;sectorCount
	*** 00000a	50 			push	ax
	*** 00000b	ff 76 08 		push	WORD PTR [bp+8]	;chs
	*** 00000e	8a 46 06 		mov	al,BYTE PTR [bp+6]	;drive
	*** 000011	50 			push	ax
	*** 000012	ff 76 04 		push	WORD PTR [bp+4]	;buffer
	*** 000015	6a 00 			push	0
	*** 000017	e8 00 00 		call	?ReadWriteSectors@@YAEDPAEEABUChsAddress@@ED@Z	; ReadWriteSectors
;|*** }
; Line 168
	*** 00001a	c9 			leave	
	*** 00001b	c3 			ret	

?ReadSectors@@YAEPAEEABUChsAddress@@ED@Z	ENDP
	PUBLIC	?WriteSectors@@YAEPAEEABUChsAddress@@ED@Z	; WriteSectors
?WriteSectors@@YAEPAEEABUChsAddress@@ED@Z	PROC NEAR	; WriteSectors COMDAT
;|*** 
;|*** 
;|*** BiosResult WriteSectors (byte *buffer, byte drive, const ChsAddress &chs, byte sectorCount, bool silent)
;|*** {
; Line 172
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;	buffer = 4
;	drive = 6
;	chs = 8
;	sectorCount = 10
;	silent = 12
;|*** 	return ReadWriteSectors (true, buffer, drive, chs, sectorCount, silent);
; Line 173
	*** 000003	8a 46 0c 		mov	al,BYTE PTR [bp+12]	;silent
	*** 000006	50 			push	ax
	*** 000007	8a 46 0a 		mov	al,BYTE PTR [bp+10]	;sectorCount
	*** 00000a	50 			push	ax
	*** 00000b	ff 76 08 		push	WORD PTR [bp+8]	;chs
	*** 00000e	8a 46 06 		mov	al,BYTE PTR [bp+6]	;drive
	*** 000011	50 			push	ax
	*** 000012	ff 76 04 		push	WORD PTR [bp+4]	;buffer
	*** 000015	6a 01 			push	1
	*** 000017	e8 00 00 		call	?ReadWriteSectors@@YAEDPAEEABUChsAddress@@ED@Z	; ReadWriteSectors
;|*** }
; Line 174
	*** 00001a	c9 			leave	
	*** 00001b	c3 			ret	

?WriteSectors@@YAEPAEEABUChsAddress@@ED@Z	ENDP

?ReadWriteSectors@@YAEDAAUBiosLbaPacket@@EABTUINT64_STRUCT@@ID@Z	PROC NEAR	; ReadWriteSectors COMDAT
;|*** 
;|*** 
;|*** static BiosResult ReadWriteSectors (bool write, BiosLbaPacket &dapPacket, byte drive, const uint64 &sector, uint16 sectorCount, bool silent)
;|*** {
; Line 178
	*** 000000	c8 10 00 00 		enter	16,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	function = -2
;	result = -4
;	tryCount = -6
;	silent = 14
;	sectorCount = 12
;	sector = 10
;	drive = 8
;	dapPacket = 6
;	write = 4
;|*** 	CheckStack();
;|*** 
;|*** 	if (!IsLbaSupported (drive))
; Line 181
	*** 000006	8a 46 08 		mov	al,BYTE PTR [bp+8]	;drive
	*** 000009	50 			push	ax
	*** 00000a	e8 00 00 		call	?IsLbaSupported@@YADE@Z	; IsLbaSupported
	*** 00000d	5b 			pop	bx
	*** 00000e	0a c0 			or	al,al
	*** 000010	75 52 			jne	SHORT $I1471
;|*** 	{
; Line 182
;	geometry = -10
;	result = -12
;	chs = -16
;|*** 		DriveGeometry geometry;
;|*** 
;|*** 		BiosResult result = GetDriveGeometry (drive, geometry, silent);
;|*** 		if (result != BiosResultSuccess)
; Line 186
	*** 000012	8a 46 0e 		mov	al,BYTE PTR [bp+14]	;silent
	*** 000015	50 			push	ax
	*** 000016	8d 46 f6 		lea	ax,WORD PTR [bp-10]	;geometry
	*** 000019	50 			push	ax
	*** 00001a	8a 46 08 		mov	al,BYTE PTR [bp+8]	;drive
	*** 00001d	50 			push	ax
	*** 00001e	e8 00 00 		call	?GetDriveGeometry@@YAEEAAUDriveGeometry@@D@Z	; GetDriveGeometry
	*** 000021	83 c4 06 		add	sp,6
	*** 000024	88 46 f4 		mov	BYTE PTR [bp-12],al	;result
	*** 000027	0a c0 			or	al,al
	*** 000029	0f 85 ba 00 		jne	$EX1470
;|*** 			return result;
;|*** 
;|*** 		ChsAddress chs;
;|*** 		LbaToChs (geometry, sector, chs);
; Line 190
	*** 00002d	8d 46 f0 		lea	ax,WORD PTR [bp-16]	;chs
	*** 000030	50 			push	ax
	*** 000031	ff 76 0a 		push	WORD PTR [bp+10]	;sector
	*** 000034	8d 4e f6 		lea	cx,WORD PTR [bp-10]	;geometry
	*** 000037	51 			push	cx
	*** 000038	e8 00 00 		call	?LbaToChs@@YAXABUDriveGeometry@@ABTUINT64_STRUCT@@AAUChsAddress@@@Z	; LbaToChs
	*** 00003b	83 c4 06 		add	sp,6
;|*** 		return ReadWriteSectors (write, (uint16) (dapPacket.Buffer >> 16), (uint16) dapPacket.Buffer, drive, chs, sectorCount, silent);
; Line 191
	*** 00003e	8a 46 0e 		mov	al,BYTE PTR [bp+14]	;silent
	*** 000041	50 			push	ax
	*** 000042	8a 46 0c 		mov	al,BYTE PTR [bp+12]	;sectorCount
	*** 000045	50 			push	ax
	*** 000046	8d 46 f0 		lea	ax,WORD PTR [bp-16]	;chs
	*** 000049	50 			push	ax
	*** 00004a	8a 46 08 		mov	al,BYTE PTR [bp+8]	;drive
	*** 00004d	50 			push	ax
	*** 00004e	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;dapPacket
	*** 000051	ff 77 04 		push	WORD PTR [bx+4]
	*** 000054	ff 77 06 		push	WORD PTR [bx+6]
	*** 000057	8a 46 04 		mov	al,BYTE PTR [bp+4]	;write
	*** 00005a	50 			push	ax
	*** 00005b	e8 00 00 		call	?ReadWriteSectors@@YAEDIIEABUChsAddress@@ED@Z	; ReadWriteSectors
	*** 00005e	83 c4 0e 		add	sp,14	;000eH
	*** 000061	e9 83 00 		jmp	$EX1470
;|*** 	}
;|*** 
;|*** 	dapPacket.Size = sizeof (dapPacket);
; Line 194
					$I1471:
	*** 000064	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;dapPacket
	*** 000067	c6 07 10 		mov	BYTE PTR [bx],16	;0010H
;|*** 	dapPacket.Reserved = 0;
; Line 195
	*** 00006a	c6 47 01 00 		mov	BYTE PTR [bx+1],0
;|*** 	dapPacket.SectorCount = sectorCount;
; Line 196
	*** 00006e	8b 46 0c 		mov	ax,WORD PTR [bp+12]	;sectorCount
	*** 000071	89 47 02 		mov	WORD PTR [bx+2],ax
;|*** 	dapPacket.Sector = sector;
; Line 197
	*** 000074	8b 46 0a 		mov	ax,WORD PTR [bp+10]	;sector
	*** 000077	8d 7f 08 		lea	di,WORD PTR [bx+8]
	*** 00007a	8b f0 			mov	si,ax
	*** 00007c	1e 			push	ds
	*** 00007d	07 			pop	es
	*** 00007e	66 a5 			movsd
	*** 000080	66 a5 			movsd
;|*** 
;|*** 	byte function = write ? 0x43 : 0x42;
; Line 199
	*** 000082	80 7e 04 01 		cmp	BYTE PTR [bp+4],1	;write
	*** 000086	1a c0 			sbb	al,al
	*** 000088	24 ff 			and	al,255	;00ffH
	*** 00008a	04 43 			add	al,67	;0043H
	*** 00008c	88 46 fe 		mov	BYTE PTR [bp-2],al	;function
;|*** 	
;|*** 	BiosResult result;
;|*** 	byte tryCount = TC_MAX_BIOS_DISK_IO_RETRIES;
; Line 202
	*** 00008f	c6 46 fa 05 		mov	BYTE PTR [bp-6],5	;tryCount
;|*** 
;|*** 	do
; Line 204
					$D1481:
;|*** 	{
;|*** 		result = BiosResultSuccess;
; Line 206
	*** 000093	c6 46 fc 00 		mov	BYTE PTR [bp-4],0	;result
;|*** 
;|*** 		__asm
;|*** 		{
;|*** 			mov	bx, 0x55aa
; Line 210
	*** 000097	bb aa 55 		mov	bx,21930	;55aaH
;|*** 			mov	dl, drive
; Line 211
	*** 00009a	8a 56 08 		mov	dl,BYTE PTR [bp+8]	;drive
;|*** 			mov si, [dapPacket]
; Line 212
	*** 00009d	8b 76 06 		mov	si,WORD PTR [bp+6]	;dapPacket
;|*** 			mov	ah, function
; Line 213
	*** 0000a0	8a 66 fe 		mov	ah,BYTE PTR [bp-2]	;function
;|*** 			xor al, al
; Line 214
	*** 0000a3	32 c0 			xor	al,al
;|*** 			int	0x13
; Line 215
	*** 0000a5	cd 13 			int	19	;0013H
;|*** 			jnc ok				// If CF=0, ignore AH to prevent issues caused by potential bugs in BIOSes
; Line 216
	*** 0000a7	73 03 			jae	SHORT $ok1484
;|*** 			mov	result, ah
; Line 217
	*** 0000a9	88 66 fc 		mov	BYTE PTR [bp-4],ah	;result
;|*** 		ok:
; Line 218
					$ok1484:
;|*** 		}
; Line 219
;|*** 
;|*** 		if (result == BiosResultEccCorrected)
; Line 221
	*** 0000ac	80 7e fc 11 		cmp	BYTE PTR [bp-4],17	;0011H	;result
	*** 0000b0	75 04 			jne	SHORT $I1485
;|*** 			result = BiosResultSuccess;
; Line 222
	*** 0000b2	c6 46 fc 00 		mov	BYTE PTR [bp-4],0	;result
;|*** 
;|*** 	// Some BIOSes report I/O errors prematurely in some cases
;|*** 	} while (result != BiosResultSuccess && --tryCount != 0);
; Line 225
					$I1485:
	*** 0000b6	80 7e fc 00 		cmp	BYTE PTR [bp-4],0	;result
	*** 0000ba	74 05 			je	SHORT $D1486
	*** 0000bc	fe 4e fa 		dec	BYTE PTR [bp-6]	;tryCount
	*** 0000bf	75 d2 			jne	SHORT $D1481
					$D1486:
;|*** 
;|*** 	if (!silent && result != BiosResultSuccess)
; Line 227
	*** 0000c1	80 7e 0e 00 		cmp	BYTE PTR [bp+14],0	;silent
	*** 0000c5	75 1d 			jne	SHORT $I1487
	*** 0000c7	80 7e fc 00 		cmp	BYTE PTR [bp-4],0	;result
	*** 0000cb	74 17 			je	SHORT $I1487
;|*** 		PrintDiskError (result, write, drive, &sector);
; Line 228
	*** 0000cd	6a 00 			push	0
	*** 0000cf	ff 76 0a 		push	WORD PTR [bp+10]	;sector
	*** 0000d2	8a 46 08 		mov	al,BYTE PTR [bp+8]	;drive
	*** 0000d5	50 			push	ax
	*** 0000d6	8a 46 04 		mov	al,BYTE PTR [bp+4]	;write
	*** 0000d9	50 			push	ax
	*** 0000da	8a 46 fc 		mov	al,BYTE PTR [bp-4]	;result
	*** 0000dd	50 			push	ax
	*** 0000de	e8 00 00 		call	?PrintDiskError@@YAXEDEPBTUINT64_STRUCT@@PBUChsAddress@@@Z	; PrintDiskError
	*** 0000e1	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|*** 	return result;
; Line 230
					$I1487:
	*** 0000e4	8a 46 fc 		mov	al,BYTE PTR [bp-4]	;result
;|*** }
; Line 231
					$EX1470:
	*** 0000e7	5e 			pop	si
	*** 0000e8	5f 			pop	di
	*** 0000e9	c9 			leave	
	*** 0000ea	c3 			ret	

?ReadWriteSectors@@YAEDAAUBiosLbaPacket@@EABTUINT64_STRUCT@@ID@Z	ENDP

?ReadWriteSectors@@YAEDPAEEABTUINT64_STRUCT@@ID@Z	PROC NEAR	; ReadWriteSectors COMDAT
;|*** 
;|*** 
;|*** static BiosResult ReadWriteSectors (bool write, byte *buffer, byte drive, const uint64 &sector, uint16 sectorCount, bool silent)
;|*** {
; Line 235
	*** 000000	c8 10 00 00 		enter	16,0
;	write = 4
;	buffer = 6
;	drive = 8
;	sector = 10
;	sectorCount = 12
;	silent = 14
;	dapPacket = -16
;|*** 	BiosLbaPacket dapPacket;
;|*** 	dapPacket.Buffer = (uint32) buffer;
; Line 237
	*** 000004	8b 46 06 		mov	ax,WORD PTR [bp+6]	;buffer
	*** 000007	89 46 f4 		mov	WORD PTR [bp-12],ax
	*** 00000a	8c 5e f6 		mov	WORD PTR [bp-10],ds
;|*** 	return ReadWriteSectors (write, dapPacket, drive, sector, sectorCount, silent);
; Line 238
	*** 00000d	8a 46 0e 		mov	al,BYTE PTR [bp+14]	;silent
	*** 000010	50 			push	ax
	*** 000011	66 ff 76 0a 		push	DWORD PTR [bp+10]	;sector
	*** 000015	8a 46 08 		mov	al,BYTE PTR [bp+8]	;drive
	*** 000018	50 			push	ax
	*** 000019	8d 46 f0 		lea	ax,WORD PTR [bp-16]	;dapPacket
	*** 00001c	50 			push	ax
	*** 00001d	8a 46 04 		mov	al,BYTE PTR [bp+4]	;write
	*** 000020	50 			push	ax
	*** 000021	e8 00 00 		call	?ReadWriteSectors@@YAEDAAUBiosLbaPacket@@EABTUINT64_STRUCT@@ID@Z	; ReadWriteSectors
;|*** }
; Line 239
	*** 000024	c9 			leave	
	*** 000025	c3 			ret	

?ReadWriteSectors@@YAEDPAEEABTUINT64_STRUCT@@ID@Z	ENDP
	PUBLIC	?ReadWriteSectors@@YAEDIIEABTUINT64_STRUCT@@ID@Z	; ReadWriteSectors
?ReadWriteSectors@@YAEDIIEABTUINT64_STRUCT@@ID@Z	PROC NEAR	; ReadWriteSectors COMDAT
;|*** 
;|*** 
;|*** BiosResult ReadWriteSectors (bool write, uint16 bufferSegment, uint16 bufferOffset, byte drive, const uint64 &sector, uint16 sectorCount, bool silent)
;|*** {
; Line 243
	*** 000000	c8 10 00 00 		enter	16,0
;	write = 4
;	bufferSegment = 6
;	bufferOffset = 8
;	drive = 10
;	sector = 12
;	sectorCount = 14
;	silent = 16
;	dapPacket = -16
;|*** 	BiosLbaPacket dapPacket;
;|*** 	dapPacket.Buffer = ((uint32) bufferSegment << 16) | bufferOffset;
; Line 245
	*** 000004	8b 46 06 		mov	ax,WORD PTR [bp+6]	;bufferSegment
	*** 000007	8b 4e 08 		mov	cx,WORD PTR [bp+8]	;bufferOffset
	*** 00000a	89 4e f4 		mov	WORD PTR [bp-12],cx
	*** 00000d	89 46 f6 		mov	WORD PTR [bp-10],ax
;|*** 	return ReadWriteSectors (write, dapPacket, drive, sector, sectorCount, silent);
; Line 246
	*** 000010	8a 46 10 		mov	al,BYTE PTR [bp+16]	;silent
	*** 000013	50 			push	ax
	*** 000014	66 ff 76 0c 		push	DWORD PTR [bp+12]	;sector
	*** 000018	8a 46 0a 		mov	al,BYTE PTR [bp+10]	;drive
	*** 00001b	50 			push	ax
	*** 00001c	8d 46 f0 		lea	ax,WORD PTR [bp-16]	;dapPacket
	*** 00001f	50 			push	ax
	*** 000020	8a 46 04 		mov	al,BYTE PTR [bp+4]	;write
	*** 000023	50 			push	ax
	*** 000024	e8 00 00 		call	?ReadWriteSectors@@YAEDAAUBiosLbaPacket@@EABTUINT64_STRUCT@@ID@Z	; ReadWriteSectors
;|*** }
; Line 247
	*** 000027	c9 			leave	
	*** 000028	c3 			ret	

?ReadWriteSectors@@YAEDIIEABTUINT64_STRUCT@@ID@Z	ENDP
	PUBLIC	?ReadSectors@@YAEIIEABTUINT64_STRUCT@@ID@Z	; ReadSectors
?ReadSectors@@YAEIIEABTUINT64_STRUCT@@ID@Z	PROC NEAR	; ReadSectors COMDAT
;|*** 
;|*** BiosResult ReadSectors (uint16 bufferSegment, uint16 bufferOffset, byte drive, const uint64 &sector, uint16 sectorCount, bool silent)
;|*** {
; Line 250
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;	bufferSegment = 4
;	bufferOffset = 6
;	drive = 8
;	sector = 10
;	sectorCount = 12
;	silent = 14
;|*** 	return ReadWriteSectors (false, bufferSegment, bufferOffset, drive, sector, sectorCount, silent);
; Line 251
	*** 000003	8a 46 0e 		mov	al,BYTE PTR [bp+14]	;silent
	*** 000006	50 			push	ax
	*** 000007	66 ff 76 0a 		push	DWORD PTR [bp+10]	;sector
	*** 00000b	8a 46 08 		mov	al,BYTE PTR [bp+8]	;drive
	*** 00000e	50 			push	ax
	*** 00000f	66 ff 76 04 		push	DWORD PTR [bp+4]	;bufferSegment
	*** 000013	6a 00 			push	0
	*** 000015	e8 00 00 		call	?ReadWriteSectors@@YAEDIIEABTUINT64_STRUCT@@ID@Z	; ReadWriteSectors
;|*** }
; Line 252
	*** 000018	c9 			leave	
	*** 000019	c3 			ret	

?ReadSectors@@YAEIIEABTUINT64_STRUCT@@ID@Z	ENDP
	PUBLIC	?ReadSectors@@YAEPAEEABTUINT64_STRUCT@@ID@Z	; ReadSectors
?ReadSectors@@YAEPAEEABTUINT64_STRUCT@@ID@Z	PROC NEAR	; ReadSectors COMDAT
;|*** 
;|*** 
;|*** BiosResult ReadSectors (byte *buffer, byte drive, const uint64 &sector, uint16 sectorCount, bool silent)
;|*** {
; Line 256
	*** 000000	c8 06 00 00 		enter	6,0
;	result = -2
;	codeSeg = -4
;	silent = 12
;	sectorCount = 10
;	sector = 8
;	drive = 6
;	buffer = 4
;|*** 	BiosResult result;
;|*** 	uint16 codeSeg;
;|*** 	__asm mov codeSeg, cs
; Line 259
	*** 000004	8c 4e fc 		mov	WORD PTR [bp-4],cs	;codeSeg
;|*** 	
;|*** 	result = ReadSectors (BootStarted ? codeSeg : TC_BOOT_LOADER_ALT_SEGMENT, (uint16) buffer, drive, sector, sectorCount, silent);
; Line 261
	*** 000007	8a 46 0c 		mov	al,BYTE PTR [bp+12]	;silent
	*** 00000a	50 			push	ax
	*** 00000b	66 ff 76 08 		push	DWORD PTR [bp+8]	;sector
	*** 00000f	8a 46 06 		mov	al,BYTE PTR [bp+6]	;drive
	*** 000012	50 			push	ax
	*** 000013	ff 76 04 		push	WORD PTR [bp+4]	;buffer
	*** 000016	80 3e 00 00 00 		cmp	BYTE PTR ?BootStarted@@3DA,0	;BootStarted
	*** 00001b	74 05 			je	SHORT $L1632
	*** 00001d	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;codeSeg
	*** 000020	eb 03 			jmp	SHORT $L1633
					$L1632:
	*** 000022	b8 00 60 		mov	ax,24576	;6000H
					$L1633:
	*** 000025	50 			push	ax
	*** 000026	e8 00 00 		call	?ReadSectors@@YAEIIEABTUINT64_STRUCT@@ID@Z	; ReadSectors
	*** 000029	83 c4 0c 		add	sp,12	;000cH
	*** 00002c	88 46 fe 		mov	BYTE PTR [bp-2],al	;result
;|*** 
;|*** 	// Alternative segment is used to prevent memory corruption caused by buggy BIOSes
;|*** 	if (!BootStarted)
; Line 264
	*** 00002f	80 3e 00 00 00 		cmp	BYTE PTR ?BootStarted@@3DA,0	;BootStarted
	*** 000034	75 13 			jne	SHORT $I1524
;|*** 		CopyMemory (TC_BOOT_LOADER_ALT_SEGMENT, (uint16) buffer, buffer, sectorCount * TC_LB_SIZE);
; Line 265
	*** 000036	8b 46 0a 		mov	ax,WORD PTR [bp+10]	;sectorCount
	*** 000039	c1 e0 09 		shl	ax,9
	*** 00003c	50 			push	ax
	*** 00003d	ff 76 04 		push	WORD PTR [bp+4]	;buffer
	*** 000040	ff 76 04 		push	WORD PTR [bp+4]	;buffer
	*** 000043	68 00 60 		push	24576	;6000H
	*** 000046	e8 00 00 		call	?CopyMemory@@YAXIIPAXI@Z	; CopyMemory
;|*** 
;|*** 	return result;
; Line 267
					$I1524:
	*** 000049	8a 46 fe 		mov	al,BYTE PTR [bp-2]	;result
;|*** }
; Line 268
	*** 00004c	c9 			leave	
	*** 00004d	c3 			ret	

?ReadSectors@@YAEPAEEABTUINT64_STRUCT@@ID@Z	ENDP
	PUBLIC	?WriteSectors@@YAEPAEEABTUINT64_STRUCT@@ID@Z	; WriteSectors
?WriteSectors@@YAEPAEEABTUINT64_STRUCT@@ID@Z	PROC NEAR	; WriteSectors COMDAT
;|*** 
;|*** 
;|*** BiosResult WriteSectors (byte *buffer, byte drive, const uint64 &sector, uint16 sectorCount, bool silent)
;|*** {
; Line 272
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;	buffer = 4
;	drive = 6
;	sector = 8
;	sectorCount = 10
;	silent = 12
;|*** 	return ReadWriteSectors (true, buffer, drive, sector, sectorCount, silent);
; Line 273
	*** 000003	8a 46 0c 		mov	al,BYTE PTR [bp+12]	;silent
	*** 000006	50 			push	ax
	*** 000007	66 ff 76 08 		push	DWORD PTR [bp+8]	;sector
	*** 00000b	8a 46 06 		mov	al,BYTE PTR [bp+6]	;drive
	*** 00000e	50 			push	ax
	*** 00000f	ff 76 04 		push	WORD PTR [bp+4]	;buffer
	*** 000012	6a 01 			push	1
	*** 000014	e8 00 00 		call	?ReadWriteSectors@@YAEDPAEEABTUINT64_STRUCT@@ID@Z	; ReadWriteSectors
;|*** }
; Line 274
	*** 000017	c9 			leave	
	*** 000018	c3 			ret	

?WriteSectors@@YAEPAEEABTUINT64_STRUCT@@ID@Z	ENDP
	PUBLIC	?GetDriveGeometry@@YAEEAAUDriveGeometry@@D@Z	; GetDriveGeometry
?GetDriveGeometry@@YAEEAAUDriveGeometry@@D@Z	PROC NEAR	; GetDriveGeometry COMDAT
;|*** 
;|*** 
;|*** BiosResult GetDriveGeometry (byte drive, DriveGeometry &geometry, bool silent)
;|*** {
; Line 278
	*** 000000	c8 08 00 00 		enter	8,0
;	maxCylinderLow = -2
;	maxHead = -4
;	maxSector = -6
;	result = -8
;	silent = 8
;	geometry = 6
;	drive = 4
;|*** 	CheckStack();
;|*** 
;|*** 	byte maxCylinderLow, maxHead, maxSector;
;|*** 	BiosResult result;
;|*** 	__asm
;|*** 	{
;|*** 		push es
; Line 285
	*** 000004	06 			push	es
;|*** 		mov dl, drive
; Line 286
	*** 000005	8a 56 04 		mov	dl,BYTE PTR [bp+4]	;drive
;|*** 		mov ah, 0x08
; Line 287
	*** 000008	b4 08 			mov	ah,8
;|*** 		int	0x13
; Line 288
	*** 00000a	cd 13 			int	19	;0013H
;|*** 
;|*** 		mov	result, ah
; Line 290
	*** 00000c	88 66 f8 		mov	BYTE PTR [bp-8],ah	;result
;|*** 		mov maxCylinderLow, ch
; Line 291
	*** 00000f	88 6e fe 		mov	BYTE PTR [bp-2],ch	;maxCylinderLow
;|*** 		mov maxSector, cl
; Line 292
	*** 000012	88 4e fa 		mov	BYTE PTR [bp-6],cl	;maxSector
;|*** 		mov maxHead, dh
; Line 293
	*** 000015	88 76 fc 		mov	BYTE PTR [bp-4],dh	;maxHead
;|*** 		pop es
; Line 294
	*** 000018	07 			pop	es
;|*** 	}
; Line 295
;|*** 
;|*** 	if (result == BiosResultSuccess)
; Line 297
	*** 000019	80 7e f8 00 		cmp	BYTE PTR [bp-8],0	;result
	*** 00001d	75 28 			jne	SHORT $I1540
;|*** 	{
;|*** 		geometry.Cylinders = (maxCylinderLow | (uint16 (maxSector & 0xc0) << 2)) + 1;
; Line 299
	*** 00001f	8a 46 fa 		mov	al,BYTE PTR [bp-6]	;maxSector
	*** 000022	25 c0 00 		and	ax,192	;00c0H
	*** 000025	c1 e0 02 		shl	ax,2
	*** 000028	8a 4e fe 		mov	cl,BYTE PTR [bp-2]	;maxCylinderLow
	*** 00002b	2a ed 			sub	ch,ch
	*** 00002d	0b c1 			or	ax,cx
	*** 00002f	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;geometry
	*** 000032	40 			inc	ax
	*** 000033	89 07 			mov	WORD PTR [bx],ax
;|*** 		geometry.Heads = maxHead + 1;
; Line 300
	*** 000035	8a 46 fc 		mov	al,BYTE PTR [bp-4]	;maxHead
	*** 000038	fe c0 			inc	al
	*** 00003a	88 47 02 		mov	BYTE PTR [bx+2],al
;|*** 		geometry.Sectors = maxSector & ~0xc0;
; Line 301
	*** 00003d	8a 46 fa 		mov	al,BYTE PTR [bp-6]	;maxSector
	*** 000040	24 3f 			and	al,63	;003fH
	*** 000042	88 47 03 		mov	BYTE PTR [bx+3],al
;|*** 	}
;|*** 	else if (!silent)
; Line 303
	*** 000045	eb 3c 			jmp	SHORT $I1542
					$I1540:
	*** 000047	80 7e 08 00 		cmp	BYTE PTR [bp+8],0	;silent
	*** 00004b	75 36 			jne	SHORT $I1542
;|*** 	{
;|*** 		Print ("Drive ");
; Line 305
	*** 00004d	68 00 00 		push	OFFSET DGROUP:??_C@_06OLBI@Drive?5?$AA@
	*** 000050	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000053	5b 			pop	bx
;|*** 		Print (drive ^ 0x80);
; Line 306
	*** 000054	8a 46 04 		mov	al,BYTE PTR [bp+4]	;drive
	*** 000057	34 80 			xor	al,128	;0080H
	*** 000059	2a e4 			sub	ah,ah
	*** 00005b	6a 00 			push	0
	*** 00005d	50 			push	ax
	*** 00005e	e8 00 00 		call	?Print@@YAXK@Z	; Print
	*** 000061	83 c4 04 		add	sp,4
;|*** 		Print (" not found: ");
; Line 307
	*** 000064	68 00 00 		push	OFFSET DGROUP:??_C@_0N@JJKN@?5not?5found?3?5?$AA@
	*** 000067	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 00006a	5b 			pop	bx
;|*** 		PrintErrorNoEndl ("");
; Line 308
	*** 00006b	68 00 00 		push	OFFSET DGROUP:??_C@_00A@?$AA@
	*** 00006e	e8 00 00 		call	?PrintErrorNoEndl@@YAXPBD@Z	; PrintErrorNoEndl
	*** 000071	5b 			pop	bx
;|*** 		Print (result);
; Line 309
	*** 000072	8a 46 f8 		mov	al,BYTE PTR [bp-8]	;result
	*** 000075	2a e4 			sub	ah,ah
	*** 000077	6a 00 			push	0
	*** 000079	50 			push	ax
	*** 00007a	e8 00 00 		call	?Print@@YAXK@Z	; Print
	*** 00007d	83 c4 04 		add	sp,4
;|*** 		PrintEndl();
; Line 310
	*** 000080	e8 00 00 		call	?PrintEndl@@YAXXZ	; PrintEndl
;|*** 	}
;|*** 
;|*** 	return result;
; Line 313
					$I1542:
	*** 000083	8a 46 f8 		mov	al,BYTE PTR [bp-8]	;result
;|*** }
; Line 314
	*** 000086	c9 			leave	
	*** 000087	c3 			ret	

?GetDriveGeometry@@YAEEAAUDriveGeometry@@D@Z	ENDP
	PUBLIC	?ChsToLba@@YAXABUDriveGeometry@@ABUChsAddress@@AATUINT64_STRUCT@@@Z	; ChsToLba
?ChsToLba@@YAXABUDriveGeometry@@ABUChsAddress@@AATUINT64_STRUCT@@@Z	PROC NEAR	; ChsToLba COMDAT
;|*** 
;|*** 
;|*** void ChsToLba (const DriveGeometry &geometry, const ChsAddress &chs, uint64 &lba)
;|*** {
; Line 318
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
	*** 000003	57 			push	di
	*** 000004	56 			push	si
;	geometry = 4
;	chs = 6
;	lba = 8
	*** 000005	8b 7e 08 		mov	di,WORD PTR [bp+8]	;lba
	*** 000008	8b 76 06 		mov	si,WORD PTR [bp+6]	;chs
;|*** 	lba.HighPart = 0;
; Line 319
	*** 00000b	66 2b c0 		sub	eax,eax
	*** 00000e	66 89 45 04 		mov	DWORD PTR [di+4],eax
;|*** 	lba.LowPart = (uint32 (chs.Cylinder) * geometry.Heads + chs.Head) * geometry.Sectors + chs.Sector - 1;
; Line 320
	*** 000012	8b 5e 04 		mov	bx,WORD PTR [bp+4]	;geometry
	*** 000015	8a 47 03 		mov	al,BYTE PTR [bx+3]
	*** 000018	6a 00 			push	0
	*** 00001a	50 			push	ax
	*** 00001b	8a 47 02 		mov	al,BYTE PTR [bx+2]
	*** 00001e	f7 24 			mul	WORD PTR [si]
	*** 000020	8a 4c 02 		mov	cl,BYTE PTR [si+2]
	*** 000023	2a ed 			sub	ch,ch
	*** 000025	03 c1 			add	ax,cx
	*** 000027	83 d2 00 		adc	dx,0
	*** 00002a	52 			push	dx
	*** 00002b	50 			push	ax
	*** 00002c	e8 00 00 		call	__aNulmul
	*** 00002f	8a 4c 03 		mov	cl,BYTE PTR [si+3]
	*** 000032	2a ed 			sub	ch,ch
	*** 000034	03 c1 			add	ax,cx
	*** 000036	83 d2 00 		adc	dx,0
	*** 000039	2d 01 00 		sub	ax,1
	*** 00003c	83 da 00 		sbb	dx,0
	*** 00003f	89 05 			mov	WORD PTR [di],ax
	*** 000041	89 55 02 		mov	WORD PTR [di+2],dx
;|*** }
; Line 321
	*** 000044	5e 			pop	si
	*** 000045	5f 			pop	di
	*** 000046	c9 			leave	
	*** 000047	c3 			ret	

?ChsToLba@@YAXABUDriveGeometry@@ABUChsAddress@@AATUINT64_STRUCT@@@Z	ENDP
	PUBLIC	?LbaToChs@@YAXABUDriveGeometry@@ABTUINT64_STRUCT@@AAUChsAddress@@@Z	; LbaToChs
?LbaToChs@@YAXABUDriveGeometry@@ABTUINT64_STRUCT@@AAUChsAddress@@@Z	PROC NEAR	; LbaToChs COMDAT
;|*** 
;|*** 
;|*** void LbaToChs (const DriveGeometry &geometry, const uint64 &lba, ChsAddress &chs)
;|*** {
; Line 325
	*** 000000	c8 04 00 00 		enter	4,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	geometry = 4
;	lba = 6
;	chs = 8
;	ch = -4
	*** 000006	8b 76 04 		mov	si,WORD PTR [bp+4]	;geometry
	*** 000009	8b 7e 08 		mov	di,WORD PTR [bp+8]	;chs
;|*** 	chs.Sector = (byte) ((lba.LowPart % geometry.Sectors) + 1);
; Line 326
	*** 00000c	8a 44 03 		mov	al,BYTE PTR [si+3]
	*** 00000f	2a e4 			sub	ah,ah
	*** 000011	6a 00 			push	0
	*** 000013	50 			push	ax
	*** 000014	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;lba
	*** 000017	66 ff 37 		push	DWORD PTR [bx]
	*** 00001a	e8 00 00 		call	__aNulrem
	*** 00001d	fe c0 			inc	al
	*** 00001f	88 45 03 		mov	BYTE PTR [di+3],al
;|*** 	uint32 ch = lba.LowPart / geometry.Sectors;
; Line 327
	*** 000022	8a 44 03 		mov	al,BYTE PTR [si+3]
	*** 000025	2a e4 			sub	ah,ah
	*** 000027	6a 00 			push	0
	*** 000029	50 			push	ax
	*** 00002a	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;lba
	*** 00002d	66 8b 07 		mov	eax,DWORD PTR [bx]
	*** 000030	66 59 			pop	ecx
	*** 000032	66 33 d2 		xor	edx,edx
	*** 000035	66 f7 f1 		div	ecx
	*** 000038	66 89 46 fc 		mov	DWORD PTR [bp-4],eax	;ch
	*** 00003c	8b 56 fe 		mov	dx,WORD PTR [bp-2]
;|*** 	chs.Head = (byte) (ch % geometry.Heads);
; Line 328
	*** 00003f	8a 4c 02 		mov	cl,BYTE PTR [si+2]
	*** 000042	2a ed 			sub	ch,ch
	*** 000044	6a 00 			push	0
	*** 000046	51 			push	cx
	*** 000047	52 			push	dx
	*** 000048	50 			push	ax
	*** 000049	e8 00 00 		call	__aNulrem
	*** 00004c	88 45 02 		mov	BYTE PTR [di+2],al
;|*** 	chs.Cylinder = (uint16) (ch / geometry.Heads);
; Line 329
	*** 00004f	8a 44 02 		mov	al,BYTE PTR [si+2]
	*** 000052	2a e4 			sub	ah,ah
	*** 000054	6a 00 			push	0
	*** 000056	50 			push	ax
	*** 000057	66 ff 76 fc 		push	DWORD PTR [bp-4]	;ch
	*** 00005b	e8 00 00 		call	__aNuldiv
	*** 00005e	89 05 			mov	WORD PTR [di],ax
;|*** }
; Line 330
	*** 000060	5e 			pop	si
	*** 000061	5f 			pop	di
	*** 000062	c9 			leave	
	*** 000063	c3 			ret	

?LbaToChs@@YAXABUDriveGeometry@@ABTUINT64_STRUCT@@AAUChsAddress@@@Z	ENDP
	PUBLIC	?PartitionEntryMBRToPartition@@YAXABUPartitionEntryMBR@@AAUPartition@@@Z	; PartitionEntryMBRToPartition
?PartitionEntryMBRToPartition@@YAXABUPartitionEntryMBR@@AAUPartition@@@Z	PROC NEAR	; PartitionEntryMBRToPartition COMDAT
;|*** 
;|*** 
;|*** void PartitionEntryMBRToPartition (const PartitionEntryMBR &partEntry, Partition &partition)
;|*** {
; Line 334
	*** 000000	c8 04 00 00 		enter	4,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	partEntry = 4
;	partition = 6
	*** 000006	8b 7e 04 		mov	di,WORD PTR [bp+4]	;partEntry
	*** 000009	8b 76 06 		mov	si,WORD PTR [bp+6]	;partition
;|*** 	partition.Active = partEntry.BootIndicator == 0x80;
; Line 335
	*** 00000c	89 76 fe 		mov	WORD PTR [bp-2],si
	*** 00000f	89 7e fc 		mov	WORD PTR [bp-4],di
	*** 000012	80 3d 80 		cmp	BYTE PTR [di],128	;0080H
	*** 000015	75 04 			jne	SHORT $L1637
	*** 000017	b0 01 			mov	al,1
	*** 000019	eb 02 			jmp	SHORT $L1638
					$L1637:
	*** 00001b	32 c0 			xor	al,al
					$L1638:
	*** 00001d	8b 5e fe 		mov	bx,WORD PTR [bp-2]
	*** 000020	88 47 02 		mov	BYTE PTR [bx+2],al
;|*** 	partition.EndSector.HighPart = 0;
; Line 336
	*** 000023	66 c7 47 08 00 00 00 00 mov	DWORD PTR [bx+8],0
;|*** 	partition.EndSector.LowPart = partEntry.StartLBA + partEntry.SectorCountLBA - 1;
; Line 337
	*** 00002b	8b 76 fc 		mov	si,WORD PTR [bp-4]
	*** 00002e	66 8b 44 08 		mov	eax,DWORD PTR [si+8]
	*** 000032	66 03 44 0c 		add	eax,DWORD PTR [si+12]
	*** 000036	66 48 			dec	eax
	*** 000038	66 89 47 04 		mov	DWORD PTR [bx+4],eax
;|*** 	partition.SectorCount.HighPart = 0;
; Line 338
	*** 00003c	66 c7 47 12 00 00 00 00 mov	DWORD PTR [bx+18],0
;|*** 	partition.SectorCount.LowPart = partEntry.SectorCountLBA;
; Line 339
	*** 000044	66 8b 44 0c 		mov	eax,DWORD PTR [si+12]
	*** 000048	66 89 47 0e 		mov	DWORD PTR [bx+14],eax
;|*** 	partition.StartSector.HighPart = 0;
; Line 340
	*** 00004c	66 c7 47 1a 00 00 00 00 mov	DWORD PTR [bx+26],0
;|*** 	partition.StartSector.LowPart = partEntry.StartLBA;
; Line 341
	*** 000054	66 8b 44 08 		mov	eax,DWORD PTR [si+8]
	*** 000058	66 89 47 16 		mov	DWORD PTR [bx+22],eax
;|*** 	partition.Type = partEntry.Type;
; Line 342
	*** 00005c	8a 44 04 		mov	al,BYTE PTR [si+4]
	*** 00005f	88 47 1e 		mov	BYTE PTR [bx+30],al
;|*** }
; Line 343
	*** 000062	5e 			pop	si
	*** 000063	5f 			pop	di
	*** 000064	c9 			leave	
	*** 000065	c3 			ret	

?PartitionEntryMBRToPartition@@YAXABUPartitionEntryMBR@@AAUPartition@@@Z	ENDP
	PUBLIC	?ReadWriteMBR@@YAEDED@Z	; ReadWriteMBR
?ReadWriteMBR@@YAEDED@Z	PROC NEAR	; ReadWriteMBR COMDAT
;|*** 
;|*** 
;|*** BiosResult ReadWriteMBR (bool write, byte drive, bool silent)
;|*** {
; Line 347
	*** 000000	c8 08 00 00 		enter	8,0
;	write = 4
;	drive = 6
;	silent = 8
;	mbrSector = -8
;|*** 	uint64 mbrSector;
;|*** 	mbrSector.HighPart = 0;
; Line 349
	*** 000004	66 2b c0 		sub	eax,eax
	*** 000007	66 89 46 fc 		mov	DWORD PTR [bp-4],eax
;|*** 	mbrSector.LowPart = 0;
; Line 350
	*** 00000b	66 89 46 f8 		mov	DWORD PTR [bp-8],eax	;mbrSector
;|*** 
;|*** 	if (write)
; Line 352
	*** 00000f	38 46 04 		cmp	BYTE PTR [bp+4],al	;write
	*** 000012	74 16 			je	SHORT $I1567
	*** 000014	8a 46 08 		mov	al,BYTE PTR [bp+8]	;silent
	*** 000017	50 			push	ax
	*** 000018	6a 01 			push	1
	*** 00001a	8d 46 f8 		lea	ax,WORD PTR [bp-8]	;mbrSector
	*** 00001d	50 			push	ax
	*** 00001e	8a 46 06 		mov	al,BYTE PTR [bp+6]	;drive
	*** 000021	50 			push	ax
	*** 000022	68 00 00 		push	OFFSET DGROUP:?SectorBuffer@@3QAEA	;SectorBuffer
	*** 000025	e8 00 00 		call	?WriteSectors@@YAEPAEEABTUINT64_STRUCT@@ID@Z	; WriteSectors
	*** 000028	c9 			leave	
	*** 000029	c3 			ret	
					$I1567:
	*** 00002a	8a 46 08 		mov	al,BYTE PTR [bp+8]	;silent
	*** 00002d	50 			push	ax
	*** 00002e	6a 01 			push	1
	*** 000030	8d 46 f8 		lea	ax,WORD PTR [bp-8]	;mbrSector
	*** 000033	50 			push	ax
	*** 000034	8a 46 06 		mov	al,BYTE PTR [bp+6]	;drive
	*** 000037	50 			push	ax
	*** 000038	68 00 00 		push	OFFSET DGROUP:?SectorBuffer@@3QAEA	;SectorBuffer
	*** 00003b	e8 00 00 		call	?ReadSectors@@YAEPAEEABTUINT64_STRUCT@@ID@Z	; ReadSectors
;|*** 		return WriteSectors (SectorBuffer, drive, mbrSector, 1, silent);
;|*** 
;|*** 	return ReadSectors (SectorBuffer, drive, mbrSector, 1, silent);		// Uses alternative segment
;|*** }
; Line 356
	*** 00003e	c9 			leave	
	*** 00003f	c3 			ret	

?ReadWriteMBR@@YAEDED@Z	ENDP
	PUBLIC	?GetDrivePartitions@@YAEEPAUPartition@@IAAID0D@Z	; GetDrivePartitions
?GetDrivePartitions@@YAEEPAUPartition@@IAAID0D@Z	PROC NEAR	; GetDrivePartitions COMDAT
;|*** 
;|*** 
;|*** BiosResult GetDrivePartitions (byte drive, Partition *partitionArray, size_t partitionArrayCapacity, size_t &partitionCount, bool activeOnly, Partition *findPartitionFollowingThis, bool silent)
;|*** {
; Line 360
	*** 000000	c8 7c 00 00 		enter	124,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	logPart = -2
;	drive = 4
;	partitionArray = 6
;	partitionArrayCapacity = 8
;	partitionCount = 10
;	activeOnly = 12
;	findPartitionFollowingThis = 14
;	silent = 16
;	followingPartition = -10
;	tmpPartition = -60
;	result = -3
;	mbr = -2
;	mbrPartitions = -124
;	partitionArrayPos = -8
;	partitionNumber = -12
;	register si = partEntry
;	partition = -2
;	firstExtStartLBA = -28
;	extStartLBA = -20
;	extMbr = -6
;|*** 	Partition *followingPartition;
;|*** 	Partition tmpPartition;
;|*** 
;|*** 	if (findPartitionFollowingThis)
; Line 364
	*** 000006	83 7e 0e 00 		cmp	WORD PTR [bp+14],0	;findPartitionFollowingThis
	*** 00000a	74 20 			je	SHORT $I1578
;|*** 	{
;|*** 		assert (partitionArrayCapacity == 1);
;|*** 		partitionArrayCapacity = 0xff;
; Line 367
	*** 00000c	c7 46 08 ff 00 		mov	WORD PTR [bp+8],255	;00ffH	;partitionArrayCapacity
;|*** 		followingPartition = partitionArray;
; Line 368
	*** 000011	8b 46 06 		mov	ax,WORD PTR [bp+6]	;partitionArray
	*** 000014	89 46 f6 		mov	WORD PTR [bp-10],ax	;followingPartition
;|*** 		partitionArray = &tmpPartition;
; Line 369
	*** 000017	8d 46 c4 		lea	ax,WORD PTR [bp-60]	;tmpPartition
	*** 00001a	89 46 06 		mov	WORD PTR [bp+6],ax	;partitionArray
;|*** 
;|*** 		followingPartition->Drive = TC_INVALID_BIOS_DRIVE;
; Line 371
	*** 00001d	8b 5e f6 		mov	bx,WORD PTR [bp-10]	;followingPartition
	*** 000020	c6 47 01 7f 		mov	BYTE PTR [bx+1],127	;007fH
;|*** 		followingPartition->StartSector.LowPart = 0xFFFFffffUL;
; Line 372
	*** 000024	66 c7 47 16 ff ff ff ff mov	DWORD PTR [bx+22],-1
;|*** 	}
;|*** 
;|*** 	AcquireSectorBuffer();
; Line 375
					$I1578:
;|*** 	BiosResult result = ReadWriteMBR (false, drive, silent);
; Line 376
	*** 00002c	8a 46 10 		mov	al,BYTE PTR [bp+16]	;silent
	*** 00002f	50 			push	ax
	*** 000030	8a 46 04 		mov	al,BYTE PTR [bp+4]	;drive
	*** 000033	50 			push	ax
	*** 000034	6a 00 			push	0
	*** 000036	e8 00 00 		call	?ReadWriteMBR@@YAEDED@Z	; ReadWriteMBR
	*** 000039	83 c4 06 		add	sp,6
	*** 00003c	88 46 fd 		mov	BYTE PTR [bp-3],al	;result
;|*** 	ReleaseSectorBuffer();
;|*** 
;|*** 	partitionCount = 0;
; Line 379
	*** 00003f	8b 5e 0a 		mov	bx,WORD PTR [bp+10]	;partitionCount
	*** 000042	c7 07 00 00 		mov	WORD PTR [bx],0
;|*** 
;|*** 	MBR *mbr = (MBR *) SectorBuffer;
; Line 381
	*** 000046	c7 46 fe 00 00 		mov	WORD PTR [bp-2],OFFSET DGROUP:?SectorBuffer@@3QAEA	;logPart	;SectorBuffer
;|*** 	if (result != BiosResultSuccess || mbr->Signature != 0xaa55)
; Line 382
	*** 00004b	80 7e fd 00 		cmp	BYTE PTR [bp-3],0	;result
	*** 00004f	0f 85 cc 01 		jne	$I1583
	*** 000053	81 3e fe 01 55 aa 	cmp	WORD PTR ?SectorBuffer@@3QAEA+510,-21931	;aa55H	;SectorBuffer
	*** 000059	0f 85 c2 01 		jne	$I1583
;|*** 		return result;
;|*** 
;|*** 	PartitionEntryMBR mbrPartitions[4];
;|*** 	memcpy (mbrPartitions, mbr->Partitions, sizeof (mbrPartitions));
; Line 386
	*** 00005d	6a 40 			push	64	;0040H
	*** 00005f	68 be 01 		push	OFFSET DGROUP:?SectorBuffer@@3QAEA+446	;SectorBuffer
	*** 000062	8d 46 84 		lea	ax,WORD PTR [bp-124]	;mbrPartitions
	*** 000065	50 			push	ax
	*** 000066	e8 00 00 		call	_memcpy
	*** 000069	83 c4 06 		add	sp,6
;|*** 	size_t partitionArrayPos = 0, partitionNumber;
;|*** 	
;|*** 	for (partitionNumber = 0;
; Line 389
	*** 00006c	33 c0 			xor	ax,ax
	*** 00006e	89 46 f8 		mov	WORD PTR [bp-8],ax	;partitionArrayPos
	*** 000071	89 46 f4 		mov	WORD PTR [bp-12],ax	;partitionNumber
;|*** 		partitionNumber < array_capacity (mbrPartitions) && partitionArrayPos < partitionArrayCapacity;
;|*** 		++partitionNumber)
; Line 391
					$F1587:
	*** 000074	83 7e f4 04 		cmp	WORD PTR [bp-12],4	;partitionNumber
	*** 000078	0f 83 9b 01 		jae	$FB1589
	*** 00007c	8b 46 08 		mov	ax,WORD PTR [bp+8]	;partitionArrayCapacity
	*** 00007f	39 46 f8 		cmp	WORD PTR [bp-8],ax	;partitionArrayPos
	*** 000082	0f 83 91 01 		jae	$FB1589
;|*** 	{
;|*** 		const PartitionEntryMBR &partEntry = mbrPartitions[partitionNumber];
;|*** 		
;|*** 		if (partEntry.SectorCountLBA > 0)
; Line 395
	*** 000086	8b 7e f4 		mov	di,WORD PTR [bp-12]	;partitionNumber
	*** 000089	c1 e7 04 		shl	di,4
	*** 00008c	8d 73 84 		lea	si,WORD PTR [bp-124][di]
	*** 00008f	66 83 7c 0c 00 		cmp	DWORD PTR [si+12],0
	*** 000094	74 76 			je	SHORT $FC1588
					$L1641:
;|*** 		{
;|*** 			Partition &partition = partitionArray[partitionArrayPos];
;|*** 			PartitionEntryMBRToPartition (partEntry, partition);
; Line 398
	*** 000096	8b 46 f8 		mov	ax,WORD PTR [bp-8]	;partitionArrayPos
	*** 000099	c1 e0 05 		shl	ax,5
	*** 00009c	03 46 06 		add	ax,WORD PTR [bp+6]	;partitionArray
	*** 00009f	89 46 fe 		mov	WORD PTR [bp-2],ax	;logPart
	*** 0000a2	50 			push	ax
	*** 0000a3	56 			push	si
	*** 0000a4	e8 00 00 		call	?PartitionEntryMBRToPartition@@YAXABUPartitionEntryMBR@@AAUPartition@@@Z	; PartitionEntryMBRToPartition
	*** 0000a7	83 c4 04 		add	sp,4
;|*** 
;|*** 			if (activeOnly && !partition.Active)
; Line 400
	*** 0000aa	80 7e 0c 00 		cmp	BYTE PTR [bp+12],0	;activeOnly
	*** 0000ae	74 09 			je	SHORT $I1593
	*** 0000b0	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;logPart
	*** 0000b3	80 7f 02 00 		cmp	BYTE PTR [bx+2],0
	*** 0000b7	74 53 			je	SHORT $FC1588
;|*** 				continue;
;|*** 
;|*** 			partition.Drive = drive;
; Line 403
					$I1593:
	*** 0000b9	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;logPart
	*** 0000bc	8a 46 04 		mov	al,BYTE PTR [bp+4]	;drive
	*** 0000bf	88 47 01 		mov	BYTE PTR [bx+1],al
;|*** 			partition.Number = partitionArrayPos;
; Line 404
	*** 0000c2	8a 46 f8 		mov	al,BYTE PTR [bp-8]	;partitionArrayPos
	*** 0000c5	88 07 			mov	BYTE PTR [bx],al
;|*** 
;|*** 			if (partEntry.Type == 0x5 || partEntry.Type == 0xf) // Extended partition
; Line 406
	*** 0000c7	80 7c 04 05 		cmp	BYTE PTR [si+4],5
	*** 0000cb	74 4a 			je	SHORT $I1595
	*** 0000cd	80 7c 04 0f 		cmp	BYTE PTR [si+4],15	;000fH
	*** 0000d1	74 44 			je	SHORT $I1595
;|*** 			{
;|*** 				if (IsLbaSupported (drive))
;|*** 				{
;|*** 					// Find all extended partitions
;|*** 					uint64 firstExtStartLBA = partition.StartSector;
;|*** 					uint64 extStartLBA = partition.StartSector;
;|*** 					MBR *extMbr = (MBR *) SectorBuffer;
;|*** 
;|*** 					while (partitionArrayPos < partitionArrayCapacity &&
;|*** 						(result = ReadSectors ((byte *) extMbr, drive, extStartLBA, 1, silent)) == BiosResultSuccess
;|*** 						&& extMbr->Signature == 0xaa55)
;|*** 					{
;|*** 						if (extMbr->Partitions[0].SectorCountLBA > 0)
;|*** 						{
;|*** 							Partition &logPart = partitionArray[partitionArrayPos];
;|*** 							PartitionEntryMBRToPartition (extMbr->Partitions[0], logPart);
;|*** 							logPart.Drive = drive;
;|*** 
;|*** 							logPart.Number = partitionArrayPos;
;|*** 							logPart.Primary = false;
;|*** 
;|*** 							logPart.StartSector.LowPart += extStartLBA.LowPart;
;|*** 							logPart.EndSector.LowPart += extStartLBA.LowPart;
;|*** 
;|*** 							if (findPartitionFollowingThis)
;|*** 							{
;|*** 								if (logPart.StartSector.LowPart > findPartitionFollowingThis->EndSector.LowPart
;|*** 									&& logPart.StartSector.LowPart < followingPartition->StartSector.LowPart)
;|*** 								{
;|*** 									*followingPartition = logPart;
;|*** 								}
;|*** 							}
;|*** 							else
;|*** 								++partitionArrayPos;
;|*** 						}
;|*** 
;|*** 						// Secondary extended
;|*** 						if (extMbr->Partitions[1].Type != 0x5 && extMbr->Partitions[1].Type == 0xf
;|*** 							|| extMbr->Partitions[1].SectorCountLBA == 0)
;|*** 							break;
;|*** 
;|*** 						extStartLBA.LowPart = extMbr->Partitions[1].StartLBA + firstExtStartLBA.LowPart;
;|*** 					}
;|*** 				}
;|*** 			}
;|*** 			else
;|*** 			{
;|*** 				partition.Primary = true;
; Line 454
	*** 0000d3	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;logPart
	*** 0000d6	c6 47 0c 01 		mov	BYTE PTR [bx+12],1
;|*** 
;|*** 				if (findPartitionFollowingThis)
; Line 456
	*** 0000da	83 7e 0e 00 		cmp	WORD PTR [bp+14],0	;findPartitionFollowingThis
	*** 0000de	74 32 			je	SHORT $I1614
;|*** 				{
;|*** 					if (partition.StartSector.LowPart > findPartitionFollowingThis->EndSector.LowPart
;|*** 						&& partition.StartSector.LowPart < followingPartition->StartSector.LowPart)
; Line 459
	*** 0000e0	8b 5e 0e 		mov	bx,WORD PTR [bp+14]	;findPartitionFollowingThis
	*** 0000e3	66 8b 47 04 		mov	eax,DWORD PTR [bx+4]
	*** 0000e7	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;logPart
	*** 0000ea	66 39 47 16 		cmp	DWORD PTR [bx+22],eax
	*** 0000ee	76 1c 			jbe	SHORT $FC1588
					$L1642:
	*** 0000f0	8b 5e f6 		mov	bx,WORD PTR [bp-10]	;followingPartition
	*** 0000f3	66 8b 47 16 		mov	eax,DWORD PTR [bx+22]
	*** 0000f7	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;logPart
	*** 0000fa	66 39 47 16 		cmp	DWORD PTR [bx+22],eax
	*** 0000fe	73 0c 			jae	SHORT $FC1588
					$L1643:
;|*** 					{
;|*** 						*followingPartition = partition;
; Line 461
	*** 000100	8b f3 			mov	si,bx
	*** 000102	1e 			push	ds
	*** 000103	07 			pop	es
	*** 000104	8b 7e f6 		mov	di,WORD PTR [bp-10]	;followingPartition
	*** 000107	b9 10 00 		mov	cx,16	;0010H
	*** 00010a	f3 			rep
	*** 00010b	a5 			movsw
;|*** 					}
;|*** 				}
;|*** 				else
; Line 464
					$FC1588:
	*** 00010c	ff 46 f4 		inc	WORD PTR [bp-12]	;partitionNumber
	*** 00010f	e9 62 ff 		jmp	$F1587
					$I1614:
;|*** 					++partitionArrayPos;
; Line 465
	*** 000112	ff 46 f8 		inc	WORD PTR [bp-8]	;partitionArrayPos
;|*** 			}
;|*** 		}
;|*** 	}
; Line 468
	*** 000115	eb f5 			jmp	SHORT $FC1588
;|*** 			if (partEntry.Type == 0x5 || partEntry.Type == 0xf) // Extended partition
; Line 406
					$I1595:
;|*** 			{
;|*** 				if (IsLbaSupported (drive))
; Line 408
	*** 000117	8a 46 04 		mov	al,BYTE PTR [bp+4]	;drive
	*** 00011a	50 			push	ax
	*** 00011b	e8 00 00 		call	?IsLbaSupported@@YADE@Z	; IsLbaSupported
	*** 00011e	5b 			pop	bx
	*** 00011f	0a c0 			or	al,al
	*** 000121	74 e9 			je	SHORT $FC1588
;|*** 				{
;|*** 					// Find all extended partitions
;|*** 					uint64 firstExtStartLBA = partition.StartSector;
; Line 411
	*** 000123	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;logPart
	*** 000126	05 16 00 		add	ax,22	;0016H
	*** 000129	8d 7e e4 		lea	di,WORD PTR [bp-28]	;firstExtStartLBA
	*** 00012c	8b f0 			mov	si,ax
	*** 00012e	16 			push	ss
	*** 00012f	07 			pop	es
	*** 000130	66 a5 			movsd
	*** 000132	66 a5 			movsd
;|*** 					uint64 extStartLBA = partition.StartSector;
; Line 412
	*** 000134	8d 7e ec 		lea	di,WORD PTR [bp-20]	;extStartLBA
	*** 000137	8b f0 			mov	si,ax
	*** 000139	66 a5 			movsd
	*** 00013b	66 a5 			movsd
;|*** 					MBR *extMbr = (MBR *) SectorBuffer;
; Line 413
	*** 00013d	c7 46 fa 00 00 		mov	WORD PTR [bp-6],OFFSET DGROUP:?SectorBuffer@@3QAEA	;extMbr	;SectorBuffer
;|*** 
;|*** 					while (partitionArrayPos < partitionArrayCapacity &&
;|*** 						(result = ReadSectors ((byte *) extMbr, drive, extStartLBA, 1, silent)) == BiosResultSuccess
;|*** 						&& extMbr->Signature == 0xaa55)
; Line 417
					$FC1603:
	*** 000142	8b 46 08 		mov	ax,WORD PTR [bp+8]	;partitionArrayCapacity
	*** 000145	39 46 f8 		cmp	WORD PTR [bp-8],ax	;partitionArrayPos
	*** 000148	73 c2 			jae	SHORT $FC1588
	*** 00014a	8a 46 10 		mov	al,BYTE PTR [bp+16]	;silent
	*** 00014d	50 			push	ax
	*** 00014e	6a 01 			push	1
	*** 000150	8d 46 ec 		lea	ax,WORD PTR [bp-20]	;extStartLBA
	*** 000153	50 			push	ax
	*** 000154	8a 46 04 		mov	al,BYTE PTR [bp+4]	;drive
	*** 000157	50 			push	ax
	*** 000158	68 00 00 		push	OFFSET DGROUP:?SectorBuffer@@3QAEA	;SectorBuffer
	*** 00015b	e8 00 00 		call	?ReadSectors@@YAEPAEEABTUINT64_STRUCT@@ID@Z	; ReadSectors
	*** 00015e	83 c4 0a 		add	sp,10	;000aH
	*** 000161	88 46 fd 		mov	BYTE PTR [bp-3],al	;result
	*** 000164	0a c0 			or	al,al
	*** 000166	75 a4 			jne	SHORT $FC1588
	*** 000168	81 3e fe 01 55 aa 	cmp	WORD PTR ?SectorBuffer@@3QAEA+510,-21931	;aa55H	;SectorBuffer
	*** 00016e	75 9c 			jne	SHORT $FC1588
;|*** 					{
;|*** 						if (extMbr->Partitions[0].SectorCountLBA > 0)
; Line 419
	*** 000170	66 83 3e ca 01 00 	cmp	DWORD PTR ?SectorBuffer@@3QAEA+458,0	;SectorBuffer
	*** 000176	74 76 			je	SHORT $I1605
					$L1644:
;|*** 						{
;|*** 							Partition &logPart = partitionArray[partitionArrayPos];
;|*** 							PartitionEntryMBRToPartition (extMbr->Partitions[0], logPart);
; Line 422
	*** 000178	8b 46 f8 		mov	ax,WORD PTR [bp-8]	;partitionArrayPos
	*** 00017b	c1 e0 05 		shl	ax,5
	*** 00017e	03 46 06 		add	ax,WORD PTR [bp+6]	;partitionArray
	*** 000181	89 46 fe 		mov	WORD PTR [bp-2],ax	;logPart
	*** 000184	50 			push	ax
	*** 000185	68 be 01 		push	OFFSET DGROUP:?SectorBuffer@@3QAEA+446	;SectorBuffer
	*** 000188	8b f0 			mov	si,ax
	*** 00018a	e8 00 00 		call	?PartitionEntryMBRToPartition@@YAXABUPartitionEntryMBR@@AAUPartition@@@Z	; PartitionEntryMBRToPartition
	*** 00018d	83 c4 04 		add	sp,4
;|*** 							logPart.Drive = drive;
; Line 423
	*** 000190	8a 46 04 		mov	al,BYTE PTR [bp+4]	;drive
	*** 000193	88 44 01 		mov	BYTE PTR [si+1],al
;|*** 
;|*** 							logPart.Number = partitionArrayPos;
; Line 425
	*** 000196	8a 46 f8 		mov	al,BYTE PTR [bp-8]	;partitionArrayPos
	*** 000199	88 04 			mov	BYTE PTR [si],al
;|*** 							logPart.Primary = false;
; Line 426
	*** 00019b	c6 44 0c 00 		mov	BYTE PTR [si+12],0
;|*** 
;|*** 							logPart.StartSector.LowPart += extStartLBA.LowPart;
; Line 428
	*** 00019f	66 8b 44 16 		mov	eax,DWORD PTR [si+22]
	*** 0001a3	66 03 46 ec 		add	eax,DWORD PTR [bp-20]	;extStartLBA
	*** 0001a7	66 89 44 16 		mov	DWORD PTR [si+22],eax
;|*** 							logPart.EndSector.LowPart += extStartLBA.LowPart;
; Line 429
	*** 0001ab	66 8b 44 04 		mov	eax,DWORD PTR [si+4]
	*** 0001af	66 03 46 ec 		add	eax,DWORD PTR [bp-20]	;extStartLBA
	*** 0001b3	66 89 44 04 		mov	DWORD PTR [si+4],eax
;|*** 
;|*** 							if (findPartitionFollowingThis)
; Line 431
	*** 0001b7	83 7e 0e 00 		cmp	WORD PTR [bp+14],0	;findPartitionFollowingThis
	*** 0001bb	74 2e 			je	SHORT $I1607
;|*** 							{
;|*** 								if (logPart.StartSector.LowPart > findPartitionFollowingThis->EndSector.LowPart
;|*** 									&& logPart.StartSector.LowPart < followingPartition->StartSector.LowPart)
; Line 434
	*** 0001bd	8b 5e 0e 		mov	bx,WORD PTR [bp+14]	;findPartitionFollowingThis
	*** 0001c0	66 8b 47 04 		mov	eax,DWORD PTR [bx+4]
	*** 0001c4	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;logPart
	*** 0001c7	66 39 47 16 		cmp	DWORD PTR [bx+22],eax
	*** 0001cb	76 21 			jbe	SHORT $I1605
					$L1645:
	*** 0001cd	8b 5e f6 		mov	bx,WORD PTR [bp-10]	;followingPartition
	*** 0001d0	66 8b 47 16 		mov	eax,DWORD PTR [bx+22]
	*** 0001d4	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;logPart
	*** 0001d7	66 39 47 16 		cmp	DWORD PTR [bx+22],eax
	*** 0001db	73 11 			jae	SHORT $I1605
					$L1646:
;|*** 								{
;|*** 									*followingPartition = logPart;
; Line 436
	*** 0001dd	8b f3 			mov	si,bx
	*** 0001df	1e 			push	ds
	*** 0001e0	07 			pop	es
	*** 0001e1	8b 7e f6 		mov	di,WORD PTR [bp-10]	;followingPartition
	*** 0001e4	b9 10 00 		mov	cx,16	;0010H
	*** 0001e7	f3 			rep
	*** 0001e8	a5 			movsw
;|*** 								}
;|*** 							}
;|*** 							else
; Line 439
	*** 0001e9	eb 03 			jmp	SHORT $I1605
					$I1607:
;|*** 								++partitionArrayPos;
; Line 440
	*** 0001eb	ff 46 f8 		inc	WORD PTR [bp-8]	;partitionArrayPos
;|*** 						}
;|*** 
;|*** 						// Secondary extended
;|*** 						if (extMbr->Partitions[1].Type != 0x5 && extMbr->Partitions[1].Type == 0xf
; Line 444
					$I1605:
;|*** 							|| extMbr->Partitions[1].SectorCountLBA == 0)
; Line 445
	*** 0001ee	80 3e d2 01 05 		cmp	BYTE PTR ?SectorBuffer@@3QAEA+466,5	;SectorBuffer
	*** 0001f3	74 07 			je	SHORT $I1612
	*** 0001f5	80 3e d2 01 0f 		cmp	BYTE PTR ?SectorBuffer@@3QAEA+466,15	;000fH	;SectorBuffer
	*** 0001fa	74 08 			je	SHORT $L1650
					$I1612:
	*** 0001fc	66 83 3e da 01 00 	cmp	DWORD PTR ?SectorBuffer@@3QAEA+474,0	;SectorBuffer
	*** 000202	75 03 			jne	SHORT $L1649
;|*** 							break;
;|*** 
;|*** 						extStartLBA.LowPart = extMbr->Partitions[1].StartLBA + firstExtStartLBA.LowPart;
; Line 448
					$L1650:
	*** 000204	e9 05 ff 		jmp	$FC1588
					$L1649:
	*** 000207	66 8b 46 e4 		mov	eax,DWORD PTR [bp-28]	;firstExtStartLBA
	*** 00020b	66 03 06 d6 01 		add	eax,DWORD PTR ?SectorBuffer@@3QAEA+470	;SectorBuffer
	*** 000210	66 89 46 ec 		mov	DWORD PTR [bp-20],eax	;extStartLBA
;|*** 					}
; Line 449
	*** 000214	e9 2b ff 		jmp	$FC1603
;|*** 				}
;|*** 			}
;|*** 			else
;|*** 			{
;|*** 				partition.Primary = true;
;|*** 
;|*** 				if (findPartitionFollowingThis)
;|*** 				{
;|*** 					if (partition.StartSector.LowPart > findPartitionFollowingThis->EndSector.LowPart
;|*** 						&& partition.StartSector.LowPart < followingPartition->StartSector.LowPart)
;|*** 					{
;|*** 						*followingPartition = partition;
;|*** 					}
;|*** 				}
;|*** 				else
;|*** 					++partitionArrayPos;
;|*** 			}
;|*** 		}
;|*** 	}
; Line 468
					$FB1589:
;|*** 
;|*** 	partitionCount = partitionArrayPos;
; Line 470
	*** 000217	8b 5e 0a 		mov	bx,WORD PTR [bp+10]	;partitionCount
	*** 00021a	8b 46 f8 		mov	ax,WORD PTR [bp-8]	;partitionArrayPos
	*** 00021d	89 07 			mov	WORD PTR [bx],ax
;|*** 	if (result != BiosResultSuccess || mbr->Signature != 0xaa55)
; Line 382
					$I1583:
;|*** 		return result;
; Line 383
	*** 00021f	8a 46 fd 		mov	al,BYTE PTR [bp-3]	;result
;|*** 
;|*** 	PartitionEntryMBR mbrPartitions[4];
;|*** 	memcpy (mbrPartitions, mbr->Partitions, sizeof (mbrPartitions));
;|*** 	size_t partitionArrayPos = 0, partitionNumber;
;|*** 	
;|*** 	for (partitionNumber = 0;
;|*** 		partitionNumber < array_capacity (mbrPartitions) && partitionArrayPos < partitionArrayCapacity;
;|*** 		++partitionNumber)
;|*** 	{
;|*** 		const PartitionEntryMBR &partEntry = mbrPartitions[partitionNumber];
;|*** 		
;|*** 		if (partEntry.SectorCountLBA > 0)
;|*** 		{
;|*** 			Partition &partition = partitionArray[partitionArrayPos];
;|*** 			PartitionEntryMBRToPartition (partEntry, partition);
;|*** 
;|*** 			if (activeOnly && !partition.Active)
;|*** 				continue;
;|*** 
;|*** 			partition.Drive = drive;
;|*** 			partition.Number = partitionArrayPos;
;|*** 
;|*** 			if (partEntry.Type == 0x5 || partEntry.Type == 0xf) // Extended partition
;|*** 			{
;|*** 				if (IsLbaSupported (drive))
;|*** 				{
;|*** 					// Find all extended partitions
;|*** 					uint64 firstExtStartLBA = partition.StartSector;
;|*** 					uint64 extStartLBA = partition.StartSector;
;|*** 					MBR *extMbr = (MBR *) SectorBuffer;
;|*** 
;|*** 					while (partitionArrayPos < partitionArrayCapacity &&
;|*** 						(result = ReadSectors ((byte *) extMbr, drive, extStartLBA, 1, silent)) == BiosResultSuccess
;|*** 						&& extMbr->Signature == 0xaa55)
;|*** 					{
;|*** 						if (extMbr->Partitions[0].SectorCountLBA > 0)
;|*** 						{
;|*** 							Partition &logPart = partitionArray[partitionArrayPos];
;|*** 							PartitionEntryMBRToPartition (extMbr->Partitions[0], logPart);
;|*** 							logPart.Drive = drive;
;|*** 
;|*** 							logPart.Number = partitionArrayPos;
;|*** 							logPart.Primary = false;
;|*** 
;|*** 							logPart.StartSector.LowPart += extStartLBA.LowPart;
;|*** 							logPart.EndSector.LowPart += extStartLBA.LowPart;
;|*** 
;|*** 							if (findPartitionFollowingThis)
;|*** 							{
;|*** 								if (logPart.StartSector.LowPart > findPartitionFollowingThis->EndSector.LowPart
;|*** 									&& logPart.StartSector.LowPart < followingPartition->StartSector.LowPart)
;|*** 								{
;|*** 									*followingPartition = logPart;
;|*** 								}
;|*** 							}
;|*** 							else
;|*** 								++partitionArrayPos;
;|*** 						}
;|*** 
;|*** 						// Secondary extended
;|*** 						if (extMbr->Partitions[1].Type != 0x5 && extMbr->Partitions[1].Type == 0xf
;|*** 							|| extMbr->Partitions[1].SectorCountLBA == 0)
;|*** 							break;
;|*** 
;|*** 						extStartLBA.LowPart = extMbr->Partitions[1].StartLBA + firstExtStartLBA.LowPart;
;|*** 					}
;|*** 				}
;|*** 			}
;|*** 			else
;|*** 			{
;|*** 				partition.Primary = true;
;|*** 
;|*** 				if (findPartitionFollowingThis)
;|*** 				{
;|*** 					if (partition.StartSector.LowPart > findPartitionFollowingThis->EndSector.LowPart
;|*** 						&& partition.StartSector.LowPart < followingPartition->StartSector.LowPart)
;|*** 					{
;|*** 						*followingPartition = partition;
;|*** 					}
;|*** 				}
;|*** 				else
;|*** 					++partitionArrayPos;
;|*** 			}
;|*** 		}
;|*** 	}
;|*** 
;|*** 	partitionCount = partitionArrayPos;
;|*** 	return result;
;|*** }
; Line 472
	*** 000222	5e 			pop	si
	*** 000223	5f 			pop	di
	*** 000224	c9 			leave	
	*** 000225	c3 			ret	

?GetDrivePartitions@@YAEEPAUPartition@@IAAID0D@Z	ENDP
	PUBLIC	?GetActivePartition@@YADE@Z	; GetActivePartition
?GetActivePartition@@YADE@Z	PROC NEAR	; GetActivePartition COMDAT
;|*** 
;|*** 
;|*** bool GetActivePartition (byte drive)
;|*** {
; Line 476
	*** 000000	c8 02 00 00 		enter	2,0
;	drive = 4
;	partCount = -2
;|*** 	size_t partCount;
;|*** 
;|*** 	if (GetDrivePartitions (drive, &ActivePartition, 1, partCount, true) != BiosResultSuccess || partCount < 1)
; Line 479
	*** 000004	6a 00 			push	0
	*** 000006	6a 00 			push	0
	*** 000008	6a 01 			push	1
	*** 00000a	8d 46 fe 		lea	ax,WORD PTR [bp-2]	;partCount
	*** 00000d	50 			push	ax
	*** 00000e	6a 01 			push	1
	*** 000010	68 00 00 		push	OFFSET ?ActivePartition@@3UPartition@@A	;ActivePartition
	*** 000013	8a 46 04 		mov	al,BYTE PTR [bp+4]	;drive
	*** 000016	50 			push	ax
	*** 000017	e8 00 00 		call	?GetDrivePartitions@@YAEEPAUPartition@@IAAID0D@Z	; GetDrivePartitions
	*** 00001a	83 c4 0e 		add	sp,14	;000eH
	*** 00001d	0a c0 			or	al,al
	*** 00001f	75 0a 			jne	SHORT $I1621
	*** 000021	83 7e fe 01 		cmp	WORD PTR [bp-2],1	;partCount
	*** 000025	72 04 			jb	SHORT $I1621
;|*** 	{
;|*** 		ActivePartition.Drive = TC_INVALID_BIOS_DRIVE;
;|*** 		PrintError (TC_BOOT_STR_NO_BOOT_PARTITION);
;|*** 		return false;
;|*** 	}
;|*** 	
;|*** 	return true;
; Line 486
	*** 000027	b0 01 			mov	al,1
	*** 000029	c9 			leave	
	*** 00002a	c3 			ret	
;|*** 	if (GetDrivePartitions (drive, &ActivePartition, 1, partCount, true) != BiosResultSuccess || partCount < 1)
; Line 479
					$I1621:
;|*** 	{
;|*** 		ActivePartition.Drive = TC_INVALID_BIOS_DRIVE;
; Line 481
	*** 00002b	c6 06 01 00 7f 		mov	BYTE PTR ?ActivePartition@@3UPartition@@A+1,127	;007fH	;ActivePartition
;|*** 		PrintError (TC_BOOT_STR_NO_BOOT_PARTITION);
; Line 482
	*** 000030	68 00 00 		push	OFFSET DGROUP:??_C@_0BM@IDKA@No?5bootable?5partition?5found?$AA@
	*** 000033	e8 00 00 		call	?PrintError@@YAXPBD@Z	; PrintError
	*** 000036	5b 			pop	bx
;|*** 		return false;
; Line 483
	*** 000037	32 c0 			xor	al,al
;|*** 	}
;|*** 	
;|*** 	return true;
;|*** }
; Line 487
	*** 000039	c9 			leave	
	*** 00003a	c3 			ret	

?GetActivePartition@@YADE@Z	ENDP
_TEXT	ENDS
END
