; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\home\public\desktop\projects\ciphershed.build\src\common\xts.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_EncryptBufferXTS@32
EXTRN	_CipherSupportsIntraDataUnitParallelization@4:PROC
; Function compile flags: /Odtp
; File c:\home\public\desktop\projects\ciphershed.build\src\common\xts.c
;	COMDAT _EncryptBufferXTS@32
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_ks$ = 28						; size = 4
_ks2$ = 32						; size = 4
_cipher$ = 36						; size = 4
_EncryptBufferXTS@32 PROC				; COMDAT

; 48   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 49   : 	if (CipherSupportsIntraDataUnitParallelization (cipher))

  00005	8b 45 24	 mov	 eax, DWORD PTR _cipher$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _CipherSupportsIntraDataUnitParallelization@4
  0000e	85 c0		 test	 eax, eax
  00010	74 27		 je	 SHORT $LN2@EncryptBuf

; 50   : 		EncryptBufferXTSParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  00012	8b 4d 24	 mov	 ecx, DWORD PTR _cipher$[ebp]
  00015	51		 push	 ecx
  00016	8b 55 20	 mov	 edx, DWORD PTR _ks2$[ebp]
  00019	52		 push	 edx
  0001a	8b 45 1c	 mov	 eax, DWORD PTR _ks$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 18	 mov	 ecx, DWORD PTR _startCipherBlockNo$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 14	 mov	 edx, DWORD PTR _startDataUnitNo$[ebp]
  00025	52		 push	 edx
  00026	8b 45 10	 mov	 eax, DWORD PTR _length$[ebp+4]
  00029	50		 push	 eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _length$[ebp]
  0002d	51		 push	 ecx
  0002e	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 _EncryptBufferXTSParallel@32

; 51   : 	else

  00037	eb 25		 jmp	 SHORT $LN3@EncryptBuf
$LN2@EncryptBuf:

; 52   : 		EncryptBufferXTSNonParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  00039	8b 45 24	 mov	 eax, DWORD PTR _cipher$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d 20	 mov	 ecx, DWORD PTR _ks2$[ebp]
  00040	51		 push	 ecx
  00041	8b 55 1c	 mov	 edx, DWORD PTR _ks$[ebp]
  00044	52		 push	 edx
  00045	8b 45 18	 mov	 eax, DWORD PTR _startCipherBlockNo$[ebp]
  00048	50		 push	 eax
  00049	8b 4d 14	 mov	 ecx, DWORD PTR _startDataUnitNo$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp+4]
  00050	52		 push	 edx
  00051	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  00054	50		 push	 eax
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 _EncryptBufferXTSNonParallel@32
$LN3@EncryptBuf:

; 53   : }

  0005e	5d		 pop	 ebp
  0005f	c2 20 00	 ret	 32			; 00000020H
_EncryptBufferXTS@32 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_EncipherBlocks@16:PROC
EXTRN	_EncipherBlock@12:PROC
EXTRN	__imp__KeBugCheckEx@20:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__allshl:PROC
EXTRN	__aulldiv:PROC
EXTRN	__aullrem:PROC
; Function compile flags: /Odtp
;	COMDAT _EncryptBufferXTSParallel@32
_TEXT	SEGMENT
tv312 = -652						; size = 8
tv92 = -644						; size = 4
tv285 = -640						; size = 8
tv227 = -632						; size = 8
_burnm$26957 = -624					; size = 4
_burnc$26959 = -620					; size = 4
_burnm$26948 = -616					; size = 4
_burnc$26950 = -612					; size = 4
_startBlock$ = -608					; size = 4
_block$ = -604						; size = 4
_dataUnitNo$ = -600					; size = 8
_finalCarry$ = -585					; size = 1
_whiteningValue$ = -584					; size = 16
_byteBufUnitNo$ = -568					; size = 16
_whiteningValuesPtr64$ = -552				; size = 4
_whiteningValuePtr64$ = -548				; size = 4
_blockCount$ = -544					; size = 8
_dataUnitBufPtr$ = -536					; size = 4
_bufPtr$ = -532						; size = 4
_whiteningValues$ = -528				; size = 512
__$ArrayPad$ = -12					; size = 4
_finalInt64WhiteningValuesPtr$ = -8			; size = 4
_endBlock$ = -4						; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_ks$ = 28						; size = 4
_ks2$ = 32						; size = 4
_cipher$ = 36						; size = 4
_EncryptBufferXTSParallel@32 PROC			; COMDAT

; 64   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 8c 02 00
	00		 sub	 esp, 652		; 0000028cH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 f4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 65   : 	unsigned __int8 finalCarry;
; 66   : 	unsigned __int8 whiteningValues [ENCRYPTION_DATA_UNIT_SIZE];
; 67   : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 68   : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 69   : 	unsigned __int64 *whiteningValuesPtr64 = (unsigned __int64 *) whiteningValues;

  00015	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _whiteningValues$[ebp]
  0001b	89 85 d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], eax

; 70   : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  00021	8d 8d b8 fd ff
	ff		 lea	 ecx, DWORD PTR _whiteningValue$[ebp]
  00027	89 8d dc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr64$[ebp], ecx

; 71   : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;

  0002d	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00030	89 95 ec fd ff
	ff		 mov	 DWORD PTR _bufPtr$[ebp], edx

; 72   : 	unsigned __int64 *dataUnitBufPtr;
; 73   : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;

  00036	8b 45 18	 mov	 eax, DWORD PTR _startCipherBlockNo$[ebp]
  00039	89 85 a0 fd ff
	ff		 mov	 DWORD PTR _startBlock$[ebp], eax

; 74   : 	unsigned __int64 *const finalInt64WhiteningValuesPtr = whiteningValuesPtr64 + sizeof (whiteningValues) / sizeof (*whiteningValuesPtr64) - 1;

  0003f	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuesPtr64$[ebp]
  00045	81 c1 f8 01 00
	00		 add	 ecx, 504		; 000001f8H
  0004b	89 4d f8	 mov	 DWORD PTR _finalInt64WhiteningValuesPtr$[ebp], ecx

; 75   : 	TC_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 76   : 
; 77   : 	/* The encrypted data unit number (i.e. the resultant ciphertext block) is to be multiplied in the
; 78   : 	finite field GF(2^128) by j-th power of n, where j is the sequential plaintext/ciphertext block
; 79   : 	number and n is 2, a primitive element of GF(2^128). This can be (and is) simplified and implemented
; 80   : 	as a left shift of the preceding whitening value by one bit (with carry propagating). In addition, if
; 81   : 	the shift of the highest byte results in a carry, 135 is XORed into the lowest byte. The value 135 is
; 82   : 	derived from the modulus of the Galois Field (x^128+x^7+x^2+x+1). */
; 83   : 
; 84   : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 85   : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 86   : 	dataUnitNo = startDataUnitNo->Value;

  0004e	8b 55 14	 mov	 edx, DWORD PTR _startDataUnitNo$[ebp]
  00051	8b 02		 mov	 eax, DWORD PTR [edx]
  00053	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp], eax
  00059	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0005c	89 8d ac fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp+4], ecx

; 87   : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  00062	8b 95 a8 fd ff
	ff		 mov	 edx, DWORD PTR _dataUnitNo$[ebp]
  00068	89 95 c8 fd ff
	ff		 mov	 DWORD PTR _byteBufUnitNo$[ebp], edx
  0006e	8b 85 ac fd ff
	ff		 mov	 eax, DWORD PTR _dataUnitNo$[ebp+4]
  00074	89 85 cc fd ff
	ff		 mov	 DWORD PTR _byteBufUnitNo$[ebp+4], eax

; 88   : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;

  0007a	c7 85 d0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _byteBufUnitNo$[ebp+8], 0
  00084	c7 85 d4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _byteBufUnitNo$[ebp+12], 0

; 89   : 
; 90   : 	if (length % BYTES_PER_XTS_BLOCK)

  0008e	6a 00		 push	 0
  00090	6a 10		 push	 16			; 00000010H
  00092	8b 4d 10	 mov	 ecx, DWORD PTR _length$[ebp+4]
  00095	51		 push	 ecx
  00096	8b 55 0c	 mov	 edx, DWORD PTR _length$[ebp]
  00099	52		 push	 edx
  0009a	e8 00 00 00 00	 call	 __aullrem
  0009f	89 85 88 fd ff
	ff		 mov	 DWORD PTR tv227[ebp], eax
  000a5	89 95 8c fd ff
	ff		 mov	 DWORD PTR tv227[ebp+4], edx
  000ab	8b 85 88 fd ff
	ff		 mov	 eax, DWORD PTR tv227[ebp]
  000b1	0b 85 8c fd ff
	ff		 or	 eax, DWORD PTR tv227[ebp+4]
  000b7	74 13		 je	 SHORT $LN27@EncryptBuf@2

; 91   : 		TC_THROW_FATAL_EXCEPTION;

  000b9	68 43 54 00 00	 push	 21571			; 00005443H
  000be	6a 00		 push	 0
  000c0	6a 00		 push	 0
  000c2	6a 5b		 push	 91			; 0000005bH
  000c4	6a 29		 push	 41			; 00000029H
  000c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN27@EncryptBuf@2:

; 92   : 
; 93   : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  000cc	6a 00		 push	 0
  000ce	6a 10		 push	 16			; 00000010H
  000d0	8b 4d 10	 mov	 ecx, DWORD PTR _length$[ebp+4]
  000d3	51		 push	 ecx
  000d4	8b 55 0c	 mov	 edx, DWORD PTR _length$[ebp]
  000d7	52		 push	 edx
  000d8	e8 00 00 00 00	 call	 __aulldiv
  000dd	89 85 e0 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp], eax
  000e3	89 95 e4 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp+4], edx
$LN26@EncryptBuf@2:

; 94   : 
; 95   : 	// Process all blocks in the buffer
; 96   : 	while (blockCount > 0)

  000e9	83 bd e4 fd ff
	ff 00		 cmp	 DWORD PTR _blockCount$[ebp+4], 0
  000f0	77 0d		 ja	 SHORT $LN32@EncryptBuf@2
  000f2	83 bd e0 fd ff
	ff 00		 cmp	 DWORD PTR _blockCount$[ebp], 0
  000f9	0f 86 31 04 00
	00		 jbe	 $LN10@EncryptBuf@2
$LN32@EncryptBuf@2:

; 97   : 	{
; 98   : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  000ff	83 bd e4 fd ff
	ff 00		 cmp	 DWORD PTR _blockCount$[ebp+4], 0
  00106	77 1c		 ja	 SHORT $LN24@EncryptBuf@2
  00108	72 09		 jb	 SHORT $LN33@EncryptBuf@2
  0010a	83 bd e0 fd ff
	ff 20		 cmp	 DWORD PTR _blockCount$[ebp], 32 ; 00000020H
  00111	73 11		 jae	 SHORT $LN24@EncryptBuf@2
$LN33@EncryptBuf@2:

; 99   : 			endBlock = startBlock + (unsigned int) blockCount;

  00113	8b 85 e0 fd ff
	ff		 mov	 eax, DWORD PTR _blockCount$[ebp]
  00119	03 85 a0 fd ff
	ff		 add	 eax, DWORD PTR _startBlock$[ebp]
  0011f	89 45 fc	 mov	 DWORD PTR _endBlock$[ebp], eax

; 100  : 		else

  00122	eb 07		 jmp	 SHORT $LN23@EncryptBuf@2
$LN24@EncryptBuf@2:

; 101  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  00124	c7 45 fc 20 00
	00 00		 mov	 DWORD PTR _endBlock$[ebp], 32 ; 00000020H
$LN23@EncryptBuf@2:

; 102  : 
; 103  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  0012b	8b 4d f8	 mov	 ecx, DWORD PTR _finalInt64WhiteningValuesPtr$[ebp]
  0012e	89 8d d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], ecx

; 104  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  00134	8d 95 b8 fd ff
	ff		 lea	 edx, DWORD PTR _whiteningValue$[ebp]
  0013a	89 95 dc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr64$[ebp], edx

; 105  : 
; 106  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 107  : 		// whitening value for this data unit)
; 108  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  00140	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  00146	8b 8d c8 fd ff
	ff		 mov	 ecx, DWORD PTR _byteBufUnitNo$[ebp]
  0014c	89 08		 mov	 DWORD PTR [eax], ecx
  0014e	8b 95 cc fd ff
	ff		 mov	 edx, DWORD PTR _byteBufUnitNo$[ebp+4]
  00154	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 109  : 		*(whiteningValuePtr64 + 1) = 0;

  00157	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  0015d	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00164	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 110  : 		EncipherBlock (cipher, whiteningValue, ks2);

  0016b	8b 4d 20	 mov	 ecx, DWORD PTR _ks2$[ebp]
  0016e	51		 push	 ecx
  0016f	8d 95 b8 fd ff
	ff		 lea	 edx, DWORD PTR _whiteningValue$[ebp]
  00175	52		 push	 edx
  00176	8b 45 24	 mov	 eax, DWORD PTR _cipher$[ebp]
  00179	50		 push	 eax
  0017a	e8 00 00 00 00	 call	 _EncipherBlock@12

; 111  : 
; 112  : 		// Generate subsequent whitening values for blocks in this data unit. Note that all generated 128-bit
; 113  : 		// whitening values are stored in memory as a sequence of 64-bit integers in reverse order.
; 114  : 		for (block = 0; block < endBlock; block++)

  0017f	c7 85 a4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _block$[ebp], 0
  00189	eb 0f		 jmp	 SHORT $LN22@EncryptBuf@2
$LN21@EncryptBuf@2:
  0018b	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR _block$[ebp]
  00191	83 c1 01	 add	 ecx, 1
  00194	89 8d a4 fd ff
	ff		 mov	 DWORD PTR _block$[ebp], ecx
$LN22@EncryptBuf@2:
  0019a	8b 95 a4 fd ff
	ff		 mov	 edx, DWORD PTR _block$[ebp]
  001a0	3b 55 fc	 cmp	 edx, DWORD PTR _endBlock$[ebp]
  001a3	0f 83 75 01 00
	00		 jae	 $LN20@EncryptBuf@2

; 115  : 		{
; 116  : 			if (block >= startBlock)

  001a9	8b 85 a4 fd ff
	ff		 mov	 eax, DWORD PTR _block$[ebp]
  001af	3b 85 a0 fd ff
	ff		 cmp	 eax, DWORD PTR _startBlock$[ebp]
  001b5	72 5b		 jb	 SHORT $LN19@EncryptBuf@2

; 117  : 			{
; 118  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64++;

  001b7	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuesPtr64$[ebp]
  001bd	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  001c3	8b 02		 mov	 eax, DWORD PTR [edx]
  001c5	89 01		 mov	 DWORD PTR [ecx], eax
  001c7	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001ca	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  001cd	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuesPtr64$[ebp]
  001d3	83 e8 08	 sub	 eax, 8
  001d6	89 85 d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], eax
  001dc	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  001e2	83 c1 08	 add	 ecx, 8
  001e5	89 8d dc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr64$[ebp], ecx

; 119  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64;

  001eb	8b 95 d8 fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuesPtr64$[ebp]
  001f1	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  001f7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001f9	89 0a		 mov	 DWORD PTR [edx], ecx
  001fb	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001fe	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00201	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuesPtr64$[ebp]
  00207	83 e9 08	 sub	 ecx, 8
  0020a	89 8d d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], ecx

; 120  : 			}
; 121  : 			else

  00210	eb 0f		 jmp	 SHORT $LN18@EncryptBuf@2
$LN19@EncryptBuf@2:

; 122  : 				whiteningValuePtr64++;

  00212	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  00218	83 c2 08	 add	 edx, 8
  0021b	89 95 dc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr64$[ebp], edx
$LN18@EncryptBuf@2:

; 123  : 
; 124  : 			// Derive the next whitening value
; 125  : 
; 126  : #if BYTE_ORDER == LITTLE_ENDIAN
; 127  : 
; 128  : 			// Little-endian platforms
; 129  : 
; 130  : 			finalCarry = 
; 131  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 132  : 				135 : 0;

  00221	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  00227	8b 08		 mov	 ecx, DWORD PTR [eax]
  00229	83 e1 00	 and	 ecx, 0
  0022c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0022f	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H
  00235	89 8d 80 fd ff
	ff		 mov	 DWORD PTR tv285[ebp], ecx
  0023b	89 95 84 fd ff
	ff		 mov	 DWORD PTR tv285[ebp+4], edx
  00241	8b 85 80 fd ff
	ff		 mov	 eax, DWORD PTR tv285[ebp]
  00247	0b 85 84 fd ff
	ff		 or	 eax, DWORD PTR tv285[ebp+4]
  0024d	74 0c		 je	 SHORT $LN30@EncryptBuf@2
  0024f	c7 85 7c fd ff
	ff 87 00 00 00	 mov	 DWORD PTR tv92[ebp], 135 ; 00000087H
  00259	eb 0a		 jmp	 SHORT $LN31@EncryptBuf@2
$LN30@EncryptBuf@2:
  0025b	c7 85 7c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv92[ebp], 0
$LN31@EncryptBuf@2:
  00265	8a 8d 7c fd ff
	ff		 mov	 cl, BYTE PTR tv92[ebp]
  0026b	88 8d b7 fd ff
	ff		 mov	 BYTE PTR _finalCarry$[ebp], cl

; 133  : 
; 134  : 			*whiteningValuePtr64-- <<= 1;

  00271	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  00277	8b 02		 mov	 eax, DWORD PTR [edx]
  00279	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0027c	b1 01		 mov	 cl, 1
  0027e	e8 00 00 00 00	 call	 __allshl
  00283	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  00289	89 01		 mov	 DWORD PTR [ecx], eax
  0028b	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0028e	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  00294	83 ea 08	 sub	 edx, 8
  00297	89 95 dc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr64$[ebp], edx

; 135  : 
; 136  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  0029d	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  002a3	8b 08		 mov	 ecx, DWORD PTR [eax]
  002a5	83 e1 00	 and	 ecx, 0
  002a8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  002ab	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H
  002b1	89 8d 74 fd ff
	ff		 mov	 DWORD PTR tv312[ebp], ecx
  002b7	89 95 78 fd ff
	ff		 mov	 DWORD PTR tv312[ebp+4], edx
  002bd	8b 85 74 fd ff
	ff		 mov	 eax, DWORD PTR tv312[ebp]
  002c3	0b 85 78 fd ff
	ff		 or	 eax, DWORD PTR tv312[ebp+4]
  002c9	74 1b		 je	 SHORT $LN17@EncryptBuf@2

; 137  : 				*(whiteningValuePtr64 + 1) |= 1;	

  002cb	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  002d1	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002d4	83 ca 01	 or	 edx, 1
  002d7	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  002da	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  002e0	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  002e3	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$LN17@EncryptBuf@2:

; 138  : 
; 139  : 			*whiteningValuePtr64 <<= 1;

  002e6	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  002ec	8b 02		 mov	 eax, DWORD PTR [edx]
  002ee	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  002f1	b1 01		 mov	 cl, 1
  002f3	e8 00 00 00 00	 call	 __allshl
  002f8	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  002fe	89 01		 mov	 DWORD PTR [ecx], eax
  00300	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 140  : #else
; 141  : 
; 142  : 			// Big-endian platforms
; 143  : 
; 144  : 			finalCarry = 
; 145  : 				(*whiteningValuePtr64 & 0x80) ?
; 146  : 				135 : 0;
; 147  : 
; 148  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 149  : 
; 150  : 			whiteningValuePtr64--;
; 151  : 
; 152  : 			if (*whiteningValuePtr64 & 0x80)
; 153  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 154  : 
; 155  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 156  : #endif
; 157  : 
; 158  : 			whiteningValue[0] ^= finalCarry;

  00303	0f b6 95 b7 fd
	ff ff		 movzx	 edx, BYTE PTR _finalCarry$[ebp]
  0030a	0f b6 85 b8 fd
	ff ff		 movzx	 eax, BYTE PTR _whiteningValue$[ebp]
  00311	33 c2		 xor	 eax, edx
  00313	88 85 b8 fd ff
	ff		 mov	 BYTE PTR _whiteningValue$[ebp], al

; 159  : 		}

  00319	e9 6d fe ff ff	 jmp	 $LN21@EncryptBuf@2
$LN20@EncryptBuf@2:

; 160  : 
; 161  : 		dataUnitBufPtr = bufPtr;

  0031e	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  00324	89 8d e8 fd ff
	ff		 mov	 DWORD PTR _dataUnitBufPtr$[ebp], ecx

; 162  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  0032a	8b 55 f8	 mov	 edx, DWORD PTR _finalInt64WhiteningValuesPtr$[ebp]
  0032d	89 95 d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], edx

; 163  : 
; 164  : 		// Encrypt all blocks in this data unit
; 165  : 
; 166  : 		for (block = startBlock; block < endBlock; block++)

  00333	8b 85 a0 fd ff
	ff		 mov	 eax, DWORD PTR _startBlock$[ebp]
  00339	89 85 a4 fd ff
	ff		 mov	 DWORD PTR _block$[ebp], eax
  0033f	eb 0f		 jmp	 SHORT $LN16@EncryptBuf@2
$LN15@EncryptBuf@2:
  00341	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR _block$[ebp]
  00347	83 c1 01	 add	 ecx, 1
  0034a	89 8d a4 fd ff
	ff		 mov	 DWORD PTR _block$[ebp], ecx
$LN16@EncryptBuf@2:
  00350	8b 95 a4 fd ff
	ff		 mov	 edx, DWORD PTR _block$[ebp]
  00356	3b 55 fc	 cmp	 edx, DWORD PTR _endBlock$[ebp]
  00359	0f 83 83 00 00
	00		 jae	 $LN14@EncryptBuf@2

; 167  : 		{
; 168  : 			// Pre-whitening
; 169  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  0035f	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _bufPtr$[ebp]
  00365	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuesPtr64$[ebp]
  0036b	8b 10		 mov	 edx, DWORD PTR [eax]
  0036d	33 11		 xor	 edx, DWORD PTR [ecx]
  0036f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00372	33 41 04	 xor	 eax, DWORD PTR [ecx+4]
  00375	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  0037b	89 11		 mov	 DWORD PTR [ecx], edx
  0037d	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00380	8b 95 d8 fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuesPtr64$[ebp]
  00386	83 ea 08	 sub	 edx, 8
  00389	89 95 d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], edx
  0038f	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _bufPtr$[ebp]
  00395	83 c0 08	 add	 eax, 8
  00398	89 85 ec fd ff
	ff		 mov	 DWORD PTR _bufPtr$[ebp], eax

; 170  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  0039e	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  003a4	8b 95 d8 fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuesPtr64$[ebp]
  003aa	8b 01		 mov	 eax, DWORD PTR [ecx]
  003ac	33 02		 xor	 eax, DWORD PTR [edx]
  003ae	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  003b1	33 4a 04	 xor	 ecx, DWORD PTR [edx+4]
  003b4	8b 95 ec fd ff
	ff		 mov	 edx, DWORD PTR _bufPtr$[ebp]
  003ba	89 02		 mov	 DWORD PTR [edx], eax
  003bc	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  003bf	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuesPtr64$[ebp]
  003c5	83 e8 08	 sub	 eax, 8
  003c8	89 85 d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], eax
  003ce	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  003d4	83 c1 08	 add	 ecx, 8
  003d7	89 8d ec fd ff
	ff		 mov	 DWORD PTR _bufPtr$[ebp], ecx

; 171  : 		}

  003dd	e9 5f ff ff ff	 jmp	 $LN15@EncryptBuf@2
$LN14@EncryptBuf@2:

; 172  : 
; 173  : 		// Actual encryption
; 174  : 		EncipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);

  003e2	8b 55 fc	 mov	 edx, DWORD PTR _endBlock$[ebp]
  003e5	2b 95 a0 fd ff
	ff		 sub	 edx, DWORD PTR _startBlock$[ebp]
  003eb	52		 push	 edx
  003ec	8b 45 1c	 mov	 eax, DWORD PTR _ks$[ebp]
  003ef	50		 push	 eax
  003f0	8b 8d e8 fd ff
	ff		 mov	 ecx, DWORD PTR _dataUnitBufPtr$[ebp]
  003f6	51		 push	 ecx
  003f7	8b 55 24	 mov	 edx, DWORD PTR _cipher$[ebp]
  003fa	52		 push	 edx
  003fb	e8 00 00 00 00	 call	 _EncipherBlocks@16

; 175  : 		
; 176  : 		bufPtr = dataUnitBufPtr;

  00400	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _dataUnitBufPtr$[ebp]
  00406	89 85 ec fd ff
	ff		 mov	 DWORD PTR _bufPtr$[ebp], eax

; 177  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  0040c	8b 4d f8	 mov	 ecx, DWORD PTR _finalInt64WhiteningValuesPtr$[ebp]
  0040f	89 8d d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], ecx

; 178  : 
; 179  : 		for (block = startBlock; block < endBlock; block++)

  00415	8b 95 a0 fd ff
	ff		 mov	 edx, DWORD PTR _startBlock$[ebp]
  0041b	89 95 a4 fd ff
	ff		 mov	 DWORD PTR _block$[ebp], edx
  00421	eb 0f		 jmp	 SHORT $LN13@EncryptBuf@2
$LN12@EncryptBuf@2:
  00423	8b 85 a4 fd ff
	ff		 mov	 eax, DWORD PTR _block$[ebp]
  00429	83 c0 01	 add	 eax, 1
  0042c	89 85 a4 fd ff
	ff		 mov	 DWORD PTR _block$[ebp], eax
$LN13@EncryptBuf@2:
  00432	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR _block$[ebp]
  00438	3b 4d fc	 cmp	 ecx, DWORD PTR _endBlock$[ebp]
  0043b	0f 83 83 00 00
	00		 jae	 $LN11@EncryptBuf@2

; 180  : 		{
; 181  : 			// Post-whitening
; 182  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00441	8b 95 ec fd ff
	ff		 mov	 edx, DWORD PTR _bufPtr$[ebp]
  00447	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuesPtr64$[ebp]
  0044d	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0044f	33 08		 xor	 ecx, DWORD PTR [eax]
  00451	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00454	33 50 04	 xor	 edx, DWORD PTR [eax+4]
  00457	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _bufPtr$[ebp]
  0045d	89 08		 mov	 DWORD PTR [eax], ecx
  0045f	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00462	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuesPtr64$[ebp]
  00468	83 e9 08	 sub	 ecx, 8
  0046b	89 8d d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], ecx
  00471	8b 95 ec fd ff
	ff		 mov	 edx, DWORD PTR _bufPtr$[ebp]
  00477	83 c2 08	 add	 edx, 8
  0047a	89 95 ec fd ff
	ff		 mov	 DWORD PTR _bufPtr$[ebp], edx

; 183  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00480	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _bufPtr$[ebp]
  00486	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuesPtr64$[ebp]
  0048c	8b 10		 mov	 edx, DWORD PTR [eax]
  0048e	33 11		 xor	 edx, DWORD PTR [ecx]
  00490	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00493	33 41 04	 xor	 eax, DWORD PTR [ecx+4]
  00496	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  0049c	89 11		 mov	 DWORD PTR [ecx], edx
  0049e	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  004a1	8b 95 d8 fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuesPtr64$[ebp]
  004a7	83 ea 08	 sub	 edx, 8
  004aa	89 95 d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], edx
  004b0	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _bufPtr$[ebp]
  004b6	83 c0 08	 add	 eax, 8
  004b9	89 85 ec fd ff
	ff		 mov	 DWORD PTR _bufPtr$[ebp], eax

; 184  : 		}

  004bf	e9 5f ff ff ff	 jmp	 $LN12@EncryptBuf@2
$LN11@EncryptBuf@2:

; 185  : 
; 186  : 		blockCount -= endBlock - startBlock;

  004c4	8b 4d fc	 mov	 ecx, DWORD PTR _endBlock$[ebp]
  004c7	2b 8d a0 fd ff
	ff		 sub	 ecx, DWORD PTR _startBlock$[ebp]
  004cd	33 d2		 xor	 edx, edx
  004cf	8b 85 e0 fd ff
	ff		 mov	 eax, DWORD PTR _blockCount$[ebp]
  004d5	2b c1		 sub	 eax, ecx
  004d7	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR _blockCount$[ebp+4]
  004dd	1b ca		 sbb	 ecx, edx
  004df	89 85 e0 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp], eax
  004e5	89 8d e4 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp+4], ecx

; 187  : 		startBlock = 0;

  004eb	c7 85 a0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _startBlock$[ebp], 0

; 188  : 		dataUnitNo++;

  004f5	8b 95 a8 fd ff
	ff		 mov	 edx, DWORD PTR _dataUnitNo$[ebp]
  004fb	83 c2 01	 add	 edx, 1
  004fe	8b 85 ac fd ff
	ff		 mov	 eax, DWORD PTR _dataUnitNo$[ebp+4]
  00504	83 d0 00	 adc	 eax, 0
  00507	89 95 a8 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp], edx
  0050d	89 85 ac fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp+4], eax

; 189  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  00513	8b 8d a8 fd ff
	ff		 mov	 ecx, DWORD PTR _dataUnitNo$[ebp]
  00519	89 8d c8 fd ff
	ff		 mov	 DWORD PTR _byteBufUnitNo$[ebp], ecx
  0051f	8b 95 ac fd ff
	ff		 mov	 edx, DWORD PTR _dataUnitNo$[ebp+4]
  00525	89 95 cc fd ff
	ff		 mov	 DWORD PTR _byteBufUnitNo$[ebp+4], edx

; 190  : 	}

  0052b	e9 b9 fb ff ff	 jmp	 $LN26@EncryptBuf@2
$LN10@EncryptBuf@2:

; 191  : 
; 192  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  00530	8d 85 b8 fd ff
	ff		 lea	 eax, DWORD PTR _whiteningValue$[ebp]
  00536	89 85 98 fd ff
	ff		 mov	 DWORD PTR _burnm$26948[ebp], eax
  0053c	c7 85 9c fd ff
	ff 02 00 00 00	 mov	 DWORD PTR _burnc$26950[ebp], 2
$LN7@EncryptBuf@2:
  00546	8b 8d 9c fd ff
	ff		 mov	 ecx, DWORD PTR _burnc$26950[ebp]
  0054c	8b 95 9c fd ff
	ff		 mov	 edx, DWORD PTR _burnc$26950[ebp]
  00552	83 ea 01	 sub	 edx, 1
  00555	89 95 9c fd ff
	ff		 mov	 DWORD PTR _burnc$26950[ebp], edx
  0055b	85 c9		 test	 ecx, ecx
  0055d	74 24		 je	 SHORT $LN9@EncryptBuf@2
  0055f	8b 85 98 fd ff
	ff		 mov	 eax, DWORD PTR _burnm$26948[ebp]
  00565	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0056b	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00572	8b 8d 98 fd ff
	ff		 mov	 ecx, DWORD PTR _burnm$26948[ebp]
  00578	83 c1 08	 add	 ecx, 8
  0057b	89 8d 98 fd ff
	ff		 mov	 DWORD PTR _burnm$26948[ebp], ecx
  00581	eb c3		 jmp	 SHORT $LN7@EncryptBuf@2
$LN9@EncryptBuf@2:
  00583	33 d2		 xor	 edx, edx
  00585	75 a9		 jne	 SHORT $LN10@EncryptBuf@2
$LN5@EncryptBuf@2:

; 193  : 	FAST_ERASE64 (whiteningValues, sizeof (whiteningValues));

  00587	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _whiteningValues$[ebp]
  0058d	89 85 90 fd ff
	ff		 mov	 DWORD PTR _burnm$26957[ebp], eax
  00593	c7 85 94 fd ff
	ff 40 00 00 00	 mov	 DWORD PTR _burnc$26959[ebp], 64 ; 00000040H
$LN2@EncryptBuf@2:
  0059d	8b 8d 94 fd ff
	ff		 mov	 ecx, DWORD PTR _burnc$26959[ebp]
  005a3	8b 95 94 fd ff
	ff		 mov	 edx, DWORD PTR _burnc$26959[ebp]
  005a9	83 ea 01	 sub	 edx, 1
  005ac	89 95 94 fd ff
	ff		 mov	 DWORD PTR _burnc$26959[ebp], edx
  005b2	85 c9		 test	 ecx, ecx
  005b4	74 24		 je	 SHORT $LN4@EncryptBuf@2
  005b6	8b 85 90 fd ff
	ff		 mov	 eax, DWORD PTR _burnm$26957[ebp]
  005bc	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  005c2	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  005c9	8b 8d 90 fd ff
	ff		 mov	 ecx, DWORD PTR _burnm$26957[ebp]
  005cf	83 c1 08	 add	 ecx, 8
  005d2	89 8d 90 fd ff
	ff		 mov	 DWORD PTR _burnm$26957[ebp], ecx
  005d8	eb c3		 jmp	 SHORT $LN2@EncryptBuf@2
$LN4@EncryptBuf@2:
  005da	33 d2		 xor	 edx, edx
  005dc	75 a9		 jne	 SHORT $LN5@EncryptBuf@2
$LN29@EncryptBuf@2:

; 194  : }

  005de	8b 4d f4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005e1	33 cd		 xor	 ecx, ebp
  005e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005e8	8b e5		 mov	 esp, ebp
  005ea	5d		 pop	 ebp
  005eb	c2 20 00	 ret	 32			; 00000020H
_EncryptBufferXTSParallel@32 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp
;	COMDAT _EncryptBufferXTSNonParallel@32
_TEXT	SEGMENT
tv328 = -116						; size = 8
tv133 = -108						; size = 4
tv301 = -104						; size = 8
tv177 = -96						; size = 8
_burnm$27012 = -88					; size = 4
_burnc$27014 = -84					; size = 4
_startBlock$ = -80					; size = 4
_block$ = -76						; size = 4
_dataUnitNo$ = -72					; size = 8
_finalCarry$ = -57					; size = 1
_whiteningValue$ = -56					; size = 16
_byteBufUnitNo$ = -40					; size = 16
__$ArrayPad$ = -24					; size = 4
_whiteningValuePtr64$ = -20				; size = 4
_blockCount$ = -16					; size = 8
_bufPtr$ = -8						; size = 4
_endBlock$ = -4						; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_ks$ = 28						; size = 4
_ks2$ = 32						; size = 4
_cipher$ = 36						; size = 4
_EncryptBufferXTSNonParallel@32 PROC			; COMDAT

; 205  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 74	 sub	 esp, 116		; 00000074H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 e8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 206  : 	unsigned __int8 finalCarry;
; 207  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 208  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 209  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  00012	8d 45 c8	 lea	 eax, DWORD PTR _whiteningValue$[ebp]
  00015	89 45 ec	 mov	 DWORD PTR _whiteningValuePtr64$[ebp], eax

; 210  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;

  00018	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0001b	89 4d f8	 mov	 DWORD PTR _bufPtr$[ebp], ecx

; 211  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;

  0001e	8b 55 18	 mov	 edx, DWORD PTR _startCipherBlockNo$[ebp]
  00021	89 55 b0	 mov	 DWORD PTR _startBlock$[ebp], edx

; 212  : 	TC_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 213  : 
; 214  : 	/* The encrypted data unit number (i.e. the resultant ciphertext block) is to be multiplied in the
; 215  : 	finite field GF(2^128) by j-th power of n, where j is the sequential plaintext/ciphertext block
; 216  : 	number and n is 2, a primitive element of GF(2^128). This can be (and is) simplified and implemented
; 217  : 	as a left shift of the preceding whitening value by one bit (with carry propagating). In addition, if
; 218  : 	the shift of the highest byte results in a carry, 135 is XORed into the lowest byte. The value 135 is
; 219  : 	derived from the modulus of the Galois Field (x^128+x^7+x^2+x+1). */
; 220  : 
; 221  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 222  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 223  : 	dataUnitNo = startDataUnitNo->Value;

  00024	8b 45 14	 mov	 eax, DWORD PTR _startDataUnitNo$[ebp]
  00027	8b 08		 mov	 ecx, DWORD PTR [eax]
  00029	89 4d b8	 mov	 DWORD PTR _dataUnitNo$[ebp], ecx
  0002c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0002f	89 55 bc	 mov	 DWORD PTR _dataUnitNo$[ebp+4], edx

; 224  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  00032	8b 45 b8	 mov	 eax, DWORD PTR _dataUnitNo$[ebp]
  00035	89 45 d8	 mov	 DWORD PTR _byteBufUnitNo$[ebp], eax
  00038	8b 4d bc	 mov	 ecx, DWORD PTR _dataUnitNo$[ebp+4]
  0003b	89 4d dc	 mov	 DWORD PTR _byteBufUnitNo$[ebp+4], ecx

; 225  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;

  0003e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _byteBufUnitNo$[ebp+8], 0
  00045	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _byteBufUnitNo$[ebp+12], 0

; 226  : 
; 227  : 	if (length % BYTES_PER_XTS_BLOCK)

  0004c	6a 00		 push	 0
  0004e	6a 10		 push	 16			; 00000010H
  00050	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp+4]
  00053	52		 push	 edx
  00054	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 __aullrem
  0005d	89 45 a0	 mov	 DWORD PTR tv177[ebp], eax
  00060	89 55 a4	 mov	 DWORD PTR tv177[ebp+4], edx
  00063	8b 4d a0	 mov	 ecx, DWORD PTR tv177[ebp]
  00066	0b 4d a4	 or	 ecx, DWORD PTR tv177[ebp+4]
  00069	74 16		 je	 SHORT $LN16@EncryptBuf@3

; 228  : 		TC_THROW_FATAL_EXCEPTION;

  0006b	68 43 54 00 00	 push	 21571			; 00005443H
  00070	6a 00		 push	 0
  00072	6a 00		 push	 0
  00074	68 e4 00 00 00	 push	 228			; 000000e4H
  00079	6a 29		 push	 41			; 00000029H
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN16@EncryptBuf@3:

; 229  : 
; 230  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  00081	6a 00		 push	 0
  00083	6a 10		 push	 16			; 00000010H
  00085	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp+4]
  00088	52		 push	 edx
  00089	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 __aulldiv
  00092	89 45 f0	 mov	 DWORD PTR _blockCount$[ebp], eax
  00095	89 55 f4	 mov	 DWORD PTR _blockCount$[ebp+4], edx
$LN15@EncryptBuf@3:

; 231  : 
; 232  : 	// Process all blocks in the buffer
; 233  : 	while (blockCount > 0)

  00098	83 7d f4 00	 cmp	 DWORD PTR _blockCount$[ebp+4], 0
  0009c	77 0a		 ja	 SHORT $LN21@EncryptBuf@3
  0009e	83 7d f0 00	 cmp	 DWORD PTR _blockCount$[ebp], 0
  000a2	0f 86 2f 02 00
	00		 jbe	 $LN5@EncryptBuf@3
$LN21@EncryptBuf@3:

; 234  : 	{
; 235  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  000a8	83 7d f4 00	 cmp	 DWORD PTR _blockCount$[ebp+4], 0
  000ac	77 13		 ja	 SHORT $LN13@EncryptBuf@3
  000ae	72 06		 jb	 SHORT $LN22@EncryptBuf@3
  000b0	83 7d f0 20	 cmp	 DWORD PTR _blockCount$[ebp], 32 ; 00000020H
  000b4	73 0b		 jae	 SHORT $LN13@EncryptBuf@3
$LN22@EncryptBuf@3:

; 236  : 			endBlock = startBlock + (unsigned int) blockCount;

  000b6	8b 4d f0	 mov	 ecx, DWORD PTR _blockCount$[ebp]
  000b9	03 4d b0	 add	 ecx, DWORD PTR _startBlock$[ebp]
  000bc	89 4d fc	 mov	 DWORD PTR _endBlock$[ebp], ecx

; 237  : 		else

  000bf	eb 07		 jmp	 SHORT $LN12@EncryptBuf@3
$LN13@EncryptBuf@3:

; 238  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  000c1	c7 45 fc 20 00
	00 00		 mov	 DWORD PTR _endBlock$[ebp], 32 ; 00000020H
$LN12@EncryptBuf@3:

; 239  : 
; 240  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  000c8	8d 55 c8	 lea	 edx, DWORD PTR _whiteningValue$[ebp]
  000cb	89 55 ec	 mov	 DWORD PTR _whiteningValuePtr64$[ebp], edx

; 241  : 
; 242  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 243  : 		// whitening value for this data unit)
; 244  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  000ce	8b 45 ec	 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  000d1	8b 4d d8	 mov	 ecx, DWORD PTR _byteBufUnitNo$[ebp]
  000d4	89 08		 mov	 DWORD PTR [eax], ecx
  000d6	8b 55 dc	 mov	 edx, DWORD PTR _byteBufUnitNo$[ebp+4]
  000d9	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 245  : 		*(whiteningValuePtr64 + 1) = 0;

  000dc	8b 45 ec	 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  000df	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  000e6	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 246  : 		EncipherBlock (cipher, whiteningValue, ks2);

  000ed	8b 4d 20	 mov	 ecx, DWORD PTR _ks2$[ebp]
  000f0	51		 push	 ecx
  000f1	8d 55 c8	 lea	 edx, DWORD PTR _whiteningValue$[ebp]
  000f4	52		 push	 edx
  000f5	8b 45 24	 mov	 eax, DWORD PTR _cipher$[ebp]
  000f8	50		 push	 eax
  000f9	e8 00 00 00 00	 call	 _EncipherBlock@12

; 247  : 
; 248  : 		// Generate (and apply) subsequent whitening values for blocks in this data unit and
; 249  : 		// encrypt all relevant blocks in this data unit
; 250  : 		for (block = 0; block < endBlock; block++)

  000fe	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _block$[ebp], 0
  00105	eb 09		 jmp	 SHORT $LN11@EncryptBuf@3
$LN10@EncryptBuf@3:
  00107	8b 4d b4	 mov	 ecx, DWORD PTR _block$[ebp]
  0010a	83 c1 01	 add	 ecx, 1
  0010d	89 4d b4	 mov	 DWORD PTR _block$[ebp], ecx
$LN11@EncryptBuf@3:
  00110	8b 55 b4	 mov	 edx, DWORD PTR _block$[ebp]
  00113	3b 55 fc	 cmp	 edx, DWORD PTR _endBlock$[ebp]
  00116	0f 83 79 01 00
	00		 jae	 $LN9@EncryptBuf@3

; 251  : 		{
; 252  : 			if (block >= startBlock)

  0011c	8b 45 b4	 mov	 eax, DWORD PTR _block$[ebp]
  0011f	3b 45 b0	 cmp	 eax, DWORD PTR _startBlock$[ebp]
  00122	0f 82 b2 00 00
	00		 jb	 $LN8@EncryptBuf@3

; 253  : 			{
; 254  : 				// Pre-whitening
; 255  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  00128	8b 4d f8	 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  0012b	8b 55 ec	 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  0012e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00130	33 02		 xor	 eax, DWORD PTR [edx]
  00132	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00135	33 4a 04	 xor	 ecx, DWORD PTR [edx+4]
  00138	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  0013b	89 02		 mov	 DWORD PTR [edx], eax
  0013d	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00140	8b 45 ec	 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  00143	83 c0 08	 add	 eax, 8
  00146	89 45 ec	 mov	 DWORD PTR _whiteningValuePtr64$[ebp], eax
  00149	8b 4d f8	 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  0014c	83 c1 08	 add	 ecx, 8
  0014f	89 4d f8	 mov	 DWORD PTR _bufPtr$[ebp], ecx

; 256  : 				*bufPtr-- ^= *whiteningValuePtr64--;

  00152	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  00155	8b 45 ec	 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  00158	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0015a	33 08		 xor	 ecx, DWORD PTR [eax]
  0015c	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0015f	33 50 04	 xor	 edx, DWORD PTR [eax+4]
  00162	8b 45 f8	 mov	 eax, DWORD PTR _bufPtr$[ebp]
  00165	89 08		 mov	 DWORD PTR [eax], ecx
  00167	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0016a	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  0016d	83 e9 08	 sub	 ecx, 8
  00170	89 4d ec	 mov	 DWORD PTR _whiteningValuePtr64$[ebp], ecx
  00173	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  00176	83 ea 08	 sub	 edx, 8
  00179	89 55 f8	 mov	 DWORD PTR _bufPtr$[ebp], edx

; 257  : 
; 258  : 				// Actual encryption
; 259  : 				EncipherBlock (cipher, bufPtr, ks);

  0017c	8b 45 1c	 mov	 eax, DWORD PTR _ks$[ebp]
  0017f	50		 push	 eax
  00180	8b 4d f8	 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  00183	51		 push	 ecx
  00184	8b 55 24	 mov	 edx, DWORD PTR _cipher$[ebp]
  00187	52		 push	 edx
  00188	e8 00 00 00 00	 call	 _EncipherBlock@12

; 260  : 
; 261  : 				// Post-whitening
; 262  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  0018d	8b 45 f8	 mov	 eax, DWORD PTR _bufPtr$[ebp]
  00190	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  00193	8b 10		 mov	 edx, DWORD PTR [eax]
  00195	33 11		 xor	 edx, DWORD PTR [ecx]
  00197	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019a	33 41 04	 xor	 eax, DWORD PTR [ecx+4]
  0019d	8b 4d f8	 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  001a0	89 11		 mov	 DWORD PTR [ecx], edx
  001a2	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  001a5	8b 55 ec	 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  001a8	83 c2 08	 add	 edx, 8
  001ab	89 55 ec	 mov	 DWORD PTR _whiteningValuePtr64$[ebp], edx
  001ae	8b 45 f8	 mov	 eax, DWORD PTR _bufPtr$[ebp]
  001b1	83 c0 08	 add	 eax, 8
  001b4	89 45 f8	 mov	 DWORD PTR _bufPtr$[ebp], eax

; 263  : 				*bufPtr++ ^= *whiteningValuePtr64;

  001b7	8b 4d f8	 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  001ba	8b 55 ec	 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  001bd	8b 01		 mov	 eax, DWORD PTR [ecx]
  001bf	33 02		 xor	 eax, DWORD PTR [edx]
  001c1	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  001c4	33 4a 04	 xor	 ecx, DWORD PTR [edx+4]
  001c7	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  001ca	89 02		 mov	 DWORD PTR [edx], eax
  001cc	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  001cf	8b 45 f8	 mov	 eax, DWORD PTR _bufPtr$[ebp]
  001d2	83 c0 08	 add	 eax, 8
  001d5	89 45 f8	 mov	 DWORD PTR _bufPtr$[ebp], eax

; 264  : 			}
; 265  : 			else

  001d8	eb 09		 jmp	 SHORT $LN7@EncryptBuf@3
$LN8@EncryptBuf@3:

; 266  : 				whiteningValuePtr64++;

  001da	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  001dd	83 c1 08	 add	 ecx, 8
  001e0	89 4d ec	 mov	 DWORD PTR _whiteningValuePtr64$[ebp], ecx
$LN7@EncryptBuf@3:

; 267  : 
; 268  : 			// Derive the next whitening value
; 269  : 
; 270  : #if BYTE_ORDER == LITTLE_ENDIAN
; 271  : 
; 272  : 			// Little-endian platforms
; 273  : 
; 274  : 			finalCarry = 
; 275  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 276  : 				135 : 0;

  001e3	8b 55 ec	 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  001e6	8b 02		 mov	 eax, DWORD PTR [edx]
  001e8	83 e0 00	 and	 eax, 0
  001eb	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001ee	81 e1 00 00 00
	80		 and	 ecx, -2147483648	; 80000000H
  001f4	89 45 98	 mov	 DWORD PTR tv301[ebp], eax
  001f7	89 4d 9c	 mov	 DWORD PTR tv301[ebp+4], ecx
  001fa	8b 55 98	 mov	 edx, DWORD PTR tv301[ebp]
  001fd	0b 55 9c	 or	 edx, DWORD PTR tv301[ebp+4]
  00200	74 09		 je	 SHORT $LN19@EncryptBuf@3
  00202	c7 45 94 87 00
	00 00		 mov	 DWORD PTR tv133[ebp], 135 ; 00000087H
  00209	eb 07		 jmp	 SHORT $LN20@EncryptBuf@3
$LN19@EncryptBuf@3:
  0020b	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv133[ebp], 0
$LN20@EncryptBuf@3:
  00212	8a 45 94	 mov	 al, BYTE PTR tv133[ebp]
  00215	88 45 c7	 mov	 BYTE PTR _finalCarry$[ebp], al

; 277  : 
; 278  : 			*whiteningValuePtr64-- <<= 1;

  00218	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  0021b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0021d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00220	b1 01		 mov	 cl, 1
  00222	e8 00 00 00 00	 call	 __allshl
  00227	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  0022a	89 01		 mov	 DWORD PTR [ecx], eax
  0022c	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0022f	8b 55 ec	 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  00232	83 ea 08	 sub	 edx, 8
  00235	89 55 ec	 mov	 DWORD PTR _whiteningValuePtr64$[ebp], edx

; 279  : 
; 280  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  00238	8b 45 ec	 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  0023b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0023d	83 e1 00	 and	 ecx, 0
  00240	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00243	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H
  00249	89 4d 8c	 mov	 DWORD PTR tv328[ebp], ecx
  0024c	89 55 90	 mov	 DWORD PTR tv328[ebp+4], edx
  0024f	8b 45 8c	 mov	 eax, DWORD PTR tv328[ebp]
  00252	0b 45 90	 or	 eax, DWORD PTR tv328[ebp+4]
  00255	74 15		 je	 SHORT $LN6@EncryptBuf@3

; 281  : 				*(whiteningValuePtr64 + 1) |= 1;	

  00257	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  0025a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0025d	83 ca 01	 or	 edx, 1
  00260	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00263	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  00266	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00269	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$LN6@EncryptBuf@3:

; 282  : 
; 283  : 			*whiteningValuePtr64 <<= 1;

  0026c	8b 55 ec	 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  0026f	8b 02		 mov	 eax, DWORD PTR [edx]
  00271	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00274	b1 01		 mov	 cl, 1
  00276	e8 00 00 00 00	 call	 __allshl
  0027b	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  0027e	89 01		 mov	 DWORD PTR [ecx], eax
  00280	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 284  : #else
; 285  : 
; 286  : 			// Big-endian platforms
; 287  : 
; 288  : 			finalCarry = 
; 289  : 				(*whiteningValuePtr64 & 0x80) ?
; 290  : 				135 : 0;
; 291  : 
; 292  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 293  : 
; 294  : 			whiteningValuePtr64--;
; 295  : 
; 296  : 			if (*whiteningValuePtr64 & 0x80)
; 297  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 298  : 
; 299  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 300  : #endif
; 301  : 
; 302  : 			whiteningValue[0] ^= finalCarry;

  00283	0f b6 55 c7	 movzx	 edx, BYTE PTR _finalCarry$[ebp]
  00287	0f b6 45 c8	 movzx	 eax, BYTE PTR _whiteningValue$[ebp]
  0028b	33 c2		 xor	 eax, edx
  0028d	88 45 c8	 mov	 BYTE PTR _whiteningValue$[ebp], al

; 303  : 		}

  00290	e9 72 fe ff ff	 jmp	 $LN10@EncryptBuf@3
$LN9@EncryptBuf@3:

; 304  : 
; 305  : 		blockCount -= endBlock - startBlock;

  00295	8b 4d fc	 mov	 ecx, DWORD PTR _endBlock$[ebp]
  00298	2b 4d b0	 sub	 ecx, DWORD PTR _startBlock$[ebp]
  0029b	33 d2		 xor	 edx, edx
  0029d	8b 45 f0	 mov	 eax, DWORD PTR _blockCount$[ebp]
  002a0	2b c1		 sub	 eax, ecx
  002a2	8b 4d f4	 mov	 ecx, DWORD PTR _blockCount$[ebp+4]
  002a5	1b ca		 sbb	 ecx, edx
  002a7	89 45 f0	 mov	 DWORD PTR _blockCount$[ebp], eax
  002aa	89 4d f4	 mov	 DWORD PTR _blockCount$[ebp+4], ecx

; 306  : 		startBlock = 0;

  002ad	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _startBlock$[ebp], 0

; 307  : 		dataUnitNo++;

  002b4	8b 55 b8	 mov	 edx, DWORD PTR _dataUnitNo$[ebp]
  002b7	83 c2 01	 add	 edx, 1
  002ba	8b 45 bc	 mov	 eax, DWORD PTR _dataUnitNo$[ebp+4]
  002bd	83 d0 00	 adc	 eax, 0
  002c0	89 55 b8	 mov	 DWORD PTR _dataUnitNo$[ebp], edx
  002c3	89 45 bc	 mov	 DWORD PTR _dataUnitNo$[ebp+4], eax

; 308  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  002c6	8b 4d b8	 mov	 ecx, DWORD PTR _dataUnitNo$[ebp]
  002c9	89 4d d8	 mov	 DWORD PTR _byteBufUnitNo$[ebp], ecx
  002cc	8b 55 bc	 mov	 edx, DWORD PTR _dataUnitNo$[ebp+4]
  002cf	89 55 dc	 mov	 DWORD PTR _byteBufUnitNo$[ebp+4], edx

; 309  : 	}

  002d2	e9 c1 fd ff ff	 jmp	 $LN15@EncryptBuf@3
$LN5@EncryptBuf@3:

; 310  : 
; 311  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  002d7	8d 45 c8	 lea	 eax, DWORD PTR _whiteningValue$[ebp]
  002da	89 45 a8	 mov	 DWORD PTR _burnm$27012[ebp], eax
  002dd	c7 45 ac 02 00
	00 00		 mov	 DWORD PTR _burnc$27014[ebp], 2
$LN2@EncryptBuf@3:
  002e4	8b 4d ac	 mov	 ecx, DWORD PTR _burnc$27014[ebp]
  002e7	8b 55 ac	 mov	 edx, DWORD PTR _burnc$27014[ebp]
  002ea	83 ea 01	 sub	 edx, 1
  002ed	89 55 ac	 mov	 DWORD PTR _burnc$27014[ebp], edx
  002f0	85 c9		 test	 ecx, ecx
  002f2	74 1b		 je	 SHORT $LN4@EncryptBuf@3
  002f4	8b 45 a8	 mov	 eax, DWORD PTR _burnm$27012[ebp]
  002f7	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  002fd	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00304	8b 4d a8	 mov	 ecx, DWORD PTR _burnm$27012[ebp]
  00307	83 c1 08	 add	 ecx, 8
  0030a	89 4d a8	 mov	 DWORD PTR _burnm$27012[ebp], ecx
  0030d	eb d5		 jmp	 SHORT $LN2@EncryptBuf@3
$LN4@EncryptBuf@3:
  0030f	33 d2		 xor	 edx, edx
  00311	75 c4		 jne	 SHORT $LN5@EncryptBuf@3
$LN18@EncryptBuf@3:

; 312  : }

  00313	8b 4d e8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00316	33 cd		 xor	 ecx, ebp
  00318	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0031d	8b e5		 mov	 esp, ebp
  0031f	5d		 pop	 ebp
  00320	c2 20 00	 ret	 32			; 00000020H
_EncryptBufferXTSNonParallel@32 ENDP
_TEXT	ENDS
PUBLIC	_DecryptBufferXTS@32
; Function compile flags: /Odtp
;	COMDAT _DecryptBufferXTS@32
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_ks$ = 28						; size = 4
_ks2$ = 32						; size = 4
_cipher$ = 36						; size = 4
_DecryptBufferXTS@32 PROC				; COMDAT

; 323  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 324  : 	if (CipherSupportsIntraDataUnitParallelization (cipher))

  00005	8b 45 24	 mov	 eax, DWORD PTR _cipher$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _CipherSupportsIntraDataUnitParallelization@4
  0000e	85 c0		 test	 eax, eax
  00010	74 27		 je	 SHORT $LN2@DecryptBuf

; 325  : 		DecryptBufferXTSParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  00012	8b 4d 24	 mov	 ecx, DWORD PTR _cipher$[ebp]
  00015	51		 push	 ecx
  00016	8b 55 20	 mov	 edx, DWORD PTR _ks2$[ebp]
  00019	52		 push	 edx
  0001a	8b 45 1c	 mov	 eax, DWORD PTR _ks$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 18	 mov	 ecx, DWORD PTR _startCipherBlockNo$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 14	 mov	 edx, DWORD PTR _startDataUnitNo$[ebp]
  00025	52		 push	 edx
  00026	8b 45 10	 mov	 eax, DWORD PTR _length$[ebp+4]
  00029	50		 push	 eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _length$[ebp]
  0002d	51		 push	 ecx
  0002e	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 _DecryptBufferXTSParallel@32

; 326  : 	else

  00037	eb 25		 jmp	 SHORT $LN3@DecryptBuf
$LN2@DecryptBuf:

; 327  : 		DecryptBufferXTSNonParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  00039	8b 45 24	 mov	 eax, DWORD PTR _cipher$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d 20	 mov	 ecx, DWORD PTR _ks2$[ebp]
  00040	51		 push	 ecx
  00041	8b 55 1c	 mov	 edx, DWORD PTR _ks$[ebp]
  00044	52		 push	 edx
  00045	8b 45 18	 mov	 eax, DWORD PTR _startCipherBlockNo$[ebp]
  00048	50		 push	 eax
  00049	8b 4d 14	 mov	 ecx, DWORD PTR _startDataUnitNo$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp+4]
  00050	52		 push	 edx
  00051	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  00054	50		 push	 eax
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 _DecryptBufferXTSNonParallel@32
$LN3@DecryptBuf:

; 328  : }

  0005e	5d		 pop	 ebp
  0005f	c2 20 00	 ret	 32			; 00000020H
_DecryptBufferXTS@32 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_DecipherBlocks@16:PROC
; Function compile flags: /Odtp
;	COMDAT _DecryptBufferXTSParallel@32
_TEXT	SEGMENT
tv312 = -652						; size = 8
tv92 = -644						; size = 4
tv285 = -640						; size = 8
tv227 = -632						; size = 8
_burnm$27104 = -624					; size = 4
_burnc$27106 = -620					; size = 4
_burnm$27095 = -616					; size = 4
_burnc$27097 = -612					; size = 4
_startBlock$ = -608					; size = 4
_block$ = -604						; size = 4
_dataUnitNo$ = -600					; size = 8
_finalCarry$ = -585					; size = 1
_whiteningValue$ = -584					; size = 16
_byteBufUnitNo$ = -568					; size = 16
_whiteningValuesPtr64$ = -552				; size = 4
_whiteningValuePtr64$ = -548				; size = 4
_blockCount$ = -544					; size = 8
_dataUnitBufPtr$ = -536					; size = 4
_bufPtr$ = -532						; size = 4
_whiteningValues$ = -528				; size = 512
__$ArrayPad$ = -12					; size = 4
_finalInt64WhiteningValuesPtr$ = -8			; size = 4
_endBlock$ = -4						; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_ks$ = 28						; size = 4
_ks2$ = 32						; size = 4
_cipher$ = 36						; size = 4
_DecryptBufferXTSParallel@32 PROC			; COMDAT

; 339  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 8c 02 00
	00		 sub	 esp, 652		; 0000028cH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 f4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 340  : 	unsigned __int8 finalCarry;
; 341  : 	unsigned __int8 whiteningValues [ENCRYPTION_DATA_UNIT_SIZE];
; 342  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 343  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 344  : 	unsigned __int64 *whiteningValuesPtr64 = (unsigned __int64 *) whiteningValues;

  00015	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _whiteningValues$[ebp]
  0001b	89 85 d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], eax

; 345  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  00021	8d 8d b8 fd ff
	ff		 lea	 ecx, DWORD PTR _whiteningValue$[ebp]
  00027	89 8d dc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr64$[ebp], ecx

; 346  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;

  0002d	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00030	89 95 ec fd ff
	ff		 mov	 DWORD PTR _bufPtr$[ebp], edx

; 347  : 	unsigned __int64 *dataUnitBufPtr;
; 348  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;

  00036	8b 45 18	 mov	 eax, DWORD PTR _startCipherBlockNo$[ebp]
  00039	89 85 a0 fd ff
	ff		 mov	 DWORD PTR _startBlock$[ebp], eax

; 349  : 	unsigned __int64 *const finalInt64WhiteningValuesPtr = whiteningValuesPtr64 + sizeof (whiteningValues) / sizeof (*whiteningValuesPtr64) - 1;

  0003f	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuesPtr64$[ebp]
  00045	81 c1 f8 01 00
	00		 add	 ecx, 504		; 000001f8H
  0004b	89 4d f8	 mov	 DWORD PTR _finalInt64WhiteningValuesPtr$[ebp], ecx

; 350  : 	TC_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 351  : 
; 352  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 353  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 354  : 	dataUnitNo = startDataUnitNo->Value;

  0004e	8b 55 14	 mov	 edx, DWORD PTR _startDataUnitNo$[ebp]
  00051	8b 02		 mov	 eax, DWORD PTR [edx]
  00053	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp], eax
  00059	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0005c	89 8d ac fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp+4], ecx

; 355  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  00062	8b 95 a8 fd ff
	ff		 mov	 edx, DWORD PTR _dataUnitNo$[ebp]
  00068	89 95 c8 fd ff
	ff		 mov	 DWORD PTR _byteBufUnitNo$[ebp], edx
  0006e	8b 85 ac fd ff
	ff		 mov	 eax, DWORD PTR _dataUnitNo$[ebp+4]
  00074	89 85 cc fd ff
	ff		 mov	 DWORD PTR _byteBufUnitNo$[ebp+4], eax

; 356  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;

  0007a	c7 85 d0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _byteBufUnitNo$[ebp+8], 0
  00084	c7 85 d4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _byteBufUnitNo$[ebp+12], 0

; 357  : 
; 358  : 	if (length % BYTES_PER_XTS_BLOCK)

  0008e	6a 00		 push	 0
  00090	6a 10		 push	 16			; 00000010H
  00092	8b 4d 10	 mov	 ecx, DWORD PTR _length$[ebp+4]
  00095	51		 push	 ecx
  00096	8b 55 0c	 mov	 edx, DWORD PTR _length$[ebp]
  00099	52		 push	 edx
  0009a	e8 00 00 00 00	 call	 __aullrem
  0009f	89 85 88 fd ff
	ff		 mov	 DWORD PTR tv227[ebp], eax
  000a5	89 95 8c fd ff
	ff		 mov	 DWORD PTR tv227[ebp+4], edx
  000ab	8b 85 88 fd ff
	ff		 mov	 eax, DWORD PTR tv227[ebp]
  000b1	0b 85 8c fd ff
	ff		 or	 eax, DWORD PTR tv227[ebp+4]
  000b7	74 16		 je	 SHORT $LN27@DecryptBuf@2

; 359  : 		TC_THROW_FATAL_EXCEPTION;

  000b9	68 43 54 00 00	 push	 21571			; 00005443H
  000be	6a 00		 push	 0
  000c0	6a 00		 push	 0
  000c2	68 67 01 00 00	 push	 359			; 00000167H
  000c7	6a 29		 push	 41			; 00000029H
  000c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN27@DecryptBuf@2:

; 360  : 
; 361  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  000cf	6a 00		 push	 0
  000d1	6a 10		 push	 16			; 00000010H
  000d3	8b 4d 10	 mov	 ecx, DWORD PTR _length$[ebp+4]
  000d6	51		 push	 ecx
  000d7	8b 55 0c	 mov	 edx, DWORD PTR _length$[ebp]
  000da	52		 push	 edx
  000db	e8 00 00 00 00	 call	 __aulldiv
  000e0	89 85 e0 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp], eax
  000e6	89 95 e4 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp+4], edx
$LN26@DecryptBuf@2:

; 362  : 
; 363  : 	// Process all blocks in the buffer
; 364  : 	while (blockCount > 0)

  000ec	83 bd e4 fd ff
	ff 00		 cmp	 DWORD PTR _blockCount$[ebp+4], 0
  000f3	77 0d		 ja	 SHORT $LN32@DecryptBuf@2
  000f5	83 bd e0 fd ff
	ff 00		 cmp	 DWORD PTR _blockCount$[ebp], 0
  000fc	0f 86 31 04 00
	00		 jbe	 $LN10@DecryptBuf@2
$LN32@DecryptBuf@2:

; 365  : 	{
; 366  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  00102	83 bd e4 fd ff
	ff 00		 cmp	 DWORD PTR _blockCount$[ebp+4], 0
  00109	77 1c		 ja	 SHORT $LN24@DecryptBuf@2
  0010b	72 09		 jb	 SHORT $LN33@DecryptBuf@2
  0010d	83 bd e0 fd ff
	ff 20		 cmp	 DWORD PTR _blockCount$[ebp], 32 ; 00000020H
  00114	73 11		 jae	 SHORT $LN24@DecryptBuf@2
$LN33@DecryptBuf@2:

; 367  : 			endBlock = startBlock + (unsigned int) blockCount;

  00116	8b 85 e0 fd ff
	ff		 mov	 eax, DWORD PTR _blockCount$[ebp]
  0011c	03 85 a0 fd ff
	ff		 add	 eax, DWORD PTR _startBlock$[ebp]
  00122	89 45 fc	 mov	 DWORD PTR _endBlock$[ebp], eax

; 368  : 		else

  00125	eb 07		 jmp	 SHORT $LN23@DecryptBuf@2
$LN24@DecryptBuf@2:

; 369  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  00127	c7 45 fc 20 00
	00 00		 mov	 DWORD PTR _endBlock$[ebp], 32 ; 00000020H
$LN23@DecryptBuf@2:

; 370  : 
; 371  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  0012e	8b 4d f8	 mov	 ecx, DWORD PTR _finalInt64WhiteningValuesPtr$[ebp]
  00131	89 8d d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], ecx

; 372  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  00137	8d 95 b8 fd ff
	ff		 lea	 edx, DWORD PTR _whiteningValue$[ebp]
  0013d	89 95 dc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr64$[ebp], edx

; 373  : 
; 374  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 375  : 		// whitening value for this data unit)
; 376  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  00143	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  00149	8b 8d c8 fd ff
	ff		 mov	 ecx, DWORD PTR _byteBufUnitNo$[ebp]
  0014f	89 08		 mov	 DWORD PTR [eax], ecx
  00151	8b 95 cc fd ff
	ff		 mov	 edx, DWORD PTR _byteBufUnitNo$[ebp+4]
  00157	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 377  : 		*(whiteningValuePtr64 + 1) = 0;

  0015a	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  00160	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00167	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 378  : 		EncipherBlock (cipher, whiteningValue, ks2);

  0016e	8b 4d 20	 mov	 ecx, DWORD PTR _ks2$[ebp]
  00171	51		 push	 ecx
  00172	8d 95 b8 fd ff
	ff		 lea	 edx, DWORD PTR _whiteningValue$[ebp]
  00178	52		 push	 edx
  00179	8b 45 24	 mov	 eax, DWORD PTR _cipher$[ebp]
  0017c	50		 push	 eax
  0017d	e8 00 00 00 00	 call	 _EncipherBlock@12

; 379  : 
; 380  : 		// Generate subsequent whitening values for blocks in this data unit. Note that all generated 128-bit
; 381  : 		// whitening values are stored in memory as a sequence of 64-bit integers in reverse order.
; 382  : 		for (block = 0; block < endBlock; block++)

  00182	c7 85 a4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _block$[ebp], 0
  0018c	eb 0f		 jmp	 SHORT $LN22@DecryptBuf@2
$LN21@DecryptBuf@2:
  0018e	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR _block$[ebp]
  00194	83 c1 01	 add	 ecx, 1
  00197	89 8d a4 fd ff
	ff		 mov	 DWORD PTR _block$[ebp], ecx
$LN22@DecryptBuf@2:
  0019d	8b 95 a4 fd ff
	ff		 mov	 edx, DWORD PTR _block$[ebp]
  001a3	3b 55 fc	 cmp	 edx, DWORD PTR _endBlock$[ebp]
  001a6	0f 83 75 01 00
	00		 jae	 $LN20@DecryptBuf@2

; 383  : 		{
; 384  : 			if (block >= startBlock)

  001ac	8b 85 a4 fd ff
	ff		 mov	 eax, DWORD PTR _block$[ebp]
  001b2	3b 85 a0 fd ff
	ff		 cmp	 eax, DWORD PTR _startBlock$[ebp]
  001b8	72 5b		 jb	 SHORT $LN19@DecryptBuf@2

; 385  : 			{
; 386  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64++;

  001ba	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuesPtr64$[ebp]
  001c0	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  001c6	8b 02		 mov	 eax, DWORD PTR [edx]
  001c8	89 01		 mov	 DWORD PTR [ecx], eax
  001ca	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001cd	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  001d0	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuesPtr64$[ebp]
  001d6	83 e8 08	 sub	 eax, 8
  001d9	89 85 d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], eax
  001df	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  001e5	83 c1 08	 add	 ecx, 8
  001e8	89 8d dc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr64$[ebp], ecx

; 387  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64;

  001ee	8b 95 d8 fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuesPtr64$[ebp]
  001f4	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  001fa	8b 08		 mov	 ecx, DWORD PTR [eax]
  001fc	89 0a		 mov	 DWORD PTR [edx], ecx
  001fe	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00201	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00204	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuesPtr64$[ebp]
  0020a	83 e9 08	 sub	 ecx, 8
  0020d	89 8d d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], ecx

; 388  : 			}
; 389  : 			else

  00213	eb 0f		 jmp	 SHORT $LN18@DecryptBuf@2
$LN19@DecryptBuf@2:

; 390  : 				whiteningValuePtr64++;

  00215	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  0021b	83 c2 08	 add	 edx, 8
  0021e	89 95 dc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr64$[ebp], edx
$LN18@DecryptBuf@2:

; 391  : 
; 392  : 			// Derive the next whitening value
; 393  : 
; 394  : #if BYTE_ORDER == LITTLE_ENDIAN
; 395  : 
; 396  : 			// Little-endian platforms
; 397  : 
; 398  : 			finalCarry = 
; 399  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 400  : 				135 : 0;

  00224	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  0022a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022c	83 e1 00	 and	 ecx, 0
  0022f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00232	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H
  00238	89 8d 80 fd ff
	ff		 mov	 DWORD PTR tv285[ebp], ecx
  0023e	89 95 84 fd ff
	ff		 mov	 DWORD PTR tv285[ebp+4], edx
  00244	8b 85 80 fd ff
	ff		 mov	 eax, DWORD PTR tv285[ebp]
  0024a	0b 85 84 fd ff
	ff		 or	 eax, DWORD PTR tv285[ebp+4]
  00250	74 0c		 je	 SHORT $LN30@DecryptBuf@2
  00252	c7 85 7c fd ff
	ff 87 00 00 00	 mov	 DWORD PTR tv92[ebp], 135 ; 00000087H
  0025c	eb 0a		 jmp	 SHORT $LN31@DecryptBuf@2
$LN30@DecryptBuf@2:
  0025e	c7 85 7c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv92[ebp], 0
$LN31@DecryptBuf@2:
  00268	8a 8d 7c fd ff
	ff		 mov	 cl, BYTE PTR tv92[ebp]
  0026e	88 8d b7 fd ff
	ff		 mov	 BYTE PTR _finalCarry$[ebp], cl

; 401  : 
; 402  : 			*whiteningValuePtr64-- <<= 1;

  00274	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  0027a	8b 02		 mov	 eax, DWORD PTR [edx]
  0027c	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0027f	b1 01		 mov	 cl, 1
  00281	e8 00 00 00 00	 call	 __allshl
  00286	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  0028c	89 01		 mov	 DWORD PTR [ecx], eax
  0028e	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00291	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  00297	83 ea 08	 sub	 edx, 8
  0029a	89 95 dc fd ff
	ff		 mov	 DWORD PTR _whiteningValuePtr64$[ebp], edx

; 403  : 
; 404  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  002a0	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  002a6	8b 08		 mov	 ecx, DWORD PTR [eax]
  002a8	83 e1 00	 and	 ecx, 0
  002ab	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  002ae	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H
  002b4	89 8d 74 fd ff
	ff		 mov	 DWORD PTR tv312[ebp], ecx
  002ba	89 95 78 fd ff
	ff		 mov	 DWORD PTR tv312[ebp+4], edx
  002c0	8b 85 74 fd ff
	ff		 mov	 eax, DWORD PTR tv312[ebp]
  002c6	0b 85 78 fd ff
	ff		 or	 eax, DWORD PTR tv312[ebp+4]
  002cc	74 1b		 je	 SHORT $LN17@DecryptBuf@2

; 405  : 				*(whiteningValuePtr64 + 1) |= 1;	

  002ce	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  002d4	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002d7	83 ca 01	 or	 edx, 1
  002da	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  002dd	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  002e3	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  002e6	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$LN17@DecryptBuf@2:

; 406  : 
; 407  : 			*whiteningValuePtr64 <<= 1;

  002e9	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  002ef	8b 02		 mov	 eax, DWORD PTR [edx]
  002f1	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  002f4	b1 01		 mov	 cl, 1
  002f6	e8 00 00 00 00	 call	 __allshl
  002fb	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  00301	89 01		 mov	 DWORD PTR [ecx], eax
  00303	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 408  : 
; 409  : #else
; 410  : 			// Big-endian platforms
; 411  : 
; 412  : 			finalCarry = 
; 413  : 				(*whiteningValuePtr64 & 0x80) ?
; 414  : 				135 : 0;
; 415  : 
; 416  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 417  : 
; 418  : 			whiteningValuePtr64--;
; 419  : 
; 420  : 			if (*whiteningValuePtr64 & 0x80)
; 421  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 422  : 
; 423  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 424  : #endif
; 425  : 
; 426  : 			whiteningValue[0] ^= finalCarry;

  00306	0f b6 95 b7 fd
	ff ff		 movzx	 edx, BYTE PTR _finalCarry$[ebp]
  0030d	0f b6 85 b8 fd
	ff ff		 movzx	 eax, BYTE PTR _whiteningValue$[ebp]
  00314	33 c2		 xor	 eax, edx
  00316	88 85 b8 fd ff
	ff		 mov	 BYTE PTR _whiteningValue$[ebp], al

; 427  : 		}

  0031c	e9 6d fe ff ff	 jmp	 $LN21@DecryptBuf@2
$LN20@DecryptBuf@2:

; 428  : 
; 429  : 		dataUnitBufPtr = bufPtr;

  00321	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  00327	89 8d e8 fd ff
	ff		 mov	 DWORD PTR _dataUnitBufPtr$[ebp], ecx

; 430  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  0032d	8b 55 f8	 mov	 edx, DWORD PTR _finalInt64WhiteningValuesPtr$[ebp]
  00330	89 95 d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], edx

; 431  : 
; 432  : 		// Decrypt blocks in this data unit
; 433  : 
; 434  : 		for (block = startBlock; block < endBlock; block++)

  00336	8b 85 a0 fd ff
	ff		 mov	 eax, DWORD PTR _startBlock$[ebp]
  0033c	89 85 a4 fd ff
	ff		 mov	 DWORD PTR _block$[ebp], eax
  00342	eb 0f		 jmp	 SHORT $LN16@DecryptBuf@2
$LN15@DecryptBuf@2:
  00344	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR _block$[ebp]
  0034a	83 c1 01	 add	 ecx, 1
  0034d	89 8d a4 fd ff
	ff		 mov	 DWORD PTR _block$[ebp], ecx
$LN16@DecryptBuf@2:
  00353	8b 95 a4 fd ff
	ff		 mov	 edx, DWORD PTR _block$[ebp]
  00359	3b 55 fc	 cmp	 edx, DWORD PTR _endBlock$[ebp]
  0035c	0f 83 83 00 00
	00		 jae	 $LN14@DecryptBuf@2

; 435  : 		{
; 436  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00362	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _bufPtr$[ebp]
  00368	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuesPtr64$[ebp]
  0036e	8b 10		 mov	 edx, DWORD PTR [eax]
  00370	33 11		 xor	 edx, DWORD PTR [ecx]
  00372	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00375	33 41 04	 xor	 eax, DWORD PTR [ecx+4]
  00378	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  0037e	89 11		 mov	 DWORD PTR [ecx], edx
  00380	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00383	8b 95 d8 fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuesPtr64$[ebp]
  00389	83 ea 08	 sub	 edx, 8
  0038c	89 95 d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], edx
  00392	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _bufPtr$[ebp]
  00398	83 c0 08	 add	 eax, 8
  0039b	89 85 ec fd ff
	ff		 mov	 DWORD PTR _bufPtr$[ebp], eax

; 437  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  003a1	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  003a7	8b 95 d8 fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuesPtr64$[ebp]
  003ad	8b 01		 mov	 eax, DWORD PTR [ecx]
  003af	33 02		 xor	 eax, DWORD PTR [edx]
  003b1	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  003b4	33 4a 04	 xor	 ecx, DWORD PTR [edx+4]
  003b7	8b 95 ec fd ff
	ff		 mov	 edx, DWORD PTR _bufPtr$[ebp]
  003bd	89 02		 mov	 DWORD PTR [edx], eax
  003bf	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  003c2	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuesPtr64$[ebp]
  003c8	83 e8 08	 sub	 eax, 8
  003cb	89 85 d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], eax
  003d1	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  003d7	83 c1 08	 add	 ecx, 8
  003da	89 8d ec fd ff
	ff		 mov	 DWORD PTR _bufPtr$[ebp], ecx

; 438  : 		}

  003e0	e9 5f ff ff ff	 jmp	 $LN15@DecryptBuf@2
$LN14@DecryptBuf@2:

; 439  : 
; 440  : 		DecipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);

  003e5	8b 55 fc	 mov	 edx, DWORD PTR _endBlock$[ebp]
  003e8	2b 95 a0 fd ff
	ff		 sub	 edx, DWORD PTR _startBlock$[ebp]
  003ee	52		 push	 edx
  003ef	8b 45 1c	 mov	 eax, DWORD PTR _ks$[ebp]
  003f2	50		 push	 eax
  003f3	8b 8d e8 fd ff
	ff		 mov	 ecx, DWORD PTR _dataUnitBufPtr$[ebp]
  003f9	51		 push	 ecx
  003fa	8b 55 24	 mov	 edx, DWORD PTR _cipher$[ebp]
  003fd	52		 push	 edx
  003fe	e8 00 00 00 00	 call	 _DecipherBlocks@16

; 441  : 
; 442  : 		bufPtr = dataUnitBufPtr;

  00403	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _dataUnitBufPtr$[ebp]
  00409	89 85 ec fd ff
	ff		 mov	 DWORD PTR _bufPtr$[ebp], eax

; 443  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  0040f	8b 4d f8	 mov	 ecx, DWORD PTR _finalInt64WhiteningValuesPtr$[ebp]
  00412	89 8d d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], ecx

; 444  : 
; 445  : 		for (block = startBlock; block < endBlock; block++)

  00418	8b 95 a0 fd ff
	ff		 mov	 edx, DWORD PTR _startBlock$[ebp]
  0041e	89 95 a4 fd ff
	ff		 mov	 DWORD PTR _block$[ebp], edx
  00424	eb 0f		 jmp	 SHORT $LN13@DecryptBuf@2
$LN12@DecryptBuf@2:
  00426	8b 85 a4 fd ff
	ff		 mov	 eax, DWORD PTR _block$[ebp]
  0042c	83 c0 01	 add	 eax, 1
  0042f	89 85 a4 fd ff
	ff		 mov	 DWORD PTR _block$[ebp], eax
$LN13@DecryptBuf@2:
  00435	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR _block$[ebp]
  0043b	3b 4d fc	 cmp	 ecx, DWORD PTR _endBlock$[ebp]
  0043e	0f 83 83 00 00
	00		 jae	 $LN11@DecryptBuf@2

; 446  : 		{
; 447  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00444	8b 95 ec fd ff
	ff		 mov	 edx, DWORD PTR _bufPtr$[ebp]
  0044a	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _whiteningValuesPtr64$[ebp]
  00450	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00452	33 08		 xor	 ecx, DWORD PTR [eax]
  00454	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00457	33 50 04	 xor	 edx, DWORD PTR [eax+4]
  0045a	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _bufPtr$[ebp]
  00460	89 08		 mov	 DWORD PTR [eax], ecx
  00462	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00465	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuesPtr64$[ebp]
  0046b	83 e9 08	 sub	 ecx, 8
  0046e	89 8d d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], ecx
  00474	8b 95 ec fd ff
	ff		 mov	 edx, DWORD PTR _bufPtr$[ebp]
  0047a	83 c2 08	 add	 edx, 8
  0047d	89 95 ec fd ff
	ff		 mov	 DWORD PTR _bufPtr$[ebp], edx

; 448  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00483	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _bufPtr$[ebp]
  00489	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _whiteningValuesPtr64$[ebp]
  0048f	8b 10		 mov	 edx, DWORD PTR [eax]
  00491	33 11		 xor	 edx, DWORD PTR [ecx]
  00493	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00496	33 41 04	 xor	 eax, DWORD PTR [ecx+4]
  00499	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  0049f	89 11		 mov	 DWORD PTR [ecx], edx
  004a1	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  004a4	8b 95 d8 fd ff
	ff		 mov	 edx, DWORD PTR _whiteningValuesPtr64$[ebp]
  004aa	83 ea 08	 sub	 edx, 8
  004ad	89 95 d8 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], edx
  004b3	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _bufPtr$[ebp]
  004b9	83 c0 08	 add	 eax, 8
  004bc	89 85 ec fd ff
	ff		 mov	 DWORD PTR _bufPtr$[ebp], eax

; 449  : 		}

  004c2	e9 5f ff ff ff	 jmp	 $LN12@DecryptBuf@2
$LN11@DecryptBuf@2:

; 450  : 
; 451  : 		blockCount -= endBlock - startBlock;

  004c7	8b 4d fc	 mov	 ecx, DWORD PTR _endBlock$[ebp]
  004ca	2b 8d a0 fd ff
	ff		 sub	 ecx, DWORD PTR _startBlock$[ebp]
  004d0	33 d2		 xor	 edx, edx
  004d2	8b 85 e0 fd ff
	ff		 mov	 eax, DWORD PTR _blockCount$[ebp]
  004d8	2b c1		 sub	 eax, ecx
  004da	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR _blockCount$[ebp+4]
  004e0	1b ca		 sbb	 ecx, edx
  004e2	89 85 e0 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp], eax
  004e8	89 8d e4 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp+4], ecx

; 452  : 		startBlock = 0;

  004ee	c7 85 a0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _startBlock$[ebp], 0

; 453  : 		dataUnitNo++;

  004f8	8b 95 a8 fd ff
	ff		 mov	 edx, DWORD PTR _dataUnitNo$[ebp]
  004fe	83 c2 01	 add	 edx, 1
  00501	8b 85 ac fd ff
	ff		 mov	 eax, DWORD PTR _dataUnitNo$[ebp+4]
  00507	83 d0 00	 adc	 eax, 0
  0050a	89 95 a8 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp], edx
  00510	89 85 ac fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp+4], eax

; 454  : 
; 455  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  00516	8b 8d a8 fd ff
	ff		 mov	 ecx, DWORD PTR _dataUnitNo$[ebp]
  0051c	89 8d c8 fd ff
	ff		 mov	 DWORD PTR _byteBufUnitNo$[ebp], ecx
  00522	8b 95 ac fd ff
	ff		 mov	 edx, DWORD PTR _dataUnitNo$[ebp+4]
  00528	89 95 cc fd ff
	ff		 mov	 DWORD PTR _byteBufUnitNo$[ebp+4], edx

; 456  : 	}

  0052e	e9 b9 fb ff ff	 jmp	 $LN26@DecryptBuf@2
$LN10@DecryptBuf@2:

; 457  : 
; 458  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  00533	8d 85 b8 fd ff
	ff		 lea	 eax, DWORD PTR _whiteningValue$[ebp]
  00539	89 85 98 fd ff
	ff		 mov	 DWORD PTR _burnm$27095[ebp], eax
  0053f	c7 85 9c fd ff
	ff 02 00 00 00	 mov	 DWORD PTR _burnc$27097[ebp], 2
$LN7@DecryptBuf@2:
  00549	8b 8d 9c fd ff
	ff		 mov	 ecx, DWORD PTR _burnc$27097[ebp]
  0054f	8b 95 9c fd ff
	ff		 mov	 edx, DWORD PTR _burnc$27097[ebp]
  00555	83 ea 01	 sub	 edx, 1
  00558	89 95 9c fd ff
	ff		 mov	 DWORD PTR _burnc$27097[ebp], edx
  0055e	85 c9		 test	 ecx, ecx
  00560	74 24		 je	 SHORT $LN9@DecryptBuf@2
  00562	8b 85 98 fd ff
	ff		 mov	 eax, DWORD PTR _burnm$27095[ebp]
  00568	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0056e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00575	8b 8d 98 fd ff
	ff		 mov	 ecx, DWORD PTR _burnm$27095[ebp]
  0057b	83 c1 08	 add	 ecx, 8
  0057e	89 8d 98 fd ff
	ff		 mov	 DWORD PTR _burnm$27095[ebp], ecx
  00584	eb c3		 jmp	 SHORT $LN7@DecryptBuf@2
$LN9@DecryptBuf@2:
  00586	33 d2		 xor	 edx, edx
  00588	75 a9		 jne	 SHORT $LN10@DecryptBuf@2
$LN5@DecryptBuf@2:

; 459  : 	FAST_ERASE64 (whiteningValues, sizeof (whiteningValues));

  0058a	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _whiteningValues$[ebp]
  00590	89 85 90 fd ff
	ff		 mov	 DWORD PTR _burnm$27104[ebp], eax
  00596	c7 85 94 fd ff
	ff 40 00 00 00	 mov	 DWORD PTR _burnc$27106[ebp], 64 ; 00000040H
$LN2@DecryptBuf@2:
  005a0	8b 8d 94 fd ff
	ff		 mov	 ecx, DWORD PTR _burnc$27106[ebp]
  005a6	8b 95 94 fd ff
	ff		 mov	 edx, DWORD PTR _burnc$27106[ebp]
  005ac	83 ea 01	 sub	 edx, 1
  005af	89 95 94 fd ff
	ff		 mov	 DWORD PTR _burnc$27106[ebp], edx
  005b5	85 c9		 test	 ecx, ecx
  005b7	74 24		 je	 SHORT $LN4@DecryptBuf@2
  005b9	8b 85 90 fd ff
	ff		 mov	 eax, DWORD PTR _burnm$27104[ebp]
  005bf	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  005c5	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  005cc	8b 8d 90 fd ff
	ff		 mov	 ecx, DWORD PTR _burnm$27104[ebp]
  005d2	83 c1 08	 add	 ecx, 8
  005d5	89 8d 90 fd ff
	ff		 mov	 DWORD PTR _burnm$27104[ebp], ecx
  005db	eb c3		 jmp	 SHORT $LN2@DecryptBuf@2
$LN4@DecryptBuf@2:
  005dd	33 d2		 xor	 edx, edx
  005df	75 a9		 jne	 SHORT $LN5@DecryptBuf@2
$LN29@DecryptBuf@2:

; 460  : }

  005e1	8b 4d f4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005e4	33 cd		 xor	 ecx, ebp
  005e6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005eb	8b e5		 mov	 esp, ebp
  005ed	5d		 pop	 ebp
  005ee	c2 20 00	 ret	 32			; 00000020H
_DecryptBufferXTSParallel@32 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_DecipherBlock@12:PROC
; Function compile flags: /Odtp
;	COMDAT _DecryptBufferXTSNonParallel@32
_TEXT	SEGMENT
tv328 = -116						; size = 8
tv133 = -108						; size = 4
tv301 = -104						; size = 8
tv177 = -96						; size = 8
_burnm$27159 = -88					; size = 4
_burnc$27161 = -84					; size = 4
_startBlock$ = -80					; size = 4
_block$ = -76						; size = 4
_dataUnitNo$ = -72					; size = 8
_finalCarry$ = -57					; size = 1
_whiteningValue$ = -56					; size = 16
_byteBufUnitNo$ = -40					; size = 16
__$ArrayPad$ = -24					; size = 4
_whiteningValuePtr64$ = -20				; size = 4
_blockCount$ = -16					; size = 8
_bufPtr$ = -8						; size = 4
_endBlock$ = -4						; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_ks$ = 28						; size = 4
_ks2$ = 32						; size = 4
_cipher$ = 36						; size = 4
_DecryptBufferXTSNonParallel@32 PROC			; COMDAT

; 471  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 74	 sub	 esp, 116		; 00000074H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 e8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 472  : 	unsigned __int8 finalCarry;
; 473  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 474  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 475  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  00012	8d 45 c8	 lea	 eax, DWORD PTR _whiteningValue$[ebp]
  00015	89 45 ec	 mov	 DWORD PTR _whiteningValuePtr64$[ebp], eax

; 476  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;

  00018	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0001b	89 4d f8	 mov	 DWORD PTR _bufPtr$[ebp], ecx

; 477  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;

  0001e	8b 55 18	 mov	 edx, DWORD PTR _startCipherBlockNo$[ebp]
  00021	89 55 b0	 mov	 DWORD PTR _startBlock$[ebp], edx

; 478  : 	TC_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 479  : 
; 480  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 481  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 482  : 	dataUnitNo = startDataUnitNo->Value;

  00024	8b 45 14	 mov	 eax, DWORD PTR _startDataUnitNo$[ebp]
  00027	8b 08		 mov	 ecx, DWORD PTR [eax]
  00029	89 4d b8	 mov	 DWORD PTR _dataUnitNo$[ebp], ecx
  0002c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0002f	89 55 bc	 mov	 DWORD PTR _dataUnitNo$[ebp+4], edx

; 483  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  00032	8b 45 b8	 mov	 eax, DWORD PTR _dataUnitNo$[ebp]
  00035	89 45 d8	 mov	 DWORD PTR _byteBufUnitNo$[ebp], eax
  00038	8b 4d bc	 mov	 ecx, DWORD PTR _dataUnitNo$[ebp+4]
  0003b	89 4d dc	 mov	 DWORD PTR _byteBufUnitNo$[ebp+4], ecx

; 484  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;

  0003e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _byteBufUnitNo$[ebp+8], 0
  00045	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _byteBufUnitNo$[ebp+12], 0

; 485  : 
; 486  : 	if (length % BYTES_PER_XTS_BLOCK)

  0004c	6a 00		 push	 0
  0004e	6a 10		 push	 16			; 00000010H
  00050	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp+4]
  00053	52		 push	 edx
  00054	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 __aullrem
  0005d	89 45 a0	 mov	 DWORD PTR tv177[ebp], eax
  00060	89 55 a4	 mov	 DWORD PTR tv177[ebp+4], edx
  00063	8b 4d a0	 mov	 ecx, DWORD PTR tv177[ebp]
  00066	0b 4d a4	 or	 ecx, DWORD PTR tv177[ebp+4]
  00069	74 16		 je	 SHORT $LN16@DecryptBuf@3

; 487  : 		TC_THROW_FATAL_EXCEPTION;

  0006b	68 43 54 00 00	 push	 21571			; 00005443H
  00070	6a 00		 push	 0
  00072	6a 00		 push	 0
  00074	68 e7 01 00 00	 push	 487			; 000001e7H
  00079	6a 29		 push	 41			; 00000029H
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN16@DecryptBuf@3:

; 488  : 
; 489  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  00081	6a 00		 push	 0
  00083	6a 10		 push	 16			; 00000010H
  00085	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp+4]
  00088	52		 push	 edx
  00089	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 __aulldiv
  00092	89 45 f0	 mov	 DWORD PTR _blockCount$[ebp], eax
  00095	89 55 f4	 mov	 DWORD PTR _blockCount$[ebp+4], edx
$LN15@DecryptBuf@3:

; 490  : 
; 491  : 	// Process all blocks in the buffer
; 492  : 	while (blockCount > 0)

  00098	83 7d f4 00	 cmp	 DWORD PTR _blockCount$[ebp+4], 0
  0009c	77 0a		 ja	 SHORT $LN21@DecryptBuf@3
  0009e	83 7d f0 00	 cmp	 DWORD PTR _blockCount$[ebp], 0
  000a2	0f 86 2f 02 00
	00		 jbe	 $LN5@DecryptBuf@3
$LN21@DecryptBuf@3:

; 493  : 	{
; 494  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  000a8	83 7d f4 00	 cmp	 DWORD PTR _blockCount$[ebp+4], 0
  000ac	77 13		 ja	 SHORT $LN13@DecryptBuf@3
  000ae	72 06		 jb	 SHORT $LN22@DecryptBuf@3
  000b0	83 7d f0 20	 cmp	 DWORD PTR _blockCount$[ebp], 32 ; 00000020H
  000b4	73 0b		 jae	 SHORT $LN13@DecryptBuf@3
$LN22@DecryptBuf@3:

; 495  : 			endBlock = startBlock + (unsigned int) blockCount;

  000b6	8b 4d f0	 mov	 ecx, DWORD PTR _blockCount$[ebp]
  000b9	03 4d b0	 add	 ecx, DWORD PTR _startBlock$[ebp]
  000bc	89 4d fc	 mov	 DWORD PTR _endBlock$[ebp], ecx

; 496  : 		else

  000bf	eb 07		 jmp	 SHORT $LN12@DecryptBuf@3
$LN13@DecryptBuf@3:

; 497  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  000c1	c7 45 fc 20 00
	00 00		 mov	 DWORD PTR _endBlock$[ebp], 32 ; 00000020H
$LN12@DecryptBuf@3:

; 498  : 
; 499  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  000c8	8d 55 c8	 lea	 edx, DWORD PTR _whiteningValue$[ebp]
  000cb	89 55 ec	 mov	 DWORD PTR _whiteningValuePtr64$[ebp], edx

; 500  : 
; 501  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 502  : 		// whitening value for this data unit)
; 503  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  000ce	8b 45 ec	 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  000d1	8b 4d d8	 mov	 ecx, DWORD PTR _byteBufUnitNo$[ebp]
  000d4	89 08		 mov	 DWORD PTR [eax], ecx
  000d6	8b 55 dc	 mov	 edx, DWORD PTR _byteBufUnitNo$[ebp+4]
  000d9	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 504  : 		*(whiteningValuePtr64 + 1) = 0;

  000dc	8b 45 ec	 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  000df	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  000e6	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 505  : 		EncipherBlock (cipher, whiteningValue, ks2);

  000ed	8b 4d 20	 mov	 ecx, DWORD PTR _ks2$[ebp]
  000f0	51		 push	 ecx
  000f1	8d 55 c8	 lea	 edx, DWORD PTR _whiteningValue$[ebp]
  000f4	52		 push	 edx
  000f5	8b 45 24	 mov	 eax, DWORD PTR _cipher$[ebp]
  000f8	50		 push	 eax
  000f9	e8 00 00 00 00	 call	 _EncipherBlock@12

; 506  : 
; 507  : 		// Generate (and apply) subsequent whitening values for blocks in this data unit and
; 508  : 		// decrypt all relevant blocks in this data unit
; 509  : 		for (block = 0; block < endBlock; block++)

  000fe	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _block$[ebp], 0
  00105	eb 09		 jmp	 SHORT $LN11@DecryptBuf@3
$LN10@DecryptBuf@3:
  00107	8b 4d b4	 mov	 ecx, DWORD PTR _block$[ebp]
  0010a	83 c1 01	 add	 ecx, 1
  0010d	89 4d b4	 mov	 DWORD PTR _block$[ebp], ecx
$LN11@DecryptBuf@3:
  00110	8b 55 b4	 mov	 edx, DWORD PTR _block$[ebp]
  00113	3b 55 fc	 cmp	 edx, DWORD PTR _endBlock$[ebp]
  00116	0f 83 79 01 00
	00		 jae	 $LN9@DecryptBuf@3

; 510  : 		{
; 511  : 			if (block >= startBlock)

  0011c	8b 45 b4	 mov	 eax, DWORD PTR _block$[ebp]
  0011f	3b 45 b0	 cmp	 eax, DWORD PTR _startBlock$[ebp]
  00122	0f 82 b2 00 00
	00		 jb	 $LN8@DecryptBuf@3

; 512  : 			{
; 513  : 				// Post-whitening
; 514  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  00128	8b 4d f8	 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  0012b	8b 55 ec	 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  0012e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00130	33 02		 xor	 eax, DWORD PTR [edx]
  00132	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00135	33 4a 04	 xor	 ecx, DWORD PTR [edx+4]
  00138	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  0013b	89 02		 mov	 DWORD PTR [edx], eax
  0013d	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00140	8b 45 ec	 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  00143	83 c0 08	 add	 eax, 8
  00146	89 45 ec	 mov	 DWORD PTR _whiteningValuePtr64$[ebp], eax
  00149	8b 4d f8	 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  0014c	83 c1 08	 add	 ecx, 8
  0014f	89 4d f8	 mov	 DWORD PTR _bufPtr$[ebp], ecx

; 515  : 				*bufPtr-- ^= *whiteningValuePtr64--;

  00152	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  00155	8b 45 ec	 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  00158	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0015a	33 08		 xor	 ecx, DWORD PTR [eax]
  0015c	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0015f	33 50 04	 xor	 edx, DWORD PTR [eax+4]
  00162	8b 45 f8	 mov	 eax, DWORD PTR _bufPtr$[ebp]
  00165	89 08		 mov	 DWORD PTR [eax], ecx
  00167	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0016a	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  0016d	83 e9 08	 sub	 ecx, 8
  00170	89 4d ec	 mov	 DWORD PTR _whiteningValuePtr64$[ebp], ecx
  00173	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  00176	83 ea 08	 sub	 edx, 8
  00179	89 55 f8	 mov	 DWORD PTR _bufPtr$[ebp], edx

; 516  : 
; 517  : 				// Actual decryption
; 518  : 				DecipherBlock (cipher, bufPtr, ks);

  0017c	8b 45 1c	 mov	 eax, DWORD PTR _ks$[ebp]
  0017f	50		 push	 eax
  00180	8b 4d f8	 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  00183	51		 push	 ecx
  00184	8b 55 24	 mov	 edx, DWORD PTR _cipher$[ebp]
  00187	52		 push	 edx
  00188	e8 00 00 00 00	 call	 _DecipherBlock@12

; 519  : 
; 520  : 				// Pre-whitening
; 521  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  0018d	8b 45 f8	 mov	 eax, DWORD PTR _bufPtr$[ebp]
  00190	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  00193	8b 10		 mov	 edx, DWORD PTR [eax]
  00195	33 11		 xor	 edx, DWORD PTR [ecx]
  00197	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019a	33 41 04	 xor	 eax, DWORD PTR [ecx+4]
  0019d	8b 4d f8	 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  001a0	89 11		 mov	 DWORD PTR [ecx], edx
  001a2	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  001a5	8b 55 ec	 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  001a8	83 c2 08	 add	 edx, 8
  001ab	89 55 ec	 mov	 DWORD PTR _whiteningValuePtr64$[ebp], edx
  001ae	8b 45 f8	 mov	 eax, DWORD PTR _bufPtr$[ebp]
  001b1	83 c0 08	 add	 eax, 8
  001b4	89 45 f8	 mov	 DWORD PTR _bufPtr$[ebp], eax

; 522  : 				*bufPtr++ ^= *whiteningValuePtr64;

  001b7	8b 4d f8	 mov	 ecx, DWORD PTR _bufPtr$[ebp]
  001ba	8b 55 ec	 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  001bd	8b 01		 mov	 eax, DWORD PTR [ecx]
  001bf	33 02		 xor	 eax, DWORD PTR [edx]
  001c1	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  001c4	33 4a 04	 xor	 ecx, DWORD PTR [edx+4]
  001c7	8b 55 f8	 mov	 edx, DWORD PTR _bufPtr$[ebp]
  001ca	89 02		 mov	 DWORD PTR [edx], eax
  001cc	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  001cf	8b 45 f8	 mov	 eax, DWORD PTR _bufPtr$[ebp]
  001d2	83 c0 08	 add	 eax, 8
  001d5	89 45 f8	 mov	 DWORD PTR _bufPtr$[ebp], eax

; 523  : 			}
; 524  : 			else

  001d8	eb 09		 jmp	 SHORT $LN7@DecryptBuf@3
$LN8@DecryptBuf@3:

; 525  : 				whiteningValuePtr64++;

  001da	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  001dd	83 c1 08	 add	 ecx, 8
  001e0	89 4d ec	 mov	 DWORD PTR _whiteningValuePtr64$[ebp], ecx
$LN7@DecryptBuf@3:

; 526  : 
; 527  : 			// Derive the next whitening value
; 528  : 
; 529  : #if BYTE_ORDER == LITTLE_ENDIAN
; 530  : 
; 531  : 			// Little-endian platforms
; 532  : 
; 533  : 			finalCarry = 
; 534  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 535  : 				135 : 0;

  001e3	8b 55 ec	 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  001e6	8b 02		 mov	 eax, DWORD PTR [edx]
  001e8	83 e0 00	 and	 eax, 0
  001eb	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001ee	81 e1 00 00 00
	80		 and	 ecx, -2147483648	; 80000000H
  001f4	89 45 98	 mov	 DWORD PTR tv301[ebp], eax
  001f7	89 4d 9c	 mov	 DWORD PTR tv301[ebp+4], ecx
  001fa	8b 55 98	 mov	 edx, DWORD PTR tv301[ebp]
  001fd	0b 55 9c	 or	 edx, DWORD PTR tv301[ebp+4]
  00200	74 09		 je	 SHORT $LN19@DecryptBuf@3
  00202	c7 45 94 87 00
	00 00		 mov	 DWORD PTR tv133[ebp], 135 ; 00000087H
  00209	eb 07		 jmp	 SHORT $LN20@DecryptBuf@3
$LN19@DecryptBuf@3:
  0020b	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv133[ebp], 0
$LN20@DecryptBuf@3:
  00212	8a 45 94	 mov	 al, BYTE PTR tv133[ebp]
  00215	88 45 c7	 mov	 BYTE PTR _finalCarry$[ebp], al

; 536  : 
; 537  : 			*whiteningValuePtr64-- <<= 1;

  00218	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  0021b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0021d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00220	b1 01		 mov	 cl, 1
  00222	e8 00 00 00 00	 call	 __allshl
  00227	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  0022a	89 01		 mov	 DWORD PTR [ecx], eax
  0022c	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0022f	8b 55 ec	 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  00232	83 ea 08	 sub	 edx, 8
  00235	89 55 ec	 mov	 DWORD PTR _whiteningValuePtr64$[ebp], edx

; 538  : 
; 539  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  00238	8b 45 ec	 mov	 eax, DWORD PTR _whiteningValuePtr64$[ebp]
  0023b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0023d	83 e1 00	 and	 ecx, 0
  00240	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00243	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H
  00249	89 4d 8c	 mov	 DWORD PTR tv328[ebp], ecx
  0024c	89 55 90	 mov	 DWORD PTR tv328[ebp+4], edx
  0024f	8b 45 8c	 mov	 eax, DWORD PTR tv328[ebp]
  00252	0b 45 90	 or	 eax, DWORD PTR tv328[ebp+4]
  00255	74 15		 je	 SHORT $LN6@DecryptBuf@3

; 540  : 				*(whiteningValuePtr64 + 1) |= 1;	

  00257	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  0025a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0025d	83 ca 01	 or	 edx, 1
  00260	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00263	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  00266	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00269	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$LN6@DecryptBuf@3:

; 541  : 
; 542  : 			*whiteningValuePtr64 <<= 1;

  0026c	8b 55 ec	 mov	 edx, DWORD PTR _whiteningValuePtr64$[ebp]
  0026f	8b 02		 mov	 eax, DWORD PTR [edx]
  00271	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00274	b1 01		 mov	 cl, 1
  00276	e8 00 00 00 00	 call	 __allshl
  0027b	8b 4d ec	 mov	 ecx, DWORD PTR _whiteningValuePtr64$[ebp]
  0027e	89 01		 mov	 DWORD PTR [ecx], eax
  00280	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 543  : 
; 544  : #else
; 545  : 			// Big-endian platforms
; 546  : 
; 547  : 			finalCarry = 
; 548  : 				(*whiteningValuePtr64 & 0x80) ?
; 549  : 				135 : 0;
; 550  : 
; 551  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 552  : 
; 553  : 			whiteningValuePtr64--;
; 554  : 
; 555  : 			if (*whiteningValuePtr64 & 0x80)
; 556  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 557  : 
; 558  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 559  : #endif
; 560  : 
; 561  : 			whiteningValue[0] ^= finalCarry;

  00283	0f b6 55 c7	 movzx	 edx, BYTE PTR _finalCarry$[ebp]
  00287	0f b6 45 c8	 movzx	 eax, BYTE PTR _whiteningValue$[ebp]
  0028b	33 c2		 xor	 eax, edx
  0028d	88 45 c8	 mov	 BYTE PTR _whiteningValue$[ebp], al

; 562  : 		}

  00290	e9 72 fe ff ff	 jmp	 $LN10@DecryptBuf@3
$LN9@DecryptBuf@3:

; 563  : 
; 564  : 		blockCount -= endBlock - startBlock;

  00295	8b 4d fc	 mov	 ecx, DWORD PTR _endBlock$[ebp]
  00298	2b 4d b0	 sub	 ecx, DWORD PTR _startBlock$[ebp]
  0029b	33 d2		 xor	 edx, edx
  0029d	8b 45 f0	 mov	 eax, DWORD PTR _blockCount$[ebp]
  002a0	2b c1		 sub	 eax, ecx
  002a2	8b 4d f4	 mov	 ecx, DWORD PTR _blockCount$[ebp+4]
  002a5	1b ca		 sbb	 ecx, edx
  002a7	89 45 f0	 mov	 DWORD PTR _blockCount$[ebp], eax
  002aa	89 4d f4	 mov	 DWORD PTR _blockCount$[ebp+4], ecx

; 565  : 		startBlock = 0;

  002ad	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _startBlock$[ebp], 0

; 566  : 		dataUnitNo++;

  002b4	8b 55 b8	 mov	 edx, DWORD PTR _dataUnitNo$[ebp]
  002b7	83 c2 01	 add	 edx, 1
  002ba	8b 45 bc	 mov	 eax, DWORD PTR _dataUnitNo$[ebp+4]
  002bd	83 d0 00	 adc	 eax, 0
  002c0	89 55 b8	 mov	 DWORD PTR _dataUnitNo$[ebp], edx
  002c3	89 45 bc	 mov	 DWORD PTR _dataUnitNo$[ebp+4], eax

; 567  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  002c6	8b 4d b8	 mov	 ecx, DWORD PTR _dataUnitNo$[ebp]
  002c9	89 4d d8	 mov	 DWORD PTR _byteBufUnitNo$[ebp], ecx
  002cc	8b 55 bc	 mov	 edx, DWORD PTR _dataUnitNo$[ebp+4]
  002cf	89 55 dc	 mov	 DWORD PTR _byteBufUnitNo$[ebp+4], edx

; 568  : 	}

  002d2	e9 c1 fd ff ff	 jmp	 $LN15@DecryptBuf@3
$LN5@DecryptBuf@3:

; 569  : 
; 570  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  002d7	8d 45 c8	 lea	 eax, DWORD PTR _whiteningValue$[ebp]
  002da	89 45 a8	 mov	 DWORD PTR _burnm$27159[ebp], eax
  002dd	c7 45 ac 02 00
	00 00		 mov	 DWORD PTR _burnc$27161[ebp], 2
$LN2@DecryptBuf@3:
  002e4	8b 4d ac	 mov	 ecx, DWORD PTR _burnc$27161[ebp]
  002e7	8b 55 ac	 mov	 edx, DWORD PTR _burnc$27161[ebp]
  002ea	83 ea 01	 sub	 edx, 1
  002ed	89 55 ac	 mov	 DWORD PTR _burnc$27161[ebp], edx
  002f0	85 c9		 test	 ecx, ecx
  002f2	74 1b		 je	 SHORT $LN4@DecryptBuf@3
  002f4	8b 45 a8	 mov	 eax, DWORD PTR _burnm$27159[ebp]
  002f7	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  002fd	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00304	8b 4d a8	 mov	 ecx, DWORD PTR _burnm$27159[ebp]
  00307	83 c1 08	 add	 ecx, 8
  0030a	89 4d a8	 mov	 DWORD PTR _burnm$27159[ebp], ecx
  0030d	eb d5		 jmp	 SHORT $LN2@DecryptBuf@3
$LN4@DecryptBuf@3:
  0030f	33 d2		 xor	 edx, edx
  00311	75 c4		 jne	 SHORT $LN5@DecryptBuf@3
$LN18@DecryptBuf@3:

; 571  : }

  00313	8b 4d e8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00316	33 cd		 xor	 ecx, ebp
  00318	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0031d	8b e5		 mov	 esp, ebp
  0031f	5d		 pop	 ebp
  00320	c2 20 00	 ret	 32			; 00000020H
_DecryptBufferXTSNonParallel@32 ENDP
_TEXT	ENDS
END
