; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	__$ArrayPad$
;	COMDAT pdata
; File c:\home\public\desktop\projects\ciphershed.build\src\common\xts.c
pdata	SEGMENT
$pdata$DecryptBufferXTSNonParallel DD imagerel DecryptBufferXTSNonParallel
	DD	imagerel DecryptBufferXTSNonParallel+1001
	DD	imagerel $unwind$DecryptBufferXTSNonParallel
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecryptBufferXTSNonParallel DD 022d19H
	DD	017011bH
	DD	imagerel __GSHandlerCheck
	DD	0a8H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DecryptBufferXTSNonParallel
_TEXT	SEGMENT
endBlock$ = 48
bufPtr$ = 56
blockCount$ = 64
whiteningValuePtr64$ = 72
byteBufUnitNo$ = 88
whiteningValue$ = 104
finalCarry$ = 120
dataUnitNo$ = 128
block$ = 136
startBlock$ = 140
burnc$28812 = 144
burnm$28810 = 152
tv132 = 160
__$ArrayPad$ = 168
buffer$ = 192
length$ = 200
startDataUnitNo$ = 208
startCipherBlockNo$ = 216
ks$ = 224
ks2$ = 232
cipher$ = 240
DecryptBufferXTSNonParallel PROC			; COMDAT

; 471  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 472  : 	unsigned __int8 finalCarry;
; 473  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 474  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 475  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  0002d	48 8d 44 24 68	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  00032	48 89 44 24 48	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax

; 476  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;

  00037	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR buffer$[rsp]
  0003f	48 89 44 24 38	 mov	 QWORD PTR bufPtr$[rsp], rax

; 477  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;

  00044	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR startCipherBlockNo$[rsp]
  0004b	89 84 24 8c 00
	00 00		 mov	 DWORD PTR startBlock$[rsp], eax

; 478  : 	TC_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 479  : 
; 480  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 481  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 482  : 	dataUnitNo = startDataUnitNo->Value;

  00052	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR startDataUnitNo$[rsp]
  0005a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR dataUnitNo$[rsp], rax

; 483  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  00065	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dataUnitNo$[rsp]
  0006d	48 89 44 24 58	 mov	 QWORD PTR byteBufUnitNo$[rsp], rax

; 484  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;

  00072	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR byteBufUnitNo$[rsp+8], 0

; 485  : 
; 486  : 	if (length % BYTES_PER_XTS_BLOCK)

  0007b	33 d2		 xor	 edx, edx
  0007d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR length$[rsp]
  00085	b9 10 00 00 00	 mov	 ecx, 16
  0008a	48 f7 f1	 div	 rcx
  0008d	48 85 d2	 test	 rdx, rdx
  00090	74 1f		 je	 SHORT $LN16@DecryptBuf

; 487  : 		TC_THROW_FATAL_EXCEPTION;

  00092	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  0009b	45 33 c9	 xor	 r9d, r9d
  0009e	45 33 c0	 xor	 r8d, r8d
  000a1	ba e7 01 00 00	 mov	 edx, 487		; 000001e7H
  000a6	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN16@DecryptBuf:

; 488  : 
; 489  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  000b1	33 d2		 xor	 edx, edx
  000b3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR length$[rsp]
  000bb	b9 10 00 00 00	 mov	 ecx, 16
  000c0	48 f7 f1	 div	 rcx
  000c3	48 89 44 24 40	 mov	 QWORD PTR blockCount$[rsp], rax
$LN15@DecryptBuf:

; 490  : 
; 491  : 	// Process all blocks in the buffer
; 492  : 	while (blockCount > 0)

  000c8	48 83 7c 24 40
	00		 cmp	 QWORD PTR blockCount$[rsp], 0
  000ce	0f 86 9e 02 00
	00		 jbe	 $LN14@DecryptBuf

; 493  : 	{
; 494  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  000d4	48 83 7c 24 40
	20		 cmp	 QWORD PTR blockCount$[rsp], 32 ; 00000020H
  000da	73 13		 jae	 SHORT $LN13@DecryptBuf

; 495  : 			endBlock = startBlock + (unsigned int) blockCount;

  000dc	8b 4c 24 40	 mov	 ecx, DWORD PTR blockCount$[rsp]
  000e0	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR startBlock$[rsp]
  000e7	03 c1		 add	 eax, ecx
  000e9	89 44 24 30	 mov	 DWORD PTR endBlock$[rsp], eax

; 496  : 		else

  000ed	eb 08		 jmp	 SHORT $LN12@DecryptBuf
$LN13@DecryptBuf:

; 497  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  000ef	c7 44 24 30 20
	00 00 00	 mov	 DWORD PTR endBlock$[rsp], 32 ; 00000020H
$LN12@DecryptBuf:

; 498  : 
; 499  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  000f7	48 8d 44 24 68	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  000fc	48 89 44 24 48	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax

; 500  : 
; 501  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 502  : 		// whitening value for this data unit)
; 503  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  00101	48 8b 4c 24 48	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  00106	48 8b 44 24 58	 mov	 rax, QWORD PTR byteBufUnitNo$[rsp]
  0010b	48 89 01	 mov	 QWORD PTR [rcx], rax

; 504  : 		*(whiteningValuePtr64 + 1) = 0;

  0010e	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  00113	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 505  : 		EncipherBlock (cipher, whiteningValue, ks2);

  0011b	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR ks2$[rsp]
  00123	48 8d 54 24 68	 lea	 rdx, QWORD PTR whiteningValue$[rsp]
  00128	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  0012f	e8 00 00 00 00	 call	 EncipherBlock

; 506  : 
; 507  : 		// Generate (and apply) subsequent whitening values for blocks in this data unit and
; 508  : 		// decrypt all relevant blocks in this data unit
; 509  : 		for (block = 0; block < endBlock; block++)

  00134	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR block$[rsp], 0
  0013f	eb 11		 jmp	 SHORT $LN11@DecryptBuf
$LN10@DecryptBuf:
  00141	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR block$[rsp]
  00148	83 c0 01	 add	 eax, 1
  0014b	89 84 24 88 00
	00 00		 mov	 DWORD PTR block$[rsp], eax
$LN11@DecryptBuf:
  00152	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  00156	39 84 24 88 00
	00 00		 cmp	 DWORD PTR block$[rsp], eax
  0015d	0f 83 c2 01 00
	00		 jae	 $LN9@DecryptBuf

; 510  : 		{
; 511  : 			if (block >= startBlock)

  00163	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR startBlock$[rsp]
  0016a	39 84 24 88 00
	00 00		 cmp	 DWORD PTR block$[rsp], eax
  00171	0f 82 e9 00 00
	00		 jb	 $LN8@DecryptBuf

; 512  : 			{
; 513  : 				// Post-whitening
; 514  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  00177	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  0017c	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  00181	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00184	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00187	48 33 c8	 xor	 rcx, rax
  0018a	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  0018f	48 89 08	 mov	 QWORD PTR [rax], rcx
  00192	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  00197	48 83 c0 08	 add	 rax, 8
  0019b	48 89 44 24 48	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax
  001a0	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  001a5	48 83 c0 08	 add	 rax, 8
  001a9	48 89 44 24 38	 mov	 QWORD PTR bufPtr$[rsp], rax

; 515  : 				*bufPtr-- ^= *whiteningValuePtr64--;

  001ae	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  001b3	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  001b8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001bb	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001be	48 33 c8	 xor	 rcx, rax
  001c1	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  001c6	48 89 08	 mov	 QWORD PTR [rax], rcx
  001c9	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  001ce	48 83 e8 08	 sub	 rax, 8
  001d2	48 89 44 24 48	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax
  001d7	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  001dc	48 83 e8 08	 sub	 rax, 8
  001e0	48 89 44 24 38	 mov	 QWORD PTR bufPtr$[rsp], rax

; 516  : 
; 517  : 				// Actual decryption
; 518  : 				DecipherBlock (cipher, bufPtr, ks);

  001e5	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR ks$[rsp]
  001ed	48 8b 54 24 38	 mov	 rdx, QWORD PTR bufPtr$[rsp]
  001f2	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  001f9	e8 00 00 00 00	 call	 DecipherBlock

; 519  : 
; 520  : 				// Pre-whitening
; 521  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  001fe	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  00203	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  00208	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0020b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0020e	48 33 c8	 xor	 rcx, rax
  00211	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  00216	48 89 08	 mov	 QWORD PTR [rax], rcx
  00219	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  0021e	48 83 c0 08	 add	 rax, 8
  00222	48 89 44 24 48	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax
  00227	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  0022c	48 83 c0 08	 add	 rax, 8
  00230	48 89 44 24 38	 mov	 QWORD PTR bufPtr$[rsp], rax

; 522  : 				*bufPtr++ ^= *whiteningValuePtr64;

  00235	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  0023a	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  0023f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00242	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00245	48 33 c8	 xor	 rcx, rax
  00248	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  0024d	48 89 08	 mov	 QWORD PTR [rax], rcx
  00250	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  00255	48 83 c0 08	 add	 rax, 8
  00259	48 89 44 24 38	 mov	 QWORD PTR bufPtr$[rsp], rax

; 523  : 			}
; 524  : 			else

  0025e	eb 0e		 jmp	 SHORT $LN7@DecryptBuf
$LN8@DecryptBuf:

; 525  : 				whiteningValuePtr64++;

  00260	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  00265	48 83 c0 08	 add	 rax, 8
  00269	48 89 44 24 48	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax
$LN7@DecryptBuf:

; 526  : 
; 527  : 			// Derive the next whitening value
; 528  : 
; 529  : #if BYTE_ORDER == LITTLE_ENDIAN
; 530  : 
; 531  : 			// Little-endian platforms
; 532  : 
; 533  : 			finalCarry = 
; 534  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 535  : 				135 : 0;

  0026e	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  00273	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  0027d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00280	48 23 c1	 and	 rax, rcx
  00283	48 85 c0	 test	 rax, rax
  00286	74 0d		 je	 SHORT $LN19@DecryptBuf
  00288	c7 84 24 a0 00
	00 00 87 00 00
	00		 mov	 DWORD PTR tv132[rsp], 135 ; 00000087H
  00293	eb 0b		 jmp	 SHORT $LN20@DecryptBuf
$LN19@DecryptBuf:
  00295	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv132[rsp], 0
$LN20@DecryptBuf:
  002a0	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR tv132[rsp]
  002a8	88 44 24 78	 mov	 BYTE PTR finalCarry$[rsp], al

; 536  : 
; 537  : 			*whiteningValuePtr64-- <<= 1;

  002ac	48 8b 4c 24 48	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  002b1	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  002b4	48 d1 e1	 shl	 rcx, 1
  002b7	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002bc	48 89 08	 mov	 QWORD PTR [rax], rcx
  002bf	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002c4	48 83 e8 08	 sub	 rax, 8
  002c8	48 89 44 24 48	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax

; 538  : 
; 539  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  002cd	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002d2	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  002dc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002df	48 23 c1	 and	 rax, rcx
  002e2	48 85 c0	 test	 rax, rax
  002e5	74 16		 je	 SHORT $LN6@DecryptBuf

; 540  : 				*(whiteningValuePtr64 + 1) |= 1;	

  002e7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  002ec	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  002f0	48 83 c9 01	 or	 rcx, 1
  002f4	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002f9	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
$LN6@DecryptBuf:

; 541  : 
; 542  : 			*whiteningValuePtr64 <<= 1;

  002fd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  00302	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00305	48 d1 e1	 shl	 rcx, 1
  00308	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  0030d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 543  : 
; 544  : #else
; 545  : 			// Big-endian platforms
; 546  : 
; 547  : 			finalCarry = 
; 548  : 				(*whiteningValuePtr64 & 0x80) ?
; 549  : 				135 : 0;
; 550  : 
; 551  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 552  : 
; 553  : 			whiteningValuePtr64--;
; 554  : 
; 555  : 			if (*whiteningValuePtr64 & 0x80)
; 556  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 557  : 
; 558  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 559  : #endif
; 560  : 
; 561  : 			whiteningValue[0] ^= finalCarry;

  00310	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR finalCarry$[rsp]
  00315	0f b6 44 24 68	 movzx	 eax, BYTE PTR whiteningValue$[rsp]
  0031a	33 c1		 xor	 eax, ecx
  0031c	88 44 24 68	 mov	 BYTE PTR whiteningValue$[rsp], al

; 562  : 		}

  00320	e9 1c fe ff ff	 jmp	 $LN10@DecryptBuf
$LN9@DecryptBuf:

; 563  : 
; 564  : 		blockCount -= endBlock - startBlock;

  00325	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR startBlock$[rsp]
  0032c	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  00330	2b c1		 sub	 eax, ecx
  00332	8b c8		 mov	 ecx, eax
  00334	48 8b 44 24 40	 mov	 rax, QWORD PTR blockCount$[rsp]
  00339	48 2b c1	 sub	 rax, rcx
  0033c	48 89 44 24 40	 mov	 QWORD PTR blockCount$[rsp], rax

; 565  : 		startBlock = 0;

  00341	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR startBlock$[rsp], 0

; 566  : 		dataUnitNo++;

  0034c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dataUnitNo$[rsp]
  00354	48 83 c0 01	 add	 rax, 1
  00358	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR dataUnitNo$[rsp], rax

; 567  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  00360	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dataUnitNo$[rsp]
  00368	48 89 44 24 58	 mov	 QWORD PTR byteBufUnitNo$[rsp], rax

; 568  : 	}

  0036d	e9 56 fd ff ff	 jmp	 $LN15@DecryptBuf
$LN14@DecryptBuf:
$LN5@DecryptBuf:

; 569  : 
; 570  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  00372	48 8d 44 24 68	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  00377	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR burnm$28810[rsp], rax
  0037f	c7 84 24 90 00
	00 00 02 00 00
	00		 mov	 DWORD PTR burnc$28812[rsp], 2
$LN2@DecryptBuf:
  0038a	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR burnc$28812[rsp]
  00391	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR burnc$28812[rsp]
  00398	83 e8 01	 sub	 eax, 1
  0039b	89 84 24 90 00
	00 00		 mov	 DWORD PTR burnc$28812[rsp], eax
  003a2	85 c9		 test	 ecx, ecx
  003a4	74 25		 je	 SHORT $LN1@DecryptBuf
  003a6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR burnm$28810[rsp]
  003ae	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  003b5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR burnm$28810[rsp]
  003bd	48 83 c0 08	 add	 rax, 8
  003c1	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR burnm$28810[rsp], rax
  003c9	eb bf		 jmp	 SHORT $LN2@DecryptBuf
$LN1@DecryptBuf:
  003cb	33 c0		 xor	 eax, eax
  003cd	85 c0		 test	 eax, eax
  003cf	75 a1		 jne	 SHORT $LN5@DecryptBuf
$LN18@DecryptBuf:

; 571  : }

  003d1	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003d9	48 33 cc	 xor	 rcx, rsp
  003dc	e8 00 00 00 00	 call	 __security_check_cookie
  003e1	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  003e8	c3		 ret	 0
DecryptBufferXTSNonParallel ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptBufferXTSNonParallel DD imagerel EncryptBufferXTSNonParallel
	DD	imagerel EncryptBufferXTSNonParallel+1001
	DD	imagerel $unwind$EncryptBufferXTSNonParallel
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptBufferXTSNonParallel DD 022d19H
	DD	017011bH
	DD	imagerel __GSHandlerCheck
	DD	0a8H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EncryptBufferXTSNonParallel
_TEXT	SEGMENT
endBlock$ = 48
bufPtr$ = 56
blockCount$ = 64
whiteningValuePtr64$ = 72
byteBufUnitNo$ = 88
whiteningValue$ = 104
finalCarry$ = 120
dataUnitNo$ = 128
block$ = 136
startBlock$ = 140
burnc$28665 = 144
burnm$28663 = 152
tv132 = 160
__$ArrayPad$ = 168
buffer$ = 192
length$ = 200
startDataUnitNo$ = 208
startCipherBlockNo$ = 216
ks$ = 224
ks2$ = 232
cipher$ = 240
EncryptBufferXTSNonParallel PROC			; COMDAT

; 205  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 206  : 	unsigned __int8 finalCarry;
; 207  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 208  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 209  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  0002d	48 8d 44 24 68	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  00032	48 89 44 24 48	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax

; 210  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;

  00037	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR buffer$[rsp]
  0003f	48 89 44 24 38	 mov	 QWORD PTR bufPtr$[rsp], rax

; 211  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;

  00044	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR startCipherBlockNo$[rsp]
  0004b	89 84 24 8c 00
	00 00		 mov	 DWORD PTR startBlock$[rsp], eax

; 212  : 	TC_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 213  : 
; 214  : 	/* The encrypted data unit number (i.e. the resultant ciphertext block) is to be multiplied in the
; 215  : 	finite field GF(2^128) by j-th power of n, where j is the sequential plaintext/ciphertext block
; 216  : 	number and n is 2, a primitive element of GF(2^128). This can be (and is) simplified and implemented
; 217  : 	as a left shift of the preceding whitening value by one bit (with carry propagating). In addition, if
; 218  : 	the shift of the highest byte results in a carry, 135 is XORed into the lowest byte. The value 135 is
; 219  : 	derived from the modulus of the Galois Field (x^128+x^7+x^2+x+1). */
; 220  : 
; 221  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 222  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 223  : 	dataUnitNo = startDataUnitNo->Value;

  00052	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR startDataUnitNo$[rsp]
  0005a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR dataUnitNo$[rsp], rax

; 224  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  00065	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dataUnitNo$[rsp]
  0006d	48 89 44 24 58	 mov	 QWORD PTR byteBufUnitNo$[rsp], rax

; 225  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;

  00072	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR byteBufUnitNo$[rsp+8], 0

; 226  : 
; 227  : 	if (length % BYTES_PER_XTS_BLOCK)

  0007b	33 d2		 xor	 edx, edx
  0007d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR length$[rsp]
  00085	b9 10 00 00 00	 mov	 ecx, 16
  0008a	48 f7 f1	 div	 rcx
  0008d	48 85 d2	 test	 rdx, rdx
  00090	74 1f		 je	 SHORT $LN16@EncryptBuf

; 228  : 		TC_THROW_FATAL_EXCEPTION;

  00092	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  0009b	45 33 c9	 xor	 r9d, r9d
  0009e	45 33 c0	 xor	 r8d, r8d
  000a1	ba e4 00 00 00	 mov	 edx, 228		; 000000e4H
  000a6	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN16@EncryptBuf:

; 229  : 
; 230  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  000b1	33 d2		 xor	 edx, edx
  000b3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR length$[rsp]
  000bb	b9 10 00 00 00	 mov	 ecx, 16
  000c0	48 f7 f1	 div	 rcx
  000c3	48 89 44 24 40	 mov	 QWORD PTR blockCount$[rsp], rax
$LN15@EncryptBuf:

; 231  : 
; 232  : 	// Process all blocks in the buffer
; 233  : 	while (blockCount > 0)

  000c8	48 83 7c 24 40
	00		 cmp	 QWORD PTR blockCount$[rsp], 0
  000ce	0f 86 9e 02 00
	00		 jbe	 $LN14@EncryptBuf

; 234  : 	{
; 235  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  000d4	48 83 7c 24 40
	20		 cmp	 QWORD PTR blockCount$[rsp], 32 ; 00000020H
  000da	73 13		 jae	 SHORT $LN13@EncryptBuf

; 236  : 			endBlock = startBlock + (unsigned int) blockCount;

  000dc	8b 4c 24 40	 mov	 ecx, DWORD PTR blockCount$[rsp]
  000e0	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR startBlock$[rsp]
  000e7	03 c1		 add	 eax, ecx
  000e9	89 44 24 30	 mov	 DWORD PTR endBlock$[rsp], eax

; 237  : 		else

  000ed	eb 08		 jmp	 SHORT $LN12@EncryptBuf
$LN13@EncryptBuf:

; 238  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  000ef	c7 44 24 30 20
	00 00 00	 mov	 DWORD PTR endBlock$[rsp], 32 ; 00000020H
$LN12@EncryptBuf:

; 239  : 
; 240  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  000f7	48 8d 44 24 68	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  000fc	48 89 44 24 48	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax

; 241  : 
; 242  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 243  : 		// whitening value for this data unit)
; 244  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  00101	48 8b 4c 24 48	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  00106	48 8b 44 24 58	 mov	 rax, QWORD PTR byteBufUnitNo$[rsp]
  0010b	48 89 01	 mov	 QWORD PTR [rcx], rax

; 245  : 		*(whiteningValuePtr64 + 1) = 0;

  0010e	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  00113	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 246  : 		EncipherBlock (cipher, whiteningValue, ks2);

  0011b	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR ks2$[rsp]
  00123	48 8d 54 24 68	 lea	 rdx, QWORD PTR whiteningValue$[rsp]
  00128	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  0012f	e8 00 00 00 00	 call	 EncipherBlock

; 247  : 
; 248  : 		// Generate (and apply) subsequent whitening values for blocks in this data unit and
; 249  : 		// encrypt all relevant blocks in this data unit
; 250  : 		for (block = 0; block < endBlock; block++)

  00134	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR block$[rsp], 0
  0013f	eb 11		 jmp	 SHORT $LN11@EncryptBuf
$LN10@EncryptBuf:
  00141	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR block$[rsp]
  00148	83 c0 01	 add	 eax, 1
  0014b	89 84 24 88 00
	00 00		 mov	 DWORD PTR block$[rsp], eax
$LN11@EncryptBuf:
  00152	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  00156	39 84 24 88 00
	00 00		 cmp	 DWORD PTR block$[rsp], eax
  0015d	0f 83 c2 01 00
	00		 jae	 $LN9@EncryptBuf

; 251  : 		{
; 252  : 			if (block >= startBlock)

  00163	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR startBlock$[rsp]
  0016a	39 84 24 88 00
	00 00		 cmp	 DWORD PTR block$[rsp], eax
  00171	0f 82 e9 00 00
	00		 jb	 $LN8@EncryptBuf

; 253  : 			{
; 254  : 				// Pre-whitening
; 255  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  00177	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  0017c	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  00181	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00184	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00187	48 33 c8	 xor	 rcx, rax
  0018a	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  0018f	48 89 08	 mov	 QWORD PTR [rax], rcx
  00192	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  00197	48 83 c0 08	 add	 rax, 8
  0019b	48 89 44 24 48	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax
  001a0	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  001a5	48 83 c0 08	 add	 rax, 8
  001a9	48 89 44 24 38	 mov	 QWORD PTR bufPtr$[rsp], rax

; 256  : 				*bufPtr-- ^= *whiteningValuePtr64--;

  001ae	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  001b3	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  001b8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001bb	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001be	48 33 c8	 xor	 rcx, rax
  001c1	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  001c6	48 89 08	 mov	 QWORD PTR [rax], rcx
  001c9	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  001ce	48 83 e8 08	 sub	 rax, 8
  001d2	48 89 44 24 48	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax
  001d7	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  001dc	48 83 e8 08	 sub	 rax, 8
  001e0	48 89 44 24 38	 mov	 QWORD PTR bufPtr$[rsp], rax

; 257  : 
; 258  : 				// Actual encryption
; 259  : 				EncipherBlock (cipher, bufPtr, ks);

  001e5	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR ks$[rsp]
  001ed	48 8b 54 24 38	 mov	 rdx, QWORD PTR bufPtr$[rsp]
  001f2	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  001f9	e8 00 00 00 00	 call	 EncipherBlock

; 260  : 
; 261  : 				// Post-whitening
; 262  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  001fe	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  00203	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  00208	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0020b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0020e	48 33 c8	 xor	 rcx, rax
  00211	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  00216	48 89 08	 mov	 QWORD PTR [rax], rcx
  00219	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  0021e	48 83 c0 08	 add	 rax, 8
  00222	48 89 44 24 48	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax
  00227	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  0022c	48 83 c0 08	 add	 rax, 8
  00230	48 89 44 24 38	 mov	 QWORD PTR bufPtr$[rsp], rax

; 263  : 				*bufPtr++ ^= *whiteningValuePtr64;

  00235	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  0023a	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  0023f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00242	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00245	48 33 c8	 xor	 rcx, rax
  00248	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  0024d	48 89 08	 mov	 QWORD PTR [rax], rcx
  00250	48 8b 44 24 38	 mov	 rax, QWORD PTR bufPtr$[rsp]
  00255	48 83 c0 08	 add	 rax, 8
  00259	48 89 44 24 38	 mov	 QWORD PTR bufPtr$[rsp], rax

; 264  : 			}
; 265  : 			else

  0025e	eb 0e		 jmp	 SHORT $LN7@EncryptBuf
$LN8@EncryptBuf:

; 266  : 				whiteningValuePtr64++;

  00260	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  00265	48 83 c0 08	 add	 rax, 8
  00269	48 89 44 24 48	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax
$LN7@EncryptBuf:

; 267  : 
; 268  : 			// Derive the next whitening value
; 269  : 
; 270  : #if BYTE_ORDER == LITTLE_ENDIAN
; 271  : 
; 272  : 			// Little-endian platforms
; 273  : 
; 274  : 			finalCarry = 
; 275  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 276  : 				135 : 0;

  0026e	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  00273	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  0027d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00280	48 23 c1	 and	 rax, rcx
  00283	48 85 c0	 test	 rax, rax
  00286	74 0d		 je	 SHORT $LN19@EncryptBuf
  00288	c7 84 24 a0 00
	00 00 87 00 00
	00		 mov	 DWORD PTR tv132[rsp], 135 ; 00000087H
  00293	eb 0b		 jmp	 SHORT $LN20@EncryptBuf
$LN19@EncryptBuf:
  00295	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv132[rsp], 0
$LN20@EncryptBuf:
  002a0	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR tv132[rsp]
  002a8	88 44 24 78	 mov	 BYTE PTR finalCarry$[rsp], al

; 277  : 
; 278  : 			*whiteningValuePtr64-- <<= 1;

  002ac	48 8b 4c 24 48	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  002b1	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  002b4	48 d1 e1	 shl	 rcx, 1
  002b7	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002bc	48 89 08	 mov	 QWORD PTR [rax], rcx
  002bf	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002c4	48 83 e8 08	 sub	 rax, 8
  002c8	48 89 44 24 48	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax

; 279  : 
; 280  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  002cd	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002d2	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  002dc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002df	48 23 c1	 and	 rax, rcx
  002e2	48 85 c0	 test	 rax, rax
  002e5	74 16		 je	 SHORT $LN6@EncryptBuf

; 281  : 				*(whiteningValuePtr64 + 1) |= 1;	

  002e7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  002ec	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  002f0	48 83 c9 01	 or	 rcx, 1
  002f4	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002f9	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
$LN6@EncryptBuf:

; 282  : 
; 283  : 			*whiteningValuePtr64 <<= 1;

  002fd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  00302	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00305	48 d1 e1	 shl	 rcx, 1
  00308	48 8b 44 24 48	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  0030d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 284  : #else
; 285  : 
; 286  : 			// Big-endian platforms
; 287  : 
; 288  : 			finalCarry = 
; 289  : 				(*whiteningValuePtr64 & 0x80) ?
; 290  : 				135 : 0;
; 291  : 
; 292  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 293  : 
; 294  : 			whiteningValuePtr64--;
; 295  : 
; 296  : 			if (*whiteningValuePtr64 & 0x80)
; 297  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 298  : 
; 299  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 300  : #endif
; 301  : 
; 302  : 			whiteningValue[0] ^= finalCarry;

  00310	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR finalCarry$[rsp]
  00315	0f b6 44 24 68	 movzx	 eax, BYTE PTR whiteningValue$[rsp]
  0031a	33 c1		 xor	 eax, ecx
  0031c	88 44 24 68	 mov	 BYTE PTR whiteningValue$[rsp], al

; 303  : 		}

  00320	e9 1c fe ff ff	 jmp	 $LN10@EncryptBuf
$LN9@EncryptBuf:

; 304  : 
; 305  : 		blockCount -= endBlock - startBlock;

  00325	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR startBlock$[rsp]
  0032c	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  00330	2b c1		 sub	 eax, ecx
  00332	8b c8		 mov	 ecx, eax
  00334	48 8b 44 24 40	 mov	 rax, QWORD PTR blockCount$[rsp]
  00339	48 2b c1	 sub	 rax, rcx
  0033c	48 89 44 24 40	 mov	 QWORD PTR blockCount$[rsp], rax

; 306  : 		startBlock = 0;

  00341	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR startBlock$[rsp], 0

; 307  : 		dataUnitNo++;

  0034c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dataUnitNo$[rsp]
  00354	48 83 c0 01	 add	 rax, 1
  00358	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR dataUnitNo$[rsp], rax

; 308  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  00360	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dataUnitNo$[rsp]
  00368	48 89 44 24 58	 mov	 QWORD PTR byteBufUnitNo$[rsp], rax

; 309  : 	}

  0036d	e9 56 fd ff ff	 jmp	 $LN15@EncryptBuf
$LN14@EncryptBuf:
$LN5@EncryptBuf:

; 310  : 
; 311  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  00372	48 8d 44 24 68	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  00377	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR burnm$28663[rsp], rax
  0037f	c7 84 24 90 00
	00 00 02 00 00
	00		 mov	 DWORD PTR burnc$28665[rsp], 2
$LN2@EncryptBuf:
  0038a	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR burnc$28665[rsp]
  00391	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR burnc$28665[rsp]
  00398	83 e8 01	 sub	 eax, 1
  0039b	89 84 24 90 00
	00 00		 mov	 DWORD PTR burnc$28665[rsp], eax
  003a2	85 c9		 test	 ecx, ecx
  003a4	74 25		 je	 SHORT $LN1@EncryptBuf
  003a6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR burnm$28663[rsp]
  003ae	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  003b5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR burnm$28663[rsp]
  003bd	48 83 c0 08	 add	 rax, 8
  003c1	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR burnm$28663[rsp], rax
  003c9	eb bf		 jmp	 SHORT $LN2@EncryptBuf
$LN1@EncryptBuf:
  003cb	33 c0		 xor	 eax, eax
  003cd	85 c0		 test	 eax, eax
  003cf	75 a1		 jne	 SHORT $LN5@EncryptBuf
$LN18@EncryptBuf:

; 312  : }

  003d1	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003d9	48 33 cc	 xor	 rcx, rsp
  003dc	e8 00 00 00 00	 call	 __security_check_cookie
  003e1	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  003e8	c3		 ret	 0
EncryptBufferXTSNonParallel ENDP
PUBLIC	__$ArrayPad$
;	COMDAT pdata
pdata	SEGMENT
$pdata$DecryptBufferXTSParallel DD imagerel DecryptBufferXTSParallel
	DD	imagerel DecryptBufferXTSParallel+1631
	DD	imagerel $unwind$DecryptBufferXTSParallel
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecryptBufferXTSParallel DD 022d19H
	DD	05d011bH
	DD	imagerel __GSHandlerCheck
	DD	02d8H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DecryptBufferXTSParallel
_TEXT	SEGMENT
endBlock$ = 48
finalInt64WhiteningValuesPtr$ = 56
whiteningValues$ = 80
bufPtr$ = 592
dataUnitBufPtr$ = 600
blockCount$ = 608
whiteningValuePtr64$ = 616
whiteningValuesPtr64$ = 624
byteBufUnitNo$ = 632
whiteningValue$ = 648
finalCarry$ = 664
dataUnitNo$ = 672
block$ = 680
startBlock$ = 684
burnc$28748 = 688
burnm$28746 = 696
burnc$28757 = 704
burnm$28755 = 712
tv91 = 720
__$ArrayPad$ = 728
buffer$ = 752
length$ = 760
startDataUnitNo$ = 768
startCipherBlockNo$ = 776
ks$ = 784
ks2$ = 792
cipher$ = 800
DecryptBufferXTSParallel PROC				; COMDAT

; 339  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec e8 02
	00 00		 sub	 rsp, 744		; 000002e8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 d8
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 340  : 	unsigned __int8 finalCarry;
; 341  : 	unsigned __int8 whiteningValues [ENCRYPTION_DATA_UNIT_SIZE];
; 342  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 343  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 344  : 	unsigned __int64 *whiteningValuesPtr64 = (unsigned __int64 *) whiteningValues;

  0002d	48 8d 44 24 50	 lea	 rax, QWORD PTR whiteningValues$[rsp]
  00032	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax

; 345  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  0003a	48 8d 84 24 88
	02 00 00	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  00042	48 89 84 24 68
	02 00 00	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax

; 346  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;

  0004a	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR buffer$[rsp]
  00052	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR bufPtr$[rsp], rax

; 347  : 	unsigned __int64 *dataUnitBufPtr;
; 348  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;

  0005a	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR startCipherBlockNo$[rsp]
  00061	89 84 24 ac 02
	00 00		 mov	 DWORD PTR startBlock$[rsp], eax

; 349  : 	unsigned __int64 *const finalInt64WhiteningValuesPtr = whiteningValuesPtr64 + sizeof (whiteningValues) / sizeof (*whiteningValuesPtr64) - 1;

  00068	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  00070	48 05 f8 01 00
	00		 add	 rax, 504		; 000001f8H
  00076	48 89 44 24 38	 mov	 QWORD PTR finalInt64WhiteningValuesPtr$[rsp], rax

; 350  : 	TC_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 351  : 
; 352  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 353  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 354  : 	dataUnitNo = startDataUnitNo->Value;

  0007b	48 8b 84 24 00
	03 00 00	 mov	 rax, QWORD PTR startDataUnitNo$[rsp]
  00083	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00086	48 89 84 24 a0
	02 00 00	 mov	 QWORD PTR dataUnitNo$[rsp], rax

; 355  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  0008e	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR dataUnitNo$[rsp]
  00096	48 89 84 24 78
	02 00 00	 mov	 QWORD PTR byteBufUnitNo$[rsp], rax

; 356  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;

  0009e	48 c7 84 24 80
	02 00 00 00 00
	00 00		 mov	 QWORD PTR byteBufUnitNo$[rsp+8], 0

; 357  : 
; 358  : 	if (length % BYTES_PER_XTS_BLOCK)

  000aa	33 d2		 xor	 edx, edx
  000ac	48 8b 84 24 f8
	02 00 00	 mov	 rax, QWORD PTR length$[rsp]
  000b4	b9 10 00 00 00	 mov	 ecx, 16
  000b9	48 f7 f1	 div	 rcx
  000bc	48 85 d2	 test	 rdx, rdx
  000bf	74 1f		 je	 SHORT $LN27@DecryptBuf@5

; 359  : 		TC_THROW_FATAL_EXCEPTION;

  000c1	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  000ca	45 33 c9	 xor	 r9d, r9d
  000cd	45 33 c0	 xor	 r8d, r8d
  000d0	ba 67 01 00 00	 mov	 edx, 359		; 00000167H
  000d5	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  000da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN27@DecryptBuf@5:

; 360  : 
; 361  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  000e0	33 d2		 xor	 edx, edx
  000e2	48 8b 84 24 f8
	02 00 00	 mov	 rax, QWORD PTR length$[rsp]
  000ea	b9 10 00 00 00	 mov	 ecx, 16
  000ef	48 f7 f1	 div	 rcx
  000f2	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR blockCount$[rsp], rax
$LN26@DecryptBuf@5:

; 362  : 
; 363  : 	// Process all blocks in the buffer
; 364  : 	while (blockCount > 0)

  000fa	48 83 bc 24 60
	02 00 00 00	 cmp	 QWORD PTR blockCount$[rsp], 0
  00103	0f 86 7d 04 00
	00		 jbe	 $LN25@DecryptBuf@5

; 365  : 	{
; 366  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  00109	48 83 bc 24 60
	02 00 00 20	 cmp	 QWORD PTR blockCount$[rsp], 32 ; 00000020H
  00112	73 16		 jae	 SHORT $LN24@DecryptBuf@5

; 367  : 			endBlock = startBlock + (unsigned int) blockCount;

  00114	8b 8c 24 60 02
	00 00		 mov	 ecx, DWORD PTR blockCount$[rsp]
  0011b	8b 84 24 ac 02
	00 00		 mov	 eax, DWORD PTR startBlock$[rsp]
  00122	03 c1		 add	 eax, ecx
  00124	89 44 24 30	 mov	 DWORD PTR endBlock$[rsp], eax

; 368  : 		else

  00128	eb 08		 jmp	 SHORT $LN23@DecryptBuf@5
$LN24@DecryptBuf@5:

; 369  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  0012a	c7 44 24 30 20
	00 00 00	 mov	 DWORD PTR endBlock$[rsp], 32 ; 00000020H
$LN23@DecryptBuf@5:

; 370  : 
; 371  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  00132	48 8b 44 24 38	 mov	 rax, QWORD PTR finalInt64WhiteningValuesPtr$[rsp]
  00137	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax

; 372  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  0013f	48 8d 84 24 88
	02 00 00	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  00147	48 89 84 24 68
	02 00 00	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax

; 373  : 
; 374  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 375  : 		// whitening value for this data unit)
; 376  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  0014f	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  00157	48 8b 84 24 78
	02 00 00	 mov	 rax, QWORD PTR byteBufUnitNo$[rsp]
  0015f	48 89 01	 mov	 QWORD PTR [rcx], rax

; 377  : 		*(whiteningValuePtr64 + 1) = 0;

  00162	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  0016a	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 378  : 		EncipherBlock (cipher, whiteningValue, ks2);

  00172	4c 8b 84 24 18
	03 00 00	 mov	 r8, QWORD PTR ks2$[rsp]
  0017a	48 8d 94 24 88
	02 00 00	 lea	 rdx, QWORD PTR whiteningValue$[rsp]
  00182	8b 8c 24 20 03
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  00189	e8 00 00 00 00	 call	 EncipherBlock

; 379  : 
; 380  : 		// Generate subsequent whitening values for blocks in this data unit. Note that all generated 128-bit
; 381  : 		// whitening values are stored in memory as a sequence of 64-bit integers in reverse order.
; 382  : 		for (block = 0; block < endBlock; block++)

  0018e	c7 84 24 a8 02
	00 00 00 00 00
	00		 mov	 DWORD PTR block$[rsp], 0
  00199	eb 11		 jmp	 SHORT $LN22@DecryptBuf@5
$LN21@DecryptBuf@5:
  0019b	8b 84 24 a8 02
	00 00		 mov	 eax, DWORD PTR block$[rsp]
  001a2	83 c0 01	 add	 eax, 1
  001a5	89 84 24 a8 02
	00 00		 mov	 DWORD PTR block$[rsp], eax
$LN22@DecryptBuf@5:
  001ac	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  001b0	39 84 24 a8 02
	00 00		 cmp	 DWORD PTR block$[rsp], eax
  001b7	0f 83 6f 01 00
	00		 jae	 $LN20@DecryptBuf@5

; 383  : 		{
; 384  : 			if (block >= startBlock)

  001bd	8b 84 24 ac 02
	00 00		 mov	 eax, DWORD PTR startBlock$[rsp]
  001c4	39 84 24 a8 02
	00 00		 cmp	 DWORD PTR block$[rsp], eax
  001cb	72 6a		 jb	 SHORT $LN19@DecryptBuf@5

; 385  : 			{
; 386  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64++;

  001cd	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR whiteningValuesPtr64$[rsp]
  001d5	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  001dd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001e0	48 89 01	 mov	 QWORD PTR [rcx], rax
  001e3	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  001eb	48 83 e8 08	 sub	 rax, 8
  001ef	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax
  001f7	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  001ff	48 83 c0 08	 add	 rax, 8
  00203	48 89 84 24 68
	02 00 00	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax

; 387  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64;

  0020b	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR whiteningValuesPtr64$[rsp]
  00213	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  0021b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0021e	48 89 01	 mov	 QWORD PTR [rcx], rax
  00221	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  00229	48 83 e8 08	 sub	 rax, 8
  0022d	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax

; 388  : 			}
; 389  : 			else

  00235	eb 14		 jmp	 SHORT $LN18@DecryptBuf@5
$LN19@DecryptBuf@5:

; 390  : 				whiteningValuePtr64++;

  00237	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  0023f	48 83 c0 08	 add	 rax, 8
  00243	48 89 84 24 68
	02 00 00	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax
$LN18@DecryptBuf@5:

; 391  : 
; 392  : 			// Derive the next whitening value
; 393  : 
; 394  : #if BYTE_ORDER == LITTLE_ENDIAN
; 395  : 
; 396  : 			// Little-endian platforms
; 397  : 
; 398  : 			finalCarry = 
; 399  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 400  : 				135 : 0;

  0024b	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  00253	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  0025d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00260	48 23 c1	 and	 rax, rcx
  00263	48 85 c0	 test	 rax, rax
  00266	74 0d		 je	 SHORT $LN30@DecryptBuf@5
  00268	c7 84 24 d0 02
	00 00 87 00 00
	00		 mov	 DWORD PTR tv91[rsp], 135 ; 00000087H
  00273	eb 0b		 jmp	 SHORT $LN31@DecryptBuf@5
$LN30@DecryptBuf@5:
  00275	c7 84 24 d0 02
	00 00 00 00 00
	00		 mov	 DWORD PTR tv91[rsp], 0
$LN31@DecryptBuf@5:
  00280	0f b6 84 24 d0
	02 00 00	 movzx	 eax, BYTE PTR tv91[rsp]
  00288	88 84 24 98 02
	00 00		 mov	 BYTE PTR finalCarry$[rsp], al

; 401  : 
; 402  : 			*whiteningValuePtr64-- <<= 1;

  0028f	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  00297	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0029a	48 d1 e1	 shl	 rcx, 1
  0029d	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002a5	48 89 08	 mov	 QWORD PTR [rax], rcx
  002a8	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002b0	48 83 e8 08	 sub	 rax, 8
  002b4	48 89 84 24 68
	02 00 00	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax

; 403  : 
; 404  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  002bc	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002c4	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  002ce	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002d1	48 23 c1	 and	 rax, rcx
  002d4	48 85 c0	 test	 rax, rax
  002d7	74 1c		 je	 SHORT $LN17@DecryptBuf@5

; 405  : 				*(whiteningValuePtr64 + 1) |= 1;	

  002d9	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  002e1	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  002e5	48 83 c9 01	 or	 rcx, 1
  002e9	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002f1	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
$LN17@DecryptBuf@5:

; 406  : 
; 407  : 			*whiteningValuePtr64 <<= 1;

  002f5	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  002fd	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00300	48 d1 e1	 shl	 rcx, 1
  00303	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  0030b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 408  : 
; 409  : #else
; 410  : 			// Big-endian platforms
; 411  : 
; 412  : 			finalCarry = 
; 413  : 				(*whiteningValuePtr64 & 0x80) ?
; 414  : 				135 : 0;
; 415  : 
; 416  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 417  : 
; 418  : 			whiteningValuePtr64--;
; 419  : 
; 420  : 			if (*whiteningValuePtr64 & 0x80)
; 421  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 422  : 
; 423  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 424  : #endif
; 425  : 
; 426  : 			whiteningValue[0] ^= finalCarry;

  0030e	0f b6 8c 24 98
	02 00 00	 movzx	 ecx, BYTE PTR finalCarry$[rsp]
  00316	0f b6 84 24 88
	02 00 00	 movzx	 eax, BYTE PTR whiteningValue$[rsp]
  0031e	33 c1		 xor	 eax, ecx
  00320	88 84 24 88 02
	00 00		 mov	 BYTE PTR whiteningValue$[rsp], al

; 427  : 		}

  00327	e9 6f fe ff ff	 jmp	 $LN21@DecryptBuf@5
$LN20@DecryptBuf@5:

; 428  : 
; 429  : 		dataUnitBufPtr = bufPtr;

  0032c	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  00334	48 89 84 24 58
	02 00 00	 mov	 QWORD PTR dataUnitBufPtr$[rsp], rax

; 430  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  0033c	48 8b 44 24 38	 mov	 rax, QWORD PTR finalInt64WhiteningValuesPtr$[rsp]
  00341	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax

; 431  : 
; 432  : 		// Decrypt blocks in this data unit
; 433  : 
; 434  : 		for (block = startBlock; block < endBlock; block++)

  00349	8b 84 24 ac 02
	00 00		 mov	 eax, DWORD PTR startBlock$[rsp]
  00350	89 84 24 a8 02
	00 00		 mov	 DWORD PTR block$[rsp], eax
  00357	eb 11		 jmp	 SHORT $LN16@DecryptBuf@5
$LN15@DecryptBuf@5:
  00359	8b 84 24 a8 02
	00 00		 mov	 eax, DWORD PTR block$[rsp]
  00360	83 c0 01	 add	 eax, 1
  00363	89 84 24 a8 02
	00 00		 mov	 DWORD PTR block$[rsp], eax
$LN16@DecryptBuf@5:
  0036a	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  0036e	39 84 24 a8 02
	00 00		 cmp	 DWORD PTR block$[rsp], eax
  00375	0f 83 9d 00 00
	00		 jae	 $LN14@DecryptBuf@5

; 435  : 		{
; 436  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  0037b	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  00383	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  0038b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0038e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00391	48 33 c8	 xor	 rcx, rax
  00394	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  0039c	48 89 08	 mov	 QWORD PTR [rax], rcx
  0039f	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  003a7	48 83 e8 08	 sub	 rax, 8
  003ab	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax
  003b3	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  003bb	48 83 c0 08	 add	 rax, 8
  003bf	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR bufPtr$[rsp], rax

; 437  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  003c7	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  003cf	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  003d7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003da	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  003dd	48 33 c8	 xor	 rcx, rax
  003e0	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  003e8	48 89 08	 mov	 QWORD PTR [rax], rcx
  003eb	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  003f3	48 83 e8 08	 sub	 rax, 8
  003f7	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax
  003ff	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  00407	48 83 c0 08	 add	 rax, 8
  0040b	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR bufPtr$[rsp], rax

; 438  : 		}

  00413	e9 41 ff ff ff	 jmp	 $LN15@DecryptBuf@5
$LN14@DecryptBuf@5:

; 439  : 
; 440  : 		DecipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);

  00418	8b 8c 24 ac 02
	00 00		 mov	 ecx, DWORD PTR startBlock$[rsp]
  0041f	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  00423	2b c1		 sub	 eax, ecx
  00425	44 8b c8	 mov	 r9d, eax
  00428	4c 8b 84 24 10
	03 00 00	 mov	 r8, QWORD PTR ks$[rsp]
  00430	48 8b 94 24 58
	02 00 00	 mov	 rdx, QWORD PTR dataUnitBufPtr$[rsp]
  00438	8b 8c 24 20 03
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  0043f	e8 00 00 00 00	 call	 DecipherBlocks

; 441  : 
; 442  : 		bufPtr = dataUnitBufPtr;

  00444	4c 8b 9c 24 58
	02 00 00	 mov	 r11, QWORD PTR dataUnitBufPtr$[rsp]
  0044c	4c 89 9c 24 50
	02 00 00	 mov	 QWORD PTR bufPtr$[rsp], r11

; 443  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  00454	48 8b 44 24 38	 mov	 rax, QWORD PTR finalInt64WhiteningValuesPtr$[rsp]
  00459	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax

; 444  : 
; 445  : 		for (block = startBlock; block < endBlock; block++)

  00461	8b 84 24 ac 02
	00 00		 mov	 eax, DWORD PTR startBlock$[rsp]
  00468	89 84 24 a8 02
	00 00		 mov	 DWORD PTR block$[rsp], eax
  0046f	eb 11		 jmp	 SHORT $LN13@DecryptBuf@5
$LN12@DecryptBuf@5:
  00471	8b 84 24 a8 02
	00 00		 mov	 eax, DWORD PTR block$[rsp]
  00478	83 c0 01	 add	 eax, 1
  0047b	89 84 24 a8 02
	00 00		 mov	 DWORD PTR block$[rsp], eax
$LN13@DecryptBuf@5:
  00482	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  00486	39 84 24 a8 02
	00 00		 cmp	 DWORD PTR block$[rsp], eax
  0048d	0f 83 9d 00 00
	00		 jae	 $LN11@DecryptBuf@5

; 446  : 		{
; 447  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00493	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  0049b	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  004a3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004a6	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  004a9	48 33 c8	 xor	 rcx, rax
  004ac	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  004b4	48 89 08	 mov	 QWORD PTR [rax], rcx
  004b7	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  004bf	48 83 e8 08	 sub	 rax, 8
  004c3	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax
  004cb	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  004d3	48 83 c0 08	 add	 rax, 8
  004d7	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR bufPtr$[rsp], rax

; 448  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  004df	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  004e7	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  004ef	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004f2	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  004f5	48 33 c8	 xor	 rcx, rax
  004f8	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  00500	48 89 08	 mov	 QWORD PTR [rax], rcx
  00503	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  0050b	48 83 e8 08	 sub	 rax, 8
  0050f	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax
  00517	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  0051f	48 83 c0 08	 add	 rax, 8
  00523	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR bufPtr$[rsp], rax

; 449  : 		}

  0052b	e9 41 ff ff ff	 jmp	 $LN12@DecryptBuf@5
$LN11@DecryptBuf@5:

; 450  : 
; 451  : 		blockCount -= endBlock - startBlock;

  00530	8b 8c 24 ac 02
	00 00		 mov	 ecx, DWORD PTR startBlock$[rsp]
  00537	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  0053b	2b c1		 sub	 eax, ecx
  0053d	8b c8		 mov	 ecx, eax
  0053f	48 8b 84 24 60
	02 00 00	 mov	 rax, QWORD PTR blockCount$[rsp]
  00547	48 2b c1	 sub	 rax, rcx
  0054a	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR blockCount$[rsp], rax

; 452  : 		startBlock = 0;

  00552	c7 84 24 ac 02
	00 00 00 00 00
	00		 mov	 DWORD PTR startBlock$[rsp], 0

; 453  : 		dataUnitNo++;

  0055d	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR dataUnitNo$[rsp]
  00565	48 83 c0 01	 add	 rax, 1
  00569	48 89 84 24 a0
	02 00 00	 mov	 QWORD PTR dataUnitNo$[rsp], rax

; 454  : 
; 455  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  00571	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR dataUnitNo$[rsp]
  00579	48 89 84 24 78
	02 00 00	 mov	 QWORD PTR byteBufUnitNo$[rsp], rax

; 456  : 	}

  00581	e9 74 fb ff ff	 jmp	 $LN26@DecryptBuf@5
$LN25@DecryptBuf@5:
$LN10@DecryptBuf@5:

; 457  : 
; 458  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  00586	48 8d 84 24 88
	02 00 00	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  0058e	48 89 84 24 b8
	02 00 00	 mov	 QWORD PTR burnm$28746[rsp], rax
  00596	c7 84 24 b0 02
	00 00 02 00 00
	00		 mov	 DWORD PTR burnc$28748[rsp], 2
$LN7@DecryptBuf@5:
  005a1	8b 8c 24 b0 02
	00 00		 mov	 ecx, DWORD PTR burnc$28748[rsp]
  005a8	8b 84 24 b0 02
	00 00		 mov	 eax, DWORD PTR burnc$28748[rsp]
  005af	83 e8 01	 sub	 eax, 1
  005b2	89 84 24 b0 02
	00 00		 mov	 DWORD PTR burnc$28748[rsp], eax
  005b9	85 c9		 test	 ecx, ecx
  005bb	74 25		 je	 SHORT $LN6@DecryptBuf@5
  005bd	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR burnm$28746[rsp]
  005c5	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  005cc	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR burnm$28746[rsp]
  005d4	48 83 c0 08	 add	 rax, 8
  005d8	48 89 84 24 b8
	02 00 00	 mov	 QWORD PTR burnm$28746[rsp], rax
  005e0	eb bf		 jmp	 SHORT $LN7@DecryptBuf@5
$LN6@DecryptBuf@5:
  005e2	33 c0		 xor	 eax, eax
  005e4	85 c0		 test	 eax, eax
  005e6	75 9e		 jne	 SHORT $LN10@DecryptBuf@5
$LN5@DecryptBuf@5:

; 459  : 	FAST_ERASE64 (whiteningValues, sizeof (whiteningValues));

  005e8	48 8d 44 24 50	 lea	 rax, QWORD PTR whiteningValues$[rsp]
  005ed	48 89 84 24 c8
	02 00 00	 mov	 QWORD PTR burnm$28755[rsp], rax
  005f5	c7 84 24 c0 02
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$28757[rsp], 64 ; 00000040H
$LN2@DecryptBuf@5:
  00600	8b 8c 24 c0 02
	00 00		 mov	 ecx, DWORD PTR burnc$28757[rsp]
  00607	8b 84 24 c0 02
	00 00		 mov	 eax, DWORD PTR burnc$28757[rsp]
  0060e	83 e8 01	 sub	 eax, 1
  00611	89 84 24 c0 02
	00 00		 mov	 DWORD PTR burnc$28757[rsp], eax
  00618	85 c9		 test	 ecx, ecx
  0061a	74 25		 je	 SHORT $LN1@DecryptBuf@5
  0061c	48 8b 84 24 c8
	02 00 00	 mov	 rax, QWORD PTR burnm$28755[rsp]
  00624	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  0062b	48 8b 84 24 c8
	02 00 00	 mov	 rax, QWORD PTR burnm$28755[rsp]
  00633	48 83 c0 08	 add	 rax, 8
  00637	48 89 84 24 c8
	02 00 00	 mov	 QWORD PTR burnm$28755[rsp], rax
  0063f	eb bf		 jmp	 SHORT $LN2@DecryptBuf@5
$LN1@DecryptBuf@5:
  00641	33 c0		 xor	 eax, eax
  00643	85 c0		 test	 eax, eax
  00645	75 a1		 jne	 SHORT $LN5@DecryptBuf@5
$LN29@DecryptBuf@5:

; 460  : }

  00647	48 8b 8c 24 d8
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0064f	48 33 cc	 xor	 rcx, rsp
  00652	e8 00 00 00 00	 call	 __security_check_cookie
  00657	48 81 c4 e8 02
	00 00		 add	 rsp, 744		; 000002e8H
  0065e	c3		 ret	 0
DecryptBufferXTSParallel ENDP
_TEXT	ENDS
PUBLIC	DecryptBufferXTS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DecryptBufferXTS DD imagerel $LN5
	DD	imagerel $LN5+159
	DD	imagerel $unwind$DecryptBufferXTS
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecryptBufferXTS DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DecryptBufferXTS
_TEXT	SEGMENT
buffer$ = 80
length$ = 88
startDataUnitNo$ = 96
startCipherBlockNo$ = 104
ks$ = 112
ks2$ = 120
cipher$ = 128
DecryptBufferXTS PROC					; COMDAT

; 323  : {

$LN5:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 324  : 	if (CipherSupportsIntraDataUnitParallelization (cipher))

  00018	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  0001f	e8 00 00 00 00	 call	 CipherSupportsIntraDataUnitParallelization
  00024	85 c0		 test	 eax, eax
  00026	74 3a		 je	 SHORT $LN2@DecryptBuf@6

; 325  : 		DecryptBufferXTSParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  00028	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR cipher$[rsp]
  0002f	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00033	48 8b 44 24 78	 mov	 rax, QWORD PTR ks2$[rsp]
  00038	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0003d	48 8b 44 24 70	 mov	 rax, QWORD PTR ks$[rsp]
  00042	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00047	44 8b 4c 24 68	 mov	 r9d, DWORD PTR startCipherBlockNo$[rsp]
  0004c	4c 8b 44 24 60	 mov	 r8, QWORD PTR startDataUnitNo$[rsp]
  00051	48 8b 54 24 58	 mov	 rdx, QWORD PTR length$[rsp]
  00056	48 8b 4c 24 50	 mov	 rcx, QWORD PTR buffer$[rsp]
  0005b	e8 00 00 00 00	 call	 DecryptBufferXTSParallel

; 326  : 	else

  00060	eb 38		 jmp	 SHORT $LN1@DecryptBuf@6
$LN2@DecryptBuf@6:

; 327  : 		DecryptBufferXTSNonParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  00062	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR cipher$[rsp]
  00069	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0006d	48 8b 44 24 78	 mov	 rax, QWORD PTR ks2$[rsp]
  00072	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00077	48 8b 44 24 70	 mov	 rax, QWORD PTR ks$[rsp]
  0007c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00081	44 8b 4c 24 68	 mov	 r9d, DWORD PTR startCipherBlockNo$[rsp]
  00086	4c 8b 44 24 60	 mov	 r8, QWORD PTR startDataUnitNo$[rsp]
  0008b	48 8b 54 24 58	 mov	 rdx, QWORD PTR length$[rsp]
  00090	48 8b 4c 24 50	 mov	 rcx, QWORD PTR buffer$[rsp]
  00095	e8 00 00 00 00	 call	 DecryptBufferXTSNonParallel
$LN1@DecryptBuf@6:

; 328  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
DecryptBufferXTS ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptBufferXTSParallel DD imagerel EncryptBufferXTSParallel
	DD	imagerel EncryptBufferXTSParallel+1631
	DD	imagerel $unwind$EncryptBufferXTSParallel
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptBufferXTSParallel DD 022d19H
	DD	05d011bH
	DD	imagerel __GSHandlerCheck
	DD	02d8H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EncryptBufferXTSParallel
_TEXT	SEGMENT
endBlock$ = 48
finalInt64WhiteningValuesPtr$ = 56
whiteningValues$ = 80
bufPtr$ = 592
dataUnitBufPtr$ = 600
blockCount$ = 608
whiteningValuePtr64$ = 616
whiteningValuesPtr64$ = 624
byteBufUnitNo$ = 632
whiteningValue$ = 648
finalCarry$ = 664
dataUnitNo$ = 672
block$ = 680
startBlock$ = 684
burnc$28601 = 688
burnm$28599 = 696
burnc$28610 = 704
burnm$28608 = 712
tv91 = 720
__$ArrayPad$ = 728
buffer$ = 752
length$ = 760
startDataUnitNo$ = 768
startCipherBlockNo$ = 776
ks$ = 784
ks2$ = 792
cipher$ = 800
EncryptBufferXTSParallel PROC				; COMDAT

; 64   : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec e8 02
	00 00		 sub	 rsp, 744		; 000002e8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 d8
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 65   : 	unsigned __int8 finalCarry;
; 66   : 	unsigned __int8 whiteningValues [ENCRYPTION_DATA_UNIT_SIZE];
; 67   : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 68   : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 69   : 	unsigned __int64 *whiteningValuesPtr64 = (unsigned __int64 *) whiteningValues;

  0002d	48 8d 44 24 50	 lea	 rax, QWORD PTR whiteningValues$[rsp]
  00032	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax

; 70   : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  0003a	48 8d 84 24 88
	02 00 00	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  00042	48 89 84 24 68
	02 00 00	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax

; 71   : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;

  0004a	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR buffer$[rsp]
  00052	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR bufPtr$[rsp], rax

; 72   : 	unsigned __int64 *dataUnitBufPtr;
; 73   : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;

  0005a	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR startCipherBlockNo$[rsp]
  00061	89 84 24 ac 02
	00 00		 mov	 DWORD PTR startBlock$[rsp], eax

; 74   : 	unsigned __int64 *const finalInt64WhiteningValuesPtr = whiteningValuesPtr64 + sizeof (whiteningValues) / sizeof (*whiteningValuesPtr64) - 1;

  00068	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  00070	48 05 f8 01 00
	00		 add	 rax, 504		; 000001f8H
  00076	48 89 44 24 38	 mov	 QWORD PTR finalInt64WhiteningValuesPtr$[rsp], rax

; 75   : 	TC_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 76   : 
; 77   : 	/* The encrypted data unit number (i.e. the resultant ciphertext block) is to be multiplied in the
; 78   : 	finite field GF(2^128) by j-th power of n, where j is the sequential plaintext/ciphertext block
; 79   : 	number and n is 2, a primitive element of GF(2^128). This can be (and is) simplified and implemented
; 80   : 	as a left shift of the preceding whitening value by one bit (with carry propagating). In addition, if
; 81   : 	the shift of the highest byte results in a carry, 135 is XORed into the lowest byte. The value 135 is
; 82   : 	derived from the modulus of the Galois Field (x^128+x^7+x^2+x+1). */
; 83   : 
; 84   : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 85   : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 86   : 	dataUnitNo = startDataUnitNo->Value;

  0007b	48 8b 84 24 00
	03 00 00	 mov	 rax, QWORD PTR startDataUnitNo$[rsp]
  00083	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00086	48 89 84 24 a0
	02 00 00	 mov	 QWORD PTR dataUnitNo$[rsp], rax

; 87   : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  0008e	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR dataUnitNo$[rsp]
  00096	48 89 84 24 78
	02 00 00	 mov	 QWORD PTR byteBufUnitNo$[rsp], rax

; 88   : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;

  0009e	48 c7 84 24 80
	02 00 00 00 00
	00 00		 mov	 QWORD PTR byteBufUnitNo$[rsp+8], 0

; 89   : 
; 90   : 	if (length % BYTES_PER_XTS_BLOCK)

  000aa	33 d2		 xor	 edx, edx
  000ac	48 8b 84 24 f8
	02 00 00	 mov	 rax, QWORD PTR length$[rsp]
  000b4	b9 10 00 00 00	 mov	 ecx, 16
  000b9	48 f7 f1	 div	 rcx
  000bc	48 85 d2	 test	 rdx, rdx
  000bf	74 1f		 je	 SHORT $LN27@EncryptBuf@5

; 91   : 		TC_THROW_FATAL_EXCEPTION;

  000c1	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  000ca	45 33 c9	 xor	 r9d, r9d
  000cd	45 33 c0	 xor	 r8d, r8d
  000d0	ba 5b 00 00 00	 mov	 edx, 91			; 0000005bH
  000d5	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  000da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN27@EncryptBuf@5:

; 92   : 
; 93   : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  000e0	33 d2		 xor	 edx, edx
  000e2	48 8b 84 24 f8
	02 00 00	 mov	 rax, QWORD PTR length$[rsp]
  000ea	b9 10 00 00 00	 mov	 ecx, 16
  000ef	48 f7 f1	 div	 rcx
  000f2	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR blockCount$[rsp], rax
$LN26@EncryptBuf@5:

; 94   : 
; 95   : 	// Process all blocks in the buffer
; 96   : 	while (blockCount > 0)

  000fa	48 83 bc 24 60
	02 00 00 00	 cmp	 QWORD PTR blockCount$[rsp], 0
  00103	0f 86 7d 04 00
	00		 jbe	 $LN25@EncryptBuf@5

; 97   : 	{
; 98   : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  00109	48 83 bc 24 60
	02 00 00 20	 cmp	 QWORD PTR blockCount$[rsp], 32 ; 00000020H
  00112	73 16		 jae	 SHORT $LN24@EncryptBuf@5

; 99   : 			endBlock = startBlock + (unsigned int) blockCount;

  00114	8b 8c 24 60 02
	00 00		 mov	 ecx, DWORD PTR blockCount$[rsp]
  0011b	8b 84 24 ac 02
	00 00		 mov	 eax, DWORD PTR startBlock$[rsp]
  00122	03 c1		 add	 eax, ecx
  00124	89 44 24 30	 mov	 DWORD PTR endBlock$[rsp], eax

; 100  : 		else

  00128	eb 08		 jmp	 SHORT $LN23@EncryptBuf@5
$LN24@EncryptBuf@5:

; 101  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  0012a	c7 44 24 30 20
	00 00 00	 mov	 DWORD PTR endBlock$[rsp], 32 ; 00000020H
$LN23@EncryptBuf@5:

; 102  : 
; 103  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  00132	48 8b 44 24 38	 mov	 rax, QWORD PTR finalInt64WhiteningValuesPtr$[rsp]
  00137	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax

; 104  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;

  0013f	48 8d 84 24 88
	02 00 00	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  00147	48 89 84 24 68
	02 00 00	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax

; 105  : 
; 106  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 107  : 		// whitening value for this data unit)
; 108  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  0014f	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  00157	48 8b 84 24 78
	02 00 00	 mov	 rax, QWORD PTR byteBufUnitNo$[rsp]
  0015f	48 89 01	 mov	 QWORD PTR [rcx], rax

; 109  : 		*(whiteningValuePtr64 + 1) = 0;

  00162	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  0016a	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 110  : 		EncipherBlock (cipher, whiteningValue, ks2);

  00172	4c 8b 84 24 18
	03 00 00	 mov	 r8, QWORD PTR ks2$[rsp]
  0017a	48 8d 94 24 88
	02 00 00	 lea	 rdx, QWORD PTR whiteningValue$[rsp]
  00182	8b 8c 24 20 03
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  00189	e8 00 00 00 00	 call	 EncipherBlock

; 111  : 
; 112  : 		// Generate subsequent whitening values for blocks in this data unit. Note that all generated 128-bit
; 113  : 		// whitening values are stored in memory as a sequence of 64-bit integers in reverse order.
; 114  : 		for (block = 0; block < endBlock; block++)

  0018e	c7 84 24 a8 02
	00 00 00 00 00
	00		 mov	 DWORD PTR block$[rsp], 0
  00199	eb 11		 jmp	 SHORT $LN22@EncryptBuf@5
$LN21@EncryptBuf@5:
  0019b	8b 84 24 a8 02
	00 00		 mov	 eax, DWORD PTR block$[rsp]
  001a2	83 c0 01	 add	 eax, 1
  001a5	89 84 24 a8 02
	00 00		 mov	 DWORD PTR block$[rsp], eax
$LN22@EncryptBuf@5:
  001ac	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  001b0	39 84 24 a8 02
	00 00		 cmp	 DWORD PTR block$[rsp], eax
  001b7	0f 83 6f 01 00
	00		 jae	 $LN20@EncryptBuf@5

; 115  : 		{
; 116  : 			if (block >= startBlock)

  001bd	8b 84 24 ac 02
	00 00		 mov	 eax, DWORD PTR startBlock$[rsp]
  001c4	39 84 24 a8 02
	00 00		 cmp	 DWORD PTR block$[rsp], eax
  001cb	72 6a		 jb	 SHORT $LN19@EncryptBuf@5

; 117  : 			{
; 118  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64++;

  001cd	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR whiteningValuesPtr64$[rsp]
  001d5	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  001dd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001e0	48 89 01	 mov	 QWORD PTR [rcx], rax
  001e3	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  001eb	48 83 e8 08	 sub	 rax, 8
  001ef	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax
  001f7	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  001ff	48 83 c0 08	 add	 rax, 8
  00203	48 89 84 24 68
	02 00 00	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax

; 119  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64;

  0020b	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR whiteningValuesPtr64$[rsp]
  00213	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  0021b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0021e	48 89 01	 mov	 QWORD PTR [rcx], rax
  00221	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  00229	48 83 e8 08	 sub	 rax, 8
  0022d	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax

; 120  : 			}
; 121  : 			else

  00235	eb 14		 jmp	 SHORT $LN18@EncryptBuf@5
$LN19@EncryptBuf@5:

; 122  : 				whiteningValuePtr64++;

  00237	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  0023f	48 83 c0 08	 add	 rax, 8
  00243	48 89 84 24 68
	02 00 00	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax
$LN18@EncryptBuf@5:

; 123  : 
; 124  : 			// Derive the next whitening value
; 125  : 
; 126  : #if BYTE_ORDER == LITTLE_ENDIAN
; 127  : 
; 128  : 			// Little-endian platforms
; 129  : 
; 130  : 			finalCarry = 
; 131  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 132  : 				135 : 0;

  0024b	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  00253	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  0025d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00260	48 23 c1	 and	 rax, rcx
  00263	48 85 c0	 test	 rax, rax
  00266	74 0d		 je	 SHORT $LN30@EncryptBuf@5
  00268	c7 84 24 d0 02
	00 00 87 00 00
	00		 mov	 DWORD PTR tv91[rsp], 135 ; 00000087H
  00273	eb 0b		 jmp	 SHORT $LN31@EncryptBuf@5
$LN30@EncryptBuf@5:
  00275	c7 84 24 d0 02
	00 00 00 00 00
	00		 mov	 DWORD PTR tv91[rsp], 0
$LN31@EncryptBuf@5:
  00280	0f b6 84 24 d0
	02 00 00	 movzx	 eax, BYTE PTR tv91[rsp]
  00288	88 84 24 98 02
	00 00		 mov	 BYTE PTR finalCarry$[rsp], al

; 133  : 
; 134  : 			*whiteningValuePtr64-- <<= 1;

  0028f	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  00297	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0029a	48 d1 e1	 shl	 rcx, 1
  0029d	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002a5	48 89 08	 mov	 QWORD PTR [rax], rcx
  002a8	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002b0	48 83 e8 08	 sub	 rax, 8
  002b4	48 89 84 24 68
	02 00 00	 mov	 QWORD PTR whiteningValuePtr64$[rsp], rax

; 135  : 
; 136  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  002bc	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002c4	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  002ce	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002d1	48 23 c1	 and	 rax, rcx
  002d4	48 85 c0	 test	 rax, rax
  002d7	74 1c		 je	 SHORT $LN17@EncryptBuf@5

; 137  : 				*(whiteningValuePtr64 + 1) |= 1;	

  002d9	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  002e1	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  002e5	48 83 c9 01	 or	 rcx, 1
  002e9	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  002f1	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
$LN17@EncryptBuf@5:

; 138  : 
; 139  : 			*whiteningValuePtr64 <<= 1;

  002f5	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR whiteningValuePtr64$[rsp]
  002fd	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00300	48 d1 e1	 shl	 rcx, 1
  00303	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR whiteningValuePtr64$[rsp]
  0030b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 140  : #else
; 141  : 
; 142  : 			// Big-endian platforms
; 143  : 
; 144  : 			finalCarry = 
; 145  : 				(*whiteningValuePtr64 & 0x80) ?
; 146  : 				135 : 0;
; 147  : 
; 148  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 149  : 
; 150  : 			whiteningValuePtr64--;
; 151  : 
; 152  : 			if (*whiteningValuePtr64 & 0x80)
; 153  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 154  : 
; 155  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 156  : #endif
; 157  : 
; 158  : 			whiteningValue[0] ^= finalCarry;

  0030e	0f b6 8c 24 98
	02 00 00	 movzx	 ecx, BYTE PTR finalCarry$[rsp]
  00316	0f b6 84 24 88
	02 00 00	 movzx	 eax, BYTE PTR whiteningValue$[rsp]
  0031e	33 c1		 xor	 eax, ecx
  00320	88 84 24 88 02
	00 00		 mov	 BYTE PTR whiteningValue$[rsp], al

; 159  : 		}

  00327	e9 6f fe ff ff	 jmp	 $LN21@EncryptBuf@5
$LN20@EncryptBuf@5:

; 160  : 
; 161  : 		dataUnitBufPtr = bufPtr;

  0032c	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  00334	48 89 84 24 58
	02 00 00	 mov	 QWORD PTR dataUnitBufPtr$[rsp], rax

; 162  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  0033c	48 8b 44 24 38	 mov	 rax, QWORD PTR finalInt64WhiteningValuesPtr$[rsp]
  00341	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax

; 163  : 
; 164  : 		// Encrypt all blocks in this data unit
; 165  : 
; 166  : 		for (block = startBlock; block < endBlock; block++)

  00349	8b 84 24 ac 02
	00 00		 mov	 eax, DWORD PTR startBlock$[rsp]
  00350	89 84 24 a8 02
	00 00		 mov	 DWORD PTR block$[rsp], eax
  00357	eb 11		 jmp	 SHORT $LN16@EncryptBuf@5
$LN15@EncryptBuf@5:
  00359	8b 84 24 a8 02
	00 00		 mov	 eax, DWORD PTR block$[rsp]
  00360	83 c0 01	 add	 eax, 1
  00363	89 84 24 a8 02
	00 00		 mov	 DWORD PTR block$[rsp], eax
$LN16@EncryptBuf@5:
  0036a	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  0036e	39 84 24 a8 02
	00 00		 cmp	 DWORD PTR block$[rsp], eax
  00375	0f 83 9d 00 00
	00		 jae	 $LN14@EncryptBuf@5

; 167  : 		{
; 168  : 			// Pre-whitening
; 169  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  0037b	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  00383	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  0038b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0038e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00391	48 33 c8	 xor	 rcx, rax
  00394	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  0039c	48 89 08	 mov	 QWORD PTR [rax], rcx
  0039f	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  003a7	48 83 e8 08	 sub	 rax, 8
  003ab	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax
  003b3	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  003bb	48 83 c0 08	 add	 rax, 8
  003bf	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR bufPtr$[rsp], rax

; 170  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  003c7	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  003cf	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  003d7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003da	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  003dd	48 33 c8	 xor	 rcx, rax
  003e0	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  003e8	48 89 08	 mov	 QWORD PTR [rax], rcx
  003eb	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  003f3	48 83 e8 08	 sub	 rax, 8
  003f7	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax
  003ff	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  00407	48 83 c0 08	 add	 rax, 8
  0040b	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR bufPtr$[rsp], rax

; 171  : 		}

  00413	e9 41 ff ff ff	 jmp	 $LN15@EncryptBuf@5
$LN14@EncryptBuf@5:

; 172  : 
; 173  : 		// Actual encryption
; 174  : 		EncipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);

  00418	8b 8c 24 ac 02
	00 00		 mov	 ecx, DWORD PTR startBlock$[rsp]
  0041f	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  00423	2b c1		 sub	 eax, ecx
  00425	44 8b c8	 mov	 r9d, eax
  00428	4c 8b 84 24 10
	03 00 00	 mov	 r8, QWORD PTR ks$[rsp]
  00430	48 8b 94 24 58
	02 00 00	 mov	 rdx, QWORD PTR dataUnitBufPtr$[rsp]
  00438	8b 8c 24 20 03
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  0043f	e8 00 00 00 00	 call	 EncipherBlocks

; 175  : 		
; 176  : 		bufPtr = dataUnitBufPtr;

  00444	4c 8b 9c 24 58
	02 00 00	 mov	 r11, QWORD PTR dataUnitBufPtr$[rsp]
  0044c	4c 89 9c 24 50
	02 00 00	 mov	 QWORD PTR bufPtr$[rsp], r11

; 177  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  00454	48 8b 44 24 38	 mov	 rax, QWORD PTR finalInt64WhiteningValuesPtr$[rsp]
  00459	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax

; 178  : 
; 179  : 		for (block = startBlock; block < endBlock; block++)

  00461	8b 84 24 ac 02
	00 00		 mov	 eax, DWORD PTR startBlock$[rsp]
  00468	89 84 24 a8 02
	00 00		 mov	 DWORD PTR block$[rsp], eax
  0046f	eb 11		 jmp	 SHORT $LN13@EncryptBuf@5
$LN12@EncryptBuf@5:
  00471	8b 84 24 a8 02
	00 00		 mov	 eax, DWORD PTR block$[rsp]
  00478	83 c0 01	 add	 eax, 1
  0047b	89 84 24 a8 02
	00 00		 mov	 DWORD PTR block$[rsp], eax
$LN13@EncryptBuf@5:
  00482	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  00486	39 84 24 a8 02
	00 00		 cmp	 DWORD PTR block$[rsp], eax
  0048d	0f 83 9d 00 00
	00		 jae	 $LN11@EncryptBuf@5

; 180  : 		{
; 181  : 			// Post-whitening
; 182  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00493	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  0049b	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  004a3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004a6	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  004a9	48 33 c8	 xor	 rcx, rax
  004ac	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  004b4	48 89 08	 mov	 QWORD PTR [rax], rcx
  004b7	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  004bf	48 83 e8 08	 sub	 rax, 8
  004c3	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax
  004cb	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  004d3	48 83 c0 08	 add	 rax, 8
  004d7	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR bufPtr$[rsp], rax

; 183  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  004df	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR bufPtr$[rsp]
  004e7	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  004ef	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004f2	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  004f5	48 33 c8	 xor	 rcx, rax
  004f8	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  00500	48 89 08	 mov	 QWORD PTR [rax], rcx
  00503	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR whiteningValuesPtr64$[rsp]
  0050b	48 83 e8 08	 sub	 rax, 8
  0050f	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR whiteningValuesPtr64$[rsp], rax
  00517	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR bufPtr$[rsp]
  0051f	48 83 c0 08	 add	 rax, 8
  00523	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR bufPtr$[rsp], rax

; 184  : 		}

  0052b	e9 41 ff ff ff	 jmp	 $LN12@EncryptBuf@5
$LN11@EncryptBuf@5:

; 185  : 
; 186  : 		blockCount -= endBlock - startBlock;

  00530	8b 8c 24 ac 02
	00 00		 mov	 ecx, DWORD PTR startBlock$[rsp]
  00537	8b 44 24 30	 mov	 eax, DWORD PTR endBlock$[rsp]
  0053b	2b c1		 sub	 eax, ecx
  0053d	8b c8		 mov	 ecx, eax
  0053f	48 8b 84 24 60
	02 00 00	 mov	 rax, QWORD PTR blockCount$[rsp]
  00547	48 2b c1	 sub	 rax, rcx
  0054a	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR blockCount$[rsp], rax

; 187  : 		startBlock = 0;

  00552	c7 84 24 ac 02
	00 00 00 00 00
	00		 mov	 DWORD PTR startBlock$[rsp], 0

; 188  : 		dataUnitNo++;

  0055d	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR dataUnitNo$[rsp]
  00565	48 83 c0 01	 add	 rax, 1
  00569	48 89 84 24 a0
	02 00 00	 mov	 QWORD PTR dataUnitNo$[rsp], rax

; 189  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);

  00571	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR dataUnitNo$[rsp]
  00579	48 89 84 24 78
	02 00 00	 mov	 QWORD PTR byteBufUnitNo$[rsp], rax

; 190  : 	}

  00581	e9 74 fb ff ff	 jmp	 $LN26@EncryptBuf@5
$LN25@EncryptBuf@5:
$LN10@EncryptBuf@5:

; 191  : 
; 192  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  00586	48 8d 84 24 88
	02 00 00	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  0058e	48 89 84 24 b8
	02 00 00	 mov	 QWORD PTR burnm$28599[rsp], rax
  00596	c7 84 24 b0 02
	00 00 02 00 00
	00		 mov	 DWORD PTR burnc$28601[rsp], 2
$LN7@EncryptBuf@5:
  005a1	8b 8c 24 b0 02
	00 00		 mov	 ecx, DWORD PTR burnc$28601[rsp]
  005a8	8b 84 24 b0 02
	00 00		 mov	 eax, DWORD PTR burnc$28601[rsp]
  005af	83 e8 01	 sub	 eax, 1
  005b2	89 84 24 b0 02
	00 00		 mov	 DWORD PTR burnc$28601[rsp], eax
  005b9	85 c9		 test	 ecx, ecx
  005bb	74 25		 je	 SHORT $LN6@EncryptBuf@5
  005bd	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR burnm$28599[rsp]
  005c5	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  005cc	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR burnm$28599[rsp]
  005d4	48 83 c0 08	 add	 rax, 8
  005d8	48 89 84 24 b8
	02 00 00	 mov	 QWORD PTR burnm$28599[rsp], rax
  005e0	eb bf		 jmp	 SHORT $LN7@EncryptBuf@5
$LN6@EncryptBuf@5:
  005e2	33 c0		 xor	 eax, eax
  005e4	85 c0		 test	 eax, eax
  005e6	75 9e		 jne	 SHORT $LN10@EncryptBuf@5
$LN5@EncryptBuf@5:

; 193  : 	FAST_ERASE64 (whiteningValues, sizeof (whiteningValues));

  005e8	48 8d 44 24 50	 lea	 rax, QWORD PTR whiteningValues$[rsp]
  005ed	48 89 84 24 c8
	02 00 00	 mov	 QWORD PTR burnm$28608[rsp], rax
  005f5	c7 84 24 c0 02
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$28610[rsp], 64 ; 00000040H
$LN2@EncryptBuf@5:
  00600	8b 8c 24 c0 02
	00 00		 mov	 ecx, DWORD PTR burnc$28610[rsp]
  00607	8b 84 24 c0 02
	00 00		 mov	 eax, DWORD PTR burnc$28610[rsp]
  0060e	83 e8 01	 sub	 eax, 1
  00611	89 84 24 c0 02
	00 00		 mov	 DWORD PTR burnc$28610[rsp], eax
  00618	85 c9		 test	 ecx, ecx
  0061a	74 25		 je	 SHORT $LN1@EncryptBuf@5
  0061c	48 8b 84 24 c8
	02 00 00	 mov	 rax, QWORD PTR burnm$28608[rsp]
  00624	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  0062b	48 8b 84 24 c8
	02 00 00	 mov	 rax, QWORD PTR burnm$28608[rsp]
  00633	48 83 c0 08	 add	 rax, 8
  00637	48 89 84 24 c8
	02 00 00	 mov	 QWORD PTR burnm$28608[rsp], rax
  0063f	eb bf		 jmp	 SHORT $LN2@EncryptBuf@5
$LN1@EncryptBuf@5:
  00641	33 c0		 xor	 eax, eax
  00643	85 c0		 test	 eax, eax
  00645	75 a1		 jne	 SHORT $LN5@EncryptBuf@5
$LN29@EncryptBuf@5:

; 194  : }

  00647	48 8b 8c 24 d8
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0064f	48 33 cc	 xor	 rcx, rsp
  00652	e8 00 00 00 00	 call	 __security_check_cookie
  00657	48 81 c4 e8 02
	00 00		 add	 rsp, 744		; 000002e8H
  0065e	c3		 ret	 0
EncryptBufferXTSParallel ENDP
_TEXT	ENDS
PUBLIC	EncryptBufferXTS
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptBufferXTS DD imagerel $LN5
	DD	imagerel $LN5+159
	DD	imagerel $unwind$EncryptBufferXTS
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptBufferXTS DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EncryptBufferXTS
_TEXT	SEGMENT
buffer$ = 80
length$ = 88
startDataUnitNo$ = 96
startCipherBlockNo$ = 104
ks$ = 112
ks2$ = 120
cipher$ = 128
EncryptBufferXTS PROC					; COMDAT

; 48   : {

$LN5:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 49   : 	if (CipherSupportsIntraDataUnitParallelization (cipher))

  00018	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  0001f	e8 00 00 00 00	 call	 CipherSupportsIntraDataUnitParallelization
  00024	85 c0		 test	 eax, eax
  00026	74 3a		 je	 SHORT $LN2@EncryptBuf@6

; 50   : 		EncryptBufferXTSParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  00028	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR cipher$[rsp]
  0002f	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00033	48 8b 44 24 78	 mov	 rax, QWORD PTR ks2$[rsp]
  00038	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0003d	48 8b 44 24 70	 mov	 rax, QWORD PTR ks$[rsp]
  00042	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00047	44 8b 4c 24 68	 mov	 r9d, DWORD PTR startCipherBlockNo$[rsp]
  0004c	4c 8b 44 24 60	 mov	 r8, QWORD PTR startDataUnitNo$[rsp]
  00051	48 8b 54 24 58	 mov	 rdx, QWORD PTR length$[rsp]
  00056	48 8b 4c 24 50	 mov	 rcx, QWORD PTR buffer$[rsp]
  0005b	e8 00 00 00 00	 call	 EncryptBufferXTSParallel

; 51   : 	else

  00060	eb 38		 jmp	 SHORT $LN1@EncryptBuf@6
$LN2@EncryptBuf@6:

; 52   : 		EncryptBufferXTSNonParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  00062	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR cipher$[rsp]
  00069	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0006d	48 8b 44 24 78	 mov	 rax, QWORD PTR ks2$[rsp]
  00072	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00077	48 8b 44 24 70	 mov	 rax, QWORD PTR ks$[rsp]
  0007c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00081	44 8b 4c 24 68	 mov	 r9d, DWORD PTR startCipherBlockNo$[rsp]
  00086	4c 8b 44 24 60	 mov	 r8, QWORD PTR startDataUnitNo$[rsp]
  0008b	48 8b 54 24 58	 mov	 rdx, QWORD PTR length$[rsp]
  00090	48 8b 4c 24 50	 mov	 rcx, QWORD PTR buffer$[rsp]
  00095	e8 00 00 00 00	 call	 EncryptBufferXTSNonParallel
$LN1@EncryptBuf@6:

; 53   : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
EncryptBufferXTS ENDP
END
