; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	cacheEmpty
COMM	CachedPasswords:BYTE:0120H
nPasswordIdx DD	01H DUP (?)
cacheEmpty DD	01H
PUBLIC	$T43908
PUBLIC	AddPasswordToCache
EXTRN	memcmp:PROC
;	COMDAT pdata
; File c:\home\public\desktop\projects\ciphershed.build\src\common\cache.c
pdata	SEGMENT
$pdata$AddPasswordToCache DD imagerel $LN7
	DD	imagerel $LN7+182
	DD	imagerel $unwind$AddPasswordToCache
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AddPasswordToCache DD 030b01H
	DD	07007e20bH
	DD	06006H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT AddPasswordToCache
_TEXT	SEGMENT
i$ = 32
$T43908 = 40
password$ = 144
AddPasswordToCache PROC					; COMDAT

; 75   : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 76   : 	int i;
; 77   : 	for (i = 0; i < CACHE_SIZE; i++)

  0000b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00013	eb 0b		 jmp	 SHORT $LN4@AddPasswor
$LN3@AddPasswor:
  00015	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00019	83 c0 01	 add	 eax, 1
  0001c	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@AddPasswor:
  00020	83 7c 24 20 04	 cmp	 DWORD PTR i$[rsp], 4
  00025	7d 2e		 jge	 SHORT $LN2@AddPasswor

; 78   : 	{
; 79   : 		if (memcmp (&CachedPasswords[i], password, sizeof (Password)) == 0)

  00027	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0002c	48 6b c0 48	 imul	 rax, 72			; 00000048H
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CachedPasswords
  00037	48 03 c8	 add	 rcx, rax
  0003a	41 b8 48 00 00
	00		 mov	 r8d, 72			; 00000048H
  00040	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR password$[rsp]
  00048	e8 00 00 00 00	 call	 memcmp
  0004d	85 c0		 test	 eax, eax
  0004f	75 02		 jne	 SHORT $LN1@AddPasswor

; 80   : 			return;

  00051	eb 5c		 jmp	 SHORT $LN5@AddPasswor
$LN1@AddPasswor:

; 81   : 	}

  00053	eb c0		 jmp	 SHORT $LN3@AddPasswor
$LN2@AddPasswor:

; 82   : 
; 83   : 	CachedPasswords[nPasswordIdx] = *password;

  00055	48 8d 7c 24 28	 lea	 rdi, QWORD PTR $T43908[rsp]
  0005a	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR password$[rsp]
  00062	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00067	f3 a4		 rep movsb
  00069	48 63 0d 00 00
	00 00		 movsxd	 rcx, DWORD PTR nPasswordIdx
  00070	48 6b c9 48	 imul	 rcx, 72			; 00000048H
  00074	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:CachedPasswords
  0007b	48 8d 74 24 28	 lea	 rsi, QWORD PTR $T43908[rsp]
  00080	48 8d 3c 08	 lea	 rdi, QWORD PTR [rax+rcx]
  00084	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00089	f3 a4		 rep movsb

; 84   : 	nPasswordIdx = (nPasswordIdx + 1) % CACHE_SIZE;

  0008b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nPasswordIdx
  00091	83 c0 01	 add	 eax, 1
  00094	99		 cdq
  00095	83 e2 03	 and	 edx, 3
  00098	03 c2		 add	 eax, edx
  0009a	83 e0 03	 and	 eax, 3
  0009d	2b c2		 sub	 eax, edx
  0009f	89 05 00 00 00
	00		 mov	 DWORD PTR nPasswordIdx, eax

; 85   : 	cacheEmpty = 0;

  000a5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR cacheEmpty, 0
$LN5@AddPasswor:

; 86   : }

  000af	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000b3	5f		 pop	 rdi
  000b4	5e		 pop	 rsi
  000b5	c3		 ret	 0
AddPasswordToCache ENDP
PUBLIC	WipeCache
;	COMDAT pdata
pdata	SEGMENT
$pdata$WipeCache DD imagerel $LN8
	DD	imagerel $LN8+115
	DD	imagerel $unwind$WipeCache
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$WipeCache DD 010401H
	DD	06204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT WipeCache
_TEXT	SEGMENT
burnc$28810 = 32
burnm$28808 = 40
WipeCache PROC						; COMDAT

; 90   : {

$LN8:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN5@WipeCache:

; 91   : 	burn (CachedPasswords, sizeof (CachedPasswords));

  00004	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:CachedPasswords
  0000b	48 89 44 24 28	 mov	 QWORD PTR burnm$28808[rsp], rax
  00010	c7 44 24 20 20
	01 00 00	 mov	 DWORD PTR burnc$28810[rsp], 288 ; 00000120H
  00018	ba 20 01 00 00	 mov	 edx, 288		; 00000120H
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CachedPasswords
  00024	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN2@WipeCache:
  00029	8b 4c 24 20	 mov	 ecx, DWORD PTR burnc$28810[rsp]
  0002d	8b 44 24 20	 mov	 eax, DWORD PTR burnc$28810[rsp]
  00031	83 e8 01	 sub	 eax, 1
  00034	89 44 24 20	 mov	 DWORD PTR burnc$28810[rsp], eax
  00038	85 c9		 test	 ecx, ecx
  0003a	74 18		 je	 SHORT $LN1@WipeCache
  0003c	48 8b 44 24 28	 mov	 rax, QWORD PTR burnm$28808[rsp]
  00041	c6 00 00	 mov	 BYTE PTR [rax], 0
  00044	48 8b 44 24 28	 mov	 rax, QWORD PTR burnm$28808[rsp]
  00049	48 83 c0 01	 add	 rax, 1
  0004d	48 89 44 24 28	 mov	 QWORD PTR burnm$28808[rsp], rax
  00052	eb d5		 jmp	 SHORT $LN2@WipeCache
$LN1@WipeCache:
  00054	33 c0		 xor	 eax, eax
  00056	85 c0		 test	 eax, eax
  00058	75 aa		 jne	 SHORT $LN5@WipeCache

; 92   : 	nPasswordIdx = 0;

  0005a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR nPasswordIdx, 0

; 93   : 	cacheEmpty = 1;

  00064	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR cacheEmpty, 1

; 94   : }

  0006e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00072	c3		 ret	 0
WipeCache ENDP
PUBLIC	$T46136
PUBLIC	ReadVolumeHeaderWCache
;	COMDAT pdata
pdata	SEGMENT
$pdata$ReadVolumeHeaderWCache DD imagerel $LN18
	DD	imagerel $LN18+453
	DD	imagerel $unwind$ReadVolumeHeaderWCache
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ReadVolumeHeaderWCache DD 041b01H
	DD	011011bH
	DD	060137014H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ReadVolumeHeaderWCache
_TEXT	SEGMENT
nReturnCode$ = 48
i$ = 52
$T46136 = 56
bBoot$ = 160
bCache$ = 168
header$ = 176
password$ = 184
retInfo$ = 192
ReadVolumeHeaderWCache PROC				; COMDAT

; 25   : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	56		 push	 rsi
  00013	57		 push	 rdi
  00014	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 26   : 	int nReturnCode = ERR_PASSWORD_WRONG;

  0001b	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR nReturnCode$[rsp], 3

; 27   : 	int i;
; 28   : 
; 29   : 	/* Attempt to recognize volume using mount password */
; 30   : 	if (password->Length > 0)

  00023	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR password$[rsp]
  0002b	83 38 00	 cmp	 DWORD PTR [rax], 0
  0002e	0f 86 01 01 00
	00		 jbe	 $LN15@ReadVolume@2

; 31   : 	{
; 32   : 		nReturnCode = ReadVolumeHeader (bBoot, header, password, retInfo, NULL);

  00034	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0003d	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR retInfo$[rsp]
  00045	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR password$[rsp]
  0004d	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR header$[rsp]
  00055	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR bBoot$[rsp]
  0005c	e8 00 00 00 00	 call	 ReadVolumeHeader
  00061	89 44 24 30	 mov	 DWORD PTR nReturnCode$[rsp], eax

; 33   : 
; 34   : 		/* Save mount passwords back into cache if asked to do so */
; 35   : 		if (bCache && (nReturnCode == 0 || nReturnCode == ERR_CIPHER_INIT_WEAK_KEY))

  00065	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR bCache$[rsp], 0
  0006d	0f 84 bd 00 00
	00		 je	 $LN14@ReadVolume@2
  00073	83 7c 24 30 00	 cmp	 DWORD PTR nReturnCode$[rsp], 0
  00078	74 0b		 je	 SHORT $LN13@ReadVolume@2
  0007a	83 7c 24 30 12	 cmp	 DWORD PTR nReturnCode$[rsp], 18
  0007f	0f 85 ab 00 00
	00		 jne	 $LN14@ReadVolume@2
$LN13@ReadVolume@2:

; 36   : 		{
; 37   : 			for (i = 0; i < CACHE_SIZE; i++)

  00085	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0008d	eb 0b		 jmp	 SHORT $LN12@ReadVolume@2
$LN11@ReadVolume@2:
  0008f	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00093	83 c0 01	 add	 eax, 1
  00096	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN12@ReadVolume@2:
  0009a	83 7c 24 34 04	 cmp	 DWORD PTR i$[rsp], 4
  0009f	7d 2e		 jge	 SHORT $LN10@ReadVolume@2

; 38   : 			{
; 39   : 				if (memcmp (&CachedPasswords[i], password, sizeof (Password)) == 0)

  000a1	48 63 44 24 34	 movsxd	 rax, DWORD PTR i$[rsp]
  000a6	48 6b c0 48	 imul	 rax, 72			; 00000048H
  000aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CachedPasswords
  000b1	48 03 c8	 add	 rcx, rax
  000b4	41 b8 48 00 00
	00		 mov	 r8d, 72			; 00000048H
  000ba	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR password$[rsp]
  000c2	e8 00 00 00 00	 call	 memcmp
  000c7	85 c0		 test	 eax, eax
  000c9	75 02		 jne	 SHORT $LN9@ReadVolume@2

; 40   : 					break;

  000cb	eb 02		 jmp	 SHORT $LN10@ReadVolume@2
$LN9@ReadVolume@2:

; 41   : 			}

  000cd	eb c0		 jmp	 SHORT $LN11@ReadVolume@2
$LN10@ReadVolume@2:

; 42   : 
; 43   : 			if (i == CACHE_SIZE)

  000cf	83 7c 24 34 04	 cmp	 DWORD PTR i$[rsp], 4
  000d4	75 5a		 jne	 SHORT $LN8@ReadVolume@2

; 44   : 			{
; 45   : 				/* Store the password */
; 46   : 				CachedPasswords[nPasswordIdx] = *password;

  000d6	48 8d 7c 24 38	 lea	 rdi, QWORD PTR $T46136[rsp]
  000db	48 8b b4 24 b8
	00 00 00	 mov	 rsi, QWORD PTR password$[rsp]
  000e3	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  000e8	f3 a4		 rep movsb
  000ea	48 63 0d 00 00
	00 00		 movsxd	 rcx, DWORD PTR nPasswordIdx
  000f1	48 6b c9 48	 imul	 rcx, 72			; 00000048H
  000f5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:CachedPasswords
  000fc	48 8d 74 24 38	 lea	 rsi, QWORD PTR $T46136[rsp]
  00101	48 8d 3c 08	 lea	 rdi, QWORD PTR [rax+rcx]
  00105	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  0010a	f3 a4		 rep movsb

; 47   : 
; 48   : 				/* Try another slot */
; 49   : 				nPasswordIdx = (nPasswordIdx + 1) % CACHE_SIZE;

  0010c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nPasswordIdx
  00112	83 c0 01	 add	 eax, 1
  00115	99		 cdq
  00116	83 e2 03	 and	 edx, 3
  00119	03 c2		 add	 eax, edx
  0011b	83 e0 03	 and	 eax, 3
  0011e	2b c2		 sub	 eax, edx
  00120	89 05 00 00 00
	00		 mov	 DWORD PTR nPasswordIdx, eax

; 50   : 
; 51   : 				cacheEmpty = 0;

  00126	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR cacheEmpty, 0
$LN8@ReadVolume@2:
$LN14@ReadVolume@2:

; 52   : 			}
; 53   : 		}

  00130	e9 82 00 00 00	 jmp	 $LN7@ReadVolume@2
$LN15@ReadVolume@2:

; 54   : 	}
; 55   : 	else if (!cacheEmpty)

  00135	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR cacheEmpty, 0
  0013c	75 79		 jne	 SHORT $LN6@ReadVolume@2

; 56   : 	{
; 57   : 		/* Attempt to recognize volume using cached passwords */
; 58   : 		for (i = 0; i < CACHE_SIZE; i++)

  0013e	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00146	eb 0b		 jmp	 SHORT $LN5@ReadVolume@2
$LN4@ReadVolume@2:
  00148	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  0014c	83 c0 01	 add	 eax, 1
  0014f	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN5@ReadVolume@2:
  00153	83 7c 24 34 04	 cmp	 DWORD PTR i$[rsp], 4
  00158	7d 5d		 jge	 SHORT $LN3@ReadVolume@2

; 59   : 		{
; 60   : 			if (CachedPasswords[i].Length > 0)

  0015a	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR i$[rsp]
  0015f	48 6b c9 48	 imul	 rcx, 72			; 00000048H
  00163	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:CachedPasswords
  0016a	83 3c 08 00	 cmp	 DWORD PTR [rax+rcx], 0
  0016e	76 45		 jbe	 SHORT $LN2@ReadVolume@2

; 61   : 			{
; 62   : 				nReturnCode = ReadVolumeHeader (bBoot, header, &CachedPasswords[i], retInfo, NULL);

  00170	48 63 44 24 34	 movsxd	 rax, DWORD PTR i$[rsp]
  00175	48 6b c0 48	 imul	 rax, 72			; 00000048H
  00179	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:CachedPasswords
  00180	4c 03 c0	 add	 r8, rax
  00183	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0018c	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR retInfo$[rsp]
  00194	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR header$[rsp]
  0019c	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR bBoot$[rsp]
  001a3	e8 00 00 00 00	 call	 ReadVolumeHeader
  001a8	89 44 24 30	 mov	 DWORD PTR nReturnCode$[rsp], eax

; 63   : 
; 64   : 				if (nReturnCode != ERR_PASSWORD_WRONG)

  001ac	83 7c 24 30 03	 cmp	 DWORD PTR nReturnCode$[rsp], 3
  001b1	74 02		 je	 SHORT $LN1@ReadVolume@2

; 65   : 					break;

  001b3	eb 02		 jmp	 SHORT $LN3@ReadVolume@2
$LN1@ReadVolume@2:
$LN2@ReadVolume@2:

; 66   : 			}
; 67   : 		}

  001b5	eb 91		 jmp	 SHORT $LN4@ReadVolume@2
$LN3@ReadVolume@2:
$LN6@ReadVolume@2:
$LN7@ReadVolume@2:

; 68   : 	}
; 69   : 
; 70   : 	return nReturnCode;

  001b7	8b 44 24 30	 mov	 eax, DWORD PTR nReturnCode$[rsp]

; 71   : }

  001bb	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001c2	5f		 pop	 rdi
  001c3	5e		 pop	 rsi
  001c4	c3		 ret	 0
ReadVolumeHeaderWCache ENDP
END
