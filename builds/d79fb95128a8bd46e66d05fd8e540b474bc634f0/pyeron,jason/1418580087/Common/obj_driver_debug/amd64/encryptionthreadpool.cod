; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	ExInitializeFastMutex
EXTRN	__imp_ExAcquireFastMutex:PROC
EXTRN	__imp_ExReleaseFastMutex:PROC
ThreadPoolRunning DD 01H DUP (?)
StopPending DD	01H DUP (?)
PUBLIC	IsEncryptionThreadPoolRunning
; Function compile flags: /Odtp
; File c:\home\public\desktop\projects\ciphershed.build\src\common\encryptionthreadpool.c
;	COMDAT IsEncryptionThreadPoolRunning
_TEXT	SEGMENT
IsEncryptionThreadPoolRunning PROC			; COMDAT

; 506  : 	return ThreadPoolRunning;

  00000	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ThreadPoolRunning

; 507  : }

  00006	c3		 ret	 0
IsEncryptionThreadPoolRunning ENDP
_TEXT	ENDS
PUBLIC	GetEncryptionThreadCount
ThreadCount DD	01H DUP (?)
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetEncryptionThreadCount DD imagerel $LN5
	DD	imagerel $LN5+40
	DD	imagerel $unwind$GetEncryptionThreadCount
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetEncryptionThreadCount DD 010401H
	DD	02204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GetEncryptionThreadCount
_TEXT	SEGMENT
tv66 = 0
GetEncryptionThreadCount PROC				; COMDAT

; 493  : {

$LN5:
  00000	48 83 ec 18	 sub	 rsp, 24

; 494  : 	return ThreadPoolRunning ? ThreadCount : 0;

  00004	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ThreadPoolRunning
  0000a	85 c0		 test	 eax, eax
  0000c	74 0b		 je	 SHORT $LN3@GetEncrypt
  0000e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ThreadCount
  00014	89 04 24	 mov	 DWORD PTR tv66[rsp], eax
  00017	eb 07		 jmp	 SHORT $LN4@GetEncrypt
$LN3@GetEncrypt:
  00019	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv66[rsp], 0
$LN4@GetEncrypt:
  00020	8b 04 24	 mov	 eax, DWORD PTR tv66[rsp]

; 495  : }

  00023	48 83 c4 18	 add	 rsp, 24
  00027	c3		 ret	 0
GetEncryptionThreadCount ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT SetWorkItemState
_TEXT	SEGMENT
workItem$ = 8
newState$ = 16
SetWorkItemState PROC					; COMDAT

; 118  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 119  : 	InterlockedExchange ((LONG *) &workItem->State, (LONG) newState);

  00009	8b 4c 24 10	 mov	 ecx, DWORD PTR newState$[rsp]
  0000d	48 8b 44 24 08	 mov	 rax, QWORD PTR workItem$[rsp]
  00012	87 08		 xchg	 DWORD PTR [rax], ecx

; 120  : }

  00014	c3		 ret	 0
SetWorkItemState ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT GetWorkItemState
_TEXT	SEGMENT
workItem$ = 8
GetWorkItemState PROC					; COMDAT

; 112  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 113  : 	return InterlockedExchangeAdd ((LONG *) &workItem->State, 0);

  00005	33 c9		 xor	 ecx, ecx
  00007	48 8b 44 24 08	 mov	 rax, QWORD PTR workItem$[rsp]
  0000c	f0 0f c1 08	 lock xadd DWORD PTR [rax], ecx
  00010	8b c1		 mov	 eax, ecx

; 114  : }

  00012	c3		 ret	 0
GetWorkItemState ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$ExInitializeFastMutex DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$ExInitializeFastMutex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ExInitializeFastMutex DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ExInitializeFastMutex
_TEXT	SEGMENT
FastMutex$ = 48
ExInitializeFastMutex PROC				; COMDAT

; 16362: {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 16363: 
; 16364:     FastMutex->Count = FM_LOCK_BIT;

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR FastMutex$[rsp]
  0000e	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 16365:     FastMutex->Owner = NULL;

  00014	48 8b 44 24 30	 mov	 rax, QWORD PTR FastMutex$[rsp]
  00019	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 16366:     FastMutex->Contention = 0;

  00021	48 8b 44 24 30	 mov	 rax, QWORD PTR FastMutex$[rsp]
  00026	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 16367:     KeInitializeEvent(&FastMutex->Event, SynchronizationEvent, FALSE);

  0002d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR FastMutex$[rsp]
  00032	48 83 c1 18	 add	 rcx, 24
  00036	45 33 c0	 xor	 r8d, r8d
  00039	ba 01 00 00 00	 mov	 edx, 1
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 16368:     return;
; 16369: }

  00044	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00048	c3		 ret	 0
ExInitializeFastMutex ENDP
PUBLIC	EncryptionThreadPoolBeginKeyDerivation
WorkItemReadyEvent DB 018H DUP (?)
WorkItemCompletedEvent DB 018H DUP (?)
WorkItemQueue DB 03c00H DUP (?)
EnqueuePosition DD 01H DUP (?)
EnqueueMutex DB	038H DUP (?)
;	COMDAT pdata
; File c:\home\public\desktop\projects\ciphershed.build\src\common\encryptionthreadpool.c
pdata	SEGMENT
$pdata$EncryptionThreadPoolBeginKeyDerivation DD imagerel $LN7
	DD	imagerel $LN7+423
	DD	imagerel $unwind$EncryptionThreadPoolBeginKeyDerivation
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptionThreadPoolBeginKeyDerivation DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EncryptionThreadPoolBeginKeyDerivation
_TEXT	SEGMENT
workItem$ = 48
completionEvent$ = 80
noOutstandingWorkItemEvent$ = 88
completionFlag$ = 96
outstandingWorkItemCount$ = 104
pkcs5Prf$ = 112
password$ = 120
passwordLength$ = 128
salt$ = 136
iterationCount$ = 144
derivedKey$ = 152
EncryptionThreadPoolBeginKeyDerivation PROC		; COMDAT

; 350  : {

$LN7:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 351  : 	EncryptionThreadPoolWorkItem *workItem;
; 352  : 
; 353  : 	if (!ThreadPoolRunning)

  00018	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ThreadPoolRunning
  0001e	85 c0		 test	 eax, eax
  00020	75 1f		 jne	 SHORT $LN4@Encryption

; 354  : 		TC_THROW_FATAL_EXCEPTION;

  00022	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  0002b	45 33 c9	 xor	 r9d, r9d
  0002e	45 33 c0	 xor	 r8d, r8d
  00031	ba 62 01 00 00	 mov	 edx, 354		; 00000162H
  00036	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN4@Encryption:

; 355  : 
; 356  : 	TC_ACQUIRE_MUTEX (&EnqueueMutex);

  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EnqueueMutex
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAcquireFastMutex

; 357  : 
; 358  : 	workItem = &WorkItemQueue[EnqueuePosition++];

  0004e	44 8b 1d 00 00
	00 00		 mov	 r11d, DWORD PTR EnqueuePosition
  00055	49 63 cb	 movsxd	 rcx, r11d
  00058	48 6b c9 78	 imul	 rcx, 120		; 00000078H
  0005c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:WorkItemQueue
  00063	48 03 c1	 add	 rax, rcx
  00066	48 89 44 24 30	 mov	 QWORD PTR workItem$[rsp], rax
  0006b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR EnqueuePosition
  00071	83 c0 01	 add	 eax, 1
  00074	89 05 00 00 00
	00		 mov	 DWORD PTR EnqueuePosition, eax

; 359  : 	if (EnqueuePosition >= TC_ENC_THREAD_POOL_QUEUE_SIZE)

  0007a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR EnqueuePosition
  00080	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00085	7c 0a		 jl	 SHORT $LN3@Encryption

; 360  : 		EnqueuePosition = 0;

  00087	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR EnqueuePosition, 0
$LN3@Encryption:
$LN2@Encryption:

; 361  : 
; 362  : 	while (GetWorkItemState (workItem) != WorkItemFree)

  00091	48 8b 4c 24 30	 mov	 rcx, QWORD PTR workItem$[rsp]
  00096	e8 00 00 00 00	 call	 GetWorkItemState
  0009b	85 c0		 test	 eax, eax
  0009d	74 20		 je	 SHORT $LN1@Encryption

; 363  : 	{
; 364  : 		TC_WAIT_EVENT (WorkItemCompletedEvent);

  0009f	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000a8	45 33 c9	 xor	 r9d, r9d
  000ab	45 33 c0	 xor	 r8d, r8d
  000ae	33 d2		 xor	 edx, edx
  000b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemCompletedEvent
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 365  : 	}

  000bd	eb d2		 jmp	 SHORT $LN2@Encryption
$LN1@Encryption:

; 366  : 
; 367  : 	workItem->Type = DeriveKeyWork;

  000bf	48 8b 44 24 30	 mov	 rax, QWORD PTR workItem$[rsp]
  000c4	c7 40 04 02 00
	00 00		 mov	 DWORD PTR [rax+4], 2

; 368  : 	workItem->KeyDerivation.CompletionEvent = completionEvent;

  000cb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR workItem$[rsp]
  000d0	48 8b 44 24 50	 mov	 rax, QWORD PTR completionEvent$[rsp]
  000d5	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 369  : 	workItem->KeyDerivation.CompletionFlag = completionFlag;

  000d9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR workItem$[rsp]
  000de	48 8b 44 24 60	 mov	 rax, QWORD PTR completionFlag$[rsp]
  000e3	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 370  : 	workItem->KeyDerivation.DerivedKey = derivedKey;

  000e7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR workItem$[rsp]
  000ec	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR derivedKey$[rsp]
  000f4	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax

; 371  : 	workItem->KeyDerivation.IterationCount = iterationCount;

  000f8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR workItem$[rsp]
  000fd	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR iterationCount$[rsp]
  00104	89 41 48	 mov	 DWORD PTR [rcx+72], eax

; 372  : 	workItem->KeyDerivation.NoOutstandingWorkItemEvent = noOutstandingWorkItemEvent;

  00107	48 8b 4c 24 30	 mov	 rcx, QWORD PTR workItem$[rsp]
  0010c	48 8b 44 24 58	 mov	 rax, QWORD PTR noOutstandingWorkItemEvent$[rsp]
  00111	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax

; 373  : 	workItem->KeyDerivation.OutstandingWorkItemCount = outstandingWorkItemCount;

  00115	48 8b 4c 24 30	 mov	 rcx, QWORD PTR workItem$[rsp]
  0011a	48 8b 44 24 68	 mov	 rax, QWORD PTR outstandingWorkItemCount$[rsp]
  0011f	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax

; 374  : 	workItem->KeyDerivation.Password = password;

  00123	48 8b 4c 24 30	 mov	 rcx, QWORD PTR workItem$[rsp]
  00128	48 8b 44 24 78	 mov	 rax, QWORD PTR password$[rsp]
  0012d	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 375  : 	workItem->KeyDerivation.PasswordLength = passwordLength;

  00131	48 8b 4c 24 30	 mov	 rcx, QWORD PTR workItem$[rsp]
  00136	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR passwordLength$[rsp]
  0013d	89 41 68	 mov	 DWORD PTR [rcx+104], eax

; 376  : 	workItem->KeyDerivation.Pkcs5Prf = pkcs5Prf;

  00140	48 8b 4c 24 30	 mov	 rcx, QWORD PTR workItem$[rsp]
  00145	8b 44 24 70	 mov	 eax, DWORD PTR pkcs5Prf$[rsp]
  00149	89 41 6c	 mov	 DWORD PTR [rcx+108], eax

; 377  : 	workItem->KeyDerivation.Salt = salt;

  0014c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR workItem$[rsp]
  00151	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR salt$[rsp]
  00159	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 378  : 
; 379  : 	InterlockedIncrement (outstandingWorkItemCount);

  0015d	48 8b 44 24 68	 mov	 rax, QWORD PTR outstandingWorkItemCount$[rsp]
  00162	f0 83 00 01	 lock add DWORD PTR [rax], 1

; 380  : 	TC_CLEAR_EVENT (*noOutstandingWorkItemEvent);

  00166	48 8b 4c 24 58	 mov	 rcx, QWORD PTR noOutstandingWorkItemEvent$[rsp]
  0016b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeClearEvent

; 381  : 
; 382  : 	SetWorkItemState (workItem, WorkItemReady);

  00171	ba 01 00 00 00	 mov	 edx, 1
  00176	48 8b 4c 24 30	 mov	 rcx, QWORD PTR workItem$[rsp]
  0017b	e8 00 00 00 00	 call	 SetWorkItemState

; 383  : 	TC_SET_EVENT (WorkItemReadyEvent);

  00180	45 33 c0	 xor	 r8d, r8d
  00183	ba 01 00 00 00	 mov	 edx, 1
  00188	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemReadyEvent
  0018f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 384  : 	TC_RELEASE_MUTEX (&EnqueueMutex);

  00195	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EnqueueMutex
  0019c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExReleaseFastMutex
$LN6@Encryption:

; 385  : }

  001a2	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001a6	c3		 ret	 0
EncryptionThreadPoolBeginKeyDerivation ENDP
_TEXT	ENDS
PUBLIC	EncryptionThreadPoolStop
ThreadHandles DQ 040H DUP (?)
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptionThreadPoolStop DD imagerel $LN7
	DD	imagerel $LN7+140
	DD	imagerel $unwind$EncryptionThreadPoolStop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptionThreadPoolStop DD 010401H
	DD	06204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EncryptionThreadPoolStop
_TEXT	SEGMENT
i$ = 32
EncryptionThreadPoolStop PROC				; COMDAT

; 311  : {

$LN7:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 312  : 	size_t i;
; 313  : 
; 314  : 	if (!ThreadPoolRunning)

  00004	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ThreadPoolRunning
  0000a	85 c0		 test	 eax, eax
  0000c	75 02		 jne	 SHORT $LN4@Encryption@2

; 315  : 		return;

  0000e	eb 77		 jmp	 SHORT $LN5@Encryption@2
$LN4@Encryption@2:

; 316  : 
; 317  : 	StopPending = TRUE;

  00010	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR StopPending, 1

; 318  : 	TC_SET_EVENT (WorkItemReadyEvent);

  0001a	45 33 c0	 xor	 r8d, r8d
  0001d	ba 01 00 00 00	 mov	 edx, 1
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemReadyEvent
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 319  : 
; 320  : 	for (i = 0; i < ThreadCount; ++i)

  0002f	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00038	eb 0e		 jmp	 SHORT $LN3@Encryption@2
$LN2@Encryption@2:
  0003a	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0003f	48 83 c0 01	 add	 rax, 1
  00043	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN3@Encryption@2:
  00048	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ThreadCount
  0004e	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00053	73 1e		 jae	 SHORT $LN1@Encryption@2

; 321  : 	{
; 322  : #ifdef DEVICE_DRIVER
; 323  : 		TCStopThread (ThreadHandles[i], &WorkItemReadyEvent);

  00055	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ThreadHandles
  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:WorkItemReadyEvent
  00063	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00068	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  0006c	e8 00 00 00 00	 call	 TCStopThread

; 324  : #else
; 325  : 		TC_WAIT_EVENT (ThreadHandles[i]);
; 326  : #endif
; 327  : 	}

  00071	eb c7		 jmp	 SHORT $LN2@Encryption@2
$LN1@Encryption@2:

; 328  : 
; 329  : 	ThreadCount = 0;

  00073	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ThreadCount, 0

; 330  : 
; 331  : #ifndef DEVICE_DRIVER
; 332  : 	CloseHandle (DequeueMutex);
; 333  : 	CloseHandle (EnqueueMutex);
; 334  : 
; 335  : 	CloseHandle (WorkItemReadyEvent);
; 336  : 	CloseHandle (WorkItemCompletedEvent);
; 337  : 
; 338  : 	for (i = 0; i < sizeof (WorkItemQueue) / sizeof (WorkItemQueue[0]); ++i)
; 339  : 	{
; 340  : 		if (WorkItemQueue[i].ItemCompletedEvent)
; 341  : 			CloseHandle (WorkItemQueue[i].ItemCompletedEvent);
; 342  : 	}
; 343  : #endif
; 344  : 
; 345  : 	ThreadPoolRunning = FALSE;

  0007d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ThreadPoolRunning, 0
$LN5@Encryption@2:

; 346  : }

  00087	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008b	c3		 ret	 0
EncryptionThreadPoolStop ENDP
PUBLIC	EncryptionThreadPoolDoWork
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptionThreadPoolDoWork DD imagerel $LN22
	DD	imagerel $LN22+865
	DD	imagerel $unwind$EncryptionThreadPoolDoWork
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptionThreadPoolDoWork DD 011701H
	DD	0e217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EncryptionThreadPoolDoWork
_TEXT	SEGMENT
remainder$ = 48
workItem$ = 56
unitsPerFragment$ = 64
fragmentCount$ = 68
fragmentData$ = 72
fragmentStartUnitNo$ = 80
firstFragmentWorkItem$ = 88
tv68 = 96
type$ = 128
data$ = 136
startUnitNo$ = 144
unitCount$ = 152
cryptoInfo$ = 160
EncryptionThreadPoolDoWork PROC				; COMDAT

; 389  : {

$LN22:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 390  : 	uint32 fragmentCount;
; 391  : 	uint32 unitsPerFragment;
; 392  : 	uint32 remainder;
; 393  : 
; 394  : 	byte *fragmentData;
; 395  : 	uint64 fragmentStartUnitNo;
; 396  : 
; 397  : 	EncryptionThreadPoolWorkItem *workItem;
; 398  : 	EncryptionThreadPoolWorkItem *firstFragmentWorkItem;
; 399  : 	
; 400  : 	if (unitCount == 0)

  00017	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR unitCount$[rsp], 0
  0001f	75 05		 jne	 SHORT $LN19@Encryption@3

; 401  : 		return;

  00021	e9 36 03 00 00	 jmp	 $LN20@Encryption@3
$LN19@Encryption@3:

; 402  : 	
; 403  : 	if (!ThreadPoolRunning || unitCount == 1)

  00026	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ThreadPoolRunning
  0002c	85 c0		 test	 eax, eax
  0002e	74 0e		 je	 SHORT $LN17@Encryption@3
  00030	83 bc 24 98 00
	00 00 01	 cmp	 DWORD PTR unitCount$[rsp], 1
  00038	0f 85 8d 00 00
	00		 jne	 $LN18@Encryption@3
$LN17@Encryption@3:

; 404  : 	{
; 405  : 		switch (type)

  0003e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR type$[rsp]
  00045	89 44 24 60	 mov	 DWORD PTR tv68[rsp], eax
  00049	83 7c 24 60 00	 cmp	 DWORD PTR tv68[rsp], 0
  0004e	74 30		 je	 SHORT $LN13@Encryption@3
  00050	83 7c 24 60 01	 cmp	 DWORD PTR tv68[rsp], 1
  00055	74 02		 je	 SHORT $LN14@Encryption@3
  00057	eb 4e		 jmp	 SHORT $LN12@Encryption@3
$LN14@Encryption@3:

; 406  : 		{
; 407  : 		case DecryptDataUnitsWork:
; 408  : 			DecryptDataUnitsCurrentThread (data, startUnitNo, unitCount, cryptoInfo);

  00059	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR unitCount$[rsp]
  00061	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR cryptoInfo$[rsp]
  00069	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR startUnitNo$[rsp]
  00071	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00079	e8 00 00 00 00	 call	 DecryptDataUnitsCurrentThread

; 409  : 			break;

  0007e	eb 46		 jmp	 SHORT $LN15@Encryption@3
$LN13@Encryption@3:

; 410  : 
; 411  : 		case EncryptDataUnitsWork:
; 412  : 			EncryptDataUnitsCurrentThread (data, startUnitNo, unitCount, cryptoInfo);

  00080	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR unitCount$[rsp]
  00088	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR cryptoInfo$[rsp]
  00090	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR startUnitNo$[rsp]
  00098	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  000a0	e8 00 00 00 00	 call	 EncryptDataUnitsCurrentThread

; 413  : 			break;

  000a5	eb 1f		 jmp	 SHORT $LN15@Encryption@3
$LN12@Encryption@3:

; 414  : 
; 415  : 		default:
; 416  : 			TC_THROW_FATAL_EXCEPTION;

  000a7	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  000b0	45 33 c9	 xor	 r9d, r9d
  000b3	45 33 c0	 xor	 r8d, r8d
  000b6	ba a0 01 00 00	 mov	 edx, 416		; 000001a0H
  000bb	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN15@Encryption@3:

; 417  : 		}
; 418  : 
; 419  : 		return;

  000c6	e9 91 02 00 00	 jmp	 $LN20@Encryption@3
$LN18@Encryption@3:

; 420  : 	}
; 421  : 
; 422  : 	if (unitCount <= ThreadCount)

  000cb	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ThreadCount
  000d1	39 84 24 98 00
	00 00		 cmp	 DWORD PTR unitCount$[rsp], eax
  000d8	77 1d		 ja	 SHORT $LN11@Encryption@3

; 423  : 	{
; 424  : 		fragmentCount = unitCount;

  000da	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR unitCount$[rsp]
  000e1	89 44 24 44	 mov	 DWORD PTR fragmentCount$[rsp], eax

; 425  : 		unitsPerFragment = 1;

  000e5	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR unitsPerFragment$[rsp], 1

; 426  : 		remainder = 0;

  000ed	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR remainder$[rsp], 0

; 427  : 	}
; 428  : 	else

  000f5	eb 42		 jmp	 SHORT $LN10@Encryption@3
$LN11@Encryption@3:

; 429  : 	{
; 430  : 		/* Note that it is not efficient to divide the data into fragments smaller than a few hundred bytes.
; 431  : 		The reason is that the overhead associated with thread handling would in most cases make a multi-threaded 
; 432  : 		process actually slower than a single-threaded process. */
; 433  : 
; 434  : 		fragmentCount = ThreadCount;

  000f7	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ThreadCount
  000fd	89 44 24 44	 mov	 DWORD PTR fragmentCount$[rsp], eax

; 435  : 		unitsPerFragment = unitCount / ThreadCount;

  00101	33 d2		 xor	 edx, edx
  00103	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR unitCount$[rsp]
  0010a	f7 35 00 00 00
	00		 div	 DWORD PTR ThreadCount
  00110	89 44 24 40	 mov	 DWORD PTR unitsPerFragment$[rsp], eax

; 436  : 		remainder = unitCount % ThreadCount;

  00114	33 d2		 xor	 edx, edx
  00116	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR unitCount$[rsp]
  0011d	f7 35 00 00 00
	00		 div	 DWORD PTR ThreadCount
  00123	89 54 24 30	 mov	 DWORD PTR remainder$[rsp], edx

; 437  : 
; 438  : 		if (remainder > 0)

  00127	83 7c 24 30 00	 cmp	 DWORD PTR remainder$[rsp], 0
  0012c	76 0b		 jbe	 SHORT $LN9@Encryption@3

; 439  : 			++unitsPerFragment;

  0012e	8b 44 24 40	 mov	 eax, DWORD PTR unitsPerFragment$[rsp]
  00132	83 c0 01	 add	 eax, 1
  00135	89 44 24 40	 mov	 DWORD PTR unitsPerFragment$[rsp], eax
$LN9@Encryption@3:
$LN10@Encryption@3:

; 440  : 	}
; 441  : 	
; 442  : 	fragmentData = data;

  00139	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR data$[rsp]
  00141	48 89 44 24 48	 mov	 QWORD PTR fragmentData$[rsp], rax

; 443  : 	fragmentStartUnitNo = startUnitNo->Value;

  00146	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR startUnitNo$[rsp]
  0014e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00151	48 89 44 24 50	 mov	 QWORD PTR fragmentStartUnitNo$[rsp], rax

; 444  : 
; 445  : 	TC_ACQUIRE_MUTEX (&EnqueueMutex);

  00156	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EnqueueMutex
  0015d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAcquireFastMutex

; 446  : 	firstFragmentWorkItem = &WorkItemQueue[EnqueuePosition];

  00163	44 8b 1d 00 00
	00 00		 mov	 r11d, DWORD PTR EnqueuePosition
  0016a	49 63 cb	 movsxd	 rcx, r11d
  0016d	48 6b c9 78	 imul	 rcx, 120		; 00000078H
  00171	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:WorkItemQueue
  00178	48 03 c1	 add	 rax, rcx
  0017b	48 89 44 24 58	 mov	 QWORD PTR firstFragmentWorkItem$[rsp], rax
$LN8@Encryption@3:

; 447  : 
; 448  : 	while (GetWorkItemState (firstFragmentWorkItem) != WorkItemFree)

  00180	48 8b 4c 24 58	 mov	 rcx, QWORD PTR firstFragmentWorkItem$[rsp]
  00185	e8 00 00 00 00	 call	 GetWorkItemState
  0018a	85 c0		 test	 eax, eax
  0018c	74 20		 je	 SHORT $LN7@Encryption@3

; 449  : 	{
; 450  : 		TC_WAIT_EVENT (WorkItemCompletedEvent);

  0018e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00197	45 33 c9	 xor	 r9d, r9d
  0019a	45 33 c0	 xor	 r8d, r8d
  0019d	33 d2		 xor	 edx, edx
  0019f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemCompletedEvent
  001a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 451  : 	}

  001ac	eb d2		 jmp	 SHORT $LN8@Encryption@3
$LN7@Encryption@3:

; 452  : 
; 453  : 	firstFragmentWorkItem->OutstandingFragmentCount = fragmentCount;

  001ae	48 8b 4c 24 58	 mov	 rcx, QWORD PTR firstFragmentWorkItem$[rsp]
  001b3	8b 44 24 44	 mov	 eax, DWORD PTR fragmentCount$[rsp]
  001b7	89 41 28	 mov	 DWORD PTR [rcx+40], eax
$LN6@Encryption@3:

; 454  : 
; 455  : 	while (fragmentCount-- > 0)

  001ba	8b 4c 24 44	 mov	 ecx, DWORD PTR fragmentCount$[rsp]
  001be	8b 44 24 44	 mov	 eax, DWORD PTR fragmentCount$[rsp]
  001c2	83 e8 01	 sub	 eax, 1
  001c5	89 44 24 44	 mov	 DWORD PTR fragmentCount$[rsp], eax
  001c9	85 c9		 test	 ecx, ecx
  001cb	0f 86 3d 01 00
	00		 jbe	 $LN5@Encryption@3

; 456  : 	{
; 457  : 		workItem = &WorkItemQueue[EnqueuePosition++];

  001d1	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR EnqueuePosition
  001d7	48 63 c8	 movsxd	 rcx, eax
  001da	48 6b c9 78	 imul	 rcx, 120		; 00000078H
  001de	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:WorkItemQueue
  001e5	48 03 c1	 add	 rax, rcx
  001e8	48 89 44 24 38	 mov	 QWORD PTR workItem$[rsp], rax
  001ed	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR EnqueuePosition
  001f3	83 c0 01	 add	 eax, 1
  001f6	89 05 00 00 00
	00		 mov	 DWORD PTR EnqueuePosition, eax

; 458  : 		if (EnqueuePosition >= TC_ENC_THREAD_POOL_QUEUE_SIZE)

  001fc	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR EnqueuePosition
  00202	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00207	7c 0a		 jl	 SHORT $LN4@Encryption@3

; 459  : 			EnqueuePosition = 0;

  00209	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR EnqueuePosition, 0
$LN4@Encryption@3:
$LN3@Encryption@3:

; 460  : 
; 461  : 		while (GetWorkItemState (workItem) != WorkItemFree)

  00213	48 8b 4c 24 38	 mov	 rcx, QWORD PTR workItem$[rsp]
  00218	e8 00 00 00 00	 call	 GetWorkItemState
  0021d	85 c0		 test	 eax, eax
  0021f	74 20		 je	 SHORT $LN2@Encryption@3

; 462  : 		{
; 463  : 			TC_WAIT_EVENT (WorkItemCompletedEvent);

  00221	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0022a	45 33 c9	 xor	 r9d, r9d
  0022d	45 33 c0	 xor	 r8d, r8d
  00230	33 d2		 xor	 edx, edx
  00232	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemCompletedEvent
  00239	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 464  : 		}

  0023f	eb d2		 jmp	 SHORT $LN3@Encryption@3
$LN2@Encryption@3:

; 465  : 
; 466  : 		workItem->Type = type;

  00241	48 8b 4c 24 38	 mov	 rcx, QWORD PTR workItem$[rsp]
  00246	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR type$[rsp]
  0024d	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 467  : 		workItem->FirstFragment = firstFragmentWorkItem;

  00250	48 8b 4c 24 38	 mov	 rcx, QWORD PTR workItem$[rsp]
  00255	48 8b 44 24 58	 mov	 rax, QWORD PTR firstFragmentWorkItem$[rsp]
  0025a	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 468  : 
; 469  : 		workItem->Encryption.CryptoInfo = cryptoInfo;

  0025e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR workItem$[rsp]
  00263	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  0026b	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 470  : 		workItem->Encryption.Data = fragmentData;

  0026f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR workItem$[rsp]
  00274	48 8b 44 24 48	 mov	 rax, QWORD PTR fragmentData$[rsp]
  00279	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 471  : 		workItem->Encryption.UnitCount = unitsPerFragment;

  0027d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR workItem$[rsp]
  00282	8b 44 24 40	 mov	 eax, DWORD PTR unitsPerFragment$[rsp]
  00286	89 41 48	 mov	 DWORD PTR [rcx+72], eax

; 472  : 		workItem->Encryption.StartUnitNo.Value = fragmentStartUnitNo;

  00289	48 8b 4c 24 38	 mov	 rcx, QWORD PTR workItem$[rsp]
  0028e	48 8b 44 24 50	 mov	 rax, QWORD PTR fragmentStartUnitNo$[rsp]
  00293	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax

; 473  : 
; 474  :  		fragmentData += unitsPerFragment * ENCRYPTION_DATA_UNIT_SIZE;

  00297	8b 44 24 40	 mov	 eax, DWORD PTR unitsPerFragment$[rsp]
  0029b	69 c0 00 02 00
	00		 imul	 eax, 512		; 00000200H
  002a1	8b c8		 mov	 ecx, eax
  002a3	48 8b 44 24 48	 mov	 rax, QWORD PTR fragmentData$[rsp]
  002a8	48 03 c1	 add	 rax, rcx
  002ab	48 89 44 24 48	 mov	 QWORD PTR fragmentData$[rsp], rax

; 475  : 		fragmentStartUnitNo += unitsPerFragment;

  002b0	8b 4c 24 40	 mov	 ecx, DWORD PTR unitsPerFragment$[rsp]
  002b4	48 8b 44 24 50	 mov	 rax, QWORD PTR fragmentStartUnitNo$[rsp]
  002b9	48 03 c1	 add	 rax, rcx
  002bc	48 89 44 24 50	 mov	 QWORD PTR fragmentStartUnitNo$[rsp], rax

; 476  : 
; 477  : 		if (remainder > 0 && --remainder == 0)

  002c1	83 7c 24 30 00	 cmp	 DWORD PTR remainder$[rsp], 0
  002c6	76 1d		 jbe	 SHORT $LN1@Encryption@3
  002c8	8b 44 24 30	 mov	 eax, DWORD PTR remainder$[rsp]
  002cc	83 e8 01	 sub	 eax, 1
  002cf	89 44 24 30	 mov	 DWORD PTR remainder$[rsp], eax
  002d3	83 7c 24 30 00	 cmp	 DWORD PTR remainder$[rsp], 0
  002d8	75 0b		 jne	 SHORT $LN1@Encryption@3

; 478  : 			--unitsPerFragment;

  002da	8b 44 24 40	 mov	 eax, DWORD PTR unitsPerFragment$[rsp]
  002de	83 e8 01	 sub	 eax, 1
  002e1	89 44 24 40	 mov	 DWORD PTR unitsPerFragment$[rsp], eax
$LN1@Encryption@3:

; 479  : 
; 480  : 		SetWorkItemState (workItem, WorkItemReady);

  002e5	ba 01 00 00 00	 mov	 edx, 1
  002ea	48 8b 4c 24 38	 mov	 rcx, QWORD PTR workItem$[rsp]
  002ef	e8 00 00 00 00	 call	 SetWorkItemState

; 481  : 		TC_SET_EVENT (WorkItemReadyEvent);

  002f4	45 33 c0	 xor	 r8d, r8d
  002f7	ba 01 00 00 00	 mov	 edx, 1
  002fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemReadyEvent
  00303	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 482  : 	}

  00309	e9 ac fe ff ff	 jmp	 $LN6@Encryption@3
$LN5@Encryption@3:

; 483  : 
; 484  : 	TC_RELEASE_MUTEX (&EnqueueMutex);

  0030e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EnqueueMutex
  00315	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExReleaseFastMutex

; 485  : 
; 486  : 	TC_WAIT_EVENT (firstFragmentWorkItem->ItemCompletedEvent);

  0031b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR firstFragmentWorkItem$[rsp]
  00320	48 83 c1 08	 add	 rcx, 8
  00324	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0032d	45 33 c9	 xor	 r9d, r9d
  00330	45 33 c0	 xor	 r8d, r8d
  00333	33 d2		 xor	 edx, edx
  00335	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 487  : 	SetWorkItemState (firstFragmentWorkItem, WorkItemFree);

  0033b	33 d2		 xor	 edx, edx
  0033d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR firstFragmentWorkItem$[rsp]
  00342	e8 00 00 00 00	 call	 SetWorkItemState

; 488  : 	TC_SET_EVENT (WorkItemCompletedEvent);

  00347	45 33 c0	 xor	 r8d, r8d
  0034a	ba 01 00 00 00	 mov	 edx, 1
  0034f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemCompletedEvent
  00356	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent
$LN20@Encryption@3:
$LN21@Encryption@3:

; 489  : }

  0035c	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00360	c3		 ret	 0
EncryptionThreadPoolDoWork ENDP
DequeuePosition DD 01H DUP (?)
DequeueMutex DB	038H DUP (?)
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptionThreadProc DD imagerel EncryptionThreadProc
	DD	imagerel EncryptionThreadProc+1000
	DD	imagerel $unwind$EncryptionThreadProc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptionThreadProc DD 010901H
	DD	0a209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EncryptionThreadProc
_TEXT	SEGMENT
workItem$ = 64
tv91 = 72
tv143 = 76
threadArg$ = 96
EncryptionThreadProc PROC				; COMDAT

; 124  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN25@Encryption@4:
$LN22@Encryption@4:

; 125  : 	EncryptionThreadPoolWorkItem *workItem;
; 126  : 
; 127  : 	while (!StopPending)

  00009	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR StopPending
  0000f	85 c0		 test	 eax, eax
  00011	0f 85 c4 03 00
	00		 jne	 $LN21@Encryption@4

; 128  : 	{
; 129  : 		TC_ACQUIRE_MUTEX (&DequeueMutex);

  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:DequeueMutex
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAcquireFastMutex

; 130  : 
; 131  : 		workItem = &WorkItemQueue[DequeuePosition++];

  00024	44 8b 1d 00 00
	00 00		 mov	 r11d, DWORD PTR DequeuePosition
  0002b	49 63 cb	 movsxd	 rcx, r11d
  0002e	48 6b c9 78	 imul	 rcx, 120		; 00000078H
  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:WorkItemQueue
  00039	48 03 c1	 add	 rax, rcx
  0003c	48 89 44 24 40	 mov	 QWORD PTR workItem$[rsp], rax
  00041	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR DequeuePosition
  00047	83 c0 01	 add	 eax, 1
  0004a	89 05 00 00 00
	00		 mov	 DWORD PTR DequeuePosition, eax

; 132  : 
; 133  : 		if (DequeuePosition >= TC_ENC_THREAD_POOL_QUEUE_SIZE)

  00050	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR DequeuePosition
  00056	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0005b	7c 0a		 jl	 SHORT $LN20@Encryption@4

; 134  : 			DequeuePosition = 0;

  0005d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR DequeuePosition, 0
$LN20@Encryption@4:
$LN19@Encryption@4:

; 135  : 
; 136  : 		while (!StopPending && GetWorkItemState (workItem) != WorkItemReady)

  00067	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR StopPending
  0006d	85 c0		 test	 eax, eax
  0006f	75 2f		 jne	 SHORT $LN18@Encryption@4
  00071	48 8b 4c 24 40	 mov	 rcx, QWORD PTR workItem$[rsp]
  00076	e8 00 00 00 00	 call	 GetWorkItemState
  0007b	83 f8 01	 cmp	 eax, 1
  0007e	74 20		 je	 SHORT $LN18@Encryption@4

; 137  : 		{
; 138  : 			TC_WAIT_EVENT (WorkItemReadyEvent);

  00080	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00089	45 33 c9	 xor	 r9d, r9d
  0008c	45 33 c0	 xor	 r8d, r8d
  0008f	33 d2		 xor	 edx, edx
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemReadyEvent
  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 139  : 		}

  0009e	eb c7		 jmp	 SHORT $LN19@Encryption@4
$LN18@Encryption@4:

; 140  : 
; 141  : 		SetWorkItemState (workItem, WorkItemBusy);

  000a0	ba 02 00 00 00	 mov	 edx, 2
  000a5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR workItem$[rsp]
  000aa	e8 00 00 00 00	 call	 SetWorkItemState

; 142  : 
; 143  : 		TC_RELEASE_MUTEX (&DequeueMutex);

  000af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:DequeueMutex
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExReleaseFastMutex

; 144  : 
; 145  : 		if (StopPending)

  000bc	44 8b 1d 00 00
	00 00		 mov	 r11d, DWORD PTR StopPending
  000c3	45 85 db	 test	 r11d, r11d
  000c6	74 05		 je	 SHORT $LN17@Encryption@4

; 146  : 			break;

  000c8	e9 0e 03 00 00	 jmp	 $LN21@Encryption@4
$LN17@Encryption@4:

; 147  : 
; 148  : 		switch (workItem->Type)

  000cd	48 8b 44 24 40	 mov	 rax, QWORD PTR workItem$[rsp]
  000d2	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  000d5	89 44 24 48	 mov	 DWORD PTR tv91[rsp], eax
  000d9	83 7c 24 48 00	 cmp	 DWORD PTR tv91[rsp], 0
  000de	74 41		 je	 SHORT $LN13@Encryption@4
  000e0	83 7c 24 48 01	 cmp	 DWORD PTR tv91[rsp], 1
  000e5	74 0c		 je	 SHORT $LN14@Encryption@4
  000e7	83 7c 24 48 02	 cmp	 DWORD PTR tv91[rsp], 2
  000ec	74 61		 je	 SHORT $LN12@Encryption@4
  000ee	e9 5b 02 00 00	 jmp	 $LN3@Encryption@4
$LN14@Encryption@4:

; 149  : 		{
; 150  : 		case DecryptDataUnitsWork:
; 151  : 			DecryptDataUnitsCurrentThread (workItem->Encryption.Data, &workItem->Encryption.StartUnitNo, workItem->Encryption.UnitCount, workItem->Encryption.CryptoInfo);

  000f3	48 8b 44 24 40	 mov	 rax, QWORD PTR workItem$[rsp]
  000f8	44 8b 40 48	 mov	 r8d, DWORD PTR [rax+72]
  000fc	48 8b 54 24 40	 mov	 rdx, QWORD PTR workItem$[rsp]
  00101	48 83 c2 40	 add	 rdx, 64			; 00000040H
  00105	4c 8b 4c 24 40	 mov	 r9, QWORD PTR workItem$[rsp]
  0010a	4d 8b 49 30	 mov	 r9, QWORD PTR [r9+48]
  0010e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR workItem$[rsp]
  00113	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00117	e8 00 00 00 00	 call	 DecryptDataUnitsCurrentThread

; 152  : 			break;

  0011c	e9 4c 02 00 00	 jmp	 $LN15@Encryption@4
$LN13@Encryption@4:

; 153  : 
; 154  : 		case EncryptDataUnitsWork:
; 155  : 			EncryptDataUnitsCurrentThread (workItem->Encryption.Data, &workItem->Encryption.StartUnitNo, workItem->Encryption.UnitCount, workItem->Encryption.CryptoInfo);

  00121	48 8b 44 24 40	 mov	 rax, QWORD PTR workItem$[rsp]
  00126	44 8b 40 48	 mov	 r8d, DWORD PTR [rax+72]
  0012a	48 8b 54 24 40	 mov	 rdx, QWORD PTR workItem$[rsp]
  0012f	48 83 c2 40	 add	 rdx, 64			; 00000040H
  00133	4c 8b 4c 24 40	 mov	 r9, QWORD PTR workItem$[rsp]
  00138	4d 8b 49 30	 mov	 r9, QWORD PTR [r9+48]
  0013c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR workItem$[rsp]
  00141	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00145	e8 00 00 00 00	 call	 EncryptDataUnitsCurrentThread

; 156  : 			break;

  0014a	e9 1e 02 00 00	 jmp	 $LN15@Encryption@4
$LN12@Encryption@4:

; 157  : 
; 158  : 		case DeriveKeyWork:
; 159  : 			switch (workItem->KeyDerivation.Pkcs5Prf)

  0014f	48 8b 44 24 40	 mov	 rax, QWORD PTR workItem$[rsp]
  00154	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00157	89 44 24 4c	 mov	 DWORD PTR tv143[rsp], eax
  0015b	83 7c 24 4c 01	 cmp	 DWORD PTR tv143[rsp], 1
  00160	74 22		 je	 SHORT $LN9@Encryption@4
  00162	83 7c 24 4c 02	 cmp	 DWORD PTR tv143[rsp], 2
  00167	74 68		 je	 SHORT $LN8@Encryption@4
  00169	83 7c 24 4c 03	 cmp	 DWORD PTR tv143[rsp], 3
  0016e	0f 84 aa 00 00
	00		 je	 $LN7@Encryption@4
  00174	83 7c 24 4c 04	 cmp	 DWORD PTR tv143[rsp], 4
  00179	0f 84 e9 00 00
	00		 je	 $LN6@Encryption@4
  0017f	e9 2e 01 00 00	 jmp	 $LN5@Encryption@4
$LN9@Encryption@4:

; 160  : 			{
; 161  : 			case RIPEMD160:
; 162  : 				derive_key_ripemd160 (workItem->KeyDerivation.Password, workItem->KeyDerivation.PasswordLength, workItem->KeyDerivation.Salt, PKCS5_SALT_SIZE,
; 163  : 					workItem->KeyDerivation.IterationCount, workItem->KeyDerivation.DerivedKey, GetMaxPkcs5OutSize());

  00184	e8 00 00 00 00	 call	 GetMaxPkcs5OutSize
  00189	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0018d	48 8b 44 24 40	 mov	 rax, QWORD PTR workItem$[rsp]
  00192	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00196	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0019b	48 8b 44 24 40	 mov	 rax, QWORD PTR workItem$[rsp]
  001a0	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  001a3	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001a7	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  001ad	4c 8b 44 24 40	 mov	 r8, QWORD PTR workItem$[rsp]
  001b2	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  001b6	48 8b 44 24 40	 mov	 rax, QWORD PTR workItem$[rsp]
  001bb	8b 50 68	 mov	 edx, DWORD PTR [rax+104]
  001be	48 8b 4c 24 40	 mov	 rcx, QWORD PTR workItem$[rsp]
  001c3	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  001c7	e8 00 00 00 00	 call	 derive_key_ripemd160

; 164  : 				break;

  001cc	e9 00 01 00 00	 jmp	 $LN10@Encryption@4
$LN8@Encryption@4:

; 165  : 
; 166  : 			case SHA512:
; 167  : 				derive_key_sha512 (workItem->KeyDerivation.Password, workItem->KeyDerivation.PasswordLength, workItem->KeyDerivation.Salt, PKCS5_SALT_SIZE,
; 168  : 					workItem->KeyDerivation.IterationCount, workItem->KeyDerivation.DerivedKey, GetMaxPkcs5OutSize());

  001d1	e8 00 00 00 00	 call	 GetMaxPkcs5OutSize
  001d6	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  001da	48 8b 44 24 40	 mov	 rax, QWORD PTR workItem$[rsp]
  001df	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  001e3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001e8	48 8b 44 24 40	 mov	 rax, QWORD PTR workItem$[rsp]
  001ed	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  001f0	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001f4	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  001fa	4c 8b 44 24 40	 mov	 r8, QWORD PTR workItem$[rsp]
  001ff	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00203	48 8b 44 24 40	 mov	 rax, QWORD PTR workItem$[rsp]
  00208	8b 50 68	 mov	 edx, DWORD PTR [rax+104]
  0020b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR workItem$[rsp]
  00210	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00214	e8 00 00 00 00	 call	 derive_key_sha512

; 169  : 				break;

  00219	e9 b3 00 00 00	 jmp	 $LN10@Encryption@4
$LN7@Encryption@4:

; 170  : 
; 171  : 			case WHIRLPOOL:
; 172  : 				derive_key_whirlpool (workItem->KeyDerivation.Password, workItem->KeyDerivation.PasswordLength, workItem->KeyDerivation.Salt, PKCS5_SALT_SIZE,
; 173  : 					workItem->KeyDerivation.IterationCount, workItem->KeyDerivation.DerivedKey, GetMaxPkcs5OutSize());

  0021e	e8 00 00 00 00	 call	 GetMaxPkcs5OutSize
  00223	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00227	48 8b 44 24 40	 mov	 rax, QWORD PTR workItem$[rsp]
  0022c	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00230	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00235	48 8b 44 24 40	 mov	 rax, QWORD PTR workItem$[rsp]
  0023a	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0023d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00241	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  00247	4c 8b 44 24 40	 mov	 r8, QWORD PTR workItem$[rsp]
  0024c	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00250	48 8b 44 24 40	 mov	 rax, QWORD PTR workItem$[rsp]
  00255	8b 50 68	 mov	 edx, DWORD PTR [rax+104]
  00258	48 8b 4c 24 40	 mov	 rcx, QWORD PTR workItem$[rsp]
  0025d	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00261	e8 00 00 00 00	 call	 derive_key_whirlpool

; 174  : 				break;

  00266	eb 69		 jmp	 SHORT $LN10@Encryption@4
$LN6@Encryption@4:

; 175  : 
; 176  : 			case SHA1:
; 177  : 				derive_key_sha1 (workItem->KeyDerivation.Password, workItem->KeyDerivation.PasswordLength, workItem->KeyDerivation.Salt, PKCS5_SALT_SIZE,
; 178  : 					workItem->KeyDerivation.IterationCount, workItem->KeyDerivation.DerivedKey, GetMaxPkcs5OutSize());

  00268	e8 00 00 00 00	 call	 GetMaxPkcs5OutSize
  0026d	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00271	48 8b 44 24 40	 mov	 rax, QWORD PTR workItem$[rsp]
  00276	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0027a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0027f	48 8b 44 24 40	 mov	 rax, QWORD PTR workItem$[rsp]
  00284	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00287	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0028b	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  00291	4c 8b 44 24 40	 mov	 r8, QWORD PTR workItem$[rsp]
  00296	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  0029a	48 8b 44 24 40	 mov	 rax, QWORD PTR workItem$[rsp]
  0029f	8b 50 68	 mov	 edx, DWORD PTR [rax+104]
  002a2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR workItem$[rsp]
  002a7	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  002ab	e8 00 00 00 00	 call	 derive_key_sha1

; 179  : 				break;

  002b0	eb 1f		 jmp	 SHORT $LN10@Encryption@4
$LN5@Encryption@4:

; 180  : 
; 181  : 			default:		
; 182  : 				TC_THROW_FATAL_EXCEPTION;

  002b2	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  002bb	45 33 c9	 xor	 r9d, r9d
  002be	45 33 c0	 xor	 r8d, r8d
  002c1	ba b6 00 00 00	 mov	 edx, 182		; 000000b6H
  002c6	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  002cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN10@Encryption@4:

; 183  : 			} 
; 184  : 
; 185  : 			InterlockedExchange (workItem->KeyDerivation.CompletionFlag, TRUE);

  002d1	b9 01 00 00 00	 mov	 ecx, 1
  002d6	48 8b 44 24 40	 mov	 rax, QWORD PTR workItem$[rsp]
  002db	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  002df	87 08		 xchg	 DWORD PTR [rax], ecx

; 186  : 			TC_SET_EVENT (*workItem->KeyDerivation.CompletionEvent);

  002e1	45 33 c0	 xor	 r8d, r8d
  002e4	ba 01 00 00 00	 mov	 edx, 1
  002e9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR workItem$[rsp]
  002ee	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  002f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 187  : 			
; 188  : 			if (InterlockedDecrement (workItem->KeyDerivation.OutstandingWorkItemCount) == 0)

  002f8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR workItem$[rsp]
  002fd	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00301	b8 ff ff ff ff	 mov	 eax, -1
  00306	f0 0f c1 01	 lock xadd DWORD PTR [rcx], eax
  0030a	83 c0 ff	 add	 eax, -1
  0030d	85 c0		 test	 eax, eax
  0030f	75 17		 jne	 SHORT $LN4@Encryption@4

; 189  : 				TC_SET_EVENT (*workItem->KeyDerivation.NoOutstandingWorkItemEvent);

  00311	45 33 c0	 xor	 r8d, r8d
  00314	ba 01 00 00 00	 mov	 edx, 1
  00319	48 8b 4c 24 40	 mov	 rcx, QWORD PTR workItem$[rsp]
  0031e	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00322	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent
$LN4@Encryption@4:

; 190  : 
; 191  : 			SetWorkItemState (workItem, WorkItemFree);

  00328	33 d2		 xor	 edx, edx
  0032a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR workItem$[rsp]
  0032f	e8 00 00 00 00	 call	 SetWorkItemState

; 192  : 			TC_SET_EVENT (WorkItemCompletedEvent);

  00334	45 33 c0	 xor	 r8d, r8d
  00337	ba 01 00 00 00	 mov	 edx, 1
  0033c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemCompletedEvent
  00343	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 193  : 			continue;

  00349	e9 bb fc ff ff	 jmp	 $LN22@Encryption@4
$LN3@Encryption@4:

; 194  : 
; 195  : 		default:
; 196  : 			TC_THROW_FATAL_EXCEPTION;

  0034e	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00357	45 33 c9	 xor	 r9d, r9d
  0035a	45 33 c0	 xor	 r8d, r8d
  0035d	ba c4 00 00 00	 mov	 edx, 196		; 000000c4H
  00362	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  00367	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN15@Encryption@4:

; 197  : 		}
; 198  : 
; 199  : 		if (workItem != workItem->FirstFragment)

  0036d	48 8b 44 24 40	 mov	 rax, QWORD PTR workItem$[rsp]
  00372	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00376	48 39 44 24 40	 cmp	 QWORD PTR workItem$[rsp], rax
  0037b	74 21		 je	 SHORT $LN2@Encryption@4

; 200  : 		{
; 201  : 			SetWorkItemState (workItem, WorkItemFree);

  0037d	33 d2		 xor	 edx, edx
  0037f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR workItem$[rsp]
  00384	e8 00 00 00 00	 call	 SetWorkItemState

; 202  : 			TC_SET_EVENT (WorkItemCompletedEvent);

  00389	45 33 c0	 xor	 r8d, r8d
  0038c	ba 01 00 00 00	 mov	 edx, 1
  00391	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemCompletedEvent
  00398	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent
$LN2@Encryption@4:

; 203  : 		}
; 204  : 
; 205  : 		if (InterlockedDecrement (&workItem->FirstFragment->OutstandingFragmentCount) == 0)

  0039e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR workItem$[rsp]
  003a3	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  003a7	48 83 c1 28	 add	 rcx, 40			; 00000028H
  003ab	b8 ff ff ff ff	 mov	 eax, -1
  003b0	f0 0f c1 01	 lock xadd DWORD PTR [rcx], eax
  003b4	83 c0 ff	 add	 eax, -1
  003b7	85 c0		 test	 eax, eax
  003b9	75 1b		 jne	 SHORT $LN1@Encryption@4

; 206  : 			TC_SET_EVENT (workItem->FirstFragment->ItemCompletedEvent);

  003bb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR workItem$[rsp]
  003c0	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  003c4	48 83 c1 08	 add	 rcx, 8
  003c8	45 33 c0	 xor	 r8d, r8d
  003cb	ba 01 00 00 00	 mov	 edx, 1
  003d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent
$LN1@Encryption@4:

; 207  : 	}

  003d6	e9 2e fc ff ff	 jmp	 $LN25@Encryption@4
$LN21@Encryption@4:

; 208  : 
; 209  : #ifdef DEVICE_DRIVER
; 210  : 	PsTerminateSystemThread (STATUS_SUCCESS);

  003db	33 c9		 xor	 ecx, ecx
  003dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsTerminateSystemThread
$LN24@Encryption@4:

; 211  : #else
; 212  : 	_endthreadex (0);
; 213  :     return 0;
; 214  : #endif
; 215  : }

  003e3	48 83 c4 58	 add	 rsp, 88			; 00000058H
  003e7	c3		 ret	 0
EncryptionThreadProc ENDP
PUBLIC	EncryptionThreadPoolStart
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptionThreadPoolStart DD imagerel $LN14
	DD	imagerel $LN14+420
	DD	imagerel $unwind$EncryptionThreadPoolStart
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptionThreadPoolStart DD 020a01H
	DD	07006520aH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EncryptionThreadPoolStart
_TEXT	SEGMENT
i$ = 32
cpuCount$ = 40
encryptionFreeCpuCount$ = 64
EncryptionThreadPoolStart PROC				; COMDAT

; 219  : {

$LN14:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 220  : 	size_t cpuCount, i;
; 221  : 
; 222  : 	if (ThreadPoolRunning)

  0000a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ThreadPoolRunning
  00010	85 c0		 test	 eax, eax
  00012	74 0a		 je	 SHORT $LN11@Encryption@5

; 223  : 		return TRUE;

  00014	b8 01 00 00 00	 mov	 eax, 1
  00019	e9 80 01 00 00	 jmp	 $LN12@Encryption@5
$LN11@Encryption@5:

; 224  : 
; 225  : #ifdef DEVICE_DRIVER
; 226  : 	cpuCount = GetCpuCount();

  0001e	e8 00 00 00 00	 call	 GetCpuCount
  00023	48 89 44 24 28	 mov	 QWORD PTR cpuCount$[rsp], rax

; 227  : #else
; 228  : 	{
; 229  : 		SYSTEM_INFO sysInfo;
; 230  : 		GetSystemInfo (&sysInfo);
; 231  : 		cpuCount = sysInfo.dwNumberOfProcessors;
; 232  : 	}
; 233  : #endif
; 234  : 
; 235  : 	if (cpuCount > encryptionFreeCpuCount)

  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR encryptionFreeCpuCount$[rsp]
  0002d	48 39 44 24 28	 cmp	 QWORD PTR cpuCount$[rsp], rax
  00032	76 12		 jbe	 SHORT $LN10@Encryption@5

; 236  : 		cpuCount -= encryptionFreeCpuCount;

  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR encryptionFreeCpuCount$[rsp]
  00039	48 8b 44 24 28	 mov	 rax, QWORD PTR cpuCount$[rsp]
  0003e	48 2b c1	 sub	 rax, rcx
  00041	48 89 44 24 28	 mov	 QWORD PTR cpuCount$[rsp], rax
$LN10@Encryption@5:

; 237  : 
; 238  : 	if (cpuCount < 2)

  00046	48 83 7c 24 28
	02		 cmp	 QWORD PTR cpuCount$[rsp], 2
  0004c	73 0a		 jae	 SHORT $LN9@Encryption@5

; 239  : 		return TRUE;

  0004e	b8 01 00 00 00	 mov	 eax, 1
  00053	e9 46 01 00 00	 jmp	 $LN12@Encryption@5
$LN9@Encryption@5:

; 240  : 
; 241  : 	if (cpuCount > TC_ENC_THREAD_POOL_MAX_THREAD_COUNT)

  00058	48 83 7c 24 28
	40		 cmp	 QWORD PTR cpuCount$[rsp], 64 ; 00000040H
  0005e	76 09		 jbe	 SHORT $LN8@Encryption@5

; 242  : 		cpuCount = TC_ENC_THREAD_POOL_MAX_THREAD_COUNT;

  00060	48 c7 44 24 28
	40 00 00 00	 mov	 QWORD PTR cpuCount$[rsp], 64 ; 00000040H
$LN8@Encryption@5:

; 243  : 
; 244  : 	StopPending = FALSE;

  00069	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR StopPending, 0

; 245  : 	DequeuePosition = 0;

  00073	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR DequeuePosition, 0

; 246  : 	EnqueuePosition = 0;

  0007d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR EnqueuePosition, 0

; 247  : 
; 248  : #ifdef DEVICE_DRIVER
; 249  : 	KeInitializeEvent (&WorkItemReadyEvent, SynchronizationEvent, FALSE);

  00087	45 33 c0	 xor	 r8d, r8d
  0008a	ba 01 00 00 00	 mov	 edx, 1
  0008f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemReadyEvent
  00096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 250  : 	KeInitializeEvent (&WorkItemCompletedEvent, SynchronizationEvent, FALSE);

  0009c	45 33 c0	 xor	 r8d, r8d
  0009f	ba 01 00 00 00	 mov	 edx, 1
  000a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemCompletedEvent
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 251  : #else
; 252  : 	WorkItemReadyEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
; 253  : 	if (!WorkItemReadyEvent)
; 254  : 		return FALSE;
; 255  : 	
; 256  : 	WorkItemCompletedEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
; 257  : 	if (!WorkItemCompletedEvent)
; 258  : 		return FALSE;
; 259  : #endif
; 260  : 	
; 261  : #ifdef DEVICE_DRIVER
; 262  : 	ExInitializeFastMutex (&DequeueMutex);

  000b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:DequeueMutex
  000b8	e8 00 00 00 00	 call	 ExInitializeFastMutex

; 263  : 	ExInitializeFastMutex (&EnqueueMutex);

  000bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EnqueueMutex
  000c4	e8 00 00 00 00	 call	 ExInitializeFastMutex

; 264  : #else
; 265  : 	DequeueMutex = CreateMutex (NULL, FALSE, NULL);
; 266  : 	if (!DequeueMutex)
; 267  : 		return FALSE;
; 268  : 
; 269  : 	EnqueueMutex = CreateMutex (NULL, FALSE, NULL);
; 270  : 	if (!EnqueueMutex)
; 271  : 		return FALSE;
; 272  : #endif
; 273  : 
; 274  : 	memset (WorkItemQueue, 0, sizeof (WorkItemQueue));

  000c9	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:WorkItemQueue
  000d0	33 c0		 xor	 eax, eax
  000d2	b9 00 3c 00 00	 mov	 ecx, 15360		; 00003c00H
  000d7	f3 aa		 rep stosb

; 275  : 
; 276  : 	for (i = 0; i < sizeof (WorkItemQueue) / sizeof (WorkItemQueue[0]); ++i)

  000d9	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  000e2	eb 0e		 jmp	 SHORT $LN7@Encryption@5
$LN6@Encryption@5:
  000e4	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  000e9	48 83 c0 01	 add	 rax, 1
  000ed	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN7@Encryption@5:
  000f2	48 81 7c 24 20
	80 00 00 00	 cmp	 QWORD PTR i$[rsp], 128	; 00000080H
  000fb	73 3c		 jae	 SHORT $LN5@Encryption@5

; 277  : 	{
; 278  : 		WorkItemQueue[i].State = WorkItemFree;

  000fd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00102	48 6b c9 78	 imul	 rcx, 120		; 00000078H
  00106	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:WorkItemQueue
  0010d	c7 04 08 00 00
	00 00		 mov	 DWORD PTR [rax+rcx], 0

; 279  : 
; 280  : #ifdef DEVICE_DRIVER
; 281  : 		KeInitializeEvent (&WorkItemQueue[i].ItemCompletedEvent, SynchronizationEvent, FALSE);

  00114	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00119	48 6b c9 78	 imul	 rcx, 120		; 00000078H
  0011d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:WorkItemQueue
  00124	48 8d 4c 08 08	 lea	 rcx, QWORD PTR [rax+rcx+8]
  00129	45 33 c0	 xor	 r8d, r8d
  0012c	ba 01 00 00 00	 mov	 edx, 1
  00131	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 282  : #else
; 283  : 		WorkItemQueue[i].ItemCompletedEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
; 284  : 		if (!WorkItemQueue[i].ItemCompletedEvent)
; 285  : 		{
; 286  : 			EncryptionThreadPoolStop();
; 287  : 			return FALSE;
; 288  : 		}
; 289  : #endif
; 290  : 	}

  00137	eb ab		 jmp	 SHORT $LN6@Encryption@5
$LN5@Encryption@5:

; 291  : 
; 292  : 	for (ThreadCount = 0; ThreadCount < cpuCount; ++ThreadCount)

  00139	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ThreadCount, 0
  00143	eb 0f		 jmp	 SHORT $LN4@Encryption@5
$LN3@Encryption@5:
  00145	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ThreadCount
  0014b	83 c0 01	 add	 eax, 1
  0014e	89 05 00 00 00
	00		 mov	 DWORD PTR ThreadCount, eax
$LN4@Encryption@5:
  00154	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ThreadCount
  0015a	48 3b 44 24 28	 cmp	 rax, QWORD PTR cpuCount$[rsp]
  0015f	73 2e		 jae	 SHORT $LN2@Encryption@5

; 293  : 	{
; 294  : #ifdef DEVICE_DRIVER
; 295  : 		if (!NT_SUCCESS (TCStartThread (EncryptionThreadProc, NULL, &ThreadHandles[ThreadCount])))

  00161	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ThreadCount
  00167	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ThreadHandles
  0016e	4c 8d 04 c8	 lea	 r8, QWORD PTR [rax+rcx*8]
  00172	33 d2		 xor	 edx, edx
  00174	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionThreadProc
  0017b	e8 00 00 00 00	 call	 TCStartThread
  00180	85 c0		 test	 eax, eax
  00182	7d 09		 jge	 SHORT $LN1@Encryption@5

; 296  : #else
; 297  : 		if (!(ThreadHandles[ThreadCount] = (HANDLE) _beginthreadex (NULL, 0, EncryptionThreadProc, NULL, 0, NULL)))
; 298  : #endif
; 299  : 		{
; 300  : 			EncryptionThreadPoolStop();

  00184	e8 00 00 00 00	 call	 EncryptionThreadPoolStop

; 301  : 			return FALSE;

  00189	33 c0		 xor	 eax, eax
  0018b	eb 11		 jmp	 SHORT $LN12@Encryption@5
$LN1@Encryption@5:

; 302  : 		}
; 303  : 	}

  0018d	eb b6		 jmp	 SHORT $LN3@Encryption@5
$LN2@Encryption@5:

; 304  : 
; 305  : 	ThreadPoolRunning = TRUE;

  0018f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ThreadPoolRunning, 1

; 306  : 	return TRUE;

  00199	b8 01 00 00 00	 mov	 eax, 1
$LN12@Encryption@5:

; 307  : }

  0019e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001a2	5f		 pop	 rdi
  001a3	c3		 ret	 0
EncryptionThreadPoolStart ENDP
END
