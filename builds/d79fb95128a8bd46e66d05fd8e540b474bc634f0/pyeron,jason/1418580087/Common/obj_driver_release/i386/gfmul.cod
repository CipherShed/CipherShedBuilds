; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\home\public\desktop\projects\ciphershed.build\src\common\gfmul.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
_gft_le	DW	00H
	DW	0c201H
	DW	08403H
	DW	04602H
	DW	0807H
	DW	0ca06H
	DW	08c04H
	DW	04e05H
	DW	0100eH
	DW	0d20fH
	DW	0940dH
	DW	0560cH
	DW	01809H
	DW	0da08H
	DW	09c0aH
	DW	05e0bH
	DW	0201cH
	DW	0e21dH
	DW	0a41fH
	DW	0661eH
	DW	0281bH
	DW	0ea1aH
	DW	0ac18H
	DW	06e19H
	DW	03012H
	DW	0f213H
	DW	0b411H
	DW	07610H
	DW	03815H
	DW	0fa14H
	DW	0bc16H
	DW	07e17H
	DW	04038H
	DW	08239H
	DW	0c43bH
	DW	063aH
	DW	0483fH
	DW	08a3eH
	DW	0cc3cH
	DW	0e3dH
	DW	05036H
	DW	09237H
	DW	0d435H
	DW	01634H
	DW	05831H
	DW	09a30H
	DW	0dc32H
	DW	01e33H
	DW	06024H
	DW	0a225H
	DW	0e427H
	DW	02626H
	DW	06823H
	DW	0aa22H
	DW	0ec20H
	DW	02e21H
	DW	0702aH
	DW	0b22bH
	DW	0f429H
	DW	03628H
	DW	0782dH
	DW	0ba2cH
	DW	0fc2eH
	DW	03e2fH
	DW	08070H
	DW	04271H
	DW	0473H
	DW	0c672H
	DW	08877H
	DW	04a76H
	DW	0c74H
	DW	0ce75H
	DW	0907eH
	DW	0527fH
	DW	0147dH
	DW	0d67cH
	DW	09879H
	DW	05a78H
	DW	01c7aH
	DW	0de7bH
	DW	0a06cH
	DW	0626dH
	DW	0246fH
	DW	0e66eH
	DW	0a86bH
	DW	06a6aH
	DW	02c68H
	DW	0ee69H
	DW	0b062H
	DW	07263H
	DW	03461H
	DW	0f660H
	DW	0b865H
	DW	07a64H
	DW	03c66H
	DW	0fe67H
	DW	0c048H
	DW	0249H
	DW	0444bH
	DW	0864aH
	DW	0c84fH
	DW	0a4eH
	DW	04c4cH
	DW	08e4dH
	DW	0d046H
	DW	01247H
	DW	05445H
	DW	09644H
	DW	0d841H
	DW	01a40H
	DW	05c42H
	DW	09e43H
	DW	0e054H
	DW	02255H
	DW	06457H
	DW	0a656H
	DW	0e853H
	DW	02a52H
	DW	06c50H
	DW	0ae51H
	DW	0f05aH
	DW	0325bH
	DW	07459H
	DW	0b658H
	DW	0f85dH
	DW	03a5cH
	DW	07c5eH
	DW	0be5fH
	DW	0e1H
	DW	0c2e0H
	DW	084e2H
	DW	046e3H
	DW	08e6H
	DW	0cae7H
	DW	08ce5H
	DW	04ee4H
	DW	010efH
	DW	0d2eeH
	DW	094ecH
	DW	056edH
	DW	018e8H
	DW	0dae9H
	DW	09cebH
	DW	05eeaH
	DW	020fdH
	DW	0e2fcH
	DW	0a4feH
	DW	066ffH
	DW	028faH
	DW	0eafbH
	DW	0acf9H
	DW	06ef8H
	DW	030f3H
	DW	0f2f2H
	DW	0b4f0H
	DW	076f1H
	DW	038f4H
	DW	0faf5H
	DW	0bcf7H
	DW	07ef6H
	DW	040d9H
	DW	082d8H
	DW	0c4daH
	DW	06dbH
	DW	048deH
	DW	08adfH
	DW	0ccddH
	DW	0edcH
	DW	050d7H
	DW	092d6H
	DW	0d4d4H
	DW	016d5H
	DW	058d0H
	DW	09ad1H
	DW	0dcd3H
	DW	01ed2H
	DW	060c5H
	DW	0a2c4H
	DW	0e4c6H
	DW	026c7H
	DW	068c2H
	DW	0aac3H
	DW	0ecc1H
	DW	02ec0H
	DW	070cbH
	DW	0b2caH
	DW	0f4c8H
	DW	036c9H
	DW	078ccH
	DW	0bacdH
	DW	0fccfH
	DW	03eceH
	DW	08091H
	DW	04290H
	DW	0492H
	DW	0c693H
	DW	08896H
	DW	04a97H
	DW	0c95H
	DW	0ce94H
	DW	0909fH
	DW	0529eH
	DW	0149cH
	DW	0d69dH
	DW	09898H
	DW	05a99H
	DW	01c9bH
	DW	0de9aH
	DW	0a08dH
	DW	0628cH
	DW	0248eH
	DW	0e68fH
	DW	0a88aH
	DW	06a8bH
	DW	02c89H
	DW	0ee88H
	DW	0b083H
	DW	07282H
	DW	03480H
	DW	0f681H
	DW	0b884H
	DW	07a85H
	DW	03c87H
	DW	0fe86H
	DW	0c0a9H
	DW	02a8H
	DW	044aaH
	DW	086abH
	DW	0c8aeH
	DW	0aafH
	DW	04cadH
	DW	08eacH
	DW	0d0a7H
	DW	012a6H
	DW	054a4H
	DW	096a5H
	DW	0d8a0H
	DW	01aa1H
	DW	05ca3H
	DW	09ea2H
	DW	0e0b5H
	DW	022b4H
	DW	064b6H
	DW	0a6b7H
	DW	0e8b2H
	DW	02ab3H
	DW	06cb1H
	DW	0aeb0H
	DW	0f0bbH
	DW	032baH
	DW	074b8H
	DW	0b6b9H
	DW	0f8bcH
	DW	03abdH
	DW	07cbfH
	DW	0bebeH
_gft_le64 DW	00H
	DW	0b001H
	DW	06003H
	DW	0d002H
	DW	0c006H
	DW	07007H
	DW	0a005H
	DW	01004H
	DW	0800dH
	DW	0300cH
	DW	0e00eH
	DW	0500fH
	DW	0400bH
	DW	0f00aH
	DW	02008H
	DW	09009H
	DW	01bH
	DW	0b01aH
	DW	06018H
	DW	0d019H
	DW	0c01dH
	DW	0701cH
	DW	0a01eH
	DW	0101fH
	DW	08016H
	DW	03017H
	DW	0e015H
	DW	05014H
	DW	04010H
	DW	0f011H
	DW	02013H
	DW	09012H
	DW	036H
	DW	0b037H
	DW	06035H
	DW	0d034H
	DW	0c030H
	DW	07031H
	DW	0a033H
	DW	01032H
	DW	0803bH
	DW	0303aH
	DW	0e038H
	DW	05039H
	DW	0403dH
	DW	0f03cH
	DW	0203eH
	DW	0903fH
	DW	02dH
	DW	0b02cH
	DW	0602eH
	DW	0d02fH
	DW	0c02bH
	DW	0702aH
	DW	0a028H
	DW	01029H
	DW	08020H
	DW	03021H
	DW	0e023H
	DW	05022H
	DW	04026H
	DW	0f027H
	DW	02025H
	DW	09024H
	DW	06cH
	DW	0b06dH
	DW	0606fH
	DW	0d06eH
	DW	0c06aH
	DW	0706bH
	DW	0a069H
	DW	01068H
	DW	08061H
	DW	03060H
	DW	0e062H
	DW	05063H
	DW	04067H
	DW	0f066H
	DW	02064H
	DW	09065H
	DW	077H
	DW	0b076H
	DW	06074H
	DW	0d075H
	DW	0c071H
	DW	07070H
	DW	0a072H
	DW	01073H
	DW	0807aH
	DW	0307bH
	DW	0e079H
	DW	05078H
	DW	0407cH
	DW	0f07dH
	DW	0207fH
	DW	0907eH
	DW	05aH
	DW	0b05bH
	DW	06059H
	DW	0d058H
	DW	0c05cH
	DW	0705dH
	DW	0a05fH
	DW	0105eH
	DW	08057H
	DW	03056H
	DW	0e054H
	DW	05055H
	DW	04051H
	DW	0f050H
	DW	02052H
	DW	09053H
	DW	041H
	DW	0b040H
	DW	06042H
	DW	0d043H
	DW	0c047H
	DW	07046H
	DW	0a044H
	DW	01045H
	DW	0804cH
	DW	0304dH
	DW	0e04fH
	DW	0504eH
	DW	0404aH
	DW	0f04bH
	DW	02049H
	DW	09048H
	DW	0d8H
	DW	0b0d9H
	DW	060dbH
	DW	0d0daH
	DW	0c0deH
	DW	070dfH
	DW	0a0ddH
	DW	010dcH
	DW	080d5H
	DW	030d4H
	DW	0e0d6H
	DW	050d7H
	DW	040d3H
	DW	0f0d2H
	DW	020d0H
	DW	090d1H
	DW	0c3H
	DW	0b0c2H
	DW	060c0H
	DW	0d0c1H
	DW	0c0c5H
	DW	070c4H
	DW	0a0c6H
	DW	010c7H
	DW	080ceH
	DW	030cfH
	DW	0e0cdH
	DW	050ccH
	DW	040c8H
	DW	0f0c9H
	DW	020cbH
	DW	090caH
	DW	0eeH
	DW	0b0efH
	DW	060edH
	DW	0d0ecH
	DW	0c0e8H
	DW	070e9H
	DW	0a0ebH
	DW	010eaH
	DW	080e3H
	DW	030e2H
	DW	0e0e0H
	DW	050e1H
	DW	040e5H
	DW	0f0e4H
	DW	020e6H
	DW	090e7H
	DW	0f5H
	DW	0b0f4H
	DW	060f6H
	DW	0d0f7H
	DW	0c0f3H
	DW	070f2H
	DW	0a0f0H
	DW	010f1H
	DW	080f8H
	DW	030f9H
	DW	0e0fbH
	DW	050faH
	DW	040feH
	DW	0f0ffH
	DW	020fdH
	DW	090fcH
	DW	0b4H
	DW	0b0b5H
	DW	060b7H
	DW	0d0b6H
	DW	0c0b2H
	DW	070b3H
	DW	0a0b1H
	DW	010b0H
	DW	080b9H
	DW	030b8H
	DW	0e0baH
	DW	050bbH
	DW	040bfH
	DW	0f0beH
	DW	020bcH
	DW	090bdH
	DW	0afH
	DW	0b0aeH
	DW	060acH
	DW	0d0adH
	DW	0c0a9H
	DW	070a8H
	DW	0a0aaH
	DW	010abH
	DW	080a2H
	DW	030a3H
	DW	0e0a1H
	DW	050a0H
	DW	040a4H
	DW	0f0a5H
	DW	020a7H
	DW	090a6H
	DW	082H
	DW	0b083H
	DW	06081H
	DW	0d080H
	DW	0c084H
	DW	07085H
	DW	0a087H
	DW	01086H
	DW	0808fH
	DW	0308eH
	DW	0e08cH
	DW	0508dH
	DW	04089H
	DW	0f088H
	DW	0208aH
	DW	0908bH
	DW	099H
	DW	0b098H
	DW	0609aH
	DW	0d09bH
	DW	0c09fH
	DW	0709eH
	DW	0a09cH
	DW	0109dH
	DW	08094H
	DW	03095H
	DW	0e097H
	DW	05096H
	DW	04092H
	DW	0f093H
	DW	02091H
	DW	09090H
_gft_be	DW	00H
	DW	01c2H
	DW	0384H
	DW	0246H
	DW	0708H
	DW	06caH
	DW	048cH
	DW	054eH
	DW	0e10H
	DW	0fd2H
	DW	0d94H
	DW	0c56H
	DW	0918H
	DW	08daH
	DW	0a9cH
	DW	0b5eH
	DW	01c20H
	DW	01de2H
	DW	01fa4H
	DW	01e66H
	DW	01b28H
	DW	01aeaH
	DW	018acH
	DW	0196eH
	DW	01230H
	DW	013f2H
	DW	011b4H
	DW	01076H
	DW	01538H
	DW	014faH
	DW	016bcH
	DW	0177eH
	DW	03840H
	DW	03982H
	DW	03bc4H
	DW	03a06H
	DW	03f48H
	DW	03e8aH
	DW	03cccH
	DW	03d0eH
	DW	03650H
	DW	03792H
	DW	035d4H
	DW	03416H
	DW	03158H
	DW	0309aH
	DW	032dcH
	DW	0331eH
	DW	02460H
	DW	025a2H
	DW	027e4H
	DW	02626H
	DW	02368H
	DW	022aaH
	DW	020ecH
	DW	0212eH
	DW	02a70H
	DW	02bb2H
	DW	029f4H
	DW	02836H
	DW	02d78H
	DW	02cbaH
	DW	02efcH
	DW	02f3eH
	DW	07080H
	DW	07142H
	DW	07304H
	DW	072c6H
	DW	07788H
	DW	0764aH
	DW	0740cH
	DW	075ceH
	DW	07e90H
	DW	07f52H
	DW	07d14H
	DW	07cd6H
	DW	07998H
	DW	0785aH
	DW	07a1cH
	DW	07bdeH
	DW	06ca0H
	DW	06d62H
	DW	06f24H
	DW	06ee6H
	DW	06ba8H
	DW	06a6aH
	DW	0682cH
	DW	069eeH
	DW	062b0H
	DW	06372H
	DW	06134H
	DW	060f6H
	DW	065b8H
	DW	0647aH
	DW	0663cH
	DW	067feH
	DW	048c0H
	DW	04902H
	DW	04b44H
	DW	04a86H
	DW	04fc8H
	DW	04e0aH
	DW	04c4cH
	DW	04d8eH
	DW	046d0H
	DW	04712H
	DW	04554H
	DW	04496H
	DW	041d8H
	DW	0401aH
	DW	0425cH
	DW	0439eH
	DW	054e0H
	DW	05522H
	DW	05764H
	DW	056a6H
	DW	053e8H
	DW	0522aH
	DW	0506cH
	DW	051aeH
	DW	05af0H
	DW	05b32H
	DW	05974H
	DW	058b6H
	DW	05df8H
	DW	05c3aH
	DW	05e7cH
	DW	05fbeH
	DW	0e100H
	DW	0e0c2H
	DW	0e284H
	DW	0e346H
	DW	0e608H
	DW	0e7caH
	DW	0e58cH
	DW	0e44eH
	DW	0ef10H
	DW	0eed2H
	DW	0ec94H
	DW	0ed56H
	DW	0e818H
	DW	0e9daH
	DW	0eb9cH
	DW	0ea5eH
	DW	0fd20H
	DW	0fce2H
	DW	0fea4H
	DW	0ff66H
	DW	0fa28H
	DW	0fbeaH
	DW	0f9acH
	DW	0f86eH
	DW	0f330H
	DW	0f2f2H
	DW	0f0b4H
	DW	0f176H
	DW	0f438H
	DW	0f5faH
	DW	0f7bcH
	DW	0f67eH
	DW	0d940H
	DW	0d882H
	DW	0dac4H
	DW	0db06H
	DW	0de48H
	DW	0df8aH
	DW	0ddccH
	DW	0dc0eH
	DW	0d750H
	DW	0d692H
	DW	0d4d4H
	DW	0d516H
	DW	0d058H
	DW	0d19aH
	DW	0d3dcH
	DW	0d21eH
	DW	0c560H
	DW	0c4a2H
	DW	0c6e4H
	DW	0c726H
	DW	0c268H
	DW	0c3aaH
	DW	0c1ecH
	DW	0c02eH
	DW	0cb70H
	DW	0cab2H
	DW	0c8f4H
	DW	0c936H
	DW	0cc78H
	DW	0cdbaH
	DW	0cffcH
	DW	0ce3eH
	DW	09180H
	DW	09042H
	DW	09204H
	DW	093c6H
	DW	09688H
	DW	0974aH
	DW	0950cH
	DW	094ceH
	DW	09f90H
	DW	09e52H
	DW	09c14H
	DW	09dd6H
	DW	09898H
	DW	0995aH
	DW	09b1cH
	DW	09adeH
	DW	08da0H
	DW	08c62H
	DW	08e24H
	DW	08fe6H
	DW	08aa8H
	DW	08b6aH
	DW	0892cH
	DW	088eeH
	DW	083b0H
	DW	08272H
	DW	08034H
	DW	081f6H
	DW	084b8H
	DW	0857aH
	DW	0873cH
	DW	086feH
	DW	0a9c0H
	DW	0a802H
	DW	0aa44H
	DW	0ab86H
	DW	0aec8H
	DW	0af0aH
	DW	0ad4cH
	DW	0ac8eH
	DW	0a7d0H
	DW	0a612H
	DW	0a454H
	DW	0a596H
	DW	0a0d8H
	DW	0a11aH
	DW	0a35cH
	DW	0a29eH
	DW	0b5e0H
	DW	0b422H
	DW	0b664H
	DW	0b7a6H
	DW	0b2e8H
	DW	0b32aH
	DW	0b16cH
	DW	0b0aeH
	DW	0bbf0H
	DW	0ba32H
	DW	0b874H
	DW	0b9b6H
	DW	0bcf8H
	DW	0bd3aH
	DW	0bf7cH
	DW	0bebeH
_gft_be64 DW	00H
	DW	01b0H
	DW	0360H
	DW	02d0H
	DW	06c0H
	DW	0770H
	DW	05a0H
	DW	0410H
	DW	0d80H
	DW	0c30H
	DW	0ee0H
	DW	0f50H
	DW	0b40H
	DW	0af0H
	DW	0820H
	DW	0990H
	DW	01b00H
	DW	01ab0H
	DW	01860H
	DW	019d0H
	DW	01dc0H
	DW	01c70H
	DW	01ea0H
	DW	01f10H
	DW	01680H
	DW	01730H
	DW	015e0H
	DW	01450H
	DW	01040H
	DW	011f0H
	DW	01320H
	DW	01290H
	DW	03600H
	DW	037b0H
	DW	03560H
	DW	034d0H
	DW	030c0H
	DW	03170H
	DW	033a0H
	DW	03210H
	DW	03b80H
	DW	03a30H
	DW	038e0H
	DW	03950H
	DW	03d40H
	DW	03cf0H
	DW	03e20H
	DW	03f90H
	DW	02d00H
	DW	02cb0H
	DW	02e60H
	DW	02fd0H
	DW	02bc0H
	DW	02a70H
	DW	028a0H
	DW	02910H
	DW	02080H
	DW	02130H
	DW	023e0H
	DW	02250H
	DW	02640H
	DW	027f0H
	DW	02520H
	DW	02490H
	DW	06c00H
	DW	06db0H
	DW	06f60H
	DW	06ed0H
	DW	06ac0H
	DW	06b70H
	DW	069a0H
	DW	06810H
	DW	06180H
	DW	06030H
	DW	062e0H
	DW	06350H
	DW	06740H
	DW	066f0H
	DW	06420H
	DW	06590H
	DW	07700H
	DW	076b0H
	DW	07460H
	DW	075d0H
	DW	071c0H
	DW	07070H
	DW	072a0H
	DW	07310H
	DW	07a80H
	DW	07b30H
	DW	079e0H
	DW	07850H
	DW	07c40H
	DW	07df0H
	DW	07f20H
	DW	07e90H
	DW	05a00H
	DW	05bb0H
	DW	05960H
	DW	058d0H
	DW	05cc0H
	DW	05d70H
	DW	05fa0H
	DW	05e10H
	DW	05780H
	DW	05630H
	DW	054e0H
	DW	05550H
	DW	05140H
	DW	050f0H
	DW	05220H
	DW	05390H
	DW	04100H
	DW	040b0H
	DW	04260H
	DW	043d0H
	DW	047c0H
	DW	04670H
	DW	044a0H
	DW	04510H
	DW	04c80H
	DW	04d30H
	DW	04fe0H
	DW	04e50H
	DW	04a40H
	DW	04bf0H
	DW	04920H
	DW	04890H
	DW	0d800H
	DW	0d9b0H
	DW	0db60H
	DW	0dad0H
	DW	0dec0H
	DW	0df70H
	DW	0dda0H
	DW	0dc10H
	DW	0d580H
	DW	0d430H
	DW	0d6e0H
	DW	0d750H
	DW	0d340H
	DW	0d2f0H
	DW	0d020H
	DW	0d190H
	DW	0c300H
	DW	0c2b0H
	DW	0c060H
	DW	0c1d0H
	DW	0c5c0H
	DW	0c470H
	DW	0c6a0H
	DW	0c710H
	DW	0ce80H
	DW	0cf30H
	DW	0cde0H
	DW	0cc50H
	DW	0c840H
	DW	0c9f0H
	DW	0cb20H
	DW	0ca90H
	DW	0ee00H
	DW	0efb0H
	DW	0ed60H
	DW	0ecd0H
	DW	0e8c0H
	DW	0e970H
	DW	0eba0H
	DW	0ea10H
	DW	0e380H
	DW	0e230H
	DW	0e0e0H
	DW	0e150H
	DW	0e540H
	DW	0e4f0H
	DW	0e620H
	DW	0e790H
	DW	0f500H
	DW	0f4b0H
	DW	0f660H
	DW	0f7d0H
	DW	0f3c0H
	DW	0f270H
	DW	0f0a0H
	DW	0f110H
	DW	0f880H
	DW	0f930H
	DW	0fbe0H
	DW	0fa50H
	DW	0fe40H
	DW	0fff0H
	DW	0fd20H
	DW	0fc90H
	DW	0b400H
	DW	0b5b0H
	DW	0b760H
	DW	0b6d0H
	DW	0b2c0H
	DW	0b370H
	DW	0b1a0H
	DW	0b010H
	DW	0b980H
	DW	0b830H
	DW	0bae0H
	DW	0bb50H
	DW	0bf40H
	DW	0bef0H
	DW	0bc20H
	DW	0bd90H
	DW	0af00H
	DW	0aeb0H
	DW	0ac60H
	DW	0add0H
	DW	0a9c0H
	DW	0a870H
	DW	0aaa0H
	DW	0ab10H
	DW	0a280H
	DW	0a330H
	DW	0a1e0H
	DW	0a050H
	DW	0a440H
	DW	0a5f0H
	DW	0a720H
	DW	0a690H
	DW	08200H
	DW	083b0H
	DW	08160H
	DW	080d0H
	DW	084c0H
	DW	08570H
	DW	087a0H
	DW	08610H
	DW	08f80H
	DW	08e30H
	DW	08ce0H
	DW	08d50H
	DW	08940H
	DW	088f0H
	DW	08a20H
	DW	08b90H
	DW	09900H
	DW	098b0H
	DW	09a60H
	DW	09bd0H
	DW	09fc0H
	DW	09e70H
	DW	09ca0H
	DW	09d10H
	DW	09480H
	DW	09530H
	DW	097e0H
	DW	09650H
	DW	09240H
	DW	093f0H
	DW	09120H
	DW	09090H
CONST	ENDS
_DATA	SEGMENT
_gf_poly DD	00H
	DD	0e1000000H
_gf_poly64 DD	00H
	DD	0d8000000H
_DATA	ENDS
PUBLIC	_RtlSecureZeroMemory@8
; Function compile flags: /Ogsp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
;	COMDAT _RtlSecureZeroMemory@8
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory@8 PROC				; COMDAT

; 8322 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 8323 :     volatile char *vptr = (volatile char *)ptr;
; 8324 : 
; 8325 : #if defined(_M_AMD64)
; 8326 : 
; 8327 :         __stosb((PUCHAR)((ULONG64)vptr), 0, cnt);
; 8328 : 
; 8329 : #else
; 8330 : 
; 8331 :     while (cnt) {

  00005	83 7d 0c 00	 cmp	 DWORD PTR _cnt$[ebp], 0
  00009	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  0000c	74 09		 je	 SHORT $LN1@RtlSecureZ
$LL2@RtlSecureZ:

; 8332 :         *vptr = 0;

  0000e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 8333 :         vptr++;

  00011	40		 inc	 eax

; 8334 :         cnt--;

  00012	ff 4d 0c	 dec	 DWORD PTR _cnt$[ebp]
  00015	75 f7		 jne	 SHORT $LL2@RtlSecureZ
$LN1@RtlSecureZ:

; 8335 :     }
; 8336 : 
; 8337 : #endif
; 8338 : 
; 8339 :     return ptr;

  00017	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]

; 8340 : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
_RtlSecureZeroMemory@8 ENDP
_TEXT	ENDS
PUBLIC	_bsw_32@8
; Function compile flags: /Ogsp
; File c:\home\public\desktop\projects\ciphershed.build\src\common\gfmul.c
;	COMDAT _bsw_32@8
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$ = 12						; size = 4
_bsw_32@8 PROC						; COMDAT

; 116  : {   unsigned int i = n;

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b 55 0c	 mov	 edx, DWORD PTR _n$[ebp]

; 117  :     while(i--)

  00008	85 d2		 test	 edx, edx
  0000a	74 26		 je	 SHORT $LN6@bsw_32
  0000c	56		 push	 esi
$LL2@bsw_32:
  0000d	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00010	4a		 dec	 edx
  00011	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]

; 118  :         ((mode(32t)*)p)[i] = bswap_32(((mode(32t)*)p)[i]);

  00014	8b 01		 mov	 eax, DWORD PTR [ecx]
  00016	8b f0		 mov	 esi, eax
  00018	c1 ce 08	 ror	 esi, 8
  0001b	81 e6 00 ff 00
	ff		 and	 esi, -16711936		; ff00ff00H
  00021	c1 c0 08	 rol	 eax, 8
  00024	25 ff 00 ff 00	 and	 eax, 16711935		; 00ff00ffH
  00029	0b f0		 or	 esi, eax
  0002b	89 31		 mov	 DWORD PTR [ecx], esi
  0002d	85 d2		 test	 edx, edx
  0002f	75 dc		 jne	 SHORT $LL2@bsw_32
  00031	5e		 pop	 esi
$LN6@bsw_32:

; 119  : }

  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8
_bsw_32@8 ENDP
_TEXT	ENDS
PUBLIC	_move_block_aligned@8
; Function compile flags: /Ogsp
;	COMDAT _move_block_aligned@8
_TEXT	SEGMENT
_p$ = 8							; size = 4
_q$ = 12						; size = 4
_move_block_aligned@8 PROC				; COMDAT

; 155  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 156  :     lp32(p)[0] = lp32(q)[0], lp32(p)[1] = lp32(q)[1],
; 157  :     lp32(p)[2] = lp32(q)[2], lp32(p)[3] = lp32(q)[3];

  00005	8b 45 0c	 mov	 eax, DWORD PTR _q$[ebp]
  00008	8b 10		 mov	 edx, DWORD PTR [eax]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0000d	89 11		 mov	 DWORD PTR [ecx], edx
  0000f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00012	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00015	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00018	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0001b	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0001e	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 158  : }

  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
_move_block_aligned@8 ENDP
_TEXT	ENDS
PUBLIC	_move_block_aligned64@8
; Function compile flags: /Ogsp
;	COMDAT _move_block_aligned64@8
_TEXT	SEGMENT
_p$ = 8							; size = 4
_q$ = 12						; size = 4
_move_block_aligned64@8 PROC				; COMDAT

; 161  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 162  :     lp32(p)[0] = lp32(q)[0], lp32(p)[1] = lp32(q)[1];

  00005	8b 45 0c	 mov	 eax, DWORD PTR _q$[ebp]
  00008	8b 10		 mov	 edx, DWORD PTR [eax]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0000d	89 11		 mov	 DWORD PTR [ecx], edx
  0000f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00012	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 163  : }

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
_move_block_aligned64@8 ENDP
_TEXT	ENDS
PUBLIC	_xor_block_aligned@8
; Function compile flags: /Ogsp
;	COMDAT _xor_block_aligned@8
_TEXT	SEGMENT
_p$ = 8							; size = 4
_q$ = 12						; size = 4
_xor_block_aligned@8 PROC				; COMDAT

; 166  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 167  :     lp32(p)[0] ^= lp32(q)[0], lp32(p)[1] ^= lp32(q)[1],
; 168  :     lp32(p)[2] ^= lp32(q)[2], lp32(p)[3] ^= lp32(q)[3];

  00005	8b 4d 0c	 mov	 ecx, DWORD PTR _q$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0000d	31 10		 xor	 DWORD PTR [eax], edx
  0000f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00012	31 50 04	 xor	 DWORD PTR [eax+4], edx
  00015	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00018	31 50 08	 xor	 DWORD PTR [eax+8], edx
  0001b	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  0001e	31 48 0c	 xor	 DWORD PTR [eax+12], ecx

; 169  : }

  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
_xor_block_aligned@8 ENDP
_TEXT	ENDS
PUBLIC	_xor_block_aligned64@8
; Function compile flags: /Ogsp
;	COMDAT _xor_block_aligned64@8
_TEXT	SEGMENT
_p$ = 8							; size = 4
_q$ = 12						; size = 4
_xor_block_aligned64@8 PROC				; COMDAT

; 172  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 173  :     lp32(p)[0] ^= lp32(q)[0], lp32(p)[1] ^= lp32(q)[1];

  00005	8b 4d 0c	 mov	 ecx, DWORD PTR _q$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0000d	31 10		 xor	 DWORD PTR [eax], edx
  0000f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00012	31 48 04	 xor	 DWORD PTR [eax+4], ecx

; 174  : }

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
_xor_block_aligned64@8 ENDP
_TEXT	ENDS
PUBLIC	_mul_x@4
; Function compile flags: /Ogsp
;	COMDAT _mul_x@4
_TEXT	SEGMENT
_x$ = 8							; size = 4
_mul_x@4 PROC						; COMDAT

; 294  : {   mode(32t)   t;

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 295  : 
; 296  :     bsw_32(x, 4);

  00006	8b 75 08	 mov	 esi, DWORD PTR _x$[ebp]
  00009	57		 push	 edi
  0000a	6a 04		 push	 4
  0000c	56		 push	 esi
  0000d	e8 00 00 00 00	 call	 _bsw_32@8

; 297  : 
; 298  :     /* at this point the filed element bits 0..127 are set out  */
; 299  :     /* as follows in 32-bit words (where the most significant   */
; 300  :     /* (ms) numeric bits are to the left)                       */
; 301  :     /*                                                          */
; 302  :     /*            x[0]      x[1]      x[2]      x[3]            */
; 303  :     /*          ms    ls  ms    ls  ms    ls  ms     ls         */
; 304  :     /* field:   0 ... 31  32 .. 63  64 .. 95  96 .. 127         */
; 305  : 
; 306  :     t = gf_poly[x[3] & 1];          /* bit 127 of the element   */

  00012	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00015	8b c8		 mov	 ecx, eax
  00017	83 e1 01	 and	 ecx, 1
  0001a	8b 3c 8d 00 00
	00 00		 mov	 edi, DWORD PTR _gf_poly[ecx*4]

; 307  :     x[3] = (x[3] >> 1) | (x[2] << 31);  /* shift bits up by one */

  00021	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00024	8b d1		 mov	 edx, ecx
  00026	d1 e8		 shr	 eax, 1
  00028	c1 e2 1f	 shl	 edx, 31			; 0000001fH
  0002b	0b d0		 or	 edx, eax
  0002d	89 56 0c	 mov	 DWORD PTR [esi+12], edx

; 308  :     x[2] = (x[2] >> 1) | (x[1] << 31);  /* position             */

  00030	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00033	8b c2		 mov	 eax, edx
  00035	c1 e0 1f	 shl	 eax, 31			; 0000001fH
  00038	d1 e9		 shr	 ecx, 1
  0003a	0b c1		 or	 eax, ecx
  0003c	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 309  :     x[1] = (x[1] >> 1) | (x[0] << 31);  /* if bit 7 is 1 xor in */

  0003f	8b 06		 mov	 eax, DWORD PTR [esi]
  00041	8b c8		 mov	 ecx, eax
  00043	c1 e1 1f	 shl	 ecx, 31			; 0000001fH
  00046	d1 ea		 shr	 edx, 1

; 310  :     x[0] = (x[0] >> 1) ^ t;             /* the field polynomial */

  00048	d1 e8		 shr	 eax, 1

; 311  :     bsw_32(x, 4);

  0004a	6a 04		 push	 4
  0004c	0b ca		 or	 ecx, edx
  0004e	33 c7		 xor	 eax, edi
  00050	56		 push	 esi
  00051	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00054	89 06		 mov	 DWORD PTR [esi], eax
  00056	e8 00 00 00 00	 call	 _bsw_32@8
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi

; 312  : }

  0005d	5d		 pop	 ebp
  0005e	c2 04 00	 ret	 4
_mul_x@4 ENDP
_TEXT	ENDS
PUBLIC	_mul_x64@4
; Function compile flags: /Ogsp
;	COMDAT _mul_x64@4
_TEXT	SEGMENT
_x$ = 8							; size = 4
_mul_x64@4 PROC						; COMDAT

; 315  : {   mode(32t)   t;

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 316  : 
; 317  :     bsw_32(x, 2);

  00006	8b 75 08	 mov	 esi, DWORD PTR _x$[ebp]
  00009	57		 push	 edi
  0000a	6a 02		 push	 2
  0000c	56		 push	 esi
  0000d	e8 00 00 00 00	 call	 _bsw_32@8

; 318  : 
; 319  :     /* at this point the filed element bits 0..127 are set out  */
; 320  :     /* as follows in 32-bit words (where the most significant   */
; 321  :     /* (ms) numeric bits are to the left)                       */
; 322  :     /*                                                          */
; 323  :     /*            x[0]      x[1]      x[2]      x[3]            */
; 324  :     /*          ms    ls  ms    ls  ms    ls  ms     ls         */
; 325  :     /* field:   0 ... 31  32 .. 63  64 .. 95  96 .. 127         */
; 326  : 
; 327  :     t = gf_poly64[x[1] & 1];          /* bit 127 of the element   */

  00012	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00015	8b c1		 mov	 eax, ecx
  00017	83 e0 01	 and	 eax, 1
  0001a	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _gf_poly64[eax*4]

; 328  : 										/* shift bits up by one */
; 329  : 										/* position             */
; 330  :     x[1] = (x[1] >> 1) | (x[0] << 31);  /* if bit 7 is 1 xor in */

  00021	8b 06		 mov	 eax, DWORD PTR [esi]
  00023	8b f8		 mov	 edi, eax
  00025	c1 e7 1f	 shl	 edi, 31			; 0000001fH
  00028	d1 e9		 shr	 ecx, 1

; 331  :     x[0] = (x[0] >> 1) ^ t;             /* the field polynomial */

  0002a	d1 e8		 shr	 eax, 1

; 332  :     bsw_32(x, 2);

  0002c	6a 02		 push	 2
  0002e	0b f9		 or	 edi, ecx
  00030	33 c2		 xor	 eax, edx
  00032	56		 push	 esi
  00033	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00036	89 06		 mov	 DWORD PTR [esi], eax
  00038	e8 00 00 00 00	 call	 _bsw_32@8
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi

; 333  : }

  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
_mul_x64@4 ENDP
_TEXT	ENDS
PUBLIC	_mul_lex8@4
; Function compile flags: /Ogsp
;	COMDAT _mul_lex8@4
_TEXT	SEGMENT
_x$ = 8							; size = 4
_mul_lex8@4 PROC					; COMDAT

; 345  : {   mode(32t)   t = (x[3] >> 24);       /* in little endian format  */

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]

; 346  :     x[3] = (x[3] << 8) | (x[2] >> 24);

  00008	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0000b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8b f1		 mov	 esi, ecx
  00012	8b fa		 mov	 edi, edx
  00014	c1 ef 18	 shr	 edi, 24			; 00000018H
  00017	c1 e1 08	 shl	 ecx, 8
  0001a	0b f9		 or	 edi, ecx

; 347  :     x[2] = (x[2] << 8) | (x[1] >> 24);

  0001c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001f	89 78 0c	 mov	 DWORD PTR [eax+12], edi
  00022	8b f9		 mov	 edi, ecx
  00024	c1 ef 18	 shr	 edi, 24			; 00000018H
  00027	c1 e2 08	 shl	 edx, 8
  0002a	0b fa		 or	 edi, edx

; 348  :     x[1] = (x[1] << 8) | (x[0] >> 24);

  0002c	8b 10		 mov	 edx, DWORD PTR [eax]
  0002e	89 78 08	 mov	 DWORD PTR [eax+8], edi
  00031	8b fa		 mov	 edi, edx
  00033	c1 ef 18	 shr	 edi, 24			; 00000018H
  00036	c1 e1 08	 shl	 ecx, 8
  00039	0b f9		 or	 edi, ecx
  0003b	c1 ee 18	 shr	 esi, 24			; 00000018H
  0003e	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 349  :     x[0] = (x[0] << 8) ^ gft_le[t];

  00041	0f b7 0c 75 00
	00 00 00	 movzx	 ecx, WORD PTR _gft_le[esi*2]
  00049	c1 e2 08	 shl	 edx, 8
  0004c	33 ca		 xor	 ecx, edx
  0004e	5f		 pop	 edi
  0004f	89 08		 mov	 DWORD PTR [eax], ecx
  00051	5e		 pop	 esi

; 350  : }

  00052	5d		 pop	 ebp
  00053	c2 04 00	 ret	 4
_mul_lex8@4 ENDP
_TEXT	ENDS
PUBLIC	_mul_lex8_64@4
; Function compile flags: /Ogsp
;	COMDAT _mul_lex8_64@4
_TEXT	SEGMENT
_x$ = 8							; size = 4
_mul_lex8_64@4 PROC					; COMDAT

; 353  : {   mode(32t)   t = (x[1] >> 24);       /* in little endian format  */

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]

; 354  :     x[1] = (x[1] << 8) | (x[0] >> 24);

  00008	8b 10		 mov	 edx, DWORD PTR [eax]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b f1		 mov	 esi, ecx
  00011	8b fa		 mov	 edi, edx
  00013	c1 ef 18	 shr	 edi, 24			; 00000018H
  00016	c1 e1 08	 shl	 ecx, 8
  00019	0b f9		 or	 edi, ecx
  0001b	c1 ee 18	 shr	 esi, 24			; 00000018H
  0001e	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 355  :     x[0] = (x[0] << 8) ^ gft_le64[t];

  00021	0f b7 0c 75 00
	00 00 00	 movzx	 ecx, WORD PTR _gft_le64[esi*2]
  00029	c1 e2 08	 shl	 edx, 8
  0002c	33 ca		 xor	 ecx, edx
  0002e	5f		 pop	 edi
  0002f	89 08		 mov	 DWORD PTR [eax], ecx
  00031	5e		 pop	 esi

; 356  : }

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
_mul_lex8_64@4 ENDP
_TEXT	ENDS
PUBLIC	_mul_bex8@4
; Function compile flags: /Ogsp
;	COMDAT _mul_bex8@4
_TEXT	SEGMENT
_x$ = 8							; size = 4
_mul_bex8@4 PROC					; COMDAT

; 368  : {   mode(32t)   t = (x[3] & 0xff);      /* in big endian format     */

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]

; 369  :     x[3] = (x[3] >> 8) | (x[2] << 24);

  00008	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0000b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	0f b6 f1	 movzx	 esi, cl
  00013	8b fa		 mov	 edi, edx
  00015	c1 e7 18	 shl	 edi, 24			; 00000018H
  00018	c1 e9 08	 shr	 ecx, 8
  0001b	0b f9		 or	 edi, ecx

; 370  :     x[2] = (x[2] >> 8) | (x[1] << 24);

  0001d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00020	89 78 0c	 mov	 DWORD PTR [eax+12], edi
  00023	8b f9		 mov	 edi, ecx
  00025	c1 e7 18	 shl	 edi, 24			; 00000018H
  00028	c1 ea 08	 shr	 edx, 8
  0002b	0b fa		 or	 edi, edx

; 371  :     x[1] = (x[1] >> 8) | (x[0] << 24);

  0002d	8b 10		 mov	 edx, DWORD PTR [eax]
  0002f	89 78 08	 mov	 DWORD PTR [eax+8], edi
  00032	8b fa		 mov	 edi, edx
  00034	c1 e9 08	 shr	 ecx, 8
  00037	c1 e7 18	 shl	 edi, 24			; 00000018H
  0003a	0b f9		 or	 edi, ecx
  0003c	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 372  :     x[0] = (x[0] >> 8) ^ (((mode(32t))gft_be[t]) << 16);

  0003f	0f b7 0c 75 00
	00 00 00	 movzx	 ecx, WORD PTR _gft_be[esi*2]
  00047	c1 e1 10	 shl	 ecx, 16			; 00000010H
  0004a	c1 ea 08	 shr	 edx, 8
  0004d	33 ca		 xor	 ecx, edx
  0004f	5f		 pop	 edi
  00050	89 08		 mov	 DWORD PTR [eax], ecx
  00052	5e		 pop	 esi

; 373  : }

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
_mul_bex8@4 ENDP
_TEXT	ENDS
PUBLIC	_GfMul128@8
; Function compile flags: /Ogsp
;	COMDAT _GfMul128@8
_TEXT	SEGMENT
_p$ = -144						; size = 128
_r$ = -16						; size = 16
_a$ = 8							; size = 4
tv259 = 12						; size = 4
_b$ = 12						; size = 4
_GfMul128@8 PROC					; COMDAT

; 397  : {   mode(32t) r[CBLK_LEN >> 2], p[8][CBLK_LEN >> 2];

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H

; 398  :     int i;
; 399  : 
; 400  :     move_block_aligned(p[0], b);

  0000b	ff 75 0c	 push	 DWORD PTR _b$[ebp]
  0000e	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _p$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 _move_block_aligned@8

; 401  :     bsw_32(p[0], 4);

  0001a	6a 04		 push	 4
  0001c	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _p$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 _bsw_32@8
  00028	53		 push	 ebx
  00029	56		 push	 esi
  0002a	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _p$[ebp+8]
  00030	c7 45 0c 07 00
	00 00		 mov	 DWORD PTR tv259[ebp], 7
  00037	57		 push	 edi
$LL15@GfMul128:

; 402  :     for(i = 0; i < 7; ++i)
; 403  :     {
; 404  :         p[i + 1][3] = (p[i][3] >> 1) | (p[i][2] << 31);

  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0003d	8b f9		 mov	 edi, ecx
  0003f	8b f2		 mov	 esi, edx
  00041	d1 ee		 shr	 esi, 1
  00043	c1 e7 1f	 shl	 edi, 31			; 0000001fH
  00046	0b f7		 or	 esi, edi
  00048	89 70 14	 mov	 DWORD PTR [eax+20], esi

; 405  :         p[i + 1][2] = (p[i][2] >> 1) | (p[i][1] << 31);

  0004b	8b 70 fc	 mov	 esi, DWORD PTR [eax-4]
  0004e	d1 e9		 shr	 ecx, 1
  00050	8b de		 mov	 ebx, esi
  00052	c1 e3 1f	 shl	 ebx, 31			; 0000001fH
  00055	0b d9		 or	 ebx, ecx

; 406  :         p[i + 1][1] = (p[i][1] >> 1) | (p[i][0] << 31);

  00057	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0005a	8d 78 10	 lea	 edi, DWORD PTR [eax+16]
  0005d	89 1f		 mov	 DWORD PTR [edi], ebx
  0005f	8b d9		 mov	 ebx, ecx

; 407  :         p[i + 1][0] = (p[i][0] >> 1) ^ gf_poly[p[i][3] & 1];

  00061	83 e2 01	 and	 edx, 1
  00064	d1 e9		 shr	 ecx, 1
  00066	33 0c 95 00 00
	00 00		 xor	 ecx, DWORD PTR _gf_poly[edx*4]
  0006d	c1 e3 1f	 shl	 ebx, 31			; 0000001fH
  00070	d1 ee		 shr	 esi, 1
  00072	0b de		 or	 ebx, esi
  00074	ff 4d 0c	 dec	 DWORD PTR tv259[ebp]
  00077	89 58 0c	 mov	 DWORD PTR [eax+12], ebx
  0007a	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0007d	8b c7		 mov	 eax, edi
  0007f	75 b7		 jne	 SHORT $LL15@GfMul128

; 408  :     }
; 409  : 
; 410  :     memset(r, 0, CBLK_LEN);

  00081	8b 75 08	 mov	 esi, DWORD PTR _a$[ebp]
  00084	33 c0		 xor	 eax, eax
  00086	8d 7d f0	 lea	 edi, DWORD PTR _r$[ebp]
  00089	ab		 stosd
  0008a	ab		 stosd
  0008b	ab		 stosd
  0008c	ab		 stosd

; 411  :     for(i = 0; i < 16; ++i)

  0008d	33 ff		 xor	 edi, edi
  0008f	83 c6 0f	 add	 esi, 15			; 0000000fH
$LL22@GfMul128:

; 412  :     {
; 413  :         if(i) mul_bex8(r);  /* order is always big endian here */

  00092	85 ff		 test	 edi, edi
  00094	74 09		 je	 SHORT $LN9@GfMul128
  00096	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 _mul_bex8@4
$LN9@GfMul128:

; 414  : 
; 415  :         if(((unsigned char*)a)[15 - i] & 0x80)

  0009f	8a 1e		 mov	 bl, BYTE PTR [esi]
  000a1	84 db		 test	 bl, bl
  000a3	79 10		 jns	 SHORT $LN8@GfMul128

; 416  :             xor_block_aligned(r, p[0]);

  000a5	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _p$[ebp]
  000ab	50		 push	 eax
  000ac	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 _xor_block_aligned@8
$LN8@GfMul128:

; 417  :         if(((unsigned char*)a)[15 - i] & 0x40)

  000b5	f6 c3 40	 test	 bl, 64			; 00000040H
  000b8	74 0d		 je	 SHORT $LN7@GfMul128

; 418  :             xor_block_aligned(r, p[1]);

  000ba	8d 45 80	 lea	 eax, DWORD PTR _p$[ebp+16]
  000bd	50		 push	 eax
  000be	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 _xor_block_aligned@8
$LN7@GfMul128:

; 419  :         if(((unsigned char*)a)[15 - i] & 0x20)

  000c7	f6 c3 20	 test	 bl, 32			; 00000020H
  000ca	74 0d		 je	 SHORT $LN6@GfMul128

; 420  :             xor_block_aligned(r, p[2]);

  000cc	8d 45 90	 lea	 eax, DWORD PTR _p$[ebp+32]
  000cf	50		 push	 eax
  000d0	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  000d3	50		 push	 eax
  000d4	e8 00 00 00 00	 call	 _xor_block_aligned@8
$LN6@GfMul128:

; 421  :         if(((unsigned char*)a)[15 - i] & 0x10)

  000d9	f6 c3 10	 test	 bl, 16			; 00000010H
  000dc	74 0d		 je	 SHORT $LN5@GfMul128

; 422  :             xor_block_aligned(r, p[3]);

  000de	8d 45 a0	 lea	 eax, DWORD PTR _p$[ebp+48]
  000e1	50		 push	 eax
  000e2	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 _xor_block_aligned@8
$LN5@GfMul128:

; 423  :         if(((unsigned char*)a)[15 - i] & 0x08)

  000eb	f6 c3 08	 test	 bl, 8
  000ee	74 0d		 je	 SHORT $LN4@GfMul128

; 424  :             xor_block_aligned(r, p[4]);

  000f0	8d 45 b0	 lea	 eax, DWORD PTR _p$[ebp+64]
  000f3	50		 push	 eax
  000f4	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  000f7	50		 push	 eax
  000f8	e8 00 00 00 00	 call	 _xor_block_aligned@8
$LN4@GfMul128:

; 425  :         if(((unsigned char*)a)[15 - i] & 0x04)

  000fd	f6 c3 04	 test	 bl, 4
  00100	74 0d		 je	 SHORT $LN3@GfMul128

; 426  :             xor_block_aligned(r, p[5]);

  00102	8d 45 c0	 lea	 eax, DWORD PTR _p$[ebp+80]
  00105	50		 push	 eax
  00106	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  00109	50		 push	 eax
  0010a	e8 00 00 00 00	 call	 _xor_block_aligned@8
$LN3@GfMul128:

; 427  :         if(((unsigned char*)a)[15 - i] & 0x02)

  0010f	f6 c3 02	 test	 bl, 2
  00112	74 0d		 je	 SHORT $LN2@GfMul128

; 428  :             xor_block_aligned(r, p[6]);

  00114	8d 45 d0	 lea	 eax, DWORD PTR _p$[ebp+96]
  00117	50		 push	 eax
  00118	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  0011b	50		 push	 eax
  0011c	e8 00 00 00 00	 call	 _xor_block_aligned@8
$LN2@GfMul128:

; 429  :         if(((unsigned char*)a)[15 - i] & 0x01)

  00121	f6 c3 01	 test	 bl, 1
  00124	74 0d		 je	 SHORT $LN11@GfMul128

; 430  :             xor_block_aligned(r, p[7]);

  00126	8d 45 e0	 lea	 eax, DWORD PTR _p$[ebp+112]
  00129	50		 push	 eax
  0012a	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  0012d	50		 push	 eax
  0012e	e8 00 00 00 00	 call	 _xor_block_aligned@8
$LN11@GfMul128:
  00133	47		 inc	 edi
  00134	4e		 dec	 esi
  00135	83 ff 10	 cmp	 edi, 16			; 00000010H
  00138	0f 8c 54 ff ff
	ff		 jl	 $LL22@GfMul128

; 431  :     }
; 432  :     bsw_32(r, 4);

  0013e	6a 04		 push	 4
  00140	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  00143	50		 push	 eax
  00144	e8 00 00 00 00	 call	 _bsw_32@8

; 433  :     move_block_aligned(a, r);

  00149	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  0014c	50		 push	 eax
  0014d	ff 75 08	 push	 DWORD PTR _a$[ebp]
  00150	e8 00 00 00 00	 call	 _move_block_aligned@8
  00155	5f		 pop	 edi
  00156	5e		 pop	 esi
  00157	5b		 pop	 ebx

; 434  : }

  00158	c9		 leave
  00159	c2 08 00	 ret	 8
_GfMul128@8 ENDP
_TEXT	ENDS
PUBLIC	_GfMul128Tab@8
; Function compile flags: /Ogsp
;	COMDAT _GfMul128Tab@8
_TEXT	SEGMENT
_r$ = -16						; size = 16
tv789 = 8						; size = 4
tv777 = 8						; size = 4
tv765 = 8						; size = 4
tv753 = 8						; size = 4
tv741 = 8						; size = 4
tv729 = 8						; size = 4
tv717 = 8						; size = 4
tv705 = 8						; size = 4
tv693 = 8						; size = 4
tv681 = 8						; size = 4
tv669 = 8						; size = 4
tv657 = 8						; size = 4
tv645 = 8						; size = 4
tv633 = 8						; size = 4
tv621 = 8						; size = 4
tv610 = 8						; size = 4
_a$ = 8							; size = 4
_ctx$ = 12						; size = 4
_GfMul128Tab@8 PROC					; COMDAT

; 444  : {   unsigned __int32 r[CBLK_LEN >> 2];

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 10	 sub	 esp, 16			; 00000010H
  00008	53		 push	 ebx
  00009	56		 push	 esi

; 445  : 
; 446  :     move_block_aligned(r, ctx->gf_t8k[0][a[0] & 15]);

  0000a	8b 75 08	 mov	 esi, DWORD PTR _a$[ebp]
  0000d	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00010	57		 push	 edi
  00011	8b 7d 0c	 mov	 edi, DWORD PTR _ctx$[ebp]
  00014	6a 0f		 push	 15			; 0000000fH
  00016	89 45 08	 mov	 DWORD PTR tv610[ebp], eax
  00019	5b		 pop	 ebx
  0001a	23 c3		 and	 eax, ebx
  0001c	c1 e0 04	 shl	 eax, 4
  0001f	03 c7		 add	 eax, edi
  00021	50		 push	 eax
  00022	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _move_block_aligned@8

; 447  :     xor_block_aligned(r, ctx->gf_t8k[1][a[0] >> 4]);

  0002b	8b 45 08	 mov	 eax, DWORD PTR tv610[ebp]
  0002e	c1 e8 04	 shr	 eax, 4
  00031	83 c0 10	 add	 eax, 16			; 00000010H
  00034	c1 e0 04	 shl	 eax, 4
  00037	03 c7		 add	 eax, edi
  00039	50		 push	 eax
  0003a	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 _xor_block_aligned@8

; 448  :                 xor_8k( 1); xor_8k( 2); xor_8k( 3);

  00043	0f b6 46 01	 movzx	 eax, BYTE PTR [esi+1]
  00047	89 45 08	 mov	 DWORD PTR tv621[ebp], eax
  0004a	23 c3		 and	 eax, ebx
  0004c	83 c0 20	 add	 eax, 32			; 00000020H
  0004f	c1 e0 04	 shl	 eax, 4
  00052	03 c7		 add	 eax, edi
  00054	50		 push	 eax
  00055	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 _xor_block_aligned@8
  0005e	8b 45 08	 mov	 eax, DWORD PTR tv621[ebp]
  00061	c1 e8 04	 shr	 eax, 4
  00064	83 c0 30	 add	 eax, 48			; 00000030H
  00067	c1 e0 04	 shl	 eax, 4
  0006a	03 c7		 add	 eax, edi
  0006c	50		 push	 eax
  0006d	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 _xor_block_aligned@8
  00076	0f b6 46 02	 movzx	 eax, BYTE PTR [esi+2]
  0007a	89 45 08	 mov	 DWORD PTR tv633[ebp], eax
  0007d	23 c3		 and	 eax, ebx
  0007f	83 c0 40	 add	 eax, 64			; 00000040H
  00082	c1 e0 04	 shl	 eax, 4
  00085	03 c7		 add	 eax, edi
  00087	50		 push	 eax
  00088	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 _xor_block_aligned@8
  00091	8b 45 08	 mov	 eax, DWORD PTR tv633[ebp]
  00094	c1 e8 04	 shr	 eax, 4
  00097	83 c0 50	 add	 eax, 80			; 00000050H
  0009a	c1 e0 04	 shl	 eax, 4
  0009d	03 c7		 add	 eax, edi
  0009f	50		 push	 eax
  000a0	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 _xor_block_aligned@8
  000a9	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  000ad	89 45 08	 mov	 DWORD PTR tv645[ebp], eax
  000b0	23 c3		 and	 eax, ebx
  000b2	83 c0 60	 add	 eax, 96			; 00000060H
  000b5	c1 e0 04	 shl	 eax, 4
  000b8	03 c7		 add	 eax, edi
  000ba	50		 push	 eax
  000bb	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 _xor_block_aligned@8
  000c4	8b 45 08	 mov	 eax, DWORD PTR tv645[ebp]
  000c7	c1 e8 04	 shr	 eax, 4
  000ca	83 c0 70	 add	 eax, 112		; 00000070H
  000cd	c1 e0 04	 shl	 eax, 4
  000d0	03 c7		 add	 eax, edi
  000d2	50		 push	 eax
  000d3	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 _xor_block_aligned@8

; 449  :     xor_8k( 4); xor_8k( 5); xor_8k( 6); xor_8k( 7);

  000dc	0f b6 46 04	 movzx	 eax, BYTE PTR [esi+4]
  000e0	89 45 08	 mov	 DWORD PTR tv657[ebp], eax
  000e3	23 c3		 and	 eax, ebx
  000e5	83 e8 80	 sub	 eax, -128		; ffffff80H
  000e8	c1 e0 04	 shl	 eax, 4
  000eb	03 c7		 add	 eax, edi
  000ed	50		 push	 eax
  000ee	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  000f1	50		 push	 eax
  000f2	e8 00 00 00 00	 call	 _xor_block_aligned@8
  000f7	8b 45 08	 mov	 eax, DWORD PTR tv657[ebp]
  000fa	c1 e8 04	 shr	 eax, 4
  000fd	05 90 00 00 00	 add	 eax, 144		; 00000090H
  00102	c1 e0 04	 shl	 eax, 4
  00105	03 c7		 add	 eax, edi
  00107	50		 push	 eax
  00108	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  0010b	50		 push	 eax
  0010c	e8 00 00 00 00	 call	 _xor_block_aligned@8
  00111	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  00115	89 45 08	 mov	 DWORD PTR tv669[ebp], eax
  00118	23 c3		 and	 eax, ebx
  0011a	05 a0 00 00 00	 add	 eax, 160		; 000000a0H
  0011f	c1 e0 04	 shl	 eax, 4
  00122	03 c7		 add	 eax, edi
  00124	50		 push	 eax
  00125	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  00128	50		 push	 eax
  00129	e8 00 00 00 00	 call	 _xor_block_aligned@8
  0012e	8b 45 08	 mov	 eax, DWORD PTR tv669[ebp]
  00131	c1 e8 04	 shr	 eax, 4
  00134	05 b0 00 00 00	 add	 eax, 176		; 000000b0H
  00139	c1 e0 04	 shl	 eax, 4
  0013c	03 c7		 add	 eax, edi
  0013e	50		 push	 eax
  0013f	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  00142	50		 push	 eax
  00143	e8 00 00 00 00	 call	 _xor_block_aligned@8
  00148	0f b6 46 06	 movzx	 eax, BYTE PTR [esi+6]
  0014c	89 45 08	 mov	 DWORD PTR tv681[ebp], eax
  0014f	23 c3		 and	 eax, ebx
  00151	05 c0 00 00 00	 add	 eax, 192		; 000000c0H
  00156	c1 e0 04	 shl	 eax, 4
  00159	03 c7		 add	 eax, edi
  0015b	50		 push	 eax
  0015c	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  0015f	50		 push	 eax
  00160	e8 00 00 00 00	 call	 _xor_block_aligned@8
  00165	8b 45 08	 mov	 eax, DWORD PTR tv681[ebp]
  00168	c1 e8 04	 shr	 eax, 4
  0016b	05 d0 00 00 00	 add	 eax, 208		; 000000d0H
  00170	c1 e0 04	 shl	 eax, 4
  00173	03 c7		 add	 eax, edi
  00175	50		 push	 eax
  00176	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  00179	50		 push	 eax
  0017a	e8 00 00 00 00	 call	 _xor_block_aligned@8
  0017f	0f b6 46 07	 movzx	 eax, BYTE PTR [esi+7]
  00183	89 45 08	 mov	 DWORD PTR tv693[ebp], eax
  00186	23 c3		 and	 eax, ebx
  00188	05 e0 00 00 00	 add	 eax, 224		; 000000e0H
  0018d	c1 e0 04	 shl	 eax, 4
  00190	03 c7		 add	 eax, edi
  00192	50		 push	 eax
  00193	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  00196	50		 push	 eax
  00197	e8 00 00 00 00	 call	 _xor_block_aligned@8
  0019c	8b 45 08	 mov	 eax, DWORD PTR tv693[ebp]
  0019f	c1 e8 04	 shr	 eax, 4
  001a2	05 f0 00 00 00	 add	 eax, 240		; 000000f0H
  001a7	c1 e0 04	 shl	 eax, 4
  001aa	03 c7		 add	 eax, edi
  001ac	50		 push	 eax
  001ad	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  001b0	50		 push	 eax
  001b1	e8 00 00 00 00	 call	 _xor_block_aligned@8

; 450  :     xor_8k( 8); xor_8k( 9); xor_8k(10); xor_8k(11);

  001b6	0f b6 46 08	 movzx	 eax, BYTE PTR [esi+8]
  001ba	89 45 08	 mov	 DWORD PTR tv705[ebp], eax
  001bd	23 c3		 and	 eax, ebx
  001bf	05 00 01 00 00	 add	 eax, 256		; 00000100H
  001c4	c1 e0 04	 shl	 eax, 4
  001c7	03 c7		 add	 eax, edi
  001c9	50		 push	 eax
  001ca	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  001cd	50		 push	 eax
  001ce	e8 00 00 00 00	 call	 _xor_block_aligned@8
  001d3	8b 45 08	 mov	 eax, DWORD PTR tv705[ebp]
  001d6	c1 e8 04	 shr	 eax, 4
  001d9	05 10 01 00 00	 add	 eax, 272		; 00000110H
  001de	c1 e0 04	 shl	 eax, 4
  001e1	03 c7		 add	 eax, edi
  001e3	50		 push	 eax
  001e4	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  001e7	50		 push	 eax
  001e8	e8 00 00 00 00	 call	 _xor_block_aligned@8
  001ed	0f b6 46 09	 movzx	 eax, BYTE PTR [esi+9]
  001f1	89 45 08	 mov	 DWORD PTR tv717[ebp], eax
  001f4	23 c3		 and	 eax, ebx
  001f6	05 20 01 00 00	 add	 eax, 288		; 00000120H
  001fb	c1 e0 04	 shl	 eax, 4
  001fe	03 c7		 add	 eax, edi
  00200	50		 push	 eax
  00201	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  00204	50		 push	 eax
  00205	e8 00 00 00 00	 call	 _xor_block_aligned@8
  0020a	8b 45 08	 mov	 eax, DWORD PTR tv717[ebp]
  0020d	c1 e8 04	 shr	 eax, 4
  00210	05 30 01 00 00	 add	 eax, 304		; 00000130H
  00215	c1 e0 04	 shl	 eax, 4
  00218	03 c7		 add	 eax, edi
  0021a	50		 push	 eax
  0021b	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  0021e	50		 push	 eax
  0021f	e8 00 00 00 00	 call	 _xor_block_aligned@8
  00224	0f b6 46 0a	 movzx	 eax, BYTE PTR [esi+10]
  00228	89 45 08	 mov	 DWORD PTR tv729[ebp], eax
  0022b	23 c3		 and	 eax, ebx
  0022d	05 40 01 00 00	 add	 eax, 320		; 00000140H
  00232	c1 e0 04	 shl	 eax, 4
  00235	03 c7		 add	 eax, edi
  00237	50		 push	 eax
  00238	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  0023b	50		 push	 eax
  0023c	e8 00 00 00 00	 call	 _xor_block_aligned@8
  00241	8b 45 08	 mov	 eax, DWORD PTR tv729[ebp]
  00244	c1 e8 04	 shr	 eax, 4
  00247	05 50 01 00 00	 add	 eax, 336		; 00000150H
  0024c	c1 e0 04	 shl	 eax, 4
  0024f	03 c7		 add	 eax, edi
  00251	50		 push	 eax
  00252	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  00255	50		 push	 eax
  00256	e8 00 00 00 00	 call	 _xor_block_aligned@8
  0025b	0f b6 46 0b	 movzx	 eax, BYTE PTR [esi+11]
  0025f	89 45 08	 mov	 DWORD PTR tv741[ebp], eax
  00262	23 c3		 and	 eax, ebx
  00264	05 60 01 00 00	 add	 eax, 352		; 00000160H
  00269	c1 e0 04	 shl	 eax, 4
  0026c	03 c7		 add	 eax, edi
  0026e	50		 push	 eax
  0026f	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  00272	50		 push	 eax
  00273	e8 00 00 00 00	 call	 _xor_block_aligned@8
  00278	8b 45 08	 mov	 eax, DWORD PTR tv741[ebp]
  0027b	c1 e8 04	 shr	 eax, 4
  0027e	05 70 01 00 00	 add	 eax, 368		; 00000170H
  00283	c1 e0 04	 shl	 eax, 4
  00286	03 c7		 add	 eax, edi
  00288	50		 push	 eax
  00289	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  0028c	50		 push	 eax
  0028d	e8 00 00 00 00	 call	 _xor_block_aligned@8

; 451  :     xor_8k(12); xor_8k(13); xor_8k(14); xor_8k(15);

  00292	0f b6 46 0c	 movzx	 eax, BYTE PTR [esi+12]
  00296	89 45 08	 mov	 DWORD PTR tv753[ebp], eax
  00299	23 c3		 and	 eax, ebx
  0029b	05 80 01 00 00	 add	 eax, 384		; 00000180H
  002a0	c1 e0 04	 shl	 eax, 4
  002a3	03 c7		 add	 eax, edi
  002a5	50		 push	 eax
  002a6	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  002a9	50		 push	 eax
  002aa	e8 00 00 00 00	 call	 _xor_block_aligned@8
  002af	8b 45 08	 mov	 eax, DWORD PTR tv753[ebp]
  002b2	c1 e8 04	 shr	 eax, 4
  002b5	05 90 01 00 00	 add	 eax, 400		; 00000190H
  002ba	c1 e0 04	 shl	 eax, 4
  002bd	03 c7		 add	 eax, edi
  002bf	50		 push	 eax
  002c0	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  002c3	50		 push	 eax
  002c4	e8 00 00 00 00	 call	 _xor_block_aligned@8
  002c9	0f b6 46 0d	 movzx	 eax, BYTE PTR [esi+13]
  002cd	89 45 08	 mov	 DWORD PTR tv765[ebp], eax
  002d0	23 c3		 and	 eax, ebx
  002d2	05 a0 01 00 00	 add	 eax, 416		; 000001a0H
  002d7	c1 e0 04	 shl	 eax, 4
  002da	03 c7		 add	 eax, edi
  002dc	50		 push	 eax
  002dd	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  002e0	50		 push	 eax
  002e1	e8 00 00 00 00	 call	 _xor_block_aligned@8
  002e6	8b 45 08	 mov	 eax, DWORD PTR tv765[ebp]
  002e9	c1 e8 04	 shr	 eax, 4
  002ec	05 b0 01 00 00	 add	 eax, 432		; 000001b0H
  002f1	c1 e0 04	 shl	 eax, 4
  002f4	03 c7		 add	 eax, edi
  002f6	50		 push	 eax
  002f7	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  002fa	50		 push	 eax
  002fb	e8 00 00 00 00	 call	 _xor_block_aligned@8
  00300	0f b6 46 0e	 movzx	 eax, BYTE PTR [esi+14]
  00304	89 45 08	 mov	 DWORD PTR tv777[ebp], eax
  00307	23 c3		 and	 eax, ebx
  00309	05 c0 01 00 00	 add	 eax, 448		; 000001c0H
  0030e	c1 e0 04	 shl	 eax, 4
  00311	03 c7		 add	 eax, edi
  00313	50		 push	 eax
  00314	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  00317	50		 push	 eax
  00318	e8 00 00 00 00	 call	 _xor_block_aligned@8
  0031d	8b 45 08	 mov	 eax, DWORD PTR tv777[ebp]
  00320	c1 e8 04	 shr	 eax, 4
  00323	05 d0 01 00 00	 add	 eax, 464		; 000001d0H
  00328	c1 e0 04	 shl	 eax, 4
  0032b	03 c7		 add	 eax, edi
  0032d	50		 push	 eax
  0032e	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  00331	50		 push	 eax
  00332	e8 00 00 00 00	 call	 _xor_block_aligned@8
  00337	0f b6 46 0f	 movzx	 eax, BYTE PTR [esi+15]
  0033b	89 45 08	 mov	 DWORD PTR tv789[ebp], eax
  0033e	23 c3		 and	 eax, ebx
  00340	05 e0 01 00 00	 add	 eax, 480		; 000001e0H
  00345	c1 e0 04	 shl	 eax, 4
  00348	03 c7		 add	 eax, edi
  0034a	50		 push	 eax
  0034b	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  0034e	50		 push	 eax
  0034f	e8 00 00 00 00	 call	 _xor_block_aligned@8
  00354	8b 45 08	 mov	 eax, DWORD PTR tv789[ebp]
  00357	c1 e8 04	 shr	 eax, 4
  0035a	05 f0 01 00 00	 add	 eax, 496		; 000001f0H
  0035f	c1 e0 04	 shl	 eax, 4
  00362	03 c7		 add	 eax, edi
  00364	50		 push	 eax
  00365	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  00368	50		 push	 eax
  00369	e8 00 00 00 00	 call	 _xor_block_aligned@8

; 452  :     move_block_aligned(a, r);

  0036e	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  00371	50		 push	 eax
  00372	56		 push	 esi
  00373	e8 00 00 00 00	 call	 _move_block_aligned@8
  00378	5f		 pop	 edi
  00379	5e		 pop	 esi
  0037a	5b		 pop	 ebx

; 453  : }

  0037b	c9		 leave
  0037c	c2 08 00	 ret	 8
_GfMul128Tab@8 ENDP
_TEXT	ENDS
PUBLIC	_compile_8k_table@8
EXTRN	_memset:PROC
; Function compile flags: /Ogsp
;	COMDAT _compile_8k_table@8
_TEXT	SEGMENT
tv297 = -12						; size = 4
tv284 = -12						; size = 4
_i$ = -8						; size = 4
tv288 = -4						; size = 4
_a$ = 8							; size = 4
tv175 = 12						; size = 4
_j$ = 12						; size = 4
_ctx$ = 12						; size = 4
_compile_8k_table@8 PROC				; COMDAT

; 476  : {   int i, j, k;

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00008	53		 push	 ebx

; 477  : 
; 478  :     memset(ctx->gf_t8k, 0, 32 * 16 * 16);

  00009	8b 5d 0c	 mov	 ebx, DWORD PTR _ctx$[ebp]
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	68 00 20 00 00	 push	 8192			; 00002000H
  00013	6a 00		 push	 0
  00015	53		 push	 ebx
  00016	e8 00 00 00 00	 call	 _memset
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 479  :     for(i = 0; i < 2 * CBLK_LEN; ++i)

  0001e	83 65 f8 00	 and	 DWORD PTR _i$[ebp], 0
$LL40@compile_8k:

; 480  :     {
; 481  :         if(i == 0)

  00022	83 7d f8 00	 cmp	 DWORD PTR _i$[ebp], 0
  00026	0f 85 82 00 00
	00		 jne	 $LN18@compile_8k

; 482  :         {
; 483  :             memcpy(ctx->gf_t8k[1][8], a, CBLK_LEN);

  0002c	8b 75 08	 mov	 esi, DWORD PTR _a$[ebp]
  0002f	8d bb 80 01 00
	00		 lea	 edi, DWORD PTR [ebx+384]
  00035	a5		 movsd
  00036	a5		 movsd
  00037	a5		 movsd

; 484  :             for(j = 4; j > 0; j >>= 1)

  00038	6a 04		 push	 4
  0003a	58		 pop	 eax
  0003b	a5		 movsd
  0003c	89 45 0c	 mov	 DWORD PTR _j$[ebp], eax
  0003f	eb 03		 jmp	 SHORT $LN17@compile_8k
$LL36@compile_8k:
  00041	8b 45 0c	 mov	 eax, DWORD PTR _j$[ebp]
$LN17@compile_8k:

; 485  :             {
; 486  :                 memcpy(ctx->gf_t8k[1][j], ctx->gf_t8k[1][j + j], CBLK_LEN);

  00044	8d 48 10	 lea	 ecx, DWORD PTR [eax+16]
  00047	c1 e1 04	 shl	 ecx, 4
  0004a	8d 70 08	 lea	 esi, DWORD PTR [eax+8]
  0004d	c1 e6 05	 shl	 esi, 5
  00050	03 cb		 add	 ecx, ebx
  00052	03 f3		 add	 esi, ebx
  00054	8b f9		 mov	 edi, ecx
  00056	a5		 movsd
  00057	a5		 movsd
  00058	a5		 movsd

; 487  :                 mul_x(ctx->gf_t8k[1][j]);

  00059	51		 push	 ecx
  0005a	a5		 movsd
  0005b	e8 00 00 00 00	 call	 _mul_x@4
  00060	d1 7d 0c	 sar	 DWORD PTR _j$[ebp], 1
  00063	83 7d 0c 00	 cmp	 DWORD PTR _j$[ebp], 0
  00067	7f d8		 jg	 SHORT $LL36@compile_8k

; 488  :             }
; 489  :             memcpy(ctx->gf_t8k[0][8], ctx->gf_t8k[1][1], CBLK_LEN);

  00069	8d 83 80 00 00
	00		 lea	 eax, DWORD PTR [ebx+128]
  0006f	8b f8		 mov	 edi, eax
  00071	8d b3 10 01 00
	00		 lea	 esi, DWORD PTR [ebx+272]
  00077	a5		 movsd
  00078	a5		 movsd
  00079	a5		 movsd

; 490  :             mul_x(ctx->gf_t8k[0][8]);

  0007a	50		 push	 eax
  0007b	a5		 movsd
  0007c	e8 00 00 00 00	 call	 _mul_x@4

; 491  :             for(j = 4; j > 0; j >>= 1)

  00081	c7 45 0c 04 00
	00 00		 mov	 DWORD PTR _j$[ebp], 4
$LL37@compile_8k:

; 492  :             {
; 493  :                 memcpy(ctx->gf_t8k[0][j], ctx->gf_t8k[0][j + j], CBLK_LEN);

  00088	8b 75 0c	 mov	 esi, DWORD PTR _j$[ebp]
  0008b	8b c6		 mov	 eax, esi
  0008d	c1 e6 05	 shl	 esi, 5
  00090	c1 e0 04	 shl	 eax, 4
  00093	03 c3		 add	 eax, ebx
  00095	03 f3		 add	 esi, ebx
  00097	8b f8		 mov	 edi, eax
  00099	a5		 movsd
  0009a	a5		 movsd
  0009b	a5		 movsd

; 494  :                 mul_x(ctx->gf_t8k[0][j]);

  0009c	50		 push	 eax
  0009d	a5		 movsd
  0009e	e8 00 00 00 00	 call	 _mul_x@4
  000a3	d1 7d 0c	 sar	 DWORD PTR _j$[ebp], 1
  000a6	83 7d 0c 00	 cmp	 DWORD PTR _j$[ebp], 0
  000aa	7f dc		 jg	 SHORT $LL37@compile_8k

; 495  :             }
; 496  :         }
; 497  :         else if(i > 1)

  000ac	eb 4e		 jmp	 SHORT $LN7@compile_8k
$LN18@compile_8k:
  000ae	83 7d f8 01	 cmp	 DWORD PTR _i$[ebp], 1
  000b2	7e 48		 jle	 SHORT $LN7@compile_8k

; 498  :             for(j = 8; j > 0; j >>= 1)

  000b4	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000b7	6a 08		 push	 8
  000b9	8d 4a fe	 lea	 ecx, DWORD PTR [edx-2]
  000bc	c1 e1 04	 shl	 ecx, 4
  000bf	58		 pop	 eax
  000c0	89 55 fc	 mov	 DWORD PTR tv288[ebp], edx
  000c3	c1 65 fc 04	 shl	 DWORD PTR tv288[ebp], 4
  000c7	89 45 0c	 mov	 DWORD PTR _j$[ebp], eax
  000ca	89 4d f4	 mov	 DWORD PTR tv284[ebp], ecx
  000cd	eb 06		 jmp	 SHORT $LN9@compile_8k
$LL38@compile_8k:

; 491  :             for(j = 4; j > 0; j >>= 1)

  000cf	8b 45 0c	 mov	 eax, DWORD PTR _j$[ebp]
  000d2	8b 4d f4	 mov	 ecx, DWORD PTR tv284[ebp]
$LN9@compile_8k:

; 499  :             {
; 500  :                 memcpy(ctx->gf_t8k[i][j], ctx->gf_t8k[i - 2][j], CBLK_LEN);

  000d5	8b 55 fc	 mov	 edx, DWORD PTR tv288[ebp]
  000d8	03 d0		 add	 edx, eax
  000da	c1 e2 04	 shl	 edx, 4
  000dd	8d 34 01	 lea	 esi, DWORD PTR [ecx+eax]
  000e0	c1 e6 04	 shl	 esi, 4
  000e3	03 d3		 add	 edx, ebx
  000e5	03 f3		 add	 esi, ebx
  000e7	8b fa		 mov	 edi, edx
  000e9	a5		 movsd
  000ea	a5		 movsd
  000eb	a5		 movsd

; 501  :                 mul_x8(ctx->gf_t8k[i][j]);

  000ec	52		 push	 edx
  000ed	a5		 movsd
  000ee	e8 00 00 00 00	 call	 _mul_lex8@4
  000f3	d1 7d 0c	 sar	 DWORD PTR _j$[ebp], 1
  000f6	83 7d 0c 00	 cmp	 DWORD PTR _j$[ebp], 0
  000fa	7f d3		 jg	 SHORT $LL38@compile_8k
$LN7@compile_8k:

; 502  :             }
; 503  : 
; 504  :         for(j = 2; j < 16; j += j)

  000fc	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000ff	8b c8		 mov	 ecx, eax
  00101	c1 e1 08	 shl	 ecx, 8
  00104	6a 02		 push	 2
  00106	8d 4c 19 10	 lea	 ecx, DWORD PTR [ecx+ebx+16]
  0010a	89 45 fc	 mov	 DWORD PTR tv288[ebp], eax
  0010d	c1 65 fc 04	 shl	 DWORD PTR tv288[ebp], 4
  00111	5e		 pop	 esi
  00112	89 4d f4	 mov	 DWORD PTR tv297[ebp], ecx
$LL39@compile_8k:

; 505  :         {
; 506  :             mode(32t) *pj = ctx->gf_t8k[i][j];

  00115	8b 45 fc	 mov	 eax, DWORD PTR tv288[ebp]

; 507  :             mode(32t) *pk = ctx->gf_t8k[i][1];

  00118	8b 55 f4	 mov	 edx, DWORD PTR tv297[ebp]
  0011b	03 c6		 add	 eax, esi
  0011d	c1 e0 04	 shl	 eax, 4
  00120	03 c3		 add	 eax, ebx

; 508  :             mode(32t) *pl = ctx->gf_t8k[i][j + 1];
; 509  : 
; 510  :             for(k = 1; k < j; ++k)

  00122	83 fe 01	 cmp	 esi, 1
  00125	8d 48 10	 lea	 ecx, DWORD PTR [eax+16]
  00128	7e 3e		 jle	 SHORT $LN5@compile_8k
  0012a	8d 7e ff	 lea	 edi, DWORD PTR [esi-1]
  0012d	89 7d 0c	 mov	 DWORD PTR tv175[ebp], edi
$LL3@compile_8k:

; 511  :             {
; 512  :                 *pl++ = pj[0] ^ *pk++;

  00130	8b 3a		 mov	 edi, DWORD PTR [edx]
  00132	33 38		 xor	 edi, DWORD PTR [eax]
  00134	83 c2 04	 add	 edx, 4
  00137	89 39		 mov	 DWORD PTR [ecx], edi

; 513  :                 *pl++ = pj[1] ^ *pk++;

  00139	8b 3a		 mov	 edi, DWORD PTR [edx]
  0013b	33 78 04	 xor	 edi, DWORD PTR [eax+4]
  0013e	83 c1 04	 add	 ecx, 4
  00141	89 39		 mov	 DWORD PTR [ecx], edi
  00143	83 c2 04	 add	 edx, 4

; 514  :                 *pl++ = pj[2] ^ *pk++;

  00146	8b 3a		 mov	 edi, DWORD PTR [edx]
  00148	33 78 08	 xor	 edi, DWORD PTR [eax+8]
  0014b	83 c1 04	 add	 ecx, 4
  0014e	89 39		 mov	 DWORD PTR [ecx], edi
  00150	83 c2 04	 add	 edx, 4

; 515  :                 *pl++ = pj[3] ^ *pk++;

  00153	8b 3a		 mov	 edi, DWORD PTR [edx]
  00155	33 78 0c	 xor	 edi, DWORD PTR [eax+12]
  00158	83 c1 04	 add	 ecx, 4
  0015b	89 39		 mov	 DWORD PTR [ecx], edi
  0015d	83 c1 04	 add	 ecx, 4
  00160	83 c2 04	 add	 edx, 4
  00163	ff 4d 0c	 dec	 DWORD PTR tv175[ebp]
  00166	75 c8		 jne	 SHORT $LL3@compile_8k
$LN5@compile_8k:

; 502  :             }
; 503  : 
; 504  :         for(j = 2; j < 16; j += j)

  00168	03 f6		 add	 esi, esi
  0016a	83 fe 10	 cmp	 esi, 16			; 00000010H
  0016d	7c a6		 jl	 SHORT $LL39@compile_8k
  0016f	ff 45 f8	 inc	 DWORD PTR _i$[ebp]
  00172	83 7d f8 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00176	0f 8c a6 fe ff
	ff		 jl	 $LL40@compile_8k
  0017c	5f		 pop	 edi
  0017d	5e		 pop	 esi
  0017e	5b		 pop	 ebx

; 516  :             }
; 517  :         }
; 518  :     }
; 519  : }

  0017f	c9		 leave
  00180	c2 08 00	 ret	 8
_compile_8k_table@8 ENDP
_TEXT	ENDS
PUBLIC	_compile_4k_table64@8
; Function compile flags: /Ogsp
;	COMDAT _compile_4k_table64@8
_TEXT	SEGMENT
tv297 = -12						; size = 4
tv175 = -8						; size = 4
_i$ = -4						; size = 4
_a$ = 8							; size = 4
tv288 = 12						; size = 4
_ctx$ = 12						; size = 4
_compile_4k_table64@8 PROC				; COMDAT

; 523  : {   int i, j, k;

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00008	53		 push	 ebx
  00009	56		 push	 esi

; 524  : 
; 525  :     memset(ctx->gf_t4k, 0, sizeof(ctx->gf_t4k));

  0000a	8b 75 0c	 mov	 esi, DWORD PTR _ctx$[ebp]
  0000d	57		 push	 edi
  0000e	68 00 10 00 00	 push	 4096			; 00001000H
  00013	6a 00		 push	 0
  00015	56		 push	 esi
  00016	e8 00 00 00 00	 call	 _memset
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 526  :     for(i = 0; i < 2 * CBLK_LEN8; ++i)

  0001e	83 65 fc 00	 and	 DWORD PTR _i$[ebp], 0
$LL36@compile_4k:

; 527  :     {
; 528  :         if(i == 0)

  00022	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00025	85 c0		 test	 eax, eax
  00027	0f 85 85 00 00
	00		 jne	 $LN18@compile_4k

; 529  :         {
; 530  :             memcpy(ctx->gf_t4k[1][8], a, CBLK_LEN8);

  0002d	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	89 8e 80 01 00
	00		 mov	 DWORD PTR [esi+384], ecx
  00038	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 531  :             for(j = 4; j > 0; j >>= 1)

  0003b	6a 04		 push	 4
  0003d	89 86 84 01 00
	00		 mov	 DWORD PTR [esi+388], eax
  00043	5f		 pop	 edi
$LL17@compile_4k:

; 532  :             {
; 533  :                 memcpy(ctx->gf_t4k[1][j], ctx->gf_t4k[1][j + j], CBLK_LEN8);

  00044	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
  00047	c1 e0 04	 shl	 eax, 4
  0004a	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  0004d	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  00050	c1 e0 05	 shl	 eax, 5
  00053	8b 14 30	 mov	 edx, DWORD PTR [eax+esi]
  00056	89 11		 mov	 DWORD PTR [ecx], edx
  00058	8b 44 30 04	 mov	 eax, DWORD PTR [eax+esi+4]

; 534  :                 mul_x64(ctx->gf_t4k[1][j]);

  0005c	51		 push	 ecx
  0005d	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00060	e8 00 00 00 00	 call	 _mul_x64@4
  00065	d1 ff		 sar	 edi, 1
  00067	85 ff		 test	 edi, edi
  00069	7f d9		 jg	 SHORT $LL17@compile_4k

; 535  :             }
; 536  :             memcpy(ctx->gf_t4k[0][8], ctx->gf_t4k[1][1], CBLK_LEN8);

  0006b	8b 8e 10 01 00
	00		 mov	 ecx, DWORD PTR [esi+272]
  00071	8d 86 80 00 00
	00		 lea	 eax, DWORD PTR [esi+128]
  00077	89 08		 mov	 DWORD PTR [eax], ecx
  00079	8b 8e 14 01 00
	00		 mov	 ecx, DWORD PTR [esi+276]

; 537  :             mul_x64(ctx->gf_t4k[0][8]);

  0007f	50		 push	 eax
  00080	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00083	e8 00 00 00 00	 call	 _mul_x64@4

; 538  :             for(j = 4; j > 0; j >>= 1)

  00088	6a 04		 push	 4
  0008a	5f		 pop	 edi
$LL14@compile_4k:

; 539  :             {
; 540  :                 memcpy(ctx->gf_t4k[0][j], ctx->gf_t4k[0][j + j], CBLK_LEN8);

  0008b	8b c7		 mov	 eax, edi
  0008d	c1 e0 04	 shl	 eax, 4
  00090	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  00093	8b c7		 mov	 eax, edi
  00095	c1 e0 05	 shl	 eax, 5
  00098	8b 14 30	 mov	 edx, DWORD PTR [eax+esi]
  0009b	89 11		 mov	 DWORD PTR [ecx], edx
  0009d	8b 44 30 04	 mov	 eax, DWORD PTR [eax+esi+4]

; 541  :                 mul_x64(ctx->gf_t4k[0][j]);

  000a1	51		 push	 ecx
  000a2	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  000a5	e8 00 00 00 00	 call	 _mul_x64@4
  000aa	d1 ff		 sar	 edi, 1
  000ac	85 ff		 test	 edi, edi
  000ae	7f db		 jg	 SHORT $LL14@compile_4k

; 542  :             }
; 543  :         }
; 544  :         else if(i > 1)

  000b0	eb 3e		 jmp	 SHORT $LN7@compile_4k
$LN18@compile_4k:
  000b2	83 f8 01	 cmp	 eax, 1
  000b5	7e 39		 jle	 SHORT $LN7@compile_4k

; 545  :             for(j = 8; j > 0; j >>= 1)

  000b7	8d 58 fe	 lea	 ebx, DWORD PTR [eax-2]
  000ba	6a 08		 push	 8
  000bc	89 45 0c	 mov	 DWORD PTR tv288[ebp], eax
  000bf	c1 e3 04	 shl	 ebx, 4
  000c2	c1 65 0c 04	 shl	 DWORD PTR tv288[ebp], 4
  000c6	5f		 pop	 edi
$LL37@compile_4k:

; 546  :             {
; 547  :                 memcpy(ctx->gf_t4k[i][j], ctx->gf_t4k[i - 2][j], CBLK_LEN8);

  000c7	8b 45 0c	 mov	 eax, DWORD PTR tv288[ebp]
  000ca	03 c7		 add	 eax, edi
  000cc	c1 e0 04	 shl	 eax, 4
  000cf	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  000d2	8d 04 3b	 lea	 eax, DWORD PTR [ebx+edi]
  000d5	c1 e0 04	 shl	 eax, 4
  000d8	8b 14 30	 mov	 edx, DWORD PTR [eax+esi]
  000db	8b 44 30 04	 mov	 eax, DWORD PTR [eax+esi+4]

; 548  :                 mul_x8_64(ctx->gf_t4k[i][j]);

  000df	51		 push	 ecx
  000e0	89 11		 mov	 DWORD PTR [ecx], edx
  000e2	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  000e5	e8 00 00 00 00	 call	 _mul_lex8_64@4
  000ea	d1 ff		 sar	 edi, 1
  000ec	85 ff		 test	 edi, edi
  000ee	7f d7		 jg	 SHORT $LL37@compile_4k
$LN7@compile_4k:

; 549  :             }
; 550  : 
; 551  :         for(j = 2; j < 16; j += j)

  000f0	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000f3	8b c8		 mov	 ecx, eax
  000f5	c1 e1 08	 shl	 ecx, 8
  000f8	6a 02		 push	 2
  000fa	8d 4c 31 10	 lea	 ecx, DWORD PTR [ecx+esi+16]
  000fe	89 45 0c	 mov	 DWORD PTR tv288[ebp], eax
  00101	c1 65 0c 04	 shl	 DWORD PTR tv288[ebp], 4
  00105	5f		 pop	 edi
  00106	89 4d f4	 mov	 DWORD PTR tv297[ebp], ecx
$LL38@compile_4k:

; 552  :         {
; 553  :             mode(32t) *pj = ctx->gf_t4k[i][j];

  00109	8b 45 0c	 mov	 eax, DWORD PTR tv288[ebp]

; 554  :             mode(32t) *pk = ctx->gf_t4k[i][1];

  0010c	8b 55 f4	 mov	 edx, DWORD PTR tv297[ebp]
  0010f	03 c7		 add	 eax, edi
  00111	c1 e0 04	 shl	 eax, 4
  00114	03 c6		 add	 eax, esi

; 555  :             mode(32t) *pl = ctx->gf_t4k[i][j + 1];
; 556  : 
; 557  :             for(k = 1; k < j; ++k)

  00116	83 ff 01	 cmp	 edi, 1
  00119	8d 48 10	 lea	 ecx, DWORD PTR [eax+16]
  0011c	7e 3e		 jle	 SHORT $LN5@compile_4k
  0011e	8d 5f ff	 lea	 ebx, DWORD PTR [edi-1]
  00121	89 5d f8	 mov	 DWORD PTR tv175[ebp], ebx
$LL3@compile_4k:

; 558  :             {
; 559  :                 *pl++ = pj[0] ^ *pk++;

  00124	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00126	33 18		 xor	 ebx, DWORD PTR [eax]
  00128	83 c2 04	 add	 edx, 4
  0012b	89 19		 mov	 DWORD PTR [ecx], ebx

; 560  :                 *pl++ = pj[1] ^ *pk++;

  0012d	8b 1a		 mov	 ebx, DWORD PTR [edx]
  0012f	33 58 04	 xor	 ebx, DWORD PTR [eax+4]
  00132	83 c1 04	 add	 ecx, 4
  00135	89 19		 mov	 DWORD PTR [ecx], ebx
  00137	83 c2 04	 add	 edx, 4

; 561  :                 *pl++ = pj[2] ^ *pk++;

  0013a	8b 1a		 mov	 ebx, DWORD PTR [edx]
  0013c	33 58 08	 xor	 ebx, DWORD PTR [eax+8]
  0013f	83 c1 04	 add	 ecx, 4
  00142	89 19		 mov	 DWORD PTR [ecx], ebx
  00144	83 c2 04	 add	 edx, 4

; 562  :                 *pl++ = pj[3] ^ *pk++;

  00147	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00149	33 58 0c	 xor	 ebx, DWORD PTR [eax+12]
  0014c	83 c1 04	 add	 ecx, 4
  0014f	89 19		 mov	 DWORD PTR [ecx], ebx
  00151	83 c1 04	 add	 ecx, 4
  00154	83 c2 04	 add	 edx, 4
  00157	ff 4d f8	 dec	 DWORD PTR tv175[ebp]
  0015a	75 c8		 jne	 SHORT $LL3@compile_4k
$LN5@compile_4k:

; 549  :             }
; 550  : 
; 551  :         for(j = 2; j < 16; j += j)

  0015c	03 ff		 add	 edi, edi
  0015e	83 ff 10	 cmp	 edi, 16			; 00000010H
  00161	7c a6		 jl	 SHORT $LL38@compile_4k
  00163	ff 45 fc	 inc	 DWORD PTR _i$[ebp]
  00166	83 7d fc 10	 cmp	 DWORD PTR _i$[ebp], 16	; 00000010H
  0016a	0f 8c b2 fe ff
	ff		 jl	 $LL36@compile_4k
  00170	5f		 pop	 edi
  00171	5e		 pop	 esi
  00172	5b		 pop	 ebx

; 563  :             }
; 564  :         }
; 565  :     }
; 566  : }

  00173	c9		 leave
  00174	c2 08 00	 ret	 8
_compile_4k_table64@8 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _IsBitSet128@8
_TEXT	SEGMENT
_bit$ = 8						; size = 4
_IsBitSet128@8 PROC					; COMDAT
; _a$ = edx

; 569  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 570  : 	return a[(127 - bit) / 8] & (0x80 >> ((127 - bit) % 8));

  00005	83 c9 ff	 or	 ecx, -1
  00008	2b 4d 08	 sub	 ecx, DWORD PTR _bit$[ebp]
  0000b	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  00010	83 e1 07	 and	 ecx, 7
  00013	d3 f8		 sar	 eax, cl
  00015	6a 7f		 push	 127			; 0000007fH
  00017	59		 pop	 ecx
  00018	2b 4d 08	 sub	 ecx, DWORD PTR _bit$[ebp]
  0001b	c1 e9 03	 shr	 ecx, 3
  0001e	0f b6 0c 11	 movzx	 ecx, BYTE PTR [ecx+edx]
  00022	23 c1		 and	 eax, ecx

; 571  : }

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
_IsBitSet128@8 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _IsBitSet64@8
_TEXT	SEGMENT
_bit$ = 8						; size = 4
_IsBitSet64@8 PROC					; COMDAT
; _a$ = edx

; 574  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 575  : 	return a[(63 - bit) / 8] & (0x80 >> ((63 - bit) % 8));

  00005	83 c9 ff	 or	 ecx, -1
  00008	2b 4d 08	 sub	 ecx, DWORD PTR _bit$[ebp]
  0000b	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  00010	83 e1 07	 and	 ecx, 7
  00013	d3 f8		 sar	 eax, cl
  00015	6a 3f		 push	 63			; 0000003fH
  00017	59		 pop	 ecx
  00018	2b 4d 08	 sub	 ecx, DWORD PTR _bit$[ebp]
  0001b	c1 e9 03	 shr	 ecx, 3
  0001e	0f b6 0c 11	 movzx	 ecx, BYTE PTR [ecx+edx]
  00022	23 c1		 and	 eax, ecx

; 576  : }

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
_IsBitSet64@8 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _SetBit128@8
_TEXT	SEGMENT
_bit$ = 8						; size = 4
_SetBit128@8 PROC					; COMDAT
; _a$ = ecx

; 579  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 580  : 	a[(127 - bit) / 8] |= 0x80 >> ((127 - bit) % 8);

  00005	6a 7f		 push	 127			; 0000007fH
  00007	58		 pop	 eax
  00008	2b 45 08	 sub	 eax, DWORD PTR _bit$[ebp]
  0000b	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00010	c1 e8 03	 shr	 eax, 3
  00013	03 c1		 add	 eax, ecx
  00015	83 c9 ff	 or	 ecx, -1
  00018	2b 4d 08	 sub	 ecx, DWORD PTR _bit$[ebp]
  0001b	83 e1 07	 and	 ecx, 7
  0001e	d3 fa		 sar	 edx, cl
  00020	08 10		 or	 BYTE PTR [eax], dl

; 581  : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
_SetBit128@8 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _SetBit64@8
_TEXT	SEGMENT
_bit$ = 8						; size = 4
_SetBit64@8 PROC					; COMDAT
; _a$ = ecx

; 584  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 585  : 	a[(63 - bit) / 8] |= 0x80 >> ((63 - bit) % 8);

  00005	6a 3f		 push	 63			; 0000003fH
  00007	58		 pop	 eax
  00008	2b 45 08	 sub	 eax, DWORD PTR _bit$[ebp]
  0000b	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00010	c1 e8 03	 shr	 eax, 3
  00013	03 c1		 add	 eax, ecx
  00015	83 c9 ff	 or	 ecx, -1
  00018	2b 4d 08	 sub	 ecx, DWORD PTR _bit$[ebp]
  0001b	83 e1 07	 and	 ecx, 7
  0001e	d3 fa		 sar	 edx, cl
  00020	08 10		 or	 BYTE PTR [eax], dl

; 586  : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
_SetBit64@8 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_MirrorBits128@4
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _MirrorBits128@4
_TEXT	SEGMENT
_t$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_MirrorBits128@4 PROC					; COMDAT

; 589  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 14	 sub	 esp, 20			; 00000014H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00012	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi

; 590  : 	unsigned __int8 t[128 / 8];
; 591  : 	int i;
; 592  : 	memset (t,0,16);

  00018	33 c0		 xor	 eax, eax
  0001a	8d 7d ec	 lea	 edi, DWORD PTR _t$[ebp]
  0001d	ab		 stosd
  0001e	ab		 stosd
  0001f	ab		 stosd
  00020	ab		 stosd

; 593  : 	for (i = 0; i < 128; i++)

  00021	33 db		 xor	 ebx, ebx
  00023	bf 80 00 00 00	 mov	 edi, 128		; 00000080H
$LL9@MirrorBits:

; 594  : 	{
; 595  : 		if (IsBitSet128(i, a))

  00028	53		 push	 ebx
  00029	e8 00 00 00 00	 call	 _IsBitSet128@8
  0002e	85 c0		 test	 eax, eax
  00030	74 1f		 je	 SHORT $LN8@MirrorBits

; 596  : 			SetBit128 (127 - i, t);

  00032	6a 7f		 push	 127			; 0000007fH
  00034	58		 pop	 eax
  00035	2b c3		 sub	 eax, ebx
  00037	83 c9 ff	 or	 ecx, -1
  0003a	6a 7f		 push	 127			; 0000007fH
  0003c	2b c8		 sub	 ecx, eax
  0003e	5e		 pop	 esi
  0003f	2b f0		 sub	 esi, eax
  00041	83 e1 07	 and	 ecx, 7
  00044	8b c7		 mov	 eax, edi
  00046	c1 ee 03	 shr	 esi, 3
  00049	d3 f8		 sar	 eax, cl
  0004b	8d 74 35 ec	 lea	 esi, DWORD PTR _t$[ebp+esi]
  0004f	08 06		 or	 BYTE PTR [esi], al
$LN8@MirrorBits:
  00051	43		 inc	 ebx
  00052	3b df		 cmp	 ebx, edi
  00054	7c d2		 jl	 SHORT $LL9@MirrorBits

; 597  : 	}
; 598  : 	memcpy (a, t, sizeof (t));

  00056	8b fa		 mov	 edi, edx
  00058	8d 75 ec	 lea	 esi, DWORD PTR _t$[ebp]
  0005b	a5		 movsd
  0005c	a5		 movsd
  0005d	a5		 movsd

; 599  : 	burn (t,sizeof (t));

  0005e	6a 10		 push	 16			; 00000010H
  00060	a5		 movsd
  00061	8d 4d ec	 lea	 ecx, DWORD PTR _t$[ebp]
  00064	5e		 pop	 esi
  00065	8b d6		 mov	 edx, esi
  00067	8b c1		 mov	 eax, ecx
$LL15@MirrorBits:
  00069	c6 00 00	 mov	 BYTE PTR [eax], 0
  0006c	40		 inc	 eax
  0006d	4e		 dec	 esi
  0006e	75 f9		 jne	 SHORT $LL15@MirrorBits
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx
$LL2@MirrorBits:
  00073	4a		 dec	 edx
  00074	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00077	41		 inc	 ecx
  00078	85 d2		 test	 edx, edx
  0007a	75 f7		 jne	 SHORT $LL2@MirrorBits

; 600  : }

  0007c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007f	33 cd		 xor	 ecx, ebp
  00081	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00086	c9		 leave
  00087	c2 04 00	 ret	 4
_MirrorBits128@4 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_MirrorBits64@4
; Function compile flags: /Ogsp
;	COMDAT _MirrorBits64@4
_TEXT	SEGMENT
_t$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_MirrorBits64@4 PROC					; COMDAT

; 603  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00012	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00015	56		 push	 esi
  00016	57		 push	 edi

; 604  : 	unsigned __int8 t[64 / 8];
; 605  : 	int i;
; 606  : 	memset (t,0,8);

  00017	33 c0		 xor	 eax, eax
  00019	8d 7d f4	 lea	 edi, DWORD PTR _t$[ebp]
  0001c	ab		 stosd
  0001d	ab		 stosd

; 607  : 	for (i = 0; i < 64; i++)

  0001e	33 ff		 xor	 edi, edi
$LL9@MirrorBits@2:

; 608  : 	{
; 609  : 		if (IsBitSet64(i, a))

  00020	57		 push	 edi
  00021	e8 00 00 00 00	 call	 _IsBitSet64@8
  00026	85 c0		 test	 eax, eax
  00028	74 22		 je	 SHORT $LN8@MirrorBits@2

; 610  : 			SetBit64 (63 - i, t);

  0002a	6a 3f		 push	 63			; 0000003fH
  0002c	58		 pop	 eax
  0002d	2b c7		 sub	 eax, edi
  0002f	83 c9 ff	 or	 ecx, -1
  00032	6a 3f		 push	 63			; 0000003fH
  00034	2b c8		 sub	 ecx, eax
  00036	5e		 pop	 esi
  00037	2b f0		 sub	 esi, eax
  00039	83 e1 07	 and	 ecx, 7
  0003c	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  00041	c1 ee 03	 shr	 esi, 3
  00044	d3 f8		 sar	 eax, cl
  00046	8d 74 35 f4	 lea	 esi, DWORD PTR _t$[ebp+esi]
  0004a	08 06		 or	 BYTE PTR [esi], al
$LN8@MirrorBits@2:
  0004c	47		 inc	 edi
  0004d	83 ff 40	 cmp	 edi, 64			; 00000040H
  00050	7c ce		 jl	 SHORT $LL9@MirrorBits@2

; 611  : 	}
; 612  : 	memcpy (a, t, sizeof (t));

  00052	8b 45 f4	 mov	 eax, DWORD PTR _t$[ebp]
  00055	89 02		 mov	 DWORD PTR [edx], eax
  00057	8b 45 f8	 mov	 eax, DWORD PTR _t$[ebp+4]

; 613  : 	burn (t,sizeof (t));

  0005a	6a 08		 push	 8
  0005c	89 42 04	 mov	 DWORD PTR [edx+4], eax
  0005f	8d 4d f4	 lea	 ecx, DWORD PTR _t$[ebp]
  00062	5e		 pop	 esi
  00063	8b d6		 mov	 edx, esi
  00065	8b c1		 mov	 eax, ecx
$LL15@MirrorBits@2:
  00067	c6 00 00	 mov	 BYTE PTR [eax], 0
  0006a	40		 inc	 eax
  0006b	4e		 dec	 esi
  0006c	75 f9		 jne	 SHORT $LL15@MirrorBits@2
  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
$LL2@MirrorBits@2:
  00070	4a		 dec	 edx
  00071	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00074	41		 inc	 ecx
  00075	85 d2		 test	 edx, edx
  00077	75 f7		 jne	 SHORT $LL2@MirrorBits@2

; 614  : }

  00079	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007c	33 cd		 xor	 ecx, ebp
  0007e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00083	c9		 leave
  00084	c2 04 00	 ret	 4
_MirrorBits64@4 ENDP
_TEXT	ENDS
PUBLIC	_ctx$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_Gf128Tab64Init@8
EXTRN	__imp__ExFreePoolWithTag@8:PROC
EXTRN	__imp__ExAllocatePoolWithTag@12:PROC
; Function compile flags: /Ogsp
;	COMDAT _Gf128Tab64Init@8
_TEXT	SEGMENT
_ctx$GSCopy$ = -40					; size = 4
_ctx8k$ = -36						; size = 4
tv298 = -32						; size = 4
tv382 = -28						; size = 4
tv366 = -24						; size = 4
_am$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_ctx$ = 12						; size = 4
_Gf128Tab64Init@8 PROC					; COMDAT

; 619  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 28	 sub	 esp, 40			; 00000028H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00012	8b 45 0c	 mov	 eax, DWORD PTR _ctx$[ebp]
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	8b 75 08	 mov	 esi, DWORD PTR _a$[ebp]

; 620  : 	GfCtx8k *ctx8k;
; 621  : 	unsigned __int8 am[16];
; 622  : 	int i, j;
; 623  : 
; 624  : 	ctx8k = (GfCtx8k *) TCalloc (sizeof (GfCtx8k));

  0001a	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0001f	68 00 20 00 00	 push	 8192			; 00002000H
  00024	6a 00		 push	 0
  00026	89 45 d8	 mov	 DWORD PTR _ctx$GSCopy$[ebp], eax
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0002f	8b d8		 mov	 ebx, eax
  00031	89 5d dc	 mov	 DWORD PTR _ctx8k$[ebp], ebx

; 625  : 	if (!ctx8k)

  00034	85 db		 test	 ebx, ebx
  00036	0f 84 d3 00 00
	00		 je	 $LN18@Gf128Tab64
$LN17@Gf128Tab64:
  0003c	57		 push	 edi

; 626  : 		return FALSE;
; 627  : 
; 628  : 	memcpy (am, a, 16);

  0003d	8d 7d ec	 lea	 edi, DWORD PTR _am$[ebp]
  00040	a5		 movsd
  00041	a5		 movsd
  00042	a5		 movsd

; 629  : 	MirrorBits128 (am);

  00043	8d 45 ec	 lea	 eax, DWORD PTR _am$[ebp]
  00046	50		 push	 eax
  00047	a5		 movsd
  00048	e8 00 00 00 00	 call	 _MirrorBits128@4

; 630  :     compile_8k_table (am, ctx8k);

  0004d	53		 push	 ebx
  0004e	8d 45 ec	 lea	 eax, DWORD PTR _am$[ebp]
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 _compile_8k_table@8
  00057	83 65 e8 00	 and	 DWORD PTR tv366[ebp], 0
  0005b	81 c3 00 0f 00
	00		 add	 ebx, 3840		; 00000f00H
  00061	89 5d e4	 mov	 DWORD PTR tv382[ebp], ebx
$LL48@Gf128Tab64:

; 631  : 
; 632  : 	/* Convert 8k LSB-first table to 4k MSB-first */
; 633  : 	for (i = 16; i < 32; i++) 
; 634  : 	{
; 635  : 		for (j = 0; j < 16; j++) 

  00064	8b 45 e4	 mov	 eax, DWORD PTR tv382[ebp]
  00067	33 db		 xor	 ebx, ebx
  00069	89 45 e0	 mov	 DWORD PTR tv298[ebp], eax
$LL49@Gf128Tab64:

; 636  : 		{
; 637  : 			int jm = 0;
; 638  : 			jm |= (j & 0x1) << 3;
; 639  : 			jm |= (j & 0x2) << 1;
; 640  : 			jm |= (j & 0x4) >> 1;
; 641  : 			jm |= (j & 0x8) >> 3;
; 642  : 
; 643  : 			memcpy (&ctx->gf_t128[i-16][jm], (unsigned char *)&ctx8k->gf_t8k[31-i][j], 16);

  0006c	8b 75 e0	 mov	 esi, DWORD PTR tv298[ebp]
  0006f	8b c3		 mov	 eax, ebx
  00071	c1 f8 02	 sar	 eax, 2
  00074	83 e0 02	 and	 eax, 2
  00077	8b cb		 mov	 ecx, ebx
  00079	83 e1 04	 and	 ecx, 4
  0007c	0b c1		 or	 eax, ecx
  0007e	8b cb		 mov	 ecx, ebx
  00080	83 e1 01	 and	 ecx, 1
  00083	c1 e1 02	 shl	 ecx, 2
  00086	8b d3		 mov	 edx, ebx
  00088	83 e2 02	 and	 edx, 2
  0008b	0b ca		 or	 ecx, edx
  0008d	03 c9		 add	 ecx, ecx
  0008f	d1 f8		 sar	 eax, 1
  00091	0b c1		 or	 eax, ecx
  00093	8b 4d e8	 mov	 ecx, DWORD PTR tv366[ebp]
  00096	03 c8		 add	 ecx, eax
  00098	8b 45 d8	 mov	 eax, DWORD PTR _ctx$GSCopy$[ebp]
  0009b	c1 e1 04	 shl	 ecx, 4
  0009e	03 c1		 add	 eax, ecx
  000a0	8b f8		 mov	 edi, eax
  000a2	a5		 movsd
  000a3	a5		 movsd
  000a4	a5		 movsd

; 644  : 			MirrorBits128 ((unsigned char *)&ctx->gf_t128[i-16][jm]);

  000a5	50		 push	 eax
  000a6	a5		 movsd
  000a7	e8 00 00 00 00	 call	 _MirrorBits128@4
  000ac	83 45 e0 10	 add	 DWORD PTR tv298[ebp], 16 ; 00000010H
  000b0	43		 inc	 ebx
  000b1	83 fb 10	 cmp	 ebx, 16			; 00000010H
  000b4	7c b6		 jl	 SHORT $LL49@Gf128Tab64
  000b6	83 45 e8 10	 add	 DWORD PTR tv366[ebp], 16 ; 00000010H
  000ba	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  000bf	29 45 e4	 sub	 DWORD PTR tv382[ebp], eax
  000c2	39 45 e8	 cmp	 DWORD PTR tv366[ebp], eax
  000c5	7c 9d		 jl	 SHORT $LL48@Gf128Tab64

; 645  : 		}
; 646  : 	}
; 647  : 
; 648  : 	burn (ctx8k ,sizeof (*ctx8k));

  000c7	8b 55 dc	 mov	 edx, DWORD PTR _ctx8k$[ebp]
  000ca	b8 00 20 00 00	 mov	 eax, 8192		; 00002000H
  000cf	8b f0		 mov	 esi, eax
  000d1	8b ca		 mov	 ecx, edx
  000d3	5f		 pop	 edi
$LL21@Gf128Tab64:
  000d4	c6 01 00	 mov	 BYTE PTR [ecx], 0
  000d7	41		 inc	 ecx
  000d8	48		 dec	 eax
  000d9	75 f9		 jne	 SHORT $LL21@Gf128Tab64
$LL7@Gf128Tab64:
  000db	4e		 dec	 esi
  000dc	c6 02 00	 mov	 BYTE PTR [edx], 0
  000df	42		 inc	 edx
  000e0	85 f6		 test	 esi, esi
  000e2	75 f7		 jne	 SHORT $LL7@Gf128Tab64

; 649  : 	burn (am, sizeof (am));

  000e4	6a 10		 push	 16			; 00000010H
  000e6	8d 4d ec	 lea	 ecx, DWORD PTR _am$[ebp]
  000e9	5e		 pop	 esi
  000ea	8b d6		 mov	 edx, esi
  000ec	8b c1		 mov	 eax, ecx
$LL25@Gf128Tab64:
  000ee	c6 00 00	 mov	 BYTE PTR [eax], 0
  000f1	40		 inc	 eax
  000f2	4e		 dec	 esi
  000f3	75 f9		 jne	 SHORT $LL25@Gf128Tab64
$LL2@Gf128Tab64:
  000f5	4a		 dec	 edx
  000f6	c6 01 00	 mov	 BYTE PTR [ecx], 0
  000f9	41		 inc	 ecx
  000fa	85 d2		 test	 edx, edx
  000fc	75 f7		 jne	 SHORT $LL2@Gf128Tab64

; 650  : 	TCfree (ctx8k);

  000fe	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00103	ff 75 dc	 push	 DWORD PTR _ctx8k$[ebp]
  00106	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 651  : 	return TRUE;

  0010c	33 c0		 xor	 eax, eax
  0010e	40		 inc	 eax
$LN18@Gf128Tab64:

; 652  : }

  0010f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00112	5e		 pop	 esi
  00113	33 cd		 xor	 ecx, ebp
  00115	5b		 pop	 ebx
  00116	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011b	c9		 leave
  0011c	c2 08 00	 ret	 8
_Gf128Tab64Init@8 ENDP
_TEXT	ENDS
PUBLIC	_ctx$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_Gf64TabInit@8
; Function compile flags: /Ogsp
;	COMDAT _Gf64TabInit@8
_TEXT	SEGMENT
_ctx$GSCopy$ = -28					; size = 4
tv382 = -24						; size = 4
_ctx4k$ = -20						; size = 4
tv366 = -16						; size = 4
_am$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_ctx$ = 12						; size = 4
_Gf64TabInit@8 PROC					; COMDAT

; 655  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00012	8b 45 0c	 mov	 eax, DWORD PTR _ctx$[ebp]
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	8b 75 08	 mov	 esi, DWORD PTR _a$[ebp]
  0001a	57		 push	 edi

; 656  : 	/* Deprecated/legacy */
; 657  : 
; 658  : 	GfCtx4k64 *ctx4k;
; 659  : 	unsigned __int8 am[8];
; 660  : 	int i, j;
; 661  : 
; 662  : 	ctx4k = (GfCtx4k64 *) TCalloc (sizeof (GfCtx4k64));

  0001b	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00020	bb 00 10 00 00	 mov	 ebx, 4096		; 00001000H
  00025	53		 push	 ebx
  00026	6a 00		 push	 0
  00028	89 45 e4	 mov	 DWORD PTR _ctx$GSCopy$[ebp], eax
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00031	8b f8		 mov	 edi, eax
  00033	89 7d ec	 mov	 DWORD PTR _ctx4k$[ebp], edi

; 663  : 	if (!ctx4k)

  00036	85 ff		 test	 edi, edi
  00038	0f 84 d1 00 00
	00		 je	 $LN18@Gf64TabIni
$LN17@Gf64TabIni:

; 664  : 		return FALSE;
; 665  : 
; 666  : 	memcpy (am, a, 8);

  0003e	8b 06		 mov	 eax, DWORD PTR [esi]
  00040	89 45 f4	 mov	 DWORD PTR _am$[ebp], eax
  00043	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00046	89 45 f8	 mov	 DWORD PTR _am$[ebp+4], eax

; 667  : 	MirrorBits64 (am);

  00049	8d 45 f4	 lea	 eax, DWORD PTR _am$[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _MirrorBits64@4

; 668  :     compile_4k_table64 (am, ctx4k);

  00052	57		 push	 edi
  00053	8d 45 f4	 lea	 eax, DWORD PTR _am$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 _compile_4k_table64@8
  0005c	81 c7 00 0f 00
	00		 add	 edi, 3840		; 00000f00H
  00062	c7 45 f0 00 02
	00 00		 mov	 DWORD PTR tv366[ebp], 512 ; 00000200H
  00069	89 7d e8	 mov	 DWORD PTR tv382[ebp], edi
$LL48@Gf64TabIni:

; 669  : 
; 670  : 	/* Convert LSB-first table to MSB-first */
; 671  : 	for (i = 0; i < 16; i++) 
; 672  : 	{
; 673  : 		for (j = 0; j < 16; j++) 

  0006c	8b 75 e8	 mov	 esi, DWORD PTR tv382[ebp]
  0006f	33 ff		 xor	 edi, edi
$LL13@Gf64TabIni:

; 674  : 		{
; 675  : 			int jm = 0;
; 676  : 			jm |= (j & 0x1) << 3;
; 677  : 			jm |= (j & 0x2) << 1;
; 678  : 			jm |= (j & 0x4) >> 1;
; 679  : 			jm |= (j & 0x8) >> 3;

  00071	8b c7		 mov	 eax, edi
  00073	c1 f8 02	 sar	 eax, 2
  00076	83 e0 02	 and	 eax, 2
  00079	8b cf		 mov	 ecx, edi
  0007b	83 e1 04	 and	 ecx, 4
  0007e	0b c1		 or	 eax, ecx
  00080	8b cf		 mov	 ecx, edi
  00082	83 e1 01	 and	 ecx, 1
  00085	c1 e1 02	 shl	 ecx, 2
  00088	8b d7		 mov	 edx, edi
  0008a	83 e2 02	 and	 edx, 2
  0008d	0b ca		 or	 ecx, edx
  0008f	03 c9		 add	 ecx, ecx
  00091	d1 f8		 sar	 eax, 1
  00093	0b c1		 or	 eax, ecx

; 680  : 
; 681  : 			memcpy (&ctx->gf_t64[i][jm], (unsigned char *)&ctx4k->gf_t4k[15-i][j], 8);

  00095	8b 4d f0	 mov	 ecx, DWORD PTR tv366[ebp]
  00098	03 c8		 add	 ecx, eax
  0009a	8b 45 e4	 mov	 eax, DWORD PTR _ctx$GSCopy$[ebp]
  0009d	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]
  000a0	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000a2	89 08		 mov	 DWORD PTR [eax], ecx
  000a4	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 682  : 			MirrorBits64 ((unsigned char *)&ctx->gf_t64[i][jm]);

  000a7	50		 push	 eax
  000a8	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  000ab	e8 00 00 00 00	 call	 _MirrorBits64@4
  000b0	47		 inc	 edi
  000b1	83 c6 10	 add	 esi, 16			; 00000010H
  000b4	83 ff 10	 cmp	 edi, 16			; 00000010H
  000b7	7c b8		 jl	 SHORT $LL13@Gf64TabIni
  000b9	83 45 f0 10	 add	 DWORD PTR tv366[ebp], 16 ; 00000010H
  000bd	81 6d e8 00 01
	00 00		 sub	 DWORD PTR tv382[ebp], 256 ; 00000100H
  000c4	81 7d f0 00 03
	00 00		 cmp	 DWORD PTR tv366[ebp], 768 ; 00000300H
  000cb	7c 9f		 jl	 SHORT $LL48@Gf64TabIni

; 683  : 		}
; 684  : 	}
; 685  : 
; 686  : 	burn (ctx4k,sizeof (*ctx4k));

  000cd	8b 4d ec	 mov	 ecx, DWORD PTR _ctx4k$[ebp]
  000d0	8b d3		 mov	 edx, ebx
  000d2	8b c1		 mov	 eax, ecx
$LL21@Gf64TabIni:
  000d4	c6 00 00	 mov	 BYTE PTR [eax], 0
  000d7	40		 inc	 eax
  000d8	4b		 dec	 ebx
  000d9	75 f9		 jne	 SHORT $LL21@Gf64TabIni
$LL7@Gf64TabIni:
  000db	4a		 dec	 edx
  000dc	c6 01 00	 mov	 BYTE PTR [ecx], 0
  000df	41		 inc	 ecx
  000e0	85 d2		 test	 edx, edx
  000e2	75 f7		 jne	 SHORT $LL7@Gf64TabIni

; 687  : 	burn (am, sizeof (am));

  000e4	6a 08		 push	 8
  000e6	8d 4d f4	 lea	 ecx, DWORD PTR _am$[ebp]
  000e9	5e		 pop	 esi
  000ea	8b d6		 mov	 edx, esi
  000ec	8b c1		 mov	 eax, ecx
$LL25@Gf64TabIni:
  000ee	c6 00 00	 mov	 BYTE PTR [eax], 0
  000f1	40		 inc	 eax
  000f2	4e		 dec	 esi
  000f3	75 f9		 jne	 SHORT $LL25@Gf64TabIni
$LL2@Gf64TabIni:
  000f5	4a		 dec	 edx
  000f6	c6 01 00	 mov	 BYTE PTR [ecx], 0
  000f9	41		 inc	 ecx
  000fa	85 d2		 test	 edx, edx
  000fc	75 f7		 jne	 SHORT $LL2@Gf64TabIni

; 688  : 	TCfree (ctx4k);

  000fe	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00103	ff 75 ec	 push	 DWORD PTR _ctx4k$[ebp]
  00106	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 689  : 	return TRUE;

  0010c	33 c0		 xor	 eax, eax
  0010e	40		 inc	 eax
$LN18@Gf64TabIni:

; 690  : }

  0010f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00112	5f		 pop	 edi
  00113	5e		 pop	 esi
  00114	33 cd		 xor	 ecx, ebp
  00116	5b		 pop	 ebx
  00117	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011c	c9		 leave
  0011d	c2 08 00	 ret	 8
_Gf64TabInit@8 ENDP
_TEXT	ENDS
PUBLIC	_Gf128MulBy64Tab@12
; Function compile flags: /Ogsp
;	COMDAT _Gf128MulBy64Tab@12
_TEXT	SEGMENT
_r$ = -16						; size = 16
_a$ = 8							; size = 4
_p$ = 12						; size = 4
_ctx$ = 16						; size = 4
_Gf128MulBy64Tab@12 PROC				; COMDAT

; 698  : {  

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 10	 sub	 esp, 16			; 00000010H
  00008	53		 push	 ebx

; 699  : 	unsigned __int32 r[CBLK_LEN >> 2];
; 700  : 
; 701  : 	move_block_aligned(r, ctx->gf_t128[7*2][a[7] & 15]);

  00009	8b 5d 10	 mov	 ebx, DWORD PTR _ctx$[ebp]
  0000c	56		 push	 esi
  0000d	8b 75 08	 mov	 esi, DWORD PTR _a$[ebp]
  00010	57		 push	 edi
  00011	0f b6 7e 07	 movzx	 edi, BYTE PTR [esi+7]
  00015	8b c7		 mov	 eax, edi
  00017	83 e0 0f	 and	 eax, 15			; 0000000fH
  0001a	05 e0 00 00 00	 add	 eax, 224		; 000000e0H
  0001f	c1 e0 04	 shl	 eax, 4
  00022	03 c3		 add	 eax, ebx
  00024	50		 push	 eax
  00025	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 _move_block_aligned@8

; 702  :     xor_block_aligned(r,  ctx->gf_t128[7*2+1][a[7] >> 4]);

  0002e	c1 ef 04	 shr	 edi, 4
  00031	81 c7 f0 00 00
	00		 add	 edi, 240		; 000000f0H
  00037	c1 e7 04	 shl	 edi, 4
  0003a	03 fb		 add	 edi, ebx
  0003c	57		 push	 edi
  0003d	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _xor_block_aligned@8

; 703  : 
; 704  : 	if (*(unsigned __int16 *)a)

  00046	66 83 3e 00	 cmp	 WORD PTR [esi], 0
  0004a	74 5c		 je	 SHORT $LN2@Gf128MulBy

; 705  : 	{
; 706  : 		xor_8kt64(0);

  0004c	0f b6 3e	 movzx	 edi, BYTE PTR [esi]
  0004f	8b c7		 mov	 eax, edi
  00051	83 e0 0f	 and	 eax, 15			; 0000000fH
  00054	c1 e0 04	 shl	 eax, 4
  00057	03 c3		 add	 eax, ebx
  00059	50		 push	 eax
  0005a	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 _xor_block_aligned@8
  00063	c1 ef 04	 shr	 edi, 4
  00066	83 c7 10	 add	 edi, 16			; 00000010H
  00069	c1 e7 04	 shl	 edi, 4
  0006c	03 fb		 add	 edi, ebx
  0006e	57		 push	 edi
  0006f	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 _xor_block_aligned@8

; 707  : 		xor_8kt64(1);

  00078	0f b6 7e 01	 movzx	 edi, BYTE PTR [esi+1]
  0007c	8b c7		 mov	 eax, edi
  0007e	83 e0 0f	 and	 eax, 15			; 0000000fH
  00081	83 c0 20	 add	 eax, 32			; 00000020H
  00084	c1 e0 04	 shl	 eax, 4
  00087	03 c3		 add	 eax, ebx
  00089	50		 push	 eax
  0008a	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 _xor_block_aligned@8
  00093	c1 ef 04	 shr	 edi, 4
  00096	83 c7 30	 add	 edi, 48			; 00000030H
  00099	c1 e7 04	 shl	 edi, 4
  0009c	03 fb		 add	 edi, ebx
  0009e	57		 push	 edi
  0009f	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 _xor_block_aligned@8
$LN2@Gf128MulBy:

; 708  : 	}
; 709  : 	if (a[2])

  000a8	8a 46 02	 mov	 al, BYTE PTR [esi+2]
  000ab	84 c0		 test	 al, al
  000ad	74 2f		 je	 SHORT $LN1@Gf128MulBy

; 710  : 	{
; 711  : 		xor_8kt64(2);

  000af	0f b6 f8	 movzx	 edi, al
  000b2	8b c7		 mov	 eax, edi
  000b4	83 e0 0f	 and	 eax, 15			; 0000000fH
  000b7	83 c0 40	 add	 eax, 64			; 00000040H
  000ba	c1 e0 04	 shl	 eax, 4
  000bd	03 c3		 add	 eax, ebx
  000bf	50		 push	 eax
  000c0	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  000c3	50		 push	 eax
  000c4	e8 00 00 00 00	 call	 _xor_block_aligned@8
  000c9	c1 ef 04	 shr	 edi, 4
  000cc	83 c7 50	 add	 edi, 80			; 00000050H
  000cf	c1 e7 04	 shl	 edi, 4
  000d2	03 fb		 add	 edi, ebx
  000d4	57		 push	 edi
  000d5	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 _xor_block_aligned@8
$LN1@Gf128MulBy:

; 712  : 	}
; 713  : 	xor_8kt64(3);

  000de	0f b6 7e 03	 movzx	 edi, BYTE PTR [esi+3]
  000e2	8b c7		 mov	 eax, edi
  000e4	83 e0 0f	 and	 eax, 15			; 0000000fH
  000e7	83 c0 60	 add	 eax, 96			; 00000060H
  000ea	c1 e0 04	 shl	 eax, 4
  000ed	03 c3		 add	 eax, ebx
  000ef	50		 push	 eax
  000f0	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  000f3	50		 push	 eax
  000f4	e8 00 00 00 00	 call	 _xor_block_aligned@8
  000f9	c1 ef 04	 shr	 edi, 4
  000fc	83 c7 70	 add	 edi, 112		; 00000070H
  000ff	c1 e7 04	 shl	 edi, 4
  00102	03 fb		 add	 edi, ebx
  00104	57		 push	 edi
  00105	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 _xor_block_aligned@8

; 714  :     xor_8kt64(4);

  0010e	0f b6 7e 04	 movzx	 edi, BYTE PTR [esi+4]
  00112	8b c7		 mov	 eax, edi
  00114	83 e0 0f	 and	 eax, 15			; 0000000fH
  00117	83 e8 80	 sub	 eax, -128		; ffffff80H
  0011a	c1 e0 04	 shl	 eax, 4
  0011d	03 c3		 add	 eax, ebx
  0011f	50		 push	 eax
  00120	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  00123	50		 push	 eax
  00124	e8 00 00 00 00	 call	 _xor_block_aligned@8
  00129	c1 ef 04	 shr	 edi, 4
  0012c	81 c7 90 00 00
	00		 add	 edi, 144		; 00000090H
  00132	c1 e7 04	 shl	 edi, 4
  00135	03 fb		 add	 edi, ebx
  00137	57		 push	 edi
  00138	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  0013b	50		 push	 eax
  0013c	e8 00 00 00 00	 call	 _xor_block_aligned@8

; 715  : 	xor_8kt64(5);

  00141	0f b6 7e 05	 movzx	 edi, BYTE PTR [esi+5]
  00145	8b c7		 mov	 eax, edi
  00147	83 e0 0f	 and	 eax, 15			; 0000000fH
  0014a	05 a0 00 00 00	 add	 eax, 160		; 000000a0H
  0014f	c1 e0 04	 shl	 eax, 4
  00152	03 c3		 add	 eax, ebx
  00154	50		 push	 eax
  00155	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  00158	50		 push	 eax
  00159	e8 00 00 00 00	 call	 _xor_block_aligned@8
  0015e	c1 ef 04	 shr	 edi, 4
  00161	81 c7 b0 00 00
	00		 add	 edi, 176		; 000000b0H
  00167	c1 e7 04	 shl	 edi, 4
  0016a	03 fb		 add	 edi, ebx
  0016c	57		 push	 edi
  0016d	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  00170	50		 push	 eax
  00171	e8 00 00 00 00	 call	 _xor_block_aligned@8

; 716  : 	xor_8kt64(6);

  00176	0f b6 76 06	 movzx	 esi, BYTE PTR [esi+6]
  0017a	8b c6		 mov	 eax, esi
  0017c	83 e0 0f	 and	 eax, 15			; 0000000fH
  0017f	05 c0 00 00 00	 add	 eax, 192		; 000000c0H
  00184	c1 e0 04	 shl	 eax, 4
  00187	03 c3		 add	 eax, ebx
  00189	50		 push	 eax
  0018a	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  0018d	50		 push	 eax
  0018e	e8 00 00 00 00	 call	 _xor_block_aligned@8
  00193	c1 ee 04	 shr	 esi, 4
  00196	81 c6 d0 00 00
	00		 add	 esi, 208		; 000000d0H
  0019c	c1 e6 04	 shl	 esi, 4
  0019f	03 f3		 add	 esi, ebx
  001a1	56		 push	 esi
  001a2	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  001a5	50		 push	 eax
  001a6	e8 00 00 00 00	 call	 _xor_block_aligned@8

; 717  : 
; 718  :     move_block_aligned(p, r);

  001ab	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  001ae	50		 push	 eax
  001af	ff 75 0c	 push	 DWORD PTR _p$[ebp]
  001b2	e8 00 00 00 00	 call	 _move_block_aligned@8
  001b7	5f		 pop	 edi
  001b8	5e		 pop	 esi
  001b9	5b		 pop	 ebx

; 719  : }

  001ba	c9		 leave
  001bb	c2 0c 00	 ret	 12			; 0000000cH
_Gf128MulBy64Tab@12 ENDP
_TEXT	ENDS
PUBLIC	_Gf64MulTab@12
; Function compile flags: /Ogsp
;	COMDAT _Gf64MulTab@12
_TEXT	SEGMENT
_a$ = 8							; size = 4
_p$ = 12						; size = 4
_ctx$ = 16						; size = 4
_Gf64MulTab@12 PROC					; COMDAT

; 727  : {  

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 728  : 	/* Deprecated/legacy */
; 729  : 
; 730  : 	unsigned __int32 r[CBLK_LEN8 >> 2];
; 731  : 
; 732  : 	move_block_aligned64(r, ctx->gf_t64[7*2][a[7] & 15]);

  00005	8b 55 10	 mov	 edx, DWORD PTR _ctx$[ebp]
  00008	53		 push	 ebx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR _a$[ebp]
  0000d	57		 push	 edi
  0000e	0f b6 7e 07	 movzx	 edi, BYTE PTR [esi+7]
  00012	8b c7		 mov	 eax, edi
  00014	83 e0 0f	 and	 eax, 15			; 0000000fH
  00017	8d 8c c2 00 17
	00 00		 lea	 ecx, DWORD PTR [edx+eax*8+5888]
  0001e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]

; 733  :     xor_block_aligned64(r,  ctx->gf_t64[7*2+1][a[7] >> 4]);

  00023	c1 ef 04	 shr	 edi, 4
  00026	8d bc fa 80 17
	00 00		 lea	 edi, DWORD PTR [edx+edi*8+6016]
  0002d	33 07		 xor	 eax, DWORD PTR [edi]
  0002f	33 4f 04	 xor	 ecx, DWORD PTR [edi+4]

; 734  : 
; 735  : 	if (*(unsigned __int16 *)a)

  00032	66 83 3e 00	 cmp	 WORD PTR [esi], 0
  00036	74 47		 je	 SHORT $LN15@Gf64MulTab

; 736  : 	{
; 737  : 		xor_8k64(0);

  00038	0f b6 3e	 movzx	 edi, BYTE PTR [esi]
  0003b	8b df		 mov	 ebx, edi
  0003d	83 e3 0f	 and	 ebx, 15			; 0000000fH
  00040	8d 9c da 00 10
	00 00		 lea	 ebx, DWORD PTR [edx+ebx*8+4096]
  00047	33 03		 xor	 eax, DWORD PTR [ebx]
  00049	33 4b 04	 xor	 ecx, DWORD PTR [ebx+4]
  0004c	c1 ef 04	 shr	 edi, 4
  0004f	8d bc fa 80 10
	00 00		 lea	 edi, DWORD PTR [edx+edi*8+4224]
  00056	33 07		 xor	 eax, DWORD PTR [edi]
  00058	33 4f 04	 xor	 ecx, DWORD PTR [edi+4]

; 738  : 		xor_8k64(1);

  0005b	0f b6 7e 01	 movzx	 edi, BYTE PTR [esi+1]
  0005f	8b df		 mov	 ebx, edi
  00061	83 e3 0f	 and	 ebx, 15			; 0000000fH
  00064	8d 9c da 00 11
	00 00		 lea	 ebx, DWORD PTR [edx+ebx*8+4352]
  0006b	33 03		 xor	 eax, DWORD PTR [ebx]
  0006d	33 4b 04	 xor	 ecx, DWORD PTR [ebx+4]
  00070	c1 ef 04	 shr	 edi, 4
  00073	8d bc fa 80 11
	00 00		 lea	 edi, DWORD PTR [edx+edi*8+4480]
  0007a	33 07		 xor	 eax, DWORD PTR [edi]
  0007c	33 4f 04	 xor	 ecx, DWORD PTR [edi+4]
$LN15@Gf64MulTab:

; 739  : 	}
; 740  : 	if (a[2])

  0007f	80 7e 02 00	 cmp	 BYTE PTR [esi+2], 0
  00083	74 24		 je	 SHORT $LN19@Gf64MulTab

; 741  : 	{
; 742  : 		xor_8k64(2);

  00085	0f b6 7e 02	 movzx	 edi, BYTE PTR [esi+2]
  00089	8b df		 mov	 ebx, edi
  0008b	83 e3 0f	 and	 ebx, 15			; 0000000fH
  0008e	8d 9c da 00 12
	00 00		 lea	 ebx, DWORD PTR [edx+ebx*8+4608]
  00095	33 03		 xor	 eax, DWORD PTR [ebx]
  00097	33 4b 04	 xor	 ecx, DWORD PTR [ebx+4]
  0009a	c1 ef 04	 shr	 edi, 4
  0009d	8d bc fa 80 12
	00 00		 lea	 edi, DWORD PTR [edx+edi*8+4736]
  000a4	33 07		 xor	 eax, DWORD PTR [edi]
  000a6	33 4f 04	 xor	 ecx, DWORD PTR [edi+4]
$LN19@Gf64MulTab:

; 743  : 	}
; 744  : 	xor_8k64(3);

  000a9	0f b6 7e 03	 movzx	 edi, BYTE PTR [esi+3]
  000ad	8b df		 mov	 ebx, edi
  000af	83 e3 0f	 and	 ebx, 15			; 0000000fH
  000b2	8d 9c da 00 13
	00 00		 lea	 ebx, DWORD PTR [edx+ebx*8+4864]
  000b9	33 03		 xor	 eax, DWORD PTR [ebx]
  000bb	33 4b 04	 xor	 ecx, DWORD PTR [ebx+4]
  000be	c1 ef 04	 shr	 edi, 4
  000c1	8d bc fa 80 13
	00 00		 lea	 edi, DWORD PTR [edx+edi*8+4992]
  000c8	33 07		 xor	 eax, DWORD PTR [edi]
  000ca	33 4f 04	 xor	 ecx, DWORD PTR [edi+4]

; 745  :     xor_8k64(4);

  000cd	0f b6 7e 04	 movzx	 edi, BYTE PTR [esi+4]
  000d1	8b df		 mov	 ebx, edi
  000d3	83 e3 0f	 and	 ebx, 15			; 0000000fH
  000d6	8d 9c da 00 14
	00 00		 lea	 ebx, DWORD PTR [edx+ebx*8+5120]
  000dd	33 03		 xor	 eax, DWORD PTR [ebx]
  000df	33 4b 04	 xor	 ecx, DWORD PTR [ebx+4]
  000e2	c1 ef 04	 shr	 edi, 4
  000e5	8d bc fa 80 14
	00 00		 lea	 edi, DWORD PTR [edx+edi*8+5248]
  000ec	33 07		 xor	 eax, DWORD PTR [edi]
  000ee	33 4f 04	 xor	 ecx, DWORD PTR [edi+4]

; 746  : 	xor_8k64(5);

  000f1	0f b6 7e 05	 movzx	 edi, BYTE PTR [esi+5]

; 747  : 	xor_8k64(6);

  000f5	0f b6 76 06	 movzx	 esi, BYTE PTR [esi+6]
  000f9	8b df		 mov	 ebx, edi
  000fb	83 e3 0f	 and	 ebx, 15			; 0000000fH
  000fe	8d 9c da 00 15
	00 00		 lea	 ebx, DWORD PTR [edx+ebx*8+5376]
  00105	33 03		 xor	 eax, DWORD PTR [ebx]
  00107	33 4b 04	 xor	 ecx, DWORD PTR [ebx+4]
  0010a	c1 ef 04	 shr	 edi, 4
  0010d	8d bc fa 80 15
	00 00		 lea	 edi, DWORD PTR [edx+edi*8+5504]
  00114	33 07		 xor	 eax, DWORD PTR [edi]
  00116	33 4f 04	 xor	 ecx, DWORD PTR [edi+4]
  00119	8b fe		 mov	 edi, esi
  0011b	83 e7 0f	 and	 edi, 15			; 0000000fH
  0011e	8d bc fa 00 16
	00 00		 lea	 edi, DWORD PTR [edx+edi*8+5632]
  00125	33 07		 xor	 eax, DWORD PTR [edi]
  00127	33 4f 04	 xor	 ecx, DWORD PTR [edi+4]
  0012a	c1 ee 04	 shr	 esi, 4
  0012d	8d 94 f2 80 16
	00 00		 lea	 edx, DWORD PTR [edx+esi*8+5760]
  00134	33 02		 xor	 eax, DWORD PTR [edx]
  00136	33 4a 04	 xor	 ecx, DWORD PTR [edx+4]

; 748  : 
; 749  :     move_block_aligned64(p, r);

  00139	8b 55 0c	 mov	 edx, DWORD PTR _p$[ebp]
  0013c	5f		 pop	 edi
  0013d	5e		 pop	 esi
  0013e	89 02		 mov	 DWORD PTR [edx], eax
  00140	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00143	5b		 pop	 ebx

; 750  : }

  00144	5d		 pop	 ebp
  00145	c2 0c 00	 ret	 12			; 0000000cH
_Gf64MulTab@12 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _xor128@8
_TEXT	SEGMENT
_xor128@8 PROC						; COMDAT
; _a$ = eax
; _b$ = ecx

; 757  : 	*a++ ^= *b++;

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	31 10		 xor	 DWORD PTR [eax], edx
  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	31 50 04	 xor	 DWORD PTR [eax+4], edx

; 758  : 	*a ^= *b;

  0000a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0000d	83 c0 08	 add	 eax, 8
  00010	31 10		 xor	 DWORD PTR [eax], edx
  00012	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00015	31 48 04	 xor	 DWORD PTR [eax+4], ecx

; 759  : }

  00018	c3		 ret	 0
_xor128@8 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _shl128@4
_TEXT	SEGMENT
_a$ = 8							; size = 4
_shl128@4 PROC						; COMDAT

; 762  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi
  00006	57		 push	 edi

; 763  : 	int i, x = 0, xx;
; 764  : 	for (i = 15; i >= 0; i--)

  00007	6a 0f		 push	 15			; 0000000fH
  00009	33 d2		 xor	 edx, edx
  0000b	5f		 pop	 edi
$LL3@shl128:
  0000c	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0000f	8d 34 07	 lea	 esi, DWORD PTR [edi+eax]

; 765  : 	{
; 766  : 		xx = (a[i] & 0x80) >> 7;

  00012	8a 06		 mov	 al, BYTE PTR [esi]
  00014	0f b6 c8	 movzx	 ecx, al

; 767  : 		a[i] = (char) ((a[i] << 1) | x);

  00017	02 c0		 add	 al, al
  00019	0a c2		 or	 al, dl
  0001b	c1 e9 07	 shr	 ecx, 7
  0001e	4f		 dec	 edi
  0001f	88 06		 mov	 BYTE PTR [esi], al

; 768  : 		x = xx;

  00021	8b d1		 mov	 edx, ecx
  00023	79 e7		 jns	 SHORT $LL3@shl128
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 769  : 	}
; 770  : }

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
_shl128@4 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogsp
;	COMDAT _GfMul128Basic@12
_TEXT	SEGMENT
_la$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_b$ = 8							; size = 4
_GfMul128Basic@12 PROC					; COMDAT
; _a$ = ecx
; _p$ = ebx

; 773  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 14	 sub	 esp, 20			; 00000014H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	8b f1		 mov	 esi, ecx

; 774  : 	int i;
; 775  : 	unsigned __int8 la[16];
; 776  : 	memcpy (la, a, 16);

  00016	8d 7d ec	 lea	 edi, DWORD PTR _la$[ebp]
  00019	a5		 movsd
  0001a	a5		 movsd
  0001b	a5		 movsd
  0001c	a5		 movsd

; 777  : 	memset (p, 0, 16);

  0001d	33 c0		 xor	 eax, eax
  0001f	8b fb		 mov	 edi, ebx
  00021	ab		 stosd
  00022	ab		 stosd
  00023	ab		 stosd
  00024	ab		 stosd

; 778  : 
; 779  : 	for (i = 0; i < 128; i++)

  00025	33 f6		 xor	 esi, esi
$LL6@GfMul128Ba:

; 780  : 	{
; 781  : 		if (IsBitSet128 (i, b))

  00027	8b 55 08	 mov	 edx, DWORD PTR _b$[ebp]
  0002a	56		 push	 esi
  0002b	e8 00 00 00 00	 call	 _IsBitSet128@8
  00030	85 c0		 test	 eax, eax
  00032	74 17		 je	 SHORT $LN9@GfMul128Ba

; 782  : 			xor128 ((uint64 *)p, (uint64 *)la);

  00034	8b 45 ec	 mov	 eax, DWORD PTR _la$[ebp]
  00037	31 03		 xor	 DWORD PTR [ebx], eax
  00039	8b 45 f0	 mov	 eax, DWORD PTR _la$[ebp+4]
  0003c	31 43 04	 xor	 DWORD PTR [ebx+4], eax
  0003f	8b 45 f4	 mov	 eax, DWORD PTR _la$[ebp+8]
  00042	31 43 08	 xor	 DWORD PTR [ebx+8], eax
  00045	8b 45 f8	 mov	 eax, DWORD PTR _la$[ebp+12]
  00048	31 43 0c	 xor	 DWORD PTR [ebx+12], eax
$LN9@GfMul128Ba:

; 783  : 
; 784  : 		if (la[0] & 0x80)

  0004b	f6 45 ec 80	 test	 BYTE PTR _la$[ebp], 128	; 00000080H

; 785  : 		{
; 786  : 			shl128 (la);

  0004f	8d 45 ec	 lea	 eax, DWORD PTR _la$[ebp]
  00052	50		 push	 eax
  00053	74 0b		 je	 SHORT $LN2@GfMul128Ba
  00055	e8 00 00 00 00	 call	 _shl128@4

; 787  : 			la[15] ^= 0x87;

  0005a	80 75 fb 87	 xor	 BYTE PTR _la$[ebp+15], 135 ; 00000087H

; 788  : 		}
; 789  : 		else

  0005e	eb 05		 jmp	 SHORT $LN5@GfMul128Ba
$LN2@GfMul128Ba:

; 790  : 		{
; 791  : 			shl128 (la);

  00060	e8 00 00 00 00	 call	 _shl128@4
$LN5@GfMul128Ba:

; 778  : 
; 779  : 	for (i = 0; i < 128; i++)

  00065	46		 inc	 esi
  00066	81 fe 80 00 00
	00		 cmp	 esi, 128		; 00000080H
  0006c	7c b9		 jl	 SHORT $LL6@GfMul128Ba

; 792  : 		}
; 793  : 	}
; 794  : }

  0006e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00071	5f		 pop	 edi
  00072	33 cd		 xor	 ecx, ebp
  00074	5e		 pop	 esi
  00075	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007a	c9		 leave
  0007b	c2 04 00	 ret	 4
_GfMul128Basic@12 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _xor64@8
_TEXT	SEGMENT
_xor64@8 PROC						; COMDAT
; _a$ = eax
; _b$ = ecx

; 798  : 	*a ^= *b;

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	31 10		 xor	 DWORD PTR [eax], edx
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	31 48 04	 xor	 DWORD PTR [eax+4], ecx

; 799  : }

  0000a	c3		 ret	 0
_xor64@8 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _shl64@4
_TEXT	SEGMENT
_a$ = 8							; size = 4
_shl64@4 PROC						; COMDAT

; 802  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi
  00006	57		 push	 edi

; 803  : 	int i, x = 0, xx;
; 804  : 	for (i = 7; i >= 0; i--)

  00007	6a 07		 push	 7
  00009	33 d2		 xor	 edx, edx
  0000b	5f		 pop	 edi
$LL3@shl64:
  0000c	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0000f	8d 34 07	 lea	 esi, DWORD PTR [edi+eax]

; 805  : 	{
; 806  : 		xx = (a[i] & 0x80) >> 7;

  00012	8a 06		 mov	 al, BYTE PTR [esi]
  00014	0f b6 c8	 movzx	 ecx, al

; 807  : 		a[i] = (char) ((a[i] << 1) | x);

  00017	02 c0		 add	 al, al
  00019	0a c2		 or	 al, dl
  0001b	c1 e9 07	 shr	 ecx, 7
  0001e	4f		 dec	 edi
  0001f	88 06		 mov	 BYTE PTR [esi], al

; 808  : 		x = xx;

  00021	8b d1		 mov	 edx, ecx
  00023	79 e7		 jns	 SHORT $LL3@shl64
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 809  : 	}
; 810  : }

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
_shl64@4 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogsp
;	COMDAT _GfMul64Basic@12
_TEXT	SEGMENT
_la$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_GfMul64Basic@12 PROC					; COMDAT
; _p$ = esi

; 813  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00012	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]

; 814  : 	/* Deprecated/legacy */
; 815  : 
; 816  : 	int i;
; 817  : 	unsigned __int8 la[8];
; 818  : 	memcpy (la, a, 8);

  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001a	57		 push	 edi
  0001b	89 45 f8	 mov	 DWORD PTR _la$[ebp+4], eax

; 819  : 	memset (p, 0, 8);

  0001e	33 c0		 xor	 eax, eax
  00020	8b fe		 mov	 edi, esi
  00022	ab		 stosd
  00023	ab		 stosd
  00024	89 4d f4	 mov	 DWORD PTR _la$[ebp], ecx

; 820  : 
; 821  : 	for (i = 0; i < 64; i++)

  00027	33 ff		 xor	 edi, edi
$LL13@GfMul64Bas:

; 822  : 	{
; 823  : 		if (IsBitSet64 (i, b))

  00029	8b 55 0c	 mov	 edx, DWORD PTR _b$[ebp]
  0002c	57		 push	 edi
  0002d	e8 00 00 00 00	 call	 _IsBitSet64@8
  00032	85 c0		 test	 eax, eax
  00034	74 0b		 je	 SHORT $LN9@GfMul64Bas

; 824  : 			xor64 ((uint64 *)p, (uint64 *)la);

  00036	8b 45 f4	 mov	 eax, DWORD PTR _la$[ebp]
  00039	31 06		 xor	 DWORD PTR [esi], eax
  0003b	8b 45 f8	 mov	 eax, DWORD PTR _la$[ebp+4]
  0003e	31 46 04	 xor	 DWORD PTR [esi+4], eax
$LN9@GfMul64Bas:

; 825  : 
; 826  : 		if (la[0] & 0x80)

  00041	f6 45 f4 80	 test	 BYTE PTR _la$[ebp], 128	; 00000080H

; 827  : 		{
; 828  : 			shl64 (la);

  00045	8d 45 f4	 lea	 eax, DWORD PTR _la$[ebp]
  00048	50		 push	 eax
  00049	74 0b		 je	 SHORT $LN2@GfMul64Bas
  0004b	e8 00 00 00 00	 call	 _shl64@4

; 829  : 			la[7] ^= 0x1b;

  00050	80 75 fb 1b	 xor	 BYTE PTR _la$[ebp+7], 27 ; 0000001bH

; 830  : 		}
; 831  : 		else

  00054	eb 05		 jmp	 SHORT $LN5@GfMul64Bas
$LN2@GfMul64Bas:

; 832  : 		{
; 833  : 			shl64 (la);

  00056	e8 00 00 00 00	 call	 _shl64@4
$LN5@GfMul64Bas:

; 820  : 
; 821  : 	for (i = 0; i < 64; i++)

  0005b	47		 inc	 edi
  0005c	83 ff 40	 cmp	 edi, 64			; 00000040H
  0005f	7c c8		 jl	 SHORT $LL13@GfMul64Bas

; 834  : 		}
; 835  : 	}
; 836  : }

  00061	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00064	33 cd		 xor	 ecx, ebp
  00066	5f		 pop	 edi
  00067	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006c	c9		 leave
  0006d	c2 08 00	 ret	 8
_GfMul64Basic@12 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_GfMulSelfTest@0
; Function compile flags: /Ogsp
;	COMDAT _GfMulSelfTest@0
_TEXT	SEGMENT
_result$ = -84						; size = 4
_gfCtx$ = -80						; size = 4
_p2$ = -76						; size = 16
_b$ = -60						; size = 16
_a$ = -44						; size = 16
_p1$ = -28						; size = 16
_la$28944 = -12						; size = 8
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_GfMulSelfTest@0 PROC					; COMDAT

; 840  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 54	 sub	 esp, 84			; 00000054H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00012	53		 push	 ebx

; 841  : 	BOOL result = TRUE;
; 842  : 	unsigned __int8 a[16];
; 843  : 	unsigned __int8 b[16];
; 844  : 	unsigned __int8 p1[16];
; 845  : 	unsigned __int8 p2[16];
; 846  : 	GfCtx *gfCtx = (GfCtx *) TCalloc (sizeof (GfCtx));

  00013	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00018	68 00 18 00 00	 push	 6144			; 00001800H
  0001d	33 db		 xor	 ebx, ebx
  0001f	53		 push	 ebx
  00020	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR _result$[ebp], 1
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0002d	89 45 b0	 mov	 DWORD PTR _gfCtx$[ebp], eax

; 847  : 	int i, j;
; 848  : 
; 849  : 	if (!gfCtx)

  00030	3b c3		 cmp	 eax, ebx
  00032	75 07		 jne	 SHORT $LN15@GfMulSelfT

; 850  : 		return FALSE;

  00034	33 c0		 xor	 eax, eax
  00036	e9 3b 01 00 00	 jmp	 $LN16@GfMulSelfT
$LN15@GfMulSelfT:
  0003b	56		 push	 esi
  0003c	57		 push	 edi
$LL44@GfMulSelfT:

; 854  : 	{
; 855  : 		for (j = 0; j < 8; j++)
; 856  : 		{
; 857  : 			a[j] = (unsigned __int8) i;
; 858  : 			b[j] = a[j] ^ 0xff;

  0003d	8a c3		 mov	 al, bl
  0003f	f6 d0		 not	 al
  00041	0f b6 c0	 movzx	 eax, al
  00044	69 c0 01 01 01
	01		 imul	 eax, 16843009		; 01010101H
  0004a	8d 7d c4	 lea	 edi, DWORD PTR _b$[ebp]
  0004d	ab		 stosd
  0004e	ab		 stosd
  0004f	8a c3		 mov	 al, bl
  00051	0f b6 c0	 movzx	 eax, al
  00054	69 c0 01 01 01
	01		 imul	 eax, 16843009		; 01010101H
  0005a	8d 7d d4	 lea	 edi, DWORD PTR _a$[ebp]
  0005d	ab		 stosd
  0005e	ab		 stosd

; 859  : 		}
; 860  : 
; 861  : 		GfMul64Basic (a, b, p1);

  0005f	8b 45 d4	 mov	 eax, DWORD PTR _a$[ebp]
  00062	89 45 f4	 mov	 DWORD PTR _la$28944[ebp], eax
  00065	8b 45 d8	 mov	 eax, DWORD PTR _a$[ebp+4]
  00068	89 45 f8	 mov	 DWORD PTR _la$28944[ebp+4], eax
  0006b	33 c0		 xor	 eax, eax
  0006d	8d 7d e4	 lea	 edi, DWORD PTR _p1$[ebp]
  00070	ab		 stosd
  00071	ab		 stosd
  00072	33 f6		 xor	 esi, esi
$LL42@GfMulSelfT:
  00074	56		 push	 esi
  00075	8d 55 c4	 lea	 edx, DWORD PTR _b$[ebp]
  00078	e8 00 00 00 00	 call	 _IsBitSet64@8
  0007d	85 c0		 test	 eax, eax
  0007f	74 0c		 je	 SHORT $LN28@GfMulSelfT
  00081	8b 45 f4	 mov	 eax, DWORD PTR _la$28944[ebp]
  00084	31 45 e4	 xor	 DWORD PTR _p1$[ebp], eax
  00087	8b 45 f8	 mov	 eax, DWORD PTR _la$28944[ebp+4]
  0008a	31 45 e8	 xor	 DWORD PTR _p1$[ebp+4], eax
$LN28@GfMulSelfT:
  0008d	f6 45 f4 80	 test	 BYTE PTR _la$28944[ebp], 128 ; 00000080H
  00091	8d 45 f4	 lea	 eax, DWORD PTR _la$28944[ebp]
  00094	50		 push	 eax
  00095	74 0b		 je	 SHORT $LN21@GfMulSelfT
  00097	e8 00 00 00 00	 call	 _shl64@4
  0009c	80 75 fb 1b	 xor	 BYTE PTR _la$28944[ebp+7], 27 ; 0000001bH
  000a0	eb 05		 jmp	 SHORT $LN24@GfMulSelfT
$LN21@GfMulSelfT:
  000a2	e8 00 00 00 00	 call	 _shl64@4
$LN24@GfMulSelfT:
  000a7	46		 inc	 esi
  000a8	83 fe 40	 cmp	 esi, 64			; 00000040H
  000ab	7c c7		 jl	 SHORT $LL42@GfMulSelfT

; 862  : 	
; 863  : 		Gf64TabInit (a, gfCtx);

  000ad	ff 75 b0	 push	 DWORD PTR _gfCtx$[ebp]
  000b0	8d 45 d4	 lea	 eax, DWORD PTR _a$[ebp]
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 _Gf64TabInit@8

; 864  : 		Gf64MulTab (b, p2, gfCtx);

  000b9	ff 75 b0	 push	 DWORD PTR _gfCtx$[ebp]
  000bc	8d 45 b4	 lea	 eax, DWORD PTR _p2$[ebp]
  000bf	50		 push	 eax
  000c0	8d 45 c4	 lea	 eax, DWORD PTR _b$[ebp]
  000c3	50		 push	 eax
  000c4	e8 00 00 00 00	 call	 _Gf64MulTab@12

; 865  : 
; 866  : 		if (memcmp (p1, p2, 8) != 0)

  000c9	6a 02		 push	 2
  000cb	59		 pop	 ecx
  000cc	8d 7d b4	 lea	 edi, DWORD PTR _p2$[ebp]
  000cf	8d 75 e4	 lea	 esi, DWORD PTR _p1$[ebp]
  000d2	33 c0		 xor	 eax, eax
  000d4	f3 a7		 repe cmpsd
  000d6	74 03		 je	 SHORT $LN13@GfMulSelfT

; 867  : 			result = FALSE;

  000d8	21 45 ac	 and	 DWORD PTR _result$[ebp], eax
$LN13@GfMulSelfT:

; 851  : 
; 852  : 	/* GF(2^64) - deprecated/legacy */
; 853  : 	for (i = 0; i < 0x100; i++)

  000db	43		 inc	 ebx
  000dc	81 fb 00 01 00
	00		 cmp	 ebx, 256		; 00000100H
  000e2	0f 8c 55 ff ff
	ff		 jl	 $LL44@GfMulSelfT

; 868  : 	}
; 869  : 
; 870  : 	/* GF(2^128) */
; 871  : 	for (i = 0; i < 0x100; i++)

  000e8	21 45 f8	 and	 DWORD PTR _i$[ebp], eax
$LL43@GfMulSelfT:

; 872  : 	{
; 873  : 		for (j = 0; j < 16; j++)
; 874  : 		{
; 875  : 			a[j] = (unsigned __int8) i;

  000eb	8a 45 f8	 mov	 al, BYTE PTR _i$[ebp]
  000ee	0f b6 c0	 movzx	 eax, al
  000f1	33 c9		 xor	 ecx, ecx
  000f3	69 c0 01 01 01
	01		 imul	 eax, 16843009		; 01010101H
  000f9	8d 7d d4	 lea	 edi, DWORD PTR _a$[ebp]
  000fc	ab		 stosd
  000fd	ab		 stosd
  000fe	ab		 stosd
  000ff	ab		 stosd
$LL4@GfMulSelfT:

; 876  : 			b[j] = j < 8 ? 0 : a[j] ^ 0xff;

  00100	83 f9 08	 cmp	 ecx, 8
  00103	7d 04		 jge	 SHORT $LN18@GfMulSelfT
  00105	33 c0		 xor	 eax, eax
  00107	eb 08		 jmp	 SHORT $LN19@GfMulSelfT
$LN18@GfMulSelfT:
  00109	8a 45 f8	 mov	 al, BYTE PTR _i$[ebp]
  0010c	f6 d0		 not	 al
  0010e	0f b6 c0	 movzx	 eax, al
$LN19@GfMulSelfT:
  00111	88 44 0d c4	 mov	 BYTE PTR _b$[ebp+ecx], al
  00115	41		 inc	 ecx
  00116	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00119	7c e5		 jl	 SHORT $LL4@GfMulSelfT

; 877  : 		}
; 878  : 
; 879  : 		GfMul128Basic (a, b, p1);

  0011b	8d 45 c4	 lea	 eax, DWORD PTR _b$[ebp]
  0011e	50		 push	 eax
  0011f	8d 5d e4	 lea	 ebx, DWORD PTR _p1$[ebp]
  00122	8d 4d d4	 lea	 ecx, DWORD PTR _a$[ebp]
  00125	e8 00 00 00 00	 call	 _GfMul128Basic@12

; 880  : 	
; 881  : 		Gf128Tab64Init (a, gfCtx);

  0012a	ff 75 b0	 push	 DWORD PTR _gfCtx$[ebp]
  0012d	8d 45 d4	 lea	 eax, DWORD PTR _a$[ebp]
  00130	50		 push	 eax
  00131	e8 00 00 00 00	 call	 _Gf128Tab64Init@8

; 882  : 		Gf128MulBy64Tab (b + 8, p2, gfCtx);

  00136	ff 75 b0	 push	 DWORD PTR _gfCtx$[ebp]
  00139	8d 45 b4	 lea	 eax, DWORD PTR _p2$[ebp]
  0013c	50		 push	 eax
  0013d	8d 45 cc	 lea	 eax, DWORD PTR _b$[ebp+8]
  00140	50		 push	 eax
  00141	e8 00 00 00 00	 call	 _Gf128MulBy64Tab@12

; 883  : 
; 884  : 		if (memcmp (p1, p2, 16) != 0)

  00146	6a 04		 push	 4
  00148	59		 pop	 ecx
  00149	8d 7d b4	 lea	 edi, DWORD PTR _p2$[ebp]
  0014c	8b f3		 mov	 esi, ebx
  0014e	33 c0		 xor	 eax, eax
  00150	f3 a7		 repe cmpsd
  00152	74 03		 je	 SHORT $LN6@GfMulSelfT

; 885  : 			result = FALSE;

  00154	21 45 ac	 and	 DWORD PTR _result$[ebp], eax
$LN6@GfMulSelfT:

; 868  : 	}
; 869  : 
; 870  : 	/* GF(2^128) */
; 871  : 	for (i = 0; i < 0x100; i++)

  00157	ff 45 f8	 inc	 DWORD PTR _i$[ebp]
  0015a	81 7d f8 00 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 256	; 00000100H
  00161	7c 88		 jl	 SHORT $LL43@GfMulSelfT

; 886  : 	}
; 887  : 
; 888  : 	TCfree (gfCtx);

  00163	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00168	ff 75 b0	 push	 DWORD PTR _gfCtx$[ebp]
  0016b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 889  : 	return result;

  00171	8b 45 ac	 mov	 eax, DWORD PTR _result$[ebp]
  00174	5f		 pop	 edi
  00175	5e		 pop	 esi
$LN16@GfMulSelfT:

; 890  : }

  00176	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00179	33 cd		 xor	 ecx, ebp
  0017b	5b		 pop	 ebx
  0017c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00181	c9		 leave
  00182	c3		 ret	 0
_GfMulSelfTest@0 ENDP
_TEXT	ENDS
END
