; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\home\public\desktop\projects\ciphershed.build\src\common\volumes.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_ReadVolumeHeaderRecoveryMode
_BSS	SEGMENT
_ReadVolumeHeaderRecoveryMode DD 01H DUP (?)
_BSS	ENDS
PUBLIC	_RtlSecureZeroMemory@8
; Function compile flags: /Ogsp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
;	COMDAT _RtlSecureZeroMemory@8
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory@8 PROC				; COMDAT

; 8322 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 8323 :     volatile char *vptr = (volatile char *)ptr;
; 8324 : 
; 8325 : #if defined(_M_AMD64)
; 8326 : 
; 8327 :         __stosb((PUCHAR)((ULONG64)vptr), 0, cnt);
; 8328 : 
; 8329 : #else
; 8330 : 
; 8331 :     while (cnt) {

  00005	83 7d 0c 00	 cmp	 DWORD PTR _cnt$[ebp], 0
  00009	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  0000c	74 09		 je	 SHORT $LN1@RtlSecureZ
$LL2@RtlSecureZ:

; 8332 :         *vptr = 0;

  0000e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 8333 :         vptr++;

  00011	40		 inc	 eax

; 8334 :         cnt--;

  00012	ff 4d 0c	 dec	 DWORD PTR _cnt$[ebp]
  00015	75 f7		 jne	 SHORT $LL2@RtlSecureZ
$LN1@RtlSecureZ:

; 8335 :     }
; 8336 : 
; 8337 : #endif
; 8338 : 
; 8339 :     return ptr;

  00017	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]

; 8340 : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
_RtlSecureZeroMemory@8 ENDP
_TEXT	ENDS
PUBLIC	_GetHeaderField16@8
EXTRN	_MirrorBytes16@4:PROC
; Function compile flags: /Ogsp
; File c:\home\public\desktop\projects\ciphershed.build\src\common\volumes.c
;	COMDAT _GetHeaderField16@8
_TEXT	SEGMENT
_header$ = 8						; size = 4
_offset$ = 12						; size = 4
_GetHeaderField16@8 PROC				; COMDAT

; 125  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 126  : 	return BE16 (*(uint16 *) (header + offset));

  00005	8b 4d 08	 mov	 ecx, DWORD PTR _header$[ebp]
  00008	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  0000b	0f b7 04 01	 movzx	 eax, WORD PTR [ecx+eax]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 _MirrorBytes16@4

; 127  : }

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
_GetHeaderField16@8 ENDP
_TEXT	ENDS
PUBLIC	_GetHeaderField32@8
EXTRN	_MirrorBytes32@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _GetHeaderField32@8
_TEXT	SEGMENT
_header$ = 8						; size = 4
_offset$ = 12						; size = 4
_GetHeaderField32@8 PROC				; COMDAT

; 131  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 132  : 	return BE32 (*(uint32 *) (header + offset));

  00005	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _header$[ebp]
  0000b	ff 34 01	 push	 DWORD PTR [ecx+eax]
  0000e	e8 00 00 00 00	 call	 _MirrorBytes32@4

; 133  : }

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
_GetHeaderField32@8 ENDP
_TEXT	ENDS
PUBLIC	_GetHeaderField64@8
EXTRN	_MirrorBytes64@8:PROC
; Function compile flags: /Ogsp
;	COMDAT _GetHeaderField64@8
_TEXT	SEGMENT
_header$ = 8						; size = 4
_offset$ = 12						; size = 4
_GetHeaderField64@8 PROC				; COMDAT

; 137  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 138  : 	UINT64_STRUCT uint64Struct;
; 139  : 
; 140  : #ifndef TC_NO_COMPILER_INT64
; 141  : 	uint64Struct.Value = BE64 (*(uint64 *) (header + offset));

  00005	8b 45 08	 mov	 eax, DWORD PTR _header$[ebp]
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  0000b	ff 74 08 04	 push	 DWORD PTR [eax+ecx+4]
  0000f	ff 34 08	 push	 DWORD PTR [eax+ecx]
  00012	e8 00 00 00 00	 call	 _MirrorBytes64@8

; 142  : #else
; 143  : 	uint64Struct.HighPart = BE32 (*(uint32 *) (header + offset));
; 144  : 	uint64Struct.LowPart = BE32 (*(uint32 *) (header + offset + 4));
; 145  : #endif
; 146  : 	return uint64Struct;
; 147  : }

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
_GetHeaderField64@8 ENDP
_TEXT	ENDS
PUBLIC	_retHeaderCryptoInfo$GSCopy$
PUBLIC	_retInfo$GSCopy$
PUBLIC	_encryptedHeader$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_ReadVolumeHeader@20
EXTRN	__imp__ExFreePoolWithTag@8:PROC
EXTRN	_crypto_close@4:PROC
EXTRN	__imp__KeBugCheckEx@20:PROC
EXTRN	_EAGetNext@4:PROC
EXTRN	_GetCrc32@8:PROC
EXTRN	_DecryptBuffer@16:PROC
EXTRN	_EAInitMode@4:PROC
EXTRN	_EAGetKeySize@4:PROC
EXTRN	_EAInit@12:PROC
EXTRN	_CipherGetBlockSize@4:PROC
EXTRN	_EAGetFirstCipher@4:PROC
EXTRN	_EAIsModeSupported@8:PROC
EXTRN	_EAGetFirst@0:PROC
EXTRN	_derive_key_ripemd160@28:PROC
EXTRN	_derive_key_sha512@28:PROC
EXTRN	_derive_key_whirlpool@28:PROC
EXTRN	_derive_key_sha1@28:PROC
EXTRN	_GetMaxPkcs5OutSize@0:PROC
EXTRN	__imp__KeWaitForSingleObject@20:PROC
EXTRN	_EncryptionThreadPoolBeginKeyDerivation@40:PROC
EXTRN	_get_pkcs5_iteration_count@8:PROC
EXTRN	_crypto_loadkey@12:PROC
EXTRN	__imp__KeInitializeEvent@12:PROC
EXTRN	__imp__ExAllocatePoolWithTag@12:PROC
EXTRN	_crypto_open@0:PROC
EXTRN	_GetEncryptionThreadCount@0:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memcpy:PROC
; Function compile flags: /Ogsp
;	COMDAT _ReadVolumeHeader@20
_TEXT	SEGMENT
_keyDerivationCompletedEvent$ = -1248			; size = 16
_noOutstandingWorkItemEvent$ = -1232			; size = 16
_outstandingWorkItemCount$ = -1216			; size = 4
_lrw128InitDone$28081 = -1212				; size = 4
_encryptedHeader$GSCopy$ = -1208			; size = 4
_retInfo$GSCopy$ = -1204				; size = 4
_lrw64InitDone$28080 = -1200				; size = 4
_retHeaderCryptoInfo$GSCopy$ = -1196			; size = 4
_encryptionThreadCount$ = -1192				; size = 4
_pkcs5_prf$ = -1188					; size = 4
_keyDerivationWorkItems$ = -1184			; size = 4
_primaryKeyOffset$ = -1180				; size = 4
_item$ = -1180						; size = 4
_queuedWorkItems$ = -1176				; size = 4
_enqPkcs5Prf$ = -1172					; size = 4
_status$ = -1168					; size = 4
_keyInfo$ = -1164					; size = 392
_header$ = -772						; size = 512
_dk$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_bBoot$ = 8						; size = 4
_encryptedHeader$ = 12					; size = 4
_password$ = 16						; size = 4
_retInfo$ = 20						; size = 4
_retHeaderCryptoInfo$ = 24				; size = 4
_ReadVolumeHeader@20 PROC				; COMDAT

; 164  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec e0 04 00
	00		 sub	 esp, 1248		; 000004e0H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	8b 45 0c	 mov	 eax, DWORD PTR _encryptedHeader$[ebp]
  00018	53		 push	 ebx
  00019	8b 5d 18	 mov	 ebx, DWORD PTR _retHeaderCryptoInfo$[ebp]
  0001c	56		 push	 esi
  0001d	8b 75 14	 mov	 esi, DWORD PTR _retInfo$[ebp]
  00020	57		 push	 edi
  00021	8b 7d 10	 mov	 edi, DWORD PTR _password$[ebp]

; 165  : 	char header[TC_VOLUME_HEADER_EFFECTIVE_SIZE];
; 166  : 	KEY_INFO keyInfo;
; 167  : 	PCRYPTO_INFO cryptoInfo;
; 168  : 	char dk[MASTER_KEYDATA_SIZE];
; 169  : 	int enqPkcs5Prf, pkcs5_prf;
; 170  : 	uint16 headerVersion;
; 171  : 	int status = ERR_PARAMETER_INCORRECT;
; 172  : 	int primaryKeyOffset;
; 173  : 
; 174  : 	TC_EVENT keyDerivationCompletedEvent;
; 175  : 	TC_EVENT noOutstandingWorkItemEvent;
; 176  : 	KeyDerivationWorkItem *keyDerivationWorkItems;
; 177  : 	KeyDerivationWorkItem *item;
; 178  : 	int pkcs5PrfCount = LAST_PRF_ID - FIRST_PRF_ID + 1;
; 179  : 	size_t encryptionThreadCount = GetEncryptionThreadCount();

  00024	89 85 48 fb ff
	ff		 mov	 DWORD PTR _encryptedHeader$GSCopy$[ebp], eax
  0002a	89 b5 4c fb ff
	ff		 mov	 DWORD PTR _retInfo$GSCopy$[ebp], esi
  00030	89 9d 54 fb ff
	ff		 mov	 DWORD PTR _retHeaderCryptoInfo$GSCopy$[ebp], ebx
  00036	e8 00 00 00 00	 call	 _GetEncryptionThreadCount@0

; 180  : 	size_t queuedWorkItems = 0;

  0003b	83 a5 68 fb ff
	ff 00		 and	 DWORD PTR _queuedWorkItems$[ebp], 0

; 181  : 	LONG outstandingWorkItemCount = 0;

  00042	83 a5 40 fb ff
	ff 00		 and	 DWORD PTR _outstandingWorkItemCount$[ebp], 0
  00049	89 85 58 fb ff
	ff		 mov	 DWORD PTR _encryptionThreadCount$[ebp], eax

; 182  : 	int i;
; 183  : 
; 184  : 	if (retHeaderCryptoInfo != NULL)

  0004f	85 db		 test	 ebx, ebx

; 185  : 	{
; 186  : 		cryptoInfo = retHeaderCryptoInfo;
; 187  : 	}
; 188  : 	else

  00051	75 15		 jne	 SHORT $LN90@ReadVolume

; 189  : 	{
; 190  : 		cryptoInfo = *retInfo = crypto_open ();

  00053	e8 00 00 00 00	 call	 _crypto_open@0
  00058	8b d8		 mov	 ebx, eax
  0005a	89 06		 mov	 DWORD PTR [esi], eax

; 191  : 		if (cryptoInfo == NULL)

  0005c	85 db		 test	 ebx, ebx
  0005e	75 08		 jne	 SHORT $LN90@ReadVolume
$LN166@ReadVolume:

; 192  : 			return ERR_OUTOFMEMORY;

  00060	6a 02		 push	 2
  00062	58		 pop	 eax
  00063	e9 58 08 00 00	 jmp	 $LN93@ReadVolume
$LN90@ReadVolume:

; 193  : 	}
; 194  : 
; 195  : 	if (encryptionThreadCount > 1)

  00068	33 f6		 xor	 esi, esi
  0006a	46		 inc	 esi
  0006b	39 b5 58 fb ff
	ff		 cmp	 DWORD PTR _encryptionThreadCount$[ebp], esi
  00071	76 4d		 jbe	 SHORT $LN155@ReadVolume

; 196  : 	{
; 197  : 		keyDerivationWorkItems = TCalloc (sizeof (KeyDerivationWorkItem) * pkcs5PrfCount);

  00073	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00078	68 30 04 00 00	 push	 1072			; 00000430H
  0007d	6a 00		 push	 0
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00085	89 85 60 fb ff
	ff		 mov	 DWORD PTR _keyDerivationWorkItems$[ebp], eax

; 198  : 		if (!keyDerivationWorkItems)

  0008b	85 c0		 test	 eax, eax

; 199  : 			return ERR_OUTOFMEMORY;

  0008d	74 d1		 je	 SHORT $LN166@ReadVolume

; 200  : 
; 201  : 		for (i = 0; i < pkcs5PrfCount; ++i)

  0008f	6a 04		 push	 4
  00091	05 00 01 00 00	 add	 eax, 256		; 00000100H
  00096	59		 pop	 ecx
$LL87@ReadVolume:

; 202  : 			keyDerivationWorkItems[i].Free = TRUE;

  00097	89 30		 mov	 DWORD PTR [eax], esi
  00099	05 0c 01 00 00	 add	 eax, 268		; 0000010cH
  0009e	49		 dec	 ecx
  0009f	75 f6		 jne	 SHORT $LL87@ReadVolume

; 203  : 
; 204  : #ifdef DEVICE_DRIVER
; 205  : 		KeInitializeEvent (&keyDerivationCompletedEvent, SynchronizationEvent, FALSE);

  000a1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__KeInitializeEvent@12
  000a7	51		 push	 ecx
  000a8	6a 01		 push	 1
  000aa	8d 85 20 fb ff
	ff		 lea	 eax, DWORD PTR _keyDerivationCompletedEvent$[ebp]
  000b0	50		 push	 eax
  000b1	ff d6		 call	 esi

; 206  : 		KeInitializeEvent (&noOutstandingWorkItemEvent, SynchronizationEvent, TRUE);

  000b3	6a 01		 push	 1
  000b5	6a 01		 push	 1
  000b7	8d 85 30 fb ff
	ff		 lea	 eax, DWORD PTR _noOutstandingWorkItemEvent$[ebp]
  000bd	50		 push	 eax
  000be	ff d6		 call	 esi
$LN155@ReadVolume:

; 207  : #else
; 208  : 		keyDerivationCompletedEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
; 209  : 		if (!keyDerivationCompletedEvent)
; 210  : 		{
; 211  : 			TCfree (keyDerivationWorkItems);
; 212  : 			return ERR_OUTOFMEMORY;
; 213  : 		}
; 214  : 
; 215  : 		noOutstandingWorkItemEvent = CreateEvent (NULL, FALSE, TRUE, NULL);
; 216  : 		if (!noOutstandingWorkItemEvent)
; 217  : 		{
; 218  : 			CloseHandle (keyDerivationCompletedEvent);
; 219  : 			TCfree (keyDerivationWorkItems);
; 220  : 			return ERR_OUTOFMEMORY;
; 221  : 		}
; 222  : #endif
; 223  : 	}
; 224  : 		
; 225  : #ifndef DEVICE_DRIVER
; 226  : 	VirtualLock (&keyInfo, sizeof (keyInfo));
; 227  : 	VirtualLock (&dk, sizeof (dk));
; 228  : #endif
; 229  : 
; 230  : 	crypto_loadkey (&keyInfo, password->Text, (int) password->Length);

  000c0	ff 37		 push	 DWORD PTR [edi]
  000c2	83 c7 04	 add	 edi, 4
  000c5	57		 push	 edi
  000c6	8d 85 74 fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp]
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 _crypto_loadkey@12

; 231  : 
; 232  : 	// PKCS5 is used to derive the primary header key(s) and secondary header key(s) (XTS mode) from the password
; 233  : 	memcpy (keyInfo.salt, encryptedHeader + HEADER_SALT_OFFSET, PKCS5_SALT_SIZE);

  000d2	8b b5 48 fb ff
	ff		 mov	 esi, DWORD PTR _encryptedHeader$GSCopy$[ebp]
  000d8	6a 10		 push	 16			; 00000010H
  000da	59		 pop	 ecx
  000db	8d bd bc fb ff
	ff		 lea	 edi, DWORD PTR _keyInfo$[ebp+72]
  000e1	f3 a5		 rep movsd

; 234  : 
; 235  : 	// Test all available PKCS5 PRFs
; 236  : 	for (enqPkcs5Prf = FIRST_PRF_ID; enqPkcs5Prf <= LAST_PRF_ID || queuedWorkItems > 0; ++enqPkcs5Prf)

  000e3	c7 85 6c fb ff
	ff 01 00 00 00	 mov	 DWORD PTR _enqPkcs5Prf$[ebp], 1
  000ed	33 ff		 xor	 edi, edi
$LL84@ReadVolume:
  000ef	83 bd 6c fb ff
	ff 04		 cmp	 DWORD PTR _enqPkcs5Prf$[ebp], 4
  000f6	7e 0c		 jle	 SHORT $LN160@ReadVolume
  000f8	39 bd 68 fb ff
	ff		 cmp	 DWORD PTR _queuedWorkItems$[ebp], edi
  000fe	0f 86 8b 04 00
	00		 jbe	 $LN82@ReadVolume
$LN160@ReadVolume:

; 237  : 	{
; 238  : 		BOOL lrw64InitDone = FALSE;		// Deprecated/legacy
; 239  : 		BOOL lrw128InitDone = FALSE;	// Deprecated/legacy
; 240  : 
; 241  : 		if (encryptionThreadCount > 1)

  00104	8b 85 58 fb ff
	ff		 mov	 eax, DWORD PTR _encryptionThreadCount$[ebp]
  0010a	89 bd 50 fb ff
	ff		 mov	 DWORD PTR _lrw64InitDone$28080[ebp], edi
  00110	89 bd 44 fb ff
	ff		 mov	 DWORD PTR _lrw128InitDone$28081[ebp], edi
  00116	83 f8 01	 cmp	 eax, 1
  00119	0f 86 4e 01 00
	00		 jbe	 $LN80@ReadVolume

; 242  : 		{
; 243  : 			// Enqueue key derivation on thread pool
; 244  : 			if (queuedWorkItems < encryptionThreadCount && enqPkcs5Prf <= LAST_PRF_ID)

  0011f	39 85 68 fb ff
	ff		 cmp	 DWORD PTR _queuedWorkItems$[ebp], eax
  00125	0f 83 99 00 00
	00		 jae	 $LN79@ReadVolume
  0012b	83 bd 6c fb ff
	ff 04		 cmp	 DWORD PTR _enqPkcs5Prf$[ebp], 4
  00132	0f 8f 8c 00 00
	00		 jg	 $LN79@ReadVolume

; 245  : 			{
; 246  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  00138	8b 85 60 fb ff
	ff		 mov	 eax, DWORD PTR _keyDerivationWorkItems$[ebp]
  0013e	33 c9		 xor	 ecx, ecx
$LL78@ReadVolume:

; 247  : 				{
; 248  : 					item = &keyDerivationWorkItems[i];
; 249  : 					if (item->Free)

  00140	39 b8 00 01 00
	00		 cmp	 DWORD PTR [eax+256], edi
  00146	75 0d		 jne	 SHORT $LN123@ReadVolume
  00148	41		 inc	 ecx
  00149	05 0c 01 00 00	 add	 eax, 268		; 0000010cH
  0014e	83 f9 04	 cmp	 ecx, 4
  00151	7c ed		 jl	 SHORT $LL78@ReadVolume

; 411  : 				
; 412  : 				if (headerVersion > VOLUME_HEADER_VERSION)

  00153	eb 60		 jmp	 SHORT $LN76@ReadVolume
$LN123@ReadVolume:

; 250  : 					{
; 251  : 						item->Free = FALSE;
; 252  : 						item->KeyReady = FALSE;
; 253  : 						item->Pkcs5Prf = enqPkcs5Prf;

  00155	8b 8d 6c fb ff
	ff		 mov	 ecx, DWORD PTR _enqPkcs5Prf$[ebp]

; 254  : 
; 255  : 						EncryptionThreadPoolBeginKeyDerivation (&keyDerivationCompletedEvent, &noOutstandingWorkItemEvent,
; 256  : 							&item->KeyReady, &outstandingWorkItemCount, enqPkcs5Prf, keyInfo.userKey,
; 257  : 							keyInfo.keyLength, keyInfo.salt, get_pkcs5_iteration_count (enqPkcs5Prf, bBoot), item->DerivedKey);

  0015b	50		 push	 eax
  0015c	ff 75 08	 push	 DWORD PTR _bBoot$[ebp]
  0015f	8d b0 04 01 00
	00		 lea	 esi, DWORD PTR [eax+260]
  00165	51		 push	 ecx
  00166	89 b8 00 01 00
	00		 mov	 DWORD PTR [eax+256], edi
  0016c	89 3e		 mov	 DWORD PTR [esi], edi
  0016e	89 88 08 01 00
	00		 mov	 DWORD PTR [eax+264], ecx
  00174	e8 00 00 00 00	 call	 _get_pkcs5_iteration_count@8
  00179	50		 push	 eax
  0017a	8d 85 bc fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+72]
  00180	50		 push	 eax
  00181	ff b5 78 fb ff
	ff		 push	 DWORD PTR _keyInfo$[ebp+4]
  00187	8d 85 7c fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+8]
  0018d	50		 push	 eax
  0018e	ff b5 6c fb ff
	ff		 push	 DWORD PTR _enqPkcs5Prf$[ebp]
  00194	8d 85 40 fb ff
	ff		 lea	 eax, DWORD PTR _outstandingWorkItemCount$[ebp]
  0019a	50		 push	 eax
  0019b	56		 push	 esi
  0019c	8d 85 30 fb ff
	ff		 lea	 eax, DWORD PTR _noOutstandingWorkItemEvent$[ebp]
  001a2	50		 push	 eax
  001a3	8d 85 20 fb ff
	ff		 lea	 eax, DWORD PTR _keyDerivationCompletedEvent$[ebp]
  001a9	50		 push	 eax
  001aa	e8 00 00 00 00	 call	 _EncryptionThreadPoolBeginKeyDerivation@40

; 258  : 						
; 259  : 						++queuedWorkItems;

  001af	ff 85 68 fb ff
	ff		 inc	 DWORD PTR _queuedWorkItems$[ebp]
$LN76@ReadVolume:

; 260  : 						break;
; 261  : 					}
; 262  : 				}
; 263  : 
; 264  : 				if (enqPkcs5Prf < LAST_PRF_ID)

  001b5	83 bd 6c fb ff
	ff 04		 cmp	 DWORD PTR _enqPkcs5Prf$[ebp], 4
  001bc	0f 8c c2 03 00
	00		 jl	 $LN83@ReadVolume

; 265  : 					continue;
; 266  : 			}
; 267  : 			else

  001c2	eb 06		 jmp	 SHORT $LN113@ReadVolume
$LN79@ReadVolume:

; 268  : 				--enqPkcs5Prf;

  001c4	ff 8d 6c fb ff
	ff		 dec	 DWORD PTR _enqPkcs5Prf$[ebp]
$LN113@ReadVolume:

; 269  : 
; 270  : 			// Wait for completion of a key derivation
; 271  : 			while (queuedWorkItems > 0)

  001ca	39 bd 68 fb ff
	ff		 cmp	 DWORD PTR _queuedWorkItems$[ebp], edi
  001d0	0f 86 ae 03 00
	00		 jbe	 $LN83@ReadVolume
  001d6	8b b5 60 fb ff
	ff		 mov	 esi, DWORD PTR _keyDerivationWorkItems$[ebp]
  001dc	81 c6 04 01 00
	00		 add	 esi, 260		; 00000104H
$LL72@ReadVolume:

; 272  : 			{
; 273  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  001e2	33 c9		 xor	 ecx, ecx
  001e4	8b c6		 mov	 eax, esi
$LL70@ReadVolume:

; 274  : 				{
; 275  : 					item = &keyDerivationWorkItems[i];

  001e6	8d 90 fc fe ff
	ff		 lea	 edx, DWORD PTR [eax-260]
  001ec	89 95 64 fb ff
	ff		 mov	 DWORD PTR _item$[ebp], edx

; 276  : 					if (!item->Free && InterlockedExchangeAdd (&item->KeyReady, 0) == TRUE)

  001f2	39 78 fc	 cmp	 DWORD PTR [eax-4], edi
  001f5	75 0f		 jne	 SHORT $LN69@ReadVolume
  001f7	33 d2		 xor	 edx, edx
  001f9	8b f8		 mov	 edi, eax
  001fb	f0 0f c1 17	 lock	  xadd	 DWORD PTR [edi], edx
  001ff	83 fa 01	 cmp	 edx, 1
  00202	74 20		 je	 SHORT $LN124@ReadVolume
  00204	33 ff		 xor	 edi, edi
$LN69@ReadVolume:

; 272  : 			{
; 273  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  00206	41		 inc	 ecx
  00207	05 0c 01 00 00	 add	 eax, 268		; 0000010cH
  0020c	83 f9 04	 cmp	 ecx, 4
  0020f	7c d5		 jl	 SHORT $LL70@ReadVolume

; 284  : 						goto KeyReady;
; 285  : 					}
; 286  : 				}
; 287  : 
; 288  : 				if (queuedWorkItems > 0)
; 289  : 					TC_WAIT_EVENT (keyDerivationCompletedEvent);

  00211	57		 push	 edi
  00212	57		 push	 edi
  00213	57		 push	 edi
  00214	57		 push	 edi
  00215	8d 85 20 fb ff
	ff		 lea	 eax, DWORD PTR _keyDerivationCompletedEvent$[ebp]
  0021b	50		 push	 eax
  0021c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
  00222	eb be		 jmp	 SHORT $LL72@ReadVolume
$LN124@ReadVolume:

; 277  : 					{
; 278  : 						pkcs5_prf = item->Pkcs5Prf;

  00224	8b b5 64 fb ff
	ff		 mov	 esi, DWORD PTR _item$[ebp]
  0022a	8b 86 08 01 00
	00		 mov	 eax, DWORD PTR [esi+264]

; 279  : 						keyInfo.noIterations = get_pkcs5_iteration_count (pkcs5_prf, bBoot);

  00230	ff 75 08	 push	 DWORD PTR _bBoot$[ebp]
  00233	89 85 5c fb ff
	ff		 mov	 DWORD PTR _pkcs5_prf$[ebp], eax
  00239	50		 push	 eax
  0023a	e8 00 00 00 00	 call	 _get_pkcs5_iteration_count@8

; 280  : 						memcpy (dk, item->DerivedKey, sizeof (dk));
; 281  : 
; 282  : 						item->Free = TRUE;
; 283  : 						--queuedWorkItems;

  0023f	ff 8d 68 fb ff
	ff		 dec	 DWORD PTR _queuedWorkItems$[ebp]
  00245	89 85 74 fb ff
	ff		 mov	 DWORD PTR _keyInfo$[ebp], eax
  0024b	8b 85 64 fb ff
	ff		 mov	 eax, DWORD PTR _item$[ebp]
  00251	6a 40		 push	 64			; 00000040H
  00253	59		 pop	 ecx
  00254	8d bd fc fe ff
	ff		 lea	 edi, DWORD PTR _dk$[ebp]
  0025a	f3 a5		 rep movsd
  0025c	c7 80 00 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+256], 1
$KeyReady$28097:

; 290  : 			}
; 291  : 			continue;
; 292  : KeyReady:	;
; 293  : 		}
; 294  : 		else

  00266	33 ff		 xor	 edi, edi
  00268	e9 f2 00 00 00	 jmp	 $LN63@ReadVolume
$LN80@ReadVolume:

; 295  : 		{
; 296  : 			pkcs5_prf = enqPkcs5Prf;
; 297  : 			keyInfo.noIterations = get_pkcs5_iteration_count (enqPkcs5Prf, bBoot);

  0026d	ff 75 08	 push	 DWORD PTR _bBoot$[ebp]
  00270	8b b5 6c fb ff
	ff		 mov	 esi, DWORD PTR _enqPkcs5Prf$[ebp]
  00276	56		 push	 esi
  00277	89 b5 5c fb ff
	ff		 mov	 DWORD PTR _pkcs5_prf$[ebp], esi
  0027d	e8 00 00 00 00	 call	 _get_pkcs5_iteration_count@8
  00282	89 85 74 fb ff
	ff		 mov	 DWORD PTR _keyInfo$[ebp], eax

; 298  : 
; 299  : 			switch (pkcs5_prf)

  00288	8b c6		 mov	 eax, esi
  0028a	48		 dec	 eax
  0028b	0f 84 a0 00 00
	00		 je	 $LN62@ReadVolume
  00291	48		 dec	 eax
  00292	74 6d		 je	 SHORT $LN61@ReadVolume
  00294	48		 dec	 eax
  00295	74 3a		 je	 SHORT $LN59@ReadVolume
  00297	48		 dec	 eax
  00298	0f 85 00 03 00
	00		 jne	 $LN58@ReadVolume

; 310  : 
; 311  : 			case SHA1:
; 312  : 				// Deprecated/legacy
; 313  : 				derive_key_sha1 (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 314  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  0029e	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize@0
  002a3	50		 push	 eax
  002a4	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _dk$[ebp]
  002aa	50		 push	 eax
  002ab	ff b5 74 fb ff
	ff		 push	 DWORD PTR _keyInfo$[ebp]
  002b1	8d 85 bc fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+72]
  002b7	6a 40		 push	 64			; 00000040H
  002b9	50		 push	 eax
  002ba	ff b5 78 fb ff
	ff		 push	 DWORD PTR _keyInfo$[ebp+4]
  002c0	8d 85 7c fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+8]
  002c6	50		 push	 eax
  002c7	e8 00 00 00 00	 call	 _derive_key_sha1@28

; 315  : 				break;

  002cc	e9 8e 00 00 00	 jmp	 $LN63@ReadVolume
$LN59@ReadVolume:

; 316  : 
; 317  : 			case WHIRLPOOL:
; 318  : 				derive_key_whirlpool (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 319  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  002d1	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize@0
  002d6	50		 push	 eax
  002d7	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _dk$[ebp]
  002dd	50		 push	 eax
  002de	ff b5 74 fb ff
	ff		 push	 DWORD PTR _keyInfo$[ebp]
  002e4	8d 85 bc fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+72]
  002ea	6a 40		 push	 64			; 00000040H
  002ec	50		 push	 eax
  002ed	ff b5 78 fb ff
	ff		 push	 DWORD PTR _keyInfo$[ebp+4]
  002f3	8d 85 7c fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+8]
  002f9	50		 push	 eax
  002fa	e8 00 00 00 00	 call	 _derive_key_whirlpool@28

; 320  : 				break;

  002ff	eb 5e		 jmp	 SHORT $LN63@ReadVolume
$LN61@ReadVolume:

; 304  : 				break;
; 305  : 
; 306  : 			case SHA512:
; 307  : 				derive_key_sha512 (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 308  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  00301	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize@0
  00306	50		 push	 eax
  00307	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _dk$[ebp]
  0030d	50		 push	 eax
  0030e	ff b5 74 fb ff
	ff		 push	 DWORD PTR _keyInfo$[ebp]
  00314	8d 85 bc fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+72]
  0031a	6a 40		 push	 64			; 00000040H
  0031c	50		 push	 eax
  0031d	ff b5 78 fb ff
	ff		 push	 DWORD PTR _keyInfo$[ebp+4]
  00323	8d 85 7c fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+8]
  00329	50		 push	 eax
  0032a	e8 00 00 00 00	 call	 _derive_key_sha512@28

; 309  : 				break;

  0032f	eb 2e		 jmp	 SHORT $LN63@ReadVolume
$LN62@ReadVolume:

; 300  : 			{
; 301  : 			case RIPEMD160:
; 302  : 				derive_key_ripemd160 (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 303  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  00331	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize@0
  00336	50		 push	 eax
  00337	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _dk$[ebp]
  0033d	50		 push	 eax
  0033e	ff b5 74 fb ff
	ff		 push	 DWORD PTR _keyInfo$[ebp]
  00344	8d 85 bc fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+72]
  0034a	6a 40		 push	 64			; 00000040H
  0034c	50		 push	 eax
  0034d	ff b5 78 fb ff
	ff		 push	 DWORD PTR _keyInfo$[ebp+4]
  00353	8d 85 7c fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+8]
  00359	50		 push	 eax
  0035a	e8 00 00 00 00	 call	 _derive_key_ripemd160@28
$LN63@ReadVolume:

; 325  : 			} 
; 326  : 		}
; 327  : 
; 328  : 		// Test all available modes of operation
; 329  : 		for (cryptoInfo->mode = FIRST_MODE_OF_OPERATION_ID;
; 330  : 			cryptoInfo->mode <= LAST_MODE_OF_OPERATION;
; 331  : 			cryptoInfo->mode++)

  0035f	c7 43 04 01 00
	00 00		 mov	 DWORD PTR [ebx+4], 1
$LL57@ReadVolume:

; 332  : 		{
; 333  : 			switch (cryptoInfo->mode)

  00366	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00369	83 c0 fe	 add	 eax, -2			; fffffffeH
  0036c	83 f8 03	 cmp	 eax, 3
  0036f	77 1f		 ja	 SHORT $LN51@ReadVolume

; 334  : 			{
; 335  : 			case LRW:
; 336  : 			case CBC:
; 337  : 			case INNER_CBC:
; 338  : 			case OUTER_CBC:
; 339  : 
; 340  : 				// For LRW (deprecated/legacy), copy the tweak key 
; 341  : 				// For CBC (deprecated/legacy), copy the IV/whitening seed 
; 342  : 				memcpy (cryptoInfo->k2, dk, LEGACY_VOL_IV_SIZE);

  00371	6a 08		 push	 8
  00373	8d bb a8 42 00
	00		 lea	 edi, DWORD PTR [ebx+17064]
  00379	59		 pop	 ecx
  0037a	8d b5 fc fe ff
	ff		 lea	 esi, DWORD PTR _dk$[ebp]
  00380	f3 a5		 rep movsd

; 343  : 				primaryKeyOffset = LEGACY_VOL_IV_SIZE;

  00382	c7 85 64 fb ff
	ff 20 00 00 00	 mov	 DWORD PTR _primaryKeyOffset$[ebp], 32 ; 00000020H

; 344  : 				break;

  0038c	33 ff		 xor	 edi, edi
  0038e	eb 06		 jmp	 SHORT $LN53@ReadVolume
$LN51@ReadVolume:

; 345  : 
; 346  : 			default:
; 347  : 				primaryKeyOffset = 0;

  00390	89 bd 64 fb ff
	ff		 mov	 DWORD PTR _primaryKeyOffset$[ebp], edi
$LN53@ReadVolume:

; 348  : 			}
; 349  : 
; 350  : 			// Test all available encryption algorithms
; 351  : 			for (cryptoInfo->ea = EAGetFirst ();
; 352  : 				cryptoInfo->ea != 0;
; 353  : 				cryptoInfo->ea = EAGetNext (cryptoInfo->ea))

  00396	e8 00 00 00 00	 call	 _EAGetFirst@0
  0039b	e9 cd 01 00 00	 jmp	 $LN165@ReadVolume
$LL156@ReadVolume:

; 354  : 			{
; 355  : 				int blockSize;
; 356  : 
; 357  : 				if (!EAIsModeSupported (cryptoInfo->ea, cryptoInfo->mode))

  003a0	ff 73 04	 push	 DWORD PTR [ebx+4]
  003a3	ff 33		 push	 DWORD PTR [ebx]
  003a5	e8 00 00 00 00	 call	 _EAIsModeSupported@8
  003aa	85 c0		 test	 eax, eax
  003ac	0f 84 b2 01 00
	00		 je	 $LN49@ReadVolume

; 358  : 					continue;	// This encryption algorithm has never been available with this mode of operation
; 359  : 
; 360  : 				blockSize = CipherGetBlockSize (EAGetFirstCipher (cryptoInfo->ea));

  003b2	ff 33		 push	 DWORD PTR [ebx]
  003b4	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  003b9	50		 push	 eax
  003ba	e8 00 00 00 00	 call	 _CipherGetBlockSize@4
  003bf	8b f0		 mov	 esi, eax

; 361  : 
; 362  : 				status = EAInit (cryptoInfo->ea, dk + primaryKeyOffset, cryptoInfo->ks);

  003c1	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  003c4	50		 push	 eax
  003c5	8b 85 64 fb ff
	ff		 mov	 eax, DWORD PTR _primaryKeyOffset$[ebp]
  003cb	8d 84 05 fc fe
	ff ff		 lea	 eax, DWORD PTR _dk$[ebp+eax]
  003d2	50		 push	 eax
  003d3	ff 33		 push	 DWORD PTR [ebx]
  003d5	e8 00 00 00 00	 call	 _EAInit@12
  003da	89 85 70 fb ff
	ff		 mov	 DWORD PTR _status$[ebp], eax

; 363  : 				if (status == ERR_CIPHER_INIT_FAILURE)

  003e0	83 f8 11	 cmp	 eax, 17			; 00000011H
  003e3	0f 84 30 04 00
	00		 je	 $err$28126

; 364  : 					goto err;
; 365  : 
; 366  : 				// Init objects related to the mode of operation
; 367  : 
; 368  : 				if (cryptoInfo->mode == XTS)

  003e9	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  003ec	83 f8 01	 cmp	 eax, 1
  003ef	75 3f		 jne	 SHORT $LN45@ReadVolume

; 369  : 				{
; 370  : 					// Copy the secondary key (if cascade, multiple concatenated)
; 371  : 					memcpy (cryptoInfo->k2, dk + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));

  003f1	ff 33		 push	 DWORD PTR [ebx]
  003f3	e8 00 00 00 00	 call	 _EAGetKeySize@4
  003f8	50		 push	 eax
  003f9	ff 33		 push	 DWORD PTR [ebx]
  003fb	e8 00 00 00 00	 call	 _EAGetKeySize@4
  00400	8d 84 05 fc fe
	ff ff		 lea	 eax, DWORD PTR _dk$[ebp+eax]
  00407	50		 push	 eax
  00408	8d 83 a8 42 00
	00		 lea	 eax, DWORD PTR [ebx+17064]
  0040e	50		 push	 eax
  0040f	e8 00 00 00 00	 call	 _memcpy
  00414	83 c4 0c	 add	 esp, 12			; 0000000cH

; 372  : 
; 373  : 					// Secondary key schedule
; 374  : 					if (!EAInitMode (cryptoInfo))

  00417	53		 push	 ebx
  00418	e8 00 00 00 00	 call	 _EAInitMode@4
  0041d	85 c0		 test	 eax, eax
  0041f	75 58		 jne	 SHORT $LN36@ReadVolume
$LN126@ReadVolume:

; 375  : 					{
; 376  : 						status = ERR_MODE_INIT_FAILED;

  00421	c7 85 70 fb ff
	ff 1b 00 00 00	 mov	 DWORD PTR _status$[ebp], 27 ; 0000001bH

; 377  : 						goto err;

  0042b	e9 e9 03 00 00	 jmp	 $err$28126
$LN45@ReadVolume:

; 378  : 					}
; 379  : 				}
; 380  : 				else if (cryptoInfo->mode == LRW
; 381  : 					&& (blockSize == 8 && !lrw64InitDone || blockSize == 16 && !lrw128InitDone))

  00430	83 f8 02	 cmp	 eax, 2
  00433	75 44		 jne	 SHORT $LN36@ReadVolume
  00435	83 fe 08	 cmp	 esi, 8
  00438	75 08		 jne	 SHORT $LN40@ReadVolume
  0043a	39 bd 50 fb ff
	ff		 cmp	 DWORD PTR _lrw64InitDone$28080[ebp], edi
  00440	74 0d		 je	 SHORT $LN157@ReadVolume
$LN40@ReadVolume:
  00442	83 fe 10	 cmp	 esi, 16			; 00000010H
  00445	75 32		 jne	 SHORT $LN36@ReadVolume
  00447	39 bd 44 fb ff
	ff		 cmp	 DWORD PTR _lrw128InitDone$28081[ebp], edi
  0044d	75 2a		 jne	 SHORT $LN36@ReadVolume
$LN157@ReadVolume:

; 382  : 				{
; 383  : 					// Deprecated/legacy
; 384  : 
; 385  : 					if (!EAInitMode (cryptoInfo))

  0044f	53		 push	 ebx
  00450	e8 00 00 00 00	 call	 _EAInitMode@4
  00455	85 c0		 test	 eax, eax
  00457	74 c8		 je	 SHORT $LN126@ReadVolume

; 386  : 					{
; 387  : 						status = ERR_MODE_INIT_FAILED;
; 388  : 						goto err;
; 389  : 					}
; 390  : 
; 391  : 					if (blockSize == 8)

  00459	83 fe 08	 cmp	 esi, 8
  0045c	75 0c		 jne	 SHORT $LN38@ReadVolume

; 392  : 						lrw64InitDone = TRUE;

  0045e	c7 85 50 fb ff
	ff 01 00 00 00	 mov	 DWORD PTR _lrw64InitDone$28080[ebp], 1
  00468	eb 0f		 jmp	 SHORT $LN36@ReadVolume
$LN38@ReadVolume:

; 393  : 					else if (blockSize == 16)

  0046a	83 fe 10	 cmp	 esi, 16			; 00000010H
  0046d	75 0a		 jne	 SHORT $LN36@ReadVolume

; 394  : 						lrw128InitDone = TRUE;

  0046f	c7 85 44 fb ff
	ff 01 00 00 00	 mov	 DWORD PTR _lrw128InitDone$28081[ebp], 1
$LN36@ReadVolume:

; 395  : 				}
; 396  : 
; 397  : 				// Copy the header for decryption
; 398  : 				memcpy (header, encryptedHeader, sizeof (header));

  00479	8b b5 48 fb ff
	ff		 mov	 esi, DWORD PTR _encryptedHeader$GSCopy$[ebp]

; 399  : 
; 400  : 				// Try to decrypt header 
; 401  : 
; 402  : 				DecryptBuffer (header + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, cryptoInfo);

  0047f	53		 push	 ebx
  00480	6a 00		 push	 0
  00482	68 c0 01 00 00	 push	 448			; 000001c0H
  00487	8d 85 3c fd ff
	ff		 lea	 eax, DWORD PTR _header$[ebp+64]
  0048d	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00492	8d bd fc fc ff
	ff		 lea	 edi, DWORD PTR _header$[ebp]
  00498	50		 push	 eax
  00499	f3 a5		 rep movsd
  0049b	e8 00 00 00 00	 call	 _DecryptBuffer@16

; 403  : 
; 404  : 				// Magic 'TRUE'
; 405  : 				/* Modifying 'TRUE' can introduce incompatibility with previous versions. */
; 406  : 				if (GetHeaderField32 (header, TC_HEADER_OFFSET_MAGIC) != 0x54525545)

  004a0	6a 40		 push	 64			; 00000040H
  004a2	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  004a8	50		 push	 eax
  004a9	e8 00 00 00 00	 call	 _GetHeaderField32@8
  004ae	3d 45 55 52 54	 cmp	 eax, 1414681925		; 54525545H
  004b3	0f 85 ab 00 00
	00		 jne	 $LN49@ReadVolume

; 407  : 					continue;
; 408  : 
; 409  : 				// Header version
; 410  : 				headerVersion = GetHeaderField16 (header, TC_HEADER_OFFSET_VERSION);

  004b9	6a 44		 push	 68			; 00000044H
  004bb	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  004c1	50		 push	 eax
  004c2	e8 00 00 00 00	 call	 _GetHeaderField16@8
  004c7	0f b7 f0	 movzx	 esi, ax

; 411  : 				
; 412  : 				if (headerVersion > VOLUME_HEADER_VERSION)

  004ca	66 83 fe 05	 cmp	 si, 5
  004ce	0f 87 de 00 00
	00		 ja	 $LN128@ReadVolume

; 416  : 				}
; 417  : 
; 418  : 				// Check CRC of the header fields
; 419  : 				if (!ReadVolumeHeaderRecoveryMode
; 420  : 					&& headerVersion >= 4
; 421  : 					&& GetHeaderField32 (header, TC_HEADER_OFFSET_HEADER_CRC) != GetCrc32 (header + TC_HEADER_OFFSET_MAGIC, TC_HEADER_OFFSET_HEADER_CRC - TC_HEADER_OFFSET_MAGIC))

  004d4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ReadVolumeHeaderRecoveryMode, 0
  004db	75 2e		 jne	 SHORT $LN33@ReadVolume
  004dd	66 83 fe 04	 cmp	 si, 4
  004e1	72 28		 jb	 SHORT $LN33@ReadVolume
  004e3	68 fc 00 00 00	 push	 252			; 000000fcH
  004e8	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  004ee	50		 push	 eax
  004ef	e8 00 00 00 00	 call	 _GetHeaderField32@8
  004f4	8b f8		 mov	 edi, eax
  004f6	68 bc 00 00 00	 push	 188			; 000000bcH
  004fb	8d 85 3c fd ff
	ff		 lea	 eax, DWORD PTR _header$[ebp+64]
  00501	50		 push	 eax
  00502	e8 00 00 00 00	 call	 _GetCrc32@8
  00507	3b f8		 cmp	 edi, eax
  00509	75 59		 jne	 SHORT $LN49@ReadVolume
$LN33@ReadVolume:

; 422  : 					continue;
; 423  : 
; 424  : 				// Required program version
; 425  : 				cryptoInfo->RequiredProgramVersion = GetHeaderField16 (header, TC_HEADER_OFFSET_REQUIRED_VERSION);

  0050b	6a 46		 push	 70			; 00000046H
  0050d	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  00513	50		 push	 eax
  00514	e8 00 00 00 00	 call	 _GetHeaderField16@8

; 426  : 				cryptoInfo->LegacyVolume = cryptoInfo->RequiredProgramVersion < 0x600;

  00519	b9 00 06 00 00	 mov	 ecx, 1536		; 00000600H
  0051e	66 3b c1	 cmp	 ax, cx
  00521	66 89 83 38 44
	00 00		 mov	 WORD PTR [ebx+17464], ax
  00528	1b c0		 sbb	 eax, eax
  0052a	f7 d8		 neg	 eax
  0052c	89 83 3c 44 00
	00		 mov	 DWORD PTR [ebx+17468], eax

; 427  : 
; 428  : 				// Check CRC of the key set
; 429  : 				if (!ReadVolumeHeaderRecoveryMode
; 430  : 					&& GetHeaderField32 (header, TC_HEADER_OFFSET_KEY_AREA_CRC) != GetCrc32 (header + HEADER_MASTER_KEYDATA_OFFSET, MASTER_KEYDATA_SIZE))

  00532	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ReadVolumeHeaderRecoveryMode, 0
  00539	0f 85 82 00 00
	00		 jne	 $LN158@ReadVolume
  0053f	68 00 01 00 00	 push	 256			; 00000100H
  00544	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _header$[ebp+256]
  0054a	50		 push	 eax
  0054b	e8 00 00 00 00	 call	 _GetCrc32@8
  00550	8b f8		 mov	 edi, eax
  00552	6a 48		 push	 72			; 00000048H
  00554	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  0055a	50		 push	 eax
  0055b	e8 00 00 00 00	 call	 _GetHeaderField32@8
  00560	3b c7		 cmp	 eax, edi
  00562	74 5d		 je	 SHORT $LN158@ReadVolume
$LN49@ReadVolume:

; 348  : 			}
; 349  : 
; 350  : 			// Test all available encryption algorithms
; 351  : 			for (cryptoInfo->ea = EAGetFirst ();
; 352  : 				cryptoInfo->ea != 0;
; 353  : 				cryptoInfo->ea = EAGetNext (cryptoInfo->ea))

  00564	ff 33		 push	 DWORD PTR [ebx]
  00566	e8 00 00 00 00	 call	 _EAGetNext@4
  0056b	33 ff		 xor	 edi, edi
$LN165@ReadVolume:
  0056d	89 03		 mov	 DWORD PTR [ebx], eax
  0056f	3b c7		 cmp	 eax, edi
  00571	0f 85 29 fe ff
	ff		 jne	 $LL156@ReadVolume
  00577	ff 43 04	 inc	 DWORD PTR [ebx+4]
  0057a	83 7b 04 05	 cmp	 DWORD PTR [ebx+4], 5
  0057e	0f 8e e2 fd ff
	ff		 jle	 $LL57@ReadVolume
$LN83@ReadVolume:

; 234  : 
; 235  : 	// Test all available PKCS5 PRFs
; 236  : 	for (enqPkcs5Prf = FIRST_PRF_ID; enqPkcs5Prf <= LAST_PRF_ID || queuedWorkItems > 0; ++enqPkcs5Prf)

  00584	ff 85 6c fb ff
	ff		 inc	 DWORD PTR _enqPkcs5Prf$[ebp]
  0058a	e9 60 fb ff ff	 jmp	 $LL84@ReadVolume
$LN82@ReadVolume:

; 541  : 			}
; 542  : 		}
; 543  : 	}
; 544  : 	status = ERR_PASSWORD_WRONG;

  0058f	c7 85 70 fb ff
	ff 03 00 00 00	 mov	 DWORD PTR _status$[ebp], 3
  00599	e9 7b 02 00 00	 jmp	 $err$28126
$LN58@ReadVolume:

; 321  : 
; 322  : 			default:		
; 323  : 				// Unknown/wrong ID
; 324  : 				TC_THROW_FATAL_EXCEPTION;

  0059e	68 43 54 00 00	 push	 21571			; 00005443H
  005a3	57		 push	 edi
  005a4	57		 push	 edi
  005a5	68 44 01 00 00	 push	 324			; 00000144H
  005aa	6a 29		 push	 41			; 00000029H
  005ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN167@ReadVolume:
$LN128@ReadVolume:

; 413  : 				{
; 414  : 					status = ERR_NEW_VERSION_REQUIRED;

  005b2	c7 85 70 fb ff
	ff 10 00 00 00	 mov	 DWORD PTR _status$[ebp], 16 ; 00000010H

; 415  : 					goto err;

  005bc	e9 58 02 00 00	 jmp	 $err$28126
$LN158@ReadVolume:

; 431  : 					continue;
; 432  : 
; 433  : 				// Now we have the correct password, cipher, hash algorithm, and volume type
; 434  : 
; 435  : 				// Check the version required to handle this volume
; 436  : 				if (cryptoInfo->RequiredProgramVersion > VERSION_NUM)

  005c1	b8 30 07 00 00	 mov	 eax, 1840		; 00000730H
  005c6	66 39 83 38 44
	00 00		 cmp	 WORD PTR [ebx+17464], ax

; 437  : 				{
; 438  : 					status = ERR_NEW_VERSION_REQUIRED;
; 439  : 					goto err;

  005cd	77 e3		 ja	 SHORT $LN128@ReadVolume

; 440  : 				}
; 441  : 
; 442  : 				// Header version
; 443  : 				cryptoInfo->HeaderVersion = headerVersion;
; 444  : 
; 445  : 				// Volume creation time (legacy)
; 446  : 				cryptoInfo->volume_creation_time = GetHeaderField64 (header, TC_HEADER_OFFSET_VOLUME_CREATION_TIME).Value;

  005cf	6a 4c		 push	 76			; 0000004cH
  005d1	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  005d7	50		 push	 eax
  005d8	66 89 b3 a4 29
	00 00		 mov	 WORD PTR [ebx+10660], si
  005df	e8 00 00 00 00	 call	 _GetHeaderField64@8
  005e4	89 83 f0 43 00
	00		 mov	 DWORD PTR [ebx+17392], eax

; 447  : 
; 448  : 				// Header creation time (legacy)
; 449  : 				cryptoInfo->header_creation_time = GetHeaderField64 (header, TC_HEADER_OFFSET_MODIFICATION_TIME).Value;

  005ea	6a 54		 push	 84			; 00000054H
  005ec	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  005f2	50		 push	 eax
  005f3	89 93 f4 43 00
	00		 mov	 DWORD PTR [ebx+17396], edx
  005f9	e8 00 00 00 00	 call	 _GetHeaderField64@8
  005fe	89 83 f8 43 00
	00		 mov	 DWORD PTR [ebx+17400], eax

; 450  : 
; 451  : 				// Hidden volume size (if any)
; 452  : 				cryptoInfo->hiddenVolumeSize = GetHeaderField64 (header, TC_HEADER_OFFSET_HIDDEN_VOLUME_SIZE).Value;

  00604	6a 5c		 push	 92			; 0000005cH
  00606	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  0060c	50		 push	 eax
  0060d	89 93 fc 43 00
	00		 mov	 DWORD PTR [ebx+17404], edx
  00613	e8 00 00 00 00	 call	 _GetHeaderField64@8
  00618	89 83 10 44 00
	00		 mov	 DWORD PTR [ebx+17424], eax

; 453  : 
; 454  : 				// Hidden volume status
; 455  : 				cryptoInfo->hiddenVolume = (cryptoInfo->hiddenVolumeSize != 0);

  0061e	0b c2		 or	 eax, edx
  00620	89 93 14 44 00
	00		 mov	 DWORD PTR [ebx+17428], edx
  00626	74 05		 je	 SHORT $LN95@ReadVolume
  00628	33 c0		 xor	 eax, eax
  0062a	40		 inc	 eax
  0062b	eb 02		 jmp	 SHORT $LN96@ReadVolume
$LN95@ReadVolume:
  0062d	33 c0		 xor	 eax, eax
$LN96@ReadVolume:
  0062f	89 83 a0 29 00
	00		 mov	 DWORD PTR [ebx+10656], eax

; 456  : 
; 457  : 				// Volume size
; 458  : 				cryptoInfo->VolumeSize = GetHeaderField64 (header, TC_HEADER_OFFSET_VOLUME_SIZE);

  00635	6a 64		 push	 100			; 00000064H
  00637	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  0063d	50		 push	 eax
  0063e	e8 00 00 00 00	 call	 _GetHeaderField64@8
  00643	89 83 48 44 00
	00		 mov	 DWORD PTR [ebx+17480], eax

; 459  : 				
; 460  : 				// Encrypted area size and length
; 461  : 				cryptoInfo->EncryptedAreaStart = GetHeaderField64 (header, TC_HEADER_OFFSET_ENCRYPTED_AREA_START);

  00649	6a 6c		 push	 108			; 0000006cH
  0064b	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  00651	50		 push	 eax
  00652	89 93 4c 44 00
	00		 mov	 DWORD PTR [ebx+17484], edx
  00658	e8 00 00 00 00	 call	 _GetHeaderField64@8
  0065d	89 83 50 44 00
	00		 mov	 DWORD PTR [ebx+17488], eax

; 462  : 				cryptoInfo->EncryptedAreaLength = GetHeaderField64 (header, TC_HEADER_OFFSET_ENCRYPTED_AREA_LENGTH);

  00663	6a 74		 push	 116			; 00000074H
  00665	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  0066b	50		 push	 eax
  0066c	89 93 54 44 00
	00		 mov	 DWORD PTR [ebx+17492], edx
  00672	e8 00 00 00 00	 call	 _GetHeaderField64@8
  00677	89 83 58 44 00
	00		 mov	 DWORD PTR [ebx+17496], eax

; 463  : 
; 464  : 				// Flags
; 465  : 				cryptoInfo->HeaderFlags = GetHeaderField32 (header, TC_HEADER_OFFSET_FLAGS);

  0067d	6a 7c		 push	 124			; 0000007cH
  0067f	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  00685	50		 push	 eax
  00686	89 93 5c 44 00
	00		 mov	 DWORD PTR [ebx+17500], edx
  0068c	e8 00 00 00 00	 call	 _GetHeaderField32@8
  00691	89 83 60 44 00
	00		 mov	 DWORD PTR [ebx+17504], eax

; 466  : 
; 467  : 				// Sector size
; 468  : 				if (headerVersion >= 5)

  00697	bf 00 02 00 00	 mov	 edi, 512		; 00000200H
  0069c	66 83 fe 05	 cmp	 si, 5
  006a0	72 19		 jb	 SHORT $LN30@ReadVolume

; 469  : 					cryptoInfo->SectorSize = GetHeaderField32 (header, TC_HEADER_OFFSET_SECTOR_SIZE);

  006a2	68 80 00 00 00	 push	 128			; 00000080H
  006a7	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  006ad	50		 push	 eax
  006ae	e8 00 00 00 00	 call	 _GetHeaderField32@8
  006b3	89 83 40 44 00
	00		 mov	 DWORD PTR [ebx+17472], eax

; 470  : 				else

  006b9	eb 06		 jmp	 SHORT $LN29@ReadVolume
$LN30@ReadVolume:

; 471  : 					cryptoInfo->SectorSize = TC_SECTOR_SIZE_LEGACY;

  006bb	89 bb 40 44 00
	00		 mov	 DWORD PTR [ebx+17472], edi
$LN29@ReadVolume:

; 472  : 
; 473  : 				if (cryptoInfo->SectorSize < TC_MIN_VOLUME_SECTOR_SIZE
; 474  : 					|| cryptoInfo->SectorSize > TC_MAX_VOLUME_SECTOR_SIZE
; 475  : 					|| cryptoInfo->SectorSize % ENCRYPTION_DATA_UNIT_SIZE != 0)

  006c1	8b 83 40 44 00
	00		 mov	 eax, DWORD PTR [ebx+17472]
  006c7	3b c7		 cmp	 eax, edi
  006c9	0f 82 40 01 00
	00		 jb	 $LN27@ReadVolume
  006cf	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  006d4	0f 87 35 01 00
	00		 ja	 $LN27@ReadVolume
  006da	a9 ff 01 00 00	 test	 eax, 511		; 000001ffH
  006df	0f 85 2a 01 00
	00		 jne	 $LN27@ReadVolume

; 478  : 					goto err;
; 479  : 				}
; 480  : 
; 481  : 				// Preserve scheduled header keys if requested			
; 482  : 				if (retHeaderCryptoInfo)

  006e5	83 bd 54 fb ff
	ff 00		 cmp	 DWORD PTR _retHeaderCryptoInfo$GSCopy$[ebp], 0
  006ec	74 57		 je	 SHORT $LN26@ReadVolume

; 483  : 				{
; 484  : 					if (retInfo == NULL)

  006ee	8b b5 4c fb ff
	ff		 mov	 esi, DWORD PTR _retInfo$GSCopy$[ebp]
  006f4	85 f6		 test	 esi, esi
  006f6	75 1d		 jne	 SHORT $LN25@ReadVolume

; 485  : 					{
; 486  : 						cryptoInfo->pkcs5 = pkcs5_prf;

  006f8	8b 85 5c fb ff
	ff		 mov	 eax, DWORD PTR _pkcs5_prf$[ebp]
  006fe	89 83 ec 43 00
	00		 mov	 DWORD PTR [ebx+17388], eax

; 487  : 						cryptoInfo->noIterations = keyInfo.noIterations;

  00704	8b 85 74 fb ff
	ff		 mov	 eax, DWORD PTR _keyInfo$[ebp]
  0070a	89 83 e8 43 00
	00		 mov	 DWORD PTR [ebx+17384], eax

; 488  : 						goto ret;

  00710	e9 1b 01 00 00	 jmp	 $ret$28149
$LN25@ReadVolume:

; 489  : 					}
; 490  : 
; 491  : 					cryptoInfo = *retInfo = crypto_open ();

  00715	e8 00 00 00 00	 call	 _crypto_open@0
  0071a	8b d8		 mov	 ebx, eax
  0071c	89 06		 mov	 DWORD PTR [esi], eax

; 492  : 					if (cryptoInfo == NULL)

  0071e	85 db		 test	 ebx, ebx
  00720	75 0f		 jne	 SHORT $LN24@ReadVolume

; 493  : 					{
; 494  : 						status = ERR_OUTOFMEMORY;

  00722	c7 85 70 fb ff
	ff 02 00 00 00	 mov	 DWORD PTR _status$[ebp], 2

; 495  : 						goto err;

  0072c	e9 e8 00 00 00	 jmp	 $err$28126
$LN24@ReadVolume:

; 496  : 					}
; 497  : 
; 498  : 					memcpy (cryptoInfo, retHeaderCryptoInfo, sizeof (*cryptoInfo));

  00731	68 68 44 00 00	 push	 17512			; 00004468H
  00736	ff b5 54 fb ff
	ff		 push	 DWORD PTR _retHeaderCryptoInfo$GSCopy$[ebp]
  0073c	53		 push	 ebx
  0073d	e8 00 00 00 00	 call	 _memcpy
  00742	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN26@ReadVolume:

; 499  : 				}
; 500  : 
; 501  : 				// Master key data
; 502  : 				memcpy (keyInfo.master_keydata, header + HEADER_MASTER_KEYDATA_OFFSET, MASTER_KEYDATA_SIZE);
; 503  : 				memcpy (cryptoInfo->master_keydata, keyInfo.master_keydata, MASTER_KEYDATA_SIZE);
; 504  : 
; 505  : 				// PKCS #5
; 506  : 				memcpy (cryptoInfo->salt, keyInfo.salt, PKCS5_SALT_SIZE);
; 507  : 				cryptoInfo->pkcs5 = pkcs5_prf;

  00745	8b 85 5c fb ff
	ff		 mov	 eax, DWORD PTR _pkcs5_prf$[ebp]
  0074b	6a 40		 push	 64			; 00000040H
  0074d	59		 pop	 ecx
  0074e	6a 40		 push	 64			; 00000040H
  00750	8d b5 fc fd ff
	ff		 lea	 esi, DWORD PTR _header$[ebp+256]
  00756	8d bd fc fb ff
	ff		 lea	 edi, DWORD PTR _keyInfo$[ebp+136]
  0075c	f3 a5		 rep movsd
  0075e	59		 pop	 ecx
  0075f	6a 10		 push	 16			; 00000010H
  00761	8d bb a8 41 00
	00		 lea	 edi, DWORD PTR [ebx+16808]
  00767	8d b5 fc fb ff
	ff		 lea	 esi, DWORD PTR _keyInfo$[ebp+136]
  0076d	f3 a5		 rep movsd
  0076f	59		 pop	 ecx
  00770	8d bb a8 43 00
	00		 lea	 edi, DWORD PTR [ebx+17320]
  00776	8d b5 bc fb ff
	ff		 lea	 esi, DWORD PTR _keyInfo$[ebp+72]
  0077c	f3 a5		 rep movsd
  0077e	89 83 ec 43 00
	00		 mov	 DWORD PTR [ebx+17388], eax

; 508  : 				cryptoInfo->noIterations = keyInfo.noIterations;

  00784	8b 85 74 fb ff
	ff		 mov	 eax, DWORD PTR _keyInfo$[ebp]
  0078a	89 83 e8 43 00
	00		 mov	 DWORD PTR [ebx+17384], eax

; 509  : 
; 510  : 				// Init the cipher with the decrypted master key
; 511  : 				status = EAInit (cryptoInfo->ea, keyInfo.master_keydata + primaryKeyOffset, cryptoInfo->ks);

  00790	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  00793	50		 push	 eax
  00794	8b 85 64 fb ff
	ff		 mov	 eax, DWORD PTR _primaryKeyOffset$[ebp]
  0079a	8d 84 05 fc fb
	ff ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+eax+136]
  007a1	50		 push	 eax
  007a2	ff 33		 push	 DWORD PTR [ebx]
  007a4	e8 00 00 00 00	 call	 _EAInit@12
  007a9	89 85 70 fb ff
	ff		 mov	 DWORD PTR _status$[ebp], eax

; 512  : 				if (status == ERR_CIPHER_INIT_FAILURE)

  007af	83 f8 11	 cmp	 eax, 17			; 00000011H
  007b2	74 65		 je	 SHORT $err$28126

; 513  : 					goto err;
; 514  : 
; 515  : 				switch (cryptoInfo->mode)

  007b4	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  007b7	83 c0 fe	 add	 eax, -2			; fffffffeH
  007ba	83 f8 03	 cmp	 eax, 3
  007bd	77 13		 ja	 SHORT $LN19@ReadVolume

; 516  : 				{
; 517  : 				case LRW:
; 518  : 				case CBC:
; 519  : 				case INNER_CBC:
; 520  : 				case OUTER_CBC:
; 521  : 
; 522  : 					// For LRW (deprecated/legacy), the tweak key
; 523  : 					// For CBC (deprecated/legacy), the IV/whitening seed
; 524  : 					memcpy (cryptoInfo->k2, keyInfo.master_keydata, LEGACY_VOL_IV_SIZE);

  007bf	6a 08		 push	 8
  007c1	8d bb a8 42 00
	00		 lea	 edi, DWORD PTR [ebx+17064]
  007c7	59		 pop	 ecx
  007c8	8d b5 fc fb ff
	ff		 lea	 esi, DWORD PTR _keyInfo$[ebp+136]
  007ce	f3 a5		 rep movsd

; 525  : 					break;

  007d0	eb 26		 jmp	 SHORT $LN21@ReadVolume
$LN19@ReadVolume:

; 526  : 
; 527  : 				default:
; 528  : 					// The secondary master key (if cascade, multiple concatenated)
; 529  : 					memcpy (cryptoInfo->k2, keyInfo.master_keydata + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));

  007d2	ff 33		 push	 DWORD PTR [ebx]
  007d4	e8 00 00 00 00	 call	 _EAGetKeySize@4
  007d9	50		 push	 eax
  007da	ff 33		 push	 DWORD PTR [ebx]
  007dc	e8 00 00 00 00	 call	 _EAGetKeySize@4
  007e1	8d 84 05 fc fb
	ff ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+eax+136]
  007e8	50		 push	 eax
  007e9	8d 83 a8 42 00
	00		 lea	 eax, DWORD PTR [ebx+17064]
  007ef	50		 push	 eax
  007f0	e8 00 00 00 00	 call	 _memcpy
  007f5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN21@ReadVolume:

; 530  : 
; 531  : 				}
; 532  : 
; 533  : 				if (!EAInitMode (cryptoInfo))

  007f8	53		 push	 ebx
  007f9	e8 00 00 00 00	 call	 _EAInitMode@4
  007fe	85 c0		 test	 eax, eax

; 534  : 				{
; 535  : 					status = ERR_MODE_INIT_FAILED;
; 536  : 					goto err;

  00800	0f 84 1b fc ff
	ff		 je	 $LN126@ReadVolume

; 537  : 				}
; 538  : 
; 539  : 				status = ERR_SUCCESS;

  00806	83 a5 70 fb ff
	ff 00		 and	 DWORD PTR _status$[ebp], 0

; 540  : 				goto ret;

  0080d	eb 21		 jmp	 SHORT $ret$28149
$LN27@ReadVolume:

; 476  : 				{
; 477  : 					status = ERR_PARAMETER_INCORRECT;

  0080f	c7 85 70 fb ff
	ff 1e 00 00 00	 mov	 DWORD PTR _status$[ebp], 30 ; 0000001eH
$err$28126:

; 545  : 
; 546  : err:
; 547  : 	if (cryptoInfo != retHeaderCryptoInfo)

  00819	3b 9d 54 fb ff
	ff		 cmp	 ebx, DWORD PTR _retHeaderCryptoInfo$GSCopy$[ebp]
  0081f	74 0f		 je	 SHORT $ret$28149

; 548  : 	{
; 549  : 		crypto_close(cryptoInfo);

  00821	53		 push	 ebx
  00822	e8 00 00 00 00	 call	 _crypto_close@4

; 550  : 		*retInfo = NULL; 

  00827	8b 85 4c fb ff
	ff		 mov	 eax, DWORD PTR _retInfo$GSCopy$[ebp]
  0082d	83 20 00	 and	 DWORD PTR [eax], 0
$ret$28149:

; 551  : 	}
; 552  : 
; 553  : ret:
; 554  : 	burn (&keyInfo, sizeof (keyInfo));

  00830	8d 95 74 fb ff
	ff		 lea	 edx, DWORD PTR _keyInfo$[ebp]
  00836	b8 88 01 00 00	 mov	 eax, 392		; 00000188H
  0083b	8b f8		 mov	 edi, eax
  0083d	8b ca		 mov	 ecx, edx
$LL98@ReadVolume:
  0083f	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00842	41		 inc	 ecx
  00843	48		 dec	 eax
  00844	75 f9		 jne	 SHORT $LL98@ReadVolume
  00846	33 f6		 xor	 esi, esi
$LL13@ReadVolume:
  00848	4f		 dec	 edi
  00849	c6 02 00	 mov	 BYTE PTR [edx], 0
  0084c	42		 inc	 edx
  0084d	3b fe		 cmp	 edi, esi
  0084f	75 f7		 jne	 SHORT $LL13@ReadVolume

; 555  : 	burn (dk, sizeof(dk));

  00851	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _dk$[ebp]
  00857	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  0085c	8b f8		 mov	 edi, eax
  0085e	8b ca		 mov	 ecx, edx
$LL102@ReadVolume:
  00860	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00863	41		 inc	 ecx
  00864	48		 dec	 eax
  00865	75 f9		 jne	 SHORT $LL102@ReadVolume
$LL8@ReadVolume:
  00867	4f		 dec	 edi
  00868	c6 02 00	 mov	 BYTE PTR [edx], 0
  0086b	42		 inc	 edx
  0086c	3b fe		 cmp	 edi, esi
  0086e	75 f7		 jne	 SHORT $LL8@ReadVolume

; 556  : 
; 557  : #ifndef DEVICE_DRIVER
; 558  : 	VirtualUnlock (&keyInfo, sizeof (keyInfo));
; 559  : 	VirtualUnlock (&dk, sizeof (dk));
; 560  : #endif
; 561  : 
; 562  : 	if (encryptionThreadCount > 1)

  00870	83 bd 58 fb ff
	ff 01		 cmp	 DWORD PTR _encryptionThreadCount$[ebp], 1
  00877	76 41		 jbe	 SHORT $LN6@ReadVolume

; 563  : 	{
; 564  : 		TC_WAIT_EVENT (noOutstandingWorkItemEvent);

  00879	56		 push	 esi
  0087a	56		 push	 esi
  0087b	56		 push	 esi
  0087c	56		 push	 esi
  0087d	8d 85 30 fb ff
	ff		 lea	 eax, DWORD PTR _noOutstandingWorkItemEvent$[ebp]
  00883	50		 push	 eax
  00884	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 565  : 
; 566  : 		burn (keyDerivationWorkItems, sizeof (KeyDerivationWorkItem) * pkcs5PrfCount);

  0088a	8b 95 60 fb ff
	ff		 mov	 edx, DWORD PTR _keyDerivationWorkItems$[ebp]
  00890	b8 30 04 00 00	 mov	 eax, 1072		; 00000430H
  00895	8b f8		 mov	 edi, eax
  00897	8b ca		 mov	 ecx, edx
$LL106@ReadVolume:
  00899	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0089c	41		 inc	 ecx
  0089d	48		 dec	 eax
  0089e	75 f9		 jne	 SHORT $LL106@ReadVolume
$LL2@ReadVolume:
  008a0	4f		 dec	 edi
  008a1	c6 02 00	 mov	 BYTE PTR [edx], 0
  008a4	42		 inc	 edx
  008a5	3b fe		 cmp	 edi, esi
  008a7	75 f7		 jne	 SHORT $LL2@ReadVolume

; 567  : 		TCfree (keyDerivationWorkItems);

  008a9	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  008ae	ff b5 60 fb ff
	ff		 push	 DWORD PTR _keyDerivationWorkItems$[ebp]
  008b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN6@ReadVolume:

; 568  : 
; 569  : #ifndef DEVICE_DRIVER
; 570  : 		CloseHandle (keyDerivationCompletedEvent);
; 571  : 		CloseHandle (noOutstandingWorkItemEvent);
; 572  : #endif
; 573  : 	}
; 574  : 
; 575  : 	return status;

  008ba	8b 85 70 fb ff
	ff		 mov	 eax, DWORD PTR _status$[ebp]
$LN93@ReadVolume:

; 576  : }

  008c0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  008c3	5f		 pop	 edi
  008c4	5e		 pop	 esi
  008c5	33 cd		 xor	 ecx, ebp
  008c7	5b		 pop	 ebx
  008c8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  008cd	c9		 leave
  008ce	c2 14 00	 ret	 20			; 00000014H
$LN164@ReadVolume:
_ReadVolumeHeader@20 ENDP
_TEXT	ENDS
END
