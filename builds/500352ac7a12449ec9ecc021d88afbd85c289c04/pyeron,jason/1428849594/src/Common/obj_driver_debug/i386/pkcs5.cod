; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\home\public\desktop\projects\ciphershed.build\src\common\pkcs5.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_hmac_truncate@12
; Function compile flags: /Odtp
; File c:\home\public\desktop\projects\ciphershed.build\src\common\pkcs5.c
;	COMDAT _hmac_truncate@12
_TEXT	SEGMENT
_i$ = -4						; size = 4
_d1$ = 8						; size = 4
_d2$ = 12						; size = 4
_len$ = 16						; size = 4
_hmac_truncate@12 PROC					; COMDAT

; 30   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 31   : 	int i;
; 32   : 	for (i = 0; i < len; i++)

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000d	eb 09		 jmp	 SHORT $LN3@hmac_trunc
$LN2@hmac_trunc:
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00012	83 c0 01	 add	 eax, 1
  00015	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN3@hmac_trunc:
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0001b	3b 4d 10	 cmp	 ecx, DWORD PTR _len$[ebp]
  0001e	7d 12		 jge	 SHORT $LN4@hmac_trunc

; 33   : 		d2[i] = d1[i];

  00020	8b 55 0c	 mov	 edx, DWORD PTR _d2$[ebp]
  00023	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  00026	8b 45 08	 mov	 eax, DWORD PTR _d1$[ebp]
  00029	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0002c	8a 08		 mov	 cl, BYTE PTR [eax]
  0002e	88 0a		 mov	 BYTE PTR [edx], cl
  00030	eb dd		 jmp	 SHORT $LN2@hmac_trunc
$LN4@hmac_trunc:

; 34   : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 0c 00	 ret	 12			; 0000000cH
_hmac_truncate@12 ENDP
_TEXT	ENDS
PUBLIC	_RtlSecureZeroMemory@8
PUBLIC	__$ArrayPad$
PUBLIC	_hmac_sha512@24
EXTRN	_sha512_end@8:PROC
EXTRN	_sha512_hash@12:PROC
EXTRN	_sha512_begin@4:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Odtp
;	COMDAT _hmac_sha512@24
_TEXT	SEGMENT
tv148 = -1012						; size = 4
_burnm$27074 = -1008					; size = 4
_burnc$27076 = -1004					; size = 4
_burnm$27065 = -1000					; size = 4
_burnc$27067 = -996					; size = 4
_burnm$27056 = -992					; size = 4
_burnc$27058 = -988					; size = 4
_burnm$27047 = -984					; size = 4
_burnc$27049 = -980					; size = 4
_burnm$27038 = -976					; size = 4
_burnc$27040 = -972					; size = 4
_burnm$27029 = -968					; size = 4
_burnc$27031 = -964					; size = 4
_burnm$27000 = -960					; size = 4
_burnc$27002 = -956					; size = 4
_tctx$26994 = -952					; size = 208
_octx$ = -744						; size = 208
_ictx$ = -536						; size = 208
_buf$ = -328						; size = 128
_key$ = -200						; size = 64
_isha$ = -136						; size = 64
_osha$ = -72						; size = 64
__$ArrayPad$ = -8					; size = 4
_i$ = -4						; size = 4
_k$ = 8							; size = 4
_lk$ = 12						; size = 4
_d$ = 16						; size = 4
_ld$ = 20						; size = 4
_out$ = 24						; size = 4
_t$ = 28						; size = 4
_hmac_sha512@24 PROC					; COMDAT

; 47   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec f4 03 00
	00		 sub	 esp, 1012		; 000003f4H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 48   : 	sha512_ctx ictx, octx;
; 49   : 	char isha[SHA512_DIGESTSIZE], osha[SHA512_DIGESTSIZE];
; 50   : 	char key[SHA512_DIGESTSIZE];
; 51   : 	char buf[SHA512_BLOCKSIZE];
; 52   : 	int i;
; 53   : 
; 54   :     /* If the key is longer than the hash algorithm block size,
; 55   : 	   let key = sha512(key), as per HMAC specifications. */
; 56   : 	if (lk > SHA512_BLOCKSIZE)

  00015	81 7d 0c 80 00
	00 00		 cmp	 DWORD PTR _lk$[ebp], 128 ; 00000080H
  0001c	0f 8e a1 00 00
	00		 jle	 $LN48@hmac_sha51

; 57   : 	{
; 58   : 		sha512_ctx tctx;
; 59   : 
; 60   : 		sha512_begin (&tctx);

  00022	8d 85 48 fc ff
	ff		 lea	 eax, DWORD PTR _tctx$26994[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 _sha512_begin@4

; 61   : 		sha512_hash ((unsigned char *) k, lk, &tctx);

  0002e	8d 8d 48 fc ff
	ff		 lea	 ecx, DWORD PTR _tctx$26994[ebp]
  00034	51		 push	 ecx
  00035	8b 55 0c	 mov	 edx, DWORD PTR _lk$[ebp]
  00038	52		 push	 edx
  00039	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _sha512_hash@12

; 62   : 		sha512_end ((unsigned char *) key, &tctx);

  00042	8d 8d 48 fc ff
	ff		 lea	 ecx, DWORD PTR _tctx$26994[ebp]
  00048	51		 push	 ecx
  00049	8d 95 38 ff ff
	ff		 lea	 edx, DWORD PTR _key$[ebp]
  0004f	52		 push	 edx
  00050	e8 00 00 00 00	 call	 _sha512_end@8

; 63   : 
; 64   : 		k = key;

  00055	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR _key$[ebp]
  0005b	89 45 08	 mov	 DWORD PTR _k$[ebp], eax

; 65   : 		lk = SHA512_DIGESTSIZE;

  0005e	c7 45 0c 40 00
	00 00		 mov	 DWORD PTR _lk$[ebp], 64	; 00000040H
$LN47@hmac_sha51:

; 66   : 
; 67   : 		burn (&tctx, sizeof(tctx));		// Prevent leaks

  00065	8d 8d 48 fc ff
	ff		 lea	 ecx, DWORD PTR _tctx$26994[ebp]
  0006b	89 8d 40 fc ff
	ff		 mov	 DWORD PTR _burnm$27000[ebp], ecx
  00071	c7 85 44 fc ff
	ff d0 00 00 00	 mov	 DWORD PTR _burnc$27002[ebp], 208 ; 000000d0H
  0007b	68 d0 00 00 00	 push	 208			; 000000d0H
  00080	8d 95 48 fc ff
	ff		 lea	 edx, DWORD PTR _tctx$26994[ebp]
  00086	52		 push	 edx
  00087	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN44@hmac_sha51:
  0008c	8b 85 44 fc ff
	ff		 mov	 eax, DWORD PTR _burnc$27002[ebp]
  00092	8b 8d 44 fc ff
	ff		 mov	 ecx, DWORD PTR _burnc$27002[ebp]
  00098	83 e9 01	 sub	 ecx, 1
  0009b	89 8d 44 fc ff
	ff		 mov	 DWORD PTR _burnc$27002[ebp], ecx
  000a1	85 c0		 test	 eax, eax
  000a3	74 1a		 je	 SHORT $LN46@hmac_sha51
  000a5	8b 95 40 fc ff
	ff		 mov	 edx, DWORD PTR _burnm$27000[ebp]
  000ab	c6 02 00	 mov	 BYTE PTR [edx], 0
  000ae	8b 85 40 fc ff
	ff		 mov	 eax, DWORD PTR _burnm$27000[ebp]
  000b4	83 c0 01	 add	 eax, 1
  000b7	89 85 40 fc ff
	ff		 mov	 DWORD PTR _burnm$27000[ebp], eax
  000bd	eb cd		 jmp	 SHORT $LN44@hmac_sha51
$LN46@hmac_sha51:
  000bf	33 c9		 xor	 ecx, ecx
  000c1	75 a2		 jne	 SHORT $LN47@hmac_sha51
$LN48@hmac_sha51:

; 68   : 	}
; 69   : 
; 70   : 	/**** Inner Digest ****/
; 71   : 
; 72   : 	sha512_begin (&ictx);

  000c3	8d 95 e8 fd ff
	ff		 lea	 edx, DWORD PTR _ictx$[ebp]
  000c9	52		 push	 edx
  000ca	e8 00 00 00 00	 call	 _sha512_begin@4

; 73   : 
; 74   : 	/* Pad the key for inner digest */
; 75   : 	for (i = 0; i < lk; ++i)

  000cf	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000d6	eb 09		 jmp	 SHORT $LN42@hmac_sha51
$LN41@hmac_sha51:
  000d8	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000db	83 c0 01	 add	 eax, 1
  000de	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN42@hmac_sha51:
  000e1	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000e4	3b 4d 0c	 cmp	 ecx, DWORD PTR _lk$[ebp]
  000e7	7d 18		 jge	 SHORT $LN40@hmac_sha51

; 76   : 		buf[i] = (char) (k[i] ^ 0x36);

  000e9	8b 55 08	 mov	 edx, DWORD PTR _k$[ebp]
  000ec	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  000ef	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000f2	83 f0 36	 xor	 eax, 54			; 00000036H
  000f5	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000f8	88 84 0d b8 fe
	ff ff		 mov	 BYTE PTR _buf$[ebp+ecx], al
  000ff	eb d7		 jmp	 SHORT $LN41@hmac_sha51
$LN40@hmac_sha51:

; 77   : 	for (i = lk; i < SHA512_BLOCKSIZE; ++i)

  00101	8b 55 0c	 mov	 edx, DWORD PTR _lk$[ebp]
  00104	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
  00107	eb 09		 jmp	 SHORT $LN39@hmac_sha51
$LN38@hmac_sha51:
  00109	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0010c	83 c0 01	 add	 eax, 1
  0010f	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN39@hmac_sha51:
  00112	81 7d fc 80 00
	00 00		 cmp	 DWORD PTR _i$[ebp], 128	; 00000080H
  00119	7d 0d		 jge	 SHORT $LN37@hmac_sha51

; 78   : 		buf[i] = 0x36;

  0011b	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0011e	c6 84 0d b8 fe
	ff ff 36	 mov	 BYTE PTR _buf$[ebp+ecx], 54 ; 00000036H
  00126	eb e1		 jmp	 SHORT $LN38@hmac_sha51
$LN37@hmac_sha51:

; 79   : 
; 80   : 	sha512_hash ((unsigned char *) buf, SHA512_BLOCKSIZE, &ictx);

  00128	8d 95 e8 fd ff
	ff		 lea	 edx, DWORD PTR _ictx$[ebp]
  0012e	52		 push	 edx
  0012f	68 80 00 00 00	 push	 128			; 00000080H
  00134	8d 85 b8 fe ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 _sha512_hash@12

; 81   : 	sha512_hash ((unsigned char *) d, ld, &ictx);

  00140	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _ictx$[ebp]
  00146	51		 push	 ecx
  00147	8b 55 14	 mov	 edx, DWORD PTR _ld$[ebp]
  0014a	52		 push	 edx
  0014b	8b 45 10	 mov	 eax, DWORD PTR _d$[ebp]
  0014e	50		 push	 eax
  0014f	e8 00 00 00 00	 call	 _sha512_hash@12

; 82   : 
; 83   : 	sha512_end ((unsigned char *) isha, &ictx);

  00154	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _ictx$[ebp]
  0015a	51		 push	 ecx
  0015b	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR _isha$[ebp]
  00161	52		 push	 edx
  00162	e8 00 00 00 00	 call	 _sha512_end@8

; 84   : 
; 85   : 	/**** Outer Digest ****/
; 86   : 
; 87   : 	sha512_begin (&octx);

  00167	8d 85 18 fd ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 _sha512_begin@4

; 88   : 
; 89   : 	for (i = 0; i < lk; ++i)

  00173	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0017a	eb 09		 jmp	 SHORT $LN36@hmac_sha51
$LN35@hmac_sha51:
  0017c	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0017f	83 c1 01	 add	 ecx, 1
  00182	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN36@hmac_sha51:
  00185	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00188	3b 55 0c	 cmp	 edx, DWORD PTR _lk$[ebp]
  0018b	7d 18		 jge	 SHORT $LN34@hmac_sha51

; 90   : 		buf[i] = (char) (k[i] ^ 0x5C);

  0018d	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]
  00190	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00193	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00196	83 f1 5c	 xor	 ecx, 92			; 0000005cH
  00199	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0019c	88 8c 15 b8 fe
	ff ff		 mov	 BYTE PTR _buf$[ebp+edx], cl
  001a3	eb d7		 jmp	 SHORT $LN35@hmac_sha51
$LN34@hmac_sha51:

; 91   : 	for (i = lk; i < SHA512_BLOCKSIZE; ++i)

  001a5	8b 45 0c	 mov	 eax, DWORD PTR _lk$[ebp]
  001a8	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  001ab	eb 09		 jmp	 SHORT $LN33@hmac_sha51
$LN32@hmac_sha51:
  001ad	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  001b0	83 c1 01	 add	 ecx, 1
  001b3	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN33@hmac_sha51:
  001b6	81 7d fc 80 00
	00 00		 cmp	 DWORD PTR _i$[ebp], 128	; 00000080H
  001bd	7d 0d		 jge	 SHORT $LN31@hmac_sha51

; 92   : 		buf[i] = 0x5C;

  001bf	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  001c2	c6 84 15 b8 fe
	ff ff 5c	 mov	 BYTE PTR _buf$[ebp+edx], 92 ; 0000005cH
  001ca	eb e1		 jmp	 SHORT $LN32@hmac_sha51
$LN31@hmac_sha51:

; 93   : 
; 94   : 	sha512_hash ((unsigned char *) buf, SHA512_BLOCKSIZE, &octx);

  001cc	8d 85 18 fd ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  001d2	50		 push	 eax
  001d3	68 80 00 00 00	 push	 128			; 00000080H
  001d8	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR _buf$[ebp]
  001de	51		 push	 ecx
  001df	e8 00 00 00 00	 call	 _sha512_hash@12

; 95   : 	sha512_hash ((unsigned char *) isha, SHA512_DIGESTSIZE, &octx);

  001e4	8d 95 18 fd ff
	ff		 lea	 edx, DWORD PTR _octx$[ebp]
  001ea	52		 push	 edx
  001eb	6a 40		 push	 64			; 00000040H
  001ed	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _isha$[ebp]
  001f3	50		 push	 eax
  001f4	e8 00 00 00 00	 call	 _sha512_hash@12

; 96   : 
; 97   : 	sha512_end ((unsigned char *) osha, &octx);

  001f9	8d 8d 18 fd ff
	ff		 lea	 ecx, DWORD PTR _octx$[ebp]
  001ff	51		 push	 ecx
  00200	8d 55 b8	 lea	 edx, DWORD PTR _osha$[ebp]
  00203	52		 push	 edx
  00204	e8 00 00 00 00	 call	 _sha512_end@8

; 98   : 
; 99   : 	/* truncate and print the results */
; 100  : 	t = t > SHA512_DIGESTSIZE ? SHA512_DIGESTSIZE : t;

  00209	83 7d 1c 40	 cmp	 DWORD PTR _t$[ebp], 64	; 00000040H
  0020d	7e 0c		 jle	 SHORT $LN51@hmac_sha51
  0020f	c7 85 0c fc ff
	ff 40 00 00 00	 mov	 DWORD PTR tv148[ebp], 64 ; 00000040H
  00219	eb 09		 jmp	 SHORT $LN52@hmac_sha51
$LN51@hmac_sha51:
  0021b	8b 45 1c	 mov	 eax, DWORD PTR _t$[ebp]
  0021e	89 85 0c fc ff
	ff		 mov	 DWORD PTR tv148[ebp], eax
$LN52@hmac_sha51:
  00224	8b 8d 0c fc ff
	ff		 mov	 ecx, DWORD PTR tv148[ebp]
  0022a	89 4d 1c	 mov	 DWORD PTR _t$[ebp], ecx

; 101  : 	hmac_truncate (osha, out, t);

  0022d	8b 55 1c	 mov	 edx, DWORD PTR _t$[ebp]
  00230	52		 push	 edx
  00231	8b 45 18	 mov	 eax, DWORD PTR _out$[ebp]
  00234	50		 push	 eax
  00235	8d 4d b8	 lea	 ecx, DWORD PTR _osha$[ebp]
  00238	51		 push	 ecx
  00239	e8 00 00 00 00	 call	 _hmac_truncate@12
$LN30@hmac_sha51:

; 102  : 
; 103  : 	/* Prevent leaks */
; 104  : 	burn (&ictx, sizeof(ictx));

  0023e	8d 95 e8 fd ff
	ff		 lea	 edx, DWORD PTR _ictx$[ebp]
  00244	89 95 38 fc ff
	ff		 mov	 DWORD PTR _burnm$27029[ebp], edx
  0024a	c7 85 3c fc ff
	ff d0 00 00 00	 mov	 DWORD PTR _burnc$27031[ebp], 208 ; 000000d0H
  00254	68 d0 00 00 00	 push	 208			; 000000d0H
  00259	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _ictx$[ebp]
  0025f	50		 push	 eax
  00260	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN27@hmac_sha51:
  00265	8b 8d 3c fc ff
	ff		 mov	 ecx, DWORD PTR _burnc$27031[ebp]
  0026b	8b 95 3c fc ff
	ff		 mov	 edx, DWORD PTR _burnc$27031[ebp]
  00271	83 ea 01	 sub	 edx, 1
  00274	89 95 3c fc ff
	ff		 mov	 DWORD PTR _burnc$27031[ebp], edx
  0027a	85 c9		 test	 ecx, ecx
  0027c	74 1a		 je	 SHORT $LN29@hmac_sha51
  0027e	8b 85 38 fc ff
	ff		 mov	 eax, DWORD PTR _burnm$27029[ebp]
  00284	c6 00 00	 mov	 BYTE PTR [eax], 0
  00287	8b 8d 38 fc ff
	ff		 mov	 ecx, DWORD PTR _burnm$27029[ebp]
  0028d	83 c1 01	 add	 ecx, 1
  00290	89 8d 38 fc ff
	ff		 mov	 DWORD PTR _burnm$27029[ebp], ecx
  00296	eb cd		 jmp	 SHORT $LN27@hmac_sha51
$LN29@hmac_sha51:
  00298	33 d2		 xor	 edx, edx
  0029a	75 a2		 jne	 SHORT $LN30@hmac_sha51
$LN25@hmac_sha51:

; 105  : 	burn (&octx, sizeof(octx));

  0029c	8d 85 18 fd ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  002a2	89 85 30 fc ff
	ff		 mov	 DWORD PTR _burnm$27038[ebp], eax
  002a8	c7 85 34 fc ff
	ff d0 00 00 00	 mov	 DWORD PTR _burnc$27040[ebp], 208 ; 000000d0H
  002b2	68 d0 00 00 00	 push	 208			; 000000d0H
  002b7	8d 8d 18 fd ff
	ff		 lea	 ecx, DWORD PTR _octx$[ebp]
  002bd	51		 push	 ecx
  002be	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN22@hmac_sha51:
  002c3	8b 95 34 fc ff
	ff		 mov	 edx, DWORD PTR _burnc$27040[ebp]
  002c9	8b 85 34 fc ff
	ff		 mov	 eax, DWORD PTR _burnc$27040[ebp]
  002cf	83 e8 01	 sub	 eax, 1
  002d2	89 85 34 fc ff
	ff		 mov	 DWORD PTR _burnc$27040[ebp], eax
  002d8	85 d2		 test	 edx, edx
  002da	74 1a		 je	 SHORT $LN24@hmac_sha51
  002dc	8b 8d 30 fc ff
	ff		 mov	 ecx, DWORD PTR _burnm$27038[ebp]
  002e2	c6 01 00	 mov	 BYTE PTR [ecx], 0
  002e5	8b 95 30 fc ff
	ff		 mov	 edx, DWORD PTR _burnm$27038[ebp]
  002eb	83 c2 01	 add	 edx, 1
  002ee	89 95 30 fc ff
	ff		 mov	 DWORD PTR _burnm$27038[ebp], edx
  002f4	eb cd		 jmp	 SHORT $LN22@hmac_sha51
$LN24@hmac_sha51:
  002f6	33 c0		 xor	 eax, eax
  002f8	75 a2		 jne	 SHORT $LN25@hmac_sha51
$LN20@hmac_sha51:

; 106  : 	burn (isha, sizeof(isha));

  002fa	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _isha$[ebp]
  00300	89 8d 28 fc ff
	ff		 mov	 DWORD PTR _burnm$27047[ebp], ecx
  00306	c7 85 2c fc ff
	ff 40 00 00 00	 mov	 DWORD PTR _burnc$27049[ebp], 64 ; 00000040H
  00310	6a 40		 push	 64			; 00000040H
  00312	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR _isha$[ebp]
  00318	52		 push	 edx
  00319	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN17@hmac_sha51:
  0031e	8b 85 2c fc ff
	ff		 mov	 eax, DWORD PTR _burnc$27049[ebp]
  00324	8b 8d 2c fc ff
	ff		 mov	 ecx, DWORD PTR _burnc$27049[ebp]
  0032a	83 e9 01	 sub	 ecx, 1
  0032d	89 8d 2c fc ff
	ff		 mov	 DWORD PTR _burnc$27049[ebp], ecx
  00333	85 c0		 test	 eax, eax
  00335	74 1a		 je	 SHORT $LN19@hmac_sha51
  00337	8b 95 28 fc ff
	ff		 mov	 edx, DWORD PTR _burnm$27047[ebp]
  0033d	c6 02 00	 mov	 BYTE PTR [edx], 0
  00340	8b 85 28 fc ff
	ff		 mov	 eax, DWORD PTR _burnm$27047[ebp]
  00346	83 c0 01	 add	 eax, 1
  00349	89 85 28 fc ff
	ff		 mov	 DWORD PTR _burnm$27047[ebp], eax
  0034f	eb cd		 jmp	 SHORT $LN17@hmac_sha51
$LN19@hmac_sha51:
  00351	33 c9		 xor	 ecx, ecx
  00353	75 a5		 jne	 SHORT $LN20@hmac_sha51
$LN15@hmac_sha51:

; 107  : 	burn (osha, sizeof(osha));

  00355	8d 55 b8	 lea	 edx, DWORD PTR _osha$[ebp]
  00358	89 95 20 fc ff
	ff		 mov	 DWORD PTR _burnm$27056[ebp], edx
  0035e	c7 85 24 fc ff
	ff 40 00 00 00	 mov	 DWORD PTR _burnc$27058[ebp], 64 ; 00000040H
  00368	6a 40		 push	 64			; 00000040H
  0036a	8d 45 b8	 lea	 eax, DWORD PTR _osha$[ebp]
  0036d	50		 push	 eax
  0036e	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN12@hmac_sha51:
  00373	8b 8d 24 fc ff
	ff		 mov	 ecx, DWORD PTR _burnc$27058[ebp]
  00379	8b 95 24 fc ff
	ff		 mov	 edx, DWORD PTR _burnc$27058[ebp]
  0037f	83 ea 01	 sub	 edx, 1
  00382	89 95 24 fc ff
	ff		 mov	 DWORD PTR _burnc$27058[ebp], edx
  00388	85 c9		 test	 ecx, ecx
  0038a	74 1a		 je	 SHORT $LN14@hmac_sha51
  0038c	8b 85 20 fc ff
	ff		 mov	 eax, DWORD PTR _burnm$27056[ebp]
  00392	c6 00 00	 mov	 BYTE PTR [eax], 0
  00395	8b 8d 20 fc ff
	ff		 mov	 ecx, DWORD PTR _burnm$27056[ebp]
  0039b	83 c1 01	 add	 ecx, 1
  0039e	89 8d 20 fc ff
	ff		 mov	 DWORD PTR _burnm$27056[ebp], ecx
  003a4	eb cd		 jmp	 SHORT $LN12@hmac_sha51
$LN14@hmac_sha51:
  003a6	33 d2		 xor	 edx, edx
  003a8	75 ab		 jne	 SHORT $LN15@hmac_sha51
$LN10@hmac_sha51:

; 108  : 	burn (buf, sizeof(buf));

  003aa	8d 85 b8 fe ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  003b0	89 85 18 fc ff
	ff		 mov	 DWORD PTR _burnm$27065[ebp], eax
  003b6	c7 85 1c fc ff
	ff 80 00 00 00	 mov	 DWORD PTR _burnc$27067[ebp], 128 ; 00000080H
  003c0	68 80 00 00 00	 push	 128			; 00000080H
  003c5	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR _buf$[ebp]
  003cb	51		 push	 ecx
  003cc	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN7@hmac_sha51:
  003d1	8b 95 1c fc ff
	ff		 mov	 edx, DWORD PTR _burnc$27067[ebp]
  003d7	8b 85 1c fc ff
	ff		 mov	 eax, DWORD PTR _burnc$27067[ebp]
  003dd	83 e8 01	 sub	 eax, 1
  003e0	89 85 1c fc ff
	ff		 mov	 DWORD PTR _burnc$27067[ebp], eax
  003e6	85 d2		 test	 edx, edx
  003e8	74 1a		 je	 SHORT $LN9@hmac_sha51
  003ea	8b 8d 18 fc ff
	ff		 mov	 ecx, DWORD PTR _burnm$27065[ebp]
  003f0	c6 01 00	 mov	 BYTE PTR [ecx], 0
  003f3	8b 95 18 fc ff
	ff		 mov	 edx, DWORD PTR _burnm$27065[ebp]
  003f9	83 c2 01	 add	 edx, 1
  003fc	89 95 18 fc ff
	ff		 mov	 DWORD PTR _burnm$27065[ebp], edx
  00402	eb cd		 jmp	 SHORT $LN7@hmac_sha51
$LN9@hmac_sha51:
  00404	33 c0		 xor	 eax, eax
  00406	75 a2		 jne	 SHORT $LN10@hmac_sha51
$LN5@hmac_sha51:

; 109  : 	burn (key, sizeof(key));

  00408	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR _key$[ebp]
  0040e	89 8d 10 fc ff
	ff		 mov	 DWORD PTR _burnm$27074[ebp], ecx
  00414	c7 85 14 fc ff
	ff 40 00 00 00	 mov	 DWORD PTR _burnc$27076[ebp], 64 ; 00000040H
  0041e	6a 40		 push	 64			; 00000040H
  00420	8d 95 38 ff ff
	ff		 lea	 edx, DWORD PTR _key$[ebp]
  00426	52		 push	 edx
  00427	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@hmac_sha51:
  0042c	8b 85 14 fc ff
	ff		 mov	 eax, DWORD PTR _burnc$27076[ebp]
  00432	8b 8d 14 fc ff
	ff		 mov	 ecx, DWORD PTR _burnc$27076[ebp]
  00438	83 e9 01	 sub	 ecx, 1
  0043b	89 8d 14 fc ff
	ff		 mov	 DWORD PTR _burnc$27076[ebp], ecx
  00441	85 c0		 test	 eax, eax
  00443	74 1a		 je	 SHORT $LN4@hmac_sha51
  00445	8b 95 10 fc ff
	ff		 mov	 edx, DWORD PTR _burnm$27074[ebp]
  0044b	c6 02 00	 mov	 BYTE PTR [edx], 0
  0044e	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _burnm$27074[ebp]
  00454	83 c0 01	 add	 eax, 1
  00457	89 85 10 fc ff
	ff		 mov	 DWORD PTR _burnm$27074[ebp], eax
  0045d	eb cd		 jmp	 SHORT $LN2@hmac_sha51
$LN4@hmac_sha51:
  0045f	33 c9		 xor	 ecx, ecx
  00461	75 a5		 jne	 SHORT $LN5@hmac_sha51

; 110  : }

  00463	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00466	33 cd		 xor	 ecx, ebp
  00468	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0046d	8b e5		 mov	 esp, ebp
  0046f	5d		 pop	 ebp
  00470	c2 18 00	 ret	 24			; 00000018H
_hmac_sha512@24 ENDP
; Function compile flags: /Odtp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT _RtlSecureZeroMemory@8
_TEXT	SEGMENT
_vptr$ = -4						; size = 4
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory@8 PROC				; COMDAT

; 8322 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 8323 :     volatile char *vptr = (volatile char *)ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _vptr$[ebp], eax
$LN2@RtlSecureZ:

; 8324 : 
; 8325 : #if defined(_M_AMD64)
; 8326 : 
; 8327 :         __stosb((PUCHAR)((ULONG64)vptr), 0, cnt);
; 8328 : 
; 8329 : #else
; 8330 : 
; 8331 :     while (cnt) {

  0000c	83 7d 0c 00	 cmp	 DWORD PTR _cnt$[ebp], 0
  00010	74 1a		 je	 SHORT $LN1@RtlSecureZ

; 8332 :         *vptr = 0;

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _vptr$[ebp]
  00015	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 8333 :         vptr++;

  00018	8b 55 fc	 mov	 edx, DWORD PTR _vptr$[ebp]
  0001b	83 c2 01	 add	 edx, 1
  0001e	89 55 fc	 mov	 DWORD PTR _vptr$[ebp], edx

; 8334 :         cnt--;

  00021	8b 45 0c	 mov	 eax, DWORD PTR _cnt$[ebp]
  00024	83 e8 01	 sub	 eax, 1
  00027	89 45 0c	 mov	 DWORD PTR _cnt$[ebp], eax

; 8335 :     }

  0002a	eb e0		 jmp	 SHORT $LN2@RtlSecureZ
$LN1@RtlSecureZ:

; 8336 : 
; 8337 : #endif
; 8338 : 
; 8339 :     return ptr;

  0002c	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]

; 8340 : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
_RtlSecureZeroMemory@8 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_derive_u_sha512@28
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
; File c:\home\public\desktop\projects\ciphershed.build\src\common\pkcs5.c
;	COMDAT _derive_u_sha512@28
_TEXT	SEGMENT
_burnm$27120 = -296					; size = 4
_burnc$27122 = -292					; size = 4
_burnm$27111 = -288					; size = 4
_burnc$27113 = -284					; size = 4
_j$ = -280						; size = 64
_c$ = -212						; size = 4
_k$ = -208						; size = 64
_counter$ = -140					; size = 4
_init$ = -136						; size = 128
__$ArrayPad$ = -8					; size = 4
_i$ = -4						; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_u$ = 28						; size = 4
_b$ = 32						; size = 4
_derive_u_sha512@28 PROC				; COMDAT

; 114  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 28 01 00
	00		 sub	 esp, 296		; 00000128H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi
  00016	57		 push	 edi

; 115  : 	char j[SHA512_DIGESTSIZE], k[SHA512_DIGESTSIZE];
; 116  : 	char init[128];
; 117  : 	char counter[4];
; 118  : 	int c, i;
; 119  : 
; 120  : 	/* iteration 1 */
; 121  : 	memset (counter, 0, 4);

  00017	33 c0		 xor	 eax, eax
  00019	89 85 74 ff ff
	ff		 mov	 DWORD PTR _counter$[ebp], eax

; 122  : 	counter[3] = (char) b;

  0001f	8a 4d 20	 mov	 cl, BYTE PTR _b$[ebp]
  00022	88 8d 77 ff ff
	ff		 mov	 BYTE PTR _counter$[ebp+3], cl

; 123  : 	memcpy (init, salt, salt_len);	/* salt */

  00028	8b 55 14	 mov	 edx, DWORD PTR _salt_len$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 10	 mov	 eax, DWORD PTR _salt$[ebp]
  0002f	50		 push	 eax
  00030	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _init$[ebp]
  00036	51		 push	 ecx
  00037	e8 00 00 00 00	 call	 _memcpy
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 124  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */

  0003f	8b 55 14	 mov	 edx, DWORD PTR _salt_len$[ebp]
  00042	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _counter$[ebp]
  00048	89 84 15 78 ff
	ff ff		 mov	 DWORD PTR _init$[ebp+edx], eax

; 125  : 	hmac_sha512 (pwd, pwd_len, init, salt_len + 4, j, SHA512_DIGESTSIZE);

  0004f	6a 40		 push	 64			; 00000040H
  00051	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _j$[ebp]
  00057	51		 push	 ecx
  00058	8b 55 14	 mov	 edx, DWORD PTR _salt_len$[ebp]
  0005b	83 c2 04	 add	 edx, 4
  0005e	52		 push	 edx
  0005f	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _init$[ebp]
  00065	50		 push	 eax
  00066	8b 4d 0c	 mov	 ecx, DWORD PTR _pwd_len$[ebp]
  00069	51		 push	 ecx
  0006a	8b 55 08	 mov	 edx, DWORD PTR _pwd$[ebp]
  0006d	52		 push	 edx
  0006e	e8 00 00 00 00	 call	 _hmac_sha512@24

; 126  : 	memcpy (u, j, SHA512_DIGESTSIZE);

  00073	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00078	8d b5 e8 fe ff
	ff		 lea	 esi, DWORD PTR _j$[ebp]
  0007e	8b 7d 1c	 mov	 edi, DWORD PTR _u$[ebp]
  00081	f3 a5		 rep movsd

; 127  : 
; 128  : 	/* remaining iterations */
; 129  : 	for (c = 1; c < iterations; c++)

  00083	c7 85 2c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _c$[ebp], 1
  0008d	eb 0f		 jmp	 SHORT $LN16@derive_u_s
$LN15@derive_u_s:
  0008f	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _c$[ebp]
  00095	83 c0 01	 add	 eax, 1
  00098	89 85 2c ff ff
	ff		 mov	 DWORD PTR _c$[ebp], eax
$LN16@derive_u_s:
  0009e	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _c$[ebp]
  000a4	3b 4d 18	 cmp	 ecx, DWORD PTR _iterations$[ebp]
  000a7	7d 70		 jge	 SHORT $LN10@derive_u_s

; 130  : 	{
; 131  : 		hmac_sha512 (pwd, pwd_len, j, SHA512_DIGESTSIZE, k, SHA512_DIGESTSIZE);

  000a9	6a 40		 push	 64			; 00000040H
  000ab	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR _k$[ebp]
  000b1	52		 push	 edx
  000b2	6a 40		 push	 64			; 00000040H
  000b4	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _j$[ebp]
  000ba	50		 push	 eax
  000bb	8b 4d 0c	 mov	 ecx, DWORD PTR _pwd_len$[ebp]
  000be	51		 push	 ecx
  000bf	8b 55 08	 mov	 edx, DWORD PTR _pwd$[ebp]
  000c2	52		 push	 edx
  000c3	e8 00 00 00 00	 call	 _hmac_sha512@24

; 132  : 		for (i = 0; i < SHA512_DIGESTSIZE; i++)

  000c8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000cf	eb 09		 jmp	 SHORT $LN13@derive_u_s
$LN12@derive_u_s:
  000d1	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000d4	83 c0 01	 add	 eax, 1
  000d7	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN13@derive_u_s:
  000da	83 7d fc 40	 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  000de	7d 34		 jge	 SHORT $LN11@derive_u_s

; 133  : 		{
; 134  : 			u[i] ^= k[i];

  000e0	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000e3	0f be 94 0d 30
	ff ff ff	 movsx	 edx, BYTE PTR _k$[ebp+ecx]
  000eb	8b 45 1c	 mov	 eax, DWORD PTR _u$[ebp]
  000ee	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  000f1	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000f4	33 ca		 xor	 ecx, edx
  000f6	8b 55 1c	 mov	 edx, DWORD PTR _u$[ebp]
  000f9	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  000fc	88 0a		 mov	 BYTE PTR [edx], cl

; 135  : 			j[i] = k[i];

  000fe	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00101	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00104	8a 94 0d 30 ff
	ff ff		 mov	 dl, BYTE PTR _k$[ebp+ecx]
  0010b	88 94 05 e8 fe
	ff ff		 mov	 BYTE PTR _j$[ebp+eax], dl

; 136  : 		}

  00112	eb bd		 jmp	 SHORT $LN12@derive_u_s
$LN11@derive_u_s:

; 137  : 	}

  00114	e9 76 ff ff ff	 jmp	 $LN15@derive_u_s
$LN10@derive_u_s:

; 138  : 
; 139  : 	/* Prevent possible leaks. */
; 140  : 	burn (j, sizeof(j));

  00119	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _j$[ebp]
  0011f	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _burnm$27111[ebp], eax
  00125	c7 85 e4 fe ff
	ff 40 00 00 00	 mov	 DWORD PTR _burnc$27113[ebp], 64 ; 00000040H
  0012f	6a 40		 push	 64			; 00000040H
  00131	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _j$[ebp]
  00137	51		 push	 ecx
  00138	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN7@derive_u_s:
  0013d	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _burnc$27113[ebp]
  00143	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _burnc$27113[ebp]
  00149	83 e8 01	 sub	 eax, 1
  0014c	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _burnc$27113[ebp], eax
  00152	85 d2		 test	 edx, edx
  00154	74 1a		 je	 SHORT $LN9@derive_u_s
  00156	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _burnm$27111[ebp]
  0015c	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0015f	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _burnm$27111[ebp]
  00165	83 c2 01	 add	 edx, 1
  00168	89 95 e0 fe ff
	ff		 mov	 DWORD PTR _burnm$27111[ebp], edx
  0016e	eb cd		 jmp	 SHORT $LN7@derive_u_s
$LN9@derive_u_s:
  00170	33 c0		 xor	 eax, eax
  00172	75 a5		 jne	 SHORT $LN10@derive_u_s
$LN5@derive_u_s:

; 141  : 	burn (k, sizeof(k));

  00174	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _k$[ebp]
  0017a	89 8d d8 fe ff
	ff		 mov	 DWORD PTR _burnm$27120[ebp], ecx
  00180	c7 85 dc fe ff
	ff 40 00 00 00	 mov	 DWORD PTR _burnc$27122[ebp], 64 ; 00000040H
  0018a	6a 40		 push	 64			; 00000040H
  0018c	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR _k$[ebp]
  00192	52		 push	 edx
  00193	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@derive_u_s:
  00198	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _burnc$27122[ebp]
  0019e	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _burnc$27122[ebp]
  001a4	83 e9 01	 sub	 ecx, 1
  001a7	89 8d dc fe ff
	ff		 mov	 DWORD PTR _burnc$27122[ebp], ecx
  001ad	85 c0		 test	 eax, eax
  001af	74 1a		 je	 SHORT $LN4@derive_u_s
  001b1	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _burnm$27120[ebp]
  001b7	c6 02 00	 mov	 BYTE PTR [edx], 0
  001ba	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _burnm$27120[ebp]
  001c0	83 c0 01	 add	 eax, 1
  001c3	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _burnm$27120[ebp], eax
  001c9	eb cd		 jmp	 SHORT $LN2@derive_u_s
$LN4@derive_u_s:
  001cb	33 c9		 xor	 ecx, ecx
  001cd	75 a5		 jne	 SHORT $LN5@derive_u_s

; 142  : }

  001cf	5f		 pop	 edi
  001d0	5e		 pop	 esi
  001d1	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d4	33 cd		 xor	 ecx, ebp
  001d6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001db	8b e5		 mov	 esp, ebp
  001dd	5d		 pop	 ebp
  001de	c2 1c 00	 ret	 28			; 0000001cH
_derive_u_sha512@28 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_derive_key_sha512@28
; Function compile flags: /Odtp
;	COMDAT _derive_key_sha512@28
_TEXT	SEGMENT
_burnm$27153 = -92					; size = 4
_burnc$27155 = -88					; size = 4
_r$ = -84						; size = 4
_l$ = -80						; size = 4
_b$ = -76						; size = 4
_u$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_dk$ = 28						; size = 4
_dklen$ = 32						; size = 4
_derive_key_sha512@28 PROC				; COMDAT

; 146  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00012	56		 push	 esi
  00013	57		 push	 edi

; 147  : 	char u[SHA512_DIGESTSIZE];
; 148  : 	int b, l, r;
; 149  : 
; 150  : 	if (dklen % SHA512_DIGESTSIZE)

  00014	8b 45 20	 mov	 eax, DWORD PTR _dklen$[ebp]
  00017	25 3f 00 00 80	 and	 eax, -2147483585	; 8000003fH
  0001c	79 05		 jns	 SHORT $LN13@derive_key
  0001e	48		 dec	 eax
  0001f	83 c8 c0	 or	 eax, -64		; ffffffc0H
  00022	40		 inc	 eax
$LN13@derive_key:
  00023	85 c0		 test	 eax, eax
  00025	74 14		 je	 SHORT $LN10@derive_key

; 151  : 	{
; 152  : 		l = 1 + dklen / SHA512_DIGESTSIZE;

  00027	8b 45 20	 mov	 eax, DWORD PTR _dklen$[ebp]
  0002a	99		 cdq
  0002b	83 e2 3f	 and	 edx, 63			; 0000003fH
  0002e	03 c2		 add	 eax, edx
  00030	c1 f8 06	 sar	 eax, 6
  00033	83 c0 01	 add	 eax, 1
  00036	89 45 b0	 mov	 DWORD PTR _l$[ebp], eax

; 153  : 	}
; 154  : 	else

  00039	eb 0f		 jmp	 SHORT $LN9@derive_key
$LN10@derive_key:

; 155  : 	{
; 156  : 		l = dklen / SHA512_DIGESTSIZE;

  0003b	8b 45 20	 mov	 eax, DWORD PTR _dklen$[ebp]
  0003e	99		 cdq
  0003f	83 e2 3f	 and	 edx, 63			; 0000003fH
  00042	03 c2		 add	 eax, edx
  00044	c1 f8 06	 sar	 eax, 6
  00047	89 45 b0	 mov	 DWORD PTR _l$[ebp], eax
$LN9@derive_key:

; 157  : 	}
; 158  : 
; 159  : 	r = dklen - (l - 1) * SHA512_DIGESTSIZE;

  0004a	8b 4d b0	 mov	 ecx, DWORD PTR _l$[ebp]
  0004d	83 e9 01	 sub	 ecx, 1
  00050	c1 e1 06	 shl	 ecx, 6
  00053	8b 55 20	 mov	 edx, DWORD PTR _dklen$[ebp]
  00056	2b d1		 sub	 edx, ecx
  00058	89 55 ac	 mov	 DWORD PTR _r$[ebp], edx

; 160  : 
; 161  : 	/* first l - 1 blocks */
; 162  : 	for (b = 1; b < l; b++)

  0005b	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR _b$[ebp], 1
  00062	eb 09		 jmp	 SHORT $LN8@derive_key
$LN7@derive_key:
  00064	8b 45 b4	 mov	 eax, DWORD PTR _b$[ebp]
  00067	83 c0 01	 add	 eax, 1
  0006a	89 45 b4	 mov	 DWORD PTR _b$[ebp], eax
$LN8@derive_key:
  0006d	8b 4d b4	 mov	 ecx, DWORD PTR _b$[ebp]
  00070	3b 4d b0	 cmp	 ecx, DWORD PTR _l$[ebp]
  00073	7d 39		 jge	 SHORT $LN6@derive_key

; 163  : 	{
; 164  : 		derive_u_sha512 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  00075	8b 55 b4	 mov	 edx, DWORD PTR _b$[ebp]
  00078	52		 push	 edx
  00079	8d 45 b8	 lea	 eax, DWORD PTR _u$[ebp]
  0007c	50		 push	 eax
  0007d	8b 4d 18	 mov	 ecx, DWORD PTR _iterations$[ebp]
  00080	51		 push	 ecx
  00081	8b 55 14	 mov	 edx, DWORD PTR _salt_len$[ebp]
  00084	52		 push	 edx
  00085	8b 45 10	 mov	 eax, DWORD PTR _salt$[ebp]
  00088	50		 push	 eax
  00089	8b 4d 0c	 mov	 ecx, DWORD PTR _pwd_len$[ebp]
  0008c	51		 push	 ecx
  0008d	8b 55 08	 mov	 edx, DWORD PTR _pwd$[ebp]
  00090	52		 push	 edx
  00091	e8 00 00 00 00	 call	 _derive_u_sha512@28

; 165  : 		memcpy (dk, u, SHA512_DIGESTSIZE);

  00096	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0009b	8d 75 b8	 lea	 esi, DWORD PTR _u$[ebp]
  0009e	8b 7d 1c	 mov	 edi, DWORD PTR _dk$[ebp]
  000a1	f3 a5		 rep movsd

; 166  : 		dk += SHA512_DIGESTSIZE;

  000a3	8b 45 1c	 mov	 eax, DWORD PTR _dk$[ebp]
  000a6	83 c0 40	 add	 eax, 64			; 00000040H
  000a9	89 45 1c	 mov	 DWORD PTR _dk$[ebp], eax

; 167  : 	}

  000ac	eb b6		 jmp	 SHORT $LN7@derive_key
$LN6@derive_key:

; 168  : 
; 169  : 	/* last block */
; 170  : 	derive_u_sha512 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  000ae	8b 4d b4	 mov	 ecx, DWORD PTR _b$[ebp]
  000b1	51		 push	 ecx
  000b2	8d 55 b8	 lea	 edx, DWORD PTR _u$[ebp]
  000b5	52		 push	 edx
  000b6	8b 45 18	 mov	 eax, DWORD PTR _iterations$[ebp]
  000b9	50		 push	 eax
  000ba	8b 4d 14	 mov	 ecx, DWORD PTR _salt_len$[ebp]
  000bd	51		 push	 ecx
  000be	8b 55 10	 mov	 edx, DWORD PTR _salt$[ebp]
  000c1	52		 push	 edx
  000c2	8b 45 0c	 mov	 eax, DWORD PTR _pwd_len$[ebp]
  000c5	50		 push	 eax
  000c6	8b 4d 08	 mov	 ecx, DWORD PTR _pwd$[ebp]
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 _derive_u_sha512@28

; 171  : 	memcpy (dk, u, r);

  000cf	8b 55 ac	 mov	 edx, DWORD PTR _r$[ebp]
  000d2	52		 push	 edx
  000d3	8d 45 b8	 lea	 eax, DWORD PTR _u$[ebp]
  000d6	50		 push	 eax
  000d7	8b 4d 1c	 mov	 ecx, DWORD PTR _dk$[ebp]
  000da	51		 push	 ecx
  000db	e8 00 00 00 00	 call	 _memcpy
  000e0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@derive_key:

; 172  : 
; 173  : 
; 174  : 	/* Prevent possible leaks. */
; 175  : 	burn (u, sizeof(u));

  000e3	8d 55 b8	 lea	 edx, DWORD PTR _u$[ebp]
  000e6	89 55 a4	 mov	 DWORD PTR _burnm$27153[ebp], edx
  000e9	c7 45 a8 40 00
	00 00		 mov	 DWORD PTR _burnc$27155[ebp], 64 ; 00000040H
  000f0	6a 40		 push	 64			; 00000040H
  000f2	8d 45 b8	 lea	 eax, DWORD PTR _u$[ebp]
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@derive_key:
  000fb	8b 4d a8	 mov	 ecx, DWORD PTR _burnc$27155[ebp]
  000fe	8b 55 a8	 mov	 edx, DWORD PTR _burnc$27155[ebp]
  00101	83 ea 01	 sub	 edx, 1
  00104	89 55 a8	 mov	 DWORD PTR _burnc$27155[ebp], edx
  00107	85 c9		 test	 ecx, ecx
  00109	74 11		 je	 SHORT $LN4@derive_key
  0010b	8b 45 a4	 mov	 eax, DWORD PTR _burnm$27153[ebp]
  0010e	c6 00 00	 mov	 BYTE PTR [eax], 0
  00111	8b 4d a4	 mov	 ecx, DWORD PTR _burnm$27153[ebp]
  00114	83 c1 01	 add	 ecx, 1
  00117	89 4d a4	 mov	 DWORD PTR _burnm$27153[ebp], ecx
  0011a	eb df		 jmp	 SHORT $LN2@derive_key
$LN4@derive_key:
  0011c	33 d2		 xor	 edx, edx
  0011e	75 c3		 jne	 SHORT $LN5@derive_key

; 176  : }

  00120	5f		 pop	 edi
  00121	5e		 pop	 esi
  00122	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00125	33 cd		 xor	 ecx, ebp
  00127	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c2 1c 00	 ret	 28			; 0000001cH
_derive_key_sha512@28 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_hmac_sha1@24
EXTRN	_sha1_end@8:PROC
EXTRN	_sha1_hash@12:PROC
EXTRN	_sha1_begin@4:PROC
; Function compile flags: /Odtp
;	COMDAT _hmac_sha1@24
_TEXT	SEGMENT
tv148 = -484						; size = 4
_burnm$27260 = -480					; size = 4
_burnc$27262 = -476					; size = 4
_burnm$27251 = -472					; size = 4
_burnc$27253 = -468					; size = 4
_burnm$27242 = -464					; size = 4
_burnc$27244 = -460					; size = 4
_burnm$27233 = -456					; size = 4
_burnc$27235 = -452					; size = 4
_burnm$27224 = -448					; size = 4
_burnc$27226 = -444					; size = 4
_burnm$27215 = -440					; size = 4
_burnc$27217 = -436					; size = 4
_burnm$27186 = -432					; size = 4
_burnc$27188 = -428					; size = 4
_tctx$27180 = -424					; size = 92
_octx$ = -328						; size = 92
_ictx$ = -232						; size = 92
_buf$ = -136						; size = 64
_key$ = -68						; size = 20
_isha$ = -48						; size = 20
_osha$ = -28						; size = 20
__$ArrayPad$ = -8					; size = 4
_i$ = -4						; size = 4
_k$ = 8							; size = 4
_lk$ = 12						; size = 4
_d$ = 16						; size = 4
_ld$ = 20						; size = 4
_out$ = 24						; size = 4
_t$ = 28						; size = 4
_hmac_sha1@24 PROC					; COMDAT

; 189  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec e4 01 00
	00		 sub	 esp, 484		; 000001e4H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 190  : 	sha1_ctx ictx, octx;
; 191  : 	char isha[SHA1_DIGESTSIZE], osha[SHA1_DIGESTSIZE];
; 192  : 	char key[SHA1_DIGESTSIZE];
; 193  : 	char buf[SHA1_BLOCKSIZE];
; 194  : 	int i;
; 195  : 
; 196  :     /* If the key is longer than the hash algorithm block size,
; 197  : 	   let key = sha1(key), as per HMAC specifications. */
; 198  : 	if (lk > SHA1_BLOCKSIZE)

  00015	83 7d 0c 40	 cmp	 DWORD PTR _lk$[ebp], 64	; 00000040H
  00019	0f 8e 98 00 00
	00		 jle	 $LN48@hmac_sha1

; 199  : 	{
; 200  : 		sha1_ctx tctx;
; 201  : 
; 202  : 		sha1_begin (&tctx);

  0001f	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR _tctx$27180[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _sha1_begin@4

; 203  : 		sha1_hash ((unsigned char *) k, lk, &tctx);

  0002b	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR _tctx$27180[ebp]
  00031	51		 push	 ecx
  00032	8b 55 0c	 mov	 edx, DWORD PTR _lk$[ebp]
  00035	52		 push	 edx
  00036	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _sha1_hash@12

; 204  : 		sha1_end ((unsigned char *) key, &tctx);

  0003f	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR _tctx$27180[ebp]
  00045	51		 push	 ecx
  00046	8d 55 bc	 lea	 edx, DWORD PTR _key$[ebp]
  00049	52		 push	 edx
  0004a	e8 00 00 00 00	 call	 _sha1_end@8

; 205  : 
; 206  : 		k = key;

  0004f	8d 45 bc	 lea	 eax, DWORD PTR _key$[ebp]
  00052	89 45 08	 mov	 DWORD PTR _k$[ebp], eax

; 207  : 		lk = SHA1_DIGESTSIZE;

  00055	c7 45 0c 14 00
	00 00		 mov	 DWORD PTR _lk$[ebp], 20	; 00000014H
$LN47@hmac_sha1:

; 208  : 
; 209  : 		burn (&tctx, sizeof(tctx));		// Prevent leaks

  0005c	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR _tctx$27180[ebp]
  00062	89 8d 50 fe ff
	ff		 mov	 DWORD PTR _burnm$27186[ebp], ecx
  00068	c7 85 54 fe ff
	ff 5c 00 00 00	 mov	 DWORD PTR _burnc$27188[ebp], 92 ; 0000005cH
  00072	6a 5c		 push	 92			; 0000005cH
  00074	8d 95 58 fe ff
	ff		 lea	 edx, DWORD PTR _tctx$27180[ebp]
  0007a	52		 push	 edx
  0007b	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN44@hmac_sha1:
  00080	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR _burnc$27188[ebp]
  00086	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR _burnc$27188[ebp]
  0008c	83 e9 01	 sub	 ecx, 1
  0008f	89 8d 54 fe ff
	ff		 mov	 DWORD PTR _burnc$27188[ebp], ecx
  00095	85 c0		 test	 eax, eax
  00097	74 1a		 je	 SHORT $LN46@hmac_sha1
  00099	8b 95 50 fe ff
	ff		 mov	 edx, DWORD PTR _burnm$27186[ebp]
  0009f	c6 02 00	 mov	 BYTE PTR [edx], 0
  000a2	8b 85 50 fe ff
	ff		 mov	 eax, DWORD PTR _burnm$27186[ebp]
  000a8	83 c0 01	 add	 eax, 1
  000ab	89 85 50 fe ff
	ff		 mov	 DWORD PTR _burnm$27186[ebp], eax
  000b1	eb cd		 jmp	 SHORT $LN44@hmac_sha1
$LN46@hmac_sha1:
  000b3	33 c9		 xor	 ecx, ecx
  000b5	75 a5		 jne	 SHORT $LN47@hmac_sha1
$LN48@hmac_sha1:

; 210  : 	}
; 211  : 
; 212  : 	/**** Inner Digest ****/
; 213  : 
; 214  : 	sha1_begin (&ictx);

  000b7	8d 95 18 ff ff
	ff		 lea	 edx, DWORD PTR _ictx$[ebp]
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 _sha1_begin@4

; 215  : 
; 216  : 	/* Pad the key for inner digest */
; 217  : 	for (i = 0; i < lk; ++i)

  000c3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000ca	eb 09		 jmp	 SHORT $LN42@hmac_sha1
$LN41@hmac_sha1:
  000cc	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000cf	83 c0 01	 add	 eax, 1
  000d2	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN42@hmac_sha1:
  000d5	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000d8	3b 4d 0c	 cmp	 ecx, DWORD PTR _lk$[ebp]
  000db	7d 18		 jge	 SHORT $LN40@hmac_sha1

; 218  : 		buf[i] = (char) (k[i] ^ 0x36);

  000dd	8b 55 08	 mov	 edx, DWORD PTR _k$[ebp]
  000e0	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  000e3	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000e6	83 f0 36	 xor	 eax, 54			; 00000036H
  000e9	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000ec	88 84 0d 78 ff
	ff ff		 mov	 BYTE PTR _buf$[ebp+ecx], al
  000f3	eb d7		 jmp	 SHORT $LN41@hmac_sha1
$LN40@hmac_sha1:

; 219  : 	for (i = lk; i < SHA1_BLOCKSIZE; ++i)

  000f5	8b 55 0c	 mov	 edx, DWORD PTR _lk$[ebp]
  000f8	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
  000fb	eb 09		 jmp	 SHORT $LN39@hmac_sha1
$LN38@hmac_sha1:
  000fd	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00100	83 c0 01	 add	 eax, 1
  00103	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN39@hmac_sha1:
  00106	83 7d fc 40	 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  0010a	7d 0d		 jge	 SHORT $LN37@hmac_sha1

; 220  : 		buf[i] = 0x36;

  0010c	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0010f	c6 84 0d 78 ff
	ff ff 36	 mov	 BYTE PTR _buf$[ebp+ecx], 54 ; 00000036H
  00117	eb e4		 jmp	 SHORT $LN38@hmac_sha1
$LN37@hmac_sha1:

; 221  : 
; 222  : 	sha1_hash ((unsigned char *) buf, SHA1_BLOCKSIZE, &ictx);

  00119	8d 95 18 ff ff
	ff		 lea	 edx, DWORD PTR _ictx$[ebp]
  0011f	52		 push	 edx
  00120	6a 40		 push	 64			; 00000040H
  00122	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  00128	50		 push	 eax
  00129	e8 00 00 00 00	 call	 _sha1_hash@12

; 223  : 	sha1_hash ((unsigned char *) d, ld, &ictx);

  0012e	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _ictx$[ebp]
  00134	51		 push	 ecx
  00135	8b 55 14	 mov	 edx, DWORD PTR _ld$[ebp]
  00138	52		 push	 edx
  00139	8b 45 10	 mov	 eax, DWORD PTR _d$[ebp]
  0013c	50		 push	 eax
  0013d	e8 00 00 00 00	 call	 _sha1_hash@12

; 224  : 
; 225  : 	sha1_end ((unsigned char *) isha, &ictx);

  00142	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _ictx$[ebp]
  00148	51		 push	 ecx
  00149	8d 55 d0	 lea	 edx, DWORD PTR _isha$[ebp]
  0014c	52		 push	 edx
  0014d	e8 00 00 00 00	 call	 _sha1_end@8

; 226  : 
; 227  : 	/**** Outer Digest ****/
; 228  : 
; 229  : 	sha1_begin (&octx);

  00152	8d 85 b8 fe ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  00158	50		 push	 eax
  00159	e8 00 00 00 00	 call	 _sha1_begin@4

; 230  : 
; 231  : 	for (i = 0; i < lk; ++i)

  0015e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00165	eb 09		 jmp	 SHORT $LN36@hmac_sha1
$LN35@hmac_sha1:
  00167	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0016a	83 c1 01	 add	 ecx, 1
  0016d	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN36@hmac_sha1:
  00170	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00173	3b 55 0c	 cmp	 edx, DWORD PTR _lk$[ebp]
  00176	7d 18		 jge	 SHORT $LN34@hmac_sha1

; 232  : 		buf[i] = (char) (k[i] ^ 0x5C);

  00178	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]
  0017b	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0017e	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00181	83 f1 5c	 xor	 ecx, 92			; 0000005cH
  00184	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00187	88 8c 15 78 ff
	ff ff		 mov	 BYTE PTR _buf$[ebp+edx], cl
  0018e	eb d7		 jmp	 SHORT $LN35@hmac_sha1
$LN34@hmac_sha1:

; 233  : 	for (i = lk; i < SHA1_BLOCKSIZE; ++i)

  00190	8b 45 0c	 mov	 eax, DWORD PTR _lk$[ebp]
  00193	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00196	eb 09		 jmp	 SHORT $LN33@hmac_sha1
$LN32@hmac_sha1:
  00198	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0019b	83 c1 01	 add	 ecx, 1
  0019e	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN33@hmac_sha1:
  001a1	83 7d fc 40	 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  001a5	7d 0d		 jge	 SHORT $LN31@hmac_sha1

; 234  : 		buf[i] = 0x5C;

  001a7	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  001aa	c6 84 15 78 ff
	ff ff 5c	 mov	 BYTE PTR _buf$[ebp+edx], 92 ; 0000005cH
  001b2	eb e4		 jmp	 SHORT $LN32@hmac_sha1
$LN31@hmac_sha1:

; 235  : 
; 236  : 	sha1_hash ((unsigned char *) buf, SHA1_BLOCKSIZE, &octx);

  001b4	8d 85 b8 fe ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  001ba	50		 push	 eax
  001bb	6a 40		 push	 64			; 00000040H
  001bd	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _buf$[ebp]
  001c3	51		 push	 ecx
  001c4	e8 00 00 00 00	 call	 _sha1_hash@12

; 237  : 	sha1_hash ((unsigned char *) isha, SHA1_DIGESTSIZE, &octx);

  001c9	8d 95 b8 fe ff
	ff		 lea	 edx, DWORD PTR _octx$[ebp]
  001cf	52		 push	 edx
  001d0	6a 14		 push	 20			; 00000014H
  001d2	8d 45 d0	 lea	 eax, DWORD PTR _isha$[ebp]
  001d5	50		 push	 eax
  001d6	e8 00 00 00 00	 call	 _sha1_hash@12

; 238  : 
; 239  : 	sha1_end ((unsigned char *) osha, &octx);

  001db	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR _octx$[ebp]
  001e1	51		 push	 ecx
  001e2	8d 55 e4	 lea	 edx, DWORD PTR _osha$[ebp]
  001e5	52		 push	 edx
  001e6	e8 00 00 00 00	 call	 _sha1_end@8

; 240  : 
; 241  : 	/* truncate and print the results */
; 242  : 	t = t > SHA1_DIGESTSIZE ? SHA1_DIGESTSIZE : t;

  001eb	83 7d 1c 14	 cmp	 DWORD PTR _t$[ebp], 20	; 00000014H
  001ef	7e 0c		 jle	 SHORT $LN51@hmac_sha1
  001f1	c7 85 1c fe ff
	ff 14 00 00 00	 mov	 DWORD PTR tv148[ebp], 20 ; 00000014H
  001fb	eb 09		 jmp	 SHORT $LN52@hmac_sha1
$LN51@hmac_sha1:
  001fd	8b 45 1c	 mov	 eax, DWORD PTR _t$[ebp]
  00200	89 85 1c fe ff
	ff		 mov	 DWORD PTR tv148[ebp], eax
$LN52@hmac_sha1:
  00206	8b 8d 1c fe ff
	ff		 mov	 ecx, DWORD PTR tv148[ebp]
  0020c	89 4d 1c	 mov	 DWORD PTR _t$[ebp], ecx

; 243  : 	hmac_truncate (osha, out, t);

  0020f	8b 55 1c	 mov	 edx, DWORD PTR _t$[ebp]
  00212	52		 push	 edx
  00213	8b 45 18	 mov	 eax, DWORD PTR _out$[ebp]
  00216	50		 push	 eax
  00217	8d 4d e4	 lea	 ecx, DWORD PTR _osha$[ebp]
  0021a	51		 push	 ecx
  0021b	e8 00 00 00 00	 call	 _hmac_truncate@12
$LN30@hmac_sha1:

; 244  : 
; 245  : 	/* Prevent leaks */
; 246  : 	burn (&ictx, sizeof(ictx));

  00220	8d 95 18 ff ff
	ff		 lea	 edx, DWORD PTR _ictx$[ebp]
  00226	89 95 48 fe ff
	ff		 mov	 DWORD PTR _burnm$27215[ebp], edx
  0022c	c7 85 4c fe ff
	ff 5c 00 00 00	 mov	 DWORD PTR _burnc$27217[ebp], 92 ; 0000005cH
  00236	6a 5c		 push	 92			; 0000005cH
  00238	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _ictx$[ebp]
  0023e	50		 push	 eax
  0023f	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN27@hmac_sha1:
  00244	8b 8d 4c fe ff
	ff		 mov	 ecx, DWORD PTR _burnc$27217[ebp]
  0024a	8b 95 4c fe ff
	ff		 mov	 edx, DWORD PTR _burnc$27217[ebp]
  00250	83 ea 01	 sub	 edx, 1
  00253	89 95 4c fe ff
	ff		 mov	 DWORD PTR _burnc$27217[ebp], edx
  00259	85 c9		 test	 ecx, ecx
  0025b	74 1a		 je	 SHORT $LN29@hmac_sha1
  0025d	8b 85 48 fe ff
	ff		 mov	 eax, DWORD PTR _burnm$27215[ebp]
  00263	c6 00 00	 mov	 BYTE PTR [eax], 0
  00266	8b 8d 48 fe ff
	ff		 mov	 ecx, DWORD PTR _burnm$27215[ebp]
  0026c	83 c1 01	 add	 ecx, 1
  0026f	89 8d 48 fe ff
	ff		 mov	 DWORD PTR _burnm$27215[ebp], ecx
  00275	eb cd		 jmp	 SHORT $LN27@hmac_sha1
$LN29@hmac_sha1:
  00277	33 d2		 xor	 edx, edx
  00279	75 a5		 jne	 SHORT $LN30@hmac_sha1
$LN25@hmac_sha1:

; 247  : 	burn (&octx, sizeof(octx));

  0027b	8d 85 b8 fe ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  00281	89 85 40 fe ff
	ff		 mov	 DWORD PTR _burnm$27224[ebp], eax
  00287	c7 85 44 fe ff
	ff 5c 00 00 00	 mov	 DWORD PTR _burnc$27226[ebp], 92 ; 0000005cH
  00291	6a 5c		 push	 92			; 0000005cH
  00293	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR _octx$[ebp]
  00299	51		 push	 ecx
  0029a	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN22@hmac_sha1:
  0029f	8b 95 44 fe ff
	ff		 mov	 edx, DWORD PTR _burnc$27226[ebp]
  002a5	8b 85 44 fe ff
	ff		 mov	 eax, DWORD PTR _burnc$27226[ebp]
  002ab	83 e8 01	 sub	 eax, 1
  002ae	89 85 44 fe ff
	ff		 mov	 DWORD PTR _burnc$27226[ebp], eax
  002b4	85 d2		 test	 edx, edx
  002b6	74 1a		 je	 SHORT $LN24@hmac_sha1
  002b8	8b 8d 40 fe ff
	ff		 mov	 ecx, DWORD PTR _burnm$27224[ebp]
  002be	c6 01 00	 mov	 BYTE PTR [ecx], 0
  002c1	8b 95 40 fe ff
	ff		 mov	 edx, DWORD PTR _burnm$27224[ebp]
  002c7	83 c2 01	 add	 edx, 1
  002ca	89 95 40 fe ff
	ff		 mov	 DWORD PTR _burnm$27224[ebp], edx
  002d0	eb cd		 jmp	 SHORT $LN22@hmac_sha1
$LN24@hmac_sha1:
  002d2	33 c0		 xor	 eax, eax
  002d4	75 a5		 jne	 SHORT $LN25@hmac_sha1
$LN20@hmac_sha1:

; 248  : 	burn (isha, sizeof(isha));

  002d6	8d 4d d0	 lea	 ecx, DWORD PTR _isha$[ebp]
  002d9	89 8d 38 fe ff
	ff		 mov	 DWORD PTR _burnm$27233[ebp], ecx
  002df	c7 85 3c fe ff
	ff 14 00 00 00	 mov	 DWORD PTR _burnc$27235[ebp], 20 ; 00000014H
  002e9	6a 14		 push	 20			; 00000014H
  002eb	8d 55 d0	 lea	 edx, DWORD PTR _isha$[ebp]
  002ee	52		 push	 edx
  002ef	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN17@hmac_sha1:
  002f4	8b 85 3c fe ff
	ff		 mov	 eax, DWORD PTR _burnc$27235[ebp]
  002fa	8b 8d 3c fe ff
	ff		 mov	 ecx, DWORD PTR _burnc$27235[ebp]
  00300	83 e9 01	 sub	 ecx, 1
  00303	89 8d 3c fe ff
	ff		 mov	 DWORD PTR _burnc$27235[ebp], ecx
  00309	85 c0		 test	 eax, eax
  0030b	74 1a		 je	 SHORT $LN19@hmac_sha1
  0030d	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR _burnm$27233[ebp]
  00313	c6 02 00	 mov	 BYTE PTR [edx], 0
  00316	8b 85 38 fe ff
	ff		 mov	 eax, DWORD PTR _burnm$27233[ebp]
  0031c	83 c0 01	 add	 eax, 1
  0031f	89 85 38 fe ff
	ff		 mov	 DWORD PTR _burnm$27233[ebp], eax
  00325	eb cd		 jmp	 SHORT $LN17@hmac_sha1
$LN19@hmac_sha1:
  00327	33 c9		 xor	 ecx, ecx
  00329	75 ab		 jne	 SHORT $LN20@hmac_sha1
$LN15@hmac_sha1:

; 249  : 	burn (osha, sizeof(osha));

  0032b	8d 55 e4	 lea	 edx, DWORD PTR _osha$[ebp]
  0032e	89 95 30 fe ff
	ff		 mov	 DWORD PTR _burnm$27242[ebp], edx
  00334	c7 85 34 fe ff
	ff 14 00 00 00	 mov	 DWORD PTR _burnc$27244[ebp], 20 ; 00000014H
  0033e	6a 14		 push	 20			; 00000014H
  00340	8d 45 e4	 lea	 eax, DWORD PTR _osha$[ebp]
  00343	50		 push	 eax
  00344	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN12@hmac_sha1:
  00349	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR _burnc$27244[ebp]
  0034f	8b 95 34 fe ff
	ff		 mov	 edx, DWORD PTR _burnc$27244[ebp]
  00355	83 ea 01	 sub	 edx, 1
  00358	89 95 34 fe ff
	ff		 mov	 DWORD PTR _burnc$27244[ebp], edx
  0035e	85 c9		 test	 ecx, ecx
  00360	74 1a		 je	 SHORT $LN14@hmac_sha1
  00362	8b 85 30 fe ff
	ff		 mov	 eax, DWORD PTR _burnm$27242[ebp]
  00368	c6 00 00	 mov	 BYTE PTR [eax], 0
  0036b	8b 8d 30 fe ff
	ff		 mov	 ecx, DWORD PTR _burnm$27242[ebp]
  00371	83 c1 01	 add	 ecx, 1
  00374	89 8d 30 fe ff
	ff		 mov	 DWORD PTR _burnm$27242[ebp], ecx
  0037a	eb cd		 jmp	 SHORT $LN12@hmac_sha1
$LN14@hmac_sha1:
  0037c	33 d2		 xor	 edx, edx
  0037e	75 ab		 jne	 SHORT $LN15@hmac_sha1
$LN10@hmac_sha1:

; 250  : 	burn (buf, sizeof(buf));

  00380	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  00386	89 85 28 fe ff
	ff		 mov	 DWORD PTR _burnm$27251[ebp], eax
  0038c	c7 85 2c fe ff
	ff 40 00 00 00	 mov	 DWORD PTR _burnc$27253[ebp], 64 ; 00000040H
  00396	6a 40		 push	 64			; 00000040H
  00398	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _buf$[ebp]
  0039e	51		 push	 ecx
  0039f	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN7@hmac_sha1:
  003a4	8b 95 2c fe ff
	ff		 mov	 edx, DWORD PTR _burnc$27253[ebp]
  003aa	8b 85 2c fe ff
	ff		 mov	 eax, DWORD PTR _burnc$27253[ebp]
  003b0	83 e8 01	 sub	 eax, 1
  003b3	89 85 2c fe ff
	ff		 mov	 DWORD PTR _burnc$27253[ebp], eax
  003b9	85 d2		 test	 edx, edx
  003bb	74 1a		 je	 SHORT $LN9@hmac_sha1
  003bd	8b 8d 28 fe ff
	ff		 mov	 ecx, DWORD PTR _burnm$27251[ebp]
  003c3	c6 01 00	 mov	 BYTE PTR [ecx], 0
  003c6	8b 95 28 fe ff
	ff		 mov	 edx, DWORD PTR _burnm$27251[ebp]
  003cc	83 c2 01	 add	 edx, 1
  003cf	89 95 28 fe ff
	ff		 mov	 DWORD PTR _burnm$27251[ebp], edx
  003d5	eb cd		 jmp	 SHORT $LN7@hmac_sha1
$LN9@hmac_sha1:
  003d7	33 c0		 xor	 eax, eax
  003d9	75 a5		 jne	 SHORT $LN10@hmac_sha1
$LN5@hmac_sha1:

; 251  : 	burn (key, sizeof(key));

  003db	8d 4d bc	 lea	 ecx, DWORD PTR _key$[ebp]
  003de	89 8d 20 fe ff
	ff		 mov	 DWORD PTR _burnm$27260[ebp], ecx
  003e4	c7 85 24 fe ff
	ff 14 00 00 00	 mov	 DWORD PTR _burnc$27262[ebp], 20 ; 00000014H
  003ee	6a 14		 push	 20			; 00000014H
  003f0	8d 55 bc	 lea	 edx, DWORD PTR _key$[ebp]
  003f3	52		 push	 edx
  003f4	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@hmac_sha1:
  003f9	8b 85 24 fe ff
	ff		 mov	 eax, DWORD PTR _burnc$27262[ebp]
  003ff	8b 8d 24 fe ff
	ff		 mov	 ecx, DWORD PTR _burnc$27262[ebp]
  00405	83 e9 01	 sub	 ecx, 1
  00408	89 8d 24 fe ff
	ff		 mov	 DWORD PTR _burnc$27262[ebp], ecx
  0040e	85 c0		 test	 eax, eax
  00410	74 1a		 je	 SHORT $LN4@hmac_sha1
  00412	8b 95 20 fe ff
	ff		 mov	 edx, DWORD PTR _burnm$27260[ebp]
  00418	c6 02 00	 mov	 BYTE PTR [edx], 0
  0041b	8b 85 20 fe ff
	ff		 mov	 eax, DWORD PTR _burnm$27260[ebp]
  00421	83 c0 01	 add	 eax, 1
  00424	89 85 20 fe ff
	ff		 mov	 DWORD PTR _burnm$27260[ebp], eax
  0042a	eb cd		 jmp	 SHORT $LN2@hmac_sha1
$LN4@hmac_sha1:
  0042c	33 c9		 xor	 ecx, ecx
  0042e	75 ab		 jne	 SHORT $LN5@hmac_sha1

; 252  : }

  00430	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00433	33 cd		 xor	 ecx, ebp
  00435	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0043a	8b e5		 mov	 esp, ebp
  0043c	5d		 pop	 ebp
  0043d	c2 18 00	 ret	 24			; 00000018H
_hmac_sha1@24 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_derive_u_sha1@28
; Function compile flags: /Odtp
;	COMDAT _derive_u_sha1@28
_TEXT	SEGMENT
_burnm$27306 = -200					; size = 4
_burnc$27308 = -196					; size = 4
_burnm$27297 = -192					; size = 4
_burnc$27299 = -188					; size = 4
_j$ = -184						; size = 20
_c$ = -164						; size = 4
_k$ = -160						; size = 20
_counter$ = -140					; size = 4
_init$ = -136						; size = 128
__$ArrayPad$ = -8					; size = 4
_i$ = -4						; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_u$ = 28						; size = 4
_b$ = 32						; size = 4
_derive_u_sha1@28 PROC					; COMDAT

; 257  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 258  : 	char j[SHA1_DIGESTSIZE], k[SHA1_DIGESTSIZE];
; 259  : 	char init[128];
; 260  : 	char counter[4];
; 261  : 	int c, i;
; 262  : 
; 263  : 	/* iteration 1 */
; 264  : 	memset (counter, 0, 4);

  00015	33 c0		 xor	 eax, eax
  00017	89 85 74 ff ff
	ff		 mov	 DWORD PTR _counter$[ebp], eax

; 265  : 	counter[3] = (char) b;

  0001d	8a 4d 20	 mov	 cl, BYTE PTR _b$[ebp]
  00020	88 8d 77 ff ff
	ff		 mov	 BYTE PTR _counter$[ebp+3], cl

; 266  : 	memcpy (init, salt, salt_len);	/* salt */

  00026	8b 55 14	 mov	 edx, DWORD PTR _salt_len$[ebp]
  00029	52		 push	 edx
  0002a	8b 45 10	 mov	 eax, DWORD PTR _salt$[ebp]
  0002d	50		 push	 eax
  0002e	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _init$[ebp]
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 _memcpy
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 267  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */

  0003d	8b 55 14	 mov	 edx, DWORD PTR _salt_len$[ebp]
  00040	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _counter$[ebp]
  00046	89 84 15 78 ff
	ff ff		 mov	 DWORD PTR _init$[ebp+edx], eax

; 268  : 	hmac_sha1 (pwd, pwd_len, init, salt_len + 4, j, SHA1_DIGESTSIZE);

  0004d	6a 14		 push	 20			; 00000014H
  0004f	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _j$[ebp]
  00055	51		 push	 ecx
  00056	8b 55 14	 mov	 edx, DWORD PTR _salt_len$[ebp]
  00059	83 c2 04	 add	 edx, 4
  0005c	52		 push	 edx
  0005d	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _init$[ebp]
  00063	50		 push	 eax
  00064	8b 4d 0c	 mov	 ecx, DWORD PTR _pwd_len$[ebp]
  00067	51		 push	 ecx
  00068	8b 55 08	 mov	 edx, DWORD PTR _pwd$[ebp]
  0006b	52		 push	 edx
  0006c	e8 00 00 00 00	 call	 _hmac_sha1@24

; 269  : 	memcpy (u, j, SHA1_DIGESTSIZE);

  00071	8b 45 1c	 mov	 eax, DWORD PTR _u$[ebp]
  00074	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  0007a	89 08		 mov	 DWORD PTR [eax], ecx
  0007c	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _j$[ebp+4]
  00082	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00085	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp+8]
  0008b	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0008e	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _j$[ebp+12]
  00094	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00097	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp+16]
  0009d	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 270  : 
; 271  : 	/* remaining iterations */
; 272  : 	for (c = 1; c < iterations; c++)

  000a0	c7 85 5c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _c$[ebp], 1
  000aa	eb 0f		 jmp	 SHORT $LN16@derive_u_s@2
$LN15@derive_u_s@2:
  000ac	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _c$[ebp]
  000b2	83 c2 01	 add	 edx, 1
  000b5	89 95 5c ff ff
	ff		 mov	 DWORD PTR _c$[ebp], edx
$LN16@derive_u_s@2:
  000bb	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _c$[ebp]
  000c1	3b 45 18	 cmp	 eax, DWORD PTR _iterations$[ebp]
  000c4	7d 70		 jge	 SHORT $LN10@derive_u_s@2

; 273  : 	{
; 274  : 		hmac_sha1 (pwd, pwd_len, j, SHA1_DIGESTSIZE, k, SHA1_DIGESTSIZE);

  000c6	6a 14		 push	 20			; 00000014H
  000c8	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _k$[ebp]
  000ce	51		 push	 ecx
  000cf	6a 14		 push	 20			; 00000014H
  000d1	8d 95 48 ff ff
	ff		 lea	 edx, DWORD PTR _j$[ebp]
  000d7	52		 push	 edx
  000d8	8b 45 0c	 mov	 eax, DWORD PTR _pwd_len$[ebp]
  000db	50		 push	 eax
  000dc	8b 4d 08	 mov	 ecx, DWORD PTR _pwd$[ebp]
  000df	51		 push	 ecx
  000e0	e8 00 00 00 00	 call	 _hmac_sha1@24

; 275  : 		for (i = 0; i < SHA1_DIGESTSIZE; i++)

  000e5	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000ec	eb 09		 jmp	 SHORT $LN13@derive_u_s@2
$LN12@derive_u_s@2:
  000ee	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000f1	83 c2 01	 add	 edx, 1
  000f4	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN13@derive_u_s@2:
  000f7	83 7d fc 14	 cmp	 DWORD PTR _i$[ebp], 20	; 00000014H
  000fb	7d 34		 jge	 SHORT $LN11@derive_u_s@2

; 276  : 		{
; 277  : 			u[i] ^= k[i];

  000fd	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00100	0f be 8c 05 60
	ff ff ff	 movsx	 ecx, BYTE PTR _k$[ebp+eax]
  00108	8b 55 1c	 mov	 edx, DWORD PTR _u$[ebp]
  0010b	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  0010e	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00111	33 c1		 xor	 eax, ecx
  00113	8b 4d 1c	 mov	 ecx, DWORD PTR _u$[ebp]
  00116	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  00119	88 01		 mov	 BYTE PTR [ecx], al

; 278  : 			j[i] = k[i];

  0011b	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0011e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00121	8a 8c 05 60 ff
	ff ff		 mov	 cl, BYTE PTR _k$[ebp+eax]
  00128	88 8c 15 48 ff
	ff ff		 mov	 BYTE PTR _j$[ebp+edx], cl

; 279  : 		}

  0012f	eb bd		 jmp	 SHORT $LN12@derive_u_s@2
$LN11@derive_u_s@2:

; 280  : 	}

  00131	e9 76 ff ff ff	 jmp	 $LN15@derive_u_s@2
$LN10@derive_u_s@2:

; 281  : 
; 282  : 	/* Prevent possible leaks. */
; 283  : 	burn (j, sizeof(j));

  00136	8d 95 48 ff ff
	ff		 lea	 edx, DWORD PTR _j$[ebp]
  0013c	89 95 40 ff ff
	ff		 mov	 DWORD PTR _burnm$27297[ebp], edx
  00142	c7 85 44 ff ff
	ff 14 00 00 00	 mov	 DWORD PTR _burnc$27299[ebp], 20 ; 00000014H
  0014c	6a 14		 push	 20			; 00000014H
  0014e	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR _j$[ebp]
  00154	50		 push	 eax
  00155	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN7@derive_u_s@2:
  0015a	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _burnc$27299[ebp]
  00160	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR _burnc$27299[ebp]
  00166	83 ea 01	 sub	 edx, 1
  00169	89 95 44 ff ff
	ff		 mov	 DWORD PTR _burnc$27299[ebp], edx
  0016f	85 c9		 test	 ecx, ecx
  00171	74 1a		 je	 SHORT $LN9@derive_u_s@2
  00173	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _burnm$27297[ebp]
  00179	c6 00 00	 mov	 BYTE PTR [eax], 0
  0017c	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _burnm$27297[ebp]
  00182	83 c1 01	 add	 ecx, 1
  00185	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _burnm$27297[ebp], ecx
  0018b	eb cd		 jmp	 SHORT $LN7@derive_u_s@2
$LN9@derive_u_s@2:
  0018d	33 d2		 xor	 edx, edx
  0018f	75 a5		 jne	 SHORT $LN10@derive_u_s@2
$LN5@derive_u_s@2:

; 284  : 	burn (k, sizeof(k));

  00191	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _k$[ebp]
  00197	89 85 38 ff ff
	ff		 mov	 DWORD PTR _burnm$27306[ebp], eax
  0019d	c7 85 3c ff ff
	ff 14 00 00 00	 mov	 DWORD PTR _burnc$27308[ebp], 20 ; 00000014H
  001a7	6a 14		 push	 20			; 00000014H
  001a9	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _k$[ebp]
  001af	51		 push	 ecx
  001b0	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@derive_u_s@2:
  001b5	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _burnc$27308[ebp]
  001bb	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _burnc$27308[ebp]
  001c1	83 e8 01	 sub	 eax, 1
  001c4	89 85 3c ff ff
	ff		 mov	 DWORD PTR _burnc$27308[ebp], eax
  001ca	85 d2		 test	 edx, edx
  001cc	74 1a		 je	 SHORT $LN4@derive_u_s@2
  001ce	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _burnm$27306[ebp]
  001d4	c6 01 00	 mov	 BYTE PTR [ecx], 0
  001d7	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _burnm$27306[ebp]
  001dd	83 c2 01	 add	 edx, 1
  001e0	89 95 38 ff ff
	ff		 mov	 DWORD PTR _burnm$27306[ebp], edx
  001e6	eb cd		 jmp	 SHORT $LN2@derive_u_s@2
$LN4@derive_u_s@2:
  001e8	33 c0		 xor	 eax, eax
  001ea	75 a5		 jne	 SHORT $LN5@derive_u_s@2

; 285  : }

  001ec	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ef	33 cd		 xor	 ecx, ebp
  001f1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f6	8b e5		 mov	 esp, ebp
  001f8	5d		 pop	 ebp
  001f9	c2 1c 00	 ret	 28			; 0000001cH
_derive_u_sha1@28 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_derive_key_sha1@28
; Function compile flags: /Odtp
;	COMDAT _derive_key_sha1@28
_TEXT	SEGMENT
_burnm$27339 = -44					; size = 4
_burnc$27341 = -40					; size = 4
_r$ = -36						; size = 4
_l$ = -32						; size = 4
_b$ = -28						; size = 4
_u$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_dk$ = 28						; size = 4
_dklen$ = 32						; size = 4
_derive_key_sha1@28 PROC				; COMDAT

; 290  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 291  : 	char u[SHA1_DIGESTSIZE];
; 292  : 	int b, l, r;
; 293  : 
; 294  : 	if (dklen % SHA1_DIGESTSIZE)

  00012	8b 45 20	 mov	 eax, DWORD PTR _dklen$[ebp]
  00015	99		 cdq
  00016	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0001b	f7 f9		 idiv	 ecx
  0001d	85 d2		 test	 edx, edx
  0001f	74 13		 je	 SHORT $LN10@derive_key@2

; 295  : 	{
; 296  : 		l = 1 + dklen / SHA1_DIGESTSIZE;

  00021	8b 45 20	 mov	 eax, DWORD PTR _dklen$[ebp]
  00024	99		 cdq
  00025	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0002a	f7 f9		 idiv	 ecx
  0002c	83 c0 01	 add	 eax, 1
  0002f	89 45 e0	 mov	 DWORD PTR _l$[ebp], eax

; 297  : 	}
; 298  : 	else

  00032	eb 0e		 jmp	 SHORT $LN9@derive_key@2
$LN10@derive_key@2:

; 299  : 	{
; 300  : 		l = dklen / SHA1_DIGESTSIZE;

  00034	8b 45 20	 mov	 eax, DWORD PTR _dklen$[ebp]
  00037	99		 cdq
  00038	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0003d	f7 f9		 idiv	 ecx
  0003f	89 45 e0	 mov	 DWORD PTR _l$[ebp], eax
$LN9@derive_key@2:

; 301  : 	}
; 302  : 
; 303  : 	r = dklen - (l - 1) * SHA1_DIGESTSIZE;

  00042	8b 55 e0	 mov	 edx, DWORD PTR _l$[ebp]
  00045	83 ea 01	 sub	 edx, 1
  00048	6b d2 14	 imul	 edx, 20			; 00000014H
  0004b	8b 45 20	 mov	 eax, DWORD PTR _dklen$[ebp]
  0004e	2b c2		 sub	 eax, edx
  00050	89 45 dc	 mov	 DWORD PTR _r$[ebp], eax

; 304  : 
; 305  : 	/* first l - 1 blocks */
; 306  : 	for (b = 1; b < l; b++)

  00053	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _b$[ebp], 1
  0005a	eb 09		 jmp	 SHORT $LN8@derive_key@2
$LN7@derive_key@2:
  0005c	8b 4d e4	 mov	 ecx, DWORD PTR _b$[ebp]
  0005f	83 c1 01	 add	 ecx, 1
  00062	89 4d e4	 mov	 DWORD PTR _b$[ebp], ecx
$LN8@derive_key@2:
  00065	8b 55 e4	 mov	 edx, DWORD PTR _b$[ebp]
  00068	3b 55 e0	 cmp	 edx, DWORD PTR _l$[ebp]
  0006b	7d 4c		 jge	 SHORT $LN6@derive_key@2

; 307  : 	{
; 308  : 		derive_u_sha1 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  0006d	8b 45 e4	 mov	 eax, DWORD PTR _b$[ebp]
  00070	50		 push	 eax
  00071	8d 4d e8	 lea	 ecx, DWORD PTR _u$[ebp]
  00074	51		 push	 ecx
  00075	8b 55 18	 mov	 edx, DWORD PTR _iterations$[ebp]
  00078	52		 push	 edx
  00079	8b 45 14	 mov	 eax, DWORD PTR _salt_len$[ebp]
  0007c	50		 push	 eax
  0007d	8b 4d 10	 mov	 ecx, DWORD PTR _salt$[ebp]
  00080	51		 push	 ecx
  00081	8b 55 0c	 mov	 edx, DWORD PTR _pwd_len$[ebp]
  00084	52		 push	 edx
  00085	8b 45 08	 mov	 eax, DWORD PTR _pwd$[ebp]
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 _derive_u_sha1@28

; 309  : 		memcpy (dk, u, SHA1_DIGESTSIZE);

  0008e	8b 4d 1c	 mov	 ecx, DWORD PTR _dk$[ebp]
  00091	8b 55 e8	 mov	 edx, DWORD PTR _u$[ebp]
  00094	89 11		 mov	 DWORD PTR [ecx], edx
  00096	8b 45 ec	 mov	 eax, DWORD PTR _u$[ebp+4]
  00099	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0009c	8b 55 f0	 mov	 edx, DWORD PTR _u$[ebp+8]
  0009f	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  000a2	8b 45 f4	 mov	 eax, DWORD PTR _u$[ebp+12]
  000a5	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  000a8	8b 55 f8	 mov	 edx, DWORD PTR _u$[ebp+16]
  000ab	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 310  : 		dk += SHA1_DIGESTSIZE;

  000ae	8b 45 1c	 mov	 eax, DWORD PTR _dk$[ebp]
  000b1	83 c0 14	 add	 eax, 20			; 00000014H
  000b4	89 45 1c	 mov	 DWORD PTR _dk$[ebp], eax

; 311  : 	}

  000b7	eb a3		 jmp	 SHORT $LN7@derive_key@2
$LN6@derive_key@2:

; 312  : 
; 313  : 	/* last block */
; 314  : 	derive_u_sha1 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  000b9	8b 4d e4	 mov	 ecx, DWORD PTR _b$[ebp]
  000bc	51		 push	 ecx
  000bd	8d 55 e8	 lea	 edx, DWORD PTR _u$[ebp]
  000c0	52		 push	 edx
  000c1	8b 45 18	 mov	 eax, DWORD PTR _iterations$[ebp]
  000c4	50		 push	 eax
  000c5	8b 4d 14	 mov	 ecx, DWORD PTR _salt_len$[ebp]
  000c8	51		 push	 ecx
  000c9	8b 55 10	 mov	 edx, DWORD PTR _salt$[ebp]
  000cc	52		 push	 edx
  000cd	8b 45 0c	 mov	 eax, DWORD PTR _pwd_len$[ebp]
  000d0	50		 push	 eax
  000d1	8b 4d 08	 mov	 ecx, DWORD PTR _pwd$[ebp]
  000d4	51		 push	 ecx
  000d5	e8 00 00 00 00	 call	 _derive_u_sha1@28

; 315  : 	memcpy (dk, u, r);

  000da	8b 55 dc	 mov	 edx, DWORD PTR _r$[ebp]
  000dd	52		 push	 edx
  000de	8d 45 e8	 lea	 eax, DWORD PTR _u$[ebp]
  000e1	50		 push	 eax
  000e2	8b 4d 1c	 mov	 ecx, DWORD PTR _dk$[ebp]
  000e5	51		 push	 ecx
  000e6	e8 00 00 00 00	 call	 _memcpy
  000eb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@derive_key@2:

; 316  : 
; 317  : 
; 318  : 	/* Prevent possible leaks. */
; 319  : 	burn (u, sizeof(u));

  000ee	8d 55 e8	 lea	 edx, DWORD PTR _u$[ebp]
  000f1	89 55 d4	 mov	 DWORD PTR _burnm$27339[ebp], edx
  000f4	c7 45 d8 14 00
	00 00		 mov	 DWORD PTR _burnc$27341[ebp], 20 ; 00000014H
  000fb	6a 14		 push	 20			; 00000014H
  000fd	8d 45 e8	 lea	 eax, DWORD PTR _u$[ebp]
  00100	50		 push	 eax
  00101	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@derive_key@2:
  00106	8b 4d d8	 mov	 ecx, DWORD PTR _burnc$27341[ebp]
  00109	8b 55 d8	 mov	 edx, DWORD PTR _burnc$27341[ebp]
  0010c	83 ea 01	 sub	 edx, 1
  0010f	89 55 d8	 mov	 DWORD PTR _burnc$27341[ebp], edx
  00112	85 c9		 test	 ecx, ecx
  00114	74 11		 je	 SHORT $LN4@derive_key@2
  00116	8b 45 d4	 mov	 eax, DWORD PTR _burnm$27339[ebp]
  00119	c6 00 00	 mov	 BYTE PTR [eax], 0
  0011c	8b 4d d4	 mov	 ecx, DWORD PTR _burnm$27339[ebp]
  0011f	83 c1 01	 add	 ecx, 1
  00122	89 4d d4	 mov	 DWORD PTR _burnm$27339[ebp], ecx
  00125	eb df		 jmp	 SHORT $LN2@derive_key@2
$LN4@derive_key@2:
  00127	33 d2		 xor	 edx, edx
  00129	75 c3		 jne	 SHORT $LN5@derive_key@2

; 320  : }

  0012b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012e	33 cd		 xor	 ecx, ebp
  00130	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00135	8b e5		 mov	 esp, ebp
  00137	5d		 pop	 ebp
  00138	c2 1c 00	 ret	 28			; 0000001cH
_derive_key_sha1@28 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_hmac_ripemd160@20
EXTRN	_RMD160Final@8:PROC
EXTRN	_RMD160Update@12:PROC
EXTRN	_RMD160Init@4:PROC
EXTRN	_memset:PROC
; Function compile flags: /Odtp
;	COMDAT _hmac_ripemd160@20
_TEXT	SEGMENT
_burnm$27411 = -408					; size = 4
_burnc$27413 = -404					; size = 4
_burnm$27402 = -400					; size = 4
_burnc$27404 = -396					; size = 4
_burnm$27393 = -392					; size = 4
_burnc$27395 = -388					; size = 4
_burnm$27384 = -384					; size = 4
_burnc$27386 = -380					; size = 4
_burnm$27368 = -376					; size = 4
_burnc$27370 = -372					; size = 4
_tctx$27362 = -368					; size = 96
_context$ = -272					; size = 96
_k_ipad$ = -176						; size = 65
_tk$ = -100						; size = 20
_k_opad$ = -80						; size = 65
__$ArrayPad$ = -8					; size = 4
_i$ = -4						; size = 4
_key$ = 8						; size = 4
_keylen$ = 12						; size = 4
_input$ = 16						; size = 4
_len$ = 20						; size = 4
_digest$ = 24						; size = 4
_hmac_ripemd160@20 PROC					; COMDAT

; 325  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 98 01 00
	00		 sub	 esp, 408		; 00000198H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 326  :     RMD160_CTX context;
; 327  :     unsigned char k_ipad[65];  /* inner padding - key XORd with ipad */
; 328  :     unsigned char k_opad[65];  /* outer padding - key XORd with opad */
; 329  :     unsigned char tk[RIPEMD160_DIGESTSIZE];
; 330  :     int i;
; 331  : 
; 332  :     /* If the key is longer than the hash algorithm block size,
; 333  : 	   let key = ripemd160(key), as per HMAC specifications. */
; 334  :     if (keylen > RIPEMD160_BLOCKSIZE) 

  00015	83 7d 0c 40	 cmp	 DWORD PTR _keylen$[ebp], 64 ; 00000040H
  00019	0f 8e 98 00 00
	00		 jle	 $LN29@hmac_ripem

; 335  : 	{
; 336  :         RMD160_CTX      tctx;
; 337  : 
; 338  :         RMD160Init(&tctx);

  0001f	8d 85 90 fe ff
	ff		 lea	 eax, DWORD PTR _tctx$27362[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _RMD160Init@4

; 339  :         RMD160Update(&tctx, (const unsigned char *) key, keylen);

  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _keylen$[ebp]
  0002e	51		 push	 ecx
  0002f	8b 55 08	 mov	 edx, DWORD PTR _key$[ebp]
  00032	52		 push	 edx
  00033	8d 85 90 fe ff
	ff		 lea	 eax, DWORD PTR _tctx$27362[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _RMD160Update@12

; 340  :         RMD160Final(tk, &tctx);

  0003f	8d 8d 90 fe ff
	ff		 lea	 ecx, DWORD PTR _tctx$27362[ebp]
  00045	51		 push	 ecx
  00046	8d 55 9c	 lea	 edx, DWORD PTR _tk$[ebp]
  00049	52		 push	 edx
  0004a	e8 00 00 00 00	 call	 _RMD160Final@8

; 341  : 
; 342  :         key = (char *) tk;

  0004f	8d 45 9c	 lea	 eax, DWORD PTR _tk$[ebp]
  00052	89 45 08	 mov	 DWORD PTR _key$[ebp], eax

; 343  :         keylen = RIPEMD160_DIGESTSIZE;

  00055	c7 45 0c 14 00
	00 00		 mov	 DWORD PTR _keylen$[ebp], 20 ; 00000014H
$LN28@hmac_ripem:

; 344  : 
; 345  : 		burn (&tctx, sizeof(tctx));	// Prevent leaks

  0005c	8d 8d 90 fe ff
	ff		 lea	 ecx, DWORD PTR _tctx$27362[ebp]
  00062	89 8d 88 fe ff
	ff		 mov	 DWORD PTR _burnm$27368[ebp], ecx
  00068	c7 85 8c fe ff
	ff 60 00 00 00	 mov	 DWORD PTR _burnc$27370[ebp], 96 ; 00000060H
  00072	6a 60		 push	 96			; 00000060H
  00074	8d 95 90 fe ff
	ff		 lea	 edx, DWORD PTR _tctx$27362[ebp]
  0007a	52		 push	 edx
  0007b	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN25@hmac_ripem:
  00080	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR _burnc$27370[ebp]
  00086	8b 8d 8c fe ff
	ff		 mov	 ecx, DWORD PTR _burnc$27370[ebp]
  0008c	83 e9 01	 sub	 ecx, 1
  0008f	89 8d 8c fe ff
	ff		 mov	 DWORD PTR _burnc$27370[ebp], ecx
  00095	85 c0		 test	 eax, eax
  00097	74 1a		 je	 SHORT $LN27@hmac_ripem
  00099	8b 95 88 fe ff
	ff		 mov	 edx, DWORD PTR _burnm$27368[ebp]
  0009f	c6 02 00	 mov	 BYTE PTR [edx], 0
  000a2	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR _burnm$27368[ebp]
  000a8	83 c0 01	 add	 eax, 1
  000ab	89 85 88 fe ff
	ff		 mov	 DWORD PTR _burnm$27368[ebp], eax
  000b1	eb cd		 jmp	 SHORT $LN25@hmac_ripem
$LN27@hmac_ripem:
  000b3	33 c9		 xor	 ecx, ecx
  000b5	75 a5		 jne	 SHORT $LN28@hmac_ripem
$LN29@hmac_ripem:

; 346  :     }
; 347  : 
; 348  : 	/*
; 349  : 
; 350  : 	RMD160(K XOR opad, RMD160(K XOR ipad, text))
; 351  : 
; 352  : 	where K is an n byte key
; 353  : 	ipad is the byte 0x36 repeated RIPEMD160_BLOCKSIZE times
; 354  : 	opad is the byte 0x5c repeated RIPEMD160_BLOCKSIZE times
; 355  : 	and text is the data being protected */
; 356  : 
; 357  : 
; 358  : 	/* start out by storing key in pads */
; 359  : 	memset(k_ipad, 0x36, sizeof(k_ipad));

  000b7	6a 41		 push	 65			; 00000041H
  000b9	6a 36		 push	 54			; 00000036H
  000bb	8d 95 50 ff ff
	ff		 lea	 edx, DWORD PTR _k_ipad$[ebp]
  000c1	52		 push	 edx
  000c2	e8 00 00 00 00	 call	 _memset
  000c7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 360  :     memset(k_opad, 0x5c, sizeof(k_opad));

  000ca	6a 41		 push	 65			; 00000041H
  000cc	6a 5c		 push	 92			; 0000005cH
  000ce	8d 45 b0	 lea	 eax, DWORD PTR _k_opad$[ebp]
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 _memset
  000d7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 361  : 
; 362  :     /* XOR key with ipad and opad values */
; 363  :     for (i=0; i<keylen; i++) 

  000da	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000e1	eb 09		 jmp	 SHORT $LN23@hmac_ripem
$LN22@hmac_ripem:
  000e3	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000e6	83 c1 01	 add	 ecx, 1
  000e9	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN23@hmac_ripem:
  000ec	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000ef	3b 55 0c	 cmp	 edx, DWORD PTR _keylen$[ebp]
  000f2	7d 3c		 jge	 SHORT $LN21@hmac_ripem

; 364  : 	{
; 365  :         k_ipad[i] ^= key[i];

  000f4	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]
  000f7	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  000fa	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000fd	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00100	0f b6 84 15 50
	ff ff ff	 movzx	 eax, BYTE PTR _k_ipad$[ebp+edx]
  00108	33 c1		 xor	 eax, ecx
  0010a	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0010d	88 84 0d 50 ff
	ff ff		 mov	 BYTE PTR _k_ipad$[ebp+ecx], al

; 366  :         k_opad[i] ^= key[i];

  00114	8b 55 08	 mov	 edx, DWORD PTR _key$[ebp]
  00117	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  0011a	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0011d	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00120	0f b6 54 0d b0	 movzx	 edx, BYTE PTR _k_opad$[ebp+ecx]
  00125	33 d0		 xor	 edx, eax
  00127	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0012a	88 54 05 b0	 mov	 BYTE PTR _k_opad$[ebp+eax], dl

; 367  :     }

  0012e	eb b3		 jmp	 SHORT $LN22@hmac_ripem
$LN21@hmac_ripem:

; 368  : 
; 369  :     /* perform inner RIPEMD-160 */
; 370  : 
; 371  :     RMD160Init(&context);           /* init context for 1st pass */

  00130	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _context$[ebp]
  00136	51		 push	 ecx
  00137	e8 00 00 00 00	 call	 _RMD160Init@4

; 372  :     RMD160Update(&context, k_ipad, RIPEMD160_BLOCKSIZE);  /* start with inner pad */

  0013c	6a 40		 push	 64			; 00000040H
  0013e	8d 95 50 ff ff
	ff		 lea	 edx, DWORD PTR _k_ipad$[ebp]
  00144	52		 push	 edx
  00145	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _context$[ebp]
  0014b	50		 push	 eax
  0014c	e8 00 00 00 00	 call	 _RMD160Update@12

; 373  :     RMD160Update(&context, (const unsigned char *) input, len); /* then text of datagram */

  00151	8b 4d 14	 mov	 ecx, DWORD PTR _len$[ebp]
  00154	51		 push	 ecx
  00155	8b 55 10	 mov	 edx, DWORD PTR _input$[ebp]
  00158	52		 push	 edx
  00159	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _context$[ebp]
  0015f	50		 push	 eax
  00160	e8 00 00 00 00	 call	 _RMD160Update@12

; 374  :     RMD160Final((unsigned char *) digest, &context);         /* finish up 1st pass */

  00165	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _context$[ebp]
  0016b	51		 push	 ecx
  0016c	8b 55 18	 mov	 edx, DWORD PTR _digest$[ebp]
  0016f	52		 push	 edx
  00170	e8 00 00 00 00	 call	 _RMD160Final@8

; 375  : 
; 376  :     /* perform outer RIPEMD-160 */
; 377  :     RMD160Init(&context);           /* init context for 2nd pass */

  00175	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _context$[ebp]
  0017b	50		 push	 eax
  0017c	e8 00 00 00 00	 call	 _RMD160Init@4

; 378  :     RMD160Update(&context, k_opad, RIPEMD160_BLOCKSIZE);  /* start with outer pad */

  00181	6a 40		 push	 64			; 00000040H
  00183	8d 4d b0	 lea	 ecx, DWORD PTR _k_opad$[ebp]
  00186	51		 push	 ecx
  00187	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR _context$[ebp]
  0018d	52		 push	 edx
  0018e	e8 00 00 00 00	 call	 _RMD160Update@12

; 379  :     /* results of 1st hash */
; 380  :     RMD160Update(&context, (const unsigned char *) digest, RIPEMD160_DIGESTSIZE);

  00193	6a 14		 push	 20			; 00000014H
  00195	8b 45 18	 mov	 eax, DWORD PTR _digest$[ebp]
  00198	50		 push	 eax
  00199	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _context$[ebp]
  0019f	51		 push	 ecx
  001a0	e8 00 00 00 00	 call	 _RMD160Update@12

; 381  :     RMD160Final((unsigned char *) digest, &context);         /* finish up 2nd pass */

  001a5	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR _context$[ebp]
  001ab	52		 push	 edx
  001ac	8b 45 18	 mov	 eax, DWORD PTR _digest$[ebp]
  001af	50		 push	 eax
  001b0	e8 00 00 00 00	 call	 _RMD160Final@8
$LN20@hmac_ripem:

; 382  : 
; 383  : 	/* Prevent possible leaks. */
; 384  :     burn (k_ipad, sizeof(k_ipad));

  001b5	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR _k_ipad$[ebp]
  001bb	89 8d 80 fe ff
	ff		 mov	 DWORD PTR _burnm$27384[ebp], ecx
  001c1	c7 85 84 fe ff
	ff 41 00 00 00	 mov	 DWORD PTR _burnc$27386[ebp], 65 ; 00000041H
  001cb	6a 41		 push	 65			; 00000041H
  001cd	8d 95 50 ff ff
	ff		 lea	 edx, DWORD PTR _k_ipad$[ebp]
  001d3	52		 push	 edx
  001d4	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN17@hmac_ripem:
  001d9	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR _burnc$27386[ebp]
  001df	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR _burnc$27386[ebp]
  001e5	83 e9 01	 sub	 ecx, 1
  001e8	89 8d 84 fe ff
	ff		 mov	 DWORD PTR _burnc$27386[ebp], ecx
  001ee	85 c0		 test	 eax, eax
  001f0	74 1a		 je	 SHORT $LN19@hmac_ripem
  001f2	8b 95 80 fe ff
	ff		 mov	 edx, DWORD PTR _burnm$27384[ebp]
  001f8	c6 02 00	 mov	 BYTE PTR [edx], 0
  001fb	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR _burnm$27384[ebp]
  00201	83 c0 01	 add	 eax, 1
  00204	89 85 80 fe ff
	ff		 mov	 DWORD PTR _burnm$27384[ebp], eax
  0020a	eb cd		 jmp	 SHORT $LN17@hmac_ripem
$LN19@hmac_ripem:
  0020c	33 c9		 xor	 ecx, ecx
  0020e	75 a5		 jne	 SHORT $LN20@hmac_ripem
$LN15@hmac_ripem:

; 385  :     burn (k_opad, sizeof(k_opad));

  00210	8d 55 b0	 lea	 edx, DWORD PTR _k_opad$[ebp]
  00213	89 95 78 fe ff
	ff		 mov	 DWORD PTR _burnm$27393[ebp], edx
  00219	c7 85 7c fe ff
	ff 41 00 00 00	 mov	 DWORD PTR _burnc$27395[ebp], 65 ; 00000041H
  00223	6a 41		 push	 65			; 00000041H
  00225	8d 45 b0	 lea	 eax, DWORD PTR _k_opad$[ebp]
  00228	50		 push	 eax
  00229	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN12@hmac_ripem:
  0022e	8b 8d 7c fe ff
	ff		 mov	 ecx, DWORD PTR _burnc$27395[ebp]
  00234	8b 95 7c fe ff
	ff		 mov	 edx, DWORD PTR _burnc$27395[ebp]
  0023a	83 ea 01	 sub	 edx, 1
  0023d	89 95 7c fe ff
	ff		 mov	 DWORD PTR _burnc$27395[ebp], edx
  00243	85 c9		 test	 ecx, ecx
  00245	74 1a		 je	 SHORT $LN14@hmac_ripem
  00247	8b 85 78 fe ff
	ff		 mov	 eax, DWORD PTR _burnm$27393[ebp]
  0024d	c6 00 00	 mov	 BYTE PTR [eax], 0
  00250	8b 8d 78 fe ff
	ff		 mov	 ecx, DWORD PTR _burnm$27393[ebp]
  00256	83 c1 01	 add	 ecx, 1
  00259	89 8d 78 fe ff
	ff		 mov	 DWORD PTR _burnm$27393[ebp], ecx
  0025f	eb cd		 jmp	 SHORT $LN12@hmac_ripem
$LN14@hmac_ripem:
  00261	33 d2		 xor	 edx, edx
  00263	75 ab		 jne	 SHORT $LN15@hmac_ripem
$LN10@hmac_ripem:

; 386  : 	burn (tk, sizeof(tk));

  00265	8d 45 9c	 lea	 eax, DWORD PTR _tk$[ebp]
  00268	89 85 70 fe ff
	ff		 mov	 DWORD PTR _burnm$27402[ebp], eax
  0026e	c7 85 74 fe ff
	ff 14 00 00 00	 mov	 DWORD PTR _burnc$27404[ebp], 20 ; 00000014H
  00278	6a 14		 push	 20			; 00000014H
  0027a	8d 4d 9c	 lea	 ecx, DWORD PTR _tk$[ebp]
  0027d	51		 push	 ecx
  0027e	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN7@hmac_ripem:
  00283	8b 95 74 fe ff
	ff		 mov	 edx, DWORD PTR _burnc$27404[ebp]
  00289	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR _burnc$27404[ebp]
  0028f	83 e8 01	 sub	 eax, 1
  00292	89 85 74 fe ff
	ff		 mov	 DWORD PTR _burnc$27404[ebp], eax
  00298	85 d2		 test	 edx, edx
  0029a	74 1a		 je	 SHORT $LN9@hmac_ripem
  0029c	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR _burnm$27402[ebp]
  002a2	c6 01 00	 mov	 BYTE PTR [ecx], 0
  002a5	8b 95 70 fe ff
	ff		 mov	 edx, DWORD PTR _burnm$27402[ebp]
  002ab	83 c2 01	 add	 edx, 1
  002ae	89 95 70 fe ff
	ff		 mov	 DWORD PTR _burnm$27402[ebp], edx
  002b4	eb cd		 jmp	 SHORT $LN7@hmac_ripem
$LN9@hmac_ripem:
  002b6	33 c0		 xor	 eax, eax
  002b8	75 ab		 jne	 SHORT $LN10@hmac_ripem
$LN5@hmac_ripem:

; 387  : 	burn (&context, sizeof(context));

  002ba	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _context$[ebp]
  002c0	89 8d 68 fe ff
	ff		 mov	 DWORD PTR _burnm$27411[ebp], ecx
  002c6	c7 85 6c fe ff
	ff 60 00 00 00	 mov	 DWORD PTR _burnc$27413[ebp], 96 ; 00000060H
  002d0	6a 60		 push	 96			; 00000060H
  002d2	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR _context$[ebp]
  002d8	52		 push	 edx
  002d9	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@hmac_ripem:
  002de	8b 85 6c fe ff
	ff		 mov	 eax, DWORD PTR _burnc$27413[ebp]
  002e4	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR _burnc$27413[ebp]
  002ea	83 e9 01	 sub	 ecx, 1
  002ed	89 8d 6c fe ff
	ff		 mov	 DWORD PTR _burnc$27413[ebp], ecx
  002f3	85 c0		 test	 eax, eax
  002f5	74 1a		 je	 SHORT $LN4@hmac_ripem
  002f7	8b 95 68 fe ff
	ff		 mov	 edx, DWORD PTR _burnm$27411[ebp]
  002fd	c6 02 00	 mov	 BYTE PTR [edx], 0
  00300	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR _burnm$27411[ebp]
  00306	83 c0 01	 add	 eax, 1
  00309	89 85 68 fe ff
	ff		 mov	 DWORD PTR _burnm$27411[ebp], eax
  0030f	eb cd		 jmp	 SHORT $LN2@hmac_ripem
$LN4@hmac_ripem:
  00311	33 c9		 xor	 ecx, ecx
  00313	75 a5		 jne	 SHORT $LN5@hmac_ripem

; 388  : }

  00315	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00318	33 cd		 xor	 ecx, ebp
  0031a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0031f	8b e5		 mov	 esp, ebp
  00321	5d		 pop	 ebp
  00322	c2 14 00	 ret	 20			; 00000014H
_hmac_ripemd160@20 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_derive_u_ripemd160@28
; Function compile flags: /Odtp
;	COMDAT _derive_u_ripemd160@28
_TEXT	SEGMENT
_burnm$27457 = -200					; size = 4
_burnc$27459 = -196					; size = 4
_burnm$27448 = -192					; size = 4
_burnc$27450 = -188					; size = 4
_j$ = -184						; size = 20
_c$ = -164						; size = 4
_k$ = -160						; size = 20
_counter$ = -140					; size = 4
_init$ = -136						; size = 128
__$ArrayPad$ = -8					; size = 4
_i$ = -4						; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_u$ = 28						; size = 4
_b$ = 32						; size = 4
_derive_u_ripemd160@28 PROC				; COMDAT

; 391  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 392  : 	char j[RIPEMD160_DIGESTSIZE], k[RIPEMD160_DIGESTSIZE];
; 393  : 	char init[128];
; 394  : 	char counter[4];
; 395  : 	int c, i;
; 396  : 
; 397  : 	/* iteration 1 */
; 398  : 	memset (counter, 0, 4);

  00015	33 c0		 xor	 eax, eax
  00017	89 85 74 ff ff
	ff		 mov	 DWORD PTR _counter$[ebp], eax

; 399  : 	counter[3] = (char) b;

  0001d	8a 4d 20	 mov	 cl, BYTE PTR _b$[ebp]
  00020	88 8d 77 ff ff
	ff		 mov	 BYTE PTR _counter$[ebp+3], cl

; 400  : 	memcpy (init, salt, salt_len);	/* salt */

  00026	8b 55 14	 mov	 edx, DWORD PTR _salt_len$[ebp]
  00029	52		 push	 edx
  0002a	8b 45 10	 mov	 eax, DWORD PTR _salt$[ebp]
  0002d	50		 push	 eax
  0002e	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _init$[ebp]
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 _memcpy
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 401  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */

  0003d	8b 55 14	 mov	 edx, DWORD PTR _salt_len$[ebp]
  00040	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _counter$[ebp]
  00046	89 84 15 78 ff
	ff ff		 mov	 DWORD PTR _init$[ebp+edx], eax

; 402  : 	hmac_ripemd160 (pwd, pwd_len, init, salt_len + 4, j);

  0004d	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _j$[ebp]
  00053	51		 push	 ecx
  00054	8b 55 14	 mov	 edx, DWORD PTR _salt_len$[ebp]
  00057	83 c2 04	 add	 edx, 4
  0005a	52		 push	 edx
  0005b	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _init$[ebp]
  00061	50		 push	 eax
  00062	8b 4d 0c	 mov	 ecx, DWORD PTR _pwd_len$[ebp]
  00065	51		 push	 ecx
  00066	8b 55 08	 mov	 edx, DWORD PTR _pwd$[ebp]
  00069	52		 push	 edx
  0006a	e8 00 00 00 00	 call	 _hmac_ripemd160@20

; 403  : 	memcpy (u, j, RIPEMD160_DIGESTSIZE);

  0006f	8b 45 1c	 mov	 eax, DWORD PTR _u$[ebp]
  00072	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  00078	89 08		 mov	 DWORD PTR [eax], ecx
  0007a	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _j$[ebp+4]
  00080	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00083	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp+8]
  00089	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0008c	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _j$[ebp+12]
  00092	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00095	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp+16]
  0009b	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 404  : 
; 405  : 	/* remaining iterations */
; 406  : 	for (c = 1; c < iterations; c++)

  0009e	c7 85 5c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _c$[ebp], 1
  000a8	eb 0f		 jmp	 SHORT $LN16@derive_u_r
$LN15@derive_u_r:
  000aa	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _c$[ebp]
  000b0	83 c2 01	 add	 edx, 1
  000b3	89 95 5c ff ff
	ff		 mov	 DWORD PTR _c$[ebp], edx
$LN16@derive_u_r:
  000b9	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _c$[ebp]
  000bf	3b 45 18	 cmp	 eax, DWORD PTR _iterations$[ebp]
  000c2	7d 6e		 jge	 SHORT $LN10@derive_u_r

; 407  : 	{
; 408  : 		hmac_ripemd160 (pwd, pwd_len, j, RIPEMD160_DIGESTSIZE, k);

  000c4	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _k$[ebp]
  000ca	51		 push	 ecx
  000cb	6a 14		 push	 20			; 00000014H
  000cd	8d 95 48 ff ff
	ff		 lea	 edx, DWORD PTR _j$[ebp]
  000d3	52		 push	 edx
  000d4	8b 45 0c	 mov	 eax, DWORD PTR _pwd_len$[ebp]
  000d7	50		 push	 eax
  000d8	8b 4d 08	 mov	 ecx, DWORD PTR _pwd$[ebp]
  000db	51		 push	 ecx
  000dc	e8 00 00 00 00	 call	 _hmac_ripemd160@20

; 409  : 		for (i = 0; i < RIPEMD160_DIGESTSIZE; i++)

  000e1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000e8	eb 09		 jmp	 SHORT $LN13@derive_u_r
$LN12@derive_u_r:
  000ea	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000ed	83 c2 01	 add	 edx, 1
  000f0	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN13@derive_u_r:
  000f3	83 7d fc 14	 cmp	 DWORD PTR _i$[ebp], 20	; 00000014H
  000f7	7d 34		 jge	 SHORT $LN11@derive_u_r

; 410  : 		{
; 411  : 			u[i] ^= k[i];

  000f9	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000fc	0f be 8c 05 60
	ff ff ff	 movsx	 ecx, BYTE PTR _k$[ebp+eax]
  00104	8b 55 1c	 mov	 edx, DWORD PTR _u$[ebp]
  00107	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  0010a	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0010d	33 c1		 xor	 eax, ecx
  0010f	8b 4d 1c	 mov	 ecx, DWORD PTR _u$[ebp]
  00112	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  00115	88 01		 mov	 BYTE PTR [ecx], al

; 412  : 			j[i] = k[i];

  00117	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0011a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0011d	8a 8c 05 60 ff
	ff ff		 mov	 cl, BYTE PTR _k$[ebp+eax]
  00124	88 8c 15 48 ff
	ff ff		 mov	 BYTE PTR _j$[ebp+edx], cl

; 413  : 		}

  0012b	eb bd		 jmp	 SHORT $LN12@derive_u_r
$LN11@derive_u_r:

; 414  : 	}

  0012d	e9 78 ff ff ff	 jmp	 $LN15@derive_u_r
$LN10@derive_u_r:

; 415  : 
; 416  : 	/* Prevent possible leaks. */
; 417  : 	burn (j, sizeof(j));

  00132	8d 95 48 ff ff
	ff		 lea	 edx, DWORD PTR _j$[ebp]
  00138	89 95 40 ff ff
	ff		 mov	 DWORD PTR _burnm$27448[ebp], edx
  0013e	c7 85 44 ff ff
	ff 14 00 00 00	 mov	 DWORD PTR _burnc$27450[ebp], 20 ; 00000014H
  00148	6a 14		 push	 20			; 00000014H
  0014a	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR _j$[ebp]
  00150	50		 push	 eax
  00151	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN7@derive_u_r:
  00156	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _burnc$27450[ebp]
  0015c	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR _burnc$27450[ebp]
  00162	83 ea 01	 sub	 edx, 1
  00165	89 95 44 ff ff
	ff		 mov	 DWORD PTR _burnc$27450[ebp], edx
  0016b	85 c9		 test	 ecx, ecx
  0016d	74 1a		 je	 SHORT $LN9@derive_u_r
  0016f	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _burnm$27448[ebp]
  00175	c6 00 00	 mov	 BYTE PTR [eax], 0
  00178	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _burnm$27448[ebp]
  0017e	83 c1 01	 add	 ecx, 1
  00181	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _burnm$27448[ebp], ecx
  00187	eb cd		 jmp	 SHORT $LN7@derive_u_r
$LN9@derive_u_r:
  00189	33 d2		 xor	 edx, edx
  0018b	75 a5		 jne	 SHORT $LN10@derive_u_r
$LN5@derive_u_r:

; 418  : 	burn (k, sizeof(k));

  0018d	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _k$[ebp]
  00193	89 85 38 ff ff
	ff		 mov	 DWORD PTR _burnm$27457[ebp], eax
  00199	c7 85 3c ff ff
	ff 14 00 00 00	 mov	 DWORD PTR _burnc$27459[ebp], 20 ; 00000014H
  001a3	6a 14		 push	 20			; 00000014H
  001a5	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _k$[ebp]
  001ab	51		 push	 ecx
  001ac	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@derive_u_r:
  001b1	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _burnc$27459[ebp]
  001b7	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _burnc$27459[ebp]
  001bd	83 e8 01	 sub	 eax, 1
  001c0	89 85 3c ff ff
	ff		 mov	 DWORD PTR _burnc$27459[ebp], eax
  001c6	85 d2		 test	 edx, edx
  001c8	74 1a		 je	 SHORT $LN4@derive_u_r
  001ca	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _burnm$27457[ebp]
  001d0	c6 01 00	 mov	 BYTE PTR [ecx], 0
  001d3	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _burnm$27457[ebp]
  001d9	83 c2 01	 add	 edx, 1
  001dc	89 95 38 ff ff
	ff		 mov	 DWORD PTR _burnm$27457[ebp], edx
  001e2	eb cd		 jmp	 SHORT $LN2@derive_u_r
$LN4@derive_u_r:
  001e4	33 c0		 xor	 eax, eax
  001e6	75 a5		 jne	 SHORT $LN5@derive_u_r

; 419  : }

  001e8	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001eb	33 cd		 xor	 ecx, ebp
  001ed	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f2	8b e5		 mov	 esp, ebp
  001f4	5d		 pop	 ebp
  001f5	c2 1c 00	 ret	 28			; 0000001cH
_derive_u_ripemd160@28 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_derive_key_ripemd160@28
; Function compile flags: /Odtp
;	COMDAT _derive_key_ripemd160@28
_TEXT	SEGMENT
_burnm$27490 = -44					; size = 4
_burnc$27492 = -40					; size = 4
_r$ = -36						; size = 4
_l$ = -32						; size = 4
_b$ = -28						; size = 4
_u$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_dk$ = 28						; size = 4
_dklen$ = 32						; size = 4
_derive_key_ripemd160@28 PROC				; COMDAT

; 422  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 423  : 	char u[RIPEMD160_DIGESTSIZE];
; 424  : 	int b, l, r;
; 425  : 
; 426  : 	if (dklen % RIPEMD160_DIGESTSIZE)

  00012	8b 45 20	 mov	 eax, DWORD PTR _dklen$[ebp]
  00015	99		 cdq
  00016	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0001b	f7 f9		 idiv	 ecx
  0001d	85 d2		 test	 edx, edx
  0001f	74 13		 je	 SHORT $LN10@derive_key@3

; 427  : 	{
; 428  : 		l = 1 + dklen / RIPEMD160_DIGESTSIZE;

  00021	8b 45 20	 mov	 eax, DWORD PTR _dklen$[ebp]
  00024	99		 cdq
  00025	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0002a	f7 f9		 idiv	 ecx
  0002c	83 c0 01	 add	 eax, 1
  0002f	89 45 e0	 mov	 DWORD PTR _l$[ebp], eax

; 429  : 	}
; 430  : 	else

  00032	eb 0e		 jmp	 SHORT $LN9@derive_key@3
$LN10@derive_key@3:

; 431  : 	{
; 432  : 		l = dklen / RIPEMD160_DIGESTSIZE;

  00034	8b 45 20	 mov	 eax, DWORD PTR _dklen$[ebp]
  00037	99		 cdq
  00038	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0003d	f7 f9		 idiv	 ecx
  0003f	89 45 e0	 mov	 DWORD PTR _l$[ebp], eax
$LN9@derive_key@3:

; 433  : 	}
; 434  : 
; 435  : 	r = dklen - (l - 1) * RIPEMD160_DIGESTSIZE;

  00042	8b 55 e0	 mov	 edx, DWORD PTR _l$[ebp]
  00045	83 ea 01	 sub	 edx, 1
  00048	6b d2 14	 imul	 edx, 20			; 00000014H
  0004b	8b 45 20	 mov	 eax, DWORD PTR _dklen$[ebp]
  0004e	2b c2		 sub	 eax, edx
  00050	89 45 dc	 mov	 DWORD PTR _r$[ebp], eax

; 436  : 
; 437  : 	/* first l - 1 blocks */
; 438  : 	for (b = 1; b < l; b++)

  00053	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _b$[ebp], 1
  0005a	eb 09		 jmp	 SHORT $LN8@derive_key@3
$LN7@derive_key@3:
  0005c	8b 4d e4	 mov	 ecx, DWORD PTR _b$[ebp]
  0005f	83 c1 01	 add	 ecx, 1
  00062	89 4d e4	 mov	 DWORD PTR _b$[ebp], ecx
$LN8@derive_key@3:
  00065	8b 55 e4	 mov	 edx, DWORD PTR _b$[ebp]
  00068	3b 55 e0	 cmp	 edx, DWORD PTR _l$[ebp]
  0006b	7d 4c		 jge	 SHORT $LN6@derive_key@3

; 439  : 	{
; 440  : 		derive_u_ripemd160 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  0006d	8b 45 e4	 mov	 eax, DWORD PTR _b$[ebp]
  00070	50		 push	 eax
  00071	8d 4d e8	 lea	 ecx, DWORD PTR _u$[ebp]
  00074	51		 push	 ecx
  00075	8b 55 18	 mov	 edx, DWORD PTR _iterations$[ebp]
  00078	52		 push	 edx
  00079	8b 45 14	 mov	 eax, DWORD PTR _salt_len$[ebp]
  0007c	50		 push	 eax
  0007d	8b 4d 10	 mov	 ecx, DWORD PTR _salt$[ebp]
  00080	51		 push	 ecx
  00081	8b 55 0c	 mov	 edx, DWORD PTR _pwd_len$[ebp]
  00084	52		 push	 edx
  00085	8b 45 08	 mov	 eax, DWORD PTR _pwd$[ebp]
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 _derive_u_ripemd160@28

; 441  : 		memcpy (dk, u, RIPEMD160_DIGESTSIZE);

  0008e	8b 4d 1c	 mov	 ecx, DWORD PTR _dk$[ebp]
  00091	8b 55 e8	 mov	 edx, DWORD PTR _u$[ebp]
  00094	89 11		 mov	 DWORD PTR [ecx], edx
  00096	8b 45 ec	 mov	 eax, DWORD PTR _u$[ebp+4]
  00099	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0009c	8b 55 f0	 mov	 edx, DWORD PTR _u$[ebp+8]
  0009f	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  000a2	8b 45 f4	 mov	 eax, DWORD PTR _u$[ebp+12]
  000a5	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  000a8	8b 55 f8	 mov	 edx, DWORD PTR _u$[ebp+16]
  000ab	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 442  : 		dk += RIPEMD160_DIGESTSIZE;

  000ae	8b 45 1c	 mov	 eax, DWORD PTR _dk$[ebp]
  000b1	83 c0 14	 add	 eax, 20			; 00000014H
  000b4	89 45 1c	 mov	 DWORD PTR _dk$[ebp], eax

; 443  : 	}

  000b7	eb a3		 jmp	 SHORT $LN7@derive_key@3
$LN6@derive_key@3:

; 444  : 
; 445  : 	/* last block */
; 446  : 	derive_u_ripemd160 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  000b9	8b 4d e4	 mov	 ecx, DWORD PTR _b$[ebp]
  000bc	51		 push	 ecx
  000bd	8d 55 e8	 lea	 edx, DWORD PTR _u$[ebp]
  000c0	52		 push	 edx
  000c1	8b 45 18	 mov	 eax, DWORD PTR _iterations$[ebp]
  000c4	50		 push	 eax
  000c5	8b 4d 14	 mov	 ecx, DWORD PTR _salt_len$[ebp]
  000c8	51		 push	 ecx
  000c9	8b 55 10	 mov	 edx, DWORD PTR _salt$[ebp]
  000cc	52		 push	 edx
  000cd	8b 45 0c	 mov	 eax, DWORD PTR _pwd_len$[ebp]
  000d0	50		 push	 eax
  000d1	8b 4d 08	 mov	 ecx, DWORD PTR _pwd$[ebp]
  000d4	51		 push	 ecx
  000d5	e8 00 00 00 00	 call	 _derive_u_ripemd160@28

; 447  : 	memcpy (dk, u, r);

  000da	8b 55 dc	 mov	 edx, DWORD PTR _r$[ebp]
  000dd	52		 push	 edx
  000de	8d 45 e8	 lea	 eax, DWORD PTR _u$[ebp]
  000e1	50		 push	 eax
  000e2	8b 4d 1c	 mov	 ecx, DWORD PTR _dk$[ebp]
  000e5	51		 push	 ecx
  000e6	e8 00 00 00 00	 call	 _memcpy
  000eb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@derive_key@3:

; 448  : 
; 449  : 
; 450  : 	/* Prevent possible leaks. */
; 451  : 	burn (u, sizeof(u));

  000ee	8d 55 e8	 lea	 edx, DWORD PTR _u$[ebp]
  000f1	89 55 d4	 mov	 DWORD PTR _burnm$27490[ebp], edx
  000f4	c7 45 d8 14 00
	00 00		 mov	 DWORD PTR _burnc$27492[ebp], 20 ; 00000014H
  000fb	6a 14		 push	 20			; 00000014H
  000fd	8d 45 e8	 lea	 eax, DWORD PTR _u$[ebp]
  00100	50		 push	 eax
  00101	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@derive_key@3:
  00106	8b 4d d8	 mov	 ecx, DWORD PTR _burnc$27492[ebp]
  00109	8b 55 d8	 mov	 edx, DWORD PTR _burnc$27492[ebp]
  0010c	83 ea 01	 sub	 edx, 1
  0010f	89 55 d8	 mov	 DWORD PTR _burnc$27492[ebp], edx
  00112	85 c9		 test	 ecx, ecx
  00114	74 11		 je	 SHORT $LN4@derive_key@3
  00116	8b 45 d4	 mov	 eax, DWORD PTR _burnm$27490[ebp]
  00119	c6 00 00	 mov	 BYTE PTR [eax], 0
  0011c	8b 4d d4	 mov	 ecx, DWORD PTR _burnm$27490[ebp]
  0011f	83 c1 01	 add	 ecx, 1
  00122	89 4d d4	 mov	 DWORD PTR _burnm$27490[ebp], ecx
  00125	eb df		 jmp	 SHORT $LN2@derive_key@3
$LN4@derive_key@3:
  00127	33 d2		 xor	 edx, edx
  00129	75 c3		 jne	 SHORT $LN5@derive_key@3

; 452  : }

  0012b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012e	33 cd		 xor	 ecx, ebp
  00130	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00135	8b e5		 mov	 esp, ebp
  00137	5d		 pop	 ebp
  00138	c2 1c 00	 ret	 28			; 0000001cH
_derive_key_ripemd160@28 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_hmac_whirlpool@24
EXTRN	_WHIRLPOOL_finalize@8:PROC
EXTRN	_WHIRLPOOL_add@12:PROC
EXTRN	_WHIRLPOOL_init@4:PROC
; Function compile flags: /Odtp
;	COMDAT _hmac_whirlpool@24
_TEXT	SEGMENT
tv150 = -828						; size = 4
_burnm$27597 = -824					; size = 4
_burnc$27599 = -820					; size = 4
_burnm$27588 = -816					; size = 4
_burnc$27590 = -812					; size = 4
_burnm$27579 = -808					; size = 4
_burnc$27581 = -804					; size = 4
_burnm$27570 = -800					; size = 4
_burnc$27572 = -796					; size = 4
_burnm$27561 = -792					; size = 4
_burnc$27563 = -788					; size = 4
_burnm$27552 = -784					; size = 4
_burnc$27554 = -780					; size = 4
_burnm$27523 = -776					; size = 4
_burnc$27525 = -772					; size = 4
_tctx$27517 = -768					; size = 168
_octx$ = -600						; size = 168
_iwhi$ = -432						; size = 64
_ictx$ = -368						; size = 168
_buf$ = -200						; size = 64
_owhi$ = -136						; size = 64
_key$ = -72						; size = 64
__$ArrayPad$ = -8					; size = 4
_i$ = -4						; size = 4
_k$ = 8							; size = 4
_lk$ = 12						; size = 4
_d$ = 16						; size = 4
_ld$ = 20						; size = 4
_out$ = 24						; size = 4
_t$ = 28						; size = 4
_hmac_whirlpool@24 PROC					; COMDAT

; 465  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 3c 03 00
	00		 sub	 esp, 828		; 0000033cH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 466  : 	WHIRLPOOL_CTX ictx, octx;
; 467  : 	char iwhi[WHIRLPOOL_DIGESTSIZE], owhi[WHIRLPOOL_DIGESTSIZE];
; 468  : 	char key[WHIRLPOOL_DIGESTSIZE];
; 469  : 	char buf[WHIRLPOOL_BLOCKSIZE];
; 470  : 	int i;
; 471  : 
; 472  :     /* If the key is longer than the hash algorithm block size,
; 473  : 	   let key = whirlpool(key), as per HMAC specifications. */
; 474  : 	if (lk > WHIRLPOOL_BLOCKSIZE)

  00015	83 7d 0c 40	 cmp	 DWORD PTR _lk$[ebp], 64	; 00000040H
  00019	0f 8e 9e 00 00
	00		 jle	 $LN48@hmac_whirl

; 475  : 	{
; 476  : 		WHIRLPOOL_CTX tctx;
; 477  : 
; 478  : 		WHIRLPOOL_init (&tctx);

  0001f	8d 85 00 fd ff
	ff		 lea	 eax, DWORD PTR _tctx$27517[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _WHIRLPOOL_init@4

; 479  : 		WHIRLPOOL_add ((unsigned char *) k, lk * 8, &tctx);

  0002b	8d 8d 00 fd ff
	ff		 lea	 ecx, DWORD PTR _tctx$27517[ebp]
  00031	51		 push	 ecx
  00032	8b 55 0c	 mov	 edx, DWORD PTR _lk$[ebp]
  00035	c1 e2 03	 shl	 edx, 3
  00038	52		 push	 edx
  00039	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _WHIRLPOOL_add@12

; 480  : 		WHIRLPOOL_finalize (&tctx, (unsigned char *) key);

  00042	8d 4d b8	 lea	 ecx, DWORD PTR _key$[ebp]
  00045	51		 push	 ecx
  00046	8d 95 00 fd ff
	ff		 lea	 edx, DWORD PTR _tctx$27517[ebp]
  0004c	52		 push	 edx
  0004d	e8 00 00 00 00	 call	 _WHIRLPOOL_finalize@8

; 481  : 
; 482  : 		k = key;

  00052	8d 45 b8	 lea	 eax, DWORD PTR _key$[ebp]
  00055	89 45 08	 mov	 DWORD PTR _k$[ebp], eax

; 483  : 		lk = WHIRLPOOL_DIGESTSIZE;

  00058	c7 45 0c 40 00
	00 00		 mov	 DWORD PTR _lk$[ebp], 64	; 00000040H
$LN47@hmac_whirl:

; 484  : 
; 485  : 		burn (&tctx, sizeof(tctx));		// Prevent leaks

  0005f	8d 8d 00 fd ff
	ff		 lea	 ecx, DWORD PTR _tctx$27517[ebp]
  00065	89 8d f8 fc ff
	ff		 mov	 DWORD PTR _burnm$27523[ebp], ecx
  0006b	c7 85 fc fc ff
	ff a8 00 00 00	 mov	 DWORD PTR _burnc$27525[ebp], 168 ; 000000a8H
  00075	68 a8 00 00 00	 push	 168			; 000000a8H
  0007a	8d 95 00 fd ff
	ff		 lea	 edx, DWORD PTR _tctx$27517[ebp]
  00080	52		 push	 edx
  00081	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN44@hmac_whirl:
  00086	8b 85 fc fc ff
	ff		 mov	 eax, DWORD PTR _burnc$27525[ebp]
  0008c	8b 8d fc fc ff
	ff		 mov	 ecx, DWORD PTR _burnc$27525[ebp]
  00092	83 e9 01	 sub	 ecx, 1
  00095	89 8d fc fc ff
	ff		 mov	 DWORD PTR _burnc$27525[ebp], ecx
  0009b	85 c0		 test	 eax, eax
  0009d	74 1a		 je	 SHORT $LN46@hmac_whirl
  0009f	8b 95 f8 fc ff
	ff		 mov	 edx, DWORD PTR _burnm$27523[ebp]
  000a5	c6 02 00	 mov	 BYTE PTR [edx], 0
  000a8	8b 85 f8 fc ff
	ff		 mov	 eax, DWORD PTR _burnm$27523[ebp]
  000ae	83 c0 01	 add	 eax, 1
  000b1	89 85 f8 fc ff
	ff		 mov	 DWORD PTR _burnm$27523[ebp], eax
  000b7	eb cd		 jmp	 SHORT $LN44@hmac_whirl
$LN46@hmac_whirl:
  000b9	33 c9		 xor	 ecx, ecx
  000bb	75 a2		 jne	 SHORT $LN47@hmac_whirl
$LN48@hmac_whirl:

; 486  : 	}
; 487  : 
; 488  : 	/**** Inner Digest ****/
; 489  : 
; 490  : 	WHIRLPOOL_init (&ictx);

  000bd	8d 95 90 fe ff
	ff		 lea	 edx, DWORD PTR _ictx$[ebp]
  000c3	52		 push	 edx
  000c4	e8 00 00 00 00	 call	 _WHIRLPOOL_init@4

; 491  : 
; 492  : 	/* Pad the key for inner digest */
; 493  : 	for (i = 0; i < lk; ++i)

  000c9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000d0	eb 09		 jmp	 SHORT $LN42@hmac_whirl
$LN41@hmac_whirl:
  000d2	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000d5	83 c0 01	 add	 eax, 1
  000d8	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN42@hmac_whirl:
  000db	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000de	3b 4d 0c	 cmp	 ecx, DWORD PTR _lk$[ebp]
  000e1	7d 18		 jge	 SHORT $LN40@hmac_whirl

; 494  : 		buf[i] = (char) (k[i] ^ 0x36);

  000e3	8b 55 08	 mov	 edx, DWORD PTR _k$[ebp]
  000e6	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  000e9	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000ec	83 f0 36	 xor	 eax, 54			; 00000036H
  000ef	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000f2	88 84 0d 38 ff
	ff ff		 mov	 BYTE PTR _buf$[ebp+ecx], al
  000f9	eb d7		 jmp	 SHORT $LN41@hmac_whirl
$LN40@hmac_whirl:

; 495  : 	for (i = lk; i < WHIRLPOOL_BLOCKSIZE; ++i)

  000fb	8b 55 0c	 mov	 edx, DWORD PTR _lk$[ebp]
  000fe	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
  00101	eb 09		 jmp	 SHORT $LN39@hmac_whirl
$LN38@hmac_whirl:
  00103	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00106	83 c0 01	 add	 eax, 1
  00109	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN39@hmac_whirl:
  0010c	83 7d fc 40	 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  00110	7d 0d		 jge	 SHORT $LN37@hmac_whirl

; 496  : 		buf[i] = 0x36;

  00112	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00115	c6 84 0d 38 ff
	ff ff 36	 mov	 BYTE PTR _buf$[ebp+ecx], 54 ; 00000036H
  0011d	eb e4		 jmp	 SHORT $LN38@hmac_whirl
$LN37@hmac_whirl:

; 497  : 
; 498  : 	WHIRLPOOL_add ((unsigned char *) buf, WHIRLPOOL_BLOCKSIZE * 8, &ictx);

  0011f	8d 95 90 fe ff
	ff		 lea	 edx, DWORD PTR _ictx$[ebp]
  00125	52		 push	 edx
  00126	68 00 02 00 00	 push	 512			; 00000200H
  0012b	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  00131	50		 push	 eax
  00132	e8 00 00 00 00	 call	 _WHIRLPOOL_add@12

; 499  : 	WHIRLPOOL_add ((unsigned char *) d, ld * 8, &ictx);

  00137	8d 8d 90 fe ff
	ff		 lea	 ecx, DWORD PTR _ictx$[ebp]
  0013d	51		 push	 ecx
  0013e	8b 55 14	 mov	 edx, DWORD PTR _ld$[ebp]
  00141	c1 e2 03	 shl	 edx, 3
  00144	52		 push	 edx
  00145	8b 45 10	 mov	 eax, DWORD PTR _d$[ebp]
  00148	50		 push	 eax
  00149	e8 00 00 00 00	 call	 _WHIRLPOOL_add@12

; 500  : 
; 501  : 	WHIRLPOOL_finalize (&ictx, (unsigned char *) iwhi);

  0014e	8d 8d 50 fe ff
	ff		 lea	 ecx, DWORD PTR _iwhi$[ebp]
  00154	51		 push	 ecx
  00155	8d 95 90 fe ff
	ff		 lea	 edx, DWORD PTR _ictx$[ebp]
  0015b	52		 push	 edx
  0015c	e8 00 00 00 00	 call	 _WHIRLPOOL_finalize@8

; 502  : 
; 503  : 	/**** Outer Digest ****/
; 504  : 
; 505  : 	WHIRLPOOL_init (&octx);

  00161	8d 85 a8 fd ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  00167	50		 push	 eax
  00168	e8 00 00 00 00	 call	 _WHIRLPOOL_init@4

; 506  : 
; 507  : 	for (i = 0; i < lk; ++i)

  0016d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00174	eb 09		 jmp	 SHORT $LN36@hmac_whirl
$LN35@hmac_whirl:
  00176	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00179	83 c1 01	 add	 ecx, 1
  0017c	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN36@hmac_whirl:
  0017f	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00182	3b 55 0c	 cmp	 edx, DWORD PTR _lk$[ebp]
  00185	7d 18		 jge	 SHORT $LN34@hmac_whirl

; 508  : 		buf[i] = (char) (k[i] ^ 0x5C);

  00187	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]
  0018a	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0018d	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00190	83 f1 5c	 xor	 ecx, 92			; 0000005cH
  00193	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00196	88 8c 15 38 ff
	ff ff		 mov	 BYTE PTR _buf$[ebp+edx], cl
  0019d	eb d7		 jmp	 SHORT $LN35@hmac_whirl
$LN34@hmac_whirl:

; 509  : 	for (i = lk; i < WHIRLPOOL_BLOCKSIZE; ++i)

  0019f	8b 45 0c	 mov	 eax, DWORD PTR _lk$[ebp]
  001a2	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  001a5	eb 09		 jmp	 SHORT $LN33@hmac_whirl
$LN32@hmac_whirl:
  001a7	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  001aa	83 c1 01	 add	 ecx, 1
  001ad	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN33@hmac_whirl:
  001b0	83 7d fc 40	 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  001b4	7d 0d		 jge	 SHORT $LN31@hmac_whirl

; 510  : 		buf[i] = 0x5C;

  001b6	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  001b9	c6 84 15 38 ff
	ff ff 5c	 mov	 BYTE PTR _buf$[ebp+edx], 92 ; 0000005cH
  001c1	eb e4		 jmp	 SHORT $LN32@hmac_whirl
$LN31@hmac_whirl:

; 511  : 
; 512  : 	WHIRLPOOL_add ((unsigned char *) buf, WHIRLPOOL_BLOCKSIZE * 8, &octx);

  001c3	8d 85 a8 fd ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  001c9	50		 push	 eax
  001ca	68 00 02 00 00	 push	 512			; 00000200H
  001cf	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR _buf$[ebp]
  001d5	51		 push	 ecx
  001d6	e8 00 00 00 00	 call	 _WHIRLPOOL_add@12

; 513  : 	WHIRLPOOL_add ((unsigned char *) iwhi, WHIRLPOOL_DIGESTSIZE * 8, &octx);

  001db	8d 95 a8 fd ff
	ff		 lea	 edx, DWORD PTR _octx$[ebp]
  001e1	52		 push	 edx
  001e2	68 00 02 00 00	 push	 512			; 00000200H
  001e7	8d 85 50 fe ff
	ff		 lea	 eax, DWORD PTR _iwhi$[ebp]
  001ed	50		 push	 eax
  001ee	e8 00 00 00 00	 call	 _WHIRLPOOL_add@12

; 514  : 
; 515  : 	WHIRLPOOL_finalize (&octx, (unsigned char *) owhi);

  001f3	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _owhi$[ebp]
  001f9	51		 push	 ecx
  001fa	8d 95 a8 fd ff
	ff		 lea	 edx, DWORD PTR _octx$[ebp]
  00200	52		 push	 edx
  00201	e8 00 00 00 00	 call	 _WHIRLPOOL_finalize@8

; 516  : 
; 517  : 	/* truncate and print the results */
; 518  : 	t = t > WHIRLPOOL_DIGESTSIZE ? WHIRLPOOL_DIGESTSIZE : t;

  00206	83 7d 1c 40	 cmp	 DWORD PTR _t$[ebp], 64	; 00000040H
  0020a	7e 0c		 jle	 SHORT $LN51@hmac_whirl
  0020c	c7 85 c4 fc ff
	ff 40 00 00 00	 mov	 DWORD PTR tv150[ebp], 64 ; 00000040H
  00216	eb 09		 jmp	 SHORT $LN52@hmac_whirl
$LN51@hmac_whirl:
  00218	8b 45 1c	 mov	 eax, DWORD PTR _t$[ebp]
  0021b	89 85 c4 fc ff
	ff		 mov	 DWORD PTR tv150[ebp], eax
$LN52@hmac_whirl:
  00221	8b 8d c4 fc ff
	ff		 mov	 ecx, DWORD PTR tv150[ebp]
  00227	89 4d 1c	 mov	 DWORD PTR _t$[ebp], ecx

; 519  : 	hmac_truncate (owhi, out, t);

  0022a	8b 55 1c	 mov	 edx, DWORD PTR _t$[ebp]
  0022d	52		 push	 edx
  0022e	8b 45 18	 mov	 eax, DWORD PTR _out$[ebp]
  00231	50		 push	 eax
  00232	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _owhi$[ebp]
  00238	51		 push	 ecx
  00239	e8 00 00 00 00	 call	 _hmac_truncate@12
$LN30@hmac_whirl:

; 520  : 
; 521  : 	/* Prevent possible leaks. */
; 522  : 	burn (&ictx, sizeof(ictx));

  0023e	8d 95 90 fe ff
	ff		 lea	 edx, DWORD PTR _ictx$[ebp]
  00244	89 95 f0 fc ff
	ff		 mov	 DWORD PTR _burnm$27552[ebp], edx
  0024a	c7 85 f4 fc ff
	ff a8 00 00 00	 mov	 DWORD PTR _burnc$27554[ebp], 168 ; 000000a8H
  00254	68 a8 00 00 00	 push	 168			; 000000a8H
  00259	8d 85 90 fe ff
	ff		 lea	 eax, DWORD PTR _ictx$[ebp]
  0025f	50		 push	 eax
  00260	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN27@hmac_whirl:
  00265	8b 8d f4 fc ff
	ff		 mov	 ecx, DWORD PTR _burnc$27554[ebp]
  0026b	8b 95 f4 fc ff
	ff		 mov	 edx, DWORD PTR _burnc$27554[ebp]
  00271	83 ea 01	 sub	 edx, 1
  00274	89 95 f4 fc ff
	ff		 mov	 DWORD PTR _burnc$27554[ebp], edx
  0027a	85 c9		 test	 ecx, ecx
  0027c	74 1a		 je	 SHORT $LN29@hmac_whirl
  0027e	8b 85 f0 fc ff
	ff		 mov	 eax, DWORD PTR _burnm$27552[ebp]
  00284	c6 00 00	 mov	 BYTE PTR [eax], 0
  00287	8b 8d f0 fc ff
	ff		 mov	 ecx, DWORD PTR _burnm$27552[ebp]
  0028d	83 c1 01	 add	 ecx, 1
  00290	89 8d f0 fc ff
	ff		 mov	 DWORD PTR _burnm$27552[ebp], ecx
  00296	eb cd		 jmp	 SHORT $LN27@hmac_whirl
$LN29@hmac_whirl:
  00298	33 d2		 xor	 edx, edx
  0029a	75 a2		 jne	 SHORT $LN30@hmac_whirl
$LN25@hmac_whirl:

; 523  : 	burn (&octx, sizeof(octx));

  0029c	8d 85 a8 fd ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  002a2	89 85 e8 fc ff
	ff		 mov	 DWORD PTR _burnm$27561[ebp], eax
  002a8	c7 85 ec fc ff
	ff a8 00 00 00	 mov	 DWORD PTR _burnc$27563[ebp], 168 ; 000000a8H
  002b2	68 a8 00 00 00	 push	 168			; 000000a8H
  002b7	8d 8d a8 fd ff
	ff		 lea	 ecx, DWORD PTR _octx$[ebp]
  002bd	51		 push	 ecx
  002be	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN22@hmac_whirl:
  002c3	8b 95 ec fc ff
	ff		 mov	 edx, DWORD PTR _burnc$27563[ebp]
  002c9	8b 85 ec fc ff
	ff		 mov	 eax, DWORD PTR _burnc$27563[ebp]
  002cf	83 e8 01	 sub	 eax, 1
  002d2	89 85 ec fc ff
	ff		 mov	 DWORD PTR _burnc$27563[ebp], eax
  002d8	85 d2		 test	 edx, edx
  002da	74 1a		 je	 SHORT $LN24@hmac_whirl
  002dc	8b 8d e8 fc ff
	ff		 mov	 ecx, DWORD PTR _burnm$27561[ebp]
  002e2	c6 01 00	 mov	 BYTE PTR [ecx], 0
  002e5	8b 95 e8 fc ff
	ff		 mov	 edx, DWORD PTR _burnm$27561[ebp]
  002eb	83 c2 01	 add	 edx, 1
  002ee	89 95 e8 fc ff
	ff		 mov	 DWORD PTR _burnm$27561[ebp], edx
  002f4	eb cd		 jmp	 SHORT $LN22@hmac_whirl
$LN24@hmac_whirl:
  002f6	33 c0		 xor	 eax, eax
  002f8	75 a2		 jne	 SHORT $LN25@hmac_whirl
$LN20@hmac_whirl:

; 524  : 	burn (owhi, sizeof(owhi));

  002fa	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _owhi$[ebp]
  00300	89 8d e0 fc ff
	ff		 mov	 DWORD PTR _burnm$27570[ebp], ecx
  00306	c7 85 e4 fc ff
	ff 40 00 00 00	 mov	 DWORD PTR _burnc$27572[ebp], 64 ; 00000040H
  00310	6a 40		 push	 64			; 00000040H
  00312	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR _owhi$[ebp]
  00318	52		 push	 edx
  00319	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN17@hmac_whirl:
  0031e	8b 85 e4 fc ff
	ff		 mov	 eax, DWORD PTR _burnc$27572[ebp]
  00324	8b 8d e4 fc ff
	ff		 mov	 ecx, DWORD PTR _burnc$27572[ebp]
  0032a	83 e9 01	 sub	 ecx, 1
  0032d	89 8d e4 fc ff
	ff		 mov	 DWORD PTR _burnc$27572[ebp], ecx
  00333	85 c0		 test	 eax, eax
  00335	74 1a		 je	 SHORT $LN19@hmac_whirl
  00337	8b 95 e0 fc ff
	ff		 mov	 edx, DWORD PTR _burnm$27570[ebp]
  0033d	c6 02 00	 mov	 BYTE PTR [edx], 0
  00340	8b 85 e0 fc ff
	ff		 mov	 eax, DWORD PTR _burnm$27570[ebp]
  00346	83 c0 01	 add	 eax, 1
  00349	89 85 e0 fc ff
	ff		 mov	 DWORD PTR _burnm$27570[ebp], eax
  0034f	eb cd		 jmp	 SHORT $LN17@hmac_whirl
$LN19@hmac_whirl:
  00351	33 c9		 xor	 ecx, ecx
  00353	75 a5		 jne	 SHORT $LN20@hmac_whirl
$LN15@hmac_whirl:

; 525  : 	burn (iwhi, sizeof(iwhi));

  00355	8d 95 50 fe ff
	ff		 lea	 edx, DWORD PTR _iwhi$[ebp]
  0035b	89 95 d8 fc ff
	ff		 mov	 DWORD PTR _burnm$27579[ebp], edx
  00361	c7 85 dc fc ff
	ff 40 00 00 00	 mov	 DWORD PTR _burnc$27581[ebp], 64 ; 00000040H
  0036b	6a 40		 push	 64			; 00000040H
  0036d	8d 85 50 fe ff
	ff		 lea	 eax, DWORD PTR _iwhi$[ebp]
  00373	50		 push	 eax
  00374	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN12@hmac_whirl:
  00379	8b 8d dc fc ff
	ff		 mov	 ecx, DWORD PTR _burnc$27581[ebp]
  0037f	8b 95 dc fc ff
	ff		 mov	 edx, DWORD PTR _burnc$27581[ebp]
  00385	83 ea 01	 sub	 edx, 1
  00388	89 95 dc fc ff
	ff		 mov	 DWORD PTR _burnc$27581[ebp], edx
  0038e	85 c9		 test	 ecx, ecx
  00390	74 1a		 je	 SHORT $LN14@hmac_whirl
  00392	8b 85 d8 fc ff
	ff		 mov	 eax, DWORD PTR _burnm$27579[ebp]
  00398	c6 00 00	 mov	 BYTE PTR [eax], 0
  0039b	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _burnm$27579[ebp]
  003a1	83 c1 01	 add	 ecx, 1
  003a4	89 8d d8 fc ff
	ff		 mov	 DWORD PTR _burnm$27579[ebp], ecx
  003aa	eb cd		 jmp	 SHORT $LN12@hmac_whirl
$LN14@hmac_whirl:
  003ac	33 d2		 xor	 edx, edx
  003ae	75 a5		 jne	 SHORT $LN15@hmac_whirl
$LN10@hmac_whirl:

; 526  : 	burn (buf, sizeof(buf));

  003b0	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  003b6	89 85 d0 fc ff
	ff		 mov	 DWORD PTR _burnm$27588[ebp], eax
  003bc	c7 85 d4 fc ff
	ff 40 00 00 00	 mov	 DWORD PTR _burnc$27590[ebp], 64 ; 00000040H
  003c6	6a 40		 push	 64			; 00000040H
  003c8	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR _buf$[ebp]
  003ce	51		 push	 ecx
  003cf	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN7@hmac_whirl:
  003d4	8b 95 d4 fc ff
	ff		 mov	 edx, DWORD PTR _burnc$27590[ebp]
  003da	8b 85 d4 fc ff
	ff		 mov	 eax, DWORD PTR _burnc$27590[ebp]
  003e0	83 e8 01	 sub	 eax, 1
  003e3	89 85 d4 fc ff
	ff		 mov	 DWORD PTR _burnc$27590[ebp], eax
  003e9	85 d2		 test	 edx, edx
  003eb	74 1a		 je	 SHORT $LN9@hmac_whirl
  003ed	8b 8d d0 fc ff
	ff		 mov	 ecx, DWORD PTR _burnm$27588[ebp]
  003f3	c6 01 00	 mov	 BYTE PTR [ecx], 0
  003f6	8b 95 d0 fc ff
	ff		 mov	 edx, DWORD PTR _burnm$27588[ebp]
  003fc	83 c2 01	 add	 edx, 1
  003ff	89 95 d0 fc ff
	ff		 mov	 DWORD PTR _burnm$27588[ebp], edx
  00405	eb cd		 jmp	 SHORT $LN7@hmac_whirl
$LN9@hmac_whirl:
  00407	33 c0		 xor	 eax, eax
  00409	75 a5		 jne	 SHORT $LN10@hmac_whirl
$LN5@hmac_whirl:

; 527  : 	burn (key, sizeof(key));

  0040b	8d 4d b8	 lea	 ecx, DWORD PTR _key$[ebp]
  0040e	89 8d c8 fc ff
	ff		 mov	 DWORD PTR _burnm$27597[ebp], ecx
  00414	c7 85 cc fc ff
	ff 40 00 00 00	 mov	 DWORD PTR _burnc$27599[ebp], 64 ; 00000040H
  0041e	6a 40		 push	 64			; 00000040H
  00420	8d 55 b8	 lea	 edx, DWORD PTR _key$[ebp]
  00423	52		 push	 edx
  00424	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@hmac_whirl:
  00429	8b 85 cc fc ff
	ff		 mov	 eax, DWORD PTR _burnc$27599[ebp]
  0042f	8b 8d cc fc ff
	ff		 mov	 ecx, DWORD PTR _burnc$27599[ebp]
  00435	83 e9 01	 sub	 ecx, 1
  00438	89 8d cc fc ff
	ff		 mov	 DWORD PTR _burnc$27599[ebp], ecx
  0043e	85 c0		 test	 eax, eax
  00440	74 1a		 je	 SHORT $LN4@hmac_whirl
  00442	8b 95 c8 fc ff
	ff		 mov	 edx, DWORD PTR _burnm$27597[ebp]
  00448	c6 02 00	 mov	 BYTE PTR [edx], 0
  0044b	8b 85 c8 fc ff
	ff		 mov	 eax, DWORD PTR _burnm$27597[ebp]
  00451	83 c0 01	 add	 eax, 1
  00454	89 85 c8 fc ff
	ff		 mov	 DWORD PTR _burnm$27597[ebp], eax
  0045a	eb cd		 jmp	 SHORT $LN2@hmac_whirl
$LN4@hmac_whirl:
  0045c	33 c9		 xor	 ecx, ecx
  0045e	75 ab		 jne	 SHORT $LN5@hmac_whirl

; 528  : }

  00460	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00463	33 cd		 xor	 ecx, ebp
  00465	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0046a	8b e5		 mov	 esp, ebp
  0046c	5d		 pop	 ebp
  0046d	c2 18 00	 ret	 24			; 00000018H
_hmac_whirlpool@24 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_derive_u_whirlpool@28
; Function compile flags: /Odtp
;	COMDAT _derive_u_whirlpool@28
_TEXT	SEGMENT
_burnm$27643 = -296					; size = 4
_burnc$27645 = -292					; size = 4
_burnm$27634 = -288					; size = 4
_burnc$27636 = -284					; size = 4
_j$ = -280						; size = 64
_c$ = -212						; size = 4
_k$ = -208						; size = 64
_counter$ = -140					; size = 4
_init$ = -136						; size = 128
__$ArrayPad$ = -8					; size = 4
_i$ = -4						; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_u$ = 28						; size = 4
_b$ = 32						; size = 4
_derive_u_whirlpool@28 PROC				; COMDAT

; 531  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 28 01 00
	00		 sub	 esp, 296		; 00000128H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi
  00016	57		 push	 edi

; 532  : 	char j[WHIRLPOOL_DIGESTSIZE], k[WHIRLPOOL_DIGESTSIZE];
; 533  : 	char init[128];
; 534  : 	char counter[4];
; 535  : 	int c, i;
; 536  : 
; 537  : 	/* iteration 1 */
; 538  : 	memset (counter, 0, 4);

  00017	33 c0		 xor	 eax, eax
  00019	89 85 74 ff ff
	ff		 mov	 DWORD PTR _counter$[ebp], eax

; 539  : 	counter[3] = (char) b;

  0001f	8a 4d 20	 mov	 cl, BYTE PTR _b$[ebp]
  00022	88 8d 77 ff ff
	ff		 mov	 BYTE PTR _counter$[ebp+3], cl

; 540  : 	memcpy (init, salt, salt_len);	/* salt */

  00028	8b 55 14	 mov	 edx, DWORD PTR _salt_len$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 10	 mov	 eax, DWORD PTR _salt$[ebp]
  0002f	50		 push	 eax
  00030	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _init$[ebp]
  00036	51		 push	 ecx
  00037	e8 00 00 00 00	 call	 _memcpy
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 541  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */

  0003f	8b 55 14	 mov	 edx, DWORD PTR _salt_len$[ebp]
  00042	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _counter$[ebp]
  00048	89 84 15 78 ff
	ff ff		 mov	 DWORD PTR _init$[ebp+edx], eax

; 542  : 	hmac_whirlpool (pwd, pwd_len, init, salt_len + 4, j, WHIRLPOOL_DIGESTSIZE);

  0004f	6a 40		 push	 64			; 00000040H
  00051	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _j$[ebp]
  00057	51		 push	 ecx
  00058	8b 55 14	 mov	 edx, DWORD PTR _salt_len$[ebp]
  0005b	83 c2 04	 add	 edx, 4
  0005e	52		 push	 edx
  0005f	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _init$[ebp]
  00065	50		 push	 eax
  00066	8b 4d 0c	 mov	 ecx, DWORD PTR _pwd_len$[ebp]
  00069	51		 push	 ecx
  0006a	8b 55 08	 mov	 edx, DWORD PTR _pwd$[ebp]
  0006d	52		 push	 edx
  0006e	e8 00 00 00 00	 call	 _hmac_whirlpool@24

; 543  : 	memcpy (u, j, WHIRLPOOL_DIGESTSIZE);

  00073	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00078	8d b5 e8 fe ff
	ff		 lea	 esi, DWORD PTR _j$[ebp]
  0007e	8b 7d 1c	 mov	 edi, DWORD PTR _u$[ebp]
  00081	f3 a5		 rep movsd

; 544  : 
; 545  : 	/* remaining iterations */
; 546  : 	for (c = 1; c < iterations; c++)

  00083	c7 85 2c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _c$[ebp], 1
  0008d	eb 0f		 jmp	 SHORT $LN16@derive_u_w
$LN15@derive_u_w:
  0008f	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _c$[ebp]
  00095	83 c0 01	 add	 eax, 1
  00098	89 85 2c ff ff
	ff		 mov	 DWORD PTR _c$[ebp], eax
$LN16@derive_u_w:
  0009e	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _c$[ebp]
  000a4	3b 4d 18	 cmp	 ecx, DWORD PTR _iterations$[ebp]
  000a7	7d 70		 jge	 SHORT $LN10@derive_u_w

; 547  : 	{
; 548  : 		hmac_whirlpool (pwd, pwd_len, j, WHIRLPOOL_DIGESTSIZE, k, WHIRLPOOL_DIGESTSIZE);

  000a9	6a 40		 push	 64			; 00000040H
  000ab	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR _k$[ebp]
  000b1	52		 push	 edx
  000b2	6a 40		 push	 64			; 00000040H
  000b4	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _j$[ebp]
  000ba	50		 push	 eax
  000bb	8b 4d 0c	 mov	 ecx, DWORD PTR _pwd_len$[ebp]
  000be	51		 push	 ecx
  000bf	8b 55 08	 mov	 edx, DWORD PTR _pwd$[ebp]
  000c2	52		 push	 edx
  000c3	e8 00 00 00 00	 call	 _hmac_whirlpool@24

; 549  : 		for (i = 0; i < WHIRLPOOL_DIGESTSIZE; i++)

  000c8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000cf	eb 09		 jmp	 SHORT $LN13@derive_u_w
$LN12@derive_u_w:
  000d1	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000d4	83 c0 01	 add	 eax, 1
  000d7	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN13@derive_u_w:
  000da	83 7d fc 40	 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  000de	7d 34		 jge	 SHORT $LN11@derive_u_w

; 550  : 		{
; 551  : 			u[i] ^= k[i];

  000e0	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000e3	0f be 94 0d 30
	ff ff ff	 movsx	 edx, BYTE PTR _k$[ebp+ecx]
  000eb	8b 45 1c	 mov	 eax, DWORD PTR _u$[ebp]
  000ee	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  000f1	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000f4	33 ca		 xor	 ecx, edx
  000f6	8b 55 1c	 mov	 edx, DWORD PTR _u$[ebp]
  000f9	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  000fc	88 0a		 mov	 BYTE PTR [edx], cl

; 552  : 			j[i] = k[i];

  000fe	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00101	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00104	8a 94 0d 30 ff
	ff ff		 mov	 dl, BYTE PTR _k$[ebp+ecx]
  0010b	88 94 05 e8 fe
	ff ff		 mov	 BYTE PTR _j$[ebp+eax], dl

; 553  : 		}

  00112	eb bd		 jmp	 SHORT $LN12@derive_u_w
$LN11@derive_u_w:

; 554  : 	}

  00114	e9 76 ff ff ff	 jmp	 $LN15@derive_u_w
$LN10@derive_u_w:

; 555  : 
; 556  : 	/* Prevent possible leaks. */
; 557  : 	burn (j, sizeof(j));

  00119	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _j$[ebp]
  0011f	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _burnm$27634[ebp], eax
  00125	c7 85 e4 fe ff
	ff 40 00 00 00	 mov	 DWORD PTR _burnc$27636[ebp], 64 ; 00000040H
  0012f	6a 40		 push	 64			; 00000040H
  00131	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _j$[ebp]
  00137	51		 push	 ecx
  00138	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN7@derive_u_w:
  0013d	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _burnc$27636[ebp]
  00143	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _burnc$27636[ebp]
  00149	83 e8 01	 sub	 eax, 1
  0014c	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _burnc$27636[ebp], eax
  00152	85 d2		 test	 edx, edx
  00154	74 1a		 je	 SHORT $LN9@derive_u_w
  00156	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _burnm$27634[ebp]
  0015c	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0015f	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _burnm$27634[ebp]
  00165	83 c2 01	 add	 edx, 1
  00168	89 95 e0 fe ff
	ff		 mov	 DWORD PTR _burnm$27634[ebp], edx
  0016e	eb cd		 jmp	 SHORT $LN7@derive_u_w
$LN9@derive_u_w:
  00170	33 c0		 xor	 eax, eax
  00172	75 a5		 jne	 SHORT $LN10@derive_u_w
$LN5@derive_u_w:

; 558  : 	burn (k, sizeof(k));

  00174	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _k$[ebp]
  0017a	89 8d d8 fe ff
	ff		 mov	 DWORD PTR _burnm$27643[ebp], ecx
  00180	c7 85 dc fe ff
	ff 40 00 00 00	 mov	 DWORD PTR _burnc$27645[ebp], 64 ; 00000040H
  0018a	6a 40		 push	 64			; 00000040H
  0018c	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR _k$[ebp]
  00192	52		 push	 edx
  00193	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@derive_u_w:
  00198	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _burnc$27645[ebp]
  0019e	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _burnc$27645[ebp]
  001a4	83 e9 01	 sub	 ecx, 1
  001a7	89 8d dc fe ff
	ff		 mov	 DWORD PTR _burnc$27645[ebp], ecx
  001ad	85 c0		 test	 eax, eax
  001af	74 1a		 je	 SHORT $LN4@derive_u_w
  001b1	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _burnm$27643[ebp]
  001b7	c6 02 00	 mov	 BYTE PTR [edx], 0
  001ba	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _burnm$27643[ebp]
  001c0	83 c0 01	 add	 eax, 1
  001c3	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _burnm$27643[ebp], eax
  001c9	eb cd		 jmp	 SHORT $LN2@derive_u_w
$LN4@derive_u_w:
  001cb	33 c9		 xor	 ecx, ecx
  001cd	75 a5		 jne	 SHORT $LN5@derive_u_w

; 559  : }

  001cf	5f		 pop	 edi
  001d0	5e		 pop	 esi
  001d1	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d4	33 cd		 xor	 ecx, ebp
  001d6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001db	8b e5		 mov	 esp, ebp
  001dd	5d		 pop	 ebp
  001de	c2 1c 00	 ret	 28			; 0000001cH
_derive_u_whirlpool@28 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_derive_key_whirlpool@28
; Function compile flags: /Odtp
;	COMDAT _derive_key_whirlpool@28
_TEXT	SEGMENT
_burnm$27676 = -92					; size = 4
_burnc$27678 = -88					; size = 4
_r$ = -84						; size = 4
_l$ = -80						; size = 4
_b$ = -76						; size = 4
_u$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_dk$ = 28						; size = 4
_dklen$ = 32						; size = 4
_derive_key_whirlpool@28 PROC				; COMDAT

; 562  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00012	56		 push	 esi
  00013	57		 push	 edi

; 563  : 	char u[WHIRLPOOL_DIGESTSIZE];
; 564  : 	int b, l, r;
; 565  : 
; 566  : 	if (dklen % WHIRLPOOL_DIGESTSIZE)

  00014	8b 45 20	 mov	 eax, DWORD PTR _dklen$[ebp]
  00017	25 3f 00 00 80	 and	 eax, -2147483585	; 8000003fH
  0001c	79 05		 jns	 SHORT $LN13@derive_key@4
  0001e	48		 dec	 eax
  0001f	83 c8 c0	 or	 eax, -64		; ffffffc0H
  00022	40		 inc	 eax
$LN13@derive_key@4:
  00023	85 c0		 test	 eax, eax
  00025	74 14		 je	 SHORT $LN10@derive_key@4

; 567  : 	{
; 568  : 		l = 1 + dklen / WHIRLPOOL_DIGESTSIZE;

  00027	8b 45 20	 mov	 eax, DWORD PTR _dklen$[ebp]
  0002a	99		 cdq
  0002b	83 e2 3f	 and	 edx, 63			; 0000003fH
  0002e	03 c2		 add	 eax, edx
  00030	c1 f8 06	 sar	 eax, 6
  00033	83 c0 01	 add	 eax, 1
  00036	89 45 b0	 mov	 DWORD PTR _l$[ebp], eax

; 569  : 	}
; 570  : 	else

  00039	eb 0f		 jmp	 SHORT $LN9@derive_key@4
$LN10@derive_key@4:

; 571  : 	{
; 572  : 		l = dklen / WHIRLPOOL_DIGESTSIZE;

  0003b	8b 45 20	 mov	 eax, DWORD PTR _dklen$[ebp]
  0003e	99		 cdq
  0003f	83 e2 3f	 and	 edx, 63			; 0000003fH
  00042	03 c2		 add	 eax, edx
  00044	c1 f8 06	 sar	 eax, 6
  00047	89 45 b0	 mov	 DWORD PTR _l$[ebp], eax
$LN9@derive_key@4:

; 573  : 	}
; 574  : 
; 575  : 	r = dklen - (l - 1) * WHIRLPOOL_DIGESTSIZE;

  0004a	8b 4d b0	 mov	 ecx, DWORD PTR _l$[ebp]
  0004d	83 e9 01	 sub	 ecx, 1
  00050	c1 e1 06	 shl	 ecx, 6
  00053	8b 55 20	 mov	 edx, DWORD PTR _dklen$[ebp]
  00056	2b d1		 sub	 edx, ecx
  00058	89 55 ac	 mov	 DWORD PTR _r$[ebp], edx

; 576  : 
; 577  : 	/* first l - 1 blocks */
; 578  : 	for (b = 1; b < l; b++)

  0005b	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR _b$[ebp], 1
  00062	eb 09		 jmp	 SHORT $LN8@derive_key@4
$LN7@derive_key@4:
  00064	8b 45 b4	 mov	 eax, DWORD PTR _b$[ebp]
  00067	83 c0 01	 add	 eax, 1
  0006a	89 45 b4	 mov	 DWORD PTR _b$[ebp], eax
$LN8@derive_key@4:
  0006d	8b 4d b4	 mov	 ecx, DWORD PTR _b$[ebp]
  00070	3b 4d b0	 cmp	 ecx, DWORD PTR _l$[ebp]
  00073	7d 39		 jge	 SHORT $LN6@derive_key@4

; 579  : 	{
; 580  : 		derive_u_whirlpool (pwd, pwd_len, salt, salt_len, iterations, u, b);

  00075	8b 55 b4	 mov	 edx, DWORD PTR _b$[ebp]
  00078	52		 push	 edx
  00079	8d 45 b8	 lea	 eax, DWORD PTR _u$[ebp]
  0007c	50		 push	 eax
  0007d	8b 4d 18	 mov	 ecx, DWORD PTR _iterations$[ebp]
  00080	51		 push	 ecx
  00081	8b 55 14	 mov	 edx, DWORD PTR _salt_len$[ebp]
  00084	52		 push	 edx
  00085	8b 45 10	 mov	 eax, DWORD PTR _salt$[ebp]
  00088	50		 push	 eax
  00089	8b 4d 0c	 mov	 ecx, DWORD PTR _pwd_len$[ebp]
  0008c	51		 push	 ecx
  0008d	8b 55 08	 mov	 edx, DWORD PTR _pwd$[ebp]
  00090	52		 push	 edx
  00091	e8 00 00 00 00	 call	 _derive_u_whirlpool@28

; 581  : 		memcpy (dk, u, WHIRLPOOL_DIGESTSIZE);

  00096	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0009b	8d 75 b8	 lea	 esi, DWORD PTR _u$[ebp]
  0009e	8b 7d 1c	 mov	 edi, DWORD PTR _dk$[ebp]
  000a1	f3 a5		 rep movsd

; 582  : 		dk += WHIRLPOOL_DIGESTSIZE;

  000a3	8b 45 1c	 mov	 eax, DWORD PTR _dk$[ebp]
  000a6	83 c0 40	 add	 eax, 64			; 00000040H
  000a9	89 45 1c	 mov	 DWORD PTR _dk$[ebp], eax

; 583  : 	}

  000ac	eb b6		 jmp	 SHORT $LN7@derive_key@4
$LN6@derive_key@4:

; 584  : 
; 585  : 	/* last block */
; 586  : 	derive_u_whirlpool (pwd, pwd_len, salt, salt_len, iterations, u, b);

  000ae	8b 4d b4	 mov	 ecx, DWORD PTR _b$[ebp]
  000b1	51		 push	 ecx
  000b2	8d 55 b8	 lea	 edx, DWORD PTR _u$[ebp]
  000b5	52		 push	 edx
  000b6	8b 45 18	 mov	 eax, DWORD PTR _iterations$[ebp]
  000b9	50		 push	 eax
  000ba	8b 4d 14	 mov	 ecx, DWORD PTR _salt_len$[ebp]
  000bd	51		 push	 ecx
  000be	8b 55 10	 mov	 edx, DWORD PTR _salt$[ebp]
  000c1	52		 push	 edx
  000c2	8b 45 0c	 mov	 eax, DWORD PTR _pwd_len$[ebp]
  000c5	50		 push	 eax
  000c6	8b 4d 08	 mov	 ecx, DWORD PTR _pwd$[ebp]
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 _derive_u_whirlpool@28

; 587  : 	memcpy (dk, u, r);

  000cf	8b 55 ac	 mov	 edx, DWORD PTR _r$[ebp]
  000d2	52		 push	 edx
  000d3	8d 45 b8	 lea	 eax, DWORD PTR _u$[ebp]
  000d6	50		 push	 eax
  000d7	8b 4d 1c	 mov	 ecx, DWORD PTR _dk$[ebp]
  000da	51		 push	 ecx
  000db	e8 00 00 00 00	 call	 _memcpy
  000e0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@derive_key@4:

; 588  : 
; 589  : 
; 590  : 	/* Prevent possible leaks. */
; 591  : 	burn (u, sizeof(u));

  000e3	8d 55 b8	 lea	 edx, DWORD PTR _u$[ebp]
  000e6	89 55 a4	 mov	 DWORD PTR _burnm$27676[ebp], edx
  000e9	c7 45 a8 40 00
	00 00		 mov	 DWORD PTR _burnc$27678[ebp], 64 ; 00000040H
  000f0	6a 40		 push	 64			; 00000040H
  000f2	8d 45 b8	 lea	 eax, DWORD PTR _u$[ebp]
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@derive_key@4:
  000fb	8b 4d a8	 mov	 ecx, DWORD PTR _burnc$27678[ebp]
  000fe	8b 55 a8	 mov	 edx, DWORD PTR _burnc$27678[ebp]
  00101	83 ea 01	 sub	 edx, 1
  00104	89 55 a8	 mov	 DWORD PTR _burnc$27678[ebp], edx
  00107	85 c9		 test	 ecx, ecx
  00109	74 11		 je	 SHORT $LN4@derive_key@4
  0010b	8b 45 a4	 mov	 eax, DWORD PTR _burnm$27676[ebp]
  0010e	c6 00 00	 mov	 BYTE PTR [eax], 0
  00111	8b 4d a4	 mov	 ecx, DWORD PTR _burnm$27676[ebp]
  00114	83 c1 01	 add	 ecx, 1
  00117	89 4d a4	 mov	 DWORD PTR _burnm$27676[ebp], ecx
  0011a	eb df		 jmp	 SHORT $LN2@derive_key@4
$LN4@derive_key@4:
  0011c	33 d2		 xor	 edx, edx
  0011e	75 c3		 jne	 SHORT $LN5@derive_key@4

; 592  : }

  00120	5f		 pop	 edi
  00121	5e		 pop	 esi
  00122	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00125	33 cd		 xor	 ecx, ebp
  00127	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c2 1c 00	 ret	 28			; 0000001cH
_derive_key_whirlpool@28 ENDP
_TEXT	ENDS
PUBLIC	??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BA@EMJCKHIJ@HMAC?9RIPEMD?9160?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0L@GENPDEDH@HMAC?9SHA?91?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0N@PGAIHMNP@HMAC?9SHA?9512?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	_get_pkcs5_prf_name@4
;	COMDAT ??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@FNODOBFM@ DB '(Unknown)', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@FNODOBFM@ DB 'HMAC-Whirlpool', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BA@EMJCKHIJ@HMAC?9RIPEMD?9160?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BA@EMJCKHIJ@HMAC?9RIPEMD?9160?$AA@FNODOBFM@ DB 'HMAC-RIPEMD-160', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0L@GENPDEDH@HMAC?9SHA?91?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0L@GENPDEDH@HMAC?9SHA?91?$AA@FNODOBFM@ DB 'HMAC-SHA-1', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0N@PGAIHMNP@HMAC?9SHA?9512?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0N@PGAIHMNP@HMAC?9SHA?9512?$AA@FNODOBFM@ DB 'HMAC-SHA-512', 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _get_pkcs5_prf_name@4
_TEXT	SEGMENT
tv64 = -4						; size = 4
_pkcs5_prf_id$ = 8					; size = 4
_get_pkcs5_prf_name@4 PROC				; COMDAT

; 596  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 597  : 	switch (pkcs5_prf_id)

  00006	8b 45 08	 mov	 eax, DWORD PTR _pkcs5_prf_id$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR tv64[ebp], eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR tv64[ebp]
  0000f	83 e9 01	 sub	 ecx, 1
  00012	89 4d fc	 mov	 DWORD PTR tv64[ebp], ecx
  00015	83 7d fc 03	 cmp	 DWORD PTR tv64[ebp], 3
  00019	77 26		 ja	 SHORT $LN1@get_pkcs5_
  0001b	8b 55 fc	 mov	 edx, DWORD PTR tv64[ebp]
  0001e	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN10@get_pkcs5_[edx*4]
$LN5@get_pkcs5_:

; 598  : 	{
; 599  : 	case SHA512:	
; 600  : 		return "HMAC-SHA-512";

  00025	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0N@PGAIHMNP@HMAC?9SHA?9512?$AA@FNODOBFM@
  0002a	eb 1a		 jmp	 SHORT $LN8@get_pkcs5_
$LN4@get_pkcs5_:

; 601  : 
; 602  : 	case SHA1:	// Deprecated/legacy
; 603  : 		return "HMAC-SHA-1";

  0002c	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0L@GENPDEDH@HMAC?9SHA?91?$AA@FNODOBFM@
  00031	eb 13		 jmp	 SHORT $LN8@get_pkcs5_
$LN3@get_pkcs5_:

; 604  : 
; 605  : 	case RIPEMD160:	
; 606  : 		return "HMAC-RIPEMD-160";

  00033	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BA@EMJCKHIJ@HMAC?9RIPEMD?9160?$AA@FNODOBFM@
  00038	eb 0c		 jmp	 SHORT $LN8@get_pkcs5_
$LN2@get_pkcs5_:

; 607  : 
; 608  : 	case WHIRLPOOL:	
; 609  : 		return "HMAC-Whirlpool";

  0003a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@FNODOBFM@
  0003f	eb 05		 jmp	 SHORT $LN8@get_pkcs5_
$LN1@get_pkcs5_:

; 610  : 
; 611  : 	default:		
; 612  : 		return "(Unknown)";

  00041	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@FNODOBFM@
$LN8@get_pkcs5_:

; 613  : 	}
; 614  : }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
$LN10@get_pkcs5_:
  0004c	00 00 00 00	 DD	 $LN3@get_pkcs5_
  00050	00 00 00 00	 DD	 $LN5@get_pkcs5_
  00054	00 00 00 00	 DD	 $LN2@get_pkcs5_
  00058	00 00 00 00	 DD	 $LN4@get_pkcs5_
_get_pkcs5_prf_name@4 ENDP
_TEXT	ENDS
PUBLIC	_get_pkcs5_iteration_count@8
EXTRN	__imp__KeBugCheckEx@20:PROC
; Function compile flags: /Odtp
;	COMDAT _get_pkcs5_iteration_count@8
_TEXT	SEGMENT
tv64 = -4						; size = 4
_pkcs5_prf_id$ = 8					; size = 4
_bBoot$ = 12						; size = 4
_get_pkcs5_iteration_count@8 PROC			; COMDAT

; 620  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 621  : 	switch (pkcs5_prf_id)

  00006	8b 45 08	 mov	 eax, DWORD PTR _pkcs5_prf_id$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR tv64[ebp], eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR tv64[ebp]
  0000f	83 e9 01	 sub	 ecx, 1
  00012	89 4d fc	 mov	 DWORD PTR tv64[ebp], ecx
  00015	83 7d fc 03	 cmp	 DWORD PTR tv64[ebp], 3
  00019	77 32		 ja	 SHORT $LN1@get_pkcs5_@2
  0001b	8b 55 fc	 mov	 edx, DWORD PTR tv64[ebp]
  0001e	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN10@get_pkcs5_@2[edx*4]
$LN5@get_pkcs5_@2:

; 622  : 	{
; 623  : 	case RIPEMD160:	
; 624  : 		return (bBoot ? 1000 : 2000);

  00025	8b 45 0c	 mov	 eax, DWORD PTR _bBoot$[ebp]
  00028	f7 d8		 neg	 eax
  0002a	1b c0		 sbb	 eax, eax
  0002c	25 18 fc ff ff	 and	 eax, -1000		; fffffc18H
  00031	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  00036	eb 2d		 jmp	 SHORT $LN9@get_pkcs5_@2
$LN4@get_pkcs5_@2:

; 625  : 
; 626  : #ifndef TC_WINDOWS_BOOT
; 627  : 
; 628  : 	case SHA512:	
; 629  : 		return 1000;			

  00038	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  0003d	eb 26		 jmp	 SHORT $LN9@get_pkcs5_@2
$LN3@get_pkcs5_@2:

; 630  : 
; 631  : 	case SHA1:		// Deprecated/legacy		
; 632  : 		return 2000;			

  0003f	b8 d0 07 00 00	 mov	 eax, 2000		; 000007d0H
  00044	eb 1f		 jmp	 SHORT $LN9@get_pkcs5_@2
$LN2@get_pkcs5_@2:

; 633  : 
; 634  : 	case WHIRLPOOL:	
; 635  : 		return 1000;

  00046	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  0004b	eb 18		 jmp	 SHORT $LN9@get_pkcs5_@2
$LN1@get_pkcs5_@2:

; 636  : #endif
; 637  : 
; 638  : 	default:		
; 639  : 		TC_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID

  0004d	68 43 54 00 00	 push	 21571			; 00005443H
  00052	6a 00		 push	 0
  00054	6a 00		 push	 0
  00056	68 7f 02 00 00	 push	 639			; 0000027fH
  0005b	6a 29		 push	 41			; 00000029H
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20

; 640  : 	}
; 641  : 	return 0;

  00063	33 c0		 xor	 eax, eax
$LN9@get_pkcs5_@2:

; 642  : }

  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 08 00	 ret	 8
  0006b	90		 npad	 1
$LN10@get_pkcs5_@2:
  0006c	00 00 00 00	 DD	 $LN5@get_pkcs5_@2
  00070	00 00 00 00	 DD	 $LN4@get_pkcs5_@2
  00074	00 00 00 00	 DD	 $LN2@get_pkcs5_@2
  00078	00 00 00 00	 DD	 $LN3@get_pkcs5_@2
_get_pkcs5_iteration_count@8 ENDP
_TEXT	ENDS
END
