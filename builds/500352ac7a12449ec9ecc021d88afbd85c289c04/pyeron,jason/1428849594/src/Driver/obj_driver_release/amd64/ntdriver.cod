; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	RootDeviceObject
PUBLIC	DriverShuttingDown
PUBLIC	OsMajorVersion
PUBLIC	DriverUnloadDisabled
PUBLIC	PortableMode
PUBLIC	VolumeClassFilterRegistered
PUBLIC	CacheBootPassword
PUBLIC	NonAdminSystemFavoritesAccessDisabled
PUBLIC	??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_1M@IOJLKPKK@?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_09EMKKFGIH@TrueCrypt?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BA@CCLAPIHO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_19JHEHLFPM@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DA@GMJGMIMP@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EA@FPAPEGHJ@?$AAP?$AAs?$AAD?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAI?$AAm?$AAp?$AAe?$AAr?$AAs?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAk?$AAe?$AAn?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1MA@BNNNAGDA@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BK@FNJCPENK@?$AAU?$AAp?$AAp?$AAe?$AAr?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAs?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BE@OBOIPPHP@?$AAt?$AAr?$AAu?$AAe?$AAc?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1HM@GLBNDPGI@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CA@LGEHFLCO@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EA@CEOJFLPD@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAE?$AAn?$AAc?$AAr?$AAy?$AAp?$AAt?$AAi?$AAo?$AAn?$AAF?$AAr?$AAe?$AAe?$AAC?$AAp?$AAu?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp_PsGetVersion:PROC
EXTRN	__imp_IoGetDeviceInterfaces:PROC
EXTRN	GUID_DEVINTERFACE_VOLUME:BYTE
EXTRN	__imp_IoRegisterShutdownNotification:PROC
EXTRN	__imp_KeInitializeSemaphore:PROC
EXTRN	__imp_IoEnumerateDeviceObjectList:PROC
EXTRN	__imp_ObOpenObjectByPointer:PROC
EXTRN	__imp_PsCreateSystemThread:PROC
EXTRN	__imp_SeCreateClientSecurity:PROC
EXTRN	__imp_KeReleaseSemaphore:PROC
EXTRN	__imp_KeInitializeTimerEx:PROC
EXTRN	__imp_KeSetTimerEx:PROC
EXTRN	__imp_wcsncat:PROC
EXTRN	__imp_MmGetSystemRoutineAddress:PROC
EXTRN	__imp_SeTokenType:PROC
EXTRN	__imp_IoGetDeviceObjectPointer:PROC
EXTRN	__imp_ObReferenceObjectByHandle:PROC
EXTRN	__imp_IoBuildSynchronousFsdRequest:PROC
EXTRN	__imp_ObfReferenceObject:PROC
EXTRN	__imp_IoBuildDeviceIoControlRequest:PROC
EXTRN	__imp_IoGetRelatedDeviceObject:PROC
EXTRN	__imp_IoCreateSymbolicLink:PROC
EXTRN	__imp_IoDeleteSymbolicLink:PROC
EXTRN	__imp_RtlLengthSid:PROC
EXTRN	__imp_RtlCopySid:PROC
EXTRN	__imp_ZwQuerySymbolicLinkObject:PROC
EXTRN	__imp_ZwCreateFile:PROC
EXTRN	__imp_ZwOpenSymbolicLinkObject:PROC
EXTRN	__imp_IofCompleteRequest:PROC
EXTRN	__imp_KeQueryActiveProcessors:PROC
EXTRN	__imp_KeDelayExecutionThread:PROC
EXTRN	__imp_ZwQueryValueKey:PROC
EXTRN	__imp_ZwClose:PROC
EXTRN	__imp_ZwOpenKey:PROC
EXTRN	__imp_ZwSetValueKey:PROC
EXTRN	__imp_RtlInitUnicodeString:PROC
EXTRN	__imp_SeCaptureSubjectContext:PROC
EXTRN	__imp_SeReleaseSubjectContext:PROC
EXTRN	__imp_RtlEqualSid:PROC
EXTRN	__imp_SeTokenIsAdmin:PROC
EXTRN	__imp_SeQueryInformationToken:PROC
EXTRN	__imp_KeQueryPerformanceCounter:PROC
COMM	VirtualVolumeDeviceObjects:QWORD:01aH
COMM	TCDriverObject:QWORD
COMM	LastUniqueVolumeId:DWORD
COMM	OsMinorVersion:DWORD
COMM	SelfTestsPassed:DWORD
RootDeviceObject DQ 01H DUP (?)
DriverShuttingDown DD 01H DUP (?)
OsMajorVersion DD 01H DUP (?)
DriverUnloadDisabled DD 01H DUP (?)
PortableMode DD	01H DUP (?)
VolumeClassFilterRegistered DD 01H DUP (?)
CacheBootPassword DD 01H DUP (?)
NonAdminSystemFavoritesAccessDisabled DD 01H DUP (?)
	ALIGN	8

EncryptionThreadPoolFreeCpuCountLimit DQ 01H DUP (?)
SystemFavoriteVolumeDirty DD 01H DUP (?)
PagingFileCreationPrevented DD 01H DUP (?)
;	COMDAT ??_C@_1EA@CEOJFLPD@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAE?$AAn?$AAc?$AAr?$AAy?$AAp?$AAt?$AAi?$AAo?$AAn?$AAF?$AAr?$AAe?$AAe?$AAC?$AAp?$AAu?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1EA@CEOJFLPD@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAE?$AAn?$AAc?$AAr?$AAy?$AAp?$AAt?$AAi?$AAo?$AAn?$AAF?$AAr?$AAe?$AAe?$AAC?$AAp?$AAu?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, 'E', 00H, 'n', 00H, 'c', 00H, 'r', 00H, 'y'
	DB	00H, 'p', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'F', 00H
	DB	'r', 00H, 'e', 00H, 'e', 00H, 'C', 00H, 'p', 00H, 'u', 00H, 'C'
	DB	00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CA@LGEHFLCO@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CA@LGEHFLCO@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 'f', 00H, 'i'
	DB	00H, 'g', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1HM@GLBNDPGI@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
text$s	SEGMENT
??_C@_1HM@GLBNDPGI@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@ DB '\'
	DB	00H, 'R', 00H, 'E', 00H, 'G', 00H, 'I', 00H, 'S', 00H, 'T', 00H
	DB	'R', 00H, 'Y', 00H, '\', 00H, 'M', 00H, 'A', 00H, 'C', 00H, 'H'
	DB	00H, 'I', 00H, 'N', 00H, 'E', 00H, '\', 00H, 'S', 00H, 'Y', 00H
	DB	'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '\', 00H, 'C', 00H, 'u'
	DB	00H, 'r', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'C', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, 'r', 00H, 'o', 00H, 'l', 00H, 'S'
	DB	00H, 'e', 00H, 't', 00H, '\', 00H, 'S', 00H, 'e', 00H, 'r', 00H
	DB	'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 'c', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BE@OBOIPPHP@?$AAt?$AAr?$AAu?$AAe?$AAc?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BE@OBOIPPHP@?$AAt?$AAr?$AAu?$AAe?$AAc?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ DB 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 'c', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BK@FNJCPENK@?$AAU?$AAp?$AAp?$AAe?$AAr?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAs?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BK@FNJCPENK@?$AAU?$AAp?$AAp?$AAe?$AAr?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAs?$AA?$AA@FNODOBFM@ DB 'U'
	DB	00H, 'p', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'F', 00H, 'i', 00H
	DB	'l', 00H, 't', 00H, 'e', 00H, 'r', 00H, 's', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1MA@BNNNAGDA@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
text$s	SEGMENT
??_C@_1MA@BNNNAGDA@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@ DB '\'
	DB	00H, 'R', 00H, 'E', 00H, 'G', 00H, 'I', 00H, 'S', 00H, 'T', 00H
	DB	'R', 00H, 'Y', 00H, '\', 00H, 'M', 00H, 'A', 00H, 'C', 00H, 'H'
	DB	00H, 'I', 00H, 'N', 00H, 'E', 00H, '\', 00H, 'S', 00H, 'Y', 00H
	DB	'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '\', 00H, 'C', 00H, 'u'
	DB	00H, 'r', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'C', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, 'r', 00H, 'o', 00H, 'l', 00H, 'S'
	DB	00H, 'e', 00H, 't', 00H, '\', 00H, 'C', 00H, 'o', 00H, 'n', 00H
	DB	't', 00H, 'r', 00H, 'o', 00H, 'l', 00H, '\', 00H, 'C', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, '\', 00H, '{', 00H, '7', 00H
	DB	'1', 00H, 'A', 00H, '2', 00H, '7', 00H, 'C', 00H, 'D', 00H, 'D'
	DB	00H, '-', 00H, '8', 00H, '1', 00H, '2', 00H, 'A', 00H, '-', 00H
	DB	'1', 00H, '1', 00H, 'D', 00H, '0', 00H, '-', 00H, 'B', 00H, 'E'
	DB	00H, 'C', 00H, '7', 00H, '-', 00H, '0', 00H, '8', 00H, '0', 00H
	DB	'0', 00H, '2', 00H, 'B', 00H, 'E', 00H, '2', 00H, '0', 00H, '9'
	DB	00H, '2', 00H, 'F', 00H, '}', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'M', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, 'P'
	DB	00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'M', 00H, 'a', 00H
	DB	'n', 00H, 'a', 00H, 'g', 00H, 'e', 00H, 'r', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EA@FPAPEGHJ@?$AAP?$AAs?$AAD?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAI?$AAm?$AAp?$AAe?$AAr?$AAs?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAk?$AAe?$AAn?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1EA@FPAPEGHJ@?$AAP?$AAs?$AAD?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAI?$AAm?$AAp?$AAe?$AAr?$AAs?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAk?$AAe?$AAn?$AA?$AA@FNODOBFM@ DB 'P'
	DB	00H, 's', 00H, 'D', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H
	DB	'e', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, 'I'
	DB	00H, 'm', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 's', 00H, 'o', 00H
	DB	'n', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'T'
	DB	00H, 'o', 00H, 'k', 00H, 'e', 00H, 'n', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'T', 00H, 'r'
	DB	00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r', 00H, 'y', 00H, 'p', 00H
	DB	't', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DA@GMJGMIMP@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DA@GMJGMIMP@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'T', 00H, 'r', 00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r'
	DB	00H, 'y', 00H, 'p', 00H, 't', 00H, 'V', 00H, 'o', 00H, 'l', 00H
	DB	'u', 00H, 'm', 00H, 'e', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_19JHEHLFPM@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_19JHEHLFPM@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$AA@FNODOBFM@ DB '\', 00H
	DB	'?', 00H, '?', 00H, '\', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BA@CCLAPIHO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BA@CCLAPIHO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_09EMKKFGIH@TrueCrypt?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09EMKKFGIH@TrueCrypt?$AA@FNODOBFM@ DB 'TrueCrypt', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@FNODOBFM@ DB 'TrueCryptVolume', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'T', 00H, 'r'
	DB	00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r', 00H, 'y', 00H, 'p', 00H
	DB	't', 00H, 00H, 00H				;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_1M@IOJLKPKK@?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_1M@IOJLKPKK@?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@PBOPGDP@ DB 'S', 00H, 't'
	DB	00H, 'a', 00H, 'r', 00H, 't', 00H, 00H, 00H	;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'T', 00H, 'r', 00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r'
	DB	00H, 'y', 00H, 'p', 00H, 't', 00H, 00H, 00H	;  ?? ::PBOPGDP::`string'
PUBLIC	IsOSAtLeast
;	COMDAT pdata
; File c:\home\public\desktop\projects\ciphershed.build\src\driver\ntdriver.c
pdata	SEGMENT
$pdata$IsOSAtLeast DD imagerel $LN16
	DD	imagerel $LN16+167
	DD	imagerel $unwind$IsOSAtLeast
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IsOSAtLeast DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT IsOSAtLeast
_TEXT	SEGMENT
reqMinOS$ = 64
IsOSAtLeast PROC					; COMDAT

; 3280 : {

$LN16:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3281 : 	/* When updating this function, update IsOSVersionAtLeast() in Dlgcode.c too. */
; 3282 : 
; 3283 : 	ULONG major = 0, minor = 0;
; 3284 : 
; 3285 : 	ASSERT (OsMajorVersion != 0);
; 3286 : 
; 3287 : 	switch (reqMinOS)

  00004	45 33 c0	 xor	 r8d, r8d
  00007	83 e9 07	 sub	 ecx, 7
  0000a	74 68		 je	 SHORT $LN8@IsOSAtLeas
  0000c	45 8d 48 01	 lea	 r9d, QWORD PTR [r8+1]
  00010	41 2b c9	 sub	 ecx, r9d
  00013	74 55		 je	 SHORT $LN7@IsOSAtLeas
  00015	41 8d 50 02	 lea	 edx, QWORD PTR [r8+2]
  00019	2b ca		 sub	 ecx, edx
  0001b	74 46		 je	 SHORT $LN6@IsOSAtLeas
  0001d	41 2b c9	 sub	 ecx, r9d
  00020	74 3a		 je	 SHORT $LN5@IsOSAtLeas
  00022	2b ca		 sub	 ecx, edx
  00024	74 2f		 je	 SHORT $LN4@IsOSAtLeas
  00026	2b ca		 sub	 ecx, edx
  00028	74 24		 je	 SHORT $LN3@IsOSAtLeas
  0002a	41 8d 50 04	 lea	 edx, QWORD PTR [r8+4]
  0002e	3b ca		 cmp	 ecx, edx
  00030	74 1c		 je	 SHORT $LN3@IsOSAtLeas

; 3295 : 	case WIN_10:			major = 6; minor = 4; break;
; 3296 : 
; 3297 : 	default:
; 3298 : 		TC_THROW_FATAL_EXCEPTION;

  00032	41 8d 48 29	 lea	 ecx, QWORD PTR [r8+41]
  00036	45 33 c9	 xor	 r9d, r9d
  00039	ba e2 0c 00 00	 mov	 edx, 3298		; 00000ce2H
  0003e	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  0004d	cc		 int	 3
$LN3@IsOSAtLeas:

; 3294 : 	case WIN_8:				major = 6; minor = 2; break;

  0004e	b8 06 00 00 00	 mov	 eax, 6
  00053	eb 27		 jmp	 SHORT $LN9@IsOSAtLeas
$LN4@IsOSAtLeas:

; 3293 : 	case WIN_7:				major = 6; minor = 1; break;

  00055	b8 06 00 00 00	 mov	 eax, 6
  0005a	eb 13		 jmp	 SHORT $LN15@IsOSAtLeas
$LN5@IsOSAtLeas:

; 3292 : 	case WIN_VISTA:			major = 6; minor = 0; break;

  0005c	b8 06 00 00 00	 mov	 eax, 6
  00061	eb 16		 jmp	 SHORT $LN14@IsOSAtLeas
$LN6@IsOSAtLeas:

; 3291 : 	case WIN_SERVER_2003:	major = 5; minor = 2; break;

  00063	b8 05 00 00 00	 mov	 eax, 5
  00068	eb 12		 jmp	 SHORT $LN9@IsOSAtLeas
$LN7@IsOSAtLeas:

; 3290 : 	case WIN_XP:			major = 5; minor = 1; break;

  0006a	b8 05 00 00 00	 mov	 eax, 5
$LN15@IsOSAtLeas:
  0006f	41 8b d1	 mov	 edx, r9d
  00072	eb 08		 jmp	 SHORT $LN9@IsOSAtLeas
$LN8@IsOSAtLeas:

; 3288 : 	{
; 3289 : 	case WIN_2000:			major = 5; minor = 0; break;

  00074	b8 05 00 00 00	 mov	 eax, 5
$LN14@IsOSAtLeas:
  00079	41 8b d0	 mov	 edx, r8d
$LN9@IsOSAtLeas:

; 3299 : 		break;
; 3300 : 	}
; 3301 : 
; 3302 : 	return ((OsMajorVersion << 16 | OsMinorVersion << 8)
; 3303 : 		>= (major << 16 | minor << 8));

  0007c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR OsMajorVersion
  00082	c1 e0 08	 shl	 eax, 8
  00085	0b c2		 or	 eax, edx
  00087	c1 e1 08	 shl	 ecx, 8
  0008a	ba ff ff ff 00	 mov	 edx, 16777215		; 00ffffffH
  0008f	0b 0d 00 00 00
	00		 or	 ecx, DWORD PTR OsMinorVersion
  00095	23 c2		 and	 eax, edx
  00097	23 ca		 and	 ecx, edx
  00099	3b c8		 cmp	 ecx, eax
  0009b	41 0f 93 c0	 setae	 r8b
  0009f	41 8b c0	 mov	 eax, r8d

; 3304 : }

  000a2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a6	c3		 ret	 0
$LN13@IsOSAtLeas:
IsOSAtLeast ENDP
_TEXT	ENDS
PUBLIC	TCReadRegistryKey
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCReadRegistryKey DD imagerel $LN9
	DD	imagerel $LN9+291
	DD	imagerel $unwind$TCReadRegistryKey
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCReadRegistryKey DD 040f01H
	DD	013340fH
	DD	07008f20fH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT TCReadRegistryKey
_TEXT	SEGMENT
regKeyHandle$ = 48
valName$ = 56
size$ = 144
keyPath$ = 144
keyValueName$ = 152
keyData$ = 160
resultSize$ = 168
TCReadRegistryKey PROC					; COMDAT

; 2976 : {

$LN9:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00007	57		 push	 rdi
  00008	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 2977 : 	OBJECT_ATTRIBUTES regObjAttribs;
; 2978 : 	HANDLE regKeyHandle;
; 2979 : 	NTSTATUS status;
; 2980 : 	UNICODE_STRING valName;
; 2981 : 	ULONG size = 0;

  0000f	83 60 08 00	 and	 DWORD PTR [rax+8], 0

; 2982 : 	ULONG resultSize;
; 2983 : 
; 2984 : 	InitializeObjectAttributes (&regObjAttribs, keyPath, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

  00013	48 83 60 c8 00	 and	 QWORD PTR [rax-56], 0
  00018	48 83 60 e0 00	 and	 QWORD PTR [rax-32], 0
  0001d	48 83 60 e8 00	 and	 QWORD PTR [rax-24], 0
  00022	49 8b f8	 mov	 rdi, r8
  00025	48 89 48 d0	 mov	 QWORD PTR [rax-48], rcx
  00029	48 8b da	 mov	 rbx, rdx

; 2985 : 	status = ZwOpenKey (&regKeyHandle, KEY_READ, &regObjAttribs);

  0002c	4c 8d 40 c0	 lea	 r8, QWORD PTR [rax-64]
  00030	48 8d 48 a8	 lea	 rcx, QWORD PTR [rax-88]
  00034	ba 19 00 02 00	 mov	 edx, 131097		; 00020019H
  00039	c7 40 c0 30 00
	00 00		 mov	 DWORD PTR [rax-64], 48	; 00000030H
  00040	c7 40 d8 40 02
	00 00		 mov	 DWORD PTR [rax-40], 576	; 00000240H
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwOpenKey

; 2986 : 	if (!NT_SUCCESS (status))

  0004d	85 c0		 test	 eax, eax

; 2987 : 		return status;

  0004f	0f 88 bd 00 00
	00		 js	 $LN5@TCReadRegi

; 2988 : 
; 2989 : 	RtlInitUnicodeString (&valName, keyValueName);

  00055	48 8d 4c 24 38	 lea	 rcx, QWORD PTR valName$[rsp]
  0005a	48 8b d3	 mov	 rdx, rbx
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2990 : 	status = ZwQueryValueKey (regKeyHandle, &valName, KeyValuePartialInformation, NULL, 0, &size);

  00063	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regKeyHandle$[rsp]
  00068	45 33 c9	 xor	 r9d, r9d
  0006b	4c 8d 9c 24 90
	00 00 00	 lea	 r11, QWORD PTR size$[rsp]
  00073	45 8d 41 02	 lea	 r8d, QWORD PTR [r9+2]
  00077	48 8d 54 24 38	 lea	 rdx, QWORD PTR valName$[rsp]
  0007c	4c 89 5c 24 28	 mov	 QWORD PTR [rsp+40], r11
  00081	83 64 24 20 00	 and	 DWORD PTR [rsp+32], 0
  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwQueryValueKey
  0008c	8b d8		 mov	 ebx, eax

; 2991 : 		
; 2992 : 	if (!NT_SUCCESS (status) && status != STATUS_BUFFER_OVERFLOW && status != STATUS_BUFFER_TOO_SMALL)

  0008e	85 c0		 test	 eax, eax
  00090	79 0e		 jns	 SHORT $LN3@TCReadRegi
  00092	3d 05 00 00 80	 cmp	 eax, -2147483643	; ffffffff80000005H
  00097	74 07		 je	 SHORT $LN3@TCReadRegi
  00099	3d 23 00 00 c0	 cmp	 eax, -1073741789	; ffffffffc0000023H
  0009e	75 65		 jne	 SHORT $LN7@TCReadRegi
$LN3@TCReadRegi:

; 2993 : 	{
; 2994 : 		ZwClose (regKeyHandle);
; 2995 : 		return status;
; 2996 : 	}
; 2997 : 
; 2998 : 	if (size == 0)

  000a0	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  000a7	85 c0		 test	 eax, eax
  000a9	75 07		 jne	 SHORT $LN2@TCReadRegi
  000ab	bb 22 00 00 80	 mov	 ebx, -2147483614	; ffffffff80000022H
  000b0	eb 53		 jmp	 SHORT $LN7@TCReadRegi
$LN2@TCReadRegi:

; 2999 : 	{
; 3000 : 		ZwClose (regKeyHandle);
; 3001 : 		return STATUS_NO_DATA_DETECTED;
; 3002 : 	}
; 3003 : 
; 3004 : 	*keyData = (PKEY_VALUE_PARTIAL_INFORMATION) TCalloc (size);

  000b2	48 8b d0	 mov	 rdx, rax
  000b5	33 c9		 xor	 ecx, ecx
  000b7	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  000c3	4c 8b c8	 mov	 r9, rax
  000c6	48 89 07	 mov	 QWORD PTR [rdi], rax

; 3005 : 	if (!*keyData)

  000c9	48 85 c0	 test	 rax, rax
  000cc	75 07		 jne	 SHORT $LN1@TCReadRegi
  000ce	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; ffffffffc000009aH
  000d3	eb 30		 jmp	 SHORT $LN7@TCReadRegi
$LN1@TCReadRegi:

; 3006 : 	{
; 3007 : 		ZwClose (regKeyHandle);
; 3008 : 		return STATUS_INSUFFICIENT_RESOURCES;
; 3009 : 	}
; 3010 : 
; 3011 : 	status = ZwQueryValueKey (regKeyHandle, &valName, KeyValuePartialInformation, *keyData, size, &resultSize);

  000d5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regKeyHandle$[rsp]
  000da	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR resultSize$[rsp]
  000e2	48 8d 54 24 38	 lea	 rdx, QWORD PTR valName$[rsp]
  000e7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000ec	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  000f3	41 b8 02 00 00
	00		 mov	 r8d, 2
  000f9	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwQueryValueKey
  00103	8b d8		 mov	 ebx, eax
$LN7@TCReadRegi:
  00105	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regKeyHandle$[rsp]
  0010a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
  00110	8b c3		 mov	 eax, ebx
$LN5@TCReadRegi:

; 3012 : 
; 3013 : 	ZwClose (regKeyHandle);
; 3014 : 	return status;
; 3015 : }

  00112	48 8b 9c 24 98
	00 00 00	 mov	 rbx, QWORD PTR [rsp+152]
  0011a	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00121	5f		 pop	 rdi
  00122	c3		 ret	 0
TCReadRegistryKey ENDP
_TEXT	ENDS
PUBLIC	EnsureNullTerminatedString
; Function compile flags: /Ogspy
;	COMDAT EnsureNullTerminatedString
_TEXT	SEGMENT
str$ = 8
maxSizeInBytes$ = 16
EnsureNullTerminatedString PROC				; COMDAT

; 2945 : 	ASSERT ((maxSizeInBytes & 1) == 0);
; 2946 : 	str[maxSizeInBytes / sizeof (wchar_t) - 1] = 0;

  00000	33 c0		 xor	 eax, eax
  00002	66 89 81 06 02
	00 00		 mov	 WORD PTR [rcx+518], ax

; 2947 : }

  00009	c3		 ret	 0
EnsureNullTerminatedString ENDP
_TEXT	ENDS
PUBLIC	GetCpuCount
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetCpuCount DD imagerel $LN10
	DD	imagerel $LN10+54
	DD	imagerel $unwind$GetCpuCount
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetCpuCount DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GetCpuCount
_TEXT	SEGMENT
GetCpuCount PROC					; COMDAT

; 2923 : {

$LN10:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2924 : 	KAFFINITY activeCpuMap = KeQueryActiveProcessors();

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeQueryActiveProcessors

; 2925 : 	size_t mapSize = sizeof (activeCpuMap) * 8;

  0000a	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0000f	4c 8b d8	 mov	 r11, rax

; 2926 : 	size_t cpuCount = 0;

  00012	33 c0		 xor	 eax, eax
  00014	8d 51 c1	 lea	 edx, QWORD PTR [rcx-63]
$LL4@GetCpuCoun:

; 2927 : 
; 2928 : 	while (mapSize--)

  00017	48 2b ca	 sub	 rcx, rdx

; 2929 : 	{
; 2930 : 		if (activeCpuMap & 1)

  0001a	44 84 da	 test	 r11b, dl
  0001d	74 03		 je	 SHORT $LN2@GetCpuCoun

; 2931 : 			++cpuCount;

  0001f	48 03 c2	 add	 rax, rdx
$LN2@GetCpuCoun:

; 2932 : 
; 2933 : 		activeCpuMap >>= 1;

  00022	49 d1 eb	 shr	 r11, 1
  00025	48 85 c9	 test	 rcx, rcx
  00028	75 ed		 jne	 SHORT $LL4@GetCpuCoun

; 2934 : 	}
; 2935 : 
; 2936 : 	if (cpuCount == 0)

  0002a	48 85 c0	 test	 rax, rax
  0002d	48 0f 44 c2	 cmove	 rax, rdx

; 2937 : 		return 1;
; 2938 : 
; 2939 : 	return cpuCount;
; 2940 : }

  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	c3		 ret	 0
GetCpuCount ENDP
_TEXT	ENDS
PUBLIC	TCCompleteDiskIrp
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCCompleteDiskIrp DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$TCCompleteDiskIrp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCCompleteDiskIrp DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT TCCompleteDiskIrp
_TEXT	SEGMENT
irp$ = 48
status$ = 56
information$ = 64
TCCompleteDiskIrp PROC					; COMDAT

; 2914 : {

$LN3:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2915 : 	irp->IoStatus.Status = status;
; 2916 : 	irp->IoStatus.Information = information;
; 2917 : 	IoCompleteRequest (irp, NT_SUCCESS (status) ? IO_DISK_INCREMENT : IO_NO_INCREMENT);

  00006	85 d2		 test	 edx, edx
  00008	8b da		 mov	 ebx, edx
  0000a	89 51 30	 mov	 DWORD PTR [rcx+48], edx
  0000d	0f 99 c2	 setns	 dl
  00010	4c 89 41 38	 mov	 QWORD PTR [rcx+56], r8
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 2918 : 	return status;

  0001a	8b c3		 mov	 eax, ebx

; 2919 : }

  0001c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00020	5b		 pop	 rbx
  00021	c3		 ret	 0
TCCompleteDiskIrp ENDP
_TEXT	ENDS
PUBLIC	TCCompleteIrp
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCCompleteIrp DD imagerel $LN3
	DD	imagerel $LN3+31
	DD	imagerel $unwind$TCCompleteIrp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCCompleteIrp DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT TCCompleteIrp
_TEXT	SEGMENT
irp$ = 48
status$ = 56
information$ = 64
TCCompleteIrp PROC					; COMDAT

; 2905 : {

$LN3:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	8b da		 mov	 ebx, edx

; 2906 : 	irp->IoStatus.Status = status;

  00008	89 51 30	 mov	 DWORD PTR [rcx+48], edx

; 2907 : 	irp->IoStatus.Information = information;
; 2908 : 	IoCompleteRequest (irp, IO_NO_INCREMENT);

  0000b	33 d2		 xor	 edx, edx
  0000d	4c 89 41 38	 mov	 QWORD PTR [rcx+56], r8
  00011	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 2909 : 	return status;

  00017	8b c3		 mov	 eax, ebx

; 2910 : }

  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5b		 pop	 rbx
  0001e	c3		 ret	 0
TCCompleteIrp ENDP
_TEXT	ENDS
PUBLIC	IsAccessibleByUser
;	COMDAT pdata
pdata	SEGMENT
$pdata$IsAccessibleByUser DD imagerel $LN4
	DD	imagerel $LN4+144
	DD	imagerel $unwind$IsAccessibleByUser
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IsAccessibleByUser DD 020a01H
	DD	015010aH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT IsAccessibleByUser
_TEXT	SEGMENT
fileHandle$ = 176
objectFileName$ = 176
readOnly$ = 184
IsAccessibleByUser PROC					; COMDAT

; 2842 : {

$LN4:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 2843 : 	OBJECT_ATTRIBUTES fileObjAttributes;
; 2844 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2845 : 	HANDLE fileHandle;
; 2846 : 	NTSTATUS status;
; 2847 : 
; 2848 : 	ASSERT (!IoIsSystemThread (PsGetCurrentThread()));
; 2849 : 
; 2850 : 	InitializeObjectAttributes (&fileObjAttributes, objectFileName, OBJ_CASE_INSENSITIVE | OBJ_FORCE_ACCESS_CHECK | OBJ_KERNEL_HANDLE, NULL, NULL);
; 2851 : 	
; 2852 : 	status = ZwCreateFile (&fileHandle,
; 2853 : 		readOnly ? GENERIC_READ : GENERIC_READ | GENERIC_WRITE,
; 2854 : 		&fileObjAttributes,
; 2855 : 		&ioStatusBlock,
; 2856 : 		NULL,
; 2857 : 		FILE_ATTRIBUTE_NORMAL,
; 2858 : 		FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
; 2859 : 		FILE_OPEN,
; 2860 : 		FILE_SYNCHRONOUS_IO_NONALERT,
; 2861 : 		NULL,
; 2862 : 		0);

  0000a	83 60 a8 00	 and	 DWORD PTR [rax-88], 0
  0000e	48 83 60 a0 00	 and	 QWORD PTR [rax-96], 0
  00013	48 83 60 d0 00	 and	 QWORD PTR [rax-48], 0
  00018	48 83 60 e8 00	 and	 QWORD PTR [rax-24], 0
  0001d	48 83 60 f0 00	 and	 QWORD PTR [rax-16], 0
  00022	c7 40 98 20 00
	00 00		 mov	 DWORD PTR [rax-104], 32	; 00000020H
  00029	c7 40 90 01 00
	00 00		 mov	 DWORD PTR [rax-112], 1
  00030	c7 40 88 07 00
	00 00		 mov	 DWORD PTR [rax-120], 7
  00037	48 89 48 d8	 mov	 QWORD PTR [rax-40], rcx
  0003b	c7 40 80 80 00
	00 00		 mov	 DWORD PTR [rax-128], 128 ; 00000080H
  00042	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00048	4c 8d 48 b8	 lea	 r9, QWORD PTR [rax-72]
  0004c	4c 8d 40 c8	 lea	 r8, QWORD PTR [rax-56]
  00050	48 8d 48 08	 lea	 rcx, QWORD PTR [rax+8]
  00054	ba 00 00 00 c0	 mov	 edx, -1073741824	; c0000000H
  00059	c7 40 c8 30 00
	00 00		 mov	 DWORD PTR [rax-56], 48	; 00000030H
  00060	c7 40 e0 40 06
	00 00		 mov	 DWORD PTR [rax-32], 1600 ; 00000640H
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwCreateFile

; 2863 : 
; 2864 : 	if (NT_SUCCESS (status))

  0006d	85 c0		 test	 eax, eax
  0006f	78 15		 js	 SHORT $LN1@IsAccessib

; 2865 : 	{
; 2866 : 		ZwClose (fileHandle);

  00071	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR fileHandle$[rsp]
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 2867 : 		return TRUE;

  0007f	b8 01 00 00 00	 mov	 eax, 1
  00084	eb 02		 jmp	 SHORT $LN2@IsAccessib
$LN1@IsAccessib:

; 2868 : 	}
; 2869 : 
; 2870 : 	return FALSE;

  00086	33 c0		 xor	 eax, eax
$LN2@IsAccessib:

; 2871 : }

  00088	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0008f	c3		 ret	 0
IsAccessibleByUser ENDP
_TEXT	ENDS
PUBLIC	GetIntersection
; Function compile flags: /Ogspy
;	COMDAT GetIntersection
_TEXT	SEGMENT
start1$ = 8
length1$ = 16
start2$ = 24
end2$ = 32
intersectStart$ = 40
intersectLength$ = 48
GetIntersection PROC					; COMDAT

; 2830 : 	uint64 end1 = start1 + length1 - 1;

  00000	8b c2		 mov	 eax, edx
  00002	48 8d 54 08 ff	 lea	 rdx, QWORD PTR [rax+rcx-1]

; 2831 : 	uint64 intersectEnd = (end1 <= end2) ? end1 : end2;

  00007	49 3b d1	 cmp	 rdx, r9
  0000a	4c 0f 46 ca	 cmovbe	 r9, rdx

; 2832 : 	
; 2833 : 	*intersectStart = (start1 >= start2) ? start1 : start2;

  0000e	48 8b 54 24 28	 mov	 rdx, QWORD PTR intersectStart$[rsp]
  00013	49 3b c8	 cmp	 rcx, r8
  00016	4c 0f 43 c1	 cmovae	 r8, rcx
  0001a	4c 89 02	 mov	 QWORD PTR [rdx], r8

; 2834 : 	*intersectLength = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);

  0001d	4d 3b c1	 cmp	 r8, r9
  00020	76 05		 jbe	 SHORT $LN4@GetInterse
  00022	45 33 c9	 xor	 r9d, r9d
  00025	eb 06		 jmp	 SHORT $LN5@GetInterse
$LN4@GetInterse:
  00027	4d 2b c8	 sub	 r9, r8
  0002a	49 ff c1	 inc	 r9
$LN5@GetInterse:
  0002d	48 8b 44 24 30	 mov	 rax, QWORD PTR intersectLength$[rsp]
  00032	44 89 08	 mov	 DWORD PTR [rax], r9d

; 2835 : 	
; 2836 : 	if (*intersectLength == 0)

  00035	45 85 c9	 test	 r9d, r9d
  00038	75 03		 jne	 SHORT $LN1@GetInterse

; 2837 : 		*intersectStart = start1;

  0003a	48 89 0a	 mov	 QWORD PTR [rdx], rcx
$LN1@GetInterse:

; 2838 : }

  0003d	c3		 ret	 0
GetIntersection ENDP
_TEXT	ENDS
PUBLIC	RegionsOverlap
; Function compile flags: /Ogspy
;	COMDAT RegionsOverlap
_TEXT	SEGMENT
start1$ = 8
end1$ = 16
start2$ = 24
end2$ = 32
RegionsOverlap PROC					; COMDAT

; 2824 : 	return (start1 < start2) ? (end1 >= start2) : (start1 <= end2);

  00000	33 c0		 xor	 eax, eax
  00002	49 3b d0	 cmp	 rdx, r8
  00005	44 8b d0	 mov	 r10d, eax
  00008	41 0f 93 c2	 setae	 r10b
  0000c	49 3b c9	 cmp	 rcx, r9
  0000f	0f 96 c0	 setbe	 al
  00012	49 3b c8	 cmp	 rcx, r8
  00015	41 0f 42 c2	 cmovb	 eax, r10d

; 2825 : }

  00019	c3		 ret	 0
RegionsOverlap ENDP
_TEXT	ENDS
PUBLIC	SymbolicLinkToTarget
;	COMDAT pdata
pdata	SEGMENT
$pdata$SymbolicLinkToTarget DD imagerel $LN4
	DD	imagerel $LN4+195
	DD	imagerel $unwind$SymbolicLinkToTarget
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SymbolicLinkToTarget DD 060f01H
	DD	011640fH
	DD	010340fH
	DD	0700bd20fH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT SymbolicLinkToTarget
_TEXT	SEGMENT
target$32692 = 32
fullFileName$ = 48
objectAttributes$ = 64
symlinkName$ = 128
targetName$ = 136
maxTargetNameLength$ = 144
handle$ = 152
SymbolicLinkToTarget PROC				; COMDAT

; 2793 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8b fa	 mov	 rdi, rdx

; 2794 : 	NTSTATUS ntStatus;
; 2795 : 	OBJECT_ATTRIBUTES objectAttributes;
; 2796 : 	UNICODE_STRING fullFileName;
; 2797 : 	HANDLE handle;
; 2798 : 
; 2799 : 	RtlInitUnicodeString (&fullFileName, symlinkName);

  00012	48 8b d1	 mov	 rdx, rcx
  00015	48 8d 4c 24 30	 lea	 rcx, QWORD PTR fullFileName$[rsp]
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2800 : 	InitializeObjectAttributes (&objectAttributes, &fullFileName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

  00020	33 f6		 xor	 esi, esi
  00022	48 8d 44 24 30	 lea	 rax, QWORD PTR fullFileName$[rsp]

; 2801 : 
; 2802 : 	ntStatus = ZwOpenSymbolicLinkObject (&handle, GENERIC_READ, &objectAttributes);

  00027	4c 8d 44 24 40	 lea	 r8, QWORD PTR objectAttributes$[rsp]
  0002c	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR handle$[rsp]
  00034	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  00039	48 89 44 24 50	 mov	 QWORD PTR objectAttributes$[rsp+16], rax
  0003e	c7 44 24 40 30
	00 00 00	 mov	 DWORD PTR objectAttributes$[rsp], 48 ; 00000030H
  00046	48 89 74 24 48	 mov	 QWORD PTR objectAttributes$[rsp+8], rsi
  0004b	c7 44 24 58 40
	02 00 00	 mov	 DWORD PTR objectAttributes$[rsp+24], 576 ; 00000240H
  00053	48 89 74 24 60	 mov	 QWORD PTR objectAttributes$[rsp+32], rsi
  00058	48 89 74 24 68	 mov	 QWORD PTR objectAttributes$[rsp+40], rsi
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwOpenSymbolicLinkObject

; 2803 : 
; 2804 : 	if (NT_SUCCESS (ntStatus))

  00063	3b c6		 cmp	 eax, esi
  00065	8b d8		 mov	 ebx, eax
  00067	7c 46		 jl	 SHORT $LN1@SymbolicLi

; 2805 : 	{
; 2806 : 		UNICODE_STRING target;
; 2807 : 		target.Buffer = targetName;
; 2808 : 		target.Length = 0;
; 2809 : 		target.MaximumLength = maxTargetNameLength;

  00069	41 b8 08 02 00
	00		 mov	 r8d, 520		; 00000208H

; 2810 : 		memset (targetName, 0, maxTargetNameLength);

  0006f	33 d2		 xor	 edx, edx
  00071	48 8b cf	 mov	 rcx, rdi
  00074	48 89 7c 24 28	 mov	 QWORD PTR target$32692[rsp+8], rdi
  00079	66 89 74 24 20	 mov	 WORD PTR target$32692[rsp], si
  0007e	66 44 89 44 24
	22		 mov	 WORD PTR target$32692[rsp+2], r8w
  00084	e8 00 00 00 00	 call	 memset

; 2811 : 
; 2812 : 		ntStatus = ZwQuerySymbolicLinkObject (handle, &target, NULL);

  00089	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR handle$[rsp]
  00091	48 8d 54 24 20	 lea	 rdx, QWORD PTR target$32692[rsp]
  00096	45 33 c0	 xor	 r8d, r8d
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwQuerySymbolicLinkObject

; 2813 : 
; 2814 : 		ZwClose (handle);

  0009f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR handle$[rsp]
  000a7	8b d8		 mov	 ebx, eax
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
$LN1@SymbolicLi:

; 2815 : 	}
; 2816 : 
; 2817 : 	return ntStatus;
; 2818 : }

  000af	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  000b4	8b c3		 mov	 eax, ebx
  000b6	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  000ba	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  000be	49 8b e3	 mov	 rsp, r11
  000c1	5f		 pop	 rdi
  000c2	c3		 ret	 0
SymbolicLinkToTarget ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCReadWriteDevice DD imagerel TCReadWriteDevice
	DD	imagerel TCReadWriteDevice+213
	DD	imagerel $unwind$TCReadWriteDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCReadWriteDevice DD 061401H
	DD	0116414H
	DD	0103414H
	DD	07010d214H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT TCReadWriteDevice
_TEXT	SEGMENT
ioStatusBlock$ = 64
completionEvent$ = 80
write$ = 128
deviceObject$ = 136
buffer$ = 144
offset$ = 152
length$ = 160
TCReadWriteDevice PROC					; COMDAT

; 2340 : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0000b	4c 89 48 20	 mov	 QWORD PTR [rax+32], r9
  0000f	57		 push	 rdi
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	8b d9		 mov	 ebx, ecx
  00016	49 8b f8	 mov	 rdi, r8
  00019	48 8b f2	 mov	 rsi, rdx

; 2341 : 	NTSTATUS status;
; 2342 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2343 : 	PIRP irp;
; 2344 : 	KEVENT completionEvent;
; 2345 : 
; 2346 : 	ASSERT (KeGetCurrentIrql() <= APC_LEVEL);
; 2347 : 
; 2348 : 	KeInitializeEvent (&completionEvent, NotificationEvent, FALSE);

  0001c	48 8d 48 d8	 lea	 rcx, QWORD PTR [rax-40]
  00020	45 33 c0	 xor	 r8d, r8d
  00023	33 d2		 xor	 edx, edx
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 2349 : 	irp = IoBuildSynchronousFsdRequest (write ? IRP_MJ_WRITE : IRP_MJ_READ, deviceObject, buffer, length, &offset, &completionEvent, &ioStatusBlock);

  0002b	44 8b 8c 24 a0
	00 00 00	 mov	 r9d, DWORD PTR length$[rsp]
  00033	48 8d 44 24 40	 lea	 rax, QWORD PTR ioStatusBlock$[rsp]
  00038	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0003d	48 8d 44 24 50	 lea	 rax, QWORD PTR completionEvent$[rsp]
  00042	f7 db		 neg	 ebx
  00044	1b c9		 sbb	 ecx, ecx
  00046	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0004b	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR offset$[rsp]
  00053	f7 d9		 neg	 ecx
  00055	4c 8b c7	 mov	 r8, rdi
  00058	48 8b d6	 mov	 rdx, rsi
  0005b	83 c1 03	 add	 ecx, 3
  0005e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoBuildSynchronousFsdRequest
  00069	48 8b d8	 mov	 rbx, rax

; 2350 : 	if (!irp)

  0006c	48 85 c0	 test	 rax, rax
  0006f	75 07		 jne	 SHORT $LN3@TCReadWrit

; 2351 : 		return STATUS_INSUFFICIENT_RESOURCES;

  00071	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  00076	eb 4b		 jmp	 SHORT $LN4@TCReadWrit
$LN3@TCReadWrit:

; 2352 : 
; 2353 : 	ObReferenceObject (deviceObject);

  00078	48 8b ce	 mov	 rcx, rsi
  0007b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfReferenceObject

; 2354 : 	status = IoCallDriver (deviceObject, irp);

  00081	48 8b d3	 mov	 rdx, rbx
  00084	48 8b ce	 mov	 rcx, rsi
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCallDriver
  0008d	8b d8		 mov	 ebx, eax

; 2355 : 
; 2356 : 	if (status == STATUS_PENDING)

  0008f	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  00094	75 22		 jne	 SHORT $LN1@TCReadWrit

; 2357 : 	{
; 2358 : 		status = KeWaitForSingleObject (&completionEvent, Executive, KernelMode, FALSE, NULL);

  00096	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  0009c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR completionEvent$[rsp]
  000a1	45 33 c9	 xor	 r9d, r9d
  000a4	45 33 c0	 xor	 r8d, r8d
  000a7	33 d2		 xor	 edx, edx
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  000af	8b d8		 mov	 ebx, eax

; 2359 : 		if (NT_SUCCESS (status))

  000b1	85 c0		 test	 eax, eax
  000b3	0f 49 5c 24 40	 cmovns	 ebx, DWORD PTR ioStatusBlock$[rsp]
$LN1@TCReadWrit:

; 2360 : 			status = ioStatusBlock.Status;
; 2361 : 	}
; 2362 : 
; 2363 : 	ObDereferenceObject (deviceObject);

  000b8	48 8b ce	 mov	 rcx, rsi
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 2364 : 	return status;

  000c1	8b c3		 mov	 eax, ebx
$LN4@TCReadWrit:

; 2365 : }

  000c3	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  000c8	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  000cc	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  000d0	49 8b e3	 mov	 rsp, r11
  000d3	5f		 pop	 rdi
  000d4	c3		 ret	 0
TCReadWriteDevice ENDP
_TEXT	ENDS
PUBLIC	TCCloseFsVolume
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCCloseFsVolume DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$TCCloseFsVolume
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCCloseFsVolume DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT TCCloseFsVolume
_TEXT	SEGMENT
volumeHandle$ = 48
fileObject$ = 56
TCCloseFsVolume PROC					; COMDAT

; 2333 : {

$LN3:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 2334 : 	ObDereferenceObject (fileObject);

  00009	48 8b ca	 mov	 rcx, rdx
  0000c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 2335 : 	ZwClose (volumeHandle);

  00012	48 8b cb	 mov	 rcx, rbx

; 2336 : }

  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5b		 pop	 rbx
  0001a	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_ZwClose
TCCloseFsVolume ENDP
_TEXT	ENDS
PUBLIC	SendDeviceIoControlRequest
;	COMDAT pdata
pdata	SEGMENT
$pdata$SendDeviceIoControlRequestWorkItemRoutine DD imagerel SendDeviceIoControlRequestWorkItemRoutine
	DD	imagerel SendDeviceIoControlRequestWorkItemRoutine+68
	DD	imagerel $unwind$SendDeviceIoControlRequestWorkItemRoutine
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SendDeviceIoControlRequestWorkItemRoutine DD 020601H
	DD	030025206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT SendDeviceIoControlRequestWorkItemRoutine
_TEXT	SEGMENT
rootDeviceObject$ = 64
arg$ = 72
SendDeviceIoControlRequestWorkItemRoutine PROC		; COMDAT

; 2178 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2179 : 	arg->Status = SendDeviceIoControlRequest (arg->deviceObject, arg->ioControlCode, arg->inputBuffer, arg->inputBufferSize, arg->outputBuffer, arg->outputBufferSize);

  00006	8b 42 28	 mov	 eax, DWORD PTR [rdx+40]
  00009	44 8b 4a 18	 mov	 r9d, DWORD PTR [rdx+24]
  0000d	4c 8b 42 10	 mov	 r8, QWORD PTR [rdx+16]
  00011	48 8b da	 mov	 rbx, rdx
  00014	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00018	48 8b 42 20	 mov	 rax, QWORD PTR [rdx+32]
  0001c	8b 52 08	 mov	 edx, DWORD PTR [rdx+8]
  0001f	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00022	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00027	e8 00 00 00 00	 call	 SendDeviceIoControlRequest

; 2180 : 	KeSetEvent (&arg->WorkItemCompletedEvent, IO_NO_INCREMENT, FALSE);

  0002c	48 8d 4b 30	 lea	 rcx, QWORD PTR [rbx+48]
  00030	45 33 c0	 xor	 r8d, r8d
  00033	33 d2		 xor	 edx, edx
  00035	89 43 2c	 mov	 DWORD PTR [rbx+44], eax

; 2181 : }

  00038	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003c	5b		 pop	 rbx
  0003d	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_KeSetEvent
SendDeviceIoControlRequestWorkItemRoutine ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	TCGetDosNameFromNumber
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCGetDosNameFromNumber DD imagerel $LN6
	DD	imagerel $LN6+133
	DD	imagerel $unwind$TCGetDosNameFromNumber
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCGetDosNameFromNumber DD 021519H
	DD	070021206H
	DD	imagerel __GSHandlerCheck
	DD	08H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT TCGetDosNameFromNumber
_TEXT	SEGMENT
tmp$ = 0
__$ArrayPad$ = 8
dosname$ = 32
nDriveNo$ = 40
TCGetDosNameFromNumber PROC				; COMDAT

; 1855 : {

$LN6:
  00000	40 57		 push	 rdi
  00002	48 83 ec 10	 sub	 rsp, 16
  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000d	48 33 c4	 xor	 rax, rsp
  00010	48 89 44 24 08	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1856 : 	WCHAR tmp[3] =
; 1857 : 	{0, ':', 0};
; 1858 : 	int j = nDriveNo + (WCHAR) 'A';

  00015	66 83 c2 41	 add	 dx, 65			; 00000041H
  00019	48 8b f9	 mov	 rdi, rcx
  0001c	45 33 c0	 xor	 r8d, r8d

; 1859 : 
; 1860 : 	tmp[0] = (short) j;

  0001f	66 89 14 24	 mov	 WORD PTR tmp$[rsp], dx

; 1861 : 	wcscpy (dosname, (LPWSTR) DOS_MOUNT_PREFIX);

  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@FNODOBFM@
  0002a	b8 3a 00 00 00	 mov	 eax, 58			; 0000003aH
  0002f	48 8b d7	 mov	 rdx, rdi
  00032	66 44 89 44 24
	04		 mov	 WORD PTR tmp$[rsp+4], r8w
  00038	66 89 44 24 02	 mov	 WORD PTR tmp$[rsp+2], ax
  0003d	48 2b d1	 sub	 rdx, rcx
$LL3@TCGetDosNa:
  00040	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00043	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00047	48 83 c1 02	 add	 rcx, 2
  0004b	66 41 3b c0	 cmp	 ax, r8w
  0004f	75 ef		 jne	 SHORT $LL3@TCGetDosNa

; 1862 : 	wcscat (dosname, tmp);

  00051	33 c0		 xor	 eax, eax
  00053	48 83 c9 ff	 or	 rcx, -1
  00057	48 8d 14 24	 lea	 rdx, QWORD PTR tmp$[rsp]
  0005b	66 f2 af	 repne scasw
  0005e	33 c9		 xor	 ecx, ecx
$LL5@TCGetDosNa:
  00060	0f b7 04 0a	 movzx	 eax, WORD PTR [rdx+rcx]
  00064	48 83 c1 02	 add	 rcx, 2
  00068	66 89 44 0f fc	 mov	 WORD PTR [rdi+rcx-4], ax
  0006d	66 85 c0	 test	 ax, ax
  00070	75 ee		 jne	 SHORT $LL5@TCGetDosNa

; 1863 : }

  00072	48 8b 4c 24 08	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00077	48 33 cc	 xor	 rcx, rsp
  0007a	e8 00 00 00 00	 call	 __security_check_cookie
  0007f	48 83 c4 10	 add	 rsp, 16
  00083	5f		 pop	 rdi
  00084	c3		 ret	 0
TCGetDosNameFromNumber ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	TCGetNTNameFromNumber
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCGetNTNameFromNumber DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$TCGetNTNameFromNumber
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCGetNTNameFromNumber DD 011319H
	DD	06204H
	DD	imagerel __GSHandlerCheck
	DD	028H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT TCGetNTNameFromNumber
_TEXT	SEGMENT
tmp$ = 32
__$ArrayPad$ = 40
ntname$ = 64
nDriveNo$ = 72
TCGetNTNameFromNumber PROC				; COMDAT

; 1844 : {

$LN5:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000b	48 33 c4	 xor	 rax, rsp
  0000e	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1845 : 	WCHAR tmp[3] =
; 1846 : 	{0, ':', 0};
; 1847 : 	int j = nDriveNo + (WCHAR) 'A';

  00013	66 83 c2 41	 add	 dx, 65			; 00000041H
  00017	45 33 c9	 xor	 r9d, r9d
  0001a	b8 3a 00 00 00	 mov	 eax, 58			; 0000003aH

; 1848 : 
; 1849 : 	tmp[0] = (short) j;

  0001f	66 89 54 24 20	 mov	 WORD PTR tmp$[rsp], dx

; 1850 : 	wcscpy (ntname, (LPWSTR) NT_MOUNT_PREFIX);

  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@GMJGMIMP@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@FNODOBFM@
  0002b	4c 8b c1	 mov	 r8, rcx
  0002e	66 89 44 24 22	 mov	 WORD PTR tmp$[rsp+2], ax
  00033	66 44 89 4c 24
	24		 mov	 WORD PTR tmp$[rsp+4], r9w
  00039	4c 2b c2	 sub	 r8, rdx
$LL3@TCGetNTNam:
  0003c	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  0003f	66 41 89 04 10	 mov	 WORD PTR [r8+rdx], ax
  00044	48 83 c2 02	 add	 rdx, 2
  00048	66 41 3b c1	 cmp	 ax, r9w
  0004c	75 ee		 jne	 SHORT $LL3@TCGetNTNam

; 1851 : 	wcsncat (ntname, tmp, 1);

  0004e	48 8d 54 24 20	 lea	 rdx, QWORD PTR tmp$[rsp]
  00053	41 b8 01 00 00
	00		 mov	 r8d, 1
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncat

; 1852 : }

  0005f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00064	48 33 cc	 xor	 rcx, rsp
  00067	e8 00 00 00 00	 call	 __security_check_cookie
  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
TCGetNTNameFromNumber ENDP
_TEXT	ENDS
PUBLIC	TCSleep
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCSleep DD imagerel $LN4
	DD	imagerel $LN4+124
	DD	imagerel $unwind$TCSleep
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCSleep DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT TCSleep
_TEXT	SEGMENT
milliSeconds$ = 64
TCSleep	PROC						; COMDAT

; 1719 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 63 d9	 movsxd	 rbx, ecx

; 1720 : 	PKTIMER timer = (PKTIMER) TCalloc (sizeof (KTIMER));

  0000d	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00012	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  00018	33 c9		 xor	 ecx, ecx
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00020	48 8b f8	 mov	 rdi, rax

; 1721 : 	LARGE_INTEGER duetime;
; 1722 : 
; 1723 : 	if (!timer)

  00023	48 85 c0	 test	 rax, rax
  00026	74 49		 je	 SHORT $LN2@TCSleep

; 1724 : 		return;
; 1725 : 
; 1726 : 	duetime.QuadPart = (__int64) milliSeconds * -10000;
; 1727 : 	KeInitializeTimerEx(timer, NotificationTimer);

  00028	33 d2		 xor	 edx, edx
  0002a	48 8b c8	 mov	 rcx, rax
  0002d	48 69 db f0 d8
	ff ff		 imul	 rbx, -10000		; ffffffffffffd8f0H
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeTimerEx

; 1728 : 	KeSetTimerEx(timer, duetime, 0, NULL);

  0003a	45 33 c9	 xor	 r9d, r9d
  0003d	45 33 c0	 xor	 r8d, r8d
  00040	48 8b d3	 mov	 rdx, rbx
  00043	48 8b cf	 mov	 rcx, rdi
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetTimerEx

; 1729 : 
; 1730 : 	KeWaitForSingleObject (timer, Executive, KernelMode, FALSE, NULL);

  0004c	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00052	45 33 c9	 xor	 r9d, r9d
  00055	45 33 c0	 xor	 r8d, r8d
  00058	33 d2		 xor	 edx, edx
  0005a	48 8b cf	 mov	 rcx, rdi
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 1731 : 
; 1732 : 	TCfree (timer);

  00063	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00068	48 8b cf	 mov	 rcx, rdi
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN2@TCSleep:

; 1733 : }

  00071	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00076	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007a	5f		 pop	 rdi
  0007b	c3		 ret	 0
TCSleep	ENDP
_TEXT	ENDS
PUBLIC	TCStopVolumeThread
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCStopVolumeThread DD imagerel $LN4
	DD	imagerel $LN4+79
	DD	imagerel $unwind$TCStopVolumeThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCStopVolumeThread DD 020601H
	DD	030025206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT TCStopVolumeThread
_TEXT	SEGMENT
DeviceObject$ = 64
Extension$ = 72
TCStopVolumeThread PROC					; COMDAT

; 1688 : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1689 : 	NTSTATUS ntStatus;
; 1690 : 
; 1691 : 	if (DeviceObject);	/* Remove compiler warning */
; 1692 : 
; 1693 : 	Dump ("Signalling thread to quit...\n");
; 1694 : 
; 1695 : 	Extension->bThreadShouldQuit = TRUE;

  00006	41 b8 01 00 00
	00		 mov	 r8d, 1

; 1696 : 
; 1697 : 	KeReleaseSemaphore (&Extension->RequestSemaphore,
; 1698 : 			    0,
; 1699 : 			    1,
; 1700 : 			    TRUE);

  0000c	48 8d 4a 58	 lea	 rcx, QWORD PTR [rdx+88]
  00010	48 8b da	 mov	 rbx, rdx
  00013	44 89 42 1c	 mov	 DWORD PTR [rdx+28], r8d
  00017	33 d2		 xor	 edx, edx
  00019	45 8a c8	 mov	 r9b, r8b
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseSemaphore

; 1701 : 
; 1702 : 	ntStatus = KeWaitForSingleObject (Extension->peThread,
; 1703 : 					  Executive,
; 1704 : 					  KernelMode,
; 1705 : 					  FALSE,
; 1706 : 					  NULL);

  00022	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00026	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  0002c	45 33 c9	 xor	 r9d, r9d
  0002f	45 33 c0	 xor	 r8d, r8d
  00032	33 d2		 xor	 edx, edx
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 1707 : 
; 1708 : 	ASSERT (NT_SUCCESS (ntStatus));
; 1709 : 
; 1710 : 	ObDereferenceObject (Extension->peThread);

  0003a	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 1711 : 	Extension->peThread = NULL;

  00044	48 83 63 20 00	 and	 QWORD PTR [rbx+32], 0

; 1712 : 
; 1713 : 	Dump ("Thread exited\n");
; 1714 : }

  00049	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004d	5b		 pop	 rbx
  0004e	c3		 ret	 0
TCStopVolumeThread ENDP
_TEXT	ENDS
PUBLIC	TCStopThread
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCStopThread DD imagerel $LN4
	DD	imagerel $LN4+69
	DD	imagerel $unwind$TCStopThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCStopThread DD 020601H
	DD	030025206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT TCStopThread
_TEXT	SEGMENT
kThread$ = 64
wakeUpEvent$ = 72
TCStopThread PROC					; COMDAT

; 1601 : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 1602 : 	if (wakeUpEvent)

  0000c	48 85 d2	 test	 rdx, rdx
  0000f	74 0e		 je	 SHORT $LN1@TCStopThre

; 1603 : 		KeSetEvent (wakeUpEvent, 0, FALSE);

  00011	45 33 c0	 xor	 r8d, r8d
  00014	33 d2		 xor	 edx, edx
  00016	48 8b c8	 mov	 rcx, rax
  00019	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent
$LN1@TCStopThre:

; 1604 : 
; 1605 : 	KeWaitForSingleObject (kThread, Executive, KernelMode, FALSE, NULL);

  0001f	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00025	45 33 c9	 xor	 r9d, r9d
  00028	45 33 c0	 xor	 r8d, r8d
  0002b	33 d2		 xor	 edx, edx
  0002d	48 8b cb	 mov	 rcx, rbx
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 1606 : 	ObDereferenceObject (kThread);

  00036	48 8b cb	 mov	 rcx, rbx

; 1607 : }

  00039	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003d	5b		 pop	 rbx
  0003e	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_ObfDereferenceObject
TCStopThread ENDP
_TEXT	ENDS
PUBLIC	TCStartThreadInProcess
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCStartThreadInProcess DD imagerel $LN8
	DD	imagerel $LN8+212
	DD	imagerel $unwind$TCStartThreadInProcess
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCStartThreadInProcess DD 041301H
	DD	0123413H
	DD	0700cf213H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT TCStartThreadInProcess
_TEXT	SEGMENT
processHandle$ = 64
threadProc$ = 144
threadArg$ = 152
kThread$ = 160
threadHandle$ = 168
process$ = 168
TCStartThreadInProcess PROC				; COMDAT

; 1565 : {

$LN8:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	4c 89 48 20	 mov	 QWORD PTR [rax+32], r9
  0000b	57		 push	 rdi
  0000c	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 1566 : 	NTSTATUS status;
; 1567 : 	HANDLE threadHandle;
; 1568 : 	HANDLE processHandle = NULL;

  00013	48 83 60 b8 00	 and	 QWORD PTR [rax-72], 0

; 1569 : 	OBJECT_ATTRIBUTES threadObjAttributes;
; 1570 : 
; 1571 : 	if (process)
; 1572 : 	{
; 1573 : 		status = ObOpenObjectByPointer (process, OBJ_KERNEL_HANDLE, NULL, 0, NULL, KernelMode, &processHandle);
; 1574 : 		if (!NT_SUCCESS (status))
; 1575 : 			return status;
; 1576 : 	}
; 1577 : 
; 1578 : 	InitializeObjectAttributes (&threadObjAttributes, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);

  00018	48 83 60 c8 00	 and	 QWORD PTR [rax-56], 0
  0001d	48 83 60 d0 00	 and	 QWORD PTR [rax-48], 0
  00022	48 83 60 e0 00	 and	 QWORD PTR [rax-32], 0
  00027	48 83 60 e8 00	 and	 QWORD PTR [rax-24], 0

; 1579 : 	
; 1580 : 	status = PsCreateSystemThread (&threadHandle, THREAD_ALL_ACCESS, &threadObjAttributes, processHandle, NULL, threadProc, threadArg);

  0002c	48 89 50 a8	 mov	 QWORD PTR [rax-88], rdx
  00030	48 89 48 a0	 mov	 QWORD PTR [rax-96], rcx
  00034	48 83 60 98 00	 and	 QWORD PTR [rax-104], 0
  00039	49 8b f8	 mov	 rdi, r8
  0003c	bb ff 03 1f 00	 mov	 ebx, 2032639		; 001f03ffH
  00041	48 8d 48 20	 lea	 rcx, QWORD PTR [rax+32]
  00045	4c 8d 40 c0	 lea	 r8, QWORD PTR [rax-64]
  00049	45 33 c9	 xor	 r9d, r9d
  0004c	8b d3		 mov	 edx, ebx
  0004e	c7 40 c0 30 00
	00 00		 mov	 DWORD PTR [rax-64], 48	; 00000030H
  00055	c7 40 d8 00 02
	00 00		 mov	 DWORD PTR [rax-40], 512	; 00000200H
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsCreateSystemThread

; 1581 : 	if (!NT_SUCCESS (status))

  00062	85 c0		 test	 eax, eax

; 1582 : 		return status;

  00064	78 5d		 js	 SHORT $LN6@TCStartThr

; 1583 : 
; 1584 : 	status = ObReferenceObjectByHandle (threadHandle, THREAD_ALL_ACCESS, NULL, KernelMode, (PVOID *) kThread, NULL);

  00066	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR threadHandle$[rsp]
  0006e	48 83 64 24 28
	00		 and	 QWORD PTR [rsp+40], 0
  00074	45 33 c9	 xor	 r9d, r9d
  00077	45 33 c0	 xor	 r8d, r8d
  0007a	8b d3		 mov	 edx, ebx
  0007c	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObReferenceObjectByHandle
  00087	8b d8		 mov	 ebx, eax

; 1585 : 	if (!NT_SUCCESS (status))

  00089	85 c0		 test	 eax, eax
  0008b	79 16		 jns	 SHORT $LN2@TCStartThr

; 1586 : 	{
; 1587 : 		ZwClose (threadHandle);

  0008d	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR threadHandle$[rsp]
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 1588 : 		*kThread = NULL;

  0009b	48 83 27 00	 and	 QWORD PTR [rdi], 0

; 1589 : 		return status;

  0009f	8b c3		 mov	 eax, ebx
  000a1	eb 20		 jmp	 SHORT $LN6@TCStartThr
$LN2@TCStartThr:

; 1590 : 	}
; 1591 : 
; 1592 : 	if (processHandle)

  000a3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR processHandle$[rsp]
  000a8	48 85 c9	 test	 rcx, rcx
  000ab	74 06		 je	 SHORT $LN1@TCStartThr

; 1593 : 		ZwClose (processHandle);

  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
$LN1@TCStartThr:

; 1594 : 
; 1595 : 	ZwClose (threadHandle);

  000b3	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR threadHandle$[rsp]
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 1596 : 	return STATUS_SUCCESS;

  000c1	33 c0		 xor	 eax, eax
$LN6@TCStartThr:

; 1597 : }

  000c3	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
  000cb	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  000d2	5f		 pop	 rdi
  000d3	c3		 ret	 0
TCStartThreadInProcess ENDP
_TEXT	ENDS
PUBLIC	TCStartThread
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCStartThread DD imagerel $LN10
	DD	imagerel $LN10+211
	DD	imagerel $unwind$TCStartThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCStartThread DD 040f01H
	DD	012340fH
	DD	07008f20fH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT TCStartThread
_TEXT	SEGMENT
processHandle$46051 = 64
threadProc$ = 144
threadArg$ = 152
kThread$ = 160
threadHandle$46050 = 168
TCStartThread PROC					; COMDAT

; 1559 : {

$LN10:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	57		 push	 rdi
  00008	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 1560 : 	return TCStartThreadInProcess (threadProc, threadArg, kThread, NULL);

  0000f	48 83 60 b8 00	 and	 QWORD PTR [rax-72], 0
  00014	48 83 60 c8 00	 and	 QWORD PTR [rax-56], 0
  00019	48 83 60 d0 00	 and	 QWORD PTR [rax-48], 0
  0001e	48 83 60 e0 00	 and	 QWORD PTR [rax-32], 0
  00023	48 83 60 e8 00	 and	 QWORD PTR [rax-24], 0
  00028	48 89 50 a8	 mov	 QWORD PTR [rax-88], rdx
  0002c	48 89 48 a0	 mov	 QWORD PTR [rax-96], rcx
  00030	48 83 60 98 00	 and	 QWORD PTR [rax-104], 0
  00035	49 8b f8	 mov	 rdi, r8
  00038	48 8d 48 20	 lea	 rcx, QWORD PTR [rax+32]
  0003c	4c 8d 40 c0	 lea	 r8, QWORD PTR [rax-64]
  00040	45 33 c9	 xor	 r9d, r9d
  00043	ba ff 03 1f 00	 mov	 edx, 2032639		; 001f03ffH
  00048	c7 40 c0 30 00
	00 00		 mov	 DWORD PTR [rax-64], 48	; 00000030H
  0004f	c7 40 d8 00 02
	00 00		 mov	 DWORD PTR [rax-40], 512	; 00000200H
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsCreateSystemThread
  0005c	8b d8		 mov	 ebx, eax
  0005e	85 c0		 test	 eax, eax
  00060	78 5e		 js	 SHORT $LN8@TCStartThr@2
  00062	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR threadHandle$46050[rsp]
  0006a	48 83 64 24 28
	00		 and	 QWORD PTR [rsp+40], 0
  00070	45 33 c9	 xor	 r9d, r9d
  00073	45 33 c0	 xor	 r8d, r8d
  00076	ba ff 03 1f 00	 mov	 edx, 2032639		; 001f03ffH
  0007b	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00080	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObReferenceObjectByHandle
  00086	8b d8		 mov	 ebx, eax
  00088	85 c0		 test	 eax, eax
  0008a	79 14		 jns	 SHORT $LN4@TCStartThr@2
  0008c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR threadHandle$46050[rsp]
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
  0009a	48 83 27 00	 and	 QWORD PTR [rdi], 0
  0009e	eb 20		 jmp	 SHORT $LN8@TCStartThr@2
$LN4@TCStartThr@2:
  000a0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR processHandle$46051[rsp]
  000a5	48 85 c9	 test	 rcx, rcx
  000a8	74 06		 je	 SHORT $LN3@TCStartThr@2
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
$LN3@TCStartThr@2:
  000b0	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR threadHandle$46050[rsp]
  000b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
  000be	33 db		 xor	 ebx, ebx
$LN8@TCStartThr@2:
  000c0	8b c3		 mov	 eax, ebx

; 1561 : }

  000c2	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
  000ca	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  000d1	5f		 pop	 rdi
  000d2	c3		 ret	 0
TCStartThread ENDP
_TEXT	ENDS
PUBLIC	RootDeviceControlMutexRelease
RootDeviceControlMutex DB 038H DUP (?)
; Function compile flags: /Ogspy
;	COMDAT RootDeviceControlMutexRelease
_TEXT	SEGMENT
RootDeviceControlMutexRelease PROC			; COMDAT

; 491  : 	KeReleaseMutex (&RootDeviceControlMutex, FALSE);

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:RootDeviceControlMutex
  00007	33 d2		 xor	 edx, edx

; 492  : }

  00009	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_KeReleaseMutex
RootDeviceControlMutexRelease ENDP
_TEXT	ENDS
PUBLIC	RootDeviceControlMutexAcquireNoWait
;	COMDAT pdata
pdata	SEGMENT
$pdata$RootDeviceControlMutexAcquireNoWait DD imagerel $LN5
	DD	imagerel $LN5+68
	DD	imagerel $unwind$RootDeviceControlMutexAcquireNoWait
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RootDeviceControlMutexAcquireNoWait DD 020601H
	DD	030025206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT RootDeviceControlMutexAcquireNoWait
_TEXT	SEGMENT
timeout$ = 64
RootDeviceControlMutexAcquireNoWait PROC		; COMDAT

; 479  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 480  : 	NTSTATUS status;
; 481  : 	LARGE_INTEGER timeout;
; 482  : 	timeout.QuadPart = 0;
; 483  : 
; 484  : 	status = KeWaitForMutexObject (&RootDeviceControlMutex, Executive, KernelMode, FALSE, &timeout);

  00006	48 8d 44 24 40	 lea	 rax, QWORD PTR timeout$[rsp]
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:RootDeviceControlMutex
  00012	33 db		 xor	 ebx, ebx
  00014	45 33 c9	 xor	 r9d, r9d
  00017	45 33 c0	 xor	 r8d, r8d
  0001a	33 d2		 xor	 edx, edx
  0001c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00021	48 89 5c 24 40	 mov	 QWORD PTR timeout$[rsp], rbx
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 485  : 	return NT_SUCCESS (status) && status != STATUS_TIMEOUT;

  0002c	3b c3		 cmp	 eax, ebx
  0002e	7c 0c		 jl	 SHORT $LN4@RootDevice
  00030	3d 02 01 00 00	 cmp	 eax, 258		; 00000102H
  00035	74 05		 je	 SHORT $LN4@RootDevice
  00037	bb 01 00 00 00	 mov	 ebx, 1
$LN4@RootDevice:
  0003c	8b c3		 mov	 eax, ebx

; 486  : }

  0003e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00042	5b		 pop	 rbx
  00043	c3		 ret	 0
RootDeviceControlMutexAcquireNoWait ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	TCCreateRootDeviceObject
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCCreateRootDeviceObject DD imagerel $LN9
	DD	imagerel $LN9+323
	DD	imagerel $unwind$TCCreateRootDeviceObject
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCCreateRootDeviceObject DD 051f19H
	DD	023340dH
	DD	020010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	0f0H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT TCCreateRootDeviceObject
INIT	SEGMENT
DeviceObject$ = 64
ntUnicodeString$ = 72
Win32NameString$ = 88
ntname$ = 112
dosname$ = 176
__$ArrayPad$ = 240
DriverObject$ = 272
TCCreateRootDeviceObject PROC				; COMDAT

; 354  : {

$LN9:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 81 ec 00 01
	00 00		 sub	 rsp, 256		; 00000100H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 355  : 	UNICODE_STRING Win32NameString, ntUnicodeString;
; 356  : 	WCHAR dosname[32], ntname[32];
; 357  : 	PDEVICE_OBJECT DeviceObject;
; 358  : 	NTSTATUS ntStatus;
; 359  : 	BOOL *bRootExtension;
; 360  : 
; 361  : 	Dump ("TCCreateRootDeviceObject BEGIN\n");
; 362  : 	ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);
; 363  : 
; 364  : 	wcscpy (dosname, (LPWSTR) DOS_ROOT_PREFIX);

  0001f	33 ff		 xor	 edi, edi
  00021	48 8b d9	 mov	 rbx, rcx
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  0002b	48 8b cf	 mov	 rcx, rdi
$LL5@TCCreateRo@2:
  0002e	0f b7 84 11 00
	00 00 00	 movzx	 eax, WORD PTR ??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@[rcx+rdx]
  00036	48 83 c1 02	 add	 rcx, 2
  0003a	66 89 84 0c ae
	00 00 00	 mov	 WORD PTR dosname$[rsp+rcx-2], ax
  00042	66 3b c7	 cmp	 ax, di
  00045	75 e7		 jne	 SHORT $LL5@TCCreateRo@2

; 365  : 	wcscpy (ntname, (LPWSTR) NT_ROOT_PREFIX);

  00047	48 8b cf	 mov	 rcx, rdi
$LL6@TCCreateRo@2:
  0004a	0f b7 84 11 00
	00 00 00	 movzx	 eax, WORD PTR ??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@[rcx+rdx]
  00052	48 83 c1 02	 add	 rcx, 2
  00056	66 89 44 0c 6e	 mov	 WORD PTR ntname$[rsp+rcx-2], ax
  0005b	66 3b c7	 cmp	 ax, di
  0005e	75 ea		 jne	 SHORT $LL6@TCCreateRo@2

; 366  : 	RtlInitUnicodeString (&ntUnicodeString, ntname);

  00060	48 8d 54 24 70	 lea	 rdx, QWORD PTR ntname$[rsp]
  00065	48 8d 4c 24 48	 lea	 rcx, QWORD PTR ntUnicodeString$[rsp]
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 367  : 	RtlInitUnicodeString (&Win32NameString, dosname);

  00070	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR dosname$[rsp]
  00078	48 8d 4c 24 58	 lea	 rcx, QWORD PTR Win32NameString$[rsp]
  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 368  : 
; 369  : 	Dump ("Creating root device nt=%ls dos=%ls\n", ntname, dosname);
; 370  : 	
; 371  : 	ntStatus = IoCreateDevice (
; 372  : 					  DriverObject,
; 373  : 					  sizeof (BOOL),
; 374  : 					  &ntUnicodeString,
; 375  : 					  FILE_DEVICE_UNKNOWN,
; 376  : 					  FILE_DEVICE_SECURE_OPEN,
; 377  : 					  FALSE,
; 378  : 					  &DeviceObject);

  00083	41 b9 22 00 00
	00		 mov	 r9d, 34			; 00000022H
  00089	4c 8d 5c 24 40	 lea	 r11, QWORD PTR DeviceObject$[rsp]
  0008e	4c 89 5c 24 30	 mov	 QWORD PTR [rsp+48], r11
  00093	4c 8d 44 24 48	 lea	 r8, QWORD PTR ntUnicodeString$[rsp]
  00098	41 8d 51 e2	 lea	 edx, QWORD PTR [r9-30]
  0009c	48 8b cb	 mov	 rcx, rbx
  0009f	40 88 7c 24 28	 mov	 BYTE PTR [rsp+40], dil
  000a4	c7 44 24 20 00
	01 00 00	 mov	 DWORD PTR [rsp+32], 256	; 00000100H
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateDevice

; 379  : 
; 380  : 	if (!NT_SUCCESS (ntStatus))

  000b2	3b c7		 cmp	 eax, edi

; 381  : 	{
; 382  : 		Dump ("TCCreateRootDeviceObject NTSTATUS = 0x%08x END\n", ntStatus);
; 383  : 		return ntStatus;/* Failed to create DeviceObject */

  000b4	7c 6c		 jl	 SHORT $LN3@TCCreateRo@2

; 384  : 	}
; 385  : 
; 386  : 	DeviceObject->Flags |= DO_DIRECT_IO;

  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR DeviceObject$[rsp]

; 387  : 	DeviceObject->AlignmentRequirement = FILE_WORD_ALIGNMENT;

  000bb	ba 01 00 00 00	 mov	 edx, 1
  000c0	83 48 30 10	 or	 DWORD PTR [rax+48], 16
  000c4	48 8b 44 24 40	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  000c9	89 90 98 00 00
	00		 mov	 DWORD PTR [rax+152], edx

; 388  : 
; 389  : 	/* Setup the device extension */
; 390  : 	bRootExtension = (BOOL *) DeviceObject->DeviceExtension;

  000cf	48 8b 44 24 40	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  000d4	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]

; 391  : 	*bRootExtension = TRUE;

  000d8	89 11		 mov	 DWORD PTR [rcx], edx

; 392  : 
; 393  : 	KeInitializeMutex (&RootDeviceControlMutex, 0);

  000da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:RootDeviceControlMutex
  000e1	33 d2		 xor	 edx, edx
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeMutex

; 394  : 
; 395  : 	ntStatus = IoCreateSymbolicLink (&Win32NameString, &ntUnicodeString);

  000e9	48 8d 54 24 48	 lea	 rdx, QWORD PTR ntUnicodeString$[rsp]
  000ee	48 8d 4c 24 58	 lea	 rcx, QWORD PTR Win32NameString$[rsp]
  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateSymbolicLink

; 396  : 
; 397  : 	if (!NT_SUCCESS (ntStatus))
; 398  : 	{
; 399  : 		Dump ("TCCreateRootDeviceObject NTSTATUS = 0x%08x END\n", ntStatus);
; 400  : 		IoDeleteDevice (DeviceObject);

  000f9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  000fe	3b c7		 cmp	 eax, edi
  00100	8b d8		 mov	 ebx, eax
  00102	7d 0a		 jge	 SHORT $LN1@TCCreateRo@2
  00104	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteDevice

; 401  : 		return ntStatus;

  0010a	8b c3		 mov	 eax, ebx
  0010c	eb 14		 jmp	 SHORT $LN3@TCCreateRo@2
$LN1@TCCreateRo@2:

; 402  : 	}
; 403  : 
; 404  : 	IoRegisterShutdownNotification (DeviceObject);

  0010e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoRegisterShutdownNotification

; 405  : 	RootDeviceObject = DeviceObject;

  00114	4c 8b 5c 24 40	 mov	 r11, QWORD PTR DeviceObject$[rsp]

; 406  : 
; 407  : 	Dump ("TCCreateRootDeviceObject STATUS_SUCCESS END\n");
; 408  : 	return STATUS_SUCCESS;

  00119	33 c0		 xor	 eax, eax
  0011b	4c 89 1d 00 00
	00 00		 mov	 QWORD PTR RootDeviceObject, r11
$LN3@TCCreateRo@2:

; 409  : }

  00122	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0012a	48 33 cc	 xor	 rcx, rsp
  0012d	e8 00 00 00 00	 call	 __security_check_cookie
  00132	48 8b 9c 24 18
	01 00 00	 mov	 rbx, QWORD PTR [rsp+280]
  0013a	48 81 c4 00 01
	00 00		 add	 rsp, 256		; 00000100H
  00141	5f		 pop	 rdi
  00142	c3		 ret	 0
TCCreateRootDeviceObject ENDP
INIT	ENDS
PUBLIC	GetVirtualVolumeDeviceObject
; Function compile flags: /Ogspy
;	COMDAT GetVirtualVolumeDeviceObject
_TEXT	SEGMENT
driveNumber$ = 8
GetVirtualVolumeDeviceObject PROC			; COMDAT

; 192  : 	if (driveNumber < MIN_MOUNTED_VOLUME_DRIVE_NUMBER || driveNumber > MAX_MOUNTED_VOLUME_DRIVE_NUMBER)

  00000	83 f9 19	 cmp	 ecx, 25
  00003	77 0f		 ja	 SHORT $LN1@GetVirtual

; 194  : 
; 195  : 	return VirtualVolumeDeviceObjects[driveNumber];

  00005	48 63 c1	 movsxd	 rax, ecx
  00008	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:VirtualVolumeDeviceObjects
  0000f	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]

; 196  : }

  00013	c3		 ret	 0
$LN1@GetVirtual:

; 193  : 		return NULL;

  00014	33 c0		 xor	 eax, eax

; 196  : }

  00016	c3		 ret	 0
GetVirtualVolumeDeviceObject ENDP
PUBLIC	ReadRegistryConfigFlags
;	COMDAT pdata
; File c:\home\public\desktop\projects\ciphershed.build\src\common\crypto.c
pdata	SEGMENT
$pdata$ReadRegistryConfigFlags DD imagerel $LN13
	DD	imagerel $LN13+226
	DD	imagerel $unwind$ReadRegistryConfigFlags
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ReadRegistryConfigFlags DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed.build\src\driver\ntdriver.c
xdata	ENDS
;	COMDAT ReadRegistryConfigFlags
_TEXT	SEGMENT
name$ = 32
driverEntry$ = 64
data$ = 72
ReadRegistryConfigFlags PROC				; COMDAT

; 3082 : {

$LN13:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	8b f9		 mov	 edi, ecx

; 3083 : 	PKEY_VALUE_PARTIAL_INFORMATION data;
; 3084 : 	UNICODE_STRING name;
; 3085 : 	NTSTATUS status;
; 3086 : 	uint32 flags = 0;
; 3087 : 
; 3088 : 	RtlInitUnicodeString (&name, L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\truecrypt");

  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1HM@GLBNDPGI@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
  00013	48 8d 4c 24 20	 lea	 rcx, QWORD PTR name$[rsp]
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 3089 : 	status = TCReadRegistryKey (&name, TC_DRIVER_CONFIG_REG_VALUE_NAME, &data);

  0001e	4c 8d 44 24 48	 lea	 r8, QWORD PTR data$[rsp]
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@LGEHFLCO@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@
  0002a	48 8d 4c 24 20	 lea	 rcx, QWORD PTR name$[rsp]
  0002f	e8 00 00 00 00	 call	 TCReadRegistryKey
  00034	8b d8		 mov	 ebx, eax

; 3090 : 
; 3091 : 	if (NT_SUCCESS (status))

  00036	85 c0		 test	 eax, eax
  00038	78 5d		 js	 SHORT $LN8@ReadRegist

; 3092 : 	{
; 3093 : 		if (data->Type == REG_DWORD)

  0003a	4c 8b 44 24 48	 mov	 r8, QWORD PTR data$[rsp]
  0003f	41 83 78 04 04	 cmp	 DWORD PTR [r8+4], 4
  00044	75 3e		 jne	 SHORT $LN7@ReadRegist

; 3094 : 		{
; 3095 : 			flags = *(uint32 *) data->Data;

  00046	41 8b 48 0c	 mov	 ecx, DWORD PTR [r8+12]

; 3096 : 			Dump ("Configuration flags = 0x%x\n", flags);
; 3097 : 
; 3098 : 			if (driverEntry)

  0004a	ba 01 00 00 00	 mov	 edx, 1
  0004f	85 ff		 test	 edi, edi
  00051	74 24		 je	 SHORT $LN4@ReadRegist

; 3099 : 			{
; 3100 : 				if (flags & (TC_DRIVER_CONFIG_CACHE_BOOT_PASSWORD | TC_DRIVER_CONFIG_CACHE_BOOT_PASSWORD_FOR_SYS_FAVORITES))

  00053	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR CacheBootPassword
  00059	f6 c1 03	 test	 cl, 3
  0005c	0f 45 c2	 cmovne	 eax, edx

; 3101 : 					CacheBootPassword = TRUE;
; 3102 : 
; 3103 : 				if (flags & TC_DRIVER_CONFIG_DISABLE_NONADMIN_SYS_FAVORITES_ACCESS)

  0005f	f6 c1 04	 test	 cl, 4
  00062	89 05 00 00 00
	00		 mov	 DWORD PTR CacheBootPassword, eax
  00068	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR NonAdminSystemFavoritesAccessDisabled
  0006e	0f 45 c2	 cmovne	 eax, edx
  00071	89 05 00 00 00
	00		 mov	 DWORD PTR NonAdminSystemFavoritesAccessDisabled, eax
$LN4@ReadRegist:

; 3104 : 					NonAdminSystemFavoritesAccessDisabled = TRUE;
; 3105 : 			}
; 3106 : 
; 3107 : 			EnableHwEncryption ((flags & TC_DRIVER_CONFIG_DISABLE_HARDWARE_ENCRYPTION) ? FALSE : TRUE);

  00077	c1 e9 03	 shr	 ecx, 3
  0007a	23 ca		 and	 ecx, edx
  0007c	89 0d 00 00 00
	00		 mov	 DWORD PTR HwEncryptionDisabled, ecx

; 3108 : 		}
; 3109 : 		else

  00082	eb 05		 jmp	 SHORT $LN3@ReadRegist
$LN7@ReadRegist:

; 3110 : 			status = STATUS_INVALID_PARAMETER;

  00084	bb 0d 00 00 c0	 mov	 ebx, -1073741811	; ffffffffc000000dH
$LN3@ReadRegist:

; 3111 : 
; 3112 : 		TCfree (data);

  00089	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  0008e	49 8b c8	 mov	 rcx, r8
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN8@ReadRegist:

; 3113 : 	}
; 3114 : 
; 3115 : 	if (driverEntry && NT_SUCCESS (TCReadRegistryKey (&name, TC_ENCRYPTION_FREE_CPU_COUNT_REG_VALUE_NAME, &data)))

  00097	85 ff		 test	 edi, edi
  00099	74 3a		 je	 SHORT $LN2@ReadRegist
  0009b	4c 8d 44 24 48	 lea	 r8, QWORD PTR data$[rsp]
  000a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EA@CEOJFLPD@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAE?$AAn?$AAc?$AAr?$AAy?$AAp?$AAt?$AAi?$AAo?$AAn?$AAF?$AAr?$AAe?$AAe?$AAC?$AAp?$AAu?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@FNODOBFM@
  000a7	48 8d 4c 24 20	 lea	 rcx, QWORD PTR name$[rsp]
  000ac	e8 00 00 00 00	 call	 TCReadRegistryKey
  000b1	85 c0		 test	 eax, eax
  000b3	78 20		 js	 SHORT $LN2@ReadRegist

; 3116 : 	{
; 3117 : 		if (data->Type == REG_DWORD)

  000b5	48 8b 4c 24 48	 mov	 rcx, QWORD PTR data$[rsp]
  000ba	83 79 04 04	 cmp	 DWORD PTR [rcx+4], 4
  000be	75 0a		 jne	 SHORT $LN1@ReadRegist

; 3118 : 			EncryptionThreadPoolFreeCpuCountLimit = *(uint32 *) data->Data;

  000c0	8b 41 0c	 mov	 eax, DWORD PTR [rcx+12]
  000c3	48 89 05 00 00
	00 00		 mov	 QWORD PTR EncryptionThreadPoolFreeCpuCountLimit, rax
$LN1@ReadRegist:

; 3119 : 
; 3120 : 		TCfree (data);

  000ca	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  000cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN2@ReadRegist:

; 3121 : 	}
; 3122 : 
; 3123 : 	return status;

  000d5	8b c3		 mov	 eax, ebx

; 3124 : }

  000d7	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000dc	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e0	5f		 pop	 rdi
  000e1	c3		 ret	 0
ReadRegistryConfigFlags ENDP
_TEXT	ENDS
PUBLIC	IsVolumeClassFilterRegistered
;	COMDAT pdata
pdata	SEGMENT
$pdata$IsVolumeClassFilterRegistered DD imagerel $LN14
	DD	imagerel $LN14+175
	DD	imagerel $unwind$IsVolumeClassFilterRegistered
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IsVolumeClassFilterRegistered DD 020601H
	DD	030025206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT IsVolumeClassFilterRegistered
_TEXT	SEGMENT
name$ = 32
data$ = 64
IsVolumeClassFilterRegistered PROC			; COMDAT

; 3040 : {

$LN14:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3041 : 	UNICODE_STRING name;
; 3042 : 	NTSTATUS status;
; 3043 : 	BOOL registered = FALSE;
; 3044 : 
; 3045 : 	PKEY_VALUE_PARTIAL_INFORMATION data;
; 3046 : 
; 3047 : 	/*
; 3048 : 	 * Note: Do not change the "Storage Volumes" guid (System-Defined Device Setup Classes).
; 3049 : 	 * This class includes storage volumes as defined by the system-supplied
; 3050 : 	 * logical volume manager and class drivers that create device objects to
; 3051 : 	 * represent storage volumes, such as the system disk class driver.
; 3052 : 	 * @see	http://msdn.microsoft.com/en-us/library/windows/hardware/ff553426%28v=vs.85%29.aspx
; 3053 : 	 */
; 3054 : 	RtlInitUnicodeString (&name, L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class\\{71A27CDD-812A-11D0-BEC7-08002BE2092F}");

  00006	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1MA@BNNNAGDA@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
  0000d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR name$[rsp]
  00012	33 db		 xor	 ebx, ebx
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 3055 : 	status = TCReadRegistryKey (&name, L"UpperFilters", &data);

  0001a	4c 8d 44 24 40	 lea	 r8, QWORD PTR data$[rsp]
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1BK@FNJCPENK@?$AAU?$AAp?$AAp?$AAe?$AAr?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAs?$AA?$AA@FNODOBFM@
  00026	48 8d 4c 24 20	 lea	 rcx, QWORD PTR name$[rsp]
  0002b	e8 00 00 00 00	 call	 TCReadRegistryKey

; 3056 : 
; 3057 : 	if (NT_SUCCESS (status))

  00030	3b c3		 cmp	 eax, ebx
  00032	7c 73		 jl	 SHORT $LN6@IsVolumeCl

; 3058 : 	{
; 3059 : 		if (data->Type == REG_MULTI_SZ && data->DataLength >= 9 * sizeof (wchar_t))

  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  00039	83 79 04 07	 cmp	 DWORD PTR [rcx+4], 7
  0003d	75 5d		 jne	 SHORT $LN2@IsVolumeCl
  0003f	83 79 08 12	 cmp	 DWORD PTR [rcx+8], 18
  00043	72 57		 jb	 SHORT $LN2@IsVolumeCl

; 3060 : 		{
; 3061 : 			// Search for the string "truecrypt"
; 3062 : 			ULONG i;
; 3063 : 			for (i = 0; i <= data->DataLength - 9 * sizeof (wchar_t); ++i)

  00045	44 8b 51 08	 mov	 r10d, DWORD PTR [rcx+8]
  00049	44 8b cb	 mov	 r9d, ebx
  0004c	48 8b c3	 mov	 rax, rbx
  0004f	49 83 ea 12	 sub	 r10, 18
$LL4@IsVolumeCl:

; 3064 : 			{
; 3065 : 				if (memcmp (data->Data + i, L"truecrypt", 9 * sizeof (wchar_t)) == 0)

  00053	48 8d 44 08 0c	 lea	 rax, QWORD PTR [rax+rcx+12]
  00058	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1BE@OBOIPPHP@?$AAt?$AAr?$AAu?$AAe?$AAc?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
  0005f	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00062	4c 3b 02	 cmp	 r8, QWORD PTR [rdx]
  00065	75 1a		 jne	 SHORT $LN12@IsVolumeCl
  00067	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  0006b	4c 3b 42 08	 cmp	 r8, QWORD PTR [rdx+8]
  0006f	75 10		 jne	 SHORT $LN12@IsVolumeCl
  00071	66 44 8b 40 10	 mov	 r8w, WORD PTR [rax+16]
  00076	66 44 3b 42 10	 cmp	 r8w, WORD PTR [rdx+16]
  0007b	75 04		 jne	 SHORT $LN12@IsVolumeCl
  0007d	8b c3		 mov	 eax, ebx
  0007f	eb 05		 jmp	 SHORT $LN13@IsVolumeCl
$LN12@IsVolumeCl:
  00081	1b c0		 sbb	 eax, eax
  00083	83 d8 ff	 sbb	 eax, -1
$LN13@IsVolumeCl:
  00086	3b c3		 cmp	 eax, ebx
  00088	74 0d		 je	 SHORT $LN10@IsVolumeCl
  0008a	41 ff c1	 inc	 r9d
  0008d	41 8b c1	 mov	 eax, r9d
  00090	49 3b c2	 cmp	 rax, r10
  00093	76 be		 jbe	 SHORT $LL4@IsVolumeCl
  00095	eb 05		 jmp	 SHORT $LN2@IsVolumeCl
$LN10@IsVolumeCl:

; 3066 : 				{
; 3067 : 					Dump ("Volume class filter active\n");
; 3068 : 					registered = TRUE;

  00097	bb 01 00 00 00	 mov	 ebx, 1
$LN2@IsVolumeCl:

; 3069 : 					break;
; 3070 : 				}
; 3071 : 			}
; 3072 : 		}
; 3073 : 
; 3074 : 		TCfree (data);

  0009c	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN6@IsVolumeCl:

; 3075 : 	}
; 3076 : 
; 3077 : 	return registered;

  000a7	8b c3		 mov	 eax, ebx

; 3078 : }

  000a9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ad	5b		 pop	 rbx
  000ae	c3		 ret	 0
IsVolumeClassFilterRegistered ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	IsDriveLetterAvailable
;	COMDAT pdata
pdata	SEGMENT
$pdata$IsDriveLetterAvailable DD imagerel $LN4
	DD	imagerel $LN4+166
	DD	imagerel $unwind$IsDriveLetterAvailable
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IsDriveLetterAvailable DD 021919H
	DD	0310107H
	DD	imagerel __GSHandlerCheck
	DD	0170H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT IsDriveLetterAvailable
_TEXT	SEGMENT
handle$ = 32
objectAttributes$ = 40
objectName$ = 88
link$ = 112
__$ArrayPad$ = 368
nDosDriveNo$ = 400
IsDriveLetterAvailable PROC				; COMDAT

; 2884 : {

$LN4:
  00000	48 81 ec 88 01
	00 00		 sub	 rsp, 392		; 00000188H
  00007	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000e	48 33 c4	 xor	 rax, rsp
  00011	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2885 : 	OBJECT_ATTRIBUTES objectAttributes;
; 2886 : 	UNICODE_STRING objectName;
; 2887 : 	WCHAR link[128];
; 2888 : 	HANDLE handle;
; 2889 : 
; 2890 : 	TCGetDosNameFromNumber (link, nDosDriveNo);

  00019	8b d1		 mov	 edx, ecx
  0001b	48 8d 4c 24 70	 lea	 rcx, QWORD PTR link$[rsp]
  00020	e8 00 00 00 00	 call	 TCGetDosNameFromNumber

; 2891 : 	RtlInitUnicodeString (&objectName, link);

  00025	48 8d 54 24 70	 lea	 rdx, QWORD PTR link$[rsp]
  0002a	48 8d 4c 24 58	 lea	 rcx, QWORD PTR objectName$[rsp]
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2892 : 	InitializeObjectAttributes (&objectAttributes, &objectName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

  00035	48 83 64 24 30
	00		 and	 QWORD PTR objectAttributes$[rsp+8], 0
  0003b	48 83 64 24 48
	00		 and	 QWORD PTR objectAttributes$[rsp+32], 0
  00041	48 83 64 24 50
	00		 and	 QWORD PTR objectAttributes$[rsp+40], 0
  00047	48 8d 44 24 58	 lea	 rax, QWORD PTR objectName$[rsp]

; 2893 : 
; 2894 : 	if (NT_SUCCESS (ZwOpenSymbolicLinkObject (&handle, GENERIC_READ, &objectAttributes)))

  0004c	4c 8d 44 24 28	 lea	 r8, QWORD PTR objectAttributes$[rsp]
  00051	48 8d 4c 24 20	 lea	 rcx, QWORD PTR handle$[rsp]
  00056	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  0005b	48 89 44 24 38	 mov	 QWORD PTR objectAttributes$[rsp+16], rax
  00060	c7 44 24 28 30
	00 00 00	 mov	 DWORD PTR objectAttributes$[rsp], 48 ; 00000030H
  00068	c7 44 24 40 40
	02 00 00	 mov	 DWORD PTR objectAttributes$[rsp+24], 576 ; 00000240H
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwOpenSymbolicLinkObject
  00076	85 c0		 test	 eax, eax
  00078	78 0f		 js	 SHORT $LN1@IsDriveLet

; 2895 : 	{
; 2896 : 		ZwClose (handle);

  0007a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR handle$[rsp]
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 2897 : 		return FALSE;

  00085	33 c0		 xor	 eax, eax
  00087	eb 05		 jmp	 SHORT $LN2@IsDriveLet
$LN1@IsDriveLet:

; 2898 : 	}
; 2899 : 
; 2900 : 	return TRUE;

  00089	b8 01 00 00 00	 mov	 eax, 1
$LN2@IsDriveLet:

; 2901 : }

  0008e	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00096	48 33 cc	 xor	 rcx, rsp
  00099	e8 00 00 00 00	 call	 __security_check_cookie
  0009e	48 81 c4 88 01
	00 00		 add	 rsp, 392		; 00000188H
  000a5	c3		 ret	 0
IsDriveLetterAvailable ENDP
_TEXT	ENDS
PUBLIC	UserCanAccessDriveDevice
;	COMDAT pdata
pdata	SEGMENT
$pdata$UserCanAccessDriveDevice DD imagerel $LN6
	DD	imagerel $LN6+204
	DD	imagerel $unwind$UserCanAccessDriveDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$UserCanAccessDriveDevice DD 030901H
	DD	0160109H
	DD	03002H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT UserCanAccessDriveDevice
_TEXT	SEGMENT
name$ = 96
ioStatusBlock$49247 = 112
fileObjAttributes$49246 = 128
fileHandle$49248 = 192
UserCanAccessDriveDevice PROC				; COMDAT

; 2875 : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H

; 2876 : 	UNICODE_STRING name;
; 2877 : 	RtlInitUnicodeString (&name, L"\\Device\\MountPointManager");

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
  00010	48 8d 4c 24 60	 lea	 rcx, QWORD PTR name$[rsp]
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2878 : 
; 2879 : 	return IsAccessibleByUser (&name, FALSE);

  0001b	83 64 24 50 00	 and	 DWORD PTR [rsp+80], 0
  00020	48 83 64 24 48
	00		 and	 QWORD PTR [rsp+72], 0
  00026	48 83 a4 24 88
	00 00 00 00	 and	 QWORD PTR fileObjAttributes$49246[rsp+8], 0
  0002f	48 83 a4 24 a0
	00 00 00 00	 and	 QWORD PTR fileObjAttributes$49246[rsp+32], 0
  00038	48 83 a4 24 a8
	00 00 00 00	 and	 QWORD PTR fileObjAttributes$49246[rsp+40], 0
  00041	c7 44 24 40 20
	00 00 00	 mov	 DWORD PTR [rsp+64], 32	; 00000020H
  00049	48 8d 44 24 60	 lea	 rax, QWORD PTR name$[rsp]
  0004e	bb 01 00 00 00	 mov	 ebx, 1
  00053	89 5c 24 38	 mov	 DWORD PTR [rsp+56], ebx
  00057	c7 44 24 30 07
	00 00 00	 mov	 DWORD PTR [rsp+48], 7
  0005f	4c 8d 4c 24 70	 lea	 r9, QWORD PTR ioStatusBlock$49247[rsp]
  00064	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR fileObjAttributes$49246[rsp]
  0006c	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR fileHandle$49248[rsp]
  00074	ba 00 00 00 c0	 mov	 edx, -1073741824	; c0000000H
  00079	c7 44 24 28 80
	00 00 00	 mov	 DWORD PTR [rsp+40], 128	; 00000080H
  00081	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00087	c7 84 24 80 00
	00 00 30 00 00
	00		 mov	 DWORD PTR fileObjAttributes$49246[rsp], 48 ; 00000030H
  00092	c7 84 24 98 00
	00 00 40 06 00
	00		 mov	 DWORD PTR fileObjAttributes$49246[rsp+24], 1600 ; 00000640H
  0009d	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR fileObjAttributes$49246[rsp+16], rax
  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwCreateFile
  000ab	85 c0		 test	 eax, eax
  000ad	78 10		 js	 SHORT $LN3@UserCanAcc
  000af	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR fileHandle$49248[rsp]
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
  000bd	eb 02		 jmp	 SHORT $LN4@UserCanAcc
$LN3@UserCanAcc:
  000bf	33 db		 xor	 ebx, ebx
$LN4@UserCanAcc:
  000c1	8b c3		 mov	 eax, ebx

; 2880 : }

  000c3	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  000ca	5b		 pop	 rbx
  000cb	c3		 ret	 0
UserCanAccessDriveDevice ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT FindVolumeWithHighestUniqueId
_TEXT	SEGMENT
maxUniqueId$ = 8
FindVolumeWithHighestUniqueId PROC			; COMDAT

; 2734 : 	PDEVICE_OBJECT highestIdDevice = NULL;
; 2735 : 	int highestId = -1;
; 2736 : 	int drive;
; 2737 : 
; 2738 : 	for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)

  00000	33 d2		 xor	 edx, edx
  00002	45 33 c9	 xor	 r9d, r9d
  00005	41 83 ca ff	 or	 r10d, -1

; 2739 : 	{
; 2740 : 		PDEVICE_OBJECT device = GetVirtualVolumeDeviceObject (drive);

  00009	48 83 fa 19	 cmp	 rdx, 25
$LN14@FindVolume:
  0000d	77 0d		 ja	 SHORT $LN8@FindVolume
  0000f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:VirtualVolumeDeviceObjects
  00016	4d 8b 04 d0	 mov	 r8, QWORD PTR [r8+rdx*8]
  0001a	eb 03		 jmp	 SHORT $LN10@FindVolume
$LN8@FindVolume:
  0001c	45 33 c0	 xor	 r8d, r8d
$LN10@FindVolume:

; 2741 : 		if (device)

  0001f	4d 85 c0	 test	 r8, r8
  00022	74 16		 je	 SHORT $LN4@FindVolume

; 2742 : 		{
; 2743 : 			PEXTENSION extension = (PEXTENSION) device->DeviceExtension;

  00024	49 8b 40 40	 mov	 rax, QWORD PTR [r8+64]

; 2744 : 			if (extension->UniqueVolumeId > highestId && extension->UniqueVolumeId <= maxUniqueId)

  00028	44 39 50 10	 cmp	 DWORD PTR [rax+16], r10d
  0002c	7e 0c		 jle	 SHORT $LN4@FindVolume
  0002e	39 48 10	 cmp	 DWORD PTR [rax+16], ecx
  00031	7f 07		 jg	 SHORT $LN4@FindVolume

; 2745 : 			{
; 2746 : 				highestId = extension->UniqueVolumeId;

  00033	44 8b 50 10	 mov	 r10d, DWORD PTR [rax+16]

; 2747 : 				highestIdDevice = device;

  00037	4d 8b c8	 mov	 r9, r8
$LN4@FindVolume:
  0003a	48 ff c2	 inc	 rdx
  0003d	48 83 fa 19	 cmp	 rdx, 25
  00041	7e ca		 jle	 SHORT $LN14@FindVolume

; 2748 : 			}
; 2749 : 		}
; 2750 : 	}
; 2751 : 
; 2752 : 	return highestIdDevice;

  00043	49 8b c1	 mov	 rax, r9

; 2753 : }

  00046	c3		 ret	 0
FindVolumeWithHighestUniqueId ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	RemoveDriveLink
;	COMDAT pdata
pdata	SEGMENT
$pdata$RemoveDriveLink DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$RemoveDriveLink
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RemoveDriveLink DD 021919H
	DD	0490107H
	DD	imagerel __GSHandlerCheck
	DD	0230H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT RemoveDriveLink
_TEXT	SEGMENT
symLink$ = 32
link$ = 48
__$ArrayPad$ = 560
nDosDriveNo$ = 592
RemoveDriveLink PROC					; COMDAT

; 2439 : {

$LN3:
  00000	48 81 ec 48 02
	00 00		 sub	 rsp, 584		; 00000248H
  00007	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000e	48 33 c4	 xor	 rax, rsp
  00011	48 89 84 24 30
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2440 : 	WCHAR link[256];
; 2441 : 	UNICODE_STRING symLink;
; 2442 : 	NTSTATUS ntStatus;
; 2443 : 
; 2444 : 	TCGetDosNameFromNumber (link, nDosDriveNo);

  00019	8b d1		 mov	 edx, ecx
  0001b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR link$[rsp]
  00020	e8 00 00 00 00	 call	 TCGetDosNameFromNumber

; 2445 : 	RtlInitUnicodeString (&symLink, link);

  00025	48 8d 54 24 30	 lea	 rdx, QWORD PTR link$[rsp]
  0002a	48 8d 4c 24 20	 lea	 rcx, QWORD PTR symLink$[rsp]
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2446 : 
; 2447 : 	ntStatus = IoDeleteSymbolicLink (&symLink);

  00035	48 8d 4c 24 20	 lea	 rcx, QWORD PTR symLink$[rsp]
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteSymbolicLink

; 2448 : 	Dump ("IoDeleteSymbolicLink returned %X\n", ntStatus);
; 2449 : 	return ntStatus;
; 2450 : }

  00040	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00048	48 33 cc	 xor	 rcx, rsp
  0004b	e8 00 00 00 00	 call	 __security_check_cookie
  00050	48 81 c4 48 02
	00 00		 add	 rsp, 584		; 00000248H
  00057	c3		 ret	 0
RemoveDriveLink ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	CreateDriveLink
;	COMDAT pdata
pdata	SEGMENT
$pdata$CreateDriveLink DD imagerel $LN3
	DD	imagerel $LN3+132
	DD	imagerel $unwind$CreateDriveLink
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CreateDriveLink DD 031b19H
	DD	04a0109H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	0240H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT CreateDriveLink
_TEXT	SEGMENT
symLink$ = 32
deviceName$ = 48
dev$ = 64
link$ = 320
__$ArrayPad$ = 576
nDosDriveNo$ = 608
CreateDriveLink PROC					; COMDAT

; 2421 : {

$LN3:
  00000	40 53		 push	 rbx
  00002	48 81 ec 50 02
	00 00		 sub	 rsp, 592		; 00000250H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0001b	8b d9		 mov	 ebx, ecx

; 2422 : 	WCHAR dev[128], link[128];
; 2423 : 	UNICODE_STRING deviceName, symLink;
; 2424 : 	NTSTATUS ntStatus;
; 2425 : 
; 2426 : 	TCGetNTNameFromNumber (dev, nDosDriveNo);

  0001d	8b d1		 mov	 edx, ecx
  0001f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR dev$[rsp]
  00024	e8 00 00 00 00	 call	 TCGetNTNameFromNumber

; 2427 : 	TCGetDosNameFromNumber (link, nDosDriveNo);

  00029	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR link$[rsp]
  00031	8b d3		 mov	 edx, ebx
  00033	e8 00 00 00 00	 call	 TCGetDosNameFromNumber

; 2428 : 
; 2429 : 	RtlInitUnicodeString (&deviceName, dev);

  00038	48 8d 54 24 40	 lea	 rdx, QWORD PTR dev$[rsp]
  0003d	48 8d 4c 24 30	 lea	 rcx, QWORD PTR deviceName$[rsp]
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2430 : 	RtlInitUnicodeString (&symLink, link);

  00048	48 8d 94 24 40
	01 00 00	 lea	 rdx, QWORD PTR link$[rsp]
  00050	48 8d 4c 24 20	 lea	 rcx, QWORD PTR symLink$[rsp]
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2431 : 
; 2432 : 	ntStatus = IoCreateSymbolicLink (&symLink, &deviceName);

  0005b	48 8d 54 24 30	 lea	 rdx, QWORD PTR deviceName$[rsp]
  00060	48 8d 4c 24 20	 lea	 rcx, QWORD PTR symLink$[rsp]
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateSymbolicLink

; 2433 : 	Dump ("IoCreateSymbolicLink returned %X\n", ntStatus);
; 2434 : 	return ntStatus;
; 2435 : }

  0006b	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00073	48 33 cc	 xor	 rcx, rsp
  00076	e8 00 00 00 00	 call	 __security_check_cookie
  0007b	48 81 c4 50 02
	00 00		 add	 rsp, 592		; 00000250H
  00082	5b		 pop	 rbx
  00083	c3		 ret	 0
CreateDriveLink ENDP
_TEXT	ENDS
PUBLIC	TCFsctlCall
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$TCFsctlCall DD imagerel $LN7
	DD	imagerel $LN7+214
	DD	imagerel $unwind$TCFsctlCall
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCFsctlCall DD 061201H
	DD	0136412H
	DD	0123412H
	DD	0700bf212H
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed.build\src\driver\ntdriver.c
xdata	ENDS
;	COMDAT TCFsctlCall
_TEXT	SEGMENT
ioStatusBlock$ = 80
event$ = 96
fileObject$ = 144
IoControlCode$ = 152
InputBuffer$ = 160
InputBufferSize$ = 168
OutputBuffer$ = 176
OutputBufferSize$ = 184
TCFsctlCall PROC					; COMDAT

; 2382 : {

$LN7:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00012	8b da		 mov	 ebx, edx
  00014	48 8b f9	 mov	 rdi, rcx

; 2383 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2384 : 	NTSTATUS ntStatus;
; 2385 : 	PIRP irp;
; 2386 : 	KEVENT event;
; 2387 : 	PIO_STACK_LOCATION stack;
; 2388 : 	PDEVICE_OBJECT deviceObject = IoGetRelatedDeviceObject (fileObject);

  00017	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetRelatedDeviceObject

; 2389 : 
; 2390 : 	KeInitializeEvent(&event, NotificationEvent, FALSE);

  0001d	48 8d 4c 24 60	 lea	 rcx, QWORD PTR event$[rsp]
  00022	45 33 c0	 xor	 r8d, r8d
  00025	33 d2		 xor	 edx, edx
  00027	48 8b f0	 mov	 rsi, rax
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 2391 : 
; 2392 : 	irp = IoBuildDeviceIoControlRequest (IoControlCode,
; 2393 : 					     deviceObject,
; 2394 : 					     InputBuffer, InputBufferSize,
; 2395 : 					     OutputBuffer, OutputBufferSize,
; 2396 : 					     FALSE,
; 2397 : 					     &event,
; 2398 : 					     &ioStatusBlock);

  00030	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR OutputBufferSize$[rsp]
  00037	4c 8d 5c 24 50	 lea	 r11, QWORD PTR ioStatusBlock$[rsp]
  0003c	48 8d 44 24 60	 lea	 rax, QWORD PTR event$[rsp]
  00041	45 33 c9	 xor	 r9d, r9d
  00044	4c 89 5c 24 40	 mov	 QWORD PTR [rsp+64], r11
  00049	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0004e	c6 44 24 30 00	 mov	 BYTE PTR [rsp+48], 0
  00053	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  00057	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR OutputBuffer$[rsp]
  0005f	45 33 c0	 xor	 r8d, r8d
  00062	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00067	8b cb		 mov	 ecx, ebx
  00069	48 8b d6	 mov	 rdx, rsi
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoBuildDeviceIoControlRequest
  00072	48 8b d0	 mov	 rdx, rax

; 2399 : 
; 2400 : 	if (irp == NULL)

  00075	48 85 c0	 test	 rax, rax
  00078	75 07		 jne	 SHORT $LN2@TCFsctlCal

; 2401 : 		return STATUS_INSUFFICIENT_RESOURCES;

  0007a	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  0007f	eb 40		 jmp	 SHORT $LN1@TCFsctlCal
$LN2@TCFsctlCal:

; 2402 : 
; 2403 : 	stack = IoGetNextIrpStackLocation(irp);

  00081	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]

; 2404 : 	
; 2405 : 	stack->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
; 2406 : 	stack->MinorFunction = IRP_MN_USER_FS_REQUEST;
; 2407 : 	stack->FileObject = fileObject;
; 2408 : 
; 2409 : 	ntStatus = IoCallDriver (deviceObject, irp);

  00088	48 8b ce	 mov	 rcx, rsi
  0008b	c6 40 b8 0d	 mov	 BYTE PTR [rax-72], 13
  0008f	c6 40 b9 00	 mov	 BYTE PTR [rax-71], 0
  00093	48 89 78 e8	 mov	 QWORD PTR [rax-24], rdi
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCallDriver

; 2410 : 	if (ntStatus == STATUS_PENDING)

  0009d	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  000a2	75 1d		 jne	 SHORT $LN1@TCFsctlCal

; 2411 : 	{
; 2412 : 		KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);

  000a4	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  000aa	48 8d 4c 24 60	 lea	 rcx, QWORD PTR event$[rsp]
  000af	45 33 c9	 xor	 r9d, r9d
  000b2	45 33 c0	 xor	 r8d, r8d
  000b5	33 d2		 xor	 edx, edx
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 2413 : 		ntStatus = ioStatusBlock.Status;

  000bd	8b 44 24 50	 mov	 eax, DWORD PTR ioStatusBlock$[rsp]
$LN1@TCFsctlCal:

; 2414 : 	}
; 2415 : 
; 2416 : 	return ntStatus;
; 2417 : }

  000c1	4c 8d 9c 24 80
	00 00 00	 lea	 r11, QWORD PTR [rsp+128]
  000c9	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  000cd	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  000d1	49 8b e3	 mov	 rsp, r11
  000d4	5f		 pop	 rdi
  000d5	c3		 ret	 0
TCFsctlCall ENDP
_TEXT	ENDS
PUBLIC	TCWriteDevice
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCWriteDevice DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$TCWriteDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCWriteDevice DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT TCWriteDevice
_TEXT	SEGMENT
deviceObject$ = 64
buffer$ = 72
offset$ = 80
length$ = 88
TCWriteDevice PROC					; COMDAT

; 2375 : {

$LN3:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2376 : 	return TCReadWriteDevice (TRUE, deviceObject, buffer, offset, length);

  00004	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00009	4d 8b c8	 mov	 r9, r8
  0000c	4c 8b c2	 mov	 r8, rdx
  0000f	48 8b d1	 mov	 rdx, rcx
  00012	b9 01 00 00 00	 mov	 ecx, 1
  00017	e8 00 00 00 00	 call	 TCReadWriteDevice

; 2377 : }

  0001c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00020	c3		 ret	 0
TCWriteDevice ENDP
_TEXT	ENDS
PUBLIC	TCReadDevice
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCReadDevice DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$TCReadDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCReadDevice DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT TCReadDevice
_TEXT	SEGMENT
deviceObject$ = 64
buffer$ = 72
offset$ = 80
length$ = 88
TCReadDevice PROC					; COMDAT

; 2369 : {

$LN3:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2370 : 	return TCReadWriteDevice (FALSE, deviceObject, buffer, offset, length);

  00004	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00009	4d 8b c8	 mov	 r9, r8
  0000c	4c 8b c2	 mov	 r8, rdx
  0000f	48 8b d1	 mov	 rdx, rcx
  00012	33 c9		 xor	 ecx, ecx
  00014	e8 00 00 00 00	 call	 TCReadWriteDevice

; 2371 : }

  00019	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0001d	c3		 ret	 0
TCReadDevice ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	TCOpenFsVolume
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCOpenFsVolume DD imagerel $LN5
	DD	imagerel $LN5+288
	DD	imagerel $unwind$TCOpenFsVolume
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCOpenFsVolume DD 051f19H
	DD	05f340dH
	DD	05a010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	02c0H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT TCOpenFsVolume
_TEXT	SEGMENT
objectAttributes$ = 96
fullFileName$ = 144
ioStatus$ = 160
volumeName$ = 176
__$ArrayPad$ = 704
Extension$ = 736
volumeHandle$ = 744
fileObject$ = 752
TCOpenFsVolume PROC					; COMDAT

; 2290 : {

$LN5:
  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	57		 push	 rdi
  00006	48 81 ec d0 02
	00 00		 sub	 rsp, 720		; 000002d0H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 c0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0001f	48 8b fa	 mov	 rdi, rdx

; 2291 : 	NTSTATUS ntStatus;
; 2292 : 	OBJECT_ATTRIBUTES objectAttributes;
; 2293 : 	UNICODE_STRING fullFileName;
; 2294 : 	IO_STATUS_BLOCK ioStatus;
; 2295 : 	WCHAR volumeName[TC_MAX_PATH];
; 2296 : 
; 2297 : 	TCGetNTNameFromNumber (volumeName, Extension->nDosDriveNo);

  00022	8b 51 14	 mov	 edx, DWORD PTR [rcx+20]
  00025	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR volumeName$[rsp]
  0002d	49 8b d8	 mov	 rbx, r8
  00030	e8 00 00 00 00	 call	 TCGetNTNameFromNumber

; 2298 : 	RtlInitUnicodeString (&fullFileName, volumeName);

  00035	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR volumeName$[rsp]
  0003d	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR fullFileName$[rsp]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2299 : 	InitializeObjectAttributes (&objectAttributes, &fullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);
; 2300 : 
; 2301 : 	ntStatus = ZwCreateFile (volumeHandle,
; 2302 : 		SYNCHRONIZE | GENERIC_READ,
; 2303 : 		&objectAttributes,
; 2304 : 		&ioStatus,
; 2305 : 		NULL,
; 2306 : 		FILE_ATTRIBUTE_NORMAL,
; 2307 : 		FILE_SHARE_READ | FILE_SHARE_WRITE,
; 2308 : 		FILE_OPEN,
; 2309 : 		FILE_SYNCHRONOUS_IO_NONALERT,
; 2310 : 		NULL,
; 2311 : 		0);

  0004b	83 64 24 50 00	 and	 DWORD PTR [rsp+80], 0
  00050	48 83 64 24 48
	00		 and	 QWORD PTR [rsp+72], 0
  00056	48 83 64 24 68
	00		 and	 QWORD PTR objectAttributes$[rsp+8], 0
  0005c	48 83 a4 24 80
	00 00 00 00	 and	 QWORD PTR objectAttributes$[rsp+32], 0
  00065	48 83 a4 24 88
	00 00 00 00	 and	 QWORD PTR objectAttributes$[rsp+40], 0
  0006e	c7 44 24 40 20
	00 00 00	 mov	 DWORD PTR [rsp+64], 32	; 00000020H
  00076	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR [rsp+56], 1
  0007e	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR fullFileName$[rsp]
  00086	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR [rsp+48], 3
  0008e	4c 8d 8c 24 a0
	00 00 00	 lea	 r9, QWORD PTR ioStatus$[rsp]
  00096	4c 8d 44 24 60	 lea	 r8, QWORD PTR objectAttributes$[rsp]
  0009b	ba 00 00 10 80	 mov	 edx, -2146435072	; 80100000H
  000a0	48 8b cf	 mov	 rcx, rdi
  000a3	c7 44 24 28 80
	00 00 00	 mov	 DWORD PTR [rsp+40], 128	; 00000080H
  000ab	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  000b1	c7 44 24 60 30
	00 00 00	 mov	 DWORD PTR objectAttributes$[rsp], 48 ; 00000030H
  000b9	c7 44 24 78 40
	02 00 00	 mov	 DWORD PTR objectAttributes$[rsp+24], 576 ; 00000240H
  000c1	48 89 44 24 70	 mov	 QWORD PTR objectAttributes$[rsp+16], rax
  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwCreateFile

; 2312 : 
; 2313 : 	Dump ("Volume %ls open NTSTATUS 0x%08x\n", volumeName, ntStatus);
; 2314 : 
; 2315 : 	if (!NT_SUCCESS (ntStatus))

  000cc	85 c0		 test	 eax, eax

; 2316 : 		return ntStatus;

  000ce	78 2f		 js	 SHORT $LN3@TCOpenFsVo

; 2317 : 
; 2318 : 	ntStatus = ObReferenceObjectByHandle (*volumeHandle,
; 2319 : 		FILE_READ_DATA,
; 2320 : 		NULL,
; 2321 : 		KernelMode,
; 2322 : 		fileObject,
; 2323 : 		NULL);

  000d0	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  000d3	48 83 64 24 28
	00		 and	 QWORD PTR [rsp+40], 0
  000d9	45 33 c9	 xor	 r9d, r9d
  000dc	41 8d 51 01	 lea	 edx, QWORD PTR [r9+1]
  000e0	45 33 c0	 xor	 r8d, r8d
  000e3	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  000e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObReferenceObjectByHandle
  000ee	8b d8		 mov	 ebx, eax

; 2324 : 
; 2325 : 	if (!NT_SUCCESS (ntStatus))

  000f0	85 c0		 test	 eax, eax
  000f2	79 09		 jns	 SHORT $LN1@TCOpenFsVo

; 2326 : 		ZwClose (*volumeHandle);

  000f4	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  000f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
$LN1@TCOpenFsVo:

; 2327 : 
; 2328 : 	return ntStatus;

  000fd	8b c3		 mov	 eax, ebx
$LN3@TCOpenFsVo:

; 2329 : }

  000ff	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00107	48 33 cc	 xor	 rcx, rsp
  0010a	e8 00 00 00 00	 call	 __security_check_cookie
  0010f	48 8b 9c 24 f8
	02 00 00	 mov	 rbx, QWORD PTR [rsp+760]
  00117	48 81 c4 d0 02
	00 00		 add	 rsp, 720		; 000002d0H
  0011e	5f		 pop	 rdi
  0011f	c3		 ret	 0
TCOpenFsVolume ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$SendDeviceIoControlRequest DD imagerel $LN10
	DD	imagerel $LN10+439
	DD	imagerel $unwind$SendDeviceIoControlRequest
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SendDeviceIoControlRequest DD 0b1c01H
	DD	01f741cH
	DD	01e641cH
	DD	01d541cH
	DD	01c341cH
	DD	01a011cH
	DD	0c015H
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed.build\src\driver\ntdriver.c
xdata	ENDS
;	COMDAT SendDeviceIoControlRequest
_TEXT	SEGMENT
ioStatusBlock$ = 80
event$ = 96
args$32350 = 128
deviceObject$ = 224
ioControlCode$ = 232
inputBuffer$ = 240
inputBufferSize$ = 248
outputBuffer$ = 256
outputBufferSize$ = 264
SendDeviceIoControlRequest PROC				; COMDAT

; 2185 : {

$LN10:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 54		 push	 r12
  00015	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  0001c	41 8b f1	 mov	 esi, r9d
  0001f	49 8b e8	 mov	 rbp, r8
  00022	44 8b e2	 mov	 r12d, edx
  00025	48 8b d9	 mov	 rbx, rcx

; 2186 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2187 : 	NTSTATUS status;
; 2188 : 	PIRP irp;
; 2189 : 	KEVENT event;
; 2190 : 
; 2191 : 	if (KeGetCurrentIrql() > APC_LEVEL)

  00028	44 0f 20 c0	 mov	 rax, cr8
  0002c	3c 01		 cmp	 al, 1
  0002e	0f 86 c0 00 00
	00		 jbe	 $LN4@SendDevice

; 2192 : 	{
; 2193 : 		SendDeviceIoControlRequestWorkItemArgs args;
; 2194 : 
; 2195 : 		PIO_WORKITEM workItem = IoAllocateWorkItem (RootDeviceObject);

  00034	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR RootDeviceObject
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAllocateWorkItem
  00041	48 8b f8	 mov	 rdi, rax

; 2196 : 		if (!workItem)

  00044	48 85 c0	 test	 rax, rax
  00047	75 0a		 jne	 SHORT $LN3@SendDevice
$LN9@SendDevice:

; 2197 : 			return STATUS_INSUFFICIENT_RESOURCES;

  00049	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  0004e	e9 46 01 00 00	 jmp	 $LN5@SendDevice
$LN3@SendDevice:

; 2198 : 
; 2199 : 		args.deviceObject = deviceObject;
; 2200 : 		args.ioControlCode = ioControlCode;
; 2201 : 		args.inputBuffer = inputBuffer;
; 2202 : 		args.inputBufferSize = inputBufferSize;
; 2203 : 		args.outputBuffer = outputBuffer;

  00053	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR outputBuffer$[rsp]

; 2204 : 		args.outputBufferSize = outputBufferSize;
; 2205 : 
; 2206 : 		KeInitializeEvent (&args.WorkItemCompletedEvent, SynchronizationEvent, FALSE);

  0005b	45 33 c0	 xor	 r8d, r8d
  0005e	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR args$32350[rsp+48]
  00066	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR args$32350[rsp+32], rax
  0006e	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR outputBufferSize$[rsp]
  00075	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  00079	48 89 9c 24 80
	00 00 00	 mov	 QWORD PTR args$32350[rsp], rbx
  00081	44 89 a4 24 88
	00 00 00	 mov	 DWORD PTR args$32350[rsp+8], r12d
  00089	48 89 ac 24 90
	00 00 00	 mov	 QWORD PTR args$32350[rsp+16], rbp
  00091	89 84 24 a8 00
	00 00		 mov	 DWORD PTR args$32350[rsp+40], eax
  00098	89 b4 24 98 00
	00 00		 mov	 DWORD PTR args$32350[rsp+24], esi
  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 2207 : 		IoQueueWorkItem (workItem, SendDeviceIoControlRequestWorkItemRoutine, DelayedWorkQueue, &args); 

  000a5	4c 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR args$32350[rsp]
  000ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:SendDeviceIoControlRequestWorkItemRoutine
  000b4	41 b8 01 00 00
	00		 mov	 r8d, 1
  000ba	48 8b cf	 mov	 rcx, rdi
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoQueueWorkItem

; 2208 : 
; 2209 : 		KeWaitForSingleObject (&args.WorkItemCompletedEvent, Executive, KernelMode, FALSE, NULL);

  000c3	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  000c9	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR args$32350[rsp+48]
  000d1	45 33 c9	 xor	 r9d, r9d
  000d4	45 33 c0	 xor	 r8d, r8d
  000d7	33 d2		 xor	 edx, edx
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 2210 : 		IoFreeWorkItem (workItem);

  000df	48 8b cf	 mov	 rcx, rdi
  000e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoFreeWorkItem

; 2211 :  
; 2212 : 		return args.Status;

  000e8	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR args$32350[rsp+44]
  000ef	e9 a5 00 00 00	 jmp	 $LN5@SendDevice
$LN4@SendDevice:

; 2213 : 	}
; 2214 : 
; 2215 : 	KeInitializeEvent (&event, NotificationEvent, FALSE);

  000f4	48 8d 4c 24 60	 lea	 rcx, QWORD PTR event$[rsp]
  000f9	45 33 c0	 xor	 r8d, r8d
  000fc	33 d2		 xor	 edx, edx
  000fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 2216 : 
; 2217 : 	irp = IoBuildDeviceIoControlRequest (ioControlCode, deviceObject, inputBuffer, inputBufferSize,
; 2218 : 		outputBuffer, outputBufferSize, FALSE, &event, &ioStatusBlock);

  00104	48 8d 44 24 60	 lea	 rax, QWORD PTR event$[rsp]
  00109	4c 8d 5c 24 50	 lea	 r11, QWORD PTR ioStatusBlock$[rsp]
  0010e	4c 89 5c 24 40	 mov	 QWORD PTR [rsp+64], r11
  00113	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00118	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR outputBufferSize$[rsp]
  0011f	c6 44 24 30 00	 mov	 BYTE PTR [rsp+48], 0
  00124	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00128	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR outputBuffer$[rsp]
  00130	44 8b ce	 mov	 r9d, esi
  00133	4c 8b c5	 mov	 r8, rbp
  00136	48 8b d3	 mov	 rdx, rbx
  00139	41 8b cc	 mov	 ecx, r12d
  0013c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00141	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoBuildDeviceIoControlRequest
  00147	48 8b f8	 mov	 rdi, rax

; 2219 : 
; 2220 : 	if (!irp)

  0014a	48 85 c0	 test	 rax, rax

; 2221 : 		return STATUS_INSUFFICIENT_RESOURCES;

  0014d	0f 84 f6 fe ff
	ff		 je	 $LN9@SendDevice

; 2222 : 
; 2223 : 	ObReferenceObject (deviceObject);

  00153	48 8b cb	 mov	 rcx, rbx
  00156	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfReferenceObject

; 2224 : 
; 2225 : 	status = IoCallDriver (deviceObject, irp);

  0015c	48 8b d7	 mov	 rdx, rdi
  0015f	48 8b cb	 mov	 rcx, rbx
  00162	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCallDriver
  00168	8b f8		 mov	 edi, eax

; 2226 : 	if (status == STATUS_PENDING)

  0016a	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  0016f	75 1d		 jne	 SHORT $LN1@SendDevice

; 2227 : 	{
; 2228 : 		KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);

  00171	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00177	48 8d 4c 24 60	 lea	 rcx, QWORD PTR event$[rsp]
  0017c	45 33 c9	 xor	 r9d, r9d
  0017f	45 33 c0	 xor	 r8d, r8d
  00182	33 d2		 xor	 edx, edx
  00184	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 2229 : 		status = ioStatusBlock.Status;

  0018a	8b 7c 24 50	 mov	 edi, DWORD PTR ioStatusBlock$[rsp]
$LN1@SendDevice:

; 2230 : 	}
; 2231 : 
; 2232 : 	ObDereferenceObject (deviceObject);

  0018e	48 8b cb	 mov	 rcx, rbx
  00191	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 2233 : 	return status;

  00197	8b c7		 mov	 eax, edi
$LN5@SendDevice:

; 2234 : }

  00199	4c 8d 9c 24 d0
	00 00 00	 lea	 r11, QWORD PTR [rsp+208]
  001a1	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  001a5	49 8b 6b 18	 mov	 rbp, QWORD PTR [r11+24]
  001a9	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  001ad	49 8b 7b 28	 mov	 rdi, QWORD PTR [r11+40]
  001b1	49 8b e3	 mov	 rsp, r11
  001b4	41 5c		 pop	 r12
  001b6	c3		 ret	 0
SendDeviceIoControlRequest ENDP
_TEXT	ENDS
PUBLIC	TCDeviceIoControl
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$TCDeviceIoControl DD imagerel $LN8
	DD	imagerel $LN8+281
	DD	imagerel $unwind$TCDeviceIoControl
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCDeviceIoControl DD 071201H
	DD	0176412H
	DD	0163412H
	DD	0140112H
	DD	0700bH
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed.build\src\driver\ntdriver.c
xdata	ENDS
;	COMDAT TCDeviceIoControl
_TEXT	SEGMENT
deviceObject$ = 80
fileObject$ = 88
name$ = 96
ioStatusBlock$ = 112
event$ = 128
deviceName$ = 176
IoControlCode$ = 184
InputBuffer$ = 192
InputBufferSize$ = 200
OutputBuffer$ = 208
OutputBufferSize$ = 216
TCDeviceIoControl PROC					; COMDAT

; 2122 : {

$LN8:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  00012	8b f2		 mov	 esi, edx

; 2123 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2124 : 	NTSTATUS ntStatus;
; 2125 : 	PIRP irp;
; 2126 : 	PFILE_OBJECT fileObject;
; 2127 : 	PDEVICE_OBJECT deviceObject;
; 2128 : 	KEVENT event;
; 2129 : 	UNICODE_STRING name;
; 2130 : 
; 2131 : 	RtlInitUnicodeString(&name, deviceName);

  00014	48 8b d1	 mov	 rdx, rcx
  00017	48 8d 4c 24 60	 lea	 rcx, QWORD PTR name$[rsp]
  0001c	41 8b d9	 mov	 ebx, r9d
  0001f	49 8b f8	 mov	 rdi, r8
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2132 : 	ntStatus = IoGetDeviceObjectPointer (&name, FILE_READ_ATTRIBUTES, &fileObject, &deviceObject);

  00028	4c 8d 4c 24 50	 lea	 r9, QWORD PTR deviceObject$[rsp]
  0002d	4c 8d 44 24 58	 lea	 r8, QWORD PTR fileObject$[rsp]
  00032	48 8d 4c 24 60	 lea	 rcx, QWORD PTR name$[rsp]
  00037	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetDeviceObjectPointer

; 2133 : 
; 2134 : 	if (!NT_SUCCESS (ntStatus))

  00042	85 c0		 test	 eax, eax

; 2135 : 		return ntStatus;

  00044	0f 88 ba 00 00
	00		 js	 $LN4@TCDeviceIo

; 2136 : 
; 2137 : 	KeInitializeEvent(&event, NotificationEvent, FALSE);

  0004a	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR event$[rsp]
  00052	45 33 c0	 xor	 r8d, r8d
  00055	33 d2		 xor	 edx, edx
  00057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 2138 : 
; 2139 : 	irp = IoBuildDeviceIoControlRequest (IoControlCode,
; 2140 : 					     deviceObject,
; 2141 : 					     InputBuffer, InputBufferSize,
; 2142 : 					     OutputBuffer, OutputBufferSize,
; 2143 : 					     FALSE,
; 2144 : 					     &event,
; 2145 : 					     &ioStatusBlock);

  0005d	48 8b 54 24 50	 mov	 rdx, QWORD PTR deviceObject$[rsp]
  00062	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR event$[rsp]
  0006a	4c 8d 5c 24 70	 lea	 r11, QWORD PTR ioStatusBlock$[rsp]
  0006f	44 8b cb	 mov	 r9d, ebx
  00072	4c 8b c7	 mov	 r8, rdi
  00075	4c 89 5c 24 40	 mov	 QWORD PTR [rsp+64], r11
  0007a	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0007f	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR OutputBufferSize$[rsp]
  00086	c6 44 24 30 00	 mov	 BYTE PTR [rsp+48], 0
  0008b	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0008f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR OutputBuffer$[rsp]
  00097	8b ce		 mov	 ecx, esi
  00099	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoBuildDeviceIoControlRequest
  000a4	48 8b d0	 mov	 rdx, rax

; 2146 : 
; 2147 : 	if (irp == NULL)

  000a7	48 85 c0	 test	 rax, rax
  000aa	75 07		 jne	 SHORT $LN2@TCDeviceIo

; 2148 : 	{
; 2149 : 		Dump ("IRP allocation failed\n");
; 2150 : 		ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  000ac	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; ffffffffc000009aH

; 2151 : 		goto ret;

  000b1	eb 44		 jmp	 SHORT $ret$32312
$LN2@TCDeviceIo:

; 2152 : 	}
; 2153 : 
; 2154 : 	IoGetNextIrpStackLocation (irp)->FileObject = fileObject;

  000b3	48 8b 88 b8 00
	00 00		 mov	 rcx, QWORD PTR [rax+184]
  000ba	48 8b 44 24 58	 mov	 rax, QWORD PTR fileObject$[rsp]
  000bf	48 89 41 e8	 mov	 QWORD PTR [rcx-24], rax

; 2155 : 
; 2156 : 	ntStatus = IoCallDriver (deviceObject, irp);

  000c3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  000c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCallDriver
  000ce	8b d8		 mov	 ebx, eax

; 2157 : 	if (ntStatus == STATUS_PENDING)

  000d0	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  000d5	75 20		 jne	 SHORT $ret$32312

; 2158 : 	{
; 2159 : 		KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);

  000d7	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  000dd	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR event$[rsp]
  000e5	45 33 c9	 xor	 r9d, r9d
  000e8	45 33 c0	 xor	 r8d, r8d
  000eb	33 d2		 xor	 edx, edx
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 2160 : 		ntStatus = ioStatusBlock.Status;

  000f3	8b 5c 24 70	 mov	 ebx, DWORD PTR ioStatusBlock$[rsp]
$ret$32312:

; 2161 : 	}
; 2162 : 
; 2163 : ret:
; 2164 : 	ObDereferenceObject (fileObject);

  000f7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR fileObject$[rsp]
  000fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 2165 : 	return ntStatus;

  00102	8b c3		 mov	 eax, ebx
$LN4@TCDeviceIo:

; 2166 : }

  00104	4c 8d 9c 24 a0
	00 00 00	 lea	 r11, QWORD PTR [rsp+160]
  0010c	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00110	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  00114	49 8b e3	 mov	 rsp, r11
  00117	5f		 pop	 rdi
  00118	c3		 ret	 0
TCDeviceIoControl ENDP
_TEXT	ENDS
PUBLIC	OnShutdownPending
;	COMDAT pdata
pdata	SEGMENT
$pdata$OnShutdownPending DD imagerel $LN14
	DD	imagerel $LN14+137
	DD	imagerel $unwind$OnShutdownPending
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$OnShutdownPending DD 010401H
	DD	08204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT OnShutdownPending
_TEXT	SEGMENT
unmount$ = 48
OnShutdownPending PROC					; COMDAT

; 2109 : {

$LN14:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2110 : 	UNMOUNT_STRUCT unmount;
; 2111 : 	memset (&unmount, 0, sizeof (unmount));

  00004	33 c0		 xor	 eax, eax
  00006	48 89 44 24 30	 mov	 QWORD PTR unmount$[rsp], rax

; 2112 : 	unmount.ignoreOpenFiles = TRUE;

  0000b	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR unmount$[rsp+4], 1
  00013	48 89 44 24 38	 mov	 QWORD PTR unmount$[rsp+8], rax
$LL5@OnShutdown:

; 2113 : 
; 2114 : 	while (SendDeviceIoControlRequest (RootDeviceObject, TC_IOCTL_DISMOUNT_ALL_VOLUMES, &unmount, sizeof (unmount), &unmount, sizeof (unmount)) == STATUS_INSUFFICIENT_RESOURCES || unmount.HiddenVolumeProtectionTriggered)

  00018	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR RootDeviceObject
  0001f	48 8d 44 24 30	 lea	 rax, QWORD PTR unmount$[rsp]
  00024	4c 8d 44 24 30	 lea	 r8, QWORD PTR unmount$[rsp]
  00029	41 b9 10 00 00
	00		 mov	 r9d, 16
  0002f	ba 14 20 22 00	 mov	 edx, 2236436		; 00222014H
  00034	c7 44 24 28 10
	00 00 00	 mov	 DWORD PTR [rsp+40], 16
  0003c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00041	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  00046	3d 9a 00 00 c0	 cmp	 eax, -1073741670	; ffffffffc000009aH
  0004b	74 07		 je	 SHORT $LN3@OnShutdown
  0004d	83 7c 24 38 00	 cmp	 DWORD PTR unmount$[rsp+8], 0
  00052	74 07		 je	 SHORT $LL2@OnShutdown
$LN3@OnShutdown:

; 2115 : 		unmount.HiddenVolumeProtectionTriggered = FALSE;

  00054	83 64 24 38 00	 and	 DWORD PTR unmount$[rsp+8], 0
  00059	eb bd		 jmp	 SHORT $LL5@OnShutdown
$LL2@OnShutdown:

; 2116 : 
; 2117 : 	while (SendDeviceIoControlRequest (RootDeviceObject, TC_IOCTL_WIPE_PASSWORD_CACHE, NULL, 0, NULL, 0) == STATUS_INSUFFICIENT_RESOURCES);

  0005b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR RootDeviceObject
  00062	83 64 24 28 00	 and	 DWORD PTR [rsp+40], 0
  00067	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  0006d	45 33 c9	 xor	 r9d, r9d
  00070	45 33 c0	 xor	 r8d, r8d
  00073	ba 30 20 22 00	 mov	 edx, 2236464		; 00222030H
  00078	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  0007d	3d 9a 00 00 c0	 cmp	 eax, -1073741670	; ffffffffc000009aH
  00082	74 d7		 je	 SHORT $LL2@OnShutdown

; 2118 : }

  00084	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00088	c3		 ret	 0
OnShutdownPending ENDP
_TEXT	ENDS
PUBLIC	TCDeleteDeviceObject
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCDeleteDeviceObject DD imagerel $LN18
	DD	imagerel $LN18+348
	DD	imagerel $unwind$TCDeleteDeviceObject
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCDeleteDeviceObject DD 060f01H
	DD	0d640fH
	DD	0c340fH
	DD	0700b920fH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT TCDeleteDeviceObject
_TEXT	SEGMENT
Win32NameString$ = 48
name$32257 = 64
DeviceObject$ = 96
Extension$ = 104
TCDeleteDeviceObject PROC				; COMDAT

; 2031 : {

$LN18:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 2032 : 	UNICODE_STRING Win32NameString;
; 2033 : 	NTSTATUS ntStatus;
; 2034 : 
; 2035 : 	Dump ("TCDeleteDeviceObject BEGIN\n");
; 2036 : 
; 2037 : 	if (Extension->bRootDevice)

  0000f	83 3a 00	 cmp	 DWORD PTR [rdx], 0
  00012	48 8b da	 mov	 rbx, rdx
  00015	48 8b f1	 mov	 rsi, rcx
  00018	74 2a		 je	 SHORT $LN11@TCDeleteDe

; 2038 : 	{
; 2039 : 		RtlInitUnicodeString (&Win32NameString, (LPWSTR) DOS_ROOT_PREFIX);

  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
  00021	48 8d 4c 24 30	 lea	 rcx, QWORD PTR Win32NameString$[rsp]
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2040 : 		ntStatus = IoDeleteSymbolicLink (&Win32NameString);

  0002c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR Win32NameString$[rsp]
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteSymbolicLink

; 2041 : 		if (!NT_SUCCESS (ntStatus))
; 2042 : 			Dump ("IoDeleteSymbolicLink failed ntStatus = 0x%08x\n", ntStatus);
; 2043 : 
; 2044 : 		RootDeviceObject = NULL;

  00037	48 83 25 00 00
	00 00 00	 and	 QWORD PTR RootDeviceObject, 0

; 2045 : 	}
; 2046 : 	else

  0003f	e9 ff 00 00 00	 jmp	 $LN9@TCDeleteDe
$LN11@TCDeleteDe:

; 2047 : 	{
; 2048 : 		if (Extension->peThread != NULL)

  00044	48 83 7a 20 00	 cmp	 QWORD PTR [rdx+32], 0
  00049	74 41		 je	 SHORT $LN15@TCDeleteDe

; 2049 : 			TCStopVolumeThread (DeviceObject, Extension);

  0004b	c7 42 1c 01 00
	00 00		 mov	 DWORD PTR [rdx+28], 1
  00052	48 8d 4a 58	 lea	 rcx, QWORD PTR [rdx+88]
  00056	33 d2		 xor	 edx, edx
  00058	44 8d 42 01	 lea	 r8d, QWORD PTR [rdx+1]
  0005c	41 b1 01	 mov	 r9b, 1
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseSemaphore
  00065	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00069	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  0006f	45 33 c9	 xor	 r9d, r9d
  00072	45 33 c0	 xor	 r8d, r8d
  00075	33 d2		 xor	 edx, edx
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  0007d	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject
  00087	48 83 63 20 00	 and	 QWORD PTR [rbx+32], 0
$LN15@TCDeleteDe:

; 2050 : 
; 2051 : 		if (Extension->UserSid)

  0008c	48 8b 8b 88 05
	00 00		 mov	 rcx, QWORD PTR [rbx+1416]
  00093	48 85 c9	 test	 rcx, rcx
  00096	74 0b		 je	 SHORT $LN7@TCDeleteDe

; 2052 : 			TCfree (Extension->UserSid);

  00098	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN7@TCDeleteDe:

; 2053 : 
; 2054 : 		if (Extension->SecurityClientContextValid)

  000a3	83 bb 90 05 00
	00 00		 cmp	 DWORD PTR [rbx+1424], 0
  000aa	0f 84 83 00 00
	00		 je	 $LN1@TCDeleteDe

; 2055 : 		{
; 2056 : 			if (OsMajorVersion == 5 && OsMinorVersion == 0)

  000b0	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR OsMajorVersion, 5
  000b7	75 18		 jne	 SHORT $LN5@TCDeleteDe
  000b9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR OsMinorVersion, 0
  000c0	75 0f		 jne	 SHORT $LN5@TCDeleteDe

; 2057 : 			{
; 2058 : 				ObDereferenceObject (Extension->SecurityClientContext.ClientToken);

  000c2	48 8b 8b a8 05
	00 00		 mov	 rcx, QWORD PTR [rbx+1448]
  000c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 2059 : 			}
; 2060 : 			else

  000cf	eb 62		 jmp	 SHORT $LN1@TCDeleteDe
$LN5@TCDeleteDe:

; 2061 : 			{
; 2062 : 				// Windows 2000 does not support PsDereferenceImpersonationToken() used by SeDeleteClientSecurity().
; 2063 : 				// TODO: Use only SeDeleteClientSecurity() once support for Windows 2000 is dropped.
; 2064 : 
; 2065 : 				VOID (*PsDereferenceImpersonationTokenD) (PACCESS_TOKEN ImpersonationToken);
; 2066 : 				UNICODE_STRING name;
; 2067 : 				RtlInitUnicodeString (&name, L"PsDereferenceImpersonationToken");

  000d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EA@FPAPEGHJ@?$AAP?$AAs?$AAD?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAI?$AAm?$AAp?$AAe?$AAr?$AAs?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAk?$AAe?$AAn?$AA?$AA@FNODOBFM@
  000d8	48 8d 4c 24 40	 lea	 rcx, QWORD PTR name$32257[rsp]
  000dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2068 : 
; 2069 : 				PsDereferenceImpersonationTokenD = MmGetSystemRoutineAddress (&name);

  000e3	48 8d 4c 24 40	 lea	 rcx, QWORD PTR name$32257[rsp]
  000e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmGetSystemRoutineAddress
  000ee	48 8b f8	 mov	 rdi, rax

; 2070 : 				if (!PsDereferenceImpersonationTokenD)

  000f1	48 85 c0	 test	 rax, rax
  000f4	75 22		 jne	 SHORT $LN3@TCDeleteDe

; 2071 : 					TC_BUG_CHECK (STATUS_NOT_IMPLEMENTED);

  000f6	8d 48 29	 lea	 ecx, QWORD PTR [rax+41]
  000f9	45 33 c9	 xor	 r9d, r9d
  000fc	ba 17 08 00 00	 mov	 edx, 2071		; 00000817H
  00101	49 c7 c0 02 00
	00 c0		 mov	 r8, -1073741822		; ffffffffc0000002H
  00108	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00111	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00117	cc		 int	 3
$LN3@TCDeleteDe:

; 2072 : 				
; 2073 : #				define PsDereferencePrimaryToken
; 2074 : #				define PsDereferenceImpersonationToken PsDereferenceImpersonationTokenD
; 2075 : 
; 2076 : 				SeDeleteClientSecurity (&Extension->SecurityClientContext);

  00118	48 8b 8b a8 05
	00 00		 mov	 rcx, QWORD PTR [rbx+1448]
  0011f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeTokenType
  00125	83 f8 01	 cmp	 eax, 1
  00128	74 09		 je	 SHORT $LN1@TCDeleteDe
  0012a	48 8b 8b a8 05
	00 00		 mov	 rcx, QWORD PTR [rbx+1448]
  00131	ff d7		 call	 rdi
$LN1@TCDeleteDe:

; 2077 : 
; 2078 : #				undef PsDereferencePrimaryToken
; 2079 : #				undef PsDereferenceImpersonationToken
; 2080 : 			}
; 2081 : 		}
; 2082 : 
; 2083 : 		VirtualVolumeDeviceObjects[Extension->nDosDriveNo] = NULL;

  00133	48 63 43 14	 movsxd	 rax, DWORD PTR [rbx+20]
  00137	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:VirtualVolumeDeviceObjects
  0013e	48 83 24 c1 00	 and	 QWORD PTR [rcx+rax*8], 0
$LN9@TCDeleteDe:

; 2084 : 	}
; 2085 : 
; 2086 : 	IoDeleteDevice (DeviceObject);

  00143	48 8b ce	 mov	 rcx, rsi
  00146	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteDevice

; 2087 : 
; 2088 : 	Dump ("TCDeleteDeviceObject END\n");
; 2089 : }

  0014c	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00151	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00156	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0015a	5f		 pop	 rdi
  0015b	c3		 ret	 0
$LN17@TCDeleteDe:
TCDeleteDeviceObject ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	TCCreateDeviceObject
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$TCCreateDeviceObject DD imagerel $LN8
	DD	imagerel $LN8+403
	DD	imagerel $unwind$TCCreateDeviceObject
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCCreateDeviceObject DD 051f19H
	DD	01e010dH
	DD	060057006H
	DD	03004H
	DD	imagerel __GSHandlerCheck
	DD	0e0H
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed.build\src\driver\ntdriver.c
xdata	ENDS
;	COMDAT TCCreateDeviceObject
_TEXT	SEGMENT
ntUnicodeString$ = 64
Win32NameString$ = 80
ntname$ = 96
dosname$ = 160
__$ArrayPad$ = 224
DriverObject$ = 272
ppDeviceObject$ = 280
mount$ = 288
TCCreateDeviceObject PROC				; COMDAT

; 414  : {

$LN8:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	56		 push	 rsi
  00005	57		 push	 rdi
  00006	48 81 ec f0 00
	00 00		 sub	 rsp, 240		; 000000f0H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0001f	48 8b f2	 mov	 rsi, rdx

; 415  : 	UNICODE_STRING Win32NameString, ntUnicodeString;
; 416  : 	WCHAR dosname[32], ntname[32];
; 417  : 	PEXTENSION Extension;
; 418  : 	NTSTATUS ntStatus;
; 419  : 	ULONG devChars = 0;
; 420  : 
; 421  : 	Dump ("TCCreateDeviceObject BEGIN\n");
; 422  : 	ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);
; 423  : 
; 424  : 	TCGetDosNameFromNumber (dosname, mount->nDosDriveNo);

  00022	41 8b 90 64 02
	00 00		 mov	 edx, DWORD PTR [r8+612]
  00029	48 8b d9	 mov	 rbx, rcx
  0002c	49 8d 4b 98	 lea	 rcx, QWORD PTR [r11-104]
  00030	49 8b f8	 mov	 rdi, r8
  00033	e8 00 00 00 00	 call	 TCGetDosNameFromNumber

; 425  : 	TCGetNTNameFromNumber (ntname, mount->nDosDriveNo);

  00038	8b 97 64 02 00
	00		 mov	 edx, DWORD PTR [rdi+612]
  0003e	48 8d 4c 24 60	 lea	 rcx, QWORD PTR ntname$[rsp]
  00043	e8 00 00 00 00	 call	 TCGetNTNameFromNumber

; 426  : 	RtlInitUnicodeString (&ntUnicodeString, ntname);

  00048	48 8d 54 24 60	 lea	 rdx, QWORD PTR ntname$[rsp]
  0004d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ntUnicodeString$[rsp]
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 427  : 	RtlInitUnicodeString (&Win32NameString, dosname);

  00058	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR dosname$[rsp]
  00060	48 8d 4c 24 50	 lea	 rcx, QWORD PTR Win32NameString$[rsp]
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 428  : 
; 429  : 	devChars = FILE_DEVICE_SECURE_OPEN;
; 430  : 	devChars |= mount->bMountReadOnly ? FILE_READ_ONLY_DEVICE : 0;

  0006b	8b 87 6c 02 00
	00		 mov	 eax, DWORD PTR [rdi+620]

; 431  : 	devChars |= mount->bMountRemovable ? FILE_REMOVABLE_MEDIA : 0;
; 432  : 
; 433  : 	Dump ("Creating device nt=%ls dos=%ls\n", ntname, dosname);
; 434  : 
; 435  : 	ntStatus = IoCreateDevice (
; 436  : 					  DriverObject,			/* Our Driver Object */
; 437  : 					  sizeof (EXTENSION),	/* Size of state information */
; 438  : 					  &ntUnicodeString,		/* Device name "\Device\Name" */
; 439  : 					  FILE_DEVICE_DISK,		/* Device type */
; 440  : 					  devChars,				/* Device characteristics */
; 441  : 					  FALSE,				/* Exclusive device */
; 442  : 					  ppDeviceObject);		/* Returned ptr to Device Object */

  00071	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00076	f7 d8		 neg	 eax
  00078	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  0007d	4c 8d 44 24 40	 lea	 r8, QWORD PTR ntUnicodeString$[rsp]
  00082	1b d2		 sbb	 edx, edx
  00084	33 c0		 xor	 eax, eax
  00086	41 b9 07 00 00
	00		 mov	 r9d, 7
  0008c	83 e2 02	 and	 edx, 2
  0008f	39 87 70 02 00
	00		 cmp	 DWORD PTR [rdi+624], eax
  00095	48 8b cb	 mov	 rcx, rbx
  00098	0f 95 c0	 setne	 al
  0009b	0b d0		 or	 edx, eax
  0009d	0f ba ea 08	 bts	 edx, 8
  000a1	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  000a5	ba e0 05 00 00	 mov	 edx, 1504		; 000005e0H
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateDevice

; 443  : 
; 444  : 	if (!NT_SUCCESS (ntStatus))

  000b0	85 c0		 test	 eax, eax

; 445  : 	{
; 446  : 		Dump ("TCCreateDeviceObject NTSTATUS = 0x%08x END\n", ntStatus);
; 447  : 		return ntStatus;/* Failed to create DeviceObject */

  000b2	0f 88 c0 00 00
	00		 js	 $LN2@TCCreateDe

; 448  : 	}
; 449  : 	/* Initialize device object and extension. */
; 450  : 
; 451  : 	(*ppDeviceObject)->Flags |= DO_DIRECT_IO;

  000b8	48 8b 06	 mov	 rax, QWORD PTR [rsi]

; 452  : 	(*ppDeviceObject)->StackSize += 6;		// Reduce occurrence of NO_MORE_IRP_STACK_LOCATIONS bug check caused by buggy drivers
; 453  : 
; 454  : 	/* Setup the device extension */
; 455  : 	Extension = (PEXTENSION) (*ppDeviceObject)->DeviceExtension;
; 456  : 	memset (Extension, 0, sizeof (EXTENSION));

  000bb	33 d2		 xor	 edx, edx
  000bd	41 b8 e0 05 00
	00		 mov	 r8d, 1504		; 000005e0H
  000c3	83 48 30 10	 or	 DWORD PTR [rax+48], 16
  000c7	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000ca	80 40 4c 06	 add	 BYTE PTR [rax+76], 6
  000ce	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000d1	48 8b 58 40	 mov	 rbx, QWORD PTR [rax+64]
  000d5	48 8b cb	 mov	 rcx, rbx
  000d8	e8 00 00 00 00	 call	 memset

; 457  : 
; 458  : 	Extension->IsVolumeDevice = TRUE;

  000dd	ba 01 00 00 00	 mov	 edx, 1

; 459  : 	Extension->nDosDriveNo = mount->nDosDriveNo;
; 460  : 	Extension->bRemovable = mount->bMountRemovable;
; 461  : 	Extension->PartitionInInactiveSysEncScope = mount->bPartitionInInactiveSysEncScope;
; 462  : 	Extension->SystemFavorite = mount->SystemFavorite;
; 463  : 
; 464  : 	KeInitializeEvent (&Extension->keCreateEvent, SynchronizationEvent, FALSE);

  000e2	48 8d 4b 28	 lea	 rcx, QWORD PTR [rbx+40]
  000e6	89 53 04	 mov	 DWORD PTR [rbx+4], edx
  000e9	8b 87 64 02 00
	00		 mov	 eax, DWORD PTR [rdi+612]
  000ef	45 33 c0	 xor	 r8d, r8d
  000f2	89 43 14	 mov	 DWORD PTR [rbx+20], eax
  000f5	8b 87 70 02 00
	00		 mov	 eax, DWORD PTR [rdi+624]
  000fb	89 83 44 03 00
	00		 mov	 DWORD PTR [rbx+836], eax
  00101	8b 87 80 02 00
	00		 mov	 eax, DWORD PTR [rdi+640]
  00107	89 83 48 03 00
	00		 mov	 DWORD PTR [rbx+840], eax
  0010d	8b 87 88 02 00
	00		 mov	 eax, DWORD PTR [rdi+648]
  00113	89 83 54 03 00
	00		 mov	 DWORD PTR [rbx+852], eax
  00119	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 465  : 	KeInitializeSemaphore (&Extension->RequestSemaphore, 0L, MAXLONG);

  0011f	48 8d 4b 58	 lea	 rcx, QWORD PTR [rbx+88]
  00123	33 d2		 xor	 edx, edx
  00125	41 b8 ff ff ff
	7f		 mov	 r8d, 2147483647		; 7fffffffH
  0012b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeSemaphore

; 466  : 	KeInitializeSpinLock (&Extension->ListSpinLock);

  00131	48 83 63 40 00	 and	 QWORD PTR [rbx+64], 0

; 467  : 	InitializeListHead (&Extension->ListEntry);

  00136	48 8d 43 48	 lea	 rax, QWORD PTR [rbx+72]

; 468  : 	IoInitializeRemoveLock (&Extension->Queue.RemoveLock, 'LRCT', 0, 0);

  0013a	48 8d 8b 80 01
	00 00		 lea	 rcx, QWORD PTR [rbx+384]
  00141	45 33 c9	 xor	 r9d, r9d
  00144	45 33 c0	 xor	 r8d, r8d
  00147	ba 54 43 52 4c	 mov	 edx, 1280459604		; 4c524354H
  0014c	48 89 40 08	 mov	 QWORD PTR [rax+8], rax
  00150	48 89 00	 mov	 QWORD PTR [rax], rax
  00153	c7 44 24 20 20
	00 00 00	 mov	 DWORD PTR [rsp+32], 32	; 00000020H
  0015b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoInitializeRemoveLockEx

; 469  : 
; 470  : 	VirtualVolumeDeviceObjects[mount->nDosDriveNo] = *ppDeviceObject;

  00161	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00164	4c 63 9f 64 02
	00 00		 movsxd	 r11, DWORD PTR [rdi+612]
  0016b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:VirtualVolumeDeviceObjects
  00172	4a 89 04 d9	 mov	 QWORD PTR [rcx+r11*8], rax

; 471  : 
; 472  : 	Dump ("TCCreateDeviceObject STATUS_SUCCESS END\n");
; 473  : 
; 474  : 	return STATUS_SUCCESS;

  00176	33 c0		 xor	 eax, eax
$LN2@TCCreateDe:

; 475  : }

  00178	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00180	48 33 cc	 xor	 rcx, rsp
  00183	e8 00 00 00 00	 call	 __security_check_cookie
  00188	48 81 c4 f0 00
	00 00		 add	 rsp, 240		; 000000f0H
  0018f	5f		 pop	 rdi
  00190	5e		 pop	 rsi
  00191	5b		 pop	 rbx
  00192	c3		 ret	 0
TCCreateDeviceObject ENDP
_TEXT	ENDS
PUBLIC	ValidateIOBufferSize
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$ValidateIOBufferSize DD imagerel $LN13
	DD	imagerel $LN13+135
	DD	imagerel $unwind$ValidateIOBufferSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ValidateIOBufferSize DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed.build\src\driver\ntdriver.c
xdata	ENDS
;	COMDAT ValidateIOBufferSize
_TEXT	SEGMENT
irp$ = 48
requiredBufferSize$ = 56
type$ = 64
ValidateIOBufferSize PROC				; COMDAT

; 168  : {

$LN13:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 169  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (irp);

  00004	4c 8b 99 b8 00
	00 00		 mov	 r11, QWORD PTR [rcx+184]
  0000b	4c 8b c9	 mov	 r9, rcx

; 170  : 	BOOL input = (type == ValidateInput || type == ValidateInputOutput);

  0000e	45 85 c0	 test	 r8d, r8d
  00011	74 0b		 je	 SHORT $LN7@ValidateIO
  00013	41 83 f8 02	 cmp	 r8d, 2
  00017	74 05		 je	 SHORT $LN7@ValidateIO
  00019	45 33 d2	 xor	 r10d, r10d
  0001c	eb 06		 jmp	 SHORT $LN8@ValidateIO
$LN7@ValidateIO:
  0001e	41 ba 01 00 00
	00		 mov	 r10d, 1
$LN8@ValidateIO:

; 171  : 	BOOL output = (type == ValidateOutput || type == ValidateInputOutput);

  00024	41 83 f8 01	 cmp	 r8d, 1
  00028	74 0a		 je	 SHORT $LN9@ValidateIO
  0002a	41 83 f8 02	 cmp	 r8d, 2
  0002e	74 04		 je	 SHORT $LN9@ValidateIO
  00030	33 c9		 xor	 ecx, ecx
  00032	eb 05		 jmp	 SHORT $LN10@ValidateIO
$LN9@ValidateIO:
  00034	b9 01 00 00 00	 mov	 ecx, 1
$LN10@ValidateIO:

; 172  : 
; 173  : 	if ((input && irpSp->Parameters.DeviceIoControl.InputBufferLength < requiredBufferSize)
; 174  : 		|| (output && irpSp->Parameters.DeviceIoControl.OutputBufferLength < requiredBufferSize))

  00039	45 85 d2	 test	 r10d, r10d
  0003c	74 09		 je	 SHORT $LN2@ValidateIO
  0003e	41 8b 43 10	 mov	 eax, DWORD PTR [r11+16]
  00042	48 3b c2	 cmp	 rax, rdx
  00045	72 0d		 jb	 SHORT $LN3@ValidateIO
$LN2@ValidateIO:
  00047	85 c9		 test	 ecx, ecx
  00049	74 1a		 je	 SHORT $LN4@ValidateIO
  0004b	41 8b 43 08	 mov	 eax, DWORD PTR [r11+8]
  0004f	48 3b c2	 cmp	 rax, rdx
  00052	73 11		 jae	 SHORT $LN4@ValidateIO
$LN3@ValidateIO:

; 175  : 	{
; 176  : 		Dump ("STATUS_BUFFER_TOO_SMALL ioctl=0x%x,%d in=%d out=%d reqsize=%d insize=%d outsize=%d\n", (int) (irpSp->Parameters.DeviceIoControl.IoControlCode >> 16), (int) ((irpSp->Parameters.DeviceIoControl.IoControlCode & 0x1FFF) >> 2), input, output, requiredBufferSize, irpSp->Parameters.DeviceIoControl.InputBufferLength, irpSp->Parameters.DeviceIoControl.OutputBufferLength);
; 177  : 
; 178  : 		irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
; 179  : 		irp->IoStatus.Information = 0;

  00054	49 83 61 38 00	 and	 QWORD PTR [r9+56], 0
  00059	41 c7 41 30 23
	00 00 c0	 mov	 DWORD PTR [r9+48], -1073741789 ; ffffffffc0000023H

; 180  : 		return FALSE;

  00061	33 c0		 xor	 eax, eax
  00063	eb 1d		 jmp	 SHORT $LN5@ValidateIO
$LN4@ValidateIO:

; 181  : 	}
; 182  : 
; 183  : 	if (!input && output)

  00065	45 85 d2	 test	 r10d, r10d
  00068	75 13		 jne	 SHORT $LN1@ValidateIO
  0006a	85 c9		 test	 ecx, ecx
  0006c	74 0f		 je	 SHORT $LN1@ValidateIO

; 184  : 		memset (irp->AssociatedIrp.SystemBuffer, 0, irpSp->Parameters.DeviceIoControl.OutputBufferLength);

  0006e	45 8b 43 08	 mov	 r8d, DWORD PTR [r11+8]
  00072	49 8b 49 18	 mov	 rcx, QWORD PTR [r9+24]
  00076	33 d2		 xor	 edx, edx
  00078	e8 00 00 00 00	 call	 memset
$LN1@ValidateIO:

; 185  : 
; 186  : 	return TRUE;

  0007d	b8 01 00 00 00	 mov	 eax, 1
$LN5@ValidateIO:

; 187  : }

  00082	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00086	c3		 ret	 0
ValidateIOBufferSize ENDP
_TEXT	ENDS
PUBLIC	DriverAddDevice
;	COMDAT pdata
pdata	SEGMENT
$pdata$DriverAddDevice DD imagerel $LN6
	DD	imagerel $LN6+138
	DD	imagerel $unwind$DriverAddDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DriverAddDevice DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT DriverAddDevice
_TEXT	SEGMENT
driverObject$ = 48
pdo$ = 56
interfaceLinks$31396 = 64
DriverAddDevice PROC					; COMDAT

; 112  : {

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 113  : #ifdef DEBUG
; 114  : 	char nameInfoBuffer[128];
; 115  : 	POBJECT_NAME_INFORMATION nameInfo = (POBJECT_NAME_INFORMATION) nameInfoBuffer;
; 116  : 	ULONG nameInfoSize;
; 117  : 	Dump ("AddDevice pdo=%p type=%x name=%ws\n", pdo, pdo->DeviceType, NT_SUCCESS (ObQueryNameString (pdo, nameInfo, sizeof (nameInfoBuffer), &nameInfoSize)) ? nameInfo->Name.Buffer : L"?");
; 118  : #endif
; 119  : 
; 120  : 	if (VolumeClassFilterRegistered && BootArgsValid && BootArgs.HiddenSystemPartitionStart != 0)

  0000f	33 f6		 xor	 esi, esi
  00011	48 8b da	 mov	 rbx, rdx
  00014	48 8b f9	 mov	 rdi, rcx
  00017	39 35 00 00 00
	00		 cmp	 DWORD PTR VolumeClassFilterRegistered, esi
  0001d	74 50		 je	 SHORT $LN2@DriverAddD
  0001f	39 35 00 00 00
	00		 cmp	 DWORD PTR BootArgsValid, esi
  00025	74 48		 je	 SHORT $LN2@DriverAddD
  00027	48 39 35 5a 00
	00 00		 cmp	 QWORD PTR BootArgs+90, rsi
  0002e	74 3f		 je	 SHORT $LN2@DriverAddD

; 121  : 	{
; 122  : 		PWSTR interfaceLinks;
; 123  : 		if (NT_SUCCESS (IoGetDeviceInterfaces (&GUID_DEVINTERFACE_VOLUME, pdo, DEVICE_INTERFACE_INCLUDE_NONACTIVE, &interfaceLinks)))

  00030	4c 8d 4c 24 40	 lea	 r9, QWORD PTR interfaceLinks$31396[rsp]
  00035	44 8d 46 01	 lea	 r8d, QWORD PTR [rsi+1]
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:GUID_DEVINTERFACE_VOLUME
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetDeviceInterfaces
  00046	3b c6		 cmp	 eax, esi
  00048	7c 25		 jl	 SHORT $LN2@DriverAddD

; 124  : 		{
; 125  : 			if (interfaceLinks[0] != UNICODE_NULL)

  0004a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR interfaceLinks$31396[rsp]

; 126  : 			{
; 127  : 				Dump ("Volume pdo=%p interface=%ws\n", pdo, interfaceLinks);
; 128  : 				ExFreePool (interfaceLinks);

  0004f	33 d2		 xor	 edx, edx
  00051	66 39 31	 cmp	 WORD PTR [rcx], si
  00054	74 13		 je	 SHORT $LN1@DriverAddD
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 129  : 
; 130  : 				return VolumeFilterAddDevice (driverObject, pdo);

  0005c	48 8b d3	 mov	 rdx, rbx
  0005f	48 8b cf	 mov	 rcx, rdi
  00062	e8 00 00 00 00	 call	 VolumeFilterAddDevice
  00067	eb 11		 jmp	 SHORT $LN4@DriverAddD
$LN1@DriverAddD:

; 131  : 			}
; 132  : 
; 133  : 			ExFreePool (interfaceLinks);

  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN2@DriverAddD:

; 134  : 		}
; 135  : 	}
; 136  : 
; 137  : 	return DriveFilterAddDevice (driverObject, pdo);

  0006f	48 8b d3	 mov	 rdx, rbx
  00072	48 8b cf	 mov	 rcx, rdi
  00075	e8 00 00 00 00	 call	 DriveFilterAddDevice
$LN4@DriverAddD:

; 138  : }

  0007a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007f	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00084	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00088	5f		 pop	 rdi
  00089	c3		 ret	 0
DriverAddDevice ENDP
PUBLIC	IsVolumeAccessibleByCurrentUser
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$IsVolumeAccessibleByCurrentUser DD imagerel $LN12
	DD	imagerel $LN12+233
	DD	imagerel $unwind$IsVolumeAccessibleByCurrentUser
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IsVolumeAccessibleByCurrentUser DD 060f01H
	DD	0c640fH
	DD	0a340fH
	DD	0700b720fH
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed.build\src\driver\ntdriver.c
xdata	ENDS
;	COMDAT IsVolumeAccessibleByCurrentUser
_TEXT	SEGMENT
subContext$ = 32
volumeDeviceExtension$ = 80
tokenUser$ = 88
IsVolumeAccessibleByCurrentUser PROC			; COMDAT

; 3222 : {

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8b f1	 mov	 rsi, rcx

; 3223 : 	SECURITY_SUBJECT_CONTEXT subContext;
; 3224 : 	PACCESS_TOKEN accessToken;
; 3225 : 	PTOKEN_USER tokenUser;
; 3226 : 	BOOL result = FALSE;
; 3227 : 
; 3228 : 	if (IoIsSystemThread (PsGetCurrentThread())
; 3229 : 		|| UserCanAccessDriveDevice()
; 3230 : 		|| !volumeDeviceExtension->UserSid
; 3231 : 		|| (volumeDeviceExtension->SystemFavorite && !NonAdminSystemFavoritesAccessDisabled))

  00012	65 48 8b 0c 25
	88 01 00 00	 mov	 rcx, QWORD PTR gs:392
  0001b	33 db		 xor	 ebx, ebx
  0001d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoIsSystemThread
  00023	3a c3		 cmp	 al, bl
  00025	0f 85 a9 00 00
	00		 jne	 $LN4@IsVolumeAc
  0002b	e8 00 00 00 00	 call	 UserCanAccessDriveDevice
  00030	3b c3		 cmp	 eax, ebx
  00032	0f 85 9c 00 00
	00		 jne	 $LN4@IsVolumeAc
  00038	48 39 9e 88 05
	00 00		 cmp	 QWORD PTR [rsi+1416], rbx
  0003f	0f 84 8f 00 00
	00		 je	 $LN4@IsVolumeAc
  00045	39 9e 54 03 00
	00		 cmp	 DWORD PTR [rsi+852], ebx
  0004b	74 08		 je	 SHORT $LN5@IsVolumeAc
  0004d	39 1d 00 00 00
	00		 cmp	 DWORD PTR NonAdminSystemFavoritesAccessDisabled, ebx
  00053	74 7f		 je	 SHORT $LN4@IsVolumeAc
$LN5@IsVolumeAc:

; 3234 : 	}
; 3235 : 
; 3236 : 	SeCaptureSubjectContext (&subContext);

  00055	48 8d 4c 24 20	 lea	 rcx, QWORD PTR subContext$[rsp]
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeCaptureSubjectContext

; 3237 : 	accessToken = SeQuerySubjectContextToken (&subContext);

  00060	48 39 5c 24 20	 cmp	 QWORD PTR subContext$[rsp], rbx
  00065	48 8b 7c 24 30	 mov	 rdi, QWORD PTR subContext$[rsp+16]
  0006a	48 0f 45 7c 24
	20		 cmovne	 rdi, QWORD PTR subContext$[rsp]

; 3238 : 
; 3239 : 	if (!accessToken)

  00070	48 3b fb	 cmp	 rdi, rbx
  00073	74 50		 je	 SHORT $ret$32981

; 3240 : 		goto ret;
; 3241 : 	
; 3242 : 	if (SeTokenIsAdmin (accessToken))

  00075	48 8b cf	 mov	 rcx, rdi
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeTokenIsAdmin
  0007e	3a c3		 cmp	 al, bl
  00080	74 07		 je	 SHORT $LN2@IsVolumeAc

; 3243 : 	{
; 3244 : 		result = TRUE;

  00082	bb 01 00 00 00	 mov	 ebx, 1

; 3245 : 		goto ret;

  00087	eb 3c		 jmp	 SHORT $ret$32981
$LN2@IsVolumeAc:

; 3246 : 	}
; 3247 : 
; 3248 : 	if (!NT_SUCCESS (SeQueryInformationToken (accessToken, TokenUser, &tokenUser)))

  00089	4c 8d 44 24 58	 lea	 r8, QWORD PTR tokenUser$[rsp]
  0008e	ba 01 00 00 00	 mov	 edx, 1
  00093	48 8b cf	 mov	 rcx, rdi
  00096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeQueryInformationToken
  0009c	3b c3		 cmp	 eax, ebx
  0009e	7c 25		 jl	 SHORT $ret$32981

; 3249 : 		goto ret;
; 3250 : 
; 3251 : 	result = RtlEqualSid (volumeDeviceExtension->UserSid, tokenUser->User.Sid);

  000a0	48 8b 54 24 58	 mov	 rdx, QWORD PTR tokenUser$[rsp]
  000a5	48 8b 8e 88 05
	00 00		 mov	 rcx, QWORD PTR [rsi+1416]
  000ac	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlEqualSid

; 3252 : 	ExFreePool (tokenUser);		// Documented in newer versions of WDK

  000b5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tokenUser$[rsp]
  000ba	33 d2		 xor	 edx, edx
  000bc	0f b6 d8	 movzx	 ebx, al
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$ret$32981:

; 3253 : 
; 3254 : ret:
; 3255 : 	SeReleaseSubjectContext (&subContext);

  000c5	48 8d 4c 24 20	 lea	 rcx, QWORD PTR subContext$[rsp]
  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeReleaseSubjectContext

; 3256 : 	return result;

  000d0	8b c3		 mov	 eax, ebx
  000d2	eb 05		 jmp	 SHORT $LN6@IsVolumeAc
$LN4@IsVolumeAc:

; 3232 : 	{
; 3233 : 		return TRUE;

  000d4	b8 01 00 00 00	 mov	 eax, 1
$LN6@IsVolumeAc:

; 3257 : }

  000d9	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000de	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  000e3	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000e7	5f		 pop	 rdi
  000e8	c3		 ret	 0
IsVolumeAccessibleByCurrentUser ENDP
_TEXT	ENDS
PUBLIC	GetDeviceSectorSize
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetDeviceSectorSize DD imagerel $LN4
	DD	imagerel $LN4+61
	DD	imagerel $unwind$GetDeviceSectorSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetDeviceSectorSize DD 020601H
	DD	030029206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GetDeviceSectorSize
_TEXT	SEGMENT
geometry$ = 48
deviceObject$ = 96
bytesPerSector$ = 104
GetDeviceSectorSize PROC				; COMDAT

; 3137 : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 3138 : 	NTSTATUS status;
; 3139 : 	DISK_GEOMETRY geometry;
; 3140 : 
; 3141 : 	status = SendDeviceIoControlRequest (deviceObject, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &geometry, sizeof (geometry));

  00006	48 8d 44 24 30	 lea	 rax, QWORD PTR geometry$[rsp]
  0000b	48 8b da	 mov	 rbx, rdx
  0000e	45 33 c9	 xor	 r9d, r9d
  00011	45 33 c0	 xor	 r8d, r8d
  00014	ba 00 00 07 00	 mov	 edx, 458752		; 00070000H
  00019	c7 44 24 28 18
	00 00 00	 mov	 DWORD PTR [rsp+40], 24
  00021	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00026	e8 00 00 00 00	 call	 SendDeviceIoControlRequest

; 3142 : 
; 3143 : 	if (!NT_SUCCESS (status))

  0002b	85 c0		 test	 eax, eax

; 3144 : 		return status;

  0002d	78 08		 js	 SHORT $LN2@GetDeviceS

; 3145 : 
; 3146 : 	*bytesPerSector = geometry.BytesPerSector;

  0002f	8b 44 24 44	 mov	 eax, DWORD PTR geometry$[rsp+20]
  00033	89 03		 mov	 DWORD PTR [rbx], eax

; 3147 : 	return STATUS_SUCCESS;

  00035	33 c0		 xor	 eax, eax
$LN2@GetDeviceS:

; 3148 : }

  00037	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0003b	5b		 pop	 rbx
  0003c	c3		 ret	 0
GetDeviceSectorSize ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	MountManagerUnmount
;	COMDAT pdata
pdata	SEGMENT
$pdata$MountManagerUnmount DD imagerel $LN3
	DD	imagerel $LN3+171
	DD	imagerel $unwind$MountManagerUnmount
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MountManagerUnmount DD 031b19H
	DD	04e0109H
	DD	07002H
	DD	imagerel __GSHandlerCheck
	DD	0260H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT MountManagerUnmount
_TEXT	SEGMENT
buf$ = 48
out$ = 304
__$ArrayPad$ = 608
nDosDriveNo$ = 640
MountManagerUnmount PROC				; COMDAT

; 2491 : {

$LN3:
  00000	40 57		 push	 rdi
  00002	48 81 ec 70 02
	00 00		 sub	 rsp, 624		; 00000270H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0001b	8b f9		 mov	 edi, ecx

; 2492 : 	NTSTATUS ntStatus; 
; 2493 : 	char buf[256], out[300];
; 2494 : 	PMOUNTMGR_MOUNT_POINT in = (PMOUNTMGR_MOUNT_POINT) buf;
; 2495 : 
; 2496 : 	memset (buf, 0, sizeof buf);

  0001d	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  00022	33 d2		 xor	 edx, edx
  00024	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0002a	e8 00 00 00 00	 call	 memset

; 2497 : 
; 2498 : 	TCGetDosNameFromNumber ((PWSTR) &in[1], nDosDriveNo);

  0002f	48 8d 4c 24 48	 lea	 rcx, QWORD PTR buf$[rsp+24]
  00034	8b d7		 mov	 edx, edi
  00036	e8 00 00 00 00	 call	 TCGetDosNameFromNumber

; 2499 : 
; 2500 : 	// Only symbolic link can be deleted with IOCTL_MOUNTMGR_DELETE_POINTS. If any other entry is specified, the mount manager will ignore subsequent IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION for the same volume ID.
; 2501 : 	in->SymbolicLinkNameOffset = sizeof (MOUNTMGR_MOUNT_POINT);
; 2502 : 	in->SymbolicLinkNameLength = (USHORT) wcslen ((PWCHAR) &in[1]) * 2;

  0003b	48 83 c9 ff	 or	 rcx, -1
  0003f	33 c0		 xor	 eax, eax
  00041	c7 44 24 30 18
	00 00 00	 mov	 DWORD PTR buf$[rsp], 24
  00049	48 8d 7c 24 48	 lea	 rdi, QWORD PTR buf$[rsp+24]

; 2503 : 
; 2504 : 	ntStatus = TCDeviceIoControl (MOUNTMGR_DEVICE_NAME, IOCTL_MOUNTMGR_DELETE_POINTS,
; 2505 : 		in, sizeof(MOUNTMGR_MOUNT_POINT) + in->SymbolicLinkNameLength, out, sizeof out);

  0004e	4c 8d 44 24 30	 lea	 r8, QWORD PTR buf$[rsp]
  00053	66 f2 af	 repne scasw
  00056	48 8d 84 24 30
	01 00 00	 lea	 rax, QWORD PTR out$[rsp]
  0005e	ba 04 c0 6d 00	 mov	 edx, 7192580		; 006dc004H
  00063	48 f7 d1	 not	 rcx
  00066	c7 44 24 28 2c
	01 00 00	 mov	 DWORD PTR [rsp+40], 300	; 0000012cH
  0006e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00073	48 ff c9	 dec	 rcx
  00076	66 03 c9	 add	 cx, cx

; 2506 : 
; 2507 : 	Dump ("IOCTL_MOUNTMGR_DELETE_POINTS returned 0x%08x\n", ntStatus);
; 2508 : 
; 2509 : 	return ntStatus;

  00079	44 0f b7 c9	 movzx	 r9d, cx
  0007d	66 89 4c 24 34	 mov	 WORD PTR buf$[rsp+4], cx
  00082	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
  00089	41 83 c1 18	 add	 r9d, 24
  0008d	e8 00 00 00 00	 call	 TCDeviceIoControl

; 2510 : }

  00092	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0009a	48 33 cc	 xor	 rcx, rsp
  0009d	e8 00 00 00 00	 call	 __security_check_cookie
  000a2	48 81 c4 70 02
	00 00		 add	 rsp, 624		; 00000270H
  000a9	5f		 pop	 rdi
  000aa	c3		 ret	 0
MountManagerUnmount ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	MountManagerMount
;	COMDAT pdata
pdata	SEGMENT
$pdata$MountManagerMount DD imagerel $LN5
	DD	imagerel $LN5+415
	DD	imagerel $unwind$MountManagerMount
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MountManagerMount DD 092919H
	DD	06b6417H
	DD	06a5417H
	DD	0693417H
	DD	0660117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0320H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT MountManagerMount
_TEXT	SEGMENT
devName$ = 48
symName$ = 64
buf$ = 80
arrVolume$ = 288
__$ArrayPad$ = 800
mount$ = 832
MountManagerMount PROC					; COMDAT

; 2454 : {

$LN5:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 10	 mov	 QWORD PTR [r11+16], rbx
  00007	49 89 6b 18	 mov	 QWORD PTR [r11+24], rbp
  0000b	49 89 73 20	 mov	 QWORD PTR [r11+32], rsi
  0000f	57		 push	 rdi
  00010	48 81 ec 30 03
	00 00		 sub	 rsp, 816		; 00000330H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 20
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2455 : 	NTSTATUS ntStatus; 
; 2456 : 	WCHAR arrVolume[256];
; 2457 : 	char buf[200];
; 2458 : 	PMOUNTMGR_TARGET_NAME in = (PMOUNTMGR_TARGET_NAME) buf;
; 2459 : 	PMOUNTMGR_CREATE_POINT_INPUT point = (PMOUNTMGR_CREATE_POINT_INPUT) buf;
; 2460 : 	UNICODE_STRING symName, devName;
; 2461 : 
; 2462 : 	TCGetNTNameFromNumber (arrVolume, mount->nDosDriveNo);

  00029	8b 91 64 02 00
	00		 mov	 edx, DWORD PTR [rcx+612]
  0002f	48 8b d9	 mov	 rbx, rcx
  00032	49 8d 8b e8 fd
	ff ff		 lea	 rcx, QWORD PTR [r11-536]
  00039	e8 00 00 00 00	 call	 TCGetNTNameFromNumber

; 2463 : 	in->DeviceNameLength = (USHORT) wcslen (arrVolume) * 2;

  0003e	33 c0		 xor	 eax, eax
  00040	48 83 cd ff	 or	 rbp, -1
  00044	48 8d bc 24 20
	01 00 00	 lea	 rdi, QWORD PTR arrVolume$[rsp]
  0004c	48 8b cd	 mov	 rcx, rbp
  0004f	66 f2 af	 repne scasw
  00052	48 f7 d1	 not	 rcx
  00055	48 ff c9	 dec	 rcx
  00058	0f b7 c1	 movzx	 eax, cx
  0005b	66 03 c0	 add	 ax, ax

; 2464 : 	wcscpy(in->DeviceName, arrVolume);

  0005e	33 f6		 xor	 esi, esi
  00060	48 8b d6	 mov	 rdx, rsi
  00063	66 89 44 24 50	 mov	 WORD PTR buf$[rsp], ax
$LL3@MountManag:
  00068	0f b7 84 14 20
	01 00 00	 movzx	 eax, WORD PTR arrVolume$[rsp+rdx]
  00070	48 83 c2 02	 add	 rdx, 2
  00074	66 89 44 14 50	 mov	 WORD PTR buf$[rsp+rdx], ax
  00079	66 3b c6	 cmp	 ax, si
  0007c	75 ea		 jne	 SHORT $LL3@MountManag

; 2465 : 
; 2466 : 	ntStatus = TCDeviceIoControl (MOUNTMGR_DEVICE_NAME, IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION,
; 2467 : 		in, (ULONG) (sizeof (in->DeviceNameLength) + wcslen (arrVolume) * 2), 0, 0);

  0007e	44 8d 4c 09 02	 lea	 r9d, DWORD PTR [rcx+rcx+2]
  00083	4c 8d 44 24 50	 lea	 r8, QWORD PTR buf$[rsp]
  00088	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
  0008f	ba 2c 40 6d 00	 mov	 edx, 7159852		; 006d402cH
  00094	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00098	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0009d	e8 00 00 00 00	 call	 TCDeviceIoControl

; 2468 : 
; 2469 : 	memset (buf, 0, sizeof buf);

  000a2	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  000a7	33 d2		 xor	 edx, edx
  000a9	41 b8 c8 00 00
	00		 mov	 r8d, 200		; 000000c8H
  000af	e8 00 00 00 00	 call	 memset

; 2470 : 	TCGetDosNameFromNumber ((PWSTR) &point[1], mount->nDosDriveNo);

  000b4	8b 93 64 02 00
	00		 mov	 edx, DWORD PTR [rbx+612]
  000ba	48 8d 4c 24 58	 lea	 rcx, QWORD PTR buf$[rsp+8]
  000bf	e8 00 00 00 00	 call	 TCGetDosNameFromNumber

; 2471 : 
; 2472 : 	point->SymbolicLinkNameOffset = sizeof (MOUNTMGR_CREATE_POINT_INPUT);

  000c4	ba 08 00 00 00	 mov	 edx, 8

; 2473 : 	point->SymbolicLinkNameLength = (USHORT) wcslen ((PWSTR) &point[1]) * 2;

  000c9	33 c0		 xor	 eax, eax
  000cb	66 89 54 24 50	 mov	 WORD PTR buf$[rsp], dx
  000d0	48 8d 7c 24 58	 lea	 rdi, QWORD PTR buf$[rsp+8]
  000d5	48 8b cd	 mov	 rcx, rbp
  000d8	66 f2 af	 repne scasw

; 2474 : 
; 2475 : 	RtlInitUnicodeString(&symName, (PWSTR) (buf + point->SymbolicLinkNameOffset));

  000db	48 8d 54 24 58	 lea	 rdx, QWORD PTR buf$[rsp+8]
  000e0	48 f7 d1	 not	 rcx
  000e3	48 ff c9	 dec	 rcx
  000e6	66 03 c9	 add	 cx, cx
  000e9	66 89 4c 24 52	 mov	 WORD PTR buf$[rsp+2], cx
  000ee	48 8d 4c 24 40	 lea	 rcx, QWORD PTR symName$[rsp]
  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2476 : 
; 2477 : 	point->DeviceNameOffset = point->SymbolicLinkNameOffset + point->SymbolicLinkNameLength;

  000f9	0f b7 54 24 52	 movzx	 edx, WORD PTR buf$[rsp+2]
  000fe	66 03 54 24 50	 add	 dx, WORD PTR buf$[rsp]

; 2478 : 	TCGetNTNameFromNumber ((PWSTR) (buf + point->DeviceNameOffset), mount->nDosDriveNo);

  00103	0f b7 c2	 movzx	 eax, dx
  00106	66 89 54 24 54	 mov	 WORD PTR buf$[rsp+4], dx
  0010b	8b 93 64 02 00
	00		 mov	 edx, DWORD PTR [rbx+612]
  00111	48 8d 4c 04 50	 lea	 rcx, QWORD PTR buf$[rsp+rax]
  00116	e8 00 00 00 00	 call	 TCGetNTNameFromNumber

; 2479 : 	point->DeviceNameLength = (USHORT) wcslen ((PWSTR) (buf + point->DeviceNameOffset)) * 2;

  0011b	0f b7 54 24 54	 movzx	 edx, WORD PTR buf$[rsp+4]
  00120	33 c0		 xor	 eax, eax
  00122	48 8d 54 14 50	 lea	 rdx, QWORD PTR buf$[rsp+rdx]
  00127	48 8b cd	 mov	 rcx, rbp
  0012a	48 8b fa	 mov	 rdi, rdx
  0012d	66 f2 af	 repne scasw
  00130	48 f7 d1	 not	 rcx
  00133	48 ff c9	 dec	 rcx
  00136	66 03 c9	 add	 cx, cx
  00139	66 89 4c 24 56	 mov	 WORD PTR buf$[rsp+6], cx

; 2480 : 
; 2481 : 	RtlInitUnicodeString(&devName, (PWSTR) (buf + point->DeviceNameOffset));

  0013e	48 8d 4c 24 30	 lea	 rcx, QWORD PTR devName$[rsp]
  00143	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2482 : 
; 2483 : 	ntStatus = TCDeviceIoControl (MOUNTMGR_DEVICE_NAME, IOCTL_MOUNTMGR_CREATE_POINT, point,
; 2484 : 		point->DeviceNameOffset + point->DeviceNameLength, 0, 0);
; 2485 : 
; 2486 : 	return ntStatus;

  00149	44 0f b7 4c 24
	56		 movzx	 r9d, WORD PTR buf$[rsp+6]
  0014f	0f b7 44 24 54	 movzx	 eax, WORD PTR buf$[rsp+4]
  00154	4c 8d 44 24 50	 lea	 r8, QWORD PTR buf$[rsp]
  00159	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
  00160	44 03 c8	 add	 r9d, eax
  00163	ba 00 c0 6d 00	 mov	 edx, 7192576		; 006dc000H
  00168	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  0016c	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00171	e8 00 00 00 00	 call	 TCDeviceIoControl

; 2487 : }

  00176	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0017e	48 33 cc	 xor	 rcx, rsp
  00181	e8 00 00 00 00	 call	 __security_check_cookie
  00186	4c 8d 9c 24 30
	03 00 00	 lea	 r11, QWORD PTR [rsp+816]
  0018e	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  00192	49 8b 6b 20	 mov	 rbp, QWORD PTR [r11+32]
  00196	49 8b 73 28	 mov	 rsi, QWORD PTR [r11+40]
  0019a	49 8b e3	 mov	 rsp, r11
  0019d	5f		 pop	 rdi
  0019e	c3		 ret	 0
MountManagerMount ENDP
_TEXT	ENDS
PUBLIC	ProbeRealDriveSize
;	COMDAT pdata
pdata	SEGMENT
$pdata$ProbeRealDriveSize DD imagerel $LN21
	DD	imagerel $LN21+292
	DD	imagerel $unwind$ProbeRealDriveSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ProbeRealDriveSize DD 0a1801H
	DD	0d6418H
	DD	0b5418H
	DD	0a3418H
	DD	0d0145218H
	DD	07010c012H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ProbeRealDriveSize
_TEXT	SEGMENT
driveDeviceObject$ = 80
driveSize$ = 88
sysLength$ = 96
ProbeRealDriveSize PROC					; COMDAT

; 2238 : {

$LN21:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00018	48 8b fa	 mov	 rdi, rdx
  0001b	48 8b e9	 mov	 rbp, rcx

; 2239 : 	NTSTATUS status;
; 2240 : 	LARGE_INTEGER sysLength;
; 2241 : 	LARGE_INTEGER offset;
; 2242 : 	byte *sectorBuffer;
; 2243 : 	ULONGLONG startTime;
; 2244 : 
; 2245 : 	if (!UserCanAccessDriveDevice())

  0001e	e8 00 00 00 00	 call	 UserCanAccessDriveDevice
  00023	85 c0		 test	 eax, eax
  00025	75 0a		 jne	 SHORT $LN9@ProbeRealD

; 2246 : 		return STATUS_ACCESS_DENIED;

  00027	b8 22 00 00 c0	 mov	 eax, -1073741790	; ffffffffc0000022H
  0002c	e9 da 00 00 00	 jmp	 $LN4@ProbeRealD
$LN9@ProbeRealD:

; 2247 : 
; 2248 : 	sectorBuffer = TCalloc (TC_SECTOR_SIZE_BIOS);

  00031	41 bd 00 02 00
	00		 mov	 r13d, 512		; 00000200H
  00037	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  0003d	33 c9		 xor	 ecx, ecx
  0003f	49 8b d5	 mov	 rdx, r13
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00048	48 8b f0	 mov	 rsi, rax

; 2249 : 	if (!sectorBuffer)

  0004b	48 85 c0	 test	 rax, rax
  0004e	75 0a		 jne	 SHORT $LN8@ProbeRealD

; 2250 : 		return STATUS_INSUFFICIENT_RESOURCES;

  00050	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  00055	e9 b1 00 00 00	 jmp	 $LN4@ProbeRealD
$LN8@ProbeRealD:

; 2251 : 
; 2252 : 	status = SendDeviceIoControlRequest (driveDeviceObject, IOCTL_DISK_GET_LENGTH_INFO,
; 2253 : 		NULL, 0, &sysLength, sizeof (sysLength));

  0005a	48 8d 44 24 60	 lea	 rax, QWORD PTR sysLength$[rsp]
  0005f	45 33 c9	 xor	 r9d, r9d
  00062	45 33 c0	 xor	 r8d, r8d
  00065	ba 5c 40 07 00	 mov	 edx, 475228		; 0007405cH
  0006a	48 8b cd	 mov	 rcx, rbp
  0006d	c7 44 24 28 08
	00 00 00	 mov	 DWORD PTR [rsp+40], 8
  00075	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007a	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  0007f	8b d8		 mov	 ebx, eax

; 2254 : 
; 2255 : 	if (!NT_SUCCESS (status))

  00081	85 c0		 test	 eax, eax
  00083	78 76		 js	 SHORT $LN20@ProbeRealD

; 2256 : 	{
; 2257 : 		Dump ("Failed to get drive size - error %x\n", status);
; 2258 : 		TCfree (sectorBuffer);
; 2259 : 		return status;
; 2260 : 	}
; 2261 : 
; 2262 : 	startTime = KeQueryInterruptTime ();

  00085	49 bc 08 00 00
	00 80 f7 ff ff	 mov	 r12, -9345848836088	; fffff78000000008H
  0008f	4d 8b 24 24	 mov	 r12, QWORD PTR [r12]

; 2263 : 	for (offset.QuadPart = sysLength.QuadPart; ; offset.QuadPart += TC_SECTOR_SIZE_BIOS)

  00093	48 8b 5c 24 60	 mov	 rbx, QWORD PTR sysLength$[rsp]
$LL6@ProbeRealD:

; 2264 : 	{
; 2265 : 		status = TCReadDevice (driveDeviceObject, sectorBuffer, offset, TC_SECTOR_SIZE_BIOS);

  00098	4c 8b cb	 mov	 r9, rbx
  0009b	4c 8b c6	 mov	 r8, rsi
  0009e	48 8b d5	 mov	 rdx, rbp
  000a1	33 c9		 xor	 ecx, ecx
  000a3	44 89 6c 24 20	 mov	 DWORD PTR [rsp+32], r13d
  000a8	e8 00 00 00 00	 call	 TCReadWriteDevice

; 2266 : 		
; 2267 : 		if (NT_SUCCESS (status))

  000ad	85 c0		 test	 eax, eax
  000af	78 45		 js	 SHORT $LN18@ProbeRealD

; 2268 : 			status = TCWriteDevice (driveDeviceObject, sectorBuffer, offset, TC_SECTOR_SIZE_BIOS);

  000b1	4c 8b cb	 mov	 r9, rbx
  000b4	4c 8b c6	 mov	 r8, rsi
  000b7	48 8b d5	 mov	 rdx, rbp
  000ba	b9 01 00 00 00	 mov	 ecx, 1
  000bf	44 89 6c 24 20	 mov	 DWORD PTR [rsp+32], r13d
  000c4	e8 00 00 00 00	 call	 TCReadWriteDevice

; 2269 : 
; 2270 : 		if (!NT_SUCCESS (status))

  000c9	85 c0		 test	 eax, eax
  000cb	78 29		 js	 SHORT $LN18@ProbeRealD

; 2273 : 			Dump ("Real drive size = %I64d bytes (%I64d hidden)\n", driveSize->QuadPart, driveSize->QuadPart - sysLength.QuadPart);
; 2274 : 			TCfree (sectorBuffer);
; 2275 : 			return STATUS_SUCCESS;
; 2276 : 		}
; 2277 : 
; 2278 : 		if (KeQueryInterruptTime() - startTime > 3ULL * 60 * 1000 * 1000 * 10)

  000cd	48 a1 08 00 00
	00 80 f7 ff ff	 mov	 rax, QWORD PTR ds:-9345848836088
  000d7	49 2b c4	 sub	 rax, r12
  000da	48 3d 00 d2 49
	6b		 cmp	 rax, 1800000000		; 6b49d200H
  000e0	77 05		 ja	 SHORT $LN19@ProbeRealD

; 2263 : 	for (offset.QuadPart = sysLength.QuadPart; ; offset.QuadPart += TC_SECTOR_SIZE_BIOS)

  000e2	49 03 dd	 add	 rbx, r13
  000e5	eb b1		 jmp	 SHORT $LL6@ProbeRealD
$LN19@ProbeRealD:

; 2279 : 		{
; 2280 : 			// Abort if probing for more than 3 minutes
; 2281 : 			driveSize->QuadPart = sysLength.QuadPart;

  000e7	48 8b 44 24 60	 mov	 rax, QWORD PTR sysLength$[rsp]
  000ec	bb 02 01 00 00	 mov	 ebx, 258		; 00000102H
  000f1	48 89 07	 mov	 QWORD PTR [rdi], rax
  000f4	eb 05		 jmp	 SHORT $LN20@ProbeRealD
$LN18@ProbeRealD:

; 2271 : 		{
; 2272 : 			driveSize->QuadPart = offset.QuadPart;

  000f6	48 89 1f	 mov	 QWORD PTR [rdi], rbx
  000f9	33 db		 xor	 ebx, ebx
$LN20@ProbeRealD:
  000fb	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00100	48 8b ce	 mov	 rcx, rsi
  00103	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
  00109	8b c3		 mov	 eax, ebx
$LN4@ProbeRealD:

; 2282 : 			TCfree (sectorBuffer);
; 2283 : 			return STATUS_TIMEOUT;
; 2284 : 		}
; 2285 : 	}
; 2286 : }

  0010b	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00110	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00115	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  0011a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0011e	41 5d		 pop	 r13
  00120	41 5c		 pop	 r12
  00122	5f		 pop	 rdi
  00123	c3		 ret	 0
ProbeRealDriveSize ENDP
_TEXT	ENDS
PUBLIC	TCUnloadDriver
;	COMDAT pdata
; File c:\home\public\desktop\projects\ciphershed.build\src\driver\drivefilter.c
pdata	SEGMENT
$pdata$TCUnloadDriver DD imagerel $LN10
	DD	imagerel $LN10+91
	DD	imagerel $unwind$TCUnloadDriver
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCUnloadDriver DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed.build\src\driver\ntdriver.c
xdata	ENDS
;	COMDAT TCUnloadDriver
_TEXT	SEGMENT
DriverObject$ = 64
TCUnloadDriver PROC					; COMDAT

; 2093 : {

$LN10:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2094 : 	Dump ("TCUnloadDriver BEGIN\n");
; 2095 : 
; 2096 : 	OnShutdownPending();

  00004	e8 00 00 00 00	 call	 OnShutdownPending

; 2097 : 
; 2098 : 	if (IsBootDriveMounted())

  00009	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR BootDriveFilterExtension
  00010	4d 85 db	 test	 r11, r11
  00013	74 2d		 je	 SHORT $LN1@TCUnloadDr
  00015	41 83 bb b8 02
	00 00 00	 cmp	 DWORD PTR [r11+696], 0
  0001d	74 23		 je	 SHORT $LN1@TCUnloadDr

; 2099 : 		TC_BUG_CHECK (STATUS_INVALID_DEVICE_STATE);

  0001f	45 33 c9	 xor	 r9d, r9d
  00022	ba 33 08 00 00	 mov	 edx, 2099		; 00000833H
  00027	49 c7 c0 84 01
	00 c0		 mov	 r8, -1073741436		; ffffffffc0000184H
  0002e	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00032	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00041	cc		 int	 3
$LN1@TCUnloadDr:

; 2100 : 
; 2101 : 	EncryptionThreadPoolStop();

  00042	e8 00 00 00 00	 call	 EncryptionThreadPoolStop

; 2102 : 	TCDeleteDeviceObject (RootDeviceObject, (PEXTENSION) RootDeviceObject->DeviceExtension);

  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR RootDeviceObject
  0004e	48 8b 51 40	 mov	 rdx, QWORD PTR [rcx+64]

; 2103 : 
; 2104 : 	Dump ("TCUnloadDriver END\n");
; 2105 : }

  00052	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00056	e9 00 00 00 00	 jmp	 TCDeleteDeviceObject
$LN9@TCUnloadDr:
TCUnloadDriver ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	ProcessVolumeDeviceControlIrp
;	COMDAT pdata
pdata	SEGMENT
$pdata$ProcessVolumeDeviceControlIrp DD imagerel $LN68
	DD	imagerel $LN68+1545
	DD	imagerel $unwind$ProcessVolumeDeviceControlIrp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ProcessVolumeDeviceControlIrp DD 092819H
	DD	0695416H
	DD	0663416H
	DD	0620116H
	DD	0c00dd00fH
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	0300H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ProcessVolumeDeviceControlIrp
_TEXT	SEGMENT
tmp$31594 = 80
offset$31676 = 88
ntUnicodeString$31609 = 88
ntUnicodeString$31576 = 88
ioStatus$31670 = 104
volId$31593 = 128
ntName$31610 = 256
ntName$31577 = 256
__$ArrayPad$ = 768
DeviceObject$ = 816
Extension$ = 824
Irp$ = 832
ProcessVolumeDeviceControlIrp PROC			; COMDAT

; 496  : {

$LN68:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	57		 push	 rdi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	48 81 ec 10 03
	00 00		 sub	 rsp, 784		; 00000310H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 00
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 497  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);

  00028	4d 8b a0 b8 00
	00 00		 mov	 r12, QWORD PTR [r8+184]

; 498  : 
; 499  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  0002f	b9 5c 40 07 00	 mov	 ecx, 475228		; 0007405cH
  00034	49 8b d8	 mov	 rbx, r8
  00037	41 8b 44 24 18	 mov	 eax, DWORD PTR [r12+24]
  0003c	48 8b fa	 mov	 rdi, rdx
  0003f	3b c1		 cmp	 eax, ecx
  00041	0f 87 03 03 00
	00		 ja	 $LN50@ProcessVol
  00047	0f 84 c0 02 00
	00		 je	 $LN22@ProcessVol
  0004d	2d 00 00 07 00	 sub	 eax, 458752		; 00070000H
  00052	0f 84 53 02 00
	00		 je	 $LN30@ProcessVol
  00058	83 e8 14	 sub	 eax, 20
  0005b	0f 84 52 01 00
	00		 je	 $LN19@ProcessVol
  00061	83 e8 10	 sub	 eax, 16
  00064	0f 84 2b 01 00
	00		 je	 $LN10@ProcessVol
  0006a	83 e8 24	 sub	 eax, 36			; 00000024H
  0006d	0f 84 ca 00 00
	00		 je	 $LN26@ProcessVol
  00073	2d b8 0b 00 00	 sub	 eax, 3000		; 00000bb8H
  00078	0f 84 2d 02 00
	00		 je	 $LN30@ProcessVol
  0007e	2d 04 34 00 00	 sub	 eax, 13316		; 00003404H
  00083	74 66		 je	 SHORT $LN28@ProcessVol
  00085	83 f8 08	 cmp	 eax, 8
  00088	0f 85 01 03 00
	00		 jne	 $LN1@ProcessVol

; 665  : 
; 666  : 	case IOCTL_DISK_GET_DRIVE_LAYOUT:
; 667  : 		if (ValidateIOBufferSize (Irp, sizeof (DRIVE_LAYOUT_INFORMATION), ValidateOutput))

  0008e	8d 50 20	 lea	 edx, QWORD PTR [rax+32]
  00091	44 8d 40 f9	 lea	 r8d, QWORD PTR [rax-7]
  00095	48 8b cb	 mov	 rcx, rbx
  00098	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0009d	85 c0		 test	 eax, eax
  0009f	0f 84 28 05 00
	00		 je	 $LN11@ProcessVol

; 668  : 		{
; 669  : 			PDRIVE_LAYOUT_INFORMATION outputBuffer = (PDRIVE_LAYOUT_INFORMATION)
; 670  : 			Irp->AssociatedIrp.SystemBuffer;

  000a5	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]

; 671  : 
; 672  : 			outputBuffer->PartitionCount = 1;
; 673  : 			outputBuffer->Signature = 0;
; 674  : 
; 675  : 			outputBuffer->PartitionEntry->PartitionType = Extension->PartitionType;
; 676  : 			outputBuffer->PartitionEntry->BootIndicator = FALSE;
; 677  : 			outputBuffer->PartitionEntry->RecognizedPartition = TRUE;
; 678  : 			outputBuffer->PartitionEntry->RewritePartition = FALSE;
; 679  : 			outputBuffer->PartitionEntry->StartingOffset.QuadPart = Extension->BytesPerSector;
; 680  : 			outputBuffer->PartitionEntry->PartitionLength.QuadPart = Extension->DiskLength;
; 681  : 			outputBuffer->PartitionEntry->HiddenSectors = 0;
; 682  : 
; 683  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 684  : 			Irp->IoStatus.Information = sizeof (PARTITION_INFORMATION);

  000a9	bd 20 00 00 00	 mov	 ebp, 32			; 00000020H
  000ae	83 61 04 00	 and	 DWORD PTR [rcx+4], 0
  000b2	c7 01 01 00 00
	00		 mov	 DWORD PTR [rcx], 1
  000b8	8a 87 bc 00 00
	00		 mov	 al, BYTE PTR [rdi+188]
  000be	88 41 20	 mov	 BYTE PTR [rcx+32], al
  000c1	c6 41 21 00	 mov	 BYTE PTR [rcx+33], 0
  000c5	c6 41 22 01	 mov	 BYTE PTR [rcx+34], 1
  000c9	c6 41 23 00	 mov	 BYTE PTR [rcx+35], 0
  000cd	8b 87 b8 00 00
	00		 mov	 eax, DWORD PTR [rdi+184]
  000d3	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  000d7	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
  000de	83 61 18 00	 and	 DWORD PTR [rcx+24], 0
  000e2	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 685  : 		}
; 686  : 		break;

  000e6	e9 15 02 00 00	 jmp	 $LN63@ProcessVol
$LN28@ProcessVol:

; 629  : 
; 630  : 	case IOCTL_DISK_GET_PARTITION_INFO:
; 631  : 		if (ValidateIOBufferSize (Irp, sizeof (PARTITION_INFORMATION), ValidateOutput))

  000eb	bd 20 00 00 00	 mov	 ebp, 32			; 00000020H
  000f0	48 8b cb	 mov	 rcx, rbx
  000f3	44 8d 45 e1	 lea	 r8d, QWORD PTR [rbp-31]
  000f7	48 8b d5	 mov	 rdx, rbp
  000fa	e8 00 00 00 00	 call	 ValidateIOBufferSize
  000ff	85 c0		 test	 eax, eax
  00101	0f 84 c6 04 00
	00		 je	 $LN11@ProcessVol

; 632  : 		{
; 633  : 			PPARTITION_INFORMATION outputBuffer = (PPARTITION_INFORMATION)
; 634  : 			Irp->AssociatedIrp.SystemBuffer;
; 635  : 
; 636  : 			outputBuffer->PartitionType = Extension->PartitionType;

  00107	8a 87 bc 00 00
	00		 mov	 al, BYTE PTR [rdi+188]
  0010d	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
  00111	88 41 18	 mov	 BYTE PTR [rcx+24], al

; 637  : 			outputBuffer->BootIndicator = FALSE;

  00114	c6 41 19 00	 mov	 BYTE PTR [rcx+25], 0

; 638  : 			outputBuffer->RecognizedPartition = TRUE;

  00118	c6 41 1a 01	 mov	 BYTE PTR [rcx+26], 1

; 639  : 			outputBuffer->RewritePartition = FALSE;

  0011c	c6 41 1b 00	 mov	 BYTE PTR [rcx+27], 0

; 640  : 			outputBuffer->StartingOffset.QuadPart = Extension->BytesPerSector;

  00120	8b 87 b8 00 00
	00		 mov	 eax, DWORD PTR [rdi+184]
  00126	48 89 01	 mov	 QWORD PTR [rcx], rax

; 641  : 			outputBuffer->PartitionLength.QuadPart= Extension->DiskLength;

  00129	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]

; 642  : 			outputBuffer->HiddenSectors = 0;

  00130	83 61 10 00	 and	 DWORD PTR [rcx+16], 0
  00134	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 643  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 644  : 			Irp->IoStatus.Information = sizeof (PARTITION_INFORMATION);
; 645  : 		}
; 646  : 		break;

  00138	e9 c3 01 00 00	 jmp	 $LN63@ProcessVol
$LN26@ProcessVol:

; 647  : 
; 648  : 	case IOCTL_DISK_GET_PARTITION_INFO_EX:
; 649  : 		if (ValidateIOBufferSize (Irp, sizeof (PARTITION_INFORMATION_EX), ValidateOutput))

  0013d	bd 90 00 00 00	 mov	 ebp, 144		; 00000090H
  00142	41 b8 01 00 00
	00		 mov	 r8d, 1
  00148	48 8b cb	 mov	 rcx, rbx
  0014b	48 8b d5	 mov	 rdx, rbp
  0014e	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00153	85 c0		 test	 eax, eax
  00155	0f 84 72 04 00
	00		 je	 $LN11@ProcessVol

; 650  : 		{
; 651  : 			PPARTITION_INFORMATION_EX outputBuffer = (PPARTITION_INFORMATION_EX) Irp->AssociatedIrp.SystemBuffer;

  0015b	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]

; 652  : 
; 653  : 			outputBuffer->PartitionStyle = PARTITION_STYLE_MBR;

  0015f	83 21 00	 and	 DWORD PTR [rcx], 0

; 654  : 			outputBuffer->RewritePartition = FALSE;

  00162	c6 41 1c 00	 mov	 BYTE PTR [rcx+28], 0

; 655  : 			outputBuffer->StartingOffset.QuadPart = Extension->BytesPerSector;

  00166	8b 87 b8 00 00
	00		 mov	 eax, DWORD PTR [rdi+184]
  0016c	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 656  : 			outputBuffer->PartitionLength.QuadPart= Extension->DiskLength;

  00170	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
  00177	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 657  : 			outputBuffer->Mbr.PartitionType = Extension->PartitionType;

  0017b	8a 87 bc 00 00
	00		 mov	 al, BYTE PTR [rdi+188]

; 658  : 			outputBuffer->Mbr.BootIndicator = FALSE;
; 659  : 			outputBuffer->Mbr.RecognizedPartition = TRUE;
; 660  : 			outputBuffer->Mbr.HiddenSectors = 0;

  00181	83 61 24 00	 and	 DWORD PTR [rcx+36], 0
  00185	88 41 20	 mov	 BYTE PTR [rcx+32], al
  00188	c6 41 21 00	 mov	 BYTE PTR [rcx+33], 0
  0018c	c6 41 22 01	 mov	 BYTE PTR [rcx+34], 1

; 661  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 662  : 			Irp->IoStatus.Information = sizeof (PARTITION_INFORMATION_EX);
; 663  : 		}
; 664  : 		break;

  00190	e9 6b 01 00 00	 jmp	 $LN63@ProcessVol
$LN10@ProcessVol:

; 748  : 			}
; 749  : 		}
; 750  : 		break;
; 751  : 
; 752  : 	case IOCTL_DISK_IS_WRITABLE:
; 753  : 		{
; 754  : 			if (Extension->bReadOnly)

  00195	8b 82 40 03 00
	00		 mov	 eax, DWORD PTR [rdx+832]
  0019b	f7 d8		 neg	 eax
  0019d	1b c9		 sbb	 ecx, ecx
  0019f	81 e1 a2 00 00
	c0		 and	 ecx, -1073741662	; ffffffffc00000a2H
  001a5	41 89 48 30	 mov	 DWORD PTR [r8+48], ecx
$LN66@ProcessVol:

; 755  : 				Irp->IoStatus.Status = STATUS_MEDIA_WRITE_PROTECTED;
; 756  : 			else
; 757  : 				Irp->IoStatus.Status = STATUS_SUCCESS;
; 758  : 			Irp->IoStatus.Information = 0;

  001a9	49 83 60 38 00	 and	 QWORD PTR [r8+56], 0

; 759  : 
; 760  : 		}
; 761  : 		break;

  001ae	e9 1a 04 00 00	 jmp	 $LN11@ProcessVol
$LN19@ProcessVol:

; 703  : 
; 704  : 	case IOCTL_DISK_VERIFY:
; 705  : 		if (ValidateIOBufferSize (Irp, sizeof (VERIFY_INFORMATION), ValidateInput))

  001b3	45 33 c0	 xor	 r8d, r8d
  001b6	48 8b cb	 mov	 rcx, rbx
  001b9	41 8d 50 10	 lea	 edx, QWORD PTR [r8+16]
  001bd	e8 00 00 00 00	 call	 ValidateIOBufferSize
  001c2	85 c0		 test	 eax, eax
  001c4	0f 84 03 04 00
	00		 je	 $LN11@ProcessVol

; 706  : 		{
; 707  : 			PVERIFY_INFORMATION pVerifyInformation;
; 708  : 			pVerifyInformation = (PVERIFY_INFORMATION) Irp->AssociatedIrp.SystemBuffer;

  001ca	48 8b 6b 18	 mov	 rbp, QWORD PTR [rbx+24]

; 709  : 
; 710  : 			if (pVerifyInformation->StartingOffset.QuadPart + pVerifyInformation->Length > Extension->DiskLength)

  001ce	8b 4d 08	 mov	 ecx, DWORD PTR [rbp+8]
  001d1	48 8b c1	 mov	 rax, rcx
  001d4	48 03 45 00	 add	 rax, QWORD PTR [rbp]
  001d8	48 3b 87 a0 00
	00 00		 cmp	 rax, QWORD PTR [rdi+160]

; 711  : 				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
; 712  : 			else

  001df	0f 8f 43 02 00
	00		 jg	 $LN58@ProcessVol

; 713  : 			{
; 714  : 				IO_STATUS_BLOCK ioStatus;
; 715  : 				PVOID buffer = TCalloc (max (pVerifyInformation->Length, PAGE_SIZE));

  001e5	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  001ea	41 bd 54 43 4d
	4d		 mov	 r13d, 1296909140	; 4d4d4354H
  001f0	3b c8		 cmp	 ecx, eax
  001f2	45 8b c5	 mov	 r8d, r13d
  001f5	0f 47 c1	 cmova	 eax, ecx
  001f8	33 c9		 xor	 ecx, ecx
  001fa	8b d0		 mov	 edx, eax
  001fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00202	4c 8b e0	 mov	 r12, rax

; 716  : 				
; 717  : 				if (!buffer)

  00205	48 85 c0	 test	 rax, rax
  00208	75 0c		 jne	 SHORT $LN15@ProcessVol

; 718  : 				{
; 719  : 					Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

  0020a	c7 43 30 9a 00
	00 c0		 mov	 DWORD PTR [rbx+48], -1073741670 ; ffffffffc000009aH

; 720  : 				}
; 721  : 				else

  00211	e9 19 02 00 00	 jmp	 $LN13@ProcessVol
$LN15@ProcessVol:

; 722  : 				{
; 723  : 					LARGE_INTEGER offset = pVerifyInformation->StartingOffset;

  00216	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]

; 724  : 					offset.QuadPart += Extension->cryptoInfo->hiddenVolume ? Extension->cryptoInfo->hiddenVolumeOffset : Extension->cryptoInfo->volDataAreaOffset;

  0021a	48 8b 8f 90 00
	00 00		 mov	 rcx, QWORD PTR [rdi+144]
  00221	48 89 44 24 58	 mov	 QWORD PTR offset$31676[rsp], rax
  00226	83 b9 a0 29 00
	00 00		 cmp	 DWORD PTR [rcx+10656], 0
  0022d	74 09		 je	 SHORT $LN48@ProcessVol
  0022f	48 8b 91 18 44
	00 00		 mov	 rdx, QWORD PTR [rcx+17432]
  00236	eb 07		 jmp	 SHORT $LN49@ProcessVol
$LN48@ProcessVol:
  00238	48 8b 91 08 44
	00 00		 mov	 rdx, QWORD PTR [rcx+17416]
$LN49@ProcessVol:

; 725  : 
; 726  : 					Irp->IoStatus.Status = ZwReadFile (Extension->hDeviceFile, NULL, NULL, NULL, &ioStatus, buffer, pVerifyInformation->Length, &offset, NULL);

  0023f	48 83 64 24 40
	00		 and	 QWORD PTR [rsp+64], 0
  00245	48 8b 4f 78	 mov	 rcx, QWORD PTR [rdi+120]
  00249	48 03 c2	 add	 rax, rdx
  0024c	48 89 44 24 58	 mov	 QWORD PTR offset$31676[rsp], rax
  00251	48 8d 44 24 58	 lea	 rax, QWORD PTR offset$31676[rsp]
  00256	45 33 c9	 xor	 r9d, r9d
  00259	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0025e	8b 45 08	 mov	 eax, DWORD PTR [rbp+8]
  00261	45 33 c0	 xor	 r8d, r8d
  00264	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00268	48 8d 44 24 68	 lea	 rax, QWORD PTR ioStatus$31670[rsp]
  0026d	33 d2		 xor	 edx, edx
  0026f	4c 89 64 24 28	 mov	 QWORD PTR [rsp+40], r12
  00274	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00279	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwReadFile

; 727  : 					TCfree (buffer);

  0027f	41 8b d5	 mov	 edx, r13d
  00282	49 8b cc	 mov	 rcx, r12
  00285	89 43 30	 mov	 DWORD PTR [rbx+48], eax
  00288	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 728  : 
; 729  : 					if (NT_SUCCESS (Irp->IoStatus.Status) && ioStatus.Information != pVerifyInformation->Length)

  0028e	83 7b 30 00	 cmp	 DWORD PTR [rbx+48], 0
  00292	0f 8c 97 01 00
	00		 jl	 $LN13@ProcessVol
  00298	8b 45 08	 mov	 eax, DWORD PTR [rbp+8]
  0029b	48 39 44 24 70	 cmp	 QWORD PTR ioStatus$31670[rsp+8], rax
  002a0	0f 84 89 01 00
	00		 je	 $LN13@ProcessVol

; 730  : 						Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
; 731  : 				}
; 732  : 			}
; 733  : 
; 734  : 			Irp->IoStatus.Information = 0;
; 735  : 		}
; 736  : 		break;

  002a6	e9 7d 01 00 00	 jmp	 $LN58@ProcessVol
$LN30@ProcessVol:

; 610  : 
; 611  : 	case IOCTL_DISK_GET_MEDIA_TYPES:
; 612  : 	case IOCTL_DISK_GET_DRIVE_GEOMETRY:
; 613  : 		/* Return the drive geometry for the disk.  Note that we
; 614  : 		   return values which were made up to suit the disk size.  */
; 615  : 		if (ValidateIOBufferSize (Irp, sizeof (DISK_GEOMETRY), ValidateOutput))

  002ab	bd 18 00 00 00	 mov	 ebp, 24
  002b0	48 8b cb	 mov	 rcx, rbx
  002b3	44 8d 45 e9	 lea	 r8d, QWORD PTR [rbp-23]
  002b7	48 8b d5	 mov	 rdx, rbp
  002ba	e8 00 00 00 00	 call	 ValidateIOBufferSize
  002bf	85 c0		 test	 eax, eax
  002c1	0f 84 06 03 00
	00		 je	 $LN11@ProcessVol

; 616  : 		{
; 617  : 			PDISK_GEOMETRY outputBuffer = (PDISK_GEOMETRY)
; 618  : 			Irp->AssociatedIrp.SystemBuffer;
; 619  : 
; 620  : 			outputBuffer->MediaType = Extension->bRemovable ? RemovableMedia : FixedMedia;

  002c7	8b 87 44 03 00
	00		 mov	 eax, DWORD PTR [rdi+836]
  002cd	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  002d1	f7 d8		 neg	 eax
  002d3	1b c9		 sbb	 ecx, ecx
  002d5	83 c1 0c	 add	 ecx, 12
  002d8	89 4a 08	 mov	 DWORD PTR [rdx+8], ecx

; 621  : 			outputBuffer->Cylinders.QuadPart = Extension->NumberOfCylinders;

  002db	48 8b 87 a8 00
	00 00		 mov	 rax, QWORD PTR [rdi+168]
  002e2	48 89 02	 mov	 QWORD PTR [rdx], rax

; 622  : 			outputBuffer->TracksPerCylinder = Extension->TracksPerCylinder;

  002e5	8b 87 b0 00 00
	00		 mov	 eax, DWORD PTR [rdi+176]
  002eb	89 42 0c	 mov	 DWORD PTR [rdx+12], eax

; 623  : 			outputBuffer->SectorsPerTrack = Extension->SectorsPerTrack;

  002ee	8b 87 b4 00 00
	00		 mov	 eax, DWORD PTR [rdi+180]
  002f4	89 42 10	 mov	 DWORD PTR [rdx+16], eax

; 624  : 			outputBuffer->BytesPerSector = Extension->BytesPerSector;

  002f7	8b 87 b8 00 00
	00		 mov	 eax, DWORD PTR [rdi+184]
  002fd	89 42 14	 mov	 DWORD PTR [rdx+20], eax
$LN63@ProcessVol:

; 625  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00300	83 63 30 00	 and	 DWORD PTR [rbx+48], 0

; 626  : 			Irp->IoStatus.Information = sizeof (DISK_GEOMETRY);

  00304	48 89 6b 38	 mov	 QWORD PTR [rbx+56], rbp

; 627  : 		}
; 628  : 		break;

  00308	e9 c0 02 00 00	 jmp	 $LN11@ProcessVol
$LN22@ProcessVol:

; 687  : 
; 688  : 	case IOCTL_DISK_GET_LENGTH_INFO:
; 689  : 		if (!ValidateIOBufferSize (Irp, sizeof (GET_LENGTH_INFORMATION), ValidateOutput))

  0030d	ba 08 00 00 00	 mov	 edx, 8
  00312	48 8b cb	 mov	 rcx, rbx
  00315	44 8d 42 f9	 lea	 r8d, QWORD PTR [rdx-7]
  00319	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0031e	85 c0		 test	 eax, eax
  00320	75 09		 jne	 SHORT $LN21@ProcessVol

; 690  : 		{
; 691  : 			Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

  00322	c7 43 30 05 00
	00 80		 mov	 DWORD PTR [rbx+48], -2147483643 ; ffffffff80000005H

; 692  : 			Irp->IoStatus.Information = sizeof (GET_LENGTH_INFORMATION);
; 693  : 		}
; 694  : 		else

  00329	eb 12		 jmp	 SHORT $LN65@ProcessVol
$LN21@ProcessVol:

; 695  : 		{
; 696  : 			PGET_LENGTH_INFORMATION outputBuffer = (PGET_LENGTH_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
; 697  : 
; 698  : 			outputBuffer->Length.QuadPart = Extension->DiskLength;

  0032b	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
  00332	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
  00336	48 89 01	 mov	 QWORD PTR [rcx], rax

; 699  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00339	83 63 30 00	 and	 DWORD PTR [rbx+48], 0
$LN65@ProcessVol:

; 700  : 			Irp->IoStatus.Information = sizeof (GET_LENGTH_INFORMATION);

  0033d	48 c7 43 38 08
	00 00 00	 mov	 QWORD PTR [rbx+56], 8

; 701  : 		}
; 702  : 		break;

  00345	e9 83 02 00 00	 jmp	 $LN11@ProcessVol
$LN50@ProcessVol:

; 498  : 
; 499  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  0034a	2d 00 48 07 00	 sub	 eax, 477184		; 00074800H
  0034f	0f 84 57 02 00
	00		 je	 $LN12@ProcessVol
  00355	2d 00 00 26 00	 sub	 eax, 2490368		; 00260000H
  0035a	0f 84 4c 02 00
	00		 je	 $LN12@ProcessVol
  00360	2d 00 b8 1f 00	 sub	 eax, 2078720		; 001fb800H
  00365	bd 04 00 00 00	 mov	 ebp, 4
  0036a	0f 84 a1 01 00
	00		 je	 $LN37@ProcessVol
  00370	83 e8 08	 sub	 eax, 8
  00373	0f 84 10 01 00
	00		 je	 $LN41@ProcessVol
  00379	2b c5		 sub	 eax, ebp
  0037b	0f 84 8e 00 00
	00		 je	 $LN33@ProcessVol
  00381	2d f4 ff 08 00	 sub	 eax, 589812		; 0008fff4H
  00386	74 33		 je	 SHORT $LN6@ProcessVol
  00388	3d 08 c0 00 00	 cmp	 eax, 49160		; 0000c008H
  0038d	74 22		 je	 SHORT $LN7@ProcessVol
$LN1@ProcessVol:

; 788  : 
; 789  : 	default:
; 790  : 		return TCCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);

  0038f	49 83 60 38 00	 and	 QWORD PTR [r8+56], 0
  00394	33 d2		 xor	 edx, edx
  00396	48 8b cb	 mov	 rcx, rbx
  00399	41 c7 40 30 10
	00 00 c0	 mov	 DWORD PTR [r8+48], -1073741808 ; ffffffffc0000010H
  003a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest
  003a7	b8 10 00 00 c0	 mov	 eax, -1073741808	; ffffffffc0000010H
  003ac	e9 2f 02 00 00	 jmp	 $LN44@ProcessVol
$LN7@ProcessVol:

; 762  : 		
; 763  : 	case IOCTL_VOLUME_ONLINE:
; 764  : 		Irp->IoStatus.Status = STATUS_SUCCESS;

  003b1	41 83 60 30 00	 and	 DWORD PTR [r8+48], 0

; 765  : 		Irp->IoStatus.Information = 0;
; 766  : 		break;

  003b6	e9 ee fd ff ff	 jmp	 $LN66@ProcessVol
$LN6@ProcessVol:

; 767  : 
; 768  : 	case IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS:
; 769  : 
; 770  : 		// Vista's filesystem defragmenter fails if IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS does not succeed.
; 771  : 		if (!(OsMajorVersion == 6 && OsMinorVersion == 0))

  003bb	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR OsMajorVersion, 6
  003c2	75 3e		 jne	 SHORT $LN4@ProcessVol
  003c4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR OsMinorVersion, 0
  003cb	75 35		 jne	 SHORT $LN4@ProcessVol

; 774  : 			Irp->IoStatus.Information = 0;
; 775  : 		}
; 776  : 		else if (ValidateIOBufferSize (Irp, sizeof (VOLUME_DISK_EXTENTS), ValidateOutput))

  003cd	bd 20 00 00 00	 mov	 ebp, 32			; 00000020H
  003d2	48 8b cb	 mov	 rcx, rbx
  003d5	44 8d 45 e1	 lea	 r8d, QWORD PTR [rbp-31]
  003d9	48 8b d5	 mov	 rdx, rbp
  003dc	e8 00 00 00 00	 call	 ValidateIOBufferSize
  003e1	85 c0		 test	 eax, eax
  003e3	0f 84 e4 01 00
	00		 je	 $LN11@ProcessVol

; 777  : 		{
; 778  : 			VOLUME_DISK_EXTENTS *extents = (VOLUME_DISK_EXTENTS *) Irp->AssociatedIrp.SystemBuffer;

  003e9	48 8b 7b 18	 mov	 rdi, QWORD PTR [rbx+24]

; 779  : 
; 780  : 			// No extent data can be returned as this is not a physical drive.
; 781  : 			memset (extents, 0, sizeof (*extents));

  003ed	4c 8b c5	 mov	 r8, rbp
  003f0	33 d2		 xor	 edx, edx
  003f2	48 8b cf	 mov	 rcx, rdi
  003f5	e8 00 00 00 00	 call	 memset

; 782  : 			extents->NumberOfDiskExtents = 0;

  003fa	83 27 00	 and	 DWORD PTR [rdi], 0

; 783  : 
; 784  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 785  : 			Irp->IoStatus.Information = sizeof (*extents);

  003fd	e9 fe fe ff ff	 jmp	 $LN63@ProcessVol
$LN4@ProcessVol:

; 772  : 		{
; 773  : 			Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;

  00402	41 c7 40 30 10
	00 00 c0	 mov	 DWORD PTR [r8+48], -1073741808 ; ffffffffc0000010H

; 786  : 		}
; 787  : 		break;

  0040a	e9 9a fd ff ff	 jmp	 $LN66@ProcessVol
$LN33@ProcessVol:

; 572  : 
; 573  : 	case IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME:
; 574  : 		{
; 575  : 			ULONG outLength;
; 576  : 			UNICODE_STRING ntUnicodeString;
; 577  : 			WCHAR ntName[256];
; 578  : 			PMOUNTDEV_SUGGESTED_LINK_NAME outputBuffer = (PMOUNTDEV_SUGGESTED_LINK_NAME) Irp->AssociatedIrp.SystemBuffer;

  0040f	4d 8b 68 18	 mov	 r13, QWORD PTR [r8+24]

; 579  : 
; 580  : 			if (!ValidateIOBufferSize (Irp, sizeof (MOUNTDEV_SUGGESTED_LINK_NAME), ValidateOutput))

  00413	ba 06 00 00 00	 mov	 edx, 6
  00418	48 8b cb	 mov	 rcx, rbx
  0041b	44 8d 42 fb	 lea	 r8d, QWORD PTR [rdx-5]
  0041f	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00424	85 c0		 test	 eax, eax
  00426	75 11		 jne	 SHORT $LN32@ProcessVol
$LN58@ProcessVol:

; 581  : 			{
; 582  : 				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  00428	c7 43 30 0d 00
	00 c0		 mov	 DWORD PTR [rbx+48], -1073741811 ; ffffffffc000000dH
$LN13@ProcessVol:

; 583  : 				Irp->IoStatus.Information = 0;

  0042f	48 83 63 38 00	 and	 QWORD PTR [rbx+56], 0

; 584  : 				break; 

  00434	e9 94 01 00 00	 jmp	 $LN11@ProcessVol
$LN32@ProcessVol:

; 585  : 			}
; 586  : 
; 587  : 			TCGetDosNameFromNumber (ntName, Extension->nDosDriveNo);

  00439	8b 57 14	 mov	 edx, DWORD PTR [rdi+20]
  0043c	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR ntName$31610[rsp]
  00444	e8 00 00 00 00	 call	 TCGetDosNameFromNumber

; 588  : 			RtlInitUnicodeString (&ntUnicodeString, ntName);

  00449	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR ntName$31610[rsp]
  00451	48 8d 4c 24 58	 lea	 rcx, QWORD PTR ntUnicodeString$31609[rsp]
  00456	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 589  : 
; 590  : 			outLength = FIELD_OFFSET(MOUNTDEV_SUGGESTED_LINK_NAME,Name) + ntUnicodeString.Length;

  0045c	0f b7 7c 24 58	 movzx	 edi, WORD PTR ntUnicodeString$31609[rsp]

; 591  : 
; 592  : 			outputBuffer->UseOnlyIfThereAreNoOtherLinks = FALSE;

  00461	41 c6 45 00 00	 mov	 BYTE PTR [r13], 0

; 593  : 			outputBuffer->NameLength = ntUnicodeString.Length;

  00466	0f b7 44 24 58	 movzx	 eax, WORD PTR ntUnicodeString$31609[rsp]
  0046b	03 fd		 add	 edi, ebp
  0046d	66 41 89 45 02	 mov	 WORD PTR [r13+2], ax

; 594  : 
; 595  : 			if(irpSp->Parameters.DeviceIoControl.OutputBufferLength < outLength)

  00472	41 39 7c 24 08	 cmp	 DWORD PTR [r12+8], edi
  00477	73 0a		 jae	 SHORT $LN31@ProcessVol

; 596  : 			{
; 597  : 				Irp->IoStatus.Information = sizeof (MOUNTDEV_SUGGESTED_LINK_NAME);

  00479	48 c7 43 38 06
	00 00 00	 mov	 QWORD PTR [rbx+56], 6

; 598  : 				Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
; 599  : 				break;

  00481	eb 5f		 jmp	 SHORT $LN60@ProcessVol
$LN31@ProcessVol:

; 600  : 			}
; 601  : 
; 602  : 			RtlCopyMemory ((PCHAR)outputBuffer->Name,ntUnicodeString.Buffer, ntUnicodeString.Length);

  00483	49 8d 4d 04	 lea	 rcx, QWORD PTR [r13+4]

; 603  : 		
; 604  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 605  : 			Irp->IoStatus.Information = outLength;
; 606  : 
; 607  : 			Dump ("link = %ls\n",ntName);
; 608  : 		}
; 609  : 		break;

  00487	eb 69		 jmp	 SHORT $LN67@ProcessVol
$LN41@ProcessVol:

; 500  : 	{
; 501  : 
; 502  : 	case IOCTL_MOUNTDEV_QUERY_DEVICE_NAME:
; 503  : 		if (!ValidateIOBufferSize (Irp, sizeof (MOUNTDEV_NAME), ValidateOutput))

  00489	41 b8 01 00 00
	00		 mov	 r8d, 1
  0048f	48 8b d5	 mov	 rdx, rbp
  00492	48 8b cb	 mov	 rcx, rbx
  00495	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0049a	85 c0		 test	 eax, eax

; 504  : 		{
; 505  : 			Irp->IoStatus.Information = sizeof (MOUNTDEV_NAME);
; 506  : 			Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
; 507  : 		}
; 508  : 		else

  0049c	74 40		 je	 SHORT $LN59@ProcessVol

; 509  : 		{
; 510  : 			ULONG outLength;
; 511  : 			UNICODE_STRING ntUnicodeString;
; 512  : 			WCHAR ntName[256];
; 513  : 			PMOUNTDEV_NAME outputBuffer = (PMOUNTDEV_NAME) Irp->AssociatedIrp.SystemBuffer;
; 514  : 
; 515  : 			TCGetNTNameFromNumber (ntName, Extension->nDosDriveNo);

  0049e	8b 57 14	 mov	 edx, DWORD PTR [rdi+20]
  004a1	4c 8b 6b 18	 mov	 r13, QWORD PTR [rbx+24]
  004a5	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR ntName$31577[rsp]
  004ad	e8 00 00 00 00	 call	 TCGetNTNameFromNumber

; 516  : 			RtlInitUnicodeString (&ntUnicodeString, ntName);

  004b2	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR ntName$31577[rsp]
  004ba	48 8d 4c 24 58	 lea	 rcx, QWORD PTR ntUnicodeString$31576[rsp]
  004bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 517  : 
; 518  : 			outputBuffer->NameLength = ntUnicodeString.Length;

  004c5	0f b7 54 24 58	 movzx	 edx, WORD PTR ntUnicodeString$31576[rsp]
  004ca	66 41 89 55 00	 mov	 WORD PTR [r13], dx

; 519  : 			outLength = ntUnicodeString.Length + sizeof(USHORT);

  004cf	0f b7 7c 24 58	 movzx	 edi, WORD PTR ntUnicodeString$31576[rsp]
  004d4	83 c7 02	 add	 edi, 2

; 520  : 
; 521  : 			if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < outLength)

  004d7	41 39 7c 24 08	 cmp	 DWORD PTR [r12+8], edi
  004dc	73 10		 jae	 SHORT $LN38@ProcessVol
$LN59@ProcessVol:

; 522  : 			{
; 523  : 				Irp->IoStatus.Information = sizeof (MOUNTDEV_NAME);

  004de	48 89 6b 38	 mov	 QWORD PTR [rbx+56], rbp
$LN60@ProcessVol:

; 524  : 				Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

  004e2	c7 43 30 05 00
	00 80		 mov	 DWORD PTR [rbx+48], -2147483643 ; ffffffff80000005H

; 525  : 
; 526  : 				break;

  004e9	e9 df 00 00 00	 jmp	 $LN11@ProcessVol
$LN38@ProcessVol:

; 527  : 			}
; 528  : 
; 529  : 			RtlCopyMemory ((PCHAR)outputBuffer->Name,ntUnicodeString.Buffer, ntUnicodeString.Length);

  004ee	49 8d 4d 02	 lea	 rcx, QWORD PTR [r13+2]
$LN67@ProcessVol:
  004f2	44 0f b7 44 24
	58		 movzx	 r8d, WORD PTR ntUnicodeString$31576[rsp]
  004f8	48 8b 54 24 60	 mov	 rdx, QWORD PTR ntUnicodeString$31576[rsp+8]
$LN61@ProcessVol:
  004fd	e8 00 00 00 00	 call	 memcpy

; 530  : 
; 531  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00502	83 63 30 00	 and	 DWORD PTR [rbx+48], 0

; 532  : 			Irp->IoStatus.Information = outLength;

  00506	8b c7		 mov	 eax, edi
  00508	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax

; 533  : 
; 534  : 			Dump ("name = %ls\n",ntName);
; 535  : 		}
; 536  : 		break;

  0050c	e9 bc 00 00 00	 jmp	 $LN11@ProcessVol
$LN37@ProcessVol:

; 537  : 
; 538  : 	case IOCTL_MOUNTDEV_QUERY_UNIQUE_ID:
; 539  : 		if (!ValidateIOBufferSize (Irp, sizeof (MOUNTDEV_UNIQUE_ID), ValidateOutput))

  00511	41 b8 01 00 00
	00		 mov	 r8d, 1
  00517	48 8b d5	 mov	 rdx, rbp
  0051a	48 8b cb	 mov	 rcx, rbx
  0051d	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00522	85 c0		 test	 eax, eax

; 540  : 		{
; 541  : 			Irp->IoStatus.Information = sizeof (MOUNTDEV_UNIQUE_ID);
; 542  : 			Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
; 543  : 		}
; 544  : 		else

  00524	74 b8		 je	 SHORT $LN59@ProcessVol

; 545  : 		{
; 546  : 			ULONG outLength;
; 547  : 			UCHAR volId[128], tmp[] = { 0,0 };
; 548  : 			PMOUNTDEV_UNIQUE_ID outputBuffer = (PMOUNTDEV_UNIQUE_ID) Irp->AssociatedIrp.SystemBuffer;
; 549  : 
; 550  : 			strcpy (volId, TC_UNIQUE_ID_PREFIX); 
; 551  : 			tmp[0] = 'A' + (UCHAR) Extension->nDosDriveNo;

  00526	8a 47 14	 mov	 al, BYTE PTR [rdi+20]
  00529	f3 0f 6f 05 00
	00 00 00	 movdqu	 xmm0, XMMWORD PTR ??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@FNODOBFM@
  00531	4c 8b 4b 18	 mov	 r9, QWORD PTR [rbx+24]
  00535	04 41		 add	 al, 65			; 00000041H

; 552  : 			strcat (volId, tmp);

  00537	49 83 c8 ff	 or	 r8, -1
  0053b	48 8d bc 24 80
	00 00 00	 lea	 rdi, QWORD PTR volId$31593[rsp]
  00543	f3 0f 7f 84 24
	80 00 00 00	 movdqu	 XMMWORD PTR volId$31593[rsp], xmm0
  0054c	88 44 24 50	 mov	 BYTE PTR tmp$31594[rsp], al
  00550	33 c0		 xor	 eax, eax
  00552	49 8b c8	 mov	 rcx, r8
  00555	f2 ae		 repne scasb
  00557	48 8d 4c 24 50	 lea	 rcx, QWORD PTR tmp$31594[rsp]
  0055c	33 d2		 xor	 edx, edx
  0055e	c6 44 24 51 00	 mov	 BYTE PTR tmp$31594[rsp+1], 0
$LL57@ProcessVol:
  00563	8a 04 11	 mov	 al, BYTE PTR [rcx+rdx]
  00566	48 ff c2	 inc	 rdx
  00569	88 44 17 fe	 mov	 BYTE PTR [rdi+rdx-2], al
  0056d	84 c0		 test	 al, al
  0056f	75 f2		 jne	 SHORT $LL57@ProcessVol

; 553  : 			
; 554  : 			outputBuffer->UniqueIdLength = (USHORT) strlen (volId);

  00571	33 c0		 xor	 eax, eax
  00573	49 8b c8	 mov	 rcx, r8
  00576	48 8d bc 24 80
	00 00 00	 lea	 rdi, QWORD PTR volId$31593[rsp]
  0057e	f2 ae		 repne scasb
  00580	48 f7 d1	 not	 rcx
  00583	48 ff c9	 dec	 rcx
  00586	66 41 89 09	 mov	 WORD PTR [r9], cx
  0058a	4c 8b c1	 mov	 r8, rcx

; 555  : 			outLength = (ULONG) (strlen (volId) + sizeof (USHORT));

  0058d	8d 79 02	 lea	 edi, DWORD PTR [rcx+2]

; 556  : 
; 557  : 			if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < outLength)

  00590	41 39 7c 24 08	 cmp	 DWORD PTR [r12+8], edi

; 558  : 			{
; 559  : 				Irp->IoStatus.Information = sizeof (MOUNTDEV_UNIQUE_ID);
; 560  : 				Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
; 561  : 				break;

  00595	0f 82 43 ff ff
	ff		 jb	 $LN59@ProcessVol

; 562  : 			}
; 563  : 
; 564  : 			RtlCopyMemory ((PCHAR)outputBuffer->UniqueId, volId, strlen (volId));

  0059b	49 8d 49 02	 lea	 rcx, QWORD PTR [r9+2]
  0059f	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR volId$31593[rsp]

; 565  : 
; 566  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 567  : 			Irp->IoStatus.Information = outLength;
; 568  : 
; 569  : 			Dump ("id = %s\n",volId);
; 570  : 		}
; 571  : 		break;

  005a7	e9 51 ff ff ff	 jmp	 $LN61@ProcessVol
$LN12@ProcessVol:

; 737  : 
; 738  : 	case IOCTL_DISK_CHECK_VERIFY:
; 739  : 	case IOCTL_STORAGE_CHECK_VERIFY:
; 740  : 		{
; 741  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  005ac	41 83 60 30 00	 and	 DWORD PTR [r8+48], 0

; 742  : 			Irp->IoStatus.Information = 0;

  005b1	49 83 60 38 00	 and	 QWORD PTR [r8+56], 0

; 743  : 
; 744  : 			if (irpSp->Parameters.DeviceIoControl.OutputBufferLength >= sizeof (ULONG))

  005b6	bd 04 00 00 00	 mov	 ebp, 4
  005bb	41 39 6c 24 08	 cmp	 DWORD PTR [r12+8], ebp
  005c0	72 0b		 jb	 SHORT $LN11@ProcessVol

; 745  : 			{
; 746  : 				*((ULONG *) Irp->AssociatedIrp.SystemBuffer) = 0;

  005c2	49 8b 40 18	 mov	 rax, QWORD PTR [r8+24]
  005c6	83 20 00	 and	 DWORD PTR [rax], 0

; 747  : 				Irp->IoStatus.Information = sizeof (ULONG);

  005c9	49 89 68 38	 mov	 QWORD PTR [r8+56], rbp
$LN11@ProcessVol:

; 791  : 	}
; 792  : 
; 793  : #ifdef DEBUG
; 794  : 	if (!NT_SUCCESS (Irp->IoStatus.Status))
; 795  : 	{
; 796  : 		Dump ("IOCTL error 0x%08x (0x%x %d)\n",
; 797  : 			Irp->IoStatus.Status,
; 798  : 			(int) (irpSp->Parameters.DeviceIoControl.IoControlCode >> 16),
; 799  : 			(int) ((irpSp->Parameters.DeviceIoControl.IoControlCode & 0x1FFF) >> 2));
; 800  : 	}
; 801  : #endif
; 802  : 
; 803  : 	return TCCompleteDiskIrp (Irp, Irp->IoStatus.Status, Irp->IoStatus.Information);

  005cd	8b 7b 30	 mov	 edi, DWORD PTR [rbx+48]
  005d0	48 8b cb	 mov	 rcx, rbx
  005d3	85 ff		 test	 edi, edi
  005d5	0f 99 c2	 setns	 dl
  005d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest
  005de	8b c7		 mov	 eax, edi
$LN44@ProcessVol:

; 804  : }

  005e0	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005e8	48 33 cc	 xor	 rcx, rsp
  005eb	e8 00 00 00 00	 call	 __security_check_cookie
  005f0	4c 8d 9c 24 10
	03 00 00	 lea	 r11, QWORD PTR [rsp+784]
  005f8	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  005fc	49 8b 6b 38	 mov	 rbp, QWORD PTR [r11+56]
  00600	49 8b e3	 mov	 rsp, r11
  00603	41 5d		 pop	 r13
  00605	41 5c		 pop	 r12
  00607	5f		 pop	 rdi
  00608	c3		 ret	 0
ProcessVolumeDeviceControlIrp ENDP
PUBLIC	ReadDeviceSkipUnreadableSectors
;	COMDAT pdata
pdata	SEGMENT
$pdata$ReadDeviceSkipUnreadableSectors DD imagerel $LN15
	DD	imagerel $LN15+223
	DD	imagerel $unwind$ReadDeviceSkipUnreadableSectors
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ReadDeviceSkipUnreadableSectors DD 0a1c01H
	DD	011641cH
	DD	0f541cH
	DD	0e341cH
	DD	0d018921cH
	DD	07014c016H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ReadDeviceSkipUnreadableSectors
_TEXT	SEGMENT
geometry$51946 = 48
deviceObject$ = 112
buffer$ = 120
startOffset$ = 128
size$ = 136
sectorSize$ = 144
badSectorCount$ = 144
ReadDeviceSkipUnreadableSectors PROC			; COMDAT

; 3195 : {

$LN15:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 20	 mov	 QWORD PTR [rax+32], rsi
  0000f	4c 89 40 18	 mov	 QWORD PTR [rax+24], r8
  00013	57		 push	 rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 3196 : 	NTSTATUS status;
; 3197 : 	ULONG sectorSize;
; 3198 : 	ULONG sectorCount;
; 3199 : 
; 3200 : 	*badSectorCount = 0;

  0001c	4c 8b a4 24 90
	00 00 00	 mov	 r12, QWORD PTR badSectorCount$[rsp]

; 3201 : 
; 3202 : 	status = GetDeviceSectorSize (deviceObject, &sectorSize);

  00024	c7 40 c0 18 00
	00 00		 mov	 DWORD PTR [rax-64], 24
  0002b	48 8d 40 c8	 lea	 rax, QWORD PTR [rax-56]
  0002f	49 83 24 24 00	 and	 QWORD PTR [r12], 0
  00034	41 8b d9	 mov	 ebx, r9d
  00037	48 8b ea	 mov	 rbp, rdx
  0003a	45 33 c9	 xor	 r9d, r9d
  0003d	45 33 c0	 xor	 r8d, r8d
  00040	ba 00 00 07 00	 mov	 edx, 458752		; 00070000H
  00045	4c 8b e9	 mov	 r13, rcx
  00048	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004d	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  00052	85 c0		 test	 eax, eax
  00054	79 09		 jns	 SHORT $LN8@ReadDevice
  00056	8b bc 24 90 00
	00 00		 mov	 edi, DWORD PTR sectorSize$[rsp]
  0005d	eb 06		 jmp	 SHORT $LN9@ReadDevice
$LN8@ReadDevice:
  0005f	8b 7c 24 44	 mov	 edi, DWORD PTR geometry$51946[rsp+20]
  00063	33 c0		 xor	 eax, eax
$LN9@ReadDevice:

; 3203 : 	if (!NT_SUCCESS (status))

  00065	85 c0		 test	 eax, eax

; 3204 : 		return status;

  00067	78 5c		 js	 SHORT $LN6@ReadDevice

; 3205 : 
; 3206 : 	for (sectorCount = size / sectorSize; sectorCount > 0; --sectorCount, startOffset.QuadPart += sectorSize, buffer += sectorSize)

  00069	33 d2		 xor	 edx, edx
  0006b	8b c3		 mov	 eax, ebx
  0006d	f7 f7		 div	 edi
  0006f	8b d8		 mov	 ebx, eax
  00071	85 c0		 test	 eax, eax
  00073	74 4e		 je	 SHORT $LN2@ReadDevice
  00075	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR startOffset$[rsp]
  0007d	8b f7		 mov	 esi, edi
$LL4@ReadDevice:

; 3207 : 	{
; 3208 : 		status = TCReadDevice (deviceObject, buffer, startOffset, sectorSize);

  0007f	4c 8b c9	 mov	 r9, rcx
  00082	4c 8b c5	 mov	 r8, rbp
  00085	49 8b d5	 mov	 rdx, r13
  00088	33 c9		 xor	 ecx, ecx
  0008a	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  0008e	e8 00 00 00 00	 call	 TCReadWriteDevice

; 3209 : 		if (!NT_SUCCESS (status))

  00093	85 c0		 test	 eax, eax
  00095	79 11		 jns	 SHORT $LN3@ReadDevice

; 3210 : 		{
; 3211 : 			Dump ("Skipping bad sector at %I64d\n", startOffset.QuadPart);
; 3212 : 			memset (buffer, 0, sectorSize);

  00097	4c 8b c6	 mov	 r8, rsi
  0009a	33 d2		 xor	 edx, edx
  0009c	48 8b cd	 mov	 rcx, rbp
  0009f	e8 00 00 00 00	 call	 memset

; 3213 : 			++(*badSectorCount);

  000a4	49 ff 04 24	 inc	 QWORD PTR [r12]
$LN3@ReadDevice:
  000a8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR startOffset$[rsp]
  000b0	48 03 ee	 add	 rbp, rsi
  000b3	48 03 ce	 add	 rcx, rsi
  000b6	83 c3 ff	 add	 ebx, -1			; ffffffffH
  000b9	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR startOffset$[rsp], rcx
  000c1	75 bc		 jne	 SHORT $LL4@ReadDevice
$LN2@ReadDevice:

; 3214 : 		}
; 3215 : 	}
; 3216 : 
; 3217 : 	return STATUS_SUCCESS;

  000c3	33 c0		 xor	 eax, eax
$LN6@ReadDevice:

; 3218 : }

  000c5	4c 8d 5c 24 50	 lea	 r11, QWORD PTR [rsp+80]
  000ca	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  000ce	49 8b 6b 28	 mov	 rbp, QWORD PTR [r11+40]
  000d2	49 8b 73 38	 mov	 rsi, QWORD PTR [r11+56]
  000d6	49 8b e3	 mov	 rsp, r11
  000d9	41 5d		 pop	 r13
  000db	41 5c		 pop	 r12
  000dd	5f		 pop	 rdi
  000de	c3		 ret	 0
ReadDeviceSkipUnreadableSectors ENDP
_TEXT	ENDS
PUBLIC	ZeroUnreadableSectors
;	COMDAT pdata
pdata	SEGMENT
$pdata$ZeroUnreadableSectors DD imagerel $LN21
	DD	imagerel $LN21+298
	DD	imagerel $unwind$ZeroUnreadableSectors
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ZeroUnreadableSectors DD 0a1b01H
	DD	012541bH
	DD	010341bH
	DD	0e017921bH
	DD	0c013d015H
	DD	060107011H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ZeroUnreadableSectors
_TEXT	SEGMENT
geometry$51974 = 48
deviceObject$ = 128
startOffset$ = 136
size$ = 144
sectorSize$ = 152
zeroedSectorCount$ = 152
ZeroUnreadableSectors PROC				; COMDAT

; 3152 : {

$LN21:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 18	 mov	 QWORD PTR [rax+24], rbp
  0000b	48 89 50 10	 mov	 QWORD PTR [rax+16], rdx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	41 54		 push	 r12
  00013	41 55		 push	 r13
  00015	41 56		 push	 r14
  00017	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 3153 : 	NTSTATUS status;
; 3154 : 	ULONG sectorSize;
; 3155 : 	ULONG sectorCount;
; 3156 : 	byte *sectorBuffer = NULL;
; 3157 : 
; 3158 : 	*zeroedSectorCount = 0;

  0001b	49 83 21 00	 and	 QWORD PTR [r9], 0

; 3159 : 
; 3160 : 	status = GetDeviceSectorSize (deviceObject, &sectorSize);

  0001f	c7 40 b0 18 00
	00 00		 mov	 DWORD PTR [rax-80], 24
  00026	48 8d 40 b8	 lea	 rax, QWORD PTR [rax-72]
  0002a	4d 8b e9	 mov	 r13, r9
  0002d	41 8b f8	 mov	 edi, r8d
  00030	ba 00 00 07 00	 mov	 edx, 458752		; 00070000H
  00035	45 33 c9	 xor	 r9d, r9d
  00038	45 33 c0	 xor	 r8d, r8d
  0003b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00040	4c 8b f1	 mov	 r14, rcx
  00043	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  00048	85 c0		 test	 eax, eax
  0004a	79 09		 jns	 SHORT $LN11@ZeroUnread
  0004c	8b 9c 24 98 00
	00 00		 mov	 ebx, DWORD PTR sectorSize$[rsp]
  00053	eb 06		 jmp	 SHORT $LN12@ZeroUnread
$LN11@ZeroUnread:
  00055	8b 5c 24 44	 mov	 ebx, DWORD PTR geometry$51974[rsp+20]
  00059	33 c0		 xor	 eax, eax
$LN12@ZeroUnread:

; 3161 : 	if (!NT_SUCCESS (status))

  0005b	85 c0		 test	 eax, eax

; 3162 : 		return status;

  0005d	0f 88 ae 00 00
	00		 js	 $LN9@ZeroUnread

; 3163 : 
; 3164 : 	sectorBuffer = TCalloc (sectorSize);

  00063	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  00069	8b d3		 mov	 edx, ebx
  0006b	33 c9		 xor	 ecx, ecx
  0006d	44 8b e3	 mov	 r12d, ebx
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00076	48 8b e8	 mov	 rbp, rax

; 3165 : 	if (!sectorBuffer)

  00079	48 85 c0	 test	 rax, rax
  0007c	75 0a		 jne	 SHORT $LN7@ZeroUnread

; 3166 : 		return STATUS_INSUFFICIENT_RESOURCES;

  0007e	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  00083	e9 89 00 00 00	 jmp	 $LN9@ZeroUnread
$LN7@ZeroUnread:

; 3167 : 
; 3168 : 	for (sectorCount = size / sectorSize; sectorCount > 0; --sectorCount, startOffset.QuadPart += sectorSize)

  00088	33 d2		 xor	 edx, edx
  0008a	8b c7		 mov	 eax, edi
  0008c	f7 f3		 div	 ebx
  0008e	8b f8		 mov	 edi, eax
  00090	85 c0		 test	 eax, eax
  00092	74 6b		 je	 SHORT $LN4@ZeroUnread
  00094	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR startOffset$[rsp]
$LL6@ZeroUnread:

; 3169 : 	{
; 3170 : 		status = TCReadDevice (deviceObject, sectorBuffer, startOffset, sectorSize);

  0009c	4c 8b c9	 mov	 r9, rcx
  0009f	4c 8b c5	 mov	 r8, rbp
  000a2	49 8b d6	 mov	 rdx, r14
  000a5	33 c9		 xor	 ecx, ecx
  000a7	89 5c 24 20	 mov	 DWORD PTR [rsp+32], ebx
  000ab	e8 00 00 00 00	 call	 TCReadWriteDevice

; 3171 : 		if (!NT_SUCCESS (status))

  000b0	85 c0		 test	 eax, eax
  000b2	79 33		 jns	 SHORT $LN5@ZeroUnread

; 3172 : 		{
; 3173 : 			Dump ("Zeroing sector at %I64d\n", startOffset.QuadPart);
; 3174 : 			memset (sectorBuffer, 0, sectorSize);

  000b4	4d 8b c4	 mov	 r8, r12
  000b7	33 d2		 xor	 edx, edx
  000b9	48 8b cd	 mov	 rcx, rbp
  000bc	e8 00 00 00 00	 call	 memset

; 3175 : 
; 3176 : 			status = TCWriteDevice (deviceObject, sectorBuffer, startOffset, sectorSize);

  000c1	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR startOffset$[rsp]
  000c9	4c 8b c5	 mov	 r8, rbp
  000cc	49 8b d6	 mov	 rdx, r14
  000cf	b9 01 00 00 00	 mov	 ecx, 1
  000d4	89 5c 24 20	 mov	 DWORD PTR [rsp+32], ebx
  000d8	e8 00 00 00 00	 call	 TCReadWriteDevice
  000dd	8b f0		 mov	 esi, eax

; 3177 : 			if (!NT_SUCCESS (status))

  000df	85 c0		 test	 eax, eax
  000e1	78 1e		 js	 SHORT $err$32939

; 3178 : 				goto err;
; 3179 : 
; 3180 : 			++(*zeroedSectorCount);

  000e3	49 ff 45 00	 inc	 QWORD PTR [r13]
$LN5@ZeroUnread:

; 3167 : 
; 3168 : 	for (sectorCount = size / sectorSize; sectorCount > 0; --sectorCount, startOffset.QuadPart += sectorSize)

  000e7	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR startOffset$[rsp]
  000ef	49 03 cc	 add	 rcx, r12
  000f2	83 c7 ff	 add	 edi, -1			; ffffffffH
  000f5	48 89 8c 24 88
	00 00 00	 mov	 QWORD PTR startOffset$[rsp], rcx
  000fd	75 9d		 jne	 SHORT $LL6@ZeroUnread
$LN4@ZeroUnread:

; 3181 : 		}
; 3182 : 	}
; 3183 : 
; 3184 : 	status = STATUS_SUCCESS;

  000ff	33 f6		 xor	 esi, esi
$err$32939:

; 3185 : 
; 3186 : err:
; 3187 : 	if (sectorBuffer)
; 3188 : 		TCfree (sectorBuffer);

  00101	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00106	48 8b cd	 mov	 rcx, rbp
  00109	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 3189 : 
; 3190 : 	return status;

  0010f	8b c6		 mov	 eax, esi
$LN9@ZeroUnread:

; 3191 : }

  00111	4c 8d 5c 24 50	 lea	 r11, QWORD PTR [rsp+80]
  00116	49 8b 5b 30	 mov	 rbx, QWORD PTR [r11+48]
  0011a	49 8b 6b 40	 mov	 rbp, QWORD PTR [r11+64]
  0011e	49 8b e3	 mov	 rsp, r11
  00121	41 5e		 pop	 r14
  00123	41 5d		 pop	 r13
  00125	41 5c		 pop	 r12
  00127	5f		 pop	 rdi
  00128	5e		 pop	 rsi
  00129	c3		 ret	 0
ZeroUnreadableSectors ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	UnmountDevice
;	COMDAT pdata
pdata	SEGMENT
$pdata$UnmountDevice DD imagerel $LN49
	DD	imagerel $LN49+714
	DD	imagerel $unwind$UnmountDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$UnmountDevice DD 092519H
	DD	0803413H
	DD	0780113H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	03b0H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT UnmountDevice
_TEXT	SEGMENT
volumeFileObject$ = 48
volumeHandle$ = 56
symLink$52048 = 64
ntfsData$32606 = 80
buf$52038 = 176
link$52047 = 432
out$52039 = 432
__$ArrayPad$ = 944
unmountRequest$ = 1008
deviceObject$ = 1016
ignoreOpenFiles$ = 1024
UnmountDevice PROC					; COMDAT

; 2646 : {

$LN49:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	48 81 ec c0 03
	00 00		 sub	 rsp, 960		; 000003c0H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 b0
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2647 : 	PEXTENSION extension = deviceObject->DeviceExtension;

  00025	4c 8b 62 40	 mov	 r12, QWORD PTR [rdx+64]
  00029	41 8b f0	 mov	 esi, r8d
  0002c	48 8b ea	 mov	 rbp, rdx
  0002f	4c 8b e9	 mov	 r13, rcx

; 2648 : 	NTSTATUS ntStatus;
; 2649 : 	HANDLE volumeHandle;
; 2650 : 	PFILE_OBJECT volumeFileObject;
; 2651 : 
; 2652 : 	Dump ("UnmountDevice %d\n", extension->nDosDriveNo);
; 2653 : 
; 2654 : 	ntStatus = TCOpenFsVolume (extension, &volumeHandle, &volumeFileObject);

  00032	4c 8d 44 24 30	 lea	 r8, QWORD PTR volumeFileObject$[rsp]
  00037	48 8d 54 24 38	 lea	 rdx, QWORD PTR volumeHandle$[rsp]
  0003c	49 8b cc	 mov	 rcx, r12
  0003f	e8 00 00 00 00	 call	 TCOpenFsVolume

; 2655 : 
; 2656 : 	if (NT_SUCCESS (ntStatus))

  00044	bb 01 00 00 00	 mov	 ebx, 1
  00049	85 c0		 test	 eax, eax
  0004b	0f 88 f0 00 00
	00		 js	 $LN16@UnmountDev
  00051	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR OsMajorVersion
  00057	c1 e0 08	 shl	 eax, 8

; 2657 : 	{
; 2658 : 		int dismountRetry;
; 2659 : 
; 2660 : 		// Dismounting a writable NTFS filesystem prevents the driver from being unloaded on Windows 7
; 2661 : 		if (IsOSAtLeast (WIN_7) && !extension->bReadOnly)

  0005a	0b 05 00 00 00
	00		 or	 eax, DWORD PTR OsMinorVersion
  00060	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00065	3d 01 06 00 00	 cmp	 eax, 1537		; 00000601H
  0006a	72 43		 jb	 SHORT $LN14@UnmountDev
  0006c	41 83 bc 24 40
	03 00 00 00	 cmp	 DWORD PTR [r12+832], 0
  00075	75 38		 jne	 SHORT $LN14@UnmountDev

; 2662 : 		{
; 2663 : 			NTFS_VOLUME_DATA_BUFFER ntfsData;
; 2664 : 
; 2665 : 			if (NT_SUCCESS (TCFsctlCall (volumeFileObject, FSCTL_GET_NTFS_VOLUME_DATA, NULL, 0, &ntfsData, sizeof (ntfsData))))

  00077	48 8b 4c 24 30	 mov	 rcx, QWORD PTR volumeFileObject$[rsp]
  0007c	48 8d 44 24 50	 lea	 rax, QWORD PTR ntfsData$32606[rsp]
  00081	45 33 c9	 xor	 r9d, r9d
  00084	45 33 c0	 xor	 r8d, r8d
  00087	ba 64 00 09 00	 mov	 edx, 589924		; 00090064H
  0008c	c7 44 24 28 60
	00 00 00	 mov	 DWORD PTR [rsp+40], 96	; 00000060H
  00094	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00099	e8 00 00 00 00	 call	 TCFsctlCall
  0009e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR DriverUnloadDisabled
  000a4	85 c0		 test	 eax, eax
  000a6	0f 49 cb	 cmovns	 ecx, ebx
  000a9	89 0d 00 00 00
	00		 mov	 DWORD PTR DriverUnloadDisabled, ecx
$LN14@UnmountDev:

; 2666 : 				DriverUnloadDisabled = TRUE;
; 2667 : 		}
; 2668 : 
; 2669 : 		// Lock volume
; 2670 : 		ntStatus = TCFsctlCall (volumeFileObject, FSCTL_LOCK_VOLUME, NULL, 0, NULL, 0);

  000af	48 8b 4c 24 30	 mov	 rcx, QWORD PTR volumeFileObject$[rsp]
  000b4	83 64 24 28 00	 and	 DWORD PTR [rsp+40], 0
  000b9	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  000bf	45 33 c9	 xor	 r9d, r9d
  000c2	45 33 c0	 xor	 r8d, r8d
  000c5	ba 18 00 09 00	 mov	 edx, 589848		; 00090018H
  000ca	e8 00 00 00 00	 call	 TCFsctlCall

; 2671 : 		Dump ("FSCTL_LOCK_VOLUME returned %X\n", ntStatus);
; 2672 : 
; 2673 : 		if (!NT_SUCCESS (ntStatus) && !ignoreOpenFiles)

  000cf	85 c0		 test	 eax, eax
  000d1	79 27		 jns	 SHORT $LN13@UnmountDev
  000d3	85 f6		 test	 esi, esi
  000d5	75 23		 jne	 SHORT $LN13@UnmountDev
$LN46@UnmountDev:

; 2674 : 		{
; 2675 : 			TCCloseFsVolume (volumeHandle, volumeFileObject);

  000d7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR volumeFileObject$[rsp]
  000dc	48 8b 7c 24 38	 mov	 rdi, QWORD PTR volumeHandle$[rsp]
  000e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject
  000e7	48 8b cf	 mov	 rcx, rdi
  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
$LN48@UnmountDev:

; 2676 : 			return ERR_FILES_OPEN;

  000f0	b8 06 00 00 00	 mov	 eax, 6
  000f5	e9 a9 01 00 00	 jmp	 $LN17@UnmountDev
$LN13@UnmountDev:

; 2677 : 		}
; 2678 : 
; 2679 : 		// Dismount volume
; 2680 : 		for (dismountRetry = 0; dismountRetry < 200; ++dismountRetry)

  000fa	33 ff		 xor	 edi, edi
$LL12@UnmountDev:

; 2681 : 		{
; 2682 : 			ntStatus = TCFsctlCall (volumeFileObject, FSCTL_DISMOUNT_VOLUME, NULL, 0, NULL, 0);

  000fc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR volumeFileObject$[rsp]
  00101	83 64 24 28 00	 and	 DWORD PTR [rsp+40], 0
  00106	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  0010c	45 33 c9	 xor	 r9d, r9d
  0010f	45 33 c0	 xor	 r8d, r8d
  00112	ba 20 00 09 00	 mov	 edx, 589856		; 00090020H
  00117	e8 00 00 00 00	 call	 TCFsctlCall

; 2683 : 			Dump ("FSCTL_DISMOUNT_VOLUME returned %X\n", ntStatus);
; 2684 : 
; 2685 : 			if (NT_SUCCESS (ntStatus) || ntStatus == STATUS_VOLUME_DISMOUNTED)

  0011c	85 c0		 test	 eax, eax
  0011e	79 2b		 jns	 SHORT $LN4@UnmountDev
  00120	3d 6e 02 00 c0	 cmp	 eax, -1073741202	; ffffffffc000026eH
  00125	74 24		 je	 SHORT $LN4@UnmountDev

; 2686 : 				break;
; 2687 : 
; 2688 : 			if (!ignoreOpenFiles)

  00127	85 f6		 test	 esi, esi
  00129	74 ac		 je	 SHORT $LN46@UnmountDev

; 2689 : 			{
; 2690 : 				TCCloseFsVolume (volumeHandle, volumeFileObject);
; 2691 : 				return ERR_FILES_OPEN;
; 2692 : 			}
; 2693 : 
; 2694 : 			TCSleep (100);

  0012b	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00130	e8 00 00 00 00	 call	 TCSleep
  00135	03 fb		 add	 edi, ebx
  00137	81 ff c8 00 00
	00		 cmp	 edi, 200		; 000000c8H
  0013d	7c bd		 jl	 SHORT $LL12@UnmountDev

; 2686 : 				break;
; 2687 : 
; 2688 : 			if (!ignoreOpenFiles)

  0013f	eb 0a		 jmp	 SHORT $LN4@UnmountDev
$LN16@UnmountDev:

; 2695 : 		}
; 2696 : 	}
; 2697 : 	else 
; 2698 : 	{
; 2699 : 		// Volume cannot be opened => force dismount if allowed
; 2700 : 		if (!ignoreOpenFiles)

  00141	85 f6		 test	 esi, esi

; 2701 : 			return ERR_FILES_OPEN;

  00143	74 ab		 je	 SHORT $LN48@UnmountDev

; 2702 : 		else
; 2703 : 			volumeHandle = NULL;

  00145	48 83 64 24 38
	00		 and	 QWORD PTR volumeHandle$[rsp], 0
$LN4@UnmountDev:

; 2704 : 	}
; 2705 : 
; 2706 : 	if (extension->bMountManager)

  0014b	41 83 bc 24 50
	03 00 00 00	 cmp	 DWORD PTR [r12+848], 0
  00154	0f 84 8a 00 00
	00		 je	 $LN38@UnmountDev

; 2707 : 		MountManagerUnmount (extension->nDosDriveNo);

  0015a	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$52038[rsp]
  00162	33 d2		 xor	 edx, edx
  00164	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0016a	e8 00 00 00 00	 call	 memset
  0016f	41 8b 54 24 14	 mov	 edx, DWORD PTR [r12+20]
  00174	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR buf$52038[rsp+24]
  0017c	e8 00 00 00 00	 call	 TCGetDosNameFromNumber
  00181	48 83 c9 ff	 or	 rcx, -1
  00185	33 c0		 xor	 eax, eax
  00187	c7 84 24 b0 00
	00 00 18 00 00
	00		 mov	 DWORD PTR buf$52038[rsp], 24
  00192	48 8d bc 24 c8
	00 00 00	 lea	 rdi, QWORD PTR buf$52038[rsp+24]
  0019a	4c 8d 84 24 b0
	00 00 00	 lea	 r8, QWORD PTR buf$52038[rsp]
  001a2	66 f2 af	 repne scasw
  001a5	48 8d 84 24 b0
	01 00 00	 lea	 rax, QWORD PTR out$52039[rsp]
  001ad	ba 04 c0 6d 00	 mov	 edx, 7192580		; 006dc004H
  001b2	48 f7 d1	 not	 rcx
  001b5	c7 44 24 28 2c
	01 00 00	 mov	 DWORD PTR [rsp+40], 300	; 0000012cH
  001bd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c2	48 2b cb	 sub	 rcx, rbx
  001c5	66 03 c9	 add	 cx, cx
  001c8	44 0f b7 c9	 movzx	 r9d, cx
  001cc	66 89 8c 24 b4
	00 00 00	 mov	 WORD PTR buf$52038[rsp+4], cx
  001d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
  001db	41 83 c1 18	 add	 r9d, 24
  001df	e8 00 00 00 00	 call	 TCDeviceIoControl
$LN38@UnmountDev:

; 2708 : 
; 2709 : 	// We always remove symbolic link as mount manager might fail to do so
; 2710 : 	RemoveDriveLink (extension->nDosDriveNo);

  001e4	41 8b 54 24 14	 mov	 edx, DWORD PTR [r12+20]
  001e9	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR link$52047[rsp]
  001f1	e8 00 00 00 00	 call	 TCGetDosNameFromNumber
  001f6	48 8d 94 24 b0
	01 00 00	 lea	 rdx, QWORD PTR link$52047[rsp]
  001fe	48 8d 4c 24 40	 lea	 rcx, QWORD PTR symLink$52048[rsp]
  00203	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString
  00209	48 8d 4c 24 40	 lea	 rcx, QWORD PTR symLink$52048[rsp]
  0020e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteSymbolicLink

; 2711 : 
; 2712 : 	extension->bShuttingDown = TRUE;
; 2713 : 
; 2714 : 	ntStatus = IoAcquireRemoveLock (&extension->Queue.RemoveLock, NULL);

  00214	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@FNODOBFM@
  0021b	49 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR [r12+384]
  00223	be 20 00 00 00	 mov	 esi, 32			; 00000020H
  00228	44 8b cb	 mov	 r9d, ebx
  0022b	33 d2		 xor	 edx, edx
  0022d	41 89 5c 24 18	 mov	 DWORD PTR [r12+24], ebx
  00232	89 74 24 20	 mov	 DWORD PTR [rsp+32], esi
  00236	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAcquireRemoveLockEx

; 2715 : 	ASSERT (NT_SUCCESS (ntStatus));
; 2716 : 	IoReleaseRemoveLockAndWait (&extension->Queue.RemoveLock, NULL);

  0023c	49 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR [r12+384]
  00244	44 8b c6	 mov	 r8d, esi
  00247	33 d2		 xor	 edx, edx
  00249	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockAndWaitEx

; 2717 : 
; 2718 : 	if (volumeHandle != NULL)

  0024f	48 8b 7c 24 38	 mov	 rdi, QWORD PTR volumeHandle$[rsp]
  00254	48 85 ff	 test	 rdi, rdi
  00257	74 14		 je	 SHORT $LN42@UnmountDev

; 2719 : 		TCCloseFsVolume (volumeHandle, volumeFileObject);

  00259	48 8b 4c 24 30	 mov	 rcx, QWORD PTR volumeFileObject$[rsp]
  0025e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject
  00264	48 8b cf	 mov	 rcx, rdi
  00267	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
$LN42@UnmountDev:

; 2720 : 
; 2721 : 	if (unmountRequest)

  0026d	4d 85 ed	 test	 r13, r13
  00270	74 23		 je	 SHORT $LN1@UnmountDev

; 2722 : 	{
; 2723 : 		PCRYPTO_INFO cryptoInfo = ((PEXTENSION) deviceObject->DeviceExtension)->cryptoInfo;

  00272	48 8b 45 40	 mov	 rax, QWORD PTR [rbp+64]
  00276	48 8b 88 90 00
	00 00		 mov	 rcx, QWORD PTR [rax+144]

; 2724 : 		unmountRequest->HiddenVolumeProtectionTriggered = (cryptoInfo->bProtectHiddenVolume && cryptoInfo->bHiddenVolProtectionAction);

  0027d	83 b9 00 44 00
	00 00		 cmp	 DWORD PTR [rcx+17408], 0
  00284	74 09		 je	 SHORT $LN19@UnmountDev
  00286	83 b9 04 44 00
	00 00		 cmp	 DWORD PTR [rcx+17412], 0
  0028d	75 02		 jne	 SHORT $LN20@UnmountDev
$LN19@UnmountDev:
  0028f	33 db		 xor	 ebx, ebx
$LN20@UnmountDev:
  00291	41 89 5d 08	 mov	 DWORD PTR [r13+8], ebx
$LN1@UnmountDev:

; 2725 : 	}
; 2726 : 
; 2727 : 	TCDeleteDeviceObject (deviceObject, (PEXTENSION) deviceObject->DeviceExtension);

  00295	48 8b 55 40	 mov	 rdx, QWORD PTR [rbp+64]
  00299	48 8b cd	 mov	 rcx, rbp
  0029c	e8 00 00 00 00	 call	 TCDeleteDeviceObject

; 2728 : 	return 0;

  002a1	33 c0		 xor	 eax, eax
$LN17@UnmountDev:

; 2729 : }

  002a3	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002ab	48 33 cc	 xor	 rcx, rsp
  002ae	e8 00 00 00 00	 call	 __security_check_cookie
  002b3	48 8b 9c 24 00
	04 00 00	 mov	 rbx, QWORD PTR [rsp+1024]
  002bb	48 81 c4 c0 03
	00 00		 add	 rsp, 960		; 000003c0H
  002c2	41 5d		 pop	 r13
  002c4	41 5c		 pop	 r12
  002c6	5f		 pop	 rdi
  002c7	5e		 pop	 rsi
  002c8	5d		 pop	 rbp
  002c9	c3		 ret	 0
UnmountDevice ENDP
PUBLIC	UnmountAllDevices
;	COMDAT pdata
pdata	SEGMENT
$pdata$UnmountAllDevices DD imagerel $LN31
	DD	imagerel $LN31+219
	DD	imagerel $unwind$UnmountAllDevices
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$UnmountAllDevices DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0d0143218H
	DD	07010c012H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT UnmountAllDevices
_TEXT	SEGMENT
unmountRequest$ = 64
ignoreOpenFiles$ = 72
UnmountAllDevices PROC					; COMDAT

; 2757 : {

$LN31:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2758 : 	NTSTATUS status = 0;
; 2759 : 	PDEVICE_OBJECT ListDevice;
; 2760 : 	int maxUniqueId = LastUniqueVolumeId;

  00018	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR LastUniqueVolumeId
  0001e	45 33 e4	 xor	 r12d, r12d
  00021	44 8b ea	 mov	 r13d, edx
  00024	48 8b d9	 mov	 rbx, rcx

; 2761 : 
; 2762 : 	Dump ("Unmounting all volumes\n");
; 2763 : 
; 2764 : 	if (unmountRequest)

  00027	48 85 c9	 test	 rcx, rcx
  0002a	74 04		 je	 SHORT $LL5@UnmountAll

; 2765 : 		unmountRequest->HiddenVolumeProtectionTriggered = FALSE;

  0002c	44 21 61 08	 and	 DWORD PTR [rcx+8], r12d
$LL5@UnmountAll:

; 2766 : 
; 2767 : 	// Dismount volumes in the reverse order they were mounted to properly dismount nested volumes
; 2768 : 	while ((ListDevice = FindVolumeWithHighestUniqueId (maxUniqueId)) != NULL)

  00030	33 c9		 xor	 ecx, ecx
  00032	33 f6		 xor	 esi, esi
  00034	41 83 c8 ff	 or	 r8d, -1
  00038	48 83 f9 19	 cmp	 rcx, 25
$LN30@UnmountAll:
  0003c	77 0d		 ja	 SHORT $LN16@UnmountAll
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:VirtualVolumeDeviceObjects
  00045	48 8b 14 ca	 mov	 rdx, QWORD PTR [rdx+rcx*8]
  00049	eb 02		 jmp	 SHORT $LN18@UnmountAll
$LN16@UnmountAll:
  0004b	33 d2		 xor	 edx, edx
$LN18@UnmountAll:
  0004d	48 85 d2	 test	 rdx, rdx
  00050	74 16		 je	 SHORT $LN12@UnmountAll
  00052	48 8b 42 40	 mov	 rax, QWORD PTR [rdx+64]
  00056	44 39 40 10	 cmp	 DWORD PTR [rax+16], r8d
  0005a	7e 0c		 jle	 SHORT $LN12@UnmountAll
  0005c	39 68 10	 cmp	 DWORD PTR [rax+16], ebp
  0005f	7f 07		 jg	 SHORT $LN12@UnmountAll
  00061	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  00065	48 8b f2	 mov	 rsi, rdx
$LN12@UnmountAll:
  00068	48 ff c1	 inc	 rcx
  0006b	48 83 f9 19	 cmp	 rcx, 25
  0006f	7e cb		 jle	 SHORT $LN30@UnmountAll
  00071	48 85 f6	 test	 rsi, rsi
  00074	74 49		 je	 SHORT $LN22@UnmountAll

; 2769 : 	{
; 2770 : 		PEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;

  00076	48 8b 7e 40	 mov	 rdi, QWORD PTR [rsi+64]

; 2771 : 		maxUniqueId = ListExtension->UniqueVolumeId - 1;
; 2772 : 
; 2773 : 		if (IsVolumeAccessibleByCurrentUser (ListExtension))

  0007a	48 8b cf	 mov	 rcx, rdi
  0007d	8b 6f 10	 mov	 ebp, DWORD PTR [rdi+16]
  00080	ff cd		 dec	 ebp
  00082	e8 00 00 00 00	 call	 IsVolumeAccessibleByCurrentUser
  00087	85 c0		 test	 eax, eax
  00089	74 a5		 je	 SHORT $LL5@UnmountAll

; 2774 : 		{
; 2775 : 			NTSTATUS ntStatus;
; 2776 : 
; 2777 : 			if (unmountRequest)

  0008b	48 85 db	 test	 rbx, rbx
  0008e	74 05		 je	 SHORT $LN2@UnmountAll

; 2778 : 				unmountRequest->nDosDriveNo = ListExtension->nDosDriveNo;

  00090	8b 47 14	 mov	 eax, DWORD PTR [rdi+20]
  00093	89 03		 mov	 DWORD PTR [rbx], eax
$LN2@UnmountAll:

; 2779 : 
; 2780 : 			ntStatus = UnmountDevice (unmountRequest, ListDevice, ignoreOpenFiles);

  00095	45 8b c5	 mov	 r8d, r13d
  00098	48 8b d6	 mov	 rdx, rsi
  0009b	48 8b cb	 mov	 rcx, rbx
  0009e	e8 00 00 00 00	 call	 UnmountDevice

; 2781 : 			status = ntStatus == 0 ? status : ntStatus;

  000a3	85 c0		 test	 eax, eax
  000a5	41 0f 44 c4	 cmove	 eax, r12d
  000a9	44 8b e0	 mov	 r12d, eax

; 2782 : 
; 2783 : 			if (unmountRequest && unmountRequest->HiddenVolumeProtectionTriggered)

  000ac	48 85 db	 test	 rbx, rbx
  000af	0f 84 7b ff ff
	ff		 je	 $LL5@UnmountAll
  000b5	83 7b 08 00	 cmp	 DWORD PTR [rbx+8], 0

; 2784 : 				break;
; 2785 : 		}
; 2786 : 	}

  000b9	0f 84 71 ff ff
	ff		 je	 $LL5@UnmountAll
$LN22@UnmountAll:

; 2787 : 
; 2788 : 	return status;
; 2789 : }

  000bf	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c4	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000c9	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000ce	41 8b c4	 mov	 eax, r12d
  000d1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d5	41 5d		 pop	 r13
  000d7	41 5c		 pop	 r12
  000d9	5f		 pop	 rdi
  000da	c3		 ret	 0
UnmountAllDevices ENDP
PUBLIC	VolumeThreadProc
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$VolumeThreadProc DD imagerel $LN29
	DD	imagerel $LN29+612
	DD	imagerel $unwind$VolumeThreadProc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$VolumeThreadProc DD 0c1c01H
	DD	0e641cH
	DD	0d541cH
	DD	0c341cH
	DD	0f018521cH
	DD	0d014e016H
	DD	07010c012H
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed.build\src\driver\ntdriver.c
xdata	ENDS
;	COMDAT VolumeThreadProc
_TEXT	SEGMENT
Context$ = 96
VolumeThreadProc PROC					; COMDAT

; 1739 : {

$LN29:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1740 : 	PTHREAD_BLOCK pThreadBlock = (PTHREAD_BLOCK) Context;
; 1741 : 	PDEVICE_OBJECT DeviceObject = pThreadBlock->DeviceObject;

  0001c	48 8b 29	 mov	 rbp, QWORD PTR [rcx]
  0001f	48 8b d9	 mov	 rbx, rcx

; 1742 : 	PEXTENSION Extension = (PEXTENSION) DeviceObject->DeviceExtension;
; 1743 : 	BOOL bDevice;
; 1744 : 
; 1745 : 	/* Set thread priority to lowest realtime level. */
; 1746 : 	KeSetPriorityThread (KeGetCurrentThread (), LOW_REALTIME_PRIORITY);

  00022	65 48 8b 0c 25
	88 01 00 00	 mov	 rcx, QWORD PTR gs:392
  0002b	48 8b 7d 40	 mov	 rdi, QWORD PTR [rbp+64]
  0002f	ba 10 00 00 00	 mov	 edx, 16
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetPriorityThread

; 1747 : 
; 1748 : 	Dump ("Mount THREAD OPENING VOLUME BEGIN\n");
; 1749 : 
; 1750 : 	if (memcmp (pThreadBlock->mount->wszVolume, WIDE ("\\Device"), 14) != 0)

  0003a	4c 8b 8b 28 02
	00 00		 mov	 r9, QWORD PTR [rbx+552]
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BA@CCLAPIHO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@
  00048	49 8b 51 10	 mov	 rdx, QWORD PTR [r9+16]
  0004c	45 33 e4	 xor	 r12d, r12d
  0004f	48 3b 11	 cmp	 rdx, QWORD PTR [rcx]
  00052	75 19		 jne	 SHORT $LN27@VolumeThre
  00054	41 8b 51 18	 mov	 edx, DWORD PTR [r9+24]
  00058	3b 51 08	 cmp	 edx, DWORD PTR [rcx+8]
  0005b	75 10		 jne	 SHORT $LN27@VolumeThre
  0005d	66 41 8b 51 1c	 mov	 dx, WORD PTR [r9+28]
  00062	66 3b 51 0c	 cmp	 dx, WORD PTR [rcx+12]
  00066	75 05		 jne	 SHORT $LN27@VolumeThre
  00068	41 8b c4	 mov	 eax, r12d
  0006b	eb 05		 jmp	 SHORT $LN28@VolumeThre
$LN27@VolumeThre:
  0006d	1b c0		 sbb	 eax, eax
  0006f	83 d8 ff	 sbb	 eax, -1
$LN28@VolumeThre:
  00072	41 bd 01 00 00
	00		 mov	 r13d, 1

; 1751 : 	{
; 1752 : 		wcscpy (pThreadBlock->wszMountVolume, WIDE ("\\??\\"));

  00078	48 8d 73 0c	 lea	 rsi, QWORD PTR [rbx+12]
  0007c	41 3b c4	 cmp	 eax, r12d
  0007f	74 3d		 je	 SHORT $LN13@VolumeThre
  00081	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_19JHEHLFPM@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$AA@FNODOBFM@
  00088	48 8b d6	 mov	 rdx, rsi
  0008b	48 2b d1	 sub	 rdx, rcx
$LL16@VolumeThre:
  0008e	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00091	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00095	48 83 c1 02	 add	 rcx, 2
  00099	66 41 3b c4	 cmp	 ax, r12w
  0009d	75 ef		 jne	 SHORT $LL16@VolumeThre

; 1753 : 		wcsncat (pThreadBlock->wszMountVolume, pThreadBlock->mount->wszVolume,
; 1754 : 			sizeof (pThreadBlock->wszMountVolume) / 2 - 5);

  0009f	48 8b 93 28 02
	00 00		 mov	 rdx, QWORD PTR [rbx+552]
  000a6	41 b8 07 01 00
	00		 mov	 r8d, 263		; 00000107H
  000ac	48 8b ce	 mov	 rcx, rsi
  000af	48 83 c2 10	 add	 rdx, 16
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncat

; 1755 : 		bDevice = FALSE;

  000b9	45 8b dc	 mov	 r11d, r12d

; 1756 : 	}
; 1757 : 	else

  000bc	eb 1a		 jmp	 SHORT $LN12@VolumeThre
$LN13@VolumeThre:

; 1758 : 	{
; 1759 : 		pThreadBlock->wszMountVolume[0] = 0;
; 1760 : 		wcsncat (pThreadBlock->wszMountVolume, pThreadBlock->mount->wszVolume,
; 1761 : 			sizeof (pThreadBlock->wszMountVolume) / 2 - 1);

  000be	49 8d 51 10	 lea	 rdx, QWORD PTR [r9+16]
  000c2	41 b8 0b 01 00
	00		 mov	 r8d, 267		; 0000010bH
  000c8	48 8b ce	 mov	 rcx, rsi
  000cb	66 44 89 26	 mov	 WORD PTR [rsi], r12w
  000cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncat

; 1762 : 		bDevice = TRUE;

  000d5	45 8b dd	 mov	 r11d, r13d
$LN12@VolumeThre:

; 1763 : 	}
; 1764 : 
; 1765 : 	Dump ("Mount THREAD request for File %ls DriveNumber %d Device = %d\n",
; 1766 : 	      pThreadBlock->wszMountVolume, pThreadBlock->mount->nDosDriveNo, bDevice);
; 1767 : 
; 1768 : 	pThreadBlock->ntCreateStatus = TCOpenVolume (DeviceObject,
; 1769 : 		Extension,
; 1770 : 		pThreadBlock->mount,
; 1771 : 		pThreadBlock->wszMountVolume,
; 1772 : 		bDevice);

  000d8	4c 8b 83 28 02
	00 00		 mov	 r8, QWORD PTR [rbx+552]
  000df	4c 8b ce	 mov	 r9, rsi
  000e2	48 8b d7	 mov	 rdx, rdi
  000e5	48 8b cd	 mov	 rcx, rbp
  000e8	44 89 5c 24 20	 mov	 DWORD PTR [rsp+32], r11d
  000ed	e8 00 00 00 00	 call	 TCOpenVolume

; 1773 : 
; 1774 : 	if (!NT_SUCCESS (pThreadBlock->ntCreateStatus) || pThreadBlock->mount->nReturnCode != 0)

  000f2	41 3b c4	 cmp	 eax, r12d
  000f5	89 43 08	 mov	 DWORD PTR [rbx+8], eax
  000f8	7c 0c		 jl	 SHORT $LN10@VolumeThre
  000fa	48 8b 83 28 02
	00 00		 mov	 rax, QWORD PTR [rbx+552]
  00101	44 39 20	 cmp	 DWORD PTR [rax], r12d
  00104	74 17		 je	 SHORT $LN11@VolumeThre
$LN10@VolumeThre:

; 1775 : 	{
; 1776 : 		KeSetEvent (&Extension->keCreateEvent, 0, FALSE);

  00106	48 8d 4f 28	 lea	 rcx, QWORD PTR [rdi+40]
  0010a	45 33 c0	 xor	 r8d, r8d
  0010d	33 d2		 xor	 edx, edx
  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 1777 : 		PsTerminateSystemThread (STATUS_SUCCESS);

  00115	33 c9		 xor	 ecx, ecx
  00117	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsTerminateSystemThread
$LN11@VolumeThre:

; 1778 : 	}
; 1779 : 
; 1780 : 	// Start IO queue
; 1781 : 	Extension->Queue.IsFilterDevice = FALSE;
; 1782 : 	Extension->Queue.DeviceObject = DeviceObject;
; 1783 : 	Extension->Queue.CryptoInfo = Extension->cryptoInfo;

  0011d	48 8b 87 90 00
	00 00		 mov	 rax, QWORD PTR [rdi+144]
  00124	44 89 a7 48 01
	00 00		 mov	 DWORD PTR [rdi+328], r12d
  0012b	48 89 af e0 00
	00 00		 mov	 QWORD PTR [rdi+224], rbp
  00132	48 89 87 28 01
	00 00		 mov	 QWORD PTR [rdi+296], rax

; 1784 : 	Extension->Queue.HostFileHandle = Extension->hDeviceFile;

  00139	48 8b 47 78	 mov	 rax, QWORD PTR [rdi+120]
  0013d	48 89 87 30 01
	00 00		 mov	 QWORD PTR [rdi+304], rax

; 1785 : 	Extension->Queue.VirtualDeviceLength = Extension->DiskLength;

  00144	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
  0014b	48 89 87 38 01
	00 00		 mov	 QWORD PTR [rdi+312], rax

; 1786 : 	Extension->Queue.MaxReadAheadOffset.QuadPart = Extension->HostLength;

  00152	48 8b 87 98 00
	00 00		 mov	 rax, QWORD PTR [rdi+152]
  00159	48 89 87 b8 02
	00 00		 mov	 QWORD PTR [rdi+696], rax

; 1787 : 
; 1788 : 	if (Extension->SecurityClientContextValid)

  00160	44 39 a7 90 05
	00 00		 cmp	 DWORD PTR [rdi+1424], r12d
  00167	74 10		 je	 SHORT $LN9@VolumeThre

; 1789 : 		Extension->Queue.SecurityClientContext = &Extension->SecurityClientContext;

  00169	48 8d 87 98 05
	00 00		 lea	 rax, QWORD PTR [rdi+1432]
  00170	48 89 87 40 01
	00 00		 mov	 QWORD PTR [rdi+320], rax

; 1790 : 	else

  00177	eb 07		 jmp	 SHORT $LN8@VolumeThre
$LN9@VolumeThre:

; 1791 : 		Extension->Queue.SecurityClientContext = NULL;

  00179	4c 89 a7 40 01
	00 00		 mov	 QWORD PTR [rdi+320], r12
$LN8@VolumeThre:

; 1792 : 
; 1793 : 	pThreadBlock->ntCreateStatus = EncryptedIoQueueStart (&Extension->Queue);

  00180	48 8d 8f e0 00
	00 00		 lea	 rcx, QWORD PTR [rdi+224]
  00187	e8 00 00 00 00	 call	 EncryptedIoQueueStart

; 1794 : 
; 1795 : 	if (!NT_SUCCESS (pThreadBlock->ntCreateStatus))

  0018c	41 3b c4	 cmp	 eax, r12d
  0018f	89 43 08	 mov	 DWORD PTR [rbx+8], eax
  00192	7d 2c		 jge	 SHORT $LN7@VolumeThre

; 1796 : 	{
; 1797 : 		TCCloseVolume (DeviceObject, Extension);

  00194	48 8b d7	 mov	 rdx, rdi
  00197	48 8b cd	 mov	 rcx, rbp
  0019a	e8 00 00 00 00	 call	 TCCloseVolume

; 1798 : 
; 1799 : 		pThreadBlock->mount->nReturnCode = ERR_OS_ERROR;

  0019f	4c 8b 9b 28 02
	00 00		 mov	 r11, QWORD PTR [rbx+552]

; 1800 : 		KeSetEvent (&Extension->keCreateEvent, 0, FALSE);

  001a6	48 8d 4f 28	 lea	 rcx, QWORD PTR [rdi+40]
  001aa	45 33 c0	 xor	 r8d, r8d
  001ad	33 d2		 xor	 edx, edx
  001af	45 89 2b	 mov	 DWORD PTR [r11], r13d
  001b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 1801 : 		PsTerminateSystemThread (STATUS_SUCCESS);

  001b8	33 c9		 xor	 ecx, ecx
  001ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsTerminateSystemThread
$LN7@VolumeThre:

; 1802 : 	}
; 1803 : 
; 1804 : 	KeSetEvent (&Extension->keCreateEvent, 0, FALSE);

  001c0	48 8d 4f 28	 lea	 rcx, QWORD PTR [rdi+40]
  001c4	45 33 c0	 xor	 r8d, r8d
  001c7	33 d2		 xor	 edx, edx
  001c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent
$LL6@VolumeThre:

; 1805 : 	/* From this point on pThreadBlock cannot be used as it will have been released! */
; 1806 : 	pThreadBlock = NULL;
; 1807 : 
; 1808 : 	for (;;)
; 1809 : 	{
; 1810 : 		/* Wait for a request from the dispatch routines. */
; 1811 : 		KeWaitForSingleObject ((PVOID) & Extension->RequestSemaphore, Executive, KernelMode, FALSE, NULL);

  001cf	48 8d 4f 58	 lea	 rcx, QWORD PTR [rdi+88]
  001d3	45 33 c9	 xor	 r9d, r9d
  001d6	45 33 c0	 xor	 r8d, r8d
  001d9	33 d2		 xor	 edx, edx
  001db	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  001e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 1812 : 
; 1813 : 		for (;;)
; 1814 : 		{
; 1815 : 			PIO_STACK_LOCATION irpSp;
; 1816 : 			PLIST_ENTRY request;
; 1817 : 			PIRP irp;
; 1818 : 
; 1819 : 			request = ExInterlockedRemoveHeadList (&Extension->ListEntry, &Extension->ListSpinLock);

  001e6	48 8d 57 40	 lea	 rdx, QWORD PTR [rdi+64]
  001ea	48 8d 4f 48	 lea	 rcx, QWORD PTR [rdi+72]
  001ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExInterlockedRemoveHeadList

; 1820 : 			if (request == NULL)

  001f4	49 3b c4	 cmp	 rax, r12
  001f7	74 41		 je	 SHORT $LN25@VolumeThre
$LL4@VolumeThre:

; 1821 : 				break;
; 1822 : 
; 1823 : 			irp = CONTAINING_RECORD (request, IRP, Tail.Overlay.ListEntry);

  001f9	48 8d 98 58 ff
	ff ff		 lea	 rbx, QWORD PTR [rax-168]

; 1824 : 			irpSp = IoGetCurrentIrpStackLocation (irp);
; 1825 : 
; 1826 : 			ASSERT (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL);
; 1827 : 
; 1828 : 			ProcessVolumeDeviceControlIrp (DeviceObject, Extension, irp);

  00200	48 8b d7	 mov	 rdx, rdi
  00203	48 8b cd	 mov	 rcx, rbp
  00206	4c 8b c3	 mov	 r8, rbx
  00209	e8 00 00 00 00	 call	 ProcessVolumeDeviceControlIrp

; 1829 : 			IoReleaseRemoveLock (&Extension->Queue.RemoveLock, irp);

  0020e	48 8d 8f 80 01
	00 00		 lea	 rcx, QWORD PTR [rdi+384]
  00215	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  0021b	48 8b d3	 mov	 rdx, rbx
  0021e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx
  00224	48 8d 57 40	 lea	 rdx, QWORD PTR [rdi+64]
  00228	48 8d 4f 48	 lea	 rcx, QWORD PTR [rdi+72]
  0022c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExInterlockedRemoveHeadList
  00232	48 85 c0	 test	 rax, rax
  00235	75 c2		 jne	 SHORT $LL4@VolumeThre
  00237	45 33 e4	 xor	 r12d, r12d
$LN25@VolumeThre:

; 1830 : 		}
; 1831 : 
; 1832 : 		if (Extension->bThreadShouldQuit)

  0023a	44 39 67 1c	 cmp	 DWORD PTR [rdi+28], r12d
  0023e	74 8f		 je	 SHORT $LL6@VolumeThre

; 1833 : 		{
; 1834 : 			Dump ("Closing volume\n");
; 1835 : 			EncryptedIoQueueStop (&Extension->Queue);

  00240	48 8d 8f e0 00
	00 00		 lea	 rcx, QWORD PTR [rdi+224]
  00247	e8 00 00 00 00	 call	 EncryptedIoQueueStop

; 1836 : 
; 1837 : 			TCCloseVolume (DeviceObject, Extension);

  0024c	48 8b d7	 mov	 rdx, rdi
  0024f	48 8b cd	 mov	 rcx, rbp
  00252	e8 00 00 00 00	 call	 TCCloseVolume

; 1838 : 			PsTerminateSystemThread (STATUS_SUCCESS);

  00257	33 c9		 xor	 ecx, ecx
  00259	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsTerminateSystemThread
  0025f	e9 6b ff ff ff	 jmp	 $LL6@VolumeThre
VolumeThreadProc ENDP
_TEXT	ENDS
PUBLIC	TCStartVolumeThread
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$TCStartVolumeThread DD imagerel $LN12
	DD	imagerel $LN12+382
	DD	imagerel $unwind$TCStartVolumeThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCStartVolumeThread DD 081701H
	DD	0146417H
	DD	0135417H
	DD	0123417H
	DD	07010f217H
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed.build\src\driver\ntdriver.c
xdata	ENDS
;	COMDAT TCStartVolumeThread
_TEXT	SEGMENT
qos$ = 64
threadObjAttributes$ = 80
DeviceObject$ = 144
Extension$ = 152
mount$ = 160
hThread$ = 168
TCStartVolumeThread PROC				; COMDAT

; 1611 : {

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00017	49 8b d8	 mov	 rbx, r8
  0001a	48 8b f2	 mov	 rsi, rdx
  0001d	48 8b e9	 mov	 rbp, rcx

; 1612 : 	PTHREAD_BLOCK pThreadBlock = TCalloc (sizeof (THREAD_BLOCK));

  00020	ba 30 02 00 00	 mov	 edx, 560		; 00000230H
  00025	33 c9		 xor	 ecx, ecx
  00027	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00033	48 8b f8	 mov	 rdi, rax

; 1613 : 	HANDLE hThread;
; 1614 : 	NTSTATUS ntStatus;
; 1615 : 	OBJECT_ATTRIBUTES threadObjAttributes;
; 1616 : 	SECURITY_QUALITY_OF_SERVICE qos;
; 1617 : 
; 1618 : 	Dump ("Starting thread...\n");
; 1619 : 
; 1620 : 	if (pThreadBlock == NULL)

  00036	48 85 c0	 test	 rax, rax
  00039	75 0a		 jne	 SHORT $LN5@TCStartVol

; 1621 : 	{
; 1622 : 		return STATUS_INSUFFICIENT_RESOURCES;

  0003b	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  00040	e9 20 01 00 00	 jmp	 $LN6@TCStartVol
$LN5@TCStartVol:

; 1623 : 	}
; 1624 : 	else
; 1625 : 	{
; 1626 : 		pThreadBlock->DeviceObject = DeviceObject;

  00045	48 89 28	 mov	 QWORD PTR [rax], rbp

; 1627 : 		pThreadBlock->mount = mount;

  00048	48 89 98 28 02
	00 00		 mov	 QWORD PTR [rax+552], rbx

; 1628 : 	}
; 1629 : 
; 1630 : 	qos.Length = sizeof (qos);

  0004f	c7 44 24 40 0c
	00 00 00	 mov	 DWORD PTR qos$[rsp], 12

; 1631 : 	qos.ContextTrackingMode = SECURITY_STATIC_TRACKING;

  00057	c6 44 24 48 00	 mov	 BYTE PTR qos$[rsp+8], 0

; 1632 : 	qos.EffectiveOnly = TRUE;

  0005c	c6 44 24 49 01	 mov	 BYTE PTR qos$[rsp+9], 1

; 1633 : 	qos.ImpersonationLevel = SecurityImpersonation;

  00061	c7 44 24 44 02
	00 00 00	 mov	 DWORD PTR qos$[rsp+4], 2

; 1634 : 
; 1635 : 	ntStatus = SeCreateClientSecurity (PsGetCurrentThread(), &qos, FALSE, &Extension->SecurityClientContext);

  00069	65 48 8b 0c 25
	88 01 00 00	 mov	 rcx, QWORD PTR gs:392
  00072	4c 8d 8e 98 05
	00 00		 lea	 r9, QWORD PTR [rsi+1432]
  00079	48 8d 54 24 40	 lea	 rdx, QWORD PTR qos$[rsp]
  0007e	45 33 c0	 xor	 r8d, r8d
  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeCreateClientSecurity
  00087	8b d8		 mov	 ebx, eax

; 1636 : 	if (!NT_SUCCESS (ntStatus))

  00089	85 c0		 test	 eax, eax
  0008b	0f 88 c4 00 00
	00		 js	 $ret$32125

; 1637 : 		goto ret;
; 1638 : 
; 1639 : 	Extension->SecurityClientContextValid = TRUE;
; 1640 : 
; 1641 : 	Extension->bThreadShouldQuit = FALSE;

  00091	83 66 1c 00	 and	 DWORD PTR [rsi+28], 0

; 1642 : 
; 1643 : 	InitializeObjectAttributes (&threadObjAttributes, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);

  00095	48 83 64 24 58
	00		 and	 QWORD PTR threadObjAttributes$[rsp+8], 0
  0009b	48 83 64 24 60
	00		 and	 QWORD PTR threadObjAttributes$[rsp+16], 0
  000a1	48 83 64 24 70
	00		 and	 QWORD PTR threadObjAttributes$[rsp+32], 0
  000a7	48 83 64 24 78
	00		 and	 QWORD PTR threadObjAttributes$[rsp+40], 0

; 1644 : 
; 1645 : 	ntStatus = PsCreateSystemThread (&hThread,
; 1646 : 					 THREAD_ALL_ACCESS,
; 1647 : 					 &threadObjAttributes,
; 1648 : 					 NULL,
; 1649 : 					 NULL,
; 1650 : 					 VolumeThreadProc,
; 1651 : 					 pThreadBlock);

  000ad	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:VolumeThreadProc
  000b4	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  000b9	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000be	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  000c4	bd ff 03 1f 00	 mov	 ebp, 2032639		; 001f03ffH
  000c9	4c 8d 44 24 50	 lea	 r8, QWORD PTR threadObjAttributes$[rsp]
  000ce	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR hThread$[rsp]
  000d6	45 33 c9	 xor	 r9d, r9d
  000d9	8b d5		 mov	 edx, ebp
  000db	c7 86 90 05 00
	00 01 00 00 00	 mov	 DWORD PTR [rsi+1424], 1
  000e5	c7 44 24 50 30
	00 00 00	 mov	 DWORD PTR threadObjAttributes$[rsp], 48 ; 00000030H
  000ed	c7 44 24 68 00
	02 00 00	 mov	 DWORD PTR threadObjAttributes$[rsp+24], 512 ; 00000200H
  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsCreateSystemThread
  000fb	8b d8		 mov	 ebx, eax

; 1652 : 
; 1653 : 	if (!NT_SUCCESS (ntStatus))

  000fd	85 c0		 test	 eax, eax
  000ff	78 54		 js	 SHORT $ret$32125

; 1654 : 	{
; 1655 : 		Dump ("PsCreateSystemThread Failed END\n");
; 1656 : 		goto ret;
; 1657 : 	}
; 1658 : 
; 1659 : 	ntStatus = ObReferenceObjectByHandle (hThread,
; 1660 : 				   THREAD_ALL_ACCESS,
; 1661 : 				   NULL,
; 1662 : 				   KernelMode,
; 1663 : 				   &Extension->peThread,
; 1664 : 				   NULL);

  00101	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR hThread$[rsp]
  00109	48 83 64 24 28
	00		 and	 QWORD PTR [rsp+40], 0
  0010f	48 8d 46 20	 lea	 rax, QWORD PTR [rsi+32]
  00113	45 33 c9	 xor	 r9d, r9d
  00116	45 33 c0	 xor	 r8d, r8d
  00119	8b d5		 mov	 edx, ebp
  0011b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00120	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObReferenceObjectByHandle

; 1665 : 
; 1666 : 	ZwClose (hThread);

  00126	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR hThread$[rsp]
  0012e	8b d8		 mov	 ebx, eax
  00130	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 1667 : 
; 1668 : 	if (!NT_SUCCESS (ntStatus))

  00136	85 db		 test	 ebx, ebx
  00138	78 1b		 js	 SHORT $ret$32125

; 1669 : 		goto ret;
; 1670 : 
; 1671 : 	Dump ("Waiting for thread to initialize...\n");
; 1672 : 
; 1673 : 	KeWaitForSingleObject (&Extension->keCreateEvent,
; 1674 : 			       Executive,
; 1675 : 			       KernelMode,
; 1676 : 			       FALSE,
; 1677 : 			       NULL);

  0013a	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00140	48 8d 4e 28	 lea	 rcx, QWORD PTR [rsi+40]
  00144	45 33 c9	 xor	 r9d, r9d
  00147	45 33 c0	 xor	 r8d, r8d
  0014a	33 d2		 xor	 edx, edx
  0014c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 1678 : 
; 1679 : 	Dump ("Waiting completed! Thread returns 0x%08x\n", pThreadBlock->ntCreateStatus);
; 1680 : 	ntStatus = pThreadBlock->ntCreateStatus;

  00152	8b 5f 08	 mov	 ebx, DWORD PTR [rdi+8]
$ret$32125:

; 1681 : 
; 1682 : ret:
; 1683 : 	TCfree (pThreadBlock);

  00155	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  0015a	48 8b cf	 mov	 rcx, rdi
  0015d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 1684 : 	return ntStatus;

  00163	8b c3		 mov	 eax, ebx
$LN6@TCStartVol:

; 1685 : }

  00165	4c 8d 9c 24 80
	00 00 00	 lea	 r11, QWORD PTR [rsp+128]
  0016d	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00171	49 8b 6b 18	 mov	 rbp, QWORD PTR [r11+24]
  00175	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  00179	49 8b e3	 mov	 rsp, r11
  0017c	5f		 pop	 rdi
  0017d	c3		 ret	 0
TCStartVolumeThread ENDP
PUBLIC	mount$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	MountDevice
EXTRN	__GSHandlerCheck_SEH:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$MountDevice DD imagerel $LN32
	DD	imagerel $LN32+706
	DD	imagerel $unwind$MountDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MountDevice DD 072419H
	DD	0596412H
	DD	0583412H
	DD	0540112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck_SEH
	DD	01H
	DD	imagerel $LN32+547
	DD	imagerel $LN32+606
	DD	01H
	DD	imagerel $LN32+606
	DD	0291H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT MountDevice
_TEXT	SEGMENT
NewDeviceObject$ = 48
deviceName$54855 = 56
fsStatus$32585 = 56
tokenUser$32564 = 56
volumeFileObject$32579 = 72
volumeHandle$32578 = 80
mount$GSCopy$ = 88
subContext$32552 = 96
symLink$54856 = 128
dev$54853 = 144
link$54854 = 400
__$ArrayPad$ = 656
DeviceObject$ = 688
mount$ = 696
MountDevice PROC					; COMDAT

; 2514 : {

$LN32:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec a0 02
	00 00		 sub	 rsp, 672		; 000002a0H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 90
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00024	48 8b fa	 mov	 rdi, rdx
  00027	48 8b d9	 mov	 rbx, rcx

; 2515 : 	PDEVICE_OBJECT NewDeviceObject;
; 2516 : 	NTSTATUS ntStatus;
; 2517 : 
; 2518 : 	// Make sure the user is asking for a reasonable nDosDriveNo
; 2519 : 	if (mount->nDosDriveNo >= 0 && mount->nDosDriveNo <= 25 && IsDriveLetterAvailable (mount->nDosDriveNo))

  0002a	48 89 54 24 58	 mov	 QWORD PTR mount$GSCopy$[rsp], rdx
  0002f	8b 8a 64 02 00
	00		 mov	 ecx, DWORD PTR [rdx+612]
  00035	85 c9		 test	 ecx, ecx
  00037	0f 88 59 02 00
	00		 js	 $LN20@MountDevic
  0003d	83 f9 19	 cmp	 ecx, 25
  00040	0f 8f 50 02 00
	00		 jg	 $LN20@MountDevic
  00046	e8 00 00 00 00	 call	 IsDriveLetterAvailable
  0004b	85 c0		 test	 eax, eax
  0004d	0f 84 43 02 00
	00		 je	 $LN20@MountDevic

; 2527 : 		return ERR_DRIVE_NOT_FOUND;
; 2528 : 	}
; 2529 : 
; 2530 : 	if (!SelfTestsPassed)

  00053	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR SelfTestsPassed, 0
  0005a	75 0c		 jne	 SHORT $LN18@MountDevic

; 2531 : 	{
; 2532 : 		mount->nReturnCode = ERR_SELF_TESTS_FAILED;

  0005c	b8 13 00 00 00	 mov	 eax, 19
  00061	89 07		 mov	 DWORD PTR [rdi], eax

; 2533 : 		return ERR_SELF_TESTS_FAILED;

  00063	e9 35 02 00 00	 jmp	 $LN8@MountDevic
$LN18@MountDevic:

; 2534 : 	}
; 2535 : 
; 2536 : 	ntStatus = TCCreateDeviceObject (DeviceObject->DriverObject, &NewDeviceObject, mount);

  00068	4c 8b c7	 mov	 r8, rdi
  0006b	48 8d 54 24 30	 lea	 rdx, QWORD PTR NewDeviceObject$[rsp]
  00070	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  00074	e8 00 00 00 00	 call	 TCCreateDeviceObject

; 2537 : 
; 2538 : 	if (!NT_SUCCESS (ntStatus))

  00079	85 c0		 test	 eax, eax

; 2539 : 	{
; 2540 : 		Dump ("Mount CREATE DEVICE ERROR, ntStatus = 0x%08x\n", ntStatus);
; 2541 : 		return ntStatus;

  0007b	0f 88 1c 02 00
	00		 js	 $LN8@MountDevic

; 2542 : 	}
; 2543 : 	else
; 2544 : 	{
; 2545 : 		PEXTENSION NewExtension = (PEXTENSION) NewDeviceObject->DeviceExtension;

  00081	48 8b 44 24 30	 mov	 rax, QWORD PTR NewDeviceObject$[rsp]
  00086	48 8b 70 40	 mov	 rsi, QWORD PTR [rax+64]

; 2546 : 		SECURITY_SUBJECT_CONTEXT subContext;
; 2547 : 		PACCESS_TOKEN accessToken;
; 2548 : 
; 2549 : 		SeCaptureSubjectContext (&subContext);

  0008a	48 8d 4c 24 60	 lea	 rcx, QWORD PTR subContext$32552[rsp]
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeCaptureSubjectContext

; 2550 : 		accessToken = SeQuerySubjectContextToken (&subContext);

  00095	48 8b 4c 24 70	 mov	 rcx, QWORD PTR subContext$32552[rsp+16]
  0009a	48 8b 44 24 60	 mov	 rax, QWORD PTR subContext$32552[rsp]
  0009f	48 85 c0	 test	 rax, rax
  000a2	48 0f 45 c8	 cmovne	 rcx, rax

; 2551 : 
; 2552 : 		if (!accessToken)

  000a6	48 85 c9	 test	 rcx, rcx
  000a9	75 07		 jne	 SHORT $LN15@MountDevic

; 2553 : 		{
; 2554 : 			ntStatus = STATUS_INVALID_PARAMETER;

  000ab	bb 0d 00 00 c0	 mov	 ebx, -1073741811	; ffffffffc000000dH

; 2555 : 		}
; 2556 : 		else

  000b0	eb 6b		 jmp	 SHORT $LN13@MountDevic
$LN15@MountDevic:

; 2557 : 		{
; 2558 : 			PTOKEN_USER tokenUser;
; 2559 : 
; 2560 : 			ntStatus = SeQueryInformationToken (accessToken, TokenUser, &tokenUser);

  000b2	4c 8d 44 24 38	 lea	 r8, QWORD PTR tokenUser$32564[rsp]
  000b7	ba 01 00 00 00	 mov	 edx, 1
  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeQueryInformationToken
  000c2	8b d8		 mov	 ebx, eax

; 2561 : 			if (NT_SUCCESS (ntStatus))

  000c4	85 c0		 test	 eax, eax
  000c6	78 55		 js	 SHORT $LN13@MountDevic

; 2562 : 			{
; 2563 : 				ULONG sidLength = RtlLengthSid (tokenUser->User.Sid);

  000c8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tokenUser$32564[rsp]
  000cd	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlLengthSid
  000d6	8b d8		 mov	 ebx, eax

; 2564 : 
; 2565 : 				NewExtension->UserSid = TCalloc (sidLength);

  000d8	8b d0		 mov	 edx, eax
  000da	33 c9		 xor	 ecx, ecx
  000dc	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  000e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  000e8	48 89 86 88 05
	00 00		 mov	 QWORD PTR [rsi+1416], rax

; 2566 : 				if (!NewExtension->UserSid)

  000ef	48 85 c0	 test	 rax, rax
  000f2	75 07		 jne	 SHORT $LN12@MountDevic

; 2567 : 					ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  000f4	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; ffffffffc000009aH

; 2568 : 				else

  000f9	eb 15		 jmp	 SHORT $LN11@MountDevic
$LN12@MountDevic:

; 2569 : 					ntStatus = RtlCopySid (sidLength, NewExtension->UserSid, tokenUser->User.Sid);

  000fb	4c 8b 44 24 38	 mov	 r8, QWORD PTR tokenUser$32564[rsp]
  00100	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  00103	48 8b d0	 mov	 rdx, rax
  00106	8b cb		 mov	 ecx, ebx
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCopySid
  0010e	8b d8		 mov	 ebx, eax
$LN11@MountDevic:

; 2570 : 
; 2571 : 				ExFreePool (tokenUser);		// Documented in newer versions of WDK

  00110	33 d2		 xor	 edx, edx
  00112	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tokenUser$32564[rsp]
  00117	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN13@MountDevic:

; 2572 : 			}
; 2573 : 		}
; 2574 : 
; 2575 : 		SeReleaseSubjectContext (&subContext);

  0011d	48 8d 4c 24 60	 lea	 rcx, QWORD PTR subContext$32552[rsp]
  00122	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeReleaseSubjectContext

; 2576 : 
; 2577 : 		if (NT_SUCCESS (ntStatus))

  00128	85 db		 test	 ebx, ebx
  0012a	78 12		 js	 SHORT $LN10@MountDevic

; 2578 : 			ntStatus = TCStartVolumeThread (NewDeviceObject, NewExtension, mount);

  0012c	4c 8b c7	 mov	 r8, rdi
  0012f	48 8b d6	 mov	 rdx, rsi
  00132	48 8b 4c 24 30	 mov	 rcx, QWORD PTR NewDeviceObject$[rsp]
  00137	e8 00 00 00 00	 call	 TCStartVolumeThread
  0013c	8b d8		 mov	 ebx, eax
$LN10@MountDevic:

; 2579 : 
; 2580 : 		if (!NT_SUCCESS (ntStatus))

  0013e	85 db		 test	 ebx, ebx
  00140	79 14		 jns	 SHORT $LN9@MountDevic

; 2581 : 		{
; 2582 : 			Dump ("Mount FAILURE NT ERROR, ntStatus = 0x%08x\n", ntStatus);
; 2583 : 			TCDeleteDeviceObject (NewDeviceObject, NewExtension);

  00142	48 8b d6	 mov	 rdx, rsi
  00145	48 8b 4c 24 30	 mov	 rcx, QWORD PTR NewDeviceObject$[rsp]
  0014a	e8 00 00 00 00	 call	 TCDeleteDeviceObject

; 2584 : 			return ntStatus;

  0014f	8b c3		 mov	 eax, ebx
  00151	e9 47 01 00 00	 jmp	 $LN8@MountDevic
$LN9@MountDevic:

; 2585 : 		}
; 2586 : 		else
; 2587 : 		{
; 2588 : 			if (mount->nReturnCode == 0)

  00156	83 3f 00	 cmp	 DWORD PTR [rdi], 0
  00159	0f 85 26 01 00
	00		 jne	 $LN7@MountDevic

; 2589 : 			{
; 2590 : 				HANDLE volumeHandle;
; 2591 : 				PFILE_OBJECT volumeFileObject;
; 2592 : 
; 2593 : 				Dump ("Mount SUCCESS TC code = 0x%08x READ-ONLY = %d\n", mount->nReturnCode, NewExtension->bReadOnly);
; 2594 : 
; 2595 : 				if (NewExtension->bReadOnly)

  0015f	83 be 40 03 00
	00 00		 cmp	 DWORD PTR [rsi+832], 0
  00166	74 09		 je	 SHORT $LN6@MountDevic

; 2596 : 					NewDeviceObject->Characteristics |= FILE_READ_ONLY_DEVICE;

  00168	48 8b 44 24 30	 mov	 rax, QWORD PTR NewDeviceObject$[rsp]
  0016d	83 48 34 02	 or	 DWORD PTR [rax+52], 2
$LN6@MountDevic:

; 2597 : 
; 2598 : 				NewDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

  00171	48 8b 44 24 30	 mov	 rax, QWORD PTR NewDeviceObject$[rsp]
  00176	0f ba 70 30 07	 btr	 DWORD PTR [rax+48], 7

; 2599 : 
; 2600 : 				NewExtension->UniqueVolumeId = LastUniqueVolumeId++;

  0017b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR LastUniqueVolumeId
  00181	89 46 10	 mov	 DWORD PTR [rsi+16], eax
  00184	ff c0		 inc	 eax
  00186	89 05 00 00 00
	00		 mov	 DWORD PTR LastUniqueVolumeId, eax

; 2601 : 
; 2602 : 				if (mount->bMountManager)

  0018c	83 bf 78 02 00
	00 00		 cmp	 DWORD PTR [rdi+632], 0
  00193	74 08		 je	 SHORT $LN5@MountDevic

; 2603 : 					MountManagerMount (mount);

  00195	48 8b cf	 mov	 rcx, rdi
  00198	e8 00 00 00 00	 call	 MountManagerMount
$LN5@MountDevic:

; 2604 : 
; 2605 : 				NewExtension->bMountManager = mount->bMountManager;

  0019d	8b 87 78 02 00
	00		 mov	 eax, DWORD PTR [rdi+632]
  001a3	89 86 50 03 00
	00		 mov	 DWORD PTR [rsi+848], eax

; 2606 : 
; 2607 : 				// We create symbolic link even if mount manager is notified of
; 2608 : 				// arriving volume as it apparently sometimes fails to create the link
; 2609 : 				CreateDriveLink (mount->nDosDriveNo);

  001a9	8b 9f 64 02 00
	00		 mov	 ebx, DWORD PTR [rdi+612]
  001af	8b d3		 mov	 edx, ebx
  001b1	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR dev$54853[rsp]
  001b9	e8 00 00 00 00	 call	 TCGetNTNameFromNumber
  001be	8b d3		 mov	 edx, ebx
  001c0	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR link$54854[rsp]
  001c8	e8 00 00 00 00	 call	 TCGetDosNameFromNumber
  001cd	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR dev$54853[rsp]
  001d5	48 8d 4c 24 38	 lea	 rcx, QWORD PTR deviceName$54855[rsp]
  001da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString
  001e0	48 8d 94 24 90
	01 00 00	 lea	 rdx, QWORD PTR link$54854[rsp]
  001e8	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR symLink$54856[rsp]
  001f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString
  001f6	48 8d 54 24 38	 lea	 rdx, QWORD PTR deviceName$54855[rsp]
  001fb	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR symLink$54856[rsp]
  00203	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateSymbolicLink

; 2610 : 
; 2611 : 				mount->FilesystemDirty = FALSE;

  00209	83 67 04 00	 and	 DWORD PTR [rdi+4], 0

; 2612 : 
; 2613 : 				if (NT_SUCCESS (TCOpenFsVolume (NewExtension, &volumeHandle, &volumeFileObject)))

  0020d	4c 8d 44 24 48	 lea	 r8, QWORD PTR volumeFileObject$32579[rsp]
  00212	48 8d 54 24 50	 lea	 rdx, QWORD PTR volumeHandle$32578[rsp]
  00217	48 8b ce	 mov	 rcx, rsi
  0021a	e8 00 00 00 00	 call	 TCOpenFsVolume
  0021f	85 c0		 test	 eax, eax
  00221	78 6f		 js	 SHORT $LN1@MountDevic

; 2614 : 				{
; 2615 : 					__try
; 2616 : 					{
; 2617 : 						ULONG fsStatus;
; 2618 : 
; 2619 : 						if (NT_SUCCESS (TCFsctlCall (volumeFileObject, FSCTL_IS_VOLUME_DIRTY, NULL, 0, &fsStatus, sizeof (fsStatus)))
; 2620 : 							&& (fsStatus & VOLUME_IS_DIRTY))

  00223	c7 44 24 28 04
	00 00 00	 mov	 DWORD PTR [rsp+40], 4
  0022b	48 8d 44 24 38	 lea	 rax, QWORD PTR fsStatus$32585[rsp]
  00230	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00235	45 33 c9	 xor	 r9d, r9d
  00238	45 33 c0	 xor	 r8d, r8d
  0023b	ba 78 00 09 00	 mov	 edx, 589944		; 00090078H
  00240	48 8b 4c 24 48	 mov	 rcx, QWORD PTR volumeFileObject$32579[rsp]
  00245	e8 00 00 00 00	 call	 TCFsctlCall
  0024a	85 c0		 test	 eax, eax
  0024c	78 0e		 js	 SHORT $LN2@MountDevic
  0024e	f6 44 24 38 01	 test	 BYTE PTR fsStatus$32585[rsp], 1
  00253	74 07		 je	 SHORT $LN2@MountDevic

; 2621 : 						{
; 2622 : 							mount->FilesystemDirty = TRUE;

  00255	c7 47 04 01 00
	00 00		 mov	 DWORD PTR [rdi+4], 1
$LN2@MountDevic:

; 2623 : 						}
; 2624 : 					}

  0025c	eb 0c		 jmp	 SHORT $LN27@MountDevic
$LN25@MountDevic:

; 2625 : 					__except (EXCEPTION_EXECUTE_HANDLER)
; 2626 : 					{
; 2627 : 						mount->FilesystemDirty = TRUE;

  0025e	48 8b 44 24 58	 mov	 rax, QWORD PTR mount$GSCopy$[rsp]
  00263	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [rax+4], 1
$LN27@MountDevic:

; 2628 : 					}
; 2629 : 
; 2630 : 
; 2631 : 					TCCloseFsVolume (volumeHandle, volumeFileObject);

  0026a	48 8b 5c 24 50	 mov	 rbx, QWORD PTR volumeHandle$32578[rsp]
  0026f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR volumeFileObject$32579[rsp]
  00274	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject
  0027a	48 8b cb	 mov	 rcx, rbx
  0027d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 2632 : 				}
; 2633 : 			}
; 2634 : 			else

  00283	eb 0d		 jmp	 SHORT $LN1@MountDevic
$LN7@MountDevic:

; 2635 : 			{
; 2636 : 				Dump ("Mount FAILURE TC code = 0x%08x\n", mount->nReturnCode);
; 2637 : 				TCDeleteDeviceObject (NewDeviceObject, NewExtension);

  00285	48 8b d6	 mov	 rdx, rsi
  00288	48 8b 4c 24 30	 mov	 rcx, QWORD PTR NewDeviceObject$[rsp]
  0028d	e8 00 00 00 00	 call	 TCDeleteDeviceObject
$LN1@MountDevic:

; 2638 : 			}
; 2639 : 			
; 2640 : 			return STATUS_SUCCESS;

  00292	33 c0		 xor	 eax, eax
  00294	eb 07		 jmp	 SHORT $LN8@MountDevic
$LN20@MountDevic:

; 2520 : 	{
; 2521 : 		Dump ("Mount request looks valid\n");
; 2522 : 	}
; 2523 : 	else
; 2524 : 	{
; 2525 : 		Dump ("WARNING: MOUNT DRIVE LETTER INVALID\n");
; 2526 : 		mount->nReturnCode = ERR_DRIVE_NOT_FOUND;

  00296	b8 05 00 00 00	 mov	 eax, 5
  0029b	89 07		 mov	 DWORD PTR [rdi], eax
$LN8@MountDevic:

; 2641 : 		}
; 2642 : 	}
; 2643 : }

  0029d	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002a5	48 33 cc	 xor	 rcx, rsp
  002a8	e8 00 00 00 00	 call	 __security_check_cookie
  002ad	4c 8d 9c 24 a0
	02 00 00	 lea	 r11, QWORD PTR [rsp+672]
  002b5	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  002b9	49 8b 73 28	 mov	 rsi, QWORD PTR [r11+40]
  002bd	49 8b e3	 mov	 rsp, r11
  002c0	5f		 pop	 rdi
  002c1	c3		 ret	 0
MountDevice ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	ProcessMainDeviceControlIrp
;	COMDAT pdata
pdata	SEGMENT
$pdata$ProcessMainDeviceControlIrp DD imagerel $LN290
	DD	imagerel $LN290+4754
	DD	imagerel $unwind$ProcessMainDeviceControlIrp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ProcessMainDeviceControlIrp DD 0b2919H
	DD	0873417H
	DD	07e0117H
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	03e0H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ProcessMainDeviceControlIrp
_TEXT	SEGMENT
deviceObjectCount$31737 = 96
NtFileHandle$31763 = 104
NtFileHandle$31815 = 112
IoStatus$31765 = 120
offset$31818 = 136
offset$31766 = 144
lengthInfo$31928 = 152
fileObject$31953 = 160
deviceObject$31954 = 168
ObjectAttributes$31814 = 176
ObjectAttributes$31762 = 224
FullFileName$31764 = 272
FullFileName$31816 = 288
IoStatus$31817 = 304
name$31952 = 320
pi$31918 = 336
readBuffer$31819 = 480
__$ArrayPad$ = 992
DeviceObject$ = 1072
Extension$ = 1080
Irp$ = 1088
ProcessMainDeviceControlIrp PROC			; COMDAT

; 808  : {

$LN290:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 81 ec f0 03
	00 00		 sub	 rsp, 1008		; 000003f0H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 e0
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 809  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);

  00029	4d 8b a0 b8 00
	00 00		 mov	 r12, QWORD PTR [r8+184]
  00030	4c 8b f1	 mov	 r14, rcx

; 810  : 	NTSTATUS ntStatus;
; 811  : 
; 812  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  00033	b9 48 20 22 00	 mov	 ecx, 2236488		; 00222048H
  00038	41 8b 44 24 18	 mov	 eax, DWORD PTR [r12+24]
  0003d	49 8b f0	 mov	 rsi, r8
  00040	3b c1		 cmp	 eax, ecx
  00042	0f 87 75 0c 00
	00		 ja	 $LN150@ProcessMai
  00048	0f 84 5f 0c 00
	00		 je	 $LN24@ProcessMai
  0004e	b9 20 20 22 00	 mov	 ecx, 2236448		; 00222020H
  00053	3b c1		 cmp	 eax, ecx
  00055	0f 87 55 05 00
	00		 ja	 $LN151@ProcessMai
  0005b	0f 84 25 05 00
	00		 je	 $LN141@ProcessMai
  00061	2d 04 20 07 00	 sub	 eax, 466948		; 00072004H
  00066	0f 84 d7 04 00
	00		 je	 $LN74@ProcessMai
  0006c	83 e8 14	 sub	 eax, 20
  0006f	0f 84 99 04 00
	00		 je	 $LN143@ProcessMai
  00075	2d ec ff 1a 00	 sub	 eax, 1769452		; 001affecH
  0007a	0f 84 8e 04 00
	00		 je	 $LN143@ProcessMai
  00080	bf 04 00 00 00	 mov	 edi, 4
  00085	2b c7		 sub	 eax, edi
  00087	0f 84 46 04 00
	00		 je	 $LN21@ProcessMai
  0008d	2b c7		 sub	 eax, edi
  0008f	0f 84 a2 03 00
	00		 je	 $LN46@ProcessMai
  00095	2b c7		 sub	 eax, edi
  00097	0f 84 27 03 00
	00		 je	 $LN32@ProcessMai
  0009d	2b c7		 sub	 eax, edi
  0009f	0f 84 ef 02 00
	00		 je	 $LN28@ProcessMai
  000a5	2b c7		 sub	 eax, edi
  000a7	0f 84 b3 01 00
	00		 je	 $LN87@ProcessMai
  000ad	3b c7		 cmp	 eax, edi
  000af	0f 85 2f 10 00
	00		 jne	 $LN1@ProcessMai

; 1160 : 
; 1161 : 	case TC_IOCTL_GET_VOLUME_PROPERTIES:
; 1162 : 		if (ValidateIOBufferSize (Irp, sizeof (VOLUME_PROPERTIES_STRUCT), ValidateInputOutput))

  000b5	41 bd 54 02 00
	00		 mov	 r13d, 596		; 00000254H
  000bb	44 8d 47 fe	 lea	 r8d, QWORD PTR [rdi-2]
  000bf	48 8b ce	 mov	 rcx, rsi
  000c2	49 8b d5	 mov	 rdx, r13
  000c5	e8 00 00 00 00	 call	 ValidateIOBufferSize
  000ca	33 db		 xor	 ebx, ebx
  000cc	3b c3		 cmp	 eax, ebx
  000ce	0f 84 83 11 00
	00		 je	 $LN144@ProcessMai

; 1163 : 		{
; 1164 : 			VOLUME_PROPERTIES_STRUCT *prop = (VOLUME_PROPERTIES_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  000d4	48 8b 7e 18	 mov	 rdi, QWORD PTR [rsi+24]

; 1165 : 			PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject (prop->driveNo);

  000d8	83 3f 19	 cmp	 DWORD PTR [rdi], 25
  000db	77 14		 ja	 SHORT $LN182@ProcessMai
  000dd	48 63 07	 movsxd	 rax, DWORD PTR [rdi]
  000e0	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:__ImageBase
  000e7	4d 8b a4 c6 00
	00 00 00	 mov	 r12, QWORD PTR VirtualVolumeDeviceObjects[r14+rax*8]
  000ef	eb 03		 jmp	 SHORT $LN184@ProcessMai
$LN182@ProcessMai:
  000f1	4c 8b e3	 mov	 r12, rbx
$LN184@ProcessMai:

; 1166 : 
; 1167 : 			Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  000f4	b8 0d 00 00 c0	 mov	 eax, -1073741811	; ffffffffc000000dH

; 1168 : 			Irp->IoStatus.Information = 0;

  000f9	48 89 5e 38	 mov	 QWORD PTR [rsi+56], rbx
  000fd	89 46 30	 mov	 DWORD PTR [rsi+48], eax

; 1169 : 
; 1170 : 			if (ListDevice)

  00100	4c 3b e3	 cmp	 r12, rbx
  00103	0f 84 4e 11 00
	00		 je	 $LN144@ProcessMai

; 1171 : 			{
; 1172 : 				PEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;

  00109	4d 8b 64 24 40	 mov	 r12, QWORD PTR [r12+64]

; 1173 : 				if (IsVolumeAccessibleByCurrentUser (ListExtension))

  0010e	49 8b cc	 mov	 rcx, r12
  00111	e8 00 00 00 00	 call	 IsVolumeAccessibleByCurrentUser
  00116	3b c3		 cmp	 eax, ebx
  00118	0f 84 39 11 00
	00		 je	 $LN144@ProcessMai

; 1174 : 				{
; 1175 : 					prop->uniqueId = ListExtension->UniqueVolumeId;

  0011e	41 8b 44 24 10	 mov	 eax, DWORD PTR [r12+16]

; 1176 : 					wcscpy (prop->wszVolume, ListExtension->wszVolume);

  00123	49 8d 8c 24 58
	03 00 00	 lea	 rcx, QWORD PTR [r12+856]
  0012b	48 8b d7	 mov	 rdx, rdi
  0012e	89 47 04	 mov	 DWORD PTR [rdi+4], eax
  00131	48 2b d1	 sub	 rdx, rcx
$LL149@ProcessMai:
  00134	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00137	48 83 c1 02	 add	 rcx, 2
  0013b	66 89 44 0a 06	 mov	 WORD PTR [rdx+rcx+6], ax
  00140	66 3b c3	 cmp	 ax, bx
  00143	75 ef		 jne	 SHORT $LL149@ProcessMai

; 1177 : 					prop->diskLength = ListExtension->DiskLength;

  00145	49 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR [r12+160]
  0014d	48 89 87 10 02
	00 00		 mov	 QWORD PTR [rdi+528], rax

; 1178 : 					prop->ea = ListExtension->cryptoInfo->ea;

  00154	49 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR [r12+144]
  0015c	8b 08		 mov	 ecx, DWORD PTR [rax]
  0015e	89 8f 18 02 00
	00		 mov	 DWORD PTR [rdi+536], ecx

; 1179 : 					prop->mode = ListExtension->cryptoInfo->mode;

  00164	49 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR [r12+144]
  0016c	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  0016f	89 8f 1c 02 00
	00		 mov	 DWORD PTR [rdi+540], ecx

; 1180 : 					prop->pkcs5 = ListExtension->cryptoInfo->pkcs5;

  00175	49 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR [r12+144]
  0017d	8b 88 ec 43 00
	00		 mov	 ecx, DWORD PTR [rax+17388]
  00183	89 8f 20 02 00
	00		 mov	 DWORD PTR [rdi+544], ecx

; 1181 : 					prop->pkcs5Iterations = ListExtension->cryptoInfo->noIterations;

  00189	49 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR [r12+144]
  00191	8b 88 e8 43 00
	00		 mov	 ecx, DWORD PTR [rax+17384]
  00197	89 8f 24 02 00
	00		 mov	 DWORD PTR [rdi+548], ecx

; 1182 : #if 0
; 1183 : 					prop->volumeCreationTime = ListExtension->cryptoInfo->volume_creation_time;
; 1184 : 					prop->headerCreationTime = ListExtension->cryptoInfo->header_creation_time;
; 1185 : #endif
; 1186 : 					prop->volumeHeaderFlags = ListExtension->cryptoInfo->HeaderFlags;

  0019d	49 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR [r12+144]
  001a5	8b 88 60 44 00
	00		 mov	 ecx, DWORD PTR [rax+17504]
  001ab	89 8f 38 02 00
	00		 mov	 DWORD PTR [rdi+568], ecx

; 1187 : 					prop->readOnly = ListExtension->bReadOnly;

  001b1	41 8b 84 24 40
	03 00 00	 mov	 eax, DWORD PTR [r12+832]
  001b9	89 87 2c 02 00
	00		 mov	 DWORD PTR [rdi+556], eax

; 1188 : 					prop->removable = ListExtension->bRemovable;

  001bf	41 8b 84 24 44
	03 00 00	 mov	 eax, DWORD PTR [r12+836]
  001c7	89 87 30 02 00
	00		 mov	 DWORD PTR [rdi+560], eax

; 1189 : 					prop->partitionInInactiveSysEncScope = ListExtension->PartitionInInactiveSysEncScope;

  001cd	41 8b 84 24 48
	03 00 00	 mov	 eax, DWORD PTR [r12+840]
  001d5	89 87 34 02 00
	00		 mov	 DWORD PTR [rdi+564], eax

; 1190 : 					prop->hiddenVolume = ListExtension->cryptoInfo->hiddenVolume;

  001db	49 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR [r12+144]
  001e3	8b 88 a0 29 00
	00		 mov	 ecx, DWORD PTR [rax+10656]
  001e9	89 8f 28 02 00
	00		 mov	 DWORD PTR [rdi+552], ecx

; 1191 : 
; 1192 : 					if (ListExtension->cryptoInfo->bProtectHiddenVolume)

  001ef	49 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR [r12+144]
  001f7	39 98 00 44 00
	00		 cmp	 DWORD PTR [rax+17408], ebx
  001fd	74 16		 je	 SHORT $LN68@ProcessMai

; 1193 : 						prop->hiddenVolProtection = ListExtension->cryptoInfo->bHiddenVolProtectionAction ? HIDVOL_PROT_STATUS_ACTION_TAKEN : HIDVOL_PROT_STATUS_ACTIVE;

  001ff	8b 88 04 44 00
	00		 mov	 ecx, DWORD PTR [rax+17412]
  00205	f7 d9		 neg	 ecx
  00207	1b c0		 sbb	 eax, eax
  00209	f7 d8		 neg	 eax
  0020b	ff c0		 inc	 eax
  0020d	89 87 4c 02 00
	00		 mov	 DWORD PTR [rdi+588], eax

; 1194 : 					else

  00213	eb 06		 jmp	 SHORT $LN67@ProcessMai
$LN68@ProcessMai:

; 1195 : 						prop->hiddenVolProtection = HIDVOL_PROT_STATUS_NONE;

  00215	89 9f 4c 02 00
	00		 mov	 DWORD PTR [rdi+588], ebx
$LN67@ProcessMai:

; 1196 : 
; 1197 : 					prop->totalBytesRead = ListExtension->Queue.TotalBytesRead;

  0021b	49 8b 84 24 00
	03 00 00	 mov	 rax, QWORD PTR [r12+768]
  00223	48 89 87 3c 02
	00 00		 mov	 QWORD PTR [rdi+572], rax

; 1198 : 					prop->totalBytesWritten = ListExtension->Queue.TotalBytesWritten;

  0022a	49 8b 84 24 08
	03 00 00	 mov	 rax, QWORD PTR [r12+776]
  00232	48 89 87 44 02
	00 00		 mov	 QWORD PTR [rdi+580], rax

; 1199 : 
; 1200 : 					prop->volFormatVersion = ListExtension->cryptoInfo->LegacyVolume ? TC_VOLUME_FORMAT_VERSION_PRE_6_0 : TC_VOLUME_FORMAT_VERSION;

  00239	49 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR [r12+144]
  00241	8b 88 3c 44 00
	00		 mov	 ecx, DWORD PTR [rax+17468]
  00247	f7 d9		 neg	 ecx
  00249	1b c0		 sbb	 eax, eax
  0024b	83 c0 02	 add	 eax, 2
  0024e	89 87 50 02 00
	00		 mov	 DWORD PTR [rdi+592], eax

; 1201 : 
; 1202 : 					Irp->IoStatus.Status = STATUS_SUCCESS;

  00254	89 5e 30	 mov	 DWORD PTR [rsi+48], ebx

; 1203 : 					Irp->IoStatus.Information = sizeof (VOLUME_PROPERTIES_STRUCT);

  00257	4c 89 6e 38	 mov	 QWORD PTR [rsi+56], r13

; 1204 : 				}
; 1205 : 			}
; 1206 : 		}
; 1207 : 		break;

  0025b	e9 f7 0f 00 00	 jmp	 $LN144@ProcessMai
$LN87@ProcessMai:

; 1104 : 
; 1105 : 	case TC_IOCTL_GET_MOUNTED_VOLUMES:
; 1106 : 
; 1107 : 		if (ValidateIOBufferSize (Irp, sizeof (MOUNT_LIST_STRUCT), ValidateOutput))

  00260	bd 01 00 00 00	 mov	 ebp, 1
  00265	41 bf 74 36 00
	00		 mov	 r15d, 13940		; 00003674H
  0026b	48 8b ce	 mov	 rcx, rsi
  0026e	44 8b c5	 mov	 r8d, ebp
  00271	49 8b d7	 mov	 rdx, r15
  00274	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00279	33 db		 xor	 ebx, ebx
  0027b	3b c3		 cmp	 eax, ebx
  0027d	0f 84 d4 0f 00
	00		 je	 $LN144@ProcessMai

; 1108 : 		{
; 1109 : 			MOUNT_LIST_STRUCT *list = (MOUNT_LIST_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  00283	4c 8b 66 18	 mov	 r12, QWORD PTR [rsi+24]

; 1110 : 			PDEVICE_OBJECT ListDevice;
; 1111 : 			int drive;
; 1112 : 
; 1113 : 			list->ulMountedDrives = 0;
; 1114 : 
; 1115 : 			for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)

  00287	4c 8b eb	 mov	 r13, rbx
  0028a	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:__ImageBase
  00291	41 89 1c 24	 mov	 DWORD PTR [r12], ebx

; 1116 : 			{
; 1117 : 				PEXTENSION ListExtension;
; 1118 : 				
; 1119 : 				ListDevice = GetVirtualVolumeDeviceObject (drive);

  00295	48 83 fb 19	 cmp	 rbx, 25
$LN274@ProcessMai:
  00299	77 0a		 ja	 SHORT $LN178@ProcessMai
  0029b	4b 8b bc ee 00
	00 00 00	 mov	 rdi, QWORD PTR VirtualVolumeDeviceObjects[r14+r13*8]
  002a3	eb 03		 jmp	 SHORT $LN180@ProcessMai
$LN178@ProcessMai:
  002a5	48 8b fb	 mov	 rdi, rbx
$LN180@ProcessMai:

; 1120 : 				if (!ListDevice)

  002a8	48 3b fb	 cmp	 rdi, rbx
  002ab	0f 84 ca 00 00
	00		 je	 $LN84@ProcessMai

; 1121 : 					continue;
; 1122 : 
; 1123 : 				ListExtension = (PEXTENSION) ListDevice->DeviceExtension;

  002b1	48 8b 7f 40	 mov	 rdi, QWORD PTR [rdi+64]

; 1124 : 				if (IsVolumeAccessibleByCurrentUser (ListExtension))

  002b5	48 8b cf	 mov	 rcx, rdi
  002b8	e8 00 00 00 00	 call	 IsVolumeAccessibleByCurrentUser
  002bd	3b c3		 cmp	 eax, ebx
  002bf	0f 84 b6 00 00
	00		 je	 $LN84@ProcessMai

; 1125 : 				{
; 1126 : 					list->ulMountedDrives |= (1 << ListExtension->nDosDriveNo);

  002c5	8b 4f 14	 mov	 ecx, DWORD PTR [rdi+20]
  002c8	8b c5		 mov	 eax, ebp
  002ca	d3 e0		 shl	 eax, cl

; 1127 : 					wcscpy (list->wszVolume[ListExtension->nDosDriveNo], ListExtension->wszVolume);

  002cc	48 8d 8f 58 03
	00 00		 lea	 rcx, QWORD PTR [rdi+856]
  002d3	41 09 04 24	 or	 DWORD PTR [r12], eax
  002d7	48 63 47 14	 movsxd	 rax, DWORD PTR [rdi+20]
  002db	48 69 c0 08 02
	00 00		 imul	 rax, 520		; 00000208H
  002e2	4a 8d 54 20 04	 lea	 rdx, QWORD PTR [rax+r12+4]
$LL148@ProcessMai:
  002e7	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  002ea	48 83 c1 02	 add	 rcx, 2
  002ee	66 89 02	 mov	 WORD PTR [rdx], ax
  002f1	48 83 c2 02	 add	 rdx, 2
  002f5	66 3b c3	 cmp	 ax, bx
  002f8	75 ed		 jne	 SHORT $LL148@ProcessMai

; 1128 : 					list->diskLength[ListExtension->nDosDriveNo] = ListExtension->DiskLength;

  002fa	48 63 4f 14	 movsxd	 rcx, DWORD PTR [rdi+20]
  002fe	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
  00305	49 89 84 cc d4
	34 00 00	 mov	 QWORD PTR [r12+rcx*8+13524], rax

; 1129 : 					list->ea[ListExtension->nDosDriveNo] = ListExtension->cryptoInfo->ea;

  0030d	48 8b 87 90 00
	00 00		 mov	 rax, QWORD PTR [rdi+144]
  00314	48 63 4f 14	 movsxd	 rcx, DWORD PTR [rdi+20]
  00318	8b 00		 mov	 eax, DWORD PTR [rax]
  0031a	41 89 84 8c a4
	35 00 00	 mov	 DWORD PTR [r12+rcx*4+13732], eax

; 1130 : 					if (ListExtension->cryptoInfo->hiddenVolume)

  00322	48 8b 87 90 00
	00 00		 mov	 rax, QWORD PTR [rdi+144]
  00329	39 98 a0 29 00
	00		 cmp	 DWORD PTR [rax+10656], ebx
  0032f	74 0e		 je	 SHORT $LN80@ProcessMai

; 1131 : 						list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_HIDDEN;	// Hidden volume

  00331	48 63 47 14	 movsxd	 rax, DWORD PTR [rdi+20]
  00335	41 89 ac 84 0c
	36 00 00	 mov	 DWORD PTR [r12+rax*4+13836], ebp
  0033d	eb 3c		 jmp	 SHORT $LN84@ProcessMai
$LN80@ProcessMai:

; 1132 : 					else if (ListExtension->cryptoInfo->bHiddenVolProtectionAction)

  0033f	39 98 04 44 00
	00		 cmp	 DWORD PTR [rax+17412], ebx
  00345	74 12		 je	 SHORT $LN78@ProcessMai

; 1133 : 						list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_OUTER_VOL_WRITE_PREVENTED;	// Normal/outer volume (hidden volume protected AND write already prevented)

  00347	48 63 47 14	 movsxd	 rax, DWORD PTR [rdi+20]
  0034b	41 c7 84 84 0c
	36 00 00 03 00
	00 00		 mov	 DWORD PTR [r12+rax*4+13836], 3
  00357	eb 22		 jmp	 SHORT $LN84@ProcessMai
$LN78@ProcessMai:

; 1134 : 					else if (ListExtension->cryptoInfo->bProtectHiddenVolume)

  00359	39 98 00 44 00
	00		 cmp	 DWORD PTR [rax+17408], ebx

; 1135 : 						list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_OUTER;	// Normal/outer volume (hidden volume protected)

  0035f	48 63 47 14	 movsxd	 rax, DWORD PTR [rdi+20]
  00363	74 0e		 je	 SHORT $LN76@ProcessMai
  00365	41 c7 84 84 0c
	36 00 00 02 00
	00 00		 mov	 DWORD PTR [r12+rax*4+13836], 2

; 1136 : 					else

  00371	eb 08		 jmp	 SHORT $LN84@ProcessMai
$LN76@ProcessMai:

; 1137 : 						list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_NORMAL;	// Normal volume

  00373	41 89 9c 84 0c
	36 00 00	 mov	 DWORD PTR [r12+rax*4+13836], ebx
$LN84@ProcessMai:

; 1110 : 			PDEVICE_OBJECT ListDevice;
; 1111 : 			int drive;
; 1112 : 
; 1113 : 			list->ulMountedDrives = 0;
; 1114 : 
; 1115 : 			for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)

  0037b	4c 03 ed	 add	 r13, rbp
  0037e	49 83 fd 19	 cmp	 r13, 25
  00382	0f 8e 11 ff ff
	ff		 jle	 $LN274@ProcessMai

; 1138 : 				}
; 1139 : 			}
; 1140 : 
; 1141 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00388	89 5e 30	 mov	 DWORD PTR [rsi+48], ebx

; 1142 : 			Irp->IoStatus.Information = sizeof (MOUNT_LIST_STRUCT);

  0038b	4c 89 7e 38	 mov	 QWORD PTR [rsi+56], r15

; 1143 : 		}
; 1144 : 		break;

  0038f	e9 c3 0e 00 00	 jmp	 $LN144@ProcessMai
$LN28@ProcessMai:

; 1393 : 
; 1394 : 	case TC_IOCTL_DISMOUNT_ALL_VOLUMES:
; 1395 : 		if (ValidateIOBufferSize (Irp, sizeof (UNMOUNT_STRUCT), ValidateInputOutput))

  00394	41 b8 02 00 00
	00		 mov	 r8d, 2
  0039a	48 8b ce	 mov	 rcx, rsi
  0039d	45 8d 68 0e	 lea	 r13d, QWORD PTR [r8+14]
  003a1	49 8b d5	 mov	 rdx, r13
  003a4	e8 00 00 00 00	 call	 ValidateIOBufferSize
  003a9	33 db		 xor	 ebx, ebx
  003ab	3b c3		 cmp	 eax, ebx
  003ad	0f 84 a4 0e 00
	00		 je	 $LN144@ProcessMai

; 1396 : 		{
; 1397 : 			UNMOUNT_STRUCT *unmount = (UNMOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  003b3	48 8b 7e 18	 mov	 rdi, QWORD PTR [rsi+24]

; 1398 : 
; 1399 : 			unmount->nReturnCode = UnmountAllDevices (unmount, unmount->ignoreOpenFiles);

  003b7	48 8b cf	 mov	 rcx, rdi
  003ba	8b 57 04	 mov	 edx, DWORD PTR [rdi+4]
  003bd	e8 00 00 00 00	 call	 UnmountAllDevices

; 1400 : 
; 1401 : 			Irp->IoStatus.Information = sizeof (UNMOUNT_STRUCT);
; 1402 : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 1403 : 		}
; 1404 : 		break;

  003c2	eb 67		 jmp	 SHORT $LN288@ProcessMai
$LN32@ProcessMai:

; 1370 : 		}
; 1371 : 		break;
; 1372 : 
; 1373 : 	case TC_IOCTL_DISMOUNT_VOLUME:
; 1374 : 		if (ValidateIOBufferSize (Irp, sizeof (UNMOUNT_STRUCT), ValidateInputOutput))

  003c4	41 b8 02 00 00
	00		 mov	 r8d, 2
  003ca	48 8b ce	 mov	 rcx, rsi
  003cd	45 8d 68 0e	 lea	 r13d, QWORD PTR [r8+14]
  003d1	49 8b d5	 mov	 rdx, r13
  003d4	e8 00 00 00 00	 call	 ValidateIOBufferSize
  003d9	33 db		 xor	 ebx, ebx
  003db	3b c3		 cmp	 eax, ebx
  003dd	0f 84 74 0e 00
	00		 je	 $LN144@ProcessMai

; 1375 : 		{
; 1376 : 			UNMOUNT_STRUCT *unmount = (UNMOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  003e3	48 8b 7e 18	 mov	 rdi, QWORD PTR [rsi+24]

; 1377 : 			PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject (unmount->nDosDriveNo);

  003e7	83 3f 19	 cmp	 DWORD PTR [rdi], 25
  003ea	77 14		 ja	 SHORT $LN200@ProcessMai
  003ec	48 63 07	 movsxd	 rax, DWORD PTR [rdi]
  003ef	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:__ImageBase
  003f6	49 8b ac c6 00
	00 00 00	 mov	 rbp, QWORD PTR VirtualVolumeDeviceObjects[r14+rax*8]
  003fe	eb 03		 jmp	 SHORT $LN202@ProcessMai
$LN200@ProcessMai:
  00400	48 8b eb	 mov	 rbp, rbx
$LN202@ProcessMai:

; 1378 : 
; 1379 : 			unmount->nReturnCode = ERR_DRIVE_NOT_FOUND;

  00403	c7 47 0c 05 00
	00 00		 mov	 DWORD PTR [rdi+12], 5

; 1380 : 
; 1381 : 			if (ListDevice)

  0040a	48 3b eb	 cmp	 rbp, rbx
  0040d	74 1f		 je	 SHORT $LN29@ProcessMai

; 1382 : 			{
; 1383 : 				PEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;
; 1384 : 
; 1385 : 				if (IsVolumeAccessibleByCurrentUser (ListExtension))

  0040f	48 8b 4d 40	 mov	 rcx, QWORD PTR [rbp+64]
  00413	e8 00 00 00 00	 call	 IsVolumeAccessibleByCurrentUser
  00418	3b c3		 cmp	 eax, ebx
  0041a	74 12		 je	 SHORT $LN29@ProcessMai

; 1386 : 					unmount->nReturnCode = UnmountDevice (unmount, ListDevice, unmount->ignoreOpenFiles);

  0041c	44 8b 47 04	 mov	 r8d, DWORD PTR [rdi+4]
  00420	48 8b d5	 mov	 rdx, rbp
  00423	48 8b cf	 mov	 rcx, rdi
  00426	e8 00 00 00 00	 call	 UnmountDevice
$LN288@ProcessMai:
  0042b	89 47 0c	 mov	 DWORD PTR [rdi+12], eax
$LN29@ProcessMai:

; 1387 : 			}
; 1388 : 
; 1389 : 			Irp->IoStatus.Information = sizeof (UNMOUNT_STRUCT);

  0042e	4c 89 6e 38	 mov	 QWORD PTR [rsi+56], r13

; 1390 : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 1391 : 		}
; 1392 : 		break;

  00432	e9 04 01 00 00	 jmp	 $LN283@ProcessMai
$LN46@ProcessMai:

; 1350 : 
; 1351 : 	case TC_IOCTL_MOUNT_VOLUME:
; 1352 : 		if (ValidateIOBufferSize (Irp, sizeof (MOUNT_STRUCT), ValidateInputOutput))

  00437	bf e0 02 00 00	 mov	 edi, 736		; 000002e0H
  0043c	41 b8 02 00 00
	00		 mov	 r8d, 2
  00442	48 8b ce	 mov	 rcx, rsi
  00445	48 8b d7	 mov	 rdx, rdi
  00448	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0044d	33 db		 xor	 ebx, ebx
  0044f	3b c3		 cmp	 eax, ebx
  00451	0f 84 00 0e 00
	00		 je	 $LN144@ProcessMai

; 1353 : 		{
; 1354 : 			MOUNT_STRUCT *mount = (MOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  00457	48 8b 56 18	 mov	 rdx, QWORD PTR [rsi+24]

; 1355 : 
; 1356 : 			if (mount->VolumePassword.Length > MAX_PASSWORD || mount->ProtectedHidVolPassword.Length > MAX_PASSWORD)

  0045b	4c 8d aa 18 02
	00 00		 lea	 r13, QWORD PTR [rdx+536]
  00462	41 83 7d 00 40	 cmp	 DWORD PTR [r13], 64	; 00000040H
  00467	77 60		 ja	 SHORT $LN43@ProcessMai
  00469	4c 8d a2 90 02
	00 00		 lea	 r12, QWORD PTR [rdx+656]
  00470	41 83 3c 24 40	 cmp	 DWORD PTR [r12], 64	; 00000040H
  00475	77 52		 ja	 SHORT $LN43@ProcessMai

; 1361 : 			}
; 1362 : 
; 1363 : 			EnsureNullTerminatedString (mount->wszVolume, sizeof (mount->wszVolume));

  00477	66 89 9a 16 02
	00 00		 mov	 WORD PTR [rdx+534], bx

; 1364 : 
; 1365 : 			Irp->IoStatus.Information = sizeof (MOUNT_STRUCT);
; 1366 : 			Irp->IoStatus.Status = MountDevice (DeviceObject, mount);

  0047e	49 8b ce	 mov	 rcx, r14
  00481	48 89 7e 38	 mov	 QWORD PTR [rsi+56], rdi
  00485	e8 00 00 00 00	 call	 MountDevice

; 1367 : 
; 1368 : 			burn (&mount->VolumePassword, sizeof (mount->VolumePassword));

  0048a	8d 53 48	 lea	 edx, QWORD PTR [rbx+72]
  0048d	49 8b fd	 mov	 rdi, r13
  00490	89 46 30	 mov	 DWORD PTR [rsi+48], eax
  00493	33 c0		 xor	 eax, eax
  00495	48 8b ca	 mov	 rcx, rdx
  00498	44 8b c2	 mov	 r8d, edx
  0049b	8d 6b 01	 lea	 ebp, QWORD PTR [rbx+1]
  0049e	f3 aa		 rep stosb
$LL39@ProcessMai:
  004a0	44 2b c5	 sub	 r8d, ebp
  004a3	41 88 5d 00	 mov	 BYTE PTR [r13], bl
  004a7	4c 03 ed	 add	 r13, rbp
  004aa	44 3b c3	 cmp	 r8d, ebx
  004ad	75 f1		 jne	 SHORT $LL39@ProcessMai

; 1369 : 			burn (&mount->ProtectedHidVolPassword, sizeof (mount->ProtectedHidVolPassword));

  004af	49 8b fc	 mov	 rdi, r12
  004b2	48 8b ca	 mov	 rcx, rdx
  004b5	f3 aa		 rep stosb
$LL34@ProcessMai:
  004b7	2b d5		 sub	 edx, ebp
  004b9	41 88 1c 24	 mov	 BYTE PTR [r12], bl
  004bd	4c 03 e5	 add	 r12, rbp
  004c0	3b d3		 cmp	 edx, ebx
  004c2	75 f3		 jne	 SHORT $LL34@ProcessMai

; 930  : 							{
; 931  : 								// Search for the string "TrueCrypt"
; 932  : 								for (i = 0; i < TC_SECTOR_SIZE_BIOS - strlen (TC_APP_NAME_LEGACY); ++i)

  004c4	e9 8e 0d 00 00	 jmp	 $LN144@ProcessMai
$LN43@ProcessMai:

; 1357 : 			{
; 1358 : 				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  004c9	b8 0d 00 00 c0	 mov	 eax, -1073741811	; ffffffffc000000dH

; 1359 : 				Irp->IoStatus.Information = 0;
; 1360 : 				break;

  004ce	e9 7d 0d 00 00	 jmp	 $LN275@ProcessMai
$LN21@ProcessMai:

; 1428 : 
; 1429 : 	case TC_IOCTL_GET_BOOT_LOADER_VERSION:
; 1430 : 		GetBootLoaderVersion (Irp, irpSp);

  004d3	ba 02 00 00 00	 mov	 edx, 2
  004d8	48 8b ce	 mov	 rcx, rsi
  004db	44 8d 42 ff	 lea	 r8d, QWORD PTR [rdx-1]
  004df	e8 00 00 00 00	 call	 ValidateIOBufferSize
  004e4	33 db		 xor	 ebx, ebx
  004e6	3b c3		 cmp	 eax, ebx
  004e8	0f 84 69 0d 00
	00		 je	 $LN144@ProcessMai
  004ee	39 1d 00 00 00
	00		 cmp	 DWORD PTR BootArgsValid, ebx
  004f4	74 d3		 je	 SHORT $LN43@ProcessMai
  004f6	0f b7 05 08 00
	00 00		 movzx	 eax, WORD PTR BootArgs+8
  004fd	48 8b 4e 18	 mov	 rcx, QWORD PTR [rsi+24]
  00501	66 89 01	 mov	 WORD PTR [rcx], ax
  00504	48 c7 46 38 02
	00 00 00	 mov	 QWORD PTR [rsi+56], 2
  0050c	eb 2d		 jmp	 SHORT $LN283@ProcessMai
$LN143@ProcessMai:

; 813  : 	{
; 814  : 	case TC_IOCTL_GET_DRIVER_VERSION:
; 815  : 	case TC_IOCTL_LEGACY_GET_DRIVER_VERSION:
; 816  : 		if (ValidateIOBufferSize (Irp, sizeof (LONG), ValidateOutput))

  0050e	bf 04 00 00 00	 mov	 edi, 4
  00513	48 8b ce	 mov	 rcx, rsi
  00516	44 8d 47 fd	 lea	 r8d, QWORD PTR [rdi-3]
  0051a	48 8b d7	 mov	 rdx, rdi
  0051d	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00522	33 db		 xor	 ebx, ebx
  00524	3b c3		 cmp	 eax, ebx
  00526	0f 84 2b 0d 00
	00		 je	 $LN144@ProcessMai

; 817  : 		{
; 818  : 			LONG tmp = VERSION_NUM;
; 819  : 			memcpy (Irp->AssociatedIrp.SystemBuffer, &tmp, 4);

  0052c	48 8b 46 18	 mov	 rax, QWORD PTR [rsi+24]
  00530	ba 30 07 00 00	 mov	 edx, 1840		; 00000730H
  00535	89 10		 mov	 DWORD PTR [rax], edx
$LN282@ProcessMai:

; 820  : 			Irp->IoStatus.Information = sizeof (LONG);

  00537	48 89 7e 38	 mov	 QWORD PTR [rsi+56], rdi
$LN283@ProcessMai:

; 821  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  0053b	89 5e 30	 mov	 DWORD PTR [rsi+48], ebx

; 822  : 		}
; 823  : 		break;

  0053e	e9 14 0d 00 00	 jmp	 $LN144@ProcessMai
$LN74@ProcessMai:

; 1145 : 
; 1146 : 	case TC_IOCTL_LEGACY_GET_MOUNTED_VOLUMES:
; 1147 : 		if (ValidateIOBufferSize (Irp, sizeof (uint32), ValidateOutput))

  00543	ba 04 00 00 00	 mov	 edx, 4
  00548	48 8b ce	 mov	 rcx, rsi
  0054b	44 8d 42 fd	 lea	 r8d, QWORD PTR [rdx-3]
  0054f	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00554	33 db		 xor	 ebx, ebx
  00556	3b c3		 cmp	 eax, ebx
  00558	0f 84 f9 0c 00
	00		 je	 $LN144@ProcessMai

; 1148 : 		{
; 1149 : 			// Prevent the user from downgrading to versions lower than 5.0 by faking mounted volumes.
; 1150 : 			// The user could render the system unbootable by downgrading when boot encryption
; 1151 : 			// is active or being set up.
; 1152 : 
; 1153 : 			memset (Irp->AssociatedIrp.SystemBuffer, 0, irpSp->Parameters.DeviceIoControl.OutputBufferLength);

  0055e	45 8b 44 24 08	 mov	 r8d, DWORD PTR [r12+8]
  00563	48 8b 4e 18	 mov	 rcx, QWORD PTR [rsi+24]
  00567	33 d2		 xor	 edx, edx
  00569	e8 00 00 00 00	 call	 memset

; 1154 : 			*(uint32 *) Irp->AssociatedIrp.SystemBuffer = 0xffffFFFF;

  0056e	48 8b 56 18	 mov	 rdx, QWORD PTR [rsi+24]
  00572	83 0a ff	 or	 DWORD PTR [rdx], -1	; ffffffffH

; 1155 : 
; 1156 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00575	89 5e 30	 mov	 DWORD PTR [rsi+48], ebx

; 1157 : 			Irp->IoStatus.Information = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

  00578	41 8b 44 24 08	 mov	 eax, DWORD PTR [r12+8]
  0057d	48 89 46 38	 mov	 QWORD PTR [rsi+56], rax

; 1158 : 		}
; 1159 : 		break;

  00581	e9 d1 0c 00 00	 jmp	 $LN144@ProcessMai
$LN141@ProcessMai:

; 824  : 
; 825  : 	case TC_IOCTL_GET_DEVICE_REFCOUNT:
; 826  : 		if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))

  00586	bf 04 00 00 00	 mov	 edi, 4
  0058b	48 8b ce	 mov	 rcx, rsi
  0058e	44 8d 47 fd	 lea	 r8d, QWORD PTR [rdi-3]
  00592	48 8b d7	 mov	 rdx, rdi
  00595	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0059a	33 db		 xor	 ebx, ebx
  0059c	3b c3		 cmp	 eax, ebx
  0059e	0f 84 b3 0c 00
	00		 je	 $LN144@ProcessMai

; 827  : 		{
; 828  : 			*(int *) Irp->AssociatedIrp.SystemBuffer = DeviceObject->ReferenceCount;

  005a4	48 8b 4e 18	 mov	 rcx, QWORD PTR [rsi+24]
  005a8	41 8b 46 04	 mov	 eax, DWORD PTR [r14+4]
  005ac	89 01		 mov	 DWORD PTR [rcx], eax

; 829  : 			Irp->IoStatus.Information = sizeof (int);
; 830  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 831  : 		}
; 832  : 		break;

  005ae	eb 87		 jmp	 SHORT $LN282@ProcessMai
$LN151@ProcessMai:

; 810  : 	NTSTATUS ntStatus;
; 811  : 
; 812  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  005b0	2d 24 20 22 00	 sub	 eax, 2236452		; 00222024H
  005b5	bf 04 00 00 00	 mov	 edi, 4
  005ba	0f 84 89 06 00
	00		 je	 $LN139@ProcessMai
  005c0	2b c7		 sub	 eax, edi
  005c2	0f 84 0d 06 00
	00		 je	 $LN136@ProcessMai
  005c8	2b c7		 sub	 eax, edi
  005ca	0f 84 e6 05 00
	00		 je	 $LN92@ProcessMai
  005d0	2b c7		 sub	 eax, edi
  005d2	0f 84 9d 05 00
	00		 je	 $LN173@ProcessMai
  005d8	2b c7		 sub	 eax, edi
  005da	0f 84 24 03 00
	00		 je	 $LN129@ProcessMai
  005e0	2b c7		 sub	 eax, edi
  005e2	0f 84 77 01 00
	00		 je	 $LN64@ProcessMai
  005e8	2b c7		 sub	 eax, edi
  005ea	0f 84 1b 01 00
	00		 je	 $LN55@ProcessMai
  005f0	2b c7		 sub	 eax, edi
  005f2	74 4e		 je	 SHORT $LN53@ProcessMai
  005f4	3b c7		 cmp	 eax, edi
  005f6	0f 85 e8 0a 00
	00		 jne	 $LN1@ProcessMai

; 1208 : 
; 1209 : 	case TC_IOCTL_GET_RESOLVED_SYMLINK:
; 1210 : 		if (ValidateIOBufferSize (Irp, sizeof (RESOLVE_SYMLINK_STRUCT), ValidateInputOutput))

  005fc	bf 10 04 00 00	 mov	 edi, 1040		; 00000410H
  00601	41 b8 02 00 00
	00		 mov	 r8d, 2
  00607	48 8b ce	 mov	 rcx, rsi
  0060a	48 8b d7	 mov	 rdx, rdi
  0060d	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00612	33 db		 xor	 ebx, ebx
  00614	3b c3		 cmp	 eax, ebx
  00616	0f 84 3b 0c 00
	00		 je	 $LN144@ProcessMai

; 1211 : 		{
; 1212 : 			RESOLVE_SYMLINK_STRUCT *resolve = (RESOLVE_SYMLINK_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  0061c	48 8b 4e 18	 mov	 rcx, QWORD PTR [rsi+24]

; 1213 : 			{
; 1214 : 				NTSTATUS ntStatus;
; 1215 : 
; 1216 : 				EnsureNullTerminatedString (resolve->symLinkName, sizeof (resolve->symLinkName));
; 1217 : 
; 1218 : 				ntStatus = SymbolicLinkToTarget (resolve->symLinkName,
; 1219 : 					resolve->targetName,
; 1220 : 					sizeof (resolve->targetName));

  00620	41 b8 08 02 00
	00		 mov	 r8d, 520		; 00000208H
  00626	48 8d 91 08 02
	00 00		 lea	 rdx, QWORD PTR [rcx+520]
  0062d	66 89 99 06 02
	00 00		 mov	 WORD PTR [rcx+518], bx
  00634	e8 00 00 00 00	 call	 SymbolicLinkToTarget
$LN281@ProcessMai:

; 1221 : 
; 1222 : 				Irp->IoStatus.Information = sizeof (RESOLVE_SYMLINK_STRUCT);

  00639	48 89 7e 38	 mov	 QWORD PTR [rsi+56], rdi

; 1223 : 				Irp->IoStatus.Status = ntStatus;
; 1224 : 			}
; 1225 : 		}
; 1226 : 		break;

  0063d	e9 12 0c 00 00	 jmp	 $LN276@ProcessMai
$LN53@ProcessMai:

; 1307 : 
; 1308 : 	case TC_IOCTL_PROBE_REAL_DRIVE_SIZE:
; 1309 : 		if (ValidateIOBufferSize (Irp, sizeof (ProbeRealDriveSizeRequest), ValidateInputOutput))

  00642	41 be 14 02 00
	00		 mov	 r14d, 532		; 00000214H
  00648	41 b8 02 00 00
	00		 mov	 r8d, 2
  0064e	48 8b ce	 mov	 rcx, rsi
  00651	49 8b d6	 mov	 rdx, r14
  00654	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00659	33 db		 xor	 ebx, ebx
  0065b	3b c3		 cmp	 eax, ebx
  0065d	0f 84 f4 0b 00
	00		 je	 $LN144@ProcessMai

; 1310 : 		{
; 1311 : 			ProbeRealDriveSizeRequest *request = (ProbeRealDriveSizeRequest *) Irp->AssociatedIrp.SystemBuffer;

  00663	4c 8b 66 18	 mov	 r12, QWORD PTR [rsi+24]

; 1312 : 			NTSTATUS status;
; 1313 : 			UNICODE_STRING name;
; 1314 : 			PFILE_OBJECT fileObject;
; 1315 : 			PDEVICE_OBJECT deviceObject;
; 1316 : 
; 1317 : 			EnsureNullTerminatedString (request->DeviceName, sizeof (request->DeviceName));
; 1318 : 
; 1319 : 			RtlInitUnicodeString (&name, request->DeviceName);

  00667	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR name$31952[rsp]
  0066f	49 8b d4	 mov	 rdx, r12
  00672	66 41 89 9c 24
	06 02 00 00	 mov	 WORD PTR [r12+518], bx
  0067b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 1320 : 			status = IoGetDeviceObjectPointer (&name, FILE_READ_ATTRIBUTES, &fileObject, &deviceObject);

  00681	4c 8d 8c 24 a8
	00 00 00	 lea	 r9, QWORD PTR deviceObject$31954[rsp]
  00689	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR fileObject$31953[rsp]
  00691	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR name$31952[rsp]
  00699	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0069e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetDeviceObjectPointer

; 1321 : 			if (!NT_SUCCESS (status))

  006a4	3b c3		 cmp	 eax, ebx

; 1322 : 			{
; 1323 : 				Irp->IoStatus.Information = 0;
; 1324 : 				Irp->IoStatus.Status = status;
; 1325 : 				break;

  006a6	0f 8c a4 0b 00
	00		 jl	 $LN275@ProcessMai

; 1326 : 			}
; 1327 : 
; 1328 : 			status = ProbeRealDriveSize (deviceObject, &request->RealDriveSize);

  006ac	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR deviceObject$31954[rsp]
  006b4	49 8d 94 24 08
	02 00 00	 lea	 rdx, QWORD PTR [r12+520]
  006bc	e8 00 00 00 00	 call	 ProbeRealDriveSize

; 1329 : 			ObDereferenceObject (fileObject);

  006c1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fileObject$31953[rsp]
  006c9	8b f8		 mov	 edi, eax
  006cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 1330 : 
; 1331 : 			if (status == STATUS_TIMEOUT)

  006d1	81 ff 02 01 00
	00		 cmp	 edi, 258		; 00000102H
  006d7	75 14		 jne	 SHORT $LN50@ProcessMai

; 1332 : 			{
; 1333 : 				request->TimeOut = TRUE;

  006d9	8d 6b 01	 lea	 ebp, QWORD PTR [rbx+1]
  006dc	41 89 ac 24 10
	02 00 00	 mov	 DWORD PTR [r12+528], ebp

; 1334 : 				Irp->IoStatus.Information = sizeof (ProbeRealDriveSizeRequest);

  006e4	4c 89 76 38	 mov	 QWORD PTR [rsi+56], r14

; 1335 : 				Irp->IoStatus.Status = STATUS_SUCCESS;

  006e8	e9 4e fe ff ff	 jmp	 $LN283@ProcessMai
$LN50@ProcessMai:

; 1336 : 			}
; 1337 : 			else if (!NT_SUCCESS (status))

  006ed	3b fb		 cmp	 edi, ebx
  006ef	7d 06		 jge	 SHORT $LN48@ProcessMai

; 1338 : 			{
; 1339 : 				Irp->IoStatus.Information = 0;

  006f1	48 89 5e 38	 mov	 QWORD PTR [rsi+56], rbx

; 1340 : 				Irp->IoStatus.Status = status;
; 1341 : 			}
; 1342 : 			else

  006f5	eb 0c		 jmp	 SHORT $LN286@ProcessMai
$LN48@ProcessMai:

; 1343 : 			{
; 1344 : 				request->TimeOut = FALSE;

  006f7	41 89 9c 24 10
	02 00 00	 mov	 DWORD PTR [r12+528], ebx

; 1345 : 				Irp->IoStatus.Information = sizeof (ProbeRealDriveSizeRequest);

  006ff	4c 89 76 38	 mov	 QWORD PTR [rsi+56], r14
$LN286@ProcessMai:

; 1346 : 				Irp->IoStatus.Status = status;

  00703	89 7e 30	 mov	 DWORD PTR [rsi+48], edi

; 1347 : 			}
; 1348 : 		}
; 1349 : 		break;

  00706	e9 4c 0b 00 00	 jmp	 $LN144@ProcessMai
$LN55@ProcessMai:

; 1288 : 
; 1289 : 	case TC_IOCTL_GET_DRIVE_GEOMETRY:
; 1290 : 		if (ValidateIOBufferSize (Irp, sizeof (DISK_GEOMETRY_STRUCT), ValidateInputOutput))

  0070b	bf 20 02 00 00	 mov	 edi, 544		; 00000220H
  00710	41 b8 02 00 00
	00		 mov	 r8d, 2
  00716	48 8b ce	 mov	 rcx, rsi
  00719	48 8b d7	 mov	 rdx, rdi
  0071c	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00721	33 db		 xor	 ebx, ebx
  00723	3b c3		 cmp	 eax, ebx
  00725	0f 84 2c 0b 00
	00		 je	 $LN144@ProcessMai

; 1291 : 		{
; 1292 : 			DISK_GEOMETRY_STRUCT *g = (DISK_GEOMETRY_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  0072b	48 8b 4e 18	 mov	 rcx, QWORD PTR [rsi+24]

; 1293 : 			{
; 1294 : 				NTSTATUS ntStatus;
; 1295 : 
; 1296 : 				EnsureNullTerminatedString (g->deviceName, sizeof (g->deviceName));
; 1297 : 
; 1298 : 				ntStatus = TCDeviceIoControl (g->deviceName,
; 1299 : 					IOCTL_DISK_GET_DRIVE_GEOMETRY,
; 1300 : 					NULL, 0, &g->diskGeometry, sizeof (g->diskGeometry));

  0072f	45 33 c9	 xor	 r9d, r9d
  00732	45 33 c0	 xor	 r8d, r8d
  00735	48 8d 81 08 02
	00 00		 lea	 rax, QWORD PTR [rcx+520]
  0073c	ba 00 00 07 00	 mov	 edx, 458752		; 00070000H
  00741	c7 44 24 28 18
	00 00 00	 mov	 DWORD PTR [rsp+40], 24
  00749	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0074e	66 89 99 06 02
	00 00		 mov	 WORD PTR [rcx+518], bx
  00755	e8 00 00 00 00	 call	 TCDeviceIoControl

; 1301 : 
; 1302 : 				Irp->IoStatus.Information = sizeof (DISK_GEOMETRY_STRUCT);
; 1303 : 				Irp->IoStatus.Status = ntStatus;
; 1304 : 			}
; 1305 : 		}
; 1306 : 		break;

  0075a	e9 da fe ff ff	 jmp	 $LN281@ProcessMai
$LN64@ProcessMai:

; 1227 : 
; 1228 : 	case TC_IOCTL_GET_DRIVE_PARTITION_INFO:
; 1229 : 		if (ValidateIOBufferSize (Irp, sizeof (DISK_PARTITION_INFO_STRUCT), ValidateInputOutput))

  0075f	41 bf 30 02 00
	00		 mov	 r15d, 560		; 00000230H
  00765	41 b8 02 00 00
	00		 mov	 r8d, 2
  0076b	48 8b ce	 mov	 rcx, rsi
  0076e	49 8b d7	 mov	 rdx, r15
  00771	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00776	33 db		 xor	 ebx, ebx
  00778	3b c3		 cmp	 eax, ebx
  0077a	0f 84 d7 0a 00
	00		 je	 $LN144@ProcessMai

; 1230 : 		{
; 1231 : 			DISK_PARTITION_INFO_STRUCT *info = (DISK_PARTITION_INFO_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  00780	4c 8b 66 18	 mov	 r12, QWORD PTR [rsi+24]

; 1232 : 			{
; 1233 : 				PARTITION_INFORMATION_EX pi;
; 1234 : 				NTSTATUS ntStatus;
; 1235 : 
; 1236 : 				EnsureNullTerminatedString (info->deviceName, sizeof (info->deviceName));
; 1237 : 
; 1238 : 				ntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0, &pi, sizeof (pi));

  00784	48 8d 84 24 50
	01 00 00	 lea	 rax, QWORD PTR pi$31918[rsp]
  0078c	45 33 c9	 xor	 r9d, r9d
  0078f	45 33 c0	 xor	 r8d, r8d
  00792	ba 48 00 07 00	 mov	 edx, 458824		; 00070048H
  00797	49 8b cc	 mov	 rcx, r12
  0079a	c7 44 24 28 90
	00 00 00	 mov	 DWORD PTR [rsp+40], 144	; 00000090H
  007a2	66 41 89 9c 24
	06 02 00 00	 mov	 WORD PTR [r12+518], bx
  007ab	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007b0	e8 00 00 00 00	 call	 TCDeviceIoControl

; 1239 : 				if (NT_SUCCESS(ntStatus))
; 1240 : 				{
; 1241 : 					memset (&info->partInfo, 0, sizeof (info->partInfo));

  007b5	4d 8d b4 24 08
	02 00 00	 lea	 r14, QWORD PTR [r12+520]
  007bd	3b c3		 cmp	 eax, ebx
  007bf	44 8b e8	 mov	 r13d, eax
  007c2	7c 7a		 jl	 SHORT $LN62@ProcessMai
  007c4	44 8d 43 20	 lea	 r8d, QWORD PTR [rbx+32]
  007c8	33 d2		 xor	 edx, edx
  007ca	49 8b ce	 mov	 rcx, r14
  007cd	e8 00 00 00 00	 call	 memset

; 1242 : 
; 1243 : 					info->partInfo.PartitionLength = pi.PartitionLength;
; 1244 : 					info->partInfo.PartitionNumber = pi.PartitionNumber;

  007d2	8b 8c 24 68 01
	00 00		 mov	 ecx, DWORD PTR pi$31918[rsp+24]
  007d9	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR pi$31918[rsp+16]
  007e1	41 89 8c 24 1c
	02 00 00	 mov	 DWORD PTR [r12+540], ecx

; 1245 : 					info->partInfo.StartingOffset = pi.StartingOffset;

  007e9	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR pi$31918[rsp+8]
  007f1	49 89 94 24 10
	02 00 00	 mov	 QWORD PTR [r12+528], rdx
  007f9	49 89 0e	 mov	 QWORD PTR [r14], rcx

; 1246 : 
; 1247 : 					if (pi.PartitionStyle == PARTITION_STYLE_MBR)

  007fc	39 9c 24 50 01
	00 00		 cmp	 DWORD PTR pi$31918[rsp], ebx
  00803	75 1e		 jne	 SHORT $LN61@ProcessMai

; 1248 : 					{
; 1249 : 						info->partInfo.PartitionType = pi.Mbr.PartitionType;

  00805	8a 84 24 70 01
	00 00		 mov	 al, BYTE PTR pi$31918[rsp+32]
  0080c	41 88 84 24 20
	02 00 00	 mov	 BYTE PTR [r12+544], al

; 1250 : 						info->partInfo.BootIndicator = pi.Mbr.BootIndicator;

  00814	8a 84 24 71 01
	00 00		 mov	 al, BYTE PTR pi$31918[rsp+33]
  0081b	41 88 84 24 21
	02 00 00	 mov	 BYTE PTR [r12+545], al
$LN61@ProcessMai:

; 1251 : 					}
; 1252 : 
; 1253 : 					info->IsGPT = pi.PartitionStyle == PARTITION_STYLE_GPT;

  00823	8b c3		 mov	 eax, ebx
  00825	bd 01 00 00 00	 mov	 ebp, 1
  0082a	39 ac 24 50 01
	00 00		 cmp	 DWORD PTR pi$31918[rsp], ebp
  00831	0f 94 c0	 sete	 al
  00834	41 89 84 24 28
	02 00 00	 mov	 DWORD PTR [r12+552], eax

; 1254 : 				}
; 1255 : 				else

  0083c	eb 2b		 jmp	 SHORT $LN60@ProcessMai
$LN62@ProcessMai:

; 1256 : 				{
; 1257 : 					// Windows 2000 does not support IOCTL_DISK_GET_PARTITION_INFO_EX
; 1258 : 					ntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0, &info->partInfo, sizeof (info->partInfo));

  0083e	45 33 c9	 xor	 r9d, r9d
  00841	45 33 c0	 xor	 r8d, r8d
  00844	ba 04 40 07 00	 mov	 edx, 475140		; 00074004H
  00849	49 8b cc	 mov	 rcx, r12
  0084c	c7 44 24 28 20
	00 00 00	 mov	 DWORD PTR [rsp+40], 32	; 00000020H
  00854	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  00859	e8 00 00 00 00	 call	 TCDeviceIoControl

; 1259 : 					info->IsGPT = FALSE;

  0085e	41 89 9c 24 28
	02 00 00	 mov	 DWORD PTR [r12+552], ebx
  00866	44 8b e8	 mov	 r13d, eax
$LN60@ProcessMai:

; 1260 : 				}
; 1261 : 
; 1262 : 				if (!NT_SUCCESS (ntStatus))

  00869	44 3b eb	 cmp	 r13d, ebx
  0086c	7d 4d		 jge	 SHORT $LN58@ProcessMai

; 1263 : 				{
; 1264 : 					GET_LENGTH_INFORMATION lengthInfo;
; 1265 : 					ntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_LENGTH_INFO, NULL, 0, &lengthInfo, sizeof (lengthInfo));

  0086e	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR lengthInfo$31928[rsp]
  00876	45 33 c9	 xor	 r9d, r9d
  00879	45 33 c0	 xor	 r8d, r8d
  0087c	ba 5c 40 07 00	 mov	 edx, 475228		; 0007405cH
  00881	49 8b cc	 mov	 rcx, r12
  00884	c7 44 24 28 08
	00 00 00	 mov	 DWORD PTR [rsp+40], 8
  0088c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00891	e8 00 00 00 00	 call	 TCDeviceIoControl

; 1266 : 
; 1267 : 					if (NT_SUCCESS (ntStatus))

  00896	3b c3		 cmp	 eax, ebx
  00898	44 8b e8	 mov	 r13d, eax
  0089b	7c 1e		 jl	 SHORT $LN58@ProcessMai

; 1268 : 					{
; 1269 : 						memset (&info->partInfo, 0, sizeof (info->partInfo));

  0089d	33 d2		 xor	 edx, edx
  0089f	49 8b ce	 mov	 rcx, r14
  008a2	44 8d 42 20	 lea	 r8d, QWORD PTR [rdx+32]
  008a6	e8 00 00 00 00	 call	 memset

; 1270 : 						info->partInfo.PartitionLength = lengthInfo.Length;

  008ab	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR lengthInfo$31928[rsp]
  008b3	49 89 94 24 10
	02 00 00	 mov	 QWORD PTR [r12+528], rdx
$LN58@ProcessMai:

; 1271 : 					}
; 1272 : 				}
; 1273 : 
; 1274 : 				info->IsDynamic = FALSE;
; 1275 : 
; 1276 : 				if (NT_SUCCESS (ntStatus) && OsMajorVersion >= 6)

  008bb	44 3b eb	 cmp	 r13d, ebx
  008be	49 8d ac 24 2c
	02 00 00	 lea	 rbp, QWORD PTR [r12+556]
  008c6	89 5d 00	 mov	 DWORD PTR [rbp], ebx
  008c9	7c 2c		 jl	 SHORT $LN56@ProcessMai
  008cb	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR OsMajorVersion, 6
  008d2	72 23		 jb	 SHORT $LN56@ProcessMai

; 1277 : 				{
; 1278 : #					define IOCTL_VOLUME_IS_DYNAMIC CTL_CODE(IOCTL_VOLUME_BASE, 18, METHOD_BUFFERED, FILE_ANY_ACCESS)
; 1279 : 					if (!NT_SUCCESS (TCDeviceIoControl (info->deviceName, IOCTL_VOLUME_IS_DYNAMIC, NULL, 0, &info->IsDynamic, sizeof (info->IsDynamic))))

  008d4	45 33 c9	 xor	 r9d, r9d
  008d7	45 33 c0	 xor	 r8d, r8d
  008da	ba 48 00 56 00	 mov	 edx, 5636168		; 00560048H
  008df	49 8b cc	 mov	 rcx, r12
  008e2	89 7c 24 28	 mov	 DWORD PTR [rsp+40], edi
  008e6	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  008eb	e8 00 00 00 00	 call	 TCDeviceIoControl
  008f0	3b c3		 cmp	 eax, ebx
  008f2	7d 03		 jge	 SHORT $LN56@ProcessMai

; 1280 : 						info->IsDynamic = FALSE;

  008f4	89 5d 00	 mov	 DWORD PTR [rbp], ebx
$LN56@ProcessMai:

; 1281 : 				}
; 1282 : 
; 1283 : 				Irp->IoStatus.Information = sizeof (DISK_PARTITION_INFO_STRUCT);

  008f7	4c 89 7e 38	 mov	 QWORD PTR [rsi+56], r15

; 1284 : 				Irp->IoStatus.Status = ntStatus;

  008fb	44 89 6e 30	 mov	 DWORD PTR [rsi+48], r13d

; 1285 : 			}
; 1286 : 		}
; 1287 : 		break;

  008ff	e9 53 09 00 00	 jmp	 $LN144@ProcessMai
$LN129@ProcessMai:

; 871  : 
; 872  : 	case TC_IOCTL_OPEN_TEST:
; 873  : 		{
; 874  : 			OPEN_TEST_STRUCT *opentest = (OPEN_TEST_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  00904	49 8b 78 18	 mov	 rdi, QWORD PTR [r8+24]

; 875  : 			OBJECT_ATTRIBUTES ObjectAttributes;
; 876  : 			HANDLE NtFileHandle;
; 877  : 			UNICODE_STRING FullFileName;
; 878  : 			IO_STATUS_BLOCK IoStatus;
; 879  : 			LARGE_INTEGER offset;
; 880  : 			ACCESS_MASK access = FILE_READ_ATTRIBUTES;

  00908	41 bd 80 00 00
	00		 mov	 r13d, 128		; 00000080H

; 881  : 
; 882  : 			if (!ValidateIOBufferSize (Irp, sizeof (OPEN_TEST_STRUCT), ValidateInputOutput))

  0090e	41 be 18 02 00
	00		 mov	 r14d, 536		; 00000218H
  00914	45 8d 45 82	 lea	 r8d, QWORD PTR [r13-126]
  00918	49 8b d6	 mov	 rdx, r14
  0091b	48 8b ce	 mov	 rcx, rsi
  0091e	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00923	33 db		 xor	 ebx, ebx
  00925	3b c3		 cmp	 eax, ebx
  00927	0f 84 2a 09 00
	00		 je	 $LN144@ProcessMai

; 883  : 				break;
; 884  : 
; 885  : 			EnsureNullTerminatedString (opentest->wszFileName, sizeof (opentest->wszFileName));
; 886  : 			RtlInitUnicodeString (&FullFileName, opentest->wszFileName);

  0092d	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR FullFileName$31764[rsp]
  00935	48 8b d7	 mov	 rdx, rdi
  00938	66 89 9f 06 02
	00 00		 mov	 WORD PTR [rdi+518], bx
  0093f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 887  : 
; 888  : 			InitializeObjectAttributes (&ObjectAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

  00945	48 8d 84 24 10
	01 00 00	 lea	 rax, QWORD PTR FullFileName$31764[rsp]
  0094d	c7 84 24 e0 00
	00 00 30 00 00
	00		 mov	 DWORD PTR ObjectAttributes$31762[rsp], 48 ; 00000030H
  00958	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR ObjectAttributes$31762[rsp+16], rax
  00960	48 89 9c 24 e8
	00 00 00	 mov	 QWORD PTR ObjectAttributes$31762[rsp+8], rbx
  00968	c7 84 24 f8 00
	00 00 40 02 00
	00		 mov	 DWORD PTR ObjectAttributes$31762[rsp+24], 576 ; 00000240H
  00973	48 89 9c 24 00
	01 00 00	 mov	 QWORD PTR ObjectAttributes$31762[rsp+32], rbx
  0097b	48 89 9c 24 08
	01 00 00	 mov	 QWORD PTR ObjectAttributes$31762[rsp+40], rbx

; 889  : 
; 890  : 			if (opentest->bDetectTCBootLoader || opentest->DetectFilesystem)

  00983	39 9f 08 02 00
	00		 cmp	 DWORD PTR [rdi+520], ebx
  00989	75 08		 jne	 SHORT $LN126@ProcessMai
  0098b	39 9f 10 02 00
	00		 cmp	 DWORD PTR [rdi+528], ebx
  00991	74 06		 je	 SHORT $LN127@ProcessMai
$LN126@ProcessMai:

; 891  : 				access |= FILE_READ_DATA;

  00993	41 bd 81 00 00
	00		 mov	 r13d, 129		; 00000081H
$LN127@ProcessMai:

; 892  : 
; 893  : 			ntStatus = ZwCreateFile (&NtFileHandle,
; 894  : 						 SYNCHRONIZE | access, &ObjectAttributes, &IoStatus, NULL,
; 895  : 						 0, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);

  00999	89 5c 24 50	 mov	 DWORD PTR [rsp+80], ebx
  0099d	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  009a2	c7 44 24 40 20
	00 00 00	 mov	 DWORD PTR [rsp+64], 32	; 00000020H
  009aa	41 0f ba ed 14	 bts	 r13d, 20
  009af	bd 01 00 00 00	 mov	 ebp, 1
  009b4	4c 8d 4c 24 78	 lea	 r9, QWORD PTR IoStatus$31765[rsp]
  009b9	89 6c 24 38	 mov	 DWORD PTR [rsp+56], ebp
  009bd	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR [rsp+48], 3
  009c5	4c 8d 84 24 e0
	00 00 00	 lea	 r8, QWORD PTR ObjectAttributes$31762[rsp]
  009cd	48 8d 4c 24 68	 lea	 rcx, QWORD PTR NtFileHandle$31763[rsp]
  009d2	41 8b d5	 mov	 edx, r13d
  009d5	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  009d9	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  009de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwCreateFile

; 896  : 
; 897  : 			if (NT_SUCCESS (ntStatus))

  009e4	3b c3		 cmp	 eax, ebx
  009e6	44 8b e0	 mov	 r12d, eax
  009e9	0f 8c 72 01 00
	00		 jl	 $LN125@ProcessMai

; 898  : 			{
; 899  : 				opentest->TCBootLoaderDetected = FALSE;

  009ef	89 9f 0c 02 00
	00		 mov	 DWORD PTR [rdi+524], ebx

; 900  : 				opentest->FilesystemDetected = FALSE;

  009f5	89 9f 14 02 00
	00		 mov	 DWORD PTR [rdi+532], ebx

; 901  : 
; 902  : 				if (opentest->bDetectTCBootLoader || opentest->DetectFilesystem)

  009fb	39 9f 08 02 00
	00		 cmp	 DWORD PTR [rdi+520], ebx
  00a01	75 0c		 jne	 SHORT $LN123@ProcessMai
  00a03	39 9f 10 02 00
	00		 cmp	 DWORD PTR [rdi+528], ebx
  00a09	0f 84 47 01 00
	00		 je	 $LN121@ProcessMai
$LN123@ProcessMai:

; 903  : 				{
; 904  : 					byte *readBuffer = TCalloc (TC_MAX_VOLUME_SECTOR_SIZE);

  00a0f	41 bf 54 43 4d
	4d		 mov	 r15d, 1296909140	; 4d4d4354H
  00a15	41 bc 00 10 00
	00		 mov	 r12d, 4096		; 00001000H
  00a1b	33 c9		 xor	 ecx, ecx
  00a1d	45 8b c7	 mov	 r8d, r15d
  00a20	49 8b d4	 mov	 rdx, r12
  00a23	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00a29	4c 8b e8	 mov	 r13, rax

; 905  : 					if (!readBuffer)

  00a2c	48 3b c3	 cmp	 rax, rbx
  00a2f	75 0b		 jne	 SHORT $LN122@ProcessMai

; 906  : 					{
; 907  : 						ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00a31	41 bc 9a 00 00
	c0		 mov	 r12d, -1073741670	; ffffffffc000009aH

; 908  : 					}
; 909  : 					else

  00a37	e9 1a 01 00 00	 jmp	 $LN121@ProcessMai
$LN122@ProcessMai:

; 910  : 					{
; 911  : 						// Determine if the first sector contains a portion of the TrueCrypt Boot Loader
; 912  : 
; 913  : 						offset.QuadPart = 0;
; 914  : 
; 915  : 						ntStatus = ZwReadFile (NtFileHandle,
; 916  : 							NULL,
; 917  : 							NULL,
; 918  : 							NULL,
; 919  : 							&IoStatus,
; 920  : 							readBuffer,
; 921  : 							TC_MAX_VOLUME_SECTOR_SIZE,
; 922  : 							&offset,
; 923  : 							NULL);

  00a3c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR NtFileHandle$31763[rsp]
  00a41	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00a46	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR offset$31766[rsp]
  00a4e	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00a53	48 8d 44 24 78	 lea	 rax, QWORD PTR IoStatus$31765[rsp]
  00a58	44 89 64 24 30	 mov	 DWORD PTR [rsp+48], r12d
  00a5d	45 33 c9	 xor	 r9d, r9d
  00a60	45 33 c0	 xor	 r8d, r8d
  00a63	33 d2		 xor	 edx, edx
  00a65	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  00a6a	48 89 9c 24 90
	00 00 00	 mov	 QWORD PTR offset$31766[rsp], rbx
  00a72	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a77	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwReadFile

; 924  : 
; 925  : 						if (NT_SUCCESS (ntStatus))

  00a7d	3b c3		 cmp	 eax, ebx
  00a7f	44 8b e0	 mov	 r12d, eax
  00a82	0f 8c c2 00 00
	00		 jl	 $LN112@ProcessMai

; 926  : 						{
; 927  : 							size_t i;
; 928  : 
; 929  : 							if (opentest->bDetectTCBootLoader && IoStatus.Information >= TC_SECTOR_SIZE_BIOS)

  00a88	39 9f 08 02 00
	00		 cmp	 DWORD PTR [rdi+520], ebx
  00a8e	74 5c		 je	 SHORT $LN273@ProcessMai
  00a90	48 81 bc 24 80
	00 00 00 00 02
	00 00		 cmp	 QWORD PTR IoStatus$31765[rsp+8], 512 ; 00000200H
  00a9c	72 4e		 jb	 SHORT $LN273@ProcessMai

; 930  : 							{
; 931  : 								// Search for the string "TrueCrypt"
; 932  : 								for (i = 0; i < TC_SECTOR_SIZE_BIOS - strlen (TC_APP_NAME_LEGACY); ++i)

  00a9e	48 8b cb	 mov	 rcx, rbx
  00aa1	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:__ImageBase
$LL118@ProcessMai:

; 933  : 								{
; 934  : 									if (memcmp (readBuffer + i, TC_APP_NAME_LEGACY, strlen (TC_APP_NAME_LEGACY)) == 0)

  00aa8	4a 8d 04 29	 lea	 rax, QWORD PTR [rcx+r13]
  00aac	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00aaf	4d 3b 86 00 00
	00 00		 cmp	 r8, QWORD PTR ??_C@_09EMKKFGIH@TrueCrypt?$AA@FNODOBFM@[r14]
  00ab6	75 11		 jne	 SHORT $LN271@ProcessMai
  00ab8	44 8a 40 08	 mov	 r8b, BYTE PTR [rax+8]
  00abc	45 3a 86 08 00
	00 00		 cmp	 r8b, BYTE PTR ??_C@_09EMKKFGIH@TrueCrypt?$AA@FNODOBFM@[r14+8]
  00ac3	75 04		 jne	 SHORT $LN271@ProcessMai
  00ac5	8b c3		 mov	 eax, ebx
  00ac7	eb 05		 jmp	 SHORT $LN272@ProcessMai
$LN271@ProcessMai:
  00ac9	1b c0		 sbb	 eax, eax
  00acb	83 d8 ff	 sbb	 eax, -1
$LN272@ProcessMai:
  00ace	3b c3		 cmp	 eax, ebx
  00ad0	74 0e		 je	 SHORT $LN251@ProcessMai
  00ad2	48 03 cd	 add	 rcx, rbp
  00ad5	48 81 f9 f7 01
	00 00		 cmp	 rcx, 503		; 000001f7H
  00adc	72 ca		 jb	 SHORT $LL118@ProcessMai

; 1040 : 					{
; 1041 : 						if (memcmp (readBuffer + i, TC_APP_NAME_LEGACY, strlen (TC_APP_NAME_LEGACY)) == 0)

  00ade	eb 06		 jmp	 SHORT $LN277@ProcessMai
$LN251@ProcessMai:

; 935  : 									{
; 936  : 										opentest->TCBootLoaderDetected = TRUE;

  00ae0	89 af 0c 02 00
	00		 mov	 DWORD PTR [rdi+524], ebp
$LN277@ProcessMai:
  00ae6	41 be 18 02 00
	00		 mov	 r14d, 536		; 00000218H
$LN273@ProcessMai:

; 937  : 										break;
; 938  : 									}
; 939  : 								}
; 940  : 							}
; 941  : 
; 942  : 							if (opentest->DetectFilesystem && IoStatus.Information >= sizeof (int64))

  00aec	39 9f 10 02 00
	00		 cmp	 DWORD PTR [rdi+528], ebx
  00af2	74 56		 je	 SHORT $LN112@ProcessMai
  00af4	48 83 bc 24 80
	00 00 00 08	 cmp	 QWORD PTR IoStatus$31765[rsp+8], 8
  00afd	72 4b		 jb	 SHORT $LN112@ProcessMai

; 943  : 							{
; 944  : 								switch (BE64 (*(uint64 *) readBuffer))

  00aff	49 8b 4d 00	 mov	 rcx, QWORD PTR [r13]
  00b03	e8 00 00 00 00	 call	 MirrorBytes64
  00b08	48 b9 53 4f 44
	53 4d 90 3c eb	 mov	 rcx, -1496162314409980077 ; eb3c904d53444f53H
  00b12	48 3b c1	 cmp	 rax, rcx
  00b15	74 2d		 je	 SHORT $LN111@ProcessMai
  00b17	48 b9 20 53 46
	54 4e 90 52 eb	 mov	 rcx, -1489969860610469088 ; eb52904e54465320H
  00b21	48 3b c1	 cmp	 rax, rcx
  00b24	74 1e		 je	 SHORT $LN111@ProcessMai
  00b26	48 b9 53 4f 44
	53 4d 90 58 eb	 mov	 rcx, -1488281015062081709 ; eb58904d53444f53H
  00b30	48 3b c1	 cmp	 rax, rcx
  00b33	74 0f		 je	 SHORT $LN111@ProcessMai
  00b35	48 b9 54 41 46
	58 45 90 76 eb	 mov	 rcx, -1479836800036486828 ; eb76904558464154H
  00b3f	48 3b c1	 cmp	 rax, rcx
  00b42	75 06		 jne	 SHORT $LN112@ProcessMai
$LN111@ProcessMai:

; 945  : 								{
; 946  : 								case 0xEB52904E54465320: // NTFS
; 947  : 								case 0xEB3C904D53444F53: // FAT16
; 948  : 								case 0xEB58904D53444F53: // FAT32
; 949  : 								case 0xEB76904558464154: // exFAT
; 950  : 
; 951  : 									opentest->FilesystemDetected = TRUE;

  00b44	89 af 14 02 00
	00		 mov	 DWORD PTR [rdi+532], ebp
$LN112@ProcessMai:

; 952  : 									break;
; 953  : 								}
; 954  : 							}
; 955  : 						}
; 956  : 
; 957  : 						TCfree (readBuffer);

  00b4a	41 8b d7	 mov	 edx, r15d
  00b4d	49 8b cd	 mov	 rcx, r13
  00b50	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN121@ProcessMai:

; 958  : 					}
; 959  : 				}
; 960  : 
; 961  : 				ZwClose (NtFileHandle);

  00b56	48 8b 4c 24 68	 mov	 rcx, QWORD PTR NtFileHandle$31763[rsp]
  00b5b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
$LN125@ProcessMai:

; 962  : 				Dump ("Open test on file %ls success.\n", opentest->wszFileName);
; 963  : 			}
; 964  : 			else
; 965  : 			{
; 966  : #if 0
; 967  : 				Dump ("Open test on file %ls failed NTSTATUS 0x%08x\n", opentest->wszFileName, ntStatus);
; 968  : #endif
; 969  : 			}
; 970  : 
; 971  : 			Irp->IoStatus.Information = NT_SUCCESS (ntStatus) ? sizeof (OPEN_TEST_STRUCT) : 0;

  00b61	44 3b e3	 cmp	 r12d, ebx

; 972  : 			Irp->IoStatus.Status = ntStatus;

  00b64	44 89 66 30	 mov	 DWORD PTR [rsi+48], r12d
  00b68	49 0f 4d de	 cmovge	 rbx, r14
  00b6c	48 89 5e 38	 mov	 QWORD PTR [rsi+56], rbx

; 973  : 		}
; 974  : 		break;

  00b70	e9 e2 06 00 00	 jmp	 $LN144@ProcessMai

; 1068 : 			{
; 1069 : 				Irp->IoStatus.Status = ntStatus;
; 1070 : 				Irp->IoStatus.Information = 0;
; 1071 : 			}
; 1072 : 		}
; 1073 : 		break;
; 1074 : 
; 1075 : 	case TC_IOCTL_WIPE_PASSWORD_CACHE:
; 1076 : 		WipeCache ();

$LN173@ProcessMai:
  00b75	33 c0		 xor	 eax, eax
  00b77	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:CachedPasswords
  00b7e	41 b8 20 01 00
	00		 mov	 r8d, 288		; 00000120H
  00b84	48 8b fa	 mov	 rdi, rdx
  00b87	49 8b c8	 mov	 rcx, r8
  00b8a	33 db		 xor	 ebx, ebx
  00b8c	f3 aa		 rep stosb
  00b8e	8d 68 01	 lea	 ebp, QWORD PTR [rax+1]
$LL170@ProcessMai:
  00b91	44 2b c5	 sub	 r8d, ebp
  00b94	88 1a		 mov	 BYTE PTR [rdx], bl
  00b96	48 03 d5	 add	 rdx, rbp
  00b99	44 3b c3	 cmp	 r8d, ebx
  00b9c	75 f3		 jne	 SHORT $LL170@ProcessMai
  00b9e	89 1d 00 00 00
	00		 mov	 DWORD PTR nPasswordIdx, ebx
  00ba4	89 2d 00 00 00
	00		 mov	 DWORD PTR cacheEmpty, ebp
$LN289@ProcessMai:

; 1077 : 
; 1078 : 		Irp->IoStatus.Status = STATUS_SUCCESS;

  00baa	89 5e 30	 mov	 DWORD PTR [rsi+48], ebx
$LN7@ProcessMai:

; 1079 : 		Irp->IoStatus.Information = 0;

  00bad	48 89 5e 38	 mov	 QWORD PTR [rsi+56], rbx

; 1080 : 		break;

  00bb1	e9 a1 06 00 00	 jmp	 $LN144@ProcessMai
$LN92@ProcessMai:

; 1081 : 
; 1082 : 	case TC_IOCTL_GET_PASSWORD_CACHE_STATUS:
; 1083 : 		Irp->IoStatus.Status = cacheEmpty ? STATUS_PIPE_EMPTY : STATUS_SUCCESS;

  00bb6	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cacheEmpty
  00bbc	f7 d8		 neg	 eax
  00bbe	1b c9		 sbb	 ecx, ecx
$LN284@ProcessMai:
  00bc0	81 e1 d9 00 00
	c0		 and	 ecx, -1073741607	; ffffffffc00000d9H
  00bc6	41 89 48 30	 mov	 DWORD PTR [r8+48], ecx
$LN285@ProcessMai:

; 1084 : 		Irp->IoStatus.Information = 0;

  00bca	33 db		 xor	 ebx, ebx
  00bcc	49 89 58 38	 mov	 QWORD PTR [r8+56], rbx

; 1085 : 		break;

  00bd0	e9 82 06 00 00	 jmp	 $LN144@ProcessMai
$LN136@ProcessMai:

; 848  : 
; 849  : 	case TC_IOCTL_IS_ANY_VOLUME_MOUNTED:
; 850  : 		if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))

  00bd5	bd 01 00 00 00	 mov	 ebp, 1
  00bda	48 8b d7	 mov	 rdx, rdi
  00bdd	48 8b ce	 mov	 rcx, rsi
  00be0	44 8b c5	 mov	 r8d, ebp
  00be3	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00be8	33 db		 xor	 ebx, ebx
  00bea	3b c3		 cmp	 eax, ebx
  00bec	0f 84 65 06 00
	00		 je	 $LN144@ProcessMai

; 851  : 		{
; 852  : 			int drive;
; 853  : 			*(int *) Irp->AssociatedIrp.SystemBuffer = 0;

  00bf2	48 8b 46 18	 mov	 rax, QWORD PTR [rsi+24]

; 854  : 
; 855  : 			for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)

  00bf6	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:__ImageBase
  00bfd	89 18		 mov	 DWORD PTR [rax], ebx
  00bff	48 8b c3	 mov	 rax, rbx

; 856  : 			{
; 857  : 				if (GetVirtualVolumeDeviceObject (drive))

  00c02	48 83 f8 19	 cmp	 rax, 25
$LN278@ProcessMai:
  00c06	77 0a		 ja	 SHORT $LN155@ProcessMai
  00c08	49 8b 8c c6 00
	00 00 00	 mov	 rcx, QWORD PTR VirtualVolumeDeviceObjects[r14+rax*8]
  00c10	eb 03		 jmp	 SHORT $LN157@ProcessMai
$LN155@ProcessMai:
  00c12	48 8b cb	 mov	 rcx, rbx
$LN157@ProcessMai:
  00c15	48 3b cb	 cmp	 rcx, rbx
  00c18	75 0b		 jne	 SHORT $LN252@ProcessMai
  00c1a	48 03 c5	 add	 rax, rbp
  00c1d	48 83 f8 19	 cmp	 rax, 25
  00c21	7e e3		 jle	 SHORT $LN278@ProcessMai

; 1040 : 					{
; 1041 : 						if (memcmp (readBuffer + i, TC_APP_NAME_LEGACY, strlen (TC_APP_NAME_LEGACY)) == 0)

  00c23	eb 06		 jmp	 SHORT $LN132@ProcessMai
$LN252@ProcessMai:

; 858  : 				{
; 859  : 					*(int *) Irp->AssociatedIrp.SystemBuffer = 1;

  00c25	48 8b 46 18	 mov	 rax, QWORD PTR [rsi+24]
  00c29	89 28		 mov	 DWORD PTR [rax], ebp
$LN132@ProcessMai:

; 860  : 					break;
; 861  : 				}
; 862  : 			}
; 863  : 
; 864  : 			if (IsBootDriveMounted())

  00c2b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00c32	48 3b c3	 cmp	 rax, rbx
  00c35	0f 84 fc f8 ff
	ff		 je	 $LN282@ProcessMai
  00c3b	39 98 b8 02 00
	00		 cmp	 DWORD PTR [rax+696], ebx
  00c41	0f 84 f0 f8 ff
	ff		 je	 $LN282@ProcessMai

; 865  : 				*(int *) Irp->AssociatedIrp.SystemBuffer = 1;
; 866  : 
; 867  : 			Irp->IoStatus.Information = sizeof (int);
; 868  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 869  : 		}
; 870  : 		break;

  00c47	eb 59		 jmp	 SHORT $LN287@ProcessMai
$LN139@ProcessMai:

; 833  : 
; 834  : 	case TC_IOCTL_IS_DRIVER_UNLOAD_DISABLED:
; 835  : 		if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))

  00c49	bd 01 00 00 00	 mov	 ebp, 1
  00c4e	48 8b d7	 mov	 rdx, rdi
  00c51	48 8b ce	 mov	 rcx, rsi
  00c54	44 8b c5	 mov	 r8d, ebp
  00c57	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00c5c	33 db		 xor	 ebx, ebx
  00c5e	3b c3		 cmp	 eax, ebx
  00c60	0f 84 f1 05 00
	00		 je	 $LN144@ProcessMai

; 836  : 		{
; 837  : 			LONG deviceObjectCount = 0;
; 838  : 
; 839  : 			*(int *) Irp->AssociatedIrp.SystemBuffer = DriverUnloadDisabled;

  00c66	48 8b 4e 18	 mov	 rcx, QWORD PTR [rsi+24]
  00c6a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR DriverUnloadDisabled
  00c70	89 5c 24 60	 mov	 DWORD PTR deviceObjectCount$31737[rsp], ebx
  00c74	89 01		 mov	 DWORD PTR [rcx], eax

; 840  : 
; 841  : 			if (IoEnumerateDeviceObjectList (TCDriverObject, NULL, 0, &deviceObjectCount) == STATUS_BUFFER_TOO_SMALL && deviceObjectCount > 1)

  00c76	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR TCDriverObject
  00c7d	4c 8d 4c 24 60	 lea	 r9, QWORD PTR deviceObjectCount$31737[rsp]
  00c82	45 33 c0	 xor	 r8d, r8d
  00c85	33 d2		 xor	 edx, edx
  00c87	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoEnumerateDeviceObjectList
  00c8d	3d 23 00 00 c0	 cmp	 eax, -1073741789	; ffffffffc0000023H
  00c92	0f 85 9f f8 ff
	ff		 jne	 $LN282@ProcessMai
  00c98	39 6c 24 60	 cmp	 DWORD PTR deviceObjectCount$31737[rsp], ebp
  00c9c	0f 8e 95 f8 ff
	ff		 jle	 $LN282@ProcessMai
$LN287@ProcessMai:

; 842  : 				*(int *) Irp->AssociatedIrp.SystemBuffer = TRUE;

  00ca2	48 8b 46 18	 mov	 rax, QWORD PTR [rsi+24]
  00ca6	89 28		 mov	 DWORD PTR [rax], ebp

; 843  : 
; 844  : 			Irp->IoStatus.Information = sizeof (int);
; 845  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 846  : 		}
; 847  : 		break;

  00ca8	e9 8a f8 ff ff	 jmp	 $LN282@ProcessMai
$LN24@ProcessMai:

; 1415 : 
; 1416 : 	case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS:
; 1417 : 		GetBootEncryptionStatus (Irp, irpSp);

  00cad	49 8b d4	 mov	 rdx, r12
  00cb0	49 8b c8	 mov	 rcx, r8
  00cb3	e8 00 00 00 00	 call	 GetBootEncryptionStatus

; 1418 : 		break;

  00cb8	e9 9a 05 00 00	 jmp	 $LN144@ProcessMai
$LN150@ProcessMai:

; 810  : 	NTSTATUS ntStatus;
; 811  : 
; 812  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  00cbd	b9 70 20 22 00	 mov	 ecx, 2236528		; 00222070H
  00cc2	3b c1		 cmp	 eax, ecx
  00cc4	0f 87 d2 03 00
	00		 ja	 $LN152@ProcessMai
  00cca	0f 84 66 01 00
	00		 je	 $LN109@ProcessMai
  00cd0	2d 4c 20 22 00	 sub	 eax, 2236492		; 0022204cH
  00cd5	0f 84 48 01 00
	00		 je	 $LN26@ProcessMai
  00cdb	bf 04 00 00 00	 mov	 edi, 4
  00ce0	2b c7		 sub	 eax, edi
  00ce2	0f 84 31 01 00
	00		 je	 $LN25@ProcessMai
  00ce8	2b c7		 sub	 eax, edi
  00cea	0f 84 14 01 00
	00		 je	 $LN23@ProcessMai
  00cf0	2b c7		 sub	 eax, edi
  00cf2	0f 84 fc 00 00
	00		 je	 $LN22@ProcessMai
  00cf8	2b c7		 sub	 eax, edi
  00cfa	0f 84 e4 00 00
	00		 je	 $LN20@ProcessMai
  00d00	2b c7		 sub	 eax, edi
  00d02	0f 84 89 00 00
	00		 je	 $LN19@ProcessMai
  00d08	2b c7		 sub	 eax, edi
  00d0a	74 74		 je	 SHORT $LN88@ProcessMai
  00d0c	2b c7		 sub	 eax, edi
  00d0e	74 4b		 je	 SHORT $LN91@ProcessMai
  00d10	3b c7		 cmp	 eax, edi
  00d12	0f 85 cc 03 00
	00		 jne	 $LN1@ProcessMai

; 1439 : 		break;
; 1440 : 
; 1441 : 	case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:
; 1442 : 		if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))

  00d18	8d 6f fd	 lea	 ebp, QWORD PTR [rdi-3]
  00d1b	48 8b d7	 mov	 rdx, rdi
  00d1e	48 8b ce	 mov	 rcx, rsi
  00d21	44 8b c5	 mov	 r8d, ebp
  00d24	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00d29	33 db		 xor	 ebx, ebx
  00d2b	3b c3		 cmp	 eax, ebx
  00d2d	0f 84 24 05 00
	00		 je	 $LN144@ProcessMai

; 1443 : 		{
; 1444 : 			*(int *) Irp->AssociatedIrp.SystemBuffer = IsHiddenSystemRunning() ? 1 : 0;

  00d33	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00d3a	48 3b c3	 cmp	 rax, rbx
  00d3d	74 08		 je	 SHORT $LN218@ProcessMai
  00d3f	39 98 e0 02 00
	00		 cmp	 DWORD PTR [rax+736], ebx
  00d45	75 02		 jne	 SHORT $LN219@ProcessMai
$LN218@ProcessMai:
  00d47	8b eb		 mov	 ebp, ebx
$LN219@ProcessMai:
  00d49	48 8b 46 18	 mov	 rax, QWORD PTR [rsi+24]
  00d4d	8b cb		 mov	 ecx, ebx
  00d4f	3b eb		 cmp	 ebp, ebx
  00d51	0f 95 c1	 setne	 cl
  00d54	89 08		 mov	 DWORD PTR [rax], ecx

; 1445 : 			Irp->IoStatus.Information = sizeof (int);
; 1446 : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 1447 : 		}
; 1448 : 		break;

  00d56	e9 dc f7 ff ff	 jmp	 $LN282@ProcessMai
$LN91@ProcessMai:

; 1086 : 
; 1087 : 	case TC_IOCTL_SET_PORTABLE_MODE_STATUS:
; 1088 : 		if (!UserCanAccessDriveDevice())

  00d5b	e8 00 00 00 00	 call	 UserCanAccessDriveDevice
  00d60	33 db		 xor	 ebx, ebx
  00d62	3b c3		 cmp	 eax, ebx
  00d64	75 0a		 jne	 SHORT $LN90@ProcessMai
$LN280@ProcessMai:

; 1089 : 		{
; 1090 : 			Irp->IoStatus.Status = STATUS_ACCESS_DENIED;

  00d66	b8 22 00 00 c0	 mov	 eax, -1073741790	; ffffffffc0000022H

; 1091 : 			Irp->IoStatus.Information = 0;
; 1092 : 		}
; 1093 : 		else

  00d6b	e9 e0 04 00 00	 jmp	 $LN275@ProcessMai
$LN90@ProcessMai:

; 1094 : 		{
; 1095 : 			PortableMode = TRUE;

  00d70	bd 01 00 00 00	 mov	 ebp, 1
  00d75	89 2d 00 00 00
	00		 mov	 DWORD PTR PortableMode, ebp

; 1096 : 			Dump ("Setting portable mode\n");
; 1097 : 		}
; 1098 : 		break;

  00d7b	e9 d7 04 00 00	 jmp	 $LN144@ProcessMai
$LN88@ProcessMai:

; 1099 : 
; 1100 : 	case TC_IOCTL_GET_PORTABLE_MODE_STATUS:
; 1101 : 		Irp->IoStatus.Status = PortableMode ? STATUS_SUCCESS : STATUS_PIPE_EMPTY;

  00d80	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR PortableMode
  00d86	f7 d8		 neg	 eax
  00d88	1b c9		 sbb	 ecx, ecx
  00d8a	f7 d1		 not	 ecx

; 1102 : 		Irp->IoStatus.Information = 0;
; 1103 : 		break;

  00d8c	e9 2f fe ff ff	 jmp	 $LN284@ProcessMai
$LN19@ProcessMai:

; 1436 : 
; 1437 : 	case TC_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME:
; 1438 : 		GetBootEncryptionAlgorithmName (Irp, irpSp);

  00d91	bf 00 01 00 00	 mov	 edi, 256		; 00000100H
  00d96	41 b8 01 00 00
	00		 mov	 r8d, 1
  00d9c	48 8b ce	 mov	 rcx, rsi
  00d9f	48 8b d7	 mov	 rdx, rdi
  00da2	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00da7	33 db		 xor	 ebx, ebx
  00da9	3b c3		 cmp	 eax, ebx
  00dab	0f 84 a6 04 00
	00		 je	 $LN144@ProcessMai
  00db1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00db8	48 3b c3	 cmp	 rax, rbx
  00dbb	0f 84 08 f7 ff
	ff		 je	 $LN43@ProcessMai
  00dc1	39 98 b8 02 00
	00		 cmp	 DWORD PTR [rax+696], ebx
  00dc7	0f 84 fc f6 ff
	ff		 je	 $LN43@ProcessMai
  00dcd	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  00dd4	48 8b 4e 18	 mov	 rcx, QWORD PTR [rsi+24]
  00dd8	8b 10		 mov	 edx, DWORD PTR [rax]
  00dda	e8 00 00 00 00	 call	 EAGetName
  00ddf	e9 53 f7 ff ff	 jmp	 $LN282@ProcessMai
$LN20@ProcessMai:

; 1431 : 		break;
; 1432 : 
; 1433 : 	case TC_IOCTL_REOPEN_BOOT_VOLUME_HEADER:
; 1434 : 		ReopenBootVolumeHeader (Irp, irpSp);

  00de4	49 8b d4	 mov	 rdx, r12
  00de7	49 8b c8	 mov	 rcx, r8
  00dea	e8 00 00 00 00	 call	 ReopenBootVolumeHeader

; 1435 : 		break;

  00def	e9 63 04 00 00	 jmp	 $LN144@ProcessMai
$LN22@ProcessMai:

; 1424 : 
; 1425 : 	case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:
; 1426 : 		GetBootDriveVolumeProperties (Irp, irpSp);

  00df4	49 8b d4	 mov	 rdx, r12
  00df7	49 8b c8	 mov	 rcx, r8
  00dfa	e8 00 00 00 00	 call	 GetBootDriveVolumeProperties

; 1427 : 		break;

  00dff	e9 53 04 00 00	 jmp	 $LN144@ProcessMai
$LN23@ProcessMai:

; 1419 : 
; 1420 : 	case TC_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT:
; 1421 : 		Irp->IoStatus.Information = 0;
; 1422 : 		Irp->IoStatus.Status = GetSetupResult();

  00e04	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR SetupResult
  00e0a	33 db		 xor	 ebx, ebx
  00e0c	41 89 40 30	 mov	 DWORD PTR [r8+48], eax
  00e10	49 89 58 38	 mov	 QWORD PTR [r8+56], rbx

; 1423 : 		break;

  00e14	e9 3e 04 00 00	 jmp	 $LN144@ProcessMai
$LN25@ProcessMai:

; 1410 : 
; 1411 : 	case TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP:
; 1412 : 		Irp->IoStatus.Status = AbortBootEncryptionSetup();

  00e19	e8 00 00 00 00	 call	 AbortBootEncryptionSetup

; 1413 : 		Irp->IoStatus.Information = 0;
; 1414 : 		break;

  00e1e	e9 2b 04 00 00	 jmp	 $LN279@ProcessMai
$LN26@ProcessMai:

; 1405 : 
; 1406 : 	case TC_IOCTL_BOOT_ENCRYPTION_SETUP:
; 1407 : 		Irp->IoStatus.Status = StartBootEncryptionSetup (DeviceObject, Irp, irpSp);

  00e23	4d 8b c4	 mov	 r8, r12
  00e26	48 8b d6	 mov	 rdx, rsi
  00e29	49 8b ce	 mov	 rcx, r14
  00e2c	e8 00 00 00 00	 call	 StartBootEncryptionSetup

; 1408 : 		Irp->IoStatus.Information = 0;
; 1409 : 		break;

  00e31	e9 18 04 00 00	 jmp	 $LN279@ProcessMai
$LN109@ProcessMai:

; 975  : 
; 976  : 	case TC_IOCTL_GET_SYSTEM_DRIVE_CONFIG:
; 977  : 		{
; 978  : 			GetSystemDriveConfigurationRequest *request = (GetSystemDriveConfigurationRequest *) Irp->AssociatedIrp.SystemBuffer;

  00e36	4d 8b 60 18	 mov	 r12, QWORD PTR [r8+24]

; 979  : 			OBJECT_ATTRIBUTES ObjectAttributes;
; 980  : 			HANDLE NtFileHandle;
; 981  : 			UNICODE_STRING FullFileName;
; 982  : 			IO_STATUS_BLOCK IoStatus;
; 983  : 			LARGE_INTEGER offset;
; 984  : 			byte readBuffer [TC_SECTOR_SIZE_BIOS];
; 985  : 
; 986  : 			if (!ValidateIOBufferSize (Irp, sizeof (GetSystemDriveConfigurationRequest), ValidateInputOutput))

  00e3a	41 bf 29 02 00
	00		 mov	 r15d, 553		; 00000229H
  00e40	48 8b ce	 mov	 rcx, rsi
  00e43	49 8b d7	 mov	 rdx, r15
  00e46	41 b8 02 00 00
	00		 mov	 r8d, 2
  00e4c	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00e51	33 db		 xor	 ebx, ebx
  00e53	3b c3		 cmp	 eax, ebx
  00e55	0f 84 fc 03 00
	00		 je	 $LN144@ProcessMai

; 987  : 				break;
; 988  : 
; 989  : 			EnsureNullTerminatedString (request->DevicePath, sizeof (request->DevicePath));
; 990  : 			RtlInitUnicodeString (&FullFileName, request->DevicePath);

  00e5b	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR FullFileName$31816[rsp]
  00e63	49 8b d4	 mov	 rdx, r12
  00e66	66 41 89 9c 24
	06 02 00 00	 mov	 WORD PTR [r12+518], bx
  00e6f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 991  : 
; 992  : 			InitializeObjectAttributes (&ObjectAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);
; 993  : 
; 994  : 			ntStatus = ZwCreateFile (&NtFileHandle,
; 995  : 				SYNCHRONIZE | GENERIC_READ, &ObjectAttributes, &IoStatus, NULL,
; 996  : 				FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS, NULL, 0);

  00e75	89 5c 24 50	 mov	 DWORD PTR [rsp+80], ebx
  00e79	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00e7e	c7 44 24 40 20
	08 00 00	 mov	 DWORD PTR [rsp+64], 2080 ; 00000820H
  00e86	8d 6b 01	 lea	 ebp, QWORD PTR [rbx+1]
  00e89	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR FullFileName$31816[rsp]
  00e91	89 6c 24 38	 mov	 DWORD PTR [rsp+56], ebp
  00e95	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR [rsp+48], 3
  00e9d	44 8d 6d 7f	 lea	 r13d, QWORD PTR [rbp+127]
  00ea1	4c 8d 8c 24 30
	01 00 00	 lea	 r9, QWORD PTR IoStatus$31817[rsp]
  00ea9	4c 8d 84 24 b0
	00 00 00	 lea	 r8, QWORD PTR ObjectAttributes$31814[rsp]
  00eb1	48 8d 4c 24 70	 lea	 rcx, QWORD PTR NtFileHandle$31815[rsp]
  00eb6	ba 00 00 10 80	 mov	 edx, -2146435072	; 80100000H
  00ebb	44 89 6c 24 28	 mov	 DWORD PTR [rsp+40], r13d
  00ec0	c7 84 24 b0 00
	00 00 30 00 00
	00		 mov	 DWORD PTR ObjectAttributes$31814[rsp], 48 ; 00000030H
  00ecb	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00ed0	48 89 9c 24 b8
	00 00 00	 mov	 QWORD PTR ObjectAttributes$31814[rsp+8], rbx
  00ed8	c7 84 24 c8 00
	00 00 40 02 00
	00		 mov	 DWORD PTR ObjectAttributes$31814[rsp+24], 576 ; 00000240H
  00ee3	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR ObjectAttributes$31814[rsp+16], rax
  00eeb	48 89 9c 24 d0
	00 00 00	 mov	 QWORD PTR ObjectAttributes$31814[rsp+32], rbx
  00ef3	48 89 9c 24 d8
	00 00 00	 mov	 QWORD PTR ObjectAttributes$31814[rsp+40], rbx
  00efb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwCreateFile

; 997  : 
; 998  : 			if (NT_SUCCESS (ntStatus))

  00f01	3b c3		 cmp	 eax, ebx
  00f03	0f 8c 47 03 00
	00		 jl	 $LN275@ProcessMai

; 999  : 			{
; 1000 : 				// Determine if the first sector contains a portion of the TrueCrypt Boot Loader
; 1001 : 				offset.QuadPart = 0;	// MBR
; 1002 : 
; 1003 : 				ntStatus = ZwReadFile (NtFileHandle,
; 1004 : 					NULL,
; 1005 : 					NULL,
; 1006 : 					NULL,
; 1007 : 					&IoStatus,
; 1008 : 					readBuffer,
; 1009 : 					sizeof(readBuffer),
; 1010 : 					&offset,
; 1011 : 					NULL);

  00f09	48 8b 4c 24 70	 mov	 rcx, QWORD PTR NtFileHandle$31815[rsp]
  00f0e	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00f13	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR offset$31818[rsp]
  00f1b	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00f20	48 8d 84 24 e0
	01 00 00	 lea	 rax, QWORD PTR readBuffer$31819[rsp]
  00f28	c7 44 24 30 00
	02 00 00	 mov	 DWORD PTR [rsp+48], 512	; 00000200H
  00f30	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00f35	48 8d 84 24 30
	01 00 00	 lea	 rax, QWORD PTR IoStatus$31817[rsp]
  00f3d	45 33 c9	 xor	 r9d, r9d
  00f40	45 33 c0	 xor	 r8d, r8d
  00f43	33 d2		 xor	 edx, edx
  00f45	48 89 9c 24 88
	00 00 00	 mov	 QWORD PTR offset$31818[rsp], rbx
  00f4d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f52	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwReadFile

; 1012 : 
; 1013 : 				if (NT_SUCCESS (ntStatus))

  00f58	3b c3		 cmp	 eax, ebx
  00f5a	0f 8c 25 01 00
	00		 jl	 $LN106@ProcessMai

; 1014 : 				{
; 1015 : 					size_t i;
; 1016 : 
; 1017 : 					// Check for dynamic drive
; 1018 : 					request->DriveIsDynamic = FALSE;

  00f60	41 89 9c 24 09
	02 00 00	 mov	 DWORD PTR [r12+521], ebx

; 1019 : 
; 1020 : 					if (readBuffer[510] == 0x55 && readBuffer[511] == 0xaa)

  00f68	80 bc 24 de 03
	00 00 55	 cmp	 BYTE PTR readBuffer$31819[rsp+510], 85 ; 00000055H
  00f70	75 36		 jne	 SHORT $LN102@ProcessMai
  00f72	80 bc 24 df 03
	00 00 aa	 cmp	 BYTE PTR readBuffer$31819[rsp+511], 170 ; 000000aaH
  00f7a	75 2c		 jne	 SHORT $LN102@ProcessMai

; 1021 : 					{
; 1022 : 						int i;
; 1023 : 						for (i = 0; i < 4; ++i)

  00f7c	48 8b cb	 mov	 rcx, rbx
  00f7f	48 8d 84 24 a2
	03 00 00	 lea	 rax, QWORD PTR readBuffer$31819[rsp+450]
  00f87	8d 7b 04	 lea	 edi, QWORD PTR [rbx+4]
  00f8a	44 8d 6b 10	 lea	 r13d, QWORD PTR [rbx+16]
$LL104@ProcessMai:

; 1024 : 						{
; 1025 : 							if (readBuffer[446 + i * 16 + 4] == PARTITION_LDM)

  00f8e	80 38 42	 cmp	 BYTE PTR [rax], 66	; 00000042H
  00f91	74 0d		 je	 SHORT $LN253@ProcessMai
  00f93	48 03 cd	 add	 rcx, rbp
  00f96	49 03 c5	 add	 rax, r13
  00f99	48 3b cf	 cmp	 rcx, rdi
  00f9c	7c f0		 jl	 SHORT $LL104@ProcessMai

; 1040 : 					{
; 1041 : 						if (memcmp (readBuffer + i, TC_APP_NAME_LEGACY, strlen (TC_APP_NAME_LEGACY)) == 0)

  00f9e	eb 08		 jmp	 SHORT $LN102@ProcessMai
$LN253@ProcessMai:

; 1026 : 							{
; 1027 : 								request->DriveIsDynamic = TRUE;

  00fa0	41 89 ac 24 09
	02 00 00	 mov	 DWORD PTR [r12+521], ebp
$LN102@ProcessMai:

; 1028 : 								break;
; 1029 : 							}
; 1030 : 						}
; 1031 : 					}
; 1032 : 
; 1033 : 					request->BootLoaderVersion = 0;

  00fa8	66 41 89 9c 24
	0d 02 00 00	 mov	 WORD PTR [r12+525], bx

; 1034 : 					request->Configuration = 0;

  00fb1	41 88 9c 24 08
	02 00 00	 mov	 BYTE PTR [r12+520], bl

; 1035 : 					request->UserConfiguration = 0;

  00fb9	41 88 9c 24 0f
	02 00 00	 mov	 BYTE PTR [r12+527], bl

; 1036 : 					request->CustomUserMessage[0] = 0;

  00fc1	41 88 9c 24 10
	02 00 00	 mov	 BYTE PTR [r12+528], bl

; 1037 : 
; 1038 : 					// Search for the string "TrueCrypt"
; 1039 : 					for (i = 0; i < sizeof (readBuffer) - strlen (TC_APP_NAME_LEGACY); ++i)

  00fc9	48 8b cb	 mov	 rcx, rbx
  00fcc	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:__ImageBase
$LL100@ProcessMai:

; 1040 : 					{
; 1041 : 						if (memcmp (readBuffer + i, TC_APP_NAME_LEGACY, strlen (TC_APP_NAME_LEGACY)) == 0)

  00fd3	48 8d 84 0c e0
	01 00 00	 lea	 rax, QWORD PTR readBuffer$31819[rsp+rcx]
  00fdb	48 8b 38	 mov	 rdi, QWORD PTR [rax]
  00fde	49 3b be 00 00
	00 00		 cmp	 rdi, QWORD PTR ??_C@_09EMKKFGIH@TrueCrypt?$AA@FNODOBFM@[r14]
  00fe5	75 11		 jne	 SHORT $LN269@ProcessMai
  00fe7	40 8a 78 08	 mov	 dil, BYTE PTR [rax+8]
  00feb	41 3a be 08 00
	00 00		 cmp	 dil, BYTE PTR ??_C@_09EMKKFGIH@TrueCrypt?$AA@FNODOBFM@[r14+8]
  00ff2	75 04		 jne	 SHORT $LN269@ProcessMai
  00ff4	8b c3		 mov	 eax, ebx
  00ff6	eb 05		 jmp	 SHORT $LN270@ProcessMai
$LN269@ProcessMai:
  00ff8	1b c0		 sbb	 eax, eax
  00ffa	83 d8 ff	 sbb	 eax, -1
$LN270@ProcessMai:
  00ffd	3b c3		 cmp	 eax, ebx
  00fff	74 0e		 je	 SHORT $LN254@ProcessMai
  01001	48 03 cd	 add	 rcx, rbp
  01004	48 81 f9 f7 01
	00 00		 cmp	 rcx, 503		; 000001f7H
  0100b	72 c6		 jb	 SHORT $LL100@ProcessMai
  0100d	eb 6d		 jmp	 SHORT $LN96@ProcessMai
$LN254@ProcessMai:

; 1042 : 						{
; 1043 : 							request->BootLoaderVersion = BE16 (*(uint16 *) (readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET));

  0100f	0f b7 8c 24 8e
	03 00 00	 movzx	 ecx, WORD PTR readBuffer$31819[rsp+430]
  01017	66 c1 c1 08	 rol	 cx, 8
  0101b	66 41 89 8c 24
	0d 02 00 00	 mov	 WORD PTR [r12+525], cx

; 1044 : 							request->Configuration = readBuffer[TC_BOOT_SECTOR_CONFIG_OFFSET];

  01024	8a 84 24 97 03
	00 00		 mov	 al, BYTE PTR readBuffer$31819[rsp+439]
  0102b	41 88 84 24 08
	02 00 00	 mov	 BYTE PTR [r12+520], al

; 1045 : 
; 1046 : 							if (request->BootLoaderVersion != 0 && request->BootLoaderVersion <= VERSION_NUM)

  01033	66 3b cb	 cmp	 cx, bx
  01036	74 44		 je	 SHORT $LN96@ProcessMai
  01038	ba 30 07 00 00	 mov	 edx, 1840		; 00000730H
  0103d	66 3b ca	 cmp	 cx, dx
  01040	77 3a		 ja	 SHORT $LN96@ProcessMai

; 1047 : 							{
; 1048 : 								request->UserConfiguration = readBuffer[TC_BOOT_SECTOR_USER_CONFIG_OFFSET];

  01042	8a 84 24 96 03
	00 00		 mov	 al, BYTE PTR readBuffer$31819[rsp+438]

; 1049 : 								memcpy (request->CustomUserMessage, readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET, TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH);

  01049	48 8d 8c 24 76
	03 00 00	 lea	 rcx, QWORD PTR readBuffer$31819[rsp+406]
  01051	41 88 84 24 0f
	02 00 00	 mov	 BYTE PTR [r12+527], al
  01059	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0105c	49 89 84 24 10
	02 00 00	 mov	 QWORD PTR [r12+528], rax
  01064	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  01068	49 89 84 24 18
	02 00 00	 mov	 QWORD PTR [r12+536], rax
  01070	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  01074	49 89 84 24 20
	02 00 00	 mov	 QWORD PTR [r12+544], rax
$LN96@ProcessMai:

; 1050 : 							}
; 1051 : 							break;
; 1052 : 						}
; 1053 : 					}
; 1054 : 
; 1055 : 					Irp->IoStatus.Status = STATUS_SUCCESS;

  0107c	89 5e 30	 mov	 DWORD PTR [rsi+48], ebx

; 1056 : 					Irp->IoStatus.Information = sizeof (*request);

  0107f	4c 89 7e 38	 mov	 QWORD PTR [rsi+56], r15

; 1057 : 				}
; 1058 : 				else

  01083	eb 07		 jmp	 SHORT $LN95@ProcessMai
$LN106@ProcessMai:

; 1059 : 				{
; 1060 : 					Irp->IoStatus.Status = ntStatus;

  01085	89 46 30	 mov	 DWORD PTR [rsi+48], eax

; 1061 : 					Irp->IoStatus.Information = 0;

  01088	48 89 5e 38	 mov	 QWORD PTR [rsi+56], rbx
$LN95@ProcessMai:

; 1062 : 				}
; 1063 : 
; 1064 : 				ZwClose (NtFileHandle);

  0108c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR NtFileHandle$31815[rsp]
  01091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 1065 : 
; 1066 : 			}
; 1067 : 			else

  01097	e9 bb 01 00 00	 jmp	 $LN144@ProcessMai
$LN152@ProcessMai:

; 810  : 	NTSTATUS ntStatus;
; 811  : 
; 812  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  0109c	2d 78 20 22 00	 sub	 eax, 2236536		; 00222078H
  010a1	0f 84 99 01 00
	00		 je	 $LN16@ProcessMai
  010a7	bf 04 00 00 00	 mov	 edi, 4
  010ac	2b c7		 sub	 eax, edi
  010ae	0f 84 85 01 00
	00		 je	 $LN15@ProcessMai
  010b4	2b c7		 sub	 eax, edi
  010b6	0f 84 70 01 00
	00		 je	 $LN13@ProcessMai
  010bc	2b c7		 sub	 eax, edi
  010be	0f 84 59 01 00
	00		 je	 $LN14@ProcessMai
  010c4	2b c7		 sub	 eax, edi
  010c6	0f 84 02 01 00
	00		 je	 $LN12@ProcessMai
  010cc	2b c7		 sub	 eax, edi
  010ce	0f 84 b1 00 00
	00		 je	 $LN11@ProcessMai
  010d4	2b c7		 sub	 eax, edi
  010d6	0f 84 83 00 00
	00		 je	 $LN9@ProcessMai
  010dc	2b c7		 sub	 eax, edi
  010de	74 73		 je	 SHORT $LN6@ProcessMai
  010e0	3b c7		 cmp	 eax, edi
  010e2	74 14		 je	 SHORT $LN5@ProcessMai
$LN1@ProcessMai:

; 1519 : 			{
; 1520 : 				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
; 1521 : 				Irp->IoStatus.Information = 0;
; 1522 : 			}
; 1523 : 		}
; 1524 : 		break;
; 1525 : 
; 1526 : 	default:
; 1527 : 		return TCCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);

  010e4	bf 10 00 00 c0	 mov	 edi, -1073741808	; ffffffffc0000010H
  010e9	33 db		 xor	 ebx, ebx
  010eb	41 89 78 30	 mov	 DWORD PTR [r8+48], edi
  010ef	49 89 58 38	 mov	 QWORD PTR [r8+56], rbx
  010f3	e9 62 01 00 00	 jmp	 $LN268@ProcessMai
$LN5@ProcessMai:

; 1505 : 
; 1506 : 	case TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG:
; 1507 : 		if (ValidateIOBufferSize (Irp, sizeof (GetSystemDriveDumpConfigRequest), ValidateOutput))

  010f8	bf 0c 00 00 00	 mov	 edi, 12
  010fd	48 8b ce	 mov	 rcx, rsi
  01100	44 8d 47 f5	 lea	 r8d, QWORD PTR [rdi-11]
  01104	48 8b d7	 mov	 rdx, rdi
  01107	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0110c	33 db		 xor	 ebx, ebx
  0110e	3b c3		 cmp	 eax, ebx
  01110	0f 84 41 01 00
	00		 je	 $LN144@ProcessMai

; 1508 : 		{
; 1509 : 			GetSystemDriveDumpConfigRequest *request = (GetSystemDriveDumpConfigRequest *) Irp->AssociatedIrp.SystemBuffer;
; 1510 : 
; 1511 : 			request->BootDriveFilterExtension = GetBootDriveFilterExtension();

  01116	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  0111d	48 8b 4e 18	 mov	 rcx, QWORD PTR [rsi+24]
  01121	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1512 : 			if (IsBootDriveMounted() && request->BootDriveFilterExtension)

  01124	48 3b c3	 cmp	 rax, rbx
  01127	0f 84 9c f3 ff
	ff		 je	 $LN43@ProcessMai
  0112d	39 98 b8 02 00
	00		 cmp	 DWORD PTR [rax+696], ebx
  01133	0f 84 90 f3 ff
	ff		 je	 $LN43@ProcessMai

; 1513 : 			{
; 1514 : 				request->HwEncryptionEnabled = IsHwEncryptionEnabled();

  01139	39 1d 00 00 00
	00		 cmp	 DWORD PTR HwEncryptionDisabled, ebx
  0113f	8b c3		 mov	 eax, ebx
  01141	0f 94 c0	 sete	 al
  01144	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 1515 : 				Irp->IoStatus.Status = STATUS_SUCCESS;

  01147	89 5e 30	 mov	 DWORD PTR [rsi+48], ebx

; 1516 : 				Irp->IoStatus.Information = sizeof (*request);

  0114a	48 89 7e 38	 mov	 QWORD PTR [rsi+56], rdi

; 1517 : 			}
; 1518 : 			else

  0114e	e9 04 01 00 00	 jmp	 $LN144@ProcessMai
$LN6@ProcessMai:

; 1500 : 
; 1501 : 	case TC_IOCTL_REREAD_DRIVER_CONFIG:
; 1502 : 		Irp->IoStatus.Status = ReadRegistryConfigFlags (FALSE);

  01153	33 c9		 xor	 ecx, ecx
  01155	e8 00 00 00 00	 call	 ReadRegistryConfigFlags

; 1503 : 		Irp->IoStatus.Information = 0;
; 1504 : 		break;

  0115a	e9 ef 00 00 00	 jmp	 $LN279@ProcessMai
$LN9@ProcessMai:

; 1488 : 
; 1489 : 	case TC_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY:
; 1490 : 		if (UserCanAccessDriveDevice())

  0115f	e8 00 00 00 00	 call	 UserCanAccessDriveDevice
  01164	33 db		 xor	 ebx, ebx
  01166	3b c3		 cmp	 eax, ebx
  01168	74 0e		 je	 SHORT $LN8@ProcessMai

; 1491 : 		{
; 1492 : 			SystemFavoriteVolumeDirty = TRUE;

  0116a	8d 6b 01	 lea	 ebp, QWORD PTR [rbx+1]
  0116d	89 2d 00 00 00
	00		 mov	 DWORD PTR SystemFavoriteVolumeDirty, ebp

; 1493 : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 1494 : 		}
; 1495 : 		else

  01173	e9 32 fa ff ff	 jmp	 $LN289@ProcessMai
$LN8@ProcessMai:

; 1496 : 			Irp->IoStatus.Status = STATUS_ACCESS_DENIED;

  01178	b8 22 00 00 c0	 mov	 eax, -1073741790	; ffffffffc0000022H
  0117d	89 46 30	 mov	 DWORD PTR [rsi+48], eax

; 1497 : 
; 1498 : 		Irp->IoStatus.Information = 0;
; 1499 : 		break;

  01180	e9 28 fa ff ff	 jmp	 $LN7@ProcessMai
$LN11@ProcessMai:

; 1471 : 		Irp->IoStatus.Information = 0;
; 1472 : 		break;
; 1473 : 
; 1474 : 	case TC_IOCTL_GET_WARNING_FLAGS:
; 1475 : 		if (ValidateIOBufferSize (Irp, sizeof (GetWarningFlagsRequest), ValidateOutput))

  01185	ba 08 00 00 00	 mov	 edx, 8
  0118a	48 8b ce	 mov	 rcx, rsi
  0118d	44 8d 42 f9	 lea	 r8d, QWORD PTR [rdx-7]
  01191	e8 00 00 00 00	 call	 ValidateIOBufferSize
  01196	33 db		 xor	 ebx, ebx
  01198	3b c3		 cmp	 eax, ebx
  0119a	0f 84 b7 00 00
	00		 je	 $LN144@ProcessMai

; 1476 : 		{
; 1477 : 			GetWarningFlagsRequest *flags = (GetWarningFlagsRequest *) Irp->AssociatedIrp.SystemBuffer;
; 1478 : 
; 1479 : 			flags->PagingFileCreationPrevented = PagingFileCreationPrevented;

  011a0	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR PagingFileCreationPrevented
  011a6	48 8b 4e 18	 mov	 rcx, QWORD PTR [rsi+24]

; 1480 : 			PagingFileCreationPrevented = FALSE;

  011aa	89 1d 00 00 00
	00		 mov	 DWORD PTR PagingFileCreationPrevented, ebx
  011b0	89 01		 mov	 DWORD PTR [rcx], eax

; 1481 : 			flags->SystemFavoriteVolumeDirty = SystemFavoriteVolumeDirty;

  011b2	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR SystemFavoriteVolumeDirty

; 1482 : 			SystemFavoriteVolumeDirty = FALSE;

  011b8	89 1d 00 00 00
	00		 mov	 DWORD PTR SystemFavoriteVolumeDirty, ebx
  011be	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 1483 : 
; 1484 : 			Irp->IoStatus.Information = sizeof (GetWarningFlagsRequest);

  011c1	48 c7 46 38 08
	00 00 00	 mov	 QWORD PTR [rsi+56], 8

; 1485 : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 1486 : 		}
; 1487 : 		break;

  011c9	e9 6d f3 ff ff	 jmp	 $LN283@ProcessMai
$LN12@ProcessMai:

; 1468 : 
; 1469 : 	case TC_IOCTL_WRITE_BOOT_DRIVE_SECTOR:
; 1470 : 		Irp->IoStatus.Status = WriteBootDriveSector (Irp, irpSp);

  011ce	e8 00 00 00 00	 call	 UserCanAccessDriveDevice
  011d3	33 db		 xor	 ebx, ebx
  011d5	3b c3		 cmp	 eax, ebx
  011d7	0f 84 89 fb ff
	ff		 je	 $LN280@ProcessMai
  011dd	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR BootDriveFilterExtension
  011e4	48 3b d3	 cmp	 rdx, rbx
  011e7	0f 84 dc f2 ff
	ff		 je	 $LN43@ProcessMai
  011ed	41 81 7c 24 10
	08 02 00 00	 cmp	 DWORD PTR [r12+16], 520	; 00000208H
  011f6	0f 82 cd f2 ff
	ff		 jb	 $LN43@ProcessMai
  011fc	4c 8b 4e 18	 mov	 r9, QWORD PTR [rsi+24]
  01200	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  01204	8d 4b 01	 lea	 ecx, QWORD PTR [rbx+1]
  01207	4d 8d 41 08	 lea	 r8, QWORD PTR [r9+8]
  0120b	4d 8b 09	 mov	 r9, QWORD PTR [r9]
  0120e	c7 44 24 20 00
	02 00 00	 mov	 DWORD PTR [rsp+32], 512	; 00000200H
  01216	e8 00 00 00 00	 call	 TCReadWriteDevice
  0121b	eb 33		 jmp	 SHORT $LN275@ProcessMai
$LN14@ProcessMai:

; 1459 : 
; 1460 : 	case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT:
; 1461 : 		Irp->IoStatus.Status = GetDecoySystemWipeResult();

  0121d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR DecoySystemWipeResult
  01223	41 89 40 30	 mov	 DWORD PTR [r8+48], eax

; 1462 : 		Irp->IoStatus.Information = 0;
; 1463 : 		break;

  01227	e9 9e f9 ff ff	 jmp	 $LN285@ProcessMai
$LN13@ProcessMai:

; 1464 : 
; 1465 : 	case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS:
; 1466 : 		GetDecoySystemWipeStatus (Irp, irpSp);

  0122c	49 8b d4	 mov	 rdx, r12
  0122f	49 8b c8	 mov	 rcx, r8
  01232	e8 00 00 00 00	 call	 GetDecoySystemWipeStatus

; 1467 : 		break;

  01237	eb 1e		 jmp	 SHORT $LN144@ProcessMai
$LN15@ProcessMai:

; 1453 : 		break;
; 1454 : 
; 1455 : 	case TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE:
; 1456 : 		Irp->IoStatus.Status = AbortDecoySystemWipe();

  01239	e8 00 00 00 00	 call	 AbortDecoySystemWipe

; 1457 : 		Irp->IoStatus.Information = 0;
; 1458 : 		break;

  0123e	eb 0e		 jmp	 SHORT $LN279@ProcessMai
$LN16@ProcessMai:

; 1449 : 
; 1450 : 	case TC_IOCTL_START_DECOY_SYSTEM_WIPE:
; 1451 : 		Irp->IoStatus.Status = StartDecoySystemWipe (DeviceObject, Irp, irpSp);

  01240	4d 8b c4	 mov	 r8, r12
  01243	48 8b d6	 mov	 rdx, rsi
  01246	49 8b ce	 mov	 rcx, r14
  01249	e8 00 00 00 00	 call	 StartDecoySystemWipe
$LN279@ProcessMai:

; 1452 : 		Irp->IoStatus.Information = 0;

  0124e	33 db		 xor	 ebx, ebx
$LN275@ProcessMai:
  01250	48 89 5e 38	 mov	 QWORD PTR [rsi+56], rbx
$LN276@ProcessMai:

; 1449 : 
; 1450 : 	case TC_IOCTL_START_DECOY_SYSTEM_WIPE:
; 1451 : 		Irp->IoStatus.Status = StartDecoySystemWipe (DeviceObject, Irp, irpSp);

  01254	89 46 30	 mov	 DWORD PTR [rsi+48], eax
$LN144@ProcessMai:

; 1528 : 	}
; 1529 : 
; 1530 : 	
; 1531 : #ifdef DEBUG
; 1532 : 	if (!NT_SUCCESS (Irp->IoStatus.Status))
; 1533 : 	{
; 1534 : 		switch (irpSp->Parameters.DeviceIoControl.IoControlCode)
; 1535 : 		{
; 1536 : 		case TC_IOCTL_GET_MOUNTED_VOLUMES:
; 1537 : 		case TC_IOCTL_GET_PASSWORD_CACHE_STATUS:
; 1538 : 		case TC_IOCTL_GET_PORTABLE_MODE_STATUS:
; 1539 : 		case TC_IOCTL_SET_PORTABLE_MODE_STATUS:
; 1540 : 		case TC_IOCTL_OPEN_TEST:
; 1541 : 		case TC_IOCTL_GET_RESOLVED_SYMLINK:
; 1542 : 		case TC_IOCTL_GET_DRIVE_PARTITION_INFO:
; 1543 : 		case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:
; 1544 : 		case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS:
; 1545 : 		case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:
; 1546 : 			break;
; 1547 : 
; 1548 : 		default:
; 1549 : 			Dump ("IOCTL error 0x%08x\n", Irp->IoStatus.Status);
; 1550 : 		}
; 1551 : 	}
; 1552 : #endif
; 1553 : 
; 1554 : 	return TCCompleteIrp (Irp, Irp->IoStatus.Status, Irp->IoStatus.Information);

  01257	8b 7e 30	 mov	 edi, DWORD PTR [rsi+48]
$LN268@ProcessMai:

; 1519 : 			{
; 1520 : 				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
; 1521 : 				Irp->IoStatus.Information = 0;
; 1522 : 			}
; 1523 : 		}
; 1524 : 		break;
; 1525 : 
; 1526 : 	default:
; 1527 : 		return TCCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);

  0125a	33 d2		 xor	 edx, edx
  0125c	48 8b ce	 mov	 rcx, rsi
  0125f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest
  01265	8b c7		 mov	 eax, edi

; 1555 : }

  01267	48 8b 8c 24 e0
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0126f	48 33 cc	 xor	 rcx, rsp
  01272	e8 00 00 00 00	 call	 __security_check_cookie
  01277	48 8b 9c 24 38
	04 00 00	 mov	 rbx, QWORD PTR [rsp+1080]
  0127f	48 81 c4 f0 03
	00 00		 add	 rsp, 1008		; 000003f0H
  01286	41 5f		 pop	 r15
  01288	41 5e		 pop	 r14
  0128a	41 5d		 pop	 r13
  0128c	41 5c		 pop	 r12
  0128e	5f		 pop	 rdi
  0128f	5e		 pop	 rsi
  01290	5d		 pop	 rbp
  01291	c3		 ret	 0
ProcessMainDeviceControlIrp ENDP
PUBLIC	TCDispatchQueueIRP
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCDispatchQueueIRP DD imagerel $LN65
	DD	imagerel $LN65+742
	DD	imagerel $unwind$TCDispatchQueueIRP
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCDispatchQueueIRP DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT TCDispatchQueueIRP
_TEXT	SEGMENT
DeviceObject$ = 64
Irp$ = 72
TCDispatchQueueIRP PROC					; COMDAT

; 202  : {

$LN65:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 203  : 	PEXTENSION Extension = (PEXTENSION) DeviceObject->DeviceExtension;

  00014	48 8b 71 40	 mov	 rsi, QWORD PTR [rcx+64]

; 204  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);
; 205  : 	NTSTATUS ntStatus;
; 206  : 
; 207  : #ifdef _DEBUG
; 208  : 	if (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL && (Extension->bRootDevice || Extension->IsVolumeDevice))
; 209  : 	{
; 210  : 		switch (irpSp->Parameters.DeviceIoControl.IoControlCode)
; 211  : 		{
; 212  : 		case TC_IOCTL_GET_MOUNTED_VOLUMES:
; 213  : 		case TC_IOCTL_GET_PASSWORD_CACHE_STATUS:
; 214  : 		case TC_IOCTL_GET_PORTABLE_MODE_STATUS:
; 215  : 		case TC_IOCTL_SET_PORTABLE_MODE_STATUS:
; 216  : 		case TC_IOCTL_OPEN_TEST:
; 217  : 		case TC_IOCTL_GET_RESOLVED_SYMLINK:
; 218  : 		case TC_IOCTL_GET_DEVICE_REFCOUNT:
; 219  : 		case TC_IOCTL_GET_DRIVE_PARTITION_INFO:
; 220  : 		case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:
; 221  : 		case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS:
; 222  : 		case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS:
; 223  : 		case TC_IOCTL_GET_WARNING_FLAGS:
; 224  : 		case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:
; 225  : 		case IOCTL_DISK_CHECK_VERIFY:
; 226  : 			break;
; 227  : 
; 228  : 		default:
; 229  : 			Dump ("%ls (0x%x %d)\n",
; 230  : 				TCTranslateCode (irpSp->Parameters.DeviceIoControl.IoControlCode),
; 231  : 				(int) (irpSp->Parameters.DeviceIoControl.IoControlCode >> 16),
; 232  : 				(int) ((irpSp->Parameters.DeviceIoControl.IoControlCode & 0x1FFF) >> 2));
; 233  : 		}
; 234  : 	}
; 235  : #endif
; 236  : 
; 237  : 	if (!Extension->bRootDevice)

  00018	33 ed		 xor	 ebp, ebp
  0001a	48 8b da	 mov	 rbx, rdx
  0001d	44 8b 06	 mov	 r8d, DWORD PTR [rsi]
  00020	48 8b 92 b8 00
	00 00		 mov	 rdx, QWORD PTR [rdx+184]
  00027	48 8b f9	 mov	 rdi, rcx
  0002a	44 3b c5	 cmp	 r8d, ebp
  0002d	75 24		 jne	 SHORT $LN27@TCDispatch

; 238  : 	{
; 239  : 		// Drive filter IRP
; 240  : 		if (Extension->IsDriveFilterDevice)

  0002f	39 6e 08	 cmp	 DWORD PTR [rsi+8], ebp
  00032	74 0d		 je	 SHORT $LN28@TCDispatch

; 241  : 			return DriveFilterDispatchIrp (DeviceObject, Irp);

  00034	48 8b d3	 mov	 rdx, rbx
  00037	e8 00 00 00 00	 call	 DriveFilterDispatchIrp
  0003c	e9 90 02 00 00	 jmp	 $LN30@TCDispatch
$LN28@TCDispatch:

; 242  : 
; 243  : 		// Volume filter IRP
; 244  : 		if (Extension->IsVolumeFilterDevice)

  00041	39 6e 0c	 cmp	 DWORD PTR [rsi+12], ebp
  00044	74 0d		 je	 SHORT $LN27@TCDispatch

; 245  : 			return VolumeFilterDispatchIrp (DeviceObject, Irp);

  00046	48 8b d3	 mov	 rdx, rbx
  00049	e8 00 00 00 00	 call	 VolumeFilterDispatchIrp
  0004e	e9 7e 02 00 00	 jmp	 $LN30@TCDispatch
$LN27@TCDispatch:

; 246  : 	}
; 247  : 
; 248  : 	switch (irpSp->MajorFunction)

  00053	8a 0a		 mov	 cl, BYTE PTR [rdx]
  00055	8a c1		 mov	 al, cl
  00057	40 3a cd	 cmp	 cl, bpl
  0005a	0f 84 5d 02 00
	00		 je	 $LN24@TCDispatch
  00060	41 b1 02	 mov	 r9b, 2
  00063	41 3a c1	 cmp	 al, r9b
  00066	0f 84 51 02 00
	00		 je	 $LN24@TCDispatch
  0006c	0f 86 41 02 00
	00		 jbe	 $LN8@TCDispatch
  00072	41 b3 09	 mov	 r11b, 9
  00075	41 b2 0e	 mov	 r10b, 14
  00078	3c 04		 cmp	 al, 4
  0007a	0f 86 e7 00 00
	00		 jbe	 $LN15@TCDispatch
  00080	41 3a c3	 cmp	 al, r11b
  00083	0f 84 de 00 00
	00		 je	 $LN15@TCDispatch
  00089	41 3a c2	 cmp	 al, r10b
  0008c	0f 84 d5 00 00
	00		 je	 $LN15@TCDispatch
  00092	3c 10		 cmp	 al, 16
  00094	74 54		 je	 SHORT $LN23@TCDispatch
  00096	3c 12		 cmp	 al, 18
  00098	0f 84 1f 02 00
	00		 je	 $LN24@TCDispatch
  0009e	3c 1b		 cmp	 al, 27
  000a0	0f 85 0d 02 00
	00		 jne	 $LN8@TCDispatch

; 333  : 		}
; 334  : 
; 335  : 		break;
; 336  : 
; 337  : 	case IRP_MJ_PNP:
; 338  : 		if (!Extension->bRootDevice
; 339  : 			&& Extension->IsVolumeDevice
; 340  : 			&& irpSp->MinorFunction == IRP_MN_DEVICE_USAGE_NOTIFICATION
; 341  : 			&& irpSp->Parameters.UsageNotification.Type == DeviceUsageTypePaging
; 342  : 			&& irpSp->Parameters.UsageNotification.InPath)

  000a6	44 3b c5	 cmp	 r8d, ebp
  000a9	0f 85 04 02 00
	00		 jne	 $LN8@TCDispatch
  000af	39 6e 04	 cmp	 DWORD PTR [rsi+4], ebp
  000b2	0f 84 fb 01 00
	00		 je	 $LN8@TCDispatch
  000b8	80 7a 01 16	 cmp	 BYTE PTR [rdx+1], 22
  000bc	0f 85 f1 01 00
	00		 jne	 $LN8@TCDispatch
  000c2	83 7a 10 01	 cmp	 DWORD PTR [rdx+16], 1
  000c6	0f 85 e7 01 00
	00		 jne	 $LN8@TCDispatch
  000cc	40 38 6a 08	 cmp	 BYTE PTR [rdx+8], bpl
  000d0	0f 84 dd 01 00
	00		 je	 $LN8@TCDispatch

; 343  : 		{
; 344  : 			PagingFileCreationPrevented = TRUE;

  000d6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR PagingFileCreationPrevented, 1

; 345  : 			return TCCompleteIrp (Irp, STATUS_UNSUCCESSFUL, 0);

  000e0	bf 01 00 00 c0	 mov	 edi, -1073741823	; ffffffffc0000001H
  000e5	e9 dd 00 00 00	 jmp	 $LN61@TCDispatch
$LN23@TCDispatch:

; 254  : 
; 255  : 	case IRP_MJ_SHUTDOWN:
; 256  : 		if (Extension->bRootDevice)

  000ea	44 3b c5	 cmp	 r8d, ebp
  000ed	74 6e		 je	 SHORT $LN22@TCDispatch

; 257  : 		{
; 258  : 			Dump ("Driver shutting down\n");
; 259  : 			DriverShuttingDown = TRUE;

  000ef	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR DriverShuttingDown, 1

; 260  : 
; 261  : 			if (EncryptionSetupThread)

  000f9	bf 9a 00 00 c0	 mov	 edi, -1073741670	; ffffffffc000009aH
  000fe	48 39 2d 00 00
	00 00		 cmp	 QWORD PTR EncryptionSetupThread, rbp
  00105	74 24		 je	 SHORT $LN19@TCDispatch
$LL20@TCDispatch:

; 262  : 				while (SendDeviceIoControlRequest (RootDeviceObject, TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP, NULL, 0, NULL, 0) == STATUS_INSUFFICIENT_RESOURCES);

  00107	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR RootDeviceObject
  0010e	45 33 c9	 xor	 r9d, r9d
  00111	45 33 c0	 xor	 r8d, r8d
  00114	ba 50 20 22 00	 mov	 edx, 2236496		; 00222050H
  00119	89 6c 24 28	 mov	 DWORD PTR [rsp+40], ebp
  0011d	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  00122	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  00127	3b c7		 cmp	 eax, edi
  00129	74 dc		 je	 SHORT $LL20@TCDispatch
$LN19@TCDispatch:

; 263  : 
; 264  : 			if (DecoySystemWipeThread)

  0012b	48 39 2d 00 00
	00 00		 cmp	 QWORD PTR DecoySystemWipeThread, rbp
  00132	74 24		 je	 SHORT $LN16@TCDispatch
$LL17@TCDispatch:

; 265  : 				while (SendDeviceIoControlRequest (RootDeviceObject, TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE, NULL, 0, NULL, 0) == STATUS_INSUFFICIENT_RESOURCES);

  00134	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR RootDeviceObject
  0013b	45 33 c9	 xor	 r9d, r9d
  0013e	45 33 c0	 xor	 r8d, r8d
  00141	ba 7c 20 22 00	 mov	 edx, 2236540		; 0022207cH
  00146	89 6c 24 28	 mov	 DWORD PTR [rsp+40], ebp
  0014a	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0014f	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  00154	3b c7		 cmp	 eax, edi
  00156	74 dc		 je	 SHORT $LL17@TCDispatch
$LN16@TCDispatch:

; 266  : 
; 267  : 			OnShutdownPending();

  00158	e8 00 00 00 00	 call	 OnShutdownPending
$LN22@TCDispatch:

; 268  : 		}
; 269  : 
; 270  : 		return COMPLETE_IRP (DeviceObject, Irp, STATUS_SUCCESS, 0);

  0015d	89 6b 30	 mov	 DWORD PTR [rbx+48], ebp
  00160	8b fd		 mov	 edi, ebp
  00162	e9 d8 00 00 00	 jmp	 $LN60@TCDispatch
$LN15@TCDispatch:

; 271  : 
; 272  : 	case IRP_MJ_FLUSH_BUFFERS:
; 273  : 	case IRP_MJ_READ:
; 274  : 	case IRP_MJ_WRITE:
; 275  : 	case IRP_MJ_DEVICE_CONTROL:
; 276  : 
; 277  : 		if (Extension->bRootDevice)

  00167	44 3b c5	 cmp	 r8d, ebp
  0016a	74 51		 je	 SHORT $LN14@TCDispatch

; 278  : 		{
; 279  : 			if (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL)

  0016c	41 3a ca	 cmp	 cl, r10b
  0016f	0f 85 3e 01 00
	00		 jne	 $LN8@TCDispatch

; 280  : 			{
; 281  : 				NTSTATUS status = KeWaitForMutexObject (&RootDeviceControlMutex, Executive, KernelMode, FALSE, NULL);

  00175	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:RootDeviceControlMutex
  0017c	45 33 c9	 xor	 r9d, r9d
  0017f	45 33 c0	 xor	 r8d, r8d
  00182	33 d2		 xor	 edx, edx
  00184	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  00189	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 282  : 				if (!NT_SUCCESS (status))

  0018f	3b c5		 cmp	 eax, ebp

; 283  : 					return status;

  00191	0f 8c 3a 01 00
	00		 jl	 $LN30@TCDispatch

; 284  : 
; 285  : 				status = ProcessMainDeviceControlIrp (DeviceObject, Extension, Irp);

  00197	4c 8b c3	 mov	 r8, rbx
  0019a	48 8b d6	 mov	 rdx, rsi
  0019d	48 8b cf	 mov	 rcx, rdi
  001a0	e8 00 00 00 00	 call	 ProcessMainDeviceControlIrp

; 286  : 
; 287  : 				KeReleaseMutex (&RootDeviceControlMutex, FALSE);

  001a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:RootDeviceControlMutex
  001ac	33 d2		 xor	 edx, edx
  001ae	8b d8		 mov	 ebx, eax
  001b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseMutex

; 288  : 				return status;

  001b6	8b c3		 mov	 eax, ebx
  001b8	e9 14 01 00 00	 jmp	 $LN30@TCDispatch
$LN14@TCDispatch:

; 289  : 			}
; 290  : 			break;
; 291  : 		}
; 292  : 
; 293  : 		if (Extension->bShuttingDown)

  001bd	39 6e 18	 cmp	 DWORD PTR [rsi+24], ebp
  001c0	74 0a		 je	 SHORT $LN11@TCDispatch

; 294  : 		{
; 295  : 			Dump ("Device %d shutting down: STATUS_DELETE_PENDING\n", Extension->nDosDriveNo);
; 296  : 			return TCCompleteDiskIrp (Irp, STATUS_DELETE_PENDING, 0);

  001c2	bf 56 00 00 c0	 mov	 edi, -1073741738	; ffffffffc0000056H
$LN61@TCDispatch:
  001c7	89 7b 30	 mov	 DWORD PTR [rbx+48], edi
  001ca	eb 73		 jmp	 SHORT $LN60@TCDispatch
$LN11@TCDispatch:

; 297  : 		}
; 298  : 
; 299  : 		if (Extension->bRemovable
; 300  : 			&& (DeviceObject->Flags & DO_VERIFY_VOLUME)
; 301  : 			&& !(irpSp->Flags & SL_OVERRIDE_VERIFY_VOLUME)
; 302  : 			&& irpSp->MajorFunction != IRP_MJ_FLUSH_BUFFERS)

  001cc	39 ae 44 03 00
	00		 cmp	 DWORD PTR [rsi+836], ebp
  001d2	74 18		 je	 SHORT $LN10@TCDispatch
  001d4	44 84 4f 30	 test	 BYTE PTR [rdi+48], r9b
  001d8	74 12		 je	 SHORT $LN10@TCDispatch
  001da	44 84 4a 02	 test	 BYTE PTR [rdx+2], r9b
  001de	75 0c		 jne	 SHORT $LN10@TCDispatch
  001e0	41 3a cb	 cmp	 cl, r11b
  001e3	74 07		 je	 SHORT $LN10@TCDispatch

; 303  : 		{
; 304  : 			Dump ("Removable device %d has DO_VERIFY_VOLUME flag: STATUS_DEVICE_NOT_READY\n", Extension->nDosDriveNo);
; 305  : 			return TCCompleteDiskIrp (Irp, STATUS_DEVICE_NOT_READY, 0);

  001e5	bf a3 00 00 c0	 mov	 edi, -1073741661	; ffffffffc00000a3H
  001ea	eb db		 jmp	 SHORT $LN61@TCDispatch
$LN10@TCDispatch:

; 306  : 		}
; 307  : 
; 308  : 		switch (irpSp->MajorFunction)

  001ec	8a c1		 mov	 al, cl
  001ee	80 f9 03	 cmp	 cl, 3
  001f1	0f 82 bc 00 00
	00		 jb	 $LN8@TCDispatch
  001f7	3c 04		 cmp	 al, 4
  001f9	0f 86 92 00 00
	00		 jbe	 $LN7@TCDispatch
  001ff	41 3a c3	 cmp	 al, r11b
  00202	0f 84 85 00 00
	00		 je	 $LN3@TCDispatch
  00208	41 3a c2	 cmp	 al, r10b
  0020b	0f 85 a2 00 00
	00		 jne	 $LN8@TCDispatch

; 318  : 
; 319  : 		case IRP_MJ_DEVICE_CONTROL:
; 320  : 			ntStatus = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00211	48 8d 8e 80 01
	00 00		 lea	 rcx, QWORD PTR [rsi+384]
  00218	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@FNODOBFM@
  0021f	41 b9 01 00 00
	00		 mov	 r9d, 1
  00225	48 8b d3	 mov	 rdx, rbx
  00228	c7 44 24 20 20
	00 00 00	 mov	 DWORD PTR [rsp+32], 32	; 00000020H
  00230	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAcquireRemoveLockEx

; 321  : 			if (!NT_SUCCESS (ntStatus))

  00236	3b c5		 cmp	 eax, ebp
  00238	8b f8		 mov	 edi, eax
  0023a	7d 16		 jge	 SHORT $LN4@TCDispatch

; 322  : 				return TCCompleteIrp (Irp, ntStatus, 0);

  0023c	89 43 30	 mov	 DWORD PTR [rbx+48], eax
$LN60@TCDispatch:

; 268  : 		}
; 269  : 
; 270  : 		return COMPLETE_IRP (DeviceObject, Irp, STATUS_SUCCESS, 0);

  0023f	33 d2		 xor	 edx, edx
$LN64@TCDispatch:
  00241	48 8b cb	 mov	 rcx, rbx
  00244	48 89 6b 38	 mov	 QWORD PTR [rbx+56], rbp
  00248	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 315  : 				TCCompleteDiskIrp (Irp, ntStatus, 0);

$LN44@TCDispatch:

; 268  : 		}
; 269  : 
; 270  : 		return COMPLETE_IRP (DeviceObject, Irp, STATUS_SUCCESS, 0);

  0024e	8b c7		 mov	 eax, edi
  00250	eb 7f		 jmp	 SHORT $LN30@TCDispatch
$LN4@TCDispatch:

; 323  : 
; 324  : 			IoMarkIrpPending (Irp);

  00252	48 8b 83 b8 00
	00 00		 mov	 rax, QWORD PTR [rbx+184]

; 325  : 			
; 326  : 			ExInterlockedInsertTailList (&Extension->ListEntry, &Irp->Tail.Overlay.ListEntry, &Extension->ListSpinLock);

  00259	4c 8d 46 40	 lea	 r8, QWORD PTR [rsi+64]
  0025d	48 8d 93 a8 00
	00 00		 lea	 rdx, QWORD PTR [rbx+168]
  00264	80 48 03 01	 or	 BYTE PTR [rax+3], 1
  00268	48 8d 4e 48	 lea	 rcx, QWORD PTR [rsi+72]
  0026c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExInterlockedInsertTailList

; 327  : 			KeReleaseSemaphore (&Extension->RequestSemaphore, IO_DISK_INCREMENT, 1, FALSE);

  00272	45 33 c9	 xor	 r9d, r9d
  00275	48 8d 4e 58	 lea	 rcx, QWORD PTR [rsi+88]
  00279	41 8d 51 01	 lea	 edx, QWORD PTR [r9+1]
  0027d	44 8b c2	 mov	 r8d, edx
  00280	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseSemaphore

; 328  : 			
; 329  : 			return STATUS_PENDING;

  00286	b8 03 01 00 00	 mov	 eax, 259		; 00000103H
  0028b	eb 44		 jmp	 SHORT $LN30@TCDispatch
$LN3@TCDispatch:

; 330  : 
; 331  : 		case IRP_MJ_FLUSH_BUFFERS:
; 332  : 			return TCCompleteDiskIrp (Irp, STATUS_SUCCESS, 0);

  0028d	b2 01		 mov	 dl, 1
  0028f	eb 2e		 jmp	 SHORT $LN62@TCDispatch
$LN7@TCDispatch:

; 309  : 		{
; 310  : 		case IRP_MJ_READ:
; 311  : 		case IRP_MJ_WRITE:
; 312  : 			ntStatus = EncryptedIoQueueAddIrp (&Extension->Queue, Irp);

  00291	48 8d 8e e0 00
	00 00		 lea	 rcx, QWORD PTR [rsi+224]
  00298	48 8b d3	 mov	 rdx, rbx
  0029b	e8 00 00 00 00	 call	 EncryptedIoQueueAddIrp
  002a0	8b f8		 mov	 edi, eax

; 313  : 
; 314  : 			if (ntStatus != STATUS_PENDING)

  002a2	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  002a7	74 a5		 je	 SHORT $LN44@TCDispatch

; 315  : 				TCCompleteDiskIrp (Irp, ntStatus, 0);

  002a9	3b c5		 cmp	 eax, ebp
  002ab	89 43 30	 mov	 DWORD PTR [rbx+48], eax
  002ae	0f 9d c2	 setge	 dl

; 316  : 
; 317  : 			return ntStatus;

  002b1	eb 8e		 jmp	 SHORT $LN64@TCDispatch
$LN8@TCDispatch:

; 346  : 		}
; 347  : 		break;
; 348  : 	}
; 349  : 
; 350  : 	return TCCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);

  002b3	bf 10 00 00 c0	 mov	 edi, -1073741808	; ffffffffc0000010H
  002b8	e9 0a ff ff ff	 jmp	 $LN61@TCDispatch
$LN24@TCDispatch:

; 249  : 	{
; 250  : 	case IRP_MJ_CLOSE:
; 251  : 	case IRP_MJ_CREATE:
; 252  : 	case IRP_MJ_CLEANUP:
; 253  : 		return COMPLETE_IRP (DeviceObject, Irp, STATUS_SUCCESS, 0);

  002bd	33 d2		 xor	 edx, edx
$LN62@TCDispatch:
  002bf	48 8b cb	 mov	 rcx, rbx
  002c2	89 6b 30	 mov	 DWORD PTR [rbx+48], ebp
  002c5	48 89 6b 38	 mov	 QWORD PTR [rbx+56], rbp
  002c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest
  002cf	33 c0		 xor	 eax, eax
$LN30@TCDispatch:

; 351  : }

  002d1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  002d6	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  002db	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  002e0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  002e4	5f		 pop	 rdi
  002e5	c3		 ret	 0
TCDispatchQueueIRP ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	DriverEntry
;	COMDAT pdata
pdata	SEGMENT
$pdata$DriverEntry DD imagerel $LN21
	DD	imagerel $LN21+636
	DD	imagerel $unwind$DriverEntry
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DriverEntry DD 072219H
	DD	0263410H
	DD	0200110H
	DD	07007d009H
	DD	06006H
	DD	imagerel __GSHandlerCheck
	DD	0f0H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT DriverEntry
INIT	SEGMENT
DeviceObject$55531 = 64
startKeyValue$ = 64
version$ = 72
ntUnicodeString$55528 = 80
Win32NameString$55527 = 96
ntname$55530 = 112
dosname$55529 = 176
__$ArrayPad$ = 240
DriverObject$ = 288
RegistryPath$ = 296
DriverEntry PROC					; COMDAT

; 63   : {

$LN21:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 55		 push	 r13
  00009	48 81 ec 00 01
	00 00		 sub	 rsp, 256		; 00000100H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00022	48 8b fa	 mov	 rdi, rdx
  00025	48 8b d9	 mov	 rbx, rcx

; 64   : 	PKEY_VALUE_PARTIAL_INFORMATION startKeyValue;
; 65   : 	LONG version;
; 66   : 	int i;
; 67   : 
; 68   : 	Dump ("DriverEntry " TC_APP_NAME " " VERSION_STRING "\n");
; 69   : 
; 70   : 	PsGetVersion (&OsMajorVersion, &OsMinorVersion, NULL, NULL);

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:OsMinorVersion
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:OsMajorVersion
  00036	45 33 c9	 xor	 r9d, r9d
  00039	45 33 c0	 xor	 r8d, r8d
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsGetVersion

; 71   : 
; 72   : 	// Load dump filter if the main driver is already loaded
; 73   : 	if (NT_SUCCESS (TCDeviceIoControl (NT_ROOT_PREFIX, TC_IOCTL_GET_DRIVER_VERSION, NULL, 0, &version, sizeof (version))))

  00042	48 8d 44 24 48	 lea	 rax, QWORD PTR version$[rsp]
  00047	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@
  0004e	49 8b cd	 mov	 rcx, r13
  00051	45 33 c9	 xor	 r9d, r9d
  00054	45 33 c0	 xor	 r8d, r8d
  00057	ba 04 20 22 00	 mov	 edx, 2236420		; 00222004H
  0005c	c7 44 24 28 04
	00 00 00	 mov	 DWORD PTR [rsp+40], 4
  00064	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00069	e8 00 00 00 00	 call	 TCDeviceIoControl
  0006e	33 f6		 xor	 esi, esi
  00070	3b c6		 cmp	 eax, esi
  00072	7c 10		 jl	 SHORT $LN7@DriverEntr

; 74   : 		return DumpFilterEntry ((PFILTER_EXTENSION) DriverObject, (PFILTER_INITIALIZATION_DATA) RegistryPath);

  00074	48 8b d7	 mov	 rdx, rdi
  00077	48 8b cb	 mov	 rcx, rbx
  0007a	e8 00 00 00 00	 call	 DumpFilterEntry
  0007f	e9 d4 01 00 00	 jmp	 $LN8@DriverEntr
$LN7@DriverEntr:

; 75   : 
; 76   : 	TCDriverObject = DriverObject;
; 77   : 	memset (VirtualVolumeDeviceObjects, 0, sizeof (VirtualVolumeDeviceObjects));

  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:VirtualVolumeDeviceObjects
  0008b	33 d2		 xor	 edx, edx
  0008d	41 b8 d0 00 00
	00		 mov	 r8d, 208		; 000000d0H
  00093	48 89 1d 00 00
	00 00		 mov	 QWORD PTR TCDriverObject, rbx
  0009a	e8 00 00 00 00	 call	 memset

; 78   : 
; 79   : 	ReadRegistryConfigFlags (TRUE);

  0009f	b9 01 00 00 00	 mov	 ecx, 1
  000a4	e8 00 00 00 00	 call	 ReadRegistryConfigFlags

; 80   : 	EncryptionThreadPoolStart (EncryptionThreadPoolFreeCpuCountLimit);

  000a9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR EncryptionThreadPoolFreeCpuCountLimit
  000b0	e8 00 00 00 00	 call	 EncryptionThreadPoolStart

; 81   : 	SelfTestsPassed = AutoTestAlgorithms();

  000b5	e8 00 00 00 00	 call	 AutoTestAlgorithms

; 82   : 
; 83   : 	// Enable device class filters and load boot arguments if the driver is set to start at system boot
; 84   : 		
; 85   : 	if (NT_SUCCESS (TCReadRegistryKey (RegistryPath, L"Start", &startKeyValue)))

  000ba	4c 8d 44 24 40	 lea	 r8, QWORD PTR startKeyValue$[rsp]
  000bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1M@IOJLKPKK@?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@PBOPGDP@
  000c6	48 8b cf	 mov	 rcx, rdi
  000c9	89 05 00 00 00
	00		 mov	 DWORD PTR SelfTestsPassed, eax
  000cf	e8 00 00 00 00	 call	 TCReadRegistryKey
  000d4	3b c6		 cmp	 eax, esi
  000d6	7c 66		 jl	 SHORT $LN6@DriverEntr

; 86   : 	{
; 87   : 		if (startKeyValue->Type == REG_DWORD && *((uint32 *) startKeyValue->Data) == SERVICE_BOOT_START)

  000d8	48 8b 7c 24 40	 mov	 rdi, QWORD PTR startKeyValue$[rsp]
  000dd	83 7f 04 04	 cmp	 DWORD PTR [rdi+4], 4
  000e1	75 4d		 jne	 SHORT $LN5@DriverEntr
  000e3	39 77 0c	 cmp	 DWORD PTR [rdi+12], esi
  000e6	75 48		 jne	 SHORT $LN5@DriverEntr

; 88   : 		{
; 89   : 			if (!SelfTestsPassed)

  000e8	39 35 00 00 00
	00		 cmp	 DWORD PTR SelfTestsPassed, esi
  000ee	75 21		 jne	 SHORT $LN4@DriverEntr

; 90   : 				TC_BUG_CHECK (STATUS_INVALID_PARAMETER);

  000f0	45 33 c9	 xor	 r9d, r9d
  000f3	49 c7 c0 0d 00
	00 c0		 mov	 r8, -1073741811		; ffffffffc000000dH
  000fa	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00103	41 8d 51 5a	 lea	 edx, QWORD PTR [r9+90]
  00107	8d 4a cf	 lea	 ecx, QWORD PTR [rdx-49]
  0010a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00110	cc		 int	 3
$LN4@DriverEntr:

; 91   : 
; 92   : 			LoadBootArguments();

  00111	e8 00 00 00 00	 call	 LoadBootArguments

; 93   : 			VolumeClassFilterRegistered = IsVolumeClassFilterRegistered();

  00116	e8 00 00 00 00	 call	 IsVolumeClassFilterRegistered

; 94   : 
; 95   : 			DriverObject->DriverExtension->AddDevice = DriverAddDevice;

  0011b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:DriverAddDevice
  00122	89 05 00 00 00
	00		 mov	 DWORD PTR VolumeClassFilterRegistered, eax
  00128	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0012c	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
$LN5@DriverEntr:

; 96   : 		}
; 97   : 
; 98   : 		TCfree (startKeyValue);

  00130	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00135	48 8b cf	 mov	 rcx, rdi
  00138	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN6@DriverEntr:

; 99   : 	}
; 100  : 
; 101  : 	for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; ++i)
; 102  : 	{
; 103  : 		DriverObject->MajorFunction[i] = TCDispatchQueueIRP;

  0013e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:TCDispatchQueueIRP
  00145	48 8d 7b 70	 lea	 rdi, QWORD PTR [rbx+112]
  00149	b9 1c 00 00 00	 mov	 ecx, 28
  0014e	f3 48 ab	 rep stosq

; 104  : 	}
; 105  : 
; 106  : 	DriverObject->DriverUnload = TCUnloadDriver;

  00151	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:TCUnloadDriver

; 107  : 	return TCCreateRootDeviceObject (DriverObject);

  00158	48 8b ce	 mov	 rcx, rsi
  0015b	48 89 43 68	 mov	 QWORD PTR [rbx+104], rax
$LL14@DriverEntr:
  0015f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@
  00166	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  0016a	48 83 c1 02	 add	 rcx, 2
  0016e	66 89 84 0c ae
	00 00 00	 mov	 WORD PTR dosname$55529[rsp+rcx-2], ax
  00176	66 3b c6	 cmp	 ax, si
  00179	75 e4		 jne	 SHORT $LL14@DriverEntr
  0017b	48 8b ce	 mov	 rcx, rsi
$LL15@DriverEntr:
  0017e	42 0f b7 04 29	 movzx	 eax, WORD PTR [rcx+r13]
  00183	48 83 c1 02	 add	 rcx, 2
  00187	66 89 44 0c 6e	 mov	 WORD PTR ntname$55530[rsp+rcx-2], ax
  0018c	66 3b c6	 cmp	 ax, si
  0018f	75 ed		 jne	 SHORT $LL15@DriverEntr
  00191	48 8d 54 24 70	 lea	 rdx, QWORD PTR ntname$55530[rsp]
  00196	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ntUnicodeString$55528[rsp]
  0019b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString
  001a1	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR dosname$55529[rsp]
  001a9	48 8d 4c 24 60	 lea	 rcx, QWORD PTR Win32NameString$55527[rsp]
  001ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString
  001b4	48 8d 4c 24 40	 lea	 rcx, QWORD PTR DeviceObject$55531[rsp]
  001b9	41 b9 22 00 00
	00		 mov	 r9d, 34			; 00000022H
  001bf	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001c4	41 8d 51 e2	 lea	 edx, QWORD PTR [r9-30]
  001c8	4c 8d 44 24 50	 lea	 r8, QWORD PTR ntUnicodeString$55528[rsp]
  001cd	48 8b cb	 mov	 rcx, rbx
  001d0	40 88 74 24 28	 mov	 BYTE PTR [rsp+40], sil
  001d5	c7 44 24 20 00
	01 00 00	 mov	 DWORD PTR [rsp+32], 256	; 00000100H
  001dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateDevice
  001e3	3b c6		 cmp	 eax, esi
  001e5	8b f8		 mov	 edi, eax
  001e7	7c 6d		 jl	 SHORT $LN12@DriverEntr
  001e9	48 8b 44 24 40	 mov	 rax, QWORD PTR DeviceObject$55531[rsp]
  001ee	33 d2		 xor	 edx, edx
  001f0	83 48 30 10	 or	 DWORD PTR [rax+48], 16
  001f4	48 8b 44 24 40	 mov	 rax, QWORD PTR DeviceObject$55531[rsp]
  001f9	c7 80 98 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+152], 1
  00203	48 8b 44 24 40	 mov	 rax, QWORD PTR DeviceObject$55531[rsp]
  00208	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  0020c	c7 01 01 00 00
	00		 mov	 DWORD PTR [rcx], 1
  00212	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:RootDeviceControlMutex
  00219	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeMutex
  0021f	48 8d 54 24 50	 lea	 rdx, QWORD PTR ntUnicodeString$55528[rsp]
  00224	48 8d 4c 24 60	 lea	 rcx, QWORD PTR Win32NameString$55527[rsp]
  00229	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateSymbolicLink
  0022f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR DeviceObject$55531[rsp]
  00234	3b c6		 cmp	 eax, esi
  00236	8b f8		 mov	 edi, eax
  00238	7d 08		 jge	 SHORT $LN10@DriverEntr
  0023a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteDevice
  00240	eb 14		 jmp	 SHORT $LN12@DriverEntr
$LN10@DriverEntr:
  00242	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoRegisterShutdownNotification
  00248	48 8b 54 24 40	 mov	 rdx, QWORD PTR DeviceObject$55531[rsp]
  0024d	8b fe		 mov	 edi, esi
  0024f	48 89 15 00 00
	00 00		 mov	 QWORD PTR RootDeviceObject, rdx
$LN12@DriverEntr:
  00256	8b c7		 mov	 eax, edi
$LN8@DriverEntr:

; 108  : }

  00258	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00260	48 33 cc	 xor	 rcx, rsp
  00263	e8 00 00 00 00	 call	 __security_check_cookie
  00268	48 8b 9c 24 30
	01 00 00	 mov	 rbx, QWORD PTR [rsp+304]
  00270	48 81 c4 00 01
	00 00		 add	 rsp, 256		; 00000100H
  00277	41 5d		 pop	 r13
  00279	5f		 pop	 rdi
  0027a	5e		 pop	 rsi
  0027b	c3		 ret	 0
$LN20@DriverEntr:
DriverEntry ENDP
INIT	ENDS
END
