; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\home\public\Desktop\projects\ciphershed.build\src\Setup\Setup.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@KMEHMKJJ@truecrypt?9x64?4sys?$AA@	; `string'
PUBLIC	??_C@_0O@OJENBJKN@truecrypt?4sys?$AA@		; `string'
PUBLIC	??_C@_0BG@NHCNJMON@CipherShed?5Format?4exe?$AA@	; `string'
PUBLIC	??_C@_0P@KEOPEMDF@CipherShed?4exe?$AA@		; `string'
PUBLIC	??_C@_0M@HNDLNFKG@License?4txt?$AA@		; `string'
PUBLIC	??_C@_0BK@LMECBCPP@CipherShed?5User?5Guide?4pdf?$AA@ ; `string'
PUBLIC	??_C@_0BG@DJBAHGBG@ACipherShed?9Setup?4exe?$AA@	; `string'
PUBLIC	??_C@_0P@KPKCHNJD@Dtruecrypt?4sys?$AA@		; `string'
PUBLIC	??_C@_0BD@ILLOKAML@Atruecrypt?9x64?4sys?$AA@	; `string'
PUBLIC	??_C@_0P@JMCFMDBI@Atruecrypt?4sys?$AA@		; `string'
PUBLIC	??_C@_0BH@JDBNPKKN@ACipherShed?5Format?4exe?$AA@ ; `string'
PUBLIC	??_C@_0BA@BPJBGDOM@ACipherShed?4exe?$AA@	; `string'
PUBLIC	??_C@_0N@GJIBBNGF@ALicense?4txt?$AA@		; `string'
PUBLIC	??_C@_0BL@MFPLEOCK@ACipherShed?5User?5Guide?4pdf?$AA@ ; `string'
PUBLIC	??_C@_0P@GHFPNOJB@bad?5allocation?$AA@		; `string'
PUBLIC	_SetupFilesDir
PUBLIC	_InstallationPath
PUBLIC	?UninstallBatch@@3PADA				; UninstallBatch
PUBLIC	?UninstallationPath@@3PADA			; UninstallationPath
PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
PUBLIC	?RescueIsoImageSize@BootEncryption@CipherShed@@1IB ; CipherShed::BootEncryption::RescueIsoImageSize
PUBLIC	?InstalledVersion@@3JA				; InstalledVersion
PUBLIC	?bUninstall@@3HA				; bUninstall
PUBLIC	_bRestartRequired
PUBLIC	?bMakePackage@@3HA				; bMakePackage
PUBLIC	?bDone@@3HA					; bDone
PUBLIC	_Rollback
PUBLIC	_bCipherShedMigration
PUBLIC	_bUpgrade
PUBLIC	?bDowngrade@@3HA				; bDowngrade
PUBLIC	_SystemEncryptionUpdate
PUBLIC	?PortableMode@@3HA				; PortableMode
PUBLIC	_bRepairMode
PUBLIC	?bChangeMode@@3HA				; bChangeMode
PUBLIC	_bDevm
PUBLIC	_bPossiblyFirstTimeInstall
PUBLIC	?bUninstallInProgress@@3HA			; bUninstallInProgress
PUBLIC	?UnloadDriver@@3HA				; UnloadDriver
PUBLIC	_bSystemRestore
PUBLIC	_bDisableSwapFiles
PUBLIC	_bForAllUsers
PUBLIC	_bRegisterFileExt
PUBLIC	_bAddToStartMenu
PUBLIC	_bDesktopIcon
PUBLIC	_bDesktopIconStatusDetermined
PUBLIC	_SystemRestoreDll
PUBLIC	?quiet@@3HA					; quiet
_BSS	SEGMENT
_SetupFilesDir DB 0104H DUP (?)
_InstallationPath DB 0104H DUP (?)
?UninstallBatch@@3PADA DB 0104H DUP (?)			; UninstallBatch
?UninstallationPath@@3PADA DB 0104H DUP (?)		; UninstallationPath
?InstalledVersion@@3JA DD 01H DUP (?)			; InstalledVersion
?bUninstall@@3HA DD 01H DUP (?)				; bUninstall
_bRestartRequired DD 01H DUP (?)
?bMakePackage@@3HA DD 01H DUP (?)			; bMakePackage
?bDone@@3HA DD	01H DUP (?)				; bDone
_Rollback DD	01H DUP (?)
_bCipherShedMigration DD 01H DUP (?)
_bUpgrade DD	01H DUP (?)
?bDowngrade@@3HA DD 01H DUP (?)				; bDowngrade
_SystemEncryptionUpdate DD 01H DUP (?)
?PortableMode@@3HA DD 01H DUP (?)			; PortableMode
_bRepairMode DD	01H DUP (?)
?bChangeMode@@3HA DD 01H DUP (?)			; bChangeMode
_bDevm	DD	01H DUP (?)
_bPossiblyFirstTimeInstall DD 01H DUP (?)
?bUninstallInProgress@@3HA DD 01H DUP (?)		; bUninstallInProgress
_bDisableSwapFiles DD 01H DUP (?)
_bDesktopIconStatusDetermined DD 01H DUP (?)
_SystemRestoreDll DD 01H DUP (?)
?quiet@@3HA DD	01H DUP (?)				; quiet
_BSS	ENDS
;	COMDAT ??_C@_0BC@KMEHMKJJ@truecrypt?9x64?4sys?$AA@
CONST	SEGMENT
??_C@_0BC@KMEHMKJJ@truecrypt?9x64?4sys?$AA@ DB 'truecrypt-x64.sys', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OJENBJKN@truecrypt?4sys?$AA@
CONST	SEGMENT
??_C@_0O@OJENBJKN@truecrypt?4sys?$AA@ DB 'truecrypt.sys', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NHCNJMON@CipherShed?5Format?4exe?$AA@
CONST	SEGMENT
??_C@_0BG@NHCNJMON@CipherShed?5Format?4exe?$AA@ DB 'CipherShed Format.exe'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KEOPEMDF@CipherShed?4exe?$AA@
CONST	SEGMENT
??_C@_0P@KEOPEMDF@CipherShed?4exe?$AA@ DB 'CipherShed.exe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HNDLNFKG@License?4txt?$AA@
CONST	SEGMENT
??_C@_0M@HNDLNFKG@License?4txt?$AA@ DB 'License.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LMECBCPP@CipherShed?5User?5Guide?4pdf?$AA@
CONST	SEGMENT
??_C@_0BK@LMECBCPP@CipherShed?5User?5Guide?4pdf?$AA@ DB 'CipherShed User '
	DB	'Guide.pdf', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DJBAHGBG@ACipherShed?9Setup?4exe?$AA@
CONST	SEGMENT
??_C@_0BG@DJBAHGBG@ACipherShed?9Setup?4exe?$AA@ DB 'ACipherShed-Setup.exe'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KPKCHNJD@Dtruecrypt?4sys?$AA@
CONST	SEGMENT
??_C@_0P@KPKCHNJD@Dtruecrypt?4sys?$AA@ DB 'Dtruecrypt.sys', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@ILLOKAML@Atruecrypt?9x64?4sys?$AA@
CONST	SEGMENT
??_C@_0BD@ILLOKAML@Atruecrypt?9x64?4sys?$AA@ DB 'Atruecrypt-x64.sys', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JMCFMDBI@Atruecrypt?4sys?$AA@
CONST	SEGMENT
??_C@_0P@JMCFMDBI@Atruecrypt?4sys?$AA@ DB 'Atruecrypt.sys', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JDBNPKKN@ACipherShed?5Format?4exe?$AA@
CONST	SEGMENT
??_C@_0BH@JDBNPKKN@ACipherShed?5Format?4exe?$AA@ DB 'ACipherShed Format.e'
	DB	'xe', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BPJBGDOM@ACipherShed?4exe?$AA@
CONST	SEGMENT
??_C@_0BA@BPJBGDOM@ACipherShed?4exe?$AA@ DB 'ACipherShed.exe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GJIBBNGF@ALicense?4txt?$AA@
CONST	SEGMENT
??_C@_0N@GJIBBNGF@ALicense?4txt?$AA@ DB 'ALicense.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MFPLEOCK@ACipherShed?5User?5Guide?4pdf?$AA@
CONST	SEGMENT
??_C@_0BL@MFPLEOCK@ACipherShed?5User?5Guide?4pdf?$AA@ DB 'ACipherShed Use'
	DB	'r Guide.pdf', 00H				; `string'
CONST	ENDS
;	COMDAT ?RescueIsoImageSize@BootEncryption@CipherShed@@1IB
CONST	SEGMENT
?RescueIsoImageSize@BootEncryption@CipherShed@@1IB DD 01c0000H ; CipherShed::BootEncryption::RescueIsoImageSize
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
_szFiles DD	FLAT:??_C@_0BL@MFPLEOCK@ACipherShed?5User?5Guide?4pdf?$AA@
	DD	FLAT:??_C@_0N@GJIBBNGF@ALicense?4txt?$AA@
	DD	FLAT:??_C@_0BA@BPJBGDOM@ACipherShed?4exe?$AA@
	DD	FLAT:??_C@_0BH@JDBNPKKN@ACipherShed?5Format?4exe?$AA@
	DD	FLAT:??_C@_0P@JMCFMDBI@Atruecrypt?4sys?$AA@
	DD	FLAT:??_C@_0BD@ILLOKAML@Atruecrypt?9x64?4sys?$AA@
	DD	FLAT:??_C@_0P@KPKCHNJD@Dtruecrypt?4sys?$AA@
	DD	FLAT:??_C@_0BG@DJBAHGBG@ACipherShed?9Setup?4exe?$AA@
_szCompressedFiles DD FLAT:??_C@_0BK@LMECBCPP@CipherShed?5User?5Guide?4pdf?$AA@
	DD	FLAT:??_C@_0M@HNDLNFKG@License?4txt?$AA@
	DD	FLAT:??_C@_0P@KEOPEMDF@CipherShed?4exe?$AA@
	DD	FLAT:??_C@_0BG@NHCNJMON@CipherShed?5Format?4exe?$AA@
	DD	FLAT:??_C@_0O@OJENBJKN@truecrypt?4sys?$AA@
	DD	FLAT:??_C@_0BC@KMEHMKJJ@truecrypt?9x64?4sys?$AA@
?UnloadDriver@@3HA DD 01H				; UnloadDriver
_bSystemRestore DD 01H
_bForAllUsers DD 01H
_bRegisterFileExt DD 01H
_bAddToStartMenu DD 01H
_bDesktopIcon DD 01H
_DATA	ENDS
;	COMDAT ??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
CONST	SEGMENT
??_C@_0P@GHFPNOJB@bad?5allocation?$AA@ DB 'bad allocation', 00H ; `string'
CONST	ENDS
PUBLIC	?strrchr@@YAPADPADH@Z				; strrchr
EXTRN	_strrchr:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\string.h
;	COMDAT ?strrchr@@YAPADPADH@Z
_TEXT	SEGMENT
__Str$ = 8						; size = 4
__Ch$ = 12						; size = 4
?strrchr@@YAPADPADH@Z PROC				; strrchr, COMDAT

; 188  : 	{ return (char*)strrchr((const char*)_Str, _Ch); }

  00000	e9 00 00 00 00	 jmp	 _strrchr
?strrchr@@YAPADPADH@Z ENDP				; strrchr
_TEXT	ENDS
PUBLIC	?strstr@@YAPADPADPBD@Z				; strstr
EXTRN	_strstr:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?strstr@@YAPADPADPBD@Z
_TEXT	SEGMENT
__Str$ = 8						; size = 4
__SubStr$ = 12						; size = 4
?strstr@@YAPADPADPBD@Z PROC				; strstr, COMDAT

; 190  : 	{ return (char*)strstr((const char*)_Str, _SubStr); }

  00000	e9 00 00 00 00	 jmp	 _strstr
?strstr@@YAPADPADPBD@Z ENDP				; strstr
_TEXT	ENDS
PUBLIC	_PropVariantInit
; Function compile flags: /Ogtpy
; File c:\program files\microsoft sdks\windows\v7.1\include\propidl.h
;	COMDAT _PropVariantInit
_TEXT	SEGMENT
_pvar$ = 8						; size = 4
_PropVariantInit PROC					; COMDAT

; 1173 :     memset ( pvar, 0, sizeof(PROPVARIANT) );

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _pvar$[esp-4]
  00004	33 c0		 xor	 eax, eax
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0000b	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0000e	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 1174 : }

  00011	c3		 ret	 0
_PropVariantInit ENDP
_TEXT	ENDS
PUBLIC	?swprintf@@YAHPA_WPB_WZZ			; swprintf
EXTRN	__vswprintf:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\swprintf.inl
;	COMDAT ?swprintf@@YAHPA_WPB_WZZ
_TEXT	SEGMENT
__String$ = 8						; size = 4
__Format$ = 12						; size = 4
?swprintf@@YAHPA_WPB_WZZ PROC				; swprintf, COMDAT

; 87   :     va_list _Arglist;
; 88   :     _crt_va_start(_Arglist, _Format);
; 89   :     int _Ret = _vswprintf(_String, _Format, _Arglist);

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Format$[esp-4]
  00004	8b 54 24 04	 mov	 edx, DWORD PTR __String$[esp-4]
  00008	8d 44 24 0c	 lea	 eax, DWORD PTR __Format$[esp]
  0000c	50		 push	 eax
  0000d	51		 push	 ecx
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 __vswprintf
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 90   :     _crt_va_end(_Arglist);
; 91   :     return _Ret;
; 92   : }

  00017	c3		 ret	 0
?swprintf@@YAHPA_WPB_WZZ ENDP				; swprintf
_TEXT	ENDS
PUBLIC	?InitPropVariantFromString@@YAJPB_WPAUtagPROPVARIANT@@@Z ; InitPropVariantFromString
EXTRN	__imp__SHStrDupW@8:PROC
; Function compile flags: /Ogtpy
; File c:\program files\microsoft sdks\windows\v7.1\include\propvarutil.h
;	COMDAT ?InitPropVariantFromString@@YAJPB_WPAUtagPROPVARIANT@@@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
_ppropvar$ = 12						; size = 4
?InitPropVariantFromString@@YAJPB_WPAUtagPROPVARIANT@@@Z PROC ; InitPropVariantFromString, COMDAT

; 416  :     ppropvar->vt = VT_LPWSTR;
; 417  :     HRESULT hr = SHStrDupW(psz, &ppropvar->pwszVal);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _psz$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR _ppropvar$[esp]
  00009	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  0000c	51		 push	 ecx
  0000d	b8 1f 00 00 00	 mov	 eax, 31			; 0000001fH
  00012	52		 push	 edx
  00013	66 89 06	 mov	 WORD PTR [esi], ax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SHStrDupW@8

; 418  :     if (FAILED(hr))

  0001c	85 c0		 test	 eax, eax
  0001e	7d 0d		 jge	 SHORT $LN4@InitPropVa

; 419  :     {
; 420  :         PropVariantInit(ppropvar);

  00020	33 c9		 xor	 ecx, ecx
  00022	89 0e		 mov	 DWORD PTR [esi], ecx
  00024	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00027	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0002a	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
$LN4@InitPropVa:
  0002d	5e		 pop	 esi

; 421  :     }
; 422  :     return hr;
; 423  : }

  0002e	c3		 ret	 0
?InitPropVariantFromString@@YAJPB_WPAUtagPROPVARIANT@@@Z ENDP ; InitPropVariantFromString
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

  00000	56		 push	 esi
  00001	8d 44 24 08	 lea	 eax, DWORD PTR __Message$[esp]
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

  00006	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00009	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000e	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  00013	74 09		 je	 SHORT $LN6@scalar
  00015	56		 push	 esi
  00016	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001b	83 c4 04	 add	 esp, 4
$LN6@scalar:
  0001e	8b c6		 mov	 eax, esi
  00020	5e		 pop	 esi
  00021	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 425  : 		_Left = _Right;

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Right$[esp-4]
  00004	8a 08		 mov	 cl, BYTE PTR [eax]
  00006	8b 54 24 04	 mov	 edx, DWORD PTR __Left$[esp-4]
  0000a	88 0a		 mov	 BYTE PTR [edx], cl

; 426  : 		}

  0000c	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
PUBLIC	?compare@?$char_traits@D@std@@SAHPBD0I@Z	; std::char_traits<char>::compare
; Function compile flags: /Ogtpy
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?compare@?$char_traits@D@std@@SAHPBD0I@Z PROC		; std::char_traits<char>::compare, COMDAT

; 441  : //		_DEBUG_POINTER(_First1);
; 442  : //		_DEBUG_POINTER(_First2);
; 443  : 		return (::memcmp(_First1, _First2, _Count));

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __First2$[esp-4]
  00004	8b 54 24 04	 mov	 edx, DWORD PTR __First1$[esp-4]
  00008	56		 push	 esi
  00009	8b 74 24 10	 mov	 esi, DWORD PTR __Count$[esp]
  0000d	57		 push	 edi
  0000e	83 fe 04	 cmp	 esi, 4
  00011	72 14		 jb	 SHORT $LN11@compare
$LL4@compare:
  00013	8b 02		 mov	 eax, DWORD PTR [edx]
  00015	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00017	75 12		 jne	 SHORT $LN5@compare
  00019	83 ee 04	 sub	 esi, 4
  0001c	83 c1 04	 add	 ecx, 4
  0001f	83 c2 04	 add	 edx, 4
  00022	83 fe 04	 cmp	 esi, 4
  00025	73 ec		 jae	 SHORT $LL4@compare
$LN11@compare:
  00027	85 f6		 test	 esi, esi
  00029	74 44		 je	 SHORT $LN6@compare
$LN5@compare:
  0002b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0002e	0f b6 39	 movzx	 edi, BYTE PTR [ecx]
  00031	2b c7		 sub	 eax, edi
  00033	75 31		 jne	 SHORT $LN7@compare
  00035	83 fe 01	 cmp	 esi, 1
  00038	76 35		 jbe	 SHORT $LN6@compare
  0003a	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  0003e	0f b6 79 01	 movzx	 edi, BYTE PTR [ecx+1]
  00042	2b c7		 sub	 eax, edi
  00044	75 20		 jne	 SHORT $LN7@compare
  00046	83 fe 02	 cmp	 esi, 2
  00049	76 24		 jbe	 SHORT $LN6@compare
  0004b	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  0004f	0f b6 79 02	 movzx	 edi, BYTE PTR [ecx+2]
  00053	2b c7		 sub	 eax, edi
  00055	75 0f		 jne	 SHORT $LN7@compare
  00057	83 fe 03	 cmp	 esi, 3
  0005a	76 13		 jbe	 SHORT $LN6@compare
  0005c	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  00060	0f b6 49 03	 movzx	 ecx, BYTE PTR [ecx+3]
  00064	2b c1		 sub	 eax, ecx
$LN7@compare:
  00066	c1 f8 1f	 sar	 eax, 31			; 0000001fH
  00069	5f		 pop	 edi
  0006a	83 c8 01	 or	 eax, 1
  0006d	5e		 pop	 esi

; 444  : 		}

  0006e	c3		 ret	 0
$LN6@compare:
  0006f	5f		 pop	 edi

; 441  : //		_DEBUG_POINTER(_First1);
; 442  : //		_DEBUG_POINTER(_First2);
; 443  : 		return (::memcmp(_First1, _First2, _Count));

  00070	33 c0		 xor	 eax, eax
  00072	5e		 pop	 esi

; 444  : 		}

  00073	c3		 ret	 0
?compare@?$char_traits@D@std@@SAHPBD0I@Z ENDP		; std::char_traits<char>::compare
_TEXT	ENDS
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
; Function compile flags: /Ogtpy
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 448  : //		_DEBUG_POINTER(_First);
; 449  : 		return (::strlen(_First));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL3@length:
  00007	8a 08		 mov	 cl, BYTE PTR [eax]
  00009	40		 inc	 eax
  0000a	84 c9		 test	 cl, cl
  0000c	75 f9		 jne	 SHORT $LL3@length
  0000e	2b c2		 sub	 eax, edx

; 450  : 		}

  00010	c3		 ret	 0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
PUBLIC	?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z	; std::char_traits<char>::_Copy_s
EXTRN	_memcpy_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size_in_bytes$ = 12					; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z PROC	; std::char_traits<char>::_Copy_s, COMDAT

; 463  : //		_DEBUG_POINTER(_First1);
; 464  : //		_DEBUG_POINTER(_First2);
; 465  : 		_CRT_SECURE_MEMCPY(_First1, _Size_in_bytes, _First2, _Count);

  00000	8b 44 24 10	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8b 4c 24 0c	 mov	 ecx, DWORD PTR __First2$[esp-4]
  00008	8b 54 24 08	 mov	 edx, DWORD PTR __Size_in_bytes$[esp-4]
  0000c	56		 push	 esi
  0000d	8b 74 24 08	 mov	 esi, DWORD PTR __First1$[esp]
  00011	50		 push	 eax
  00012	51		 push	 ecx
  00013	52		 push	 edx
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 _memcpy_s
  0001a	83 c4 10	 add	 esp, 16			; 00000010H

; 466  : 		return _First1;

  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi

; 467  : 		}

  00020	c3		 ret	 0
?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z ENDP	; std::char_traits<char>::_Copy_s
_TEXT	ENDS
PUBLIC	?find@?$char_traits@D@std@@SAPBDPBDIABD@Z	; std::char_traits<char>::find
EXTRN	_memchr:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?find@?$char_traits@D@std@@SAPBDPBDIABD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 4
?find@?$char_traits@D@std@@SAPBDPBDIABD@Z PROC		; std::char_traits<char>::find, COMDAT

; 472  : //		_DEBUG_POINTER(_First);
; 473  : 		return ((const _Elem *)::memchr(_First, _Ch, _Count));

  00000	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Ch$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Count$[esp-4]
  00008	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0000b	50		 push	 eax
  0000c	8b 44 24 08	 mov	 eax, DWORD PTR __First$[esp]
  00010	52		 push	 edx
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _memchr
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 474  : 		}

  0001a	c3		 ret	 0
?find@?$char_traits@D@std@@SAPBDPBDIABD@Z ENDP		; std::char_traits<char>::find
_TEXT	ENDS
PUBLIC	?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z	; std::char_traits<char>::_Move_s
EXTRN	_memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size_in_bytes$ = 12					; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z PROC	; std::char_traits<char>::_Move_s, COMDAT

; 487  : //		_DEBUG_POINTER(_First1);
; 488  : //		_DEBUG_POINTER(_First2);
; 489  : 		_CRT_SECURE_MEMMOVE(_First1, _Size_in_bytes, _First2, _Count);

  00000	8b 44 24 10	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8b 4c 24 0c	 mov	 ecx, DWORD PTR __First2$[esp-4]
  00008	8b 54 24 08	 mov	 edx, DWORD PTR __Size_in_bytes$[esp-4]
  0000c	56		 push	 esi
  0000d	8b 74 24 08	 mov	 esi, DWORD PTR __First1$[esp]
  00011	50		 push	 eax
  00012	51		 push	 ecx
  00013	52		 push	 edx
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 _memmove_s
  0001a	83 c4 10	 add	 esp, 16			; 00000010H

; 490  : 		return _First1;

  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi

; 491  : 		}

  00020	c3		 ret	 0
?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z ENDP	; std::char_traits<char>::_Move_s
_TEXT	ENDS
PUBLIC	_localcleanup
EXTRN	_CloseAppSetupMutex:PROC
EXTRN	_cleanup:PROC
EXTRN	_localcleanupwiz:PROC
; Function compile flags: /Ogtpy
; File c:\home\public\desktop\projects\ciphershed.build\src\setup\setup.c
;	COMDAT _localcleanup
_TEXT	SEGMENT
_localcleanup PROC					; COMDAT

; 86   : 	localcleanupwiz ();

  00000	e8 00 00 00 00	 call	 _localcleanupwiz

; 87   : 	cleanup ();

  00005	e8 00 00 00 00	 call	 _cleanup

; 88   : 
; 89   : 	CloseAppSetupMutex ();

  0000a	e9 00 00 00 00	 jmp	 _CloseAppSetupMutex
_localcleanup ENDP
_TEXT	ENDS
PUBLIC	_StatDeleteFile
EXTRN	__imp__DeleteFileA@4:PROC
EXTRN	__stat64:PROC
; Function compile flags: /Ogtpy
;	COMDAT _StatDeleteFile
_TEXT	SEGMENT
_st$ = -56						; size = 56
_lpszFile$ = 8						; size = 4
_StatDeleteFile PROC					; COMDAT

; 93   : {

  00000	83 ec 38	 sub	 esp, 56			; 00000038H
  00003	56		 push	 esi

; 94   : 	struct __stat64 st;
; 95   : 
; 96   : 	if (_stat64 (lpszFile, &st) == 0)

  00004	8b 74 24 40	 mov	 esi, DWORD PTR _lpszFile$[esp+56]
  00008	8d 44 24 04	 lea	 eax, DWORD PTR _st$[esp+60]
  0000c	50		 push	 eax
  0000d	56		 push	 esi
  0000e	e8 00 00 00 00	 call	 __stat64
  00013	83 c4 08	 add	 esp, 8
  00016	85 c0		 test	 eax, eax
  00018	75 0c		 jne	 SHORT $LN2@StatDelete

; 97   : 		return DeleteFile (lpszFile);

  0001a	56		 push	 esi
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteFileA@4
  00021	5e		 pop	 esi

; 100  : }

  00022	83 c4 38	 add	 esp, 56			; 00000038H
  00025	c3		 ret	 0
$LN2@StatDelete:

; 98   : 	else
; 99   : 		return TRUE;

  00026	b8 01 00 00 00	 mov	 eax, 1
  0002b	5e		 pop	 esi

; 100  : }

  0002c	83 c4 38	 add	 esp, 56			; 00000038H
  0002f	c3		 ret	 0
_StatDeleteFile ENDP
_TEXT	ENDS
PUBLIC	_StatRemoveDirectory
EXTRN	__imp__RemoveDirectoryA@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT _StatRemoveDirectory
_TEXT	SEGMENT
_st$ = -56						; size = 56
_lpszDir$ = 8						; size = 4
_StatRemoveDirectory PROC				; COMDAT

; 103  : {

  00000	83 ec 38	 sub	 esp, 56			; 00000038H
  00003	56		 push	 esi

; 104  : 	struct __stat64 st;
; 105  : 
; 106  : 	if (_stat64 (lpszDir, &st) == 0)

  00004	8b 74 24 40	 mov	 esi, DWORD PTR _lpszDir$[esp+56]
  00008	8d 44 24 04	 lea	 eax, DWORD PTR _st$[esp+60]
  0000c	50		 push	 eax
  0000d	56		 push	 esi
  0000e	e8 00 00 00 00	 call	 __stat64
  00013	83 c4 08	 add	 esp, 8
  00016	85 c0		 test	 eax, eax
  00018	75 0c		 jne	 SHORT $LN2@StatRemove

; 107  : 		return RemoveDirectory (lpszDir);

  0001a	56		 push	 esi
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RemoveDirectoryA@4
  00021	5e		 pop	 esi

; 110  : }

  00022	83 c4 38	 add	 esp, 56			; 00000038H
  00025	c3		 ret	 0
$LN2@StatRemove:

; 108  : 	else
; 109  : 		return TRUE;

  00026	b8 01 00 00 00	 mov	 eax, 1
  0002b	5e		 pop	 esi

; 110  : }

  0002c	83 c4 38	 add	 esp, 56			; 00000038H
  0002f	c3		 ret	 0
_StatRemoveDirectory ENDP
_TEXT	ENDS
PUBLIC	_GetProgramPath
EXTRN	__imp__SHGetPathFromIDListA@8:PROC
EXTRN	__imp__SHGetSpecialFolderLocation@12:PROC
; Function compile flags: /Ogtpy
;	COMDAT _GetProgramPath
_TEXT	SEGMENT
_i$ = -4						; size = 4
_hwndDlg$ = 8						; size = 4
_path$ = 12						; size = 4
_GetProgramPath PROC					; COMDAT

; 173  : {

  00000	51		 push	 ecx

; 174  : 	ITEMIDLIST *i;
; 175  : 	HRESULT res;
; 176  : 
; 177  : 	if (bForAllUsers)

  00001	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bForAllUsers, 0
  00008	74 0d		 je	 SHORT $LN2@GetProgram

; 178  :         res = SHGetSpecialFolderLocation (hwndDlg, CSIDL_COMMON_PROGRAMS, &i);

  0000a	8b 4c 24 08	 mov	 ecx, DWORD PTR _hwndDlg$[esp]
  0000e	8d 04 24	 lea	 eax, DWORD PTR _i$[esp+4]
  00011	50		 push	 eax
  00012	6a 17		 push	 23			; 00000017H
  00014	51		 push	 ecx

; 179  : 	else

  00015	eb 0b		 jmp	 SHORT $LN5@GetProgram
$LN2@GetProgram:

; 180  :         res = SHGetSpecialFolderLocation (hwndDlg, CSIDL_PROGRAMS, &i);

  00017	8b 44 24 08	 mov	 eax, DWORD PTR _hwndDlg$[esp]
  0001b	8d 14 24	 lea	 edx, DWORD PTR _i$[esp+4]
  0001e	52		 push	 edx
  0001f	6a 02		 push	 2
  00021	50		 push	 eax
$LN5@GetProgram:
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SHGetSpecialFolderLocation@12

; 181  : 
; 182  : 	SHGetPathFromIDList (i, path);

  00028	8b 4c 24 0c	 mov	 ecx, DWORD PTR _path$[esp]
  0002c	8b 14 24	 mov	 edx, DWORD PTR _i$[esp+4]
  0002f	51		 push	 ecx
  00030	52		 push	 edx
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SHGetPathFromIDListA@8

; 183  : }

  00037	59		 pop	 ecx
  00038	c3		 ret	 0
_GetProgramPath ENDP
_TEXT	ENDS
PUBLIC	_StatusMessage
EXTRN	__imp__SendDlgItemMessageA@20:PROC
EXTRN	__imp__SendMessageW@16:PROC
EXTRN	__imp__GetDlgItem@8:PROC
EXTRN	_GetString:PROC
; Function compile flags: /Ogtpy
;	COMDAT _StatusMessage
_TEXT	SEGMENT
_hwndDlg$ = 8						; size = 4
_stringId$ = 12						; size = 4
_StatusMessage PROC					; COMDAT

; 187  : 	if (Rollback)

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  00007	75 58		 jne	 SHORT $LN2@StatusMess

; 188  : 		return;
; 189  : 
; 190  : 	SendMessageW (GetDlgItem (hwndDlg, IDC_LOG_WINDOW), LB_ADDSTRING, 0, (LPARAM) GetString (stringId));

  00009	8b 44 24 08	 mov	 eax, DWORD PTR _stringId$[esp-4]
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 _GetString
  00015	8b 74 24 10	 mov	 esi, DWORD PTR _hwndDlg$[esp+8]
  00019	83 c4 04	 add	 esp, 4
  0001c	50		 push	 eax
  0001d	6a 00		 push	 0
  0001f	68 80 01 00 00	 push	 384			; 00000180H
  00024	68 f9 03 00 00	 push	 1017			; 000003f9H
  00029	56		 push	 esi
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00030	50		 push	 eax
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageW@16

; 191  : 
; 192  : 	SendDlgItemMessage (hwndDlg, IDC_LOG_WINDOW, LB_SETTOPINDEX, 
; 193  : 		SendDlgItemMessage (hwndDlg, IDC_LOG_WINDOW, LB_GETCOUNT, 0, 0) - 1, 0);

  00037	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__SendDlgItemMessageA@20
  0003d	6a 00		 push	 0
  0003f	6a 00		 push	 0
  00041	6a 00		 push	 0
  00043	68 8b 01 00 00	 push	 395			; 0000018bH
  00048	68 f9 03 00 00	 push	 1017			; 000003f9H
  0004d	56		 push	 esi
  0004e	ff d7		 call	 edi
  00050	48		 dec	 eax
  00051	50		 push	 eax
  00052	68 97 01 00 00	 push	 407			; 00000197H
  00057	68 f9 03 00 00	 push	 1017			; 000003f9H
  0005c	56		 push	 esi
  0005d	ff d7		 call	 edi
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
$LN2@StatusMess:

; 194  : }

  00061	c3		 ret	 0
_StatusMessage ENDP
_TEXT	ENDS
PUBLIC	??_C@_1O@FHLBCOCO@?$AA?$CF?$AAs?$AA?5?$AA?$CF?$AAh?$AAs?$AA?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_StatusMessageParam
EXTRN	__imp__wsprintfW:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_1O@FHLBCOCO@?$AA?$CF?$AAs?$AA?5?$AA?$CF?$AAh?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1O@FHLBCOCO@?$AA?$CF?$AAs?$AA?5?$AA?$CF?$AAh?$AAs?$AA?$AA@ DB '%', 00H
	DB	's', 00H, ' ', 00H, '%', 00H, 'h', 00H, 's', 00H, 00H, 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _StatusMessageParam
_TEXT	SEGMENT
_szTmp$ = -2052						; size = 2048
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_stringId$ = 12						; size = 4
_param$ = 16						; size = 4
_StatusMessageParam PROC				; COMDAT

; 197  : {

  00000	81 ec 04 08 00
	00		 sub	 esp, 2052		; 00000804H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 00 08
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+2052], eax

; 198  : 	wchar_t szTmp[1024];
; 199  : 
; 200  : 	if (Rollback)

  00014	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  0001b	8b 84 24 0c 08
	00 00		 mov	 eax, DWORD PTR _stringId$[esp+2048]
  00022	8b 8c 24 10 08
	00 00		 mov	 ecx, DWORD PTR _param$[esp+2048]
  00029	56		 push	 esi
  0002a	8b b4 24 0c 08
	00 00		 mov	 esi, DWORD PTR _hwndDlg$[esp+2052]
  00031	75 67		 jne	 SHORT $LN2@StatusMess@2
  00033	57		 push	 edi

; 201  : 		return;
; 202  : 
; 203  : 	wsprintfW (szTmp, L"%s %hs", GetString (stringId), param);

  00034	51		 push	 ecx
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _GetString
  0003b	83 c4 04	 add	 esp, 4
  0003e	50		 push	 eax
  0003f	8d 44 24 10	 lea	 eax, DWORD PTR _szTmp$[esp+2068]
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1O@FHLBCOCO@?$AA?$CF?$AAs?$AA?5?$AA?$CF?$AAh?$AAs?$AA?$AA@
  00048	50		 push	 eax
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfW
  0004f	83 c4 10	 add	 esp, 16			; 00000010H

; 204  : 	SendMessageW (GetDlgItem (hwndDlg, IDC_LOG_WINDOW), LB_ADDSTRING, 0, (LPARAM) szTmp);

  00052	8d 4c 24 08	 lea	 ecx, DWORD PTR _szTmp$[esp+2060]
  00056	51		 push	 ecx
  00057	6a 00		 push	 0
  00059	68 80 01 00 00	 push	 384			; 00000180H
  0005e	68 f9 03 00 00	 push	 1017			; 000003f9H
  00063	56		 push	 esi
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0006a	50		 push	 eax
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageW@16

; 205  : 		
; 206  : 	SendDlgItemMessage (hwndDlg, IDC_LOG_WINDOW, LB_SETTOPINDEX, 
; 207  : 		SendDlgItemMessage (hwndDlg, IDC_LOG_WINDOW, LB_GETCOUNT, 0, 0) - 1, 0);

  00071	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__SendDlgItemMessageA@20
  00077	6a 00		 push	 0
  00079	6a 00		 push	 0
  0007b	6a 00		 push	 0
  0007d	68 8b 01 00 00	 push	 395			; 0000018bH
  00082	68 f9 03 00 00	 push	 1017			; 000003f9H
  00087	56		 push	 esi
  00088	ff d7		 call	 edi
  0008a	48		 dec	 eax
  0008b	50		 push	 eax
  0008c	68 97 01 00 00	 push	 407			; 00000197H
  00091	68 f9 03 00 00	 push	 1017			; 000003f9H
  00096	56		 push	 esi
  00097	ff d7		 call	 edi
  00099	5f		 pop	 edi
$LN2@StatusMess@2:

; 208  : }

  0009a	8b 8c 24 04 08
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+2056]
  000a1	5e		 pop	 esi
  000a2	33 cc		 xor	 ecx, esp
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	81 c4 04 08 00
	00		 add	 esp, 2052		; 00000804H
  000af	c3		 ret	 0
_StatusMessageParam ENDP
_TEXT	ENDS
PUBLIC	_ClearLogWindow
EXTRN	__imp__SendMessageA@16:PROC
; Function compile flags: /Ogtpy
;	COMDAT _ClearLogWindow
_TEXT	SEGMENT
_hwndDlg$ = 8						; size = 4
_ClearLogWindow PROC					; COMDAT

; 212  : 	SendMessage (GetDlgItem (hwndDlg, IDC_LOG_WINDOW), LB_RESETCONTENT, 0, 0);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _hwndDlg$[esp-4]
  00004	6a 00		 push	 0
  00006	6a 00		 push	 0
  00008	68 84 01 00 00	 push	 388			; 00000184H
  0000d	68 f9 03 00 00	 push	 1017			; 000003f9H
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00019	50		 push	 eax
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 213  : }

  00020	c3		 ret	 0
_ClearLogWindow ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@LFAEJJAB@ADDING_REG?$AA@		; `string'
PUBLIC	_RegMessage
;	COMDAT ??_C@_0L@LFAEJJAB@ADDING_REG?$AA@
CONST	SEGMENT
??_C@_0L@LFAEJJAB@ADDING_REG?$AA@ DB 'ADDING_REG', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _RegMessage
_TEXT	SEGMENT
_hwndDlg$ = 8						; size = 4
_txt$ = 12						; size = 4
_RegMessage PROC					; COMDAT

; 217  : 	StatusMessageParam (hwndDlg, "ADDING_REG", txt);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _txt$[esp-4]
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR _hwndDlg$[esp-4]
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0L@LFAEJJAB@ADDING_REG?$AA@
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 _StatusMessageParam
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 218  : }

  00017	c3		 ret	 0
_RegMessage ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@HHILBMI@INSTALLING?$AA@		; `string'
PUBLIC	_CopyMessage
;	COMDAT ??_C@_0L@HHILBMI@INSTALLING?$AA@
CONST	SEGMENT
??_C@_0L@HHILBMI@INSTALLING?$AA@ DB 'INSTALLING', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _CopyMessage
_TEXT	SEGMENT
_hwndDlg$ = 8						; size = 4
_txt$ = 12						; size = 4
_CopyMessage PROC					; COMDAT

; 222  : 	StatusMessageParam (hwndDlg, "INSTALLING", txt);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _txt$[esp-4]
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR _hwndDlg$[esp-4]
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0L@HHILBMI@INSTALLING?$AA@
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 _StatusMessageParam
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 223  : }

  00017	c3		 ret	 0
_CopyMessage ENDP
_TEXT	ENDS
PUBLIC	??_C@_08GLIOLGPM@REMOVING?$AA@			; `string'
PUBLIC	_RemoveMessage
;	COMDAT ??_C@_08GLIOLGPM@REMOVING?$AA@
CONST	SEGMENT
??_C@_08GLIOLGPM@REMOVING?$AA@ DB 'REMOVING', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _RemoveMessage
_TEXT	SEGMENT
_hwndDlg$ = 8						; size = 4
_txt$ = 12						; size = 4
_RemoveMessage PROC					; COMDAT

; 227  : 	if (!Rollback)

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  00007	75 17		 jne	 SHORT $LN1@RemoveMess

; 228  : 		StatusMessageParam (hwndDlg, "REMOVING", txt);

  00009	8b 44 24 08	 mov	 eax, DWORD PTR _txt$[esp-4]
  0000d	8b 4c 24 04	 mov	 ecx, DWORD PTR _hwndDlg$[esp-4]
  00011	50		 push	 eax
  00012	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _StatusMessageParam
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@RemoveMess:

; 229  : }

  00020	c3		 ret	 0
_RemoveMessage ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@CFAAPOHD@ADDING_ICON?$AA@		; `string'
PUBLIC	_IconMessage
;	COMDAT ??_C@_0M@CFAAPOHD@ADDING_ICON?$AA@
CONST	SEGMENT
??_C@_0M@CFAAPOHD@ADDING_ICON?$AA@ DB 'ADDING_ICON', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _IconMessage
_TEXT	SEGMENT
_hwndDlg$ = 8						; size = 4
_txt$ = 12						; size = 4
_IconMessage PROC					; COMDAT

; 233  : 	StatusMessageParam (hwndDlg, "ADDING_ICON", txt);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _txt$[esp-4]
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR _hwndDlg$[esp-4]
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CFAAPOHD@ADDING_ICON?$AA@
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 _StatusMessageParam
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 234  : }

  00017	c3		 ret	 0
_IconMessage ENDP
_TEXT	ENDS
PUBLIC	_DetermineUpgradeDowngradeStatus
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__DeviceIoControl@32:PROC
EXTRN	_DriverAttach:PROC
EXTRN	_hDriver:DWORD
; Function compile flags: /Ogtpy
;	COMDAT _DetermineUpgradeDowngradeStatus
_TEXT	SEGMENT
_driverVersion$ = -8					; size = 4
_dwResult$134128 = -4					; size = 4
_bCloseDriverHandle$ = 8				; size = 4
_driverVersionPtr$ = 12					; size = 4
_DetermineUpgradeDowngradeStatus PROC			; COMDAT

; 243  : {

  00000	83 ec 08	 sub	 esp, 8

; 244  : 	/* Defaults to the callers version number if no installed driver is found. */
; 245  : 	LONG driverVersion = VERSION_NUM;
; 246  : 
; 247  : 	/* Singleton pattern. */
; 248  : 	if (hDriver == INVALID_HANDLE_VALUE)

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR _hDriver
  00008	c7 04 24 30 07
	00 00		 mov	 DWORD PTR _driverVersion$[esp+8], 1840 ; 00000730H
  0000f	83 f8 ff	 cmp	 eax, -1
  00012	75 13		 jne	 SHORT $LN15@DetermineU

; 249  : 		DriverAttach();

  00014	e8 00 00 00 00	 call	 _DriverAttach

; 250  : 
; 251  : 	/* Check if the driver was opened successfully. */
; 252  : 	if (hDriver != INVALID_HANDLE_VALUE)

  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR _hDriver
  0001e	83 f8 ff	 cmp	 eax, -1
  00021	0f 84 0c 01 00
	00		 je	 $LN17@DetermineU
$LN15@DetermineU:
  00027	56		 push	 esi

; 253  : 	{
; 254  : 		DWORD dwResult;
; 255  : 
; 256  : 		/* Send a ioctl to determine the driver version. */
; 257  : 		BOOL bResult = DeviceIoControl (hDriver, TC_IOCTL_GET_DRIVER_VERSION, NULL, 0, &driverVersion, sizeof (driverVersion), &dwResult, NULL);

  00028	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__DeviceIoControl@32
  0002e	6a 00		 push	 0
  00030	8d 4c 24 0c	 lea	 ecx, DWORD PTR _dwResult$134128[esp+16]
  00034	51		 push	 ecx
  00035	6a 04		 push	 4
  00037	8d 54 24 10	 lea	 edx, DWORD PTR _driverVersion$[esp+24]
  0003b	52		 push	 edx
  0003c	6a 00		 push	 0
  0003e	6a 00		 push	 0
  00040	68 04 20 22 00	 push	 2236420			; 00222004H
  00045	50		 push	 eax
  00046	ff d6		 call	 esi

; 258  : 
; 259  : 		if (!bResult)

  00048	85 c0		 test	 eax, eax
  0004a	75 23		 jne	 SHORT $LN14@DetermineU

; 260  : 			bResult = DeviceIoControl (hDriver, TC_IOCTL_LEGACY_GET_DRIVER_VERSION, NULL, 0, &driverVersion, sizeof (driverVersion), &dwResult, NULL);

  0004c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hDriver
  00052	50		 push	 eax
  00053	8d 44 24 0c	 lea	 eax, DWORD PTR _dwResult$134128[esp+16]
  00057	50		 push	 eax
  00058	6a 04		 push	 4
  0005a	8d 4c 24 10	 lea	 ecx, DWORD PTR _driverVersion$[esp+24]
  0005e	51		 push	 ecx
  0005f	6a 00		 push	 0
  00061	6a 00		 push	 0
  00063	68 18 20 07 00	 push	 466968			; 00072018H
  00068	52		 push	 edx
  00069	ff d6		 call	 esi

; 261  : 
; 262  : 		if (bResult)

  0006b	85 c0		 test	 eax, eax
  0006d	74 1d		 je	 SHORT $LN18@DetermineU
$LN14@DetermineU:

; 263  : 			InstalledVersion = driverVersion;

  0006f	8b 4c 24 04	 mov	 ecx, DWORD PTR _driverVersion$[esp+12]
  00073	89 0d 00 00 00
	00		 mov	 DWORD PTR ?InstalledVersion@@3JA, ecx ; InstalledVersion

; 264  : 
; 265  : 		bUpgrade = (bResult && driverVersion < VERSION_NUM);

  00079	85 c0		 test	 eax, eax
  0007b	74 13		 je	 SHORT $LN8@DetermineU
  0007d	81 f9 30 07 00
	00		 cmp	 ecx, 1840		; 00000730H
  00083	7d 0b		 jge	 SHORT $LN8@DetermineU
  00085	ba 01 00 00 00	 mov	 edx, 1
  0008a	eb 06		 jmp	 SHORT $LN19@DetermineU
$LN18@DetermineU:
  0008c	8b 4c 24 04	 mov	 ecx, DWORD PTR _driverVersion$[esp+12]
$LN8@DetermineU:
  00090	33 d2		 xor	 edx, edx
$LN19@DetermineU:
  00092	89 15 00 00 00
	00		 mov	 DWORD PTR _bUpgrade, edx

; 266  : 		bDowngrade = (bResult && driverVersion > VERSION_NUM);

  00098	85 c0		 test	 eax, eax
  0009a	74 12		 je	 SHORT $LN10@DetermineU
  0009c	81 f9 30 07 00
	00		 cmp	 ecx, 1840		; 00000730H
  000a2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bDowngrade@@3HA, 1 ; bDowngrade
  000ac	7f 0a		 jg	 SHORT $LN11@DetermineU
$LN10@DetermineU:
  000ae	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bDowngrade@@3HA, 0 ; bDowngrade
$LN11@DetermineU:

; 267  : 
; 268  : 		/* TrueCrypt to CipherShed migration flag. */
; 269  : 		bCipherShedMigration = (bUpgrade && driverVersion < 0x730);

  000b8	85 d2		 test	 edx, edx
  000ba	74 12		 je	 SHORT $LN12@DetermineU
  000bc	81 f9 30 07 00
	00		 cmp	 ecx, 1840		; 00000730H
  000c2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bCipherShedMigration, 1
  000cc	7c 0a		 jl	 SHORT $LN13@DetermineU
$LN12@DetermineU:
  000ce	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bCipherShedMigration, 0
$LN13@DetermineU:

; 270  : 
; 271  : 		/* Determine if the driver was loaded in portable mode. */
; 272  : 		PortableMode = DeviceIoControl (hDriver, TC_IOCTL_GET_PORTABLE_MODE_STATUS, NULL, 0, NULL, 0, &dwResult, NULL);

  000d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hDriver
  000de	6a 00		 push	 0
  000e0	8d 44 24 0c	 lea	 eax, DWORD PTR _dwResult$134128[esp+16]
  000e4	50		 push	 eax
  000e5	6a 00		 push	 0
  000e7	6a 00		 push	 0
  000e9	6a 00		 push	 0
  000eb	6a 00		 push	 0
  000ed	68 64 20 22 00	 push	 2236516			; 00222064H
  000f2	51		 push	 ecx
  000f3	ff d6		 call	 esi

; 273  : 
; 274  : 		if (bCloseDriverHandle)

  000f5	83 7c 24 10 00	 cmp	 DWORD PTR _bCloseDriverHandle$[esp+8], 0
  000fa	a3 00 00 00 00	 mov	 DWORD PTR ?PortableMode@@3HA, eax ; PortableMode
  000ff	5e		 pop	 esi
  00100	74 24		 je	 SHORT $LN16@DetermineU

; 275  : 		{
; 276  : 			CloseHandle (hDriver);

  00102	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hDriver
  00108	52		 push	 edx
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 277  : 			hDriver = INVALID_HANDLE_VALUE;
; 278  : 		}
; 279  : 	}
; 280  : 
; 281  : 	*driverVersionPtr = driverVersion;

  0010f	8b 44 24 10	 mov	 eax, DWORD PTR _driverVersionPtr$[esp+4]
  00113	8b 0c 24	 mov	 ecx, DWORD PTR _driverVersion$[esp+8]
  00116	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _hDriver, -1
  00120	89 08		 mov	 DWORD PTR [eax], ecx

; 282  : }

  00122	83 c4 08	 add	 esp, 8
  00125	c3		 ret	 0
$LN16@DetermineU:

; 277  : 			hDriver = INVALID_HANDLE_VALUE;
; 278  : 		}
; 279  : 	}
; 280  : 
; 281  : 	*driverVersionPtr = driverVersion;

  00126	8b 54 24 10	 mov	 edx, DWORD PTR _driverVersionPtr$[esp+4]
  0012a	8b 04 24	 mov	 eax, DWORD PTR _driverVersion$[esp+8]
  0012d	89 02		 mov	 DWORD PTR [edx], eax

; 282  : }

  0012f	83 c4 08	 add	 esp, 8
  00132	c3		 ret	 0
$LN17@DetermineU:

; 277  : 			hDriver = INVALID_HANDLE_VALUE;
; 278  : 		}
; 279  : 	}
; 280  : 
; 281  : 	*driverVersionPtr = driverVersion;

  00133	8b 4c 24 10	 mov	 ecx, DWORD PTR _driverVersionPtr$[esp+4]
  00137	8b 14 24	 mov	 edx, DWORD PTR _driverVersion$[esp+8]
  0013a	89 11		 mov	 DWORD PTR [ecx], edx

; 282  : }

  0013c	83 c4 08	 add	 esp, 8
  0013f	c3		 ret	 0
_DetermineUpgradeDowngradeStatus ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@DAPCIKHM@TrueCrypt?5User?5Guide?4pdf?$AA@ ; `string'
PUBLIC	??_C@_0BE@NCPFOFMD@TrueCrypt?5Setup?4exe?$AA@	; `string'
PUBLIC	??_C@_0BF@PLOADIIL@TrueCrypt?5Format?4exe?$AA@	; `string'
PUBLIC	??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@		; `string'
PUBLIC	??_C@_0O@DFMLFAG@TrueCrypt?4exe?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_DoTrueCryptFilesUninstall
EXTRN	_handleWin32Error:PROC
EXTRN	__snprintf:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_0BJ@DAPCIKHM@TrueCrypt?5User?5Guide?4pdf?$AA@
CONST	SEGMENT
??_C@_0BJ@DAPCIKHM@TrueCrypt?5User?5Guide?4pdf?$AA@ DB 'TrueCrypt User Gu'
	DB	'ide.pdf', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NCPFOFMD@TrueCrypt?5Setup?4exe?$AA@
CONST	SEGMENT
??_C@_0BE@NCPFOFMD@TrueCrypt?5Setup?4exe?$AA@ DB 'TrueCrypt Setup.exe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PLOADIIL@TrueCrypt?5Format?4exe?$AA@
CONST	SEGMENT
??_C@_0BF@PLOADIIL@TrueCrypt?5Format?4exe?$AA@ DB 'TrueCrypt Format.exe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
CONST	SEGMENT
??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@ DB '%s%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DFMLFAG@TrueCrypt?4exe?$AA@
CONST	SEGMENT
??_C@_0O@DFMLFAG@TrueCrypt?4exe?$AA@ DB 'TrueCrypt.exe', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _DoTrueCryptFilesUninstall
_TEXT	SEGMENT
_st$138138 = -320					; size = 56
_st$138129 = -320					; size = 56
_st$138119 = -320					; size = 56
_st$138109 = -320					; size = 56
_st$138099 = -320					; size = 56
_st$138089 = -320					; size = 56
_st$138079 = -320					; size = 56
_st$138069 = -320					; size = 56
_path$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_DoTrueCryptFilesUninstall PROC				; COMDAT

; 545  : {

  00000	81 ec 40 01 00
	00		 sub	 esp, 320		; 00000140H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 3c 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+320], eax
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	8b b4 24 4c 01
	00 00		 mov	 esi, DWORD PTR _hwndDlg$[esp+324]
  0001d	57		 push	 edi

; 546  : 	char path[MAX_PATH] = { 0 };

  0001e	68 03 01 00 00	 push	 259			; 00000103H
  00023	8d 44 24 49	 lea	 eax, DWORD PTR _path$[esp+337]
  00027	6a 00		 push	 0
  00029	50		 push	 eax
  0002a	c6 44 24 50 00	 mov	 BYTE PTR _path$[esp+344], 0
  0002f	e8 00 00 00 00	 call	 _memset

; 547  : 	BOOL bOK = TRUE;
; 548  : 
; 549  : 	/* TrueCrypt.exe */
; 550  : 	if (_snprintf (path, sizeof (path) - 1, "%s%s", UninstallationPath, TC_APP_NAME_LEGACY ".exe") >= 0)

  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0O@DFMLFAG@TrueCrypt?4exe?$AA@
  00039	68 00 00 00 00	 push	 OFFSET ?UninstallationPath@@3PADA ; UninstallationPath
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  00043	8d 4c 24 5c	 lea	 ecx, DWORD PTR _path$[esp+356]
  00047	68 03 01 00 00	 push	 259			; 00000103H
  0004c	51		 push	 ecx
  0004d	bb 01 00 00 00	 mov	 ebx, 1
  00052	e8 00 00 00 00	 call	 __snprintf
  00057	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__DeleteFileA@4
  0005d	83 c4 20	 add	 esp, 32			; 00000020H
  00060	85 c0		 test	 eax, eax
  00062	7c 39		 jl	 SHORT $LN18@DoTrueCryp

; 551  : 	{
; 552  : 		RemoveMessage (hwndDlg, path);

  00064	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  0006b	75 13		 jne	 SHORT $LN14@DoTrueCryp
  0006d	8d 54 24 44	 lea	 edx, DWORD PTR _path$[esp+332]
  00071	52		 push	 edx
  00072	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  00077	56		 push	 esi
  00078	e8 00 00 00 00	 call	 _StatusMessageParam
  0007d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@DoTrueCryp:

; 553  : 		StatDeleteFile (path);

  00080	8d 44 24 0c	 lea	 eax, DWORD PTR _st$138069[esp+332]
  00084	50		 push	 eax
  00085	8d 4c 24 48	 lea	 ecx, DWORD PTR _path$[esp+336]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 __stat64
  0008f	83 c4 08	 add	 esp, 8
  00092	85 c0		 test	 eax, eax
  00094	75 07		 jne	 SHORT $LN18@DoTrueCryp
  00096	8d 54 24 44	 lea	 edx, DWORD PTR _path$[esp+332]
  0009a	52		 push	 edx
  0009b	ff d7		 call	 edi
$LN18@DoTrueCryp:

; 554  : 	}
; 555  : 
; 556  : 	/* TrueCrypt Format.exe */
; 557  : 	if (_snprintf (path, sizeof (path) - 1, "%s%s", UninstallationPath, TC_APP_NAME_LEGACY " Format.exe") >= 0)

  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PLOADIIL@TrueCrypt?5Format?4exe?$AA@
  000a2	68 00 00 00 00	 push	 OFFSET ?UninstallationPath@@3PADA ; UninstallationPath
  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  000ac	8d 44 24 50	 lea	 eax, DWORD PTR _path$[esp+344]
  000b0	68 03 01 00 00	 push	 259			; 00000103H
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 __snprintf
  000bb	83 c4 14	 add	 esp, 20			; 00000014H
  000be	85 c0		 test	 eax, eax
  000c0	7c 39		 jl	 SHORT $LN25@DoTrueCryp

; 558  : 	{
; 559  : 		RemoveMessage (hwndDlg, path);

  000c2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  000c9	75 13		 jne	 SHORT $LN21@DoTrueCryp
  000cb	8d 4c 24 44	 lea	 ecx, DWORD PTR _path$[esp+332]
  000cf	51		 push	 ecx
  000d0	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  000d5	56		 push	 esi
  000d6	e8 00 00 00 00	 call	 _StatusMessageParam
  000db	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN21@DoTrueCryp:

; 560  : 		StatDeleteFile (path);

  000de	8d 54 24 0c	 lea	 edx, DWORD PTR _st$138079[esp+332]
  000e2	52		 push	 edx
  000e3	8d 44 24 48	 lea	 eax, DWORD PTR _path$[esp+336]
  000e7	50		 push	 eax
  000e8	e8 00 00 00 00	 call	 __stat64
  000ed	83 c4 08	 add	 esp, 8
  000f0	85 c0		 test	 eax, eax
  000f2	75 07		 jne	 SHORT $LN25@DoTrueCryp
  000f4	8d 4c 24 44	 lea	 ecx, DWORD PTR _path$[esp+332]
  000f8	51		 push	 ecx
  000f9	ff d7		 call	 edi
$LN25@DoTrueCryp:

; 561  : 	}
; 562  : 
; 563  : 	/* TrueCrypt Setup.exe */
; 564  : 	if (_snprintf (path, sizeof (path) - 1, "%s%s", UninstallationPath, TC_APP_NAME_LEGACY " Setup.exe") >= 0)

  000fb	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@NCPFOFMD@TrueCrypt?5Setup?4exe?$AA@
  00100	68 00 00 00 00	 push	 OFFSET ?UninstallationPath@@3PADA ; UninstallationPath
  00105	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  0010a	8d 54 24 50	 lea	 edx, DWORD PTR _path$[esp+344]
  0010e	68 03 01 00 00	 push	 259			; 00000103H
  00113	52		 push	 edx
  00114	e8 00 00 00 00	 call	 __snprintf
  00119	83 c4 14	 add	 esp, 20			; 00000014H
  0011c	85 c0		 test	 eax, eax
  0011e	7c 39		 jl	 SHORT $LN32@DoTrueCryp

; 565  : 	{
; 566  : 		RemoveMessage (hwndDlg, path);

  00120	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  00127	75 13		 jne	 SHORT $LN28@DoTrueCryp
  00129	8d 44 24 44	 lea	 eax, DWORD PTR _path$[esp+332]
  0012d	50		 push	 eax
  0012e	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  00133	56		 push	 esi
  00134	e8 00 00 00 00	 call	 _StatusMessageParam
  00139	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN28@DoTrueCryp:

; 567  : 		StatDeleteFile (path);

  0013c	8d 4c 24 0c	 lea	 ecx, DWORD PTR _st$138089[esp+332]
  00140	51		 push	 ecx
  00141	8d 54 24 48	 lea	 edx, DWORD PTR _path$[esp+336]
  00145	52		 push	 edx
  00146	e8 00 00 00 00	 call	 __stat64
  0014b	83 c4 08	 add	 esp, 8
  0014e	85 c0		 test	 eax, eax
  00150	75 07		 jne	 SHORT $LN32@DoTrueCryp
  00152	8d 44 24 44	 lea	 eax, DWORD PTR _path$[esp+332]
  00156	50		 push	 eax
  00157	ff d7		 call	 edi
$LN32@DoTrueCryp:

; 568  : 	}
; 569  : 
; 570  : 	/* TrueCrypt User Guide.pdf */
; 571  : 	if (_snprintf (path, sizeof (path) - 1, "%s%s", UninstallationPath, TC_APP_NAME_LEGACY " User Guide.pdf") >= 0)

  00159	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DAPCIKHM@TrueCrypt?5User?5Guide?4pdf?$AA@
  0015e	68 00 00 00 00	 push	 OFFSET ?UninstallationPath@@3PADA ; UninstallationPath
  00163	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  00168	8d 4c 24 50	 lea	 ecx, DWORD PTR _path$[esp+344]
  0016c	68 03 01 00 00	 push	 259			; 00000103H
  00171	51		 push	 ecx
  00172	e8 00 00 00 00	 call	 __snprintf
  00177	83 c4 14	 add	 esp, 20			; 00000014H
  0017a	85 c0		 test	 eax, eax
  0017c	7c 39		 jl	 SHORT $LN39@DoTrueCryp

; 572  : 	{
; 573  : 		RemoveMessage (hwndDlg, path);

  0017e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  00185	75 13		 jne	 SHORT $LN35@DoTrueCryp
  00187	8d 54 24 44	 lea	 edx, DWORD PTR _path$[esp+332]
  0018b	52		 push	 edx
  0018c	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  00191	56		 push	 esi
  00192	e8 00 00 00 00	 call	 _StatusMessageParam
  00197	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN35@DoTrueCryp:

; 574  : 		StatDeleteFile (path);

  0019a	8d 44 24 0c	 lea	 eax, DWORD PTR _st$138099[esp+332]
  0019e	50		 push	 eax
  0019f	8d 4c 24 48	 lea	 ecx, DWORD PTR _path$[esp+336]
  001a3	51		 push	 ecx
  001a4	e8 00 00 00 00	 call	 __stat64
  001a9	83 c4 08	 add	 esp, 8
  001ac	85 c0		 test	 eax, eax
  001ae	75 07		 jne	 SHORT $LN39@DoTrueCryp
  001b0	8d 54 24 44	 lea	 edx, DWORD PTR _path$[esp+332]
  001b4	52		 push	 edx
  001b5	ff d7		 call	 edi
$LN39@DoTrueCryp:

; 575  : 	}
; 576  : 
; 577  : 	if (strcmp(InstallationPath, UninstallationPath) != 0)

  001b7	b9 00 00 00 00	 mov	 ecx, OFFSET ?UninstallationPath@@3PADA ; UninstallationPath
  001bc	b8 00 00 00 00	 mov	 eax, OFFSET _InstallationPath
$LL71@DoTrueCryp:
  001c1	8a 10		 mov	 dl, BYTE PTR [eax]
  001c3	3a 11		 cmp	 dl, BYTE PTR [ecx]
  001c5	75 1a		 jne	 SHORT $LN72@DoTrueCryp
  001c7	84 d2		 test	 dl, dl
  001c9	74 12		 je	 SHORT $LN73@DoTrueCryp
  001cb	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  001ce	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  001d1	75 0e		 jne	 SHORT $LN72@DoTrueCryp
  001d3	83 c0 02	 add	 eax, 2
  001d6	83 c1 02	 add	 ecx, 2
  001d9	84 d2		 test	 dl, dl
  001db	75 e4		 jne	 SHORT $LL71@DoTrueCryp
$LN73@DoTrueCryp:
  001dd	33 c0		 xor	 eax, eax
  001df	eb 05		 jmp	 SHORT $LN74@DoTrueCryp
$LN72@DoTrueCryp:
  001e1	1b c0		 sbb	 eax, eax
  001e3	83 d8 ff	 sbb	 eax, -1
$LN74@DoTrueCryp:
  001e6	85 c0		 test	 eax, eax
  001e8	0f 84 b2 01 00
	00		 je	 $LN78@DoTrueCryp

; 578  : 	{
; 579  : 		/* truecrypt.sys */
; 580  : 		if (_snprintf (path, sizeof (path) - 1, "%s%s", UninstallationPath, "truecrypt.sys") >= 0)

  001ee	68 00 00 00 00	 push	 OFFSET ??_C@_0O@OJENBJKN@truecrypt?4sys?$AA@
  001f3	68 00 00 00 00	 push	 OFFSET ?UninstallationPath@@3PADA ; UninstallationPath
  001f8	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  001fd	8d 44 24 50	 lea	 eax, DWORD PTR _path$[esp+344]
  00201	68 03 01 00 00	 push	 259			; 00000103H
  00206	50		 push	 eax
  00207	e8 00 00 00 00	 call	 __snprintf
  0020c	83 c4 14	 add	 esp, 20			; 00000014H
  0020f	85 c0		 test	 eax, eax
  00211	7c 39		 jl	 SHORT $LN46@DoTrueCryp

; 581  : 		{
; 582  : 			RemoveMessage (hwndDlg, path);

  00213	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  0021a	75 13		 jne	 SHORT $LN42@DoTrueCryp
  0021c	8d 4c 24 44	 lea	 ecx, DWORD PTR _path$[esp+332]
  00220	51		 push	 ecx
  00221	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  00226	56		 push	 esi
  00227	e8 00 00 00 00	 call	 _StatusMessageParam
  0022c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN42@DoTrueCryp:

; 583  : 			StatDeleteFile (path);

  0022f	8d 54 24 0c	 lea	 edx, DWORD PTR _st$138109[esp+332]
  00233	52		 push	 edx
  00234	8d 44 24 48	 lea	 eax, DWORD PTR _path$[esp+336]
  00238	50		 push	 eax
  00239	e8 00 00 00 00	 call	 __stat64
  0023e	83 c4 08	 add	 esp, 8
  00241	85 c0		 test	 eax, eax
  00243	75 07		 jne	 SHORT $LN46@DoTrueCryp
  00245	8d 4c 24 44	 lea	 ecx, DWORD PTR _path$[esp+332]
  00249	51		 push	 ecx
  0024a	ff d7		 call	 edi
$LN46@DoTrueCryp:

; 584  : 		}
; 585  : 
; 586  : 		/* truecrypt-x64.sys */
; 587  : 		if (_snprintf (path, sizeof (path) - 1, "%s%s", UninstallationPath, "truecrypt-x64.sys") >= 0)

  0024c	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KMEHMKJJ@truecrypt?9x64?4sys?$AA@
  00251	68 00 00 00 00	 push	 OFFSET ?UninstallationPath@@3PADA ; UninstallationPath
  00256	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  0025b	8d 54 24 50	 lea	 edx, DWORD PTR _path$[esp+344]
  0025f	68 03 01 00 00	 push	 259			; 00000103H
  00264	52		 push	 edx
  00265	e8 00 00 00 00	 call	 __snprintf
  0026a	83 c4 14	 add	 esp, 20			; 00000014H
  0026d	85 c0		 test	 eax, eax
  0026f	7c 39		 jl	 SHORT $LN53@DoTrueCryp

; 588  : 		{
; 589  : 			RemoveMessage (hwndDlg, path);

  00271	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  00278	75 13		 jne	 SHORT $LN49@DoTrueCryp
  0027a	8d 44 24 44	 lea	 eax, DWORD PTR _path$[esp+332]
  0027e	50		 push	 eax
  0027f	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  00284	56		 push	 esi
  00285	e8 00 00 00 00	 call	 _StatusMessageParam
  0028a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN49@DoTrueCryp:

; 590  : 			StatDeleteFile (path);

  0028d	8d 4c 24 0c	 lea	 ecx, DWORD PTR _st$138119[esp+332]
  00291	51		 push	 ecx
  00292	8d 54 24 48	 lea	 edx, DWORD PTR _path$[esp+336]
  00296	52		 push	 edx
  00297	e8 00 00 00 00	 call	 __stat64
  0029c	83 c4 08	 add	 esp, 8
  0029f	85 c0		 test	 eax, eax
  002a1	75 07		 jne	 SHORT $LN53@DoTrueCryp
  002a3	8d 44 24 44	 lea	 eax, DWORD PTR _path$[esp+332]
  002a7	50		 push	 eax
  002a8	ff d7		 call	 edi
$LN53@DoTrueCryp:

; 591  : 		}
; 592  : 
; 593  : 		/* License.txt */
; 594  : 		if (_snprintf (path, sizeof (path) - 1, "%s%s", UninstallationPath, "License.txt") >= 0)

  002aa	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HNDLNFKG@License?4txt?$AA@
  002af	68 00 00 00 00	 push	 OFFSET ?UninstallationPath@@3PADA ; UninstallationPath
  002b4	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  002b9	8d 4c 24 50	 lea	 ecx, DWORD PTR _path$[esp+344]
  002bd	68 03 01 00 00	 push	 259			; 00000103H
  002c2	51		 push	 ecx
  002c3	e8 00 00 00 00	 call	 __snprintf
  002c8	83 c4 14	 add	 esp, 20			; 00000014H
  002cb	85 c0		 test	 eax, eax
  002cd	7c 39		 jl	 SHORT $LN60@DoTrueCryp

; 595  : 		{
; 596  : 			RemoveMessage (hwndDlg, path);

  002cf	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  002d6	75 13		 jne	 SHORT $LN56@DoTrueCryp
  002d8	8d 54 24 44	 lea	 edx, DWORD PTR _path$[esp+332]
  002dc	52		 push	 edx
  002dd	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  002e2	56		 push	 esi
  002e3	e8 00 00 00 00	 call	 _StatusMessageParam
  002e8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN56@DoTrueCryp:

; 597  : 			StatDeleteFile (path);

  002eb	8d 44 24 0c	 lea	 eax, DWORD PTR _st$138129[esp+332]
  002ef	50		 push	 eax
  002f0	8d 4c 24 48	 lea	 ecx, DWORD PTR _path$[esp+336]
  002f4	51		 push	 ecx
  002f5	e8 00 00 00 00	 call	 __stat64
  002fa	83 c4 08	 add	 esp, 8
  002fd	85 c0		 test	 eax, eax
  002ff	75 07		 jne	 SHORT $LN60@DoTrueCryp
  00301	8d 54 24 44	 lea	 edx, DWORD PTR _path$[esp+332]
  00305	52		 push	 edx
  00306	ff d7		 call	 edi
$LN60@DoTrueCryp:

; 598  : 		}
; 599  : 
; 600  : 		strcpy(path, UninstallationPath);

  00308	33 c0		 xor	 eax, eax
  0030a	8d 9b 00 00 00
	00		 npad	 6
$LL13@DoTrueCryp:
  00310	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR ?UninstallationPath@@3PADA[eax]
  00316	88 4c 04 44	 mov	 BYTE PTR _path$[esp+eax+332], cl
  0031a	40		 inc	 eax
  0031b	84 c9		 test	 cl, cl
  0031d	75 f1		 jne	 SHORT $LL13@DoTrueCryp

; 601  : 
; 602  : 		/* Remove trailing backslash. */
; 603  : 		size_t len = strlen (path);

  0031f	8d 44 24 44	 lea	 eax, DWORD PTR _path$[esp+332]
  00323	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL75@DoTrueCryp:
  00326	8a 08		 mov	 cl, BYTE PTR [eax]
  00328	40		 inc	 eax
  00329	84 c9		 test	 cl, cl
  0032b	75 f9		 jne	 SHORT $LL75@DoTrueCryp
  0032d	2b c2		 sub	 eax, edx

; 604  : 		if (path[len - 1] == '\\')

  0032f	80 7c 04 43 5c	 cmp	 BYTE PTR _path$[esp+eax+331], 92 ; 0000005cH
  00334	8d 44 04 43	 lea	 eax, DWORD PTR _path$[esp+eax+331]
  00338	75 02		 jne	 SHORT $LN2@DoTrueCryp

; 605  : 			path[len - 1] = 0;

  0033a	88 08		 mov	 BYTE PTR [eax], cl
$LN2@DoTrueCryp:

; 606  : 
; 607  : 		/* Remove directory */
; 608  : 		RemoveMessage (hwndDlg, path);

  0033c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  00343	75 13		 jne	 SHORT $LN63@DoTrueCryp
  00345	8d 44 24 44	 lea	 eax, DWORD PTR _path$[esp+332]
  00349	50		 push	 eax
  0034a	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  0034f	56		 push	 esi
  00350	e8 00 00 00 00	 call	 _StatusMessageParam
  00355	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN63@DoTrueCryp:

; 609  : 		if (!StatRemoveDirectory (path))

  00358	8d 4c 24 0c	 lea	 ecx, DWORD PTR _st$138138[esp+332]
  0035c	51		 push	 ecx
  0035d	8d 54 24 48	 lea	 edx, DWORD PTR _path$[esp+336]
  00361	52		 push	 edx
  00362	e8 00 00 00 00	 call	 __stat64
  00367	83 c4 08	 add	 esp, 8
  0036a	85 c0		 test	 eax, eax
  0036c	75 32		 jne	 SHORT $LN78@DoTrueCryp
  0036e	8d 44 24 44	 lea	 eax, DWORD PTR _path$[esp+332]
  00372	50		 push	 eax
  00373	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RemoveDirectoryA@4
  00379	85 c0		 test	 eax, eax
  0037b	75 23		 jne	 SHORT $LN78@DoTrueCryp

; 610  : 		{
; 611  : 			handleWin32Error (hwndDlg);

  0037d	56		 push	 esi
  0037e	e8 00 00 00 00	 call	 _handleWin32Error
  00383	83 c4 04	 add	 esp, 4
  00386	5f		 pop	 edi
  00387	5e		 pop	 esi

; 612  : 			bOK = FALSE;

  00388	33 c0		 xor	 eax, eax
  0038a	5b		 pop	 ebx

; 613  : 		}
; 614  : 	}
; 615  : 
; 616  : 	return bOK;
; 617  : }

  0038b	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+320]
  00392	33 cc		 xor	 ecx, esp
  00394	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00399	81 c4 40 01 00
	00		 add	 esp, 320		; 00000140H
  0039f	c3		 ret	 0
$LN78@DoTrueCryp:
  003a0	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+332]
  003a7	5f		 pop	 edi
  003a8	5e		 pop	 esi
  003a9	8b c3		 mov	 eax, ebx
  003ab	5b		 pop	 ebx
  003ac	33 cc		 xor	 ecx, esp
  003ae	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003b3	81 c4 40 01 00
	00		 add	 esp, 320		; 00000140H
  003b9	c3		 ret	 0
_DoTrueCryptFilesUninstall ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@LLMHDMAL@COM_REG_FAILED?$AA@		; `string'
PUBLIC	??_C@_0BD@HFNFAFOP@REG_INSTALL_FAILED?$AA@	; `string'
PUBLIC	??_C@_0BB@GIJFLPKB@MigrationVersion?$AA@	; `string'
PUBLIC	??_C@_0O@PNHONFDO@MigrationPath?$AA@		; `string'
PUBLIC	??_C@_0BB@FKJFEMO@InstallationPath?$AA@		; `string'
PUBLIC	??_C@_0BE@GEGOEFMH@Software?2CipherShed?$AA@	; `string'
PUBLIC	??_C@_09PNIDBPNC@Publisher?$AA@			; `string'
PUBLIC	??_C@_0BD@GIJEKPBA@CipherShed?5Project?$AA@	; `string'
PUBLIC	??_C@_0M@MLHPPPJP@DisplayName?$AA@		; `string'
PUBLIC	??_C@_0M@DDCGOGKB@DisplayIcon?$AA@		; `string'
PUBLIC	??_C@_0BJ@BAIMPNHC@?$CC?$CFsCipherShed?9Setup?4exe?$CC?$AA@ ; `string'
PUBLIC	??_C@_0L@OGHNHFGG@ModifyPath?$AA@		; `string'
PUBLIC	??_C@_0BM@MPJKHKFC@?$CC?$CFsCipherShed?9Setup?4exe?$CC?5?1c?$AA@ ; `string'
PUBLIC	??_C@_0BA@OJMJCMCH@UninstallString?$AA@		; `string'
PUBLIC	??_C@_0BM@NDACMPIF@?$CC?$CFsCipherShed?9Setup?4exe?$CC?5?1u?$AA@ ; `string'
PUBLIC	??_C@_0N@CIJCJNDA@URLInfoAbout?$AA@		; `string'
PUBLIC	??_C@_0BI@INHGIDBI@https?3?1?1ciphershed?4org?1?$AA@ ; `string'
PUBLIC	??_C@_0P@BNDLMAIF@DisplayVersion?$AA@		; `string'
PUBLIC	??_C@_05JPPCAGFG@0?47?43?$AA@			; `string'
PUBLIC	??_C@_0DO@FLBIDANE@Software?2Microsoft?2Windows?2Curre@ ; `string'
PUBLIC	??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@		; `string'
PUBLIC	??_C@_0BF@MHIJGGNK@Software?2Classes?2?4tc?$AA@	; `string'
PUBLIC	??_C@_0BM@JMPIFFGC@?$CC?$CFsCipherShed?4exe?$CC?5?1v?5?$CC?$CF?$CF1?$CC?$AA@ ; `string'
PUBLIC	??_C@_0DE@JBHHIJAN@Software?2Classes?2TrueCryptVolume@ ; `string'
PUBLIC	??_C@_0BD@CFGFJIC@?$CFsCipherShed?4exe?01?$AA@	; `string'
PUBLIC	??_C@_0CN@DNPKJBAH@Software?2Classes?2TrueCryptVolume@ ; `string'
PUBLIC	??_C@_0P@LGELIEHB@AppUserModelID?$AA@		; `string'
PUBLIC	??_C@_03BMPLCLAP@?$CFws?$AA@			; `string'
PUBLIC	??_C@_1DK@KHACNMIN@?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AAP?$AAr?$AAo?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BC@NFHPLCKP@CipherShed?5Volume?$AA@	; `string'
PUBLIC	??_C@_0CB@JOIIBOEC@Software?2Classes?2TrueCryptVolume@ ; `string'
PUBLIC	??_C@_0L@FEEFGEIL@CipherShed?$AA@		; `string'
PUBLIC	??_C@_0O@LOPOCHJI@?5?1a?5favorites?$AA@		; `string'
PUBLIC	??_C@_0M@JCEADJGE@?5?1a?5devices?$AA@		; `string'
PUBLIC	??_C@_0CL@INAOHPON@?$CC?$CFsCipherShed?4exe?$CC?5?1q?5preference@ ; `string'
PUBLIC	??_C@_0P@MOFIICPA@?2TrueCrypt?4exe?$AA@		; `string'
PUBLIC	??_C@_09EMKKFGIH@TrueCrypt?$AA@			; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_01KICIPPFI@?2?$AA@			; `string'
PUBLIC	_hwndDlg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_DoRegInstall
EXTRN	_RegisterComServers:PROC
EXTRN	_IsOSAtLeast:PROC
EXTRN	_Error:PROC
EXTRN	__imp__SHChangeNotify@16:PROC
EXTRN	_ReadLocalMachineRegistryString:PROC
EXTRN	__imp__RegCloseKey@4:PROC
EXTRN	_sprintf_s:PROC
EXTRN	__imp__RegCreateKeyExA@36:PROC
EXTRN	__imp__RegSetValueExA@24:PROC
EXTRN	_DeleteRegistryValue:PROC
EXTRN	_WriteRegistryString:PROC
EXTRN	_ReadRegistryString:PROC
EXTRN	_GetStartupRegKeyName:PROC
EXTRN	_strcat_s:PROC
;	COMDAT ??_C@_0P@LLMHDMAL@COM_REG_FAILED?$AA@
CONST	SEGMENT
??_C@_0P@LLMHDMAL@COM_REG_FAILED?$AA@ DB 'COM_REG_FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HFNFAFOP@REG_INSTALL_FAILED?$AA@
CONST	SEGMENT
??_C@_0BD@HFNFAFOP@REG_INSTALL_FAILED?$AA@ DB 'REG_INSTALL_FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GIJFLPKB@MigrationVersion?$AA@
CONST	SEGMENT
??_C@_0BB@GIJFLPKB@MigrationVersion?$AA@ DB 'MigrationVersion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PNHONFDO@MigrationPath?$AA@
CONST	SEGMENT
??_C@_0O@PNHONFDO@MigrationPath?$AA@ DB 'MigrationPath', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FKJFEMO@InstallationPath?$AA@
CONST	SEGMENT
??_C@_0BB@FKJFEMO@InstallationPath?$AA@ DB 'InstallationPath', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GEGOEFMH@Software?2CipherShed?$AA@
CONST	SEGMENT
??_C@_0BE@GEGOEFMH@Software?2CipherShed?$AA@ DB 'Software\CipherShed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09PNIDBPNC@Publisher?$AA@
CONST	SEGMENT
??_C@_09PNIDBPNC@Publisher?$AA@ DB 'Publisher', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GIJEKPBA@CipherShed?5Project?$AA@
CONST	SEGMENT
??_C@_0BD@GIJEKPBA@CipherShed?5Project?$AA@ DB 'CipherShed Project', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MLHPPPJP@DisplayName?$AA@
CONST	SEGMENT
??_C@_0M@MLHPPPJP@DisplayName?$AA@ DB 'DisplayName', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DDCGOGKB@DisplayIcon?$AA@
CONST	SEGMENT
??_C@_0M@DDCGOGKB@DisplayIcon?$AA@ DB 'DisplayIcon', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BAIMPNHC@?$CC?$CFsCipherShed?9Setup?4exe?$CC?$AA@
CONST	SEGMENT
??_C@_0BJ@BAIMPNHC@?$CC?$CFsCipherShed?9Setup?4exe?$CC?$AA@ DB '"%sCipher'
	DB	'Shed-Setup.exe"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OGHNHFGG@ModifyPath?$AA@
CONST	SEGMENT
??_C@_0L@OGHNHFGG@ModifyPath?$AA@ DB 'ModifyPath', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MPJKHKFC@?$CC?$CFsCipherShed?9Setup?4exe?$CC?5?1c?$AA@
CONST	SEGMENT
??_C@_0BM@MPJKHKFC@?$CC?$CFsCipherShed?9Setup?4exe?$CC?5?1c?$AA@ DB '"%sC'
	DB	'ipherShed-Setup.exe" /c', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OJMJCMCH@UninstallString?$AA@
CONST	SEGMENT
??_C@_0BA@OJMJCMCH@UninstallString?$AA@ DB 'UninstallString', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NDACMPIF@?$CC?$CFsCipherShed?9Setup?4exe?$CC?5?1u?$AA@
CONST	SEGMENT
??_C@_0BM@NDACMPIF@?$CC?$CFsCipherShed?9Setup?4exe?$CC?5?1u?$AA@ DB '"%sC'
	DB	'ipherShed-Setup.exe" /u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CIJCJNDA@URLInfoAbout?$AA@
CONST	SEGMENT
??_C@_0N@CIJCJNDA@URLInfoAbout?$AA@ DB 'URLInfoAbout', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@INHGIDBI@https?3?1?1ciphershed?4org?1?$AA@
CONST	SEGMENT
??_C@_0BI@INHGIDBI@https?3?1?1ciphershed?4org?1?$AA@ DB 'https://ciphersh'
	DB	'ed.org/', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BNDLMAIF@DisplayVersion?$AA@
CONST	SEGMENT
??_C@_0P@BNDLMAIF@DisplayVersion?$AA@ DB 'DisplayVersion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05JPPCAGFG@0?47?43?$AA@
CONST	SEGMENT
??_C@_05JPPCAGFG@0?47?43?$AA@ DB '0.7.3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@FLBIDANE@Software?2Microsoft?2Windows?2Curre@
CONST	SEGMENT
??_C@_0DO@FLBIDANE@Software?2Microsoft?2Windows?2Curre@ DB 'Software\Micr'
	DB	'osoft\Windows\CurrentVersion\Uninstall\TrueCrypt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@
CONST	SEGMENT
??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@ DB 'TrueCryptVolume', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MHIJGGNK@Software?2Classes?2?4tc?$AA@
CONST	SEGMENT
??_C@_0BF@MHIJGGNK@Software?2Classes?2?4tc?$AA@ DB 'Software\Classes\.tc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JMPIFFGC@?$CC?$CFsCipherShed?4exe?$CC?5?1v?5?$CC?$CF?$CF1?$CC?$AA@
CONST	SEGMENT
??_C@_0BM@JMPIFFGC@?$CC?$CFsCipherShed?4exe?$CC?5?1v?5?$CC?$CF?$CF1?$CC?$AA@ DB '"'
	DB	'%sCipherShed.exe" /v "%%1"', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@JBHHIJAN@Software?2Classes?2TrueCryptVolume@
CONST	SEGMENT
??_C@_0DE@JBHHIJAN@Software?2Classes?2TrueCryptVolume@ DB 'Software\Class'
	DB	'es\TrueCryptVolume\Shell\open\command', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CFGFJIC@?$CFsCipherShed?4exe?01?$AA@
CONST	SEGMENT
??_C@_0BD@CFGFJIC@?$CFsCipherShed?4exe?01?$AA@ DB '%sCipherShed.exe,1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@DNPKJBAH@Software?2Classes?2TrueCryptVolume@
CONST	SEGMENT
??_C@_0CN@DNPKJBAH@Software?2Classes?2TrueCryptVolume@ DB 'Software\Class'
	DB	'es\TrueCryptVolume\DefaultIcon', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LGELIEHB@AppUserModelID?$AA@
CONST	SEGMENT
??_C@_0P@LGELIEHB@AppUserModelID?$AA@ DB 'AppUserModelID', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03BMPLCLAP@?$CFws?$AA@
CONST	SEGMENT
??_C@_03BMPLCLAP@?$CFws?$AA@ DB '%ws', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@KHACNMIN@?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AAP?$AAr?$AAo?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@KHACNMIN@?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AAP?$AAr?$AAo?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AA?$AA@ DB 'C'
	DB	00H, 'i', 00H, 'p', 00H, 'h', 00H, 'e', 00H, 'r', 00H, 'S', 00H
	DB	'h', 00H, 'e', 00H, 'd', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'j'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, '.', 00H, 'C', 00H, 'i', 00H
	DB	'p', 00H, 'h', 00H, 'e', 00H, 'r', 00H, 'S', 00H, 'h', 00H, 'e'
	DB	00H, 'd', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NFHPLCKP@CipherShed?5Volume?$AA@
CONST	SEGMENT
??_C@_0BC@NFHPLCKP@CipherShed?5Volume?$AA@ DB 'CipherShed Volume', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@JOIIBOEC@Software?2Classes?2TrueCryptVolume@
CONST	SEGMENT
??_C@_0CB@JOIIBOEC@Software?2Classes?2TrueCryptVolume@ DB 'Software\Class'
	DB	'es\TrueCryptVolume', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FEEFGEIL@CipherShed?$AA@
CONST	SEGMENT
??_C@_0L@FEEFGEIL@CipherShed?$AA@ DB 'CipherShed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LOPOCHJI@?5?1a?5favorites?$AA@
CONST	SEGMENT
??_C@_0O@LOPOCHJI@?5?1a?5favorites?$AA@ DB ' /a favorites', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JCEADJGE@?5?1a?5devices?$AA@
CONST	SEGMENT
??_C@_0M@JCEADJGE@?5?1a?5devices?$AA@ DB ' /a devices', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@INAOHPON@?$CC?$CFsCipherShed?4exe?$CC?5?1q?5preference@
CONST	SEGMENT
??_C@_0CL@INAOHPON@?$CC?$CFsCipherShed?4exe?$CC?5?1q?5preference@ DB '"%s'
	DB	'CipherShed.exe" /q preferences /a logon', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MOFIICPA@?2TrueCrypt?4exe?$AA@
CONST	SEGMENT
??_C@_0P@MOFIICPA@?2TrueCrypt?4exe?$AA@ DB '\TrueCrypt.exe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09EMKKFGIH@TrueCrypt?$AA@
CONST	SEGMENT
??_C@_09EMKKFGIH@TrueCrypt?$AA@ DB 'TrueCrypt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01KICIPPFI@?2?$AA@
CONST	SEGMENT
??_C@_01KICIPPFI@?2?$AA@ DB '\', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _DoRegInstall
_TEXT	SEGMENT
_hkey$ = -2164						; size = 4
_dw$ = -2160						; size = 4
_hwndDlg$GSCopy$ = -2156				; size = 4
_bOK$ = -2152						; size = 4
_typeClassSize$134358 = -2148				; size = 4
_szTmp$ = -2144						; size = 1040
_regk$134289 = -1104					; size = 64
_szDir$ = -1040						; size = 260
_exe$134290 = -780					; size = 520
_typeClass$134357 = -260				; size = 256
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_szDestDir$ = 12					; size = 4
_bInstallType$ = 16					; size = 4
_DoRegInstall PROC					; COMDAT

; 620  : {

  00000	81 ec 74 08 00
	00		 sub	 esp, 2164		; 00000874H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 70 08
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+2164], eax
  00014	53		 push	 ebx
  00015	56		 push	 esi

; 621  : 	char szDir[TC_MAX_PATH], *key;
; 622  : 	char szTmp[TC_MAX_PATH*4];
; 623  : 	HKEY hkey = 0;
; 624  : 	BOOL bSlash, bOK = FALSE;
; 625  : 	DWORD dw;
; 626  : 	int x;
; 627  : 
; 628  : 	strcpy (szDir, szDestDir);

  00016	8b b4 24 84 08
	00 00		 mov	 esi, DWORD PTR _szDestDir$[esp+2168]
  0001d	33 db		 xor	 ebx, ebx
  0001f	57		 push	 edi
  00020	8b bc 24 84 08
	00 00		 mov	 edi, DWORD PTR _hwndDlg$[esp+2172]
  00027	8d 94 24 70 04
	00 00		 lea	 edx, DWORD PTR _szDir$[esp+2176]
  0002e	89 7c 24 14	 mov	 DWORD PTR _hwndDlg$GSCopy$[esp+2176], edi
  00032	89 5c 24 0c	 mov	 DWORD PTR _hkey$[esp+2176], ebx
  00036	89 5c 24 18	 mov	 DWORD PTR _bOK$[esp+2176], ebx
  0003a	8b c6		 mov	 eax, esi
  0003c	2b d6		 sub	 edx, esi
  0003e	8b ff		 npad	 2
$LL62@DoRegInsta:
  00040	8a 08		 mov	 cl, BYTE PTR [eax]
  00042	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00045	40		 inc	 eax
  00046	3a cb		 cmp	 cl, bl
  00048	75 f6		 jne	 SHORT $LL62@DoRegInsta

; 629  : 	x = strlen (szDestDir);

  0004a	8b c6		 mov	 eax, esi
  0004c	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0004f	90		 npad	 1
$LL75@DoRegInsta:
  00050	8a 08		 mov	 cl, BYTE PTR [eax]
  00052	40		 inc	 eax
  00053	3a cb		 cmp	 cl, bl
  00055	75 f9		 jne	 SHORT $LL75@DoRegInsta
  00057	2b c2		 sub	 eax, edx

; 630  : 	if (szDestDir[x - 1] == '\\')

  00059	80 7c 30 ff 5c	 cmp	 BYTE PTR [eax+esi-1], 92 ; 0000005cH

; 631  : 		bSlash = TRUE;
; 632  : 	else

  0005e	74 1a		 je	 SHORT $LN57@DoRegInsta

; 633  : 		bSlash = FALSE;
; 634  : 
; 635  : 	if (bSlash == FALSE)
; 636  : 		strcat_s (szDir, sizeof(szDir), "\\");

  00060	68 00 00 00 00	 push	 OFFSET ??_C@_01KICIPPFI@?2?$AA@
  00065	8d 84 24 74 04
	00 00		 lea	 eax, DWORD PTR _szDir$[esp+2180]
  0006c	68 04 01 00 00	 push	 260			; 00000104H
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 _strcat_s
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN57@DoRegInsta:

; 637  : 
; 638  : 	/* CipherShed registry migration. */
; 639  : 	if (bCipherShedMigration)

  0007a	39 1d 00 00 00
	00		 cmp	 DWORD PTR _bCipherShedMigration, ebx
  00080	0f 84 c7 03 00
	00		 je	 $LN56@DoRegInsta

; 640  : 	{
; 641  : 		/* Gui autorun entry. */
; 642  : 		char regk[64];
; 643  : 		char exe[MAX_PATH * 2] = { 0 }; // terminating null character

  00086	68 07 02 00 00	 push	 519			; 00000207H
  0008b	8d 8c 24 79 05
	00 00		 lea	 ecx, DWORD PTR _exe$134290[esp+2181]
  00092	53		 push	 ebx
  00093	51		 push	 ecx
  00094	88 9c 24 80 05
	00 00		 mov	 BYTE PTR _exe$134290[esp+2188], bl
  0009b	e8 00 00 00 00	 call	 _memset

; 644  : 
; 645  : 		GetStartupRegKeyName (regk);

  000a0	8d 94 24 3c 04
	00 00		 lea	 edx, DWORD PTR _regk$134289[esp+2188]
  000a7	52		 push	 edx
  000a8	e8 00 00 00 00	 call	 _GetStartupRegKeyName

; 646  : 		ReadRegistryString (regk, "TrueCrypt", "", szTmp, sizeof (szTmp));

  000ad	68 10 04 00 00	 push	 1040			; 00000410H
  000b2	8d 44 24 34	 lea	 eax, DWORD PTR _szTmp$[esp+2196]
  000b6	50		 push	 eax
  000b7	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  000bc	8d 8c 24 4c 04
	00 00		 lea	 ecx, DWORD PTR _regk$134289[esp+2204]
  000c3	68 00 00 00 00	 push	 OFFSET ??_C@_09EMKKFGIH@TrueCrypt?$AA@
  000c8	51		 push	 ecx
  000c9	e8 00 00 00 00	 call	 _ReadRegistryString

; 647  : 
; 648  : 		if (strstr (szTmp, "\\TrueCrypt.exe") &&
; 649  : 			_snprintf (exe, sizeof (exe) - 32, "\"%sCipherShed.exe\" /q preferences /a logon", szDir) >= 0)

  000ce	8d 54 24 44	 lea	 edx, DWORD PTR _szTmp$[esp+2212]
  000d2	68 00 00 00 00	 push	 OFFSET ??_C@_0P@MOFIICPA@?2TrueCrypt?4exe?$AA@
  000d7	52		 push	 edx
  000d8	e8 00 00 00 00	 call	 _strstr
  000dd	83 c4 2c	 add	 esp, 44			; 0000002cH
  000e0	85 c0		 test	 eax, eax
  000e2	0f 84 a3 00 00
	00		 je	 $LN55@DoRegInsta
  000e8	8d 84 24 70 04
	00 00		 lea	 eax, DWORD PTR _szDir$[esp+2176]
  000ef	50		 push	 eax
  000f0	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@INAOHPON@?$CC?$CFsCipherShed?4exe?$CC?5?1q?5preference@
  000f5	8d 8c 24 7c 05
	00 00		 lea	 ecx, DWORD PTR _exe$134290[esp+2184]
  000fc	68 e8 01 00 00	 push	 488			; 000001e8H
  00101	51		 push	 ecx
  00102	e8 00 00 00 00	 call	 __snprintf
  00107	83 c4 10	 add	 esp, 16			; 00000010H
  0010a	85 c0		 test	 eax, eax
  0010c	7c 7d		 jl	 SHORT $LN55@DoRegInsta

; 650  : 		{
; 651  : 			if (strstr (szTmp, " /a devices"))

  0010e	8d 54 24 20	 lea	 edx, DWORD PTR _szTmp$[esp+2176]
  00112	68 00 00 00 00	 push	 OFFSET ??_C@_0M@JCEADJGE@?5?1a?5devices?$AA@
  00117	52		 push	 edx
  00118	e8 00 00 00 00	 call	 _strstr
  0011d	83 c4 08	 add	 esp, 8
  00120	85 c0		 test	 eax, eax
  00122	74 1a		 je	 SHORT $LN54@DoRegInsta

; 652  : 				strcat_s (exe, sizeof(exe), " /a devices");

  00124	68 00 00 00 00	 push	 OFFSET ??_C@_0M@JCEADJGE@?5?1a?5devices?$AA@
  00129	8d 84 24 78 05
	00 00		 lea	 eax, DWORD PTR _exe$134290[esp+2180]
  00130	68 08 02 00 00	 push	 520			; 00000208H
  00135	50		 push	 eax
  00136	e8 00 00 00 00	 call	 _strcat_s
  0013b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN54@DoRegInsta:

; 653  : 			if (strstr (szTmp, " /a favorites"))

  0013e	8d 4c 24 20	 lea	 ecx, DWORD PTR _szTmp$[esp+2176]
  00142	68 00 00 00 00	 push	 OFFSET ??_C@_0O@LOPOCHJI@?5?1a?5favorites?$AA@
  00147	51		 push	 ecx
  00148	e8 00 00 00 00	 call	 _strstr
  0014d	83 c4 08	 add	 esp, 8
  00150	85 c0		 test	 eax, eax
  00152	74 1a		 je	 SHORT $LN53@DoRegInsta

; 654  : 				strcat_s (exe, sizeof(exe), " /a favorites");

  00154	68 00 00 00 00	 push	 OFFSET ??_C@_0O@LOPOCHJI@?5?1a?5favorites?$AA@
  00159	8d 94 24 78 05
	00 00		 lea	 edx, DWORD PTR _exe$134290[esp+2180]
  00160	68 08 02 00 00	 push	 520			; 00000208H
  00165	52		 push	 edx
  00166	e8 00 00 00 00	 call	 _strcat_s
  0016b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN53@DoRegInsta:

; 655  : 
; 656  : 			WriteRegistryString (regk, "CipherShed", exe);

  0016e	8d 84 24 74 05
	00 00		 lea	 eax, DWORD PTR _exe$134290[esp+2176]
  00175	50		 push	 eax
  00176	8d 8c 24 34 04
	00 00		 lea	 ecx, DWORD PTR _regk$134289[esp+2180]
  0017d	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FEEFGEIL@CipherShed?$AA@
  00182	51		 push	 ecx
  00183	e8 00 00 00 00	 call	 _WriteRegistryString
  00188	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN55@DoRegInsta:

; 657  : 		}
; 658  : 
; 659  : 		DeleteRegistryValue (regk, "TrueCrypt");

  0018b	8d 94 24 30 04
	00 00		 lea	 edx, DWORD PTR _regk$134289[esp+2176]
  00192	68 00 00 00 00	 push	 OFFSET ??_C@_09EMKKFGIH@TrueCrypt?$AA@
  00197	52		 push	 edx
  00198	e8 00 00 00 00	 call	 _DeleteRegistryValue
  0019d	83 c4 08	 add	 esp, 8
$LN51@DoRegInsta:

; 677  : 	}
; 678  : 
; 679  : 	if (bInstallType)

  001a0	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__RegSetValueExA@24
  001a6	55		 push	 ebp
  001a7	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__RegCreateKeyExA@36
  001ad	39 9c 24 90 08
	00 00		 cmp	 DWORD PTR _bInstallType$[esp+2176], ebx
  001b4	0f 84 52 04 00
	00		 je	 $LN29@DoRegInsta

; 680  : 	{
; 681  : 
; 682  : 		key = "Software\\Classes\\TrueCryptVolume";
; 683  : 		RegMessage (hwndDlg, key);

  001ba	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@JOIIBOEC@Software?2Classes?2TrueCryptVolume@
  001bf	68 00 00 00 00	 push	 OFFSET ??_C@_0L@LFAEJJAB@ADDING_REG?$AA@
  001c4	57		 push	 edi
  001c5	e8 00 00 00 00	 call	 _StatusMessageParam
  001ca	83 c4 0c	 add	 esp, 12			; 0000000cH

; 684  : 		if (RegCreateKeyEx (HKEY_LOCAL_MACHINE,
; 685  : 				    key,
; 686  : 				    0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &dw) != ERROR_SUCCESS)

  001cd	8d 44 24 14	 lea	 eax, DWORD PTR _dw$[esp+2180]
  001d1	50		 push	 eax
  001d2	8d 4c 24 14	 lea	 ecx, DWORD PTR _hkey$[esp+2184]
  001d6	51		 push	 ecx
  001d7	53		 push	 ebx
  001d8	68 06 00 02 00	 push	 131078			; 00020006H
  001dd	53		 push	 ebx
  001de	53		 push	 ebx
  001df	53		 push	 ebx
  001e0	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@JOIIBOEC@Software?2Classes?2TrueCryptVolume@
  001e5	68 02 00 00 80	 push	 -2147483646		; 80000002H
  001ea	ff d5		 call	 ebp
  001ec	85 c0		 test	 eax, eax
  001ee	0f 85 95 07 00
	00		 jne	 $error$134319

; 687  : 			goto error;
; 688  : 
; 689  : 		strcpy (szTmp, "CipherShed Volume");

  001f4	a1 04 00 00 00	 mov	 eax, DWORD PTR ??_C@_0BC@NFHPLCKP@CipherShed?5Volume?$AA@+4
  001f9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ??_C@_0BC@NFHPLCKP@CipherShed?5Volume?$AA@
  001ff	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_0BC@NFHPLCKP@CipherShed?5Volume?$AA@+8
  00205	89 44 24 28	 mov	 DWORD PTR _szTmp$[esp+2184], eax
  00209	66 a1 10 00 00
	00		 mov	 ax, WORD PTR ??_C@_0BC@NFHPLCKP@CipherShed?5Volume?$AA@+16
  0020f	89 54 24 24	 mov	 DWORD PTR _szTmp$[esp+2180], edx
  00213	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ??_C@_0BC@NFHPLCKP@CipherShed?5Volume?$AA@+12
  00219	66 89 44 24 34	 mov	 WORD PTR _szTmp$[esp+2196], ax

; 690  : 		if (RegSetValueEx (hkey, "", 0, REG_SZ, (BYTE *) szTmp, strlen (szTmp) + 1) != ERROR_SUCCESS)

  0021e	8d 44 24 24	 lea	 eax, DWORD PTR _szTmp$[esp+2180]
  00222	89 54 24 30	 mov	 DWORD PTR _szTmp$[esp+2192], edx
  00226	89 4c 24 2c	 mov	 DWORD PTR _szTmp$[esp+2188], ecx
  0022a	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0022d	8d 49 00	 npad	 3
$LL78@DoRegInsta:
  00230	8a 08		 mov	 cl, BYTE PTR [eax]
  00232	40		 inc	 eax
  00233	3a cb		 cmp	 cl, bl
  00235	75 f9		 jne	 SHORT $LL78@DoRegInsta
  00237	2b c2		 sub	 eax, edx
  00239	8b 54 24 10	 mov	 edx, DWORD PTR _hkey$[esp+2180]
  0023d	40		 inc	 eax
  0023e	50		 push	 eax
  0023f	8d 4c 24 28	 lea	 ecx, DWORD PTR _szTmp$[esp+2184]
  00243	51		 push	 ecx
  00244	6a 01		 push	 1
  00246	53		 push	 ebx
  00247	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0024c	52		 push	 edx
  0024d	ff d6		 call	 esi
  0024f	85 c0		 test	 eax, eax
  00251	0f 85 32 07 00
	00		 jne	 $error$134319

; 691  : 			goto error;
; 692  : 
; 693  : 		snprintf (szTmp, sizeof(szTmp), "%ws", TC_APPLICATION_ID);

  00257	68 00 00 00 00	 push	 OFFSET ??_C@_1DK@KHACNMIN@?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AAP?$AAr?$AAo?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AA?$AA@
  0025c	68 00 00 00 00	 push	 OFFSET ??_C@_03BMPLCLAP@?$CFws?$AA@
  00261	8d 44 24 2c	 lea	 eax, DWORD PTR _szTmp$[esp+2188]
  00265	68 10 04 00 00	 push	 1040			; 00000410H
  0026a	50		 push	 eax
  0026b	e8 00 00 00 00	 call	 _sprintf_s

; 694  : 		if (RegSetValueEx (hkey, "AppUserModelID", 0, REG_SZ, (BYTE *) szTmp, strlen (szTmp) + 1) != ERROR_SUCCESS)

  00270	8d 44 24 34	 lea	 eax, DWORD PTR _szTmp$[esp+2196]
  00274	83 c4 10	 add	 esp, 16			; 00000010H
  00277	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0027a	8d 9b 00 00 00
	00		 npad	 6
$LL79@DoRegInsta:
  00280	8a 08		 mov	 cl, BYTE PTR [eax]
  00282	40		 inc	 eax
  00283	3a cb		 cmp	 cl, bl
  00285	75 f9		 jne	 SHORT $LL79@DoRegInsta
  00287	2b c2		 sub	 eax, edx
  00289	8b 54 24 10	 mov	 edx, DWORD PTR _hkey$[esp+2180]
  0028d	40		 inc	 eax
  0028e	50		 push	 eax
  0028f	8d 4c 24 28	 lea	 ecx, DWORD PTR _szTmp$[esp+2184]
  00293	51		 push	 ecx
  00294	6a 01		 push	 1
  00296	53		 push	 ebx
  00297	68 00 00 00 00	 push	 OFFSET ??_C@_0P@LGELIEHB@AppUserModelID?$AA@
  0029c	52		 push	 edx
  0029d	ff d6		 call	 esi
  0029f	85 c0		 test	 eax, eax
  002a1	0f 85 e2 06 00
	00		 jne	 $error$134319

; 695  : 			goto error;
; 696  : 
; 697  : 		RegCloseKey (hkey);

  002a7	8b 44 24 10	 mov	 eax, DWORD PTR _hkey$[esp+2180]
  002ab	50		 push	 eax
  002ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 698  : 		hkey = 0;
; 699  : 
; 700  : 		key = "Software\\Classes\\TrueCryptVolume\\DefaultIcon";
; 701  : 		RegMessage (hwndDlg, key);

  002b2	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@DNPKJBAH@Software?2Classes?2TrueCryptVolume@
  002b7	57		 push	 edi
  002b8	89 5c 24 18	 mov	 DWORD PTR _hkey$[esp+2188], ebx
  002bc	e8 00 00 00 00	 call	 _RegMessage
  002c1	83 c4 08	 add	 esp, 8

; 702  : 		if (RegCreateKeyEx (HKEY_LOCAL_MACHINE,
; 703  : 				    key,
; 704  : 				    0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &dw) != ERROR_SUCCESS)

  002c4	8d 4c 24 14	 lea	 ecx, DWORD PTR _dw$[esp+2180]
  002c8	51		 push	 ecx
  002c9	8d 54 24 14	 lea	 edx, DWORD PTR _hkey$[esp+2184]
  002cd	52		 push	 edx
  002ce	53		 push	 ebx
  002cf	68 06 00 02 00	 push	 131078			; 00020006H
  002d4	53		 push	 ebx
  002d5	53		 push	 ebx
  002d6	53		 push	 ebx
  002d7	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@DNPKJBAH@Software?2Classes?2TrueCryptVolume@
  002dc	68 02 00 00 80	 push	 -2147483646		; 80000002H
  002e1	ff d5		 call	 ebp
  002e3	85 c0		 test	 eax, eax
  002e5	0f 85 9e 06 00
	00		 jne	 $error$134319

; 705  : 			goto error;
; 706  : 
; 707  : 		snprintf (szTmp, sizeof(szTmp), "%sCipherShed.exe,1", szDir);

  002eb	8d 84 24 74 04
	00 00		 lea	 eax, DWORD PTR _szDir$[esp+2180]
  002f2	50		 push	 eax
  002f3	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@CFGFJIC@?$CFsCipherShed?4exe?01?$AA@
  002f8	8d 4c 24 2c	 lea	 ecx, DWORD PTR _szTmp$[esp+2188]
  002fc	68 10 04 00 00	 push	 1040			; 00000410H
  00301	51		 push	 ecx
  00302	e8 00 00 00 00	 call	 _sprintf_s

; 708  : 		if (RegSetValueEx (hkey, "", 0, REG_SZ, (BYTE *) szTmp, strlen (szTmp) + 1) != ERROR_SUCCESS)

  00307	8d 44 24 34	 lea	 eax, DWORD PTR _szTmp$[esp+2196]
  0030b	83 c4 10	 add	 esp, 16			; 00000010H
  0030e	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL80@DoRegInsta:
  00311	8a 08		 mov	 cl, BYTE PTR [eax]
  00313	40		 inc	 eax
  00314	3a cb		 cmp	 cl, bl
  00316	75 f9		 jne	 SHORT $LL80@DoRegInsta
  00318	2b c2		 sub	 eax, edx
  0031a	40		 inc	 eax
  0031b	50		 push	 eax
  0031c	8b 44 24 14	 mov	 eax, DWORD PTR _hkey$[esp+2184]
  00320	8d 54 24 28	 lea	 edx, DWORD PTR _szTmp$[esp+2184]
  00324	52		 push	 edx
  00325	6a 01		 push	 1
  00327	53		 push	 ebx
  00328	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0032d	50		 push	 eax
  0032e	ff d6		 call	 esi
  00330	85 c0		 test	 eax, eax
  00332	0f 85 51 06 00
	00		 jne	 $error$134319

; 709  : 			goto error;
; 710  : 
; 711  : 		RegCloseKey (hkey);

  00338	8b 4c 24 10	 mov	 ecx, DWORD PTR _hkey$[esp+2180]
  0033c	51		 push	 ecx
  0033d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 712  : 		hkey = 0;
; 713  : 
; 714  : 		key = "Software\\Classes\\TrueCryptVolume\\Shell\\open\\command";
; 715  : 		RegMessage (hwndDlg, key);

  00343	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@JBHHIJAN@Software?2Classes?2TrueCryptVolume@
  00348	57		 push	 edi
  00349	89 5c 24 18	 mov	 DWORD PTR _hkey$[esp+2188], ebx
  0034d	e8 00 00 00 00	 call	 _RegMessage
  00352	83 c4 08	 add	 esp, 8

; 716  : 		if (RegCreateKeyEx (HKEY_LOCAL_MACHINE,
; 717  : 				    key,
; 718  : 				    0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &dw) != ERROR_SUCCESS)

  00355	8d 54 24 14	 lea	 edx, DWORD PTR _dw$[esp+2180]
  00359	52		 push	 edx
  0035a	8d 44 24 14	 lea	 eax, DWORD PTR _hkey$[esp+2184]
  0035e	50		 push	 eax
  0035f	53		 push	 ebx
  00360	68 06 00 02 00	 push	 131078			; 00020006H
  00365	53		 push	 ebx
  00366	53		 push	 ebx
  00367	53		 push	 ebx
  00368	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@JBHHIJAN@Software?2Classes?2TrueCryptVolume@
  0036d	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00372	ff d5		 call	 ebp
  00374	85 c0		 test	 eax, eax
  00376	0f 85 0d 06 00
	00		 jne	 $error$134319

; 719  : 			goto error;
; 720  : 
; 721  : 		snprintf (szTmp, sizeof(szTmp), "\"%sCipherShed.exe\" /v \"%%1\"", szDir );

  0037c	8d 8c 24 74 04
	00 00		 lea	 ecx, DWORD PTR _szDir$[esp+2180]
  00383	51		 push	 ecx
  00384	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@JMPIFFGC@?$CC?$CFsCipherShed?4exe?$CC?5?1v?5?$CC?$CF?$CF1?$CC?$AA@
  00389	8d 54 24 2c	 lea	 edx, DWORD PTR _szTmp$[esp+2188]
  0038d	68 10 04 00 00	 push	 1040			; 00000410H
  00392	52		 push	 edx
  00393	e8 00 00 00 00	 call	 _sprintf_s

; 722  : 		if (RegSetValueEx (hkey, "", 0, REG_SZ, (BYTE *) szTmp, strlen (szTmp) + 1) != ERROR_SUCCESS)

  00398	8d 44 24 34	 lea	 eax, DWORD PTR _szTmp$[esp+2196]
  0039c	83 c4 10	 add	 esp, 16			; 00000010H
  0039f	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL81@DoRegInsta:
  003a2	8a 08		 mov	 cl, BYTE PTR [eax]
  003a4	40		 inc	 eax
  003a5	3a cb		 cmp	 cl, bl
  003a7	75 f9		 jne	 SHORT $LL81@DoRegInsta
  003a9	8b 4c 24 10	 mov	 ecx, DWORD PTR _hkey$[esp+2180]
  003ad	2b c2		 sub	 eax, edx
  003af	40		 inc	 eax
  003b0	50		 push	 eax
  003b1	8d 44 24 28	 lea	 eax, DWORD PTR _szTmp$[esp+2184]
  003b5	50		 push	 eax
  003b6	6a 01		 push	 1
  003b8	53		 push	 ebx
  003b9	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  003be	51		 push	 ecx
  003bf	ff d6		 call	 esi
  003c1	85 c0		 test	 eax, eax
  003c3	0f 85 c0 05 00
	00		 jne	 $error$134319

; 723  : 			goto error;
; 724  : 
; 725  : 		RegCloseKey (hkey);

  003c9	8b 54 24 10	 mov	 edx, DWORD PTR _hkey$[esp+2180]
  003cd	52		 push	 edx
  003ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 726  : 		hkey = 0;
; 727  : 
; 728  : 		key = "Software\\Classes\\.tc";
; 729  : 		BOOL typeClassChanged = TRUE;
; 730  : 		char typeClass[256];
; 731  : 		DWORD typeClassSize = sizeof (typeClass);
; 732  : 
; 733  : 		if (ReadLocalMachineRegistryString (key, "", typeClass, &typeClassSize) && typeClassSize > 0 && strcmp (typeClass, "TrueCryptVolume") == 0)

  003d4	8d 44 24 20	 lea	 eax, DWORD PTR _typeClassSize$134358[esp+2180]
  003d8	50		 push	 eax
  003d9	8d 8c 24 84 07
	00 00		 lea	 ecx, DWORD PTR _typeClass$134357[esp+2184]
  003e0	51		 push	 ecx
  003e1	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  003e6	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@MHIJGGNK@Software?2Classes?2?4tc?$AA@
  003eb	89 5c 24 20	 mov	 DWORD PTR _hkey$[esp+2196], ebx
  003ef	bf 01 00 00 00	 mov	 edi, 1
  003f4	c7 44 24 30 00
	01 00 00	 mov	 DWORD PTR _typeClassSize$134358[esp+2196], 256 ; 00000100H
  003fc	e8 00 00 00 00	 call	 _ReadLocalMachineRegistryString
  00401	83 c4 10	 add	 esp, 16			; 00000010H
  00404	85 c0		 test	 eax, eax
  00406	0f 84 4c 01 00
	00		 je	 $LN34@DoRegInsta
  0040c	39 5c 24 20	 cmp	 DWORD PTR _typeClassSize$134358[esp+2180], ebx
  00410	0f 86 42 01 00
	00		 jbe	 $LN34@DoRegInsta
  00416	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@
  0041b	8d 8c 24 80 07
	00 00		 lea	 ecx, DWORD PTR _typeClass$134357[esp+2180]
$LL82@DoRegInsta:
  00422	8a 01		 mov	 al, BYTE PTR [ecx]
  00424	3a 02		 cmp	 al, BYTE PTR [edx]
  00426	0f 85 21 01 00
	00		 jne	 $LN83@DoRegInsta
  0042c	3a c3		 cmp	 al, bl
  0042e	74 16		 je	 SHORT $LN84@DoRegInsta
  00430	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00433	3a 42 01	 cmp	 al, BYTE PTR [edx+1]
  00436	0f 85 11 01 00
	00		 jne	 $LN83@DoRegInsta
  0043c	83 c1 02	 add	 ecx, 2
  0043f	83 c2 02	 add	 edx, 2
  00442	3a c3		 cmp	 al, bl
  00444	75 dc		 jne	 SHORT $LL82@DoRegInsta
$LN84@DoRegInsta:
  00446	33 c0		 xor	 eax, eax
  00448	e9 05 01 00 00	 jmp	 $LN85@DoRegInsta
$LN56@DoRegInsta:

; 660  : 	}
; 661  : 
; 662  : 	else if (SystemEncryptionUpdate)

  0044d	39 1d 00 00 00
	00		 cmp	 DWORD PTR _SystemEncryptionUpdate, ebx
  00453	0f 84 47 fd ff
	ff		 je	 $LN51@DoRegInsta

; 663  : 	{
; 664  : 		if (RegCreateKeyEx (HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\TrueCrypt",
; 665  : 			0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &dw) == ERROR_SUCCESS)

  00459	8d 44 24 10	 lea	 eax, DWORD PTR _dw$[esp+2176]
  0045d	50		 push	 eax
  0045e	8d 4c 24 10	 lea	 ecx, DWORD PTR _hkey$[esp+2180]
  00462	51		 push	 ecx
  00463	53		 push	 ebx
  00464	68 06 00 02 00	 push	 131078			; 00020006H
  00469	53		 push	 ebx
  0046a	53		 push	 ebx
  0046b	53		 push	 ebx
  0046c	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@FLBIDANE@Software?2Microsoft?2Windows?2Curre@
  00471	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00476	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCreateKeyExA@36
  0047c	85 c0		 test	 eax, eax
  0047e	0f 85 ac 00 00
	00		 jne	 $LN50@DoRegInsta

; 666  : 		{
; 667  : 			strcpy (szTmp, VERSION_STRING);

  00484	66 a1 04 00 00
	00		 mov	 ax, WORD PTR ??_C@_05JPPCAGFG@0?47?43?$AA@+4
  0048a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ??_C@_05JPPCAGFG@0?47?43?$AA@
  00490	66 89 44 24 24	 mov	 WORD PTR _szTmp$[esp+2180], ax

; 668  : 			RegSetValueEx (hkey, "DisplayVersion", 0, REG_SZ, (BYTE *) szTmp, strlen (szTmp) + 1);

  00495	8d 44 24 20	 lea	 eax, DWORD PTR _szTmp$[esp+2176]
  00499	89 54 24 20	 mov	 DWORD PTR _szTmp$[esp+2176], edx
  0049d	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL76@DoRegInsta:
  004a0	8a 08		 mov	 cl, BYTE PTR [eax]
  004a2	40		 inc	 eax
  004a3	3a cb		 cmp	 cl, bl
  004a5	75 f9		 jne	 SHORT $LL76@DoRegInsta
  004a7	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__RegSetValueExA@24
  004ad	2b c2		 sub	 eax, edx
  004af	8b 54 24 0c	 mov	 edx, DWORD PTR _hkey$[esp+2176]
  004b3	40		 inc	 eax
  004b4	50		 push	 eax
  004b5	8d 4c 24 24	 lea	 ecx, DWORD PTR _szTmp$[esp+2180]
  004b9	51		 push	 ecx
  004ba	6a 01		 push	 1
  004bc	53		 push	 ebx
  004bd	68 00 00 00 00	 push	 OFFSET ??_C@_0P@BNDLMAIF@DisplayVersion?$AA@
  004c2	52		 push	 edx
  004c3	ff d6		 call	 esi

; 669  : 
; 670  : 			strcpy (szTmp, TC_HOMEPAGE);

  004c5	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_0BI@INHGIDBI@https?3?1?1ciphershed?4org?1?$AA@
  004ca	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR ??_C@_0BI@INHGIDBI@https?3?1?1ciphershed?4org?1?$AA@+8
  004d0	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_0BI@INHGIDBI@https?3?1?1ciphershed?4org?1?$AA@+4
  004d6	89 44 24 20	 mov	 DWORD PTR _szTmp$[esp+2176], eax
  004da	a1 0c 00 00 00	 mov	 eax, DWORD PTR ??_C@_0BI@INHGIDBI@https?3?1?1ciphershed?4org?1?$AA@+12
  004df	89 54 24 28	 mov	 DWORD PTR _szTmp$[esp+2184], edx
  004e3	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ??_C@_0BI@INHGIDBI@https?3?1?1ciphershed?4org?1?$AA@+20
  004e9	89 4c 24 24	 mov	 DWORD PTR _szTmp$[esp+2180], ecx
  004ed	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_0BI@INHGIDBI@https?3?1?1ciphershed?4org?1?$AA@+16
  004f3	89 44 24 2c	 mov	 DWORD PTR _szTmp$[esp+2188], eax

; 671  : 			RegSetValueEx (hkey, "URLInfoAbout", 0, REG_SZ, (BYTE *) szTmp, strlen (szTmp) + 1);

  004f7	8d 44 24 20	 lea	 eax, DWORD PTR _szTmp$[esp+2176]
  004fb	89 54 24 34	 mov	 DWORD PTR _szTmp$[esp+2196], edx
  004ff	89 4c 24 30	 mov	 DWORD PTR _szTmp$[esp+2192], ecx
  00503	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL77@DoRegInsta:
  00506	8a 08		 mov	 cl, BYTE PTR [eax]
  00508	40		 inc	 eax
  00509	3a cb		 cmp	 cl, bl
  0050b	75 f9		 jne	 SHORT $LL77@DoRegInsta
  0050d	8b 4c 24 0c	 mov	 ecx, DWORD PTR _hkey$[esp+2176]
  00511	2b c2		 sub	 eax, edx
  00513	40		 inc	 eax
  00514	50		 push	 eax
  00515	8d 44 24 24	 lea	 eax, DWORD PTR _szTmp$[esp+2180]
  00519	50		 push	 eax
  0051a	6a 01		 push	 1
  0051c	53		 push	 ebx
  0051d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@CIJCJNDA@URLInfoAbout?$AA@
  00522	51		 push	 ecx
  00523	ff d6		 call	 esi

; 672  : 
; 673  : 			RegCloseKey (hkey);

  00525	8b 54 24 0c	 mov	 edx, DWORD PTR _hkey$[esp+2176]
  00529	52		 push	 edx
  0052a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$LN50@DoRegInsta:
  00530	5f		 pop	 edi
  00531	5e		 pop	 esi

; 674  : 		}
; 675  : 
; 676  : 		return TRUE;

  00532	b8 01 00 00 00	 mov	 eax, 1
  00537	5b		 pop	 ebx

; 828  : 		}
; 829  : 	}
; 830  : 
; 831  : 	return bOK;
; 832  : }

  00538	8b 8c 24 70 08
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+2164]
  0053f	33 cc		 xor	 ecx, esp
  00541	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00546	81 c4 74 08 00
	00		 add	 esp, 2164		; 00000874H
  0054c	c3		 ret	 0
$LN83@DoRegInsta:

; 726  : 		hkey = 0;
; 727  : 
; 728  : 		key = "Software\\Classes\\.tc";
; 729  : 		BOOL typeClassChanged = TRUE;
; 730  : 		char typeClass[256];
; 731  : 		DWORD typeClassSize = sizeof (typeClass);
; 732  : 
; 733  : 		if (ReadLocalMachineRegistryString (key, "", typeClass, &typeClassSize) && typeClassSize > 0 && strcmp (typeClass, "TrueCryptVolume") == 0)

  0054d	1b c0		 sbb	 eax, eax
  0054f	83 d8 ff	 sbb	 eax, -1
$LN85@DoRegInsta:
  00552	3b c3		 cmp	 eax, ebx
  00554	75 02		 jne	 SHORT $LN34@DoRegInsta

; 734  : 			typeClassChanged = FALSE;

  00556	33 ff		 xor	 edi, edi
$LN34@DoRegInsta:

; 735  : 
; 736  : 		RegMessage (hwndDlg, key);

  00558	8b 54 24 18	 mov	 edx, DWORD PTR _hwndDlg$GSCopy$[esp+2180]
  0055c	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@MHIJGGNK@Software?2Classes?2?4tc?$AA@
  00561	52		 push	 edx
  00562	e8 00 00 00 00	 call	 _RegMessage
  00567	83 c4 08	 add	 esp, 8

; 737  : 		if (RegCreateKeyEx (HKEY_LOCAL_MACHINE,
; 738  : 				    key,
; 739  : 				    0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &dw) != ERROR_SUCCESS)

  0056a	8d 44 24 14	 lea	 eax, DWORD PTR _dw$[esp+2180]
  0056e	50		 push	 eax
  0056f	8d 4c 24 14	 lea	 ecx, DWORD PTR _hkey$[esp+2184]
  00573	51		 push	 ecx
  00574	53		 push	 ebx
  00575	68 06 00 02 00	 push	 131078			; 00020006H
  0057a	53		 push	 ebx
  0057b	53		 push	 ebx
  0057c	53		 push	 ebx
  0057d	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@MHIJGGNK@Software?2Classes?2?4tc?$AA@
  00582	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00587	ff d5		 call	 ebp
  00589	85 c0		 test	 eax, eax
  0058b	0f 85 f4 03 00
	00		 jne	 $LN97@DoRegInsta

; 740  : 			goto error;
; 741  : 
; 742  : 		strcpy (szTmp, "TrueCryptVolume");

  00591	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@
  00597	a1 04 00 00 00	 mov	 eax, DWORD PTR ??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@+4
  0059c	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@+8
  005a2	89 54 24 24	 mov	 DWORD PTR _szTmp$[esp+2180], edx
  005a6	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@+12
  005ac	89 44 24 28	 mov	 DWORD PTR _szTmp$[esp+2184], eax

; 743  : 		if (RegSetValueEx (hkey, "", 0, REG_SZ, (BYTE *) szTmp, strlen (szTmp) + 1) != ERROR_SUCCESS)

  005b0	8d 44 24 24	 lea	 eax, DWORD PTR _szTmp$[esp+2180]
  005b4	89 54 24 30	 mov	 DWORD PTR _szTmp$[esp+2192], edx
  005b8	89 4c 24 2c	 mov	 DWORD PTR _szTmp$[esp+2188], ecx
  005bc	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  005bf	90		 npad	 1
$LL86@DoRegInsta:
  005c0	8a 08		 mov	 cl, BYTE PTR [eax]
  005c2	40		 inc	 eax
  005c3	3a cb		 cmp	 cl, bl
  005c5	75 f9		 jne	 SHORT $LL86@DoRegInsta
  005c7	8b 4c 24 10	 mov	 ecx, DWORD PTR _hkey$[esp+2180]
  005cb	2b c2		 sub	 eax, edx
  005cd	40		 inc	 eax
  005ce	50		 push	 eax
  005cf	8d 44 24 28	 lea	 eax, DWORD PTR _szTmp$[esp+2184]
  005d3	50		 push	 eax
  005d4	6a 01		 push	 1
  005d6	53		 push	 ebx
  005d7	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  005dc	51		 push	 ecx
  005dd	ff d6		 call	 esi
  005df	85 c0		 test	 eax, eax
  005e1	0f 85 9e 03 00
	00		 jne	 $LN97@DoRegInsta

; 744  : 			goto error;
; 745  : 		
; 746  : 		RegCloseKey (hkey);

  005e7	8b 54 24 10	 mov	 edx, DWORD PTR _hkey$[esp+2180]
  005eb	52		 push	 edx
  005ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 747  : 		hkey = 0;

  005f2	89 5c 24 10	 mov	 DWORD PTR _hkey$[esp+2180], ebx

; 748  : 
; 749  : 		if (typeClassChanged)

  005f6	3b fb		 cmp	 edi, ebx
  005f8	74 0e		 je	 SHORT $LN96@DoRegInsta

; 750  : 			SHChangeNotify (SHCNE_ASSOCCHANGED, SHCNF_IDLIST, NULL, NULL);

  005fa	53		 push	 ebx
  005fb	53		 push	 ebx
  005fc	53		 push	 ebx
  005fd	68 00 00 00 08	 push	 134217728		; 08000000H
  00602	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SHChangeNotify@16
$LN96@DoRegInsta:
  00608	8b 7c 24 18	 mov	 edi, DWORD PTR _hwndDlg$GSCopy$[esp+2180]
$LN29@DoRegInsta:

; 751  : 	}
; 752  : 
; 753  : 	key = "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\TrueCrypt";
; 754  : 	RegMessage (hwndDlg, key);

  0060c	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@FLBIDANE@Software?2Microsoft?2Windows?2Curre@
  00611	68 00 00 00 00	 push	 OFFSET ??_C@_0L@LFAEJJAB@ADDING_REG?$AA@
  00616	57		 push	 edi
  00617	e8 00 00 00 00	 call	 _StatusMessageParam
  0061c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 755  : 	if (RegCreateKeyEx (HKEY_LOCAL_MACHINE,
; 756  : 		key,
; 757  : 		0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &dw) != ERROR_SUCCESS)

  0061f	8d 44 24 14	 lea	 eax, DWORD PTR _dw$[esp+2180]
  00623	50		 push	 eax
  00624	8d 4c 24 14	 lea	 ecx, DWORD PTR _hkey$[esp+2184]
  00628	51		 push	 ecx
  00629	53		 push	 ebx
  0062a	68 06 00 02 00	 push	 131078			; 00020006H
  0062f	53		 push	 ebx
  00630	53		 push	 ebx
  00631	53		 push	 ebx
  00632	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@FLBIDANE@Software?2Microsoft?2Windows?2Curre@
  00637	68 02 00 00 80	 push	 -2147483646		; 80000002H
  0063c	ff d5		 call	 ebp
  0063e	85 c0		 test	 eax, eax
  00640	0f 85 43 03 00
	00		 jne	 $error$134319

; 758  : 		goto error;
; 759  : 
; 760  : 	/* IMPORTANT: IF YOU CHANGE THIS IN ANY WAY, REVISE AND UPDATE SetInstallationPath() ACCORDINGLY! */ 
; 761  : 	snprintf (szTmp, sizeof(szTmp), "\"%sCipherShed-Setup.exe\" /u", szDir);

  00646	8d 94 24 74 04
	00 00		 lea	 edx, DWORD PTR _szDir$[esp+2180]
  0064d	52		 push	 edx
  0064e	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@NDACMPIF@?$CC?$CFsCipherShed?9Setup?4exe?$CC?5?1u?$AA@
  00653	8d 44 24 2c	 lea	 eax, DWORD PTR _szTmp$[esp+2188]
  00657	68 10 04 00 00	 push	 1040			; 00000410H
  0065c	50		 push	 eax
  0065d	e8 00 00 00 00	 call	 _sprintf_s

; 762  : 	if (RegSetValueEx (hkey, "UninstallString", 0, REG_SZ, (BYTE *) szTmp, strlen (szTmp) + 1) != ERROR_SUCCESS)

  00662	8d 44 24 34	 lea	 eax, DWORD PTR _szTmp$[esp+2196]
  00666	83 c4 10	 add	 esp, 16			; 00000010H
  00669	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0066c	8d 64 24 00	 npad	 4
$LL87@DoRegInsta:
  00670	8a 08		 mov	 cl, BYTE PTR [eax]
  00672	40		 inc	 eax
  00673	3a cb		 cmp	 cl, bl
  00675	75 f9		 jne	 SHORT $LL87@DoRegInsta
  00677	2b c2		 sub	 eax, edx
  00679	8b 54 24 10	 mov	 edx, DWORD PTR _hkey$[esp+2180]
  0067d	40		 inc	 eax
  0067e	50		 push	 eax
  0067f	8d 4c 24 28	 lea	 ecx, DWORD PTR _szTmp$[esp+2184]
  00683	51		 push	 ecx
  00684	6a 01		 push	 1
  00686	53		 push	 ebx
  00687	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@OJMJCMCH@UninstallString?$AA@
  0068c	52		 push	 edx
  0068d	ff d6		 call	 esi
  0068f	85 c0		 test	 eax, eax
  00691	0f 85 f2 02 00
	00		 jne	 $error$134319

; 763  : 		goto error;
; 764  : 
; 765  : 	snprintf (szTmp, sizeof(szTmp), "\"%sCipherShed-Setup.exe\" /c", szDir);

  00697	8d 84 24 74 04
	00 00		 lea	 eax, DWORD PTR _szDir$[esp+2180]
  0069e	50		 push	 eax
  0069f	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@MPJKHKFC@?$CC?$CFsCipherShed?9Setup?4exe?$CC?5?1c?$AA@
  006a4	8d 4c 24 2c	 lea	 ecx, DWORD PTR _szTmp$[esp+2188]
  006a8	68 10 04 00 00	 push	 1040			; 00000410H
  006ad	51		 push	 ecx
  006ae	e8 00 00 00 00	 call	 _sprintf_s

; 766  : 	if (RegSetValueEx (hkey, "ModifyPath", 0, REG_SZ, (BYTE *) szTmp, strlen (szTmp) + 1) != ERROR_SUCCESS)

  006b3	8d 44 24 34	 lea	 eax, DWORD PTR _szTmp$[esp+2196]
  006b7	83 c4 10	 add	 esp, 16			; 00000010H
  006ba	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  006bd	8d 49 00	 npad	 3
$LL88@DoRegInsta:
  006c0	8a 08		 mov	 cl, BYTE PTR [eax]
  006c2	40		 inc	 eax
  006c3	3a cb		 cmp	 cl, bl
  006c5	75 f9		 jne	 SHORT $LL88@DoRegInsta
  006c7	2b c2		 sub	 eax, edx
  006c9	40		 inc	 eax
  006ca	50		 push	 eax
  006cb	8b 44 24 14	 mov	 eax, DWORD PTR _hkey$[esp+2184]
  006cf	8d 54 24 28	 lea	 edx, DWORD PTR _szTmp$[esp+2184]
  006d3	52		 push	 edx
  006d4	6a 01		 push	 1
  006d6	53		 push	 ebx
  006d7	68 00 00 00 00	 push	 OFFSET ??_C@_0L@OGHNHFGG@ModifyPath?$AA@
  006dc	50		 push	 eax
  006dd	ff d6		 call	 esi
  006df	85 c0		 test	 eax, eax
  006e1	0f 85 a2 02 00
	00		 jne	 $error$134319

; 767  : 		goto error;
; 768  : 
; 769  : 	snprintf (szTmp, sizeof(szTmp), "\"%sCipherShed-Setup.exe\"", szDir);

  006e7	8d 8c 24 74 04
	00 00		 lea	 ecx, DWORD PTR _szDir$[esp+2180]
  006ee	51		 push	 ecx
  006ef	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@BAIMPNHC@?$CC?$CFsCipherShed?9Setup?4exe?$CC?$AA@
  006f4	8d 54 24 2c	 lea	 edx, DWORD PTR _szTmp$[esp+2188]
  006f8	68 10 04 00 00	 push	 1040			; 00000410H
  006fd	52		 push	 edx
  006fe	e8 00 00 00 00	 call	 _sprintf_s

; 770  : 	if (RegSetValueEx (hkey, "DisplayIcon", 0, REG_SZ, (BYTE *) szTmp, strlen (szTmp) + 1) != ERROR_SUCCESS)

  00703	8d 44 24 34	 lea	 eax, DWORD PTR _szTmp$[esp+2196]
  00707	83 c4 10	 add	 esp, 16			; 00000010H
  0070a	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0070d	8d 49 00	 npad	 3
$LL89@DoRegInsta:
  00710	8a 08		 mov	 cl, BYTE PTR [eax]
  00712	40		 inc	 eax
  00713	3a cb		 cmp	 cl, bl
  00715	75 f9		 jne	 SHORT $LL89@DoRegInsta
  00717	8b 4c 24 10	 mov	 ecx, DWORD PTR _hkey$[esp+2180]
  0071b	2b c2		 sub	 eax, edx
  0071d	40		 inc	 eax
  0071e	50		 push	 eax
  0071f	8d 44 24 28	 lea	 eax, DWORD PTR _szTmp$[esp+2184]
  00723	50		 push	 eax
  00724	6a 01		 push	 1
  00726	53		 push	 ebx
  00727	68 00 00 00 00	 push	 OFFSET ??_C@_0M@DDCGOGKB@DisplayIcon?$AA@
  0072c	51		 push	 ecx
  0072d	ff d6		 call	 esi
  0072f	85 c0		 test	 eax, eax
  00731	0f 85 52 02 00
	00		 jne	 $error$134319

; 771  : 		goto error;
; 772  : 
; 773  : 	strcpy (szTmp, VERSION_STRING);

  00737	66 a1 04 00 00
	00		 mov	 ax, WORD PTR ??_C@_05JPPCAGFG@0?47?43?$AA@+4
  0073d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ??_C@_05JPPCAGFG@0?47?43?$AA@
  00743	66 89 44 24 28	 mov	 WORD PTR _szTmp$[esp+2184], ax

; 774  : 	if (RegSetValueEx (hkey, "DisplayVersion", 0, REG_SZ, (BYTE *) szTmp, strlen (szTmp) + 1) != ERROR_SUCCESS)

  00748	8d 44 24 24	 lea	 eax, DWORD PTR _szTmp$[esp+2180]
  0074c	89 54 24 24	 mov	 DWORD PTR _szTmp$[esp+2180], edx
  00750	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL90@DoRegInsta:
  00753	8a 08		 mov	 cl, BYTE PTR [eax]
  00755	40		 inc	 eax
  00756	3a cb		 cmp	 cl, bl
  00758	75 f9		 jne	 SHORT $LL90@DoRegInsta
  0075a	2b c2		 sub	 eax, edx
  0075c	8b 54 24 10	 mov	 edx, DWORD PTR _hkey$[esp+2180]
  00760	40		 inc	 eax
  00761	50		 push	 eax
  00762	8d 4c 24 28	 lea	 ecx, DWORD PTR _szTmp$[esp+2184]
  00766	51		 push	 ecx
  00767	6a 01		 push	 1
  00769	53		 push	 ebx
  0076a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@BNDLMAIF@DisplayVersion?$AA@
  0076f	52		 push	 edx
  00770	ff d6		 call	 esi
  00772	85 c0		 test	 eax, eax
  00774	0f 85 0f 02 00
	00		 jne	 $error$134319

; 775  : 		goto error;
; 776  : 		
; 777  : 	strcpy (szTmp, "CipherShed");

  0077a	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_0L@FEEFGEIL@CipherShed?$AA@
  0077f	66 8b 15 08 00
	00 00		 mov	 dx, WORD PTR ??_C@_0L@FEEFGEIL@CipherShed?$AA@+8
  00786	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_0L@FEEFGEIL@CipherShed?$AA@+4
  0078c	89 44 24 24	 mov	 DWORD PTR _szTmp$[esp+2180], eax
  00790	a0 0a 00 00 00	 mov	 al, BYTE PTR ??_C@_0L@FEEFGEIL@CipherShed?$AA@+10
  00795	88 44 24 2e	 mov	 BYTE PTR _szTmp$[esp+2190], al

; 778  : 	if (RegSetValueEx (hkey, "DisplayName", 0, REG_SZ, (BYTE *) szTmp, strlen (szTmp) + 1) != ERROR_SUCCESS)

  00799	8d 44 24 24	 lea	 eax, DWORD PTR _szTmp$[esp+2180]
  0079d	66 89 54 24 2c	 mov	 WORD PTR _szTmp$[esp+2188], dx
  007a2	89 4c 24 28	 mov	 DWORD PTR _szTmp$[esp+2184], ecx
  007a6	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  007a9	8d a4 24 00 00
	00 00		 npad	 7
$LL91@DoRegInsta:
  007b0	8a 08		 mov	 cl, BYTE PTR [eax]
  007b2	40		 inc	 eax
  007b3	3a cb		 cmp	 cl, bl
  007b5	75 f9		 jne	 SHORT $LL91@DoRegInsta
  007b7	2b c2		 sub	 eax, edx
  007b9	8b 54 24 10	 mov	 edx, DWORD PTR _hkey$[esp+2180]
  007bd	40		 inc	 eax
  007be	50		 push	 eax
  007bf	8d 4c 24 28	 lea	 ecx, DWORD PTR _szTmp$[esp+2184]
  007c3	51		 push	 ecx
  007c4	6a 01		 push	 1
  007c6	53		 push	 ebx
  007c7	68 00 00 00 00	 push	 OFFSET ??_C@_0M@MLHPPPJP@DisplayName?$AA@
  007cc	52		 push	 edx
  007cd	ff d6		 call	 esi
  007cf	85 c0		 test	 eax, eax
  007d1	0f 85 b2 01 00
	00		 jne	 $error$134319

; 779  : 		goto error;
; 780  : 
; 781  : 	strcpy (szTmp, "CipherShed Project");

  007d7	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_0BD@GIJEKPBA@CipherShed?5Project?$AA@
  007dc	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR ??_C@_0BD@GIJEKPBA@CipherShed?5Project?$AA@+8
  007e2	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_0BD@GIJEKPBA@CipherShed?5Project?$AA@+4
  007e8	89 44 24 24	 mov	 DWORD PTR _szTmp$[esp+2180], eax
  007ec	a1 0c 00 00 00	 mov	 eax, DWORD PTR ??_C@_0BD@GIJEKPBA@CipherShed?5Project?$AA@+12
  007f1	89 54 24 2c	 mov	 DWORD PTR _szTmp$[esp+2188], edx
  007f5	8a 15 12 00 00
	00		 mov	 dl, BYTE PTR ??_C@_0BD@GIJEKPBA@CipherShed?5Project?$AA@+18
  007fb	89 4c 24 28	 mov	 DWORD PTR _szTmp$[esp+2184], ecx
  007ff	66 8b 0d 10 00
	00 00		 mov	 cx, WORD PTR ??_C@_0BD@GIJEKPBA@CipherShed?5Project?$AA@+16
  00806	89 44 24 30	 mov	 DWORD PTR _szTmp$[esp+2192], eax

; 782  : 	if (RegSetValueEx (hkey, "Publisher", 0, REG_SZ, (BYTE *) szTmp, strlen (szTmp) + 1) != ERROR_SUCCESS)

  0080a	8d 44 24 24	 lea	 eax, DWORD PTR _szTmp$[esp+2180]
  0080e	88 54 24 36	 mov	 BYTE PTR _szTmp$[esp+2198], dl
  00812	66 89 4c 24 34	 mov	 WORD PTR _szTmp$[esp+2196], cx
  00817	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0081a	8d 9b 00 00 00
	00		 npad	 6
$LL92@DoRegInsta:
  00820	8a 08		 mov	 cl, BYTE PTR [eax]
  00822	40		 inc	 eax
  00823	3a cb		 cmp	 cl, bl
  00825	75 f9		 jne	 SHORT $LL92@DoRegInsta
  00827	8b 4c 24 10	 mov	 ecx, DWORD PTR _hkey$[esp+2180]
  0082b	2b c2		 sub	 eax, edx
  0082d	40		 inc	 eax
  0082e	50		 push	 eax
  0082f	8d 44 24 28	 lea	 eax, DWORD PTR _szTmp$[esp+2184]
  00833	50		 push	 eax
  00834	6a 01		 push	 1
  00836	53		 push	 ebx
  00837	68 00 00 00 00	 push	 OFFSET ??_C@_09PNIDBPNC@Publisher?$AA@
  0083c	51		 push	 ecx
  0083d	ff d6		 call	 esi
  0083f	85 c0		 test	 eax, eax
  00841	0f 85 42 01 00
	00		 jne	 $error$134319

; 783  : 		goto error;
; 784  : 
; 785  : 	strcpy (szTmp, TC_HOMEPAGE);

  00847	a1 04 00 00 00	 mov	 eax, DWORD PTR ??_C@_0BI@INHGIDBI@https?3?1?1ciphershed?4org?1?$AA@+4
  0084c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ??_C@_0BI@INHGIDBI@https?3?1?1ciphershed?4org?1?$AA@
  00852	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_0BI@INHGIDBI@https?3?1?1ciphershed?4org?1?$AA@+8
  00858	89 44 24 28	 mov	 DWORD PTR _szTmp$[esp+2184], eax
  0085c	a1 10 00 00 00	 mov	 eax, DWORD PTR ??_C@_0BI@INHGIDBI@https?3?1?1ciphershed?4org?1?$AA@+16
  00861	89 54 24 24	 mov	 DWORD PTR _szTmp$[esp+2180], edx
  00865	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ??_C@_0BI@INHGIDBI@https?3?1?1ciphershed?4org?1?$AA@+12
  0086b	89 4c 24 2c	 mov	 DWORD PTR _szTmp$[esp+2188], ecx
  0086f	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_0BI@INHGIDBI@https?3?1?1ciphershed?4org?1?$AA@+20
  00875	89 44 24 34	 mov	 DWORD PTR _szTmp$[esp+2196], eax

; 786  : 	if (RegSetValueEx (hkey, "URLInfoAbout", 0, REG_SZ, (BYTE *) szTmp, strlen (szTmp) + 1) != ERROR_SUCCESS)

  00879	8d 44 24 24	 lea	 eax, DWORD PTR _szTmp$[esp+2180]
  0087d	89 54 24 30	 mov	 DWORD PTR _szTmp$[esp+2192], edx
  00881	89 4c 24 38	 mov	 DWORD PTR _szTmp$[esp+2200], ecx
  00885	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL93@DoRegInsta:
  00888	8a 08		 mov	 cl, BYTE PTR [eax]
  0088a	40		 inc	 eax
  0088b	3a cb		 cmp	 cl, bl
  0088d	75 f9		 jne	 SHORT $LL93@DoRegInsta
  0088f	2b c2		 sub	 eax, edx
  00891	40		 inc	 eax
  00892	50		 push	 eax
  00893	8b 44 24 14	 mov	 eax, DWORD PTR _hkey$[esp+2184]
  00897	8d 54 24 28	 lea	 edx, DWORD PTR _szTmp$[esp+2184]
  0089b	52		 push	 edx
  0089c	6a 01		 push	 1
  0089e	53		 push	 ebx
  0089f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@CIJCJNDA@URLInfoAbout?$AA@
  008a4	50		 push	 eax
  008a5	ff d6		 call	 esi
  008a7	85 c0		 test	 eax, eax
  008a9	0f 85 da 00 00
	00		 jne	 $error$134319

; 787  : 		goto error;
; 788  : 
; 789  : 	RegCloseKey (hkey);

  008af	8b 4c 24 10	 mov	 ecx, DWORD PTR _hkey$[esp+2180]
  008b3	51		 push	 ecx
  008b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 790  : 	hkey = 0;
; 791  : 
; 792  : 	/* CipherShed. */
; 793  : 	key = "Software\\CipherShed";
; 794  : 	RegMessage (hwndDlg, key);

  008ba	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@GEGOEFMH@Software?2CipherShed?$AA@
  008bf	57		 push	 edi
  008c0	89 5c 24 18	 mov	 DWORD PTR _hkey$[esp+2188], ebx
  008c4	e8 00 00 00 00	 call	 _RegMessage
  008c9	83 c4 08	 add	 esp, 8

; 795  : 	if (RegCreateKeyEx (HKEY_LOCAL_MACHINE,
; 796  : 		key,
; 797  : 		0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &dw) != ERROR_SUCCESS)

  008cc	8d 54 24 14	 lea	 edx, DWORD PTR _dw$[esp+2180]
  008d0	52		 push	 edx
  008d1	8d 44 24 14	 lea	 eax, DWORD PTR _hkey$[esp+2184]
  008d5	50		 push	 eax
  008d6	53		 push	 ebx
  008d7	68 06 00 02 00	 push	 131078			; 00020006H
  008dc	53		 push	 ebx
  008dd	53		 push	 ebx
  008de	53		 push	 ebx
  008df	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@GEGOEFMH@Software?2CipherShed?$AA@
  008e4	68 02 00 00 80	 push	 -2147483646		; 80000002H
  008e9	ff d5		 call	 ebp
  008eb	85 c0		 test	 eax, eax
  008ed	0f 85 96 00 00
	00		 jne	 $error$134319

; 798  : 		goto error;
; 799  : 
; 800  : 	if (RegSetValueEx (hkey, "InstallationPath", 0, REG_SZ, (BYTE *) szDir, strlen (szDir) + 1) != ERROR_SUCCESS)

  008f3	8d 84 24 74 04
	00 00		 lea	 eax, DWORD PTR _szDir$[esp+2180]
  008fa	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  008fd	8d 49 00	 npad	 3
$LL94@DoRegInsta:
  00900	8a 08		 mov	 cl, BYTE PTR [eax]
  00902	40		 inc	 eax
  00903	3a cb		 cmp	 cl, bl
  00905	75 f9		 jne	 SHORT $LL94@DoRegInsta
  00907	2b c2		 sub	 eax, edx
  00909	8b 54 24 10	 mov	 edx, DWORD PTR _hkey$[esp+2180]
  0090d	40		 inc	 eax
  0090e	50		 push	 eax
  0090f	8d 8c 24 78 04
	00 00		 lea	 ecx, DWORD PTR _szDir$[esp+2184]
  00916	51		 push	 ecx
  00917	6a 01		 push	 1
  00919	53		 push	 ebx
  0091a	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FKJFEMO@InstallationPath?$AA@
  0091f	52		 push	 edx
  00920	ff d6		 call	 esi
  00922	85 c0		 test	 eax, eax
  00924	75 63		 jne	 SHORT $error$134319

; 801  : 		goto error;
; 802  : 
; 803  : 	if (bCipherShedMigration && RegSetValueEx (hkey, "MigrationPath", 0, REG_SZ, (BYTE *) UninstallationPath, strlen (UninstallationPath) + 1) != ERROR_SUCCESS)

  00926	39 1d 00 00 00
	00		 cmp	 DWORD PTR _bCipherShedMigration, ebx
  0092c	74 4d		 je	 SHORT $LN6@DoRegInsta
  0092e	b8 00 00 00 00	 mov	 eax, OFFSET ?UninstallationPath@@3PADA ; UninstallationPath
  00933	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL95@DoRegInsta:
  00936	8a 08		 mov	 cl, BYTE PTR [eax]
  00938	40		 inc	 eax
  00939	3a cb		 cmp	 cl, bl
  0093b	75 f9		 jne	 SHORT $LL95@DoRegInsta
  0093d	2b c2		 sub	 eax, edx
  0093f	40		 inc	 eax
  00940	50		 push	 eax
  00941	8b 44 24 14	 mov	 eax, DWORD PTR _hkey$[esp+2184]
  00945	68 00 00 00 00	 push	 OFFSET ?UninstallationPath@@3PADA ; UninstallationPath
  0094a	6a 01		 push	 1
  0094c	53		 push	 ebx
  0094d	68 00 00 00 00	 push	 OFFSET ??_C@_0O@PNHONFDO@MigrationPath?$AA@
  00952	50		 push	 eax
  00953	ff d6		 call	 esi
  00955	85 c0		 test	 eax, eax
  00957	75 30		 jne	 SHORT $error$134319

; 804  : 		goto error;
; 805  : 
; 806  : 	if (bCipherShedMigration && RegSetValueEx (hkey, "MigrationVersion", 0, REG_DWORD, (BYTE *) &InstalledVersion, sizeof (InstalledVersion)) != ERROR_SUCCESS)

  00959	39 1d 00 00 00
	00		 cmp	 DWORD PTR _bCipherShedMigration, ebx
  0095f	74 1a		 je	 SHORT $LN6@DoRegInsta
  00961	8b 4c 24 10	 mov	 ecx, DWORD PTR _hkey$[esp+2180]
  00965	6a 04		 push	 4
  00967	68 00 00 00 00	 push	 OFFSET ?InstalledVersion@@3JA ; InstalledVersion
  0096c	6a 04		 push	 4
  0096e	53		 push	 ebx
  0096f	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@GIJFLPKB@MigrationVersion?$AA@
  00974	51		 push	 ecx
  00975	ff d6		 call	 esi
  00977	85 c0		 test	 eax, eax
  00979	75 0e		 jne	 SHORT $error$134319
$LN6@DoRegInsta:

; 807  : 		goto error;
; 808  : 
; 809  : 	bOK = TRUE;

  0097b	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR _bOK$[esp+2180], 1
  00983	eb 04		 jmp	 SHORT $error$134319
$LN97@DoRegInsta:
  00985	8b 7c 24 18	 mov	 edi, DWORD PTR _hwndDlg$GSCopy$[esp+2180]
$error$134319:

; 810  : 
; 811  : error:
; 812  : 	if (hkey != 0)

  00989	8b 44 24 10	 mov	 eax, DWORD PTR _hkey$[esp+2180]
  0098d	5d		 pop	 ebp
  0098e	3b c3		 cmp	 eax, ebx
  00990	74 07		 je	 SHORT $LN4@DoRegInsta

; 813  : 		RegCloseKey (hkey);

  00992	50		 push	 eax
  00993	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$LN4@DoRegInsta:

; 814  : 
; 815  : 	if (bOK == FALSE)

  00999	8b 74 24 18	 mov	 esi, DWORD PTR _bOK$[esp+2176]
  0099d	3b f3		 cmp	 esi, ebx
  0099f	75 13		 jne	 SHORT $LN3@DoRegInsta

; 816  : 	{
; 817  : 		handleWin32Error (hwndDlg);

  009a1	57		 push	 edi
  009a2	e8 00 00 00 00	 call	 _handleWin32Error

; 818  : 		Error ("REG_INSTALL_FAILED");

  009a7	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@HFNFAFOP@REG_INSTALL_FAILED?$AA@
  009ac	e8 00 00 00 00	 call	 _Error
  009b1	83 c4 08	 add	 esp, 8
$LN3@DoRegInsta:

; 819  : 	}
; 820  : 	
; 821  : 	// Register COM servers for UAC
; 822  : 	if (IsOSAtLeast (WIN_VISTA))

  009b4	6a 0b		 push	 11			; 0000000bH
  009b6	e8 00 00 00 00	 call	 _IsOSAtLeast
  009bb	83 c4 04	 add	 esp, 4
  009be	85 c0		 test	 eax, eax
  009c0	74 3b		 je	 SHORT $LN1@DoRegInsta

; 823  : 	{
; 824  : 		if (!RegisterComServers (szDir))

  009c2	8d 94 24 70 04
	00 00		 lea	 edx, DWORD PTR _szDir$[esp+2176]
  009c9	52		 push	 edx
  009ca	e8 00 00 00 00	 call	 _RegisterComServers
  009cf	83 c4 04	 add	 esp, 4
  009d2	85 c0		 test	 eax, eax
  009d4	75 27		 jne	 SHORT $LN1@DoRegInsta

; 825  : 		{
; 826  : 			Error ("COM_REG_FAILED");

  009d6	68 00 00 00 00	 push	 OFFSET ??_C@_0P@LLMHDMAL@COM_REG_FAILED?$AA@
  009db	e8 00 00 00 00	 call	 _Error
  009e0	83 c4 04	 add	 esp, 4
  009e3	5f		 pop	 edi
  009e4	5e		 pop	 esi

; 827  : 			return FALSE;

  009e5	33 c0		 xor	 eax, eax
  009e7	5b		 pop	 ebx

; 828  : 		}
; 829  : 	}
; 830  : 
; 831  : 	return bOK;
; 832  : }

  009e8	8b 8c 24 70 08
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+2164]
  009ef	33 cc		 xor	 ecx, esp
  009f1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  009f6	81 c4 74 08 00
	00		 add	 esp, 2164		; 00000874H
  009fc	c3		 ret	 0
$LN1@DoRegInsta:
  009fd	8b 8c 24 7c 08
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+2176]
  00a04	5f		 pop	 edi
  00a05	8b c6		 mov	 eax, esi
  00a07	5e		 pop	 esi
  00a08	5b		 pop	 ebx
  00a09	33 cc		 xor	 ecx, esp
  00a0b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a10	81 c4 74 08 00
	00		 add	 esp, 2164		; 00000874H
  00a16	c3		 ret	 0
_DoRegInstall ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@LGADMAPO@?2TrueCrypt?$AA@		; `string'
PUBLIC	??_C@_0BG@NJOIKHOP@System?5Encryption?4xml?$AA@	; `string'
PUBLIC	??_C@_0BC@FNANDAA@Configuration?4xml?$AA@	; `string'
PUBLIC	??_C@_0M@COMBLGLD@History?4xml?$AA@		; `string'
PUBLIC	??_C@_0BF@CEDLNBLM@Default?5Keyfiles?4xml?$AA@	; `string'
PUBLIC	??_C@_0BF@EGBOIEGJ@Favorite?5Volumes?4xml?$AA@	; `string'
PUBLIC	??_C@_0M@EMLNMOID@?2TrueCrypt?2?$AA@		; `string'
PUBLIC	??_C@_0BB@EKLCNMAG@REMOVING_APPDATA?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?DoApplicationDataUninstall@@YAHPAUHWND__@@@Z	; DoApplicationDataUninstall
EXTRN	__imp__SHGetFolderPathA@20:PROC
;	COMDAT ??_C@_0L@LGADMAPO@?2TrueCrypt?$AA@
CONST	SEGMENT
??_C@_0L@LGADMAPO@?2TrueCrypt?$AA@ DB '\TrueCrypt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NJOIKHOP@System?5Encryption?4xml?$AA@
CONST	SEGMENT
??_C@_0BG@NJOIKHOP@System?5Encryption?4xml?$AA@ DB 'System Encryption.xml'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FNANDAA@Configuration?4xml?$AA@
CONST	SEGMENT
??_C@_0BC@FNANDAA@Configuration?4xml?$AA@ DB 'Configuration.xml', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@COMBLGLD@History?4xml?$AA@
CONST	SEGMENT
??_C@_0M@COMBLGLD@History?4xml?$AA@ DB 'History.xml', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CEDLNBLM@Default?5Keyfiles?4xml?$AA@
CONST	SEGMENT
??_C@_0BF@CEDLNBLM@Default?5Keyfiles?4xml?$AA@ DB 'Default Keyfiles.xml', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EGBOIEGJ@Favorite?5Volumes?4xml?$AA@
CONST	SEGMENT
??_C@_0BF@EGBOIEGJ@Favorite?5Volumes?4xml?$AA@ DB 'Favorite Volumes.xml', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EMLNMOID@?2TrueCrypt?2?$AA@
CONST	SEGMENT
??_C@_0M@EMLNMOID@?2TrueCrypt?2?$AA@ DB '\TrueCrypt\', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EKLCNMAG@REMOVING_APPDATA?$AA@
CONST	SEGMENT
??_C@_0BB@EKLCNMAG@REMOVING_APPDATA?$AA@ DB 'REMOVING_APPDATA', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?DoApplicationDataUninstall@@YAHPAUHWND__@@@Z
_TEXT	SEGMENT
_st$138260 = -580					; size = 56
_st$138250 = -580					; size = 56
_st$138239 = -580					; size = 56
_st$138229 = -580					; size = 56
_st$138219 = -580					; size = 56
_st$138209 = -580					; size = 56
_path2$ = -524						; size = 260
_path$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
?DoApplicationDataUninstall@@YAHPAUHWND__@@@Z PROC	; DoApplicationDataUninstall, COMDAT

; 835  : {

  00000	81 ec 44 02 00
	00		 sub	 esp, 580		; 00000244H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 40 02
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+580], eax
  00014	55		 push	 ebp
  00015	56		 push	 esi
  00016	8b b4 24 50 02
	00 00		 mov	 esi, DWORD PTR _hwndDlg$[esp+584]
  0001d	57		 push	 edi

; 836  : 	char path[MAX_PATH];
; 837  : 	char path2[MAX_PATH];
; 838  : 	BOOL bOK = TRUE;
; 839  : 
; 840  : 	StatusMessage (hwndDlg, "REMOVING_APPDATA");

  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@EKLCNMAG@REMOVING_APPDATA?$AA@
  00023	56		 push	 esi
  00024	bd 01 00 00 00	 mov	 ebp, 1
  00029	e8 00 00 00 00	 call	 _StatusMessage

; 841  : 
; 842  : 	SHGetFolderPath (NULL, CSIDL_APPDATA, NULL, 0, path);

  0002e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__SHGetFolderPathA@20
  00034	83 c4 08	 add	 esp, 8
  00037	8d 84 24 48 01
	00 00		 lea	 eax, DWORD PTR _path$[esp+592]
  0003e	50		 push	 eax
  0003f	6a 00		 push	 0
  00041	6a 00		 push	 0
  00043	6a 1a		 push	 26			; 0000001aH
  00045	6a 00		 push	 0
  00047	ff d7		 call	 edi

; 843  : 	strcat_s (path, sizeof(path), "\\TrueCrypt\\");

  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0M@EMLNMOID@?2TrueCrypt?2?$AA@
  0004e	8d 8c 24 4c 01
	00 00		 lea	 ecx, DWORD PTR _path$[esp+596]
  00055	68 04 01 00 00	 push	 260			; 00000104H
  0005a	51		 push	 ecx
  0005b	e8 00 00 00 00	 call	 _strcat_s

; 844  : 
; 845  : 	// Delete favorite volumes file
; 846  : 	snprintf (path2, sizeof(path2), "%s%s", path, TC_APPD_FILENAME_FAVORITE_VOLUMES);

  00060	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@EGBOIEGJ@Favorite?5Volumes?4xml?$AA@
  00065	8d 94 24 58 01
	00 00		 lea	 edx, DWORD PTR _path$[esp+608]
  0006c	52		 push	 edx
  0006d	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  00072	8d 44 24 5c	 lea	 eax, DWORD PTR _path2$[esp+616]
  00076	68 04 01 00 00	 push	 260			; 00000104H
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 _sprintf_s
  00081	83 c4 20	 add	 esp, 32			; 00000020H

; 847  : 	RemoveMessage (hwndDlg, path2);

  00084	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  0008b	75 13		 jne	 SHORT $LN4@DoApplicat
  0008d	8d 4c 24 44	 lea	 ecx, DWORD PTR _path2$[esp+592]
  00091	51		 push	 ecx
  00092	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  00097	56		 push	 esi
  00098	e8 00 00 00 00	 call	 _StatusMessageParam
  0009d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@DoApplicat:
  000a0	53		 push	 ebx

; 848  : 	StatDeleteFile (path2);

  000a1	8d 54 24 10	 lea	 edx, DWORD PTR _st$138209[esp+596]
  000a5	52		 push	 edx
  000a6	8d 44 24 4c	 lea	 eax, DWORD PTR _path2$[esp+600]
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 __stat64
  000b0	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__DeleteFileA@4
  000b6	83 c4 08	 add	 esp, 8
  000b9	85 c0		 test	 eax, eax
  000bb	75 07		 jne	 SHORT $LN8@DoApplicat
  000bd	8d 4c 24 48	 lea	 ecx, DWORD PTR _path2$[esp+596]
  000c1	51		 push	 ecx
  000c2	ff d3		 call	 ebx
$LN8@DoApplicat:

; 849  : 
; 850  : 	// Delete keyfile defaults
; 851  : 	snprintf (path2, sizeof(path2), "%s%s", path, TC_APPD_FILENAME_DEFAULT_KEYFILES);

  000c4	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@CEDLNBLM@Default?5Keyfiles?4xml?$AA@
  000c9	8d 94 24 50 01
	00 00		 lea	 edx, DWORD PTR _path$[esp+600]
  000d0	52		 push	 edx
  000d1	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  000d6	8d 44 24 54	 lea	 eax, DWORD PTR _path2$[esp+608]
  000da	68 04 01 00 00	 push	 260			; 00000104H
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 _sprintf_s
  000e5	83 c4 14	 add	 esp, 20			; 00000014H

; 852  : 	RemoveMessage (hwndDlg, path2);

  000e8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  000ef	75 13		 jne	 SHORT $LN11@DoApplicat
  000f1	8d 4c 24 48	 lea	 ecx, DWORD PTR _path2$[esp+596]
  000f5	51		 push	 ecx
  000f6	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  000fb	56		 push	 esi
  000fc	e8 00 00 00 00	 call	 _StatusMessageParam
  00101	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN11@DoApplicat:

; 853  : 	StatDeleteFile (path2);

  00104	8d 54 24 10	 lea	 edx, DWORD PTR _st$138219[esp+596]
  00108	52		 push	 edx
  00109	8d 44 24 4c	 lea	 eax, DWORD PTR _path2$[esp+600]
  0010d	50		 push	 eax
  0010e	e8 00 00 00 00	 call	 __stat64
  00113	83 c4 08	 add	 esp, 8
  00116	85 c0		 test	 eax, eax
  00118	75 07		 jne	 SHORT $LN15@DoApplicat
  0011a	8d 4c 24 48	 lea	 ecx, DWORD PTR _path2$[esp+596]
  0011e	51		 push	 ecx
  0011f	ff d3		 call	 ebx
$LN15@DoApplicat:

; 854  : 
; 855  : 	// Delete history file
; 856  : 	snprintf (path2, sizeof(path2), "%s%s", path, TC_APPD_FILENAME_HISTORY);

  00121	68 00 00 00 00	 push	 OFFSET ??_C@_0M@COMBLGLD@History?4xml?$AA@
  00126	8d 94 24 50 01
	00 00		 lea	 edx, DWORD PTR _path$[esp+600]
  0012d	52		 push	 edx
  0012e	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  00133	8d 44 24 54	 lea	 eax, DWORD PTR _path2$[esp+608]
  00137	68 04 01 00 00	 push	 260			; 00000104H
  0013c	50		 push	 eax
  0013d	e8 00 00 00 00	 call	 _sprintf_s
  00142	83 c4 14	 add	 esp, 20			; 00000014H

; 857  : 	RemoveMessage (hwndDlg, path2);

  00145	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  0014c	75 13		 jne	 SHORT $LN18@DoApplicat
  0014e	8d 4c 24 48	 lea	 ecx, DWORD PTR _path2$[esp+596]
  00152	51		 push	 ecx
  00153	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  00158	56		 push	 esi
  00159	e8 00 00 00 00	 call	 _StatusMessageParam
  0015e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN18@DoApplicat:

; 858  : 	StatDeleteFile (path2);

  00161	8d 54 24 10	 lea	 edx, DWORD PTR _st$138229[esp+596]
  00165	52		 push	 edx
  00166	8d 44 24 4c	 lea	 eax, DWORD PTR _path2$[esp+600]
  0016a	50		 push	 eax
  0016b	e8 00 00 00 00	 call	 __stat64
  00170	83 c4 08	 add	 esp, 8
  00173	85 c0		 test	 eax, eax
  00175	75 07		 jne	 SHORT $LN22@DoApplicat
  00177	8d 4c 24 48	 lea	 ecx, DWORD PTR _path2$[esp+596]
  0017b	51		 push	 ecx
  0017c	ff d3		 call	 ebx
$LN22@DoApplicat:

; 859  : 	
; 860  : 	// Delete configuration file
; 861  : 	snprintf (path2, sizeof(path2), "%s%s", path, TC_APPD_FILENAME_CONFIGURATION);

  0017e	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@FNANDAA@Configuration?4xml?$AA@
  00183	8d 94 24 50 01
	00 00		 lea	 edx, DWORD PTR _path$[esp+600]
  0018a	52		 push	 edx
  0018b	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  00190	8d 44 24 54	 lea	 eax, DWORD PTR _path2$[esp+608]
  00194	68 04 01 00 00	 push	 260			; 00000104H
  00199	50		 push	 eax
  0019a	e8 00 00 00 00	 call	 _sprintf_s
  0019f	83 c4 14	 add	 esp, 20			; 00000014H

; 862  : 	RemoveMessage (hwndDlg, path2);

  001a2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  001a9	75 13		 jne	 SHORT $LN25@DoApplicat
  001ab	8d 4c 24 48	 lea	 ecx, DWORD PTR _path2$[esp+596]
  001af	51		 push	 ecx
  001b0	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  001b5	56		 push	 esi
  001b6	e8 00 00 00 00	 call	 _StatusMessageParam
  001bb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN25@DoApplicat:

; 863  : 	StatDeleteFile (path2);

  001be	8d 54 24 10	 lea	 edx, DWORD PTR _st$138239[esp+596]
  001c2	52		 push	 edx
  001c3	8d 44 24 4c	 lea	 eax, DWORD PTR _path2$[esp+600]
  001c7	50		 push	 eax
  001c8	e8 00 00 00 00	 call	 __stat64
  001cd	83 c4 08	 add	 esp, 8
  001d0	85 c0		 test	 eax, eax
  001d2	75 07		 jne	 SHORT $LN29@DoApplicat
  001d4	8d 4c 24 48	 lea	 ecx, DWORD PTR _path2$[esp+596]
  001d8	51		 push	 ecx
  001d9	ff d3		 call	 ebx
$LN29@DoApplicat:

; 864  : 
; 865  : 	// Delete system encryption configuration file
; 866  : 	snprintf (path2, sizeof(path2), "%s%s", path, TC_APPD_FILENAME_SYSTEM_ENCRYPTION);

  001db	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@NJOIKHOP@System?5Encryption?4xml?$AA@
  001e0	8d 94 24 50 01
	00 00		 lea	 edx, DWORD PTR _path$[esp+600]
  001e7	52		 push	 edx
  001e8	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  001ed	8d 44 24 54	 lea	 eax, DWORD PTR _path2$[esp+608]
  001f1	68 04 01 00 00	 push	 260			; 00000104H
  001f6	50		 push	 eax
  001f7	e8 00 00 00 00	 call	 _sprintf_s
  001fc	83 c4 14	 add	 esp, 20			; 00000014H

; 867  : 	RemoveMessage (hwndDlg, path2);

  001ff	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  00206	75 13		 jne	 SHORT $LN32@DoApplicat
  00208	8d 4c 24 48	 lea	 ecx, DWORD PTR _path2$[esp+596]
  0020c	51		 push	 ecx
  0020d	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  00212	56		 push	 esi
  00213	e8 00 00 00 00	 call	 _StatusMessageParam
  00218	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN32@DoApplicat:

; 868  : 	StatDeleteFile (path2);

  0021b	8d 54 24 10	 lea	 edx, DWORD PTR _st$138250[esp+596]
  0021f	52		 push	 edx
  00220	8d 44 24 4c	 lea	 eax, DWORD PTR _path2$[esp+600]
  00224	50		 push	 eax
  00225	e8 00 00 00 00	 call	 __stat64
  0022a	83 c4 08	 add	 esp, 8
  0022d	85 c0		 test	 eax, eax
  0022f	75 07		 jne	 SHORT $LN36@DoApplicat
  00231	8d 4c 24 48	 lea	 ecx, DWORD PTR _path2$[esp+596]
  00235	51		 push	 ecx
  00236	ff d3		 call	 ebx
$LN36@DoApplicat:

; 869  : 
; 870  : 	SHGetFolderPath (NULL, CSIDL_APPDATA, NULL, 0, path);

  00238	8d 94 24 4c 01
	00 00		 lea	 edx, DWORD PTR _path$[esp+596]
  0023f	52		 push	 edx
  00240	6a 00		 push	 0
  00242	6a 00		 push	 0
  00244	6a 1a		 push	 26			; 0000001aH
  00246	6a 00		 push	 0
  00248	ff d7		 call	 edi

; 871  : 	strcat_s (path, sizeof(path), "\\TrueCrypt");

  0024a	68 00 00 00 00	 push	 OFFSET ??_C@_0L@LGADMAPO@?2TrueCrypt?$AA@
  0024f	8d 84 24 50 01
	00 00		 lea	 eax, DWORD PTR _path$[esp+600]
  00256	68 04 01 00 00	 push	 260			; 00000104H
  0025b	50		 push	 eax
  0025c	e8 00 00 00 00	 call	 _strcat_s
  00261	83 c4 0c	 add	 esp, 12			; 0000000cH

; 872  : 	RemoveMessage (hwndDlg, path);

  00264	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  0026b	5b		 pop	 ebx
  0026c	75 16		 jne	 SHORT $LN39@DoApplicat
  0026e	8d 8c 24 48 01
	00 00		 lea	 ecx, DWORD PTR _path$[esp+592]
  00275	51		 push	 ecx
  00276	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  0027b	56		 push	 esi
  0027c	e8 00 00 00 00	 call	 _StatusMessageParam
  00281	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN39@DoApplicat:

; 873  : 	if (!StatRemoveDirectory (path))

  00284	8d 54 24 0c	 lea	 edx, DWORD PTR _st$138260[esp+592]
  00288	52		 push	 edx
  00289	8d 84 24 4c 01
	00 00		 lea	 eax, DWORD PTR _path$[esp+596]
  00290	50		 push	 eax
  00291	e8 00 00 00 00	 call	 __stat64
  00296	83 c4 08	 add	 esp, 8
  00299	85 c0		 test	 eax, eax
  0029b	75 35		 jne	 SHORT $LN47@DoApplicat
  0029d	8d 8c 24 48 01
	00 00		 lea	 ecx, DWORD PTR _path$[esp+592]
  002a4	51		 push	 ecx
  002a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RemoveDirectoryA@4
  002ab	85 c0		 test	 eax, eax
  002ad	75 23		 jne	 SHORT $LN47@DoApplicat

; 874  : 	{
; 875  : 		handleWin32Error (hwndDlg);

  002af	56		 push	 esi
  002b0	e8 00 00 00 00	 call	 _handleWin32Error
  002b5	83 c4 04	 add	 esp, 4
  002b8	5f		 pop	 edi
  002b9	5e		 pop	 esi

; 876  : 		bOK = FALSE;

  002ba	33 c0		 xor	 eax, eax
  002bc	5d		 pop	 ebp

; 877  : 	}
; 878  : 
; 879  : 	return bOK;
; 880  : }

  002bd	8b 8c 24 40 02
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+580]
  002c4	33 cc		 xor	 ecx, esp
  002c6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002cb	81 c4 44 02 00
	00		 add	 esp, 580		; 00000244H
  002d1	c3		 ret	 0
$LN47@DoApplicat:
  002d2	8b 8c 24 4c 02
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+592]
  002d9	5f		 pop	 edi
  002da	5e		 pop	 esi
  002db	8b c5		 mov	 eax, ebp
  002dd	5d		 pop	 ebp
  002de	33 cc		 xor	 ecx, esp
  002e0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002e5	81 c4 44 02 00
	00		 add	 esp, 580		; 00000244H
  002eb	c3		 ret	 0
?DoApplicationDataUninstall@@YAHPAUHWND__@@@Z ENDP	; DoApplicationDataUninstall
_TEXT	ENDS
PUBLIC	??_C@_0BD@NCHEPDGI@Software?2TrueCrypt?$AA@	; `string'
PUBLIC	??_C@_0CH@BHAFNGC@Software?2Classes?2TrueCryptVolume@ ; `string'
PUBLIC	??_C@_0CM@CJAMGNCN@Software?2Classes?2TrueCryptVolume@ ; `string'
PUBLIC	??_C@_0N@GACNCPHC@REMOVING_REG?$AA@		; `string'
PUBLIC	??_C@_0BB@OBMIEKIN@COM_DEREG_FAILED?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_DoRegUninstall
EXTRN	__imp__RegDeleteKeyA@8:PROC
EXTRN	_UnregisterComServers:PROC
;	COMDAT ??_C@_0BD@NCHEPDGI@Software?2TrueCrypt?$AA@
CONST	SEGMENT
??_C@_0BD@NCHEPDGI@Software?2TrueCrypt?$AA@ DB 'Software\TrueCrypt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@BHAFNGC@Software?2Classes?2TrueCryptVolume@
CONST	SEGMENT
??_C@_0CH@BHAFNGC@Software?2Classes?2TrueCryptVolume@ DB 'Software\Classe'
	DB	's\TrueCryptVolume\Shell', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@CJAMGNCN@Software?2Classes?2TrueCryptVolume@
CONST	SEGMENT
??_C@_0CM@CJAMGNCN@Software?2Classes?2TrueCryptVolume@ DB 'Software\Class'
	DB	'es\TrueCryptVolume\Shell\open', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GACNCPHC@REMOVING_REG?$AA@
CONST	SEGMENT
??_C@_0N@GACNCPHC@REMOVING_REG?$AA@ DB 'REMOVING_REG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OBMIEKIN@COM_DEREG_FAILED?$AA@
CONST	SEGMENT
??_C@_0BB@OBMIEKIN@COM_DEREG_FAILED?$AA@ DB 'COM_DEREG_FAILED', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _DoRegUninstall
_TEXT	SEGMENT
_regk$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_bRemoveDeprecated$ = 12				; size = 4
_DoRegUninstall PROC					; COMDAT

; 883  : {

  00000	83 ec 44	 sub	 esp, 68			; 00000044H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 40	 mov	 DWORD PTR __$ArrayPad$[esp+68], eax
  0000e	56		 push	 esi
  0000f	8b 74 24 4c	 mov	 esi, DWORD PTR _hwndDlg$[esp+68]
  00013	57		 push	 edi

; 884  : 	BOOL bOK = FALSE;
; 885  : 	char regk [64];
; 886  : 
; 887  : 	// Unregister COM servers
; 888  : 	if (!bRemoveDeprecated && IsOSAtLeast (WIN_VISTA))

  00014	8b 7c 24 54	 mov	 edi, DWORD PTR _bRemoveDeprecated$[esp+72]
  00018	85 ff		 test	 edi, edi
  0001a	75 3b		 jne	 SHORT $LN4@DoRegUnins
  0001c	6a 0b		 push	 11			; 0000000bH
  0001e	e8 00 00 00 00	 call	 _IsOSAtLeast
  00023	83 c4 04	 add	 esp, 4
  00026	85 c0		 test	 eax, eax
  00028	74 1f		 je	 SHORT $LN9@DoRegUnins

; 889  : 	{
; 890  : 		if (!UnregisterComServers (UninstallationPath))

  0002a	68 00 00 00 00	 push	 OFFSET ?UninstallationPath@@3PADA ; UninstallationPath
  0002f	e8 00 00 00 00	 call	 _UnregisterComServers
  00034	83 c4 04	 add	 esp, 4
  00037	85 c0		 test	 eax, eax
  00039	75 0e		 jne	 SHORT $LN9@DoRegUnins

; 891  : 			StatusMessage (hwndDlg, "COM_DEREG_FAILED");

  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@OBMIEKIN@COM_DEREG_FAILED?$AA@
  00040	56		 push	 esi
  00041	e8 00 00 00 00	 call	 _StatusMessage
  00046	83 c4 08	 add	 esp, 8
$LN9@DoRegUnins:

; 892  : 	}
; 893  : 
; 894  : 	if (!bRemoveDeprecated)
; 895  : 		StatusMessage (hwndDlg, "REMOVING_REG");

  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GACNCPHC@REMOVING_REG?$AA@
  0004e	56		 push	 esi
  0004f	e8 00 00 00 00	 call	 _StatusMessage
  00054	83 c4 08	 add	 esp, 8
$LN4@DoRegUnins:

; 896  : 
; 897  : 	RegDeleteKey (HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\TrueCrypt");

  00057	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__RegDeleteKeyA@8
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@FLBIDANE@Software?2Microsoft?2Windows?2Curre@
  00062	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00067	ff d6		 call	 esi

; 898  : 	RegDeleteKey (HKEY_LOCAL_MACHINE, "Software\\Classes\\TrueCryptVolume\\Shell\\open\\command");

  00069	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@JBHHIJAN@Software?2Classes?2TrueCryptVolume@
  0006e	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00073	ff d6		 call	 esi

; 899  : 	RegDeleteKey (HKEY_LOCAL_MACHINE, "Software\\Classes\\TrueCryptVolume\\Shell\\open");

  00075	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@CJAMGNCN@Software?2Classes?2TrueCryptVolume@
  0007a	68 02 00 00 80	 push	 -2147483646		; 80000002H
  0007f	ff d6		 call	 esi

; 900  : 	RegDeleteKey (HKEY_LOCAL_MACHINE, "Software\\Classes\\TrueCryptVolume\\Shell");

  00081	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@BHAFNGC@Software?2Classes?2TrueCryptVolume@
  00086	68 02 00 00 80	 push	 -2147483646		; 80000002H
  0008b	ff d6		 call	 esi

; 901  : 	RegDeleteKey (HKEY_LOCAL_MACHINE, "Software\\Classes\\TrueCryptVolume\\DefaultIcon");

  0008d	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@DNPKJBAH@Software?2Classes?2TrueCryptVolume@
  00092	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00097	ff d6		 call	 esi

; 902  : 	RegDeleteKey (HKEY_LOCAL_MACHINE, "Software\\Classes\\TrueCryptVolume");

  00099	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@JOIIBOEC@Software?2Classes?2TrueCryptVolume@
  0009e	68 02 00 00 80	 push	 -2147483646		; 80000002H
  000a3	ff d6		 call	 esi

; 903  : 	RegDeleteKey (HKEY_CURRENT_USER, "Software\\TrueCrypt");

  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@NCHEPDGI@Software?2TrueCrypt?$AA@
  000aa	68 01 00 00 80	 push	 -2147483647		; 80000001H
  000af	ff d6		 call	 esi

; 904  : 
; 905  : 	if (!bRemoveDeprecated)

  000b1	85 ff		 test	 edi, edi
  000b3	75 42		 jne	 SHORT $LN10@DoRegUnins

; 906  : 	{
; 907  : 		/* CipherShed. */
; 908  : 		RegDeleteKey (HKEY_LOCAL_MACHINE, "Software\\CipherShed");

  000b5	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@GEGOEFMH@Software?2CipherShed?$AA@
  000ba	68 02 00 00 80	 push	 -2147483646		; 80000002H
  000bf	ff d6		 call	 esi

; 909  : 
; 910  : 		GetStartupRegKeyName (regk);

  000c1	8d 44 24 08	 lea	 eax, DWORD PTR _regk$[esp+76]
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 _GetStartupRegKeyName

; 911  : 		DeleteRegistryValue (regk, "CipherShed");

  000cb	8d 4c 24 0c	 lea	 ecx, DWORD PTR _regk$[esp+80]
  000cf	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FEEFGEIL@CipherShed?$AA@
  000d4	51		 push	 ecx
  000d5	e8 00 00 00 00	 call	 _DeleteRegistryValue
  000da	83 c4 0c	 add	 esp, 12			; 0000000cH

; 912  : 
; 913  : 		RegDeleteKey (HKEY_LOCAL_MACHINE, "Software\\Classes\\.tc");

  000dd	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@MHIJGGNK@Software?2Classes?2?4tc?$AA@
  000e2	68 02 00 00 80	 push	 -2147483646		; 80000002H
  000e7	ff d6		 call	 esi

; 914  : 		SHChangeNotify (SHCNE_ASSOCCHANGED, SHCNF_IDLIST, NULL, NULL);

  000e9	57		 push	 edi
  000ea	57		 push	 edi
  000eb	57		 push	 edi
  000ec	68 00 00 00 08	 push	 134217728		; 08000000H
  000f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SHChangeNotify@16
$LN10@DoRegUnins:

; 915  : 	}
; 916  : 
; 917  : 	bOK = TRUE;
; 918  : 
; 919  : 	if (bOK == FALSE && GetLastError ()!= ERROR_NO_TOKEN && GetLastError ()!= ERROR_FILE_NOT_FOUND
; 920  : 	    && GetLastError ()!= ERROR_PATH_NOT_FOUND)
; 921  : 	{
; 922  : 		handleWin32Error (hwndDlg);
; 923  : 	}
; 924  : 	else
; 925  : 		bOK = TRUE;
; 926  : 
; 927  : 	return bOK;
; 928  : }

  000f7	8b 4c 24 48	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+76]
  000fb	5f		 pop	 edi
  000fc	5e		 pop	 esi
  000fd	33 cc		 xor	 ecx, esp
  000ff	b8 01 00 00 00	 mov	 eax, 1
  00104	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00109	83 c4 44	 add	 esp, 68			; 00000044H
  0010c	c3		 ret	 0
_DoRegUninstall ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@BJNFCLGM@DRIVER_UINSTALL_FAILED?$AA@	; `string'
PUBLIC	??_C@_0BA@LFOBNNHD@REMOVING_DRIVER?$AA@		; `string'
PUBLIC	??_C@_08CGLLMHMN@STOPPING?$AA@			; `string'
PUBLIC	??_C@_0BA@HLDEBKOH@STOPPING_DRIVER?$AA@		; `string'
PUBLIC	??_C@_09EFLFAGB@truecrypt?$AA@			; `string'
PUBLIC	_lpszService$GSCopy$
PUBLIC	_hwndDlg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_DoServiceUninstall
EXTRN	__imp__MessageBoxW@16:PROC
EXTRN	_lpszTitle:DWORD
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__DeleteService@4:PROC
EXTRN	__imp__CloseServiceHandle@4:PROC
EXTRN	__imp__ControlService@12:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__QueryServiceStatus@8:PROC
EXTRN	??1BootEncryption@CipherShed@@QAE@XZ:PROC	; CipherShed::BootEncryption::~BootEncryption
EXTRN	?RegisterFilterDriver@BootEncryption@CipherShed@@QAEX_NW4FilterType@12@@Z:PROC ; CipherShed::BootEncryption::RegisterFilterDriver
EXTRN	?GetDriverServiceStartType@BootEncryption@CipherShed@@QAEKXZ:PROC ; CipherShed::BootEncryption::GetDriverServiceStartType
EXTRN	??0BootEncryption@CipherShed@@QAE@PAUHWND__@@@Z:PROC ; CipherShed::BootEncryption::BootEncryption
EXTRN	__imp__OpenServiceA@12:PROC
EXTRN	__imp__OpenSCManagerA@12:PROC
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT ??_C@_0BH@BJNFCLGM@DRIVER_UINSTALL_FAILED?$AA@
CONST	SEGMENT
??_C@_0BH@BJNFCLGM@DRIVER_UINSTALL_FAILED?$AA@ DB 'DRIVER_UINSTALL_FAILED'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LFOBNNHD@REMOVING_DRIVER?$AA@
CONST	SEGMENT
??_C@_0BA@LFOBNNHD@REMOVING_DRIVER?$AA@ DB 'REMOVING_DRIVER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08CGLLMHMN@STOPPING?$AA@
CONST	SEGMENT
??_C@_08CGLLMHMN@STOPPING?$AA@ DB 'STOPPING', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HLDEBKOH@STOPPING_DRIVER?$AA@
CONST	SEGMENT
??_C@_0BA@HLDEBKOH@STOPPING_DRIVER?$AA@ DB 'STOPPING_DRIVER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09EFLFAGB@truecrypt?$AA@
CONST	SEGMENT
??_C@_09EFLFAGB@truecrypt?$AA@ DB 'truecrypt', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$_DoServiceUninstall$21 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_DoServiceUninstall$8
__catchsym$_DoServiceUninstall$20 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_DoServiceUninstall$6
__catchsym$_DoServiceUninstall$19 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_DoServiceUninstall$4
__catchsym$_DoServiceUninstall$18 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_DoServiceUninstall$2
__ehfuncinfo$_DoServiceUninstall DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$_DoServiceUninstall
	DD	04H
	DD	FLAT:__tryblocktable$_DoServiceUninstall
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$_DoServiceUninstall DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$_DoServiceUninstall$17
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$_DoServiceUninstall DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$_DoServiceUninstall$18
	DD	04H
	DD	04H
	DD	05H
	DD	01H
	DD	FLAT:__catchsym$_DoServiceUninstall$19
	DD	06H
	DD	06H
	DD	07H
	DD	01H
	DD	FLAT:__catchsym$_DoServiceUninstall$20
	DD	00H
	DD	07H
	DD	08H
	DD	01H
	DD	FLAT:__catchsym$_DoServiceUninstall$21
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT _DoServiceUninstall
_TEXT	SEGMENT
_status$ = -68						; size = 28
_firstTry$ = -40					; size = 4
_lpszService$GSCopy$ = -36				; size = 4
_hwndDlg$GSCopy$ = -32					; size = 4
_hService$ = -28					; size = 4
_bOK$ = -24						; size = 4
_hManager$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_bootEnc$134508 = 0					; size = 1560
__$ArrayPad$ = 1560					; size = 4
_hwndDlg$ = 1572					; size = 4
_lpszService$ = 1576					; size = 4
_DoServiceUninstall PROC				; COMDAT

; 938  : {

  00000	55		 push	 ebp
  00001	8d ac 24 e4 f9
	ff ff		 lea	 ebp, DWORD PTR [esp-1564]
  00008	81 ec 1c 06 00
	00		 sub	 esp, 1564		; 0000061cH
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$_DoServiceUninstall
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	83 ec 38	 sub	 esp, 56			; 00000038H
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c5		 xor	 eax, ebp
  00026	89 85 18 06 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002c	53		 push	 ebx
  0002d	56		 push	 esi
  0002e	57		 push	 edi
  0002f	50		 push	 eax
  00030	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00033	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00039	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0003c	8b 9d 24 06 00
	00		 mov	 ebx, DWORD PTR _hwndDlg$[ebp]
  00042	8b b5 28 06 00
	00		 mov	 esi, DWORD PTR _lpszService$[ebp]

; 939  : 	SC_HANDLE hManager, hService = NULL;

  00048	33 c0		 xor	 eax, eax
  0004a	89 5d e0	 mov	 DWORD PTR _hwndDlg$GSCopy$[ebp], ebx
  0004d	89 75 dc	 mov	 DWORD PTR _lpszService$GSCopy$[ebp], esi
  00050	33 ff		 xor	 edi, edi

; 940  : 	BOOL bOK = FALSE, bRet;

  00052	89 45 e8	 mov	 DWORD PTR _bOK$[ebp], eax

; 941  : 	SERVICE_STATUS status;
; 942  : 	BOOL firstTry = TRUE;

  00055	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR _firstTry$[ebp], 1

; 943  : 	int x;
; 944  : 
; 945  : 	memset (&status, 0, sizeof (status));	/* Keep VC6 quiet */

  0005c	89 45 bc	 mov	 DWORD PTR _status$[ebp], eax
  0005f	89 45 c0	 mov	 DWORD PTR _status$[ebp+4], eax
  00062	89 45 c4	 mov	 DWORD PTR _status$[ebp+8], eax
  00065	89 45 c8	 mov	 DWORD PTR _status$[ebp+12], eax
  00068	89 45 cc	 mov	 DWORD PTR _status$[ebp+16], eax
  0006b	89 45 d0	 mov	 DWORD PTR _status$[ebp+20], eax
  0006e	89 45 d4	 mov	 DWORD PTR _status$[ebp+24], eax
$retry$134499:

; 946  : 
; 947  : retry:
; 948  : 
; 949  : 	/* Service control manager. */
; 950  : 	hManager = OpenSCManager (NULL, NULL, SC_MANAGER_ALL_ACCESS);

  00071	68 3f 00 0f 00	 push	 983103			; 000f003fH
  00076	6a 00		 push	 0
  00078	6a 00		 push	 0
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenSCManagerA@12
  00080	89 45 ec	 mov	 DWORD PTR _hManager$[ebp], eax

; 951  : 	if (hManager == NULL)

  00083	85 c0		 test	 eax, eax
  00085	0f 84 04 03 00
	00		 je	 $LN96@DoServiceU

; 952  : 		goto error;
; 953  : 
; 954  : 	hService = OpenService (hManager, lpszService, SERVICE_ALL_ACCESS);

  0008b	68 ff 01 0f 00	 push	 983551			; 000f01ffH
  00090	56		 push	 esi
  00091	50		 push	 eax
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenServiceA@12
  00098	8b f8		 mov	 edi, eax
  0009a	89 7d e4	 mov	 DWORD PTR _hService$[ebp], edi

; 955  : 	if (hService == NULL)

  0009d	85 ff		 test	 edi, edi
  0009f	0f 84 ea 02 00
	00		 je	 $LN96@DoServiceU

; 956  : 		goto error;
; 957  : 
; 958  : 	if (strcmp ("truecrypt", lpszService) == 0)

  000a5	8b ce		 mov	 ecx, esi
  000a7	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09EFLFAGB@truecrypt?$AA@
  000ac	8d 64 24 00	 npad	 4
$LL79@DoServiceU:
  000b0	8a 10		 mov	 dl, BYTE PTR [eax]
  000b2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000b4	75 1a		 jne	 SHORT $LN80@DoServiceU
  000b6	84 d2		 test	 dl, dl
  000b8	74 12		 je	 SHORT $LN81@DoServiceU
  000ba	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000bd	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000c0	75 0e		 jne	 SHORT $LN80@DoServiceU
  000c2	83 c0 02	 add	 eax, 2
  000c5	83 c1 02	 add	 ecx, 2
  000c8	84 d2		 test	 dl, dl
  000ca	75 e4		 jne	 SHORT $LL79@DoServiceU
$LN81@DoServiceU:
  000cc	33 c0		 xor	 eax, eax
  000ce	eb 05		 jmp	 SHORT $LN82@DoServiceU
$LN80@DoServiceU:
  000d0	1b c0		 sbb	 eax, eax
  000d2	83 d8 ff	 sbb	 eax, -1
$LN82@DoServiceU:
  000d5	85 c0		 test	 eax, eax
  000d7	0f 85 e8 00 00
	00		 jne	 $LN39@DoServiceU

; 959  : 	{
; 960  : 		try
; 961  : 		{
; 962  : 			BootEncryption bootEnc (hwndDlg);

  000dd	53		 push	 ebx
  000de	8d 4d 00	 lea	 ecx, DWORD PTR _bootEnc$134508[ebp]
  000e1	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+12], eax
  000e4	e8 00 00 00 00	 call	 ??0BootEncryption@CipherShed@@QAE@PAUHWND__@@@Z ; CipherShed::BootEncryption::BootEncryption

; 963  : 
; 964  : 			if (bootEnc.GetDriverServiceStartType() == SERVICE_BOOT_START)

  000e9	8d 4d 00	 lea	 ecx, DWORD PTR _bootEnc$134508[ebp]
  000ec	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  000f0	e8 00 00 00 00	 call	 ?GetDriverServiceStartType@BootEncryption@CipherShed@@QAEKXZ ; CipherShed::BootEncryption::GetDriverServiceStartType
  000f5	85 c0		 test	 eax, eax
  000f7	0f 85 82 00 00
	00		 jne	 $LN60@DoServiceU

; 965  : 			{
; 966  : 				/* Uninstall filter drivers. */
; 967  : 				try { bootEnc.RegisterFilterDriver (false, BootEncryption::DriveFilter); } catch (...) { }

  000fd	50		 push	 eax
  000fe	50		 push	 eax
  000ff	8d 4d 00	 lea	 ecx, DWORD PTR _bootEnc$134508[ebp]
  00102	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00106	e8 00 00 00 00	 call	 ?RegisterFilterDriver@BootEncryption@CipherShed@@QAEX_NW4FilterType@12@@Z ; CipherShed::BootEncryption::RegisterFilterDriver
  0010b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  00112	eb 13		 jmp	 SHORT $LN56@DoServiceU
__catch$_DoServiceUninstall$2:
  00114	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  0011b	b8 00 00 00 00	 mov	 eax, $LN88@DoServiceU
  00120	c3		 ret	 0
$LN88@DoServiceU:
  00121	8b 7d e4	 mov	 edi, DWORD PTR _hService$[ebp]
  00124	8b 5d e0	 mov	 ebx, DWORD PTR _hwndDlg$GSCopy$[ebp]
$LN56@DoServiceU:

; 968  : 				try { bootEnc.RegisterFilterDriver (false, BootEncryption::VolumeFilter); } catch (...) { }

  00127	6a 01		 push	 1
  00129	6a 00		 push	 0
  0012b	8d 4d 00	 lea	 ecx, DWORD PTR _bootEnc$134508[ebp]
  0012e	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
  00132	e8 00 00 00 00	 call	 ?RegisterFilterDriver@BootEncryption@CipherShed@@QAEX_NW4FilterType@12@@Z ; CipherShed::BootEncryption::RegisterFilterDriver
  00137	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  0013e	eb 13		 jmp	 SHORT $LN58@DoServiceU
__catch$_DoServiceUninstall$4:
  00140	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  00147	b8 00 00 00 00	 mov	 eax, $LN89@DoServiceU
  0014c	c3		 ret	 0
$LN89@DoServiceU:
  0014d	8b 7d e4	 mov	 edi, DWORD PTR _hService$[ebp]
  00150	8b 5d e0	 mov	 ebx, DWORD PTR _hwndDlg$GSCopy$[ebp]
$LN58@DoServiceU:

; 969  : 				try { bootEnc.RegisterFilterDriver (false, BootEncryption::DumpFilter); } catch (...) { }

  00153	6a 02		 push	 2
  00155	6a 00		 push	 0
  00157	8d 4d 00	 lea	 ecx, DWORD PTR _bootEnc$134508[ebp]
  0015a	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
  0015e	e8 00 00 00 00	 call	 ?RegisterFilterDriver@BootEncryption@CipherShed@@QAEX_NW4FilterType@12@@Z ; CipherShed::BootEncryption::RegisterFilterDriver
  00163	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  0016a	eb 13		 jmp	 SHORT $LN60@DoServiceU
__catch$_DoServiceUninstall$6:
  0016c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  00173	b8 00 00 00 00	 mov	 eax, $LN90@DoServiceU
  00178	c3		 ret	 0
$LN90@DoServiceU:
  00179	8b 7d e4	 mov	 edi, DWORD PTR _hService$[ebp]
  0017c	8b 5d e0	 mov	 ebx, DWORD PTR _hwndDlg$GSCopy$[ebp]
$LN60@DoServiceU:

; 970  : 			}
; 971  : 		}

  0017f	8d 4d 00	 lea	 ecx, DWORD PTR _bootEnc$134508[ebp]
  00182	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  00186	e8 00 00 00 00	 call	 ??1BootEncryption@CipherShed@@QAE@XZ ; CipherShed::BootEncryption::~BootEncryption

; 973  : 
; 974  : 		StatusMessage (hwndDlg, "STOPPING_DRIVER");

  0018b	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@HLDEBKOH@STOPPING_DRIVER?$AA@
  00190	53		 push	 ebx
  00191	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00198	e8 00 00 00 00	 call	 _StatusMessage
  0019d	83 c4 08	 add	 esp, 8

; 975  : 	}
; 976  : 	else

  001a0	eb 32		 jmp	 SHORT $LN33@DoServiceU
__catch$_DoServiceUninstall$8:

; 972  : 		catch (...) { }

  001a2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  001a9	b8 00 00 00 00	 mov	 eax, $LN91@DoServiceU
  001ae	c3		 ret	 0
$LN91@DoServiceU:
  001af	8b 5d e0	 mov	 ebx, DWORD PTR _hwndDlg$GSCopy$[ebp]
  001b2	8b 7d e4	 mov	 edi, DWORD PTR _hService$[ebp]

; 973  : 
; 974  : 		StatusMessage (hwndDlg, "STOPPING_DRIVER");

  001b5	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@HLDEBKOH@STOPPING_DRIVER?$AA@
  001ba	53		 push	 ebx
  001bb	e8 00 00 00 00	 call	 _StatusMessage
  001c0	83 c4 08	 add	 esp, 8

; 975  : 	}
; 976  : 	else

  001c3	eb 0f		 jmp	 SHORT $LN33@DoServiceU
$LN39@DoServiceU:

; 977  : 		StatusMessageParam (hwndDlg, "STOPPING", lpszService);

  001c5	56		 push	 esi
  001c6	68 00 00 00 00	 push	 OFFSET ??_C@_08CGLLMHMN@STOPPING?$AA@
  001cb	53		 push	 ebx
  001cc	e8 00 00 00 00	 call	 _StatusMessageParam
  001d1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN33@DoServiceU:

; 978  : 
; 979  : #define WAIT_PERIOD 3
; 980  : 
; 981  : 	/* Status pending. */
; 982  : 	for (x = 0; x < WAIT_PERIOD; x++)

  001d4	33 f6		 xor	 esi, esi
$LL32@DoServiceU:

; 983  : 	{
; 984  : 		bRet = QueryServiceStatus (hService, &status);

  001d6	8d 45 bc	 lea	 eax, DWORD PTR _status$[ebp]
  001d9	50		 push	 eax
  001da	57		 push	 edi
  001db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryServiceStatus@8

; 985  : 		if (bRet != TRUE)

  001e1	83 f8 01	 cmp	 eax, 1
  001e4	0f 85 a5 01 00
	00		 jne	 $LN96@DoServiceU

; 986  : 			goto error;
; 987  : 
; 988  : 		if (status.dwCurrentState != SERVICE_START_PENDING &&
; 989  : 		    status.dwCurrentState != SERVICE_STOP_PENDING &&
; 990  : 		    status.dwCurrentState != SERVICE_CONTINUE_PENDING)

  001ea	8b 45 c0	 mov	 eax, DWORD PTR _status$[ebp+4]
  001ed	83 f8 02	 cmp	 eax, 2
  001f0	74 0a		 je	 SHORT $LN27@DoServiceU
  001f2	83 f8 03	 cmp	 eax, 3
  001f5	74 05		 je	 SHORT $LN27@DoServiceU
  001f7	83 f8 05	 cmp	 eax, 5
  001fa	75 14		 jne	 SHORT $LN74@DoServiceU
$LN27@DoServiceU:

; 991  : 			break;
; 992  : 
; 993  : 		Sleep (1000);

  001fc	68 e8 03 00 00	 push	 1000			; 000003e8H
  00201	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
  00207	46		 inc	 esi
  00208	83 fe 03	 cmp	 esi, 3
  0020b	7c c9		 jl	 SHORT $LL32@DoServiceU

; 978  : 
; 979  : #define WAIT_PERIOD 3
; 980  : 
; 981  : 	/* Status pending. */
; 982  : 	for (x = 0; x < WAIT_PERIOD; x++)

  0020d	8b 45 c0	 mov	 eax, DWORD PTR _status$[ebp+4]
$LN74@DoServiceU:

; 994  : 	}
; 995  : 
; 996  : 	/* Check if the service is running (driver is loaded). */
; 997  : 	if (status.dwCurrentState != SERVICE_STOPPED)

  00210	83 f8 01	 cmp	 eax, 1
  00213	74 5b		 je	 SHORT $try_delete$134524

; 998  : 	{
; 999  : 		/* Stop the service (unload the driver). */
; 1000 : 		bRet = ControlService (hService, SERVICE_CONTROL_STOP, &status);

  00215	8d 4d bc	 lea	 ecx, DWORD PTR _status$[ebp]
  00218	51		 push	 ecx
  00219	6a 01		 push	 1
  0021b	57		 push	 edi
  0021c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ControlService@12

; 1001 : 		if (bRet == FALSE)

  00222	85 c0		 test	 eax, eax
  00224	74 4a		 je	 SHORT $try_delete$134524

; 1002 : 			goto try_delete;
; 1003 : 
; 1004 : 		/* Status pending. */
; 1005 : 		for (x = 0; x < WAIT_PERIOD; x++)

  00226	33 f6		 xor	 esi, esi
$LL23@DoServiceU:

; 1006 : 		{
; 1007 : 			bRet = QueryServiceStatus (hService, &status);

  00228	8d 55 bc	 lea	 edx, DWORD PTR _status$[ebp]
  0022b	52		 push	 edx
  0022c	57		 push	 edi
  0022d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryServiceStatus@8

; 1008 : 			if (bRet != TRUE)

  00233	83 f8 01	 cmp	 eax, 1
  00236	0f 85 53 01 00
	00		 jne	 $LN96@DoServiceU

; 1009 : 				goto error;
; 1010 : 
; 1011 : 			if (status.dwCurrentState != SERVICE_START_PENDING &&
; 1012 : 			    status.dwCurrentState != SERVICE_STOP_PENDING &&
; 1013 : 			  status.dwCurrentState != SERVICE_CONTINUE_PENDING)

  0023c	8b 45 c0	 mov	 eax, DWORD PTR _status$[ebp+4]
  0023f	83 f8 02	 cmp	 eax, 2
  00242	74 0a		 je	 SHORT $LN18@DoServiceU
  00244	83 f8 03	 cmp	 eax, 3
  00247	74 05		 je	 SHORT $LN18@DoServiceU
  00249	83 f8 05	 cmp	 eax, 5
  0024c	75 14		 jne	 SHORT $LN76@DoServiceU
$LN18@DoServiceU:

; 1014 : 				break;
; 1015 : 
; 1016 : 			Sleep (1000);

  0024e	68 e8 03 00 00	 push	 1000			; 000003e8H
  00253	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
  00259	46		 inc	 esi
  0025a	83 fe 03	 cmp	 esi, 3
  0025d	7c c9		 jl	 SHORT $LL23@DoServiceU

; 1002 : 			goto try_delete;
; 1003 : 
; 1004 : 		/* Status pending. */
; 1005 : 		for (x = 0; x < WAIT_PERIOD; x++)

  0025f	8b 45 c0	 mov	 eax, DWORD PTR _status$[ebp+4]
$LN76@DoServiceU:

; 1017 : 		}
; 1018 : 
; 1019 : 		if (status.dwCurrentState != SERVICE_STOPPED && status.dwCurrentState != SERVICE_STOP_PENDING)

  00262	83 f8 01	 cmp	 eax, 1
  00265	74 09		 je	 SHORT $try_delete$134524
  00267	83 f8 03	 cmp	 eax, 3
  0026a	0f 85 1f 01 00
	00		 jne	 $LN96@DoServiceU
$try_delete$134524:

; 1020 : 			goto error;
; 1021 : 	}
; 1022 : 
; 1023 : try_delete:
; 1024 : 
; 1025 : 	if (strcmp ("truecrypt", lpszService) == 0)

  00270	8b 75 dc	 mov	 esi, DWORD PTR _lpszService$GSCopy$[ebp]
  00273	8b ce		 mov	 ecx, esi
  00275	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09EFLFAGB@truecrypt?$AA@
  0027a	8d 9b 00 00 00
	00		 npad	 6
$LL83@DoServiceU:
  00280	8a 10		 mov	 dl, BYTE PTR [eax]
  00282	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00284	75 1a		 jne	 SHORT $LN84@DoServiceU
  00286	84 d2		 test	 dl, dl
  00288	74 12		 je	 SHORT $LN85@DoServiceU
  0028a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0028d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00290	75 0e		 jne	 SHORT $LN84@DoServiceU
  00292	83 c0 02	 add	 eax, 2
  00295	83 c1 02	 add	 ecx, 2
  00298	84 d2		 test	 dl, dl
  0029a	75 e4		 jne	 SHORT $LL83@DoServiceU
$LN85@DoServiceU:
  0029c	33 c0		 xor	 eax, eax
  0029e	eb 05		 jmp	 SHORT $LN86@DoServiceU
$LN84@DoServiceU:
  002a0	1b c0		 sbb	 eax, eax
  002a2	83 d8 ff	 sbb	 eax, -1
$LN86@DoServiceU:
  002a5	85 c0		 test	 eax, eax
  002a7	75 5a		 jne	 SHORT $LN15@DoServiceU

; 1026 : 		StatusMessage (hwndDlg, "REMOVING_DRIVER");

  002a9	39 05 00 00 00
	00		 cmp	 DWORD PTR _Rollback, eax
  002af	75 61		 jne	 SHORT $LN14@DoServiceU
  002b1	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@LFOBNNHD@REMOVING_DRIVER?$AA@
  002b6	e8 00 00 00 00	 call	 _GetString
  002bb	83 c4 04	 add	 esp, 4
  002be	50		 push	 eax
  002bf	6a 00		 push	 0
  002c1	68 80 01 00 00	 push	 384			; 00000180H
  002c6	68 f9 03 00 00	 push	 1017			; 000003f9H
  002cb	53		 push	 ebx
  002cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  002d2	50		 push	 eax
  002d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageW@16
  002d9	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendDlgItemMessageA@20
  002df	6a 00		 push	 0
  002e1	6a 00		 push	 0
  002e3	6a 00		 push	 0
  002e5	68 8b 01 00 00	 push	 395			; 0000018bH
  002ea	68 f9 03 00 00	 push	 1017			; 000003f9H
  002ef	53		 push	 ebx
  002f0	ff d6		 call	 esi
  002f2	48		 dec	 eax
  002f3	50		 push	 eax
  002f4	68 97 01 00 00	 push	 407			; 00000197H
  002f9	68 f9 03 00 00	 push	 1017			; 000003f9H
  002fe	53		 push	 ebx
  002ff	ff d6		 call	 esi

; 1027 : 	else

  00301	eb 0f		 jmp	 SHORT $LN14@DoServiceU
$LN15@DoServiceU:

; 1028 : 		StatusMessageParam (hwndDlg, "REMOVING", lpszService);

  00303	56		 push	 esi
  00304	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  00309	53		 push	 ebx
  0030a	e8 00 00 00 00	 call	 _StatusMessageParam
  0030f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@DoServiceU:

; 1029 : 
; 1030 : 	if (hService != NULL)
; 1031 : 		CloseServiceHandle (hService);

  00312	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CloseServiceHandle@4
  00318	57		 push	 edi
  00319	ff d6		 call	 esi

; 1032 : 
; 1033 : 	if (hManager != NULL)
; 1034 : 		CloseServiceHandle (hManager);

  0031b	8b 45 ec	 mov	 eax, DWORD PTR _hManager$[ebp]
  0031e	50		 push	 eax
  0031f	ff d6		 call	 esi

; 1035 : 
; 1036 : 	hManager = OpenSCManager (NULL, NULL, SC_MANAGER_ALL_ACCESS);

  00321	68 3f 00 0f 00	 push	 983103			; 000f003fH
  00326	6a 00		 push	 0
  00328	6a 00		 push	 0
  0032a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenSCManagerA@12
  00330	89 45 ec	 mov	 DWORD PTR _hManager$[ebp], eax

; 1037 : 	if (hManager == NULL)

  00333	85 c0		 test	 eax, eax
  00335	74 5e		 je	 SHORT $error$134501

; 1038 : 		goto error;
; 1039 : 
; 1040 : 	hService = OpenService (hManager, lpszService, SERVICE_ALL_ACCESS);

  00337	8b 4d dc	 mov	 ecx, DWORD PTR _lpszService$GSCopy$[ebp]
  0033a	68 ff 01 0f 00	 push	 983551			; 000f01ffH
  0033f	51		 push	 ecx
  00340	8b d0		 mov	 edx, eax
  00342	52		 push	 edx
  00343	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenServiceA@12
  00349	8b f8		 mov	 edi, eax

; 1041 : 	if (hService == NULL)

  0034b	85 ff		 test	 edi, edi
  0034d	74 46		 je	 SHORT $error$134501

; 1042 : 		goto error;
; 1043 : 
; 1044 : 	/* Delete service registry keys. */
; 1045 : 	bRet = DeleteService (hService);

  0034f	57		 push	 edi
  00350	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteService@4

; 1046 : 	if (bRet == FALSE)

  00356	85 c0		 test	 eax, eax
  00358	75 77		 jne	 SHORT $LN4@DoServiceU

; 1047 : 	{
; 1048 : 		if (firstTry && GetLastError () == ERROR_SERVICE_MARKED_FOR_DELETE)

  0035a	39 45 d8	 cmp	 DWORD PTR _firstTry$[ebp], eax
  0035d	74 36		 je	 SHORT $error$134501
  0035f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00365	3d 30 04 00 00	 cmp	 eax, 1072		; 00000430H
  0036a	75 29		 jne	 SHORT $error$134501

; 1049 : 		{
; 1050 : 			// Second try for an eventual no-install driver instance
; 1051 : 			CloseServiceHandle (hService);

  0036c	57		 push	 edi
  0036d	ff d6		 call	 esi

; 1052 : 			CloseServiceHandle (hManager);

  0036f	8b 45 ec	 mov	 eax, DWORD PTR _hManager$[ebp]
  00372	50		 push	 eax
  00373	ff d6		 call	 esi

; 1053 : 
; 1054 : 			Sleep(1000);

  00375	68 e8 03 00 00	 push	 1000			; 000003e8H
  0037a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 1055 : 			firstTry = FALSE;
; 1056 : 			goto retry;

  00380	8b 75 dc	 mov	 esi, DWORD PTR _lpszService$GSCopy$[ebp]
  00383	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _firstTry$[ebp], 0
  0038a	e9 e2 fc ff ff	 jmp	 $retry$134499
$LN96@DoServiceU:
  0038f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CloseServiceHandle@4
$error$134501:

; 1057 : 		}
; 1058 : 
; 1059 : 		goto error;
; 1060 : 	}
; 1061 : 
; 1062 : 	bOK = TRUE;
; 1063 : 
; 1064 : error:
; 1065 : 
; 1066 : 	if (bOK == FALSE && GetLastError ()!= ERROR_SERVICE_DOES_NOT_EXIST)

  00395	83 7d e8 00	 cmp	 DWORD PTR _bOK$[ebp], 0
  00399	75 36		 jne	 SHORT $LN4@DoServiceU
  0039b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  003a1	3d 24 04 00 00	 cmp	 eax, 1060		; 00000424H
  003a6	74 29		 je	 SHORT $LN4@DoServiceU

; 1067 : 	{
; 1068 : 		handleWin32Error (hwndDlg);

  003a8	53		 push	 ebx
  003a9	e8 00 00 00 00	 call	 _handleWin32Error

; 1069 : 		MessageBoxW (hwndDlg, GetString ("DRIVER_UINSTALL_FAILED"), lpszTitle, MB_ICONHAND);

  003ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpszTitle
  003b4	83 c4 04	 add	 esp, 4
  003b7	6a 10		 push	 16			; 00000010H
  003b9	51		 push	 ecx
  003ba	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@BJNFCLGM@DRIVER_UINSTALL_FAILED?$AA@
  003bf	e8 00 00 00 00	 call	 _GetString
  003c4	83 c4 04	 add	 esp, 4
  003c7	50		 push	 eax
  003c8	53		 push	 ebx
  003c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 1070 : 	}
; 1071 : 	else

  003cf	eb 07		 jmp	 SHORT $LN3@DoServiceU
$LN4@DoServiceU:

; 1072 : 		bOK = TRUE;

  003d1	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _bOK$[ebp], 1
$LN3@DoServiceU:

; 1073 : 
; 1074 : 	if (hService != NULL)

  003d8	85 ff		 test	 edi, edi
  003da	74 03		 je	 SHORT $LN2@DoServiceU

; 1075 : 		CloseServiceHandle (hService);

  003dc	57		 push	 edi
  003dd	ff d6		 call	 esi
$LN2@DoServiceU:

; 1076 : 
; 1077 : 	if (hManager != NULL)

  003df	8b 45 ec	 mov	 eax, DWORD PTR _hManager$[ebp]
  003e2	85 c0		 test	 eax, eax
  003e4	74 03		 je	 SHORT $LN87@DoServiceU

; 1078 : 		CloseServiceHandle (hManager);

  003e6	50		 push	 eax
  003e7	ff d6		 call	 esi
$LN87@DoServiceU:

; 1079 : 
; 1080 : 	return bOK;

  003e9	8b 45 e8	 mov	 eax, DWORD PTR _bOK$[ebp]

; 1081 : }

  003ec	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  003ef	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003f6	59		 pop	 ecx
  003f7	5f		 pop	 edi
  003f8	5e		 pop	 esi
  003f9	5b		 pop	 ebx
  003fa	8b 8d 18 06 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00400	33 cd		 xor	 ecx, ebp
  00402	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00407	81 c5 1c 06 00
	00		 add	 ebp, 1564		; 0000061cH
  0040d	8b e5		 mov	 esp, ebp
  0040f	5d		 pop	 ebp
  00410	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_DoServiceUninstall$17:
  00000	8d 4d 00	 lea	 ecx, DWORD PTR _bootEnc$134508[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1BootEncryption@CipherShed@@QAE@XZ ; CipherShed::BootEncryption::~BootEncryption
__ehhandler$_DoServiceUninstall:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 8a 24 06 00
	00		 mov	 ecx, DWORD PTR [edx+1572]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_DoServiceUninstall
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_DoServiceUninstall ENDP
PUBLIC	??_C@_0P@KGAEHPDJ@CLOSE_TC_FIRST?$AA@		; `string'
PUBLIC	??_C@_0BD@OMJBKKEL@DISMOUNT_ALL_FIRST?$AA@	; `string'
PUBLIC	??_C@_0CC@MKLHADEI@SETUP_FAILED_BOOT_DRIVE_ENCRYPTE@ ; `string'
PUBLIC	??_C@_0CM@LPOONFIE@SETUP_FAILED_BOOT_DRIVE_ENCRYPTE@ ; `string'
PUBLIC	??_C@_0DA@EDIMDHJI@SYS_ENCRYPTION_UPGRADE_UNSUPPORT@ ; `string'
PUBLIC	??_C@_0BM@PPLHKJJC@UPDATE_TC_IN_DECOY_OS_FIRST?$AA@ ; `string'
PUBLIC	??_C@_08ELEAABKI@NODRIVER?$AA@			; `string'
PUBLIC	_hwndDlg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_DoDriverUnload
EXTRN	__imp__EnumWindows@8:PROC
EXTRN	_CloseTCWindowsEnum@8:PROC
EXTRN	_CurrentOSServicePack:DWORD
EXTRN	_CurrentOSMinor:DWORD
EXTRN	_CurrentOSMajor:DWORD
EXTRN	?SetDriverServiceStartType@BootEncryption@CipherShed@@QAEXK@Z:PROC ; CipherShed::BootEncryption::SetDriverServiceStartType
EXTRN	?GetStatus@BootEncryption@CipherShed@@QAE?AUBootEncryptionStatus@@XZ:PROC ; CipherShed::BootEncryption::GetStatus
EXTRN	_AbortProcessSilent:PROC
EXTRN	_AskWarnNoYes:PROC
EXTRN	?GetInstalledBootLoaderVersion@BootEncryption@CipherShed@@QAEGXZ:PROC ; CipherShed::BootEncryption::GetInstalledBootLoaderVersion
EXTRN	_IsHiddenOSRunning:PROC
EXTRN	_handleError:PROC
EXTRN	_AbortProcess:PROC
EXTRN	__chkstk:PROC
;	COMDAT ??_C@_0P@KGAEHPDJ@CLOSE_TC_FIRST?$AA@
CONST	SEGMENT
??_C@_0P@KGAEHPDJ@CLOSE_TC_FIRST?$AA@ DB 'CLOSE_TC_FIRST', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OMJBKKEL@DISMOUNT_ALL_FIRST?$AA@
CONST	SEGMENT
??_C@_0BD@OMJBKKEL@DISMOUNT_ALL_FIRST?$AA@ DB 'DISMOUNT_ALL_FIRST', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@MKLHADEI@SETUP_FAILED_BOOT_DRIVE_ENCRYPTE@
CONST	SEGMENT
??_C@_0CC@MKLHADEI@SETUP_FAILED_BOOT_DRIVE_ENCRYPTE@ DB 'SETUP_FAILED_BOO'
	DB	'T_DRIVE_ENCRYPTED', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@LPOONFIE@SETUP_FAILED_BOOT_DRIVE_ENCRYPTE@
CONST	SEGMENT
??_C@_0CM@LPOONFIE@SETUP_FAILED_BOOT_DRIVE_ENCRYPTE@ DB 'SETUP_FAILED_BOO'
	DB	'T_DRIVE_ENCRYPTED_DOWNGRADE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@EDIMDHJI@SYS_ENCRYPTION_UPGRADE_UNSUPPORT@
CONST	SEGMENT
??_C@_0DA@EDIMDHJI@SYS_ENCRYPTION_UPGRADE_UNSUPPORT@ DB 'SYS_ENCRYPTION_U'
	DB	'PGRADE_UNSUPPORTED_ON_VISTA_SP0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PPLHKJJC@UPDATE_TC_IN_DECOY_OS_FIRST?$AA@
CONST	SEGMENT
??_C@_0BM@PPLHKJJC@UPDATE_TC_IN_DECOY_OS_FIRST?$AA@ DB 'UPDATE_TC_IN_DECO'
	DB	'Y_OS_FIRST', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08ELEAABKI@NODRIVER?$AA@
CONST	SEGMENT
??_C@_08ELEAABKI@NODRIVER?$AA@ DB 'NODRIVER', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$_DoDriverUnload$15 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_DoDriverUnload$8
__catchsym$_DoDriverUnload$14 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_DoDriverUnload$6
__catchsym$_DoDriverUnload$13 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_DoDriverUnload$4
__catchsym$_DoDriverUnload$12 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_DoDriverUnload$2
__catchsym$_DoDriverUnload$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_DoDriverUnload$0
__ehfuncinfo$_DoDriverUnload DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$_DoDriverUnload
	DD	05H
	DD	FLAT:__tryblocktable$_DoDriverUnload
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$_DoDriverUnload DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$_DoDriverUnload$10
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$_DoDriverUnload DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$_DoDriverUnload$11
	DD	04H
	DD	04H
	DD	05H
	DD	01H
	DD	FLAT:__catchsym$_DoDriverUnload$12
	DD	06H
	DD	06H
	DD	07H
	DD	01H
	DD	FLAT:__catchsym$_DoDriverUnload$13
	DD	08H
	DD	08H
	DD	09H
	DD	01H
	DD	FLAT:__catchsym$_DoDriverUnload$14
	DD	00H
	DD	09H
	DD	0aH
	DD	01H
	DD	FLAT:__catchsym$_DoDriverUnload$15
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT _DoDriverUnload
_TEXT	SEGMENT
_driver$134563 = -14072					; size = 13940
$T138351 = -130						; size = 94
_refCount$134565 = -36					; size = 4
_dwResult$134566 = -32					; size = 4
_hwndDlg$GSCopy$ = -28					; size = 4
_TCWindowClosed$134601 = -24				; size = 4
_driverVersion$134564 = -24				; size = 4
_volumesMounted$134593 = -20				; size = 4
__$EHRec$ = -16						; size = 16
_bootEnc$134569 = 0					; size = 1560
__$ArrayPad$ = 1560					; size = 4
_hwndDlg$ = 1572					; size = 4
_DoDriverUnload PROC					; COMDAT

; 1089 : {

  00000	55		 push	 ebp
  00001	8d ac 24 e4 f9
	ff ff		 lea	 ebp, DWORD PTR [esp-1564]
  00008	81 ec 1c 06 00
	00		 sub	 esp, 1564		; 0000061cH
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$_DoDriverUnload
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	51		 push	 ecx
  0001d	b8 e8 36 00 00	 mov	 eax, 14056		; 000036e8H
  00022	e8 00 00 00 00	 call	 __chkstk
  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002c	33 c5		 xor	 eax, ebp
  0002e	89 85 18 06 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00034	53		 push	 ebx
  00035	56		 push	 esi
  00036	57		 push	 edi
  00037	50		 push	 eax
  00038	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  0003b	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00041	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00044	8b b5 24 06 00
	00		 mov	 esi, DWORD PTR _hwndDlg$[ebp]

; 1090 : 	BOOL bOK = TRUE;

  0004a	bb 01 00 00 00	 mov	 ebx, 1
  0004f	89 75 e4	 mov	 DWORD PTR _hwndDlg$GSCopy$[ebp], esi
  00052	8b fb		 mov	 edi, ebx

; 1091 : 	int status;
; 1092 : 
; 1093 : 	/* Open a handle to the driver device. */
; 1094 : 	status = DriverAttach ();

  00054	e8 00 00 00 00	 call	 _DriverAttach

; 1095 : 	if (status != 0)

  00059	85 c0		 test	 eax, eax
  0005b	74 39		 je	 SHORT $LN32@DoDriverUn

; 1096 : 	{
; 1097 : 		if (status == ERR_OS_ERROR && GetLastError () != ERROR_FILE_NOT_FOUND)

  0005d	3b c3		 cmp	 eax, ebx
  0005f	75 20		 jne	 SHORT $LN68@DoDriverUn
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00067	83 f8 02	 cmp	 eax, 2
  0006a	74 2a		 je	 SHORT $LN32@DoDriverUn

; 1098 : 		{
; 1099 : 			handleWin32Error (hwndDlg);

  0006c	56		 push	 esi
  0006d	e8 00 00 00 00	 call	 _handleWin32Error

; 1100 : 			AbortProcess ("NODRIVER");

  00072	68 00 00 00 00	 push	 OFFSET ??_C@_08ELEAABKI@NODRIVER?$AA@
  00077	e8 00 00 00 00	 call	 _AbortProcess
  0007c	83 c4 08	 add	 esp, 8

; 1101 : 		}
; 1102 : 
; 1103 : 		if (status != ERR_OS_ERROR)

  0007f	eb 15		 jmp	 SHORT $LN32@DoDriverUn
$LN68@DoDriverUn:

; 1104 : 		{
; 1105 : 			handleError (NULL, status);

  00081	50		 push	 eax
  00082	6a 00		 push	 0
  00084	e8 00 00 00 00	 call	 _handleError

; 1106 : 			AbortProcess ("NODRIVER");

  00089	68 00 00 00 00	 push	 OFFSET ??_C@_08ELEAABKI@NODRIVER?$AA@
  0008e	e8 00 00 00 00	 call	 _AbortProcess
  00093	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN32@DoDriverUn:

; 1107 : 		}
; 1108 : 	}
; 1109 : 
; 1110 : 	if (hDriver != INVALID_HANDLE_VALUE)

  00096	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _hDriver, -1
  0009d	0f 84 8a 03 00
	00		 je	 $LN31@DoDriverUn

; 1111 : 	{
; 1112 : 		MOUNT_LIST_STRUCT driver;
; 1113 : 		LONG driverVersion = VERSION_NUM;
; 1114 : 		int refCount;
; 1115 : 		DWORD dwResult;
; 1116 : 		BOOL bResult;
; 1117 : 
; 1118 : 		// Try to determine if it's upgrade (and not reinstall, downgrade, or first-time install).
; 1119 : 		DetermineUpgradeDowngradeStatus (FALSE, &driverVersion);

  000a3	8d 45 e8	 lea	 eax, DWORD PTR _driverVersion$134564[ebp]
  000a6	50		 push	 eax
  000a7	6a 00		 push	 0
  000a9	c7 45 e8 30 07
	00 00		 mov	 DWORD PTR _driverVersion$134564[ebp], 1840 ; 00000730H
  000b0	e8 00 00 00 00	 call	 _DetermineUpgradeDowngradeStatus
  000b5	83 c4 08	 add	 esp, 8

; 1120 : 
; 1121 : 		// Test for encrypted boot drive
; 1122 : 		try
; 1123 : 		{
; 1124 : 			BootEncryption bootEnc (hwndDlg);

  000b8	56		 push	 esi
  000b9	8d 4d 00	 lea	 ecx, DWORD PTR _bootEnc$134569[ebp]
  000bc	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000c3	e8 00 00 00 00	 call	 ??0BootEncryption@CipherShed@@QAE@PAUHWND__@@@Z ; CipherShed::BootEncryption::BootEncryption

; 1125 : 
; 1126 : 			/* The driver starts at boot time in case of full system encryption. */
; 1127 : 			if (bootEnc.GetDriverServiceStartType() == SERVICE_BOOT_START)

  000c8	8d 4d 00	 lea	 ecx, DWORD PTR _bootEnc$134569[ebp]
  000cb	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl
  000ce	e8 00 00 00 00	 call	 ?GetDriverServiceStartType@BootEncryption@CipherShed@@QAEKXZ ; CipherShed::BootEncryption::GetDriverServiceStartType
  000d3	85 c0		 test	 eax, eax
  000d5	0f 85 08 01 00
	00		 jne	 $LN19@DoDriverUn

; 1128 : 			{
; 1129 : 				try
; 1130 : 				{

  000db	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 1131 : 					// Check hidden OS update consistency
; 1132 : 					if (IsHiddenOSRunning() &&
; 1133 : 						bootEnc.GetInstalledBootLoaderVersion() != VERSION_NUM &&
; 1134 : 						AskWarnNoYes ("UPDATE_TC_IN_DECOY_OS_FIRST") == IDNO)

  000df	e8 00 00 00 00	 call	 _IsHiddenOSRunning
  000e4	85 c0		 test	 eax, eax
  000e6	74 2c		 je	 SHORT $LN27@DoDriverUn
  000e8	8d 4d 00	 lea	 ecx, DWORD PTR _bootEnc$134569[ebp]
  000eb	e8 00 00 00 00	 call	 ?GetInstalledBootLoaderVersion@BootEncryption@CipherShed@@QAEGXZ ; CipherShed::BootEncryption::GetInstalledBootLoaderVersion
  000f0	0f b7 c0	 movzx	 eax, ax
  000f3	b9 30 07 00 00	 mov	 ecx, 1840		; 00000730H
  000f8	66 3b c1	 cmp	 ax, cx
  000fb	74 17		 je	 SHORT $LN27@DoDriverUn
  000fd	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PPLHKJJC@UPDATE_TC_IN_DECOY_OS_FIRST?$AA@
  00102	e8 00 00 00 00	 call	 _AskWarnNoYes
  00107	83 c4 04	 add	 esp, 4
  0010a	83 f8 07	 cmp	 eax, 7
  0010d	75 05		 jne	 SHORT $LN27@DoDriverUn

; 1135 : 					{
; 1136 : 						AbortProcessSilent ();

  0010f	e8 00 00 00 00	 call	 _AbortProcessSilent
$LN27@DoDriverUn:
  00114	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx
$LN50@DoDriverUn:

; 1140 : 
; 1141 : 				/* Uninstall filter drivers and set driver start to "system start". */
; 1142 : 				if (bUninstallInProgress && driverVersion >= 0x500 && !bootEnc.GetStatus().DriveMounted)

  00117	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bUninstallInProgress@@3HA, 0 ; bUninstallInProgress
  0011e	0f 84 d9 00 00
	00		 je	 $LN67@DoDriverUn
  00124	81 7d e8 00 05
	00 00		 cmp	 DWORD PTR _driverVersion$134564[ebp], 1280 ; 00000500H
  0012b	0f 8c c3 00 00
	00		 jl	 $LN26@DoDriverUn
  00131	8d 95 7e ff ff
	ff		 lea	 edx, DWORD PTR $T138351[ebp]
  00137	52		 push	 edx
  00138	8d 4d 00	 lea	 ecx, DWORD PTR _bootEnc$134569[ebp]
  0013b	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@CipherShed@@QAE?AUBootEncryptionStatus@@XZ ; CipherShed::BootEncryption::GetStatus
  00140	83 78 06 00	 cmp	 DWORD PTR [eax+6], 0
  00144	0f 85 aa 00 00
	00		 jne	 $LN26@DoDriverUn

; 1143 : 				{
; 1144 : 					try { bootEnc.RegisterFilterDriver (false, BootEncryption::DriveFilter); } catch (...) { }

  0014a	6a 00		 push	 0
  0014c	6a 00		 push	 0
  0014e	8d 4d 00	 lea	 ecx, DWORD PTR _bootEnc$134569[ebp]
  00151	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
  00155	e8 00 00 00 00	 call	 ?RegisterFilterDriver@BootEncryption@CipherShed@@QAEX_NW4FilterType@12@@Z ; CipherShed::BootEncryption::RegisterFilterDriver
  0015a	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx
  0015d	eb 2a		 jmp	 SHORT $LN53@DoDriverUn
__catch$_DoDriverUnload$0:

; 1137 : 					}
; 1138 : 				}
; 1139 : 				catch (...) { }

  0015f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  00166	b8 00 00 00 00	 mov	 eax, $LN51@DoDriverUn
  0016b	c3		 ret	 0
$LN51@DoDriverUn:
  0016c	bb 01 00 00 00	 mov	 ebx, 1
  00171	8b fb		 mov	 edi, ebx
  00173	eb a2		 jmp	 SHORT $LN50@DoDriverUn
__catch$_DoDriverUnload$2:

; 1143 : 				{
; 1144 : 					try { bootEnc.RegisterFilterDriver (false, BootEncryption::DriveFilter); } catch (...) { }

  00175	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  0017c	b8 00 00 00 00	 mov	 eax, $LN72@DoDriverUn
  00181	c3		 ret	 0
$LN72@DoDriverUn:
  00182	bb 01 00 00 00	 mov	 ebx, 1
  00187	8b fb		 mov	 edi, ebx
$LN53@DoDriverUn:

; 1145 : 					try { bootEnc.RegisterFilterDriver (false, BootEncryption::VolumeFilter); } catch (...) { }

  00189	53		 push	 ebx
  0018a	6a 00		 push	 0
  0018c	8d 4d 00	 lea	 ecx, DWORD PTR _bootEnc$134569[ebp]
  0018f	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
  00193	e8 00 00 00 00	 call	 ?RegisterFilterDriver@BootEncryption@CipherShed@@QAEX_NW4FilterType@12@@Z ; CipherShed::BootEncryption::RegisterFilterDriver
  00198	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx
  0019b	eb 14		 jmp	 SHORT $LN55@DoDriverUn
__catch$_DoDriverUnload$4:
  0019d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  001a4	b8 00 00 00 00	 mov	 eax, $LN73@DoDriverUn
  001a9	c3		 ret	 0
$LN73@DoDriverUn:
  001aa	bb 01 00 00 00	 mov	 ebx, 1
  001af	8b fb		 mov	 edi, ebx
$LN55@DoDriverUn:

; 1146 : 					try { bootEnc.RegisterFilterDriver (false, BootEncryption::DumpFilter); } catch (...) { }

  001b1	6a 02		 push	 2
  001b3	6a 00		 push	 0
  001b5	8d 4d 00	 lea	 ecx, DWORD PTR _bootEnc$134569[ebp]
  001b8	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+12], 8
  001bc	e8 00 00 00 00	 call	 ?RegisterFilterDriver@BootEncryption@CipherShed@@QAEX_NW4FilterType@12@@Z ; CipherShed::BootEncryption::RegisterFilterDriver
  001c1	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx
  001c4	eb 14		 jmp	 SHORT $LN57@DoDriverUn
__catch$_DoDriverUnload$6:
  001c6	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  001cd	b8 00 00 00 00	 mov	 eax, $LN74@DoDriverUn
  001d2	c3		 ret	 0
$LN74@DoDriverUn:
  001d3	bb 01 00 00 00	 mov	 ebx, 1
  001d8	8b fb		 mov	 edi, ebx
$LN57@DoDriverUn:

; 1147 : 					bootEnc.SetDriverServiceStartType (SERVICE_SYSTEM_START);

  001da	53		 push	 ebx
  001db	8d 4d 00	 lea	 ecx, DWORD PTR _bootEnc$134569[ebp]
  001de	e8 00 00 00 00	 call	 ?SetDriverServiceStartType@BootEncryption@CipherShed@@QAEXK@Z ; CipherShed::BootEncryption::SetDriverServiceStartType
$LN19@DoDriverUn:

; 1159 : 
; 1160 : 					SystemEncryptionUpdate = TRUE;
; 1161 : 					PortableMode = FALSE;
; 1162 : 				}
; 1163 : 			}
; 1164 : 		}

  001e3	8d 4d 00	 lea	 ecx, DWORD PTR _bootEnc$134569[ebp]
  001e6	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  001ea	e8 00 00 00 00	 call	 ??1BootEncryption@CipherShed@@QAE@XZ ; CipherShed::BootEncryption::~BootEncryption
  001ef	e9 95 00 00 00	 jmp	 $LN59@DoDriverUn
$LN26@DoDriverUn:

; 1148 : 				}
; 1149 : 				/* Abort if the boot drive is encrypted. */
; 1150 : 				else if (bUninstallInProgress || bDowngrade)

  001f4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bUninstallInProgress@@3HA, 0 ; bUninstallInProgress
  001fb	75 4e		 jne	 SHORT $LN20@DoDriverUn
$LN67@DoDriverUn:
  001fd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDowngrade@@3HA, 0 ; bDowngrade
  00204	75 4e		 jne	 SHORT $LN66@DoDriverUn

; 1154 : 				}
; 1155 : 				else
; 1156 : 				{
; 1157 : 					if (CurrentOSMajor == 6 && CurrentOSMinor == 0 && CurrentOSServicePack < 1)

  00206	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _CurrentOSMajor, 6
  0020d	75 1e		 jne	 SHORT $LN18@DoDriverUn
  0020f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _CurrentOSMinor, 0
  00216	75 15		 jne	 SHORT $LN18@DoDriverUn
  00218	39 1d 00 00 00
	00		 cmp	 DWORD PTR _CurrentOSServicePack, ebx
  0021e	7d 0d		 jge	 SHORT $LN18@DoDriverUn

; 1158 : 						AbortProcess ("SYS_ENCRYPTION_UPGRADE_UNSUPPORTED_ON_VISTA_SP0");

  00220	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@EDIMDHJI@SYS_ENCRYPTION_UPGRADE_UNSUPPORT@
  00225	e8 00 00 00 00	 call	 _AbortProcess
  0022a	83 c4 04	 add	 esp, 4
$LN18@DoDriverUn:

; 1159 : 
; 1160 : 					SystemEncryptionUpdate = TRUE;
; 1161 : 					PortableMode = FALSE;
; 1162 : 				}
; 1163 : 			}
; 1164 : 		}

  0022d	8d 4d 00	 lea	 ecx, DWORD PTR _bootEnc$134569[ebp]
  00230	89 1d 00 00 00
	00		 mov	 DWORD PTR _SystemEncryptionUpdate, ebx
  00236	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?PortableMode@@3HA, 0 ; PortableMode
  00240	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  00244	e8 00 00 00 00	 call	 ??1BootEncryption@CipherShed@@QAE@XZ ; CipherShed::BootEncryption::~BootEncryption
  00249	eb 3e		 jmp	 SHORT $LN59@DoDriverUn
$LN20@DoDriverUn:

; 1151 : 				{
; 1152 : 					Error (bDowngrade ? "SETUP_FAILED_BOOT_DRIVE_ENCRYPTED_DOWNGRADE" : "SETUP_FAILED_BOOT_DRIVE_ENCRYPTED");

  0024b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDowngrade@@3HA, 0 ; bDowngrade
  00252	74 07		 je	 SHORT $LN37@DoDriverUn
$LN66@DoDriverUn:
  00254	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CM@LPOONFIE@SETUP_FAILED_BOOT_DRIVE_ENCRYPTE@
  00259	eb 05		 jmp	 SHORT $LN38@DoDriverUn
$LN37@DoDriverUn:
  0025b	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CC@MKLHADEI@SETUP_FAILED_BOOT_DRIVE_ENCRYPTE@
$LN38@DoDriverUn:
  00260	50		 push	 eax
  00261	e8 00 00 00 00	 call	 _Error
  00266	83 c4 04	 add	 esp, 4

; 1153 : 					return FALSE;

  00269	8d 4d 00	 lea	 ecx, DWORD PTR _bootEnc$134569[ebp]
  0026c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  00270	e8 00 00 00 00	 call	 ??1BootEncryption@CipherShed@@QAE@XZ ; CipherShed::BootEncryption::~BootEncryption
  00275	33 c0		 xor	 eax, eax
  00277	e9 b9 01 00 00	 jmp	 $LN35@DoDriverUn
__catch$_DoDriverUnload$8:

; 1165 : 		catch (...)	{ }

  0027c	b8 00 00 00 00	 mov	 eax, $LN77@DoDriverUn
  00281	c3		 ret	 0
$LN77@DoDriverUn:
  00282	bb 01 00 00 00	 mov	 ebx, 1
  00287	8b fb		 mov	 edi, ebx
$LN59@DoDriverUn:

; 1166 : 
; 1167 : 		/* Do not unload the driver in case of upgrade or system encryption update. */
; 1168 : 		if (!bUninstall
; 1169 : 			&& (bUpgrade || SystemEncryptionUpdate)
; 1170 : 			&& (!bDevm || SystemEncryptionUpdate))

  00289	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bUninstall@@3HA, 0 ; bUninstall
  00290	75 2e		 jne	 SHORT $LN17@DoDriverUn
  00292	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bUpgrade, 0
  00299	75 09		 jne	 SHORT $LN16@DoDriverUn
  0029b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SystemEncryptionUpdate, 0
  002a2	74 1c		 je	 SHORT $LN17@DoDriverUn
$LN16@DoDriverUn:
  002a4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bDevm, 0
  002ab	74 09		 je	 SHORT $LN15@DoDriverUn
  002ad	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SystemEncryptionUpdate, 0
  002b4	74 0a		 je	 SHORT $LN17@DoDriverUn
$LN15@DoDriverUn:

; 1171 : 		{
; 1172 : 			UnloadDriver = FALSE;

  002b6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?UnloadDriver@@3HA, 0 ; UnloadDriver
$LN17@DoDriverUn:

; 1173 : 		}
; 1174 : 
; 1175 : 		if (PortableMode && !SystemEncryptionUpdate)

  002c0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PortableMode@@3HA, 0 ; PortableMode
  002c7	74 11		 je	 SHORT $LN14@DoDriverUn
  002c9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SystemEncryptionUpdate, 0
  002d0	75 08		 jne	 SHORT $LN14@DoDriverUn

; 1176 : 			UnloadDriver = TRUE;

  002d2	89 1d 00 00 00
	00		 mov	 DWORD PTR ?UnloadDriver@@3HA, ebx ; UnloadDriver

; 1177 : 
; 1178 : 		/* Check mounted volumes. */
; 1179 : 		if (UnloadDriver)

  002d8	eb 0d		 jmp	 SHORT $LN69@DoDriverUn
$LN14@DoDriverUn:
  002da	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?UnloadDriver@@3HA, 0 ; UnloadDriver
  002e1	0f 84 9a 00 00
	00		 je	 $LN82@DoDriverUn
$LN69@DoDriverUn:

; 1180 : 		{
; 1181 : 			int volumesMounted = 0;
; 1182 : 
; 1183 : 			bResult = DeviceIoControl (hDriver, TC_IOCTL_IS_ANY_VOLUME_MOUNTED, NULL, 0, &volumesMounted, sizeof (volumesMounted), &dwResult, NULL);

  002e7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hDriver
  002ed	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__DeviceIoControl@32
  002f3	6a 00		 push	 0
  002f5	8d 45 e0	 lea	 eax, DWORD PTR _dwResult$134566[ebp]
  002f8	50		 push	 eax
  002f9	6a 04		 push	 4
  002fb	8d 4d ec	 lea	 ecx, DWORD PTR _volumesMounted$134593[ebp]
  002fe	51		 push	 ecx
  002ff	6a 00		 push	 0
  00301	6a 00		 push	 0
  00303	68 28 20 22 00	 push	 2236456			; 00222028H
  00308	52		 push	 edx
  00309	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _volumesMounted$134593[ebp], 0
  00310	ff d6		 call	 esi

; 1184 : 
; 1185 : 			if (!bResult)

  00312	85 c0		 test	 eax, eax
  00314	75 30		 jne	 SHORT $LN65@DoDriverUn

; 1186 : 			{
; 1187 : 				bResult = DeviceIoControl (hDriver, TC_IOCTL_LEGACY_GET_MOUNTED_VOLUMES, NULL, 0, &driver, sizeof (driver), &dwResult, NULL);

  00316	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hDriver
  0031c	50		 push	 eax
  0031d	8d 45 e0	 lea	 eax, DWORD PTR _dwResult$134566[ebp]
  00320	50		 push	 eax
  00321	68 74 36 00 00	 push	 13940			; 00003674H
  00326	8d 8d 08 c9 ff
	ff		 lea	 ecx, DWORD PTR _driver$134563[ebp]
  0032c	51		 push	 ecx
  0032d	6a 00		 push	 0
  0032f	6a 00		 push	 0
  00331	68 04 20 07 00	 push	 466948			; 00072004H
  00336	52		 push	 edx
  00337	ff d6		 call	 esi

; 1188 : 				if (bResult)

  00339	85 c0		 test	 eax, eax
  0033b	74 34		 je	 SHORT $LN10@DoDriverUn

; 1189 : 					volumesMounted = driver.ulMountedDrives;

  0033d	8b 85 08 c9 ff
	ff		 mov	 eax, DWORD PTR _driver$134563[ebp]
  00343	89 45 ec	 mov	 DWORD PTR _volumesMounted$134593[ebp], eax
$LN65@DoDriverUn:

; 1190 : 			}
; 1191 : 
; 1192 : 			if (bResult)
; 1193 : 			{
; 1194 : 				if (volumesMounted != 0)

  00346	83 7d ec 00	 cmp	 DWORD PTR _volumesMounted$134593[ebp], 0
  0034a	74 3b		 je	 SHORT $LN70@DoDriverUn

; 1195 : 				{
; 1196 : 					/* Abort. */
; 1197 : 					bOK = FALSE;
; 1198 : 					MessageBoxW (hwndDlg, GetString ("DISMOUNT_ALL_FIRST"), lpszTitle, MB_ICONHAND);

  0034c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpszTitle
  00352	6a 10		 push	 16			; 00000010H
  00354	51		 push	 ecx
  00355	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OMJBKKEL@DISMOUNT_ALL_FIRST?$AA@
  0035a	33 ff		 xor	 edi, edi
  0035c	e8 00 00 00 00	 call	 _GetString
  00361	8b 55 e4	 mov	 edx, DWORD PTR _hwndDlg$GSCopy$[ebp]
  00364	83 c4 04	 add	 esp, 4
  00367	50		 push	 eax
  00368	52		 push	 edx
  00369	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 1199 : 				}
; 1200 : 			}
; 1201 : 			else

  0036f	eb 3d		 jmp	 SHORT $LN6@DoDriverUn
$LN10@DoDriverUn:

; 1202 : 			{
; 1203 : 				/* Abort. */
; 1204 : 				bOK = FALSE;
; 1205 : 				handleWin32Error (hwndDlg);

  00371	8b 45 e4	 mov	 eax, DWORD PTR _hwndDlg$GSCopy$[ebp]
  00374	50		 push	 eax
  00375	33 ff		 xor	 edi, edi
  00377	e8 00 00 00 00	 call	 _handleWin32Error
  0037c	83 c4 04	 add	 esp, 4

; 1206 : 			}
; 1207 : 		}
; 1208 : 
; 1209 : 		// Try to close all open TC windows
; 1210 : 		if (bOK)

  0037f	eb 2d		 jmp	 SHORT $LN6@DoDriverUn
$LN82@DoDriverUn:
  00381	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__DeviceIoControl@32
$LN70@DoDriverUn:

; 1211 : 		{
; 1212 : 			BOOL TCWindowClosed = FALSE;
; 1213 : 
; 1214 : 			EnumWindows (CloseTCWindowsEnum, (LPARAM) &TCWindowClosed);

  00387	8d 4d e8	 lea	 ecx, DWORD PTR _TCWindowClosed$134601[ebp]
  0038a	51		 push	 ecx
  0038b	68 00 00 00 00	 push	 OFFSET _CloseTCWindowsEnum@8
  00390	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _TCWindowClosed$134601[ebp], 0
  00397	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnumWindows@8

; 1215 : 
; 1216 : 			if (TCWindowClosed) 

  0039d	83 7d e8 00	 cmp	 DWORD PTR _TCWindowClosed$134601[ebp], 0
  003a1	74 0b		 je	 SHORT $LN6@DoDriverUn

; 1217 : 				Sleep (2000);

  003a3	68 d0 07 00 00	 push	 2000			; 000007d0H
  003a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
$LN6@DoDriverUn:

; 1218 : 		}
; 1219 : 
; 1220 : 		// Test for any applications attached to driver
; 1221 : 		if (!bUpgrade)

  003ae	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bUpgrade, 0
  003b5	75 50		 jne	 SHORT $LN4@DoDriverUn

; 1222 : 		{
; 1223 : 			bResult = DeviceIoControl (hDriver, TC_IOCTL_GET_DEVICE_REFCOUNT, &refCount, sizeof (refCount), &refCount,
; 1224 : 				sizeof (refCount), &dwResult, NULL);

  003b7	6a 00		 push	 0
  003b9	8d 55 e0	 lea	 edx, DWORD PTR _dwResult$134566[ebp]
  003bc	52		 push	 edx
  003bd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hDriver
  003c3	6a 04		 push	 4
  003c5	8d 45 dc	 lea	 eax, DWORD PTR _refCount$134565[ebp]
  003c8	50		 push	 eax
  003c9	6a 04		 push	 4
  003cb	8b c8		 mov	 ecx, eax
  003cd	51		 push	 ecx
  003ce	68 20 20 22 00	 push	 2236448			; 00222020H
  003d3	52		 push	 edx
  003d4	ff d6		 call	 esi

; 1225 : 
; 1226 : 			if (bOK && bResult && refCount > 1)

  003d6	85 ff		 test	 edi, edi
  003d8	74 3a		 je	 SHORT $LN2@DoDriverUn
  003da	85 c0		 test	 eax, eax
  003dc	74 29		 je	 SHORT $LN4@DoDriverUn
  003de	39 5d dc	 cmp	 DWORD PTR _refCount$134565[ebp], ebx
  003e1	7e 24		 jle	 SHORT $LN4@DoDriverUn

; 1227 : 			{
; 1228 : 				/* Abort. */
; 1229 : 				MessageBoxW (hwndDlg, GetString ("CLOSE_TC_FIRST"), lpszTitle, MB_ICONSTOP);

  003e3	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  003e8	6a 10		 push	 16			; 00000010H
  003ea	50		 push	 eax
  003eb	68 00 00 00 00	 push	 OFFSET ??_C@_0P@KGAEHPDJ@CLOSE_TC_FIRST?$AA@
  003f0	e8 00 00 00 00	 call	 _GetString
  003f5	8b 4d e4	 mov	 ecx, DWORD PTR _hwndDlg$GSCopy$[ebp]
  003f8	83 c4 04	 add	 esp, 4
  003fb	50		 push	 eax
  003fc	51		 push	 ecx
  003fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 1230 : 				bOK = FALSE;

  00403	33 ff		 xor	 edi, edi

; 1231 : 			}
; 1232 : 		}
; 1233 : 
; 1234 : 		/* Close the driver device handle. */
; 1235 : 		if (!bOK || UnloadDriver)

  00405	eb 0d		 jmp	 SHORT $LN2@DoDriverUn
$LN4@DoDriverUn:
  00407	85 ff		 test	 edi, edi
  00409	74 09		 je	 SHORT $LN2@DoDriverUn
  0040b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?UnloadDriver@@3HA, 0 ; UnloadDriver
  00412	74 1f		 je	 SHORT $LN1@DoDriverUn
$LN2@DoDriverUn:

; 1236 : 		{
; 1237 : 			CloseHandle (hDriver);

  00414	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hDriver
  0041a	52		 push	 edx
  0041b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 1238 : 			hDriver = INVALID_HANDLE_VALUE;

  00421	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _hDriver, -1

; 1239 : 		}
; 1240 : 	}
; 1241 : 	else

  0042b	eb 06		 jmp	 SHORT $LN1@DoDriverUn
$LN31@DoDriverUn:

; 1242 : 	{
; 1243 : 		// Note that the driver may have already been unloaded during this session (e.g. retry after an error, etc.) so it is not 
; 1244 : 		// guaranteed that the user is installing CipherShed for the first time now (we also cannot know if the user has already
; 1245 : 		// installed and used CipherShed on another system before).
; 1246 : 		bPossiblyFirstTimeInstall = TRUE;

  0042d	89 1d 00 00 00
	00		 mov	 DWORD PTR _bPossiblyFirstTimeInstall, ebx
$LN1@DoDriverUn:

; 1247 : 	}
; 1248 : 
; 1249 : 	return bOK;

  00433	8b c7		 mov	 eax, edi
$LN35@DoDriverUn:

; 1250 : }

  00435	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00438	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0043f	59		 pop	 ecx
  00440	5f		 pop	 edi
  00441	5e		 pop	 esi
  00442	5b		 pop	 ebx
  00443	8b 8d 18 06 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00449	33 cd		 xor	 ecx, ebp
  0044b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00450	81 c5 1c 06 00
	00		 add	 ebp, 1564		; 0000061cH
  00456	8b e5		 mov	 esp, ebp
  00458	5d		 pop	 ebp
  00459	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_DoDriverUnload$10:
  00000	8d 4d 00	 lea	 ecx, DWORD PTR _bootEnc$134569[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1BootEncryption@CipherShed@@QAE@XZ ; CipherShed::BootEncryption::~BootEncryption
__ehhandler$_DoDriverUnload:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 04 c9 ff
	ff		 mov	 ecx, DWORD PTR [edx-14076]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	8b 8a 24 06 00
	00		 mov	 ecx, DWORD PTR [edx+1572]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_DoDriverUnload
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_DoDriverUnload ENDP
PUBLIC	??_C@_0BL@LKLMNDDM@BOOT_LOADER_UPGRADE_FAILED?$AA@ ; `string'
PUBLIC	??_C@_0BH@FCKJHOEL@BOOT_LOADER_UPGRADE_OK?$AA@	; `string'
PUBLIC	??_C@_0CB@JHJCAANH@BOOT_LOADER_UPGRADE_OK_HIDDEN_OS@ ; `string'
PUBLIC	??_C@_0BP@LJKCMEDG@INSTALLER_UPDATING_BOOT_LOADER?$AA@ ; `string'
PUBLIC	_hwndDlg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_UpgradeBootLoader
PUBLIC	??_R0?AUException@CipherShed@@@8		; CipherShed::Exception `RTTI Type Descriptor'
EXTRN	_Info:PROC
EXTRN	?InstallBootLoader@BootEncryption@CipherShed@@QAEX_N0@Z:PROC ; CipherShed::BootEncryption::InstallBootLoader
;	COMDAT ??_R0?AUException@CipherShed@@@8
_DATA	SEGMENT
??_R0?AUException@CipherShed@@@8 DD FLAT:??_7type_info@@6B@ ; CipherShed::Exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUException@CipherShed@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_0BL@LKLMNDDM@BOOT_LOADER_UPGRADE_FAILED?$AA@
CONST	SEGMENT
??_C@_0BL@LKLMNDDM@BOOT_LOADER_UPGRADE_FAILED?$AA@ DB 'BOOT_LOADER_UPGRAD'
	DB	'E_FAILED', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FCKJHOEL@BOOT_LOADER_UPGRADE_OK?$AA@
CONST	SEGMENT
??_C@_0BH@FCKJHOEL@BOOT_LOADER_UPGRADE_OK?$AA@ DB 'BOOT_LOADER_UPGRADE_OK'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@JHJCAANH@BOOT_LOADER_UPGRADE_OK_HIDDEN_OS@
CONST	SEGMENT
??_C@_0CB@JHJCAANH@BOOT_LOADER_UPGRADE_OK_HIDDEN_OS@ DB 'BOOT_LOADER_UPGR'
	DB	'ADE_OK_HIDDEN_OS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LJKCMEDG@INSTALLER_UPDATING_BOOT_LOADER?$AA@
CONST	SEGMENT
??_C@_0BP@LJKCMEDG@INSTALLER_UPDATING_BOOT_LOADER?$AA@ DB 'INSTALLER_UPDA'
	DB	'TING_BOOT_LOADER', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$_UpgradeBootLoader DD 00H
	DD	01H
	DD	02H
	DD	02H
	DD	FLAT:__catchsym$_UpgradeBootLoader$4
__unwindtable$_UpgradeBootLoader DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$_UpgradeBootLoader$3
	DD	0ffffffffH
	DD	00H
__catchsym$_UpgradeBootLoader$4 DD 08H
	DD	FLAT:??_R0?AUException@CipherShed@@@8
	DD	0fffff9ccH
	DD	FLAT:__catch$_UpgradeBootLoader$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_UpgradeBootLoader$1
__ehfuncinfo$_UpgradeBootLoader DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$_UpgradeBootLoader
	DD	01H
	DD	FLAT:__tryblocktable$_UpgradeBootLoader
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT _UpgradeBootLoader
_TEXT	SEGMENT
_e$134624 = -1588					; size = 4
_hwndDlg$GSCopy$ = -1584				; size = 4
_bootEnc$134617 = -1580					; size = 1560
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_hwndDlg$ = 8						; size = 4
_UpgradeBootLoader PROC					; COMDAT

; 1258 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_UpgradeBootLoader
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 28 06 00
	00		 sub	 esp, 1576		; 00000628H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8b 75 08	 mov	 esi, DWORD PTR _hwndDlg$[ebp]

; 1259 : 	/*
; 1260 : 	 * The bootloader is only installed in case of full system encryption,
; 1261 : 	 * otherwise no upgrade is needed and we return here.
; 1262 : 	 */
; 1263 : 	if (!SystemEncryptionUpdate)

  00034	33 db		 xor	 ebx, ebx
  00036	89 b5 d0 f9 ff
	ff		 mov	 DWORD PTR _hwndDlg$GSCopy$[ebp], esi
  0003c	39 1d 00 00 00
	00		 cmp	 DWORD PTR _SystemEncryptionUpdate, ebx

; 1264 : 		return TRUE;

  00042	0f 84 89 00 00
	00		 je	 $LN21@UpgradeBoo

; 1265 : 
; 1266 : 	try
; 1267 : 	{
; 1268 : 		BootEncryption bootEnc (hwndDlg);

  00048	56		 push	 esi
  00049	8d 8d d4 f9 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$134617[ebp]
  0004f	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx
  00052	e8 00 00 00 00	 call	 ??0BootEncryption@CipherShed@@QAE@PAUHWND__@@@Z ; CipherShed::BootEncryption::BootEncryption

; 1269 : 
; 1270 : 		if (bootEnc.GetInstalledBootLoaderVersion() < VERSION_NUM)

  00057	8d 8d d4 f9 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$134617[ebp]
  0005d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00061	e8 00 00 00 00	 call	 ?GetInstalledBootLoaderVersion@BootEncryption@CipherShed@@QAEGXZ ; CipherShed::BootEncryption::GetInstalledBootLoaderVersion
  00066	0f b7 c0	 movzx	 eax, ax
  00069	b9 30 07 00 00	 mov	 ecx, 1840		; 00000730H
  0006e	66 3b c1	 cmp	 ax, cx
  00071	73 50		 jae	 SHORT $LN1@UpgradeBoo

; 1271 : 		{
; 1272 : 			StatusMessage (hwndDlg, "INSTALLER_UPDATING_BOOT_LOADER");

  00073	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@LJKCMEDG@INSTALLER_UPDATING_BOOT_LOADER?$AA@
  00078	56		 push	 esi
  00079	e8 00 00 00 00	 call	 _StatusMessage
  0007e	83 c4 08	 add	 esp, 8

; 1273 : 
; 1274 : 			/* Upgrade the installed bootloader to new version. */
; 1275 : 			bootEnc.InstallBootLoader (true);

  00081	53		 push	 ebx
  00082	6a 01		 push	 1
  00084	8d 8d d4 f9 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$134617[ebp]
  0008a	e8 00 00 00 00	 call	 ?InstallBootLoader@BootEncryption@CipherShed@@QAEX_N0@Z ; CipherShed::BootEncryption::InstallBootLoader

; 1276 : 
; 1277 : 			/* Give the user an advice to create a new rescue disk with updated bootloader (<= TrueCrypt 6.0a). */
; 1278 : 			if (bootEnc.GetInstalledBootLoaderVersion() <= TC_RESCUE_DISK_UPGRADE_NOTICE_MAX_VERSION)

  0008f	8d 8d d4 f9 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$134617[ebp]
  00095	e8 00 00 00 00	 call	 ?GetInstalledBootLoaderVersion@BootEncryption@CipherShed@@QAEGXZ ; CipherShed::BootEncryption::GetInstalledBootLoaderVersion
  0009a	0f b7 c0	 movzx	 eax, ax
  0009d	ba 0a 06 00 00	 mov	 edx, 1546		; 0000060aH
  000a2	66 3b c2	 cmp	 ax, dx
  000a5	77 1c		 ja	 SHORT $LN1@UpgradeBoo

; 1279 : 				Info (IsHiddenOSRunning() ? "BOOT_LOADER_UPGRADE_OK_HIDDEN_OS" : "BOOT_LOADER_UPGRADE_OK");

  000a7	e8 00 00 00 00	 call	 _IsHiddenOSRunning
  000ac	85 c0		 test	 eax, eax
  000ae	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CB@JHJCAANH@BOOT_LOADER_UPGRADE_OK_HIDDEN_OS@
  000b3	75 05		 jne	 SHORT $LN8@UpgradeBoo
  000b5	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BH@FCKJHOEL@BOOT_LOADER_UPGRADE_OK?$AA@
$LN8@UpgradeBoo:
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _Info
  000c0	83 c4 04	 add	 esp, 4
$LN1@UpgradeBoo:

; 1280 : 		}
; 1281 : 
; 1282 : 		return TRUE;

  000c3	8d 8d d4 f9 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$134617[ebp]
  000c9	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl
  000cc	e8 00 00 00 00	 call	 ??1BootEncryption@CipherShed@@QAE@XZ ; CipherShed::BootEncryption::~BootEncryption
$LN21@UpgradeBoo:
  000d1	b8 01 00 00 00	 mov	 eax, 1
  000d6	eb 28		 jmp	 SHORT $LN5@UpgradeBoo
__catch$_UpgradeBootLoader$0:

; 1283 : 	}
; 1284 : 	catch (Exception &e)
; 1285 : 	{
; 1286 : 		e.Show (hwndDlg);

  000d8	8b 8d cc f9 ff
	ff		 mov	 ecx, DWORD PTR _e$134624[ebp]
  000de	8b 01		 mov	 eax, DWORD PTR [ecx]
  000e0	8b 95 d0 f9 ff
	ff		 mov	 edx, DWORD PTR _hwndDlg$GSCopy$[ebp]
  000e6	8b 00		 mov	 eax, DWORD PTR [eax]
  000e8	52		 push	 edx
  000e9	ff d0		 call	 eax

; 1287 : 	}

  000eb	b8 00 00 00 00	 mov	 eax, $LN16@UpgradeBoo
  000f0	c3		 ret	 0
$LN16@UpgradeBoo:

; 1289 : 
; 1290 : 	Error ("BOOT_LOADER_UPGRADE_FAILED");

  000f1	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@LKLMNDDM@BOOT_LOADER_UPGRADE_FAILED?$AA@
  000f6	e8 00 00 00 00	 call	 _Error
  000fb	83 c4 04	 add	 esp, 4

; 1291 : 	return FALSE;

  000fe	33 c0		 xor	 eax, eax
$LN5@UpgradeBoo:

; 1292 : }

  00100	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00103	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0010a	59		 pop	 ecx
  0010b	5f		 pop	 edi
  0010c	5e		 pop	 esi
  0010d	5b		 pop	 ebx
  0010e	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00111	33 cd		 xor	 ecx, ebp
  00113	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c3		 ret	 0
__catch$_UpgradeBootLoader$1:

; 1288 : 	catch (...) { }

  0011c	b8 00 00 00 00	 mov	 eax, $LN16@UpgradeBoo
  00121	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_UpgradeBootLoader$3:
  00000	8d 8d d4 f9 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$134617[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1BootEncryption@CipherShed@@QAE@XZ ; CipherShed::BootEncryption::~BootEncryption
__ehhandler$_UpgradeBootLoader:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a c8 f9 ff
	ff		 mov	 ecx, DWORD PTR [edx-1592]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_UpgradeBootLoader
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_UpgradeBootLoader ENDP
PUBLIC	??_C@_0BN@DGJJNBJI@?2CipherShed?5User?8s?5Guide?4lnk?$AA@ ; `string'
PUBLIC	??_C@_0BK@EABHBBNJ@?2Uninstall?5CipherShed?4lnk?$AA@ ; `string'
PUBLIC	??_C@_0BI@GABNFKIJ@?2CipherShed?5Website?4url?$AA@ ; `string'
PUBLIC	??_C@_0BA@LNMKCON@?2CipherShed?4lnk?$AA@	; `string'
PUBLIC	??_C@_0M@HNGGAEIF@?2CipherShed?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_DoShortcutsUninstall
EXTRN	__imp__OleUninitialize@0:PROC
EXTRN	__stat64i32:PROC
EXTRN	__imp__SHGetSpecialFolderPathA@16:PROC
EXTRN	__imp__OleInitialize@4:PROC
;	COMDAT ??_C@_0BN@DGJJNBJI@?2CipherShed?5User?8s?5Guide?4lnk?$AA@
CONST	SEGMENT
??_C@_0BN@DGJJNBJI@?2CipherShed?5User?8s?5Guide?4lnk?$AA@ DB '\CipherShed'
	DB	' User''s Guide.lnk', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EABHBBNJ@?2Uninstall?5CipherShed?4lnk?$AA@
CONST	SEGMENT
??_C@_0BK@EABHBBNJ@?2Uninstall?5CipherShed?4lnk?$AA@ DB '\Uninstall Ciphe'
	DB	'rShed.lnk', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GABNFKIJ@?2CipherShed?5Website?4url?$AA@
CONST	SEGMENT
??_C@_0BI@GABNFKIJ@?2CipherShed?5Website?4url?$AA@ DB '\CipherShed Websit'
	DB	'e.url', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LNMKCON@?2CipherShed?4lnk?$AA@
CONST	SEGMENT
??_C@_0BA@LNMKCON@?2CipherShed?4lnk?$AA@ DB '\CipherShed.lnk', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HNGGAEIF@?2CipherShed?$AA@
CONST	SEGMENT
??_C@_0M@HNGGAEIF@?2CipherShed?$AA@ DB '\CipherShed', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _DoShortcutsUninstall
_TEXT	SEGMENT
_bOK$ = -844						; size = 4
_st$138475 = -840					; size = 56
_st$138464 = -840					; size = 56
_st$138453 = -840					; size = 56
_st$134641 = -840					; size = 48
_szTmp2$ = -784						; size = 260
_szLinkDir$ = -524					; size = 260
_path$134642 = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_szDestDir$ = 12					; size = 4
_DoShortcutsUninstall PROC				; COMDAT

; 1298 : {

  00000	81 ec 4c 03 00
	00		 sub	 esp, 844		; 0000034cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 48 03
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+844], eax
  00014	53		 push	 ebx
  00015	55		 push	 ebp
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	8b bc 24 60 03
	00 00		 mov	 edi, DWORD PTR _hwndDlg$[esp+856]

; 1299 : 	char szLinkDir[TC_MAX_PATH];
; 1300 : 	char szTmp2[TC_MAX_PATH];
; 1301 : 	BOOL bSlash, bOK = FALSE;
; 1302 : 	HRESULT hOle;
; 1303 : 	int x;
; 1304 : 	BOOL allUsers = FALSE;

  0001f	33 ed		 xor	 ebp, ebp

; 1305 : 
; 1306 : 	hOle = OleInitialize (NULL);

  00021	55		 push	 ebp
  00022	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _bOK$[esp+864], 0
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OleInitialize@4

; 1307 : 
; 1308 : 	// User start menu
; 1309 : 	SHGetSpecialFolderPath (hwndDlg, szLinkDir, CSIDL_PROGRAMS, 0);

  00030	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__SHGetSpecialFolderPathA@16
  00036	55		 push	 ebp
  00037	6a 02		 push	 2
  00039	8d 84 24 58 01
	00 00		 lea	 eax, DWORD PTR _szLinkDir$[esp+868]
  00040	50		 push	 eax
  00041	57		 push	 edi
  00042	ff d3		 call	 ebx

; 1310 : 	x = strlen (szLinkDir);

  00044	8d 84 24 50 01
	00 00		 lea	 eax, DWORD PTR _szLinkDir$[esp+860]
  0004b	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0004e	8b ff		 npad	 2
$LL52@DoShortcut:
  00050	8a 08		 mov	 cl, BYTE PTR [eax]
  00052	40		 inc	 eax
  00053	84 c9		 test	 cl, cl
  00055	75 f9		 jne	 SHORT $LL52@DoShortcut
  00057	2b c2		 sub	 eax, edx

; 1311 : 	if (szLinkDir[x - 1] == '\\')

  00059	80 bc 04 4f 01
	00 00 5c	 cmp	 BYTE PTR _szLinkDir$[esp+eax+859], 92 ; 0000005cH
  00061	74 1a		 je	 SHORT $LN53@DoShortcut

; 1312 : 		bSlash = TRUE;
; 1313 : 	else
; 1314 : 		bSlash = FALSE;
; 1315 : 
; 1316 : 	if (bSlash == FALSE)
; 1317 : 		strcat_s (szLinkDir, sizeof(szLinkDir), "\\");

  00063	68 00 00 00 00	 push	 OFFSET ??_C@_01KICIPPFI@?2?$AA@
  00068	8d 8c 24 54 01
	00 00		 lea	 ecx, DWORD PTR _szLinkDir$[esp+864]
  0006f	68 04 01 00 00	 push	 260			; 00000104H
  00074	51		 push	 ecx
  00075	e8 00 00 00 00	 call	 _strcat_s
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN53@DoShortcut:

; 1318 : 
; 1319 : 	strcat_s (szLinkDir, sizeof(szLinkDir), "CipherShed");

  0007d	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FEEFGEIL@CipherShed?$AA@
  00082	8d 94 24 54 01
	00 00		 lea	 edx, DWORD PTR _szLinkDir$[esp+864]
  00089	68 04 01 00 00	 push	 260			; 00000104H
  0008e	52		 push	 edx
  0008f	e8 00 00 00 00	 call	 _strcat_s
  00094	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1320 : 
; 1321 : 	// Global start menu
; 1322 : 	{
; 1323 : 		struct _stat st;
; 1324 : 		char path[TC_MAX_PATH];
; 1325 : 
; 1326 : 		SHGetSpecialFolderPath (hwndDlg, path, CSIDL_COMMON_PROGRAMS, 0);

  00097	6a 00		 push	 0
  00099	6a 17		 push	 23			; 00000017H
  0009b	8d 84 24 5c 02
	00 00		 lea	 eax, DWORD PTR _path$134642[esp+868]
  000a2	50		 push	 eax
  000a3	57		 push	 edi
  000a4	ff d3		 call	 ebx

; 1327 : 		strcat_s (path, sizeof(path), "\\CipherShed");

  000a6	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HNGGAEIF@?2CipherShed?$AA@
  000ab	8d 8c 24 58 02
	00 00		 lea	 ecx, DWORD PTR _path$134642[esp+864]
  000b2	68 04 01 00 00	 push	 260			; 00000104H
  000b7	51		 push	 ecx
  000b8	e8 00 00 00 00	 call	 _strcat_s

; 1328 : 
; 1329 : 		if (_stat (path, &st) == 0)

  000bd	8d 54 24 20	 lea	 edx, DWORD PTR _st$134641[esp+872]
  000c1	52		 push	 edx
  000c2	8d 84 24 64 02
	00 00		 lea	 eax, DWORD PTR _path$134642[esp+876]
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 __stat64i32
  000cf	83 c4 14	 add	 esp, 20			; 00000014H
  000d2	85 c0		 test	 eax, eax
  000d4	75 22		 jne	 SHORT $LN13@DoShortcut
  000d6	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL19@DoShortcut:

; 1330 : 		{
; 1331 : 			strcpy (szLinkDir, path);

  000e0	8a 8c 04 54 02
	00 00		 mov	 cl, BYTE PTR _path$134642[esp+eax+860]
  000e7	88 8c 04 50 01
	00 00		 mov	 BYTE PTR _szLinkDir$[esp+eax+860], cl
  000ee	40		 inc	 eax
  000ef	84 c9		 test	 cl, cl
  000f1	75 ed		 jne	 SHORT $LL19@DoShortcut

; 1332 : 			allUsers = TRUE;

  000f3	bd 01 00 00 00	 mov	 ebp, 1
$LN13@DoShortcut:

; 1333 : 		}
; 1334 : 	}
; 1335 : 
; 1336 : 	// Start menu entries
; 1337 : 	snprintf (szTmp2, sizeof(szTmp2), "%s%s", szLinkDir, "\\CipherShed.lnk");

  000f8	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@LNMKCON@?2CipherShed?4lnk?$AA@
  000fd	8d 8c 24 54 01
	00 00		 lea	 ecx, DWORD PTR _szLinkDir$[esp+864]
  00104	51		 push	 ecx
  00105	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  0010a	8d 54 24 58	 lea	 edx, DWORD PTR _szTmp2$[esp+872]
  0010e	68 04 01 00 00	 push	 260			; 00000104H
  00113	52		 push	 edx
  00114	e8 00 00 00 00	 call	 _sprintf_s
  00119	83 c4 14	 add	 esp, 20			; 00000014H

; 1338 : 	RemoveMessage (hwndDlg, szTmp2);

  0011c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  00123	75 13		 jne	 SHORT $LN20@DoShortcut
  00125	8d 44 24 4c	 lea	 eax, DWORD PTR _szTmp2$[esp+860]
  00129	50		 push	 eax
  0012a	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  0012f	57		 push	 edi
  00130	e8 00 00 00 00	 call	 _StatusMessageParam
  00135	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN20@DoShortcut:

; 1339 : 	if (StatDeleteFile (szTmp2) == FALSE)

  00138	8d 4c 24 14	 lea	 ecx, DWORD PTR _st$138453[esp+860]
  0013c	51		 push	 ecx
  0013d	8d 54 24 50	 lea	 edx, DWORD PTR _szTmp2$[esp+864]
  00141	52		 push	 edx
  00142	e8 00 00 00 00	 call	 __stat64
  00147	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__DeleteFileA@4
  0014d	83 c4 08	 add	 esp, 8
  00150	85 c0		 test	 eax, eax
  00152	75 0f		 jne	 SHORT $LN49@DoShortcut
  00154	8d 44 24 4c	 lea	 eax, DWORD PTR _szTmp2$[esp+860]
  00158	50		 push	 eax
  00159	ff d6		 call	 esi
  0015b	85 c0		 test	 eax, eax
  0015d	0f 84 cd 01 00
	00		 je	 $LN54@DoShortcut
$LN49@DoShortcut:

; 1340 : 		goto error;
; 1341 : 
; 1342 : 	snprintf (szTmp2, sizeof(szTmp2), "%s%s", szLinkDir, "\\CipherShed Website.url");

  00163	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@GABNFKIJ@?2CipherShed?5Website?4url?$AA@
  00168	8d 8c 24 54 01
	00 00		 lea	 ecx, DWORD PTR _szLinkDir$[esp+864]
  0016f	51		 push	 ecx
  00170	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  00175	8d 54 24 58	 lea	 edx, DWORD PTR _szTmp2$[esp+872]
  00179	68 04 01 00 00	 push	 260			; 00000104H
  0017e	52		 push	 edx
  0017f	e8 00 00 00 00	 call	 _sprintf_s
  00184	83 c4 14	 add	 esp, 20			; 00000014H

; 1343 : 	RemoveMessage (hwndDlg, szTmp2);

  00187	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  0018e	75 13		 jne	 SHORT $LN27@DoShortcut
  00190	8d 44 24 4c	 lea	 eax, DWORD PTR _szTmp2$[esp+860]
  00194	50		 push	 eax
  00195	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  0019a	57		 push	 edi
  0019b	e8 00 00 00 00	 call	 _StatusMessageParam
  001a0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN27@DoShortcut:

; 1344 : 	if (StatDeleteFile (szTmp2) == FALSE)

  001a3	8d 4c 24 14	 lea	 ecx, DWORD PTR _st$138464[esp+860]
  001a7	51		 push	 ecx
  001a8	8d 54 24 50	 lea	 edx, DWORD PTR _szTmp2$[esp+864]
  001ac	52		 push	 edx
  001ad	e8 00 00 00 00	 call	 __stat64
  001b2	83 c4 08	 add	 esp, 8
  001b5	85 c0		 test	 eax, eax
  001b7	75 0f		 jne	 SHORT $LN50@DoShortcut
  001b9	8d 44 24 4c	 lea	 eax, DWORD PTR _szTmp2$[esp+860]
  001bd	50		 push	 eax
  001be	ff d6		 call	 esi
  001c0	85 c0		 test	 eax, eax
  001c2	0f 84 68 01 00
	00		 je	 $LN54@DoShortcut
$LN50@DoShortcut:

; 1345 : 		goto error;
; 1346 : 
; 1347 : 	snprintf (szTmp2, sizeof(szTmp2), "%s%s", szLinkDir, "\\Uninstall CipherShed.lnk");

  001c8	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@EABHBBNJ@?2Uninstall?5CipherShed?4lnk?$AA@
  001cd	8d 8c 24 54 01
	00 00		 lea	 ecx, DWORD PTR _szLinkDir$[esp+864]
  001d4	51		 push	 ecx
  001d5	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  001da	8d 54 24 58	 lea	 edx, DWORD PTR _szTmp2$[esp+872]
  001de	68 04 01 00 00	 push	 260			; 00000104H
  001e3	52		 push	 edx
  001e4	e8 00 00 00 00	 call	 _sprintf_s
  001e9	83 c4 14	 add	 esp, 20			; 00000014H

; 1348 : 	RemoveMessage (hwndDlg, szTmp2);

  001ec	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  001f3	75 13		 jne	 SHORT $LN34@DoShortcut
  001f5	8d 44 24 4c	 lea	 eax, DWORD PTR _szTmp2$[esp+860]
  001f9	50		 push	 eax
  001fa	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  001ff	57		 push	 edi
  00200	e8 00 00 00 00	 call	 _StatusMessageParam
  00205	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN34@DoShortcut:

; 1349 : 	if (StatDeleteFile (szTmp2) == FALSE)

  00208	8d 4c 24 14	 lea	 ecx, DWORD PTR _st$138475[esp+860]
  0020c	51		 push	 ecx
  0020d	8d 54 24 50	 lea	 edx, DWORD PTR _szTmp2$[esp+864]
  00211	52		 push	 edx
  00212	e8 00 00 00 00	 call	 __stat64
  00217	83 c4 08	 add	 esp, 8
  0021a	85 c0		 test	 eax, eax
  0021c	75 0f		 jne	 SHORT $LN51@DoShortcut
  0021e	8d 44 24 4c	 lea	 eax, DWORD PTR _szTmp2$[esp+860]
  00222	50		 push	 eax
  00223	ff d6		 call	 esi
  00225	85 c0		 test	 eax, eax
  00227	0f 84 03 01 00
	00		 je	 $LN54@DoShortcut
$LN51@DoShortcut:

; 1350 : 		goto error;
; 1351 : 	
; 1352 : 	snprintf (szTmp2, sizeof(szTmp2), "%s%s", szLinkDir, "\\CipherShed User's Guide.lnk");

  0022d	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@DGJJNBJI@?2CipherShed?5User?8s?5Guide?4lnk?$AA@
  00232	8d 8c 24 54 01
	00 00		 lea	 ecx, DWORD PTR _szLinkDir$[esp+864]
  00239	51		 push	 ecx
  0023a	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  0023f	8d 54 24 58	 lea	 edx, DWORD PTR _szTmp2$[esp+872]
  00243	68 04 01 00 00	 push	 260			; 00000104H
  00248	52		 push	 edx
  00249	e8 00 00 00 00	 call	 _sprintf_s
  0024e	83 c4 14	 add	 esp, 20			; 00000014H

; 1353 : 	DeleteFile (szTmp2);

  00251	8d 44 24 4c	 lea	 eax, DWORD PTR _szTmp2$[esp+860]
  00255	50		 push	 eax
  00256	ff d6		 call	 esi

; 1354 : 
; 1355 : 	// Start menu group
; 1356 : 	RemoveMessage ((HWND) hwndDlg, szLinkDir);

  00258	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  0025f	75 16		 jne	 SHORT $LN41@DoShortcut
  00261	8d 8c 24 50 01
	00 00		 lea	 ecx, DWORD PTR _szLinkDir$[esp+860]
  00268	51		 push	 ecx
  00269	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  0026e	57		 push	 edi
  0026f	e8 00 00 00 00	 call	 _StatusMessageParam
  00274	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN41@DoShortcut:

; 1357 : 	if (StatRemoveDirectory (szLinkDir))

  00277	8d 94 24 50 01
	00 00		 lea	 edx, DWORD PTR _szLinkDir$[esp+860]
  0027e	52		 push	 edx
  0027f	e8 00 00 00 00	 call	 _StatRemoveDirectory
  00284	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SHChangeNotify@16
  0028a	83 c4 04	 add	 esp, 4
  0028d	85 c0		 test	 eax, eax
  0028f	74 12		 je	 SHORT $LN6@DoShortcut

; 1358 : 		SHChangeNotify (SHCNE_RMDIR, SHCNF_PATH, szLinkDir, NULL);

  00291	6a 00		 push	 0
  00293	8d 84 24 54 01
	00 00		 lea	 eax, DWORD PTR _szLinkDir$[esp+864]
  0029a	50		 push	 eax
  0029b	6a 01		 push	 1
  0029d	6a 10		 push	 16			; 00000010H
  0029f	ff d6		 call	 esi

; 1359 : 	else

  002a1	eb 09		 jmp	 SHORT $LN5@DoShortcut
$LN6@DoShortcut:

; 1360 : 		handleWin32Error ((HWND) hwndDlg);

  002a3	57		 push	 edi
  002a4	e8 00 00 00 00	 call	 _handleWin32Error
  002a9	83 c4 04	 add	 esp, 4
$LN5@DoShortcut:

; 1361 : 
; 1362 : 	// Desktop icon
; 1363 : 	if (allUsers)
; 1364 : 		SHGetSpecialFolderPath (hwndDlg, szLinkDir, CSIDL_COMMON_DESKTOPDIRECTORY, 0);

  002ac	6a 00		 push	 0
  002ae	85 ed		 test	 ebp, ebp
  002b0	74 0c		 je	 SHORT $LN4@DoShortcut
  002b2	6a 19		 push	 25			; 00000019H
  002b4	8d 8c 24 58 01
	00 00		 lea	 ecx, DWORD PTR _szLinkDir$[esp+868]
  002bb	51		 push	 ecx

; 1365 : 	else

  002bc	eb 0a		 jmp	 SHORT $LN55@DoShortcut
$LN4@DoShortcut:

; 1366 : 		SHGetSpecialFolderPath (hwndDlg, szLinkDir, CSIDL_DESKTOPDIRECTORY, 0);

  002be	6a 10		 push	 16			; 00000010H
  002c0	8d 94 24 58 01
	00 00		 lea	 edx, DWORD PTR _szLinkDir$[esp+868]
  002c7	52		 push	 edx
$LN55@DoShortcut:
  002c8	57		 push	 edi
  002c9	ff d3		 call	 ebx

; 1367 : 
; 1368 : 	snprintf (szTmp2, sizeof(szTmp2), "%s%s", szLinkDir, "\\CipherShed.lnk");

  002cb	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@LNMKCON@?2CipherShed?4lnk?$AA@
  002d0	8d 84 24 54 01
	00 00		 lea	 eax, DWORD PTR _szLinkDir$[esp+864]
  002d7	50		 push	 eax
  002d8	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  002dd	8d 4c 24 58	 lea	 ecx, DWORD PTR _szTmp2$[esp+872]
  002e1	68 04 01 00 00	 push	 260			; 00000104H
  002e6	51		 push	 ecx
  002e7	e8 00 00 00 00	 call	 _sprintf_s
  002ec	83 c4 14	 add	 esp, 20			; 00000014H

; 1369 : 
; 1370 : 	RemoveMessage (hwndDlg, szTmp2);

  002ef	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  002f6	75 13		 jne	 SHORT $LN44@DoShortcut
  002f8	8d 54 24 4c	 lea	 edx, DWORD PTR _szTmp2$[esp+860]
  002fc	52		 push	 edx
  002fd	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  00302	57		 push	 edi
  00303	e8 00 00 00 00	 call	 _StatusMessageParam
  00308	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN44@DoShortcut:

; 1371 : 	if (StatDeleteFile (szTmp2) == FALSE)

  0030b	8d 44 24 4c	 lea	 eax, DWORD PTR _szTmp2$[esp+860]
  0030f	50		 push	 eax
  00310	e8 00 00 00 00	 call	 _StatDeleteFile
  00315	83 c4 04	 add	 esp, 4
  00318	85 c0		 test	 eax, eax
  0031a	74 14		 je	 SHORT $LN54@DoShortcut

; 1372 : 		goto error;
; 1373 : 
; 1374 : 	SHChangeNotify (SHCNE_DELETE, SHCNF_PATH, szTmp2, NULL);

  0031c	6a 00		 push	 0
  0031e	8d 4c 24 50	 lea	 ecx, DWORD PTR _szTmp2$[esp+864]
  00322	51		 push	 ecx
  00323	6a 01		 push	 1
  00325	6a 04		 push	 4
  00327	ff d6		 call	 esi

; 1375 : 
; 1376 : 	bOK = TRUE;

  00329	be 01 00 00 00	 mov	 esi, 1
  0032e	eb 04		 jmp	 SHORT $error$134647
$LN54@DoShortcut:
  00330	8b 74 24 10	 mov	 esi, DWORD PTR _bOK$[esp+860]
$error$134647:

; 1377 : 
; 1378 : error:
; 1379 : 	OleUninitialize ();

  00334	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OleUninitialize@0

; 1380 : 
; 1381 : 	return bOK;
; 1382 : }

  0033a	8b 8c 24 58 03
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+860]
  00341	5f		 pop	 edi
  00342	8b c6		 mov	 eax, esi
  00344	5e		 pop	 esi
  00345	5d		 pop	 ebp
  00346	5b		 pop	 ebx
  00347	33 cc		 xor	 ecx, esp
  00349	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0034e	81 c4 4c 03 00
	00		 add	 esp, 844		; 0000034cH
  00354	c3		 ret	 0
_DoShortcutsUninstall ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@LNFOIEOO@?2TrueCrypt?5User?8s?5Guide?4lnk?$AA@ ; `string'
PUBLIC	??_C@_0BJ@PKBPEMBD@?2Uninstall?5TrueCrypt?4lnk?$AA@ ; `string'
PUBLIC	??_C@_0BH@CJOJHCCA@?2TrueCrypt?5Website?4url?$AA@ ; `string'
PUBLIC	??_C@_0P@DFHIDPDG@?2TrueCrypt?4lnk?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_DoTrueCryptShortcutsUninstall
;	COMDAT ??_C@_0BM@LNFOIEOO@?2TrueCrypt?5User?8s?5Guide?4lnk?$AA@
CONST	SEGMENT
??_C@_0BM@LNFOIEOO@?2TrueCrypt?5User?8s?5Guide?4lnk?$AA@ DB '\TrueCrypt U'
	DB	'ser''s Guide.lnk', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PKBPEMBD@?2Uninstall?5TrueCrypt?4lnk?$AA@
CONST	SEGMENT
??_C@_0BJ@PKBPEMBD@?2Uninstall?5TrueCrypt?4lnk?$AA@ DB '\Uninstall TrueCr'
	DB	'ypt.lnk', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CJOJHCCA@?2TrueCrypt?5Website?4url?$AA@
CONST	SEGMENT
??_C@_0BH@CJOJHCCA@?2TrueCrypt?5Website?4url?$AA@ DB '\TrueCrypt Website.'
	DB	'url', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DFHIDPDG@?2TrueCrypt?4lnk?$AA@
CONST	SEGMENT
??_C@_0P@DFHIDPDG@?2TrueCrypt?4lnk?$AA@ DB '\TrueCrypt.lnk', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _DoTrueCryptShortcutsUninstall
_TEXT	SEGMENT
_bOK$ = -844						; size = 4
_st$138530 = -840					; size = 56
_st$138519 = -840					; size = 56
_st$138508 = -840					; size = 56
_st$134678 = -840					; size = 48
_szTmp2$ = -784						; size = 260
_szLinkDir$ = -524					; size = 260
_path$134679 = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_szDestDir$ = 12					; size = 4
_DoTrueCryptShortcutsUninstall PROC			; COMDAT

; 1388 : {

  00000	81 ec 4c 03 00
	00		 sub	 esp, 844		; 0000034cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 48 03
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+844], eax
  00014	53		 push	 ebx
  00015	55		 push	 ebp
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	8b bc 24 60 03
	00 00		 mov	 edi, DWORD PTR _hwndDlg$[esp+856]

; 1389 : 	char szLinkDir[TC_MAX_PATH];
; 1390 : 	char szTmp2[TC_MAX_PATH];
; 1391 : 	BOOL bSlash, bOK = FALSE;
; 1392 : 	HRESULT hOle;
; 1393 : 	int x;
; 1394 : 	BOOL allUsers = FALSE;

  0001f	33 ed		 xor	 ebp, ebp

; 1395 : 
; 1396 : 	hOle = OleInitialize (NULL);

  00021	55		 push	 ebp
  00022	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _bOK$[esp+864], 0
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OleInitialize@4

; 1397 : 
; 1398 : 	// User start menu
; 1399 : 	SHGetSpecialFolderPath (hwndDlg, szLinkDir, CSIDL_PROGRAMS, 0);

  00030	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__SHGetSpecialFolderPathA@16
  00036	55		 push	 ebp
  00037	6a 02		 push	 2
  00039	8d 84 24 58 01
	00 00		 lea	 eax, DWORD PTR _szLinkDir$[esp+868]
  00040	50		 push	 eax
  00041	57		 push	 edi
  00042	ff d3		 call	 ebx

; 1400 : 	x = strlen (szLinkDir);

  00044	8d 84 24 50 01
	00 00		 lea	 eax, DWORD PTR _szLinkDir$[esp+860]
  0004b	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0004e	8b ff		 npad	 2
$LL52@DoTrueCryp@2:
  00050	8a 08		 mov	 cl, BYTE PTR [eax]
  00052	40		 inc	 eax
  00053	84 c9		 test	 cl, cl
  00055	75 f9		 jne	 SHORT $LL52@DoTrueCryp@2
  00057	2b c2		 sub	 eax, edx

; 1401 : 	if (szLinkDir[x - 1] == '\\')

  00059	80 bc 04 4f 01
	00 00 5c	 cmp	 BYTE PTR _szLinkDir$[esp+eax+859], 92 ; 0000005cH
  00061	74 1a		 je	 SHORT $LN53@DoTrueCryp@2

; 1402 : 		bSlash = TRUE;
; 1403 : 	else
; 1404 : 		bSlash = FALSE;
; 1405 : 
; 1406 : 	if (bSlash == FALSE)
; 1407 : 		strcat_s (szLinkDir, sizeof(szLinkDir), "\\");

  00063	68 00 00 00 00	 push	 OFFSET ??_C@_01KICIPPFI@?2?$AA@
  00068	8d 8c 24 54 01
	00 00		 lea	 ecx, DWORD PTR _szLinkDir$[esp+864]
  0006f	68 04 01 00 00	 push	 260			; 00000104H
  00074	51		 push	 ecx
  00075	e8 00 00 00 00	 call	 _strcat_s
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN53@DoTrueCryp@2:

; 1408 : 
; 1409 : 	strcat_s (szLinkDir, sizeof(szLinkDir), "TrueCrypt");

  0007d	68 00 00 00 00	 push	 OFFSET ??_C@_09EMKKFGIH@TrueCrypt?$AA@
  00082	8d 94 24 54 01
	00 00		 lea	 edx, DWORD PTR _szLinkDir$[esp+864]
  00089	68 04 01 00 00	 push	 260			; 00000104H
  0008e	52		 push	 edx
  0008f	e8 00 00 00 00	 call	 _strcat_s
  00094	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1410 : 
; 1411 : 	// Global start menu
; 1412 : 	{
; 1413 : 		struct _stat st;
; 1414 : 		char path[TC_MAX_PATH];
; 1415 : 
; 1416 : 		SHGetSpecialFolderPath (hwndDlg, path, CSIDL_COMMON_PROGRAMS, 0);

  00097	6a 00		 push	 0
  00099	6a 17		 push	 23			; 00000017H
  0009b	8d 84 24 5c 02
	00 00		 lea	 eax, DWORD PTR _path$134679[esp+868]
  000a2	50		 push	 eax
  000a3	57		 push	 edi
  000a4	ff d3		 call	 ebx

; 1417 : 		strcat_s (path, sizeof(path), "\\TrueCrypt");

  000a6	68 00 00 00 00	 push	 OFFSET ??_C@_0L@LGADMAPO@?2TrueCrypt?$AA@
  000ab	8d 8c 24 58 02
	00 00		 lea	 ecx, DWORD PTR _path$134679[esp+864]
  000b2	68 04 01 00 00	 push	 260			; 00000104H
  000b7	51		 push	 ecx
  000b8	e8 00 00 00 00	 call	 _strcat_s

; 1418 : 
; 1419 : 		if (_stat (path, &st) == 0)

  000bd	8d 54 24 20	 lea	 edx, DWORD PTR _st$134678[esp+872]
  000c1	52		 push	 edx
  000c2	8d 84 24 64 02
	00 00		 lea	 eax, DWORD PTR _path$134679[esp+876]
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 __stat64i32
  000cf	83 c4 14	 add	 esp, 20			; 00000014H
  000d2	85 c0		 test	 eax, eax
  000d4	75 22		 jne	 SHORT $LN13@DoTrueCryp@2
  000d6	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL19@DoTrueCryp@2:

; 1420 : 		{
; 1421 : 			strcpy (szLinkDir, path);

  000e0	8a 8c 04 54 02
	00 00		 mov	 cl, BYTE PTR _path$134679[esp+eax+860]
  000e7	88 8c 04 50 01
	00 00		 mov	 BYTE PTR _szLinkDir$[esp+eax+860], cl
  000ee	40		 inc	 eax
  000ef	84 c9		 test	 cl, cl
  000f1	75 ed		 jne	 SHORT $LL19@DoTrueCryp@2

; 1422 : 			allUsers = TRUE;

  000f3	bd 01 00 00 00	 mov	 ebp, 1
$LN13@DoTrueCryp@2:

; 1423 : 		}
; 1424 : 	}
; 1425 : 
; 1426 : 	// Start menu entries
; 1427 : 	snprintf (szTmp2, sizeof(szTmp2), "%s%s", szLinkDir, "\\TrueCrypt.lnk");

  000f8	68 00 00 00 00	 push	 OFFSET ??_C@_0P@DFHIDPDG@?2TrueCrypt?4lnk?$AA@
  000fd	8d 8c 24 54 01
	00 00		 lea	 ecx, DWORD PTR _szLinkDir$[esp+864]
  00104	51		 push	 ecx
  00105	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  0010a	8d 54 24 58	 lea	 edx, DWORD PTR _szTmp2$[esp+872]
  0010e	68 04 01 00 00	 push	 260			; 00000104H
  00113	52		 push	 edx
  00114	e8 00 00 00 00	 call	 _sprintf_s
  00119	83 c4 14	 add	 esp, 20			; 00000014H

; 1428 : 	RemoveMessage (hwndDlg, szTmp2);

  0011c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  00123	75 13		 jne	 SHORT $LN20@DoTrueCryp@2
  00125	8d 44 24 4c	 lea	 eax, DWORD PTR _szTmp2$[esp+860]
  00129	50		 push	 eax
  0012a	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  0012f	57		 push	 edi
  00130	e8 00 00 00 00	 call	 _StatusMessageParam
  00135	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN20@DoTrueCryp@2:

; 1429 : 	if (StatDeleteFile (szTmp2) == FALSE)

  00138	8d 4c 24 14	 lea	 ecx, DWORD PTR _st$138508[esp+860]
  0013c	51		 push	 ecx
  0013d	8d 54 24 50	 lea	 edx, DWORD PTR _szTmp2$[esp+864]
  00141	52		 push	 edx
  00142	e8 00 00 00 00	 call	 __stat64
  00147	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__DeleteFileA@4
  0014d	83 c4 08	 add	 esp, 8
  00150	85 c0		 test	 eax, eax
  00152	75 0f		 jne	 SHORT $LN49@DoTrueCryp@2
  00154	8d 44 24 4c	 lea	 eax, DWORD PTR _szTmp2$[esp+860]
  00158	50		 push	 eax
  00159	ff d6		 call	 esi
  0015b	85 c0		 test	 eax, eax
  0015d	0f 84 cd 01 00
	00		 je	 $LN54@DoTrueCryp@2
$LN49@DoTrueCryp@2:

; 1430 : 		goto error;
; 1431 : 
; 1432 : 	snprintf (szTmp2, sizeof(szTmp2), "%s%s", szLinkDir, "\\TrueCrypt Website.url");

  00163	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@CJOJHCCA@?2TrueCrypt?5Website?4url?$AA@
  00168	8d 8c 24 54 01
	00 00		 lea	 ecx, DWORD PTR _szLinkDir$[esp+864]
  0016f	51		 push	 ecx
  00170	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  00175	8d 54 24 58	 lea	 edx, DWORD PTR _szTmp2$[esp+872]
  00179	68 04 01 00 00	 push	 260			; 00000104H
  0017e	52		 push	 edx
  0017f	e8 00 00 00 00	 call	 _sprintf_s
  00184	83 c4 14	 add	 esp, 20			; 00000014H

; 1433 : 	RemoveMessage (hwndDlg, szTmp2);

  00187	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  0018e	75 13		 jne	 SHORT $LN27@DoTrueCryp@2
  00190	8d 44 24 4c	 lea	 eax, DWORD PTR _szTmp2$[esp+860]
  00194	50		 push	 eax
  00195	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  0019a	57		 push	 edi
  0019b	e8 00 00 00 00	 call	 _StatusMessageParam
  001a0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN27@DoTrueCryp@2:

; 1434 : 	if (StatDeleteFile (szTmp2) == FALSE)

  001a3	8d 4c 24 14	 lea	 ecx, DWORD PTR _st$138519[esp+860]
  001a7	51		 push	 ecx
  001a8	8d 54 24 50	 lea	 edx, DWORD PTR _szTmp2$[esp+864]
  001ac	52		 push	 edx
  001ad	e8 00 00 00 00	 call	 __stat64
  001b2	83 c4 08	 add	 esp, 8
  001b5	85 c0		 test	 eax, eax
  001b7	75 0f		 jne	 SHORT $LN50@DoTrueCryp@2
  001b9	8d 44 24 4c	 lea	 eax, DWORD PTR _szTmp2$[esp+860]
  001bd	50		 push	 eax
  001be	ff d6		 call	 esi
  001c0	85 c0		 test	 eax, eax
  001c2	0f 84 68 01 00
	00		 je	 $LN54@DoTrueCryp@2
$LN50@DoTrueCryp@2:

; 1435 : 		goto error;
; 1436 : 
; 1437 : 	snprintf (szTmp2, sizeof(szTmp2), "%s%s", szLinkDir, "\\Uninstall TrueCrypt.lnk");

  001c8	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@PKBPEMBD@?2Uninstall?5TrueCrypt?4lnk?$AA@
  001cd	8d 8c 24 54 01
	00 00		 lea	 ecx, DWORD PTR _szLinkDir$[esp+864]
  001d4	51		 push	 ecx
  001d5	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  001da	8d 54 24 58	 lea	 edx, DWORD PTR _szTmp2$[esp+872]
  001de	68 04 01 00 00	 push	 260			; 00000104H
  001e3	52		 push	 edx
  001e4	e8 00 00 00 00	 call	 _sprintf_s
  001e9	83 c4 14	 add	 esp, 20			; 00000014H

; 1438 : 	RemoveMessage (hwndDlg, szTmp2);

  001ec	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  001f3	75 13		 jne	 SHORT $LN34@DoTrueCryp@2
  001f5	8d 44 24 4c	 lea	 eax, DWORD PTR _szTmp2$[esp+860]
  001f9	50		 push	 eax
  001fa	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  001ff	57		 push	 edi
  00200	e8 00 00 00 00	 call	 _StatusMessageParam
  00205	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN34@DoTrueCryp@2:

; 1439 : 	if (StatDeleteFile (szTmp2) == FALSE)

  00208	8d 4c 24 14	 lea	 ecx, DWORD PTR _st$138530[esp+860]
  0020c	51		 push	 ecx
  0020d	8d 54 24 50	 lea	 edx, DWORD PTR _szTmp2$[esp+864]
  00211	52		 push	 edx
  00212	e8 00 00 00 00	 call	 __stat64
  00217	83 c4 08	 add	 esp, 8
  0021a	85 c0		 test	 eax, eax
  0021c	75 0f		 jne	 SHORT $LN51@DoTrueCryp@2
  0021e	8d 44 24 4c	 lea	 eax, DWORD PTR _szTmp2$[esp+860]
  00222	50		 push	 eax
  00223	ff d6		 call	 esi
  00225	85 c0		 test	 eax, eax
  00227	0f 84 03 01 00
	00		 je	 $LN54@DoTrueCryp@2
$LN51@DoTrueCryp@2:

; 1440 : 		goto error;
; 1441 : 	
; 1442 : 	snprintf (szTmp2, sizeof(szTmp2), "%s%s", szLinkDir, "\\TrueCrypt User's Guide.lnk");

  0022d	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@LNFOIEOO@?2TrueCrypt?5User?8s?5Guide?4lnk?$AA@
  00232	8d 8c 24 54 01
	00 00		 lea	 ecx, DWORD PTR _szLinkDir$[esp+864]
  00239	51		 push	 ecx
  0023a	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  0023f	8d 54 24 58	 lea	 edx, DWORD PTR _szTmp2$[esp+872]
  00243	68 04 01 00 00	 push	 260			; 00000104H
  00248	52		 push	 edx
  00249	e8 00 00 00 00	 call	 _sprintf_s
  0024e	83 c4 14	 add	 esp, 20			; 00000014H

; 1443 : 	DeleteFile (szTmp2);

  00251	8d 44 24 4c	 lea	 eax, DWORD PTR _szTmp2$[esp+860]
  00255	50		 push	 eax
  00256	ff d6		 call	 esi

; 1444 : 
; 1445 : 	// Start menu group
; 1446 : 	RemoveMessage ((HWND) hwndDlg, szLinkDir);

  00258	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  0025f	75 16		 jne	 SHORT $LN41@DoTrueCryp@2
  00261	8d 8c 24 50 01
	00 00		 lea	 ecx, DWORD PTR _szLinkDir$[esp+860]
  00268	51		 push	 ecx
  00269	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  0026e	57		 push	 edi
  0026f	e8 00 00 00 00	 call	 _StatusMessageParam
  00274	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN41@DoTrueCryp@2:

; 1447 : 	if (StatRemoveDirectory (szLinkDir))

  00277	8d 94 24 50 01
	00 00		 lea	 edx, DWORD PTR _szLinkDir$[esp+860]
  0027e	52		 push	 edx
  0027f	e8 00 00 00 00	 call	 _StatRemoveDirectory
  00284	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SHChangeNotify@16
  0028a	83 c4 04	 add	 esp, 4
  0028d	85 c0		 test	 eax, eax
  0028f	74 12		 je	 SHORT $LN6@DoTrueCryp@2

; 1448 : 		SHChangeNotify (SHCNE_RMDIR, SHCNF_PATH, szLinkDir, NULL);

  00291	6a 00		 push	 0
  00293	8d 84 24 54 01
	00 00		 lea	 eax, DWORD PTR _szLinkDir$[esp+864]
  0029a	50		 push	 eax
  0029b	6a 01		 push	 1
  0029d	6a 10		 push	 16			; 00000010H
  0029f	ff d6		 call	 esi

; 1449 : 	else

  002a1	eb 09		 jmp	 SHORT $LN5@DoTrueCryp@2
$LN6@DoTrueCryp@2:

; 1450 : 		handleWin32Error ((HWND) hwndDlg);

  002a3	57		 push	 edi
  002a4	e8 00 00 00 00	 call	 _handleWin32Error
  002a9	83 c4 04	 add	 esp, 4
$LN5@DoTrueCryp@2:

; 1451 : 
; 1452 : 	// Desktop icon
; 1453 : 	if (allUsers)
; 1454 : 		SHGetSpecialFolderPath (hwndDlg, szLinkDir, CSIDL_COMMON_DESKTOPDIRECTORY, 0);

  002ac	6a 00		 push	 0
  002ae	85 ed		 test	 ebp, ebp
  002b0	74 0c		 je	 SHORT $LN4@DoTrueCryp@2
  002b2	6a 19		 push	 25			; 00000019H
  002b4	8d 8c 24 58 01
	00 00		 lea	 ecx, DWORD PTR _szLinkDir$[esp+868]
  002bb	51		 push	 ecx

; 1455 : 	else

  002bc	eb 0a		 jmp	 SHORT $LN55@DoTrueCryp@2
$LN4@DoTrueCryp@2:

; 1456 : 		SHGetSpecialFolderPath (hwndDlg, szLinkDir, CSIDL_DESKTOPDIRECTORY, 0);

  002be	6a 10		 push	 16			; 00000010H
  002c0	8d 94 24 58 01
	00 00		 lea	 edx, DWORD PTR _szLinkDir$[esp+868]
  002c7	52		 push	 edx
$LN55@DoTrueCryp@2:
  002c8	57		 push	 edi
  002c9	ff d3		 call	 ebx

; 1457 : 
; 1458 : 	snprintf (szTmp2, sizeof(szTmp2), "%s%s", szLinkDir, "\\TrueCrypt.lnk");

  002cb	68 00 00 00 00	 push	 OFFSET ??_C@_0P@DFHIDPDG@?2TrueCrypt?4lnk?$AA@
  002d0	8d 84 24 54 01
	00 00		 lea	 eax, DWORD PTR _szLinkDir$[esp+864]
  002d7	50		 push	 eax
  002d8	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  002dd	8d 4c 24 58	 lea	 ecx, DWORD PTR _szTmp2$[esp+872]
  002e1	68 04 01 00 00	 push	 260			; 00000104H
  002e6	51		 push	 ecx
  002e7	e8 00 00 00 00	 call	 _sprintf_s
  002ec	83 c4 14	 add	 esp, 20			; 00000014H

; 1459 : 
; 1460 : 	RemoveMessage (hwndDlg, szTmp2);

  002ef	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  002f6	75 13		 jne	 SHORT $LN44@DoTrueCryp@2
  002f8	8d 54 24 4c	 lea	 edx, DWORD PTR _szTmp2$[esp+860]
  002fc	52		 push	 edx
  002fd	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
  00302	57		 push	 edi
  00303	e8 00 00 00 00	 call	 _StatusMessageParam
  00308	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN44@DoTrueCryp@2:

; 1461 : 	if (StatDeleteFile (szTmp2) == FALSE)

  0030b	8d 44 24 4c	 lea	 eax, DWORD PTR _szTmp2$[esp+860]
  0030f	50		 push	 eax
  00310	e8 00 00 00 00	 call	 _StatDeleteFile
  00315	83 c4 04	 add	 esp, 4
  00318	85 c0		 test	 eax, eax
  0031a	74 14		 je	 SHORT $LN54@DoTrueCryp@2

; 1462 : 		goto error;
; 1463 : 
; 1464 : 	SHChangeNotify (SHCNE_DELETE, SHCNF_PATH, szTmp2, NULL);

  0031c	6a 00		 push	 0
  0031e	8d 4c 24 50	 lea	 ecx, DWORD PTR _szTmp2$[esp+864]
  00322	51		 push	 ecx
  00323	6a 01		 push	 1
  00325	6a 04		 push	 4
  00327	ff d6		 call	 esi

; 1465 : 
; 1466 : 	bOK = TRUE;

  00329	be 01 00 00 00	 mov	 esi, 1
  0032e	eb 04		 jmp	 SHORT $error$134683
$LN54@DoTrueCryp@2:
  00330	8b 74 24 10	 mov	 esi, DWORD PTR _bOK$[esp+860]
$error$134683:

; 1467 : 
; 1468 : error:
; 1469 : 	OleUninitialize ();

  00334	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OleUninitialize@0

; 1470 : 
; 1471 : 	return bOK;
; 1472 : }

  0033a	8b 8c 24 58 03
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+860]
  00341	5f		 pop	 edi
  00342	8b c6		 mov	 eax, esi
  00344	5e		 pop	 esi
  00345	5d		 pop	 ebp
  00346	5b		 pop	 ebx
  00347	33 cc		 xor	 ecx, esp
  00349	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0034e	81 c4 4c 03 00
	00		 add	 esp, 844		; 0000034cH
  00354	c3		 ret	 0
_DoTrueCryptShortcutsUninstall ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@JJJJFLNM@UNINSTALL_FAILED?$AA@	; `string'
PUBLIC	??_C@_0P@DHOALJNC@INSTALL_FAILED?$AA@		; `string'
PUBLIC	??_C@_0N@HGHJILFC@UNINSTALL_OK?$AA@		; `string'
PUBLIC	??_C@_0L@NPHNJMLA@INSTALL_OK?$AA@		; `string'
PUBLIC	??_C@_0BA@GIHLNOHP@SETUP_UPDATE_OK?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_OutcomePrompt
EXTRN	__imp__PostMessageA@16:PROC
EXTRN	_MainDlg:DWORD
EXTRN	__imp__EnableWindow@8:PROC
;	COMDAT ??_C@_0BB@JJJJFLNM@UNINSTALL_FAILED?$AA@
CONST	SEGMENT
??_C@_0BB@JJJJFLNM@UNINSTALL_FAILED?$AA@ DB 'UNINSTALL_FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DHOALJNC@INSTALL_FAILED?$AA@
CONST	SEGMENT
??_C@_0P@DHOALJNC@INSTALL_FAILED?$AA@ DB 'INSTALL_FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HGHJILFC@UNINSTALL_OK?$AA@
CONST	SEGMENT
??_C@_0N@HGHJILFC@UNINSTALL_OK?$AA@ DB 'UNINSTALL_OK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NPHNJMLA@INSTALL_OK?$AA@
CONST	SEGMENT
??_C@_0L@NPHNJMLA@INSTALL_OK?$AA@ DB 'INSTALL_OK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GIHLNOHP@SETUP_UPDATE_OK?$AA@
CONST	SEGMENT
??_C@_0BA@GIHLNOHP@SETUP_UPDATE_OK?$AA@ DB 'SETUP_UPDATE_OK', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _OutcomePrompt
_TEXT	SEGMENT
_str$134767 = -8196					; size = 8192
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_bOK$ = 12						; size = 4
_OutcomePrompt PROC					; COMDAT

; 1595 : {

  00000	b8 04 20 00 00	 mov	 eax, 8196		; 00002004H
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000f	33 c4		 xor	 eax, esp
  00011	89 84 24 00 20
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+8196], eax

; 1596 : 	if (bOK)

  00018	83 bc 24 0c 20
	00 00 00	 cmp	 DWORD PTR _bOK$[esp+8192], 0
  00020	56		 push	 esi
  00021	8b b4 24 0c 20
	00 00		 mov	 esi, DWORD PTR _hwndDlg$[esp+8196]
  00028	0f 84 dd 00 00
	00		 je	 $LN11@OutcomePro

; 1597 : 	{
; 1598 : 		EnableWindow (GetDlgItem ((HWND) hwndDlg, IDCANCEL), FALSE);

  0002e	6a 00		 push	 0
  00030	6a 02		 push	 2
  00032	56		 push	 esi
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00039	50		 push	 eax
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 1599 : 
; 1600 : 		bDone = TRUE;
; 1601 : 
; 1602 : 		if (bUninstall == FALSE)

  00040	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bUninstall@@3HA, 0 ; bUninstall
  00047	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bDone@@3HA, 1 ; bDone
  00051	75 6d		 jne	 SHORT $LN10@OutcomePro

; 1603 : 		{
; 1604 : 			if (bDevm)

  00053	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bDevm, 0
  0005a	74 28		 je	 SHORT $LN9@OutcomePro

; 1605 : 				PostMessage (MainDlg, WM_CLOSE, 0, 0);

  0005c	a1 00 00 00 00	 mov	 eax, DWORD PTR _MainDlg
  00061	6a 00		 push	 0
  00063	6a 00		 push	 0
  00065	6a 10		 push	 16			; 00000010H
  00067	50		 push	 eax
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16
  0006e	5e		 pop	 esi

; 1625 : 	}
; 1626 : }

  0006f	8b 8c 24 00 20
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+8196]
  00076	33 cc		 xor	 ecx, esp
  00078	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007d	81 c4 04 20 00
	00		 add	 esp, 8196		; 00002004H
  00083	c3		 ret	 0
$LN9@OutcomePro:

; 1606 : 			else if (bPossiblyFirstTimeInstall || bRepairMode || (!bUpgrade && !bDowngrade))

  00084	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bPossiblyFirstTimeInstall, 0
  0008b	75 27		 jne	 SHORT $LN6@OutcomePro
  0008d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bRepairMode, 0
  00094	75 1e		 jne	 SHORT $LN6@OutcomePro
  00096	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bUpgrade, 0
  0009d	75 09		 jne	 SHORT $LN7@OutcomePro
  0009f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDowngrade@@3HA, 0 ; bDowngrade
  000a6	74 0c		 je	 SHORT $LN6@OutcomePro
$LN7@OutcomePro:

; 1608 : 			else
; 1609 : 				Info ("SETUP_UPDATE_OK");

  000a8	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@GIHLNOHP@SETUP_UPDATE_OK?$AA@
  000ad	e8 00 00 00 00	 call	 _Info
  000b2	eb 71		 jmp	 SHORT $LN14@OutcomePro
$LN6@OutcomePro:

; 1607 : 				Info ("INSTALL_OK");

  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_0L@NPHNJMLA@INSTALL_OK?$AA@
  000b9	e8 00 00 00 00	 call	 _Info

; 1610 : 		}
; 1611 : 		else

  000be	eb 65		 jmp	 SHORT $LN14@OutcomePro
$LN10@OutcomePro:

; 1612 : 		{
; 1613 : 			wchar_t str[4096];
; 1614 : 
; 1615 : 			swprintf (str, GetString ("UNINSTALL_OK"), UninstallationPath);

  000c0	68 00 00 00 00	 push	 OFFSET ?UninstallationPath@@3PADA ; UninstallationPath
  000c5	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HGHJILFC@UNINSTALL_OK?$AA@
  000ca	e8 00 00 00 00	 call	 _GetString
  000cf	83 c4 04	 add	 esp, 4
  000d2	50		 push	 eax
  000d3	8d 4c 24 0c	 lea	 ecx, DWORD PTR _str$134767[esp+8208]
  000d7	51		 push	 ecx
  000d8	e8 00 00 00 00	 call	 ?swprintf@@YAHPA_WPB_WZZ ; swprintf

; 1616 : 			MessageBoxW (hwndDlg, str, lpszTitle, MB_ICONASTERISK);

  000dd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lpszTitle
  000e3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e6	6a 40		 push	 64			; 00000040H
  000e8	52		 push	 edx
  000e9	8d 44 24 0c	 lea	 eax, DWORD PTR _str$134767[esp+8208]
  000ed	50		 push	 eax
  000ee	56		 push	 esi
  000ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
  000f5	5e		 pop	 esi

; 1625 : 	}
; 1626 : }

  000f6	8b 8c 24 00 20
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+8196]
  000fd	33 cc		 xor	 ecx, esp
  000ff	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00104	81 c4 04 20 00
	00		 add	 esp, 8196		; 00002004H
  0010a	c3		 ret	 0
$LN11@OutcomePro:

; 1617 : 		}
; 1618 : 	}
; 1619 : 	else
; 1620 : 	{
; 1621 : 		if (bUninstall == FALSE)

  0010b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bUninstall@@3HA, 0 ; bUninstall
  00112	75 07		 jne	 SHORT $LN2@OutcomePro

; 1622 : 			Error ("INSTALL_FAILED");

  00114	68 00 00 00 00	 push	 OFFSET ??_C@_0P@DHOALJNC@INSTALL_FAILED?$AA@

; 1623 : 		else

  00119	eb 05		 jmp	 SHORT $LN15@OutcomePro
$LN2@OutcomePro:

; 1624 : 			Error ("UNINSTALL_FAILED");

  0011b	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@JJJJFLNM@UNINSTALL_FAILED?$AA@
$LN15@OutcomePro:
  00120	e8 00 00 00 00	 call	 _Error
$LN14@OutcomePro:

; 1625 : 	}
; 1626 : }

  00125	8b 8c 24 08 20
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+8204]
  0012c	83 c4 04	 add	 esp, 4
  0012f	5e		 pop	 esi
  00130	33 cc		 xor	 ecx, esp
  00132	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00137	81 c4 04 20 00
	00		 add	 esp, 8196		; 00002004H
  0013d	c3		 ret	 0
_OutcomePrompt ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@EKOFOABK@FAILED_SYS_RESTORE?$AA@	; `string'
PUBLIC	??_C@_0BI@NHHPLGPL@CipherShed?5installation?$AA@ ; `string'
PUBLIC	??_C@_0BK@JOHDEADA@CipherShed?5uninstallation?$AA@ ; `string'
PUBLIC	??_C@_0BF@DPJDLMKG@CREATING_SYS_RESTORE?$AA@	; `string'
PUBLIC	??_C@_0BD@BOLGBJDG@SRSetRestorePointA?$AA@	; `string'
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
;	COMDAT ?failed@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4HA
_BSS	SEGMENT
?failed@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4HA DD 01H DUP (?) ; `SetSystemRestorePoint'::`2'::failed
_BSS	ENDS
;	COMDAT ?SMgrStatus@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_SMGRSTATUS@@A
_BSS	SEGMENT
?SMgrStatus@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_SMGRSTATUS@@A DB 0cH DUP (?) ; `SetSystemRestorePoint'::`2'::SMgrStatus
_BSS	ENDS
;	COMDAT ?RestPtInfo@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_RESTOREPTINFOA@@A
_BSS	SEGMENT
?RestPtInfo@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_RESTOREPTINFOA@@A DB 050H DUP (?) ; `SetSystemRestorePoint'::`2'::RestPtInfo
_BSS	ENDS
;	COMDAT ?_SRSetRestorePoint@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4P6GHPAU_RESTOREPTINFOA@@PAU_SMGRSTATUS@@@ZA
_BSS	SEGMENT
?_SRSetRestorePoint@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4P6GHPAU_RESTOREPTINFOA@@PAU_SMGRSTATUS@@@ZA DD 01H DUP (?) ; `SetSystemRestorePoint'::`2'::_SRSetRestorePoint
_BSS	ENDS
;	COMDAT ??_C@_0BD@EKOFOABK@FAILED_SYS_RESTORE?$AA@
CONST	SEGMENT
??_C@_0BD@EKOFOABK@FAILED_SYS_RESTORE?$AA@ DB 'FAILED_SYS_RESTORE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NHHPLGPL@CipherShed?5installation?$AA@
CONST	SEGMENT
??_C@_0BI@NHHPLGPL@CipherShed?5installation?$AA@ DB 'CipherShed installat'
	DB	'ion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JOHDEADA@CipherShed?5uninstallation?$AA@
CONST	SEGMENT
??_C@_0BK@JOHDEADA@CipherShed?5uninstallation?$AA@ DB 'CipherShed uninsta'
	DB	'llation', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DPJDLMKG@CREATING_SYS_RESTORE?$AA@
CONST	SEGMENT
??_C@_0BF@DPJDLMKG@CREATING_SYS_RESTORE?$AA@ DB 'CREATING_SYS_RESTORE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BOLGBJDG@SRSetRestorePointA?$AA@
CONST	SEGMENT
??_C@_0BD@BOLGBJDG@SRSetRestorePointA?$AA@ DB 'SRSetRestorePointA', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?SetSystemRestorePoint@@YAXPAUHWND__@@H@Z
_TEXT	SEGMENT
_finalize$ = 8						; size = 4
?SetSystemRestorePoint@@YAXPAUHWND__@@H@Z PROC		; SetSystemRestorePoint, COMDAT
; _hwndDlg$ = esi

; 1636 : 	static RESTOREPOINTINFO RestPtInfo;
; 1637 : 	static STATEMGRSTATUS SMgrStatus;
; 1638 : 	static BOOL failed = FALSE;
; 1639 : 	static BOOL (__stdcall *_SRSetRestorePoint)(PRESTOREPOINTINFO, PSTATEMGRSTATUS);
; 1640 : 
; 1641 : 	/* Abort if the system restore dll wasn't loaded successfully. */
; 1642 : 	if (!SystemRestoreDll)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _SystemRestoreDll
  00005	85 c0		 test	 eax, eax
  00007	0f 84 14 01 00
	00		 je	 $LN1@SetSystemR

; 1643 : 		return;
; 1644 : 
; 1645 : 	/* Retrieve the address of SRSetRestorePointA. */
; 1646 : 	_SRSetRestorePoint = (BOOL (__stdcall *)(PRESTOREPOINTINFO, PSTATEMGRSTATUS))GetProcAddress (SystemRestoreDll,"SRSetRestorePointA");

  0000d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SystemRestoreDll
  00013	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@BOLGBJDG@SRSetRestorePointA?$AA@
  00018	51		 push	 ecx
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  0001f	a3 00 00 00 00	 mov	 DWORD PTR ?_SRSetRestorePoint@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4P6GHPAU_RESTOREPTINFOA@@PAU_SMGRSTATUS@@@ZA, eax

; 1647 : 	if (_SRSetRestorePoint == 0)

  00024	85 c0		 test	 eax, eax
  00026	75 18		 jne	 SHORT $LN6@SetSystemR

; 1648 : 	{
; 1649 : 		FreeLibrary (SystemRestoreDll);

  00028	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SystemRestoreDll
  0002e	52		 push	 edx
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4

; 1650 : 		SystemRestoreDll = 0;

  00035	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _SystemRestoreDll, 0

; 1680 : 		}
; 1681 : 	}
; 1682 : }

  0003f	c3		 ret	 0
$LN6@SetSystemR:

; 1651 : 		return;
; 1652 : 	}
; 1653 : 
; 1654 : 	/* Begin system change. */
; 1655 : 	if (!finalize)

  00040	83 7c 24 04 00	 cmp	 DWORD PTR _finalize$[esp-4], 0
  00045	0f 85 8d 00 00
	00		 jne	 $LN5@SetSystemR

; 1656 : 	{
; 1657 : 		StatusMessage (hwndDlg, "CREATING_SYS_RESTORE");

  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@DPJDLMKG@CREATING_SYS_RESTORE?$AA@
  00050	56		 push	 esi
  00051	e8 00 00 00 00	 call	 _StatusMessage

; 1658 : 
; 1659 : 		RestPtInfo.dwEventType = BEGIN_SYSTEM_CHANGE;
; 1660 : 		RestPtInfo.dwRestorePtType = bUninstall ? APPLICATION_UNINSTALL : APPLICATION_INSTALL | DEVICE_DRIVER_INSTALL;

  00056	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bUninstall@@3HA ; bUninstall
  0005b	83 c4 08	 add	 esp, 8
  0005e	8b c8		 mov	 ecx, eax
  00060	f7 d9		 neg	 ecx
  00062	1b c9		 sbb	 ecx, ecx
  00064	83 e1 f7	 and	 ecx, -9			; fffffff7H
  00067	83 c1 0a	 add	 ecx, 10			; 0000000aH
  0006a	89 0d 04 00 00
	00		 mov	 DWORD PTR ?RestPtInfo@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_RESTOREPTINFOA@@A+4, ecx
  00070	c7 05 00 00 00
	00 64 00 00 00	 mov	 DWORD PTR ?RestPtInfo@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_RESTOREPTINFOA@@A, 100 ; 00000064H

; 1661 : 		RestPtInfo.llSequenceNumber = 0;

  0007a	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?RestPtInfo@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_RESTOREPTINFOA@@A+8, 0
  00084	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?RestPtInfo@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_RESTOREPTINFOA@@A+12, 0

; 1662 : 		strcpy (RestPtInfo.szDescription, bUninstall ? "CipherShed uninstallation" : "CipherShed installation");

  0008e	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BK@JOHDEADA@CipherShed?5uninstallation?$AA@
  00093	85 c0		 test	 eax, eax
  00095	75 05		 jne	 SHORT $LN11@SetSystemR
  00097	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BI@NHHPLGPL@CipherShed?5installation?$AA@
$LN11@SetSystemR:
  0009c	ba 10 00 00 00	 mov	 edx, OFFSET ?RestPtInfo@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_RESTOREPTINFOA@@A+16
$LL12@SetSystemR:
  000a1	8a 01		 mov	 al, BYTE PTR [ecx]
  000a3	88 02		 mov	 BYTE PTR [edx], al
  000a5	41		 inc	 ecx
  000a6	42		 inc	 edx
  000a7	84 c0		 test	 al, al
  000a9	75 f6		 jne	 SHORT $LL12@SetSystemR

; 1663 : 
; 1664 : 		if(!_SRSetRestorePoint (&RestPtInfo, &SMgrStatus)) 

  000ab	68 00 00 00 00	 push	 OFFSET ?SMgrStatus@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_SMGRSTATUS@@A
  000b0	68 00 00 00 00	 push	 OFFSET ?RestPtInfo@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_RESTOREPTINFOA@@A
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR ?_SRSetRestorePoint@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4P6GHPAU_RESTOREPTINFOA@@PAU_SMGRSTATUS@@@ZA
  000bb	85 c0		 test	 eax, eax
  000bd	75 62		 jne	 SHORT $LN1@SetSystemR

; 1665 : 		{
; 1666 : 			StatusMessage (hwndDlg, "FAILED_SYS_RESTORE");

  000bf	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@EKOFOABK@FAILED_SYS_RESTORE?$AA@
  000c4	56		 push	 esi
  000c5	e8 00 00 00 00	 call	 _StatusMessage

; 1667 : 			failed = TRUE;

  000ca	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?failed@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4HA, 1

; 1678 : 		{
; 1679 : 			StatusMessage (hwndDlg, "FAILED_SYS_RESTORE");

  000d4	83 c4 08	 add	 esp, 8

; 1680 : 		}
; 1681 : 	}
; 1682 : }

  000d7	c3		 ret	 0
$LN5@SetSystemR:

; 1668 : 		}
; 1669 : 	}
; 1670 : 
; 1671 : 	/* End system change. */
; 1672 : 	else if (!failed)

  000d8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?failed@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4HA, 0
  000df	75 40		 jne	 SHORT $LN1@SetSystemR

; 1673 : 	{
; 1674 : 		RestPtInfo.dwEventType = END_SYSTEM_CHANGE;
; 1675 : 		RestPtInfo.llSequenceNumber = SMgrStatus.llSequenceNumber;

  000e1	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?SMgrStatus@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_SMGRSTATUS@@A+4
  000e7	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?SMgrStatus@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_SMGRSTATUS@@A+8

; 1676 : 
; 1677 : 		if(!_SRSetRestorePoint(&RestPtInfo, &SMgrStatus)) 

  000ed	68 00 00 00 00	 push	 OFFSET ?SMgrStatus@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_SMGRSTATUS@@A
  000f2	68 00 00 00 00	 push	 OFFSET ?RestPtInfo@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_RESTOREPTINFOA@@A
  000f7	c7 05 00 00 00
	00 65 00 00 00	 mov	 DWORD PTR ?RestPtInfo@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_RESTOREPTINFOA@@A, 101 ; 00000065H
  00101	89 15 08 00 00
	00		 mov	 DWORD PTR ?RestPtInfo@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_RESTOREPTINFOA@@A+8, edx
  00107	89 0d 0c 00 00
	00		 mov	 DWORD PTR ?RestPtInfo@?1??SetSystemRestorePoint@@YAXPAUHWND__@@H@Z@4U_RESTOREPTINFOA@@A+12, ecx
  0010d	ff d0		 call	 eax
  0010f	85 c0		 test	 eax, eax
  00111	75 0e		 jne	 SHORT $LN1@SetSystemR

; 1678 : 		{
; 1679 : 			StatusMessage (hwndDlg, "FAILED_SYS_RESTORE");

  00113	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@EKOFOABK@FAILED_SYS_RESTORE?$AA@
  00118	56		 push	 esi
  00119	e8 00 00 00 00	 call	 _StatusMessage
  0011e	83 c4 08	 add	 esp, 8
$LN1@SetSystemR:

; 1680 : 		}
; 1681 : 	}
; 1682 : }

  00121	c3		 ret	 0
?SetSystemRestorePoint@@YAXPAUHWND__@@H@Z ENDP		; SetSystemRestorePoint
_TEXT	ENDS
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1666 : 		return (_Mysize);

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 1667 : 		}

  00003	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtpy
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2170 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00004	72 04		 jb	 SHORT $LN3@Myptr
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 2171 : 		}

  00009	c3		 ret	 0
$LN3@Myptr:

; 2170 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  0000a	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 2171 : 		}

  0000d	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtpy
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2175 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00004	72 04		 jb	 SHORT $LN3@Myptr@2
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 2176 : 		}

  00009	c3		 ret	 0
$LN3@Myptr@2:

; 2175 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  0000a	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 2176 : 		}

  0000d	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

  00002	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 141  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

  00000	83 c8 ff	 or	 eax, -1

; 167  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
PUBLIC	??$IID_PPV_ARGS_Helper@UIPropertyStore@@@@YAPAPAXPAPAUIPropertyStore@@@Z ; IID_PPV_ARGS_Helper<IPropertyStore>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft sdks\windows\v7.1\include\objbase.h
;	COMDAT ??$IID_PPV_ARGS_Helper@UIPropertyStore@@@@YAPAPAXPAPAUIPropertyStore@@@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
??$IID_PPV_ARGS_Helper@UIPropertyStore@@@@YAPAPAXPAPAUIPropertyStore@@@Z PROC ; IID_PPV_ARGS_Helper<IPropertyStore>, COMDAT

; 239  :         static_cast<IUnknown*>(*pp);    // make sure everyone derives from IUnknown
; 240  :         return reinterpret_cast<void**>(pp);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _pp$[esp-4]

; 241  :     }

  00004	c3		 ret	 0
??$IID_PPV_ARGS_Helper@UIPropertyStore@@@@YAPAPAXPAPAUIPropertyStore@@@Z ENDP ; IID_PPV_ARGS_Helper<IPropertyStore>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
$T138590 = -12						; size = 12
$T138595 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 37   : 	if (_Count <= 0)

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00007	85 c9		 test	 ecx, ecx
  00009	77 0f		 ja	 SHORT $LN3@Allocate

; 38   : 		_Count = 0;

  0000b	33 c9		 xor	 ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00013	83 c4 04	 add	 esp, 4

; 44   : 	}

  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	c3		 ret	 0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

  0001a	83 c8 ff	 or	 eax, -1
  0001d	33 d2		 xor	 edx, edx
  0001f	f7 f1		 div	 ecx
  00021	83 f8 01	 cmp	 eax, 1
  00024	73 e7		 jae	 SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

  00026	8d 44 24 10	 lea	 eax, DWORD PTR $T138595[esp+8]
  0002a	50		 push	 eax
  0002b	8d 4c 24 04	 lea	 ecx, DWORD PTR $T138590[esp+16]
  0002f	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR $T138595[esp+12], 0
  00037	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003c	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00041	8d 4c 24 04	 lea	 ecx, DWORD PTR $T138590[esp+16]
  00045	51		 push	 ecx
  00046	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR $T138590[esp+20], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN8@Allocate:
  00053	cc		 int	 3
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___that$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ ; std::_Char_traits_cat<std::char_traits<char> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\iosfwd
;	COMDAT ??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ
_TEXT	SEGMENT
__Secure$ = -1						; size = 1
??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ PROC ; std::_Char_traits_cat<std::char_traits<char> >, COMDAT

; 575  : 	{

  00000	51		 push	 ecx

; 576  : 		typename _Char_traits_category<_Traits>::_Secure_char_traits _Secure;
; 577  : 		return (_Secure);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Secure$[esp+4]

; 578  : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ ENDP ; std::_Char_traits_cat<std::char_traits<char> >
_TEXT	ENDS
PUBLIC	??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ; std::_Traits_helper::move_s<std::char_traits<char> >
; Function compile flags: /Ogtpy
;	COMDAT ??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
___formal$ = 24						; size = 1
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z PROC ; std::_Traits_helper::move_s<std::char_traits<char> >, COMDAT

; 624  : 		return _Traits::_Move_s(_First1, _Size, _First2, _Count);

  00000	8b 44 24 10	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8b 4c 24 0c	 mov	 ecx, DWORD PTR __First2$[esp-4]
  00008	8b 54 24 08	 mov	 edx, DWORD PTR __Size$[esp-4]
  0000c	56		 push	 esi
  0000d	8b 74 24 08	 mov	 esi, DWORD PTR __First1$[esp]
  00011	50		 push	 eax
  00012	51		 push	 ecx
  00013	52		 push	 edx
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 _memmove_s
  0001a	83 c4 10	 add	 esp, 16			; 00000010H
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi

; 625  : 	}

  00020	c3		 ret	 0
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ENDP ; std::_Traits_helper::move_s<std::char_traits<char> >
_TEXT	ENDS
PUBLIC	??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ; std::_Traits_helper::copy_s<std::char_traits<char> >
; Function compile flags: /Ogtpy
;	COMDAT ??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
___formal$ = 24						; size = 1
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z PROC ; std::_Traits_helper::copy_s<std::char_traits<char> >, COMDAT

; 597  : 		return _Traits::_Copy_s(_First1, _Size, _First2, _Count);

  00000	8b 44 24 10	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8b 4c 24 0c	 mov	 ecx, DWORD PTR __First2$[esp-4]
  00008	8b 54 24 08	 mov	 edx, DWORD PTR __Size$[esp-4]
  0000c	56		 push	 esi
  0000d	8b 74 24 08	 mov	 esi, DWORD PTR __First1$[esp]
  00011	50		 push	 eax
  00012	51		 push	 ecx
  00013	52		 push	 edx
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 _memcpy_s
  0001a	83 c4 10	 add	 esp, 16			; 00000010H
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi

; 598  : 	}

  00020	c3		 ret	 0
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ENDP ; std::_Traits_helper::copy_s<std::char_traits<char> >
_TEXT	ENDS
PUBLIC	__GUID_886d8eeb_8cf2_4446_8d02_cdba1dbdcf99
PUBLIC	__$ArrayPad$
PUBLIC	_CreateLink
EXTRN	__imp__MultiByteToWideChar@24:PROC
EXTRN	_IID_IPersistFile:BYTE
EXTRN	__imp__PropVariantClear@4:PROC
EXTRN	_PKEY_AppUserModel_ID:BYTE
EXTRN	__imp__CoCreateInstance@20:PROC
EXTRN	_CLSID_ShellLink:BYTE
EXTRN	_IID_IShellLinkA:BYTE
;	COMDAT __GUID_886d8eeb_8cf2_4446_8d02_cdba1dbdcf99
; File c:\program files\microsoft sdks\windows\v7.1\include\propidl.h
CONST	SEGMENT
__GUID_886d8eeb_8cf2_4446_8d02_cdba1dbdcf99 DD 0886d8eebH
	DW	08cf2H
	DW	04446H
	DB	08dH
	DB	02H
	DB	0cdH
	DB	0baH
	DB	01dH
	DB	0bdH
	DB	0cfH
	DB	099H
; Function compile flags: /Ogtpy
; File c:\home\public\desktop\projects\ciphershed.build\src\setup\setup.c
CONST	ENDS
;	COMDAT _CreateLink
_TEXT	SEGMENT
_psl$ = -552						; size = 4
_propStore$134052 = -548				; size = 4
_ppf$134050 = -544					; size = 4
_propVariant$134060 = -540				; size = 16
_wsz$134069 = -524					; size = 520
__$ArrayPad$ = -4					; size = 4
_lpszPathObj$ = 8					; size = 4
_lpszArguments$ = 12					; size = 4
_lpszPathLink$ = 16					; size = 4
_CreateLink PROC					; COMDAT

; 114  : {

  00000	81 ec 28 02 00
	00		 sub	 esp, 552		; 00000228H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 24 02
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+552], eax
  00014	53		 push	 ebx
  00015	8b 9c 24 38 02
	00 00		 mov	 ebx, DWORD PTR _lpszPathLink$[esp+552]
  0001c	56		 push	 esi
  0001d	8b b4 24 34 02
	00 00		 mov	 esi, DWORD PTR _lpszPathObj$[esp+556]
  00024	57		 push	 edi
  00025	8b bc 24 3c 02
	00 00		 mov	 edi, DWORD PTR _lpszArguments$[esp+560]

; 115  : 	HRESULT hres;
; 116  : 	IShellLink *psl;
; 117  : 
; 118  : 	/* Get a pointer to the IShellLink interface.  */
; 119  : 	hres = CoCreateInstance (CLSID_ShellLink, NULL,
; 120  : 			       CLSCTX_INPROC_SERVER, IID_IShellLink, (LPVOID *) &psl);

  0002c	8d 44 24 0c	 lea	 eax, DWORD PTR _psl$[esp+564]
  00030	50		 push	 eax
  00031	68 00 00 00 00	 push	 OFFSET _IID_IShellLinkA
  00036	6a 01		 push	 1
  00038	6a 00		 push	 0
  0003a	68 00 00 00 00	 push	 OFFSET _CLSID_ShellLink
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoCreateInstance@20

; 121  : 	if (SUCCEEDED (hres))

  00045	85 c0		 test	 eax, eax
  00047	0f 8c 19 01 00
	00		 jl	 $LN6@CreateLink

; 122  : 	{
; 123  : 		IPersistFile *ppf;
; 124  : 
; 125  : 		/* Set the path to the shortcut target, and add the
; 126  : 		   description.  */
; 127  : 		psl->SetPath (lpszPathObj);

  0004d	8b 44 24 0c	 mov	 eax, DWORD PTR _psl$[esp+564]
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  00056	56		 push	 esi
  00057	50		 push	 eax
  00058	ff d2		 call	 edx

; 128  : 		psl->SetArguments (lpszArguments);

  0005a	8b 44 24 0c	 mov	 eax, DWORD PTR _psl$[esp+564]
  0005e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00060	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00063	57		 push	 edi
  00064	50		 push	 eax
  00065	ff d2		 call	 edx

; 129  : 
; 130  : 		// Application ID
; 131  : 		if (strstr (lpszPathObj, TC_APP_NAME ".exe"))

  00067	68 00 00 00 00	 push	 OFFSET ??_C@_0P@KEOPEMDF@CipherShed?4exe?$AA@
  0006c	56		 push	 esi
  0006d	e8 00 00 00 00	 call	 _strstr
  00072	83 c4 08	 add	 esp, 8
  00075	85 c0		 test	 eax, eax
  00077	0f 84 88 00 00
	00		 je	 $LN4@CreateLink

; 132  : 		{
; 133  : 			IPropertyStore *propStore;
; 134  : 
; 135  : 			if (SUCCEEDED (psl->QueryInterface (IID_PPV_ARGS (&propStore))))

  0007d	8b 44 24 0c	 mov	 eax, DWORD PTR _psl$[esp+564]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	8d 54 24 10	 lea	 edx, DWORD PTR _propStore$134052[esp+564]
  00087	52		 push	 edx
  00088	68 00 00 00 00	 push	 OFFSET __GUID_886d8eeb_8cf2_4446_8d02_cdba1dbdcf99
  0008d	50		 push	 eax
  0008e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00090	ff d0		 call	 eax
  00092	85 c0		 test	 eax, eax
  00094	7c 6f		 jl	 SHORT $LN4@CreateLink

; 136  : 			{
; 137  : 				PROPVARIANT propVariant;
; 138  : 				if (SUCCEEDED (InitPropVariantFromString (TC_APPLICATION_ID, &propVariant)))

  00096	8d 54 24 20	 lea	 edx, DWORD PTR _propVariant$134060[esp+572]
  0009a	52		 push	 edx
  0009b	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_1DK@KHACNMIN@?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AAP?$AAr?$AAo?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AA?$AA@
  000a5	66 89 4c 24 20	 mov	 WORD PTR _propVariant$134060[esp+572], cx
  000aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SHStrDupW@8
  000b0	85 c0		 test	 eax, eax
  000b2	7d 14		 jge	 SHORT $LN18@CreateLink
  000b4	33 c0		 xor	 eax, eax
  000b6	89 44 24 18	 mov	 DWORD PTR _propVariant$134060[esp+564], eax
  000ba	89 44 24 1c	 mov	 DWORD PTR _propVariant$134060[esp+568], eax
  000be	89 44 24 20	 mov	 DWORD PTR _propVariant$134060[esp+572], eax
  000c2	89 44 24 24	 mov	 DWORD PTR _propVariant$134060[esp+576], eax
  000c6	eb 31		 jmp	 SHORT $LN3@CreateLink
$LN18@CreateLink:

; 139  : 				{
; 140  : 					if (SUCCEEDED (propStore->SetValue (PKEY_AppUserModel_ID, propVariant)))

  000c8	8b 44 24 10	 mov	 eax, DWORD PTR _propStore$134052[esp+564]
  000cc	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ce	8d 54 24 18	 lea	 edx, DWORD PTR _propVariant$134060[esp+564]
  000d2	52		 push	 edx
  000d3	68 00 00 00 00	 push	 OFFSET _PKEY_AppUserModel_ID
  000d8	50		 push	 eax
  000d9	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  000dc	ff d0		 call	 eax
  000de	85 c0		 test	 eax, eax
  000e0	7c 0c		 jl	 SHORT $LN2@CreateLink

; 141  : 						propStore->Commit();

  000e2	8b 44 24 10	 mov	 eax, DWORD PTR _propStore$134052[esp+564]
  000e6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e8	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  000eb	50		 push	 eax
  000ec	ff d2		 call	 edx
$LN2@CreateLink:

; 142  : 
; 143  : 					PropVariantClear (&propVariant);

  000ee	8d 44 24 18	 lea	 eax, DWORD PTR _propVariant$134060[esp+564]
  000f2	50		 push	 eax
  000f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PropVariantClear@4
$LN3@CreateLink:

; 144  : 				}
; 145  : 
; 146  : 				propStore->Release();

  000f9	8b 44 24 10	 mov	 eax, DWORD PTR _propStore$134052[esp+564]
  000fd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ff	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00102	50		 push	 eax
  00103	ff d2		 call	 edx
$LN4@CreateLink:

; 147  : 			}
; 148  : 		}
; 149  : 
; 150  : 		/* Query IShellLink for the IPersistFile interface for saving
; 151  : 		   the shortcut in persistent storage.  */
; 152  : 		hres = psl->QueryInterface (IID_IPersistFile,
; 153  : 						    (void **) &ppf);

  00105	8b 44 24 0c	 mov	 eax, DWORD PTR _psl$[esp+564]
  00109	8b 08		 mov	 ecx, DWORD PTR [eax]
  0010b	8d 54 24 14	 lea	 edx, DWORD PTR _ppf$134050[esp+564]
  0010f	52		 push	 edx
  00110	68 00 00 00 00	 push	 OFFSET _IID_IPersistFile
  00115	50		 push	 eax
  00116	8b 01		 mov	 eax, DWORD PTR [ecx]
  00118	ff d0		 call	 eax
  0011a	8b f0		 mov	 esi, eax

; 154  : 
; 155  : 		if (SUCCEEDED (hres))

  0011c	85 f6		 test	 esi, esi
  0011e	7c 38		 jl	 SHORT $LN1@CreateLink

; 156  : 		{
; 157  : 			wchar_t wsz[TC_MAX_PATH];
; 158  : 
; 159  : 			/* Ensure that the string is ANSI.  */
; 160  : 			MultiByteToWideChar (CP_ACP, 0, lpszPathLink, -1,
; 161  : 					     wsz, sizeof(wsz) / sizeof(wsz[0]));

  00120	68 04 01 00 00	 push	 260			; 00000104H
  00125	8d 4c 24 2c	 lea	 ecx, DWORD PTR _wsz$134069[esp+568]
  00129	51		 push	 ecx
  0012a	6a ff		 push	 -1
  0012c	53		 push	 ebx
  0012d	6a 00		 push	 0
  0012f	6a 00		 push	 0
  00131	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 162  : 
; 163  : 			/* Save the link by calling IPersistFile::Save.  */
; 164  : 			hres = ppf->Save (wsz, TRUE);

  00137	8b 44 24 14	 mov	 eax, DWORD PTR _ppf$134050[esp+564]
  0013b	8b 10		 mov	 edx, DWORD PTR [eax]
  0013d	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  00140	6a 01		 push	 1
  00142	8d 4c 24 2c	 lea	 ecx, DWORD PTR _wsz$134069[esp+568]
  00146	51		 push	 ecx
  00147	50		 push	 eax
  00148	ff d2		 call	 edx
  0014a	8b f0		 mov	 esi, eax

; 165  : 			ppf->Release ();

  0014c	8b 44 24 14	 mov	 eax, DWORD PTR _ppf$134050[esp+564]
  00150	8b 08		 mov	 ecx, DWORD PTR [eax]
  00152	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00155	50		 push	 eax
  00156	ff d2		 call	 edx
$LN1@CreateLink:

; 166  : 		}
; 167  : 		psl->Release ();

  00158	8b 44 24 0c	 mov	 eax, DWORD PTR _psl$[esp+564]
  0015c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0015e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00161	50		 push	 eax
  00162	ff d2		 call	 edx

; 168  : 	}
; 169  : 	return hres;

  00164	8b c6		 mov	 eax, esi
$LN6@CreateLink:

; 170  : }

  00166	8b 8c 24 30 02
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+564]
  0016d	5f		 pop	 edi
  0016e	5e		 pop	 esi
  0016f	5b		 pop	 ebx
  00170	33 cc		 xor	 ecx, esp
  00172	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00177	81 c4 28 02 00
	00		 add	 esp, 552		; 00000228H
  0017d	c3		 ret	 0
_CreateLink ENDP
_TEXT	ENDS
PUBLIC	??_C@_02GBOHKKID@?1u?$AA@			; `string'
PUBLIC	??_C@_0BF@NFLEFHK@CipherShed?9Setup?4exe?$AA@	; `string'
PUBLIC	??_C@_0BL@MKLFJBBF@?$FLInternetShortcut?$FN?6URL?$DN?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_01NOFIACDB@w?$AA@				; `string'
PUBLIC	??_C@_0BD@KJOFIBFE@CANT_CREATE_FOLDER?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_DoShortcutsInstall
EXTRN	_fclose:PROC
EXTRN	_CheckFileStreamWriteErrors:PROC
EXTRN	_fprintf:PROC
EXTRN	_fopen:PROC
EXTRN	_mkfulldir:PROC
;	COMDAT ??_C@_02GBOHKKID@?1u?$AA@
CONST	SEGMENT
??_C@_02GBOHKKID@?1u?$AA@ DB '/u', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NFLEFHK@CipherShed?9Setup?4exe?$AA@
CONST	SEGMENT
??_C@_0BF@NFLEFHK@CipherShed?9Setup?4exe?$AA@ DB 'CipherShed-Setup.exe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MKLFJBBF@?$FLInternetShortcut?$FN?6URL?$DN?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BL@MKLFJBBF@?$FLInternetShortcut?$FN?6URL?$DN?$CFs?6?$AA@ DB '[Int'
	DB	'ernetShortcut]', 0aH, 'URL=%s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w?$AA@
CONST	SEGMENT
??_C@_01NOFIACDB@w?$AA@ DB 'w', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KJOFIBFE@CANT_CREATE_FOLDER?$AA@
CONST	SEGMENT
??_C@_0BD@KJOFIBFE@CANT_CREATE_FOLDER?$AA@ DB 'CANT_CREATE_FOLDER', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _DoShortcutsInstall
_TEXT	SEGMENT
_i$138644 = -1832					; size = 4
_bOK$ = -1828						; size = 4
_szTmp2$ = -1824					; size = 260
_szLinkDir$ = -1564					; size = 260
_szTmp$ = -1304						; size = 260
_szDir$ = -1044						; size = 260
_szTmp3$ = -784						; size = 260
_szTmp$134726 = -524					; size = 520
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_szDestDir$ = 12					; size = 4
_bProgGroup$ = 16					; size = 4
_bDesktopIcon$ = 20					; size = 4
_DoShortcutsInstall PROC				; COMDAT

; 1475 : {

  00000	81 ec 28 07 00
	00		 sub	 esp, 1832		; 00000728H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 24 07
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1832], eax
  00014	53		 push	 ebx
  00015	8b 9c 24 30 07
	00 00		 mov	 ebx, DWORD PTR _hwndDlg$[esp+1832]
  0001c	56		 push	 esi

; 1476 : 	char szLinkDir[TC_MAX_PATH], szDir[TC_MAX_PATH];
; 1477 : 	char szTmp[TC_MAX_PATH], szTmp2[TC_MAX_PATH], szTmp3[TC_MAX_PATH];
; 1478 : 	BOOL bSlash, bOK = FALSE;
; 1479 : 	HRESULT hOle;
; 1480 : 	int x;
; 1481 : 
; 1482 : 	if (bProgGroup == FALSE && bDesktopIcon == FALSE)

  0001d	8b b4 24 3c 07
	00 00		 mov	 esi, DWORD PTR _bProgGroup$[esp+1836]
  00024	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _bOK$[esp+1840], 0
  0002c	85 f6		 test	 esi, esi
  0002e	75 23		 jne	 SHORT $LN51@DoShortcut@2
  00030	39 b4 24 40 07
	00 00		 cmp	 DWORD PTR _bDesktopIcon$[esp+1836], esi
  00037	75 1a		 jne	 SHORT $LN51@DoShortcut@2

; 1483 : 		return TRUE;

  00039	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx

; 1589 : 
; 1590 : 	return bOK;
; 1591 : }

  0003e	8b 8c 24 24 07
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1832]
  00045	33 cc		 xor	 ecx, esp
  00047	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004c	81 c4 28 07 00
	00		 add	 esp, 1832		; 00000728H
  00052	c3		 ret	 0
$LN51@DoShortcut@2:

; 1484 : 
; 1485 : 	hOle = OleInitialize (NULL);

  00053	6a 00		 push	 0
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OleInitialize@4

; 1486 : 
; 1487 : 	GetProgramPath (hwndDlg, szLinkDir);

  0005b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bForAllUsers, 0
  00062	74 09		 je	 SHORT $LN32@DoShortcut@2
  00064	8d 44 24 08	 lea	 eax, DWORD PTR _i$138644[esp+1840]
  00068	50		 push	 eax
  00069	6a 17		 push	 23			; 00000017H
  0006b	eb 07		 jmp	 SHORT $LN56@DoShortcut@2
$LN32@DoShortcut@2:
  0006d	8d 4c 24 08	 lea	 ecx, DWORD PTR _i$138644[esp+1840]
  00071	51		 push	 ecx
  00072	6a 02		 push	 2
$LN56@DoShortcut@2:
  00074	53		 push	 ebx
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SHGetSpecialFolderLocation@12
  0007b	8b 44 24 08	 mov	 eax, DWORD PTR _i$138644[esp+1840]
  0007f	8d 94 24 14 01
	00 00		 lea	 edx, DWORD PTR _szLinkDir$[esp+1840]
  00086	52		 push	 edx
  00087	50		 push	 eax
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SHGetPathFromIDListA@8

; 1488 : 
; 1489 : 	x = strlen (szLinkDir);

  0008e	8d 84 24 14 01
	00 00		 lea	 eax, DWORD PTR _szLinkDir$[esp+1840]
  00095	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL48@DoShortcut@2:
  00098	8a 08		 mov	 cl, BYTE PTR [eax]
  0009a	40		 inc	 eax
  0009b	84 c9		 test	 cl, cl
  0009d	75 f9		 jne	 SHORT $LL48@DoShortcut@2
  0009f	2b c2		 sub	 eax, edx

; 1490 : 	if (szLinkDir[x - 1] == '\\')

  000a1	80 bc 04 13 01
	00 00 5c	 cmp	 BYTE PTR _szLinkDir$[esp+eax+1839], 92 ; 0000005cH

; 1491 : 		bSlash = TRUE;
; 1492 : 	else

  000a9	74 1a		 je	 SHORT $LN52@DoShortcut@2

; 1493 : 		bSlash = FALSE;
; 1494 : 
; 1495 : 	if (bSlash == FALSE)
; 1496 : 		strcat_s (szLinkDir, sizeof(szLinkDir), "\\");

  000ab	68 00 00 00 00	 push	 OFFSET ??_C@_01KICIPPFI@?2?$AA@
  000b0	8d 8c 24 18 01
	00 00		 lea	 ecx, DWORD PTR _szLinkDir$[esp+1844]
  000b7	68 04 01 00 00	 push	 260			; 00000104H
  000bc	51		 push	 ecx
  000bd	e8 00 00 00 00	 call	 _strcat_s
  000c2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN52@DoShortcut@2:
  000c5	55		 push	 ebp
  000c6	57		 push	 edi

; 1497 : 
; 1498 : 	strcat_s (szLinkDir, sizeof(szLinkDir), "CipherShed");

  000c7	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FEEFGEIL@CipherShed?$AA@
  000cc	8d 94 24 20 01
	00 00		 lea	 edx, DWORD PTR _szLinkDir$[esp+1852]
  000d3	68 04 01 00 00	 push	 260			; 00000104H
  000d8	52		 push	 edx
  000d9	e8 00 00 00 00	 call	 _strcat_s

; 1499 : 
; 1500 : 	strcpy (szDir, szDestDir);

  000de	8b ac 24 4c 07
	00 00		 mov	 ebp, DWORD PTR _szDestDir$[esp+1856]
  000e5	8d bc 24 30 03
	00 00		 lea	 edi, DWORD PTR _szDir$[esp+1860]
  000ec	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ef	8b c5		 mov	 eax, ebp
  000f1	2b fd		 sub	 edi, ebp
$LL29@DoShortcut@2:
  000f3	8a 08		 mov	 cl, BYTE PTR [eax]
  000f5	88 0c 07	 mov	 BYTE PTR [edi+eax], cl
  000f8	40		 inc	 eax
  000f9	84 c9		 test	 cl, cl
  000fb	75 f6		 jne	 SHORT $LL29@DoShortcut@2

; 1501 : 	x = strlen (szDestDir);

  000fd	8b c5		 mov	 eax, ebp
  000ff	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL49@DoShortcut@2:
  00102	8a 08		 mov	 cl, BYTE PTR [eax]
  00104	40		 inc	 eax
  00105	84 c9		 test	 cl, cl
  00107	75 f9		 jne	 SHORT $LL49@DoShortcut@2
  00109	2b c2		 sub	 eax, edx

; 1502 : 	if (szDestDir[x - 1] == '\\')

  0010b	80 7c 28 ff 5c	 cmp	 BYTE PTR [eax+ebp-1], 92 ; 0000005cH

; 1503 : 		bSlash = TRUE;
; 1504 : 	else

  00110	74 1a		 je	 SHORT $LN20@DoShortcut@2

; 1505 : 		bSlash = FALSE;
; 1506 : 
; 1507 : 	if (bSlash == FALSE)
; 1508 : 		strcat_s (szDir, sizeof(szDir), "\\");

  00112	68 00 00 00 00	 push	 OFFSET ??_C@_01KICIPPFI@?2?$AA@
  00117	8d 84 24 28 03
	00 00		 lea	 eax, DWORD PTR _szDir$[esp+1852]
  0011e	68 04 01 00 00	 push	 260			; 00000104H
  00123	50		 push	 eax
  00124	e8 00 00 00 00	 call	 _strcat_s
  00129	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN20@DoShortcut@2:

; 1509 : 
; 1510 : 	if (bProgGroup)

  0012c	85 f6		 test	 esi, esi
  0012e	0f 84 25 02 00
	00		 je	 $LN53@DoShortcut@2

; 1511 : 	{
; 1512 : 		FILE *f;
; 1513 : 
; 1514 : 		if (mkfulldir (szLinkDir, TRUE) != 0)

  00134	8d 8c 24 1c 01
	00 00		 lea	 ecx, DWORD PTR _szLinkDir$[esp+1848]
  0013b	6a 01		 push	 1
  0013d	51		 push	 ecx
  0013e	e8 00 00 00 00	 call	 _mkfulldir
  00143	83 c4 08	 add	 esp, 8
  00146	85 c0		 test	 eax, eax
  00148	74 63		 je	 SHORT $LN17@DoShortcut@2

; 1515 : 		{
; 1516 : 			if (mkfulldir (szLinkDir, FALSE) != 0)

  0014a	8d 94 24 1c 01
	00 00		 lea	 edx, DWORD PTR _szLinkDir$[esp+1848]
  00151	6a 00		 push	 0
  00153	52		 push	 edx
  00154	e8 00 00 00 00	 call	 _mkfulldir
  00159	83 c4 08	 add	 esp, 8
  0015c	85 c0		 test	 eax, eax
  0015e	74 4d		 je	 SHORT $LN17@DoShortcut@2

; 1517 : 			{
; 1518 : 				wchar_t szTmp[TC_MAX_PATH];
; 1519 : 
; 1520 : 				handleWin32Error (hwndDlg);

  00160	53		 push	 ebx
  00161	e8 00 00 00 00	 call	 _handleWin32Error
  00166	83 c4 04	 add	 esp, 4

; 1521 : 				wsprintfW (szTmp, GetString ("CANT_CREATE_FOLDER"), szLinkDir);

  00169	8d 84 24 1c 01
	00 00		 lea	 eax, DWORD PTR _szLinkDir$[esp+1848]
  00170	50		 push	 eax
  00171	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KJOFIBFE@CANT_CREATE_FOLDER?$AA@
  00176	e8 00 00 00 00	 call	 _GetString
  0017b	83 c4 04	 add	 esp, 4
  0017e	50		 push	 eax
  0017f	8d 8c 24 34 05
	00 00		 lea	 ecx, DWORD PTR _szTmp$134726[esp+1856]
  00186	51		 push	 ecx
  00187	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfW

; 1522 : 				MessageBoxW (hwndDlg, szTmp, lpszTitle, MB_ICONHAND);

  0018d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lpszTitle
  00193	83 c4 0c	 add	 esp, 12			; 0000000cH
  00196	6a 10		 push	 16			; 00000010H
  00198	52		 push	 edx
  00199	8d 84 24 34 05
	00 00		 lea	 eax, DWORD PTR _szTmp$134726[esp+1856]
  001a0	50		 push	 eax
  001a1	53		 push	 ebx
  001a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
  001a8	e9 a0 02 00 00	 jmp	 $error$134728
$LN17@DoShortcut@2:

; 1523 : 				goto error;
; 1524 : 			}
; 1525 : 		}
; 1526 : 
; 1527 : 		snprintf (szTmp, sizeof(szTmp), "%s%s", szDir, "CipherShed.exe");

  001ad	68 00 00 00 00	 push	 OFFSET ??_C@_0P@KEOPEMDF@CipherShed?4exe?$AA@
  001b2	8d 8c 24 28 03
	00 00		 lea	 ecx, DWORD PTR _szDir$[esp+1852]
  001b9	51		 push	 ecx
  001ba	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  001bf	8d 94 24 2c 02
	00 00		 lea	 edx, DWORD PTR _szTmp$[esp+1860]
  001c6	68 04 01 00 00	 push	 260			; 00000104H
  001cb	52		 push	 edx
  001cc	e8 00 00 00 00	 call	 _sprintf_s

; 1528 : 		snprintf (szTmp2, sizeof(szTmp2), "%s%s", szLinkDir, "\\CipherShed.lnk");

  001d1	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@LNMKCON@?2CipherShed?4lnk?$AA@
  001d6	8d 84 24 34 01
	00 00		 lea	 eax, DWORD PTR _szLinkDir$[esp+1872]
  001dd	50		 push	 eax
  001de	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  001e3	8d 4c 24 38	 lea	 ecx, DWORD PTR _szTmp2$[esp+1880]
  001e7	68 04 01 00 00	 push	 260			; 00000104H
  001ec	51		 push	 ecx
  001ed	e8 00 00 00 00	 call	 _sprintf_s

; 1529 : 
; 1530 : 		IconMessage (hwndDlg, szTmp2);

  001f2	8d 54 24 40	 lea	 edx, DWORD PTR _szTmp2$[esp+1888]
  001f6	52		 push	 edx
  001f7	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CFAAPOHD@ADDING_ICON?$AA@
  001fc	53		 push	 ebx
  001fd	e8 00 00 00 00	 call	 _StatusMessageParam

; 1531 : 		if (CreateLink (szTmp, "", szTmp2) != S_OK)

  00202	8d 44 24 4c	 lea	 eax, DWORD PTR _szTmp2$[esp+1900]
  00206	50		 push	 eax
  00207	8d 8c 24 58 02
	00 00		 lea	 ecx, DWORD PTR _szTmp$[esp+1904]
  0020e	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00213	51		 push	 ecx
  00214	e8 00 00 00 00	 call	 _CreateLink
  00219	83 c4 40	 add	 esp, 64			; 00000040H
  0021c	85 c0		 test	 eax, eax
  0021e	0f 85 29 02 00
	00		 jne	 $error$134728

; 1532 : 			goto error;
; 1533 : 
; 1534 : 		snprintf (szTmp2, sizeof(szTmp2), "%s%s", szLinkDir, "\\CipherShed Website.url");

  00224	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@GABNFKIJ@?2CipherShed?5Website?4url?$AA@
  00229	8d 94 24 20 01
	00 00		 lea	 edx, DWORD PTR _szLinkDir$[esp+1852]
  00230	52		 push	 edx
  00231	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  00236	8d 44 24 24	 lea	 eax, DWORD PTR _szTmp2$[esp+1860]
  0023a	68 04 01 00 00	 push	 260			; 00000104H
  0023f	50		 push	 eax
  00240	e8 00 00 00 00	 call	 _sprintf_s

; 1535 : 		IconMessage (hwndDlg, szTmp2);

  00245	8d 4c 24 2c	 lea	 ecx, DWORD PTR _szTmp2$[esp+1868]
  00249	51		 push	 ecx
  0024a	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CFAAPOHD@ADDING_ICON?$AA@
  0024f	53		 push	 ebx
  00250	e8 00 00 00 00	 call	 _StatusMessageParam

; 1536 : 		f = fopen (szTmp2, "w");

  00255	8d 54 24 38	 lea	 edx, DWORD PTR _szTmp2$[esp+1880]
  00259	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  0025e	52		 push	 edx
  0025f	e8 00 00 00 00	 call	 _fopen
  00264	8b f0		 mov	 esi, eax
  00266	83 c4 28	 add	 esp, 40			; 00000028H

; 1537 : 		if (f)

  00269	85 f6		 test	 esi, esi
  0026b	0f 84 dc 01 00
	00		 je	 $error$134728

; 1538 : 		{
; 1539 : 			fprintf (f, "[InternetShortcut]\nURL=%s\n", TC_HOMEPAGE);

  00271	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@INHGIDBI@https?3?1?1ciphershed?4org?1?$AA@
  00276	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@MKLFJBBF@?$FLInternetShortcut?$FN?6URL?$DN?$CFs?6?$AA@
  0027b	56		 push	 esi
  0027c	e8 00 00 00 00	 call	 _fprintf

; 1540 : 
; 1541 : 			CheckFileStreamWriteErrors (f, szTmp2);

  00281	8d 44 24 24	 lea	 eax, DWORD PTR _szTmp2$[esp+1860]
  00285	50		 push	 eax
  00286	56		 push	 esi
  00287	e8 00 00 00 00	 call	 _CheckFileStreamWriteErrors

; 1542 : 			fclose (f);

  0028c	56		 push	 esi
  0028d	e8 00 00 00 00	 call	 _fclose

; 1543 : 		}
; 1544 : 		else
; 1545 : 			goto error;
; 1546 : 
; 1547 : 		snprintf (szTmp, sizeof(szTmp), "%s%s", szDir, "CipherShed-Setup.exe");

  00292	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@NFLEFHK@CipherShed?9Setup?4exe?$AA@
  00297	8d 8c 24 40 03
	00 00		 lea	 ecx, DWORD PTR _szDir$[esp+1876]
  0029e	51		 push	 ecx
  0029f	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  002a4	8d 94 24 44 02
	00 00		 lea	 edx, DWORD PTR _szTmp$[esp+1884]
  002ab	68 04 01 00 00	 push	 260			; 00000104H
  002b0	52		 push	 edx
  002b1	e8 00 00 00 00	 call	 _sprintf_s

; 1548 : 		snprintf (szTmp2, sizeof(szTmp2), "%s%s", szLinkDir, "\\Uninstall CipherShed.lnk");

  002b6	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@EABHBBNJ@?2Uninstall?5CipherShed?4lnk?$AA@
  002bb	8d 84 24 4c 01
	00 00		 lea	 eax, DWORD PTR _szLinkDir$[esp+1896]
  002c2	50		 push	 eax
  002c3	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  002c8	8d 4c 24 50	 lea	 ecx, DWORD PTR _szTmp2$[esp+1904]
  002cc	68 04 01 00 00	 push	 260			; 00000104H
  002d1	51		 push	 ecx
  002d2	e8 00 00 00 00	 call	 _sprintf_s

; 1549 : 		strcpy (szTmp3, "/u");

  002d7	66 8b 15 00 00
	00 00		 mov	 dx, WORD PTR ??_C@_02GBOHKKID@?1u?$AA@
  002de	a0 02 00 00 00	 mov	 al, BYTE PTR ??_C@_02GBOHKKID@?1u?$AA@+2
  002e3	83 c4 40	 add	 esp, 64			; 00000040H

; 1550 : 
; 1551 : 		IconMessage (hwndDlg, szTmp2);

  002e6	8d 4c 24 18	 lea	 ecx, DWORD PTR _szTmp2$[esp+1848]
  002ea	51		 push	 ecx
  002eb	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CFAAPOHD@ADDING_ICON?$AA@
  002f0	53		 push	 ebx
  002f1	66 89 94 24 34
	04 00 00	 mov	 WORD PTR _szTmp3$[esp+1860], dx
  002f9	88 84 24 36 04
	00 00		 mov	 BYTE PTR _szTmp3$[esp+1862], al
  00300	e8 00 00 00 00	 call	 _StatusMessageParam

; 1552 : 		if (CreateLink (szTmp, szTmp3, szTmp2) != S_OK)

  00305	8d 54 24 24	 lea	 edx, DWORD PTR _szTmp2$[esp+1860]
  00309	52		 push	 edx
  0030a	8d 84 24 38 04
	00 00		 lea	 eax, DWORD PTR _szTmp3$[esp+1864]
  00311	50		 push	 eax
  00312	8d 8c 24 34 02
	00 00		 lea	 ecx, DWORD PTR _szTmp$[esp+1868]
  00319	51		 push	 ecx
  0031a	e8 00 00 00 00	 call	 _CreateLink
  0031f	83 c4 18	 add	 esp, 24			; 00000018H
  00322	85 c0		 test	 eax, eax
  00324	0f 85 23 01 00
	00		 jne	 $error$134728

; 1553 : 			goto error;
; 1554 : 
; 1555 : 		snprintf (szTmp2, sizeof(szTmp2), "%s%s", szLinkDir, "\\CipherShed User's Guide.lnk");

  0032a	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@DGJJNBJI@?2CipherShed?5User?8s?5Guide?4lnk?$AA@
  0032f	8d 94 24 20 01
	00 00		 lea	 edx, DWORD PTR _szLinkDir$[esp+1852]
  00336	52		 push	 edx
  00337	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  0033c	8d 44 24 24	 lea	 eax, DWORD PTR _szTmp2$[esp+1860]
  00340	68 04 01 00 00	 push	 260			; 00000104H
  00345	50		 push	 eax
  00346	e8 00 00 00 00	 call	 _sprintf_s
  0034b	83 c4 14	 add	 esp, 20			; 00000014H

; 1556 : 		DeleteFile (szTmp2);

  0034e	8d 4c 24 18	 lea	 ecx, DWORD PTR _szTmp2$[esp+1848]
  00352	51		 push	 ecx
  00353	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteFileA@4
$LN53@DoShortcut@2:

; 1557 : 	}
; 1558 : 
; 1559 : 	if (bDesktopIcon)

  00359	83 bc 24 48 07
	00 00 00	 cmp	 DWORD PTR _bDesktopIcon$[esp+1844], 0
  00361	0f 84 de 00 00
	00		 je	 $LN2@DoShortcut@2

; 1560 : 	{
; 1561 : 		strcpy (szDir, szDestDir);

  00367	8b c5		 mov	 eax, ebp
  00369	8d a4 24 00 00
	00 00		 npad	 7
$LL30@DoShortcut@2:
  00370	8a 08		 mov	 cl, BYTE PTR [eax]
  00372	88 0c 07	 mov	 BYTE PTR [edi+eax], cl
  00375	40		 inc	 eax
  00376	84 c9		 test	 cl, cl
  00378	75 f6		 jne	 SHORT $LL30@DoShortcut@2

; 1562 : 		x = strlen (szDestDir);

  0037a	8b c5		 mov	 eax, ebp
  0037c	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0037f	90		 npad	 1
$LL50@DoShortcut@2:
  00380	8a 08		 mov	 cl, BYTE PTR [eax]
  00382	40		 inc	 eax
  00383	84 c9		 test	 cl, cl
  00385	75 f9		 jne	 SHORT $LL50@DoShortcut@2
  00387	2b c2		 sub	 eax, edx

; 1563 : 		if (szDestDir[x - 1] == '\\')

  00389	80 7c 28 ff 5c	 cmp	 BYTE PTR [eax+ebp-1], 92 ; 0000005cH

; 1564 : 			bSlash = TRUE;
; 1565 : 		else

  0038e	74 1a		 je	 SHORT $LN55@DoShortcut@2

; 1566 : 			bSlash = FALSE;
; 1567 : 
; 1568 : 		if (bSlash == FALSE)
; 1569 : 			strcat_s (szDir, sizeof(szDir), "\\");

  00390	68 00 00 00 00	 push	 OFFSET ??_C@_01KICIPPFI@?2?$AA@
  00395	8d 94 24 28 03
	00 00		 lea	 edx, DWORD PTR _szDir$[esp+1852]
  0039c	68 04 01 00 00	 push	 260			; 00000104H
  003a1	52		 push	 edx
  003a2	e8 00 00 00 00	 call	 _strcat_s
  003a7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN55@DoShortcut@2:

; 1570 : 
; 1571 : 		if (bForAllUsers)

  003aa	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bForAllUsers, 0

; 1572 : 			SHGetSpecialFolderPath (hwndDlg, szLinkDir, CSIDL_COMMON_DESKTOPDIRECTORY, 0);

  003b1	6a 00		 push	 0
  003b3	74 0c		 je	 SHORT $LN4@DoShortcut@2
  003b5	6a 19		 push	 25			; 00000019H
  003b7	8d 84 24 24 01
	00 00		 lea	 eax, DWORD PTR _szLinkDir$[esp+1856]
  003be	50		 push	 eax

; 1573 : 		else

  003bf	eb 0a		 jmp	 SHORT $LN57@DoShortcut@2
$LN4@DoShortcut@2:

; 1574 : 			SHGetSpecialFolderPath (hwndDlg, szLinkDir, CSIDL_DESKTOPDIRECTORY, 0);

  003c1	6a 10		 push	 16			; 00000010H
  003c3	8d 8c 24 24 01
	00 00		 lea	 ecx, DWORD PTR _szLinkDir$[esp+1856]
  003ca	51		 push	 ecx
$LN57@DoShortcut@2:
  003cb	53		 push	 ebx
  003cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SHGetSpecialFolderPathA@16

; 1575 : 
; 1576 : 		snprintf (szTmp, sizeof(szTmp), "%s%s", szDir, "CipherShed.exe");

  003d2	68 00 00 00 00	 push	 OFFSET ??_C@_0P@KEOPEMDF@CipherShed?4exe?$AA@
  003d7	8d 94 24 28 03
	00 00		 lea	 edx, DWORD PTR _szDir$[esp+1852]
  003de	52		 push	 edx
  003df	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  003e4	8d 84 24 2c 02
	00 00		 lea	 eax, DWORD PTR _szTmp$[esp+1860]
  003eb	68 04 01 00 00	 push	 260			; 00000104H
  003f0	50		 push	 eax
  003f1	e8 00 00 00 00	 call	 _sprintf_s

; 1577 : 		snprintf (szTmp2, sizeof(szTmp2), "%s%s", szLinkDir, "\\CipherShed.lnk");

  003f6	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@LNMKCON@?2CipherShed?4lnk?$AA@
  003fb	8d 8c 24 34 01
	00 00		 lea	 ecx, DWORD PTR _szLinkDir$[esp+1872]
  00402	51		 push	 ecx
  00403	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  00408	8d 54 24 38	 lea	 edx, DWORD PTR _szTmp2$[esp+1880]
  0040c	68 04 01 00 00	 push	 260			; 00000104H
  00411	52		 push	 edx
  00412	e8 00 00 00 00	 call	 _sprintf_s

; 1578 : 
; 1579 : 		IconMessage (hwndDlg, szTmp2);

  00417	8d 44 24 40	 lea	 eax, DWORD PTR _szTmp2$[esp+1888]
  0041b	50		 push	 eax
  0041c	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CFAAPOHD@ADDING_ICON?$AA@
  00421	53		 push	 ebx
  00422	e8 00 00 00 00	 call	 _StatusMessageParam

; 1580 : 
; 1581 : 		if (CreateLink (szTmp, "", szTmp2) != S_OK)

  00427	8d 4c 24 4c	 lea	 ecx, DWORD PTR _szTmp2$[esp+1900]
  0042b	51		 push	 ecx
  0042c	8d 94 24 58 02
	00 00		 lea	 edx, DWORD PTR _szTmp$[esp+1904]
  00433	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00438	52		 push	 edx
  00439	e8 00 00 00 00	 call	 _CreateLink
  0043e	83 c4 40	 add	 esp, 64			; 00000040H
  00441	85 c0		 test	 eax, eax
  00443	75 08		 jne	 SHORT $error$134728
$LN2@DoShortcut@2:

; 1582 : 			goto error;
; 1583 : 	}
; 1584 : 
; 1585 : 	bOK = TRUE;

  00445	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR _bOK$[esp+1848], 1
$error$134728:

; 1586 : 
; 1587 : error:
; 1588 : 	OleUninitialize ();

  0044d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OleUninitialize@0

; 1589 : 
; 1590 : 	return bOK;
; 1591 : }

  00453	8b 8c 24 34 07
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1848]
  0045a	8b 44 24 14	 mov	 eax, DWORD PTR _bOK$[esp+1848]
  0045e	5f		 pop	 edi
  0045f	5d		 pop	 ebp
  00460	5e		 pop	 esi
  00461	5b		 pop	 ebx
  00462	33 cc		 xor	 ecx, esp
  00464	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00469	81 c4 28 07 00
	00		 add	 esp, 1832		; 00000728H
  0046f	c3		 ret	 0
_DoShortcutsInstall ENDP
_TEXT	ENDS
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1651 : 		return (_Myptr());

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00004	72 04		 jb	 SHORT $LN5@c_str
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1652 : 		}

  00009	c3		 ret	 0

; 1651 : 		return (_Myptr());

$LN5@c_str:
  0000a	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 1652 : 		}

  0000d	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
; Function compile flags: /Ogtpy
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
tv206 = 12						; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT
; _this$ = ecx

; 1770 : 		{	// look for [_Ptr, _Ptr + _Count) beginnng at or after _Off

  00000	51		 push	 ecx

; 1771 : 
; 1772 :  #if _HAS_ITERATOR_DEBUGGING
; 1773 : 		if (_Count != 0)
; 1774 : 			_DEBUG_POINTER(_Ptr);
; 1775 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1776 : 
; 1777 : 		if (_Count == 0 && _Off <= _Mysize)

  00001	8b 54 24 10	 mov	 edx, DWORD PTR __Count$[esp]
  00005	8b 44 24 0c	 mov	 eax, DWORD PTR __Off$[esp]
  00009	89 0c 24	 mov	 DWORD PTR _this$[esp+4], ecx
  0000c	85 d2		 test	 edx, edx
  0000e	75 09		 jne	 SHORT $LN6@find
  00010	3b 41 14	 cmp	 eax, DWORD PTR [ecx+20]

; 1778 : 			return (_Off);	// null string always matches (if inside string)

  00013	0f 86 86 00 00
	00		 jbe	 $LN7@find
$LN6@find:
  00019	53		 push	 ebx
  0001a	55		 push	 ebp
  0001b	56		 push	 esi
  0001c	57		 push	 edi

; 1779 : 
; 1780 : 		size_type _Nm;
; 1781 : 		if (_Off < _Mysize && _Count <= (_Nm = _Mysize - _Off))

  0001d	8b 79 14	 mov	 edi, DWORD PTR [ecx+20]
  00020	3b c7		 cmp	 eax, edi
  00022	73 74		 jae	 SHORT $LN2@find
  00024	2b f8		 sub	 edi, eax
  00026	3b d7		 cmp	 edx, edi
  00028	77 6e		 ja	 SHORT $LN2@find

; 1782 : 			{	// room for match, look for it
; 1783 : 			const _Elem *_Uptr, *_Vptr;
; 1784 : 			for (_Nm -= _Count - 1, _Vptr = _Myptr() + _Off;

  0002a	be 01 00 00 00	 mov	 esi, 1
  0002f	2b f2		 sub	 esi, edx
  00031	03 fe		 add	 edi, esi
  00033	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00037	72 0b		 jb	 SHORT $LN11@find
  00039	83 c1 04	 add	 ecx, 4
  0003c	89 4c 24 1c	 mov	 DWORD PTR tv206[esp+16], ecx
  00040	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00042	eb 07		 jmp	 SHORT $LN12@find
$LN11@find:
  00044	83 c1 04	 add	 ecx, 4
  00047	89 4c 24 1c	 mov	 DWORD PTR tv206[esp+16], ecx
$LN12@find:

; 1785 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1786 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)

  0004b	8b 6c 24 18	 mov	 ebp, DWORD PTR __Ptr$[esp+16]
  0004f	8d 1c 01	 lea	 ebx, DWORD PTR [ecx+eax]
  00052	0f be 45 00	 movsx	 eax, BYTE PTR [ebp]
  00056	57		 push	 edi
  00057	50		 push	 eax
  00058	53		 push	 ebx
  00059	e8 00 00 00 00	 call	 _memchr
  0005e	8b f0		 mov	 esi, eax
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH
  00063	85 f6		 test	 esi, esi
  00065	74 31		 je	 SHORT $LN2@find
$LL4@find:

; 1787 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)

  00067	8b 4c 24 20	 mov	 ecx, DWORD PTR __Count$[esp+16]
  0006b	51		 push	 ecx
  0006c	55		 push	 ebp
  0006d	56		 push	 esi
  0006e	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH
  00076	85 c0		 test	 eax, eax
  00078	74 29		 je	 SHORT $LN20@find
  0007a	0f be 55 00	 movsx	 edx, BYTE PTR [ebp]
  0007e	2b de		 sub	 ebx, esi
  00080	8d 7c 1f ff	 lea	 edi, DWORD PTR [edi+ebx-1]
  00084	57		 push	 edi
  00085	52		 push	 edx
  00086	8d 5e 01	 lea	 ebx, DWORD PTR [esi+1]
  00089	53		 push	 ebx
  0008a	e8 00 00 00 00	 call	 _memchr
  0008f	8b f0		 mov	 esi, eax
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH
  00094	85 f6		 test	 esi, esi
  00096	75 cf		 jne	 SHORT $LL4@find
$LN2@find:
  00098	5f		 pop	 edi
  00099	5e		 pop	 esi
  0009a	5d		 pop	 ebp

; 1789 : 			}
; 1790 : 
; 1791 : 		return (npos);	// no match

  0009b	83 c8 ff	 or	 eax, -1
  0009e	5b		 pop	 ebx
$LN7@find:

; 1792 : 		}

  0009f	59		 pop	 ecx
  000a0	c2 0c 00	 ret	 12			; 0000000cH
$LN20@find:

; 1788 : 					return (_Uptr - _Myptr());	// found a match

  000a3	8b 44 24 10	 mov	 eax, DWORD PTR _this$[esp+20]
  000a7	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  000ab	8b 4c 24 1c	 mov	 ecx, DWORD PTR tv206[esp+16]
  000af	72 02		 jb	 SHORT $LN18@find
  000b1	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN18@find:
  000b3	5f		 pop	 edi
  000b4	8b c6		 mov	 eax, esi
  000b6	5e		 pop	 esi
  000b7	5d		 pop	 ebp
  000b8	2b c1		 sub	 eax, ecx
  000ba	5b		 pop	 ebx

; 1792 : 		}

  000bb	59		 pop	 ecx
  000bc	c2 0c 00	 ret	 12			; 0000000cH
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
PUBLIC	?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
; Function compile flags: /Ogtpy
;	COMDAT ?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator, COMDAT
; _this$ = ecx

; 2058 : 		return (_Mybase::_Alval);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 2059 : 		}

  00004	c2 04 00	 ret	 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
_TEXT	ENDS
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Ogtpy
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2114 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00004	8b 44 24 04	 mov	 eax, DWORD PTR __Newsize$[esp-4]
  00008	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  0000b	72 0a		 jb	 SHORT $LN5@Eos
  0000d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00010	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0

; 2115 : 		}

  00014	c2 04 00	 ret	 4

; 2114 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

$LN5@Eos:
  00017	c6 44 01 04 00	 mov	 BYTE PTR [ecx+eax+4], 0

; 2115 : 		}

  0001c	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Ogtpy
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2133 : 		{	// test if _Ptr points inside string

  00000	56		 push	 esi
  00001	57		 push	 edi

; 2134 : 		if (_Ptr == 0 || _Ptr < _Myptr() || _Myptr() + _Mysize <= _Ptr)

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR __Ptr$[esp+4]
  00006	85 ff		 test	 edi, edi
  00008	74 2c		 je	 SHORT $LN2@Inside
  0000a	8b 71 18	 mov	 esi, DWORD PTR [ecx+24]
  0000d	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00010	83 fe 10	 cmp	 esi, 16			; 00000010H
  00013	72 04		 jb	 SHORT $LN8@Inside
  00015	8b 10		 mov	 edx, DWORD PTR [eax]
  00017	eb 02		 jmp	 SHORT $LN9@Inside
$LN8@Inside:
  00019	8b d0		 mov	 edx, eax
$LN9@Inside:
  0001b	3b fa		 cmp	 edi, edx
  0001d	72 17		 jb	 SHORT $LN2@Inside
  0001f	83 fe 10	 cmp	 esi, 16			; 00000010H
  00022	72 02		 jb	 SHORT $LN12@Inside
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
$LN12@Inside:
  00026	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00029	03 c8		 add	 ecx, eax
  0002b	3b cf		 cmp	 ecx, edi
  0002d	76 07		 jbe	 SHORT $LN2@Inside
  0002f	5f		 pop	 edi

; 2136 : 		else
; 2137 : 			return (true);

  00030	b0 01		 mov	 al, 1
  00032	5e		 pop	 esi

; 2138 : 		}

  00033	c2 04 00	 ret	 4
$LN2@Inside:
  00036	5f		 pop	 edi

; 2135 : 			return (false);	// don't ask

  00037	32 c0		 xor	 al, al
  00039	5e		 pop	 esi

; 2138 : 		}

  0003a	c2 04 00	 ret	 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z PROC ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 472  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 473  : 		}

  00002	c2 04 00	 ret	 4
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z PROC ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 478  : 		{	// copy constructor

  00000	8b c1		 mov	 eax, ecx

; 479  : #if defined(_DEBUG)
; 480  : 		if (_Right._Myfirstiter == _IGNORE_MYITERLIST)
; 481  : 			{
; 482  : 			this->_Myfirstiter = _IGNORE_MYITERLIST;
; 483  : 			}
; 484  : #endif
; 485  : 		}

  00002	c2 04 00	 ret	 4
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1671 : 		size_type _Num = _Mybase::_Alval.max_size();
; 1672 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1673 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	6a 00		 push	 0
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>
  0000c	83 c4 08	 add	 esp, 8

; 146  : 		}

  0000f	c2 04 00	 ret	 4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
PUBLIC	??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ; std::_Traits_helper::move_s<std::char_traits<char> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\iosfwd
;	COMDAT ??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z PROC ; std::_Traits_helper::move_s<std::char_traits<char> >, COMDAT

; 616  : 		return move_s<_Traits>(_First1, _Size, _First2, _Count, _Char_traits_cat<_Traits>());

  00000	8b 44 24 10	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8b 4c 24 0c	 mov	 ecx, DWORD PTR __First2$[esp-4]
  00008	8b 54 24 08	 mov	 edx, DWORD PTR __Size$[esp-4]
  0000c	56		 push	 esi
  0000d	8b 74 24 08	 mov	 esi, DWORD PTR __First1$[esp]
  00011	50		 push	 eax
  00012	51		 push	 ecx
  00013	52		 push	 edx
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 _memmove_s
  0001a	83 c4 10	 add	 esp, 16			; 00000010H
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi

; 617  : 	}

  00020	c3		 ret	 0
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ENDP ; std::_Traits_helper::move_s<std::char_traits<char> >
_TEXT	ENDS
PUBLIC	??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ; std::_Traits_helper::copy_s<std::char_traits<char> >
; Function compile flags: /Ogtpy
;	COMDAT ??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z PROC ; std::_Traits_helper::copy_s<std::char_traits<char> >, COMDAT

; 589  : 		return copy_s<_Traits>(_First1, _Size, _First2, _Count, _Char_traits_cat<_Traits>());

  00000	8b 44 24 10	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8b 4c 24 0c	 mov	 ecx, DWORD PTR __First2$[esp-4]
  00008	8b 54 24 08	 mov	 edx, DWORD PTR __Size$[esp-4]
  0000c	56		 push	 esi
  0000d	8b 74 24 08	 mov	 esi, DWORD PTR __First1$[esp]
  00011	50		 push	 eax
  00012	51		 push	 ecx
  00013	52		 push	 edx
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 _memcpy_s
  0001a	83 c4 10	 add	 esp, 16			; 00000010H
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi

; 590  : 	}

  00020	c3		 ret	 0
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ENDP ; std::_Traits_helper::copy_s<std::char_traits<char> >
_TEXT	ENDS
EXTRN	__imp__CreateFileA@28:PROC
; Function compile flags: /Ogtpy
; File c:\home\public\desktop\projects\ciphershed.build\src\setup\setup.c
;	COMDAT ?IsFileInUse@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
?IsFileInUse@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; IsFileInUse, COMDAT
; _filePath$ = eax

; 287  : 	HANDLE useTestHandle = CreateFile (filePath.c_str(), GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);

  00000	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  00004	72 05		 jb	 SHORT $LN10@IsFileInUs
  00006	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00009	eb 03		 jmp	 SHORT $LN11@IsFileInUs
$LN10@IsFileInUs:
  0000b	83 c0 04	 add	 eax, 4
$LN11@IsFileInUs:
  0000e	6a 00		 push	 0
  00010	6a 00		 push	 0
  00012	6a 03		 push	 3
  00014	6a 00		 push	 0
  00016	6a 00		 push	 0
  00018	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  0001d	50		 push	 eax
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28

; 288  : 
; 289  : 	if (useTestHandle != INVALID_HANDLE_VALUE)

  00024	83 f8 ff	 cmp	 eax, -1
  00027	74 0a		 je	 SHORT $LN3@IsFileInUs

; 290  : 		CloseHandle (useTestHandle);

  00029	50		 push	 eax
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN1@IsFileInUs:

; 293  : 
; 294  : 	return FALSE;

  00030	33 c0		 xor	 eax, eax

; 295  : }

  00032	c3		 ret	 0
$LN3@IsFileInUs:

; 291  : 	else if (GetLastError() == ERROR_SHARING_VIOLATION)

  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00039	83 f8 20	 cmp	 eax, 32			; 00000020H
  0003c	75 f2		 jne	 SHORT $LN1@IsFileInUs

; 292  : 		return TRUE;

  0003e	b8 01 00 00 00	 mov	 eax, 1

; 295  : }

  00043	c3		 ret	 0
?IsFileInUse@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; IsFileInUse
_TEXT	ENDS
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT
; _this$ = ecx

; 1795 : 		{	// look for [_Ptr, <null>) beginnng at or after _Off

  00000	56		 push	 esi

; 1796 : 		_DEBUG_POINTER(_Ptr);
; 1797 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));

  00001	8b 74 24 08	 mov	 esi, DWORD PTR __Ptr$[esp]
  00005	8b c6		 mov	 eax, esi
  00007	57		 push	 edi
  00008	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000b	eb 03 8d 49 00	 npad	 5
$LL5@find@2:
  00010	8a 10		 mov	 dl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 d2		 test	 dl, dl
  00015	75 f9		 jne	 SHORT $LL5@find@2
  00017	2b c7		 sub	 eax, edi
  00019	50		 push	 eax
  0001a	8b 44 24 14	 mov	 eax, DWORD PTR __Off$[esp+8]
  0001e	50		 push	 eax
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 1798 : 		}

  00027	c2 08 00	 ret	 8
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2149 : 		if (!_Built)

  00000	80 7c 24 04 00	 cmp	 BYTE PTR __Built$[esp-4], 0
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b 7c 24 10	 mov	 edi, DWORD PTR __Newsize$[esp+4]
  0000b	8b f1		 mov	 esi, ecx
  0000d	74 27		 je	 SHORT $LN15@Tidy

; 2150 : 			;
; 2151 : 		else if (_BUF_SIZE <= _Myres)

  0000f	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00013	72 21		 jb	 SHORT $LN15@Tidy

; 2152 : 			{	// copy any leftovers to small buffer and deallocate
; 2153 : 			_Elem *_Ptr = _Bx._Ptr;

  00015	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00018	53		 push	 ebx
  00019	8b 18		 mov	 ebx, DWORD PTR [eax]

; 2154 : 			if (0 < _Newsize)

  0001b	85 ff		 test	 edi, edi
  0001d	76 0d		 jbe	 SHORT $LN13@Tidy

; 2155 : 				_Traits_helper::copy_s<_Traits>(_Bx._Buf, _BUF_SIZE, _Ptr, _Newsize);

  0001f	57		 push	 edi
  00020	53		 push	 ebx
  00021	6a 10		 push	 16			; 00000010H
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 _memcpy_s
  00029	83 c4 10	 add	 esp, 16			; 00000010H
$LN13@Tidy:

; 2156 : 			_Mybase::_Alval.deallocate(_Ptr, _Myres + 1);

  0002c	53		 push	 ebx
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00032	83 c4 04	 add	 esp, 4
  00035	5b		 pop	 ebx
$LN15@Tidy:

; 2157 : 			}
; 2158 : 		_Myres = _BUF_SIZE - 1;
; 2159 : 		_Eos(_Newsize);

  00036	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00039	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00040	c6 44 3e 04 00	 mov	 BYTE PTR [esi+edi+4], 0
  00045	5f		 pop	 edi
  00046	5e		 pop	 esi

; 2160 : 		}

  00047	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
EXTRN	?_Xran@_String_base@std@@SAXXZ:PROC		; std::_String_base::_Xran
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
tv130 = 8						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1262 : 		{	// erase elements [_Off, _Off + _Count)

  00000	53		 push	 ebx

; 1263 : 		if (_Mysize < _Off)

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR __Off$[esp]
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	57		 push	 edi
  00009	39 5e 14	 cmp	 DWORD PTR [esi+20], ebx
  0000c	73 05		 jae	 SHORT $LN3@erase

; 1264 : 			_String_base::_Xran();	// _Off off end

  0000e	e8 00 00 00 00	 call	 ?_Xran@_String_base@std@@SAXXZ ; std::_String_base::_Xran
$LN3@erase:

; 1265 : 		if (_Mysize - _Off < _Count)

  00013	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00016	8b 7c 24 14	 mov	 edi, DWORD PTR __Count$[esp+8]
  0001a	2b c3		 sub	 eax, ebx
  0001c	3b c7		 cmp	 eax, edi
  0001e	73 02		 jae	 SHORT $LN2@erase

; 1266 : 			_Count = _Mysize - _Off;	// trim _Count

  00020	8b f8		 mov	 edi, eax
$LN2@erase:

; 1267 : 		if (0 < _Count)

  00022	85 ff		 test	 edi, edi
  00024	76 55		 jbe	 SHORT $LN30@erase

; 1268 : 			{	// move elements down
; 1269 : 			_Traits_helper::move_s<_Traits>(_Myptr() + _Off, _Myres - _Off, _Myptr() + _Off + _Count,
; 1270 : 				_Mysize - _Off - _Count);

  00026	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00029	55		 push	 ebp
  0002a	8d 6e 04	 lea	 ebp, DWORD PTR [esi+4]
  0002d	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00030	72 09		 jb	 SHORT $LN8@erase
  00032	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  00035	89 54 24 14	 mov	 DWORD PTR tv130[esp+12], edx
  00039	eb 04		 jmp	 SHORT $LN9@erase
$LN8@erase:
  0003b	89 6c 24 14	 mov	 DWORD PTR tv130[esp+12], ebp
$LN9@erase:
  0003f	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00042	72 05		 jb	 SHORT $LN12@erase
  00044	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  00047	eb 02		 jmp	 SHORT $LN13@erase
$LN12@erase:
  00049	8b d5		 mov	 edx, ebp
$LN13@erase:
  0004b	2b c7		 sub	 eax, edi
  0004d	50		 push	 eax
  0004e	8b 44 24 18	 mov	 eax, DWORD PTR tv130[esp+16]
  00052	03 c3		 add	 eax, ebx
  00054	03 c7		 add	 eax, edi
  00056	50		 push	 eax
  00057	2b cb		 sub	 ecx, ebx
  00059	51		 push	 ecx
  0005a	03 d3		 add	 edx, ebx
  0005c	52		 push	 edx
  0005d	e8 00 00 00 00	 call	 _memmove_s

; 1271 : 			size_type _Newsize = _Mysize - _Count;

  00062	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00065	2b c7		 sub	 eax, edi
  00067	83 c4 10	 add	 esp, 16			; 00000010H

; 1272 : 			_Eos(_Newsize);

  0006a	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  0006e	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00071	72 03		 jb	 SHORT $LN26@erase
  00073	8b 6d 00	 mov	 ebp, DWORD PTR [ebp]
$LN26@erase:
  00076	c6 04 28 00	 mov	 BYTE PTR [eax+ebp], 0
  0007a	5d		 pop	 ebp
$LN30@erase:
  0007b	5f		 pop	 edi

; 1273 : 			}
; 1274 : 		return (*this);

  0007c	8b c6		 mov	 eax, esi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx

; 1275 : 		}

  00080	c2 08 00	 ret	 8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT
__Newres$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ptr$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2083 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx
  0002d	89 7d ec	 mov	 DWORD PTR _this$[ebp], edi

; 2084 : 		size_type _Newres = _Newsize | _ALLOC_MASK;

  00030	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00033	8b f0		 mov	 esi, eax
  00035	83 ce 0f	 or	 esi, 15			; 0000000fH

; 2085 : 		if (max_size() < _Newres)

  00038	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0003b	76 04		 jbe	 SHORT $LN6@Copy

; 2086 : 			_Newres = _Newsize;	// undo roundup if too big

  0003d	8b f0		 mov	 esi, eax

; 2087 : 		else if (_Newres / 3 < _Myres / 2

  0003f	eb 22		 jmp	 SHORT $LN4@Copy
$LN6@Copy:

; 2088 : 			&& _Myres <= max_size() - _Myres / 2)

  00041	8b 5f 18	 mov	 ebx, DWORD PTR [edi+24]
  00044	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00049	f7 e6		 mul	 esi
  0004b	8b cb		 mov	 ecx, ebx
  0004d	d1 e9		 shr	 ecx, 1
  0004f	d1 ea		 shr	 edx, 1
  00051	3b d1		 cmp	 edx, ecx
  00053	73 0e		 jae	 SHORT $LN4@Copy
  00055	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0005a	2b c1		 sub	 eax, ecx
  0005c	3b d8		 cmp	 ebx, eax
  0005e	77 03		 ja	 SHORT $LN4@Copy

; 2089 : 			_Newres = _Myres + _Myres / 2;	// grow exponentially if possible

  00060	8d 34 19	 lea	 esi, DWORD PTR [ecx+ebx]
$LN4@Copy:

; 2090 : 		_Elem *_Ptr = 0;
; 2091 : 
; 2092 : 		_TRY_BEGIN
; 2093 : 			_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

  00063	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  00066	6a 00		 push	 0
  00068	51		 push	 ecx
  00069	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00070	e8 00 00 00 00	 call	 ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>
  00075	83 c4 08	 add	 esp, 8
  00078	89 45 08	 mov	 DWORD PTR __Ptr$[ebp], eax
  0007b	eb 28		 jmp	 SHORT $LN16@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$0:

; 2094 : 		_CATCH_ALL
; 2095 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  0007d	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00080	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00083	89 45 e8	 mov	 DWORD PTR __Newres$[ebp], eax

; 2096 : 			_TRY_BEGIN
; 2097 : 				_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

  00086	40		 inc	 eax
  00087	6a 00		 push	 0
  00089	50		 push	 eax
  0008a	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  0008e	e8 00 00 00 00	 call	 ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>
  00093	89 45 08	 mov	 DWORD PTR __Ptr$[ebp], eax
  00096	83 c4 08	 add	 esp, 8

; 2101 : 			_CATCH_END
; 2102 : 		_CATCH_END

  00099	b8 00 00 00 00	 mov	 eax, $LN106@Copy
  0009e	c3		 ret	 0
$LN106@Copy:
  0009f	8b 7d ec	 mov	 edi, DWORD PTR _this$[ebp]
  000a2	8b 75 e8	 mov	 esi, DWORD PTR __Newres$[ebp]
$LN16@Copy:

; 2103 : 
; 2104 : 		if (0 < _Oldlen)

  000a5	8b 5d 0c	 mov	 ebx, DWORD PTR __Oldlen$[ebp]
  000a8	85 db		 test	 ebx, ebx
  000aa	76 20		 jbe	 SHORT $LN71@Copy

; 2105 : 			_Traits_helper::copy_s<_Traits>(_Ptr, _Newres + 1, _Myptr(), _Oldlen);	// copy existing elements

  000ac	83 7f 18 10	 cmp	 DWORD PTR [edi+24], 16	; 00000010H
  000b0	72 05		 jb	 SHORT $LN63@Copy
  000b2	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000b5	eb 03		 jmp	 SHORT $LN64@Copy
$LN63@Copy:
  000b7	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
$LN64@Copy:
  000ba	53		 push	 ebx
  000bb	50		 push	 eax
  000bc	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000bf	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
  000c2	52		 push	 edx
  000c3	50		 push	 eax
  000c4	e8 00 00 00 00	 call	 _memcpy_s
  000c9	83 c4 10	 add	 esp, 16			; 00000010H
$LN71@Copy:

; 2106 : 		_Tidy(true);

  000cc	83 7f 18 10	 cmp	 DWORD PTR [edi+24], 16	; 00000010H
  000d0	72 0c		 jb	 SHORT $LN87@Copy
  000d2	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000d5	51		 push	 ecx
  000d6	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000db	83 c4 04	 add	 esp, 4
$LN87@Copy:

; 2107 : 		_Bx._Ptr = _Ptr;

  000de	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  000e1	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  000e4	c6 00 00	 mov	 BYTE PTR [eax], 0
  000e7	89 08		 mov	 DWORD PTR [eax], ecx

; 2108 : 		_Myres = _Newres;

  000e9	89 77 18	 mov	 DWORD PTR [edi+24], esi

; 2109 : 		_Eos(_Oldlen);

  000ec	89 5f 14	 mov	 DWORD PTR [edi+20], ebx
  000ef	83 fe 10	 cmp	 esi, 16			; 00000010H
  000f2	72 02		 jb	 SHORT $LN101@Copy
  000f4	8b c1		 mov	 eax, ecx
$LN101@Copy:
  000f6	c6 04 18 00	 mov	 BYTE PTR [eax+ebx], 0

; 2110 : 		}

  000fa	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000fd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00104	59		 pop	 ecx
  00105	5f		 pop	 edi
  00106	5e		 pop	 esi
  00107	5b		 pop	 ebx
  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c2 08 00	 ret	 8
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$1:

; 2098 : 			_CATCH_ALL
; 2099 : 			_Tidy(true);	// failed again, discard storage and reraise

  0010e	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00111	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00115	72 0c		 jb	 SHORT $LN51@Copy
  00117	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0011a	52		 push	 edx
  0011b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00120	83 c4 04	 add	 esp, 4
$LN51@Copy:

; 2100 : 			_RERAISE;

  00123	6a 00		 push	 0
  00125	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  0012c	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00133	6a 00		 push	 0
  00135	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
  00139	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN109@Copy:
  0013e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 565  : 		{	// construct empty string

  00000	8b c1		 mov	 eax, ecx

; 566  : 		_Tidy();

  00002	33 c9		 xor	 ecx, ecx
  00004	c7 40 18 0f 00
	00 00		 mov	 DWORD PTR [eax+24], 15	; 0000000fH
  0000b	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  0000e	88 48 04	 mov	 BYTE PTR [eax+4], cl

; 567  : 		}

  00011	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 905  : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 906  : 		_Tidy(true);

  00003	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00007	72 0c		 jb	 SHORT $LN17@basic_stri
  00009	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00012	83 c4 04	 add	 esp, 4
$LN17@basic_stri:
  00015	33 c0		 xor	 eax, eax
  00017	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  0001e	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00021	88 46 04	 mov	 BYTE PTR [esi+4], al
  00024	5e		 pop	 esi

; 907  : 		}

  00025	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
EXTRN	?_Xlen@_String_base@std@@SAXXZ:PROC		; std::_String_base::_Xlen
; Function compile flags: /Ogtpy
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2119 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	53		 push	 ebx

; 2120 : 			if (max_size() < _Newsize)

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR __Newsize$[esp]
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	83 fb fe	 cmp	 ebx, -2			; fffffffeH
  0000b	76 05		 jbe	 SHORT $LN6@Grow

; 2121 : 			_String_base::_Xlen();	// result too long

  0000d	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@SAXXZ ; std::_String_base::_Xlen
$LN6@Grow:

; 2122 : 		if (_Myres < _Newsize)

  00012	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00015	3b c3		 cmp	 eax, ebx
  00017	73 19		 jae	 SHORT $LN5@Grow

; 2123 : 			_Copy(_Newsize, _Mysize);	// reallocate to grow

  00019	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0001c	50		 push	 eax
  0001d	53		 push	 ebx
  0001e	8b ce		 mov	 ecx, esi
  00020	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2129 : 		return (0 < _Newsize);	// return true only if more work to do

  00025	33 c9		 xor	 ecx, ecx
  00027	3b cb		 cmp	 ecx, ebx
  00029	1b c0		 sbb	 eax, eax
  0002b	5e		 pop	 esi
  0002c	f7 d8		 neg	 eax
  0002e	5b		 pop	 ebx

; 2130 : 		}

  0002f	c2 08 00	 ret	 8
$LN5@Grow:

; 2124 : 		else if (_Trim && _Newsize < _BUF_SIZE)

  00032	80 7c 24 10 00	 cmp	 BYTE PTR __Trim$[esp+4], 0
  00037	74 52		 je	 SHORT $LN3@Grow
  00039	83 fb 10	 cmp	 ebx, 16			; 00000010H
  0003c	73 4d		 jae	 SHORT $LN3@Grow
  0003e	57		 push	 edi

; 2125 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2126 : 				_Newsize < _Mysize ? _Newsize : _Mysize);

  0003f	8b 7e 14	 mov	 edi, DWORD PTR [esi+20]
  00042	3b df		 cmp	 ebx, edi
  00044	73 02		 jae	 SHORT $LN9@Grow
  00046	8b fb		 mov	 edi, ebx
$LN9@Grow:
  00048	83 f8 10	 cmp	 eax, 16			; 00000010H
  0004b	72 21		 jb	 SHORT $LN33@Grow
  0004d	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00050	55		 push	 ebp
  00051	8b 28		 mov	 ebp, DWORD PTR [eax]
  00053	85 ff		 test	 edi, edi
  00055	76 0d		 jbe	 SHORT $LN31@Grow
  00057	57		 push	 edi
  00058	55		 push	 ebp
  00059	6a 10		 push	 16			; 00000010H
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _memcpy_s
  00061	83 c4 10	 add	 esp, 16			; 00000010H
$LN31@Grow:
  00064	55		 push	 ebp
  00065	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0006a	83 c4 04	 add	 esp, 4
  0006d	5d		 pop	 ebp
$LN33@Grow:
  0006e	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00071	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH

; 2129 : 		return (0 < _Newsize);	// return true only if more work to do

  00078	33 c9		 xor	 ecx, ecx
  0007a	c6 44 3e 04 00	 mov	 BYTE PTR [esi+edi+4], 0
  0007f	3b cb		 cmp	 ecx, ebx
  00081	5f		 pop	 edi
  00082	1b c0		 sbb	 eax, eax
  00084	5e		 pop	 esi
  00085	f7 d8		 neg	 eax
  00087	5b		 pop	 ebx

; 2130 : 		}

  00088	c2 08 00	 ret	 8
$LN3@Grow:

; 2127 : 		else if (_Newsize == 0)

  0008b	85 db		 test	 ebx, ebx
  0008d	75 20		 jne	 SHORT $LN49@Grow

; 2128 : 			_Eos(0);	// new size is zero, just null terminate

  0008f	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  00092	83 f8 10	 cmp	 eax, 16			; 00000010H
  00095	72 12		 jb	 SHORT $LN47@Grow
  00097	8b 76 04	 mov	 esi, DWORD PTR [esi+4]

; 2129 : 		return (0 < _Newsize);	// return true only if more work to do

  0009a	33 c9		 xor	 ecx, ecx
  0009c	3b cb		 cmp	 ecx, ebx
  0009e	88 1e		 mov	 BYTE PTR [esi], bl
  000a0	1b c0		 sbb	 eax, eax
  000a2	5e		 pop	 esi
  000a3	f7 d8		 neg	 eax
  000a5	5b		 pop	 ebx

; 2130 : 		}

  000a6	c2 08 00	 ret	 8

; 2128 : 			_Eos(0);	// new size is zero, just null terminate

$LN47@Grow:
  000a9	83 c6 04	 add	 esi, 4
  000ac	c6 06 00	 mov	 BYTE PTR [esi], 0
$LN49@Grow:

; 2129 : 		return (0 < _Newsize);	// return true only if more work to do

  000af	33 c9		 xor	 ecx, ecx
  000b1	3b cb		 cmp	 ecx, ebx
  000b3	1b c0		 sbb	 eax, eax
  000b5	5e		 pop	 esi
  000b6	f7 d8		 neg	 eax
  000b8	5b		 pop	 ebx

; 2130 : 		}

  000b9	c2 08 00	 ret	 8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogtpy
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 951  : 		{	// append _Right [_Roff, _Roff + _Count)

  00000	53		 push	 ebx
  00001	55		 push	 ebp

; 952  : 		if (_Right.size() < _Roff)

  00002	8b 6c 24 0c	 mov	 ebp, DWORD PTR __Right$[esp+4]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b 7c 24 18	 mov	 edi, DWORD PTR __Roff$[esp+12]
  0000c	8b f1		 mov	 esi, ecx
  0000e	39 7d 14	 cmp	 DWORD PTR [ebp+20], edi
  00011	73 05		 jae	 SHORT $LN5@append

; 953  : 			_String_base::_Xran();	// _Roff off end

  00013	e8 00 00 00 00	 call	 ?_Xran@_String_base@std@@SAXXZ ; std::_String_base::_Xran
$LN5@append:

; 954  : 		size_type _Num = _Right.size() - _Roff;

  00018	8b 45 14	 mov	 eax, DWORD PTR [ebp+20]

; 955  : 		if (_Num < _Count)

  0001b	8b 5c 24 1c	 mov	 ebx, DWORD PTR __Count$[esp+12]
  0001f	2b c7		 sub	 eax, edi
  00021	3b c3		 cmp	 eax, ebx
  00023	73 02		 jae	 SHORT $LN4@append

; 956  : 			_Count = _Num;	// trim _Count to size

  00025	8b d8		 mov	 ebx, eax
$LN4@append:

; 957  : 		if (npos - _Mysize <= _Count || _Mysize + _Count < _Mysize)

  00027	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002a	83 c9 ff	 or	 ecx, -1
  0002d	2b c8		 sub	 ecx, eax
  0002f	3b cb		 cmp	 ecx, ebx
  00031	76 07		 jbe	 SHORT $LN2@append
  00033	8d 14 18	 lea	 edx, DWORD PTR [eax+ebx]
  00036	3b d0		 cmp	 edx, eax
  00038	73 05		 jae	 SHORT $LN3@append
$LN2@append:

; 958  : 			_String_base::_Xlen();	// result too long

  0003a	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@SAXXZ ; std::_String_base::_Xlen
$LN3@append:

; 959  : 
; 960  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

  0003f	85 db		 test	 ebx, ebx
  00041	0f 86 ab 00 00
	00		 jbe	 $LN87@append
  00047	8b 7e 14	 mov	 edi, DWORD PTR [esi+20]
  0004a	03 fb		 add	 edi, ebx
  0004c	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0004f	76 05		 jbe	 SHORT $LN17@append
  00051	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@SAXXZ ; std::_String_base::_Xlen
$LN17@append:
  00056	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00059	3b c7		 cmp	 eax, edi
  0005b	73 1f		 jae	 SHORT $LN16@append
  0005d	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00060	50		 push	 eax
  00061	57		 push	 edi
  00062	8b ce		 mov	 ecx, esi
  00064	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00069	85 ff		 test	 edi, edi
$LN88@append:
  0006b	0f 86 81 00 00
	00		 jbe	 $LN87@append

; 961  : 			{	// make room and append new stuff
; 962  : 			_Traits_helper::copy_s<_Traits>(_Myptr() + _Mysize, _Myres - _Mysize,
; 963  : 				_Right._Myptr() + _Roff, _Count);

  00071	83 7d 18 10	 cmp	 DWORD PTR [ebp+24], 16	; 00000010H
  00075	72 2f		 jb	 SHORT $LN64@append
  00077	8b 6d 04	 mov	 ebp, DWORD PTR [ebp+4]
  0007a	eb 2d		 jmp	 SHORT $LN65@append

; 959  : 
; 960  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN16@append:
  0007c	85 ff		 test	 edi, edi
  0007e	75 eb		 jne	 SHORT $LN88@append
  00080	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00083	83 f8 10	 cmp	 eax, 16			; 00000010H
  00086	72 0f		 jb	 SHORT $LN58@append
  00088	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0008b	5f		 pop	 edi
  0008c	c6 00 00	 mov	 BYTE PTR [eax], 0

; 965  : 			}
; 966  : 		return (*this);

  0008f	8b c6		 mov	 eax, esi
  00091	5e		 pop	 esi
  00092	5d		 pop	 ebp
  00093	5b		 pop	 ebx

; 967  : 		}

  00094	c2 0c 00	 ret	 12			; 0000000cH

; 959  : 
; 960  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN58@append:
  00097	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0009a	5f		 pop	 edi
  0009b	c6 00 00	 mov	 BYTE PTR [eax], 0

; 965  : 			}
; 966  : 		return (*this);

  0009e	8b c6		 mov	 eax, esi
  000a0	5e		 pop	 esi
  000a1	5d		 pop	 ebp
  000a2	5b		 pop	 ebx

; 967  : 		}

  000a3	c2 0c 00	 ret	 12			; 0000000cH

; 961  : 			{	// make room and append new stuff
; 962  : 			_Traits_helper::copy_s<_Traits>(_Myptr() + _Mysize, _Myres - _Mysize,
; 963  : 				_Right._Myptr() + _Roff, _Count);

$LN64@append:
  000a6	83 c5 04	 add	 ebp, 4
$LN65@append:
  000a9	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  000ac	83 f8 10	 cmp	 eax, 16			; 00000010H
  000af	72 05		 jb	 SHORT $LN68@append
  000b1	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  000b4	eb 03		 jmp	 SHORT $LN69@append
$LN68@append:
  000b6	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
$LN69@append:
  000b9	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  000bc	53		 push	 ebx
  000bd	8b 5c 24 1c	 mov	 ebx, DWORD PTR __Roff$[esp+16]
  000c1	03 eb		 add	 ebp, ebx
  000c3	2b c1		 sub	 eax, ecx
  000c5	55		 push	 ebp
  000c6	50		 push	 eax
  000c7	03 ca		 add	 ecx, edx
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 _memcpy_s
  000cf	83 c4 10	 add	 esp, 16			; 00000010H

; 964  : 			_Eos(_Num);

  000d2	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  000d6	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  000d9	72 10		 jb	 SHORT $LN82@append
  000db	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000de	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
  000e2	5f		 pop	 edi

; 965  : 			}
; 966  : 		return (*this);

  000e3	8b c6		 mov	 eax, esi
  000e5	5e		 pop	 esi
  000e6	5d		 pop	 ebp
  000e7	5b		 pop	 ebx

; 967  : 		}

  000e8	c2 0c 00	 ret	 12			; 0000000cH

; 964  : 			_Eos(_Num);

$LN82@append:
  000eb	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  000ee	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN87@append:
  000f2	5f		 pop	 edi

; 965  : 			}
; 966  : 		return (*this);

  000f3	8b c6		 mov	 eax, esi
  000f5	5e		 pop	 esi
  000f6	5d		 pop	 ebp
  000f7	5b		 pop	 ebx

; 967  : 		}

  000f8	c2 0c 00	 ret	 12			; 0000000cH
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogtpy
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 971  : 
; 972  :  #if _HAS_ITERATOR_DEBUGGING
; 973  : 		if (_Count != 0)
; 974  : 			_DEBUG_POINTER(_Ptr);
; 975  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 976  : 
; 977  : 		if (_Inside(_Ptr))

  00000	8b 54 24 04	 mov	 edx, DWORD PTR __Ptr$[esp-4]
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f1		 mov	 esi, ecx
  00009	85 d2		 test	 edx, edx
  0000b	74 46		 je	 SHORT $LN4@append@2
  0000d	8b 7e 18	 mov	 edi, DWORD PTR [esi+24]
  00010	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00013	83 ff 10	 cmp	 edi, 16			; 00000010H
  00016	72 04		 jb	 SHORT $LN14@append@2
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	eb 02		 jmp	 SHORT $LN15@append@2
$LN14@append@2:
  0001c	8b c8		 mov	 ecx, eax
$LN15@append@2:
  0001e	3b d1		 cmp	 edx, ecx
  00020	72 31		 jb	 SHORT $LN4@append@2
  00022	83 ff 10	 cmp	 edi, 16			; 00000010H
  00025	72 04		 jb	 SHORT $LN18@append@2
  00027	8b 08		 mov	 ecx, DWORD PTR [eax]
  00029	eb 02		 jmp	 SHORT $LN19@append@2
$LN18@append@2:
  0002b	8b c8		 mov	 ecx, eax
$LN19@append@2:
  0002d	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  00030	03 d9		 add	 ebx, ecx
  00032	3b da		 cmp	 ebx, edx
  00034	76 1d		 jbe	 SHORT $LN4@append@2

; 978  : 			return (append(*this, _Ptr - _Myptr(), _Count));	// substring

  00036	83 ff 10	 cmp	 edi, 16			; 00000010H
  00039	72 02		 jb	 SHORT $LN22@append@2
  0003b	8b 00		 mov	 eax, DWORD PTR [eax]
$LN22@append@2:
  0003d	8b 4c 24 14	 mov	 ecx, DWORD PTR __Count$[esp+8]
  00041	51		 push	 ecx
  00042	2b d0		 sub	 edx, eax
  00044	52		 push	 edx
  00045	56		 push	 esi
  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx

; 989  : 		}

  00050	c2 08 00	 ret	 8
$LN4@append@2:

; 979  : 		if (npos - _Mysize <= _Count || _Mysize + _Count < _Mysize)

  00053	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00056	83 ca ff	 or	 edx, -1
  00059	55		 push	 ebp
  0005a	8b 6c 24 18	 mov	 ebp, DWORD PTR __Count$[esp+12]
  0005e	2b d0		 sub	 edx, eax
  00060	3b d5		 cmp	 edx, ebp
  00062	76 07		 jbe	 SHORT $LN2@append@2
  00064	8d 0c 28	 lea	 ecx, DWORD PTR [eax+ebp]
  00067	3b c8		 cmp	 ecx, eax
  00069	73 05		 jae	 SHORT $LN3@append@2
$LN2@append@2:

; 980  : 			_String_base::_Xlen();	// result too long

  0006b	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@SAXXZ ; std::_String_base::_Xlen
$LN3@append@2:

; 981  : 
; 982  : 		size_type _Num;
; 983  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

  00070	85 ed		 test	 ebp, ebp
  00072	0f 86 87 00 00
	00		 jbe	 $LN92@append@2
  00078	8b 7e 14	 mov	 edi, DWORD PTR [esi+20]
  0007b	03 fd		 add	 edi, ebp
  0007d	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00080	76 05		 jbe	 SHORT $LN29@append@2
  00082	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@SAXXZ ; std::_String_base::_Xlen
$LN29@append@2:
  00087	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0008a	3b c7		 cmp	 eax, edi
  0008c	73 1f		 jae	 SHORT $LN28@append@2
  0008e	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00091	52		 push	 edx
  00092	57		 push	 edi
  00093	8b ce		 mov	 ecx, esi
  00095	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0009a	85 ff		 test	 edi, edi
$LN95@append@2:
  0009c	76 61		 jbe	 SHORT $LN92@append@2

; 984  : 			{	// make room and append new stuff
; 985  : 			_Traits_helper::copy_s<_Traits>(_Myptr() + _Mysize, _Myres - _Mysize, _Ptr, _Count);

  0009e	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  000a1	8d 5e 04	 lea	 ebx, DWORD PTR [esi+4]
  000a4	83 f8 10	 cmp	 eax, 16			; 00000010H
  000a7	72 2e		 jb	 SHORT $LN76@append@2
  000a9	8b 13		 mov	 edx, DWORD PTR [ebx]
  000ab	eb 2c		 jmp	 SHORT $LN77@append@2

; 981  : 
; 982  : 		size_type _Num;
; 983  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN28@append@2:
  000ad	85 ff		 test	 edi, edi
  000af	75 eb		 jne	 SHORT $LN95@append@2
  000b1	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  000b4	83 f8 10	 cmp	 eax, 16			; 00000010H
  000b7	72 0f		 jb	 SHORT $LN70@append@2
  000b9	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000bc	5d		 pop	 ebp
  000bd	5f		 pop	 edi
  000be	c6 00 00	 mov	 BYTE PTR [eax], 0

; 987  : 			}
; 988  : 		return (*this);

  000c1	8b c6		 mov	 eax, esi
  000c3	5e		 pop	 esi
  000c4	5b		 pop	 ebx

; 989  : 		}

  000c5	c2 08 00	 ret	 8

; 981  : 
; 982  : 		size_type _Num;
; 983  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN70@append@2:
  000c8	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  000cb	5d		 pop	 ebp
  000cc	5f		 pop	 edi
  000cd	c6 00 00	 mov	 BYTE PTR [eax], 0

; 987  : 			}
; 988  : 		return (*this);

  000d0	8b c6		 mov	 eax, esi
  000d2	5e		 pop	 esi
  000d3	5b		 pop	 ebx

; 989  : 		}

  000d4	c2 08 00	 ret	 8

; 984  : 			{	// make room and append new stuff
; 985  : 			_Traits_helper::copy_s<_Traits>(_Myptr() + _Mysize, _Myres - _Mysize, _Ptr, _Count);

$LN76@append@2:
  000d7	8b d3		 mov	 edx, ebx
$LN77@append@2:
  000d9	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  000dc	55		 push	 ebp
  000dd	8b 6c 24 18	 mov	 ebp, DWORD PTR __Ptr$[esp+16]
  000e1	2b c1		 sub	 eax, ecx
  000e3	55		 push	 ebp
  000e4	50		 push	 eax
  000e5	03 ca		 add	 ecx, edx
  000e7	51		 push	 ecx
  000e8	e8 00 00 00 00	 call	 _memcpy_s
  000ed	83 c4 10	 add	 esp, 16			; 00000010H

; 986  : 			_Eos(_Num);

  000f0	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  000f4	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  000f7	72 02		 jb	 SHORT $LN90@append@2
  000f9	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN90@append@2:
  000fb	c6 04 3b 00	 mov	 BYTE PTR [ebx+edi], 0
$LN92@append@2:
  000ff	5d		 pop	 ebp
  00100	5f		 pop	 edi

; 987  : 			}
; 988  : 		return (*this);

  00101	8b c6		 mov	 eax, esi
  00103	5e		 pop	 esi
  00104	5b		 pop	 ebx

; 989  : 		}

  00105	c2 08 00	 ret	 8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
PUBLIC	??_C@_0BM@NGMAPMJP@CipherShed?5User?5Guide?4?$CK?4pdf?$AA@ ; `string'
PUBLIC	??_C@_0M@LJEGBCFM@Setup?5files?$AA@		; `string'
PUBLIC	??_C@_0P@GPPOMBKF@Language?4?$CK?4xml?$AA@	; `string'
PUBLIC	??_C@_0BE@ICFIOGFL@UNINSTALL_OF_FAILED?$AA@	; `string'
PUBLIC	??_C@_0BC@MNFHJDAJ@INSTALL_OF_FAILED?$AA@	; `string'
PUBLIC	??_C@_0CM@CEEDGJNL@SYSTEM?2CurrentControlSet?2Service@ ; `string'
PUBLIC	??_C@_09JMMKOPDJ@ImagePath?$AA@			; `string'
PUBLIC	??_C@_0BP@MGAEPBHO@System32?2drivers?2truecrypt?4sys?$AA@ ; `string'
PUBLIC	??_C@_08GHPFJMCG@Drivers?2?$AA@			; `string'
PUBLIC	??_C@_0BB@DDEACFEL@CipherShed?9Setup?$AA@	; `string'
PUBLIC	_szDestDir$GSCopy$
PUBLIC	_hwndDlg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_DoFilesInstall
EXTRN	__imp__FindClose@4:PROC
EXTRN	__imp__FindFirstFileA@8:PROC
EXTRN	_Silent:DWORD
EXTRN	__imp__LocalFree@4:PROC
EXTRN	__imp__FormatMessageA@28:PROC
EXTRN	__imp__CopyFileA@12:PROC
EXTRN	_FileExists:PROC
EXTRN	?GetServiceConfigPath@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z:PROC ; GetServiceConfigPath
EXTRN	_WriteLocalMachineRegistryString:PROC
EXTRN	_SaveBufferToFile:PROC
EXTRN	_EnableWow64FsRedirection:PROC
EXTRN	_Decompressed_Files:BYTE
EXTRN	_Is64BitOs:PROC
EXTRN	_strncpy:PROC
EXTRN	_TCCopyFile:PROC
EXTRN	__imp__SetCurrentDirectoryA@4:PROC
EXTRN	__imp__GetWindowsDirectoryA@8:PROC
EXTRN	__imp__GetSystemDirectoryA@8:PROC
EXTRN	_SelfExtractInMemory:PROC
EXTRN	__imp__GetModuleFileNameA@12:PROC
;	COMDAT ??_C@_0BM@NGMAPMJP@CipherShed?5User?5Guide?4?$CK?4pdf?$AA@
; File c:\home\public\desktop\projects\ciphershed.build\src\setup\setup.c
CONST	SEGMENT
??_C@_0BM@NGMAPMJP@CipherShed?5User?5Guide?4?$CK?4pdf?$AA@ DB 'CipherShed'
	DB	' User Guide.*.pdf', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LJEGBCFM@Setup?5files?$AA@
CONST	SEGMENT
??_C@_0M@LJEGBCFM@Setup?5files?$AA@ DB 'Setup files', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GPPOMBKF@Language?4?$CK?4xml?$AA@
CONST	SEGMENT
??_C@_0P@GPPOMBKF@Language?4?$CK?4xml?$AA@ DB 'Language.*.xml', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@ICFIOGFL@UNINSTALL_OF_FAILED?$AA@
CONST	SEGMENT
??_C@_0BE@ICFIOGFL@UNINSTALL_OF_FAILED?$AA@ DB 'UNINSTALL_OF_FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MNFHJDAJ@INSTALL_OF_FAILED?$AA@
CONST	SEGMENT
??_C@_0BC@MNFHJDAJ@INSTALL_OF_FAILED?$AA@ DB 'INSTALL_OF_FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@CEEDGJNL@SYSTEM?2CurrentControlSet?2Service@
CONST	SEGMENT
??_C@_0CM@CEEDGJNL@SYSTEM?2CurrentControlSet?2Service@ DB 'SYSTEM\Current'
	DB	'ControlSet\Services\truecrypt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09JMMKOPDJ@ImagePath?$AA@
CONST	SEGMENT
??_C@_09JMMKOPDJ@ImagePath?$AA@ DB 'ImagePath', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MGAEPBHO@System32?2drivers?2truecrypt?4sys?$AA@
CONST	SEGMENT
??_C@_0BP@MGAEPBHO@System32?2drivers?2truecrypt?4sys?$AA@ DB 'System32\dr'
	DB	'ivers\truecrypt.sys', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08GHPFJMCG@Drivers?2?$AA@
CONST	SEGMENT
??_C@_08GHPFJMCG@Drivers?2?$AA@ DB 'Drivers\', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DDEACFEL@CipherShed?9Setup?$AA@
CONST	SEGMENT
??_C@_0BB@DDEACFEL@CipherShed?9Setup?$AA@ DB 'CipherShed-Setup', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _DoFilesInstall
_TEXT	SEGMENT
_hwndDlg$GSCopy$ = -2836				; size = 4
tv835 = -2832						; size = 4
_szDestDir$GSCopy$ = -2828				; size = 4
_lpMsgBuf$134222 = -2824				; size = 4
_st$140236 = -2820					; size = 56
_servicePath$134216 = -2820				; size = 28
_f$134234 = -2764					; size = 320
_mp$134186 = -2764					; size = 260
_szTmp$ = -2444						; size = 260
_curFileName$ = -2184					; size = 260
_d$134251 = -1924					; size = 520
_d$134240 = -1924					; size = 520
_szDir$134163 = -1924					; size = 260
_szTmp2$134224 = -1404					; size = 1400
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_szDestDir$ = 12					; size = 4
_DoFilesInstall PROC					; COMDAT

; 299  : {

  00000	81 ec 14 0b 00
	00		 sub	 esp, 2836		; 00000b14H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 10 0b
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+2836], eax
  00014	53		 push	 ebx
  00015	8b 9c 24 1c 0b
	00 00		 mov	 ebx, DWORD PTR _hwndDlg$[esp+2836]
  0001c	56		 push	 esi
  0001d	8b b4 24 24 0b
	00 00		 mov	 esi, DWORD PTR _szDestDir$[esp+2840]

; 300  : 	/* WARNING: Note that, despite its name, this function is used during UNinstallation as well. */
; 301  : 
; 302  : 	char szTmp[TC_MAX_PATH];
; 303  : 	BOOL bOK = TRUE;
; 304  : 	int i, x, fileNo;
; 305  : 	char curFileName [TC_MAX_PATH] = {0};

  00024	68 03 01 00 00	 push	 259			; 00000103H
  00029	8d 84 24 99 02
	00 00		 lea	 eax, DWORD PTR _curFileName$[esp+2849]
  00030	6a 00		 push	 0
  00032	50		 push	 eax

; 410  : 							}
; 411  : 
; 412  : 							bResult = SaveBufferToFile (
; 413  : 								(char *) Decompressed_Files[fileNo].fileContent,
; 414  : 								szTmp,
; 415  : 								Decompressed_Files[fileNo].fileLength, 
; 416  : 								FALSE);

  00033	89 5c 24 14	 mov	 DWORD PTR _hwndDlg$GSCopy$[esp+2856], ebx
  00037	89 74 24 1c	 mov	 DWORD PTR _szDestDir$GSCopy$[esp+2856], esi
  0003b	c6 84 24 a0 02
	00 00 00	 mov	 BYTE PTR _curFileName$[esp+2856], 0
  00043	e8 00 00 00 00	 call	 _memset
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bUninstall@@3HA, 0 ; bUninstall
  00052	75 4b		 jne	 SHORT $LN50@DoFilesIns

; 306  : 
; 307  : 	if (!bUninstall && !bDevm)

  00054	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bDevm, 0
  0005b	75 42		 jne	 SHORT $LN50@DoFilesIns

; 308  : 	{
; 309  : 		// Self-extract all files to memory
; 310  : 
; 311  : 		GetModuleFileName (NULL, szTmp, sizeof (szTmp));

  0005d	68 04 01 00 00	 push	 260			; 00000104H
  00062	8d 8c 24 94 01
	00 00		 lea	 ecx, DWORD PTR _szTmp$[esp+2848]
  00069	51		 push	 ecx
  0006a	6a 00		 push	 0
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12

; 312  : 
; 313  : 		if (!SelfExtractInMemory (szTmp))

  00072	8d 94 24 90 01
	00 00		 lea	 edx, DWORD PTR _szTmp$[esp+2844]
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 _SelfExtractInMemory
  0007f	83 c4 04	 add	 esp, 4
  00082	85 c0		 test	 eax, eax
  00084	75 19		 jne	 SHORT $LN50@DoFilesIns
$LN165@DoFilesIns:
  00086	5e		 pop	 esi

; 314  : 			return FALSE;

  00087	33 c0		 xor	 eax, eax
  00089	5b		 pop	 ebx

; 537  : }

  0008a	8b 8c 24 10 0b
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+2836]
  00091	33 cc		 xor	 ecx, esp
  00093	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00098	81 c4 14 0b 00
	00		 add	 esp, 2836		; 00000b14H
  0009e	c3		 ret	 0
$LN50@DoFilesIns:

; 315  : 	}
; 316  : 
; 317  : 	x = strlen (szDestDir);

  0009f	8b c6		 mov	 eax, esi
  000a1	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL136@DoFilesIns:
  000a4	8a 08		 mov	 cl, BYTE PTR [eax]
  000a6	40		 inc	 eax
  000a7	84 c9		 test	 cl, cl
  000a9	75 f9		 jne	 SHORT $LL136@DoFilesIns
  000ab	2b c2		 sub	 eax, edx

; 318  : 	if (x < 2)

  000ad	83 f8 02	 cmp	 eax, 2

; 319  : 		return FALSE;

  000b0	7c d4		 jl	 SHORT $LN165@DoFilesIns

; 320  : 
; 321  : 	if (szDestDir[x - 1] != '\\')

  000b2	80 7c 06 ff 5c	 cmp	 BYTE PTR [esi+eax-1], 92 ; 0000005cH
  000b7	74 10		 je	 SHORT $LN48@DoFilesIns

; 322  : 		strcat_s (szDestDir, sizeof(szDestDir), "\\");

  000b9	68 00 00 00 00	 push	 OFFSET ??_C@_01KICIPPFI@?2?$AA@
  000be	6a 04		 push	 4
  000c0	56		 push	 esi
  000c1	e8 00 00 00 00	 call	 _strcat_s
  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN48@DoFilesIns:
  000c9	57		 push	 edi

; 323  : 
; 324  : 	for (i = 0; i < sizeof (szFiles) / sizeof (szFiles[0]); i++)

  000ca	33 ff		 xor	 edi, edi
  000cc	89 7c 24 10	 mov	 DWORD PTR tv835[esp+2848], edi
  000d0	55		 push	 ebp
$LL156@DoFilesIns:

; 325  : 	{
; 326  : 		BOOL bResult;
; 327  : 		char szDir[TC_MAX_PATH];
; 328  : 
; 329  : 		if (strstr (szFiles[i], "CipherShed-Setup") != 0)

  000d1	8b 87 00 00 00
	00		 mov	 eax, DWORD PTR _szFiles[edi]
  000d7	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@DDEACFEL@CipherShed?9Setup?$AA@
  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 _strstr
  000e2	83 c4 08	 add	 esp, 8
  000e5	85 c0		 test	 eax, eax
  000e7	74 1a		 je	 SHORT $LN157@DoFilesIns

; 330  : 		{
; 331  : 			if (bUninstall)

  000e9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bUninstall@@3HA, 0 ; bUninstall
  000f0	0f 85 87 05 00
	00		 jne	 $LN46@DoFilesIns

; 332  : 				continue;	// Prevent 'access denied' error
; 333  : 
; 334  : 			if (bRepairMode)

  000f6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bRepairMode, 0
  000fd	0f 85 7a 05 00
	00		 jne	 $LN46@DoFilesIns
$LN157@DoFilesIns:

; 335  : 				continue;	// Destination = target
; 336  : 		}
; 337  : 
; 338  : 		if (*szFiles[i] == 'A')

  00103	8b 87 00 00 00
	00		 mov	 eax, DWORD PTR _szFiles[edi]
  00109	8a 00		 mov	 al, BYTE PTR [eax]
  0010b	3c 41		 cmp	 al, 65			; 00000041H
  0010d	75 20		 jne	 SHORT $LN41@DoFilesIns

; 339  : 			strcpy (szDir, szDestDir);

  0010f	8d 94 24 a0 03
	00 00		 lea	 edx, DWORD PTR _szDir$134163[esp+2852]
  00116	8b c6		 mov	 eax, esi
  00118	2b d6		 sub	 edx, esi
  0011a	8d 9b 00 00 00
	00		 npad	 6
$LL54@DoFilesIns:
  00120	8a 08		 mov	 cl, BYTE PTR [eax]
  00122	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00125	40		 inc	 eax
  00126	84 c9		 test	 cl, cl
  00128	75 f6		 jne	 SHORT $LL54@DoFilesIns
  0012a	e9 81 00 00 00	 jmp	 $LN158@DoFilesIns
$LN41@DoFilesIns:

; 340  : 		else if (*szFiles[i] == 'D')

  0012f	3c 44		 cmp	 al, 68			; 00000044H
  00131	75 66		 jne	 SHORT $LN39@DoFilesIns

; 341  : 		{
; 342  : 			GetSystemDirectory (szDir, sizeof (szDir));

  00133	68 04 01 00 00	 push	 260			; 00000104H
  00138	8d 8c 24 a4 03
	00 00		 lea	 ecx, DWORD PTR _szDir$134163[esp+2856]
  0013f	51		 push	 ecx
  00140	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemDirectoryA@8

; 343  : 
; 344  : 			x = strlen (szDir);

  00146	8d 84 24 a0 03
	00 00		 lea	 eax, DWORD PTR _szDir$134163[esp+2852]
  0014d	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL137@DoFilesIns:
  00150	8a 08		 mov	 cl, BYTE PTR [eax]
  00152	40		 inc	 eax
  00153	84 c9		 test	 cl, cl
  00155	75 f9		 jne	 SHORT $LL137@DoFilesIns
  00157	2b c2		 sub	 eax, edx

; 345  : 			if (szDir[x - 1] != '\\')

  00159	80 bc 04 9f 03
	00 00 5c	 cmp	 BYTE PTR _szDir$134163[esp+eax+2851], 92 ; 0000005cH
  00161	74 1a		 je	 SHORT $LN38@DoFilesIns

; 346  : 				strcat_s (szDir, sizeof(szDir), "\\");

  00163	68 00 00 00 00	 push	 OFFSET ??_C@_01KICIPPFI@?2?$AA@
  00168	8d 94 24 a4 03
	00 00		 lea	 edx, DWORD PTR _szDir$134163[esp+2856]
  0016f	68 04 01 00 00	 push	 260			; 00000104H
  00174	52		 push	 edx
  00175	e8 00 00 00 00	 call	 _strcat_s
  0017a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN38@DoFilesIns:

; 347  : 
; 348  : 			strcat_s (szDir, sizeof(szDir), "Drivers\\");

  0017d	68 00 00 00 00	 push	 OFFSET ??_C@_08GHPFJMCG@Drivers?2?$AA@
  00182	8d 84 24 a4 03
	00 00		 lea	 eax, DWORD PTR _szDir$134163[esp+2856]
  00189	68 04 01 00 00	 push	 260			; 00000104H
  0018e	50		 push	 eax
  0018f	e8 00 00 00 00	 call	 _strcat_s
  00194	83 c4 0c	 add	 esp, 12			; 0000000cH
  00197	eb 17		 jmp	 SHORT $LN158@DoFilesIns
$LN39@DoFilesIns:

; 349  : 		}
; 350  : 		else if (*szFiles[i] == 'W')

  00199	3c 57		 cmp	 al, 87			; 00000057H
  0019b	75 13		 jne	 SHORT $LN158@DoFilesIns

; 351  : 			GetWindowsDirectory (szDir, sizeof (szDir));

  0019d	68 04 01 00 00	 push	 260			; 00000104H
  001a2	8d 8c 24 a4 03
	00 00		 lea	 ecx, DWORD PTR _szDir$134163[esp+2856]
  001a9	51		 push	 ecx
  001aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowsDirectoryA@8
$LN158@DoFilesIns:

; 352  : 
; 353  : 		if (*szFiles[i] == 'I')

  001b0	8b 87 00 00 00
	00		 mov	 eax, DWORD PTR _szFiles[edi]
  001b6	80 38 49	 cmp	 BYTE PTR [eax], 73	; 00000049H
  001b9	0f 84 be 04 00
	00		 je	 $LN46@DoFilesIns

; 354  : 			continue;
; 355  : 
; 356  : 		snprintf (szTmp, sizeof(szTmp), "%s%s", szDir, szFiles[i] + 1);

  001bf	40		 inc	 eax
  001c0	50		 push	 eax
  001c1	8d 94 24 a4 03
	00 00		 lea	 edx, DWORD PTR _szDir$134163[esp+2856]
  001c8	52		 push	 edx
  001c9	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  001ce	8d 84 24 a4 01
	00 00		 lea	 eax, DWORD PTR _szTmp$[esp+2864]
  001d5	68 04 01 00 00	 push	 260			; 00000104H
  001da	50		 push	 eax
  001db	e8 00 00 00 00	 call	 _sprintf_s
  001e0	83 c4 14	 add	 esp, 20			; 00000014H

; 357  : 
; 358  : 		if (bUninstall == FALSE)

  001e3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bUninstall@@3HA, 0 ; bUninstall
  001ea	75 0f		 jne	 SHORT $LN34@DoFilesIns

; 359  : 			CopyMessage (hwndDlg, szTmp);

  001ec	8d 8c 24 98 01
	00 00		 lea	 ecx, DWORD PTR _szTmp$[esp+2852]
  001f3	51		 push	 ecx
  001f4	68 00 00 00 00	 push	 OFFSET ??_C@_0L@HHILBMI@INSTALLING?$AA@

; 360  : 		else

  001f9	eb 16		 jmp	 SHORT $LN162@DoFilesIns
$LN34@DoFilesIns:

; 361  : 			RemoveMessage (hwndDlg, szTmp);

  001fb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  00202	75 16		 jne	 SHORT $LN65@DoFilesIns
  00204	8d 94 24 98 01
	00 00		 lea	 edx, DWORD PTR _szTmp$[esp+2852]
  0020b	52		 push	 edx
  0020c	68 00 00 00 00	 push	 OFFSET ??_C@_08GLIOLGPM@REMOVING?$AA@
$LN162@DoFilesIns:
  00211	53		 push	 ebx
  00212	e8 00 00 00 00	 call	 _StatusMessageParam
  00217	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN65@DoFilesIns:

; 362  : 
; 363  : 		if (bUninstall == FALSE)

  0021a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bUninstall@@3HA, 0 ; bUninstall
  00221	0f 85 7f 03 00
	00		 jne	 $LN32@DoFilesIns

; 364  : 		{
; 365  : 			SetCurrentDirectory (SetupFilesDir);

  00227	68 00 00 00 00	 push	 OFFSET _SetupFilesDir
  0022c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCurrentDirectoryA@4

; 366  : 
; 367  : 			if (strstr (szFiles[i], "CipherShed-Setup") != 0)

  00232	8b 87 00 00 00
	00		 mov	 eax, DWORD PTR _szFiles[edi]
  00238	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@DDEACFEL@CipherShed?9Setup?$AA@
  0023d	50		 push	 eax
  0023e	e8 00 00 00 00	 call	 _strstr
  00243	83 c4 08	 add	 esp, 8
  00246	85 c0		 test	 eax, eax
  00248	74 2c		 je	 SHORT $LN31@DoFilesIns

; 368  : 			{
; 369  : 				// Copy ourselves (the distribution package) to the destination location as 'CipherShed-Setup.exe'
; 370  : 
; 371  : 				char mp[MAX_PATH];
; 372  : 
; 373  : 				GetModuleFileName (NULL, mp, sizeof (mp));

  0024a	68 04 01 00 00	 push	 260			; 00000104H
  0024f	8d 44 24 5c	 lea	 eax, DWORD PTR _mp$134186[esp+2856]
  00253	50		 push	 eax
  00254	6a 00		 push	 0
  00256	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12

; 374  : 				bResult = TCCopyFile (mp, szTmp);

  0025c	8d 8c 24 98 01
	00 00		 lea	 ecx, DWORD PTR _szTmp$[esp+2852]
  00263	51		 push	 ecx
  00264	8d 54 24 5c	 lea	 edx, DWORD PTR _mp$134186[esp+2856]
  00268	52		 push	 edx
  00269	e8 00 00 00 00	 call	 _TCCopyFile
  0026e	83 c4 08	 add	 esp, 8

; 375  : 			}
; 376  : 			else

  00271	e9 5b 03 00 00	 jmp	 $LN163@DoFilesIns
$LN31@DoFilesIns:

; 377  : 			{
; 378  : 				BOOL driver64 = FALSE;
; 379  : 
; 380  : 				strncpy (curFileName, szFiles[i] + 1, strlen (szFiles[i]) - 1);

  00276	8b 8f 00 00 00
	00		 mov	 ecx, DWORD PTR _szFiles[edi]
  0027c	8b c1		 mov	 eax, ecx
  0027e	33 db		 xor	 ebx, ebx
  00280	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$LL138@DoFilesIns:
  00283	8a 10		 mov	 dl, BYTE PTR [eax]
  00285	40		 inc	 eax
  00286	84 d2		 test	 dl, dl
  00288	75 f9		 jne	 SHORT $LL138@DoFilesIns
  0028a	2b c6		 sub	 eax, esi
  0028c	48		 dec	 eax
  0028d	50		 push	 eax
  0028e	41		 inc	 ecx
  0028f	51		 push	 ecx
  00290	8d 84 24 a4 02
	00 00		 lea	 eax, DWORD PTR _curFileName$[esp+2860]
  00297	50		 push	 eax
  00298	e8 00 00 00 00	 call	 _strncpy

; 381  : 				curFileName [strlen (szFiles[i]) - 1] = 0;

  0029d	8b 87 00 00 00
	00		 mov	 eax, DWORD PTR _szFiles[edi]
  002a3	83 c4 0c	 add	 esp, 12			; 0000000cH
  002a6	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  002a9	8d a4 24 00 00
	00 00		 npad	 7
$LL139@DoFilesIns:
  002b0	8a 08		 mov	 cl, BYTE PTR [eax]
  002b2	40		 inc	 eax
  002b3	84 c9		 test	 cl, cl
  002b5	75 f9		 jne	 SHORT $LL139@DoFilesIns
  002b7	2b c2		 sub	 eax, edx
  002b9	88 8c 04 9b 02
	00 00		 mov	 BYTE PTR _curFileName$[esp+eax+2851], cl

; 382  : 
; 383  : 				if (Is64BitOs ()
; 384  : 					&& strcmp (szFiles[i], "Dtruecrypt.sys") == 0)

  002c0	e8 00 00 00 00	 call	 _Is64BitOs
  002c5	85 c0		 test	 eax, eax
  002c7	74 4e		 je	 SHORT $LN159@DoFilesIns
  002c9	8b 87 00 00 00
	00		 mov	 eax, DWORD PTR _szFiles[edi]
  002cf	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0P@KPKCHNJD@Dtruecrypt?4sys?$AA@
$LL140@DoFilesIns:
  002d4	8a 10		 mov	 dl, BYTE PTR [eax]
  002d6	3a 11		 cmp	 dl, BYTE PTR [ecx]
  002d8	75 1a		 jne	 SHORT $LN141@DoFilesIns
  002da	84 d2		 test	 dl, dl
  002dc	74 12		 je	 SHORT $LN142@DoFilesIns
  002de	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  002e1	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  002e4	75 0e		 jne	 SHORT $LN141@DoFilesIns
  002e6	83 c0 02	 add	 eax, 2
  002e9	83 c1 02	 add	 ecx, 2
  002ec	84 d2		 test	 dl, dl
  002ee	75 e4		 jne	 SHORT $LL140@DoFilesIns
$LN142@DoFilesIns:
  002f0	33 c0		 xor	 eax, eax
  002f2	eb 05		 jmp	 SHORT $LN143@DoFilesIns
$LN141@DoFilesIns:
  002f4	1b c0		 sbb	 eax, eax
  002f6	83 d8 ff	 sbb	 eax, -1
$LN143@DoFilesIns:
  002f9	85 c0		 test	 eax, eax
  002fb	75 1a		 jne	 SHORT $LN159@DoFilesIns

; 385  : 				{
; 386  : 					driver64 = TRUE;
; 387  : 					strncpy (curFileName, FILENAME_64BIT_DRIVER, sizeof (FILENAME_64BIT_DRIVER));

  002fd	6a 12		 push	 18			; 00000012H
  002ff	8d 8c 24 a0 02
	00 00		 lea	 ecx, DWORD PTR _curFileName$[esp+2856]
  00306	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KMEHMKJJ@truecrypt?9x64?4sys?$AA@
  0030b	51		 push	 ecx
  0030c	8d 58 01	 lea	 ebx, DWORD PTR [eax+1]
  0030f	e8 00 00 00 00	 call	 _strncpy
  00314	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN159@DoFilesIns:

; 388  : 				}
; 389  : 
; 390  : 				if (!bDevm)

  00317	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bDevm, 0
  0031e	0f 85 7f 01 00
	00		 jne	 $LN28@DoFilesIns

; 391  : 				{
; 392  : 					bResult = FALSE;
; 393  : 
; 394  : 					// Find the correct decompressed file in memory
; 395  : 					for (fileNo = 0; fileNo < NBR_COMPRESSED_FILES; fileNo++)

  00324	33 ed		 xor	 ebp, ebp
  00326	33 ff		 xor	 edi, edi
  00328	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL27@DoFilesIns:

; 396  : 					{
; 397  : 						// Write the file (stored in memory) directly to the destination location 
; 398  : 						// (there will be no temporary files).
; 399  : 						if (memcmp (
; 400  : 							curFileName, 
; 401  : 							Decompressed_Files[fileNo].fileName, 
; 402  : 							min (strlen (curFileName), (size_t) Decompressed_Files[fileNo].fileNameLength)) == 0)

  00330	8d 84 24 9c 02
	00 00		 lea	 eax, DWORD PTR _curFileName$[esp+2852]
  00337	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0033a	8d 9b 00 00 00
	00		 npad	 6
$LL144@DoFilesIns:
  00340	8a 08		 mov	 cl, BYTE PTR [eax]
  00342	40		 inc	 eax
  00343	84 c9		 test	 cl, cl
  00345	75 f9		 jne	 SHORT $LL144@DoFilesIns
  00347	2b c2		 sub	 eax, edx
  00349	8b c8		 mov	 ecx, eax
  0034b	8b 87 04 00 00
	00		 mov	 eax, DWORD PTR _Decompressed_Files[edi+4]
  00351	3b c8		 cmp	 ecx, eax
  00353	73 14		 jae	 SHORT $LN55@DoFilesIns
  00355	8d 84 24 9c 02
	00 00		 lea	 eax, DWORD PTR _curFileName$[esp+2852]
  0035c	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0035f	90		 npad	 1
$LL145@DoFilesIns:
  00360	8a 08		 mov	 cl, BYTE PTR [eax]
  00362	40		 inc	 eax
  00363	84 c9		 test	 cl, cl
  00365	75 f9		 jne	 SHORT $LL145@DoFilesIns
  00367	2b c2		 sub	 eax, edx
$LN55@DoFilesIns:
  00369	8b 8f 00 00 00
	00		 mov	 ecx, DWORD PTR _Decompressed_Files[edi]
  0036f	8d b4 24 9c 02
	00 00		 lea	 esi, DWORD PTR _curFileName$[esp+2852]
  00376	83 f8 04	 cmp	 eax, 4
  00379	72 19		 jb	 SHORT $LN129@DoFilesIns
  0037b	eb 03 8d 49 00	 npad	 5
$LL58@DoFilesIns:
  00380	8b 16		 mov	 edx, DWORD PTR [esi]
  00382	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00384	75 32		 jne	 SHORT $LN26@DoFilesIns
  00386	83 e8 04	 sub	 eax, 4
  00389	83 c1 04	 add	 ecx, 4
  0038c	83 c6 04	 add	 esi, 4
  0038f	83 f8 04	 cmp	 eax, 4
  00392	73 ec		 jae	 SHORT $LL58@DoFilesIns
$LN129@DoFilesIns:
  00394	85 c0		 test	 eax, eax
  00396	74 32		 je	 SHORT $LN130@DoFilesIns
  00398	8a 11		 mov	 dl, BYTE PTR [ecx]
  0039a	3a 16		 cmp	 dl, BYTE PTR [esi]
  0039c	75 1a		 jne	 SHORT $LN26@DoFilesIns
  0039e	83 f8 01	 cmp	 eax, 1
  003a1	76 27		 jbe	 SHORT $LN130@DoFilesIns
  003a3	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  003a6	3a 56 01	 cmp	 dl, BYTE PTR [esi+1]
  003a9	75 0d		 jne	 SHORT $LN26@DoFilesIns
  003ab	83 f8 02	 cmp	 eax, 2
  003ae	76 1a		 jbe	 SHORT $LN130@DoFilesIns
  003b0	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  003b3	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  003b6	74 12		 je	 SHORT $LN130@DoFilesIns
$LN26@DoFilesIns:

; 391  : 				{
; 392  : 					bResult = FALSE;
; 393  : 
; 394  : 					// Find the correct decompressed file in memory
; 395  : 					for (fileNo = 0; fileNo < NBR_COMPRESSED_FILES; fileNo++)

  003b8	83 c7 14	 add	 edi, 20			; 00000014H
  003bb	45		 inc	 ebp
  003bc	83 ff 78	 cmp	 edi, 120		; 00000078H
  003bf	0f 82 6b ff ff
	ff		 jb	 $LL27@DoFilesIns

; 498  : 
; 499  : 			if (!Silent && MessageBoxW (hwndDlg, szTmp2, lpszTitle, MB_YESNO | MB_ICONHAND) != IDYES)

  003c5	e9 11 02 00 00	 jmp	 $LN135@DoFilesIns
$LN130@DoFilesIns:

; 403  : 						{
; 404  : 							// Dump filter driver cannot be installed to SysWOW64 directory
; 405  : 							if (driver64 && !EnableWow64FsRedirection (FALSE))

  003ca	85 db		 test	 ebx, ebx
  003cc	74 20		 je	 SHORT $LN152@DoFilesIns
  003ce	6a 00		 push	 0
  003d0	e8 00 00 00 00	 call	 _EnableWow64FsRedirection
  003d5	83 c4 04	 add	 esp, 4
  003d8	85 c0		 test	 eax, eax
  003da	75 12		 jne	 SHORT $LN152@DoFilesIns

; 406  : 							{
; 407  : 								handleWin32Error (hwndDlg);

  003dc	8b 4c 24 10	 mov	 ecx, DWORD PTR _hwndDlg$GSCopy$[esp+2852]
  003e0	51		 push	 ecx
  003e1	e8 00 00 00 00	 call	 _handleWin32Error
  003e6	83 c4 04	 add	 esp, 4

; 408  : 								bResult = FALSE;
; 409  : 								goto err;

  003e9	e9 ed 01 00 00	 jmp	 $LN135@DoFilesIns
$LN152@DoFilesIns:

; 410  : 							}
; 411  : 
; 412  : 							bResult = SaveBufferToFile (
; 413  : 								(char *) Decompressed_Files[fileNo].fileContent,
; 414  : 								szTmp,
; 415  : 								Decompressed_Files[fileNo].fileLength, 
; 416  : 								FALSE);

  003ee	8d 44 ad 00	 lea	 eax, DWORD PTR [ebp+ebp*4]
  003f2	03 c0		 add	 eax, eax
  003f4	8b 94 00 0c 00
	00 00		 mov	 edx, DWORD PTR _Decompressed_Files[eax+eax+12]
  003fb	03 c0		 add	 eax, eax
  003fd	6a 00		 push	 0
  003ff	52		 push	 edx
  00400	8b 90 10 00 00
	00		 mov	 edx, DWORD PTR _Decompressed_Files[eax+16]
  00406	8d 8c 24 a0 01
	00 00		 lea	 ecx, DWORD PTR _szTmp$[esp+2860]
  0040d	51		 push	 ecx
  0040e	52		 push	 edx
  0040f	e8 00 00 00 00	 call	 _SaveBufferToFile
  00414	83 c4 10	 add	 esp, 16			; 00000010H
  00417	8b f0		 mov	 esi, eax

; 417  : 
; 418  : 							if (driver64)

  00419	85 db		 test	 ebx, ebx
  0041b	0f 84 b8 00 00
	00		 je	 $LN11@DoFilesIns

; 419  : 							{
; 420  : 								if (!EnableWow64FsRedirection (TRUE))

  00421	6a 01		 push	 1
  00423	e8 00 00 00 00	 call	 _EnableWow64FsRedirection
  00428	83 c4 04	 add	 esp, 4
  0042b	85 c0		 test	 eax, eax
  0042d	75 12		 jne	 SHORT $LN20@DoFilesIns

; 421  : 								{
; 422  : 									handleWin32Error (hwndDlg);

  0042f	8b 44 24 10	 mov	 eax, DWORD PTR _hwndDlg$GSCopy$[esp+2852]
  00433	50		 push	 eax
  00434	e8 00 00 00 00	 call	 _handleWin32Error
  00439	83 c4 04	 add	 esp, 4

; 423  : 									bResult = FALSE;
; 424  : 									goto err;

  0043c	e9 9a 01 00 00	 jmp	 $LN135@DoFilesIns
$LN20@DoFilesIns:

; 425  : 								}
; 426  : 
; 427  : 								if (!bResult)

  00441	85 f6		 test	 esi, esi
  00443	0f 84 92 01 00
	00		 je	 $LN135@DoFilesIns

; 428  : 									goto err;
; 429  : 
; 430  : 								if (bUpgrade && InstalledVersion < 0x700)

  00449	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bUpgrade, 0
  00450	0f 84 83 00 00
	00		 je	 $LN11@DoFilesIns
  00456	81 3d 00 00 00
	00 00 07 00 00	 cmp	 DWORD PTR ?InstalledVersion@@3JA, 1792 ; InstalledVersion, 00000700H
  00460	7d 77		 jge	 SHORT $LN11@DoFilesIns

; 431  : 								{
; 432  : 									bResult = WriteLocalMachineRegistryString ("SYSTEM\\CurrentControlSet\\Services\\truecrypt", "ImagePath", "System32\\drivers\\truecrypt.sys", TRUE);

  00462	6a 01		 push	 1
  00464	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@MGAEPBHO@System32?2drivers?2truecrypt?4sys?$AA@
  00469	68 00 00 00 00	 push	 OFFSET ??_C@_09JMMKOPDJ@ImagePath?$AA@
  0046e	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@CEEDGJNL@SYSTEM?2CurrentControlSet?2Service@
  00473	e8 00 00 00 00	 call	 _WriteLocalMachineRegistryString
  00478	8b f0		 mov	 esi, eax
  0047a	83 c4 10	 add	 esp, 16			; 00000010H

; 433  : 									if (!bResult)

  0047d	85 f6		 test	 esi, esi
  0047f	75 12		 jne	 SHORT $LN15@DoFilesIns

; 434  : 									{
; 435  : 										handleWin32Error (hwndDlg);

  00481	8b 4c 24 10	 mov	 ecx, DWORD PTR _hwndDlg$GSCopy$[esp+2852]
  00485	51		 push	 ecx
  00486	e8 00 00 00 00	 call	 _handleWin32Error
  0048b	83 c4 04	 add	 esp, 4

; 436  : 										goto err;

  0048e	e9 40 01 00 00	 jmp	 $err$134198
$LN15@DoFilesIns:

; 437  : 									}
; 438  : 
; 439  : 									DeleteFile (szTmp);

  00493	8d 94 24 98 01
	00 00		 lea	 edx, DWORD PTR _szTmp$[esp+2852]
  0049a	52		 push	 edx
  0049b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteFileA@4

; 440  : 								}
; 441  : 							}
; 442  : 
; 443  : 							break;
; 444  : 						}
; 445  : 					}
; 446  : 				}
; 447  : 				else

  004a1	eb 36		 jmp	 SHORT $LN11@DoFilesIns
$LN28@DoFilesIns:

; 448  : 				{
; 449  : 					if (driver64)

  004a3	85 db		 test	 ebx, ebx
  004a5	74 0a		 je	 SHORT $LN12@DoFilesIns

; 450  : 						EnableWow64FsRedirection (FALSE);

  004a7	6a 00		 push	 0
  004a9	e8 00 00 00 00	 call	 _EnableWow64FsRedirection
  004ae	83 c4 04	 add	 esp, 4
$LN12@DoFilesIns:

; 451  : 
; 452  : 					bResult = TCCopyFile (curFileName, szTmp);

  004b1	8d 84 24 98 01
	00 00		 lea	 eax, DWORD PTR _szTmp$[esp+2852]
  004b8	50		 push	 eax
  004b9	8d 8c 24 a0 02
	00 00		 lea	 ecx, DWORD PTR _curFileName$[esp+2856]
  004c0	51		 push	 ecx
  004c1	e8 00 00 00 00	 call	 _TCCopyFile
  004c6	83 c4 08	 add	 esp, 8
  004c9	8b f0		 mov	 esi, eax

; 453  : 
; 454  : 					if (driver64)

  004cb	85 db		 test	 ebx, ebx
  004cd	74 0a		 je	 SHORT $LN11@DoFilesIns

; 455  : 						EnableWow64FsRedirection (TRUE);

  004cf	6a 01		 push	 1
  004d1	e8 00 00 00 00	 call	 _EnableWow64FsRedirection
  004d6	83 c4 04	 add	 esp, 4
$LN11@DoFilesIns:

; 456  : 				}
; 457  : 
; 458  : 				if (bResult && strcmp (szFiles[i], "ACipherShed.exe") == 0)

  004d9	85 f6		 test	 esi, esi
  004db	0f 84 fa 00 00
	00		 je	 $LN135@DoFilesIns
  004e1	8b 54 24 14	 mov	 edx, DWORD PTR tv835[esp+2852]
  004e5	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _szFiles[edx]
  004eb	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BA@BPJBGDOM@ACipherShed?4exe?$AA@
$LL146@DoFilesIns:
  004f0	8a 10		 mov	 dl, BYTE PTR [eax]
  004f2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  004f4	75 1a		 jne	 SHORT $LN147@DoFilesIns
  004f6	84 d2		 test	 dl, dl
  004f8	74 12		 je	 SHORT $LN148@DoFilesIns
  004fa	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  004fd	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00500	75 0e		 jne	 SHORT $LN147@DoFilesIns
  00502	83 c0 02	 add	 eax, 2
  00505	83 c1 02	 add	 ecx, 2
  00508	84 d2		 test	 dl, dl
  0050a	75 e4		 jne	 SHORT $LL146@DoFilesIns
$LN148@DoFilesIns:
  0050c	33 c0		 xor	 eax, eax
  0050e	eb 05		 jmp	 SHORT $LN149@DoFilesIns
$LN147@DoFilesIns:
  00510	1b c0		 sbb	 eax, eax
  00512	83 d8 ff	 sbb	 eax, -1
$LN149@DoFilesIns:
  00515	85 c0		 test	 eax, eax
  00517	0f 85 b6 00 00
	00		 jne	 $err$134198

; 459  : 				{
; 460  : 					string servicePath = GetServiceConfigPath (TC_APP_NAME ".exe");

  0051d	8d 44 24 20	 lea	 eax, DWORD PTR _servicePath$134216[esp+2852]
  00521	68 00 00 00 00	 push	 OFFSET ??_C@_0P@KEOPEMDF@CipherShed?4exe?$AA@
  00526	50		 push	 eax
  00527	e8 00 00 00 00	 call	 ?GetServiceConfigPath@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; GetServiceConfigPath

; 461  : 					if (FileExists (servicePath.c_str()))

  0052c	8b 44 24 2c	 mov	 eax, DWORD PTR _servicePath$134216[esp+2864]
  00530	bf 10 00 00 00	 mov	 edi, 16			; 00000010H
  00535	83 c4 08	 add	 esp, 8
  00538	39 7c 24 38	 cmp	 DWORD PTR _servicePath$134216[esp+2876], edi
  0053c	73 04		 jae	 SHORT $LN75@DoFilesIns
  0053e	8d 44 24 24	 lea	 eax, DWORD PTR _servicePath$134216[esp+2856]
$LN75@DoFilesIns:
  00542	50		 push	 eax
  00543	e8 00 00 00 00	 call	 _FileExists
  00548	83 c4 04	 add	 esp, 4
  0054b	85 c0		 test	 eax, eax
  0054d	74 42		 je	 SHORT $LN9@DoFilesIns

; 462  : 					{
; 463  : 						CopyMessage (hwndDlg, (char *) servicePath.c_str());

  0054f	8b 44 24 24	 mov	 eax, DWORD PTR _servicePath$134216[esp+2856]
  00553	39 7c 24 38	 cmp	 DWORD PTR _servicePath$134216[esp+2876], edi
  00557	73 04		 jae	 SHORT $LN81@DoFilesIns
  00559	8d 44 24 24	 lea	 eax, DWORD PTR _servicePath$134216[esp+2856]
$LN81@DoFilesIns:
  0055d	8b 4c 24 10	 mov	 ecx, DWORD PTR _hwndDlg$GSCopy$[esp+2852]
  00561	50		 push	 eax
  00562	68 00 00 00 00	 push	 OFFSET ??_C@_0L@HHILBMI@INSTALLING?$AA@
  00567	51		 push	 ecx
  00568	e8 00 00 00 00	 call	 _StatusMessageParam

; 464  : 						bResult = CopyFile (szTmp, servicePath.c_str(), FALSE);

  0056d	8b 44 24 30	 mov	 eax, DWORD PTR _servicePath$134216[esp+2868]
  00571	83 c4 0c	 add	 esp, 12			; 0000000cH
  00574	39 7c 24 38	 cmp	 DWORD PTR _servicePath$134216[esp+2876], edi
  00578	73 04		 jae	 SHORT $LN89@DoFilesIns
  0057a	8d 44 24 24	 lea	 eax, DWORD PTR _servicePath$134216[esp+2856]
$LN89@DoFilesIns:
  0057e	6a 00		 push	 0
  00580	50		 push	 eax
  00581	8d 94 24 a0 01
	00 00		 lea	 edx, DWORD PTR _szTmp$[esp+2860]
  00588	52		 push	 edx
  00589	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CopyFileA@12
  0058f	8b f0		 mov	 esi, eax
$LN9@DoFilesIns:

; 465  : 					}
; 466  : 				}

  00591	39 7c 24 38	 cmp	 DWORD PTR _servicePath$134216[esp+2876], edi
  00595	72 3c		 jb	 SHORT $err$134198
  00597	8b 44 24 24	 mov	 eax, DWORD PTR _servicePath$134216[esp+2856]
  0059b	50		 push	 eax
  0059c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  005a1	83 c4 04	 add	 esp, 4

; 467  : 			}
; 468  : 		}
; 469  : 		else

  005a4	eb 2d		 jmp	 SHORT $err$134198
$LN32@DoFilesIns:

; 470  : 		{
; 471  : 			bResult = StatDeleteFile (szTmp);

  005a6	8d 4c 24 20	 lea	 ecx, DWORD PTR _st$140236[esp+2852]
  005aa	51		 push	 ecx
  005ab	8d 94 24 9c 01
	00 00		 lea	 edx, DWORD PTR _szTmp$[esp+2856]
  005b2	52		 push	 edx
  005b3	e8 00 00 00 00	 call	 __stat64
  005b8	83 c4 08	 add	 esp, 8
  005bb	85 c0		 test	 eax, eax
  005bd	0f 85 b6 00 00
	00		 jne	 $LN150@DoFilesIns
  005c3	8d 84 24 98 01
	00 00		 lea	 eax, DWORD PTR _szTmp$[esp+2852]
  005ca	50		 push	 eax
  005cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteFileA@4
$LN163@DoFilesIns:
  005d1	8b f0		 mov	 esi, eax
$err$134198:

; 472  : 		}
; 473  : 
; 474  : err:
; 475  : 		if (bResult == FALSE)

  005d3	85 f6		 test	 esi, esi
  005d5	0f 85 96 00 00
	00		 jne	 $LN155@DoFilesIns
$LN135@DoFilesIns:

; 476  : 		{
; 477  : 			LPVOID lpMsgBuf;
; 478  : 			DWORD dwError = GetLastError ();

  005db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 479  : 			wchar_t szTmp2[700];
; 480  : 
; 481  : 			FormatMessage (
; 482  : 					      FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
; 483  : 					      NULL,
; 484  : 					      dwError,
; 485  : 				 MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT),	/* Default language */
; 486  : 					      (char *) &lpMsgBuf,
; 487  : 					      0,
; 488  : 					      NULL
; 489  : 				);

  005e1	6a 00		 push	 0
  005e3	6a 00		 push	 0
  005e5	8d 4c 24 24	 lea	 ecx, DWORD PTR _lpMsgBuf$134222[esp+2860]
  005e9	51		 push	 ecx
  005ea	68 00 04 00 00	 push	 1024			; 00000400H
  005ef	50		 push	 eax
  005f0	6a 00		 push	 0
  005f2	68 00 11 00 00	 push	 4352			; 00001100H
  005f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FormatMessageA@28

; 490  : 
; 491  : 
; 492  : 			if (bUninstall == FALSE)

  005fd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bUninstall@@3HA, 0 ; bUninstall

; 493  : 				wsprintfW (szTmp2, GetString ("INSTALL_OF_FAILED"), szTmp, lpMsgBuf);

  00604	8b 54 24 1c	 mov	 edx, DWORD PTR _lpMsgBuf$134222[esp+2852]
  00608	8d 84 24 98 01
	00 00		 lea	 eax, DWORD PTR _szTmp$[esp+2852]
  0060f	52		 push	 edx
  00610	50		 push	 eax
  00611	75 07		 jne	 SHORT $LN6@DoFilesIns
  00613	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@MNFHJDAJ@INSTALL_OF_FAILED?$AA@

; 494  : 			else

  00618	eb 05		 jmp	 SHORT $LN164@DoFilesIns
$LN6@DoFilesIns:

; 495  : 				wsprintfW (szTmp2, GetString ("UNINSTALL_OF_FAILED"), szTmp, lpMsgBuf);

  0061a	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@ICFIOGFL@UNINSTALL_OF_FAILED?$AA@
$LN164@DoFilesIns:
  0061f	e8 00 00 00 00	 call	 _GetString
  00624	83 c4 04	 add	 esp, 4
  00627	50		 push	 eax
  00628	8d 8c 24 b4 05
	00 00		 lea	 ecx, DWORD PTR _szTmp2$134224[esp+2864]
  0062f	51		 push	 ecx
  00630	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfW

; 496  : 
; 497  : 			LocalFree (lpMsgBuf);

  00636	8b 54 24 2c	 mov	 edx, DWORD PTR _lpMsgBuf$134222[esp+2868]
  0063a	83 c4 10	 add	 esp, 16			; 00000010H
  0063d	52		 push	 edx
  0063e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalFree@4

; 498  : 
; 499  : 			if (!Silent && MessageBoxW (hwndDlg, szTmp2, lpszTitle, MB_YESNO | MB_ICONHAND) != IDYES)

  00644	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  0064b	75 24		 jne	 SHORT $LN155@DoFilesIns
  0064d	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  00652	8b 54 24 10	 mov	 edx, DWORD PTR _hwndDlg$GSCopy$[esp+2852]
  00656	6a 14		 push	 20			; 00000014H
  00658	50		 push	 eax
  00659	8d 8c 24 b0 05
	00 00		 lea	 ecx, DWORD PTR _szTmp2$134224[esp+2860]
  00660	51		 push	 ecx
  00661	52		 push	 edx
  00662	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
  00668	83 f8 06	 cmp	 eax, 6
  0066b	0f 85 47 01 00
	00		 jne	 $LN131@DoFilesIns
$LN155@DoFilesIns:
  00671	8b 7c 24 14	 mov	 edi, DWORD PTR tv835[esp+2852]
  00675	8b 74 24 18	 mov	 esi, DWORD PTR _szDestDir$GSCopy$[esp+2852]
$LN150@DoFilesIns:
  00679	8b 5c 24 10	 mov	 ebx, DWORD PTR _hwndDlg$GSCopy$[esp+2852]
$LN46@DoFilesIns:

; 323  : 
; 324  : 	for (i = 0; i < sizeof (szFiles) / sizeof (szFiles[0]); i++)

  0067d	83 c7 04	 add	 edi, 4
  00680	89 7c 24 14	 mov	 DWORD PTR tv835[esp+2852], edi
  00684	83 ff 20	 cmp	 edi, 32			; 00000020H
  00687	0f 82 44 fa ff
	ff		 jb	 $LL156@DoFilesIns

; 501  : 		}
; 502  : 	}
; 503  : 
; 504  : 	// Language pack
; 505  : 	if (bUninstall == FALSE)

  0068d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bUninstall@@3HA, 0 ; bUninstall
  00694	0f 85 00 01 00
	00		 jne	 $LN3@DoFilesIns

; 506  : 	{
; 507  : 		WIN32_FIND_DATA f;
; 508  : 		HANDLE h;
; 509  : 		
; 510  : 		SetCurrentDirectory (SetupFilesDir);

  0069a	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__SetCurrentDirectoryA@4
  006a0	68 00 00 00 00	 push	 OFFSET _SetupFilesDir
  006a5	ff d5		 call	 ebp

; 511  : 		h = FindFirstFile ("Language.*.xml", &f);

  006a7	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__FindFirstFileA@8
  006ad	8d 44 24 58	 lea	 eax, DWORD PTR _f$134234[esp+2852]
  006b1	50		 push	 eax
  006b2	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GPPOMBKF@Language?4?$CK?4xml?$AA@
  006b7	ff d3		 call	 ebx

; 512  : 
; 513  : 		if (h != INVALID_HANDLE_VALUE)

  006b9	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__FindClose@4
  006bf	8b f0		 mov	 esi, eax
  006c1	83 fe ff	 cmp	 esi, -1
  006c4	74 56		 je	 SHORT $LN151@DoFilesIns

; 514  : 		{
; 515  : 			char d[MAX_PATH*2];
; 516  : 			snprintf (d, sizeof(d), "%s%s", szDestDir, f.cFileName);

  006c6	8b 54 24 18	 mov	 edx, DWORD PTR _szDestDir$GSCopy$[esp+2852]
  006ca	8d 8c 24 84 00
	00 00		 lea	 ecx, DWORD PTR _f$134234[esp+2896]
  006d1	51		 push	 ecx
  006d2	52		 push	 edx
  006d3	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  006d8	8d 84 24 ac 03
	00 00		 lea	 eax, DWORD PTR _d$134240[esp+2864]
  006df	68 08 02 00 00	 push	 520			; 00000208H
  006e4	50		 push	 eax
  006e5	e8 00 00 00 00	 call	 _sprintf_s

; 517  : 			CopyMessage (hwndDlg, d);

  006ea	8b 54 24 24	 mov	 edx, DWORD PTR _hwndDlg$GSCopy$[esp+2872]
  006ee	8d 8c 24 b4 03
	00 00		 lea	 ecx, DWORD PTR _d$134240[esp+2872]
  006f5	51		 push	 ecx
  006f6	68 00 00 00 00	 push	 OFFSET ??_C@_0L@HHILBMI@INSTALLING?$AA@
  006fb	52		 push	 edx
  006fc	e8 00 00 00 00	 call	 _StatusMessageParam

; 518  : 			TCCopyFile (f.cFileName, d);

  00701	8d 84 24 c0 03
	00 00		 lea	 eax, DWORD PTR _d$134240[esp+2884]
  00708	50		 push	 eax
  00709	8d 8c 24 a8 00
	00 00		 lea	 ecx, DWORD PTR _f$134234[esp+2932]
  00710	51		 push	 ecx
  00711	e8 00 00 00 00	 call	 _TCCopyFile
  00716	83 c4 28	 add	 esp, 40			; 00000028H

; 519  : 			FindClose (h);

  00719	56		 push	 esi
  0071a	ff d7		 call	 edi
$LN151@DoFilesIns:

; 520  : 		}
; 521  : 
; 522  : 		SetCurrentDirectory (SetupFilesDir);

  0071c	68 00 00 00 00	 push	 OFFSET _SetupFilesDir
  00721	ff d5		 call	 ebp

; 523  : 		SetCurrentDirectory ("Setup files");

  00723	68 00 00 00 00	 push	 OFFSET ??_C@_0M@LJEGBCFM@Setup?5files?$AA@
  00728	ff d5		 call	 ebp

; 524  : 		h = FindFirstFile ("CipherShed User Guide.*.pdf", &f);

  0072a	8d 54 24 58	 lea	 edx, DWORD PTR _f$134234[esp+2852]
  0072e	52		 push	 edx
  0072f	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@NGMAPMJP@CipherShed?5User?5Guide?4?$CK?4pdf?$AA@
  00734	ff d3		 call	 ebx
  00736	8b f0		 mov	 esi, eax

; 525  : 		if (h != INVALID_HANDLE_VALUE)

  00738	83 fe ff	 cmp	 esi, -1
  0073b	74 56		 je	 SHORT $LN1@DoFilesIns

; 526  : 		{
; 527  : 			char d[MAX_PATH*2];
; 528  : 			snprintf (d, sizeof(d), "%s%s", szDestDir, f.cFileName);

  0073d	8b 4c 24 18	 mov	 ecx, DWORD PTR _szDestDir$GSCopy$[esp+2852]
  00741	8d 84 24 84 00
	00 00		 lea	 eax, DWORD PTR _f$134234[esp+2896]
  00748	50		 push	 eax
  00749	51		 push	 ecx
  0074a	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  0074f	8d 94 24 ac 03
	00 00		 lea	 edx, DWORD PTR _d$134251[esp+2864]
  00756	68 08 02 00 00	 push	 520			; 00000208H
  0075b	52		 push	 edx
  0075c	e8 00 00 00 00	 call	 _sprintf_s

; 529  : 			CopyMessage (hwndDlg, d);

  00761	8b 4c 24 24	 mov	 ecx, DWORD PTR _hwndDlg$GSCopy$[esp+2872]
  00765	8d 84 24 b4 03
	00 00		 lea	 eax, DWORD PTR _d$134251[esp+2872]
  0076c	50		 push	 eax
  0076d	68 00 00 00 00	 push	 OFFSET ??_C@_0L@HHILBMI@INSTALLING?$AA@
  00772	51		 push	 ecx
  00773	e8 00 00 00 00	 call	 _StatusMessageParam

; 530  : 			TCCopyFile (f.cFileName, d);

  00778	8d 94 24 c0 03
	00 00		 lea	 edx, DWORD PTR _d$134251[esp+2884]
  0077f	52		 push	 edx
  00780	8d 84 24 a8 00
	00 00		 lea	 eax, DWORD PTR _f$134234[esp+2932]
  00787	50		 push	 eax
  00788	e8 00 00 00 00	 call	 _TCCopyFile
  0078d	83 c4 28	 add	 esp, 40			; 00000028H

; 531  : 			FindClose (h);

  00790	56		 push	 esi
  00791	ff d7		 call	 edi
$LN1@DoFilesIns:

; 532  : 		}
; 533  : 		SetCurrentDirectory (SetupFilesDir);

  00793	68 00 00 00 00	 push	 OFFSET _SetupFilesDir
  00798	ff d5		 call	 ebp
$LN3@DoFilesIns:

; 534  : 	}
; 535  : 
; 536  : 	return bOK;

  0079a	b8 01 00 00 00	 mov	 eax, 1
$LN161@DoFilesIns:

; 537  : }

  0079f	8b 8c 24 20 0b
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+2852]
  007a6	5d		 pop	 ebp
  007a7	5f		 pop	 edi
  007a8	5e		 pop	 esi
  007a9	5b		 pop	 ebx
  007aa	33 cc		 xor	 ecx, esp
  007ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007b1	81 c4 14 0b 00
	00		 add	 esp, 2836		; 00000b14H
  007b7	c3		 ret	 0
$LN131@DoFilesIns:

; 500  : 				return FALSE;

  007b8	33 c0		 xor	 eax, eax
  007ba	eb e3		 jmp	 SHORT $LN161@DoFilesIns
_DoFilesInstall ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DP@MNNFDDNO@?3loop?6del?5?$CC?$CFs?$CFs?$CC?6if?5exist?5?$CC?$CFs?$CFs?$CC@ ; `string'
PUBLIC	??_C@_0BM@DOLMKHMK@?$CFs?2CipherShed?9Uninstall?4bat?$AA@ ; `string'
PUBLIC	??_C@_0BB@FKFJCDPE@TrueCryptService?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_DoUninstall
EXTRN	_NormalCursor:PROC
EXTRN	__imp__GetTempPathA@8:PROC
EXTRN	_WaitCursor:PROC
;	COMDAT ??_C@_0DP@MNNFDDNO@?3loop?6del?5?$CC?$CFs?$CFs?$CC?6if?5exist?5?$CC?$CFs?$CFs?$CC@
CONST	SEGMENT
??_C@_0DP@MNNFDDNO@?3loop?6del?5?$CC?$CFs?$CFs?$CC?6if?5exist?5?$CC?$CFs?$CFs?$CC@ DB ':'
	DB	'loop', 0aH, 'del "%s%s"', 0aH, 'if exist "%s%s" goto loop', 0aH
	DB	'rmdir "%s"', 0aH, 'del "%s"', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DOLMKHMK@?$CFs?2CipherShed?9Uninstall?4bat?$AA@
CONST	SEGMENT
??_C@_0BM@DOLMKHMK@?$CFs?2CipherShed?9Uninstall?4bat?$AA@ DB '%s\CipherSh'
	DB	'ed-Uninstall.bat', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FKFJCDPE@TrueCryptService?$AA@
CONST	SEGMENT
??_C@_0BB@FKFJCDPE@TrueCryptService?$AA@ DB 'TrueCryptService', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _DoUninstall
_TEXT	SEGMENT
_bTempSkipSysRestore$ = -268				; size = 4
_temp$134828 = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_arg$ = 8						; size = 4
_DoUninstall PROC					; COMDAT

; 1690 : {

  00000	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 08 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+268], eax

; 1691 : 	HWND hwndDlg = (HWND) arg;
; 1692 : 	BOOL bOK = TRUE;
; 1693 : 	BOOL bTempSkipSysRestore = FALSE;
; 1694 : 
; 1695 : 	if (!Rollback)

  00014	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  0001b	55		 push	 ebp
  0001c	56		 push	 esi
  0001d	8b b4 24 18 01
	00 00		 mov	 esi, DWORD PTR _arg$[esp+272]
  00024	bd 01 00 00 00	 mov	 ebp, 1
  00029	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR _bTempSkipSysRestore$[esp+276], 0
  00031	75 15		 jne	 SHORT $LN27@DoUninstal

; 1696 : 		EnableWindow (GetDlgItem ((HWND) hwndDlg, IDC_UNINSTALL), FALSE);

  00033	6a 00		 push	 0
  00035	68 f7 03 00 00	 push	 1015			; 000003f7H
  0003a	56		 push	 esi
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00041	50		 push	 eax
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8
$LN27@DoUninstal:

; 1697 : 
; 1698 : 	WaitCursor ();

  00048	e8 00 00 00 00	 call	 _WaitCursor

; 1699 : 
; 1700 : 	if (!Rollback)

  0004d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  00054	75 1c		 jne	 SHORT $LN24@DoUninstal

; 1701 : 	{
; 1702 : 		ClearLogWindow (hwndDlg);

  00056	6a 00		 push	 0
  00058	6a 00		 push	 0
  0005a	68 84 01 00 00	 push	 388			; 00000184H
  0005f	68 f9 03 00 00	 push	 1017			; 000003f9H
  00064	56		 push	 esi
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0006b	50		 push	 eax
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
$LN24@DoUninstal:

; 1703 : 	}
; 1704 : 
; 1705 : 	/* Unload the kernel driver. */
; 1706 : 	if (DoDriverUnload (hwndDlg) == FALSE)

  00072	56		 push	 esi
  00073	e8 00 00 00 00	 call	 _DoDriverUnload
  00078	83 c4 04	 add	 esp, 4
  0007b	85 c0		 test	 eax, eax
  0007d	75 0f		 jne	 SHORT $LN19@DoUninstal

; 1707 : 	{
; 1708 : 		bOK = FALSE;

  0007f	33 ed		 xor	 ebp, ebp

; 1709 : 		bTempSkipSysRestore = TRUE;		// Volumes are possibly mounted; defer System Restore point creation for this uninstall attempt.

  00081	c7 44 24 08 01
	00 00 00	 mov	 DWORD PTR _bTempSkipSysRestore$[esp+276], 1

; 1710 : 	}
; 1711 : 	else

  00089	e9 2a 01 00 00	 jmp	 $LN5@DoUninstal
$LN19@DoUninstal:

; 1712 : 	{
; 1713 : 		/* Begin system change. */
; 1714 : 		if (!Rollback && bSystemRestore && !bTempSkipSysRestore)

  0008e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  00095	75 13		 jne	 SHORT $LN17@DoUninstal
  00097	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bSystemRestore, 0
  0009e	74 0a		 je	 SHORT $LN17@DoUninstal

; 1715 : 			SetSystemRestorePoint (hwndDlg, FALSE);

  000a0	6a 00		 push	 0
  000a2	e8 00 00 00 00	 call	 ?SetSystemRestorePoint@@YAXPAUHWND__@@H@Z ; SetSystemRestorePoint
  000a7	83 c4 04	 add	 esp, 4
$LN17@DoUninstal:

; 1716 : 
; 1717 : 		/* Uninstall the kernel driver. */
; 1718 : 		if (DoServiceUninstall (hwndDlg, "truecrypt") == FALSE)

  000aa	68 00 00 00 00	 push	 OFFSET ??_C@_09EFLFAGB@truecrypt?$AA@
  000af	56		 push	 esi
  000b0	e8 00 00 00 00	 call	 _DoServiceUninstall
  000b5	83 c4 08	 add	 esp, 8
  000b8	85 c0		 test	 eax, eax
  000ba	75 07		 jne	 SHORT $LN16@DoUninstal

; 1719 : 		{
; 1720 : 			bOK = FALSE;

  000bc	33 ed		 xor	 ebp, ebp
  000be	e9 f5 00 00 00	 jmp	 $LN5@DoUninstal
$LN16@DoUninstal:

; 1721 : 		}
; 1722 : 		/* Uninstall registry keys. */
; 1723 : 		else if (DoRegUninstall ((HWND) hwndDlg, FALSE) == FALSE)

  000c3	6a 00		 push	 0
  000c5	56		 push	 esi
  000c6	e8 00 00 00 00	 call	 _DoRegUninstall
  000cb	83 c4 08	 add	 esp, 8
  000ce	85 c0		 test	 eax, eax
  000d0	75 07		 jne	 SHORT $LN14@DoUninstal

; 1724 : 		{
; 1725 : 			bOK = FALSE;

  000d2	33 ed		 xor	 ebp, ebp
  000d4	e9 df 00 00 00	 jmp	 $LN5@DoUninstal
$LN14@DoUninstal:

; 1726 : 		}
; 1727 : 		/* Remove files. */
; 1728 : 		else if (DoFilesInstall ((HWND) hwndDlg, UninstallationPath) == FALSE)

  000d9	68 00 00 00 00	 push	 OFFSET ?UninstallationPath@@3PADA ; UninstallationPath
  000de	56		 push	 esi
  000df	e8 00 00 00 00	 call	 _DoFilesInstall
  000e4	83 c4 08	 add	 esp, 8
  000e7	85 c0		 test	 eax, eax
  000e9	75 07		 jne	 SHORT $LN12@DoUninstal

; 1729 : 		{
; 1730 : 			bOK = FALSE;

  000eb	33 ed		 xor	 ebp, ebp
  000ed	e9 c6 00 00 00	 jmp	 $LN5@DoUninstal
$LN12@DoUninstal:

; 1731 : 		}
; 1732 : 		/* Remove desktop and startmenu shortcuts. */
; 1733 : 		else if (DoShortcutsUninstall (hwndDlg, UninstallationPath) == FALSE)

  000f2	68 00 00 00 00	 push	 OFFSET ?UninstallationPath@@3PADA ; UninstallationPath
  000f7	56		 push	 esi
  000f8	e8 00 00 00 00	 call	 _DoShortcutsUninstall
  000fd	83 c4 08	 add	 esp, 8
  00100	85 c0		 test	 eax, eax
  00102	75 07		 jne	 SHORT $LN10@DoUninstal

; 1734 : 		{
; 1735 : 			bOK = FALSE;

  00104	33 ed		 xor	 ebp, ebp
  00106	e9 ad 00 00 00	 jmp	 $LN5@DoUninstal
$LN10@DoUninstal:

; 1736 : 		}
; 1737 : 		/* Remove configs. */
; 1738 : 		else if (!DoApplicationDataUninstall (hwndDlg))

  0010b	56		 push	 esi
  0010c	e8 00 00 00 00	 call	 ?DoApplicationDataUninstall@@YAHPAUHWND__@@@Z ; DoApplicationDataUninstall
  00111	83 c4 04	 add	 esp, 4
  00114	85 c0		 test	 eax, eax
  00116	75 07		 jne	 SHORT $LN8@DoUninstal

; 1739 : 		{
; 1740 : 			bOK = FALSE;

  00118	33 ed		 xor	 ebp, ebp

; 1741 : 		}
; 1742 : 		else

  0011a	e9 99 00 00 00	 jmp	 $LN5@DoUninstal
$LN8@DoUninstal:
  0011f	57		 push	 edi

; 1743 : 		{
; 1744 : 			char temp[MAX_PATH];
; 1745 : 			FILE *f;
; 1746 : 
; 1747 : 			/* Remove driver with deprecated name. */
; 1748 : 			DoServiceUninstall (hwndDlg, "TrueCryptService");

  00120	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FKFJCDPE@TrueCryptService?$AA@
  00125	56		 push	 esi
  00126	e8 00 00 00 00	 call	 _DoServiceUninstall
  0012b	83 c4 08	 add	 esp, 8

; 1749 : 
; 1750 : 			GetTempPath (sizeof (temp), temp);

  0012e	8d 44 24 10	 lea	 eax, DWORD PTR _temp$134828[esp+280]
  00132	50		 push	 eax
  00133	68 04 01 00 00	 push	 260			; 00000104H
  00138	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTempPathA@8

; 1751 : 			_snprintf (UninstallBatch, sizeof (UninstallBatch), "%s\\CipherShed-Uninstall.bat", temp);

  0013e	8d 4c 24 10	 lea	 ecx, DWORD PTR _temp$134828[esp+280]
  00142	51		 push	 ecx
  00143	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@DOLMKHMK@?$CFs?2CipherShed?9Uninstall?4bat?$AA@
  00148	68 04 01 00 00	 push	 260			; 00000104H
  0014d	68 00 00 00 00	 push	 OFFSET ?UninstallBatch@@3PADA ; UninstallBatch
  00152	e8 00 00 00 00	 call	 __snprintf

; 1752 : 
; 1753 : 			UninstallBatch [sizeof(UninstallBatch)-1] = 0;
; 1754 : 
; 1755 : 			// Create uninstall batch
; 1756 : 			f = fopen (UninstallBatch, "w");

  00157	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  0015c	68 00 00 00 00	 push	 OFFSET ?UninstallBatch@@3PADA ; UninstallBatch
  00161	c6 05 03 01 00
	00 00		 mov	 BYTE PTR ?UninstallBatch@@3PADA+259, 0
  00168	e8 00 00 00 00	 call	 _fopen
  0016d	8b f8		 mov	 edi, eax
  0016f	83 c4 18	 add	 esp, 24			; 00000018H

; 1757 : 			if (!f)

  00172	85 ff		 test	 edi, edi
  00174	75 04		 jne	 SHORT $LN6@DoUninstal

; 1758 : 				bOK = FALSE;

  00176	33 ed		 xor	 ebp, ebp

; 1759 : 			else

  00178	eb 3d		 jmp	 SHORT $LN29@DoUninstal
$LN6@DoUninstal:

; 1760 : 			{
; 1761 : 				fprintf (f, ":loop\n"
; 1762 : 					"del \"%s%s\"\n"
; 1763 : 					"if exist \"%s%s\" goto loop\n"
; 1764 : 					"rmdir \"%s\"\n"
; 1765 : 					"del \"%s\"",
; 1766 : 					UninstallationPath, "CipherShed-Setup.exe",
; 1767 : 					UninstallationPath, "CipherShed-Setup.exe",
; 1768 : 					UninstallationPath,
; 1769 : 					UninstallBatch
; 1770 : 					);

  0017a	68 00 00 00 00	 push	 OFFSET ?UninstallBatch@@3PADA ; UninstallBatch
  0017f	68 00 00 00 00	 push	 OFFSET ?UninstallationPath@@3PADA ; UninstallationPath
  00184	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@NFLEFHK@CipherShed?9Setup?4exe?$AA@
  00189	68 00 00 00 00	 push	 OFFSET ?UninstallationPath@@3PADA ; UninstallationPath
  0018e	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@NFLEFHK@CipherShed?9Setup?4exe?$AA@
  00193	68 00 00 00 00	 push	 OFFSET ?UninstallationPath@@3PADA ; UninstallationPath
  00198	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@MNNFDDNO@?3loop?6del?5?$CC?$CFs?$CFs?$CC?6if?5exist?5?$CC?$CFs?$CFs?$CC@
  0019d	57		 push	 edi
  0019e	e8 00 00 00 00	 call	 _fprintf

; 1771 : 
; 1772 : 				CheckFileStreamWriteErrors (f, UninstallBatch);

  001a3	68 00 00 00 00	 push	 OFFSET ?UninstallBatch@@3PADA ; UninstallBatch
  001a8	57		 push	 edi
  001a9	e8 00 00 00 00	 call	 _CheckFileStreamWriteErrors

; 1773 : 				fclose (f);

  001ae	57		 push	 edi
  001af	e8 00 00 00 00	 call	 _fclose
  001b4	83 c4 2c	 add	 esp, 44			; 0000002cH
$LN29@DoUninstal:
  001b7	5f		 pop	 edi
$LN5@DoUninstal:

; 1774 : 			}
; 1775 : 		}
; 1776 : 	}
; 1777 : 
; 1778 : 	NormalCursor ();

  001b8	e8 00 00 00 00	 call	 _NormalCursor

; 1779 : 
; 1780 : 	if (Rollback)

  001bd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Rollback, 0
  001c4	75 59		 jne	 SHORT $LN22@DoUninstal

; 1781 : 		return;
; 1782 : 
; 1783 : 	/* End system change. */
; 1784 : 	if (bSystemRestore && !bTempSkipSysRestore)

  001c6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bSystemRestore, 0
  001cd	74 11		 je	 SHORT $LN28@DoUninstal
  001cf	83 7c 24 08 00	 cmp	 DWORD PTR _bTempSkipSysRestore$[esp+276], 0
  001d4	75 0a		 jne	 SHORT $LN28@DoUninstal

; 1785 : 		SetSystemRestorePoint (hwndDlg, TRUE);

  001d6	6a 01		 push	 1
  001d8	e8 00 00 00 00	 call	 ?SetSystemRestorePoint@@YAXPAUHWND__@@H@Z ; SetSystemRestorePoint
  001dd	83 c4 04	 add	 esp, 4
$LN28@DoUninstal:

; 1786 : 
; 1787 : 	if (bOK)

  001e0	85 ed		 test	 ebp, ebp
  001e2	74 12		 je	 SHORT $LN2@DoUninstal

; 1788 : 		PostMessage (hwndDlg, TC_APPMSG_UNINSTALL_SUCCESS, 0, 0);

  001e4	6a 00		 push	 0
  001e6	6a 00		 push	 0
  001e8	68 92 81 00 00	 push	 33170			; 00008192H
  001ed	56		 push	 esi
  001ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16

; 1789 : 	else

  001f4	eb 0a		 jmp	 SHORT $LN1@DoUninstal
$LN2@DoUninstal:

; 1790 : 		bUninstallInProgress = FALSE;

  001f6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bUninstallInProgress@@3HA, 0 ; bUninstallInProgress
$LN1@DoUninstal:

; 1791 : 
; 1792 : 	EnableWindow (GetDlgItem ((HWND) hwndDlg, IDC_UNINSTALL), TRUE);

  00200	6a 01		 push	 1
  00202	68 f7 03 00 00	 push	 1015			; 000003f7H
  00207	56		 push	 esi
  00208	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0020e	50		 push	 eax
  0020f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 1793 : 	OutcomePrompt (hwndDlg, bOK);

  00215	55		 push	 ebp
  00216	56		 push	 esi
  00217	e8 00 00 00 00	 call	 _OutcomePrompt
  0021c	83 c4 08	 add	 esp, 8
$LN22@DoUninstal:

; 1794 : }

  0021f	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+276]
  00226	5e		 pop	 esi
  00227	5d		 pop	 ebp
  00228	33 cc		 xor	 ecx, esp
  0022a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0022f	81 c4 0c 01 00
	00		 add	 esp, 268		; 0000010cH
  00235	c3		 ret	 0
_DoUninstall ENDP
_TEXT	ENDS
PUBLIC	??_C@_08MFKGCNCO@FINALIZE?$AA@			; `string'
PUBLIC	??_C@_0BH@KAHGPAJO@CONFIRM_EXIT_UNIVERSAL?$AA@	; `string'
PUBLIC	??_C@_0BI@FLNDDLDP@TC_INSTALLER_IS_RUNNING?$AA@	; `string'
PUBLIC	?UninstallDlgProc@@YGHPAUHWND__@@IIJ@Z		; UninstallDlgProc
EXTRN	__imp__DialogBoxParamW@20:PROC
EXTRN	_AboutDlgProc@16:PROC
EXTRN	_hInst:DWORD
EXTRN	_IsButtonChecked:PROC
EXTRN	__beginthread:PROC
EXTRN	__imp__EndDialog@8:PROC
EXTRN	_AskNoYes:PROC
EXTRN	__imp__SetFocus@4:PROC
EXTRN	_SetCheckBox:PROC
EXTRN	__imp__SetWindowTextW@8:PROC
EXTRN	_LocalizeDialog:PROC
EXTRN	_InitDialog:PROC
EXTRN	_CreateAppSetupMutex:PROC
;	COMDAT ??_C@_08MFKGCNCO@FINALIZE?$AA@
CONST	SEGMENT
??_C@_08MFKGCNCO@FINALIZE?$AA@ DB 'FINALIZE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KAHGPAJO@CONFIRM_EXIT_UNIVERSAL?$AA@
CONST	SEGMENT
??_C@_0BH@KAHGPAJO@CONFIRM_EXIT_UNIVERSAL?$AA@ DB 'CONFIRM_EXIT_UNIVERSAL'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FLNDDLDP@TC_INSTALLER_IS_RUNNING?$AA@
CONST	SEGMENT
??_C@_0BI@FLNDDLDP@TC_INSTALLER_IS_RUNNING?$AA@ DB 'TC_INSTALLER_IS_RUNNI'
	DB	'NG', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?UninstallDlgProc@@YGHPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_hwndDlg$ = 8						; size = 4
_msg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?UninstallDlgProc@@YGHPAUHWND__@@IIJ@Z PROC		; UninstallDlgProc, COMDAT

; 2284 : 	WORD lw = LOWORD (wParam);
; 2285 : 
; 2286 : 	switch (msg)

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _msg$[esp-4]
  00004	3d 11 01 00 00	 cmp	 eax, 273		; 00000111H
  00009	0f 87 b4 01 00
	00		 ja	 $LN20@UninstallD
  0000f	0f 84 f1 00 00
	00		 je	 $LN10@UninstallD
  00015	83 f8 10	 cmp	 eax, 16			; 00000010H
  00018	0f 84 aa 00 00
	00		 je	 $LN3@UninstallD
  0001e	3d 10 01 00 00	 cmp	 eax, 272		; 00000110H
  00023	0f 85 0c 02 00
	00		 jne	 $LN11@UninstallD
  00029	56		 push	 esi

; 2287 : 	{
; 2288 : 	case WM_INITDIALOG:
; 2289 : 
; 2290 : 		MainDlg = hwndDlg;

  0002a	8b 74 24 08	 mov	 esi, DWORD PTR _hwndDlg$[esp]
  0002e	57		 push	 edi
  0002f	89 35 00 00 00
	00		 mov	 DWORD PTR _MainDlg, esi

; 2291 : 
; 2292 : 		if (!CreateAppSetupMutex ())

  00035	e8 00 00 00 00	 call	 _CreateAppSetupMutex
  0003a	85 c0		 test	 eax, eax
  0003c	75 0d		 jne	 SHORT $LN14@UninstallD

; 2293 : 			AbortProcess ("TC_INSTALLER_IS_RUNNING");

  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@FLNDDLDP@TC_INSTALLER_IS_RUNNING?$AA@
  00043	e8 00 00 00 00	 call	 _AbortProcess
  00048	83 c4 04	 add	 esp, 4
$LN14@UninstallD:

; 2294 : 
; 2295 : 		InitDialog (hwndDlg);

  0004b	56		 push	 esi
  0004c	e8 00 00 00 00	 call	 _InitDialog

; 2296 : 		LocalizeDialog (hwndDlg, NULL);

  00051	6a 00		 push	 0
  00053	56		 push	 esi
  00054	e8 00 00 00 00	 call	 _LocalizeDialog

; 2297 : 
; 2298 : 		SetWindowTextW (hwndDlg, lpszTitle);

  00059	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00061	50		 push	 eax
  00062	56		 push	 esi
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 2299 : 
; 2300 : 		// System Restore
; 2301 : 		SetCheckBox (hwndDlg, IDC_SYSTEM_RESTORE, bSystemRestore);

  00069	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _bSystemRestore
  0006f	51		 push	 ecx
  00070	68 f3 03 00 00	 push	 1011			; 000003f3H
  00075	56		 push	 esi
  00076	e8 00 00 00 00	 call	 _SetCheckBox

; 2302 : 		if (SystemRestoreDll == 0)

  0007b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SystemRestoreDll
  00081	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetDlgItem@8
  00087	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008a	85 d2		 test	 edx, edx
  0008c	75 21		 jne	 SHORT $LN13@UninstallD

; 2303 : 		{
; 2304 : 			/* No System Restore dll available, unset the checkbox and disable it. */
; 2305 : 			SetCheckBox (hwndDlg, IDC_SYSTEM_RESTORE, FALSE);

  0008e	6a 00		 push	 0
  00090	68 f3 03 00 00	 push	 1011			; 000003f3H
  00095	56		 push	 esi
  00096	e8 00 00 00 00	 call	 _SetCheckBox
  0009b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2306 : 			EnableWindow (GetDlgItem (hwndDlg, IDC_SYSTEM_RESTORE), FALSE);

  0009e	6a 00		 push	 0
  000a0	68 f3 03 00 00	 push	 1011			; 000003f3H
  000a5	56		 push	 esi
  000a6	ff d7		 call	 edi
  000a8	50		 push	 eax
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8
$LN13@UninstallD:

; 2307 : 		}
; 2308 : 
; 2309 : 		SetFocus (GetDlgItem (hwndDlg, IDC_UNINSTALL));

  000af	68 f7 03 00 00	 push	 1015			; 000003f7H
  000b4	56		 push	 esi
  000b5	ff d7		 call	 edi
  000b7	50		 push	 eax
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFocus@4
  000be	5f		 pop	 edi

; 2310 : 
; 2311 : 		return 1;

  000bf	b8 01 00 00 00	 mov	 eax, 1
  000c4	5e		 pop	 esi

; 2376 : }

  000c5	c2 10 00	 ret	 16			; 00000010H
$LN3@UninstallD:

; 2351 : 			return 1;
; 2352 : 		}
; 2353 : 
; 2354 : 		return 0;
; 2355 : 
; 2356 : 	case TC_APPMSG_UNINSTALL_SUCCESS:
; 2357 : 		SetWindowTextW (GetDlgItem ((HWND) hwndDlg, IDC_UNINSTALL), GetString ("FINALIZE"));
; 2358 : 		NormalCursor ();
; 2359 : 		return 1;
; 2360 : 
; 2361 : 	case WM_CLOSE:
; 2362 : 		if (bUninstallInProgress)

  000c8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bUninstallInProgress@@3HA, 0 ; bUninstallInProgress
  000cf	74 20		 je	 SHORT $LN2@UninstallD

; 2363 : 		{
; 2364 : 			NormalCursor();

  000d1	e8 00 00 00 00	 call	 _NormalCursor

; 2365 : 			if (AskNoYes("CONFIRM_EXIT_UNIVERSAL") == IDNO)

  000d6	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@KAHGPAJO@CONFIRM_EXIT_UNIVERSAL?$AA@
  000db	e8 00 00 00 00	 call	 _AskNoYes
  000e0	83 c4 04	 add	 esp, 4
  000e3	83 f8 07	 cmp	 eax, 7

; 2366 : 			{
; 2367 : 				return 1;

  000e6	0f 84 41 01 00
	00		 je	 $LN21@UninstallD

; 2368 : 			}
; 2369 : 			WaitCursor ();

  000ec	e8 00 00 00 00	 call	 _WaitCursor
$LN2@UninstallD:

; 2370 : 		}
; 2371 : 		EndDialog (hwndDlg, IDCANCEL);

  000f1	8b 44 24 04	 mov	 eax, DWORD PTR _hwndDlg$[esp-4]
  000f5	6a 02		 push	 2
  000f7	50		 push	 eax
  000f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndDialog@8

; 2372 : 		return 1;

  000fe	b8 01 00 00 00	 mov	 eax, 1

; 2376 : }

  00103	c2 10 00	 ret	 16			; 00000010H
$LN10@UninstallD:

; 2320 : 
; 2321 : 	case WM_COMMAND:
; 2322 : 		if (lw == IDC_UNINSTALL)

  00106	8b 44 24 0c	 mov	 eax, DWORD PTR _wParam$[esp-4]
  0010a	b9 f7 03 00 00	 mov	 ecx, 1015		; 000003f7H
  0010f	66 3b c1	 cmp	 ax, cx
  00112	75 60		 jne	 SHORT $LN9@UninstallD

; 2323 : 		{
; 2324 : 			if (bDone)

  00114	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDone@@3HA, 0 ; bDone
  0011b	74 23		 je	 SHORT $LN8@UninstallD

; 2325 : 			{
; 2326 : 				bUninstallInProgress = FALSE;
; 2327 : 				PostMessage (hwndDlg, WM_CLOSE, 0, 0);

  0011d	8b 54 24 04	 mov	 edx, DWORD PTR _hwndDlg$[esp-4]
  00121	6a 00		 push	 0
  00123	6a 00		 push	 0
  00125	6a 10		 push	 16			; 00000010H
  00127	52		 push	 edx
  00128	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bUninstallInProgress@@3HA, 0 ; bUninstallInProgress
  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16

; 2328 : 				return 1;

  00138	b8 01 00 00 00	 mov	 eax, 1

; 2376 : }

  0013d	c2 10 00	 ret	 16			; 00000010H
$LN8@UninstallD:

; 2329 : 			}
; 2330 : 
; 2331 : 			bUninstallInProgress = TRUE;

  00140	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bUninstallInProgress@@3HA, 1 ; bUninstallInProgress

; 2332 : 
; 2333 : 			WaitCursor ();

  0014a	e8 00 00 00 00	 call	 _WaitCursor

; 2334 : 
; 2335 : 			/* Do uninstall. */
; 2336 : 			if (bUninstall)

  0014f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bUninstall@@3HA, 0 ; bUninstall
  00156	74 14		 je	 SHORT $LN7@UninstallD

; 2337 : 				_beginthread (DoUninstall, 0, (void *) hwndDlg);

  00158	8b 44 24 04	 mov	 eax, DWORD PTR _hwndDlg$[esp-4]
  0015c	50		 push	 eax
  0015d	6a 00		 push	 0
  0015f	68 00 00 00 00	 push	 OFFSET _DoUninstall
  00164	e8 00 00 00 00	 call	 __beginthread
  00169	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@UninstallD:

; 2338 : 
; 2339 : 			return 1;

  0016c	b8 01 00 00 00	 mov	 eax, 1

; 2376 : }

  00171	c2 10 00	 ret	 16			; 00000010H
$LN9@UninstallD:

; 2340 : 		}
; 2341 : 
; 2342 : 		if (lw == IDC_SYSTEM_RESTORE)

  00174	b9 f3 03 00 00	 mov	 ecx, 1011		; 000003f3H
  00179	66 3b c1	 cmp	 ax, cx
  0017c	75 22		 jne	 SHORT $LN6@UninstallD

; 2343 : 		{
; 2344 : 			bSystemRestore = IsButtonChecked (GetDlgItem (hwndDlg, IDC_SYSTEM_RESTORE));

  0017e	8b 54 24 04	 mov	 edx, DWORD PTR _hwndDlg$[esp-4]
  00182	51		 push	 ecx
  00183	52		 push	 edx
  00184	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0018a	50		 push	 eax
  0018b	e8 00 00 00 00	 call	 _IsButtonChecked
  00190	a3 00 00 00 00	 mov	 DWORD PTR _bSystemRestore, eax
  00195	83 c4 04	 add	 esp, 4

; 2345 : 			return 1;

  00198	b8 01 00 00 00	 mov	 eax, 1

; 2376 : }

  0019d	c2 10 00	 ret	 16			; 00000010H
$LN6@UninstallD:

; 2346 : 		}
; 2347 : 
; 2348 : 		if (lw == IDCANCEL)

  001a0	66 83 f8 02	 cmp	 ax, 2
  001a4	0f 85 8b 00 00
	00		 jne	 $LN11@UninstallD

; 2349 : 		{
; 2350 : 			PostMessage (hwndDlg, WM_CLOSE, 0, 0);

  001aa	8b 44 24 04	 mov	 eax, DWORD PTR _hwndDlg$[esp-4]
  001ae	6a 00		 push	 0
  001b0	6a 00		 push	 0
  001b2	6a 10		 push	 16			; 00000010H
  001b4	50		 push	 eax
  001b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16
  001bb	b8 01 00 00 00	 mov	 eax, 1

; 2376 : }

  001c0	c2 10 00	 ret	 16			; 00000010H
$LN20@UninstallD:

; 2284 : 	WORD lw = LOWORD (wParam);
; 2285 : 
; 2286 : 	switch (msg)

  001c3	3d 12 01 00 00	 cmp	 eax, 274		; 00000112H
  001c8	74 39		 je	 SHORT $LN12@UninstallD
  001ca	3d 92 81 00 00	 cmp	 eax, 33170		; 00008192H

; 2373 : 	}
; 2374 : 
; 2375 : 	return 0;

  001cf	75 64		 jne	 SHORT $LN11@UninstallD
  001d1	68 00 00 00 00	 push	 OFFSET ??_C@_08MFKGCNCO@FINALIZE?$AA@
  001d6	e8 00 00 00 00	 call	 _GetString
  001db	8b 4c 24 08	 mov	 ecx, DWORD PTR _hwndDlg$[esp]
  001df	83 c4 04	 add	 esp, 4
  001e2	50		 push	 eax
  001e3	68 f7 03 00 00	 push	 1015			; 000003f7H
  001e8	51		 push	 ecx
  001e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  001ef	50		 push	 eax
  001f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8
  001f6	e8 00 00 00 00	 call	 _NormalCursor
  001fb	b8 01 00 00 00	 mov	 eax, 1

; 2376 : }

  00200	c2 10 00	 ret	 16			; 00000010H
$LN12@UninstallD:

; 2312 : 
; 2313 : 	case WM_SYSCOMMAND:
; 2314 : 		if (lw == IDC_ABOUT)

  00203	ba ff 7f 00 00	 mov	 edx, 32767		; 00007fffH
  00208	66 39 54 24 0c	 cmp	 WORD PTR _wParam$[esp-4], dx
  0020d	75 26		 jne	 SHORT $LN11@UninstallD

; 2315 : 		{
; 2316 : 			DialogBoxW (hInst, MAKEINTRESOURCEW (IDD_ABOUT_DLG), hwndDlg, (DLGPROC) AboutDlgProc);

  0020f	8b 44 24 04	 mov	 eax, DWORD PTR _hwndDlg$[esp-4]
  00213	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hInst
  00219	6a 00		 push	 0
  0021b	68 00 00 00 00	 push	 OFFSET _AboutDlgProc@16
  00220	50		 push	 eax
  00221	68 fc 01 00 00	 push	 508			; 000001fcH
  00226	51		 push	 ecx
  00227	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DialogBoxParamW@20
$LN21@UninstallD:

; 2317 : 			return 1;

  0022d	b8 01 00 00 00	 mov	 eax, 1

; 2376 : }

  00232	c2 10 00	 ret	 16			; 00000010H
$LN11@UninstallD:

; 2318 : 		}
; 2319 : 		return 0;

  00235	33 c0		 xor	 eax, eax

; 2376 : }

  00237	c2 10 00	 ret	 16			; 00000010H
?UninstallDlgProc@@YGHPAUHWND__@@IIJ@Z ENDP		; UninstallDlgProc
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1046 : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	53		 push	 ebx

; 1047 : 		if (_Right.size() < _Roff)

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR __Right$[esp]
  00005	55		 push	 ebp
  00006	8b 6c 24 10	 mov	 ebp, DWORD PTR __Roff$[esp+4]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f1		 mov	 esi, ecx
  0000e	39 6b 14	 cmp	 DWORD PTR [ebx+20], ebp
  00011	73 05		 jae	 SHORT $LN5@assign

; 1048 : 			_String_base::_Xran();	// _Roff off end

  00013	e8 00 00 00 00	 call	 ?_Xran@_String_base@std@@SAXXZ ; std::_String_base::_Xran
$LN5@assign:

; 1049 : 		size_type _Num = _Right.size() - _Roff;

  00018	8b 7b 14	 mov	 edi, DWORD PTR [ebx+20]

; 1050 : 		if (_Count < _Num)

  0001b	8b 44 24 1c	 mov	 eax, DWORD PTR __Count$[esp+12]
  0001f	2b fd		 sub	 edi, ebp
  00021	3b c7		 cmp	 eax, edi
  00023	73 02		 jae	 SHORT $LN4@assign

; 1051 : 			_Num = _Count;	// trim _Num to size

  00025	8b f8		 mov	 edi, eax
$LN4@assign:

; 1052 : 
; 1053 : 		if (this == &_Right)

  00027	3b f3		 cmp	 esi, ebx
  00029	75 1f		 jne	 SHORT $LN3@assign

; 1054 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  0002b	6a ff		 push	 -1
  0002d	03 fd		 add	 edi, ebp
  0002f	57		 push	 edi
  00030	8b ce		 mov	 ecx, esi
  00032	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00037	55		 push	 ebp
  00038	6a 00		 push	 0
  0003a	8b ce		 mov	 ecx, esi
  0003c	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00041	5f		 pop	 edi

; 1059 : 			}
; 1060 : 		return (*this);

  00042	8b c6		 mov	 eax, esi
  00044	5e		 pop	 esi
  00045	5d		 pop	 ebp
  00046	5b		 pop	 ebx

; 1061 : 		}

  00047	c2 0c 00	 ret	 12			; 0000000cH
$LN3@assign:

; 1055 : 		else if (_Grow(_Num))

  0004a	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0004d	76 05		 jbe	 SHORT $LN17@assign
  0004f	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@SAXXZ ; std::_String_base::_Xlen
$LN17@assign:
  00054	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00057	3b c7		 cmp	 eax, edi
  00059	73 1b		 jae	 SHORT $LN16@assign
  0005b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0005e	50		 push	 eax
  0005f	57		 push	 edi
  00060	8b ce		 mov	 ecx, esi
  00062	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00067	85 ff		 test	 edi, edi
$LN87@assign:
  00069	76 66		 jbe	 SHORT $LN86@assign

; 1056 : 			{	// make room and assign new stuff
; 1057 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Right._Myptr() + _Roff, _Num);

  0006b	83 7b 18 10	 cmp	 DWORD PTR [ebx+24], 16	; 00000010H
  0006f	72 2f		 jb	 SHORT $LN64@assign
  00071	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00074	eb 2d		 jmp	 SHORT $LN65@assign

; 1055 : 		else if (_Grow(_Num))

$LN16@assign:
  00076	85 ff		 test	 edi, edi
  00078	75 ef		 jne	 SHORT $LN87@assign
  0007a	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  0007d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00080	72 0f		 jb	 SHORT $LN58@assign
  00082	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00085	5f		 pop	 edi
  00086	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1059 : 			}
; 1060 : 		return (*this);

  00089	8b c6		 mov	 eax, esi
  0008b	5e		 pop	 esi
  0008c	5d		 pop	 ebp
  0008d	5b		 pop	 ebx

; 1061 : 		}

  0008e	c2 0c 00	 ret	 12			; 0000000cH

; 1055 : 		else if (_Grow(_Num))

$LN58@assign:
  00091	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00094	5f		 pop	 edi
  00095	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1059 : 			}
; 1060 : 		return (*this);

  00098	8b c6		 mov	 eax, esi
  0009a	5e		 pop	 esi
  0009b	5d		 pop	 ebp
  0009c	5b		 pop	 ebx

; 1061 : 		}

  0009d	c2 0c 00	 ret	 12			; 0000000cH

; 1056 : 			{	// make room and assign new stuff
; 1057 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Right._Myptr() + _Roff, _Num);

$LN64@assign:
  000a0	8d 53 04	 lea	 edx, DWORD PTR [ebx+4]
$LN65@assign:
  000a3	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  000a6	8d 5e 04	 lea	 ebx, DWORD PTR [esi+4]
  000a9	83 f9 10	 cmp	 ecx, 16			; 00000010H
  000ac	72 04		 jb	 SHORT $LN68@assign
  000ae	8b 03		 mov	 eax, DWORD PTR [ebx]
  000b0	eb 02		 jmp	 SHORT $LN69@assign
$LN68@assign:
  000b2	8b c3		 mov	 eax, ebx
$LN69@assign:
  000b4	57		 push	 edi
  000b5	03 d5		 add	 edx, ebp
  000b7	52		 push	 edx
  000b8	51		 push	 ecx
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 _memcpy_s
  000bf	83 c4 10	 add	 esp, 16			; 00000010H

; 1058 : 			_Eos(_Num);

  000c2	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  000c6	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  000c9	72 02		 jb	 SHORT $LN82@assign
  000cb	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN82@assign:
  000cd	c6 04 3b 00	 mov	 BYTE PTR [ebx+edi], 0
$LN86@assign:
  000d1	5f		 pop	 edi

; 1059 : 			}
; 1060 : 		return (*this);

  000d2	8b c6		 mov	 eax, esi
  000d4	5e		 pop	 esi
  000d5	5d		 pop	 ebp
  000d6	5b		 pop	 ebx

; 1061 : 		}

  000d7	c2 0c 00	 ret	 12			; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z
_TEXT	SEGMENT
__Num$ = 8						; size = 4
__Off$ = 8						; size = 4
__Right$ = 12						; size = 4
tv140 = 16						; size = 4
__Roff$ = 16						; size = 4
__Count$ = 20						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1136 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off

  00000	53		 push	 ebx

; 1137 : 		if (_Mysize < _Off || _Right.size() < _Roff)

  00001	8b 5c 24 10	 mov	 ebx, DWORD PTR __Roff$[esp]
  00005	55		 push	 ebp
  00006	8b 6c 24 10	 mov	 ebp, DWORD PTR __Right$[esp+4]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b 7c 24 14	 mov	 edi, DWORD PTR __Off$[esp+12]
  00010	8b f1		 mov	 esi, ecx
  00012	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00015	72 05		 jb	 SHORT $LN6@insert
  00017	39 5d 14	 cmp	 DWORD PTR [ebp+20], ebx
  0001a	73 05		 jae	 SHORT $LN7@insert
$LN6@insert:

; 1138 : 			_String_base::_Xran();	// _Off or _Roff off end

  0001c	e8 00 00 00 00	 call	 ?_Xran@_String_base@std@@SAXXZ ; std::_String_base::_Xran
$LN7@insert:

; 1139 : 		size_type _Num = _Right.size() - _Roff;

  00021	8b 45 14	 mov	 eax, DWORD PTR [ebp+20]
  00024	2b c3		 sub	 eax, ebx

; 1140 : 		if (_Num < _Count)

  00026	8b 5c 24 20	 mov	 ebx, DWORD PTR __Count$[esp+12]
  0002a	3b c3		 cmp	 eax, ebx
  0002c	73 02		 jae	 SHORT $LN5@insert

; 1141 : 			_Count = _Num;	// trim _Count to size

  0002e	8b d8		 mov	 ebx, eax
$LN5@insert:

; 1142 : 		if (npos - _Mysize <= _Count)

  00030	83 c8 ff	 or	 eax, -1
  00033	2b 46 14	 sub	 eax, DWORD PTR [esi+20]
  00036	3b c3		 cmp	 eax, ebx
  00038	77 05		 ja	 SHORT $LN4@insert

; 1143 : 			_String_base::_Xlen();	// result too long

  0003a	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@SAXXZ ; std::_String_base::_Xlen
$LN4@insert:

; 1144 : 
; 1145 : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

  0003f	85 db		 test	 ebx, ebx
  00041	0f 86 1e 01 00
	00		 jbe	 $LN123@insert
  00047	8b 6e 14	 mov	 ebp, DWORD PTR [esi+20]
  0004a	03 eb		 add	 ebp, ebx
  0004c	89 6c 24 14	 mov	 DWORD PTR __Num$[esp+12], ebp
  00050	83 fd fe	 cmp	 ebp, -2			; fffffffeH
  00053	76 05		 jbe	 SHORT $LN21@insert
  00055	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@SAXXZ ; std::_String_base::_Xlen
$LN21@insert:
  0005a	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0005d	3b c5		 cmp	 eax, ebp
  0005f	73 23		 jae	 SHORT $LN20@insert
  00061	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00064	51		 push	 ecx
  00065	55		 push	 ebp
  00066	8b ce		 mov	 ecx, esi
  00068	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0006d	85 ed		 test	 ebp, ebp
$LN124@insert:
  0006f	0f 86 f0 00 00
	00		 jbe	 $LN123@insert

; 1146 : 			{	// make room and insert new stuff
; 1147 : 			_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
; 1148 : 				_Myptr() + _Off, _Mysize - _Off);	// empty out hole

  00075	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00078	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0007b	83 f8 10	 cmp	 eax, 16			; 00000010H
  0007e	72 2e		 jb	 SHORT $LN68@insert
  00080	8b 11		 mov	 edx, DWORD PTR [ecx]
  00082	eb 2c		 jmp	 SHORT $LN69@insert

; 1144 : 
; 1145 : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN20@insert:
  00084	85 ed		 test	 ebp, ebp
  00086	75 e7		 jne	 SHORT $LN124@insert
  00088	89 6e 14	 mov	 DWORD PTR [esi+20], ebp
  0008b	83 f8 10	 cmp	 eax, 16			; 00000010H
  0008e	72 0f		 jb	 SHORT $LN62@insert
  00090	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00093	5f		 pop	 edi
  00094	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1157 : 			}
; 1158 : 		return (*this);

  00097	8b c6		 mov	 eax, esi
  00099	5e		 pop	 esi
  0009a	5d		 pop	 ebp
  0009b	5b		 pop	 ebx

; 1159 : 		}

  0009c	c2 10 00	 ret	 16			; 00000010H

; 1144 : 
; 1145 : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN62@insert:
  0009f	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  000a2	5f		 pop	 edi
  000a3	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1157 : 			}
; 1158 : 		return (*this);

  000a6	8b c6		 mov	 eax, esi
  000a8	5e		 pop	 esi
  000a9	5d		 pop	 ebp
  000aa	5b		 pop	 ebx

; 1159 : 		}

  000ab	c2 10 00	 ret	 16			; 00000010H

; 1146 : 			{	// make room and insert new stuff
; 1147 : 			_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
; 1148 : 				_Myptr() + _Off, _Mysize - _Off);	// empty out hole

$LN68@insert:
  000ae	8b d1		 mov	 edx, ecx
$LN69@insert:
  000b0	83 f8 10	 cmp	 eax, 16			; 00000010H
  000b3	72 02		 jb	 SHORT $LN72@insert
  000b5	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN72@insert:
  000b7	8b 6e 14	 mov	 ebp, DWORD PTR [esi+20]
  000ba	2b ef		 sub	 ebp, edi
  000bc	55		 push	 ebp
  000bd	03 d7		 add	 edx, edi
  000bf	2b c7		 sub	 eax, edi
  000c1	52		 push	 edx
  000c2	2b c3		 sub	 eax, ebx
  000c4	03 cf		 add	 ecx, edi
  000c6	50		 push	 eax
  000c7	03 cb		 add	 ecx, ebx
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 _memmove_s

; 1149 : 			if (this == &_Right)

  000cf	8b 44 24 28	 mov	 eax, DWORD PTR __Right$[esp+28]
  000d3	83 c4 10	 add	 esp, 16			; 00000010H
  000d6	3b f0		 cmp	 esi, eax
  000d8	75 41		 jne	 SHORT $LN2@insert

; 1150 : 				_Traits_helper::move_s<_Traits>(_Myptr() + _Off, _Myres - _Off,
; 1151 : 					_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1152 : 						_Count);	// substring

  000da	8b 44 24 1c	 mov	 eax, DWORD PTR __Roff$[esp+12]
  000de	3b f8		 cmp	 edi, eax
  000e0	73 02		 jae	 SHORT $LN10@insert
  000e2	03 c3		 add	 eax, ebx
$LN10@insert:
  000e4	89 44 24 1c	 mov	 DWORD PTR tv140[esp+12], eax
  000e8	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  000eb	8d 6e 04	 lea	 ebp, DWORD PTR [esi+4]
  000ee	83 f8 10	 cmp	 eax, 16			; 00000010H
  000f1	72 05		 jb	 SHORT $LN84@insert
  000f3	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  000f6	eb 02		 jmp	 SHORT $LN85@insert
$LN84@insert:
  000f8	8b d5		 mov	 edx, ebp
$LN85@insert:
  000fa	83 f8 10	 cmp	 eax, 16			; 00000010H
  000fd	72 05		 jb	 SHORT $LN88@insert
  000ff	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  00102	eb 02		 jmp	 SHORT $LN89@insert
$LN88@insert:
  00104	8b cd		 mov	 ecx, ebp
$LN89@insert:
  00106	53		 push	 ebx
  00107	8b 5c 24 20	 mov	 ebx, DWORD PTR tv140[esp+16]
  0010b	03 d3		 add	 edx, ebx
  0010d	52		 push	 edx
  0010e	2b c7		 sub	 eax, edi
  00110	50		 push	 eax
  00111	03 cf		 add	 ecx, edi
  00113	51		 push	 ecx
  00114	e8 00 00 00 00	 call	 _memmove_s

; 1153 : 			else

  00119	eb 33		 jmp	 SHORT $LN125@insert
$LN2@insert:

; 1154 : 				_Traits_helper::copy_s<_Traits>(_Myptr() + _Off, _Myres - _Off,
; 1155 : 					_Right._Myptr() + _Roff, _Count);	// fill hole

  0011b	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  0011f	72 05		 jb	 SHORT $LN100@insert
  00121	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00124	eb 03		 jmp	 SHORT $LN101@insert
$LN100@insert:
  00126	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
$LN101@insert:
  00129	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0012c	8d 6e 04	 lea	 ebp, DWORD PTR [esi+4]
  0012f	83 f8 10	 cmp	 eax, 16			; 00000010H
  00132	72 05		 jb	 SHORT $LN104@insert
  00134	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  00137	eb 02		 jmp	 SHORT $LN105@insert
$LN104@insert:
  00139	8b cd		 mov	 ecx, ebp
$LN105@insert:
  0013b	53		 push	 ebx
  0013c	8b 5c 24 20	 mov	 ebx, DWORD PTR __Roff$[esp+16]
  00140	03 d3		 add	 edx, ebx
  00142	52		 push	 edx
  00143	2b c7		 sub	 eax, edi
  00145	50		 push	 eax
  00146	03 cf		 add	 ecx, edi
  00148	51		 push	 ecx
  00149	e8 00 00 00 00	 call	 _memcpy_s
$LN125@insert:

; 1156 : 			_Eos(_Num);

  0014e	8b 44 24 24	 mov	 eax, DWORD PTR __Num$[esp+28]
  00152	83 c4 10	 add	 esp, 16			; 00000010H
  00155	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00159	89 46 14	 mov	 DWORD PTR [esi+20], eax
  0015c	72 03		 jb	 SHORT $LN118@insert
  0015e	8b 6d 00	 mov	 ebp, DWORD PTR [ebp]
$LN118@insert:
  00161	c6 04 28 00	 mov	 BYTE PTR [eax+ebp], 0
$LN123@insert:
  00165	5f		 pop	 edi

; 1157 : 			}
; 1158 : 		return (*this);

  00166	8b c6		 mov	 eax, esi
  00168	5e		 pop	 esi
  00169	5d		 pop	 ebp
  0016a	5b		 pop	 ebx

; 1159 : 		}

  0016b	c2 10 00	 ret	 16			; 00000010H
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtpy
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1064 : 		{	// assign [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp

; 1065 : 
; 1066 :  #if _HAS_ITERATOR_DEBUGGING
; 1067 : 		if (_Count != 0)
; 1068 : 			_DEBUG_POINTER(_Ptr);
; 1069 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1070 : 
; 1071 : 		if (_Inside(_Ptr))

  00001	8b 6c 24 08	 mov	 ebp, DWORD PTR __Ptr$[esp]
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f1		 mov	 esi, ecx
  00009	85 ed		 test	 ebp, ebp
  0000b	74 46		 je	 SHORT $LN93@assign@2
  0000d	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  00010	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00013	83 fa 10	 cmp	 edx, 16			; 00000010H
  00016	72 04		 jb	 SHORT $LN12@assign@2
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	eb 02		 jmp	 SHORT $LN13@assign@2
$LN12@assign@2:
  0001c	8b c8		 mov	 ecx, eax
$LN13@assign@2:
  0001e	3b e9		 cmp	 ebp, ecx
  00020	72 31		 jb	 SHORT $LN93@assign@2
  00022	83 fa 10	 cmp	 edx, 16			; 00000010H
  00025	72 04		 jb	 SHORT $LN16@assign@2
  00027	8b 08		 mov	 ecx, DWORD PTR [eax]
  00029	eb 02		 jmp	 SHORT $LN17@assign@2
$LN16@assign@2:
  0002b	8b c8		 mov	 ecx, eax
$LN17@assign@2:
  0002d	8b 7e 14	 mov	 edi, DWORD PTR [esi+20]
  00030	03 f9		 add	 edi, ecx
  00032	3b fd		 cmp	 edi, ebp
  00034	76 1d		 jbe	 SHORT $LN93@assign@2

; 1072 : 			return (assign(*this, _Ptr - _Myptr(), _Count));	// substring

  00036	83 fa 10	 cmp	 edx, 16			; 00000010H
  00039	72 02		 jb	 SHORT $LN20@assign@2
  0003b	8b 00		 mov	 eax, DWORD PTR [eax]
$LN20@assign@2:
  0003d	8b 4c 24 14	 mov	 ecx, DWORD PTR __Count$[esp+8]
  00041	51		 push	 ecx
  00042	2b e8		 sub	 ebp, eax
  00044	55		 push	 ebp
  00045	56		 push	 esi
  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5d		 pop	 ebp

; 1080 : 		}

  00050	c2 08 00	 ret	 8
$LN93@assign@2:

; 1073 : 
; 1074 : 		if (_Grow(_Count))

  00053	8b 7c 24 14	 mov	 edi, DWORD PTR __Count$[esp+8]
  00057	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0005a	76 05		 jbe	 SHORT $LN27@assign@2
  0005c	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@SAXXZ ; std::_String_base::_Xlen
$LN27@assign@2:
  00061	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00064	3b c7		 cmp	 eax, edi
  00066	73 20		 jae	 SHORT $LN26@assign@2
  00068	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0006b	52		 push	 edx
  0006c	57		 push	 edi
  0006d	8b ce		 mov	 ecx, esi
  0006f	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00074	85 ff		 test	 edi, edi
$LN94@assign@2:
  00076	76 56		 jbe	 SHORT $LN90@assign@2

; 1075 : 			{	// make room and assign new stuff
; 1076 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Ptr, _Count);

  00078	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  0007b	53		 push	 ebx
  0007c	8d 5e 04	 lea	 ebx, DWORD PTR [esi+4]
  0007f	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00082	72 2c		 jb	 SHORT $LN74@assign@2
  00084	8b 03		 mov	 eax, DWORD PTR [ebx]
  00086	eb 2a		 jmp	 SHORT $LN75@assign@2

; 1073 : 
; 1074 : 		if (_Grow(_Count))

$LN26@assign@2:
  00088	85 ff		 test	 edi, edi
  0008a	75 ea		 jne	 SHORT $LN94@assign@2
  0008c	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  0008f	83 f8 10	 cmp	 eax, 16			; 00000010H
  00092	72 0e		 jb	 SHORT $LN68@assign@2
  00094	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00097	5f		 pop	 edi
  00098	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1078 : 			}
; 1079 : 		return (*this);

  0009b	8b c6		 mov	 eax, esi
  0009d	5e		 pop	 esi
  0009e	5d		 pop	 ebp

; 1080 : 		}

  0009f	c2 08 00	 ret	 8

; 1073 : 
; 1074 : 		if (_Grow(_Count))

$LN68@assign@2:
  000a2	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  000a5	5f		 pop	 edi
  000a6	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1078 : 			}
; 1079 : 		return (*this);

  000a9	8b c6		 mov	 eax, esi
  000ab	5e		 pop	 esi
  000ac	5d		 pop	 ebp

; 1080 : 		}

  000ad	c2 08 00	 ret	 8

; 1075 : 			{	// make room and assign new stuff
; 1076 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Ptr, _Count);

$LN74@assign@2:
  000b0	8b c3		 mov	 eax, ebx
$LN75@assign@2:
  000b2	57		 push	 edi
  000b3	55		 push	 ebp
  000b4	51		 push	 ecx
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 _memcpy_s
  000bb	83 c4 10	 add	 esp, 16			; 00000010H

; 1077 : 			_Eos(_Count);

  000be	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  000c2	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  000c5	72 02		 jb	 SHORT $LN88@assign@2
  000c7	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN88@assign@2:
  000c9	c6 04 3b 00	 mov	 BYTE PTR [ebx+edi], 0
  000cd	5b		 pop	 ebx
$LN90@assign@2:
  000ce	5f		 pop	 edi

; 1078 : 			}
; 1079 : 		return (*this);

  000cf	8b c6		 mov	 eax, esi
  000d1	5e		 pop	 esi
  000d2	5d		 pop	 ebp

; 1080 : 		}

  000d3	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogtpy
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 992  : 		{	// append [_Ptr, <null>)

  00000	56		 push	 esi

; 993  : 		_DEBUG_POINTER(_Ptr);
; 994  : 		return (append(_Ptr, _Traits::length(_Ptr)));

  00001	8b 74 24 08	 mov	 esi, DWORD PTR __Ptr$[esp]
  00005	8b c6		 mov	 eax, esi
  00007	57		 push	 edi
  00008	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000b	eb 03 8d 49 00	 npad	 5
$LL5@append@3:
  00010	8a 10		 mov	 dl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 d2		 test	 dl, dl
  00015	75 f9		 jne	 SHORT $LL5@append@3
  00017	2b c7		 sub	 eax, edi
  00019	50		 push	 eax
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 995  : 		}

  00022	c2 04 00	 ret	 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 721  : 		{	// construct by copying _Right

  00000	56		 push	 esi

; 722  : 		_Tidy();

  00001	33 c0		 xor	 eax, eax
  00003	8b f1		 mov	 esi, ecx

; 723  : 		assign(_Right, 0, npos);

  00005	6a ff		 push	 -1
  00007	89 46 14	 mov	 DWORD PTR [esi+20], eax
  0000a	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00011	50		 push	 eax
  00012	88 46 04	 mov	 BYTE PTR [esi+4], al
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Right$[esp+8]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 724  : 		}

  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z
_TEXT	SEGMENT
tv232 = 8						; size = 4
__Off$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1164 : 
; 1165 :  #if _HAS_ITERATOR_DEBUGGING
; 1166 : 		if (_Count != 0)
; 1167 : 			_DEBUG_POINTER(_Ptr);
; 1168 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1169 : 
; 1170 : 		if (_Inside(_Ptr))

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Ptr$[esp-4]
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f1		 mov	 esi, ecx
  00009	85 d2		 test	 edx, edx
  0000b	74 4b		 je	 SHORT $LN4@insert@2
  0000d	8b 7e 18	 mov	 edi, DWORD PTR [esi+24]
  00010	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00013	83 ff 10	 cmp	 edi, 16			; 00000010H
  00016	72 04		 jb	 SHORT $LN14@insert@2
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	eb 02		 jmp	 SHORT $LN15@insert@2
$LN14@insert@2:
  0001c	8b c8		 mov	 ecx, eax
$LN15@insert@2:
  0001e	3b d1		 cmp	 edx, ecx
  00020	72 36		 jb	 SHORT $LN4@insert@2
  00022	83 ff 10	 cmp	 edi, 16			; 00000010H
  00025	72 04		 jb	 SHORT $LN18@insert@2
  00027	8b 08		 mov	 ecx, DWORD PTR [eax]
  00029	eb 02		 jmp	 SHORT $LN19@insert@2
$LN18@insert@2:
  0002b	8b c8		 mov	 ecx, eax
$LN19@insert@2:
  0002d	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  00030	03 d9		 add	 ebx, ecx
  00032	3b da		 cmp	 ebx, edx
  00034	76 22		 jbe	 SHORT $LN4@insert@2

; 1171 : 			return (insert(_Off, *this,
; 1172 : 				_Ptr - _Myptr(), _Count));	// substring

  00036	83 ff 10	 cmp	 edi, 16			; 00000010H
  00039	72 02		 jb	 SHORT $LN22@insert@2
  0003b	8b 00		 mov	 eax, DWORD PTR [eax]
$LN22@insert@2:
  0003d	8b 4c 24 18	 mov	 ecx, DWORD PTR __Count$[esp+8]
  00041	51		 push	 ecx
  00042	2b d0		 sub	 edx, eax
  00044	52		 push	 edx
  00045	8b 54 24 18	 mov	 edx, DWORD PTR __Off$[esp+16]
  00049	56		 push	 esi
  0004a	52		 push	 edx
  0004b	8b ce		 mov	 ecx, esi
  0004d	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx

; 1186 : 		}

  00055	c2 0c 00	 ret	 12			; 0000000cH
$LN4@insert@2:

; 1173 : 		if (_Mysize < _Off)

  00058	8b 7c 24 10	 mov	 edi, DWORD PTR __Off$[esp+8]
  0005c	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0005f	73 05		 jae	 SHORT $LN3@insert@2

; 1174 : 			_String_base::_Xran();	// _Off off end

  00061	e8 00 00 00 00	 call	 ?_Xran@_String_base@std@@SAXXZ ; std::_String_base::_Xran
$LN3@insert@2:

; 1175 : 		if (npos - _Mysize <= _Count)

  00066	8b 5c 24 18	 mov	 ebx, DWORD PTR __Count$[esp+8]
  0006a	83 c8 ff	 or	 eax, -1
  0006d	2b 46 14	 sub	 eax, DWORD PTR [esi+20]
  00070	3b c3		 cmp	 eax, ebx
  00072	77 05		 ja	 SHORT $LN2@insert@2

; 1176 : 			_String_base::_Xlen();	// result too long

  00074	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@SAXXZ ; std::_String_base::_Xlen
$LN2@insert@2:

; 1177 : 		size_type _Num;
; 1178 : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

  00079	85 db		 test	 ebx, ebx
  0007b	0f 86 de 00 00
	00		 jbe	 $LN108@insert@2
  00081	55		 push	 ebp
  00082	8b 6e 14	 mov	 ebp, DWORD PTR [esi+20]
  00085	03 eb		 add	 ebp, ebx
  00087	83 fd fe	 cmp	 ebp, -2			; fffffffeH
  0008a	76 05		 jbe	 SHORT $LN29@insert@2
  0008c	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@SAXXZ ; std::_String_base::_Xlen
$LN29@insert@2:
  00091	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00094	3b c5		 cmp	 eax, ebp
  00096	73 25		 jae	 SHORT $LN28@insert@2
  00098	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0009b	51		 push	 ecx
  0009c	55		 push	 ebp
  0009d	8b ce		 mov	 ecx, esi
  0009f	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  000a4	85 ed		 test	 ebp, ebp
$LN112@insert@2:
  000a6	0f 86 b2 00 00
	00		 jbe	 $LN111@insert@2

; 1179 : 			{	// make room and insert new stuff
; 1180 : 			_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
; 1181 : 				_Myptr() + _Off, _Mysize - _Off);	// empty out hole

  000ac	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  000af	83 f8 10	 cmp	 eax, 16			; 00000010H
  000b2	72 33		 jb	 SHORT $LN76@insert@2
  000b4	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  000b7	89 54 24 14	 mov	 DWORD PTR tv232[esp+12], edx
  000bb	eb 31		 jmp	 SHORT $LN77@insert@2

; 1177 : 		size_type _Num;
; 1178 : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN28@insert@2:
  000bd	85 ed		 test	 ebp, ebp
  000bf	75 e5		 jne	 SHORT $LN112@insert@2
  000c1	89 6e 14	 mov	 DWORD PTR [esi+20], ebp
  000c4	83 f8 10	 cmp	 eax, 16			; 00000010H
  000c7	72 0f		 jb	 SHORT $LN70@insert@2
  000c9	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000cc	5d		 pop	 ebp
  000cd	5f		 pop	 edi
  000ce	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1184 : 			}
; 1185 : 		return (*this);

  000d1	8b c6		 mov	 eax, esi
  000d3	5e		 pop	 esi
  000d4	5b		 pop	 ebx

; 1186 : 		}

  000d5	c2 0c 00	 ret	 12			; 0000000cH

; 1177 : 		size_type _Num;
; 1178 : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN70@insert@2:
  000d8	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  000db	5d		 pop	 ebp
  000dc	5f		 pop	 edi
  000dd	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1184 : 			}
; 1185 : 		return (*this);

  000e0	8b c6		 mov	 eax, esi
  000e2	5e		 pop	 esi
  000e3	5b		 pop	 ebx

; 1186 : 		}

  000e4	c2 0c 00	 ret	 12			; 0000000cH

; 1179 : 			{	// make room and insert new stuff
; 1180 : 			_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
; 1181 : 				_Myptr() + _Off, _Mysize - _Off);	// empty out hole

$LN76@insert@2:
  000e7	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  000ea	89 4c 24 14	 mov	 DWORD PTR tv232[esp+12], ecx
$LN77@insert@2:
  000ee	83 f8 10	 cmp	 eax, 16			; 00000010H
  000f1	72 05		 jb	 SHORT $LN80@insert@2
  000f3	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000f6	eb 03		 jmp	 SHORT $LN81@insert@2
$LN80@insert@2:
  000f8	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
$LN81@insert@2:
  000fb	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  000fe	2b d7		 sub	 edx, edi
  00100	52		 push	 edx
  00101	8b 54 24 18	 mov	 edx, DWORD PTR tv232[esp+16]
  00105	03 d7		 add	 edx, edi
  00107	2b c7		 sub	 eax, edi
  00109	52		 push	 edx
  0010a	2b c3		 sub	 eax, ebx
  0010c	03 cf		 add	 ecx, edi
  0010e	50		 push	 eax
  0010f	03 cb		 add	 ecx, ebx
  00111	51		 push	 ecx
  00112	e8 00 00 00 00	 call	 _memmove_s

; 1182 : 			_Traits_helper::copy_s<_Traits>(_Myptr() + _Off, _Myres - _Off, _Ptr, _Count);	// fill hole

  00117	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0011a	83 c4 10	 add	 esp, 16			; 00000010H
  0011d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00120	72 05		 jb	 SHORT $LN92@insert@2
  00122	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00125	eb 03		 jmp	 SHORT $LN93@insert@2
$LN92@insert@2:
  00127	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
$LN93@insert@2:
  0012a	8b 54 24 18	 mov	 edx, DWORD PTR __Ptr$[esp+12]
  0012e	53		 push	 ebx
  0012f	52		 push	 edx
  00130	2b c7		 sub	 eax, edi
  00132	50		 push	 eax
  00133	03 cf		 add	 ecx, edi
  00135	51		 push	 ecx
  00136	e8 00 00 00 00	 call	 _memcpy_s
  0013b	83 c4 10	 add	 esp, 16			; 00000010H

; 1183 : 			_Eos(_Num);

  0013e	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00142	89 6e 14	 mov	 DWORD PTR [esi+20], ebp
  00145	72 10		 jb	 SHORT $LN106@insert@2
  00147	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0014a	c6 04 28 00	 mov	 BYTE PTR [eax+ebp], 0
  0014e	5d		 pop	 ebp
  0014f	5f		 pop	 edi

; 1184 : 			}
; 1185 : 		return (*this);

  00150	8b c6		 mov	 eax, esi
  00152	5e		 pop	 esi
  00153	5b		 pop	 ebx

; 1186 : 		}

  00154	c2 0c 00	 ret	 12			; 0000000cH

; 1183 : 			_Eos(_Num);

$LN106@insert@2:
  00157	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0015a	c6 04 28 00	 mov	 BYTE PTR [eax+ebp], 0
$LN111@insert@2:
  0015e	5d		 pop	 ebp
$LN108@insert@2:
  0015f	5f		 pop	 edi

; 1184 : 			}
; 1185 : 		return (*this);

  00160	8b c6		 mov	 eax, esi
  00162	5e		 pop	 esi
  00163	5b		 pop	 ebx

; 1186 : 		}

  00164	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Ptr$ = 12						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1189 : 		{	// insert [_Ptr, <null>) at _Off

  00000	56		 push	 esi

; 1190 : 		_DEBUG_POINTER(_Ptr);
; 1191 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));

  00001	8b 74 24 0c	 mov	 esi, DWORD PTR __Ptr$[esp]
  00005	8b c6		 mov	 eax, esi
  00007	57		 push	 edi
  00008	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000b	eb 03 8d 49 00	 npad	 5
$LL5@insert@3:
  00010	8a 10		 mov	 dl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 d2		 test	 dl, dl
  00015	75 f9		 jne	 SHORT $LL5@insert@3
  00017	2b c7		 sub	 eax, edi
  00019	50		 push	 eax
  0001a	8b 44 24 10	 mov	 eax, DWORD PTR __Off$[esp+8]
  0001e	56		 push	 esi
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 1192 : 		}

  00027	c2 08 00	 ret	 8
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
__Al$ = 20						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 625  : #if _HAS_ITERATOR_DEBUGGING
; 626  : 		if (_Right._Myfirstiter == _IGNORE_MYITERLIST)
; 627  : 			{
; 628  : 			this->_Myfirstiter = _IGNORE_MYITERLIST;
; 629  : 			}
; 630  : #endif
; 631  : 		_Tidy();
; 632  : 		assign(_Right, _Roff, _Count);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR __Right$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Roff$[esp]
  0000b	33 c0		 xor	 eax, eax
  0000d	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00010	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00017	88 46 04	 mov	 BYTE PTR [esi+4], al
  0001a	8b 44 24 10	 mov	 eax, DWORD PTR __Count$[esp]
  0001e	50		 push	 eax
  0001f	51		 push	 ecx
  00020	52		 push	 edx
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 633  : 		}

  00028	8b c6		 mov	 eax, esi
  0002a	5e		 pop	 esi
  0002b	c2 10 00	 ret	 16			; 00000010H
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtpy
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1041 : 		return (assign(_Right, 0, npos));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Right$[esp-4]
  00004	6a ff		 push	 -1
  00006	6a 00		 push	 0
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1042 : 		}

  0000e	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtpy
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1083 : 		{	// assign [_Ptr, <null>)

  00000	56		 push	 esi

; 1084 : 		_DEBUG_POINTER(_Ptr);
; 1085 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00001	8b 74 24 08	 mov	 esi, DWORD PTR __Ptr$[esp]
  00005	8b c6		 mov	 eax, esi
  00007	57		 push	 edi
  00008	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000b	eb 03 8d 49 00	 npad	 5
$LL5@assign@3:
  00010	8a 10		 mov	 dl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 d2		 test	 dl, dl
  00015	75 f9		 jne	 SHORT $LL5@assign@3
  00017	2b c7		 sub	 eax, edi
  00019	50		 push	 eax
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 1086 : 		}

  00022	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 935  : 		{	// append [_Ptr, <null>)

  00000	56		 push	 esi

; 936  : 		return (append(_Ptr));

  00001	8b 74 24 08	 mov	 esi, DWORD PTR __Ptr$[esp]
  00005	8b c6		 mov	 eax, esi
  00007	57		 push	 edi
  00008	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000b	eb 03 8d 49 00	 npad	 5
$LL7@operator:
  00010	8a 10		 mov	 dl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 d2		 test	 dl, dl
  00015	75 f9		 jne	 SHORT $LL7@operator
  00017	2b c7		 sub	 eax, edi
  00019	50		 push	 eax
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 937  : 		}

  00022	c2 04 00	 ret	 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 652  : 		_Tidy();
; 653  : 		assign(_Ptr);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR __Ptr$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	8b c2		 mov	 eax, edx
  00009	57		 push	 edi
  0000a	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00011	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00018	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
  0001c	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0001f	90		 npad	 1
$LL37@basic_stri@2:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $LL37@basic_stri@2
  00027	2b c7		 sub	 eax, edi
  00029	50		 push	 eax
  0002a	52		 push	 edx
  0002b	8b ce		 mov	 ecx, esi
  0002d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00032	5f		 pop	 edi

; 654  : 		}

  00033	8b c6		 mov	 eax, esi
  00035	5e		 pop	 esi
  00036	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 916  : 		return (assign(_Right));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Right$[esp-4]
  00004	6a ff		 push	 -1
  00006	6a 00		 push	 0
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 917  : 		}

  0000e	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
PUBLIC	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
; Function compile flags: /Ogtpy
;	COMDAT ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
_TEXT	SEGMENT
$T141815 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr, COMDAT
; _this$ = ecx

; 1998 : 		{	// return [_Off, _Off + _Count) as new string

  00000	51		 push	 ecx

; 1999 : 		return (_Myt(*this, _Off, _Count, get_allocator()));

  00001	8b 54 24 0c	 mov	 edx, DWORD PTR __Off$[esp]
  00005	56		 push	 esi
  00006	8b 74 24 0c	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+4]
  0000a	33 c0		 xor	 eax, eax
  0000c	89 46 14	 mov	 DWORD PTR [esi+20], eax
  0000f	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00016	89 44 24 04	 mov	 DWORD PTR $T141815[esp+8], eax
  0001a	88 46 04	 mov	 BYTE PTR [esi+4], al
  0001d	8b 44 24 14	 mov	 eax, DWORD PTR __Count$[esp+4]
  00021	50		 push	 eax
  00022	52		 push	 edx
  00023	51		 push	 ecx
  00024	8b ce		 mov	 ecx, esi
  00026	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0002b	8b c6		 mov	 eax, esi
  0002d	5e		 pop	 esi

; 2000 : 		}

  0002e	59		 pop	 ecx
  0002f	c2 0c 00	 ret	 12			; 0000000cH
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
_TEXT	ENDS
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z$0
__ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\string
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
_TEXT	SEGMENT
$T141961 = -44						; size = 4
$T141958 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 53   : 	{	// return string + NTCS

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	83 ec 20	 sub	 esp, 32			; 00000020H
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c4		 xor	 eax, esp
  0001a	50		 push	 eax
  0001b	8d 44 24 2c	 lea	 eax, DWORD PTR __$EHRec$[esp+56]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 54   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00025	8b 44 24 40	 mov	 eax, DWORD PTR __Left$[esp+52]
  00029	33 db		 xor	 ebx, ebx
  0002b	6a ff		 push	 -1
  0002d	53		 push	 ebx
  0002e	50		 push	 eax
  0002f	8d 4c 24 1c	 lea	 ecx, DWORD PTR $T141958[esp+68]
  00033	89 5c 24 18	 mov	 DWORD PTR $T141961[esp+68], ebx
  00037	c7 44 24 34 0f
	00 00 00	 mov	 DWORD PTR $T141958[esp+92], 15 ; 0000000fH
  0003f	89 5c 24 30	 mov	 DWORD PTR $T141958[esp+88], ebx
  00043	88 5c 24 20	 mov	 BYTE PTR $T141958[esp+72], bl
  00047	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0004c	8b 54 24 44	 mov	 edx, DWORD PTR __Right$[esp+52]
  00050	8b c2		 mov	 eax, edx
  00052	89 5c 24 34	 mov	 DWORD PTR __$EHRec$[esp+64], ebx
  00056	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  00059	8d a4 24 00 00
	00 00		 npad	 7
$LL90@operator@2:
  00060	8a 08		 mov	 cl, BYTE PTR [eax]
  00062	40		 inc	 eax
  00063	3a cb		 cmp	 cl, bl
  00065	75 f9		 jne	 SHORT $LL90@operator@2
  00067	2b c6		 sub	 eax, esi
  00069	50		 push	 eax
  0006a	52		 push	 edx
  0006b	8d 4c 24 18	 lea	 ecx, DWORD PTR $T141958[esp+64]
  0006f	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00074	8b 74 24 3c	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+52]
  00078	6a ff		 push	 -1
  0007a	53		 push	 ebx
  0007b	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00082	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  00085	50		 push	 eax
  00086	8b ce		 mov	 ecx, esi
  00088	88 5e 04	 mov	 BYTE PTR [esi+4], bl
  0008b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00090	83 7c 24 28 10	 cmp	 DWORD PTR $T141958[esp+80], 16 ; 00000010H
  00095	72 0d		 jb	 SHORT $LN91@operator@2
  00097	8b 4c 24 14	 mov	 ecx, DWORD PTR $T141958[esp+60]
  0009b	51		 push	 ecx
  0009c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a1	83 c4 04	 add	 esp, 4
$LN91@operator@2:
  000a4	8b c6		 mov	 eax, esi

; 55   : 	}

  000a6	8b 4c 24 2c	 mov	 ecx, DWORD PTR __$EHRec$[esp+56]
  000aa	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b1	59		 pop	 ecx
  000b2	5e		 pop	 esi
  000b3	5b		 pop	 ebx
  000b4	83 c4 2c	 add	 esp, 44			; 0000002cH
  000b7	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T141958[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 d8	 lea	 eax, DWORD PTR [edx-40]
  0000f	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??_C@_0BH@FAKCOHIL@SYS_ENC_UPGRADE_FAILED?$AA@	; `string'
PUBLIC	??_C@_08COBEBGNM@ROLLBACK?$AA@			; `string'
PUBLIC	??_C@_0BC@KNJLNLNB@INSTALL_COMPLETED?$AA@	; `string'
PUBLIC	??_C@_0BM@IAAIJFIC@System?5Favorite?5Volumes?4xml?$AA@ ; `string'
PUBLIC	??_C@_0CG@EGPGHNFL@TrueCrypt?5System?5Favorite?5Volume@ ; `string'
PUBLIC	??_C@_0BF@BECKOJBF@?2TrueCrypt?5Setup?4exe?$AA@	; `string'
PUBLIC	??_C@_09KHMMGKKB@?5?1a?5logon?$AA@		; `string'
PUBLIC	??_C@_09OAMOHPIB@favorites?$AA@			; `string'
PUBLIC	??_C@_0BI@DLANKHNO@openExplorerWindow?$DN?$CC1?$CC?5?$AA@ ; `string'
PUBLIC	??_C@_0BC@JBHLDJCD@mountOnLogOn?$DN?$CC1?$CC?5?$AA@ ; `string'
PUBLIC	??_C@_08JKOCNOKF@?$DMvolume?5?$AA@		; `string'
PUBLIC	??_C@_0BN@JJNCGBDA@OpenExplorerWindowAfterMount?$AA@ ; `string'
PUBLIC	??_C@_0BG@IDCDKCEI@MountFavoritesOnLogon?$AA@	; `string'
PUBLIC	??_C@_0EL@DAJCBMFB@SYSTEM?2CurrentControlSet?2Control@ ; `string'
PUBLIC	??_C@_0EL@LBBGNDAK@SYSTEM?2CurrentControlSet?2Control@ ; `string'
PUBLIC	??_C@_07LMLHFMEG@Service?$AA@			; `string'
PUBLIC	??_C@_0BP@JGNDMOPD@FAILED_TO_DISABLE_PAGING_FILES?$AA@ ; `string'
PUBLIC	??_C@_0BF@MGMPAIHN@CipherShed?5Setup?4exe?$AA@	; `string'
PUBLIC	_arg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_DoInstall
EXTRN	_SavePostInstallTasksSettings:PROC
EXTRN	_bPromptTutorial:DWORD
EXTRN	_bPromptReleaseNotes:DWORD
EXTRN	_Warning:PROC
EXTRN	__imp__MoveFileA@8:PROC
EXTRN	_GetProgramConfigPath:PROC
EXTRN	?RenameDeprecatedSystemLoaderBackup@BootEncryption@CipherShed@@QAEXXZ:PROC ; CipherShed::BootEncryption::RenameDeprecatedSystemLoaderBackup
EXTRN	_DoDriverInstall:PROC
EXTRN	_free:PROC
EXTRN	_LoadFile:PROC
EXTRN	_GetConfigPath:PROC
EXTRN	_ConfigReadInt:PROC
EXTRN	_ReadDriverConfigurationFlags:PROC
EXTRN	_DisablePagingFile:PROC
EXTRN	_IsPagingFileActive:PROC
EXTRN	_UpdateProgressBarProc:PROC
EXTRN	__imp__InvalidateRect@12:PROC
;	COMDAT ??_C@_0BH@FAKCOHIL@SYS_ENC_UPGRADE_FAILED?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
CONST	SEGMENT
??_C@_0BH@FAKCOHIL@SYS_ENC_UPGRADE_FAILED?$AA@ DB 'SYS_ENC_UPGRADE_FAILED'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08COBEBGNM@ROLLBACK?$AA@
CONST	SEGMENT
??_C@_08COBEBGNM@ROLLBACK?$AA@ DB 'ROLLBACK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KNJLNLNB@INSTALL_COMPLETED?$AA@
CONST	SEGMENT
??_C@_0BC@KNJLNLNB@INSTALL_COMPLETED?$AA@ DB 'INSTALL_COMPLETED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IAAIJFIC@System?5Favorite?5Volumes?4xml?$AA@
CONST	SEGMENT
??_C@_0BM@IAAIJFIC@System?5Favorite?5Volumes?4xml?$AA@ DB 'System Favorit'
	DB	'e Volumes.xml', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@EGPGHNFL@TrueCrypt?5System?5Favorite?5Volume@
CONST	SEGMENT
??_C@_0CG@EGPGHNFL@TrueCrypt?5System?5Favorite?5Volume@ DB 'TrueCrypt Sys'
	DB	'tem Favorite Volumes.xml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BECKOJBF@?2TrueCrypt?5Setup?4exe?$AA@
CONST	SEGMENT
??_C@_0BF@BECKOJBF@?2TrueCrypt?5Setup?4exe?$AA@ DB '\TrueCrypt Setup.exe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KHMMGKKB@?5?1a?5logon?$AA@
CONST	SEGMENT
??_C@_09KHMMGKKB@?5?1a?5logon?$AA@ DB ' /a logon', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OAMOHPIB@favorites?$AA@
CONST	SEGMENT
??_C@_09OAMOHPIB@favorites?$AA@ DB 'favorites', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DLANKHNO@openExplorerWindow?$DN?$CC1?$CC?5?$AA@
CONST	SEGMENT
??_C@_0BI@DLANKHNO@openExplorerWindow?$DN?$CC1?$CC?5?$AA@ DB 'openExplore'
	DB	'rWindow="1" ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JBHLDJCD@mountOnLogOn?$DN?$CC1?$CC?5?$AA@
CONST	SEGMENT
??_C@_0BC@JBHLDJCD@mountOnLogOn?$DN?$CC1?$CC?5?$AA@ DB 'mountOnLogOn="1" '
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08JKOCNOKF@?$DMvolume?5?$AA@
CONST	SEGMENT
??_C@_08JKOCNOKF@?$DMvolume?5?$AA@ DB '<volume ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JJNCGBDA@OpenExplorerWindowAfterMount?$AA@
CONST	SEGMENT
??_C@_0BN@JJNCGBDA@OpenExplorerWindowAfterMount?$AA@ DB 'OpenExplorerWind'
	DB	'owAfterMount', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IDCDKCEI@MountFavoritesOnLogon?$AA@
CONST	SEGMENT
??_C@_0BG@IDCDKCEI@MountFavoritesOnLogon?$AA@ DB 'MountFavoritesOnLogon', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@DAJCBMFB@SYSTEM?2CurrentControlSet?2Control@
CONST	SEGMENT
??_C@_0EL@DAJCBMFB@SYSTEM?2CurrentControlSet?2Control@ DB 'SYSTEM\Current'
	DB	'ControlSet\Control\SafeBoot\Network\TrueCryptSystemFavorites', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@LBBGNDAK@SYSTEM?2CurrentControlSet?2Control@
CONST	SEGMENT
??_C@_0EL@LBBGNDAK@SYSTEM?2CurrentControlSet?2Control@ DB 'SYSTEM\Current'
	DB	'ControlSet\Control\SafeBoot\Minimal\TrueCryptSystemFavorites', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LMLHFMEG@Service?$AA@
CONST	SEGMENT
??_C@_07LMLHFMEG@Service?$AA@ DB 'Service', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JGNDMOPD@FAILED_TO_DISABLE_PAGING_FILES?$AA@
CONST	SEGMENT
??_C@_0BP@JGNDMOPD@FAILED_TO_DISABLE_PAGING_FILES?$AA@ DB 'FAILED_TO_DISA'
	DB	'BLE_PAGING_FILES', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MGMPAIHN@CipherShed?5Setup?4exe?$AA@
CONST	SEGMENT
??_C@_0BF@MGMPAIHN@CipherShed?5Setup?4exe?$AA@ DB 'CipherShed Setup.exe', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$_DoInstall$28 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_DoInstall$7
__catchsym$_DoInstall$27 DD 08H
	DD	FLAT:??_R0?AUException@CipherShed@@@8
	DD	0ffffffd8H
	DD	FLAT:__catch$_DoInstall$2
__catchsym$_DoInstall$26 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_DoInstall$3
__catchsym$_DoInstall$25 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_DoInstall$0
__ehfuncinfo$_DoInstall DD 019930522H
	DD	016H
	DD	FLAT:__unwindtable$_DoInstall
	DD	04H
	DD	FLAT:__tryblocktable$_DoInstall
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$_DoInstall DD 0cH
	DD	0cH
	DD	0dH
	DD	01H
	DD	FLAT:__catchsym$_DoInstall$25
	DD	010H
	DD	010H
	DD	011H
	DD	01H
	DD	FLAT:__catchsym$_DoInstall$26
	DD	0eH
	DD	0eH
	DD	011H
	DD	01H
	DD	FLAT:__catchsym$_DoInstall$27
	DD	013H
	DD	013H
	DD	014H
	DD	01H
	DD	FLAT:__catchsym$_DoInstall$28
__unwindtable$_DoInstall DD 0ffffffffH
	DD	FLAT:__unwindfunclet$_DoInstall$9
	DD	00H
	DD	FLAT:__unwindfunclet$_DoInstall$10
	DD	01H
	DD	FLAT:__unwindfunclet$_DoInstall$11
	DD	02H
	DD	FLAT:__unwindfunclet$_DoInstall$12
	DD	03H
	DD	FLAT:__unwindfunclet$_DoInstall$13
	DD	04H
	DD	FLAT:__unwindfunclet$_DoInstall$14
	DD	05H
	DD	FLAT:__unwindfunclet$_DoInstall$15
	DD	06H
	DD	FLAT:__unwindfunclet$_DoInstall$16
	DD	07H
	DD	FLAT:__unwindfunclet$_DoInstall$17
	DD	08H
	DD	FLAT:__unwindfunclet$_DoInstall$18
	DD	09H
	DD	FLAT:__unwindfunclet$_DoInstall$19
	DD	0aH
	DD	FLAT:__unwindfunclet$_DoInstall$20
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0fH
	DD	00H
	DD	0fH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$_DoInstall$22
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$_DoInstall$23
; Function compile flags: /Ogtpy
; File c:\home\public\desktop\projects\ciphershed.build\src\setup\setup.c
xdata$x	ENDS
;	COMDAT _DoInstall
_TEXT	SEGMENT
$T142322 = -320						; size = 28
$T142329 = -292						; size = 28
$T142324 = -264						; size = 28
$T142332 = -236						; size = 28
$T142328 = -208						; size = 28
$T142331 = -180						; size = 28
$T142325 = -152						; size = 28
$T142327 = -124						; size = 28
$T142323 = -96						; size = 28
$T142330 = -68						; size = 28
_e$134877 = -40						; size = 4
_favoritesFilename$134892 = -36				; size = 4
_arg$GSCopy$ = -32					; size = 4
_bOK$ = -28						; size = 4
$T142346 = -24						; size = 4
_size$134893 = -24					; size = 4
_bOpenExplorerWindowAfterMount$134888 = -17		; size = 1
$T142321 = -17						; size = 1
__$EHRec$ = -16						; size = 16
_bootEnc$ = 0						; size = 1560
_sysFavorites$135022 = 1560				; size = 28
$T142334 = 1560						; size = 28
_legacySysFavorites$135025 = 1588			; size = 28
_favorites$134896 = 1588				; size = 28
$T142333 = 1588						; size = 28
_path$ = 1616						; size = 260
_regVal$134998 = 1876					; size = 520
_szTmp$134850 = 1876					; size = 520
_regk$134997 = 2396					; size = 64
__$ArrayPad$ = 2460					; size = 4
_arg$ = 2472						; size = 4
_DoInstall PROC						; COMDAT

; 1802 : {

  00000	55		 push	 ebp
  00001	8d ac 24 60 f6
	ff ff		 lea	 ebp, DWORD PTR [esp-2464]
  00008	81 ec a0 09 00
	00		 sub	 esp, 2464		; 000009a0H
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$_DoInstall
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	81 ec 34 01 00
	00		 sub	 esp, 308		; 00000134H
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	89 85 9c 09 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002f	53		 push	 ebx
  00030	56		 push	 esi
  00031	57		 push	 edi
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0003f	8b b5 a8 09 00
	00		 mov	 esi, DWORD PTR _arg$[ebp]
  00045	33 db		 xor	 ebx, ebx

; 1803 : 	HWND hwndDlg = (HWND) arg;
; 1804 : 	BOOL bOK = TRUE;

  00047	bf 01 00 00 00	 mov	 edi, 1

; 1805 : 	char path[MAX_PATH];
; 1806 : 
; 1807 : 	/* BootEncryption instance. */
; 1808 : 	BootEncryption bootEnc (hwndDlg);

  0004c	56		 push	 esi
  0004d	8d 4d 00	 lea	 ecx, DWORD PTR _bootEnc$[ebp]
  00050	89 75 e0	 mov	 DWORD PTR _arg$GSCopy$[ebp], esi
  00053	89 5d e8	 mov	 DWORD PTR $T142346[ebp], ebx
  00056	89 7d e4	 mov	 DWORD PTR _bOK$[ebp], edi
  00059	e8 00 00 00 00	 call	 ??0BootEncryption@CipherShed@@QAE@PAUHWND__@@@Z ; CipherShed::BootEncryption::BootEncryption

; 1809 : 
; 1810 : 	// Refresh the main GUI (wizard thread)
; 1811 : 	InvalidateRect (MainDlg, NULL, TRUE);

  0005e	a1 00 00 00 00	 mov	 eax, DWORD PTR _MainDlg
  00063	57		 push	 edi
  00064	53		 push	 ebx
  00065	50		 push	 eax
  00066	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InvalidateRect@12

; 1812 : 
; 1813 : 	ClearLogWindow (hwndDlg);

  0006f	53		 push	 ebx
  00070	53		 push	 ebx
  00071	68 84 01 00 00	 push	 388			; 00000184H
  00076	68 f9 03 00 00	 push	 1017			; 000003f9H
  0007b	56		 push	 esi
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00082	50		 push	 eax
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 1814 : 
; 1815 : 	/* Create the installation folder if it doesn't already exist. */
; 1816 : 	if (mkfulldir (InstallationPath, TRUE) != 0)

  00089	57		 push	 edi
  0008a	68 00 00 00 00	 push	 OFFSET _InstallationPath
  0008f	e8 00 00 00 00	 call	 _mkfulldir
  00094	83 c4 08	 add	 esp, 8
  00097	85 c0		 test	 eax, eax
  00099	74 6e		 je	 SHORT $LN59@DoInstall

; 1817 : 	{
; 1818 : 		if (mkfulldir (InstallationPath, FALSE) != 0)

  0009b	53		 push	 ebx
  0009c	68 00 00 00 00	 push	 OFFSET _InstallationPath
  000a1	e8 00 00 00 00	 call	 _mkfulldir
  000a6	83 c4 08	 add	 esp, 8
  000a9	85 c0		 test	 eax, eax
  000ab	74 5c		 je	 SHORT $LN59@DoInstall

; 1819 : 		{
; 1820 : 			wchar_t szTmp[TC_MAX_PATH];
; 1821 : 
; 1822 : 			handleWin32Error (hwndDlg);

  000ad	56		 push	 esi
  000ae	e8 00 00 00 00	 call	 _handleWin32Error
  000b3	83 c4 04	 add	 esp, 4

; 1823 : 			wsprintfW (szTmp, GetString ("CANT_CREATE_FOLDER"), InstallationPath);

  000b6	68 00 00 00 00	 push	 OFFSET _InstallationPath
  000bb	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KJOFIBFE@CANT_CREATE_FOLDER?$AA@
  000c0	e8 00 00 00 00	 call	 _GetString
  000c5	83 c4 04	 add	 esp, 4
  000c8	50		 push	 eax
  000c9	8d 8d 54 07 00
	00		 lea	 ecx, DWORD PTR _szTmp$134850[ebp]
  000cf	51		 push	 ecx
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfW

; 1824 : 			MessageBoxW (hwndDlg, szTmp, lpszTitle, MB_ICONHAND);

  000d6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lpszTitle
  000dc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000df	6a 10		 push	 16			; 00000010H
  000e1	52		 push	 edx
  000e2	8d 85 54 07 00
	00		 lea	 eax, DWORD PTR _szTmp$134850[ebp]
  000e8	50		 push	 eax
  000e9	56		 push	 esi
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 1825 : 			Error ("INSTALL_FAILED");

  000f0	68 00 00 00 00	 push	 OFFSET ??_C@_0P@DHOALJNC@INSTALL_FAILED?$AA@
  000f5	e8 00 00 00 00	 call	 _Error
  000fa	83 c4 04	 add	 esp, 4

; 1826 : 			PostMessage (MainDlg, TC_APPMSG_INSTALL_FAILURE, 0, 0);

  000fd	53		 push	 ebx
  000fe	53		 push	 ebx
  000ff	68 94 81 00 00	 push	 33172			; 00008194H

; 1827 : 			return;

  00104	e9 98 0b 00 00	 jmp	 $LN537@DoInstall
$LN59@DoInstall:

; 1828 : 		}
; 1829 : 	}
; 1830 : 
; 1831 : 	UpdateProgressBarProc(2);

  00109	6a 02		 push	 2
  0010b	e8 00 00 00 00	 call	 _UpdateProgressBarProc

; 1832 : 
; 1833 : 	/* Unload the kernel driver, in case of full system encryption the driver is NOT unloaded. */
; 1834 : 	if (DoDriverUnload (hwndDlg) == FALSE)

  00110	56		 push	 esi
  00111	e8 00 00 00 00	 call	 _DoDriverUnload
  00116	83 c4 08	 add	 esp, 8
  00119	85 c0		 test	 eax, eax
  0011b	75 1a		 jne	 SHORT $LN58@DoInstall

; 1835 : 	{
; 1836 : 		NormalCursor ();

  0011d	e8 00 00 00 00	 call	 _NormalCursor

; 1837 : 		PostMessage (MainDlg, TC_APPMSG_INSTALL_FAILURE, 0, 0);

  00122	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  00128	6a 00		 push	 0
  0012a	6a 00		 push	 0
  0012c	68 94 81 00 00	 push	 33172			; 00008194H
  00131	52		 push	 edx

; 1838 : 		return;

  00132	e9 71 0b 00 00	 jmp	 $LN538@DoInstall
$LN58@DoInstall:

; 1839 : 	}
; 1840 : 
; 1841 : 	/* Check if the previous installed version is running. */
; 1842 : 	if (bUpgrade
; 1843 : 		&&	(
; 1844 : 			/* CipherShed. */
; 1845 : 			IsFileInUse (string (InstallationPath) + TC_APP_NAME ".exe")
; 1846 : 			|| IsFileInUse (string (InstallationPath) + TC_APP_NAME " Format.exe")
; 1847 : 			|| IsFileInUse (string (InstallationPath) + TC_APP_NAME " Setup.exe")
; 1848 : 			/* TrueCrypt. */
; 1849 : 			|| IsFileInUse (string (UninstallationPath) + TC_APP_NAME_LEGACY ".exe")
; 1850 : 			|| IsFileInUse (string (UninstallationPath) + TC_APP_NAME_LEGACY " Format.exe")
; 1851 : 			|| IsFileInUse (string (UninstallationPath) + TC_APP_NAME_LEGACY " Setup.exe")
; 1852 : 			)
; 1853 : 		)

  00137	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bUpgrade, 0
  0013e	0f 84 c4 01 00
	00		 je	 $LN511@DoInstall
  00144	68 00 00 00 00	 push	 OFFSET _InstallationPath
  00149	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR $T142322[ebp]
  0014f	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00154	68 00 00 00 00	 push	 OFFSET ??_C@_0P@KEOPEMDF@CipherShed?4exe?$AA@
  00159	50		 push	 eax
  0015a	8d 45 a0	 lea	 eax, DWORD PTR $T142323[ebp]
  0015d	50		 push	 eax
  0015e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00162	89 7d e8	 mov	 DWORD PTR $T142346[ebp], edi
  00165	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0016a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0016d	bb 03 00 00 00	 mov	 ebx, 3
  00172	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2
  00179	89 5d e8	 mov	 DWORD PTR $T142346[ebp], ebx
  0017c	e8 00 00 00 00	 call	 ?IsFileInUse@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; IsFileInUse
  00181	85 c0		 test	 eax, eax
  00183	0f 85 74 01 00
	00		 jne	 $LN508@DoInstall
  00189	68 00 00 00 00	 push	 OFFSET _InstallationPath
  0018e	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR $T142324[ebp]
  00194	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00199	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@NHCNJMON@CipherShed?5Format?4exe?$AA@
  0019e	50		 push	 eax
  0019f	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR $T142325[ebp]
  001a5	be 07 00 00 00	 mov	 esi, 7
  001aa	51		 push	 ecx
  001ab	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx
  001ae	89 75 e8	 mov	 DWORD PTR $T142346[ebp], esi
  001b1	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  001b6	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b9	bf 0f 00 00 00	 mov	 edi, 15			; 0000000fH
  001be	8b df		 mov	 ebx, edi
  001c0	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4
  001c7	89 5d e8	 mov	 DWORD PTR $T142346[ebp], ebx
  001ca	e8 00 00 00 00	 call	 ?IsFileInUse@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; IsFileInUse
  001cf	85 c0		 test	 eax, eax
  001d1	0f 85 2b 01 00
	00		 jne	 $LN63@DoInstall
  001d7	68 00 00 00 00	 push	 OFFSET _InstallationPath
  001dc	8d 4d 84	 lea	 ecx, DWORD PTR $T142327[ebp]
  001df	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  001e4	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@MGMPAIHN@CipherShed?5Setup?4exe?$AA@
  001e9	50		 push	 eax
  001ea	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR $T142328[ebp]
  001f0	52		 push	 edx
  001f1	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 5
  001f8	c7 45 e8 1f 00
	00 00		 mov	 DWORD PTR $T142346[ebp], 31 ; 0000001fH
  001ff	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00204	83 c4 0c	 add	 esp, 12			; 0000000cH
  00207	bb 3f 00 00 00	 mov	 ebx, 63			; 0000003fH
  0020c	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 6
  00213	89 5d e8	 mov	 DWORD PTR $T142346[ebp], ebx
  00216	e8 00 00 00 00	 call	 ?IsFileInUse@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; IsFileInUse
  0021b	85 c0		 test	 eax, eax
  0021d	0f 85 df 00 00
	00		 jne	 $LN63@DoInstall
  00223	68 00 00 00 00	 push	 OFFSET ?UninstallationPath@@3PADA ; UninstallationPath
  00228	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR $T142329[ebp]
  0022e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00233	68 00 00 00 00	 push	 OFFSET ??_C@_0O@DFMLFAG@TrueCrypt?4exe?$AA@
  00238	50		 push	 eax
  00239	8d 45 bc	 lea	 eax, DWORD PTR $T142330[ebp]
  0023c	50		 push	 eax
  0023d	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+12], esi
  00240	c7 45 e8 7f 00
	00 00		 mov	 DWORD PTR $T142346[ebp], 127 ; 0000007fH
  00247	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0024c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0024f	bb ff 00 00 00	 mov	 ebx, 255		; 000000ffH
  00254	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 8
  0025b	89 5d e8	 mov	 DWORD PTR $T142346[ebp], ebx
  0025e	e8 00 00 00 00	 call	 ?IsFileInUse@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; IsFileInUse
  00263	85 c0		 test	 eax, eax
  00265	0f 85 97 00 00
	00		 jne	 $LN63@DoInstall
  0026b	68 00 00 00 00	 push	 OFFSET ?UninstallationPath@@3PADA ; UninstallationPath
  00270	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR $T142331[ebp]
  00276	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0027b	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PLOADIIL@TrueCrypt?5Format?4exe?$AA@
  00280	50		 push	 eax
  00281	8d 8d 14 ff ff
	ff		 lea	 ecx, DWORD PTR $T142332[ebp]
  00287	51		 push	 ecx
  00288	c7 45 fc 09 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 9
  0028f	c7 45 e8 ff 01
	00 00		 mov	 DWORD PTR $T142346[ebp], 511 ; 000001ffH
  00296	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0029b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0029e	bb ff 03 00 00	 mov	 ebx, 1023		; 000003ffH
  002a3	c7 45 fc 0a 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 10 ; 0000000aH
  002aa	89 5d e8	 mov	 DWORD PTR $T142346[ebp], ebx
  002ad	e8 00 00 00 00	 call	 ?IsFileInUse@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; IsFileInUse
  002b2	85 c0		 test	 eax, eax
  002b4	75 4c		 jne	 SHORT $LN63@DoInstall
  002b6	68 00 00 00 00	 push	 OFFSET ?UninstallationPath@@3PADA ; UninstallationPath
  002bb	8d 8d 34 06 00
	00		 lea	 ecx, DWORD PTR $T142333[ebp]
  002c1	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  002c6	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@NCPFOFMD@TrueCrypt?5Setup?4exe?$AA@
  002cb	50		 push	 eax
  002cc	8d 95 18 06 00
	00		 lea	 edx, DWORD PTR $T142334[ebp]
  002d2	52		 push	 edx
  002d3	c7 45 fc 0b 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 11 ; 0000000bH
  002da	c7 45 e8 ff 07
	00 00		 mov	 DWORD PTR $T142346[ebp], 2047 ; 000007ffH
  002e1	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  002e6	83 c4 0c	 add	 esp, 12			; 0000000cH
  002e9	bb ff 0f 00 00	 mov	 ebx, 4095		; 00000fffH
  002ee	e8 00 00 00 00	 call	 ?IsFileInUse@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; IsFileInUse
  002f3	85 c0		 test	 eax, eax
  002f5	74 16		 je	 SHORT $LN64@DoInstall
  002f7	c6 45 ef 01	 mov	 BYTE PTR $T142321[ebp], 1
  002fb	eb 14		 jmp	 SHORT $LN65@DoInstall
$LN508@DoInstall:
  002fd	bf 0f 00 00 00	 mov	 edi, 15			; 0000000fH
$LN63@DoInstall:
  00302	c6 45 ef 01	 mov	 BYTE PTR $T142321[ebp], 1
  00306	eb 09		 jmp	 SHORT $LN65@DoInstall
$LN511@DoInstall:
  00308	bf 0f 00 00 00	 mov	 edi, 15			; 0000000fH
$LN64@DoInstall:
  0030d	c6 45 ef 00	 mov	 BYTE PTR $T142321[ebp], 0
$LN65@DoInstall:
  00311	be 10 00 00 00	 mov	 esi, 16			; 00000010H
  00316	f7 c3 00 08 00
	00		 test	 ebx, 2048		; 00000800H
  0031c	74 34		 je	 SHORT $LN148@DoInstall
  0031e	81 e3 ff f7 ff
	ff		 and	 ebx, -2049		; fffff7ffH
  00324	39 b5 30 06 00
	00		 cmp	 DWORD PTR $T142334[ebp+24], esi
  0032a	72 0f		 jb	 SHORT $LN140@DoInstall
  0032c	8b 85 1c 06 00
	00		 mov	 eax, DWORD PTR $T142334[ebp+4]
  00332	50		 push	 eax
  00333	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00338	83 c4 04	 add	 esp, 4
$LN140@DoInstall:
  0033b	89 bd 30 06 00
	00		 mov	 DWORD PTR $T142334[ebp+24], edi
  00341	c7 85 2c 06 00
	00 00 00 00 00	 mov	 DWORD PTR $T142334[ebp+20], 0
  0034b	c6 85 1c 06 00
	00 00		 mov	 BYTE PTR $T142334[ebp+4], 0
$LN148@DoInstall:
  00352	f7 c3 00 04 00
	00		 test	 ebx, 1024		; 00000400H
  00358	74 34		 je	 SHORT $LN174@DoInstall
  0035a	81 e3 ff fb ff
	ff		 and	 ebx, -1025		; fffffbffH
  00360	39 b5 4c 06 00
	00		 cmp	 DWORD PTR $T142333[ebp+24], esi
  00366	72 0f		 jb	 SHORT $LN166@DoInstall
  00368	8b 8d 38 06 00
	00		 mov	 ecx, DWORD PTR $T142333[ebp+4]
  0036e	51		 push	 ecx
  0036f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00374	83 c4 04	 add	 esp, 4
$LN166@DoInstall:
  00377	89 bd 4c 06 00
	00		 mov	 DWORD PTR $T142333[ebp+24], edi
  0037d	c7 85 48 06 00
	00 00 00 00 00	 mov	 DWORD PTR $T142333[ebp+20], 0
  00387	c6 85 38 06 00
	00 00		 mov	 BYTE PTR $T142333[ebp+4], 0
$LN174@DoInstall:
  0038e	f7 c3 00 02 00
	00		 test	 ebx, 512		; 00000200H
  00394	74 34		 je	 SHORT $LN200@DoInstall
  00396	81 e3 ff fd ff
	ff		 and	 ebx, -513		; fffffdffH
  0039c	39 b5 2c ff ff
	ff		 cmp	 DWORD PTR $T142332[ebp+24], esi
  003a2	72 0f		 jb	 SHORT $LN192@DoInstall
  003a4	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR $T142332[ebp+4]
  003aa	52		 push	 edx
  003ab	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  003b0	83 c4 04	 add	 esp, 4
$LN192@DoInstall:
  003b3	89 bd 2c ff ff
	ff		 mov	 DWORD PTR $T142332[ebp+24], edi
  003b9	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T142332[ebp+20], 0
  003c3	c6 85 18 ff ff
	ff 00		 mov	 BYTE PTR $T142332[ebp+4], 0
$LN200@DoInstall:
  003ca	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H
  003d0	74 34		 je	 SHORT $LN226@DoInstall
  003d2	81 e3 ff fe ff
	ff		 and	 ebx, -257		; fffffeffH
  003d8	39 b5 64 ff ff
	ff		 cmp	 DWORD PTR $T142331[ebp+24], esi
  003de	72 0f		 jb	 SHORT $LN218@DoInstall
  003e0	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR $T142331[ebp+4]
  003e6	50		 push	 eax
  003e7	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  003ec	83 c4 04	 add	 esp, 4
$LN218@DoInstall:
  003ef	89 bd 64 ff ff
	ff		 mov	 DWORD PTR $T142331[ebp+24], edi
  003f5	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T142331[ebp+20], 0
  003ff	c6 85 50 ff ff
	ff 00		 mov	 BYTE PTR $T142331[ebp+4], 0
$LN226@DoInstall:
  00406	84 db		 test	 bl, bl
  00408	79 25		 jns	 SHORT $LN252@DoInstall
  0040a	81 e3 7f ff ff
	ff		 and	 ebx, -129		; ffffff7fH
  00410	39 75 d4	 cmp	 DWORD PTR $T142330[ebp+24], esi
  00413	72 0c		 jb	 SHORT $LN244@DoInstall
  00415	8b 4d c0	 mov	 ecx, DWORD PTR $T142330[ebp+4]
  00418	51		 push	 ecx
  00419	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0041e	83 c4 04	 add	 esp, 4
$LN244@DoInstall:
  00421	89 7d d4	 mov	 DWORD PTR $T142330[ebp+24], edi
  00424	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T142330[ebp+20], 0
  0042b	c6 45 c0 00	 mov	 BYTE PTR $T142330[ebp+4], 0
$LN252@DoInstall:
  0042f	f6 c3 40	 test	 bl, 64			; 00000040H
  00432	74 31		 je	 SHORT $LN278@DoInstall
  00434	83 e3 bf	 and	 ebx, -65		; ffffffbfH
  00437	39 b5 f4 fe ff
	ff		 cmp	 DWORD PTR $T142329[ebp+24], esi
  0043d	72 0f		 jb	 SHORT $LN270@DoInstall
  0043f	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR $T142329[ebp+4]
  00445	52		 push	 edx
  00446	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0044b	83 c4 04	 add	 esp, 4
$LN270@DoInstall:
  0044e	89 bd f4 fe ff
	ff		 mov	 DWORD PTR $T142329[ebp+24], edi
  00454	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T142329[ebp+20], 0
  0045e	c6 85 e0 fe ff
	ff 00		 mov	 BYTE PTR $T142329[ebp+4], 0
$LN278@DoInstall:
  00465	f6 c3 20	 test	 bl, 32			; 00000020H
  00468	74 31		 je	 SHORT $LN304@DoInstall
  0046a	83 e3 df	 and	 ebx, -33		; ffffffdfH
  0046d	39 b5 48 ff ff
	ff		 cmp	 DWORD PTR $T142328[ebp+24], esi
  00473	72 0f		 jb	 SHORT $LN296@DoInstall
  00475	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR $T142328[ebp+4]
  0047b	50		 push	 eax
  0047c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00481	83 c4 04	 add	 esp, 4
$LN296@DoInstall:
  00484	89 bd 48 ff ff
	ff		 mov	 DWORD PTR $T142328[ebp+24], edi
  0048a	c7 85 44 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T142328[ebp+20], 0
  00494	c6 85 34 ff ff
	ff 00		 mov	 BYTE PTR $T142328[ebp+4], 0
$LN304@DoInstall:
  0049b	f6 c3 10	 test	 bl, 16			; 00000010H
  0049e	74 22		 je	 SHORT $LN330@DoInstall
  004a0	83 e3 ef	 and	 ebx, -17		; ffffffefH
  004a3	39 75 9c	 cmp	 DWORD PTR $T142327[ebp+24], esi
  004a6	72 0c		 jb	 SHORT $LN322@DoInstall
  004a8	8b 4d 88	 mov	 ecx, DWORD PTR $T142327[ebp+4]
  004ab	51		 push	 ecx
  004ac	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  004b1	83 c4 04	 add	 esp, 4
$LN322@DoInstall:
  004b4	89 7d 9c	 mov	 DWORD PTR $T142327[ebp+24], edi
  004b7	c7 45 98 00 00
	00 00		 mov	 DWORD PTR $T142327[ebp+20], 0
  004be	c6 45 88 00	 mov	 BYTE PTR $T142327[ebp+4], 0
$LN330@DoInstall:
  004c2	f6 c3 08	 test	 bl, 8
  004c5	74 2b		 je	 SHORT $LN356@DoInstall
  004c7	83 e3 f7	 and	 ebx, -9			; fffffff7H
  004ca	39 75 80	 cmp	 DWORD PTR $T142325[ebp+24], esi
  004cd	72 0f		 jb	 SHORT $LN348@DoInstall
  004cf	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR $T142325[ebp+4]
  004d5	52		 push	 edx
  004d6	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  004db	83 c4 04	 add	 esp, 4
$LN348@DoInstall:
  004de	89 7d 80	 mov	 DWORD PTR $T142325[ebp+24], edi
  004e1	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T142325[ebp+20], 0
  004eb	c6 85 6c ff ff
	ff 00		 mov	 BYTE PTR $T142325[ebp+4], 0
$LN356@DoInstall:
  004f2	f6 c3 04	 test	 bl, 4
  004f5	74 31		 je	 SHORT $LN382@DoInstall
  004f7	83 e3 fb	 and	 ebx, -5			; fffffffbH
  004fa	39 b5 10 ff ff
	ff		 cmp	 DWORD PTR $T142324[ebp+24], esi
  00500	72 0f		 jb	 SHORT $LN374@DoInstall
  00502	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR $T142324[ebp+4]
  00508	50		 push	 eax
  00509	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0050e	83 c4 04	 add	 esp, 4
$LN374@DoInstall:
  00511	89 bd 10 ff ff
	ff		 mov	 DWORD PTR $T142324[ebp+24], edi
  00517	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T142324[ebp+20], 0
  00521	c6 85 fc fe ff
	ff 00		 mov	 BYTE PTR $T142324[ebp+4], 0
$LN382@DoInstall:
  00528	f6 c3 02	 test	 bl, 2
  0052b	74 22		 je	 SHORT $LN408@DoInstall
  0052d	83 e3 fd	 and	 ebx, -3			; fffffffdH
  00530	39 75 b8	 cmp	 DWORD PTR $T142323[ebp+24], esi
  00533	72 0c		 jb	 SHORT $LN400@DoInstall
  00535	8b 4d a4	 mov	 ecx, DWORD PTR $T142323[ebp+4]
  00538	51		 push	 ecx
  00539	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0053e	83 c4 04	 add	 esp, 4
$LN400@DoInstall:
  00541	89 7d b8	 mov	 DWORD PTR $T142323[ebp+24], edi
  00544	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR $T142323[ebp+20], 0
  0054b	c6 45 a4 00	 mov	 BYTE PTR $T142323[ebp+4], 0
$LN408@DoInstall:
  0054f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00556	f6 c3 01	 test	 bl, 1
  00559	74 17		 je	 SHORT $LN426@DoInstall
  0055b	39 b5 d8 fe ff
	ff		 cmp	 DWORD PTR $T142322[ebp+24], esi
  00561	72 0f		 jb	 SHORT $LN426@DoInstall
  00563	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR $T142322[ebp+4]
  00569	52		 push	 edx
  0056a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0056f	83 c4 04	 add	 esp, 4
$LN426@DoInstall:
  00572	80 7d ef 00	 cmp	 BYTE PTR $T142321[ebp], 0
  00576	74 26		 je	 SHORT $LN57@DoInstall

; 1854 : 	{
; 1855 : 		NormalCursor ();

  00578	e8 00 00 00 00	 call	 _NormalCursor

; 1856 : 		Error ("CLOSE_TC_FIRST");

  0057d	68 00 00 00 00	 push	 OFFSET ??_C@_0P@KGAEHPDJ@CLOSE_TC_FIRST?$AA@
  00582	e8 00 00 00 00	 call	 _Error

; 1857 : 		PostMessage (MainDlg, TC_APPMSG_INSTALL_FAILURE, 0, 0);

  00587	a1 00 00 00 00	 mov	 eax, DWORD PTR _MainDlg
  0058c	83 c4 04	 add	 esp, 4
  0058f	6a 00		 push	 0
  00591	6a 00		 push	 0
  00593	68 94 81 00 00	 push	 33172			; 00008194H
  00598	50		 push	 eax

; 1858 : 		return;

  00599	e9 0a 07 00 00	 jmp	 $LN538@DoInstall
$LN57@DoInstall:

; 1859 : 	}
; 1860 : 
; 1861 : 	UpdateProgressBarProc(12);

  0059e	6a 0c		 push	 12			; 0000000cH
  005a0	e8 00 00 00 00	 call	 _UpdateProgressBarProc

; 1862 : 
; 1863 : 	/* Begin system restore point. */
; 1864 : 	if (bSystemRestore)
; 1865 : 		SetSystemRestorePoint (hwndDlg, FALSE);

  005a5	8b 75 e0	 mov	 esi, DWORD PTR _arg$GSCopy$[ebp]
  005a8	83 c4 04	 add	 esp, 4
  005ab	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bSystemRestore, 0
  005b2	74 0a		 je	 SHORT $LN56@DoInstall
  005b4	6a 00		 push	 0
  005b6	e8 00 00 00 00	 call	 ?SetSystemRestorePoint@@YAXPAUHWND__@@H@Z ; SetSystemRestorePoint
  005bb	83 c4 04	 add	 esp, 4
$LN56@DoInstall:

; 1866 : 
; 1867 : 	UpdateProgressBarProc(48);

  005be	6a 30		 push	 48			; 00000030H
  005c0	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  005c5	83 c4 04	 add	 esp, 4

; 1868 : 
; 1869 : 	if (bDisableSwapFiles
; 1870 : 		&& IsPagingFileActive (FALSE))

  005c8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bDisableSwapFiles, 0
  005cf	74 36		 je	 SHORT $LN53@DoInstall
  005d1	6a 00		 push	 0
  005d3	e8 00 00 00 00	 call	 _IsPagingFileActive
  005d8	83 c4 04	 add	 esp, 4
  005db	85 c0		 test	 eax, eax
  005dd	74 28		 je	 SHORT $LN53@DoInstall

; 1871 : 	{
; 1872 : 		if (!DisablePagingFile())

  005df	e8 00 00 00 00	 call	 _DisablePagingFile
  005e4	85 c0		 test	 eax, eax
  005e6	75 15		 jne	 SHORT $LN54@DoInstall

; 1873 : 		{
; 1874 : 			handleWin32Error (hwndDlg);

  005e8	56		 push	 esi
  005e9	e8 00 00 00 00	 call	 _handleWin32Error

; 1875 : 			Error ("FAILED_TO_DISABLE_PAGING_FILES");

  005ee	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@JGNDMOPD@FAILED_TO_DISABLE_PAGING_FILES?$AA@
  005f3	e8 00 00 00 00	 call	 _Error
  005f8	83 c4 08	 add	 esp, 8

; 1876 : 		}
; 1877 : 		else

  005fb	eb 0a		 jmp	 SHORT $LN53@DoInstall
$LN54@DoInstall:

; 1878 : 			bRestartRequired = TRUE;

  005fd	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bRestartRequired, 1
$LN53@DoInstall:

; 1879 : 	}
; 1880 : 
; 1881 : 	UpdateProgressBarProc(50);

  00607	6a 32		 push	 50			; 00000032H
  00609	e8 00 00 00 00	 call	 _UpdateProgressBarProc

; 1882 : 
; 1883 : 	/* Remove driver with deprecated name. */
; 1884 : 	DoServiceUninstall (hwndDlg, "TrueCryptService");

  0060e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FKFJCDPE@TrueCryptService?$AA@
  00613	56		 push	 esi
  00614	e8 00 00 00 00	 call	 _DoServiceUninstall

; 1885 : 
; 1886 : 	UpdateProgressBarProc(55);

  00619	6a 37		 push	 55			; 00000037H
  0061b	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  00620	83 c4 10	 add	 esp, 16			; 00000010H

; 1887 : 
; 1888 : 	/* Remove registry keys before re-install. */
; 1889 : 	if (!SystemEncryptionUpdate)

  00623	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SystemEncryptionUpdate, 0
  0062a	75 14		 jne	 SHORT $LN507@DoInstall

; 1890 : 		DoRegUninstall ((HWND) hwndDlg, TRUE);

  0062c	6a 01		 push	 1
  0062e	56		 push	 esi
  0062f	e8 00 00 00 00	 call	 _DoRegUninstall
  00634	83 c4 08	 add	 esp, 8

; 1891 : 
; 1892 : 	/* Install new dump filter driver. */
; 1893 : 	if (SystemEncryptionUpdate && InstalledVersion < 0x700)

  00637	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SystemEncryptionUpdate, 0
  0063e	74 6c		 je	 SHORT $LN46@DoInstall
$LN507@DoInstall:
  00640	81 3d 00 00 00
	00 00 07 00 00	 cmp	 DWORD PTR ?InstalledVersion@@3JA, 1792 ; InstalledVersion, 00000700H
  0064a	7d 60		 jge	 SHORT $LN46@DoInstall

; 1894 : 	{
; 1895 : 		try
; 1896 : 		{
; 1897 : 			bootEnc.RegisterFilterDriver (false, BootEncryption::DumpFilter);

  0064c	6a 02		 push	 2
  0064e	6a 00		 push	 0
  00650	8d 4d 00	 lea	 ecx, DWORD PTR _bootEnc$[ebp]
  00653	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+12], 12 ; 0000000cH
  00657	e8 00 00 00 00	 call	 ?RegisterFilterDriver@BootEncryption@CipherShed@@QAEX_NW4FilterType@12@@Z ; CipherShed::BootEncryption::RegisterFilterDriver
  0065c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN115@DoInstall:

; 1900 : 
; 1901 : 		try
; 1902 : 		{
; 1903 : 			bootEnc.RegisterFilterDriver (true, BootEncryption::DumpFilter);

  00663	6a 02		 push	 2
  00665	6a 01		 push	 1
  00667	8d 4d 00	 lea	 ecx, DWORD PTR _bootEnc$[ebp]
  0066a	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+12], 14 ; 0000000eH
  0066e	e8 00 00 00 00	 call	 ?RegisterFilterDriver@BootEncryption@CipherShed@@QAEX_NW4FilterType@12@@Z ; CipherShed::BootEncryption::RegisterFilterDriver
  00673	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1916 : 			goto outcome;
; 1917 : 		}
; 1918 : 
; 1919 : 		if (ReadDriverConfigurationFlags() & TC_DRIVER_CONFIG_CACHE_BOOT_PASSWORD_FOR_SYS_FAVORITES)

  0067a	e8 00 00 00 00	 call	 _ReadDriverConfigurationFlags
  0067f	a8 02		 test	 al, 2
  00681	74 29		 je	 SHORT $LN46@DoInstall

; 1920 : 		{
; 1921 : 			WriteLocalMachineRegistryString ("SYSTEM\\CurrentControlSet\\Control\\SafeBoot\\Minimal\\" TC_SYSTEM_FAVORITES_SERVICE_NAME, NULL, "Service", FALSE);

  00683	6a 00		 push	 0
  00685	68 00 00 00 00	 push	 OFFSET ??_C@_07LMLHFMEG@Service?$AA@
  0068a	6a 00		 push	 0
  0068c	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@LBBGNDAK@SYSTEM?2CurrentControlSet?2Control@
  00691	e8 00 00 00 00	 call	 _WriteLocalMachineRegistryString

; 1922 : 			WriteLocalMachineRegistryString ("SYSTEM\\CurrentControlSet\\Control\\SafeBoot\\Network\\" TC_SYSTEM_FAVORITES_SERVICE_NAME, NULL, "Service", FALSE);

  00696	6a 00		 push	 0
  00698	68 00 00 00 00	 push	 OFFSET ??_C@_07LMLHFMEG@Service?$AA@
  0069d	6a 00		 push	 0
  0069f	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@DAJCBMFB@SYSTEM?2CurrentControlSet?2Control@
  006a4	e8 00 00 00 00	 call	 _WriteLocalMachineRegistryString
  006a9	83 c4 20	 add	 esp, 32			; 00000020H
$LN46@DoInstall:

; 1923 : 		}
; 1924 : 	}
; 1925 : 
; 1926 : 	UpdateProgressBarProc(61);

  006ac	6a 3d		 push	 61			; 0000003dH
  006ae	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  006b3	83 c4 04	 add	 esp, 4

; 1927 : 
; 1928 : 	/* Migrate config file. */
; 1929 : 	if (bUpgrade && InstalledVersion < 0x700)

  006b6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bUpgrade, 0
  006bd	0f 84 c2 01 00
	00		 je	 $LN35@DoInstall
  006c3	81 3d 00 00 00
	00 00 07 00 00	 cmp	 DWORD PTR ?InstalledVersion@@3JA, 1792 ; InstalledVersion, 00000700H
  006cd	0f 8d b2 01 00
	00		 jge	 $LN35@DoInstall

; 1930 : 	{
; 1931 : 		bool bMountFavoritesOnLogon = ConfigReadInt ("MountFavoritesOnLogon", FALSE) != 0;

  006d3	6a 00		 push	 0
  006d5	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@IDCDKCEI@MountFavoritesOnLogon?$AA@
  006da	e8 00 00 00 00	 call	 _ConfigReadInt
  006df	85 c0		 test	 eax, eax

; 1932 : 		bool bOpenExplorerWindowAfterMount = ConfigReadInt ("OpenExplorerWindowAfterMount", FALSE) != 0;

  006e1	6a 00		 push	 0
  006e3	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JJNCGBDA@OpenExplorerWindowAfterMount?$AA@
  006e8	0f 95 c3	 setne	 bl
  006eb	e8 00 00 00 00	 call	 _ConfigReadInt
  006f0	83 c4 10	 add	 esp, 16			; 00000010H
  006f3	85 c0		 test	 eax, eax
  006f5	0f 95 c0	 setne	 al
  006f8	88 45 ef	 mov	 BYTE PTR _bOpenExplorerWindowAfterMount$134888[ebp], al

; 1933 : 
; 1934 : 		if (bMountFavoritesOnLogon || bOpenExplorerWindowAfterMount)

  006fb	84 db		 test	 bl, bl
  006fd	75 08		 jne	 SHORT $LN43@DoInstall
  006ff	84 c0		 test	 al, al
  00701	0f 84 7e 01 00
	00		 je	 $LN35@DoInstall
$LN43@DoInstall:

; 1935 : 		{
; 1936 : 			char *favoritesFilename = GetConfigPath (TC_APPD_FILENAME_FAVORITE_VOLUMES);

  00707	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@EGBOIEGJ@Favorite?5Volumes?4xml?$AA@
  0070c	e8 00 00 00 00	 call	 _GetConfigPath

; 1937 : 			DWORD size;
; 1938 : 			char *favoritesXml = LoadFile (favoritesFilename, &size);

  00711	8d 4d e8	 lea	 ecx, DWORD PTR _size$134893[ebp]
  00714	51		 push	 ecx
  00715	50		 push	 eax
  00716	89 45 dc	 mov	 DWORD PTR _favoritesFilename$134892[ebp], eax
  00719	e8 00 00 00 00	 call	 _LoadFile
  0071e	8b f8		 mov	 edi, eax
  00720	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1939 : 
; 1940 : 			if (favoritesXml && size != 0)

  00723	85 ff		 test	 edi, edi
  00725	0f 84 5a 01 00
	00		 je	 $LN35@DoInstall
  0072b	8b 45 e8	 mov	 eax, DWORD PTR _size$134893[ebp]
  0072e	85 c0		 test	 eax, eax
  00730	0f 84 46 01 00
	00		 je	 $LN42@DoInstall

; 1941 : 			{
; 1942 : 				string favorites;

  00736	c7 85 4c 06 00
	00 0f 00 00 00	 mov	 DWORD PTR _favorites$134896[ebp+24], 15 ; 0000000fH
  00740	c7 85 48 06 00
	00 00 00 00 00	 mov	 DWORD PTR _favorites$134896[ebp+20], 0
  0074a	c6 85 38 06 00
	00 00		 mov	 BYTE PTR _favorites$134896[ebp+4], 0

; 1943 : 				favorites.insert (0, favoritesXml, size);

  00751	50		 push	 eax
  00752	57		 push	 edi
  00753	6a 00		 push	 0
  00755	8d 8d 34 06 00
	00		 lea	 ecx, DWORD PTR _favorites$134896[ebp]
  0075b	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+12], 18 ; 00000012H
  0075f	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1944 : 
; 1945 : 				size_t p = favorites.find ("<volume ");

  00764	6a 00		 push	 0
  00766	68 00 00 00 00	 push	 OFFSET ??_C@_08JKOCNOKF@?$DMvolume?5?$AA@
  0076b	8d 8d 34 06 00
	00		 lea	 ecx, DWORD PTR _favorites$134896[ebp]
  00771	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00776	8b f0		 mov	 esi, eax

; 1946 : 				while (p != string::npos)

  00778	83 fe ff	 cmp	 esi, -1
  0077b	74 4e		 je	 SHORT $LN40@DoInstall
  0077d	8d 49 00	 npad	 3
$LL41@DoInstall:

; 1947 : 				{
; 1948 : 					if (bMountFavoritesOnLogon)

  00780	84 db		 test	 bl, bl
  00782	74 14		 je	 SHORT $LN39@DoInstall

; 1949 : 						favorites.insert (p + 8, "mountOnLogOn=\"1\" ");

  00784	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@JBHLDJCD@mountOnLogOn?$DN?$CC1?$CC?5?$AA@
  00789	8d 56 08	 lea	 edx, DWORD PTR [esi+8]
  0078c	52		 push	 edx
  0078d	8d 8d 34 06 00
	00		 lea	 ecx, DWORD PTR _favorites$134896[ebp]
  00793	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
$LN39@DoInstall:

; 1950 : 
; 1951 : 					if (bOpenExplorerWindowAfterMount)

  00798	80 7d ef 00	 cmp	 BYTE PTR _bOpenExplorerWindowAfterMount$134888[ebp], 0
  0079c	74 14		 je	 SHORT $LN38@DoInstall

; 1952 : 						favorites.insert (p + 8, "openExplorerWindow=\"1\" ");

  0079e	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@DLANKHNO@openExplorerWindow?$DN?$CC1?$CC?5?$AA@
  007a3	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  007a6	50		 push	 eax
  007a7	8d 8d 34 06 00
	00		 lea	 ecx, DWORD PTR _favorites$134896[ebp]
  007ad	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
$LN38@DoInstall:

; 1953 : 
; 1954 : 					p = favorites.find ("<volume ", p + 1);

  007b2	46		 inc	 esi
  007b3	56		 push	 esi
  007b4	68 00 00 00 00	 push	 OFFSET ??_C@_08JKOCNOKF@?$DMvolume?5?$AA@
  007b9	8d 8d 34 06 00
	00		 lea	 ecx, DWORD PTR _favorites$134896[ebp]
  007bf	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  007c4	8b f0		 mov	 esi, eax
  007c6	83 fe ff	 cmp	 esi, -1
  007c9	75 b5		 jne	 SHORT $LL41@DoInstall
$LN40@DoInstall:

; 1955 : 				}
; 1956 : 
; 1957 : 				SaveBufferToFile (favorites.c_str(), favoritesFilename, favorites.size(), FALSE);

  007cb	83 bd 4c 06 00
	00 10		 cmp	 DWORD PTR _favorites$134896[ebp+24], 16 ; 00000010H
  007d2	8b 85 38 06 00
	00		 mov	 eax, DWORD PTR _favorites$134896[ebp+4]
  007d8	73 06		 jae	 SHORT $LN475@DoInstall
  007da	8d 85 38 06 00
	00		 lea	 eax, DWORD PTR _favorites$134896[ebp+4]
$LN475@DoInstall:
  007e0	8b 8d 48 06 00
	00		 mov	 ecx, DWORD PTR _favorites$134896[ebp+20]
  007e6	8b 55 dc	 mov	 edx, DWORD PTR _favoritesFilename$134892[ebp]
  007e9	6a 00		 push	 0
  007eb	51		 push	 ecx
  007ec	52		 push	 edx
  007ed	50		 push	 eax
  007ee	e8 00 00 00 00	 call	 _SaveBufferToFile
  007f3	83 c4 10	 add	 esp, 16			; 00000010H

; 1958 : 
; 1959 : 				if (bMountFavoritesOnLogon)

  007f6	84 db		 test	 bl, bl
  007f8	74 77		 je	 SHORT $LN36@DoInstall

; 1960 : 				{
; 1961 : 					char regk[64];
; 1962 : 					char regVal[MAX_PATH * 2];
; 1963 : 
; 1964 : 					GetStartupRegKeyName (regk);

  007fa	8d 85 5c 09 00
	00		 lea	 eax, DWORD PTR _regk$134997[ebp]
  00800	50		 push	 eax
  00801	e8 00 00 00 00	 call	 _GetStartupRegKeyName

; 1965 : 
; 1966 : 					ReadRegistryString (regk, "TrueCrypt", "", regVal, sizeof (regVal));

  00806	68 08 02 00 00	 push	 520			; 00000208H
  0080b	8d 8d 54 07 00
	00		 lea	 ecx, DWORD PTR _regVal$134998[ebp]
  00811	51		 push	 ecx
  00812	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00817	8d 95 5c 09 00
	00		 lea	 edx, DWORD PTR _regk$134997[ebp]
  0081d	68 00 00 00 00	 push	 OFFSET ??_C@_09EMKKFGIH@TrueCrypt?$AA@
  00822	52		 push	 edx
  00823	e8 00 00 00 00	 call	 _ReadRegistryString

; 1967 : 
; 1968 : 					if (strstr (regVal, "favorites"))

  00828	8d 85 54 07 00
	00		 lea	 eax, DWORD PTR _regVal$134998[ebp]
  0082e	68 00 00 00 00	 push	 OFFSET ??_C@_09OAMOHPIB@favorites?$AA@
  00833	50		 push	 eax
  00834	e8 00 00 00 00	 call	 _strstr
  00839	83 c4 20	 add	 esp, 32			; 00000020H
  0083c	85 c0		 test	 eax, eax
  0083e	74 31		 je	 SHORT $LN36@DoInstall

; 1969 : 					{
; 1970 : 						strcat_s (regVal, sizeof (regVal), " /a logon");

  00840	68 00 00 00 00	 push	 OFFSET ??_C@_09KHMMGKKB@?5?1a?5logon?$AA@
  00845	8d 8d 54 07 00
	00		 lea	 ecx, DWORD PTR _regVal$134998[ebp]
  0084b	68 08 02 00 00	 push	 520			; 00000208H
  00850	51		 push	 ecx
  00851	e8 00 00 00 00	 call	 _strcat_s

; 1971 : 						WriteRegistryString (regk, "TrueCrypt", regVal);

  00856	8d 95 54 07 00
	00		 lea	 edx, DWORD PTR _regVal$134998[ebp]
  0085c	52		 push	 edx
  0085d	8d 85 5c 09 00
	00		 lea	 eax, DWORD PTR _regk$134997[ebp]
  00863	68 00 00 00 00	 push	 OFFSET ??_C@_09EMKKFGIH@TrueCrypt?$AA@
  00868	50		 push	 eax
  00869	e8 00 00 00 00	 call	 _WriteRegistryString
  0086e	83 c4 18	 add	 esp, 24			; 00000018H
$LN36@DoInstall:

; 1972 : 					}
; 1973 : 				}
; 1974 : 			}

  00871	8d 8d 34 06 00
	00		 lea	 ecx, DWORD PTR _favorites$134896[ebp]
  00877	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN42@DoInstall:

; 1975 : 
; 1976 : 			if (favoritesXml)
; 1977 : 				free (favoritesXml);

  0087c	57		 push	 edi
  0087d	e8 00 00 00 00	 call	 _free
  00882	83 c4 04	 add	 esp, 4
$LN35@DoInstall:

; 1978 : 		}
; 1979 : 	}
; 1980 : 
; 1981 : 	/* Remove deprecated setup file (TrueCrypt 1.0 - 4.2a) */
; 1982 : 	GetWindowsDirectory (path, sizeof (path));

  00885	68 04 01 00 00	 push	 260			; 00000104H
  0088a	8d 8d 50 06 00
	00		 lea	 ecx, DWORD PTR _path$[ebp]
  00890	51		 push	 ecx
  00891	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowsDirectoryA@8

; 1983 : 	strcat_s (path, sizeof (path), "\\TrueCrypt Setup.exe");

  00897	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@BECKOJBF@?2TrueCrypt?5Setup?4exe?$AA@
  0089c	8d 95 50 06 00
	00		 lea	 edx, DWORD PTR _path$[ebp]
  008a2	68 04 01 00 00	 push	 260			; 00000104H
  008a7	52		 push	 edx
  008a8	e8 00 00 00 00	 call	 _strcat_s
  008ad	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1984 : 	DeleteFile (path);

  008b0	8d 85 50 06 00
	00		 lea	 eax, DWORD PTR _path$[ebp]
  008b6	50		 push	 eax
  008b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteFileA@4

; 1985 : 
; 1986 : 	/* Uninstall the old kernel driver, if it was unloaded before (NOT in case of full system encryption). */
; 1987 : 	if (UpdateProgressBarProc(63) && UnloadDriver && DoServiceUninstall (hwndDlg, "truecrypt") == FALSE)

  008bd	6a 3f		 push	 63			; 0000003fH
  008bf	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  008c4	83 c4 04	 add	 esp, 4
  008c7	85 c0		 test	 eax, eax
  008c9	74 74		 je	 SHORT $LN520@DoInstall
  008cb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?UnloadDriver@@3HA, 0 ; UnloadDriver
  008d2	74 6b		 je	 SHORT $LN520@DoInstall
  008d4	8b 75 e0	 mov	 esi, DWORD PTR _arg$GSCopy$[ebp]
  008d7	68 00 00 00 00	 push	 OFFSET ??_C@_09EFLFAGB@truecrypt?$AA@
  008dc	56		 push	 esi
  008dd	e8 00 00 00 00	 call	 _DoServiceUninstall
  008e2	83 c4 08	 add	 esp, 8
  008e5	85 c0		 test	 eax, eax
  008e7	75 59		 jne	 SHORT $LN34@DoInstall

; 1988 : 	{
; 1989 : 		bOK = FALSE;

  008e9	89 45 e4	 mov	 DWORD PTR _bOK$[ebp], eax
  008ec	e9 49 01 00 00	 jmp	 $LN22@DoInstall
__catch$_DoInstall$0:

; 1898 : 		}
; 1899 : 		catch (...) { }

  008f1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  008f8	b8 00 00 00 00	 mov	 eax, $LN115@DoInstall
  008fd	c3		 ret	 0
__catch$_DoInstall$2:

; 1904 : 		}
; 1905 : 		catch (Exception &e)

  008fe	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 1906 : 		{
; 1907 : 			try
; 1908 : 			{
; 1909 : 				bootEnc.RegisterFilterDriver (false, BootEncryption::DumpFilter);

  00901	6a 02		 push	 2
  00903	6a 00		 push	 0
  00905	8d 4d 00	 lea	 ecx, DWORD PTR _bootEnc$[ebp]
  00908	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+12], 16 ; 00000010H
  0090c	e8 00 00 00 00	 call	 ?RegisterFilterDriver@BootEncryption@CipherShed@@QAEX_NW4FilterType@12@@Z ; CipherShed::BootEncryption::RegisterFilterDriver
  00911	c7 45 fc 0f 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 15 ; 0000000fH
$LN117@DoInstall:

; 1910 : 			}
; 1911 : 			catch (...) { }
; 1912 : 
; 1913 : 			e.Show (hwndDlg);

  00918	8b 4d d8	 mov	 ecx, DWORD PTR _e$134877[ebp]
  0091b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0091d	8b 45 e0	 mov	 eax, DWORD PTR _arg$GSCopy$[ebp]
  00920	8b 12		 mov	 edx, DWORD PTR [edx]
  00922	50		 push	 eax
  00923	ff d2		 call	 edx

; 1914 : 
; 1915 : 			bOK = FALSE;

  00925	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bOK$[ebp], 0

; 2078 : 		}
; 2079 : 	}
; 2080 : 
; 2081 : outcome:

  0092c	b8 00 00 00 00	 mov	 eax, $LN119@DoInstall
  00931	c3		 ret	 0
__catch$_DoInstall$3:
  00932	c7 45 fc 0f 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 15 ; 0000000fH
  00939	b8 00 00 00 00	 mov	 eax, $LN117@DoInstall
  0093e	c3		 ret	 0
$LN520@DoInstall:

; 1988 : 	{
; 1989 : 		bOK = FALSE;

  0093f	8b 75 e0	 mov	 esi, DWORD PTR _arg$GSCopy$[ebp]
$LN34@DoInstall:

; 1990 : 	}
; 1991 : 	/* Install new files. */
; 1992 : 	else if (UpdateProgressBarProc(72) && DoFilesInstall ((HWND) hwndDlg, InstallationPath) == FALSE)

  00942	6a 48		 push	 72			; 00000048H
  00944	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  00949	83 c4 04	 add	 esp, 4
  0094c	85 c0		 test	 eax, eax
  0094e	74 1a		 je	 SHORT $LN32@DoInstall
  00950	68 00 00 00 00	 push	 OFFSET _InstallationPath
  00955	56		 push	 esi
  00956	e8 00 00 00 00	 call	 _DoFilesInstall
  0095b	83 c4 08	 add	 esp, 8
  0095e	85 c0		 test	 eax, eax
  00960	75 08		 jne	 SHORT $LN32@DoInstall

; 1993 : 	{
; 1994 : 		bOK = FALSE;

  00962	89 45 e4	 mov	 DWORD PTR _bOK$[ebp], eax
  00965	e9 d0 00 00 00	 jmp	 $LN22@DoInstall
$LN32@DoInstall:

; 1995 : 	}
; 1996 : 	/* Install registry keys. */
; 1997 : 	else if (UpdateProgressBarProc(80) && DoRegInstall ((HWND) hwndDlg, InstallationPath, bRegisterFileExt) == FALSE)

  0096a	6a 50		 push	 80			; 00000050H
  0096c	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  00971	83 c4 04	 add	 esp, 4
  00974	85 c0		 test	 eax, eax
  00976	74 21		 je	 SHORT $LN30@DoInstall
  00978	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _bRegisterFileExt
  0097e	51		 push	 ecx
  0097f	68 00 00 00 00	 push	 OFFSET _InstallationPath
  00984	56		 push	 esi
  00985	e8 00 00 00 00	 call	 _DoRegInstall
  0098a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0098d	85 c0		 test	 eax, eax
  0098f	75 08		 jne	 SHORT $LN30@DoInstall

; 1998 : 	{
; 1999 : 		bOK = FALSE;

  00991	89 45 e4	 mov	 DWORD PTR _bOK$[ebp], eax
  00994	e9 a1 00 00 00	 jmp	 $LN22@DoInstall
$LN30@DoInstall:

; 2000 : 	}
; 2001 : 	/* Install the new kernel driver, if it was unloaded before (NOT in case of full system encryption). */
; 2002 : 	else if (UpdateProgressBarProc(85) && UnloadDriver && DoDriverInstall (hwndDlg) == FALSE)

  00999	6a 55		 push	 85			; 00000055H
  0099b	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  009a0	83 c4 04	 add	 esp, 4
  009a3	85 c0		 test	 eax, eax
  009a5	74 1b		 je	 SHORT $LN28@DoInstall
  009a7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?UnloadDriver@@3HA, 0 ; UnloadDriver
  009ae	74 12		 je	 SHORT $LN28@DoInstall
  009b0	56		 push	 esi
  009b1	e8 00 00 00 00	 call	 _DoDriverInstall
  009b6	83 c4 04	 add	 esp, 4
  009b9	85 c0		 test	 eax, eax
  009bb	75 05		 jne	 SHORT $LN28@DoInstall

; 2003 : 	{
; 2004 : 		bOK = FALSE;

  009bd	89 45 e4	 mov	 DWORD PTR _bOK$[ebp], eax
  009c0	eb 78		 jmp	 SHORT $LN22@DoInstall
$LN28@DoInstall:

; 2005 : 	}
; 2006 : 	/* Upgrade the bootloader in case of full system encryption. */
; 2007 : 	else if (UpdateProgressBarProc(90) && SystemEncryptionUpdate && UpgradeBootLoader (hwndDlg) == FALSE)

  009c2	6a 5a		 push	 90			; 0000005aH
  009c4	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  009c9	83 c4 04	 add	 esp, 4
  009cc	85 c0		 test	 eax, eax
  009ce	74 1b		 je	 SHORT $LN26@DoInstall
  009d0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SystemEncryptionUpdate, 0
  009d7	74 12		 je	 SHORT $LN26@DoInstall
  009d9	56		 push	 esi
  009da	e8 00 00 00 00	 call	 _UpgradeBootLoader
  009df	83 c4 04	 add	 esp, 4
  009e2	85 c0		 test	 eax, eax
  009e4	75 05		 jne	 SHORT $LN26@DoInstall

; 2008 : 	{
; 2009 : 		bOK = FALSE;

  009e6	89 45 e4	 mov	 DWORD PTR _bOK$[ebp], eax
  009e9	eb 4f		 jmp	 SHORT $LN22@DoInstall
$LN26@DoInstall:

; 2010 : 	}
; 2011 : 	/* Install desktop / startmenu shortcuts. */
; 2012 : 	else if (UpdateProgressBarProc(93) && DoShortcutsInstall (hwndDlg, InstallationPath, bAddToStartMenu, bDesktopIcon) == FALSE)

  009eb	6a 5d		 push	 93			; 0000005dH
  009ed	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  009f2	83 c4 04	 add	 esp, 4
  009f5	85 c0		 test	 eax, eax
  009f7	74 24		 je	 SHORT $LN24@DoInstall
  009f9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _bDesktopIcon
  009ff	a1 00 00 00 00	 mov	 eax, DWORD PTR _bAddToStartMenu
  00a04	52		 push	 edx
  00a05	50		 push	 eax
  00a06	68 00 00 00 00	 push	 OFFSET _InstallationPath
  00a0b	56		 push	 esi
  00a0c	e8 00 00 00 00	 call	 _DoShortcutsInstall
  00a11	83 c4 10	 add	 esp, 16			; 00000010H
  00a14	85 c0		 test	 eax, eax
  00a16	75 05		 jne	 SHORT $LN24@DoInstall

; 2013 : 	{
; 2014 : 		bOK = FALSE;

  00a18	89 45 e4	 mov	 DWORD PTR _bOK$[ebp], eax
  00a1b	eb 1d		 jmp	 SHORT $LN22@DoInstall
$LN24@DoInstall:

; 2015 : 	}
; 2016 : 
; 2017 : 	/* Remove TrueCrypt program files and shortcuts. */
; 2018 : 	else if (bCipherShedMigration)

  00a1d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bCipherShedMigration, 0
  00a24	74 14		 je	 SHORT $LN22@DoInstall

; 2019 : 	{
; 2020 : 		DoTrueCryptShortcutsUninstall (hwndDlg, UninstallationPath);

  00a26	68 00 00 00 00	 push	 OFFSET ?UninstallationPath@@3PADA ; UninstallationPath
  00a2b	56		 push	 esi
  00a2c	e8 00 00 00 00	 call	 _DoTrueCryptShortcutsUninstall

; 2021 : 		DoTrueCryptFilesUninstall (hwndDlg);

  00a31	56		 push	 esi
  00a32	e8 00 00 00 00	 call	 _DoTrueCryptFilesUninstall
  00a37	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN22@DoInstall:

; 2022 : 	}
; 2023 : 
; 2024 : 	/* Driver couldn't be unloaded, we need a system restart (full system encryption). */
; 2025 : 	if (!UnloadDriver)

  00a3a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?UnloadDriver@@3HA, 0 ; UnloadDriver
  00a41	75 0a		 jne	 SHORT $LN21@DoInstall

; 2026 : 		bRestartRequired = TRUE;

  00a43	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bRestartRequired, 1
$LN21@DoInstall:

; 2027 : 
; 2028 : 	try
; 2029 : 	{
; 2030 : 		bootEnc.RenameDeprecatedSystemLoaderBackup();

  00a4d	8d 4d 00	 lea	 ecx, DWORD PTR _bootEnc$[ebp]
  00a50	c6 45 fc 13	 mov	 BYTE PTR __$EHRec$[ebp+12], 19 ; 00000013H
  00a54	e8 00 00 00 00	 call	 ?RenameDeprecatedSystemLoaderBackup@BootEncryption@CipherShed@@QAEXXZ ; CipherShed::BootEncryption::RenameDeprecatedSystemLoaderBackup
  00a59	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN519@DoInstall:

; 2031 : 	}
; 2032 : 	catch (...)	{ }

  00a60	33 db		 xor	 ebx, ebx
  00a62	be 10 00 00 00	 mov	 esi, 16			; 00000010H
  00a67	8d 7e f1	 lea	 edi, DWORD PTR [esi-15]

; 2033 : 
; 2034 : 	/* Move system favorite volumes config. */
; 2035 : 	if (SystemEncryptionUpdate && InstalledVersion == 0x630)

  00a6a	39 1d 00 00 00
	00		 cmp	 DWORD PTR _SystemEncryptionUpdate, ebx
  00a70	0f 84 ca 00 00
	00		 je	 $LN19@DoInstall
  00a76	81 3d 00 00 00
	00 30 06 00 00	 cmp	 DWORD PTR ?InstalledVersion@@3JA, 1584 ; InstalledVersion, 00000630H
  00a80	0f 85 ba 00 00
	00		 jne	 $LN19@DoInstall

; 2036 : 	{
; 2037 : 		string sysFavorites = GetServiceConfigPath (TC_APPD_FILENAME_SYSTEM_FAVORITE_VOLUMES);

  00a86	8d 8d 18 06 00
	00		 lea	 ecx, DWORD PTR _sysFavorites$135022[ebp]
  00a8c	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@EGPGHNFL@TrueCrypt?5System?5Favorite?5Volume@
  00a91	51		 push	 ecx
  00a92	e8 00 00 00 00	 call	 ?GetServiceConfigPath@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; GetServiceConfigPath

; 2038 : 		string legacySysFavorites = GetProgramConfigPath ("System Favorite Volumes.xml");

  00a97	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@IAAIJFIC@System?5Favorite?5Volumes?4xml?$AA@
  00a9c	c6 45 fc 15	 mov	 BYTE PTR __$EHRec$[ebp+12], 21 ; 00000015H
  00aa0	e8 00 00 00 00	 call	 _GetProgramConfigPath
  00aa5	83 c4 0c	 add	 esp, 12			; 0000000cH
  00aa8	50		 push	 eax
  00aa9	8d 8d 34 06 00
	00		 lea	 ecx, DWORD PTR _legacySysFavorites$135025[ebp]
  00aaf	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 2039 : 
; 2040 : 		if (FileExists (legacySysFavorites.c_str()) && !FileExists (sysFavorites.c_str()))

  00ab4	8b 85 38 06 00
	00		 mov	 eax, DWORD PTR _legacySysFavorites$135025[ebp+4]
  00aba	39 b5 4c 06 00
	00		 cmp	 DWORD PTR _legacySysFavorites$135025[ebp+24], esi
  00ac0	73 06		 jae	 SHORT $LN483@DoInstall
  00ac2	8d 85 38 06 00
	00		 lea	 eax, DWORD PTR _legacySysFavorites$135025[ebp+4]
$LN483@DoInstall:
  00ac8	50		 push	 eax
  00ac9	e8 00 00 00 00	 call	 _FileExists
  00ace	83 c4 04	 add	 esp, 4
  00ad1	85 c0		 test	 eax, eax
  00ad3	74 51		 je	 SHORT $LN18@DoInstall
  00ad5	8b 85 1c 06 00
	00		 mov	 eax, DWORD PTR _sysFavorites$135022[ebp+4]
  00adb	39 b5 30 06 00
	00		 cmp	 DWORD PTR _sysFavorites$135022[ebp+24], esi
  00ae1	73 06		 jae	 SHORT $LN489@DoInstall
  00ae3	8d 85 1c 06 00
	00		 lea	 eax, DWORD PTR _sysFavorites$135022[ebp+4]
$LN489@DoInstall:
  00ae9	50		 push	 eax
  00aea	e8 00 00 00 00	 call	 _FileExists
  00aef	83 c4 04	 add	 esp, 4
  00af2	85 c0		 test	 eax, eax
  00af4	75 30		 jne	 SHORT $LN18@DoInstall

; 2041 : 			MoveFile (legacySysFavorites.c_str(), sysFavorites.c_str());

  00af6	8b 8d 1c 06 00
	00		 mov	 ecx, DWORD PTR _sysFavorites$135022[ebp+4]
  00afc	39 b5 30 06 00
	00		 cmp	 DWORD PTR _sysFavorites$135022[ebp+24], esi
  00b02	73 06		 jae	 SHORT $LN495@DoInstall
  00b04	8d 8d 1c 06 00
	00		 lea	 ecx, DWORD PTR _sysFavorites$135022[ebp+4]
$LN495@DoInstall:
  00b0a	8b 85 38 06 00
	00		 mov	 eax, DWORD PTR _legacySysFavorites$135025[ebp+4]
  00b10	39 b5 4c 06 00
	00		 cmp	 DWORD PTR _legacySysFavorites$135025[ebp+24], esi
  00b16	73 06		 jae	 SHORT $LN501@DoInstall
  00b18	8d 85 38 06 00
	00		 lea	 eax, DWORD PTR _legacySysFavorites$135025[ebp+4]
$LN501@DoInstall:
  00b1e	51		 push	 ecx
  00b1f	50		 push	 eax
  00b20	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MoveFileA@8
$LN18@DoInstall:

; 2042 : 	}

  00b26	8d 8d 34 06 00
	00		 lea	 ecx, DWORD PTR _legacySysFavorites$135025[ebp]
  00b2c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00b31	8d 8d 18 06 00
	00		 lea	 ecx, DWORD PTR _sysFavorites$135022[ebp]
  00b37	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  00b3b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN19@DoInstall:

; 2043 : 
; 2044 : 	if (bOK)

  00b40	39 5d e4	 cmp	 DWORD PTR _bOK$[ebp], ebx
  00b43	74 0a		 je	 SHORT $LN17@DoInstall

; 2045 : 		UpdateProgressBarProc(97);

  00b45	6a 61		 push	 97			; 00000061H
  00b47	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  00b4c	83 c4 04	 add	 esp, 4
$LN17@DoInstall:

; 2046 : 
; 2047 : 	/* End system restore point. */
; 2048 : 	if (bSystemRestore)

  00b4f	39 1d 00 00 00
	00		 cmp	 DWORD PTR _bSystemRestore, ebx
  00b55	74 0c		 je	 SHORT $LN16@DoInstall

; 2049 : 		SetSystemRestorePoint (hwndDlg, TRUE);

  00b57	8b 75 e0	 mov	 esi, DWORD PTR _arg$GSCopy$[ebp]
  00b5a	57		 push	 edi
  00b5b	e8 00 00 00 00	 call	 ?SetSystemRestorePoint@@YAXPAUHWND__@@H@Z ; SetSystemRestorePoint
  00b60	83 c4 04	 add	 esp, 4
$LN16@DoInstall:

; 2050 : 
; 2051 : 	if (bOK)

  00b63	39 5d e4	 cmp	 DWORD PTR _bOK$[ebp], ebx
  00b66	74 2e		 je	 SHORT $LN15@DoInstall

; 2052 : 	{
; 2053 : 		UpdateProgressBarProc(100);

  00b68	6a 64		 push	 100			; 00000064H
  00b6a	e8 00 00 00 00	 call	 _UpdateProgressBarProc

; 2054 : 		UninstallBatch[0] = 0;
; 2055 : 		StatusMessage (hwndDlg, "INSTALL_COMPLETED");

  00b6f	8b 55 e0	 mov	 edx, DWORD PTR _arg$GSCopy$[ebp]
  00b72	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KNJLNLNB@INSTALL_COMPLETED?$AA@
  00b77	52		 push	 edx
  00b78	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?UninstallBatch@@3PADA, 0
  00b7f	e8 00 00 00 00	 call	 _StatusMessage
  00b84	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2056 : 	}
; 2057 : 	else

  00b87	eb 68		 jmp	 SHORT $LN119@DoInstall
__catch$_DoInstall$7:

; 2031 : 	}
; 2032 : 	catch (...)	{ }

  00b89	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00b90	b8 00 00 00 00	 mov	 eax, $LN519@DoInstall
  00b95	c3		 ret	 0
$LN15@DoInstall:

; 2058 : 	{
; 2059 : 		UpdateProgressBarProc(0);

  00b96	53		 push	 ebx
  00b97	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  00b9c	83 c4 04	 add	 esp, 4

; 2060 : 
; 2061 : 		if (!SystemEncryptionUpdate)

  00b9f	39 1d 00 00 00
	00		 cmp	 DWORD PTR _SystemEncryptionUpdate, ebx
  00ba5	75 3d		 jne	 SHORT $LN13@DoInstall

; 2062 : 		{
; 2063 : 			bUninstall = TRUE;
; 2064 : 			Rollback = TRUE;
; 2065 : 			Silent = TRUE;
; 2066 : 
; 2067 : 			DoUninstall (hwndDlg);

  00ba7	8b 75 e0	 mov	 esi, DWORD PTR _arg$GSCopy$[ebp]
  00baa	56		 push	 esi
  00bab	89 3d 00 00 00
	00		 mov	 DWORD PTR ?bUninstall@@3HA, edi ; bUninstall
  00bb1	89 3d 00 00 00
	00		 mov	 DWORD PTR _Rollback, edi
  00bb7	89 3d 00 00 00
	00		 mov	 DWORD PTR _Silent, edi
  00bbd	e8 00 00 00 00	 call	 _DoUninstall

; 2068 : 
; 2069 : 			bUninstall = FALSE;
; 2070 : 			Rollback = FALSE;
; 2071 : 			Silent = FALSE;
; 2072 : 
; 2073 : 			StatusMessage (hwndDlg, "ROLLBACK");

  00bc2	68 00 00 00 00	 push	 OFFSET ??_C@_08COBEBGNM@ROLLBACK?$AA@
  00bc7	56		 push	 esi
  00bc8	89 1d 00 00 00
	00		 mov	 DWORD PTR ?bUninstall@@3HA, ebx ; bUninstall
  00bce	89 1d 00 00 00
	00		 mov	 DWORD PTR _Rollback, ebx
  00bd4	89 1d 00 00 00
	00		 mov	 DWORD PTR _Silent, ebx
  00bda	e8 00 00 00 00	 call	 _StatusMessage
  00bdf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2074 : 		}
; 2075 : 		else

  00be2	eb 0d		 jmp	 SHORT $LN119@DoInstall
$LN13@DoInstall:

; 2076 : 		{
; 2077 : 			Warning ("SYS_ENC_UPGRADE_FAILED");

  00be4	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@FAKCOHIL@SYS_ENC_UPGRADE_FAILED?$AA@
  00be9	e8 00 00 00 00	 call	 _Warning
  00bee	83 c4 04	 add	 esp, 4
$LN119@DoInstall:
  00bf1	8b 75 e4	 mov	 esi, DWORD PTR _bOK$[ebp]

; 2082 : 	OutcomePrompt (hwndDlg, bOK);

  00bf4	8b 45 e0	 mov	 eax, DWORD PTR _arg$GSCopy$[ebp]
  00bf7	56		 push	 esi
  00bf8	50		 push	 eax
$outcome$134879:
  00bf9	e8 00 00 00 00	 call	 _OutcomePrompt
  00bfe	83 c4 08	 add	 esp, 8

; 2083 : 
; 2084 : 	if (bOK && !bUninstall && !bDowngrade && !bRepairMode && !bDevm)

  00c01	85 f6		 test	 esi, esi
  00c03	0f 84 86 00 00
	00		 je	 $LN5@DoInstall
  00c09	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bUninstall@@3HA, 0 ; bUninstall
  00c10	75 7d		 jne	 SHORT $LN5@DoInstall
  00c12	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDowngrade@@3HA, 0 ; bDowngrade
  00c19	75 74		 jne	 SHORT $LN5@DoInstall
  00c1b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bRepairMode, 0
  00c22	75 6b		 jne	 SHORT $LN5@DoInstall
  00c24	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bDevm, 0
  00c2b	75 62		 jne	 SHORT $LN5@DoInstall

; 2085 : 	{
; 2086 : 		if (!IsHiddenOSRunning())	// A hidden OS user should not see the post-install notes twice (on decoy OS and then on hidden OS).

  00c2d	e8 00 00 00 00	 call	 _IsHiddenOSRunning
  00c32	85 c0		 test	 eax, eax
  00c34	75 59		 jne	 SHORT $LN5@DoInstall

; 2087 : 		{
; 2088 : 			if (bRestartRequired || SystemEncryptionUpdate)

  00c36	39 05 00 00 00
	00		 cmp	 DWORD PTR _bRestartRequired, eax
  00c3c	75 31		 jne	 SHORT $LN8@DoInstall
  00c3e	39 05 00 00 00
	00		 cmp	 DWORD PTR _SystemEncryptionUpdate, eax
  00c44	75 29		 jne	 SHORT $LN8@DoInstall

; 2099 : 				}
; 2100 : 			}
; 2101 : 			else
; 2102 : 			{
; 2103 : 				// No restart will be required
; 2104 : 
; 2105 : 				if (bUpgrade)

  00c46	39 05 00 00 00
	00		 cmp	 DWORD PTR _bUpgrade, eax
  00c4c	74 0c		 je	 SHORT $LN3@DoInstall

; 2106 : 				{
; 2107 : 					bPromptReleaseNotes = TRUE;

  00c4e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bPromptReleaseNotes, 1
  00c58	eb 35		 jmp	 SHORT $LN5@DoInstall
$LN3@DoInstall:

; 2108 : 				}
; 2109 : 				else if (bPossiblyFirstTimeInstall)

  00c5a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bPossiblyFirstTimeInstall, 0
  00c61	74 2c		 je	 SHORT $LN5@DoInstall

; 2110 : 				{
; 2111 : 					bPromptTutorial = TRUE;

  00c63	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bPromptTutorial, 1
  00c6d	eb 20		 jmp	 SHORT $LN5@DoInstall
$LN8@DoInstall:

; 2089 : 			{
; 2090 : 				// Restart required
; 2091 : 
; 2092 : 				if (bUpgrade)

  00c6f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bUpgrade, 0
  00c76	74 04		 je	 SHORT $LN7@DoInstall

; 2093 : 				{
; 2094 : 					SavePostInstallTasksSettings (TC_POST_INSTALL_CFG_RELEASE_NOTES);

  00c78	6a 02		 push	 2
  00c7a	eb 0b		 jmp	 SHORT $LN539@DoInstall
$LN7@DoInstall:

; 2095 : 				}
; 2096 : 				else if (bPossiblyFirstTimeInstall)

  00c7c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bPossiblyFirstTimeInstall, 0
  00c83	74 0a		 je	 SHORT $LN5@DoInstall

; 2097 : 				{
; 2098 : 					SavePostInstallTasksSettings (TC_POST_INSTALL_CFG_TUTORIAL);

  00c85	6a 01		 push	 1
$LN539@DoInstall:
  00c87	e8 00 00 00 00	 call	 _SavePostInstallTasksSettings
  00c8c	83 c4 04	 add	 esp, 4
$LN5@DoInstall:

; 2112 : 				}
; 2113 : 			}
; 2114 : 		}
; 2115 : 	}
; 2116 : 
; 2117 : 	PostMessage (MainDlg, bOK ? TC_APPMSG_INSTALL_SUCCESS : TC_APPMSG_INSTALL_FAILURE, 0, 0);

  00c8f	f7 de		 neg	 esi
  00c91	1b f6		 sbb	 esi, esi
  00c93	6a 00		 push	 0
  00c95	83 e6 fd	 and	 esi, -3			; fffffffdH
  00c98	6a 00		 push	 0
  00c9a	81 c6 94 81 00
	00		 add	 esi, 33172		; 00008194H
  00ca0	56		 push	 esi
$LN537@DoInstall:
  00ca1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _MainDlg
  00ca7	51		 push	 ecx
$LN538@DoInstall:
  00ca8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16

; 2118 : }

  00cae	8d 4d 00	 lea	 ecx, DWORD PTR _bootEnc$[ebp]
  00cb1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00cb8	e8 00 00 00 00	 call	 ??1BootEncryption@CipherShed@@QAE@XZ ; CipherShed::BootEncryption::~BootEncryption
  00cbd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00cc0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00cc7	59		 pop	 ecx
  00cc8	5f		 pop	 edi
  00cc9	5e		 pop	 esi
  00cca	5b		 pop	 ebx
  00ccb	8b 8d 9c 09 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00cd1	33 cd		 xor	 ecx, ebp
  00cd3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00cd8	81 c5 a0 09 00
	00		 add	 ebp, 2464		; 000009a0H
  00cde	8b e5		 mov	 esp, ebp
  00ce0	5d		 pop	 ebp
  00ce1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_DoInstall$9:
  00000	8d 4d 00	 lea	 ecx, DWORD PTR _bootEnc$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1BootEncryption@CipherShed@@QAE@XZ ; CipherShed::BootEncryption::~BootEncryption
__unwindfunclet$_DoInstall$10:
  00008	8b 45 e8	 mov	 eax, DWORD PTR $T142346[ebp]
  0000b	83 e0 01	 and	 eax, 1
  0000e	0f 84 0f 00 00
	00		 je	 $LN76@DoInstall
  00014	83 65 e8 fe	 and	 DWORD PTR $T142346[ebp], -2 ; fffffffeH
  00018	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR $T142322[ebp]
  0001e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN76@DoInstall:
  00023	c3		 ret	 0
__unwindfunclet$_DoInstall$11:
  00024	8b 45 e8	 mov	 eax, DWORD PTR $T142346[ebp]
  00027	83 e0 02	 and	 eax, 2
  0002a	0f 84 0c 00 00
	00		 je	 $LN78@DoInstall
  00030	83 65 e8 fd	 and	 DWORD PTR $T142346[ebp], -3 ; fffffffdH
  00034	8d 4d a0	 lea	 ecx, DWORD PTR $T142323[ebp]
  00037	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN78@DoInstall:
  0003c	c3		 ret	 0
__unwindfunclet$_DoInstall$12:
  0003d	8b 45 e8	 mov	 eax, DWORD PTR $T142346[ebp]
  00040	83 e0 04	 and	 eax, 4
  00043	0f 84 0f 00 00
	00		 je	 $LN80@DoInstall
  00049	83 65 e8 fb	 and	 DWORD PTR $T142346[ebp], -5 ; fffffffbH
  0004d	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR $T142324[ebp]
  00053	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN80@DoInstall:
  00058	c3		 ret	 0
__unwindfunclet$_DoInstall$13:
  00059	8b 45 e8	 mov	 eax, DWORD PTR $T142346[ebp]
  0005c	83 e0 08	 and	 eax, 8
  0005f	0f 84 0f 00 00
	00		 je	 $LN82@DoInstall
  00065	83 65 e8 f7	 and	 DWORD PTR $T142346[ebp], -9 ; fffffff7H
  00069	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR $T142325[ebp]
  0006f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN82@DoInstall:
  00074	c3		 ret	 0
__unwindfunclet$_DoInstall$14:
  00075	8b 45 e8	 mov	 eax, DWORD PTR $T142346[ebp]
  00078	83 e0 10	 and	 eax, 16			; 00000010H
  0007b	0f 84 0c 00 00
	00		 je	 $LN84@DoInstall
  00081	83 65 e8 ef	 and	 DWORD PTR $T142346[ebp], -17 ; ffffffefH
  00085	8d 4d 84	 lea	 ecx, DWORD PTR $T142327[ebp]
  00088	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN84@DoInstall:
  0008d	c3		 ret	 0
__unwindfunclet$_DoInstall$15:
  0008e	8b 45 e8	 mov	 eax, DWORD PTR $T142346[ebp]
  00091	83 e0 20	 and	 eax, 32			; 00000020H
  00094	0f 84 0f 00 00
	00		 je	 $LN86@DoInstall
  0009a	83 65 e8 df	 and	 DWORD PTR $T142346[ebp], -33 ; ffffffdfH
  0009e	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR $T142328[ebp]
  000a4	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN86@DoInstall:
  000a9	c3		 ret	 0
__unwindfunclet$_DoInstall$16:
  000aa	8b 45 e8	 mov	 eax, DWORD PTR $T142346[ebp]
  000ad	83 e0 40	 and	 eax, 64			; 00000040H
  000b0	0f 84 0f 00 00
	00		 je	 $LN88@DoInstall
  000b6	83 65 e8 bf	 and	 DWORD PTR $T142346[ebp], -65 ; ffffffbfH
  000ba	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR $T142329[ebp]
  000c0	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN88@DoInstall:
  000c5	c3		 ret	 0
__unwindfunclet$_DoInstall$17:
  000c6	8b 45 e8	 mov	 eax, DWORD PTR $T142346[ebp]
  000c9	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000ce	0f 84 0f 00 00
	00		 je	 $LN90@DoInstall
  000d4	81 65 e8 7f ff
	ff ff		 and	 DWORD PTR $T142346[ebp], -129 ; ffffff7fH
  000db	8d 4d bc	 lea	 ecx, DWORD PTR $T142330[ebp]
  000de	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN90@DoInstall:
  000e3	c3		 ret	 0
__unwindfunclet$_DoInstall$18:
  000e4	8b 45 e8	 mov	 eax, DWORD PTR $T142346[ebp]
  000e7	25 00 01 00 00	 and	 eax, 256		; 00000100H
  000ec	0f 84 12 00 00
	00		 je	 $LN92@DoInstall
  000f2	81 65 e8 ff fe
	ff ff		 and	 DWORD PTR $T142346[ebp], -257 ; fffffeffH
  000f9	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR $T142331[ebp]
  000ff	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN92@DoInstall:
  00104	c3		 ret	 0
__unwindfunclet$_DoInstall$19:
  00105	8b 45 e8	 mov	 eax, DWORD PTR $T142346[ebp]
  00108	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0010d	0f 84 12 00 00
	00		 je	 $LN94@DoInstall
  00113	81 65 e8 ff fd
	ff ff		 and	 DWORD PTR $T142346[ebp], -513 ; fffffdffH
  0011a	8d 8d 14 ff ff
	ff		 lea	 ecx, DWORD PTR $T142332[ebp]
  00120	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN94@DoInstall:
  00125	c3		 ret	 0
__unwindfunclet$_DoInstall$20:
  00126	8b 45 e8	 mov	 eax, DWORD PTR $T142346[ebp]
  00129	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  0012e	0f 84 12 00 00
	00		 je	 $LN96@DoInstall
  00134	81 65 e8 ff fb
	ff ff		 and	 DWORD PTR $T142346[ebp], -1025 ; fffffbffH
  0013b	8d 8d 34 06 00
	00		 lea	 ecx, DWORD PTR $T142333[ebp]
  00141	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN96@DoInstall:
  00146	c3		 ret	 0
__unwindfunclet$_DoInstall$22:
  00147	8d 8d 34 06 00
	00		 lea	 ecx, DWORD PTR _favorites$134896[ebp]
  0014d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_DoInstall$23:
  00152	8d 8d 18 06 00
	00		 lea	 ecx, DWORD PTR _sysFavorites$135022[ebp]
  00158	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$_DoInstall:
  0015d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00161	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00164	8b 8a bc fe ff
	ff		 mov	 ecx, DWORD PTR [edx-324]
  0016a	33 c8		 xor	 ecx, eax
  0016c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00171	8b 8a a8 09 00
	00		 mov	 ecx, DWORD PTR [edx+2472]
  00177	33 c8		 xor	 ecx, eax
  00179	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_DoInstall
  00183	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_DoInstall ENDP
PUBLIC	??_C@_0N@ILKBADPD@?2CipherShed?2?$AA@		; `string'
PUBLIC	??_C@_06NOEMODMP@?5?$CIx86?$CJ?$AA@		; `string'
PUBLIC	??_C@_04PMOCAHAA@open?$AA@			; `string'
PUBLIC	??_C@_0BM@IFDMFKIM@UNINSTALL_OLD_VERSION_FIRST?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_SetInstallationPath
EXTRN	_strncat:PROC
EXTRN	_strcpy_s:PROC
EXTRN	__access:PROC
EXTRN	_IsNonInstallMode:PROC
EXTRN	_strncmp:PROC
EXTRN	_exit:PROC
EXTRN	__imp__ShellExecuteA@24:PROC
EXTRN	__imp__RegQueryValueExA@24:PROC
EXTRN	__imp__RegOpenKeyExA@20:PROC
;	COMDAT ??_C@_0N@ILKBADPD@?2CipherShed?2?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\iosfwd
CONST	SEGMENT
??_C@_0N@ILKBADPD@?2CipherShed?2?$AA@ DB '\CipherShed\', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06NOEMODMP@?5?$CIx86?$CJ?$AA@
CONST	SEGMENT
??_C@_06NOEMODMP@?5?$CIx86?$CJ?$AA@ DB ' (x86)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04PMOCAHAA@open?$AA@
CONST	SEGMENT
??_C@_04PMOCAHAA@open?$AA@ DB 'open', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IFDMFKIM@UNINSTALL_OLD_VERSION_FIRST?$AA@
CONST	SEGMENT
??_C@_0BM@IFDMFKIM@UNINSTALL_OLD_VERSION_FIRST?$AA@ DB 'UNINSTALL_OLD_VER'
	DB	'SION_FIRST', 00H				; `string'
; Function compile flags: /Ogtpy
; File c:\home\public\desktop\projects\ciphershed.build\src\setup\setup.c
CONST	ENDS
;	COMDAT _SetInstallationPath
_TEXT	SEGMENT
_hkey$ = -1652						; size = 4
_size$135060 = -1648					; size = 4
_itemList$ = -1644					; size = 4
$T143979 = -1640					; size = 28
_s$135077 = -1612					; size = 28
_path$ = -1584						; size = 280
_mp$135072 = -1304					; size = 260
_rv$135059 = -1044					; size = 1040
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_SetInstallationPath PROC				; COMDAT

; 2127 : {

  00000	81 ec 74 06 00
	00		 sub	 esp, 1652		; 00000674H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 70 06
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1652], eax
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	8b bc 24 84 06
	00 00		 mov	 edi, DWORD PTR _hwndDlg$[esp+1660]

; 2128 : 	HKEY hkey;
; 2129 : 	BOOL bInstallPathDetermined = FALSE;
; 2130 : 	char path[MAX_PATH+20];
; 2131 : 	ITEMIDLIST *itemList;
; 2132 : 
; 2133 : 	memset (InstallationPath, 0, sizeof (InstallationPath));

  0001e	68 04 01 00 00	 push	 260			; 00000104H
  00023	33 db		 xor	 ebx, ebx
  00025	53		 push	 ebx
  00026	68 00 00 00 00	 push	 OFFSET _InstallationPath
  0002b	33 f6		 xor	 esi, esi
  0002d	e8 00 00 00 00	 call	 _memset
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2134 : 
; 2135 : 	// Determine if CipherShed is already installed and try to determine its "Program Files" location
; 2136 : 	if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\TrueCrypt", 0, KEY_READ, &hkey) == ERROR_SUCCESS)

  00035	8d 44 24 0c	 lea	 eax, DWORD PTR _hkey$[esp+1664]
  00039	50		 push	 eax
  0003a	68 19 00 02 00	 push	 131097			; 00020019H
  0003f	53		 push	 ebx
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@FLBIDANE@Software?2Microsoft?2Windows?2Curre@
  00045	68 02 00 00 80	 push	 -2147483646		; 80000002H
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  00050	85 c0		 test	 eax, eax
  00052	0f 85 58 02 00
	00		 jne	 $LN8@SetInstall

; 2137 : 	{
; 2138 : 		/* Default 'UninstallString' registry strings written by past versions of CipherShed:
; 2139 : 		------------------------------------------------------------------------------------
; 2140 : 		1.0		C:\WINDOWS\TrueCrypt Setup.exe /u			[optional]
; 2141 : 		1.0a	C:\WINDOWS\TrueCrypt Setup.exe /u			[optional]
; 2142 : 		2.0		C:\WINDOWS\TrueCrypt Setup.exe /u			[optional]
; 2143 : 		2.1		C:\WINDOWS\TrueCrypt Setup.exe /u			[optional]
; 2144 : 		2.1a	C:\WINDOWS\TrueCrypt Setup.exe /u			[optional]
; 2145 : 		3.0		C:\WINDOWS\TrueCrypt Setup.exe /u			[optional]
; 2146 : 		3.0a	C:\WINDOWS\TrueCrypt Setup.exe /u			[optional]
; 2147 : 		3.1		The UninstallString was NEVER written (fortunately, 3.1a replaced 3.1 after 2 weeks)
; 2148 : 		3.1a	C:\WINDOWS\TrueCrypt Setup.exe /u
; 2149 : 		4.0		C:\WINDOWS\TrueCrypt Setup.exe /u C:\Program Files\TrueCrypt
; 2150 : 		4.1		C:\WINDOWS\TrueCrypt Setup.exe /u C:\Program Files\TrueCrypt
; 2151 : 		4.2		C:\WINDOWS\TrueCrypt Setup.exe /u C:\Program Files\TrueCrypt
; 2152 : 		4.2a	C:\WINDOWS\TrueCrypt Setup.exe /u C:\Program Files\TrueCrypt
; 2153 : 		4.3		"C:\Program Files\TrueCrypt\TrueCrypt Setup.exe" /u C:\Program Files\TrueCrypt\
; 2154 : 		4.3a	"C:\Program Files\TrueCrypt\TrueCrypt Setup.exe" /u C:\Program Files\TrueCrypt\
; 2155 : 		5.0+	"C:\Program Files\TrueCrypt\TrueCrypt Setup.exe" /u
; 2156 : 
; 2157 : 		Note: In versions 1.0-3.0a the user was able to choose whether to install the uninstaller.
; 2158 : 			  The default was to install it. If it wasn't installed, there was no UninstallString.
; 2159 : 		*/
; 2160 : 
; 2161 : 		char rv[MAX_PATH*4];
; 2162 : 		DWORD size = sizeof (rv);
; 2163 : 		if (RegQueryValueEx (hkey, "UninstallString", 0, 0, (LPBYTE) &rv, &size) == ERROR_SUCCESS && strrchr (rv, '/'))

  00058	8b 44 24 0c	 mov	 eax, DWORD PTR _hkey$[esp+1664]
  0005c	8d 4c 24 10	 lea	 ecx, DWORD PTR _size$135060[esp+1664]
  00060	51		 push	 ecx
  00061	8d 94 24 70 02
	00 00		 lea	 edx, DWORD PTR _rv$135059[esp+1668]
  00068	52		 push	 edx
  00069	53		 push	 ebx
  0006a	53		 push	 ebx
  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@OJMJCMCH@UninstallString?$AA@
  00070	50		 push	 eax
  00071	c7 44 24 28 10
	04 00 00	 mov	 DWORD PTR _size$135060[esp+1688], 1040 ; 00000410H
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  0007f	85 c0		 test	 eax, eax
  00081	0f 85 8f 00 00
	00		 jne	 $LN9@SetInstall
  00087	8d 8c 24 6c 02
	00 00		 lea	 ecx, DWORD PTR _rv$135059[esp+1664]
  0008e	6a 2f		 push	 47			; 0000002fH
  00090	51		 push	 ecx
  00091	e8 00 00 00 00	 call	 _strrchr
  00096	83 c4 08	 add	 esp, 8
  00099	85 c0		 test	 eax, eax
  0009b	74 79		 je	 SHORT $LN9@SetInstall

; 2164 : 		{
; 2165 : 			size_t len = 0;
; 2166 : 
; 2167 : 			// Cut and paste the location (path) where CipherShed is installed to InstallationPath
; 2168 : 			if (rv[0] == '"')

  0009d	80 bc 24 6c 02
	00 00 22	 cmp	 BYTE PTR _rv$135059[esp+1664], 34 ; 00000022H

; 2169 : 			{
; 2170 : 				// 4.3 or later
; 2171 : 
; 2172 : 				len = strrchr (rv, '/') - rv - 2;

  000a5	6a 2f		 push	 47			; 0000002fH
  000a7	0f 85 d0 00 00
	00		 jne	 $LN13@SetInstall
  000ad	8d 94 24 70 02
	00 00		 lea	 edx, DWORD PTR _rv$135059[esp+1668]
  000b4	52		 push	 edx
  000b5	e8 00 00 00 00	 call	 _strrchr
  000ba	8b f0		 mov	 esi, eax
  000bc	8d 8c 24 74 02
	00 00		 lea	 ecx, DWORD PTR _rv$135059[esp+1672]
  000c3	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000c8	2b c1		 sub	 eax, ecx
  000ca	03 f0		 add	 esi, eax

; 2173 : 				strncpy (InstallationPath, rv + 1, len);

  000cc	56		 push	 esi
  000cd	8d 94 24 79 02
	00 00		 lea	 edx, DWORD PTR _rv$135059[esp+1677]
  000d4	52		 push	 edx
  000d5	68 00 00 00 00	 push	 OFFSET _InstallationPath
  000da	e8 00 00 00 00	 call	 _strncpy

; 2174 : 				InstallationPath [len] = 0;
; 2175 : 				bInstallPathDetermined = TRUE;
; 2176 : 
; 2177 : 				if (InstallationPath [strlen (InstallationPath) - 1] != '\\')

  000df	b8 00 00 00 00	 mov	 eax, OFFSET _InstallationPath
  000e4	88 9e 00 00 00
	00		 mov	 BYTE PTR _InstallationPath[esi], bl
  000ea	83 c4 14	 add	 esp, 20			; 00000014H
  000ed	8d 73 01	 lea	 esi, DWORD PTR [ebx+1]
  000f0	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL142@SetInstall:
  000f3	8a 08		 mov	 cl, BYTE PTR [eax]
  000f5	40		 inc	 eax
  000f6	3a cb		 cmp	 cl, bl
  000f8	75 f9		 jne	 SHORT $LL142@SetInstall
  000fa	2b c2		 sub	 eax, edx
  000fc	80 b8 ff ff ff
	ff 5c		 cmp	 BYTE PTR _InstallationPath[eax-1], 92 ; 0000005cH
  00103	74 11		 je	 SHORT $LN9@SetInstall

; 2178 : 				{
; 2179 : 					len = strrchr (InstallationPath, '\\') - InstallationPath;

  00105	6a 5c		 push	 92			; 0000005cH
  00107	68 00 00 00 00	 push	 OFFSET _InstallationPath
  0010c	e8 00 00 00 00	 call	 _strrchr
  00111	83 c4 08	 add	 esp, 8

; 2180 : 					InstallationPath [len] = 0;

  00114	88 18		 mov	 BYTE PTR [eax], bl
$LN9@SetInstall:

; 2213 : 				}
; 2214 : 			}
; 2215 : 
; 2216 : 		}
; 2217 : 		RegCloseKey (hkey);

  00116	8b 4c 24 0c	 mov	 ecx, DWORD PTR _hkey$[esp+1664]
  0011a	51		 push	 ecx
  0011b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 2218 : 	}
; 2219 : 
; 2220 : 	if (bInstallPathDetermined)

  00121	3b f3		 cmp	 esi, ebx
  00123	0f 84 87 01 00
	00		 je	 $LN8@SetInstall

; 2221 : 	{
; 2222 : 		char mp[MAX_PATH];
; 2223 : 
; 2224 : 		// Determine whether we were launched from the folder where CipherShed is installed
; 2225 : 		GetModuleFileName (NULL, mp, sizeof (mp));

  00129	68 04 01 00 00	 push	 260			; 00000104H
  0012e	8d 94 24 6c 01
	00 00		 lea	 edx, DWORD PTR _mp$135072[esp+1668]
  00135	52		 push	 edx
  00136	53		 push	 ebx
  00137	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12

; 2226 : 		if (strncmp (InstallationPath, mp, min (strlen(InstallationPath), strlen(mp))) == 0)

  0013d	b8 00 00 00 00	 mov	 eax, OFFSET _InstallationPath
  00142	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL145@SetInstall:
  00145	8a 08		 mov	 cl, BYTE PTR [eax]
  00147	40		 inc	 eax
  00148	3a cb		 cmp	 cl, bl
  0014a	75 f9		 jne	 SHORT $LL145@SetInstall
  0014c	8d 8c 24 68 01
	00 00		 lea	 ecx, DWORD PTR _mp$135072[esp+1664]
  00153	2b c2		 sub	 eax, edx
  00155	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$LL146@SetInstall:
  00158	8a 11		 mov	 dl, BYTE PTR [ecx]
  0015a	41		 inc	 ecx
  0015b	3a d3		 cmp	 dl, bl
  0015d	75 f9		 jne	 SHORT $LL146@SetInstall
  0015f	2b ce		 sub	 ecx, esi
  00161	3b c1		 cmp	 eax, ecx
  00163	0f 83 ee 00 00
	00		 jae	 $LN18@SetInstall
  00169	b8 00 00 00 00	 mov	 eax, OFFSET _InstallationPath
  0016e	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL147@SetInstall:
  00171	8a 08		 mov	 cl, BYTE PTR [eax]
  00173	40		 inc	 eax
  00174	3a cb		 cmp	 cl, bl
  00176	75 f9		 jne	 SHORT $LL147@SetInstall
  00178	e9 eb 00 00 00	 jmp	 $LN155@SetInstall
$LN13@SetInstall:

; 2181 : 				}
; 2182 : 			}
; 2183 : 			else
; 2184 : 			{
; 2185 : 				// 1.0-4.2a (except 3.1)
; 2186 : 
; 2187 : 				len = strrchr (rv, '/') - rv;

  0017d	8d 84 24 70 02
	00 00		 lea	 eax, DWORD PTR _rv$135059[esp+1668]
  00184	50		 push	 eax
  00185	e8 00 00 00 00	 call	 _strrchr
  0018a	8b f0		 mov	 esi, eax
  0018c	8d 8c 24 74 02
	00 00		 lea	 ecx, DWORD PTR _rv$135059[esp+1672]
  00193	2b f1		 sub	 esi, ecx
  00195	83 c4 08	 add	 esp, 8

; 2188 : 				if (rv[len+2] == ' ')

  00198	80 bc 34 6e 02
	00 00 20	 cmp	 BYTE PTR _rv$135059[esp+esi+1666], 32 ; 00000020H
  001a0	75 4e		 jne	 SHORT $LN10@SetInstall

; 2189 : 				{
; 2190 : 					// 4.0-4.2a
; 2191 : 
; 2192 : 					strncpy (InstallationPath, rv + len + 3, strlen (rv) - len - 3);

  001a2	8b c1		 mov	 eax, ecx
  001a4	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL143@SetInstall:
  001a7	8a 08		 mov	 cl, BYTE PTR [eax]
  001a9	40		 inc	 eax
  001aa	3a cb		 cmp	 cl, bl
  001ac	75 f9		 jne	 SHORT $LL143@SetInstall
  001ae	2b c2		 sub	 eax, edx
  001b0	2b c6		 sub	 eax, esi
  001b2	83 e8 03	 sub	 eax, 3
  001b5	50		 push	 eax
  001b6	8d 94 34 73 02
	00 00		 lea	 edx, DWORD PTR _rv$135059[esp+esi+1671]
  001bd	52		 push	 edx
  001be	68 00 00 00 00	 push	 OFFSET _InstallationPath
  001c3	e8 00 00 00 00	 call	 _strncpy

; 2193 : 					InstallationPath [strlen (rv) - len - 3] = 0;

  001c8	8d 84 24 78 02
	00 00		 lea	 eax, DWORD PTR _rv$135059[esp+1676]
  001cf	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d2	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL144@SetInstall:
  001d5	8a 08		 mov	 cl, BYTE PTR [eax]
  001d7	40		 inc	 eax
  001d8	3a cb		 cmp	 cl, bl
  001da	75 f9		 jne	 SHORT $LL144@SetInstall
  001dc	2b c2		 sub	 eax, edx
  001de	2b c6		 sub	 eax, esi
  001e0	88 98 fd ff ff
	ff		 mov	 BYTE PTR _InstallationPath[eax-3], bl

; 2194 : 					bInstallPathDetermined = TRUE;

  001e6	be 01 00 00 00	 mov	 esi, 1

; 2195 : 				}
; 2196 : 				else

  001eb	e9 26 ff ff ff	 jmp	 $LN9@SetInstall
$LN10@SetInstall:

; 2197 : 				{
; 2198 : 					// 1.0-3.1a (except 3.1)
; 2199 : 
; 2200 : 					// We know that CipherShed is installed but don't know where. It's not safe to continue installing
; 2201 : 					// over the old version.
; 2202 : 
; 2203 : 					Error ("UNINSTALL_OLD_VERSION_FIRST");

  001f0	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@IFDMFKIM@UNINSTALL_OLD_VERSION_FIRST?$AA@
  001f5	e8 00 00 00 00	 call	 _Error

; 2204 : 
; 2205 : 					len = strrchr (rv, '/') - rv - 1;

  001fa	8d 84 24 70 02
	00 00		 lea	 eax, DWORD PTR _rv$135059[esp+1668]
  00201	6a 2f		 push	 47			; 0000002fH
  00203	50		 push	 eax
  00204	e8 00 00 00 00	 call	 _strrchr
  00209	8d 8c 24 78 02
	00 00		 lea	 ecx, DWORD PTR _rv$135059[esp+1676]
  00210	8b f0		 mov	 esi, eax
  00212	2b f1		 sub	 esi, ecx
  00214	4e		 dec	 esi

; 2206 : 					strncpy (InstallationPath, rv, len);	// Path and filename of the uninstaller

  00215	56		 push	 esi
  00216	8b d1		 mov	 edx, ecx
  00218	52		 push	 edx
  00219	68 00 00 00 00	 push	 OFFSET _InstallationPath
  0021e	e8 00 00 00 00	 call	 _strncpy
  00223	83 c4 18	 add	 esp, 24			; 00000018H

; 2207 : 					InstallationPath [len] = 0;
; 2208 : 					bInstallPathDetermined = FALSE;
; 2209 : 
; 2210 : 					ShellExecute (NULL, "open", InstallationPath, "/u", NULL, SW_SHOWNORMAL);

  00226	6a 01		 push	 1
  00228	53		 push	 ebx
  00229	68 00 00 00 00	 push	 OFFSET ??_C@_02GBOHKKID@?1u?$AA@
  0022e	68 00 00 00 00	 push	 OFFSET _InstallationPath
  00233	68 00 00 00 00	 push	 OFFSET ??_C@_04PMOCAHAA@open?$AA@
  00238	53		 push	 ebx
  00239	88 9e 00 00 00
	00		 mov	 BYTE PTR _InstallationPath[esi], bl
  0023f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShellExecuteA@24

; 2211 : 					RegCloseKey (hkey);

  00245	8b 44 24 0c	 mov	 eax, DWORD PTR _hkey$[esp+1664]
  00249	50		 push	 eax
  0024a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 2212 : 					exit (1);

  00250	6a 01		 push	 1
  00252	e8 00 00 00 00	 call	 _exit
$LN18@SetInstall:

; 2226 : 		if (strncmp (InstallationPath, mp, min (strlen(InstallationPath), strlen(mp))) == 0)

  00257	8d 84 24 68 01
	00 00		 lea	 eax, DWORD PTR _mp$135072[esp+1664]
  0025e	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL148@SetInstall:
  00261	8a 08		 mov	 cl, BYTE PTR [eax]
  00263	40		 inc	 eax
  00264	3a cb		 cmp	 cl, bl
  00266	75 f9		 jne	 SHORT $LL148@SetInstall
$LN155@SetInstall:
  00268	2b c2		 sub	 eax, edx
  0026a	50		 push	 eax
  0026b	8d 84 24 6c 01
	00 00		 lea	 eax, DWORD PTR _mp$135072[esp+1668]
  00272	50		 push	 eax
  00273	68 00 00 00 00	 push	 OFFSET _InstallationPath
  00278	e8 00 00 00 00	 call	 _strncmp
  0027d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00280	85 c0		 test	 eax, eax
  00282	0f 85 82 01 00
	00		 jne	 $LN5@SetInstall

; 2227 : 		{
; 2228 : 			// We were launched from the folder where CipherShed is installed
; 2229 : 
; 2230 : 			if (!IsNonInstallMode() && !bDevm)

  00288	e8 00 00 00 00	 call	 _IsNonInstallMode
  0028d	85 c0		 test	 eax, eax
  0028f	0f 85 75 01 00
	00		 jne	 $LN5@SetInstall
  00295	39 1d 00 00 00
	00		 cmp	 DWORD PTR _bDevm, ebx
  0029b	0f 85 69 01 00
	00		 jne	 $LN5@SetInstall

; 2231 : 				bChangeMode = TRUE;

  002a1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bChangeMode@@3HA, 1 ; bChangeMode

; 2232 : 		}
; 2233 : 	}
; 2234 : 	else

  002ab	e9 5a 01 00 00	 jmp	 $LN5@SetInstall
$LN8@SetInstall:

; 2235 : 	{
; 2236 : 		/* CipherShed is not installed or it wasn't possible to determine where it is installed. */
; 2237 : 
; 2238 : 		// Default "Program Files" path. 
; 2239 : 		SHGetSpecialFolderLocation (hwndDlg, CSIDL_PROGRAM_FILES, &itemList);

  002b0	8d 4c 24 14	 lea	 ecx, DWORD PTR _itemList$[esp+1664]
  002b4	51		 push	 ecx
  002b5	6a 26		 push	 38			; 00000026H
  002b7	57		 push	 edi
  002b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SHGetSpecialFolderLocation@12

; 2240 : 		SHGetPathFromIDList (itemList, path);

  002be	8b 44 24 14	 mov	 eax, DWORD PTR _itemList$[esp+1664]
  002c2	8d 54 24 50	 lea	 edx, DWORD PTR _path$[esp+1664]
  002c6	52		 push	 edx
  002c7	50		 push	 eax
  002c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SHGetPathFromIDListA@8

; 2241 : 
; 2242 : 		if (Is64BitOs())

  002ce	e8 00 00 00 00	 call	 _Is64BitOs
  002d3	85 c0		 test	 eax, eax
  002d5	0f 84 cb 00 00
	00		 je	 $LN131@SetInstall

; 2243 : 		{
; 2244 : 			// Use a unified default installation path (registry redirection of %ProgramFiles% does not work if the installation path is user-selectable)
; 2245 : 			string s = path;

  002db	8d 44 24 50	 lea	 eax, DWORD PTR _path$[esp+1664]
  002df	c7 44 24 4c 0f
	00 00 00	 mov	 DWORD PTR _s$135077[esp+1688], 15 ; 0000000fH
  002e7	89 5c 24 48	 mov	 DWORD PTR _s$135077[esp+1684], ebx
  002eb	88 5c 24 38	 mov	 BYTE PTR _s$135077[esp+1668], bl
  002ef	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL149@SetInstall:
  002f2	8a 08		 mov	 cl, BYTE PTR [eax]
  002f4	40		 inc	 eax
  002f5	3a cb		 cmp	 cl, bl
  002f7	75 f9		 jne	 SHORT $LL149@SetInstall
  002f9	2b c2		 sub	 eax, edx
  002fb	50		 push	 eax
  002fc	8d 4c 24 54	 lea	 ecx, DWORD PTR _path$[esp+1668]
  00300	51		 push	 ecx
  00301	8d 4c 24 3c	 lea	 ecx, DWORD PTR _s$135077[esp+1672]
  00305	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2246 : 			size_t p = s.find (" (x86)");

  0030a	6a 06		 push	 6
  0030c	53		 push	 ebx
  0030d	68 00 00 00 00	 push	 OFFSET ??_C@_06NOEMODMP@?5?$CIx86?$CJ?$AA@
  00312	8d 4c 24 40	 lea	 ecx, DWORD PTR _s$135077[esp+1676]
  00316	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find

; 2247 : 			if (p != string::npos)

  0031b	be 10 00 00 00	 mov	 esi, 16			; 00000010H
  00320	83 f8 ff	 cmp	 eax, -1
  00323	74 6e		 je	 SHORT $LN2@SetInstall

; 2248 : 			{
; 2249 : 				s = s.substr (0, p);

  00325	50		 push	 eax
  00326	53		 push	 ebx
  00327	8d 54 24 20	 lea	 edx, DWORD PTR $T143979[esp+1672]
  0032b	52		 push	 edx
  0032c	8d 4c 24 40	 lea	 ecx, DWORD PTR _s$135077[esp+1676]
  00330	e8 00 00 00 00	 call	 ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
  00335	6a ff		 push	 -1
  00337	53		 push	 ebx
  00338	50		 push	 eax
  00339	8d 4c 24 40	 lea	 ecx, DWORD PTR _s$135077[esp+1676]
  0033d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00342	39 74 24 30	 cmp	 DWORD PTR $T143979[esp+1688], esi
  00346	72 0d		 jb	 SHORT $LN93@SetInstall
  00348	8b 44 24 1c	 mov	 eax, DWORD PTR $T143979[esp+1668]
  0034c	50		 push	 eax
  0034d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00352	83 c4 04	 add	 esp, 4
$LN93@SetInstall:

; 2250 : 				if (_access (s.c_str(), 0) != -1)

  00355	8b 44 24 38	 mov	 eax, DWORD PTR _s$135077[esp+1668]
  00359	39 74 24 4c	 cmp	 DWORD PTR _s$135077[esp+1688], esi
  0035d	73 04		 jae	 SHORT $LN108@SetInstall
  0035f	8d 44 24 38	 lea	 eax, DWORD PTR _s$135077[esp+1668]
$LN108@SetInstall:
  00363	53		 push	 ebx
  00364	50		 push	 eax
  00365	e8 00 00 00 00	 call	 __access
  0036a	83 c4 08	 add	 esp, 8
  0036d	83 f8 ff	 cmp	 eax, -1
  00370	74 21		 je	 SHORT $LN2@SetInstall

; 2251 : 					strcpy_s (path, sizeof (path), s.c_str());

  00372	8b 44 24 38	 mov	 eax, DWORD PTR _s$135077[esp+1668]
  00376	39 74 24 4c	 cmp	 DWORD PTR _s$135077[esp+1688], esi
  0037a	73 04		 jae	 SHORT $LN114@SetInstall
  0037c	8d 44 24 38	 lea	 eax, DWORD PTR _s$135077[esp+1668]
$LN114@SetInstall:
  00380	50		 push	 eax
  00381	8d 4c 24 54	 lea	 ecx, DWORD PTR _path$[esp+1668]
  00385	68 18 01 00 00	 push	 280			; 00000118H
  0038a	51		 push	 ecx
  0038b	e8 00 00 00 00	 call	 _strcpy_s
  00390	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@SetInstall:

; 2252 : 			}
; 2253 : 		}

  00393	39 74 24 4c	 cmp	 DWORD PTR _s$135077[esp+1688], esi
  00397	72 0d		 jb	 SHORT $LN131@SetInstall
  00399	8b 54 24 38	 mov	 edx, DWORD PTR _s$135077[esp+1668]
  0039d	52		 push	 edx
  0039e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  003a3	83 c4 04	 add	 esp, 4
$LN131@SetInstall:

; 2254 : 
; 2255 : 		strncat (path, "\\CipherShed\\", min (strlen("\\CipherShed\\"), sizeof(path)-strlen(path)-1));

  003a6	8d 44 24 50	 lea	 eax, DWORD PTR _path$[esp+1664]
  003aa	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  003ad	8d 49 00	 npad	 3
$LL150@SetInstall:
  003b0	8a 08		 mov	 cl, BYTE PTR [eax]
  003b2	40		 inc	 eax
  003b3	3a cb		 cmp	 cl, bl
  003b5	75 f9		 jne	 SHORT $LL150@SetInstall
  003b7	2b c2		 sub	 eax, edx
  003b9	b9 17 01 00 00	 mov	 ecx, 279		; 00000117H
  003be	2b c8		 sub	 ecx, eax
  003c0	83 f9 0c	 cmp	 ecx, 12			; 0000000cH
  003c3	76 07		 jbe	 SHORT $LN20@SetInstall
  003c5	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  003ca	eb 17		 jmp	 SHORT $LN21@SetInstall
$LN20@SetInstall:
  003cc	8d 44 24 50	 lea	 eax, DWORD PTR _path$[esp+1664]
  003d0	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL151@SetInstall:
  003d3	8a 08		 mov	 cl, BYTE PTR [eax]
  003d5	40		 inc	 eax
  003d6	3a cb		 cmp	 cl, bl
  003d8	75 f9		 jne	 SHORT $LL151@SetInstall
  003da	2b c2		 sub	 eax, edx
  003dc	b9 17 01 00 00	 mov	 ecx, 279		; 00000117H
  003e1	2b c8		 sub	 ecx, eax
$LN21@SetInstall:
  003e3	51		 push	 ecx
  003e4	8d 54 24 54	 lea	 edx, DWORD PTR _path$[esp+1668]
  003e8	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ILKBADPD@?2CipherShed?2?$AA@
  003ed	52		 push	 edx
  003ee	e8 00 00 00 00	 call	 _strncat

; 2256 : 		strncpy (InstallationPath, path, sizeof(InstallationPath)-1);

  003f3	68 03 01 00 00	 push	 259			; 00000103H
  003f8	8d 44 24 60	 lea	 eax, DWORD PTR _path$[esp+1680]
  003fc	50		 push	 eax
  003fd	68 00 00 00 00	 push	 OFFSET _InstallationPath
  00402	e8 00 00 00 00	 call	 _strncpy
  00407	83 c4 18	 add	 esp, 24			; 00000018H
$LN5@SetInstall:

; 2257 : 	}
; 2258 : 
; 2259 : 	// Make sure the path ends with a backslash
; 2260 : 	if (InstallationPath [strlen (InstallationPath) - 1] != '\\')

  0040a	b8 00 00 00 00	 mov	 eax, OFFSET _InstallationPath
  0040f	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL152@SetInstall:
  00412	8a 08		 mov	 cl, BYTE PTR [eax]
  00414	40		 inc	 eax
  00415	3a cb		 cmp	 cl, bl
  00417	75 f9		 jne	 SHORT $LL152@SetInstall
  00419	2b c2		 sub	 eax, edx
  0041b	80 b8 ff ff ff
	ff 5c		 cmp	 BYTE PTR _InstallationPath[eax-1], 92 ; 0000005cH
  00422	74 1e		 je	 SHORT $LN1@SetInstall

; 2261 : 	{
; 2262 : 		strcat (InstallationPath, "\\");

  00424	bf 00 00 00 00	 mov	 edi, OFFSET _InstallationPath
  00429	4f		 dec	 edi
  0042a	8d 9b 00 00 00
	00		 npad	 6
$LL153@SetInstall:
  00430	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00433	47		 inc	 edi
  00434	3a c3		 cmp	 al, bl
  00436	75 f8		 jne	 SHORT $LL153@SetInstall
  00438	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR ??_C@_01KICIPPFI@?2?$AA@
  0043f	66 89 0f	 mov	 WORD PTR [edi], cx
$LN1@SetInstall:

; 2263 : 	}
; 2264 : 
; 2265 : 	/*
; 2266 : 	 * CipherShed changes the InstallationPath in case of TrueCrypt upgrade,
; 2267 : 	 * we need to store the original path for TrueCrypt uninstall.
; 2268 : 	 */
; 2269 : 	strcpy(UninstallationPath, InstallationPath);

  00442	33 c0		 xor	 eax, eax
  00444	eb 0a 8d a4 24
	00 00 00 00 8d
	49 00		 npad	 12
$LL22@SetInstall:
  00450	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR _InstallationPath[eax]
  00456	88 88 00 00 00
	00		 mov	 BYTE PTR ?UninstallationPath@@3PADA[eax], cl
  0045c	40		 inc	 eax
  0045d	3a cb		 cmp	 cl, bl
  0045f	75 ef		 jne	 SHORT $LL22@SetInstall

; 2270 : }

  00461	8b 8c 24 7c 06
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1664]
  00468	5f		 pop	 edi
  00469	5e		 pop	 esi
  0046a	5b		 pop	 ebx
  0046b	33 cc		 xor	 ecx, esp
  0046d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00472	81 c4 74 06 00
	00		 add	 esp, 1652		; 00000674H
  00478	c3		 ret	 0
$LN154@SetInstall:
_SetInstallationPath ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@FMOIKEAK@srclient?4dll?$AA@		; `string'
PUBLIC	??_C@_0LF@DPEFIJFF@Error?3?5This?5installer?5file?5does?5@ ; `string'
PUBLIC	??_C@_04GOLNGIJ@EXIT?$AA@			; `string'
PUBLIC	??_C@_09DGJDINFF@UNINSTALL?$AA@			; `string'
PUBLIC	??_C@_0BB@OFECFCBP@REPAIR_REINSTALL?$AA@	; `string'
PUBLIC	??_C@_0BB@FLPPPJPG@SELECT_AN_ACTION?$AA@	; `string'
PUBLIC	??_C@_0M@HBOJDPDG@SETUP_ADMIN?$AA@		; `string'
PUBLIC	??_C@_1CC@JAFFKJKA@?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AA?5?$AAS?$AAe?$AAt?$AAu?$AAp?$AA?$AA@ ; `string'
PUBLIC	_WinMain@16
EXTRN	__imp__CreateProcessA@40:PROC
EXTRN	_MainDialogProc@16:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	_AskMultiChoice:PROC
EXTRN	_VerifyPackageIntegrity:PROC
EXTRN	_IsSelfExtractingPackage:PROC
EXTRN	_MakeSelfExtractingPackage:PROC
EXTRN	_IsAdmin:PROC
EXTRN	_InitApp:PROC
EXTRN	__imp__InitCommonControls@0:PROC
EXTRN	_SelfExtractStartupInit:PROC
EXTRN	_atexit:PROC
;	COMDAT ??_C@_0N@FMOIKEAK@srclient?4dll?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\string.h
CONST	SEGMENT
??_C@_0N@FMOIKEAK@srclient?4dll?$AA@ DB 'srclient.dll', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0LF@DPEFIJFF@Error?3?5This?5installer?5file?5does?5@
CONST	SEGMENT
??_C@_0LF@DPEFIJFF@Error?3?5This?5installer?5file?5does?5@ DB 'Error: Thi'
	DB	's installer file does not contain any compressed files.', 0aH
	DB	0aH, 'To create a self-extracting installation package (with e'
	DB	'mbedded compressed files), run:', 0aH, '"CipherShed-Setup.exe'
	DB	'" /p', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_04GOLNGIJ@EXIT?$AA@
CONST	SEGMENT
??_C@_04GOLNGIJ@EXIT?$AA@ DB 'EXIT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09DGJDINFF@UNINSTALL?$AA@
CONST	SEGMENT
??_C@_09DGJDINFF@UNINSTALL?$AA@ DB 'UNINSTALL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OFECFCBP@REPAIR_REINSTALL?$AA@
CONST	SEGMENT
??_C@_0BB@OFECFCBP@REPAIR_REINSTALL?$AA@ DB 'REPAIR_REINSTALL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FLPPPJPG@SELECT_AN_ACTION?$AA@
CONST	SEGMENT
??_C@_0BB@FLPPPJPG@SELECT_AN_ACTION?$AA@ DB 'SELECT_AN_ACTION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HBOJDPDG@SETUP_ADMIN?$AA@
CONST	SEGMENT
??_C@_0M@HBOJDPDG@SETUP_ADMIN?$AA@ DB 'SETUP_ADMIN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@JAFFKJKA@?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AA?5?$AAS?$AAe?$AAt?$AAu?$AAp?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@JAFFKJKA@?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AA?5?$AAS?$AAe?$AAt?$AAu?$AAp?$AA?$AA@ DB 'C'
	DB	00H, 'i', 00H, 'p', 00H, 'h', 00H, 'e', 00H, 'r', 00H, 'S', 00H
	DB	'h', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'S', 00H, 'e', 00H, 't'
	DB	00H, 'u', 00H, 'p', 00H, 00H, 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\home\public\desktop\projects\ciphershed.build\src\setup\setup.c
CONST	ENDS
;	COMDAT _WinMain@16
_TEXT	SEGMENT
_pi$135178 = -108					; size = 16
_tmpStr$135151 = -92					; size = 24
_si$135177 = -68					; size = 68
_hInstance$ = 8						; size = 4
_hPrevInstance$ = 12					; size = 4
_lpszCommandLine$ = 16					; size = 4
_nCmdShow$ = 20						; size = 4
_WinMain@16 PROC					; COMDAT

; 2382 : {

  00000	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	57		 push	 edi

; 2383 : 	atexit (localcleanup);

  00006	68 00 00 00 00	 push	 OFFSET _localcleanup
  0000b	e8 00 00 00 00	 call	 _atexit
  00010	83 c4 04	 add	 esp, 4

; 2384 : 
; 2385 : 	SelfExtractStartupInit();

  00013	e8 00 00 00 00	 call	 _SelfExtractStartupInit

; 2386 : 
; 2387 : 	lpszTitle = L"CipherShed Setup";

  00018	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _lpszTitle, OFFSET ??_C@_1CC@JAFFKJKA@?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AA?5?$AAS?$AAe?$AAt?$AAu?$AAp?$AA?$AA@

; 2388 : 
; 2389 : 	InitCommonControls ();

  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitCommonControls@0

; 2390 : 
; 2391 : 	/* Call InitApp to initialize the common code */
; 2392 : 	InitApp (hInstance, NULL);

  00028	8b 6c 24 7c	 mov	 ebp, DWORD PTR _hInstance$[esp+116]
  0002c	33 db		 xor	 ebx, ebx
  0002e	53		 push	 ebx
  0002f	55		 push	 ebp
  00030	e8 00 00 00 00	 call	 _InitApp
  00035	83 c4 08	 add	 esp, 8

; 2393 : 
; 2394 : 	/* The setup requires admin privileges, but give the user an option to continue. */
; 2395 : 	if (IsAdmin () != TRUE &&
; 2396 : 		MessageBoxW (NULL, GetString ("SETUP_ADMIN"), lpszTitle, MB_YESNO | MB_ICONQUESTION) != IDYES)

  00038	e8 00 00 00 00	 call	 _IsAdmin
  0003d	bf 01 00 00 00	 mov	 edi, 1
  00042	3b c7		 cmp	 eax, edi
  00044	74 28		 je	 SHORT $LN29@WinMain
  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  0004b	6a 24		 push	 36			; 00000024H
  0004d	50		 push	 eax
  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HBOJDPDG@SETUP_ADMIN?$AA@
  00053	e8 00 00 00 00	 call	 _GetString
  00058	83 c4 04	 add	 esp, 4
  0005b	50		 push	 eax
  0005c	53		 push	 ebx
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
  00063	83 f8 06	 cmp	 eax, 6
  00066	74 06		 je	 SHORT $LN29@WinMain

; 2397 : 	{
; 2398 : 		exit (1);

  00068	57		 push	 edi
  00069	e8 00 00 00 00	 call	 _exit
$LN29@WinMain:

; 2399 : 	}
; 2400 : 
; 2401 : 	/* Setup directory */
; 2402 : 	{
; 2403 : 		char *s;
; 2404 : 		GetModuleFileName (NULL, SetupFilesDir, sizeof (SetupFilesDir));

  0006e	68 04 01 00 00	 push	 260			; 00000104H
  00073	68 00 00 00 00	 push	 OFFSET _SetupFilesDir
  00078	53		 push	 ebx
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12

; 2405 : 		s = strrchr (SetupFilesDir, '\\');

  0007f	6a 5c		 push	 92			; 0000005cH
  00081	68 00 00 00 00	 push	 OFFSET _SetupFilesDir
  00086	e8 00 00 00 00	 call	 _strrchr
  0008b	83 c4 08	 add	 esp, 8

; 2406 : 		if (s)

  0008e	3b c3		 cmp	 eax, ebx
  00090	74 03		 je	 SHORT $LN28@WinMain

; 2407 : 			s[1] = 0;

  00092	88 58 01	 mov	 BYTE PTR [eax+1], bl
$LN28@WinMain:
  00095	56		 push	 esi

; 2408 : 	}
; 2409 : 
; 2410 : 	/* Parse command line arguments */
; 2411 : 	if (lpszCommandLine[0] == '/')

  00096	8b b4 24 88 00
	00 00		 mov	 esi, DWORD PTR _lpszCommandLine$[esp+120]
  0009d	80 3e 2f	 cmp	 BYTE PTR [esi], 47	; 0000002fH
  000a0	75 3d		 jne	 SHORT $LN19@WinMain

; 2412 : 	{
; 2413 : 		if (lpszCommandLine[1] == 'u')

  000a2	8a 46 01	 mov	 al, BYTE PTR [esi+1]
  000a5	3c 75		 cmp	 al, 117			; 00000075H
  000a7	75 08		 jne	 SHORT $LN26@WinMain

; 2414 : 		{
; 2415 : 			// Uninstall:	/u
; 2416 : 			bUninstall = TRUE;

  000a9	89 3d 00 00 00
	00		 mov	 DWORD PTR ?bUninstall@@3HA, edi ; bUninstall
  000af	eb 2e		 jmp	 SHORT $LN19@WinMain
$LN26@WinMain:

; 2417 : 		}
; 2418 : 		else if (lpszCommandLine[1] == 'c')

  000b1	3c 63		 cmp	 al, 99			; 00000063H
  000b3	75 08		 jne	 SHORT $LN24@WinMain

; 2419 : 		{
; 2420 : 			// Change:	/c
; 2421 : 			bChangeMode = TRUE;

  000b5	89 3d 00 00 00
	00		 mov	 DWORD PTR ?bChangeMode@@3HA, edi ; bChangeMode
  000bb	eb 22		 jmp	 SHORT $LN19@WinMain
$LN24@WinMain:

; 2422 : 		}
; 2423 : 		else if (lpszCommandLine[1] == 'p')

  000bd	3c 70		 cmp	 al, 112			; 00000070H
  000bf	75 14		 jne	 SHORT $LN22@WinMain

; 2424 : 		{
; 2425 : 			// Create self-extracting package:	/p
; 2426 : 			bMakePackage = TRUE;

  000c1	89 3d 00 00 00
	00		 mov	 DWORD PTR ?bMakePackage@@3HA, edi ; bMakePackage

; 2427 : 
; 2428 : 			if ('q' == lpszCommandLine[2] )

  000c7	80 7e 02 71	 cmp	 BYTE PTR [esi+2], 113	; 00000071H
  000cb	75 1a		 jne	 SHORT $LN35@WinMain

; 2429 : 			{
; 2430 : 				quiet=TRUE;

  000cd	89 3d 00 00 00
	00		 mov	 DWORD PTR ?quiet@@3HA, edi ; quiet

; 2431 : 			}
; 2432 : 
; 2433 : 		}

  000d3	eb 12		 jmp	 SHORT $LN35@WinMain
$LN22@WinMain:

; 2434 : 		else if (lpszCommandLine[1] == 'd')

  000d5	3c 64		 cmp	 al, 100			; 00000064H
  000d7	75 06		 jne	 SHORT $LN19@WinMain

; 2435 : 		{
; 2436 : 			// Dev mode:	/d
; 2437 : 			bDevm = TRUE;

  000d9	89 3d 00 00 00
	00		 mov	 DWORD PTR _bDevm, edi
$LN19@WinMain:

; 2438 : 		}
; 2439 : 	}
; 2440 : 
; 2441 : 	if (bMakePackage)

  000df	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?bMakePackage@@3HA, ebx ; bMakePackage
  000e5	74 21		 je	 SHORT $LN18@WinMain
$LN35@WinMain:

; 2442 : 	{
; 2443 : 		/* Create self-extracting package */
; 2444 : 		MakeSelfExtractingPackage (NULL, SetupFilesDir, quiet);

  000e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?quiet@@3HA ; quiet
  000ed	51		 push	 ecx
  000ee	68 00 00 00 00	 push	 OFFSET _SetupFilesDir
  000f3	53		 push	 ebx
  000f4	e8 00 00 00 00	 call	 _MakeSelfExtractingPackage
  000f9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000fc	5e		 pop	 esi
  000fd	5f		 pop	 edi
  000fe	5d		 pop	 ebp

; 2521 : 				}
; 2522 : 			}
; 2523 : 		}
; 2524 : 	}
; 2525 : 
; 2526 : 	return 0;

  000ff	33 c0		 xor	 eax, eax
  00101	5b		 pop	 ebx

; 2527 : }

  00102	83 c4 6c	 add	 esp, 108		; 0000006cH
  00105	c2 10 00	 ret	 16			; 00000010H
$LN18@WinMain:

; 2445 : 	}
; 2446 : 	else
; 2447 : 	{
; 2448 : 		SetInstallationPath (NULL);

  00108	53		 push	 ebx
  00109	e8 00 00 00 00	 call	 _SetInstallationPath
  0010e	83 c4 04	 add	 esp, 4

; 2449 : 
; 2450 : 		if (!bUninstall)

  00111	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?bUninstall@@3HA, ebx ; bUninstall
  00117	0f 85 9c 00 00
	00		 jne	 $LN9@WinMain

; 2451 : 		{
; 2452 : 			if (IsSelfExtractingPackage())

  0011d	e8 00 00 00 00	 call	 _IsSelfExtractingPackage
  00122	85 c0		 test	 eax, eax
  00124	74 61		 je	 SHORT $LN15@WinMain

; 2453 : 			{
; 2454 : 				if (!VerifyPackageIntegrity())

  00126	e8 00 00 00 00	 call	 _VerifyPackageIntegrity
  0012b	85 c0		 test	 eax, eax
  0012d	75 06		 jne	 SHORT $LN14@WinMain

; 2455 : 				{
; 2456 : 					// Package corrupted 
; 2457 : 					exit (1);

  0012f	57		 push	 edi
  00130	e8 00 00 00 00	 call	 _exit
$LN14@WinMain:

; 2458 : 				}
; 2459 : 				bDevm = FALSE;

  00135	89 1d 00 00 00
	00		 mov	 DWORD PTR _bDevm, ebx
$LN12@WinMain:

; 2465 : 			}
; 2466 : 
; 2467 : 			if (bChangeMode)

  0013b	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?bChangeMode@@3HA, ebx ; bChangeMode
  00141	74 76		 je	 SHORT $LN9@WinMain

; 2468 : 			{
; 2469 : 				/* CipherShed is already installed on this system and we were launched from the Program Files folder */
; 2470 : 				char *tmpStr[] = {0, "SELECT_AN_ACTION", "REPAIR_REINSTALL", "UNINSTALL", "EXIT", 0};
; 2471 : 
; 2472 : 				// Ask the user to select either Repair or Unistallation
; 2473 : 				switch (AskMultiChoice ((void **) tmpStr, FALSE))

  00143	8d 54 24 20	 lea	 edx, DWORD PTR _tmpStr$135151[esp+124]
  00147	53		 push	 ebx
  00148	52		 push	 edx
  00149	89 5c 24 28	 mov	 DWORD PTR _tmpStr$135151[esp+132], ebx
  0014d	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR _tmpStr$135151[esp+136], OFFSET ??_C@_0BB@FLPPPJPG@SELECT_AN_ACTION?$AA@
  00155	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR _tmpStr$135151[esp+140], OFFSET ??_C@_0BB@OFECFCBP@REPAIR_REINSTALL?$AA@
  0015d	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR _tmpStr$135151[esp+144], OFFSET ??_C@_09DGJDINFF@UNINSTALL?$AA@
  00165	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR _tmpStr$135151[esp+148], OFFSET ??_C@_04GOLNGIJ@EXIT?$AA@
  0016d	89 5c 24 3c	 mov	 DWORD PTR _tmpStr$135151[esp+152], ebx
  00171	e8 00 00 00 00	 call	 _AskMultiChoice
  00176	83 c4 08	 add	 esp, 8
  00179	2b c7		 sub	 eax, edi
  0017b	74 36		 je	 SHORT $LN8@WinMain
  0017d	2b c7		 sub	 eax, edi
  0017f	74 2a		 je	 SHORT $LN7@WinMain

; 2481 : 				default:
; 2482 : 					exit (1);

  00181	57		 push	 edi
  00182	e8 00 00 00 00	 call	 _exit
$LN15@WinMain:

; 2460 : 			}
; 2461 : 			else if (!bDevm)

  00187	39 1d 00 00 00
	00		 cmp	 DWORD PTR _bDevm, ebx
  0018d	75 ac		 jne	 SHORT $LN12@WinMain

; 2462 : 			{
; 2463 : 				MessageBox (NULL, "Error: This installer file does not contain any compressed files.\n\nTo create a self-extracting installation package (with embedded compressed files), run:\n\"CipherShed-Setup.exe\" /p", "CipherShed", MB_ICONERROR | MB_SETFOREGROUND | MB_TOPMOST);

  0018f	68 10 00 05 00	 push	 327696			; 00050010H
  00194	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FEEFGEIL@CipherShed?$AA@
  00199	68 00 00 00 00	 push	 OFFSET ??_C@_0LF@DPEFIJFF@Error?3?5This?5installer?5file?5does?5@
  0019e	53		 push	 ebx
  0019f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 2464 : 				exit (1);

  001a5	57		 push	 edi
  001a6	e8 00 00 00 00	 call	 _exit
$LN7@WinMain:

; 2477 : 					break;
; 2478 : 				case 2:
; 2479 : 					bUninstall = TRUE;

  001ab	89 3d 00 00 00
	00		 mov	 DWORD PTR ?bUninstall@@3HA, edi ; bUninstall

; 2480 : 					break;

  001b1	eb 06		 jmp	 SHORT $LN9@WinMain
$LN8@WinMain:

; 2474 : 				{
; 2475 : 				case 1:
; 2476 : 					bRepairMode = TRUE;

  001b3	89 3d 00 00 00
	00		 mov	 DWORD PTR _bRepairMode, edi
$LN9@WinMain:

; 2483 : 				}
; 2484 : 			}
; 2485 : 		}
; 2486 : 
; 2487 : 		/* Try to load the System Restore dll. */
; 2488 : 		SystemRestoreDll = LoadLibrary ("srclient.dll");

  001b9	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FMOIKEAK@srclient?4dll?$AA@
  001be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  001c4	a3 00 00 00 00	 mov	 DWORD PTR _SystemRestoreDll, eax

; 2489 : 
; 2490 : 		if (!bUninstall)

  001c9	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?bUninstall@@3HA, ebx ; bUninstall
  001cf	75 1c		 jne	 SHORT $LN5@WinMain

; 2491 : 		{
; 2492 : 			/* Create the main dialog for install */
; 2493 : 			DialogBoxParamW (hInstance, MAKEINTRESOURCEW (IDD_INSTL_DLG), NULL, (DLGPROC) MainDialogProc, 
; 2494 : 				(LPARAM)lpszCommandLine);

  001d1	56		 push	 esi
  001d2	68 00 00 00 00	 push	 OFFSET _MainDialogProc@16
  001d7	53		 push	 ebx
  001d8	6a 6f		 push	 111			; 0000006fH
  001da	55		 push	 ebp
  001db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DialogBoxParamW@20
  001e1	5e		 pop	 esi
  001e2	5f		 pop	 edi
  001e3	5d		 pop	 ebp

; 2521 : 				}
; 2522 : 			}
; 2523 : 		}
; 2524 : 	}
; 2525 : 
; 2526 : 	return 0;

  001e4	33 c0		 xor	 eax, eax
  001e6	5b		 pop	 ebx

; 2527 : }

  001e7	83 c4 6c	 add	 esp, 108		; 0000006cH
  001ea	c2 10 00	 ret	 16			; 00000010H
$LN5@WinMain:

; 2495 : 		}
; 2496 : 		else
; 2497 : 		{
; 2498 : 			/* Create the main dialog for uninstall */
; 2499 : 			DialogBoxW (hInstance, MAKEINTRESOURCEW (IDD_UNINSTALL), NULL, (DLGPROC) UninstallDlgProc);

  001ed	53		 push	 ebx
  001ee	68 00 00 00 00	 push	 OFFSET ?UninstallDlgProc@@YGHPAUHWND__@@IIJ@Z ; UninstallDlgProc
  001f3	53		 push	 ebx
  001f4	6a 67		 push	 103			; 00000067H
  001f6	55		 push	 ebp
  001f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DialogBoxParamW@20

; 2500 : 
; 2501 : 			/* Check if the UninstallBatch path is not empty. */
; 2502 : 			if (UninstallBatch[0])

  001fd	38 1d 00 00 00
	00		 cmp	 BYTE PTR ?UninstallBatch@@3PADA, bl
  00203	74 75		 je	 SHORT $LN1@WinMain

; 2503 : 			{
; 2504 : 				STARTUPINFO si;
; 2505 : 				PROCESS_INFORMATION pi;
; 2506 : 
; 2507 : 				ZeroMemory (&si, sizeof (si));

  00205	6a 44		 push	 68			; 00000044H
  00207	8d 44 24 3c	 lea	 eax, DWORD PTR _si$135177[esp+128]
  0020b	53		 push	 ebx
  0020c	50		 push	 eax
  0020d	e8 00 00 00 00	 call	 _memset
  00212	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2508 : 				si.cb = sizeof (si);
; 2509 : 				si.dwFlags = STARTF_USESHOWWINDOW;
; 2510 : 				si.wShowWindow = SW_HIDE;
; 2511 : 
; 2512 : 				/* Execute the uninstall batch script. */
; 2513 : 				if (!CreateProcess (UninstallBatch, NULL, NULL, NULL, FALSE, IDLE_PRIORITY_CLASS, NULL, NULL, &si, &pi))

  00215	8d 54 24 10	 lea	 edx, DWORD PTR _pi$135178[esp+124]
  00219	52		 push	 edx
  0021a	8d 44 24 3c	 lea	 eax, DWORD PTR _si$135177[esp+128]
  0021e	50		 push	 eax
  0021f	53		 push	 ebx
  00220	53		 push	 ebx
  00221	6a 40		 push	 64			; 00000040H
  00223	53		 push	 ebx
  00224	53		 push	 ebx
  00225	53		 push	 ebx
  00226	53		 push	 ebx
  00227	33 c9		 xor	 ecx, ecx
  00229	68 00 00 00 00	 push	 OFFSET ?UninstallBatch@@3PADA ; UninstallBatch
  0022e	c7 44 24 60 44
	00 00 00	 mov	 DWORD PTR _si$135177[esp+164], 68 ; 00000044H
  00236	89 bc 24 8c 00
	00 00		 mov	 DWORD PTR _si$135177[esp+208], edi
  0023d	66 89 8c 24 90
	00 00 00	 mov	 WORD PTR _si$135177[esp+212], cx
  00245	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateProcessA@40
  0024b	85 c0		 test	 eax, eax
  0024d	75 17		 jne	 SHORT $LN2@WinMain

; 2514 : 				{
; 2515 : 					DeleteFile (UninstallBatch);

  0024f	68 00 00 00 00	 push	 OFFSET ?UninstallBatch@@3PADA ; UninstallBatch
  00254	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteFileA@4
  0025a	5e		 pop	 esi
  0025b	5f		 pop	 edi
  0025c	5d		 pop	 ebp

; 2521 : 				}
; 2522 : 			}
; 2523 : 		}
; 2524 : 	}
; 2525 : 
; 2526 : 	return 0;

  0025d	33 c0		 xor	 eax, eax
  0025f	5b		 pop	 ebx

; 2527 : }

  00260	83 c4 6c	 add	 esp, 108		; 0000006cH
  00263	c2 10 00	 ret	 16			; 00000010H
$LN2@WinMain:

; 2516 : 				}
; 2517 : 				else
; 2518 : 				{
; 2519 : 					CloseHandle (pi.hProcess);

  00266	8b 4c 24 10	 mov	 ecx, DWORD PTR _pi$135178[esp+124]
  0026a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CloseHandle@4
  00270	51		 push	 ecx
  00271	ff d6		 call	 esi

; 2520 : 					CloseHandle (pi.hThread);

  00273	8b 54 24 14	 mov	 edx, DWORD PTR _pi$135178[esp+128]
  00277	52		 push	 edx
  00278	ff d6		 call	 esi
$LN1@WinMain:
  0027a	5e		 pop	 esi
  0027b	5f		 pop	 edi
  0027c	5d		 pop	 ebp

; 2521 : 				}
; 2522 : 			}
; 2523 : 		}
; 2524 : 	}
; 2525 : 
; 2526 : 	return 0;

  0027d	33 c0		 xor	 eax, eax
  0027f	5b		 pop	 ebx

; 2527 : }

  00280	83 c4 6c	 add	 esp, 108		; 0000006cH
  00283	c2 10 00	 ret	 16			; 00000010H
$LN37@WinMain:
_WinMain@16 ENDP
_TEXT	ENDS
END
