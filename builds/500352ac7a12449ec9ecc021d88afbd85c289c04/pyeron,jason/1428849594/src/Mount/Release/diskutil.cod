; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\home\public\Desktop\projects\ciphershed.build\src\Common\fsutil\diskutil.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0P@GHFPNOJB@bad?5allocation?$AA@		; `string'
PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
_DATA	ENDS
;	COMDAT ??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
CONST	SEGMENT
??_C@_0P@GHFPNOJB@bad?5allocation?$AA@ DB 'bad allocation', 00H ; `string'
CONST	ENDS
PUBLIC	??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs?$AA?$AA@	; `string'
PUBLIC	_GetDeviceInfo
EXTRN	__imp__DeviceIoControl@32:PROC
EXTRN	_hDriver:DWORD
EXTRN	__snwprintf:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs?$AA?$AA@
; File c:\home\public\desktop\projects\ciphershed.build\src\common\fsutil\diskutil.cpp
CONST	SEGMENT
??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs?$AA?$AA@ DB '%', 00H, 'h', 00H, 's', 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _GetDeviceInfo
_TEXT	SEGMENT
_dwResult$ = -4						; size = 4
_deviceName$ = 8					; size = 4
_info$ = 12						; size = 4
_GetDeviceInfo PROC					; COMDAT

; 7    : {

  00000	51		 push	 ecx
  00001	56		 push	 esi

; 8    : 	DWORD dwResult;
; 9    : 
; 10   : 	memset (info, 0, sizeof(*info));

  00002	8b 74 24 10	 mov	 esi, DWORD PTR _info$[esp+4]
  00006	68 30 02 00 00	 push	 560			; 00000230H
  0000b	6a 00		 push	 0
  0000d	56		 push	 esi
  0000e	e8 00 00 00 00	 call	 _memset

; 11   : 	_snwprintf ((PWSTR) &info->deviceName, ARRAY_LENGTH(info->deviceName), L"%hs", deviceName);

  00013	8b 44 24 18	 mov	 eax, DWORD PTR _deviceName$[esp+16]
  00017	50		 push	 eax
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs?$AA?$AA@
  0001d	68 04 01 00 00	 push	 260			; 00000104H
  00022	56		 push	 esi
  00023	e8 00 00 00 00	 call	 __snwprintf

; 12   : 
; 13   : 	return DeviceIoControl (hDriver, TC_IOCTL_GET_DRIVE_PARTITION_INFO, info, sizeof (*info), info, sizeof (*info), &dwResult, NULL);

  00028	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hDriver
  0002e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00031	6a 00		 push	 0
  00033	8d 4c 24 08	 lea	 ecx, DWORD PTR _dwResult$[esp+12]
  00037	51		 push	 ecx
  00038	68 30 02 00 00	 push	 560			; 00000230H
  0003d	56		 push	 esi
  0003e	68 30 02 00 00	 push	 560			; 00000230H
  00043	56		 push	 esi
  00044	68 38 20 22 00	 push	 2236472			; 00222038H
  00049	52		 push	 edx
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  00050	5e		 pop	 esi

; 14   : }

  00051	59		 pop	 ecx
  00052	c3		 ret	 0
_GetDeviceInfo ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_GetDriveGeometry
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT _GetDriveGeometry
_TEXT	SEGMENT
_dwResult$ = -552					; size = 4
_dg$ = -548						; size = 544
__$ArrayPad$ = -4					; size = 4
_deviceName$ = 8					; size = 4
_diskGeometry$ = 12					; size = 4
_GetDriveGeometry PROC					; COMDAT

; 18   : {

  00000	81 ec 28 02 00
	00		 sub	 esp, 552		; 00000228H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 24 02
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+552], eax
  00014	56		 push	 esi
  00015	8b b4 24 34 02
	00 00		 mov	 esi, DWORD PTR _diskGeometry$[esp+552]
  0001c	57		 push	 edi
  0001d	8b bc 24 34 02
	00 00		 mov	 edi, DWORD PTR _deviceName$[esp+556]

; 19   : 	BOOL bResult;
; 20   : 	DWORD dwResult;
; 21   : 	DISK_GEOMETRY_STRUCT dg;
; 22   : 
; 23   : 	memset (&dg, 0, sizeof(dg));

  00024	68 20 02 00 00	 push	 544			; 00000220H
  00029	8d 44 24 10	 lea	 eax, DWORD PTR _dg$[esp+564]
  0002d	6a 00		 push	 0
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 _memset

; 24   : 	_snwprintf ((PWSTR) &dg.deviceName, ARRAY_LENGTH(dg.deviceName), L"%hs", deviceName);

  00035	57		 push	 edi
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs?$AA?$AA@
  0003b	8d 4c 24 20	 lea	 ecx, DWORD PTR _dg$[esp+580]
  0003f	68 04 01 00 00	 push	 260			; 00000104H
  00044	51		 push	 ecx
  00045	e8 00 00 00 00	 call	 __snwprintf
  0004a	83 c4 1c	 add	 esp, 28			; 0000001cH

; 25   : 
; 26   : 	bResult = DeviceIoControl (hDriver, TC_IOCTL_GET_DRIVE_GEOMETRY, &dg,
; 27   : 		sizeof (dg), &dg, sizeof (dg), &dwResult, NULL);

  0004d	6a 00		 push	 0
  0004f	8d 54 24 0c	 lea	 edx, DWORD PTR _dwResult$[esp+564]
  00053	52		 push	 edx
  00054	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hDriver
  0005a	68 20 02 00 00	 push	 544			; 00000220H
  0005f	8d 44 24 18	 lea	 eax, DWORD PTR _dg$[esp+572]
  00063	50		 push	 eax
  00064	68 20 02 00 00	 push	 544			; 00000220H
  00069	8b c8		 mov	 ecx, eax
  0006b	51		 push	 ecx
  0006c	68 3c 20 22 00	 push	 2236476			; 0022203cH
  00071	52		 push	 edx
  00072	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32

; 28   : 
; 29   : 	memcpy (diskGeometry, &dg.diskGeometry, sizeof (DISK_GEOMETRY));

  00078	8b 8c 24 14 02
	00 00		 mov	 ecx, DWORD PTR _dg$[esp+1080]
  0007f	8b 94 24 18 02
	00 00		 mov	 edx, DWORD PTR _dg$[esp+1084]
  00086	89 0e		 mov	 DWORD PTR [esi], ecx
  00088	8b 8c 24 1c 02
	00 00		 mov	 ecx, DWORD PTR _dg$[esp+1088]
  0008f	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00092	8b 94 24 20 02
	00 00		 mov	 edx, DWORD PTR _dg$[esp+1092]
  00099	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0009c	8b 8c 24 24 02
	00 00		 mov	 ecx, DWORD PTR _dg$[esp+1096]
  000a3	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  000a6	8b 94 24 28 02
	00 00		 mov	 edx, DWORD PTR _dg$[esp+1100]
  000ad	89 4e 10	 mov	 DWORD PTR [esi+16], ecx

; 30   : 	return bResult;
; 31   : }

  000b0	8b 8c 24 2c 02
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+560]
  000b7	5f		 pop	 edi
  000b8	89 56 14	 mov	 DWORD PTR [esi+20], edx
  000bb	5e		 pop	 esi
  000bc	33 cc		 xor	 ecx, esp
  000be	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c3	81 c4 28 02 00
	00		 add	 esp, 552		; 00000228H
  000c9	c3		 ret	 0
_GetDriveGeometry ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_GetDiskDeviceDriveLetter
EXTRN	_ResolveSymbolicLink:PROC
;	COMDAT ??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 00H, 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _GetDiskDeviceDriveLetter
_TEXT	SEGMENT
_drive$80979 = -1572					; size = 6
_link$ = -1564						; size = 520
_device$ = -1044					; size = 520
_target$ = -524						; size = 520
__$ArrayPad$ = -4					; size = 4
_deviceName$ = 8					; size = 4
_GetDiskDeviceDriveLetter PROC				; COMDAT

; 36   : {

  00000	81 ec 24 06 00
	00		 sub	 esp, 1572		; 00000624H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 20 06
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1572], eax
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	8b b4 24 30 06
	00 00		 mov	 esi, DWORD PTR _deviceName$[esp+1576]
  0001d	57		 push	 edi

; 37   : 	int i;
; 38   : 	WCHAR link[MAX_PATH];
; 39   : 	WCHAR target[MAX_PATH];
; 40   : 	WCHAR device[MAX_PATH];
; 41   : 
; 42   : 	if (!ResolveSymbolicLink (deviceName, device))

  0001e	8d 84 24 1c 02
	00 00		 lea	 eax, DWORD PTR _device$[esp+1584]
  00025	50		 push	 eax
  00026	56		 push	 esi
  00027	e8 00 00 00 00	 call	 _ResolveSymbolicLink
  0002c	83 c4 08	 add	 esp, 8
  0002f	85 c0		 test	 eax, eax
  00031	75 1c		 jne	 SHORT $LN5@GetDiskDev

; 43   : 		wcscpy (device, deviceName);

  00033	8d 94 24 1c 02
	00 00		 lea	 edx, DWORD PTR _device$[esp+1584]
  0003a	8b c6		 mov	 eax, esi
  0003c	2b d6		 sub	 edx, esi
  0003e	8b ff		 npad	 2
$LL8@GetDiskDev:
  00040	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00043	66 89 0c 02	 mov	 WORD PTR [edx+eax], cx
  00047	83 c0 02	 add	 eax, 2
  0004a	66 85 c9	 test	 cx, cx
  0004d	75 f1		 jne	 SHORT $LL8@GetDiskDev
$LN5@GetDiskDev:

; 44   : 
; 45   : 	for (i = 0; i < 26; i++)

  0004f	33 db		 xor	 ebx, ebx

; 46   : 	{
; 47   : 		WCHAR drive[] = { (WCHAR) i + 'A', ':', 0 };

  00051	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00056	33 d2		 xor	 edx, edx
  00058	66 89 4c 24 0e	 mov	 WORD PTR _drive$80979[esp+1586], cx
  0005d	66 89 54 24 10	 mov	 WORD PTR _drive$80979[esp+1588], dx
$LL4@GetDiskDev:
  00062	8d 43 41	 lea	 eax, DWORD PTR [ebx+65]
  00065	66 89 44 24 0c	 mov	 WORD PTR _drive$80979[esp+1584], ax

; 48   : 
; 49   : 		wcscpy (link, L"\\DosDevices\\");

  0006a	33 c0		 xor	 eax, eax
  0006c	8d 64 24 00	 npad	 4
$LL9@GetDiskDev:
  00070	0f b7 88 00 00
	00 00		 movzx	 ecx, WORD PTR ??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@[eax]
  00077	66 89 4c 04 14	 mov	 WORD PTR _link$[esp+eax+1584], cx
  0007c	83 c0 02	 add	 eax, 2
  0007f	66 85 c9	 test	 cx, cx
  00082	75 ec		 jne	 SHORT $LL9@GetDiskDev

; 50   : 		wcscat (link, drive);

  00084	8d 44 24 0c	 lea	 eax, DWORD PTR _drive$80979[esp+1584]
  00088	8b d0		 mov	 edx, eax
  0008a	8d 9b 00 00 00
	00		 npad	 6
$LL15@GetDiskDev:
  00090	66 8b 08	 mov	 cx, WORD PTR [eax]
  00093	83 c0 02	 add	 eax, 2
  00096	66 85 c9	 test	 cx, cx
  00099	75 f5		 jne	 SHORT $LL15@GetDiskDev
  0009b	8d 7c 24 14	 lea	 edi, DWORD PTR _link$[esp+1584]
  0009f	2b c2		 sub	 eax, edx
  000a1	83 c7 fe	 add	 edi, -2			; fffffffeH
$LL16@GetDiskDev:
  000a4	66 8b 4f 02	 mov	 cx, WORD PTR [edi+2]
  000a8	83 c7 02	 add	 edi, 2
  000ab	66 85 c9	 test	 cx, cx
  000ae	75 f4		 jne	 SHORT $LL16@GetDiskDev
  000b0	8b c8		 mov	 ecx, eax
  000b2	c1 e9 02	 shr	 ecx, 2
  000b5	8b f2		 mov	 esi, edx
  000b7	f3 a5		 rep movsd
  000b9	8b c8		 mov	 ecx, eax
  000bb	83 e1 03	 and	 ecx, 3
  000be	f3 a4		 rep movsb

; 51   : 
; 52   : 		ResolveSymbolicLink (link, target);

  000c0	8d 8c 24 24 04
	00 00		 lea	 ecx, DWORD PTR _target$[esp+1584]
  000c7	51		 push	 ecx
  000c8	8d 54 24 18	 lea	 edx, DWORD PTR _link$[esp+1588]
  000cc	52		 push	 edx
  000cd	e8 00 00 00 00	 call	 _ResolveSymbolicLink
  000d2	83 c4 08	 add	 esp, 8

; 53   : 
; 54   : 		if (wcscmp (device, target) == 0)

  000d5	8d 8c 24 24 04
	00 00		 lea	 ecx, DWORD PTR _target$[esp+1584]
  000dc	8d 84 24 1c 02
	00 00		 lea	 eax, DWORD PTR _device$[esp+1584]
$LL17@GetDiskDev:
  000e3	66 8b 10	 mov	 dx, WORD PTR [eax]
  000e6	66 3b 11	 cmp	 dx, WORD PTR [ecx]
  000e9	75 1e		 jne	 SHORT $LN18@GetDiskDev
  000eb	66 85 d2	 test	 dx, dx
  000ee	74 15		 je	 SHORT $LN19@GetDiskDev
  000f0	66 8b 50 02	 mov	 dx, WORD PTR [eax+2]
  000f4	66 3b 51 02	 cmp	 dx, WORD PTR [ecx+2]
  000f8	75 0f		 jne	 SHORT $LN18@GetDiskDev
  000fa	83 c0 04	 add	 eax, 4
  000fd	83 c1 04	 add	 ecx, 4
  00100	66 85 d2	 test	 dx, dx
  00103	75 de		 jne	 SHORT $LL17@GetDiskDev
$LN19@GetDiskDev:
  00105	33 c0		 xor	 eax, eax
  00107	eb 05		 jmp	 SHORT $LN20@GetDiskDev
$LN18@GetDiskDev:
  00109	1b c0		 sbb	 eax, eax
  0010b	83 d8 ff	 sbb	 eax, -1
$LN20@GetDiskDev:
  0010e	85 c0		 test	 eax, eax
  00110	74 25		 je	 SHORT $LN13@GetDiskDev
  00112	43		 inc	 ebx
  00113	83 fb 1a	 cmp	 ebx, 26			; 0000001aH
  00116	0f 8c 46 ff ff
	ff		 jl	 $LL4@GetDiskDev
  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi

; 55   : 			return i;
; 56   : 	}
; 57   : 
; 58   : 	return -1;

  0011e	83 c8 ff	 or	 eax, -1
  00121	5b		 pop	 ebx

; 59   : }

  00122	8b 8c 24 20 06
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1572]
  00129	33 cc		 xor	 ecx, esp
  0012b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00130	81 c4 24 06 00
	00		 add	 esp, 1572		; 00000624H
  00136	c3		 ret	 0
$LN13@GetDiskDev:
  00137	8b 8c 24 2c 06
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1584]
  0013e	5f		 pop	 edi
  0013f	5e		 pop	 esi
  00140	8b c3		 mov	 eax, ebx
  00142	5b		 pop	 ebx
  00143	33 cc		 xor	 ecx, esp
  00145	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014a	81 c4 24 06 00
	00		 add	 esp, 1572		; 00000624H
  00150	c3		 ret	 0
_GetDiskDeviceDriveLetter ENDP
_TEXT	ENDS
PUBLIC	_IsDiskReadError
; Function compile flags: /Ogtpy
;	COMDAT _IsDiskReadError
_TEXT	SEGMENT
_error$ = 8						; size = 4
_IsDiskReadError PROC					; COMDAT

; 63   : 	return (error == ERROR_CRC
; 64   : 		|| error == ERROR_IO_DEVICE
; 65   : 		|| error == ERROR_BAD_CLUSTERS
; 66   : 		|| error == ERROR_SECTOR_NOT_FOUND
; 67   : 		|| error == ERROR_READ_FAULT
; 68   : 		|| error == ERROR_INVALID_FUNCTION // I/O error may be reported as ERROR_INVALID_FUNCTION by buggy chipset drivers
; 69   : 		|| error == ERROR_SEM_TIMEOUT);	// I/O operation timeout may be reported as ERROR_SEM_TIMEOUT

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _error$[esp-4]
  00004	83 f8 17	 cmp	 eax, 23			; 00000017H
  00007	74 25		 je	 SHORT $LN3@IsDiskRead
  00009	3d 5d 04 00 00	 cmp	 eax, 1117		; 0000045dH
  0000e	74 1e		 je	 SHORT $LN3@IsDiskRead
  00010	3d c1 1a 00 00	 cmp	 eax, 6849		; 00001ac1H
  00015	74 17		 je	 SHORT $LN3@IsDiskRead
  00017	83 f8 1b	 cmp	 eax, 27			; 0000001bH
  0001a	74 12		 je	 SHORT $LN3@IsDiskRead
  0001c	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  0001f	74 0d		 je	 SHORT $LN3@IsDiskRead
  00021	83 f8 01	 cmp	 eax, 1
  00024	74 08		 je	 SHORT $LN3@IsDiskRead
  00026	83 f8 79	 cmp	 eax, 121		; 00000079H
  00029	74 03		 je	 SHORT $LN3@IsDiskRead
  0002b	33 c0		 xor	 eax, eax

; 70   : }

  0002d	c3		 ret	 0
$LN3@IsDiskRead:

; 63   : 	return (error == ERROR_CRC
; 64   : 		|| error == ERROR_IO_DEVICE
; 65   : 		|| error == ERROR_BAD_CLUSTERS
; 66   : 		|| error == ERROR_SECTOR_NOT_FOUND
; 67   : 		|| error == ERROR_READ_FAULT
; 68   : 		|| error == ERROR_INVALID_FUNCTION // I/O error may be reported as ERROR_INVALID_FUNCTION by buggy chipset drivers
; 69   : 		|| error == ERROR_SEM_TIMEOUT);	// I/O operation timeout may be reported as ERROR_SEM_TIMEOUT

  0002e	b8 01 00 00 00	 mov	 eax, 1

; 70   : }

  00033	c3		 ret	 0
_IsDiskReadError ENDP
_TEXT	ENDS
PUBLIC	_IsDiskWriteError
; Function compile flags: /Ogtpy
;	COMDAT _IsDiskWriteError
_TEXT	SEGMENT
_error$ = 8						; size = 4
_IsDiskWriteError PROC					; COMDAT

; 75   : 	return (error == ERROR_IO_DEVICE
; 76   : 		|| error == ERROR_BAD_CLUSTERS
; 77   : 		|| error == ERROR_SECTOR_NOT_FOUND
; 78   : 		|| error == ERROR_WRITE_FAULT
; 79   : 		|| error == ERROR_INVALID_FUNCTION // I/O error may be reported as ERROR_INVALID_FUNCTION by buggy chipset drivers
; 80   : 		|| error == ERROR_SEM_TIMEOUT);	// I/O operation timeout may be reported as ERROR_SEM_TIMEOUT

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _error$[esp-4]
  00004	3d 5d 04 00 00	 cmp	 eax, 1117		; 0000045dH
  00009	74 1e		 je	 SHORT $LN3@IsDiskWrit
  0000b	3d c1 1a 00 00	 cmp	 eax, 6849		; 00001ac1H
  00010	74 17		 je	 SHORT $LN3@IsDiskWrit
  00012	83 f8 1b	 cmp	 eax, 27			; 0000001bH
  00015	74 12		 je	 SHORT $LN3@IsDiskWrit
  00017	83 f8 1d	 cmp	 eax, 29			; 0000001dH
  0001a	74 0d		 je	 SHORT $LN3@IsDiskWrit
  0001c	83 f8 01	 cmp	 eax, 1
  0001f	74 08		 je	 SHORT $LN3@IsDiskWrit
  00021	83 f8 79	 cmp	 eax, 121		; 00000079H
  00024	74 03		 je	 SHORT $LN3@IsDiskWrit
  00026	33 c0		 xor	 eax, eax

; 81   : }

  00028	c3		 ret	 0
$LN3@IsDiskWrit:

; 75   : 	return (error == ERROR_IO_DEVICE
; 76   : 		|| error == ERROR_BAD_CLUSTERS
; 77   : 		|| error == ERROR_SECTOR_NOT_FOUND
; 78   : 		|| error == ERROR_WRITE_FAULT
; 79   : 		|| error == ERROR_INVALID_FUNCTION // I/O error may be reported as ERROR_INVALID_FUNCTION by buggy chipset drivers
; 80   : 		|| error == ERROR_SEM_TIMEOUT);	// I/O operation timeout may be reported as ERROR_SEM_TIMEOUT

  00029	b8 01 00 00 00	 mov	 eax, 1

; 81   : }

  0002e	c3		 ret	 0
_IsDiskWriteError ENDP
_TEXT	ENDS
PUBLIC	_IsDiskError
; Function compile flags: /Ogtpy
;	COMDAT _IsDiskError
_TEXT	SEGMENT
_error$ = 8						; size = 4
_IsDiskError PROC					; COMDAT

; 86   : 	return IsDiskReadError (error) || IsDiskWriteError (error);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _error$[esp-4]
  00004	83 f8 17	 cmp	 eax, 23			; 00000017H
  00007	74 2a		 je	 SHORT $LN3@IsDiskErro
  00009	3d 5d 04 00 00	 cmp	 eax, 1117		; 0000045dH
  0000e	74 23		 je	 SHORT $LN3@IsDiskErro
  00010	3d c1 1a 00 00	 cmp	 eax, 6849		; 00001ac1H
  00015	74 1c		 je	 SHORT $LN3@IsDiskErro
  00017	83 f8 1b	 cmp	 eax, 27			; 0000001bH
  0001a	74 17		 je	 SHORT $LN3@IsDiskErro
  0001c	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  0001f	74 12		 je	 SHORT $LN3@IsDiskErro
  00021	83 f8 01	 cmp	 eax, 1
  00024	74 0d		 je	 SHORT $LN3@IsDiskErro
  00026	83 f8 79	 cmp	 eax, 121		; 00000079H
  00029	74 08		 je	 SHORT $LN3@IsDiskErro
  0002b	83 f8 1d	 cmp	 eax, 29			; 0000001dH
  0002e	74 03		 je	 SHORT $LN3@IsDiskErro
  00030	33 c0		 xor	 eax, eax

; 87   : }

  00032	c3		 ret	 0
$LN3@IsDiskErro:

; 86   : 	return IsDiskReadError (error) || IsDiskWriteError (error);

  00033	b8 01 00 00 00	 mov	 eax, 1

; 87   : }

  00038	c3		 ret	 0
_IsDiskError ENDP
_TEXT	ENDS
END
