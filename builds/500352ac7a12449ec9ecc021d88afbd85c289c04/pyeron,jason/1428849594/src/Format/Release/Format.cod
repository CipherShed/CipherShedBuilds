; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\home\public\Desktop\projects\ciphershed.build\src\Common\Format.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_FormatWriteBufferSize
_DATA	SEGMENT
COMM	_FormatExResult:BYTE
_DATA	ENDS
_BSS	SEGMENT
_FormatSectorSize DD 01H DUP (?)
?updateTime@?1??WriteSector@@9@9 DD 01H DUP (?)		; `WriteSector'::`2'::updateTime
_BSS	ENDS
_DATA	SEGMENT
_FormatWriteBufferSize DD 0100000H
_DATA	ENDS
PUBLIC	_RtlSecureZeroMemory
; Function compile flags: /Ogtpy
; File c:\program files\microsoft sdks\windows\v7.1\include\winnt.h
;	COMDAT _RtlSecureZeroMemory
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory PROC				; COMDAT

; 13070:     volatile char *vptr = (volatile char *)ptr;
; 13071: 
; 13072: #if defined(_M_AMD64)
; 13073: 
; 13074:         __stosb((PBYTE )((DWORD64)vptr), 0, cnt);
; 13075: 
; 13076: #else
; 13077: 
; 13078:     while (cnt) {

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _cnt$[esp-4]
  00004	8b 44 24 04	 mov	 eax, DWORD PTR _ptr$[esp-4]
  00008	8b c8		 mov	 ecx, eax
  0000a	85 d2		 test	 edx, edx
  0000c	74 0b		 je	 SHORT $LN1@RtlSecureZ
  0000e	8b ff		 npad	 2
$LL2@RtlSecureZ:

; 13079:         *vptr = 0;

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 13080:         vptr++;

  00013	41		 inc	 ecx

; 13081:         cnt--;

  00014	83 ea 01	 sub	 edx, 1
  00017	75 f7		 jne	 SHORT $LL2@RtlSecureZ
$LN1@RtlSecureZ:

; 13082:     }
; 13083: 
; 13084: #endif
; 13085: 
; 13086:     return ptr;
; 13087: }

  00019	c3		 ret	 0
_RtlSecureZeroMemory ENDP
_TEXT	ENDS
PUBLIC	_GetVolumeDataAreaSize
; Function compile flags: /Ogtpy
; File c:\home\public\desktop\projects\ciphershed.build\src\common\format.c
;	COMDAT _GetVolumeDataAreaSize
_TEXT	SEGMENT
_hiddenVolume$ = 8					; size = 4
_volumeSize$ = 12					; size = 8
_GetVolumeDataAreaSize PROC				; COMDAT

; 38   : 	uint64 reservedSize;
; 39   : 
; 40   : 	if (hiddenVolume)

  00000	83 7c 24 04 00	 cmp	 DWORD PTR _hiddenVolume$[esp-4], 0
  00005	8b 54 24 0c	 mov	 edx, DWORD PTR _volumeSize$[esp]
  00009	8b 44 24 08	 mov	 eax, DWORD PTR _volumeSize$[esp-4]
  0000d	56		 push	 esi
  0000e	74 1b		 je	 SHORT $LN5@GetVolumeD

; 41   : 	{
; 42   : 		// Reserve free space at the end of the host filesystem. FAT file system fills the last sector with
; 43   : 		// zeroes (marked as free; observed when quick format was performed using the OS format tool).
; 44   : 		// Therefore, when the outer volume is mounted with hidden volume protection, such write operations
; 45   : 		// (e.g. quick formatting the outer volume filesystem as FAT) would needlessly trigger hidden volume
; 46   : 		// protection.
; 47   : 
; 48   : #if TC_HIDDEN_VOLUME_HOST_FS_RESERVED_END_AREA_SIZE > 4096
; 49   : #	error	TC_HIDDEN_VOLUME_HOST_FS_RESERVED_END_AREA_SIZE too large for very small volumes. Revise the code.
; 50   : #endif
; 51   : 
; 52   : #if TC_HIDDEN_VOLUME_HOST_FS_RESERVED_END_AREA_SIZE_HIGH < TC_MAX_VOLUME_SECTOR_SIZE
; 53   : #	error	TC_HIDDEN_VOLUME_HOST_FS_RESERVED_END_AREA_SIZE_HIGH too small.
; 54   : #endif
; 55   : 		
; 56   : 		if (volumeSize < TC_VOLUME_SMALL_SIZE_THRESHOLD)

  00010	85 d2		 test	 edx, edx
  00012	77 10		 ja	 SHORT $LN4@GetVolumeD
  00014	72 07		 jb	 SHORT $LN8@GetVolumeD
  00016	3d 00 00 20 00	 cmp	 eax, 2097152		; 00200000H
  0001b	73 07		 jae	 SHORT $LN4@GetVolumeD
$LN8@GetVolumeD:

; 57   : 			reservedSize = TC_HIDDEN_VOLUME_HOST_FS_RESERVED_END_AREA_SIZE;

  0001d	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H

; 58   : 		else

  00022	eb 0c		 jmp	 SHORT $LN10@GetVolumeD
$LN4@GetVolumeD:

; 59   : 			reservedSize = TC_HIDDEN_VOLUME_HOST_FS_RESERVED_END_AREA_SIZE_HIGH; // Ensure size of a hidden volume larger than TC_VOLUME_SMALL_SIZE_THRESHOLD is a multiple of the maximum supported sector size

  00024	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H

; 60   : 	}
; 61   : 	else

  00029	eb 05		 jmp	 SHORT $LN10@GetVolumeD
$LN5@GetVolumeD:

; 62   : 	{
; 63   : 		reservedSize = TC_TOTAL_VOLUME_HEADERS_SIZE;

  0002b	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
$LN10@GetVolumeD:
  00030	33 f6		 xor	 esi, esi

; 64   : 	}
; 65   : 
; 66   : 	if (volumeSize < reservedSize)

  00032	3b d6		 cmp	 edx, esi
  00034	77 0c		 ja	 SHORT $LN1@GetVolumeD
  00036	72 04		 jb	 SHORT $LN9@GetVolumeD
  00038	3b c1		 cmp	 eax, ecx
  0003a	73 06		 jae	 SHORT $LN1@GetVolumeD
$LN9@GetVolumeD:

; 67   : 		return 0;

  0003c	33 c0		 xor	 eax, eax
  0003e	33 d2		 xor	 edx, edx
  00040	5e		 pop	 esi

; 70   : }

  00041	c3		 ret	 0
$LN1@GetVolumeD:

; 68   : 
; 69   : 	return volumeSize - reservedSize;

  00042	2b c1		 sub	 eax, ecx
  00044	1b d6		 sbb	 edx, esi
  00046	5e		 pop	 esi

; 70   : }

  00047	c3		 ret	 0
_GetVolumeDataAreaSize ENDP
_TEXT	ENDS
PUBLIC	_FormatExCallback@12
; Function compile flags: /Ogtpy
;	COMDAT _FormatExCallback@12
_TEXT	SEGMENT
_command$ = 8						; size = 4
_subCommand$ = 12					; size = 4
_parameter$ = 16					; size = 4
_FormatExCallback@12 PROC				; COMDAT

; 791  : 	if (command == FMIFS_DONE)

  00000	83 7c 24 04 0b	 cmp	 DWORD PTR _command$[esp-4], 11 ; 0000000bH
  00005	75 0c		 jne	 SHORT $LN4@FormatExCa

; 792  : 		FormatExResult = *(BOOLEAN *) parameter;

  00007	8b 44 24 0c	 mov	 eax, DWORD PTR _parameter$[esp-4]
  0000b	8a 08		 mov	 cl, BYTE PTR [eax]
  0000d	88 0d 00 00 00
	00		 mov	 BYTE PTR _FormatExResult, cl
$LN4@FormatExCa:

; 793  : 	return TRUE;

  00013	b0 01		 mov	 al, 1

; 794  : }

  00015	c2 0c 00	 ret	 12			; 0000000cH
_FormatExCallback@12 ENDP
_TEXT	ENDS
PUBLIC	??_C@_19ENNDBEJL@?$AAN?$AAT?$AAF?$AAS?$AA?$AA@	; `string'
PUBLIC	??_C@_11LOCGONAA@?$AA?$AA@			; `string'
PUBLIC	??_C@_15GKAHMKIN@?$AA?3?$AA?2?$AA?$AA@		; `string'
PUBLIC	??_C@_08KDJACLKO@FormatEx?$AA@			; `string'
PUBLIC	??_C@_09IFOENPLD@fmifs?4dll?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_FormatNtfs
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__GetModuleHandleA@4:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_19ENNDBEJL@?$AAN?$AAT?$AAF?$AAS?$AA?$AA@
CONST	SEGMENT
??_C@_19ENNDBEJL@?$AAN?$AAT?$AAF?$AAS?$AA?$AA@ DB 'N', 00H, 'T', 00H, 'F', 00H
	DB	'S', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@?$AA?$AA@
CONST	SEGMENT
??_C@_11LOCGONAA@?$AA?$AA@ DB 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_15GKAHMKIN@?$AA?3?$AA?2?$AA?$AA@
CONST	SEGMENT
??_C@_15GKAHMKIN@?$AA?3?$AA?2?$AA?$AA@ DB ':', 00H, '\', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08KDJACLKO@FormatEx?$AA@
CONST	SEGMENT
??_C@_08KDJACLKO@FormatEx?$AA@ DB 'FormatEx', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09IFOENPLD@fmifs?4dll?$AA@
CONST	SEGMENT
??_C@_09IFOENPLD@fmifs?4dll?$AA@ DB 'fmifs.dll', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _FormatNtfs
_TEXT	SEGMENT
_dir$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_driveNo$ = 8						; size = 4
_clusterSize$ = 12					; size = 4
_FormatNtfs PROC					; COMDAT

; 797  : {

  00000	83 ec 14	 sub	 esp, 20			; 00000014H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 10	 mov	 DWORD PTR __$ArrayPad$[esp+20], eax

; 798  : 	WCHAR dir[8] = { (WCHAR) driveNo + 'A', 0 };

  0000e	8b 44 24 18	 mov	 eax, DWORD PTR _driveNo$[esp+16]
  00012	83 c0 41	 add	 eax, 65			; 00000041H
  00015	55		 push	 ebp
  00016	66 89 44 24 04	 mov	 WORD PTR _dir$[esp+24], ax
  0001b	33 c0		 xor	 eax, eax
  0001d	33 c9		 xor	 ecx, ecx

; 799  : 	PFORMATEX FormatEx;
; 800  : 	HMODULE hModule = LoadLibrary ("fmifs.dll");

  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_09IFOENPLD@fmifs?4dll?$AA@
  00024	66 89 4c 24 0a	 mov	 WORD PTR _dir$[esp+30], cx
  00029	89 44 24 0c	 mov	 DWORD PTR _dir$[esp+32], eax
  0002d	89 44 24 10	 mov	 DWORD PTR _dir$[esp+36], eax
  00031	89 44 24 14	 mov	 DWORD PTR _dir$[esp+40], eax
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  0003b	8b e8		 mov	 ebp, eax

; 801  : 	int i;
; 802  : 
; 803  : 	if (hModule == NULL)

  0003d	85 ed		 test	 ebp, ebp
  0003f	75 10		 jne	 SHORT $LN5@FormatNtfs
  00041	5d		 pop	 ebp

; 828  : }

  00042	8b 4c 24 10	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+20]
  00046	33 cc		 xor	 ecx, esp
  00048	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004d	83 c4 14	 add	 esp, 20			; 00000014H
  00050	c3		 ret	 0
$LN5@FormatNtfs:
  00051	53		 push	 ebx

; 804  : 		return FALSE;
; 805  : 
; 806  : 	if (!(FormatEx = (PFORMATEX) GetProcAddress (GetModuleHandle ("fmifs.dll"), "FormatEx")))

  00052	68 00 00 00 00	 push	 OFFSET ??_C@_08KDJACLKO@FormatEx?$AA@
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_09IFOENPLD@fmifs?4dll?$AA@
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  00062	50		 push	 eax
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00069	8b d8		 mov	 ebx, eax
  0006b	85 db		 test	 ebx, ebx
  0006d	75 1a		 jne	 SHORT $LN4@FormatNtfs

; 807  : 	{
; 808  : 		FreeLibrary (hModule);

  0006f	55		 push	 ebp
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4
  00076	5b		 pop	 ebx

; 809  : 		return FALSE;

  00077	33 c0		 xor	 eax, eax
  00079	5d		 pop	 ebp

; 828  : }

  0007a	8b 4c 24 10	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+20]
  0007e	33 cc		 xor	 ecx, esp
  00080	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00085	83 c4 14	 add	 esp, 20			; 00000014H
  00088	c3		 ret	 0
$LN4@FormatNtfs:

; 810  : 	}
; 811  : 
; 812  : 	wcscat (dir, L":\\");

  00089	8d 44 24 08	 lea	 eax, DWORD PTR _dir$[esp+28]
  0008d	83 c0 fe	 add	 eax, -2			; fffffffeH
$LL10@FormatNtfs:
  00090	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  00094	83 c0 02	 add	 eax, 2
  00097	66 85 c9	 test	 cx, cx
  0009a	75 f4		 jne	 SHORT $LL10@FormatNtfs
  0009c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ??_C@_15GKAHMKIN@?$AA?3?$AA?2?$AA?$AA@
  000a2	66 8b 0d 04 00
	00 00		 mov	 cx, WORD PTR ??_C@_15GKAHMKIN@?$AA?3?$AA?2?$AA?$AA@+4
  000a9	56		 push	 esi
  000aa	89 10		 mov	 DWORD PTR [eax], edx
  000ac	57		 push	 edi

; 813  : 
; 814  : 	FormatExResult = FALSE;
; 815  : 
; 816  : 	// Windows sometimes fails to format a volume (hosted on a removable medium) as NTFS.
; 817  : 	// It often helps to retry several times.
; 818  : 	for (i = 0; i < 50 && FormatExResult != TRUE; i++)

  000ad	8b 7c 24 2c	 mov	 edi, DWORD PTR _clusterSize$[esp+32]
  000b1	66 89 48 04	 mov	 WORD PTR [eax+4], cx
  000b5	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _FormatExResult, 0
  000bc	33 f6		 xor	 esi, esi
  000be	8b ff		 npad	 2
$LL3@FormatNtfs:
  000c0	8a 15 00 00 00
	00		 mov	 dl, BYTE PTR _FormatExResult
  000c6	80 fa 01	 cmp	 dl, 1
  000c9	74 29		 je	 SHORT $LN1@FormatNtfs

; 819  : 	{
; 820  : 		FormatEx (dir, FMIFS_HARDDISK, L"NTFS", L"", TRUE, clusterSize * FormatSectorSize, FormatExCallback);

  000cb	a1 00 00 00 00	 mov	 eax, DWORD PTR _FormatSectorSize
  000d0	0f af c7	 imul	 eax, edi
  000d3	68 00 00 00 00	 push	 OFFSET _FormatExCallback@12
  000d8	50		 push	 eax
  000d9	6a 01		 push	 1
  000db	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@?$AA?$AA@
  000e0	68 00 00 00 00	 push	 OFFSET ??_C@_19ENNDBEJL@?$AAN?$AAT?$AAF?$AAS?$AA?$AA@
  000e5	6a 0c		 push	 12			; 0000000cH
  000e7	8d 4c 24 28	 lea	 ecx, DWORD PTR _dir$[esp+60]
  000eb	51		 push	 ecx
  000ec	ff d3		 call	 ebx
  000ee	46		 inc	 esi
  000ef	83 fe 32	 cmp	 esi, 50			; 00000032H
  000f2	7c cc		 jl	 SHORT $LL3@FormatNtfs
$LN1@FormatNtfs:

; 821  : 	}
; 822  : 
; 823  : 	// The device may be referenced for some time after FormatEx() returns
; 824  : 	Sleep (2000);

  000f4	68 d0 07 00 00	 push	 2000			; 000007d0H
  000f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 825  : 
; 826  : 	FreeLibrary (hModule);

  000ff	55		 push	 ebp
  00100	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4

; 827  : 	return FormatExResult;

  00106	8a 15 00 00 00
	00		 mov	 dl, BYTE PTR _FormatExResult

; 828  : }

  0010c	8b 4c 24 20	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+36]
  00110	5f		 pop	 edi
  00111	5e		 pop	 esi
  00112	5b		 pop	 ebx
  00113	5d		 pop	 ebp
  00114	33 cc		 xor	 ecx, esp
  00116	0f b6 c2	 movzx	 eax, dl
  00119	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011e	83 c4 14	 add	 esp, 20			; 00000014H
  00121	c3		 ret	 0
_FormatNtfs ENDP
_TEXT	ENDS
EXTRN	__endthread:PROC
EXTRN	_handleWin32Error:PROC
EXTRN	__imp__WriteFile@20:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__SetEvent@4:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__SetThreadPriority@8:PROC
EXTRN	__imp__GetCurrentThread@0:PROC
_BSS	SEGMENT
_WriteThreadRunning DD 01H DUP (?)
_WriteBufferEmptyEvent DD 01H DUP (?)
_WriteRequestResult DD 01H DUP (?)
_WriteRequestHandle DD 01H DUP (?)
_WriteThreadBuffer DD 01H DUP (?)
_WriteRequestSize DD 01H DUP (?)
_WriteBufferFullEvent DD 01H DUP (?)
_WriteThreadExitRequested DD 01H DUP (?)
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _FormatWriteThreadProc
_TEXT	SEGMENT
_bytesWritten$ = -4					; size = 4
_arg$ = 8						; size = 4
_FormatWriteThreadProc PROC				; COMDAT

; 872  : {

  00000	51		 push	 ecx

; 873  : 	DWORD bytesWritten;
; 874  : 
; 875  : 	SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_HIGHEST);

  00001	6a 02		 push	 2
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThread@0
  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetThreadPriority@8

; 876  : 
; 877  : 	while (!WriteThreadExitRequested)

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR _WriteThreadExitRequested
  00015	85 c0		 test	 eax, eax
  00017	0f 85 97 00 00
	00		 jne	 $LN14@FormatWrit
  0001d	53		 push	 ebx
  0001e	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetLastError@0
  00024	55		 push	 ebp
  00025	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__SetEvent@4
  0002b	56		 push	 esi
  0002c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__WaitForSingleObject@8
  00032	57		 push	 edi
  00033	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__WriteFile@20
  00039	8d a4 24 00 00
	00 00		 npad	 7
$LL7@FormatWrit:

; 878  : 	{
; 879  : 		if (WaitForSingleObject (WriteBufferFullEvent, INFINITE) == WAIT_FAILED)

  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WriteBufferFullEvent
  00046	6a ff		 push	 -1
  00048	51		 push	 ecx
  00049	ff d6		 call	 esi
  0004b	83 f8 ff	 cmp	 eax, -1
  0004e	74 56		 je	 SHORT $LN13@FormatWrit

; 880  : 		{
; 881  : 			handleWin32Error (NULL);
; 882  : 			break;
; 883  : 		}
; 884  : 
; 885  : 		if (WriteThreadExitRequested)

  00050	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WriteThreadExitRequested
  00056	85 d2		 test	 edx, edx
  00058	75 56		 jne	 SHORT $LN15@FormatWrit

; 886  : 			break;
; 887  : 
; 888  : 		if (!WriteFile (WriteRequestHandle, WriteThreadBuffer, WriteRequestSize, &bytesWritten, NULL))

  0005a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WriteRequestSize
  00060	52		 push	 edx
  00061	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WriteThreadBuffer
  00067	8d 44 24 14	 lea	 eax, DWORD PTR _bytesWritten$[esp+24]
  0006b	50		 push	 eax
  0006c	a1 00 00 00 00	 mov	 eax, DWORD PTR _WriteRequestHandle
  00071	51		 push	 ecx
  00072	52		 push	 edx
  00073	50		 push	 eax
  00074	ff d7		 call	 edi
  00076	85 c0		 test	 eax, eax
  00078	75 09		 jne	 SHORT $LN3@FormatWrit

; 889  : 			WriteRequestResult = GetLastError();

  0007a	ff d3		 call	 ebx
  0007c	a3 00 00 00 00	 mov	 DWORD PTR _WriteRequestResult, eax

; 890  : 		else		

  00081	eb 0a		 jmp	 SHORT $LN2@FormatWrit
$LN3@FormatWrit:

; 891  : 			WriteRequestResult = ERROR_SUCCESS;

  00083	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _WriteRequestResult, 0
$LN2@FormatWrit:

; 892  : 
; 893  : 		if (!SetEvent (WriteBufferEmptyEvent))

  0008d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WriteBufferEmptyEvent
  00093	51		 push	 ecx
  00094	ff d5		 call	 ebp
  00096	85 c0		 test	 eax, eax
  00098	74 0c		 je	 SHORT $LN13@FormatWrit
  0009a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WriteThreadExitRequested
  000a0	85 d2		 test	 edx, edx
  000a2	74 9c		 je	 SHORT $LL7@FormatWrit
  000a4	eb 0a		 jmp	 SHORT $LN15@FormatWrit
$LN13@FormatWrit:

; 894  : 		{
; 895  : 			handleWin32Error (NULL);

  000a6	6a 00		 push	 0
  000a8	e8 00 00 00 00	 call	 _handleWin32Error
  000ad	83 c4 04	 add	 esp, 4
$LN15@FormatWrit:
  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	5d		 pop	 ebp
  000b3	5b		 pop	 ebx
$LN14@FormatWrit:

; 896  : 			break;
; 897  : 		}
; 898  : 	}
; 899  : 
; 900  : 	WriteThreadRunning = FALSE;

  000b4	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _WriteThreadRunning, 0

; 901  : 	_endthread();

  000be	e8 00 00 00 00	 call	 __endthread

; 902  : }

  000c3	59		 pop	 ecx
  000c4	c3		 ret	 0
_FormatWriteThreadProc ENDP
_TEXT	ENDS
EXTRN	_free:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__beginthread:PROC
EXTRN	_malloc:PROC
EXTRN	__imp__SetLastError@4:PROC
EXTRN	__imp__CreateEventA@16:PROC
_BSS	SEGMENT
_WriteThreadHandle DD 01H DUP (?)
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _StartFormatWriteThread
_TEXT	SEGMENT
_StartFormatWriteThread PROC				; COMDAT

; 906  : {

  00000	55		 push	 ebp
  00001	56		 push	 esi

; 907  : 	DWORD sysErr;
; 908  : 
; 909  : 	WriteBufferEmptyEvent = NULL;
; 910  : 	WriteBufferFullEvent = NULL;
; 911  : 	WriteThreadBuffer = NULL;
; 912  : 
; 913  : 	WriteBufferEmptyEvent = CreateEvent (NULL, FALSE, TRUE, NULL);

  00002	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CreateEventA@16
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	57		 push	 edi
  0000c	6a 01		 push	 1
  0000e	57		 push	 edi
  0000f	57		 push	 edi
  00010	89 3d 00 00 00
	00		 mov	 DWORD PTR _WriteBufferEmptyEvent, edi
  00016	89 3d 00 00 00
	00		 mov	 DWORD PTR _WriteBufferFullEvent, edi
  0001c	89 3d 00 00 00
	00		 mov	 DWORD PTR _WriteThreadBuffer, edi
  00022	ff d6		 call	 esi

; 914  : 	if (!WriteBufferEmptyEvent)

  00024	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__SetLastError@4
  0002a	a3 00 00 00 00	 mov	 DWORD PTR _WriteBufferEmptyEvent, eax
  0002f	3b c7		 cmp	 eax, edi
  00031	74 51		 je	 SHORT $err$80887

; 915  : 		goto err;
; 916  : 
; 917  : 	WriteBufferFullEvent = CreateEvent (NULL, FALSE, FALSE, NULL);

  00033	57		 push	 edi
  00034	57		 push	 edi
  00035	57		 push	 edi
  00036	57		 push	 edi
  00037	ff d6		 call	 esi
  00039	a3 00 00 00 00	 mov	 DWORD PTR _WriteBufferFullEvent, eax

; 918  : 	if (!WriteBufferFullEvent)

  0003e	3b c7		 cmp	 eax, edi
  00040	74 42		 je	 SHORT $err$80887

; 919  : 		goto err;
; 920  : 
; 921  : 	WriteThreadBuffer = TCalloc (FormatWriteBufferSize);

  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR _FormatWriteBufferSize
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _malloc
  0004d	83 c4 04	 add	 esp, 4
  00050	a3 00 00 00 00	 mov	 DWORD PTR _WriteThreadBuffer, eax

; 922  : 	if (!WriteThreadBuffer)

  00055	3b c7		 cmp	 eax, edi
  00057	75 06		 jne	 SHORT $LN5@StartForma

; 923  : 	{
; 924  : 		SetLastError (ERROR_OUTOFMEMORY);

  00059	6a 0e		 push	 14			; 0000000eH
  0005b	ff d5		 call	 ebp

; 925  : 		goto err;

  0005d	eb 25		 jmp	 SHORT $err$80887
$LN5@StartForma:

; 926  : 	}
; 927  : 
; 928  : 	WriteThreadExitRequested = FALSE;
; 929  : 	WriteRequestResult = ERROR_SUCCESS;
; 930  : 
; 931  : 	WriteThreadHandle = (HANDLE) _beginthread (FormatWriteThreadProc, 0, NULL);

  0005f	57		 push	 edi
  00060	57		 push	 edi
  00061	89 3d 00 00 00
	00		 mov	 DWORD PTR _WriteThreadExitRequested, edi
  00067	68 00 00 00 00	 push	 OFFSET _FormatWriteThreadProc
  0006c	89 3d 00 00 00
	00		 mov	 DWORD PTR _WriteRequestResult, edi
  00072	e8 00 00 00 00	 call	 __beginthread
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007a	a3 00 00 00 00	 mov	 DWORD PTR _WriteThreadHandle, eax

; 932  : 	if ((uintptr_t) WriteThreadHandle == -1L)

  0007f	83 f8 ff	 cmp	 eax, -1
  00082	75 43		 jne	 SHORT $LN4@StartForma
$err$80887:
  00084	53		 push	 ebx

; 937  : 
; 938  : err:
; 939  : 	sysErr = GetLastError();

  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 940  : 
; 941  : 	if (WriteBufferEmptyEvent)

  0008b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CloseHandle@4
  00091	8b d8		 mov	 ebx, eax
  00093	a1 00 00 00 00	 mov	 eax, DWORD PTR _WriteBufferEmptyEvent
  00098	3b c7		 cmp	 eax, edi
  0009a	74 03		 je	 SHORT $LN3@StartForma

; 942  : 		CloseHandle (WriteBufferEmptyEvent);

  0009c	50		 push	 eax
  0009d	ff d6		 call	 esi
$LN3@StartForma:

; 943  : 	if (WriteBufferFullEvent)

  0009f	a1 00 00 00 00	 mov	 eax, DWORD PTR _WriteBufferFullEvent
  000a4	3b c7		 cmp	 eax, edi
  000a6	74 03		 je	 SHORT $LN2@StartForma

; 944  : 		CloseHandle (WriteBufferFullEvent);

  000a8	50		 push	 eax
  000a9	ff d6		 call	 esi
$LN2@StartForma:

; 945  : 	if (WriteThreadBuffer)

  000ab	a1 00 00 00 00	 mov	 eax, DWORD PTR _WriteThreadBuffer
  000b0	3b c7		 cmp	 eax, edi
  000b2	74 09		 je	 SHORT $LN1@StartForma

; 946  : 		TCfree (WriteThreadBuffer);

  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 _free
  000ba	83 c4 04	 add	 esp, 4
$LN1@StartForma:

; 947  : 
; 948  : 	SetLastError (sysErr);

  000bd	53		 push	 ebx
  000be	ff d5		 call	 ebp
  000c0	5b		 pop	 ebx
  000c1	5f		 pop	 edi
  000c2	5e		 pop	 esi

; 949  : 	return FALSE;

  000c3	33 c0		 xor	 eax, eax
  000c5	5d		 pop	 ebp

; 950  : }

  000c6	c3		 ret	 0
$LN4@StartForma:
  000c7	5f		 pop	 edi
  000c8	5e		 pop	 esi

; 933  : 		goto err;
; 934  : 
; 935  : 	WriteThreadRunning = TRUE;

  000c9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _WriteThreadRunning, 1

; 936  : 	return TRUE;

  000d3	b8 01 00 00 00	 mov	 eax, 1
  000d8	5d		 pop	 ebp

; 950  : }

  000d9	c3		 ret	 0
_StartFormatWriteThread ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _StopFormatWriteThread
_TEXT	SEGMENT
_StopFormatWriteThread PROC				; COMDAT

; 955  : 	if (WriteThreadRunning)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _WriteThreadRunning
  00005	56		 push	 esi
  00006	85 c0		 test	 eax, eax
  00008	74 32		 je	 SHORT $LN1@StopFormat

; 956  : 	{
; 957  : 		WaitForSingleObject (WriteBufferEmptyEvent, INFINITE);

  0000a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WriteBufferEmptyEvent
  00010	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__WaitForSingleObject@8
  00016	6a ff		 push	 -1
  00018	51		 push	 ecx
  00019	ff d6		 call	 esi

; 958  : 
; 959  : 		WriteThreadExitRequested = TRUE;
; 960  : 		SetEvent (WriteBufferFullEvent);

  0001b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WriteBufferFullEvent
  00021	52		 push	 edx
  00022	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _WriteThreadExitRequested, 1
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 961  : 
; 962  : 		WaitForSingleObject (WriteThreadHandle, INFINITE);

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR _WriteThreadHandle
  00037	6a ff		 push	 -1
  00039	50		 push	 eax
  0003a	ff d6		 call	 esi
$LN1@StopFormat:

; 963  : 	}
; 964  : 
; 965  : 	CloseHandle (WriteBufferEmptyEvent);

  0003c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WriteBufferEmptyEvent
  00042	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CloseHandle@4
  00048	51		 push	 ecx
  00049	ff d6		 call	 esi

; 966  : 	CloseHandle (WriteBufferFullEvent);

  0004b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WriteBufferFullEvent
  00051	52		 push	 edx
  00052	ff d6		 call	 esi

; 967  : 	TCfree (WriteThreadBuffer);

  00054	a1 00 00 00 00	 mov	 eax, DWORD PTR _WriteThreadBuffer
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 _free
  0005f	83 c4 04	 add	 esp, 4
  00062	5e		 pop	 esi

; 968  : }

  00063	c3		 ret	 0
_StopFormatWriteThread ENDP
_TEXT	ENDS
PUBLIC	_FlushFormatWriteBuffer
EXTRN	_EncryptDataUnits:PROC
EXTRN	_memcpy:PROC
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
; Function compile flags: /Ogtpy
;	COMDAT _FlushFormatWriteBuffer
_TEXT	SEGMENT
_unitNo$ = -8						; size = 8
_dev$ = 8						; size = 4
_write_buf$ = 12					; size = 4
_bytesWritten$ = 16					; size = 4
_write_buf_cnt$ = 16					; size = 4
_nSecNo$ = 20						; size = 4
_cryptoInfo$ = 24					; size = 4
_FlushFormatWriteBuffer PROC				; COMDAT

; 972  : {

  00000	83 ec 08	 sub	 esp, 8
  00003	56		 push	 esi
  00004	57		 push	 edi

; 973  : 	UINT64_STRUCT unitNo;
; 974  : 	DWORD bytesWritten;
; 975  : 
; 976  : 	if (*write_buf_cnt == 0)

  00005	8b 7c 24 1c	 mov	 edi, DWORD PTR _write_buf_cnt$[esp+12]
  00009	8b 37		 mov	 esi, DWORD PTR [edi]
  0000b	85 f6		 test	 esi, esi

; 977  : 		return TRUE;

  0000d	0f 84 05 01 00
	00		 je	 $LN10@FlushForma

; 978  : 
; 979  : 	unitNo.Value = (*nSecNo * FormatSectorSize - *write_buf_cnt) / ENCRYPTION_DATA_UNIT_SIZE;

  00013	8b 44 24 20	 mov	 eax, DWORD PTR _nSecNo$[esp+12]
  00017	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001a	8b 10		 mov	 edx, DWORD PTR [eax]
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR _FormatSectorSize
  00021	53		 push	 ebx
  00022	51		 push	 ecx
  00023	52		 push	 edx
  00024	6a 00		 push	 0
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 __allmul
  0002c	8b c8		 mov	 ecx, eax
  0002e	8b da		 mov	 ebx, edx
  00030	8b c6		 mov	 eax, esi
  00032	99		 cdq
  00033	6a 00		 push	 0
  00035	2b c8		 sub	 ecx, eax
  00037	68 00 02 00 00	 push	 512			; 00000200H
  0003c	1b da		 sbb	 ebx, edx
  0003e	53		 push	 ebx
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 __alldiv
  00045	89 44 24 0c	 mov	 DWORD PTR _unitNo$[esp+20], eax
  00049	89 54 24 10	 mov	 DWORD PTR _unitNo$[esp+24], edx

; 980  : 
; 981  : 	EncryptDataUnits (write_buf, &unitNo, *write_buf_cnt / ENCRYPTION_DATA_UNIT_SIZE, cryptoInfo);

  0004d	8b 54 24 28	 mov	 edx, DWORD PTR _cryptoInfo$[esp+16]
  00051	52		 push	 edx
  00052	8b c6		 mov	 eax, esi
  00054	8b 74 24 20	 mov	 esi, DWORD PTR _write_buf$[esp+20]
  00058	99		 cdq
  00059	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  0005f	03 c2		 add	 eax, edx
  00061	c1 f8 09	 sar	 eax, 9
  00064	50		 push	 eax
  00065	8d 44 24 14	 lea	 eax, DWORD PTR _unitNo$[esp+28]
  00069	50		 push	 eax
  0006a	56		 push	 esi
  0006b	e8 00 00 00 00	 call	 _EncryptDataUnits

; 982  : 
; 983  : 	if (WriteThreadRunning)

  00070	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WriteThreadRunning
  00076	83 c4 10	 add	 esp, 16			; 00000010H
  00079	5b		 pop	 ebx
  0007a	85 c9		 test	 ecx, ecx
  0007c	74 7a		 je	 SHORT $LN6@FlushForma

; 984  : 	{
; 985  : 		if (WaitForSingleObject (WriteBufferEmptyEvent, INFINITE) == WAIT_FAILED)

  0007e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WriteBufferEmptyEvent
  00084	6a ff		 push	 -1
  00086	52		 push	 edx
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  0008d	83 f8 ff	 cmp	 eax, -1

; 986  : 			return FALSE;

  00090	74 23		 je	 SHORT $LN11@FlushForma

; 987  : 		
; 988  : 		if (WriteRequestResult != ERROR_SUCCESS)

  00092	a1 00 00 00 00	 mov	 eax, DWORD PTR _WriteRequestResult
  00097	85 c0		 test	 eax, eax
  00099	74 22		 je	 SHORT $LN4@FlushForma

; 989  : 		{
; 990  : 			SetEvent (WriteBufferEmptyEvent);

  0009b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WriteBufferEmptyEvent
  000a1	51		 push	 ecx
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 991  : 			SetLastError (WriteRequestResult);

  000a8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WriteRequestResult
  000ae	52		 push	 edx
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
$LN11@FlushForma:
  000b5	5f		 pop	 edi

; 992  : 			return FALSE;

  000b6	33 c0		 xor	 eax, eax
  000b8	5e		 pop	 esi

; 1010 : }

  000b9	83 c4 08	 add	 esp, 8
  000bc	c3		 ret	 0
$LN4@FlushForma:

; 993  : 		}
; 994  : 
; 995  : 		memcpy (WriteThreadBuffer, write_buf, *write_buf_cnt);

  000bd	8b 07		 mov	 eax, DWORD PTR [edi]
  000bf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WriteThreadBuffer
  000c5	50		 push	 eax
  000c6	56		 push	 esi
  000c7	51		 push	 ecx
  000c8	e8 00 00 00 00	 call	 _memcpy

; 996  : 		WriteRequestHandle = dev;

  000cd	8b 54 24 20	 mov	 edx, DWORD PTR _dev$[esp+24]

; 997  : 		WriteRequestSize = *write_buf_cnt;
; 998  : 
; 999  : 		if (!SetEvent (WriteBufferFullEvent))

  000d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WriteBufferFullEvent
  000d7	8b 07		 mov	 eax, DWORD PTR [edi]
  000d9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000dc	89 15 00 00 00
	00		 mov	 DWORD PTR _WriteRequestHandle, edx
  000e2	51		 push	 ecx
  000e3	a3 00 00 00 00	 mov	 DWORD PTR _WriteRequestSize, eax
  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
  000ee	85 c0		 test	 eax, eax
  000f0	75 20		 jne	 SHORT $LN1@FlushForma
  000f2	5f		 pop	 edi
  000f3	5e		 pop	 esi

; 1010 : }

  000f4	83 c4 08	 add	 esp, 8
  000f7	c3		 ret	 0
$LN6@FlushForma:

; 1000 : 			return FALSE;
; 1001 : 	}
; 1002 : 	else
; 1003 : 	{
; 1004 : 		if (!WriteFile ((HANDLE) dev, write_buf, *write_buf_cnt, &bytesWritten, NULL))

  000f8	8b 07		 mov	 eax, DWORD PTR [edi]
  000fa	8b 4c 24 14	 mov	 ecx, DWORD PTR _dev$[esp+12]
  000fe	6a 00		 push	 0
  00100	8d 54 24 20	 lea	 edx, DWORD PTR _bytesWritten$[esp+16]
  00104	52		 push	 edx
  00105	50		 push	 eax
  00106	56		 push	 esi
  00107	51		 push	 ecx
  00108	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  0010e	85 c0		 test	 eax, eax

; 1005 : 			return FALSE;

  00110	74 a3		 je	 SHORT $LN11@FlushForma
$LN1@FlushForma:

; 1006 : 	}
; 1007 : 
; 1008 : 	*write_buf_cnt = 0;

  00112	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN10@FlushForma:
  00118	5f		 pop	 edi

; 1009 : 	return TRUE;

  00119	b8 01 00 00 00	 mov	 eax, 1
  0011e	5e		 pop	 esi

; 1010 : }

  0011f	83 c4 08	 add	 esp, 8
  00122	c3		 ret	 0
_FlushFormatWriteBuffer ENDP
_TEXT	ENDS
PUBLIC	_WriteSector
EXTRN	_UpdateProgressBar:PROC
EXTRN	__imp__GetTickCount@0:PROC
; Function compile flags: /Ogtpy
;	COMDAT _WriteSector
_TEXT	SEGMENT
_dev$ = 8						; size = 4
_sector$ = 12						; size = 4
_write_buf$ = 16					; size = 4
_write_buf_cnt$ = 20					; size = 4
_nSecNo$ = 24						; size = 4
_cryptoInfo$ = 28					; size = 4
_WriteSector PROC					; COMDAT

; 835  : 	static __int32 updateTime = 0;
; 836  : 
; 837  : 	(*nSecNo)++;
; 838  : 
; 839  : 	memcpy (write_buf + *write_buf_cnt, sector, FormatSectorSize);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _sector$[esp-4]
  00004	53		 push	 ebx
  00005	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _FormatSectorSize
  0000b	55		 push	 ebp
  0000c	8b 6c 24 14	 mov	 ebp, DWORD PTR _write_buf$[esp+4]
  00010	56		 push	 esi
  00011	8b 74 24 20	 mov	 esi, DWORD PTR _nSecNo$[esp+8]
  00015	83 06 01	 add	 DWORD PTR [esi], 1
  00018	57		 push	 edi
  00019	8b 7c 24 20	 mov	 edi, DWORD PTR _write_buf_cnt$[esp+12]
  0001d	83 56 04 00	 adc	 DWORD PTR [esi+4], 0
  00021	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00023	53		 push	 ebx
  00024	50		 push	 eax
  00025	03 cd		 add	 ecx, ebp
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 _memcpy

; 840  : 	(*write_buf_cnt) += FormatSectorSize;

  0002d	01 1f		 add	 DWORD PTR [edi], ebx
  0002f	8b 07		 mov	 eax, DWORD PTR [edi]
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 841  : 
; 842  : 	if (*write_buf_cnt == FormatWriteBufferSize && !FlushFormatWriteBuffer (dev, write_buf, write_buf_cnt, nSecNo, cryptoInfo))

  00034	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _FormatWriteBufferSize
  0003a	75 20		 jne	 SHORT $LN3@WriteSecto
  0003c	8b 54 24 28	 mov	 edx, DWORD PTR _cryptoInfo$[esp+12]
  00040	8b 44 24 14	 mov	 eax, DWORD PTR _dev$[esp+12]
  00044	52		 push	 edx
  00045	56		 push	 esi
  00046	57		 push	 edi
  00047	55		 push	 ebp
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _FlushFormatWriteBuffer
  0004e	83 c4 14	 add	 esp, 20			; 00000014H
  00051	85 c0		 test	 eax, eax
  00053	75 07		 jne	 SHORT $LN3@WriteSecto
$LN6@WriteSecto:
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5d		 pop	 ebp

; 843  : 		return FALSE;

  00058	33 c0		 xor	 eax, eax
  0005a	5b		 pop	 ebx

; 854  : 
; 855  : }

  0005b	c3		 ret	 0
$LN3@WriteSecto:

; 844  : 	
; 845  : 	if (GetTickCount () - updateTime > 25)

  0005c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetTickCount@0
  00062	ff d7		 call	 edi
  00064	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?updateTime@?1??WriteSector@@9@9
  0006a	83 f8 19	 cmp	 eax, 25			; 00000019H
  0006d	76 29		 jbe	 SHORT $LN2@WriteSecto

; 846  : 	{
; 847  : 		if (UpdateProgressBar (*nSecNo * FormatSectorSize))

  0006f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00072	8b 16		 mov	 edx, DWORD PTR [esi]
  00074	a1 00 00 00 00	 mov	 eax, DWORD PTR _FormatSectorSize
  00079	51		 push	 ecx
  0007a	52		 push	 edx
  0007b	6a 00		 push	 0
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 __allmul
  00083	52		 push	 edx
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 _UpdateProgressBar
  0008a	83 c4 08	 add	 esp, 8
  0008d	85 c0		 test	 eax, eax

; 848  : 			return FALSE;

  0008f	75 c4		 jne	 SHORT $LN6@WriteSecto

; 849  : 
; 850  : 		updateTime = GetTickCount ();

  00091	ff d7		 call	 edi
  00093	a3 00 00 00 00	 mov	 DWORD PTR ?updateTime@?1??WriteSector@@9@9, eax
$LN2@WriteSecto:
  00098	5f		 pop	 edi
  00099	5e		 pop	 esi
  0009a	5d		 pop	 ebp

; 851  : 	}
; 852  : 
; 853  : 	return TRUE;

  0009b	b8 01 00 00 00	 mov	 eax, 1
  000a0	5b		 pop	 ebx

; 854  : 
; 855  : }

  000a1	c3		 ret	 0
_WriteSector ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_FormatNoFs
EXTRN	__imp__VirtualUnlock@8:PROC
EXTRN	_EAInitMode:PROC
EXTRN	_EAInit:PROC
EXTRN	_RandgetBytes:PROC
EXTRN	_EAGetKeySize:PROC
EXTRN	__imp__VirtualLock@8:PROC
EXTRN	__imp__SetFilePointerEx@20:PROC
EXTRN	__chkstk:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogtpy
;	COMDAT _FormatNoFs
_TEXT	SEGMENT
_retVal$ = -4640					; size = 4
_write_buf$ = -4636					; size = 4
_nSecNo$ = -4632					; size = 8
_write_buf_cnt$ = -4624					; size = 4
_newOffset$ = -4620					; size = 8
_temporaryKey$ = -4612					; size = 256
_originalK2$ = -4356					; size = 256
_sector$ = -4100					; size = 4096
__$ArrayPad$ = -4					; size = 4
_startSector$ = 8					; size = 8
_num_sectors$ = 16					; size = 8
_dev$ = 24						; size = 4
_cryptoInfo$ = 28					; size = 4
_quickFormat$ = 32					; size = 4
_FormatNoFs PROC					; COMDAT

; 679  : {

  00000	b8 20 12 00 00	 mov	 eax, 4640		; 00001220H
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000f	33 c4		 xor	 eax, esp
  00011	89 84 24 1c 12
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+4640], eax

; 680  : 	int write_buf_cnt = 0;
; 681  : 	char sector[TC_MAX_VOLUME_SECTOR_SIZE], *write_buf;
; 682  : 	unsigned __int64 nSecNo = startSector;

  00018	8b 8c 24 28 12
	00 00		 mov	 ecx, DWORD PTR _startSector$[esp+4640]
  0001f	8b 84 24 24 12
	00 00		 mov	 eax, DWORD PTR _startSector$[esp+4636]
  00026	53		 push	 ebx
  00027	8b 9c 24 3c 12
	00 00		 mov	 ebx, DWORD PTR _cryptoInfo$[esp+4640]
  0002e	55		 push	 ebp
  0002f	8b ac 24 3c 12
	00 00		 mov	 ebp, DWORD PTR _dev$[esp+4644]
  00036	56		 push	 esi
  00037	57		 push	 edi

; 683  : 	int retVal = 0;
; 684  : 	DWORD err;
; 685  : 	char temporaryKey[MASTER_KEYDATA_SIZE];
; 686  : 	char originalK2[MASTER_KEYDATA_SIZE];
; 687  : 
; 688  : 	LARGE_INTEGER startOffset;
; 689  : 	LARGE_INTEGER newOffset;
; 690  : 
; 691  : 	// Seek to start sector
; 692  : 	startOffset.QuadPart = startSector * FormatSectorSize;

  00038	51		 push	 ecx
  00039	33 d2		 xor	 edx, edx
  0003b	50		 push	 eax
  0003c	89 44 24 20	 mov	 DWORD PTR _nSecNo$[esp+4664], eax
  00040	a1 00 00 00 00	 mov	 eax, DWORD PTR _FormatSectorSize
  00045	52		 push	 edx
  00046	50		 push	 eax
  00047	89 54 24 30	 mov	 DWORD PTR _write_buf_cnt$[esp+4672], edx
  0004b	89 4c 24 2c	 mov	 DWORD PTR _nSecNo$[esp+4676], ecx
  0004f	89 54 24 20	 mov	 DWORD PTR _retVal$[esp+4672], edx
  00053	e8 00 00 00 00	 call	 __allmul

; 693  : 	if (!SetFilePointerEx ((HANDLE) dev, startOffset, &newOffset, FILE_BEGIN)
; 694  : 		|| newOffset.QuadPart != startOffset.QuadPart)

  00058	6a 00		 push	 0
  0005a	8d 4c 24 28	 lea	 ecx, DWORD PTR _newOffset$[esp+4660]
  0005e	51		 push	 ecx
  0005f	8b fa		 mov	 edi, edx
  00061	57		 push	 edi
  00062	8b f0		 mov	 esi, eax
  00064	56		 push	 esi
  00065	55		 push	 ebp
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  0006c	85 c0		 test	 eax, eax
  0006e	0f 84 92 02 00
	00		 je	 $LN34@FormatNoFs
  00074	8b 54 24 24	 mov	 edx, DWORD PTR _newOffset$[esp+4656]
  00078	3b d6		 cmp	 edx, esi
  0007a	0f 85 86 02 00
	00		 jne	 $LN34@FormatNoFs
  00080	8b 44 24 28	 mov	 eax, DWORD PTR _newOffset$[esp+4660]
  00084	3b c7		 cmp	 eax, edi
  00086	0f 85 7a 02 00
	00		 jne	 $LN34@FormatNoFs

; 697  : 	}
; 698  : 
; 699  : 	write_buf = (char *)TCalloc (FormatWriteBufferSize);

  0008c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _FormatWriteBufferSize
  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 _malloc
  00098	83 c4 04	 add	 esp, 4
  0009b	89 44 24 14	 mov	 DWORD PTR _write_buf$[esp+4656], eax

; 700  : 	if (!write_buf)

  0009f	85 c0		 test	 eax, eax
  000a1	75 0a		 jne	 SHORT $LN33@FormatNoFs

; 701  : 		return ERR_OUTOFMEMORY;

  000a3	b8 02 00 00 00	 mov	 eax, 2
  000a8	e9 5e 02 00 00	 jmp	 $LN36@FormatNoFs
$LN33@FormatNoFs:

; 702  : 
; 703  : 	VirtualLock (temporaryKey, sizeof (temporaryKey));

  000ad	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__VirtualLock@8
  000b3	68 00 01 00 00	 push	 256			; 00000100H
  000b8	8d 54 24 30	 lea	 edx, DWORD PTR _temporaryKey$[esp+4660]
  000bc	52		 push	 edx
  000bd	ff d6		 call	 esi

; 704  : 	VirtualLock (originalK2, sizeof (originalK2));

  000bf	68 00 01 00 00	 push	 256			; 00000100H
  000c4	8d 84 24 30 01
	00 00		 lea	 eax, DWORD PTR _originalK2$[esp+4660]
  000cb	50		 push	 eax
  000cc	ff d6		 call	 esi

; 705  : 
; 706  : 	memset (sector, 0, sizeof (sector));

  000ce	68 00 10 00 00	 push	 4096			; 00001000H
  000d3	8d 8c 24 30 02
	00 00		 lea	 ecx, DWORD PTR _sector$[esp+4660]
  000da	6a 00		 push	 0
  000dc	51		 push	 ecx
  000dd	e8 00 00 00 00	 call	 _memset
  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 707  : 
; 708  : 	// Remember the original secondary key (XTS mode) before generating a temporary one
; 709  : 	memcpy (originalK2, cryptoInfo->k2, sizeof (cryptoInfo->k2));
; 710  : 
; 711  : 	/* Fill the rest of the data area with random data */
; 712  : 
; 713  : 	if(!quickFormat)

  000e5	83 bc 24 4c 12
	00 00 00	 cmp	 DWORD PTR _quickFormat$[esp+4652], 0
  000ed	8d b3 a8 42 00
	00		 lea	 esi, DWORD PTR [ebx+17064]
  000f3	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000f8	8d bc 24 2c 01
	00 00		 lea	 edi, DWORD PTR _originalK2$[esp+4656]
  000ff	f3 a5		 rep movsd
  00101	0f 85 e1 00 00
	00		 jne	 $LN32@FormatNoFs

; 714  : 	{
; 715  : 		/* Generate a random temporary key set to be used for "dummy" encryption that will fill
; 716  : 		the free disk space (data area) with random data.  This is necessary for plausible
; 717  : 		deniability of hidden volumes. */
; 718  : 
; 719  : 		// Temporary master key
; 720  : 		if (!RandgetBytes (temporaryKey, EAGetKeySize (cryptoInfo->ea), FALSE))

  00107	8b 13		 mov	 edx, DWORD PTR [ebx]
  00109	6a 00		 push	 0
  0010b	52		 push	 edx
  0010c	e8 00 00 00 00	 call	 _EAGetKeySize
  00111	83 c4 04	 add	 esp, 4
  00114	50		 push	 eax
  00115	8d 44 24 34	 lea	 eax, DWORD PTR _temporaryKey$[esp+4664]
  00119	50		 push	 eax
  0011a	e8 00 00 00 00	 call	 _RandgetBytes
  0011f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00122	85 c0		 test	 eax, eax
  00124	0f 84 3e 01 00
	00		 je	 $fail$80754

; 721  : 			goto fail;
; 722  : 
; 723  : 		// Temporary secondary key (XTS mode)
; 724  : 		if (!RandgetBytes (cryptoInfo->k2, sizeof cryptoInfo->k2, FALSE))

  0012a	6a 00		 push	 0
  0012c	8d 83 a8 42 00
	00		 lea	 eax, DWORD PTR [ebx+17064]
  00132	68 00 01 00 00	 push	 256			; 00000100H
  00137	50		 push	 eax
  00138	e8 00 00 00 00	 call	 _RandgetBytes
  0013d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00140	85 c0		 test	 eax, eax
  00142	0f 84 20 01 00
	00		 je	 $fail$80754

; 725  : 			goto fail;
; 726  : 
; 727  : 		retVal = EAInit (cryptoInfo->ea, temporaryKey, cryptoInfo->ks);

  00148	8b 03		 mov	 eax, DWORD PTR [ebx]
  0014a	8d 4b 08	 lea	 ecx, DWORD PTR [ebx+8]
  0014d	51		 push	 ecx
  0014e	8d 54 24 30	 lea	 edx, DWORD PTR _temporaryKey$[esp+4660]
  00152	52		 push	 edx
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 _EAInit
  00159	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015c	89 44 24 10	 mov	 DWORD PTR _retVal$[esp+4656], eax

; 728  : 		if (retVal != ERR_SUCCESS)

  00160	85 c0		 test	 eax, eax
  00162	0f 85 00 01 00
	00		 jne	 $fail$80754

; 729  : 			goto fail;
; 730  : 
; 731  : 		if (!EAInitMode (cryptoInfo))

  00168	53		 push	 ebx
  00169	e8 00 00 00 00	 call	 _EAInitMode
  0016e	83 c4 04	 add	 esp, 4
  00171	85 c0		 test	 eax, eax

; 732  : 		{
; 733  : 			retVal = ERR_MODE_INIT_FAILED;
; 734  : 			goto fail;

  00173	0f 84 e7 00 00
	00		 je	 $LN111@FormatNoFs

; 735  : 		}
; 736  : 
; 737  : 		while (num_sectors--)

  00179	8b b4 24 3c 12
	00 00		 mov	 esi, DWORD PTR _num_sectors$[esp+4652]
  00180	8b bc 24 40 12
	00 00		 mov	 edi, DWORD PTR _num_sectors$[esp+4656]
  00187	8b ce		 mov	 ecx, esi
  00189	0b cf		 or	 ecx, edi
  0018b	74 38		 je	 SHORT $LN97@FormatNoFs
  0018d	8d 49 00	 npad	 3
$LL27@FormatNoFs:

; 738  : 		{
; 739  : 			if (WriteSector (dev, sector, write_buf, &write_buf_cnt, &nSecNo,
; 740  : 				cryptoInfo) == FALSE)

  00190	8b 4c 24 14	 mov	 ecx, DWORD PTR _write_buf$[esp+4656]
  00194	53		 push	 ebx
  00195	8d 54 24 1c	 lea	 edx, DWORD PTR _nSecNo$[esp+4660]
  00199	52		 push	 edx
  0019a	8d 44 24 28	 lea	 eax, DWORD PTR _write_buf_cnt$[esp+4664]
  0019e	50		 push	 eax
  0019f	51		 push	 ecx
  001a0	8d 94 24 3c 02
	00 00		 lea	 edx, DWORD PTR _sector$[esp+4672]
  001a7	52		 push	 edx
  001a8	83 c6 ff	 add	 esi, -1
  001ab	55		 push	 ebp
  001ac	83 d7 ff	 adc	 edi, -1
  001af	e8 00 00 00 00	 call	 _WriteSector
  001b4	83 c4 18	 add	 esp, 24			; 00000018H
  001b7	85 c0		 test	 eax, eax
  001b9	0f 84 a9 00 00
	00		 je	 $fail$80754
  001bf	8b c6		 mov	 eax, esi
  001c1	0b c7		 or	 eax, edi
  001c3	75 cb		 jne	 SHORT $LL27@FormatNoFs
$LN97@FormatNoFs:

; 741  : 				goto fail;
; 742  : 		}
; 743  : 
; 744  : 		if (!FlushFormatWriteBuffer (dev, write_buf, &write_buf_cnt, &nSecNo, cryptoInfo))

  001c5	8b 44 24 14	 mov	 eax, DWORD PTR _write_buf$[esp+4656]
  001c9	53		 push	 ebx
  001ca	8d 4c 24 1c	 lea	 ecx, DWORD PTR _nSecNo$[esp+4660]
  001ce	51		 push	 ecx
  001cf	8d 54 24 28	 lea	 edx, DWORD PTR _write_buf_cnt$[esp+4664]
  001d3	52		 push	 edx
  001d4	50		 push	 eax
  001d5	55		 push	 ebp
  001d6	e8 00 00 00 00	 call	 _FlushFormatWriteBuffer
  001db	83 c4 14	 add	 esp, 20			; 00000014H
  001de	85 c0		 test	 eax, eax
  001e0	0f 84 82 00 00
	00		 je	 $fail$80754

; 745  : 			goto fail;
; 746  : 	}
; 747  : 	else

  001e6	eb 16		 jmp	 SHORT $LN23@FormatNoFs
$LN32@FormatNoFs:

; 748  : 		nSecNo = num_sectors;

  001e8	8b 8c 24 3c 12
	00 00		 mov	 ecx, DWORD PTR _num_sectors$[esp+4652]
  001ef	8b 94 24 40 12
	00 00		 mov	 edx, DWORD PTR _num_sectors$[esp+4656]
  001f6	89 4c 24 18	 mov	 DWORD PTR _nSecNo$[esp+4656], ecx
  001fa	89 54 24 1c	 mov	 DWORD PTR _nSecNo$[esp+4660], edx
$LN23@FormatNoFs:

; 749  : 
; 750  : 	UpdateProgressBar (nSecNo * FormatSectorSize);

  001fe	8b 44 24 1c	 mov	 eax, DWORD PTR _nSecNo$[esp+4660]
  00202	8b 4c 24 18	 mov	 ecx, DWORD PTR _nSecNo$[esp+4656]
  00206	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _FormatSectorSize
  0020c	50		 push	 eax
  0020d	51		 push	 ecx
  0020e	6a 00		 push	 0
  00210	52		 push	 edx
  00211	e8 00 00 00 00	 call	 __allmul
  00216	52		 push	 edx
  00217	50		 push	 eax
  00218	e8 00 00 00 00	 call	 _UpdateProgressBar

; 751  : 
; 752  : 	// Restore the original secondary key (XTS mode) in case NTFS format fails and the user wants to try FAT immediately
; 753  : 	memcpy (cryptoInfo->k2, originalK2, sizeof (cryptoInfo->k2));
; 754  : 
; 755  : 	// Reinitialize the encryption algorithm and mode in case NTFS format fails and the user wants to try FAT immediately
; 756  : 	retVal = EAInit (cryptoInfo->ea, cryptoInfo->master_keydata, cryptoInfo->ks);

  0021d	8b 13		 mov	 edx, DWORD PTR [ebx]
  0021f	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00224	8d b4 24 34 01
	00 00		 lea	 esi, DWORD PTR _originalK2$[esp+4664]
  0022b	8d bb a8 42 00
	00		 lea	 edi, DWORD PTR [ebx+17064]
  00231	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  00234	f3 a5		 rep movsd
  00236	50		 push	 eax
  00237	8d 8b a8 41 00
	00		 lea	 ecx, DWORD PTR [ebx+16808]
  0023d	51		 push	 ecx
  0023e	52		 push	 edx
  0023f	e8 00 00 00 00	 call	 _EAInit
  00244	83 c4 14	 add	 esp, 20			; 00000014H
  00247	89 44 24 10	 mov	 DWORD PTR _retVal$[esp+4656], eax

; 757  : 	if (retVal != ERR_SUCCESS)

  0024b	85 c0		 test	 eax, eax
  0024d	75 19		 jne	 SHORT $fail$80754

; 758  : 		goto fail;
; 759  : 	if (!EAInitMode (cryptoInfo))

  0024f	53		 push	 ebx
  00250	e8 00 00 00 00	 call	 _EAInitMode
  00255	83 c4 04	 add	 esp, 4
  00258	85 c0		 test	 eax, eax
  0025a	0f 85 c4 00 00
	00		 jne	 $LN20@FormatNoFs
$LN111@FormatNoFs:

; 760  : 	{
; 761  : 		retVal = ERR_MODE_INIT_FAILED;

  00260	c7 44 24 10 1b
	00 00 00	 mov	 DWORD PTR _retVal$[esp+4656], 27 ; 0000001bH
$fail$80754:

; 772  : 
; 773  : fail:
; 774  : 	err = GetLastError();

  00268	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 775  : 
; 776  : 	burn (temporaryKey, sizeof(temporaryKey));

  0026e	8d 54 24 2c	 lea	 edx, DWORD PTR _temporaryKey$[esp+4656]
  00272	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00277	8b f8		 mov	 edi, eax
  00279	8b f1		 mov	 esi, ecx
  0027b	8b c2		 mov	 eax, edx
  0027d	8d 49 00	 npad	 3
$LL49@FormatNoFs:
  00280	c6 00 00	 mov	 BYTE PTR [eax], 0
  00283	40		 inc	 eax
  00284	83 ee 01	 sub	 esi, 1
  00287	75 f7		 jne	 SHORT $LL49@FormatNoFs
  00289	8d a4 24 00 00
	00 00		 npad	 7
$LL7@FormatNoFs:
  00290	49		 dec	 ecx
  00291	c6 02 00	 mov	 BYTE PTR [edx], 0
  00294	42		 inc	 edx
  00295	85 c9		 test	 ecx, ecx
  00297	75 f7		 jne	 SHORT $LL7@FormatNoFs

; 777  : 	burn (originalK2, sizeof(originalK2));

  00299	8d 94 24 2c 01
	00 00		 lea	 edx, DWORD PTR _originalK2$[esp+4656]
  002a0	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  002a5	8b f1		 mov	 esi, ecx
  002a7	8b c2		 mov	 eax, edx
  002a9	8d a4 24 00 00
	00 00		 npad	 7
$LL53@FormatNoFs:
  002b0	c6 00 00	 mov	 BYTE PTR [eax], 0
  002b3	40		 inc	 eax
  002b4	83 ee 01	 sub	 esi, 1
  002b7	75 f7		 jne	 SHORT $LL53@FormatNoFs
  002b9	8d a4 24 00 00
	00 00		 npad	 7
$LL2@FormatNoFs:
  002c0	49		 dec	 ecx
  002c1	c6 02 00	 mov	 BYTE PTR [edx], 0
  002c4	42		 inc	 edx
  002c5	85 c9		 test	 ecx, ecx
  002c7	75 f7		 jne	 SHORT $LL2@FormatNoFs

; 778  : 	VirtualUnlock (temporaryKey, sizeof (temporaryKey));

  002c9	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__VirtualUnlock@8
  002cf	68 00 01 00 00	 push	 256			; 00000100H
  002d4	8d 44 24 30	 lea	 eax, DWORD PTR _temporaryKey$[esp+4660]
  002d8	50		 push	 eax
  002d9	ff d6		 call	 esi

; 779  : 	VirtualUnlock (originalK2, sizeof (originalK2));

  002db	68 00 01 00 00	 push	 256			; 00000100H
  002e0	8d 8c 24 30 01
	00 00		 lea	 ecx, DWORD PTR _originalK2$[esp+4660]
  002e7	51		 push	 ecx
  002e8	ff d6		 call	 esi

; 780  : 	TCfree (write_buf);

  002ea	8b 54 24 14	 mov	 edx, DWORD PTR _write_buf$[esp+4656]
  002ee	52		 push	 edx
  002ef	e8 00 00 00 00	 call	 _free
  002f4	83 c4 04	 add	 esp, 4

; 781  : 
; 782  : 	SetLastError (err);

  002f7	57		 push	 edi
  002f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 783  : 	return (retVal ? retVal : ERR_OS_ERROR);

  002fe	8b 44 24 10	 mov	 eax, DWORD PTR _retVal$[esp+4656]
  00302	85 c0		 test	 eax, eax
  00304	75 05		 jne	 SHORT $LN36@FormatNoFs
$LN34@FormatNoFs:

; 695  : 	{
; 696  : 		return ERR_OS_ERROR;

  00306	b8 01 00 00 00	 mov	 eax, 1
$LN36@FormatNoFs:

; 784  : }

  0030b	8b 8c 24 2c 12
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+4656]
  00312	5f		 pop	 edi
  00313	5e		 pop	 esi
  00314	5d		 pop	 ebp
  00315	5b		 pop	 ebx
  00316	33 cc		 xor	 ecx, esp
  00318	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0031d	81 c4 20 12 00
	00		 add	 esp, 4640		; 00001220H
  00323	c3		 ret	 0
$LN20@FormatNoFs:

; 762  : 		goto fail;
; 763  : 	}
; 764  : 
; 765  : 	burn (temporaryKey, sizeof(temporaryKey));

  00324	8d 54 24 2c	 lea	 edx, DWORD PTR _temporaryKey$[esp+4656]
  00328	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0032d	8b f1		 mov	 esi, ecx
  0032f	8b c2		 mov	 eax, edx
$LL41@FormatNoFs:
  00331	c6 00 00	 mov	 BYTE PTR [eax], 0
  00334	40		 inc	 eax
  00335	83 ee 01	 sub	 esi, 1
  00338	75 f7		 jne	 SHORT $LL41@FormatNoFs
  0033a	8d 9b 00 00 00
	00		 npad	 6
$LL17@FormatNoFs:
  00340	49		 dec	 ecx
  00341	c6 02 00	 mov	 BYTE PTR [edx], 0
  00344	42		 inc	 edx
  00345	85 c9		 test	 ecx, ecx
  00347	75 f7		 jne	 SHORT $LL17@FormatNoFs

; 766  : 	burn (originalK2, sizeof(originalK2));

  00349	8d 94 24 2c 01
	00 00		 lea	 edx, DWORD PTR _originalK2$[esp+4656]
  00350	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00355	8b f1		 mov	 esi, ecx
  00357	8b c2		 mov	 eax, edx
  00359	8d a4 24 00 00
	00 00		 npad	 7
$LL45@FormatNoFs:
  00360	c6 00 00	 mov	 BYTE PTR [eax], 0
  00363	40		 inc	 eax
  00364	83 ee 01	 sub	 esi, 1
  00367	75 f7		 jne	 SHORT $LL45@FormatNoFs
  00369	8d a4 24 00 00
	00 00		 npad	 7
$LL12@FormatNoFs:
  00370	49		 dec	 ecx
  00371	c6 02 00	 mov	 BYTE PTR [edx], 0
  00374	42		 inc	 edx
  00375	85 c9		 test	 ecx, ecx
  00377	75 f7		 jne	 SHORT $LL12@FormatNoFs

; 767  : 	VirtualUnlock (temporaryKey, sizeof (temporaryKey));

  00379	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__VirtualUnlock@8
  0037f	68 00 01 00 00	 push	 256			; 00000100H
  00384	8d 44 24 30	 lea	 eax, DWORD PTR _temporaryKey$[esp+4660]
  00388	50		 push	 eax
  00389	ff d6		 call	 esi

; 768  : 	VirtualUnlock (originalK2, sizeof (originalK2));

  0038b	68 00 01 00 00	 push	 256			; 00000100H
  00390	8d 8c 24 30 01
	00 00		 lea	 ecx, DWORD PTR _originalK2$[esp+4660]
  00397	51		 push	 ecx
  00398	ff d6		 call	 esi

; 769  : 	TCfree (write_buf);

  0039a	8b 54 24 14	 mov	 edx, DWORD PTR _write_buf$[esp+4656]
  0039e	52		 push	 edx
  0039f	e8 00 00 00 00	 call	 _free
  003a4	83 c4 04	 add	 esp, 4

; 770  : 
; 771  : 	return 0;

  003a7	33 c0		 xor	 eax, eax
  003a9	e9 5d ff ff ff	 jmp	 $LN36@FormatNoFs
_FormatNoFs ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@FCILOPDD@SECTOR_SIZE_UNSUPPORTED?$AA@	; `string'
PUBLIC	??_C@_0BD@KDGBHLHC@FORMAT_NTFS_FAILED?$AA@	; `string'
PUBLIC	??_C@_0BC@NBGKCIGC@CANT_MOUNT_VOLUME?$AA@	; `string'
PUBLIC	??_C@_0BB@FNPBIAIE@FORMAT_NTFS_STOP?$AA@	; `string'
PUBLIC	??_C@_0P@ECPPAAM@NO_FREE_DRIVES?$AA@		; `string'
PUBLIC	??_C@_0BL@GAPIEOII@FORMAT_NTFS_FAILED_ASK_FAT?$AA@ ; `string'
PUBLIC	??_C@_0BF@OLCHNIN@CANT_DISMOUNT_VOLUME?$AA@	; `string'
PUBLIC	??_C@_0M@BCIBMEHP@NO?5NAME?5?5?5?5?$AA@		; `string'
PUBLIC	??_C@_0BA@GFCNKOPI@CANT_ACCESS_VOL?$AA@		; `string'
PUBLIC	??_C@_0BF@LPDGKFHG@DEVICE_IN_USE_FORMAT?$AA@	; `string'
PUBLIC	??_C@_0BN@NJIOHEOP@FORMAT_CANT_DISMOUNT_FILESYS?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_TCFormatVolume
EXTRN	_crypto_close:PROC
EXTRN	_RemoveFakeDosName:PROC
EXTRN	_AskErrYesNo:PROC
EXTRN	_UnmountVolume:PROC
EXTRN	_UacFormatNtfs:PROC
EXTRN	_IsUacSupported:PROC
EXTRN	_IsAdmin:PROC
EXTRN	_MountVolume:PROC
EXTRN	_GetLastAvailableDrive:PROC
EXTRN	__imp__SetFileTime@16:PROC
EXTRN	_WriteRandomDataToReservedHeaderAreas:PROC
EXTRN	_FormatFat:PROC
EXTRN	_GetFatParams:PROC
EXTRN	_WriteEffectiveVolumeHeader:PROC
EXTRN	__imp__SetFilePointer@16:PROC
EXTRN	__imp__SetEndOfFile@4:PROC
EXTRN	_DisableFileCompression:PROC
EXTRN	__imp__KillTimer@8:PROC
EXTRN	__imp__GetFileTime@16:PROC
EXTRN	_bPreserveTimestamp:DWORD
EXTRN	__imp__FlushFileBuffers@4:PROC
EXTRN	__imp__MessageBoxW@16:PROC
EXTRN	_GetString:PROC
EXTRN	_lpszTitle:DWORD
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp__DeleteVolumeMountPointA@4:PROC
EXTRN	__imp__SetVolumeMountPointA@8:PROC
EXTRN	__imp__GetVolumeNameForVolumeMountPointA@12:PROC
EXTRN	_GetFirstAvailableDrive:PROC
EXTRN	_IsOSAtLeast:PROC
EXTRN	__imp__DeviceIoControl@32:PROC
EXTRN	_Error:PROC
EXTRN	_DismountDrive:PROC
EXTRN	_IsDeviceMounted:PROC
EXTRN	_FakeDosNameForDevice:PROC
EXTRN	__imp__DefineDosDeviceA@12:PROC
EXTRN	_CreateVolumeHeaderInMemory:PROC
EXTRN	_GetDiskDeviceDriveLetter:PROC
EXTRN	_ToUNICODE:PROC
EXTRN	__aullrem:PROC
EXTRN	__aulldiv:PROC
;	COMDAT ??_C@_0BI@FCILOPDD@SECTOR_SIZE_UNSUPPORTED?$AA@
; File c:\program files\microsoft sdks\windows\v7.1\include\winnt.h
CONST	SEGMENT
??_C@_0BI@FCILOPDD@SECTOR_SIZE_UNSUPPORTED?$AA@ DB 'SECTOR_SIZE_UNSUPPORT'
	DB	'ED', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KDGBHLHC@FORMAT_NTFS_FAILED?$AA@
CONST	SEGMENT
??_C@_0BD@KDGBHLHC@FORMAT_NTFS_FAILED?$AA@ DB 'FORMAT_NTFS_FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NBGKCIGC@CANT_MOUNT_VOLUME?$AA@
CONST	SEGMENT
??_C@_0BC@NBGKCIGC@CANT_MOUNT_VOLUME?$AA@ DB 'CANT_MOUNT_VOLUME', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FNPBIAIE@FORMAT_NTFS_STOP?$AA@
CONST	SEGMENT
??_C@_0BB@FNPBIAIE@FORMAT_NTFS_STOP?$AA@ DB 'FORMAT_NTFS_STOP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ECPPAAM@NO_FREE_DRIVES?$AA@
CONST	SEGMENT
??_C@_0P@ECPPAAM@NO_FREE_DRIVES?$AA@ DB 'NO_FREE_DRIVES', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GAPIEOII@FORMAT_NTFS_FAILED_ASK_FAT?$AA@
CONST	SEGMENT
??_C@_0BL@GAPIEOII@FORMAT_NTFS_FAILED_ASK_FAT?$AA@ DB 'FORMAT_NTFS_FAILED'
	DB	'_ASK_FAT', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OLCHNIN@CANT_DISMOUNT_VOLUME?$AA@
CONST	SEGMENT
??_C@_0BF@OLCHNIN@CANT_DISMOUNT_VOLUME?$AA@ DB 'CANT_DISMOUNT_VOLUME', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BCIBMEHP@NO?5NAME?5?5?5?5?$AA@
CONST	SEGMENT
??_C@_0M@BCIBMEHP@NO?5NAME?5?5?5?5?$AA@ DB 'NO NAME    ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GFCNKOPI@CANT_ACCESS_VOL?$AA@
CONST	SEGMENT
??_C@_0BA@GFCNKOPI@CANT_ACCESS_VOL?$AA@ DB 'CANT_ACCESS_VOL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LPDGKFHG@DEVICE_IN_USE_FORMAT?$AA@
CONST	SEGMENT
??_C@_0BF@LPDGKFHG@DEVICE_IN_USE_FORMAT?$AA@ DB 'DEVICE_IN_USE_FORMAT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NJIOHEOP@FORMAT_CANT_DISMOUNT_FILESYS?$AA@
CONST	SEGMENT
??_C@_0BN@NJIOHEOP@FORMAT_CANT_DISMOUNT_FILESYS?$AA@ DB 'FORMAT_CANT_DISM'
	DB	'OUNT_FILESYS', 00H				; `string'
; Function compile flags: /Ogtpy
; File c:\home\public\desktop\projects\ciphershed.build\src\common\format.c
CONST	ENDS
;	COMDAT _TCFormatVolume
_TEXT	SEGMENT
_cryptoInfo$ = -140836					; size = 4
_szDriveLetter$80566 = -140832				; size = 3
_rootPath$80567 = -140828				; size = 4
_bInstantRetryOtherFilesys$ = -140824			; size = 4
_dataAreaSize$ = -140820				; size = 8
_dwError$ = -140812					; size = 4
_nPass$80552 = -140812					; size = 4
_dataOffset$ = -140808					; size = 8
_bTimeStampValid$ = -140800				; size = 4
_bFailedRequiredDASD$ = -140796				; size = 4
_driveLetter$ = -140792					; size = 4
_dwResult$80551 = -140788				; size = 4
_num_sectors$ = -140784					; size = 8
_bytesWritten$80655 = -140776				; size = 4
_ftLastWriteTime$ = -140772				; size = 8
_ftLastAccessTime$ = -140764				; size = 8
_ftCreationTime$ = -140756				; size = 8
_tmp$80625 = -140748					; size = 4
_bw$80607 = -140744					; size = 4
_ft$ = -140740						; size = 68
_mountOptions$80707 = -140672				; size = 100
_devName$ = -140572					; size = 260
_header$ = -140312					; size = 512
_dosDev$ = -139800					; size = 260
_uniqVolName$80568 = -139540				; size = 261
_deviceName$ = -139276					; size = 520
_buf$80606 = -138756					; size = 8192
_buf$80654 = -130564					; size = 130560
__$ArrayPad$ = -4					; size = 4
_volParams$ = 8						; size = 4
_TCFormatVolume PROC					; COMDAT

; 74   : {

  00000	b8 24 26 02 00	 mov	 eax, 140836		; 00022624H
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000f	33 c4		 xor	 eax, esp
  00011	89 84 24 20 26
	02 00		 mov	 DWORD PTR __$ArrayPad$[esp+140836], eax
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	8b b4 24 30 26
	02 00		 mov	 esi, DWORD PTR _volParams$[esp+140840]
  00021	57		 push	 edi

; 75   : 	int nStatus;
; 76   : 	PCRYPTO_INFO cryptoInfo = NULL;

  00022	33 db		 xor	 ebx, ebx

; 77   : 	HANDLE dev = INVALID_HANDLE_VALUE;
; 78   : 	DWORD dwError;
; 79   : 	char header[TC_VOLUME_HEADER_EFFECTIVE_SIZE];
; 80   : 	unsigned __int64 num_sectors, startSector;
; 81   : 	fatparams ft;
; 82   : 	FILETIME ftCreationTime;
; 83   : 	FILETIME ftLastWriteTime;
; 84   : 	FILETIME ftLastAccessTime;
; 85   : 	BOOL bTimeStampValid = FALSE;
; 86   : 	BOOL bInstantRetryOtherFilesys = FALSE;
; 87   : 	char dosDev[TC_MAX_PATH] = { 0 };

  00024	68 03 01 00 00	 push	 259			; 00000103H
  00029	8d 84 24 1d 04
	00 00		 lea	 eax, DWORD PTR _dosDev$[esp+140853]
  00030	53		 push	 ebx
  00031	50		 push	 eax
  00032	89 5c 24 18	 mov	 DWORD PTR _cryptoInfo$[esp+140860], ebx
  00036	83 cf ff	 or	 edi, -1
  00039	89 5c 24 3c	 mov	 DWORD PTR _bTimeStampValid$[esp+140860], ebx
  0003d	89 5c 24 24	 mov	 DWORD PTR _bInstantRetryOtherFilesys$[esp+140860], ebx
  00041	88 9c 24 24 04
	00 00		 mov	 BYTE PTR _dosDev$[esp+140860], bl
  00048	e8 00 00 00 00	 call	 _memset

; 88   : 	char devName[MAX_PATH] = { 0 };

  0004d	68 03 01 00 00	 push	 259			; 00000103H
  00052	8d 8c 24 25 01
	00 00		 lea	 ecx, DWORD PTR _devName$[esp+140865]
  00059	53		 push	 ebx
  0005a	51		 push	 ecx
  0005b	88 9c 24 2c 01
	00 00		 mov	 BYTE PTR _devName$[esp+140872], bl
  00062	e8 00 00 00 00	 call	 _memset

; 89   : 	int driveLetter = -1;
; 90   : 	WCHAR deviceName[MAX_PATH];
; 91   : 	uint64 dataOffset, dataAreaSize;
; 92   : 	LARGE_INTEGER offset;
; 93   : 	BOOL bFailedRequiredDASD = FALSE;
; 94   : 
; 95   : 	FormatSectorSize = volParams->sectorSize;

  00067	8b 56 3c	 mov	 edx, DWORD PTR [esi+60]

; 96   : 
; 97   : 	if (FormatSectorSize < TC_MIN_VOLUME_SECTOR_SIZE
; 98   : 		|| FormatSectorSize > TC_MAX_VOLUME_SECTOR_SIZE
; 99   : 		|| FormatSectorSize % ENCRYPTION_DATA_UNIT_SIZE != 0)

  0006a	8b c2		 mov	 eax, edx
  0006c	8d 88 00 fe ff
	ff		 lea	 ecx, DWORD PTR [eax-512]
  00072	83 c4 18	 add	 esp, 24			; 00000018H
  00075	89 7c 24 38	 mov	 DWORD PTR _driveLetter$[esp+140848], edi
  00079	89 5c 24 34	 mov	 DWORD PTR _bFailedRequiredDASD$[esp+140848], ebx
  0007d	89 15 00 00 00
	00		 mov	 DWORD PTR _FormatSectorSize, edx
  00083	81 f9 00 0e 00
	00		 cmp	 ecx, 3584		; 00000e00H
  00089	0f 87 71 0c 00
	00		 ja	 $LN98@TCFormatVo
  0008f	a9 ff 01 00 00	 test	 eax, 511		; 000001ffH
  00094	0f 85 66 0c 00
	00		 jne	 $LN98@TCFormatVo

; 102  : 		return ERR_DONT_REPORT; 
; 103  : 	}
; 104  : 
; 105  : 	/* WARNING: Note that if Windows fails to format the volume as NTFS and the volume size is
; 106  : 	less than the maximum FAT size, the user is asked within this function whether he wants to instantly
; 107  : 	retry FAT format instead (to avoid having to re-create the whole container again). If the user
; 108  : 	answers yes, some of the input parameters are modified, the code below 'begin_format' is re-executed 
; 109  : 	and some destructive operations that were performed during the first attempt must be (and are) skipped. 
; 110  : 	Therefore, whenever adding or modifying any potentially destructive operations below 'begin_format',
; 111  : 	determine whether they (or their portions) need to be skipped during such a second attempt; if so, 
; 112  : 	use the 'bInstantRetryOtherFilesys' flag to skip them. */
; 113  : 
; 114  : 	if (volParams->hiddenVol)

  0009a	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0009d	85 d2		 test	 edx, edx
  0009f	74 21		 je	 SHORT $LN97@TCFormatVo

; 115  : 	{
; 116  : 		dataOffset = volParams->hiddenVolHostSize - TC_VOLUME_HEADER_GROUP_SIZE - volParams->size;

  000a1	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  000a4	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  000a7	b8 00 00 fe ff	 mov	 eax, -131072		; fffe0000H
  000ac	2b c1		 sub	 eax, ecx
  000ae	8b cf		 mov	 ecx, edi
  000b0	1b ca		 sbb	 ecx, edx
  000b2	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  000b5	8b 5e 1c	 mov	 ebx, DWORD PTR [esi+28]
  000b8	03 d0		 add	 edx, eax
  000ba	89 54 24 28	 mov	 DWORD PTR _dataOffset$[esp+140848], edx
  000be	13 d9		 adc	 ebx, ecx

; 117  : 	}
; 118  : 	else

  000c0	eb 36		 jmp	 SHORT $LN197@TCFormatVo
$LN97@TCFormatVo:

; 119  : 	{
; 120  : 		if (volParams->size <= TC_TOTAL_VOLUME_HEADERS_SIZE)

  000c2	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000c5	39 5e 14	 cmp	 DWORD PTR [esi+20], ebx
  000c8	77 26		 ja	 SHORT $LN95@TCFormatVo
  000ca	72 07		 jb	 SHORT $LN157@TCFormatVo
  000cc	3d 00 00 04 00	 cmp	 eax, 262144		; 00040000H
  000d1	77 1d		 ja	 SHORT $LN95@TCFormatVo
$LN157@TCFormatVo:
  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi

; 121  : 			return ERR_VOL_SIZE_WRONG;

  000d5	b8 07 00 00 00	 mov	 eax, 7
  000da	5b		 pop	 ebx

; 675  : }

  000db	8b 8c 24 20 26
	02 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+140836]
  000e2	33 cc		 xor	 ecx, esp
  000e4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e9	81 c4 24 26 02
	00		 add	 esp, 140836		; 00022624H
  000ef	c3		 ret	 0
$LN95@TCFormatVo:

; 122  : 
; 123  : 		dataOffset = TC_VOLUME_DATA_OFFSET;

  000f0	c7 44 24 28 00
	00 02 00	 mov	 DWORD PTR _dataOffset$[esp+140848], 131072 ; 00020000H
$LN197@TCFormatVo:

; 124  : 	}
; 125  : 
; 126  : 	dataAreaSize = GetVolumeDataAreaSize (volParams->hiddenVol, volParams->size);

  000f8	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000fb	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  000fe	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00101	55		 push	 ebp
  00102	50		 push	 eax
  00103	51		 push	 ecx
  00104	52		 push	 edx
  00105	89 5c 24 3c	 mov	 DWORD PTR _dataOffset$[esp+140868], ebx
  00109	e8 00 00 00 00	 call	 _GetVolumeDataAreaSize
  0010e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00111	8b e8		 mov	 ebp, eax

; 127  : 
; 128  : 	num_sectors = dataAreaSize / FormatSectorSize;

  00113	a1 00 00 00 00	 mov	 eax, DWORD PTR _FormatSectorSize
  00118	6a 00		 push	 0
  0011a	8b da		 mov	 ebx, edx
  0011c	50		 push	 eax
  0011d	53		 push	 ebx
  0011e	55		 push	 ebp
  0011f	89 6c 24 30	 mov	 DWORD PTR _dataAreaSize$[esp+140868], ebp
  00123	89 5c 24 34	 mov	 DWORD PTR _dataAreaSize$[esp+140872], ebx
  00127	e8 00 00 00 00	 call	 __aulldiv

; 129  : 
; 130  : 	if (volParams->bDevice)

  0012c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0012e	89 44 24 44	 mov	 DWORD PTR _num_sectors$[esp+140852], eax
  00132	89 54 24 48	 mov	 DWORD PTR _num_sectors$[esp+140856], edx
  00136	85 c9		 test	 ecx, ecx
  00138	74 35		 je	 SHORT $LN94@TCFormatVo

; 131  : 	{
; 132  : 		strcpy ((char *)deviceName, volParams->volumePath);

  0013a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0013d	8d 94 24 28 06
	00 00		 lea	 edx, DWORD PTR _deviceName$[esp+140852]
$LL102@TCFormatVo:
  00144	8a 01		 mov	 al, BYTE PTR [ecx]
  00146	88 02		 mov	 BYTE PTR [edx], al
  00148	41		 inc	 ecx
  00149	42		 inc	 edx
  0014a	84 c0		 test	 al, al
  0014c	75 f6		 jne	 SHORT $LL102@TCFormatVo

; 133  : 		ToUNICODE ((char *)deviceName);

  0014e	8d 94 24 28 06
	00 00		 lea	 edx, DWORD PTR _deviceName$[esp+140852]
  00155	52		 push	 edx
  00156	e8 00 00 00 00	 call	 _ToUNICODE

; 134  : 
; 135  : 		driveLetter = GetDiskDeviceDriveLetter (deviceName);

  0015b	8d 84 24 2c 06
	00 00		 lea	 eax, DWORD PTR _deviceName$[esp+140856]
  00162	50		 push	 eax
  00163	e8 00 00 00 00	 call	 _GetDiskDeviceDriveLetter
  00168	83 c4 08	 add	 esp, 8
  0016b	89 44 24 3c	 mov	 DWORD PTR _driveLetter$[esp+140852], eax
$LN94@TCFormatVo:

; 136  : 	}
; 137  : 
; 138  : 	VirtualLock (header, sizeof (header));

  0016f	68 00 02 00 00	 push	 512			; 00000200H
  00174	8d 8c 24 20 02
	00 00		 lea	 ecx, DWORD PTR _header$[esp+140856]
  0017b	51		 push	 ecx
  0017c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualLock@8

; 139  : 
; 140  : 	nStatus = CreateVolumeHeaderInMemory (FALSE,
; 141  : 				     header,
; 142  : 				     volParams->ea,
; 143  : 					 FIRST_MODE_OF_OPERATION_ID,
; 144  : 				     volParams->password,
; 145  : 				     volParams->pkcs5,
; 146  : 					 NULL,
; 147  : 				     &cryptoInfo,
; 148  : 					 dataAreaSize,
; 149  : 					 volParams->hiddenVol ? dataAreaSize : 0,
; 150  : 					 dataOffset,
; 151  : 					 dataAreaSize,
; 152  : 					 0,
; 153  : 					 volParams->headerFlags,
; 154  : 					 FormatSectorSize,
; 155  : 					 FALSE);

  00182	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00185	85 d2		 test	 edx, edx
  00187	74 06		 je	 SHORT $LN103@TCFormatVo
  00189	8b c5		 mov	 eax, ebp
  0018b	8b cb		 mov	 ecx, ebx
  0018d	eb 04		 jmp	 SHORT $LN104@TCFormatVo
$LN103@TCFormatVo:
  0018f	33 c0		 xor	 eax, eax
  00191	33 c9		 xor	 ecx, ecx
$LN104@TCFormatVo:
  00193	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _FormatSectorSize
  00199	6a 00		 push	 0
  0019b	52		 push	 edx
  0019c	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  0019f	52		 push	 edx
  001a0	8b 54 24 3c	 mov	 edx, DWORD PTR _dataOffset$[esp+140868]
  001a4	6a 00		 push	 0
  001a6	53		 push	 ebx
  001a7	55		 push	 ebp
  001a8	52		 push	 edx
  001a9	8b 54 24 48	 mov	 edx, DWORD PTR _dataOffset$[esp+140880]
  001ad	52		 push	 edx
  001ae	51		 push	 ecx
  001af	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  001b2	8b 56 44	 mov	 edx, DWORD PTR [esi+68]
  001b5	50		 push	 eax
  001b6	53		 push	 ebx
  001b7	55		 push	 ebp
  001b8	8d 44 24 40	 lea	 eax, DWORD PTR _cryptoInfo$[esp+140900]
  001bc	50		 push	 eax
  001bd	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  001c0	6a 00		 push	 0
  001c2	51		 push	 ecx
  001c3	52		 push	 edx
  001c4	6a 01		 push	 1
  001c6	50		 push	 eax
  001c7	8d 8c 24 64 02
	00 00		 lea	 ecx, DWORD PTR _header$[esp+140924]
  001ce	51		 push	 ecx
  001cf	6a 00		 push	 0
  001d1	e8 00 00 00 00	 call	 _CreateVolumeHeaderInMemory
  001d6	8b d8		 mov	 ebx, eax
  001d8	83 c4 50	 add	 esp, 80			; 00000050H

; 156  : 
; 157  : 	if (nStatus != 0)

  001db	85 db		 test	 ebx, ebx
  001dd	74 58		 je	 SHORT $LN163@TCFormatVo

; 158  : 	{
; 159  : 		burn (header, sizeof (header));

  001df	8d 94 24 1c 02
	00 00		 lea	 edx, DWORD PTR _header$[esp+140852]
  001e6	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001eb	8b f1		 mov	 esi, ecx
  001ed	8b c2		 mov	 eax, edx
  001ef	90		 npad	 1
$LL114@TCFormatVo:
  001f0	c6 00 00	 mov	 BYTE PTR [eax], 0
  001f3	40		 inc	 eax
  001f4	83 ee 01	 sub	 esi, 1
  001f7	75 f7		 jne	 SHORT $LL114@TCFormatVo
  001f9	8d a4 24 00 00
	00 00		 npad	 7
$LL89@TCFormatVo:
  00200	49		 dec	 ecx
  00201	c6 02 00	 mov	 BYTE PTR [edx], 0
  00204	42		 inc	 edx
  00205	85 c9		 test	 ecx, ecx
  00207	75 f7		 jne	 SHORT $LL89@TCFormatVo

; 160  : 		VirtualUnlock (header, sizeof (header));

  00209	68 00 02 00 00	 push	 512			; 00000200H
  0020e	8d 94 24 20 02
	00 00		 lea	 edx, DWORD PTR _header$[esp+140856]
  00215	52		 push	 edx
  00216	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualUnlock@8

; 161  : 		return nStatus;

  0021c	8b c3		 mov	 eax, ebx
$LN196@TCFormatVo:
  0021e	5d		 pop	 ebp
  0021f	5f		 pop	 edi
  00220	5e		 pop	 esi
  00221	5b		 pop	 ebx

; 675  : }

  00222	8b 8c 24 20 26
	02 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+140836]
  00229	33 cc		 xor	 ecx, esp
  0022b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00230	81 c4 24 26 02
	00		 add	 esp, 140836		; 00022624H
  00236	c3		 ret	 0
$LN163@TCFormatVo:

; 162  : 	}
; 163  : 
; 164  : begin_format:
; 165  : 
; 166  : 	if (volParams->bDevice)

  00237	8b 06		 mov	 eax, DWORD PTR [esi]
  00239	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__DefineDosDeviceA@12
  0023f	90		 npad	 1
$begin_format$80549:
  00240	85 c0		 test	 eax, eax
  00242	0f 84 9e 03 00
	00		 je	 $LN87@TCFormatVo

; 167  : 	{
; 168  : 		/* Device-hosted volume */
; 169  : 
; 170  : 		DWORD dwResult;
; 171  : 		int nPass;
; 172  : 
; 173  : 		if (FakeDosNameForDevice (volParams->volumePath, dosDev, devName, FALSE) != 0)

  00248	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0024b	6a 00		 push	 0
  0024d	8d 8c 24 1c 01
	00 00		 lea	 ecx, DWORD PTR _devName$[esp+140856]
  00254	51		 push	 ecx
  00255	8d 94 24 24 04
	00 00		 lea	 edx, DWORD PTR _dosDev$[esp+140860]
  0025c	52		 push	 edx
  0025d	50		 push	 eax
  0025e	e8 00 00 00 00	 call	 _FakeDosNameForDevice
  00263	83 c4 10	 add	 esp, 16			; 00000010H
  00266	85 c0		 test	 eax, eax
  00268	0f 85 62 09 00
	00		 jne	 $LN132@TCFormatVo

; 175  : 
; 176  : 		if (IsDeviceMounted (devName))

  0026e	8d 8c 24 18 01
	00 00		 lea	 ecx, DWORD PTR _devName$[esp+140852]
  00275	51		 push	 ecx
  00276	e8 00 00 00 00	 call	 _IsDeviceMounted
  0027b	83 c4 04	 add	 esp, 4
  0027e	85 c0		 test	 eax, eax
  00280	74 62		 je	 SHORT $LN85@TCFormatVo

; 177  : 		{
; 178  : 			if ((dev = DismountDrive (devName, volParams->volumePath)) == INVALID_HANDLE_VALUE)

  00282	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00285	52		 push	 edx
  00286	8d 84 24 1c 01
	00 00		 lea	 eax, DWORD PTR _devName$[esp+140856]
  0028d	50		 push	 eax
  0028e	e8 00 00 00 00	 call	 _DismountDrive
  00293	8b f8		 mov	 edi, eax
  00295	83 c4 08	 add	 esp, 8
  00298	83 ff ff	 cmp	 edi, -1
  0029b	75 17		 jne	 SHORT $LN84@TCFormatVo
$LN200@TCFormatVo:

; 179  : 			{
; 180  : 				Error ("FORMAT_CANT_DISMOUNT_FILESYS");

  0029d	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@NJIOHEOP@FORMAT_CANT_DISMOUNT_FILESYS?$AA@
  002a2	e8 00 00 00 00	 call	 _Error
  002a7	83 c4 04	 add	 esp, 4
$LN129@TCFormatVo:

; 181  : 				nStatus = ERR_DONT_REPORT; 

  002aa	bd 1c 00 00 00	 mov	 ebp, 28			; 0000001cH

; 182  : 				goto error;

  002af	e9 21 07 00 00	 jmp	 $error$80559
$LN84@TCFormatVo:

; 183  : 			}
; 184  : 
; 185  : 			/* Gain "raw" access to the partition (it contains a live filesystem and the filesystem driver 
; 186  : 			would otherwise prevent us from writing to hidden sectors). */
; 187  : 
; 188  : 			if (!DeviceIoControl (dev,
; 189  : 				FSCTL_ALLOW_EXTENDED_DASD_IO,
; 190  : 				NULL,
; 191  : 				0,   
; 192  : 				NULL,
; 193  : 				0,
; 194  : 				&dwResult,
; 195  : 				NULL))

  002b4	6a 00		 push	 0
  002b6	8d 4c 24 44	 lea	 ecx, DWORD PTR _dwResult$80551[esp+140856]
  002ba	51		 push	 ecx
  002bb	6a 00		 push	 0
  002bd	6a 00		 push	 0
  002bf	6a 00		 push	 0
  002c1	6a 00		 push	 0
  002c3	68 83 00 09 00	 push	 589955			; 00090083H
  002c8	57		 push	 edi
  002c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  002cf	85 c0		 test	 eax, eax
  002d1	0f 85 dc 00 00
	00		 jne	 $LN183@TCFormatVo

; 196  : 			{
; 197  : 				bFailedRequiredDASD = TRUE;

  002d7	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR _bFailedRequiredDASD$[esp+140852], 1

; 198  : 			}

  002df	e9 cf 00 00 00	 jmp	 $LN183@TCFormatVo
$LN85@TCFormatVo:

; 199  : 		}
; 200  : 		else if (IsOSAtLeast (WIN_VISTA) && driveLetter == -1)

  002e4	6a 0b		 push	 11			; 0000000bH
  002e6	e8 00 00 00 00	 call	 _IsOSAtLeast
  002eb	83 c4 04	 add	 esp, 4
  002ee	85 c0		 test	 eax, eax
  002f0	0f 84 bd 00 00
	00		 je	 $LN183@TCFormatVo
  002f6	83 7c 24 3c ff	 cmp	 DWORD PTR _driveLetter$[esp+140852], -1
  002fb	0f 85 b2 00 00
	00		 jne	 $LN183@TCFormatVo

; 201  : 		{
; 202  : 			// Windows Vista doesn't allow overwriting sectors belonging to an unformatted partition 
; 203  : 			// to which no drive letter has been assigned under the system. This problem can be worked
; 204  : 			// around by assigning a drive letter to the partition temporarily.
; 205  : 
; 206  : 			char szDriveLetter[] = { 'A', ':', 0 };
; 207  : 			char rootPath[] = { 'A', ':', '\\', 0 };
; 208  : 			char uniqVolName[MAX_PATH+1] = { 0 };

  00301	68 04 01 00 00	 push	 260			; 00000104H
  00306	8d 94 24 25 05
	00 00		 lea	 edx, DWORD PTR _uniqVolName$80568[esp+140857]
  0030d	6a 00		 push	 0
  0030f	52		 push	 edx
  00310	c6 44 24 20 41	 mov	 BYTE PTR _szDriveLetter$80566[esp+140864], 65 ; 00000041H
  00315	c6 44 24 21 3a	 mov	 BYTE PTR _szDriveLetter$80566[esp+140865], 58 ; 0000003aH
  0031a	c6 44 24 22 00	 mov	 BYTE PTR _szDriveLetter$80566[esp+140866], 0
  0031f	c6 44 24 24 41	 mov	 BYTE PTR _rootPath$80567[esp+140864], 65 ; 00000041H
  00324	c6 44 24 25 3a	 mov	 BYTE PTR _rootPath$80567[esp+140865], 58 ; 0000003aH
  00329	c6 44 24 26 5c	 mov	 BYTE PTR _rootPath$80567[esp+140866], 92 ; 0000005cH
  0032e	c6 44 24 27 00	 mov	 BYTE PTR _rootPath$80567[esp+140867], 0
  00333	c6 84 24 2c 05
	00 00 00	 mov	 BYTE PTR _uniqVolName$80568[esp+140864], 0
  0033b	e8 00 00 00 00	 call	 _memset
  00340	83 c4 0c	 add	 esp, 12			; 0000000cH

; 209  : 			int tmpDriveLetter = -1;
; 210  : 			BOOL bResult = FALSE;
; 211  : 
; 212  : 			tmpDriveLetter = GetFirstAvailableDrive ();

  00343	e8 00 00 00 00	 call	 _GetFirstAvailableDrive

; 213  :  
; 214  : 			if (tmpDriveLetter != -1)

  00348	83 f8 ff	 cmp	 eax, -1
  0034b	74 66		 je	 SHORT $LN183@TCFormatVo

; 215  : 			{
; 216  : 				rootPath[0] += (char) tmpDriveLetter;

  0034d	00 44 24 18	 add	 BYTE PTR _rootPath$80567[esp+140852], al

; 217  : 				szDriveLetter[0] += (char) tmpDriveLetter;

  00351	00 44 24 14	 add	 BYTE PTR _szDriveLetter$80566[esp+140852], al

; 218  : 
; 219  : 				if (DefineDosDevice (DDD_RAW_TARGET_PATH, szDriveLetter, volParams->volumePath))

  00355	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00358	50		 push	 eax
  00359	8d 4c 24 18	 lea	 ecx, DWORD PTR _szDriveLetter$80566[esp+140856]
  0035d	51		 push	 ecx
  0035e	6a 01		 push	 1
  00360	ff d3		 call	 ebx
  00362	85 c0		 test	 eax, eax
  00364	74 4d		 je	 SHORT $LN183@TCFormatVo

; 220  : 				{
; 221  : 					bResult = GetVolumeNameForVolumeMountPoint (rootPath, uniqVolName, MAX_PATH);

  00366	68 04 01 00 00	 push	 260			; 00000104H
  0036b	8d 94 24 24 05
	00 00		 lea	 edx, DWORD PTR _uniqVolName$80568[esp+140856]
  00372	52		 push	 edx
  00373	8d 44 24 20	 lea	 eax, DWORD PTR _rootPath$80567[esp+140860]
  00377	50		 push	 eax
  00378	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVolumeNameForVolumeMountPointA@12

; 222  : 
; 223  : 					DefineDosDevice (DDD_RAW_TARGET_PATH|DDD_REMOVE_DEFINITION|DDD_EXACT_MATCH_ON_REMOVE,
; 224  : 						szDriveLetter,
; 225  : 						volParams->volumePath);

  0037e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00381	51		 push	 ecx
  00382	8d 54 24 18	 lea	 edx, DWORD PTR _szDriveLetter$80566[esp+140856]
  00386	52		 push	 edx
  00387	6a 07		 push	 7
  00389	8b e8		 mov	 ebp, eax
  0038b	ff d3		 call	 ebx

; 226  : 
; 227  : 					if (bResult 
; 228  : 						&& SetVolumeMountPoint (rootPath, uniqVolName))

  0038d	85 ed		 test	 ebp, ebp
  0038f	74 22		 je	 SHORT $LN183@TCFormatVo
  00391	8d 84 24 20 05
	00 00		 lea	 eax, DWORD PTR _uniqVolName$80568[esp+140852]
  00398	50		 push	 eax
  00399	8d 4c 24 1c	 lea	 ecx, DWORD PTR _rootPath$80567[esp+140856]
  0039d	51		 push	 ecx
  0039e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetVolumeMountPointA@8
  003a4	85 c0		 test	 eax, eax
  003a6	74 0b		 je	 SHORT $LN183@TCFormatVo

; 229  : 					{
; 230  : 						// The drive letter can be removed now
; 231  : 						DeleteVolumeMountPoint (rootPath);

  003a8	8d 54 24 18	 lea	 edx, DWORD PTR _rootPath$80567[esp+140852]
  003ac	52		 push	 edx
  003ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteVolumeMountPointA@4
$LN183@TCFormatVo:

; 232  : 					}
; 233  : 				}
; 234  : 			}
; 235  : 		}
; 236  : 
; 237  : 		// For extra safety, we will try to gain "raw" access to the partition. Note that this should actually be
; 238  : 		// redundant because if the filesystem was mounted, we already tried to obtain DASD above. If we failed,
; 239  : 		// bFailedRequiredDASD was set to TRUE and therefore we will perform pseudo "quick format" below. However, 
; 240  : 		// for extra safety, in case IsDeviceMounted() failed to detect a live filesystem, we will blindly
; 241  : 		// send FSCTL_ALLOW_EXTENDED_DASD_IO (possibly for a second time) without checking the result.
; 242  : 
; 243  : 		DeviceIoControl (dev,
; 244  : 			FSCTL_ALLOW_EXTENDED_DASD_IO,
; 245  : 			NULL,
; 246  : 			0,   
; 247  : 			NULL,
; 248  : 			0,
; 249  : 			&dwResult,
; 250  : 			NULL);

  003b3	6a 00		 push	 0
  003b5	8d 44 24 44	 lea	 eax, DWORD PTR _dwResult$80551[esp+140856]
  003b9	50		 push	 eax
  003ba	6a 00		 push	 0
  003bc	6a 00		 push	 0
  003be	6a 00		 push	 0
  003c0	6a 00		 push	 0
  003c2	68 83 00 09 00	 push	 589955			; 00090083H
  003c7	57		 push	 edi
  003c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32

; 251  : 
; 252  : 
; 253  : 		// If DASD is needed but we failed to obtain it, perform open - 'quick format' - close - open 
; 254  : 		// so that the filesystem driver does not prevent us from formatting hidden sectors.
; 255  : 		for (nPass = (bFailedRequiredDASD ? 0 : 1); nPass < 2; nPass++)

  003ce	33 c0		 xor	 eax, eax
  003d0	39 44 24 38	 cmp	 DWORD PTR _bFailedRequiredDASD$[esp+140852], eax
  003d4	0f 94 c0	 sete	 al
  003d7	83 f8 02	 cmp	 eax, 2
  003da	89 44 24 28	 mov	 DWORD PTR _nPass$80552[esp+140852], eax
  003de	0f 8d 1b 01 00
	00		 jge	 $LN66@TCFormatVo
  003e4	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__CreateFileA@28
  003ea	8d 9b 00 00 00
	00		 npad	 6
$LL77@TCFormatVo:

; 256  : 		{
; 257  : 			int retryCount;
; 258  : 
; 259  : 			retryCount = 0;

  003f0	33 ed		 xor	 ebp, ebp

; 260  : 
; 261  : 			// Try exclusive access mode first
; 262  : 			// Note that when exclusive access is denied, it is worth retrying (usually succeeds after a few tries).
; 263  : 			while (dev == INVALID_HANDLE_VALUE && retryCount++ < EXCL_ACCESS_MAX_AUTO_RETRIES)

  003f2	83 ff ff	 cmp	 edi, -1
  003f5	0f 85 95 00 00
	00		 jne	 $LN69@TCFormatVo
  003fb	eb 03 8d 49 00	 npad	 5
$LL74@TCFormatVo:
  00400	8b cd		 mov	 ecx, ebp
  00402	45		 inc	 ebp
  00403	81 f9 f4 01 00
	00		 cmp	 ecx, 500		; 000001f4H
  00409	7d 2f		 jge	 SHORT $LN73@TCFormatVo

; 264  : 			{
; 265  : 				dev = CreateFile (devName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);

  0040b	6a 00		 push	 0
  0040d	6a 00		 push	 0
  0040f	6a 03		 push	 3
  00411	6a 00		 push	 0
  00413	6a 00		 push	 0
  00415	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  0041a	8d 94 24 30 01
	00 00		 lea	 edx, DWORD PTR _devName$[esp+140876]
  00421	52		 push	 edx
  00422	ff d3		 call	 ebx

; 266  : 
; 267  : 				if (retryCount > 1)

  00424	83 fd 01	 cmp	 ebp, 1
  00427	8b f8		 mov	 edi, eax
  00429	7e 08		 jle	 SHORT $LN72@TCFormatVo

; 268  : 					Sleep (EXCL_ACCESS_AUTO_RETRY_DELAY);

  0042b	6a 0a		 push	 10			; 0000000aH
  0042d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
$LN72@TCFormatVo:

; 260  : 
; 261  : 			// Try exclusive access mode first
; 262  : 			// Note that when exclusive access is denied, it is worth retrying (usually succeeds after a few tries).
; 263  : 			while (dev == INVALID_HANDLE_VALUE && retryCount++ < EXCL_ACCESS_MAX_AUTO_RETRIES)

  00433	83 ff ff	 cmp	 edi, -1
  00436	74 c8		 je	 SHORT $LL74@TCFormatVo

; 269  : 			}
; 270  : 
; 271  : 			if (dev == INVALID_HANDLE_VALUE)

  00438	eb 56		 jmp	 SHORT $LN69@TCFormatVo
$LN73@TCFormatVo:
  0043a	83 ff ff	 cmp	 edi, -1
  0043d	75 51		 jne	 SHORT $LN69@TCFormatVo

; 272  : 			{
; 273  : 				// Exclusive access denied -- retry in shared mode
; 274  : 				dev = CreateFile (devName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);

  0043f	6a 00		 push	 0
  00441	6a 00		 push	 0
  00443	6a 03		 push	 3
  00445	6a 00		 push	 0
  00447	6a 03		 push	 3
  00449	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  0044e	8d 84 24 30 01
	00 00		 lea	 eax, DWORD PTR _devName$[esp+140876]
  00455	50		 push	 eax
  00456	ff d3		 call	 ebx
  00458	8b f8		 mov	 edi, eax

; 275  : 				if (dev != INVALID_HANDLE_VALUE)

  0045a	83 ff ff	 cmp	 edi, -1
  0045d	0f 84 63 01 00
	00		 je	 $LN70@TCFormatVo

; 276  : 				{
; 277  : 					if (IDNO == MessageBoxW (volParams->hwndDlg, GetString ("DEVICE_IN_USE_FORMAT"), lpszTitle, MB_YESNO|MB_ICONWARNING|MB_DEFBUTTON2))

  00463	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpszTitle
  00469	68 34 01 00 00	 push	 308			; 00000134H
  0046e	51		 push	 ecx
  0046f	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@LPDGKFHG@DEVICE_IN_USE_FORMAT?$AA@
  00474	e8 00 00 00 00	 call	 _GetString
  00479	8b 56 48	 mov	 edx, DWORD PTR [esi+72]
  0047c	83 c4 04	 add	 esp, 4
  0047f	50		 push	 eax
  00480	52		 push	 edx
  00481	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
  00487	83 f8 07	 cmp	 eax, 7
  0048a	0f 84 1a fe ff
	ff		 je	 $LN129@TCFormatVo
$LN69@TCFormatVo:

; 289  : 				}
; 290  : 			}
; 291  : 
; 292  : 			if (volParams->hiddenVol || bInstantRetryOtherFilesys)

  00490	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00493	85 c0		 test	 eax, eax
  00495	75 68		 jne	 SHORT $LN66@TCFormatVo
  00497	39 44 24 1c	 cmp	 DWORD PTR _bInstantRetryOtherFilesys$[esp+140852], eax
  0049b	75 62		 jne	 SHORT $LN66@TCFormatVo

; 293  : 				break;	// The following "quick format" operation would damage the outer volume
; 294  : 
; 295  : 			if (nPass == 0)

  0049d	39 44 24 28	 cmp	 DWORD PTR _nPass$80552[esp+140852], eax
  004a1	75 4a		 jne	 SHORT $LN76@TCFormatVo

; 296  : 			{
; 297  : 				char buf [2 * TC_MAX_VOLUME_SECTOR_SIZE];
; 298  : 				DWORD bw;
; 299  : 
; 300  : 				// Perform pseudo "quick format" so that the filesystem driver does not prevent us from 
; 301  : 				// formatting hidden sectors
; 302  : 				memset (buf, 0, sizeof (buf));

  004a3	68 00 20 00 00	 push	 8192			; 00002000H
  004a8	50		 push	 eax
  004a9	8d 8c 24 38 08
	00 00		 lea	 ecx, DWORD PTR _buf$80606[esp+140860]
  004b0	51		 push	 ecx
  004b1	e8 00 00 00 00	 call	 _memset
  004b6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 303  : 
; 304  : 				if (!WriteFile (dev, buf, sizeof (buf), &bw, NULL))

  004b9	6a 00		 push	 0
  004bb	8d 54 24 70	 lea	 edx, DWORD PTR _bw$80607[esp+140856]
  004bf	52		 push	 edx
  004c0	68 00 20 00 00	 push	 8192			; 00002000H
  004c5	8d 84 24 3c 08
	00 00		 lea	 eax, DWORD PTR _buf$80606[esp+140864]
  004cc	50		 push	 eax
  004cd	57		 push	 edi
  004ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  004d4	85 c0		 test	 eax, eax
  004d6	0f 84 53 01 00
	00		 je	 $LN131@TCFormatVo

; 305  : 				{
; 306  : 					nStatus = ERR_OS_ERROR; 
; 307  : 					goto error;
; 308  : 				}
; 309  : 
; 310  : 				FlushFileBuffers (dev);

  004dc	57		 push	 edi
  004dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FlushFileBuffers@4

; 311  : 				CloseHandle (dev);

  004e3	57		 push	 edi
  004e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 312  : 				dev = INVALID_HANDLE_VALUE;

  004ea	83 cf ff	 or	 edi, -1
$LN76@TCFormatVo:
  004ed	8b 44 24 28	 mov	 eax, DWORD PTR _nPass$80552[esp+140852]
  004f1	40		 inc	 eax
  004f2	83 f8 02	 cmp	 eax, 2
  004f5	89 44 24 28	 mov	 DWORD PTR _nPass$80552[esp+140852], eax
  004f9	0f 8c f1 fe ff
	ff		 jl	 $LL77@TCFormatVo
$LN66@TCFormatVo:

; 313  : 			}
; 314  : 		}
; 315  : 
; 316  : 		if (DeviceIoControl (dev, FSCTL_IS_VOLUME_MOUNTED, NULL, 0, NULL, 0, &dwResult, NULL))

  004ff	6a 00		 push	 0
  00501	8d 54 24 44	 lea	 edx, DWORD PTR _dwResult$80551[esp+140856]
  00505	52		 push	 edx
  00506	6a 00		 push	 0
  00508	6a 00		 push	 0
  0050a	6a 00		 push	 0
  0050c	6a 00		 push	 0
  0050e	68 28 00 09 00	 push	 589864			; 00090028H
  00513	57		 push	 edi
  00514	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  0051a	85 c0		 test	 eax, eax
  0051c	0f 85 7b fd ff
	ff		 jne	 $LN200@TCFormatVo
$LN57@TCFormatVo:

; 362  : 			}
; 363  : 		}
; 364  : 	}
; 365  : 
; 366  : 	if (volParams->hiddenVol && !volParams->bDevice && bPreserveTimestamp)

  00522	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00525	85 d2		 test	 edx, edx
  00527	74 2e		 je	 SHORT $LN170@TCFormatVo
  00529	8b 06		 mov	 eax, DWORD PTR [esi]
  0052b	85 c0		 test	 eax, eax
  0052d	75 28		 jne	 SHORT $LN170@TCFormatVo
  0052f	39 05 00 00 00
	00		 cmp	 DWORD PTR _bPreserveTimestamp, eax
  00535	74 20		 je	 SHORT $LN170@TCFormatVo

; 367  : 	{
; 368  : 		if (GetFileTime ((HANDLE) dev, &ftCreationTime, &ftLastAccessTime, &ftLastWriteTime) == 0)

  00537	8d 4c 24 50	 lea	 ecx, DWORD PTR _ftLastWriteTime$[esp+140852]
  0053b	51		 push	 ecx
  0053c	8d 54 24 5c	 lea	 edx, DWORD PTR _ftLastAccessTime$[esp+140856]
  00540	52		 push	 edx
  00541	8d 44 24 68	 lea	 eax, DWORD PTR _ftCreationTime$[esp+140860]
  00545	50		 push	 eax
  00546	57		 push	 edi
  00547	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileTime@16
  0054d	f7 d8		 neg	 eax
  0054f	1b c0		 sbb	 eax, eax
  00551	f7 d8		 neg	 eax
  00553	89 44 24 34	 mov	 DWORD PTR _bTimeStampValid$[esp+140852], eax
$LN170@TCFormatVo:

; 369  : 			bTimeStampValid = FALSE;
; 370  : 		else
; 371  : 			bTimeStampValid = TRUE;
; 372  : 	}
; 373  : 
; 374  : 	KillTimer (volParams->hwndDlg, TIMER_ID_RANDVIEW);

  00557	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  0055a	68 ff 00 00 00	 push	 255			; 000000ffH
  0055f	51		 push	 ecx
  00560	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8

; 375  : 
; 376  : 	/* Volume header */
; 377  : 
; 378  : 	// Hidden volume setup
; 379  : 	if (volParams->hiddenVol)

  00566	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00569	85 d2		 test	 edx, edx
  0056b	0f 84 65 01 00
	00		 je	 $LN52@TCFormatVo

; 380  : 	{
; 381  : 		LARGE_INTEGER headerOffset;
; 382  : 
; 383  : 		// Check hidden volume size
; 384  : 		if (volParams->hiddenVolHostSize < TC_MIN_HIDDEN_VOLUME_HOST_SIZE || volParams->hiddenVolHostSize > TC_MAX_HIDDEN_VOLUME_HOST_SIZE)

  00571	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00574	83 7e 1c 00	 cmp	 DWORD PTR [esi+28], 0
  00578	77 0b		 ja	 SHORT $LN158@TCFormatVo
  0057a	3d 00 50 05 00	 cmp	 eax, 348160		; 00055000H
  0057f	0f 82 16 02 00
	00		 jb	 $LN50@TCFormatVo
$LN158@TCFormatVo:
  00585	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00588	81 7e 1c ff 7f
	00 00		 cmp	 DWORD PTR [esi+28], 32767 ; 00007fffH
  0058f	0f 87 06 02 00
	00		 ja	 $LN50@TCFormatVo
  00595	72 0b		 jb	 SHORT $LN159@TCFormatVo
  00597	3d 00 00 fc ff	 cmp	 eax, -262144		; fffc0000H
  0059c	0f 87 f9 01 00
	00		 ja	 $LN50@TCFormatVo
$LN159@TCFormatVo:

; 385  : 		{		
; 386  : 			nStatus = ERR_VOL_SIZE_WRONG;
; 387  : 			goto error;
; 388  : 		}
; 389  : 
; 390  : 		// Seek to hidden volume header location
; 391  : 		
; 392  : 		headerOffset.QuadPart = TC_HIDDEN_VOLUME_HEADER_OFFSET;

  005a2	b8 00 00 01 00	 mov	 eax, 65536		; 00010000H
$LN201@TCFormatVo:
  005a7	33 c9		 xor	 ecx, ecx

; 393  : 
; 394  : 		if (!SetFilePointerEx ((HANDLE) dev, headerOffset, NULL, FILE_BEGIN))

  005a9	51		 push	 ecx
  005aa	51		 push	 ecx
  005ab	51		 push	 ecx
  005ac	50		 push	 eax
  005ad	57		 push	 edi
  005ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  005b4	85 c0		 test	 eax, eax
  005b6	0f 85 2b 01 00
	00		 jne	 $LN172@TCFormatVo
$LN202@TCFormatVo:

; 395  : 		{
; 396  : 			nStatus = ERR_OS_ERROR;

  005bc	bd 01 00 00 00	 mov	 ebp, 1

; 397  : 			goto error;

  005c1	e9 0f 04 00 00	 jmp	 $error$80559
$LN70@TCFormatVo:

; 278  : 					{
; 279  : 						nStatus = ERR_DONT_REPORT; 
; 280  : 						goto error;
; 281  : 					}
; 282  : 				}
; 283  : 				else
; 284  : 				{
; 285  : 					handleWin32Error (volParams->hwndDlg);

  005c6	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  005c9	51		 push	 ecx
  005ca	e8 00 00 00 00	 call	 _handleWin32Error

; 286  : 					Error ("CANT_ACCESS_VOL");

  005cf	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@GFCNKOPI@CANT_ACCESS_VOL?$AA@
  005d4	e8 00 00 00 00	 call	 _Error
  005d9	83 c4 08	 add	 esp, 8

; 287  : 					nStatus = ERR_DONT_REPORT; 

  005dc	bd 1c 00 00 00	 mov	 ebp, 28			; 0000001cH

; 288  : 					goto error;

  005e1	e9 ef 03 00 00	 jmp	 $error$80559
$LN87@TCFormatVo:

; 317  : 		{
; 318  : 			Error ("FORMAT_CANT_DISMOUNT_FILESYS");
; 319  : 			nStatus = ERR_DONT_REPORT; 
; 320  : 			goto error;
; 321  : 		}
; 322  : 	}
; 323  : 	else
; 324  : 	{
; 325  : 		/* File-hosted volume */
; 326  : 
; 327  : 		dev = CreateFile (volParams->volumePath, GENERIC_READ | GENERIC_WRITE,
; 328  : 			(volParams->hiddenVol || bInstantRetryOtherFilesys) ? (FILE_SHARE_READ | FILE_SHARE_WRITE) : 0,
; 329  : 			NULL, (volParams->hiddenVol || bInstantRetryOtherFilesys) ? OPEN_EXISTING : CREATE_ALWAYS, 0, NULL);

  005e6	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  005e9	85 c0		 test	 eax, eax
  005eb	75 09		 jne	 SHORT $LN187@TCFormatVo
  005ed	8d 48 02	 lea	 ecx, DWORD PTR [eax+2]
  005f0	39 44 24 1c	 cmp	 DWORD PTR _bInstantRetryOtherFilesys$[esp+140852], eax
  005f4	74 05		 je	 SHORT $LN106@TCFormatVo
$LN187@TCFormatVo:
  005f6	b9 03 00 00 00	 mov	 ecx, 3
$LN106@TCFormatVo:
  005fb	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  005fe	85 d2		 test	 edx, edx
  00600	75 0a		 jne	 SHORT $LN189@TCFormatVo
  00602	39 54 24 1c	 cmp	 DWORD PTR _bInstantRetryOtherFilesys$[esp+140852], edx
  00606	75 04		 jne	 SHORT $LN189@TCFormatVo
  00608	33 c0		 xor	 eax, eax
  0060a	eb 05		 jmp	 SHORT $LN108@TCFormatVo
$LN189@TCFormatVo:
  0060c	b8 03 00 00 00	 mov	 eax, 3
$LN108@TCFormatVo:
  00611	6a 00		 push	 0
  00613	6a 00		 push	 0
  00615	51		 push	 ecx
  00616	6a 00		 push	 0
  00618	50		 push	 eax
  00619	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0061c	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  00621	50		 push	 eax
  00622	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00628	8b f8		 mov	 edi, eax

; 330  : 
; 331  : 		if (dev == INVALID_HANDLE_VALUE)

  0062a	83 ff ff	 cmp	 edi, -1
  0062d	75 0a		 jne	 SHORT $LN61@TCFormatVo
$LN131@TCFormatVo:

; 332  : 		{
; 333  : 			nStatus = ERR_OS_ERROR; 

  0062f	bd 01 00 00 00	 mov	 ebp, 1

; 334  : 			goto error;

  00634	e9 9c 03 00 00	 jmp	 $error$80559
$LN61@TCFormatVo:

; 335  : 		}
; 336  : 
; 337  : 		DisableFileCompression (dev);

  00639	57		 push	 edi
  0063a	e8 00 00 00 00	 call	 _DisableFileCompression

; 338  : 
; 339  : 		if (!volParams->hiddenVol && !bInstantRetryOtherFilesys)

  0063f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00642	83 c4 04	 add	 esp, 4
  00645	85 c9		 test	 ecx, ecx
  00647	0f 85 d5 fe ff
	ff		 jne	 $LN57@TCFormatVo
  0064d	39 4c 24 1c	 cmp	 DWORD PTR _bInstantRetryOtherFilesys$[esp+140852], ecx
  00651	0f 85 cb fe ff
	ff		 jne	 $LN57@TCFormatVo

; 340  : 		{
; 341  : 			LARGE_INTEGER volumeSize;
; 342  : 			volumeSize.QuadPart = dataAreaSize + TC_VOLUME_HEADER_GROUP_SIZE;

  00657	8b 6c 24 20	 mov	 ebp, DWORD PTR _dataAreaSize$[esp+140852]
  0065b	8b 5c 24 24	 mov	 ebx, DWORD PTR _dataAreaSize$[esp+140856]

; 343  : 
; 344  : 			if (volParams->sparseFileSwitch && volParams->quickFormat)

  0065f	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  00662	81 c5 00 00 02
	00		 add	 ebp, 131072		; 00020000H
  00668	13 d9		 adc	 ebx, ecx
  0066a	85 d2		 test	 edx, edx
  0066c	74 2d		 je	 SHORT $LN58@TCFormatVo
  0066e	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00671	85 c0		 test	 eax, eax
  00673	74 26		 je	 SHORT $LN58@TCFormatVo

; 345  : 			{
; 346  : 				// Create as sparse file container
; 347  : 				DWORD tmp;
; 348  : 				if (!DeviceIoControl (dev, FSCTL_SET_SPARSE, NULL, 0, NULL, 0, &tmp, NULL))

  00675	51		 push	 ecx
  00676	8d 4c 24 6c	 lea	 ecx, DWORD PTR _tmp$80625[esp+140856]
  0067a	51		 push	 ecx
  0067b	6a 00		 push	 0
  0067d	6a 00		 push	 0
  0067f	6a 00		 push	 0
  00681	6a 00		 push	 0
  00683	68 c4 00 09 00	 push	 590020			; 000900c4H
  00688	57		 push	 edi
  00689	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  0068f	85 c0		 test	 eax, eax
  00691	75 08		 jne	 SHORT $LN58@TCFormatVo

; 349  : 				{
; 350  : 					nStatus = ERR_OS_ERROR; 

  00693	8d 68 01	 lea	 ebp, DWORD PTR [eax+1]

; 351  : 					goto error;

  00696	e9 3a 03 00 00	 jmp	 $error$80559
$LN58@TCFormatVo:

; 352  : 				}
; 353  : 			}
; 354  : 
; 355  : 			// Preallocate the file
; 356  : 			if (!SetFilePointerEx (dev, volumeSize, NULL, FILE_BEGIN)
; 357  : 				|| !SetEndOfFile (dev)
; 358  : 				|| SetFilePointer (dev, 0, NULL, FILE_BEGIN) != 0)

  0069b	6a 00		 push	 0
  0069d	6a 00		 push	 0
  0069f	53		 push	 ebx
  006a0	55		 push	 ebp
  006a1	57		 push	 edi
  006a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  006a8	85 c0		 test	 eax, eax
  006aa	74 20		 je	 SHORT $LN168@TCFormatVo
  006ac	57		 push	 edi
  006ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEndOfFile@4
  006b3	85 c0		 test	 eax, eax
  006b5	74 15		 je	 SHORT $LN168@TCFormatVo
  006b7	6a 00		 push	 0
  006b9	6a 00		 push	 0
  006bb	6a 00		 push	 0
  006bd	57		 push	 edi
  006be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointer@16
  006c4	85 c0		 test	 eax, eax
  006c6	0f 84 56 fe ff
	ff		 je	 $LN57@TCFormatVo
$LN168@TCFormatVo:

; 359  : 			{
; 360  : 				nStatus = ERR_OS_ERROR;

  006cc	bd 01 00 00 00	 mov	 ebp, 1

; 361  : 				goto error;

  006d1	e9 ff 02 00 00	 jmp	 $error$80559
$LN52@TCFormatVo:

; 398  : 		}
; 399  : 	}
; 400  : 	else if (bInstantRetryOtherFilesys)

  006d6	83 7c 24 1c 00	 cmp	 DWORD PTR _bInstantRetryOtherFilesys$[esp+140852], 0
  006db	74 11		 je	 SHORT $LN174@TCFormatVo

; 401  : 	{
; 402  : 		// The previous file system format failed and the user wants to try again with a different file system.
; 403  : 		// The volume header had been written successfully so we need to seek to the byte after the header.
; 404  : 
; 405  : 		LARGE_INTEGER offset;
; 406  : 		offset.QuadPart = TC_VOLUME_DATA_OFFSET;

  006dd	b8 00 00 02 00	 mov	 eax, 131072		; 00020000H

; 407  : 		if (!SetFilePointerEx ((HANDLE) dev, offset, NULL, FILE_BEGIN))
; 408  : 		{
; 409  : 			nStatus = ERR_OS_ERROR;
; 410  : 			goto error;

  006e2	e9 c0 fe ff ff	 jmp	 $LN201@TCFormatVo
$LN172@TCFormatVo:

; 411  : 		}
; 412  : 	}
; 413  : 
; 414  : 	if (!bInstantRetryOtherFilesys)

  006e7	83 7c 24 1c 00	 cmp	 DWORD PTR _bInstantRetryOtherFilesys$[esp+140852], 0
  006ec	75 76		 jne	 SHORT $LN41@TCFormatVo
$LN174@TCFormatVo:

; 415  : 	{
; 416  : 		// Write the volume header
; 417  : 		if (!WriteEffectiveVolumeHeader (volParams->bDevice, dev, header))

  006ee	8b 0e		 mov	 ecx, DWORD PTR [esi]
  006f0	8d 84 24 1c 02
	00 00		 lea	 eax, DWORD PTR _header$[esp+140852]
  006f7	50		 push	 eax
  006f8	57		 push	 edi
  006f9	51		 push	 ecx
  006fa	e8 00 00 00 00	 call	 _WriteEffectiveVolumeHeader
  006ff	83 c4 0c	 add	 esp, 12			; 0000000cH
  00702	85 c0		 test	 eax, eax

; 418  : 		{
; 419  : 			nStatus = ERR_OS_ERROR;
; 420  : 			goto error;

  00704	0f 84 b2 fe ff
	ff		 je	 $LN202@TCFormatVo

; 421  : 		}
; 422  : 
; 423  : 		// To prevent fragmentation, write zeroes to reserved header sectors which are going to be filled with random data
; 424  : 		if (!volParams->bDevice && !volParams->hiddenVol)

  0070a	8b 16		 mov	 edx, DWORD PTR [esi]
  0070c	85 d2		 test	 edx, edx
  0070e	75 54		 jne	 SHORT $LN41@TCFormatVo
  00710	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00713	85 c0		 test	 eax, eax
  00715	75 4d		 jne	 SHORT $LN41@TCFormatVo

; 425  : 		{
; 426  : 			byte buf[TC_VOLUME_HEADER_GROUP_SIZE - TC_VOLUME_HEADER_EFFECTIVE_SIZE];
; 427  : 			DWORD bytesWritten;
; 428  : 			ZeroMemory (buf, sizeof (buf));

  00717	68 00 fe 01 00	 push	 130560			; 0001fe00H
  0071c	50		 push	 eax
  0071d	8d 8c 24 38 28
	00 00		 lea	 ecx, DWORD PTR _buf$80654[esp+140860]
  00724	51		 push	 ecx
  00725	e8 00 00 00 00	 call	 _memset
  0072a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 429  : 
; 430  : 			if (!WriteFile (dev, buf, sizeof (buf), &bytesWritten, NULL))

  0072d	6a 00		 push	 0
  0072f	8d 54 24 50	 lea	 edx, DWORD PTR _bytesWritten$80655[esp+140856]
  00733	52		 push	 edx
  00734	68 00 fe 01 00	 push	 130560			; 0001fe00H
  00739	8d 84 24 3c 28
	00 00		 lea	 eax, DWORD PTR _buf$80654[esp+140864]
  00740	50		 push	 eax
  00741	57		 push	 edi
  00742	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  00748	85 c0		 test	 eax, eax

; 431  : 			{
; 432  : 				nStatus = ERR_OS_ERROR;
; 433  : 				goto error;

  0074a	0f 84 6c fe ff
	ff		 je	 $LN202@TCFormatVo

; 434  : 			}
; 435  : 
; 436  : 			if (bytesWritten != sizeof (buf))

  00750	81 7c 24 4c 00
	fe 01 00	 cmp	 DWORD PTR _bytesWritten$80655[esp+140852], 130560 ; 0001fe00H
  00758	74 0a		 je	 SHORT $LN41@TCFormatVo

; 437  : 			{
; 438  : 				nStatus = ERR_PARAMETER_INCORRECT;

  0075a	bd 1e 00 00 00	 mov	 ebp, 30			; 0000001eH

; 439  : 				goto error;

  0075f	e9 71 02 00 00	 jmp	 $error$80559
$LN41@TCFormatVo:

; 440  : 			}
; 441  : 		}
; 442  : 	}
; 443  : 
; 444  : 	if (volParams->hiddenVol)

  00764	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 445  : 	{
; 446  : 		// Calculate data area position of hidden volume
; 447  : 		cryptoInfo->hiddenVolumeOffset = dataOffset;

  00767	8b 5c 24 2c	 mov	 ebx, DWORD PTR _dataOffset$[esp+140852]
  0076b	8b 6c 24 30	 mov	 ebp, DWORD PTR _dataOffset$[esp+140856]
  0076f	85 c9		 test	 ecx, ecx
  00771	74 39		 je	 SHORT $LN40@TCFormatVo

; 448  : 
; 449  : 		// Validate the offset
; 450  : 		if (dataOffset % FormatSectorSize != 0)

  00773	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _FormatSectorSize
  00779	8b 54 24 10	 mov	 edx, DWORD PTR _cryptoInfo$[esp+140852]
  0077d	6a 00		 push	 0
  0077f	51		 push	 ecx
  00780	89 9a 18 44 00
	00		 mov	 DWORD PTR [edx+17432], ebx
  00786	8b 44 24 18	 mov	 eax, DWORD PTR _cryptoInfo$[esp+140860]
  0078a	55		 push	 ebp
  0078b	53		 push	 ebx
  0078c	89 a8 1c 44 00
	00		 mov	 DWORD PTR [eax+17436], ebp
  00792	e8 00 00 00 00	 call	 __aullrem
  00797	0b c2		 or	 eax, edx
  00799	74 0a		 je	 SHORT $LN39@TCFormatVo
$LN50@TCFormatVo:

; 451  : 		{
; 452  : 			nStatus = ERR_VOL_SIZE_WRONG; 

  0079b	bd 07 00 00 00	 mov	 ebp, 7

; 453  : 			goto error;

  007a0	e9 30 02 00 00	 jmp	 $error$80559
$LN39@TCFormatVo:

; 454  : 		}
; 455  : 
; 456  : 		volParams->quickFormat = TRUE;		// To entirely format a hidden volume would be redundant

  007a5	c7 46 38 01 00
	00 00		 mov	 DWORD PTR [esi+56], 1
$LN40@TCFormatVo:

; 457  : 	}
; 458  : 
; 459  : 	/* Data area */
; 460  : 	startSector = dataOffset / FormatSectorSize;

  007ac	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _FormatSectorSize
  007b2	6a 00		 push	 0
  007b4	52		 push	 edx
  007b5	55		 push	 ebp
  007b6	53		 push	 ebx
  007b7	e8 00 00 00 00	 call	 __aulldiv
  007bc	8b d8		 mov	 ebx, eax

; 461  : 
; 462  : 	// Format filesystem
; 463  : 
; 464  : 	switch (volParams->fileSystem)

  007be	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  007c1	83 e8 00	 sub	 eax, 0
  007c4	8b ea		 mov	 ebp, edx
  007c6	0f 84 c8 00 00
	00		 je	 $LN36@TCFormatVo
  007cc	83 e8 01	 sub	 eax, 1
  007cf	74 13		 je	 SHORT $LN33@TCFormatVo
  007d1	83 e8 01	 sub	 eax, 1
  007d4	0f 84 ba 00 00
	00		 je	 $LN36@TCFormatVo

; 514  : 
; 515  : 	default:
; 516  : 		nStatus = ERR_PARAMETER_INCORRECT; 

  007da	bd 1e 00 00 00	 mov	 ebp, 30			; 0000001eH

; 517  : 		goto error;

  007df	e9 f1 01 00 00	 jmp	 $error$80559
$LN33@TCFormatVo:

; 479  : 
; 480  : 		break;
; 481  : 		
; 482  : 	case FILESYS_FAT:
; 483  : 		if (num_sectors > 0xFFFFffff)

  007e4	83 7c 24 48 00	 cmp	 DWORD PTR _num_sectors$[esp+140856], 0
  007e9	77 09		 ja	 SHORT $LN176@TCFormatVo
  007eb	8b 44 24 44	 mov	 eax, DWORD PTR _num_sectors$[esp+140852]
  007ef	83 f8 ff	 cmp	 eax, -1
  007f2	76 0a		 jbe	 SHORT $LN32@TCFormatVo
$LN176@TCFormatVo:

; 484  : 		{
; 485  : 			nStatus = ERR_VOL_SIZE_WRONG; 

  007f4	bd 07 00 00 00	 mov	 ebp, 7

; 486  : 			goto error;

  007f9	e9 d7 01 00 00	 jmp	 $error$80559
$LN32@TCFormatVo:

; 487  : 		}
; 488  : 
; 489  : 		// Calculate the fats, root dir etc
; 490  : 		ft.num_sectors = (unsigned int) (num_sectors);
; 491  : 
; 492  : #if TC_MAX_VOLUME_SECTOR_SIZE > 0xFFFF
; 493  : #error TC_MAX_VOLUME_SECTOR_SIZE > 0xFFFF
; 494  : #endif
; 495  : 
; 496  : 		ft.sector_size = (uint16) FormatSectorSize;
; 497  : 		ft.cluster_size = volParams->clusterSize;

  007fe	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]

; 498  : 		memcpy (ft.volume_name, "NO NAME    ", 11);

  00801	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ??_C@_0M@BCIBMEHP@NO?5NAME?5?5?5?5?$AA@
  00807	89 84 24 80 00
	00 00		 mov	 DWORD PTR _ft$[esp+140868], eax
  0080e	66 a1 00 00 00
	00		 mov	 ax, WORD PTR _FormatSectorSize
  00814	66 89 84 24 a2
	00 00 00	 mov	 WORD PTR _ft$[esp+140902], ax
  0081c	a1 04 00 00 00	 mov	 eax, DWORD PTR ??_C@_0M@BCIBMEHP@NO?5NAME?5?5?5?5?$AA@+4
  00821	89 44 24 74	 mov	 DWORD PTR _ft$[esp+140856], eax
  00825	89 8c 24 98 00
	00 00		 mov	 DWORD PTR _ft$[esp+140892], ecx
  0082c	66 8b 0d 08 00
	00 00		 mov	 cx, WORD PTR ??_C@_0M@BCIBMEHP@NO?5NAME?5?5?5?5?$AA@+8
  00833	89 54 24 70	 mov	 DWORD PTR _ft$[esp+140852], edx
  00837	8a 15 0a 00 00
	00		 mov	 dl, BYTE PTR ??_C@_0M@BCIBMEHP@NO?5NAME?5?5?5?5?$AA@+10

; 499  : 		GetFatParams (&ft); 

  0083d	8d 44 24 70	 lea	 eax, DWORD PTR _ft$[esp+140852]
  00841	50		 push	 eax
  00842	66 89 4c 24 7c	 mov	 WORD PTR _ft$[esp+140864], cx
  00847	88 54 24 7e	 mov	 BYTE PTR _ft$[esp+140866], dl
  0084b	e8 00 00 00 00	 call	 _GetFatParams

; 500  : 		*(volParams->realClusterSize) = ft.cluster_size * FormatSectorSize;

  00850	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR _ft$[esp+140896]
  00857	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _FormatSectorSize
  0085e	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  00861	89 01		 mov	 DWORD PTR [ecx], eax

; 501  : 
; 502  : 		if (volParams->bDevice && !StartFormatWriteThread())

  00863	8b 16		 mov	 edx, DWORD PTR [esi]
  00865	83 c4 04	 add	 esp, 4
  00868	85 d2		 test	 edx, edx
  0086a	74 0d		 je	 SHORT $LN31@TCFormatVo
  0086c	e8 00 00 00 00	 call	 _StartFormatWriteThread
  00871	85 c0		 test	 eax, eax

; 503  : 		{
; 504  : 			nStatus = ERR_OS_ERROR; 
; 505  : 			goto error;

  00873	0f 84 43 fd ff
	ff		 je	 $LN202@TCFormatVo
$LN31@TCFormatVo:

; 506  : 		}
; 507  : 
; 508  : 		nStatus = FormatFat (startSector, &ft, (void *) dev, cryptoInfo, volParams->quickFormat);

  00879	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  0087c	8b 4c 24 10	 mov	 ecx, DWORD PTR _cryptoInfo$[esp+140852]
  00880	50		 push	 eax
  00881	51		 push	 ecx
  00882	57		 push	 edi
  00883	8d 54 24 7c	 lea	 edx, DWORD PTR _ft$[esp+140864]
  00887	52		 push	 edx
  00888	55		 push	 ebp
  00889	53		 push	 ebx
  0088a	e8 00 00 00 00	 call	 _FormatFat
  0088f	83 c4 18	 add	 esp, 24			; 00000018H

; 509  : 
; 510  : 		if (volParams->bDevice)
; 511  : 			StopFormatWriteThread();
; 512  : 
; 513  : 		break;

  00892	eb 31		 jmp	 SHORT $LN199@TCFormatVo
$LN36@TCFormatVo:

; 465  : 	{
; 466  : 	case FILESYS_NONE:
; 467  : 	case FILESYS_NTFS:
; 468  : 
; 469  : 		if (volParams->bDevice && !StartFormatWriteThread())

  00894	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00896	85 c9		 test	 ecx, ecx
  00898	74 0d		 je	 SHORT $LN35@TCFormatVo
  0089a	e8 00 00 00 00	 call	 _StartFormatWriteThread
  0089f	85 c0		 test	 eax, eax

; 470  : 		{
; 471  : 			nStatus = ERR_OS_ERROR; 
; 472  : 			goto error;

  008a1	0f 84 15 fd ff
	ff		 je	 $LN202@TCFormatVo
$LN35@TCFormatVo:

; 473  : 		}
; 474  : 
; 475  : 		nStatus = FormatNoFs (startSector, num_sectors, dev, cryptoInfo, volParams->quickFormat);

  008a7	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  008aa	8b 44 24 10	 mov	 eax, DWORD PTR _cryptoInfo$[esp+140852]
  008ae	8b 4c 24 48	 mov	 ecx, DWORD PTR _num_sectors$[esp+140856]
  008b2	52		 push	 edx
  008b3	8b 54 24 48	 mov	 edx, DWORD PTR _num_sectors$[esp+140856]
  008b7	50		 push	 eax
  008b8	57		 push	 edi
  008b9	51		 push	 ecx
  008ba	52		 push	 edx
  008bb	55		 push	 ebp
  008bc	53		 push	 ebx
  008bd	e8 00 00 00 00	 call	 _FormatNoFs
  008c2	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN199@TCFormatVo:
  008c5	8b e8		 mov	 ebp, eax

; 476  : 
; 477  : 		if (volParams->bDevice)

  008c7	8b 06		 mov	 eax, DWORD PTR [esi]
  008c9	85 c0		 test	 eax, eax
  008cb	74 05		 je	 SHORT $LN177@TCFormatVo

; 478  : 			StopFormatWriteThread();

  008cd	e8 00 00 00 00	 call	 _StopFormatWriteThread
$LN177@TCFormatVo:

; 518  : 	}
; 519  : 
; 520  : 	if (nStatus != ERR_SUCCESS)

  008d2	85 ed		 test	 ebp, ebp
  008d4	0f 85 fb 00 00
	00		 jne	 $error$80559

; 521  : 		goto error;
; 522  : 
; 523  : 	// Write header backup
; 524  : 	offset.QuadPart = volParams->hiddenVol ? volParams->hiddenVolHostSize - TC_HIDDEN_VOLUME_HEADER_OFFSET : dataAreaSize + TC_VOLUME_HEADER_GROUP_SIZE;

  008da	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  008dd	8b 5c 24 20	 mov	 ebx, DWORD PTR _dataAreaSize$[esp+140852]
  008e1	85 c9		 test	 ecx, ecx
  008e3	74 0f		 je	 SHORT $LN109@TCFormatVo
  008e5	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  008e8	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  008eb	2d 00 00 01 00	 sub	 eax, 65536		; 00010000H
  008f0	1b cd		 sbb	 ecx, ebp
  008f2	eb 0e		 jmp	 SHORT $LN110@TCFormatVo
$LN109@TCFormatVo:
  008f4	8b 4c 24 24	 mov	 ecx, DWORD PTR _dataAreaSize$[esp+140856]
  008f8	8b c3		 mov	 eax, ebx
  008fa	05 00 00 02 00	 add	 eax, 131072		; 00020000H
  008ff	83 d1 00	 adc	 ecx, 0
$LN110@TCFormatVo:

; 525  : 
; 526  : 	if (!SetFilePointerEx ((HANDLE) dev, offset, NULL, FILE_BEGIN))

  00902	6a 00		 push	 0
  00904	6a 00		 push	 0
  00906	51		 push	 ecx
  00907	50		 push	 eax
  00908	57		 push	 edi
  00909	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  0090f	85 c0		 test	 eax, eax

; 527  : 	{
; 528  : 		nStatus = ERR_OS_ERROR;
; 529  : 		goto error;

  00911	0f 84 a5 fc ff
	ff		 je	 $LN202@TCFormatVo

; 530  : 	}
; 531  : 
; 532  : 	nStatus = CreateVolumeHeaderInMemory (FALSE,
; 533  : 		header,
; 534  : 		volParams->ea,
; 535  : 		FIRST_MODE_OF_OPERATION_ID,
; 536  : 		volParams->password,
; 537  : 		volParams->pkcs5,
; 538  : 		cryptoInfo->master_keydata,
; 539  : 		&cryptoInfo,
; 540  : 		dataAreaSize,
; 541  : 		volParams->hiddenVol ? dataAreaSize : 0,
; 542  : 		dataOffset,
; 543  : 		dataAreaSize,
; 544  : 		0,
; 545  : 		volParams->headerFlags,
; 546  : 		FormatSectorSize,
; 547  : 		FALSE);

  00917	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0091a	85 d2		 test	 edx, edx
  0091c	74 08		 je	 SHORT $LN111@TCFormatVo
  0091e	8b 4c 24 24	 mov	 ecx, DWORD PTR _dataAreaSize$[esp+140856]
  00922	8b c3		 mov	 eax, ebx
  00924	eb 04		 jmp	 SHORT $LN112@TCFormatVo
$LN111@TCFormatVo:
  00926	33 c0		 xor	 eax, eax
  00928	33 c9		 xor	 ecx, ecx
$LN112@TCFormatVo:
  0092a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _FormatSectorSize
  00930	8b 6c 24 30	 mov	 ebp, DWORD PTR _dataOffset$[esp+140856]
  00934	6a 00		 push	 0
  00936	52		 push	 edx
  00937	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  0093a	52		 push	 edx
  0093b	8b 54 24 30	 mov	 edx, DWORD PTR _dataAreaSize$[esp+140868]
  0093f	6a 00		 push	 0
  00941	52		 push	 edx
  00942	53		 push	 ebx
  00943	55		 push	 ebp
  00944	8b 6c 24 48	 mov	 ebp, DWORD PTR _dataOffset$[esp+140880]
  00948	55		 push	 ebp
  00949	51		 push	 ecx
  0094a	8b 4c 24 34	 mov	 ecx, DWORD PTR _cryptoInfo$[esp+140888]
  0094e	50		 push	 eax
  0094f	52		 push	 edx
  00950	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  00953	53		 push	 ebx
  00954	8d 44 24 40	 lea	 eax, DWORD PTR _cryptoInfo$[esp+140900]
  00958	50		 push	 eax
  00959	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  0095c	81 c1 a8 41 00
	00		 add	 ecx, 16808		; 000041a8H
  00962	51		 push	 ecx
  00963	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00966	52		 push	 edx
  00967	50		 push	 eax
  00968	6a 01		 push	 1
  0096a	51		 push	 ecx
  0096b	8d 94 24 64 02
	00 00		 lea	 edx, DWORD PTR _header$[esp+140924]
  00972	52		 push	 edx
  00973	6a 00		 push	 0
  00975	e8 00 00 00 00	 call	 _CreateVolumeHeaderInMemory

; 548  : 
; 549  : 	if (!WriteEffectiveVolumeHeader (volParams->bDevice, dev, header))

  0097a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0097c	8b e8		 mov	 ebp, eax
  0097e	8d 84 24 6c 02
	00 00		 lea	 eax, DWORD PTR _header$[esp+140932]
  00985	50		 push	 eax
  00986	57		 push	 edi
  00987	51		 push	 ecx
  00988	e8 00 00 00 00	 call	 _WriteEffectiveVolumeHeader
  0098d	83 c4 5c	 add	 esp, 92			; 0000005cH
  00990	85 c0		 test	 eax, eax

; 550  : 	{
; 551  : 		nStatus = ERR_OS_ERROR;
; 552  : 		goto error;

  00992	0f 84 24 fc ff
	ff		 je	 $LN202@TCFormatVo

; 553  : 	}
; 554  : 
; 555  : 	// Fill reserved header sectors (including the backup header area) with random data
; 556  : 	if (!volParams->hiddenVol)

  00998	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0099b	85 d2		 test	 edx, edx
  0099d	75 1c		 jne	 SHORT $LN24@TCFormatVo

; 557  : 	{
; 558  : 		nStatus = WriteRandomDataToReservedHeaderAreas (dev, cryptoInfo, dataAreaSize, FALSE, FALSE);

  0099f	8b 44 24 24	 mov	 eax, DWORD PTR _dataAreaSize$[esp+140856]
  009a3	8b 4c 24 10	 mov	 ecx, DWORD PTR _cryptoInfo$[esp+140852]
  009a7	52		 push	 edx
  009a8	52		 push	 edx
  009a9	50		 push	 eax
  009aa	53		 push	 ebx
  009ab	51		 push	 ecx
  009ac	57		 push	 edi
  009ad	e8 00 00 00 00	 call	 _WriteRandomDataToReservedHeaderAreas
  009b2	8b e8		 mov	 ebp, eax
  009b4	83 c4 18	 add	 esp, 24			; 00000018H

; 559  : 
; 560  : 		if (nStatus != ERR_SUCCESS)

  009b7	85 ed		 test	 ebp, ebp
  009b9	75 1a		 jne	 SHORT $error$80559
$LN24@TCFormatVo:

; 561  : 			goto error;
; 562  : 	}
; 563  : 
; 564  : #ifndef DEBUG
; 565  : 	if (volParams->quickFormat && volParams->fileSystem != FILESYS_NTFS)

  009bb	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  009be	85 d2		 test	 edx, edx
  009c0	74 13		 je	 SHORT $error$80559
  009c2	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  009c5	83 f8 02	 cmp	 eax, 2
  009c8	74 0b		 je	 SHORT $error$80559

; 566  : 		Sleep (500);	// User-friendly GUI

  009ca	68 f4 01 00 00	 push	 500			; 000001f4H
  009cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
$error$80559:

; 567  : #endif
; 568  : 
; 569  : error:
; 570  : 	dwError = GetLastError();

  009d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 571  : 
; 572  : 	burn (header, sizeof (header));

  009db	8d 94 24 1c 02
	00 00		 lea	 edx, DWORD PTR _header$[esp+140852]
  009e2	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  009e7	89 44 24 28	 mov	 DWORD PTR _dwError$[esp+140852], eax
  009eb	8b d9		 mov	 ebx, ecx
  009ed	8b c2		 mov	 eax, edx
  009ef	90		 npad	 1
$LL118@TCFormatVo:
  009f0	c6 00 00	 mov	 BYTE PTR [eax], 0
  009f3	40		 inc	 eax
  009f4	83 eb 01	 sub	 ebx, 1
  009f7	75 f7		 jne	 SHORT $LL118@TCFormatVo
  009f9	8d a4 24 00 00
	00 00		 npad	 7
$LL19@TCFormatVo:
  00a00	49		 dec	 ecx
  00a01	c6 02 00	 mov	 BYTE PTR [edx], 0
  00a04	42		 inc	 edx
  00a05	85 c9		 test	 ecx, ecx
  00a07	75 f7		 jne	 SHORT $LL19@TCFormatVo

; 573  : 	VirtualUnlock (header, sizeof (header));

  00a09	68 00 02 00 00	 push	 512			; 00000200H
  00a0e	8d 8c 24 20 02
	00 00		 lea	 ecx, DWORD PTR _header$[esp+140856]
  00a15	51		 push	 ecx
  00a16	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualUnlock@8

; 574  : 
; 575  : 	if (dev != INVALID_HANDLE_VALUE)

  00a1c	83 ff ff	 cmp	 edi, -1
  00a1f	74 54		 je	 SHORT $LN17@TCFormatVo

; 576  : 	{
; 577  : 		if (!volParams->bDevice && !volParams->hiddenVol && nStatus != 0)

  00a21	8b 16		 mov	 edx, DWORD PTR [esi]
  00a23	85 d2		 test	 edx, edx
  00a25	75 20		 jne	 SHORT $LN15@TCFormatVo
  00a27	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00a2a	85 c0		 test	 eax, eax
  00a2c	75 19		 jne	 SHORT $LN15@TCFormatVo
  00a2e	85 ed		 test	 ebp, ebp
  00a30	74 15		 je	 SHORT $LN15@TCFormatVo

; 578  : 		{
; 579  : 			// Remove preallocated part before closing file handle if format failed
; 580  : 			if (SetFilePointer (dev, 0, NULL, FILE_BEGIN) == 0)

  00a32	50		 push	 eax
  00a33	50		 push	 eax
  00a34	50		 push	 eax
  00a35	57		 push	 edi
  00a36	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointer@16
  00a3c	85 c0		 test	 eax, eax
  00a3e	75 07		 jne	 SHORT $LN15@TCFormatVo

; 581  : 				SetEndOfFile (dev);

  00a40	57		 push	 edi
  00a41	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEndOfFile@4
$LN15@TCFormatVo:

; 582  : 		}
; 583  : 
; 584  : 		FlushFileBuffers (dev);

  00a47	57		 push	 edi
  00a48	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FlushFileBuffers@4

; 585  : 
; 586  : 		if (bTimeStampValid)

  00a4e	83 7c 24 34 00	 cmp	 DWORD PTR _bTimeStampValid$[esp+140852], 0
  00a53	74 16		 je	 SHORT $LN14@TCFormatVo

; 587  : 			SetFileTime (dev, &ftCreationTime, &ftLastAccessTime, &ftLastWriteTime);

  00a55	8d 4c 24 50	 lea	 ecx, DWORD PTR _ftLastWriteTime$[esp+140852]
  00a59	51		 push	 ecx
  00a5a	8d 54 24 5c	 lea	 edx, DWORD PTR _ftLastAccessTime$[esp+140856]
  00a5e	52		 push	 edx
  00a5f	8d 44 24 68	 lea	 eax, DWORD PTR _ftCreationTime$[esp+140860]
  00a63	50		 push	 eax
  00a64	57		 push	 edi
  00a65	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFileTime@16
$LN14@TCFormatVo:

; 588  : 
; 589  : 		CloseHandle (dev);

  00a6b	57		 push	 edi
  00a6c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 590  : 		dev = INVALID_HANDLE_VALUE;

  00a72	83 cf ff	 or	 edi, -1
$LN17@TCFormatVo:

; 591  : 	}
; 592  : 
; 593  : 	if (nStatus != 0)

  00a75	85 ed		 test	 ebp, ebp
  00a77	0f 85 5d 01 00
	00		 jne	 $LN133@TCFormatVo

; 597  : 	}
; 598  : 
; 599  : 	if (volParams->fileSystem == FILESYS_NTFS)

  00a7d	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  00a80	83 f9 02	 cmp	 ecx, 2
  00a83	0f 85 36 02 00
	00		 jne	 $fv_end$80704

; 600  : 	{
; 601  : 		// Quick-format volume as NTFS
; 602  : 		int driveNo = GetLastAvailableDrive ();

  00a89	e8 00 00 00 00	 call	 _GetLastAvailableDrive

; 603  : 		MountOptions mountOptions;
; 604  : 		int retCode;
; 605  : 
; 606  : 		ZeroMemory (&mountOptions, sizeof (mountOptions));

  00a8e	6a 64		 push	 100			; 00000064H
  00a90	8d 94 24 b8 00
	00 00		 lea	 edx, DWORD PTR _mountOptions$80707[esp+140856]
  00a97	55		 push	 ebp
  00a98	52		 push	 edx
  00a99	8b d8		 mov	 ebx, eax
  00a9b	e8 00 00 00 00	 call	 _memset
  00aa0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 607  : 
; 608  : 		if (driveNo == -1)

  00aa3	83 fb ff	 cmp	 ebx, -1
  00aa6	0f 84 3e 01 00
	00		 je	 $LN134@TCFormatVo

; 615  : 		}
; 616  : 
; 617  : 		mountOptions.ReadOnly = FALSE;
; 618  : 		mountOptions.Removable = FALSE;
; 619  : 		mountOptions.ProtectHiddenVolume = FALSE;
; 620  : 		mountOptions.PreserveTimestamp = bPreserveTimestamp;

  00aac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _bPreserveTimestamp
  00ab2	33 c0		 xor	 eax, eax

; 621  : 		mountOptions.PartitionInInactiveSysEncScope = FALSE;
; 622  : 		mountOptions.UseBackupHeader = FALSE;
; 623  : 
; 624  : 		if (MountVolume (volParams->hwndDlg, driveNo, volParams->volumePath, volParams->password, FALSE, TRUE, &mountOptions, FALSE, TRUE) < 1)

  00ab4	6a 01		 push	 1
  00ab6	50		 push	 eax
  00ab7	8d 94 24 bc 00
	00 00		 lea	 edx, DWORD PTR _mountOptions$80707[esp+140860]
  00abe	52		 push	 edx
  00abf	6a 01		 push	 1
  00ac1	50		 push	 eax
  00ac2	89 84 24 c8 00
	00 00		 mov	 DWORD PTR _mountOptions$80707[esp+140872], eax
  00ac9	89 84 24 cc 00
	00 00		 mov	 DWORD PTR _mountOptions$80707[esp+140876], eax
  00ad0	89 84 24 d0 00
	00 00		 mov	 DWORD PTR _mountOptions$80707[esp+140880], eax
  00ad7	89 84 24 d8 00
	00 00		 mov	 DWORD PTR _mountOptions$80707[esp+140888], eax
  00ade	89 84 24 24 01
	00 00		 mov	 DWORD PTR _mountOptions$80707[esp+140964], eax
  00ae5	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  00ae8	50		 push	 eax
  00ae9	89 8c 24 d8 00
	00 00		 mov	 DWORD PTR _mountOptions$80707[esp+140888], ecx
  00af0	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00af3	8b 56 48	 mov	 edx, DWORD PTR [esi+72]
  00af6	51		 push	 ecx
  00af7	53		 push	 ebx
  00af8	52		 push	 edx
  00af9	e8 00 00 00 00	 call	 _MountVolume
  00afe	83 c4 24	 add	 esp, 36			; 00000024H
  00b01	83 f8 01	 cmp	 eax, 1
  00b04	0f 8c 2a 01 00
	00		 jl	 $LN135@TCFormatVo

; 630  : 		}
; 631  : 
; 632  : 		if (!IsAdmin () && IsUacSupported ())

  00b0a	e8 00 00 00 00	 call	 _IsAdmin
  00b0f	85 c0		 test	 eax, eax
  00b11	75 1c		 jne	 SHORT $LN9@TCFormatVo
  00b13	e8 00 00 00 00	 call	 _IsUacSupported
  00b18	85 c0		 test	 eax, eax
  00b1a	74 13		 je	 SHORT $LN9@TCFormatVo

; 633  : 			retCode = UacFormatNtfs (volParams->hwndDlg, driveNo, volParams->clusterSize);

  00b1c	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00b1f	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  00b22	50		 push	 eax
  00b23	53		 push	 ebx
  00b24	51		 push	 ecx
  00b25	e8 00 00 00 00	 call	 _UacFormatNtfs
  00b2a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 634  : 		else

  00b2d	eb 0d		 jmp	 SHORT $LN8@TCFormatVo
$LN9@TCFormatVo:

; 635  : 			retCode = FormatNtfs (driveNo, volParams->clusterSize);

  00b2f	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  00b32	52		 push	 edx
  00b33	53		 push	 ebx
  00b34	e8 00 00 00 00	 call	 _FormatNtfs
  00b39	83 c4 08	 add	 esp, 8
$LN8@TCFormatVo:

; 636  : 
; 637  : 		if (retCode != TRUE)
; 638  : 		{
; 639  : 			if (!UnmountVolume (volParams->hwndDlg, driveNo, FALSE))

  00b3c	6a 00		 push	 0
  00b3e	53		 push	 ebx
  00b3f	83 f8 01	 cmp	 eax, 1
  00b42	0f 84 46 01 00
	00		 je	 $LN7@TCFormatVo
  00b48	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  00b4b	50		 push	 eax
  00b4c	e8 00 00 00 00	 call	 _UnmountVolume
  00b51	83 c4 0c	 add	 esp, 12			; 0000000cH
  00b54	85 c0		 test	 eax, eax
  00b56	75 21		 jne	 SHORT $LN6@TCFormatVo

; 640  : 				MessageBoxW (volParams->hwndDlg, GetString ("CANT_DISMOUNT_VOLUME"), lpszTitle, ICON_HAND);

  00b58	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpszTitle
  00b5e	6a 10		 push	 16			; 00000010H
  00b60	51		 push	 ecx
  00b61	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OLCHNIN@CANT_DISMOUNT_VOLUME?$AA@
  00b66	e8 00 00 00 00	 call	 _GetString
  00b6b	8b 56 48	 mov	 edx, DWORD PTR [esi+72]
  00b6e	83 c4 04	 add	 esp, 4
  00b71	50		 push	 eax
  00b72	52		 push	 edx
  00b73	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
$LN6@TCFormatVo:

; 641  : 
; 642  : 			if (dataAreaSize <= TC_MAX_FAT_SECTOR_COUNT * FormatSectorSize)

  00b79	a1 00 00 00 00	 mov	 eax, DWORD PTR _FormatSectorSize
  00b7e	bb 01 00 00 00	 mov	 ebx, 1
  00b83	53		 push	 ebx
  00b84	6a 00		 push	 0
  00b86	6a 00		 push	 0
  00b88	50		 push	 eax
  00b89	e8 00 00 00 00	 call	 __allmul
  00b8e	39 54 24 24	 cmp	 DWORD PTR _dataAreaSize$[esp+140856], edx
  00b92	0f 87 e2 00 00
	00		 ja	 $LN5@TCFormatVo
  00b98	72 0a		 jb	 SHORT $LN161@TCFormatVo
  00b9a	39 44 24 20	 cmp	 DWORD PTR _dataAreaSize$[esp+140852], eax
  00b9e	0f 87 d6 00 00
	00		 ja	 $LN5@TCFormatVo
$LN161@TCFormatVo:

; 643  : 			{
; 644  : 				if (AskErrYesNo ("FORMAT_NTFS_FAILED_ASK_FAT") == IDYES)

  00ba4	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@GAPIEOII@FORMAT_NTFS_FAILED_ASK_FAT?$AA@
  00ba9	e8 00 00 00 00	 call	 _AskErrYesNo
  00bae	83 c4 04	 add	 esp, 4
  00bb1	83 f8 06	 cmp	 eax, 6
  00bb4	0f 85 cd 00 00
	00		 jne	 $LN3@TCFormatVo

; 645  : 				{
; 646  : 					// NTFS format failed and the user wants to try FAT format immediately
; 647  : 					volParams->fileSystem = FILESYS_FAT;

  00bba	89 5e 2c	 mov	 DWORD PTR [esi+44], ebx

; 648  : 					bInstantRetryOtherFilesys = TRUE;
; 649  : 					volParams->quickFormat = TRUE;		// Volume has already been successfully TC-formatted

  00bbd	89 5e 38	 mov	 DWORD PTR [esi+56], ebx
  00bc0	89 5c 24 1c	 mov	 DWORD PTR _bInstantRetryOtherFilesys$[esp+140852], ebx

; 650  : 					volParams->clusterSize = 0;		// Default cluster size

  00bc4	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0

; 651  : 					goto begin_format;

  00bcb	e9 67 f6 ff ff	 jmp	 $LN163@TCFormatVo
$LN132@TCFormatVo:

; 174  : 			return ERR_OS_ERROR;

  00bd0	b8 01 00 00 00	 mov	 eax, 1
  00bd5	e9 44 f6 ff ff	 jmp	 $LN196@TCFormatVo
$LN133@TCFormatVo:

; 594  : 	{
; 595  : 		SetLastError(dwError);

  00bda	8b 4c 24 28	 mov	 ecx, DWORD PTR _dwError$[esp+140852]
  00bde	51		 push	 ecx
  00bdf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 596  : 		goto fv_end;

  00be5	e9 d5 00 00 00	 jmp	 $fv_end$80704
$LN134@TCFormatVo:

; 609  : 		{
; 610  : 			MessageBoxW (volParams->hwndDlg, GetString ("NO_FREE_DRIVES"), lpszTitle, ICON_HAND);

  00bea	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lpszTitle
  00bf0	6a 10		 push	 16			; 00000010H
  00bf2	52		 push	 edx
  00bf3	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ECPPAAM@NO_FREE_DRIVES?$AA@
  00bf8	e8 00 00 00 00	 call	 _GetString
  00bfd	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__MessageBoxW@16
  00c03	83 c4 04	 add	 esp, 4
  00c06	50		 push	 eax
  00c07	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  00c0a	50		 push	 eax
  00c0b	ff d7		 call	 edi

; 611  : 			MessageBoxW (volParams->hwndDlg, GetString ("FORMAT_NTFS_STOP"), lpszTitle, ICON_HAND);

  00c0d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpszTitle
  00c13	6a 10		 push	 16			; 00000010H
  00c15	51		 push	 ecx
  00c16	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FNPBIAIE@FORMAT_NTFS_STOP?$AA@
  00c1b	e8 00 00 00 00	 call	 _GetString
  00c20	8b 56 48	 mov	 edx, DWORD PTR [esi+72]
  00c23	83 c4 04	 add	 esp, 4
  00c26	50		 push	 eax
  00c27	52		 push	 edx
  00c28	ff d7		 call	 edi

; 612  : 
; 613  : 			nStatus = ERR_NO_FREE_DRIVES;

  00c2a	bd 16 00 00 00	 mov	 ebp, 22			; 00000016H

; 614  : 			goto fv_end;

  00c2f	e9 8b 00 00 00	 jmp	 $fv_end$80704
$LN135@TCFormatVo:

; 625  : 		{
; 626  : 			MessageBoxW (volParams->hwndDlg, GetString ("CANT_MOUNT_VOLUME"), lpszTitle, ICON_HAND);

  00c34	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  00c39	6a 10		 push	 16			; 00000010H
  00c3b	50		 push	 eax
  00c3c	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@NBGKCIGC@CANT_MOUNT_VOLUME?$AA@
  00c41	e8 00 00 00 00	 call	 _GetString
  00c46	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  00c49	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__MessageBoxW@16
  00c4f	83 c4 04	 add	 esp, 4
  00c52	50		 push	 eax
  00c53	51		 push	 ecx
  00c54	ff d7		 call	 edi

; 627  : 			MessageBoxW (volParams->hwndDlg, GetString ("FORMAT_NTFS_STOP"), lpszTitle, ICON_HAND);

  00c56	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lpszTitle
  00c5c	6a 10		 push	 16			; 00000010H
  00c5e	52		 push	 edx
  00c5f	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FNPBIAIE@FORMAT_NTFS_STOP?$AA@
  00c64	e8 00 00 00 00	 call	 _GetString
  00c69	83 c4 04	 add	 esp, 4
  00c6c	50		 push	 eax
  00c6d	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  00c70	50		 push	 eax
  00c71	ff d7		 call	 edi

; 628  : 			nStatus = ERR_VOL_MOUNT_FAILED;

  00c73	bd 18 00 00 00	 mov	 ebp, 24			; 00000018H

; 629  : 			goto fv_end;

  00c78	eb 45		 jmp	 SHORT $fv_end$80704
$LN5@TCFormatVo:

; 652  : 				}
; 653  : 			}
; 654  : 			else
; 655  : 				Error ("FORMAT_NTFS_FAILED");

  00c7a	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KDGBHLHC@FORMAT_NTFS_FAILED?$AA@
  00c7f	e8 00 00 00 00	 call	 _Error
  00c84	83 c4 04	 add	 esp, 4
$LN3@TCFormatVo:

; 656  : 
; 657  : 			nStatus = ERR_DONT_REPORT;

  00c87	bd 1c 00 00 00	 mov	 ebp, 28			; 0000001cH

; 658  : 			goto fv_end;

  00c8c	eb 31		 jmp	 SHORT $fv_end$80704
$LN7@TCFormatVo:

; 659  : 		}
; 660  : 
; 661  : 		if (!UnmountVolume (volParams->hwndDlg, driveNo, FALSE))

  00c8e	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  00c91	51		 push	 ecx
  00c92	e8 00 00 00 00	 call	 _UnmountVolume
  00c97	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c9a	85 c0		 test	 eax, eax
  00c9c	75 21		 jne	 SHORT $fv_end$80704

; 662  : 			MessageBoxW (volParams->hwndDlg, GetString ("CANT_DISMOUNT_VOLUME"), lpszTitle, ICON_HAND);

  00c9e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lpszTitle
  00ca4	6a 10		 push	 16			; 00000010H
  00ca6	52		 push	 edx
  00ca7	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OLCHNIN@CANT_DISMOUNT_VOLUME?$AA@
  00cac	e8 00 00 00 00	 call	 _GetString
  00cb1	83 c4 04	 add	 esp, 4
  00cb4	50		 push	 eax
  00cb5	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  00cb8	50		 push	 eax
  00cb9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
$fv_end$80704:

; 663  : 	}
; 664  : 
; 665  : fv_end:
; 666  : 	dwError = GetLastError();

  00cbf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 667  : 
; 668  : 	if (dosDev[0])

  00cc5	80 bc 24 1c 04
	00 00 00	 cmp	 BYTE PTR _dosDev$[esp+140852], 0
  00ccd	8b f8		 mov	 edi, eax
  00ccf	74 14		 je	 SHORT $LN1@TCFormatVo

; 669  : 		RemoveFakeDosName (volParams->volumePath, dosDev);

  00cd1	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00cd4	8d 8c 24 1c 04
	00 00		 lea	 ecx, DWORD PTR _dosDev$[esp+140852]
  00cdb	51		 push	 ecx
  00cdc	52		 push	 edx
  00cdd	e8 00 00 00 00	 call	 _RemoveFakeDosName
  00ce2	83 c4 08	 add	 esp, 8
$LN1@TCFormatVo:

; 670  : 
; 671  : 	crypto_close (cryptoInfo);

  00ce5	8b 44 24 10	 mov	 eax, DWORD PTR _cryptoInfo$[esp+140852]
  00ce9	50		 push	 eax
  00cea	e8 00 00 00 00	 call	 _crypto_close
  00cef	83 c4 04	 add	 esp, 4

; 672  : 
; 673  : 	SetLastError (dwError);

  00cf2	57		 push	 edi
  00cf3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 674  : 	return nStatus;

  00cf9	8b c5		 mov	 eax, ebp
  00cfb	e9 1e f5 ff ff	 jmp	 $LN196@TCFormatVo
$LN98@TCFormatVo:

; 100  : 	{
; 101  : 		Error ("SECTOR_SIZE_UNSUPPORTED");

  00d00	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@FCILOPDD@SECTOR_SIZE_UNSUPPORTED?$AA@
  00d05	e8 00 00 00 00	 call	 _Error

; 675  : }

  00d0a	8b 8c 24 30 26
	02 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+140852]
  00d11	83 c4 04	 add	 esp, 4
  00d14	5f		 pop	 edi
  00d15	5e		 pop	 esi
  00d16	5b		 pop	 ebx
  00d17	33 cc		 xor	 ecx, esp
  00d19	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  00d1e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d23	81 c4 24 26 02
	00		 add	 esp, 140836		; 00022624H
  00d29	c3		 ret	 0
_TCFormatVolume ENDP
_TEXT	ENDS
END
