; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\home\public\Desktop\projects\ciphershed.build\src\Common\Random.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_bFastPollEnabled
PUBLIC	_bRandmixEnabled
PUBLIC	_hMouse
PUBLIC	_hKeyboard
PUBLIC	_bThreadTerminate
PUBLIC	_hNetAPI32
PUBLIC	_CryptoAPIAvailable
PUBLIC	_pNetStatisticsGet
PUBLIC	_pNetApiBufferSize
PUBLIC	_pNetApiBufferFree
_DATA	SEGMENT
COMM	_hCryptProv:DWORD
COMM	_critRandProt:BYTE:018H
_DATA	ENDS
_BSS	SEGMENT
_pRandPool DD	01H DUP (?)
_bRandDidInit DD 01H DUP (?)
_nRandIndex DD	01H DUP (?)
_randPoolReadIndex DD 01H DUP (?)
_bDidSlowPoll DD 01H DUP (?)
_RandomPoolEnrichedByUser DD 01H DUP (?)
_PeriodicFastPollThreadHandle DD 01H DUP (?)
_hMouse	DD	01H DUP (?)
_hKeyboard DD	01H DUP (?)
_bThreadTerminate DD 01H DUP (?)
_hNetAPI32 DD	01H DUP (?)
_CryptoAPIAvailable DD 01H DUP (?)
_pNetStatisticsGet DD 01H DUP (?)
_pNetApiBufferSize DD 01H DUP (?)
_pNetApiBufferFree DD 01H DUP (?)
?addedFixedItems@?1??FastPoll@@9@9 DD 01H DUP (?)	; `FastPoll'::`2'::addedFixedItems
_BSS	ENDS
_DATA	SEGMENT
_HashFunction DD 01H
_bFastPollEnabled DD 01H
_bRandmixEnabled DD 01H
?isWorkstation@?1??SlowPoll@@9@9 DD 0ffffffffH		; `SlowPoll'::`2'::isWorkstation
?cbPerfData@?1??SlowPoll@@9@9 DD 010000H		; `SlowPoll'::`2'::cbPerfData
_DATA	ENDS
PUBLIC	_RtlSecureZeroMemory
; Function compile flags: /Ogtpy
; File c:\program files\microsoft sdks\windows\v7.1\include\winnt.h
;	COMDAT _RtlSecureZeroMemory
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory PROC				; COMDAT

; 13070:     volatile char *vptr = (volatile char *)ptr;
; 13071: 
; 13072: #if defined(_M_AMD64)
; 13073: 
; 13074:         __stosb((PBYTE )((DWORD64)vptr), 0, cnt);
; 13075: 
; 13076: #else
; 13077: 
; 13078:     while (cnt) {

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _cnt$[esp-4]
  00004	8b 44 24 04	 mov	 eax, DWORD PTR _ptr$[esp-4]
  00008	8b c8		 mov	 ecx, eax
  0000a	85 d2		 test	 edx, edx
  0000c	74 0b		 je	 SHORT $LN1@RtlSecureZ
  0000e	8b ff		 npad	 2
$LL2@RtlSecureZ:

; 13079:         *vptr = 0;

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 13080:         vptr++;

  00013	41		 inc	 ecx

; 13081:         cnt--;

  00014	83 ea 01	 sub	 edx, 1
  00017	75 f7		 jne	 SHORT $LL2@RtlSecureZ
$LN1@RtlSecureZ:

; 13082:     }
; 13083: 
; 13084: #endif
; 13085: 
; 13086:     return ptr;
; 13087: }

  00019	c3		 ret	 0
_RtlSecureZeroMemory ENDP
_TEXT	ENDS
PUBLIC	_RandStop
EXTRN	_free:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__CryptReleaseContext@8:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__UnhookWindowsHookEx@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
; Function compile flags: /Ogtpy
; File c:\home\public\desktop\projects\ciphershed.build\src\common\random.c
;	COMDAT _RandStop
_TEXT	SEGMENT
_freePool$ = 8						; size = 4
_RandStop PROC						; COMDAT

; 121  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp

; 122  : 	if (!bRandDidInit && freePool && pRandPool)

  00002	8b 6c 24 0c	 mov	 ebp, DWORD PTR _freePool$[esp+4]
  00006	33 db		 xor	 ebx, ebx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	39 1d 00 00 00
	00		 cmp	 DWORD PTR _bRandDidInit, ebx
  00010	75 1b		 jne	 SHORT $LN26@RandStop
  00012	3b eb		 cmp	 ebp, ebx
  00014	0f 84 fd 00 00
	00		 je	 $LN6@RandStop
  0001a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _pRandPool
  00020	3b fb		 cmp	 edi, ebx
  00022	0f 85 af 00 00
	00		 jne	 $freePool$80275
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5d		 pop	 ebp
  0002b	5b		 pop	 ebx

; 172  : 		}
; 173  : 	}
; 174  : }

  0002c	c3		 ret	 0
$LN26@RandStop:

; 123  : 		goto freePool;
; 124  : 
; 125  : 	if (bRandDidInit == FALSE)
; 126  : 		return;
; 127  : 
; 128  : 	EnterCriticalSection (&critRandProt);

  0002d	68 00 00 00 00	 push	 OFFSET _critRandProt
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 129  : 
; 130  : 	if (hMouse != 0)

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _hMouse
  0003d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__UnhookWindowsHookEx@4
  00043	3b c3		 cmp	 eax, ebx
  00045	74 03		 je	 SHORT $LN12@RandStop

; 131  : 		UnhookWindowsHookEx (hMouse);

  00047	50		 push	 eax
  00048	ff d6		 call	 esi
$LN12@RandStop:

; 132  : 	if (hKeyboard != 0)

  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR _hKeyboard
  0004f	3b c3		 cmp	 eax, ebx
  00051	74 03		 je	 SHORT $LN11@RandStop

; 133  : 		UnhookWindowsHookEx (hKeyboard);

  00053	50		 push	 eax
  00054	ff d6		 call	 esi
$LN11@RandStop:

; 134  : 
; 135  : 	bThreadTerminate = TRUE;
; 136  : 
; 137  : 	LeaveCriticalSection (&critRandProt);

  00056	68 00 00 00 00	 push	 OFFSET _critRandProt
  0005b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bThreadTerminate, 1
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 138  : 
; 139  : 	if (PeriodicFastPollThreadHandle)

  0006b	a1 00 00 00 00	 mov	 eax, DWORD PTR _PeriodicFastPollThreadHandle
  00070	3b c3		 cmp	 eax, ebx
  00072	74 09		 je	 SHORT $LN10@RandStop

; 140  : 		WaitForSingleObject (PeriodicFastPollThreadHandle, INFINITE);

  00074	6a ff		 push	 -1
  00076	50		 push	 eax
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
$LN10@RandStop:

; 141  : 
; 142  : 	if (hNetAPI32 != 0)

  0007d	a1 00 00 00 00	 mov	 eax, DWORD PTR _hNetAPI32
  00082	3b c3		 cmp	 eax, ebx
  00084	74 0d		 je	 SHORT $LN9@RandStop

; 143  : 	{
; 144  : 		FreeLibrary (hNetAPI32);

  00086	50		 push	 eax
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4

; 145  : 		hNetAPI32 = NULL;

  0008d	89 1d 00 00 00
	00		 mov	 DWORD PTR _hNetAPI32, ebx
$LN9@RandStop:

; 146  : 	}
; 147  : 
; 148  : 	if (CryptoAPIAvailable)

  00093	39 1d 00 00 00
	00		 cmp	 DWORD PTR _CryptoAPIAvailable, ebx
  00099	74 13		 je	 SHORT $LN8@RandStop

; 149  : 	{
; 150  : 		CryptReleaseContext (hCryptProv, 0);

  0009b	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCryptProv
  000a0	53		 push	 ebx
  000a1	50		 push	 eax
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptReleaseContext@8

; 151  : 		CryptoAPIAvailable = FALSE;

  000a8	89 1d 00 00 00
	00		 mov	 DWORD PTR _CryptoAPIAvailable, ebx
$LN8@RandStop:

; 152  : 	}
; 153  : 
; 154  : 	hMouse = NULL;

  000ae	89 1d 00 00 00
	00		 mov	 DWORD PTR _hMouse, ebx

; 155  : 	hKeyboard = NULL;

  000b4	89 1d 00 00 00
	00		 mov	 DWORD PTR _hKeyboard, ebx

; 156  : 	bThreadTerminate = FALSE;
; 157  : 	DeleteCriticalSection (&critRandProt);

  000ba	68 00 00 00 00	 push	 OFFSET _critRandProt
  000bf	89 1d 00 00 00
	00		 mov	 DWORD PTR _bThreadTerminate, ebx
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 158  : 
; 159  : 	bRandDidInit = FALSE;

  000cb	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _pRandPool
  000d1	89 1d 00 00 00
	00		 mov	 DWORD PTR _bRandDidInit, ebx
$freePool$80275:

; 160  : 
; 161  : freePool:
; 162  : 	if (freePool)

  000d7	3b eb		 cmp	 ebp, ebx
  000d9	74 3c		 je	 SHORT $LN6@RandStop

; 163  : 	{
; 164  : 		bDidSlowPoll = FALSE;

  000db	89 1d 00 00 00
	00		 mov	 DWORD PTR _bDidSlowPoll, ebx

; 165  : 		RandomPoolEnrichedByUser = FALSE;

  000e1	89 1d 00 00 00
	00		 mov	 DWORD PTR _RandomPoolEnrichedByUser, ebx

; 166  : 
; 167  : 		if (pRandPool != NULL)

  000e7	3b fb		 cmp	 edi, ebx
  000e9	74 2c		 je	 SHORT $LN6@RandStop

; 168  : 		{
; 169  : 			burn (pRandPool, RANDOMPOOL_ALLOCSIZE);

  000eb	b9 40 01 00 00	 mov	 ecx, 320		; 00000140H
  000f0	8b d7		 mov	 edx, edi
  000f2	8b f1		 mov	 esi, ecx
  000f4	8b c7		 mov	 eax, edi
$LL18@RandStop:
  000f6	88 18		 mov	 BYTE PTR [eax], bl
  000f8	40		 inc	 eax
  000f9	83 ee 01	 sub	 esi, 1
  000fc	75 f8		 jne	 SHORT $LL18@RandStop
  000fe	8b ff		 npad	 2
$LL2@RandStop:
  00100	49		 dec	 ecx
  00101	88 1a		 mov	 BYTE PTR [edx], bl
  00103	42		 inc	 edx
  00104	3b cb		 cmp	 ecx, ebx
  00106	75 f8		 jne	 SHORT $LL2@RandStop

; 170  : 			TCfree (pRandPool);

  00108	57		 push	 edi
  00109	e8 00 00 00 00	 call	 _free
  0010e	83 c4 04	 add	 esp, 4

; 171  : 			pRandPool = NULL;

  00111	89 1d 00 00 00
	00		 mov	 DWORD PTR _pRandPool, ebx
$LN6@RandStop:
  00117	5f		 pop	 edi
  00118	5e		 pop	 esi
  00119	5d		 pop	 ebp
  0011a	5b		 pop	 ebx

; 172  : 		}
; 173  : 	}
; 174  : }

  0011b	c3		 ret	 0
_RandStop ENDP
_TEXT	ENDS
PUBLIC	_IsRandomNumberGeneratorStarted
; Function compile flags: /Ogtpy
;	COMDAT _IsRandomNumberGeneratorStarted
_TEXT	SEGMENT
_IsRandomNumberGeneratorStarted PROC			; COMDAT

; 178  : 	return bRandDidInit;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _bRandDidInit

; 179  : }

  00005	c3		 ret	 0
_IsRandomNumberGeneratorStarted ENDP
_TEXT	ENDS
PUBLIC	_RandSetHashFunction
EXTRN	_HashIsDeprecated:PROC
; Function compile flags: /Ogtpy
;	COMDAT _RandSetHashFunction
_TEXT	SEGMENT
_hash_algo_id$ = 8					; size = 4
_RandSetHashFunction PROC				; COMDAT

; 182  : {

  00000	56		 push	 esi

; 183  : 	if (HashIsDeprecated (hash_algo_id))

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _hash_algo_id$[esp]
  00005	56		 push	 esi
  00006	e8 00 00 00 00	 call	 _HashIsDeprecated
  0000b	83 c4 04	 add	 esp, 4
  0000e	85 c0		 test	 eax, eax
  00010	74 0c		 je	 SHORT $LN4@RandSetHas

; 184  : 		hash_algo_id = DEFAULT_HASH_ALGORITHM;

  00012	b8 01 00 00 00	 mov	 eax, 1

; 185  : 
; 186  : 	HashFunction = hash_algo_id;

  00017	a3 00 00 00 00	 mov	 DWORD PTR _HashFunction, eax
  0001c	5e		 pop	 esi

; 187  : }

  0001d	c3		 ret	 0
$LN4@RandSetHas:

; 185  : 
; 186  : 	HashFunction = hash_algo_id;

  0001e	89 35 00 00 00
	00		 mov	 DWORD PTR _HashFunction, esi
  00024	5e		 pop	 esi

; 187  : }

  00025	c3		 ret	 0
_RandSetHashFunction ENDP
_TEXT	ENDS
PUBLIC	_RandGetHashFunction
; Function compile flags: /Ogtpy
;	COMDAT _RandGetHashFunction
_TEXT	SEGMENT
_RandGetHashFunction PROC				; COMDAT

; 191  : 	return HashFunction;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _HashFunction

; 192  : }

  00005	c3		 ret	 0
_RandGetHashFunction ENDP
_TEXT	ENDS
PUBLIC	_SetRandomPoolEnrichedByUserStatus
; Function compile flags: /Ogtpy
;	COMDAT _SetRandomPoolEnrichedByUserStatus
_TEXT	SEGMENT
_enriched$ = 8						; size = 4
_SetRandomPoolEnrichedByUserStatus PROC			; COMDAT

; 196  : 	RandomPoolEnrichedByUser = enriched;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _enriched$[esp-4]
  00004	a3 00 00 00 00	 mov	 DWORD PTR _RandomPoolEnrichedByUser, eax

; 197  : }

  00009	c3		 ret	 0
_SetRandomPoolEnrichedByUserStatus ENDP
_TEXT	ENDS
PUBLIC	_IsRandomPoolEnrichedByUser
; Function compile flags: /Ogtpy
;	COMDAT _IsRandomPoolEnrichedByUser
_TEXT	SEGMENT
_IsRandomPoolEnrichedByUser PROC			; COMDAT

; 201  : 	return RandomPoolEnrichedByUser;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _RandomPoolEnrichedByUser

; 202  : }

  00005	c3		 ret	 0
_IsRandomPoolEnrichedByUser ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_Randmix
EXTRN	_RMD160Final:PROC
EXTRN	_RMD160Update:PROC
EXTRN	_RMD160Init:PROC
EXTRN	_sha512_end:PROC
EXTRN	_sha512_hash:PROC
EXTRN	_sha512_begin:PROC
EXTRN	_WHIRLPOOL_finalize:PROC
EXTRN	_WHIRLPOOL_add:PROC
EXTRN	_WHIRLPOOL_init:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT _Randmix
_TEXT	SEGMENT
_digestSize$80317 = -544				; size = 4
_sctx$80314 = -540					; size = 208
_rctx$80313 = -332					; size = 96
_wctx$80312 = -236					; size = 168
_hashOutputBuffer$80311 = -68				; size = 64
__$ArrayPad$ = -4					; size = 4
_Randmix PROC						; COMDAT

; 206  : {

  00000	81 ec 20 02 00
	00		 sub	 esp, 544		; 00000220H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 1c 02
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+544], eax

; 207  : 	if (bRandmixEnabled)

  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR _bRandmixEnabled
  00019	85 c0		 test	 eax, eax
  0001b	0f 84 19 02 00
	00		 je	 $LN107@Randmix

; 208  : 	{
; 209  : 		unsigned char hashOutputBuffer [MAX_DIGESTSIZE];
; 210  : 		WHIRLPOOL_CTX	wctx;
; 211  : 		RMD160_CTX		rctx;
; 212  : 		sha512_ctx		sctx;
; 213  : 		int poolIndex, digestIndex, digestSize;
; 214  : 
; 215  : 		switch (HashFunction)

  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR _HashFunction
  00026	83 e8 01	 sub	 eax, 1
  00029	56		 push	 esi
  0002a	74 1e		 je	 SHORT $LN43@Randmix
  0002c	83 e8 01	 sub	 eax, 1
  0002f	74 12		 je	 SHORT $LN42@Randmix
  00031	83 e8 01	 sub	 eax, 1
  00034	74 0d		 je	 SHORT $LN42@Randmix

; 224  : 
; 225  : 		case WHIRLPOOL:
; 226  : 			digestSize = WHIRLPOOL_DIGESTSIZE;
; 227  : 			break;
; 228  : 
; 229  : 		default:
; 230  : 			TC_THROW_FATAL_EXCEPTION;

  00036	8b 74 24 04	 mov	 esi, DWORD PTR _digestSize$80317[esp+548]
  0003a	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
  00041	eb 0c		 jmp	 SHORT $LN44@Randmix
$LN42@Randmix:

; 219  : 			break;
; 220  : 
; 221  : 		case SHA512:
; 222  : 			digestSize = SHA512_DIGESTSIZE;

  00043	be 40 00 00 00	 mov	 esi, 64			; 00000040H

; 223  : 			break;

  00048	eb 05		 jmp	 SHORT $LN44@Randmix
$LN43@Randmix:

; 216  : 		{
; 217  : 		case RIPEMD160:
; 218  : 			digestSize = RIPEMD160_DIGESTSIZE;

  0004a	be 14 00 00 00	 mov	 esi, 20			; 00000014H
$LN44@Randmix:

; 231  : 		}
; 232  : 
; 233  : 		if (RNG_POOL_SIZE % digestSize)

  0004f	b8 40 01 00 00	 mov	 eax, 320		; 00000140H
  00054	99		 cdq
  00055	f7 fe		 idiv	 esi
  00057	85 d2		 test	 edx, edx
  00059	74 07		 je	 SHORT $LN39@Randmix

; 234  : 			TC_THROW_FATAL_EXCEPTION;

  0005b	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
$LN39@Randmix:
  00062	57		 push	 edi

; 235  : 
; 236  : 		for (poolIndex = 0; poolIndex < RNG_POOL_SIZE; poolIndex += digestSize)		

  00063	33 ff		 xor	 edi, edi
  00065	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL108@Randmix:

; 237  : 		{
; 238  : 			/* Compute the message digest of the entire pool using the selected hash function. */
; 239  : 			switch (HashFunction)

  00070	a1 00 00 00 00	 mov	 eax, DWORD PTR _HashFunction
  00075	83 e8 01	 sub	 eax, 1
  00078	0f 84 86 00 00
	00		 je	 $LN33@Randmix
  0007e	83 e8 01	 sub	 eax, 1
  00081	74 4d		 je	 SHORT $LN32@Randmix
  00083	83 e8 01	 sub	 eax, 1
  00086	74 0c		 je	 SHORT $LN31@Randmix

; 258  : 
; 259  : 			default:		
; 260  : 				// Unknown/wrong ID
; 261  : 				TC_THROW_FATAL_EXCEPTION;

  00088	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
  0008f	e9 ad 00 00 00	 jmp	 $LN34@Randmix
$LN31@Randmix:

; 252  : 
; 253  : 			case WHIRLPOOL:
; 254  : 				WHIRLPOOL_init (&wctx);

  00094	8d 8c 24 3c 01
	00 00		 lea	 ecx, DWORD PTR _wctx$80312[esp+552]
  0009b	51		 push	 ecx
  0009c	e8 00 00 00 00	 call	 _WHIRLPOOL_init

; 255  : 				WHIRLPOOL_add (pRandPool, RNG_POOL_SIZE * 8, &wctx);

  000a1	a1 00 00 00 00	 mov	 eax, DWORD PTR _pRandPool
  000a6	8d 94 24 40 01
	00 00		 lea	 edx, DWORD PTR _wctx$80312[esp+556]
  000ad	52		 push	 edx
  000ae	68 00 0a 00 00	 push	 2560			; 00000a00H
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 _WHIRLPOOL_add

; 256  : 				WHIRLPOOL_finalize (&wctx, hashOutputBuffer);

  000b9	8d 8c 24 f4 01
	00 00		 lea	 ecx, DWORD PTR _hashOutputBuffer$80311[esp+568]
  000c0	51		 push	 ecx
  000c1	8d 94 24 50 01
	00 00		 lea	 edx, DWORD PTR _wctx$80312[esp+572]
  000c8	52		 push	 edx
  000c9	e8 00 00 00 00	 call	 _WHIRLPOOL_finalize

; 257  : 				break;

  000ce	eb 6e		 jmp	 SHORT $LN117@Randmix
$LN32@Randmix:

; 245  : 				break;
; 246  : 
; 247  : 			case SHA512:
; 248  : 				sha512_begin (&sctx);

  000d0	8d 44 24 0c	 lea	 eax, DWORD PTR _sctx$80314[esp+552]
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 _sha512_begin

; 249  : 				sha512_hash (pRandPool, RNG_POOL_SIZE, &sctx);

  000da	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pRandPool
  000e0	8d 4c 24 10	 lea	 ecx, DWORD PTR _sctx$80314[esp+556]
  000e4	51		 push	 ecx
  000e5	68 40 01 00 00	 push	 320			; 00000140H
  000ea	52		 push	 edx
  000eb	e8 00 00 00 00	 call	 _sha512_hash

; 250  : 				sha512_end (hashOutputBuffer, &sctx);

  000f0	8d 44 24 1c	 lea	 eax, DWORD PTR _sctx$80314[esp+568]
  000f4	50		 push	 eax
  000f5	8d 8c 24 f8 01
	00 00		 lea	 ecx, DWORD PTR _hashOutputBuffer$80311[esp+572]
  000fc	51		 push	 ecx
  000fd	e8 00 00 00 00	 call	 _sha512_end

; 251  : 				break;

  00102	eb 3a		 jmp	 SHORT $LN117@Randmix
$LN33@Randmix:

; 240  : 			{
; 241  : 			case RIPEMD160:
; 242  : 				RMD160Init(&rctx);

  00104	8d 94 24 dc 00
	00 00		 lea	 edx, DWORD PTR _rctx$80313[esp+552]
  0010b	52		 push	 edx
  0010c	e8 00 00 00 00	 call	 _RMD160Init

; 243  : 				RMD160Update(&rctx, pRandPool, RNG_POOL_SIZE);

  00111	a1 00 00 00 00	 mov	 eax, DWORD PTR _pRandPool
  00116	68 40 01 00 00	 push	 320			; 00000140H
  0011b	50		 push	 eax
  0011c	8d 8c 24 e8 00
	00 00		 lea	 ecx, DWORD PTR _rctx$80313[esp+564]
  00123	51		 push	 ecx
  00124	e8 00 00 00 00	 call	 _RMD160Update

; 244  : 				RMD160Final(hashOutputBuffer, &rctx);

  00129	8d 94 24 ec 00
	00 00		 lea	 edx, DWORD PTR _rctx$80313[esp+568]
  00130	52		 push	 edx
  00131	8d 84 24 f8 01
	00 00		 lea	 eax, DWORD PTR _hashOutputBuffer$80311[esp+572]
  00138	50		 push	 eax
  00139	e8 00 00 00 00	 call	 _RMD160Final
$LN117@Randmix:
  0013e	83 c4 18	 add	 esp, 24			; 00000018H
$LN34@Randmix:

; 262  : 			}
; 263  : 
; 264  : 			/* XOR the resultant message digest to the pool at the poolIndex position. */
; 265  : 			for (digestIndex = 0; digestIndex < digestSize; digestIndex++)

  00141	33 c0		 xor	 eax, eax
  00143	85 f6		 test	 esi, esi
  00145	7e 18		 jle	 SHORT $LN37@Randmix
  00147	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pRandPool
  0014d	03 cf		 add	 ecx, edi
  0014f	90		 npad	 1
$LL29@Randmix:

; 266  : 			{
; 267  : 				pRandPool [poolIndex + digestIndex] ^= hashOutputBuffer [digestIndex];

  00150	8a 94 04 e4 01
	00 00		 mov	 dl, BYTE PTR _hashOutputBuffer$80311[esp+eax+552]
  00157	30 14 01	 xor	 BYTE PTR [ecx+eax], dl
  0015a	40		 inc	 eax
  0015b	3b c6		 cmp	 eax, esi
  0015d	7c f1		 jl	 SHORT $LL29@Randmix
$LN37@Randmix:

; 235  : 
; 236  : 		for (poolIndex = 0; poolIndex < RNG_POOL_SIZE; poolIndex += digestSize)		

  0015f	03 fe		 add	 edi, esi
  00161	81 ff 40 01 00
	00		 cmp	 edi, 320		; 00000140H
  00167	0f 8c 03 ff ff
	ff		 jl	 $LL108@Randmix

; 268  : 			}
; 269  : 		}
; 270  : 
; 271  : 		/* Prevent leaks */
; 272  : 		burn (hashOutputBuffer, MAX_DIGESTSIZE);	

  0016d	8d 94 24 e4 01
	00 00		 lea	 edx, DWORD PTR _hashOutputBuffer$80311[esp+552]
  00174	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00179	8b f1		 mov	 esi, ecx
  0017b	8b c2		 mov	 eax, edx
  0017d	5f		 pop	 edi
  0017e	8b ff		 npad	 2
$LL50@Randmix:
  00180	c6 00 00	 mov	 BYTE PTR [eax], 0
  00183	40		 inc	 eax
  00184	83 ee 01	 sub	 esi, 1
  00187	75 f7		 jne	 SHORT $LL50@Randmix
  00189	8d a4 24 00 00
	00 00		 npad	 7
$LL23@Randmix:
  00190	49		 dec	 ecx
  00191	c6 02 00	 mov	 BYTE PTR [edx], 0
  00194	42		 inc	 edx
  00195	85 c9		 test	 ecx, ecx
  00197	75 f7		 jne	 SHORT $LL23@Randmix

; 273  : 		switch (HashFunction)

  00199	a1 00 00 00 00	 mov	 eax, DWORD PTR _HashFunction
  0019e	83 e8 01	 sub	 eax, 1
  001a1	74 68		 je	 SHORT $LN18@Randmix
  001a3	83 e8 01	 sub	 eax, 1
  001a6	74 34		 je	 SHORT $LN12@Randmix
  001a8	83 e8 01	 sub	 eax, 1
  001ab	74 0b		 je	 SHORT $LN6@Randmix

; 286  : 
; 287  : 		default:		
; 288  : 			// Unknown/wrong ID
; 289  : 			TC_THROW_FATAL_EXCEPTION;

  001ad	88 0d 00 00 00
	00		 mov	 BYTE PTR ds:0, cl
  001b3	e9 81 00 00 00	 jmp	 $LN118@Randmix
$LN6@Randmix:

; 282  : 
; 283  : 		case WHIRLPOOL:
; 284  : 			burn (&wctx, sizeof(wctx));		

  001b8	8d 94 24 38 01
	00 00		 lea	 edx, DWORD PTR _wctx$80312[esp+548]
  001bf	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  001c4	8b f1		 mov	 esi, ecx
  001c6	8b c2		 mov	 eax, edx
$LL62@Randmix:
  001c8	c6 00 00	 mov	 BYTE PTR [eax], 0
  001cb	40		 inc	 eax
  001cc	83 ee 01	 sub	 esi, 1
  001cf	75 f7		 jne	 SHORT $LL62@Randmix
$LL3@Randmix:
  001d1	49		 dec	 ecx
  001d2	c6 02 00	 mov	 BYTE PTR [edx], 0
  001d5	42		 inc	 edx
  001d6	85 c9		 test	 ecx, ecx
  001d8	75 f7		 jne	 SHORT $LL3@Randmix

; 285  : 			break;

  001da	eb 5d		 jmp	 SHORT $LN118@Randmix
$LN12@Randmix:

; 277  : 			break;
; 278  : 
; 279  : 		case SHA512:
; 280  : 			burn (&sctx, sizeof(sctx));		

  001dc	8d 54 24 08	 lea	 edx, DWORD PTR _sctx$80314[esp+548]
  001e0	b9 d0 00 00 00	 mov	 ecx, 208		; 000000d0H
  001e5	8b f1		 mov	 esi, ecx
  001e7	8b c2		 mov	 eax, edx
  001e9	8d a4 24 00 00
	00 00		 npad	 7
$LL58@Randmix:
  001f0	c6 00 00	 mov	 BYTE PTR [eax], 0
  001f3	40		 inc	 eax
  001f4	83 ee 01	 sub	 esi, 1
  001f7	75 f7		 jne	 SHORT $LL58@Randmix
  001f9	8d a4 24 00 00
	00 00		 npad	 7
$LL9@Randmix:
  00200	49		 dec	 ecx
  00201	c6 02 00	 mov	 BYTE PTR [edx], 0
  00204	42		 inc	 edx
  00205	85 c9		 test	 ecx, ecx
  00207	75 f7		 jne	 SHORT $LL9@Randmix

; 281  : 			break;

  00209	eb 2e		 jmp	 SHORT $LN118@Randmix
$LN18@Randmix:

; 274  : 		{
; 275  : 		case RIPEMD160:
; 276  : 			burn (&rctx, sizeof(rctx));		

  0020b	8d 94 24 d8 00
	00 00		 lea	 edx, DWORD PTR _rctx$80313[esp+548]
  00212	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  00217	8b f1		 mov	 esi, ecx
  00219	8b c2		 mov	 eax, edx
  0021b	eb 03 8d 49 00	 npad	 5
$LL54@Randmix:
  00220	c6 00 00	 mov	 BYTE PTR [eax], 0
  00223	40		 inc	 eax
  00224	83 ee 01	 sub	 esi, 1
  00227	75 f7		 jne	 SHORT $LL54@Randmix
  00229	8d a4 24 00 00
	00 00		 npad	 7
$LL15@Randmix:
  00230	49		 dec	 ecx
  00231	c6 02 00	 mov	 BYTE PTR [edx], 0
  00234	42		 inc	 edx
  00235	85 c9		 test	 ecx, ecx
  00237	75 f7		 jne	 SHORT $LL15@Randmix
$LN118@Randmix:
  00239	5e		 pop	 esi
$LN107@Randmix:

; 290  : 		}
; 291  : 	}
; 292  : 	return TRUE;
; 293  : }

  0023a	8b 8c 24 1c 02
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+544]
  00241	33 cc		 xor	 ecx, esp
  00243	b8 01 00 00 00	 mov	 eax, 1
  00248	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0024d	81 c4 20 02 00
	00		 add	 esp, 544		; 00000220H
  00253	c3		 ret	 0
_Randmix ENDP
_TEXT	ENDS
PUBLIC	_RandaddBuf
; Function compile flags: /Ogtpy
;	COMDAT _RandaddBuf
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_RandaddBuf PROC					; COMDAT

; 297  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 298  : 	int i;
; 299  : 	for (i = 0; i < len; i++)

  00002	8b 7c 24 10	 mov	 edi, DWORD PTR _len$[esp+4]
  00006	33 f6		 xor	 esi, esi
  00008	85 ff		 test	 edi, edi
  0000a	7e 55		 jle	 SHORT $LN3@RandaddBuf
  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR _nRandIndex
  00011	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pRandPool
  00017	55		 push	 ebp
  00018	8b 6c 24 10	 mov	 ebp, DWORD PTR _buf$[esp+8]
  0001c	8d 64 24 00	 npad	 4
$LL5@RandaddBuf:

; 300  : 	{
; 301  : 		RandaddByte (((unsigned char *) buf)[i]);

  00020	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  00025	75 07		 jne	 SHORT $LN2@RandaddBuf
  00027	33 c0		 xor	 eax, eax
  00029	a3 00 00 00 00	 mov	 DWORD PTR _nRandIndex, eax
$LN2@RandaddBuf:
  0002e	8a 14 2e	 mov	 dl, BYTE PTR [esi+ebp]
  00031	00 14 01	 add	 BYTE PTR [ecx+eax], dl
  00034	8b d0		 mov	 edx, eax
  00036	81 e2 0f 00 00
	80		 and	 edx, -2147483633	; 8000000fH
  0003c	79 05		 jns	 SHORT $LN10@RandaddBuf
  0003e	4a		 dec	 edx
  0003f	83 ca f0	 or	 edx, -16		; fffffff0H
  00042	42		 inc	 edx
$LN10@RandaddBuf:
  00043	75 10		 jne	 SHORT $LN1@RandaddBuf
  00045	e8 00 00 00 00	 call	 _Randmix
  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR _nRandIndex
  0004f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pRandPool
$LN1@RandaddBuf:
  00055	40		 inc	 eax
  00056	46		 inc	 esi
  00057	3b f7		 cmp	 esi, edi
  00059	a3 00 00 00 00	 mov	 DWORD PTR _nRandIndex, eax
  0005e	7c c0		 jl	 SHORT $LL5@RandaddBuf
  00060	5d		 pop	 ebp
$LN3@RandaddBuf:
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi

; 302  : 	}
; 303  : }

  00063	c3		 ret	 0
_RandaddBuf ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@BENPDJPG@ERR_NOT_ENOUGH_RANDOM_DATA?$AA@ ; `string'
PUBLIC	_RandpeekBytes
EXTRN	_Error:PROC
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_0BL@BENPDJPG@ERR_NOT_ENOUGH_RANDOM_DATA?$AA@
CONST	SEGMENT
??_C@_0BL@BENPDJPG@ERR_NOT_ENOUGH_RANDOM_DATA?$AA@ DB 'ERR_NOT_ENOUGH_RAN'
	DB	'DOM_DATA', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _RandpeekBytes
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_RandpeekBytes PROC					; COMDAT

; 307  : 	if (!bRandDidInit)

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bRandDidInit, 0
  00007	75 03		 jne	 SHORT $LN2@RandpeekBy

; 308  : 		return FALSE;

  00009	33 c0		 xor	 eax, eax

; 321  : }

  0000b	c3		 ret	 0
$LN2@RandpeekBy:
  0000c	56		 push	 esi

; 309  : 
; 310  : 	if (len > RNG_POOL_SIZE)

  0000d	8b 74 24 0c	 mov	 esi, DWORD PTR _len$[esp]
  00011	81 fe 40 01 00
	00		 cmp	 esi, 320		; 00000140H
  00017	7e 12		 jle	 SHORT $LN1@RandpeekBy

; 311  : 	{
; 312  : 		Error ("ERR_NOT_ENOUGH_RANDOM_DATA");	

  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@BENPDJPG@ERR_NOT_ENOUGH_RANDOM_DATA?$AA@
  0001e	e8 00 00 00 00	 call	 _Error
  00023	83 c4 04	 add	 esp, 4

; 313  : 		len = RNG_POOL_SIZE;

  00026	be 40 01 00 00	 mov	 esi, 320		; 00000140H
$LN1@RandpeekBy:

; 314  : 	}
; 315  : 
; 316  : 	EnterCriticalSection (&critRandProt);

  0002b	68 00 00 00 00	 push	 OFFSET _critRandProt
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 317  : 	memcpy (buf, pRandPool, len);

  00036	a1 00 00 00 00	 mov	 eax, DWORD PTR _pRandPool
  0003b	8b 4c 24 08	 mov	 ecx, DWORD PTR _buf$[esp]
  0003f	56		 push	 esi
  00040	50		 push	 eax
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 _memcpy
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH

; 318  : 	LeaveCriticalSection (&critRandProt);

  0004a	68 00 00 00 00	 push	 OFFSET _critRandProt
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 319  : 
; 320  : 	return TRUE;

  00055	b8 01 00 00 00	 mov	 eax, 1
  0005a	5e		 pop	 esi

; 321  : }

  0005b	c3		 ret	 0
_RandpeekBytes ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@JBDFGGOO@?2?2?4?2PhysicalDrive?$CFd?$AA@ ; `string'
PUBLIC	??_C@_1BK@FJCAAMNP@?$AAL?$AAa?$AAn?$AAm?$AAa?$AAn?$AAS?$AAe?$AAr?$AAv?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CE@MINGJEKI@?$AAL?$AAa?$AAn?$AAm?$AAa?$AAn?$AAW?$AAo?$AAr?$AAk?$AAs?$AAt?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BB@EODNGDFL@NetApiBufferFree?$AA@	; `string'
PUBLIC	??_C@_0BB@HGFPEPHK@NetApiBufferSize?$AA@	; `string'
PUBLIC	??_C@_0BB@NIBHPBJM@NetStatisticsGet?$AA@	; `string'
PUBLIC	??_C@_0N@HNENINMF@NETAPI32?4DLL?$AA@		; `string'
PUBLIC	??_C@_05LELOMLIF@WinNT?$AA@			; `string'
PUBLIC	??_C@_0M@GGPOPAAP@ProductType?$AA@		; `string'
PUBLIC	??_C@_0DA@NKLICLFP@SYSTEM?2CurrentControlSet?2Control@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_SlowPoll
EXTRN	__imp__CryptGenRandom@12:PROC
EXTRN	__imp__DeviceIoControl@32:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	_sprintf_s:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	__imp__RegCloseKey@4:PROC
EXTRN	__stricmp:PROC
EXTRN	__imp__RegQueryValueExA@24:PROC
EXTRN	__imp__RegOpenKeyExA@20:PROC
_BSS	SEGMENT
_buffer	DB	0140H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BE@JBDFGGOO@?2?2?4?2PhysicalDrive?$CFd?$AA@
; File c:\program files\microsoft sdks\windows\v7.1\include\winnt.h
CONST	SEGMENT
??_C@_0BE@JBDFGGOO@?2?2?4?2PhysicalDrive?$CFd?$AA@ DB '\\.\PhysicalDrive%'
	DB	'd', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@FJCAAMNP@?$AAL?$AAa?$AAn?$AAm?$AAa?$AAn?$AAS?$AAe?$AAr?$AAv?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@FJCAAMNP@?$AAL?$AAa?$AAn?$AAm?$AAa?$AAn?$AAS?$AAe?$AAr?$AAv?$AAe?$AAr?$AA?$AA@ DB 'L'
	DB	00H, 'a', 00H, 'n', 00H, 'm', 00H, 'a', 00H, 'n', 00H, 'S', 00H
	DB	'e', 00H, 'r', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@MINGJEKI@?$AAL?$AAa?$AAn?$AAm?$AAa?$AAn?$AAW?$AAo?$AAr?$AAk?$AAs?$AAt?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@MINGJEKI@?$AAL?$AAa?$AAn?$AAm?$AAa?$AAn?$AAW?$AAo?$AAr?$AAk?$AAs?$AAt?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@ DB 'L'
	DB	00H, 'a', 00H, 'n', 00H, 'm', 00H, 'a', 00H, 'n', 00H, 'W', 00H
	DB	'o', 00H, 'r', 00H, 'k', 00H, 's', 00H, 't', 00H, 'a', 00H, 't'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EODNGDFL@NetApiBufferFree?$AA@
CONST	SEGMENT
??_C@_0BB@EODNGDFL@NetApiBufferFree?$AA@ DB 'NetApiBufferFree', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HGFPEPHK@NetApiBufferSize?$AA@
CONST	SEGMENT
??_C@_0BB@HGFPEPHK@NetApiBufferSize?$AA@ DB 'NetApiBufferSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NIBHPBJM@NetStatisticsGet?$AA@
CONST	SEGMENT
??_C@_0BB@NIBHPBJM@NetStatisticsGet?$AA@ DB 'NetStatisticsGet', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HNENINMF@NETAPI32?4DLL?$AA@
CONST	SEGMENT
??_C@_0N@HNENINMF@NETAPI32?4DLL?$AA@ DB 'NETAPI32.DLL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05LELOMLIF@WinNT?$AA@
CONST	SEGMENT
??_C@_05LELOMLIF@WinNT?$AA@ DB 'WinNT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GGPOPAAP@ProductType?$AA@
CONST	SEGMENT
??_C@_0M@GGPOPAAP@ProductType?$AA@ DB 'ProductType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@NKLICLFP@SYSTEM?2CurrentControlSet?2Control@
CONST	SEGMENT
??_C@_0DA@NKLICLFP@SYSTEM?2CurrentControlSet?2Control@ DB 'SYSTEM\Current'
	DB	'ControlSet\Control\ProductOptions', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\home\public\desktop\projects\ciphershed.build\src\common\random.c
CONST	ENDS
;	COMDAT _SlowPoll
_TEXT	SEGMENT
_dwSize$ = -160						; size = 4
_lpBuffer$ = -156					; size = 4
_hKey$80587 = -152					; size = 4
_diskPerformance$80628 = -148				; size = 88
_szDevice$80629 = -60					; size = 24
_szValue$80593 = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_SlowPoll PROC						; COMDAT

; 537  : {

  00000	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 9c 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+160], eax

; 538  : 	static int isWorkstation = -1;
; 539  : 	static int cbPerfData = 0x10000;
; 540  : 	HANDLE hDevice;
; 541  : 	LPBYTE lpBuffer;
; 542  : 	DWORD dwSize, status;
; 543  : 	LPWSTR lpszLanW, lpszLanS;
; 544  : 	int nDrive;
; 545  : 
; 546  : 	/* Find out whether this is an NT server or workstation if necessary */
; 547  : 	if (isWorkstation == -1)

  00014	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?isWorkstation@?1??SlowPoll@@9@9, -1
  0001b	75 7f		 jne	 SHORT $LN41@SlowPoll

; 548  : 	{
; 549  : 		HKEY hKey;
; 550  : 
; 551  : 		if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
; 552  : 		       "SYSTEM\\CurrentControlSet\\Control\\ProductOptions",
; 553  : 				  0, KEY_READ, &hKey) == ERROR_SUCCESS)

  0001d	8d 44 24 08	 lea	 eax, DWORD PTR _hKey$80587[esp+160]
  00021	50		 push	 eax
  00022	68 19 00 02 00	 push	 131097			; 00020019H
  00027	6a 00		 push	 0
  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@NKLICLFP@SYSTEM?2CurrentControlSet?2Control@
  0002e	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  00039	85 c0		 test	 eax, eax
  0003b	75 5f		 jne	 SHORT $LN41@SlowPoll

; 554  : 		{
; 555  : 			unsigned char szValue[32];
; 556  : 			dwSize = sizeof (szValue);
; 557  : 
; 558  : 			isWorkstation = TRUE;
; 559  : 			status = RegQueryValueEx (hKey, "ProductType", 0, NULL,
; 560  : 						  szValue, &dwSize);

  0003d	8d 0c 24	 lea	 ecx, DWORD PTR _dwSize$[esp+160]
  00040	51		 push	 ecx
  00041	8d 94 24 80 00
	00 00		 lea	 edx, DWORD PTR _szValue$80593[esp+164]
  00048	52		 push	 edx
  00049	50		 push	 eax
  0004a	50		 push	 eax
  0004b	8b 44 24 18	 mov	 eax, DWORD PTR _hKey$80587[esp+176]
  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_0M@GGPOPAAP@ProductType?$AA@
  00054	50		 push	 eax
  00055	c7 44 24 18 20
	00 00 00	 mov	 DWORD PTR _dwSize$[esp+184], 32 ; 00000020H
  0005d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?isWorkstation@?1??SlowPoll@@9@9, 1
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24

; 561  : 
; 562  : 			if (status == ERROR_SUCCESS && _stricmp ((char *) szValue, "WinNT"))

  0006d	85 c0		 test	 eax, eax
  0006f	75 20		 jne	 SHORT $LN17@SlowPoll
  00071	8d 4c 24 7c	 lea	 ecx, DWORD PTR _szValue$80593[esp+160]
  00075	68 00 00 00 00	 push	 OFFSET ??_C@_05LELOMLIF@WinNT?$AA@
  0007a	51		 push	 ecx
  0007b	e8 00 00 00 00	 call	 __stricmp
  00080	83 c4 08	 add	 esp, 8
  00083	85 c0		 test	 eax, eax
  00085	74 0a		 je	 SHORT $LN17@SlowPoll

; 563  : 				/* Note: There are (at least) three cases for
; 564  : 				   ProductType: WinNT = NT Workstation,
; 565  : 				   ServerNT = NT Server, LanmanNT = NT Server
; 566  : 				   acting as a Domain Controller */
; 567  : 				isWorkstation = FALSE;

  00087	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?isWorkstation@?1??SlowPoll@@9@9, 0
$LN17@SlowPoll:

; 568  : 
; 569  : 			RegCloseKey (hKey);

  00091	8b 54 24 08	 mov	 edx, DWORD PTR _hKey$80587[esp+160]
  00095	52		 push	 edx
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$LN41@SlowPoll:
  0009c	56		 push	 esi
  0009d	57		 push	 edi

; 570  : 		}
; 571  : 	}
; 572  : 	/* Initialize the NetAPI32 function pointers if necessary */
; 573  : 	if (hNetAPI32 == NULL)

  0009e	33 ff		 xor	 edi, edi
  000a0	39 3d 00 00 00
	00		 cmp	 DWORD PTR _hNetAPI32, edi
  000a6	0f 85 81 00 00
	00		 jne	 $LN42@SlowPoll

; 574  : 	{
; 575  : 		/* Obtain a handle to the module containing the Lan Manager
; 576  : 		   functions */
; 577  : 		hNetAPI32 = LoadLibrary ("NETAPI32.DLL");

  000ac	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HNENINMF@NETAPI32?4DLL?$AA@
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  000b7	a3 00 00 00 00	 mov	 DWORD PTR _hNetAPI32, eax

; 578  : 		if (hNetAPI32 != NULL)

  000bc	3b c7		 cmp	 eax, edi
  000be	0f 84 bb 00 00
	00		 je	 $LN12@SlowPoll

; 579  : 		{
; 580  : 			/* Now get pointers to the functions */
; 581  : 			pNetStatisticsGet = (NETSTATISTICSGET) GetProcAddress (hNetAPI32,
; 582  : 							"NetStatisticsGet");

  000c4	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetProcAddress@8
  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@NIBHPBJM@NetStatisticsGet?$AA@
  000cf	50		 push	 eax
  000d0	ff d6		 call	 esi
  000d2	a3 00 00 00 00	 mov	 DWORD PTR _pNetStatisticsGet, eax

; 583  : 			pNetApiBufferSize = (NETAPIBUFFERSIZE) GetProcAddress (hNetAPI32,
; 584  : 							"NetApiBufferSize");

  000d7	a1 00 00 00 00	 mov	 eax, DWORD PTR _hNetAPI32
  000dc	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@HGFPEPHK@NetApiBufferSize?$AA@
  000e1	50		 push	 eax
  000e2	ff d6		 call	 esi

; 585  : 			pNetApiBufferFree = (NETAPIBUFFERFREE) GetProcAddress (hNetAPI32,
; 586  : 							"NetApiBufferFree");

  000e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hNetAPI32
  000ea	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@EODNGDFL@NetApiBufferFree?$AA@
  000ef	51		 push	 ecx
  000f0	a3 00 00 00 00	 mov	 DWORD PTR _pNetApiBufferSize, eax
  000f5	ff d6		 call	 esi
  000f7	a3 00 00 00 00	 mov	 DWORD PTR _pNetApiBufferFree, eax

; 587  : 
; 588  : 			/* Make sure we got valid pointers for every NetAPI32
; 589  : 			   function */
; 590  : 			if (pNetStatisticsGet == NULL ||
; 591  : 			    pNetApiBufferSize == NULL ||
; 592  : 			    pNetApiBufferFree == NULL)

  000fc	39 3d 00 00 00
	00		 cmp	 DWORD PTR _pNetStatisticsGet, edi
  00102	74 0c		 je	 SHORT $LN13@SlowPoll
  00104	39 3d 00 00 00
	00		 cmp	 DWORD PTR _pNetApiBufferSize, edi
  0010a	74 04		 je	 SHORT $LN13@SlowPoll
  0010c	3b c7		 cmp	 eax, edi
  0010e	75 15		 jne	 SHORT $LN14@SlowPoll
$LN13@SlowPoll:

; 593  : 			{
; 594  : 				/* Free the library reference and reset the
; 595  : 				   static handle */
; 596  : 				FreeLibrary (hNetAPI32);

  00110	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hNetAPI32
  00116	52		 push	 edx
  00117	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4

; 597  : 				hNetAPI32 = NULL;

  0011d	89 3d 00 00 00
	00		 mov	 DWORD PTR _hNetAPI32, edi

; 598  : 			}
; 599  : 		}
; 600  : 	}
; 601  : 
; 602  : 	/* Get network statistics.  Note: Both NT Workstation and NT Server
; 603  : 	   by default will be running both the workstation and server
; 604  : 	   services.  The heuristic below is probably useful though on the
; 605  : 	   assumption that the majority of the network traffic will be via
; 606  : 	   the appropriate service */
; 607  : 	lpszLanW = (LPWSTR) WIDE ("LanmanWorkstation");
; 608  : 	lpszLanS = (LPWSTR) WIDE ("LanmanServer");
; 609  : 	if (hNetAPI32 &&
; 610  : 	    pNetStatisticsGet (NULL,
; 611  : 			       isWorkstation ? lpszLanW : lpszLanS,
; 612  : 			       0, 0, &lpBuffer) == 0)

  00123	eb 5a		 jmp	 SHORT $LN12@SlowPoll
$LN14@SlowPoll:
  00125	39 3d 00 00 00
	00		 cmp	 DWORD PTR _hNetAPI32, edi
  0012b	74 52		 je	 SHORT $LN12@SlowPoll
$LN42@SlowPoll:
  0012d	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1CE@MINGJEKI@?$AAL?$AAa?$AAn?$AAm?$AAa?$AAn?$AAW?$AAo?$AAr?$AAk?$AAs?$AAt?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@
  00132	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?isWorkstation@?1??SlowPoll@@9@9, edi
  00138	75 05		 jne	 SHORT $LN23@SlowPoll
  0013a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1BK@FJCAAMNP@?$AAL?$AAa?$AAn?$AAm?$AAa?$AAn?$AAS?$AAe?$AAr?$AAv?$AAe?$AAr?$AA?$AA@
$LN23@SlowPoll:
  0013f	8d 4c 24 0c	 lea	 ecx, DWORD PTR _lpBuffer$[esp+168]
  00143	51		 push	 ecx
  00144	57		 push	 edi
  00145	57		 push	 edi
  00146	50		 push	 eax
  00147	57		 push	 edi
  00148	ff 15 00 00 00
	00		 call	 DWORD PTR _pNetStatisticsGet
  0014e	85 c0		 test	 eax, eax
  00150	75 2d		 jne	 SHORT $LN12@SlowPoll

; 613  : 	{
; 614  : 		pNetApiBufferSize (lpBuffer, &dwSize);

  00152	8b 44 24 0c	 mov	 eax, DWORD PTR _lpBuffer$[esp+168]
  00156	8d 54 24 08	 lea	 edx, DWORD PTR _dwSize$[esp+168]
  0015a	52		 push	 edx
  0015b	50		 push	 eax
  0015c	ff 15 00 00 00
	00		 call	 DWORD PTR _pNetApiBufferSize

; 615  : 		RandaddBuf ((unsigned char *) lpBuffer, dwSize);

  00162	8b 4c 24 08	 mov	 ecx, DWORD PTR _dwSize$[esp+168]
  00166	8b 54 24 0c	 mov	 edx, DWORD PTR _lpBuffer$[esp+168]
  0016a	51		 push	 ecx
  0016b	52		 push	 edx
  0016c	e8 00 00 00 00	 call	 _RandaddBuf

; 616  : 		pNetApiBufferFree (lpBuffer);

  00171	8b 44 24 14	 mov	 eax, DWORD PTR _lpBuffer$[esp+176]
  00175	83 c4 08	 add	 esp, 8
  00178	50		 push	 eax
  00179	ff 15 00 00 00
	00		 call	 DWORD PTR _pNetApiBufferFree
$LN12@SlowPoll:
  0017f	55		 push	 ebp

; 617  : 	}
; 618  : 
; 619  : 	/* Get disk I/O statistics for all the hard drives */
; 620  : 	for (nDrive = 0;; nDrive++)
; 621  : 	{
; 622  : 		DISK_PERFORMANCE diskPerformance;
; 623  : 		char szDevice[24];
; 624  : 
; 625  : 		/* Check whether we can access this device */
; 626  : 		snprintf (szDevice, ARRAY_LENGTH(szDevice), "\\\\.\\PhysicalDrive%d", nDrive);

  00180	57		 push	 edi
  00181	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JBDFGGOO@?2?2?4?2PhysicalDrive?$CFd?$AA@
  00186	8d 4c 24 78	 lea	 ecx, DWORD PTR _szDevice$80629[esp+180]
  0018a	6a 18		 push	 24			; 00000018H
  0018c	51		 push	 ecx
  0018d	e8 00 00 00 00	 call	 _sprintf_s

; 627  : 		hDevice = CreateFile (szDevice, 0, FILE_SHARE_READ | FILE_SHARE_WRITE,
; 628  : 				      NULL, OPEN_EXISTING, 0, NULL);

  00192	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__CreateFileA@28
  00198	83 c4 10	 add	 esp, 16			; 00000010H
  0019b	57		 push	 edi
  0019c	57		 push	 edi
  0019d	6a 03		 push	 3
  0019f	57		 push	 edi
  001a0	6a 03		 push	 3
  001a2	57		 push	 edi
  001a3	8d 94 24 88 00
	00 00		 lea	 edx, DWORD PTR _szDevice$80629[esp+196]
  001aa	52		 push	 edx
  001ab	ff d5		 call	 ebp
  001ad	8b f0		 mov	 esi, eax

; 629  : 		if (hDevice == INVALID_HANDLE_VALUE)

  001af	83 fe ff	 cmp	 esi, -1
  001b2	74 77		 je	 SHORT $LN32@SlowPoll
  001b4	53		 push	 ebx
  001b5	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__CloseHandle@4
  001bb	eb 03 8d 49 00	 npad	 5
$LL11@SlowPoll:

; 630  : 			break;
; 631  : 
; 632  : 
; 633  : 		/* Note: This only works if you have turned on the disk
; 634  : 		   performance counters with 'diskperf -y'.  These counters
; 635  : 		   are off by default */
; 636  : 		if (DeviceIoControl (hDevice, IOCTL_DISK_PERFORMANCE, NULL, 0,
; 637  : 				&diskPerformance, sizeof (DISK_PERFORMANCE),
; 638  : 				     &dwSize, NULL))

  001c0	6a 00		 push	 0
  001c2	8d 44 24 14	 lea	 eax, DWORD PTR _dwSize$[esp+180]
  001c6	50		 push	 eax
  001c7	6a 58		 push	 88			; 00000058H
  001c9	8d 4c 24 28	 lea	 ecx, DWORD PTR _diskPerformance$80628[esp+188]
  001cd	51		 push	 ecx
  001ce	6a 00		 push	 0
  001d0	6a 00		 push	 0
  001d2	68 20 00 07 00	 push	 458784			; 00070020H
  001d7	56		 push	 esi
  001d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  001de	85 c0		 test	 eax, eax
  001e0	74 12		 je	 SHORT $LN7@SlowPoll

; 639  : 		{
; 640  : 			RandaddBuf ((unsigned char *) &diskPerformance, dwSize);

  001e2	8b 54 24 10	 mov	 edx, DWORD PTR _dwSize$[esp+176]
  001e6	52		 push	 edx
  001e7	8d 44 24 20	 lea	 eax, DWORD PTR _diskPerformance$80628[esp+180]
  001eb	50		 push	 eax
  001ec	e8 00 00 00 00	 call	 _RandaddBuf
  001f1	83 c4 08	 add	 esp, 8
$LN7@SlowPoll:

; 641  : 		}
; 642  : 		CloseHandle (hDevice);

  001f4	56		 push	 esi
  001f5	ff d3		 call	 ebx
  001f7	47		 inc	 edi
  001f8	57		 push	 edi
  001f9	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JBDFGGOO@?2?2?4?2PhysicalDrive?$CFd?$AA@
  001fe	8d 4c 24 7c	 lea	 ecx, DWORD PTR _szDevice$80629[esp+184]
  00202	6a 18		 push	 24			; 00000018H
  00204	51		 push	 ecx
  00205	e8 00 00 00 00	 call	 _sprintf_s
  0020a	83 c4 10	 add	 esp, 16			; 00000010H
  0020d	6a 00		 push	 0
  0020f	6a 00		 push	 0
  00211	6a 03		 push	 3
  00213	6a 00		 push	 0
  00215	6a 03		 push	 3
  00217	6a 00		 push	 0
  00219	8d 94 24 8c 00
	00 00		 lea	 edx, DWORD PTR _szDevice$80629[esp+200]
  00220	52		 push	 edx
  00221	ff d5		 call	 ebp
  00223	8b f0		 mov	 esi, eax
  00225	83 fe ff	 cmp	 esi, -1
  00228	75 96		 jne	 SHORT $LL11@SlowPoll
  0022a	5b		 pop	 ebx
$LN32@SlowPoll:

; 643  : 	}
; 644  : 
; 645  : 	// CryptoAPI
; 646  : 	if (CryptoAPIAvailable && CryptGenRandom (hCryptProv, sizeof (buffer), buffer)) 

  0022b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _CryptoAPIAvailable, 0
  00232	5d		 pop	 ebp
  00233	74 2c		 je	 SHORT $LN5@SlowPoll
  00235	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCryptProv
  0023a	68 00 00 00 00	 push	 OFFSET _buffer
  0023f	68 40 01 00 00	 push	 320			; 00000140H
  00244	50		 push	 eax
  00245	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptGenRandom@12
  0024b	85 c0		 test	 eax, eax
  0024d	74 12		 je	 SHORT $LN5@SlowPoll

; 647  : 		RandaddBuf (buffer, sizeof (buffer));

  0024f	68 40 01 00 00	 push	 320			; 00000140H
  00254	68 00 00 00 00	 push	 OFFSET _buffer
  00259	e8 00 00 00 00	 call	 _RandaddBuf
  0025e	83 c4 08	 add	 esp, 8
$LN5@SlowPoll:

; 648  : 
; 649  : 	burn(buffer, sizeof (buffer));

  00261	ba 00 00 00 00	 mov	 edx, OFFSET _buffer
  00266	b9 40 01 00 00	 mov	 ecx, 320		; 00000140H
  0026b	8b f1		 mov	 esi, ecx
  0026d	8b c2		 mov	 eax, edx
  0026f	90		 npad	 1
$LL25@SlowPoll:
  00270	c6 00 00	 mov	 BYTE PTR [eax], 0
  00273	40		 inc	 eax
  00274	83 ee 01	 sub	 esi, 1
  00277	75 f7		 jne	 SHORT $LL25@SlowPoll
  00279	5f		 pop	 edi
  0027a	5e		 pop	 esi
  0027b	eb 03 8d 49 00	 npad	 5
$LL2@SlowPoll:
  00280	49		 dec	 ecx
  00281	c6 02 00	 mov	 BYTE PTR [edx], 0
  00284	42		 inc	 edx
  00285	85 c9		 test	 ecx, ecx
  00287	75 f7		 jne	 SHORT $LL2@SlowPoll

; 650  : 	Randmix();

  00289	e8 00 00 00 00	 call	 _Randmix

; 651  : 	return TRUE;
; 652  : }

  0028e	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+160]
  00295	33 cc		 xor	 ecx, esp
  00297	b8 01 00 00 00	 mov	 eax, 1
  0029c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002a1	81 c4 a0 00 00
	00		 add	 esp, 160		; 000000a0H
  002a7	c3		 ret	 0
_SlowPoll ENDP
_TEXT	ENDS
PUBLIC	_RandAddInt
; Function compile flags: /Ogtpy
;	COMDAT _RandAddInt
_TEXT	SEGMENT
_x$ = 8							; size = 4
_RandAddInt PROC					; COMDAT

; 41   : 	RandaddByte(x); 

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _nRandIndex
  00005	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  0000a	75 07		 jne	 SHORT $LN8@RandAddInt
  0000c	33 c0		 xor	 eax, eax
  0000e	a3 00 00 00 00	 mov	 DWORD PTR _nRandIndex, eax
$LN8@RandAddInt:
  00013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pRandPool
  00019	53		 push	 ebx
  0001a	8b 5c 24 08	 mov	 ebx, DWORD PTR _x$[esp]
  0001e	00 1c 01	 add	 BYTE PTR [ecx+eax], bl
  00021	8b d0		 mov	 edx, eax
  00023	81 e2 0f 00 00
	80		 and	 edx, -2147483633	; 8000000fH
  00029	79 05		 jns	 SHORT $LN12@RandAddInt
  0002b	4a		 dec	 edx
  0002c	83 ca f0	 or	 edx, -16		; fffffff0H
  0002f	42		 inc	 edx
$LN12@RandAddInt:
  00030	75 10		 jne	 SHORT $LN7@RandAddInt
  00032	e8 00 00 00 00	 call	 _Randmix
  00037	a1 00 00 00 00	 mov	 eax, DWORD PTR _nRandIndex
  0003c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pRandPool
$LN7@RandAddInt:
  00042	40		 inc	 eax
  00043	a3 00 00 00 00	 mov	 DWORD PTR _nRandIndex, eax

; 42   : 	RandaddByte((x >> 8)); 

  00048	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  0004d	75 07		 jne	 SHORT $LN6@RandAddInt
  0004f	33 c0		 xor	 eax, eax
  00051	a3 00 00 00 00	 mov	 DWORD PTR _nRandIndex, eax
$LN6@RandAddInt:
  00056	8b d3		 mov	 edx, ebx
  00058	c1 ea 08	 shr	 edx, 8
  0005b	00 14 01	 add	 BYTE PTR [ecx+eax], dl
  0005e	8b d0		 mov	 edx, eax
  00060	81 e2 0f 00 00
	80		 and	 edx, -2147483633	; 8000000fH
  00066	79 05		 jns	 SHORT $LN13@RandAddInt
  00068	4a		 dec	 edx
  00069	83 ca f0	 or	 edx, -16		; fffffff0H
  0006c	42		 inc	 edx
$LN13@RandAddInt:
  0006d	75 10		 jne	 SHORT $LN5@RandAddInt
  0006f	e8 00 00 00 00	 call	 _Randmix
  00074	a1 00 00 00 00	 mov	 eax, DWORD PTR _nRandIndex
  00079	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pRandPool
$LN5@RandAddInt:
  0007f	40		 inc	 eax
  00080	a3 00 00 00 00	 mov	 DWORD PTR _nRandIndex, eax

; 43   : 	RandaddByte((x >> 16));

  00085	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  0008a	75 07		 jne	 SHORT $LN4@RandAddInt
  0008c	33 c0		 xor	 eax, eax
  0008e	a3 00 00 00 00	 mov	 DWORD PTR _nRandIndex, eax
$LN4@RandAddInt:
  00093	8b d3		 mov	 edx, ebx
  00095	c1 ea 10	 shr	 edx, 16			; 00000010H
  00098	00 14 01	 add	 BYTE PTR [ecx+eax], dl
  0009b	8b d0		 mov	 edx, eax
  0009d	81 e2 0f 00 00
	80		 and	 edx, -2147483633	; 8000000fH
  000a3	79 05		 jns	 SHORT $LN14@RandAddInt
  000a5	4a		 dec	 edx
  000a6	83 ca f0	 or	 edx, -16		; fffffff0H
  000a9	42		 inc	 edx
$LN14@RandAddInt:
  000aa	75 10		 jne	 SHORT $LN3@RandAddInt
  000ac	e8 00 00 00 00	 call	 _Randmix
  000b1	a1 00 00 00 00	 mov	 eax, DWORD PTR _nRandIndex
  000b6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pRandPool
$LN3@RandAddInt:
  000bc	40		 inc	 eax
  000bd	a3 00 00 00 00	 mov	 DWORD PTR _nRandIndex, eax

; 44   : 	RandaddByte((x >> 24));

  000c2	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  000c7	75 07		 jne	 SHORT $LN2@RandAddInt
  000c9	33 c0		 xor	 eax, eax
  000cb	a3 00 00 00 00	 mov	 DWORD PTR _nRandIndex, eax
$LN2@RandAddInt:
  000d0	c1 eb 18	 shr	 ebx, 24			; 00000018H
  000d3	00 1c 01	 add	 BYTE PTR [ecx+eax], bl
  000d6	8b c8		 mov	 ecx, eax
  000d8	81 e1 0f 00 00
	80		 and	 ecx, -2147483633	; 8000000fH
  000de	5b		 pop	 ebx
  000df	79 05		 jns	 SHORT $LN15@RandAddInt
  000e1	49		 dec	 ecx
  000e2	83 c9 f0	 or	 ecx, -16		; fffffff0H
  000e5	41		 inc	 ecx
$LN15@RandAddInt:
  000e6	75 0c		 jne	 SHORT $LN11@RandAddInt
  000e8	e8 00 00 00 00	 call	 _Randmix
  000ed	ff 05 00 00 00
	00		 inc	 DWORD PTR _nRandIndex

; 45   : }

  000f3	c3		 ret	 0
$LN11@RandAddInt:

; 44   : 	RandaddByte((x >> 24));

  000f4	40		 inc	 eax
  000f5	a3 00 00 00 00	 mov	 DWORD PTR _nRandIndex, eax

; 45   : }

  000fa	c3		 ret	 0
_RandAddInt ENDP
_TEXT	ENDS
PUBLIC	_MouseProc@12
EXTRN	_crc_32_tab:BYTE
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__CallNextHookEx@16:PROC
_BSS	SEGMENT
?lastCrc2@?1??MouseProc@@9@9 DD 01H DUP (?)		; `MouseProc'::`2'::lastCrc2
?lastCrc@?1??MouseProc@@9@9 DD 01H DUP (?)		; `MouseProc'::`2'::lastCrc
?dwLastTimer@?1??MouseProc@@9@9 DD 01H DUP (?)		; `MouseProc'::`2'::dwLastTimer
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _MouseProc@12
_TEXT	SEGMENT
_j$80463 = 8						; size = 4
_nCode$ = 8						; size = 4
_dwTimer$80462 = 12					; size = 4
_wParam$ = 12						; size = 4
_lParam$ = 16						; size = 4
_MouseProc@12 PROC					; COMDAT

; 395  : 	static DWORD dwLastTimer;
; 396  : 	static unsigned __int32 lastCrc, lastCrc2;
; 397  : 	MOUSEHOOKSTRUCT *lpMouse = (MOUSEHOOKSTRUCT *) lParam;
; 398  : 
; 399  : 	if (nCode < 0)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nCode$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7d 1a		 jge	 SHORT $LN12@MouseProc

; 400  : 		return CallNextHookEx (hMouse, nCode, wParam, lParam);

  00008	8b 4c 24 0c	 mov	 ecx, DWORD PTR _lParam$[esp-4]
  0000c	8b 54 24 08	 mov	 edx, DWORD PTR _wParam$[esp-4]
  00010	51		 push	 ecx
  00011	52		 push	 edx
  00012	50		 push	 eax
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR _hMouse
  00018	50		 push	 eax
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallNextHookEx@16

; 438  : }

  0001f	c2 0c 00	 ret	 12			; 0000000cH
$LN12@MouseProc:
  00022	53		 push	 ebx
  00023	56		 push	 esi
  00024	57		 push	 edi

; 401  : 	else
; 402  : 	{
; 403  : 		DWORD dwTimer = GetTickCount ();

  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 404  : 		DWORD j = dwLastTimer - dwTimer;

  0002b	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?dwLastTimer@?1??MouseProc@@9@9
  00031	8b 54 24 18	 mov	 edx, DWORD PTR _lParam$[esp+8]
  00035	2b d8		 sub	 ebx, eax

; 405  : 		unsigned __int32 crc = 0L;

  00037	33 f6		 xor	 esi, esi
  00039	89 44 24 14	 mov	 DWORD PTR _dwTimer$80462[esp+8], eax
  0003d	89 5c 24 10	 mov	 DWORD PTR _j$80463[esp+8], ebx

; 406  : 		int i;
; 407  : 
; 408  : 		dwLastTimer = dwTimer;

  00041	a3 00 00 00 00	 mov	 DWORD PTR ?dwLastTimer@?1??MouseProc@@9@9, eax
  00046	42		 inc	 edx
  00047	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]
  0004a	55		 push	 ebp
  0004b	eb 03 8d 49 00	 npad	 5
$LL10@MouseProc:

; 409  : 
; 410  : 		for (i = 0; i < sizeof (MOUSEHOOKSTRUCT); i++)
; 411  : 		{
; 412  : 			crc = UPDC32 (((unsigned char *) lpMouse)[i], crc);

  00050	0f b6 6a ff	 movzx	 ebp, BYTE PTR [edx-1]
  00054	33 ee		 xor	 ebp, esi
  00056	8b ce		 mov	 ecx, esi
  00058	0f b6 32	 movzx	 esi, BYTE PTR [edx]
  0005b	c1 e9 08	 shr	 ecx, 8
  0005e	81 e5 ff 00 00
	00		 and	 ebp, 255		; 000000ffH
  00064	33 0c ad 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[ebp*4]
  0006b	83 c2 05	 add	 edx, 5
  0006e	33 f1		 xor	 esi, ecx
  00070	81 e6 ff 00 00
	00		 and	 esi, 255		; 000000ffH
  00076	c1 e9 08	 shr	 ecx, 8
  00079	33 0c b5 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[esi*4]
  00080	0f b6 72 fc	 movzx	 esi, BYTE PTR [edx-4]
  00084	33 f1		 xor	 esi, ecx
  00086	81 e6 ff 00 00
	00		 and	 esi, 255		; 000000ffH
  0008c	c1 e9 08	 shr	 ecx, 8
  0008f	33 0c b5 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[esi*4]
  00096	0f b6 72 fd	 movzx	 esi, BYTE PTR [edx-3]
  0009a	33 f1		 xor	 esi, ecx
  0009c	81 e6 ff 00 00
	00		 and	 esi, 255		; 000000ffH
  000a2	c1 e9 08	 shr	 ecx, 8
  000a5	33 0c b5 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[esi*4]
  000ac	0f b6 72 fe	 movzx	 esi, BYTE PTR [edx-2]
  000b0	33 f1		 xor	 esi, ecx
  000b2	81 e6 ff 00 00
	00		 and	 esi, 255		; 000000ffH
  000b8	c1 e9 08	 shr	 ecx, 8
  000bb	33 0c b5 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[esi*4]
  000c2	83 ef 01	 sub	 edi, 1
  000c5	8b f1		 mov	 esi, ecx
  000c7	75 87		 jne	 SHORT $LL10@MouseProc
  000c9	5d		 pop	 ebp

; 413  : 		}
; 414  : 
; 415  : 		if (crc != lastCrc && crc != lastCrc2)

  000ca	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?lastCrc@?1??MouseProc@@9@9
  000d0	0f 84 d2 00 00
	00		 je	 $LN7@MouseProc
  000d6	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?lastCrc2@?1??MouseProc@@9@9
  000dc	0f 84 c6 00 00
	00		 je	 $LN7@MouseProc

; 416  : 		{
; 417  : 			unsigned __int32 timeCrc = 0L;
; 418  : 
; 419  : 			for (i = 0; i < 4; i++)
; 420  : 			{
; 421  : 				timeCrc = UPDC32 (((unsigned char *) &j)[i], timeCrc);

  000e2	0f b6 cb	 movzx	 ecx, bl
  000e5	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR _crc_32_tab[ecx*4]
  000ec	0f b6 d7	 movzx	 edx, bh
  000ef	33 d1		 xor	 edx, ecx
  000f1	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000f7	c1 e9 08	 shr	 ecx, 8
  000fa	33 0c 95 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[edx*4]
  00101	0f b6 54 24 12	 movzx	 edx, BYTE PTR _j$80463[esp+10]
  00106	33 d1		 xor	 edx, ecx
  00108	c1 e9 08	 shr	 ecx, 8
  0010b	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00111	33 0c 95 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[edx*4]
  00118	0f b6 54 24 13	 movzx	 edx, BYTE PTR _j$80463[esp+11]
  0011d	33 d1		 xor	 edx, ecx
  0011f	c1 e9 08	 shr	 ecx, 8
  00122	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00128	33 0c 95 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[edx*4]

; 422  : 			}
; 423  : 
; 424  : 			for (i = 0; i < 4; i++)
; 425  : 			{
; 426  : 				timeCrc = UPDC32 (((unsigned char *) &dwTimer)[i], timeCrc);

  0012f	0f b6 d0	 movzx	 edx, al
  00132	33 d1		 xor	 edx, ecx
  00134	c1 e9 08	 shr	 ecx, 8
  00137	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0013d	33 0c 95 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[edx*4]
  00144	0f b6 54 24 16	 movzx	 edx, BYTE PTR _dwTimer$80462[esp+10]
  00149	0f b6 c4	 movzx	 eax, ah
  0014c	33 c1		 xor	 eax, ecx
  0014e	c1 e9 08	 shr	 ecx, 8
  00151	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00156	33 0c 85 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[eax*4]
  0015d	0f b6 44 24 17	 movzx	 eax, BYTE PTR _dwTimer$80462[esp+11]
  00162	33 d1		 xor	 edx, ecx
  00164	c1 e9 08	 shr	 ecx, 8
  00167	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0016d	33 0c 95 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[edx*4]

; 427  : 			}
; 428  : 
; 429  : 			EnterCriticalSection (&critRandProt);

  00174	68 00 00 00 00	 push	 OFFSET _critRandProt
  00179	33 c1		 xor	 eax, ecx
  0017b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00180	c1 e9 08	 shr	 ecx, 8
  00183	33 0c 85 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[eax*4]
  0018a	8b f9		 mov	 edi, ecx
  0018c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 430  : 			RandaddInt32 ((unsigned __int32) (crc + timeCrc));

  00192	03 fe		 add	 edi, esi
  00194	57		 push	 edi
  00195	e8 00 00 00 00	 call	 _RandAddInt
  0019a	83 c4 04	 add	 esp, 4

; 431  : 			LeaveCriticalSection (&critRandProt);

  0019d	68 00 00 00 00	 push	 OFFSET _critRandProt
  001a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$LN7@MouseProc:

; 432  : 		}
; 433  : 		lastCrc2 = lastCrc;

  001a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?lastCrc@?1??MouseProc@@9@9
  001ae	5f		 pop	 edi

; 434  : 		lastCrc = crc;

  001af	89 35 00 00 00
	00		 mov	 DWORD PTR ?lastCrc@?1??MouseProc@@9@9, esi
  001b5	5e		 pop	 esi
  001b6	89 0d 00 00 00
	00		 mov	 DWORD PTR ?lastCrc2@?1??MouseProc@@9@9, ecx

; 435  : 
; 436  : 	}
; 437  : 	return 0;

  001bc	33 c0		 xor	 eax, eax
  001be	5b		 pop	 ebx

; 438  : }

  001bf	c2 0c 00	 ret	 12			; 0000000cH
_MouseProc@12 ENDP
_TEXT	ENDS
PUBLIC	_KeyboardProc@12
EXTRN	_crc32int:PROC
_BSS	SEGMENT
?dwLastTimer@?1??KeyboardProc@@9@9 DD 01H DUP (?)	; `KeyboardProc'::`2'::dwLastTimer
?lLastKey2@?1??KeyboardProc@@9@9 DD 01H DUP (?)		; `KeyboardProc'::`2'::lLastKey2
?lLastKey@?1??KeyboardProc@@9@9 DD 01H DUP (?)		; `KeyboardProc'::`2'::lLastKey
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _KeyboardProc@12
_TEXT	SEGMENT
_dwTimer$80516 = -4					; size = 4
_j$80517 = 8						; size = 4
_nCode$ = 8						; size = 4
_wParam$ = 12						; size = 4
_lParam$ = 16						; size = 4
_KeyboardProc@12 PROC					; COMDAT

; 446  : {

  00000	51		 push	 ecx

; 447  : 	static int lLastKey, lLastKey2;
; 448  : 	static DWORD dwLastTimer;
; 449  : 	int nKey = (lParam & 0x00ff0000) >> 16;

  00001	8b 44 24 10	 mov	 eax, DWORD PTR _lParam$[esp]
  00005	56		 push	 esi
  00006	8b f0		 mov	 esi, eax
  00008	c1 fe 10	 sar	 esi, 16			; 00000010H
  0000b	57		 push	 edi

; 450  : 	int nCapture = 0;
; 451  : 
; 452  : 	if (nCode < 0)

  0000c	8b 7c 24 10	 mov	 edi, DWORD PTR _nCode$[esp+8]
  00010	81 e6 ff 00 00
	00		 and	 esi, 255		; 000000ffH
  00016	85 ff		 test	 edi, edi
  00018	7d 1a		 jge	 SHORT $LN12@KeyboardPr

; 453  : 		return CallNextHookEx (hMouse, nCode, wParam, lParam);

  0001a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hMouse
  00020	50		 push	 eax
  00021	8b 44 24 18	 mov	 eax, DWORD PTR _wParam$[esp+12]
  00025	50		 push	 eax
  00026	57		 push	 edi
  00027	51		 push	 ecx

; 487  : 	}
; 488  : 
; 489  : 	return CallNextHookEx (hMouse, nCode, wParam, lParam);

  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallNextHookEx@16
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi

; 490  : }

  00030	59		 pop	 ecx
  00031	c2 0c 00	 ret	 12			; 0000000cH
$LN12@KeyboardPr:

; 454  : 
; 455  : 	if ((lParam & 0x0000ffff) == 1 && !(lParam & 0x20000000) &&
; 456  : 	    (lParam & 0x80000000))

  00034	8b d0		 mov	 edx, eax
  00036	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  0003c	83 fa 01	 cmp	 edx, 1
  0003f	0f 85 28 01 00
	00		 jne	 $LN7@KeyboardPr
  00045	a9 00 00 00 20	 test	 eax, 536870912		; 20000000H
  0004a	0f 85 1d 01 00
	00		 jne	 $LN7@KeyboardPr
  00050	85 c0		 test	 eax, eax
  00052	0f 89 15 01 00
	00		 jns	 $LN7@KeyboardPr

; 457  : 	{
; 458  : 		if (nKey != lLastKey)

  00058	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?lLastKey@?1??KeyboardProc@@9@9

; 459  : 			nCapture = 1;	/* Capture this key */

  0005e	75 0c		 jne	 SHORT $LN27@KeyboardPr

; 460  : 		else if (nKey != lLastKey2)

  00060	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?lLastKey2@?1??KeyboardProc@@9@9
  00066	0f 84 01 01 00
	00		 je	 $LN7@KeyboardPr
$LN27@KeyboardPr:

; 461  : 			nCapture = 1;	/* Allow for one repeat */
; 462  : 	}
; 463  : 	if (nCapture)
; 464  : 	{
; 465  : 		DWORD dwTimer = GetTickCount ();

  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 466  : 		DWORD j = dwLastTimer - dwTimer;

  00072	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?dwLastTimer@?1??KeyboardProc@@9@9

; 467  : 		unsigned __int32 timeCrc = 0L;
; 468  : 		int i;
; 469  : 
; 470  : 		dwLastTimer = dwTimer;
; 471  : 		lLastKey2 = lLastKey;

  00078	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?lLastKey@?1??KeyboardProc@@9@9
  0007e	2b d0		 sub	 edx, eax
  00080	89 0d 00 00 00
	00		 mov	 DWORD PTR ?lLastKey2@?1??KeyboardProc@@9@9, ecx

; 472  : 		lLastKey = nKey;
; 473  : 
; 474  : 		for (i = 0; i < 4; i++)
; 475  : 		{
; 476  : 			timeCrc = UPDC32 (((unsigned char *) &j)[i], timeCrc);

  00086	0f b6 ca	 movzx	 ecx, dl
  00089	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR _crc_32_tab[ecx*4]
  00090	89 54 24 10	 mov	 DWORD PTR _j$80517[esp+8], edx
  00094	0f b6 d6	 movzx	 edx, dh
  00097	33 d1		 xor	 edx, ecx
  00099	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0009f	c1 e9 08	 shr	 ecx, 8
  000a2	33 0c 95 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[edx*4]
  000a9	0f b6 54 24 12	 movzx	 edx, BYTE PTR _j$80517[esp+10]
  000ae	33 d1		 xor	 edx, ecx
  000b0	c1 e9 08	 shr	 ecx, 8
  000b3	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000b9	33 0c 95 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[edx*4]
  000c0	0f b6 54 24 13	 movzx	 edx, BYTE PTR _j$80517[esp+11]
  000c5	33 d1		 xor	 edx, ecx
  000c7	c1 e9 08	 shr	 ecx, 8
  000ca	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000d0	33 0c 95 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[edx*4]

; 477  : 		}
; 478  : 
; 479  : 		for (i = 0; i < 4; i++)
; 480  : 		{
; 481  : 			timeCrc = UPDC32 (((unsigned char *) &dwTimer)[i], timeCrc);

  000d7	0f b6 d0	 movzx	 edx, al
  000da	33 d1		 xor	 edx, ecx
  000dc	89 44 24 08	 mov	 DWORD PTR _dwTimer$80516[esp+12], eax
  000e0	c1 e9 08	 shr	 ecx, 8
  000e3	a3 00 00 00 00	 mov	 DWORD PTR ?dwLastTimer@?1??KeyboardProc@@9@9, eax
  000e8	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000ee	33 0c 95 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[edx*4]
  000f5	0f b6 54 24 0a	 movzx	 edx, BYTE PTR _dwTimer$80516[esp+14]
  000fa	0f b6 c4	 movzx	 eax, ah
  000fd	33 c1		 xor	 eax, ecx
  000ff	c1 e9 08	 shr	 ecx, 8
  00102	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00107	33 0c 85 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[eax*4]
  0010e	0f b6 44 24 0b	 movzx	 eax, BYTE PTR _dwTimer$80516[esp+15]
  00113	33 d1		 xor	 edx, ecx
  00115	c1 e9 08	 shr	 ecx, 8
  00118	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0011e	33 0c 95 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[edx*4]
  00125	89 35 00 00 00
	00		 mov	 DWORD PTR ?lLastKey@?1??KeyboardProc@@9@9, esi
  0012b	33 c1		 xor	 eax, ecx
  0012d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00132	c1 e9 08	 shr	 ecx, 8
  00135	33 0c 85 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[eax*4]

; 482  : 		}
; 483  : 
; 484  : 		EnterCriticalSection (&critRandProt);

  0013c	68 00 00 00 00	 push	 OFFSET _critRandProt
  00141	8b f1		 mov	 esi, ecx
  00143	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 485  : 		RandaddInt32 ((unsigned __int32) (crc32int(&lParam) + timeCrc));

  00149	8d 4c 24 18	 lea	 ecx, DWORD PTR _lParam$[esp+8]
  0014d	51		 push	 ecx
  0014e	e8 00 00 00 00	 call	 _crc32int
  00153	03 c6		 add	 eax, esi
  00155	50		 push	 eax
  00156	e8 00 00 00 00	 call	 _RandAddInt
  0015b	83 c4 08	 add	 esp, 8

; 486  : 		LeaveCriticalSection (&critRandProt);

  0015e	68 00 00 00 00	 push	 OFFSET _critRandProt
  00163	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00169	8b 44 24 18	 mov	 eax, DWORD PTR _lParam$[esp+8]
$LN7@KeyboardPr:

; 487  : 	}
; 488  : 
; 489  : 	return CallNextHookEx (hMouse, nCode, wParam, lParam);

  0016d	8b 54 24 14	 mov	 edx, DWORD PTR _wParam$[esp+8]
  00171	50		 push	 eax
  00172	a1 00 00 00 00	 mov	 eax, DWORD PTR _hMouse
  00177	52		 push	 edx
  00178	57		 push	 edi
  00179	50		 push	 eax
  0017a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallNextHookEx@16
  00180	5f		 pop	 edi
  00181	5e		 pop	 esi

; 490  : }

  00182	59		 pop	 ecx
  00183	c2 0c 00	 ret	 12			; 0000000cH
_KeyboardProc@12 ENDP
_TEXT	ENDS
PUBLIC	_FastPoll
EXTRN	__imp__QueryPerformanceCounter@4:PROC
EXTRN	__imp__GetStartupInfoA@4:PROC
EXTRN	__imp__GetProcessWorkingSetSize@12:PROC
EXTRN	__imp__GetProcessTimes@20:PROC
EXTRN	__imp__GetThreadTimes@20:PROC
EXTRN	__imp__GlobalMemoryStatus@4:PROC
EXTRN	__imp__GetCursorPos@4:PROC
EXTRN	__imp__GetCaretPos@4:PROC
EXTRN	__imp__GetQueueStatus@4:PROC
EXTRN	__imp__GetProcessWindowStation@0:PROC
EXTRN	__imp__GetProcessHeap@0:PROC
EXTRN	__imp__GetOpenClipboardWindow@0:PROC
EXTRN	__imp__GetMessageTime@0:PROC
EXTRN	__imp__GetMessagePos@0:PROC
EXTRN	__imp__GetInputState@0:PROC
EXTRN	__imp__GetFocus@0:PROC
EXTRN	__imp__GetDesktopWindow@0:PROC
EXTRN	__imp__GetCurrentThreadId@0:PROC
EXTRN	__imp__GetCurrentThread@0:PROC
EXTRN	__imp__GetCurrentProcessId@0:PROC
EXTRN	__imp__GetCurrentProcess@0:PROC
EXTRN	__imp__GetClipboardViewer@0:PROC
EXTRN	__imp__GetClipboardOwner@0:PROC
EXTRN	__imp__GetCapture@0:PROC
EXTRN	__imp__GetActiveWindow@0:PROC
; Function compile flags: /Ogtpy
;	COMDAT _FastPoll
_TEXT	SEGMENT
_exitTime$ = -164					; size = 8
_minimumWorkingSetSize$ = -156				; size = 4
_kernelTime$ = -152					; size = 8
_dwTicks$80718 = -144					; size = 4
_userTime$ = -140					; size = 8
_creationTime$ = -132					; size = 8
_point$ = -124						; size = 8
_maximumWorkingSetSize$ = -116				; size = 4
_performanceCount$ = -112				; size = 8
_memoryStatus$ = -104					; size = 32
_startupInfo$80710 = -72				; size = 68
_FastPoll PROC						; COMDAT

; 657  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  0000c	53		 push	 ebx
  0000d	55		 push	 ebp

; 658  : 	int nOriginalRandIndex = nRandIndex;

  0000e	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR _nRandIndex
  00014	56		 push	 esi
  00015	57		 push	 edi

; 659  : 	static BOOL addedFixedItems = FALSE;
; 660  : 	FILETIME creationTime, exitTime, kernelTime, userTime;
; 661  : 	DWORD minimumWorkingSetSize, maximumWorkingSetSize;
; 662  : 	LARGE_INTEGER performanceCount;
; 663  : 	MEMORYSTATUS memoryStatus;
; 664  : 	HANDLE handle;
; 665  : 	POINT point;
; 666  : 
; 667  : 	/* Get various basic pieces of system information */
; 668  : 	RandaddInt32 (GetActiveWindow ());	/* Handle of active window */

  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetActiveWindow@0
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _RandAddInt
  00022	83 c4 04	 add	 esp, 4

; 669  : 	RandaddInt32 (GetCapture ());	/* Handle of window with mouse

  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCapture@0
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _RandAddInt
  00031	83 c4 04	 add	 esp, 4

; 670  : 					   capture */
; 671  : 	RandaddInt32 (GetClipboardOwner ());	/* Handle of clipboard owner */

  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClipboardOwner@0
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 _RandAddInt
  00040	83 c4 04	 add	 esp, 4

; 672  : 	RandaddInt32 (GetClipboardViewer ());	/* Handle of start of

  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClipboardViewer@0
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 _RandAddInt

; 673  : 						   clpbd.viewer list */
; 674  : 	RandaddInt32 (GetCurrentProcess ());	/* Pseudohandle of current

  0004f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetCurrentProcess@0
  00055	83 c4 04	 add	 esp, 4
  00058	ff d6		 call	 esi
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 _RandAddInt
  00060	83 c4 04	 add	 esp, 4

; 675  : 						   process */
; 676  : 	RandaddInt32 (GetCurrentProcessId ());	/* Current process ID */

  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcessId@0
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 _RandAddInt

; 677  : 	RandaddInt32 (GetCurrentThread ());	/* Pseudohandle of current

  0006f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetCurrentThread@0
  00075	83 c4 04	 add	 esp, 4
  00078	ff d7		 call	 edi
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 _RandAddInt
  00080	83 c4 04	 add	 esp, 4

; 678  : 						   thread */
; 679  : 	RandaddInt32 (GetCurrentThreadId ());	/* Current thread ID */

  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThreadId@0
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 _RandAddInt

; 680  : 	RandaddInt32 (GetCurrentTime ());	/* Milliseconds since Windows

  0008f	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetTickCount@0
  00095	83 c4 04	 add	 esp, 4
  00098	ff d3		 call	 ebx
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 _RandAddInt
  000a0	83 c4 04	 add	 esp, 4

; 681  : 						   started */
; 682  : 	RandaddInt32 (GetDesktopWindow ());	/* Handle of desktop window */

  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDesktopWindow@0
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 _RandAddInt
  000af	83 c4 04	 add	 esp, 4

; 683  : 	RandaddInt32 (GetFocus ());	/* Handle of window with kb.focus */

  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFocus@0
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 _RandAddInt
  000be	83 c4 04	 add	 esp, 4

; 684  : 	RandaddInt32 (GetInputState ());	/* Whether sys.queue has any events */

  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetInputState@0
  000c7	50		 push	 eax
  000c8	e8 00 00 00 00	 call	 _RandAddInt
  000cd	83 c4 04	 add	 esp, 4

; 685  : 	RandaddInt32 (GetMessagePos ());	/* Cursor pos.for last message */

  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetMessagePos@0
  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 _RandAddInt
  000dc	83 c4 04	 add	 esp, 4

; 686  : 	RandaddInt32 (GetMessageTime ());	/* 1 ms time for last message */

  000df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetMessageTime@0
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 _RandAddInt
  000eb	83 c4 04	 add	 esp, 4

; 687  : 	RandaddInt32 (GetOpenClipboardWindow ());	/* Handle of window with

  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetOpenClipboardWindow@0
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 _RandAddInt
  000fa	83 c4 04	 add	 esp, 4

; 688  : 							   clpbd.open */
; 689  : 	RandaddInt32 (GetProcessHeap ());	/* Handle of process heap */

  000fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 _RandAddInt
  00109	83 c4 04	 add	 esp, 4

; 690  : 	RandaddInt32 (GetProcessWindowStation ());	/* Handle of procs

  0010c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessWindowStation@0
  00112	50		 push	 eax
  00113	e8 00 00 00 00	 call	 _RandAddInt
  00118	83 c4 04	 add	 esp, 4

; 691  : 							   window station */
; 692  : 	RandaddInt32 (GetQueueStatus (QS_ALLEVENTS));	/* Types of events in

  0011b	68 bf 04 00 00	 push	 1215			; 000004bfH
  00120	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetQueueStatus@4
  00126	50		 push	 eax
  00127	e8 00 00 00 00	 call	 _RandAddInt
  0012c	83 c4 04	 add	 esp, 4

; 693  : 							   input queue */
; 694  : 
; 695  : 	/* Get multiword system information */
; 696  : 	GetCaretPos (&point);	/* Current caret position */

  0012f	8d 44 24 3c	 lea	 eax, DWORD PTR _point$[esp+184]
  00133	50		 push	 eax
  00134	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCaretPos@4

; 697  : 	RandaddBuf ((unsigned char *) &point, sizeof (POINT));

  0013a	8d 4c 24 3c	 lea	 ecx, DWORD PTR _point$[esp+184]
  0013e	6a 08		 push	 8
  00140	51		 push	 ecx
  00141	e8 00 00 00 00	 call	 _RandaddBuf
  00146	83 c4 08	 add	 esp, 8

; 698  : 	GetCursorPos (&point);	/* Current mouse cursor position */

  00149	8d 54 24 3c	 lea	 edx, DWORD PTR _point$[esp+184]
  0014d	52		 push	 edx
  0014e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCursorPos@4

; 699  : 	RandaddBuf ((unsigned char *) &point, sizeof (POINT));

  00154	8d 44 24 3c	 lea	 eax, DWORD PTR _point$[esp+184]
  00158	6a 08		 push	 8
  0015a	50		 push	 eax
  0015b	e8 00 00 00 00	 call	 _RandaddBuf
  00160	83 c4 08	 add	 esp, 8

; 700  : 
; 701  : 	/* Get percent of memory in use, bytes of physical memory, bytes of
; 702  : 	   free physical memory, bytes in paging file, free bytes in paging
; 703  : 	   file, user bytes of address space, and free user bytes */
; 704  : 	memoryStatus.dwLength = sizeof (MEMORYSTATUS);
; 705  : 	GlobalMemoryStatus (&memoryStatus);

  00163	8d 4c 24 50	 lea	 ecx, DWORD PTR _memoryStatus$[esp+184]
  00167	51		 push	 ecx
  00168	c7 44 24 54 20
	00 00 00	 mov	 DWORD PTR _memoryStatus$[esp+188], 32 ; 00000020H
  00170	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalMemoryStatus@4

; 706  : 	RandaddBuf ((unsigned char *) &memoryStatus, sizeof (MEMORYSTATUS));

  00176	8d 54 24 50	 lea	 edx, DWORD PTR _memoryStatus$[esp+184]
  0017a	6a 20		 push	 32			; 00000020H
  0017c	52		 push	 edx
  0017d	e8 00 00 00 00	 call	 _RandaddBuf
  00182	83 c4 08	 add	 esp, 8

; 707  : 
; 708  : 	/* Get thread and process creation time, exit time, time in kernel
; 709  : 	   mode, and time in user mode in 100ns intervals */
; 710  : 	handle = GetCurrentThread ();

  00185	ff d7		 call	 edi

; 711  : 	GetThreadTimes (handle, &creationTime, &exitTime, &kernelTime, &userTime);

  00187	8d 4c 24 2c	 lea	 ecx, DWORD PTR _userTime$[esp+184]
  0018b	51		 push	 ecx
  0018c	8d 54 24 24	 lea	 edx, DWORD PTR _kernelTime$[esp+188]
  00190	52		 push	 edx
  00191	8d 4c 24 1c	 lea	 ecx, DWORD PTR _exitTime$[esp+192]
  00195	51		 push	 ecx
  00196	8d 54 24 40	 lea	 edx, DWORD PTR _creationTime$[esp+196]
  0019a	52		 push	 edx
  0019b	50		 push	 eax
  0019c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetThreadTimes@20

; 712  : 	RandaddBuf ((unsigned char *) &creationTime, sizeof (FILETIME));

  001a2	8d 44 24 34	 lea	 eax, DWORD PTR _creationTime$[esp+184]
  001a6	6a 08		 push	 8
  001a8	50		 push	 eax
  001a9	e8 00 00 00 00	 call	 _RandaddBuf

; 713  : 	RandaddBuf ((unsigned char *) &exitTime, sizeof (FILETIME));

  001ae	8d 4c 24 1c	 lea	 ecx, DWORD PTR _exitTime$[esp+192]
  001b2	6a 08		 push	 8
  001b4	51		 push	 ecx
  001b5	e8 00 00 00 00	 call	 _RandaddBuf

; 714  : 	RandaddBuf ((unsigned char *) &kernelTime, sizeof (FILETIME));

  001ba	8d 54 24 30	 lea	 edx, DWORD PTR _kernelTime$[esp+200]
  001be	6a 08		 push	 8
  001c0	52		 push	 edx
  001c1	e8 00 00 00 00	 call	 _RandaddBuf

; 715  : 	RandaddBuf ((unsigned char *) &userTime, sizeof (FILETIME));

  001c6	8d 44 24 44	 lea	 eax, DWORD PTR _userTime$[esp+208]
  001ca	6a 08		 push	 8
  001cc	50		 push	 eax
  001cd	e8 00 00 00 00	 call	 _RandaddBuf
  001d2	83 c4 20	 add	 esp, 32			; 00000020H

; 716  : 	handle = GetCurrentProcess ();

  001d5	ff d6		 call	 esi

; 717  : 	GetProcessTimes (handle, &creationTime, &exitTime, &kernelTime, &userTime);

  001d7	8d 4c 24 2c	 lea	 ecx, DWORD PTR _userTime$[esp+184]
  001db	51		 push	 ecx
  001dc	8b f0		 mov	 esi, eax
  001de	8d 54 24 24	 lea	 edx, DWORD PTR _kernelTime$[esp+188]
  001e2	52		 push	 edx
  001e3	8d 44 24 1c	 lea	 eax, DWORD PTR _exitTime$[esp+192]
  001e7	50		 push	 eax
  001e8	8d 4c 24 40	 lea	 ecx, DWORD PTR _creationTime$[esp+196]
  001ec	51		 push	 ecx
  001ed	56		 push	 esi
  001ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessTimes@20

; 718  : 	RandaddBuf ((unsigned char *) &creationTime, sizeof (FILETIME));

  001f4	8d 54 24 34	 lea	 edx, DWORD PTR _creationTime$[esp+184]
  001f8	6a 08		 push	 8
  001fa	52		 push	 edx
  001fb	e8 00 00 00 00	 call	 _RandaddBuf

; 719  : 	RandaddBuf ((unsigned char *) &exitTime, sizeof (FILETIME));

  00200	8d 44 24 1c	 lea	 eax, DWORD PTR _exitTime$[esp+192]
  00204	6a 08		 push	 8
  00206	50		 push	 eax
  00207	e8 00 00 00 00	 call	 _RandaddBuf

; 720  : 	RandaddBuf ((unsigned char *) &kernelTime, sizeof (FILETIME));

  0020c	8d 4c 24 30	 lea	 ecx, DWORD PTR _kernelTime$[esp+200]
  00210	6a 08		 push	 8
  00212	51		 push	 ecx
  00213	e8 00 00 00 00	 call	 _RandaddBuf

; 721  : 	RandaddBuf ((unsigned char *) &userTime, sizeof (FILETIME));

  00218	8d 54 24 44	 lea	 edx, DWORD PTR _userTime$[esp+208]
  0021c	6a 08		 push	 8
  0021e	52		 push	 edx
  0021f	e8 00 00 00 00	 call	 _RandaddBuf
  00224	83 c4 20	 add	 esp, 32			; 00000020H

; 722  : 
; 723  : 	/* Get the minimum and maximum working set size for the current
; 724  : 	   process */
; 725  : 	GetProcessWorkingSetSize (handle, &minimumWorkingSetSize,
; 726  : 				  &maximumWorkingSetSize);

  00227	8d 44 24 44	 lea	 eax, DWORD PTR _maximumWorkingSetSize$[esp+184]
  0022b	50		 push	 eax
  0022c	8d 4c 24 20	 lea	 ecx, DWORD PTR _minimumWorkingSetSize$[esp+188]
  00230	51		 push	 ecx
  00231	56		 push	 esi
  00232	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessWorkingSetSize@12

; 727  : 	RandaddInt32 (minimumWorkingSetSize);

  00238	8b 54 24 1c	 mov	 edx, DWORD PTR _minimumWorkingSetSize$[esp+184]
  0023c	52		 push	 edx
  0023d	e8 00 00 00 00	 call	 _RandAddInt

; 728  : 	RandaddInt32 (maximumWorkingSetSize);

  00242	8b 44 24 48	 mov	 eax, DWORD PTR _maximumWorkingSetSize$[esp+188]
  00246	50		 push	 eax
  00247	e8 00 00 00 00	 call	 _RandAddInt
  0024c	83 c4 08	 add	 esp, 8

; 729  : 
; 730  : 	/* The following are fixed for the lifetime of the process so we only
; 731  : 	   add them once */
; 732  : 	if (addedFixedItems == 0)

  0024f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?addedFixedItems@?1??FastPoll@@9@9, 0
  00256	75 2c		 jne	 SHORT $LN4@FastPoll

; 733  : 	{
; 734  : 		STARTUPINFO startupInfo;
; 735  : 
; 736  : 		/* Get name of desktop, console window title, new window
; 737  : 		   position and size, window flags, and handles for stdin,
; 738  : 		   stdout, and stderr */
; 739  : 		startupInfo.cb = sizeof (STARTUPINFO);
; 740  : 		GetStartupInfo (&startupInfo);

  00258	8d 4c 24 70	 lea	 ecx, DWORD PTR _startupInfo$80710[esp+184]
  0025c	51		 push	 ecx
  0025d	c7 44 24 74 44
	00 00 00	 mov	 DWORD PTR _startupInfo$80710[esp+188], 68 ; 00000044H
  00265	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStartupInfoA@4

; 741  : 		RandaddBuf ((unsigned char *) &startupInfo, sizeof (STARTUPINFO));

  0026b	8d 54 24 70	 lea	 edx, DWORD PTR _startupInfo$80710[esp+184]
  0026f	6a 44		 push	 68			; 00000044H
  00271	52		 push	 edx
  00272	e8 00 00 00 00	 call	 _RandaddBuf
  00277	83 c4 08	 add	 esp, 8

; 742  : 		addedFixedItems = TRUE;

  0027a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?addedFixedItems@?1??FastPoll@@9@9, 1
$LN4@FastPoll:

; 743  : 	}
; 744  : 	/* The docs say QPC can fail if appropriate hardware is not
; 745  : 	   available. It works on 486 & Pentium boxes, but hasn't been tested
; 746  : 	   for 386 or RISC boxes */
; 747  : 	if (QueryPerformanceCounter (&performanceCount))

  00284	8d 44 24 48	 lea	 eax, DWORD PTR _performanceCount$[esp+184]
  00288	50		 push	 eax
  00289	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0028f	85 c0		 test	 eax, eax
  00291	74 09		 je	 SHORT $LN3@FastPoll

; 748  : 		RandaddBuf ((unsigned char *) &performanceCount, sizeof (LARGE_INTEGER));

  00293	6a 08		 push	 8
  00295	8d 4c 24 4c	 lea	 ecx, DWORD PTR _performanceCount$[esp+188]
  00299	51		 push	 ecx

; 749  : 	else

  0029a	eb 0d		 jmp	 SHORT $LN7@FastPoll
$LN3@FastPoll:

; 750  : 	{
; 751  : 		/* Millisecond accuracy at best... */
; 752  : 		DWORD dwTicks = GetTickCount ();

  0029c	ff d3		 call	 ebx

; 753  : 		RandaddBuf ((unsigned char *) &dwTicks, sizeof (dwTicks));

  0029e	6a 04		 push	 4
  002a0	8d 54 24 2c	 lea	 edx, DWORD PTR _dwTicks$80718[esp+188]
  002a4	89 44 24 2c	 mov	 DWORD PTR _dwTicks$80718[esp+188], eax
  002a8	52		 push	 edx
$LN7@FastPoll:
  002a9	e8 00 00 00 00	 call	 _RandaddBuf
  002ae	83 c4 08	 add	 esp, 8

; 754  : 	}
; 755  : 
; 756  : 	// CryptoAPI
; 757  : 	if (CryptoAPIAvailable && CryptGenRandom (hCryptProv, sizeof (buffer), buffer)) 

  002b1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _CryptoAPIAvailable, 0
  002b8	74 2c		 je	 SHORT $LN1@FastPoll
  002ba	a1 00 00 00 00	 mov	 eax, DWORD PTR _hCryptProv
  002bf	68 00 00 00 00	 push	 OFFSET _buffer
  002c4	68 40 01 00 00	 push	 320			; 00000140H
  002c9	50		 push	 eax
  002ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptGenRandom@12
  002d0	85 c0		 test	 eax, eax
  002d2	74 12		 je	 SHORT $LN1@FastPoll

; 758  : 		RandaddBuf (buffer, sizeof (buffer));

  002d4	68 40 01 00 00	 push	 320			; 00000140H
  002d9	68 00 00 00 00	 push	 OFFSET _buffer
  002de	e8 00 00 00 00	 call	 _RandaddBuf
  002e3	83 c4 08	 add	 esp, 8
$LN1@FastPoll:

; 759  : 
; 760  : 	/* Apply the pool mixing function */
; 761  : 	Randmix();

  002e6	e8 00 00 00 00	 call	 _Randmix

; 762  : 
; 763  : 	/* Restore the original pool cursor position. If this wasn't done, mouse coordinates
; 764  : 	   could be written to a limited area of the pool, especially when moving the mouse
; 765  : 	   uninterruptedly. The severity of the problem would depend on the length of data
; 766  : 	   written by FastPoll (if it was equal to the size of the pool, mouse coordinates
; 767  : 	   would be written only to a particular 4-byte area, whenever moving the mouse
; 768  : 	   uninterruptedly). */
; 769  : 	nRandIndex = nOriginalRandIndex;
; 770  : 
; 771  : 	return TRUE;
; 772  : }

  002eb	5f		 pop	 edi
  002ec	89 2d 00 00 00
	00		 mov	 DWORD PTR _nRandIndex, ebp
  002f2	b8 01 00 00 00	 mov	 eax, 1
  002f7	5e		 pop	 esi
  002f8	5d		 pop	 ebp
  002f9	5b		 pop	 ebx
  002fa	8b e5		 mov	 esp, ebp
  002fc	5d		 pop	 ebp
  002fd	c3		 ret	 0
_FastPoll ENDP
_TEXT	ENDS
PUBLIC	_RandgetBytes
; Function compile flags: /Ogtpy
;	COMDAT _RandgetBytes
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_forceSlowPoll$ = 16					; size = 4
_RandgetBytes PROC					; COMDAT

; 327  : 	int i;
; 328  : 	BOOL ret = TRUE;
; 329  : 
; 330  : 	if (!bRandDidInit || HashFunction == 0)

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bRandDidInit, 0
  00007	53		 push	 ebx
  00008	55		 push	 ebp
  00009	bb 01 00 00 00	 mov	 ebx, 1
  0000e	74 09		 je	 SHORT $LN20@RandgetByt
  00010	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _HashFunction, 0
  00017	75 07		 jne	 SHORT $LN21@RandgetByt
$LN20@RandgetByt:

; 331  : 		TC_THROW_FATAL_EXCEPTION;

  00019	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
$LN21@RandgetByt:

; 332  : 
; 333  : 	EnterCriticalSection (&critRandProt);

  00020	68 00 00 00 00	 push	 OFFSET _critRandProt
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 334  : 
; 335  : 	if (bDidSlowPoll == FALSE || forceSlowPoll)

  0002b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bDidSlowPoll, 0
  00032	74 07		 je	 SHORT $LN18@RandgetByt
  00034	83 7c 24 14 00	 cmp	 DWORD PTR _forceSlowPoll$[esp+4], 0
  00039	74 13		 je	 SHORT $LN16@RandgetByt
$LN18@RandgetByt:

; 336  : 	{
; 337  : 		if (!SlowPoll ())

  0003b	e8 00 00 00 00	 call	 _SlowPoll
  00040	85 c0		 test	 eax, eax
  00042	75 04		 jne	 SHORT $LN17@RandgetByt

; 338  : 			ret = FALSE;

  00044	33 db		 xor	 ebx, ebx

; 339  : 		else

  00046	eb 06		 jmp	 SHORT $LN16@RandgetByt
$LN17@RandgetByt:

; 340  : 			bDidSlowPoll = TRUE;

  00048	89 1d 00 00 00
	00		 mov	 DWORD PTR _bDidSlowPoll, ebx
$LN16@RandgetByt:

; 341  : 	}
; 342  : 
; 343  : 	if (!FastPoll ())

  0004e	e8 00 00 00 00	 call	 _FastPoll
  00053	85 c0		 test	 eax, eax
  00055	75 02		 jne	 SHORT $LN15@RandgetByt

; 344  : 		ret = FALSE;

  00057	33 db		 xor	 ebx, ebx
$LN15@RandgetByt:

; 345  : 
; 346  : 	/* There's never more than RNG_POOL_SIZE worth of randomess */
; 347  : 	if (len > RNG_POOL_SIZE)

  00059	8b 6c 24 10	 mov	 ebp, DWORD PTR _len$[esp+4]
  0005d	81 fd 40 01 00
	00		 cmp	 ebp, 320		; 00000140H
  00063	7e 12		 jle	 SHORT $LN14@RandgetByt

; 348  : 	{
; 349  : 		Error ("ERR_NOT_ENOUGH_RANDOM_DATA");	

  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@BENPDJPG@ERR_NOT_ENOUGH_RANDOM_DATA?$AA@
  0006a	e8 00 00 00 00	 call	 _Error
  0006f	83 c4 04	 add	 esp, 4
  00072	5d		 pop	 ebp

; 350  : 		len = RNG_POOL_SIZE;
; 351  : 		return FALSE;

  00073	33 c0		 xor	 eax, eax
  00075	5b		 pop	 ebx

; 385  : }

  00076	c3		 ret	 0
$LN14@RandgetByt:
  00077	56		 push	 esi

; 352  : 	}
; 353  : 
; 354  : 	// Requested number of bytes is copied from pool to output buffer,
; 355  : 	// pool is rehashed, and output buffer is XORed with new data from pool
; 356  : 	for (i = 0; i < len; i++)

  00078	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _pRandPool
  0007e	33 c9		 xor	 ecx, ecx
  00080	57		 push	 edi
  00081	8b 7c 24 14	 mov	 edi, DWORD PTR _buf$[esp+12]
  00085	85 ed		 test	 ebp, ebp
  00087	7e 21		 jle	 SHORT $LN30@RandgetByt
  00089	a1 00 00 00 00	 mov	 eax, DWORD PTR _randPoolReadIndex
  0008e	8b ff		 npad	 2
$LL13@RandgetByt:

; 357  : 	{
; 358  : 		buf[i] = pRandPool[randPoolReadIndex++];

  00090	8a 14 30	 mov	 dl, BYTE PTR [eax+esi]
  00093	40		 inc	 eax
  00094	88 14 39	 mov	 BYTE PTR [ecx+edi], dl

; 359  : 		if (randPoolReadIndex == RNG_POOL_SIZE) randPoolReadIndex = 0;

  00097	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  0009c	75 02		 jne	 SHORT $LN12@RandgetByt
  0009e	33 c0		 xor	 eax, eax
$LN12@RandgetByt:

; 352  : 	}
; 353  : 
; 354  : 	// Requested number of bytes is copied from pool to output buffer,
; 355  : 	// pool is rehashed, and output buffer is XORed with new data from pool
; 356  : 	for (i = 0; i < len; i++)

  000a0	41		 inc	 ecx
  000a1	3b cd		 cmp	 ecx, ebp
  000a3	7c eb		 jl	 SHORT $LL13@RandgetByt

; 357  : 	{
; 358  : 		buf[i] = pRandPool[randPoolReadIndex++];

  000a5	a3 00 00 00 00	 mov	 DWORD PTR _randPoolReadIndex, eax
$LN30@RandgetByt:

; 360  : 	}
; 361  : 
; 362  : 	/* Invert the pool */
; 363  : 	for (i = 0; i < RNG_POOL_SIZE / 4; i++)

  000aa	33 c0		 xor	 eax, eax
  000ac	8d 64 24 00	 npad	 4
$LL9@RandgetByt:

; 364  : 	{
; 365  : 		((unsigned __int32 *) pRandPool)[i] = ~((unsigned __int32 *) pRandPool)[i];

  000b0	8b 0c 86	 mov	 ecx, DWORD PTR [esi+eax*4]
  000b3	f7 d1		 not	 ecx
  000b5	89 0c 86	 mov	 DWORD PTR [esi+eax*4], ecx
  000b8	40		 inc	 eax
  000b9	83 f8 50	 cmp	 eax, 80			; 00000050H
  000bc	7c f2		 jl	 SHORT $LL9@RandgetByt

; 366  : 	}
; 367  : 
; 368  : 	// Mix the pool
; 369  : 	if (!FastPoll ())

  000be	e8 00 00 00 00	 call	 _FastPoll
  000c3	85 c0		 test	 eax, eax
  000c5	75 02		 jne	 SHORT $LN31@RandgetByt

; 370  : 		ret = FALSE;

  000c7	33 db		 xor	 ebx, ebx
$LN31@RandgetByt:

; 371  : 
; 372  : 	// XOR the current pool content into the output buffer to prevent pool state leaks
; 373  : 	for (i = 0; i < len; i++)

  000c9	33 c9		 xor	 ecx, ecx
  000cb	85 ed		 test	 ebp, ebp
  000cd	7e 2b		 jle	 SHORT $LN3@RandgetByt
  000cf	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _pRandPool
  000d5	a1 00 00 00 00	 mov	 eax, DWORD PTR _randPoolReadIndex
  000da	8d 9b 00 00 00
	00		 npad	 6
$LL5@RandgetByt:

; 374  : 	{
; 375  : 		buf[i] ^= pRandPool[randPoolReadIndex++];

  000e0	8a 14 30	 mov	 dl, BYTE PTR [eax+esi]
  000e3	30 14 39	 xor	 BYTE PTR [ecx+edi], dl
  000e6	40		 inc	 eax

; 376  : 		if (randPoolReadIndex == RNG_POOL_SIZE) randPoolReadIndex = 0;

  000e7	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  000ec	75 02		 jne	 SHORT $LN4@RandgetByt
  000ee	33 c0		 xor	 eax, eax
$LN4@RandgetByt:

; 371  : 
; 372  : 	// XOR the current pool content into the output buffer to prevent pool state leaks
; 373  : 	for (i = 0; i < len; i++)

  000f0	41		 inc	 ecx
  000f1	3b cd		 cmp	 ecx, ebp
  000f3	7c eb		 jl	 SHORT $LL5@RandgetByt

; 374  : 	{
; 375  : 		buf[i] ^= pRandPool[randPoolReadIndex++];

  000f5	a3 00 00 00 00	 mov	 DWORD PTR _randPoolReadIndex, eax
$LN3@RandgetByt:

; 377  : 	}
; 378  : 
; 379  : 	LeaveCriticalSection (&critRandProt);

  000fa	68 00 00 00 00	 push	 OFFSET _critRandProt
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00105	5f		 pop	 edi
  00106	5e		 pop	 esi

; 380  : 
; 381  : 	if (!ret)

  00107	85 db		 test	 ebx, ebx
  00109	75 07		 jne	 SHORT $LN1@RandgetByt

; 382  : 		TC_THROW_FATAL_EXCEPTION;

  0010b	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
$LN1@RandgetByt:
  00112	5d		 pop	 ebp

; 383  : 
; 384  : 	return ret;

  00113	8b c3		 mov	 eax, ebx
  00115	5b		 pop	 ebx

; 385  : }

  00116	c3		 ret	 0
_RandgetBytes ENDP
_TEXT	ENDS
EXTRN	__endthreadex:PROC
EXTRN	__imp__Sleep@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT _PeriodicFastPollThreadProc@4
_TEXT	SEGMENT
_dummy$ = 8						; size = 4
_PeriodicFastPollThreadProc@4 PROC			; COMDAT

; 494  : {

  00000	53		 push	 ebx
  00001	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__EnterCriticalSection@4
  00007	56		 push	 esi
  00008	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__LeaveCriticalSection@4
  0000e	57		 push	 edi
  0000f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__Sleep@4
$LL5@PeriodicFa:

; 495  : 	if (dummy);		/* Remove unused parameter warning */
; 496  : 
; 497  : 	for (;;)
; 498  : 	{
; 499  : 		EnterCriticalSection (&critRandProt);

  00015	68 00 00 00 00	 push	 OFFSET _critRandProt
  0001a	ff d3		 call	 ebx

; 500  : 
; 501  : 		if (bThreadTerminate)

  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR _bThreadTerminate
  00021	85 c0		 test	 eax, eax
  00023	74 2b		 je	 SHORT $LN3@PeriodicFa

; 502  : 		{
; 503  : 			bThreadTerminate = FALSE;
; 504  : 			LeaveCriticalSection (&critRandProt);

  00025	68 00 00 00 00	 push	 OFFSET _critRandProt
  0002a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bThreadTerminate, 0
  00034	ff d6		 call	 esi

; 505  : 			_endthreadex (0);

  00036	6a 00		 push	 0
  00038	e8 00 00 00 00	 call	 __endthreadex
  0003d	83 c4 04	 add	 esp, 4

; 510  : 		}
; 511  : 
; 512  : 		LeaveCriticalSection (&critRandProt);

  00040	68 00 00 00 00	 push	 OFFSET _critRandProt
  00045	ff d6		 call	 esi

; 513  : 
; 514  : 		Sleep (FASTPOLL_INTERVAL);

  00047	68 f4 01 00 00	 push	 500			; 000001f4H
  0004c	ff d7		 call	 edi

; 515  : 	}

  0004e	eb c5		 jmp	 SHORT $LL5@PeriodicFa
$LN3@PeriodicFa:

; 506  : 		}
; 507  : 		else if (bFastPollEnabled)

  00050	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _bFastPollEnabled
  00056	85 c9		 test	 ecx, ecx
  00058	74 05		 je	 SHORT $LN1@PeriodicFa

; 508  : 		{
; 509  : 			FastPoll ();

  0005a	e8 00 00 00 00	 call	 _FastPoll
$LN1@PeriodicFa:

; 510  : 		}
; 511  : 
; 512  : 		LeaveCriticalSection (&critRandProt);

  0005f	68 00 00 00 00	 push	 OFFSET _critRandProt
  00064	ff d6		 call	 esi

; 513  : 
; 514  : 		Sleep (FASTPOLL_INTERVAL);

  00066	68 f4 01 00 00	 push	 500			; 000001f4H
  0006b	ff d7		 call	 edi

; 515  : 	}

  0006d	eb a6		 jmp	 SHORT $LL5@PeriodicFa
_PeriodicFastPollThreadProc@4 ENDP
_TEXT	ENDS
PUBLIC	_Randinit
EXTRN	__beginthreadex:PROC
EXTRN	__imp__CryptAcquireContextA@20:PROC
EXTRN	_handleWin32Error:PROC
EXTRN	__imp__SetWindowsHookExA@16:PROC
EXTRN	__imp__VirtualLock@8:PROC
EXTRN	_malloc:PROC
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	_GetMaxPkcs5OutSize:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogtpy
;	COMDAT _Randinit
_TEXT	SEGMENT
_Randinit PROC						; COMDAT

; 69   : 	if (GetMaxPkcs5OutSize() > RNG_POOL_SIZE)

  00000	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize
  00005	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  0000a	7e 07		 jle	 SHORT $LN9@Randinit

; 70   : 		TC_THROW_FATAL_EXCEPTION;

  0000c	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
$LN9@Randinit:

; 71   : 
; 72   : 	if(bRandDidInit) 

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bRandDidInit, 0
  0001a	74 03		 je	 SHORT $LN8@Randinit

; 73   : 		return 0;

  0001c	33 c0		 xor	 eax, eax

; 116  : }

  0001e	c3		 ret	 0
$LN8@Randinit:
  0001f	56		 push	 esi

; 74   : 
; 75   : 	InitializeCriticalSection (&critRandProt);

  00020	68 00 00 00 00	 push	 OFFSET _critRandProt
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 76   : 
; 77   : 	bRandDidInit = TRUE;
; 78   : 
; 79   : 	if (pRandPool == NULL)

  0002b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _pRandPool, 0
  00032	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bRandDidInit, 1
  0003c	75 4d		 jne	 SHORT $LN7@Randinit

; 80   : 	{
; 81   : 		pRandPool = (unsigned char *) TCalloc (RANDOMPOOL_ALLOCSIZE);

  0003e	68 40 01 00 00	 push	 320			; 00000140H
  00043	e8 00 00 00 00	 call	 _malloc
  00048	8b f0		 mov	 esi, eax
  0004a	83 c4 04	 add	 esp, 4
  0004d	89 35 00 00 00
	00		 mov	 DWORD PTR _pRandPool, esi

; 82   : 		if (pRandPool == NULL)

  00053	85 f6		 test	 esi, esi
  00055	0f 84 f0 00 00
	00		 je	 $error$80253

; 83   : 			goto error;
; 84   : 
; 85   : 		bDidSlowPoll = FALSE;
; 86   : 		RandomPoolEnrichedByUser = FALSE;
; 87   : 
; 88   : 		memset (pRandPool, 0, RANDOMPOOL_ALLOCSIZE);

  0005b	68 40 01 00 00	 push	 320			; 00000140H
  00060	6a 00		 push	 0
  00062	56		 push	 esi
  00063	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bDidSlowPoll, 0
  0006d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _RandomPoolEnrichedByUser, 0
  00077	e8 00 00 00 00	 call	 _memset
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 89   : 		VirtualLock (pRandPool, RANDOMPOOL_ALLOCSIZE);

  0007f	68 40 01 00 00	 push	 320			; 00000140H
  00084	56		 push	 esi
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualLock@8
$LN7@Randinit:

; 90   : 	}
; 91   : 
; 92   : 	hKeyboard = SetWindowsHookEx (WH_KEYBOARD, (HOOKPROC)&KeyboardProc, NULL, GetCurrentThreadId ());

  0008b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetCurrentThreadId@0
  00091	57		 push	 edi
  00092	ff d6		 call	 esi
  00094	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__SetWindowsHookExA@16
  0009a	50		 push	 eax
  0009b	6a 00		 push	 0
  0009d	68 00 00 00 00	 push	 OFFSET _KeyboardProc@12
  000a2	6a 02		 push	 2
  000a4	ff d7		 call	 edi
  000a6	a3 00 00 00 00	 mov	 DWORD PTR _hKeyboard, eax

; 93   : 	if (hKeyboard == 0) handleWin32Error (0);

  000ab	85 c0		 test	 eax, eax
  000ad	75 09		 jne	 SHORT $LN5@Randinit
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 _handleWin32Error
  000b5	83 c4 04	 add	 esp, 4
$LN5@Randinit:

; 94   : 
; 95   : 	hMouse = SetWindowsHookEx (WH_MOUSE, (HOOKPROC)&MouseProc, NULL, GetCurrentThreadId ());

  000b8	ff d6		 call	 esi
  000ba	50		 push	 eax
  000bb	6a 00		 push	 0
  000bd	68 00 00 00 00	 push	 OFFSET _MouseProc@12
  000c2	6a 07		 push	 7
  000c4	ff d7		 call	 edi
  000c6	a3 00 00 00 00	 mov	 DWORD PTR _hMouse, eax
  000cb	5f		 pop	 edi

; 96   : 	if (hMouse == 0)

  000cc	85 c0		 test	 eax, eax
  000ce	75 1a		 jne	 SHORT $LN4@Randinit

; 97   : 	{
; 98   : 		handleWin32Error (0);

  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 _handleWin32Error
  000d6	83 c4 04	 add	 esp, 4

; 112  : 
; 113  : error:
; 114  : 	RandStop (TRUE);

  000d9	6a 01		 push	 1
  000db	e8 00 00 00 00	 call	 _RandStop
  000e0	83 c4 04	 add	 esp, 4

; 115  : 	return 1;

  000e3	b8 01 00 00 00	 mov	 eax, 1
  000e8	5e		 pop	 esi

; 116  : }

  000e9	c3		 ret	 0
$LN4@Randinit:

; 99   : 		goto error;
; 100  : 	}
; 101  : 
; 102  : 	if (!CryptAcquireContext (&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)
; 103  : 		&& !CryptAcquireContext (&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET))

  000ea	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CryptAcquireContextA@20
  000f0	68 00 00 00 f0	 push	 -268435456		; f0000000H
  000f5	6a 01		 push	 1
  000f7	6a 00		 push	 0
  000f9	6a 00		 push	 0
  000fb	68 00 00 00 00	 push	 OFFSET _hCryptProv
  00100	ff d6		 call	 esi
  00102	85 c0		 test	 eax, eax
  00104	75 1b		 jne	 SHORT $LN3@Randinit
  00106	6a 08		 push	 8
  00108	6a 01		 push	 1
  0010a	50		 push	 eax
  0010b	50		 push	 eax
  0010c	68 00 00 00 00	 push	 OFFSET _hCryptProv
  00111	ff d6		 call	 esi

; 104  : 		CryptoAPIAvailable = FALSE;

  00113	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CryptoAPIAvailable, 0
  0011d	85 c0		 test	 eax, eax
  0011f	74 0a		 je	 SHORT $LN2@Randinit
$LN3@Randinit:

; 105  : 	else
; 106  : 		CryptoAPIAvailable = TRUE;

  00121	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CryptoAPIAvailable, 1
$LN2@Randinit:

; 107  : 
; 108  : 	if (!(PeriodicFastPollThreadHandle = (HANDLE) _beginthreadex (NULL, 0, PeriodicFastPollThreadProc, NULL, 0, NULL)))

  0012b	6a 00		 push	 0
  0012d	6a 00		 push	 0
  0012f	6a 00		 push	 0
  00131	68 00 00 00 00	 push	 OFFSET _PeriodicFastPollThreadProc@4
  00136	6a 00		 push	 0
  00138	6a 00		 push	 0
  0013a	e8 00 00 00 00	 call	 __beginthreadex
  0013f	83 c4 18	 add	 esp, 24			; 00000018H
  00142	a3 00 00 00 00	 mov	 DWORD PTR _PeriodicFastPollThreadHandle, eax
  00147	85 c0		 test	 eax, eax
  00149	75 11		 jne	 SHORT $LN1@Randinit
$error$80253:

; 112  : 
; 113  : error:
; 114  : 	RandStop (TRUE);

  0014b	6a 01		 push	 1
  0014d	e8 00 00 00 00	 call	 _RandStop
  00152	83 c4 04	 add	 esp, 4

; 115  : 	return 1;

  00155	b8 01 00 00 00	 mov	 eax, 1
  0015a	5e		 pop	 esi

; 116  : }

  0015b	c3		 ret	 0
$LN1@Randinit:

; 109  : 		goto error;
; 110  : 
; 111  : 	return 0;

  0015c	33 c0		 xor	 eax, eax
  0015e	5e		 pop	 esi

; 116  : }

  0015f	c3		 ret	 0
_Randinit ENDP
_TEXT	ENDS
END
