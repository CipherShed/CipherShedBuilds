; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\home\public\Desktop\projects\cipherShed\src\Common\Xml.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

; Function compile flags: /Ogtpy
; File c:\home\public\desktop\projects\ciphershed\src\common\xml.c
;	COMDAT _BeginsWith
_TEXT	SEGMENT
_BeginsWith PROC					; COMDAT
; _string$ = eax
; _subString$ = edx

; 15   : {

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax

; 16   : 	while (*string++ == *subString++)

  00003	8a 06		 mov	 al, BYTE PTR [esi]
  00005	3a 02		 cmp	 al, BYTE PTR [edx]
  00007	75 1a		 jne	 SHORT $LN10@BeginsWith
  00009	8d a4 24 00 00
	00 00		 npad	 7
$LL4@BeginsWith:

; 17   : 	{
; 18   : 		if (*subString == 0) return TRUE;

  00010	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  00013	42		 inc	 edx
  00014	46		 inc	 esi
  00015	84 c0		 test	 al, al
  00017	74 0e		 je	 SHORT $LN8@BeginsWith

; 19   : 		if (*string == 0) return FALSE;

  00019	8a 0e		 mov	 cl, BYTE PTR [esi]
  0001b	84 c9		 test	 cl, cl
  0001d	74 04		 je	 SHORT $LN10@BeginsWith

; 16   : 	while (*string++ == *subString++)

  0001f	3a c8		 cmp	 cl, al
  00021	74 ed		 je	 SHORT $LL4@BeginsWith
$LN10@BeginsWith:

; 20   : 	}
; 21   : 
; 22   : 	return FALSE;

  00023	33 c0		 xor	 eax, eax
  00025	5e		 pop	 esi

; 23   : }

  00026	c3		 ret	 0
$LN8@BeginsWith:

; 17   : 	{
; 18   : 		if (*subString == 0) return TRUE;

  00027	b8 01 00 00 00	 mov	 eax, 1
  0002c	5e		 pop	 esi

; 23   : }

  0002d	c3		 ret	 0
_BeginsWith ENDP
_TEXT	ENDS
PUBLIC	_XmlNextNode
EXTRN	_strchr:PROC
; Function compile flags: /Ogtpy
;	COMDAT _XmlNextNode
_TEXT	SEGMENT
_xmlNode$ = 8						; size = 4
_XmlNextNode PROC					; COMDAT

; 28   : 	char *t = xmlNode + 1;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _xmlNode$[esp-4]
  00004	40		 inc	 eax

; 29   : 	while ((t = strchr (t, '<')) != NULL)

  00005	6a 3c		 push	 60			; 0000003cH
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 _strchr
  0000d	83 c4 08	 add	 esp, 8
  00010	85 c0		 test	 eax, eax
  00012	74 18		 je	 SHORT $LN2@XmlNextNod
$LL3@XmlNextNod:

; 30   : 	{
; 31   : 		if (t[1] != '/')

  00014	80 78 01 2f	 cmp	 BYTE PTR [eax+1], 47	; 0000002fH
  00018	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0001b	75 11		 jne	 SHORT $LN4@XmlNextNod
  0001d	6a 3c		 push	 60			; 0000003cH
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 _strchr
  00025	83 c4 08	 add	 esp, 8
  00028	85 c0		 test	 eax, eax
  0002a	75 e8		 jne	 SHORT $LL3@XmlNextNod
$LN2@XmlNextNod:

; 32   : 			return t;
; 33   : 
; 34   : 		t++;
; 35   : 	}
; 36   : 
; 37   : 	return NULL;

  0002c	33 c0		 xor	 eax, eax
$LN4@XmlNextNod:

; 38   : }

  0002e	c3		 ret	 0
_XmlNextNode ENDP
_TEXT	ENDS
PUBLIC	_XmlFindElement
; Function compile flags: /Ogtpy
;	COMDAT _XmlFindElement
_TEXT	SEGMENT
_nameLen$ = 8						; size = 4
_xmlNode$ = 8						; size = 4
_nodeName$ = 12						; size = 4
_XmlFindElement PROC					; COMDAT

; 43   : 	char *t = xmlNode;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _xmlNode$[esp-4]
  00004	53		 push	 ebx
  00005	55		 push	 ebp

; 44   : 	size_t nameLen = strlen (nodeName);

  00006	8b 6c 24 10	 mov	 ebp, DWORD PTR _nodeName$[esp+4]
  0000a	56		 push	 esi
  0000b	8b cd		 mov	 ecx, ebp
  0000d	57		 push	 edi
  0000e	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$LL30@XmlFindEle:
  00011	8a 11		 mov	 dl, BYTE PTR [ecx]
  00013	41		 inc	 ecx
  00014	84 d2		 test	 dl, dl
  00016	75 f9		 jne	 SHORT $LL30@XmlFindEle
  00018	2b ce		 sub	 ecx, esi
  0001a	89 4c 24 14	 mov	 DWORD PTR _nameLen$[esp+12], ecx
  0001e	8b ff		 npad	 2
$LL5@XmlFindEle:

; 45   : 
; 46   : 	do
; 47   : 	{
; 48   : 		if (BeginsWith (t + 1, nodeName)
; 49   : 			&& (t[nameLen + 1] == '>'
; 50   : 			|| t[nameLen + 1] == ' ')) return t;

  00020	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00023	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  00026	8b cd		 mov	 ecx, ebp
  00028	3a 55 00	 cmp	 dl, BYTE PTR [ebp]
  0002b	75 2b		 jne	 SHORT $LN4@XmlFindEle
  0002d	8b f7		 mov	 esi, edi
  0002f	2b f5		 sub	 esi, ebp
$LL11@XmlFindEle:
  00031	8a 59 01	 mov	 bl, BYTE PTR [ecx+1]
  00034	41		 inc	 ecx
  00035	84 db		 test	 bl, bl
  00037	74 0d		 je	 SHORT $LN28@XmlFindEle
  00039	8a 14 0e	 mov	 dl, BYTE PTR [esi+ecx]
  0003c	84 d2		 test	 dl, dl
  0003e	74 18		 je	 SHORT $LN4@XmlFindEle
  00040	3a d3		 cmp	 dl, bl
  00042	74 ed		 je	 SHORT $LL11@XmlFindEle

; 51   : 
; 52   : 	} while (t = XmlNextNode (t));

  00044	eb 12		 jmp	 SHORT $LN4@XmlFindEle
$LN28@XmlFindEle:

; 45   : 
; 46   : 	do
; 47   : 	{
; 48   : 		if (BeginsWith (t + 1, nodeName)
; 49   : 			&& (t[nameLen + 1] == '>'
; 50   : 			|| t[nameLen + 1] == ' ')) return t;

  00046	8b 4c 24 14	 mov	 ecx, DWORD PTR _nameLen$[esp+12]
  0004a	8a 4c 01 01	 mov	 cl, BYTE PTR [ecx+eax+1]
  0004e	80 f9 3e	 cmp	 cl, 62			; 0000003eH
  00051	74 2e		 je	 SHORT $LN6@XmlFindEle
  00053	80 f9 20	 cmp	 cl, 32			; 00000020H
  00056	74 29		 je	 SHORT $LN6@XmlFindEle
$LN4@XmlFindEle:

; 51   : 
; 52   : 	} while (t = XmlNextNode (t));

  00058	6a 3c		 push	 60			; 0000003cH
  0005a	57		 push	 edi
  0005b	e8 00 00 00 00	 call	 _strchr
  00060	83 c4 08	 add	 esp, 8
  00063	85 c0		 test	 eax, eax
  00065	74 18		 je	 SHORT $LN25@XmlFindEle
$LL16@XmlFindEle:
  00067	80 78 01 2f	 cmp	 BYTE PTR [eax+1], 47	; 0000002fH
  0006b	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0006e	75 b0		 jne	 SHORT $LL5@XmlFindEle
  00070	6a 3c		 push	 60			; 0000003cH
  00072	51		 push	 ecx
  00073	e8 00 00 00 00	 call	 _strchr
  00078	83 c4 08	 add	 esp, 8
  0007b	85 c0		 test	 eax, eax
  0007d	75 e8		 jne	 SHORT $LL16@XmlFindEle
$LN25@XmlFindEle:

; 53   : 
; 54   : 	return NULL;

  0007f	33 c0		 xor	 eax, eax
$LN6@XmlFindEle:
  00081	5f		 pop	 edi
  00082	5e		 pop	 esi
  00083	5d		 pop	 ebp
  00084	5b		 pop	 ebx

; 55   : }

  00085	c3		 ret	 0
_XmlFindElement ENDP
_TEXT	ENDS
PUBLIC	??_C@_04GFKCAHFK@?5?$DN?5?$CC?$AA@		; `string'
PUBLIC	??_C@_03PFIILPDO@?5?$DN?$CC?$AA@		; `string'
PUBLIC	??_C@_03EDAFAAFP@?$DN?5?$CC?$AA@		; `string'
PUBLIC	??_C@_02ILLPBGAO@?$DN?$CC?$AA@			; `string'
PUBLIC	_XmlGetAttributeText
EXTRN	_strstr:PROC
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_04GFKCAHFK@?5?$DN?5?$CC?$AA@
CONST	SEGMENT
??_C@_04GFKCAHFK@?5?$DN?5?$CC?$AA@ DB ' = "', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03PFIILPDO@?5?$DN?$CC?$AA@
CONST	SEGMENT
??_C@_03PFIILPDO@?5?$DN?$CC?$AA@ DB ' ="', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03EDAFAAFP@?$DN?5?$CC?$AA@
CONST	SEGMENT
??_C@_03EDAFAAFP@?$DN?5?$CC?$AA@ DB '= "', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02ILLPBGAO@?$DN?$CC?$AA@
CONST	SEGMENT
??_C@_02ILLPBGAO@?$DN?$CC?$AA@ DB '="', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _XmlGetAttributeText
_TEXT	SEGMENT
_e$ = 8							; size = 4
_xmlNode$ = 8						; size = 4
_xmlAttrName$ = 12					; size = 4
_xmlAttrValue$ = 16					; size = 4
_xmlAttrValueSize$ = 20					; size = 4
_XmlGetAttributeText PROC				; COMDAT

; 77   : 	char *t = xmlNode;
; 78   : 	char *e = xmlNode;
; 79   : 	int l = 0;
; 80   : 
; 81   : 	xmlAttrValue[0] = 0;

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR _xmlAttrValue$[esp-4]
  00004	56		 push	 esi

; 82   : 	if (t[0] != '<') return NULL;

  00005	8b 74 24 08	 mov	 esi, DWORD PTR _xmlNode$[esp]
  00009	c6 00 00	 mov	 BYTE PTR [eax], 0
  0000c	80 3e 3c	 cmp	 BYTE PTR [esi], 60	; 0000003cH
  0000f	74 04		 je	 SHORT $LN10@XmlGetAttr
  00011	33 c0		 xor	 eax, eax
  00013	5e		 pop	 esi

; 113  : }

  00014	c3		 ret	 0
$LN10@XmlGetAttr:
  00015	53		 push	 ebx

; 83   : 
; 84   : 	e = strchr (e, '>');

  00016	6a 3e		 push	 62			; 0000003eH
  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 _strchr
  0001e	8b d8		 mov	 ebx, eax
  00020	83 c4 08	 add	 esp, 8
  00023	89 5c 24 0c	 mov	 DWORD PTR _e$[esp+4], ebx

; 85   : 	if (e == NULL) return NULL;

  00027	85 db		 test	 ebx, ebx
  00029	75 03		 jne	 SHORT $LN37@XmlGetAttr
  0002b	5b		 pop	 ebx
  0002c	5e		 pop	 esi

; 113  : }

  0002d	c3		 ret	 0
$LN37@XmlGetAttr:
  0002e	55		 push	 ebp
  0002f	57		 push	 edi

; 86   : 
; 87   : 	while ((t = strstr (t, xmlAttrName)) && t < e)

  00030	8b 7c 24 18	 mov	 edi, DWORD PTR _xmlAttrName$[esp+12]
  00034	57		 push	 edi
  00035	56		 push	 esi
  00036	e8 00 00 00 00	 call	 _strstr
  0003b	8b e8		 mov	 ebp, eax
  0003d	83 c4 08	 add	 esp, 8
  00040	85 ed		 test	 ebp, ebp
  00042	0f 84 cd 00 00
	00		 je	 $LN3@XmlGetAttr
$LL8@XmlGetAttr:
  00048	3b eb		 cmp	 ebp, ebx
  0004a	0f 83 cc 00 00
	00		 jae	 $LN64@XmlGetAttr

; 88   : 	{
; 89   : 		char *o = t + strlen (xmlAttrName);

  00050	8b cf		 mov	 ecx, edi
  00052	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL59@XmlGetAttr:
  00055	8a 01		 mov	 al, BYTE PTR [ecx]
  00057	41		 inc	 ecx
  00058	84 c0		 test	 al, al
  0005a	75 f9		 jne	 SHORT $LL59@XmlGetAttr
  0005c	2b ca		 sub	 ecx, edx

; 90   : 		if (t[-1] == ' '
; 91   : 			&&
; 92   : 			(BeginsWith (o, "=\"")
; 93   : 			|| BeginsWith (o, "= \"")
; 94   : 			|| BeginsWith (o, " =\"")
; 95   : 			|| BeginsWith (o, " = \""))
; 96   : 			)

  0005e	80 7d ff 20	 cmp	 BYTE PTR [ebp-1], 32	; 00000020H
  00062	8d 34 29	 lea	 esi, DWORD PTR [ecx+ebp]
  00065	0f 85 95 00 00
	00		 jne	 $LN49@XmlGetAttr
  0006b	8a 1e		 mov	 bl, BYTE PTR [esi]
  0006d	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_02ILLPBGAO@?$DN?$CC?$AA@
  00072	80 fb 3d	 cmp	 bl, 61			; 0000003dH
  00075	75 20		 jne	 SHORT $LN60@XmlGetAttr
  00077	8b fe		 mov	 edi, esi
  00079	2b f9		 sub	 edi, ecx
  0007b	eb 03 8d 49 00	 npad	 5
$LL16@XmlGetAttr:
  00080	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00083	41		 inc	 ecx
  00084	84 c0		 test	 al, al
  00086	0f 84 90 00 00
	00		 je	 $LN64@XmlGetAttr
  0008c	8a 14 0f	 mov	 dl, BYTE PTR [edi+ecx]
  0008f	84 d2		 test	 dl, dl
  00091	74 04		 je	 SHORT $LN60@XmlGetAttr
  00093	3a d0		 cmp	 dl, al
  00095	74 e9		 je	 SHORT $LL16@XmlGetAttr
$LN60@XmlGetAttr:
  00097	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_03EDAFAAFP@?$DN?5?$CC?$AA@
  0009c	80 fb 3d	 cmp	 bl, 61			; 0000003dH
  0009f	75 17		 jne	 SHORT $LN61@XmlGetAttr
  000a1	8b fe		 mov	 edi, esi
  000a3	2b f9		 sub	 edi, ecx
$LL22@XmlGetAttr:
  000a5	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  000a8	41		 inc	 ecx
  000a9	84 c0		 test	 al, al
  000ab	74 6f		 je	 SHORT $LN64@XmlGetAttr
  000ad	8a 14 0f	 mov	 dl, BYTE PTR [edi+ecx]
  000b0	84 d2		 test	 dl, dl
  000b2	74 04		 je	 SHORT $LN61@XmlGetAttr
  000b4	3a d0		 cmp	 dl, al
  000b6	74 ed		 je	 SHORT $LL22@XmlGetAttr
$LN61@XmlGetAttr:
  000b8	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_03PFIILPDO@?5?$DN?$CC?$AA@
  000bd	80 fb 20	 cmp	 bl, 32			; 00000020H
  000c0	75 17		 jne	 SHORT $LN62@XmlGetAttr
  000c2	8b fe		 mov	 edi, esi
  000c4	2b f9		 sub	 edi, ecx
$LL28@XmlGetAttr:
  000c6	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  000c9	41		 inc	 ecx
  000ca	84 c0		 test	 al, al
  000cc	74 4e		 je	 SHORT $LN64@XmlGetAttr
  000ce	8a 14 0f	 mov	 dl, BYTE PTR [edi+ecx]
  000d1	84 d2		 test	 dl, dl
  000d3	74 04		 je	 SHORT $LN62@XmlGetAttr
  000d5	3a d0		 cmp	 dl, al
  000d7	74 ed		 je	 SHORT $LL28@XmlGetAttr
$LN62@XmlGetAttr:
  000d9	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_04GFKCAHFK@?5?$DN?5?$CC?$AA@
  000de	80 fb 20	 cmp	 bl, 32			; 00000020H
  000e1	75 15		 jne	 SHORT $LN63@XmlGetAttr
  000e3	2b f1		 sub	 esi, ecx
$LL34@XmlGetAttr:
  000e5	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  000e8	41		 inc	 ecx
  000e9	84 c0		 test	 al, al
  000eb	74 2f		 je	 SHORT $LN64@XmlGetAttr
  000ed	8a 14 0e	 mov	 dl, BYTE PTR [esi+ecx]
  000f0	84 d2		 test	 dl, dl
  000f2	74 04		 je	 SHORT $LN63@XmlGetAttr
  000f4	3a d0		 cmp	 dl, al
  000f6	74 ed		 je	 SHORT $LL34@XmlGetAttr
$LN63@XmlGetAttr:
  000f8	8b 5c 24 14	 mov	 ebx, DWORD PTR _e$[esp+12]
  000fc	8b 7c 24 18	 mov	 edi, DWORD PTR _xmlAttrName$[esp+12]
$LN49@XmlGetAttr:
  00100	57		 push	 edi

; 97   : 			break;
; 98   : 
; 99   : 		t++;

  00101	45		 inc	 ebp
  00102	55		 push	 ebp
  00103	e8 00 00 00 00	 call	 _strstr
  00108	8b e8		 mov	 ebp, eax
  0010a	83 c4 08	 add	 esp, 8
  0010d	85 ed		 test	 ebp, ebp
  0010f	0f 85 33 ff ff
	ff		 jne	 $LL8@XmlGetAttr
$LN3@XmlGetAttr:
  00115	5f		 pop	 edi
  00116	5d		 pop	 ebp
  00117	5b		 pop	 ebx

; 100  : 	}
; 101  : 
; 102  : 	if (t == NULL || t > e) return NULL;

  00118	33 c0		 xor	 eax, eax
  0011a	5e		 pop	 esi

; 113  : }

  0011b	c3		 ret	 0
$LN64@XmlGetAttr:

; 100  : 	}
; 101  : 
; 102  : 	if (t == NULL || t > e) return NULL;

  0011c	85 ed		 test	 ebp, ebp
  0011e	74 f5		 je	 SHORT $LN3@XmlGetAttr
  00120	3b 6c 24 14	 cmp	 ebp, DWORD PTR _e$[esp+12]
  00124	77 ef		 ja	 SHORT $LN3@XmlGetAttr

; 103  : 
; 104  : 	t = strchr (t, '"') + 1;

  00126	6a 22		 push	 34			; 00000022H
  00128	55		 push	 ebp
  00129	e8 00 00 00 00	 call	 _strchr
  0012e	8b f0		 mov	 esi, eax
  00130	46		 inc	 esi

; 105  : 	e = strchr (t, '"');

  00131	6a 22		 push	 34			; 00000022H
  00133	56		 push	 esi
  00134	e8 00 00 00 00	 call	 _strchr

; 106  : 	l = (int)(e - t);

  00139	8b f8		 mov	 edi, eax
  0013b	83 c4 10	 add	 esp, 16			; 00000010H
  0013e	2b fe		 sub	 edi, esi

; 107  : 	if (e == NULL || l > xmlAttrValueSize) return NULL;

  00140	85 c0		 test	 eax, eax
  00142	74 d1		 je	 SHORT $LN3@XmlGetAttr
  00144	3b 7c 24 20	 cmp	 edi, DWORD PTR _xmlAttrValueSize$[esp+12]
  00148	7f cb		 jg	 SHORT $LN3@XmlGetAttr

; 108  : 
; 109  : 	memcpy (xmlAttrValue, t, l);

  0014a	57		 push	 edi
  0014b	56		 push	 esi
  0014c	8b 74 24 24	 mov	 esi, DWORD PTR _xmlAttrValue$[esp+20]
  00150	56		 push	 esi
  00151	e8 00 00 00 00	 call	 _memcpy
  00156	83 c4 0c	 add	 esp, 12			; 0000000cH

; 110  : 	xmlAttrValue[l] = 0;

  00159	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
  0015d	5f		 pop	 edi
  0015e	5d		 pop	 ebp
  0015f	5b		 pop	 ebx

; 111  : 
; 112  : 	return xmlAttrValue;

  00160	8b c6		 mov	 eax, esi
  00162	5e		 pop	 esi

; 113  : }

  00163	c3		 ret	 0
_XmlGetAttributeText ENDP
_TEXT	ENDS
PUBLIC	??_C@_05JKJFEODM@?$CGamp?$DL?$AA@		; `string'
PUBLIC	??_C@_04LOOHDCEI@?$CGgt?$DL?$AA@		; `string'
PUBLIC	??_C@_04GJOGLFEJ@?$CGlt?$DL?$AA@		; `string'
PUBLIC	_XmlGetNodeText
;	COMDAT ??_C@_05JKJFEODM@?$CGamp?$DL?$AA@
CONST	SEGMENT
??_C@_05JKJFEODM@?$CGamp?$DL?$AA@ DB '&amp;', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOOHDCEI@?$CGgt?$DL?$AA@
CONST	SEGMENT
??_C@_04LOOHDCEI@?$CGgt?$DL?$AA@ DB '&gt;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GJOGLFEJ@?$CGlt?$DL?$AA@
CONST	SEGMENT
??_C@_04GJOGLFEJ@?$CGlt?$DL?$AA@ DB '&lt;', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _XmlGetNodeText
_TEXT	SEGMENT
_l$ = 8							; size = 4
_xmlNode$ = 8						; size = 4
_t$ = 12						; size = 4
_xmlText$ = 12						; size = 4
_xmlTextSize$ = 16					; size = 4
_XmlGetNodeText PROC					; COMDAT

; 118  : 	char *t = xmlNode;
; 119  : 	char *e = xmlNode + 1;
; 120  : 	int l = 0, i = 0, j = 0;
; 121  : 
; 122  : 	xmlText[0] = 0;
; 123  : 
; 124  : 	if (t[0] != '<')

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _xmlNode$[esp-4]
  00004	53		 push	 ebx
  00005	55		 push	 ebp
  00006	8b 6c 24 10	 mov	 ebp, DWORD PTR _xmlText$[esp+4]
  0000a	33 db		 xor	 ebx, ebx
  0000c	56		 push	 esi
  0000d	33 f6		 xor	 esi, esi
  0000f	88 5d 00	 mov	 BYTE PTR [ebp], bl
  00012	80 38 3c	 cmp	 BYTE PTR [eax], 60	; 0000003cH
  00015	74 06		 je	 SHORT $LN10@XmlGetNode
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp

; 125  : 		return NULL;

  00019	33 c0		 xor	 eax, eax
  0001b	5b		 pop	 ebx

; 161  : }

  0001c	c3		 ret	 0
$LN10@XmlGetNode:
  0001d	57		 push	 edi

; 126  : 
; 127  : 	t = strchr (t, '>') + 1;

  0001e	6a 3e		 push	 62			; 0000003eH
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 _strchr
  00026	8b f8		 mov	 edi, eax
  00028	47		 inc	 edi
  00029	83 c4 08	 add	 esp, 8
  0002c	89 7c 24 18	 mov	 DWORD PTR _t$[esp+12], edi

; 128  : 	if (t == (char *)1) return NULL;

  00030	83 ff 01	 cmp	 edi, 1
  00033	0f 84 9c 00 00
	00		 je	 $LN6@XmlGetNode
  00039	8b 44 24 14	 mov	 eax, DWORD PTR _xmlNode$[esp+12]
  0003d	40		 inc	 eax

; 129  : 
; 130  : 	e = strchr (e, '<');

  0003e	6a 3c		 push	 60			; 0000003cH
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _strchr
  00046	83 c4 08	 add	 esp, 8

; 131  : 	if (e == NULL) return NULL;

  00049	85 c0		 test	 eax, eax
  0004b	0f 84 84 00 00
	00		 je	 $LN6@XmlGetNode

; 132  : 
; 133  : 	l = (int)(e - t);

  00051	2b c7		 sub	 eax, edi

; 134  : 	if (e == NULL || l > xmlTextSize) return NULL;

  00053	3b 44 24 1c	 cmp	 eax, DWORD PTR _xmlTextSize$[esp+12]
  00057	89 44 24 14	 mov	 DWORD PTR _l$[esp+12], eax
  0005b	7f 78		 jg	 SHORT $LN6@XmlGetNode

; 135  : 
; 136  : 	while (i < l)

  0005d	85 c0		 test	 eax, eax
  0005f	7e 69		 jle	 SHORT $LN4@XmlGetNode
$LL5@XmlGetNode:

; 137  : 	{
; 138  : 		if (BeginsWith (&t[i], "&lt;"))

  00061	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_04GJOGLFEJ@?$CGlt?$DL?$AA@
  00066	8b c7		 mov	 eax, edi
  00068	e8 00 00 00 00	 call	 _BeginsWith
  0006d	85 c0		 test	 eax, eax
  0006f	74 0d		 je	 SHORT $LN3@XmlGetNode

; 139  : 		{
; 140  : 			xmlText[j++] = '<';

  00071	c6 04 2e 3c	 mov	 BYTE PTR [esi+ebp], 60	; 0000003cH
  00075	46		 inc	 esi

; 141  : 			i += 4;

  00076	83 c3 04	 add	 ebx, 4
  00079	83 c7 04	 add	 edi, 4

; 142  : 			continue;

  0007c	eb 42		 jmp	 SHORT $LN17@XmlGetNode
$LN3@XmlGetNode:

; 143  : 		}
; 144  : 		if (BeginsWith (&t[i], "&gt;"))

  0007e	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_04LOOHDCEI@?$CGgt?$DL?$AA@
  00083	8b c7		 mov	 eax, edi
  00085	e8 00 00 00 00	 call	 _BeginsWith
  0008a	85 c0		 test	 eax, eax
  0008c	74 0d		 je	 SHORT $LN2@XmlGetNode

; 145  : 		{
; 146  : 			xmlText[j++] = '>';

  0008e	c6 04 2e 3e	 mov	 BYTE PTR [esi+ebp], 62	; 0000003eH
  00092	46		 inc	 esi

; 147  : 			i += 4;

  00093	83 c3 04	 add	 ebx, 4
  00096	83 c7 04	 add	 edi, 4

; 148  : 			continue;

  00099	eb 25		 jmp	 SHORT $LN17@XmlGetNode
$LN2@XmlGetNode:

; 149  : 		}
; 150  : 		if (BeginsWith (&t[i], "&amp;"))

  0009b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_05JKJFEODM@?$CGamp?$DL?$AA@
  000a0	8b c7		 mov	 eax, edi
  000a2	e8 00 00 00 00	 call	 _BeginsWith
  000a7	85 c0		 test	 eax, eax
  000a9	74 0d		 je	 SHORT $LN1@XmlGetNode

; 151  : 		{
; 152  : 			xmlText[j++] = '&';

  000ab	c6 04 2e 26	 mov	 BYTE PTR [esi+ebp], 38	; 00000026H
  000af	46		 inc	 esi

; 153  : 			i += 5;

  000b0	83 c3 05	 add	 ebx, 5
  000b3	83 c7 05	 add	 edi, 5

; 154  : 			continue;

  000b6	eb 08		 jmp	 SHORT $LN17@XmlGetNode
$LN1@XmlGetNode:

; 155  : 		}
; 156  : 		xmlText[j++] = t[i++];

  000b8	8a 0f		 mov	 cl, BYTE PTR [edi]
  000ba	88 0c 2e	 mov	 BYTE PTR [esi+ebp], cl
  000bd	46		 inc	 esi
  000be	43		 inc	 ebx
  000bf	47		 inc	 edi
$LN17@XmlGetNode:

; 135  : 
; 136  : 	while (i < l)

  000c0	3b 5c 24 14	 cmp	 ebx, DWORD PTR _l$[esp+12]
  000c4	7c 9b		 jl	 SHORT $LL5@XmlGetNode
  000c6	8b 7c 24 18	 mov	 edi, DWORD PTR _t$[esp+12]
$LN4@XmlGetNode:

; 157  : 	}
; 158  : 	xmlText[j] = 0;
; 159  : 
; 160  : 	return t;

  000ca	8b c7		 mov	 eax, edi
  000cc	5f		 pop	 edi
  000cd	c6 04 2e 00	 mov	 BYTE PTR [esi+ebp], 0
  000d1	5e		 pop	 esi
  000d2	5d		 pop	 ebp
  000d3	5b		 pop	 ebx

; 161  : }

  000d4	c3		 ret	 0
$LN6@XmlGetNode:
  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	5d		 pop	 ebp

; 134  : 	if (e == NULL || l > xmlTextSize) return NULL;

  000d8	33 c0		 xor	 eax, eax
  000da	5b		 pop	 ebx

; 161  : }

  000db	c3		 ret	 0
_XmlGetNodeText ENDP
_TEXT	ENDS
PUBLIC	_XmlQuoteText
; Function compile flags: /Ogtpy
;	COMDAT _XmlQuoteText
_TEXT	SEGMENT
_textSrc$ = 8						; size = 4
_textDst$ = 12						; size = 4
_textDstMaxSize$ = 16					; size = 4
_XmlQuoteText PROC					; COMDAT

; 166  : 	char *textDstLast = textDst + textDstMaxSize - 1;

  00000	8b 4c 24 0c	 mov	 ecx, DWORD PTR _textDstMaxSize$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR _textDst$[esp-4]
  00008	53		 push	 ebx
  00009	8d 5c 08 ff	 lea	 ebx, DWORD PTR [eax+ecx-1]

; 167  : 
; 168  : 	if (textDstMaxSize == 0)

  0000d	85 c9		 test	 ecx, ecx
  0000f	75 04		 jne	 SHORT $LN19@XmlQuoteTe

; 169  : 		return NULL;

  00011	33 c0		 xor	 eax, eax
  00013	5b		 pop	 ebx

; 206  : 	return textDst;
; 207  : }

  00014	c3		 ret	 0
$LN19@XmlQuoteTe:
  00015	55		 push	 ebp

; 170  : 
; 171  : 	while (*textSrc != 0 && textDst <= textDstLast) 

  00016	8b 6c 24 0c	 mov	 ebp, DWORD PTR _textSrc$[esp+4]
  0001a	8a 55 00	 mov	 dl, BYTE PTR [ebp]
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	84 d2		 test	 dl, dl
  00021	0f 84 96 00 00
	00		 je	 $LN11@XmlQuoteTe
  00027	8d 78 06	 lea	 edi, DWORD PTR [eax+6]
  0002a	8d 70 05	 lea	 esi, DWORD PTR [eax+5]
  0002d	8d 49 00	 npad	 3
$LL12@XmlQuoteTe:
  00030	3b c3		 cmp	 eax, ebx
  00032	0f 87 89 00 00
	00		 ja	 $LN24@XmlQuoteTe

; 172  : 	{
; 173  : 		char c = *textSrc++;
; 174  : 		switch (c)

  00038	0f be ca	 movsx	 ecx, dl
  0003b	45		 inc	 ebp
  0003c	83 e9 26	 sub	 ecx, 38			; 00000026H
  0003f	74 51		 je	 SHORT $LN8@XmlQuoteTe
  00041	83 e9 16	 sub	 ecx, 22			; 00000016H
  00044	74 2c		 je	 SHORT $LN4@XmlQuoteTe
  00046	83 e9 02	 sub	 ecx, 2
  00049	74 07		 je	 SHORT $LN6@XmlQuoteTe

; 196  : 
; 197  : 		default:
; 198  : 			*textDst++ = c;

  0004b	88 10		 mov	 BYTE PTR [eax], dl
  0004d	40		 inc	 eax
  0004e	46		 inc	 esi
  0004f	47		 inc	 edi

; 199  : 		}
; 200  : 	}

  00050	eb 60		 jmp	 SHORT $LN23@XmlQuoteTe
$LN6@XmlQuoteTe:

; 181  : 			continue;
; 182  : 
; 183  : 		case '>':
; 184  : 			if (textDst + 5 > textDstLast)

  00052	3b f3		 cmp	 esi, ebx
  00054	77 6b		 ja	 SHORT $LN24@XmlQuoteTe

; 185  : 				return NULL;
; 186  : 			strcpy (textDst, "&gt;");

  00056	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_04LOOHDCEI@?$CGgt?$DL?$AA@
  0005c	89 08		 mov	 DWORD PTR [eax], ecx
  0005e	8a 15 04 00 00
	00		 mov	 dl, BYTE PTR ??_C@_04LOOHDCEI@?$CGgt?$DL?$AA@+4
  00064	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 187  : 			textDst += 4;

  00067	83 c0 04	 add	 eax, 4
  0006a	83 c6 04	 add	 esi, 4
  0006d	83 c7 04	 add	 edi, 4

; 188  : 			continue;

  00070	eb 40		 jmp	 SHORT $LN23@XmlQuoteTe
$LN4@XmlQuoteTe:

; 189  : 
; 190  : 		case '<':
; 191  : 			if (textDst + 5 > textDstLast)

  00072	3b f3		 cmp	 esi, ebx
  00074	77 4b		 ja	 SHORT $LN24@XmlQuoteTe

; 192  : 				return NULL;
; 193  : 			strcpy (textDst, "&lt;");

  00076	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_04GJOGLFEJ@?$CGlt?$DL?$AA@
  0007c	89 08		 mov	 DWORD PTR [eax], ecx
  0007e	8a 15 04 00 00
	00		 mov	 dl, BYTE PTR ??_C@_04GJOGLFEJ@?$CGlt?$DL?$AA@+4
  00084	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 194  : 			textDst += 4;

  00087	83 c0 04	 add	 eax, 4
  0008a	83 c6 04	 add	 esi, 4
  0008d	83 c7 04	 add	 edi, 4

; 195  : 			continue;

  00090	eb 20		 jmp	 SHORT $LN23@XmlQuoteTe
$LN8@XmlQuoteTe:

; 175  : 		{
; 176  : 		case '&':
; 177  : 			if (textDst + 6 > textDstLast)

  00092	3b fb		 cmp	 edi, ebx
  00094	77 2b		 ja	 SHORT $LN24@XmlQuoteTe

; 178  : 				return NULL;
; 179  : 			strcpy (textDst, "&amp;");

  00096	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_05JKJFEODM@?$CGamp?$DL?$AA@
  0009c	89 08		 mov	 DWORD PTR [eax], ecx
  0009e	66 8b 15 04 00
	00 00		 mov	 dx, WORD PTR ??_C@_05JKJFEODM@?$CGamp?$DL?$AA@+4
  000a5	66 89 50 04	 mov	 WORD PTR [eax+4], dx

; 180  : 			textDst += 5;

  000a9	83 c0 05	 add	 eax, 5
  000ac	83 c6 05	 add	 esi, 5
  000af	83 c7 05	 add	 edi, 5
$LN23@XmlQuoteTe:
  000b2	8a 55 00	 mov	 dl, BYTE PTR [ebp]
  000b5	84 d2		 test	 dl, dl
  000b7	0f 85 73 ff ff
	ff		 jne	 $LL12@XmlQuoteTe
$LN11@XmlQuoteTe:

; 201  : 
; 202  : 	if (textDst > textDstLast)

  000bd	3b c3		 cmp	 eax, ebx
  000bf	76 07		 jbe	 SHORT $LN1@XmlQuoteTe
$LN24@XmlQuoteTe:
  000c1	5f		 pop	 edi
  000c2	5e		 pop	 esi
  000c3	5d		 pop	 ebp

; 203  : 		return NULL;

  000c4	33 c0		 xor	 eax, eax
  000c6	5b		 pop	 ebx

; 206  : 	return textDst;
; 207  : }

  000c7	c3		 ret	 0
$LN1@XmlQuoteTe:
  000c8	5f		 pop	 edi
  000c9	5e		 pop	 esi
  000ca	5d		 pop	 ebp

; 204  : 
; 205  : 	*textDst = 0;

  000cb	c6 00 00	 mov	 BYTE PTR [eax], 0
  000ce	5b		 pop	 ebx

; 206  : 	return textDst;
; 207  : }

  000cf	c3		 ret	 0
_XmlQuoteText ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@NFGIKLFN@?$DM?$DPxml?5version?$DN?$CC1?40?$CC?5encoding?$DN?$CCut@ ; `string'
PUBLIC	_XmlWriteHeader
EXTRN	_fputs:PROC
;	COMDAT ??_C@_0DD@NFGIKLFN@?$DM?$DPxml?5version?$DN?$CC1?40?$CC?5encoding?$DN?$CCut@
CONST	SEGMENT
??_C@_0DD@NFGIKLFN@?$DM?$DPxml?5version?$DN?$CC1?40?$CC?5encoding?$DN?$CCut@ DB '<'
	DB	'?xml version="1.0" encoding="utf-8"?>', 0aH, '<TrueCrypt>', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _XmlWriteHeader
_TEXT	SEGMENT
_file$ = 8						; size = 4
_XmlWriteHeader PROC					; COMDAT

; 212  : 	return fputs ("<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<TrueCrypt>", file);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _file$[esp-4]
  00004	50		 push	 eax
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@NFGIKLFN@?$DM?$DPxml?5version?$DN?$CC1?40?$CC?5encoding?$DN?$CCut@
  0000a	e8 00 00 00 00	 call	 _fputs
  0000f	83 c4 08	 add	 esp, 8

; 213  : }

  00012	c3		 ret	 0
_XmlWriteHeader ENDP
_TEXT	ENDS
PUBLIC	??_C@_1GG@BPLLCFPM@?$AA?$DM?$AA?$DP?$AAx?$AAm?$AAl?$AA?5?$AAv?$AAe?$AAr?$AAs?$AAi?$AAo?$AAn?$AA?$DN?$AA?$CC?$AA1?$AA?4?$AA0?$AA?$CC?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?$DN?$AA?$CC?$AAu?$AAt@ ; `string'
PUBLIC	_XmlWriteHeaderW
EXTRN	_fputws:PROC
;	COMDAT ??_C@_1GG@BPLLCFPM@?$AA?$DM?$AA?$DP?$AAx?$AAm?$AAl?$AA?5?$AAv?$AAe?$AAr?$AAs?$AAi?$AAo?$AAn?$AA?$DN?$AA?$CC?$AA1?$AA?4?$AA0?$AA?$CC?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?$DN?$AA?$CC?$AAu?$AAt@
CONST	SEGMENT
??_C@_1GG@BPLLCFPM@?$AA?$DM?$AA?$DP?$AAx?$AAm?$AAl?$AA?5?$AAv?$AAe?$AAr?$AAs?$AAi?$AAo?$AAn?$AA?$DN?$AA?$CC?$AA1?$AA?4?$AA0?$AA?$CC?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?$DN?$AA?$CC?$AAu?$AAt@ DB '<'
	DB	00H, '?', 00H, 'x', 00H, 'm', 00H, 'l', 00H, ' ', 00H, 'v', 00H
	DB	'e', 00H, 'r', 00H, 's', 00H, 'i', 00H, 'o', 00H, 'n', 00H, '='
	DB	00H, '"', 00H, '1', 00H, '.', 00H, '0', 00H, '"', 00H, ' ', 00H
	DB	'e', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, '=', 00H, '"', 00H, 'u', 00H, 't', 00H, 'f', 00H
	DB	'-', 00H, '8', 00H, '"', 00H, '?', 00H, '>', 00H, 0aH, 00H, '<'
	DB	00H, 'T', 00H, 'r', 00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r', 00H
	DB	'y', 00H, 'p', 00H, 't', 00H, '>', 00H, 00H, 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _XmlWriteHeaderW
_TEXT	SEGMENT
_file$ = 8						; size = 4
_XmlWriteHeaderW PROC					; COMDAT

; 218  : 	return fputws (L"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<TrueCrypt>", file);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _file$[esp-4]
  00004	50		 push	 eax
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_1GG@BPLLCFPM@?$AA?$DM?$AA?$DP?$AAx?$AAm?$AAl?$AA?5?$AAv?$AAe?$AAr?$AAs?$AAi?$AAo?$AAn?$AA?$DN?$AA?$CC?$AA1?$AA?4?$AA0?$AA?$CC?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA?$DN?$AA?$CC?$AAu?$AAt@
  0000a	e8 00 00 00 00	 call	 _fputws
  0000f	83 c4 08	 add	 esp, 8

; 219  : }

  00012	c3		 ret	 0
_XmlWriteHeaderW ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@KNDIKFEF@?6?$DM?1TrueCrypt?$DO?$AA@	; `string'
PUBLIC	_XmlWriteFooter
;	COMDAT ??_C@_0O@KNDIKFEF@?6?$DM?1TrueCrypt?$DO?$AA@
CONST	SEGMENT
??_C@_0O@KNDIKFEF@?6?$DM?1TrueCrypt?$DO?$AA@ DB 0aH, '</TrueCrypt>', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _XmlWriteFooter
_TEXT	SEGMENT
_file$ = 8						; size = 4
_XmlWriteFooter PROC					; COMDAT

; 224  : 	return fputs ("\n</TrueCrypt>", file);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _file$[esp-4]
  00004	50		 push	 eax
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_0O@KNDIKFEF@?6?$DM?1TrueCrypt?$DO?$AA@
  0000a	e8 00 00 00 00	 call	 _fputs
  0000f	83 c4 08	 add	 esp, 8

; 225  : }

  00012	c3		 ret	 0
_XmlWriteFooter ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BM@LBMOHPBG@?$AA?6?$AA?$DM?$AA?1?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$DO?$AA?$AA@ ; `string'
PUBLIC	_XmlWriteFooterW
;	COMDAT ??_C@_1BM@LBMOHPBG@?$AA?6?$AA?$DM?$AA?1?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$DO?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@LBMOHPBG@?$AA?6?$AA?$DM?$AA?1?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$DO?$AA?$AA@ DB 0aH
	DB	00H, '<', 00H, '/', 00H, 'T', 00H, 'r', 00H, 'u', 00H, 'e', 00H
	DB	'C', 00H, 'r', 00H, 'y', 00H, 'p', 00H, 't', 00H, '>', 00H, 00H
	DB	00H						; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _XmlWriteFooterW
_TEXT	SEGMENT
_file$ = 8						; size = 4
_XmlWriteFooterW PROC					; COMDAT

; 230  : 	return fputws (L"\n</TrueCrypt>", file);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _file$[esp-4]
  00004	50		 push	 eax
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_1BM@LBMOHPBG@?$AA?6?$AA?$DM?$AA?1?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$DO?$AA?$AA@
  0000a	e8 00 00 00 00	 call	 _fputws
  0000f	83 c4 08	 add	 esp, 8

; 231  : }

  00012	c3		 ret	 0
_XmlWriteFooterW ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_XmlFindElementByAttributeValue
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT _XmlFindElementByAttributeValue
_TEXT	SEGMENT
_attr$ = -2052						; size = 2048
__$ArrayPad$ = -4					; size = 4
_xml$ = 8						; size = 4
_nodeName$ = 12						; size = 4
_attrName$ = 16						; size = 4
_attrValue$ = 20					; size = 4
_XmlFindElementByAttributeValue PROC			; COMDAT

; 59   : {

  00000	81 ec 04 08 00
	00		 sub	 esp, 2052		; 00000804H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 00 08
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+2052], eax
  00014	8b 84 24 08 08
	00 00		 mov	 eax, DWORD PTR _xml$[esp+2048]
  0001b	53		 push	 ebx
  0001c	55		 push	 ebp
  0001d	8b ac 24 14 08
	00 00		 mov	 ebp, DWORD PTR _nodeName$[esp+2056]
  00024	56		 push	 esi
  00025	57		 push	 edi
  00026	8b bc 24 20 08
	00 00		 mov	 edi, DWORD PTR _attrName$[esp+2064]

; 60   : 	char attr[2048];
; 61   : 
; 62   : 	while (xml = XmlFindElement (xml, nodeName))

  0002d	55		 push	 ebp
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _XmlFindElement
  00034	8b f0		 mov	 esi, eax
  00036	83 c4 08	 add	 esp, 8
  00039	85 f6		 test	 esi, esi
  0003b	74 5d		 je	 SHORT $LN2@XmlFindEle@2
  0003d	8b 9c 24 24 08
	00 00		 mov	 ebx, DWORD PTR _attrValue$[esp+2064]
$LL3@XmlFindEle@2:

; 63   : 	{
; 64   : 		XmlGetAttributeText (xml, attrName, attr, sizeof (attr));

  00044	68 00 08 00 00	 push	 2048			; 00000800H
  00049	8d 44 24 14	 lea	 eax, DWORD PTR _attr$[esp+2072]
  0004d	50		 push	 eax
  0004e	57		 push	 edi
  0004f	56		 push	 esi
  00050	e8 00 00 00 00	 call	 _XmlGetAttributeText
  00055	83 c4 10	 add	 esp, 16			; 00000010H

; 65   : 		if (strcmp (attr, attrValue) == 0)

  00058	8b cb		 mov	 ecx, ebx
  0005a	8d 44 24 10	 lea	 eax, DWORD PTR _attr$[esp+2068]
  0005e	8b ff		 npad	 2
$LL9@XmlFindEle@2:
  00060	8a 10		 mov	 dl, BYTE PTR [eax]
  00062	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00064	75 1a		 jne	 SHORT $LN10@XmlFindEle@2
  00066	84 d2		 test	 dl, dl
  00068	74 12		 je	 SHORT $LN11@XmlFindEle@2
  0006a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0006d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00070	75 0e		 jne	 SHORT $LN10@XmlFindEle@2
  00072	83 c0 02	 add	 eax, 2
  00075	83 c1 02	 add	 ecx, 2
  00078	84 d2		 test	 dl, dl
  0007a	75 e4		 jne	 SHORT $LL9@XmlFindEle@2
$LN11@XmlFindEle@2:
  0007c	33 c0		 xor	 eax, eax
  0007e	eb 05		 jmp	 SHORT $LN12@XmlFindEle@2
$LN10@XmlFindEle@2:
  00080	1b c0		 sbb	 eax, eax
  00082	83 d8 ff	 sbb	 eax, -1
$LN12@XmlFindEle@2:
  00085	85 c0		 test	 eax, eax
  00087	74 2c		 je	 SHORT $LN7@XmlFindEle@2
  00089	55		 push	 ebp

; 67   : 
; 68   : 		xml++;

  0008a	46		 inc	 esi
  0008b	56		 push	 esi
  0008c	e8 00 00 00 00	 call	 _XmlFindElement
  00091	8b f0		 mov	 esi, eax
  00093	83 c4 08	 add	 esp, 8
  00096	85 f6		 test	 esi, esi
  00098	75 aa		 jne	 SHORT $LL3@XmlFindEle@2
$LN2@XmlFindEle@2:

; 69   : 	}
; 70   : 
; 71   : 	return NULL;

  0009a	33 c0		 xor	 eax, eax
$LN4@XmlFindEle@2:

; 72   : }

  0009c	8b 8c 24 10 08
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+2068]
  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
  000a5	5d		 pop	 ebp
  000a6	5b		 pop	 ebx
  000a7	33 cc		 xor	 ecx, esp
  000a9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ae	81 c4 04 08 00
	00		 add	 esp, 2052		; 00000804H
  000b4	c3		 ret	 0
$LN7@XmlFindEle@2:

; 66   : 			return xml;

  000b5	8b c6		 mov	 eax, esi
  000b7	eb e3		 jmp	 SHORT $LN4@XmlFindEle@2
_XmlFindElementByAttributeValue ENDP
_TEXT	ENDS
END
