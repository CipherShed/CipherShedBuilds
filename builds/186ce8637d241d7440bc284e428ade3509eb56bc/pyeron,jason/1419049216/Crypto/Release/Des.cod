; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\home\public\Desktop\projects\cipherShed\src\Crypto\Des.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
_pc1	DB	039H
	DB	031H
	DB	029H
	DB	021H
	DB	019H
	DB	011H
	DB	09H
	DB	01H
	DB	03aH
	DB	032H
	DB	02aH
	DB	022H
	DB	01aH
	DB	012H
	DB	0aH
	DB	02H
	DB	03bH
	DB	033H
	DB	02bH
	DB	023H
	DB	01bH
	DB	013H
	DB	0bH
	DB	03H
	DB	03cH
	DB	034H
	DB	02cH
	DB	024H
	DB	03fH
	DB	037H
	DB	02fH
	DB	027H
	DB	01fH
	DB	017H
	DB	0fH
	DB	07H
	DB	03eH
	DB	036H
	DB	02eH
	DB	026H
	DB	01eH
	DB	016H
	DB	0eH
	DB	06H
	DB	03dH
	DB	035H
	DB	02dH
	DB	025H
	DB	01dH
	DB	015H
	DB	0dH
	DB	05H
	DB	01cH
	DB	014H
	DB	0cH
	DB	04H
_totrot	DB	01H
	DB	02H
	DB	04H
	DB	06H
	DB	08H
	DB	0aH
	DB	0cH
	DB	0eH
	DB	0fH
	DB	011H
	DB	013H
	DB	015H
	DB	017H
	DB	019H
	DB	01bH
	DB	01cH
_pc2	DB	0eH
	DB	011H
	DB	0bH
	DB	018H
	DB	01H
	DB	05H
	DB	03H
	DB	01cH
	DB	0fH
	DB	06H
	DB	015H
	DB	0aH
	DB	017H
	DB	013H
	DB	0cH
	DB	04H
	DB	01aH
	DB	08H
	DB	010H
	DB	07H
	DB	01bH
	DB	014H
	DB	0dH
	DB	02H
	DB	029H
	DB	034H
	DB	01fH
	DB	025H
	DB	02fH
	DB	037H
	DB	01eH
	DB	028H
	DB	033H
	DB	02dH
	DB	021H
	DB	030H
	DB	02cH
	DB	031H
	DB	027H
	DB	038H
	DB	022H
	DB	035H
	DB	02eH
	DB	02aH
	DB	032H
	DB	024H
	DB	01dH
	DB	020H
_bytebit DD	080H
	DD	040H
	DD	020H
	DD	010H
	DD	08H
	DD	04H
	DD	02H
	DD	01H
_Spbox	DD	01010400H
	DD	00H
	DD	010000H
	DD	01010404H
	DD	01010004H
	DD	010404H
	DD	04H
	DD	010000H
	DD	0400H
	DD	01010400H
	DD	01010404H
	DD	0400H
	DD	01000404H
	DD	01010004H
	DD	01000000H
	DD	04H
	DD	0404H
	DD	01000400H
	DD	01000400H
	DD	010400H
	DD	010400H
	DD	01010000H
	DD	01010000H
	DD	01000404H
	DD	010004H
	DD	01000004H
	DD	01000004H
	DD	010004H
	DD	00H
	DD	0404H
	DD	010404H
	DD	01000000H
	DD	010000H
	DD	01010404H
	DD	04H
	DD	01010000H
	DD	01010400H
	DD	01000000H
	DD	01000000H
	DD	0400H
	DD	01010004H
	DD	010000H
	DD	010400H
	DD	01000004H
	DD	0400H
	DD	04H
	DD	01000404H
	DD	010404H
	DD	01010404H
	DD	010004H
	DD	01010000H
	DD	01000404H
	DD	01000004H
	DD	0404H
	DD	010404H
	DD	01010400H
	DD	0404H
	DD	01000400H
	DD	01000400H
	DD	00H
	DD	010004H
	DD	010400H
	DD	00H
	DD	01010004H
	DD	080108020H
	DD	080008000H
	DD	08000H
	DD	0108020H
	DD	0100000H
	DD	020H
	DD	080100020H
	DD	080008020H
	DD	080000020H
	DD	080108020H
	DD	080108000H
	DD	080000000H
	DD	080008000H
	DD	0100000H
	DD	020H
	DD	080100020H
	DD	0108000H
	DD	0100020H
	DD	080008020H
	DD	00H
	DD	080000000H
	DD	08000H
	DD	0108020H
	DD	080100000H
	DD	0100020H
	DD	080000020H
	DD	00H
	DD	0108000H
	DD	08020H
	DD	080108000H
	DD	080100000H
	DD	08020H
	DD	00H
	DD	0108020H
	DD	080100020H
	DD	0100000H
	DD	080008020H
	DD	080100000H
	DD	080108000H
	DD	08000H
	DD	080100000H
	DD	080008000H
	DD	020H
	DD	080108020H
	DD	0108020H
	DD	020H
	DD	08000H
	DD	080000000H
	DD	08020H
	DD	080108000H
	DD	0100000H
	DD	080000020H
	DD	0100020H
	DD	080008020H
	DD	080000020H
	DD	0100020H
	DD	0108000H
	DD	00H
	DD	080008000H
	DD	08020H
	DD	080000000H
	DD	080100020H
	DD	080108020H
	DD	0108000H
	DD	0208H
	DD	08020200H
	DD	00H
	DD	08020008H
	DD	08000200H
	DD	00H
	DD	020208H
	DD	08000200H
	DD	020008H
	DD	08000008H
	DD	08000008H
	DD	020000H
	DD	08020208H
	DD	020008H
	DD	08020000H
	DD	0208H
	DD	08000000H
	DD	08H
	DD	08020200H
	DD	0200H
	DD	020200H
	DD	08020000H
	DD	08020008H
	DD	020208H
	DD	08000208H
	DD	020200H
	DD	020000H
	DD	08000208H
	DD	08H
	DD	08020208H
	DD	0200H
	DD	08000000H
	DD	08020200H
	DD	08000000H
	DD	020008H
	DD	0208H
	DD	020000H
	DD	08020200H
	DD	08000200H
	DD	00H
	DD	0200H
	DD	020008H
	DD	08020208H
	DD	08000200H
	DD	08000008H
	DD	0200H
	DD	00H
	DD	08020008H
	DD	08000208H
	DD	020000H
	DD	08000000H
	DD	08020208H
	DD	08H
	DD	020208H
	DD	020200H
	DD	08000008H
	DD	08020000H
	DD	08000208H
	DD	0208H
	DD	08020000H
	DD	020208H
	DD	08H
	DD	08020008H
	DD	020200H
	DD	0802001H
	DD	02081H
	DD	02081H
	DD	080H
	DD	0802080H
	DD	0800081H
	DD	0800001H
	DD	02001H
	DD	00H
	DD	0802000H
	DD	0802000H
	DD	0802081H
	DD	081H
	DD	00H
	DD	0800080H
	DD	0800001H
	DD	01H
	DD	02000H
	DD	0800000H
	DD	0802001H
	DD	080H
	DD	0800000H
	DD	02001H
	DD	02080H
	DD	0800081H
	DD	01H
	DD	02080H
	DD	0800080H
	DD	02000H
	DD	0802080H
	DD	0802081H
	DD	081H
	DD	0800080H
	DD	0800001H
	DD	0802000H
	DD	0802081H
	DD	081H
	DD	00H
	DD	00H
	DD	0802000H
	DD	02080H
	DD	0800080H
	DD	0800081H
	DD	01H
	DD	0802001H
	DD	02081H
	DD	02081H
	DD	080H
	DD	0802081H
	DD	081H
	DD	01H
	DD	02000H
	DD	0800001H
	DD	02001H
	DD	0802080H
	DD	0800081H
	DD	02001H
	DD	02080H
	DD	0800000H
	DD	0802001H
	DD	080H
	DD	0800000H
	DD	02000H
	DD	0802080H
	DD	0100H
	DD	02080100H
	DD	02080000H
	DD	042000100H
	DD	080000H
	DD	0100H
	DD	040000000H
	DD	02080000H
	DD	040080100H
	DD	080000H
	DD	02000100H
	DD	040080100H
	DD	042000100H
	DD	042080000H
	DD	080100H
	DD	040000000H
	DD	02000000H
	DD	040080000H
	DD	040080000H
	DD	00H
	DD	040000100H
	DD	042080100H
	DD	042080100H
	DD	02000100H
	DD	042080000H
	DD	040000100H
	DD	00H
	DD	042000000H
	DD	02080100H
	DD	02000000H
	DD	042000000H
	DD	080100H
	DD	080000H
	DD	042000100H
	DD	0100H
	DD	02000000H
	DD	040000000H
	DD	02080000H
	DD	042000100H
	DD	040080100H
	DD	02000100H
	DD	040000000H
	DD	042080000H
	DD	02080100H
	DD	040080100H
	DD	0100H
	DD	02000000H
	DD	042080000H
	DD	042080100H
	DD	080100H
	DD	042000000H
	DD	042080100H
	DD	02080000H
	DD	00H
	DD	040080000H
	DD	042000000H
	DD	080100H
	DD	02000100H
	DD	040000100H
	DD	080000H
	DD	00H
	DD	040080000H
	DD	02080100H
	DD	040000100H
	DD	020000010H
	DD	020400000H
	DD	04000H
	DD	020404010H
	DD	020400000H
	DD	010H
	DD	020404010H
	DD	0400000H
	DD	020004000H
	DD	0404010H
	DD	0400000H
	DD	020000010H
	DD	0400010H
	DD	020004000H
	DD	020000000H
	DD	04010H
	DD	00H
	DD	0400010H
	DD	020004010H
	DD	04000H
	DD	0404000H
	DD	020004010H
	DD	010H
	DD	020400010H
	DD	020400010H
	DD	00H
	DD	0404010H
	DD	020404000H
	DD	04010H
	DD	0404000H
	DD	020404000H
	DD	020000000H
	DD	020004000H
	DD	010H
	DD	020400010H
	DD	0404000H
	DD	020404010H
	DD	0400000H
	DD	04010H
	DD	020000010H
	DD	0400000H
	DD	020004000H
	DD	020000000H
	DD	04010H
	DD	020000010H
	DD	020404010H
	DD	0404000H
	DD	020400000H
	DD	0404010H
	DD	020404000H
	DD	00H
	DD	020400010H
	DD	010H
	DD	04000H
	DD	020400000H
	DD	0404010H
	DD	04000H
	DD	0400010H
	DD	020004010H
	DD	00H
	DD	020404000H
	DD	020000000H
	DD	0400010H
	DD	020004010H
	DD	0200000H
	DD	04200002H
	DD	04000802H
	DD	00H
	DD	0800H
	DD	04000802H
	DD	0200802H
	DD	04200800H
	DD	04200802H
	DD	0200000H
	DD	00H
	DD	04000002H
	DD	02H
	DD	04000000H
	DD	04200002H
	DD	0802H
	DD	04000800H
	DD	0200802H
	DD	0200002H
	DD	04000800H
	DD	04000002H
	DD	04200000H
	DD	04200800H
	DD	0200002H
	DD	04200000H
	DD	0800H
	DD	0802H
	DD	04200802H
	DD	0200800H
	DD	02H
	DD	04000000H
	DD	0200800H
	DD	04000000H
	DD	0200800H
	DD	0200000H
	DD	04000802H
	DD	04000802H
	DD	04200002H
	DD	04200002H
	DD	02H
	DD	0200002H
	DD	04000000H
	DD	04000800H
	DD	0200000H
	DD	04200800H
	DD	0802H
	DD	0200802H
	DD	04200800H
	DD	0802H
	DD	04000002H
	DD	04200802H
	DD	04200000H
	DD	0200800H
	DD	00H
	DD	02H
	DD	04200802H
	DD	00H
	DD	0200802H
	DD	04200000H
	DD	0800H
	DD	04000002H
	DD	04000800H
	DD	0800H
	DD	0200002H
	DD	010001040H
	DD	01000H
	DD	040000H
	DD	010041040H
	DD	010000000H
	DD	010001040H
	DD	040H
	DD	010000000H
	DD	040040H
	DD	010040000H
	DD	010041040H
	DD	041000H
	DD	010041000H
	DD	041040H
	DD	01000H
	DD	040H
	DD	010040000H
	DD	010000040H
	DD	010001000H
	DD	01040H
	DD	041000H
	DD	040040H
	DD	010040040H
	DD	010041000H
	DD	01040H
	DD	00H
	DD	00H
	DD	010040040H
	DD	010000040H
	DD	010001000H
	DD	041040H
	DD	040000H
	DD	041040H
	DD	040000H
	DD	010041000H
	DD	01000H
	DD	040H
	DD	010040040H
	DD	01000H
	DD	041040H
	DD	010001000H
	DD	040H
	DD	010000040H
	DD	010040000H
	DD	010040040H
	DD	010000000H
	DD	040000H
	DD	010001040H
	DD	00H
	DD	010041040H
	DD	040040H
	DD	010000040H
	DD	010040000H
	DD	010001000H
	DD	010001040H
	DD	00H
	DD	010041040H
	DD	041000H
	DD	041000H
	DD	01040H
	DD	01040H
	DD	040040H
	DD	010000000H
	DD	010041000H
CONST	ENDS
PUBLIC	_RtlSecureZeroMemory
; Function compile flags: /Ogtpy
; File c:\program files\microsoft sdks\windows\v7.1\include\winnt.h
;	COMDAT _RtlSecureZeroMemory
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory PROC				; COMDAT

; 13070:     volatile char *vptr = (volatile char *)ptr;
; 13071: 
; 13072: #if defined(_M_AMD64)
; 13073: 
; 13074:         __stosb((PBYTE )((DWORD64)vptr), 0, cnt);
; 13075: 
; 13076: #else
; 13077: 
; 13078:     while (cnt) {

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _cnt$[esp-4]
  00004	8b 44 24 04	 mov	 eax, DWORD PTR _ptr$[esp-4]
  00008	8b c8		 mov	 ecx, eax
  0000a	85 d2		 test	 edx, edx
  0000c	74 0b		 je	 SHORT $LN1@RtlSecureZ
  0000e	8b ff		 npad	 2
$LL2@RtlSecureZ:

; 13079:         *vptr = 0;

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 13080:         vptr++;

  00013	41		 inc	 ecx

; 13081:         cnt--;

  00014	83 ea 01	 sub	 edx, 1
  00017	75 f7		 jne	 SHORT $LL2@RtlSecureZ
$LN1@RtlSecureZ:

; 13082:     }
; 13083: 
; 13084: #endif
; 13085: 
; 13086:     return ptr;
; 13087: }

  00019	c3		 ret	 0
_RtlSecureZeroMemory ENDP
; Function compile flags: /Ogtpy
; File c:\home\public\desktop\projects\ciphershed\src\crypto\des.c
_TEXT	ENDS
;	COMDAT _rotlFixed
_TEXT	SEGMENT
_rotlFixed PROC						; COMDAT
; _x$ = eax
; _y$ = ecx

; 32   : 	return (word32)((x<<y) | (x>>(sizeof(word32)*8-y)));

  00000	d3 c0		 rol	 eax, cl

; 33   : }

  00002	c3		 ret	 0
_rotlFixed ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _rotrFixed
_TEXT	SEGMENT
_rotrFixed PROC						; COMDAT
; _x$ = eax
; _y$ = ecx

; 37   : 	return (word32)((x>>y) | (x<<(sizeof(word32)*8-y)));

  00000	d3 c8		 ror	 eax, cl

; 38   : }

  00002	c3		 ret	 0
_rotrFixed ENDP
_TEXT	ENDS
PUBLIC	_scheduledKey$GSCopy$
PUBLIC	__$ArrayPad$
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT _RawSetKey
_TEXT	SEGMENT
tv1786 = -140						; size = 4
tv1782 = -136						; size = 4
_i$ = -132						; size = 4
_scheduledKey$GSCopy$ = -128				; size = 4
_buffer$ = -124						; size = 120
__$ArrayPad$ = -4					; size = 4
_encryption$ = 8					; size = 4
_scheduledKey$ = 12					; size = 4
_RawSetKey PROC						; COMDAT
; _key$ = ecx

; 262  : {

  00000	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 88 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+140], eax

; 281  : 		/* rotate left and right halves independently */
; 282  : 		for (j=0; j<48; j++){   /* select bits individually */

  00014	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR _scheduledKey$[esp+136]
  0001b	56		 push	 esi
  0001c	89 44 24 10	 mov	 DWORD PTR _scheduledKey$GSCopy$[esp+144], eax
  00020	8b f1		 mov	 esi, ecx
  00022	33 c0		 xor	 eax, eax
$LL22@RawSetKey:
  00024	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _pc1[eax]
  0002b	49		 dec	 ecx
  0002c	8b d1		 mov	 edx, ecx
  0002e	c1 fa 03	 sar	 edx, 3
  00031	0f b6 14 32	 movzx	 edx, BYTE PTR [edx+esi]
  00035	83 e1 07	 and	 ecx, 7
  00038	84 14 8d 00 00
	00 00		 test	 dl, BYTE PTR _bytebit[ecx*4]
  0003f	0f 95 c1	 setne	 cl
  00042	88 4c 04 14	 mov	 BYTE PTR _buffer$[esp+eax+144], cl
  00046	0f b6 88 01 00
	00 00		 movzx	 ecx, BYTE PTR _pc1[eax+1]
  0004d	49		 dec	 ecx
  0004e	8b d1		 mov	 edx, ecx
  00050	c1 fa 03	 sar	 edx, 3
  00053	0f b6 14 32	 movzx	 edx, BYTE PTR [edx+esi]
  00057	83 e1 07	 and	 ecx, 7
  0005a	84 14 8d 00 00
	00 00		 test	 dl, BYTE PTR _bytebit[ecx*4]
  00061	0f 95 c1	 setne	 cl
  00064	88 4c 04 15	 mov	 BYTE PTR _buffer$[esp+eax+145], cl
  00068	0f b6 88 02 00
	00 00		 movzx	 ecx, BYTE PTR _pc1[eax+2]
  0006f	49		 dec	 ecx
  00070	8b d1		 mov	 edx, ecx
  00072	c1 fa 03	 sar	 edx, 3
  00075	0f b6 14 32	 movzx	 edx, BYTE PTR [edx+esi]
  00079	83 e1 07	 and	 ecx, 7
  0007c	84 14 8d 00 00
	00 00		 test	 dl, BYTE PTR _bytebit[ecx*4]
  00083	0f 95 c1	 setne	 cl
  00086	88 4c 04 16	 mov	 BYTE PTR _buffer$[esp+eax+146], cl
  0008a	0f b6 88 03 00
	00 00		 movzx	 ecx, BYTE PTR _pc1[eax+3]
  00091	49		 dec	 ecx
  00092	8b d1		 mov	 edx, ecx
  00094	c1 fa 03	 sar	 edx, 3
  00097	0f b6 14 32	 movzx	 edx, BYTE PTR [edx+esi]
  0009b	83 e1 07	 and	 ecx, 7
  0009e	84 14 8d 00 00
	00 00		 test	 dl, BYTE PTR _bytebit[ecx*4]
  000a5	0f 95 c1	 setne	 cl
  000a8	88 4c 04 17	 mov	 BYTE PTR _buffer$[esp+eax+147], cl
  000ac	83 c0 04	 add	 eax, 4
  000af	83 f8 38	 cmp	 eax, 56			; 00000038H
  000b2	0f 8c 6c ff ff
	ff		 jl	 $LL22@RawSetKey
  000b8	53		 push	 ebx
  000b9	33 d2		 xor	 edx, edx
  000bb	55		 push	 ebp
  000bc	89 54 24 14	 mov	 DWORD PTR _i$[esp+152], edx
  000c0	57		 push	 edi
  000c1	eb 0d 8d a4 24
	00 00 00 00 8d
	9b 00 00 00 00	 npad	 15
$LL64@RawSetKey:
  000d0	0f b6 8a 00 00
	00 00		 movzx	 ecx, BYTE PTR _totrot[edx]
  000d7	33 c0		 xor	 eax, eax
  000d9	89 84 24 90 00
	00 00		 mov	 DWORD PTR _buffer$[esp+268], eax
  000e0	89 84 24 94 00
	00 00		 mov	 DWORD PTR _buffer$[esp+272], eax
  000e7	83 e9 1a	 sub	 ecx, 26			; 0000001aH
  000ea	8d 9b 00 00 00
	00		 npad	 6
$LL16@RawSetKey:
  000f0	33 d2		 xor	 edx, edx
  000f2	83 f8 1c	 cmp	 eax, 28			; 0000001cH
  000f5	0f 9d c2	 setge	 dl
  000f8	8d 71 1a	 lea	 esi, DWORD PTR [ecx+26]
  000fb	4a		 dec	 edx
  000fc	83 e2 e4	 and	 edx, -28		; ffffffe4H
  000ff	83 c2 38	 add	 edx, 56			; 00000038H
  00102	3b f2		 cmp	 esi, edx
  00104	7c 03		 jl	 SHORT $LN26@RawSetKey

; 263  : 	byte buffer[56+56+8];
; 264  : 	byte *const pc1m=buffer;                 /* place to modify pc1 into */
; 265  : 	byte *const pcr=pc1m+56;                 /* place to rotate pc1 into */
; 266  : 	byte *const ks=pcr+56;
; 267  : 	register int i,j,l;
; 268  : 	int m;
; 269  : 	
; 270  : 	for (j=0; j<56; j++) {          /* convert pc1 to bits of key */
; 271  : 		l=pc1[j]-1;             /* integer bit location  */
; 272  : 		m = l & 07;             /* find bit              */
; 273  : 		pc1m[j]=(key[l>>3] &    /* find which key byte l is in */
; 274  : 			bytebit[m])     /* and which bit of that byte */
; 275  : 			? 1 : 0;        /* and store 1-bit result */
; 276  : 	}
; 277  : 	for (i=0; i<16; i++) {          /* key chunk for each iteration */
; 278  : 		memset(ks,0,8);         /* Clear key schedule */
; 279  : 		for (j=0; j<56; j++)    /* rotate pc1 the right amount */
; 280  : 			pcr[j] = pc1m[(l=j+totrot[i])<(j<28? 28 : 56) ? l: l-28];

  00106	8d 71 fe	 lea	 esi, DWORD PTR [ecx-2]
$LN26@RawSetKey:
  00109	8a 54 34 20	 mov	 dl, BYTE PTR _buffer$[esp+esi+156]
  0010d	88 54 04 58	 mov	 BYTE PTR _buffer$[esp+eax+212], dl
  00111	33 d2		 xor	 edx, edx
  00113	83 f8 1b	 cmp	 eax, 27			; 0000001bH
  00116	0f 9d c2	 setge	 dl
  00119	8d 71 1b	 lea	 esi, DWORD PTR [ecx+27]
  0011c	4a		 dec	 edx
  0011d	83 e2 e4	 and	 edx, -28		; ffffffe4H
  00120	83 c2 38	 add	 edx, 56			; 00000038H
  00123	3b f2		 cmp	 esi, edx
  00125	7c 03		 jl	 SHORT $LN49@RawSetKey
  00127	8d 71 ff	 lea	 esi, DWORD PTR [ecx-1]
$LN49@RawSetKey:
  0012a	8a 54 34 20	 mov	 dl, BYTE PTR _buffer$[esp+esi+156]
  0012e	88 54 04 59	 mov	 BYTE PTR _buffer$[esp+eax+213], dl
  00132	33 d2		 xor	 edx, edx
  00134	83 f8 1a	 cmp	 eax, 26			; 0000001aH
  00137	0f 9d c2	 setge	 dl
  0013a	8d 71 1c	 lea	 esi, DWORD PTR [ecx+28]
  0013d	4a		 dec	 edx
  0013e	83 e2 e4	 and	 edx, -28		; ffffffe4H
  00141	83 c2 38	 add	 edx, 56			; 00000038H
  00144	3b f2		 cmp	 esi, edx
  00146	7c 02		 jl	 SHORT $LN51@RawSetKey
  00148	8b f1		 mov	 esi, ecx
$LN51@RawSetKey:
  0014a	8a 54 34 20	 mov	 dl, BYTE PTR _buffer$[esp+esi+156]
  0014e	88 54 04 5a	 mov	 BYTE PTR _buffer$[esp+eax+214], dl
  00152	33 d2		 xor	 edx, edx
  00154	83 f8 19	 cmp	 eax, 25			; 00000019H
  00157	0f 9d c2	 setge	 dl
  0015a	8d 71 1d	 lea	 esi, DWORD PTR [ecx+29]
  0015d	4a		 dec	 edx
  0015e	83 e2 e4	 and	 edx, -28		; ffffffe4H
  00161	83 c2 38	 add	 edx, 56			; 00000038H
  00164	3b f2		 cmp	 esi, edx
  00166	7c 03		 jl	 SHORT $LN53@RawSetKey
  00168	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$LN53@RawSetKey:
  0016b	8a 54 34 20	 mov	 dl, BYTE PTR _buffer$[esp+esi+156]
  0016f	88 54 04 5b	 mov	 BYTE PTR _buffer$[esp+eax+215], dl
  00173	83 c0 04	 add	 eax, 4
  00176	83 c1 04	 add	 ecx, 4
  00179	83 f8 38	 cmp	 eax, 56			; 00000038H
  0017c	0f 8c 6e ff ff
	ff		 jl	 $LL16@RawSetKey

; 281  : 		/* rotate left and right halves independently */
; 282  : 		for (j=0; j<48; j++){   /* select bits individually */

  00182	33 c9		 xor	 ecx, ecx
  00184	c7 44 24 14 05
	00 00 00	 mov	 DWORD PTR tv1782[esp+156], 5
  0018c	c7 44 24 10 04
	00 00 00	 mov	 DWORD PTR tv1786[esp+156], 4
  00194	8d 69 03	 lea	 ebp, DWORD PTR [ecx+3]
  00197	8d 79 02	 lea	 edi, DWORD PTR [ecx+2]
  0019a	be 01 00 00 00	 mov	 esi, 1
  0019f	90		 npad	 1
$LL65@RawSetKey:

; 283  : 			/* check bit that goes to ks[j] */
; 284  : 			if (pcr[pc2[j]-1]){

  001a0	0f b6 86 ff ff
	ff ff		 movzx	 eax, BYTE PTR _pc2[esi-1]
  001a7	80 7c 04 57 00	 cmp	 BYTE PTR _buffer$[esp+eax+211], 0
  001ac	74 26		 je	 SHORT $LN12@RawSetKey

; 285  : 				/* mask it in if it's there */
; 286  : 				l= j % 6;

  001ae	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  001b3	f7 e1		 mul	 ecx
  001b5	c1 ea 02	 shr	 edx, 2

; 287  : 				ks[j/6] |= bytebit[l] >> 2;

  001b8	8d 84 14 90 00
	00 00		 lea	 eax, DWORD PTR _buffer$[esp+edx+268]
  001bf	8d 14 52	 lea	 edx, DWORD PTR [edx+edx*2]
  001c2	03 d2		 add	 edx, edx
  001c4	8b d9		 mov	 ebx, ecx
  001c6	2b da		 sub	 ebx, edx
  001c8	8b 14 9d 00 00
	00 00		 mov	 edx, DWORD PTR _bytebit[ebx*4]
  001cf	c1 fa 02	 sar	 edx, 2
  001d2	08 10		 or	 BYTE PTR [eax], dl
$LN12@RawSetKey:
  001d4	0f b6 86 00 00
	00 00		 movzx	 eax, BYTE PTR _pc2[esi]
  001db	80 7c 04 57 00	 cmp	 BYTE PTR _buffer$[esp+eax+211], 0
  001e0	74 26		 je	 SHORT $LN55@RawSetKey
  001e2	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  001e7	f7 e6		 mul	 esi
  001e9	c1 ea 02	 shr	 edx, 2
  001ec	8d 84 14 90 00
	00 00		 lea	 eax, DWORD PTR _buffer$[esp+edx+268]
  001f3	8d 14 52	 lea	 edx, DWORD PTR [edx+edx*2]
  001f6	03 d2		 add	 edx, edx
  001f8	8b d9		 mov	 ebx, ecx
  001fa	2b da		 sub	 ebx, edx
  001fc	8b 14 9d 04 00
	00 00		 mov	 edx, DWORD PTR _bytebit[ebx*4+4]
  00203	c1 fa 02	 sar	 edx, 2
  00206	08 10		 or	 BYTE PTR [eax], dl
$LN55@RawSetKey:
  00208	0f b6 87 00 00
	00 00		 movzx	 eax, BYTE PTR _pc2[edi]
  0020f	80 7c 04 57 00	 cmp	 BYTE PTR _buffer$[esp+eax+211], 0
  00214	74 26		 je	 SHORT $LN56@RawSetKey
  00216	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0021b	f7 e7		 mul	 edi
  0021d	c1 ea 02	 shr	 edx, 2
  00220	8d 84 14 90 00
	00 00		 lea	 eax, DWORD PTR _buffer$[esp+edx+268]
  00227	8d 14 52	 lea	 edx, DWORD PTR [edx+edx*2]
  0022a	03 d2		 add	 edx, edx
  0022c	8b d9		 mov	 ebx, ecx
  0022e	2b da		 sub	 ebx, edx
  00230	8b 14 9d 08 00
	00 00		 mov	 edx, DWORD PTR _bytebit[ebx*4+8]
  00237	c1 fa 02	 sar	 edx, 2
  0023a	08 10		 or	 BYTE PTR [eax], dl
$LN56@RawSetKey:
  0023c	0f b6 85 00 00
	00 00		 movzx	 eax, BYTE PTR _pc2[ebp]
  00243	80 7c 04 57 00	 cmp	 BYTE PTR _buffer$[esp+eax+211], 0
  00248	74 26		 je	 SHORT $LN57@RawSetKey
  0024a	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0024f	f7 e5		 mul	 ebp
  00251	c1 ea 02	 shr	 edx, 2
  00254	8d 84 14 90 00
	00 00		 lea	 eax, DWORD PTR _buffer$[esp+edx+268]
  0025b	8d 14 52	 lea	 edx, DWORD PTR [edx+edx*2]
  0025e	03 d2		 add	 edx, edx
  00260	8b d9		 mov	 ebx, ecx
  00262	2b da		 sub	 ebx, edx
  00264	8b 14 9d 0c 00
	00 00		 mov	 edx, DWORD PTR _bytebit[ebx*4+12]
  0026b	c1 fa 02	 sar	 edx, 2
  0026e	08 10		 or	 BYTE PTR [eax], dl
$LN57@RawSetKey:
  00270	8b 54 24 10	 mov	 edx, DWORD PTR tv1786[esp+156]
  00274	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR _pc2[edx]
  0027b	80 7c 04 57 00	 cmp	 BYTE PTR _buffer$[esp+eax+211], 0
  00280	74 26		 je	 SHORT $LN58@RawSetKey
  00282	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00287	f7 e2		 mul	 edx
  00289	c1 ea 02	 shr	 edx, 2
  0028c	8d 84 14 90 00
	00 00		 lea	 eax, DWORD PTR _buffer$[esp+edx+268]
  00293	8d 14 52	 lea	 edx, DWORD PTR [edx+edx*2]
  00296	03 d2		 add	 edx, edx
  00298	8b d9		 mov	 ebx, ecx
  0029a	2b da		 sub	 ebx, edx
  0029c	8b 14 9d 10 00
	00 00		 mov	 edx, DWORD PTR _bytebit[ebx*4+16]
  002a3	c1 fa 02	 sar	 edx, 2
  002a6	08 10		 or	 BYTE PTR [eax], dl
$LN58@RawSetKey:
  002a8	8b 54 24 14	 mov	 edx, DWORD PTR tv1782[esp+156]
  002ac	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR _pc2[edx]
  002b3	80 7c 04 57 00	 cmp	 BYTE PTR _buffer$[esp+eax+211], 0
  002b8	74 26		 je	 SHORT $LN59@RawSetKey
  002ba	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  002bf	f7 e2		 mul	 edx
  002c1	c1 ea 02	 shr	 edx, 2
  002c4	8d 84 14 90 00
	00 00		 lea	 eax, DWORD PTR _buffer$[esp+edx+268]
  002cb	8d 14 52	 lea	 edx, DWORD PTR [edx+edx*2]
  002ce	03 d2		 add	 edx, edx
  002d0	8b d9		 mov	 ebx, ecx
  002d2	2b da		 sub	 ebx, edx
  002d4	8b 14 9d 14 00
	00 00		 mov	 edx, DWORD PTR _bytebit[ebx*4+20]
  002db	c1 fa 02	 sar	 edx, 2
  002de	08 10		 or	 BYTE PTR [eax], dl
$LN59@RawSetKey:
  002e0	b8 06 00 00 00	 mov	 eax, 6
  002e5	01 44 24 10	 add	 DWORD PTR tv1786[esp+156], eax
  002e9	01 44 24 14	 add	 DWORD PTR tv1782[esp+156], eax
  002ed	03 f0		 add	 esi, eax
  002ef	03 c8		 add	 ecx, eax
  002f1	03 f8		 add	 edi, eax
  002f3	03 e8		 add	 ebp, eax
  002f5	83 fe 31	 cmp	 esi, 49			; 00000031H
  002f8	0f 8c a2 fe ff
	ff		 jl	 $LL65@RawSetKey

; 288  : 			}
; 289  : 		}
; 290  : 		/* Now convert to odd/even interleaved form for use in F */
; 291  : 		scheduledKey[2*i] = ((word32)ks[0] << 24)
; 292  : 			| ((word32)ks[2] << 16)
; 293  : 			| ((word32)ks[4] << 8)
; 294  : 			| ((word32)ks[6]);

  002fe	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR _buffer$[esp+268]
  00305	0f b6 8c 24 92
	00 00 00	 movzx	 ecx, BYTE PTR _buffer$[esp+270]
  0030d	8b 74 24 1c	 mov	 esi, DWORD PTR _scheduledKey$GSCopy$[esp+156]
  00311	0f b6 f8	 movzx	 edi, al
  00314	c1 e7 08	 shl	 edi, 8
  00317	0b f9		 or	 edi, ecx
  00319	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _buffer$[esp+272]
  00320	0f b6 d1	 movzx	 edx, cl
  00323	c1 e7 08	 shl	 edi, 8
  00326	0b fa		 or	 edi, edx
  00328	0f b6 94 24 96
	00 00 00	 movzx	 edx, BYTE PTR _buffer$[esp+274]
  00330	c1 e7 08	 shl	 edi, 8
  00333	0b fa		 or	 edi, edx
  00335	8b 54 24 18	 mov	 edx, DWORD PTR _i$[esp+156]

; 295  : 		scheduledKey[2*i+1] = ((word32)ks[1] << 24)
; 296  : 			| ((word32)ks[3] << 16)
; 297  : 			| ((word32)ks[5] << 8)
; 298  : 			| ((word32)ks[7]);

  00339	0f b6 c4	 movzx	 eax, ah
  0033c	c1 e0 08	 shl	 eax, 8
  0033f	89 3c d6	 mov	 DWORD PTR [esi+edx*8], edi
  00342	0f b6 bc 24 93
	00 00 00	 movzx	 edi, BYTE PTR _buffer$[esp+271]
  0034a	0b c7		 or	 eax, edi
  0034c	c1 e0 08	 shl	 eax, 8
  0034f	0f b6 cd	 movzx	 ecx, ch
  00352	0b c1		 or	 eax, ecx
  00354	0f b6 8c 24 97
	00 00 00	 movzx	 ecx, BYTE PTR _buffer$[esp+275]
  0035c	c1 e0 08	 shl	 eax, 8
  0035f	0b c1		 or	 eax, ecx
  00361	89 44 d6 04	 mov	 DWORD PTR [esi+edx*8+4], eax
  00365	42		 inc	 edx
  00366	83 fa 10	 cmp	 edx, 16			; 00000010H
  00369	89 54 24 18	 mov	 DWORD PTR _i$[esp+156], edx
  0036d	0f 8c 5d fd ff
	ff		 jl	 $LL64@RawSetKey

; 299  : 	}
; 300  : 	
; 301  : 	if (!encryption)     // reverse key schedule order

  00373	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR _encryption$[esp+152], 0
  0037b	75 28		 jne	 SHORT $LN5@RawSetKey

; 302  : 		for (i=0; i<16; i+=2)

  0037d	33 c0		 xor	 eax, eax
  0037f	8d 4e 7c	 lea	 ecx, DWORD PTR [esi+124]
$LL8@RawSetKey:

; 303  : 		{
; 304  : 			word32 b = scheduledKey[i];
; 305  : 			scheduledKey[i] = scheduledKey[32-2-i];

  00382	8b 79 fc	 mov	 edi, DWORD PTR [ecx-4]
  00385	8b 14 86	 mov	 edx, DWORD PTR [esi+eax*4]
  00388	89 3c 86	 mov	 DWORD PTR [esi+eax*4], edi

; 306  : 			scheduledKey[32-2-i] = b;

  0038b	89 51 fc	 mov	 DWORD PTR [ecx-4], edx

; 307  : 
; 308  : 			b = scheduledKey[i+1];
; 309  : 			scheduledKey[i+1] = scheduledKey[32-1-i];

  0038e	8b 39		 mov	 edi, DWORD PTR [ecx]
  00390	8b 54 86 04	 mov	 edx, DWORD PTR [esi+eax*4+4]
  00394	89 7c 86 04	 mov	 DWORD PTR [esi+eax*4+4], edi

; 310  : 			scheduledKey[32-1-i] = b;

  00398	89 11		 mov	 DWORD PTR [ecx], edx
  0039a	83 c0 02	 add	 eax, 2
  0039d	83 e9 08	 sub	 ecx, 8
  003a0	83 f8 10	 cmp	 eax, 16			; 00000010H
  003a3	7c dd		 jl	 SHORT $LL8@RawSetKey
$LN5@RawSetKey:
  003a5	5f		 pop	 edi

; 311  : 		}
; 312  : 
; 313  : 	burn (buffer, sizeof (buffer));

  003a6	8d 54 24 1c	 lea	 edx, DWORD PTR _buffer$[esp+152]
  003aa	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  003af	5d		 pop	 ebp
  003b0	8b f1		 mov	 esi, ecx
  003b2	8b c2		 mov	 eax, edx
  003b4	5b		 pop	 ebx
$LL28@RawSetKey:
  003b5	c6 00 00	 mov	 BYTE PTR [eax], 0
  003b8	40		 inc	 eax
  003b9	83 ee 01	 sub	 esi, 1
  003bc	75 f7		 jne	 SHORT $LL28@RawSetKey
  003be	5e		 pop	 esi
  003bf	90		 npad	 1
$LL2@RawSetKey:
  003c0	49		 dec	 ecx
  003c1	c6 02 00	 mov	 BYTE PTR [edx], 0
  003c4	42		 inc	 edx
  003c5	85 c9		 test	 ecx, ecx
  003c7	75 f7		 jne	 SHORT $LL2@RawSetKey

; 314  : }

  003c9	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+140]
  003d0	33 cc		 xor	 ecx, esp
  003d2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003d7	81 c4 8c 00 00
	00		 add	 esp, 140		; 0000008cH
  003dd	c3		 ret	 0
_RawSetKey ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _RawProcessBlock
_TEXT	SEGMENT
_l_$ = 8						; size = 4
_r_$ = 12						; size = 4
_k$ = 16						; size = 4
_RawProcessBlock PROC					; COMDAT

; 318  : 	word32 l = *l_, r = *r_;

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR _r_$[esp-4]
  00004	8b 44 24 04	 mov	 eax, DWORD PTR _l_$[esp-4]
  00008	8b 10		 mov	 edx, DWORD PTR [eax]
  0000a	53		 push	 ebx
  0000b	55		 push	 ebp
  0000c	56		 push	 esi
  0000d	8b 31		 mov	 esi, DWORD PTR [ecx]
  0000f	8b 4c 24 18	 mov	 ecx, DWORD PTR _k$[esp+8]
  00013	57		 push	 edi
  00014	83 c1 08	 add	 ecx, 8
  00017	bf 08 00 00 00	 mov	 edi, 8
  0001c	8d 64 24 00	 npad	 4
$LL3@RawProcess:

; 319  : 	const word32 *kptr=k;
; 320  : 	unsigned i;
; 321  : 
; 322  : 	for (i=0; i<8; i++)
; 323  : 	{
; 324  : 		word32 work = rotrFixed(r, 4U) ^ kptr[4*i+0];

  00020	8b c6		 mov	 eax, esi
  00022	c1 c8 04	 ror	 eax, 4
  00025	33 41 f8	 xor	 eax, DWORD PTR [ecx-8]
  00028	83 c1 10	 add	 ecx, 16			; 00000010H

; 325  : 		l ^= Spbox[6][(work) & 0x3f]
; 326  : 		  ^  Spbox[4][(work >> 8) & 0x3f]
; 327  : 		  ^  Spbox[2][(work >> 16) & 0x3f]
; 328  : 		  ^  Spbox[0][(work >> 24) & 0x3f];

  0002b	8b d8		 mov	 ebx, eax
  0002d	c1 eb 18	 shr	 ebx, 24			; 00000018H
  00030	83 e3 3f	 and	 ebx, 63			; 0000003fH
  00033	8b 1c 9d 00 00
	00 00		 mov	 ebx, DWORD PTR _Spbox[ebx*4]
  0003a	8b e8		 mov	 ebp, eax
  0003c	c1 ed 10	 shr	 ebp, 16			; 00000010H
  0003f	83 e5 3f	 and	 ebp, 63			; 0000003fH
  00042	33 1c ad 00 02
	00 00		 xor	 ebx, DWORD PTR _Spbox[ebp*4+512]
  00049	8b e8		 mov	 ebp, eax
  0004b	c1 ed 08	 shr	 ebp, 8
  0004e	83 e5 3f	 and	 ebp, 63			; 0000003fH
  00051	33 1c ad 00 04
	00 00		 xor	 ebx, DWORD PTR _Spbox[ebp*4+1024]
  00058	83 e0 3f	 and	 eax, 63			; 0000003fH
  0005b	33 1c 85 00 06
	00 00		 xor	 ebx, DWORD PTR _Spbox[eax*4+1536]

; 329  : 		work = r ^ kptr[4*i+1];

  00062	8b 41 ec	 mov	 eax, DWORD PTR [ecx-20]
  00065	33 d3		 xor	 edx, ebx
  00067	33 c6		 xor	 eax, esi

; 330  : 		l ^= Spbox[7][(work) & 0x3f]
; 331  : 		  ^  Spbox[5][(work >> 8) & 0x3f]
; 332  : 		  ^  Spbox[3][(work >> 16) & 0x3f]
; 333  : 		  ^  Spbox[1][(work >> 24) & 0x3f];

  00069	8b d8		 mov	 ebx, eax
  0006b	c1 eb 18	 shr	 ebx, 24			; 00000018H
  0006e	83 e3 3f	 and	 ebx, 63			; 0000003fH
  00071	8b 1c 9d 00 01
	00 00		 mov	 ebx, DWORD PTR _Spbox[ebx*4+256]
  00078	8b e8		 mov	 ebp, eax
  0007a	c1 ed 10	 shr	 ebp, 16			; 00000010H
  0007d	83 e5 3f	 and	 ebp, 63			; 0000003fH
  00080	33 1c ad 00 03
	00 00		 xor	 ebx, DWORD PTR _Spbox[ebp*4+768]
  00087	8b e8		 mov	 ebp, eax
  00089	c1 ed 08	 shr	 ebp, 8
  0008c	83 e5 3f	 and	 ebp, 63			; 0000003fH
  0008f	33 1c ad 00 05
	00 00		 xor	 ebx, DWORD PTR _Spbox[ebp*4+1280]
  00096	83 e0 3f	 and	 eax, 63			; 0000003fH
  00099	33 1c 85 00 07
	00 00		 xor	 ebx, DWORD PTR _Spbox[eax*4+1792]
  000a0	33 d3		 xor	 edx, ebx

; 334  : 
; 335  : 		work = rotrFixed(l, 4U) ^ kptr[4*i+2];

  000a2	8b c2		 mov	 eax, edx
  000a4	c1 c8 04	 ror	 eax, 4
  000a7	33 41 f0	 xor	 eax, DWORD PTR [ecx-16]

; 336  : 		r ^= Spbox[6][(work) & 0x3f]
; 337  : 		  ^  Spbox[4][(work >> 8) & 0x3f]
; 338  : 		  ^  Spbox[2][(work >> 16) & 0x3f]
; 339  : 		  ^  Spbox[0][(work >> 24) & 0x3f];

  000aa	8b d8		 mov	 ebx, eax
  000ac	c1 eb 18	 shr	 ebx, 24			; 00000018H
  000af	83 e3 3f	 and	 ebx, 63			; 0000003fH
  000b2	8b 1c 9d 00 00
	00 00		 mov	 ebx, DWORD PTR _Spbox[ebx*4]
  000b9	8b e8		 mov	 ebp, eax
  000bb	c1 ed 10	 shr	 ebp, 16			; 00000010H
  000be	83 e5 3f	 and	 ebp, 63			; 0000003fH
  000c1	33 1c ad 00 02
	00 00		 xor	 ebx, DWORD PTR _Spbox[ebp*4+512]
  000c8	8b e8		 mov	 ebp, eax
  000ca	c1 ed 08	 shr	 ebp, 8
  000cd	83 e5 3f	 and	 ebp, 63			; 0000003fH
  000d0	33 1c ad 00 04
	00 00		 xor	 ebx, DWORD PTR _Spbox[ebp*4+1024]
  000d7	83 e0 3f	 and	 eax, 63			; 0000003fH
  000da	33 1c 85 00 06
	00 00		 xor	 ebx, DWORD PTR _Spbox[eax*4+1536]

; 340  : 		work = l ^ kptr[4*i+3];

  000e1	8b 41 f4	 mov	 eax, DWORD PTR [ecx-12]
  000e4	33 f3		 xor	 esi, ebx
  000e6	33 c2		 xor	 eax, edx

; 341  : 		r ^= Spbox[7][(work) & 0x3f]
; 342  : 		  ^  Spbox[5][(work >> 8) & 0x3f]
; 343  : 		  ^  Spbox[3][(work >> 16) & 0x3f]
; 344  : 		  ^  Spbox[1][(work >> 24) & 0x3f];

  000e8	8b d8		 mov	 ebx, eax
  000ea	c1 eb 18	 shr	 ebx, 24			; 00000018H
  000ed	83 e3 3f	 and	 ebx, 63			; 0000003fH
  000f0	8b 1c 9d 00 01
	00 00		 mov	 ebx, DWORD PTR _Spbox[ebx*4+256]
  000f7	8b e8		 mov	 ebp, eax
  000f9	c1 ed 10	 shr	 ebp, 16			; 00000010H
  000fc	83 e5 3f	 and	 ebp, 63			; 0000003fH
  000ff	33 1c ad 00 03
	00 00		 xor	 ebx, DWORD PTR _Spbox[ebp*4+768]
  00106	8b e8		 mov	 ebp, eax
  00108	c1 ed 08	 shr	 ebp, 8
  0010b	83 e5 3f	 and	 ebp, 63			; 0000003fH
  0010e	33 1c ad 00 05
	00 00		 xor	 ebx, DWORD PTR _Spbox[ebp*4+1280]
  00115	83 e0 3f	 and	 eax, 63			; 0000003fH
  00118	33 1c 85 00 07
	00 00		 xor	 ebx, DWORD PTR _Spbox[eax*4+1792]
  0011f	33 f3		 xor	 esi, ebx
  00121	83 ef 01	 sub	 edi, 1
  00124	0f 85 f6 fe ff
	ff		 jne	 $LL3@RawProcess

; 345  : 	}
; 346  : 
; 347  : 	*l_ = l; *r_ = r;

  0012a	8b 44 24 14	 mov	 eax, DWORD PTR _l_$[esp+12]
  0012e	8b 4c 24 18	 mov	 ecx, DWORD PTR _r_$[esp+12]
  00132	5f		 pop	 edi
  00133	89 10		 mov	 DWORD PTR [eax], edx
  00135	89 31		 mov	 DWORD PTR [ecx], esi
  00137	5e		 pop	 esi
  00138	5d		 pop	 ebp
  00139	5b		 pop	 ebx

; 348  : }

  0013a	c3		 ret	 0
_RawProcessBlock ENDP
_TEXT	ENDS
PUBLIC	_TripleDesSetKey
; Function compile flags: /Ogtpy
;	COMDAT _TripleDesSetKey
_TEXT	SEGMENT
_userKey$ = 8						; size = 4
_length$ = 12						; size = 4
_ks$ = 16						; size = 4
_TripleDesSetKey PROC					; COMDAT

; 351  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi

; 352  : 	RawSetKey (1, userKey + 0, ks->k1);

  00003	8b 74 24 18	 mov	 esi, DWORD PTR _ks$[esp+8]
  00007	57		 push	 edi
  00008	8b 7c 24 14	 mov	 edi, DWORD PTR _userKey$[esp+12]
  0000c	56		 push	 esi
  0000d	6a 01		 push	 1
  0000f	8b cf		 mov	 ecx, edi
  00011	e8 00 00 00 00	 call	 _RawSetKey

; 353  : 	RawSetKey (1, userKey + 8, ks->k2);

  00016	8d 86 80 00 00
	00		 lea	 eax, DWORD PTR [esi+128]
  0001c	50		 push	 eax
  0001d	8d 5f 08	 lea	 ebx, DWORD PTR [edi+8]
  00020	6a 01		 push	 1
  00022	8b cb		 mov	 ecx, ebx
  00024	e8 00 00 00 00	 call	 _RawSetKey

; 354  : 	RawSetKey (1, userKey + 16, ks->k3);

  00029	8d 8e 00 01 00
	00		 lea	 ecx, DWORD PTR [esi+256]
  0002f	51		 push	 ecx
  00030	8d 6f 10	 lea	 ebp, DWORD PTR [edi+16]
  00033	6a 01		 push	 1
  00035	8b cd		 mov	 ecx, ebp
  00037	e8 00 00 00 00	 call	 _RawSetKey

; 355  : 	RawSetKey (0, userKey + 16, ks->k1d);

  0003c	8d 96 80 01 00
	00		 lea	 edx, DWORD PTR [esi+384]
  00042	52		 push	 edx
  00043	6a 00		 push	 0
  00045	8b cd		 mov	 ecx, ebp
  00047	e8 00 00 00 00	 call	 _RawSetKey

; 356  : 	RawSetKey (0, userKey + 8, ks->k2d);

  0004c	8d 86 00 02 00
	00		 lea	 eax, DWORD PTR [esi+512]
  00052	50		 push	 eax
  00053	6a 00		 push	 0
  00055	8b cb		 mov	 ecx, ebx
  00057	e8 00 00 00 00	 call	 _RawSetKey

; 357  : 	RawSetKey (0, userKey + 0, ks->k3d);

  0005c	81 c6 80 02 00
	00		 add	 esi, 640		; 00000280H
  00062	56		 push	 esi
  00063	6a 00		 push	 0
  00065	8b cf		 mov	 ecx, edi
  00067	e8 00 00 00 00	 call	 _RawSetKey
  0006c	83 c4 30	 add	 esp, 48			; 00000030H
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5d		 pop	 ebp
  00072	5b		 pop	 ebx

; 358  : }

  00073	c3		 ret	 0
_TripleDesSetKey ENDP
_TEXT	ENDS
PUBLIC	_TripleDesEncrypt
EXTRN	_MirrorBytes32:PROC
; Function compile flags: /Ogtpy
;	COMDAT _TripleDesEncrypt
_TEXT	SEGMENT
_left$ = -4						; size = 4
_right$ = 8						; size = 4
_inBlock$ = 8						; size = 4
_outBlock$ = 12						; size = 4
_key$ = 16						; size = 4
_encrypt$ = 20						; size = 4
_TripleDesEncrypt PROC					; COMDAT

; 361  : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 362  : 	word32 left = BE32 (((word32 *)inBlock)[0]);

  00003	8b 7c 24 10	 mov	 edi, DWORD PTR _inBlock$[esp+8]
  00007	8b 07		 mov	 eax, DWORD PTR [edi]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _MirrorBytes32

; 363  : 	word32 right = BE32 (((word32 *)inBlock)[1]);

  0000f	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00012	51		 push	 ecx
  00013	8b f0		 mov	 esi, eax
  00015	e8 00 00 00 00	 call	 _MirrorBytes32
  0001a	83 c4 08	 add	 esp, 8

; 364  : 	word32 work;
; 365  : 
; 366  : 	right = rotlFixed(right, 4U);

  0001d	c1 c0 04	 rol	 eax, 4

; 367  : 	work = (left ^ right) & 0xf0f0f0f0;

  00020	8b c8		 mov	 ecx, eax
  00022	33 ce		 xor	 ecx, esi
  00024	81 e1 f0 f0 f0
	f0		 and	 ecx, -252645136		; f0f0f0f0H

; 368  : 	left ^= work;

  0002a	33 f1		 xor	 esi, ecx

; 369  : 	right = rotrFixed(right^work, 20U);

  0002c	33 c8		 xor	 ecx, eax
  0002e	c1 c1 0c	 rol	 ecx, 12			; 0000000cH

; 370  : 	work = (left ^ right) & 0xffff0000;

  00031	8b c1		 mov	 eax, ecx
  00033	33 c6		 xor	 eax, esi
  00035	25 00 00 ff ff	 and	 eax, -65536		; ffff0000H

; 371  : 	left ^= work;

  0003a	33 f0		 xor	 esi, eax

; 372  : 	right = rotrFixed(right^work, 18U);

  0003c	33 c1		 xor	 eax, ecx
  0003e	c1 c0 0e	 rol	 eax, 14			; 0000000eH

; 373  : 	work = (left ^ right) & 0x33333333;

  00041	8b c8		 mov	 ecx, eax
  00043	33 ce		 xor	 ecx, esi
  00045	81 e1 33 33 33
	33		 and	 ecx, 858993459		; 33333333H

; 374  : 	left ^= work;

  0004b	33 f1		 xor	 esi, ecx

; 375  : 	right = rotrFixed(right^work, 6U);

  0004d	33 c8		 xor	 ecx, eax

; 376  : 	work = (left ^ right) & 0x00ff00ff;
; 377  : 	left ^= work;
; 378  : 	right = rotlFixed(right^work, 9U);
; 379  : 	work = (left ^ right) & 0xaaaaaaaa;
; 380  : 	left = rotlFixed(left^work, 1U);
; 381  : 	right ^= work;
; 382  : 
; 383  : 	RawProcessBlock (&left, &right, encrypt ? key->k1 : key->k1d);

  0004f	8b 7c 24 18	 mov	 edi, DWORD PTR _key$[esp+8]
  00053	c1 c9 06	 ror	 ecx, 6
  00056	8b c1		 mov	 eax, ecx
  00058	33 c6		 xor	 eax, esi
  0005a	25 ff 00 ff 00	 and	 eax, 16711935		; 00ff00ffH
  0005f	33 f0		 xor	 esi, eax
  00061	33 c1		 xor	 eax, ecx
  00063	c1 c0 09	 rol	 eax, 9
  00066	8b c8		 mov	 ecx, eax
  00068	33 ce		 xor	 ecx, esi
  0006a	81 e1 aa aa aa
	aa		 and	 ecx, -1431655766	; aaaaaaaaH
  00070	8b d1		 mov	 edx, ecx
  00072	33 d6		 xor	 edx, esi
  00074	8b 74 24 1c	 mov	 esi, DWORD PTR _encrypt$[esp+8]
  00078	33 c1		 xor	 eax, ecx
  0007a	d1 c2		 rol	 edx, 1
  0007c	89 44 24 10	 mov	 DWORD PTR _right$[esp+8], eax
  00080	89 54 24 08	 mov	 DWORD PTR _left$[esp+12], edx
  00084	8b c7		 mov	 eax, edi
  00086	85 f6		 test	 esi, esi
  00088	75 06		 jne	 SHORT $LN4@TripleDesE
  0008a	8d 87 80 01 00
	00		 lea	 eax, DWORD PTR [edi+384]
$LN4@TripleDesE:
  00090	50		 push	 eax
  00091	8d 44 24 14	 lea	 eax, DWORD PTR _right$[esp+12]
  00095	50		 push	 eax
  00096	8d 4c 24 10	 lea	 ecx, DWORD PTR _left$[esp+20]
  0009a	51		 push	 ecx
  0009b	e8 00 00 00 00	 call	 _RawProcessBlock
  000a0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 384  : 	RawProcessBlock (&right, &left, !encrypt ? key->k2 : key->k2d);

  000a3	8d 87 80 00 00
	00		 lea	 eax, DWORD PTR [edi+128]
  000a9	85 f6		 test	 esi, esi
  000ab	74 06		 je	 SHORT $LN6@TripleDesE
  000ad	8d 87 00 02 00
	00		 lea	 eax, DWORD PTR [edi+512]
$LN6@TripleDesE:
  000b3	50		 push	 eax
  000b4	8d 54 24 0c	 lea	 edx, DWORD PTR _left$[esp+16]
  000b8	52		 push	 edx
  000b9	8d 44 24 18	 lea	 eax, DWORD PTR _right$[esp+16]
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 _RawProcessBlock
  000c3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 385  : 	RawProcessBlock (&left, &right, encrypt ? key->k3 : key->k3d);

  000c6	8d 87 00 01 00
	00		 lea	 eax, DWORD PTR [edi+256]
  000cc	85 f6		 test	 esi, esi
  000ce	75 06		 jne	 SHORT $LN8@TripleDesE
  000d0	8d 87 80 02 00
	00		 lea	 eax, DWORD PTR [edi+640]
$LN8@TripleDesE:
  000d6	50		 push	 eax
  000d7	8d 4c 24 14	 lea	 ecx, DWORD PTR _right$[esp+12]
  000db	51		 push	 ecx
  000dc	8d 54 24 10	 lea	 edx, DWORD PTR _left$[esp+20]
  000e0	52		 push	 edx
  000e1	e8 00 00 00 00	 call	 _RawProcessBlock

; 386  : 	
; 387  : 	right = rotrFixed(right, 1U);

  000e6	8b 44 24 1c	 mov	 eax, DWORD PTR _right$[esp+20]

; 388  : 	work = (left ^ right) & 0xaaaaaaaa;

  000ea	8b 54 24 14	 mov	 edx, DWORD PTR _left$[esp+24]
  000ee	d1 c8		 ror	 eax, 1
  000f0	8b c8		 mov	 ecx, eax
  000f2	33 ca		 xor	 ecx, edx
  000f4	81 e1 aa aa aa
	aa		 and	 ecx, -1431655766	; aaaaaaaaH

; 389  : 	right ^= work;

  000fa	33 c1		 xor	 eax, ecx

; 390  : 	left = rotrFixed(left^work, 9U);

  000fc	33 ca		 xor	 ecx, edx
  000fe	c1 c9 09	 ror	 ecx, 9

; 391  : 	work = (left ^ right) & 0x00ff00ff;

  00101	8b d0		 mov	 edx, eax
  00103	33 d1		 xor	 edx, ecx
  00105	81 e2 ff 00 ff
	00		 and	 edx, 16711935		; 00ff00ffH

; 392  : 	right ^= work;

  0010b	33 c2		 xor	 eax, edx

; 393  : 	left = rotlFixed(left^work, 6U);

  0010d	33 d1		 xor	 edx, ecx
  0010f	c1 c2 06	 rol	 edx, 6

; 394  : 	work = (left ^ right) & 0x33333333;

  00112	8b c8		 mov	 ecx, eax
  00114	33 ca		 xor	 ecx, edx
  00116	81 e1 33 33 33
	33		 and	 ecx, 858993459		; 33333333H

; 395  : 	right ^= work;

  0011c	33 c1		 xor	 eax, ecx

; 396  : 	left = rotlFixed(left^work, 18U);

  0011e	33 ca		 xor	 ecx, edx
  00120	c1 c9 0e	 ror	 ecx, 14			; 0000000eH

; 397  : 	work = (left ^ right) & 0xffff0000;

  00123	8b d0		 mov	 edx, eax
  00125	33 d1		 xor	 edx, ecx
  00127	81 e2 00 00 ff
	ff		 and	 edx, -65536		; ffff0000H

; 398  : 	right ^= work;

  0012d	33 c2		 xor	 eax, edx

; 399  : 	left = rotlFixed(left^work, 20U);

  0012f	33 d1		 xor	 edx, ecx
  00131	c1 ca 0c	 ror	 edx, 12			; 0000000cH

; 400  : 	work = (left ^ right) & 0xf0f0f0f0;

  00134	8b c8		 mov	 ecx, eax
  00136	33 ca		 xor	 ecx, edx
  00138	81 e1 f0 f0 f0
	f0		 and	 ecx, -252645136		; f0f0f0f0H

; 401  : 	right ^= work;

  0013e	33 c1		 xor	 eax, ecx

; 402  : 	left = rotrFixed(left^work, 4U);

  00140	33 ca		 xor	 ecx, edx
  00142	c1 c9 04	 ror	 ecx, 4

; 403  : 
; 404  : 	((word32 *)outBlock)[0] = BE32 (right);

  00145	50		 push	 eax
  00146	8b f1		 mov	 esi, ecx
  00148	e8 00 00 00 00	 call	 _MirrorBytes32
  0014d	8b 7c 24 24	 mov	 edi, DWORD PTR _outBlock$[esp+24]

; 405  : 	((word32 *)outBlock)[1] = BE32 (left);

  00151	56		 push	 esi
  00152	89 07		 mov	 DWORD PTR [edi], eax
  00154	e8 00 00 00 00	 call	 _MirrorBytes32
  00159	83 c4 14	 add	 esp, 20			; 00000014H
  0015c	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0015f	5f		 pop	 edi
  00160	5e		 pop	 esi

; 406  : }

  00161	59		 pop	 ecx
  00162	c3		 ret	 0
_TripleDesEncrypt ENDP
_TEXT	ENDS
END
