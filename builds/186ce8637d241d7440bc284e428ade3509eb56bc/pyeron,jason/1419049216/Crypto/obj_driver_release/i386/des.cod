; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\home\public\desktop\projects\ciphershed\src\crypto\des.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
_pc1	DB	039H
	DB	031H
	DB	029H
	DB	021H
	DB	019H
	DB	011H
	DB	09H
	DB	01H
	DB	03aH
	DB	032H
	DB	02aH
	DB	022H
	DB	01aH
	DB	012H
	DB	0aH
	DB	02H
	DB	03bH
	DB	033H
	DB	02bH
	DB	023H
	DB	01bH
	DB	013H
	DB	0bH
	DB	03H
	DB	03cH
	DB	034H
	DB	02cH
	DB	024H
	DB	03fH
	DB	037H
	DB	02fH
	DB	027H
	DB	01fH
	DB	017H
	DB	0fH
	DB	07H
	DB	03eH
	DB	036H
	DB	02eH
	DB	026H
	DB	01eH
	DB	016H
	DB	0eH
	DB	06H
	DB	03dH
	DB	035H
	DB	02dH
	DB	025H
	DB	01dH
	DB	015H
	DB	0dH
	DB	05H
	DB	01cH
	DB	014H
	DB	0cH
	DB	04H
_totrot	DB	01H
	DB	02H
	DB	04H
	DB	06H
	DB	08H
	DB	0aH
	DB	0cH
	DB	0eH
	DB	0fH
	DB	011H
	DB	013H
	DB	015H
	DB	017H
	DB	019H
	DB	01bH
	DB	01cH
_pc2	DB	0eH
	DB	011H
	DB	0bH
	DB	018H
	DB	01H
	DB	05H
	DB	03H
	DB	01cH
	DB	0fH
	DB	06H
	DB	015H
	DB	0aH
	DB	017H
	DB	013H
	DB	0cH
	DB	04H
	DB	01aH
	DB	08H
	DB	010H
	DB	07H
	DB	01bH
	DB	014H
	DB	0dH
	DB	02H
	DB	029H
	DB	034H
	DB	01fH
	DB	025H
	DB	02fH
	DB	037H
	DB	01eH
	DB	028H
	DB	033H
	DB	02dH
	DB	021H
	DB	030H
	DB	02cH
	DB	031H
	DB	027H
	DB	038H
	DB	022H
	DB	035H
	DB	02eH
	DB	02aH
	DB	032H
	DB	024H
	DB	01dH
	DB	020H
_bytebit DD	080H
	DD	040H
	DD	020H
	DD	010H
	DD	08H
	DD	04H
	DD	02H
	DD	01H
_Spbox	DD	01010400H
	DD	00H
	DD	010000H
	DD	01010404H
	DD	01010004H
	DD	010404H
	DD	04H
	DD	010000H
	DD	0400H
	DD	01010400H
	DD	01010404H
	DD	0400H
	DD	01000404H
	DD	01010004H
	DD	01000000H
	DD	04H
	DD	0404H
	DD	01000400H
	DD	01000400H
	DD	010400H
	DD	010400H
	DD	01010000H
	DD	01010000H
	DD	01000404H
	DD	010004H
	DD	01000004H
	DD	01000004H
	DD	010004H
	DD	00H
	DD	0404H
	DD	010404H
	DD	01000000H
	DD	010000H
	DD	01010404H
	DD	04H
	DD	01010000H
	DD	01010400H
	DD	01000000H
	DD	01000000H
	DD	0400H
	DD	01010004H
	DD	010000H
	DD	010400H
	DD	01000004H
	DD	0400H
	DD	04H
	DD	01000404H
	DD	010404H
	DD	01010404H
	DD	010004H
	DD	01010000H
	DD	01000404H
	DD	01000004H
	DD	0404H
	DD	010404H
	DD	01010400H
	DD	0404H
	DD	01000400H
	DD	01000400H
	DD	00H
	DD	010004H
	DD	010400H
	DD	00H
	DD	01010004H
	DD	080108020H
	DD	080008000H
	DD	08000H
	DD	0108020H
	DD	0100000H
	DD	020H
	DD	080100020H
	DD	080008020H
	DD	080000020H
	DD	080108020H
	DD	080108000H
	DD	080000000H
	DD	080008000H
	DD	0100000H
	DD	020H
	DD	080100020H
	DD	0108000H
	DD	0100020H
	DD	080008020H
	DD	00H
	DD	080000000H
	DD	08000H
	DD	0108020H
	DD	080100000H
	DD	0100020H
	DD	080000020H
	DD	00H
	DD	0108000H
	DD	08020H
	DD	080108000H
	DD	080100000H
	DD	08020H
	DD	00H
	DD	0108020H
	DD	080100020H
	DD	0100000H
	DD	080008020H
	DD	080100000H
	DD	080108000H
	DD	08000H
	DD	080100000H
	DD	080008000H
	DD	020H
	DD	080108020H
	DD	0108020H
	DD	020H
	DD	08000H
	DD	080000000H
	DD	08020H
	DD	080108000H
	DD	0100000H
	DD	080000020H
	DD	0100020H
	DD	080008020H
	DD	080000020H
	DD	0100020H
	DD	0108000H
	DD	00H
	DD	080008000H
	DD	08020H
	DD	080000000H
	DD	080100020H
	DD	080108020H
	DD	0108000H
	DD	0208H
	DD	08020200H
	DD	00H
	DD	08020008H
	DD	08000200H
	DD	00H
	DD	020208H
	DD	08000200H
	DD	020008H
	DD	08000008H
	DD	08000008H
	DD	020000H
	DD	08020208H
	DD	020008H
	DD	08020000H
	DD	0208H
	DD	08000000H
	DD	08H
	DD	08020200H
	DD	0200H
	DD	020200H
	DD	08020000H
	DD	08020008H
	DD	020208H
	DD	08000208H
	DD	020200H
	DD	020000H
	DD	08000208H
	DD	08H
	DD	08020208H
	DD	0200H
	DD	08000000H
	DD	08020200H
	DD	08000000H
	DD	020008H
	DD	0208H
	DD	020000H
	DD	08020200H
	DD	08000200H
	DD	00H
	DD	0200H
	DD	020008H
	DD	08020208H
	DD	08000200H
	DD	08000008H
	DD	0200H
	DD	00H
	DD	08020008H
	DD	08000208H
	DD	020000H
	DD	08000000H
	DD	08020208H
	DD	08H
	DD	020208H
	DD	020200H
	DD	08000008H
	DD	08020000H
	DD	08000208H
	DD	0208H
	DD	08020000H
	DD	020208H
	DD	08H
	DD	08020008H
	DD	020200H
	DD	0802001H
	DD	02081H
	DD	02081H
	DD	080H
	DD	0802080H
	DD	0800081H
	DD	0800001H
	DD	02001H
	DD	00H
	DD	0802000H
	DD	0802000H
	DD	0802081H
	DD	081H
	DD	00H
	DD	0800080H
	DD	0800001H
	DD	01H
	DD	02000H
	DD	0800000H
	DD	0802001H
	DD	080H
	DD	0800000H
	DD	02001H
	DD	02080H
	DD	0800081H
	DD	01H
	DD	02080H
	DD	0800080H
	DD	02000H
	DD	0802080H
	DD	0802081H
	DD	081H
	DD	0800080H
	DD	0800001H
	DD	0802000H
	DD	0802081H
	DD	081H
	DD	00H
	DD	00H
	DD	0802000H
	DD	02080H
	DD	0800080H
	DD	0800081H
	DD	01H
	DD	0802001H
	DD	02081H
	DD	02081H
	DD	080H
	DD	0802081H
	DD	081H
	DD	01H
	DD	02000H
	DD	0800001H
	DD	02001H
	DD	0802080H
	DD	0800081H
	DD	02001H
	DD	02080H
	DD	0800000H
	DD	0802001H
	DD	080H
	DD	0800000H
	DD	02000H
	DD	0802080H
	DD	0100H
	DD	02080100H
	DD	02080000H
	DD	042000100H
	DD	080000H
	DD	0100H
	DD	040000000H
	DD	02080000H
	DD	040080100H
	DD	080000H
	DD	02000100H
	DD	040080100H
	DD	042000100H
	DD	042080000H
	DD	080100H
	DD	040000000H
	DD	02000000H
	DD	040080000H
	DD	040080000H
	DD	00H
	DD	040000100H
	DD	042080100H
	DD	042080100H
	DD	02000100H
	DD	042080000H
	DD	040000100H
	DD	00H
	DD	042000000H
	DD	02080100H
	DD	02000000H
	DD	042000000H
	DD	080100H
	DD	080000H
	DD	042000100H
	DD	0100H
	DD	02000000H
	DD	040000000H
	DD	02080000H
	DD	042000100H
	DD	040080100H
	DD	02000100H
	DD	040000000H
	DD	042080000H
	DD	02080100H
	DD	040080100H
	DD	0100H
	DD	02000000H
	DD	042080000H
	DD	042080100H
	DD	080100H
	DD	042000000H
	DD	042080100H
	DD	02080000H
	DD	00H
	DD	040080000H
	DD	042000000H
	DD	080100H
	DD	02000100H
	DD	040000100H
	DD	080000H
	DD	00H
	DD	040080000H
	DD	02080100H
	DD	040000100H
	DD	020000010H
	DD	020400000H
	DD	04000H
	DD	020404010H
	DD	020400000H
	DD	010H
	DD	020404010H
	DD	0400000H
	DD	020004000H
	DD	0404010H
	DD	0400000H
	DD	020000010H
	DD	0400010H
	DD	020004000H
	DD	020000000H
	DD	04010H
	DD	00H
	DD	0400010H
	DD	020004010H
	DD	04000H
	DD	0404000H
	DD	020004010H
	DD	010H
	DD	020400010H
	DD	020400010H
	DD	00H
	DD	0404010H
	DD	020404000H
	DD	04010H
	DD	0404000H
	DD	020404000H
	DD	020000000H
	DD	020004000H
	DD	010H
	DD	020400010H
	DD	0404000H
	DD	020404010H
	DD	0400000H
	DD	04010H
	DD	020000010H
	DD	0400000H
	DD	020004000H
	DD	020000000H
	DD	04010H
	DD	020000010H
	DD	020404010H
	DD	0404000H
	DD	020400000H
	DD	0404010H
	DD	020404000H
	DD	00H
	DD	020400010H
	DD	010H
	DD	04000H
	DD	020400000H
	DD	0404010H
	DD	04000H
	DD	0400010H
	DD	020004010H
	DD	00H
	DD	020404000H
	DD	020000000H
	DD	0400010H
	DD	020004010H
	DD	0200000H
	DD	04200002H
	DD	04000802H
	DD	00H
	DD	0800H
	DD	04000802H
	DD	0200802H
	DD	04200800H
	DD	04200802H
	DD	0200000H
	DD	00H
	DD	04000002H
	DD	02H
	DD	04000000H
	DD	04200002H
	DD	0802H
	DD	04000800H
	DD	0200802H
	DD	0200002H
	DD	04000800H
	DD	04000002H
	DD	04200000H
	DD	04200800H
	DD	0200002H
	DD	04200000H
	DD	0800H
	DD	0802H
	DD	04200802H
	DD	0200800H
	DD	02H
	DD	04000000H
	DD	0200800H
	DD	04000000H
	DD	0200800H
	DD	0200000H
	DD	04000802H
	DD	04000802H
	DD	04200002H
	DD	04200002H
	DD	02H
	DD	0200002H
	DD	04000000H
	DD	04000800H
	DD	0200000H
	DD	04200800H
	DD	0802H
	DD	0200802H
	DD	04200800H
	DD	0802H
	DD	04000002H
	DD	04200802H
	DD	04200000H
	DD	0200800H
	DD	00H
	DD	02H
	DD	04200802H
	DD	00H
	DD	0200802H
	DD	04200000H
	DD	0800H
	DD	04000002H
	DD	04000800H
	DD	0800H
	DD	0200002H
	DD	010001040H
	DD	01000H
	DD	040000H
	DD	010041040H
	DD	010000000H
	DD	010001040H
	DD	040H
	DD	010000000H
	DD	040040H
	DD	010040000H
	DD	010041040H
	DD	041000H
	DD	010041000H
	DD	041040H
	DD	01000H
	DD	040H
	DD	010040000H
	DD	010000040H
	DD	010001000H
	DD	01040H
	DD	041000H
	DD	040040H
	DD	010040040H
	DD	010041000H
	DD	01040H
	DD	00H
	DD	00H
	DD	010040040H
	DD	010000040H
	DD	010001000H
	DD	041040H
	DD	040000H
	DD	041040H
	DD	040000H
	DD	010041000H
	DD	01000H
	DD	040H
	DD	010040040H
	DD	01000H
	DD	041040H
	DD	010001000H
	DD	040H
	DD	010000040H
	DD	010040000H
	DD	010040040H
	DD	010000000H
	DD	040000H
	DD	010001040H
	DD	00H
	DD	010041040H
	DD	040040H
	DD	010000040H
	DD	010040000H
	DD	010001000H
	DD	010001040H
	DD	00H
	DD	010041040H
	DD	041000H
	DD	041000H
	DD	01040H
	DD	01040H
	DD	040040H
	DD	010000000H
	DD	010041000H
CONST	ENDS
PUBLIC	_RtlSecureZeroMemory@8
; Function compile flags: /Ogsp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
;	COMDAT _RtlSecureZeroMemory@8
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory@8 PROC				; COMDAT

; 8322 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 8323 :     volatile char *vptr = (volatile char *)ptr;
; 8324 : 
; 8325 : #if defined(_M_AMD64)
; 8326 : 
; 8327 :         __stosb((PUCHAR)((ULONG64)vptr), 0, cnt);
; 8328 : 
; 8329 : #else
; 8330 : 
; 8331 :     while (cnt) {

  00005	83 7d 0c 00	 cmp	 DWORD PTR _cnt$[ebp], 0
  00009	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  0000c	74 09		 je	 SHORT $LN1@RtlSecureZ
$LL2@RtlSecureZ:

; 8332 :         *vptr = 0;

  0000e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 8333 :         vptr++;

  00011	40		 inc	 eax

; 8334 :         cnt--;

  00012	ff 4d 0c	 dec	 DWORD PTR _cnt$[ebp]
  00015	75 f7		 jne	 SHORT $LL2@RtlSecureZ
$LN1@RtlSecureZ:

; 8335 :     }
; 8336 : 
; 8337 : #endif
; 8338 : 
; 8339 :     return ptr;

  00017	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]

; 8340 : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
_RtlSecureZeroMemory@8 ENDP
; Function compile flags: /Ogsp
; File c:\home\public\desktop\projects\ciphershed\src\crypto\des.c
_TEXT	ENDS
;	COMDAT _rotlFixed@8
_TEXT	SEGMENT
_rotlFixed@8 PROC					; COMDAT
; _x$ = eax
; _y$ = ecx

; 32   : 	return (word32)((x<<y) | (x>>(sizeof(word32)*8-y)));

  00000	d3 c0		 rol	 eax, cl

; 33   : }

  00002	c3		 ret	 0
_rotlFixed@8 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _rotrFixed@8
_TEXT	SEGMENT
_rotrFixed@8 PROC					; COMDAT
; _x$ = eax
; _y$ = ecx

; 37   : 	return (word32)((x>>y) | (x<<(sizeof(word32)*8-y)));

  00000	d3 c8		 ror	 eax, cl

; 38   : }

  00002	c3		 ret	 0
_rotrFixed@8 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _RawSetKey@12
_TEXT	SEGMENT
_buffer$ = -124						; size = 120
__$ArrayPad$ = -4					; size = 4
_encryption$ = 8					; size = 4
_key$ = 12						; size = 4
_RawSetKey@12 PROC					; COMDAT
; _scheduledKey$ = ecx

; 262  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 7c	 sub	 esp, 124		; 0000007cH
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00012	56		 push	 esi
  00013	53		 push	 ebx
  00014	8b f1		 mov	 esi, ecx

; 263  : 	byte buffer[56+56+8];
; 264  : 	byte *const pc1m=buffer;                 /* place to modify pc1 into */
; 265  : 	byte *const pcr=pc1m+56;                 /* place to rotate pc1 into */
; 266  : 	byte *const ks=pcr+56;
; 267  : 	register int i,j,l;
; 268  : 	int m;
; 269  : 	
; 270  : 	for (j=0; j<56; j++) {          /* convert pc1 to bits of key */

  00016	33 c9		 xor	 ecx, ecx
  00018	57		 push	 edi
$LL22@RawSetKey:

; 271  : 		l=pc1[j]-1;             /* integer bit location  */

  00019	0f b6 81 00 00
	00 00		 movzx	 eax, BYTE PTR _pc1[ecx]

; 272  : 		m = l & 07;             /* find bit              */
; 273  : 		pc1m[j]=(key[l>>3] &    /* find which key byte l is in */
; 274  : 			bytebit[m])     /* and which bit of that byte */
; 275  : 			? 1 : 0;        /* and store 1-bit result */

  00020	8b 7d 0c	 mov	 edi, DWORD PTR _key$[ebp]
  00023	48		 dec	 eax
  00024	8b d0		 mov	 edx, eax
  00026	c1 fa 03	 sar	 edx, 3
  00029	8a 14 3a	 mov	 dl, BYTE PTR [edx+edi]
  0002c	83 e0 07	 and	 eax, 7
  0002f	84 14 85 00 00
	00 00		 test	 dl, BYTE PTR _bytebit[eax*4]
  00036	0f 95 c0	 setne	 al
  00039	88 44 0d 84	 mov	 BYTE PTR _buffer$[ebp+ecx], al
  0003d	41		 inc	 ecx
  0003e	83 f9 38	 cmp	 ecx, 56			; 00000038H
  00041	7c d6		 jl	 SHORT $LL22@RawSetKey

; 276  : 	}
; 277  : 	for (i=0; i<16; i++) {          /* key chunk for each iteration */

  00043	33 db		 xor	 ebx, ebx
$LL48@RawSetKey:

; 278  : 		memset(ks,0,8);         /* Clear key schedule */

  00045	33 c0		 xor	 eax, eax
  00047	8d 7d f4	 lea	 edi, DWORD PTR _buffer$[ebp+112]
  0004a	ab		 stosd
  0004b	ab		 stosd
  0004c	0f b6 83 00 00
	00 00		 movzx	 eax, BYTE PTR _totrot[ebx]

; 279  : 		for (j=0; j<56; j++)    /* rotate pc1 the right amount */

  00053	33 c9		 xor	 ecx, ecx
$LL16@RawSetKey:

; 280  : 			pcr[j] = pc1m[(l=j+totrot[i])<(j<28? 28 : 56) ? l: l-28];

  00055	33 d2		 xor	 edx, edx
  00057	83 f9 1c	 cmp	 ecx, 28			; 0000001cH
  0005a	0f 9d c2	 setge	 dl
  0005d	8b f8		 mov	 edi, eax
  0005f	4a		 dec	 edx
  00060	83 e2 e4	 and	 edx, -28		; ffffffe4H
  00063	83 c2 38	 add	 edx, 56			; 00000038H
  00066	3b c2		 cmp	 eax, edx
  00068	7c 03		 jl	 SHORT $LN26@RawSetKey

; 279  : 		for (j=0; j<56; j++)    /* rotate pc1 the right amount */

  0006a	8d 78 e4	 lea	 edi, DWORD PTR [eax-28]
$LN26@RawSetKey:

; 280  : 			pcr[j] = pc1m[(l=j+totrot[i])<(j<28? 28 : 56) ? l: l-28];

  0006d	8a 54 3d 84	 mov	 dl, BYTE PTR _buffer$[ebp+edi]
  00071	88 54 0d bc	 mov	 BYTE PTR _buffer$[ebp+ecx+56], dl
  00075	41		 inc	 ecx
  00076	40		 inc	 eax
  00077	83 f9 38	 cmp	 ecx, 56			; 00000038H
  0007a	7c d9		 jl	 SHORT $LL16@RawSetKey

; 281  : 		/* rotate left and right halves independently */
; 282  : 		for (j=0; j<48; j++){   /* select bits individually */

  0007c	33 c9		 xor	 ecx, ecx
$LL13@RawSetKey:

; 283  : 			/* check bit that goes to ks[j] */
; 284  : 			if (pcr[pc2[j]-1]){

  0007e	0f b6 81 00 00
	00 00		 movzx	 eax, BYTE PTR _pc2[ecx]
  00085	80 7c 05 bb 00	 cmp	 BYTE PTR _buffer$[ebp+eax+55], 0
  0008a	74 18		 je	 SHORT $LN12@RawSetKey

; 285  : 				/* mask it in if it's there */
; 286  : 				l= j % 6;

  0008c	8b c1		 mov	 eax, ecx
  0008e	99		 cdq
  0008f	6a 06		 push	 6
  00091	5f		 pop	 edi
  00092	f7 ff		 idiv	 edi

; 287  : 				ks[j/6] |= bytebit[l] >> 2;

  00094	8b 14 95 00 00
	00 00		 mov	 edx, DWORD PTR _bytebit[edx*4]
  0009b	8d 44 05 f4	 lea	 eax, DWORD PTR _buffer$[ebp+eax+112]
  0009f	c1 fa 02	 sar	 edx, 2
  000a2	08 10		 or	 BYTE PTR [eax], dl
$LN12@RawSetKey:
  000a4	41		 inc	 ecx
  000a5	83 f9 30	 cmp	 ecx, 48			; 00000030H
  000a8	7c d4		 jl	 SHORT $LL13@RawSetKey

; 288  : 			}
; 289  : 		}
; 290  : 		/* Now convert to odd/even interleaved form for use in F */
; 291  : 		scheduledKey[2*i] = ((word32)ks[0] << 24)
; 292  : 			| ((word32)ks[2] << 16)
; 293  : 			| ((word32)ks[4] << 8)
; 294  : 			| ((word32)ks[6]);

  000aa	0f b6 45 f4	 movzx	 eax, BYTE PTR _buffer$[ebp+112]
  000ae	0f b6 4d f6	 movzx	 ecx, BYTE PTR _buffer$[ebp+114]
  000b2	c1 e0 08	 shl	 eax, 8
  000b5	0b c1		 or	 eax, ecx
  000b7	0f b6 4d f8	 movzx	 ecx, BYTE PTR _buffer$[ebp+116]
  000bb	c1 e0 08	 shl	 eax, 8
  000be	0b c1		 or	 eax, ecx
  000c0	0f b6 4d fa	 movzx	 ecx, BYTE PTR _buffer$[ebp+118]
  000c4	c1 e0 08	 shl	 eax, 8
  000c7	0b c1		 or	 eax, ecx

; 295  : 		scheduledKey[2*i+1] = ((word32)ks[1] << 24)
; 296  : 			| ((word32)ks[3] << 16)
; 297  : 			| ((word32)ks[5] << 8)
; 298  : 			| ((word32)ks[7]);

  000c9	0f b6 4d f7	 movzx	 ecx, BYTE PTR _buffer$[ebp+115]
  000cd	89 04 de	 mov	 DWORD PTR [esi+ebx*8], eax
  000d0	0f b6 45 f5	 movzx	 eax, BYTE PTR _buffer$[ebp+113]
  000d4	c1 e0 08	 shl	 eax, 8
  000d7	0b c1		 or	 eax, ecx
  000d9	0f b6 4d f9	 movzx	 ecx, BYTE PTR _buffer$[ebp+117]
  000dd	c1 e0 08	 shl	 eax, 8
  000e0	0b c1		 or	 eax, ecx
  000e2	0f b6 4d fb	 movzx	 ecx, BYTE PTR _buffer$[ebp+119]
  000e6	c1 e0 08	 shl	 eax, 8
  000e9	0b c1		 or	 eax, ecx
  000eb	89 44 de 04	 mov	 DWORD PTR [esi+ebx*8+4], eax
  000ef	43		 inc	 ebx
  000f0	83 fb 10	 cmp	 ebx, 16			; 00000010H
  000f3	0f 8c 4c ff ff
	ff		 jl	 $LL48@RawSetKey

; 299  : 	}
; 300  : 	
; 301  : 	if (!encryption)     // reverse key schedule order

  000f9	33 ff		 xor	 edi, edi
  000fb	39 7d 08	 cmp	 DWORD PTR _encryption$[ebp], edi
  000fe	75 26		 jne	 SHORT $LN5@RawSetKey

; 302  : 		for (i=0; i<16; i+=2)

  00100	8d 46 7c	 lea	 eax, DWORD PTR [esi+124]
$LL8@RawSetKey:

; 303  : 		{
; 304  : 			word32 b = scheduledKey[i];
; 305  : 			scheduledKey[i] = scheduledKey[32-2-i];

  00103	8b 58 fc	 mov	 ebx, DWORD PTR [eax-4]
  00106	8d 14 be	 lea	 edx, DWORD PTR [esi+edi*4]
  00109	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0010b	89 1a		 mov	 DWORD PTR [edx], ebx

; 306  : 			scheduledKey[32-2-i] = b;

  0010d	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 307  : 
; 308  : 			b = scheduledKey[i+1];
; 309  : 			scheduledKey[i+1] = scheduledKey[32-1-i];

  00110	8b 18		 mov	 ebx, DWORD PTR [eax]
  00112	8d 4c be 04	 lea	 ecx, DWORD PTR [esi+edi*4+4]
  00116	8b 11		 mov	 edx, DWORD PTR [ecx]
  00118	47		 inc	 edi
  00119	89 19		 mov	 DWORD PTR [ecx], ebx

; 310  : 			scheduledKey[32-1-i] = b;

  0011b	89 10		 mov	 DWORD PTR [eax], edx
  0011d	47		 inc	 edi
  0011e	83 e8 08	 sub	 eax, 8
  00121	83 ff 10	 cmp	 edi, 16			; 00000010H
  00124	7c dd		 jl	 SHORT $LL8@RawSetKey
$LN5@RawSetKey:

; 311  : 		}
; 312  : 
; 313  : 	burn (buffer, sizeof (buffer));

  00126	6a 78		 push	 120			; 00000078H
  00128	5e		 pop	 esi
  00129	8d 4d 84	 lea	 ecx, DWORD PTR _buffer$[ebp]
  0012c	5f		 pop	 edi
  0012d	8b d6		 mov	 edx, esi
  0012f	8b c1		 mov	 eax, ecx
  00131	5b		 pop	 ebx
$LL28@RawSetKey:
  00132	c6 00 00	 mov	 BYTE PTR [eax], 0
  00135	40		 inc	 eax
  00136	4e		 dec	 esi
  00137	75 f9		 jne	 SHORT $LL28@RawSetKey
  00139	5e		 pop	 esi
$LL2@RawSetKey:
  0013a	4a		 dec	 edx
  0013b	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0013e	41		 inc	 ecx
  0013f	85 d2		 test	 edx, edx
  00141	75 f7		 jne	 SHORT $LL2@RawSetKey

; 314  : }

  00143	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00146	33 cd		 xor	 ecx, ebp
  00148	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014d	c9		 leave
  0014e	c2 08 00	 ret	 8
_RawSetKey@12 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _RawProcessBlock@12
_TEXT	SEGMENT
tv354 = -8						; size = 4
_r$ = -4						; size = 4
_l_$ = 8						; size = 4
_r_$ = 12						; size = 4
_RawProcessBlock@12 PROC				; COMDAT
; _k$ = edx

; 317  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	51		 push	 ecx

; 318  : 	word32 l = *l_, r = *r_;

  00007	8b 45 08	 mov	 eax, DWORD PTR _l_$[ebp]
  0000a	53		 push	 ebx
  0000b	56		 push	 esi
  0000c	8b 30		 mov	 esi, DWORD PTR [eax]
  0000e	8b 45 0c	 mov	 eax, DWORD PTR _r_$[ebp]
  00011	8b 00		 mov	 eax, DWORD PTR [eax]
  00013	57		 push	 edi
  00014	6a 3f		 push	 63			; 0000003fH
  00016	89 45 fc	 mov	 DWORD PTR _r$[ebp], eax
  00019	83 c2 08	 add	 edx, 8
  0001c	c7 45 f8 08 00
	00 00		 mov	 DWORD PTR tv354[ebp], 8
  00023	59		 pop	 ecx
$LL3@RawProcess:

; 319  : 	const word32 *kptr=k;
; 320  : 	unsigned i;
; 321  : 
; 322  : 	for (i=0; i<8; i++)
; 323  : 	{
; 324  : 		word32 work = rotrFixed(r, 4U) ^ kptr[4*i+0];

  00024	c1 c8 04	 ror	 eax, 4
  00027	33 42 f8	 xor	 eax, DWORD PTR [edx-8]

; 325  : 		l ^= Spbox[6][(work) & 0x3f]
; 326  : 		  ^  Spbox[4][(work >> 8) & 0x3f]
; 327  : 		  ^  Spbox[2][(work >> 16) & 0x3f]
; 328  : 		  ^  Spbox[0][(work >> 24) & 0x3f];

  0002a	8b f8		 mov	 edi, eax
  0002c	c1 ef 18	 shr	 edi, 24			; 00000018H
  0002f	23 f9		 and	 edi, ecx
  00031	8b 3c bd 00 00
	00 00		 mov	 edi, DWORD PTR _Spbox[edi*4]
  00038	8b d8		 mov	 ebx, eax
  0003a	c1 eb 10	 shr	 ebx, 16			; 00000010H
  0003d	23 d9		 and	 ebx, ecx
  0003f	33 3c 9d 00 02
	00 00		 xor	 edi, DWORD PTR _Spbox[ebx*4+512]
  00046	8b d8		 mov	 ebx, eax
  00048	c1 eb 08	 shr	 ebx, 8
  0004b	23 d9		 and	 ebx, ecx
  0004d	33 3c 9d 00 04
	00 00		 xor	 edi, DWORD PTR _Spbox[ebx*4+1024]
  00054	23 c1		 and	 eax, ecx
  00056	33 3c 85 00 06
	00 00		 xor	 edi, DWORD PTR _Spbox[eax*4+1536]

; 329  : 		work = r ^ kptr[4*i+1];

  0005d	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  00060	33 45 fc	 xor	 eax, DWORD PTR _r$[ebp]
  00063	33 f7		 xor	 esi, edi

; 330  : 		l ^= Spbox[7][(work) & 0x3f]
; 331  : 		  ^  Spbox[5][(work >> 8) & 0x3f]
; 332  : 		  ^  Spbox[3][(work >> 16) & 0x3f]
; 333  : 		  ^  Spbox[1][(work >> 24) & 0x3f];

  00065	8b f8		 mov	 edi, eax
  00067	c1 ef 18	 shr	 edi, 24			; 00000018H
  0006a	23 f9		 and	 edi, ecx
  0006c	8b 3c bd 00 01
	00 00		 mov	 edi, DWORD PTR _Spbox[edi*4+256]
  00073	8b d8		 mov	 ebx, eax
  00075	c1 eb 10	 shr	 ebx, 16			; 00000010H
  00078	23 d9		 and	 ebx, ecx
  0007a	33 3c 9d 00 03
	00 00		 xor	 edi, DWORD PTR _Spbox[ebx*4+768]
  00081	8b d8		 mov	 ebx, eax
  00083	c1 eb 08	 shr	 ebx, 8
  00086	23 d9		 and	 ebx, ecx
  00088	33 3c 9d 00 05
	00 00		 xor	 edi, DWORD PTR _Spbox[ebx*4+1280]
  0008f	23 c1		 and	 eax, ecx
  00091	33 3c 85 00 07
	00 00		 xor	 edi, DWORD PTR _Spbox[eax*4+1792]
  00098	33 f7		 xor	 esi, edi

; 334  : 
; 335  : 		work = rotrFixed(l, 4U) ^ kptr[4*i+2];

  0009a	8b c6		 mov	 eax, esi
  0009c	c1 c8 04	 ror	 eax, 4
  0009f	33 02		 xor	 eax, DWORD PTR [edx]
  000a1	83 c2 10	 add	 edx, 16			; 00000010H

; 336  : 		r ^= Spbox[6][(work) & 0x3f]
; 337  : 		  ^  Spbox[4][(work >> 8) & 0x3f]
; 338  : 		  ^  Spbox[2][(work >> 16) & 0x3f]
; 339  : 		  ^  Spbox[0][(work >> 24) & 0x3f];

  000a4	8b f8		 mov	 edi, eax
  000a6	c1 ef 18	 shr	 edi, 24			; 00000018H
  000a9	23 f9		 and	 edi, ecx
  000ab	8b 3c bd 00 00
	00 00		 mov	 edi, DWORD PTR _Spbox[edi*4]
  000b2	8b d8		 mov	 ebx, eax
  000b4	c1 eb 10	 shr	 ebx, 16			; 00000010H
  000b7	23 d9		 and	 ebx, ecx
  000b9	33 3c 9d 00 02
	00 00		 xor	 edi, DWORD PTR _Spbox[ebx*4+512]
  000c0	8b d8		 mov	 ebx, eax
  000c2	c1 eb 08	 shr	 ebx, 8
  000c5	23 d9		 and	 ebx, ecx
  000c7	33 3c 9d 00 04
	00 00		 xor	 edi, DWORD PTR _Spbox[ebx*4+1024]
  000ce	23 c1		 and	 eax, ecx
  000d0	33 3c 85 00 06
	00 00		 xor	 edi, DWORD PTR _Spbox[eax*4+1536]

; 340  : 		work = l ^ kptr[4*i+3];

  000d7	8b 42 f4	 mov	 eax, DWORD PTR [edx-12]
  000da	31 7d fc	 xor	 DWORD PTR _r$[ebp], edi
  000dd	33 c6		 xor	 eax, esi

; 341  : 		r ^= Spbox[7][(work) & 0x3f]
; 342  : 		  ^  Spbox[5][(work >> 8) & 0x3f]
; 343  : 		  ^  Spbox[3][(work >> 16) & 0x3f]
; 344  : 		  ^  Spbox[1][(work >> 24) & 0x3f];

  000df	8b f8		 mov	 edi, eax
  000e1	c1 ef 18	 shr	 edi, 24			; 00000018H
  000e4	8b d8		 mov	 ebx, eax
  000e6	23 f9		 and	 edi, ecx
  000e8	8b 3c bd 00 01
	00 00		 mov	 edi, DWORD PTR _Spbox[edi*4+256]
  000ef	c1 eb 10	 shr	 ebx, 16			; 00000010H
  000f2	23 d9		 and	 ebx, ecx
  000f4	33 3c 9d 00 03
	00 00		 xor	 edi, DWORD PTR _Spbox[ebx*4+768]
  000fb	8b d8		 mov	 ebx, eax
  000fd	c1 eb 08	 shr	 ebx, 8
  00100	23 d9		 and	 ebx, ecx
  00102	33 3c 9d 00 05
	00 00		 xor	 edi, DWORD PTR _Spbox[ebx*4+1280]
  00109	23 c1		 and	 eax, ecx
  0010b	33 3c 85 00 07
	00 00		 xor	 edi, DWORD PTR _Spbox[eax*4+1792]
  00112	8b 45 fc	 mov	 eax, DWORD PTR _r$[ebp]
  00115	33 c7		 xor	 eax, edi
  00117	ff 4d f8	 dec	 DWORD PTR tv354[ebp]
  0011a	89 45 fc	 mov	 DWORD PTR _r$[ebp], eax
  0011d	0f 85 01 ff ff
	ff		 jne	 $LL3@RawProcess

; 345  : 	}
; 346  : 
; 347  : 	*l_ = l; *r_ = r;

  00123	8b 4d 08	 mov	 ecx, DWORD PTR _l_$[ebp]
  00126	89 31		 mov	 DWORD PTR [ecx], esi
  00128	8b 4d 0c	 mov	 ecx, DWORD PTR _r_$[ebp]
  0012b	5f		 pop	 edi
  0012c	5e		 pop	 esi
  0012d	89 01		 mov	 DWORD PTR [ecx], eax
  0012f	5b		 pop	 ebx

; 348  : }

  00130	c9		 leave
  00131	c2 08 00	 ret	 8
_RawProcessBlock@12 ENDP
_TEXT	ENDS
PUBLIC	_TripleDesSetKey@12
; Function compile flags: /Ogsp
;	COMDAT _TripleDesSetKey@12
_TEXT	SEGMENT
_userKey$ = 8						; size = 4
_length$ = 12						; size = 4
_ks$ = 16						; size = 4
_TripleDesSetKey@12 PROC				; COMDAT

; 351  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	53		 push	 ebx
  00006	56		 push	 esi

; 352  : 	RawSetKey (1, userKey + 0, ks->k1);

  00007	8b 75 10	 mov	 esi, DWORD PTR _ks$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 08	 mov	 edi, DWORD PTR _userKey$[ebp]
  0000e	57		 push	 edi
  0000f	6a 01		 push	 1
  00011	8b ce		 mov	 ecx, esi
  00013	e8 00 00 00 00	 call	 _RawSetKey@12

; 353  : 	RawSetKey (1, userKey + 8, ks->k2);

  00018	8d 5f 08	 lea	 ebx, DWORD PTR [edi+8]
  0001b	53		 push	 ebx
  0001c	8d 8e 80 00 00
	00		 lea	 ecx, DWORD PTR [esi+128]
  00022	6a 01		 push	 1
  00024	e8 00 00 00 00	 call	 _RawSetKey@12

; 354  : 	RawSetKey (1, userKey + 16, ks->k3);

  00029	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
  0002c	50		 push	 eax
  0002d	8d 8e 00 01 00
	00		 lea	 ecx, DWORD PTR [esi+256]
  00033	6a 01		 push	 1
  00035	e8 00 00 00 00	 call	 _RawSetKey@12

; 355  : 	RawSetKey (0, userKey + 16, ks->k1d);

  0003a	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
  0003d	50		 push	 eax
  0003e	8d 8e 80 01 00
	00		 lea	 ecx, DWORD PTR [esi+384]
  00044	6a 00		 push	 0
  00046	e8 00 00 00 00	 call	 _RawSetKey@12

; 356  : 	RawSetKey (0, userKey + 8, ks->k2d);

  0004b	53		 push	 ebx
  0004c	8d 8e 00 02 00
	00		 lea	 ecx, DWORD PTR [esi+512]
  00052	6a 00		 push	 0
  00054	e8 00 00 00 00	 call	 _RawSetKey@12

; 357  : 	RawSetKey (0, userKey + 0, ks->k3d);

  00059	57		 push	 edi
  0005a	8d 8e 80 02 00
	00		 lea	 ecx, DWORD PTR [esi+640]
  00060	6a 00		 push	 0
  00062	e8 00 00 00 00	 call	 _RawSetKey@12
  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx

; 358  : }

  0006a	5d		 pop	 ebp
  0006b	c2 0c 00	 ret	 12			; 0000000cH
_TripleDesSetKey@12 ENDP
_TEXT	ENDS
PUBLIC	_TripleDesEncrypt@16
EXTRN	_MirrorBytes32@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _TripleDesEncrypt@16
_TEXT	SEGMENT
_left$ = -4						; size = 4
_right$ = 8						; size = 4
_inBlock$ = 8						; size = 4
_outBlock$ = 12						; size = 4
_key$ = 16						; size = 4
_encrypt$ = 20						; size = 4
_TripleDesEncrypt@16 PROC				; COMDAT

; 361  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 362  : 	word32 left = BE32 (((word32 *)inBlock)[0]);

  00009	8b 7d 08	 mov	 edi, DWORD PTR _inBlock$[ebp]
  0000c	ff 37		 push	 DWORD PTR [edi]
  0000e	e8 00 00 00 00	 call	 _MirrorBytes32@4

; 363  : 	word32 right = BE32 (((word32 *)inBlock)[1]);

  00013	ff 77 04	 push	 DWORD PTR [edi+4]
  00016	8b f0		 mov	 esi, eax
  00018	e8 00 00 00 00	 call	 _MirrorBytes32@4

; 364  : 	word32 work;
; 365  : 
; 366  : 	right = rotlFixed(right, 4U);

  0001d	c1 c0 04	 rol	 eax, 4

; 367  : 	work = (left ^ right) & 0xf0f0f0f0;

  00020	8b c8		 mov	 ecx, eax
  00022	33 ce		 xor	 ecx, esi
  00024	81 e1 f0 f0 f0
	f0		 and	 ecx, -252645136		; f0f0f0f0H

; 368  : 	left ^= work;

  0002a	33 f1		 xor	 esi, ecx

; 369  : 	right = rotrFixed(right^work, 20U);

  0002c	33 c8		 xor	 ecx, eax
  0002e	c1 c1 0c	 rol	 ecx, 12			; 0000000cH

; 370  : 	work = (left ^ right) & 0xffff0000;

  00031	8b c1		 mov	 eax, ecx
  00033	33 c6		 xor	 eax, esi
  00035	25 00 00 ff ff	 and	 eax, -65536		; ffff0000H

; 371  : 	left ^= work;

  0003a	33 f0		 xor	 esi, eax

; 372  : 	right = rotrFixed(right^work, 18U);

  0003c	33 c1		 xor	 eax, ecx
  0003e	c1 c0 0e	 rol	 eax, 14			; 0000000eH

; 373  : 	work = (left ^ right) & 0x33333333;

  00041	8b c8		 mov	 ecx, eax
  00043	33 ce		 xor	 ecx, esi
  00045	81 e1 33 33 33
	33		 and	 ecx, 858993459		; 33333333H

; 374  : 	left ^= work;

  0004b	33 f1		 xor	 esi, ecx

; 375  : 	right = rotrFixed(right^work, 6U);

  0004d	33 c8		 xor	 ecx, eax
  0004f	c1 c9 06	 ror	 ecx, 6

; 376  : 	work = (left ^ right) & 0x00ff00ff;

  00052	8b c1		 mov	 eax, ecx
  00054	33 c6		 xor	 eax, esi
  00056	bb ff 00 ff 00	 mov	 ebx, 16711935		; 00ff00ffH
  0005b	23 c3		 and	 eax, ebx

; 377  : 	left ^= work;

  0005d	33 f0		 xor	 esi, eax

; 378  : 	right = rotlFixed(right^work, 9U);

  0005f	33 c1		 xor	 eax, ecx
  00061	c1 c0 09	 rol	 eax, 9
  00064	89 45 08	 mov	 DWORD PTR _right$[ebp], eax

; 379  : 	work = (left ^ right) & 0xaaaaaaaa;

  00067	33 c6		 xor	 eax, esi
  00069	bf aa aa aa aa	 mov	 edi, -1431655766	; aaaaaaaaH
  0006e	23 c7		 and	 eax, edi

; 380  : 	left = rotlFixed(left^work, 1U);
; 381  : 	right ^= work;

  00070	31 45 08	 xor	 DWORD PTR _right$[ebp], eax
  00073	8b c8		 mov	 ecx, eax
  00075	33 ce		 xor	 ecx, esi

; 382  : 
; 383  : 	RawProcessBlock (&left, &right, encrypt ? key->k1 : key->k1d);

  00077	8b 75 10	 mov	 esi, DWORD PTR _key$[ebp]
  0007a	d1 c1		 rol	 ecx, 1
  0007c	83 7d 14 00	 cmp	 DWORD PTR _encrypt$[ebp], 0
  00080	89 4d fc	 mov	 DWORD PTR _left$[ebp], ecx
  00083	8b d6		 mov	 edx, esi
  00085	75 06		 jne	 SHORT $LN4@TripleDesE
  00087	8d 96 80 01 00
	00		 lea	 edx, DWORD PTR [esi+384]
$LN4@TripleDesE:
  0008d	8d 45 08	 lea	 eax, DWORD PTR _right$[ebp]
  00090	50		 push	 eax
  00091	8d 45 fc	 lea	 eax, DWORD PTR _left$[ebp]
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 _RawProcessBlock@12

; 384  : 	RawProcessBlock (&right, &left, !encrypt ? key->k2 : key->k2d);

  0009a	83 7d 14 00	 cmp	 DWORD PTR _encrypt$[ebp], 0
  0009e	8d 96 80 00 00
	00		 lea	 edx, DWORD PTR [esi+128]
  000a4	74 06		 je	 SHORT $LN6@TripleDesE
  000a6	8d 96 00 02 00
	00		 lea	 edx, DWORD PTR [esi+512]
$LN6@TripleDesE:
  000ac	8d 45 fc	 lea	 eax, DWORD PTR _left$[ebp]
  000af	50		 push	 eax
  000b0	8d 45 08	 lea	 eax, DWORD PTR _right$[ebp]
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 _RawProcessBlock@12

; 385  : 	RawProcessBlock (&left, &right, encrypt ? key->k3 : key->k3d);

  000b9	83 7d 14 00	 cmp	 DWORD PTR _encrypt$[ebp], 0
  000bd	8d 96 00 01 00
	00		 lea	 edx, DWORD PTR [esi+256]
  000c3	75 06		 jne	 SHORT $LN8@TripleDesE
  000c5	8d 96 80 02 00
	00		 lea	 edx, DWORD PTR [esi+640]
$LN8@TripleDesE:
  000cb	8d 45 08	 lea	 eax, DWORD PTR _right$[ebp]
  000ce	50		 push	 eax
  000cf	8d 45 fc	 lea	 eax, DWORD PTR _left$[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 _RawProcessBlock@12

; 386  : 	
; 387  : 	right = rotrFixed(right, 1U);

  000d8	8b 55 08	 mov	 edx, DWORD PTR _right$[ebp]
  000db	d1 ca		 ror	 edx, 1

; 388  : 	work = (left ^ right) & 0xaaaaaaaa;

  000dd	8b c2		 mov	 eax, edx
  000df	33 45 fc	 xor	 eax, DWORD PTR _left$[ebp]
  000e2	23 c7		 and	 eax, edi

; 389  : 	right ^= work;

  000e4	33 d0		 xor	 edx, eax

; 390  : 	left = rotrFixed(left^work, 9U);

  000e6	33 45 fc	 xor	 eax, DWORD PTR _left$[ebp]

; 391  : 	work = (left ^ right) & 0x00ff00ff;

  000e9	8b ca		 mov	 ecx, edx
  000eb	c1 c8 09	 ror	 eax, 9
  000ee	33 c8		 xor	 ecx, eax
  000f0	23 cb		 and	 ecx, ebx

; 392  : 	right ^= work;

  000f2	33 d1		 xor	 edx, ecx

; 393  : 	left = rotlFixed(left^work, 6U);

  000f4	33 c8		 xor	 ecx, eax
  000f6	c1 c1 06	 rol	 ecx, 6

; 394  : 	work = (left ^ right) & 0x33333333;

  000f9	8b c2		 mov	 eax, edx
  000fb	33 c1		 xor	 eax, ecx
  000fd	25 33 33 33 33	 and	 eax, 858993459		; 33333333H

; 395  : 	right ^= work;

  00102	33 d0		 xor	 edx, eax

; 396  : 	left = rotlFixed(left^work, 18U);

  00104	33 c1		 xor	 eax, ecx
  00106	c1 c8 0e	 ror	 eax, 14			; 0000000eH

; 397  : 	work = (left ^ right) & 0xffff0000;

  00109	8b ca		 mov	 ecx, edx
  0010b	33 c8		 xor	 ecx, eax
  0010d	81 e1 00 00 ff
	ff		 and	 ecx, -65536		; ffff0000H

; 398  : 	right ^= work;

  00113	33 d1		 xor	 edx, ecx

; 399  : 	left = rotlFixed(left^work, 20U);

  00115	33 c8		 xor	 ecx, eax
  00117	c1 c9 0c	 ror	 ecx, 12			; 0000000cH

; 400  : 	work = (left ^ right) & 0xf0f0f0f0;

  0011a	8b c2		 mov	 eax, edx
  0011c	33 c1		 xor	 eax, ecx
  0011e	25 f0 f0 f0 f0	 and	 eax, -252645136		; f0f0f0f0H

; 401  : 	right ^= work;

  00123	33 d0		 xor	 edx, eax

; 402  : 	left = rotrFixed(left^work, 4U);

  00125	33 c1		 xor	 eax, ecx
  00127	c1 c8 04	 ror	 eax, 4

; 403  : 
; 404  : 	((word32 *)outBlock)[0] = BE32 (right);

  0012a	52		 push	 edx
  0012b	8b f8		 mov	 edi, eax
  0012d	e8 00 00 00 00	 call	 _MirrorBytes32@4
  00132	8b 75 0c	 mov	 esi, DWORD PTR _outBlock$[ebp]

; 405  : 	((word32 *)outBlock)[1] = BE32 (left);

  00135	57		 push	 edi
  00136	89 06		 mov	 DWORD PTR [esi], eax
  00138	e8 00 00 00 00	 call	 _MirrorBytes32@4
  0013d	5f		 pop	 edi
  0013e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00141	5e		 pop	 esi
  00142	5b		 pop	 ebx

; 406  : }

  00143	c9		 leave
  00144	c2 10 00	 ret	 16			; 00000010H
_TripleDesEncrypt@16 ENDP
_TEXT	ENDS
END
