; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	InitializeListHead
EXTRN	__imp_KeClearEvent:PROC
EXTRN	__imp_ZwWriteFile:PROC
EXTRN	__imp_SeImpersonateClientEx:PROC
EXTRN	__imp_ZwReadFile:PROC
EXTRN	__imp_KeSetPriorityThread:PROC
EXTRN	__imp_ExInterlockedInsertTailList:PROC
EXTRN	__imp_ExInterlockedRemoveHeadList:PROC
PUBLIC	EncryptedIoQueueResumeFromHold
;	COMDAT pdata
; File c:\home\public\desktop\projects\ciphershed\src\driver\encryptedioqueue.c
pdata	SEGMENT
$pdata$EncryptedIoQueueResumeFromHold DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$EncryptedIoQueueResumeFromHold
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptedIoQueueResumeFromHold DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EncryptedIoQueueResumeFromHold
_TEXT	SEGMENT
queue$ = 48
EncryptedIoQueueResumeFromHold PROC			; COMDAT

; 858  : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 859  : 	ASSERT (queue->Suspended);
; 860  : 	
; 861  : 	queue->Suspended = FALSE;
; 862  : 	KeSetEvent (&queue->QueueResumedEvent, IO_DISK_INCREMENT, FALSE);

  00004	45 33 c0	 xor	 r8d, r8d
  00007	c7 81 38 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rcx+568], 0
  00011	48 81 c1 48 02
	00 00		 add	 rcx, 584		; 00000248H
  00018	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 863  : 
; 864  : 	return STATUS_SUCCESS;

  00022	33 c0		 xor	 eax, eax

; 865  : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	c3		 ret	 0
EncryptedIoQueueResumeFromHold ENDP
_TEXT	ENDS
PUBLIC	EncryptedIoQueueIsRunning
; Function compile flags: /Ogspy
;	COMDAT EncryptedIoQueueIsRunning
_TEXT	SEGMENT
queue$ = 8
EncryptedIoQueueIsRunning PROC				; COMDAT

; 853  : 	return !queue->StopPending;

  00000	8b 91 40 02 00
	00		 mov	 edx, DWORD PTR [rcx+576]
  00006	33 c0		 xor	 eax, eax
  00008	3b d0		 cmp	 edx, eax
  0000a	0f 94 c0	 sete	 al

; 854  : }

  0000d	c3		 ret	 0
EncryptedIoQueueIsRunning ENDP
_TEXT	ENDS
PUBLIC	EncryptedIoQueueIsSuspended
; Function compile flags: /Ogspy
;	COMDAT EncryptedIoQueueIsSuspended
_TEXT	SEGMENT
queue$ = 8
EncryptedIoQueueIsSuspended PROC			; COMDAT

; 847  : 	return queue->Suspended;

  00000	8b 81 38 02 00
	00		 mov	 eax, DWORD PTR [rcx+568]

; 848  : }

  00006	c3		 ret	 0
EncryptedIoQueueIsSuspended ENDP
_TEXT	ENDS
PUBLIC	EncryptedIoQueueHoldWhenIdle
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptedIoQueueHoldWhenIdle DD imagerel $LN18
	DD	imagerel $LN18+292
	DD	imagerel $unwind$EncryptedIoQueueHoldWhenIdle
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptedIoQueueHoldWhenIdle DD 0a1801H
	DD	0d6418H
	DD	0c5418H
	DD	0b3418H
	DD	0d0145218H
	DD	07010c012H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EncryptedIoQueueHoldWhenIdle
_TEXT	SEGMENT
waitTimeout$29753 = 80
queue$ = 80
timeout$ = 88
EncryptedIoQueueHoldWhenIdle PROC			; COMDAT

; 796  : {

$LN18:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00018	4c 8b e2	 mov	 r12, rdx
  0001b	48 8b d9	 mov	 rbx, rcx

; 797  : 	NTSTATUS status;
; 798  : 	ASSERT (!queue->Suspended);
; 799  : 
; 800  : 	queue->SuspendPending = TRUE;

  0001e	c7 81 3c 02 00
	00 01 00 00 00	 mov	 DWORD PTR [rcx+572], 1
  00028	bf 01 00 00 c0	 mov	 edi, -1073741823	; ffffffffc0000001H
$LL8@EncryptedI:

; 801  : 	
; 802  : 	while (TRUE)
; 803  : 	{
; 804  : 		while (InterlockedExchangeAdd (&queue->OutstandingIoCount, 0) > 0)

  0002d	33 c0		 xor	 eax, eax
  0002f	f0 0f c1 83 e0
	01 00 00	 lock xadd DWORD PTR [rbx+480], eax
  00037	85 c0		 test	 eax, eax
  00039	7e 6f		 jle	 SHORT $LN5@EncryptedI
  0003b	49 8b f4	 mov	 rsi, r12

; 805  : 		{
; 806  : 			LARGE_INTEGER waitTimeout;
; 807  : 
; 808  : 			waitTimeout.QuadPart = timeout * -10000;
; 809  : 			status = KeWaitForSingleObject (&queue->NoOutstandingIoEvent, Executive, KernelMode, FALSE, timeout != 0 ? &waitTimeout : NULL);

  0003e	49 8b c4	 mov	 rax, r12
  00041	48 69 f6 f0 d8
	ff ff		 imul	 rsi, -10000		; ffffffffffffd8f0H
  00048	48 f7 d8	 neg	 rax
  0004b	48 8d 44 24 50	 lea	 rax, QWORD PTR waitTimeout$29753[rsp]
  00050	48 1b ed	 sbb	 rbp, rbp
  00053	48 23 e8	 and	 rbp, rax
$LL6@EncryptedI:
  00056	48 8d 8b e8 01
	00 00		 lea	 rcx, QWORD PTR [rbx+488]
  0005d	45 33 c9	 xor	 r9d, r9d
  00060	45 33 c0	 xor	 r8d, r8d
  00063	33 d2		 xor	 edx, edx
  00065	48 89 74 24 50	 mov	 QWORD PTR waitTimeout$29753[rsp], rsi
  0006a	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 810  : 
; 811  : 			if (status == STATUS_TIMEOUT)

  00075	3d 02 01 00 00	 cmp	 eax, 258		; 00000102H
  0007a	0f 44 c7	 cmove	 eax, edi

; 812  : 				status = STATUS_UNSUCCESSFUL;
; 813  : 
; 814  : 			if (!NT_SUCCESS (status))

  0007d	85 c0		 test	 eax, eax
  0007f	78 71		 js	 SHORT $LN14@EncryptedI

; 815  : 			{
; 816  : 				queue->SuspendPending = FALSE;
; 817  : 				return status;
; 818  : 			}
; 819  : 
; 820  : 			TCSleep (1);

  00081	b9 01 00 00 00	 mov	 ecx, 1
  00086	e8 00 00 00 00	 call	 TCSleep

; 821  : 			if (InterlockedExchangeAdd (&queue->OutstandingIoCount, 0) > 0)

  0008b	45 33 db	 xor	 r11d, r11d
  0008e	f0 44 0f c1 9b
	e0 01 00 00	 lock xadd DWORD PTR [rbx+480], r11d
  00097	45 85 db	 test	 r11d, r11d
  0009a	7f 63		 jg	 SHORT $LN17@EncryptedI

; 801  : 	
; 802  : 	while (TRUE)
; 803  : 	{
; 804  : 		while (InterlockedExchangeAdd (&queue->OutstandingIoCount, 0) > 0)

  0009c	33 c0		 xor	 eax, eax
  0009e	f0 0f c1 83 e0
	01 00 00	 lock xadd DWORD PTR [rbx+480], eax
  000a6	85 c0		 test	 eax, eax
  000a8	7f ac		 jg	 SHORT $LL6@EncryptedI
$LN5@EncryptedI:

; 822  : 			{
; 823  : 				queue->SuspendPending = FALSE;
; 824  : 				return STATUS_UNSUCCESSFUL;
; 825  : 			}
; 826  : 		}
; 827  : 
; 828  : 		KeClearEvent (&queue->QueueResumedEvent);

  000aa	48 8d 8b 48 02
	00 00		 lea	 rcx, QWORD PTR [rbx+584]
  000b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeClearEvent

; 829  : 		queue->Suspended = TRUE;

  000b7	c7 83 38 02 00
	00 01 00 00 00	 mov	 DWORD PTR [rbx+568], 1

; 830  : 
; 831  : 		if (InterlockedExchangeAdd (&queue->OutstandingIoCount, 0) == 0)

  000c1	33 c0		 xor	 eax, eax
  000c3	f0 0f c1 83 e0
	01 00 00	 lock xadd DWORD PTR [rbx+480], eax
  000cb	85 c0		 test	 eax, eax
  000cd	74 27		 je	 SHORT $LN16@EncryptedI

; 832  : 			break;
; 833  : 
; 834  : 		queue->Suspended = FALSE;
; 835  : 		KeSetEvent (&queue->QueueResumedEvent, IO_DISK_INCREMENT, FALSE);

  000cf	45 33 c0	 xor	 r8d, r8d
  000d2	48 8d 8b 48 02
	00 00		 lea	 rcx, QWORD PTR [rbx+584]
  000d9	c7 83 38 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rbx+568], 0
  000e3	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  000e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 836  : 	}

  000ed	e9 3b ff ff ff	 jmp	 $LL8@EncryptedI
$LN14@EncryptedI:
  000f2	8b f8		 mov	 edi, eax
  000f4	eb 09		 jmp	 SHORT $LN17@EncryptedI
$LN16@EncryptedI:

; 837  : 
; 838  : 	queue->ReadAheadBufferValid = FALSE;

  000f6	83 a3 a8 01 00
	00 00		 and	 DWORD PTR [rbx+424], 0
  000fd	33 ff		 xor	 edi, edi
$LN17@EncryptedI:

; 839  : 
; 840  : 	queue->SuspendPending = FALSE;
; 841  : 	return STATUS_SUCCESS;
; 842  : }

  000ff	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  00104	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00109	c7 83 3c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rbx+572], 0
  00113	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00118	8b c7		 mov	 eax, edi
  0011a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0011e	41 5d		 pop	 r13
  00120	41 5c		 pop	 r12
  00122	5f		 pop	 rdi
  00123	c3		 ret	 0
EncryptedIoQueueHoldWhenIdle ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ReleaseFragmentBuffer DD imagerel ReleaseFragmentBuffer
	DD	imagerel ReleaseFragmentBuffer+91
	DD	imagerel $unwind$ReleaseFragmentBuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ReleaseFragmentBuffer DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ReleaseFragmentBuffer
_TEXT	SEGMENT
queue$ = 64
buffer$ = 72
ReleaseFragmentBuffer PROC				; COMDAT

; 208  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 209  : 	if (buffer == queue->FragmentBufferA)

  00004	48 3b 91 68 01
	00 00		 cmp	 rdx, QWORD PTR [rcx+360]
  0000b	75 09		 jne	 SHORT $LN4@ReleaseFra

; 210  : 	{
; 211  : 		KeSetEvent (&queue->FragmentBufferAFreeEvent, IO_DISK_INCREMENT, FALSE);

  0000d	48 81 c1 78 01
	00 00		 add	 rcx, 376		; 00000178H
  00014	eb 10		 jmp	 SHORT $LN8@ReleaseFra
$LN4@ReleaseFra:

; 212  : 	}
; 213  : 	else if (buffer == queue->FragmentBufferB)

  00016	48 3b 91 70 01
	00 00		 cmp	 rdx, QWORD PTR [rcx+368]
  0001d	75 19		 jne	 SHORT $LN2@ReleaseFra

; 214  : 	{
; 215  : 		KeSetEvent (&queue->FragmentBufferBFreeEvent, IO_DISK_INCREMENT, FALSE);

  0001f	48 81 c1 90 01
	00 00		 add	 rcx, 400		; 00000190H
$LN8@ReleaseFra:
  00026	45 33 c0	 xor	 r8d, r8d
  00029	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]

; 220  : 	}
; 221  : }

  0002d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00031	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_KeSetEvent
$LN2@ReleaseFra:

; 216  : 	}
; 217  : 	else
; 218  : 	{
; 219  : 		TC_BUG_CHECK (STATUS_INVALID_PARAMETER);

  00038	45 33 c9	 xor	 r9d, r9d
  0003b	ba db 00 00 00	 mov	 edx, 219		; 000000dbH
  00040	49 c7 c0 0d 00
	00 c0		 mov	 r8, -1073741811		; ffffffffc000000dH
  00047	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  0004b	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  0005a	cc		 int	 3
$LN7@ReleaseFra:
ReleaseFragmentBuffer ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcquireFragmentBuffer DD imagerel AcquireFragmentBuffer
	DD	imagerel AcquireFragmentBuffer+103
	DD	imagerel $unwind$AcquireFragmentBuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcquireFragmentBuffer DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT AcquireFragmentBuffer
_TEXT	SEGMENT
queue$ = 64
buffer$ = 72
AcquireFragmentBuffer PROC				; COMDAT

; 190  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 191  : 	NTSTATUS status = STATUS_INVALID_PARAMETER;

  00004	b8 0d 00 00 c0	 mov	 eax, -1073741811	; ffffffffc000000dH

; 192  : 
; 193  : 	if (buffer == queue->FragmentBufferA)

  00009	48 3b 91 68 01
	00 00		 cmp	 rdx, QWORD PTR [rcx+360]
  00010	75 09		 jne	 SHORT $LN4@AcquireFra

; 194  : 	{
; 195  : 		status = KeWaitForSingleObject (&queue->FragmentBufferAFreeEvent, Executive, KernelMode, FALSE, NULL);

  00012	48 81 c1 78 01
	00 00		 add	 rcx, 376		; 00000178H
  00019	eb 10		 jmp	 SHORT $LN9@AcquireFra
$LN4@AcquireFra:

; 196  : 	}
; 197  : 	else if (buffer == queue->FragmentBufferB)

  0001b	48 3b 91 70 01
	00 00		 cmp	 rdx, QWORD PTR [rcx+368]
  00022	75 1f		 jne	 SHORT $LN7@AcquireFra

; 198  : 	{
; 199  : 		status = KeWaitForSingleObject (&queue->FragmentBufferBFreeEvent, Executive, KernelMode, FALSE, NULL);

  00024	48 81 c1 90 01
	00 00		 add	 rcx, 400		; 00000190H
$LN9@AcquireFra:
  0002b	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00031	45 33 c9	 xor	 r9d, r9d
  00034	45 33 c0	 xor	 r8d, r8d
  00037	33 d2		 xor	 edx, edx
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 200  : 	}
; 201  : 
; 202  : 	if (!NT_SUCCESS (status))

  0003f	85 c0		 test	 eax, eax
  00041	79 1f		 jns	 SHORT $LN1@AcquireFra
$LN7@AcquireFra:

; 203  : 		TC_BUG_CHECK (status);

  00043	45 33 c9	 xor	 r9d, r9d
  00046	4c 63 c0	 movsxd	 r8, eax
  00049	ba cb 00 00 00	 mov	 edx, 203		; 000000cbH
  0004e	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00052	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00061	cc		 int	 3
$LN1@AcquireFra:

; 204  : }

  00062	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00066	c3		 ret	 0
$LN8@AcquireFra:
AcquireFragmentBuffer ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DecrementOutstandingIoCount DD imagerel DecrementOutstandingIoCount
	DD	imagerel DecrementOutstandingIoCount+59
	DD	imagerel $unwind$DecrementOutstandingIoCount
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecrementOutstandingIoCount DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT DecrementOutstandingIoCount
_TEXT	SEGMENT
queue$ = 48
DecrementOutstandingIoCount PROC			; COMDAT

; 150  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 151  : 	if (InterlockedDecrement (&queue->OutstandingIoCount) == 0 && (queue->SuspendPending || queue->StopPending))

  00004	f0 83 81 e0 01
	00 00 ff	 lock add DWORD PTR [rcx+480], -1
  0000c	75 28		 jne	 SHORT $LN2@DecrementO
  0000e	8b 81 3c 02 00
	00		 mov	 eax, DWORD PTR [rcx+572]
  00014	85 c0		 test	 eax, eax
  00016	75 0a		 jne	 SHORT $LN1@DecrementO
  00018	8b 81 40 02 00
	00		 mov	 eax, DWORD PTR [rcx+576]
  0001e	85 c0		 test	 eax, eax
  00020	74 14		 je	 SHORT $LN2@DecrementO
$LN1@DecrementO:

; 152  : 		KeSetEvent (&queue->NoOutstandingIoEvent, IO_DISK_INCREMENT, FALSE);

  00022	45 33 c0	 xor	 r8d, r8d
  00025	48 81 c1 e8 01
	00 00		 add	 rcx, 488		; 000001e8H
  0002c	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent
$LN2@DecrementO:

; 153  : }

  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
DecrementOutstandingIoCount ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT ReleaseBufferPoolMutex
_TEXT	SEGMENT
queue$ = 8
ReleaseBufferPoolMutex PROC				; COMDAT

; 30   : 	KeReleaseMutex (&queue->BufferPoolMutex, FALSE);

  00000	48 83 c1 08	 add	 rcx, 8
  00004	33 d2		 xor	 edx, edx

; 31   : }

  00006	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_KeReleaseMutex
ReleaseBufferPoolMutex ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcquireBufferPoolMutex DD imagerel AcquireBufferPoolMutex
	DD	imagerel AcquireBufferPoolMutex+66
	DD	imagerel $unwind$AcquireBufferPoolMutex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcquireBufferPoolMutex DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT AcquireBufferPoolMutex
_TEXT	SEGMENT
queue$ = 64
AcquireBufferPoolMutex PROC				; COMDAT

; 19   : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 20   : 	NTSTATUS status;
; 21   : 
; 22   : 	status = KeWaitForMutexObject (&queue->BufferPoolMutex, Executive, KernelMode, FALSE, NULL);

  00004	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  0000a	48 83 c1 08	 add	 rcx, 8
  0000e	45 33 c9	 xor	 r9d, r9d
  00011	45 33 c0	 xor	 r8d, r8d
  00014	33 d2		 xor	 edx, edx
  00016	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 23   : 	if (!NT_SUCCESS (status))

  0001c	85 c0		 test	 eax, eax
  0001e	79 1d		 jns	 SHORT $LN1@AcquireBuf

; 24   : 		TC_BUG_CHECK (status);

  00020	45 33 c9	 xor	 r9d, r9d
  00023	4c 63 c0	 movsxd	 r8, eax
  00026	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  0002f	41 8d 51 18	 lea	 edx, QWORD PTR [r9+24]
  00033	8d 4a 11	 lea	 ecx, QWORD PTR [rdx+17]
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  0003c	cc		 int	 3
$LN1@AcquireBuf:

; 25   : }

  0003d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00041	c3		 ret	 0
$LN4@AcquireBuf:
AcquireBufferPoolMutex ENDP
; Function compile flags: /Ogspy
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT InitializeListHead
_TEXT	SEGMENT
ListHead$ = 8
InitializeListHead PROC					; COMDAT

; 7551 :     ListHead->Flink = ListHead->Blink = ListHead;

  00000	48 89 49 08	 mov	 QWORD PTR [rcx+8], rcx
  00004	48 89 09	 mov	 QWORD PTR [rcx], rcx

; 7552 : }

  00007	c3		 ret	 0
InitializeListHead ENDP
;	COMDAT pdata
; File c:\home\public\desktop\projects\ciphershed\src\driver\ntdriver.c
pdata	SEGMENT
$pdata$TCCachedRead DD imagerel TCCachedRead
	DD	imagerel TCCachedRead+200
	DD	imagerel $unwind$TCCachedRead
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCCachedRead DD 061401H
	DD	0d6414H
	DD	0c3414H
	DD	070109214H
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed\src\driver\encryptedioqueue.c
xdata	ENDS
;	COMDAT TCCachedRead
_TEXT	SEGMENT
queue$ = 96
ioStatus$ = 104
buffer$ = 112
offset$ = 120
length$ = 128
TCCachedRead PROC					; COMDAT

; 274  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0000f	57		 push	 rdi
  00010	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 275  : 	queue->LastReadOffset = offset;
; 276  : 	queue->LastReadLength = length;
; 277  : 
; 278  : 	if (queue->ReadAheadBufferValid && queue->ReadAheadOffset.QuadPart == offset.QuadPart && queue->ReadAheadLength >= length)

  00014	83 b9 a8 01 00
	00 00		 cmp	 DWORD PTR [rcx+424], 0
  0001b	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR length$[rsp]
  00022	4d 8b d0	 mov	 r10, r8
  00025	48 8b fa	 mov	 rdi, rdx
  00028	48 8b d9	 mov	 rbx, rcx
  0002b	4c 89 89 b0 01
	00 00		 mov	 QWORD PTR [rcx+432], r9
  00032	89 81 b8 01 00
	00		 mov	 DWORD PTR [rcx+440], eax
  00038	74 37		 je	 SHORT $LN3@TCCachedRe
  0003a	4c 39 89 c0 01
	00 00		 cmp	 QWORD PTR [rcx+448], r9
  00041	75 2e		 jne	 SHORT $LN3@TCCachedRe
  00043	39 81 c8 01 00
	00		 cmp	 DWORD PTR [rcx+456], eax
  00049	72 26		 jb	 SHORT $LN3@TCCachedRe

; 279  : 	{
; 280  : 		memcpy (buffer, queue->ReadAheadBuffer, length);

  0004b	48 8b 91 d0 01
	00 00		 mov	 rdx, QWORD PTR [rcx+464]
  00052	4c 8b c0	 mov	 r8, rax
  00055	49 8b ca	 mov	 rcx, r10
  00058	48 8b f0	 mov	 rsi, rax
  0005b	e8 00 00 00 00	 call	 memcpy

; 281  : 
; 282  : 		if (!queue->IsFilterDevice)

  00060	83 7b 68 00	 cmp	 DWORD PTR [rbx+104], 0
  00064	75 07		 jne	 SHORT $LN2@TCCachedRe

; 283  : 		{
; 284  : 			ioStatus->Information = length;
; 285  : 			ioStatus->Status = STATUS_SUCCESS;

  00066	83 27 00	 and	 DWORD PTR [rdi], 0
  00069	48 89 77 08	 mov	 QWORD PTR [rdi+8], rsi
$LN2@TCCachedRe:

; 286  : 		}
; 287  : 
; 288  : 		return STATUS_SUCCESS;

  0006d	33 c0		 xor	 eax, eax
  0006f	eb 47		 jmp	 SHORT $LN4@TCCachedRe
$LN3@TCCachedRe:

; 289  : 	}
; 290  : 
; 291  : 	if (queue->IsFilterDevice)

  00071	83 79 68 00	 cmp	 DWORD PTR [rcx+104], 0
  00075	74 11		 je	 SHORT $LN1@TCCachedRe

; 292  : 		return TCReadDevice (queue->LowerDeviceObject, buffer, offset, length);

  00077	48 8b 51 70	 mov	 rdx, QWORD PTR [rcx+112]
  0007b	33 c9		 xor	 ecx, ecx
  0007d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00081	e8 00 00 00 00	 call	 TCReadWriteDevice
  00086	eb 30		 jmp	 SHORT $LN4@TCCachedRe
$LN1@TCCachedRe:

; 293  : 
; 294  : 	return ZwReadFile (queue->HostFileHandle, NULL, NULL, NULL, ioStatus, buffer, length, &offset, NULL);

  00088	48 83 64 24 40
	00		 and	 QWORD PTR [rsp+64], 0
  0008e	48 8d 4c 24 78	 lea	 rcx, QWORD PTR offset$[rsp]
  00093	45 33 c9	 xor	 r9d, r9d
  00096	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0009b	48 8b 4b 50	 mov	 rcx, QWORD PTR [rbx+80]
  0009f	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000a3	4c 89 44 24 28	 mov	 QWORD PTR [rsp+40], r8
  000a8	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  000ad	33 d2		 xor	 edx, edx
  000af	45 33 c0	 xor	 r8d, r8d
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwReadFile
$LN4@TCCachedRe:

; 295  : }

  000b8	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000bd	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  000c2	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000c6	5f		 pop	 rdi
  000c7	c3		 ret	 0
TCCachedRead ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$FreePoolBuffers DD imagerel FreePoolBuffers
	DD	imagerel FreePoolBuffers+105
	DD	imagerel $unwind$FreePoolBuffers
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$FreePoolBuffers DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT FreePoolBuffers
_TEXT	SEGMENT
queue$ = 48
FreePoolBuffers PROC					; COMDAT

; 128  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f9	 mov	 rdi, rcx

; 129  : 	EncryptedIoQueueBuffer *buffer;
; 130  : 	AcquireBufferPoolMutex (queue);

  00012	e8 00 00 00 00	 call	 AcquireBufferPoolMutex

; 131  : 
; 132  : 	for (buffer = queue->FirstPoolBuffer; buffer != NULL; )

  00017	48 8b 77 40	 mov	 rsi, QWORD PTR [rdi+64]
  0001b	48 85 f6	 test	 rsi, rsi
  0001e	74 28		 je	 SHORT $LN1@FreePoolBu@2
$LL2@FreePoolBu@2:

; 133  : 	{
; 134  : 		EncryptedIoQueueBuffer *nextBuffer = buffer->NextBuffer;
; 135  : 
; 136  : 		ASSERT (!buffer->InUse || queue->StartPending);
; 137  : 
; 138  : 		TCfree (buffer->Address);

  00020	48 8b 4e 08	 mov	 rcx, QWORD PTR [rsi+8]
  00024	48 8b 1e	 mov	 rbx, QWORD PTR [rsi]
  00027	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 139  : 		TCfree (buffer);

  00032	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00037	48 8b ce	 mov	 rcx, rsi
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 140  : 
; 141  : 		buffer = nextBuffer;

  00040	48 8b f3	 mov	 rsi, rbx
  00043	48 85 db	 test	 rbx, rbx
  00046	75 d8		 jne	 SHORT $LL2@FreePoolBu@2
$LN1@FreePoolBu@2:

; 142  : 	}
; 143  : 
; 144  : 	queue->FirstPoolBuffer = NULL;

  00048	48 83 67 40 00	 and	 QWORD PTR [rdi+64], 0

; 145  : 	ReleaseBufferPoolMutex (queue);

  0004d	48 8d 4f 08	 lea	 rcx, QWORD PTR [rdi+8]
  00051	33 d2		 xor	 edx, edx

; 146  : }

  00053	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00058	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00061	5f		 pop	 rdi
  00062	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_KeReleaseMutex
FreePoolBuffers ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ReleasePoolBuffer DD imagerel ReleasePoolBuffer
	DD	imagerel ReleasePoolBuffer+91
	DD	imagerel $unwind$ReleasePoolBuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ReleasePoolBuffer DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ReleasePoolBuffer
_TEXT	SEGMENT
queue$ = 48
address$ = 56
ReleasePoolBuffer PROC					; COMDAT

; 107  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 108  : 	EncryptedIoQueueBuffer *buffer;
; 109  : 	AcquireBufferPoolMutex (queue);

  00010	e8 00 00 00 00	 call	 AcquireBufferPoolMutex

; 110  : 	
; 111  : 	for (buffer = queue->FirstPoolBuffer; buffer != NULL; buffer = buffer->NextBuffer)

  00015	4c 8b 5b 40	 mov	 r11, QWORD PTR [rbx+64]
  00019	eb 09		 jmp	 SHORT $LN12@ReleasePoo
$LL4@ReleasePoo:

; 112  : 	{
; 113  : 		if (buffer->Address == address)

  0001b	49 39 7b 08	 cmp	 QWORD PTR [r11+8], rdi
  0001f	74 0a		 je	 SHORT $LN10@ReleasePoo

; 110  : 	
; 111  : 	for (buffer = queue->FirstPoolBuffer; buffer != NULL; buffer = buffer->NextBuffer)

  00021	4d 8b 1b	 mov	 r11, QWORD PTR [r11]
$LN12@ReleasePoo:
  00024	4d 85 db	 test	 r11, r11
  00027	75 f2		 jne	 SHORT $LL4@ReleasePoo

; 112  : 	{
; 113  : 		if (buffer->Address == address)

  00029	eb 05		 jmp	 SHORT $LN2@ReleasePoo
$LN10@ReleasePoo:

; 114  : 		{
; 115  : 			ASSERT (buffer->InUse);
; 116  : 
; 117  : 			buffer->InUse = FALSE;

  0002b	41 83 63 14 00	 and	 DWORD PTR [r11+20], 0
$LN2@ReleasePoo:

; 118  : 			break;
; 119  : 		}
; 120  : 	}
; 121  : 
; 122  : 	ReleaseBufferPoolMutex (queue);

  00030	48 8d 4b 08	 lea	 rcx, QWORD PTR [rbx+8]
  00034	33 d2		 xor	 edx, edx
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseMutex

; 123  : 	KeSetEvent (&queue->PoolBufferFreeEvent, IO_DISK_INCREMENT, FALSE);

  0003c	45 33 c0	 xor	 r8d, r8d
  0003f	48 8d 8b 08 02
	00 00		 lea	 rcx, QWORD PTR [rbx+520]
  00046	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]

; 124  : }

  0004a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00053	5f		 pop	 rdi
  00054	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_KeSetEvent
ReleasePoolBuffer ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetPoolBuffer DD imagerel GetPoolBuffer
	DD	imagerel GetPoolBuffer+316
	DD	imagerel $unwind$GetPoolBuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetPoolBuffer DD 0c1d01H
	DD	0d741dH
	DD	0c641dH
	DD	0b541dH
	DD	0a341dH
	DD	0e019521dH
	DD	0c015d017H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GetPoolBuffer
_TEXT	SEGMENT
queue$ = 80
requestedSize$ = 88
GetPoolBuffer PROC					; COMDAT

; 35   : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 54		 push	 r12
  00015	41 55		 push	 r13
  00017	41 56		 push	 r14
  00019	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 36   : 	EncryptedIoQueueBuffer *buffer;
; 37   : 	void *bufferAddress = NULL;

  0001d	33 f6		 xor	 esi, esi
  0001f	44 8b ea	 mov	 r13d, edx
  00022	48 8b e9	 mov	 rbp, rcx

; 38   : 	BOOL requestedSizePresentInPool = FALSE;

  00025	45 33 e4	 xor	 r12d, r12d
$LL17@GetPoolBuf:

; 39   : 
; 40   : 	while (TRUE)
; 41   : 	{
; 42   : 		AcquireBufferPoolMutex (queue);

  00028	48 8b cd	 mov	 rcx, rbp
  0002b	e8 00 00 00 00	 call	 AcquireBufferPoolMutex

; 43   : 
; 44   : 		for (buffer = queue->FirstPoolBuffer; ; buffer = buffer->NextBuffer)

  00030	48 8b 5d 40	 mov	 rbx, QWORD PTR [rbp+64]
$LL15@GetPoolBuf:

; 45   : 		{
; 46   : 			if (buffer && buffer->Size == requestedSize)

  00034	48 85 db	 test	 rbx, rbx
  00037	74 29		 je	 SHORT $LN25@GetPoolBuf
  00039	44 39 6b 10	 cmp	 DWORD PTR [rbx+16], r13d
  0003d	75 0c		 jne	 SHORT $LN11@GetPoolBuf

; 47   : 			{
; 48   : 				requestedSizePresentInPool = TRUE;
; 49   : 
; 50   : 				if (!buffer->InUse)

  0003f	83 7b 14 00	 cmp	 DWORD PTR [rbx+20], 0
  00043	41 bc 01 00 00
	00		 mov	 r12d, 1
  00049	74 0d		 je	 SHORT $LN24@GetPoolBuf
$LN11@GetPoolBuf:

; 56   : 				}
; 57   : 			}
; 58   : 
; 59   : 			if (!buffer || !buffer->NextBuffer)

  0004b	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0004e	48 85 c0	 test	 rax, rax
  00051	74 0f		 je	 SHORT $LN25@GetPoolBuf

; 43   : 
; 44   : 		for (buffer = queue->FirstPoolBuffer; ; buffer = buffer->NextBuffer)

  00053	48 8b d8	 mov	 rbx, rax
  00056	eb dc		 jmp	 SHORT $LL15@GetPoolBuf
$LN24@GetPoolBuf:

; 51   : 				{
; 52   : 					// Reuse a free buffer
; 53   : 					buffer->InUse = TRUE;
; 54   : 					bufferAddress = buffer->Address;

  00058	48 8b 73 08	 mov	 rsi, QWORD PTR [rbx+8]
  0005c	44 89 63 14	 mov	 DWORD PTR [rbx+20], r12d

; 55   : 					break;

  00060	eb 78		 jmp	 SHORT $LN3@GetPoolBuf
$LN25@GetPoolBuf:

; 60   : 			{
; 61   : 				EncryptedIoQueueBuffer *newBuffer;
; 62   : 
; 63   : 				if (requestedSizePresentInPool && !queue->StartPending)

  00062	45 85 e4	 test	 r12d, r12d
  00065	74 0a		 je	 SHORT $LN8@GetPoolBuf
  00067	8b 85 30 02 00
	00		 mov	 eax, DWORD PTR [rbp+560]
  0006d	85 c0		 test	 eax, eax
  0006f	74 69		 je	 SHORT $LN3@GetPoolBuf
$LN8@GetPoolBuf:

; 64   : 					break;
; 65   : 
; 66   : 				// Allocate a new buffer
; 67   : 				newBuffer = TCalloc (sizeof (EncryptedIoQueueBuffer));

  00071	ba 18 00 00 00	 mov	 edx, 24
  00076	33 c9		 xor	 ecx, ecx
  00078	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00084	48 8b f8	 mov	 rdi, rax

; 68   : 				if (!newBuffer)

  00087	48 85 c0	 test	 rax, rax
  0008a	75 04		 jne	 SHORT $LN7@GetPoolBuf

; 69   : 				{
; 70   : 					bufferAddress = NULL;

  0008c	33 f6		 xor	 esi, esi

; 71   : 					break;

  0008e	eb 4a		 jmp	 SHORT $LN3@GetPoolBuf
$LN7@GetPoolBuf:

; 72   : 				}
; 73   : 
; 74   : 				bufferAddress = TCalloc (requestedSize);

  00090	49 8b d5	 mov	 rdx, r13
  00093	33 c9		 xor	 ecx, ecx
  00095	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  000a1	48 8b f0	 mov	 rsi, rax

; 75   : 				if (bufferAddress)

  000a4	48 85 c0	 test	 rax, rax
  000a7	74 23		 je	 SHORT $LN6@GetPoolBuf

; 76   : 				{
; 77   : 					newBuffer->NextBuffer = NULL;

  000a9	48 83 27 00	 and	 QWORD PTR [rdi], 0

; 78   : 					newBuffer->Address = bufferAddress;

  000ad	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax

; 79   : 					newBuffer->Size = requestedSize;

  000b1	44 89 6f 10	 mov	 DWORD PTR [rdi+16], r13d

; 80   : 					newBuffer->InUse = TRUE;

  000b5	c7 47 14 01 00
	00 00		 mov	 DWORD PTR [rdi+20], 1

; 81   : 
; 82   : 					if (!buffer)

  000bc	48 85 db	 test	 rbx, rbx
  000bf	75 06		 jne	 SHORT $LN5@GetPoolBuf

; 83   : 						queue->FirstPoolBuffer = newBuffer;

  000c1	48 89 7d 40	 mov	 QWORD PTR [rbp+64], rdi

; 84   : 					else

  000c5	eb 13		 jmp	 SHORT $LN3@GetPoolBuf
$LN5@GetPoolBuf:

; 85   : 						buffer->NextBuffer = newBuffer;

  000c7	48 89 3b	 mov	 QWORD PTR [rbx], rdi

; 86   : 				}
; 87   : 				else

  000ca	eb 0e		 jmp	 SHORT $LN3@GetPoolBuf
$LN6@GetPoolBuf:

; 88   : 					TCfree (newBuffer);

  000cc	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  000d1	48 8b cf	 mov	 rcx, rdi
  000d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN3@GetPoolBuf:

; 89   : 
; 90   : 				break;
; 91   : 			}
; 92   : 		}
; 93   : 
; 94   : 		ReleaseBufferPoolMutex (queue);

  000da	48 8d 4d 08	 lea	 rcx, QWORD PTR [rbp+8]
  000de	33 d2		 xor	 edx, edx
  000e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseMutex

; 95   : 
; 96   : 		if (bufferAddress || !requestedSizePresentInPool || queue->StartPending)

  000e6	48 85 f6	 test	 rsi, rsi
  000e9	75 2f		 jne	 SHORT $LN26@GetPoolBuf
  000eb	45 85 e4	 test	 r12d, r12d
  000ee	74 2a		 je	 SHORT $LN26@GetPoolBuf
  000f0	8b 85 30 02 00
	00		 mov	 eax, DWORD PTR [rbp+560]
  000f6	85 c0		 test	 eax, eax
  000f8	75 20		 jne	 SHORT $LN26@GetPoolBuf

; 97   : 			break;
; 98   : 
; 99   : 		KeWaitForSingleObject (&queue->PoolBufferFreeEvent, Executive, KernelMode, FALSE, NULL);

  000fa	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00100	48 8d 8d 08 02
	00 00		 lea	 rcx, QWORD PTR [rbp+520]
  00107	45 33 c9	 xor	 r9d, r9d
  0010a	45 33 c0	 xor	 r8d, r8d
  0010d	33 d2		 xor	 edx, edx
  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 100  : 	}

  00115	e9 0e ff ff ff	 jmp	 $LL17@GetPoolBuf
$LN26@GetPoolBuf:

; 101  : 
; 102  : 	return bufferAddress;
; 103  : }

  0011a	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0011f	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00124	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  00129	48 8b c6	 mov	 rax, rsi
  0012c	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00131	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00135	41 5e		 pop	 r14
  00137	41 5d		 pop	 r13
  00139	41 5c		 pop	 r12
  0013b	c3		 ret	 0
GetPoolBuffer ENDP
PUBLIC	EncryptedIoQueueStop
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptedIoQueueStop DD imagerel $LN7
	DD	imagerel $LN7+219
	DD	imagerel $unwind$EncryptedIoQueueStop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptedIoQueueStop DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EncryptedIoQueueStop
_TEXT	SEGMENT
queue$ = 64
EncryptedIoQueueStop PROC				; COMDAT

; 983  : {

$LN7:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b d9	 mov	 rbx, rcx

; 984  : 	ASSERT (!queue->StopPending);
; 985  : 	queue->StopPending = TRUE;

  0000d	c7 81 40 02 00
	00 01 00 00 00	 mov	 DWORD PTR [rcx+576], 1

; 986  : 	
; 987  : 	while (InterlockedExchangeAdd (&queue->OutstandingIoCount, 0) > 0)

  00017	33 c0		 xor	 eax, eax
  00019	f0 0f c1 81 e0
	01 00 00	 lock xadd DWORD PTR [rcx+480], eax
  00021	85 c0		 test	 eax, eax
  00023	7e 2c		 jle	 SHORT $LN1@EncryptedI@2
$LL2@EncryptedI@2:

; 988  : 	{
; 989  : 		KeWaitForSingleObject (&queue->NoOutstandingIoEvent, Executive, KernelMode, FALSE, NULL);

  00025	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  0002b	48 8d 8b e8 01
	00 00		 lea	 rcx, QWORD PTR [rbx+488]
  00032	45 33 c9	 xor	 r9d, r9d
  00035	45 33 c0	 xor	 r8d, r8d
  00038	33 d2		 xor	 edx, edx
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  00040	45 33 db	 xor	 r11d, r11d

; 986  : 	
; 987  : 	while (InterlockedExchangeAdd (&queue->OutstandingIoCount, 0) > 0)

  00043	f0 44 0f c1 9b
	e0 01 00 00	 lock xadd DWORD PTR [rbx+480], r11d
  0004c	45 85 db	 test	 r11d, r11d
  0004f	7f d4		 jg	 SHORT $LL2@EncryptedI@2
$LN1@EncryptedI@2:

; 990  : 	}
; 991  : 
; 992  : 	Dump ("Queue stopping  out=%d\n", queue->OutstandingIoCount);
; 993  : 
; 994  : 	queue->ThreadExitRequested = TRUE;
; 995  : 
; 996  : 	TCStopThread (queue->MainThread, &queue->MainThreadQueueNotEmptyEvent);

  00051	48 8b 8b c0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+192]
  00058	48 8d 93 e0 00
	00 00		 lea	 rdx, QWORD PTR [rbx+224]
  0005f	c7 83 34 02 00
	00 01 00 00 00	 mov	 DWORD PTR [rbx+564], 1
  00069	e8 00 00 00 00	 call	 TCStopThread

; 997  : 	TCStopThread (queue->IoThread, &queue->IoThreadQueueNotEmptyEvent);

  0006e	48 8b 8b f8 00
	00 00		 mov	 rcx, QWORD PTR [rbx+248]
  00075	48 8d 93 18 01
	00 00		 lea	 rdx, QWORD PTR [rbx+280]
  0007c	e8 00 00 00 00	 call	 TCStopThread

; 998  : 	TCStopThread (queue->CompletionThread, &queue->CompletionThreadQueueNotEmptyEvent);

  00081	48 8b 8b 30 01
	00 00		 mov	 rcx, QWORD PTR [rbx+304]
  00088	48 8d 93 50 01
	00 00		 lea	 rdx, QWORD PTR [rbx+336]
  0008f	e8 00 00 00 00	 call	 TCStopThread

; 999  : 
; 1000 : 	TCfree (queue->FragmentBufferA);

  00094	48 8b 8b 68 01
	00 00		 mov	 rcx, QWORD PTR [rbx+360]
  0009b	bf 54 43 4d 4d	 mov	 edi, 1296909140		; 4d4d4354H
  000a0	8b d7		 mov	 edx, edi
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 1001 : 	TCfree (queue->FragmentBufferB);

  000a8	48 8b 8b 70 01
	00 00		 mov	 rcx, QWORD PTR [rbx+368]
  000af	8b d7		 mov	 edx, edi
  000b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 1002 : 	TCfree (queue->ReadAheadBuffer);

  000b7	48 8b 8b d0 01
	00 00		 mov	 rcx, QWORD PTR [rbx+464]
  000be	8b d7		 mov	 edx, edi
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 1003 : 
; 1004 : 	FreePoolBuffers (queue);

  000c6	48 8b cb	 mov	 rcx, rbx
  000c9	e8 00 00 00 00	 call	 FreePoolBuffers

; 1005 : 
; 1006 : 	Dump ("Queue stopped  out=%d\n", queue->OutstandingIoCount);
; 1007 : 	return STATUS_SUCCESS;
; 1008 : }

  000ce	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d3	33 c0		 xor	 eax, eax
  000d5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d9	5f		 pop	 rdi
  000da	c3		 ret	 0
EncryptedIoQueueStop ENDP
_TEXT	ENDS
PUBLIC	EncryptedIoQueueAddIrp
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$EncryptedIoQueueAddIrp DD imagerel $LN9
	DD	imagerel $LN9+177
	DD	imagerel $unwind$EncryptedIoQueueAddIrp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptedIoQueueAddIrp DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed\src\driver\encryptedioqueue.c
xdata	ENDS
;	COMDAT EncryptedIoQueueAddIrp
_TEXT	SEGMENT
queue$ = 64
irp$ = 72
EncryptedIoQueueAddIrp PROC				; COMDAT

; 760  : {

$LN9:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b f2	 mov	 rsi, rdx
  00012	48 8b d9	 mov	 rbx, rcx

; 761  : 	NTSTATUS status;
; 762  : 
; 763  : 	InterlockedIncrement (&queue->OutstandingIoCount);

  00015	f0 83 81 e0 01
	00 00 01	 lock add DWORD PTR [rcx+480], 1

; 764  : 	if (queue->StopPending)

  0001d	8b 81 40 02 00
	00		 mov	 eax, DWORD PTR [rcx+576]
  00023	85 c0		 test	 eax, eax
  00025	74 07		 je	 SHORT $LN2@EncryptedI@3

; 765  : 	{
; 766  : 		Dump ("STATUS_DEVICE_NOT_READY  out=%d\n", queue->OutstandingIoCount);
; 767  : 		status = STATUS_DEVICE_NOT_READY;

  00027	bf a3 00 00 c0	 mov	 edi, -1073741661	; ffffffffc00000a3H

; 768  : 		goto err;

  0002c	eb 28		 jmp	 SHORT $err$29733
$LN2@EncryptedI@3:

; 769  : 	}
; 770  : 
; 771  : 	status = IoAcquireRemoveLock (&queue->RemoveLock, irp);

  0002e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@FNODOBFM@
  00035	48 81 c1 a0 00
	00 00		 add	 rcx, 160		; 000000a0H
  0003c	41 b9 01 00 00
	00		 mov	 r9d, 1
  00042	c7 44 24 20 20
	00 00 00	 mov	 DWORD PTR [rsp+32], 32	; 00000020H
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAcquireRemoveLockEx
  00050	8b f8		 mov	 edi, eax

; 772  : 	if (!NT_SUCCESS (status))

  00052	85 c0		 test	 eax, eax
  00054	79 0c		 jns	 SHORT $LN1@EncryptedI@3
$err$29733:

; 788  : 
; 789  : err:
; 790  : 	DecrementOutstandingIoCount (queue);

  00056	48 8b cb	 mov	 rcx, rbx
  00059	e8 00 00 00 00	 call	 DecrementOutstandingIoCount

; 791  : 	return status;

  0005e	8b c7		 mov	 eax, edi
  00060	eb 3f		 jmp	 SHORT $LN3@EncryptedI@3
$LN1@EncryptedI@3:

; 773  : 		goto err;
; 774  : 
; 775  : #ifdef TC_TRACE_IO_QUEUE
; 776  : 	{
; 777  : 		PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (irp);
; 778  : 		Dump ("* %I64d [%I64d] %c len=%d out=%d\n", irpSp->MajorFunction == IRP_MJ_WRITE ? irpSp->Parameters.Write.ByteOffset : irpSp->Parameters.Read.ByteOffset, GetElapsedTime (&queue->LastPerformanceCounter), irpSp->MajorFunction == IRP_MJ_WRITE ? 'W' : 'R', irpSp->MajorFunction == IRP_MJ_WRITE ? irpSp->Parameters.Write.Length : irpSp->Parameters.Read.Length, queue->OutstandingIoCount);
; 779  : 	}
; 780  : #endif
; 781  : 
; 782  : 	IoMarkIrpPending (irp);

  00062	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]

; 783  : 
; 784  : 	ExInterlockedInsertTailList (&queue->MainThreadQueue, &irp->Tail.Overlay.ListEntry, &queue->MainThreadQueueLock);

  00069	4c 8d 83 d8 00
	00 00		 lea	 r8, QWORD PTR [rbx+216]
  00070	48 8d 96 a8 00
	00 00		 lea	 rdx, QWORD PTR [rsi+168]
  00077	80 48 03 01	 or	 BYTE PTR [rax+3], 1
  0007b	48 8d 8b c8 00
	00 00		 lea	 rcx, QWORD PTR [rbx+200]
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExInterlockedInsertTailList

; 785  : 	KeSetEvent (&queue->MainThreadQueueNotEmptyEvent, IO_DISK_INCREMENT, FALSE);

  00088	45 33 c0	 xor	 r8d, r8d
  0008b	48 8d 8b e0 00
	00 00		 lea	 rcx, QWORD PTR [rbx+224]
  00092	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  00096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 786  : 	
; 787  : 	return STATUS_PENDING;

  0009c	b8 03 01 00 00	 mov	 eax, 259		; 00000103H
$LN3@EncryptedI@3:

; 792  : }

  000a1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a6	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000ab	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000af	5f		 pop	 rdi
  000b0	c3		 ret	 0
EncryptedIoQueueAddIrp ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$OnItemCompleted DD imagerel OnItemCompleted
	DD	imagerel OnItemCompleted+93
	DD	imagerel $unwind$OnItemCompleted
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$OnItemCompleted DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT OnItemCompleted
_TEXT	SEGMENT
item$ = 48
freeItem$ = 56
OnItemCompleted PROC					; COMDAT

; 157  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 158  : 	DecrementOutstandingIoCount (item->Queue);

  00009	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0000c	e8 00 00 00 00	 call	 DecrementOutstandingIoCount

; 159  : 	IoReleaseRemoveLock (&item->Queue->RemoveLock, item->OriginalIrp);

  00011	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00014	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  00018	48 81 c1 a0 00
	00 00		 add	 rcx, 160		; 000000a0H
  0001f	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 160  : 
; 161  : 	if (NT_SUCCESS (item->Status))

  0002b	83 7b 20 00	 cmp	 DWORD PTR [rbx+32], 0
  0002f	7c 1c		 jl	 SHORT $LN2@OnItemComp

; 162  : 	{
; 163  : 		if (item->Write)

  00031	83 7b 10 00	 cmp	 DWORD PTR [rbx+16], 0

; 164  : 			item->Queue->TotalBytesWritten += item->OriginalLength;

  00035	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00038	8b 43 14	 mov	 eax, DWORD PTR [rbx+20]
  0003b	74 09		 je	 SHORT $LN3@OnItemComp
  0003d	48 01 81 28 02
	00 00		 add	 QWORD PTR [rcx+552], rax

; 165  : 		else

  00044	eb 07		 jmp	 SHORT $LN2@OnItemComp
$LN3@OnItemComp:

; 166  : 			item->Queue->TotalBytesRead += item->OriginalLength;

  00046	48 01 81 20 02
	00 00		 add	 QWORD PTR [rcx+544], rax
$LN2@OnItemComp:

; 167  : 	}
; 168  : 
; 169  : 	if (freeItem)
; 170  : 		ReleasePoolBuffer (item->Queue, item);

  0004d	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00050	48 8b d3	 mov	 rdx, rbx

; 171  : }

  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 ReleasePoolBuffer
OnItemCompleted ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$CompleteOriginalIrp DD imagerel CompleteOriginalIrp
	DD	imagerel CompleteOriginalIrp+132
	DD	imagerel $unwind$CompleteOriginalIrp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CompleteOriginalIrp DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT CompleteOriginalIrp
_TEXT	SEGMENT
item$ = 48
status$ = 56
information$ = 64
CompleteOriginalIrp PROC				; COMDAT

; 175  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 176  : #ifdef TC_TRACE_IO_QUEUE
; 177  : 	Dump ("< %I64d [%I64d] %c status=%x info=%I64d\n", item->OriginalIrpOffset, GetElapsedTime (&item->Queue->LastPerformanceCounter), item->Write ? 'W' : 'R', status, (int64) information);
; 178  : #endif
; 179  : 
; 180  : 	TCCompleteDiskIrp (item->OriginalIrp, status, information);

  0000d	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00011	85 d2		 test	 edx, edx
  00013	89 51 30	 mov	 DWORD PTR [rcx+48], edx
  00016	8b fa		 mov	 edi, edx
  00018	0f 99 c2	 setns	 dl
  0001b	4c 89 41 38	 mov	 QWORD PTR [rcx+56], r8
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 181  : 
; 182  : 	item->Status = status;
; 183  : 	OnItemCompleted (item, TRUE);

  00025	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00028	89 7b 20	 mov	 DWORD PTR [rbx+32], edi
  0002b	e8 00 00 00 00	 call	 DecrementOutstandingIoCount
  00030	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00033	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  00037	48 81 c1 a0 00
	00 00		 add	 rcx, 160		; 000000a0H
  0003e	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx
  0004a	83 7b 20 00	 cmp	 DWORD PTR [rbx+32], 0
  0004e	7c 1c		 jl	 SHORT $LN6@CompleteOr
  00050	83 7b 10 00	 cmp	 DWORD PTR [rbx+16], 0
  00054	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00057	8b 43 14	 mov	 eax, DWORD PTR [rbx+20]
  0005a	74 09		 je	 SHORT $LN7@CompleteOr
  0005c	48 01 81 28 02
	00 00		 add	 QWORD PTR [rcx+552], rax
  00063	eb 07		 jmp	 SHORT $LN6@CompleteOr
$LN7@CompleteOr:
  00065	48 01 81 20 02
	00 00		 add	 QWORD PTR [rcx+544], rax
$LN6@CompleteOr:
  0006c	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0006f	48 8b d3	 mov	 rdx, rbx
  00072	e8 00 00 00 00	 call	 ReleasePoolBuffer

; 184  : 
; 185  : 	return status;
; 186  : }

  00077	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007c	8b c7		 mov	 eax, edi
  0007e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00082	5f		 pop	 rdi
  00083	c3		 ret	 0
CompleteOriginalIrp ENDP
;	COMDAT pdata
; File c:\home\public\desktop\projects\ciphershed\src\driver\ntdriver.c
pdata	SEGMENT
$pdata$IoThreadProc DD imagerel IoThreadProc
	DD	imagerel IoThreadProc+1031
	DD	imagerel $unwind$IoThreadProc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IoThreadProc DD 0c1c01H
	DD	017641cH
	DD	016541cH
	DD	015341cH
	DD	0f018d21cH
	DD	0d014e016H
	DD	07010c012H
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed\src\driver\encryptedioqueue.c
xdata	ENDS
;	COMDAT IoThreadProc
_TEXT	SEGMENT
ioStatus$29578 = 80
ioStatus$29602 = 96
subFragmentLength$29554 = 160
threadArg$ = 160
IoThreadProc PROC					; COMDAT

; 299  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0001c	48 8b d9	 mov	 rbx, rcx

; 300  : 	EncryptedIoQueue *queue = (EncryptedIoQueue *) threadArg;
; 301  : 	PLIST_ENTRY listEntry;
; 302  : 	EncryptedIoRequest *request;
; 303  : 
; 304  : 	KeSetPriorityThread (KeGetCurrentThread(), LOW_REALTIME_PRIORITY);

  0001f	65 48 8b 0c 25
	88 01 00 00	 mov	 rcx, QWORD PTR gs:392
  00028	ba 10 00 00 00	 mov	 edx, 16
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetPriorityThread

; 305  : 
; 306  : 	if (!queue->IsFilterDevice && queue->SecurityClientContext)

  00033	33 ed		 xor	 ebp, ebp
  00035	39 6b 68	 cmp	 DWORD PTR [rbx+104], ebp
  00038	75 11		 jne	 SHORT $LN57@IoThreadPr
  0003a	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  0003e	48 3b cd	 cmp	 rcx, rbp
  00041	74 08		 je	 SHORT $LN57@IoThreadPr

; 307  : 	{
; 308  : #ifdef DEBUG
; 309  : 		NTSTATUS status =
; 310  : #endif
; 311  : 		SeImpersonateClientEx (queue->SecurityClientContext, NULL);

  00043	33 d2		 xor	 edx, edx
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeImpersonateClientEx
$LN57@IoThreadPr:

; 312  : 		ASSERT (NT_SUCCESS (status));
; 313  : 	}
; 314  : 
; 315  : 	while (!queue->ThreadExitRequested)

  0004b	8b 83 34 02 00
	00		 mov	 eax, DWORD PTR [rbx+564]
  00051	3b c5		 cmp	 eax, ebp
  00053	0f 85 88 03 00
	00		 jne	 $LN60@IoThreadPr
  00059	44 8b a4 24 a0
	00 00 00	 mov	 r12d, DWORD PTR subFragmentLength$29554[rsp]
$LL40@IoThreadPr:

; 316  : 	{
; 317  : 		if (!NT_SUCCESS (KeWaitForSingleObject (&queue->IoThreadQueueNotEmptyEvent, Executive, KernelMode, FALSE, NULL)))

  00061	48 8d 8b 18 01
	00 00		 lea	 rcx, QWORD PTR [rbx+280]
  00068	45 33 c9	 xor	 r9d, r9d
  0006b	45 33 c0	 xor	 r8d, r8d
  0006e	33 d2		 xor	 edx, edx
  00070	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  0007b	3b c5		 cmp	 eax, ebp
  0007d	0f 8c 50 03 00
	00		 jl	 $LN35@IoThreadPr

; 318  : 			continue;
; 319  : 
; 320  : 		if (queue->ThreadExitRequested)

  00083	8b 83 34 02 00
	00		 mov	 eax, DWORD PTR [rbx+564]
  00089	3b c5		 cmp	 eax, ebp
  0008b	0f 85 50 03 00
	00		 jne	 $LN60@IoThreadPr

; 321  : 			break;
; 322  : 
; 323  : 		while ((listEntry = ExInterlockedRemoveHeadList (&queue->IoThreadQueue, &queue->IoThreadQueueLock)))

  00091	e9 20 03 00 00	 jmp	 $LN4@IoThreadPr
$LL36@IoThreadPr:

; 324  : 		{
; 325  : 			InterlockedDecrement (&queue->IoThreadPendingRequestCount);

  00096	f0 83 83 00 02
	00 00 ff	 lock add DWORD PTR [rbx+512], -1

; 326  : 			request = CONTAINING_RECORD (listEntry, EncryptedIoRequest, ListEntry);

  0009e	48 8d 78 c0	 lea	 rdi, QWORD PTR [rax-64]

; 327  : 			
; 328  : #ifdef TC_TRACE_IO_QUEUE
; 329  : 			Dump ("%c   %I64d [%I64d] roff=%I64d rlen=%d\n", request->Item->Write ? 'W' : 'R', request->Item->OriginalIrpOffset.QuadPart, GetElapsedTime (&queue->LastPerformanceCounter), request->Offset.QuadPart, request->Length);
; 330  : #endif
; 331  : 
; 332  : 			// Perform IO request if no preceding request of the item failed
; 333  : 			if (NT_SUCCESS (request->Item->Status))

  000a2	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  000a5	39 68 20	 cmp	 DWORD PTR [rax+32], ebp
  000a8	0f 8c 8a 01 00
	00		 jl	 $LN10@IoThreadPr

; 334  : 			{
; 335  : 				if (queue->IsFilterDevice)

  000ae	39 6b 68	 cmp	 DWORD PTR [rbx+104], ebp
  000b1	0f 84 05 01 00
	00		 je	 $LN33@IoThreadPr

; 336  : 				{
; 337  : 					if (queue->RemapEncryptedArea && request->EncryptedLength > 0)

  000b7	39 ab 8c 00 00
	00		 cmp	 DWORD PTR [rbx+140], ebp
  000bd	0f 84 c3 00 00
	00		 je	 $LN32@IoThreadPr
  000c3	39 6f 28	 cmp	 DWORD PTR [rdi+40], ebp
  000c6	0f 86 ba 00 00
	00		 jbe	 $LN32@IoThreadPr

; 338  : 					{
; 339  : 						if (request->EncryptedLength != request->Length)

  000cc	8b 4f 18	 mov	 ecx, DWORD PTR [rdi+24]
  000cf	39 4f 28	 cmp	 DWORD PTR [rdi+40], ecx
  000d2	0f 84 9a 00 00
	00		 je	 $LN31@IoThreadPr

; 340  : 						{
; 341  : 							// Up to three subfragments may be required to handle a partially remapped fragment
; 342  : 							int subFragment;
; 343  : 							byte *subFragmentData = request->Data;

  000d8	48 8b 6f 30	 mov	 rbp, QWORD PTR [rdi+48]

; 344  : 
; 345  : 							for (subFragment = 0 ; subFragment < 3; ++subFragment)

  000dc	33 f6		 xor	 esi, esi
$LL30@IoThreadPr:

; 346  : 							{
; 347  : 								LARGE_INTEGER subFragmentOffset;
; 348  : 								ULONG subFragmentLength;
; 349  : 								subFragmentOffset.QuadPart = request->Offset.QuadPart;

  000de	4c 8b 4f 10	 mov	 r9, QWORD PTR [rdi+16]

; 350  : 
; 351  : 								switch (subFragment)

  000e2	8b ce		 mov	 ecx, esi
  000e4	85 f6		 test	 esi, esi
  000e6	74 38		 je	 SHORT $LN25@IoThreadPr
  000e8	83 e9 01	 sub	 ecx, 1
  000eb	74 1f		 je	 SHORT $LN24@IoThreadPr
  000ed	83 f9 01	 cmp	 ecx, 1
  000f0	75 32		 jne	 SHORT $LN26@IoThreadPr

; 361  : 
; 362  : 								case 2:
; 363  : 									subFragmentOffset.QuadPart += request->EncryptedOffset + request->EncryptedLength;

  000f2	8b 4f 28	 mov	 ecx, DWORD PTR [rdi+40]

; 364  : 									subFragmentLength = (ULONG) (request->Length - (request->EncryptedOffset + request->EncryptedLength));

  000f5	44 8b 67 18	 mov	 r12d, DWORD PTR [rdi+24]
  000f9	48 8b c1	 mov	 rax, rcx
  000fc	44 2b e1	 sub	 r12d, ecx
  000ff	48 03 47 20	 add	 rax, QWORD PTR [rdi+32]
  00103	4c 03 c8	 add	 r9, rax
  00106	44 2b 67 20	 sub	 r12d, DWORD PTR [rdi+32]

; 365  : 									break;

  0010a	eb 18		 jmp	 SHORT $LN26@IoThreadPr
$LN24@IoThreadPr:

; 355  : 									break;
; 356  : 
; 357  : 								case 1:
; 358  : 									subFragmentOffset.QuadPart += request->EncryptedOffset + queue->RemappedAreaOffset;

  0010c	48 8b 83 90 00
	00 00		 mov	 rax, QWORD PTR [rbx+144]

; 359  : 									subFragmentLength = request->EncryptedLength;

  00113	44 8b 67 28	 mov	 r12d, DWORD PTR [rdi+40]
  00117	48 03 47 20	 add	 rax, QWORD PTR [rdi+32]
  0011b	4c 03 c8	 add	 r9, rax

; 360  : 									break;

  0011e	eb 04		 jmp	 SHORT $LN26@IoThreadPr
$LN25@IoThreadPr:

; 352  : 								{
; 353  : 								case 0:
; 354  : 									subFragmentLength = (ULONG) request->EncryptedOffset;

  00120	44 8b 67 20	 mov	 r12d, DWORD PTR [rdi+32]
$LN26@IoThreadPr:

; 366  : 								}
; 367  : 
; 368  : 								if (subFragmentLength > 0)

  00124	45 85 e4	 test	 r12d, r12d
  00127	74 37		 je	 SHORT $LN29@IoThreadPr

; 369  : 								{
; 370  : 									if (request->Item->Write)

  00129	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 371  : 										request->Item->Status = TCWriteDevice (queue->LowerDeviceObject, subFragmentData, subFragmentOffset, subFragmentLength);

  0012c	44 89 64 24 20	 mov	 DWORD PTR [rsp+32], r12d
  00131	4c 8b c5	 mov	 r8, rbp
  00134	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  00138	74 10		 je	 SHORT $LN21@IoThreadPr
  0013a	48 8b 53 70	 mov	 rdx, QWORD PTR [rbx+112]
  0013e	b9 01 00 00 00	 mov	 ecx, 1
  00143	e8 00 00 00 00	 call	 TCReadWriteDevice

; 372  : 									else

  00148	eb 0a		 jmp	 SHORT $LN64@IoThreadPr
$LN21@IoThreadPr:

; 373  : 										request->Item->Status = TCCachedRead (queue, NULL, subFragmentData, subFragmentOffset, subFragmentLength);

  0014a	33 d2		 xor	 edx, edx
  0014c	48 8b cb	 mov	 rcx, rbx
  0014f	e8 00 00 00 00	 call	 TCCachedRead
$LN64@IoThreadPr:
  00154	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  00157	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 374  : 
; 375  : 									subFragmentData += subFragmentLength;

  0015a	41 8b c4	 mov	 eax, r12d
  0015d	48 03 e8	 add	 rbp, rax
$LN29@IoThreadPr:
  00160	ff c6		 inc	 esi
  00162	83 fe 03	 cmp	 esi, 3
  00165	0f 8c 73 ff ff
	ff		 jl	 $LL30@IoThreadPr

; 376  : 								}
; 377  : 							}
; 378  : 						}
; 379  : 						else

  0016b	33 ed		 xor	 ebp, ebp
  0016d	e9 c6 00 00 00	 jmp	 $LN10@IoThreadPr
$LN31@IoThreadPr:

; 380  : 						{
; 381  : 							// Remap the fragment
; 382  : 							LARGE_INTEGER remappedOffset;
; 383  : 							remappedOffset.QuadPart = request->Offset.QuadPart + queue->RemappedAreaOffset;

  00172	4c 8b 8b 90 00
	00 00		 mov	 r9, QWORD PTR [rbx+144]

; 384  : 
; 385  : 							if (request->Item->Write)
; 386  : 								request->Item->Status = TCWriteDevice (queue->LowerDeviceObject, request->Data, remappedOffset, request->Length);

  00179	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0017d	4c 03 4f 10	 add	 r9, QWORD PTR [rdi+16]
  00181	39 68 10	 cmp	 DWORD PTR [rax+16], ebp

; 387  : 							else

  00184	eb 0e		 jmp	 SHORT $LN69@IoThreadPr
$LN32@IoThreadPr:

; 388  : 								request->Item->Status = TCCachedRead (queue, NULL, request->Data, remappedOffset, request->Length);
; 389  : 						}
; 390  : 					}
; 391  : 					else
; 392  : 					{
; 393  : 						if (request->Item->Write)

  00186	39 68 10	 cmp	 DWORD PTR [rax+16], ebp

; 394  : 							request->Item->Status = TCWriteDevice (queue->LowerDeviceObject, request->Data, request->Offset, request->Length);

  00189	8b 47 18	 mov	 eax, DWORD PTR [rdi+24]
  0018c	4c 8b 4f 10	 mov	 r9, QWORD PTR [rdi+16]
  00190	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
$LN69@IoThreadPr:
  00194	4c 8b 47 30	 mov	 r8, QWORD PTR [rdi+48]

; 388  : 								request->Item->Status = TCCachedRead (queue, NULL, request->Data, remappedOffset, request->Length);
; 389  : 						}
; 390  : 					}
; 391  : 					else
; 392  : 					{
; 393  : 						if (request->Item->Write)

  00198	74 10		 je	 SHORT $LN15@IoThreadPr

; 394  : 							request->Item->Status = TCWriteDevice (queue->LowerDeviceObject, request->Data, request->Offset, request->Length);

  0019a	48 8b 53 70	 mov	 rdx, QWORD PTR [rbx+112]
  0019e	b9 01 00 00 00	 mov	 ecx, 1
  001a3	e8 00 00 00 00	 call	 TCReadWriteDevice

; 395  : 						else

  001a8	eb 0a		 jmp	 SHORT $LN66@IoThreadPr
$LN15@IoThreadPr:

; 396  : 							request->Item->Status = TCCachedRead (queue, NULL, request->Data, request->Offset, request->Length);

  001aa	33 d2		 xor	 edx, edx
  001ac	48 8b cb	 mov	 rcx, rbx
  001af	e8 00 00 00 00	 call	 TCCachedRead
$LN66@IoThreadPr:
  001b4	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  001b7	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 397  : 					}
; 398  : 				}
; 399  : 				else

  001ba	eb 7c		 jmp	 SHORT $LN10@IoThreadPr
$LN33@IoThreadPr:

; 400  : 				{
; 401  : 					IO_STATUS_BLOCK ioStatus;
; 402  : 
; 403  : 					if (request->Item->Write)

  001bc	39 68 10	 cmp	 DWORD PTR [rax+16], ebp
  001bf	74 3c		 je	 SHORT $LN12@IoThreadPr

; 404  : 						request->Item->Status = ZwWriteFile (queue->HostFileHandle, NULL, NULL, NULL, &ioStatus, request->Data, request->Length, &request->Offset, NULL);

  001c1	48 8b 4b 50	 mov	 rcx, QWORD PTR [rbx+80]
  001c5	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  001ca	48 8d 47 10	 lea	 rax, QWORD PTR [rdi+16]
  001ce	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  001d3	8b 47 18	 mov	 eax, DWORD PTR [rdi+24]
  001d6	45 33 c9	 xor	 r9d, r9d
  001d9	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  001dd	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  001e1	45 33 c0	 xor	 r8d, r8d
  001e4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001e9	48 8d 44 24 50	 lea	 rax, QWORD PTR ioStatus$29578[rsp]
  001ee	33 d2		 xor	 edx, edx
  001f0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwWriteFile

; 405  : 					else

  001fb	eb 1c		 jmp	 SHORT $LN65@IoThreadPr
$LN12@IoThreadPr:

; 406  : 						request->Item->Status = TCCachedRead (queue, &ioStatus, request->Data, request->Offset, request->Length);

  001fd	8b 47 18	 mov	 eax, DWORD PTR [rdi+24]
  00200	4c 8b 4f 10	 mov	 r9, QWORD PTR [rdi+16]
  00204	4c 8b 47 30	 mov	 r8, QWORD PTR [rdi+48]
  00208	48 8d 54 24 50	 lea	 rdx, QWORD PTR ioStatus$29578[rsp]
  0020d	48 8b cb	 mov	 rcx, rbx
  00210	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00214	e8 00 00 00 00	 call	 TCCachedRead
$LN65@IoThreadPr:
  00219	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  0021c	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 407  : 
; 408  : 					if (NT_SUCCESS (request->Item->Status) && ioStatus.Information != request->Length)

  0021f	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  00222	39 69 20	 cmp	 DWORD PTR [rcx+32], ebp
  00225	7c 11		 jl	 SHORT $LN10@IoThreadPr
  00227	8b 47 18	 mov	 eax, DWORD PTR [rdi+24]
  0022a	48 39 44 24 58	 cmp	 QWORD PTR ioStatus$29578[rsp+8], rax
  0022f	74 07		 je	 SHORT $LN10@IoThreadPr

; 409  : 						request->Item->Status = STATUS_END_OF_FILE;

  00231	c7 41 20 11 00
	00 c0		 mov	 DWORD PTR [rcx+32], -1073741807 ; ffffffffc0000011H
$LN10@IoThreadPr:

; 410  : 				}
; 411  : 			}
; 412  : 
; 413  : 			if (request->Item->Write)

  00238	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0023b	39 68 10	 cmp	 DWORD PTR [rax+16], ebp
  0023e	74 40		 je	 SHORT $LN9@IoThreadPr

; 414  : 			{
; 415  : 				queue->ReadAheadBufferValid = FALSE;

  00240	89 ab a8 01 00
	00		 mov	 DWORD PTR [rbx+424], ebp

; 416  : 
; 417  : 				ReleaseFragmentBuffer (queue, request->Data);

  00246	48 8b 57 30	 mov	 rdx, QWORD PTR [rdi+48]
  0024a	48 8b cb	 mov	 rcx, rbx
  0024d	e8 00 00 00 00	 call	 ReleaseFragmentBuffer

; 418  : 
; 419  : 				if (request->CompleteOriginalIrp)

  00252	39 6f 08	 cmp	 DWORD PTR [rdi+8], ebp
  00255	74 19		 je	 SHORT $LN8@IoThreadPr

; 420  : 				{
; 421  : 					CompleteOriginalIrp (request->Item, request->Item->Status,
; 422  : 						NT_SUCCESS (request->Item->Status) ? request->Item->OriginalLength : 0);

  00257	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  0025a	8b 51 20	 mov	 edx, DWORD PTR [rcx+32]
  0025d	3b d5		 cmp	 edx, ebp
  0025f	7c 05		 jl	 SHORT $LN44@IoThreadPr
  00261	8b 41 14	 mov	 eax, DWORD PTR [rcx+20]
  00264	eb 02		 jmp	 SHORT $LN45@IoThreadPr
$LN44@IoThreadPr:
  00266	8b c5		 mov	 eax, ebp
$LN45@IoThreadPr:
  00268	44 8b c0	 mov	 r8d, eax
  0026b	e8 00 00 00 00	 call	 CompleteOriginalIrp
$LN8@IoThreadPr:

; 423  : 				}
; 424  : 
; 425  : 				ReleasePoolBuffer (queue, request);

  00270	48 8b d7	 mov	 rdx, rdi
  00273	48 8b cb	 mov	 rcx, rbx
  00276	e8 00 00 00 00	 call	 ReleasePoolBuffer

; 426  : 			}
; 427  : 			else

  0027b	e9 36 01 00 00	 jmp	 $LN4@IoThreadPr
$LN9@IoThreadPr:

; 428  : 			{
; 429  : 				BOOL readAhead = FALSE;
; 430  : 
; 431  : 				if (NT_SUCCESS (request->Item->Status))

  00280	39 68 20	 cmp	 DWORD PTR [rax+32], ebp
  00283	8b f5		 mov	 esi, ebp
  00285	7c 11		 jl	 SHORT $LN6@IoThreadPr

; 432  : 					memcpy (request->OrigDataBufferFragment, request->Data, request->Length);

  00287	44 8b 47 18	 mov	 r8d, DWORD PTR [rdi+24]
  0028b	48 8b 57 30	 mov	 rdx, QWORD PTR [rdi+48]
  0028f	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00293	e8 00 00 00 00	 call	 memcpy
$LN6@IoThreadPr:

; 433  : 
; 434  : 				ReleaseFragmentBuffer (queue, request->Data);

  00298	48 8b 57 30	 mov	 rdx, QWORD PTR [rdi+48]
  0029c	48 8b cb	 mov	 rcx, rbx
  0029f	e8 00 00 00 00	 call	 ReleaseFragmentBuffer

; 435  : 				request->Data = request->OrigDataBufferFragment;

  002a4	4c 8b 5f 38	 mov	 r11, QWORD PTR [rdi+56]
  002a8	4c 89 5f 30	 mov	 QWORD PTR [rdi+48], r11

; 436  : 
; 437  : 				if (request->CompleteOriginalIrp
; 438  : 					&& queue->LastReadLength > 0
; 439  : 					&& NT_SUCCESS (request->Item->Status)
; 440  : 					&& InterlockedExchangeAdd (&queue->IoThreadPendingRequestCount, 0) == 0)

  002ac	39 6f 08	 cmp	 DWORD PTR [rdi+8], ebp
  002af	74 2a		 je	 SHORT $LN5@IoThreadPr
  002b1	39 ab b8 01 00
	00		 cmp	 DWORD PTR [rbx+440], ebp
  002b7	76 22		 jbe	 SHORT $LN5@IoThreadPr
  002b9	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  002bc	39 68 20	 cmp	 DWORD PTR [rax+32], ebp
  002bf	7c 1a		 jl	 SHORT $LN5@IoThreadPr
  002c1	8b c5		 mov	 eax, ebp
  002c3	f0 0f c1 83 00
	02 00 00	 lock xadd DWORD PTR [rbx+512], eax
  002cb	3b c5		 cmp	 eax, ebp
  002cd	75 0c		 jne	 SHORT $LN5@IoThreadPr

; 441  : 				{
; 442  : 					readAhead = TRUE;

  002cf	be 01 00 00 00	 mov	 esi, 1

; 443  : 					InterlockedIncrement (&queue->OutstandingIoCount);

  002d4	f0 01 b3 e0 01
	00 00		 lock add DWORD PTR [rbx+480], esi
$LN5@IoThreadPr:

; 444  : 				}
; 445  : 
; 446  : 				ExInterlockedInsertTailList (&queue->CompletionThreadQueue, &request->CompletionListEntry, &queue->CompletionThreadQueueLock);

  002db	4c 8d 83 48 01
	00 00		 lea	 r8, QWORD PTR [rbx+328]
  002e2	48 8d 57 50	 lea	 rdx, QWORD PTR [rdi+80]
  002e6	48 8d 8b 38 01
	00 00		 lea	 rcx, QWORD PTR [rbx+312]
  002ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExInterlockedInsertTailList

; 447  : 				KeSetEvent (&queue->CompletionThreadQueueNotEmptyEvent, IO_DISK_INCREMENT, FALSE);

  002f3	45 33 c0	 xor	 r8d, r8d
  002f6	48 8d 8b 50 01
	00 00		 lea	 rcx, QWORD PTR [rbx+336]
  002fd	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  00301	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 448  : 
; 449  : 				if (readAhead)

  00307	3b f5		 cmp	 esi, ebp
  00309	0f 84 a7 00 00
	00		 je	 $LN4@IoThreadPr

; 450  : 				{
; 451  : 					queue->ReadAheadBufferValid = FALSE;
; 452  : 					queue->ReadAheadOffset.QuadPart = queue->LastReadOffset.QuadPart + queue->LastReadLength;

  0030f	8b 8b b8 01 00
	00		 mov	 ecx, DWORD PTR [rbx+440]
  00315	4c 8b 8b b0 01
	00 00		 mov	 r9, QWORD PTR [rbx+432]
  0031c	48 8d 93 c0 01
	00 00		 lea	 rdx, QWORD PTR [rbx+448]
  00323	4c 03 c9	 add	 r9, rcx
  00326	89 ab a8 01 00
	00		 mov	 DWORD PTR [rbx+424], ebp

; 453  : 					queue->ReadAheadLength = queue->LastReadLength;

  0032c	89 8b c8 01 00
	00		 mov	 DWORD PTR [rbx+456], ecx

; 454  : 
; 455  : 					if (queue->ReadAheadOffset.QuadPart + queue->ReadAheadLength <= queue->MaxReadAheadOffset.QuadPart)

  00332	49 8d 04 09	 lea	 rax, QWORD PTR [r9+rcx]
  00336	4c 89 0a	 mov	 QWORD PTR [rdx], r9
  00339	48 3b 83 d8 01
	00 00		 cmp	 rax, QWORD PTR [rbx+472]
  00340	7f 6c		 jg	 SHORT $LN1@IoThreadPr

; 456  : 					{
; 457  : #ifdef TC_TRACE_IO_QUEUE
; 458  : 						Dump ("A   %I64d [%I64d] roff=%I64d rlen=%d\n", request->Item->OriginalIrpOffset.QuadPart, GetElapsedTime (&queue->LastPerformanceCounter), queue->ReadAheadOffset, queue->ReadAheadLength);
; 459  : #endif
; 460  : 						if (queue->IsFilterDevice)

  00342	39 6b 68	 cmp	 DWORD PTR [rbx+104], ebp
  00345	74 1a		 je	 SHORT $LN2@IoThreadPr

; 461  : 						{
; 462  : 							queue->ReadAheadBufferValid = NT_SUCCESS (TCReadDevice (queue->LowerDeviceObject, queue->ReadAheadBuffer, queue->ReadAheadOffset, queue->ReadAheadLength));

  00347	4c 8b 83 d0 01
	00 00		 mov	 r8, QWORD PTR [rbx+464]
  0034e	48 8b 53 70	 mov	 rdx, QWORD PTR [rbx+112]
  00352	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00356	33 c9		 xor	 ecx, ecx
  00358	e8 00 00 00 00	 call	 TCReadWriteDevice
  0035d	3b c5		 cmp	 eax, ebp

; 463  : 						}
; 464  : 						else

  0035f	eb 42		 jmp	 SHORT $LN67@IoThreadPr
$LN2@IoThreadPr:

; 465  : 						{
; 466  : 							IO_STATUS_BLOCK ioStatus;
; 467  : 							queue->ReadAheadBufferValid = NT_SUCCESS (ZwReadFile (queue->HostFileHandle, NULL, NULL, NULL, &ioStatus, queue->ReadAheadBuffer, queue->ReadAheadLength, &queue->ReadAheadOffset, NULL));

  00361	48 8b 83 d0 01
	00 00		 mov	 rax, QWORD PTR [rbx+464]
  00368	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  0036d	48 89 54 24 38	 mov	 QWORD PTR [rsp+56], rdx
  00372	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  00376	48 8b 4b 50	 mov	 rcx, QWORD PTR [rbx+80]
  0037a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0037f	48 8d 44 24 60	 lea	 rax, QWORD PTR ioStatus$29602[rsp]
  00384	45 33 c9	 xor	 r9d, r9d
  00387	45 33 c0	 xor	 r8d, r8d
  0038a	33 d2		 xor	 edx, edx
  0038c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00391	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwReadFile
  00397	3b c5		 cmp	 eax, ebp

; 468  : 							queue->ReadAheadLength = (ULONG) ioStatus.Information;

  00399	8b 44 24 68	 mov	 eax, DWORD PTR ioStatus$29602[rsp+8]
  0039d	89 83 c8 01 00
	00		 mov	 DWORD PTR [rbx+456], eax
$LN67@IoThreadPr:
  003a3	8b cd		 mov	 ecx, ebp
  003a5	0f 9d c1	 setge	 cl
  003a8	89 8b a8 01 00
	00		 mov	 DWORD PTR [rbx+424], ecx
$LN1@IoThreadPr:

; 469  : 						}
; 470  : 					}
; 471  : 
; 472  : 					DecrementOutstandingIoCount (queue);

  003ae	48 8b cb	 mov	 rcx, rbx
  003b1	e8 00 00 00 00	 call	 DecrementOutstandingIoCount
$LN4@IoThreadPr:
  003b6	48 8d 93 10 01
	00 00		 lea	 rdx, QWORD PTR [rbx+272]
  003bd	48 8d 8b 00 01
	00 00		 lea	 rcx, QWORD PTR [rbx+256]
  003c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExInterlockedRemoveHeadList
  003ca	48 3b c5	 cmp	 rax, rbp
  003cd	0f 85 c3 fc ff
	ff		 jne	 $LL36@IoThreadPr
$LN35@IoThreadPr:

; 312  : 		ASSERT (NT_SUCCESS (status));
; 313  : 	}
; 314  : 
; 315  : 	while (!queue->ThreadExitRequested)

  003d3	8b 83 34 02 00
	00		 mov	 eax, DWORD PTR [rbx+564]
  003d9	3b c5		 cmp	 eax, ebp
  003db	0f 84 80 fc ff
	ff		 je	 $LL40@IoThreadPr
$LN60@IoThreadPr:

; 473  : 				}
; 474  : 			}
; 475  : 		}
; 476  : 	}
; 477  : 
; 478  : 	PsTerminateSystemThread (STATUS_SUCCESS);

  003e1	33 c9		 xor	 ecx, ecx

; 479  : }

  003e3	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  003e8	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  003ec	49 8b 6b 40	 mov	 rbp, QWORD PTR [r11+64]
  003f0	49 8b 73 48	 mov	 rsi, QWORD PTR [r11+72]
  003f4	49 8b e3	 mov	 rsp, r11
  003f7	41 5f		 pop	 r15
  003f9	41 5e		 pop	 r14
  003fb	41 5d		 pop	 r13
  003fd	41 5c		 pop	 r12
  003ff	5f		 pop	 rdi
  00400	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_PsTerminateSystemThread
IoThreadProc ENDP
;	COMDAT pdata
; File c:\home\public\desktop\projects\ciphershed\src\common\crypto.c
pdata	SEGMENT
$pdata$MainThreadProc DD imagerel MainThreadProc
	DD	imagerel MainThreadProc+1797
	DD	imagerel $unwind$MainThreadProc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MainThreadProc DD 0a1401H
	DD	0113414H
	DD	0f0105214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed\src\driver\encryptedioqueue.c
xdata	ENDS
;	COMDAT MainThreadProc
_TEXT	SEGMENT
activeFragmentBuffer$1$ = 112
threadArg$ = 112
dataUnit$29718 = 120
dataUnit$29671 = 128
MainThreadProc PROC					; COMDAT

; 483  : {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 491  : 	PUCHAR dataBuffer;
; 492  : 	EncryptedIoRequest *request;
; 493  : 	uint64 intersectStart;
; 494  : 	uint32 intersectLength;
; 495  : 
; 496  : 	if (IsEncryptionThreadPoolRunning())

  00014	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ThreadPoolRunning
  0001a	48 8b a9 68 01
	00 00		 mov	 rbp, QWORD PTR [rcx+360]
  00021	45 33 ff	 xor	 r15d, r15d
  00024	48 8b f1	 mov	 rsi, rcx
  00027	48 89 6c 24 70	 mov	 QWORD PTR activeFragmentBuffer$1$[rsp], rbp
  0002c	41 3b c7	 cmp	 eax, r15d
  0002f	74 13		 je	 SHORT $LN112@MainThread

; 497  : 		KeSetPriorityThread (KeGetCurrentThread(), LOW_REALTIME_PRIORITY);

  00031	65 48 8b 0c 25
	88 01 00 00	 mov	 rcx, QWORD PTR gs:392
  0003a	41 8d 57 10	 lea	 edx, QWORD PTR [r15+16]
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetPriorityThread
$LN112@MainThread:

; 498  : 
; 499  : 	while (!queue->ThreadExitRequested)

  00044	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [rsi+564]
  0004a	41 3b c7	 cmp	 eax, r15d
  0004d	0f 85 92 06 00
	00		 jne	 $LN122@MainThread
  00053	48 8d 86 e0 00
	00 00		 lea	 rax, QWORD PTR [rsi+224]

; 500  : 	{
; 501  : 		if (!NT_SUCCESS (KeWaitForSingleObject (&queue->MainThreadQueueNotEmptyEvent, Executive, KernelMode, FALSE, NULL)))

  0005a	45 33 c9	 xor	 r9d, r9d
  0005d	45 33 c0	 xor	 r8d, r8d
  00060	33 d2		 xor	 edx, edx
  00062	48 8b c8	 mov	 rcx, rax
  00065	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  00070	41 3b c7	 cmp	 eax, r15d
  00073	7c cf		 jl	 SHORT $LN112@MainThread

; 502  : 			continue;
; 503  : 
; 504  : 		while ((listEntry = ExInterlockedRemoveHeadList (&queue->MainThreadQueue, &queue->MainThreadQueueLock)))

  00075	e9 2a 06 00 00	 jmp	 $LN118@MainThread
$LL42@MainThread:

; 505  : 		{
; 506  : 			PIRP irp = CONTAINING_RECORD (listEntry, IRP, Tail.Overlay.ListEntry);

  0007a	4c 8d a8 58 ff
	ff ff		 lea	 r13, QWORD PTR [rax-168]

; 507  : 			PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (irp);
; 508  : 			
; 509  : 			if (queue->Suspended)

  00081	8b 86 38 02 00
	00		 mov	 eax, DWORD PTR [rsi+568]
  00087	49 8b 9d b8 00
	00 00		 mov	 rbx, QWORD PTR [r13+184]
  0008e	41 3b c7	 cmp	 eax, r15d
  00091	74 1a		 je	 SHORT $LN40@MainThread

; 510  : 				KeWaitForSingleObject (&queue->QueueResumedEvent, Executive, KernelMode, FALSE, NULL);

  00093	48 8d 8e 48 02
	00 00		 lea	 rcx, QWORD PTR [rsi+584]
  0009a	45 33 c9	 xor	 r9d, r9d
  0009d	45 33 c0	 xor	 r8d, r8d
  000a0	33 d2		 xor	 edx, edx
  000a2	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  000a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
$LN40@MainThread:

; 511  : 
; 512  : 			item = GetPoolBuffer (queue, sizeof (EncryptedIoQueueItem));

  000ad	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  000b2	48 8b ce	 mov	 rcx, rsi
  000b5	e8 00 00 00 00	 call	 GetPoolBuffer

; 513  : 			item->Queue = queue;
; 514  : 			item->OriginalIrp = irp;
; 515  : 			item->Status = STATUS_SUCCESS;
; 516  : 
; 517  : 			IoSetCancelRoutine (irp, NULL);

  000ba	49 8b cf	 mov	 rcx, r15
  000bd	48 89 30	 mov	 QWORD PTR [rax], rsi
  000c0	4c 89 68 08	 mov	 QWORD PTR [rax+8], r13
  000c4	44 89 78 20	 mov	 DWORD PTR [rax+32], r15d
  000c8	49 87 4d 68	 xchg	 QWORD PTR [r13+104], rcx
  000cc	48 8b f8	 mov	 rdi, rax

; 518  : 			if (irp->Cancel)

  000cf	45 38 7d 44	 cmp	 BYTE PTR [r13+68], r15b
  000d3	74 15		 je	 SHORT $LN39@MainThread

; 519  : 			{
; 520  : 				CompleteOriginalIrp (item, STATUS_CANCELLED, 0);

  000d5	ba 20 01 00 c0	 mov	 edx, -1073741536	; ffffffffc0000120H
$LN139@MainThread:
  000da	48 8b c8	 mov	 rcx, rax
$LN142@MainThread:
  000dd	45 33 c0	 xor	 r8d, r8d
  000e0	e8 00 00 00 00	 call	 CompleteOriginalIrp

; 521  : 				continue;

  000e5	e9 ba 05 00 00	 jmp	 $LN118@MainThread
$LN39@MainThread:

; 522  : 			}
; 523  : 
; 524  : 			switch (irpSp->MajorFunction)

  000ea	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  000ed	83 e9 03	 sub	 ecx, 3
  000f0	74 15		 je	 SHORT $LN36@MainThread
  000f2	83 f9 01	 cmp	 ecx, 1
  000f5	74 07		 je	 SHORT $LN35@MainThread

; 537  : 
; 538  : 			default:
; 539  : 				CompleteOriginalIrp (item, STATUS_INVALID_PARAMETER, 0);

  000f7	ba 0d 00 00 c0	 mov	 edx, -1073741811	; ffffffffc000000dH

; 540  : 				continue;

  000fc	eb dc		 jmp	 SHORT $LN139@MainThread
$LN35@MainThread:

; 530  : 				break;
; 531  : 
; 532  : 			case IRP_MJ_WRITE:
; 533  : 				item->Write = TRUE;

  000fe	c7 40 10 01 00
	00 00		 mov	 DWORD PTR [rax+16], 1

; 534  : 				item->OriginalOffset = irpSp->Parameters.Write.ByteOffset;
; 535  : 				item->OriginalLength = irpSp->Parameters.Write.Length;
; 536  : 				break;

  00105	eb 04		 jmp	 SHORT $LN126@MainThread
$LN36@MainThread:

; 525  : 			{
; 526  : 			case IRP_MJ_READ:
; 527  : 				item->Write = FALSE;

  00107	44 89 78 10	 mov	 DWORD PTR [rax+16], r15d
$LN126@MainThread:

; 528  : 				item->OriginalOffset = irpSp->Parameters.Read.ByteOffset;

  0010b	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  0010f	48 89 47 18	 mov	 QWORD PTR [rdi+24], rax

; 529  : 				item->OriginalLength = irpSp->Parameters.Read.Length;

  00113	44 8b 43 08	 mov	 r8d, DWORD PTR [rbx+8]
  00117	44 89 47 14	 mov	 DWORD PTR [rdi+20], r8d

; 541  : 			}
; 542  : 
; 543  : #ifdef TC_TRACE_IO_QUEUE
; 544  : 			item->OriginalIrpOffset = item->OriginalOffset;
; 545  : #endif
; 546  : 
; 547  : 			// Handle misaligned read operations to work around a bug in Windows System Assessment Tool which does not follow FILE_FLAG_NO_BUFFERING requirements when benchmarking disk devices
; 548  : 			if (queue->IsFilterDevice
; 549  : 				&& !item->Write
; 550  : 				&& item->OriginalLength > 0
; 551  : 				&& (item->OriginalLength & (ENCRYPTION_DATA_UNIT_SIZE - 1)) == 0
; 552  : 				&& (item->OriginalOffset.QuadPart & (ENCRYPTION_DATA_UNIT_SIZE - 1)) != 0)

  0011b	8b 4e 68	 mov	 ecx, DWORD PTR [rsi+104]
  0011e	41 3b cf	 cmp	 ecx, r15d
  00121	0f 84 93 01 00
	00		 je	 $LN33@MainThread
  00127	44 39 7f 10	 cmp	 DWORD PTR [rdi+16], r15d
  0012b	0f 85 89 01 00
	00		 jne	 $LN33@MainThread
  00131	45 3b c7	 cmp	 r8d, r15d
  00134	0f 86 83 01 00
	00		 jbe	 $LN127@MainThread
  0013a	41 f7 c0 ff 01
	00 00		 test	 r8d, 511		; 000001ffH
  00141	0f 85 73 01 00
	00		 jne	 $LN33@MainThread
  00147	48 8b d8	 mov	 rbx, rax
  0014a	48 a9 ff 01 00
	00		 test	 rax, 511		; 000001ffH
  00150	0f 84 64 01 00
	00		 je	 $LN33@MainThread

; 553  : 			{
; 554  : 				byte *buffer;
; 555  : 				ULONG alignedLength = item->OriginalLength + ENCRYPTION_DATA_UNIT_SIZE;

  00156	45 8d a0 00 02
	00 00		 lea	 r12d, DWORD PTR [r8+512]

; 556  : 				LARGE_INTEGER alignedOffset;
; 557  : 				alignedOffset.QuadPart = item->OriginalOffset.QuadPart & ~((LONGLONG) ENCRYPTION_DATA_UNIT_SIZE - 1);
; 558  : 
; 559  : 				buffer = TCalloc (alignedLength);

  0015d	33 c9		 xor	 ecx, ecx
  0015f	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  00165	41 8b d4	 mov	 edx, r12d
  00168	48 81 e3 00 fe
	ff ff		 and	 rbx, -512		; fffffffffffffe00H
  0016f	45 8b f4	 mov	 r14d, r12d
  00172	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00178	48 8b e8	 mov	 rbp, rax

; 560  : 				if (!buffer)

  0017b	49 3b c7	 cmp	 rax, r15
  0017e	75 15		 jne	 SHORT $LN32@MainThread
$LN134@MainThread:

; 561  : 				{
; 562  : 					CompleteOriginalIrp (item, STATUS_INSUFFICIENT_RESOURCES, 0);

  00180	45 33 c0	 xor	 r8d, r8d
  00183	ba 9a 00 00 c0	 mov	 edx, -1073741670	; ffffffffc000009aH
$LN135@MainThread:
  00188	48 8b cf	 mov	 rcx, rdi
  0018b	e8 00 00 00 00	 call	 CompleteOriginalIrp

; 563  : 					continue;

  00190	e9 0a 05 00 00	 jmp	 $LN128@MainThread
$LN32@MainThread:

; 564  : 				}
; 565  : 
; 566  : 				item->Status = TCReadDevice (queue->LowerDeviceObject, buffer, alignedOffset, alignedLength);

  00195	48 8b 56 70	 mov	 rdx, QWORD PTR [rsi+112]
  00199	4c 8b cb	 mov	 r9, rbx
  0019c	4c 8b c0	 mov	 r8, rax
  0019f	33 c9		 xor	 ecx, ecx
  001a1	44 89 64 24 20	 mov	 DWORD PTR [rsp+32], r12d
  001a6	e8 00 00 00 00	 call	 TCReadWriteDevice

; 567  : 
; 568  : 				if (NT_SUCCESS (item->Status))

  001ab	41 3b c7	 cmp	 eax, r15d
  001ae	89 47 20	 mov	 DWORD PTR [rdi+32], eax
  001b1	0f 8c dd 00 00
	00		 jl	 $LN31@MainThread

; 569  : 				{
; 570  : 					UINT64_STRUCT dataUnit;
; 571  : 
; 572  : 					dataBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe (irp->MdlAddress, HighPagePriority);

  001b7	49 8b 4d 08	 mov	 rcx, QWORD PTR [r13+8]
  001bb	f6 41 0a 05	 test	 BYTE PTR [rcx+10], 5
  001bf	74 06		 je	 SHORT $LN49@MainThread
  001c1	4c 8b 61 18	 mov	 r12, QWORD PTR [rcx+24]
  001c5	eb 1f		 jmp	 SHORT $LN50@MainThread
$LN49@MainThread:
  001c7	45 33 c9	 xor	 r9d, r9d
  001ca	33 d2		 xor	 edx, edx
  001cc	c7 44 24 28 20
	00 00 00	 mov	 DWORD PTR [rsp+40], 32	; 00000020H
  001d4	45 8d 41 01	 lea	 r8d, QWORD PTR [r9+1]
  001d8	44 89 7c 24 20	 mov	 DWORD PTR [rsp+32], r15d
  001dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmMapLockedPagesSpecifyCache
  001e3	4c 8b e0	 mov	 r12, rax
$LN50@MainThread:

; 573  : 					if (!dataBuffer)

  001e6	4d 3b e7	 cmp	 r12, r15
  001e9	75 10		 jne	 SHORT $LN30@MainThread

; 574  : 					{
; 575  : 						TCfree (buffer);

  001eb	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  001f0	48 8b cd	 mov	 rcx, rbp
  001f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 576  : 						CompleteOriginalIrp (item, STATUS_INSUFFICIENT_RESOURCES, 0);
; 577  : 						continue;

  001f9	eb 85		 jmp	 SHORT $LN134@MainThread
$LN30@MainThread:

; 578  : 					}
; 579  : 
; 580  : 					if (queue->EncryptedAreaStart != -1 && queue->EncryptedAreaEnd != -1)

  001fb	48 83 7e 78 ff	 cmp	 QWORD PTR [rsi+120], -1
  00200	74 7a		 je	 SHORT $LN70@MainThread
  00202	48 8b 86 80 00
	00 00		 mov	 rax, QWORD PTR [rsi+128]
  00209	48 83 f8 ff	 cmp	 rax, -1
  0020d	74 6d		 je	 SHORT $LN70@MainThread

; 581  : 					{
; 582  : 						GetIntersection (alignedOffset.QuadPart, alignedLength, queue->EncryptedAreaStart, queue->EncryptedAreaEnd, &intersectStart, &intersectLength);

  0020f	48 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [rsi+128]
  00216	48 8b 56 78	 mov	 rdx, QWORD PTR [rsi+120]
  0021a	49 8d 44 1e ff	 lea	 rax, QWORD PTR [r14+rbx-1]
  0021f	48 3b c1	 cmp	 rax, rcx
  00222	48 0f 46 c8	 cmovbe	 rcx, rax
  00226	48 3b da	 cmp	 rbx, rdx
  00229	48 0f 43 d3	 cmovae	 rdx, rbx
  0022d	48 3b d1	 cmp	 rdx, rcx
  00230	76 05		 jbe	 SHORT $LN68@MainThread
  00232	41 8b cf	 mov	 ecx, r15d
  00235	eb 07		 jmp	 SHORT $LN119@MainThread
$LN68@MainThread:
  00237	2b ca		 sub	 ecx, edx
  00239	83 c1 01	 add	 ecx, 1
  0023c	75 03		 jne	 SHORT $LN65@MainThread
$LN119@MainThread:
  0023e	48 8b d3	 mov	 rdx, rbx
$LN65@MainThread:

; 583  : 						if (intersectLength > 0)

  00241	41 3b cf	 cmp	 ecx, r15d
  00244	76 36		 jbe	 SHORT $LN70@MainThread

; 584  : 						{
; 585  : 							dataUnit.Value = intersectStart / ENCRYPTION_DATA_UNIT_SIZE;

  00246	48 8b c2	 mov	 rax, rdx

; 586  : 							DecryptDataUnits (buffer + (intersectStart - alignedOffset.QuadPart), &dataUnit, intersectLength / ENCRYPTION_DATA_UNIT_SIZE, queue->CryptoInfo);

  00249	c1 e9 09	 shr	 ecx, 9
  0024c	48 2b d3	 sub	 rdx, rbx
  0024f	48 c1 e8 09	 shr	 rax, 9
  00253	44 8b c9	 mov	 r9d, ecx
  00256	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR dataUnit$29671[rsp]
  0025e	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR dataUnit$29671[rsp], rax
  00266	48 8b 46 48	 mov	 rax, QWORD PTR [rsi+72]
  0026a	48 03 d5	 add	 rdx, rbp
  0026d	b9 01 00 00 00	 mov	 ecx, 1
  00272	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00277	e8 00 00 00 00	 call	 EncryptionThreadPoolDoWork
$LN70@MainThread:

; 587  : 						}
; 588  : 					}
; 589  : 
; 590  : 					memcpy (dataBuffer, buffer + (item->OriginalOffset.LowPart & (ENCRYPTION_DATA_UNIT_SIZE - 1)), item->OriginalLength);

  0027c	8b 57 18	 mov	 edx, DWORD PTR [rdi+24]
  0027f	44 8b 47 14	 mov	 r8d, DWORD PTR [rdi+20]
  00283	49 8b cc	 mov	 rcx, r12
  00286	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  0028c	48 03 d5	 add	 rdx, rbp
  0028f	e8 00 00 00 00	 call	 memcpy
$LN31@MainThread:

; 591  : 				}
; 592  : 
; 593  : 				TCfree (buffer);

  00294	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00299	48 8b cd	 mov	 rcx, rbp
  0029c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 594  : 				CompleteOriginalIrp (item, item->Status, NT_SUCCESS (item->Status) ? item->OriginalLength : 0);

  002a2	8b 57 20	 mov	 edx, DWORD PTR [rdi+32]
  002a5	41 3b d7	 cmp	 edx, r15d
  002a8	7c 05		 jl	 SHORT $LN51@MainThread
  002aa	8b 47 14	 mov	 eax, DWORD PTR [rdi+20]
  002ad	eb 03		 jmp	 SHORT $LN52@MainThread
$LN51@MainThread:
  002af	41 8b c7	 mov	 eax, r15d
$LN52@MainThread:
  002b2	44 8b c0	 mov	 r8d, eax

; 595  : 				continue;

  002b5	e9 ce fe ff ff	 jmp	 $LN135@MainThread
$LN33@MainThread:

; 596  : 			}
; 597  : 
; 598  : 			// Validate offset and length
; 599  : 			if (item->OriginalLength == 0
; 600  : 				|| (item->OriginalLength & (ENCRYPTION_DATA_UNIT_SIZE - 1)) != 0
; 601  : 				|| (item->OriginalOffset.QuadPart & (ENCRYPTION_DATA_UNIT_SIZE - 1)) != 0
; 602  : 				|| (!queue->IsFilterDevice && item->OriginalOffset.QuadPart + item->OriginalLength > queue->VirtualDeviceLength))

  002ba	45 3b c7	 cmp	 r8d, r15d
$LN127@MainThread:
  002bd	74 7d		 je	 SHORT $LN141@MainThread
  002bf	41 f7 c0 ff 01
	00 00		 test	 r8d, 511		; 000001ffH
  002c6	75 74		 jne	 SHORT $LN141@MainThread
  002c8	4c 8b 4f 18	 mov	 r9, QWORD PTR [rdi+24]
  002cc	49 f7 c1 ff 01
	00 00		 test	 r9, 511			; 000001ffH
  002d3	75 67		 jne	 SHORT $LN141@MainThread
  002d5	41 3b cf	 cmp	 ecx, r15d
  002d8	0f 85 b5 00 00
	00		 jne	 $LN25@MainThread
  002de	41 8b c0	 mov	 eax, r8d
  002e1	49 03 c1	 add	 rax, r9
  002e4	48 3b 46 58	 cmp	 rax, QWORD PTR [rsi+88]
  002e8	7f 52		 jg	 SHORT $LN141@MainThread

; 603  : 			{
; 604  : 				CompleteOriginalIrp (item, STATUS_INVALID_PARAMETER, 0);
; 605  : 				continue;
; 606  : 			}
; 607  : 
; 608  : #ifdef TC_TRACE_IO_QUEUE
; 609  : 			Dump ("Q  %I64d [%I64d] %c len=%d\n", item->OriginalOffset.QuadPart, GetElapsedTime (&queue->LastPerformanceCounter), item->Write ? 'W' : 'R', item->OriginalLength);
; 610  : #endif
; 611  : 
; 612  : 			if (!queue->IsFilterDevice)

  002ea	41 3b cf	 cmp	 ecx, r15d
  002ed	0f 85 a0 00 00
	00		 jne	 $LN25@MainThread

; 613  : 			{
; 614  : 				// Adjust the offset for host file or device
; 615  : 				if (queue->CryptoInfo->hiddenVolume)

  002f3	48 8b 46 48	 mov	 rax, QWORD PTR [rsi+72]
  002f7	44 39 b8 a0 29
	00 00		 cmp	 DWORD PTR [rax+10656], r15d
  002fe	74 09		 je	 SHORT $LN24@MainThread

; 616  : 					item->OriginalOffset.QuadPart += queue->CryptoInfo->hiddenVolumeOffset;

  00300	48 8b 80 18 44
	00 00		 mov	 rax, QWORD PTR [rax+17432]

; 617  : 				else

  00307	eb 07		 jmp	 SHORT $LN130@MainThread
$LN24@MainThread:

; 618  : 					item->OriginalOffset.QuadPart += queue->CryptoInfo->volDataAreaOffset; 

  00309	48 8b 80 08 44
	00 00		 mov	 rax, QWORD PTR [rax+17416]
$LN130@MainThread:
  00310	49 8d 0c 01	 lea	 rcx, QWORD PTR [r9+rax]
  00314	48 89 4f 18	 mov	 QWORD PTR [rdi+24], rcx

; 619  : 
; 620  : 				// Hidden volume protection
; 621  : 				if (item->Write && queue->CryptoInfo->bProtectHiddenVolume)

  00318	44 39 7f 10	 cmp	 DWORD PTR [rdi+16], r15d
  0031c	0f 84 36 01 00
	00		 je	 $LN16@MainThread
  00322	4c 8b 56 48	 mov	 r10, QWORD PTR [rsi+72]
  00326	45 39 ba 00 44
	00 00		 cmp	 DWORD PTR [r10+17408], r15d
  0032d	0f 84 25 01 00
	00		 je	 $LN16@MainThread

; 622  : 				{
; 623  : 					// If there has already been a write operation denied in order to protect the
; 624  : 					// hidden volume (since the volume mount time)
; 625  : 					if (queue->CryptoInfo->bHiddenVolProtectionAction)	

  00333	45 39 ba 04 44
	00 00		 cmp	 DWORD PTR [r10+17412], r15d
  0033a	74 0a		 je	 SHORT $LN21@MainThread
$LN141@MainThread:

; 626  : 					{
; 627  : 						// Do not allow writing to this volume anymore. This is to fake a complete volume
; 628  : 						// or system failure (otherwise certain kinds of inconsistency within the file
; 629  : 						// system could indicate that this volume has used hidden volume protection).
; 630  : 						CompleteOriginalIrp (item, STATUS_INVALID_PARAMETER, 0);

  0033c	ba 0d 00 00 c0	 mov	 edx, -1073741811	; ffffffffc000000dH

; 631  : 						continue;

  00341	e9 4b 01 00 00	 jmp	 $LN140@MainThread
$LN21@MainThread:

; 632  : 					}
; 633  : 
; 634  : 					// Verify that no byte is going to be written to the hidden volume area
; 635  : 					if (RegionsOverlap ((unsigned __int64) item->OriginalOffset.QuadPart,
; 636  : 						(unsigned __int64) item->OriginalOffset.QuadPart + item->OriginalLength - 1,
; 637  : 						queue->CryptoInfo->hiddenVolumeOffset,
; 638  : 						(unsigned __int64) queue->CryptoInfo->hiddenVolumeOffset + queue->CryptoInfo->hiddenVolumeProtectedSize - 1))

  00346	4c 8b 47 18	 mov	 r8, QWORD PTR [rdi+24]
  0034a	4d 8b 8a 18 44
	00 00		 mov	 r9, QWORD PTR [r10+17432]
  00351	8b 47 14	 mov	 eax, DWORD PTR [rdi+20]
  00354	4a 8d 4c 00 ff	 lea	 rcx, QWORD PTR [rax+r8-1]
  00359	49 8b 82 20 44
	00 00		 mov	 rax, QWORD PTR [r10+17440]
  00360	41 8b d7	 mov	 edx, r15d
  00363	49 3b c9	 cmp	 rcx, r9
  00366	4a 8d 4c 08 ff	 lea	 rcx, QWORD PTR [rax+r9-1]
  0036b	41 8b c7	 mov	 eax, r15d
  0036e	0f 93 c2	 setae	 dl
  00371	4c 3b c1	 cmp	 r8, rcx
  00374	0f 96 c0	 setbe	 al
  00377	4d 3b c1	 cmp	 r8, r9
  0037a	0f 42 c2	 cmovb	 eax, edx
  0037d	41 3b c7	 cmp	 eax, r15d
  00380	0f 84 d2 00 00
	00		 je	 $LN16@MainThread

; 639  : 					{
; 640  : 						Dump ("Hidden volume protection triggered: write %I64d-%I64d (protected %I64d-%I64d)\n", item->OriginalOffset.QuadPart, item->OriginalOffset.QuadPart + item->OriginalLength - 1, queue->CryptoInfo->hiddenVolumeOffset, queue->CryptoInfo->hiddenVolumeOffset + queue->CryptoInfo->hiddenVolumeProtectedSize - 1);
; 641  : 						queue->CryptoInfo->bHiddenVolProtectionAction = TRUE;

  00386	41 c7 82 04 44
	00 00 01 00 00
	00		 mov	 DWORD PTR [r10+17412], 1

; 642  : 
; 643  : 						// Deny this write operation to prevent the hidden volume from being overwritten
; 644  : 						CompleteOriginalIrp (item, STATUS_INVALID_PARAMETER, 0);
; 645  : 						continue;

  00391	eb a9		 jmp	 SHORT $LN141@MainThread
$LN25@MainThread:

; 646  : 					}
; 647  : 				}
; 648  : 			}
; 649  : 			else if (item->Write
; 650  : 				&& RegionsOverlap (item->OriginalOffset.QuadPart, item->OriginalOffset.QuadPart + item->OriginalLength - 1, TC_BOOT_VOLUME_HEADER_SECTOR_OFFSET, TC_BOOT_VOLUME_HEADER_SECTOR_OFFSET + TC_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE - 1))

  00393	44 8b 57 10	 mov	 r10d, DWORD PTR [rdi+16]
  00397	45 3b d7	 cmp	 r10d, r15d
  0039a	0f 84 b8 00 00
	00		 je	 $LN16@MainThread
  003a0	41 8b c0	 mov	 eax, r8d
  003a3	41 8b d7	 mov	 edx, r15d
  003a6	4a 8d 4c 08 ff	 lea	 rcx, QWORD PTR [rax+r9-1]
  003ab	41 8b c7	 mov	 eax, r15d
  003ae	48 81 f9 00 7c
	00 00		 cmp	 rcx, 31744		; 00007c00H
  003b5	0f 93 c2	 setae	 dl
  003b8	49 81 f9 ff 7d
	00 00		 cmp	 r9, 32255		; 00007dffH
  003bf	0f 96 c0	 setbe	 al
  003c2	49 81 f9 00 7c
	00 00		 cmp	 r9, 31744		; 00007c00H
  003c9	0f 42 c2	 cmovb	 eax, edx
  003cc	41 3b c7	 cmp	 eax, r15d
  003cf	74 0a		 je	 SHORT $LN18@MainThread
$LN15@MainThread:

; 651  : 			{
; 652  : 				// Prevent inappropriately designed software from damaging important data that may be out of sync with the backup on the Rescue Disk (such as the end of the encrypted area).
; 653  : 				Dump ("Preventing write to the system encryption key data area\n");
; 654  : 				CompleteOriginalIrp (item, STATUS_MEDIA_WRITE_PROTECTED, 0);

  003d1	ba a2 00 00 c0	 mov	 edx, -1073741662	; ffffffffc00000a2H

; 655  : 				continue;

  003d6	e9 b6 00 00 00	 jmp	 $LN140@MainThread
$LN18@MainThread:

; 656  : 			}
; 657  : 			else if (item->Write && IsHiddenSystemRunning()
; 658  : 				&& (RegionsOverlap (item->OriginalOffset.QuadPart, item->OriginalOffset.QuadPart + item->OriginalLength - 1, TC_SECTOR_SIZE_BIOS, TC_BOOT_LOADER_AREA_SECTOR_COUNT * TC_SECTOR_SIZE_BIOS - 1)
; 659  : 				 || RegionsOverlap (item->OriginalOffset.QuadPart, item->OriginalOffset.QuadPart + item->OriginalLength - 1, GetBootDriveLength(), _I64_MAX)))

  003db	45 3b d7	 cmp	 r10d, r15d
  003de	74 78		 je	 SHORT $LN16@MainThread
  003e0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  003e7	49 3b c7	 cmp	 rax, r15
  003ea	74 6c		 je	 SHORT $LN16@MainThread
  003ec	44 39 b8 e0 02
	00 00		 cmp	 DWORD PTR [rax+736], r15d
  003f3	74 63		 je	 SHORT $LN16@MainThread
  003f5	41 8b c0	 mov	 eax, r8d
  003f8	41 8b cf	 mov	 ecx, r15d
  003fb	4e 8d 44 08 ff	 lea	 r8, QWORD PTR [rax+r9-1]
  00400	41 8b c7	 mov	 eax, r15d
  00403	49 81 f8 00 02
	00 00		 cmp	 r8, 512			; 00000200H
  0040a	0f 93 c1	 setae	 cl
  0040d	49 81 f9 ff 7d
	00 00		 cmp	 r9, 32255		; 00007dffH
  00414	0f 96 c0	 setbe	 al
  00417	49 81 f9 00 02
	00 00		 cmp	 r9, 512			; 00000200H
  0041e	0f 42 c1	 cmovb	 eax, ecx
  00421	41 3b c7	 cmp	 eax, r15d
  00424	75 ab		 jne	 SHORT $LN15@MainThread
  00426	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveLength
  0042d	41 8b d7	 mov	 edx, r15d
  00430	41 8b cf	 mov	 ecx, r15d
  00433	4c 3b c0	 cmp	 r8, rax
  00436	49 b8 ff ff ff
	ff ff ff ff 7f	 mov	 r8, 9223372036854775807	; 7fffffffffffffffH
  00440	0f 93 c2	 setae	 dl
  00443	4d 3b c8	 cmp	 r9, r8
  00446	0f 96 c1	 setbe	 cl
  00449	4c 3b c8	 cmp	 r9, rax
  0044c	0f 42 ca	 cmovb	 ecx, edx
  0044f	41 3b cf	 cmp	 ecx, r15d

; 660  : 			{
; 661  : 				Dump ("Preventing write to boot loader or host protected area\n");
; 662  : 				CompleteOriginalIrp (item, STATUS_MEDIA_WRITE_PROTECTED, 0);
; 663  : 				continue;

  00452	0f 85 79 ff ff
	ff		 jne	 $LN15@MainThread
$LN16@MainThread:

; 664  : 			}
; 665  : 
; 666  : 			dataBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe (irp->MdlAddress, HighPagePriority);

  00458	49 8b 4d 08	 mov	 rcx, QWORD PTR [r13+8]
  0045c	f6 41 0a 05	 test	 BYTE PTR [rcx+10], 5
  00460	74 06		 je	 SHORT $LN53@MainThread
  00462	4c 8b 71 18	 mov	 r14, QWORD PTR [rcx+24]
  00466	eb 1f		 jmp	 SHORT $LN54@MainThread
$LN53@MainThread:
  00468	45 33 c9	 xor	 r9d, r9d
  0046b	33 d2		 xor	 edx, edx
  0046d	c7 44 24 28 20
	00 00 00	 mov	 DWORD PTR [rsp+40], 32	; 00000020H
  00475	45 8d 41 01	 lea	 r8d, QWORD PTR [r9+1]
  00479	44 89 7c 24 20	 mov	 DWORD PTR [rsp+32], r15d
  0047e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmMapLockedPagesSpecifyCache
  00484	4c 8b f0	 mov	 r14, rax
$LN54@MainThread:

; 667  : 
; 668  : 			if (dataBuffer == NULL)

  00487	4d 3b f7	 cmp	 r14, r15
  0048a	75 0d		 jne	 SHORT $LN14@MainThread

; 669  : 			{
; 670  : 				CompleteOriginalIrp (item, STATUS_INSUFFICIENT_RESOURCES, 0);

  0048c	ba 9a 00 00 c0	 mov	 edx, -1073741670	; ffffffffc000009aH
$LN140@MainThread:
  00491	48 8b cf	 mov	 rcx, rdi

; 671  : 				continue;

  00494	e9 44 fc ff ff	 jmp	 $LN142@MainThread
$LN14@MainThread:

; 672  : 			}
; 673  : 
; 674  : 			// Divide data block to fragments to enable efficient overlapping of encryption and IO operations
; 675  : 
; 676  : 			dataRemaining = item->OriginalLength;

  00499	44 8b 6f 14	 mov	 r13d, DWORD PTR [rdi+20]

; 677  : 			fragmentOffset = item->OriginalOffset;

  0049d	48 8b 5f 18	 mov	 rbx, QWORD PTR [rdi+24]

; 678  : 
; 679  : 			while (dataRemaining > 0)

  004a1	45 3b ef	 cmp	 r13d, r15d
  004a4	0f 86 fa 01 00
	00		 jbe	 $LN118@MainThread
$LL13@MainThread:

; 680  : 			{
; 681  : 				BOOL isLastFragment = dataRemaining <= TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE;
; 682  : 				
; 683  : 				ULONG dataFragmentLength = isLastFragment ? dataRemaining : TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE;
; 684  : 				activeFragmentBuffer = (activeFragmentBuffer == queue->FragmentBufferA ? queue->FragmentBufferB : queue->FragmentBufferA);

  004aa	48 8b 86 68 01
	00 00		 mov	 rax, QWORD PTR [rsi+360]
  004b1	41 81 fd 00 00
	04 00		 cmp	 r13d, 262144		; 00040000H
  004b8	41 bc 00 00 04
	00		 mov	 r12d, 262144		; 00040000H
  004be	41 0f 96 c7	 setbe	 r15b
  004c2	45 85 ff	 test	 r15d, r15d
  004c5	45 0f 45 e5	 cmovne	 r12d, r13d
  004c9	48 3b e8	 cmp	 rbp, rax
  004cc	75 07		 jne	 SHORT $LN55@MainThread
  004ce	48 8b 86 70 01
	00 00		 mov	 rax, QWORD PTR [rsi+368]
$LN55@MainThread:
  004d5	48 89 44 24 70	 mov	 QWORD PTR activeFragmentBuffer$1$[rsp], rax

; 685  : 
; 686  : 				InterlockedIncrement (&queue->IoThreadPendingRequestCount);

  004da	f0 83 86 00 02
	00 00 01	 lock add DWORD PTR [rsi+512], 1

; 687  : 
; 688  : 				// Create IO request
; 689  : 				request = GetPoolBuffer (queue, sizeof (EncryptedIoRequest));

  004e2	ba 60 00 00 00	 mov	 edx, 96			; 00000060H
  004e7	48 8b ce	 mov	 rcx, rsi
  004ea	e8 00 00 00 00	 call	 GetPoolBuffer

; 690  : 				request->Item = item;
; 691  : 				request->CompleteOriginalIrp = isLastFragment;
; 692  : 				request->Offset = fragmentOffset;
; 693  : 				request->Data = activeFragmentBuffer;

  004ef	4c 8b 4c 24 70	 mov	 r9, QWORD PTR activeFragmentBuffer$1$[rsp]

; 694  : 				request->OrigDataBufferFragment = dataBuffer;
; 695  : 				request->Length = dataFragmentLength;
; 696  : 
; 697  : 				if (queue->IsFilterDevice)

  004f4	45 33 d2	 xor	 r10d, r10d
  004f7	48 89 38	 mov	 QWORD PTR [rax], rdi
  004fa	44 89 78 08	 mov	 DWORD PTR [rax+8], r15d
  004fe	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00502	4c 89 48 30	 mov	 QWORD PTR [rax+48], r9
  00506	4c 89 70 38	 mov	 QWORD PTR [rax+56], r14
  0050a	44 89 60 18	 mov	 DWORD PTR [rax+24], r12d
  0050e	48 8b e8	 mov	 rbp, rax
  00511	44 39 56 68	 cmp	 DWORD PTR [rsi+104], r10d
  00515	74 59		 je	 SHORT $LN11@MainThread

; 698  : 				{
; 699  : 					if (queue->EncryptedAreaStart == -1 || queue->EncryptedAreaEnd == -1)

  00517	48 83 7e 78 ff	 cmp	 QWORD PTR [rsi+120], -1
  0051c	74 4c		 je	 SHORT $LN9@MainThread
  0051e	48 8b 86 80 00
	00 00		 mov	 rax, QWORD PTR [rsi+128]
  00525	48 83 f8 ff	 cmp	 rax, -1
  00529	74 3f		 je	 SHORT $LN9@MainThread

; 702  : 					}
; 703  : 					else
; 704  : 					{
; 705  : 						// Get intersection of data fragment with encrypted area
; 706  : 						GetIntersection (fragmentOffset.QuadPart, dataFragmentLength, queue->EncryptedAreaStart, queue->EncryptedAreaEnd, &intersectStart, &intersectLength);

  0052b	48 8b 96 80 00
	00 00		 mov	 rdx, QWORD PTR [rsi+128]
  00532	4c 8b 46 78	 mov	 r8, QWORD PTR [rsi+120]
  00536	49 8d 4c 1c ff	 lea	 rcx, QWORD PTR [r12+rbx-1]
  0053b	48 3b ca	 cmp	 rcx, rdx
  0053e	48 0f 46 d1	 cmovbe	 rdx, rcx
  00542	49 3b d8	 cmp	 rbx, r8
  00545	4c 0f 43 c3	 cmovae	 r8, rbx
  00549	4c 3b c2	 cmp	 r8, rdx
  0054c	76 05		 jbe	 SHORT $LN89@MainThread
  0054e	41 8b d2	 mov	 edx, r10d
  00551	eb 08		 jmp	 SHORT $LN121@MainThread
$LN89@MainThread:
  00553	41 2b d0	 sub	 edx, r8d
  00556	83 c2 01	 add	 edx, 1
  00559	75 03		 jne	 SHORT $LN86@MainThread
$LN121@MainThread:
  0055b	4c 8b c3	 mov	 r8, rbx
$LN86@MainThread:

; 707  : 
; 708  : 						request->EncryptedOffset = intersectStart - fragmentOffset.QuadPart;

  0055e	4c 2b c3	 sub	 r8, rbx

; 709  : 						request->EncryptedLength = intersectLength;

  00561	89 55 28	 mov	 DWORD PTR [rbp+40], edx
  00564	4c 89 45 20	 mov	 QWORD PTR [rbp+32], r8
  00568	eb 0e		 jmp	 SHORT $LN7@MainThread
$LN9@MainThread:

; 700  : 					{
; 701  : 						request->EncryptedLength = 0;

  0056a	44 89 55 28	 mov	 DWORD PTR [rbp+40], r10d

; 710  : 					}
; 711  : 				}
; 712  : 				else

  0056e	eb 08		 jmp	 SHORT $LN7@MainThread
$LN11@MainThread:

; 713  : 				{
; 714  : 					request->EncryptedOffset = 0;

  00570	4c 89 50 20	 mov	 QWORD PTR [rax+32], r10

; 715  : 					request->EncryptedLength = dataFragmentLength;

  00574	44 89 60 28	 mov	 DWORD PTR [rax+40], r12d
$LN7@MainThread:

; 716  : 				}
; 717  : 
; 718  : 				AcquireFragmentBuffer (queue, activeFragmentBuffer);

  00578	b8 0d 00 00 c0	 mov	 eax, -1073741811	; ffffffffc000000dH
  0057d	4c 3b 8e 68 01
	00 00		 cmp	 r9, QWORD PTR [rsi+360]
  00584	75 09		 jne	 SHORT $LN94@MainThread
  00586	48 8d 8e 78 01
	00 00		 lea	 rcx, QWORD PTR [rsi+376]
  0058d	eb 14		 jmp	 SHORT $LN132@MainThread
$LN94@MainThread:
  0058f	4c 3b 8e 70 01
	00 00		 cmp	 r9, QWORD PTR [rsi+368]
  00596	0f 85 2a 01 00
	00		 jne	 $LN115@MainThread
  0059c	48 8d 8e 90 01
	00 00		 lea	 rcx, QWORD PTR [rsi+400]
$LN132@MainThread:
  005a3	45 33 c9	 xor	 r9d, r9d
  005a6	45 33 c0	 xor	 r8d, r8d
  005a9	33 d2		 xor	 edx, edx
  005ab	4c 89 54 24 20	 mov	 QWORD PTR [rsp+32], r10
  005b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  005b6	85 c0		 test	 eax, eax
  005b8	0f 88 08 01 00
	00		 js	 $LN115@MainThread

; 719  : 
; 720  : 				if (item->Write)

  005be	83 7f 10 00	 cmp	 DWORD PTR [rdi+16], 0
  005c2	74 7f		 je	 SHORT $LN98@MainThread

; 721  : 				{
; 722  : 					// Encrypt data
; 723  : 					memcpy (activeFragmentBuffer, dataBuffer, dataFragmentLength);

  005c4	45 8b c4	 mov	 r8d, r12d
  005c7	4c 8b 64 24 70	 mov	 r12, QWORD PTR activeFragmentBuffer$1$[rsp]
  005cc	49 8b d6	 mov	 rdx, r14
  005cf	49 8b cc	 mov	 rcx, r12
  005d2	e8 00 00 00 00	 call	 memcpy

; 724  : 
; 725  : 					if (request->EncryptedLength > 0)

  005d7	44 8b 4d 28	 mov	 r9d, DWORD PTR [rbp+40]
  005db	45 85 c9	 test	 r9d, r9d
  005de	74 63		 je	 SHORT $LN98@MainThread

; 726  : 					{
; 727  : 						UINT64_STRUCT dataUnit;
; 728  : 						ASSERT (request->EncryptedOffset + request->EncryptedLength <= request->Offset.QuadPart + request->Length);
; 729  : 
; 730  : 						dataUnit.Value = (request->Offset.QuadPart + request->EncryptedOffset) / ENCRYPTION_DATA_UNIT_SIZE;

  005e0	4c 8b 45 20	 mov	 r8, QWORD PTR [rbp+32]
  005e4	48 8b 45 10	 mov	 rax, QWORD PTR [rbp+16]

; 731  : 
; 732  : 						if (queue->CryptoInfo->bPartitionInInactiveSysEncScope)

  005e8	48 8b 4e 48	 mov	 rcx, QWORD PTR [rsi+72]
  005ec	49 03 c0	 add	 rax, r8
  005ef	48 99		 cdq
  005f1	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  005f7	48 03 c2	 add	 rax, rdx
  005fa	48 c1 f8 09	 sar	 rax, 9
  005fe	83 b9 28 44 00
	00 00		 cmp	 DWORD PTR [rcx+17448], 0
  00605	48 89 44 24 78	 mov	 QWORD PTR dataUnit$29718[rsp], rax
  0060a	74 09		 je	 SHORT $LN4@MainThread

; 733  : 							dataUnit.Value += queue->CryptoInfo->FirstDataUnitNo.Value;

  0060c	48 03 81 30 44
	00 00		 add	 rax, QWORD PTR [rcx+17456]
  00613	eb 10		 jmp	 SHORT $LN133@MainThread
$LN4@MainThread:

; 734  : 						else if (queue->RemapEncryptedArea)

  00615	83 be 8c 00 00
	00 00		 cmp	 DWORD PTR [rsi+140], 0
  0061c	74 0c		 je	 SHORT $LN2@MainThread

; 735  : 							dataUnit.Value += queue->RemappedAreaDataUnitOffset;

  0061e	48 03 86 98 00
	00 00		 add	 rax, QWORD PTR [rsi+152]
$LN133@MainThread:
  00625	48 89 44 24 78	 mov	 QWORD PTR dataUnit$29718[rsp], rax
$LN2@MainThread:

; 736  : 								
; 737  : 						EncryptDataUnits (activeFragmentBuffer + request->EncryptedOffset, &dataUnit, request->EncryptedLength / ENCRYPTION_DATA_UNIT_SIZE, queue->CryptoInfo);

  0062a	4b 8d 14 20	 lea	 rdx, QWORD PTR [r8+r12]
  0062e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00633	4c 8d 44 24 78	 lea	 r8, QWORD PTR dataUnit$29718[rsp]
  00638	41 c1 e9 09	 shr	 r9d, 9
  0063c	33 c9		 xor	 ecx, ecx
  0063e	e8 00 00 00 00	 call	 EncryptionThreadPoolDoWork
$LN98@MainThread:

; 738  : 					}
; 739  : 				}
; 740  : 
; 741  : 				// Queue IO request
; 742  : 				ExInterlockedInsertTailList (&queue->IoThreadQueue, &request->ListEntry, &queue->IoThreadQueueLock);

  00643	4c 8d 86 10 01
	00 00		 lea	 r8, QWORD PTR [rsi+272]
  0064a	48 8d 55 40	 lea	 rdx, QWORD PTR [rbp+64]
  0064e	48 8d 8e 00 01
	00 00		 lea	 rcx, QWORD PTR [rsi+256]
  00655	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExInterlockedInsertTailList

; 743  : 				KeSetEvent (&queue->IoThreadQueueNotEmptyEvent, IO_DISK_INCREMENT, FALSE);

  0065b	45 33 c0	 xor	 r8d, r8d
  0065e	48 8d 8e 18 01
	00 00		 lea	 rcx, QWORD PTR [rsi+280]
  00665	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  00669	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 744  : 
; 745  : 				if (isLastFragment)

  0066f	45 85 ff	 test	 r15d, r15d
  00672	75 28		 jne	 SHORT $LN123@MainThread
  00674	48 8b 6c 24 70	 mov	 rbp, QWORD PTR activeFragmentBuffer$1$[rsp]

; 746  : 					break;
; 747  : 
; 748  : 				dataRemaining -= TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE;

  00679	41 81 c5 00 00
	fc ff		 add	 r13d, -262144		; fffc0000H
  00680	45 33 ff	 xor	 r15d, r15d

; 749  : 				dataBuffer += TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE;

  00683	49 81 c6 00 00
	04 00		 add	 r14, 262144		; 00040000H

; 750  : 				fragmentOffset.QuadPart += TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE;

  0068a	48 81 c3 00 00
	04 00		 add	 rbx, 262144		; 00040000H
  00691	45 3b ef	 cmp	 r13d, r15d
  00694	0f 87 10 fe ff
	ff		 ja	 $LL13@MainThread

; 751  : 			}
; 752  : 		}

  0069a	eb 08		 jmp	 SHORT $LN118@MainThread
$LN123@MainThread:

; 484  : 	EncryptedIoQueue *queue = (EncryptedIoQueue *) threadArg;
; 485  : 	PLIST_ENTRY listEntry;
; 486  : 	EncryptedIoQueueItem *item;
; 487  : 
; 488  : 	LARGE_INTEGER fragmentOffset;
; 489  : 	ULONG dataRemaining;
; 490  : 	PUCHAR activeFragmentBuffer = queue->FragmentBufferA;

  0069c	45 33 ff	 xor	 r15d, r15d
$LN128@MainThread:
  0069f	48 8b 6c 24 70	 mov	 rbp, QWORD PTR activeFragmentBuffer$1$[rsp]
$LN118@MainThread:

; 502  : 			continue;
; 503  : 
; 504  : 		while ((listEntry = ExInterlockedRemoveHeadList (&queue->MainThreadQueue, &queue->MainThreadQueueLock)))

  006a4	48 8d 96 d8 00
	00 00		 lea	 rdx, QWORD PTR [rsi+216]
  006ab	48 8d 8e c8 00
	00 00		 lea	 rcx, QWORD PTR [rsi+200]
  006b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExInterlockedRemoveHeadList
  006b8	49 3b c7	 cmp	 rax, r15
  006bb	0f 85 b9 f9 ff
	ff		 jne	 $LL42@MainThread

; 498  : 
; 499  : 	while (!queue->ThreadExitRequested)

  006c1	e9 7e f9 ff ff	 jmp	 $LN112@MainThread
$LN115@MainThread:

; 716  : 				}
; 717  : 
; 718  : 				AcquireFragmentBuffer (queue, activeFragmentBuffer);

  006c6	45 33 c9	 xor	 r9d, r9d
  006c9	4c 63 c0	 movsxd	 r8, eax
  006cc	ba cb 00 00 00	 mov	 edx, 203		; 000000cbH
  006d1	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  006d5	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  006de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  006e4	cc		 int	 3
$LN122@MainThread:

; 753  : 	}
; 754  : 
; 755  : 	PsTerminateSystemThread (STATUS_SUCCESS);

  006e5	33 c9		 xor	 ecx, ecx

; 756  : }

  006e7	48 8b 9c 24 88
	00 00 00	 mov	 rbx, QWORD PTR [rsp+136]
  006ef	48 83 c4 30	 add	 rsp, 48			; 00000030H
  006f3	41 5f		 pop	 r15
  006f5	41 5e		 pop	 r14
  006f7	41 5d		 pop	 r13
  006f9	41 5c		 pop	 r12
  006fb	5f		 pop	 rdi
  006fc	5e		 pop	 rsi
  006fd	5d		 pop	 rbp
  006fe	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_PsTerminateSystemThread
$LN124@MainThread:
MainThreadProc ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\home\public\desktop\projects\ciphershed\src\common\crypto.c
pdata	SEGMENT
$pdata$CompletionThreadProc DD imagerel CompletionThreadProc
	DD	imagerel CompletionThreadProc+354
	DD	imagerel $unwind$CompletionThreadProc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CompletionThreadProc DD 081201H
	DD	0c5412H
	DD	0b3412H
	DD	0c00e5212H
	DD	0600b700cH
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed\src\driver\encryptedioqueue.c
xdata	ENDS
;	COMDAT CompletionThreadProc
_TEXT	SEGMENT
dataUnit$ = 80
threadArg$ = 80
CompletionThreadProc PROC				; COMDAT

; 225  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 226  : 	EncryptedIoQueue *queue = (EncryptedIoQueue *) threadArg;
; 227  : 	PLIST_ENTRY listEntry;
; 228  : 	EncryptedIoRequest *request;
; 229  : 	UINT64_STRUCT dataUnit;
; 230  : 
; 231  : 	if (IsEncryptionThreadPoolRunning())

  00012	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ThreadPoolRunning
  00018	48 8b d9	 mov	 rbx, rcx
  0001b	85 c0		 test	 eax, eax
  0001d	0f 84 16 01 00
	00		 je	 $LN6@Completion

; 232  : 		KeSetPriorityThread (KeGetCurrentThread(), LOW_REALTIME_PRIORITY);

  00023	65 48 8b 0c 25
	88 01 00 00	 mov	 rcx, QWORD PTR gs:392
  0002c	ba 10 00 00 00	 mov	 edx, 16
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetPriorityThread

; 233  : 
; 234  : 	while (!queue->ThreadExitRequested)

  00037	e9 fd 00 00 00	 jmp	 $LN6@Completion
$LL11@Completion:

; 235  : 	{
; 236  : 		if (!NT_SUCCESS (KeWaitForSingleObject (&queue->CompletionThreadQueueNotEmptyEvent, Executive, KernelMode, FALSE, NULL)))

  0003c	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00042	48 8d 8b 50 01
	00 00		 lea	 rcx, QWORD PTR [rbx+336]
  00049	45 33 c9	 xor	 r9d, r9d
  0004c	45 33 c0	 xor	 r8d, r8d
  0004f	33 d2		 xor	 edx, edx
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  00057	85 c0		 test	 eax, eax
  00059	0f 88 da 00 00
	00		 js	 $LN6@Completion

; 237  : 			continue;
; 238  : 
; 239  : 		if (queue->ThreadExitRequested)

  0005f	8b 83 34 02 00
	00		 mov	 eax, DWORD PTR [rbx+564]
  00065	85 c0		 test	 eax, eax
  00067	0f 85 da 00 00
	00		 jne	 $LN26@Completion

; 240  : 			break;
; 241  : 
; 242  : 		while ((listEntry = ExInterlockedRemoveHeadList (&queue->CompletionThreadQueue, &queue->CompletionThreadQueueLock)))

  0006d	e9 aa 00 00 00	 jmp	 $LN31@Completion
$LL7@Completion:

; 243  : 		{
; 244  : 			request = CONTAINING_RECORD (listEntry, EncryptedIoRequest, CompletionListEntry);

  00072	48 8d 78 b0	 lea	 rdi, QWORD PTR [rax-80]

; 245  : 
; 246  : 			if (request->EncryptedLength > 0 && NT_SUCCESS (request->Item->Status))

  00076	44 8b 4f 28	 mov	 r9d, DWORD PTR [rdi+40]
  0007a	45 85 c9	 test	 r9d, r9d
  0007d	74 73		 je	 SHORT $LN21@Completion
  0007f	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00082	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  00086	7c 6a		 jl	 SHORT $LN21@Completion

; 247  : 			{
; 248  : 				ASSERT (request->EncryptedOffset + request->EncryptedLength <= request->Offset.QuadPart + request->Length);
; 249  : 				dataUnit.Value = (request->Offset.QuadPart + request->EncryptedOffset) / ENCRYPTION_DATA_UNIT_SIZE;

  00088	4c 8b 47 20	 mov	 r8, QWORD PTR [rdi+32]
  0008c	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]

; 250  : 
; 251  : 				if (queue->CryptoInfo->bPartitionInInactiveSysEncScope)

  00090	48 8b 4b 48	 mov	 rcx, QWORD PTR [rbx+72]
  00094	49 03 c0	 add	 rax, r8
  00097	48 99		 cdq
  00099	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  0009f	48 03 c2	 add	 rax, rdx
  000a2	48 c1 f8 09	 sar	 rax, 9
  000a6	83 b9 28 44 00
	00 00		 cmp	 DWORD PTR [rcx+17448], 0
  000ad	48 89 44 24 50	 mov	 QWORD PTR dataUnit$[rsp], rax
  000b2	74 09		 je	 SHORT $LN4@Completion

; 252  : 					dataUnit.Value += queue->CryptoInfo->FirstDataUnitNo.Value;

  000b4	48 03 81 30 44
	00 00		 add	 rax, QWORD PTR [rcx+17456]
  000bb	eb 10		 jmp	 SHORT $LN32@Completion
$LN4@Completion:

; 253  : 				else if (queue->RemapEncryptedArea)

  000bd	83 bb 8c 00 00
	00 00		 cmp	 DWORD PTR [rbx+140], 0
  000c4	74 0c		 je	 SHORT $LN2@Completion

; 254  : 					dataUnit.Value += queue->RemappedAreaDataUnitOffset;

  000c6	48 03 83 98 00
	00 00		 add	 rax, QWORD PTR [rbx+152]
$LN32@Completion:
  000cd	48 89 44 24 50	 mov	 QWORD PTR dataUnit$[rsp], rax
$LN2@Completion:

; 255  : 
; 256  : 				DecryptDataUnits (request->Data + request->EncryptedOffset, &dataUnit, request->EncryptedLength / ENCRYPTION_DATA_UNIT_SIZE, queue->CryptoInfo);

  000d2	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  000d6	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000db	41 c1 e9 09	 shr	 r9d, 9
  000df	49 8d 14 00	 lea	 rdx, QWORD PTR [r8+rax]
  000e3	4c 8d 44 24 50	 lea	 r8, QWORD PTR dataUnit$[rsp]
  000e8	b9 01 00 00 00	 mov	 ecx, 1
  000ed	e8 00 00 00 00	 call	 EncryptionThreadPoolDoWork
$LN21@Completion:

; 257  : 			}
; 258  : 
; 259  : 			if (request->CompleteOriginalIrp)

  000f2	83 7f 08 00	 cmp	 DWORD PTR [rdi+8], 0
  000f6	74 19		 je	 SHORT $LN1@Completion

; 260  : 			{
; 261  : 				CompleteOriginalIrp (request->Item, request->Item->Status,
; 262  : 					NT_SUCCESS (request->Item->Status) ? request->Item->OriginalLength : 0);

  000f8	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  000fb	8b 51 20	 mov	 edx, DWORD PTR [rcx+32]
  000fe	85 d2		 test	 edx, edx
  00100	78 05		 js	 SHORT $LN15@Completion
  00102	8b 41 14	 mov	 eax, DWORD PTR [rcx+20]
  00105	eb 02		 jmp	 SHORT $LN16@Completion
$LN15@Completion:
  00107	33 c0		 xor	 eax, eax
$LN16@Completion:
  00109	44 8b c0	 mov	 r8d, eax
  0010c	e8 00 00 00 00	 call	 CompleteOriginalIrp
$LN1@Completion:

; 263  : 			}
; 264  : 
; 265  : 			ReleasePoolBuffer (queue, request);

  00111	48 8b d7	 mov	 rdx, rdi
  00114	48 8b cb	 mov	 rcx, rbx
  00117	e8 00 00 00 00	 call	 ReleasePoolBuffer
$LN31@Completion:
  0011c	48 8d 93 48 01
	00 00		 lea	 rdx, QWORD PTR [rbx+328]
  00123	48 8d 8b 38 01
	00 00		 lea	 rcx, QWORD PTR [rbx+312]
  0012a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExInterlockedRemoveHeadList
  00130	48 85 c0	 test	 rax, rax
  00133	0f 85 39 ff ff
	ff		 jne	 $LL7@Completion
$LN6@Completion:

; 233  : 
; 234  : 	while (!queue->ThreadExitRequested)

  00139	8b 83 34 02 00
	00		 mov	 eax, DWORD PTR [rbx+564]
  0013f	85 c0		 test	 eax, eax
  00141	0f 84 f5 fe ff
	ff		 je	 $LL11@Completion
$LN26@Completion:

; 266  : 		}
; 267  : 	}
; 268  : 
; 269  : 	PsTerminateSystemThread (STATUS_SUCCESS);

  00147	33 c9		 xor	 ecx, ecx

; 270  : }

  00149	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0014e	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  00153	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00157	41 5c		 pop	 r12
  00159	5f		 pop	 rdi
  0015a	5e		 pop	 rsi
  0015b	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_PsTerminateSystemThread
CompletionThreadProc ENDP
PUBLIC	EncryptedIoQueueStart
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$EncryptedIoQueueStart DD imagerel $LN41
	DD	imagerel $LN41+780
	DD	imagerel $unwind$EncryptedIoQueueStart
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptedIoQueueStart DD 0c1c01H
	DD	0c641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed\src\driver\encryptedioqueue.c
xdata	ENDS
;	COMDAT EncryptedIoQueueStart
_TEXT	SEGMENT
queue$ = 80
EncryptedIoQueueStart PROC				; COMDAT

; 869  : {

$LN41:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 870  : 	NTSTATUS status;
; 871  : 	EncryptedIoQueueBuffer *buffer;
; 872  : 	int i;
; 873  : 
; 874  : 	queue->StartPending = TRUE;
; 875  : 	queue->ThreadExitRequested = FALSE;

  0001c	45 33 f6	 xor	 r14d, r14d
  0001f	48 8b d9	 mov	 rbx, rcx
  00022	41 bf 01 00 00
	00		 mov	 r15d, 1
  00028	44 89 b9 30 02
	00 00		 mov	 DWORD PTR [rcx+560], r15d
  0002f	44 89 b1 34 02
	00 00		 mov	 DWORD PTR [rcx+564], r14d

; 876  : 
; 877  : 	queue->OutstandingIoCount = 0;

  00036	44 89 b1 e0 01
	00 00		 mov	 DWORD PTR [rcx+480], r14d

; 878  : 	queue->IoThreadPendingRequestCount = 0;

  0003d	44 89 b1 00 02
	00 00		 mov	 DWORD PTR [rcx+512], r14d

; 879  : 
; 880  : 	queue->FirstPoolBuffer = NULL;

  00044	4c 89 71 40	 mov	 QWORD PTR [rcx+64], r14

; 881  : 	KeInitializeMutex (&queue->BufferPoolMutex, 0);

  00048	48 83 c1 08	 add	 rcx, 8
  0004c	33 d2		 xor	 edx, edx
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeMutex

; 882  : 
; 883  : 	KeInitializeEvent (&queue->NoOutstandingIoEvent, SynchronizationEvent, FALSE);

  00054	48 8d 8b e8 01
	00 00		 lea	 rcx, QWORD PTR [rbx+488]
  0005b	45 33 c0	 xor	 r8d, r8d
  0005e	41 8b d7	 mov	 edx, r15d
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 884  : 	KeInitializeEvent (&queue->PoolBufferFreeEvent, SynchronizationEvent, FALSE);

  00067	48 8d 8b 08 02
	00 00		 lea	 rcx, QWORD PTR [rbx+520]
  0006e	45 33 c0	 xor	 r8d, r8d
  00071	41 8b d7	 mov	 edx, r15d
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 885  : 	KeInitializeEvent (&queue->QueueResumedEvent, SynchronizationEvent, FALSE);

  0007a	48 8d 8b 48 02
	00 00		 lea	 rcx, QWORD PTR [rbx+584]
  00081	45 33 c0	 xor	 r8d, r8d
  00084	41 8b d7	 mov	 edx, r15d
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 886  : 
; 887  : 	queue->FragmentBufferA = TCalloc (TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE);

  0008d	bf 00 00 04 00	 mov	 edi, 262144		; 00040000H
  00092	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  00098	48 8b d7	 mov	 rdx, rdi
  0009b	33 c9		 xor	 ecx, ecx
  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  000a3	48 89 83 68 01
	00 00		 mov	 QWORD PTR [rbx+360], rax

; 888  : 	if (!queue->FragmentBufferA)

  000aa	49 3b c6	 cmp	 rax, r14
  000ad	0f 84 e1 01 00
	00		 je	 $noMemory$29784

; 889  : 		goto noMemory;
; 890  : 
; 891  : 	queue->FragmentBufferB = TCalloc (TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE);

  000b3	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  000b9	48 8b d7	 mov	 rdx, rdi
  000bc	33 c9		 xor	 ecx, ecx
  000be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  000c4	48 89 83 70 01
	00 00		 mov	 QWORD PTR [rbx+368], rax

; 892  : 	if (!queue->FragmentBufferB)

  000cb	49 3b c6	 cmp	 rax, r14
  000ce	0f 84 c0 01 00
	00		 je	 $noMemory$29784

; 893  : 		goto noMemory;
; 894  : 
; 895  : 	KeInitializeEvent (&queue->FragmentBufferAFreeEvent, SynchronizationEvent, TRUE);

  000d4	48 8d 8b 78 01
	00 00		 lea	 rcx, QWORD PTR [rbx+376]
  000db	45 8a c7	 mov	 r8b, r15b
  000de	41 8b d7	 mov	 edx, r15d
  000e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 896  : 	KeInitializeEvent (&queue->FragmentBufferBFreeEvent, SynchronizationEvent, TRUE);

  000e7	48 8d 8b 90 01
	00 00		 lea	 rcx, QWORD PTR [rbx+400]
  000ee	45 8a c7	 mov	 r8b, r15b
  000f1	41 8b d7	 mov	 edx, r15d
  000f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 897  : 
; 898  : 	queue->ReadAheadBufferValid = FALSE;
; 899  : 	queue->ReadAheadBuffer = TCalloc (TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE);

  000fa	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  00100	48 8b d7	 mov	 rdx, rdi
  00103	33 c9		 xor	 ecx, ecx
  00105	44 89 b3 a8 01
	00 00		 mov	 DWORD PTR [rbx+424], r14d
  0010c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00112	48 89 83 d0 01
	00 00		 mov	 QWORD PTR [rbx+464], rax

; 900  : 	if (!queue->ReadAheadBuffer)

  00119	49 3b c6	 cmp	 rax, r14
  0011c	0f 84 72 01 00
	00		 je	 $noMemory$29784

; 901  : 		goto noMemory;
; 902  : 
; 903  : 	// Preallocate buffers
; 904  : 	for (i = 0; i < TC_ENC_IO_QUEUE_PREALLOCATED_IO_REQUEST_COUNT; ++i)

  00122	41 8b fe	 mov	 edi, r14d
$LL14@EncryptedI@4:

; 905  : 	{
; 906  : 		if (i < TC_ENC_IO_QUEUE_PREALLOCATED_ITEM_COUNT && !GetPoolBuffer (queue, sizeof (EncryptedIoQueueItem)))

  00125	83 ff 08	 cmp	 edi, 8
  00128	7d 16		 jge	 SHORT $LN11@EncryptedI@4
  0012a	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  0012f	48 8b cb	 mov	 rcx, rbx
  00132	e8 00 00 00 00	 call	 GetPoolBuffer
  00137	49 3b c6	 cmp	 rax, r14
  0013a	0f 84 54 01 00
	00		 je	 $noMemory$29784
$LN11@EncryptedI@4:

; 907  : 			goto noMemory;
; 908  : 
; 909  : 		if (!GetPoolBuffer (queue, sizeof (EncryptedIoRequest)))

  00140	ba 60 00 00 00	 mov	 edx, 96			; 00000060H
  00145	48 8b cb	 mov	 rcx, rbx
  00148	e8 00 00 00 00	 call	 GetPoolBuffer
  0014d	49 3b c6	 cmp	 rax, r14
  00150	0f 84 3e 01 00
	00		 je	 $noMemory$29784
  00156	41 03 ff	 add	 edi, r15d
  00159	83 ff 10	 cmp	 edi, 16
  0015c	7c c7		 jl	 SHORT $LL14@EncryptedI@4

; 910  : 			goto noMemory;
; 911  : 	}
; 912  : 
; 913  : 	for (buffer = queue->FirstPoolBuffer; buffer != NULL; buffer = buffer->NextBuffer)

  0015e	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]
  00162	eb 07		 jmp	 SHORT $LN38@EncryptedI@4
$LL9@EncryptedI@4:

; 914  : 	{
; 915  : 		buffer->InUse = FALSE;

  00164	44 89 70 14	 mov	 DWORD PTR [rax+20], r14d
  00168	48 8b 00	 mov	 rax, QWORD PTR [rax]
$LN38@EncryptedI@4:

; 910  : 			goto noMemory;
; 911  : 	}
; 912  : 
; 913  : 	for (buffer = queue->FirstPoolBuffer; buffer != NULL; buffer = buffer->NextBuffer)

  0016b	49 3b c6	 cmp	 rax, r14
  0016e	75 f4		 jne	 SHORT $LL9@EncryptedI@4

; 916  : 	}
; 917  : 
; 918  : 	// Main thread
; 919  : 	InitializeListHead (&queue->MainThreadQueue);

  00170	48 8d 83 c8 00
	00 00		 lea	 rax, QWORD PTR [rbx+200]

; 920  : 	KeInitializeSpinLock (&queue->MainThreadQueueLock);
; 921  : 	KeInitializeEvent (&queue->MainThreadQueueNotEmptyEvent, SynchronizationEvent, FALSE);

  00177	48 8d 8b e0 00
	00 00		 lea	 rcx, QWORD PTR [rbx+224]
  0017e	45 33 c0	 xor	 r8d, r8d
  00181	48 89 40 08	 mov	 QWORD PTR [rax+8], rax
  00185	48 89 00	 mov	 QWORD PTR [rax], rax
  00188	41 8b d7	 mov	 edx, r15d
  0018b	4c 89 b3 d8 00
	00 00		 mov	 QWORD PTR [rbx+216], r14
  00192	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 922  : 
; 923  : 	status = TCStartThread (MainThreadProc, queue, &queue->MainThread);

  00198	4c 8d 83 c0 00
	00 00		 lea	 r8, QWORD PTR [rbx+192]
  0019f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:MainThreadProc
  001a6	48 8b d3	 mov	 rdx, rbx
  001a9	e8 00 00 00 00	 call	 TCStartThread

; 924  : 	if (!NT_SUCCESS (status))

  001ae	41 3b c6	 cmp	 eax, r14d
  001b1	8b f8		 mov	 edi, eax
  001b3	0f 8c e0 00 00
	00		 jl	 $err$29802

; 925  : 		goto err;
; 926  : 
; 927  : 	// IO thread
; 928  : 	InitializeListHead (&queue->IoThreadQueue);

  001b9	48 8d 83 00 01
	00 00		 lea	 rax, QWORD PTR [rbx+256]

; 929  : 	KeInitializeSpinLock (&queue->IoThreadQueueLock);
; 930  : 	KeInitializeEvent (&queue->IoThreadQueueNotEmptyEvent, SynchronizationEvent, FALSE);

  001c0	48 8d 8b 18 01
	00 00		 lea	 rcx, QWORD PTR [rbx+280]
  001c7	45 33 c0	 xor	 r8d, r8d
  001ca	48 89 40 08	 mov	 QWORD PTR [rax+8], rax
  001ce	48 89 00	 mov	 QWORD PTR [rax], rax
  001d1	41 8b d7	 mov	 edx, r15d
  001d4	4c 89 b3 10 01
	00 00		 mov	 QWORD PTR [rbx+272], r14
  001db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 931  : 
; 932  : 	status = TCStartThread (IoThreadProc, queue, &queue->IoThread);

  001e1	4c 8d 83 f8 00
	00 00		 lea	 r8, QWORD PTR [rbx+248]
  001e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:IoThreadProc
  001ef	48 8b d3	 mov	 rdx, rbx
  001f2	e8 00 00 00 00	 call	 TCStartThread

; 933  : 	if (!NT_SUCCESS (status))

  001f7	41 3b c6	 cmp	 eax, r14d
  001fa	8b f8		 mov	 edi, eax
  001fc	7d 1c		 jge	 SHORT $LN5@EncryptedI@4

; 934  : 	{
; 935  : 		queue->ThreadExitRequested = TRUE;
; 936  : 		TCStopThread (queue->MainThread, &queue->MainThreadQueueNotEmptyEvent);

  001fe	48 8b 8b c0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+192]
  00205	44 89 bb 34 02
	00 00		 mov	 DWORD PTR [rbx+564], r15d
  0020c	48 8d 93 e0 00
	00 00		 lea	 rdx, QWORD PTR [rbx+224]
$LN40@EncryptedI@4:
  00213	e8 00 00 00 00	 call	 TCStopThread

; 937  : 		goto err;

  00218	eb 7f		 jmp	 SHORT $err$29802
$LN5@EncryptedI@4:

; 938  : 	}
; 939  : 
; 940  : 	// Completion thread
; 941  : 	InitializeListHead (&queue->CompletionThreadQueue);

  0021a	48 8d 83 38 01
	00 00		 lea	 rax, QWORD PTR [rbx+312]

; 942  : 	KeInitializeSpinLock (&queue->CompletionThreadQueueLock);
; 943  : 	KeInitializeEvent (&queue->CompletionThreadQueueNotEmptyEvent, SynchronizationEvent, FALSE);

  00221	48 8d 8b 50 01
	00 00		 lea	 rcx, QWORD PTR [rbx+336]
  00228	45 33 c0	 xor	 r8d, r8d
  0022b	48 89 40 08	 mov	 QWORD PTR [rax+8], rax
  0022f	48 89 00	 mov	 QWORD PTR [rax], rax
  00232	41 8b d7	 mov	 edx, r15d
  00235	4c 89 b3 48 01
	00 00		 mov	 QWORD PTR [rbx+328], r14
  0023c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 944  : 
; 945  : 	status = TCStartThread (CompletionThreadProc, queue, &queue->CompletionThread);

  00242	4c 8d 83 30 01
	00 00		 lea	 r8, QWORD PTR [rbx+304]
  00249	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CompletionThreadProc
  00250	48 8b d3	 mov	 rdx, rbx
  00253	e8 00 00 00 00	 call	 TCStartThread

; 946  : 	if (!NT_SUCCESS (status))

  00258	41 3b c6	 cmp	 eax, r14d
  0025b	8b f8		 mov	 edi, eax
  0025d	7d 2a		 jge	 SHORT $LN4@EncryptedI@4

; 947  : 	{
; 948  : 		queue->ThreadExitRequested = TRUE;
; 949  : 		TCStopThread (queue->MainThread, &queue->MainThreadQueueNotEmptyEvent);

  0025f	48 8b 8b c0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+192]
  00266	48 8d 93 e0 00
	00 00		 lea	 rdx, QWORD PTR [rbx+224]
  0026d	44 89 bb 34 02
	00 00		 mov	 DWORD PTR [rbx+564], r15d
  00274	e8 00 00 00 00	 call	 TCStopThread

; 950  : 		TCStopThread (queue->IoThread, &queue->IoThreadQueueNotEmptyEvent);

  00279	48 8b 8b f8 00
	00 00		 mov	 rcx, QWORD PTR [rbx+248]
  00280	48 8d 93 18 01
	00 00		 lea	 rdx, QWORD PTR [rbx+280]
  00287	eb 8a		 jmp	 SHORT $LN40@EncryptedI@4
$LN4@EncryptedI@4:

; 951  : 		goto err;
; 952  : 	}
; 953  : 
; 954  : #ifdef TC_TRACE_IO_QUEUE
; 955  : 	GetElapsedTimeInit (&queue->LastPerformanceCounter);
; 956  : #endif
; 957  : 
; 958  : 	queue->StopPending = FALSE;

  00289	44 89 b3 40 02
	00 00		 mov	 DWORD PTR [rbx+576], r14d

; 959  : 	queue->StartPending = FALSE;
; 960  : 
; 961  : 	Dump ("Queue started\n");
; 962  : 	return STATUS_SUCCESS;

  00290	33 c0		 xor	 eax, eax
  00292	eb 54		 jmp	 SHORT $LN39@EncryptedI@4
$noMemory$29784:

; 963  : 
; 964  : noMemory:
; 965  : 	status = STATUS_INSUFFICIENT_RESOURCES;

  00294	bf 9a 00 00 c0	 mov	 edi, -1073741670	; ffffffffc000009aH
$err$29802:

; 966  : 
; 967  : err:
; 968  : 	if (queue->FragmentBufferA)

  00299	48 8b 8b 68 01
	00 00		 mov	 rcx, QWORD PTR [rbx+360]
  002a0	49 3b ce	 cmp	 rcx, r14
  002a3	74 0b		 je	 SHORT $LN3@EncryptedI@4

; 969  : 		TCfree (queue->FragmentBufferA);

  002a5	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  002aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN3@EncryptedI@4:

; 970  : 	if (queue->FragmentBufferB)

  002b0	48 8b 8b 70 01
	00 00		 mov	 rcx, QWORD PTR [rbx+368]
  002b7	49 3b ce	 cmp	 rcx, r14
  002ba	74 0b		 je	 SHORT $LN2@EncryptedI@4

; 971  : 		TCfree (queue->FragmentBufferB);

  002bc	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  002c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN2@EncryptedI@4:

; 972  : 	if (queue->ReadAheadBuffer)

  002c7	48 8b 8b d0 01
	00 00		 mov	 rcx, QWORD PTR [rbx+464]
  002ce	49 3b ce	 cmp	 rcx, r14
  002d1	74 0b		 je	 SHORT $LN1@EncryptedI@4

; 973  : 		TCfree (queue->ReadAheadBuffer);

  002d3	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  002d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN1@EncryptedI@4:

; 974  : 
; 975  : 	FreePoolBuffers (queue);

  002de	48 8b cb	 mov	 rcx, rbx
  002e1	e8 00 00 00 00	 call	 FreePoolBuffers

; 976  : 
; 977  : 	queue->StartPending = FALSE;
; 978  : 	return status;

  002e6	8b c7		 mov	 eax, edi
$LN39@EncryptedI@4:

; 979  : }

  002e8	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  002ed	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  002f2	44 89 b3 30 02
	00 00		 mov	 DWORD PTR [rbx+560], r14d
  002f9	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  002fe	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00302	41 5f		 pop	 r15
  00304	41 5e		 pop	 r14
  00306	41 5d		 pop	 r13
  00308	41 5c		 pop	 r12
  0030a	5f		 pop	 rdi
  0030b	c3		 ret	 0
EncryptedIoQueueStart ENDP
END
