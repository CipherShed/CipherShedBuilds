; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\home\public\desktop\projects\ciphershed\src\common\gfmul.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
_gft_le	DW	00H
	DW	0c201H
	DW	08403H
	DW	04602H
	DW	0807H
	DW	0ca06H
	DW	08c04H
	DW	04e05H
	DW	0100eH
	DW	0d20fH
	DW	0940dH
	DW	0560cH
	DW	01809H
	DW	0da08H
	DW	09c0aH
	DW	05e0bH
	DW	0201cH
	DW	0e21dH
	DW	0a41fH
	DW	0661eH
	DW	0281bH
	DW	0ea1aH
	DW	0ac18H
	DW	06e19H
	DW	03012H
	DW	0f213H
	DW	0b411H
	DW	07610H
	DW	03815H
	DW	0fa14H
	DW	0bc16H
	DW	07e17H
	DW	04038H
	DW	08239H
	DW	0c43bH
	DW	063aH
	DW	0483fH
	DW	08a3eH
	DW	0cc3cH
	DW	0e3dH
	DW	05036H
	DW	09237H
	DW	0d435H
	DW	01634H
	DW	05831H
	DW	09a30H
	DW	0dc32H
	DW	01e33H
	DW	06024H
	DW	0a225H
	DW	0e427H
	DW	02626H
	DW	06823H
	DW	0aa22H
	DW	0ec20H
	DW	02e21H
	DW	0702aH
	DW	0b22bH
	DW	0f429H
	DW	03628H
	DW	0782dH
	DW	0ba2cH
	DW	0fc2eH
	DW	03e2fH
	DW	08070H
	DW	04271H
	DW	0473H
	DW	0c672H
	DW	08877H
	DW	04a76H
	DW	0c74H
	DW	0ce75H
	DW	0907eH
	DW	0527fH
	DW	0147dH
	DW	0d67cH
	DW	09879H
	DW	05a78H
	DW	01c7aH
	DW	0de7bH
	DW	0a06cH
	DW	0626dH
	DW	0246fH
	DW	0e66eH
	DW	0a86bH
	DW	06a6aH
	DW	02c68H
	DW	0ee69H
	DW	0b062H
	DW	07263H
	DW	03461H
	DW	0f660H
	DW	0b865H
	DW	07a64H
	DW	03c66H
	DW	0fe67H
	DW	0c048H
	DW	0249H
	DW	0444bH
	DW	0864aH
	DW	0c84fH
	DW	0a4eH
	DW	04c4cH
	DW	08e4dH
	DW	0d046H
	DW	01247H
	DW	05445H
	DW	09644H
	DW	0d841H
	DW	01a40H
	DW	05c42H
	DW	09e43H
	DW	0e054H
	DW	02255H
	DW	06457H
	DW	0a656H
	DW	0e853H
	DW	02a52H
	DW	06c50H
	DW	0ae51H
	DW	0f05aH
	DW	0325bH
	DW	07459H
	DW	0b658H
	DW	0f85dH
	DW	03a5cH
	DW	07c5eH
	DW	0be5fH
	DW	0e1H
	DW	0c2e0H
	DW	084e2H
	DW	046e3H
	DW	08e6H
	DW	0cae7H
	DW	08ce5H
	DW	04ee4H
	DW	010efH
	DW	0d2eeH
	DW	094ecH
	DW	056edH
	DW	018e8H
	DW	0dae9H
	DW	09cebH
	DW	05eeaH
	DW	020fdH
	DW	0e2fcH
	DW	0a4feH
	DW	066ffH
	DW	028faH
	DW	0eafbH
	DW	0acf9H
	DW	06ef8H
	DW	030f3H
	DW	0f2f2H
	DW	0b4f0H
	DW	076f1H
	DW	038f4H
	DW	0faf5H
	DW	0bcf7H
	DW	07ef6H
	DW	040d9H
	DW	082d8H
	DW	0c4daH
	DW	06dbH
	DW	048deH
	DW	08adfH
	DW	0ccddH
	DW	0edcH
	DW	050d7H
	DW	092d6H
	DW	0d4d4H
	DW	016d5H
	DW	058d0H
	DW	09ad1H
	DW	0dcd3H
	DW	01ed2H
	DW	060c5H
	DW	0a2c4H
	DW	0e4c6H
	DW	026c7H
	DW	068c2H
	DW	0aac3H
	DW	0ecc1H
	DW	02ec0H
	DW	070cbH
	DW	0b2caH
	DW	0f4c8H
	DW	036c9H
	DW	078ccH
	DW	0bacdH
	DW	0fccfH
	DW	03eceH
	DW	08091H
	DW	04290H
	DW	0492H
	DW	0c693H
	DW	08896H
	DW	04a97H
	DW	0c95H
	DW	0ce94H
	DW	0909fH
	DW	0529eH
	DW	0149cH
	DW	0d69dH
	DW	09898H
	DW	05a99H
	DW	01c9bH
	DW	0de9aH
	DW	0a08dH
	DW	0628cH
	DW	0248eH
	DW	0e68fH
	DW	0a88aH
	DW	06a8bH
	DW	02c89H
	DW	0ee88H
	DW	0b083H
	DW	07282H
	DW	03480H
	DW	0f681H
	DW	0b884H
	DW	07a85H
	DW	03c87H
	DW	0fe86H
	DW	0c0a9H
	DW	02a8H
	DW	044aaH
	DW	086abH
	DW	0c8aeH
	DW	0aafH
	DW	04cadH
	DW	08eacH
	DW	0d0a7H
	DW	012a6H
	DW	054a4H
	DW	096a5H
	DW	0d8a0H
	DW	01aa1H
	DW	05ca3H
	DW	09ea2H
	DW	0e0b5H
	DW	022b4H
	DW	064b6H
	DW	0a6b7H
	DW	0e8b2H
	DW	02ab3H
	DW	06cb1H
	DW	0aeb0H
	DW	0f0bbH
	DW	032baH
	DW	074b8H
	DW	0b6b9H
	DW	0f8bcH
	DW	03abdH
	DW	07cbfH
	DW	0bebeH
_gft_le64 DW	00H
	DW	0b001H
	DW	06003H
	DW	0d002H
	DW	0c006H
	DW	07007H
	DW	0a005H
	DW	01004H
	DW	0800dH
	DW	0300cH
	DW	0e00eH
	DW	0500fH
	DW	0400bH
	DW	0f00aH
	DW	02008H
	DW	09009H
	DW	01bH
	DW	0b01aH
	DW	06018H
	DW	0d019H
	DW	0c01dH
	DW	0701cH
	DW	0a01eH
	DW	0101fH
	DW	08016H
	DW	03017H
	DW	0e015H
	DW	05014H
	DW	04010H
	DW	0f011H
	DW	02013H
	DW	09012H
	DW	036H
	DW	0b037H
	DW	06035H
	DW	0d034H
	DW	0c030H
	DW	07031H
	DW	0a033H
	DW	01032H
	DW	0803bH
	DW	0303aH
	DW	0e038H
	DW	05039H
	DW	0403dH
	DW	0f03cH
	DW	0203eH
	DW	0903fH
	DW	02dH
	DW	0b02cH
	DW	0602eH
	DW	0d02fH
	DW	0c02bH
	DW	0702aH
	DW	0a028H
	DW	01029H
	DW	08020H
	DW	03021H
	DW	0e023H
	DW	05022H
	DW	04026H
	DW	0f027H
	DW	02025H
	DW	09024H
	DW	06cH
	DW	0b06dH
	DW	0606fH
	DW	0d06eH
	DW	0c06aH
	DW	0706bH
	DW	0a069H
	DW	01068H
	DW	08061H
	DW	03060H
	DW	0e062H
	DW	05063H
	DW	04067H
	DW	0f066H
	DW	02064H
	DW	09065H
	DW	077H
	DW	0b076H
	DW	06074H
	DW	0d075H
	DW	0c071H
	DW	07070H
	DW	0a072H
	DW	01073H
	DW	0807aH
	DW	0307bH
	DW	0e079H
	DW	05078H
	DW	0407cH
	DW	0f07dH
	DW	0207fH
	DW	0907eH
	DW	05aH
	DW	0b05bH
	DW	06059H
	DW	0d058H
	DW	0c05cH
	DW	0705dH
	DW	0a05fH
	DW	0105eH
	DW	08057H
	DW	03056H
	DW	0e054H
	DW	05055H
	DW	04051H
	DW	0f050H
	DW	02052H
	DW	09053H
	DW	041H
	DW	0b040H
	DW	06042H
	DW	0d043H
	DW	0c047H
	DW	07046H
	DW	0a044H
	DW	01045H
	DW	0804cH
	DW	0304dH
	DW	0e04fH
	DW	0504eH
	DW	0404aH
	DW	0f04bH
	DW	02049H
	DW	09048H
	DW	0d8H
	DW	0b0d9H
	DW	060dbH
	DW	0d0daH
	DW	0c0deH
	DW	070dfH
	DW	0a0ddH
	DW	010dcH
	DW	080d5H
	DW	030d4H
	DW	0e0d6H
	DW	050d7H
	DW	040d3H
	DW	0f0d2H
	DW	020d0H
	DW	090d1H
	DW	0c3H
	DW	0b0c2H
	DW	060c0H
	DW	0d0c1H
	DW	0c0c5H
	DW	070c4H
	DW	0a0c6H
	DW	010c7H
	DW	080ceH
	DW	030cfH
	DW	0e0cdH
	DW	050ccH
	DW	040c8H
	DW	0f0c9H
	DW	020cbH
	DW	090caH
	DW	0eeH
	DW	0b0efH
	DW	060edH
	DW	0d0ecH
	DW	0c0e8H
	DW	070e9H
	DW	0a0ebH
	DW	010eaH
	DW	080e3H
	DW	030e2H
	DW	0e0e0H
	DW	050e1H
	DW	040e5H
	DW	0f0e4H
	DW	020e6H
	DW	090e7H
	DW	0f5H
	DW	0b0f4H
	DW	060f6H
	DW	0d0f7H
	DW	0c0f3H
	DW	070f2H
	DW	0a0f0H
	DW	010f1H
	DW	080f8H
	DW	030f9H
	DW	0e0fbH
	DW	050faH
	DW	040feH
	DW	0f0ffH
	DW	020fdH
	DW	090fcH
	DW	0b4H
	DW	0b0b5H
	DW	060b7H
	DW	0d0b6H
	DW	0c0b2H
	DW	070b3H
	DW	0a0b1H
	DW	010b0H
	DW	080b9H
	DW	030b8H
	DW	0e0baH
	DW	050bbH
	DW	040bfH
	DW	0f0beH
	DW	020bcH
	DW	090bdH
	DW	0afH
	DW	0b0aeH
	DW	060acH
	DW	0d0adH
	DW	0c0a9H
	DW	070a8H
	DW	0a0aaH
	DW	010abH
	DW	080a2H
	DW	030a3H
	DW	0e0a1H
	DW	050a0H
	DW	040a4H
	DW	0f0a5H
	DW	020a7H
	DW	090a6H
	DW	082H
	DW	0b083H
	DW	06081H
	DW	0d080H
	DW	0c084H
	DW	07085H
	DW	0a087H
	DW	01086H
	DW	0808fH
	DW	0308eH
	DW	0e08cH
	DW	0508dH
	DW	04089H
	DW	0f088H
	DW	0208aH
	DW	0908bH
	DW	099H
	DW	0b098H
	DW	0609aH
	DW	0d09bH
	DW	0c09fH
	DW	0709eH
	DW	0a09cH
	DW	0109dH
	DW	08094H
	DW	03095H
	DW	0e097H
	DW	05096H
	DW	04092H
	DW	0f093H
	DW	02091H
	DW	09090H
_gft_be	DW	00H
	DW	01c2H
	DW	0384H
	DW	0246H
	DW	0708H
	DW	06caH
	DW	048cH
	DW	054eH
	DW	0e10H
	DW	0fd2H
	DW	0d94H
	DW	0c56H
	DW	0918H
	DW	08daH
	DW	0a9cH
	DW	0b5eH
	DW	01c20H
	DW	01de2H
	DW	01fa4H
	DW	01e66H
	DW	01b28H
	DW	01aeaH
	DW	018acH
	DW	0196eH
	DW	01230H
	DW	013f2H
	DW	011b4H
	DW	01076H
	DW	01538H
	DW	014faH
	DW	016bcH
	DW	0177eH
	DW	03840H
	DW	03982H
	DW	03bc4H
	DW	03a06H
	DW	03f48H
	DW	03e8aH
	DW	03cccH
	DW	03d0eH
	DW	03650H
	DW	03792H
	DW	035d4H
	DW	03416H
	DW	03158H
	DW	0309aH
	DW	032dcH
	DW	0331eH
	DW	02460H
	DW	025a2H
	DW	027e4H
	DW	02626H
	DW	02368H
	DW	022aaH
	DW	020ecH
	DW	0212eH
	DW	02a70H
	DW	02bb2H
	DW	029f4H
	DW	02836H
	DW	02d78H
	DW	02cbaH
	DW	02efcH
	DW	02f3eH
	DW	07080H
	DW	07142H
	DW	07304H
	DW	072c6H
	DW	07788H
	DW	0764aH
	DW	0740cH
	DW	075ceH
	DW	07e90H
	DW	07f52H
	DW	07d14H
	DW	07cd6H
	DW	07998H
	DW	0785aH
	DW	07a1cH
	DW	07bdeH
	DW	06ca0H
	DW	06d62H
	DW	06f24H
	DW	06ee6H
	DW	06ba8H
	DW	06a6aH
	DW	0682cH
	DW	069eeH
	DW	062b0H
	DW	06372H
	DW	06134H
	DW	060f6H
	DW	065b8H
	DW	0647aH
	DW	0663cH
	DW	067feH
	DW	048c0H
	DW	04902H
	DW	04b44H
	DW	04a86H
	DW	04fc8H
	DW	04e0aH
	DW	04c4cH
	DW	04d8eH
	DW	046d0H
	DW	04712H
	DW	04554H
	DW	04496H
	DW	041d8H
	DW	0401aH
	DW	0425cH
	DW	0439eH
	DW	054e0H
	DW	05522H
	DW	05764H
	DW	056a6H
	DW	053e8H
	DW	0522aH
	DW	0506cH
	DW	051aeH
	DW	05af0H
	DW	05b32H
	DW	05974H
	DW	058b6H
	DW	05df8H
	DW	05c3aH
	DW	05e7cH
	DW	05fbeH
	DW	0e100H
	DW	0e0c2H
	DW	0e284H
	DW	0e346H
	DW	0e608H
	DW	0e7caH
	DW	0e58cH
	DW	0e44eH
	DW	0ef10H
	DW	0eed2H
	DW	0ec94H
	DW	0ed56H
	DW	0e818H
	DW	0e9daH
	DW	0eb9cH
	DW	0ea5eH
	DW	0fd20H
	DW	0fce2H
	DW	0fea4H
	DW	0ff66H
	DW	0fa28H
	DW	0fbeaH
	DW	0f9acH
	DW	0f86eH
	DW	0f330H
	DW	0f2f2H
	DW	0f0b4H
	DW	0f176H
	DW	0f438H
	DW	0f5faH
	DW	0f7bcH
	DW	0f67eH
	DW	0d940H
	DW	0d882H
	DW	0dac4H
	DW	0db06H
	DW	0de48H
	DW	0df8aH
	DW	0ddccH
	DW	0dc0eH
	DW	0d750H
	DW	0d692H
	DW	0d4d4H
	DW	0d516H
	DW	0d058H
	DW	0d19aH
	DW	0d3dcH
	DW	0d21eH
	DW	0c560H
	DW	0c4a2H
	DW	0c6e4H
	DW	0c726H
	DW	0c268H
	DW	0c3aaH
	DW	0c1ecH
	DW	0c02eH
	DW	0cb70H
	DW	0cab2H
	DW	0c8f4H
	DW	0c936H
	DW	0cc78H
	DW	0cdbaH
	DW	0cffcH
	DW	0ce3eH
	DW	09180H
	DW	09042H
	DW	09204H
	DW	093c6H
	DW	09688H
	DW	0974aH
	DW	0950cH
	DW	094ceH
	DW	09f90H
	DW	09e52H
	DW	09c14H
	DW	09dd6H
	DW	09898H
	DW	0995aH
	DW	09b1cH
	DW	09adeH
	DW	08da0H
	DW	08c62H
	DW	08e24H
	DW	08fe6H
	DW	08aa8H
	DW	08b6aH
	DW	0892cH
	DW	088eeH
	DW	083b0H
	DW	08272H
	DW	08034H
	DW	081f6H
	DW	084b8H
	DW	0857aH
	DW	0873cH
	DW	086feH
	DW	0a9c0H
	DW	0a802H
	DW	0aa44H
	DW	0ab86H
	DW	0aec8H
	DW	0af0aH
	DW	0ad4cH
	DW	0ac8eH
	DW	0a7d0H
	DW	0a612H
	DW	0a454H
	DW	0a596H
	DW	0a0d8H
	DW	0a11aH
	DW	0a35cH
	DW	0a29eH
	DW	0b5e0H
	DW	0b422H
	DW	0b664H
	DW	0b7a6H
	DW	0b2e8H
	DW	0b32aH
	DW	0b16cH
	DW	0b0aeH
	DW	0bbf0H
	DW	0ba32H
	DW	0b874H
	DW	0b9b6H
	DW	0bcf8H
	DW	0bd3aH
	DW	0bf7cH
	DW	0bebeH
_gft_be64 DW	00H
	DW	01b0H
	DW	0360H
	DW	02d0H
	DW	06c0H
	DW	0770H
	DW	05a0H
	DW	0410H
	DW	0d80H
	DW	0c30H
	DW	0ee0H
	DW	0f50H
	DW	0b40H
	DW	0af0H
	DW	0820H
	DW	0990H
	DW	01b00H
	DW	01ab0H
	DW	01860H
	DW	019d0H
	DW	01dc0H
	DW	01c70H
	DW	01ea0H
	DW	01f10H
	DW	01680H
	DW	01730H
	DW	015e0H
	DW	01450H
	DW	01040H
	DW	011f0H
	DW	01320H
	DW	01290H
	DW	03600H
	DW	037b0H
	DW	03560H
	DW	034d0H
	DW	030c0H
	DW	03170H
	DW	033a0H
	DW	03210H
	DW	03b80H
	DW	03a30H
	DW	038e0H
	DW	03950H
	DW	03d40H
	DW	03cf0H
	DW	03e20H
	DW	03f90H
	DW	02d00H
	DW	02cb0H
	DW	02e60H
	DW	02fd0H
	DW	02bc0H
	DW	02a70H
	DW	028a0H
	DW	02910H
	DW	02080H
	DW	02130H
	DW	023e0H
	DW	02250H
	DW	02640H
	DW	027f0H
	DW	02520H
	DW	02490H
	DW	06c00H
	DW	06db0H
	DW	06f60H
	DW	06ed0H
	DW	06ac0H
	DW	06b70H
	DW	069a0H
	DW	06810H
	DW	06180H
	DW	06030H
	DW	062e0H
	DW	06350H
	DW	06740H
	DW	066f0H
	DW	06420H
	DW	06590H
	DW	07700H
	DW	076b0H
	DW	07460H
	DW	075d0H
	DW	071c0H
	DW	07070H
	DW	072a0H
	DW	07310H
	DW	07a80H
	DW	07b30H
	DW	079e0H
	DW	07850H
	DW	07c40H
	DW	07df0H
	DW	07f20H
	DW	07e90H
	DW	05a00H
	DW	05bb0H
	DW	05960H
	DW	058d0H
	DW	05cc0H
	DW	05d70H
	DW	05fa0H
	DW	05e10H
	DW	05780H
	DW	05630H
	DW	054e0H
	DW	05550H
	DW	05140H
	DW	050f0H
	DW	05220H
	DW	05390H
	DW	04100H
	DW	040b0H
	DW	04260H
	DW	043d0H
	DW	047c0H
	DW	04670H
	DW	044a0H
	DW	04510H
	DW	04c80H
	DW	04d30H
	DW	04fe0H
	DW	04e50H
	DW	04a40H
	DW	04bf0H
	DW	04920H
	DW	04890H
	DW	0d800H
	DW	0d9b0H
	DW	0db60H
	DW	0dad0H
	DW	0dec0H
	DW	0df70H
	DW	0dda0H
	DW	0dc10H
	DW	0d580H
	DW	0d430H
	DW	0d6e0H
	DW	0d750H
	DW	0d340H
	DW	0d2f0H
	DW	0d020H
	DW	0d190H
	DW	0c300H
	DW	0c2b0H
	DW	0c060H
	DW	0c1d0H
	DW	0c5c0H
	DW	0c470H
	DW	0c6a0H
	DW	0c710H
	DW	0ce80H
	DW	0cf30H
	DW	0cde0H
	DW	0cc50H
	DW	0c840H
	DW	0c9f0H
	DW	0cb20H
	DW	0ca90H
	DW	0ee00H
	DW	0efb0H
	DW	0ed60H
	DW	0ecd0H
	DW	0e8c0H
	DW	0e970H
	DW	0eba0H
	DW	0ea10H
	DW	0e380H
	DW	0e230H
	DW	0e0e0H
	DW	0e150H
	DW	0e540H
	DW	0e4f0H
	DW	0e620H
	DW	0e790H
	DW	0f500H
	DW	0f4b0H
	DW	0f660H
	DW	0f7d0H
	DW	0f3c0H
	DW	0f270H
	DW	0f0a0H
	DW	0f110H
	DW	0f880H
	DW	0f930H
	DW	0fbe0H
	DW	0fa50H
	DW	0fe40H
	DW	0fff0H
	DW	0fd20H
	DW	0fc90H
	DW	0b400H
	DW	0b5b0H
	DW	0b760H
	DW	0b6d0H
	DW	0b2c0H
	DW	0b370H
	DW	0b1a0H
	DW	0b010H
	DW	0b980H
	DW	0b830H
	DW	0bae0H
	DW	0bb50H
	DW	0bf40H
	DW	0bef0H
	DW	0bc20H
	DW	0bd90H
	DW	0af00H
	DW	0aeb0H
	DW	0ac60H
	DW	0add0H
	DW	0a9c0H
	DW	0a870H
	DW	0aaa0H
	DW	0ab10H
	DW	0a280H
	DW	0a330H
	DW	0a1e0H
	DW	0a050H
	DW	0a440H
	DW	0a5f0H
	DW	0a720H
	DW	0a690H
	DW	08200H
	DW	083b0H
	DW	08160H
	DW	080d0H
	DW	084c0H
	DW	08570H
	DW	087a0H
	DW	08610H
	DW	08f80H
	DW	08e30H
	DW	08ce0H
	DW	08d50H
	DW	08940H
	DW	088f0H
	DW	08a20H
	DW	08b90H
	DW	09900H
	DW	098b0H
	DW	09a60H
	DW	09bd0H
	DW	09fc0H
	DW	09e70H
	DW	09ca0H
	DW	09d10H
	DW	09480H
	DW	09530H
	DW	097e0H
	DW	09650H
	DW	09240H
	DW	093f0H
	DW	09120H
	DW	09090H
CONST	ENDS
_DATA	SEGMENT
_gf_poly DD	00H
	DD	0e1000000H
_gf_poly64 DD	00H
	DD	0d8000000H
_DATA	ENDS
PUBLIC	_xor_block_aligned@8
PUBLIC	_mul_bex8@4
PUBLIC	_bsw_32@8
PUBLIC	_move_block_aligned@8
PUBLIC	_GfMul128@8
; Function compile flags: /Odtp
; File c:\home\public\desktop\projects\ciphershed\src\common\gfmul.c
;	COMDAT _GfMul128@8
_TEXT	SEGMENT
_r$ = -148						; size = 16
_i$ = -132						; size = 4
_p$ = -128						; size = 128
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_GfMul128@8 PROC					; COMDAT

; 397  : {   mode(32t) r[CBLK_LEN >> 2], p[8][CBLK_LEN >> 2];

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H

; 398  :     int i;
; 399  : 
; 400  :     move_block_aligned(p[0], b);

  0000b	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0000e	50		 push	 eax
  0000f	8d 4d 80	 lea	 ecx, DWORD PTR _p$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 _move_block_aligned@8

; 401  :     bsw_32(p[0], 4);

  00018	6a 04		 push	 4
  0001a	8d 55 80	 lea	 edx, DWORD PTR _p$[ebp]
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 _bsw_32@8

; 402  :     for(i = 0; i < 7; ++i)

  00023	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  0002d	eb 0f		 jmp	 SHORT $LN15@GfMul128
$LN14@GfMul128:
  0002f	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00035	83 c0 01	 add	 eax, 1
  00038	89 85 7c ff ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN15@GfMul128:
  0003e	83 bd 7c ff ff
	ff 07		 cmp	 DWORD PTR _i$[ebp], 7
  00045	0f 8d ce 00 00
	00		 jge	 $LN13@GfMul128

; 403  :     {
; 404  :         p[i + 1][3] = (p[i][3] >> 1) | (p[i][2] << 31);

  0004b	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00051	c1 e1 04	 shl	 ecx, 4
  00054	8b 54 0d 8c	 mov	 edx, DWORD PTR _p$[ebp+ecx+12]
  00058	d1 ea		 shr	 edx, 1
  0005a	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00060	c1 e0 04	 shl	 eax, 4
  00063	8b 4c 05 88	 mov	 ecx, DWORD PTR _p$[ebp+eax+8]
  00067	c1 e1 1f	 shl	 ecx, 31			; 0000001fH
  0006a	0b d1		 or	 edx, ecx
  0006c	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00072	83 c0 01	 add	 eax, 1
  00075	c1 e0 04	 shl	 eax, 4
  00078	89 54 05 8c	 mov	 DWORD PTR _p$[ebp+eax+12], edx

; 405  :         p[i + 1][2] = (p[i][2] >> 1) | (p[i][1] << 31);

  0007c	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00082	c1 e1 04	 shl	 ecx, 4
  00085	8b 54 0d 88	 mov	 edx, DWORD PTR _p$[ebp+ecx+8]
  00089	d1 ea		 shr	 edx, 1
  0008b	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00091	c1 e0 04	 shl	 eax, 4
  00094	8b 4c 05 84	 mov	 ecx, DWORD PTR _p$[ebp+eax+4]
  00098	c1 e1 1f	 shl	 ecx, 31			; 0000001fH
  0009b	0b d1		 or	 edx, ecx
  0009d	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  000a3	83 c0 01	 add	 eax, 1
  000a6	c1 e0 04	 shl	 eax, 4
  000a9	89 54 05 88	 mov	 DWORD PTR _p$[ebp+eax+8], edx

; 406  :         p[i + 1][1] = (p[i][1] >> 1) | (p[i][0] << 31);

  000ad	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  000b3	c1 e1 04	 shl	 ecx, 4
  000b6	8b 54 0d 84	 mov	 edx, DWORD PTR _p$[ebp+ecx+4]
  000ba	d1 ea		 shr	 edx, 1
  000bc	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  000c2	c1 e0 04	 shl	 eax, 4
  000c5	8b 4c 05 80	 mov	 ecx, DWORD PTR _p$[ebp+eax]
  000c9	c1 e1 1f	 shl	 ecx, 31			; 0000001fH
  000cc	0b d1		 or	 edx, ecx
  000ce	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  000d4	83 c0 01	 add	 eax, 1
  000d7	c1 e0 04	 shl	 eax, 4
  000da	89 54 05 84	 mov	 DWORD PTR _p$[ebp+eax+4], edx

; 407  :         p[i + 1][0] = (p[i][0] >> 1) ^ gf_poly[p[i][3] & 1];

  000de	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  000e4	c1 e1 04	 shl	 ecx, 4
  000e7	8b 54 0d 80	 mov	 edx, DWORD PTR _p$[ebp+ecx]
  000eb	d1 ea		 shr	 edx, 1
  000ed	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  000f3	c1 e0 04	 shl	 eax, 4
  000f6	8b 4c 05 8c	 mov	 ecx, DWORD PTR _p$[ebp+eax+12]
  000fa	83 e1 01	 and	 ecx, 1
  000fd	33 14 8d 00 00
	00 00		 xor	 edx, DWORD PTR _gf_poly[ecx*4]
  00104	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0010a	83 c0 01	 add	 eax, 1
  0010d	c1 e0 04	 shl	 eax, 4
  00110	89 54 05 80	 mov	 DWORD PTR _p$[ebp+eax], edx

; 408  :     }

  00114	e9 16 ff ff ff	 jmp	 $LN14@GfMul128
$LN13@GfMul128:

; 409  : 
; 410  :     memset(r, 0, CBLK_LEN);

  00119	33 c9		 xor	 ecx, ecx
  0011b	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _r$[ebp], ecx
  00121	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _r$[ebp+4], ecx
  00127	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _r$[ebp+8], ecx
  0012d	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _r$[ebp+12], ecx

; 411  :     for(i = 0; i < 16; ++i)

  00133	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  0013d	eb 0f		 jmp	 SHORT $LN12@GfMul128
$LN11@GfMul128:
  0013f	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00145	83 c2 01	 add	 edx, 1
  00148	89 95 7c ff ff
	ff		 mov	 DWORD PTR _i$[ebp], edx
$LN12@GfMul128:
  0014e	83 bd 7c ff ff
	ff 10		 cmp	 DWORD PTR _i$[ebp], 16	; 00000010H
  00155	0f 8d 54 01 00
	00		 jge	 $LN10@GfMul128

; 412  :     {
; 413  :         if(i) mul_bex8(r);  /* order is always big endian here */

  0015b	83 bd 7c ff ff
	ff 00		 cmp	 DWORD PTR _i$[ebp], 0
  00162	74 0c		 je	 SHORT $LN9@GfMul128
  00164	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR _r$[ebp]
  0016a	50		 push	 eax
  0016b	e8 00 00 00 00	 call	 _mul_bex8@4
$LN9@GfMul128:

; 414  : 
; 415  :         if(((unsigned char*)a)[15 - i] & 0x80)

  00170	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  00175	2b 8d 7c ff ff
	ff		 sub	 ecx, DWORD PTR _i$[ebp]
  0017b	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0017e	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00182	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00187	74 10		 je	 SHORT $LN8@GfMul128

; 416  :             xor_block_aligned(r, p[0]);

  00189	8d 4d 80	 lea	 ecx, DWORD PTR _p$[ebp]
  0018c	51		 push	 ecx
  0018d	8d 95 6c ff ff
	ff		 lea	 edx, DWORD PTR _r$[ebp]
  00193	52		 push	 edx
  00194	e8 00 00 00 00	 call	 _xor_block_aligned@8
$LN8@GfMul128:

; 417  :         if(((unsigned char*)a)[15 - i] & 0x40)

  00199	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH
  0019e	2b 85 7c ff ff
	ff		 sub	 eax, DWORD PTR _i$[ebp]
  001a4	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  001a7	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  001ab	83 e2 40	 and	 edx, 64			; 00000040H
  001ae	74 10		 je	 SHORT $LN7@GfMul128

; 418  :             xor_block_aligned(r, p[1]);

  001b0	8d 45 90	 lea	 eax, DWORD PTR _p$[ebp+16]
  001b3	50		 push	 eax
  001b4	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _r$[ebp]
  001ba	51		 push	 ecx
  001bb	e8 00 00 00 00	 call	 _xor_block_aligned@8
$LN7@GfMul128:

; 419  :         if(((unsigned char*)a)[15 - i] & 0x20)

  001c0	ba 0f 00 00 00	 mov	 edx, 15			; 0000000fH
  001c5	2b 95 7c ff ff
	ff		 sub	 edx, DWORD PTR _i$[ebp]
  001cb	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  001ce	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  001d2	83 e1 20	 and	 ecx, 32			; 00000020H
  001d5	74 10		 je	 SHORT $LN6@GfMul128

; 420  :             xor_block_aligned(r, p[2]);

  001d7	8d 55 a0	 lea	 edx, DWORD PTR _p$[ebp+32]
  001da	52		 push	 edx
  001db	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR _r$[ebp]
  001e1	50		 push	 eax
  001e2	e8 00 00 00 00	 call	 _xor_block_aligned@8
$LN6@GfMul128:

; 421  :         if(((unsigned char*)a)[15 - i] & 0x10)

  001e7	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  001ec	2b 8d 7c ff ff
	ff		 sub	 ecx, DWORD PTR _i$[ebp]
  001f2	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  001f5	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  001f9	83 e0 10	 and	 eax, 16			; 00000010H
  001fc	74 10		 je	 SHORT $LN5@GfMul128

; 422  :             xor_block_aligned(r, p[3]);

  001fe	8d 4d b0	 lea	 ecx, DWORD PTR _p$[ebp+48]
  00201	51		 push	 ecx
  00202	8d 95 6c ff ff
	ff		 lea	 edx, DWORD PTR _r$[ebp]
  00208	52		 push	 edx
  00209	e8 00 00 00 00	 call	 _xor_block_aligned@8
$LN5@GfMul128:

; 423  :         if(((unsigned char*)a)[15 - i] & 0x08)

  0020e	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH
  00213	2b 85 7c ff ff
	ff		 sub	 eax, DWORD PTR _i$[ebp]
  00219	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0021c	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00220	83 e2 08	 and	 edx, 8
  00223	74 10		 je	 SHORT $LN4@GfMul128

; 424  :             xor_block_aligned(r, p[4]);

  00225	8d 45 c0	 lea	 eax, DWORD PTR _p$[ebp+64]
  00228	50		 push	 eax
  00229	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _r$[ebp]
  0022f	51		 push	 ecx
  00230	e8 00 00 00 00	 call	 _xor_block_aligned@8
$LN4@GfMul128:

; 425  :         if(((unsigned char*)a)[15 - i] & 0x04)

  00235	ba 0f 00 00 00	 mov	 edx, 15			; 0000000fH
  0023a	2b 95 7c ff ff
	ff		 sub	 edx, DWORD PTR _i$[ebp]
  00240	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00243	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00247	83 e1 04	 and	 ecx, 4
  0024a	74 10		 je	 SHORT $LN3@GfMul128

; 426  :             xor_block_aligned(r, p[5]);

  0024c	8d 55 d0	 lea	 edx, DWORD PTR _p$[ebp+80]
  0024f	52		 push	 edx
  00250	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR _r$[ebp]
  00256	50		 push	 eax
  00257	e8 00 00 00 00	 call	 _xor_block_aligned@8
$LN3@GfMul128:

; 427  :         if(((unsigned char*)a)[15 - i] & 0x02)

  0025c	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  00261	2b 8d 7c ff ff
	ff		 sub	 ecx, DWORD PTR _i$[ebp]
  00267	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0026a	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0026e	83 e0 02	 and	 eax, 2
  00271	74 10		 je	 SHORT $LN2@GfMul128

; 428  :             xor_block_aligned(r, p[6]);

  00273	8d 4d e0	 lea	 ecx, DWORD PTR _p$[ebp+96]
  00276	51		 push	 ecx
  00277	8d 95 6c ff ff
	ff		 lea	 edx, DWORD PTR _r$[ebp]
  0027d	52		 push	 edx
  0027e	e8 00 00 00 00	 call	 _xor_block_aligned@8
$LN2@GfMul128:

; 429  :         if(((unsigned char*)a)[15 - i] & 0x01)

  00283	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH
  00288	2b 85 7c ff ff
	ff		 sub	 eax, DWORD PTR _i$[ebp]
  0028e	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00291	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00295	83 e2 01	 and	 edx, 1
  00298	74 10		 je	 SHORT $LN1@GfMul128

; 430  :             xor_block_aligned(r, p[7]);

  0029a	8d 45 f0	 lea	 eax, DWORD PTR _p$[ebp+112]
  0029d	50		 push	 eax
  0029e	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _r$[ebp]
  002a4	51		 push	 ecx
  002a5	e8 00 00 00 00	 call	 _xor_block_aligned@8
$LN1@GfMul128:

; 431  :     }

  002aa	e9 90 fe ff ff	 jmp	 $LN11@GfMul128
$LN10@GfMul128:

; 432  :     bsw_32(r, 4);

  002af	6a 04		 push	 4
  002b1	8d 95 6c ff ff
	ff		 lea	 edx, DWORD PTR _r$[ebp]
  002b7	52		 push	 edx
  002b8	e8 00 00 00 00	 call	 _bsw_32@8

; 433  :     move_block_aligned(a, r);

  002bd	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR _r$[ebp]
  002c3	50		 push	 eax
  002c4	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  002c7	51		 push	 ecx
  002c8	e8 00 00 00 00	 call	 _move_block_aligned@8

; 434  : }

  002cd	8b e5		 mov	 esp, ebp
  002cf	5d		 pop	 ebp
  002d0	c2 08 00	 ret	 8
_GfMul128@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _bsw_32@8
_TEXT	SEGMENT
_i$ = -4						; size = 4
_p$ = 8							; size = 4
_n$ = 12						; size = 4
_bsw_32@8 PROC						; COMDAT

; 116  : {   unsigned int i = n;

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	56		 push	 esi
  00007	8b 45 0c	 mov	 eax, DWORD PTR _n$[ebp]
  0000a	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN2@bsw_32:

; 117  :     while(i--)

  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00010	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00013	83 ea 01	 sub	 edx, 1
  00016	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
  00019	85 c9		 test	 ecx, ecx
  0001b	74 4d		 je	 SHORT $LN3@bsw_32

; 118  :         ((mode(32t)*)p)[i] = bswap_32(((mode(32t)*)p)[i]);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00020	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00023	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00026	c1 ea 18	 shr	 edx, 24			; 00000018H
  00029	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0002f	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00032	c1 e0 08	 shl	 eax, 8
  00035	0b d0		 or	 edx, eax
  00037	81 e2 ff 00 ff
	00		 and	 edx, 16711935		; 00ff00ffH
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00040	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00043	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]
  00046	c1 e9 08	 shr	 ecx, 8
  00049	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0004c	8b 75 08	 mov	 esi, DWORD PTR _p$[ebp]
  0004f	8b 04 86	 mov	 eax, DWORD PTR [esi+eax*4]
  00052	c1 e0 18	 shl	 eax, 24			; 00000018H
  00055	0b c8		 or	 ecx, eax
  00057	81 e1 00 ff 00
	ff		 and	 ecx, -16711936		; ff00ff00H
  0005d	0b d1		 or	 edx, ecx
  0005f	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00062	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00065	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx
  00068	eb a3		 jmp	 SHORT $LN2@bsw_32
$LN3@bsw_32:

; 119  : }

  0006a	5e		 pop	 esi
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 08 00	 ret	 8
_bsw_32@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _move_block_aligned@8
_TEXT	SEGMENT
_p$ = 8							; size = 4
_q$ = 12						; size = 4
_move_block_aligned@8 PROC				; COMDAT

; 155  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 156  :     lp32(p)[0] = lp32(q)[0], lp32(p)[1] = lp32(q)[1],
; 157  :     lp32(p)[2] = lp32(q)[2], lp32(p)[3] = lp32(q)[3];

  00005	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR _q$[ebp]
  0000b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00012	8b 4d 0c	 mov	 ecx, DWORD PTR _q$[ebp]
  00015	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00018	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR _q$[ebp]
  00021	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00024	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00027	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _q$[ebp]
  0002d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00030	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 158  : }

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
_move_block_aligned@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _xor_block_aligned@8
_TEXT	SEGMENT
_p$ = 8							; size = 4
_q$ = 12						; size = 4
_xor_block_aligned@8 PROC				; COMDAT

; 166  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 167  :     lp32(p)[0] ^= lp32(q)[0], lp32(p)[1] ^= lp32(q)[1],
; 168  :     lp32(p)[2] ^= lp32(q)[2], lp32(p)[3] ^= lp32(q)[3];

  00005	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR _q$[ebp]
  0000b	8b 10		 mov	 edx, DWORD PTR [eax]
  0000d	33 11		 xor	 edx, DWORD PTR [ecx]
  0000f	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00012	89 10		 mov	 DWORD PTR [eax], edx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00017	8b 55 0c	 mov	 edx, DWORD PTR _q$[ebp]
  0001a	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0001d	33 42 04	 xor	 eax, DWORD PTR [edx+4]
  00020	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00023	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00026	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00029	8b 45 0c	 mov	 eax, DWORD PTR _q$[ebp]
  0002c	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0002f	33 48 08	 xor	 ecx, DWORD PTR [eax+8]
  00032	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00035	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00038	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR _q$[ebp]
  0003e	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00041	33 51 0c	 xor	 edx, DWORD PTR [ecx+12]
  00044	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00047	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 169  : }

  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
_xor_block_aligned@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _mul_bex8@4
_TEXT	SEGMENT
_t$ = -4						; size = 4
_x$ = 8							; size = 4
_mul_bex8@4 PROC					; COMDAT

; 368  : {   mode(32t)   t = (x[3] & 0xff);      /* in big endian format     */

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00009	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0000c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00012	89 4d fc	 mov	 DWORD PTR _t$[ebp], ecx

; 369  :     x[3] = (x[3] >> 8) | (x[2] << 24);

  00015	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  00018	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0001b	c1 e8 08	 shr	 eax, 8
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00021	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00024	c1 e2 18	 shl	 edx, 24			; 00000018H
  00027	0b c2		 or	 eax, edx
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0002c	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 370  :     x[2] = (x[2] >> 8) | (x[1] << 24);

  0002f	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  00032	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00035	c1 e8 08	 shr	 eax, 8
  00038	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0003b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0003e	c1 e2 18	 shl	 edx, 24			; 00000018H
  00041	0b c2		 or	 eax, edx
  00043	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00046	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 371  :     x[1] = (x[1] >> 8) | (x[0] << 24);

  00049	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  0004c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0004f	c1 e8 08	 shr	 eax, 8
  00052	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00055	8b 11		 mov	 edx, DWORD PTR [ecx]
  00057	c1 e2 18	 shl	 edx, 24			; 00000018H
  0005a	0b c2		 or	 eax, edx
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0005f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 372  :     x[0] = (x[0] >> 8) ^ (((mode(32t))gft_be[t]) << 16);

  00062	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  00065	8b 02		 mov	 eax, DWORD PTR [edx]
  00067	c1 e8 08	 shr	 eax, 8
  0006a	8b 4d fc	 mov	 ecx, DWORD PTR _t$[ebp]
  0006d	0f b7 14 4d 00
	00 00 00	 movzx	 edx, WORD PTR _gft_be[ecx*2]
  00075	c1 e2 10	 shl	 edx, 16			; 00000010H
  00078	33 c2		 xor	 eax, edx
  0007a	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0007d	89 01		 mov	 DWORD PTR [ecx], eax

; 373  : }

  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 04 00	 ret	 4
_mul_bex8@4 ENDP
_TEXT	ENDS
PUBLIC	_GfMul128Tab@8
; Function compile flags: /Odtp
;	COMDAT _GfMul128Tab@8
_TEXT	SEGMENT
_r$ = -16						; size = 16
_a$ = 8							; size = 4
_ctx$ = 12						; size = 4
_GfMul128Tab@8 PROC					; COMDAT

; 444  : {   unsigned __int32 r[CBLK_LEN >> 2];

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 10	 sub	 esp, 16			; 00000010H

; 445  : 
; 446  :     move_block_aligned(r, ctx->gf_t8k[0][a[0] & 15]);

  00008	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0000b	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0000e	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00011	c1 e1 04	 shl	 ecx, 4
  00014	03 4d 0c	 add	 ecx, DWORD PTR _ctx$[ebp]
  00017	51		 push	 ecx
  00018	8d 55 f0	 lea	 edx, DWORD PTR _r$[ebp]
  0001b	52		 push	 edx
  0001c	e8 00 00 00 00	 call	 _move_block_aligned@8

; 447  :     xor_block_aligned(r, ctx->gf_t8k[1][a[0] >> 4]);

  00021	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00024	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00027	c1 f9 04	 sar	 ecx, 4
  0002a	c1 e1 04	 shl	 ecx, 4
  0002d	8b 55 0c	 mov	 edx, DWORD PTR _ctx$[ebp]
  00030	8d 84 0a 00 01
	00 00		 lea	 eax, DWORD PTR [edx+ecx+256]
  00037	50		 push	 eax
  00038	8d 4d f0	 lea	 ecx, DWORD PTR _r$[ebp]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 _xor_block_aligned@8

; 448  :                 xor_8k( 1); xor_8k( 2); xor_8k( 3);

  00041	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00044	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  00048	83 e0 0f	 and	 eax, 15			; 0000000fH
  0004b	c1 e0 04	 shl	 eax, 4
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR _ctx$[ebp]
  00051	8d 94 01 00 02
	00 00		 lea	 edx, DWORD PTR [ecx+eax+512]
  00058	52		 push	 edx
  00059	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 _xor_block_aligned@8
  00062	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00065	0f b6 51 01	 movzx	 edx, BYTE PTR [ecx+1]
  00069	c1 fa 04	 sar	 edx, 4
  0006c	c1 e2 04	 shl	 edx, 4
  0006f	8b 45 0c	 mov	 eax, DWORD PTR _ctx$[ebp]
  00072	8d 8c 10 00 03
	00 00		 lea	 ecx, DWORD PTR [eax+edx+768]
  00079	51		 push	 ecx
  0007a	8d 55 f0	 lea	 edx, DWORD PTR _r$[ebp]
  0007d	52		 push	 edx
  0007e	e8 00 00 00 00	 call	 _xor_block_aligned@8
  00083	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00086	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  0008a	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0008d	c1 e1 04	 shl	 ecx, 4
  00090	8b 55 0c	 mov	 edx, DWORD PTR _ctx$[ebp]
  00093	8d 84 0a 00 04
	00 00		 lea	 eax, DWORD PTR [edx+ecx+1024]
  0009a	50		 push	 eax
  0009b	8d 4d f0	 lea	 ecx, DWORD PTR _r$[ebp]
  0009e	51		 push	 ecx
  0009f	e8 00 00 00 00	 call	 _xor_block_aligned@8
  000a4	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  000a7	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  000ab	c1 f8 04	 sar	 eax, 4
  000ae	c1 e0 04	 shl	 eax, 4
  000b1	8b 4d 0c	 mov	 ecx, DWORD PTR _ctx$[ebp]
  000b4	8d 94 01 00 05
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1280]
  000bb	52		 push	 edx
  000bc	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  000bf	50		 push	 eax
  000c0	e8 00 00 00 00	 call	 _xor_block_aligned@8
  000c5	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  000c8	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  000cc	83 e2 0f	 and	 edx, 15			; 0000000fH
  000cf	c1 e2 04	 shl	 edx, 4
  000d2	8b 45 0c	 mov	 eax, DWORD PTR _ctx$[ebp]
  000d5	8d 8c 10 00 06
	00 00		 lea	 ecx, DWORD PTR [eax+edx+1536]
  000dc	51		 push	 ecx
  000dd	8d 55 f0	 lea	 edx, DWORD PTR _r$[ebp]
  000e0	52		 push	 edx
  000e1	e8 00 00 00 00	 call	 _xor_block_aligned@8
  000e6	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000e9	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  000ed	c1 f9 04	 sar	 ecx, 4
  000f0	c1 e1 04	 shl	 ecx, 4
  000f3	8b 55 0c	 mov	 edx, DWORD PTR _ctx$[ebp]
  000f6	8d 84 0a 00 07
	00 00		 lea	 eax, DWORD PTR [edx+ecx+1792]
  000fd	50		 push	 eax
  000fe	8d 4d f0	 lea	 ecx, DWORD PTR _r$[ebp]
  00101	51		 push	 ecx
  00102	e8 00 00 00 00	 call	 _xor_block_aligned@8

; 449  :     xor_8k( 4); xor_8k( 5); xor_8k( 6); xor_8k( 7);

  00107	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0010a	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  0010e	83 e0 0f	 and	 eax, 15			; 0000000fH
  00111	c1 e0 04	 shl	 eax, 4
  00114	8b 4d 0c	 mov	 ecx, DWORD PTR _ctx$[ebp]
  00117	8d 94 01 00 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax+2048]
  0011e	52		 push	 edx
  0011f	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  00122	50		 push	 eax
  00123	e8 00 00 00 00	 call	 _xor_block_aligned@8
  00128	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0012b	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  0012f	c1 fa 04	 sar	 edx, 4
  00132	c1 e2 04	 shl	 edx, 4
  00135	8b 45 0c	 mov	 eax, DWORD PTR _ctx$[ebp]
  00138	8d 8c 10 00 09
	00 00		 lea	 ecx, DWORD PTR [eax+edx+2304]
  0013f	51		 push	 ecx
  00140	8d 55 f0	 lea	 edx, DWORD PTR _r$[ebp]
  00143	52		 push	 edx
  00144	e8 00 00 00 00	 call	 _xor_block_aligned@8
  00149	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0014c	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00150	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00153	c1 e1 04	 shl	 ecx, 4
  00156	8b 55 0c	 mov	 edx, DWORD PTR _ctx$[ebp]
  00159	8d 84 0a 00 0a
	00 00		 lea	 eax, DWORD PTR [edx+ecx+2560]
  00160	50		 push	 eax
  00161	8d 4d f0	 lea	 ecx, DWORD PTR _r$[ebp]
  00164	51		 push	 ecx
  00165	e8 00 00 00 00	 call	 _xor_block_aligned@8
  0016a	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0016d	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  00171	c1 f8 04	 sar	 eax, 4
  00174	c1 e0 04	 shl	 eax, 4
  00177	8b 4d 0c	 mov	 ecx, DWORD PTR _ctx$[ebp]
  0017a	8d 94 01 00 0b
	00 00		 lea	 edx, DWORD PTR [ecx+eax+2816]
  00181	52		 push	 edx
  00182	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  00185	50		 push	 eax
  00186	e8 00 00 00 00	 call	 _xor_block_aligned@8
  0018b	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0018e	0f b6 51 06	 movzx	 edx, BYTE PTR [ecx+6]
  00192	83 e2 0f	 and	 edx, 15			; 0000000fH
  00195	c1 e2 04	 shl	 edx, 4
  00198	8b 45 0c	 mov	 eax, DWORD PTR _ctx$[ebp]
  0019b	8d 8c 10 00 0c
	00 00		 lea	 ecx, DWORD PTR [eax+edx+3072]
  001a2	51		 push	 ecx
  001a3	8d 55 f0	 lea	 edx, DWORD PTR _r$[ebp]
  001a6	52		 push	 edx
  001a7	e8 00 00 00 00	 call	 _xor_block_aligned@8
  001ac	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  001af	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  001b3	c1 f9 04	 sar	 ecx, 4
  001b6	c1 e1 04	 shl	 ecx, 4
  001b9	8b 55 0c	 mov	 edx, DWORD PTR _ctx$[ebp]
  001bc	8d 84 0a 00 0d
	00 00		 lea	 eax, DWORD PTR [edx+ecx+3328]
  001c3	50		 push	 eax
  001c4	8d 4d f0	 lea	 ecx, DWORD PTR _r$[ebp]
  001c7	51		 push	 ecx
  001c8	e8 00 00 00 00	 call	 _xor_block_aligned@8
  001cd	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  001d0	0f b6 42 07	 movzx	 eax, BYTE PTR [edx+7]
  001d4	83 e0 0f	 and	 eax, 15			; 0000000fH
  001d7	c1 e0 04	 shl	 eax, 4
  001da	8b 4d 0c	 mov	 ecx, DWORD PTR _ctx$[ebp]
  001dd	8d 94 01 00 0e
	00 00		 lea	 edx, DWORD PTR [ecx+eax+3584]
  001e4	52		 push	 edx
  001e5	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  001e8	50		 push	 eax
  001e9	e8 00 00 00 00	 call	 _xor_block_aligned@8
  001ee	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  001f1	0f b6 51 07	 movzx	 edx, BYTE PTR [ecx+7]
  001f5	c1 fa 04	 sar	 edx, 4
  001f8	c1 e2 04	 shl	 edx, 4
  001fb	8b 45 0c	 mov	 eax, DWORD PTR _ctx$[ebp]
  001fe	8d 8c 10 00 0f
	00 00		 lea	 ecx, DWORD PTR [eax+edx+3840]
  00205	51		 push	 ecx
  00206	8d 55 f0	 lea	 edx, DWORD PTR _r$[ebp]
  00209	52		 push	 edx
  0020a	e8 00 00 00 00	 call	 _xor_block_aligned@8

; 450  :     xor_8k( 8); xor_8k( 9); xor_8k(10); xor_8k(11);

  0020f	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00212	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  00216	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00219	c1 e1 04	 shl	 ecx, 4
  0021c	8b 55 0c	 mov	 edx, DWORD PTR _ctx$[ebp]
  0021f	8d 84 0a 00 10
	00 00		 lea	 eax, DWORD PTR [edx+ecx+4096]
  00226	50		 push	 eax
  00227	8d 4d f0	 lea	 ecx, DWORD PTR _r$[ebp]
  0022a	51		 push	 ecx
  0022b	e8 00 00 00 00	 call	 _xor_block_aligned@8
  00230	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00233	0f b6 42 08	 movzx	 eax, BYTE PTR [edx+8]
  00237	c1 f8 04	 sar	 eax, 4
  0023a	c1 e0 04	 shl	 eax, 4
  0023d	8b 4d 0c	 mov	 ecx, DWORD PTR _ctx$[ebp]
  00240	8d 94 01 00 11
	00 00		 lea	 edx, DWORD PTR [ecx+eax+4352]
  00247	52		 push	 edx
  00248	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  0024b	50		 push	 eax
  0024c	e8 00 00 00 00	 call	 _xor_block_aligned@8
  00251	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00254	0f b6 51 09	 movzx	 edx, BYTE PTR [ecx+9]
  00258	83 e2 0f	 and	 edx, 15			; 0000000fH
  0025b	c1 e2 04	 shl	 edx, 4
  0025e	8b 45 0c	 mov	 eax, DWORD PTR _ctx$[ebp]
  00261	8d 8c 10 00 12
	00 00		 lea	 ecx, DWORD PTR [eax+edx+4608]
  00268	51		 push	 ecx
  00269	8d 55 f0	 lea	 edx, DWORD PTR _r$[ebp]
  0026c	52		 push	 edx
  0026d	e8 00 00 00 00	 call	 _xor_block_aligned@8
  00272	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00275	0f b6 48 09	 movzx	 ecx, BYTE PTR [eax+9]
  00279	c1 f9 04	 sar	 ecx, 4
  0027c	c1 e1 04	 shl	 ecx, 4
  0027f	8b 55 0c	 mov	 edx, DWORD PTR _ctx$[ebp]
  00282	8d 84 0a 00 13
	00 00		 lea	 eax, DWORD PTR [edx+ecx+4864]
  00289	50		 push	 eax
  0028a	8d 4d f0	 lea	 ecx, DWORD PTR _r$[ebp]
  0028d	51		 push	 ecx
  0028e	e8 00 00 00 00	 call	 _xor_block_aligned@8
  00293	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00296	0f b6 42 0a	 movzx	 eax, BYTE PTR [edx+10]
  0029a	83 e0 0f	 and	 eax, 15			; 0000000fH
  0029d	c1 e0 04	 shl	 eax, 4
  002a0	8b 4d 0c	 mov	 ecx, DWORD PTR _ctx$[ebp]
  002a3	8d 94 01 00 14
	00 00		 lea	 edx, DWORD PTR [ecx+eax+5120]
  002aa	52		 push	 edx
  002ab	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  002ae	50		 push	 eax
  002af	e8 00 00 00 00	 call	 _xor_block_aligned@8
  002b4	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  002b7	0f b6 51 0a	 movzx	 edx, BYTE PTR [ecx+10]
  002bb	c1 fa 04	 sar	 edx, 4
  002be	c1 e2 04	 shl	 edx, 4
  002c1	8b 45 0c	 mov	 eax, DWORD PTR _ctx$[ebp]
  002c4	8d 8c 10 00 15
	00 00		 lea	 ecx, DWORD PTR [eax+edx+5376]
  002cb	51		 push	 ecx
  002cc	8d 55 f0	 lea	 edx, DWORD PTR _r$[ebp]
  002cf	52		 push	 edx
  002d0	e8 00 00 00 00	 call	 _xor_block_aligned@8
  002d5	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  002d8	0f b6 48 0b	 movzx	 ecx, BYTE PTR [eax+11]
  002dc	83 e1 0f	 and	 ecx, 15			; 0000000fH
  002df	c1 e1 04	 shl	 ecx, 4
  002e2	8b 55 0c	 mov	 edx, DWORD PTR _ctx$[ebp]
  002e5	8d 84 0a 00 16
	00 00		 lea	 eax, DWORD PTR [edx+ecx+5632]
  002ec	50		 push	 eax
  002ed	8d 4d f0	 lea	 ecx, DWORD PTR _r$[ebp]
  002f0	51		 push	 ecx
  002f1	e8 00 00 00 00	 call	 _xor_block_aligned@8
  002f6	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  002f9	0f b6 42 0b	 movzx	 eax, BYTE PTR [edx+11]
  002fd	c1 f8 04	 sar	 eax, 4
  00300	c1 e0 04	 shl	 eax, 4
  00303	8b 4d 0c	 mov	 ecx, DWORD PTR _ctx$[ebp]
  00306	8d 94 01 00 17
	00 00		 lea	 edx, DWORD PTR [ecx+eax+5888]
  0030d	52		 push	 edx
  0030e	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  00311	50		 push	 eax
  00312	e8 00 00 00 00	 call	 _xor_block_aligned@8

; 451  :     xor_8k(12); xor_8k(13); xor_8k(14); xor_8k(15);

  00317	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0031a	0f b6 51 0c	 movzx	 edx, BYTE PTR [ecx+12]
  0031e	83 e2 0f	 and	 edx, 15			; 0000000fH
  00321	c1 e2 04	 shl	 edx, 4
  00324	8b 45 0c	 mov	 eax, DWORD PTR _ctx$[ebp]
  00327	8d 8c 10 00 18
	00 00		 lea	 ecx, DWORD PTR [eax+edx+6144]
  0032e	51		 push	 ecx
  0032f	8d 55 f0	 lea	 edx, DWORD PTR _r$[ebp]
  00332	52		 push	 edx
  00333	e8 00 00 00 00	 call	 _xor_block_aligned@8
  00338	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0033b	0f b6 48 0c	 movzx	 ecx, BYTE PTR [eax+12]
  0033f	c1 f9 04	 sar	 ecx, 4
  00342	c1 e1 04	 shl	 ecx, 4
  00345	8b 55 0c	 mov	 edx, DWORD PTR _ctx$[ebp]
  00348	8d 84 0a 00 19
	00 00		 lea	 eax, DWORD PTR [edx+ecx+6400]
  0034f	50		 push	 eax
  00350	8d 4d f0	 lea	 ecx, DWORD PTR _r$[ebp]
  00353	51		 push	 ecx
  00354	e8 00 00 00 00	 call	 _xor_block_aligned@8
  00359	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0035c	0f b6 42 0d	 movzx	 eax, BYTE PTR [edx+13]
  00360	83 e0 0f	 and	 eax, 15			; 0000000fH
  00363	c1 e0 04	 shl	 eax, 4
  00366	8b 4d 0c	 mov	 ecx, DWORD PTR _ctx$[ebp]
  00369	8d 94 01 00 1a
	00 00		 lea	 edx, DWORD PTR [ecx+eax+6656]
  00370	52		 push	 edx
  00371	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  00374	50		 push	 eax
  00375	e8 00 00 00 00	 call	 _xor_block_aligned@8
  0037a	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0037d	0f b6 51 0d	 movzx	 edx, BYTE PTR [ecx+13]
  00381	c1 fa 04	 sar	 edx, 4
  00384	c1 e2 04	 shl	 edx, 4
  00387	8b 45 0c	 mov	 eax, DWORD PTR _ctx$[ebp]
  0038a	8d 8c 10 00 1b
	00 00		 lea	 ecx, DWORD PTR [eax+edx+6912]
  00391	51		 push	 ecx
  00392	8d 55 f0	 lea	 edx, DWORD PTR _r$[ebp]
  00395	52		 push	 edx
  00396	e8 00 00 00 00	 call	 _xor_block_aligned@8
  0039b	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0039e	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  003a2	83 e1 0f	 and	 ecx, 15			; 0000000fH
  003a5	c1 e1 04	 shl	 ecx, 4
  003a8	8b 55 0c	 mov	 edx, DWORD PTR _ctx$[ebp]
  003ab	8d 84 0a 00 1c
	00 00		 lea	 eax, DWORD PTR [edx+ecx+7168]
  003b2	50		 push	 eax
  003b3	8d 4d f0	 lea	 ecx, DWORD PTR _r$[ebp]
  003b6	51		 push	 ecx
  003b7	e8 00 00 00 00	 call	 _xor_block_aligned@8
  003bc	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  003bf	0f b6 42 0e	 movzx	 eax, BYTE PTR [edx+14]
  003c3	c1 f8 04	 sar	 eax, 4
  003c6	c1 e0 04	 shl	 eax, 4
  003c9	8b 4d 0c	 mov	 ecx, DWORD PTR _ctx$[ebp]
  003cc	8d 94 01 00 1d
	00 00		 lea	 edx, DWORD PTR [ecx+eax+7424]
  003d3	52		 push	 edx
  003d4	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  003d7	50		 push	 eax
  003d8	e8 00 00 00 00	 call	 _xor_block_aligned@8
  003dd	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  003e0	0f b6 51 0f	 movzx	 edx, BYTE PTR [ecx+15]
  003e4	83 e2 0f	 and	 edx, 15			; 0000000fH
  003e7	c1 e2 04	 shl	 edx, 4
  003ea	8b 45 0c	 mov	 eax, DWORD PTR _ctx$[ebp]
  003ed	8d 8c 10 00 1e
	00 00		 lea	 ecx, DWORD PTR [eax+edx+7680]
  003f4	51		 push	 ecx
  003f5	8d 55 f0	 lea	 edx, DWORD PTR _r$[ebp]
  003f8	52		 push	 edx
  003f9	e8 00 00 00 00	 call	 _xor_block_aligned@8
  003fe	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00401	0f b6 48 0f	 movzx	 ecx, BYTE PTR [eax+15]
  00405	c1 f9 04	 sar	 ecx, 4
  00408	c1 e1 04	 shl	 ecx, 4
  0040b	8b 55 0c	 mov	 edx, DWORD PTR _ctx$[ebp]
  0040e	8d 84 0a 00 1f
	00 00		 lea	 eax, DWORD PTR [edx+ecx+7936]
  00415	50		 push	 eax
  00416	8d 4d f0	 lea	 ecx, DWORD PTR _r$[ebp]
  00419	51		 push	 ecx
  0041a	e8 00 00 00 00	 call	 _xor_block_aligned@8

; 452  :     move_block_aligned(a, r);

  0041f	8d 55 f0	 lea	 edx, DWORD PTR _r$[ebp]
  00422	52		 push	 edx
  00423	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00426	50		 push	 eax
  00427	e8 00 00 00 00	 call	 _move_block_aligned@8

; 453  : }

  0042c	8b e5		 mov	 esp, ebp
  0042e	5d		 pop	 ebp
  0042f	c2 08 00	 ret	 8
_GfMul128Tab@8 ENDP
_TEXT	ENDS
PUBLIC	_mul_lex8@4
PUBLIC	_mul_x@4
PUBLIC	_compile_8k_table@8
EXTRN	_memset:PROC
; Function compile flags: /Odtp
;	COMDAT _compile_8k_table@8
_TEXT	SEGMENT
_pj$28256 = -24						; size = 4
_pl$28258 = -20						; size = 4
_pk$28257 = -16						; size = 4
_j$ = -12						; size = 4
_k$ = -8						; size = 4
_i$ = -4						; size = 4
_a$ = 8							; size = 4
_ctx$ = 12						; size = 4
_compile_8k_table@8 PROC				; COMDAT

; 476  : {   int i, j, k;

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 18	 sub	 esp, 24			; 00000018H

; 477  : 
; 478  :     memset(ctx->gf_t8k, 0, 32 * 16 * 16);

  00008	68 00 20 00 00	 push	 8192			; 00002000H
  0000d	6a 00		 push	 0
  0000f	8b 45 0c	 mov	 eax, DWORD PTR _ctx$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _memset
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 479  :     for(i = 0; i < 2 * CBLK_LEN; ++i)

  0001b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00022	eb 09		 jmp	 SHORT $LN21@compile_8k
$LN20@compile_8k:
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00027	83 c1 01	 add	 ecx, 1
  0002a	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN21@compile_8k:
  0002d	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00031	0f 8d 9a 02 00
	00		 jge	 $LN22@compile_8k

; 480  :     {
; 481  :         if(i == 0)

  00037	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  0003b	0f 85 14 01 00
	00		 jne	 $LN18@compile_8k

; 482  :         {
; 483  :             memcpy(ctx->gf_t8k[1][8], a, CBLK_LEN);

  00041	8b 55 0c	 mov	 edx, DWORD PTR _ctx$[ebp]
  00044	81 c2 80 01 00
	00		 add	 edx, 384		; 00000180H
  0004a	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0004d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004f	89 0a		 mov	 DWORD PTR [edx], ecx
  00051	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00054	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00057	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005a	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0005d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00060	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 484  :             for(j = 4; j > 0; j >>= 1)

  00063	c7 45 f4 04 00
	00 00		 mov	 DWORD PTR _j$[ebp], 4
  0006a	eb 08		 jmp	 SHORT $LN17@compile_8k
$LN16@compile_8k:
  0006c	8b 4d f4	 mov	 ecx, DWORD PTR _j$[ebp]
  0006f	d1 f9		 sar	 ecx, 1
  00071	89 4d f4	 mov	 DWORD PTR _j$[ebp], ecx
$LN17@compile_8k:
  00074	83 7d f4 00	 cmp	 DWORD PTR _j$[ebp], 0
  00078	7e 51		 jle	 SHORT $LN15@compile_8k

; 485  :             {
; 486  :                 memcpy(ctx->gf_t8k[1][j], ctx->gf_t8k[1][j + j], CBLK_LEN);

  0007a	8b 55 f4	 mov	 edx, DWORD PTR _j$[ebp]
  0007d	03 55 f4	 add	 edx, DWORD PTR _j$[ebp]
  00080	c1 e2 04	 shl	 edx, 4
  00083	8b 45 0c	 mov	 eax, DWORD PTR _ctx$[ebp]
  00086	8d 8c 10 00 01
	00 00		 lea	 ecx, DWORD PTR [eax+edx+256]
  0008d	8b 55 f4	 mov	 edx, DWORD PTR _j$[ebp]
  00090	c1 e2 04	 shl	 edx, 4
  00093	8b 45 0c	 mov	 eax, DWORD PTR _ctx$[ebp]
  00096	8d 94 10 00 01
	00 00		 lea	 edx, DWORD PTR [eax+edx+256]
  0009d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009f	89 02		 mov	 DWORD PTR [edx], eax
  000a1	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000a4	89 42 04	 mov	 DWORD PTR [edx+4], eax
  000a7	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000aa	89 42 08	 mov	 DWORD PTR [edx+8], eax
  000ad	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  000b0	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 487  :                 mul_x(ctx->gf_t8k[1][j]);

  000b3	8b 55 f4	 mov	 edx, DWORD PTR _j$[ebp]
  000b6	c1 e2 04	 shl	 edx, 4
  000b9	8b 45 0c	 mov	 eax, DWORD PTR _ctx$[ebp]
  000bc	8d 8c 10 00 01
	00 00		 lea	 ecx, DWORD PTR [eax+edx+256]
  000c3	51		 push	 ecx
  000c4	e8 00 00 00 00	 call	 _mul_x@4

; 488  :             }

  000c9	eb a1		 jmp	 SHORT $LN16@compile_8k
$LN15@compile_8k:

; 489  :             memcpy(ctx->gf_t8k[0][8], ctx->gf_t8k[1][1], CBLK_LEN);

  000cb	8b 55 0c	 mov	 edx, DWORD PTR _ctx$[ebp]
  000ce	81 c2 10 01 00
	00		 add	 edx, 272		; 00000110H
  000d4	8b 45 0c	 mov	 eax, DWORD PTR _ctx$[ebp]
  000d7	05 80 00 00 00	 add	 eax, 128		; 00000080H
  000dc	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000de	89 08		 mov	 DWORD PTR [eax], ecx
  000e0	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000e3	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  000e6	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  000e9	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000ec	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  000ef	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 490  :             mul_x(ctx->gf_t8k[0][8]);

  000f2	8b 45 0c	 mov	 eax, DWORD PTR _ctx$[ebp]
  000f5	05 80 00 00 00	 add	 eax, 128		; 00000080H
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 _mul_x@4

; 491  :             for(j = 4; j > 0; j >>= 1)

  00100	c7 45 f4 04 00
	00 00		 mov	 DWORD PTR _j$[ebp], 4
  00107	eb 08		 jmp	 SHORT $LN14@compile_8k
$LN13@compile_8k:
  00109	8b 4d f4	 mov	 ecx, DWORD PTR _j$[ebp]
  0010c	d1 f9		 sar	 ecx, 1
  0010e	89 4d f4	 mov	 DWORD PTR _j$[ebp], ecx
$LN14@compile_8k:
  00111	83 7d f4 00	 cmp	 DWORD PTR _j$[ebp], 0
  00115	7e 3c		 jle	 SHORT $LN12@compile_8k

; 492  :             {
; 493  :                 memcpy(ctx->gf_t8k[0][j], ctx->gf_t8k[0][j + j], CBLK_LEN);

  00117	8b 55 f4	 mov	 edx, DWORD PTR _j$[ebp]
  0011a	03 55 f4	 add	 edx, DWORD PTR _j$[ebp]
  0011d	c1 e2 04	 shl	 edx, 4
  00120	03 55 0c	 add	 edx, DWORD PTR _ctx$[ebp]
  00123	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  00126	c1 e0 04	 shl	 eax, 4
  00129	03 45 0c	 add	 eax, DWORD PTR _ctx$[ebp]
  0012c	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0012e	89 08		 mov	 DWORD PTR [eax], ecx
  00130	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00133	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00136	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00139	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0013c	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  0013f	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 494  :                 mul_x(ctx->gf_t8k[0][j]);

  00142	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  00145	c1 e0 04	 shl	 eax, 4
  00148	03 45 0c	 add	 eax, DWORD PTR _ctx$[ebp]
  0014b	50		 push	 eax
  0014c	e8 00 00 00 00	 call	 _mul_x@4

; 495  :             }

  00151	eb b6		 jmp	 SHORT $LN13@compile_8k
$LN12@compile_8k:

; 496  :         }
; 497  :         else if(i > 1)

  00153	eb 71		 jmp	 SHORT $LN11@compile_8k
$LN18@compile_8k:
  00155	83 7d fc 01	 cmp	 DWORD PTR _i$[ebp], 1
  00159	7e 6b		 jle	 SHORT $LN11@compile_8k

; 498  :             for(j = 8; j > 0; j >>= 1)

  0015b	c7 45 f4 08 00
	00 00		 mov	 DWORD PTR _j$[ebp], 8
  00162	eb 08		 jmp	 SHORT $LN9@compile_8k
$LN8@compile_8k:
  00164	8b 4d f4	 mov	 ecx, DWORD PTR _j$[ebp]
  00167	d1 f9		 sar	 ecx, 1
  00169	89 4d f4	 mov	 DWORD PTR _j$[ebp], ecx
$LN9@compile_8k:
  0016c	83 7d f4 00	 cmp	 DWORD PTR _j$[ebp], 0
  00170	7e 54		 jle	 SHORT $LN11@compile_8k

; 499  :             {
; 500  :                 memcpy(ctx->gf_t8k[i][j], ctx->gf_t8k[i - 2][j], CBLK_LEN);

  00172	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00175	83 ea 02	 sub	 edx, 2
  00178	c1 e2 08	 shl	 edx, 8
  0017b	03 55 0c	 add	 edx, DWORD PTR _ctx$[ebp]
  0017e	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  00181	c1 e0 04	 shl	 eax, 4
  00184	03 d0		 add	 edx, eax
  00186	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00189	c1 e1 08	 shl	 ecx, 8
  0018c	03 4d 0c	 add	 ecx, DWORD PTR _ctx$[ebp]
  0018f	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  00192	c1 e0 04	 shl	 eax, 4
  00195	03 c8		 add	 ecx, eax
  00197	8b 02		 mov	 eax, DWORD PTR [edx]
  00199	89 01		 mov	 DWORD PTR [ecx], eax
  0019b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0019e	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  001a1	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  001a4	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  001a7	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  001aa	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 501  :                 mul_x8(ctx->gf_t8k[i][j]);

  001ad	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  001b0	c1 e0 08	 shl	 eax, 8
  001b3	03 45 0c	 add	 eax, DWORD PTR _ctx$[ebp]
  001b6	8b 4d f4	 mov	 ecx, DWORD PTR _j$[ebp]
  001b9	c1 e1 04	 shl	 ecx, 4
  001bc	03 c1		 add	 eax, ecx
  001be	50		 push	 eax
  001bf	e8 00 00 00 00	 call	 _mul_lex8@4

; 502  :             }

  001c4	eb 9e		 jmp	 SHORT $LN8@compile_8k
$LN11@compile_8k:

; 503  : 
; 504  :         for(j = 2; j < 16; j += j)

  001c6	c7 45 f4 02 00
	00 00		 mov	 DWORD PTR _j$[ebp], 2
  001cd	eb 09		 jmp	 SHORT $LN6@compile_8k
$LN5@compile_8k:
  001cf	8b 55 f4	 mov	 edx, DWORD PTR _j$[ebp]
  001d2	03 55 f4	 add	 edx, DWORD PTR _j$[ebp]
  001d5	89 55 f4	 mov	 DWORD PTR _j$[ebp], edx
$LN6@compile_8k:
  001d8	83 7d f4 10	 cmp	 DWORD PTR _j$[ebp], 16	; 00000010H
  001dc	0f 8d ea 00 00
	00		 jge	 $LN4@compile_8k

; 505  :         {
; 506  :             mode(32t) *pj = ctx->gf_t8k[i][j];

  001e2	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  001e5	c1 e0 08	 shl	 eax, 8
  001e8	03 45 0c	 add	 eax, DWORD PTR _ctx$[ebp]
  001eb	8b 4d f4	 mov	 ecx, DWORD PTR _j$[ebp]
  001ee	c1 e1 04	 shl	 ecx, 4
  001f1	03 c1		 add	 eax, ecx
  001f3	89 45 e8	 mov	 DWORD PTR _pj$28256[ebp], eax

; 507  :             mode(32t) *pk = ctx->gf_t8k[i][1];

  001f6	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  001f9	c1 e2 08	 shl	 edx, 8
  001fc	8b 45 0c	 mov	 eax, DWORD PTR _ctx$[ebp]
  001ff	8d 4c 10 10	 lea	 ecx, DWORD PTR [eax+edx+16]
  00203	89 4d f0	 mov	 DWORD PTR _pk$28257[ebp], ecx

; 508  :             mode(32t) *pl = ctx->gf_t8k[i][j + 1];

  00206	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00209	c1 e2 08	 shl	 edx, 8
  0020c	03 55 0c	 add	 edx, DWORD PTR _ctx$[ebp]
  0020f	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  00212	83 c0 01	 add	 eax, 1
  00215	c1 e0 04	 shl	 eax, 4
  00218	03 d0		 add	 edx, eax
  0021a	89 55 ec	 mov	 DWORD PTR _pl$28258[ebp], edx

; 509  : 
; 510  :             for(k = 1; k < j; ++k)

  0021d	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _k$[ebp], 1
  00224	eb 09		 jmp	 SHORT $LN3@compile_8k
$LN2@compile_8k:
  00226	8b 4d f8	 mov	 ecx, DWORD PTR _k$[ebp]
  00229	83 c1 01	 add	 ecx, 1
  0022c	89 4d f8	 mov	 DWORD PTR _k$[ebp], ecx
$LN3@compile_8k:
  0022f	8b 55 f8	 mov	 edx, DWORD PTR _k$[ebp]
  00232	3b 55 f4	 cmp	 edx, DWORD PTR _j$[ebp]
  00235	0f 8d 8c 00 00
	00		 jge	 $LN1@compile_8k

; 511  :             {
; 512  :                 *pl++ = pj[0] ^ *pk++;

  0023b	8b 45 e8	 mov	 eax, DWORD PTR _pj$28256[ebp]
  0023e	8b 4d f0	 mov	 ecx, DWORD PTR _pk$28257[ebp]
  00241	8b 10		 mov	 edx, DWORD PTR [eax]
  00243	33 11		 xor	 edx, DWORD PTR [ecx]
  00245	8b 45 ec	 mov	 eax, DWORD PTR _pl$28258[ebp]
  00248	89 10		 mov	 DWORD PTR [eax], edx
  0024a	8b 4d ec	 mov	 ecx, DWORD PTR _pl$28258[ebp]
  0024d	83 c1 04	 add	 ecx, 4
  00250	89 4d ec	 mov	 DWORD PTR _pl$28258[ebp], ecx
  00253	8b 55 f0	 mov	 edx, DWORD PTR _pk$28257[ebp]
  00256	83 c2 04	 add	 edx, 4
  00259	89 55 f0	 mov	 DWORD PTR _pk$28257[ebp], edx

; 513  :                 *pl++ = pj[1] ^ *pk++;

  0025c	8b 45 e8	 mov	 eax, DWORD PTR _pj$28256[ebp]
  0025f	8b 4d f0	 mov	 ecx, DWORD PTR _pk$28257[ebp]
  00262	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00265	33 11		 xor	 edx, DWORD PTR [ecx]
  00267	8b 45 ec	 mov	 eax, DWORD PTR _pl$28258[ebp]
  0026a	89 10		 mov	 DWORD PTR [eax], edx
  0026c	8b 4d ec	 mov	 ecx, DWORD PTR _pl$28258[ebp]
  0026f	83 c1 04	 add	 ecx, 4
  00272	89 4d ec	 mov	 DWORD PTR _pl$28258[ebp], ecx
  00275	8b 55 f0	 mov	 edx, DWORD PTR _pk$28257[ebp]
  00278	83 c2 04	 add	 edx, 4
  0027b	89 55 f0	 mov	 DWORD PTR _pk$28257[ebp], edx

; 514  :                 *pl++ = pj[2] ^ *pk++;

  0027e	8b 45 e8	 mov	 eax, DWORD PTR _pj$28256[ebp]
  00281	8b 4d f0	 mov	 ecx, DWORD PTR _pk$28257[ebp]
  00284	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00287	33 11		 xor	 edx, DWORD PTR [ecx]
  00289	8b 45 ec	 mov	 eax, DWORD PTR _pl$28258[ebp]
  0028c	89 10		 mov	 DWORD PTR [eax], edx
  0028e	8b 4d ec	 mov	 ecx, DWORD PTR _pl$28258[ebp]
  00291	83 c1 04	 add	 ecx, 4
  00294	89 4d ec	 mov	 DWORD PTR _pl$28258[ebp], ecx
  00297	8b 55 f0	 mov	 edx, DWORD PTR _pk$28257[ebp]
  0029a	83 c2 04	 add	 edx, 4
  0029d	89 55 f0	 mov	 DWORD PTR _pk$28257[ebp], edx

; 515  :                 *pl++ = pj[3] ^ *pk++;

  002a0	8b 45 e8	 mov	 eax, DWORD PTR _pj$28256[ebp]
  002a3	8b 4d f0	 mov	 ecx, DWORD PTR _pk$28257[ebp]
  002a6	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  002a9	33 11		 xor	 edx, DWORD PTR [ecx]
  002ab	8b 45 ec	 mov	 eax, DWORD PTR _pl$28258[ebp]
  002ae	89 10		 mov	 DWORD PTR [eax], edx
  002b0	8b 4d ec	 mov	 ecx, DWORD PTR _pl$28258[ebp]
  002b3	83 c1 04	 add	 ecx, 4
  002b6	89 4d ec	 mov	 DWORD PTR _pl$28258[ebp], ecx
  002b9	8b 55 f0	 mov	 edx, DWORD PTR _pk$28257[ebp]
  002bc	83 c2 04	 add	 edx, 4
  002bf	89 55 f0	 mov	 DWORD PTR _pk$28257[ebp], edx

; 516  :             }

  002c2	e9 5f ff ff ff	 jmp	 $LN2@compile_8k
$LN1@compile_8k:

; 517  :         }

  002c7	e9 03 ff ff ff	 jmp	 $LN5@compile_8k
$LN4@compile_8k:

; 518  :     }

  002cc	e9 53 fd ff ff	 jmp	 $LN20@compile_8k
$LN22@compile_8k:

; 519  : }

  002d1	8b e5		 mov	 esp, ebp
  002d3	5d		 pop	 ebp
  002d4	c2 08 00	 ret	 8
_compile_8k_table@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _mul_x@4
_TEXT	SEGMENT
_t$ = -4						; size = 4
_x$ = 8							; size = 4
_mul_x@4 PROC						; COMDAT

; 294  : {   mode(32t)   t;

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 295  : 
; 296  :     bsw_32(x, 4);

  00006	6a 04		 push	 4
  00008	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _bsw_32@8

; 297  : 
; 298  :     /* at this point the filed element bits 0..127 are set out  */
; 299  :     /* as follows in 32-bit words (where the most significant   */
; 300  :     /* (ms) numeric bits are to the left)                       */
; 301  :     /*                                                          */
; 302  :     /*            x[0]      x[1]      x[2]      x[3]            */
; 303  :     /*          ms    ls  ms    ls  ms    ls  ms     ls         */
; 304  :     /* field:   0 ... 31  32 .. 63  64 .. 95  96 .. 127         */
; 305  : 
; 306  :     t = gf_poly[x[3] & 1];          /* bit 127 of the element   */

  00011	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00014	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00017	83 e2 01	 and	 edx, 1
  0001a	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _gf_poly[edx*4]
  00021	89 45 fc	 mov	 DWORD PTR _t$[ebp], eax

; 307  :     x[3] = (x[3] >> 1) | (x[2] << 31);  /* shift bits up by one */

  00024	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00027	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0002a	d1 ea		 shr	 edx, 1
  0002c	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  0002f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00032	c1 e1 1f	 shl	 ecx, 31			; 0000001fH
  00035	0b d1		 or	 edx, ecx
  00037	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  0003a	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 308  :     x[2] = (x[2] >> 1) | (x[1] << 31);  /* position             */

  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00040	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00043	d1 ea		 shr	 edx, 1
  00045	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00048	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004b	c1 e1 1f	 shl	 ecx, 31			; 0000001fH
  0004e	0b d1		 or	 edx, ecx
  00050	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00053	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 309  :     x[1] = (x[1] >> 1) | (x[0] << 31);  /* if bit 7 is 1 xor in */

  00056	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00059	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0005c	d1 ea		 shr	 edx, 1
  0005e	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00061	8b 08		 mov	 ecx, DWORD PTR [eax]
  00063	c1 e1 1f	 shl	 ecx, 31			; 0000001fH
  00066	0b d1		 or	 edx, ecx
  00068	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  0006b	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 310  :     x[0] = (x[0] >> 1) ^ t;             /* the field polynomial */

  0006e	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00071	8b 11		 mov	 edx, DWORD PTR [ecx]
  00073	d1 ea		 shr	 edx, 1
  00075	33 55 fc	 xor	 edx, DWORD PTR _t$[ebp]
  00078	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  0007b	89 10		 mov	 DWORD PTR [eax], edx

; 311  :     bsw_32(x, 4);

  0007d	6a 04		 push	 4
  0007f	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00082	51		 push	 ecx
  00083	e8 00 00 00 00	 call	 _bsw_32@8

; 312  : }

  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c2 04 00	 ret	 4
_mul_x@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _mul_lex8@4
_TEXT	SEGMENT
_t$ = -4						; size = 4
_x$ = 8							; size = 4
_mul_lex8@4 PROC					; COMDAT

; 345  : {   mode(32t)   t = (x[3] >> 24);       /* in little endian format  */

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00009	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0000c	c1 e9 18	 shr	 ecx, 24			; 00000018H
  0000f	89 4d fc	 mov	 DWORD PTR _t$[ebp], ecx

; 346  :     x[3] = (x[3] << 8) | (x[2] >> 24);

  00012	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  00015	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00018	c1 e0 08	 shl	 eax, 8
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0001e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00021	c1 ea 18	 shr	 edx, 24			; 00000018H
  00024	0b c2		 or	 eax, edx
  00026	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00029	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 347  :     x[2] = (x[2] << 8) | (x[1] >> 24);

  0002c	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  0002f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00032	c1 e0 08	 shl	 eax, 8
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00038	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0003b	c1 ea 18	 shr	 edx, 24			; 00000018H
  0003e	0b c2		 or	 eax, edx
  00040	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00043	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 348  :     x[1] = (x[1] << 8) | (x[0] >> 24);

  00046	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  00049	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0004c	c1 e0 08	 shl	 eax, 8
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00052	8b 11		 mov	 edx, DWORD PTR [ecx]
  00054	c1 ea 18	 shr	 edx, 24			; 00000018H
  00057	0b c2		 or	 eax, edx
  00059	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0005c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 349  :     x[0] = (x[0] << 8) ^ gft_le[t];

  0005f	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  00062	8b 02		 mov	 eax, DWORD PTR [edx]
  00064	c1 e0 08	 shl	 eax, 8
  00067	8b 4d fc	 mov	 ecx, DWORD PTR _t$[ebp]
  0006a	0f b7 14 4d 00
	00 00 00	 movzx	 edx, WORD PTR _gft_le[ecx*2]
  00072	33 c2		 xor	 eax, edx
  00074	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00077	89 01		 mov	 DWORD PTR [ecx], eax

; 350  : }

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 04 00	 ret	 4
_mul_lex8@4 ENDP
_TEXT	ENDS
PUBLIC	_mul_lex8_64@4
PUBLIC	_mul_x64@4
PUBLIC	_compile_4k_table64@8
; Function compile flags: /Odtp
;	COMDAT _compile_4k_table64@8
_TEXT	SEGMENT
_pj$28289 = -24						; size = 4
_pl$28291 = -20						; size = 4
_pk$28290 = -16						; size = 4
_j$ = -12						; size = 4
_k$ = -8						; size = 4
_i$ = -4						; size = 4
_a$ = 8							; size = 4
_ctx$ = 12						; size = 4
_compile_4k_table64@8 PROC				; COMDAT

; 523  : {   int i, j, k;

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 18	 sub	 esp, 24			; 00000018H
  00008	56		 push	 esi
  00009	57		 push	 edi

; 524  : 
; 525  :     memset(ctx->gf_t4k, 0, sizeof(ctx->gf_t4k));

  0000a	68 00 10 00 00	 push	 4096			; 00001000H
  0000f	6a 00		 push	 0
  00011	8b 45 0c	 mov	 eax, DWORD PTR _ctx$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 _memset
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 526  :     for(i = 0; i < 2 * CBLK_LEN8; ++i)

  0001d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00024	eb 09		 jmp	 SHORT $LN21@compile_4k
$LN20@compile_4k:
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00029	83 c1 01	 add	 ecx, 1
  0002c	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN21@compile_4k:
  0002f	83 7d fc 10	 cmp	 DWORD PTR _i$[ebp], 16	; 00000010H
  00033	0f 8d 6b 02 00
	00		 jge	 $LN22@compile_4k

; 527  :     {
; 528  :         if(i == 0)

  00039	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  0003d	0f 85 f1 00 00
	00		 jne	 $LN18@compile_4k

; 529  :         {
; 530  :             memcpy(ctx->gf_t4k[1][8], a, CBLK_LEN8);

  00043	8b 55 0c	 mov	 edx, DWORD PTR _ctx$[ebp]
  00046	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	89 8a 80 01 00
	00		 mov	 DWORD PTR [edx+384], ecx
  00051	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00054	89 82 84 01 00
	00		 mov	 DWORD PTR [edx+388], eax

; 531  :             for(j = 4; j > 0; j >>= 1)

  0005a	c7 45 f4 04 00
	00 00		 mov	 DWORD PTR _j$[ebp], 4
  00061	eb 08		 jmp	 SHORT $LN17@compile_4k
$LN16@compile_4k:
  00063	8b 4d f4	 mov	 ecx, DWORD PTR _j$[ebp]
  00066	d1 f9		 sar	 ecx, 1
  00068	89 4d f4	 mov	 DWORD PTR _j$[ebp], ecx
$LN17@compile_4k:
  0006b	83 7d f4 00	 cmp	 DWORD PTR _j$[ebp], 0
  0006f	7e 49		 jle	 SHORT $LN15@compile_4k

; 532  :             {
; 533  :                 memcpy(ctx->gf_t4k[1][j], ctx->gf_t4k[1][j + j], CBLK_LEN8);

  00071	8b 55 f4	 mov	 edx, DWORD PTR _j$[ebp]
  00074	03 55 f4	 add	 edx, DWORD PTR _j$[ebp]
  00077	c1 e2 04	 shl	 edx, 4
  0007a	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  0007d	c1 e0 04	 shl	 eax, 4
  00080	8b 4d 0c	 mov	 ecx, DWORD PTR _ctx$[ebp]
  00083	8b 75 0c	 mov	 esi, DWORD PTR _ctx$[ebp]
  00086	8b bc 16 00 01
	00 00		 mov	 edi, DWORD PTR [esi+edx+256]
  0008d	89 bc 01 00 01
	00 00		 mov	 DWORD PTR [ecx+eax+256], edi
  00094	8b 94 16 04 01
	00 00		 mov	 edx, DWORD PTR [esi+edx+260]
  0009b	89 94 01 04 01
	00 00		 mov	 DWORD PTR [ecx+eax+260], edx

; 534  :                 mul_x64(ctx->gf_t4k[1][j]);

  000a2	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  000a5	c1 e0 04	 shl	 eax, 4
  000a8	8b 4d 0c	 mov	 ecx, DWORD PTR _ctx$[ebp]
  000ab	8d 94 01 00 01
	00 00		 lea	 edx, DWORD PTR [ecx+eax+256]
  000b2	52		 push	 edx
  000b3	e8 00 00 00 00	 call	 _mul_x64@4

; 535  :             }

  000b8	eb a9		 jmp	 SHORT $LN16@compile_4k
$LN15@compile_4k:

; 536  :             memcpy(ctx->gf_t4k[0][8], ctx->gf_t4k[1][1], CBLK_LEN8);

  000ba	8b 45 0c	 mov	 eax, DWORD PTR _ctx$[ebp]
  000bd	8b 4d 0c	 mov	 ecx, DWORD PTR _ctx$[ebp]
  000c0	8b 91 10 01 00
	00		 mov	 edx, DWORD PTR [ecx+272]
  000c6	89 90 80 00 00
	00		 mov	 DWORD PTR [eax+128], edx
  000cc	8b 89 14 01 00
	00		 mov	 ecx, DWORD PTR [ecx+276]
  000d2	89 88 84 00 00
	00		 mov	 DWORD PTR [eax+132], ecx

; 537  :             mul_x64(ctx->gf_t4k[0][8]);

  000d8	8b 55 0c	 mov	 edx, DWORD PTR _ctx$[ebp]
  000db	81 c2 80 00 00
	00		 add	 edx, 128		; 00000080H
  000e1	52		 push	 edx
  000e2	e8 00 00 00 00	 call	 _mul_x64@4

; 538  :             for(j = 4; j > 0; j >>= 1)

  000e7	c7 45 f4 04 00
	00 00		 mov	 DWORD PTR _j$[ebp], 4
  000ee	eb 08		 jmp	 SHORT $LN14@compile_4k
$LN13@compile_4k:
  000f0	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  000f3	d1 f8		 sar	 eax, 1
  000f5	89 45 f4	 mov	 DWORD PTR _j$[ebp], eax
$LN14@compile_4k:
  000f8	83 7d f4 00	 cmp	 DWORD PTR _j$[ebp], 0
  000fc	7e 34		 jle	 SHORT $LN12@compile_4k

; 539  :             {
; 540  :                 memcpy(ctx->gf_t4k[0][j], ctx->gf_t4k[0][j + j], CBLK_LEN8);

  000fe	8b 4d f4	 mov	 ecx, DWORD PTR _j$[ebp]
  00101	03 4d f4	 add	 ecx, DWORD PTR _j$[ebp]
  00104	c1 e1 04	 shl	 ecx, 4
  00107	8b 55 f4	 mov	 edx, DWORD PTR _j$[ebp]
  0010a	c1 e2 04	 shl	 edx, 4
  0010d	8b 45 0c	 mov	 eax, DWORD PTR _ctx$[ebp]
  00110	8b 75 0c	 mov	 esi, DWORD PTR _ctx$[ebp]
  00113	8b 3c 0e	 mov	 edi, DWORD PTR [esi+ecx]
  00116	89 3c 10	 mov	 DWORD PTR [eax+edx], edi
  00119	8b 4c 0e 04	 mov	 ecx, DWORD PTR [esi+ecx+4]
  0011d	89 4c 10 04	 mov	 DWORD PTR [eax+edx+4], ecx

; 541  :                 mul_x64(ctx->gf_t4k[0][j]);

  00121	8b 55 f4	 mov	 edx, DWORD PTR _j$[ebp]
  00124	c1 e2 04	 shl	 edx, 4
  00127	03 55 0c	 add	 edx, DWORD PTR _ctx$[ebp]
  0012a	52		 push	 edx
  0012b	e8 00 00 00 00	 call	 _mul_x64@4

; 542  :             }

  00130	eb be		 jmp	 SHORT $LN13@compile_4k
$LN12@compile_4k:

; 543  :         }
; 544  :         else if(i > 1)

  00132	eb 65		 jmp	 SHORT $LN11@compile_4k
$LN18@compile_4k:
  00134	83 7d fc 01	 cmp	 DWORD PTR _i$[ebp], 1
  00138	7e 5f		 jle	 SHORT $LN11@compile_4k

; 545  :             for(j = 8; j > 0; j >>= 1)

  0013a	c7 45 f4 08 00
	00 00		 mov	 DWORD PTR _j$[ebp], 8
  00141	eb 08		 jmp	 SHORT $LN9@compile_4k
$LN8@compile_4k:
  00143	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  00146	d1 f8		 sar	 eax, 1
  00148	89 45 f4	 mov	 DWORD PTR _j$[ebp], eax
$LN9@compile_4k:
  0014b	83 7d f4 00	 cmp	 DWORD PTR _j$[ebp], 0
  0014f	7e 48		 jle	 SHORT $LN11@compile_4k

; 546  :             {
; 547  :                 memcpy(ctx->gf_t4k[i][j], ctx->gf_t4k[i - 2][j], CBLK_LEN8);

  00151	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00154	83 e9 02	 sub	 ecx, 2
  00157	c1 e1 08	 shl	 ecx, 8
  0015a	03 4d 0c	 add	 ecx, DWORD PTR _ctx$[ebp]
  0015d	8b 55 f4	 mov	 edx, DWORD PTR _j$[ebp]
  00160	c1 e2 04	 shl	 edx, 4
  00163	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00166	c1 e0 08	 shl	 eax, 8
  00169	03 45 0c	 add	 eax, DWORD PTR _ctx$[ebp]
  0016c	8b 75 f4	 mov	 esi, DWORD PTR _j$[ebp]
  0016f	c1 e6 04	 shl	 esi, 4
  00172	8b 3c 11	 mov	 edi, DWORD PTR [ecx+edx]
  00175	89 3c 30	 mov	 DWORD PTR [eax+esi], edi
  00178	8b 4c 11 04	 mov	 ecx, DWORD PTR [ecx+edx+4]
  0017c	89 4c 30 04	 mov	 DWORD PTR [eax+esi+4], ecx

; 548  :                 mul_x8_64(ctx->gf_t4k[i][j]);

  00180	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00183	c1 e2 08	 shl	 edx, 8
  00186	03 55 0c	 add	 edx, DWORD PTR _ctx$[ebp]
  00189	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  0018c	c1 e0 04	 shl	 eax, 4
  0018f	03 d0		 add	 edx, eax
  00191	52		 push	 edx
  00192	e8 00 00 00 00	 call	 _mul_lex8_64@4

; 549  :             }

  00197	eb aa		 jmp	 SHORT $LN8@compile_4k
$LN11@compile_4k:

; 550  : 
; 551  :         for(j = 2; j < 16; j += j)

  00199	c7 45 f4 02 00
	00 00		 mov	 DWORD PTR _j$[ebp], 2
  001a0	eb 09		 jmp	 SHORT $LN6@compile_4k
$LN5@compile_4k:
  001a2	8b 4d f4	 mov	 ecx, DWORD PTR _j$[ebp]
  001a5	03 4d f4	 add	 ecx, DWORD PTR _j$[ebp]
  001a8	89 4d f4	 mov	 DWORD PTR _j$[ebp], ecx
$LN6@compile_4k:
  001ab	83 7d f4 10	 cmp	 DWORD PTR _j$[ebp], 16	; 00000010H
  001af	0f 8d ea 00 00
	00		 jge	 $LN4@compile_4k

; 552  :         {
; 553  :             mode(32t) *pj = ctx->gf_t4k[i][j];

  001b5	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  001b8	c1 e2 08	 shl	 edx, 8
  001bb	03 55 0c	 add	 edx, DWORD PTR _ctx$[ebp]
  001be	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  001c1	c1 e0 04	 shl	 eax, 4
  001c4	03 d0		 add	 edx, eax
  001c6	89 55 e8	 mov	 DWORD PTR _pj$28289[ebp], edx

; 554  :             mode(32t) *pk = ctx->gf_t4k[i][1];

  001c9	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  001cc	c1 e1 08	 shl	 ecx, 8
  001cf	8b 55 0c	 mov	 edx, DWORD PTR _ctx$[ebp]
  001d2	8d 44 0a 10	 lea	 eax, DWORD PTR [edx+ecx+16]
  001d6	89 45 f0	 mov	 DWORD PTR _pk$28290[ebp], eax

; 555  :             mode(32t) *pl = ctx->gf_t4k[i][j + 1];

  001d9	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  001dc	c1 e1 08	 shl	 ecx, 8
  001df	03 4d 0c	 add	 ecx, DWORD PTR _ctx$[ebp]
  001e2	8b 55 f4	 mov	 edx, DWORD PTR _j$[ebp]
  001e5	83 c2 01	 add	 edx, 1
  001e8	c1 e2 04	 shl	 edx, 4
  001eb	03 ca		 add	 ecx, edx
  001ed	89 4d ec	 mov	 DWORD PTR _pl$28291[ebp], ecx

; 556  : 
; 557  :             for(k = 1; k < j; ++k)

  001f0	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _k$[ebp], 1
  001f7	eb 09		 jmp	 SHORT $LN3@compile_4k
$LN2@compile_4k:
  001f9	8b 45 f8	 mov	 eax, DWORD PTR _k$[ebp]
  001fc	83 c0 01	 add	 eax, 1
  001ff	89 45 f8	 mov	 DWORD PTR _k$[ebp], eax
$LN3@compile_4k:
  00202	8b 4d f8	 mov	 ecx, DWORD PTR _k$[ebp]
  00205	3b 4d f4	 cmp	 ecx, DWORD PTR _j$[ebp]
  00208	0f 8d 8c 00 00
	00		 jge	 $LN1@compile_4k

; 558  :             {
; 559  :                 *pl++ = pj[0] ^ *pk++;

  0020e	8b 55 e8	 mov	 edx, DWORD PTR _pj$28289[ebp]
  00211	8b 45 f0	 mov	 eax, DWORD PTR _pk$28290[ebp]
  00214	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00216	33 08		 xor	 ecx, DWORD PTR [eax]
  00218	8b 55 ec	 mov	 edx, DWORD PTR _pl$28291[ebp]
  0021b	89 0a		 mov	 DWORD PTR [edx], ecx
  0021d	8b 45 ec	 mov	 eax, DWORD PTR _pl$28291[ebp]
  00220	83 c0 04	 add	 eax, 4
  00223	89 45 ec	 mov	 DWORD PTR _pl$28291[ebp], eax
  00226	8b 4d f0	 mov	 ecx, DWORD PTR _pk$28290[ebp]
  00229	83 c1 04	 add	 ecx, 4
  0022c	89 4d f0	 mov	 DWORD PTR _pk$28290[ebp], ecx

; 560  :                 *pl++ = pj[1] ^ *pk++;

  0022f	8b 55 e8	 mov	 edx, DWORD PTR _pj$28289[ebp]
  00232	8b 45 f0	 mov	 eax, DWORD PTR _pk$28290[ebp]
  00235	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00238	33 08		 xor	 ecx, DWORD PTR [eax]
  0023a	8b 55 ec	 mov	 edx, DWORD PTR _pl$28291[ebp]
  0023d	89 0a		 mov	 DWORD PTR [edx], ecx
  0023f	8b 45 ec	 mov	 eax, DWORD PTR _pl$28291[ebp]
  00242	83 c0 04	 add	 eax, 4
  00245	89 45 ec	 mov	 DWORD PTR _pl$28291[ebp], eax
  00248	8b 4d f0	 mov	 ecx, DWORD PTR _pk$28290[ebp]
  0024b	83 c1 04	 add	 ecx, 4
  0024e	89 4d f0	 mov	 DWORD PTR _pk$28290[ebp], ecx

; 561  :                 *pl++ = pj[2] ^ *pk++;

  00251	8b 55 e8	 mov	 edx, DWORD PTR _pj$28289[ebp]
  00254	8b 45 f0	 mov	 eax, DWORD PTR _pk$28290[ebp]
  00257	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0025a	33 08		 xor	 ecx, DWORD PTR [eax]
  0025c	8b 55 ec	 mov	 edx, DWORD PTR _pl$28291[ebp]
  0025f	89 0a		 mov	 DWORD PTR [edx], ecx
  00261	8b 45 ec	 mov	 eax, DWORD PTR _pl$28291[ebp]
  00264	83 c0 04	 add	 eax, 4
  00267	89 45 ec	 mov	 DWORD PTR _pl$28291[ebp], eax
  0026a	8b 4d f0	 mov	 ecx, DWORD PTR _pk$28290[ebp]
  0026d	83 c1 04	 add	 ecx, 4
  00270	89 4d f0	 mov	 DWORD PTR _pk$28290[ebp], ecx

; 562  :                 *pl++ = pj[3] ^ *pk++;

  00273	8b 55 e8	 mov	 edx, DWORD PTR _pj$28289[ebp]
  00276	8b 45 f0	 mov	 eax, DWORD PTR _pk$28290[ebp]
  00279	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0027c	33 08		 xor	 ecx, DWORD PTR [eax]
  0027e	8b 55 ec	 mov	 edx, DWORD PTR _pl$28291[ebp]
  00281	89 0a		 mov	 DWORD PTR [edx], ecx
  00283	8b 45 ec	 mov	 eax, DWORD PTR _pl$28291[ebp]
  00286	83 c0 04	 add	 eax, 4
  00289	89 45 ec	 mov	 DWORD PTR _pl$28291[ebp], eax
  0028c	8b 4d f0	 mov	 ecx, DWORD PTR _pk$28290[ebp]
  0028f	83 c1 04	 add	 ecx, 4
  00292	89 4d f0	 mov	 DWORD PTR _pk$28290[ebp], ecx

; 563  :             }

  00295	e9 5f ff ff ff	 jmp	 $LN2@compile_4k
$LN1@compile_4k:

; 564  :         }

  0029a	e9 03 ff ff ff	 jmp	 $LN5@compile_4k
$LN4@compile_4k:

; 565  :     }

  0029f	e9 82 fd ff ff	 jmp	 $LN20@compile_4k
$LN22@compile_4k:

; 566  : }

  002a4	5f		 pop	 edi
  002a5	5e		 pop	 esi
  002a6	8b e5		 mov	 esp, ebp
  002a8	5d		 pop	 ebp
  002a9	c2 08 00	 ret	 8
_compile_4k_table64@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _mul_x64@4
_TEXT	SEGMENT
_t$ = -4						; size = 4
_x$ = 8							; size = 4
_mul_x64@4 PROC						; COMDAT

; 315  : {   mode(32t)   t;

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 316  : 
; 317  :     bsw_32(x, 2);

  00006	6a 02		 push	 2
  00008	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _bsw_32@8

; 318  : 
; 319  :     /* at this point the filed element bits 0..127 are set out  */
; 320  :     /* as follows in 32-bit words (where the most significant   */
; 321  :     /* (ms) numeric bits are to the left)                       */
; 322  :     /*                                                          */
; 323  :     /*            x[0]      x[1]      x[2]      x[3]            */
; 324  :     /*          ms    ls  ms    ls  ms    ls  ms     ls         */
; 325  :     /* field:   0 ... 31  32 .. 63  64 .. 95  96 .. 127         */
; 326  : 
; 327  :     t = gf_poly64[x[1] & 1];          /* bit 127 of the element   */

  00011	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00014	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00017	83 e2 01	 and	 edx, 1
  0001a	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _gf_poly64[edx*4]
  00021	89 45 fc	 mov	 DWORD PTR _t$[ebp], eax

; 328  : 										/* shift bits up by one */
; 329  : 										/* position             */
; 330  :     x[1] = (x[1] >> 1) | (x[0] << 31);  /* if bit 7 is 1 xor in */

  00024	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00027	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002a	d1 ea		 shr	 edx, 1
  0002c	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  0002f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00031	c1 e1 1f	 shl	 ecx, 31			; 0000001fH
  00034	0b d1		 or	 edx, ecx
  00036	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00039	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 331  :     x[0] = (x[0] >> 1) ^ t;             /* the field polynomial */

  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0003f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00041	d1 ea		 shr	 edx, 1
  00043	33 55 fc	 xor	 edx, DWORD PTR _t$[ebp]
  00046	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00049	89 10		 mov	 DWORD PTR [eax], edx

; 332  :     bsw_32(x, 2);

  0004b	6a 02		 push	 2
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 _bsw_32@8

; 333  : }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
_mul_x64@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _mul_lex8_64@4
_TEXT	SEGMENT
_t$ = -4						; size = 4
_x$ = 8							; size = 4
_mul_lex8_64@4 PROC					; COMDAT

; 353  : {   mode(32t)   t = (x[1] >> 24);       /* in little endian format  */

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00009	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000c	c1 e9 18	 shr	 ecx, 24			; 00000018H
  0000f	89 4d fc	 mov	 DWORD PTR _t$[ebp], ecx

; 354  :     x[1] = (x[1] << 8) | (x[0] >> 24);

  00012	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  00015	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00018	c1 e0 08	 shl	 eax, 8
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0001e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00020	c1 ea 18	 shr	 edx, 24			; 00000018H
  00023	0b c2		 or	 eax, edx
  00025	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00028	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 355  :     x[0] = (x[0] << 8) ^ gft_le64[t];

  0002b	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  0002e	8b 02		 mov	 eax, DWORD PTR [edx]
  00030	c1 e0 08	 shl	 eax, 8
  00033	8b 4d fc	 mov	 ecx, DWORD PTR _t$[ebp]
  00036	0f b7 14 4d 00
	00 00 00	 movzx	 edx, WORD PTR _gft_le64[ecx*2]
  0003e	33 c2		 xor	 eax, edx
  00040	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00043	89 01		 mov	 DWORD PTR [ecx], eax

; 356  : }

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
_mul_lex8_64@4 ENDP
_TEXT	ENDS
PUBLIC	_RtlSecureZeroMemory@8
PUBLIC	__$ArrayPad$
PUBLIC	_MirrorBits128@4
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Odtp
;	COMDAT _MirrorBits128@4
_TEXT	SEGMENT
_burnm$28331 = -32					; size = 4
_burnc$28333 = -28					; size = 4
_t$ = -24						; size = 16
__$ArrayPad$ = -8					; size = 4
_i$ = -4						; size = 4
_a$ = 8							; size = 4
_MirrorBits128@4 PROC					; COMDAT

; 589  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 20	 sub	 esp, 32			; 00000020H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 590  : 	unsigned __int8 t[128 / 8];
; 591  : 	int i;
; 592  : 	memset (t,0,16);

  00012	33 c0		 xor	 eax, eax
  00014	89 45 e8	 mov	 DWORD PTR _t$[ebp], eax
  00017	89 45 ec	 mov	 DWORD PTR _t$[ebp+4], eax
  0001a	89 45 f0	 mov	 DWORD PTR _t$[ebp+8], eax
  0001d	89 45 f4	 mov	 DWORD PTR _t$[ebp+12], eax

; 593  : 	for (i = 0; i < 128; i++)

  00020	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00027	eb 09		 jmp	 SHORT $LN9@MirrorBits
$LN8@MirrorBits:
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0002c	83 c1 01	 add	 ecx, 1
  0002f	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN9@MirrorBits:
  00032	81 7d fc 80 00
	00 00		 cmp	 DWORD PTR _i$[ebp], 128	; 00000080H
  00039	7d 25		 jge	 SHORT $LN7@MirrorBits

; 594  : 	{
; 595  : 		if (IsBitSet128(i, a))

  0003b	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0003e	52		 push	 edx
  0003f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 _IsBitSet128@8
  00048	85 c0		 test	 eax, eax
  0004a	74 12		 je	 SHORT $LN6@MirrorBits

; 596  : 			SetBit128 (127 - i, t);

  0004c	8d 4d e8	 lea	 ecx, DWORD PTR _t$[ebp]
  0004f	51		 push	 ecx
  00050	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00055	2b 55 fc	 sub	 edx, DWORD PTR _i$[ebp]
  00058	52		 push	 edx
  00059	e8 00 00 00 00	 call	 _SetBit128@8
$LN6@MirrorBits:

; 597  : 	}

  0005e	eb c9		 jmp	 SHORT $LN8@MirrorBits
$LN7@MirrorBits:

; 598  : 	memcpy (a, t, sizeof (t));

  00060	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00063	8b 4d e8	 mov	 ecx, DWORD PTR _t$[ebp]
  00066	89 08		 mov	 DWORD PTR [eax], ecx
  00068	8b 55 ec	 mov	 edx, DWORD PTR _t$[ebp+4]
  0006b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0006e	8b 4d f0	 mov	 ecx, DWORD PTR _t$[ebp+8]
  00071	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00074	8b 55 f4	 mov	 edx, DWORD PTR _t$[ebp+12]
  00077	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$LN5@MirrorBits:

; 599  : 	burn (t,sizeof (t));

  0007a	8d 45 e8	 lea	 eax, DWORD PTR _t$[ebp]
  0007d	89 45 e0	 mov	 DWORD PTR _burnm$28331[ebp], eax
  00080	c7 45 e4 10 00
	00 00		 mov	 DWORD PTR _burnc$28333[ebp], 16 ; 00000010H
  00087	6a 10		 push	 16			; 00000010H
  00089	8d 4d e8	 lea	 ecx, DWORD PTR _t$[ebp]
  0008c	51		 push	 ecx
  0008d	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@MirrorBits:
  00092	8b 55 e4	 mov	 edx, DWORD PTR _burnc$28333[ebp]
  00095	8b 45 e4	 mov	 eax, DWORD PTR _burnc$28333[ebp]
  00098	83 e8 01	 sub	 eax, 1
  0009b	89 45 e4	 mov	 DWORD PTR _burnc$28333[ebp], eax
  0009e	85 d2		 test	 edx, edx
  000a0	74 11		 je	 SHORT $LN4@MirrorBits
  000a2	8b 4d e0	 mov	 ecx, DWORD PTR _burnm$28331[ebp]
  000a5	c6 01 00	 mov	 BYTE PTR [ecx], 0
  000a8	8b 55 e0	 mov	 edx, DWORD PTR _burnm$28331[ebp]
  000ab	83 c2 01	 add	 edx, 1
  000ae	89 55 e0	 mov	 DWORD PTR _burnm$28331[ebp], edx
  000b1	eb df		 jmp	 SHORT $LN2@MirrorBits
$LN4@MirrorBits:
  000b3	33 c0		 xor	 eax, eax
  000b5	75 c3		 jne	 SHORT $LN5@MirrorBits

; 600  : }

  000b7	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ba	33 cd		 xor	 ecx, ebp
  000bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 04 00	 ret	 4
_MirrorBits128@4 ENDP
; Function compile flags: /Odtp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT _RtlSecureZeroMemory@8
_TEXT	SEGMENT
_vptr$ = -4						; size = 4
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory@8 PROC				; COMDAT

; 8322 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 8323 :     volatile char *vptr = (volatile char *)ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _vptr$[ebp], eax
$LN2@RtlSecureZ:

; 8324 : 
; 8325 : #if defined(_M_AMD64)
; 8326 : 
; 8327 :         __stosb((PUCHAR)((ULONG64)vptr), 0, cnt);
; 8328 : 
; 8329 : #else
; 8330 : 
; 8331 :     while (cnt) {

  0000c	83 7d 0c 00	 cmp	 DWORD PTR _cnt$[ebp], 0
  00010	74 1a		 je	 SHORT $LN1@RtlSecureZ

; 8332 :         *vptr = 0;

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _vptr$[ebp]
  00015	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 8333 :         vptr++;

  00018	8b 55 fc	 mov	 edx, DWORD PTR _vptr$[ebp]
  0001b	83 c2 01	 add	 edx, 1
  0001e	89 55 fc	 mov	 DWORD PTR _vptr$[ebp], edx

; 8334 :         cnt--;

  00021	8b 45 0c	 mov	 eax, DWORD PTR _cnt$[ebp]
  00024	83 e8 01	 sub	 eax, 1
  00027	89 45 0c	 mov	 DWORD PTR _cnt$[ebp], eax

; 8335 :     }

  0002a	eb e0		 jmp	 SHORT $LN2@RtlSecureZ
$LN1@RtlSecureZ:

; 8336 : 
; 8337 : #endif
; 8338 : 
; 8339 :     return ptr;

  0002c	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]

; 8340 : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
_RtlSecureZeroMemory@8 ENDP
; Function compile flags: /Odtp
; File c:\home\public\desktop\projects\ciphershed\src\common\gfmul.c
_TEXT	ENDS
;	COMDAT _IsBitSet128@8
_TEXT	SEGMENT
_bit$ = 8						; size = 4
_a$ = 12						; size = 4
_IsBitSet128@8 PROC					; COMDAT

; 569  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 570  : 	return a[(127 - bit) / 8] & (0x80 >> ((127 - bit) % 8));

  00006	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH
  0000b	2b 45 08	 sub	 eax, DWORD PTR _bit$[ebp]
  0000e	c1 e8 03	 shr	 eax, 3
  00011	8b 4d 0c	 mov	 ecx, DWORD PTR _a$[ebp]
  00014	0f b6 34 01	 movzx	 esi, BYTE PTR [ecx+eax]
  00018	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH
  0001d	2b 45 08	 sub	 eax, DWORD PTR _bit$[ebp]
  00020	33 d2		 xor	 edx, edx
  00022	b9 08 00 00 00	 mov	 ecx, 8
  00027	f7 f1		 div	 ecx
  00029	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  0002e	8b ca		 mov	 ecx, edx
  00030	d3 f8		 sar	 eax, cl
  00032	23 c6		 and	 eax, esi

; 571  : }

  00034	5e		 pop	 esi
  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
_IsBitSet128@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _SetBit128@8
_TEXT	SEGMENT
_bit$ = 8						; size = 4
_a$ = 12						; size = 4
_SetBit128@8 PROC					; COMDAT

; 579  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 580  : 	a[(127 - bit) / 8] |= 0x80 >> ((127 - bit) % 8);

  00006	be 7f 00 00 00	 mov	 esi, 127		; 0000007fH
  0000b	2b 75 08	 sub	 esi, DWORD PTR _bit$[ebp]
  0000e	c1 ee 03	 shr	 esi, 3
  00011	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH
  00016	2b 45 08	 sub	 eax, DWORD PTR _bit$[ebp]
  00019	33 d2		 xor	 edx, edx
  0001b	b9 08 00 00 00	 mov	 ecx, 8
  00020	f7 f1		 div	 ecx
  00022	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  00027	8b ca		 mov	 ecx, edx
  00029	d3 f8		 sar	 eax, cl
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _a$[ebp]
  0002e	0f b6 14 31	 movzx	 edx, BYTE PTR [ecx+esi]
  00032	0b d0		 or	 edx, eax
  00034	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH
  00039	2b 45 08	 sub	 eax, DWORD PTR _bit$[ebp]
  0003c	c1 e8 03	 shr	 eax, 3
  0003f	8b 4d 0c	 mov	 ecx, DWORD PTR _a$[ebp]
  00042	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 581  : }

  00045	5e		 pop	 esi
  00046	5d		 pop	 ebp
  00047	c2 08 00	 ret	 8
_SetBit128@8 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_MirrorBits64@4
; Function compile flags: /Odtp
;	COMDAT _MirrorBits64@4
_TEXT	SEGMENT
_burnm$28349 = -24					; size = 4
_burnc$28351 = -20					; size = 4
_t$ = -16						; size = 8
__$ArrayPad$ = -8					; size = 4
_i$ = -4						; size = 4
_a$ = 8							; size = 4
_MirrorBits64@4 PROC					; COMDAT

; 603  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 18	 sub	 esp, 24			; 00000018H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 604  : 	unsigned __int8 t[64 / 8];
; 605  : 	int i;
; 606  : 	memset (t,0,8);

  00012	33 c0		 xor	 eax, eax
  00014	89 45 f0	 mov	 DWORD PTR _t$[ebp], eax
  00017	89 45 f4	 mov	 DWORD PTR _t$[ebp+4], eax

; 607  : 	for (i = 0; i < 64; i++)

  0001a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00021	eb 09		 jmp	 SHORT $LN9@MirrorBits@2
$LN8@MirrorBits@2:
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00026	83 c1 01	 add	 ecx, 1
  00029	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN9@MirrorBits@2:
  0002c	83 7d fc 40	 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  00030	7d 25		 jge	 SHORT $LN7@MirrorBits@2

; 608  : 	{
; 609  : 		if (IsBitSet64(i, a))

  00032	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00035	52		 push	 edx
  00036	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _IsBitSet64@8
  0003f	85 c0		 test	 eax, eax
  00041	74 12		 je	 SHORT $LN6@MirrorBits@2

; 610  : 			SetBit64 (63 - i, t);

  00043	8d 4d f0	 lea	 ecx, DWORD PTR _t$[ebp]
  00046	51		 push	 ecx
  00047	ba 3f 00 00 00	 mov	 edx, 63			; 0000003fH
  0004c	2b 55 fc	 sub	 edx, DWORD PTR _i$[ebp]
  0004f	52		 push	 edx
  00050	e8 00 00 00 00	 call	 _SetBit64@8
$LN6@MirrorBits@2:

; 611  : 	}

  00055	eb cc		 jmp	 SHORT $LN8@MirrorBits@2
$LN7@MirrorBits@2:

; 612  : 	memcpy (a, t, sizeof (t));

  00057	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0005a	8b 4d f0	 mov	 ecx, DWORD PTR _t$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
  0005f	8b 55 f4	 mov	 edx, DWORD PTR _t$[ebp+4]
  00062	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN5@MirrorBits@2:

; 613  : 	burn (t,sizeof (t));

  00065	8d 45 f0	 lea	 eax, DWORD PTR _t$[ebp]
  00068	89 45 e8	 mov	 DWORD PTR _burnm$28349[ebp], eax
  0006b	c7 45 ec 08 00
	00 00		 mov	 DWORD PTR _burnc$28351[ebp], 8
  00072	6a 08		 push	 8
  00074	8d 4d f0	 lea	 ecx, DWORD PTR _t$[ebp]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@MirrorBits@2:
  0007d	8b 55 ec	 mov	 edx, DWORD PTR _burnc$28351[ebp]
  00080	8b 45 ec	 mov	 eax, DWORD PTR _burnc$28351[ebp]
  00083	83 e8 01	 sub	 eax, 1
  00086	89 45 ec	 mov	 DWORD PTR _burnc$28351[ebp], eax
  00089	85 d2		 test	 edx, edx
  0008b	74 11		 je	 SHORT $LN4@MirrorBits@2
  0008d	8b 4d e8	 mov	 ecx, DWORD PTR _burnm$28349[ebp]
  00090	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00093	8b 55 e8	 mov	 edx, DWORD PTR _burnm$28349[ebp]
  00096	83 c2 01	 add	 edx, 1
  00099	89 55 e8	 mov	 DWORD PTR _burnm$28349[ebp], edx
  0009c	eb df		 jmp	 SHORT $LN2@MirrorBits@2
$LN4@MirrorBits@2:
  0009e	33 c0		 xor	 eax, eax
  000a0	75 c3		 jne	 SHORT $LN5@MirrorBits@2

; 614  : }

  000a2	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a5	33 cd		 xor	 ecx, ebp
  000a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 04 00	 ret	 4
_MirrorBits64@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _IsBitSet64@8
_TEXT	SEGMENT
_bit$ = 8						; size = 4
_a$ = 12						; size = 4
_IsBitSet64@8 PROC					; COMDAT

; 574  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 575  : 	return a[(63 - bit) / 8] & (0x80 >> ((63 - bit) % 8));

  00006	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  0000b	2b 45 08	 sub	 eax, DWORD PTR _bit$[ebp]
  0000e	c1 e8 03	 shr	 eax, 3
  00011	8b 4d 0c	 mov	 ecx, DWORD PTR _a$[ebp]
  00014	0f b6 34 01	 movzx	 esi, BYTE PTR [ecx+eax]
  00018	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  0001d	2b 45 08	 sub	 eax, DWORD PTR _bit$[ebp]
  00020	33 d2		 xor	 edx, edx
  00022	b9 08 00 00 00	 mov	 ecx, 8
  00027	f7 f1		 div	 ecx
  00029	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  0002e	8b ca		 mov	 ecx, edx
  00030	d3 f8		 sar	 eax, cl
  00032	23 c6		 and	 eax, esi

; 576  : }

  00034	5e		 pop	 esi
  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
_IsBitSet64@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _SetBit64@8
_TEXT	SEGMENT
_bit$ = 8						; size = 4
_a$ = 12						; size = 4
_SetBit64@8 PROC					; COMDAT

; 584  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 585  : 	a[(63 - bit) / 8] |= 0x80 >> ((63 - bit) % 8);

  00006	be 3f 00 00 00	 mov	 esi, 63			; 0000003fH
  0000b	2b 75 08	 sub	 esi, DWORD PTR _bit$[ebp]
  0000e	c1 ee 03	 shr	 esi, 3
  00011	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  00016	2b 45 08	 sub	 eax, DWORD PTR _bit$[ebp]
  00019	33 d2		 xor	 edx, edx
  0001b	b9 08 00 00 00	 mov	 ecx, 8
  00020	f7 f1		 div	 ecx
  00022	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  00027	8b ca		 mov	 ecx, edx
  00029	d3 f8		 sar	 eax, cl
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _a$[ebp]
  0002e	0f b6 14 31	 movzx	 edx, BYTE PTR [ecx+esi]
  00032	0b d0		 or	 edx, eax
  00034	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  00039	2b 45 08	 sub	 eax, DWORD PTR _bit$[ebp]
  0003c	c1 e8 03	 shr	 eax, 3
  0003f	8b 4d 0c	 mov	 ecx, DWORD PTR _a$[ebp]
  00042	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 586  : }

  00045	5e		 pop	 esi
  00046	5d		 pop	 ebp
  00047	c2 08 00	 ret	 8
_SetBit64@8 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_Gf128Tab64Init@8
EXTRN	__imp__ExFreePoolWithTag@8:PROC
EXTRN	__imp__ExAllocatePoolWithTag@12:PROC
; Function compile flags: /Odtp
;	COMDAT _Gf128Tab64Init@8
_TEXT	SEGMENT
_burnm$28389 = -52					; size = 4
_burnc$28391 = -48					; size = 4
_burnm$28380 = -44					; size = 4
_burnc$28382 = -40					; size = 4
_jm$28374 = -36						; size = 4
_j$ = -32						; size = 4
_am$ = -28						; size = 16
__$ArrayPad$ = -12					; size = 4
_ctx8k$ = -8						; size = 4
_i$ = -4						; size = 4
_a$ = 8							; size = 4
_ctx$ = 12						; size = 4
_Gf128Tab64Init@8 PROC					; COMDAT

; 619  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 34	 sub	 esp, 52			; 00000034H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 f4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 620  : 	GfCtx8k *ctx8k;
; 621  : 	unsigned __int8 am[16];
; 622  : 	int i, j;
; 623  : 
; 624  : 	ctx8k = (GfCtx8k *) TCalloc (sizeof (GfCtx8k));

  00012	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00017	68 00 20 00 00	 push	 8192			; 00002000H
  0001c	6a 00		 push	 0
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00024	89 45 f8	 mov	 DWORD PTR _ctx8k$[ebp], eax

; 625  : 	if (!ctx8k)

  00027	83 7d f8 00	 cmp	 DWORD PTR _ctx8k$[ebp], 0
  0002b	75 07		 jne	 SHORT $LN17@Gf128Tab64

; 626  : 		return FALSE;

  0002d	33 c0		 xor	 eax, eax
  0002f	e9 9e 01 00 00	 jmp	 $LN18@Gf128Tab64
$LN17@Gf128Tab64:

; 627  : 
; 628  : 	memcpy (am, a, 16);

  00034	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00037	8b 08		 mov	 ecx, DWORD PTR [eax]
  00039	89 4d e4	 mov	 DWORD PTR _am$[ebp], ecx
  0003c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0003f	89 55 e8	 mov	 DWORD PTR _am$[ebp+4], edx
  00042	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00045	89 4d ec	 mov	 DWORD PTR _am$[ebp+8], ecx
  00048	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0004b	89 55 f0	 mov	 DWORD PTR _am$[ebp+12], edx

; 629  : 	MirrorBits128 (am);

  0004e	8d 45 e4	 lea	 eax, DWORD PTR _am$[ebp]
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 _MirrorBits128@4

; 630  :     compile_8k_table (am, ctx8k);

  00057	8b 4d f8	 mov	 ecx, DWORD PTR _ctx8k$[ebp]
  0005a	51		 push	 ecx
  0005b	8d 55 e4	 lea	 edx, DWORD PTR _am$[ebp]
  0005e	52		 push	 edx
  0005f	e8 00 00 00 00	 call	 _compile_8k_table@8

; 631  : 
; 632  : 	/* Convert 8k LSB-first table to 4k MSB-first */
; 633  : 	for (i = 16; i < 32; i++) 

  00064	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR _i$[ebp], 16	; 00000010H
  0006b	eb 09		 jmp	 SHORT $LN16@Gf128Tab64
$LN15@Gf128Tab64:
  0006d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00070	83 c0 01	 add	 eax, 1
  00073	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN16@Gf128Tab64:
  00076	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  0007a	0f 8d c1 00 00
	00		 jge	 $LN10@Gf128Tab64

; 634  : 	{
; 635  : 		for (j = 0; j < 16; j++) 

  00080	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00087	eb 09		 jmp	 SHORT $LN13@Gf128Tab64
$LN12@Gf128Tab64:
  00089	8b 4d e0	 mov	 ecx, DWORD PTR _j$[ebp]
  0008c	83 c1 01	 add	 ecx, 1
  0008f	89 4d e0	 mov	 DWORD PTR _j$[ebp], ecx
$LN13@Gf128Tab64:
  00092	83 7d e0 10	 cmp	 DWORD PTR _j$[ebp], 16	; 00000010H
  00096	0f 8d a0 00 00
	00		 jge	 $LN11@Gf128Tab64

; 636  : 		{
; 637  : 			int jm = 0;

  0009c	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _jm$28374[ebp], 0

; 638  : 			jm |= (j & 0x1) << 3;

  000a3	8b 55 e0	 mov	 edx, DWORD PTR _j$[ebp]
  000a6	83 e2 01	 and	 edx, 1
  000a9	c1 e2 03	 shl	 edx, 3
  000ac	0b 55 dc	 or	 edx, DWORD PTR _jm$28374[ebp]
  000af	89 55 dc	 mov	 DWORD PTR _jm$28374[ebp], edx

; 639  : 			jm |= (j & 0x2) << 1;

  000b2	8b 45 e0	 mov	 eax, DWORD PTR _j$[ebp]
  000b5	83 e0 02	 and	 eax, 2
  000b8	d1 e0		 shl	 eax, 1
  000ba	0b 45 dc	 or	 eax, DWORD PTR _jm$28374[ebp]
  000bd	89 45 dc	 mov	 DWORD PTR _jm$28374[ebp], eax

; 640  : 			jm |= (j & 0x4) >> 1;

  000c0	8b 4d e0	 mov	 ecx, DWORD PTR _j$[ebp]
  000c3	83 e1 04	 and	 ecx, 4
  000c6	d1 f9		 sar	 ecx, 1
  000c8	0b 4d dc	 or	 ecx, DWORD PTR _jm$28374[ebp]
  000cb	89 4d dc	 mov	 DWORD PTR _jm$28374[ebp], ecx

; 641  : 			jm |= (j & 0x8) >> 3;

  000ce	8b 55 e0	 mov	 edx, DWORD PTR _j$[ebp]
  000d1	83 e2 08	 and	 edx, 8
  000d4	c1 fa 03	 sar	 edx, 3
  000d7	0b 55 dc	 or	 edx, DWORD PTR _jm$28374[ebp]
  000da	89 55 dc	 mov	 DWORD PTR _jm$28374[ebp], edx

; 642  : 
; 643  : 			memcpy (&ctx->gf_t128[i-16][jm], (unsigned char *)&ctx8k->gf_t8k[31-i][j], 16);

  000dd	b8 1f 00 00 00	 mov	 eax, 31			; 0000001fH
  000e2	2b 45 fc	 sub	 eax, DWORD PTR _i$[ebp]
  000e5	c1 e0 08	 shl	 eax, 8
  000e8	03 45 f8	 add	 eax, DWORD PTR _ctx8k$[ebp]
  000eb	8b 4d e0	 mov	 ecx, DWORD PTR _j$[ebp]
  000ee	c1 e1 04	 shl	 ecx, 4
  000f1	03 c1		 add	 eax, ecx
  000f3	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000f6	83 ea 10	 sub	 edx, 16			; 00000010H
  000f9	c1 e2 08	 shl	 edx, 8
  000fc	03 55 0c	 add	 edx, DWORD PTR _ctx$[ebp]
  000ff	8b 4d dc	 mov	 ecx, DWORD PTR _jm$28374[ebp]
  00102	c1 e1 04	 shl	 ecx, 4
  00105	03 d1		 add	 edx, ecx
  00107	8b 08		 mov	 ecx, DWORD PTR [eax]
  00109	89 0a		 mov	 DWORD PTR [edx], ecx
  0010b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0010e	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00111	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00114	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00117	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0011a	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 644  : 			MirrorBits128 ((unsigned char *)&ctx->gf_t128[i-16][jm]);

  0011d	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00120	83 e9 10	 sub	 ecx, 16			; 00000010H
  00123	c1 e1 08	 shl	 ecx, 8
  00126	03 4d 0c	 add	 ecx, DWORD PTR _ctx$[ebp]
  00129	8b 55 dc	 mov	 edx, DWORD PTR _jm$28374[ebp]
  0012c	c1 e2 04	 shl	 edx, 4
  0012f	03 ca		 add	 ecx, edx
  00131	51		 push	 ecx
  00132	e8 00 00 00 00	 call	 _MirrorBits128@4

; 645  : 		}

  00137	e9 4d ff ff ff	 jmp	 $LN12@Gf128Tab64
$LN11@Gf128Tab64:

; 646  : 	}

  0013c	e9 2c ff ff ff	 jmp	 $LN15@Gf128Tab64
$LN10@Gf128Tab64:

; 647  : 
; 648  : 	burn (ctx8k ,sizeof (*ctx8k));

  00141	8b 45 f8	 mov	 eax, DWORD PTR _ctx8k$[ebp]
  00144	89 45 d4	 mov	 DWORD PTR _burnm$28380[ebp], eax
  00147	c7 45 d8 00 20
	00 00		 mov	 DWORD PTR _burnc$28382[ebp], 8192 ; 00002000H
  0014e	68 00 20 00 00	 push	 8192			; 00002000H
  00153	8b 4d f8	 mov	 ecx, DWORD PTR _ctx8k$[ebp]
  00156	51		 push	 ecx
  00157	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN7@Gf128Tab64:
  0015c	8b 55 d8	 mov	 edx, DWORD PTR _burnc$28382[ebp]
  0015f	8b 45 d8	 mov	 eax, DWORD PTR _burnc$28382[ebp]
  00162	83 e8 01	 sub	 eax, 1
  00165	89 45 d8	 mov	 DWORD PTR _burnc$28382[ebp], eax
  00168	85 d2		 test	 edx, edx
  0016a	74 11		 je	 SHORT $LN9@Gf128Tab64
  0016c	8b 4d d4	 mov	 ecx, DWORD PTR _burnm$28380[ebp]
  0016f	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00172	8b 55 d4	 mov	 edx, DWORD PTR _burnm$28380[ebp]
  00175	83 c2 01	 add	 edx, 1
  00178	89 55 d4	 mov	 DWORD PTR _burnm$28380[ebp], edx
  0017b	eb df		 jmp	 SHORT $LN7@Gf128Tab64
$LN9@Gf128Tab64:
  0017d	33 c0		 xor	 eax, eax
  0017f	75 c0		 jne	 SHORT $LN10@Gf128Tab64
$LN5@Gf128Tab64:

; 649  : 	burn (am, sizeof (am));

  00181	8d 4d e4	 lea	 ecx, DWORD PTR _am$[ebp]
  00184	89 4d cc	 mov	 DWORD PTR _burnm$28389[ebp], ecx
  00187	c7 45 d0 10 00
	00 00		 mov	 DWORD PTR _burnc$28391[ebp], 16 ; 00000010H
  0018e	6a 10		 push	 16			; 00000010H
  00190	8d 55 e4	 lea	 edx, DWORD PTR _am$[ebp]
  00193	52		 push	 edx
  00194	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@Gf128Tab64:
  00199	8b 45 d0	 mov	 eax, DWORD PTR _burnc$28391[ebp]
  0019c	8b 4d d0	 mov	 ecx, DWORD PTR _burnc$28391[ebp]
  0019f	83 e9 01	 sub	 ecx, 1
  001a2	89 4d d0	 mov	 DWORD PTR _burnc$28391[ebp], ecx
  001a5	85 c0		 test	 eax, eax
  001a7	74 11		 je	 SHORT $LN4@Gf128Tab64
  001a9	8b 55 cc	 mov	 edx, DWORD PTR _burnm$28389[ebp]
  001ac	c6 02 00	 mov	 BYTE PTR [edx], 0
  001af	8b 45 cc	 mov	 eax, DWORD PTR _burnm$28389[ebp]
  001b2	83 c0 01	 add	 eax, 1
  001b5	89 45 cc	 mov	 DWORD PTR _burnm$28389[ebp], eax
  001b8	eb df		 jmp	 SHORT $LN2@Gf128Tab64
$LN4@Gf128Tab64:
  001ba	33 c9		 xor	 ecx, ecx
  001bc	75 c3		 jne	 SHORT $LN5@Gf128Tab64

; 650  : 	TCfree (ctx8k);

  001be	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  001c3	8b 55 f8	 mov	 edx, DWORD PTR _ctx8k$[ebp]
  001c6	52		 push	 edx
  001c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 651  : 	return TRUE;

  001cd	b8 01 00 00 00	 mov	 eax, 1
$LN18@Gf128Tab64:

; 652  : }

  001d2	8b 4d f4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d5	33 cd		 xor	 ecx, ebp
  001d7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001dc	8b e5		 mov	 esp, ebp
  001de	5d		 pop	 ebp
  001df	c2 08 00	 ret	 8
_Gf128Tab64Init@8 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_Gf64TabInit@8
; Function compile flags: /Odtp
;	COMDAT _Gf64TabInit@8
_TEXT	SEGMENT
_burnm$28429 = -44					; size = 4
_burnc$28431 = -40					; size = 4
_burnm$28420 = -36					; size = 4
_burnc$28422 = -32					; size = 4
_jm$28414 = -28						; size = 4
_j$ = -24						; size = 4
_ctx4k$ = -20						; size = 4
_am$ = -16						; size = 8
__$ArrayPad$ = -8					; size = 4
_i$ = -4						; size = 4
_a$ = 8							; size = 4
_ctx$ = 12						; size = 4
_Gf64TabInit@8 PROC					; COMDAT

; 655  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00012	56		 push	 esi
  00013	57		 push	 edi

; 656  : 	/* Deprecated/legacy */
; 657  : 
; 658  : 	GfCtx4k64 *ctx4k;
; 659  : 	unsigned __int8 am[8];
; 660  : 	int i, j;
; 661  : 
; 662  : 	ctx4k = (GfCtx4k64 *) TCalloc (sizeof (GfCtx4k64));

  00014	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00019	68 00 10 00 00	 push	 4096			; 00001000H
  0001e	6a 00		 push	 0
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00026	89 45 ec	 mov	 DWORD PTR _ctx4k$[ebp], eax

; 663  : 	if (!ctx4k)

  00029	83 7d ec 00	 cmp	 DWORD PTR _ctx4k$[ebp], 0
  0002d	75 07		 jne	 SHORT $LN17@Gf64TabIni

; 664  : 		return FALSE;

  0002f	33 c0		 xor	 eax, eax
  00031	e9 89 01 00 00	 jmp	 $LN18@Gf64TabIni
$LN17@Gf64TabIni:

; 665  : 
; 666  : 	memcpy (am, a, 8);

  00036	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	89 4d f0	 mov	 DWORD PTR _am$[ebp], ecx
  0003e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00041	89 55 f4	 mov	 DWORD PTR _am$[ebp+4], edx

; 667  : 	MirrorBits64 (am);

  00044	8d 45 f0	 lea	 eax, DWORD PTR _am$[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _MirrorBits64@4

; 668  :     compile_4k_table64 (am, ctx4k);

  0004d	8b 4d ec	 mov	 ecx, DWORD PTR _ctx4k$[ebp]
  00050	51		 push	 ecx
  00051	8d 55 f0	 lea	 edx, DWORD PTR _am$[ebp]
  00054	52		 push	 edx
  00055	e8 00 00 00 00	 call	 _compile_4k_table64@8

; 669  : 
; 670  : 	/* Convert LSB-first table to MSB-first */
; 671  : 	for (i = 0; i < 16; i++) 

  0005a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00061	eb 09		 jmp	 SHORT $LN16@Gf64TabIni
$LN15@Gf64TabIni:
  00063	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00066	83 c0 01	 add	 eax, 1
  00069	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN16@Gf64TabIni:
  0006c	83 7d fc 10	 cmp	 DWORD PTR _i$[ebp], 16	; 00000010H
  00070	0f 8d b8 00 00
	00		 jge	 $LN10@Gf64TabIni

; 672  : 	{
; 673  : 		for (j = 0; j < 16; j++) 

  00076	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  0007d	eb 09		 jmp	 SHORT $LN13@Gf64TabIni
$LN12@Gf64TabIni:
  0007f	8b 4d e8	 mov	 ecx, DWORD PTR _j$[ebp]
  00082	83 c1 01	 add	 ecx, 1
  00085	89 4d e8	 mov	 DWORD PTR _j$[ebp], ecx
$LN13@Gf64TabIni:
  00088	83 7d e8 10	 cmp	 DWORD PTR _j$[ebp], 16	; 00000010H
  0008c	0f 8d 97 00 00
	00		 jge	 $LN11@Gf64TabIni

; 674  : 		{
; 675  : 			int jm = 0;

  00092	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _jm$28414[ebp], 0

; 676  : 			jm |= (j & 0x1) << 3;

  00099	8b 55 e8	 mov	 edx, DWORD PTR _j$[ebp]
  0009c	83 e2 01	 and	 edx, 1
  0009f	c1 e2 03	 shl	 edx, 3
  000a2	0b 55 e4	 or	 edx, DWORD PTR _jm$28414[ebp]
  000a5	89 55 e4	 mov	 DWORD PTR _jm$28414[ebp], edx

; 677  : 			jm |= (j & 0x2) << 1;

  000a8	8b 45 e8	 mov	 eax, DWORD PTR _j$[ebp]
  000ab	83 e0 02	 and	 eax, 2
  000ae	d1 e0		 shl	 eax, 1
  000b0	0b 45 e4	 or	 eax, DWORD PTR _jm$28414[ebp]
  000b3	89 45 e4	 mov	 DWORD PTR _jm$28414[ebp], eax

; 678  : 			jm |= (j & 0x4) >> 1;

  000b6	8b 4d e8	 mov	 ecx, DWORD PTR _j$[ebp]
  000b9	83 e1 04	 and	 ecx, 4
  000bc	d1 f9		 sar	 ecx, 1
  000be	0b 4d e4	 or	 ecx, DWORD PTR _jm$28414[ebp]
  000c1	89 4d e4	 mov	 DWORD PTR _jm$28414[ebp], ecx

; 679  : 			jm |= (j & 0x8) >> 3;

  000c4	8b 55 e8	 mov	 edx, DWORD PTR _j$[ebp]
  000c7	83 e2 08	 and	 edx, 8
  000ca	c1 fa 03	 sar	 edx, 3
  000cd	0b 55 e4	 or	 edx, DWORD PTR _jm$28414[ebp]
  000d0	89 55 e4	 mov	 DWORD PTR _jm$28414[ebp], edx

; 680  : 
; 681  : 			memcpy (&ctx->gf_t64[i][jm], (unsigned char *)&ctx4k->gf_t4k[15-i][j], 8);

  000d3	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH
  000d8	2b 45 fc	 sub	 eax, DWORD PTR _i$[ebp]
  000db	c1 e0 08	 shl	 eax, 8
  000de	03 45 ec	 add	 eax, DWORD PTR _ctx4k$[ebp]
  000e1	8b 4d e8	 mov	 ecx, DWORD PTR _j$[ebp]
  000e4	c1 e1 04	 shl	 ecx, 4
  000e7	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000ea	c1 e2 07	 shl	 edx, 7
  000ed	8b 75 0c	 mov	 esi, DWORD PTR _ctx$[ebp]
  000f0	8d 94 16 00 10
	00 00		 lea	 edx, DWORD PTR [esi+edx+4096]
  000f7	8b 75 e4	 mov	 esi, DWORD PTR _jm$28414[ebp]
  000fa	8b 3c 08	 mov	 edi, DWORD PTR [eax+ecx]
  000fd	89 3c f2	 mov	 DWORD PTR [edx+esi*8], edi
  00100	8b 44 08 04	 mov	 eax, DWORD PTR [eax+ecx+4]
  00104	89 44 f2 04	 mov	 DWORD PTR [edx+esi*8+4], eax

; 682  : 			MirrorBits64 ((unsigned char *)&ctx->gf_t64[i][jm]);

  00108	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0010b	c1 e1 07	 shl	 ecx, 7
  0010e	8b 55 0c	 mov	 edx, DWORD PTR _ctx$[ebp]
  00111	8d 84 0a 00 10
	00 00		 lea	 eax, DWORD PTR [edx+ecx+4096]
  00118	8b 4d e4	 mov	 ecx, DWORD PTR _jm$28414[ebp]
  0011b	8d 14 c8	 lea	 edx, DWORD PTR [eax+ecx*8]
  0011e	52		 push	 edx
  0011f	e8 00 00 00 00	 call	 _MirrorBits64@4

; 683  : 		}

  00124	e9 56 ff ff ff	 jmp	 $LN12@Gf64TabIni
$LN11@Gf64TabIni:

; 684  : 	}

  00129	e9 35 ff ff ff	 jmp	 $LN15@Gf64TabIni
$LN10@Gf64TabIni:

; 685  : 
; 686  : 	burn (ctx4k,sizeof (*ctx4k));

  0012e	8b 45 ec	 mov	 eax, DWORD PTR _ctx4k$[ebp]
  00131	89 45 dc	 mov	 DWORD PTR _burnm$28420[ebp], eax
  00134	c7 45 e0 00 10
	00 00		 mov	 DWORD PTR _burnc$28422[ebp], 4096 ; 00001000H
  0013b	68 00 10 00 00	 push	 4096			; 00001000H
  00140	8b 4d ec	 mov	 ecx, DWORD PTR _ctx4k$[ebp]
  00143	51		 push	 ecx
  00144	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN7@Gf64TabIni:
  00149	8b 55 e0	 mov	 edx, DWORD PTR _burnc$28422[ebp]
  0014c	8b 45 e0	 mov	 eax, DWORD PTR _burnc$28422[ebp]
  0014f	83 e8 01	 sub	 eax, 1
  00152	89 45 e0	 mov	 DWORD PTR _burnc$28422[ebp], eax
  00155	85 d2		 test	 edx, edx
  00157	74 11		 je	 SHORT $LN9@Gf64TabIni
  00159	8b 4d dc	 mov	 ecx, DWORD PTR _burnm$28420[ebp]
  0015c	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0015f	8b 55 dc	 mov	 edx, DWORD PTR _burnm$28420[ebp]
  00162	83 c2 01	 add	 edx, 1
  00165	89 55 dc	 mov	 DWORD PTR _burnm$28420[ebp], edx
  00168	eb df		 jmp	 SHORT $LN7@Gf64TabIni
$LN9@Gf64TabIni:
  0016a	33 c0		 xor	 eax, eax
  0016c	75 c0		 jne	 SHORT $LN10@Gf64TabIni
$LN5@Gf64TabIni:

; 687  : 	burn (am, sizeof (am));

  0016e	8d 4d f0	 lea	 ecx, DWORD PTR _am$[ebp]
  00171	89 4d d4	 mov	 DWORD PTR _burnm$28429[ebp], ecx
  00174	c7 45 d8 08 00
	00 00		 mov	 DWORD PTR _burnc$28431[ebp], 8
  0017b	6a 08		 push	 8
  0017d	8d 55 f0	 lea	 edx, DWORD PTR _am$[ebp]
  00180	52		 push	 edx
  00181	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@Gf64TabIni:
  00186	8b 45 d8	 mov	 eax, DWORD PTR _burnc$28431[ebp]
  00189	8b 4d d8	 mov	 ecx, DWORD PTR _burnc$28431[ebp]
  0018c	83 e9 01	 sub	 ecx, 1
  0018f	89 4d d8	 mov	 DWORD PTR _burnc$28431[ebp], ecx
  00192	85 c0		 test	 eax, eax
  00194	74 11		 je	 SHORT $LN4@Gf64TabIni
  00196	8b 55 d4	 mov	 edx, DWORD PTR _burnm$28429[ebp]
  00199	c6 02 00	 mov	 BYTE PTR [edx], 0
  0019c	8b 45 d4	 mov	 eax, DWORD PTR _burnm$28429[ebp]
  0019f	83 c0 01	 add	 eax, 1
  001a2	89 45 d4	 mov	 DWORD PTR _burnm$28429[ebp], eax
  001a5	eb df		 jmp	 SHORT $LN2@Gf64TabIni
$LN4@Gf64TabIni:
  001a7	33 c9		 xor	 ecx, ecx
  001a9	75 c3		 jne	 SHORT $LN5@Gf64TabIni

; 688  : 	TCfree (ctx4k);

  001ab	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  001b0	8b 55 ec	 mov	 edx, DWORD PTR _ctx4k$[ebp]
  001b3	52		 push	 edx
  001b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 689  : 	return TRUE;

  001ba	b8 01 00 00 00	 mov	 eax, 1
$LN18@Gf64TabIni:

; 690  : }

  001bf	5f		 pop	 edi
  001c0	5e		 pop	 esi
  001c1	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c4	33 cd		 xor	 ecx, ebp
  001c6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001cb	8b e5		 mov	 esp, ebp
  001cd	5d		 pop	 ebp
  001ce	c2 08 00	 ret	 8
_Gf64TabInit@8 ENDP
_TEXT	ENDS
PUBLIC	_Gf128MulBy64Tab@12
; Function compile flags: /Odtp
;	COMDAT _Gf128MulBy64Tab@12
_TEXT	SEGMENT
_r$ = -16						; size = 16
_a$ = 8							; size = 4
_p$ = 12						; size = 4
_ctx$ = 16						; size = 4
_Gf128MulBy64Tab@12 PROC				; COMDAT

; 698  : {  

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 10	 sub	 esp, 16			; 00000010H

; 699  : 	unsigned __int32 r[CBLK_LEN >> 2];
; 700  : 
; 701  : 	move_block_aligned(r, ctx->gf_t128[7*2][a[7] & 15]);

  00008	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0000b	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  0000f	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00012	c1 e1 04	 shl	 ecx, 4
  00015	8b 55 10	 mov	 edx, DWORD PTR _ctx$[ebp]
  00018	8d 84 0a 00 0e
	00 00		 lea	 eax, DWORD PTR [edx+ecx+3584]
  0001f	50		 push	 eax
  00020	8d 4d f0	 lea	 ecx, DWORD PTR _r$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 _move_block_aligned@8

; 702  :     xor_block_aligned(r,  ctx->gf_t128[7*2+1][a[7] >> 4]);

  00029	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0002c	0f b6 42 07	 movzx	 eax, BYTE PTR [edx+7]
  00030	c1 f8 04	 sar	 eax, 4
  00033	c1 e0 04	 shl	 eax, 4
  00036	8b 4d 10	 mov	 ecx, DWORD PTR _ctx$[ebp]
  00039	8d 94 01 00 0f
	00 00		 lea	 edx, DWORD PTR [ecx+eax+3840]
  00040	52		 push	 edx
  00041	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _xor_block_aligned@8

; 703  : 
; 704  : 	if (*(unsigned __int16 *)a)

  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0004d	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00050	85 d2		 test	 edx, edx
  00052	74 7b		 je	 SHORT $LN2@Gf128MulBy

; 705  : 	{
; 706  : 		xor_8kt64(0);

  00054	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00057	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0005a	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0005d	c1 e1 04	 shl	 ecx, 4
  00060	03 4d 10	 add	 ecx, DWORD PTR _ctx$[ebp]
  00063	51		 push	 ecx
  00064	8d 55 f0	 lea	 edx, DWORD PTR _r$[ebp]
  00067	52		 push	 edx
  00068	e8 00 00 00 00	 call	 _xor_block_aligned@8
  0006d	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00070	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00073	c1 f9 04	 sar	 ecx, 4
  00076	c1 e1 04	 shl	 ecx, 4
  00079	8b 55 10	 mov	 edx, DWORD PTR _ctx$[ebp]
  0007c	8d 84 0a 00 01
	00 00		 lea	 eax, DWORD PTR [edx+ecx+256]
  00083	50		 push	 eax
  00084	8d 4d f0	 lea	 ecx, DWORD PTR _r$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 _xor_block_aligned@8

; 707  : 		xor_8kt64(1);

  0008d	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00090	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  00094	83 e0 0f	 and	 eax, 15			; 0000000fH
  00097	c1 e0 04	 shl	 eax, 4
  0009a	8b 4d 10	 mov	 ecx, DWORD PTR _ctx$[ebp]
  0009d	8d 94 01 00 02
	00 00		 lea	 edx, DWORD PTR [ecx+eax+512]
  000a4	52		 push	 edx
  000a5	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 _xor_block_aligned@8
  000ae	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  000b1	0f b6 51 01	 movzx	 edx, BYTE PTR [ecx+1]
  000b5	c1 fa 04	 sar	 edx, 4
  000b8	c1 e2 04	 shl	 edx, 4
  000bb	8b 45 10	 mov	 eax, DWORD PTR _ctx$[ebp]
  000be	8d 8c 10 00 03
	00 00		 lea	 ecx, DWORD PTR [eax+edx+768]
  000c5	51		 push	 ecx
  000c6	8d 55 f0	 lea	 edx, DWORD PTR _r$[ebp]
  000c9	52		 push	 edx
  000ca	e8 00 00 00 00	 call	 _xor_block_aligned@8
$LN2@Gf128MulBy:

; 708  : 	}
; 709  : 	if (a[2])

  000cf	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000d2	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  000d6	85 c9		 test	 ecx, ecx
  000d8	74 42		 je	 SHORT $LN1@Gf128MulBy

; 710  : 	{
; 711  : 		xor_8kt64(2);

  000da	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  000dd	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  000e1	83 e0 0f	 and	 eax, 15			; 0000000fH
  000e4	c1 e0 04	 shl	 eax, 4
  000e7	8b 4d 10	 mov	 ecx, DWORD PTR _ctx$[ebp]
  000ea	8d 94 01 00 04
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1024]
  000f1	52		 push	 edx
  000f2	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 _xor_block_aligned@8
  000fb	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  000fe	0f b6 51 02	 movzx	 edx, BYTE PTR [ecx+2]
  00102	c1 fa 04	 sar	 edx, 4
  00105	c1 e2 04	 shl	 edx, 4
  00108	8b 45 10	 mov	 eax, DWORD PTR _ctx$[ebp]
  0010b	8d 8c 10 00 05
	00 00		 lea	 ecx, DWORD PTR [eax+edx+1280]
  00112	51		 push	 ecx
  00113	8d 55 f0	 lea	 edx, DWORD PTR _r$[ebp]
  00116	52		 push	 edx
  00117	e8 00 00 00 00	 call	 _xor_block_aligned@8
$LN1@Gf128MulBy:

; 712  : 	}
; 713  : 	xor_8kt64(3);

  0011c	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0011f	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00123	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00126	c1 e1 04	 shl	 ecx, 4
  00129	8b 55 10	 mov	 edx, DWORD PTR _ctx$[ebp]
  0012c	8d 84 0a 00 06
	00 00		 lea	 eax, DWORD PTR [edx+ecx+1536]
  00133	50		 push	 eax
  00134	8d 4d f0	 lea	 ecx, DWORD PTR _r$[ebp]
  00137	51		 push	 ecx
  00138	e8 00 00 00 00	 call	 _xor_block_aligned@8
  0013d	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00140	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  00144	c1 f8 04	 sar	 eax, 4
  00147	c1 e0 04	 shl	 eax, 4
  0014a	8b 4d 10	 mov	 ecx, DWORD PTR _ctx$[ebp]
  0014d	8d 94 01 00 07
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1792]
  00154	52		 push	 edx
  00155	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  00158	50		 push	 eax
  00159	e8 00 00 00 00	 call	 _xor_block_aligned@8

; 714  :     xor_8kt64(4);

  0015e	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00161	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  00165	83 e2 0f	 and	 edx, 15			; 0000000fH
  00168	c1 e2 04	 shl	 edx, 4
  0016b	8b 45 10	 mov	 eax, DWORD PTR _ctx$[ebp]
  0016e	8d 8c 10 00 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx+2048]
  00175	51		 push	 ecx
  00176	8d 55 f0	 lea	 edx, DWORD PTR _r$[ebp]
  00179	52		 push	 edx
  0017a	e8 00 00 00 00	 call	 _xor_block_aligned@8
  0017f	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00182	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00186	c1 f9 04	 sar	 ecx, 4
  00189	c1 e1 04	 shl	 ecx, 4
  0018c	8b 55 10	 mov	 edx, DWORD PTR _ctx$[ebp]
  0018f	8d 84 0a 00 09
	00 00		 lea	 eax, DWORD PTR [edx+ecx+2304]
  00196	50		 push	 eax
  00197	8d 4d f0	 lea	 ecx, DWORD PTR _r$[ebp]
  0019a	51		 push	 ecx
  0019b	e8 00 00 00 00	 call	 _xor_block_aligned@8

; 715  : 	xor_8kt64(5);

  001a0	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  001a3	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  001a7	83 e0 0f	 and	 eax, 15			; 0000000fH
  001aa	c1 e0 04	 shl	 eax, 4
  001ad	8b 4d 10	 mov	 ecx, DWORD PTR _ctx$[ebp]
  001b0	8d 94 01 00 0a
	00 00		 lea	 edx, DWORD PTR [ecx+eax+2560]
  001b7	52		 push	 edx
  001b8	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  001bb	50		 push	 eax
  001bc	e8 00 00 00 00	 call	 _xor_block_aligned@8
  001c1	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  001c4	0f b6 51 05	 movzx	 edx, BYTE PTR [ecx+5]
  001c8	c1 fa 04	 sar	 edx, 4
  001cb	c1 e2 04	 shl	 edx, 4
  001ce	8b 45 10	 mov	 eax, DWORD PTR _ctx$[ebp]
  001d1	8d 8c 10 00 0b
	00 00		 lea	 ecx, DWORD PTR [eax+edx+2816]
  001d8	51		 push	 ecx
  001d9	8d 55 f0	 lea	 edx, DWORD PTR _r$[ebp]
  001dc	52		 push	 edx
  001dd	e8 00 00 00 00	 call	 _xor_block_aligned@8

; 716  : 	xor_8kt64(6);

  001e2	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  001e5	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  001e9	83 e1 0f	 and	 ecx, 15			; 0000000fH
  001ec	c1 e1 04	 shl	 ecx, 4
  001ef	8b 55 10	 mov	 edx, DWORD PTR _ctx$[ebp]
  001f2	8d 84 0a 00 0c
	00 00		 lea	 eax, DWORD PTR [edx+ecx+3072]
  001f9	50		 push	 eax
  001fa	8d 4d f0	 lea	 ecx, DWORD PTR _r$[ebp]
  001fd	51		 push	 ecx
  001fe	e8 00 00 00 00	 call	 _xor_block_aligned@8
  00203	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00206	0f b6 42 06	 movzx	 eax, BYTE PTR [edx+6]
  0020a	c1 f8 04	 sar	 eax, 4
  0020d	c1 e0 04	 shl	 eax, 4
  00210	8b 4d 10	 mov	 ecx, DWORD PTR _ctx$[ebp]
  00213	8d 94 01 00 0d
	00 00		 lea	 edx, DWORD PTR [ecx+eax+3328]
  0021a	52		 push	 edx
  0021b	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  0021e	50		 push	 eax
  0021f	e8 00 00 00 00	 call	 _xor_block_aligned@8

; 717  : 
; 718  :     move_block_aligned(p, r);

  00224	8d 4d f0	 lea	 ecx, DWORD PTR _r$[ebp]
  00227	51		 push	 ecx
  00228	8b 55 0c	 mov	 edx, DWORD PTR _p$[ebp]
  0022b	52		 push	 edx
  0022c	e8 00 00 00 00	 call	 _move_block_aligned@8

; 719  : }

  00231	8b e5		 mov	 esp, ebp
  00233	5d		 pop	 ebp
  00234	c2 0c 00	 ret	 12			; 0000000cH
_Gf128MulBy64Tab@12 ENDP
_TEXT	ENDS
PUBLIC	_xor_block_aligned64@8
PUBLIC	_move_block_aligned64@8
PUBLIC	_Gf64MulTab@12
; Function compile flags: /Odtp
;	COMDAT _Gf64MulTab@12
_TEXT	SEGMENT
_r$ = -8						; size = 8
_a$ = 8							; size = 4
_p$ = 12						; size = 4
_ctx$ = 16						; size = 4
_Gf64MulTab@12 PROC					; COMDAT

; 727  : {  

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 728  : 	/* Deprecated/legacy */
; 729  : 
; 730  : 	unsigned __int32 r[CBLK_LEN8 >> 2];
; 731  : 
; 732  : 	move_block_aligned64(r, ctx->gf_t64[7*2][a[7] & 15]);

  00008	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0000b	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  0000f	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00012	8b 55 10	 mov	 edx, DWORD PTR _ctx$[ebp]
  00015	8d 84 ca 00 17
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+5888]
  0001c	50		 push	 eax
  0001d	8d 4d f8	 lea	 ecx, DWORD PTR _r$[ebp]
  00020	51		 push	 ecx
  00021	e8 00 00 00 00	 call	 _move_block_aligned64@8

; 733  :     xor_block_aligned64(r,  ctx->gf_t64[7*2+1][a[7] >> 4]);

  00026	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00029	0f b6 42 07	 movzx	 eax, BYTE PTR [edx+7]
  0002d	c1 f8 04	 sar	 eax, 4
  00030	8b 4d 10	 mov	 ecx, DWORD PTR _ctx$[ebp]
  00033	8d 94 c1 80 17
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+6016]
  0003a	52		 push	 edx
  0003b	8d 45 f8	 lea	 eax, DWORD PTR _r$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 _xor_block_aligned64@8

; 734  : 
; 735  : 	if (*(unsigned __int16 *)a)

  00044	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00047	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0004a	85 d2		 test	 edx, edx
  0004c	74 76		 je	 SHORT $LN2@Gf64MulTab

; 736  : 	{
; 737  : 		xor_8k64(0);

  0004e	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00051	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00054	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00057	8b 55 10	 mov	 edx, DWORD PTR _ctx$[ebp]
  0005a	8d 84 ca 00 10
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+4096]
  00061	50		 push	 eax
  00062	8d 4d f8	 lea	 ecx, DWORD PTR _r$[ebp]
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 _xor_block_aligned64@8
  0006b	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0006e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00071	c1 f8 04	 sar	 eax, 4
  00074	8b 4d 10	 mov	 ecx, DWORD PTR _ctx$[ebp]
  00077	8d 94 c1 80 10
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+4224]
  0007e	52		 push	 edx
  0007f	8d 45 f8	 lea	 eax, DWORD PTR _r$[ebp]
  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 _xor_block_aligned64@8

; 738  : 		xor_8k64(1);

  00088	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0008b	0f b6 51 01	 movzx	 edx, BYTE PTR [ecx+1]
  0008f	83 e2 0f	 and	 edx, 15			; 0000000fH
  00092	8b 45 10	 mov	 eax, DWORD PTR _ctx$[ebp]
  00095	8d 8c d0 00 11
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+4352]
  0009c	51		 push	 ecx
  0009d	8d 55 f8	 lea	 edx, DWORD PTR _r$[ebp]
  000a0	52		 push	 edx
  000a1	e8 00 00 00 00	 call	 _xor_block_aligned64@8
  000a6	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000a9	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  000ad	c1 f9 04	 sar	 ecx, 4
  000b0	8b 55 10	 mov	 edx, DWORD PTR _ctx$[ebp]
  000b3	8d 84 ca 80 11
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+4480]
  000ba	50		 push	 eax
  000bb	8d 4d f8	 lea	 ecx, DWORD PTR _r$[ebp]
  000be	51		 push	 ecx
  000bf	e8 00 00 00 00	 call	 _xor_block_aligned64@8
$LN2@Gf64MulTab:

; 739  : 	}
; 740  : 	if (a[2])

  000c4	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  000c7	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  000cb	85 c0		 test	 eax, eax
  000cd	74 3c		 je	 SHORT $LN1@Gf64MulTab

; 741  : 	{
; 742  : 		xor_8k64(2);

  000cf	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  000d2	0f b6 51 02	 movzx	 edx, BYTE PTR [ecx+2]
  000d6	83 e2 0f	 and	 edx, 15			; 0000000fH
  000d9	8b 45 10	 mov	 eax, DWORD PTR _ctx$[ebp]
  000dc	8d 8c d0 00 12
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+4608]
  000e3	51		 push	 ecx
  000e4	8d 55 f8	 lea	 edx, DWORD PTR _r$[ebp]
  000e7	52		 push	 edx
  000e8	e8 00 00 00 00	 call	 _xor_block_aligned64@8
  000ed	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000f0	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  000f4	c1 f9 04	 sar	 ecx, 4
  000f7	8b 55 10	 mov	 edx, DWORD PTR _ctx$[ebp]
  000fa	8d 84 ca 80 12
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+4736]
  00101	50		 push	 eax
  00102	8d 4d f8	 lea	 ecx, DWORD PTR _r$[ebp]
  00105	51		 push	 ecx
  00106	e8 00 00 00 00	 call	 _xor_block_aligned64@8
$LN1@Gf64MulTab:

; 743  : 	}
; 744  : 	xor_8k64(3);

  0010b	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0010e	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  00112	83 e0 0f	 and	 eax, 15			; 0000000fH
  00115	8b 4d 10	 mov	 ecx, DWORD PTR _ctx$[ebp]
  00118	8d 94 c1 00 13
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+4864]
  0011f	52		 push	 edx
  00120	8d 45 f8	 lea	 eax, DWORD PTR _r$[ebp]
  00123	50		 push	 eax
  00124	e8 00 00 00 00	 call	 _xor_block_aligned64@8
  00129	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0012c	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00130	c1 fa 04	 sar	 edx, 4
  00133	8b 45 10	 mov	 eax, DWORD PTR _ctx$[ebp]
  00136	8d 8c d0 80 13
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+4992]
  0013d	51		 push	 ecx
  0013e	8d 55 f8	 lea	 edx, DWORD PTR _r$[ebp]
  00141	52		 push	 edx
  00142	e8 00 00 00 00	 call	 _xor_block_aligned64@8

; 745  :     xor_8k64(4);

  00147	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0014a	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0014e	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00151	8b 55 10	 mov	 edx, DWORD PTR _ctx$[ebp]
  00154	8d 84 ca 00 14
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+5120]
  0015b	50		 push	 eax
  0015c	8d 4d f8	 lea	 ecx, DWORD PTR _r$[ebp]
  0015f	51		 push	 ecx
  00160	e8 00 00 00 00	 call	 _xor_block_aligned64@8
  00165	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00168	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  0016c	c1 f8 04	 sar	 eax, 4
  0016f	8b 4d 10	 mov	 ecx, DWORD PTR _ctx$[ebp]
  00172	8d 94 c1 80 14
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+5248]
  00179	52		 push	 edx
  0017a	8d 45 f8	 lea	 eax, DWORD PTR _r$[ebp]
  0017d	50		 push	 eax
  0017e	e8 00 00 00 00	 call	 _xor_block_aligned64@8

; 746  : 	xor_8k64(5);

  00183	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00186	0f b6 51 05	 movzx	 edx, BYTE PTR [ecx+5]
  0018a	83 e2 0f	 and	 edx, 15			; 0000000fH
  0018d	8b 45 10	 mov	 eax, DWORD PTR _ctx$[ebp]
  00190	8d 8c d0 00 15
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+5376]
  00197	51		 push	 ecx
  00198	8d 55 f8	 lea	 edx, DWORD PTR _r$[ebp]
  0019b	52		 push	 edx
  0019c	e8 00 00 00 00	 call	 _xor_block_aligned64@8
  001a1	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  001a4	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  001a8	c1 f9 04	 sar	 ecx, 4
  001ab	8b 55 10	 mov	 edx, DWORD PTR _ctx$[ebp]
  001ae	8d 84 ca 80 15
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+5504]
  001b5	50		 push	 eax
  001b6	8d 4d f8	 lea	 ecx, DWORD PTR _r$[ebp]
  001b9	51		 push	 ecx
  001ba	e8 00 00 00 00	 call	 _xor_block_aligned64@8

; 747  : 	xor_8k64(6);

  001bf	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  001c2	0f b6 42 06	 movzx	 eax, BYTE PTR [edx+6]
  001c6	83 e0 0f	 and	 eax, 15			; 0000000fH
  001c9	8b 4d 10	 mov	 ecx, DWORD PTR _ctx$[ebp]
  001cc	8d 94 c1 00 16
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+5632]
  001d3	52		 push	 edx
  001d4	8d 45 f8	 lea	 eax, DWORD PTR _r$[ebp]
  001d7	50		 push	 eax
  001d8	e8 00 00 00 00	 call	 _xor_block_aligned64@8
  001dd	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  001e0	0f b6 51 06	 movzx	 edx, BYTE PTR [ecx+6]
  001e4	c1 fa 04	 sar	 edx, 4
  001e7	8b 45 10	 mov	 eax, DWORD PTR _ctx$[ebp]
  001ea	8d 8c d0 80 16
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+5760]
  001f1	51		 push	 ecx
  001f2	8d 55 f8	 lea	 edx, DWORD PTR _r$[ebp]
  001f5	52		 push	 edx
  001f6	e8 00 00 00 00	 call	 _xor_block_aligned64@8

; 748  : 
; 749  :     move_block_aligned64(p, r);

  001fb	8d 45 f8	 lea	 eax, DWORD PTR _r$[ebp]
  001fe	50		 push	 eax
  001ff	8b 4d 0c	 mov	 ecx, DWORD PTR _p$[ebp]
  00202	51		 push	 ecx
  00203	e8 00 00 00 00	 call	 _move_block_aligned64@8

; 750  : }

  00208	8b e5		 mov	 esp, ebp
  0020a	5d		 pop	 ebp
  0020b	c2 0c 00	 ret	 12			; 0000000cH
_Gf64MulTab@12 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _move_block_aligned64@8
_TEXT	SEGMENT
_p$ = 8							; size = 4
_q$ = 12						; size = 4
_move_block_aligned64@8 PROC				; COMDAT

; 161  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 162  :     lp32(p)[0] = lp32(q)[0], lp32(p)[1] = lp32(q)[1];

  00005	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR _q$[ebp]
  0000b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00012	8b 4d 0c	 mov	 ecx, DWORD PTR _q$[ebp]
  00015	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00018	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 163  : }

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
_move_block_aligned64@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _xor_block_aligned64@8
_TEXT	SEGMENT
_p$ = 8							; size = 4
_q$ = 12						; size = 4
_xor_block_aligned64@8 PROC				; COMDAT

; 172  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 173  :     lp32(p)[0] ^= lp32(q)[0], lp32(p)[1] ^= lp32(q)[1];

  00005	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR _q$[ebp]
  0000b	8b 10		 mov	 edx, DWORD PTR [eax]
  0000d	33 11		 xor	 edx, DWORD PTR [ecx]
  0000f	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00012	89 10		 mov	 DWORD PTR [eax], edx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00017	8b 55 0c	 mov	 edx, DWORD PTR _q$[ebp]
  0001a	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0001d	33 42 04	 xor	 eax, DWORD PTR [edx+4]
  00020	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00023	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 174  : }

  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
_xor_block_aligned64@8 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_GfMulSelfTest@0
; Function compile flags: /Odtp
;	COMDAT _GfMulSelfTest@0
_TEXT	SEGMENT
tv135 = -88						; size = 4
_j$ = -84						; size = 4
_result$ = -80						; size = 4
_b$ = -76						; size = 16
_p1$ = -60						; size = 16
_gfCtx$ = -44						; size = 4
_p2$ = -40						; size = 16
_i$ = -24						; size = 4
_a$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_GfMulSelfTest@0 PROC					; COMDAT

; 840  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 58	 sub	 esp, 88			; 00000058H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00012	56		 push	 esi
  00013	57		 push	 edi

; 841  : 	BOOL result = TRUE;

  00014	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _result$[ebp], 1

; 842  : 	unsigned __int8 a[16];
; 843  : 	unsigned __int8 b[16];
; 844  : 	unsigned __int8 p1[16];
; 845  : 	unsigned __int8 p2[16];
; 846  : 	GfCtx *gfCtx = (GfCtx *) TCalloc (sizeof (GfCtx));

  0001b	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00020	68 00 18 00 00	 push	 6144			; 00001800H
  00025	6a 00		 push	 0
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0002d	89 45 d4	 mov	 DWORD PTR _gfCtx$[ebp], eax

; 847  : 	int i, j;
; 848  : 
; 849  : 	if (!gfCtx)

  00030	83 7d d4 00	 cmp	 DWORD PTR _gfCtx$[ebp], 0
  00034	75 07		 jne	 SHORT $LN15@GfMulSelfT

; 850  : 		return FALSE;

  00036	33 c0		 xor	 eax, eax
  00038	e9 6e 01 00 00	 jmp	 $LN16@GfMulSelfT
$LN15@GfMulSelfT:

; 851  : 
; 852  : 	/* GF(2^64) - deprecated/legacy */
; 853  : 	for (i = 0; i < 0x100; i++)

  0003d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00044	eb 09		 jmp	 SHORT $LN14@GfMulSelfT
$LN13@GfMulSelfT:
  00046	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  00049	83 c0 01	 add	 eax, 1
  0004c	89 45 e8	 mov	 DWORD PTR _i$[ebp], eax
$LN14@GfMulSelfT:
  0004f	81 7d e8 00 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 256	; 00000100H
  00056	0f 8d 85 00 00
	00		 jge	 $LN12@GfMulSelfT

; 854  : 	{
; 855  : 		for (j = 0; j < 8; j++)

  0005c	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00063	eb 09		 jmp	 SHORT $LN11@GfMulSelfT
$LN10@GfMulSelfT:
  00065	8b 4d ac	 mov	 ecx, DWORD PTR _j$[ebp]
  00068	83 c1 01	 add	 ecx, 1
  0006b	89 4d ac	 mov	 DWORD PTR _j$[ebp], ecx
$LN11@GfMulSelfT:
  0006e	83 7d ac 08	 cmp	 DWORD PTR _j$[ebp], 8
  00072	7d 21		 jge	 SHORT $LN9@GfMulSelfT

; 856  : 		{
; 857  : 			a[j] = (unsigned __int8) i;

  00074	8b 55 ac	 mov	 edx, DWORD PTR _j$[ebp]
  00077	8a 45 e8	 mov	 al, BYTE PTR _i$[ebp]
  0007a	88 44 15 ec	 mov	 BYTE PTR _a$[ebp+edx], al

; 858  : 			b[j] = a[j] ^ 0xff;

  0007e	8b 4d ac	 mov	 ecx, DWORD PTR _j$[ebp]
  00081	0f b6 54 0d ec	 movzx	 edx, BYTE PTR _a$[ebp+ecx]
  00086	81 f2 ff 00 00
	00		 xor	 edx, 255		; 000000ffH
  0008c	8b 45 ac	 mov	 eax, DWORD PTR _j$[ebp]
  0008f	88 54 05 b4	 mov	 BYTE PTR _b$[ebp+eax], dl

; 859  : 		}

  00093	eb d0		 jmp	 SHORT $LN10@GfMulSelfT
$LN9@GfMulSelfT:

; 860  : 
; 861  : 		GfMul64Basic (a, b, p1);

  00095	8d 4d c4	 lea	 ecx, DWORD PTR _p1$[ebp]
  00098	51		 push	 ecx
  00099	8d 55 b4	 lea	 edx, DWORD PTR _b$[ebp]
  0009c	52		 push	 edx
  0009d	8d 45 ec	 lea	 eax, DWORD PTR _a$[ebp]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 _GfMul64Basic@12

; 862  : 	
; 863  : 		Gf64TabInit (a, gfCtx);

  000a6	8b 4d d4	 mov	 ecx, DWORD PTR _gfCtx$[ebp]
  000a9	51		 push	 ecx
  000aa	8d 55 ec	 lea	 edx, DWORD PTR _a$[ebp]
  000ad	52		 push	 edx
  000ae	e8 00 00 00 00	 call	 _Gf64TabInit@8

; 864  : 		Gf64MulTab (b, p2, gfCtx);

  000b3	8b 45 d4	 mov	 eax, DWORD PTR _gfCtx$[ebp]
  000b6	50		 push	 eax
  000b7	8d 4d d8	 lea	 ecx, DWORD PTR _p2$[ebp]
  000ba	51		 push	 ecx
  000bb	8d 55 b4	 lea	 edx, DWORD PTR _b$[ebp]
  000be	52		 push	 edx
  000bf	e8 00 00 00 00	 call	 _Gf64MulTab@12

; 865  : 
; 866  : 		if (memcmp (p1, p2, 8) != 0)

  000c4	b9 02 00 00 00	 mov	 ecx, 2
  000c9	8d 7d d8	 lea	 edi, DWORD PTR _p2$[ebp]
  000cc	8d 75 c4	 lea	 esi, DWORD PTR _p1$[ebp]
  000cf	33 c0		 xor	 eax, eax
  000d1	f3 a7		 repe cmpsd
  000d3	74 07		 je	 SHORT $LN8@GfMulSelfT

; 867  : 			result = FALSE;

  000d5	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _result$[ebp], 0
$LN8@GfMulSelfT:

; 868  : 	}

  000dc	e9 65 ff ff ff	 jmp	 $LN13@GfMulSelfT
$LN12@GfMulSelfT:

; 869  : 
; 870  : 	/* GF(2^128) */
; 871  : 	for (i = 0; i < 0x100; i++)

  000e1	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000e8	eb 09		 jmp	 SHORT $LN7@GfMulSelfT
$LN6@GfMulSelfT:
  000ea	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  000ed	83 c1 01	 add	 ecx, 1
  000f0	89 4d e8	 mov	 DWORD PTR _i$[ebp], ecx
$LN7@GfMulSelfT:
  000f3	81 7d e8 00 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 256	; 00000100H
  000fa	0f 8d 99 00 00
	00		 jge	 $LN5@GfMulSelfT

; 872  : 	{
; 873  : 		for (j = 0; j < 16; j++)

  00100	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00107	eb 09		 jmp	 SHORT $LN4@GfMulSelfT
$LN3@GfMulSelfT:
  00109	8b 55 ac	 mov	 edx, DWORD PTR _j$[ebp]
  0010c	83 c2 01	 add	 edx, 1
  0010f	89 55 ac	 mov	 DWORD PTR _j$[ebp], edx
$LN4@GfMulSelfT:
  00112	83 7d ac 10	 cmp	 DWORD PTR _j$[ebp], 16	; 00000010H
  00116	7d 35		 jge	 SHORT $LN2@GfMulSelfT

; 874  : 		{
; 875  : 			a[j] = (unsigned __int8) i;

  00118	8b 45 ac	 mov	 eax, DWORD PTR _j$[ebp]
  0011b	8a 4d e8	 mov	 cl, BYTE PTR _i$[ebp]
  0011e	88 4c 05 ec	 mov	 BYTE PTR _a$[ebp+eax], cl

; 876  : 			b[j] = j < 8 ? 0 : a[j] ^ 0xff;

  00122	83 7d ac 08	 cmp	 DWORD PTR _j$[ebp], 8
  00126	7d 09		 jge	 SHORT $LN18@GfMulSelfT
  00128	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv135[ebp], 0
  0012f	eb 10		 jmp	 SHORT $LN19@GfMulSelfT
$LN18@GfMulSelfT:
  00131	8b 55 ac	 mov	 edx, DWORD PTR _j$[ebp]
  00134	0f b6 44 15 ec	 movzx	 eax, BYTE PTR _a$[ebp+edx]
  00139	35 ff 00 00 00	 xor	 eax, 255		; 000000ffH
  0013e	89 45 a8	 mov	 DWORD PTR tv135[ebp], eax
$LN19@GfMulSelfT:
  00141	8b 4d ac	 mov	 ecx, DWORD PTR _j$[ebp]
  00144	8a 55 a8	 mov	 dl, BYTE PTR tv135[ebp]
  00147	88 54 0d b4	 mov	 BYTE PTR _b$[ebp+ecx], dl

; 877  : 		}

  0014b	eb bc		 jmp	 SHORT $LN3@GfMulSelfT
$LN2@GfMulSelfT:

; 878  : 
; 879  : 		GfMul128Basic (a, b, p1);

  0014d	8d 45 c4	 lea	 eax, DWORD PTR _p1$[ebp]
  00150	50		 push	 eax
  00151	8d 4d b4	 lea	 ecx, DWORD PTR _b$[ebp]
  00154	51		 push	 ecx
  00155	8d 55 ec	 lea	 edx, DWORD PTR _a$[ebp]
  00158	52		 push	 edx
  00159	e8 00 00 00 00	 call	 _GfMul128Basic@12

; 880  : 	
; 881  : 		Gf128Tab64Init (a, gfCtx);

  0015e	8b 45 d4	 mov	 eax, DWORD PTR _gfCtx$[ebp]
  00161	50		 push	 eax
  00162	8d 4d ec	 lea	 ecx, DWORD PTR _a$[ebp]
  00165	51		 push	 ecx
  00166	e8 00 00 00 00	 call	 _Gf128Tab64Init@8

; 882  : 		Gf128MulBy64Tab (b + 8, p2, gfCtx);

  0016b	8b 55 d4	 mov	 edx, DWORD PTR _gfCtx$[ebp]
  0016e	52		 push	 edx
  0016f	8d 45 d8	 lea	 eax, DWORD PTR _p2$[ebp]
  00172	50		 push	 eax
  00173	8d 4d bc	 lea	 ecx, DWORD PTR _b$[ebp+8]
  00176	51		 push	 ecx
  00177	e8 00 00 00 00	 call	 _Gf128MulBy64Tab@12

; 883  : 
; 884  : 		if (memcmp (p1, p2, 16) != 0)

  0017c	b9 04 00 00 00	 mov	 ecx, 4
  00181	8d 7d d8	 lea	 edi, DWORD PTR _p2$[ebp]
  00184	8d 75 c4	 lea	 esi, DWORD PTR _p1$[ebp]
  00187	33 d2		 xor	 edx, edx
  00189	f3 a7		 repe cmpsd
  0018b	74 07		 je	 SHORT $LN1@GfMulSelfT

; 885  : 			result = FALSE;

  0018d	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _result$[ebp], 0
$LN1@GfMulSelfT:

; 886  : 	}

  00194	e9 51 ff ff ff	 jmp	 $LN6@GfMulSelfT
$LN5@GfMulSelfT:

; 887  : 
; 888  : 	TCfree (gfCtx);

  00199	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0019e	8b 45 d4	 mov	 eax, DWORD PTR _gfCtx$[ebp]
  001a1	50		 push	 eax
  001a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 889  : 	return result;

  001a8	8b 45 b0	 mov	 eax, DWORD PTR _result$[ebp]
$LN16@GfMulSelfT:

; 890  : }

  001ab	5f		 pop	 edi
  001ac	5e		 pop	 esi
  001ad	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b0	33 cd		 xor	 ecx, ebp
  001b2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b7	8b e5		 mov	 esp, ebp
  001b9	5d		 pop	 ebp
  001ba	c3		 ret	 0
_GfMulSelfTest@0 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp
;	COMDAT _GfMul128Basic@12
_TEXT	SEGMENT
_la$ = -24						; size = 16
__$ArrayPad$ = -8					; size = 4
_i$ = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_p$ = 16						; size = 4
_GfMul128Basic@12 PROC					; COMDAT

; 773  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 18	 sub	 esp, 24			; 00000018H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 774  : 	int i;
; 775  : 	unsigned __int8 la[16];
; 776  : 	memcpy (la, a, 16);

  00012	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	89 4d e8	 mov	 DWORD PTR _la$[ebp], ecx
  0001a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001d	89 55 ec	 mov	 DWORD PTR _la$[ebp+4], edx
  00020	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00023	89 4d f0	 mov	 DWORD PTR _la$[ebp+8], ecx
  00026	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00029	89 55 f4	 mov	 DWORD PTR _la$[ebp+12], edx

; 777  : 	memset (p, 0, 16);

  0002c	33 c0		 xor	 eax, eax
  0002e	8b 4d 10	 mov	 ecx, DWORD PTR _p$[ebp]
  00031	89 01		 mov	 DWORD PTR [ecx], eax
  00033	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00036	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00039	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 778  : 
; 779  : 	for (i = 0; i < 128; i++)

  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00043	eb 09		 jmp	 SHORT $LN6@GfMul128Ba
$LN5@GfMul128Ba:
  00045	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00048	83 c2 01	 add	 edx, 1
  0004b	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN6@GfMul128Ba:
  0004e	81 7d fc 80 00
	00 00		 cmp	 DWORD PTR _i$[ebp], 128	; 00000080H
  00055	7d 4c		 jge	 SHORT $LN7@GfMul128Ba

; 780  : 	{
; 781  : 		if (IsBitSet128 (i, b))

  00057	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0005a	50		 push	 eax
  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0005e	51		 push	 ecx
  0005f	e8 00 00 00 00	 call	 _IsBitSet128@8
  00064	85 c0		 test	 eax, eax
  00066	74 0d		 je	 SHORT $LN3@GfMul128Ba

; 782  : 			xor128 ((uint64 *)p, (uint64 *)la);

  00068	8d 55 e8	 lea	 edx, DWORD PTR _la$[ebp]
  0006b	52		 push	 edx
  0006c	8b 45 10	 mov	 eax, DWORD PTR _p$[ebp]
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 _xor128@8
$LN3@GfMul128Ba:

; 783  : 
; 784  : 		if (la[0] & 0x80)

  00075	0f b6 4d e8	 movzx	 ecx, BYTE PTR _la$[ebp]
  00079	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  0007f	74 17		 je	 SHORT $LN2@GfMul128Ba

; 785  : 		{
; 786  : 			shl128 (la);

  00081	8d 55 e8	 lea	 edx, DWORD PTR _la$[ebp]
  00084	52		 push	 edx
  00085	e8 00 00 00 00	 call	 _shl128@4

; 787  : 			la[15] ^= 0x87;

  0008a	0f b6 45 f7	 movzx	 eax, BYTE PTR _la$[ebp+15]
  0008e	35 87 00 00 00	 xor	 eax, 135		; 00000087H
  00093	88 45 f7	 mov	 BYTE PTR _la$[ebp+15], al

; 788  : 		}
; 789  : 		else

  00096	eb 09		 jmp	 SHORT $LN1@GfMul128Ba
$LN2@GfMul128Ba:

; 790  : 		{
; 791  : 			shl128 (la);

  00098	8d 4d e8	 lea	 ecx, DWORD PTR _la$[ebp]
  0009b	51		 push	 ecx
  0009c	e8 00 00 00 00	 call	 _shl128@4
$LN1@GfMul128Ba:

; 792  : 		}
; 793  : 	}

  000a1	eb a2		 jmp	 SHORT $LN5@GfMul128Ba
$LN7@GfMul128Ba:

; 794  : }

  000a3	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a6	33 cd		 xor	 ecx, ebp
  000a8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c2 0c 00	 ret	 12			; 0000000cH
_GfMul128Basic@12 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _xor128@8
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_xor128@8 PROC						; COMDAT

; 756  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 757  : 	*a++ ^= *b++;

  00005	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  0000b	8b 10		 mov	 edx, DWORD PTR [eax]
  0000d	33 11		 xor	 edx, DWORD PTR [ecx]
  0000f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00012	33 41 04	 xor	 eax, DWORD PTR [ecx+4]
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00018	89 11		 mov	 DWORD PTR [ecx], edx
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0001d	8b 55 0c	 mov	 edx, DWORD PTR _b$[ebp]
  00020	83 c2 08	 add	 edx, 8
  00023	89 55 0c	 mov	 DWORD PTR _b$[ebp], edx
  00026	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00029	83 c0 08	 add	 eax, 8
  0002c	89 45 08	 mov	 DWORD PTR _a$[ebp], eax

; 758  : 	*a ^= *b;

  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00032	8b 55 0c	 mov	 edx, DWORD PTR _b$[ebp]
  00035	8b 01		 mov	 eax, DWORD PTR [ecx]
  00037	33 02		 xor	 eax, DWORD PTR [edx]
  00039	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0003c	33 4a 04	 xor	 ecx, DWORD PTR [edx+4]
  0003f	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00042	89 02		 mov	 DWORD PTR [edx], eax
  00044	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 759  : }

  00047	5d		 pop	 ebp
  00048	c2 08 00	 ret	 8
_xor128@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _shl128@4
_TEXT	SEGMENT
_i$ = -12						; size = 4
_xx$ = -8						; size = 4
_x$ = -4						; size = 4
_a$ = 8							; size = 4
_shl128@4 PROC						; COMDAT

; 762  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 763  : 	int i, x = 0, xx;

  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0

; 764  : 	for (i = 15; i >= 0; i--)

  0000f	c7 45 f4 0f 00
	00 00		 mov	 DWORD PTR _i$[ebp], 15	; 0000000fH
  00016	eb 09		 jmp	 SHORT $LN3@shl128
$LN2@shl128:
  00018	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0001b	83 e8 01	 sub	 eax, 1
  0001e	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN3@shl128:
  00021	83 7d f4 00	 cmp	 DWORD PTR _i$[ebp], 0
  00025	7c 33		 jl	 SHORT $LN4@shl128

; 765  : 	{
; 766  : 		xx = (a[i] & 0x80) >> 7;

  00027	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0002a	03 4d f4	 add	 ecx, DWORD PTR _i$[ebp]
  0002d	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00030	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  00036	c1 fa 07	 sar	 edx, 7
  00039	89 55 f8	 mov	 DWORD PTR _xx$[ebp], edx

; 767  : 		a[i] = (char) ((a[i] << 1) | x);

  0003c	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0003f	03 45 f4	 add	 eax, DWORD PTR _i$[ebp]
  00042	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00045	d1 e1		 shl	 ecx, 1
  00047	0b 4d fc	 or	 ecx, DWORD PTR _x$[ebp]
  0004a	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0004d	03 55 f4	 add	 edx, DWORD PTR _i$[ebp]
  00050	88 0a		 mov	 BYTE PTR [edx], cl

; 768  : 		x = xx;

  00052	8b 45 f8	 mov	 eax, DWORD PTR _xx$[ebp]
  00055	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax

; 769  : 	}

  00058	eb be		 jmp	 SHORT $LN2@shl128
$LN4@shl128:

; 770  : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
_shl128@4 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp
;	COMDAT _GfMul64Basic@12
_TEXT	SEGMENT
_la$ = -16						; size = 8
__$ArrayPad$ = -8					; size = 4
_i$ = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_p$ = 16						; size = 4
_GfMul64Basic@12 PROC					; COMDAT

; 813  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 10	 sub	 esp, 16			; 00000010H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 814  : 	/* Deprecated/legacy */
; 815  : 
; 816  : 	int i;
; 817  : 	unsigned __int8 la[8];
; 818  : 	memcpy (la, a, 8);

  00012	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	89 4d f0	 mov	 DWORD PTR _la$[ebp], ecx
  0001a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001d	89 55 f4	 mov	 DWORD PTR _la$[ebp+4], edx

; 819  : 	memset (p, 0, 8);

  00020	33 c0		 xor	 eax, eax
  00022	8b 4d 10	 mov	 ecx, DWORD PTR _p$[ebp]
  00025	89 01		 mov	 DWORD PTR [ecx], eax
  00027	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 820  : 
; 821  : 	for (i = 0; i < 64; i++)

  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00031	eb 09		 jmp	 SHORT $LN6@GfMul64Bas
$LN5@GfMul64Bas:
  00033	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00036	83 c2 01	 add	 edx, 1
  00039	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN6@GfMul64Bas:
  0003c	83 7d fc 40	 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  00040	7d 4a		 jge	 SHORT $LN7@GfMul64Bas

; 822  : 	{
; 823  : 		if (IsBitSet64 (i, b))

  00042	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  00045	50		 push	 eax
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 _IsBitSet64@8
  0004f	85 c0		 test	 eax, eax
  00051	74 0d		 je	 SHORT $LN3@GfMul64Bas

; 824  : 			xor64 ((uint64 *)p, (uint64 *)la);

  00053	8d 55 f0	 lea	 edx, DWORD PTR _la$[ebp]
  00056	52		 push	 edx
  00057	8b 45 10	 mov	 eax, DWORD PTR _p$[ebp]
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 _xor64@8
$LN3@GfMul64Bas:

; 825  : 
; 826  : 		if (la[0] & 0x80)

  00060	0f b6 4d f0	 movzx	 ecx, BYTE PTR _la$[ebp]
  00064	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  0006a	74 15		 je	 SHORT $LN2@GfMul64Bas

; 827  : 		{
; 828  : 			shl64 (la);

  0006c	8d 55 f0	 lea	 edx, DWORD PTR _la$[ebp]
  0006f	52		 push	 edx
  00070	e8 00 00 00 00	 call	 _shl64@4

; 829  : 			la[7] ^= 0x1b;

  00075	0f b6 45 f7	 movzx	 eax, BYTE PTR _la$[ebp+7]
  00079	83 f0 1b	 xor	 eax, 27			; 0000001bH
  0007c	88 45 f7	 mov	 BYTE PTR _la$[ebp+7], al

; 830  : 		}
; 831  : 		else

  0007f	eb 09		 jmp	 SHORT $LN1@GfMul64Bas
$LN2@GfMul64Bas:

; 832  : 		{
; 833  : 			shl64 (la);

  00081	8d 4d f0	 lea	 ecx, DWORD PTR _la$[ebp]
  00084	51		 push	 ecx
  00085	e8 00 00 00 00	 call	 _shl64@4
$LN1@GfMul64Bas:

; 834  : 		}
; 835  : 	}

  0008a	eb a7		 jmp	 SHORT $LN5@GfMul64Bas
$LN7@GfMul64Bas:

; 836  : }

  0008c	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008f	33 cd		 xor	 ecx, ebp
  00091	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c2 0c 00	 ret	 12			; 0000000cH
_GfMul64Basic@12 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _xor64@8
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_xor64@8 PROC						; COMDAT

; 797  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 798  : 	*a ^= *b;

  00005	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  0000b	8b 10		 mov	 edx, DWORD PTR [eax]
  0000d	33 11		 xor	 edx, DWORD PTR [ecx]
  0000f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00012	33 41 04	 xor	 eax, DWORD PTR [ecx+4]
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00018	89 11		 mov	 DWORD PTR [ecx], edx
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 799  : }

  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
_xor64@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _shl64@4
_TEXT	SEGMENT
_i$ = -12						; size = 4
_xx$ = -8						; size = 4
_x$ = -4						; size = 4
_a$ = 8							; size = 4
_shl64@4 PROC						; COMDAT

; 802  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 803  : 	int i, x = 0, xx;

  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0

; 804  : 	for (i = 7; i >= 0; i--)

  0000f	c7 45 f4 07 00
	00 00		 mov	 DWORD PTR _i$[ebp], 7
  00016	eb 09		 jmp	 SHORT $LN3@shl64
$LN2@shl64:
  00018	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0001b	83 e8 01	 sub	 eax, 1
  0001e	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN3@shl64:
  00021	83 7d f4 00	 cmp	 DWORD PTR _i$[ebp], 0
  00025	7c 33		 jl	 SHORT $LN4@shl64

; 805  : 	{
; 806  : 		xx = (a[i] & 0x80) >> 7;

  00027	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0002a	03 4d f4	 add	 ecx, DWORD PTR _i$[ebp]
  0002d	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00030	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  00036	c1 fa 07	 sar	 edx, 7
  00039	89 55 f8	 mov	 DWORD PTR _xx$[ebp], edx

; 807  : 		a[i] = (char) ((a[i] << 1) | x);

  0003c	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0003f	03 45 f4	 add	 eax, DWORD PTR _i$[ebp]
  00042	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00045	d1 e1		 shl	 ecx, 1
  00047	0b 4d fc	 or	 ecx, DWORD PTR _x$[ebp]
  0004a	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0004d	03 55 f4	 add	 edx, DWORD PTR _i$[ebp]
  00050	88 0a		 mov	 BYTE PTR [edx], cl

; 808  : 		x = xx;

  00052	8b 45 f8	 mov	 eax, DWORD PTR _xx$[ebp]
  00055	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax

; 809  : 	}

  00058	eb be		 jmp	 SHORT $LN2@shl64
$LN4@shl64:

; 810  : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
_shl64@4 ENDP
_TEXT	ENDS
END
