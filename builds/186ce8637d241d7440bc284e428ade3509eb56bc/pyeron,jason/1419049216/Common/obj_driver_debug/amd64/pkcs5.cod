; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0N@PGAIHMNP@HMAC?9SHA?9512?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0L@GENPDEDH@HMAC?9SHA?91?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BA@EMJCKHIJ@HMAC?9RIPEMD?9160?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@FNODOBFM@ DB '(Unknown)', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@FNODOBFM@ DB 'HMAC-Whirlpool', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BA@EMJCKHIJ@HMAC?9RIPEMD?9160?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BA@EMJCKHIJ@HMAC?9RIPEMD?9160?$AA@FNODOBFM@ DB 'HMAC-RIPEMD-160', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0L@GENPDEDH@HMAC?9SHA?91?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0L@GENPDEDH@HMAC?9SHA?91?$AA@FNODOBFM@ DB 'HMAC-SHA-1', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0N@PGAIHMNP@HMAC?9SHA?9512?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0N@PGAIHMNP@HMAC?9SHA?9512?$AA@FNODOBFM@ DB 'HMAC-SHA-512', 00H ;  ?? ::FNODOBFM::`string'
PUBLIC	get_pkcs5_iteration_count
;	COMDAT pdata
; File c:\home\public\desktop\projects\ciphershed\src\common\pkcs5.c
pdata	SEGMENT
$pdata$get_pkcs5_iteration_count DD imagerel $LN12
	DD	imagerel $LN12+140
	DD	imagerel $unwind$get_pkcs5_iteration_count
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_pkcs5_iteration_count DD 010c01H
	DD	0820cH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT get_pkcs5_iteration_count
_TEXT	SEGMENT
tv64 = 48
tv66 = 52
pkcs5_prf_id$ = 80
bBoot$ = 88
get_pkcs5_iteration_count PROC				; COMDAT

; 620  : {

$LN12:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 621  : 	switch (pkcs5_prf_id)

  0000c	8b 44 24 50	 mov	 eax, DWORD PTR pkcs5_prf_id$[rsp]
  00010	89 44 24 30	 mov	 DWORD PTR tv64[rsp], eax
  00014	83 7c 24 30 01	 cmp	 DWORD PTR tv64[rsp], 1
  00019	74 17		 je	 SHORT $LN5@get_pkcs5_
  0001b	83 7c 24 30 02	 cmp	 DWORD PTR tv64[rsp], 2
  00020	74 2f		 je	 SHORT $LN4@get_pkcs5_
  00022	83 7c 24 30 03	 cmp	 DWORD PTR tv64[rsp], 3
  00027	74 36		 je	 SHORT $LN2@get_pkcs5_
  00029	83 7c 24 30 04	 cmp	 DWORD PTR tv64[rsp], 4
  0002e	74 28		 je	 SHORT $LN3@get_pkcs5_
  00030	eb 34		 jmp	 SHORT $LN1@get_pkcs5_
$LN5@get_pkcs5_:

; 622  : 	{
; 623  : 	case RIPEMD160:	
; 624  : 		return (bBoot ? 1000 : 2000);

  00032	83 7c 24 58 00	 cmp	 DWORD PTR bBoot$[rsp], 0
  00037	74 0a		 je	 SHORT $LN10@get_pkcs5_
  00039	c7 44 24 34 e8
	03 00 00	 mov	 DWORD PTR tv66[rsp], 1000 ; 000003e8H
  00041	eb 08		 jmp	 SHORT $LN11@get_pkcs5_
$LN10@get_pkcs5_:
  00043	c7 44 24 34 d0
	07 00 00	 mov	 DWORD PTR tv66[rsp], 2000 ; 000007d0H
$LN11@get_pkcs5_:
  0004b	8b 44 24 34	 mov	 eax, DWORD PTR tv66[rsp]
  0004f	eb 36		 jmp	 SHORT $LN8@get_pkcs5_
$LN4@get_pkcs5_:

; 625  : 
; 626  : #ifndef TC_WINDOWS_BOOT
; 627  : 
; 628  : 	case SHA512:	
; 629  : 		return 1000;			

  00051	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  00056	eb 2f		 jmp	 SHORT $LN8@get_pkcs5_
$LN3@get_pkcs5_:

; 630  : 
; 631  : 	case SHA1:		// Deprecated/legacy		
; 632  : 		return 2000;			

  00058	b8 d0 07 00 00	 mov	 eax, 2000		; 000007d0H
  0005d	eb 28		 jmp	 SHORT $LN8@get_pkcs5_
$LN2@get_pkcs5_:

; 633  : 
; 634  : 	case WHIRLPOOL:	
; 635  : 		return 1000;

  0005f	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  00064	eb 21		 jmp	 SHORT $LN8@get_pkcs5_
$LN1@get_pkcs5_:

; 636  : #endif
; 637  : 
; 638  : 	default:		
; 639  : 		TC_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID

  00066	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  0006f	45 33 c9	 xor	 r9d, r9d
  00072	45 33 c0	 xor	 r8d, r8d
  00075	ba 7f 02 00 00	 mov	 edx, 639		; 0000027fH
  0007a	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx

; 640  : 	}
; 641  : 	return 0;

  00085	33 c0		 xor	 eax, eax
$LN8@get_pkcs5_:
$LN9@get_pkcs5_:

; 642  : }

  00087	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0008b	c3		 ret	 0
get_pkcs5_iteration_count ENDP
_TEXT	ENDS
PUBLIC	hmac_truncate
;	COMDAT pdata
pdata	SEGMENT
$pdata$hmac_truncate DD imagerel $LN6
	DD	imagerel $LN6+79
	DD	imagerel $unwind$hmac_truncate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$hmac_truncate DD 011301H
	DD	02213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT hmac_truncate
_TEXT	SEGMENT
i$ = 0
d1$ = 32
d2$ = 40
len$ = 48
hmac_truncate PROC					; COMDAT

; 30   : {

$LN6:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 31   : 	int i;
; 32   : 	for (i = 0; i < len; i++)

  00013	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  0001a	eb 09		 jmp	 SHORT $LN3@hmac_trunc
$LN2@hmac_trunc:
  0001c	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0001f	83 c0 01	 add	 eax, 1
  00022	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN3@hmac_trunc:
  00025	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  00029	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  0002c	7d 1c		 jge	 SHORT $LN1@hmac_trunc

; 33   : 		d2[i] = d1[i];

  0002e	4c 63 04 24	 movsxd	 r8, DWORD PTR i$[rsp]
  00032	48 63 14 24	 movsxd	 rdx, DWORD PTR i$[rsp]
  00036	48 8b 4c 24 28	 mov	 rcx, QWORD PTR d2$[rsp]
  0003b	48 8b 44 24 20	 mov	 rax, QWORD PTR d1$[rsp]
  00040	42 0f b6 04 00	 movzx	 eax, BYTE PTR [rax+r8]
  00045	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  00048	eb d2		 jmp	 SHORT $LN2@hmac_trunc
$LN1@hmac_trunc:

; 34   : }

  0004a	48 83 c4 18	 add	 rsp, 24
  0004e	c3		 ret	 0
hmac_truncate ENDP
PUBLIC	__$ArrayPad$
PUBLIC	hmac_whirlpool
;	COMDAT pdata
pdata	SEGMENT
$pdata$hmac_whirlpool DD imagerel $LN53
	DD	imagerel $LN53+1419
	DD	imagerel $unwind$hmac_whirlpool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$hmac_whirlpool DD 022c19H
	DD	079011aH
	DD	imagerel __GSHandlerCheck
	DD	03b8H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT hmac_whirlpool
_TEXT	SEGMENT
i$ = 32
key$ = 48
owhi$ = 112
buf$ = 176
ictx$ = 240
iwhi$ = 416
octx$ = 480
tctx$29167 = 656
burnc$29175 = 832
burnm$29173 = 840
burnc$29204 = 848
burnm$29202 = 856
burnc$29213 = 864
burnm$29211 = 872
burnc$29222 = 880
burnm$29220 = 888
burnc$29231 = 896
burnm$29229 = 904
burnc$29240 = 912
burnm$29238 = 920
burnc$29249 = 928
burnm$29247 = 936
tv156 = 944
__$ArrayPad$ = 952
k$ = 976
lk$ = 984
d$ = 992
ld$ = 1000
out$ = 1008
t$ = 1016
hmac_whirlpool PROC					; COMDAT

; 465  : {

$LN53:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec c8 03
	00 00		 sub	 rsp, 968		; 000003c8H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 b8
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 466  : 	WHIRLPOOL_CTX ictx, octx;
; 467  : 	char iwhi[WHIRLPOOL_DIGESTSIZE], owhi[WHIRLPOOL_DIGESTSIZE];
; 468  : 	char key[WHIRLPOOL_DIGESTSIZE];
; 469  : 	char buf[WHIRLPOOL_BLOCKSIZE];
; 470  : 	int i;
; 471  : 
; 472  :     /* If the key is longer than the hash algorithm block size,
; 473  : 	   let key = whirlpool(key), as per HMAC specifications. */
; 474  : 	if (lk > WHIRLPOOL_BLOCKSIZE)

  0002c	83 bc 24 d8 03
	00 00 40	 cmp	 DWORD PTR lk$[rsp], 64	; 00000040H
  00034	0f 8e c6 00 00
	00		 jle	 $LN48@hmac_whirl

; 475  : 	{
; 476  : 		WHIRLPOOL_CTX tctx;
; 477  : 
; 478  : 		WHIRLPOOL_init (&tctx);

  0003a	48 8d 8c 24 90
	02 00 00	 lea	 rcx, QWORD PTR tctx$29167[rsp]
  00042	e8 00 00 00 00	 call	 WHIRLPOOL_init

; 479  : 		WHIRLPOOL_add ((unsigned char *) k, lk * 8, &tctx);

  00047	8b 94 24 d8 03
	00 00		 mov	 edx, DWORD PTR lk$[rsp]
  0004e	c1 e2 03	 shl	 edx, 3
  00051	4c 8d 84 24 90
	02 00 00	 lea	 r8, QWORD PTR tctx$29167[rsp]
  00059	48 8b 8c 24 d0
	03 00 00	 mov	 rcx, QWORD PTR k$[rsp]
  00061	e8 00 00 00 00	 call	 WHIRLPOOL_add

; 480  : 		WHIRLPOOL_finalize (&tctx, (unsigned char *) key);

  00066	48 8d 54 24 30	 lea	 rdx, QWORD PTR key$[rsp]
  0006b	48 8d 8c 24 90
	02 00 00	 lea	 rcx, QWORD PTR tctx$29167[rsp]
  00073	e8 00 00 00 00	 call	 WHIRLPOOL_finalize

; 481  : 
; 482  : 		k = key;

  00078	4c 8d 5c 24 30	 lea	 r11, QWORD PTR key$[rsp]
  0007d	4c 89 9c 24 d0
	03 00 00	 mov	 QWORD PTR k$[rsp], r11

; 483  : 		lk = WHIRLPOOL_DIGESTSIZE;

  00085	c7 84 24 d8 03
	00 00 40 00 00
	00		 mov	 DWORD PTR lk$[rsp], 64	; 00000040H
$LN47@hmac_whirl:

; 484  : 
; 485  : 		burn (&tctx, sizeof(tctx));		// Prevent leaks

  00090	48 8d 84 24 90
	02 00 00	 lea	 rax, QWORD PTR tctx$29167[rsp]
  00098	48 89 84 24 48
	03 00 00	 mov	 QWORD PTR burnm$29173[rsp], rax
  000a0	c7 84 24 40 03
	00 00 a8 00 00
	00		 mov	 DWORD PTR burnc$29175[rsp], 168 ; 000000a8H
  000ab	ba a8 00 00 00	 mov	 edx, 168		; 000000a8H
  000b0	48 8d 8c 24 90
	02 00 00	 lea	 rcx, QWORD PTR tctx$29167[rsp]
  000b8	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN44@hmac_whirl:
  000bd	8b 8c 24 40 03
	00 00		 mov	 ecx, DWORD PTR burnc$29175[rsp]
  000c4	8b 84 24 40 03
	00 00		 mov	 eax, DWORD PTR burnc$29175[rsp]
  000cb	83 e8 01	 sub	 eax, 1
  000ce	89 84 24 40 03
	00 00		 mov	 DWORD PTR burnc$29175[rsp], eax
  000d5	85 c9		 test	 ecx, ecx
  000d7	74 21		 je	 SHORT $LN43@hmac_whirl
  000d9	48 8b 84 24 48
	03 00 00	 mov	 rax, QWORD PTR burnm$29173[rsp]
  000e1	c6 00 00	 mov	 BYTE PTR [rax], 0
  000e4	48 8b 84 24 48
	03 00 00	 mov	 rax, QWORD PTR burnm$29173[rsp]
  000ec	48 83 c0 01	 add	 rax, 1
  000f0	48 89 84 24 48
	03 00 00	 mov	 QWORD PTR burnm$29173[rsp], rax
  000f8	eb c3		 jmp	 SHORT $LN44@hmac_whirl
$LN43@hmac_whirl:
  000fa	33 c0		 xor	 eax, eax
  000fc	85 c0		 test	 eax, eax
  000fe	75 90		 jne	 SHORT $LN47@hmac_whirl
$LN48@hmac_whirl:

; 486  : 	}
; 487  : 
; 488  : 	/**** Inner Digest ****/
; 489  : 
; 490  : 	WHIRLPOOL_init (&ictx);

  00100	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR ictx$[rsp]
  00108	e8 00 00 00 00	 call	 WHIRLPOOL_init

; 491  : 
; 492  : 	/* Pad the key for inner digest */
; 493  : 	for (i = 0; i < lk; ++i)

  0010d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00115	eb 0b		 jmp	 SHORT $LN42@hmac_whirl
$LN41@hmac_whirl:
  00117	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0011b	83 c0 01	 add	 eax, 1
  0011e	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN42@hmac_whirl:
  00122	8b 84 24 d8 03
	00 00		 mov	 eax, DWORD PTR lk$[rsp]
  00129	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0012d	7d 22		 jge	 SHORT $LN40@hmac_whirl

; 494  : 		buf[i] = (char) (k[i] ^ 0x36);

  0012f	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00134	48 8b 84 24 d0
	03 00 00	 mov	 rax, QWORD PTR k$[rsp]
  0013c	0f be 0c 08	 movsx	 ecx, BYTE PTR [rax+rcx]
  00140	83 f1 36	 xor	 ecx, 54			; 00000036H
  00143	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00148	88 8c 04 b0 00
	00 00		 mov	 BYTE PTR buf$[rsp+rax], cl
  0014f	eb c6		 jmp	 SHORT $LN41@hmac_whirl
$LN40@hmac_whirl:

; 495  : 	for (i = lk; i < WHIRLPOOL_BLOCKSIZE; ++i)

  00151	8b 84 24 d8 03
	00 00		 mov	 eax, DWORD PTR lk$[rsp]
  00158	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0015c	eb 0b		 jmp	 SHORT $LN39@hmac_whirl
$LN38@hmac_whirl:
  0015e	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00162	83 c0 01	 add	 eax, 1
  00165	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN39@hmac_whirl:
  00169	83 7c 24 20 40	 cmp	 DWORD PTR i$[rsp], 64	; 00000040H
  0016e	7d 0f		 jge	 SHORT $LN37@hmac_whirl

; 496  : 		buf[i] = 0x36;

  00170	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00175	c6 84 04 b0 00
	00 00 36	 mov	 BYTE PTR buf$[rsp+rax], 54 ; 00000036H
  0017d	eb df		 jmp	 SHORT $LN38@hmac_whirl
$LN37@hmac_whirl:

; 497  : 
; 498  : 	WHIRLPOOL_add ((unsigned char *) buf, WHIRLPOOL_BLOCKSIZE * 8, &ictx);

  0017f	4c 8d 84 24 f0
	00 00 00	 lea	 r8, QWORD PTR ictx$[rsp]
  00187	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  0018c	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00194	e8 00 00 00 00	 call	 WHIRLPOOL_add

; 499  : 	WHIRLPOOL_add ((unsigned char *) d, ld * 8, &ictx);

  00199	8b 94 24 e8 03
	00 00		 mov	 edx, DWORD PTR ld$[rsp]
  001a0	c1 e2 03	 shl	 edx, 3
  001a3	4c 8d 84 24 f0
	00 00 00	 lea	 r8, QWORD PTR ictx$[rsp]
  001ab	48 8b 8c 24 e0
	03 00 00	 mov	 rcx, QWORD PTR d$[rsp]
  001b3	e8 00 00 00 00	 call	 WHIRLPOOL_add

; 500  : 
; 501  : 	WHIRLPOOL_finalize (&ictx, (unsigned char *) iwhi);

  001b8	48 8d 94 24 a0
	01 00 00	 lea	 rdx, QWORD PTR iwhi$[rsp]
  001c0	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR ictx$[rsp]
  001c8	e8 00 00 00 00	 call	 WHIRLPOOL_finalize

; 502  : 
; 503  : 	/**** Outer Digest ****/
; 504  : 
; 505  : 	WHIRLPOOL_init (&octx);

  001cd	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR octx$[rsp]
  001d5	e8 00 00 00 00	 call	 WHIRLPOOL_init

; 506  : 
; 507  : 	for (i = 0; i < lk; ++i)

  001da	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001e2	eb 0b		 jmp	 SHORT $LN36@hmac_whirl
$LN35@hmac_whirl:
  001e4	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001e8	83 c0 01	 add	 eax, 1
  001eb	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN36@hmac_whirl:
  001ef	8b 84 24 d8 03
	00 00		 mov	 eax, DWORD PTR lk$[rsp]
  001f6	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  001fa	7d 22		 jge	 SHORT $LN34@hmac_whirl

; 508  : 		buf[i] = (char) (k[i] ^ 0x5C);

  001fc	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00201	48 8b 84 24 d0
	03 00 00	 mov	 rax, QWORD PTR k$[rsp]
  00209	0f be 0c 08	 movsx	 ecx, BYTE PTR [rax+rcx]
  0020d	83 f1 5c	 xor	 ecx, 92			; 0000005cH
  00210	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00215	88 8c 04 b0 00
	00 00		 mov	 BYTE PTR buf$[rsp+rax], cl
  0021c	eb c6		 jmp	 SHORT $LN35@hmac_whirl
$LN34@hmac_whirl:

; 509  : 	for (i = lk; i < WHIRLPOOL_BLOCKSIZE; ++i)

  0021e	8b 84 24 d8 03
	00 00		 mov	 eax, DWORD PTR lk$[rsp]
  00225	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00229	eb 0b		 jmp	 SHORT $LN33@hmac_whirl
$LN32@hmac_whirl:
  0022b	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0022f	83 c0 01	 add	 eax, 1
  00232	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN33@hmac_whirl:
  00236	83 7c 24 20 40	 cmp	 DWORD PTR i$[rsp], 64	; 00000040H
  0023b	7d 0f		 jge	 SHORT $LN31@hmac_whirl

; 510  : 		buf[i] = 0x5C;

  0023d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00242	c6 84 04 b0 00
	00 00 5c	 mov	 BYTE PTR buf$[rsp+rax], 92 ; 0000005cH
  0024a	eb df		 jmp	 SHORT $LN32@hmac_whirl
$LN31@hmac_whirl:

; 511  : 
; 512  : 	WHIRLPOOL_add ((unsigned char *) buf, WHIRLPOOL_BLOCKSIZE * 8, &octx);

  0024c	4c 8d 84 24 e0
	01 00 00	 lea	 r8, QWORD PTR octx$[rsp]
  00254	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  00259	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00261	e8 00 00 00 00	 call	 WHIRLPOOL_add

; 513  : 	WHIRLPOOL_add ((unsigned char *) iwhi, WHIRLPOOL_DIGESTSIZE * 8, &octx);

  00266	4c 8d 84 24 e0
	01 00 00	 lea	 r8, QWORD PTR octx$[rsp]
  0026e	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  00273	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR iwhi$[rsp]
  0027b	e8 00 00 00 00	 call	 WHIRLPOOL_add

; 514  : 
; 515  : 	WHIRLPOOL_finalize (&octx, (unsigned char *) owhi);

  00280	48 8d 54 24 70	 lea	 rdx, QWORD PTR owhi$[rsp]
  00285	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR octx$[rsp]
  0028d	e8 00 00 00 00	 call	 WHIRLPOOL_finalize

; 516  : 
; 517  : 	/* truncate and print the results */
; 518  : 	t = t > WHIRLPOOL_DIGESTSIZE ? WHIRLPOOL_DIGESTSIZE : t;

  00292	83 bc 24 f8 03
	00 00 40	 cmp	 DWORD PTR t$[rsp], 64	; 00000040H
  0029a	7e 0d		 jle	 SHORT $LN51@hmac_whirl
  0029c	c7 84 24 b0 03
	00 00 40 00 00
	00		 mov	 DWORD PTR tv156[rsp], 64 ; 00000040H
  002a7	eb 0e		 jmp	 SHORT $LN52@hmac_whirl
$LN51@hmac_whirl:
  002a9	8b 84 24 f8 03
	00 00		 mov	 eax, DWORD PTR t$[rsp]
  002b0	89 84 24 b0 03
	00 00		 mov	 DWORD PTR tv156[rsp], eax
$LN52@hmac_whirl:
  002b7	8b 84 24 b0 03
	00 00		 mov	 eax, DWORD PTR tv156[rsp]
  002be	89 84 24 f8 03
	00 00		 mov	 DWORD PTR t$[rsp], eax

; 519  : 	hmac_truncate (owhi, out, t);

  002c5	44 8b 84 24 f8
	03 00 00	 mov	 r8d, DWORD PTR t$[rsp]
  002cd	48 8b 94 24 f0
	03 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  002d5	48 8d 4c 24 70	 lea	 rcx, QWORD PTR owhi$[rsp]
  002da	e8 00 00 00 00	 call	 hmac_truncate
$LN30@hmac_whirl:

; 520  : 
; 521  : 	/* Prevent possible leaks. */
; 522  : 	burn (&ictx, sizeof(ictx));

  002df	48 8d 84 24 f0
	00 00 00	 lea	 rax, QWORD PTR ictx$[rsp]
  002e7	48 89 84 24 58
	03 00 00	 mov	 QWORD PTR burnm$29202[rsp], rax
  002ef	c7 84 24 50 03
	00 00 a8 00 00
	00		 mov	 DWORD PTR burnc$29204[rsp], 168 ; 000000a8H
  002fa	ba a8 00 00 00	 mov	 edx, 168		; 000000a8H
  002ff	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR ictx$[rsp]
  00307	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN27@hmac_whirl:
  0030c	8b 8c 24 50 03
	00 00		 mov	 ecx, DWORD PTR burnc$29204[rsp]
  00313	8b 84 24 50 03
	00 00		 mov	 eax, DWORD PTR burnc$29204[rsp]
  0031a	83 e8 01	 sub	 eax, 1
  0031d	89 84 24 50 03
	00 00		 mov	 DWORD PTR burnc$29204[rsp], eax
  00324	85 c9		 test	 ecx, ecx
  00326	74 21		 je	 SHORT $LN26@hmac_whirl
  00328	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR burnm$29202[rsp]
  00330	c6 00 00	 mov	 BYTE PTR [rax], 0
  00333	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR burnm$29202[rsp]
  0033b	48 83 c0 01	 add	 rax, 1
  0033f	48 89 84 24 58
	03 00 00	 mov	 QWORD PTR burnm$29202[rsp], rax
  00347	eb c3		 jmp	 SHORT $LN27@hmac_whirl
$LN26@hmac_whirl:
  00349	33 c0		 xor	 eax, eax
  0034b	85 c0		 test	 eax, eax
  0034d	75 90		 jne	 SHORT $LN30@hmac_whirl
$LN25@hmac_whirl:

; 523  : 	burn (&octx, sizeof(octx));

  0034f	48 8d 84 24 e0
	01 00 00	 lea	 rax, QWORD PTR octx$[rsp]
  00357	48 89 84 24 68
	03 00 00	 mov	 QWORD PTR burnm$29211[rsp], rax
  0035f	c7 84 24 60 03
	00 00 a8 00 00
	00		 mov	 DWORD PTR burnc$29213[rsp], 168 ; 000000a8H
  0036a	ba a8 00 00 00	 mov	 edx, 168		; 000000a8H
  0036f	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR octx$[rsp]
  00377	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN22@hmac_whirl:
  0037c	8b 8c 24 60 03
	00 00		 mov	 ecx, DWORD PTR burnc$29213[rsp]
  00383	8b 84 24 60 03
	00 00		 mov	 eax, DWORD PTR burnc$29213[rsp]
  0038a	83 e8 01	 sub	 eax, 1
  0038d	89 84 24 60 03
	00 00		 mov	 DWORD PTR burnc$29213[rsp], eax
  00394	85 c9		 test	 ecx, ecx
  00396	74 21		 je	 SHORT $LN21@hmac_whirl
  00398	48 8b 84 24 68
	03 00 00	 mov	 rax, QWORD PTR burnm$29211[rsp]
  003a0	c6 00 00	 mov	 BYTE PTR [rax], 0
  003a3	48 8b 84 24 68
	03 00 00	 mov	 rax, QWORD PTR burnm$29211[rsp]
  003ab	48 83 c0 01	 add	 rax, 1
  003af	48 89 84 24 68
	03 00 00	 mov	 QWORD PTR burnm$29211[rsp], rax
  003b7	eb c3		 jmp	 SHORT $LN22@hmac_whirl
$LN21@hmac_whirl:
  003b9	33 c0		 xor	 eax, eax
  003bb	85 c0		 test	 eax, eax
  003bd	75 90		 jne	 SHORT $LN25@hmac_whirl
$LN20@hmac_whirl:

; 524  : 	burn (owhi, sizeof(owhi));

  003bf	48 8d 44 24 70	 lea	 rax, QWORD PTR owhi$[rsp]
  003c4	48 89 84 24 78
	03 00 00	 mov	 QWORD PTR burnm$29220[rsp], rax
  003cc	c7 84 24 70 03
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$29222[rsp], 64 ; 00000040H
  003d7	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  003dc	48 8d 4c 24 70	 lea	 rcx, QWORD PTR owhi$[rsp]
  003e1	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN17@hmac_whirl:
  003e6	8b 8c 24 70 03
	00 00		 mov	 ecx, DWORD PTR burnc$29222[rsp]
  003ed	8b 84 24 70 03
	00 00		 mov	 eax, DWORD PTR burnc$29222[rsp]
  003f4	83 e8 01	 sub	 eax, 1
  003f7	89 84 24 70 03
	00 00		 mov	 DWORD PTR burnc$29222[rsp], eax
  003fe	85 c9		 test	 ecx, ecx
  00400	74 21		 je	 SHORT $LN16@hmac_whirl
  00402	48 8b 84 24 78
	03 00 00	 mov	 rax, QWORD PTR burnm$29220[rsp]
  0040a	c6 00 00	 mov	 BYTE PTR [rax], 0
  0040d	48 8b 84 24 78
	03 00 00	 mov	 rax, QWORD PTR burnm$29220[rsp]
  00415	48 83 c0 01	 add	 rax, 1
  00419	48 89 84 24 78
	03 00 00	 mov	 QWORD PTR burnm$29220[rsp], rax
  00421	eb c3		 jmp	 SHORT $LN17@hmac_whirl
$LN16@hmac_whirl:
  00423	33 c0		 xor	 eax, eax
  00425	85 c0		 test	 eax, eax
  00427	75 96		 jne	 SHORT $LN20@hmac_whirl
$LN15@hmac_whirl:

; 525  : 	burn (iwhi, sizeof(iwhi));

  00429	48 8d 84 24 a0
	01 00 00	 lea	 rax, QWORD PTR iwhi$[rsp]
  00431	48 89 84 24 88
	03 00 00	 mov	 QWORD PTR burnm$29229[rsp], rax
  00439	c7 84 24 80 03
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$29231[rsp], 64 ; 00000040H
  00444	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00449	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR iwhi$[rsp]
  00451	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN12@hmac_whirl:
  00456	8b 8c 24 80 03
	00 00		 mov	 ecx, DWORD PTR burnc$29231[rsp]
  0045d	8b 84 24 80 03
	00 00		 mov	 eax, DWORD PTR burnc$29231[rsp]
  00464	83 e8 01	 sub	 eax, 1
  00467	89 84 24 80 03
	00 00		 mov	 DWORD PTR burnc$29231[rsp], eax
  0046e	85 c9		 test	 ecx, ecx
  00470	74 21		 je	 SHORT $LN11@hmac_whirl
  00472	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR burnm$29229[rsp]
  0047a	c6 00 00	 mov	 BYTE PTR [rax], 0
  0047d	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR burnm$29229[rsp]
  00485	48 83 c0 01	 add	 rax, 1
  00489	48 89 84 24 88
	03 00 00	 mov	 QWORD PTR burnm$29229[rsp], rax
  00491	eb c3		 jmp	 SHORT $LN12@hmac_whirl
$LN11@hmac_whirl:
  00493	33 c0		 xor	 eax, eax
  00495	85 c0		 test	 eax, eax
  00497	75 90		 jne	 SHORT $LN15@hmac_whirl
$LN10@hmac_whirl:

; 526  : 	burn (buf, sizeof(buf));

  00499	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  004a1	48 89 84 24 98
	03 00 00	 mov	 QWORD PTR burnm$29238[rsp], rax
  004a9	c7 84 24 90 03
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$29240[rsp], 64 ; 00000040H
  004b4	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  004b9	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  004c1	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN7@hmac_whirl:
  004c6	8b 8c 24 90 03
	00 00		 mov	 ecx, DWORD PTR burnc$29240[rsp]
  004cd	8b 84 24 90 03
	00 00		 mov	 eax, DWORD PTR burnc$29240[rsp]
  004d4	83 e8 01	 sub	 eax, 1
  004d7	89 84 24 90 03
	00 00		 mov	 DWORD PTR burnc$29240[rsp], eax
  004de	85 c9		 test	 ecx, ecx
  004e0	74 21		 je	 SHORT $LN6@hmac_whirl
  004e2	48 8b 84 24 98
	03 00 00	 mov	 rax, QWORD PTR burnm$29238[rsp]
  004ea	c6 00 00	 mov	 BYTE PTR [rax], 0
  004ed	48 8b 84 24 98
	03 00 00	 mov	 rax, QWORD PTR burnm$29238[rsp]
  004f5	48 83 c0 01	 add	 rax, 1
  004f9	48 89 84 24 98
	03 00 00	 mov	 QWORD PTR burnm$29238[rsp], rax
  00501	eb c3		 jmp	 SHORT $LN7@hmac_whirl
$LN6@hmac_whirl:
  00503	33 c0		 xor	 eax, eax
  00505	85 c0		 test	 eax, eax
  00507	75 90		 jne	 SHORT $LN10@hmac_whirl
$LN5@hmac_whirl:

; 527  : 	burn (key, sizeof(key));

  00509	48 8d 44 24 30	 lea	 rax, QWORD PTR key$[rsp]
  0050e	48 89 84 24 a8
	03 00 00	 mov	 QWORD PTR burnm$29247[rsp], rax
  00516	c7 84 24 a0 03
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$29249[rsp], 64 ; 00000040H
  00521	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00526	48 8d 4c 24 30	 lea	 rcx, QWORD PTR key$[rsp]
  0052b	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN2@hmac_whirl:
  00530	8b 8c 24 a0 03
	00 00		 mov	 ecx, DWORD PTR burnc$29249[rsp]
  00537	8b 84 24 a0 03
	00 00		 mov	 eax, DWORD PTR burnc$29249[rsp]
  0053e	83 e8 01	 sub	 eax, 1
  00541	89 84 24 a0 03
	00 00		 mov	 DWORD PTR burnc$29249[rsp], eax
  00548	85 c9		 test	 ecx, ecx
  0054a	74 21		 je	 SHORT $LN1@hmac_whirl
  0054c	48 8b 84 24 a8
	03 00 00	 mov	 rax, QWORD PTR burnm$29247[rsp]
  00554	c6 00 00	 mov	 BYTE PTR [rax], 0
  00557	48 8b 84 24 a8
	03 00 00	 mov	 rax, QWORD PTR burnm$29247[rsp]
  0055f	48 83 c0 01	 add	 rax, 1
  00563	48 89 84 24 a8
	03 00 00	 mov	 QWORD PTR burnm$29247[rsp], rax
  0056b	eb c3		 jmp	 SHORT $LN2@hmac_whirl
$LN1@hmac_whirl:
  0056d	33 c0		 xor	 eax, eax
  0056f	85 c0		 test	 eax, eax
  00571	75 96		 jne	 SHORT $LN5@hmac_whirl

; 528  : }

  00573	48 8b 8c 24 b8
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0057b	48 33 cc	 xor	 rcx, rsp
  0057e	e8 00 00 00 00	 call	 __security_check_cookie
  00583	48 81 c4 c8 03
	00 00		 add	 rsp, 968		; 000003c8H
  0058a	c3		 ret	 0
hmac_whirlpool ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	hmac_sha1
;	COMDAT pdata
pdata	SEGMENT
$pdata$hmac_sha1 DD imagerel $LN53
	DD	imagerel $LN53+1401
	DD	imagerel $unwind$hmac_sha1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$hmac_sha1 DD 022c19H
	DD	04d011aH
	DD	imagerel __GSHandlerCheck
	DD	0258H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT hmac_sha1
_TEXT	SEGMENT
i$ = 32
osha$ = 48
isha$ = 72
key$ = 96
buf$ = 128
ictx$ = 192
octx$ = 288
tctx$28830 = 384
burnc$28838 = 480
burnm$28836 = 488
burnc$28867 = 496
burnm$28865 = 504
burnc$28876 = 512
burnm$28874 = 520
burnc$28885 = 528
burnm$28883 = 536
burnc$28894 = 544
burnm$28892 = 552
burnc$28903 = 560
burnm$28901 = 568
burnc$28912 = 576
burnm$28910 = 584
tv154 = 592
__$ArrayPad$ = 600
k$ = 624
lk$ = 632
d$ = 640
ld$ = 648
out$ = 656
t$ = 664
hmac_sha1 PROC						; COMDAT

; 189  : {

$LN53:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 68 02
	00 00		 sub	 rsp, 616		; 00000268H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 58
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 190  : 	sha1_ctx ictx, octx;
; 191  : 	char isha[SHA1_DIGESTSIZE], osha[SHA1_DIGESTSIZE];
; 192  : 	char key[SHA1_DIGESTSIZE];
; 193  : 	char buf[SHA1_BLOCKSIZE];
; 194  : 	int i;
; 195  : 
; 196  :     /* If the key is longer than the hash algorithm block size,
; 197  : 	   let key = sha1(key), as per HMAC specifications. */
; 198  : 	if (lk > SHA1_BLOCKSIZE)

  0002c	83 bc 24 78 02
	00 00 40	 cmp	 DWORD PTR lk$[rsp], 64	; 00000040H
  00034	0f 8e c3 00 00
	00		 jle	 $LN48@hmac_sha1

; 199  : 	{
; 200  : 		sha1_ctx tctx;
; 201  : 
; 202  : 		sha1_begin (&tctx);

  0003a	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR tctx$28830[rsp]
  00042	e8 00 00 00 00	 call	 sha1_begin

; 203  : 		sha1_hash ((unsigned char *) k, lk, &tctx);

  00047	4c 8d 84 24 80
	01 00 00	 lea	 r8, QWORD PTR tctx$28830[rsp]
  0004f	8b 94 24 78 02
	00 00		 mov	 edx, DWORD PTR lk$[rsp]
  00056	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR k$[rsp]
  0005e	e8 00 00 00 00	 call	 sha1_hash

; 204  : 		sha1_end ((unsigned char *) key, &tctx);

  00063	48 8d 94 24 80
	01 00 00	 lea	 rdx, QWORD PTR tctx$28830[rsp]
  0006b	48 8d 4c 24 60	 lea	 rcx, QWORD PTR key$[rsp]
  00070	e8 00 00 00 00	 call	 sha1_end

; 205  : 
; 206  : 		k = key;

  00075	4c 8d 5c 24 60	 lea	 r11, QWORD PTR key$[rsp]
  0007a	4c 89 9c 24 70
	02 00 00	 mov	 QWORD PTR k$[rsp], r11

; 207  : 		lk = SHA1_DIGESTSIZE;

  00082	c7 84 24 78 02
	00 00 14 00 00
	00		 mov	 DWORD PTR lk$[rsp], 20
$LN47@hmac_sha1:

; 208  : 
; 209  : 		burn (&tctx, sizeof(tctx));		// Prevent leaks

  0008d	48 8d 84 24 80
	01 00 00	 lea	 rax, QWORD PTR tctx$28830[rsp]
  00095	48 89 84 24 e8
	01 00 00	 mov	 QWORD PTR burnm$28836[rsp], rax
  0009d	c7 84 24 e0 01
	00 00 5c 00 00
	00		 mov	 DWORD PTR burnc$28838[rsp], 92 ; 0000005cH
  000a8	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  000ad	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR tctx$28830[rsp]
  000b5	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN44@hmac_sha1:
  000ba	8b 8c 24 e0 01
	00 00		 mov	 ecx, DWORD PTR burnc$28838[rsp]
  000c1	8b 84 24 e0 01
	00 00		 mov	 eax, DWORD PTR burnc$28838[rsp]
  000c8	83 e8 01	 sub	 eax, 1
  000cb	89 84 24 e0 01
	00 00		 mov	 DWORD PTR burnc$28838[rsp], eax
  000d2	85 c9		 test	 ecx, ecx
  000d4	74 21		 je	 SHORT $LN43@hmac_sha1
  000d6	48 8b 84 24 e8
	01 00 00	 mov	 rax, QWORD PTR burnm$28836[rsp]
  000de	c6 00 00	 mov	 BYTE PTR [rax], 0
  000e1	48 8b 84 24 e8
	01 00 00	 mov	 rax, QWORD PTR burnm$28836[rsp]
  000e9	48 83 c0 01	 add	 rax, 1
  000ed	48 89 84 24 e8
	01 00 00	 mov	 QWORD PTR burnm$28836[rsp], rax
  000f5	eb c3		 jmp	 SHORT $LN44@hmac_sha1
$LN43@hmac_sha1:
  000f7	33 c0		 xor	 eax, eax
  000f9	85 c0		 test	 eax, eax
  000fb	75 90		 jne	 SHORT $LN47@hmac_sha1
$LN48@hmac_sha1:

; 210  : 	}
; 211  : 
; 212  : 	/**** Inner Digest ****/
; 213  : 
; 214  : 	sha1_begin (&ictx);

  000fd	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR ictx$[rsp]
  00105	e8 00 00 00 00	 call	 sha1_begin

; 215  : 
; 216  : 	/* Pad the key for inner digest */
; 217  : 	for (i = 0; i < lk; ++i)

  0010a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00112	eb 0b		 jmp	 SHORT $LN42@hmac_sha1
$LN41@hmac_sha1:
  00114	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00118	83 c0 01	 add	 eax, 1
  0011b	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN42@hmac_sha1:
  0011f	8b 84 24 78 02
	00 00		 mov	 eax, DWORD PTR lk$[rsp]
  00126	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0012a	7d 22		 jge	 SHORT $LN40@hmac_sha1

; 218  : 		buf[i] = (char) (k[i] ^ 0x36);

  0012c	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00131	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR k$[rsp]
  00139	0f be 0c 08	 movsx	 ecx, BYTE PTR [rax+rcx]
  0013d	83 f1 36	 xor	 ecx, 54			; 00000036H
  00140	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00145	88 8c 04 80 00
	00 00		 mov	 BYTE PTR buf$[rsp+rax], cl
  0014c	eb c6		 jmp	 SHORT $LN41@hmac_sha1
$LN40@hmac_sha1:

; 219  : 	for (i = lk; i < SHA1_BLOCKSIZE; ++i)

  0014e	8b 84 24 78 02
	00 00		 mov	 eax, DWORD PTR lk$[rsp]
  00155	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00159	eb 0b		 jmp	 SHORT $LN39@hmac_sha1
$LN38@hmac_sha1:
  0015b	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0015f	83 c0 01	 add	 eax, 1
  00162	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN39@hmac_sha1:
  00166	83 7c 24 20 40	 cmp	 DWORD PTR i$[rsp], 64	; 00000040H
  0016b	7d 0f		 jge	 SHORT $LN37@hmac_sha1

; 220  : 		buf[i] = 0x36;

  0016d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00172	c6 84 04 80 00
	00 00 36	 mov	 BYTE PTR buf$[rsp+rax], 54 ; 00000036H
  0017a	eb df		 jmp	 SHORT $LN38@hmac_sha1
$LN37@hmac_sha1:

; 221  : 
; 222  : 	sha1_hash ((unsigned char *) buf, SHA1_BLOCKSIZE, &ictx);

  0017c	4c 8d 84 24 c0
	00 00 00	 lea	 r8, QWORD PTR ictx$[rsp]
  00184	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00189	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00191	e8 00 00 00 00	 call	 sha1_hash

; 223  : 	sha1_hash ((unsigned char *) d, ld, &ictx);

  00196	4c 8d 84 24 c0
	00 00 00	 lea	 r8, QWORD PTR ictx$[rsp]
  0019e	8b 94 24 88 02
	00 00		 mov	 edx, DWORD PTR ld$[rsp]
  001a5	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR d$[rsp]
  001ad	e8 00 00 00 00	 call	 sha1_hash

; 224  : 
; 225  : 	sha1_end ((unsigned char *) isha, &ictx);

  001b2	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR ictx$[rsp]
  001ba	48 8d 4c 24 48	 lea	 rcx, QWORD PTR isha$[rsp]
  001bf	e8 00 00 00 00	 call	 sha1_end

; 226  : 
; 227  : 	/**** Outer Digest ****/
; 228  : 
; 229  : 	sha1_begin (&octx);

  001c4	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR octx$[rsp]
  001cc	e8 00 00 00 00	 call	 sha1_begin

; 230  : 
; 231  : 	for (i = 0; i < lk; ++i)

  001d1	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001d9	eb 0b		 jmp	 SHORT $LN36@hmac_sha1
$LN35@hmac_sha1:
  001db	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001df	83 c0 01	 add	 eax, 1
  001e2	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN36@hmac_sha1:
  001e6	8b 84 24 78 02
	00 00		 mov	 eax, DWORD PTR lk$[rsp]
  001ed	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  001f1	7d 22		 jge	 SHORT $LN34@hmac_sha1

; 232  : 		buf[i] = (char) (k[i] ^ 0x5C);

  001f3	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  001f8	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR k$[rsp]
  00200	0f be 0c 08	 movsx	 ecx, BYTE PTR [rax+rcx]
  00204	83 f1 5c	 xor	 ecx, 92			; 0000005cH
  00207	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0020c	88 8c 04 80 00
	00 00		 mov	 BYTE PTR buf$[rsp+rax], cl
  00213	eb c6		 jmp	 SHORT $LN35@hmac_sha1
$LN34@hmac_sha1:

; 233  : 	for (i = lk; i < SHA1_BLOCKSIZE; ++i)

  00215	8b 84 24 78 02
	00 00		 mov	 eax, DWORD PTR lk$[rsp]
  0021c	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00220	eb 0b		 jmp	 SHORT $LN33@hmac_sha1
$LN32@hmac_sha1:
  00222	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00226	83 c0 01	 add	 eax, 1
  00229	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN33@hmac_sha1:
  0022d	83 7c 24 20 40	 cmp	 DWORD PTR i$[rsp], 64	; 00000040H
  00232	7d 0f		 jge	 SHORT $LN31@hmac_sha1

; 234  : 		buf[i] = 0x5C;

  00234	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00239	c6 84 04 80 00
	00 00 5c	 mov	 BYTE PTR buf$[rsp+rax], 92 ; 0000005cH
  00241	eb df		 jmp	 SHORT $LN32@hmac_sha1
$LN31@hmac_sha1:

; 235  : 
; 236  : 	sha1_hash ((unsigned char *) buf, SHA1_BLOCKSIZE, &octx);

  00243	4c 8d 84 24 20
	01 00 00	 lea	 r8, QWORD PTR octx$[rsp]
  0024b	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00250	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00258	e8 00 00 00 00	 call	 sha1_hash

; 237  : 	sha1_hash ((unsigned char *) isha, SHA1_DIGESTSIZE, &octx);

  0025d	4c 8d 84 24 20
	01 00 00	 lea	 r8, QWORD PTR octx$[rsp]
  00265	ba 14 00 00 00	 mov	 edx, 20
  0026a	48 8d 4c 24 48	 lea	 rcx, QWORD PTR isha$[rsp]
  0026f	e8 00 00 00 00	 call	 sha1_hash

; 238  : 
; 239  : 	sha1_end ((unsigned char *) osha, &octx);

  00274	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR octx$[rsp]
  0027c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR osha$[rsp]
  00281	e8 00 00 00 00	 call	 sha1_end

; 240  : 
; 241  : 	/* truncate and print the results */
; 242  : 	t = t > SHA1_DIGESTSIZE ? SHA1_DIGESTSIZE : t;

  00286	83 bc 24 98 02
	00 00 14	 cmp	 DWORD PTR t$[rsp], 20
  0028e	7e 0d		 jle	 SHORT $LN51@hmac_sha1
  00290	c7 84 24 50 02
	00 00 14 00 00
	00		 mov	 DWORD PTR tv154[rsp], 20
  0029b	eb 0e		 jmp	 SHORT $LN52@hmac_sha1
$LN51@hmac_sha1:
  0029d	8b 84 24 98 02
	00 00		 mov	 eax, DWORD PTR t$[rsp]
  002a4	89 84 24 50 02
	00 00		 mov	 DWORD PTR tv154[rsp], eax
$LN52@hmac_sha1:
  002ab	8b 84 24 50 02
	00 00		 mov	 eax, DWORD PTR tv154[rsp]
  002b2	89 84 24 98 02
	00 00		 mov	 DWORD PTR t$[rsp], eax

; 243  : 	hmac_truncate (osha, out, t);

  002b9	44 8b 84 24 98
	02 00 00	 mov	 r8d, DWORD PTR t$[rsp]
  002c1	48 8b 94 24 90
	02 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  002c9	48 8d 4c 24 30	 lea	 rcx, QWORD PTR osha$[rsp]
  002ce	e8 00 00 00 00	 call	 hmac_truncate
$LN30@hmac_sha1:

; 244  : 
; 245  : 	/* Prevent leaks */
; 246  : 	burn (&ictx, sizeof(ictx));

  002d3	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR ictx$[rsp]
  002db	48 89 84 24 f8
	01 00 00	 mov	 QWORD PTR burnm$28865[rsp], rax
  002e3	c7 84 24 f0 01
	00 00 5c 00 00
	00		 mov	 DWORD PTR burnc$28867[rsp], 92 ; 0000005cH
  002ee	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  002f3	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR ictx$[rsp]
  002fb	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN27@hmac_sha1:
  00300	8b 8c 24 f0 01
	00 00		 mov	 ecx, DWORD PTR burnc$28867[rsp]
  00307	8b 84 24 f0 01
	00 00		 mov	 eax, DWORD PTR burnc$28867[rsp]
  0030e	83 e8 01	 sub	 eax, 1
  00311	89 84 24 f0 01
	00 00		 mov	 DWORD PTR burnc$28867[rsp], eax
  00318	85 c9		 test	 ecx, ecx
  0031a	74 21		 je	 SHORT $LN26@hmac_sha1
  0031c	48 8b 84 24 f8
	01 00 00	 mov	 rax, QWORD PTR burnm$28865[rsp]
  00324	c6 00 00	 mov	 BYTE PTR [rax], 0
  00327	48 8b 84 24 f8
	01 00 00	 mov	 rax, QWORD PTR burnm$28865[rsp]
  0032f	48 83 c0 01	 add	 rax, 1
  00333	48 89 84 24 f8
	01 00 00	 mov	 QWORD PTR burnm$28865[rsp], rax
  0033b	eb c3		 jmp	 SHORT $LN27@hmac_sha1
$LN26@hmac_sha1:
  0033d	33 c0		 xor	 eax, eax
  0033f	85 c0		 test	 eax, eax
  00341	75 90		 jne	 SHORT $LN30@hmac_sha1
$LN25@hmac_sha1:

; 247  : 	burn (&octx, sizeof(octx));

  00343	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR octx$[rsp]
  0034b	48 89 84 24 08
	02 00 00	 mov	 QWORD PTR burnm$28874[rsp], rax
  00353	c7 84 24 00 02
	00 00 5c 00 00
	00		 mov	 DWORD PTR burnc$28876[rsp], 92 ; 0000005cH
  0035e	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  00363	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR octx$[rsp]
  0036b	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN22@hmac_sha1:
  00370	8b 8c 24 00 02
	00 00		 mov	 ecx, DWORD PTR burnc$28876[rsp]
  00377	8b 84 24 00 02
	00 00		 mov	 eax, DWORD PTR burnc$28876[rsp]
  0037e	83 e8 01	 sub	 eax, 1
  00381	89 84 24 00 02
	00 00		 mov	 DWORD PTR burnc$28876[rsp], eax
  00388	85 c9		 test	 ecx, ecx
  0038a	74 21		 je	 SHORT $LN21@hmac_sha1
  0038c	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR burnm$28874[rsp]
  00394	c6 00 00	 mov	 BYTE PTR [rax], 0
  00397	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR burnm$28874[rsp]
  0039f	48 83 c0 01	 add	 rax, 1
  003a3	48 89 84 24 08
	02 00 00	 mov	 QWORD PTR burnm$28874[rsp], rax
  003ab	eb c3		 jmp	 SHORT $LN22@hmac_sha1
$LN21@hmac_sha1:
  003ad	33 c0		 xor	 eax, eax
  003af	85 c0		 test	 eax, eax
  003b1	75 90		 jne	 SHORT $LN25@hmac_sha1
$LN20@hmac_sha1:

; 248  : 	burn (isha, sizeof(isha));

  003b3	48 8d 44 24 48	 lea	 rax, QWORD PTR isha$[rsp]
  003b8	48 89 84 24 18
	02 00 00	 mov	 QWORD PTR burnm$28883[rsp], rax
  003c0	c7 84 24 10 02
	00 00 14 00 00
	00		 mov	 DWORD PTR burnc$28885[rsp], 20
  003cb	ba 14 00 00 00	 mov	 edx, 20
  003d0	48 8d 4c 24 48	 lea	 rcx, QWORD PTR isha$[rsp]
  003d5	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN17@hmac_sha1:
  003da	8b 8c 24 10 02
	00 00		 mov	 ecx, DWORD PTR burnc$28885[rsp]
  003e1	8b 84 24 10 02
	00 00		 mov	 eax, DWORD PTR burnc$28885[rsp]
  003e8	83 e8 01	 sub	 eax, 1
  003eb	89 84 24 10 02
	00 00		 mov	 DWORD PTR burnc$28885[rsp], eax
  003f2	85 c9		 test	 ecx, ecx
  003f4	74 21		 je	 SHORT $LN16@hmac_sha1
  003f6	48 8b 84 24 18
	02 00 00	 mov	 rax, QWORD PTR burnm$28883[rsp]
  003fe	c6 00 00	 mov	 BYTE PTR [rax], 0
  00401	48 8b 84 24 18
	02 00 00	 mov	 rax, QWORD PTR burnm$28883[rsp]
  00409	48 83 c0 01	 add	 rax, 1
  0040d	48 89 84 24 18
	02 00 00	 mov	 QWORD PTR burnm$28883[rsp], rax
  00415	eb c3		 jmp	 SHORT $LN17@hmac_sha1
$LN16@hmac_sha1:
  00417	33 c0		 xor	 eax, eax
  00419	85 c0		 test	 eax, eax
  0041b	75 96		 jne	 SHORT $LN20@hmac_sha1
$LN15@hmac_sha1:

; 249  : 	burn (osha, sizeof(osha));

  0041d	48 8d 44 24 30	 lea	 rax, QWORD PTR osha$[rsp]
  00422	48 89 84 24 28
	02 00 00	 mov	 QWORD PTR burnm$28892[rsp], rax
  0042a	c7 84 24 20 02
	00 00 14 00 00
	00		 mov	 DWORD PTR burnc$28894[rsp], 20
  00435	ba 14 00 00 00	 mov	 edx, 20
  0043a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR osha$[rsp]
  0043f	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN12@hmac_sha1:
  00444	8b 8c 24 20 02
	00 00		 mov	 ecx, DWORD PTR burnc$28894[rsp]
  0044b	8b 84 24 20 02
	00 00		 mov	 eax, DWORD PTR burnc$28894[rsp]
  00452	83 e8 01	 sub	 eax, 1
  00455	89 84 24 20 02
	00 00		 mov	 DWORD PTR burnc$28894[rsp], eax
  0045c	85 c9		 test	 ecx, ecx
  0045e	74 21		 je	 SHORT $LN11@hmac_sha1
  00460	48 8b 84 24 28
	02 00 00	 mov	 rax, QWORD PTR burnm$28892[rsp]
  00468	c6 00 00	 mov	 BYTE PTR [rax], 0
  0046b	48 8b 84 24 28
	02 00 00	 mov	 rax, QWORD PTR burnm$28892[rsp]
  00473	48 83 c0 01	 add	 rax, 1
  00477	48 89 84 24 28
	02 00 00	 mov	 QWORD PTR burnm$28892[rsp], rax
  0047f	eb c3		 jmp	 SHORT $LN12@hmac_sha1
$LN11@hmac_sha1:
  00481	33 c0		 xor	 eax, eax
  00483	85 c0		 test	 eax, eax
  00485	75 96		 jne	 SHORT $LN15@hmac_sha1
$LN10@hmac_sha1:

; 250  : 	burn (buf, sizeof(buf));

  00487	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  0048f	48 89 84 24 38
	02 00 00	 mov	 QWORD PTR burnm$28901[rsp], rax
  00497	c7 84 24 30 02
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$28903[rsp], 64 ; 00000040H
  004a2	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  004a7	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  004af	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN7@hmac_sha1:
  004b4	8b 8c 24 30 02
	00 00		 mov	 ecx, DWORD PTR burnc$28903[rsp]
  004bb	8b 84 24 30 02
	00 00		 mov	 eax, DWORD PTR burnc$28903[rsp]
  004c2	83 e8 01	 sub	 eax, 1
  004c5	89 84 24 30 02
	00 00		 mov	 DWORD PTR burnc$28903[rsp], eax
  004cc	85 c9		 test	 ecx, ecx
  004ce	74 21		 je	 SHORT $LN6@hmac_sha1
  004d0	48 8b 84 24 38
	02 00 00	 mov	 rax, QWORD PTR burnm$28901[rsp]
  004d8	c6 00 00	 mov	 BYTE PTR [rax], 0
  004db	48 8b 84 24 38
	02 00 00	 mov	 rax, QWORD PTR burnm$28901[rsp]
  004e3	48 83 c0 01	 add	 rax, 1
  004e7	48 89 84 24 38
	02 00 00	 mov	 QWORD PTR burnm$28901[rsp], rax
  004ef	eb c3		 jmp	 SHORT $LN7@hmac_sha1
$LN6@hmac_sha1:
  004f1	33 c0		 xor	 eax, eax
  004f3	85 c0		 test	 eax, eax
  004f5	75 90		 jne	 SHORT $LN10@hmac_sha1
$LN5@hmac_sha1:

; 251  : 	burn (key, sizeof(key));

  004f7	48 8d 44 24 60	 lea	 rax, QWORD PTR key$[rsp]
  004fc	48 89 84 24 48
	02 00 00	 mov	 QWORD PTR burnm$28910[rsp], rax
  00504	c7 84 24 40 02
	00 00 14 00 00
	00		 mov	 DWORD PTR burnc$28912[rsp], 20
  0050f	ba 14 00 00 00	 mov	 edx, 20
  00514	48 8d 4c 24 60	 lea	 rcx, QWORD PTR key$[rsp]
  00519	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN2@hmac_sha1:
  0051e	8b 8c 24 40 02
	00 00		 mov	 ecx, DWORD PTR burnc$28912[rsp]
  00525	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR burnc$28912[rsp]
  0052c	83 e8 01	 sub	 eax, 1
  0052f	89 84 24 40 02
	00 00		 mov	 DWORD PTR burnc$28912[rsp], eax
  00536	85 c9		 test	 ecx, ecx
  00538	74 21		 je	 SHORT $LN1@hmac_sha1
  0053a	48 8b 84 24 48
	02 00 00	 mov	 rax, QWORD PTR burnm$28910[rsp]
  00542	c6 00 00	 mov	 BYTE PTR [rax], 0
  00545	48 8b 84 24 48
	02 00 00	 mov	 rax, QWORD PTR burnm$28910[rsp]
  0054d	48 83 c0 01	 add	 rax, 1
  00551	48 89 84 24 48
	02 00 00	 mov	 QWORD PTR burnm$28910[rsp], rax
  00559	eb c3		 jmp	 SHORT $LN2@hmac_sha1
$LN1@hmac_sha1:
  0055b	33 c0		 xor	 eax, eax
  0055d	85 c0		 test	 eax, eax
  0055f	75 96		 jne	 SHORT $LN5@hmac_sha1

; 252  : }

  00561	48 8b 8c 24 58
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00569	48 33 cc	 xor	 rcx, rsp
  0056c	e8 00 00 00 00	 call	 __security_check_cookie
  00571	48 81 c4 68 02
	00 00		 add	 rsp, 616		; 00000268H
  00578	c3		 ret	 0
hmac_sha1 ENDP
PUBLIC	__$ArrayPad$
PUBLIC	derive_u_whirlpool
;	COMDAT pdata
pdata	SEGMENT
$pdata$derive_u_whirlpool DD imagerel $LN19
	DD	imagerel $LN19+664
	DD	imagerel $unwind$derive_u_whirlpool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$derive_u_whirlpool DD 042e19H
	DD	033011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	0180H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT derive_u_whirlpool
_TEXT	SEGMENT
i$ = 48
init$ = 64
counter$ = 192
k$ = 208
c$ = 272
j$ = 288
burnc$29286 = 352
burnm$29284 = 360
burnc$29295 = 368
burnm$29293 = 376
__$ArrayPad$ = 384
pwd$ = 432
pwd_len$ = 440
salt$ = 448
salt_len$ = 456
iterations$ = 464
u$ = 472
b$ = 480
derive_u_whirlpool PROC					; COMDAT

; 531  : {

$LN19:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec 98 01
	00 00		 sub	 rsp, 408		; 00000198H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 532  : 	char j[WHIRLPOOL_DIGESTSIZE], k[WHIRLPOOL_DIGESTSIZE];
; 533  : 	char init[128];
; 534  : 	char counter[4];
; 535  : 	int c, i;
; 536  : 
; 537  : 	/* iteration 1 */
; 538  : 	memset (counter, 0, 4);

  0002e	48 8d bc 24 c0
	00 00 00	 lea	 rdi, QWORD PTR counter$[rsp]
  00036	33 c0		 xor	 eax, eax
  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	f3 aa		 rep stosb

; 539  : 	counter[3] = (char) b;

  0003f	0f b6 84 24 e0
	01 00 00	 movzx	 eax, BYTE PTR b$[rsp]
  00047	88 84 24 c3 00
	00 00		 mov	 BYTE PTR counter$[rsp+3], al

; 540  : 	memcpy (init, salt, salt_len);	/* salt */

  0004e	48 63 8c 24 c8
	01 00 00	 movsxd	 rcx, DWORD PTR salt_len$[rsp]
  00056	48 8d 7c 24 40	 lea	 rdi, QWORD PTR init$[rsp]
  0005b	48 8b b4 24 c0
	01 00 00	 mov	 rsi, QWORD PTR salt$[rsp]
  00063	f3 a4		 rep movsb

; 541  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */

  00065	48 63 94 24 c8
	01 00 00	 movsxd	 rdx, DWORD PTR salt_len$[rsp]
  0006d	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR counter$[rsp]
  00074	89 44 14 40	 mov	 DWORD PTR init$[rsp+rdx], eax

; 542  : 	hmac_whirlpool (pwd, pwd_len, init, salt_len + 4, j, WHIRLPOOL_DIGESTSIZE);

  00078	44 8b 8c 24 c8
	01 00 00	 mov	 r9d, DWORD PTR salt_len$[rsp]
  00080	41 83 c1 04	 add	 r9d, 4
  00084	c7 44 24 28 40
	00 00 00	 mov	 DWORD PTR [rsp+40], 64	; 00000040H
  0008c	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR j$[rsp]
  00094	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00099	4c 8d 44 24 40	 lea	 r8, QWORD PTR init$[rsp]
  0009e	8b 94 24 b8 01
	00 00		 mov	 edx, DWORD PTR pwd_len$[rsp]
  000a5	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR pwd$[rsp]
  000ad	e8 00 00 00 00	 call	 hmac_whirlpool

; 543  : 	memcpy (u, j, WHIRLPOOL_DIGESTSIZE);

  000b2	48 8d b4 24 20
	01 00 00	 lea	 rsi, QWORD PTR j$[rsp]
  000ba	48 8b bc 24 d8
	01 00 00	 mov	 rdi, QWORD PTR u$[rsp]
  000c2	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000c7	f3 a4		 rep movsb

; 544  : 
; 545  : 	/* remaining iterations */
; 546  : 	for (c = 1; c < iterations; c++)

  000c9	c7 84 24 10 01
	00 00 01 00 00
	00		 mov	 DWORD PTR c$[rsp], 1
  000d4	eb 11		 jmp	 SHORT $LN16@derive_u_w
$LN15@derive_u_w:
  000d6	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR c$[rsp]
  000dd	83 c0 01	 add	 eax, 1
  000e0	89 84 24 10 01
	00 00		 mov	 DWORD PTR c$[rsp], eax
$LN16@derive_u_w:
  000e7	8b 84 24 d0 01
	00 00		 mov	 eax, DWORD PTR iterations$[rsp]
  000ee	39 84 24 10 01
	00 00		 cmp	 DWORD PTR c$[rsp], eax
  000f5	0f 8d a3 00 00
	00		 jge	 $LN14@derive_u_w

; 547  : 	{
; 548  : 		hmac_whirlpool (pwd, pwd_len, j, WHIRLPOOL_DIGESTSIZE, k, WHIRLPOOL_DIGESTSIZE);

  000fb	c7 44 24 28 40
	00 00 00	 mov	 DWORD PTR [rsp+40], 64	; 00000040H
  00103	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR k$[rsp]
  0010b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00110	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  00116	4c 8d 84 24 20
	01 00 00	 lea	 r8, QWORD PTR j$[rsp]
  0011e	8b 94 24 b8 01
	00 00		 mov	 edx, DWORD PTR pwd_len$[rsp]
  00125	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR pwd$[rsp]
  0012d	e8 00 00 00 00	 call	 hmac_whirlpool

; 549  : 		for (i = 0; i < WHIRLPOOL_DIGESTSIZE; i++)

  00132	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0013a	eb 0b		 jmp	 SHORT $LN13@derive_u_w
$LN12@derive_u_w:
  0013c	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00140	83 c0 01	 add	 eax, 1
  00143	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN13@derive_u_w:
  00147	83 7c 24 30 40	 cmp	 DWORD PTR i$[rsp], 64	; 00000040H
  0014c	7d 4b		 jge	 SHORT $LN11@derive_u_w

; 550  : 		{
; 551  : 			u[i] ^= k[i];

  0014e	48 63 54 24 30	 movsxd	 rdx, DWORD PTR i$[rsp]
  00153	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00158	0f be 8c 04 d0
	00 00 00	 movsx	 ecx, BYTE PTR k$[rsp+rax]
  00160	48 8b 84 24 d8
	01 00 00	 mov	 rax, QWORD PTR u$[rsp]
  00168	0f be 14 10	 movsx	 edx, BYTE PTR [rax+rdx]
  0016c	33 d1		 xor	 edx, ecx
  0016e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00173	48 8b 84 24 d8
	01 00 00	 mov	 rax, QWORD PTR u$[rsp]
  0017b	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 552  : 			j[i] = k[i];

  0017e	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00183	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00188	0f b6 84 04 d0
	00 00 00	 movzx	 eax, BYTE PTR k$[rsp+rax]
  00190	88 84 0c 20 01
	00 00		 mov	 BYTE PTR j$[rsp+rcx], al

; 553  : 		}

  00197	eb a3		 jmp	 SHORT $LN12@derive_u_w
$LN11@derive_u_w:

; 554  : 	}

  00199	e9 38 ff ff ff	 jmp	 $LN15@derive_u_w
$LN14@derive_u_w:
$LN10@derive_u_w:

; 555  : 
; 556  : 	/* Prevent possible leaks. */
; 557  : 	burn (j, sizeof(j));

  0019e	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR j$[rsp]
  001a6	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR burnm$29284[rsp], rax
  001ae	c7 84 24 60 01
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$29286[rsp], 64 ; 00000040H
  001b9	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001be	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR j$[rsp]
  001c6	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN7@derive_u_w:
  001cb	8b 8c 24 60 01
	00 00		 mov	 ecx, DWORD PTR burnc$29286[rsp]
  001d2	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR burnc$29286[rsp]
  001d9	83 e8 01	 sub	 eax, 1
  001dc	89 84 24 60 01
	00 00		 mov	 DWORD PTR burnc$29286[rsp], eax
  001e3	85 c9		 test	 ecx, ecx
  001e5	74 21		 je	 SHORT $LN6@derive_u_w
  001e7	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR burnm$29284[rsp]
  001ef	c6 00 00	 mov	 BYTE PTR [rax], 0
  001f2	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR burnm$29284[rsp]
  001fa	48 83 c0 01	 add	 rax, 1
  001fe	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR burnm$29284[rsp], rax
  00206	eb c3		 jmp	 SHORT $LN7@derive_u_w
$LN6@derive_u_w:
  00208	33 c0		 xor	 eax, eax
  0020a	85 c0		 test	 eax, eax
  0020c	75 90		 jne	 SHORT $LN10@derive_u_w
$LN5@derive_u_w:

; 558  : 	burn (k, sizeof(k));

  0020e	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR k$[rsp]
  00216	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR burnm$29293[rsp], rax
  0021e	c7 84 24 70 01
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$29295[rsp], 64 ; 00000040H
  00229	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0022e	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR k$[rsp]
  00236	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN2@derive_u_w:
  0023b	8b 8c 24 70 01
	00 00		 mov	 ecx, DWORD PTR burnc$29295[rsp]
  00242	8b 84 24 70 01
	00 00		 mov	 eax, DWORD PTR burnc$29295[rsp]
  00249	83 e8 01	 sub	 eax, 1
  0024c	89 84 24 70 01
	00 00		 mov	 DWORD PTR burnc$29295[rsp], eax
  00253	85 c9		 test	 ecx, ecx
  00255	74 21		 je	 SHORT $LN1@derive_u_w
  00257	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR burnm$29293[rsp]
  0025f	c6 00 00	 mov	 BYTE PTR [rax], 0
  00262	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR burnm$29293[rsp]
  0026a	48 83 c0 01	 add	 rax, 1
  0026e	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR burnm$29293[rsp], rax
  00276	eb c3		 jmp	 SHORT $LN2@derive_u_w
$LN1@derive_u_w:
  00278	33 c0		 xor	 eax, eax
  0027a	85 c0		 test	 eax, eax
  0027c	75 90		 jne	 SHORT $LN5@derive_u_w

; 559  : }

  0027e	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00286	48 33 cc	 xor	 rcx, rsp
  00289	e8 00 00 00 00	 call	 __security_check_cookie
  0028e	48 81 c4 98 01
	00 00		 add	 rsp, 408		; 00000198H
  00295	5f		 pop	 rdi
  00296	5e		 pop	 rsi
  00297	c3		 ret	 0
derive_u_whirlpool ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	derive_u_sha1
;	COMDAT pdata
pdata	SEGMENT
$pdata$derive_u_sha1 DD imagerel $LN19
	DD	imagerel $LN19+664
	DD	imagerel $unwind$derive_u_sha1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$derive_u_sha1 DD 042e19H
	DD	027011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	0120H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT derive_u_sha1
_TEXT	SEGMENT
i$ = 48
init$ = 64
counter$ = 192
k$ = 200
c$ = 224
j$ = 232
burnc$28949 = 256
burnm$28947 = 264
burnc$28958 = 272
burnm$28956 = 280
__$ArrayPad$ = 288
pwd$ = 336
pwd_len$ = 344
salt$ = 352
salt_len$ = 360
iterations$ = 368
u$ = 376
b$ = 384
derive_u_sha1 PROC					; COMDAT

; 257  : {

$LN19:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 258  : 	char j[SHA1_DIGESTSIZE], k[SHA1_DIGESTSIZE];
; 259  : 	char init[128];
; 260  : 	char counter[4];
; 261  : 	int c, i;
; 262  : 
; 263  : 	/* iteration 1 */
; 264  : 	memset (counter, 0, 4);

  0002e	48 8d bc 24 c0
	00 00 00	 lea	 rdi, QWORD PTR counter$[rsp]
  00036	33 c0		 xor	 eax, eax
  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	f3 aa		 rep stosb

; 265  : 	counter[3] = (char) b;

  0003f	0f b6 84 24 80
	01 00 00	 movzx	 eax, BYTE PTR b$[rsp]
  00047	88 84 24 c3 00
	00 00		 mov	 BYTE PTR counter$[rsp+3], al

; 266  : 	memcpy (init, salt, salt_len);	/* salt */

  0004e	48 63 8c 24 68
	01 00 00	 movsxd	 rcx, DWORD PTR salt_len$[rsp]
  00056	48 8d 7c 24 40	 lea	 rdi, QWORD PTR init$[rsp]
  0005b	48 8b b4 24 60
	01 00 00	 mov	 rsi, QWORD PTR salt$[rsp]
  00063	f3 a4		 rep movsb

; 267  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */

  00065	48 63 94 24 68
	01 00 00	 movsxd	 rdx, DWORD PTR salt_len$[rsp]
  0006d	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR counter$[rsp]
  00074	89 44 14 40	 mov	 DWORD PTR init$[rsp+rdx], eax

; 268  : 	hmac_sha1 (pwd, pwd_len, init, salt_len + 4, j, SHA1_DIGESTSIZE);

  00078	44 8b 8c 24 68
	01 00 00	 mov	 r9d, DWORD PTR salt_len$[rsp]
  00080	41 83 c1 04	 add	 r9d, 4
  00084	c7 44 24 28 14
	00 00 00	 mov	 DWORD PTR [rsp+40], 20
  0008c	48 8d 84 24 e8
	00 00 00	 lea	 rax, QWORD PTR j$[rsp]
  00094	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00099	4c 8d 44 24 40	 lea	 r8, QWORD PTR init$[rsp]
  0009e	8b 94 24 58 01
	00 00		 mov	 edx, DWORD PTR pwd_len$[rsp]
  000a5	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pwd$[rsp]
  000ad	e8 00 00 00 00	 call	 hmac_sha1

; 269  : 	memcpy (u, j, SHA1_DIGESTSIZE);

  000b2	48 8d b4 24 e8
	00 00 00	 lea	 rsi, QWORD PTR j$[rsp]
  000ba	48 8b bc 24 78
	01 00 00	 mov	 rdi, QWORD PTR u$[rsp]
  000c2	b9 14 00 00 00	 mov	 ecx, 20
  000c7	f3 a4		 rep movsb

; 270  : 
; 271  : 	/* remaining iterations */
; 272  : 	for (c = 1; c < iterations; c++)

  000c9	c7 84 24 e0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR c$[rsp], 1
  000d4	eb 11		 jmp	 SHORT $LN16@derive_u_s
$LN15@derive_u_s:
  000d6	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR c$[rsp]
  000dd	83 c0 01	 add	 eax, 1
  000e0	89 84 24 e0 00
	00 00		 mov	 DWORD PTR c$[rsp], eax
$LN16@derive_u_s:
  000e7	8b 84 24 70 01
	00 00		 mov	 eax, DWORD PTR iterations$[rsp]
  000ee	39 84 24 e0 00
	00 00		 cmp	 DWORD PTR c$[rsp], eax
  000f5	0f 8d a3 00 00
	00		 jge	 $LN14@derive_u_s

; 273  : 	{
; 274  : 		hmac_sha1 (pwd, pwd_len, j, SHA1_DIGESTSIZE, k, SHA1_DIGESTSIZE);

  000fb	c7 44 24 28 14
	00 00 00	 mov	 DWORD PTR [rsp+40], 20
  00103	48 8d 84 24 c8
	00 00 00	 lea	 rax, QWORD PTR k$[rsp]
  0010b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00110	41 b9 14 00 00
	00		 mov	 r9d, 20
  00116	4c 8d 84 24 e8
	00 00 00	 lea	 r8, QWORD PTR j$[rsp]
  0011e	8b 94 24 58 01
	00 00		 mov	 edx, DWORD PTR pwd_len$[rsp]
  00125	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pwd$[rsp]
  0012d	e8 00 00 00 00	 call	 hmac_sha1

; 275  : 		for (i = 0; i < SHA1_DIGESTSIZE; i++)

  00132	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0013a	eb 0b		 jmp	 SHORT $LN13@derive_u_s
$LN12@derive_u_s:
  0013c	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00140	83 c0 01	 add	 eax, 1
  00143	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN13@derive_u_s:
  00147	83 7c 24 30 14	 cmp	 DWORD PTR i$[rsp], 20
  0014c	7d 4b		 jge	 SHORT $LN11@derive_u_s

; 276  : 		{
; 277  : 			u[i] ^= k[i];

  0014e	48 63 54 24 30	 movsxd	 rdx, DWORD PTR i$[rsp]
  00153	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00158	0f be 8c 04 c8
	00 00 00	 movsx	 ecx, BYTE PTR k$[rsp+rax]
  00160	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR u$[rsp]
  00168	0f be 14 10	 movsx	 edx, BYTE PTR [rax+rdx]
  0016c	33 d1		 xor	 edx, ecx
  0016e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00173	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR u$[rsp]
  0017b	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 278  : 			j[i] = k[i];

  0017e	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00183	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00188	0f b6 84 04 c8
	00 00 00	 movzx	 eax, BYTE PTR k$[rsp+rax]
  00190	88 84 0c e8 00
	00 00		 mov	 BYTE PTR j$[rsp+rcx], al

; 279  : 		}

  00197	eb a3		 jmp	 SHORT $LN12@derive_u_s
$LN11@derive_u_s:

; 280  : 	}

  00199	e9 38 ff ff ff	 jmp	 $LN15@derive_u_s
$LN14@derive_u_s:
$LN10@derive_u_s:

; 281  : 
; 282  : 	/* Prevent possible leaks. */
; 283  : 	burn (j, sizeof(j));

  0019e	48 8d 84 24 e8
	00 00 00	 lea	 rax, QWORD PTR j$[rsp]
  001a6	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR burnm$28947[rsp], rax
  001ae	c7 84 24 00 01
	00 00 14 00 00
	00		 mov	 DWORD PTR burnc$28949[rsp], 20
  001b9	ba 14 00 00 00	 mov	 edx, 20
  001be	48 8d 8c 24 e8
	00 00 00	 lea	 rcx, QWORD PTR j$[rsp]
  001c6	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN7@derive_u_s:
  001cb	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR burnc$28949[rsp]
  001d2	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR burnc$28949[rsp]
  001d9	83 e8 01	 sub	 eax, 1
  001dc	89 84 24 00 01
	00 00		 mov	 DWORD PTR burnc$28949[rsp], eax
  001e3	85 c9		 test	 ecx, ecx
  001e5	74 21		 je	 SHORT $LN6@derive_u_s
  001e7	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR burnm$28947[rsp]
  001ef	c6 00 00	 mov	 BYTE PTR [rax], 0
  001f2	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR burnm$28947[rsp]
  001fa	48 83 c0 01	 add	 rax, 1
  001fe	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR burnm$28947[rsp], rax
  00206	eb c3		 jmp	 SHORT $LN7@derive_u_s
$LN6@derive_u_s:
  00208	33 c0		 xor	 eax, eax
  0020a	85 c0		 test	 eax, eax
  0020c	75 90		 jne	 SHORT $LN10@derive_u_s
$LN5@derive_u_s:

; 284  : 	burn (k, sizeof(k));

  0020e	48 8d 84 24 c8
	00 00 00	 lea	 rax, QWORD PTR k$[rsp]
  00216	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR burnm$28956[rsp], rax
  0021e	c7 84 24 10 01
	00 00 14 00 00
	00		 mov	 DWORD PTR burnc$28958[rsp], 20
  00229	ba 14 00 00 00	 mov	 edx, 20
  0022e	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR k$[rsp]
  00236	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN2@derive_u_s:
  0023b	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR burnc$28958[rsp]
  00242	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR burnc$28958[rsp]
  00249	83 e8 01	 sub	 eax, 1
  0024c	89 84 24 10 01
	00 00		 mov	 DWORD PTR burnc$28958[rsp], eax
  00253	85 c9		 test	 ecx, ecx
  00255	74 21		 je	 SHORT $LN1@derive_u_s
  00257	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR burnm$28956[rsp]
  0025f	c6 00 00	 mov	 BYTE PTR [rax], 0
  00262	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR burnm$28956[rsp]
  0026a	48 83 c0 01	 add	 rax, 1
  0026e	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR burnm$28956[rsp], rax
  00276	eb c3		 jmp	 SHORT $LN2@derive_u_s
$LN1@derive_u_s:
  00278	33 c0		 xor	 eax, eax
  0027a	85 c0		 test	 eax, eax
  0027c	75 90		 jne	 SHORT $LN5@derive_u_s

; 285  : }

  0027e	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00286	48 33 cc	 xor	 rcx, rsp
  00289	e8 00 00 00 00	 call	 __security_check_cookie
  0028e	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  00295	5f		 pop	 rdi
  00296	5e		 pop	 rsi
  00297	c3		 ret	 0
derive_u_sha1 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	hmac_sha512
;	COMDAT pdata
pdata	SEGMENT
$pdata$hmac_sha512 DD imagerel $LN53
	DD	imagerel $LN53+1422
	DD	imagerel $unwind$hmac_sha512
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$hmac_sha512 DD 022c19H
	DD	08d011aH
	DD	imagerel __GSHandlerCheck
	DD	0458H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT hmac_sha512
_TEXT	SEGMENT
i$ = 32
osha$ = 48
isha$ = 112
key$ = 176
buf$ = 240
ictx$ = 368
octx$ = 576
tctx$28644 = 784
burnc$28652 = 992
burnm$28650 = 1000
burnc$28681 = 1008
burnm$28679 = 1016
burnc$28690 = 1024
burnm$28688 = 1032
burnc$28699 = 1040
burnm$28697 = 1048
burnc$28708 = 1056
burnm$28706 = 1064
burnc$28717 = 1072
burnm$28715 = 1080
burnc$28726 = 1088
burnm$28724 = 1096
tv154 = 1104
__$ArrayPad$ = 1112
k$ = 1136
lk$ = 1144
d$ = 1152
ld$ = 1160
out$ = 1168
t$ = 1176
hmac_sha512 PROC					; COMDAT

; 47   : {

$LN53:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 68 04
	00 00		 sub	 rsp, 1128		; 00000468H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 58
	04 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 48   : 	sha512_ctx ictx, octx;
; 49   : 	char isha[SHA512_DIGESTSIZE], osha[SHA512_DIGESTSIZE];
; 50   : 	char key[SHA512_DIGESTSIZE];
; 51   : 	char buf[SHA512_BLOCKSIZE];
; 52   : 	int i;
; 53   : 
; 54   :     /* If the key is longer than the hash algorithm block size,
; 55   : 	   let key = sha512(key), as per HMAC specifications. */
; 56   : 	if (lk > SHA512_BLOCKSIZE)

  0002c	81 bc 24 78 04
	00 00 80 00 00
	00		 cmp	 DWORD PTR lk$[rsp], 128	; 00000080H
  00037	0f 8e c9 00 00
	00		 jle	 $LN48@hmac_sha51

; 57   : 	{
; 58   : 		sha512_ctx tctx;
; 59   : 
; 60   : 		sha512_begin (&tctx);

  0003d	48 8d 8c 24 10
	03 00 00	 lea	 rcx, QWORD PTR tctx$28644[rsp]
  00045	e8 00 00 00 00	 call	 sha512_begin

; 61   : 		sha512_hash ((unsigned char *) k, lk, &tctx);

  0004a	4c 8d 84 24 10
	03 00 00	 lea	 r8, QWORD PTR tctx$28644[rsp]
  00052	8b 94 24 78 04
	00 00		 mov	 edx, DWORD PTR lk$[rsp]
  00059	48 8b 8c 24 70
	04 00 00	 mov	 rcx, QWORD PTR k$[rsp]
  00061	e8 00 00 00 00	 call	 sha512_hash

; 62   : 		sha512_end ((unsigned char *) key, &tctx);

  00066	48 8d 94 24 10
	03 00 00	 lea	 rdx, QWORD PTR tctx$28644[rsp]
  0006e	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR key$[rsp]
  00076	e8 00 00 00 00	 call	 sha512_end

; 63   : 
; 64   : 		k = key;

  0007b	4c 8d 9c 24 b0
	00 00 00	 lea	 r11, QWORD PTR key$[rsp]
  00083	4c 89 9c 24 70
	04 00 00	 mov	 QWORD PTR k$[rsp], r11

; 65   : 		lk = SHA512_DIGESTSIZE;

  0008b	c7 84 24 78 04
	00 00 40 00 00
	00		 mov	 DWORD PTR lk$[rsp], 64	; 00000040H
$LN47@hmac_sha51:

; 66   : 
; 67   : 		burn (&tctx, sizeof(tctx));		// Prevent leaks

  00096	48 8d 84 24 10
	03 00 00	 lea	 rax, QWORD PTR tctx$28644[rsp]
  0009e	48 89 84 24 e8
	03 00 00	 mov	 QWORD PTR burnm$28650[rsp], rax
  000a6	c7 84 24 e0 03
	00 00 d0 00 00
	00		 mov	 DWORD PTR burnc$28652[rsp], 208 ; 000000d0H
  000b1	ba d0 00 00 00	 mov	 edx, 208		; 000000d0H
  000b6	48 8d 8c 24 10
	03 00 00	 lea	 rcx, QWORD PTR tctx$28644[rsp]
  000be	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN44@hmac_sha51:
  000c3	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR burnc$28652[rsp]
  000ca	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR burnc$28652[rsp]
  000d1	83 e8 01	 sub	 eax, 1
  000d4	89 84 24 e0 03
	00 00		 mov	 DWORD PTR burnc$28652[rsp], eax
  000db	85 c9		 test	 ecx, ecx
  000dd	74 21		 je	 SHORT $LN43@hmac_sha51
  000df	48 8b 84 24 e8
	03 00 00	 mov	 rax, QWORD PTR burnm$28650[rsp]
  000e7	c6 00 00	 mov	 BYTE PTR [rax], 0
  000ea	48 8b 84 24 e8
	03 00 00	 mov	 rax, QWORD PTR burnm$28650[rsp]
  000f2	48 83 c0 01	 add	 rax, 1
  000f6	48 89 84 24 e8
	03 00 00	 mov	 QWORD PTR burnm$28650[rsp], rax
  000fe	eb c3		 jmp	 SHORT $LN44@hmac_sha51
$LN43@hmac_sha51:
  00100	33 c0		 xor	 eax, eax
  00102	85 c0		 test	 eax, eax
  00104	75 90		 jne	 SHORT $LN47@hmac_sha51
$LN48@hmac_sha51:

; 68   : 	}
; 69   : 
; 70   : 	/**** Inner Digest ****/
; 71   : 
; 72   : 	sha512_begin (&ictx);

  00106	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR ictx$[rsp]
  0010e	e8 00 00 00 00	 call	 sha512_begin

; 73   : 
; 74   : 	/* Pad the key for inner digest */
; 75   : 	for (i = 0; i < lk; ++i)

  00113	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0011b	eb 0b		 jmp	 SHORT $LN42@hmac_sha51
$LN41@hmac_sha51:
  0011d	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00121	83 c0 01	 add	 eax, 1
  00124	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN42@hmac_sha51:
  00128	8b 84 24 78 04
	00 00		 mov	 eax, DWORD PTR lk$[rsp]
  0012f	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00133	7d 22		 jge	 SHORT $LN40@hmac_sha51

; 76   : 		buf[i] = (char) (k[i] ^ 0x36);

  00135	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0013a	48 8b 84 24 70
	04 00 00	 mov	 rax, QWORD PTR k$[rsp]
  00142	0f be 0c 08	 movsx	 ecx, BYTE PTR [rax+rcx]
  00146	83 f1 36	 xor	 ecx, 54			; 00000036H
  00149	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0014e	88 8c 04 f0 00
	00 00		 mov	 BYTE PTR buf$[rsp+rax], cl
  00155	eb c6		 jmp	 SHORT $LN41@hmac_sha51
$LN40@hmac_sha51:

; 77   : 	for (i = lk; i < SHA512_BLOCKSIZE; ++i)

  00157	8b 84 24 78 04
	00 00		 mov	 eax, DWORD PTR lk$[rsp]
  0015e	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00162	eb 0b		 jmp	 SHORT $LN39@hmac_sha51
$LN38@hmac_sha51:
  00164	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00168	83 c0 01	 add	 eax, 1
  0016b	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN39@hmac_sha51:
  0016f	81 7c 24 20 80
	00 00 00	 cmp	 DWORD PTR i$[rsp], 128	; 00000080H
  00177	7d 0f		 jge	 SHORT $LN37@hmac_sha51

; 78   : 		buf[i] = 0x36;

  00179	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0017e	c6 84 04 f0 00
	00 00 36	 mov	 BYTE PTR buf$[rsp+rax], 54 ; 00000036H
  00186	eb dc		 jmp	 SHORT $LN38@hmac_sha51
$LN37@hmac_sha51:

; 79   : 
; 80   : 	sha512_hash ((unsigned char *) buf, SHA512_BLOCKSIZE, &ictx);

  00188	4c 8d 84 24 70
	01 00 00	 lea	 r8, QWORD PTR ictx$[rsp]
  00190	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00195	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0019d	e8 00 00 00 00	 call	 sha512_hash

; 81   : 	sha512_hash ((unsigned char *) d, ld, &ictx);

  001a2	4c 8d 84 24 70
	01 00 00	 lea	 r8, QWORD PTR ictx$[rsp]
  001aa	8b 94 24 88 04
	00 00		 mov	 edx, DWORD PTR ld$[rsp]
  001b1	48 8b 8c 24 80
	04 00 00	 mov	 rcx, QWORD PTR d$[rsp]
  001b9	e8 00 00 00 00	 call	 sha512_hash

; 82   : 
; 83   : 	sha512_end ((unsigned char *) isha, &ictx);

  001be	48 8d 94 24 70
	01 00 00	 lea	 rdx, QWORD PTR ictx$[rsp]
  001c6	48 8d 4c 24 70	 lea	 rcx, QWORD PTR isha$[rsp]
  001cb	e8 00 00 00 00	 call	 sha512_end

; 84   : 
; 85   : 	/**** Outer Digest ****/
; 86   : 
; 87   : 	sha512_begin (&octx);

  001d0	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR octx$[rsp]
  001d8	e8 00 00 00 00	 call	 sha512_begin

; 88   : 
; 89   : 	for (i = 0; i < lk; ++i)

  001dd	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001e5	eb 0b		 jmp	 SHORT $LN36@hmac_sha51
$LN35@hmac_sha51:
  001e7	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001eb	83 c0 01	 add	 eax, 1
  001ee	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN36@hmac_sha51:
  001f2	8b 84 24 78 04
	00 00		 mov	 eax, DWORD PTR lk$[rsp]
  001f9	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  001fd	7d 22		 jge	 SHORT $LN34@hmac_sha51

; 90   : 		buf[i] = (char) (k[i] ^ 0x5C);

  001ff	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00204	48 8b 84 24 70
	04 00 00	 mov	 rax, QWORD PTR k$[rsp]
  0020c	0f be 0c 08	 movsx	 ecx, BYTE PTR [rax+rcx]
  00210	83 f1 5c	 xor	 ecx, 92			; 0000005cH
  00213	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00218	88 8c 04 f0 00
	00 00		 mov	 BYTE PTR buf$[rsp+rax], cl
  0021f	eb c6		 jmp	 SHORT $LN35@hmac_sha51
$LN34@hmac_sha51:

; 91   : 	for (i = lk; i < SHA512_BLOCKSIZE; ++i)

  00221	8b 84 24 78 04
	00 00		 mov	 eax, DWORD PTR lk$[rsp]
  00228	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0022c	eb 0b		 jmp	 SHORT $LN33@hmac_sha51
$LN32@hmac_sha51:
  0022e	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00232	83 c0 01	 add	 eax, 1
  00235	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN33@hmac_sha51:
  00239	81 7c 24 20 80
	00 00 00	 cmp	 DWORD PTR i$[rsp], 128	; 00000080H
  00241	7d 0f		 jge	 SHORT $LN31@hmac_sha51

; 92   : 		buf[i] = 0x5C;

  00243	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00248	c6 84 04 f0 00
	00 00 5c	 mov	 BYTE PTR buf$[rsp+rax], 92 ; 0000005cH
  00250	eb dc		 jmp	 SHORT $LN32@hmac_sha51
$LN31@hmac_sha51:

; 93   : 
; 94   : 	sha512_hash ((unsigned char *) buf, SHA512_BLOCKSIZE, &octx);

  00252	4c 8d 84 24 40
	02 00 00	 lea	 r8, QWORD PTR octx$[rsp]
  0025a	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0025f	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00267	e8 00 00 00 00	 call	 sha512_hash

; 95   : 	sha512_hash ((unsigned char *) isha, SHA512_DIGESTSIZE, &octx);

  0026c	4c 8d 84 24 40
	02 00 00	 lea	 r8, QWORD PTR octx$[rsp]
  00274	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00279	48 8d 4c 24 70	 lea	 rcx, QWORD PTR isha$[rsp]
  0027e	e8 00 00 00 00	 call	 sha512_hash

; 96   : 
; 97   : 	sha512_end ((unsigned char *) osha, &octx);

  00283	48 8d 94 24 40
	02 00 00	 lea	 rdx, QWORD PTR octx$[rsp]
  0028b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR osha$[rsp]
  00290	e8 00 00 00 00	 call	 sha512_end

; 98   : 
; 99   : 	/* truncate and print the results */
; 100  : 	t = t > SHA512_DIGESTSIZE ? SHA512_DIGESTSIZE : t;

  00295	83 bc 24 98 04
	00 00 40	 cmp	 DWORD PTR t$[rsp], 64	; 00000040H
  0029d	7e 0d		 jle	 SHORT $LN51@hmac_sha51
  0029f	c7 84 24 50 04
	00 00 40 00 00
	00		 mov	 DWORD PTR tv154[rsp], 64 ; 00000040H
  002aa	eb 0e		 jmp	 SHORT $LN52@hmac_sha51
$LN51@hmac_sha51:
  002ac	8b 84 24 98 04
	00 00		 mov	 eax, DWORD PTR t$[rsp]
  002b3	89 84 24 50 04
	00 00		 mov	 DWORD PTR tv154[rsp], eax
$LN52@hmac_sha51:
  002ba	8b 84 24 50 04
	00 00		 mov	 eax, DWORD PTR tv154[rsp]
  002c1	89 84 24 98 04
	00 00		 mov	 DWORD PTR t$[rsp], eax

; 101  : 	hmac_truncate (osha, out, t);

  002c8	44 8b 84 24 98
	04 00 00	 mov	 r8d, DWORD PTR t$[rsp]
  002d0	48 8b 94 24 90
	04 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  002d8	48 8d 4c 24 30	 lea	 rcx, QWORD PTR osha$[rsp]
  002dd	e8 00 00 00 00	 call	 hmac_truncate
$LN30@hmac_sha51:

; 102  : 
; 103  : 	/* Prevent leaks */
; 104  : 	burn (&ictx, sizeof(ictx));

  002e2	48 8d 84 24 70
	01 00 00	 lea	 rax, QWORD PTR ictx$[rsp]
  002ea	48 89 84 24 f8
	03 00 00	 mov	 QWORD PTR burnm$28679[rsp], rax
  002f2	c7 84 24 f0 03
	00 00 d0 00 00
	00		 mov	 DWORD PTR burnc$28681[rsp], 208 ; 000000d0H
  002fd	ba d0 00 00 00	 mov	 edx, 208		; 000000d0H
  00302	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR ictx$[rsp]
  0030a	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN27@hmac_sha51:
  0030f	8b 8c 24 f0 03
	00 00		 mov	 ecx, DWORD PTR burnc$28681[rsp]
  00316	8b 84 24 f0 03
	00 00		 mov	 eax, DWORD PTR burnc$28681[rsp]
  0031d	83 e8 01	 sub	 eax, 1
  00320	89 84 24 f0 03
	00 00		 mov	 DWORD PTR burnc$28681[rsp], eax
  00327	85 c9		 test	 ecx, ecx
  00329	74 21		 je	 SHORT $LN26@hmac_sha51
  0032b	48 8b 84 24 f8
	03 00 00	 mov	 rax, QWORD PTR burnm$28679[rsp]
  00333	c6 00 00	 mov	 BYTE PTR [rax], 0
  00336	48 8b 84 24 f8
	03 00 00	 mov	 rax, QWORD PTR burnm$28679[rsp]
  0033e	48 83 c0 01	 add	 rax, 1
  00342	48 89 84 24 f8
	03 00 00	 mov	 QWORD PTR burnm$28679[rsp], rax
  0034a	eb c3		 jmp	 SHORT $LN27@hmac_sha51
$LN26@hmac_sha51:
  0034c	33 c0		 xor	 eax, eax
  0034e	85 c0		 test	 eax, eax
  00350	75 90		 jne	 SHORT $LN30@hmac_sha51
$LN25@hmac_sha51:

; 105  : 	burn (&octx, sizeof(octx));

  00352	48 8d 84 24 40
	02 00 00	 lea	 rax, QWORD PTR octx$[rsp]
  0035a	48 89 84 24 08
	04 00 00	 mov	 QWORD PTR burnm$28688[rsp], rax
  00362	c7 84 24 00 04
	00 00 d0 00 00
	00		 mov	 DWORD PTR burnc$28690[rsp], 208 ; 000000d0H
  0036d	ba d0 00 00 00	 mov	 edx, 208		; 000000d0H
  00372	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR octx$[rsp]
  0037a	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN22@hmac_sha51:
  0037f	8b 8c 24 00 04
	00 00		 mov	 ecx, DWORD PTR burnc$28690[rsp]
  00386	8b 84 24 00 04
	00 00		 mov	 eax, DWORD PTR burnc$28690[rsp]
  0038d	83 e8 01	 sub	 eax, 1
  00390	89 84 24 00 04
	00 00		 mov	 DWORD PTR burnc$28690[rsp], eax
  00397	85 c9		 test	 ecx, ecx
  00399	74 21		 je	 SHORT $LN21@hmac_sha51
  0039b	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR burnm$28688[rsp]
  003a3	c6 00 00	 mov	 BYTE PTR [rax], 0
  003a6	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR burnm$28688[rsp]
  003ae	48 83 c0 01	 add	 rax, 1
  003b2	48 89 84 24 08
	04 00 00	 mov	 QWORD PTR burnm$28688[rsp], rax
  003ba	eb c3		 jmp	 SHORT $LN22@hmac_sha51
$LN21@hmac_sha51:
  003bc	33 c0		 xor	 eax, eax
  003be	85 c0		 test	 eax, eax
  003c0	75 90		 jne	 SHORT $LN25@hmac_sha51
$LN20@hmac_sha51:

; 106  : 	burn (isha, sizeof(isha));

  003c2	48 8d 44 24 70	 lea	 rax, QWORD PTR isha$[rsp]
  003c7	48 89 84 24 18
	04 00 00	 mov	 QWORD PTR burnm$28697[rsp], rax
  003cf	c7 84 24 10 04
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$28699[rsp], 64 ; 00000040H
  003da	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  003df	48 8d 4c 24 70	 lea	 rcx, QWORD PTR isha$[rsp]
  003e4	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN17@hmac_sha51:
  003e9	8b 8c 24 10 04
	00 00		 mov	 ecx, DWORD PTR burnc$28699[rsp]
  003f0	8b 84 24 10 04
	00 00		 mov	 eax, DWORD PTR burnc$28699[rsp]
  003f7	83 e8 01	 sub	 eax, 1
  003fa	89 84 24 10 04
	00 00		 mov	 DWORD PTR burnc$28699[rsp], eax
  00401	85 c9		 test	 ecx, ecx
  00403	74 21		 je	 SHORT $LN16@hmac_sha51
  00405	48 8b 84 24 18
	04 00 00	 mov	 rax, QWORD PTR burnm$28697[rsp]
  0040d	c6 00 00	 mov	 BYTE PTR [rax], 0
  00410	48 8b 84 24 18
	04 00 00	 mov	 rax, QWORD PTR burnm$28697[rsp]
  00418	48 83 c0 01	 add	 rax, 1
  0041c	48 89 84 24 18
	04 00 00	 mov	 QWORD PTR burnm$28697[rsp], rax
  00424	eb c3		 jmp	 SHORT $LN17@hmac_sha51
$LN16@hmac_sha51:
  00426	33 c0		 xor	 eax, eax
  00428	85 c0		 test	 eax, eax
  0042a	75 96		 jne	 SHORT $LN20@hmac_sha51
$LN15@hmac_sha51:

; 107  : 	burn (osha, sizeof(osha));

  0042c	48 8d 44 24 30	 lea	 rax, QWORD PTR osha$[rsp]
  00431	48 89 84 24 28
	04 00 00	 mov	 QWORD PTR burnm$28706[rsp], rax
  00439	c7 84 24 20 04
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$28708[rsp], 64 ; 00000040H
  00444	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00449	48 8d 4c 24 30	 lea	 rcx, QWORD PTR osha$[rsp]
  0044e	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN12@hmac_sha51:
  00453	8b 8c 24 20 04
	00 00		 mov	 ecx, DWORD PTR burnc$28708[rsp]
  0045a	8b 84 24 20 04
	00 00		 mov	 eax, DWORD PTR burnc$28708[rsp]
  00461	83 e8 01	 sub	 eax, 1
  00464	89 84 24 20 04
	00 00		 mov	 DWORD PTR burnc$28708[rsp], eax
  0046b	85 c9		 test	 ecx, ecx
  0046d	74 21		 je	 SHORT $LN11@hmac_sha51
  0046f	48 8b 84 24 28
	04 00 00	 mov	 rax, QWORD PTR burnm$28706[rsp]
  00477	c6 00 00	 mov	 BYTE PTR [rax], 0
  0047a	48 8b 84 24 28
	04 00 00	 mov	 rax, QWORD PTR burnm$28706[rsp]
  00482	48 83 c0 01	 add	 rax, 1
  00486	48 89 84 24 28
	04 00 00	 mov	 QWORD PTR burnm$28706[rsp], rax
  0048e	eb c3		 jmp	 SHORT $LN12@hmac_sha51
$LN11@hmac_sha51:
  00490	33 c0		 xor	 eax, eax
  00492	85 c0		 test	 eax, eax
  00494	75 96		 jne	 SHORT $LN15@hmac_sha51
$LN10@hmac_sha51:

; 108  : 	burn (buf, sizeof(buf));

  00496	48 8d 84 24 f0
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  0049e	48 89 84 24 38
	04 00 00	 mov	 QWORD PTR burnm$28715[rsp], rax
  004a6	c7 84 24 30 04
	00 00 80 00 00
	00		 mov	 DWORD PTR burnc$28717[rsp], 128 ; 00000080H
  004b1	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  004b6	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  004be	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN7@hmac_sha51:
  004c3	8b 8c 24 30 04
	00 00		 mov	 ecx, DWORD PTR burnc$28717[rsp]
  004ca	8b 84 24 30 04
	00 00		 mov	 eax, DWORD PTR burnc$28717[rsp]
  004d1	83 e8 01	 sub	 eax, 1
  004d4	89 84 24 30 04
	00 00		 mov	 DWORD PTR burnc$28717[rsp], eax
  004db	85 c9		 test	 ecx, ecx
  004dd	74 21		 je	 SHORT $LN6@hmac_sha51
  004df	48 8b 84 24 38
	04 00 00	 mov	 rax, QWORD PTR burnm$28715[rsp]
  004e7	c6 00 00	 mov	 BYTE PTR [rax], 0
  004ea	48 8b 84 24 38
	04 00 00	 mov	 rax, QWORD PTR burnm$28715[rsp]
  004f2	48 83 c0 01	 add	 rax, 1
  004f6	48 89 84 24 38
	04 00 00	 mov	 QWORD PTR burnm$28715[rsp], rax
  004fe	eb c3		 jmp	 SHORT $LN7@hmac_sha51
$LN6@hmac_sha51:
  00500	33 c0		 xor	 eax, eax
  00502	85 c0		 test	 eax, eax
  00504	75 90		 jne	 SHORT $LN10@hmac_sha51
$LN5@hmac_sha51:

; 109  : 	burn (key, sizeof(key));

  00506	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR key$[rsp]
  0050e	48 89 84 24 48
	04 00 00	 mov	 QWORD PTR burnm$28724[rsp], rax
  00516	c7 84 24 40 04
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$28726[rsp], 64 ; 00000040H
  00521	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00526	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR key$[rsp]
  0052e	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN2@hmac_sha51:
  00533	8b 8c 24 40 04
	00 00		 mov	 ecx, DWORD PTR burnc$28726[rsp]
  0053a	8b 84 24 40 04
	00 00		 mov	 eax, DWORD PTR burnc$28726[rsp]
  00541	83 e8 01	 sub	 eax, 1
  00544	89 84 24 40 04
	00 00		 mov	 DWORD PTR burnc$28726[rsp], eax
  0054b	85 c9		 test	 ecx, ecx
  0054d	74 21		 je	 SHORT $LN1@hmac_sha51
  0054f	48 8b 84 24 48
	04 00 00	 mov	 rax, QWORD PTR burnm$28724[rsp]
  00557	c6 00 00	 mov	 BYTE PTR [rax], 0
  0055a	48 8b 84 24 48
	04 00 00	 mov	 rax, QWORD PTR burnm$28724[rsp]
  00562	48 83 c0 01	 add	 rax, 1
  00566	48 89 84 24 48
	04 00 00	 mov	 QWORD PTR burnm$28724[rsp], rax
  0056e	eb c3		 jmp	 SHORT $LN2@hmac_sha51
$LN1@hmac_sha51:
  00570	33 c0		 xor	 eax, eax
  00572	85 c0		 test	 eax, eax
  00574	75 90		 jne	 SHORT $LN5@hmac_sha51

; 110  : }

  00576	48 8b 8c 24 58
	04 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0057e	48 33 cc	 xor	 rcx, rsp
  00581	e8 00 00 00 00	 call	 __security_check_cookie
  00586	48 81 c4 68 04
	00 00		 add	 rsp, 1128		; 00000468H
  0058d	c3		 ret	 0
hmac_sha512 ENDP
PUBLIC	__$ArrayPad$
PUBLIC	derive_key_whirlpool
;	COMDAT pdata
pdata	SEGMENT
$pdata$derive_key_whirlpool DD imagerel $LN13
	DD	imagerel $LN13+530
	DD	imagerel $unwind$derive_key_whirlpool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$derive_key_whirlpool DD 042e19H
	DD	017011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT derive_key_whirlpool
_TEXT	SEGMENT
u$ = 80
b$ = 144
l$ = 148
r$ = 152
burnc$29328 = 156
burnm$29326 = 160
__$ArrayPad$ = 168
pwd$ = 208
pwd_len$ = 216
salt$ = 224
salt_len$ = 232
iterations$ = 240
dk$ = 248
dklen$ = 256
derive_key_whirlpool PROC				; COMDAT

; 562  : {

$LN13:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 563  : 	char u[WHIRLPOOL_DIGESTSIZE];
; 564  : 	int b, l, r;
; 565  : 
; 566  : 	if (dklen % WHIRLPOOL_DIGESTSIZE)

  0002e	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR dklen$[rsp]
  00035	99		 cdq
  00036	83 e2 3f	 and	 edx, 63			; 0000003fH
  00039	03 c2		 add	 eax, edx
  0003b	83 e0 3f	 and	 eax, 63			; 0000003fH
  0003e	2b c2		 sub	 eax, edx
  00040	85 c0		 test	 eax, eax
  00042	74 1c		 je	 SHORT $LN10@derive_key

; 567  : 	{
; 568  : 		l = 1 + dklen / WHIRLPOOL_DIGESTSIZE;

  00044	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR dklen$[rsp]
  0004b	99		 cdq
  0004c	83 e2 3f	 and	 edx, 63			; 0000003fH
  0004f	03 c2		 add	 eax, edx
  00051	c1 f8 06	 sar	 eax, 6
  00054	83 c0 01	 add	 eax, 1
  00057	89 84 24 94 00
	00 00		 mov	 DWORD PTR l$[rsp], eax

; 569  : 	}
; 570  : 	else

  0005e	eb 17		 jmp	 SHORT $LN9@derive_key
$LN10@derive_key:

; 571  : 	{
; 572  : 		l = dklen / WHIRLPOOL_DIGESTSIZE;

  00060	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR dklen$[rsp]
  00067	99		 cdq
  00068	83 e2 3f	 and	 edx, 63			; 0000003fH
  0006b	03 c2		 add	 eax, edx
  0006d	c1 f8 06	 sar	 eax, 6
  00070	89 84 24 94 00
	00 00		 mov	 DWORD PTR l$[rsp], eax
$LN9@derive_key:

; 573  : 	}
; 574  : 
; 575  : 	r = dklen - (l - 1) * WHIRLPOOL_DIGESTSIZE;

  00077	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR l$[rsp]
  0007e	83 e9 01	 sub	 ecx, 1
  00081	6b c9 40	 imul	 ecx, 64			; 00000040H
  00084	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR dklen$[rsp]
  0008b	2b c1		 sub	 eax, ecx
  0008d	89 84 24 98 00
	00 00		 mov	 DWORD PTR r$[rsp], eax

; 576  : 
; 577  : 	/* first l - 1 blocks */
; 578  : 	for (b = 1; b < l; b++)

  00094	c7 84 24 90 00
	00 00 01 00 00
	00		 mov	 DWORD PTR b$[rsp], 1
  0009f	eb 11		 jmp	 SHORT $LN8@derive_key
$LN7@derive_key:
  000a1	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR b$[rsp]
  000a8	83 c0 01	 add	 eax, 1
  000ab	89 84 24 90 00
	00 00		 mov	 DWORD PTR b$[rsp], eax
$LN8@derive_key:
  000b2	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR l$[rsp]
  000b9	39 84 24 90 00
	00 00		 cmp	 DWORD PTR b$[rsp], eax
  000c0	7d 71		 jge	 SHORT $LN6@derive_key

; 579  : 	{
; 580  : 		derive_u_whirlpool (pwd, pwd_len, salt, salt_len, iterations, u, b);

  000c2	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR b$[rsp]
  000c9	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000cd	48 8d 44 24 50	 lea	 rax, QWORD PTR u$[rsp]
  000d2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000d7	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR iterations$[rsp]
  000de	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000e2	44 8b 8c 24 e8
	00 00 00	 mov	 r9d, DWORD PTR salt_len$[rsp]
  000ea	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR salt$[rsp]
  000f2	8b 94 24 d8 00
	00 00		 mov	 edx, DWORD PTR pwd_len$[rsp]
  000f9	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pwd$[rsp]
  00101	e8 00 00 00 00	 call	 derive_u_whirlpool

; 581  : 		memcpy (dk, u, WHIRLPOOL_DIGESTSIZE);

  00106	48 8d 74 24 50	 lea	 rsi, QWORD PTR u$[rsp]
  0010b	48 8b bc 24 f8
	00 00 00	 mov	 rdi, QWORD PTR dk$[rsp]
  00113	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00118	f3 a4		 rep movsb

; 582  : 		dk += WHIRLPOOL_DIGESTSIZE;

  0011a	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR dk$[rsp]
  00122	48 83 c0 40	 add	 rax, 64			; 00000040H
  00126	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR dk$[rsp], rax

; 583  : 	}

  0012e	e9 6e ff ff ff	 jmp	 $LN7@derive_key
$LN6@derive_key:

; 584  : 
; 585  : 	/* last block */
; 586  : 	derive_u_whirlpool (pwd, pwd_len, salt, salt_len, iterations, u, b);

  00133	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR b$[rsp]
  0013a	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0013e	48 8d 44 24 50	 lea	 rax, QWORD PTR u$[rsp]
  00143	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00148	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR iterations$[rsp]
  0014f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00153	44 8b 8c 24 e8
	00 00 00	 mov	 r9d, DWORD PTR salt_len$[rsp]
  0015b	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR salt$[rsp]
  00163	8b 94 24 d8 00
	00 00		 mov	 edx, DWORD PTR pwd_len$[rsp]
  0016a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pwd$[rsp]
  00172	e8 00 00 00 00	 call	 derive_u_whirlpool

; 587  : 	memcpy (dk, u, r);

  00177	48 63 8c 24 98
	00 00 00	 movsxd	 rcx, DWORD PTR r$[rsp]
  0017f	48 8d 74 24 50	 lea	 rsi, QWORD PTR u$[rsp]
  00184	48 8b bc 24 f8
	00 00 00	 mov	 rdi, QWORD PTR dk$[rsp]
  0018c	f3 a4		 rep movsb
$LN5@derive_key:

; 588  : 
; 589  : 
; 590  : 	/* Prevent possible leaks. */
; 591  : 	burn (u, sizeof(u));

  0018e	48 8d 44 24 50	 lea	 rax, QWORD PTR u$[rsp]
  00193	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR burnm$29326[rsp], rax
  0019b	c7 84 24 9c 00
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$29328[rsp], 64 ; 00000040H
  001a6	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001ab	48 8d 4c 24 50	 lea	 rcx, QWORD PTR u$[rsp]
  001b0	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN2@derive_key:
  001b5	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR burnc$29328[rsp]
  001bc	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR burnc$29328[rsp]
  001c3	83 e8 01	 sub	 eax, 1
  001c6	89 84 24 9c 00
	00 00		 mov	 DWORD PTR burnc$29328[rsp], eax
  001cd	85 c9		 test	 ecx, ecx
  001cf	74 21		 je	 SHORT $LN1@derive_key
  001d1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR burnm$29326[rsp]
  001d9	c6 00 00	 mov	 BYTE PTR [rax], 0
  001dc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR burnm$29326[rsp]
  001e4	48 83 c0 01	 add	 rax, 1
  001e8	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR burnm$29326[rsp], rax
  001f0	eb c3		 jmp	 SHORT $LN2@derive_key
$LN1@derive_key:
  001f2	33 c0		 xor	 eax, eax
  001f4	85 c0		 test	 eax, eax
  001f6	75 96		 jne	 SHORT $LN5@derive_key

; 592  : }

  001f8	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00200	48 33 cc	 xor	 rcx, rsp
  00203	e8 00 00 00 00	 call	 __security_check_cookie
  00208	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0020f	5f		 pop	 rdi
  00210	5e		 pop	 rsi
  00211	c3		 ret	 0
derive_key_whirlpool ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	hmac_ripemd160
;	COMDAT pdata
pdata	SEGMENT
$pdata$hmac_ripemd160 DD imagerel $LN32
	DD	imagerel $LN32+1058
	DD	imagerel $unwind$hmac_ripemd160
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$hmac_ripemd160 DD 032d19H
	DD	042011bH
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	0200H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT hmac_ripemd160
_TEXT	SEGMENT
i$ = 32
k_opad$ = 48
tk$ = 128
k_ipad$ = 160
context$ = 240
tctx$29012 = 336
burnc$29020 = 432
burnm$29018 = 440
burnc$29036 = 448
burnm$29034 = 456
burnc$29045 = 464
burnm$29043 = 472
burnc$29054 = 480
burnm$29052 = 488
burnc$29063 = 496
burnm$29061 = 504
__$ArrayPad$ = 512
key$ = 544
keylen$ = 552
input$ = 560
len$ = 568
digest$ = 576
hmac_ripemd160 PROC					; COMDAT

; 325  : {

$LN32:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 81 ec 10 02
	00 00		 sub	 rsp, 528		; 00000210H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 00
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 326  :     RMD160_CTX context;
; 327  :     unsigned char k_ipad[65];  /* inner padding - key XORd with ipad */
; 328  :     unsigned char k_opad[65];  /* outer padding - key XORd with opad */
; 329  :     unsigned char tk[RIPEMD160_DIGESTSIZE];
; 330  :     int i;
; 331  : 
; 332  :     /* If the key is longer than the hash algorithm block size,
; 333  : 	   let key = ripemd160(key), as per HMAC specifications. */
; 334  :     if (keylen > RIPEMD160_BLOCKSIZE) 

  0002d	83 bc 24 28 02
	00 00 40	 cmp	 DWORD PTR keylen$[rsp], 64 ; 00000040H
  00035	0f 8e ca 00 00
	00		 jle	 $LN29@hmac_ripem

; 335  : 	{
; 336  :         RMD160_CTX      tctx;
; 337  : 
; 338  :         RMD160Init(&tctx);

  0003b	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR tctx$29012[rsp]
  00043	e8 00 00 00 00	 call	 RMD160Init

; 339  :         RMD160Update(&tctx, (const unsigned char *) key, keylen);

  00048	44 8b 84 24 28
	02 00 00	 mov	 r8d, DWORD PTR keylen$[rsp]
  00050	48 8b 94 24 20
	02 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  00058	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR tctx$29012[rsp]
  00060	e8 00 00 00 00	 call	 RMD160Update

; 340  :         RMD160Final(tk, &tctx);

  00065	48 8d 94 24 50
	01 00 00	 lea	 rdx, QWORD PTR tctx$29012[rsp]
  0006d	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR tk$[rsp]
  00075	e8 00 00 00 00	 call	 RMD160Final

; 341  : 
; 342  :         key = (char *) tk;

  0007a	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR tk$[rsp]
  00082	48 89 94 24 20
	02 00 00	 mov	 QWORD PTR key$[rsp], rdx

; 343  :         keylen = RIPEMD160_DIGESTSIZE;

  0008a	c7 84 24 28 02
	00 00 14 00 00
	00		 mov	 DWORD PTR keylen$[rsp], 20
$LN28@hmac_ripem:

; 344  : 
; 345  : 		burn (&tctx, sizeof(tctx));	// Prevent leaks

  00095	48 8d 84 24 50
	01 00 00	 lea	 rax, QWORD PTR tctx$29012[rsp]
  0009d	48 89 84 24 b8
	01 00 00	 mov	 QWORD PTR burnm$29018[rsp], rax
  000a5	c7 84 24 b0 01
	00 00 60 00 00
	00		 mov	 DWORD PTR burnc$29020[rsp], 96 ; 00000060H
  000b0	ba 60 00 00 00	 mov	 edx, 96			; 00000060H
  000b5	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR tctx$29012[rsp]
  000bd	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN25@hmac_ripem:
  000c2	8b 8c 24 b0 01
	00 00		 mov	 ecx, DWORD PTR burnc$29020[rsp]
  000c9	8b 84 24 b0 01
	00 00		 mov	 eax, DWORD PTR burnc$29020[rsp]
  000d0	83 e8 01	 sub	 eax, 1
  000d3	89 84 24 b0 01
	00 00		 mov	 DWORD PTR burnc$29020[rsp], eax
  000da	85 c9		 test	 ecx, ecx
  000dc	74 21		 je	 SHORT $LN24@hmac_ripem
  000de	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR burnm$29018[rsp]
  000e6	c6 00 00	 mov	 BYTE PTR [rax], 0
  000e9	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR burnm$29018[rsp]
  000f1	48 83 c0 01	 add	 rax, 1
  000f5	48 89 84 24 b8
	01 00 00	 mov	 QWORD PTR burnm$29018[rsp], rax
  000fd	eb c3		 jmp	 SHORT $LN25@hmac_ripem
$LN24@hmac_ripem:
  000ff	33 c0		 xor	 eax, eax
  00101	85 c0		 test	 eax, eax
  00103	75 90		 jne	 SHORT $LN28@hmac_ripem
$LN29@hmac_ripem:

; 346  :     }
; 347  : 
; 348  : 	/*
; 349  : 
; 350  : 	RMD160(K XOR opad, RMD160(K XOR ipad, text))
; 351  : 
; 352  : 	where K is an n byte key
; 353  : 	ipad is the byte 0x36 repeated RIPEMD160_BLOCKSIZE times
; 354  : 	opad is the byte 0x5c repeated RIPEMD160_BLOCKSIZE times
; 355  : 	and text is the data being protected */
; 356  : 
; 357  : 
; 358  : 	/* start out by storing key in pads */
; 359  : 	memset(k_ipad, 0x36, sizeof(k_ipad));

  00105	48 8d bc 24 a0
	00 00 00	 lea	 rdi, QWORD PTR k_ipad$[rsp]
  0010d	b8 36 00 00 00	 mov	 eax, 54			; 00000036H
  00112	b9 41 00 00 00	 mov	 ecx, 65			; 00000041H
  00117	f3 aa		 rep stosb

; 360  :     memset(k_opad, 0x5c, sizeof(k_opad));

  00119	48 8d 7c 24 30	 lea	 rdi, QWORD PTR k_opad$[rsp]
  0011e	b8 5c 00 00 00	 mov	 eax, 92			; 0000005cH
  00123	b9 41 00 00 00	 mov	 ecx, 65			; 00000041H
  00128	f3 aa		 rep stosb

; 361  : 
; 362  :     /* XOR key with ipad and opad values */
; 363  :     for (i=0; i<keylen; i++) 

  0012a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00132	eb 0b		 jmp	 SHORT $LN23@hmac_ripem
$LN22@hmac_ripem:
  00134	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00138	83 c0 01	 add	 eax, 1
  0013b	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN23@hmac_ripem:
  0013f	8b 84 24 28 02
	00 00		 mov	 eax, DWORD PTR keylen$[rsp]
  00146	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0014a	7d 54		 jge	 SHORT $LN21@hmac_ripem

; 364  : 	{
; 365  :         k_ipad[i] ^= key[i];

  0014c	48 63 54 24 20	 movsxd	 rdx, DWORD PTR i$[rsp]
  00151	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00156	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR key$[rsp]
  0015e	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00162	0f b6 8c 14 a0
	00 00 00	 movzx	 ecx, BYTE PTR k_ipad$[rsp+rdx]
  0016a	33 c8		 xor	 ecx, eax
  0016c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00171	88 8c 04 a0 00
	00 00		 mov	 BYTE PTR k_ipad$[rsp+rax], cl

; 366  :         k_opad[i] ^= key[i];

  00178	48 63 54 24 20	 movsxd	 rdx, DWORD PTR i$[rsp]
  0017d	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00182	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR key$[rsp]
  0018a	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  0018e	0f b6 4c 14 30	 movzx	 ecx, BYTE PTR k_opad$[rsp+rdx]
  00193	33 c8		 xor	 ecx, eax
  00195	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0019a	88 4c 04 30	 mov	 BYTE PTR k_opad$[rsp+rax], cl

; 367  :     }

  0019e	eb 94		 jmp	 SHORT $LN22@hmac_ripem
$LN21@hmac_ripem:

; 368  : 
; 369  :     /* perform inner RIPEMD-160 */
; 370  : 
; 371  :     RMD160Init(&context);           /* init context for 1st pass */

  001a0	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  001a8	e8 00 00 00 00	 call	 RMD160Init

; 372  :     RMD160Update(&context, k_ipad, RIPEMD160_BLOCKSIZE);  /* start with inner pad */

  001ad	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  001b3	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR k_ipad$[rsp]
  001bb	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  001c3	e8 00 00 00 00	 call	 RMD160Update

; 373  :     RMD160Update(&context, (const unsigned char *) input, len); /* then text of datagram */

  001c8	44 8b 84 24 38
	02 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  001d0	48 8b 94 24 30
	02 00 00	 mov	 rdx, QWORD PTR input$[rsp]
  001d8	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  001e0	e8 00 00 00 00	 call	 RMD160Update

; 374  :     RMD160Final((unsigned char *) digest, &context);         /* finish up 1st pass */

  001e5	48 8d 94 24 f0
	00 00 00	 lea	 rdx, QWORD PTR context$[rsp]
  001ed	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR digest$[rsp]
  001f5	e8 00 00 00 00	 call	 RMD160Final

; 375  : 
; 376  :     /* perform outer RIPEMD-160 */
; 377  :     RMD160Init(&context);           /* init context for 2nd pass */

  001fa	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  00202	e8 00 00 00 00	 call	 RMD160Init

; 378  :     RMD160Update(&context, k_opad, RIPEMD160_BLOCKSIZE);  /* start with outer pad */

  00207	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  0020d	48 8d 54 24 30	 lea	 rdx, QWORD PTR k_opad$[rsp]
  00212	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  0021a	e8 00 00 00 00	 call	 RMD160Update

; 379  :     /* results of 1st hash */
; 380  :     RMD160Update(&context, (const unsigned char *) digest, RIPEMD160_DIGESTSIZE);

  0021f	41 b8 14 00 00
	00		 mov	 r8d, 20
  00225	48 8b 94 24 40
	02 00 00	 mov	 rdx, QWORD PTR digest$[rsp]
  0022d	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  00235	e8 00 00 00 00	 call	 RMD160Update

; 381  :     RMD160Final((unsigned char *) digest, &context);         /* finish up 2nd pass */

  0023a	48 8d 94 24 f0
	00 00 00	 lea	 rdx, QWORD PTR context$[rsp]
  00242	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR digest$[rsp]
  0024a	e8 00 00 00 00	 call	 RMD160Final
$LN20@hmac_ripem:

; 382  : 
; 383  : 	/* Prevent possible leaks. */
; 384  :     burn (k_ipad, sizeof(k_ipad));

  0024f	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR k_ipad$[rsp]
  00257	48 89 84 24 c8
	01 00 00	 mov	 QWORD PTR burnm$29034[rsp], rax
  0025f	c7 84 24 c0 01
	00 00 41 00 00
	00		 mov	 DWORD PTR burnc$29036[rsp], 65 ; 00000041H
  0026a	ba 41 00 00 00	 mov	 edx, 65			; 00000041H
  0026f	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR k_ipad$[rsp]
  00277	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN17@hmac_ripem:
  0027c	8b 8c 24 c0 01
	00 00		 mov	 ecx, DWORD PTR burnc$29036[rsp]
  00283	8b 84 24 c0 01
	00 00		 mov	 eax, DWORD PTR burnc$29036[rsp]
  0028a	83 e8 01	 sub	 eax, 1
  0028d	89 84 24 c0 01
	00 00		 mov	 DWORD PTR burnc$29036[rsp], eax
  00294	85 c9		 test	 ecx, ecx
  00296	74 21		 je	 SHORT $LN16@hmac_ripem
  00298	48 8b 84 24 c8
	01 00 00	 mov	 rax, QWORD PTR burnm$29034[rsp]
  002a0	c6 00 00	 mov	 BYTE PTR [rax], 0
  002a3	48 8b 84 24 c8
	01 00 00	 mov	 rax, QWORD PTR burnm$29034[rsp]
  002ab	48 83 c0 01	 add	 rax, 1
  002af	48 89 84 24 c8
	01 00 00	 mov	 QWORD PTR burnm$29034[rsp], rax
  002b7	eb c3		 jmp	 SHORT $LN17@hmac_ripem
$LN16@hmac_ripem:
  002b9	33 c0		 xor	 eax, eax
  002bb	85 c0		 test	 eax, eax
  002bd	75 90		 jne	 SHORT $LN20@hmac_ripem
$LN15@hmac_ripem:

; 385  :     burn (k_opad, sizeof(k_opad));

  002bf	48 8d 44 24 30	 lea	 rax, QWORD PTR k_opad$[rsp]
  002c4	48 89 84 24 d8
	01 00 00	 mov	 QWORD PTR burnm$29043[rsp], rax
  002cc	c7 84 24 d0 01
	00 00 41 00 00
	00		 mov	 DWORD PTR burnc$29045[rsp], 65 ; 00000041H
  002d7	ba 41 00 00 00	 mov	 edx, 65			; 00000041H
  002dc	48 8d 4c 24 30	 lea	 rcx, QWORD PTR k_opad$[rsp]
  002e1	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN12@hmac_ripem:
  002e6	8b 8c 24 d0 01
	00 00		 mov	 ecx, DWORD PTR burnc$29045[rsp]
  002ed	8b 84 24 d0 01
	00 00		 mov	 eax, DWORD PTR burnc$29045[rsp]
  002f4	83 e8 01	 sub	 eax, 1
  002f7	89 84 24 d0 01
	00 00		 mov	 DWORD PTR burnc$29045[rsp], eax
  002fe	85 c9		 test	 ecx, ecx
  00300	74 21		 je	 SHORT $LN11@hmac_ripem
  00302	48 8b 84 24 d8
	01 00 00	 mov	 rax, QWORD PTR burnm$29043[rsp]
  0030a	c6 00 00	 mov	 BYTE PTR [rax], 0
  0030d	48 8b 84 24 d8
	01 00 00	 mov	 rax, QWORD PTR burnm$29043[rsp]
  00315	48 83 c0 01	 add	 rax, 1
  00319	48 89 84 24 d8
	01 00 00	 mov	 QWORD PTR burnm$29043[rsp], rax
  00321	eb c3		 jmp	 SHORT $LN12@hmac_ripem
$LN11@hmac_ripem:
  00323	33 c0		 xor	 eax, eax
  00325	85 c0		 test	 eax, eax
  00327	75 96		 jne	 SHORT $LN15@hmac_ripem
$LN10@hmac_ripem:

; 386  : 	burn (tk, sizeof(tk));

  00329	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR tk$[rsp]
  00331	48 89 84 24 e8
	01 00 00	 mov	 QWORD PTR burnm$29052[rsp], rax
  00339	c7 84 24 e0 01
	00 00 14 00 00
	00		 mov	 DWORD PTR burnc$29054[rsp], 20
  00344	ba 14 00 00 00	 mov	 edx, 20
  00349	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR tk$[rsp]
  00351	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN7@hmac_ripem:
  00356	8b 8c 24 e0 01
	00 00		 mov	 ecx, DWORD PTR burnc$29054[rsp]
  0035d	8b 84 24 e0 01
	00 00		 mov	 eax, DWORD PTR burnc$29054[rsp]
  00364	83 e8 01	 sub	 eax, 1
  00367	89 84 24 e0 01
	00 00		 mov	 DWORD PTR burnc$29054[rsp], eax
  0036e	85 c9		 test	 ecx, ecx
  00370	74 21		 je	 SHORT $LN6@hmac_ripem
  00372	48 8b 84 24 e8
	01 00 00	 mov	 rax, QWORD PTR burnm$29052[rsp]
  0037a	c6 00 00	 mov	 BYTE PTR [rax], 0
  0037d	48 8b 84 24 e8
	01 00 00	 mov	 rax, QWORD PTR burnm$29052[rsp]
  00385	48 83 c0 01	 add	 rax, 1
  00389	48 89 84 24 e8
	01 00 00	 mov	 QWORD PTR burnm$29052[rsp], rax
  00391	eb c3		 jmp	 SHORT $LN7@hmac_ripem
$LN6@hmac_ripem:
  00393	33 c0		 xor	 eax, eax
  00395	85 c0		 test	 eax, eax
  00397	75 90		 jne	 SHORT $LN10@hmac_ripem
$LN5@hmac_ripem:

; 387  : 	burn (&context, sizeof(context));

  00399	48 8d 84 24 f0
	00 00 00	 lea	 rax, QWORD PTR context$[rsp]
  003a1	48 89 84 24 f8
	01 00 00	 mov	 QWORD PTR burnm$29061[rsp], rax
  003a9	c7 84 24 f0 01
	00 00 60 00 00
	00		 mov	 DWORD PTR burnc$29063[rsp], 96 ; 00000060H
  003b4	ba 60 00 00 00	 mov	 edx, 96			; 00000060H
  003b9	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  003c1	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN2@hmac_ripem:
  003c6	8b 8c 24 f0 01
	00 00		 mov	 ecx, DWORD PTR burnc$29063[rsp]
  003cd	8b 84 24 f0 01
	00 00		 mov	 eax, DWORD PTR burnc$29063[rsp]
  003d4	83 e8 01	 sub	 eax, 1
  003d7	89 84 24 f0 01
	00 00		 mov	 DWORD PTR burnc$29063[rsp], eax
  003de	85 c9		 test	 ecx, ecx
  003e0	74 21		 je	 SHORT $LN1@hmac_ripem
  003e2	48 8b 84 24 f8
	01 00 00	 mov	 rax, QWORD PTR burnm$29061[rsp]
  003ea	c6 00 00	 mov	 BYTE PTR [rax], 0
  003ed	48 8b 84 24 f8
	01 00 00	 mov	 rax, QWORD PTR burnm$29061[rsp]
  003f5	48 83 c0 01	 add	 rax, 1
  003f9	48 89 84 24 f8
	01 00 00	 mov	 QWORD PTR burnm$29061[rsp], rax
  00401	eb c3		 jmp	 SHORT $LN2@hmac_ripem
$LN1@hmac_ripem:
  00403	33 c0		 xor	 eax, eax
  00405	85 c0		 test	 eax, eax
  00407	75 90		 jne	 SHORT $LN5@hmac_ripem

; 388  : }

  00409	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00411	48 33 cc	 xor	 rcx, rsp
  00414	e8 00 00 00 00	 call	 __security_check_cookie
  00419	48 81 c4 10 02
	00 00		 add	 rsp, 528		; 00000210H
  00420	5f		 pop	 rdi
  00421	c3		 ret	 0
hmac_ripemd160 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	derive_key_sha1
;	COMDAT pdata
pdata	SEGMENT
$pdata$derive_key_sha1 DD imagerel $LN13
	DD	imagerel $LN13+456
	DD	imagerel $unwind$derive_key_sha1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$derive_key_sha1 DD 042b19H
	DD	011011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	078H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT derive_key_sha1
_TEXT	SEGMENT
u$ = 72
b$ = 96
l$ = 100
r$ = 104
burnc$28991 = 108
burnm$28989 = 112
__$ArrayPad$ = 120
pwd$ = 160
pwd_len$ = 168
salt$ = 176
salt_len$ = 184
iterations$ = 192
dk$ = 200
dklen$ = 208
derive_key_sha1 PROC					; COMDAT

; 290  : {

$LN13:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 44 24 78	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 291  : 	char u[SHA1_DIGESTSIZE];
; 292  : 	int b, l, r;
; 293  : 
; 294  : 	if (dklen % SHA1_DIGESTSIZE)

  0002b	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR dklen$[rsp]
  00032	99		 cdq
  00033	b9 14 00 00 00	 mov	 ecx, 20
  00038	f7 f9		 idiv	 ecx
  0003a	85 d2		 test	 edx, edx
  0003c	74 18		 je	 SHORT $LN10@derive_key@2

; 295  : 	{
; 296  : 		l = 1 + dklen / SHA1_DIGESTSIZE;

  0003e	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR dklen$[rsp]
  00045	99		 cdq
  00046	b9 14 00 00 00	 mov	 ecx, 20
  0004b	f7 f9		 idiv	 ecx
  0004d	83 c0 01	 add	 eax, 1
  00050	89 44 24 64	 mov	 DWORD PTR l$[rsp], eax

; 297  : 	}
; 298  : 	else

  00054	eb 13		 jmp	 SHORT $LN9@derive_key@2
$LN10@derive_key@2:

; 299  : 	{
; 300  : 		l = dklen / SHA1_DIGESTSIZE;

  00056	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR dklen$[rsp]
  0005d	99		 cdq
  0005e	b9 14 00 00 00	 mov	 ecx, 20
  00063	f7 f9		 idiv	 ecx
  00065	89 44 24 64	 mov	 DWORD PTR l$[rsp], eax
$LN9@derive_key@2:

; 301  : 	}
; 302  : 
; 303  : 	r = dklen - (l - 1) * SHA1_DIGESTSIZE;

  00069	8b 4c 24 64	 mov	 ecx, DWORD PTR l$[rsp]
  0006d	83 e9 01	 sub	 ecx, 1
  00070	6b c9 14	 imul	 ecx, 20
  00073	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR dklen$[rsp]
  0007a	2b c1		 sub	 eax, ecx
  0007c	89 44 24 68	 mov	 DWORD PTR r$[rsp], eax

; 304  : 
; 305  : 	/* first l - 1 blocks */
; 306  : 	for (b = 1; b < l; b++)

  00080	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR b$[rsp], 1
  00088	eb 0b		 jmp	 SHORT $LN8@derive_key@2
$LN7@derive_key@2:
  0008a	8b 44 24 60	 mov	 eax, DWORD PTR b$[rsp]
  0008e	83 c0 01	 add	 eax, 1
  00091	89 44 24 60	 mov	 DWORD PTR b$[rsp], eax
$LN8@derive_key@2:
  00095	8b 44 24 64	 mov	 eax, DWORD PTR l$[rsp]
  00099	39 44 24 60	 cmp	 DWORD PTR b$[rsp], eax
  0009d	7d 6b		 jge	 SHORT $LN6@derive_key@2

; 307  : 	{
; 308  : 		derive_u_sha1 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  0009f	8b 44 24 60	 mov	 eax, DWORD PTR b$[rsp]
  000a3	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000a7	48 8d 44 24 48	 lea	 rax, QWORD PTR u$[rsp]
  000ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000b1	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR iterations$[rsp]
  000b8	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000bc	44 8b 8c 24 b8
	00 00 00	 mov	 r9d, DWORD PTR salt_len$[rsp]
  000c4	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR salt$[rsp]
  000cc	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR pwd_len$[rsp]
  000d3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pwd$[rsp]
  000db	e8 00 00 00 00	 call	 derive_u_sha1

; 309  : 		memcpy (dk, u, SHA1_DIGESTSIZE);

  000e0	48 8d 74 24 48	 lea	 rsi, QWORD PTR u$[rsp]
  000e5	48 8b bc 24 c8
	00 00 00	 mov	 rdi, QWORD PTR dk$[rsp]
  000ed	b9 14 00 00 00	 mov	 ecx, 20
  000f2	f3 a4		 rep movsb

; 310  : 		dk += SHA1_DIGESTSIZE;

  000f4	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR dk$[rsp]
  000fc	48 83 c0 14	 add	 rax, 20
  00100	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR dk$[rsp], rax

; 311  : 	}

  00108	eb 80		 jmp	 SHORT $LN7@derive_key@2
$LN6@derive_key@2:

; 312  : 
; 313  : 	/* last block */
; 314  : 	derive_u_sha1 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  0010a	8b 44 24 60	 mov	 eax, DWORD PTR b$[rsp]
  0010e	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00112	48 8d 44 24 48	 lea	 rax, QWORD PTR u$[rsp]
  00117	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0011c	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR iterations$[rsp]
  00123	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00127	44 8b 8c 24 b8
	00 00 00	 mov	 r9d, DWORD PTR salt_len$[rsp]
  0012f	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR salt$[rsp]
  00137	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR pwd_len$[rsp]
  0013e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pwd$[rsp]
  00146	e8 00 00 00 00	 call	 derive_u_sha1

; 315  : 	memcpy (dk, u, r);

  0014b	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR r$[rsp]
  00150	48 8d 74 24 48	 lea	 rsi, QWORD PTR u$[rsp]
  00155	48 8b bc 24 c8
	00 00 00	 mov	 rdi, QWORD PTR dk$[rsp]
  0015d	f3 a4		 rep movsb
$LN5@derive_key@2:

; 316  : 
; 317  : 
; 318  : 	/* Prevent possible leaks. */
; 319  : 	burn (u, sizeof(u));

  0015f	48 8d 44 24 48	 lea	 rax, QWORD PTR u$[rsp]
  00164	48 89 44 24 70	 mov	 QWORD PTR burnm$28989[rsp], rax
  00169	c7 44 24 6c 14
	00 00 00	 mov	 DWORD PTR burnc$28991[rsp], 20
  00171	ba 14 00 00 00	 mov	 edx, 20
  00176	48 8d 4c 24 48	 lea	 rcx, QWORD PTR u$[rsp]
  0017b	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN2@derive_key@2:
  00180	8b 4c 24 6c	 mov	 ecx, DWORD PTR burnc$28991[rsp]
  00184	8b 44 24 6c	 mov	 eax, DWORD PTR burnc$28991[rsp]
  00188	83 e8 01	 sub	 eax, 1
  0018b	89 44 24 6c	 mov	 DWORD PTR burnc$28991[rsp], eax
  0018f	85 c9		 test	 ecx, ecx
  00191	74 18		 je	 SHORT $LN1@derive_key@2
  00193	48 8b 44 24 70	 mov	 rax, QWORD PTR burnm$28989[rsp]
  00198	c6 00 00	 mov	 BYTE PTR [rax], 0
  0019b	48 8b 44 24 70	 mov	 rax, QWORD PTR burnm$28989[rsp]
  001a0	48 83 c0 01	 add	 rax, 1
  001a4	48 89 44 24 70	 mov	 QWORD PTR burnm$28989[rsp], rax
  001a9	eb d5		 jmp	 SHORT $LN2@derive_key@2
$LN1@derive_key@2:
  001ab	33 c0		 xor	 eax, eax
  001ad	85 c0		 test	 eax, eax
  001af	75 ae		 jne	 SHORT $LN5@derive_key@2

; 320  : }

  001b1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001b6	48 33 cc	 xor	 rcx, rsp
  001b9	e8 00 00 00 00	 call	 __security_check_cookie
  001be	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001c5	5f		 pop	 rdi
  001c6	5e		 pop	 rsi
  001c7	c3		 ret	 0
derive_key_sha1 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	derive_u_sha512
;	COMDAT pdata
pdata	SEGMENT
$pdata$derive_u_sha512 DD imagerel $LN19
	DD	imagerel $LN19+664
	DD	imagerel $unwind$derive_u_sha512
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$derive_u_sha512 DD 042e19H
	DD	033011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	0180H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT derive_u_sha512
_TEXT	SEGMENT
i$ = 48
init$ = 64
counter$ = 192
k$ = 208
c$ = 272
j$ = 288
burnc$28763 = 352
burnm$28761 = 360
burnc$28772 = 368
burnm$28770 = 376
__$ArrayPad$ = 384
pwd$ = 432
pwd_len$ = 440
salt$ = 448
salt_len$ = 456
iterations$ = 464
u$ = 472
b$ = 480
derive_u_sha512 PROC					; COMDAT

; 114  : {

$LN19:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec 98 01
	00 00		 sub	 rsp, 408		; 00000198H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 115  : 	char j[SHA512_DIGESTSIZE], k[SHA512_DIGESTSIZE];
; 116  : 	char init[128];
; 117  : 	char counter[4];
; 118  : 	int c, i;
; 119  : 
; 120  : 	/* iteration 1 */
; 121  : 	memset (counter, 0, 4);

  0002e	48 8d bc 24 c0
	00 00 00	 lea	 rdi, QWORD PTR counter$[rsp]
  00036	33 c0		 xor	 eax, eax
  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	f3 aa		 rep stosb

; 122  : 	counter[3] = (char) b;

  0003f	0f b6 84 24 e0
	01 00 00	 movzx	 eax, BYTE PTR b$[rsp]
  00047	88 84 24 c3 00
	00 00		 mov	 BYTE PTR counter$[rsp+3], al

; 123  : 	memcpy (init, salt, salt_len);	/* salt */

  0004e	48 63 8c 24 c8
	01 00 00	 movsxd	 rcx, DWORD PTR salt_len$[rsp]
  00056	48 8d 7c 24 40	 lea	 rdi, QWORD PTR init$[rsp]
  0005b	48 8b b4 24 c0
	01 00 00	 mov	 rsi, QWORD PTR salt$[rsp]
  00063	f3 a4		 rep movsb

; 124  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */

  00065	48 63 94 24 c8
	01 00 00	 movsxd	 rdx, DWORD PTR salt_len$[rsp]
  0006d	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR counter$[rsp]
  00074	89 44 14 40	 mov	 DWORD PTR init$[rsp+rdx], eax

; 125  : 	hmac_sha512 (pwd, pwd_len, init, salt_len + 4, j, SHA512_DIGESTSIZE);

  00078	44 8b 8c 24 c8
	01 00 00	 mov	 r9d, DWORD PTR salt_len$[rsp]
  00080	41 83 c1 04	 add	 r9d, 4
  00084	c7 44 24 28 40
	00 00 00	 mov	 DWORD PTR [rsp+40], 64	; 00000040H
  0008c	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR j$[rsp]
  00094	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00099	4c 8d 44 24 40	 lea	 r8, QWORD PTR init$[rsp]
  0009e	8b 94 24 b8 01
	00 00		 mov	 edx, DWORD PTR pwd_len$[rsp]
  000a5	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR pwd$[rsp]
  000ad	e8 00 00 00 00	 call	 hmac_sha512

; 126  : 	memcpy (u, j, SHA512_DIGESTSIZE);

  000b2	48 8d b4 24 20
	01 00 00	 lea	 rsi, QWORD PTR j$[rsp]
  000ba	48 8b bc 24 d8
	01 00 00	 mov	 rdi, QWORD PTR u$[rsp]
  000c2	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000c7	f3 a4		 rep movsb

; 127  : 
; 128  : 	/* remaining iterations */
; 129  : 	for (c = 1; c < iterations; c++)

  000c9	c7 84 24 10 01
	00 00 01 00 00
	00		 mov	 DWORD PTR c$[rsp], 1
  000d4	eb 11		 jmp	 SHORT $LN16@derive_u_s@2
$LN15@derive_u_s@2:
  000d6	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR c$[rsp]
  000dd	83 c0 01	 add	 eax, 1
  000e0	89 84 24 10 01
	00 00		 mov	 DWORD PTR c$[rsp], eax
$LN16@derive_u_s@2:
  000e7	8b 84 24 d0 01
	00 00		 mov	 eax, DWORD PTR iterations$[rsp]
  000ee	39 84 24 10 01
	00 00		 cmp	 DWORD PTR c$[rsp], eax
  000f5	0f 8d a3 00 00
	00		 jge	 $LN14@derive_u_s@2

; 130  : 	{
; 131  : 		hmac_sha512 (pwd, pwd_len, j, SHA512_DIGESTSIZE, k, SHA512_DIGESTSIZE);

  000fb	c7 44 24 28 40
	00 00 00	 mov	 DWORD PTR [rsp+40], 64	; 00000040H
  00103	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR k$[rsp]
  0010b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00110	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  00116	4c 8d 84 24 20
	01 00 00	 lea	 r8, QWORD PTR j$[rsp]
  0011e	8b 94 24 b8 01
	00 00		 mov	 edx, DWORD PTR pwd_len$[rsp]
  00125	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR pwd$[rsp]
  0012d	e8 00 00 00 00	 call	 hmac_sha512

; 132  : 		for (i = 0; i < SHA512_DIGESTSIZE; i++)

  00132	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0013a	eb 0b		 jmp	 SHORT $LN13@derive_u_s@2
$LN12@derive_u_s@2:
  0013c	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00140	83 c0 01	 add	 eax, 1
  00143	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN13@derive_u_s@2:
  00147	83 7c 24 30 40	 cmp	 DWORD PTR i$[rsp], 64	; 00000040H
  0014c	7d 4b		 jge	 SHORT $LN11@derive_u_s@2

; 133  : 		{
; 134  : 			u[i] ^= k[i];

  0014e	48 63 54 24 30	 movsxd	 rdx, DWORD PTR i$[rsp]
  00153	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00158	0f be 8c 04 d0
	00 00 00	 movsx	 ecx, BYTE PTR k$[rsp+rax]
  00160	48 8b 84 24 d8
	01 00 00	 mov	 rax, QWORD PTR u$[rsp]
  00168	0f be 14 10	 movsx	 edx, BYTE PTR [rax+rdx]
  0016c	33 d1		 xor	 edx, ecx
  0016e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00173	48 8b 84 24 d8
	01 00 00	 mov	 rax, QWORD PTR u$[rsp]
  0017b	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 135  : 			j[i] = k[i];

  0017e	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00183	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00188	0f b6 84 04 d0
	00 00 00	 movzx	 eax, BYTE PTR k$[rsp+rax]
  00190	88 84 0c 20 01
	00 00		 mov	 BYTE PTR j$[rsp+rcx], al

; 136  : 		}

  00197	eb a3		 jmp	 SHORT $LN12@derive_u_s@2
$LN11@derive_u_s@2:

; 137  : 	}

  00199	e9 38 ff ff ff	 jmp	 $LN15@derive_u_s@2
$LN14@derive_u_s@2:
$LN10@derive_u_s@2:

; 138  : 
; 139  : 	/* Prevent possible leaks. */
; 140  : 	burn (j, sizeof(j));

  0019e	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR j$[rsp]
  001a6	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR burnm$28761[rsp], rax
  001ae	c7 84 24 60 01
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$28763[rsp], 64 ; 00000040H
  001b9	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001be	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR j$[rsp]
  001c6	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN7@derive_u_s@2:
  001cb	8b 8c 24 60 01
	00 00		 mov	 ecx, DWORD PTR burnc$28763[rsp]
  001d2	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR burnc$28763[rsp]
  001d9	83 e8 01	 sub	 eax, 1
  001dc	89 84 24 60 01
	00 00		 mov	 DWORD PTR burnc$28763[rsp], eax
  001e3	85 c9		 test	 ecx, ecx
  001e5	74 21		 je	 SHORT $LN6@derive_u_s@2
  001e7	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR burnm$28761[rsp]
  001ef	c6 00 00	 mov	 BYTE PTR [rax], 0
  001f2	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR burnm$28761[rsp]
  001fa	48 83 c0 01	 add	 rax, 1
  001fe	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR burnm$28761[rsp], rax
  00206	eb c3		 jmp	 SHORT $LN7@derive_u_s@2
$LN6@derive_u_s@2:
  00208	33 c0		 xor	 eax, eax
  0020a	85 c0		 test	 eax, eax
  0020c	75 90		 jne	 SHORT $LN10@derive_u_s@2
$LN5@derive_u_s@2:

; 141  : 	burn (k, sizeof(k));

  0020e	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR k$[rsp]
  00216	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR burnm$28770[rsp], rax
  0021e	c7 84 24 70 01
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$28772[rsp], 64 ; 00000040H
  00229	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0022e	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR k$[rsp]
  00236	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN2@derive_u_s@2:
  0023b	8b 8c 24 70 01
	00 00		 mov	 ecx, DWORD PTR burnc$28772[rsp]
  00242	8b 84 24 70 01
	00 00		 mov	 eax, DWORD PTR burnc$28772[rsp]
  00249	83 e8 01	 sub	 eax, 1
  0024c	89 84 24 70 01
	00 00		 mov	 DWORD PTR burnc$28772[rsp], eax
  00253	85 c9		 test	 ecx, ecx
  00255	74 21		 je	 SHORT $LN1@derive_u_s@2
  00257	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR burnm$28770[rsp]
  0025f	c6 00 00	 mov	 BYTE PTR [rax], 0
  00262	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR burnm$28770[rsp]
  0026a	48 83 c0 01	 add	 rax, 1
  0026e	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR burnm$28770[rsp], rax
  00276	eb c3		 jmp	 SHORT $LN2@derive_u_s@2
$LN1@derive_u_s@2:
  00278	33 c0		 xor	 eax, eax
  0027a	85 c0		 test	 eax, eax
  0027c	75 90		 jne	 SHORT $LN5@derive_u_s@2

; 142  : }

  0027e	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00286	48 33 cc	 xor	 rcx, rsp
  00289	e8 00 00 00 00	 call	 __security_check_cookie
  0028e	48 81 c4 98 01
	00 00		 add	 rsp, 408		; 00000198H
  00295	5f		 pop	 rdi
  00296	5e		 pop	 rsi
  00297	c3		 ret	 0
derive_u_sha512 ENDP
PUBLIC	__$ArrayPad$
PUBLIC	derive_u_ripemd160
;	COMDAT pdata
pdata	SEGMENT
$pdata$derive_u_ripemd160 DD imagerel $LN19
	DD	imagerel $LN19+648
	DD	imagerel $unwind$derive_u_ripemd160
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$derive_u_ripemd160 DD 042e19H
	DD	027011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	0120H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT derive_u_ripemd160
_TEXT	SEGMENT
i$ = 48
init$ = 64
counter$ = 192
k$ = 200
c$ = 224
j$ = 232
burnc$29100 = 256
burnm$29098 = 264
burnc$29109 = 272
burnm$29107 = 280
__$ArrayPad$ = 288
pwd$ = 336
pwd_len$ = 344
salt$ = 352
salt_len$ = 360
iterations$ = 368
u$ = 376
b$ = 384
derive_u_ripemd160 PROC					; COMDAT

; 391  : {

$LN19:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 392  : 	char j[RIPEMD160_DIGESTSIZE], k[RIPEMD160_DIGESTSIZE];
; 393  : 	char init[128];
; 394  : 	char counter[4];
; 395  : 	int c, i;
; 396  : 
; 397  : 	/* iteration 1 */
; 398  : 	memset (counter, 0, 4);

  0002e	48 8d bc 24 c0
	00 00 00	 lea	 rdi, QWORD PTR counter$[rsp]
  00036	33 c0		 xor	 eax, eax
  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	f3 aa		 rep stosb

; 399  : 	counter[3] = (char) b;

  0003f	0f b6 84 24 80
	01 00 00	 movzx	 eax, BYTE PTR b$[rsp]
  00047	88 84 24 c3 00
	00 00		 mov	 BYTE PTR counter$[rsp+3], al

; 400  : 	memcpy (init, salt, salt_len);	/* salt */

  0004e	48 63 8c 24 68
	01 00 00	 movsxd	 rcx, DWORD PTR salt_len$[rsp]
  00056	48 8d 7c 24 40	 lea	 rdi, QWORD PTR init$[rsp]
  0005b	48 8b b4 24 60
	01 00 00	 mov	 rsi, QWORD PTR salt$[rsp]
  00063	f3 a4		 rep movsb

; 401  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */

  00065	48 63 94 24 68
	01 00 00	 movsxd	 rdx, DWORD PTR salt_len$[rsp]
  0006d	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR counter$[rsp]
  00074	89 44 14 40	 mov	 DWORD PTR init$[rsp+rdx], eax

; 402  : 	hmac_ripemd160 (pwd, pwd_len, init, salt_len + 4, j);

  00078	44 8b 8c 24 68
	01 00 00	 mov	 r9d, DWORD PTR salt_len$[rsp]
  00080	41 83 c1 04	 add	 r9d, 4
  00084	48 8d 84 24 e8
	00 00 00	 lea	 rax, QWORD PTR j$[rsp]
  0008c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00091	4c 8d 44 24 40	 lea	 r8, QWORD PTR init$[rsp]
  00096	8b 94 24 58 01
	00 00		 mov	 edx, DWORD PTR pwd_len$[rsp]
  0009d	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pwd$[rsp]
  000a5	e8 00 00 00 00	 call	 hmac_ripemd160

; 403  : 	memcpy (u, j, RIPEMD160_DIGESTSIZE);

  000aa	48 8d b4 24 e8
	00 00 00	 lea	 rsi, QWORD PTR j$[rsp]
  000b2	48 8b bc 24 78
	01 00 00	 mov	 rdi, QWORD PTR u$[rsp]
  000ba	b9 14 00 00 00	 mov	 ecx, 20
  000bf	f3 a4		 rep movsb

; 404  : 
; 405  : 	/* remaining iterations */
; 406  : 	for (c = 1; c < iterations; c++)

  000c1	c7 84 24 e0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR c$[rsp], 1
  000cc	eb 11		 jmp	 SHORT $LN16@derive_u_r
$LN15@derive_u_r:
  000ce	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR c$[rsp]
  000d5	83 c0 01	 add	 eax, 1
  000d8	89 84 24 e0 00
	00 00		 mov	 DWORD PTR c$[rsp], eax
$LN16@derive_u_r:
  000df	8b 84 24 70 01
	00 00		 mov	 eax, DWORD PTR iterations$[rsp]
  000e6	39 84 24 e0 00
	00 00		 cmp	 DWORD PTR c$[rsp], eax
  000ed	0f 8d 9b 00 00
	00		 jge	 $LN14@derive_u_r

; 407  : 	{
; 408  : 		hmac_ripemd160 (pwd, pwd_len, j, RIPEMD160_DIGESTSIZE, k);

  000f3	48 8d 84 24 c8
	00 00 00	 lea	 rax, QWORD PTR k$[rsp]
  000fb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00100	41 b9 14 00 00
	00		 mov	 r9d, 20
  00106	4c 8d 84 24 e8
	00 00 00	 lea	 r8, QWORD PTR j$[rsp]
  0010e	8b 94 24 58 01
	00 00		 mov	 edx, DWORD PTR pwd_len$[rsp]
  00115	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pwd$[rsp]
  0011d	e8 00 00 00 00	 call	 hmac_ripemd160

; 409  : 		for (i = 0; i < RIPEMD160_DIGESTSIZE; i++)

  00122	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0012a	eb 0b		 jmp	 SHORT $LN13@derive_u_r
$LN12@derive_u_r:
  0012c	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00130	83 c0 01	 add	 eax, 1
  00133	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN13@derive_u_r:
  00137	83 7c 24 30 14	 cmp	 DWORD PTR i$[rsp], 20
  0013c	7d 4b		 jge	 SHORT $LN11@derive_u_r

; 410  : 		{
; 411  : 			u[i] ^= k[i];

  0013e	48 63 54 24 30	 movsxd	 rdx, DWORD PTR i$[rsp]
  00143	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00148	0f be 8c 04 c8
	00 00 00	 movsx	 ecx, BYTE PTR k$[rsp+rax]
  00150	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR u$[rsp]
  00158	0f be 14 10	 movsx	 edx, BYTE PTR [rax+rdx]
  0015c	33 d1		 xor	 edx, ecx
  0015e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00163	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR u$[rsp]
  0016b	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 412  : 			j[i] = k[i];

  0016e	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00173	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00178	0f b6 84 04 c8
	00 00 00	 movzx	 eax, BYTE PTR k$[rsp+rax]
  00180	88 84 0c e8 00
	00 00		 mov	 BYTE PTR j$[rsp+rcx], al

; 413  : 		}

  00187	eb a3		 jmp	 SHORT $LN12@derive_u_r
$LN11@derive_u_r:

; 414  : 	}

  00189	e9 40 ff ff ff	 jmp	 $LN15@derive_u_r
$LN14@derive_u_r:
$LN10@derive_u_r:

; 415  : 
; 416  : 	/* Prevent possible leaks. */
; 417  : 	burn (j, sizeof(j));

  0018e	48 8d 84 24 e8
	00 00 00	 lea	 rax, QWORD PTR j$[rsp]
  00196	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR burnm$29098[rsp], rax
  0019e	c7 84 24 00 01
	00 00 14 00 00
	00		 mov	 DWORD PTR burnc$29100[rsp], 20
  001a9	ba 14 00 00 00	 mov	 edx, 20
  001ae	48 8d 8c 24 e8
	00 00 00	 lea	 rcx, QWORD PTR j$[rsp]
  001b6	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN7@derive_u_r:
  001bb	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR burnc$29100[rsp]
  001c2	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR burnc$29100[rsp]
  001c9	83 e8 01	 sub	 eax, 1
  001cc	89 84 24 00 01
	00 00		 mov	 DWORD PTR burnc$29100[rsp], eax
  001d3	85 c9		 test	 ecx, ecx
  001d5	74 21		 je	 SHORT $LN6@derive_u_r
  001d7	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR burnm$29098[rsp]
  001df	c6 00 00	 mov	 BYTE PTR [rax], 0
  001e2	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR burnm$29098[rsp]
  001ea	48 83 c0 01	 add	 rax, 1
  001ee	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR burnm$29098[rsp], rax
  001f6	eb c3		 jmp	 SHORT $LN7@derive_u_r
$LN6@derive_u_r:
  001f8	33 c0		 xor	 eax, eax
  001fa	85 c0		 test	 eax, eax
  001fc	75 90		 jne	 SHORT $LN10@derive_u_r
$LN5@derive_u_r:

; 418  : 	burn (k, sizeof(k));

  001fe	48 8d 84 24 c8
	00 00 00	 lea	 rax, QWORD PTR k$[rsp]
  00206	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR burnm$29107[rsp], rax
  0020e	c7 84 24 10 01
	00 00 14 00 00
	00		 mov	 DWORD PTR burnc$29109[rsp], 20
  00219	ba 14 00 00 00	 mov	 edx, 20
  0021e	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR k$[rsp]
  00226	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN2@derive_u_r:
  0022b	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR burnc$29109[rsp]
  00232	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR burnc$29109[rsp]
  00239	83 e8 01	 sub	 eax, 1
  0023c	89 84 24 10 01
	00 00		 mov	 DWORD PTR burnc$29109[rsp], eax
  00243	85 c9		 test	 ecx, ecx
  00245	74 21		 je	 SHORT $LN1@derive_u_r
  00247	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR burnm$29107[rsp]
  0024f	c6 00 00	 mov	 BYTE PTR [rax], 0
  00252	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR burnm$29107[rsp]
  0025a	48 83 c0 01	 add	 rax, 1
  0025e	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR burnm$29107[rsp], rax
  00266	eb c3		 jmp	 SHORT $LN2@derive_u_r
$LN1@derive_u_r:
  00268	33 c0		 xor	 eax, eax
  0026a	85 c0		 test	 eax, eax
  0026c	75 90		 jne	 SHORT $LN5@derive_u_r

; 419  : }

  0026e	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00276	48 33 cc	 xor	 rcx, rsp
  00279	e8 00 00 00 00	 call	 __security_check_cookie
  0027e	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  00285	5f		 pop	 rdi
  00286	5e		 pop	 rsi
  00287	c3		 ret	 0
derive_u_ripemd160 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	derive_key_sha512
;	COMDAT pdata
pdata	SEGMENT
$pdata$derive_key_sha512 DD imagerel $LN13
	DD	imagerel $LN13+530
	DD	imagerel $unwind$derive_key_sha512
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$derive_key_sha512 DD 042e19H
	DD	017011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT derive_key_sha512
_TEXT	SEGMENT
u$ = 80
b$ = 144
l$ = 148
r$ = 152
burnc$28805 = 156
burnm$28803 = 160
__$ArrayPad$ = 168
pwd$ = 208
pwd_len$ = 216
salt$ = 224
salt_len$ = 232
iterations$ = 240
dk$ = 248
dklen$ = 256
derive_key_sha512 PROC					; COMDAT

; 146  : {

$LN13:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 147  : 	char u[SHA512_DIGESTSIZE];
; 148  : 	int b, l, r;
; 149  : 
; 150  : 	if (dklen % SHA512_DIGESTSIZE)

  0002e	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR dklen$[rsp]
  00035	99		 cdq
  00036	83 e2 3f	 and	 edx, 63			; 0000003fH
  00039	03 c2		 add	 eax, edx
  0003b	83 e0 3f	 and	 eax, 63			; 0000003fH
  0003e	2b c2		 sub	 eax, edx
  00040	85 c0		 test	 eax, eax
  00042	74 1c		 je	 SHORT $LN10@derive_key@3

; 151  : 	{
; 152  : 		l = 1 + dklen / SHA512_DIGESTSIZE;

  00044	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR dklen$[rsp]
  0004b	99		 cdq
  0004c	83 e2 3f	 and	 edx, 63			; 0000003fH
  0004f	03 c2		 add	 eax, edx
  00051	c1 f8 06	 sar	 eax, 6
  00054	83 c0 01	 add	 eax, 1
  00057	89 84 24 94 00
	00 00		 mov	 DWORD PTR l$[rsp], eax

; 153  : 	}
; 154  : 	else

  0005e	eb 17		 jmp	 SHORT $LN9@derive_key@3
$LN10@derive_key@3:

; 155  : 	{
; 156  : 		l = dklen / SHA512_DIGESTSIZE;

  00060	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR dklen$[rsp]
  00067	99		 cdq
  00068	83 e2 3f	 and	 edx, 63			; 0000003fH
  0006b	03 c2		 add	 eax, edx
  0006d	c1 f8 06	 sar	 eax, 6
  00070	89 84 24 94 00
	00 00		 mov	 DWORD PTR l$[rsp], eax
$LN9@derive_key@3:

; 157  : 	}
; 158  : 
; 159  : 	r = dklen - (l - 1) * SHA512_DIGESTSIZE;

  00077	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR l$[rsp]
  0007e	83 e9 01	 sub	 ecx, 1
  00081	6b c9 40	 imul	 ecx, 64			; 00000040H
  00084	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR dklen$[rsp]
  0008b	2b c1		 sub	 eax, ecx
  0008d	89 84 24 98 00
	00 00		 mov	 DWORD PTR r$[rsp], eax

; 160  : 
; 161  : 	/* first l - 1 blocks */
; 162  : 	for (b = 1; b < l; b++)

  00094	c7 84 24 90 00
	00 00 01 00 00
	00		 mov	 DWORD PTR b$[rsp], 1
  0009f	eb 11		 jmp	 SHORT $LN8@derive_key@3
$LN7@derive_key@3:
  000a1	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR b$[rsp]
  000a8	83 c0 01	 add	 eax, 1
  000ab	89 84 24 90 00
	00 00		 mov	 DWORD PTR b$[rsp], eax
$LN8@derive_key@3:
  000b2	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR l$[rsp]
  000b9	39 84 24 90 00
	00 00		 cmp	 DWORD PTR b$[rsp], eax
  000c0	7d 71		 jge	 SHORT $LN6@derive_key@3

; 163  : 	{
; 164  : 		derive_u_sha512 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  000c2	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR b$[rsp]
  000c9	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000cd	48 8d 44 24 50	 lea	 rax, QWORD PTR u$[rsp]
  000d2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000d7	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR iterations$[rsp]
  000de	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000e2	44 8b 8c 24 e8
	00 00 00	 mov	 r9d, DWORD PTR salt_len$[rsp]
  000ea	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR salt$[rsp]
  000f2	8b 94 24 d8 00
	00 00		 mov	 edx, DWORD PTR pwd_len$[rsp]
  000f9	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pwd$[rsp]
  00101	e8 00 00 00 00	 call	 derive_u_sha512

; 165  : 		memcpy (dk, u, SHA512_DIGESTSIZE);

  00106	48 8d 74 24 50	 lea	 rsi, QWORD PTR u$[rsp]
  0010b	48 8b bc 24 f8
	00 00 00	 mov	 rdi, QWORD PTR dk$[rsp]
  00113	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00118	f3 a4		 rep movsb

; 166  : 		dk += SHA512_DIGESTSIZE;

  0011a	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR dk$[rsp]
  00122	48 83 c0 40	 add	 rax, 64			; 00000040H
  00126	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR dk$[rsp], rax

; 167  : 	}

  0012e	e9 6e ff ff ff	 jmp	 $LN7@derive_key@3
$LN6@derive_key@3:

; 168  : 
; 169  : 	/* last block */
; 170  : 	derive_u_sha512 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  00133	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR b$[rsp]
  0013a	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0013e	48 8d 44 24 50	 lea	 rax, QWORD PTR u$[rsp]
  00143	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00148	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR iterations$[rsp]
  0014f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00153	44 8b 8c 24 e8
	00 00 00	 mov	 r9d, DWORD PTR salt_len$[rsp]
  0015b	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR salt$[rsp]
  00163	8b 94 24 d8 00
	00 00		 mov	 edx, DWORD PTR pwd_len$[rsp]
  0016a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pwd$[rsp]
  00172	e8 00 00 00 00	 call	 derive_u_sha512

; 171  : 	memcpy (dk, u, r);

  00177	48 63 8c 24 98
	00 00 00	 movsxd	 rcx, DWORD PTR r$[rsp]
  0017f	48 8d 74 24 50	 lea	 rsi, QWORD PTR u$[rsp]
  00184	48 8b bc 24 f8
	00 00 00	 mov	 rdi, QWORD PTR dk$[rsp]
  0018c	f3 a4		 rep movsb
$LN5@derive_key@3:

; 172  : 
; 173  : 
; 174  : 	/* Prevent possible leaks. */
; 175  : 	burn (u, sizeof(u));

  0018e	48 8d 44 24 50	 lea	 rax, QWORD PTR u$[rsp]
  00193	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR burnm$28803[rsp], rax
  0019b	c7 84 24 9c 00
	00 00 40 00 00
	00		 mov	 DWORD PTR burnc$28805[rsp], 64 ; 00000040H
  001a6	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001ab	48 8d 4c 24 50	 lea	 rcx, QWORD PTR u$[rsp]
  001b0	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN2@derive_key@3:
  001b5	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR burnc$28805[rsp]
  001bc	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR burnc$28805[rsp]
  001c3	83 e8 01	 sub	 eax, 1
  001c6	89 84 24 9c 00
	00 00		 mov	 DWORD PTR burnc$28805[rsp], eax
  001cd	85 c9		 test	 ecx, ecx
  001cf	74 21		 je	 SHORT $LN1@derive_key@3
  001d1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR burnm$28803[rsp]
  001d9	c6 00 00	 mov	 BYTE PTR [rax], 0
  001dc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR burnm$28803[rsp]
  001e4	48 83 c0 01	 add	 rax, 1
  001e8	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR burnm$28803[rsp], rax
  001f0	eb c3		 jmp	 SHORT $LN2@derive_key@3
$LN1@derive_key@3:
  001f2	33 c0		 xor	 eax, eax
  001f4	85 c0		 test	 eax, eax
  001f6	75 96		 jne	 SHORT $LN5@derive_key@3

; 176  : }

  001f8	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00200	48 33 cc	 xor	 rcx, rsp
  00203	e8 00 00 00 00	 call	 __security_check_cookie
  00208	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0020f	5f		 pop	 rdi
  00210	5e		 pop	 rsi
  00211	c3		 ret	 0
derive_key_sha512 ENDP
PUBLIC	__$ArrayPad$
PUBLIC	derive_key_ripemd160
;	COMDAT pdata
pdata	SEGMENT
$pdata$derive_key_ripemd160 DD imagerel $LN13
	DD	imagerel $LN13+456
	DD	imagerel $unwind$derive_key_ripemd160
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$derive_key_ripemd160 DD 042b19H
	DD	011011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	078H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT derive_key_ripemd160
_TEXT	SEGMENT
u$ = 72
b$ = 96
l$ = 100
r$ = 104
burnc$29142 = 108
burnm$29140 = 112
__$ArrayPad$ = 120
pwd$ = 160
pwd_len$ = 168
salt$ = 176
salt_len$ = 184
iterations$ = 192
dk$ = 200
dklen$ = 208
derive_key_ripemd160 PROC				; COMDAT

; 422  : {

$LN13:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 44 24 78	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 423  : 	char u[RIPEMD160_DIGESTSIZE];
; 424  : 	int b, l, r;
; 425  : 
; 426  : 	if (dklen % RIPEMD160_DIGESTSIZE)

  0002b	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR dklen$[rsp]
  00032	99		 cdq
  00033	b9 14 00 00 00	 mov	 ecx, 20
  00038	f7 f9		 idiv	 ecx
  0003a	85 d2		 test	 edx, edx
  0003c	74 18		 je	 SHORT $LN10@derive_key@4

; 427  : 	{
; 428  : 		l = 1 + dklen / RIPEMD160_DIGESTSIZE;

  0003e	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR dklen$[rsp]
  00045	99		 cdq
  00046	b9 14 00 00 00	 mov	 ecx, 20
  0004b	f7 f9		 idiv	 ecx
  0004d	83 c0 01	 add	 eax, 1
  00050	89 44 24 64	 mov	 DWORD PTR l$[rsp], eax

; 429  : 	}
; 430  : 	else

  00054	eb 13		 jmp	 SHORT $LN9@derive_key@4
$LN10@derive_key@4:

; 431  : 	{
; 432  : 		l = dklen / RIPEMD160_DIGESTSIZE;

  00056	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR dklen$[rsp]
  0005d	99		 cdq
  0005e	b9 14 00 00 00	 mov	 ecx, 20
  00063	f7 f9		 idiv	 ecx
  00065	89 44 24 64	 mov	 DWORD PTR l$[rsp], eax
$LN9@derive_key@4:

; 433  : 	}
; 434  : 
; 435  : 	r = dklen - (l - 1) * RIPEMD160_DIGESTSIZE;

  00069	8b 4c 24 64	 mov	 ecx, DWORD PTR l$[rsp]
  0006d	83 e9 01	 sub	 ecx, 1
  00070	6b c9 14	 imul	 ecx, 20
  00073	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR dklen$[rsp]
  0007a	2b c1		 sub	 eax, ecx
  0007c	89 44 24 68	 mov	 DWORD PTR r$[rsp], eax

; 436  : 
; 437  : 	/* first l - 1 blocks */
; 438  : 	for (b = 1; b < l; b++)

  00080	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR b$[rsp], 1
  00088	eb 0b		 jmp	 SHORT $LN8@derive_key@4
$LN7@derive_key@4:
  0008a	8b 44 24 60	 mov	 eax, DWORD PTR b$[rsp]
  0008e	83 c0 01	 add	 eax, 1
  00091	89 44 24 60	 mov	 DWORD PTR b$[rsp], eax
$LN8@derive_key@4:
  00095	8b 44 24 64	 mov	 eax, DWORD PTR l$[rsp]
  00099	39 44 24 60	 cmp	 DWORD PTR b$[rsp], eax
  0009d	7d 6b		 jge	 SHORT $LN6@derive_key@4

; 439  : 	{
; 440  : 		derive_u_ripemd160 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  0009f	8b 44 24 60	 mov	 eax, DWORD PTR b$[rsp]
  000a3	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000a7	48 8d 44 24 48	 lea	 rax, QWORD PTR u$[rsp]
  000ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000b1	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR iterations$[rsp]
  000b8	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000bc	44 8b 8c 24 b8
	00 00 00	 mov	 r9d, DWORD PTR salt_len$[rsp]
  000c4	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR salt$[rsp]
  000cc	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR pwd_len$[rsp]
  000d3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pwd$[rsp]
  000db	e8 00 00 00 00	 call	 derive_u_ripemd160

; 441  : 		memcpy (dk, u, RIPEMD160_DIGESTSIZE);

  000e0	48 8d 74 24 48	 lea	 rsi, QWORD PTR u$[rsp]
  000e5	48 8b bc 24 c8
	00 00 00	 mov	 rdi, QWORD PTR dk$[rsp]
  000ed	b9 14 00 00 00	 mov	 ecx, 20
  000f2	f3 a4		 rep movsb

; 442  : 		dk += RIPEMD160_DIGESTSIZE;

  000f4	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR dk$[rsp]
  000fc	48 83 c0 14	 add	 rax, 20
  00100	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR dk$[rsp], rax

; 443  : 	}

  00108	eb 80		 jmp	 SHORT $LN7@derive_key@4
$LN6@derive_key@4:

; 444  : 
; 445  : 	/* last block */
; 446  : 	derive_u_ripemd160 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  0010a	8b 44 24 60	 mov	 eax, DWORD PTR b$[rsp]
  0010e	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00112	48 8d 44 24 48	 lea	 rax, QWORD PTR u$[rsp]
  00117	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0011c	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR iterations$[rsp]
  00123	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00127	44 8b 8c 24 b8
	00 00 00	 mov	 r9d, DWORD PTR salt_len$[rsp]
  0012f	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR salt$[rsp]
  00137	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR pwd_len$[rsp]
  0013e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pwd$[rsp]
  00146	e8 00 00 00 00	 call	 derive_u_ripemd160

; 447  : 	memcpy (dk, u, r);

  0014b	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR r$[rsp]
  00150	48 8d 74 24 48	 lea	 rsi, QWORD PTR u$[rsp]
  00155	48 8b bc 24 c8
	00 00 00	 mov	 rdi, QWORD PTR dk$[rsp]
  0015d	f3 a4		 rep movsb
$LN5@derive_key@4:

; 448  : 
; 449  : 
; 450  : 	/* Prevent possible leaks. */
; 451  : 	burn (u, sizeof(u));

  0015f	48 8d 44 24 48	 lea	 rax, QWORD PTR u$[rsp]
  00164	48 89 44 24 70	 mov	 QWORD PTR burnm$29140[rsp], rax
  00169	c7 44 24 6c 14
	00 00 00	 mov	 DWORD PTR burnc$29142[rsp], 20
  00171	ba 14 00 00 00	 mov	 edx, 20
  00176	48 8d 4c 24 48	 lea	 rcx, QWORD PTR u$[rsp]
  0017b	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN2@derive_key@4:
  00180	8b 4c 24 6c	 mov	 ecx, DWORD PTR burnc$29142[rsp]
  00184	8b 44 24 6c	 mov	 eax, DWORD PTR burnc$29142[rsp]
  00188	83 e8 01	 sub	 eax, 1
  0018b	89 44 24 6c	 mov	 DWORD PTR burnc$29142[rsp], eax
  0018f	85 c9		 test	 ecx, ecx
  00191	74 18		 je	 SHORT $LN1@derive_key@4
  00193	48 8b 44 24 70	 mov	 rax, QWORD PTR burnm$29140[rsp]
  00198	c6 00 00	 mov	 BYTE PTR [rax], 0
  0019b	48 8b 44 24 70	 mov	 rax, QWORD PTR burnm$29140[rsp]
  001a0	48 83 c0 01	 add	 rax, 1
  001a4	48 89 44 24 70	 mov	 QWORD PTR burnm$29140[rsp], rax
  001a9	eb d5		 jmp	 SHORT $LN2@derive_key@4
$LN1@derive_key@4:
  001ab	33 c0		 xor	 eax, eax
  001ad	85 c0		 test	 eax, eax
  001af	75 ae		 jne	 SHORT $LN5@derive_key@4

; 452  : }

  001b1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001b6	48 33 cc	 xor	 rcx, rsp
  001b9	e8 00 00 00 00	 call	 __security_check_cookie
  001be	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001c5	5f		 pop	 rdi
  001c6	5e		 pop	 rsi
  001c7	c3		 ret	 0
derive_key_ripemd160 ENDP
END
