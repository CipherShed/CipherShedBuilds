; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\home\public\desktop\projects\ciphershed\src\common\wipe.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

; Function compile flags: /Ogsp
; File c:\home\public\desktop\projects\ciphershed\src\common\wipe.c
;	COMDAT _Wipe1PseudoRandom@12
_TEXT	SEGMENT
_Wipe1PseudoRandom@12 PROC				; COMDAT

; 15   : 	return FALSE;

  00000	33 c0		 xor	 eax, eax

; 16   : }

  00002	c3		 ret	 0
_Wipe1PseudoRandom@12 ENDP
_TEXT	ENDS
EXTRN	_memset:PROC
; Function compile flags: /Ogsp
;	COMDAT _Wipe3Dod5220@12
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_size$ = 12						; size = 4
_Wipe3Dod5220@12 PROC					; COMDAT
; _pass$ = eax

; 23   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 24   : 	byte wipeChar;
; 25   : 
; 26   : 	switch (pass)

  00005	48		 dec	 eax
  00006	74 0b		 je	 SHORT $LN3@Wipe3Dod52
  00008	48		 dec	 eax
  00009	74 04		 je	 SHORT $LN2@Wipe3Dod52

; 35   : 
; 36   : 	default:
; 37   : 		return FALSE;

  0000b	33 c0		 xor	 eax, eax
  0000d	eb 1b		 jmp	 SHORT $LN6@Wipe3Dod52
$LN2@Wipe3Dod52:

; 30   : 		break;
; 31   : 
; 32   : 	case 2:
; 33   : 		wipeChar = 0xff;

  0000f	0c ff		 or	 al, 255			; 000000ffH

; 34   : 		break;

  00011	eb 02		 jmp	 SHORT $LN4@Wipe3Dod52
$LN3@Wipe3Dod52:

; 27   : 	{
; 28   : 	case 1:
; 29   : 		wipeChar = 0;

  00013	32 c0		 xor	 al, al
$LN4@Wipe3Dod52:

; 38   : 	}
; 39   : 
; 40   : 	memset (buffer, wipeChar, size);

  00015	ff 75 0c	 push	 DWORD PTR _size$[ebp]
  00018	0f b6 c0	 movzx	 eax, al
  0001b	50		 push	 eax
  0001c	ff 75 08	 push	 DWORD PTR _buffer$[ebp]
  0001f	e8 00 00 00 00	 call	 _memset

; 41   : 	return TRUE;

  00024	33 c0		 xor	 eax, eax
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	40		 inc	 eax
$LN6@Wipe3Dod52:

; 42   : }

  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
_Wipe3Dod5220@12 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _Wipe7Dod5220@16
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_size$ = 12						; size = 4
_Wipe7Dod5220@16 PROC					; COMDAT
; _pass$ = ecx
; _randChars$ = eax

; 46   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 47   : 	byte wipeChar;
; 48   : 
; 49   : 	switch (pass)

  00005	49		 dec	 ecx
  00006	74 26		 je	 SHORT $LN6@Wipe7Dod52
  00008	49		 dec	 ecx
  00009	74 1d		 je	 SHORT $LN5@Wipe7Dod52
  0000b	49		 dec	 ecx
  0000c	49		 dec	 ecx
  0000d	74 14		 je	 SHORT $LN4@Wipe7Dod52
  0000f	49		 dec	 ecx
  00010	74 0c		 je	 SHORT $LN3@Wipe7Dod52
  00012	49		 dec	 ecx
  00013	74 04		 je	 SHORT $LN2@Wipe7Dod52

; 70   : 
; 71   : 	default:
; 72   : 		return FALSE;

  00015	33 c0		 xor	 eax, eax
  00017	eb 2c		 jmp	 SHORT $LN9@Wipe7Dod52
$LN2@Wipe7Dod52:

; 66   : 
; 67   : 	case 6:
; 68   : 		wipeChar = ~randChars[2];

  00019	8a 40 02	 mov	 al, BYTE PTR [eax+2]

; 69   : 		break;

  0001c	eb 0c		 jmp	 SHORT $LN11@Wipe7Dod52
$LN3@Wipe7Dod52:

; 62   : 
; 63   : 	case 5:
; 64   : 		wipeChar = randChars[2];

  0001e	8a 40 02	 mov	 al, BYTE PTR [eax+2]

; 65   : 		break;

  00021	eb 0d		 jmp	 SHORT $LN7@Wipe7Dod52
$LN4@Wipe7Dod52:

; 58   : 
; 59   : 	case 4:
; 60   : 		wipeChar = randChars[1];

  00023	8a 40 01	 mov	 al, BYTE PTR [eax+1]

; 61   : 		break;

  00026	eb 08		 jmp	 SHORT $LN7@Wipe7Dod52
$LN5@Wipe7Dod52:

; 53   : 		break;
; 54   : 
; 55   : 	case 2:
; 56   : 		wipeChar = ~randChars[0];

  00028	8a 00		 mov	 al, BYTE PTR [eax]
$LN11@Wipe7Dod52:
  0002a	f6 d0		 not	 al

; 57   : 		break;

  0002c	eb 02		 jmp	 SHORT $LN7@Wipe7Dod52
$LN6@Wipe7Dod52:

; 50   : 	{
; 51   : 	case 1:
; 52   : 		wipeChar = randChars[0];

  0002e	8a 00		 mov	 al, BYTE PTR [eax]
$LN7@Wipe7Dod52:

; 73   : 	}
; 74   : 
; 75   : 	memset (buffer, wipeChar, size);

  00030	ff 75 0c	 push	 DWORD PTR _size$[ebp]
  00033	0f b6 c0	 movzx	 eax, al
  00036	50		 push	 eax
  00037	ff 75 08	 push	 DWORD PTR _buffer$[ebp]
  0003a	e8 00 00 00 00	 call	 _memset

; 76   : 	return TRUE;

  0003f	33 c0		 xor	 eax, eax
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
  00044	40		 inc	 eax
$LN9@Wipe7Dod52:

; 77   : }

  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
_Wipe7Dod5220@16 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _Wipe35Gutmann@12
_TEXT	SEGMENT
_wipePat3$ = -4						; size = 3
_size$ = 8						; size = 4
_Wipe35Gutmann@12 PROC					; COMDAT
; _pass$ = ecx
; _buffer$ = edi

; 84   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 85   : 	byte wipePat3[] = { 0x92, 0x49, 0x24 };
; 86   : 	int wipePat3Pos;
; 87   : 	size_t i;
; 88   : 
; 89   : 	switch (pass)

  00006	83 f9 1a	 cmp	 ecx, 26			; 0000001aH
  00009	8b 55 08	 mov	 edx, DWORD PTR _size$[ebp]
  0000c	56		 push	 esi
  0000d	c6 45 fc 92	 mov	 BYTE PTR _wipePat3$[ebp], 146 ; 00000092H
  00011	c6 45 fd 49	 mov	 BYTE PTR _wipePat3$[ebp+1], 73 ; 00000049H
  00015	c6 45 fe 24	 mov	 BYTE PTR _wipePat3$[ebp+2], 36 ; 00000024H
  00019	7f 19		 jg	 SHORT $LN17@Wipe35Gutm
  0001b	74 46		 je	 SHORT $LN10@Wipe35Gutm
  0001d	8b c1		 mov	 eax, ecx
  0001f	83 e8 05	 sub	 eax, 5
  00022	74 0b		 je	 SHORT $LN12@Wipe35Gutm
  00024	48		 dec	 eax
  00025	75 17		 jne	 SHORT $LN20@Wipe35Gutm

; 94   : 
; 95   : 	case 6:
; 96   : 		memset (buffer, 0xaa, size);

  00027	52		 push	 edx
  00028	68 aa 00 00 00	 push	 170			; 000000aaH

; 97   : 		break;

  0002d	eb 25		 jmp	 SHORT $LN21@Wipe35Gutm
$LN12@Wipe35Gutm:

; 90   : 	{
; 91   : 	case 5:
; 92   : 		memset (buffer, 0x55, size);

  0002f	52		 push	 edx
  00030	6a 55		 push	 85			; 00000055H

; 93   : 		break;

  00032	eb 20		 jmp	 SHORT $LN21@Wipe35Gutm
$LN17@Wipe35Gutm:

; 85   : 	byte wipePat3[] = { 0x92, 0x49, 0x24 };
; 86   : 	int wipePat3Pos;
; 87   : 	size_t i;
; 88   : 
; 89   : 	switch (pass)

  00034	8b c1		 mov	 eax, ecx
  00036	83 e8 1b	 sub	 eax, 27			; 0000001bH
  00039	74 31		 je	 SHORT $LN9@Wipe35Gutm
  0003b	48		 dec	 eax
  0003c	74 29		 je	 SHORT $LN8@Wipe35Gutm
$LN20@Wipe35Gutm:
  0003e	48		 dec	 eax
  0003f	74 22		 je	 SHORT $LN10@Wipe35Gutm
  00041	48		 dec	 eax
  00042	74 28		 je	 SHORT $LN9@Wipe35Gutm
  00044	48		 dec	 eax
  00045	74 20		 je	 SHORT $LN8@Wipe35Gutm

; 128  : 		}
; 129  : 		break;
; 130  : 
; 131  : 	default:
; 132  : 		if (pass >= 10 && pass <= 25)

  00047	8d 41 f6	 lea	 eax, DWORD PTR [ecx-10]
  0004a	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  0004d	77 10		 ja	 SHORT $LN2@Wipe35Gutm

; 133  : 			memset (buffer, (pass - 10) * 0x11, size);

  0004f	6b c0 11	 imul	 eax, 17			; 00000011H
  00052	52		 push	 edx
  00053	50		 push	 eax
$LN21@Wipe35Gutm:
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 _memset
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 134  : 		else

  0005d	eb 3f		 jmp	 SHORT $LN4@Wipe35Gutm
$LN2@Wipe35Gutm:

; 135  : 			return FALSE;

  0005f	33 c0		 xor	 eax, eax
  00061	eb 3e		 jmp	 SHORT $LN15@Wipe35Gutm
$LN10@Wipe35Gutm:

; 98   : 
; 99   : 	case 7:
; 100  : 	case 26:
; 101  : 	case 29:
; 102  : 		wipePat3Pos = 0;

  00063	33 f6		 xor	 esi, esi

; 103  : 		goto wipe3;

  00065	eb 08		 jmp	 SHORT $wipe3$24819
$LN8@Wipe35Gutm:

; 109  : 		goto wipe3;
; 110  : 
; 111  : 	case 9:
; 112  : 	case 28:
; 113  : 	case 31:
; 114  : 		wipePat3Pos = 2;

  00067	6a 02		 push	 2
  00069	5e		 pop	 esi
  0006a	eb 03		 jmp	 SHORT $wipe3$24819
$LN9@Wipe35Gutm:

; 104  : 
; 105  : 	case 8:
; 106  : 	case 27:
; 107  : 	case 30:
; 108  : 		wipePat3Pos = 1;

  0006c	33 f6		 xor	 esi, esi
  0006e	46		 inc	 esi
$wipe3$24819:

; 115  : 		goto wipe3;
; 116  : 
; 117  : wipe3:
; 118  : 		if (pass >= 29)

  0006f	83 f9 1d	 cmp	 ecx, 29			; 0000001dH
  00072	7c 0c		 jl	 SHORT $LN7@Wipe35Gutm

; 119  : 		{
; 120  : 			wipePat3[0] = ~wipePat3[0];

  00074	c6 45 fc 6d	 mov	 BYTE PTR _wipePat3$[ebp], 109 ; 0000006dH

; 121  : 			wipePat3[1] = ~wipePat3[1];

  00078	c6 45 fd b6	 mov	 BYTE PTR _wipePat3$[ebp+1], 182 ; 000000b6H

; 122  : 			wipePat3[2] = ~wipePat3[2];

  0007c	c6 45 fe db	 mov	 BYTE PTR _wipePat3$[ebp+2], 219 ; 000000dbH
$LN7@Wipe35Gutm:

; 123  : 		}
; 124  : 
; 125  : 		for (i = 0; i < size; ++i)

  00080	33 c9		 xor	 ecx, ecx
  00082	85 d2		 test	 edx, edx
  00084	76 18		 jbe	 SHORT $LN4@Wipe35Gutm
  00086	53		 push	 ebx
$LL6@Wipe35Gutm:

; 126  : 		{
; 127  : 			buffer[i] = wipePat3[wipePat3Pos++ % 3];

  00087	8b c6		 mov	 eax, esi
  00089	99		 cdq
  0008a	6a 03		 push	 3
  0008c	5b		 pop	 ebx
  0008d	f7 fb		 idiv	 ebx
  0008f	46		 inc	 esi
  00090	8a 44 15 fc	 mov	 al, BYTE PTR _wipePat3$[ebp+edx]
  00094	88 04 39	 mov	 BYTE PTR [ecx+edi], al
  00097	41		 inc	 ecx
  00098	3b 4d 08	 cmp	 ecx, DWORD PTR _size$[ebp]
  0009b	72 ea		 jb	 SHORT $LL6@Wipe35Gutm
  0009d	5b		 pop	 ebx
$LN4@Wipe35Gutm:

; 136  : 	}
; 137  : 
; 138  : 	return TRUE;

  0009e	33 c0		 xor	 eax, eax
  000a0	40		 inc	 eax
$LN15@Wipe35Gutm:
  000a1	5e		 pop	 esi

; 139  : }

  000a2	c9		 leave
  000a3	c2 04 00	 ret	 4
_Wipe35Gutmann@12 ENDP
_TEXT	ENDS
PUBLIC	_GetWipePassCount@4
EXTRN	__imp__KeBugCheckEx@20:PROC
; Function compile flags: /Ogsp
;	COMDAT _GetWipePassCount@4
_TEXT	SEGMENT
_algorithm$ = 8						; size = 4
_GetWipePassCount@4 PROC				; COMDAT

; 143  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 144  : 	switch (algorithm)

  00005	8b 45 08	 mov	 eax, DWORD PTR _algorithm$[ebp]
  00008	83 f8 64	 cmp	 eax, 100		; 00000064H
  0000b	74 38		 je	 SHORT $LN5@GetWipePas
  0000d	3d 2c 01 00 00	 cmp	 eax, 300		; 0000012cH
  00012	74 2c		 je	 SHORT $LN4@GetWipePas
  00014	3d bc 02 00 00	 cmp	 eax, 700		; 000002bcH
  00019	74 21		 je	 SHORT $LN3@GetWipePas
  0001b	3d ac 0d 00 00	 cmp	 eax, 3500		; 00000dacH
  00020	74 16		 je	 SHORT $LN2@GetWipePas

; 157  : 
; 158  : 	default:
; 159  : 		TC_THROW_FATAL_EXCEPTION;

  00022	68 43 54 00 00	 push	 21571			; 00005443H
  00027	6a 00		 push	 0
  00029	6a 00		 push	 0
  0002b	68 9f 00 00 00	 push	 159			; 0000009fH
  00030	6a 29		 push	 41			; 00000029H
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN12@GetWipePas:
$LN2@GetWipePas:

; 154  : 
; 155  : 	case TC_WIPE_35_GUTMANN:
; 156  : 		return 35;

  00038	6a 23		 push	 35			; 00000023H
  0003a	eb 06		 jmp	 SHORT $LN11@GetWipePas
$LN3@GetWipePas:

; 151  : 
; 152  : 	case TC_WIPE_7_DOD_5220:
; 153  : 		return 7;

  0003c	6a 07		 push	 7
  0003e	eb 02		 jmp	 SHORT $LN11@GetWipePas
$LN4@GetWipePas:

; 148  : 
; 149  : 	case TC_WIPE_3_DOD_5220:
; 150  : 		return 3;

  00040	6a 03		 push	 3
$LN11@GetWipePas:
  00042	58		 pop	 eax
  00043	eb 03		 jmp	 SHORT $LN8@GetWipePas
$LN5@GetWipePas:

; 145  : 	{
; 146  : 	case TC_WIPE_1_RAND:
; 147  : 		return 1;

  00045	33 c0		 xor	 eax, eax
  00047	40		 inc	 eax
$LN8@GetWipePas:

; 160  : 	}
; 161  : 
; 162  : 	return 0;	// Prevent compiler warnings
; 163  : }

  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
$LN10@GetWipePas:
_GetWipePassCount@4 ENDP
_TEXT	ENDS
PUBLIC	_WipeBuffer@20
; Function compile flags: /Ogsp
;	COMDAT _WipeBuffer@20
_TEXT	SEGMENT
_algorithm$ = 8						; size = 4
_randChars$ = 12					; size = 4
_pass$ = 16						; size = 4
_buffer$ = 20						; size = 4
_size$ = 24						; size = 4
_WipeBuffer@20 PROC					; COMDAT

; 167  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 168  : 	switch (algorithm)

  00005	8b 45 08	 mov	 eax, DWORD PTR _algorithm$[ebp]
  00008	83 f8 64	 cmp	 eax, 100		; 00000064H
  0000b	74 76		 je	 SHORT $LN5@WipeBuffer
  0000d	3d 2c 01 00 00	 cmp	 eax, 300		; 0000012cH
  00012	74 49		 je	 SHORT $LN4@WipeBuffer
  00014	3d bc 02 00 00	 cmp	 eax, 700		; 000002bcH
  00019	74 2f		 je	 SHORT $LN3@WipeBuffer
  0001b	3d ac 0d 00 00	 cmp	 eax, 3500		; 00000dacH
  00020	74 16		 je	 SHORT $LN2@WipeBuffer

; 181  : 
; 182  : 	default:
; 183  : 		TC_THROW_FATAL_EXCEPTION;

  00022	68 43 54 00 00	 push	 21571			; 00005443H
  00027	6a 00		 push	 0
  00029	6a 00		 push	 0
  0002b	68 b7 00 00 00	 push	 183			; 000000b7H
  00030	6a 29		 push	 41			; 00000029H
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN20@WipeBuffer:
$LN2@WipeBuffer:

; 178  : 
; 179  : 	case TC_WIPE_35_GUTMANN:
; 180  : 		return Wipe35Gutmann (pass, buffer, size);

  00038	8b 4d 10	 mov	 ecx, DWORD PTR _pass$[ebp]
  0003b	57		 push	 edi
  0003c	ff 75 18	 push	 DWORD PTR _size$[ebp]
  0003f	8b 7d 14	 mov	 edi, DWORD PTR _buffer$[ebp]
  00042	e8 00 00 00 00	 call	 _Wipe35Gutmann@12
  00047	5f		 pop	 edi
  00048	eb 3b		 jmp	 SHORT $LN8@WipeBuffer
$LN3@WipeBuffer:

; 175  : 
; 176  : 	case TC_WIPE_7_DOD_5220:
; 177  : 		return Wipe7Dod5220 (pass, randChars, buffer, size);

  0004a	ff 75 18	 push	 DWORD PTR _size$[ebp]
  0004d	8b 45 0c	 mov	 eax, DWORD PTR _randChars$[ebp]
  00050	ff 75 14	 push	 DWORD PTR _buffer$[ebp]
  00053	8b 4d 10	 mov	 ecx, DWORD PTR _pass$[ebp]
  00056	e8 00 00 00 00	 call	 _Wipe7Dod5220@16
  0005b	eb 28		 jmp	 SHORT $LN8@WipeBuffer
$LN4@WipeBuffer:

; 172  : 
; 173  : 	case TC_WIPE_3_DOD_5220:
; 174  : 		return Wipe3Dod5220 (pass, buffer, size);

  0005d	8b 45 10	 mov	 eax, DWORD PTR _pass$[ebp]
  00060	48		 dec	 eax
  00061	74 07		 je	 SHORT $LN14@WipeBuffer
  00063	48		 dec	 eax
  00064	75 1d		 jne	 SHORT $LN5@WipeBuffer
  00066	0c ff		 or	 al, 255			; 000000ffH
  00068	eb 02		 jmp	 SHORT $LN15@WipeBuffer
$LN14@WipeBuffer:
  0006a	32 c0		 xor	 al, al
$LN15@WipeBuffer:
  0006c	ff 75 18	 push	 DWORD PTR _size$[ebp]
  0006f	0f b6 c0	 movzx	 eax, al
  00072	50		 push	 eax
  00073	ff 75 14	 push	 DWORD PTR _buffer$[ebp]
  00076	e8 00 00 00 00	 call	 _memset
  0007b	33 c0		 xor	 eax, eax
  0007d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00080	40		 inc	 eax
  00081	eb 02		 jmp	 SHORT $LN8@WipeBuffer
$LN5@WipeBuffer:

; 169  : 	{
; 170  : 	case TC_WIPE_1_RAND:
; 171  : 		return Wipe1PseudoRandom (pass, buffer, size);

  00083	33 c0		 xor	 eax, eax
$LN8@WipeBuffer:

; 184  : 	}
; 185  : 
; 186  : 	return FALSE;	// Prevent compiler warnings
; 187  : }

  00085	5d		 pop	 ebp
  00086	c2 14 00	 ret	 20			; 00000014H
$LN19@WipeBuffer:
_WipeBuffer@20 ENDP
_TEXT	ENDS
END
