; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\home\public\desktop\projects\ciphershed\src\common\pkcs5.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_RtlSecureZeroMemory@8
; Function compile flags: /Ogsp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
;	COMDAT _RtlSecureZeroMemory@8
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory@8 PROC				; COMDAT

; 8322 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 8323 :     volatile char *vptr = (volatile char *)ptr;
; 8324 : 
; 8325 : #if defined(_M_AMD64)
; 8326 : 
; 8327 :         __stosb((PUCHAR)((ULONG64)vptr), 0, cnt);
; 8328 : 
; 8329 : #else
; 8330 : 
; 8331 :     while (cnt) {

  00005	83 7d 0c 00	 cmp	 DWORD PTR _cnt$[ebp], 0
  00009	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  0000c	74 09		 je	 SHORT $LN1@RtlSecureZ
$LL2@RtlSecureZ:

; 8332 :         *vptr = 0;

  0000e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 8333 :         vptr++;

  00011	40		 inc	 eax

; 8334 :         cnt--;

  00012	ff 4d 0c	 dec	 DWORD PTR _cnt$[ebp]
  00015	75 f7		 jne	 SHORT $LL2@RtlSecureZ
$LN1@RtlSecureZ:

; 8335 :     }
; 8336 : 
; 8337 : #endif
; 8338 : 
; 8339 :     return ptr;

  00017	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]

; 8340 : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
_RtlSecureZeroMemory@8 ENDP
_TEXT	ENDS
PUBLIC	_hmac_truncate@12
; Function compile flags: /Ogsp
; File c:\home\public\desktop\projects\ciphershed\src\common\pkcs5.c
;	COMDAT _hmac_truncate@12
_TEXT	SEGMENT
_d1$ = 8						; size = 4
_d2$ = 12						; size = 4
_len$ = 16						; size = 4
_hmac_truncate@12 PROC					; COMDAT

; 30   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 31   : 	int i;
; 32   : 	for (i = 0; i < len; i++)

  00006	8b 75 10	 mov	 esi, DWORD PTR _len$[ebp]
  00009	85 f6		 test	 esi, esi
  0000b	7e 11		 jle	 SHORT $LN1@hmac_trunc
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR _d2$[ebp]
  00010	8b 45 08	 mov	 eax, DWORD PTR _d1$[ebp]
  00013	2b c1		 sub	 eax, ecx
$LL3@hmac_trunc:

; 33   : 		d2[i] = d1[i];

  00015	8a 14 08	 mov	 dl, BYTE PTR [eax+ecx]
  00018	88 11		 mov	 BYTE PTR [ecx], dl
  0001a	41		 inc	 ecx
  0001b	4e		 dec	 esi
  0001c	75 f7		 jne	 SHORT $LL3@hmac_trunc
$LN1@hmac_trunc:
  0001e	5e		 pop	 esi

; 34   : }

  0001f	5d		 pop	 ebp
  00020	c2 0c 00	 ret	 12			; 0000000cH
_hmac_truncate@12 ENDP
_TEXT	ENDS
PUBLIC	_out$GSCopy$
PUBLIC	_d$GSCopy$
PUBLIC	_k$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_hmac_sha512@24
EXTRN	_sha512_end@8:PROC
EXTRN	_sha512_hash@12:PROC
EXTRN	_sha512_begin@4:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogsp
;	COMDAT _hmac_sha512@24
_TEXT	SEGMENT
_tctx$26985 = -964					; size = 208
_octx$ = -756						; size = 208
_ictx$ = -548						; size = 208
_out$GSCopy$ = -340					; size = 4
_d$GSCopy$ = -336					; size = 4
_k$GSCopy$ = -332					; size = 4
tv491 = -328						; size = 4
_burnc$26993 = -328					; size = 4
_isha$ = -324						; size = 64
_key$ = -260						; size = 64
_osha$ = -196						; size = 64
_buf$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_lk$ = 12						; size = 4
_d$ = 16						; size = 4
_ld$ = 20						; size = 4
_out$ = 24						; size = 4
_t$ = 28						; size = 4
_hmac_sha512@24 PROC					; COMDAT

; 47   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec c4 03 00
	00		 sub	 esp, 964		; 000003c4H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]
  00018	53		 push	 ebx
  00019	56		 push	 esi

; 48   : 	sha512_ctx ictx, octx;
; 49   : 	char isha[SHA512_DIGESTSIZE], osha[SHA512_DIGESTSIZE];
; 50   : 	char key[SHA512_DIGESTSIZE];
; 51   : 	char buf[SHA512_BLOCKSIZE];
; 52   : 	int i;
; 53   : 
; 54   :     /* If the key is longer than the hash algorithm block size,
; 55   : 	   let key = sha512(key), as per HMAC specifications. */
; 56   : 	if (lk > SHA512_BLOCKSIZE)

  0001a	8b 75 0c	 mov	 esi, DWORD PTR _lk$[ebp]

; 108  : 	burn (buf, sizeof(buf));

  0001d	89 85 b4 fe ff
	ff		 mov	 DWORD PTR _k$GSCopy$[ebp], eax
  00023	8b 45 10	 mov	 eax, DWORD PTR _d$[ebp]
  00026	57		 push	 edi
  00027	bf d0 00 00 00	 mov	 edi, 208		; 000000d0H
  0002c	89 85 b0 fe ff
	ff		 mov	 DWORD PTR _d$GSCopy$[ebp], eax
  00032	8b 45 18	 mov	 eax, DWORD PTR _out$[ebp]
  00035	8d 5f b0	 lea	 ebx, DWORD PTR [edi-80]
  00038	3b f3		 cmp	 esi, ebx
  0003a	89 85 ac fe ff
	ff		 mov	 DWORD PTR _out$GSCopy$[ebp], eax
  00040	7e 6b		 jle	 SHORT $LN45@hmac_sha51
  00042	8d 85 3c fc ff
	ff		 lea	 eax, DWORD PTR _tctx$26985[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _sha512_begin@4
  0004e	8d 85 3c fc ff
	ff		 lea	 eax, DWORD PTR _tctx$26985[ebp]
  00054	50		 push	 eax
  00055	56		 push	 esi
  00056	ff b5 b4 fe ff
	ff		 push	 DWORD PTR _k$GSCopy$[ebp]
  0005c	e8 00 00 00 00	 call	 _sha512_hash@12
  00061	8d 85 3c fc ff
	ff		 lea	 eax, DWORD PTR _tctx$26985[ebp]
  00067	50		 push	 eax
  00068	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _key$[ebp]
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _sha512_end@8
  00074	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _key$[ebp]
  0007a	6a 40		 push	 64			; 00000040H
  0007c	8d 8d 3c fc ff
	ff		 lea	 ecx, DWORD PTR _tctx$26985[ebp]
  00082	89 85 b4 fe ff
	ff		 mov	 DWORD PTR _k$GSCopy$[ebp], eax
  00088	5e		 pop	 esi
  00089	89 bd b8 fe ff
	ff		 mov	 DWORD PTR _burnc$26993[ebp], edi
  0008f	8b d7		 mov	 edx, edi
  00091	8b c1		 mov	 eax, ecx
$LL54@hmac_sha51:
  00093	c6 00 00	 mov	 BYTE PTR [eax], 0
  00096	40		 inc	 eax
  00097	4a		 dec	 edx
  00098	75 f9		 jne	 SHORT $LL54@hmac_sha51
$LL44@hmac_sha51:

; 57   : 	{
; 58   : 		sha512_ctx tctx;
; 59   : 
; 60   : 		sha512_begin (&tctx);
; 61   : 		sha512_hash ((unsigned char *) k, lk, &tctx);
; 62   : 		sha512_end ((unsigned char *) key, &tctx);
; 63   : 
; 64   : 		k = key;
; 65   : 		lk = SHA512_DIGESTSIZE;
; 66   : 
; 67   : 		burn (&tctx, sizeof(tctx));		// Prevent leaks

  0009a	ff 8d b8 fe ff
	ff		 dec	 DWORD PTR _burnc$26993[ebp]
  000a0	c6 01 00	 mov	 BYTE PTR [ecx], 0
  000a3	41		 inc	 ecx
  000a4	83 bd b8 fe ff
	ff 00		 cmp	 DWORD PTR _burnc$26993[ebp], 0
  000ab	75 ed		 jne	 SHORT $LL44@hmac_sha51
$LN45@hmac_sha51:

; 68   : 	}
; 69   : 
; 70   : 	/**** Inner Digest ****/
; 71   : 
; 72   : 	sha512_begin (&ictx);

  000ad	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _ictx$[ebp]
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 _sha512_begin@4

; 73   : 
; 74   : 	/* Pad the key for inner digest */
; 75   : 	for (i = 0; i < lk; ++i)

  000b9	33 c9		 xor	 ecx, ecx
  000bb	85 f6		 test	 esi, esi
  000bd	7e 30		 jle	 SHORT $LN40@hmac_sha51
  000bf	8b 95 b4 fe ff
	ff		 mov	 edx, DWORD PTR _k$GSCopy$[ebp]
  000c5	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  000cb	2b d0		 sub	 edx, eax
  000cd	89 95 b8 fe ff
	ff		 mov	 DWORD PTR tv491[ebp], edx
  000d3	eb 06		 jmp	 SHORT $LN42@hmac_sha51
$LL157@hmac_sha51:
  000d5	8b 95 b8 fe ff
	ff		 mov	 edx, DWORD PTR tv491[ebp]
$LN42@hmac_sha51:

; 76   : 		buf[i] = (char) (k[i] ^ 0x36);

  000db	8d 84 0d 7c ff
	ff ff		 lea	 eax, DWORD PTR _buf$[ebp+ecx]
  000e2	8a 14 02	 mov	 dl, BYTE PTR [edx+eax]
  000e5	80 f2 36	 xor	 dl, 54			; 00000036H
  000e8	41		 inc	 ecx
  000e9	3b ce		 cmp	 ecx, esi
  000eb	88 10		 mov	 BYTE PTR [eax], dl
  000ed	7c e6		 jl	 SHORT $LL157@hmac_sha51
$LN40@hmac_sha51:

; 77   : 	for (i = lk; i < SHA512_BLOCKSIZE; ++i)

  000ef	3b f3		 cmp	 esi, ebx
  000f1	7d 17		 jge	 SHORT $LN39@hmac_sha51
  000f3	8b cb		 mov	 ecx, ebx
  000f5	2b ce		 sub	 ecx, esi
  000f7	51		 push	 ecx
  000f8	8d 84 35 7c ff
	ff ff		 lea	 eax, DWORD PTR _buf$[ebp+esi]
  000ff	6a 36		 push	 54			; 00000036H
  00101	50		 push	 eax
  00102	e8 00 00 00 00	 call	 _memset
  00107	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN39@hmac_sha51:

; 78   : 		buf[i] = 0x36;
; 79   : 
; 80   : 	sha512_hash ((unsigned char *) buf, SHA512_BLOCKSIZE, &ictx);

  0010a	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _ictx$[ebp]
  00110	50		 push	 eax
  00111	53		 push	 ebx
  00112	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 _sha512_hash@12

; 81   : 	sha512_hash ((unsigned char *) d, ld, &ictx);

  0011e	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _ictx$[ebp]
  00124	50		 push	 eax
  00125	ff 75 14	 push	 DWORD PTR _ld$[ebp]
  00128	ff b5 b0 fe ff
	ff		 push	 DWORD PTR _d$GSCopy$[ebp]
  0012e	e8 00 00 00 00	 call	 _sha512_hash@12

; 82   : 
; 83   : 	sha512_end ((unsigned char *) isha, &ictx);

  00133	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _ictx$[ebp]
  00139	50		 push	 eax
  0013a	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _isha$[ebp]
  00140	50		 push	 eax
  00141	e8 00 00 00 00	 call	 _sha512_end@8

; 84   : 
; 85   : 	/**** Outer Digest ****/
; 86   : 
; 87   : 	sha512_begin (&octx);

  00146	8d 85 0c fd ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  0014c	50		 push	 eax
  0014d	e8 00 00 00 00	 call	 _sha512_begin@4

; 88   : 
; 89   : 	for (i = 0; i < lk; ++i)

  00152	33 c9		 xor	 ecx, ecx
  00154	85 f6		 test	 esi, esi
  00156	7e 30		 jle	 SHORT $LN34@hmac_sha51
  00158	8b 95 b4 fe ff
	ff		 mov	 edx, DWORD PTR _k$GSCopy$[ebp]
  0015e	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  00164	2b d0		 sub	 edx, eax
  00166	89 95 b8 fe ff
	ff		 mov	 DWORD PTR tv491[ebp], edx
  0016c	eb 06		 jmp	 SHORT $LN36@hmac_sha51
$LL156@hmac_sha51:
  0016e	8b 95 b8 fe ff
	ff		 mov	 edx, DWORD PTR tv491[ebp]
$LN36@hmac_sha51:

; 90   : 		buf[i] = (char) (k[i] ^ 0x5C);

  00174	8d 84 0d 7c ff
	ff ff		 lea	 eax, DWORD PTR _buf$[ebp+ecx]
  0017b	8a 14 02	 mov	 dl, BYTE PTR [edx+eax]
  0017e	80 f2 5c	 xor	 dl, 92			; 0000005cH
  00181	41		 inc	 ecx
  00182	3b ce		 cmp	 ecx, esi
  00184	88 10		 mov	 BYTE PTR [eax], dl
  00186	7c e6		 jl	 SHORT $LL156@hmac_sha51
$LN34@hmac_sha51:

; 91   : 	for (i = lk; i < SHA512_BLOCKSIZE; ++i)

  00188	3b f3		 cmp	 esi, ebx
  0018a	7d 17		 jge	 SHORT $LN33@hmac_sha51
  0018c	8b cb		 mov	 ecx, ebx
  0018e	2b ce		 sub	 ecx, esi
  00190	51		 push	 ecx
  00191	8d 84 35 7c ff
	ff ff		 lea	 eax, DWORD PTR _buf$[ebp+esi]
  00198	6a 5c		 push	 92			; 0000005cH
  0019a	50		 push	 eax
  0019b	e8 00 00 00 00	 call	 _memset
  001a0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN33@hmac_sha51:

; 92   : 		buf[i] = 0x5C;
; 93   : 
; 94   : 	sha512_hash ((unsigned char *) buf, SHA512_BLOCKSIZE, &octx);

  001a3	8d 85 0c fd ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  001a9	50		 push	 eax
  001aa	53		 push	 ebx
  001ab	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  001b1	50		 push	 eax
  001b2	e8 00 00 00 00	 call	 _sha512_hash@12

; 95   : 	sha512_hash ((unsigned char *) isha, SHA512_DIGESTSIZE, &octx);

  001b7	8d 85 0c fd ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  001bd	50		 push	 eax
  001be	6a 40		 push	 64			; 00000040H
  001c0	5e		 pop	 esi
  001c1	56		 push	 esi
  001c2	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _isha$[ebp]
  001c8	50		 push	 eax
  001c9	e8 00 00 00 00	 call	 _sha512_hash@12

; 96   : 
; 97   : 	sha512_end ((unsigned char *) osha, &octx);

  001ce	8d 85 0c fd ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  001d4	50		 push	 eax
  001d5	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _osha$[ebp]
  001db	50		 push	 eax
  001dc	e8 00 00 00 00	 call	 _sha512_end@8

; 98   : 
; 99   : 	/* truncate and print the results */
; 100  : 	t = t > SHA512_DIGESTSIZE ? SHA512_DIGESTSIZE : t;

  001e1	39 75 1c	 cmp	 DWORD PTR _t$[ebp], esi
  001e4	7e 03		 jle	 SHORT $LN51@hmac_sha51
  001e6	89 75 1c	 mov	 DWORD PTR _t$[ebp], esi
$LN51@hmac_sha51:

; 101  : 	hmac_truncate (osha, out, t);

  001e9	ff 75 1c	 push	 DWORD PTR _t$[ebp]
  001ec	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _osha$[ebp]
  001f2	ff b5 ac fe ff
	ff		 push	 DWORD PTR _out$GSCopy$[ebp]
  001f8	50		 push	 eax
  001f9	e8 00 00 00 00	 call	 _hmac_truncate@12

; 102  : 
; 103  : 	/* Prevent leaks */
; 104  : 	burn (&ictx, sizeof(ictx));

  001fe	8d 8d dc fd ff
	ff		 lea	 ecx, DWORD PTR _ictx$[ebp]
  00204	8b d7		 mov	 edx, edi
  00206	8b f7		 mov	 esi, edi
  00208	8b c1		 mov	 eax, ecx
$LL58@hmac_sha51:
  0020a	c6 00 00	 mov	 BYTE PTR [eax], 0
  0020d	40		 inc	 eax
  0020e	4e		 dec	 esi
  0020f	75 f9		 jne	 SHORT $LL58@hmac_sha51
$LL27@hmac_sha51:
  00211	4a		 dec	 edx
  00212	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00215	41		 inc	 ecx
  00216	85 d2		 test	 edx, edx
  00218	75 f7		 jne	 SHORT $LL27@hmac_sha51

; 105  : 	burn (&octx, sizeof(octx));

  0021a	8d 8d 0c fd ff
	ff		 lea	 ecx, DWORD PTR _octx$[ebp]
  00220	8b d7		 mov	 edx, edi
  00222	8b c1		 mov	 eax, ecx
$LL62@hmac_sha51:
  00224	c6 00 00	 mov	 BYTE PTR [eax], 0
  00227	40		 inc	 eax
  00228	4f		 dec	 edi
  00229	75 f9		 jne	 SHORT $LL62@hmac_sha51
$LL22@hmac_sha51:
  0022b	4a		 dec	 edx
  0022c	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0022f	41		 inc	 ecx
  00230	85 d2		 test	 edx, edx
  00232	75 f7		 jne	 SHORT $LL22@hmac_sha51

; 106  : 	burn (isha, sizeof(isha));

  00234	6a 40		 push	 64			; 00000040H
  00236	5a		 pop	 edx
  00237	8d 8d bc fe ff
	ff		 lea	 ecx, DWORD PTR _isha$[ebp]
  0023d	8b f2		 mov	 esi, edx
  0023f	8b fa		 mov	 edi, edx
  00241	8b c1		 mov	 eax, ecx
$LL66@hmac_sha51:
  00243	c6 00 00	 mov	 BYTE PTR [eax], 0
  00246	40		 inc	 eax
  00247	4f		 dec	 edi
  00248	75 f9		 jne	 SHORT $LL66@hmac_sha51
$LL17@hmac_sha51:
  0024a	4e		 dec	 esi
  0024b	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0024e	41		 inc	 ecx
  0024f	85 f6		 test	 esi, esi
  00251	75 f7		 jne	 SHORT $LL17@hmac_sha51

; 107  : 	burn (osha, sizeof(osha));

  00253	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR _osha$[ebp]
  00259	8b f2		 mov	 esi, edx
  0025b	8b fa		 mov	 edi, edx
  0025d	8b c1		 mov	 eax, ecx
$LL70@hmac_sha51:
  0025f	c6 00 00	 mov	 BYTE PTR [eax], 0
  00262	40		 inc	 eax
  00263	4f		 dec	 edi
  00264	75 f9		 jne	 SHORT $LL70@hmac_sha51
$LL12@hmac_sha51:
  00266	4e		 dec	 esi
  00267	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0026a	41		 inc	 ecx
  0026b	85 f6		 test	 esi, esi
  0026d	75 f7		 jne	 SHORT $LL12@hmac_sha51

; 108  : 	burn (buf, sizeof(buf));

  0026f	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _buf$[ebp]
  00275	8b f3		 mov	 esi, ebx
  00277	8b c1		 mov	 eax, ecx
$LL74@hmac_sha51:
  00279	c6 00 00	 mov	 BYTE PTR [eax], 0
  0027c	40		 inc	 eax
  0027d	4b		 dec	 ebx
  0027e	75 f9		 jne	 SHORT $LL74@hmac_sha51
$LL7@hmac_sha51:
  00280	4e		 dec	 esi
  00281	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00284	41		 inc	 ecx
  00285	85 f6		 test	 esi, esi
  00287	75 f7		 jne	 SHORT $LL7@hmac_sha51

; 109  : 	burn (key, sizeof(key));

  00289	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _key$[ebp]
  0028f	8b f2		 mov	 esi, edx
  00291	8b c1		 mov	 eax, ecx
$LL78@hmac_sha51:
  00293	c6 00 00	 mov	 BYTE PTR [eax], 0
  00296	40		 inc	 eax
  00297	4a		 dec	 edx
  00298	75 f9		 jne	 SHORT $LL78@hmac_sha51
$LL2@hmac_sha51:
  0029a	4e		 dec	 esi
  0029b	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0029e	41		 inc	 ecx
  0029f	85 f6		 test	 esi, esi
  002a1	75 f7		 jne	 SHORT $LL2@hmac_sha51

; 110  : }

  002a3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002a6	5f		 pop	 edi
  002a7	5e		 pop	 esi
  002a8	33 cd		 xor	 ecx, ebp
  002aa	5b		 pop	 ebx
  002ab	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b0	c9		 leave
  002b1	c2 18 00	 ret	 24			; 00000018H
_hmac_sha512@24 ENDP
_TEXT	ENDS
PUBLIC	_pwd$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_derive_u_sha512@28
EXTRN	_memcpy:PROC
; Function compile flags: /Ogsp
;	COMDAT _derive_u_sha512@28
_TEXT	SEGMENT
_pwd$GSCopy$ = -268					; size = 4
_counter$ = -264					; size = 4
_init$ = -260						; size = 128
_k$ = -132						; size = 64
_j$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_u$ = 28						; size = 4
_b$ = 32						; size = 4
_derive_u_sha512@28 PROC				; COMDAT

; 114  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	8b 45 08	 mov	 eax, DWORD PTR _pwd$[ebp]
  00018	8b 4d 10	 mov	 ecx, DWORD PTR _salt$[ebp]
  0001b	53		 push	 ebx
  0001c	8b 5d 1c	 mov	 ebx, DWORD PTR _u$[ebp]
  0001f	56		 push	 esi
  00020	8b 75 14	 mov	 esi, DWORD PTR _salt_len$[ebp]
  00023	57		 push	 edi

; 115  : 	char j[SHA512_DIGESTSIZE], k[SHA512_DIGESTSIZE];
; 116  : 	char init[128];
; 117  : 	char counter[4];
; 118  : 	int c, i;
; 119  : 
; 120  : 	/* iteration 1 */
; 121  : 	memset (counter, 0, 4);
; 122  : 	counter[3] = (char) b;
; 123  : 	memcpy (init, salt, salt_len);	/* salt */
; 124  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */
; 125  : 	hmac_sha512 (pwd, pwd_len, init, salt_len + 4, j, SHA512_DIGESTSIZE);
; 126  : 	memcpy (u, j, SHA512_DIGESTSIZE);
; 127  : 
; 128  : 	/* remaining iterations */
; 129  : 	for (c = 1; c < iterations; c++)

  00024	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _pwd$GSCopy$[ebp], eax
  0002a	33 c0		 xor	 eax, eax
  0002c	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR _counter$[ebp]
  00032	ab		 stosd
  00033	8a 45 20	 mov	 al, BYTE PTR _b$[ebp]
  00036	56		 push	 esi
  00037	88 85 fb fe ff
	ff		 mov	 BYTE PTR _counter$[ebp+3], al
  0003d	51		 push	 ecx
  0003e	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _init$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _memcpy
  0004a	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _counter$[ebp]
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	6a 40		 push	 64			; 00000040H
  00055	89 84 35 fc fe
	ff ff		 mov	 DWORD PTR _init$[ebp+esi], eax
  0005c	8d 45 bc	 lea	 eax, DWORD PTR _j$[ebp]
  0005f	50		 push	 eax
  00060	83 c6 04	 add	 esi, 4
  00063	56		 push	 esi
  00064	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _init$[ebp]
  0006a	50		 push	 eax
  0006b	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  0006e	ff b5 f4 fe ff
	ff		 push	 DWORD PTR _pwd$GSCopy$[ebp]
  00074	e8 00 00 00 00	 call	 _hmac_sha512@24
  00079	8b 45 18	 mov	 eax, DWORD PTR _iterations$[ebp]
  0007c	83 f8 01	 cmp	 eax, 1
  0007f	6a 10		 push	 16			; 00000010H
  00081	59		 pop	 ecx
  00082	8d 75 bc	 lea	 esi, DWORD PTR _j$[ebp]
  00085	8b fb		 mov	 edi, ebx
  00087	f3 a5		 rep movsd
  00089	7e 47		 jle	 SHORT $LN47@derive_u_s
  0008b	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _k$[ebp]
  00091	2b d9		 sub	 ebx, ecx
  00093	8d 78 ff	 lea	 edi, DWORD PTR [eax-1]
$LL16@derive_u_s:

; 130  : 	{
; 131  : 		hmac_sha512 (pwd, pwd_len, j, SHA512_DIGESTSIZE, k, SHA512_DIGESTSIZE);

  00096	6a 40		 push	 64			; 00000040H
  00098	5e		 pop	 esi
  00099	56		 push	 esi
  0009a	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _k$[ebp]
  000a0	50		 push	 eax
  000a1	56		 push	 esi
  000a2	8d 45 bc	 lea	 eax, DWORD PTR _j$[ebp]
  000a5	50		 push	 eax
  000a6	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  000a9	ff b5 f4 fe ff
	ff		 push	 DWORD PTR _pwd$GSCopy$[ebp]
  000af	e8 00 00 00 00	 call	 _hmac_sha512@24

; 132  : 		for (i = 0; i < SHA512_DIGESTSIZE; i++)

  000b4	33 d2		 xor	 edx, edx
$LL13@derive_u_s:

; 133  : 		{
; 134  : 			u[i] ^= k[i];

  000b6	8d 84 15 7c ff
	ff ff		 lea	 eax, DWORD PTR _k$[ebp+edx]
  000bd	8d 0c 03	 lea	 ecx, DWORD PTR [ebx+eax]
  000c0	8a 00		 mov	 al, BYTE PTR [eax]
  000c2	30 01		 xor	 BYTE PTR [ecx], al

; 135  : 			j[i] = k[i];

  000c4	88 44 15 bc	 mov	 BYTE PTR _j$[ebp+edx], al
  000c8	42		 inc	 edx
  000c9	3b d6		 cmp	 edx, esi
  000cb	7c e9		 jl	 SHORT $LL13@derive_u_s

; 115  : 	char j[SHA512_DIGESTSIZE], k[SHA512_DIGESTSIZE];
; 116  : 	char init[128];
; 117  : 	char counter[4];
; 118  : 	int c, i;
; 119  : 
; 120  : 	/* iteration 1 */
; 121  : 	memset (counter, 0, 4);
; 122  : 	counter[3] = (char) b;
; 123  : 	memcpy (init, salt, salt_len);	/* salt */
; 124  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */
; 125  : 	hmac_sha512 (pwd, pwd_len, init, salt_len + 4, j, SHA512_DIGESTSIZE);
; 126  : 	memcpy (u, j, SHA512_DIGESTSIZE);
; 127  : 
; 128  : 	/* remaining iterations */
; 129  : 	for (c = 1; c < iterations; c++)

  000cd	4f		 dec	 edi
  000ce	75 c6		 jne	 SHORT $LL16@derive_u_s
  000d0	eb 03		 jmp	 SHORT $LN10@derive_u_s
$LN47@derive_u_s:
  000d2	6a 40		 push	 64			; 00000040H
  000d4	5e		 pop	 esi
$LN10@derive_u_s:

; 136  : 		}
; 137  : 	}
; 138  : 
; 139  : 	/* Prevent possible leaks. */
; 140  : 	burn (j, sizeof(j));

  000d5	8d 4d bc	 lea	 ecx, DWORD PTR _j$[ebp]
  000d8	8b d6		 mov	 edx, esi
  000da	8b fe		 mov	 edi, esi
  000dc	8b c1		 mov	 eax, ecx
$LL20@derive_u_s:
  000de	c6 00 00	 mov	 BYTE PTR [eax], 0
  000e1	40		 inc	 eax
  000e2	4f		 dec	 edi
  000e3	75 f9		 jne	 SHORT $LL20@derive_u_s
$LL7@derive_u_s:
  000e5	4a		 dec	 edx
  000e6	c6 01 00	 mov	 BYTE PTR [ecx], 0
  000e9	41		 inc	 ecx
  000ea	85 d2		 test	 edx, edx
  000ec	75 f7		 jne	 SHORT $LL7@derive_u_s

; 141  : 	burn (k, sizeof(k));

  000ee	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _k$[ebp]
  000f4	8b d6		 mov	 edx, esi
  000f6	8b c1		 mov	 eax, ecx
$LL24@derive_u_s:
  000f8	c6 00 00	 mov	 BYTE PTR [eax], 0
  000fb	40		 inc	 eax
  000fc	4e		 dec	 esi
  000fd	75 f9		 jne	 SHORT $LL24@derive_u_s
  000ff	5f		 pop	 edi
  00100	5e		 pop	 esi
  00101	5b		 pop	 ebx
$LL2@derive_u_s:
  00102	4a		 dec	 edx
  00103	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00106	41		 inc	 ecx
  00107	85 d2		 test	 edx, edx
  00109	75 f7		 jne	 SHORT $LL2@derive_u_s

; 142  : }

  0010b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010e	33 cd		 xor	 ecx, ebp
  00110	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00115	c9		 leave
  00116	c2 1c 00	 ret	 28			; 0000001cH
_derive_u_sha512@28 ENDP
_TEXT	ENDS
PUBLIC	_dk$GSCopy$
PUBLIC	_salt$GSCopy$
PUBLIC	_pwd$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_derive_key_sha512@28
; Function compile flags: /Ogsp
;	COMDAT _derive_key_sha512@28
_TEXT	SEGMENT
_r$ = -88						; size = 4
_pwd$GSCopy$ = -84					; size = 4
_salt$GSCopy$ = -80					; size = 4
_dk$GSCopy$ = -76					; size = 4
_b$ = -72						; size = 4
_u$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_dk$ = 28						; size = 4
_dklen$ = 32						; size = 4
_derive_key_sha512@28 PROC				; COMDAT

; 146  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 58	 sub	 esp, 88			; 00000058H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 157  : 	}
; 158  : 
; 159  : 	r = dklen - (l - 1) * SHA512_DIGESTSIZE;

  00012	8b 45 08	 mov	 eax, DWORD PTR _pwd$[ebp]
  00015	8b 4d 20	 mov	 ecx, DWORD PTR _dklen$[ebp]
  00018	89 45 ac	 mov	 DWORD PTR _pwd$GSCopy$[ebp], eax
  0001b	8b 45 10	 mov	 eax, DWORD PTR _salt$[ebp]
  0001e	89 45 b0	 mov	 DWORD PTR _salt$GSCopy$[ebp], eax
  00021	8b 45 1c	 mov	 eax, DWORD PTR _dk$[ebp]
  00024	89 45 b4	 mov	 DWORD PTR _dk$GSCopy$[ebp], eax
  00027	8b c1		 mov	 eax, ecx
  00029	25 3f 00 00 80	 and	 eax, -2147483585	; 8000003fH
  0002e	53		 push	 ebx
  0002f	56		 push	 esi
  00030	79 05		 jns	 SHORT $LN28@derive_key
  00032	48		 dec	 eax
  00033	83 c8 c0	 or	 eax, -64		; ffffffc0H
  00036	40		 inc	 eax
$LN28@derive_key:
  00037	8b c1		 mov	 eax, ecx
  00039	99		 cdq
  0003a	74 0d		 je	 SHORT $LN10@derive_key
  0003c	83 e2 3f	 and	 edx, 63			; 0000003fH
  0003f	03 c2		 add	 eax, edx
  00041	8b d8		 mov	 ebx, eax
  00043	c1 fb 06	 sar	 ebx, 6
  00046	43		 inc	 ebx
  00047	eb 0a		 jmp	 SHORT $LN9@derive_key
$LN10@derive_key:

; 147  : 	char u[SHA512_DIGESTSIZE];
; 148  : 	int b, l, r;
; 149  : 
; 150  : 	if (dklen % SHA512_DIGESTSIZE)
; 151  : 	{
; 152  : 		l = 1 + dklen / SHA512_DIGESTSIZE;
; 153  : 	}
; 154  : 	else
; 155  : 	{
; 156  : 		l = dklen / SHA512_DIGESTSIZE;

  00049	83 e2 3f	 and	 edx, 63			; 0000003fH
  0004c	03 c2		 add	 eax, edx
  0004e	8b d8		 mov	 ebx, eax
  00050	c1 fb 06	 sar	 ebx, 6
$LN9@derive_key:

; 157  : 	}
; 158  : 
; 159  : 	r = dklen - (l - 1) * SHA512_DIGESTSIZE;

  00053	8b c3		 mov	 eax, ebx
  00055	c1 e0 06	 shl	 eax, 6
  00058	2b c8		 sub	 ecx, eax

; 160  : 
; 161  : 	/* first l - 1 blocks */
; 162  : 	for (b = 1; b < l; b++)

  0005a	33 c0		 xor	 eax, eax
  0005c	40		 inc	 eax
  0005d	83 c1 40	 add	 ecx, 64			; 00000040H
  00060	3b d8		 cmp	 ebx, eax
  00062	89 4d a8	 mov	 DWORD PTR _r$[ebp], ecx
  00065	89 45 b8	 mov	 DWORD PTR _b$[ebp], eax
  00068	7e 34		 jle	 SHORT $LN6@derive_key
  0006a	57		 push	 edi
$LL26@derive_key:

; 163  : 	{
; 164  : 		derive_u_sha512 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  0006b	ff 75 b8	 push	 DWORD PTR _b$[ebp]
  0006e	8d 45 bc	 lea	 eax, DWORD PTR _u$[ebp]
  00071	50		 push	 eax
  00072	ff 75 18	 push	 DWORD PTR _iterations$[ebp]
  00075	ff 75 14	 push	 DWORD PTR _salt_len$[ebp]
  00078	ff 75 b0	 push	 DWORD PTR _salt$GSCopy$[ebp]
  0007b	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  0007e	ff 75 ac	 push	 DWORD PTR _pwd$GSCopy$[ebp]
  00081	e8 00 00 00 00	 call	 _derive_u_sha512@28

; 165  : 		memcpy (dk, u, SHA512_DIGESTSIZE);

  00086	8b 7d b4	 mov	 edi, DWORD PTR _dk$GSCopy$[ebp]

; 166  : 		dk += SHA512_DIGESTSIZE;

  00089	83 45 b4 40	 add	 DWORD PTR _dk$GSCopy$[ebp], 64 ; 00000040H
  0008d	ff 45 b8	 inc	 DWORD PTR _b$[ebp]
  00090	39 5d b8	 cmp	 DWORD PTR _b$[ebp], ebx
  00093	6a 10		 push	 16			; 00000010H
  00095	59		 pop	 ecx
  00096	8d 75 bc	 lea	 esi, DWORD PTR _u$[ebp]
  00099	f3 a5		 rep movsd
  0009b	7c ce		 jl	 SHORT $LL26@derive_key
  0009d	5f		 pop	 edi
$LN6@derive_key:

; 167  : 	}
; 168  : 
; 169  : 	/* last block */
; 170  : 	derive_u_sha512 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  0009e	ff 75 b8	 push	 DWORD PTR _b$[ebp]
  000a1	8d 45 bc	 lea	 eax, DWORD PTR _u$[ebp]
  000a4	50		 push	 eax
  000a5	ff 75 18	 push	 DWORD PTR _iterations$[ebp]
  000a8	ff 75 14	 push	 DWORD PTR _salt_len$[ebp]
  000ab	ff 75 b0	 push	 DWORD PTR _salt$GSCopy$[ebp]
  000ae	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  000b1	ff 75 ac	 push	 DWORD PTR _pwd$GSCopy$[ebp]
  000b4	e8 00 00 00 00	 call	 _derive_u_sha512@28

; 171  : 	memcpy (dk, u, r);

  000b9	ff 75 a8	 push	 DWORD PTR _r$[ebp]
  000bc	8d 45 bc	 lea	 eax, DWORD PTR _u$[ebp]
  000bf	50		 push	 eax
  000c0	ff 75 b4	 push	 DWORD PTR _dk$GSCopy$[ebp]
  000c3	e8 00 00 00 00	 call	 _memcpy
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 172  : 
; 173  : 
; 174  : 	/* Prevent possible leaks. */
; 175  : 	burn (u, sizeof(u));

  000cb	6a 40		 push	 64			; 00000040H
  000cd	8d 4d bc	 lea	 ecx, DWORD PTR _u$[ebp]
  000d0	5e		 pop	 esi
  000d1	8b d6		 mov	 edx, esi
  000d3	8b c1		 mov	 eax, ecx
$LL14@derive_key:
  000d5	c6 00 00	 mov	 BYTE PTR [eax], 0
  000d8	40		 inc	 eax
  000d9	4e		 dec	 esi
  000da	75 f9		 jne	 SHORT $LL14@derive_key
  000dc	5e		 pop	 esi
  000dd	5b		 pop	 ebx
$LL2@derive_key:
  000de	4a		 dec	 edx
  000df	c6 01 00	 mov	 BYTE PTR [ecx], 0
  000e2	41		 inc	 ecx
  000e3	85 d2		 test	 edx, edx
  000e5	75 f7		 jne	 SHORT $LL2@derive_key

; 176  : }

  000e7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ea	33 cd		 xor	 ecx, ebp
  000ec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f1	c9		 leave
  000f2	c2 1c 00	 ret	 28			; 0000001cH
_derive_key_sha512@28 ENDP
_TEXT	ENDS
PUBLIC	_out$GSCopy$
PUBLIC	_d$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_hmac_sha1@24
EXTRN	_sha1_end@8:PROC
EXTRN	_sha1_hash@12:PROC
EXTRN	_sha1_begin@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _hmac_sha1@24
_TEXT	SEGMENT
_tctx$27171 = -416					; size = 92
_octx$ = -324						; size = 92
_ictx$ = -232						; size = 92
_out$GSCopy$ = -140					; size = 4
_d$GSCopy$ = -136					; size = 4
_burnc$27179 = -132					; size = 4
_buf$ = -128						; size = 64
_isha$ = -64						; size = 20
_key$ = -44						; size = 20
_osha$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_lk$ = 12						; size = 4
_d$ = 16						; size = 4
_ld$ = 20						; size = 4
_out$ = 24						; size = 4
_t$ = 28						; size = 4
_hmac_sha1@24 PROC					; COMDAT

; 189  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec a0 01 00
	00		 sub	 esp, 416		; 000001a0H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 251  : 	burn (key, sizeof(key));

  00015	8b 45 10	 mov	 eax, DWORD PTR _d$[ebp]
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	8b 75 0c	 mov	 esi, DWORD PTR _lk$[ebp]
  0001d	83 fe 40	 cmp	 esi, 64			; 00000040H
  00020	57		 push	 edi
  00021	8b 7d 08	 mov	 edi, DWORD PTR _k$[ebp]
  00024	89 85 78 ff ff
	ff		 mov	 DWORD PTR _d$GSCopy$[ebp], eax
  0002a	8b 45 18	 mov	 eax, DWORD PTR _out$[ebp]
  0002d	6a 5c		 push	 92			; 0000005cH
  0002f	89 85 74 ff ff
	ff		 mov	 DWORD PTR _out$GSCopy$[ebp], eax
  00035	5b		 pop	 ebx
  00036	7e 5a		 jle	 SHORT $LN45@hmac_sha1
  00038	8d 85 60 fe ff
	ff		 lea	 eax, DWORD PTR _tctx$27171[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 _sha1_begin@4
  00044	8d 85 60 fe ff
	ff		 lea	 eax, DWORD PTR _tctx$27171[ebp]
  0004a	50		 push	 eax
  0004b	56		 push	 esi
  0004c	57		 push	 edi
  0004d	e8 00 00 00 00	 call	 _sha1_hash@12
  00052	8d 85 60 fe ff
	ff		 lea	 eax, DWORD PTR _tctx$27171[ebp]
  00058	50		 push	 eax
  00059	8d 45 d4	 lea	 eax, DWORD PTR _key$[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 _sha1_end@8
  00062	6a 14		 push	 20			; 00000014H
  00064	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR _tctx$27171[ebp]
  0006a	8d 7d d4	 lea	 edi, DWORD PTR _key$[ebp]
  0006d	5e		 pop	 esi
  0006e	89 9d 7c ff ff
	ff		 mov	 DWORD PTR _burnc$27179[ebp], ebx
  00074	8b d3		 mov	 edx, ebx
  00076	8b c1		 mov	 eax, ecx
$LL54@hmac_sha1:
  00078	c6 00 00	 mov	 BYTE PTR [eax], 0
  0007b	40		 inc	 eax
  0007c	4a		 dec	 edx
  0007d	75 f9		 jne	 SHORT $LL54@hmac_sha1
$LL44@hmac_sha1:

; 190  : 	sha1_ctx ictx, octx;
; 191  : 	char isha[SHA1_DIGESTSIZE], osha[SHA1_DIGESTSIZE];
; 192  : 	char key[SHA1_DIGESTSIZE];
; 193  : 	char buf[SHA1_BLOCKSIZE];
; 194  : 	int i;
; 195  : 
; 196  :     /* If the key is longer than the hash algorithm block size,
; 197  : 	   let key = sha1(key), as per HMAC specifications. */
; 198  : 	if (lk > SHA1_BLOCKSIZE)
; 199  : 	{
; 200  : 		sha1_ctx tctx;
; 201  : 
; 202  : 		sha1_begin (&tctx);
; 203  : 		sha1_hash ((unsigned char *) k, lk, &tctx);
; 204  : 		sha1_end ((unsigned char *) key, &tctx);
; 205  : 
; 206  : 		k = key;
; 207  : 		lk = SHA1_DIGESTSIZE;
; 208  : 
; 209  : 		burn (&tctx, sizeof(tctx));		// Prevent leaks

  0007f	ff 8d 7c ff ff
	ff		 dec	 DWORD PTR _burnc$27179[ebp]
  00085	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00088	41		 inc	 ecx
  00089	83 bd 7c ff ff
	ff 00		 cmp	 DWORD PTR _burnc$27179[ebp], 0
  00090	75 ed		 jne	 SHORT $LL44@hmac_sha1
$LN45@hmac_sha1:

; 210  : 	}
; 211  : 
; 212  : 	/**** Inner Digest ****/
; 213  : 
; 214  : 	sha1_begin (&ictx);

  00092	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _ictx$[ebp]
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 _sha1_begin@4

; 215  : 
; 216  : 	/* Pad the key for inner digest */
; 217  : 	for (i = 0; i < lk; ++i)

  0009e	33 c9		 xor	 ecx, ecx
  000a0	85 f6		 test	 esi, esi
  000a2	7e 1b		 jle	 SHORT $LN40@hmac_sha1
  000a4	8b d7		 mov	 edx, edi
  000a6	8d 45 80	 lea	 eax, DWORD PTR _buf$[ebp]
  000a9	2b d0		 sub	 edx, eax
$LL42@hmac_sha1:

; 218  : 		buf[i] = (char) (k[i] ^ 0x36);

  000ab	8d 44 0d 80	 lea	 eax, DWORD PTR _buf$[ebp+ecx]
  000af	8a 1c 02	 mov	 bl, BYTE PTR [edx+eax]
  000b2	80 f3 36	 xor	 bl, 54			; 00000036H
  000b5	41		 inc	 ecx
  000b6	3b ce		 cmp	 ecx, esi
  000b8	88 18		 mov	 BYTE PTR [eax], bl
  000ba	7c ef		 jl	 SHORT $LL42@hmac_sha1
  000bc	6a 5c		 push	 92			; 0000005cH
  000be	5b		 pop	 ebx
$LN40@hmac_sha1:

; 219  : 	for (i = lk; i < SHA1_BLOCKSIZE; ++i)

  000bf	83 fe 40	 cmp	 esi, 64			; 00000040H
  000c2	7d 15		 jge	 SHORT $LN39@hmac_sha1
  000c4	6a 40		 push	 64			; 00000040H
  000c6	59		 pop	 ecx
  000c7	2b ce		 sub	 ecx, esi
  000c9	51		 push	 ecx
  000ca	8d 44 35 80	 lea	 eax, DWORD PTR _buf$[ebp+esi]
  000ce	6a 36		 push	 54			; 00000036H
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 _memset
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN39@hmac_sha1:

; 220  : 		buf[i] = 0x36;
; 221  : 
; 222  : 	sha1_hash ((unsigned char *) buf, SHA1_BLOCKSIZE, &ictx);

  000d9	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _ictx$[ebp]
  000df	50		 push	 eax
  000e0	6a 40		 push	 64			; 00000040H
  000e2	8d 45 80	 lea	 eax, DWORD PTR _buf$[ebp]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 _sha1_hash@12

; 223  : 	sha1_hash ((unsigned char *) d, ld, &ictx);

  000eb	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _ictx$[ebp]
  000f1	50		 push	 eax
  000f2	ff 75 14	 push	 DWORD PTR _ld$[ebp]
  000f5	ff b5 78 ff ff
	ff		 push	 DWORD PTR _d$GSCopy$[ebp]
  000fb	e8 00 00 00 00	 call	 _sha1_hash@12

; 224  : 
; 225  : 	sha1_end ((unsigned char *) isha, &ictx);

  00100	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _ictx$[ebp]
  00106	50		 push	 eax
  00107	8d 45 c0	 lea	 eax, DWORD PTR _isha$[ebp]
  0010a	50		 push	 eax
  0010b	e8 00 00 00 00	 call	 _sha1_end@8

; 226  : 
; 227  : 	/**** Outer Digest ****/
; 228  : 
; 229  : 	sha1_begin (&octx);

  00110	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  00116	50		 push	 eax
  00117	e8 00 00 00 00	 call	 _sha1_begin@4

; 230  : 
; 231  : 	for (i = 0; i < lk; ++i)

  0011c	33 c9		 xor	 ecx, ecx
  0011e	85 f6		 test	 esi, esi
  00120	7e 15		 jle	 SHORT $LN34@hmac_sha1
  00122	8d 45 80	 lea	 eax, DWORD PTR _buf$[ebp]
  00125	2b f8		 sub	 edi, eax
$LL36@hmac_sha1:

; 232  : 		buf[i] = (char) (k[i] ^ 0x5C);

  00127	8d 44 0d 80	 lea	 eax, DWORD PTR _buf$[ebp+ecx]
  0012b	8a 14 07	 mov	 dl, BYTE PTR [edi+eax]
  0012e	32 d3		 xor	 dl, bl
  00130	41		 inc	 ecx
  00131	3b ce		 cmp	 ecx, esi
  00133	88 10		 mov	 BYTE PTR [eax], dl
  00135	7c f0		 jl	 SHORT $LL36@hmac_sha1
$LN34@hmac_sha1:

; 233  : 	for (i = lk; i < SHA1_BLOCKSIZE; ++i)

  00137	83 fe 40	 cmp	 esi, 64			; 00000040H
  0013a	7d 14		 jge	 SHORT $LN33@hmac_sha1
  0013c	6a 40		 push	 64			; 00000040H
  0013e	59		 pop	 ecx
  0013f	2b ce		 sub	 ecx, esi
  00141	51		 push	 ecx
  00142	8d 44 35 80	 lea	 eax, DWORD PTR _buf$[ebp+esi]
  00146	53		 push	 ebx
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 _memset
  0014d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN33@hmac_sha1:

; 234  : 		buf[i] = 0x5C;
; 235  : 
; 236  : 	sha1_hash ((unsigned char *) buf, SHA1_BLOCKSIZE, &octx);

  00150	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  00156	50		 push	 eax
  00157	6a 40		 push	 64			; 00000040H
  00159	8d 45 80	 lea	 eax, DWORD PTR _buf$[ebp]
  0015c	50		 push	 eax
  0015d	e8 00 00 00 00	 call	 _sha1_hash@12

; 237  : 	sha1_hash ((unsigned char *) isha, SHA1_DIGESTSIZE, &octx);

  00162	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  00168	50		 push	 eax
  00169	6a 14		 push	 20			; 00000014H
  0016b	5f		 pop	 edi
  0016c	57		 push	 edi
  0016d	8d 45 c0	 lea	 eax, DWORD PTR _isha$[ebp]
  00170	50		 push	 eax
  00171	e8 00 00 00 00	 call	 _sha1_hash@12

; 238  : 
; 239  : 	sha1_end ((unsigned char *) osha, &octx);

  00176	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  0017c	50		 push	 eax
  0017d	8d 45 e8	 lea	 eax, DWORD PTR _osha$[ebp]
  00180	50		 push	 eax
  00181	e8 00 00 00 00	 call	 _sha1_end@8

; 240  : 
; 241  : 	/* truncate and print the results */
; 242  : 	t = t > SHA1_DIGESTSIZE ? SHA1_DIGESTSIZE : t;

  00186	39 7d 1c	 cmp	 DWORD PTR _t$[ebp], edi
  00189	7e 03		 jle	 SHORT $LN51@hmac_sha1
  0018b	89 7d 1c	 mov	 DWORD PTR _t$[ebp], edi
$LN51@hmac_sha1:

; 243  : 	hmac_truncate (osha, out, t);

  0018e	ff 75 1c	 push	 DWORD PTR _t$[ebp]
  00191	8d 45 e8	 lea	 eax, DWORD PTR _osha$[ebp]
  00194	ff b5 74 ff ff
	ff		 push	 DWORD PTR _out$GSCopy$[ebp]
  0019a	50		 push	 eax
  0019b	e8 00 00 00 00	 call	 _hmac_truncate@12

; 244  : 
; 245  : 	/* Prevent leaks */
; 246  : 	burn (&ictx, sizeof(ictx));

  001a0	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _ictx$[ebp]
  001a6	8b d3		 mov	 edx, ebx
  001a8	8b f3		 mov	 esi, ebx
  001aa	8b c1		 mov	 eax, ecx
$LL58@hmac_sha1:
  001ac	c6 00 00	 mov	 BYTE PTR [eax], 0
  001af	40		 inc	 eax
  001b0	4e		 dec	 esi
  001b1	75 f9		 jne	 SHORT $LL58@hmac_sha1
$LL27@hmac_sha1:
  001b3	4a		 dec	 edx
  001b4	c6 01 00	 mov	 BYTE PTR [ecx], 0
  001b7	41		 inc	 ecx
  001b8	85 d2		 test	 edx, edx
  001ba	75 f7		 jne	 SHORT $LL27@hmac_sha1

; 247  : 	burn (&octx, sizeof(octx));

  001bc	8d 8d bc fe ff
	ff		 lea	 ecx, DWORD PTR _octx$[ebp]
  001c2	8b d3		 mov	 edx, ebx
  001c4	8b c1		 mov	 eax, ecx
$LL62@hmac_sha1:
  001c6	c6 00 00	 mov	 BYTE PTR [eax], 0
  001c9	40		 inc	 eax
  001ca	4b		 dec	 ebx
  001cb	75 f9		 jne	 SHORT $LL62@hmac_sha1
$LL22@hmac_sha1:
  001cd	4a		 dec	 edx
  001ce	c6 01 00	 mov	 BYTE PTR [ecx], 0
  001d1	41		 inc	 ecx
  001d2	85 d2		 test	 edx, edx
  001d4	75 f7		 jne	 SHORT $LL22@hmac_sha1

; 248  : 	burn (isha, sizeof(isha));

  001d6	8d 4d c0	 lea	 ecx, DWORD PTR _isha$[ebp]
  001d9	8b d7		 mov	 edx, edi
  001db	8b f7		 mov	 esi, edi
  001dd	8b c1		 mov	 eax, ecx
$LL66@hmac_sha1:
  001df	c6 00 00	 mov	 BYTE PTR [eax], 0
  001e2	40		 inc	 eax
  001e3	4e		 dec	 esi
  001e4	75 f9		 jne	 SHORT $LL66@hmac_sha1
$LL17@hmac_sha1:
  001e6	4a		 dec	 edx
  001e7	c6 01 00	 mov	 BYTE PTR [ecx], 0
  001ea	41		 inc	 ecx
  001eb	85 d2		 test	 edx, edx
  001ed	75 f7		 jne	 SHORT $LL17@hmac_sha1

; 249  : 	burn (osha, sizeof(osha));

  001ef	8d 4d e8	 lea	 ecx, DWORD PTR _osha$[ebp]
  001f2	8b d7		 mov	 edx, edi
  001f4	8b f7		 mov	 esi, edi
  001f6	8b c1		 mov	 eax, ecx
$LL70@hmac_sha1:
  001f8	c6 00 00	 mov	 BYTE PTR [eax], 0
  001fb	40		 inc	 eax
  001fc	4e		 dec	 esi
  001fd	75 f9		 jne	 SHORT $LL70@hmac_sha1
$LL12@hmac_sha1:
  001ff	4a		 dec	 edx
  00200	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00203	41		 inc	 ecx
  00204	85 d2		 test	 edx, edx
  00206	75 f7		 jne	 SHORT $LL12@hmac_sha1

; 250  : 	burn (buf, sizeof(buf));

  00208	6a 40		 push	 64			; 00000040H
  0020a	8d 4d 80	 lea	 ecx, DWORD PTR _buf$[ebp]
  0020d	5e		 pop	 esi
  0020e	8b d6		 mov	 edx, esi
  00210	8b c1		 mov	 eax, ecx
$LL74@hmac_sha1:
  00212	c6 00 00	 mov	 BYTE PTR [eax], 0
  00215	40		 inc	 eax
  00216	4e		 dec	 esi
  00217	75 f9		 jne	 SHORT $LL74@hmac_sha1
$LL7@hmac_sha1:
  00219	4a		 dec	 edx
  0021a	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0021d	41		 inc	 ecx
  0021e	85 d2		 test	 edx, edx
  00220	75 f7		 jne	 SHORT $LL7@hmac_sha1

; 251  : 	burn (key, sizeof(key));

  00222	8d 4d d4	 lea	 ecx, DWORD PTR _key$[ebp]
  00225	8b d7		 mov	 edx, edi
  00227	8b f7		 mov	 esi, edi
  00229	8b c1		 mov	 eax, ecx
$LL78@hmac_sha1:
  0022b	c6 00 00	 mov	 BYTE PTR [eax], 0
  0022e	40		 inc	 eax
  0022f	4e		 dec	 esi
  00230	75 f9		 jne	 SHORT $LL78@hmac_sha1
  00232	5f		 pop	 edi
  00233	5e		 pop	 esi
  00234	5b		 pop	 ebx
$LL2@hmac_sha1:
  00235	4a		 dec	 edx
  00236	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00239	41		 inc	 ecx
  0023a	85 d2		 test	 edx, edx
  0023c	75 f7		 jne	 SHORT $LL2@hmac_sha1

; 252  : }

  0023e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00241	33 cd		 xor	 ecx, ebp
  00243	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00248	c9		 leave
  00249	c2 18 00	 ret	 24			; 00000018H
_hmac_sha1@24 ENDP
_TEXT	ENDS
PUBLIC	_pwd$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_derive_u_sha1@28
; Function compile flags: /Ogsp
;	COMDAT _derive_u_sha1@28
_TEXT	SEGMENT
_pwd$GSCopy$ = -180					; size = 4
_counter$ = -176					; size = 4
_init$ = -172						; size = 128
_k$ = -44						; size = 20
_j$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_u$ = 28						; size = 4
_b$ = 32						; size = 4
_derive_u_sha1@28 PROC					; COMDAT

; 257  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	8b 45 08	 mov	 eax, DWORD PTR _pwd$[ebp]
  00018	8b 4d 10	 mov	 ecx, DWORD PTR _salt$[ebp]
  0001b	53		 push	 ebx
  0001c	8b 5d 1c	 mov	 ebx, DWORD PTR _u$[ebp]
  0001f	56		 push	 esi
  00020	8b 75 14	 mov	 esi, DWORD PTR _salt_len$[ebp]
  00023	57		 push	 edi

; 258  : 	char j[SHA1_DIGESTSIZE], k[SHA1_DIGESTSIZE];
; 259  : 	char init[128];
; 260  : 	char counter[4];
; 261  : 	int c, i;
; 262  : 
; 263  : 	/* iteration 1 */
; 264  : 	memset (counter, 0, 4);
; 265  : 	counter[3] = (char) b;
; 266  : 	memcpy (init, salt, salt_len);	/* salt */
; 267  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */
; 268  : 	hmac_sha1 (pwd, pwd_len, init, salt_len + 4, j, SHA1_DIGESTSIZE);
; 269  : 	memcpy (u, j, SHA1_DIGESTSIZE);
; 270  : 
; 271  : 	/* remaining iterations */
; 272  : 	for (c = 1; c < iterations; c++)

  00024	89 85 4c ff ff
	ff		 mov	 DWORD PTR _pwd$GSCopy$[ebp], eax
  0002a	33 c0		 xor	 eax, eax
  0002c	8d bd 50 ff ff
	ff		 lea	 edi, DWORD PTR _counter$[ebp]
  00032	ab		 stosd
  00033	8a 45 20	 mov	 al, BYTE PTR _b$[ebp]
  00036	56		 push	 esi
  00037	88 85 53 ff ff
	ff		 mov	 BYTE PTR _counter$[ebp+3], al
  0003d	51		 push	 ecx
  0003e	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _init$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _memcpy
  0004a	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _counter$[ebp]
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	6a 14		 push	 20			; 00000014H
  00055	89 84 35 54 ff
	ff ff		 mov	 DWORD PTR _init$[ebp+esi], eax
  0005c	8d 45 e8	 lea	 eax, DWORD PTR _j$[ebp]
  0005f	50		 push	 eax
  00060	83 c6 04	 add	 esi, 4
  00063	56		 push	 esi
  00064	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _init$[ebp]
  0006a	50		 push	 eax
  0006b	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  0006e	ff b5 4c ff ff
	ff		 push	 DWORD PTR _pwd$GSCopy$[ebp]
  00074	e8 00 00 00 00	 call	 _hmac_sha1@24
  00079	8b 45 18	 mov	 eax, DWORD PTR _iterations$[ebp]
  0007c	83 f8 01	 cmp	 eax, 1
  0007f	6a 05		 push	 5
  00081	59		 pop	 ecx
  00082	8d 75 e8	 lea	 esi, DWORD PTR _j$[ebp]
  00085	8b fb		 mov	 edi, ebx
  00087	f3 a5		 rep movsd
  00089	7e 3e		 jle	 SHORT $LN47@derive_u_s@2
  0008b	8d 4d d4	 lea	 ecx, DWORD PTR _k$[ebp]
  0008e	2b d9		 sub	 ebx, ecx
  00090	8d 78 ff	 lea	 edi, DWORD PTR [eax-1]
$LL16@derive_u_s@2:

; 273  : 	{
; 274  : 		hmac_sha1 (pwd, pwd_len, j, SHA1_DIGESTSIZE, k, SHA1_DIGESTSIZE);

  00093	6a 14		 push	 20			; 00000014H
  00095	5e		 pop	 esi
  00096	56		 push	 esi
  00097	8d 45 d4	 lea	 eax, DWORD PTR _k$[ebp]
  0009a	50		 push	 eax
  0009b	56		 push	 esi
  0009c	8d 45 e8	 lea	 eax, DWORD PTR _j$[ebp]
  0009f	50		 push	 eax
  000a0	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  000a3	ff b5 4c ff ff
	ff		 push	 DWORD PTR _pwd$GSCopy$[ebp]
  000a9	e8 00 00 00 00	 call	 _hmac_sha1@24

; 275  : 		for (i = 0; i < SHA1_DIGESTSIZE; i++)

  000ae	33 d2		 xor	 edx, edx
$LL13@derive_u_s@2:

; 276  : 		{
; 277  : 			u[i] ^= k[i];

  000b0	8d 44 15 d4	 lea	 eax, DWORD PTR _k$[ebp+edx]
  000b4	8d 0c 03	 lea	 ecx, DWORD PTR [ebx+eax]
  000b7	8a 00		 mov	 al, BYTE PTR [eax]
  000b9	30 01		 xor	 BYTE PTR [ecx], al

; 278  : 			j[i] = k[i];

  000bb	88 44 15 e8	 mov	 BYTE PTR _j$[ebp+edx], al
  000bf	42		 inc	 edx
  000c0	3b d6		 cmp	 edx, esi
  000c2	7c ec		 jl	 SHORT $LL13@derive_u_s@2

; 258  : 	char j[SHA1_DIGESTSIZE], k[SHA1_DIGESTSIZE];
; 259  : 	char init[128];
; 260  : 	char counter[4];
; 261  : 	int c, i;
; 262  : 
; 263  : 	/* iteration 1 */
; 264  : 	memset (counter, 0, 4);
; 265  : 	counter[3] = (char) b;
; 266  : 	memcpy (init, salt, salt_len);	/* salt */
; 267  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */
; 268  : 	hmac_sha1 (pwd, pwd_len, init, salt_len + 4, j, SHA1_DIGESTSIZE);
; 269  : 	memcpy (u, j, SHA1_DIGESTSIZE);
; 270  : 
; 271  : 	/* remaining iterations */
; 272  : 	for (c = 1; c < iterations; c++)

  000c4	4f		 dec	 edi
  000c5	75 cc		 jne	 SHORT $LL16@derive_u_s@2
  000c7	eb 03		 jmp	 SHORT $LN10@derive_u_s@2
$LN47@derive_u_s@2:
  000c9	6a 14		 push	 20			; 00000014H
  000cb	5e		 pop	 esi
$LN10@derive_u_s@2:

; 279  : 		}
; 280  : 	}
; 281  : 
; 282  : 	/* Prevent possible leaks. */
; 283  : 	burn (j, sizeof(j));

  000cc	8d 4d e8	 lea	 ecx, DWORD PTR _j$[ebp]
  000cf	8b d6		 mov	 edx, esi
  000d1	8b fe		 mov	 edi, esi
  000d3	8b c1		 mov	 eax, ecx
$LL20@derive_u_s@2:
  000d5	c6 00 00	 mov	 BYTE PTR [eax], 0
  000d8	40		 inc	 eax
  000d9	4f		 dec	 edi
  000da	75 f9		 jne	 SHORT $LL20@derive_u_s@2
$LL7@derive_u_s@2:
  000dc	4a		 dec	 edx
  000dd	c6 01 00	 mov	 BYTE PTR [ecx], 0
  000e0	41		 inc	 ecx
  000e1	85 d2		 test	 edx, edx
  000e3	75 f7		 jne	 SHORT $LL7@derive_u_s@2

; 284  : 	burn (k, sizeof(k));

  000e5	8d 4d d4	 lea	 ecx, DWORD PTR _k$[ebp]
  000e8	8b d6		 mov	 edx, esi
  000ea	8b c1		 mov	 eax, ecx
$LL24@derive_u_s@2:
  000ec	c6 00 00	 mov	 BYTE PTR [eax], 0
  000ef	40		 inc	 eax
  000f0	4e		 dec	 esi
  000f1	75 f9		 jne	 SHORT $LL24@derive_u_s@2
  000f3	5f		 pop	 edi
  000f4	5e		 pop	 esi
  000f5	5b		 pop	 ebx
$LL2@derive_u_s@2:
  000f6	4a		 dec	 edx
  000f7	c6 01 00	 mov	 BYTE PTR [ecx], 0
  000fa	41		 inc	 ecx
  000fb	85 d2		 test	 edx, edx
  000fd	75 f7		 jne	 SHORT $LL2@derive_u_s@2

; 285  : }

  000ff	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00102	33 cd		 xor	 ecx, ebp
  00104	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00109	c9		 leave
  0010a	c2 1c 00	 ret	 28			; 0000001cH
_derive_u_sha1@28 ENDP
_TEXT	ENDS
PUBLIC	_dk$GSCopy$
PUBLIC	_salt$GSCopy$
PUBLIC	_pwd$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_derive_key_sha1@28
; Function compile flags: /Ogsp
;	COMDAT _derive_key_sha1@28
_TEXT	SEGMENT
_r$ = -44						; size = 4
_pwd$GSCopy$ = -40					; size = 4
_salt$GSCopy$ = -36					; size = 4
_l$ = -32						; size = 4
_dk$GSCopy$ = -28					; size = 4
_u$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_dk$ = 28						; size = 4
_dklen$ = 32						; size = 4
_derive_key_sha1@28 PROC				; COMDAT

; 290  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 291  : 	char u[SHA1_DIGESTSIZE];
; 292  : 	int b, l, r;
; 293  : 
; 294  : 	if (dklen % SHA1_DIGESTSIZE)
; 295  : 	{
; 296  : 		l = 1 + dklen / SHA1_DIGESTSIZE;

  00012	8b 45 08	 mov	 eax, DWORD PTR _pwd$[ebp]
  00015	8b 4d 20	 mov	 ecx, DWORD PTR _dklen$[ebp]
  00018	89 45 d8	 mov	 DWORD PTR _pwd$GSCopy$[ebp], eax
  0001b	8b 45 10	 mov	 eax, DWORD PTR _salt$[ebp]
  0001e	89 45 dc	 mov	 DWORD PTR _salt$GSCopy$[ebp], eax
  00021	8b 45 1c	 mov	 eax, DWORD PTR _dk$[ebp]
  00024	89 45 e4	 mov	 DWORD PTR _dk$GSCopy$[ebp], eax
  00027	56		 push	 esi
  00028	8b c1		 mov	 eax, ecx
  0002a	6a 14		 push	 20			; 00000014H
  0002c	99		 cdq
  0002d	5e		 pop	 esi
  0002e	f7 fe		 idiv	 esi
  00030	85 d2		 test	 edx, edx
  00032	74 01		 je	 SHORT $LN10@derive_key@2
  00034	40		 inc	 eax
$LN10@derive_key@2:

; 297  : 	}
; 298  : 	else
; 299  : 	{
; 300  : 		l = dklen / SHA1_DIGESTSIZE;

  00035	89 45 e0	 mov	 DWORD PTR _l$[ebp], eax

; 301  : 	}
; 302  : 
; 303  : 	r = dklen - (l - 1) * SHA1_DIGESTSIZE;

  00038	6b c0 14	 imul	 eax, 20			; 00000014H
  0003b	53		 push	 ebx

; 304  : 
; 305  : 	/* first l - 1 blocks */
; 306  : 	for (b = 1; b < l; b++)

  0003c	33 db		 xor	 ebx, ebx
  0003e	2b c8		 sub	 ecx, eax
  00040	83 c1 14	 add	 ecx, 20			; 00000014H
  00043	43		 inc	 ebx
  00044	39 5d e0	 cmp	 DWORD PTR _l$[ebp], ebx
  00047	89 4d d4	 mov	 DWORD PTR _r$[ebp], ecx
  0004a	7e 30		 jle	 SHORT $LN6@derive_key@2
  0004c	57		 push	 edi
$LL26@derive_key@2:

; 307  : 	{
; 308  : 		derive_u_sha1 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  0004d	53		 push	 ebx
  0004e	8d 45 e8	 lea	 eax, DWORD PTR _u$[ebp]
  00051	50		 push	 eax
  00052	ff 75 18	 push	 DWORD PTR _iterations$[ebp]
  00055	ff 75 14	 push	 DWORD PTR _salt_len$[ebp]
  00058	ff 75 dc	 push	 DWORD PTR _salt$GSCopy$[ebp]
  0005b	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  0005e	ff 75 d8	 push	 DWORD PTR _pwd$GSCopy$[ebp]
  00061	e8 00 00 00 00	 call	 _derive_u_sha1@28

; 309  : 		memcpy (dk, u, SHA1_DIGESTSIZE);

  00066	8b 7d e4	 mov	 edi, DWORD PTR _dk$GSCopy$[ebp]

; 310  : 		dk += SHA1_DIGESTSIZE;

  00069	83 45 e4 14	 add	 DWORD PTR _dk$GSCopy$[ebp], 20 ; 00000014H
  0006d	6a 05		 push	 5
  0006f	43		 inc	 ebx
  00070	3b 5d e0	 cmp	 ebx, DWORD PTR _l$[ebp]
  00073	59		 pop	 ecx
  00074	8d 75 e8	 lea	 esi, DWORD PTR _u$[ebp]
  00077	f3 a5		 rep movsd
  00079	7c d2		 jl	 SHORT $LL26@derive_key@2
  0007b	5f		 pop	 edi
$LN6@derive_key@2:

; 311  : 	}
; 312  : 
; 313  : 	/* last block */
; 314  : 	derive_u_sha1 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  0007c	53		 push	 ebx
  0007d	8d 45 e8	 lea	 eax, DWORD PTR _u$[ebp]
  00080	50		 push	 eax
  00081	ff 75 18	 push	 DWORD PTR _iterations$[ebp]
  00084	ff 75 14	 push	 DWORD PTR _salt_len$[ebp]
  00087	ff 75 dc	 push	 DWORD PTR _salt$GSCopy$[ebp]
  0008a	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  0008d	ff 75 d8	 push	 DWORD PTR _pwd$GSCopy$[ebp]
  00090	e8 00 00 00 00	 call	 _derive_u_sha1@28

; 315  : 	memcpy (dk, u, r);

  00095	ff 75 d4	 push	 DWORD PTR _r$[ebp]
  00098	8d 45 e8	 lea	 eax, DWORD PTR _u$[ebp]
  0009b	50		 push	 eax
  0009c	ff 75 e4	 push	 DWORD PTR _dk$GSCopy$[ebp]
  0009f	e8 00 00 00 00	 call	 _memcpy
  000a4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 316  : 
; 317  : 
; 318  : 	/* Prevent possible leaks. */
; 319  : 	burn (u, sizeof(u));

  000a7	6a 14		 push	 20			; 00000014H
  000a9	5e		 pop	 esi
  000aa	8d 4d e8	 lea	 ecx, DWORD PTR _u$[ebp]
  000ad	8b d6		 mov	 edx, esi
  000af	8b c1		 mov	 eax, ecx
  000b1	5b		 pop	 ebx
$LL14@derive_key@2:
  000b2	c6 00 00	 mov	 BYTE PTR [eax], 0
  000b5	40		 inc	 eax
  000b6	4e		 dec	 esi
  000b7	75 f9		 jne	 SHORT $LL14@derive_key@2
  000b9	5e		 pop	 esi
$LL2@derive_key@2:
  000ba	4a		 dec	 edx
  000bb	c6 01 00	 mov	 BYTE PTR [ecx], 0
  000be	41		 inc	 ecx
  000bf	85 d2		 test	 edx, edx
  000c1	75 f7		 jne	 SHORT $LL2@derive_key@2

; 320  : }

  000c3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c6	33 cd		 xor	 ecx, ebp
  000c8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cd	c9		 leave
  000ce	c2 1c 00	 ret	 28			; 0000001cH
_derive_key_sha1@28 ENDP
_TEXT	ENDS
PUBLIC	_digest$GSCopy$
PUBLIC	_input$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_hmac_ripemd160@20
EXTRN	_RMD160Final@8:PROC
EXTRN	_RMD160Update@12:PROC
EXTRN	_RMD160Init@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _hmac_ripemd160@20
_TEXT	SEGMENT
_input$GSCopy$ = -360					; size = 4
_digest$GSCopy$ = -356					; size = 4
_tctx$27353 = -352					; size = 96
_context$ = -256					; size = 96
_k_opad$ = -160						; size = 65
_k_ipad$ = -92						; size = 65
_tk$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_key$ = 8						; size = 4
_keylen$ = 12						; size = 4
_input$ = 16						; size = 4
_len$ = 20						; size = 4
_digest$ = 24						; size = 4
_hmac_ripemd160@20 PROC					; COMDAT

; 325  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 68 01 00
	00		 sub	 esp, 360		; 00000168H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 382  : 
; 383  : 	/* Prevent possible leaks. */
; 384  :     burn (k_ipad, sizeof(k_ipad));

  00015	8b 45 10	 mov	 eax, DWORD PTR _input$[ebp]
  00018	53		 push	 ebx
  00019	8b 5d 0c	 mov	 ebx, DWORD PTR _keylen$[ebp]
  0001c	83 fb 40	 cmp	 ebx, 64			; 00000040H
  0001f	56		 push	 esi
  00020	8b 75 08	 mov	 esi, DWORD PTR _key$[ebp]
  00023	89 85 98 fe ff
	ff		 mov	 DWORD PTR _input$GSCopy$[ebp], eax
  00029	8b 45 18	 mov	 eax, DWORD PTR _digest$[ebp]
  0002c	57		 push	 edi
  0002d	89 85 9c fe ff
	ff		 mov	 DWORD PTR _digest$GSCopy$[ebp], eax
  00033	7e 4d		 jle	 SHORT $LN26@hmac_ripem
  00035	8d 85 a0 fe ff
	ff		 lea	 eax, DWORD PTR _tctx$27353[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 _RMD160Init@4
  00041	53		 push	 ebx
  00042	56		 push	 esi
  00043	8d 85 a0 fe ff
	ff		 lea	 eax, DWORD PTR _tctx$27353[ebp]
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 _RMD160Update@12
  0004f	8d 85 a0 fe ff
	ff		 lea	 eax, DWORD PTR _tctx$27353[ebp]
  00055	50		 push	 eax
  00056	8d 45 e8	 lea	 eax, DWORD PTR _tk$[ebp]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 _RMD160Final@8
  0005f	6a 14		 push	 20			; 00000014H
  00061	5b		 pop	 ebx
  00062	6a 60		 push	 96			; 00000060H
  00064	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR _tctx$27353[ebp]
  0006a	5a		 pop	 edx
  0006b	8d 75 e8	 lea	 esi, DWORD PTR _tk$[ebp]
  0006e	8b fa		 mov	 edi, edx
  00070	8b c1		 mov	 eax, ecx
$LL33@hmac_ripem:
  00072	c6 00 00	 mov	 BYTE PTR [eax], 0
  00075	40		 inc	 eax
  00076	4f		 dec	 edi
  00077	75 f9		 jne	 SHORT $LL33@hmac_ripem
$LL25@hmac_ripem:

; 326  :     RMD160_CTX context;
; 327  :     unsigned char k_ipad[65];  /* inner padding - key XORd with ipad */
; 328  :     unsigned char k_opad[65];  /* outer padding - key XORd with opad */
; 329  :     unsigned char tk[RIPEMD160_DIGESTSIZE];
; 330  :     int i;
; 331  : 
; 332  :     /* If the key is longer than the hash algorithm block size,
; 333  : 	   let key = ripemd160(key), as per HMAC specifications. */
; 334  :     if (keylen > RIPEMD160_BLOCKSIZE) 
; 335  : 	{
; 336  :         RMD160_CTX      tctx;
; 337  : 
; 338  :         RMD160Init(&tctx);
; 339  :         RMD160Update(&tctx, (const unsigned char *) key, keylen);
; 340  :         RMD160Final(tk, &tctx);
; 341  : 
; 342  :         key = (char *) tk;
; 343  :         keylen = RIPEMD160_DIGESTSIZE;
; 344  : 
; 345  : 		burn (&tctx, sizeof(tctx));	// Prevent leaks

  00079	4a		 dec	 edx
  0007a	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0007d	41		 inc	 ecx
  0007e	85 d2		 test	 edx, edx
  00080	75 f7		 jne	 SHORT $LL25@hmac_ripem
$LN26@hmac_ripem:

; 346  :     }
; 347  : 
; 348  : 	/*
; 349  : 
; 350  : 	RMD160(K XOR opad, RMD160(K XOR ipad, text))
; 351  : 
; 352  : 	where K is an n byte key
; 353  : 	ipad is the byte 0x36 repeated RIPEMD160_BLOCKSIZE times
; 354  : 	opad is the byte 0x5c repeated RIPEMD160_BLOCKSIZE times
; 355  : 	and text is the data being protected */
; 356  : 
; 357  : 
; 358  : 	/* start out by storing key in pads */
; 359  : 	memset(k_ipad, 0x36, sizeof(k_ipad));

  00082	6a 41		 push	 65			; 00000041H
  00084	8d 45 a4	 lea	 eax, DWORD PTR _k_ipad$[ebp]
  00087	6a 36		 push	 54			; 00000036H
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 _memset

; 360  :     memset(k_opad, 0x5c, sizeof(k_opad));

  0008f	6a 41		 push	 65			; 00000041H
  00091	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _k_opad$[ebp]
  00097	6a 5c		 push	 92			; 0000005cH
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 _memset
  0009f	83 c4 18	 add	 esp, 24			; 00000018H

; 361  : 
; 362  :     /* XOR key with ipad and opad values */
; 363  :     for (i=0; i<keylen; i++) 

  000a2	85 db		 test	 ebx, ebx
  000a4	7e 1b		 jle	 SHORT $LN21@hmac_ripem
  000a6	8d 55 a4	 lea	 edx, DWORD PTR _k_ipad$[ebp]
  000a9	8d bd 60 ff ff
	ff		 lea	 edi, DWORD PTR _k_opad$[ebp]
  000af	2b d6		 sub	 edx, esi
  000b1	8b c6		 mov	 eax, esi
  000b3	2b fe		 sub	 edi, esi
$LL23@hmac_ripem:

; 364  : 	{
; 365  :         k_ipad[i] ^= key[i];

  000b5	8a 08		 mov	 cl, BYTE PTR [eax]
  000b7	30 0c 02	 xor	 BYTE PTR [edx+eax], cl

; 366  :         k_opad[i] ^= key[i];

  000ba	30 0c 07	 xor	 BYTE PTR [edi+eax], cl
  000bd	40		 inc	 eax
  000be	4b		 dec	 ebx
  000bf	75 f4		 jne	 SHORT $LL23@hmac_ripem
$LN21@hmac_ripem:

; 367  :     }
; 368  : 
; 369  :     /* perform inner RIPEMD-160 */
; 370  : 
; 371  :     RMD160Init(&context);           /* init context for 1st pass */

  000c1	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _context$[ebp]
  000c7	50		 push	 eax
  000c8	e8 00 00 00 00	 call	 _RMD160Init@4

; 372  :     RMD160Update(&context, k_ipad, RIPEMD160_BLOCKSIZE);  /* start with inner pad */

  000cd	6a 40		 push	 64			; 00000040H
  000cf	8d 45 a4	 lea	 eax, DWORD PTR _k_ipad$[ebp]
  000d2	50		 push	 eax
  000d3	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _context$[ebp]
  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 _RMD160Update@12

; 373  :     RMD160Update(&context, (const unsigned char *) input, len); /* then text of datagram */

  000df	ff 75 14	 push	 DWORD PTR _len$[ebp]
  000e2	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _context$[ebp]
  000e8	ff b5 98 fe ff
	ff		 push	 DWORD PTR _input$GSCopy$[ebp]
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 _RMD160Update@12

; 374  :     RMD160Final((unsigned char *) digest, &context);         /* finish up 1st pass */

  000f4	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _context$[ebp]
  000fa	50		 push	 eax
  000fb	ff b5 9c fe ff
	ff		 push	 DWORD PTR _digest$GSCopy$[ebp]
  00101	e8 00 00 00 00	 call	 _RMD160Final@8

; 375  : 
; 376  :     /* perform outer RIPEMD-160 */
; 377  :     RMD160Init(&context);           /* init context for 2nd pass */

  00106	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _context$[ebp]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 _RMD160Init@4

; 378  :     RMD160Update(&context, k_opad, RIPEMD160_BLOCKSIZE);  /* start with outer pad */

  00112	6a 40		 push	 64			; 00000040H
  00114	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _k_opad$[ebp]
  0011a	50		 push	 eax
  0011b	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _context$[ebp]
  00121	50		 push	 eax
  00122	e8 00 00 00 00	 call	 _RMD160Update@12

; 379  :     /* results of 1st hash */
; 380  :     RMD160Update(&context, (const unsigned char *) digest, RIPEMD160_DIGESTSIZE);

  00127	6a 14		 push	 20			; 00000014H
  00129	ff b5 9c fe ff
	ff		 push	 DWORD PTR _digest$GSCopy$[ebp]
  0012f	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _context$[ebp]
  00135	50		 push	 eax
  00136	e8 00 00 00 00	 call	 _RMD160Update@12

; 381  :     RMD160Final((unsigned char *) digest, &context);         /* finish up 2nd pass */

  0013b	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _context$[ebp]
  00141	50		 push	 eax
  00142	ff b5 9c fe ff
	ff		 push	 DWORD PTR _digest$GSCopy$[ebp]
  00148	e8 00 00 00 00	 call	 _RMD160Final@8

; 382  : 
; 383  : 	/* Prevent possible leaks. */
; 384  :     burn (k_ipad, sizeof(k_ipad));

  0014d	6a 41		 push	 65			; 00000041H
  0014f	5f		 pop	 edi
  00150	8d 4d a4	 lea	 ecx, DWORD PTR _k_ipad$[ebp]
  00153	8b d7		 mov	 edx, edi
  00155	8b f7		 mov	 esi, edi
  00157	8b c1		 mov	 eax, ecx
$LL37@hmac_ripem:
  00159	c6 00 00	 mov	 BYTE PTR [eax], 0
  0015c	40		 inc	 eax
  0015d	4e		 dec	 esi
  0015e	75 f9		 jne	 SHORT $LL37@hmac_ripem
$LL17@hmac_ripem:
  00160	4a		 dec	 edx
  00161	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00164	41		 inc	 ecx
  00165	85 d2		 test	 edx, edx
  00167	75 f7		 jne	 SHORT $LL17@hmac_ripem

; 385  :     burn (k_opad, sizeof(k_opad));

  00169	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _k_opad$[ebp]
  0016f	8b d7		 mov	 edx, edi
  00171	8b f7		 mov	 esi, edi
  00173	8b c1		 mov	 eax, ecx
$LL41@hmac_ripem:
  00175	c6 00 00	 mov	 BYTE PTR [eax], 0
  00178	40		 inc	 eax
  00179	4e		 dec	 esi
  0017a	75 f9		 jne	 SHORT $LL41@hmac_ripem
$LL12@hmac_ripem:
  0017c	4a		 dec	 edx
  0017d	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00180	41		 inc	 ecx
  00181	85 d2		 test	 edx, edx
  00183	75 f7		 jne	 SHORT $LL12@hmac_ripem

; 386  : 	burn (tk, sizeof(tk));

  00185	6a 14		 push	 20			; 00000014H
  00187	5a		 pop	 edx
  00188	8d 4d e8	 lea	 ecx, DWORD PTR _tk$[ebp]
  0018b	52		 push	 edx
  0018c	5e		 pop	 esi
  0018d	8b c1		 mov	 eax, ecx
$LL45@hmac_ripem:
  0018f	c6 00 00	 mov	 BYTE PTR [eax], 0
  00192	40		 inc	 eax
  00193	4e		 dec	 esi
  00194	75 f9		 jne	 SHORT $LL45@hmac_ripem
$LL7@hmac_ripem:
  00196	4a		 dec	 edx
  00197	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0019a	41		 inc	 ecx
  0019b	85 d2		 test	 edx, edx
  0019d	75 f7		 jne	 SHORT $LL7@hmac_ripem

; 387  : 	burn (&context, sizeof(context));

  0019f	6a 60		 push	 96			; 00000060H
  001a1	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _context$[ebp]
  001a7	5e		 pop	 esi
  001a8	8b d6		 mov	 edx, esi
  001aa	8b c1		 mov	 eax, ecx
$LL49@hmac_ripem:
  001ac	c6 00 00	 mov	 BYTE PTR [eax], 0
  001af	40		 inc	 eax
  001b0	4e		 dec	 esi
  001b1	75 f9		 jne	 SHORT $LL49@hmac_ripem
  001b3	5f		 pop	 edi
  001b4	5e		 pop	 esi
  001b5	5b		 pop	 ebx
$LL2@hmac_ripem:
  001b6	4a		 dec	 edx
  001b7	c6 01 00	 mov	 BYTE PTR [ecx], 0
  001ba	41		 inc	 ecx
  001bb	85 d2		 test	 edx, edx
  001bd	75 f7		 jne	 SHORT $LL2@hmac_ripem

; 388  : }

  001bf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c2	33 cd		 xor	 ecx, ebp
  001c4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c9	c9		 leave
  001ca	c2 14 00	 ret	 20			; 00000014H
_hmac_ripemd160@20 ENDP
_TEXT	ENDS
PUBLIC	_pwd$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_derive_u_ripemd160@28
; Function compile flags: /Ogsp
;	COMDAT _derive_u_ripemd160@28
_TEXT	SEGMENT
_pwd$GSCopy$ = -180					; size = 4
_counter$ = -176					; size = 4
_init$ = -172						; size = 128
_k$ = -44						; size = 20
_j$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_u$ = 28						; size = 4
_b$ = 32						; size = 4
_derive_u_ripemd160@28 PROC				; COMDAT

; 391  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	8b 45 08	 mov	 eax, DWORD PTR _pwd$[ebp]
  00018	8b 4d 10	 mov	 ecx, DWORD PTR _salt$[ebp]
  0001b	53		 push	 ebx
  0001c	8b 5d 1c	 mov	 ebx, DWORD PTR _u$[ebp]
  0001f	56		 push	 esi
  00020	8b 75 14	 mov	 esi, DWORD PTR _salt_len$[ebp]
  00023	57		 push	 edi

; 392  : 	char j[RIPEMD160_DIGESTSIZE], k[RIPEMD160_DIGESTSIZE];
; 393  : 	char init[128];
; 394  : 	char counter[4];
; 395  : 	int c, i;
; 396  : 
; 397  : 	/* iteration 1 */
; 398  : 	memset (counter, 0, 4);
; 399  : 	counter[3] = (char) b;
; 400  : 	memcpy (init, salt, salt_len);	/* salt */
; 401  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */
; 402  : 	hmac_ripemd160 (pwd, pwd_len, init, salt_len + 4, j);
; 403  : 	memcpy (u, j, RIPEMD160_DIGESTSIZE);
; 404  : 
; 405  : 	/* remaining iterations */
; 406  : 	for (c = 1; c < iterations; c++)

  00024	89 85 4c ff ff
	ff		 mov	 DWORD PTR _pwd$GSCopy$[ebp], eax
  0002a	33 c0		 xor	 eax, eax
  0002c	8d bd 50 ff ff
	ff		 lea	 edi, DWORD PTR _counter$[ebp]
  00032	ab		 stosd
  00033	8a 45 20	 mov	 al, BYTE PTR _b$[ebp]
  00036	56		 push	 esi
  00037	88 85 53 ff ff
	ff		 mov	 BYTE PTR _counter$[ebp+3], al
  0003d	51		 push	 ecx
  0003e	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _init$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _memcpy
  0004a	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _counter$[ebp]
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	89 84 35 54 ff
	ff ff		 mov	 DWORD PTR _init$[ebp+esi], eax
  0005a	8d 45 e8	 lea	 eax, DWORD PTR _j$[ebp]
  0005d	50		 push	 eax
  0005e	83 c6 04	 add	 esi, 4
  00061	56		 push	 esi
  00062	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _init$[ebp]
  00068	50		 push	 eax
  00069	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  0006c	ff b5 4c ff ff
	ff		 push	 DWORD PTR _pwd$GSCopy$[ebp]
  00072	e8 00 00 00 00	 call	 _hmac_ripemd160@20
  00077	8b 45 18	 mov	 eax, DWORD PTR _iterations$[ebp]
  0007a	83 f8 01	 cmp	 eax, 1
  0007d	6a 05		 push	 5
  0007f	59		 pop	 ecx
  00080	8d 75 e8	 lea	 esi, DWORD PTR _j$[ebp]
  00083	8b fb		 mov	 edi, ebx
  00085	6a 14		 push	 20			; 00000014H
  00087	f3 a5		 rep movsd
  00089	5e		 pop	 esi
  0008a	7e 38		 jle	 SHORT $LN10@derive_u_r
  0008c	8d 4d d4	 lea	 ecx, DWORD PTR _k$[ebp]
  0008f	2b d9		 sub	 ebx, ecx
  00091	8d 78 ff	 lea	 edi, DWORD PTR [eax-1]
$LL16@derive_u_r:

; 407  : 	{
; 408  : 		hmac_ripemd160 (pwd, pwd_len, j, RIPEMD160_DIGESTSIZE, k);

  00094	8d 45 d4	 lea	 eax, DWORD PTR _k$[ebp]
  00097	50		 push	 eax
  00098	56		 push	 esi
  00099	8d 45 e8	 lea	 eax, DWORD PTR _j$[ebp]
  0009c	50		 push	 eax
  0009d	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  000a0	ff b5 4c ff ff
	ff		 push	 DWORD PTR _pwd$GSCopy$[ebp]
  000a6	e8 00 00 00 00	 call	 _hmac_ripemd160@20

; 409  : 		for (i = 0; i < RIPEMD160_DIGESTSIZE; i++)

  000ab	33 d2		 xor	 edx, edx
$LL13@derive_u_r:

; 410  : 		{
; 411  : 			u[i] ^= k[i];

  000ad	8d 44 15 d4	 lea	 eax, DWORD PTR _k$[ebp+edx]
  000b1	8d 0c 03	 lea	 ecx, DWORD PTR [ebx+eax]
  000b4	8a 00		 mov	 al, BYTE PTR [eax]
  000b6	30 01		 xor	 BYTE PTR [ecx], al

; 412  : 			j[i] = k[i];

  000b8	88 44 15 e8	 mov	 BYTE PTR _j$[ebp+edx], al
  000bc	42		 inc	 edx
  000bd	3b d6		 cmp	 edx, esi
  000bf	7c ec		 jl	 SHORT $LL13@derive_u_r

; 392  : 	char j[RIPEMD160_DIGESTSIZE], k[RIPEMD160_DIGESTSIZE];
; 393  : 	char init[128];
; 394  : 	char counter[4];
; 395  : 	int c, i;
; 396  : 
; 397  : 	/* iteration 1 */
; 398  : 	memset (counter, 0, 4);
; 399  : 	counter[3] = (char) b;
; 400  : 	memcpy (init, salt, salt_len);	/* salt */
; 401  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */
; 402  : 	hmac_ripemd160 (pwd, pwd_len, init, salt_len + 4, j);
; 403  : 	memcpy (u, j, RIPEMD160_DIGESTSIZE);
; 404  : 
; 405  : 	/* remaining iterations */
; 406  : 	for (c = 1; c < iterations; c++)

  000c1	4f		 dec	 edi
  000c2	75 d0		 jne	 SHORT $LL16@derive_u_r
$LN10@derive_u_r:

; 413  : 		}
; 414  : 	}
; 415  : 
; 416  : 	/* Prevent possible leaks. */
; 417  : 	burn (j, sizeof(j));

  000c4	8d 4d e8	 lea	 ecx, DWORD PTR _j$[ebp]
  000c7	8b d6		 mov	 edx, esi
  000c9	8b fe		 mov	 edi, esi
  000cb	8b c1		 mov	 eax, ecx
$LL20@derive_u_r:
  000cd	c6 00 00	 mov	 BYTE PTR [eax], 0
  000d0	40		 inc	 eax
  000d1	4f		 dec	 edi
  000d2	75 f9		 jne	 SHORT $LL20@derive_u_r
$LL7@derive_u_r:
  000d4	4a		 dec	 edx
  000d5	c6 01 00	 mov	 BYTE PTR [ecx], 0
  000d8	41		 inc	 ecx
  000d9	85 d2		 test	 edx, edx
  000db	75 f7		 jne	 SHORT $LL7@derive_u_r

; 418  : 	burn (k, sizeof(k));

  000dd	8d 4d d4	 lea	 ecx, DWORD PTR _k$[ebp]
  000e0	8b d6		 mov	 edx, esi
  000e2	8b c1		 mov	 eax, ecx
$LL24@derive_u_r:
  000e4	c6 00 00	 mov	 BYTE PTR [eax], 0
  000e7	40		 inc	 eax
  000e8	4e		 dec	 esi
  000e9	75 f9		 jne	 SHORT $LL24@derive_u_r
  000eb	5f		 pop	 edi
  000ec	5e		 pop	 esi
  000ed	5b		 pop	 ebx
$LL2@derive_u_r:
  000ee	4a		 dec	 edx
  000ef	c6 01 00	 mov	 BYTE PTR [ecx], 0
  000f2	41		 inc	 ecx
  000f3	85 d2		 test	 edx, edx
  000f5	75 f7		 jne	 SHORT $LL2@derive_u_r

; 419  : }

  000f7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fa	33 cd		 xor	 ecx, ebp
  000fc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00101	c9		 leave
  00102	c2 1c 00	 ret	 28			; 0000001cH
_derive_u_ripemd160@28 ENDP
_TEXT	ENDS
PUBLIC	_dk$GSCopy$
PUBLIC	_salt$GSCopy$
PUBLIC	_pwd$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_derive_key_ripemd160@28
; Function compile flags: /Ogsp
;	COMDAT _derive_key_ripemd160@28
_TEXT	SEGMENT
_r$ = -44						; size = 4
_pwd$GSCopy$ = -40					; size = 4
_salt$GSCopy$ = -36					; size = 4
_l$ = -32						; size = 4
_dk$GSCopy$ = -28					; size = 4
_u$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_dk$ = 28						; size = 4
_dklen$ = 32						; size = 4
_derive_key_ripemd160@28 PROC				; COMDAT

; 422  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 423  : 	char u[RIPEMD160_DIGESTSIZE];
; 424  : 	int b, l, r;
; 425  : 
; 426  : 	if (dklen % RIPEMD160_DIGESTSIZE)
; 427  : 	{
; 428  : 		l = 1 + dklen / RIPEMD160_DIGESTSIZE;

  00012	8b 45 08	 mov	 eax, DWORD PTR _pwd$[ebp]
  00015	8b 4d 20	 mov	 ecx, DWORD PTR _dklen$[ebp]
  00018	89 45 d8	 mov	 DWORD PTR _pwd$GSCopy$[ebp], eax
  0001b	8b 45 10	 mov	 eax, DWORD PTR _salt$[ebp]
  0001e	89 45 dc	 mov	 DWORD PTR _salt$GSCopy$[ebp], eax
  00021	8b 45 1c	 mov	 eax, DWORD PTR _dk$[ebp]
  00024	89 45 e4	 mov	 DWORD PTR _dk$GSCopy$[ebp], eax
  00027	56		 push	 esi
  00028	8b c1		 mov	 eax, ecx
  0002a	6a 14		 push	 20			; 00000014H
  0002c	99		 cdq
  0002d	5e		 pop	 esi
  0002e	f7 fe		 idiv	 esi
  00030	85 d2		 test	 edx, edx
  00032	74 01		 je	 SHORT $LN10@derive_key@3
  00034	40		 inc	 eax
$LN10@derive_key@3:

; 429  : 	}
; 430  : 	else
; 431  : 	{
; 432  : 		l = dklen / RIPEMD160_DIGESTSIZE;

  00035	89 45 e0	 mov	 DWORD PTR _l$[ebp], eax

; 433  : 	}
; 434  : 
; 435  : 	r = dklen - (l - 1) * RIPEMD160_DIGESTSIZE;

  00038	6b c0 14	 imul	 eax, 20			; 00000014H
  0003b	53		 push	 ebx

; 436  : 
; 437  : 	/* first l - 1 blocks */
; 438  : 	for (b = 1; b < l; b++)

  0003c	33 db		 xor	 ebx, ebx
  0003e	2b c8		 sub	 ecx, eax
  00040	83 c1 14	 add	 ecx, 20			; 00000014H
  00043	43		 inc	 ebx
  00044	39 5d e0	 cmp	 DWORD PTR _l$[ebp], ebx
  00047	89 4d d4	 mov	 DWORD PTR _r$[ebp], ecx
  0004a	7e 30		 jle	 SHORT $LN6@derive_key@3
  0004c	57		 push	 edi
$LL26@derive_key@3:

; 439  : 	{
; 440  : 		derive_u_ripemd160 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  0004d	53		 push	 ebx
  0004e	8d 45 e8	 lea	 eax, DWORD PTR _u$[ebp]
  00051	50		 push	 eax
  00052	ff 75 18	 push	 DWORD PTR _iterations$[ebp]
  00055	ff 75 14	 push	 DWORD PTR _salt_len$[ebp]
  00058	ff 75 dc	 push	 DWORD PTR _salt$GSCopy$[ebp]
  0005b	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  0005e	ff 75 d8	 push	 DWORD PTR _pwd$GSCopy$[ebp]
  00061	e8 00 00 00 00	 call	 _derive_u_ripemd160@28

; 441  : 		memcpy (dk, u, RIPEMD160_DIGESTSIZE);

  00066	8b 7d e4	 mov	 edi, DWORD PTR _dk$GSCopy$[ebp]

; 442  : 		dk += RIPEMD160_DIGESTSIZE;

  00069	83 45 e4 14	 add	 DWORD PTR _dk$GSCopy$[ebp], 20 ; 00000014H
  0006d	6a 05		 push	 5
  0006f	43		 inc	 ebx
  00070	3b 5d e0	 cmp	 ebx, DWORD PTR _l$[ebp]
  00073	59		 pop	 ecx
  00074	8d 75 e8	 lea	 esi, DWORD PTR _u$[ebp]
  00077	f3 a5		 rep movsd
  00079	7c d2		 jl	 SHORT $LL26@derive_key@3
  0007b	5f		 pop	 edi
$LN6@derive_key@3:

; 443  : 	}
; 444  : 
; 445  : 	/* last block */
; 446  : 	derive_u_ripemd160 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  0007c	53		 push	 ebx
  0007d	8d 45 e8	 lea	 eax, DWORD PTR _u$[ebp]
  00080	50		 push	 eax
  00081	ff 75 18	 push	 DWORD PTR _iterations$[ebp]
  00084	ff 75 14	 push	 DWORD PTR _salt_len$[ebp]
  00087	ff 75 dc	 push	 DWORD PTR _salt$GSCopy$[ebp]
  0008a	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  0008d	ff 75 d8	 push	 DWORD PTR _pwd$GSCopy$[ebp]
  00090	e8 00 00 00 00	 call	 _derive_u_ripemd160@28

; 447  : 	memcpy (dk, u, r);

  00095	ff 75 d4	 push	 DWORD PTR _r$[ebp]
  00098	8d 45 e8	 lea	 eax, DWORD PTR _u$[ebp]
  0009b	50		 push	 eax
  0009c	ff 75 e4	 push	 DWORD PTR _dk$GSCopy$[ebp]
  0009f	e8 00 00 00 00	 call	 _memcpy
  000a4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 448  : 
; 449  : 
; 450  : 	/* Prevent possible leaks. */
; 451  : 	burn (u, sizeof(u));

  000a7	6a 14		 push	 20			; 00000014H
  000a9	5e		 pop	 esi
  000aa	8d 4d e8	 lea	 ecx, DWORD PTR _u$[ebp]
  000ad	8b d6		 mov	 edx, esi
  000af	8b c1		 mov	 eax, ecx
  000b1	5b		 pop	 ebx
$LL14@derive_key@3:
  000b2	c6 00 00	 mov	 BYTE PTR [eax], 0
  000b5	40		 inc	 eax
  000b6	4e		 dec	 esi
  000b7	75 f9		 jne	 SHORT $LL14@derive_key@3
  000b9	5e		 pop	 esi
$LL2@derive_key@3:
  000ba	4a		 dec	 edx
  000bb	c6 01 00	 mov	 BYTE PTR [ecx], 0
  000be	41		 inc	 ecx
  000bf	85 d2		 test	 edx, edx
  000c1	75 f7		 jne	 SHORT $LL2@derive_key@3

; 452  : }

  000c3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c6	33 cd		 xor	 ecx, ebp
  000c8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cd	c9		 leave
  000ce	c2 1c 00	 ret	 28			; 0000001cH
_derive_key_ripemd160@28 ENDP
_TEXT	ENDS
PUBLIC	_out$GSCopy$
PUBLIC	_k$GSCopy$
PUBLIC	_d$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_hmac_whirlpool@24
EXTRN	_WHIRLPOOL_finalize@8:PROC
EXTRN	_WHIRLPOOL_add@12:PROC
EXTRN	_WHIRLPOOL_init@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _hmac_whirlpool@24
_TEXT	SEGMENT
_out$GSCopy$ = -776					; size = 4
_k$GSCopy$ = -772					; size = 4
tv493 = -768						; size = 4
_d$GSCopy$ = -768					; size = 4
_tctx$27508 = -764					; size = 168
_octx$ = -596						; size = 168
_ictx$ = -428						; size = 168
_key$ = -260						; size = 64
_iwhi$ = -196						; size = 64
_owhi$ = -132						; size = 64
_buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_lk$ = 12						; size = 4
_d$ = 16						; size = 4
_ld$ = 20						; size = 4
_out$ = 24						; size = 4
_t$ = 28						; size = 4
_hmac_whirlpool@24 PROC					; COMDAT

; 465  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 08 03 00
	00		 sub	 esp, 776		; 00000308H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	8b 45 10	 mov	 eax, DWORD PTR _d$[ebp]
  00018	53		 push	 ebx
  00019	8b 5d 08	 mov	 ebx, DWORD PTR _k$[ebp]
  0001c	56		 push	 esi

; 466  : 	WHIRLPOOL_CTX ictx, octx;
; 467  : 	char iwhi[WHIRLPOOL_DIGESTSIZE], owhi[WHIRLPOOL_DIGESTSIZE];
; 468  : 	char key[WHIRLPOOL_DIGESTSIZE];
; 469  : 	char buf[WHIRLPOOL_BLOCKSIZE];
; 470  : 	int i;
; 471  : 
; 472  :     /* If the key is longer than the hash algorithm block size,
; 473  : 	   let key = whirlpool(key), as per HMAC specifications. */
; 474  : 	if (lk > WHIRLPOOL_BLOCKSIZE)

  0001d	8b 75 0c	 mov	 esi, DWORD PTR _lk$[ebp]
  00020	83 fe 40	 cmp	 esi, 64			; 00000040H

; 510  : 		buf[i] = 0x5C;
; 511  : 
; 512  : 	WHIRLPOOL_add ((unsigned char *) buf, WHIRLPOOL_BLOCKSIZE * 8, &octx);

  00023	89 85 00 fd ff
	ff		 mov	 DWORD PTR _d$GSCopy$[ebp], eax
  00029	8b 45 18	 mov	 eax, DWORD PTR _out$[ebp]
  0002c	57		 push	 edi
  0002d	89 9d fc fc ff
	ff		 mov	 DWORD PTR _k$GSCopy$[ebp], ebx
  00033	89 85 f8 fc ff
	ff		 mov	 DWORD PTR _out$GSCopy$[ebp], eax
  00039	bf a8 00 00 00	 mov	 edi, 168		; 000000a8H
  0003e	7e 5d		 jle	 SHORT $LN45@hmac_whirl
  00040	8d 85 04 fd ff
	ff		 lea	 eax, DWORD PTR _tctx$27508[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _WHIRLPOOL_init@4
  0004c	8d 85 04 fd ff
	ff		 lea	 eax, DWORD PTR _tctx$27508[ebp]
  00052	50		 push	 eax
  00053	8b c6		 mov	 eax, esi
  00055	c1 e0 03	 shl	 eax, 3
  00058	50		 push	 eax
  00059	53		 push	 ebx
  0005a	e8 00 00 00 00	 call	 _WHIRLPOOL_add@12
  0005f	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _key$[ebp]
  00065	50		 push	 eax
  00066	8d 85 04 fd ff
	ff		 lea	 eax, DWORD PTR _tctx$27508[ebp]
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 _WHIRLPOOL_finalize@8
  00072	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _key$[ebp]
  00078	6a 40		 push	 64			; 00000040H
  0007a	8d 8d 04 fd ff
	ff		 lea	 ecx, DWORD PTR _tctx$27508[ebp]
  00080	89 85 fc fc ff
	ff		 mov	 DWORD PTR _k$GSCopy$[ebp], eax
  00086	5e		 pop	 esi
  00087	8b d7		 mov	 edx, edi
  00089	8b df		 mov	 ebx, edi
  0008b	8b c1		 mov	 eax, ecx
$LL54@hmac_whirl:
  0008d	c6 00 00	 mov	 BYTE PTR [eax], 0
  00090	40		 inc	 eax
  00091	4b		 dec	 ebx
  00092	75 f9		 jne	 SHORT $LL54@hmac_whirl
$LL44@hmac_whirl:

; 475  : 	{
; 476  : 		WHIRLPOOL_CTX tctx;
; 477  : 
; 478  : 		WHIRLPOOL_init (&tctx);
; 479  : 		WHIRLPOOL_add ((unsigned char *) k, lk * 8, &tctx);
; 480  : 		WHIRLPOOL_finalize (&tctx, (unsigned char *) key);
; 481  : 
; 482  : 		k = key;
; 483  : 		lk = WHIRLPOOL_DIGESTSIZE;
; 484  : 
; 485  : 		burn (&tctx, sizeof(tctx));		// Prevent leaks

  00094	4a		 dec	 edx
  00095	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00098	41		 inc	 ecx
  00099	85 d2		 test	 edx, edx
  0009b	75 f7		 jne	 SHORT $LL44@hmac_whirl
$LN45@hmac_whirl:

; 486  : 	}
; 487  : 
; 488  : 	/**** Inner Digest ****/
; 489  : 
; 490  : 	WHIRLPOOL_init (&ictx);

  0009d	8d 85 54 fe ff
	ff		 lea	 eax, DWORD PTR _ictx$[ebp]
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 _WHIRLPOOL_init@4

; 491  : 
; 492  : 	/* Pad the key for inner digest */
; 493  : 	for (i = 0; i < lk; ++i)

  000a9	33 c9		 xor	 ecx, ecx
  000ab	85 f6		 test	 esi, esi
  000ad	7e 1c		 jle	 SHORT $LN40@hmac_whirl
  000af	8b 95 fc fc ff
	ff		 mov	 edx, DWORD PTR _k$GSCopy$[ebp]
  000b5	8d 45 bc	 lea	 eax, DWORD PTR _buf$[ebp]
  000b8	2b d0		 sub	 edx, eax
$LL42@hmac_whirl:

; 494  : 		buf[i] = (char) (k[i] ^ 0x36);

  000ba	8d 44 0d bc	 lea	 eax, DWORD PTR _buf$[ebp+ecx]
  000be	8a 1c 02	 mov	 bl, BYTE PTR [edx+eax]
  000c1	80 f3 36	 xor	 bl, 54			; 00000036H
  000c4	41		 inc	 ecx
  000c5	3b ce		 cmp	 ecx, esi
  000c7	88 18		 mov	 BYTE PTR [eax], bl
  000c9	7c ef		 jl	 SHORT $LL42@hmac_whirl
$LN40@hmac_whirl:

; 495  : 	for (i = lk; i < WHIRLPOOL_BLOCKSIZE; ++i)

  000cb	83 fe 40	 cmp	 esi, 64			; 00000040H
  000ce	7d 15		 jge	 SHORT $LN39@hmac_whirl
  000d0	6a 40		 push	 64			; 00000040H
  000d2	59		 pop	 ecx
  000d3	2b ce		 sub	 ecx, esi
  000d5	51		 push	 ecx
  000d6	8d 44 35 bc	 lea	 eax, DWORD PTR _buf$[ebp+esi]
  000da	6a 36		 push	 54			; 00000036H
  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 _memset
  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN39@hmac_whirl:

; 496  : 		buf[i] = 0x36;
; 497  : 
; 498  : 	WHIRLPOOL_add ((unsigned char *) buf, WHIRLPOOL_BLOCKSIZE * 8, &ictx);

  000e5	8d 85 54 fe ff
	ff		 lea	 eax, DWORD PTR _ictx$[ebp]
  000eb	50		 push	 eax
  000ec	bb 00 02 00 00	 mov	 ebx, 512		; 00000200H
  000f1	53		 push	 ebx
  000f2	8d 45 bc	 lea	 eax, DWORD PTR _buf$[ebp]
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 _WHIRLPOOL_add@12

; 499  : 	WHIRLPOOL_add ((unsigned char *) d, ld * 8, &ictx);

  000fb	8d 85 54 fe ff
	ff		 lea	 eax, DWORD PTR _ictx$[ebp]
  00101	50		 push	 eax
  00102	8b 45 14	 mov	 eax, DWORD PTR _ld$[ebp]
  00105	c1 e0 03	 shl	 eax, 3
  00108	50		 push	 eax
  00109	ff b5 00 fd ff
	ff		 push	 DWORD PTR _d$GSCopy$[ebp]
  0010f	e8 00 00 00 00	 call	 _WHIRLPOOL_add@12

; 500  : 
; 501  : 	WHIRLPOOL_finalize (&ictx, (unsigned char *) iwhi);

  00114	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _iwhi$[ebp]
  0011a	50		 push	 eax
  0011b	8d 85 54 fe ff
	ff		 lea	 eax, DWORD PTR _ictx$[ebp]
  00121	50		 push	 eax
  00122	e8 00 00 00 00	 call	 _WHIRLPOOL_finalize@8

; 502  : 
; 503  : 	/**** Outer Digest ****/
; 504  : 
; 505  : 	WHIRLPOOL_init (&octx);

  00127	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  0012d	50		 push	 eax
  0012e	e8 00 00 00 00	 call	 _WHIRLPOOL_init@4

; 506  : 
; 507  : 	for (i = 0; i < lk; ++i)

  00133	33 c9		 xor	 ecx, ecx
  00135	85 f6		 test	 esi, esi
  00137	7e 2a		 jle	 SHORT $LN34@hmac_whirl
  00139	8b 95 fc fc ff
	ff		 mov	 edx, DWORD PTR _k$GSCopy$[ebp]
  0013f	8d 45 bc	 lea	 eax, DWORD PTR _buf$[ebp]
  00142	2b d0		 sub	 edx, eax
  00144	89 95 00 fd ff
	ff		 mov	 DWORD PTR tv493[ebp], edx
  0014a	eb 06		 jmp	 SHORT $LN36@hmac_whirl
$LL156@hmac_whirl:
  0014c	8b 95 00 fd ff
	ff		 mov	 edx, DWORD PTR tv493[ebp]
$LN36@hmac_whirl:

; 508  : 		buf[i] = (char) (k[i] ^ 0x5C);

  00152	8d 44 0d bc	 lea	 eax, DWORD PTR _buf$[ebp+ecx]
  00156	8a 14 02	 mov	 dl, BYTE PTR [edx+eax]
  00159	80 f2 5c	 xor	 dl, 92			; 0000005cH
  0015c	41		 inc	 ecx
  0015d	3b ce		 cmp	 ecx, esi
  0015f	88 10		 mov	 BYTE PTR [eax], dl
  00161	7c e9		 jl	 SHORT $LL156@hmac_whirl
$LN34@hmac_whirl:

; 509  : 	for (i = lk; i < WHIRLPOOL_BLOCKSIZE; ++i)

  00163	83 fe 40	 cmp	 esi, 64			; 00000040H
  00166	7d 15		 jge	 SHORT $LN33@hmac_whirl
  00168	6a 40		 push	 64			; 00000040H
  0016a	59		 pop	 ecx
  0016b	2b ce		 sub	 ecx, esi
  0016d	51		 push	 ecx
  0016e	8d 44 35 bc	 lea	 eax, DWORD PTR _buf$[ebp+esi]
  00172	6a 5c		 push	 92			; 0000005cH
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 _memset
  0017a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN33@hmac_whirl:

; 510  : 		buf[i] = 0x5C;
; 511  : 
; 512  : 	WHIRLPOOL_add ((unsigned char *) buf, WHIRLPOOL_BLOCKSIZE * 8, &octx);

  0017d	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  00183	50		 push	 eax
  00184	53		 push	 ebx
  00185	8d 45 bc	 lea	 eax, DWORD PTR _buf$[ebp]
  00188	50		 push	 eax
  00189	e8 00 00 00 00	 call	 _WHIRLPOOL_add@12

; 513  : 	WHIRLPOOL_add ((unsigned char *) iwhi, WHIRLPOOL_DIGESTSIZE * 8, &octx);

  0018e	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  00194	50		 push	 eax
  00195	53		 push	 ebx
  00196	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _iwhi$[ebp]
  0019c	50		 push	 eax
  0019d	e8 00 00 00 00	 call	 _WHIRLPOOL_add@12

; 514  : 
; 515  : 	WHIRLPOOL_finalize (&octx, (unsigned char *) owhi);

  001a2	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _owhi$[ebp]
  001a8	50		 push	 eax
  001a9	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR _octx$[ebp]
  001af	50		 push	 eax
  001b0	e8 00 00 00 00	 call	 _WHIRLPOOL_finalize@8

; 516  : 
; 517  : 	/* truncate and print the results */
; 518  : 	t = t > WHIRLPOOL_DIGESTSIZE ? WHIRLPOOL_DIGESTSIZE : t;

  001b5	6a 40		 push	 64			; 00000040H
  001b7	5e		 pop	 esi
  001b8	39 75 1c	 cmp	 DWORD PTR _t$[ebp], esi
  001bb	7e 03		 jle	 SHORT $LN51@hmac_whirl
  001bd	89 75 1c	 mov	 DWORD PTR _t$[ebp], esi
$LN51@hmac_whirl:

; 519  : 	hmac_truncate (owhi, out, t);

  001c0	ff 75 1c	 push	 DWORD PTR _t$[ebp]
  001c3	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _owhi$[ebp]
  001c9	ff b5 f8 fc ff
	ff		 push	 DWORD PTR _out$GSCopy$[ebp]
  001cf	50		 push	 eax
  001d0	e8 00 00 00 00	 call	 _hmac_truncate@12

; 520  : 
; 521  : 	/* Prevent possible leaks. */
; 522  : 	burn (&ictx, sizeof(ictx));

  001d5	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR _ictx$[ebp]
  001db	8b d7		 mov	 edx, edi
  001dd	8b df		 mov	 ebx, edi
  001df	8b c1		 mov	 eax, ecx
$LL58@hmac_whirl:
  001e1	c6 00 00	 mov	 BYTE PTR [eax], 0
  001e4	40		 inc	 eax
  001e5	4b		 dec	 ebx
  001e6	75 f9		 jne	 SHORT $LL58@hmac_whirl
$LL27@hmac_whirl:
  001e8	4a		 dec	 edx
  001e9	c6 01 00	 mov	 BYTE PTR [ecx], 0
  001ec	41		 inc	 ecx
  001ed	85 d2		 test	 edx, edx
  001ef	75 f7		 jne	 SHORT $LL27@hmac_whirl

; 523  : 	burn (&octx, sizeof(octx));

  001f1	8d 8d ac fd ff
	ff		 lea	 ecx, DWORD PTR _octx$[ebp]
  001f7	8b d7		 mov	 edx, edi
  001f9	8b c1		 mov	 eax, ecx
$LL62@hmac_whirl:
  001fb	c6 00 00	 mov	 BYTE PTR [eax], 0
  001fe	40		 inc	 eax
  001ff	4f		 dec	 edi
  00200	75 f9		 jne	 SHORT $LL62@hmac_whirl
$LL22@hmac_whirl:
  00202	4a		 dec	 edx
  00203	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00206	41		 inc	 ecx
  00207	85 d2		 test	 edx, edx
  00209	75 f7		 jne	 SHORT $LL22@hmac_whirl

; 524  : 	burn (owhi, sizeof(owhi));

  0020b	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _owhi$[ebp]
  00211	8b d6		 mov	 edx, esi
  00213	8b fe		 mov	 edi, esi
  00215	8b c1		 mov	 eax, ecx
$LL66@hmac_whirl:
  00217	c6 00 00	 mov	 BYTE PTR [eax], 0
  0021a	40		 inc	 eax
  0021b	4f		 dec	 edi
  0021c	75 f9		 jne	 SHORT $LL66@hmac_whirl
$LL17@hmac_whirl:
  0021e	4a		 dec	 edx
  0021f	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00222	41		 inc	 ecx
  00223	85 d2		 test	 edx, edx
  00225	75 f7		 jne	 SHORT $LL17@hmac_whirl

; 525  : 	burn (iwhi, sizeof(iwhi));

  00227	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR _iwhi$[ebp]
  0022d	8b d6		 mov	 edx, esi
  0022f	8b fe		 mov	 edi, esi
  00231	8b c1		 mov	 eax, ecx
$LL70@hmac_whirl:
  00233	c6 00 00	 mov	 BYTE PTR [eax], 0
  00236	40		 inc	 eax
  00237	4f		 dec	 edi
  00238	75 f9		 jne	 SHORT $LL70@hmac_whirl
$LL12@hmac_whirl:
  0023a	4a		 dec	 edx
  0023b	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0023e	41		 inc	 ecx
  0023f	85 d2		 test	 edx, edx
  00241	75 f7		 jne	 SHORT $LL12@hmac_whirl

; 526  : 	burn (buf, sizeof(buf));

  00243	8d 4d bc	 lea	 ecx, DWORD PTR _buf$[ebp]
  00246	8b d6		 mov	 edx, esi
  00248	8b fe		 mov	 edi, esi
  0024a	8b c1		 mov	 eax, ecx
$LL74@hmac_whirl:
  0024c	c6 00 00	 mov	 BYTE PTR [eax], 0
  0024f	40		 inc	 eax
  00250	4f		 dec	 edi
  00251	75 f9		 jne	 SHORT $LL74@hmac_whirl
$LL7@hmac_whirl:
  00253	4a		 dec	 edx
  00254	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00257	41		 inc	 ecx
  00258	85 d2		 test	 edx, edx
  0025a	75 f7		 jne	 SHORT $LL7@hmac_whirl

; 527  : 	burn (key, sizeof(key));

  0025c	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _key$[ebp]
  00262	8b d6		 mov	 edx, esi
  00264	8b c1		 mov	 eax, ecx
$LL78@hmac_whirl:
  00266	c6 00 00	 mov	 BYTE PTR [eax], 0
  00269	40		 inc	 eax
  0026a	4e		 dec	 esi
  0026b	75 f9		 jne	 SHORT $LL78@hmac_whirl
  0026d	5f		 pop	 edi
  0026e	5e		 pop	 esi
  0026f	5b		 pop	 ebx
$LL2@hmac_whirl:
  00270	4a		 dec	 edx
  00271	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00274	41		 inc	 ecx
  00275	85 d2		 test	 edx, edx
  00277	75 f7		 jne	 SHORT $LL2@hmac_whirl

; 528  : }

  00279	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0027c	33 cd		 xor	 ecx, ebp
  0027e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00283	c9		 leave
  00284	c2 18 00	 ret	 24			; 00000018H
_hmac_whirlpool@24 ENDP
_TEXT	ENDS
PUBLIC	_pwd$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_derive_u_whirlpool@28
; Function compile flags: /Ogsp
;	COMDAT _derive_u_whirlpool@28
_TEXT	SEGMENT
_pwd$GSCopy$ = -268					; size = 4
_counter$ = -264					; size = 4
_init$ = -260						; size = 128
_k$ = -132						; size = 64
_j$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_u$ = 28						; size = 4
_b$ = 32						; size = 4
_derive_u_whirlpool@28 PROC				; COMDAT

; 531  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	8b 45 08	 mov	 eax, DWORD PTR _pwd$[ebp]
  00018	8b 4d 10	 mov	 ecx, DWORD PTR _salt$[ebp]
  0001b	53		 push	 ebx
  0001c	8b 5d 1c	 mov	 ebx, DWORD PTR _u$[ebp]
  0001f	56		 push	 esi
  00020	8b 75 14	 mov	 esi, DWORD PTR _salt_len$[ebp]
  00023	57		 push	 edi

; 532  : 	char j[WHIRLPOOL_DIGESTSIZE], k[WHIRLPOOL_DIGESTSIZE];
; 533  : 	char init[128];
; 534  : 	char counter[4];
; 535  : 	int c, i;
; 536  : 
; 537  : 	/* iteration 1 */
; 538  : 	memset (counter, 0, 4);
; 539  : 	counter[3] = (char) b;
; 540  : 	memcpy (init, salt, salt_len);	/* salt */
; 541  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */
; 542  : 	hmac_whirlpool (pwd, pwd_len, init, salt_len + 4, j, WHIRLPOOL_DIGESTSIZE);
; 543  : 	memcpy (u, j, WHIRLPOOL_DIGESTSIZE);
; 544  : 
; 545  : 	/* remaining iterations */
; 546  : 	for (c = 1; c < iterations; c++)

  00024	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _pwd$GSCopy$[ebp], eax
  0002a	33 c0		 xor	 eax, eax
  0002c	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR _counter$[ebp]
  00032	ab		 stosd
  00033	8a 45 20	 mov	 al, BYTE PTR _b$[ebp]
  00036	56		 push	 esi
  00037	88 85 fb fe ff
	ff		 mov	 BYTE PTR _counter$[ebp+3], al
  0003d	51		 push	 ecx
  0003e	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _init$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _memcpy
  0004a	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _counter$[ebp]
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	6a 40		 push	 64			; 00000040H
  00055	89 84 35 fc fe
	ff ff		 mov	 DWORD PTR _init$[ebp+esi], eax
  0005c	8d 45 bc	 lea	 eax, DWORD PTR _j$[ebp]
  0005f	50		 push	 eax
  00060	83 c6 04	 add	 esi, 4
  00063	56		 push	 esi
  00064	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _init$[ebp]
  0006a	50		 push	 eax
  0006b	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  0006e	ff b5 f4 fe ff
	ff		 push	 DWORD PTR _pwd$GSCopy$[ebp]
  00074	e8 00 00 00 00	 call	 _hmac_whirlpool@24
  00079	8b 45 18	 mov	 eax, DWORD PTR _iterations$[ebp]
  0007c	83 f8 01	 cmp	 eax, 1
  0007f	6a 10		 push	 16			; 00000010H
  00081	59		 pop	 ecx
  00082	8d 75 bc	 lea	 esi, DWORD PTR _j$[ebp]
  00085	8b fb		 mov	 edi, ebx
  00087	f3 a5		 rep movsd
  00089	7e 47		 jle	 SHORT $LN47@derive_u_w
  0008b	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _k$[ebp]
  00091	2b d9		 sub	 ebx, ecx
  00093	8d 78 ff	 lea	 edi, DWORD PTR [eax-1]
$LL16@derive_u_w:

; 547  : 	{
; 548  : 		hmac_whirlpool (pwd, pwd_len, j, WHIRLPOOL_DIGESTSIZE, k, WHIRLPOOL_DIGESTSIZE);

  00096	6a 40		 push	 64			; 00000040H
  00098	5e		 pop	 esi
  00099	56		 push	 esi
  0009a	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _k$[ebp]
  000a0	50		 push	 eax
  000a1	56		 push	 esi
  000a2	8d 45 bc	 lea	 eax, DWORD PTR _j$[ebp]
  000a5	50		 push	 eax
  000a6	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  000a9	ff b5 f4 fe ff
	ff		 push	 DWORD PTR _pwd$GSCopy$[ebp]
  000af	e8 00 00 00 00	 call	 _hmac_whirlpool@24

; 549  : 		for (i = 0; i < WHIRLPOOL_DIGESTSIZE; i++)

  000b4	33 d2		 xor	 edx, edx
$LL13@derive_u_w:

; 550  : 		{
; 551  : 			u[i] ^= k[i];

  000b6	8d 84 15 7c ff
	ff ff		 lea	 eax, DWORD PTR _k$[ebp+edx]
  000bd	8d 0c 03	 lea	 ecx, DWORD PTR [ebx+eax]
  000c0	8a 00		 mov	 al, BYTE PTR [eax]
  000c2	30 01		 xor	 BYTE PTR [ecx], al

; 552  : 			j[i] = k[i];

  000c4	88 44 15 bc	 mov	 BYTE PTR _j$[ebp+edx], al
  000c8	42		 inc	 edx
  000c9	3b d6		 cmp	 edx, esi
  000cb	7c e9		 jl	 SHORT $LL13@derive_u_w

; 532  : 	char j[WHIRLPOOL_DIGESTSIZE], k[WHIRLPOOL_DIGESTSIZE];
; 533  : 	char init[128];
; 534  : 	char counter[4];
; 535  : 	int c, i;
; 536  : 
; 537  : 	/* iteration 1 */
; 538  : 	memset (counter, 0, 4);
; 539  : 	counter[3] = (char) b;
; 540  : 	memcpy (init, salt, salt_len);	/* salt */
; 541  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */
; 542  : 	hmac_whirlpool (pwd, pwd_len, init, salt_len + 4, j, WHIRLPOOL_DIGESTSIZE);
; 543  : 	memcpy (u, j, WHIRLPOOL_DIGESTSIZE);
; 544  : 
; 545  : 	/* remaining iterations */
; 546  : 	for (c = 1; c < iterations; c++)

  000cd	4f		 dec	 edi
  000ce	75 c6		 jne	 SHORT $LL16@derive_u_w
  000d0	eb 03		 jmp	 SHORT $LN10@derive_u_w
$LN47@derive_u_w:
  000d2	6a 40		 push	 64			; 00000040H
  000d4	5e		 pop	 esi
$LN10@derive_u_w:

; 553  : 		}
; 554  : 	}
; 555  : 
; 556  : 	/* Prevent possible leaks. */
; 557  : 	burn (j, sizeof(j));

  000d5	8d 4d bc	 lea	 ecx, DWORD PTR _j$[ebp]
  000d8	8b d6		 mov	 edx, esi
  000da	8b fe		 mov	 edi, esi
  000dc	8b c1		 mov	 eax, ecx
$LL20@derive_u_w:
  000de	c6 00 00	 mov	 BYTE PTR [eax], 0
  000e1	40		 inc	 eax
  000e2	4f		 dec	 edi
  000e3	75 f9		 jne	 SHORT $LL20@derive_u_w
$LL7@derive_u_w:
  000e5	4a		 dec	 edx
  000e6	c6 01 00	 mov	 BYTE PTR [ecx], 0
  000e9	41		 inc	 ecx
  000ea	85 d2		 test	 edx, edx
  000ec	75 f7		 jne	 SHORT $LL7@derive_u_w

; 558  : 	burn (k, sizeof(k));

  000ee	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _k$[ebp]
  000f4	8b d6		 mov	 edx, esi
  000f6	8b c1		 mov	 eax, ecx
$LL24@derive_u_w:
  000f8	c6 00 00	 mov	 BYTE PTR [eax], 0
  000fb	40		 inc	 eax
  000fc	4e		 dec	 esi
  000fd	75 f9		 jne	 SHORT $LL24@derive_u_w
  000ff	5f		 pop	 edi
  00100	5e		 pop	 esi
  00101	5b		 pop	 ebx
$LL2@derive_u_w:
  00102	4a		 dec	 edx
  00103	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00106	41		 inc	 ecx
  00107	85 d2		 test	 edx, edx
  00109	75 f7		 jne	 SHORT $LL2@derive_u_w

; 559  : }

  0010b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010e	33 cd		 xor	 ecx, ebp
  00110	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00115	c9		 leave
  00116	c2 1c 00	 ret	 28			; 0000001cH
_derive_u_whirlpool@28 ENDP
_TEXT	ENDS
PUBLIC	_dk$GSCopy$
PUBLIC	_salt$GSCopy$
PUBLIC	_pwd$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_derive_key_whirlpool@28
; Function compile flags: /Ogsp
;	COMDAT _derive_key_whirlpool@28
_TEXT	SEGMENT
_r$ = -88						; size = 4
_pwd$GSCopy$ = -84					; size = 4
_salt$GSCopy$ = -80					; size = 4
_dk$GSCopy$ = -76					; size = 4
_b$ = -72						; size = 4
_u$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_dk$ = 28						; size = 4
_dklen$ = 32						; size = 4
_derive_key_whirlpool@28 PROC				; COMDAT

; 562  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 58	 sub	 esp, 88			; 00000058H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 573  : 	}
; 574  : 
; 575  : 	r = dklen - (l - 1) * WHIRLPOOL_DIGESTSIZE;

  00012	8b 45 08	 mov	 eax, DWORD PTR _pwd$[ebp]
  00015	8b 4d 20	 mov	 ecx, DWORD PTR _dklen$[ebp]
  00018	89 45 ac	 mov	 DWORD PTR _pwd$GSCopy$[ebp], eax
  0001b	8b 45 10	 mov	 eax, DWORD PTR _salt$[ebp]
  0001e	89 45 b0	 mov	 DWORD PTR _salt$GSCopy$[ebp], eax
  00021	8b 45 1c	 mov	 eax, DWORD PTR _dk$[ebp]
  00024	89 45 b4	 mov	 DWORD PTR _dk$GSCopy$[ebp], eax
  00027	8b c1		 mov	 eax, ecx
  00029	25 3f 00 00 80	 and	 eax, -2147483585	; 8000003fH
  0002e	53		 push	 ebx
  0002f	56		 push	 esi
  00030	79 05		 jns	 SHORT $LN28@derive_key@4
  00032	48		 dec	 eax
  00033	83 c8 c0	 or	 eax, -64		; ffffffc0H
  00036	40		 inc	 eax
$LN28@derive_key@4:
  00037	8b c1		 mov	 eax, ecx
  00039	99		 cdq
  0003a	74 0d		 je	 SHORT $LN10@derive_key@4
  0003c	83 e2 3f	 and	 edx, 63			; 0000003fH
  0003f	03 c2		 add	 eax, edx
  00041	8b d8		 mov	 ebx, eax
  00043	c1 fb 06	 sar	 ebx, 6
  00046	43		 inc	 ebx
  00047	eb 0a		 jmp	 SHORT $LN9@derive_key@4
$LN10@derive_key@4:

; 563  : 	char u[WHIRLPOOL_DIGESTSIZE];
; 564  : 	int b, l, r;
; 565  : 
; 566  : 	if (dklen % WHIRLPOOL_DIGESTSIZE)
; 567  : 	{
; 568  : 		l = 1 + dklen / WHIRLPOOL_DIGESTSIZE;
; 569  : 	}
; 570  : 	else
; 571  : 	{
; 572  : 		l = dklen / WHIRLPOOL_DIGESTSIZE;

  00049	83 e2 3f	 and	 edx, 63			; 0000003fH
  0004c	03 c2		 add	 eax, edx
  0004e	8b d8		 mov	 ebx, eax
  00050	c1 fb 06	 sar	 ebx, 6
$LN9@derive_key@4:

; 573  : 	}
; 574  : 
; 575  : 	r = dklen - (l - 1) * WHIRLPOOL_DIGESTSIZE;

  00053	8b c3		 mov	 eax, ebx
  00055	c1 e0 06	 shl	 eax, 6
  00058	2b c8		 sub	 ecx, eax

; 576  : 
; 577  : 	/* first l - 1 blocks */
; 578  : 	for (b = 1; b < l; b++)

  0005a	33 c0		 xor	 eax, eax
  0005c	40		 inc	 eax
  0005d	83 c1 40	 add	 ecx, 64			; 00000040H
  00060	3b d8		 cmp	 ebx, eax
  00062	89 4d a8	 mov	 DWORD PTR _r$[ebp], ecx
  00065	89 45 b8	 mov	 DWORD PTR _b$[ebp], eax
  00068	7e 34		 jle	 SHORT $LN6@derive_key@4
  0006a	57		 push	 edi
$LL26@derive_key@4:

; 579  : 	{
; 580  : 		derive_u_whirlpool (pwd, pwd_len, salt, salt_len, iterations, u, b);

  0006b	ff 75 b8	 push	 DWORD PTR _b$[ebp]
  0006e	8d 45 bc	 lea	 eax, DWORD PTR _u$[ebp]
  00071	50		 push	 eax
  00072	ff 75 18	 push	 DWORD PTR _iterations$[ebp]
  00075	ff 75 14	 push	 DWORD PTR _salt_len$[ebp]
  00078	ff 75 b0	 push	 DWORD PTR _salt$GSCopy$[ebp]
  0007b	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  0007e	ff 75 ac	 push	 DWORD PTR _pwd$GSCopy$[ebp]
  00081	e8 00 00 00 00	 call	 _derive_u_whirlpool@28

; 581  : 		memcpy (dk, u, WHIRLPOOL_DIGESTSIZE);

  00086	8b 7d b4	 mov	 edi, DWORD PTR _dk$GSCopy$[ebp]

; 582  : 		dk += WHIRLPOOL_DIGESTSIZE;

  00089	83 45 b4 40	 add	 DWORD PTR _dk$GSCopy$[ebp], 64 ; 00000040H
  0008d	ff 45 b8	 inc	 DWORD PTR _b$[ebp]
  00090	39 5d b8	 cmp	 DWORD PTR _b$[ebp], ebx
  00093	6a 10		 push	 16			; 00000010H
  00095	59		 pop	 ecx
  00096	8d 75 bc	 lea	 esi, DWORD PTR _u$[ebp]
  00099	f3 a5		 rep movsd
  0009b	7c ce		 jl	 SHORT $LL26@derive_key@4
  0009d	5f		 pop	 edi
$LN6@derive_key@4:

; 583  : 	}
; 584  : 
; 585  : 	/* last block */
; 586  : 	derive_u_whirlpool (pwd, pwd_len, salt, salt_len, iterations, u, b);

  0009e	ff 75 b8	 push	 DWORD PTR _b$[ebp]
  000a1	8d 45 bc	 lea	 eax, DWORD PTR _u$[ebp]
  000a4	50		 push	 eax
  000a5	ff 75 18	 push	 DWORD PTR _iterations$[ebp]
  000a8	ff 75 14	 push	 DWORD PTR _salt_len$[ebp]
  000ab	ff 75 b0	 push	 DWORD PTR _salt$GSCopy$[ebp]
  000ae	ff 75 0c	 push	 DWORD PTR _pwd_len$[ebp]
  000b1	ff 75 ac	 push	 DWORD PTR _pwd$GSCopy$[ebp]
  000b4	e8 00 00 00 00	 call	 _derive_u_whirlpool@28

; 587  : 	memcpy (dk, u, r);

  000b9	ff 75 a8	 push	 DWORD PTR _r$[ebp]
  000bc	8d 45 bc	 lea	 eax, DWORD PTR _u$[ebp]
  000bf	50		 push	 eax
  000c0	ff 75 b4	 push	 DWORD PTR _dk$GSCopy$[ebp]
  000c3	e8 00 00 00 00	 call	 _memcpy
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 588  : 
; 589  : 
; 590  : 	/* Prevent possible leaks. */
; 591  : 	burn (u, sizeof(u));

  000cb	6a 40		 push	 64			; 00000040H
  000cd	8d 4d bc	 lea	 ecx, DWORD PTR _u$[ebp]
  000d0	5e		 pop	 esi
  000d1	8b d6		 mov	 edx, esi
  000d3	8b c1		 mov	 eax, ecx
$LL14@derive_key@4:
  000d5	c6 00 00	 mov	 BYTE PTR [eax], 0
  000d8	40		 inc	 eax
  000d9	4e		 dec	 esi
  000da	75 f9		 jne	 SHORT $LL14@derive_key@4
  000dc	5e		 pop	 esi
  000dd	5b		 pop	 ebx
$LL2@derive_key@4:
  000de	4a		 dec	 edx
  000df	c6 01 00	 mov	 BYTE PTR [ecx], 0
  000e2	41		 inc	 ecx
  000e3	85 d2		 test	 edx, edx
  000e5	75 f7		 jne	 SHORT $LL2@derive_key@4

; 592  : }

  000e7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ea	33 cd		 xor	 ecx, ebp
  000ec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f1	c9		 leave
  000f2	c2 1c 00	 ret	 28			; 0000001cH
_derive_key_whirlpool@28 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@EMJCKHIJ@HMAC?9RIPEMD?9160?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0N@PGAIHMNP@HMAC?9SHA?9512?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0L@GENPDEDH@HMAC?9SHA?91?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	_get_pkcs5_prf_name@4
;	COMDAT ??_C@_0BA@EMJCKHIJ@HMAC?9RIPEMD?9160?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BA@EMJCKHIJ@HMAC?9RIPEMD?9160?$AA@FNODOBFM@ DB 'HMAC-RIPEMD-160', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0N@PGAIHMNP@HMAC?9SHA?9512?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0N@PGAIHMNP@HMAC?9SHA?9512?$AA@FNODOBFM@ DB 'HMAC-SHA-512', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@FNODOBFM@ DB 'HMAC-Whirlpool', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0L@GENPDEDH@HMAC?9SHA?91?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0L@GENPDEDH@HMAC?9SHA?91?$AA@FNODOBFM@ DB 'HMAC-SHA-1', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@FNODOBFM@ DB '(Unknown)', 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
text$s	ENDS
;	COMDAT _get_pkcs5_prf_name@4
_TEXT	SEGMENT
_pkcs5_prf_id$ = 8					; size = 4
_get_pkcs5_prf_name@4 PROC				; COMDAT

; 596  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 597  : 	switch (pkcs5_prf_id)

  00005	8b 45 08	 mov	 eax, DWORD PTR _pkcs5_prf_id$[ebp]
  00008	48		 dec	 eax
  00009	74 25		 je	 SHORT $LN3@get_pkcs5_
  0000b	48		 dec	 eax
  0000c	74 1b		 je	 SHORT $LN5@get_pkcs5_
  0000e	48		 dec	 eax
  0000f	74 11		 je	 SHORT $LN2@get_pkcs5_
  00011	48		 dec	 eax
  00012	74 07		 je	 SHORT $LN4@get_pkcs5_

; 610  : 
; 611  : 	default:		
; 612  : 		return "(Unknown)";

  00014	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@FNODOBFM@
  00019	eb 1a		 jmp	 SHORT $LN6@get_pkcs5_
$LN4@get_pkcs5_:

; 601  : 
; 602  : 	case SHA1:	// Deprecated/legacy
; 603  : 		return "HMAC-SHA-1";

  0001b	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0L@GENPDEDH@HMAC?9SHA?91?$AA@FNODOBFM@
  00020	eb 13		 jmp	 SHORT $LN6@get_pkcs5_
$LN2@get_pkcs5_:

; 607  : 
; 608  : 	case WHIRLPOOL:	
; 609  : 		return "HMAC-Whirlpool";

  00022	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@FNODOBFM@
  00027	eb 0c		 jmp	 SHORT $LN6@get_pkcs5_
$LN5@get_pkcs5_:

; 598  : 	{
; 599  : 	case SHA512:	
; 600  : 		return "HMAC-SHA-512";

  00029	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0N@PGAIHMNP@HMAC?9SHA?9512?$AA@FNODOBFM@
  0002e	eb 05		 jmp	 SHORT $LN6@get_pkcs5_
$LN3@get_pkcs5_:

; 604  : 
; 605  : 	case RIPEMD160:	
; 606  : 		return "HMAC-RIPEMD-160";

  00030	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BA@EMJCKHIJ@HMAC?9RIPEMD?9160?$AA@FNODOBFM@
$LN6@get_pkcs5_:

; 613  : 	}
; 614  : }

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
_get_pkcs5_prf_name@4 ENDP
_TEXT	ENDS
PUBLIC	_get_pkcs5_iteration_count@8
EXTRN	__imp__KeBugCheckEx@20:PROC
; Function compile flags: /Ogsp
;	COMDAT _get_pkcs5_iteration_count@8
_TEXT	SEGMENT
_pkcs5_prf_id$ = 8					; size = 4
_bBoot$ = 12						; size = 4
_get_pkcs5_iteration_count@8 PROC			; COMDAT

; 620  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 621  : 	switch (pkcs5_prf_id)

  00005	8b 45 08	 mov	 eax, DWORD PTR _pkcs5_prf_id$[ebp]
  00008	48		 dec	 eax
  00009	74 2d		 je	 SHORT $LN5@get_pkcs5_@2
  0000b	48		 dec	 eax
  0000c	74 23		 je	 SHORT $LN4@get_pkcs5_@2
  0000e	48		 dec	 eax
  0000f	74 20		 je	 SHORT $LN4@get_pkcs5_@2
  00011	48		 dec	 eax
  00012	74 16		 je	 SHORT $LN3@get_pkcs5_@2

; 633  : 
; 634  : 	case WHIRLPOOL:	
; 635  : 		return 1000;
; 636  : #endif
; 637  : 
; 638  : 	default:		
; 639  : 		TC_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID

  00014	68 43 54 00 00	 push	 21571			; 00005443H
  00019	6a 00		 push	 0
  0001b	6a 00		 push	 0
  0001d	68 7f 02 00 00	 push	 639			; 0000027fH
  00022	6a 29		 push	 41			; 00000029H
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN11@get_pkcs5_@2:
$LN3@get_pkcs5_@2:

; 630  : 
; 631  : 	case SHA1:		// Deprecated/legacy		
; 632  : 		return 2000;			

  0002a	b8 d0 07 00 00	 mov	 eax, 2000		; 000007d0H
  0002f	eb 18		 jmp	 SHORT $LN8@get_pkcs5_@2
$LN4@get_pkcs5_@2:

; 625  : 
; 626  : #ifndef TC_WINDOWS_BOOT
; 627  : 
; 628  : 	case SHA512:	
; 629  : 		return 1000;			

  00031	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  00036	eb 11		 jmp	 SHORT $LN8@get_pkcs5_@2
$LN5@get_pkcs5_@2:

; 622  : 	{
; 623  : 	case RIPEMD160:	
; 624  : 		return (bBoot ? 1000 : 2000);

  00038	8b 45 0c	 mov	 eax, DWORD PTR _bBoot$[ebp]
  0003b	f7 d8		 neg	 eax
  0003d	1b c0		 sbb	 eax, eax
  0003f	25 18 fc ff ff	 and	 eax, -1000		; fffffc18H
  00044	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
$LN8@get_pkcs5_@2:

; 640  : 	}
; 641  : 	return 0;
; 642  : }

  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
$LN10@get_pkcs5_@2:
_get_pkcs5_iteration_count@8 ENDP
_TEXT	ENDS
END
