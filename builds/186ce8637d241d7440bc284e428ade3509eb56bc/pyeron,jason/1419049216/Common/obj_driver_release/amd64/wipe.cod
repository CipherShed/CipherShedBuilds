; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	GetWipePassCount
;	COMDAT pdata
; File c:\home\public\desktop\projects\ciphershed\src\common\wipe.c
pdata	SEGMENT
$pdata$GetWipePassCount DD imagerel $LN11
	DD	imagerel $LN11+94
	DD	imagerel $unwind$GetWipePassCount
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetWipePassCount DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GetWipePassCount
_TEXT	SEGMENT
algorithm$ = 64
GetWipePassCount PROC					; COMDAT

; 143  : {

$LN11:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 144  : 	switch (algorithm)

  00004	83 f9 64	 cmp	 ecx, 100		; 00000064H
  00007	74 4b		 je	 SHORT $LN5@GetWipePas
  00009	81 f9 2c 01 00
	00		 cmp	 ecx, 300		; 0000012cH
  0000f	74 3c		 je	 SHORT $LN4@GetWipePas
  00011	81 f9 bc 02 00
	00		 cmp	 ecx, 700		; 000002bcH
  00017	74 2d		 je	 SHORT $LN3@GetWipePas
  00019	81 f9 ac 0d 00
	00		 cmp	 ecx, 3500		; 00000dacH
  0001f	74 1e		 je	 SHORT $LN2@GetWipePas

; 157  : 
; 158  : 	default:
; 159  : 		TC_THROW_FATAL_EXCEPTION;

  00021	ba 9f 00 00 00	 mov	 edx, 159		; 0000009fH
  00026	45 33 c9	 xor	 r9d, r9d
  00029	45 33 c0	 xor	 r8d, r8d
  0002c	8d 4a 8a	 lea	 ecx, QWORD PTR [rdx-118]
  0002f	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  0003e	cc		 int	 3
$LN2@GetWipePas:

; 154  : 
; 155  : 	case TC_WIPE_35_GUTMANN:
; 156  : 		return 35;

  0003f	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  00044	eb 13		 jmp	 SHORT $LN8@GetWipePas
$LN3@GetWipePas:

; 151  : 
; 152  : 	case TC_WIPE_7_DOD_5220:
; 153  : 		return 7;

  00046	b8 07 00 00 00	 mov	 eax, 7
  0004b	eb 0c		 jmp	 SHORT $LN8@GetWipePas
$LN4@GetWipePas:

; 148  : 
; 149  : 	case TC_WIPE_3_DOD_5220:
; 150  : 		return 3;

  0004d	b8 03 00 00 00	 mov	 eax, 3
  00052	eb 05		 jmp	 SHORT $LN8@GetWipePas
$LN5@GetWipePas:

; 145  : 	{
; 146  : 	case TC_WIPE_1_RAND:
; 147  : 		return 1;

  00054	b8 01 00 00 00	 mov	 eax, 1
$LN8@GetWipePas:

; 160  : 	}
; 161  : 
; 162  : 	return 0;	// Prevent compiler warnings
; 163  : }

  00059	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005d	c3		 ret	 0
$LN10@GetWipePas:
GetWipePassCount ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Wipe35Gutmann DD imagerel Wipe35Gutmann
	DD	imagerel Wipe35Gutmann+212
	DD	imagerel $unwind$Wipe35Gutmann
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Wipe35Gutmann DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT Wipe35Gutmann
_TEXT	SEGMENT
wipePat3$ = 48
pass$ = 48
buffer$ = 56
size$ = 64
Wipe35Gutmann PROC					; COMDAT

; 84   : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 85   : 	byte wipePat3[] = { 0x92, 0x49, 0x24 };
; 86   : 	int wipePat3Pos;
; 87   : 	size_t i;
; 88   : 
; 89   : 	switch (pass)

  00006	33 db		 xor	 ebx, ebx
  00008	83 f9 1a	 cmp	 ecx, 26
  0000b	4c 8b da	 mov	 r11, rdx
  0000e	44 8b c9	 mov	 r9d, ecx
  00011	c6 44 24 30 92	 mov	 BYTE PTR wipePat3$[rsp], 146 ; 00000092H
  00016	c6 44 24 31 49	 mov	 BYTE PTR wipePat3$[rsp+1], 73 ; 00000049H
  0001b	c6 44 24 32 24	 mov	 BYTE PTR wipePat3$[rsp+2], 36 ; 00000024H
  00020	7f 1a		 jg	 SHORT $LN17@Wipe35Gutm
  00022	74 4b		 je	 SHORT $LN10@Wipe35Gutm
  00024	83 e9 05	 sub	 ecx, 5
  00027	74 0c		 je	 SHORT $LN12@Wipe35Gutm
  00029	83 e9 01	 sub	 ecx, 1
  0002c	75 18		 jne	 SHORT $LN20@Wipe35Gutm

; 94   : 
; 95   : 	case 6:
; 96   : 		memset (buffer, 0xaa, size);

  0002e	ba aa 00 00 00	 mov	 edx, 170		; 000000aaH

; 97   : 		break;

  00033	eb 2c		 jmp	 SHORT $LN21@Wipe35Gutm
$LN12@Wipe35Gutm:

; 90   : 	{
; 91   : 	case 5:
; 92   : 		memset (buffer, 0x55, size);

  00035	ba 55 00 00 00	 mov	 edx, 85			; 00000055H

; 93   : 		break;

  0003a	eb 25		 jmp	 SHORT $LN21@Wipe35Gutm
$LN17@Wipe35Gutm:

; 85   : 	byte wipePat3[] = { 0x92, 0x49, 0x24 };
; 86   : 	int wipePat3Pos;
; 87   : 	size_t i;
; 88   : 
; 89   : 	switch (pass)

  0003c	83 e9 1b	 sub	 ecx, 27
  0003f	74 3b		 je	 SHORT $LN9@Wipe35Gutm
  00041	83 e9 01	 sub	 ecx, 1
  00044	74 2e		 je	 SHORT $LN8@Wipe35Gutm
$LN20@Wipe35Gutm:
  00046	83 e9 01	 sub	 ecx, 1
  00049	74 24		 je	 SHORT $LN10@Wipe35Gutm
  0004b	83 e9 01	 sub	 ecx, 1
  0004e	74 2c		 je	 SHORT $LN9@Wipe35Gutm
  00050	83 f9 01	 cmp	 ecx, 1
  00053	74 1f		 je	 SHORT $LN8@Wipe35Gutm

; 128  : 		}
; 129  : 		break;
; 130  : 
; 131  : 	default:
; 132  : 		if (pass >= 10 && pass <= 25)

  00055	41 8d 51 f6	 lea	 edx, DWORD PTR [r9-10]
  00059	83 fa 0f	 cmp	 edx, 15
  0005c	77 0d		 ja	 SHORT $LN2@Wipe35Gutm

; 133  : 			memset (buffer, (pass - 10) * 0x11, size);

  0005e	6b d2 11	 imul	 edx, 17
$LN21@Wipe35Gutm:
  00061	49 8b cb	 mov	 rcx, r11
  00064	e8 00 00 00 00	 call	 memset

; 134  : 		else

  00069	eb 5e		 jmp	 SHORT $LN4@Wipe35Gutm
$LN2@Wipe35Gutm:

; 135  : 			return FALSE;

  0006b	33 c0		 xor	 eax, eax
  0006d	eb 5f		 jmp	 SHORT $LN15@Wipe35Gutm
$LN10@Wipe35Gutm:

; 98   : 
; 99   : 	case 7:
; 100  : 	case 26:
; 101  : 	case 29:
; 102  : 		wipePat3Pos = 0;

  0006f	44 8b d3	 mov	 r10d, ebx

; 103  : 		goto wipe3;

  00072	eb 0e		 jmp	 SHORT $wipe3$26454
$LN8@Wipe35Gutm:

; 109  : 		goto wipe3;
; 110  : 
; 111  : 	case 9:
; 112  : 	case 28:
; 113  : 	case 31:
; 114  : 		wipePat3Pos = 2;

  00074	41 ba 02 00 00
	00		 mov	 r10d, 2
  0007a	eb 06		 jmp	 SHORT $wipe3$26454
$LN9@Wipe35Gutm:

; 104  : 
; 105  : 	case 8:
; 106  : 	case 27:
; 107  : 	case 30:
; 108  : 		wipePat3Pos = 1;

  0007c	41 ba 01 00 00
	00		 mov	 r10d, 1
$wipe3$26454:

; 115  : 		goto wipe3;
; 116  : 
; 117  : wipe3:
; 118  : 		if (pass >= 29)

  00082	41 83 f9 1d	 cmp	 r9d, 29
  00086	7c 0f		 jl	 SHORT $LN7@Wipe35Gutm

; 119  : 		{
; 120  : 			wipePat3[0] = ~wipePat3[0];

  00088	c6 44 24 30 6d	 mov	 BYTE PTR wipePat3$[rsp], 109 ; 0000006dH

; 121  : 			wipePat3[1] = ~wipePat3[1];

  0008d	c6 44 24 31 b6	 mov	 BYTE PTR wipePat3$[rsp+1], 182 ; 000000b6H

; 122  : 			wipePat3[2] = ~wipePat3[2];

  00092	c6 44 24 32 db	 mov	 BYTE PTR wipePat3$[rsp+2], 219 ; 000000dbH
$LN7@Wipe35Gutm:

; 123  : 		}
; 124  : 
; 125  : 		for (i = 0; i < size; ++i)

  00097	4c 3b c3	 cmp	 r8, rbx
  0009a	76 2d		 jbe	 SHORT $LN4@Wipe35Gutm
$LL6@Wipe35Gutm:

; 126  : 		{
; 127  : 			buffer[i] = wipePat3[wipePat3Pos++ % 3];

  0009c	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  000a1	41 f7 ea	 imul	 r10d
  000a4	8b c2		 mov	 eax, edx
  000a6	c1 e8 1f	 shr	 eax, 31
  000a9	03 d0		 add	 edx, eax
  000ab	8d 0c 52	 lea	 ecx, DWORD PTR [rdx+rdx*2]
  000ae	41 8b d2	 mov	 edx, r10d
  000b1	41 ff c2	 inc	 r10d
  000b4	2b d1		 sub	 edx, ecx
  000b6	48 63 ca	 movsxd	 rcx, edx
  000b9	8a 54 0c 30	 mov	 dl, BYTE PTR wipePat3$[rsp+rcx]
  000bd	42 88 14 1b	 mov	 BYTE PTR [rbx+r11], dl
  000c1	48 ff c3	 inc	 rbx
  000c4	49 3b d8	 cmp	 rbx, r8
  000c7	72 d3		 jb	 SHORT $LL6@Wipe35Gutm
$LN4@Wipe35Gutm:

; 136  : 	}
; 137  : 
; 138  : 	return TRUE;

  000c9	b8 01 00 00 00	 mov	 eax, 1
$LN15@Wipe35Gutm:

; 139  : }

  000ce	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d2	5b		 pop	 rbx
  000d3	c3		 ret	 0
Wipe35Gutmann ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Wipe7Dod5220 DD imagerel Wipe7Dod5220
	DD	imagerel Wipe7Dod5220+83
	DD	imagerel $unwind$Wipe7Dod5220
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Wipe7Dod5220 DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT Wipe7Dod5220
_TEXT	SEGMENT
pass$ = 48
randChars$ = 56
buffer$ = 64
size$ = 72
Wipe7Dod5220 PROC					; COMDAT

; 46   : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 47   : 	byte wipeChar;
; 48   : 
; 49   : 	switch (pass)

  00004	83 e9 01	 sub	 ecx, 1
  00007	4d 8b d0	 mov	 r10, r8
  0000a	74 2d		 je	 SHORT $LN6@Wipe7Dod52
  0000c	83 e9 01	 sub	 ecx, 1
  0000f	74 22		 je	 SHORT $LN5@Wipe7Dod52
  00011	83 e9 02	 sub	 ecx, 2
  00014	74 18		 je	 SHORT $LN4@Wipe7Dod52
  00016	83 e9 01	 sub	 ecx, 1
  00019	74 0e		 je	 SHORT $LN3@Wipe7Dod52
  0001b	83 f9 01	 cmp	 ecx, 1
  0001e	74 04		 je	 SHORT $LN2@Wipe7Dod52

; 70   : 
; 71   : 	default:
; 72   : 		return FALSE;

  00020	33 c0		 xor	 eax, eax
  00022	eb 2a		 jmp	 SHORT $LN9@Wipe7Dod52
$LN2@Wipe7Dod52:

; 66   : 
; 67   : 	case 6:
; 68   : 		wipeChar = ~randChars[2];

  00024	8a 42 02	 mov	 al, BYTE PTR [rdx+2]

; 69   : 		break;

  00027	eb 0c		 jmp	 SHORT $LN11@Wipe7Dod52
$LN3@Wipe7Dod52:

; 62   : 
; 63   : 	case 5:
; 64   : 		wipeChar = randChars[2];

  00029	8a 42 02	 mov	 al, BYTE PTR [rdx+2]

; 65   : 		break;

  0002c	eb 0d		 jmp	 SHORT $LN7@Wipe7Dod52
$LN4@Wipe7Dod52:

; 58   : 
; 59   : 	case 4:
; 60   : 		wipeChar = randChars[1];

  0002e	8a 42 01	 mov	 al, BYTE PTR [rdx+1]

; 61   : 		break;

  00031	eb 08		 jmp	 SHORT $LN7@Wipe7Dod52
$LN5@Wipe7Dod52:

; 53   : 		break;
; 54   : 
; 55   : 	case 2:
; 56   : 		wipeChar = ~randChars[0];

  00033	8a 02		 mov	 al, BYTE PTR [rdx]
$LN11@Wipe7Dod52:
  00035	f6 d0		 not	 al

; 57   : 		break;

  00037	eb 02		 jmp	 SHORT $LN7@Wipe7Dod52
$LN6@Wipe7Dod52:

; 50   : 	{
; 51   : 	case 1:
; 52   : 		wipeChar = randChars[0];

  00039	8a 02		 mov	 al, BYTE PTR [rdx]
$LN7@Wipe7Dod52:

; 73   : 	}
; 74   : 
; 75   : 	memset (buffer, wipeChar, size);

  0003b	0f b6 d0	 movzx	 edx, al
  0003e	4d 8b c1	 mov	 r8, r9
  00041	49 8b ca	 mov	 rcx, r10
  00044	e8 00 00 00 00	 call	 memset

; 76   : 	return TRUE;

  00049	b8 01 00 00 00	 mov	 eax, 1
$LN9@Wipe7Dod52:

; 77   : }

  0004e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00052	c3		 ret	 0
Wipe7Dod5220 ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Wipe3Dod5220 DD imagerel Wipe3Dod5220
	DD	imagerel Wipe3Dod5220+48
	DD	imagerel $unwind$Wipe3Dod5220
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Wipe3Dod5220 DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT Wipe3Dod5220
_TEXT	SEGMENT
pass$ = 48
buffer$ = 56
size$ = 64
Wipe3Dod5220 PROC					; COMDAT

; 23   : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 24   : 	byte wipeChar;
; 25   : 
; 26   : 	switch (pass)

  00004	83 e9 01	 sub	 ecx, 1
  00007	4c 8b ca	 mov	 r9, rdx
  0000a	74 0d		 je	 SHORT $LN3@Wipe3Dod52
  0000c	83 f9 01	 cmp	 ecx, 1
  0000f	74 04		 je	 SHORT $LN2@Wipe3Dod52

; 35   : 
; 36   : 	default:
; 37   : 		return FALSE;

  00011	33 c0		 xor	 eax, eax
  00013	eb 16		 jmp	 SHORT $LN6@Wipe3Dod52
$LN2@Wipe3Dod52:

; 30   : 		break;
; 31   : 
; 32   : 	case 2:
; 33   : 		wipeChar = 0xff;

  00015	b0 ff		 mov	 al, 255			; 000000ffH

; 34   : 		break;

  00017	eb 02		 jmp	 SHORT $LN4@Wipe3Dod52
$LN3@Wipe3Dod52:

; 27   : 	{
; 28   : 	case 1:
; 29   : 		wipeChar = 0;

  00019	32 c0		 xor	 al, al
$LN4@Wipe3Dod52:

; 38   : 	}
; 39   : 
; 40   : 	memset (buffer, wipeChar, size);

  0001b	0f b6 d0	 movzx	 edx, al
  0001e	49 8b c9	 mov	 rcx, r9
  00021	e8 00 00 00 00	 call	 memset

; 41   : 	return TRUE;

  00026	b8 01 00 00 00	 mov	 eax, 1
$LN6@Wipe3Dod52:

; 42   : }

  0002b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002f	c3		 ret	 0
Wipe3Dod5220 ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT Wipe1PseudoRandom
_TEXT	SEGMENT
pass$ = 8
buffer$ = 16
size$ = 24
Wipe1PseudoRandom PROC					; COMDAT

; 15   : 	return FALSE;

  00000	33 c0		 xor	 eax, eax

; 16   : }

  00002	c3		 ret	 0
Wipe1PseudoRandom ENDP
PUBLIC	WipeBuffer
;	COMDAT pdata
pdata	SEGMENT
$pdata$WipeBuffer DD imagerel $LN32
	DD	imagerel $LN32+192
	DD	imagerel $unwind$WipeBuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$WipeBuffer DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT WipeBuffer
_TEXT	SEGMENT
algorithm$ = 64
randChars$ = 72
pass$ = 80
buffer$ = 88
size$ = 96
WipeBuffer PROC						; COMDAT

; 167  : {

$LN32:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	45 8b d0	 mov	 r10d, r8d

; 168  : 	switch (algorithm)

  00007	83 f9 64	 cmp	 ecx, 100		; 00000064H
  0000a	0f 84 a9 00 00
	00		 je	 $LN5@WipeBuffer
  00010	81 f9 2c 01 00
	00		 cmp	 ecx, 300		; 0000012cH
  00016	74 78		 je	 SHORT $LN4@WipeBuffer
  00018	81 f9 bc 02 00
	00		 cmp	 ecx, 700		; 000002bcH
  0001e	74 39		 je	 SHORT $LN3@WipeBuffer
  00020	81 f9 ac 0d 00
	00		 cmp	 ecx, 3500		; 00000dacH
  00026	74 1f		 je	 SHORT $LN2@WipeBuffer

; 181  : 
; 182  : 	default:
; 183  : 		TC_THROW_FATAL_EXCEPTION;

  00028	45 33 c9	 xor	 r9d, r9d
  0002b	45 33 c0	 xor	 r8d, r8d
  0002e	ba b7 00 00 00	 mov	 edx, 183		; 000000b7H
  00033	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00037	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00046	cc		 int	 3
$LN2@WipeBuffer:

; 178  : 
; 179  : 	case TC_WIPE_35_GUTMANN:
; 180  : 		return Wipe35Gutmann (pass, buffer, size);

  00047	4c 8b 44 24 60	 mov	 r8, QWORD PTR size$[rsp]
  0004c	49 8b d1	 mov	 rdx, r9
  0004f	41 8b ca	 mov	 ecx, r10d
  00052	e8 00 00 00 00	 call	 Wipe35Gutmann
  00057	eb 62		 jmp	 SHORT $LN8@WipeBuffer
$LN3@WipeBuffer:

; 175  : 
; 176  : 	case TC_WIPE_7_DOD_5220:
; 177  : 		return Wipe7Dod5220 (pass, randChars, buffer, size);

  00059	41 83 ea 01	 sub	 r10d, 1
  0005d	74 2d		 je	 SHORT $LN24@WipeBuffer
  0005f	41 83 ea 01	 sub	 r10d, 1
  00063	74 21		 je	 SHORT $LN23@WipeBuffer
  00065	41 83 ea 02	 sub	 r10d, 2
  00069	74 16		 je	 SHORT $LN22@WipeBuffer
  0006b	41 83 ea 01	 sub	 r10d, 1
  0006f	74 0b		 je	 SHORT $LN21@WipeBuffer
  00071	41 83 fa 01	 cmp	 r10d, 1
  00075	75 42		 jne	 SHORT $LN5@WipeBuffer
  00077	8a 42 02	 mov	 al, BYTE PTR [rdx+2]
  0007a	eb 0c		 jmp	 SHORT $LN30@WipeBuffer
$LN21@WipeBuffer:
  0007c	8a 42 02	 mov	 al, BYTE PTR [rdx+2]
  0007f	eb 21		 jmp	 SHORT $LN15@WipeBuffer
$LN22@WipeBuffer:
  00081	8a 42 01	 mov	 al, BYTE PTR [rdx+1]
  00084	eb 1c		 jmp	 SHORT $LN15@WipeBuffer
$LN23@WipeBuffer:
  00086	8a 02		 mov	 al, BYTE PTR [rdx]
$LN30@WipeBuffer:
  00088	f6 d0		 not	 al
  0008a	eb 16		 jmp	 SHORT $LN15@WipeBuffer
$LN24@WipeBuffer:
  0008c	8a 02		 mov	 al, BYTE PTR [rdx]
  0008e	eb 12		 jmp	 SHORT $LN15@WipeBuffer
$LN4@WipeBuffer:

; 172  : 
; 173  : 	case TC_WIPE_3_DOD_5220:
; 174  : 		return Wipe3Dod5220 (pass, buffer, size);

  00090	41 83 ea 01	 sub	 r10d, 1
  00094	74 0a		 je	 SHORT $LN14@WipeBuffer
  00096	41 83 fa 01	 cmp	 r10d, 1
  0009a	75 1d		 jne	 SHORT $LN5@WipeBuffer
  0009c	b0 ff		 mov	 al, 255			; 000000ffH
  0009e	eb 02		 jmp	 SHORT $LN15@WipeBuffer
$LN14@WipeBuffer:
  000a0	33 c0		 xor	 eax, eax
$LN15@WipeBuffer:
  000a2	4c 8b 44 24 60	 mov	 r8, QWORD PTR size$[rsp]
  000a7	0f b6 d0	 movzx	 edx, al
  000aa	49 8b c9	 mov	 rcx, r9
  000ad	e8 00 00 00 00	 call	 memset
  000b2	b8 01 00 00 00	 mov	 eax, 1
  000b7	eb 02		 jmp	 SHORT $LN8@WipeBuffer
$LN5@WipeBuffer:

; 169  : 	{
; 170  : 	case TC_WIPE_1_RAND:
; 171  : 		return Wipe1PseudoRandom (pass, buffer, size);

  000b9	33 c0		 xor	 eax, eax
$LN8@WipeBuffer:

; 184  : 	}
; 185  : 
; 186  : 	return FALSE;	// Prevent compiler warnings
; 187  : }

  000bb	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bf	c3		 ret	 0
$LN29@WipeBuffer:
WipeBuffer ENDP
END
