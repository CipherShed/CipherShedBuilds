;	Static Name Aliases
;
	TITLE   ..\..\..\common\volumes.c
	.MODEL  SMALL
	.386p
	.387
_TEXT	SEGMENT  WORD USE16 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT  WORD USE16 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT  WORD USE16 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT  WORD USE16 PUBLIC 'BSS'
_BSS	ENDS
DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME DS: DGROUP, SS: DGROUP
EXTRN	_DecryptBuffer:NEAR
EXTRN	_EAGetFirst:NEAR
EXTRN	_EAGetNext:NEAR
EXTRN	_crypto_open:NEAR
EXTRN	_EAGetKeySize:NEAR
EXTRN	_crypto_close:NEAR
EXTRN	_derive_key_ripemd160:NEAR
EXTRN	_memcpy:NEAR
EXTRN	_GetCrc32:NEAR
EXTRN	_EAInit:NEAR
EXTRN	_MirrorBytes16:NEAR
EXTRN	_EraseMemory:NEAR
EXTRN	_MirrorBytes32:NEAR
EXTRN	_EncryptBuffer:NEAR
_BSS      SEGMENT
COMM NEAR	__mbac:	BYTE:	 8
_BSS      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	PUBLIC	_GetHeaderField16
_GetHeaderField16	PROC NEAR	;  COMDAT
;|*** /*
;|***  Legal Notice: Some portions of the source code contained in this file were
;|***  derived from the source code of Encryption for the Masses 2.02a, which is
;|***  Copyright (c) 1998-2000 Paul Le Roux and which is governed by the 'License
;|***  Agreement for Encryption for the Masses'. Modifications and additions to
;|***  the original source code (contained in this file) and all other portions
;|***  of this file are Copyright (c) 2003-2010 TrueCrypt Developers Association
;|***  and are governed by the TrueCrypt License 3.0 the full text of which is
;|***  contained in the file License.txt included in TrueCrypt binary and source
;|***  code distribution packages. */
;|*** 
;|*** #include "Tcdefs.h"
;|*** 
;|*** #ifndef TC_WINDOWS_BOOT
;|*** #include <fcntl.h>
;|*** #include <sys/types.h>
;|*** #include <sys/stat.h>
;|*** #include <time.h>
;|*** #include "EncryptionThreadPool.h"
;|*** #endif
;|*** 
;|*** #include <stddef.h>
;|*** #include <string.h>
;|*** #include <io.h>
;|*** 
;|*** #ifndef DEVICE_DRIVER
;|*** #include "Random.h"
;|*** #endif
;|*** 
;|*** #include "Crc.h"
;|*** #include "Crypto.h"
;|*** #include "Endian.h"
;|*** #include "Volumes.h"
;|*** #include "Pkcs5.h"
;|*** 
;|*** 
;|*** /* Volume header v5 structure (used since TrueCrypt 7.0): */
;|*** //
;|*** // Offset	Length	Description
;|*** // ------------------------------------------
;|*** // Unencrypted:
;|*** // 0		64		Salt
;|*** // Encrypted:
;|*** // 64		4		ASCII string 'TRUE'
;|*** // 68		2		Header version
;|*** // 70		2		Required program version
;|*** // 72		4		CRC-32 checksum of the (decrypted) bytes 256-511
;|*** // 76		16		Reserved (must contain zeroes)
;|*** // 92		8		Size of hidden volume in bytes (0 = normal volume)
;|*** // 100		8		Size of the volume in bytes (identical with field 92 for hidden volumes, valid if field 70 >= 0x600 or flag bit 0 == 1)
;|*** // 108		8		Byte offset of the start of the master key scope (valid if field 70 >= 0x600 or flag bit 0 == 1)
;|*** // 116		8		Size of the encrypted area within the master key scope (valid if field 70 >= 0x600 or flag bit 0 == 1)
;|*** // 124		4		Flags: bit 0 set = system encryption; bit 1 set = non-system in-place encryption, bits 2-31 are reserved (set to zero)
;|*** // 128		4		Sector size in bytes
;|*** // 132		120		Reserved (must contain zeroes)
;|*** // 252		4		CRC-32 checksum of the (decrypted) bytes 64-251
;|*** // 256		256		Concatenated primary master key(s) and secondary master key(s) (XTS mode)
;|*** 
;|*** 
;|*** /* Deprecated/legacy volume header v4 structure (used by TrueCrypt 6.x): */
;|*** //
;|*** // Offset	Length	Description
;|*** // ------------------------------------------
;|*** // Unencrypted:
;|*** // 0		64		Salt
;|*** // Encrypted:
;|*** // 64		4		ASCII string 'TRUE'
;|*** // 68		2		Header version
;|*** // 70		2		Required program version
;|*** // 72		4		CRC-32 checksum of the (decrypted) bytes 256-511
;|*** // 76		16		Reserved (must contain zeroes)
;|*** // 92		8		Size of hidden volume in bytes (0 = normal volume)
;|*** // 100		8		Size of the volume in bytes (identical with field 92 for hidden volumes, valid if field 70 >= 0x600 or flag bit 0 == 1)
;|*** // 108		8		Byte offset of the start of the master key scope (valid if field 70 >= 0x600 or flag bit 0 == 1)
;|*** // 116		8		Size of the encrypted area within the master key scope (valid if field 70 >= 0x600 or flag bit 0 == 1)
;|*** // 124		4		Flags: bit 0 set = system encryption; bit 1 set = non-system in-place encryption, bits 2-31 are reserved
;|*** // 128		124		Reserved (must contain zeroes)
;|*** // 252		4		CRC-32 checksum of the (decrypted) bytes 64-251
;|*** // 256		256		Concatenated primary master key(s) and secondary master key(s) (XTS mode)
;|*** 
;|*** 
;|*** /* Deprecated/legacy volume header v3 structure (used by TrueCrypt 5.x): */
;|*** //
;|*** // Offset	Length	Description
;|*** // ------------------------------------------
;|*** // Unencrypted:
;|*** // 0		64		Salt
;|*** // Encrypted:
;|*** // 64		4		ASCII string 'TRUE'
;|*** // 68		2		Header version
;|*** // 70		2		Required program version
;|*** // 72		4		CRC-32 checksum of the (decrypted) bytes 256-511
;|*** // 76		8		Volume creation time
;|*** // 84		8		Header creation time
;|*** // 92		8		Size of hidden volume in bytes (0 = normal volume)
;|*** // 100		8		Size of the volume in bytes (identical with field 92 for hidden volumes)
;|*** // 108		8		Start byte offset of the encrypted area of the volume
;|*** // 116		8		Size of the encrypted area of the volume in bytes
;|*** // 124		132		Reserved (must contain zeroes)
;|*** // 256		256		Concatenated primary master key(s) and secondary master key(s) (XTS mode)
;|*** 
;|*** 
;|*** /* Deprecated/legacy volume header v2 structure (used before TrueCrypt 5.0): */
;|*** //
;|*** // Offset	Length	Description
;|*** // ------------------------------------------
;|*** // Unencrypted:
;|*** // 0		64		Salt
;|*** // Encrypted:
;|*** // 64		4		ASCII string 'TRUE'
;|*** // 68		2		Header version
;|*** // 70		2		Required program version
;|*** // 72		4		CRC-32 checksum of the (decrypted) bytes 256-511
;|*** // 76		8		Volume creation time
;|*** // 84		8		Header creation time
;|*** // 92		8		Size of hidden volume in bytes (0 = normal volume)
;|*** // 100		156		Reserved (must contain zeroes)
;|*** // 256		32		For LRW (deprecated/legacy), secondary key
;|*** //					For CBC (deprecated/legacy), data used to generate IV and whitening values
;|*** // 288		224		Master key(s)
;|*** 
;|*** 
;|*** 
;|*** uint16 GetHeaderField16 (byte *header, int offset)
;|*** {
; Line 125
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
	*** 000003	56 			push	si
;	header = 4
;	offset = 6
;|*** 	return BE16 (*(uint16 *) (header + offset));
; Line 126
	*** 000004	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;offset
	*** 000007	8b 76 04 		mov	si,WORD PTR [bp+4]	;header
	*** 00000a	ff 30 			push	WORD PTR [bx][si]
	*** 00000c	e8 00 00 		call	_MirrorBytes16
	*** 00000f	5b 			pop	bx
;|*** }
; Line 127
	*** 000010	5e 			pop	si
	*** 000011	c9 			leave	
	*** 000012	c3 			ret	

_GetHeaderField16	ENDP
	PUBLIC	_GetHeaderField32
_GetHeaderField32	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** uint32 GetHeaderField32 (byte *header, int offset)
;|*** {
; Line 131
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
	*** 000003	56 			push	si
;	header = 4
;	offset = 6
;|*** 	return BE32 (*(uint32 *) (header + offset));
; Line 132
	*** 000004	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;offset
	*** 000007	8b 76 04 		mov	si,WORD PTR [bp+4]	;header
	*** 00000a	66 ff 30 		push	DWORD PTR [bx][si]
	*** 00000d	e8 00 00 		call	_MirrorBytes32
	*** 000010	83 c4 04 		add	sp,4
;|*** }
; Line 133
	*** 000013	5e 			pop	si
	*** 000014	c9 			leave	
	*** 000015	c3 			ret	

_GetHeaderField32	ENDP
	PUBLIC	_GetHeaderField64
_GetHeaderField64	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** UINT64_STRUCT GetHeaderField64 (byte *header, int offset)
;|*** {
; Line 137
	*** 000000	c8 08 00 00 		enter	8,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	header = 4
;	offset = 6
;	uint64Struct = -8
;|*** 	UINT64_STRUCT uint64Struct;
;|*** 
;|*** #ifndef TC_NO_COMPILER_INT64
;|*** 	uint64Struct.Value = BE64 (*(uint64 *) (header + offset));
;|*** #else
;|*** 	uint64Struct.HighPart = BE32 (*(uint32 *) (header + offset));
; Line 143
	*** 000006	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;offset
	*** 000009	8b 76 04 		mov	si,WORD PTR [bp+4]	;header
	*** 00000c	66 ff 30 		push	DWORD PTR [bx][si]
	*** 00000f	e8 00 00 		call	_MirrorBytes32
	*** 000012	83 c4 04 		add	sp,4
	*** 000015	89 46 fc 		mov	WORD PTR [bp-4],ax
	*** 000018	89 56 fe 		mov	WORD PTR [bp-2],dx
;|*** 	uint64Struct.LowPart = BE32 (*(uint32 *) (header + offset + 4));
; Line 144
	*** 00001b	03 76 06 		add	si,WORD PTR [bp+6]	;offset
	*** 00001e	66 ff 74 04 		push	DWORD PTR [si+4]
	*** 000022	e8 00 00 		call	_MirrorBytes32
	*** 000025	83 c4 04 		add	sp,4
	*** 000028	89 46 f8 		mov	WORD PTR [bp-8],ax	;uint64Struct
	*** 00002b	89 56 fa 		mov	WORD PTR [bp-6],dx
;|*** #endif
;|*** 	return uint64Struct;
; Line 146
	*** 00002e	b8 00 00 		mov	ax,OFFSET DGROUP:__mbac
	*** 000031	8b f8 			mov	di,ax
	*** 000033	8d 76 f8 		lea	si,WORD PTR [bp-8]	;uint64Struct
	*** 000036	1e 			push	ds
	*** 000037	07 			pop	es
	*** 000038	66 a5 			movsd
	*** 00003a	66 a5 			movsd
;|*** }
; Line 147
	*** 00003c	5e 			pop	si
	*** 00003d	5f 			pop	di
	*** 00003e	c9 			leave	
	*** 00003f	c3 			ret	

_GetHeaderField64	ENDP
	PUBLIC	_ReadVolumeHeader
_ReadVolumeHeader	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** #ifndef TC_WINDOWS_BOOT
;|*** 
;|*** typedef struct
;|*** {
;|*** 	char DerivedKey[MASTER_KEYDATA_SIZE];
;|*** 	BOOL Free;
;|*** 	LONG KeyReady;
;|*** 	int Pkcs5Prf;
;|*** } KeyDerivationWorkItem;
;|*** 
;|*** 
;|*** BOOL ReadVolumeHeaderRecoveryMode = FALSE;
;|*** 
;|*** int ReadVolumeHeader (BOOL bBoot, char *encryptedHeader, Password *password, PCRYPTO_INFO *retInfo, CRYPTO_INFO *retHeaderCryptoInfo)
;|*** {
;|*** 	char header[TC_VOLUME_HEADER_EFFECTIVE_SIZE];
;|*** 	KEY_INFO keyInfo;
;|*** 	PCRYPTO_INFO cryptoInfo;
;|*** 	char dk[MASTER_KEYDATA_SIZE];
;|*** 	int enqPkcs5Prf, pkcs5_prf;
;|*** 	uint16 headerVersion;
;|*** 	int status = ERR_PARAMETER_INCORRECT;
;|*** 	int primaryKeyOffset;
;|*** 
;|*** 	TC_EVENT keyDerivationCompletedEvent;
;|*** 	TC_EVENT noOutstandingWorkItemEvent;
;|*** 	KeyDerivationWorkItem *keyDerivationWorkItems;
;|*** 	KeyDerivationWorkItem *item;
;|*** 	int pkcs5PrfCount = LAST_PRF_ID - FIRST_PRF_ID + 1;
;|*** 	size_t encryptionThreadCount = GetEncryptionThreadCount();
;|*** 	size_t queuedWorkItems = 0;
;|*** 	LONG outstandingWorkItemCount = 0;
;|*** 	int i;
;|*** 
;|*** 	if (retHeaderCryptoInfo != NULL)
;|*** 	{
;|*** 		cryptoInfo = retHeaderCryptoInfo;
;|*** 	}
;|*** 	else
;|*** 	{
;|*** 		cryptoInfo = *retInfo = crypto_open ();
;|*** 		if (cryptoInfo == NULL)
;|*** 			return ERR_OUTOFMEMORY;
;|*** 	}
;|*** 
;|*** 	if (encryptionThreadCount > 1)
;|*** 	{
;|*** 		keyDerivationWorkItems = TCalloc (sizeof (KeyDerivationWorkItem) * pkcs5PrfCount);
;|*** 		if (!keyDerivationWorkItems)
;|*** 			return ERR_OUTOFMEMORY;
;|*** 
;|*** 		for (i = 0; i < pkcs5PrfCount; ++i)
;|*** 			keyDerivationWorkItems[i].Free = TRUE;
;|*** 
;|*** #ifdef DEVICE_DRIVER
;|*** 		KeInitializeEvent (&keyDerivationCompletedEvent, SynchronizationEvent, FALSE);
;|*** 		KeInitializeEvent (&noOutstandingWorkItemEvent, SynchronizationEvent, TRUE);
;|*** #else
;|*** 		keyDerivationCompletedEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
;|*** 		if (!keyDerivationCompletedEvent)
;|*** 		{
;|*** 			TCfree (keyDerivationWorkItems);
;|*** 			return ERR_OUTOFMEMORY;
;|*** 		}
;|*** 
;|*** 		noOutstandingWorkItemEvent = CreateEvent (NULL, FALSE, TRUE, NULL);
;|*** 		if (!noOutstandingWorkItemEvent)
;|*** 		{
;|*** 			CloseHandle (keyDerivationCompletedEvent);
;|*** 			TCfree (keyDerivationWorkItems);
;|*** 			return ERR_OUTOFMEMORY;
;|*** 		}
;|*** #endif
;|*** 	}
;|*** 		
;|*** #ifndef DEVICE_DRIVER
;|*** 	VirtualLock (&keyInfo, sizeof (keyInfo));
;|*** 	VirtualLock (&dk, sizeof (dk));
;|*** #endif
;|*** 
;|*** 	crypto_loadkey (&keyInfo, password->Text, (int) password->Length);
;|*** 
;|*** 	// PKCS5 is used to derive the primary header key(s) and secondary header key(s) (XTS mode) from the password
;|*** 	memcpy (keyInfo.salt, encryptedHeader + HEADER_SALT_OFFSET, PKCS5_SALT_SIZE);
;|*** 
;|*** 	// Test all available PKCS5 PRFs
;|*** 	for (enqPkcs5Prf = FIRST_PRF_ID; enqPkcs5Prf <= LAST_PRF_ID || queuedWorkItems > 0; ++enqPkcs5Prf)
;|*** 	{
;|*** 		BOOL lrw64InitDone = FALSE;		// Deprecated/legacy
;|*** 		BOOL lrw128InitDone = FALSE;	// Deprecated/legacy
;|*** 
;|*** 		if (encryptionThreadCount > 1)
;|*** 		{
;|*** 			// Enqueue key derivation on thread pool
;|*** 			if (queuedWorkItems < encryptionThreadCount && enqPkcs5Prf <= LAST_PRF_ID)
;|*** 			{
;|*** 				for (i = 0; i < pkcs5PrfCount; ++i)
;|*** 				{
;|*** 					item = &keyDerivationWorkItems[i];
;|*** 					if (item->Free)
;|*** 					{
;|*** 						item->Free = FALSE;
;|*** 						item->KeyReady = FALSE;
;|*** 						item->Pkcs5Prf = enqPkcs5Prf;
;|*** 
;|*** 						EncryptionThreadPoolBeginKeyDerivation (&keyDerivationCompletedEvent, &noOutstandingWorkItemEvent,
;|*** 							&item->KeyReady, &outstandingWorkItemCount, enqPkcs5Prf, keyInfo.userKey,
;|*** 							keyInfo.keyLength, keyInfo.salt, get_pkcs5_iteration_count (enqPkcs5Prf, bBoot), item->DerivedKey);
;|*** 						
;|*** 						++queuedWorkItems;
;|*** 						break;
;|*** 					}
;|*** 				}
;|*** 
;|*** 				if (enqPkcs5Prf < LAST_PRF_ID)
;|*** 					continue;
;|*** 			}
;|*** 			else
;|*** 				--enqPkcs5Prf;
;|*** 
;|*** 			// Wait for completion of a key derivation
;|*** 			while (queuedWorkItems > 0)
;|*** 			{
;|*** 				for (i = 0; i < pkcs5PrfCount; ++i)
;|*** 				{
;|*** 					item = &keyDerivationWorkItems[i];
;|*** 					if (!item->Free && InterlockedExchangeAdd (&item->KeyReady, 0) == TRUE)
;|*** 					{
;|*** 						pkcs5_prf = item->Pkcs5Prf;
;|*** 						keyInfo.noIterations = get_pkcs5_iteration_count (pkcs5_prf, bBoot);
;|*** 						memcpy (dk, item->DerivedKey, sizeof (dk));
;|*** 
;|*** 						item->Free = TRUE;
;|*** 						--queuedWorkItems;
;|*** 						goto KeyReady;
;|*** 					}
;|*** 				}
;|*** 
;|*** 				if (queuedWorkItems > 0)
;|*** 					TC_WAIT_EVENT (keyDerivationCompletedEvent);
;|*** 			}
;|*** 			continue;
;|*** KeyReady:	;
;|*** 		}
;|*** 		else
;|*** 		{
;|*** 			pkcs5_prf = enqPkcs5Prf;
;|*** 			keyInfo.noIterations = get_pkcs5_iteration_count (enqPkcs5Prf, bBoot);
;|*** 
;|*** 			switch (pkcs5_prf)
;|*** 			{
;|*** 			case RIPEMD160:
;|*** 				derive_key_ripemd160 (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
;|*** 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());
;|*** 				break;
;|*** 
;|*** 			case SHA512:
;|*** 				derive_key_sha512 (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
;|*** 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());
;|*** 				break;
;|*** 
;|*** 			case SHA1:
;|*** 				// Deprecated/legacy
;|*** 				derive_key_sha1 (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
;|*** 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());
;|*** 				break;
;|*** 
;|*** 			case WHIRLPOOL:
;|*** 				derive_key_whirlpool (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
;|*** 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());
;|*** 				break;
;|*** 
;|*** 			default:		
;|*** 				// Unknown/wrong ID
;|*** 				TC_THROW_FATAL_EXCEPTION;
;|*** 			} 
;|*** 		}
;|*** 
;|*** 		// Test all available modes of operation
;|*** 		for (cryptoInfo->mode = FIRST_MODE_OF_OPERATION_ID;
;|*** 			cryptoInfo->mode <= LAST_MODE_OF_OPERATION;
;|*** 			cryptoInfo->mode++)
;|*** 		{
;|*** 			switch (cryptoInfo->mode)
;|*** 			{
;|*** 			case LRW:
;|*** 			case CBC:
;|*** 			case INNER_CBC:
;|*** 			case OUTER_CBC:
;|*** 
;|*** 				// For LRW (deprecated/legacy), copy the tweak key 
;|*** 				// For CBC (deprecated/legacy), copy the IV/whitening seed 
;|*** 				memcpy (cryptoInfo->k2, dk, LEGACY_VOL_IV_SIZE);
;|*** 				primaryKeyOffset = LEGACY_VOL_IV_SIZE;
;|*** 				break;
;|*** 
;|*** 			default:
;|*** 				primaryKeyOffset = 0;
;|*** 			}
;|*** 
;|*** 			// Test all available encryption algorithms
;|*** 			for (cryptoInfo->ea = EAGetFirst ();
;|*** 				cryptoInfo->ea != 0;
;|*** 				cryptoInfo->ea = EAGetNext (cryptoInfo->ea))
;|*** 			{
;|*** 				int blockSize;
;|*** 
;|*** 				if (!EAIsModeSupported (cryptoInfo->ea, cryptoInfo->mode))
;|*** 					continue;	// This encryption algorithm has never been available with this mode of operation
;|*** 
;|*** 				blockSize = CipherGetBlockSize (EAGetFirstCipher (cryptoInfo->ea));
;|*** 
;|*** 				status = EAInit (cryptoInfo->ea, dk + primaryKeyOffset, cryptoInfo->ks);
;|*** 				if (status == ERR_CIPHER_INIT_FAILURE)
;|*** 					goto err;
;|*** 
;|*** 				// Init objects related to the mode of operation
;|*** 
;|*** 				if (cryptoInfo->mode == XTS)
;|*** 				{
;|*** 					// Copy the secondary key (if cascade, multiple concatenated)
;|*** 					memcpy (cryptoInfo->k2, dk + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));
;|*** 
;|*** 					// Secondary key schedule
;|*** 					if (!EAInitMode (cryptoInfo))
;|*** 					{
;|*** 						status = ERR_MODE_INIT_FAILED;
;|*** 						goto err;
;|*** 					}
;|*** 				}
;|*** 				else if (cryptoInfo->mode == LRW
;|*** 					&& (blockSize == 8 && !lrw64InitDone || blockSize == 16 && !lrw128InitDone))
;|*** 				{
;|*** 					// Deprecated/legacy
;|*** 
;|*** 					if (!EAInitMode (cryptoInfo))
;|*** 					{
;|*** 						status = ERR_MODE_INIT_FAILED;
;|*** 						goto err;
;|*** 					}
;|*** 
;|*** 					if (blockSize == 8)
;|*** 						lrw64InitDone = TRUE;
;|*** 					else if (blockSize == 16)
;|*** 						lrw128InitDone = TRUE;
;|*** 				}
;|*** 
;|*** 				// Copy the header for decryption
;|*** 				memcpy (header, encryptedHeader, sizeof (header));
;|*** 
;|*** 				// Try to decrypt header 
;|*** 
;|*** 				DecryptBuffer (header + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, cryptoInfo);
;|*** 
;|*** 				// Magic 'TRUE'
;|*** 				/* Modifying 'TRUE' can introduce incompatibility with previous versions. */
;|*** 				if (GetHeaderField32 (header, TC_HEADER_OFFSET_MAGIC) != 0x54525545)
;|*** 					continue;
;|*** 
;|*** 				// Header version
;|*** 				headerVersion = GetHeaderField16 (header, TC_HEADER_OFFSET_VERSION);
;|*** 				
;|*** 				if (headerVersion > VOLUME_HEADER_VERSION)
;|*** 				{
;|*** 					status = ERR_NEW_VERSION_REQUIRED;
;|*** 					goto err;
;|*** 				}
;|*** 
;|*** 				// Check CRC of the header fields
;|*** 				if (!ReadVolumeHeaderRecoveryMode
;|*** 					&& headerVersion >= 4
;|*** 					&& GetHeaderField32 (header, TC_HEADER_OFFSET_HEADER_CRC) != GetCrc32 (header + TC_HEADER_OFFSET_MAGIC, TC_HEADER_OFFSET_HEADER_CRC - TC_HEADER_OFFSET_MAGIC))
;|*** 					continue;
;|*** 
;|*** 				// Required program version
;|*** 				cryptoInfo->RequiredProgramVersion = GetHeaderField16 (header, TC_HEADER_OFFSET_REQUIRED_VERSION);
;|*** 				cryptoInfo->LegacyVolume = cryptoInfo->RequiredProgramVersion < 0x600;
;|*** 
;|*** 				// Check CRC of the key set
;|*** 				if (!ReadVolumeHeaderRecoveryMode
;|*** 					&& GetHeaderField32 (header, TC_HEADER_OFFSET_KEY_AREA_CRC) != GetCrc32 (header + HEADER_MASTER_KEYDATA_OFFSET, MASTER_KEYDATA_SIZE))
;|*** 					continue;
;|*** 
;|*** 				// Now we have the correct password, cipher, hash algorithm, and volume type
;|*** 
;|*** 				// Check the version required to handle this volume
;|*** 				if (cryptoInfo->RequiredProgramVersion > VERSION_NUM)
;|*** 				{
;|*** 					status = ERR_NEW_VERSION_REQUIRED;
;|*** 					goto err;
;|*** 				}
;|*** 
;|*** 				// Header version
;|*** 				cryptoInfo->HeaderVersion = headerVersion;
;|*** 
;|*** 				// Volume creation time (legacy)
;|*** 				cryptoInfo->volume_creation_time = GetHeaderField64 (header, TC_HEADER_OFFSET_VOLUME_CREATION_TIME).Value;
;|*** 
;|*** 				// Header creation time (legacy)
;|*** 				cryptoInfo->header_creation_time = GetHeaderField64 (header, TC_HEADER_OFFSET_MODIFICATION_TIME).Value;
;|*** 
;|*** 				// Hidden volume size (if any)
;|*** 				cryptoInfo->hiddenVolumeSize = GetHeaderField64 (header, TC_HEADER_OFFSET_HIDDEN_VOLUME_SIZE).Value;
;|*** 
;|*** 				// Hidden volume status
;|*** 				cryptoInfo->hiddenVolume = (cryptoInfo->hiddenVolumeSize != 0);
;|*** 
;|*** 				// Volume size
;|*** 				cryptoInfo->VolumeSize = GetHeaderField64 (header, TC_HEADER_OFFSET_VOLUME_SIZE);
;|*** 				
;|*** 				// Encrypted area size and length
;|*** 				cryptoInfo->EncryptedAreaStart = GetHeaderField64 (header, TC_HEADER_OFFSET_ENCRYPTED_AREA_START);
;|*** 				cryptoInfo->EncryptedAreaLength = GetHeaderField64 (header, TC_HEADER_OFFSET_ENCRYPTED_AREA_LENGTH);
;|*** 
;|*** 				// Flags
;|*** 				cryptoInfo->HeaderFlags = GetHeaderField32 (header, TC_HEADER_OFFSET_FLAGS);
;|*** 
;|*** 				// Sector size
;|*** 				if (headerVersion >= 5)
;|*** 					cryptoInfo->SectorSize = GetHeaderField32 (header, TC_HEADER_OFFSET_SECTOR_SIZE);
;|*** 				else
;|*** 					cryptoInfo->SectorSize = TC_SECTOR_SIZE_LEGACY;
;|*** 
;|*** 				if (cryptoInfo->SectorSize < TC_MIN_VOLUME_SECTOR_SIZE
;|*** 					|| cryptoInfo->SectorSize > TC_MAX_VOLUME_SECTOR_SIZE
;|*** 					|| cryptoInfo->SectorSize % ENCRYPTION_DATA_UNIT_SIZE != 0)
;|*** 				{
;|*** 					status = ERR_PARAMETER_INCORRECT;
;|*** 					goto err;
;|*** 				}
;|*** 
;|*** 				// Preserve scheduled header keys if requested			
;|*** 				if (retHeaderCryptoInfo)
;|*** 				{
;|*** 					if (retInfo == NULL)
;|*** 					{
;|*** 						cryptoInfo->pkcs5 = pkcs5_prf;
;|*** 						cryptoInfo->noIterations = keyInfo.noIterations;
;|*** 						goto ret;
;|*** 					}
;|*** 
;|*** 					cryptoInfo = *retInfo = crypto_open ();
;|*** 					if (cryptoInfo == NULL)
;|*** 					{
;|*** 						status = ERR_OUTOFMEMORY;
;|*** 						goto err;
;|*** 					}
;|*** 
;|*** 					memcpy (cryptoInfo, retHeaderCryptoInfo, sizeof (*cryptoInfo));
;|*** 				}
;|*** 
;|*** 				// Master key data
;|*** 				memcpy (keyInfo.master_keydata, header + HEADER_MASTER_KEYDATA_OFFSET, MASTER_KEYDATA_SIZE);
;|*** 				memcpy (cryptoInfo->master_keydata, keyInfo.master_keydata, MASTER_KEYDATA_SIZE);
;|*** 
;|*** 				// PKCS #5
;|*** 				memcpy (cryptoInfo->salt, keyInfo.salt, PKCS5_SALT_SIZE);
;|*** 				cryptoInfo->pkcs5 = pkcs5_prf;
;|*** 				cryptoInfo->noIterations = keyInfo.noIterations;
;|*** 
;|*** 				// Init the cipher with the decrypted master key
;|*** 				status = EAInit (cryptoInfo->ea, keyInfo.master_keydata + primaryKeyOffset, cryptoInfo->ks);
;|*** 				if (status == ERR_CIPHER_INIT_FAILURE)
;|*** 					goto err;
;|*** 
;|*** 				switch (cryptoInfo->mode)
;|*** 				{
;|*** 				case LRW:
;|*** 				case CBC:
;|*** 				case INNER_CBC:
;|*** 				case OUTER_CBC:
;|*** 
;|*** 					// For LRW (deprecated/legacy), the tweak key
;|*** 					// For CBC (deprecated/legacy), the IV/whitening seed
;|*** 					memcpy (cryptoInfo->k2, keyInfo.master_keydata, LEGACY_VOL_IV_SIZE);
;|*** 					break;
;|*** 
;|*** 				default:
;|*** 					// The secondary master key (if cascade, multiple concatenated)
;|*** 					memcpy (cryptoInfo->k2, keyInfo.master_keydata + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));
;|*** 
;|*** 				}
;|*** 
;|*** 				if (!EAInitMode (cryptoInfo))
;|*** 				{
;|*** 					status = ERR_MODE_INIT_FAILED;
;|*** 					goto err;
;|*** 				}
;|*** 
;|*** 				status = ERR_SUCCESS;
;|*** 				goto ret;
;|*** 			}
;|*** 		}
;|*** 	}
;|*** 	status = ERR_PASSWORD_WRONG;
;|*** 
;|*** err:
;|*** 	if (cryptoInfo != retHeaderCryptoInfo)
;|*** 	{
;|*** 		crypto_close(cryptoInfo);
;|*** 		*retInfo = NULL; 
;|*** 	}
;|*** 
;|*** ret:
;|*** 	burn (&keyInfo, sizeof (keyInfo));
;|*** 	burn (dk, sizeof(dk));
;|*** 
;|*** #ifndef DEVICE_DRIVER
;|*** 	VirtualUnlock (&keyInfo, sizeof (keyInfo));
;|*** 	VirtualUnlock (&dk, sizeof (dk));
;|*** #endif
;|*** 
;|*** 	if (encryptionThreadCount > 1)
;|*** 	{
;|*** 		TC_WAIT_EVENT (noOutstandingWorkItemEvent);
;|*** 
;|*** 		burn (keyDerivationWorkItems, sizeof (KeyDerivationWorkItem) * pkcs5PrfCount);
;|*** 		TCfree (keyDerivationWorkItems);
;|*** 
;|*** #ifndef DEVICE_DRIVER
;|*** 		CloseHandle (keyDerivationCompletedEvent);
;|*** 		CloseHandle (noOutstandingWorkItemEvent);
;|*** #endif
;|*** 	}
;|*** 
;|*** 	return status;
;|*** }
;|*** 
;|*** #else // TC_WINDOWS_BOOT
;|*** 
;|*** int ReadVolumeHeader (BOOL bBoot, char *header, Password *password, PCRYPTO_INFO *retInfo, CRYPTO_INFO *retHeaderCryptoInfo)
;|*** {
; Line 581
	*** 000000	c8 8c 01 00 		enter	396,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	bBoot = 4
;	header = 6
;	password = 8
;	retInfo = 10
;	retHeaderCryptoInfo = 12
;	dk = -196
;	masterKey = -388
;	cryptoInfo = -2
;	status = -4
;|*** #ifdef TC_WINDOWS_BOOT_SINGLE_CIPHER_MODE
;|*** 	char dk[32 * 2];			// 2 * 256-bit key
;|*** 	char masterKey[32 * 2];
;|*** #else
;|*** 	char dk[32 * 2 * 3];		// 6 * 256-bit key
;|*** 	char masterKey[32 * 2 * 3];
;|*** #endif
;|*** 
;|*** 	PCRYPTO_INFO cryptoInfo;
;|*** 	int status;
;|*** 
;|*** 	if (retHeaderCryptoInfo != NULL)
; Line 593
	*** 000006	83 7e 0c 00 		cmp	WORD PTR [bp+12],0	;retHeaderCryptoInfo
	*** 00000a	74 05 			je	SHORT $I1005
;|*** 		cryptoInfo = retHeaderCryptoInfo;
; Line 594
	*** 00000c	8b 76 0c 		mov	si,WORD PTR [bp+12]	;retHeaderCryptoInfo
;|*** 	else
; Line 595
	*** 00000f	eb 0a 			jmp	SHORT $I1006
					$I1005:
;|*** 		cryptoInfo = *retInfo = crypto_open ();
; Line 596
	*** 000011	e8 00 00 		call	_crypto_open
	*** 000014	8b 5e 0a 		mov	bx,WORD PTR [bp+10]	;retInfo
	*** 000017	8b f0 			mov	si,ax
	*** 000019	89 07 			mov	WORD PTR [bx],ax
					$I1006:
;|*** 
;|*** 	// PKCS5 PRF
;|*** 	derive_key_ripemd160 (password->Text, (int) password->Length, header + HEADER_SALT_OFFSET,
;|*** 		PKCS5_SALT_SIZE, bBoot ? 1000 : 2000, dk, sizeof (dk));
; Line 600
	*** 00001b	68 c0 00 		push	192	;00c0H
	*** 00001e	8d 86 3c ff 		lea	ax,WORD PTR [bp-196]	;dk
	*** 000022	50 			push	ax
	*** 000023	80 7e 04 01 		cmp	BYTE PTR [bp+4],1	;bBoot
	*** 000027	1b c0 			sbb	ax,ax
	*** 000029	25 e8 03 		and	ax,1000	;03e8H
	*** 00002c	05 e8 03 		add	ax,1000	;03e8H
	*** 00002f	50 			push	ax
	*** 000030	6a 40 			push	64	;0040H
	*** 000032	ff 76 06 		push	WORD PTR [bp+6]	;header
	*** 000035	8b 5e 08 		mov	bx,WORD PTR [bp+8]	;password
	*** 000038	ff 37 			push	WORD PTR [bx]
	*** 00003a	8d 47 04 		lea	ax,WORD PTR [bx+4]
	*** 00003d	50 			push	ax
	*** 00003e	e8 00 00 		call	_derive_key_ripemd160
	*** 000041	83 c4 0e 		add	sp,14	;000eH
;|*** 
;|*** 	// Mode of operation
;|*** 	cryptoInfo->mode = FIRST_MODE_OF_OPERATION_ID;
; Line 603
	*** 000044	c7 44 02 01 00 		mov	WORD PTR [si+2],1
;|*** 
;|*** 	// Test all available encryption algorithms
;|*** 	for (cryptoInfo->ea = EAGetFirst (); cryptoInfo->ea != 0; cryptoInfo->ea = EAGetNext (cryptoInfo->ea))
; Line 606
	*** 000049	e8 00 00 		call	_EAGetFirst
	*** 00004c	89 04 			mov	WORD PTR [si],ax
	*** 00004e	8b 7e 06 		mov	di,WORD PTR [bp+6]	;header
	*** 000051	89 76 fe 		mov	WORD PTR [bp-2],si	;cryptoInfo
					$F1007:
	*** 000054	83 3c 00 		cmp	WORD PTR [si],0
	*** 000057	0f 84 fe 01 		je	$FB1009
;|*** 	{
;|*** 		status = EAInit (cryptoInfo->ea, dk, cryptoInfo->ks);
;|*** 		if (status == ERR_CIPHER_INIT_FAILURE)
; Line 609
	*** 00005b	8d 44 04 		lea	ax,WORD PTR [si+4]
	*** 00005e	50 			push	ax
	*** 00005f	8d 86 3c ff 		lea	ax,WORD PTR [bp-196]	;dk
	*** 000063	50 			push	ax
	*** 000064	ff 34 			push	WORD PTR [si]
	*** 000066	e8 00 00 		call	_EAInit
	*** 000069	83 c4 06 		add	sp,6
	*** 00006c	89 46 fc 		mov	WORD PTR [bp-4],ax	;status
	*** 00006f	3d 11 00 		cmp	ax,17	;0011H
	*** 000072	0f 84 bd 00 		je	$L1027
;|*** 			goto err;
;|*** 
;|*** 		// Secondary key schedule
;|*** 		EAInit (cryptoInfo->ea, dk + EAGetKeySize (cryptoInfo->ea), cryptoInfo->ks2);
; Line 613
	*** 000076	8d 84 d9 03 		lea	ax,WORD PTR [si+985]
	*** 00007a	50 			push	ax
	*** 00007b	ff 34 			push	WORD PTR [si]
	*** 00007d	e8 00 00 		call	_EAGetKeySize
	*** 000080	5b 			pop	bx
	*** 000081	8d 8e 3c ff 		lea	cx,WORD PTR [bp-196]	;dk
	*** 000085	03 c1 			add	ax,cx
	*** 000087	50 			push	ax
	*** 000088	ff 34 			push	WORD PTR [si]
	*** 00008a	e8 00 00 		call	_EAInit
	*** 00008d	83 c4 06 		add	sp,6
;|*** 
;|*** 		// Try to decrypt header 
;|*** 		DecryptBuffer (header + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, cryptoInfo);
; Line 616
	*** 000090	56 			push	si
	*** 000091	6a 00 			push	0
	*** 000093	68 c0 01 		push	448	;01c0H
	*** 000096	8d 45 40 		lea	ax,WORD PTR [di+64]
	*** 000099	50 			push	ax
	*** 00009a	e8 00 00 		call	_DecryptBuffer
	*** 00009d	83 c4 08 		add	sp,8
;|*** 		
;|*** 		// Check magic 'TRUE' and CRC-32 of header fields and master keydata
;|*** 		/* Modifying 'TRUE' can introduce incompatibility with previous versions. */
;|*** 		if (GetHeaderField32 (header, TC_HEADER_OFFSET_MAGIC) != 0x54525545
;|*** 			|| (GetHeaderField16 (header, TC_HEADER_OFFSET_VERSION) >= 4 && GetHeaderField32 (header, TC_HEADER_OFFSET_HEADER_CRC) != GetCrc32 (header + TC_HEADER_OFFSET_MAGIC, TC_HEADER_OFFSET_HEADER_CRC - TC_HEADER_OFFSET_MAGIC))
;|*** 			|| GetHeaderField32 (header, TC_HEADER_OFFSET_KEY_AREA_CRC) != GetCrc32 (header + HEADER_MASTER_KEYDATA_OFFSET, MASTER_KEYDATA_SIZE))
; Line 622
	*** 0000a0	6a 40 			push	64	;0040H
	*** 0000a2	57 			push	di
	*** 0000a3	e8 00 00 		call	_GetHeaderField32
	*** 0000a6	83 c4 04 		add	sp,4
	*** 0000a9	3d 45 55 		cmp	ax,21829	;5545H
	*** 0000ac	75 6a 			jne	SHORT $L1035
	*** 0000ae	81 fa 52 54 		cmp	dx,21586	;5452H
	*** 0000b2	75 64 			jne	SHORT $L1035
	*** 0000b4	6a 44 			push	68	;0044H
	*** 0000b6	57 			push	di
	*** 0000b7	e8 00 00 		call	_GetHeaderField16
	*** 0000ba	83 c4 04 		add	sp,4
	*** 0000bd	3d 04 00 		cmp	ax,4
	*** 0000c0	72 2b 			jb	SHORT $I1014
	*** 0000c2	68 bc 00 		push	188	;00bcH
	*** 0000c5	8d 45 40 		lea	ax,WORD PTR [di+64]
	*** 0000c8	50 			push	ax
	*** 0000c9	e8 00 00 		call	_GetCrc32
	*** 0000cc	83 c4 04 		add	sp,4
	*** 0000cf	68 fc 00 		push	252	;00fcH
	*** 0000d2	57 			push	di
	*** 0000d3	89 86 78 fe 		mov	WORD PTR [bp-392],ax
	*** 0000d7	89 96 7a fe 		mov	WORD PTR [bp-390],dx
	*** 0000db	e8 00 00 		call	_GetHeaderField32
	*** 0000de	83 c4 04 		add	sp,4
	*** 0000e1	39 86 78 fe 		cmp	WORD PTR [bp-392],ax
	*** 0000e5	75 31 			jne	SHORT $L1035
	*** 0000e7	39 96 7a fe 		cmp	WORD PTR [bp-390],dx
	*** 0000eb	75 2b 			jne	SHORT $L1035
					$I1014:
	*** 0000ed	6a 48 			push	72	;0048H
	*** 0000ef	57 			push	di
	*** 0000f0	e8 00 00 		call	_GetHeaderField32
	*** 0000f3	83 c4 04 		add	sp,4
	*** 0000f6	68 00 01 		push	256	;0100H
	*** 0000f9	8d 8d 00 01 		lea	cx,WORD PTR [di+256]
	*** 0000fd	51 			push	cx
	*** 0000fe	89 86 74 fe 		mov	WORD PTR [bp-396],ax
	*** 000102	89 96 76 fe 		mov	WORD PTR [bp-394],dx
	*** 000106	e8 00 00 		call	_GetCrc32
	*** 000109	83 c4 04 		add	sp,4
	*** 00010c	39 86 74 fe 		cmp	WORD PTR [bp-396],ax
	*** 000110	75 06 			jne	SHORT $L1035
	*** 000112	39 96 76 fe 		cmp	WORD PTR [bp-394],dx
	*** 000116	74 20 			je	SHORT $L1024
					$L1035:
;|*** 		{
;|*** 			EncryptBuffer (header + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, cryptoInfo);
; Line 624
	*** 000118	56 			push	si
	*** 000119	6a 00 			push	0
	*** 00011b	68 c0 01 		push	448	;01c0H
	*** 00011e	8d 45 40 		lea	ax,WORD PTR [di+64]
	*** 000121	50 			push	ax
	*** 000122	e8 00 00 		call	_EncryptBuffer
	*** 000125	83 c4 08 		add	sp,8
;|*** 	for (cryptoInfo->ea = EAGetFirst (); cryptoInfo->ea != 0; cryptoInfo->ea = EAGetNext (cryptoInfo->ea))
; Line 606
	*** 000128	ff 34 			push	WORD PTR [si]
	*** 00012a	e8 00 00 		call	_EAGetNext
	*** 00012d	5b 			pop	bx
	*** 00012e	89 04 			mov	WORD PTR [si],ax
	*** 000130	e9 21 ff 		jmp	$F1007
					$L1027:
	*** 000133	8b f8 			mov	di,ax
	*** 000135	e9 24 01 		jmp	$err1011
					$L1024:
;|*** 	{
;|*** 		status = EAInit (cryptoInfo->ea, dk, cryptoInfo->ks);
;|*** 		if (status == ERR_CIPHER_INIT_FAILURE)
;|*** 			goto err;
;|*** 
;|*** 		// Secondary key schedule
;|*** 		EAInit (cryptoInfo->ea, dk + EAGetKeySize (cryptoInfo->ea), cryptoInfo->ks2);
;|*** 
;|*** 		// Try to decrypt header 
;|*** 		DecryptBuffer (header + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, cryptoInfo);
;|*** 		
;|*** 		// Check magic 'TRUE' and CRC-32 of header fields and master keydata
;|*** 		/* Modifying 'TRUE' can introduce incompatibility with previous versions. */
;|*** 		if (GetHeaderField32 (header, TC_HEADER_OFFSET_MAGIC) != 0x54525545
;|*** 			|| (GetHeaderField16 (header, TC_HEADER_OFFSET_VERSION) >= 4 && GetHeaderField32 (header, TC_HEADER_OFFSET_HEADER_CRC) != GetCrc32 (header + TC_HEADER_OFFSET_MAGIC, TC_HEADER_OFFSET_HEADER_CRC - TC_HEADER_OFFSET_MAGIC))
;|*** 			|| GetHeaderField32 (header, TC_HEADER_OFFSET_KEY_AREA_CRC) != GetCrc32 (header + HEADER_MASTER_KEYDATA_OFFSET, MASTER_KEYDATA_SIZE))
;|*** 		{
;|*** 			EncryptBuffer (header + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, cryptoInfo);
;|*** 			continue;
;|*** 		}
;|*** 
;|*** 		// Header decrypted
;|*** 		status = 0;
; Line 629
	*** 000138	c7 46 fc 00 00 		mov	WORD PTR [bp-4],0	;status
;|*** 
;|*** 		// Hidden volume status
;|*** 		cryptoInfo->VolumeSize = GetHeaderField64 (header, TC_HEADER_OFFSET_HIDDEN_VOLUME_SIZE);
; Line 632
	*** 00013d	6a 5c 			push	92	;005cH
	*** 00013f	ff 76 06 		push	WORD PTR [bp+6]	;header
	*** 000142	e8 00 00 		call	_GetHeaderField64
	*** 000145	83 c4 04 		add	sp,4
	*** 000148	8b 56 fe 		mov	dx,WORD PTR [bp-2]	;cryptoInfo
	*** 00014b	81 c2 b0 07 		add	dx,1968	;07b0H
	*** 00014f	8b fa 			mov	di,dx
	*** 000151	8b f0 			mov	si,ax
	*** 000153	1e 			push	ds
	*** 000154	07 			pop	es
	*** 000155	66 a5 			movsd
	*** 000157	66 a5 			movsd
;|*** 		cryptoInfo->hiddenVolume = (cryptoInfo->VolumeSize.LowPart != 0 || cryptoInfo->VolumeSize.HighPart != 0);
; Line 633
	*** 000159	8b da 			mov	bx,dx
	*** 00015b	66 83 3f 00 		cmp	DWORD PTR [bx],0
	*** 00015f	75 12 			jne	SHORT $L1022
	*** 000161	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;cryptoInfo
	*** 000164	66 83 bf b4 07 00 	cmp	DWORD PTR [bx+1972],0
	*** 00016a	75 07 			jne	SHORT $L1022
	*** 00016c	c6 87 ae 07 00 		mov	BYTE PTR [bx+1966],0
	*** 000171	eb 08 			jmp	SHORT $L1021
					$L1022:
	*** 000173	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;cryptoInfo
	*** 000176	c6 87 ae 07 01 		mov	BYTE PTR [bx+1966],1
					$L1021:
;|*** 
;|*** 		// Volume size
;|*** 		cryptoInfo->VolumeSize = GetHeaderField64 (header, TC_HEADER_OFFSET_VOLUME_SIZE);
; Line 636
	*** 00017b	6a 64 			push	100	;0064H
	*** 00017d	ff 76 06 		push	WORD PTR [bp+6]	;header
	*** 000180	e8 00 00 		call	_GetHeaderField64
	*** 000183	83 c4 04 		add	sp,4
	*** 000186	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;cryptoInfo
	*** 000189	8d bf b0 07 		lea	di,WORD PTR [bx+1968]
	*** 00018d	8b f0 			mov	si,ax
	*** 00018f	1e 			push	ds
	*** 000190	07 			pop	es
	*** 000191	66 a5 			movsd
	*** 000193	66 a5 			movsd
;|*** 
;|*** 		// Encrypted area size and length
;|*** 		cryptoInfo->EncryptedAreaStart = GetHeaderField64 (header, TC_HEADER_OFFSET_ENCRYPTED_AREA_START);
; Line 639
	*** 000195	6a 6c 			push	108	;006cH
	*** 000197	ff 76 06 		push	WORD PTR [bp+6]	;header
	*** 00019a	e8 00 00 		call	_GetHeaderField64
	*** 00019d	83 c4 04 		add	sp,4
	*** 0001a0	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;cryptoInfo
	*** 0001a3	8d bf b8 07 		lea	di,WORD PTR [bx+1976]
	*** 0001a7	8b f0 			mov	si,ax
	*** 0001a9	1e 			push	ds
	*** 0001aa	07 			pop	es
	*** 0001ab	66 a5 			movsd
	*** 0001ad	66 a5 			movsd
;|*** 		cryptoInfo->EncryptedAreaLength = GetHeaderField64 (header, TC_HEADER_OFFSET_ENCRYPTED_AREA_LENGTH);
; Line 640
	*** 0001af	6a 74 			push	116	;0074H
	*** 0001b1	ff 76 06 		push	WORD PTR [bp+6]	;header
	*** 0001b4	e8 00 00 		call	_GetHeaderField64
	*** 0001b7	83 c4 04 		add	sp,4
	*** 0001ba	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;cryptoInfo
	*** 0001bd	8d bf c0 07 		lea	di,WORD PTR [bx+1984]
	*** 0001c1	8b f0 			mov	si,ax
	*** 0001c3	1e 			push	ds
	*** 0001c4	07 			pop	es
	*** 0001c5	66 a5 			movsd
	*** 0001c7	66 a5 			movsd
;|*** 
;|*** 		// Flags
;|*** 		cryptoInfo->HeaderFlags = GetHeaderField32 (header, TC_HEADER_OFFSET_FLAGS);
; Line 643
	*** 0001c9	6a 7c 			push	124	;007cH
	*** 0001cb	ff 76 06 		push	WORD PTR [bp+6]	;header
	*** 0001ce	e8 00 00 		call	_GetHeaderField32
	*** 0001d1	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;cryptoInfo
	*** 0001d4	83 c4 04 		add	sp,4
	*** 0001d7	89 87 c8 07 		mov	WORD PTR [bx+1992],ax
	*** 0001db	89 97 ca 07 		mov	WORD PTR [bx+1994],dx
;|*** 
;|*** 		memcpy (masterKey, header + HEADER_MASTER_KEYDATA_OFFSET, sizeof (masterKey));
; Line 645
	*** 0001df	68 c0 00 		push	192	;00c0H
	*** 0001e2	8b 46 06 		mov	ax,WORD PTR [bp+6]	;header
	*** 0001e5	80 c4 01 		add	ah,1
	*** 0001e8	50 			push	ax
	*** 0001e9	8d 86 7c fe 		lea	ax,WORD PTR [bp-388]	;masterKey
	*** 0001ed	50 			push	ax
	*** 0001ee	e8 00 00 		call	_memcpy
	*** 0001f1	83 c4 06 		add	sp,6
;|*** 		EncryptBuffer (header + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, cryptoInfo);
; Line 646
	*** 0001f4	ff 76 fe 		push	WORD PTR [bp-2]	;cryptoInfo
	*** 0001f7	6a 00 			push	0
	*** 0001f9	68 c0 01 		push	448	;01c0H
	*** 0001fc	8b 46 06 		mov	ax,WORD PTR [bp+6]	;header
	*** 0001ff	05 40 00 		add	ax,64	;0040H
	*** 000202	50 			push	ax
	*** 000203	e8 00 00 		call	_EncryptBuffer
	*** 000206	83 c4 08 		add	sp,8
	*** 000209	8b 7e fc 		mov	di,WORD PTR [bp-4]	;status
;|*** 
;|*** 		if (retHeaderCryptoInfo)
; Line 648
	*** 00020c	83 7e 0c 00 		cmp	WORD PTR [bp+12],0	;retHeaderCryptoInfo
	*** 000210	75 5b 			jne	SHORT $ret1016
;|*** 			goto ret;
;|*** 
;|*** 		// Init the encryption algorithm with the decrypted master key
;|*** 		status = EAInit (cryptoInfo->ea, masterKey, cryptoInfo->ks);
;|*** 		if (status == ERR_CIPHER_INIT_FAILURE)
; Line 653
	*** 000212	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;cryptoInfo
	*** 000215	05 04 00 		add	ax,4
	*** 000218	50 			push	ax
	*** 000219	8d 86 7c fe 		lea	ax,WORD PTR [bp-388]	;masterKey
	*** 00021d	50 			push	ax
	*** 00021e	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;cryptoInfo
	*** 000221	ff 37 			push	WORD PTR [bx]
	*** 000223	e8 00 00 		call	_EAInit
	*** 000226	83 c4 06 		add	sp,6
	*** 000229	8b f8 			mov	di,ax
	*** 00022b	83 ff 11 		cmp	di,17	;0011H
	*** 00022e	74 24 			je	SHORT $L1025
;|*** 			goto err;
;|*** 
;|*** 		// The secondary master key (if cascade, multiple concatenated)
;|*** 		EAInit (cryptoInfo->ea, masterKey + EAGetKeySize (cryptoInfo->ea), cryptoInfo->ks2);
; Line 657
	*** 000230	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;cryptoInfo
	*** 000233	05 d9 03 		add	ax,985	;03d9H
	*** 000236	50 			push	ax
	*** 000237	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;cryptoInfo
	*** 00023a	ff 37 			push	WORD PTR [bx]
	*** 00023c	e8 00 00 		call	_EAGetKeySize
	*** 00023f	5b 			pop	bx
	*** 000240	8b f0 			mov	si,ax
	*** 000242	8d 82 7c fe 		lea	ax,WORD PTR [bp-388][si]
	*** 000246	50 			push	ax
	*** 000247	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;cryptoInfo
	*** 00024a	ff 37 			push	WORD PTR [bx]
	*** 00024c	e8 00 00 		call	_EAInit
	*** 00024f	83 c4 06 		add	sp,6
;|*** 		goto ret;
; Line 658
	*** 000252	eb 19 			jmp	SHORT $ret1016
					$L1025:
	*** 000254	8b 76 fe 		mov	si,WORD PTR [bp-2]	;cryptoInfo
	*** 000257	eb 03 			jmp	SHORT $err1011
;|*** 	}
; Line 659
					$FB1009:
;|*** 
;|*** 	status = ERR_PASSWORD_WRONG;
; Line 661
	*** 000259	bf 03 00 		mov	di,3
;|*** 
;|*** err:
; Line 663
					$err1011:
;|*** 	if (cryptoInfo != retHeaderCryptoInfo)
; Line 664
	*** 00025c	39 76 0c 		cmp	WORD PTR [bp+12],si	;retHeaderCryptoInfo
	*** 00025f	74 0c 			je	SHORT $ret1016
;|*** 	{
;|*** 		crypto_close(cryptoInfo);
; Line 666
	*** 000261	56 			push	si
	*** 000262	e8 00 00 		call	_crypto_close
	*** 000265	5b 			pop	bx
;|*** 		*retInfo = NULL; 
; Line 667
	*** 000266	8b 5e 0a 		mov	bx,WORD PTR [bp+10]	;retInfo
	*** 000269	c7 07 00 00 		mov	WORD PTR [bx],0
;|*** 	}
;|*** 
;|*** ret:
; Line 670
					$ret1016:
;|*** 	burn (dk, sizeof(dk));
; Line 671
	*** 00026d	68 c0 00 		push	192	;00c0H
	*** 000270	8d 86 3c ff 		lea	ax,WORD PTR [bp-196]	;dk
	*** 000274	50 			push	ax
	*** 000275	e8 00 00 		call	_EraseMemory
	*** 000278	83 c4 04 		add	sp,4
;|*** 	burn (masterKey, sizeof(masterKey));
; Line 672
	*** 00027b	68 c0 00 		push	192	;00c0H
	*** 00027e	8d 86 7c fe 		lea	ax,WORD PTR [bp-388]	;masterKey
	*** 000282	50 			push	ax
	*** 000283	e8 00 00 		call	_EraseMemory
	*** 000286	83 c4 04 		add	sp,4
;|*** 	return status;
; Line 673
	*** 000289	8b c7 			mov	ax,di
;|*** }
; Line 674
	*** 00028b	5e 			pop	si
	*** 00028c	5f 			pop	di
	*** 00028d	c9 			leave	
	*** 00028e	c3 			ret	

_ReadVolumeHeader	ENDP
_TEXT	ENDS
END
;|*** 
;|*** #endif // TC_WINDOWS_BOOT
;|*** 
;|*** 
;|*** #if !defined (DEVICE_DRIVER) && !defined (TC_WINDOWS_BOOT)
;|*** 
;|*** #ifdef VOLFORMAT
;|*** #	include "../Format/TcFormat.h"
;|*** #	include "Dlgcode.h"
;|*** #endif
;|*** 
;|*** // Creates a volume header in memory
;|*** int CreateVolumeHeaderInMemory (BOOL bBoot, char *header, int ea, int mode, Password *password,
;|*** 		   int pkcs5_prf, char *masterKeydata, PCRYPTO_INFO *retInfo,
;|*** 		   unsigned __int64 volumeSize, unsigned __int64 hiddenVolumeSize,
;|*** 		   unsigned __int64 encryptedAreaStart, unsigned __int64 encryptedAreaLength, uint16 requiredProgramVersion, uint32 headerFlags, uint32 sectorSize, BOOL bWipeMode)
;|*** {
;|*** 	unsigned char *p = (unsigned char *) header;
;|*** 	static KEY_INFO keyInfo;
;|*** 
;|*** 	int nUserKeyLen = password->Length;
;|*** 	PCRYPTO_INFO cryptoInfo = crypto_open ();
;|*** 	static char dk[MASTER_KEYDATA_SIZE];
;|*** 	int x;
;|*** 	int retVal = 0;
;|*** 	int primaryKeyOffset;
;|*** 
;|*** 	if (cryptoInfo == NULL)
;|*** 		return ERR_OUTOFMEMORY;
;|*** 
;|*** 	memset (header, 0, TC_VOLUME_HEADER_EFFECTIVE_SIZE);
;|*** 
;|*** 	VirtualLock (&keyInfo, sizeof (keyInfo));
;|*** 	VirtualLock (&dk, sizeof (dk));
;|*** 
;|*** 	/* Encryption setup */
;|*** 
;|*** 	if (masterKeydata == NULL)
;|*** 	{
;|*** 		// We have no master key data (creating a new volume) so we'll use the CipherShed RNG to generate them
;|*** 
;|*** 		int bytesNeeded;
;|*** 
;|*** 		switch (mode)
;|*** 		{
;|*** 		case LRW:
;|*** 		case CBC:
;|*** 		case INNER_CBC:
;|*** 		case OUTER_CBC:
;|*** 
;|*** 			// Deprecated/legacy modes of operation
;|*** 			bytesNeeded = LEGACY_VOL_IV_SIZE + EAGetKeySize (ea);
;|*** 
;|*** 			// In fact, this should never be the case since volumes being newly created are not
;|*** 			// supposed to use any deprecated mode of operation.
;|*** 			TC_THROW_FATAL_EXCEPTION;
;|*** 			break;
;|*** 
;|*** 		default:
;|*** 			bytesNeeded = EAGetKeySize (ea) * 2;	// Size of primary + secondary key(s)
;|*** 		}
;|*** 
;|*** 		if (!RandgetBytes (keyInfo.master_keydata, bytesNeeded, TRUE))
;|*** 			return ERR_CIPHER_INIT_WEAK_KEY;
;|*** 	}
;|*** 	else
;|*** 	{
;|*** 		// We already have existing master key data (the header is being re-encrypted)
;|*** 		memcpy (keyInfo.master_keydata, masterKeydata, MASTER_KEYDATA_SIZE);
;|*** 	}
;|*** 
;|*** 	// User key 
;|*** 	memcpy (keyInfo.userKey, password->Text, nUserKeyLen);
;|*** 	keyInfo.keyLength = nUserKeyLen;
;|*** 	keyInfo.noIterations = get_pkcs5_iteration_count (pkcs5_prf, bBoot);
;|*** 
;|*** 	// User selected encryption algorithm
;|*** 	cryptoInfo->ea = ea;
;|*** 
;|*** 	// Mode of operation
;|*** 	cryptoInfo->mode = mode;
;|*** 
;|*** 	// Salt for header key derivation
;|*** 	if (!RandgetBytes (keyInfo.salt, PKCS5_SALT_SIZE, !bWipeMode))
;|*** 		return ERR_CIPHER_INIT_WEAK_KEY; 
;|*** 
;|*** 	// PBKDF2 (PKCS5) is used to derive primary header key(s) and secondary header key(s) (XTS) from the password/keyfiles
;|*** 	switch (pkcs5_prf)
;|*** 	{
;|*** 	case SHA512:
;|*** 		derive_key_sha512 (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
;|*** 			PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());
;|*** 		break;
;|*** 
;|*** 	case SHA1:
;|*** 		// Deprecated/legacy
;|*** 		derive_key_sha1 (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
;|*** 			PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());
;|*** 		break;
;|*** 
;|*** 	case RIPEMD160:
;|*** 		derive_key_ripemd160 (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
;|*** 			PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());
;|*** 		break;
;|*** 
;|*** 	case WHIRLPOOL:
;|*** 		derive_key_whirlpool (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
;|*** 			PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());
;|*** 		break;
;|*** 
;|*** 	default:		
;|*** 		// Unknown/wrong ID
;|*** 		TC_THROW_FATAL_EXCEPTION;
;|*** 	} 
;|*** 
;|*** 	/* Header setup */
;|*** 
;|*** 	// Salt
;|*** 	mputBytes (p, keyInfo.salt, PKCS5_SALT_SIZE);	
;|*** 
;|*** 	// Magic 'TRUE'
;|*** 	/* Modifying 'TRUE' can introduce incompatibility with previous versions. */
;|*** 	mputLong (p, 0x54525545);
;|*** 
;|*** 	// Header version
;|*** 	mputWord (p, VOLUME_HEADER_VERSION);
;|*** 	cryptoInfo->HeaderVersion = VOLUME_HEADER_VERSION;
;|*** 
;|*** 	// Required program version to handle this volume
;|*** 	switch (mode)
;|*** 	{
;|*** 	case LRW:
;|*** 		// Deprecated/legacy
;|*** 		mputWord (p, 0x0410);
;|*** 		break;
;|*** 	case OUTER_CBC:
;|*** 	case INNER_CBC:
;|*** 		// Deprecated/legacy
;|*** 		mputWord (p, 0x0300);
;|*** 		break;
;|*** 	case CBC:
;|*** 		// Deprecated/legacy
;|*** 		mputWord (p, hiddenVolumeSize > 0 ? 0x0300 : 0x0100);
;|*** 		break;
;|*** 	default:
;|*** 		mputWord (p, requiredProgramVersion != 0 ? requiredProgramVersion : TC_VOLUME_MIN_REQUIRED_PROGRAM_VERSION);
;|*** 	}
;|*** 
;|*** 	// CRC of the master key data
;|*** 	x = GetCrc32(keyInfo.master_keydata, MASTER_KEYDATA_SIZE);
;|*** 	mputLong (p, x);
;|*** 
;|*** 	// Reserved fields
;|*** 	p += 2 * 8;
;|*** 
;|*** 	// Size of hidden volume (if any)
;|*** 	cryptoInfo->hiddenVolumeSize = hiddenVolumeSize;
;|*** 	mputInt64 (p, cryptoInfo->hiddenVolumeSize);
;|*** 
;|*** 	cryptoInfo->hiddenVolume = cryptoInfo->hiddenVolumeSize != 0;
;|*** 
;|*** 	// Volume size
;|*** 	cryptoInfo->VolumeSize.Value = volumeSize;
;|*** 	mputInt64 (p, volumeSize);
;|*** 
;|*** 	// Encrypted area start
;|*** 	cryptoInfo->EncryptedAreaStart.Value = encryptedAreaStart;
;|*** 	mputInt64 (p, encryptedAreaStart);
;|*** 
;|*** 	// Encrypted area size
;|*** 	cryptoInfo->EncryptedAreaLength.Value = encryptedAreaLength;
;|*** 	mputInt64 (p, encryptedAreaLength);
;|*** 
;|*** 	// Flags
;|*** 	cryptoInfo->HeaderFlags = headerFlags;
;|*** 	mputLong (p, headerFlags);
;|*** 
;|*** 	// Sector size
;|*** 	if (sectorSize < TC_MIN_VOLUME_SECTOR_SIZE
;|*** 		|| sectorSize > TC_MAX_VOLUME_SECTOR_SIZE
;|*** 		|| sectorSize % ENCRYPTION_DATA_UNIT_SIZE != 0)
;|*** 	{
;|*** 		TC_THROW_FATAL_EXCEPTION;
;|*** 	}
;|*** 
;|*** 	cryptoInfo->SectorSize = sectorSize;
;|*** 	mputLong (p, sectorSize);
;|*** 
;|*** 	// CRC of the header fields
;|*** 	x = GetCrc32 (header + TC_HEADER_OFFSET_MAGIC, TC_HEADER_OFFSET_HEADER_CRC - TC_HEADER_OFFSET_MAGIC);
;|*** 	p = header + TC_HEADER_OFFSET_HEADER_CRC;
;|*** 	mputLong (p, x);
;|*** 
;|*** 	// The master key data
;|*** 	memcpy (header + HEADER_MASTER_KEYDATA_OFFSET, keyInfo.master_keydata, MASTER_KEYDATA_SIZE);
;|*** 
;|*** 
;|*** 	/* Header encryption */
;|*** 
;|*** 	switch (mode)
;|*** 	{
;|*** 	case LRW:
;|*** 	case CBC:
;|*** 	case INNER_CBC:
;|*** 	case OUTER_CBC:
;|*** 
;|*** 		// For LRW (deprecated/legacy), the tweak key
;|*** 		// For CBC (deprecated/legacy), the IV/whitening seed
;|*** 		memcpy (cryptoInfo->k2, dk, LEGACY_VOL_IV_SIZE);
;|*** 		primaryKeyOffset = LEGACY_VOL_IV_SIZE;
;|*** 		break;
;|*** 
;|*** 	default:
;|*** 		// The secondary key (if cascade, multiple concatenated)
;|*** 		memcpy (cryptoInfo->k2, dk + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));
;|*** 		primaryKeyOffset = 0;
;|*** 	}
;|*** 
;|*** 	retVal = EAInit (cryptoInfo->ea, dk + primaryKeyOffset, cryptoInfo->ks);
;|*** 	if (retVal != ERR_SUCCESS)
;|*** 		return retVal;
;|*** 
;|*** 	// Mode of operation
;|*** 	if (!EAInitMode (cryptoInfo))
;|*** 		return ERR_OUTOFMEMORY;
;|*** 
;|*** 
;|*** 	// Encrypt the entire header (except the salt)
;|*** 	EncryptBuffer (header + HEADER_ENCRYPTED_DATA_OFFSET,
;|*** 		HEADER_ENCRYPTED_DATA_SIZE,
;|*** 		cryptoInfo);
;|*** 
;|*** 
;|*** 	/* cryptoInfo setup for further use (disk format) */
;|*** 
;|*** 	// Init with the master key(s) 
;|*** 	retVal = EAInit (cryptoInfo->ea, keyInfo.master_keydata + primaryKeyOffset, cryptoInfo->ks);
;|*** 	if (retVal != ERR_SUCCESS)
;|*** 		return retVal;
;|*** 
;|*** 	memcpy (cryptoInfo->master_keydata, keyInfo.master_keydata, MASTER_KEYDATA_SIZE);
;|*** 
;|*** 	switch (cryptoInfo->mode)
;|*** 	{
;|*** 	case LRW:
;|*** 	case CBC:
;|*** 	case INNER_CBC:
;|*** 	case OUTER_CBC:
;|*** 
;|*** 		// For LRW (deprecated/legacy), the tweak key
;|*** 		// For CBC (deprecated/legacy), the IV/whitening seed
;|*** 		memcpy (cryptoInfo->k2, keyInfo.master_keydata, LEGACY_VOL_IV_SIZE);
;|*** 		break;
;|*** 
;|*** 	default:
;|*** 		// The secondary master key (if cascade, multiple concatenated)
;|*** 		memcpy (cryptoInfo->k2, keyInfo.master_keydata + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));
;|*** 	}
;|*** 
;|*** 	// Mode of operation
;|*** 	if (!EAInitMode (cryptoInfo))
;|*** 		return ERR_OUTOFMEMORY;
;|*** 
;|*** 
;|*** #ifdef VOLFORMAT
;|*** 	if (showKeys && !bInPlaceEncNonSys)
;|*** 	{
;|*** 		BOOL dots3 = FALSE;
;|*** 		int i, j;
;|*** 
;|*** 		j = EAGetKeySize (ea);
;|*** 
;|*** 		if (j > NBR_KEY_BYTES_TO_DISPLAY)
;|*** 		{
;|*** 			dots3 = TRUE;
;|*** 			j = NBR_KEY_BYTES_TO_DISPLAY;
;|*** 		}
;|*** 
;|*** 		MasterKeyGUIView[0] = 0;
;|*** 		for (i = 0; i < j; i++)
;|*** 		{
;|*** 			char tmp2[8] = {0};
;|*** 			sprintf (tmp2, "%02X", (int) (unsigned char) keyInfo.master_keydata[i + primaryKeyOffset]);
;|*** 			strcat (MasterKeyGUIView, tmp2);
;|*** 		}
;|*** 
;|*** 		HeaderKeyGUIView[0] = 0;
;|*** 		for (i = 0; i < NBR_KEY_BYTES_TO_DISPLAY; i++)
;|*** 		{
;|*** 			char tmp2[8];
;|*** 			sprintf (tmp2, "%02X", (int) (unsigned char) dk[primaryKeyOffset + i]);
;|*** 			strcat (HeaderKeyGUIView, tmp2);
;|*** 		}
;|*** 
;|*** 		if (dots3)
;|*** 		{
;|*** 			DisplayPortionsOfKeys (hHeaderKey, hMasterKey, HeaderKeyGUIView, MasterKeyGUIView, !showKeys);
;|*** 		}
;|*** 		else
;|*** 		{
;|*** 			SendMessage (hMasterKey, WM_SETTEXT, 0, (LPARAM) MasterKeyGUIView);
;|*** 			SendMessage (hHeaderKey, WM_SETTEXT, 0, (LPARAM) HeaderKeyGUIView);
;|*** 		}
;|*** 	}
;|*** #endif	// #ifdef VOLFORMAT
;|*** 
;|*** 	burn (dk, sizeof(dk));
;|*** 	burn (&keyInfo, sizeof (keyInfo));
;|*** 
;|*** 	*retInfo = cryptoInfo;
;|*** 	return 0;
;|*** }
;|*** 
;|*** 
;|*** BOOL ReadEffectiveVolumeHeader (BOOL device, HANDLE fileHandle, byte *header, DWORD *bytesRead)
;|*** {
;|*** #if TC_VOLUME_HEADER_EFFECTIVE_SIZE > TC_MAX_VOLUME_SECTOR_SIZE
;|*** #error TC_VOLUME_HEADER_EFFECTIVE_SIZE > TC_MAX_VOLUME_SECTOR_SIZE
;|*** #endif
;|*** 
;|*** 	byte sectorBuffer[TC_MAX_VOLUME_SECTOR_SIZE];
;|*** 	DISK_GEOMETRY geometry;
;|*** 
;|*** 	if (!device)
;|*** 		return ReadFile (fileHandle, header, TC_VOLUME_HEADER_EFFECTIVE_SIZE, bytesRead, NULL);
;|*** 
;|*** 	if (!DeviceIoControl (fileHandle, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &geometry, sizeof (geometry), bytesRead, NULL))
;|*** 		return FALSE;
;|*** 
;|*** 	if (geometry.BytesPerSector > sizeof (sectorBuffer) || geometry.BytesPerSector < TC_MIN_VOLUME_SECTOR_SIZE)
;|*** 	{
;|*** 		SetLastError (ERROR_INVALID_PARAMETER);
;|*** 		return FALSE;
;|*** 	}
;|*** 
;|*** 	if (!ReadFile (fileHandle, sectorBuffer, max (TC_VOLUME_HEADER_EFFECTIVE_SIZE, geometry.BytesPerSector), bytesRead, NULL))
;|*** 		return FALSE;
;|*** 
;|*** 	memcpy (header, sectorBuffer, min (*bytesRead, TC_VOLUME_HEADER_EFFECTIVE_SIZE));
;|*** 	
;|*** 	if (*bytesRead > TC_VOLUME_HEADER_EFFECTIVE_SIZE)
;|*** 		*bytesRead = TC_VOLUME_HEADER_EFFECTIVE_SIZE;
;|*** 
;|*** 	return TRUE;
;|*** }
;|*** 
;|*** 
;|*** BOOL WriteEffectiveVolumeHeader (BOOL device, HANDLE fileHandle, byte *header)
;|*** {
;|*** #if TC_VOLUME_HEADER_EFFECTIVE_SIZE > TC_MAX_VOLUME_SECTOR_SIZE
;|*** #error TC_VOLUME_HEADER_EFFECTIVE_SIZE > TC_MAX_VOLUME_SECTOR_SIZE
;|*** #endif
;|*** 
;|*** 	byte sectorBuffer[TC_MAX_VOLUME_SECTOR_SIZE];
;|*** 	DWORD bytesDone;
;|*** 	DISK_GEOMETRY geometry;
;|*** 
;|*** 	if (!device)
;|*** 	{
;|*** 		if (!WriteFile (fileHandle, header, TC_VOLUME_HEADER_EFFECTIVE_SIZE, &bytesDone, NULL))
;|*** 			return FALSE;
;|*** 
;|*** 		if (bytesDone != TC_VOLUME_HEADER_EFFECTIVE_SIZE)
;|*** 		{
;|*** 			SetLastError (ERROR_INVALID_PARAMETER);
;|*** 			return FALSE;
;|*** 		}
;|*** 
;|*** 		return TRUE;
;|*** 	}
;|*** 
;|*** 	if (!DeviceIoControl (fileHandle, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &geometry, sizeof (geometry), &bytesDone, NULL))
;|*** 		return FALSE;
;|*** 
;|*** 	if (geometry.BytesPerSector > sizeof (sectorBuffer) || geometry.BytesPerSector < TC_MIN_VOLUME_SECTOR_SIZE)
;|*** 	{
;|*** 		SetLastError (ERROR_INVALID_PARAMETER);
;|*** 		return FALSE;
;|*** 	}
;|*** 
;|*** 	if (geometry.BytesPerSector != TC_VOLUME_HEADER_EFFECTIVE_SIZE)
;|*** 	{
;|*** 		LARGE_INTEGER seekOffset;
;|*** 
;|*** 		if (!ReadFile (fileHandle, sectorBuffer, geometry.BytesPerSector, &bytesDone, NULL))
;|*** 			return FALSE;
;|*** 
;|*** 		if (bytesDone != geometry.BytesPerSector)
;|*** 		{
;|*** 			SetLastError (ERROR_INVALID_PARAMETER);
;|*** 			return FALSE;
;|*** 		}
;|*** 
;|*** 		seekOffset.QuadPart = -(int) bytesDone;
;|*** 		if (!SetFilePointerEx (fileHandle, seekOffset, NULL, FILE_CURRENT))
;|*** 			return FALSE;
;|*** 	}
;|*** 
;|*** 	memcpy (sectorBuffer, header, TC_VOLUME_HEADER_EFFECTIVE_SIZE);
;|*** 
;|*** 	if (!WriteFile (fileHandle, sectorBuffer, geometry.BytesPerSector, &bytesDone, NULL))
;|*** 		return FALSE;
;|*** 
;|*** 	if (bytesDone != geometry.BytesPerSector)
;|*** 	{
;|*** 		SetLastError (ERROR_INVALID_PARAMETER);
;|*** 		return FALSE;
;|*** 	}
;|*** 
;|*** 	return TRUE;
;|*** }
;|*** 
;|*** 
;|*** // Writes randomly generated data to unused/reserved header areas.
;|*** // When bPrimaryOnly is TRUE, then only the primary header area (not the backup header area) is filled with random data.
;|*** // When bBackupOnly is TRUE, only the backup header area (not the primary header area) is filled with random data.
;|*** int WriteRandomDataToReservedHeaderAreas (HANDLE dev, CRYPTO_INFO *cryptoInfo, uint64 dataAreaSize, BOOL bPrimaryOnly, BOOL bBackupOnly)
;|*** {
;|*** 	char temporaryKey[MASTER_KEYDATA_SIZE];
;|*** 	char originalK2[MASTER_KEYDATA_SIZE];
;|*** 
;|*** 	byte buf[TC_VOLUME_HEADER_GROUP_SIZE];
;|*** 
;|*** 	LARGE_INTEGER offset;
;|*** 	int nStatus = ERR_SUCCESS;
;|*** 	DWORD dwError;
;|*** 	DWORD bytesDone;
;|*** 	BOOL backupHeaders = bBackupOnly;
;|*** 
;|*** 	if (bPrimaryOnly && bBackupOnly)
;|*** 		TC_THROW_FATAL_EXCEPTION;
;|*** 
;|*** 	memcpy (originalK2, cryptoInfo->k2, sizeof (cryptoInfo->k2));
;|*** 
;|*** 	while (TRUE)
;|*** 	{
;|*** 		// Temporary keys
;|*** 		if (!RandgetBytes (temporaryKey, EAGetKeySize (cryptoInfo->ea), FALSE)
;|*** 			|| !RandgetBytes (cryptoInfo->k2, sizeof (cryptoInfo->k2), FALSE))
;|*** 		{
;|*** 			nStatus = ERR_PARAMETER_INCORRECT; 
;|*** 			goto final_seq;
;|*** 		}
;|*** 
;|*** 		nStatus = EAInit (cryptoInfo->ea, temporaryKey, cryptoInfo->ks);
;|*** 		if (nStatus != ERR_SUCCESS)
;|*** 			goto final_seq;
;|*** 
;|*** 		if (!EAInitMode (cryptoInfo))
;|*** 		{
;|*** 			nStatus = ERR_MODE_INIT_FAILED;
;|*** 			goto final_seq;
;|*** 		}
;|*** 
;|*** 		offset.QuadPart = backupHeaders ? dataAreaSize + TC_VOLUME_HEADER_GROUP_SIZE : TC_VOLUME_HEADER_OFFSET;
;|*** 
;|*** 		if (!SetFilePointerEx (dev, offset, NULL, FILE_BEGIN))
;|*** 		{
;|*** 			nStatus = ERR_OS_ERROR;
;|*** 			goto final_seq;
;|*** 		}
;|*** 
;|*** 		if (!ReadFile (dev, buf, sizeof (buf), &bytesDone, NULL))
;|*** 		{
;|*** 			nStatus = ERR_OS_ERROR;
;|*** 			goto final_seq;
;|*** 		}
;|*** 
;|*** 		if (bytesDone < TC_VOLUME_HEADER_EFFECTIVE_SIZE)
;|*** 		{
;|*** 			SetLastError (ERROR_INVALID_PARAMETER);
;|*** 			nStatus = ERR_OS_ERROR;
;|*** 			goto final_seq;
;|*** 		}
;|*** 
;|*** 		EncryptBuffer (buf + TC_VOLUME_HEADER_EFFECTIVE_SIZE, sizeof (buf) - TC_VOLUME_HEADER_EFFECTIVE_SIZE, cryptoInfo);
;|*** 
;|*** 		if (!SetFilePointerEx (dev, offset, NULL, FILE_BEGIN))
;|*** 		{
;|*** 			nStatus = ERR_OS_ERROR;
;|*** 			goto final_seq;
;|*** 		}
;|*** 
;|*** 		if (!WriteFile (dev, buf, sizeof (buf), &bytesDone, NULL))
;|*** 		{
;|*** 			nStatus = ERR_OS_ERROR;
;|*** 			goto final_seq;
;|*** 		}
;|*** 
;|*** 		if (bytesDone != sizeof (buf))
;|*** 		{
;|*** 			nStatus = ERR_PARAMETER_INCORRECT;
;|*** 			goto final_seq;
;|*** 		}
;|*** 
;|*** 		if (backupHeaders || bPrimaryOnly)
;|*** 			break;
;|*** 
;|*** 		backupHeaders = TRUE;
;|*** 	}
;|*** 
;|*** 	memcpy (cryptoInfo->k2, originalK2, sizeof (cryptoInfo->k2));
;|*** 
;|*** 	nStatus = EAInit (cryptoInfo->ea, cryptoInfo->master_keydata, cryptoInfo->ks);
;|*** 	if (nStatus != ERR_SUCCESS)
;|*** 		goto final_seq;
;|*** 
;|*** 	if (!EAInitMode (cryptoInfo))
;|*** 	{
;|*** 		nStatus = ERR_MODE_INIT_FAILED;
;|*** 		goto final_seq;
;|*** 	}
;|*** 
;|*** final_seq:
;|*** 
;|*** 	dwError = GetLastError();
;|*** 
;|*** 	burn (temporaryKey, sizeof (temporaryKey));
;|*** 	burn (originalK2, sizeof (originalK2));
;|*** 
;|*** 	if (nStatus != ERR_SUCCESS)
;|*** 		SetLastError (dwError);
;|*** 
;|*** 	return nStatus;
;|*** }
;|*** 
;|*** #endif // !defined (DEVICE_DRIVER) && !defined (TC_WINDOWS_BOOT)
