; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\home\public\Desktop\projects\cipherShed\src\Common\Password.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_RtlSecureZeroMemory
; Function compile flags: /Ogtpy
; File c:\program files\microsoft sdks\windows\v7.1\include\winnt.h
;	COMDAT _RtlSecureZeroMemory
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory PROC				; COMDAT

; 13070:     volatile char *vptr = (volatile char *)ptr;
; 13071: 
; 13072: #if defined(_M_AMD64)
; 13073: 
; 13074:         __stosb((PBYTE )((DWORD64)vptr), 0, cnt);
; 13075: 
; 13076: #else
; 13077: 
; 13078:     while (cnt) {

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _cnt$[esp-4]
  00004	8b 44 24 04	 mov	 eax, DWORD PTR _ptr$[esp-4]
  00008	8b c8		 mov	 ecx, eax
  0000a	85 d2		 test	 edx, edx
  0000c	74 0b		 je	 SHORT $LN1@RtlSecureZ
  0000e	8b ff		 npad	 2
$LL2@RtlSecureZ:

; 13079:         *vptr = 0;

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 13080:         vptr++;

  00013	41		 inc	 ecx

; 13081:         cnt--;

  00014	83 ea 01	 sub	 edx, 1
  00017	75 f7		 jne	 SHORT $LL2@RtlSecureZ
$LN1@RtlSecureZ:

; 13082:     }
; 13083: 
; 13084: #endif
; 13085: 
; 13086:     return ptr;
; 13087: }

  00019	c3		 ret	 0
_RtlSecureZeroMemory ENDP
_TEXT	ENDS
PUBLIC	_szVerify$GSCopy$
PUBLIC	_hButton$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_VerifyPasswordAndUpdate
EXTRN	__imp__EnableWindow@8:PROC
EXTRN	__imp__GetWindowTextA@12:PROC
EXTRN	__imp__GetWindowTextLengthA@4:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtpy
; File c:\home\public\desktop\projects\ciphershed\src\common\password.c
;	COMDAT _VerifyPasswordAndUpdate
_TEXT	SEGMENT
_hButton$GSCopy$ = -148					; size = 4
_szVerify$GSCopy$ = -144				; size = 4
_szTmp1$ = -140						; size = 65
_szTmp2$ = -72						; size = 65
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_hButton$ = 12						; size = 4
_hPassword$ = 16					; size = 4
_hVerify$ = 20						; size = 4
_szPassword$ = 24					; size = 4
_szVerify$ = 28						; size = 4
_keyFilesEnabled$ = 32					; size = 4
_VerifyPasswordAndUpdate PROC				; COMDAT

; 29   : {

  00000	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 90 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+148], eax
  00014	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR _hButton$[esp+144]
  0001b	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR _szVerify$[esp+144]
  00022	53		 push	 ebx
  00023	8b 9c 24 a8 00
	00 00		 mov	 ebx, DWORD PTR _hVerify$[esp+148]
  0002a	55		 push	 ebp
  0002b	8b ac 24 b0 00
	00 00		 mov	 ebp, DWORD PTR _szPassword$[esp+152]
  00032	56		 push	 esi
  00033	8b b4 24 ac 00
	00 00		 mov	 esi, DWORD PTR _hPassword$[esp+156]
  0003a	57		 push	 edi

; 30   : 	char szTmp1[MAX_PASSWORD + 1];
; 31   : 	char szTmp2[MAX_PASSWORD + 1];
; 32   : 	int k = GetWindowTextLength (hPassword);

  0003b	56		 push	 esi

; 51   : 		memcpy (szPassword, szTmp1, sizeof (szTmp1));

  0003c	89 44 24 14	 mov	 DWORD PTR _hButton$GSCopy$[esp+168], eax
  00040	89 4c 24 18	 mov	 DWORD PTR _szVerify$GSCopy$[esp+168], ecx
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextLengthA@4
  0004a	6a 41		 push	 65			; 00000041H
  0004c	8d 54 24 1c	 lea	 edx, DWORD PTR _szTmp1$[esp+168]
  00050	52		 push	 edx
  00051	56		 push	 esi
  00052	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetWindowTextA@12
  00058	8b f8		 mov	 edi, eax
  0005a	ff d6		 call	 esi
  0005c	6a 41		 push	 65			; 00000041H
  0005e	8d 44 24 60	 lea	 eax, DWORD PTR _szTmp2$[esp+168]
  00062	50		 push	 eax
  00063	53		 push	 ebx
  00064	ff d6		 call	 esi
  00066	8d 4c 24 5c	 lea	 ecx, DWORD PTR _szTmp2$[esp+164]
  0006a	8d 44 24 18	 lea	 eax, DWORD PTR _szTmp1$[esp+164]
  0006e	8b ff		 npad	 2
$LL44@VerifyPass:
  00070	8a 10		 mov	 dl, BYTE PTR [eax]
  00072	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00074	75 1a		 jne	 SHORT $LN45@VerifyPass

; 33   : 	BOOL bEnable = FALSE;
; 34   : 
; 35   : 	if (hwndDlg);		/* Remove warning */
; 36   : 
; 37   : 	GetWindowText (hPassword, szTmp1, sizeof (szTmp1));
; 38   : 	GetWindowText (hVerify, szTmp2, sizeof (szTmp2));
; 39   : 
; 40   : 	if (strcmp (szTmp1, szTmp2) != 0)

  00076	84 d2		 test	 dl, dl
  00078	74 12		 je	 SHORT $LN46@VerifyPass
  0007a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0007d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00080	75 0e		 jne	 SHORT $LN45@VerifyPass
  00082	83 c0 02	 add	 eax, 2
  00085	83 c1 02	 add	 ecx, 2
  00088	84 d2		 test	 dl, dl
  0008a	75 e4		 jne	 SHORT $LL44@VerifyPass
$LN46@VerifyPass:
  0008c	33 c0		 xor	 eax, eax
  0008e	eb 05		 jmp	 SHORT $LN47@VerifyPass
$LN45@VerifyPass:
  00090	1b c0		 sbb	 eax, eax
  00092	83 d8 ff	 sbb	 eax, -1
$LN47@VerifyPass:
  00095	85 c0		 test	 eax, eax
  00097	74 04		 je	 SHORT $LN17@VerifyPass

; 41   : 		bEnable = FALSE;

  00099	33 db		 xor	 ebx, ebx

; 42   : 	else

  0009b	eb 18		 jmp	 SHORT $LN13@VerifyPass
$LN17@VerifyPass:

; 43   : 	{
; 44   : 		if (k >= MIN_PASSWORD || keyFilesEnabled)

  0009d	83 ff 01	 cmp	 edi, 1
  000a0	7d 0e		 jge	 SHORT $LN14@VerifyPass
  000a2	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR _keyFilesEnabled$[esp+160], 0
  000aa	75 04		 jne	 SHORT $LN14@VerifyPass

; 46   : 		else
; 47   : 			bEnable = FALSE;

  000ac	33 db		 xor	 ebx, ebx
  000ae	eb 05		 jmp	 SHORT $LN13@VerifyPass
$LN14@VerifyPass:

; 45   : 			bEnable = TRUE;

  000b0	bb 01 00 00 00	 mov	 ebx, 1
$LN13@VerifyPass:

; 48   : 	}
; 49   : 
; 50   : 	if (szPassword != NULL)

  000b5	85 ed		 test	 ebp, ebp
  000b7	74 0e		 je	 SHORT $LN12@VerifyPass

; 51   : 		memcpy (szPassword, szTmp1, sizeof (szTmp1));

  000b9	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  000be	8d 74 24 18	 lea	 esi, DWORD PTR _szTmp1$[esp+164]
  000c2	8b fd		 mov	 edi, ebp
  000c4	f3 a5		 rep movsd
  000c6	a4		 movsb
$LN12@VerifyPass:

; 52   : 
; 53   : 	if (szVerify != NULL)

  000c7	8b 7c 24 14	 mov	 edi, DWORD PTR _szVerify$GSCopy$[esp+164]
  000cb	85 ff		 test	 edi, edi
  000cd	74 0c		 je	 SHORT $LN10@VerifyPass

; 54   : 		memcpy (szVerify, szTmp2, sizeof (szTmp2));

  000cf	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  000d4	8d 74 24 5c	 lea	 esi, DWORD PTR _szTmp2$[esp+164]
  000d8	f3 a5		 rep movsd
  000da	a4		 movsb
$LN10@VerifyPass:

; 55   : 
; 56   : 	burn (szTmp1, sizeof (szTmp1));

  000db	8d 54 24 18	 lea	 edx, DWORD PTR _szTmp1$[esp+164]
  000df	b9 41 00 00 00	 mov	 ecx, 65			; 00000041H
  000e4	8b f1		 mov	 esi, ecx
  000e6	8b c2		 mov	 eax, edx
$LL22@VerifyPass:
  000e8	c6 00 00	 mov	 BYTE PTR [eax], 0
  000eb	40		 inc	 eax
  000ec	83 ee 01	 sub	 esi, 1
  000ef	75 f7		 jne	 SHORT $LL22@VerifyPass
$LL7@VerifyPass:
  000f1	49		 dec	 ecx
  000f2	c6 02 00	 mov	 BYTE PTR [edx], 0
  000f5	42		 inc	 edx
  000f6	85 c9		 test	 ecx, ecx
  000f8	75 f7		 jne	 SHORT $LL7@VerifyPass

; 57   : 	burn (szTmp2, sizeof (szTmp2));

  000fa	8d 54 24 5c	 lea	 edx, DWORD PTR _szTmp2$[esp+164]
  000fe	b9 41 00 00 00	 mov	 ecx, 65			; 00000041H
  00103	8b f1		 mov	 esi, ecx
  00105	8b c2		 mov	 eax, edx
$LL26@VerifyPass:
  00107	c6 00 00	 mov	 BYTE PTR [eax], 0
  0010a	40		 inc	 eax
  0010b	83 ee 01	 sub	 esi, 1
  0010e	75 f7		 jne	 SHORT $LL26@VerifyPass
$LL2@VerifyPass:
  00110	49		 dec	 ecx
  00111	c6 02 00	 mov	 BYTE PTR [edx], 0
  00114	42		 inc	 edx
  00115	85 c9		 test	 ecx, ecx
  00117	75 f7		 jne	 SHORT $LL2@VerifyPass

; 58   : 
; 59   : 	EnableWindow (hButton, bEnable);

  00119	8b 4c 24 10	 mov	 ecx, DWORD PTR _hButton$GSCopy$[esp+164]
  0011d	53		 push	 ebx
  0011e	51		 push	 ecx
  0011f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 60   : }

  00125	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+164]
  0012c	5f		 pop	 edi
  0012d	5e		 pop	 esi
  0012e	5d		 pop	 ebp
  0012f	5b		 pop	 ebx
  00130	33 cc		 xor	 ecx, esp
  00132	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00137	81 c4 94 00 00
	00		 add	 esp, 148		; 00000094H
  0013d	c3		 ret	 0
_VerifyPasswordAndUpdate ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_CheckPasswordCharEncoding
EXTRN	__imp__GetWindowTextW@12:PROC
; Function compile flags: /Ogtpy
;	COMDAT _CheckPasswordCharEncoding
_TEXT	SEGMENT
_s$80721 = -136						; size = 130
__$ArrayPad$ = -4					; size = 4
_hPassword$ = 8						; size = 4
_ptrPw$ = 12						; size = 4
_CheckPasswordCharEncoding PROC				; COMDAT

; 64   : {

  00000	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 84 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+136], eax
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	8b b4 24 94 00
	00 00		 mov	 esi, DWORD PTR _hPassword$[esp+140]

; 65   : 	int i, len;
; 66   : 	
; 67   : 	if (hPassword == NULL)

  0001d	85 f6		 test	 esi, esi
  0001f	75 41		 jne	 SHORT $LN19@CheckPassw

; 68   : 	{
; 69   : 		unsigned char *pw;
; 70   : 		len = ptrPw->Length;

  00021	8b b4 24 98 00
	00 00		 mov	 esi, DWORD PTR _ptrPw$[esp+140]
  00028	8b 16		 mov	 edx, DWORD PTR [esi]

; 71   : 		pw = (unsigned char *) ptrPw->Text;
; 72   : 
; 73   : 		for (i = 0; i < len; i++)

  0002a	33 c0		 xor	 eax, eax
  0002c	85 d2		 test	 edx, edx
  0002e	0f 8e 8b 00 00
	00		 jle	 $LN1@CheckPassw
$LL18@CheckPassw:

; 74   : 		{
; 75   : 			//for i in `seq 32 126`; do printf "\x$(printf %x $i) "; done
; 76   : 			if (pw[i] >= 0x7f || pw[i] < 0x20)	// A non-ASCII or non-printable character?

  00034	8a 4c 30 04	 mov	 cl, BYTE PTR [eax+esi+4]
  00038	80 f9 7f	 cmp	 cl, 127			; 0000007fH
  0003b	73 0c		 jae	 SHORT $LN30@CheckPassw
  0003d	80 f9 20	 cmp	 cl, 32			; 00000020H
  00040	72 07		 jb	 SHORT $LN30@CheckPassw
  00042	40		 inc	 eax
  00043	3b c2		 cmp	 eax, edx
  00045	7c ed		 jl	 SHORT $LL18@CheckPassw

; 91   : 		{
; 92   : 			if (s[i] >= 0x7f || s[i] < 0x20)	// A non-ASCII or non-printable character?

  00047	eb 76		 jmp	 SHORT $LN1@CheckPassw
$LN30@CheckPassw:
  00049	5e		 pop	 esi

; 77   : 				return FALSE;

  0004a	33 c0		 xor	 eax, eax
  0004c	5b		 pop	 ebx

; 100  : 	}
; 101  : 
; 102  : 	return TRUE;
; 103  : }

  0004d	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+136]
  00054	33 cc		 xor	 ecx, esp
  00056	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005b	81 c4 88 00 00
	00		 add	 esp, 136		; 00000088H
  00061	c3		 ret	 0
$LN19@CheckPassw:

; 78   : 		}
; 79   : 	}
; 80   : 	else
; 81   : 	{
; 82   : 		wchar_t s[MAX_PASSWORD + 1];
; 83   : 		len = GetWindowTextLength (hPassword);

  00062	56		 push	 esi
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextLengthA@4
  00069	8b d8		 mov	 ebx, eax

; 84   : 
; 85   : 		if (len > MAX_PASSWORD)

  0006b	83 fb 40	 cmp	 ebx, 64			; 00000040H

; 86   : 			return FALSE; 

  0006e	7f d9		 jg	 SHORT $LN30@CheckPassw
  00070	57		 push	 edi

; 87   : 
; 88   : 		GetWindowTextW (hPassword, s, sizeof (s) / sizeof (wchar_t));

  00071	6a 41		 push	 65			; 00000041H
  00073	8d 44 24 10	 lea	 eax, DWORD PTR _s$80721[esp+152]
  00077	50		 push	 eax
  00078	56		 push	 esi
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextW@12

; 89   : 
; 90   : 		for (i = 0; i < len; i++)

  0007f	33 ff		 xor	 edi, edi
  00081	85 db		 test	 ebx, ebx
  00083	7e 16		 jle	 SHORT $LN6@CheckPassw
$LL11@CheckPassw:

; 91   : 		{
; 92   : 			if (s[i] >= 0x7f || s[i] < 0x20)	// A non-ASCII or non-printable character?

  00085	0f b7 44 7c 0c	 movzx	 eax, WORD PTR _s$80721[esp+edi*2+148]
  0008a	66 83 f8 7f	 cmp	 ax, 127			; 0000007fH
  0008e	73 0b		 jae	 SHORT $LN6@CheckPassw
  00090	66 83 f8 20	 cmp	 ax, 32			; 00000020H
  00094	72 05		 jb	 SHORT $LN6@CheckPassw
  00096	47		 inc	 edi
  00097	3b fb		 cmp	 edi, ebx
  00099	7c ea		 jl	 SHORT $LL11@CheckPassw
$LN6@CheckPassw:

; 93   : 				break;
; 94   : 		}
; 95   : 
; 96   : 		burn (s, sizeof(s));

  0009b	8d 54 24 0c	 lea	 edx, DWORD PTR _s$80721[esp+148]
  0009f	b9 82 00 00 00	 mov	 ecx, 130		; 00000082H
  000a4	8b f1		 mov	 esi, ecx
  000a6	8b c2		 mov	 eax, edx
$LL23@CheckPassw:
  000a8	c6 00 00	 mov	 BYTE PTR [eax], 0
  000ab	40		 inc	 eax
  000ac	83 ee 01	 sub	 esi, 1
  000af	75 f7		 jne	 SHORT $LL23@CheckPassw
$LL3@CheckPassw:
  000b1	49		 dec	 ecx
  000b2	c6 02 00	 mov	 BYTE PTR [edx], 0
  000b5	42		 inc	 edx
  000b6	85 c9		 test	 ecx, ecx
  000b8	75 f7		 jne	 SHORT $LL3@CheckPassw

; 97   : 
; 98   : 		if (i < len)

  000ba	3b fb		 cmp	 edi, ebx
  000bc	5f		 pop	 edi

; 99   : 			return FALSE; 

  000bd	7c 8a		 jl	 SHORT $LN30@CheckPassw
$LN1@CheckPassw:

; 100  : 	}
; 101  : 
; 102  : 	return TRUE;
; 103  : }

  000bf	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+144]
  000c6	5e		 pop	 esi
  000c7	5b		 pop	 ebx
  000c8	33 cc		 xor	 ecx, esp
  000ca	b8 01 00 00 00	 mov	 eax, 1
  000cf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d4	81 c4 88 00 00
	00		 add	 esp, 136		; 00000088H
  000da	c3		 ret	 0
_CheckPasswordCharEncoding ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@FPFPGNBO@PASSWORD_LENGTH_WARNING?$AA@	; `string'
PUBLIC	_CheckPasswordLength
EXTRN	__imp__MessageBoxW@16:PROC
EXTRN	_GetString:PROC
EXTRN	_lpszTitle:DWORD
;	COMDAT ??_C@_0BI@FPFPGNBO@PASSWORD_LENGTH_WARNING?$AA@
CONST	SEGMENT
??_C@_0BI@FPFPGNBO@PASSWORD_LENGTH_WARNING?$AA@ DB 'PASSWORD_LENGTH_WARNI'
	DB	'NG', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _CheckPasswordLength
_TEXT	SEGMENT
_hwndDlg$ = 8						; size = 4
_hwndItem$ = 12						; size = 4
_CheckPasswordLength PROC				; COMDAT

; 108  : 	if (GetWindowTextLength (hwndItem) < PASSWORD_LEN_WARNING)

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _hwndItem$[esp-4]
  00004	50		 push	 eax
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextLengthA@4
  0000b	83 f8 14	 cmp	 eax, 20			; 00000014H
  0000e	7d 2d		 jge	 SHORT $LN1@CheckPassw@2

; 109  : 	{
; 110  : #ifndef _DEBUG
; 111  : 		if (MessageBoxW (hwndDlg, GetString ("PASSWORD_LENGTH_WARNING"), lpszTitle, MB_YESNO|MB_ICONWARNING|MB_DEFBUTTON2) != IDYES)

  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpszTitle
  00016	68 34 01 00 00	 push	 308			; 00000134H
  0001b	51		 push	 ecx
  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@FPFPGNBO@PASSWORD_LENGTH_WARNING?$AA@
  00021	e8 00 00 00 00	 call	 _GetString
  00026	8b 54 24 10	 mov	 edx, DWORD PTR _hwndDlg$[esp+8]
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	52		 push	 edx
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
  00035	83 f8 06	 cmp	 eax, 6
  00038	74 03		 je	 SHORT $LN1@CheckPassw@2

; 112  : 			return FALSE;

  0003a	33 c0		 xor	 eax, eax

; 116  : }

  0003c	c3		 ret	 0
$LN1@CheckPassw@2:

; 113  : #endif
; 114  : 	}
; 115  : 	return TRUE;

  0003d	b8 01 00 00 00	 mov	 eax, 1

; 116  : }

  00042	c3		 ret	 0
_CheckPasswordLength ENDP
_TEXT	ENDS
PUBLIC	_hwndDlg$GSCopy$
PUBLIC	_newPassword$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_ChangePwd
EXTRN	_handleError:PROC
EXTRN	_IsUacSupported:PROC
EXTRN	_UacElevated:DWORD
EXTRN	__imp__SetLastError@4:PROC
EXTRN	_RandStop:PROC
EXTRN	_RemoveFakeDosName:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__SetFileTime@16:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__FlushFileBuffers@4:PROC
EXTRN	_WriteRandomDataToReservedHeaderAreas:PROC
EXTRN	_WriteEffectiveVolumeHeader:PROC
EXTRN	_crypto_close:PROC
EXTRN	_CreateVolumeHeaderInMemory:PROC
EXTRN	_EnableElevatedCursorChange:PROC
EXTRN	_UserEnrichRandomPool:PROC
EXTRN	_NormalCursor:PROC
EXTRN	_RandSetHashFunction:PROC
EXTRN	_ReadVolumeHeader:PROC
EXTRN	_ReadEffectiveVolumeHeader:PROC
EXTRN	__imp__SetFilePointerEx@20:PROC
EXTRN	__imp__GetFileTime@16:PROC
EXTRN	_bPreserveTimestamp:DWORD
EXTRN	_Randinit:PROC
EXTRN	__imp__GetFileSizeEx@8:PROC
EXTRN	_GetPartitionInfo:PROC
EXTRN	__imp__DeviceIoControl@32:PROC
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	_FakeDosNameForDevice:PROC
EXTRN	_CreateFullVolumePath:PROC
EXTRN	_WaitCursor:PROC
EXTRN	_memset:PROC
EXTRN	__allmul:PROC
; Function compile flags: /Ogtpy
;	COMDAT _ChangePwd
_TEXT	SEGMENT
_cryptoInfo$ = -1444					; size = 4
_bDevice$ = -1440					; size = 4
_dev$ = -1436						; size = 4
_hostSize$ = -1432					; size = 8
_headerOffset$ = -1424					; size = 8
_volumeType$ = -1416					; size = 4
_hwndDlg$GSCopy$ = -1412				; size = 4
_ci$ = -1408						; size = 4
_nDosLinkCreated$ = -1404				; size = 4
_bTimeStampValid$ = -1400				; size = 4
_newPassword$GSCopy$ = -1396				; size = 4
_bytesRead$ = -1392					; size = 4
_fileSize$80810 = -1388					; size = 8
_driveInfo$ = -1380					; size = 24
_ftLastAccessTime$ = -1356				; size = 8
_ftCreationTime$ = -1348				; size = 8
_ftLastWriteTime$ = -1340				; size = 8
_dwResult$80801 = -1332					; size = 4
_diskInfo$80800 = -1328					; size = 32
_szDiskFile$ = -1296					; size = 260
_buffer$ = -1036					; size = 512
_szCFDevice$ = -524					; size = 260
_szDosDevice$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_lpszVolume$ = 8					; size = 4
_oldPassword$ = 12					; size = 4
_newPassword$ = 16					; size = 4
_pkcs5$ = 20						; size = 4
_hwndDlg$ = 24						; size = 4
_ChangePwd PROC						; COMDAT

; 119  : {

  00000	81 ec a4 05 00
	00		 sub	 esp, 1444		; 000005a4H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 a0 05
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1444], eax
  00014	8b 84 24 b0 05
	00 00		 mov	 eax, DWORD PTR _newPassword$[esp+1440]

; 120  : 	int nDosLinkCreated = 1, nStatus = ERR_OS_ERROR;

  0001b	8b 8c 24 b8 05
	00 00		 mov	 ecx, DWORD PTR _hwndDlg$[esp+1440]
  00022	53		 push	 ebx
  00023	55		 push	 ebp
  00024	8b ac 24 b0 05
	00 00		 mov	 ebp, DWORD PTR _lpszVolume$[esp+1448]
  0002b	56		 push	 esi

; 121  : 	char szDiskFile[TC_MAX_PATH], szCFDevice[TC_MAX_PATH];
; 122  : 	char szDosDevice[TC_MAX_PATH];
; 123  : 	char buffer[TC_VOLUME_HEADER_EFFECTIVE_SIZE];
; 124  : 	PCRYPTO_INFO cryptoInfo = NULL, ci = NULL;

  0002c	33 db		 xor	 ebx, ebx
  0002e	57		 push	 edi
  0002f	8b bc 24 bc 05
	00 00		 mov	 edi, DWORD PTR _oldPassword$[esp+1456]
  00036	be 01 00 00 00	 mov	 esi, 1
  0003b	89 44 24 40	 mov	 DWORD PTR _newPassword$GSCopy$[esp+1460], eax
  0003f	89 4c 24 30	 mov	 DWORD PTR _hwndDlg$GSCopy$[esp+1460], ecx
  00043	89 74 24 38	 mov	 DWORD PTR _nDosLinkCreated$[esp+1460], esi
  00047	89 5c 24 10	 mov	 DWORD PTR _cryptoInfo$[esp+1460], ebx
  0004b	89 5c 24 34	 mov	 DWORD PTR _ci$[esp+1460], ebx

; 125  : 	void *dev = INVALID_HANDLE_VALUE;

  0004f	c7 44 24 18 ff
	ff ff ff	 mov	 DWORD PTR _dev$[esp+1460], -1

; 126  : 	DWORD dwError;
; 127  : 	DWORD bytesRead;
; 128  : 	BOOL bDevice;
; 129  : 	unsigned __int64 hostSize = 0;
; 130  : 	int volumeType;
; 131  : 	int wipePass;
; 132  : 	FILETIME ftCreationTime;
; 133  : 	FILETIME ftLastWriteTime;
; 134  : 	FILETIME ftLastAccessTime;
; 135  : 	BOOL bTimeStampValid = FALSE;

  00057	89 5c 24 3c	 mov	 DWORD PTR _bTimeStampValid$[esp+1460], ebx

; 136  : 	LARGE_INTEGER headerOffset;
; 137  : 	BOOL backupHeader;
; 138  : 	DISK_GEOMETRY driveInfo;
; 139  : 
; 140  : 	if (oldPassword->Length == 0 || newPassword->Length == 0) return -1;

  0005b	39 1f		 cmp	 DWORD PTR [edi], ebx
  0005d	0f 84 a6 05 00
	00		 je	 $LN63@ChangePwd
  00063	39 18		 cmp	 DWORD PTR [eax], ebx
  00065	0f 84 9e 05 00
	00		 je	 $LN63@ChangePwd

; 141  : 
; 142  : 	WaitCursor ();

  0006b	e8 00 00 00 00	 call	 _WaitCursor

; 143  : 
; 144  : 	CreateFullVolumePath (szDiskFile, lpszVolume, &bDevice);

  00070	8d 54 24 14	 lea	 edx, DWORD PTR _bDevice$[esp+1460]
  00074	52		 push	 edx
  00075	8d 84 24 a8 00
	00 00		 lea	 eax, DWORD PTR _szDiskFile$[esp+1464]
  0007c	55		 push	 ebp
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 _CreateFullVolumePath
  00083	83 c4 0c	 add	 esp, 12			; 0000000cH

; 145  : 
; 146  : 	if (bDevice == FALSE)

  00086	39 5c 24 14	 cmp	 DWORD PTR _bDevice$[esp+1460], ebx
  0008a	75 19		 jne	 SHORT $LN62@ChangePwd

; 147  : 	{
; 148  : 		strcpy (szCFDevice, szDiskFile);

  0008c	33 c0		 xor	 eax, eax
  0008e	8b ff		 npad	 2
$LL67@ChangePwd:
  00090	8a 8c 04 a4 00
	00 00		 mov	 cl, BYTE PTR _szDiskFile$[esp+eax+1460]
  00097	88 8c 04 a8 03
	00 00		 mov	 BYTE PTR _szCFDevice$[esp+eax+1460], cl
  0009e	40		 inc	 eax
  0009f	84 c9		 test	 cl, cl
  000a1	75 ed		 jne	 SHORT $LL67@ChangePwd

; 149  : 	}
; 150  : 	else

  000a3	eb 2d		 jmp	 SHORT $LN60@ChangePwd
$LN62@ChangePwd:

; 151  : 	{
; 152  : 		nDosLinkCreated = FakeDosNameForDevice (szDiskFile, szDosDevice, szCFDevice, FALSE);

  000a5	53		 push	 ebx
  000a6	8d 8c 24 ac 03
	00 00		 lea	 ecx, DWORD PTR _szCFDevice$[esp+1464]
  000ad	51		 push	 ecx
  000ae	8d 94 24 b4 04
	00 00		 lea	 edx, DWORD PTR _szDosDevice$[esp+1468]
  000b5	52		 push	 edx
  000b6	8d 84 24 b0 00
	00 00		 lea	 eax, DWORD PTR _szDiskFile$[esp+1472]
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 _FakeDosNameForDevice
  000c3	83 c4 10	 add	 esp, 16			; 00000010H
  000c6	89 44 24 38	 mov	 DWORD PTR _nDosLinkCreated$[esp+1460], eax

; 153  : 		
; 154  : 		if (nDosLinkCreated != 0)

  000ca	3b c3		 cmp	 eax, ebx
  000cc	0f 85 58 04 00
	00		 jne	 $error$80789
$LN60@ChangePwd:

; 155  : 			goto error;
; 156  : 	}
; 157  : 
; 158  : 	dev = CreateFile (szCFDevice, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);

  000d2	6a 00		 push	 0
  000d4	6a 00		 push	 0
  000d6	6a 03		 push	 3
  000d8	6a 00		 push	 0
  000da	6a 03		 push	 3
  000dc	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  000e1	8d 8c 24 c0 03
	00 00		 lea	 ecx, DWORD PTR _szCFDevice$[esp+1484]
  000e8	51		 push	 ecx
  000e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  000ef	8b d8		 mov	 ebx, eax
  000f1	89 5c 24 18	 mov	 DWORD PTR _dev$[esp+1460], ebx

; 159  : 
; 160  : 	if (dev == INVALID_HANDLE_VALUE) 

  000f5	83 fb ff	 cmp	 ebx, -1
  000f8	0f 84 2c 04 00
	00		 je	 $error$80789

; 161  : 		goto error;
; 162  : 
; 163  : 	if (bDevice)

  000fe	83 7c 24 14 00	 cmp	 DWORD PTR _bDevice$[esp+1460], 0
  00103	0f 84 89 00 00
	00		 je	 $LN58@ChangePwd

; 164  : 	{
; 165  : 		/* This is necessary to determine the hidden volume header offset */
; 166  : 
; 167  : 		if (dev == INVALID_HANDLE_VALUE)
; 168  : 		{
; 169  : 			goto error;
; 170  : 		}
; 171  : 		else
; 172  : 		{
; 173  : 			PARTITION_INFORMATION diskInfo;
; 174  : 			DWORD dwResult;
; 175  : 			BOOL bResult;
; 176  : 
; 177  : 			bResult = DeviceIoControl (dev, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0,
; 178  : 				&driveInfo, sizeof (driveInfo), &dwResult, NULL);

  00109	6a 00		 push	 0
  0010b	8d 94 24 84 00
	00 00		 lea	 edx, DWORD PTR _dwResult$80801[esp+1464]
  00112	52		 push	 edx
  00113	6a 18		 push	 24			; 00000018H
  00115	8d 44 24 5c	 lea	 eax, DWORD PTR _driveInfo$[esp+1472]
  00119	50		 push	 eax
  0011a	6a 00		 push	 0
  0011c	6a 00		 push	 0
  0011e	68 00 00 07 00	 push	 458752			; 00070000H
  00123	53		 push	 ebx
  00124	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32

; 179  : 
; 180  : 			if (!bResult)

  0012a	85 c0		 test	 eax, eax
  0012c	0f 84 f8 03 00
	00		 je	 $error$80789

; 181  : 				goto error;
; 182  : 
; 183  : 			bResult = GetPartitionInfo (lpszVolume, &diskInfo);

  00132	8d 8c 24 84 00
	00 00		 lea	 ecx, DWORD PTR _diskInfo$80800[esp+1460]
  00139	51		 push	 ecx
  0013a	55		 push	 ebp
  0013b	e8 00 00 00 00	 call	 _GetPartitionInfo
  00140	83 c4 08	 add	 esp, 8

; 184  : 
; 185  : 			if (bResult)

  00143	85 c0		 test	 eax, eax
  00145	74 10		 je	 SHORT $LN54@ChangePwd

; 186  : 			{
; 187  : 				hostSize = diskInfo.PartitionLength.QuadPart;

  00147	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR _diskInfo$80800[esp+1468]
  0014e	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR _diskInfo$80800[esp+1472]

; 188  : 			}
; 189  : 			else

  00155	eb 27		 jmp	 SHORT $LN105@ChangePwd
$LN54@ChangePwd:

; 190  : 			{
; 191  : 				hostSize = driveInfo.Cylinders.QuadPart * driveInfo.BytesPerSector *
; 192  : 					driveInfo.SectorsPerTrack * driveInfo.TracksPerCylinder;

  00157	8b 44 24 5c	 mov	 eax, DWORD PTR _driveInfo$[esp+1472]
  0015b	f7 64 24 60	 mul	 DWORD PTR _driveInfo$[esp+1476]
  0015f	8b 4c 24 64	 mov	 ecx, DWORD PTR _driveInfo$[esp+1480]
  00163	6a 00		 push	 0
  00165	51		 push	 ecx
  00166	52		 push	 edx
  00167	50		 push	 eax
  00168	e8 00 00 00 00	 call	 __allmul
  0016d	8b 4c 24 54	 mov	 ecx, DWORD PTR _driveInfo$[esp+1464]
  00171	51		 push	 ecx
  00172	8b 4c 24 54	 mov	 ecx, DWORD PTR _driveInfo$[esp+1464]
  00176	51		 push	 ecx
  00177	52		 push	 edx
  00178	50		 push	 eax
  00179	e8 00 00 00 00	 call	 __allmul
$LN105@ChangePwd:
  0017e	89 44 24 1c	 mov	 DWORD PTR _hostSize$[esp+1460], eax

; 193  : 			}
; 194  : 
; 195  : 			if (hostSize == 0)

  00182	0b c2		 or	 eax, edx
  00184	89 54 24 20	 mov	 DWORD PTR _hostSize$[esp+1464], edx
  00188	75 2c		 jne	 SHORT $LN51@ChangePwd

; 196  : 			{
; 197  : 				nStatus = ERR_VOL_SIZE_WRONG;

  0018a	8d 70 07	 lea	 esi, DWORD PTR [eax+7]

; 198  : 				goto error;

  0018d	e9 98 03 00 00	 jmp	 $error$80789
$LN58@ChangePwd:

; 199  : 			}
; 200  : 		}
; 201  : 	}
; 202  : 	else
; 203  : 	{
; 204  : 		LARGE_INTEGER fileSize;
; 205  : 		if (!GetFileSizeEx (dev, &fileSize))

  00192	8d 54 24 48	 lea	 edx, DWORD PTR _fileSize$80810[esp+1460]
  00196	52		 push	 edx
  00197	53		 push	 ebx
  00198	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileSizeEx@8
  0019e	85 c0		 test	 eax, eax

; 206  : 		{
; 207  : 			nStatus = ERR_OS_ERROR;
; 208  : 			goto error;

  001a0	0f 84 84 03 00
	00		 je	 $error$80789

; 209  : 		}
; 210  : 
; 211  : 		hostSize = fileSize.QuadPart;

  001a6	8b 44 24 48	 mov	 eax, DWORD PTR _fileSize$80810[esp+1460]
  001aa	8b 4c 24 4c	 mov	 ecx, DWORD PTR _fileSize$80810[esp+1464]
  001ae	89 44 24 1c	 mov	 DWORD PTR _hostSize$[esp+1460], eax
  001b2	89 4c 24 20	 mov	 DWORD PTR _hostSize$[esp+1464], ecx
$LN51@ChangePwd:

; 212  : 	}
; 213  : 
; 214  : 	if (Randinit ())

  001b6	e8 00 00 00 00	 call	 _Randinit
  001bb	85 c0		 test	 eax, eax
  001bd	0f 85 67 03 00
	00		 jne	 $error$80789

; 215  : 		goto error;
; 216  : 
; 217  : 	if (!bDevice && bPreserveTimestamp)

  001c3	39 44 24 14	 cmp	 DWORD PTR _bDevice$[esp+1460], eax
  001c7	75 28		 jne	 SHORT $LN47@ChangePwd
  001c9	39 05 00 00 00
	00		 cmp	 DWORD PTR _bPreserveTimestamp, eax
  001cf	74 20		 je	 SHORT $LN47@ChangePwd

; 218  : 	{
; 219  : 		if (GetFileTime ((HANDLE) dev, &ftCreationTime, &ftLastAccessTime, &ftLastWriteTime) == 0)

  001d1	8d 54 24 78	 lea	 edx, DWORD PTR _ftLastWriteTime$[esp+1460]
  001d5	52		 push	 edx
  001d6	8d 44 24 6c	 lea	 eax, DWORD PTR _ftLastAccessTime$[esp+1464]
  001da	50		 push	 eax
  001db	8d 4c 24 78	 lea	 ecx, DWORD PTR _ftCreationTime$[esp+1468]
  001df	51		 push	 ecx
  001e0	53		 push	 ebx
  001e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileTime@16
  001e7	f7 d8		 neg	 eax
  001e9	1b c0		 sbb	 eax, eax
  001eb	f7 d8		 neg	 eax
  001ed	89 44 24 3c	 mov	 DWORD PTR _bTimeStampValid$[esp+1460], eax
$LN47@ChangePwd:

; 220  : 			bTimeStampValid = FALSE;
; 221  : 		else
; 222  : 			bTimeStampValid = TRUE;
; 223  : 	}
; 224  : 
; 225  : 	for (volumeType = TC_VOLUME_TYPE_NORMAL; volumeType < TC_VOLUME_TYPE_COUNT; volumeType++)

  001f1	8b 6c 24 28	 mov	 ebp, DWORD PTR _headerOffset$[esp+1464]
  001f5	8b 5c 24 24	 mov	 ebx, DWORD PTR _headerOffset$[esp+1460]
  001f9	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR _volumeType$[esp+1460], 0
$LL45@ChangePwd:

; 226  : 	{
; 227  : 		// Seek the volume header
; 228  : 		switch (volumeType)

  00201	8b 44 24 2c	 mov	 eax, DWORD PTR _volumeType$[esp+1460]
  00205	83 e8 00	 sub	 eax, 0
  00208	74 53		 je	 SHORT $LN40@ChangePwd
  0020a	83 e8 01	 sub	 eax, 1
  0020d	74 2c		 je	 SHORT $LN39@ChangePwd
  0020f	83 e8 01	 sub	 eax, 1
  00212	75 4d		 jne	 SHORT $LN41@ChangePwd

; 240  : 
; 241  : 		case TC_VOLUME_TYPE_HIDDEN_LEGACY:
; 242  : 			if (bDevice && driveInfo.BytesPerSector != TC_SECTOR_SIZE_LEGACY)

  00214	39 44 24 14	 cmp	 DWORD PTR _bDevice$[esp+1460], eax
  00218	74 0e		 je	 SHORT $LN36@ChangePwd
  0021a	81 7c 24 64 00
	02 00 00	 cmp	 DWORD PTR _driveInfo$[esp+1480], 512 ; 00000200H
  00222	0f 85 b8 00 00
	00		 jne	 $LN44@ChangePwd
$LN36@ChangePwd:

; 243  : 				continue;
; 244  : 
; 245  : 			headerOffset.QuadPart = hostSize - TC_HIDDEN_VOLUME_HEADER_OFFSET_LEGACY;

  00228	8b 5c 24 1c	 mov	 ebx, DWORD PTR _hostSize$[esp+1460]
  0022c	8b 6c 24 20	 mov	 ebp, DWORD PTR _hostSize$[esp+1464]
  00230	81 eb 00 06 00
	00		 sub	 ebx, 1536		; 00000600H
  00236	83 dd 00	 sbb	 ebp, 0

; 246  : 			break;

  00239	eb 26		 jmp	 SHORT $LN41@ChangePwd
$LN39@ChangePwd:

; 232  : 			break;
; 233  : 
; 234  : 		case TC_VOLUME_TYPE_HIDDEN:
; 235  : 			if (TC_HIDDEN_VOLUME_HEADER_OFFSET + TC_VOLUME_HEADER_SIZE > hostSize)

  0023b	83 7c 24 20 00	 cmp	 DWORD PTR _hostSize$[esp+1464], 0
  00240	0f 82 9a 00 00
	00		 jb	 $LN44@ChangePwd
  00246	77 0e		 ja	 SHORT $LN98@ChangePwd
  00248	81 7c 24 1c 00
	00 02 00	 cmp	 DWORD PTR _hostSize$[esp+1460], 131072 ; 00020000H
  00250	0f 82 8a 00 00
	00		 jb	 $LN44@ChangePwd
$LN98@ChangePwd:

; 236  : 				continue;
; 237  : 
; 238  : 			headerOffset.QuadPart = TC_HIDDEN_VOLUME_HEADER_OFFSET;

  00256	bb 00 00 01 00	 mov	 ebx, 65536		; 00010000H

; 239  : 			break;

  0025b	eb 02		 jmp	 SHORT $LN106@ChangePwd
$LN40@ChangePwd:

; 229  : 		{
; 230  : 		case TC_VOLUME_TYPE_NORMAL:
; 231  : 			headerOffset.QuadPart = TC_VOLUME_HEADER_OFFSET;

  0025d	33 db		 xor	 ebx, ebx
$LN106@ChangePwd:
  0025f	33 ed		 xor	 ebp, ebp
$LN41@ChangePwd:

; 247  : 		}
; 248  : 
; 249  : 		if (!SetFilePointerEx ((HANDLE) dev, headerOffset, NULL, FILE_BEGIN))

  00261	8b 74 24 18	 mov	 esi, DWORD PTR _dev$[esp+1460]
  00265	6a 00		 push	 0
  00267	6a 00		 push	 0
  00269	55		 push	 ebp
  0026a	53		 push	 ebx
  0026b	56		 push	 esi
  0026c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  00272	85 c0		 test	 eax, eax
  00274	0f 84 8d 00 00
	00		 je	 $LN80@ChangePwd

; 253  : 		}
; 254  : 
; 255  : 		/* Read in volume header */
; 256  : 		if (!ReadEffectiveVolumeHeader (bDevice, dev, buffer, &bytesRead))

  0027a	8b 4c 24 14	 mov	 ecx, DWORD PTR _bDevice$[esp+1460]
  0027e	8d 54 24 44	 lea	 edx, DWORD PTR _bytesRead$[esp+1460]
  00282	52		 push	 edx
  00283	8d 84 24 ac 01
	00 00		 lea	 eax, DWORD PTR _buffer$[esp+1464]
  0028a	50		 push	 eax
  0028b	56		 push	 esi
  0028c	51		 push	 ecx
  0028d	e8 00 00 00 00	 call	 _ReadEffectiveVolumeHeader
  00292	83 c4 10	 add	 esp, 16			; 00000010H
  00295	85 c0		 test	 eax, eax
  00297	74 6e		 je	 SHORT $LN80@ChangePwd

; 257  : 		{
; 258  : 			nStatus = ERR_OS_ERROR;
; 259  : 			goto error;
; 260  : 		}
; 261  : 
; 262  : 		if (bytesRead != sizeof (buffer))

  00299	81 7c 24 44 00
	02 00 00	 cmp	 DWORD PTR _bytesRead$[esp+1460], 512 ; 00000200H
  002a1	74 17		 je	 SHORT $LN33@ChangePwd

; 263  : 		{
; 264  : 			// Windows may report EOF when reading sectors from the last cluster of a device formatted as NTFS 
; 265  : 			memset (buffer, 0, sizeof (buffer));

  002a3	68 00 02 00 00	 push	 512			; 00000200H
  002a8	8d 94 24 ac 01
	00 00		 lea	 edx, DWORD PTR _buffer$[esp+1464]
  002af	6a 00		 push	 0
  002b1	52		 push	 edx
  002b2	e8 00 00 00 00	 call	 _memset
  002b7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN33@ChangePwd:

; 266  : 		}
; 267  : 
; 268  : 		/* Try to decrypt the header */
; 269  : 
; 270  : 		nStatus = ReadVolumeHeader (FALSE, buffer, oldPassword, &cryptoInfo, NULL);

  002ba	6a 00		 push	 0
  002bc	8d 44 24 14	 lea	 eax, DWORD PTR _cryptoInfo$[esp+1464]
  002c0	50		 push	 eax
  002c1	57		 push	 edi
  002c2	8d 8c 24 b4 01
	00 00		 lea	 ecx, DWORD PTR _buffer$[esp+1472]
  002c9	51		 push	 ecx
  002ca	6a 00		 push	 0
  002cc	e8 00 00 00 00	 call	 _ReadVolumeHeader
  002d1	8b f0		 mov	 esi, eax
  002d3	83 c4 14	 add	 esp, 20			; 00000014H

; 271  : 		if (nStatus == ERR_CIPHER_INIT_WEAK_KEY)

  002d6	83 fe 12	 cmp	 esi, 18			; 00000012H
  002d9	74 3a		 je	 SHORT $LN102@ChangePwd

; 272  : 			nStatus = 0;	// We can ignore this error here
; 273  : 
; 274  : 		if (nStatus == ERR_PASSWORD_WRONG)

  002db	83 fe 03	 cmp	 esi, 3
  002de	75 12		 jne	 SHORT $LN31@ChangePwd
$LN44@ChangePwd:

; 220  : 			bTimeStampValid = FALSE;
; 221  : 		else
; 222  : 			bTimeStampValid = TRUE;
; 223  : 	}
; 224  : 
; 225  : 	for (volumeType = TC_VOLUME_TYPE_NORMAL; volumeType < TC_VOLUME_TYPE_COUNT; volumeType++)

  002e0	8b 44 24 2c	 mov	 eax, DWORD PTR _volumeType$[esp+1460]
  002e4	40		 inc	 eax
  002e5	83 f8 03	 cmp	 eax, 3
  002e8	89 44 24 2c	 mov	 DWORD PTR _volumeType$[esp+1460], eax
  002ec	0f 8c 0f ff ff
	ff		 jl	 $LL45@ChangePwd
$LN31@ChangePwd:

; 243  : 				continue;
; 244  : 
; 245  : 			headerOffset.QuadPart = hostSize - TC_HIDDEN_VOLUME_HEADER_OFFSET_LEGACY;

  002f2	89 6c 24 28	 mov	 DWORD PTR _headerOffset$[esp+1464], ebp

; 275  : 		{
; 276  : 			continue;		// Try next volume type
; 277  : 		}
; 278  : 		else if (nStatus != 0)

  002f6	85 f6		 test	 esi, esi
  002f8	74 1f		 je	 SHORT $LN27@ChangePwd

; 279  : 		{
; 280  : 			cryptoInfo = NULL;

  002fa	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _cryptoInfo$[esp+1460], 0

; 281  : 			goto error;

  00302	e9 23 02 00 00	 jmp	 $error$80789
$LN80@ChangePwd:

; 243  : 				continue;
; 244  : 
; 245  : 			headerOffset.QuadPart = hostSize - TC_HIDDEN_VOLUME_HEADER_OFFSET_LEGACY;

  00307	89 6c 24 28	 mov	 DWORD PTR _headerOffset$[esp+1464], ebp
$LN83@ChangePwd:

; 250  : 		{
; 251  : 			nStatus = ERR_OS_ERROR;

  0030b	be 01 00 00 00	 mov	 esi, 1

; 252  : 			goto error;

  00310	e9 15 02 00 00	 jmp	 $error$80789
$LN102@ChangePwd:

; 243  : 				continue;
; 244  : 
; 245  : 			headerOffset.QuadPart = hostSize - TC_HIDDEN_VOLUME_HEADER_OFFSET_LEGACY;

  00315	89 6c 24 28	 mov	 DWORD PTR _headerOffset$[esp+1464], ebp
$LN27@ChangePwd:

; 282  : 		}
; 283  : 		else 
; 284  : 			break;
; 285  : 	}
; 286  : 
; 287  : 	if (nStatus != 0)
; 288  : 	{
; 289  : 		cryptoInfo = NULL;
; 290  : 		goto error;
; 291  : 	}
; 292  : 
; 293  : 	if (cryptoInfo->HeaderFlags & TC_HEADER_FLAG_ENCRYPTED_SYSTEM)

  00319	8b 44 24 10	 mov	 eax, DWORD PTR _cryptoInfo$[esp+1460]
  0031d	f6 80 60 44 00
	00 01		 test	 BYTE PTR [eax+17504], 1
  00324	74 0a		 je	 SHORT $LN26@ChangePwd

; 294  : 	{
; 295  : 		nStatus = ERR_SYS_HIDVOL_HEAD_REENC_MODE_WRONG;

  00326	be 1f 00 00 00	 mov	 esi, 31			; 0000001fH

; 296  : 		goto error;

  0032b	e9 fa 01 00 00	 jmp	 $error$80789
$LN26@ChangePwd:

; 297  : 	}
; 298  : 
; 299  : 	// Change the PKCS-5 PRF if requested by user
; 300  : 	if (pkcs5 != 0)

  00330	8b 8c 24 c4 05
	00 00		 mov	 ecx, DWORD PTR _pkcs5$[esp+1456]
  00337	85 c9		 test	 ecx, ecx
  00339	74 0a		 je	 SHORT $LN25@ChangePwd

; 301  : 		cryptoInfo->pkcs5 = pkcs5;

  0033b	89 88 ec 43 00
	00		 mov	 DWORD PTR [eax+17388], ecx
  00341	8b 44 24 10	 mov	 eax, DWORD PTR _cryptoInfo$[esp+1460]
$LN25@ChangePwd:

; 302  : 
; 303  : 	RandSetHashFunction (cryptoInfo->pkcs5);

  00345	8b 90 ec 43 00
	00		 mov	 edx, DWORD PTR [eax+17388]
  0034b	52		 push	 edx
  0034c	e8 00 00 00 00	 call	 _RandSetHashFunction

; 304  : 
; 305  : 	NormalCursor();

  00351	e8 00 00 00 00	 call	 _NormalCursor

; 306  : 	UserEnrichRandomPool (hwndDlg);

  00356	8b 74 24 34	 mov	 esi, DWORD PTR _hwndDlg$GSCopy$[esp+1464]
  0035a	56		 push	 esi
  0035b	e8 00 00 00 00	 call	 _UserEnrichRandomPool

; 307  : 	EnableElevatedCursorChange (hwndDlg);

  00360	56		 push	 esi
  00361	e8 00 00 00 00	 call	 _EnableElevatedCursorChange
  00366	83 c4 0c	 add	 esp, 12			; 0000000cH

; 308  : 	WaitCursor();

  00369	e8 00 00 00 00	 call	 _WaitCursor

; 309  : 
; 310  : 	/* Re-encrypt the volume header */ 
; 311  : 	backupHeader = FALSE;

  0036e	8b 44 24 10	 mov	 eax, DWORD PTR _cryptoInfo$[esp+1460]
  00372	33 ff		 xor	 edi, edi

; 312  : 
; 313  : 	while (TRUE)
; 314  : 	{
; 315  : 		/* The header will be re-encrypted PRAND_DISK_WIPE_PASSES times to prevent adversaries from using 
; 316  : 		techniques such as magnetic force microscopy or magnetic force scanning tunnelling microscopy
; 317  : 		to recover the overwritten header. According to Peter Gutmann, data should be overwritten 22
; 318  : 		times (ideally, 35 times) using non-random patterns and pseudorandom data. However, as users might
; 319  : 		impatiently interupt the process (etc.) we will not use the Gutmann's patterns but will write the
; 320  : 		valid re-encrypted header, i.e. pseudorandom data, and there will be many more passes than Guttman
; 321  : 		recommends. During each pass we will write a valid working header. Each pass will use the same master
; 322  : 		key, and also the same header key, secondary key (XTS), etc., derived from the new password. The only
; 323  : 		item that will be different for each pass will be the salt. This is sufficient to cause each "version"
; 324  : 		of the header to differ substantially and in a random manner from the versions written during the
; 325  : 		other passes. */
; 326  : 
; 327  : 		for (wipePass = 0; wipePass < PRAND_DISK_WIPE_PASSES; wipePass++)

  00374	33 ed		 xor	 ebp, ebp
  00376	eb 0c		 jmp	 SHORT $LN22@ChangePwd
  00378	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL100@ChangePwd:
  00380	8b 44 24 10	 mov	 eax, DWORD PTR _cryptoInfo$[esp+1460]
$LN22@ChangePwd:

; 328  : 		{
; 329  : 			// Prepare new volume header
; 330  : 			nStatus = CreateVolumeHeaderInMemory (FALSE,
; 331  : 				buffer,
; 332  : 				cryptoInfo->ea,
; 333  : 				cryptoInfo->mode,
; 334  : 				newPassword,
; 335  : 				cryptoInfo->pkcs5,
; 336  : 				cryptoInfo->master_keydata,
; 337  : 				&ci,
; 338  : 				cryptoInfo->VolumeSize.Value,
; 339  : 				(volumeType == TC_VOLUME_TYPE_HIDDEN || volumeType == TC_VOLUME_TYPE_HIDDEN_LEGACY) ? cryptoInfo->hiddenVolumeSize : 0,
; 340  : 				cryptoInfo->EncryptedAreaStart.Value,
; 341  : 				cryptoInfo->EncryptedAreaLength.Value,
; 342  : 				cryptoInfo->RequiredProgramVersion,
; 343  : 				cryptoInfo->HeaderFlags,
; 344  : 				cryptoInfo->SectorSize,
; 345  : 				wipePass < PRAND_DISK_WIPE_PASSES - 1);

  00384	8b 4c 24 2c	 mov	 ecx, DWORD PTR _volumeType$[esp+1460]
  00388	83 f9 01	 cmp	 ecx, 1
  0038b	74 0b		 je	 SHORT $LN68@ChangePwd
  0038d	83 f9 02	 cmp	 ecx, 2
  00390	74 06		 je	 SHORT $LN68@ChangePwd
  00392	33 c9		 xor	 ecx, ecx
  00394	33 f6		 xor	 esi, esi
  00396	eb 0c		 jmp	 SHORT $LN69@ChangePwd
$LN68@ChangePwd:
  00398	8b 88 10 44 00
	00		 mov	 ecx, DWORD PTR [eax+17424]
  0039e	8b b0 14 44 00
	00		 mov	 esi, DWORD PTR [eax+17428]
$LN69@ChangePwd:
  003a4	33 d2		 xor	 edx, edx
  003a6	81 fd ff 00 00
	00		 cmp	 ebp, 255		; 000000ffH
  003ac	0f 9c c2	 setl	 dl
  003af	52		 push	 edx
  003b0	8b 90 40 44 00
	00		 mov	 edx, DWORD PTR [eax+17472]
  003b6	52		 push	 edx
  003b7	8b 90 60 44 00
	00		 mov	 edx, DWORD PTR [eax+17504]
  003bd	52		 push	 edx
  003be	0f b7 90 38 44
	00 00		 movzx	 edx, WORD PTR [eax+17464]
  003c5	52		 push	 edx
  003c6	8b 90 5c 44 00
	00		 mov	 edx, DWORD PTR [eax+17500]
  003cc	52		 push	 edx
  003cd	8b 90 58 44 00
	00		 mov	 edx, DWORD PTR [eax+17496]
  003d3	52		 push	 edx
  003d4	8b 90 54 44 00
	00		 mov	 edx, DWORD PTR [eax+17492]
  003da	52		 push	 edx
  003db	8b 90 50 44 00
	00		 mov	 edx, DWORD PTR [eax+17488]
  003e1	52		 push	 edx
  003e2	8b 90 48 44 00
	00		 mov	 edx, DWORD PTR [eax+17480]
  003e8	56		 push	 esi
  003e9	51		 push	 ecx
  003ea	8b 88 4c 44 00
	00		 mov	 ecx, DWORD PTR [eax+17484]
  003f0	51		 push	 ecx
  003f1	52		 push	 edx
  003f2	8d 4c 24 64	 lea	 ecx, DWORD PTR _ci$[esp+1508]
  003f6	51		 push	 ecx
  003f7	8b 88 ec 43 00
	00		 mov	 ecx, DWORD PTR [eax+17388]
  003fd	8d 90 a8 41 00
	00		 lea	 edx, DWORD PTR [eax+16808]
  00403	52		 push	 edx
  00404	8b 54 24 78	 mov	 edx, DWORD PTR _newPassword$GSCopy$[esp+1516]
  00408	51		 push	 ecx
  00409	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0040c	52		 push	 edx
  0040d	8b 10		 mov	 edx, DWORD PTR [eax]
  0040f	51		 push	 ecx
  00410	52		 push	 edx
  00411	8d 84 24 f0 01
	00 00		 lea	 eax, DWORD PTR _buffer$[esp+1532]
  00418	50		 push	 eax
  00419	6a 00		 push	 0
  0041b	e8 00 00 00 00	 call	 _CreateVolumeHeaderInMemory
  00420	8b f0		 mov	 esi, eax

; 346  : 
; 347  : 			if (ci != NULL)

  00422	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR _ci$[esp+1540]
  00429	83 c4 50	 add	 esp, 80			; 00000050H
  0042c	85 c0		 test	 eax, eax
  0042e	74 09		 je	 SHORT $LN19@ChangePwd

; 348  : 				crypto_close (ci);

  00430	50		 push	 eax
  00431	e8 00 00 00 00	 call	 _crypto_close
  00436	83 c4 04	 add	 esp, 4
$LN19@ChangePwd:

; 349  : 
; 350  : 			if (nStatus != 0)

  00439	85 f6		 test	 esi, esi
  0043b	0f 85 e9 00 00
	00		 jne	 $error$80789

; 351  : 				goto error;
; 352  : 
; 353  : 			if (!SetFilePointerEx ((HANDLE) dev, headerOffset, NULL, FILE_BEGIN))

  00441	8b 4c 24 28	 mov	 ecx, DWORD PTR _headerOffset$[esp+1464]
  00445	56		 push	 esi
  00446	56		 push	 esi
  00447	8b 74 24 20	 mov	 esi, DWORD PTR _dev$[esp+1468]
  0044b	51		 push	 ecx
  0044c	53		 push	 ebx
  0044d	56		 push	 esi
  0044e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  00454	85 c0		 test	 eax, eax
  00456	0f 84 af fe ff
	ff		 je	 $LN83@ChangePwd

; 354  : 			{
; 355  : 				nStatus = ERR_OS_ERROR;
; 356  : 				goto error;
; 357  : 			}
; 358  : 
; 359  : 			if (!WriteEffectiveVolumeHeader (bDevice, dev, buffer))

  0045c	8b 44 24 14	 mov	 eax, DWORD PTR _bDevice$[esp+1460]
  00460	8d 94 24 a8 01
	00 00		 lea	 edx, DWORD PTR _buffer$[esp+1460]
  00467	52		 push	 edx
  00468	56		 push	 esi
  00469	50		 push	 eax
  0046a	e8 00 00 00 00	 call	 _WriteEffectiveVolumeHeader
  0046f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00472	85 c0		 test	 eax, eax
  00474	0f 84 91 fe ff
	ff		 je	 $LN83@ChangePwd

; 360  : 			{
; 361  : 				nStatus = ERR_OS_ERROR;
; 362  : 				goto error;
; 363  : 			}
; 364  : 
; 365  : 			if (bDevice
; 366  : 				&& !cryptoInfo->LegacyVolume
; 367  : 				&& !cryptoInfo->hiddenVolume
; 368  : 				&& cryptoInfo->HeaderVersion == 4
; 369  : 				&& (cryptoInfo->HeaderFlags & TC_HEADER_FLAG_NONSYS_INPLACE_ENC) != 0
; 370  : 				&& (cryptoInfo->HeaderFlags & ~TC_HEADER_FLAG_NONSYS_INPLACE_ENC) == 0)

  0047a	83 7c 24 14 00	 cmp	 DWORD PTR _bDevice$[esp+1460], 0
  0047f	74 60		 je	 SHORT $LN14@ChangePwd
  00481	8b 44 24 10	 mov	 eax, DWORD PTR _cryptoInfo$[esp+1460]
  00485	83 b8 3c 44 00
	00 00		 cmp	 DWORD PTR [eax+17468], 0
  0048c	75 53		 jne	 SHORT $LN14@ChangePwd
  0048e	83 b8 a0 29 00
	00 00		 cmp	 DWORD PTR [eax+10656], 0
  00495	75 4a		 jne	 SHORT $LN14@ChangePwd
  00497	66 83 b8 a4 29
	00 00 04	 cmp	 WORD PTR [eax+10660], 4
  0049f	75 40		 jne	 SHORT $LN14@ChangePwd
  004a1	8b 88 60 44 00
	00		 mov	 ecx, DWORD PTR [eax+17504]
  004a7	f6 c1 02	 test	 cl, 2
  004aa	74 35		 je	 SHORT $LN14@ChangePwd
  004ac	f7 c1 fd ff ff
	ff		 test	 ecx, -3			; fffffffdH
  004b2	75 2d		 jne	 SHORT $LN14@ChangePwd

; 371  : 			{
; 372  : 				nStatus = WriteRandomDataToReservedHeaderAreas (dev, cryptoInfo, cryptoInfo->VolumeSize.Value, !backupHeader, backupHeader);

  004b4	8b 90 4c 44 00
	00		 mov	 edx, DWORD PTR [eax+17484]
  004ba	33 c9		 xor	 ecx, ecx
  004bc	85 ff		 test	 edi, edi
  004be	0f 94 c1	 sete	 cl
  004c1	57		 push	 edi
  004c2	51		 push	 ecx
  004c3	8b 88 48 44 00
	00		 mov	 ecx, DWORD PTR [eax+17480]
  004c9	52		 push	 edx
  004ca	51		 push	 ecx
  004cb	50		 push	 eax
  004cc	8b d6		 mov	 edx, esi
  004ce	52		 push	 edx
  004cf	e8 00 00 00 00	 call	 _WriteRandomDataToReservedHeaderAreas
  004d4	8b f0		 mov	 esi, eax
  004d6	83 c4 18	 add	 esp, 24			; 00000018H

; 373  : 				if (nStatus != ERR_SUCCESS)

  004d9	85 f6		 test	 esi, esi
  004db	75 4d		 jne	 SHORT $error$80789
  004dd	8b 74 24 18	 mov	 esi, DWORD PTR _dev$[esp+1460]
$LN14@ChangePwd:

; 374  : 					goto error;
; 375  : 			}
; 376  : 
; 377  : 			FlushFileBuffers (dev);

  004e1	56		 push	 esi
  004e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FlushFileBuffers@4
  004e8	45		 inc	 ebp
  004e9	81 fd 00 01 00
	00		 cmp	 ebp, 256		; 00000100H
  004ef	0f 8c 8b fe ff
	ff		 jl	 $LL100@ChangePwd

; 378  : 		}
; 379  : 
; 380  : 		if (backupHeader || cryptoInfo->LegacyVolume)

  004f5	85 ff		 test	 edi, edi
  004f7	75 2f		 jne	 SHORT $LN86@ChangePwd
  004f9	8b 44 24 10	 mov	 eax, DWORD PTR _cryptoInfo$[esp+1460]
  004fd	39 b8 3c 44 00
	00		 cmp	 DWORD PTR [eax+17468], edi
  00503	75 23		 jne	 SHORT $LN86@ChangePwd

; 381  : 			break;
; 382  : 			
; 383  : 		backupHeader = TRUE;
; 384  : 		headerOffset.QuadPart += hostSize - TC_VOLUME_HEADER_GROUP_SIZE;

  00505	8b 4c 24 1c	 mov	 ecx, DWORD PTR _hostSize$[esp+1460]
  00509	8b 54 24 20	 mov	 edx, DWORD PTR _hostSize$[esp+1464]
  0050d	81 e9 00 00 02
	00		 sub	 ecx, 131072		; 00020000H
  00513	83 da 00	 sbb	 edx, 0
  00516	03 d9		 add	 ebx, ecx
  00518	11 54 24 28	 adc	 DWORD PTR _headerOffset$[esp+1464], edx
  0051c	bf 01 00 00 00	 mov	 edi, 1
  00521	33 ed		 xor	 ebp, ebp
  00523	e9 5c fe ff ff	 jmp	 $LN22@ChangePwd
$LN86@ChangePwd:

; 385  : 	}
; 386  : 
; 387  : 	/* Password successfully changed */
; 388  : 	nStatus = 0;

  00528	33 f6		 xor	 esi, esi
$error$80789:

; 389  : 
; 390  : error:
; 391  : 	dwError = GetLastError ();

  0052a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 392  : 
; 393  : 	burn (buffer, sizeof (buffer));

  00530	8d 94 24 a8 01
	00 00		 lea	 edx, DWORD PTR _buffer$[esp+1460]
  00537	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0053c	8b e8		 mov	 ebp, eax
  0053e	8b f9		 mov	 edi, ecx
  00540	8b c2		 mov	 eax, edx
$LL71@ChangePwd:
  00542	c6 00 00	 mov	 BYTE PTR [eax], 0
  00545	40		 inc	 eax
  00546	83 ef 01	 sub	 edi, 1
  00549	75 f7		 jne	 SHORT $LL71@ChangePwd
  0054b	eb 03 8d 49 00	 npad	 5
$LL8@ChangePwd:
  00550	49		 dec	 ecx
  00551	c6 02 00	 mov	 BYTE PTR [edx], 0
  00554	42		 inc	 edx
  00555	85 c9		 test	 ecx, ecx
  00557	75 f7		 jne	 SHORT $LL8@ChangePwd

; 394  : 
; 395  : 	if (cryptoInfo != NULL)

  00559	8b 44 24 10	 mov	 eax, DWORD PTR _cryptoInfo$[esp+1460]
  0055d	85 c0		 test	 eax, eax
  0055f	74 09		 je	 SHORT $LN6@ChangePwd

; 396  : 		crypto_close (cryptoInfo);

  00561	50		 push	 eax
  00562	e8 00 00 00 00	 call	 _crypto_close
  00567	83 c4 04	 add	 esp, 4
$LN6@ChangePwd:

; 397  : 
; 398  : 	if (bTimeStampValid)

  0056a	83 7c 24 3c 00	 cmp	 DWORD PTR _bTimeStampValid$[esp+1460], 0

; 399  : 		SetFileTime (dev, &ftCreationTime, &ftLastAccessTime, &ftLastWriteTime);

  0056f	8b 7c 24 18	 mov	 edi, DWORD PTR _dev$[esp+1460]
  00573	74 16		 je	 SHORT $LN5@ChangePwd
  00575	8d 44 24 78	 lea	 eax, DWORD PTR _ftLastWriteTime$[esp+1460]
  00579	50		 push	 eax
  0057a	8d 4c 24 6c	 lea	 ecx, DWORD PTR _ftLastAccessTime$[esp+1464]
  0057e	51		 push	 ecx
  0057f	8d 54 24 78	 lea	 edx, DWORD PTR _ftCreationTime$[esp+1468]
  00583	52		 push	 edx
  00584	57		 push	 edi
  00585	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFileTime@16
$LN5@ChangePwd:

; 400  : 
; 401  : 	if (dev != INVALID_HANDLE_VALUE)

  0058b	83 ff ff	 cmp	 edi, -1
  0058e	74 07		 je	 SHORT $LN4@ChangePwd

; 402  : 		CloseHandle ((HANDLE) dev);

  00590	57		 push	 edi
  00591	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN4@ChangePwd:

; 403  : 
; 404  : 	if (nDosLinkCreated == 0)

  00597	83 7c 24 38 00	 cmp	 DWORD PTR _nDosLinkCreated$[esp+1460], 0
  0059c	75 18		 jne	 SHORT $LN3@ChangePwd

; 405  : 		RemoveFakeDosName (szDiskFile, szDosDevice);

  0059e	8d 84 24 ac 04
	00 00		 lea	 eax, DWORD PTR _szDosDevice$[esp+1460]
  005a5	50		 push	 eax
  005a6	8d 8c 24 a8 00
	00 00		 lea	 ecx, DWORD PTR _szDiskFile$[esp+1464]
  005ad	51		 push	 ecx
  005ae	e8 00 00 00 00	 call	 _RemoveFakeDosName
  005b3	83 c4 08	 add	 esp, 8
$LN3@ChangePwd:

; 406  : 
; 407  : 	RandStop (FALSE);

  005b6	6a 00		 push	 0
  005b8	e8 00 00 00 00	 call	 _RandStop
  005bd	83 c4 04	 add	 esp, 4

; 408  : 	NormalCursor ();

  005c0	e8 00 00 00 00	 call	 _NormalCursor

; 409  : 
; 410  : 	SetLastError (dwError);

  005c5	55		 push	 ebp
  005c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 411  : 
; 412  : 	if (nStatus == ERR_OS_ERROR && dwError == ERROR_ACCESS_DENIED
; 413  : 		&& bDevice
; 414  : 		&& !UacElevated
; 415  : 		&& IsUacSupported ())

  005cc	83 fe 01	 cmp	 esi, 1
  005cf	75 22		 jne	 SHORT $LN2@ChangePwd
  005d1	83 fd 05	 cmp	 ebp, 5
  005d4	75 21		 jne	 SHORT $LN93@ChangePwd
  005d6	83 7c 24 14 00	 cmp	 DWORD PTR _bDevice$[esp+1460], 0
  005db	74 1a		 je	 SHORT $LN93@ChangePwd
  005dd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _UacElevated, 0
  005e4	75 11		 jne	 SHORT $LN93@ChangePwd
  005e6	e8 00 00 00 00	 call	 _IsUacSupported
  005eb	85 c0		 test	 eax, eax
  005ed	74 08		 je	 SHORT $LN93@ChangePwd

; 416  : 		return nStatus;

  005ef	8b c6		 mov	 eax, esi
  005f1	eb 19		 jmp	 SHORT $LN65@ChangePwd
$LN2@ChangePwd:

; 417  : 
; 418  : 	if (nStatus != 0)

  005f3	85 f6		 test	 esi, esi
  005f5	74 0e		 je	 SHORT $LN1@ChangePwd
$LN93@ChangePwd:

; 419  : 		handleError (hwndDlg, nStatus);

  005f7	8b 54 24 30	 mov	 edx, DWORD PTR _hwndDlg$GSCopy$[esp+1460]
  005fb	56		 push	 esi
  005fc	52		 push	 edx
  005fd	e8 00 00 00 00	 call	 _handleError
  00602	83 c4 08	 add	 esp, 8
$LN1@ChangePwd:

; 420  : 
; 421  : 	return nStatus;

  00605	8b c6		 mov	 eax, esi
  00607	eb 03		 jmp	 SHORT $LN65@ChangePwd
$LN63@ChangePwd:

; 136  : 	LARGE_INTEGER headerOffset;
; 137  : 	BOOL backupHeader;
; 138  : 	DISK_GEOMETRY driveInfo;
; 139  : 
; 140  : 	if (oldPassword->Length == 0 || newPassword->Length == 0) return -1;

  00609	83 c8 ff	 or	 eax, -1
$LN65@ChangePwd:

; 422  : }

  0060c	8b 8c 24 b0 05
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1460]
  00613	5f		 pop	 edi
  00614	5e		 pop	 esi
  00615	5d		 pop	 ebp
  00616	5b		 pop	 ebx
  00617	33 cc		 xor	 ecx, esp
  00619	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0061e	81 c4 a4 05 00
	00		 add	 esp, 1444		; 000005a4H
  00624	c3		 ret	 0
_ChangePwd ENDP
_TEXT	ENDS
END
