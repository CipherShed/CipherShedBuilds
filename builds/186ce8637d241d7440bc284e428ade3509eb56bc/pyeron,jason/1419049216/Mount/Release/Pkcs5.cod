; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\home\public\Desktop\projects\cipherShed\src\Common\Pkcs5.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_RtlSecureZeroMemory
; Function compile flags: /Ogtpy
; File c:\program files\microsoft sdks\windows\v7.1\include\winnt.h
;	COMDAT _RtlSecureZeroMemory
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory PROC				; COMDAT

; 13070:     volatile char *vptr = (volatile char *)ptr;
; 13071: 
; 13072: #if defined(_M_AMD64)
; 13073: 
; 13074:         __stosb((PBYTE )((DWORD64)vptr), 0, cnt);
; 13075: 
; 13076: #else
; 13077: 
; 13078:     while (cnt) {

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _cnt$[esp-4]
  00004	8b 44 24 04	 mov	 eax, DWORD PTR _ptr$[esp-4]
  00008	8b c8		 mov	 ecx, eax
  0000a	85 d2		 test	 edx, edx
  0000c	74 0b		 je	 SHORT $LN1@RtlSecureZ
  0000e	8b ff		 npad	 2
$LL2@RtlSecureZ:

; 13079:         *vptr = 0;

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 13080:         vptr++;

  00013	41		 inc	 ecx

; 13081:         cnt--;

  00014	83 ea 01	 sub	 edx, 1
  00017	75 f7		 jne	 SHORT $LL2@RtlSecureZ
$LN1@RtlSecureZ:

; 13082:     }
; 13083: 
; 13084: #endif
; 13085: 
; 13086:     return ptr;
; 13087: }

  00019	c3		 ret	 0
_RtlSecureZeroMemory ENDP
_TEXT	ENDS
PUBLIC	_hmac_truncate
; Function compile flags: /Ogtpy
; File c:\home\public\desktop\projects\ciphershed\src\common\pkcs5.c
;	COMDAT _hmac_truncate
_TEXT	SEGMENT
_d1$ = 8						; size = 4
_d2$ = 12						; size = 4
_len$ = 16						; size = 4
_hmac_truncate PROC					; COMDAT

; 30   : {

  00000	56		 push	 esi

; 31   : 	int i;
; 32   : 	for (i = 0; i < len; i++)

  00001	8b 74 24 10	 mov	 esi, DWORD PTR _len$[esp]
  00005	85 f6		 test	 esi, esi
  00007	7e 15		 jle	 SHORT $LN1@hmac_trunc
  00009	8b 44 24 0c	 mov	 eax, DWORD PTR _d2$[esp]
  0000d	8b 4c 24 08	 mov	 ecx, DWORD PTR _d1$[esp]
  00011	2b c8		 sub	 ecx, eax
$LL3@hmac_trunc:

; 33   : 		d2[i] = d1[i];

  00013	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  00016	88 10		 mov	 BYTE PTR [eax], dl
  00018	40		 inc	 eax
  00019	83 ee 01	 sub	 esi, 1
  0001c	75 f5		 jne	 SHORT $LL3@hmac_trunc
$LN1@hmac_trunc:
  0001e	5e		 pop	 esi

; 34   : }

  0001f	c3		 ret	 0
_hmac_truncate ENDP
_TEXT	ENDS
PUBLIC	_out$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_hmac_sha512
EXTRN	_sha512_end:PROC
EXTRN	_sha512_hash:PROC
EXTRN	_sha512_begin:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogtpy
;	COMDAT _hmac_sha512
_TEXT	SEGMENT
_out$GSCopy$ = -952					; size = 4
_ictx$ = -948						; size = 208
_octx$ = -740						; size = 208
_tctx$78615 = -532					; size = 208
_buf$ = -324						; size = 128
_key$ = -196						; size = 64
_osha$ = -132						; size = 64
_isha$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_lk$ = 12						; size = 4
_d$ = 16						; size = 4
_ld$ = 20						; size = 4
_out$ = 24						; size = 4
_t$ = 28						; size = 4
_hmac_sha512 PROC					; COMDAT

; 47   : {

  00000	81 ec b8 03 00
	00		 sub	 esp, 952		; 000003b8H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 b4 03
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+952], eax

; 101  : 	hmac_truncate (osha, out, t);

  00014	8b 84 24 cc 03
	00 00		 mov	 eax, DWORD PTR _out$[esp+948]
  0001b	53		 push	 ebx
  0001c	8b 9c 24 c8 03
	00 00		 mov	 ebx, DWORD PTR _d$[esp+952]
  00023	55		 push	 ebp
  00024	56		 push	 esi
  00025	8b b4 24 cc 03
	00 00		 mov	 esi, DWORD PTR _lk$[esp+960]
  0002c	81 fe 80 00 00
	00		 cmp	 esi, 128		; 00000080H
  00032	57		 push	 edi
  00033	8b bc 24 cc 03
	00 00		 mov	 edi, DWORD PTR _k$[esp+964]
  0003a	89 44 24 10	 mov	 DWORD PTR _out$GSCopy$[esp+968], eax
  0003e	7e 69		 jle	 SHORT $LN45@hmac_sha51
  00040	8d 8c 24 b4 01
	00 00		 lea	 ecx, DWORD PTR _tctx$78615[esp+968]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 _sha512_begin
  0004d	8d 94 24 b8 01
	00 00		 lea	 edx, DWORD PTR _tctx$78615[esp+972]
  00054	52		 push	 edx
  00055	56		 push	 esi
  00056	57		 push	 edi
  00057	e8 00 00 00 00	 call	 _sha512_hash
  0005c	8d 84 24 c4 01
	00 00		 lea	 eax, DWORD PTR _tctx$78615[esp+984]
  00063	50		 push	 eax
  00064	8d 8c 24 18 03
	00 00		 lea	 ecx, DWORD PTR _key$[esp+988]
  0006b	51		 push	 ecx
  0006c	e8 00 00 00 00	 call	 _sha512_end
  00071	8d 94 24 cc 01
	00 00		 lea	 edx, DWORD PTR _tctx$78615[esp+992]
  00078	b9 d0 00 00 00	 mov	 ecx, 208		; 000000d0H
  0007d	83 c4 18	 add	 esp, 24			; 00000018H
  00080	8d bc 24 04 03
	00 00		 lea	 edi, DWORD PTR _key$[esp+968]
  00087	be 40 00 00 00	 mov	 esi, 64			; 00000040H
  0008c	8b e9		 mov	 ebp, ecx
  0008e	8b c2		 mov	 eax, edx
$LL54@hmac_sha51:
  00090	c6 00 00	 mov	 BYTE PTR [eax], 0
  00093	40		 inc	 eax
  00094	83 ed 01	 sub	 ebp, 1
  00097	75 f7		 jne	 SHORT $LL54@hmac_sha51
  00099	8d a4 24 00 00
	00 00		 npad	 7
$LL44@hmac_sha51:

; 48   : 	sha512_ctx ictx, octx;
; 49   : 	char isha[SHA512_DIGESTSIZE], osha[SHA512_DIGESTSIZE];
; 50   : 	char key[SHA512_DIGESTSIZE];
; 51   : 	char buf[SHA512_BLOCKSIZE];
; 52   : 	int i;
; 53   : 
; 54   :     /* If the key is longer than the hash algorithm block size,
; 55   : 	   let key = sha512(key), as per HMAC specifications. */
; 56   : 	if (lk > SHA512_BLOCKSIZE)
; 57   : 	{
; 58   : 		sha512_ctx tctx;
; 59   : 
; 60   : 		sha512_begin (&tctx);
; 61   : 		sha512_hash ((unsigned char *) k, lk, &tctx);
; 62   : 		sha512_end ((unsigned char *) key, &tctx);
; 63   : 
; 64   : 		k = key;
; 65   : 		lk = SHA512_DIGESTSIZE;
; 66   : 
; 67   : 		burn (&tctx, sizeof(tctx));		// Prevent leaks

  000a0	49		 dec	 ecx
  000a1	c6 02 00	 mov	 BYTE PTR [edx], 0
  000a4	42		 inc	 edx
  000a5	85 c9		 test	 ecx, ecx
  000a7	75 f7		 jne	 SHORT $LL44@hmac_sha51
$LN45@hmac_sha51:

; 68   : 	}
; 69   : 
; 70   : 	/**** Inner Digest ****/
; 71   : 
; 72   : 	sha512_begin (&ictx);

  000a9	8d 54 24 14	 lea	 edx, DWORD PTR _ictx$[esp+968]
  000ad	52		 push	 edx
  000ae	e8 00 00 00 00	 call	 _sha512_begin
  000b3	83 c4 04	 add	 esp, 4

; 73   : 
; 74   : 	/* Pad the key for inner digest */
; 75   : 	for (i = 0; i < lk; ++i)

  000b6	33 c0		 xor	 eax, eax
  000b8	85 f6		 test	 esi, esi
  000ba	7e 28		 jle	 SHORT $LN40@hmac_sha51
  000bc	8b ef		 mov	 ebp, edi
  000be	8d 8c 24 84 02
	00 00		 lea	 ecx, DWORD PTR _buf$[esp+968]
  000c5	2b e9		 sub	 ebp, ecx
  000c7	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL42@hmac_sha51:

; 76   : 		buf[i] = (char) (k[i] ^ 0x36);

  000d0	8d 8c 04 84 02
	00 00		 lea	 ecx, DWORD PTR _buf$[esp+eax+968]
  000d7	8a 14 29	 mov	 dl, BYTE PTR [ecx+ebp]
  000da	80 f2 36	 xor	 dl, 54			; 00000036H
  000dd	40		 inc	 eax
  000de	3b c6		 cmp	 eax, esi
  000e0	88 11		 mov	 BYTE PTR [ecx], dl
  000e2	7c ec		 jl	 SHORT $LL42@hmac_sha51
$LN40@hmac_sha51:

; 77   : 	for (i = lk; i < SHA512_BLOCKSIZE; ++i)

  000e4	81 fe 80 00 00
	00		 cmp	 esi, 128		; 00000080H
  000ea	7d 1a		 jge	 SHORT $LN39@hmac_sha51
  000ec	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  000f1	2b ce		 sub	 ecx, esi
  000f3	51		 push	 ecx
  000f4	8d 84 34 88 02
	00 00		 lea	 eax, DWORD PTR _buf$[esp+esi+972]
  000fb	6a 36		 push	 54			; 00000036H
  000fd	50		 push	 eax
  000fe	e8 00 00 00 00	 call	 _memset
  00103	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN39@hmac_sha51:

; 78   : 		buf[i] = 0x36;
; 79   : 
; 80   : 	sha512_hash ((unsigned char *) buf, SHA512_BLOCKSIZE, &ictx);

  00106	8d 54 24 14	 lea	 edx, DWORD PTR _ictx$[esp+968]
  0010a	52		 push	 edx
  0010b	8d 84 24 88 02
	00 00		 lea	 eax, DWORD PTR _buf$[esp+972]
  00112	68 80 00 00 00	 push	 128			; 00000080H
  00117	50		 push	 eax
  00118	e8 00 00 00 00	 call	 _sha512_hash

; 81   : 	sha512_hash ((unsigned char *) d, ld, &ictx);

  0011d	8b 94 24 e4 03
	00 00		 mov	 edx, DWORD PTR _ld$[esp+976]
  00124	8d 4c 24 20	 lea	 ecx, DWORD PTR _ictx$[esp+980]
  00128	51		 push	 ecx
  00129	52		 push	 edx
  0012a	53		 push	 ebx
  0012b	e8 00 00 00 00	 call	 _sha512_hash

; 82   : 
; 83   : 	sha512_end ((unsigned char *) isha, &ictx);

  00130	8d 44 24 2c	 lea	 eax, DWORD PTR _ictx$[esp+992]
  00134	50		 push	 eax
  00135	8d 8c 24 a0 03
	00 00		 lea	 ecx, DWORD PTR _isha$[esp+996]
  0013c	51		 push	 ecx
  0013d	e8 00 00 00 00	 call	 _sha512_end

; 84   : 
; 85   : 	/**** Outer Digest ****/
; 86   : 
; 87   : 	sha512_begin (&octx);

  00142	8d 94 24 04 01
	00 00		 lea	 edx, DWORD PTR _octx$[esp+1000]
  00149	52		 push	 edx
  0014a	e8 00 00 00 00	 call	 _sha512_begin
  0014f	83 c4 24	 add	 esp, 36			; 00000024H

; 88   : 
; 89   : 	for (i = 0; i < lk; ++i)

  00152	33 c0		 xor	 eax, eax
  00154	85 f6		 test	 esi, esi
  00156	7e 1d		 jle	 SHORT $LN34@hmac_sha51
  00158	8d 8c 24 84 02
	00 00		 lea	 ecx, DWORD PTR _buf$[esp+968]
  0015f	2b f9		 sub	 edi, ecx
$LL36@hmac_sha51:

; 90   : 		buf[i] = (char) (k[i] ^ 0x5C);

  00161	8d 8c 04 84 02
	00 00		 lea	 ecx, DWORD PTR _buf$[esp+eax+968]
  00168	8a 14 0f	 mov	 dl, BYTE PTR [edi+ecx]
  0016b	80 f2 5c	 xor	 dl, 92			; 0000005cH
  0016e	40		 inc	 eax
  0016f	3b c6		 cmp	 eax, esi
  00171	88 11		 mov	 BYTE PTR [ecx], dl
  00173	7c ec		 jl	 SHORT $LL36@hmac_sha51
$LN34@hmac_sha51:

; 91   : 	for (i = lk; i < SHA512_BLOCKSIZE; ++i)

  00175	81 fe 80 00 00
	00		 cmp	 esi, 128		; 00000080H
  0017b	7d 1a		 jge	 SHORT $LN33@hmac_sha51
  0017d	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00182	2b ce		 sub	 ecx, esi
  00184	51		 push	 ecx
  00185	8d 84 34 88 02
	00 00		 lea	 eax, DWORD PTR _buf$[esp+esi+972]
  0018c	6a 5c		 push	 92			; 0000005cH
  0018e	50		 push	 eax
  0018f	e8 00 00 00 00	 call	 _memset
  00194	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN33@hmac_sha51:

; 92   : 		buf[i] = 0x5C;
; 93   : 
; 94   : 	sha512_hash ((unsigned char *) buf, SHA512_BLOCKSIZE, &octx);

  00197	8d 94 24 e4 00
	00 00		 lea	 edx, DWORD PTR _octx$[esp+968]
  0019e	52		 push	 edx
  0019f	8d 84 24 88 02
	00 00		 lea	 eax, DWORD PTR _buf$[esp+972]
  001a6	68 80 00 00 00	 push	 128			; 00000080H
  001ab	50		 push	 eax
  001ac	e8 00 00 00 00	 call	 _sha512_hash

; 95   : 	sha512_hash ((unsigned char *) isha, SHA512_DIGESTSIZE, &octx);

  001b1	8d 8c 24 f0 00
	00 00		 lea	 ecx, DWORD PTR _octx$[esp+980]
  001b8	51		 push	 ecx
  001b9	8d 94 24 94 03
	00 00		 lea	 edx, DWORD PTR _isha$[esp+984]
  001c0	6a 40		 push	 64			; 00000040H
  001c2	52		 push	 edx
  001c3	e8 00 00 00 00	 call	 _sha512_hash

; 96   : 
; 97   : 	sha512_end ((unsigned char *) osha, &octx);

  001c8	8d 84 24 fc 00
	00 00		 lea	 eax, DWORD PTR _octx$[esp+992]
  001cf	50		 push	 eax
  001d0	8d 8c 24 60 03
	00 00		 lea	 ecx, DWORD PTR _osha$[esp+996]
  001d7	51		 push	 ecx
  001d8	e8 00 00 00 00	 call	 _sha512_end

; 98   : 
; 99   : 	/* truncate and print the results */
; 100  : 	t = t > SHA512_DIGESTSIZE ? SHA512_DIGESTSIZE : t;

  001dd	8b 84 24 00 04
	00 00		 mov	 eax, DWORD PTR _t$[esp+996]
  001e4	83 c4 20	 add	 esp, 32			; 00000020H
  001e7	83 f8 40	 cmp	 eax, 64			; 00000040H
  001ea	7e 05		 jle	 SHORT $LN51@hmac_sha51
  001ec	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
$LN51@hmac_sha51:

; 101  : 	hmac_truncate (osha, out, t);

  001f1	85 c0		 test	 eax, eax
  001f3	7e 16		 jle	 SHORT $LN30@hmac_sha51
  001f5	50		 push	 eax
  001f6	8b 44 24 14	 mov	 eax, DWORD PTR _out$GSCopy$[esp+972]
  001fa	8d 94 24 48 03
	00 00		 lea	 edx, DWORD PTR _osha$[esp+972]
  00201	52		 push	 edx
  00202	50		 push	 eax
  00203	e8 00 00 00 00	 call	 _memcpy
  00208	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN30@hmac_sha51:

; 102  : 
; 103  : 	/* Prevent leaks */
; 104  : 	burn (&ictx, sizeof(ictx));

  0020b	8d 54 24 14	 lea	 edx, DWORD PTR _ictx$[esp+968]
  0020f	b9 d0 00 00 00	 mov	 ecx, 208		; 000000d0H
  00214	8b f1		 mov	 esi, ecx
  00216	8b c2		 mov	 eax, edx
$LL63@hmac_sha51:
  00218	c6 00 00	 mov	 BYTE PTR [eax], 0
  0021b	40		 inc	 eax
  0021c	83 ee 01	 sub	 esi, 1
  0021f	75 f7		 jne	 SHORT $LL63@hmac_sha51
$LL27@hmac_sha51:
  00221	49		 dec	 ecx
  00222	c6 02 00	 mov	 BYTE PTR [edx], 0
  00225	42		 inc	 edx
  00226	85 c9		 test	 ecx, ecx
  00228	75 f7		 jne	 SHORT $LL27@hmac_sha51

; 105  : 	burn (&octx, sizeof(octx));

  0022a	8d 94 24 e4 00
	00 00		 lea	 edx, DWORD PTR _octx$[esp+968]
  00231	b9 d0 00 00 00	 mov	 ecx, 208		; 000000d0H
  00236	8b f1		 mov	 esi, ecx
  00238	8b c2		 mov	 eax, edx
  0023a	8d 9b 00 00 00
	00		 npad	 6
$LL67@hmac_sha51:
  00240	c6 00 00	 mov	 BYTE PTR [eax], 0
  00243	40		 inc	 eax
  00244	83 ee 01	 sub	 esi, 1
  00247	75 f7		 jne	 SHORT $LL67@hmac_sha51
  00249	8d a4 24 00 00
	00 00		 npad	 7
$LL22@hmac_sha51:
  00250	49		 dec	 ecx
  00251	c6 02 00	 mov	 BYTE PTR [edx], 0
  00254	42		 inc	 edx
  00255	85 c9		 test	 ecx, ecx
  00257	75 f7		 jne	 SHORT $LL22@hmac_sha51

; 106  : 	burn (isha, sizeof(isha));

  00259	8d 94 24 84 03
	00 00		 lea	 edx, DWORD PTR _isha$[esp+968]
  00260	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00265	8b f1		 mov	 esi, ecx
  00267	8b c2		 mov	 eax, edx
  00269	8d a4 24 00 00
	00 00		 npad	 7
$LL71@hmac_sha51:
  00270	c6 00 00	 mov	 BYTE PTR [eax], 0
  00273	40		 inc	 eax
  00274	83 ee 01	 sub	 esi, 1
  00277	75 f7		 jne	 SHORT $LL71@hmac_sha51
  00279	8d a4 24 00 00
	00 00		 npad	 7
$LL17@hmac_sha51:
  00280	49		 dec	 ecx
  00281	c6 02 00	 mov	 BYTE PTR [edx], 0
  00284	42		 inc	 edx
  00285	85 c9		 test	 ecx, ecx
  00287	75 f7		 jne	 SHORT $LL17@hmac_sha51

; 107  : 	burn (osha, sizeof(osha));

  00289	8d 94 24 44 03
	00 00		 lea	 edx, DWORD PTR _osha$[esp+968]
  00290	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00295	8b f1		 mov	 esi, ecx
  00297	8b c2		 mov	 eax, edx
  00299	8d a4 24 00 00
	00 00		 npad	 7
$LL75@hmac_sha51:
  002a0	c6 00 00	 mov	 BYTE PTR [eax], 0
  002a3	40		 inc	 eax
  002a4	83 ee 01	 sub	 esi, 1
  002a7	75 f7		 jne	 SHORT $LL75@hmac_sha51
  002a9	8d a4 24 00 00
	00 00		 npad	 7
$LL12@hmac_sha51:
  002b0	49		 dec	 ecx
  002b1	c6 02 00	 mov	 BYTE PTR [edx], 0
  002b4	42		 inc	 edx
  002b5	85 c9		 test	 ecx, ecx
  002b7	75 f7		 jne	 SHORT $LL12@hmac_sha51

; 108  : 	burn (buf, sizeof(buf));

  002b9	8d 94 24 84 02
	00 00		 lea	 edx, DWORD PTR _buf$[esp+968]
  002c0	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  002c5	8b f1		 mov	 esi, ecx
  002c7	8b c2		 mov	 eax, edx
  002c9	8d a4 24 00 00
	00 00		 npad	 7
$LL79@hmac_sha51:
  002d0	c6 00 00	 mov	 BYTE PTR [eax], 0
  002d3	40		 inc	 eax
  002d4	83 ee 01	 sub	 esi, 1
  002d7	75 f7		 jne	 SHORT $LL79@hmac_sha51
  002d9	8d a4 24 00 00
	00 00		 npad	 7
$LL7@hmac_sha51:
  002e0	49		 dec	 ecx
  002e1	c6 02 00	 mov	 BYTE PTR [edx], 0
  002e4	42		 inc	 edx
  002e5	85 c9		 test	 ecx, ecx
  002e7	75 f7		 jne	 SHORT $LL7@hmac_sha51

; 109  : 	burn (key, sizeof(key));

  002e9	8d 94 24 04 03
	00 00		 lea	 edx, DWORD PTR _key$[esp+968]
  002f0	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  002f5	8b f1		 mov	 esi, ecx
  002f7	8b c2		 mov	 eax, edx
  002f9	8d a4 24 00 00
	00 00		 npad	 7
$LL83@hmac_sha51:
  00300	c6 00 00	 mov	 BYTE PTR [eax], 0
  00303	40		 inc	 eax
  00304	83 ee 01	 sub	 esi, 1
  00307	75 f7		 jne	 SHORT $LL83@hmac_sha51
  00309	5f		 pop	 edi
  0030a	5e		 pop	 esi
  0030b	5d		 pop	 ebp
  0030c	5b		 pop	 ebx
  0030d	8d 49 00	 npad	 3
$LL2@hmac_sha51:
  00310	49		 dec	 ecx
  00311	c6 02 00	 mov	 BYTE PTR [edx], 0
  00314	42		 inc	 edx
  00315	85 c9		 test	 ecx, ecx
  00317	75 f7		 jne	 SHORT $LL2@hmac_sha51

; 110  : }

  00319	8b 8c 24 b4 03
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+952]
  00320	33 cc		 xor	 ecx, esp
  00322	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00327	81 c4 b8 03 00
	00		 add	 esp, 952		; 000003b8H
  0032d	c3		 ret	 0
_hmac_sha512 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_derive_u_sha512
; Function compile flags: /Ogtpy
;	COMDAT _derive_u_sha512
_TEXT	SEGMENT
_counter$ = -264					; size = 4
_j$ = -260						; size = 64
_k$ = -196						; size = 64
_init$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_u$ = 28						; size = 4
_b$ = 32						; size = 4
_derive_u_sha512 PROC					; COMDAT

; 114  : {

  00000	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 04 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+264], eax
  00014	8b 84 24 14 01
	00 00		 mov	 eax, DWORD PTR _salt$[esp+260]

; 115  : 	char j[SHA512_DIGESTSIZE], k[SHA512_DIGESTSIZE];
; 116  : 	char init[128];
; 117  : 	char counter[4];
; 118  : 	int c, i;
; 119  : 
; 120  : 	/* iteration 1 */
; 121  : 	memset (counter, 0, 4);
; 122  : 	counter[3] = (char) b;

  0001b	8a 8c 24 24 01
	00 00		 mov	 cl, BYTE PTR _b$[esp+260]
  00022	53		 push	 ebx
  00023	8b 9c 24 24 01
	00 00		 mov	 ebx, DWORD PTR _u$[esp+264]
  0002a	55		 push	 ebp
  0002b	8b ac 24 14 01
	00 00		 mov	 ebp, DWORD PTR _pwd$[esp+268]
  00032	56		 push	 esi
  00033	8b b4 24 24 01
	00 00		 mov	 esi, DWORD PTR _salt_len$[esp+272]
  0003a	57		 push	 edi

; 123  : 	memcpy (init, salt, salt_len);	/* salt */

  0003b	56		 push	 esi
  0003c	50		 push	 eax
  0003d	8d 94 24 9c 00
	00 00		 lea	 edx, DWORD PTR _init$[esp+288]
  00044	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _counter$[esp+288], 0
  0004c	52		 push	 edx
  0004d	88 4c 24 1f	 mov	 BYTE PTR _counter$[esp+295], cl
  00051	e8 00 00 00 00	 call	 _memcpy

; 124  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */

  00056	8b 44 24 1c	 mov	 eax, DWORD PTR _counter$[esp+292]

; 125  : 	hmac_sha512 (pwd, pwd_len, init, salt_len + 4, j, SHA512_DIGESTSIZE);

  0005a	6a 40		 push	 64			; 00000040H
  0005c	89 84 34 a4 00
	00 00		 mov	 DWORD PTR _init$[esp+esi+296], eax
  00063	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR _pwd_len$[esp+292]
  0006a	8d 4c 24 24	 lea	 ecx, DWORD PTR _j$[esp+296]
  0006e	51		 push	 ecx
  0006f	83 c6 04	 add	 esi, 4
  00072	56		 push	 esi
  00073	8d 94 24 ac 00
	00 00		 lea	 edx, DWORD PTR _init$[esp+304]
  0007a	52		 push	 edx
  0007b	50		 push	 eax
  0007c	55		 push	 ebp
  0007d	e8 00 00 00 00	 call	 _hmac_sha512

; 126  : 	memcpy (u, j, SHA512_DIGESTSIZE);
; 127  : 
; 128  : 	/* remaining iterations */
; 129  : 	for (c = 1; c < iterations; c++)

  00082	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR _iterations$[esp+312]
  00089	83 c4 24	 add	 esp, 36			; 00000024H
  0008c	83 f8 01	 cmp	 eax, 1
  0008f	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00094	8d 74 24 14	 lea	 esi, DWORD PTR _j$[esp+280]
  00098	8b fb		 mov	 edi, ebx
  0009a	f3 a5		 rep movsd
  0009c	7e 4d		 jle	 SHORT $LN10@derive_u_s
  0009e	8b f3		 mov	 esi, ebx
  000a0	8d 4c 24 54	 lea	 ecx, DWORD PTR _k$[esp+280]
  000a4	2b f1		 sub	 esi, ecx
  000a6	8d 78 ff	 lea	 edi, DWORD PTR [eax-1]
  000a9	8d a4 24 00 00
	00 00		 npad	 7
$LL16@derive_u_s:

; 130  : 	{
; 131  : 		hmac_sha512 (pwd, pwd_len, j, SHA512_DIGESTSIZE, k, SHA512_DIGESTSIZE);

  000b0	8b 8c 24 20 01
	00 00		 mov	 ecx, DWORD PTR _pwd_len$[esp+276]
  000b7	6a 40		 push	 64			; 00000040H
  000b9	8d 54 24 58	 lea	 edx, DWORD PTR _k$[esp+284]
  000bd	52		 push	 edx
  000be	6a 40		 push	 64			; 00000040H
  000c0	8d 44 24 20	 lea	 eax, DWORD PTR _j$[esp+292]
  000c4	50		 push	 eax
  000c5	51		 push	 ecx
  000c6	55		 push	 ebp
  000c7	e8 00 00 00 00	 call	 _hmac_sha512
  000cc	83 c4 18	 add	 esp, 24			; 00000018H

; 132  : 		for (i = 0; i < SHA512_DIGESTSIZE; i++)

  000cf	33 c0		 xor	 eax, eax
$LL13@derive_u_s:

; 133  : 		{
; 134  : 			u[i] ^= k[i];

  000d1	8a 54 04 54	 mov	 dl, BYTE PTR _k$[esp+eax+280]
  000d5	8d 4c 04 54	 lea	 ecx, DWORD PTR _k$[esp+eax+280]
  000d9	30 14 0e	 xor	 BYTE PTR [esi+ecx], dl

; 135  : 			j[i] = k[i];

  000dc	88 54 04 14	 mov	 BYTE PTR _j$[esp+eax+280], dl
  000e0	40		 inc	 eax
  000e1	83 f8 40	 cmp	 eax, 64			; 00000040H
  000e4	7c eb		 jl	 SHORT $LL13@derive_u_s

; 126  : 	memcpy (u, j, SHA512_DIGESTSIZE);
; 127  : 
; 128  : 	/* remaining iterations */
; 129  : 	for (c = 1; c < iterations; c++)

  000e6	83 ef 01	 sub	 edi, 1
  000e9	75 c5		 jne	 SHORT $LL16@derive_u_s
$LN10@derive_u_s:

; 136  : 		}
; 137  : 	}
; 138  : 
; 139  : 	/* Prevent possible leaks. */
; 140  : 	burn (j, sizeof(j));

  000eb	8d 54 24 14	 lea	 edx, DWORD PTR _j$[esp+280]
  000ef	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000f4	8b f1		 mov	 esi, ecx
  000f6	8b c2		 mov	 eax, edx
$LL20@derive_u_s:
  000f8	c6 00 00	 mov	 BYTE PTR [eax], 0
  000fb	40		 inc	 eax
  000fc	83 ee 01	 sub	 esi, 1
  000ff	75 f7		 jne	 SHORT $LL20@derive_u_s
$LL7@derive_u_s:
  00101	49		 dec	 ecx
  00102	c6 02 00	 mov	 BYTE PTR [edx], 0
  00105	42		 inc	 edx
  00106	85 c9		 test	 ecx, ecx
  00108	75 f7		 jne	 SHORT $LL7@derive_u_s

; 141  : 	burn (k, sizeof(k));

  0010a	8d 54 24 54	 lea	 edx, DWORD PTR _k$[esp+280]
  0010e	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00113	8b f1		 mov	 esi, ecx
  00115	8b c2		 mov	 eax, edx
$LL24@derive_u_s:
  00117	c6 00 00	 mov	 BYTE PTR [eax], 0
  0011a	40		 inc	 eax
  0011b	83 ee 01	 sub	 esi, 1
  0011e	75 f7		 jne	 SHORT $LL24@derive_u_s
  00120	5f		 pop	 edi
  00121	5e		 pop	 esi
  00122	5d		 pop	 ebp
  00123	5b		 pop	 ebx
$LL2@derive_u_s:
  00124	49		 dec	 ecx
  00125	c6 02 00	 mov	 BYTE PTR [edx], 0
  00128	42		 inc	 edx
  00129	85 c9		 test	 ecx, ecx
  0012b	75 f7		 jne	 SHORT $LL2@derive_u_s

; 142  : }

  0012d	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+264]
  00134	33 cc		 xor	 ecx, esp
  00136	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013b	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  00141	c3		 ret	 0
_derive_u_sha512 ENDP
_TEXT	ENDS
PUBLIC	_dk$GSCopy$
PUBLIC	_pwd$GSCopy$
PUBLIC	_salt$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_derive_key_sha512
; Function compile flags: /Ogtpy
;	COMDAT _derive_key_sha512
_TEXT	SEGMENT
_dk$GSCopy$ = -84					; size = 4
_pwd$GSCopy$ = -80					; size = 4
_salt$GSCopy$ = -76					; size = 4
_r$ = -72						; size = 4
_u$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_dk$ = 28						; size = 4
_dklen$ = 32						; size = 4
_derive_key_sha512 PROC					; COMDAT

; 146  : {

  00000	83 ec 54	 sub	 esp, 84			; 00000054H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 50	 mov	 DWORD PTR __$ArrayPad$[esp+84], eax

; 157  : 	}
; 158  : 
; 159  : 	r = dklen - (l - 1) * SHA512_DIGESTSIZE;

  0000e	8b 4c 24 60	 mov	 ecx, DWORD PTR _salt$[esp+80]
  00012	8b 44 24 58	 mov	 eax, DWORD PTR _pwd$[esp+80]
  00016	8b 54 24 6c	 mov	 edx, DWORD PTR _dk$[esp+80]
  0001a	89 4c 24 08	 mov	 DWORD PTR _salt$GSCopy$[esp+84], ecx
  0001e	8b 4c 24 70	 mov	 ecx, DWORD PTR _dklen$[esp+80]
  00022	53		 push	 ebx
  00023	89 44 24 08	 mov	 DWORD PTR _pwd$GSCopy$[esp+88], eax
  00027	8b c1		 mov	 eax, ecx
  00029	25 3f 00 00 80	 and	 eax, -2147483585	; 8000003fH
  0002e	55		 push	 ebp
  0002f	56		 push	 esi
  00030	89 54 24 0c	 mov	 DWORD PTR _dk$GSCopy$[esp+96], edx
  00034	79 05		 jns	 SHORT $LN29@derive_key
  00036	48		 dec	 eax
  00037	83 c8 c0	 or	 eax, -64		; ffffffc0H
  0003a	40		 inc	 eax
$LN29@derive_key:
  0003b	8b c1		 mov	 eax, ecx
  0003d	99		 cdq
  0003e	74 0d		 je	 SHORT $LN10@derive_key
  00040	83 e2 3f	 and	 edx, 63			; 0000003fH
  00043	03 c2		 add	 eax, edx
  00045	8b e8		 mov	 ebp, eax
  00047	c1 fd 06	 sar	 ebp, 6
  0004a	45		 inc	 ebp
  0004b	eb 0a		 jmp	 SHORT $LN9@derive_key
$LN10@derive_key:

; 147  : 	char u[SHA512_DIGESTSIZE];
; 148  : 	int b, l, r;
; 149  : 
; 150  : 	if (dklen % SHA512_DIGESTSIZE)
; 151  : 	{
; 152  : 		l = 1 + dklen / SHA512_DIGESTSIZE;
; 153  : 	}
; 154  : 	else
; 155  : 	{
; 156  : 		l = dklen / SHA512_DIGESTSIZE;

  0004d	83 e2 3f	 and	 edx, 63			; 0000003fH
  00050	03 c2		 add	 eax, edx
  00052	8b e8		 mov	 ebp, eax
  00054	c1 fd 06	 sar	 ebp, 6
$LN9@derive_key:

; 157  : 	}
; 158  : 
; 159  : 	r = dklen - (l - 1) * SHA512_DIGESTSIZE;

  00057	8b d5		 mov	 edx, ebp
  00059	c1 e2 06	 shl	 edx, 6
  0005c	2b ca		 sub	 ecx, edx
  0005e	83 c1 40	 add	 ecx, 64			; 00000040H

; 160  : 
; 161  : 	/* first l - 1 blocks */
; 162  : 	for (b = 1; b < l; b++)

  00061	bb 01 00 00 00	 mov	 ebx, 1
  00066	3b eb		 cmp	 ebp, ebx
  00068	89 4c 24 18	 mov	 DWORD PTR _r$[esp+96], ecx
  0006c	7e 43		 jle	 SHORT $LN6@derive_key
  0006e	57		 push	 edi
  0006f	90		 npad	 1
$LL27@derive_key:

; 163  : 	{
; 164  : 		derive_u_sha512 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  00070	8b 4c 24 78	 mov	 ecx, DWORD PTR _iterations$[esp+96]
  00074	8b 54 24 74	 mov	 edx, DWORD PTR _salt_len$[esp+96]
  00078	53		 push	 ebx
  00079	8d 44 24 24	 lea	 eax, DWORD PTR _u$[esp+104]
  0007d	50		 push	 eax
  0007e	8b 44 24 20	 mov	 eax, DWORD PTR _salt$GSCopy$[esp+108]
  00082	51		 push	 ecx
  00083	8b 4c 24 78	 mov	 ecx, DWORD PTR _pwd_len$[esp+108]
  00087	52		 push	 edx
  00088	8b 54 24 24	 mov	 edx, DWORD PTR _pwd$GSCopy$[esp+116]
  0008c	50		 push	 eax
  0008d	51		 push	 ecx
  0008e	52		 push	 edx
  0008f	e8 00 00 00 00	 call	 _derive_u_sha512

; 165  : 		memcpy (dk, u, SHA512_DIGESTSIZE);

  00094	8b 7c 24 2c	 mov	 edi, DWORD PTR _dk$GSCopy$[esp+128]

; 166  : 		dk += SHA512_DIGESTSIZE;

  00098	83 44 24 2c 40	 add	 DWORD PTR _dk$GSCopy$[esp+128], 64 ; 00000040H
  0009d	43		 inc	 ebx
  0009e	83 c4 1c	 add	 esp, 28			; 0000001cH
  000a1	3b dd		 cmp	 ebx, ebp
  000a3	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  000a8	8d 74 24 20	 lea	 esi, DWORD PTR _u$[esp+100]
  000ac	f3 a5		 rep movsd
  000ae	7c c0		 jl	 SHORT $LL27@derive_key
  000b0	5f		 pop	 edi
$LN6@derive_key:

; 167  : 	}
; 168  : 
; 169  : 	/* last block */
; 170  : 	derive_u_sha512 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  000b1	8b 4c 24 74	 mov	 ecx, DWORD PTR _iterations$[esp+92]
  000b5	8b 54 24 70	 mov	 edx, DWORD PTR _salt_len$[esp+92]
  000b9	53		 push	 ebx
  000ba	8d 44 24 20	 lea	 eax, DWORD PTR _u$[esp+100]
  000be	50		 push	 eax
  000bf	8b 44 24 1c	 mov	 eax, DWORD PTR _salt$GSCopy$[esp+104]
  000c3	51		 push	 ecx
  000c4	8b 4c 24 74	 mov	 ecx, DWORD PTR _pwd_len$[esp+104]
  000c8	52		 push	 edx
  000c9	8b 54 24 20	 mov	 edx, DWORD PTR _pwd$GSCopy$[esp+112]
  000cd	50		 push	 eax
  000ce	51		 push	 ecx
  000cf	52		 push	 edx
  000d0	e8 00 00 00 00	 call	 _derive_u_sha512

; 171  : 	memcpy (dk, u, r);

  000d5	8b 44 24 34	 mov	 eax, DWORD PTR _r$[esp+124]
  000d9	8b 54 24 28	 mov	 edx, DWORD PTR _dk$GSCopy$[esp+124]
  000dd	50		 push	 eax
  000de	8d 4c 24 3c	 lea	 ecx, DWORD PTR _u$[esp+128]
  000e2	51		 push	 ecx
  000e3	52		 push	 edx
  000e4	e8 00 00 00 00	 call	 _memcpy

; 172  : 
; 173  : 
; 174  : 	/* Prevent possible leaks. */
; 175  : 	burn (u, sizeof(u));

  000e9	8d 54 24 44	 lea	 edx, DWORD PTR _u$[esp+136]
  000ed	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000f2	83 c4 28	 add	 esp, 40			; 00000028H
  000f5	8b f1		 mov	 esi, ecx
  000f7	8b c2		 mov	 eax, edx
  000f9	8d a4 24 00 00
	00 00		 npad	 7
$LL14@derive_key:
  00100	c6 00 00	 mov	 BYTE PTR [eax], 0
  00103	40		 inc	 eax
  00104	83 ee 01	 sub	 esi, 1
  00107	75 f7		 jne	 SHORT $LL14@derive_key
  00109	5e		 pop	 esi
  0010a	5d		 pop	 ebp
  0010b	5b		 pop	 ebx
  0010c	8d 64 24 00	 npad	 4
$LL2@derive_key:
  00110	49		 dec	 ecx
  00111	c6 02 00	 mov	 BYTE PTR [edx], 0
  00114	42		 inc	 edx
  00115	85 c9		 test	 ecx, ecx
  00117	75 f7		 jne	 SHORT $LL2@derive_key

; 176  : }

  00119	8b 4c 24 50	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+84]
  0011d	33 cc		 xor	 ecx, esp
  0011f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00124	83 c4 54	 add	 esp, 84			; 00000054H
  00127	c3		 ret	 0
_derive_key_sha512 ENDP
_TEXT	ENDS
PUBLIC	_out$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_hmac_sha1
EXTRN	_sha1_end:PROC
EXTRN	_sha1_hash:PROC
EXTRN	_sha1_begin:PROC
; Function compile flags: /Ogtpy
;	COMDAT _hmac_sha1
_TEXT	SEGMENT
_out$GSCopy$ = -408					; size = 4
_ictx$ = -404						; size = 92
_octx$ = -312						; size = 92
_tctx$78801 = -220					; size = 92
_key$ = -128						; size = 20
_isha$ = -108						; size = 20
_osha$ = -88						; size = 20
_buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_lk$ = 12						; size = 4
_d$ = 16						; size = 4
_ld$ = 20						; size = 4
_out$ = 24						; size = 4
_t$ = 28						; size = 4
_hmac_sha1 PROC						; COMDAT

; 189  : {

  00000	81 ec 98 01 00
	00		 sub	 esp, 408		; 00000198H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 94 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+408], eax

; 243  : 	hmac_truncate (osha, out, t);

  00014	8b 84 24 ac 01
	00 00		 mov	 eax, DWORD PTR _out$[esp+404]
  0001b	53		 push	 ebx
  0001c	8b 9c 24 a8 01
	00 00		 mov	 ebx, DWORD PTR _d$[esp+408]
  00023	55		 push	 ebp
  00024	56		 push	 esi
  00025	8b b4 24 ac 01
	00 00		 mov	 esi, DWORD PTR _lk$[esp+416]
  0002c	83 fe 40	 cmp	 esi, 64			; 00000040H
  0002f	57		 push	 edi
  00030	8b bc 24 ac 01
	00 00		 mov	 edi, DWORD PTR _k$[esp+420]
  00037	89 44 24 10	 mov	 DWORD PTR _out$GSCopy$[esp+424], eax
  0003b	7e 6c		 jle	 SHORT $LN45@hmac_sha1
  0003d	8d 8c 24 cc 00
	00 00		 lea	 ecx, DWORD PTR _tctx$78801[esp+424]
  00044	51		 push	 ecx
  00045	e8 00 00 00 00	 call	 _sha1_begin
  0004a	8d 94 24 d0 00
	00 00		 lea	 edx, DWORD PTR _tctx$78801[esp+428]
  00051	52		 push	 edx
  00052	56		 push	 esi
  00053	57		 push	 edi
  00054	e8 00 00 00 00	 call	 _sha1_hash
  00059	8d 84 24 dc 00
	00 00		 lea	 eax, DWORD PTR _tctx$78801[esp+440]
  00060	50		 push	 eax
  00061	8d 8c 24 3c 01
	00 00		 lea	 ecx, DWORD PTR _key$[esp+444]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 _sha1_end
  0006e	8d 94 24 e4 00
	00 00		 lea	 edx, DWORD PTR _tctx$78801[esp+448]
  00075	b9 5c 00 00 00	 mov	 ecx, 92			; 0000005cH
  0007a	83 c4 18	 add	 esp, 24			; 00000018H
  0007d	8d bc 24 28 01
	00 00		 lea	 edi, DWORD PTR _key$[esp+424]
  00084	be 14 00 00 00	 mov	 esi, 20			; 00000014H
  00089	8b e9		 mov	 ebp, ecx
  0008b	8b c2		 mov	 eax, edx
  0008d	8d 49 00	 npad	 3
$LL54@hmac_sha1:
  00090	c6 00 00	 mov	 BYTE PTR [eax], 0
  00093	40		 inc	 eax
  00094	83 ed 01	 sub	 ebp, 1
  00097	75 f7		 jne	 SHORT $LL54@hmac_sha1
  00099	8d a4 24 00 00
	00 00		 npad	 7
$LL44@hmac_sha1:

; 190  : 	sha1_ctx ictx, octx;
; 191  : 	char isha[SHA1_DIGESTSIZE], osha[SHA1_DIGESTSIZE];
; 192  : 	char key[SHA1_DIGESTSIZE];
; 193  : 	char buf[SHA1_BLOCKSIZE];
; 194  : 	int i;
; 195  : 
; 196  :     /* If the key is longer than the hash algorithm block size,
; 197  : 	   let key = sha1(key), as per HMAC specifications. */
; 198  : 	if (lk > SHA1_BLOCKSIZE)
; 199  : 	{
; 200  : 		sha1_ctx tctx;
; 201  : 
; 202  : 		sha1_begin (&tctx);
; 203  : 		sha1_hash ((unsigned char *) k, lk, &tctx);
; 204  : 		sha1_end ((unsigned char *) key, &tctx);
; 205  : 
; 206  : 		k = key;
; 207  : 		lk = SHA1_DIGESTSIZE;
; 208  : 
; 209  : 		burn (&tctx, sizeof(tctx));		// Prevent leaks

  000a0	49		 dec	 ecx
  000a1	c6 02 00	 mov	 BYTE PTR [edx], 0
  000a4	42		 inc	 edx
  000a5	85 c9		 test	 ecx, ecx
  000a7	75 f7		 jne	 SHORT $LL44@hmac_sha1
$LN45@hmac_sha1:

; 210  : 	}
; 211  : 
; 212  : 	/**** Inner Digest ****/
; 213  : 
; 214  : 	sha1_begin (&ictx);

  000a9	8d 54 24 14	 lea	 edx, DWORD PTR _ictx$[esp+424]
  000ad	52		 push	 edx
  000ae	e8 00 00 00 00	 call	 _sha1_begin
  000b3	83 c4 04	 add	 esp, 4

; 215  : 
; 216  : 	/* Pad the key for inner digest */
; 217  : 	for (i = 0; i < lk; ++i)

  000b6	33 c0		 xor	 eax, eax
  000b8	85 f6		 test	 esi, esi
  000ba	7e 28		 jle	 SHORT $LN40@hmac_sha1
  000bc	8b ef		 mov	 ebp, edi
  000be	8d 8c 24 64 01
	00 00		 lea	 ecx, DWORD PTR _buf$[esp+424]
  000c5	2b e9		 sub	 ebp, ecx
  000c7	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL42@hmac_sha1:

; 218  : 		buf[i] = (char) (k[i] ^ 0x36);

  000d0	8d 8c 04 64 01
	00 00		 lea	 ecx, DWORD PTR _buf$[esp+eax+424]
  000d7	8a 14 29	 mov	 dl, BYTE PTR [ecx+ebp]
  000da	80 f2 36	 xor	 dl, 54			; 00000036H
  000dd	40		 inc	 eax
  000de	3b c6		 cmp	 eax, esi
  000e0	88 11		 mov	 BYTE PTR [ecx], dl
  000e2	7c ec		 jl	 SHORT $LL42@hmac_sha1
$LN40@hmac_sha1:

; 219  : 	for (i = lk; i < SHA1_BLOCKSIZE; ++i)

  000e4	83 fe 40	 cmp	 esi, 64			; 00000040H
  000e7	7d 1a		 jge	 SHORT $LN39@hmac_sha1
  000e9	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000ee	2b ce		 sub	 ecx, esi
  000f0	51		 push	 ecx
  000f1	8d 84 34 68 01
	00 00		 lea	 eax, DWORD PTR _buf$[esp+esi+428]
  000f8	6a 36		 push	 54			; 00000036H
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 _memset
  00100	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN39@hmac_sha1:

; 220  : 		buf[i] = 0x36;
; 221  : 
; 222  : 	sha1_hash ((unsigned char *) buf, SHA1_BLOCKSIZE, &ictx);

  00103	8d 54 24 14	 lea	 edx, DWORD PTR _ictx$[esp+424]
  00107	52		 push	 edx
  00108	8d 84 24 68 01
	00 00		 lea	 eax, DWORD PTR _buf$[esp+428]
  0010f	6a 40		 push	 64			; 00000040H
  00111	50		 push	 eax
  00112	e8 00 00 00 00	 call	 _sha1_hash

; 223  : 	sha1_hash ((unsigned char *) d, ld, &ictx);

  00117	8b 94 24 c4 01
	00 00		 mov	 edx, DWORD PTR _ld$[esp+432]
  0011e	8d 4c 24 20	 lea	 ecx, DWORD PTR _ictx$[esp+436]
  00122	51		 push	 ecx
  00123	52		 push	 edx
  00124	53		 push	 ebx
  00125	e8 00 00 00 00	 call	 _sha1_hash

; 224  : 
; 225  : 	sha1_end ((unsigned char *) isha, &ictx);

  0012a	8d 44 24 2c	 lea	 eax, DWORD PTR _ictx$[esp+448]
  0012e	50		 push	 eax
  0012f	8d 8c 24 58 01
	00 00		 lea	 ecx, DWORD PTR _isha$[esp+452]
  00136	51		 push	 ecx
  00137	e8 00 00 00 00	 call	 _sha1_end

; 226  : 
; 227  : 	/**** Outer Digest ****/
; 228  : 
; 229  : 	sha1_begin (&octx);

  0013c	8d 94 24 90 00
	00 00		 lea	 edx, DWORD PTR _octx$[esp+456]
  00143	52		 push	 edx
  00144	e8 00 00 00 00	 call	 _sha1_begin
  00149	83 c4 24	 add	 esp, 36			; 00000024H

; 230  : 
; 231  : 	for (i = 0; i < lk; ++i)

  0014c	33 c0		 xor	 eax, eax
  0014e	85 f6		 test	 esi, esi
  00150	7e 22		 jle	 SHORT $LN34@hmac_sha1
  00152	8d 8c 24 64 01
	00 00		 lea	 ecx, DWORD PTR _buf$[esp+424]
  00159	2b f9		 sub	 edi, ecx
  0015b	eb 03 8d 49 00	 npad	 5
$LL36@hmac_sha1:

; 232  : 		buf[i] = (char) (k[i] ^ 0x5C);

  00160	8d 8c 04 64 01
	00 00		 lea	 ecx, DWORD PTR _buf$[esp+eax+424]
  00167	8a 14 0f	 mov	 dl, BYTE PTR [edi+ecx]
  0016a	80 f2 5c	 xor	 dl, 92			; 0000005cH
  0016d	40		 inc	 eax
  0016e	3b c6		 cmp	 eax, esi
  00170	88 11		 mov	 BYTE PTR [ecx], dl
  00172	7c ec		 jl	 SHORT $LL36@hmac_sha1
$LN34@hmac_sha1:

; 233  : 	for (i = lk; i < SHA1_BLOCKSIZE; ++i)

  00174	83 fe 40	 cmp	 esi, 64			; 00000040H
  00177	7d 1a		 jge	 SHORT $LN171@hmac_sha1
  00179	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0017e	2b ce		 sub	 ecx, esi
  00180	51		 push	 ecx
  00181	8d 84 34 68 01
	00 00		 lea	 eax, DWORD PTR _buf$[esp+esi+428]
  00188	6a 5c		 push	 92			; 0000005cH
  0018a	50		 push	 eax
  0018b	e8 00 00 00 00	 call	 _memset
  00190	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN171@hmac_sha1:

; 234  : 		buf[i] = 0x5C;
; 235  : 
; 236  : 	sha1_hash ((unsigned char *) buf, SHA1_BLOCKSIZE, &octx);

  00193	8d 54 24 70	 lea	 edx, DWORD PTR _octx$[esp+424]
  00197	52		 push	 edx
  00198	8d 84 24 68 01
	00 00		 lea	 eax, DWORD PTR _buf$[esp+428]
  0019f	6a 40		 push	 64			; 00000040H
  001a1	50		 push	 eax
  001a2	e8 00 00 00 00	 call	 _sha1_hash

; 237  : 	sha1_hash ((unsigned char *) isha, SHA1_DIGESTSIZE, &octx);

  001a7	8d 4c 24 7c	 lea	 ecx, DWORD PTR _octx$[esp+436]
  001ab	51		 push	 ecx
  001ac	8d 94 24 4c 01
	00 00		 lea	 edx, DWORD PTR _isha$[esp+440]
  001b3	6a 14		 push	 20			; 00000014H
  001b5	52		 push	 edx
  001b6	e8 00 00 00 00	 call	 _sha1_hash

; 238  : 
; 239  : 	sha1_end ((unsigned char *) osha, &octx);

  001bb	8d 84 24 88 00
	00 00		 lea	 eax, DWORD PTR _octx$[esp+448]
  001c2	50		 push	 eax
  001c3	8d 8c 24 6c 01
	00 00		 lea	 ecx, DWORD PTR _osha$[esp+452]
  001ca	51		 push	 ecx
  001cb	e8 00 00 00 00	 call	 _sha1_end

; 240  : 
; 241  : 	/* truncate and print the results */
; 242  : 	t = t > SHA1_DIGESTSIZE ? SHA1_DIGESTSIZE : t;

  001d0	8b 84 24 e0 01
	00 00		 mov	 eax, DWORD PTR _t$[esp+452]
  001d7	83 c4 20	 add	 esp, 32			; 00000020H
  001da	83 f8 14	 cmp	 eax, 20			; 00000014H
  001dd	7e 05		 jle	 SHORT $LN51@hmac_sha1
  001df	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
$LN51@hmac_sha1:

; 243  : 	hmac_truncate (osha, out, t);

  001e4	85 c0		 test	 eax, eax
  001e6	7e 16		 jle	 SHORT $LN30@hmac_sha1
  001e8	50		 push	 eax
  001e9	8b 44 24 14	 mov	 eax, DWORD PTR _out$GSCopy$[esp+428]
  001ed	8d 94 24 54 01
	00 00		 lea	 edx, DWORD PTR _osha$[esp+428]
  001f4	52		 push	 edx
  001f5	50		 push	 eax
  001f6	e8 00 00 00 00	 call	 _memcpy
  001fb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN30@hmac_sha1:

; 244  : 
; 245  : 	/* Prevent leaks */
; 246  : 	burn (&ictx, sizeof(ictx));

  001fe	8d 54 24 14	 lea	 edx, DWORD PTR _ictx$[esp+424]
  00202	b9 5c 00 00 00	 mov	 ecx, 92			; 0000005cH
  00207	8b f1		 mov	 esi, ecx
  00209	8b c2		 mov	 eax, edx
  0020b	eb 03 8d 49 00	 npad	 5
$LL63@hmac_sha1:
  00210	c6 00 00	 mov	 BYTE PTR [eax], 0
  00213	40		 inc	 eax
  00214	83 ee 01	 sub	 esi, 1
  00217	75 f7		 jne	 SHORT $LL63@hmac_sha1
  00219	8d a4 24 00 00
	00 00		 npad	 7
$LL27@hmac_sha1:
  00220	49		 dec	 ecx
  00221	c6 02 00	 mov	 BYTE PTR [edx], 0
  00224	42		 inc	 edx
  00225	85 c9		 test	 ecx, ecx
  00227	75 f7		 jne	 SHORT $LL27@hmac_sha1

; 247  : 	burn (&octx, sizeof(octx));

  00229	8d 54 24 70	 lea	 edx, DWORD PTR _octx$[esp+424]
  0022d	b9 5c 00 00 00	 mov	 ecx, 92			; 0000005cH
  00232	8b f1		 mov	 esi, ecx
  00234	8b c2		 mov	 eax, edx
$LL67@hmac_sha1:
  00236	c6 00 00	 mov	 BYTE PTR [eax], 0
  00239	40		 inc	 eax
  0023a	83 ee 01	 sub	 esi, 1
  0023d	75 f7		 jne	 SHORT $LL67@hmac_sha1
  0023f	90		 npad	 1
$LL22@hmac_sha1:
  00240	49		 dec	 ecx
  00241	c6 02 00	 mov	 BYTE PTR [edx], 0
  00244	42		 inc	 edx
  00245	85 c9		 test	 ecx, ecx
  00247	75 f7		 jne	 SHORT $LL22@hmac_sha1

; 248  : 	burn (isha, sizeof(isha));

  00249	8d 94 24 3c 01
	00 00		 lea	 edx, DWORD PTR _isha$[esp+424]
  00250	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  00255	8b f1		 mov	 esi, ecx
  00257	8b c2		 mov	 eax, edx
  00259	8d a4 24 00 00
	00 00		 npad	 7
$LL71@hmac_sha1:
  00260	c6 00 00	 mov	 BYTE PTR [eax], 0
  00263	40		 inc	 eax
  00264	83 ee 01	 sub	 esi, 1
  00267	75 f7		 jne	 SHORT $LL71@hmac_sha1
  00269	8d a4 24 00 00
	00 00		 npad	 7
$LL17@hmac_sha1:
  00270	49		 dec	 ecx
  00271	c6 02 00	 mov	 BYTE PTR [edx], 0
  00274	42		 inc	 edx
  00275	85 c9		 test	 ecx, ecx
  00277	75 f7		 jne	 SHORT $LL17@hmac_sha1

; 249  : 	burn (osha, sizeof(osha));

  00279	8d 94 24 50 01
	00 00		 lea	 edx, DWORD PTR _osha$[esp+424]
  00280	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  00285	8b f1		 mov	 esi, ecx
  00287	8b c2		 mov	 eax, edx
  00289	8d a4 24 00 00
	00 00		 npad	 7
$LL75@hmac_sha1:
  00290	c6 00 00	 mov	 BYTE PTR [eax], 0
  00293	40		 inc	 eax
  00294	83 ee 01	 sub	 esi, 1
  00297	75 f7		 jne	 SHORT $LL75@hmac_sha1
  00299	8d a4 24 00 00
	00 00		 npad	 7
$LL12@hmac_sha1:
  002a0	49		 dec	 ecx
  002a1	c6 02 00	 mov	 BYTE PTR [edx], 0
  002a4	42		 inc	 edx
  002a5	85 c9		 test	 ecx, ecx
  002a7	75 f7		 jne	 SHORT $LL12@hmac_sha1

; 250  : 	burn (buf, sizeof(buf));

  002a9	8d 94 24 64 01
	00 00		 lea	 edx, DWORD PTR _buf$[esp+424]
  002b0	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  002b5	8b f1		 mov	 esi, ecx
  002b7	8b c2		 mov	 eax, edx
  002b9	8d a4 24 00 00
	00 00		 npad	 7
$LL79@hmac_sha1:
  002c0	c6 00 00	 mov	 BYTE PTR [eax], 0
  002c3	40		 inc	 eax
  002c4	83 ee 01	 sub	 esi, 1
  002c7	75 f7		 jne	 SHORT $LL79@hmac_sha1
  002c9	8d a4 24 00 00
	00 00		 npad	 7
$LL7@hmac_sha1:
  002d0	49		 dec	 ecx
  002d1	c6 02 00	 mov	 BYTE PTR [edx], 0
  002d4	42		 inc	 edx
  002d5	85 c9		 test	 ecx, ecx
  002d7	75 f7		 jne	 SHORT $LL7@hmac_sha1

; 251  : 	burn (key, sizeof(key));

  002d9	8d 94 24 28 01
	00 00		 lea	 edx, DWORD PTR _key$[esp+424]
  002e0	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  002e5	8b f1		 mov	 esi, ecx
  002e7	8b c2		 mov	 eax, edx
  002e9	8d a4 24 00 00
	00 00		 npad	 7
$LL83@hmac_sha1:
  002f0	c6 00 00	 mov	 BYTE PTR [eax], 0
  002f3	40		 inc	 eax
  002f4	83 ee 01	 sub	 esi, 1
  002f7	75 f7		 jne	 SHORT $LL83@hmac_sha1
  002f9	5f		 pop	 edi
  002fa	5e		 pop	 esi
  002fb	5d		 pop	 ebp
  002fc	5b		 pop	 ebx
  002fd	8d 49 00	 npad	 3
$LL2@hmac_sha1:
  00300	49		 dec	 ecx
  00301	c6 02 00	 mov	 BYTE PTR [edx], 0
  00304	42		 inc	 edx
  00305	85 c9		 test	 ecx, ecx
  00307	75 f7		 jne	 SHORT $LL2@hmac_sha1

; 252  : }

  00309	8b 8c 24 94 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+408]
  00310	33 cc		 xor	 ecx, esp
  00312	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00317	81 c4 98 01 00
	00		 add	 esp, 408		; 00000198H
  0031d	c3		 ret	 0
_hmac_sha1 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_derive_u_sha1
; Function compile flags: /Ogtpy
;	COMDAT _derive_u_sha1
_TEXT	SEGMENT
_counter$ = -176					; size = 4
_j$ = -172						; size = 20
_k$ = -152						; size = 20
_init$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_u$ = 28						; size = 4
_b$ = 32						; size = 4
_derive_u_sha1 PROC					; COMDAT

; 257  : {

  00000	81 ec b0 00 00
	00		 sub	 esp, 176		; 000000b0H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 ac 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+176], eax
  00014	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR _salt$[esp+172]

; 258  : 	char j[SHA1_DIGESTSIZE], k[SHA1_DIGESTSIZE];
; 259  : 	char init[128];
; 260  : 	char counter[4];
; 261  : 	int c, i;
; 262  : 
; 263  : 	/* iteration 1 */
; 264  : 	memset (counter, 0, 4);
; 265  : 	counter[3] = (char) b;

  0001b	8a 8c 24 cc 00
	00 00		 mov	 cl, BYTE PTR _b$[esp+172]
  00022	53		 push	 ebx
  00023	8b 9c 24 b8 00
	00 00		 mov	 ebx, DWORD PTR _pwd$[esp+176]
  0002a	56		 push	 esi
  0002b	8b b4 24 d0 00
	00 00		 mov	 esi, DWORD PTR _u$[esp+180]
  00032	57		 push	 edi
  00033	8b bc 24 cc 00
	00 00		 mov	 edi, DWORD PTR _salt_len$[esp+184]

; 266  : 	memcpy (init, salt, salt_len);	/* salt */

  0003a	57		 push	 edi
  0003b	50		 push	 eax
  0003c	8d 54 24 40	 lea	 edx, DWORD PTR _init$[esp+196]
  00040	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _counter$[esp+196], 0
  00048	52		 push	 edx
  00049	88 4c 24 1b	 mov	 BYTE PTR _counter$[esp+203], cl
  0004d	e8 00 00 00 00	 call	 _memcpy

; 267  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */

  00052	8b 44 24 18	 mov	 eax, DWORD PTR _counter$[esp+200]

; 268  : 	hmac_sha1 (pwd, pwd_len, init, salt_len + 4, j, SHA1_DIGESTSIZE);

  00056	6a 14		 push	 20			; 00000014H
  00058	89 44 3c 48	 mov	 DWORD PTR _init$[esp+edi+204], eax
  0005c	8d 4c 24 20	 lea	 ecx, DWORD PTR _j$[esp+204]
  00060	51		 push	 ecx
  00061	83 c7 04	 add	 edi, 4
  00064	57		 push	 edi
  00065	8b bc 24 dc 00
	00 00		 mov	 edi, DWORD PTR _pwd_len$[esp+208]
  0006c	8d 54 24 50	 lea	 edx, DWORD PTR _init$[esp+212]
  00070	52		 push	 edx
  00071	57		 push	 edi
  00072	53		 push	 ebx
  00073	e8 00 00 00 00	 call	 _hmac_sha1

; 269  : 	memcpy (u, j, SHA1_DIGESTSIZE);

  00078	8b 44 24 34	 mov	 eax, DWORD PTR _j$[esp+224]
  0007c	8b 4c 24 38	 mov	 ecx, DWORD PTR _j$[esp+228]
  00080	8b 54 24 3c	 mov	 edx, DWORD PTR _j$[esp+232]
  00084	89 06		 mov	 DWORD PTR [esi], eax
  00086	8b 44 24 40	 mov	 eax, DWORD PTR _j$[esp+236]
  0008a	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0008d	8b 4c 24 44	 mov	 ecx, DWORD PTR _j$[esp+240]
  00091	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00094	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 270  : 
; 271  : 	/* remaining iterations */
; 272  : 	for (c = 1; c < iterations; c++)

  00097	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR _iterations$[esp+220]
  0009e	83 c4 24	 add	 esp, 36			; 00000024H
  000a1	83 f8 01	 cmp	 eax, 1
  000a4	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  000a7	7e 42		 jle	 SHORT $LN10@derive_u_s@2
  000a9	8d 54 24 24	 lea	 edx, DWORD PTR _k$[esp+188]
  000ad	55		 push	 ebp
  000ae	2b f2		 sub	 esi, edx
  000b0	8d 68 ff	 lea	 ebp, DWORD PTR [eax-1]
$LL16@derive_u_s@2:

; 273  : 	{
; 274  : 		hmac_sha1 (pwd, pwd_len, j, SHA1_DIGESTSIZE, k, SHA1_DIGESTSIZE);

  000b3	6a 14		 push	 20			; 00000014H
  000b5	8d 44 24 2c	 lea	 eax, DWORD PTR _k$[esp+196]
  000b9	50		 push	 eax
  000ba	6a 14		 push	 20			; 00000014H
  000bc	8d 4c 24 20	 lea	 ecx, DWORD PTR _j$[esp+204]
  000c0	51		 push	 ecx
  000c1	57		 push	 edi
  000c2	53		 push	 ebx
  000c3	e8 00 00 00 00	 call	 _hmac_sha1
  000c8	83 c4 18	 add	 esp, 24			; 00000018H

; 275  : 		for (i = 0; i < SHA1_DIGESTSIZE; i++)

  000cb	33 c0		 xor	 eax, eax
  000cd	8d 49 00	 npad	 3
$LL13@derive_u_s@2:

; 276  : 		{
; 277  : 			u[i] ^= k[i];

  000d0	8a 54 04 28	 mov	 dl, BYTE PTR _k$[esp+eax+192]
  000d4	8d 4c 04 28	 lea	 ecx, DWORD PTR _k$[esp+eax+192]
  000d8	30 14 0e	 xor	 BYTE PTR [esi+ecx], dl

; 278  : 			j[i] = k[i];

  000db	88 54 04 14	 mov	 BYTE PTR _j$[esp+eax+192], dl
  000df	40		 inc	 eax
  000e0	83 f8 14	 cmp	 eax, 20			; 00000014H
  000e3	7c eb		 jl	 SHORT $LL13@derive_u_s@2

; 270  : 
; 271  : 	/* remaining iterations */
; 272  : 	for (c = 1; c < iterations; c++)

  000e5	83 ed 01	 sub	 ebp, 1
  000e8	75 c9		 jne	 SHORT $LL16@derive_u_s@2
  000ea	5d		 pop	 ebp
$LN10@derive_u_s@2:

; 279  : 		}
; 280  : 	}
; 281  : 
; 282  : 	/* Prevent possible leaks. */
; 283  : 	burn (j, sizeof(j));

  000eb	8d 54 24 10	 lea	 edx, DWORD PTR _j$[esp+188]
  000ef	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  000f4	8b f1		 mov	 esi, ecx
  000f6	8b c2		 mov	 eax, edx
$LL20@derive_u_s@2:
  000f8	c6 00 00	 mov	 BYTE PTR [eax], 0
  000fb	40		 inc	 eax
  000fc	83 ee 01	 sub	 esi, 1
  000ff	75 f7		 jne	 SHORT $LL20@derive_u_s@2
$LL7@derive_u_s@2:
  00101	49		 dec	 ecx
  00102	c6 02 00	 mov	 BYTE PTR [edx], 0
  00105	42		 inc	 edx
  00106	85 c9		 test	 ecx, ecx
  00108	75 f7		 jne	 SHORT $LL7@derive_u_s@2

; 284  : 	burn (k, sizeof(k));

  0010a	8d 54 24 24	 lea	 edx, DWORD PTR _k$[esp+188]
  0010e	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  00113	8b f1		 mov	 esi, ecx
  00115	8b c2		 mov	 eax, edx
$LL24@derive_u_s@2:
  00117	c6 00 00	 mov	 BYTE PTR [eax], 0
  0011a	40		 inc	 eax
  0011b	83 ee 01	 sub	 esi, 1
  0011e	75 f7		 jne	 SHORT $LL24@derive_u_s@2
  00120	5f		 pop	 edi
  00121	5e		 pop	 esi
  00122	5b		 pop	 ebx
$LL2@derive_u_s@2:
  00123	49		 dec	 ecx
  00124	c6 02 00	 mov	 BYTE PTR [edx], 0
  00127	42		 inc	 edx
  00128	85 c9		 test	 ecx, ecx
  0012a	75 f7		 jne	 SHORT $LL2@derive_u_s@2

; 285  : }

  0012c	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+176]
  00133	33 cc		 xor	 ecx, esp
  00135	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013a	81 c4 b0 00 00
	00		 add	 esp, 176		; 000000b0H
  00140	c3		 ret	 0
_derive_u_sha1 ENDP
_TEXT	ENDS
PUBLIC	_salt$GSCopy$
PUBLIC	_pwd$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_derive_key_sha1
; Function compile flags: /Ogtpy
;	COMDAT _derive_key_sha1
_TEXT	SEGMENT
_pwd$GSCopy$ = -36					; size = 4
_salt$GSCopy$ = -32					; size = 4
_r$ = -28						; size = 4
_u$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_dk$ = 28						; size = 4
_dklen$ = 32						; size = 4
_derive_key_sha1 PROC					; COMDAT

; 290  : {

  00000	83 ec 24	 sub	 esp, 36			; 00000024H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 20	 mov	 DWORD PTR __$ArrayPad$[esp+36], eax
  0000e	8b 44 24 28	 mov	 eax, DWORD PTR _pwd$[esp+32]
  00012	8b 4c 24 30	 mov	 ecx, DWORD PTR _salt$[esp+32]

; 311  : 	}
; 312  : 
; 313  : 	/* last block */
; 314  : 	derive_u_sha1 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  00016	89 04 24	 mov	 DWORD PTR _pwd$GSCopy$[esp+36], eax
  00019	89 4c 24 04	 mov	 DWORD PTR _salt$GSCopy$[esp+36], ecx
  0001d	8b 4c 24 40	 mov	 ecx, DWORD PTR _dklen$[esp+32]
  00021	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00026	f7 e9		 imul	 ecx
  00028	c1 fa 03	 sar	 edx, 3
  0002b	53		 push	 ebx
  0002c	8b da		 mov	 ebx, edx
  0002e	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  00031	03 da		 add	 ebx, edx
  00033	8d 14 9b	 lea	 edx, DWORD PTR [ebx+ebx*4]
  00036	03 d2		 add	 edx, edx
  00038	55		 push	 ebp
  00039	56		 push	 esi
  0003a	8b 74 24 48	 mov	 esi, DWORD PTR _dk$[esp+44]
  0003e	03 d2		 add	 edx, edx
  00040	8b c1		 mov	 eax, ecx
  00042	2b c2		 sub	 eax, edx
  00044	57		 push	 edi
  00045	74 01		 je	 SHORT $LN10@derive_key@2

; 291  : 	char u[SHA1_DIGESTSIZE];
; 292  : 	int b, l, r;
; 293  : 
; 294  : 	if (dklen % SHA1_DIGESTSIZE)
; 295  : 	{
; 296  : 		l = 1 + dklen / SHA1_DIGESTSIZE;

  00047	43		 inc	 ebx
$LN10@derive_key@2:

; 297  : 	}
; 298  : 	else
; 299  : 	{
; 300  : 		l = dklen / SHA1_DIGESTSIZE;
; 301  : 	}
; 302  : 
; 303  : 	r = dklen - (l - 1) * SHA1_DIGESTSIZE;
; 304  : 
; 305  : 	/* first l - 1 blocks */
; 306  : 	for (b = 1; b < l; b++)

  00048	8b 6c 24 48	 mov	 ebp, DWORD PTR _iterations$[esp+48]
  0004c	8d 14 9b	 lea	 edx, DWORD PTR [ebx+ebx*4]
  0004f	03 d2		 add	 edx, edx
  00051	03 d2		 add	 edx, edx
  00053	2b ca		 sub	 ecx, edx
  00055	83 c1 14	 add	 ecx, 20			; 00000014H
  00058	bf 01 00 00 00	 mov	 edi, 1
  0005d	3b df		 cmp	 ebx, edi
  0005f	89 4c 24 18	 mov	 DWORD PTR _r$[esp+52], ecx
  00063	7e 4d		 jle	 SHORT $LN6@derive_key@2
$LL8@derive_key@2:

; 307  : 	{
; 308  : 		derive_u_sha1 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  00065	8b 4c 24 44	 mov	 ecx, DWORD PTR _salt_len$[esp+48]
  00069	8b 54 24 14	 mov	 edx, DWORD PTR _salt$GSCopy$[esp+52]
  0006d	57		 push	 edi
  0006e	8d 44 24 20	 lea	 eax, DWORD PTR _u$[esp+56]
  00072	50		 push	 eax
  00073	8b 44 24 44	 mov	 eax, DWORD PTR _pwd_len$[esp+56]
  00077	55		 push	 ebp
  00078	51		 push	 ecx
  00079	8b 4c 24 20	 mov	 ecx, DWORD PTR _pwd$GSCopy$[esp+68]
  0007d	52		 push	 edx
  0007e	50		 push	 eax
  0007f	51		 push	 ecx
  00080	e8 00 00 00 00	 call	 _derive_u_sha1

; 309  : 		memcpy (dk, u, SHA1_DIGESTSIZE);

  00085	8b 54 24 38	 mov	 edx, DWORD PTR _u$[esp+80]
  00089	8b 44 24 3c	 mov	 eax, DWORD PTR _u$[esp+84]
  0008d	8b 4c 24 40	 mov	 ecx, DWORD PTR _u$[esp+88]
  00091	89 16		 mov	 DWORD PTR [esi], edx
  00093	8b 54 24 44	 mov	 edx, DWORD PTR _u$[esp+92]
  00097	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0009a	8b 44 24 48	 mov	 eax, DWORD PTR _u$[esp+96]
  0009e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  000a1	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  000a4	89 46 10	 mov	 DWORD PTR [esi+16], eax
  000a7	47		 inc	 edi
  000a8	83 c4 1c	 add	 esp, 28			; 0000001cH

; 310  : 		dk += SHA1_DIGESTSIZE;

  000ab	83 c6 14	 add	 esi, 20			; 00000014H
  000ae	3b fb		 cmp	 edi, ebx
  000b0	7c b3		 jl	 SHORT $LL8@derive_key@2
$LN6@derive_key@2:

; 311  : 	}
; 312  : 
; 313  : 	/* last block */
; 314  : 	derive_u_sha1 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  000b2	8b 54 24 44	 mov	 edx, DWORD PTR _salt_len$[esp+48]
  000b6	8b 44 24 14	 mov	 eax, DWORD PTR _salt$GSCopy$[esp+52]
  000ba	57		 push	 edi
  000bb	8d 4c 24 20	 lea	 ecx, DWORD PTR _u$[esp+56]
  000bf	51		 push	 ecx
  000c0	8b 4c 24 44	 mov	 ecx, DWORD PTR _pwd_len$[esp+56]
  000c4	55		 push	 ebp
  000c5	52		 push	 edx
  000c6	8b 54 24 20	 mov	 edx, DWORD PTR _pwd$GSCopy$[esp+68]
  000ca	50		 push	 eax
  000cb	51		 push	 ecx
  000cc	52		 push	 edx
  000cd	e8 00 00 00 00	 call	 _derive_u_sha1

; 315  : 	memcpy (dk, u, r);

  000d2	8b 44 24 34	 mov	 eax, DWORD PTR _r$[esp+80]
  000d6	50		 push	 eax
  000d7	8d 4c 24 3c	 lea	 ecx, DWORD PTR _u$[esp+84]
  000db	51		 push	 ecx
  000dc	56		 push	 esi
  000dd	e8 00 00 00 00	 call	 _memcpy

; 316  : 
; 317  : 
; 318  : 	/* Prevent possible leaks. */
; 319  : 	burn (u, sizeof(u));

  000e2	8d 54 24 44	 lea	 edx, DWORD PTR _u$[esp+92]
  000e6	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  000eb	83 c4 28	 add	 esp, 40			; 00000028H
  000ee	8b f1		 mov	 esi, ecx
  000f0	8b c2		 mov	 eax, edx
$LL14@derive_key@2:
  000f2	c6 00 00	 mov	 BYTE PTR [eax], 0
  000f5	40		 inc	 eax
  000f6	83 ee 01	 sub	 esi, 1
  000f9	75 f7		 jne	 SHORT $LL14@derive_key@2
  000fb	5f		 pop	 edi
  000fc	5e		 pop	 esi
  000fd	5d		 pop	 ebp
  000fe	5b		 pop	 ebx
  000ff	90		 npad	 1
$LL2@derive_key@2:
  00100	49		 dec	 ecx
  00101	c6 02 00	 mov	 BYTE PTR [edx], 0
  00104	42		 inc	 edx
  00105	85 c9		 test	 ecx, ecx
  00107	75 f7		 jne	 SHORT $LL2@derive_key@2

; 320  : }

  00109	8b 4c 24 20	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+36]
  0010d	33 cc		 xor	 ecx, esp
  0010f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00114	83 c4 24	 add	 esp, 36			; 00000024H
  00117	c3		 ret	 0
_derive_key_sha1 ENDP
_TEXT	ENDS
PUBLIC	_input$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_hmac_ripemd160
EXTRN	_RMD160Final:PROC
EXTRN	_RMD160Update:PROC
EXTRN	_RMD160Init:PROC
; Function compile flags: /Ogtpy
;	COMDAT _hmac_ripemd160
_TEXT	SEGMENT
_input$GSCopy$ = -356					; size = 4
_context$ = -352					; size = 96
_tctx$78983 = -256					; size = 96
_tk$ = -160						; size = 20
_k_ipad$ = -140						; size = 65
_k_opad$ = -72						; size = 65
__$ArrayPad$ = -4					; size = 4
_key$ = 8						; size = 4
_keylen$ = 12						; size = 4
_input$ = 16						; size = 4
_len$ = 20						; size = 4
_digest$ = 24						; size = 4
_hmac_ripemd160 PROC					; COMDAT

; 325  : {

  00000	81 ec 64 01 00
	00		 sub	 esp, 356		; 00000164H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 60 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+356], eax

; 382  : 
; 383  : 	/* Prevent possible leaks. */
; 384  :     burn (k_ipad, sizeof(k_ipad));

  00014	8b 84 24 70 01
	00 00		 mov	 eax, DWORD PTR _input$[esp+352]
  0001b	53		 push	 ebx
  0001c	8b 9c 24 70 01
	00 00		 mov	 ebx, DWORD PTR _keylen$[esp+356]
  00023	83 fb 40	 cmp	 ebx, 64			; 00000040H
  00026	55		 push	 ebp
  00027	8b ac 24 80 01
	00 00		 mov	 ebp, DWORD PTR _digest$[esp+360]
  0002e	56		 push	 esi
  0002f	57		 push	 edi
  00030	8b bc 24 78 01
	00 00		 mov	 edi, DWORD PTR _key$[esp+368]
  00037	89 44 24 10	 mov	 DWORD PTR _input$GSCopy$[esp+372], eax
  0003b	7e 5c		 jle	 SHORT $LN26@hmac_ripem
  0003d	8d 4c 24 74	 lea	 ecx, DWORD PTR _tctx$78983[esp+372]
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 _RMD160Init
  00047	53		 push	 ebx
  00048	8d 54 24 7c	 lea	 edx, DWORD PTR _tctx$78983[esp+380]
  0004c	57		 push	 edi
  0004d	52		 push	 edx
  0004e	e8 00 00 00 00	 call	 _RMD160Update
  00053	8d 84 24 84 00
	00 00		 lea	 eax, DWORD PTR _tctx$78983[esp+388]
  0005a	50		 push	 eax
  0005b	8d 8c 24 e8 00
	00 00		 lea	 ecx, DWORD PTR _tk$[esp+392]
  00062	51		 push	 ecx
  00063	e8 00 00 00 00	 call	 _RMD160Final
  00068	8d 94 24 8c 00
	00 00		 lea	 edx, DWORD PTR _tctx$78983[esp+396]
  0006f	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  00074	83 c4 18	 add	 esp, 24			; 00000018H
  00077	8d bc 24 d4 00
	00 00		 lea	 edi, DWORD PTR _tk$[esp+372]
  0007e	bb 14 00 00 00	 mov	 ebx, 20			; 00000014H
  00083	8b f1		 mov	 esi, ecx
  00085	8b c2		 mov	 eax, edx
$LL33@hmac_ripem:
  00087	c6 00 00	 mov	 BYTE PTR [eax], 0
  0008a	40		 inc	 eax
  0008b	83 ee 01	 sub	 esi, 1
  0008e	75 f7		 jne	 SHORT $LL33@hmac_ripem
$LL25@hmac_ripem:

; 326  :     RMD160_CTX context;
; 327  :     unsigned char k_ipad[65];  /* inner padding - key XORd with ipad */
; 328  :     unsigned char k_opad[65];  /* outer padding - key XORd with opad */
; 329  :     unsigned char tk[RIPEMD160_DIGESTSIZE];
; 330  :     int i;
; 331  : 
; 332  :     /* If the key is longer than the hash algorithm block size,
; 333  : 	   let key = ripemd160(key), as per HMAC specifications. */
; 334  :     if (keylen > RIPEMD160_BLOCKSIZE) 
; 335  : 	{
; 336  :         RMD160_CTX      tctx;
; 337  : 
; 338  :         RMD160Init(&tctx);
; 339  :         RMD160Update(&tctx, (const unsigned char *) key, keylen);
; 340  :         RMD160Final(tk, &tctx);
; 341  : 
; 342  :         key = (char *) tk;
; 343  :         keylen = RIPEMD160_DIGESTSIZE;
; 344  : 
; 345  : 		burn (&tctx, sizeof(tctx));	// Prevent leaks

  00090	49		 dec	 ecx
  00091	c6 02 00	 mov	 BYTE PTR [edx], 0
  00094	42		 inc	 edx
  00095	85 c9		 test	 ecx, ecx
  00097	75 f7		 jne	 SHORT $LL25@hmac_ripem
$LN26@hmac_ripem:

; 346  :     }
; 347  : 
; 348  : 	/*
; 349  : 
; 350  : 	RMD160(K XOR opad, RMD160(K XOR ipad, text))
; 351  : 
; 352  : 	where K is an n byte key
; 353  : 	ipad is the byte 0x36 repeated RIPEMD160_BLOCKSIZE times
; 354  : 	opad is the byte 0x5c repeated RIPEMD160_BLOCKSIZE times
; 355  : 	and text is the data being protected */
; 356  : 
; 357  : 
; 358  : 	/* start out by storing key in pads */
; 359  : 	memset(k_ipad, 0x36, sizeof(k_ipad));

  00099	6a 41		 push	 65			; 00000041H
  0009b	8d 94 24 ec 00
	00 00		 lea	 edx, DWORD PTR _k_ipad$[esp+376]
  000a2	6a 36		 push	 54			; 00000036H
  000a4	52		 push	 edx
  000a5	e8 00 00 00 00	 call	 _memset

; 360  :     memset(k_opad, 0x5c, sizeof(k_opad));

  000aa	6a 41		 push	 65			; 00000041H
  000ac	8d 84 24 3c 01
	00 00		 lea	 eax, DWORD PTR _k_opad$[esp+388]
  000b3	6a 5c		 push	 92			; 0000005cH
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 _memset
  000bb	83 c4 18	 add	 esp, 24			; 00000018H

; 361  : 
; 362  :     /* XOR key with ipad and opad values */
; 363  :     for (i=0; i<keylen; i++) 

  000be	85 db		 test	 ebx, ebx
  000c0	7e 22		 jle	 SHORT $LN21@hmac_ripem
  000c2	8d 94 24 e8 00
	00 00		 lea	 edx, DWORD PTR _k_ipad$[esp+372]
  000c9	8d b4 24 2c 01
	00 00		 lea	 esi, DWORD PTR _k_opad$[esp+372]
  000d0	2b d7		 sub	 edx, edi
  000d2	8b c7		 mov	 eax, edi
  000d4	2b f7		 sub	 esi, edi
$LL23@hmac_ripem:

; 364  : 	{
; 365  :         k_ipad[i] ^= key[i];

  000d6	8a 08		 mov	 cl, BYTE PTR [eax]
  000d8	30 0c 02	 xor	 BYTE PTR [edx+eax], cl

; 366  :         k_opad[i] ^= key[i];

  000db	30 0c 06	 xor	 BYTE PTR [esi+eax], cl
  000de	40		 inc	 eax
  000df	83 eb 01	 sub	 ebx, 1
  000e2	75 f2		 jne	 SHORT $LL23@hmac_ripem
$LN21@hmac_ripem:

; 367  :     }
; 368  : 
; 369  :     /* perform inner RIPEMD-160 */
; 370  : 
; 371  :     RMD160Init(&context);           /* init context for 1st pass */

  000e4	8d 4c 24 14	 lea	 ecx, DWORD PTR _context$[esp+372]
  000e8	51		 push	 ecx
  000e9	e8 00 00 00 00	 call	 _RMD160Init

; 372  :     RMD160Update(&context, k_ipad, RIPEMD160_BLOCKSIZE);  /* start with inner pad */

  000ee	6a 40		 push	 64			; 00000040H
  000f0	8d 94 24 f0 00
	00 00		 lea	 edx, DWORD PTR _k_ipad$[esp+380]
  000f7	52		 push	 edx
  000f8	8d 44 24 20	 lea	 eax, DWORD PTR _context$[esp+384]
  000fc	50		 push	 eax
  000fd	e8 00 00 00 00	 call	 _RMD160Update

; 373  :     RMD160Update(&context, (const unsigned char *) input, len); /* then text of datagram */

  00102	8b 8c 24 94 01
	00 00		 mov	 ecx, DWORD PTR _len$[esp+384]
  00109	8b 54 24 20	 mov	 edx, DWORD PTR _input$GSCopy$[esp+388]
  0010d	51		 push	 ecx
  0010e	52		 push	 edx
  0010f	8d 44 24 2c	 lea	 eax, DWORD PTR _context$[esp+396]
  00113	50		 push	 eax
  00114	e8 00 00 00 00	 call	 _RMD160Update

; 374  :     RMD160Final((unsigned char *) digest, &context);         /* finish up 1st pass */

  00119	8d 4c 24 30	 lea	 ecx, DWORD PTR _context$[esp+400]
  0011d	51		 push	 ecx
  0011e	55		 push	 ebp
  0011f	e8 00 00 00 00	 call	 _RMD160Final

; 375  : 
; 376  :     /* perform outer RIPEMD-160 */
; 377  :     RMD160Init(&context);           /* init context for 2nd pass */

  00124	8d 54 24 38	 lea	 edx, DWORD PTR _context$[esp+408]
  00128	52		 push	 edx
  00129	e8 00 00 00 00	 call	 _RMD160Init

; 378  :     RMD160Update(&context, k_opad, RIPEMD160_BLOCKSIZE);  /* start with outer pad */

  0012e	6a 40		 push	 64			; 00000040H
  00130	8d 84 24 58 01
	00 00		 lea	 eax, DWORD PTR _k_opad$[esp+416]
  00137	50		 push	 eax
  00138	8d 4c 24 44	 lea	 ecx, DWORD PTR _context$[esp+420]
  0013c	51		 push	 ecx
  0013d	e8 00 00 00 00	 call	 _RMD160Update

; 379  :     /* results of 1st hash */
; 380  :     RMD160Update(&context, (const unsigned char *) digest, RIPEMD160_DIGESTSIZE);

  00142	6a 14		 push	 20			; 00000014H
  00144	8d 54 24 4c	 lea	 edx, DWORD PTR _context$[esp+428]
  00148	55		 push	 ebp
  00149	52		 push	 edx
  0014a	e8 00 00 00 00	 call	 _RMD160Update
  0014f	83 c4 40	 add	 esp, 64			; 00000040H

; 381  :     RMD160Final((unsigned char *) digest, &context);         /* finish up 2nd pass */

  00152	8d 44 24 14	 lea	 eax, DWORD PTR _context$[esp+372]
  00156	50		 push	 eax
  00157	55		 push	 ebp
  00158	e8 00 00 00 00	 call	 _RMD160Final

; 382  : 
; 383  : 	/* Prevent possible leaks. */
; 384  :     burn (k_ipad, sizeof(k_ipad));

  0015d	8d 94 24 f0 00
	00 00		 lea	 edx, DWORD PTR _k_ipad$[esp+380]
  00164	b9 41 00 00 00	 mov	 ecx, 65			; 00000041H
  00169	83 c4 08	 add	 esp, 8
  0016c	8b f1		 mov	 esi, ecx
  0016e	8b c2		 mov	 eax, edx
$LL37@hmac_ripem:
  00170	c6 00 00	 mov	 BYTE PTR [eax], 0
  00173	40		 inc	 eax
  00174	83 ee 01	 sub	 esi, 1
  00177	75 f7		 jne	 SHORT $LL37@hmac_ripem
  00179	8d a4 24 00 00
	00 00		 npad	 7
$LL17@hmac_ripem:
  00180	49		 dec	 ecx
  00181	c6 02 00	 mov	 BYTE PTR [edx], 0
  00184	42		 inc	 edx
  00185	85 c9		 test	 ecx, ecx
  00187	75 f7		 jne	 SHORT $LL17@hmac_ripem

; 385  :     burn (k_opad, sizeof(k_opad));

  00189	8d 94 24 2c 01
	00 00		 lea	 edx, DWORD PTR _k_opad$[esp+372]
  00190	b9 41 00 00 00	 mov	 ecx, 65			; 00000041H
  00195	8b f1		 mov	 esi, ecx
  00197	8b c2		 mov	 eax, edx
  00199	8d a4 24 00 00
	00 00		 npad	 7
$LL41@hmac_ripem:
  001a0	c6 00 00	 mov	 BYTE PTR [eax], 0
  001a3	40		 inc	 eax
  001a4	83 ee 01	 sub	 esi, 1
  001a7	75 f7		 jne	 SHORT $LL41@hmac_ripem
  001a9	8d a4 24 00 00
	00 00		 npad	 7
$LL12@hmac_ripem:
  001b0	49		 dec	 ecx
  001b1	c6 02 00	 mov	 BYTE PTR [edx], 0
  001b4	42		 inc	 edx
  001b5	85 c9		 test	 ecx, ecx
  001b7	75 f7		 jne	 SHORT $LL12@hmac_ripem

; 386  : 	burn (tk, sizeof(tk));

  001b9	8d 94 24 d4 00
	00 00		 lea	 edx, DWORD PTR _tk$[esp+372]
  001c0	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  001c5	8b f1		 mov	 esi, ecx
  001c7	8b c2		 mov	 eax, edx
  001c9	8d a4 24 00 00
	00 00		 npad	 7
$LL45@hmac_ripem:
  001d0	c6 00 00	 mov	 BYTE PTR [eax], 0
  001d3	40		 inc	 eax
  001d4	83 ee 01	 sub	 esi, 1
  001d7	75 f7		 jne	 SHORT $LL45@hmac_ripem
  001d9	8d a4 24 00 00
	00 00		 npad	 7
$LL7@hmac_ripem:
  001e0	49		 dec	 ecx
  001e1	c6 02 00	 mov	 BYTE PTR [edx], 0
  001e4	42		 inc	 edx
  001e5	85 c9		 test	 ecx, ecx
  001e7	75 f7		 jne	 SHORT $LL7@hmac_ripem

; 387  : 	burn (&context, sizeof(context));

  001e9	8d 54 24 14	 lea	 edx, DWORD PTR _context$[esp+372]
  001ed	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  001f2	8b f1		 mov	 esi, ecx
  001f4	8b c2		 mov	 eax, edx
$LL49@hmac_ripem:
  001f6	c6 00 00	 mov	 BYTE PTR [eax], 0
  001f9	40		 inc	 eax
  001fa	83 ee 01	 sub	 esi, 1
  001fd	75 f7		 jne	 SHORT $LL49@hmac_ripem
  001ff	5f		 pop	 edi
  00200	5e		 pop	 esi
  00201	5d		 pop	 ebp
  00202	5b		 pop	 ebx
$LL2@hmac_ripem:
  00203	49		 dec	 ecx
  00204	c6 02 00	 mov	 BYTE PTR [edx], 0
  00207	42		 inc	 edx
  00208	85 c9		 test	 ecx, ecx
  0020a	75 f7		 jne	 SHORT $LL2@hmac_ripem

; 388  : }

  0020c	8b 8c 24 60 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+356]
  00213	33 cc		 xor	 ecx, esp
  00215	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0021a	81 c4 64 01 00
	00		 add	 esp, 356		; 00000164H
  00220	c3		 ret	 0
_hmac_ripemd160 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_derive_u_ripemd160
; Function compile flags: /Ogtpy
;	COMDAT _derive_u_ripemd160
_TEXT	SEGMENT
_counter$ = -176					; size = 4
_j$ = -172						; size = 20
_k$ = -152						; size = 20
_init$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_u$ = 28						; size = 4
_b$ = 32						; size = 4
_derive_u_ripemd160 PROC				; COMDAT

; 391  : {

  00000	81 ec b0 00 00
	00		 sub	 esp, 176		; 000000b0H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 ac 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+176], eax
  00014	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR _salt$[esp+172]

; 392  : 	char j[RIPEMD160_DIGESTSIZE], k[RIPEMD160_DIGESTSIZE];
; 393  : 	char init[128];
; 394  : 	char counter[4];
; 395  : 	int c, i;
; 396  : 
; 397  : 	/* iteration 1 */
; 398  : 	memset (counter, 0, 4);
; 399  : 	counter[3] = (char) b;

  0001b	8a 8c 24 cc 00
	00 00		 mov	 cl, BYTE PTR _b$[esp+172]
  00022	53		 push	 ebx
  00023	8b 9c 24 b8 00
	00 00		 mov	 ebx, DWORD PTR _pwd$[esp+176]
  0002a	56		 push	 esi
  0002b	8b b4 24 d0 00
	00 00		 mov	 esi, DWORD PTR _u$[esp+180]
  00032	57		 push	 edi
  00033	8b bc 24 cc 00
	00 00		 mov	 edi, DWORD PTR _salt_len$[esp+184]

; 400  : 	memcpy (init, salt, salt_len);	/* salt */

  0003a	57		 push	 edi
  0003b	50		 push	 eax
  0003c	8d 54 24 40	 lea	 edx, DWORD PTR _init$[esp+196]
  00040	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _counter$[esp+196], 0
  00048	52		 push	 edx
  00049	88 4c 24 1b	 mov	 BYTE PTR _counter$[esp+203], cl
  0004d	e8 00 00 00 00	 call	 _memcpy

; 401  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */

  00052	8b 44 24 18	 mov	 eax, DWORD PTR _counter$[esp+200]
  00056	89 44 3c 44	 mov	 DWORD PTR _init$[esp+edi+200], eax

; 402  : 	hmac_ripemd160 (pwd, pwd_len, init, salt_len + 4, j);

  0005a	8d 4c 24 1c	 lea	 ecx, DWORD PTR _j$[esp+200]
  0005e	51		 push	 ecx
  0005f	83 c7 04	 add	 edi, 4
  00062	57		 push	 edi
  00063	8b bc 24 d8 00
	00 00		 mov	 edi, DWORD PTR _pwd_len$[esp+204]
  0006a	8d 54 24 4c	 lea	 edx, DWORD PTR _init$[esp+208]
  0006e	52		 push	 edx
  0006f	57		 push	 edi
  00070	53		 push	 ebx
  00071	e8 00 00 00 00	 call	 _hmac_ripemd160

; 403  : 	memcpy (u, j, RIPEMD160_DIGESTSIZE);

  00076	8b 44 24 30	 mov	 eax, DWORD PTR _j$[esp+220]
  0007a	8b 4c 24 34	 mov	 ecx, DWORD PTR _j$[esp+224]
  0007e	8b 54 24 38	 mov	 edx, DWORD PTR _j$[esp+228]
  00082	89 06		 mov	 DWORD PTR [esi], eax
  00084	8b 44 24 3c	 mov	 eax, DWORD PTR _j$[esp+232]
  00088	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0008b	8b 4c 24 40	 mov	 ecx, DWORD PTR _j$[esp+236]
  0008f	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00092	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 404  : 
; 405  : 	/* remaining iterations */
; 406  : 	for (c = 1; c < iterations; c++)

  00095	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR _iterations$[esp+216]
  0009c	83 c4 20	 add	 esp, 32			; 00000020H
  0009f	83 f8 01	 cmp	 eax, 1
  000a2	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  000a5	7e 44		 jle	 SHORT $LN10@derive_u_r
  000a7	8d 54 24 24	 lea	 edx, DWORD PTR _k$[esp+188]
  000ab	55		 push	 ebp
  000ac	2b f2		 sub	 esi, edx
  000ae	8d 68 ff	 lea	 ebp, DWORD PTR [eax-1]
$LL16@derive_u_r:

; 407  : 	{
; 408  : 		hmac_ripemd160 (pwd, pwd_len, j, RIPEMD160_DIGESTSIZE, k);

  000b1	8d 44 24 28	 lea	 eax, DWORD PTR _k$[esp+192]
  000b5	50		 push	 eax
  000b6	6a 14		 push	 20			; 00000014H
  000b8	8d 4c 24 1c	 lea	 ecx, DWORD PTR _j$[esp+200]
  000bc	51		 push	 ecx
  000bd	57		 push	 edi
  000be	53		 push	 ebx
  000bf	e8 00 00 00 00	 call	 _hmac_ripemd160
  000c4	83 c4 14	 add	 esp, 20			; 00000014H

; 409  : 		for (i = 0; i < RIPEMD160_DIGESTSIZE; i++)

  000c7	33 c0		 xor	 eax, eax
  000c9	8d a4 24 00 00
	00 00		 npad	 7
$LL13@derive_u_r:

; 410  : 		{
; 411  : 			u[i] ^= k[i];

  000d0	8a 54 04 28	 mov	 dl, BYTE PTR _k$[esp+eax+192]
  000d4	8d 4c 04 28	 lea	 ecx, DWORD PTR _k$[esp+eax+192]
  000d8	30 14 0e	 xor	 BYTE PTR [esi+ecx], dl

; 412  : 			j[i] = k[i];

  000db	88 54 04 14	 mov	 BYTE PTR _j$[esp+eax+192], dl
  000df	40		 inc	 eax
  000e0	83 f8 14	 cmp	 eax, 20			; 00000014H
  000e3	7c eb		 jl	 SHORT $LL13@derive_u_r

; 404  : 
; 405  : 	/* remaining iterations */
; 406  : 	for (c = 1; c < iterations; c++)

  000e5	83 ed 01	 sub	 ebp, 1
  000e8	75 c7		 jne	 SHORT $LL16@derive_u_r
  000ea	5d		 pop	 ebp
$LN10@derive_u_r:

; 413  : 		}
; 414  : 	}
; 415  : 
; 416  : 	/* Prevent possible leaks. */
; 417  : 	burn (j, sizeof(j));

  000eb	8d 54 24 10	 lea	 edx, DWORD PTR _j$[esp+188]
  000ef	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  000f4	8b f1		 mov	 esi, ecx
  000f6	8b c2		 mov	 eax, edx
$LL20@derive_u_r:
  000f8	c6 00 00	 mov	 BYTE PTR [eax], 0
  000fb	40		 inc	 eax
  000fc	83 ee 01	 sub	 esi, 1
  000ff	75 f7		 jne	 SHORT $LL20@derive_u_r
$LL7@derive_u_r:
  00101	49		 dec	 ecx
  00102	c6 02 00	 mov	 BYTE PTR [edx], 0
  00105	42		 inc	 edx
  00106	85 c9		 test	 ecx, ecx
  00108	75 f7		 jne	 SHORT $LL7@derive_u_r

; 418  : 	burn (k, sizeof(k));

  0010a	8d 54 24 24	 lea	 edx, DWORD PTR _k$[esp+188]
  0010e	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  00113	8b f1		 mov	 esi, ecx
  00115	8b c2		 mov	 eax, edx
$LL24@derive_u_r:
  00117	c6 00 00	 mov	 BYTE PTR [eax], 0
  0011a	40		 inc	 eax
  0011b	83 ee 01	 sub	 esi, 1
  0011e	75 f7		 jne	 SHORT $LL24@derive_u_r
  00120	5f		 pop	 edi
  00121	5e		 pop	 esi
  00122	5b		 pop	 ebx
$LL2@derive_u_r:
  00123	49		 dec	 ecx
  00124	c6 02 00	 mov	 BYTE PTR [edx], 0
  00127	42		 inc	 edx
  00128	85 c9		 test	 ecx, ecx
  0012a	75 f7		 jne	 SHORT $LL2@derive_u_r

; 419  : }

  0012c	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+176]
  00133	33 cc		 xor	 ecx, esp
  00135	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013a	81 c4 b0 00 00
	00		 add	 esp, 176		; 000000b0H
  00140	c3		 ret	 0
_derive_u_ripemd160 ENDP
_TEXT	ENDS
PUBLIC	_salt$GSCopy$
PUBLIC	_pwd$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_derive_key_ripemd160
; Function compile flags: /Ogtpy
;	COMDAT _derive_key_ripemd160
_TEXT	SEGMENT
_pwd$GSCopy$ = -36					; size = 4
_salt$GSCopy$ = -32					; size = 4
_r$ = -28						; size = 4
_u$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_dk$ = 28						; size = 4
_dklen$ = 32						; size = 4
_derive_key_ripemd160 PROC				; COMDAT

; 422  : {

  00000	83 ec 24	 sub	 esp, 36			; 00000024H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 20	 mov	 DWORD PTR __$ArrayPad$[esp+36], eax
  0000e	8b 44 24 28	 mov	 eax, DWORD PTR _pwd$[esp+32]
  00012	8b 4c 24 30	 mov	 ecx, DWORD PTR _salt$[esp+32]

; 443  : 	}
; 444  : 
; 445  : 	/* last block */
; 446  : 	derive_u_ripemd160 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  00016	89 04 24	 mov	 DWORD PTR _pwd$GSCopy$[esp+36], eax
  00019	89 4c 24 04	 mov	 DWORD PTR _salt$GSCopy$[esp+36], ecx
  0001d	8b 4c 24 40	 mov	 ecx, DWORD PTR _dklen$[esp+32]
  00021	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00026	f7 e9		 imul	 ecx
  00028	c1 fa 03	 sar	 edx, 3
  0002b	53		 push	 ebx
  0002c	8b da		 mov	 ebx, edx
  0002e	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  00031	03 da		 add	 ebx, edx
  00033	8d 14 9b	 lea	 edx, DWORD PTR [ebx+ebx*4]
  00036	03 d2		 add	 edx, edx
  00038	55		 push	 ebp
  00039	56		 push	 esi
  0003a	8b 74 24 48	 mov	 esi, DWORD PTR _dk$[esp+44]
  0003e	03 d2		 add	 edx, edx
  00040	8b c1		 mov	 eax, ecx
  00042	2b c2		 sub	 eax, edx
  00044	57		 push	 edi
  00045	74 01		 je	 SHORT $LN10@derive_key@3

; 423  : 	char u[RIPEMD160_DIGESTSIZE];
; 424  : 	int b, l, r;
; 425  : 
; 426  : 	if (dklen % RIPEMD160_DIGESTSIZE)
; 427  : 	{
; 428  : 		l = 1 + dklen / RIPEMD160_DIGESTSIZE;

  00047	43		 inc	 ebx
$LN10@derive_key@3:

; 429  : 	}
; 430  : 	else
; 431  : 	{
; 432  : 		l = dklen / RIPEMD160_DIGESTSIZE;
; 433  : 	}
; 434  : 
; 435  : 	r = dklen - (l - 1) * RIPEMD160_DIGESTSIZE;
; 436  : 
; 437  : 	/* first l - 1 blocks */
; 438  : 	for (b = 1; b < l; b++)

  00048	8b 6c 24 48	 mov	 ebp, DWORD PTR _iterations$[esp+48]
  0004c	8d 14 9b	 lea	 edx, DWORD PTR [ebx+ebx*4]
  0004f	03 d2		 add	 edx, edx
  00051	03 d2		 add	 edx, edx
  00053	2b ca		 sub	 ecx, edx
  00055	83 c1 14	 add	 ecx, 20			; 00000014H
  00058	bf 01 00 00 00	 mov	 edi, 1
  0005d	3b df		 cmp	 ebx, edi
  0005f	89 4c 24 18	 mov	 DWORD PTR _r$[esp+52], ecx
  00063	7e 4d		 jle	 SHORT $LN6@derive_key@3
$LL8@derive_key@3:

; 439  : 	{
; 440  : 		derive_u_ripemd160 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  00065	8b 4c 24 44	 mov	 ecx, DWORD PTR _salt_len$[esp+48]
  00069	8b 54 24 14	 mov	 edx, DWORD PTR _salt$GSCopy$[esp+52]
  0006d	57		 push	 edi
  0006e	8d 44 24 20	 lea	 eax, DWORD PTR _u$[esp+56]
  00072	50		 push	 eax
  00073	8b 44 24 44	 mov	 eax, DWORD PTR _pwd_len$[esp+56]
  00077	55		 push	 ebp
  00078	51		 push	 ecx
  00079	8b 4c 24 20	 mov	 ecx, DWORD PTR _pwd$GSCopy$[esp+68]
  0007d	52		 push	 edx
  0007e	50		 push	 eax
  0007f	51		 push	 ecx
  00080	e8 00 00 00 00	 call	 _derive_u_ripemd160

; 441  : 		memcpy (dk, u, RIPEMD160_DIGESTSIZE);

  00085	8b 54 24 38	 mov	 edx, DWORD PTR _u$[esp+80]
  00089	8b 44 24 3c	 mov	 eax, DWORD PTR _u$[esp+84]
  0008d	8b 4c 24 40	 mov	 ecx, DWORD PTR _u$[esp+88]
  00091	89 16		 mov	 DWORD PTR [esi], edx
  00093	8b 54 24 44	 mov	 edx, DWORD PTR _u$[esp+92]
  00097	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0009a	8b 44 24 48	 mov	 eax, DWORD PTR _u$[esp+96]
  0009e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  000a1	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  000a4	89 46 10	 mov	 DWORD PTR [esi+16], eax
  000a7	47		 inc	 edi
  000a8	83 c4 1c	 add	 esp, 28			; 0000001cH

; 442  : 		dk += RIPEMD160_DIGESTSIZE;

  000ab	83 c6 14	 add	 esi, 20			; 00000014H
  000ae	3b fb		 cmp	 edi, ebx
  000b0	7c b3		 jl	 SHORT $LL8@derive_key@3
$LN6@derive_key@3:

; 443  : 	}
; 444  : 
; 445  : 	/* last block */
; 446  : 	derive_u_ripemd160 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  000b2	8b 54 24 44	 mov	 edx, DWORD PTR _salt_len$[esp+48]
  000b6	8b 44 24 14	 mov	 eax, DWORD PTR _salt$GSCopy$[esp+52]
  000ba	57		 push	 edi
  000bb	8d 4c 24 20	 lea	 ecx, DWORD PTR _u$[esp+56]
  000bf	51		 push	 ecx
  000c0	8b 4c 24 44	 mov	 ecx, DWORD PTR _pwd_len$[esp+56]
  000c4	55		 push	 ebp
  000c5	52		 push	 edx
  000c6	8b 54 24 20	 mov	 edx, DWORD PTR _pwd$GSCopy$[esp+68]
  000ca	50		 push	 eax
  000cb	51		 push	 ecx
  000cc	52		 push	 edx
  000cd	e8 00 00 00 00	 call	 _derive_u_ripemd160

; 447  : 	memcpy (dk, u, r);

  000d2	8b 44 24 34	 mov	 eax, DWORD PTR _r$[esp+80]
  000d6	50		 push	 eax
  000d7	8d 4c 24 3c	 lea	 ecx, DWORD PTR _u$[esp+84]
  000db	51		 push	 ecx
  000dc	56		 push	 esi
  000dd	e8 00 00 00 00	 call	 _memcpy

; 448  : 
; 449  : 
; 450  : 	/* Prevent possible leaks. */
; 451  : 	burn (u, sizeof(u));

  000e2	8d 54 24 44	 lea	 edx, DWORD PTR _u$[esp+92]
  000e6	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  000eb	83 c4 28	 add	 esp, 40			; 00000028H
  000ee	8b f1		 mov	 esi, ecx
  000f0	8b c2		 mov	 eax, edx
$LL14@derive_key@3:
  000f2	c6 00 00	 mov	 BYTE PTR [eax], 0
  000f5	40		 inc	 eax
  000f6	83 ee 01	 sub	 esi, 1
  000f9	75 f7		 jne	 SHORT $LL14@derive_key@3
  000fb	5f		 pop	 edi
  000fc	5e		 pop	 esi
  000fd	5d		 pop	 ebp
  000fe	5b		 pop	 ebx
  000ff	90		 npad	 1
$LL2@derive_key@3:
  00100	49		 dec	 ecx
  00101	c6 02 00	 mov	 BYTE PTR [edx], 0
  00104	42		 inc	 edx
  00105	85 c9		 test	 ecx, ecx
  00107	75 f7		 jne	 SHORT $LL2@derive_key@3

; 452  : }

  00109	8b 4c 24 20	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+36]
  0010d	33 cc		 xor	 ecx, esp
  0010f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00114	83 c4 24	 add	 esp, 36			; 00000024H
  00117	c3		 ret	 0
_derive_key_ripemd160 ENDP
_TEXT	ENDS
PUBLIC	_out$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_hmac_whirlpool
EXTRN	_WHIRLPOOL_finalize:PROC
EXTRN	_WHIRLPOOL_add:PROC
EXTRN	_WHIRLPOOL_init:PROC
; Function compile flags: /Ogtpy
;	COMDAT _hmac_whirlpool
_TEXT	SEGMENT
_out$GSCopy$ = -768					; size = 4
_octx$ = -764						; size = 168
_ictx$ = -596						; size = 168
_tctx$79138 = -428					; size = 168
_buf$ = -260						; size = 64
_iwhi$ = -196						; size = 64
_key$ = -132						; size = 64
_owhi$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_lk$ = 12						; size = 4
_d$ = 16						; size = 4
_ld$ = 20						; size = 4
_out$ = 24						; size = 4
_t$ = 28						; size = 4
_hmac_whirlpool PROC					; COMDAT

; 465  : {

  00000	81 ec 00 03 00
	00		 sub	 esp, 768		; 00000300H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 fc 02
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+768], eax

; 519  : 	hmac_truncate (owhi, out, t);

  00014	8b 84 24 14 03
	00 00		 mov	 eax, DWORD PTR _out$[esp+764]
  0001b	53		 push	 ebx
  0001c	8b 9c 24 10 03
	00 00		 mov	 ebx, DWORD PTR _d$[esp+768]
  00023	55		 push	 ebp
  00024	56		 push	 esi
  00025	8b b4 24 14 03
	00 00		 mov	 esi, DWORD PTR _lk$[esp+776]
  0002c	83 fe 40	 cmp	 esi, 64			; 00000040H
  0002f	57		 push	 edi
  00030	8b bc 24 14 03
	00 00		 mov	 edi, DWORD PTR _k$[esp+780]
  00037	89 44 24 10	 mov	 DWORD PTR _out$GSCopy$[esp+784], eax
  0003b	7e 6c		 jle	 SHORT $LN45@hmac_whirl
  0003d	8d 8c 24 64 01
	00 00		 lea	 ecx, DWORD PTR _tctx$79138[esp+784]
  00044	51		 push	 ecx
  00045	e8 00 00 00 00	 call	 _WHIRLPOOL_init
  0004a	8d 94 24 68 01
	00 00		 lea	 edx, DWORD PTR _tctx$79138[esp+788]
  00051	52		 push	 edx
  00052	8d 04 f5 00 00
	00 00		 lea	 eax, DWORD PTR [esi*8]
  00059	50		 push	 eax
  0005a	57		 push	 edi
  0005b	e8 00 00 00 00	 call	 _WHIRLPOOL_add
  00060	8d 8c 24 9c 02
	00 00		 lea	 ecx, DWORD PTR _key$[esp+800]
  00067	51		 push	 ecx
  00068	8d 94 24 78 01
	00 00		 lea	 edx, DWORD PTR _tctx$79138[esp+804]
  0006f	52		 push	 edx
  00070	e8 00 00 00 00	 call	 _WHIRLPOOL_finalize
  00075	8d 94 24 7c 01
	00 00		 lea	 edx, DWORD PTR _tctx$79138[esp+808]
  0007c	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  00081	83 c4 18	 add	 esp, 24			; 00000018H
  00084	8d bc 24 8c 02
	00 00		 lea	 edi, DWORD PTR _key$[esp+784]
  0008b	be 40 00 00 00	 mov	 esi, 64			; 00000040H
  00090	8b e9		 mov	 ebp, ecx
  00092	8b c2		 mov	 eax, edx
$LL54@hmac_whirl:
  00094	c6 00 00	 mov	 BYTE PTR [eax], 0
  00097	40		 inc	 eax
  00098	83 ed 01	 sub	 ebp, 1
  0009b	75 f7		 jne	 SHORT $LL54@hmac_whirl
  0009d	8d 49 00	 npad	 3
$LL44@hmac_whirl:

; 466  : 	WHIRLPOOL_CTX ictx, octx;
; 467  : 	char iwhi[WHIRLPOOL_DIGESTSIZE], owhi[WHIRLPOOL_DIGESTSIZE];
; 468  : 	char key[WHIRLPOOL_DIGESTSIZE];
; 469  : 	char buf[WHIRLPOOL_BLOCKSIZE];
; 470  : 	int i;
; 471  : 
; 472  :     /* If the key is longer than the hash algorithm block size,
; 473  : 	   let key = whirlpool(key), as per HMAC specifications. */
; 474  : 	if (lk > WHIRLPOOL_BLOCKSIZE)
; 475  : 	{
; 476  : 		WHIRLPOOL_CTX tctx;
; 477  : 
; 478  : 		WHIRLPOOL_init (&tctx);
; 479  : 		WHIRLPOOL_add ((unsigned char *) k, lk * 8, &tctx);
; 480  : 		WHIRLPOOL_finalize (&tctx, (unsigned char *) key);
; 481  : 
; 482  : 		k = key;
; 483  : 		lk = WHIRLPOOL_DIGESTSIZE;
; 484  : 
; 485  : 		burn (&tctx, sizeof(tctx));		// Prevent leaks

  000a0	49		 dec	 ecx
  000a1	c6 02 00	 mov	 BYTE PTR [edx], 0
  000a4	42		 inc	 edx
  000a5	85 c9		 test	 ecx, ecx
  000a7	75 f7		 jne	 SHORT $LL44@hmac_whirl
$LN45@hmac_whirl:

; 486  : 	}
; 487  : 
; 488  : 	/**** Inner Digest ****/
; 489  : 
; 490  : 	WHIRLPOOL_init (&ictx);

  000a9	8d 84 24 bc 00
	00 00		 lea	 eax, DWORD PTR _ictx$[esp+784]
  000b0	50		 push	 eax
  000b1	e8 00 00 00 00	 call	 _WHIRLPOOL_init
  000b6	83 c4 04	 add	 esp, 4

; 491  : 
; 492  : 	/* Pad the key for inner digest */
; 493  : 	for (i = 0; i < lk; ++i)

  000b9	33 c0		 xor	 eax, eax
  000bb	85 f6		 test	 esi, esi
  000bd	7e 25		 jle	 SHORT $LN40@hmac_whirl
  000bf	8b ef		 mov	 ebp, edi
  000c1	8d 8c 24 0c 02
	00 00		 lea	 ecx, DWORD PTR _buf$[esp+784]
  000c8	2b e9		 sub	 ebp, ecx
  000ca	8d 9b 00 00 00
	00		 npad	 6
$LL42@hmac_whirl:

; 494  : 		buf[i] = (char) (k[i] ^ 0x36);

  000d0	8d 8c 04 0c 02
	00 00		 lea	 ecx, DWORD PTR _buf$[esp+eax+784]
  000d7	8a 14 29	 mov	 dl, BYTE PTR [ecx+ebp]
  000da	80 f2 36	 xor	 dl, 54			; 00000036H
  000dd	40		 inc	 eax
  000de	3b c6		 cmp	 eax, esi
  000e0	88 11		 mov	 BYTE PTR [ecx], dl
  000e2	7c ec		 jl	 SHORT $LL42@hmac_whirl
$LN40@hmac_whirl:

; 495  : 	for (i = lk; i < WHIRLPOOL_BLOCKSIZE; ++i)

  000e4	83 fe 40	 cmp	 esi, 64			; 00000040H
  000e7	7d 1a		 jge	 SHORT $LN39@hmac_whirl
  000e9	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000ee	2b ce		 sub	 ecx, esi
  000f0	51		 push	 ecx
  000f1	8d 84 34 10 02
	00 00		 lea	 eax, DWORD PTR _buf$[esp+esi+788]
  000f8	6a 36		 push	 54			; 00000036H
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 _memset
  00100	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN39@hmac_whirl:

; 496  : 		buf[i] = 0x36;
; 497  : 
; 498  : 	WHIRLPOOL_add ((unsigned char *) buf, WHIRLPOOL_BLOCKSIZE * 8, &ictx);

  00103	8d 94 24 bc 00
	00 00		 lea	 edx, DWORD PTR _ictx$[esp+784]
  0010a	52		 push	 edx
  0010b	8d 84 24 10 02
	00 00		 lea	 eax, DWORD PTR _buf$[esp+788]
  00112	68 00 02 00 00	 push	 512			; 00000200H
  00117	50		 push	 eax
  00118	e8 00 00 00 00	 call	 _WHIRLPOOL_add

; 499  : 	WHIRLPOOL_add ((unsigned char *) d, ld * 8, &ictx);

  0011d	8b 94 24 2c 03
	00 00		 mov	 edx, DWORD PTR _ld$[esp+792]
  00124	8d 8c 24 c8 00
	00 00		 lea	 ecx, DWORD PTR _ictx$[esp+796]
  0012b	51		 push	 ecx
  0012c	8d 04 d5 00 00
	00 00		 lea	 eax, DWORD PTR [edx*8]
  00133	50		 push	 eax
  00134	53		 push	 ebx
  00135	e8 00 00 00 00	 call	 _WHIRLPOOL_add

; 500  : 
; 501  : 	WHIRLPOOL_finalize (&ictx, (unsigned char *) iwhi);

  0013a	8d 8c 24 64 02
	00 00		 lea	 ecx, DWORD PTR _iwhi$[esp+808]
  00141	51		 push	 ecx
  00142	8d 94 24 d8 00
	00 00		 lea	 edx, DWORD PTR _ictx$[esp+812]
  00149	52		 push	 edx
  0014a	e8 00 00 00 00	 call	 _WHIRLPOOL_finalize

; 502  : 
; 503  : 	/**** Outer Digest ****/
; 504  : 
; 505  : 	WHIRLPOOL_init (&octx);

  0014f	8d 44 24 34	 lea	 eax, DWORD PTR _octx$[esp+816]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 _WHIRLPOOL_init
  00159	83 c4 24	 add	 esp, 36			; 00000024H

; 506  : 
; 507  : 	for (i = 0; i < lk; ++i)

  0015c	33 c0		 xor	 eax, eax
  0015e	85 f6		 test	 esi, esi
  00160	7e 22		 jle	 SHORT $LN34@hmac_whirl
  00162	8d 8c 24 0c 02
	00 00		 lea	 ecx, DWORD PTR _buf$[esp+784]
  00169	2b f9		 sub	 edi, ecx
  0016b	eb 03 8d 49 00	 npad	 5
$LL36@hmac_whirl:

; 508  : 		buf[i] = (char) (k[i] ^ 0x5C);

  00170	8d 8c 04 0c 02
	00 00		 lea	 ecx, DWORD PTR _buf$[esp+eax+784]
  00177	8a 14 0f	 mov	 dl, BYTE PTR [edi+ecx]
  0017a	80 f2 5c	 xor	 dl, 92			; 0000005cH
  0017d	40		 inc	 eax
  0017e	3b c6		 cmp	 eax, esi
  00180	88 11		 mov	 BYTE PTR [ecx], dl
  00182	7c ec		 jl	 SHORT $LL36@hmac_whirl
$LN34@hmac_whirl:

; 509  : 	for (i = lk; i < WHIRLPOOL_BLOCKSIZE; ++i)

  00184	83 fe 40	 cmp	 esi, 64			; 00000040H
  00187	7d 1a		 jge	 SHORT $LN33@hmac_whirl
  00189	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0018e	2b ce		 sub	 ecx, esi
  00190	51		 push	 ecx
  00191	8d 84 34 10 02
	00 00		 lea	 eax, DWORD PTR _buf$[esp+esi+788]
  00198	6a 5c		 push	 92			; 0000005cH
  0019a	50		 push	 eax
  0019b	e8 00 00 00 00	 call	 _memset
  001a0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN33@hmac_whirl:

; 510  : 		buf[i] = 0x5C;
; 511  : 
; 512  : 	WHIRLPOOL_add ((unsigned char *) buf, WHIRLPOOL_BLOCKSIZE * 8, &octx);

  001a3	8d 54 24 14	 lea	 edx, DWORD PTR _octx$[esp+784]
  001a7	52		 push	 edx
  001a8	8d 84 24 10 02
	00 00		 lea	 eax, DWORD PTR _buf$[esp+788]
  001af	68 00 02 00 00	 push	 512			; 00000200H
  001b4	50		 push	 eax
  001b5	e8 00 00 00 00	 call	 _WHIRLPOOL_add

; 513  : 	WHIRLPOOL_add ((unsigned char *) iwhi, WHIRLPOOL_DIGESTSIZE * 8, &octx);

  001ba	8d 4c 24 20	 lea	 ecx, DWORD PTR _octx$[esp+796]
  001be	51		 push	 ecx
  001bf	8d 94 24 5c 02
	00 00		 lea	 edx, DWORD PTR _iwhi$[esp+800]
  001c6	68 00 02 00 00	 push	 512			; 00000200H
  001cb	52		 push	 edx
  001cc	e8 00 00 00 00	 call	 _WHIRLPOOL_add

; 514  : 
; 515  : 	WHIRLPOOL_finalize (&octx, (unsigned char *) owhi);

  001d1	8d 84 24 e4 02
	00 00		 lea	 eax, DWORD PTR _owhi$[esp+808]
  001d8	50		 push	 eax
  001d9	8d 4c 24 30	 lea	 ecx, DWORD PTR _octx$[esp+812]
  001dd	51		 push	 ecx
  001de	e8 00 00 00 00	 call	 _WHIRLPOOL_finalize

; 516  : 
; 517  : 	/* truncate and print the results */
; 518  : 	t = t > WHIRLPOOL_DIGESTSIZE ? WHIRLPOOL_DIGESTSIZE : t;

  001e3	8b 84 24 48 03
	00 00		 mov	 eax, DWORD PTR _t$[esp+812]
  001ea	83 c4 20	 add	 esp, 32			; 00000020H
  001ed	83 f8 40	 cmp	 eax, 64			; 00000040H
  001f0	7e 05		 jle	 SHORT $LN51@hmac_whirl
  001f2	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
$LN51@hmac_whirl:

; 519  : 	hmac_truncate (owhi, out, t);

  001f7	85 c0		 test	 eax, eax
  001f9	7e 16		 jle	 SHORT $LN30@hmac_whirl
  001fb	50		 push	 eax
  001fc	8b 44 24 14	 mov	 eax, DWORD PTR _out$GSCopy$[esp+788]
  00200	8d 94 24 d0 02
	00 00		 lea	 edx, DWORD PTR _owhi$[esp+788]
  00207	52		 push	 edx
  00208	50		 push	 eax
  00209	e8 00 00 00 00	 call	 _memcpy
  0020e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN30@hmac_whirl:

; 520  : 
; 521  : 	/* Prevent possible leaks. */
; 522  : 	burn (&ictx, sizeof(ictx));

  00211	8d 94 24 bc 00
	00 00		 lea	 edx, DWORD PTR _ictx$[esp+784]
  00218	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  0021d	8b f1		 mov	 esi, ecx
  0021f	8b c2		 mov	 eax, edx
$LL63@hmac_whirl:
  00221	c6 00 00	 mov	 BYTE PTR [eax], 0
  00224	40		 inc	 eax
  00225	83 ee 01	 sub	 esi, 1
  00228	75 f7		 jne	 SHORT $LL63@hmac_whirl
  0022a	8d 9b 00 00 00
	00		 npad	 6
$LL27@hmac_whirl:
  00230	49		 dec	 ecx
  00231	c6 02 00	 mov	 BYTE PTR [edx], 0
  00234	42		 inc	 edx
  00235	85 c9		 test	 ecx, ecx
  00237	75 f7		 jne	 SHORT $LL27@hmac_whirl

; 523  : 	burn (&octx, sizeof(octx));

  00239	8d 54 24 14	 lea	 edx, DWORD PTR _octx$[esp+784]
  0023d	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  00242	8b f1		 mov	 esi, ecx
  00244	8b c2		 mov	 eax, edx
$LL67@hmac_whirl:
  00246	c6 00 00	 mov	 BYTE PTR [eax], 0
  00249	40		 inc	 eax
  0024a	83 ee 01	 sub	 esi, 1
  0024d	75 f7		 jne	 SHORT $LL67@hmac_whirl
  0024f	90		 npad	 1
$LL22@hmac_whirl:
  00250	49		 dec	 ecx
  00251	c6 02 00	 mov	 BYTE PTR [edx], 0
  00254	42		 inc	 edx
  00255	85 c9		 test	 ecx, ecx
  00257	75 f7		 jne	 SHORT $LL22@hmac_whirl

; 524  : 	burn (owhi, sizeof(owhi));

  00259	8d 94 24 cc 02
	00 00		 lea	 edx, DWORD PTR _owhi$[esp+784]
  00260	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00265	8b f1		 mov	 esi, ecx
  00267	8b c2		 mov	 eax, edx
  00269	8d a4 24 00 00
	00 00		 npad	 7
$LL71@hmac_whirl:
  00270	c6 00 00	 mov	 BYTE PTR [eax], 0
  00273	40		 inc	 eax
  00274	83 ee 01	 sub	 esi, 1
  00277	75 f7		 jne	 SHORT $LL71@hmac_whirl
  00279	8d a4 24 00 00
	00 00		 npad	 7
$LL17@hmac_whirl:
  00280	49		 dec	 ecx
  00281	c6 02 00	 mov	 BYTE PTR [edx], 0
  00284	42		 inc	 edx
  00285	85 c9		 test	 ecx, ecx
  00287	75 f7		 jne	 SHORT $LL17@hmac_whirl

; 525  : 	burn (iwhi, sizeof(iwhi));

  00289	8d 94 24 4c 02
	00 00		 lea	 edx, DWORD PTR _iwhi$[esp+784]
  00290	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00295	8b f1		 mov	 esi, ecx
  00297	8b c2		 mov	 eax, edx
  00299	8d a4 24 00 00
	00 00		 npad	 7
$LL75@hmac_whirl:
  002a0	c6 00 00	 mov	 BYTE PTR [eax], 0
  002a3	40		 inc	 eax
  002a4	83 ee 01	 sub	 esi, 1
  002a7	75 f7		 jne	 SHORT $LL75@hmac_whirl
  002a9	8d a4 24 00 00
	00 00		 npad	 7
$LL12@hmac_whirl:
  002b0	49		 dec	 ecx
  002b1	c6 02 00	 mov	 BYTE PTR [edx], 0
  002b4	42		 inc	 edx
  002b5	85 c9		 test	 ecx, ecx
  002b7	75 f7		 jne	 SHORT $LL12@hmac_whirl

; 526  : 	burn (buf, sizeof(buf));

  002b9	8d 94 24 0c 02
	00 00		 lea	 edx, DWORD PTR _buf$[esp+784]
  002c0	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  002c5	8b f1		 mov	 esi, ecx
  002c7	8b c2		 mov	 eax, edx
  002c9	8d a4 24 00 00
	00 00		 npad	 7
$LL79@hmac_whirl:
  002d0	c6 00 00	 mov	 BYTE PTR [eax], 0
  002d3	40		 inc	 eax
  002d4	83 ee 01	 sub	 esi, 1
  002d7	75 f7		 jne	 SHORT $LL79@hmac_whirl
  002d9	8d a4 24 00 00
	00 00		 npad	 7
$LL7@hmac_whirl:
  002e0	49		 dec	 ecx
  002e1	c6 02 00	 mov	 BYTE PTR [edx], 0
  002e4	42		 inc	 edx
  002e5	85 c9		 test	 ecx, ecx
  002e7	75 f7		 jne	 SHORT $LL7@hmac_whirl

; 527  : 	burn (key, sizeof(key));

  002e9	8d 94 24 8c 02
	00 00		 lea	 edx, DWORD PTR _key$[esp+784]
  002f0	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  002f5	8b f1		 mov	 esi, ecx
  002f7	8b c2		 mov	 eax, edx
  002f9	8d a4 24 00 00
	00 00		 npad	 7
$LL83@hmac_whirl:
  00300	c6 00 00	 mov	 BYTE PTR [eax], 0
  00303	40		 inc	 eax
  00304	83 ee 01	 sub	 esi, 1
  00307	75 f7		 jne	 SHORT $LL83@hmac_whirl
  00309	5f		 pop	 edi
  0030a	5e		 pop	 esi
  0030b	5d		 pop	 ebp
  0030c	5b		 pop	 ebx
  0030d	8d 49 00	 npad	 3
$LL2@hmac_whirl:
  00310	49		 dec	 ecx
  00311	c6 02 00	 mov	 BYTE PTR [edx], 0
  00314	42		 inc	 edx
  00315	85 c9		 test	 ecx, ecx
  00317	75 f7		 jne	 SHORT $LL2@hmac_whirl

; 528  : }

  00319	8b 8c 24 fc 02
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+768]
  00320	33 cc		 xor	 ecx, esp
  00322	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00327	81 c4 00 03 00
	00		 add	 esp, 768		; 00000300H
  0032d	c3		 ret	 0
_hmac_whirlpool ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_derive_u_whirlpool
; Function compile flags: /Ogtpy
;	COMDAT _derive_u_whirlpool
_TEXT	SEGMENT
_counter$ = -264					; size = 4
_j$ = -260						; size = 64
_k$ = -196						; size = 64
_init$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_u$ = 28						; size = 4
_b$ = 32						; size = 4
_derive_u_whirlpool PROC				; COMDAT

; 531  : {

  00000	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 04 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+264], eax
  00014	8b 84 24 14 01
	00 00		 mov	 eax, DWORD PTR _salt$[esp+260]

; 532  : 	char j[WHIRLPOOL_DIGESTSIZE], k[WHIRLPOOL_DIGESTSIZE];
; 533  : 	char init[128];
; 534  : 	char counter[4];
; 535  : 	int c, i;
; 536  : 
; 537  : 	/* iteration 1 */
; 538  : 	memset (counter, 0, 4);
; 539  : 	counter[3] = (char) b;

  0001b	8a 8c 24 24 01
	00 00		 mov	 cl, BYTE PTR _b$[esp+260]
  00022	53		 push	 ebx
  00023	8b 9c 24 24 01
	00 00		 mov	 ebx, DWORD PTR _u$[esp+264]
  0002a	55		 push	 ebp
  0002b	8b ac 24 14 01
	00 00		 mov	 ebp, DWORD PTR _pwd$[esp+268]
  00032	56		 push	 esi
  00033	8b b4 24 24 01
	00 00		 mov	 esi, DWORD PTR _salt_len$[esp+272]
  0003a	57		 push	 edi

; 540  : 	memcpy (init, salt, salt_len);	/* salt */

  0003b	56		 push	 esi
  0003c	50		 push	 eax
  0003d	8d 94 24 9c 00
	00 00		 lea	 edx, DWORD PTR _init$[esp+288]
  00044	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _counter$[esp+288], 0
  0004c	52		 push	 edx
  0004d	88 4c 24 1f	 mov	 BYTE PTR _counter$[esp+295], cl
  00051	e8 00 00 00 00	 call	 _memcpy

; 541  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */

  00056	8b 44 24 1c	 mov	 eax, DWORD PTR _counter$[esp+292]

; 542  : 	hmac_whirlpool (pwd, pwd_len, init, salt_len + 4, j, WHIRLPOOL_DIGESTSIZE);

  0005a	6a 40		 push	 64			; 00000040H
  0005c	89 84 34 a4 00
	00 00		 mov	 DWORD PTR _init$[esp+esi+296], eax
  00063	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR _pwd_len$[esp+292]
  0006a	8d 4c 24 24	 lea	 ecx, DWORD PTR _j$[esp+296]
  0006e	51		 push	 ecx
  0006f	83 c6 04	 add	 esi, 4
  00072	56		 push	 esi
  00073	8d 94 24 ac 00
	00 00		 lea	 edx, DWORD PTR _init$[esp+304]
  0007a	52		 push	 edx
  0007b	50		 push	 eax
  0007c	55		 push	 ebp
  0007d	e8 00 00 00 00	 call	 _hmac_whirlpool

; 543  : 	memcpy (u, j, WHIRLPOOL_DIGESTSIZE);
; 544  : 
; 545  : 	/* remaining iterations */
; 546  : 	for (c = 1; c < iterations; c++)

  00082	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR _iterations$[esp+312]
  00089	83 c4 24	 add	 esp, 36			; 00000024H
  0008c	83 f8 01	 cmp	 eax, 1
  0008f	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00094	8d 74 24 14	 lea	 esi, DWORD PTR _j$[esp+280]
  00098	8b fb		 mov	 edi, ebx
  0009a	f3 a5		 rep movsd
  0009c	7e 4d		 jle	 SHORT $LN10@derive_u_w
  0009e	8b f3		 mov	 esi, ebx
  000a0	8d 4c 24 54	 lea	 ecx, DWORD PTR _k$[esp+280]
  000a4	2b f1		 sub	 esi, ecx
  000a6	8d 78 ff	 lea	 edi, DWORD PTR [eax-1]
  000a9	8d a4 24 00 00
	00 00		 npad	 7
$LL16@derive_u_w:

; 547  : 	{
; 548  : 		hmac_whirlpool (pwd, pwd_len, j, WHIRLPOOL_DIGESTSIZE, k, WHIRLPOOL_DIGESTSIZE);

  000b0	8b 8c 24 20 01
	00 00		 mov	 ecx, DWORD PTR _pwd_len$[esp+276]
  000b7	6a 40		 push	 64			; 00000040H
  000b9	8d 54 24 58	 lea	 edx, DWORD PTR _k$[esp+284]
  000bd	52		 push	 edx
  000be	6a 40		 push	 64			; 00000040H
  000c0	8d 44 24 20	 lea	 eax, DWORD PTR _j$[esp+292]
  000c4	50		 push	 eax
  000c5	51		 push	 ecx
  000c6	55		 push	 ebp
  000c7	e8 00 00 00 00	 call	 _hmac_whirlpool
  000cc	83 c4 18	 add	 esp, 24			; 00000018H

; 549  : 		for (i = 0; i < WHIRLPOOL_DIGESTSIZE; i++)

  000cf	33 c0		 xor	 eax, eax
$LL13@derive_u_w:

; 550  : 		{
; 551  : 			u[i] ^= k[i];

  000d1	8a 54 04 54	 mov	 dl, BYTE PTR _k$[esp+eax+280]
  000d5	8d 4c 04 54	 lea	 ecx, DWORD PTR _k$[esp+eax+280]
  000d9	30 14 0e	 xor	 BYTE PTR [esi+ecx], dl

; 552  : 			j[i] = k[i];

  000dc	88 54 04 14	 mov	 BYTE PTR _j$[esp+eax+280], dl
  000e0	40		 inc	 eax
  000e1	83 f8 40	 cmp	 eax, 64			; 00000040H
  000e4	7c eb		 jl	 SHORT $LL13@derive_u_w

; 543  : 	memcpy (u, j, WHIRLPOOL_DIGESTSIZE);
; 544  : 
; 545  : 	/* remaining iterations */
; 546  : 	for (c = 1; c < iterations; c++)

  000e6	83 ef 01	 sub	 edi, 1
  000e9	75 c5		 jne	 SHORT $LL16@derive_u_w
$LN10@derive_u_w:

; 553  : 		}
; 554  : 	}
; 555  : 
; 556  : 	/* Prevent possible leaks. */
; 557  : 	burn (j, sizeof(j));

  000eb	8d 54 24 14	 lea	 edx, DWORD PTR _j$[esp+280]
  000ef	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000f4	8b f1		 mov	 esi, ecx
  000f6	8b c2		 mov	 eax, edx
$LL20@derive_u_w:
  000f8	c6 00 00	 mov	 BYTE PTR [eax], 0
  000fb	40		 inc	 eax
  000fc	83 ee 01	 sub	 esi, 1
  000ff	75 f7		 jne	 SHORT $LL20@derive_u_w
$LL7@derive_u_w:
  00101	49		 dec	 ecx
  00102	c6 02 00	 mov	 BYTE PTR [edx], 0
  00105	42		 inc	 edx
  00106	85 c9		 test	 ecx, ecx
  00108	75 f7		 jne	 SHORT $LL7@derive_u_w

; 558  : 	burn (k, sizeof(k));

  0010a	8d 54 24 54	 lea	 edx, DWORD PTR _k$[esp+280]
  0010e	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00113	8b f1		 mov	 esi, ecx
  00115	8b c2		 mov	 eax, edx
$LL24@derive_u_w:
  00117	c6 00 00	 mov	 BYTE PTR [eax], 0
  0011a	40		 inc	 eax
  0011b	83 ee 01	 sub	 esi, 1
  0011e	75 f7		 jne	 SHORT $LL24@derive_u_w
  00120	5f		 pop	 edi
  00121	5e		 pop	 esi
  00122	5d		 pop	 ebp
  00123	5b		 pop	 ebx
$LL2@derive_u_w:
  00124	49		 dec	 ecx
  00125	c6 02 00	 mov	 BYTE PTR [edx], 0
  00128	42		 inc	 edx
  00129	85 c9		 test	 ecx, ecx
  0012b	75 f7		 jne	 SHORT $LL2@derive_u_w

; 559  : }

  0012d	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+264]
  00134	33 cc		 xor	 ecx, esp
  00136	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013b	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  00141	c3		 ret	 0
_derive_u_whirlpool ENDP
_TEXT	ENDS
PUBLIC	_dk$GSCopy$
PUBLIC	_pwd$GSCopy$
PUBLIC	_salt$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_derive_key_whirlpool
; Function compile flags: /Ogtpy
;	COMDAT _derive_key_whirlpool
_TEXT	SEGMENT
_dk$GSCopy$ = -84					; size = 4
_pwd$GSCopy$ = -80					; size = 4
_salt$GSCopy$ = -76					; size = 4
_r$ = -72						; size = 4
_u$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_pwd$ = 8						; size = 4
_pwd_len$ = 12						; size = 4
_salt$ = 16						; size = 4
_salt_len$ = 20						; size = 4
_iterations$ = 24					; size = 4
_dk$ = 28						; size = 4
_dklen$ = 32						; size = 4
_derive_key_whirlpool PROC				; COMDAT

; 562  : {

  00000	83 ec 54	 sub	 esp, 84			; 00000054H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 50	 mov	 DWORD PTR __$ArrayPad$[esp+84], eax

; 573  : 	}
; 574  : 
; 575  : 	r = dklen - (l - 1) * WHIRLPOOL_DIGESTSIZE;

  0000e	8b 4c 24 60	 mov	 ecx, DWORD PTR _salt$[esp+80]
  00012	8b 44 24 58	 mov	 eax, DWORD PTR _pwd$[esp+80]
  00016	8b 54 24 6c	 mov	 edx, DWORD PTR _dk$[esp+80]
  0001a	89 4c 24 08	 mov	 DWORD PTR _salt$GSCopy$[esp+84], ecx
  0001e	8b 4c 24 70	 mov	 ecx, DWORD PTR _dklen$[esp+80]
  00022	53		 push	 ebx
  00023	89 44 24 08	 mov	 DWORD PTR _pwd$GSCopy$[esp+88], eax
  00027	8b c1		 mov	 eax, ecx
  00029	25 3f 00 00 80	 and	 eax, -2147483585	; 8000003fH
  0002e	55		 push	 ebp
  0002f	56		 push	 esi
  00030	89 54 24 0c	 mov	 DWORD PTR _dk$GSCopy$[esp+96], edx
  00034	79 05		 jns	 SHORT $LN29@derive_key@4
  00036	48		 dec	 eax
  00037	83 c8 c0	 or	 eax, -64		; ffffffc0H
  0003a	40		 inc	 eax
$LN29@derive_key@4:
  0003b	8b c1		 mov	 eax, ecx
  0003d	99		 cdq
  0003e	74 0d		 je	 SHORT $LN10@derive_key@4
  00040	83 e2 3f	 and	 edx, 63			; 0000003fH
  00043	03 c2		 add	 eax, edx
  00045	8b e8		 mov	 ebp, eax
  00047	c1 fd 06	 sar	 ebp, 6
  0004a	45		 inc	 ebp
  0004b	eb 0a		 jmp	 SHORT $LN9@derive_key@4
$LN10@derive_key@4:

; 563  : 	char u[WHIRLPOOL_DIGESTSIZE];
; 564  : 	int b, l, r;
; 565  : 
; 566  : 	if (dklen % WHIRLPOOL_DIGESTSIZE)
; 567  : 	{
; 568  : 		l = 1 + dklen / WHIRLPOOL_DIGESTSIZE;
; 569  : 	}
; 570  : 	else
; 571  : 	{
; 572  : 		l = dklen / WHIRLPOOL_DIGESTSIZE;

  0004d	83 e2 3f	 and	 edx, 63			; 0000003fH
  00050	03 c2		 add	 eax, edx
  00052	8b e8		 mov	 ebp, eax
  00054	c1 fd 06	 sar	 ebp, 6
$LN9@derive_key@4:

; 573  : 	}
; 574  : 
; 575  : 	r = dklen - (l - 1) * WHIRLPOOL_DIGESTSIZE;

  00057	8b d5		 mov	 edx, ebp
  00059	c1 e2 06	 shl	 edx, 6
  0005c	2b ca		 sub	 ecx, edx
  0005e	83 c1 40	 add	 ecx, 64			; 00000040H

; 576  : 
; 577  : 	/* first l - 1 blocks */
; 578  : 	for (b = 1; b < l; b++)

  00061	bb 01 00 00 00	 mov	 ebx, 1
  00066	3b eb		 cmp	 ebp, ebx
  00068	89 4c 24 18	 mov	 DWORD PTR _r$[esp+96], ecx
  0006c	7e 43		 jle	 SHORT $LN6@derive_key@4
  0006e	57		 push	 edi
  0006f	90		 npad	 1
$LL27@derive_key@4:

; 579  : 	{
; 580  : 		derive_u_whirlpool (pwd, pwd_len, salt, salt_len, iterations, u, b);

  00070	8b 4c 24 78	 mov	 ecx, DWORD PTR _iterations$[esp+96]
  00074	8b 54 24 74	 mov	 edx, DWORD PTR _salt_len$[esp+96]
  00078	53		 push	 ebx
  00079	8d 44 24 24	 lea	 eax, DWORD PTR _u$[esp+104]
  0007d	50		 push	 eax
  0007e	8b 44 24 20	 mov	 eax, DWORD PTR _salt$GSCopy$[esp+108]
  00082	51		 push	 ecx
  00083	8b 4c 24 78	 mov	 ecx, DWORD PTR _pwd_len$[esp+108]
  00087	52		 push	 edx
  00088	8b 54 24 24	 mov	 edx, DWORD PTR _pwd$GSCopy$[esp+116]
  0008c	50		 push	 eax
  0008d	51		 push	 ecx
  0008e	52		 push	 edx
  0008f	e8 00 00 00 00	 call	 _derive_u_whirlpool

; 581  : 		memcpy (dk, u, WHIRLPOOL_DIGESTSIZE);

  00094	8b 7c 24 2c	 mov	 edi, DWORD PTR _dk$GSCopy$[esp+128]

; 582  : 		dk += WHIRLPOOL_DIGESTSIZE;

  00098	83 44 24 2c 40	 add	 DWORD PTR _dk$GSCopy$[esp+128], 64 ; 00000040H
  0009d	43		 inc	 ebx
  0009e	83 c4 1c	 add	 esp, 28			; 0000001cH
  000a1	3b dd		 cmp	 ebx, ebp
  000a3	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  000a8	8d 74 24 20	 lea	 esi, DWORD PTR _u$[esp+100]
  000ac	f3 a5		 rep movsd
  000ae	7c c0		 jl	 SHORT $LL27@derive_key@4
  000b0	5f		 pop	 edi
$LN6@derive_key@4:

; 583  : 	}
; 584  : 
; 585  : 	/* last block */
; 586  : 	derive_u_whirlpool (pwd, pwd_len, salt, salt_len, iterations, u, b);

  000b1	8b 4c 24 74	 mov	 ecx, DWORD PTR _iterations$[esp+92]
  000b5	8b 54 24 70	 mov	 edx, DWORD PTR _salt_len$[esp+92]
  000b9	53		 push	 ebx
  000ba	8d 44 24 20	 lea	 eax, DWORD PTR _u$[esp+100]
  000be	50		 push	 eax
  000bf	8b 44 24 1c	 mov	 eax, DWORD PTR _salt$GSCopy$[esp+104]
  000c3	51		 push	 ecx
  000c4	8b 4c 24 74	 mov	 ecx, DWORD PTR _pwd_len$[esp+104]
  000c8	52		 push	 edx
  000c9	8b 54 24 20	 mov	 edx, DWORD PTR _pwd$GSCopy$[esp+112]
  000cd	50		 push	 eax
  000ce	51		 push	 ecx
  000cf	52		 push	 edx
  000d0	e8 00 00 00 00	 call	 _derive_u_whirlpool

; 587  : 	memcpy (dk, u, r);

  000d5	8b 44 24 34	 mov	 eax, DWORD PTR _r$[esp+124]
  000d9	8b 54 24 28	 mov	 edx, DWORD PTR _dk$GSCopy$[esp+124]
  000dd	50		 push	 eax
  000de	8d 4c 24 3c	 lea	 ecx, DWORD PTR _u$[esp+128]
  000e2	51		 push	 ecx
  000e3	52		 push	 edx
  000e4	e8 00 00 00 00	 call	 _memcpy

; 588  : 
; 589  : 
; 590  : 	/* Prevent possible leaks. */
; 591  : 	burn (u, sizeof(u));

  000e9	8d 54 24 44	 lea	 edx, DWORD PTR _u$[esp+136]
  000ed	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000f2	83 c4 28	 add	 esp, 40			; 00000028H
  000f5	8b f1		 mov	 esi, ecx
  000f7	8b c2		 mov	 eax, edx
  000f9	8d a4 24 00 00
	00 00		 npad	 7
$LL14@derive_key@4:
  00100	c6 00 00	 mov	 BYTE PTR [eax], 0
  00103	40		 inc	 eax
  00104	83 ee 01	 sub	 esi, 1
  00107	75 f7		 jne	 SHORT $LL14@derive_key@4
  00109	5e		 pop	 esi
  0010a	5d		 pop	 ebp
  0010b	5b		 pop	 ebx
  0010c	8d 64 24 00	 npad	 4
$LL2@derive_key@4:
  00110	49		 dec	 ecx
  00111	c6 02 00	 mov	 BYTE PTR [edx], 0
  00114	42		 inc	 edx
  00115	85 c9		 test	 ecx, ecx
  00117	75 f7		 jne	 SHORT $LL2@derive_key@4

; 592  : }

  00119	8b 4c 24 50	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+84]
  0011d	33 cc		 xor	 ecx, esp
  0011f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00124	83 c4 54	 add	 esp, 84			; 00000054H
  00127	c3		 ret	 0
_derive_key_whirlpool ENDP
_TEXT	ENDS
PUBLIC	??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@		; `string'
PUBLIC	??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@		; `string'
PUBLIC	??_C@_0BA@EMJCKHIJ@HMAC?9RIPEMD?9160?$AA@	; `string'
PUBLIC	??_C@_0L@GENPDEDH@HMAC?9SHA?91?$AA@		; `string'
PUBLIC	??_C@_0N@PGAIHMNP@HMAC?9SHA?9512?$AA@		; `string'
PUBLIC	_get_pkcs5_prf_name
;	COMDAT ??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@
CONST	SEGMENT
??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@ DB '(Unknown)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@
CONST	SEGMENT
??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@ DB 'HMAC-Whirlpool', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EMJCKHIJ@HMAC?9RIPEMD?9160?$AA@
CONST	SEGMENT
??_C@_0BA@EMJCKHIJ@HMAC?9RIPEMD?9160?$AA@ DB 'HMAC-RIPEMD-160', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GENPDEDH@HMAC?9SHA?91?$AA@
CONST	SEGMENT
??_C@_0L@GENPDEDH@HMAC?9SHA?91?$AA@ DB 'HMAC-SHA-1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PGAIHMNP@HMAC?9SHA?9512?$AA@
CONST	SEGMENT
??_C@_0N@PGAIHMNP@HMAC?9SHA?9512?$AA@ DB 'HMAC-SHA-512', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _get_pkcs5_prf_name
_TEXT	SEGMENT
_pkcs5_prf_id$ = 8					; size = 4
_get_pkcs5_prf_name PROC				; COMDAT

; 597  : 	switch (pkcs5_prf_id)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _pkcs5_prf_id$[esp-4]
  00004	48		 dec	 eax
  00005	83 f8 03	 cmp	 eax, 3
  00008	77 1f		 ja	 SHORT $LN1@get_pkcs5_
  0000a	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN10@get_pkcs5_[eax*4]
$LN5@get_pkcs5_:

; 598  : 	{
; 599  : 	case SHA512:	
; 600  : 		return "HMAC-SHA-512";

  00011	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0N@PGAIHMNP@HMAC?9SHA?9512?$AA@

; 613  : 	}
; 614  : }

  00016	c3		 ret	 0
$LN4@get_pkcs5_:

; 601  : 
; 602  : 	case SHA1:	// Deprecated/legacy
; 603  : 		return "HMAC-SHA-1";

  00017	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0L@GENPDEDH@HMAC?9SHA?91?$AA@

; 613  : 	}
; 614  : }

  0001c	c3		 ret	 0
$LN3@get_pkcs5_:

; 604  : 
; 605  : 	case RIPEMD160:	
; 606  : 		return "HMAC-RIPEMD-160";

  0001d	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BA@EMJCKHIJ@HMAC?9RIPEMD?9160?$AA@

; 613  : 	}
; 614  : }

  00022	c3		 ret	 0
$LN2@get_pkcs5_:

; 607  : 
; 608  : 	case WHIRLPOOL:	
; 609  : 		return "HMAC-Whirlpool";

  00023	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@

; 613  : 	}
; 614  : }

  00028	c3		 ret	 0
$LN1@get_pkcs5_:

; 610  : 
; 611  : 	default:		
; 612  : 		return "(Unknown)";

  00029	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@

; 613  : 	}
; 614  : }

  0002e	c3		 ret	 0
  0002f	90		 npad	 1
$LN10@get_pkcs5_:
  00030	00 00 00 00	 DD	 $LN3@get_pkcs5_
  00034	00 00 00 00	 DD	 $LN5@get_pkcs5_
  00038	00 00 00 00	 DD	 $LN2@get_pkcs5_
  0003c	00 00 00 00	 DD	 $LN4@get_pkcs5_
_get_pkcs5_prf_name ENDP
_TEXT	ENDS
PUBLIC	_get_pkcs5_iteration_count
; Function compile flags: /Ogtpy
;	COMDAT _get_pkcs5_iteration_count
_TEXT	SEGMENT
_pkcs5_prf_id$ = 8					; size = 4
_bBoot$ = 12						; size = 4
_get_pkcs5_iteration_count PROC				; COMDAT

; 621  : 	switch (pkcs5_prf_id)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _pkcs5_prf_id$[esp-4]
  00004	48		 dec	 eax
  00005	83 f8 03	 cmp	 eax, 3
  00008	77 26		 ja	 SHORT $LN1@get_pkcs5_@2
  0000a	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN10@get_pkcs5_@2[eax*4]
$LN5@get_pkcs5_@2:

; 622  : 	{
; 623  : 	case RIPEMD160:	
; 624  : 		return (bBoot ? 1000 : 2000);

  00011	8b 44 24 08	 mov	 eax, DWORD PTR _bBoot$[esp-4]
  00015	f7 d8		 neg	 eax
  00017	1b c0		 sbb	 eax, eax
  00019	25 18 fc ff ff	 and	 eax, -1000		; fffffc18H
  0001e	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H

; 642  : }

  00023	c3		 ret	 0
$LN4@get_pkcs5_@2:

; 625  : 
; 626  : #ifndef TC_WINDOWS_BOOT
; 627  : 
; 628  : 	case SHA512:	
; 629  : 		return 1000;			

  00024	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H

; 642  : }

  00029	c3		 ret	 0
$LN3@get_pkcs5_@2:

; 630  : 
; 631  : 	case SHA1:		// Deprecated/legacy		
; 632  : 		return 2000;			

  0002a	b8 d0 07 00 00	 mov	 eax, 2000		; 000007d0H

; 642  : }

  0002f	c3		 ret	 0
$LN1@get_pkcs5_@2:

; 633  : 
; 634  : 	case WHIRLPOOL:	
; 635  : 		return 1000;
; 636  : #endif
; 637  : 
; 638  : 	default:		
; 639  : 		TC_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID

  00030	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0

; 640  : 	}
; 641  : 	return 0;

  00037	33 c0		 xor	 eax, eax

; 642  : }

  00039	c3		 ret	 0
  0003a	8b ff		 npad	 2
$LN10@get_pkcs5_@2:
  0003c	00 00 00 00	 DD	 $LN5@get_pkcs5_@2
  00040	00 00 00 00	 DD	 $LN4@get_pkcs5_@2
  00044	00 00 00 00	 DD	 $LN4@get_pkcs5_@2
  00048	00 00 00 00	 DD	 $LN3@get_pkcs5_@2
_get_pkcs5_iteration_count ENDP
_TEXT	ENDS
END
