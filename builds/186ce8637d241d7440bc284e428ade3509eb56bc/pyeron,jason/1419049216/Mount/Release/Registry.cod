; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\home\public\Desktop\projects\cipherShed\src\Common\Registry.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_ReadLocalMachineRegistryDword
EXTRN	__imp__RegCloseKey@4:PROC
EXTRN	__imp__RegQueryValueExA@24:PROC
EXTRN	__imp__RegOpenKeyExA@20:PROC
; Function compile flags: /Ogtpy
; File c:\home\public\desktop\projects\ciphershed\src\common\registry.c
;	COMDAT _ReadLocalMachineRegistryDword
_TEXT	SEGMENT
_hkey$ = -12						; size = 4
_size$ = -8						; size = 4
_type$ = -4						; size = 4
_subKey$ = 8						; size = 4
_name$ = 12						; size = 4
_value$ = 16						; size = 4
_ReadLocalMachineRegistryDword PROC			; COMDAT

; 13   : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 14   : 	HKEY hkey = 0;
; 15   : 	DWORD size = sizeof (*value);
; 16   : 	DWORD type;
; 17   : 
; 18   : 	if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, subKey, 0, KEY_READ, &hkey) != ERROR_SUCCESS)

  00003	8b 4c 24 10	 mov	 ecx, DWORD PTR _subKey$[esp+8]
  00007	8d 04 24	 lea	 eax, DWORD PTR _hkey$[esp+12]
  0000a	50		 push	 eax
  0000b	68 19 00 02 00	 push	 131097			; 00020019H
  00010	6a 00		 push	 0
  00012	51		 push	 ecx
  00013	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00018	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _hkey$[esp+32], 0
  00020	c7 44 24 18 04
	00 00 00	 mov	 DWORD PTR _size$[esp+32], 4
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  0002e	85 c0		 test	 eax, eax

; 19   : 		return FALSE;

  00030	75 2f		 jne	 SHORT $LN5@ReadLocalM

; 20   : 
; 21   : 	if (RegQueryValueEx (hkey, name, NULL, &type, (BYTE *) value, &size) != ERROR_SUCCESS)

  00032	8b 44 24 18	 mov	 eax, DWORD PTR _value$[esp+8]
  00036	8d 54 24 04	 lea	 edx, DWORD PTR _size$[esp+12]
  0003a	52		 push	 edx
  0003b	8b 54 24 18	 mov	 edx, DWORD PTR _name$[esp+12]
  0003f	50		 push	 eax
  00040	8b 44 24 08	 mov	 eax, DWORD PTR _hkey$[esp+20]
  00044	8d 4c 24 10	 lea	 ecx, DWORD PTR _type$[esp+20]
  00048	51		 push	 ecx
  00049	6a 00		 push	 0
  0004b	52		 push	 edx
  0004c	50		 push	 eax
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  00053	85 c0		 test	 eax, eax
  00055	74 10		 je	 SHORT $LN1@ReadLocalM

; 22   : 	{
; 23   : 		RegCloseKey (hkey);

  00057	8b 0c 24	 mov	 ecx, DWORD PTR _hkey$[esp+12]
  0005a	51		 push	 ecx
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$LN5@ReadLocalM:

; 24   : 		return FALSE;

  00061	33 c0		 xor	 eax, eax

; 29   : }

  00063	83 c4 0c	 add	 esp, 12			; 0000000cH
  00066	c3		 ret	 0
$LN1@ReadLocalM:

; 25   : 	}
; 26   : 
; 27   : 	RegCloseKey (hkey);

  00067	8b 14 24	 mov	 edx, DWORD PTR _hkey$[esp+12]
  0006a	52		 push	 edx
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 28   : 	return type == REG_DWORD;

  00071	33 c0		 xor	 eax, eax
  00073	83 7c 24 08 04	 cmp	 DWORD PTR _type$[esp+12], 4
  00078	0f 94 c0	 sete	 al

; 29   : }

  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007e	c3		 ret	 0
_ReadLocalMachineRegistryDword ENDP
_TEXT	ENDS
PUBLIC	_ReadLocalMachineRegistryMultiString
; Function compile flags: /Ogtpy
;	COMDAT _ReadLocalMachineRegistryMultiString
_TEXT	SEGMENT
_hkey$ = -8						; size = 4
_type$ = -4						; size = 4
_subKey$ = 8						; size = 4
_name$ = 12						; size = 4
_value$ = 16						; size = 4
_size$ = 20						; size = 4
_ReadLocalMachineRegistryMultiString PROC		; COMDAT

; 32   : {

  00000	83 ec 08	 sub	 esp, 8

; 33   : 	HKEY hkey = 0;
; 34   : 	DWORD type;
; 35   : 
; 36   : 	if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, subKey, 0, KEY_READ, &hkey) != ERROR_SUCCESS)

  00003	8b 4c 24 0c	 mov	 ecx, DWORD PTR _subKey$[esp+4]
  00007	8d 04 24	 lea	 eax, DWORD PTR _hkey$[esp+8]
  0000a	50		 push	 eax
  0000b	68 19 00 02 00	 push	 131097			; 00020019H
  00010	6a 00		 push	 0
  00012	51		 push	 ecx
  00013	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00018	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _hkey$[esp+28], 0
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  00026	85 c0		 test	 eax, eax

; 37   : 		return FALSE;

  00028	75 2f		 jne	 SHORT $LN5@ReadLocalM@2

; 38   : 
; 39   : 	if (RegQueryValueEx (hkey, name, NULL, &type, (BYTE *) value, size) != ERROR_SUCCESS)

  0002a	8b 54 24 18	 mov	 edx, DWORD PTR _size$[esp+4]
  0002e	8b 44 24 14	 mov	 eax, DWORD PTR _value$[esp+4]
  00032	52		 push	 edx
  00033	8b 54 24 14	 mov	 edx, DWORD PTR _name$[esp+8]
  00037	50		 push	 eax
  00038	8b 44 24 08	 mov	 eax, DWORD PTR _hkey$[esp+16]
  0003c	8d 4c 24 0c	 lea	 ecx, DWORD PTR _type$[esp+16]
  00040	51		 push	 ecx
  00041	6a 00		 push	 0
  00043	52		 push	 edx
  00044	50		 push	 eax
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  0004b	85 c0		 test	 eax, eax
  0004d	74 10		 je	 SHORT $LN1@ReadLocalM@2

; 40   : 	{
; 41   : 		RegCloseKey (hkey);

  0004f	8b 0c 24	 mov	 ecx, DWORD PTR _hkey$[esp+8]
  00052	51		 push	 ecx
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$LN5@ReadLocalM@2:

; 42   : 		return FALSE;

  00059	33 c0		 xor	 eax, eax

; 47   : }

  0005b	83 c4 08	 add	 esp, 8
  0005e	c3		 ret	 0
$LN1@ReadLocalM@2:

; 43   : 	}
; 44   : 
; 45   : 	RegCloseKey (hkey);

  0005f	8b 14 24	 mov	 edx, DWORD PTR _hkey$[esp+8]
  00062	52		 push	 edx
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 46   : 	return type == REG_MULTI_SZ;

  00069	33 c0		 xor	 eax, eax
  0006b	83 7c 24 04 07	 cmp	 DWORD PTR _type$[esp+8], 7
  00070	0f 94 c0	 sete	 al

; 47   : }

  00073	83 c4 08	 add	 esp, 8
  00076	c3		 ret	 0
_ReadLocalMachineRegistryMultiString ENDP
_TEXT	ENDS
PUBLIC	_ReadLocalMachineRegistryString
; Function compile flags: /Ogtpy
;	COMDAT _ReadLocalMachineRegistryString
_TEXT	SEGMENT
_hkey$ = -8						; size = 4
_type$ = -4						; size = 4
_subKey$ = 8						; size = 4
_name$ = 12						; size = 4
_str$ = 16						; size = 4
_size$ = 20						; size = 4
_ReadLocalMachineRegistryString PROC			; COMDAT

; 50   : {

  00000	83 ec 08	 sub	 esp, 8

; 51   : 	HKEY hkey = 0;
; 52   : 	DWORD type;
; 53   : 
; 54   : 	if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, subKey, 0, KEY_READ, &hkey) != ERROR_SUCCESS)

  00003	8b 4c 24 0c	 mov	 ecx, DWORD PTR _subKey$[esp+4]
  00007	8d 04 24	 lea	 eax, DWORD PTR _hkey$[esp+8]
  0000a	50		 push	 eax
  0000b	68 19 00 02 00	 push	 131097			; 00020019H
  00010	6a 00		 push	 0
  00012	51		 push	 ecx
  00013	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00018	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _hkey$[esp+28], 0
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  00026	85 c0		 test	 eax, eax

; 55   : 		return FALSE;

  00028	75 2f		 jne	 SHORT $LN5@ReadLocalM@3

; 56   : 
; 57   : 	if (RegQueryValueEx (hkey, name, NULL, &type, (BYTE *) str, size) != ERROR_SUCCESS)

  0002a	8b 54 24 18	 mov	 edx, DWORD PTR _size$[esp+4]
  0002e	8b 44 24 14	 mov	 eax, DWORD PTR _str$[esp+4]
  00032	52		 push	 edx
  00033	8b 54 24 14	 mov	 edx, DWORD PTR _name$[esp+8]
  00037	50		 push	 eax
  00038	8b 44 24 08	 mov	 eax, DWORD PTR _hkey$[esp+16]
  0003c	8d 4c 24 0c	 lea	 ecx, DWORD PTR _type$[esp+16]
  00040	51		 push	 ecx
  00041	6a 00		 push	 0
  00043	52		 push	 edx
  00044	50		 push	 eax
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  0004b	85 c0		 test	 eax, eax
  0004d	74 10		 je	 SHORT $LN1@ReadLocalM@3

; 58   : 	{
; 59   : 		RegCloseKey (hkey);

  0004f	8b 0c 24	 mov	 ecx, DWORD PTR _hkey$[esp+8]
  00052	51		 push	 ecx
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$LN5@ReadLocalM@3:

; 60   : 		return FALSE;

  00059	33 c0		 xor	 eax, eax

; 65   : }

  0005b	83 c4 08	 add	 esp, 8
  0005e	c3		 ret	 0
$LN1@ReadLocalM@3:

; 61   : 	}
; 62   : 
; 63   : 	RegCloseKey (hkey);

  0005f	8b 14 24	 mov	 edx, DWORD PTR _hkey$[esp+8]
  00062	52		 push	 edx
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 64   : 	return type == REG_SZ;

  00069	33 c0		 xor	 eax, eax
  0006b	83 7c 24 04 01	 cmp	 DWORD PTR _type$[esp+8], 1
  00070	0f 94 c0	 sete	 al

; 65   : }

  00073	83 c4 08	 add	 esp, 8
  00076	c3		 ret	 0
_ReadLocalMachineRegistryString ENDP
_TEXT	ENDS
PUBLIC	_ReadLocalMachineRegistryStringNonReflected
; Function compile flags: /Ogtpy
;	COMDAT _ReadLocalMachineRegistryStringNonReflected
_TEXT	SEGMENT
_hkey$ = -8						; size = 4
_type$ = -4						; size = 4
_subKey$ = 8						; size = 4
_name$ = 12						; size = 4
_str$ = 16						; size = 4
_size$ = 20						; size = 4
_ReadLocalMachineRegistryStringNonReflected PROC	; COMDAT

; 68   : {

  00000	83 ec 08	 sub	 esp, 8

; 69   : 	HKEY hkey = 0;
; 70   : 	DWORD type;
; 71   : 
; 72   : 	if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, subKey, 0, KEY_READ | KEY_WOW64_64KEY, &hkey) != ERROR_SUCCESS)

  00003	8b 4c 24 0c	 mov	 ecx, DWORD PTR _subKey$[esp+4]
  00007	8d 04 24	 lea	 eax, DWORD PTR _hkey$[esp+8]
  0000a	50		 push	 eax
  0000b	68 19 01 02 00	 push	 131353			; 00020119H
  00010	6a 00		 push	 0
  00012	51		 push	 ecx
  00013	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00018	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _hkey$[esp+28], 0
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  00026	85 c0		 test	 eax, eax

; 73   : 		return FALSE;

  00028	75 2f		 jne	 SHORT $LN5@ReadLocalM@4

; 74   : 
; 75   : 	if (RegQueryValueEx (hkey, name, NULL, &type, (BYTE *) str, size) != ERROR_SUCCESS)

  0002a	8b 54 24 18	 mov	 edx, DWORD PTR _size$[esp+4]
  0002e	8b 44 24 14	 mov	 eax, DWORD PTR _str$[esp+4]
  00032	52		 push	 edx
  00033	8b 54 24 14	 mov	 edx, DWORD PTR _name$[esp+8]
  00037	50		 push	 eax
  00038	8b 44 24 08	 mov	 eax, DWORD PTR _hkey$[esp+16]
  0003c	8d 4c 24 0c	 lea	 ecx, DWORD PTR _type$[esp+16]
  00040	51		 push	 ecx
  00041	6a 00		 push	 0
  00043	52		 push	 edx
  00044	50		 push	 eax
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  0004b	85 c0		 test	 eax, eax
  0004d	74 10		 je	 SHORT $LN1@ReadLocalM@4

; 76   : 	{
; 77   : 		RegCloseKey (hkey);

  0004f	8b 0c 24	 mov	 ecx, DWORD PTR _hkey$[esp+8]
  00052	51		 push	 ecx
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$LN5@ReadLocalM@4:

; 78   : 		return FALSE;

  00059	33 c0		 xor	 eax, eax

; 83   : }

  0005b	83 c4 08	 add	 esp, 8
  0005e	c3		 ret	 0
$LN1@ReadLocalM@4:

; 79   : 	}
; 80   : 
; 81   : 	RegCloseKey (hkey);

  0005f	8b 14 24	 mov	 edx, DWORD PTR _hkey$[esp+8]
  00062	52		 push	 edx
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 82   : 	return type == REG_SZ;

  00069	33 c0		 xor	 eax, eax
  0006b	83 7c 24 04 01	 cmp	 DWORD PTR _type$[esp+8], 1
  00070	0f 94 c0	 sete	 al

; 83   : }

  00073	83 c4 08	 add	 esp, 8
  00076	c3		 ret	 0
_ReadLocalMachineRegistryStringNonReflected ENDP
_TEXT	ENDS
PUBLIC	_ReadRegistryInt
; Function compile flags: /Ogtpy
;	COMDAT _ReadRegistryInt
_TEXT	SEGMENT
_hkey$ = -12						; size = 4
_value$ = -8						; size = 4
_size$ = -4						; size = 4
_subKey$ = 8						; size = 4
_name$ = 12						; size = 4
_defaultValue$ = 16					; size = 4
_ReadRegistryInt PROC					; COMDAT

; 86   : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 87   : 	HKEY hkey = 0;
; 88   : 	DWORD value, size = sizeof (DWORD);
; 89   : 
; 90   : 	if (RegOpenKeyEx (HKEY_CURRENT_USER, subKey,
; 91   : 		0, KEY_READ, &hkey) != ERROR_SUCCESS)

  00003	8b 4c 24 10	 mov	 ecx, DWORD PTR _subKey$[esp+8]
  00007	8d 04 24	 lea	 eax, DWORD PTR _hkey$[esp+12]
  0000a	50		 push	 eax
  0000b	68 19 00 02 00	 push	 131097			; 00020019H
  00010	6a 00		 push	 0
  00012	51		 push	 ecx
  00013	68 01 00 00 80	 push	 -2147483647		; 80000001H
  00018	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _hkey$[esp+32], 0
  00020	c7 44 24 1c 04
	00 00 00	 mov	 DWORD PTR _size$[esp+32], 4
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  0002e	85 c0		 test	 eax, eax
  00030	74 08		 je	 SHORT $LN2@ReadRegist

; 92   : 		return defaultValue;

  00032	8b 44 24 18	 mov	 eax, DWORD PTR _defaultValue$[esp+8]

; 99   : }

  00036	83 c4 0c	 add	 esp, 12			; 0000000cH
  00039	c3		 ret	 0
$LN2@ReadRegist:

; 93   : 
; 94   : 	if (RegQueryValueEx (hkey, name, 0,	0, (LPBYTE) &value, &size) != ERROR_SUCCESS)

  0003a	8b 4c 24 14	 mov	 ecx, DWORD PTR _name$[esp+8]
  0003e	8d 54 24 08	 lea	 edx, DWORD PTR _size$[esp+12]
  00042	52		 push	 edx
  00043	8b 54 24 04	 mov	 edx, DWORD PTR _hkey$[esp+16]
  00047	8d 44 24 08	 lea	 eax, DWORD PTR _value$[esp+16]
  0004b	50		 push	 eax
  0004c	6a 00		 push	 0
  0004e	6a 00		 push	 0
  00050	51		 push	 ecx
  00051	52		 push	 edx
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  00058	85 c0		 test	 eax, eax
  0005a	74 08		 je	 SHORT $LN1@ReadRegist

; 95   : 		value = defaultValue;

  0005c	8b 44 24 18	 mov	 eax, DWORD PTR _defaultValue$[esp+8]
  00060	89 44 24 04	 mov	 DWORD PTR _value$[esp+12], eax
$LN1@ReadRegist:

; 96   : 
; 97   : 	RegCloseKey (hkey);

  00064	8b 0c 24	 mov	 ecx, DWORD PTR _hkey$[esp+12]
  00067	51		 push	 ecx
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 98   : 	return value;

  0006e	8b 44 24 04	 mov	 eax, DWORD PTR _value$[esp+12]

; 99   : }

  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
  00075	c3		 ret	 0
_ReadRegistryInt ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_ReadRegistryString
EXTRN	_strncpy:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogtpy
;	COMDAT _ReadRegistryString
_TEXT	SEGMENT
_hkey$ = -1052						; size = 4
_size$ = -1048						; size = 4
_value$ = -1044						; size = 1040
__$ArrayPad$ = -4					; size = 4
_subKey$ = 8						; size = 4
_name$ = 12						; size = 4
_defaultValue$ = 16					; size = 4
_str$ = 20						; size = 4
_maxLen$ = 24						; size = 4
_ReadRegistryString PROC				; COMDAT

; 102  : {

  00000	81 ec 1c 04 00
	00		 sub	 esp, 1052		; 0000041cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 18 04
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1052], eax
  00014	8b 84 24 28 04
	00 00		 mov	 eax, DWORD PTR _defaultValue$[esp+1048]
  0001b	53		 push	 ebx
  0001c	8b 9c 24 24 04
	00 00		 mov	 ebx, DWORD PTR _subKey$[esp+1052]
  00023	55		 push	 ebp
  00024	8b ac 24 2c 04
	00 00		 mov	 ebp, DWORD PTR _name$[esp+1056]
  0002b	56		 push	 esi
  0002c	8b b4 24 38 04
	00 00		 mov	 esi, DWORD PTR _str$[esp+1060]
  00033	57		 push	 edi

; 103  : 	HKEY hkey = 0;
; 104  : 	char value[MAX_PATH*4];
; 105  : 	DWORD size = sizeof (value);
; 106  : 
; 107  : 	strncpy (str, defaultValue, maxLen-1);

  00034	8b bc 24 40 04
	00 00		 mov	 edi, DWORD PTR _maxLen$[esp+1064]
  0003b	4f		 dec	 edi
  0003c	57		 push	 edi
  0003d	50		 push	 eax
  0003e	56		 push	 esi
  0003f	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _hkey$[esp+1080], 0
  00047	c7 44 24 20 10
	04 00 00	 mov	 DWORD PTR _size$[esp+1080], 1040 ; 00000410H
  0004f	e8 00 00 00 00	 call	 _strncpy

; 108  : 
; 109  : 	ZeroMemory (value, sizeof value);

  00054	68 10 04 00 00	 push	 1040			; 00000410H
  00059	8d 44 24 28	 lea	 eax, DWORD PTR _value$[esp+1084]
  0005d	6a 00		 push	 0
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 _memset
  00065	83 c4 18	 add	 esp, 24			; 00000018H

; 110  : 	if (RegOpenKeyEx (HKEY_CURRENT_USER, subKey,
; 111  : 		0, KEY_READ, &hkey) == ERROR_SUCCESS)

  00068	8d 4c 24 10	 lea	 ecx, DWORD PTR _hkey$[esp+1068]
  0006c	51		 push	 ecx
  0006d	68 19 00 02 00	 push	 131097			; 00020019H
  00072	6a 00		 push	 0
  00074	53		 push	 ebx
  00075	68 01 00 00 80	 push	 -2147483647		; 80000001H
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  00080	85 c0		 test	 eax, eax
  00082	75 2d		 jne	 SHORT $LN1@ReadRegist@2

; 112  : 		if (RegQueryValueEx (hkey, name, 0,	0, (LPBYTE) &value,	&size) == ERROR_SUCCESS)

  00084	8b 4c 24 10	 mov	 ecx, DWORD PTR _hkey$[esp+1068]
  00088	8d 54 24 14	 lea	 edx, DWORD PTR _size$[esp+1068]
  0008c	52		 push	 edx
  0008d	8d 44 24 1c	 lea	 eax, DWORD PTR _value$[esp+1072]
  00091	50		 push	 eax
  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	55		 push	 ebp
  00097	51		 push	 ecx
  00098	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  0009e	85 c0		 test	 eax, eax
  000a0	75 0f		 jne	 SHORT $LN1@ReadRegist@2

; 113  : 			strncpy (str, value, maxLen-1);

  000a2	57		 push	 edi
  000a3	8d 54 24 1c	 lea	 edx, DWORD PTR _value$[esp+1072]
  000a7	52		 push	 edx
  000a8	56		 push	 esi
  000a9	e8 00 00 00 00	 call	 _strncpy
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@ReadRegist@2:

; 114  : 
; 115  : 	RegCloseKey (hkey);

  000b1	8b 44 24 10	 mov	 eax, DWORD PTR _hkey$[esp+1068]
  000b5	50		 push	 eax
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 116  : 	return str;
; 117  : }

  000bc	8b 8c 24 28 04
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1068]
  000c3	5f		 pop	 edi
  000c4	8b c6		 mov	 eax, esi
  000c6	5e		 pop	 esi
  000c7	5d		 pop	 ebp
  000c8	5b		 pop	 ebx
  000c9	33 cc		 xor	 ecx, esp
  000cb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d0	81 c4 1c 04 00
	00		 add	 esp, 1052		; 0000041cH
  000d6	c3		 ret	 0
_ReadRegistryString ENDP
_TEXT	ENDS
PUBLIC	_ReadRegistryBytes
; Function compile flags: /Ogtpy
;	COMDAT _ReadRegistryBytes
_TEXT	SEGMENT
_hkey$ = -4						; size = 4
_path$ = 8						; size = 4
_name$ = 12						; size = 4
_value$ = 16						; size = 4
_size$ = 20						; size = 4
_maxLen$ = 20						; size = 4
_ReadRegistryBytes PROC					; COMDAT

; 120  : {

  00000	51		 push	 ecx

; 121  : 	HKEY hkey = 0;
; 122  : 	DWORD size = maxLen;
; 123  : 	BOOL success = FALSE;
; 124  : 
; 125  : 	if (RegOpenKeyEx (HKEY_CURRENT_USER, path, 0, KEY_READ, &hkey) != ERROR_SUCCESS)

  00001	8b 54 24 08	 mov	 edx, DWORD PTR _path$[esp]
  00005	8b 44 24 14	 mov	 eax, DWORD PTR _maxLen$[esp]
  00009	8d 0c 24	 lea	 ecx, DWORD PTR _hkey$[esp+4]
  0000c	51		 push	 ecx
  0000d	68 19 00 02 00	 push	 131097			; 00020019H
  00012	6a 00		 push	 0
  00014	52		 push	 edx
  00015	68 01 00 00 80	 push	 -2147483647		; 80000001H
  0001a	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _hkey$[esp+24], 0
  00022	89 44 24 28	 mov	 DWORD PTR _size$[esp+20], eax
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  0002c	85 c0		 test	 eax, eax
  0002e	74 04		 je	 SHORT $LN1@ReadRegist@3

; 126  : 		return 0;

  00030	33 c0		 xor	 eax, eax

; 132  : }

  00032	59		 pop	 ecx
  00033	c3		 ret	 0
$LN1@ReadRegist@3:

; 127  : 
; 128  : 	success = (RegQueryValueEx (hkey, name, 0,	0, (LPBYTE) value,	&size) == ERROR_SUCCESS);

  00034	8b 4c 24 10	 mov	 ecx, DWORD PTR _value$[esp]
  00038	8b 54 24 0c	 mov	 edx, DWORD PTR _name$[esp]
  0003c	56		 push	 esi
  0003d	8d 44 24 18	 lea	 eax, DWORD PTR _size$[esp+4]
  00041	50		 push	 eax
  00042	8b 44 24 08	 mov	 eax, DWORD PTR _hkey$[esp+12]
  00046	51		 push	 ecx
  00047	6a 00		 push	 0
  00049	6a 00		 push	 0
  0004b	52		 push	 edx
  0004c	50		 push	 eax
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24

; 129  : 	RegCloseKey (hkey);

  00053	8b 4c 24 04	 mov	 ecx, DWORD PTR _hkey$[esp+8]
  00057	8b f0		 mov	 esi, eax
  00059	f7 de		 neg	 esi
  0005b	1b f6		 sbb	 esi, esi
  0005d	51		 push	 ecx
  0005e	46		 inc	 esi
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 130  : 
; 131  : 	return success ? size : 0;

  00065	8b c6		 mov	 eax, esi
  00067	f7 d8		 neg	 eax
  00069	1b c0		 sbb	 eax, eax
  0006b	23 44 24 18	 and	 eax, DWORD PTR _size$[esp+4]
  0006f	5e		 pop	 esi

; 132  : }

  00070	59		 pop	 ecx
  00071	c3		 ret	 0
_ReadRegistryBytes ENDP
_TEXT	ENDS
PUBLIC	_WriteRegistryInt
EXTRN	__imp__RegSetValueExA@24:PROC
EXTRN	__imp__RegCreateKeyExA@36:PROC
; Function compile flags: /Ogtpy
;	COMDAT _WriteRegistryInt
_TEXT	SEGMENT
_hkey$ = -8						; size = 4
_disp$ = -4						; size = 4
_subKey$ = 8						; size = 4
_name$ = 12						; size = 4
_value$ = 16						; size = 4
_WriteRegistryInt PROC					; COMDAT

; 135  : {

  00000	83 ec 08	 sub	 esp, 8

; 136  : 	HKEY hkey = 0;
; 137  : 	DWORD disp;
; 138  : 
; 139  : 	if (RegCreateKeyEx (HKEY_CURRENT_USER, subKey,
; 140  : 		0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &disp) != ERROR_SUCCESS)

  00003	8b 54 24 0c	 mov	 edx, DWORD PTR _subKey$[esp+4]
  00007	8d 44 24 04	 lea	 eax, DWORD PTR _disp$[esp+8]
  0000b	50		 push	 eax
  0000c	8d 4c 24 04	 lea	 ecx, DWORD PTR _hkey$[esp+12]
  00010	51		 push	 ecx
  00011	6a 00		 push	 0
  00013	68 06 00 02 00	 push	 131078			; 00020006H
  00018	6a 00		 push	 0
  0001a	6a 00		 push	 0
  0001c	6a 00		 push	 0
  0001e	52		 push	 edx
  0001f	68 01 00 00 80	 push	 -2147483647		; 80000001H
  00024	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _hkey$[esp+44], 0
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCreateKeyExA@36
  00032	85 c0		 test	 eax, eax
  00034	75 24		 jne	 SHORT $LN2@WriteRegis

; 141  : 		return;
; 142  : 
; 143  : 	RegSetValueEx (hkey, name, 0, REG_DWORD, (BYTE *) &value, sizeof value);

  00036	8b 4c 24 10	 mov	 ecx, DWORD PTR _name$[esp+4]
  0003a	8b 14 24	 mov	 edx, DWORD PTR _hkey$[esp+8]
  0003d	6a 04		 push	 4
  0003f	8d 44 24 18	 lea	 eax, DWORD PTR _value$[esp+8]
  00043	50		 push	 eax
  00044	6a 04		 push	 4
  00046	6a 00		 push	 0
  00048	51		 push	 ecx
  00049	52		 push	 edx
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24

; 144  : 	RegCloseKey (hkey);

  00050	8b 04 24	 mov	 eax, DWORD PTR _hkey$[esp+8]
  00053	50		 push	 eax
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$LN2@WriteRegis:

; 145  : }

  0005a	83 c4 08	 add	 esp, 8
  0005d	c3		 ret	 0
_WriteRegistryInt ENDP
_TEXT	ENDS
PUBLIC	_WriteLocalMachineRegistryDword
EXTRN	__imp__SetLastError@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT _WriteLocalMachineRegistryDword
_TEXT	SEGMENT
_hkey$ = -8						; size = 4
_disp$ = -4						; size = 4
_subKey$ = 8						; size = 4
_name$ = 12						; size = 4
_value$ = 16						; size = 4
_WriteLocalMachineRegistryDword PROC			; COMDAT

; 148  : {

  00000	83 ec 08	 sub	 esp, 8

; 149  : 	HKEY hkey = 0;
; 150  : 	DWORD disp;
; 151  : 	LONG status;
; 152  : 
; 153  : 	if ((status = RegCreateKeyEx (HKEY_LOCAL_MACHINE, subKey,
; 154  : 		0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &disp)) != ERROR_SUCCESS)

  00003	8b 54 24 0c	 mov	 edx, DWORD PTR _subKey$[esp+4]
  00007	8d 44 24 04	 lea	 eax, DWORD PTR _disp$[esp+8]
  0000b	50		 push	 eax
  0000c	8d 4c 24 04	 lea	 ecx, DWORD PTR _hkey$[esp+12]
  00010	51		 push	 ecx
  00011	6a 00		 push	 0
  00013	68 06 00 02 00	 push	 131078			; 00020006H
  00018	6a 00		 push	 0
  0001a	6a 00		 push	 0
  0001c	6a 00		 push	 0
  0001e	52		 push	 edx
  0001f	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00024	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _hkey$[esp+44], 0
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCreateKeyExA@36
  00032	85 c0		 test	 eax, eax
  00034	74 0d		 je	 SHORT $LN2@WriteLocal

; 155  : 	{
; 156  : 		SetLastError (status);

  00036	50		 push	 eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 157  : 		return FALSE;

  0003d	33 c0		 xor	 eax, eax

; 169  : }

  0003f	83 c4 08	 add	 esp, 8
  00042	c3		 ret	 0
$LN2@WriteLocal:

; 158  : 	}
; 159  : 
; 160  : 	if ((status = RegSetValueEx (hkey, name, 0, REG_DWORD, (BYTE *) &value, sizeof value)) != ERROR_SUCCESS)

  00043	8b 4c 24 10	 mov	 ecx, DWORD PTR _name$[esp+4]
  00047	8b 14 24	 mov	 edx, DWORD PTR _hkey$[esp+8]
  0004a	56		 push	 esi
  0004b	6a 04		 push	 4
  0004d	8d 44 24 1c	 lea	 eax, DWORD PTR _value$[esp+12]
  00051	50		 push	 eax
  00052	6a 04		 push	 4
  00054	6a 00		 push	 0
  00056	51		 push	 ecx
  00057	52		 push	 edx
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24
  0005e	8b f0		 mov	 esi, eax
  00060	85 f6		 test	 esi, esi
  00062	74 19		 je	 SHORT $LN1@WriteLocal

; 161  : 	{
; 162  : 		RegCloseKey (hkey);

  00064	8b 44 24 04	 mov	 eax, DWORD PTR _hkey$[esp+12]
  00068	50		 push	 eax
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 163  : 		SetLastError (status);

  0006f	56		 push	 esi
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 164  : 		return FALSE;

  00076	33 c0		 xor	 eax, eax
  00078	5e		 pop	 esi

; 169  : }

  00079	83 c4 08	 add	 esp, 8
  0007c	c3		 ret	 0
$LN1@WriteLocal:

; 165  : 	}
; 166  : 
; 167  : 	RegCloseKey (hkey);

  0007d	8b 4c 24 04	 mov	 ecx, DWORD PTR _hkey$[esp+12]
  00081	51		 push	 ecx
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 168  : 	return TRUE;

  00088	b8 01 00 00 00	 mov	 eax, 1
  0008d	5e		 pop	 esi

; 169  : }

  0008e	83 c4 08	 add	 esp, 8
  00091	c3		 ret	 0
_WriteLocalMachineRegistryDword ENDP
_TEXT	ENDS
PUBLIC	_WriteLocalMachineRegistryMultiString
; Function compile flags: /Ogtpy
;	COMDAT _WriteLocalMachineRegistryMultiString
_TEXT	SEGMENT
_hkey$ = -8						; size = 4
_disp$ = -4						; size = 4
_subKey$ = 8						; size = 4
_name$ = 12						; size = 4
_multiString$ = 16					; size = 4
_size$ = 20						; size = 4
_WriteLocalMachineRegistryMultiString PROC		; COMDAT

; 172  : {

  00000	83 ec 08	 sub	 esp, 8

; 173  : 	HKEY hkey = 0;
; 174  : 	DWORD disp;
; 175  : 	LONG status;
; 176  : 
; 177  : 	if ((status = RegCreateKeyEx (HKEY_LOCAL_MACHINE, subKey,
; 178  : 		0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &disp)) != ERROR_SUCCESS)

  00003	8b 54 24 0c	 mov	 edx, DWORD PTR _subKey$[esp+4]
  00007	8d 44 24 04	 lea	 eax, DWORD PTR _disp$[esp+8]
  0000b	50		 push	 eax
  0000c	8d 4c 24 04	 lea	 ecx, DWORD PTR _hkey$[esp+12]
  00010	51		 push	 ecx
  00011	6a 00		 push	 0
  00013	68 06 00 02 00	 push	 131078			; 00020006H
  00018	6a 00		 push	 0
  0001a	6a 00		 push	 0
  0001c	6a 00		 push	 0
  0001e	52		 push	 edx
  0001f	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00024	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _hkey$[esp+44], 0
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCreateKeyExA@36
  00032	85 c0		 test	 eax, eax
  00034	74 0d		 je	 SHORT $LN2@WriteLocal@2

; 179  : 	{
; 180  : 		SetLastError (status);

  00036	50		 push	 eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 181  : 		return FALSE;

  0003d	33 c0		 xor	 eax, eax

; 193  : }

  0003f	83 c4 08	 add	 esp, 8
  00042	c3		 ret	 0
$LN2@WriteLocal@2:

; 182  : 	}
; 183  : 
; 184  : 	if ((status = RegSetValueEx (hkey, name, 0, REG_MULTI_SZ, (BYTE *) multiString, size)) != ERROR_SUCCESS)

  00043	8b 44 24 18	 mov	 eax, DWORD PTR _size$[esp+4]
  00047	8b 4c 24 14	 mov	 ecx, DWORD PTR _multiString$[esp+4]
  0004b	8b 54 24 10	 mov	 edx, DWORD PTR _name$[esp+4]
  0004f	56		 push	 esi
  00050	50		 push	 eax
  00051	8b 44 24 08	 mov	 eax, DWORD PTR _hkey$[esp+16]
  00055	51		 push	 ecx
  00056	6a 07		 push	 7
  00058	6a 00		 push	 0
  0005a	52		 push	 edx
  0005b	50		 push	 eax
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24
  00062	8b f0		 mov	 esi, eax
  00064	85 f6		 test	 esi, esi
  00066	74 19		 je	 SHORT $LN1@WriteLocal@2

; 185  : 	{
; 186  : 		RegCloseKey (hkey);

  00068	8b 4c 24 04	 mov	 ecx, DWORD PTR _hkey$[esp+12]
  0006c	51		 push	 ecx
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 187  : 		SetLastError (status);

  00073	56		 push	 esi
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 188  : 		return FALSE;

  0007a	33 c0		 xor	 eax, eax
  0007c	5e		 pop	 esi

; 193  : }

  0007d	83 c4 08	 add	 esp, 8
  00080	c3		 ret	 0
$LN1@WriteLocal@2:

; 189  : 	}
; 190  : 
; 191  : 	RegCloseKey (hkey);

  00081	8b 54 24 04	 mov	 edx, DWORD PTR _hkey$[esp+12]
  00085	52		 push	 edx
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 192  : 	return TRUE;

  0008c	b8 01 00 00 00	 mov	 eax, 1
  00091	5e		 pop	 esi

; 193  : }

  00092	83 c4 08	 add	 esp, 8
  00095	c3		 ret	 0
_WriteLocalMachineRegistryMultiString ENDP
_TEXT	ENDS
PUBLIC	_WriteLocalMachineRegistryString
; Function compile flags: /Ogtpy
;	COMDAT _WriteLocalMachineRegistryString
_TEXT	SEGMENT
_hkey$ = -8						; size = 4
_disp$ = -4						; size = 4
_subKey$ = 8						; size = 4
_name$ = 12						; size = 4
_str$ = 16						; size = 4
_expandable$ = 20					; size = 4
_WriteLocalMachineRegistryString PROC			; COMDAT

; 196  : {

  00000	83 ec 08	 sub	 esp, 8

; 197  : 	HKEY hkey = 0;
; 198  : 	DWORD disp;
; 199  : 	LONG status;
; 200  : 
; 201  : 	if ((status = RegCreateKeyEx (HKEY_LOCAL_MACHINE, subKey,
; 202  : 		0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &disp)) != ERROR_SUCCESS)

  00003	8b 54 24 0c	 mov	 edx, DWORD PTR _subKey$[esp+4]
  00007	8d 44 24 04	 lea	 eax, DWORD PTR _disp$[esp+8]
  0000b	50		 push	 eax
  0000c	8d 4c 24 04	 lea	 ecx, DWORD PTR _hkey$[esp+12]
  00010	51		 push	 ecx
  00011	6a 00		 push	 0
  00013	68 06 00 02 00	 push	 131078			; 00020006H
  00018	6a 00		 push	 0
  0001a	6a 00		 push	 0
  0001c	6a 00		 push	 0
  0001e	52		 push	 edx
  0001f	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00024	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _hkey$[esp+44], 0
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCreateKeyExA@36
  00032	85 c0		 test	 eax, eax
  00034	74 0d		 je	 SHORT $LN2@WriteLocal@3

; 203  : 	{
; 204  : 		SetLastError (status);

  00036	50		 push	 eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 205  : 		return FALSE;

  0003d	33 c0		 xor	 eax, eax

; 217  : }

  0003f	83 c4 08	 add	 esp, 8
  00042	c3		 ret	 0
$LN2@WriteLocal@3:

; 206  : 	}
; 207  : 
; 208  : 	if ((status = RegSetValueEx (hkey, name, 0, expandable ? REG_EXPAND_SZ : REG_SZ, (BYTE *) str, strlen (str) + 1)) != ERROR_SUCCESS)

  00043	8b 54 24 14	 mov	 edx, DWORD PTR _str$[esp+4]
  00047	8b c2		 mov	 eax, edx
  00049	56		 push	 esi
  0004a	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0004d	8d 49 00	 npad	 3
$LL5@WriteLocal@3:
  00050	8a 08		 mov	 cl, BYTE PTR [eax]
  00052	40		 inc	 eax
  00053	84 c9		 test	 cl, cl
  00055	75 f9		 jne	 SHORT $LL5@WriteLocal@3
  00057	8b 4c 24 14	 mov	 ecx, DWORD PTR _name$[esp+8]
  0005b	2b c6		 sub	 eax, esi
  0005d	40		 inc	 eax
  0005e	50		 push	 eax
  0005f	33 c0		 xor	 eax, eax
  00061	39 44 24 20	 cmp	 DWORD PTR _expandable$[esp+12], eax
  00065	52		 push	 edx
  00066	8b 54 24 0c	 mov	 edx, DWORD PTR _hkey$[esp+20]
  0006a	0f 95 c0	 setne	 al
  0006d	40		 inc	 eax
  0006e	50		 push	 eax
  0006f	6a 00		 push	 0
  00071	51		 push	 ecx
  00072	52		 push	 edx
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24
  00079	8b f0		 mov	 esi, eax
  0007b	85 f6		 test	 esi, esi
  0007d	74 19		 je	 SHORT $LN1@WriteLocal@3

; 209  : 	{
; 210  : 		RegCloseKey (hkey);

  0007f	8b 44 24 04	 mov	 eax, DWORD PTR _hkey$[esp+12]
  00083	50		 push	 eax
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 211  : 		SetLastError (status);

  0008a	56		 push	 esi
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 212  : 		return FALSE;

  00091	33 c0		 xor	 eax, eax
  00093	5e		 pop	 esi

; 217  : }

  00094	83 c4 08	 add	 esp, 8
  00097	c3		 ret	 0
$LN1@WriteLocal@3:

; 213  : 	}
; 214  : 
; 215  : 	RegCloseKey (hkey);

  00098	8b 4c 24 04	 mov	 ecx, DWORD PTR _hkey$[esp+12]
  0009c	51		 push	 ecx
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 216  : 	return TRUE;

  000a3	b8 01 00 00 00	 mov	 eax, 1
  000a8	5e		 pop	 esi

; 217  : }

  000a9	83 c4 08	 add	 esp, 8
  000ac	c3		 ret	 0
_WriteLocalMachineRegistryString ENDP
_TEXT	ENDS
PUBLIC	_WriteRegistryString
; Function compile flags: /Ogtpy
;	COMDAT _WriteRegistryString
_TEXT	SEGMENT
_hkey$ = -8						; size = 4
_disp$ = -4						; size = 4
_subKey$ = 8						; size = 4
_name$ = 12						; size = 4
_str$ = 16						; size = 4
_WriteRegistryString PROC				; COMDAT

; 220  : {

  00000	83 ec 08	 sub	 esp, 8

; 221  : 	HKEY hkey = 0;
; 222  : 	DWORD disp;
; 223  : 
; 224  : 	if (RegCreateKeyEx (HKEY_CURRENT_USER, subKey,
; 225  : 		0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &disp) != ERROR_SUCCESS)

  00003	8b 54 24 0c	 mov	 edx, DWORD PTR _subKey$[esp+4]
  00007	8d 44 24 04	 lea	 eax, DWORD PTR _disp$[esp+8]
  0000b	50		 push	 eax
  0000c	8d 4c 24 04	 lea	 ecx, DWORD PTR _hkey$[esp+12]
  00010	51		 push	 ecx
  00011	6a 00		 push	 0
  00013	68 06 00 02 00	 push	 131078			; 00020006H
  00018	6a 00		 push	 0
  0001a	6a 00		 push	 0
  0001c	6a 00		 push	 0
  0001e	52		 push	 edx
  0001f	68 01 00 00 80	 push	 -2147483647		; 80000001H
  00024	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _hkey$[esp+44], 0
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCreateKeyExA@36
  00032	85 c0		 test	 eax, eax
  00034	75 36		 jne	 SHORT $LN2@WriteRegis@2

; 226  : 		return;
; 227  : 
; 228  : 	RegSetValueEx (hkey, name, 0, REG_SZ, (BYTE *) str, strlen (str) + 1);

  00036	8b 54 24 14	 mov	 edx, DWORD PTR _str$[esp+4]
  0003a	8b c2		 mov	 eax, edx
  0003c	56		 push	 esi
  0003d	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$LL4@WriteRegis@2:
  00040	8a 08		 mov	 cl, BYTE PTR [eax]
  00042	40		 inc	 eax
  00043	84 c9		 test	 cl, cl
  00045	75 f9		 jne	 SHORT $LL4@WriteRegis@2
  00047	8b 4c 24 04	 mov	 ecx, DWORD PTR _hkey$[esp+12]
  0004b	2b c6		 sub	 eax, esi
  0004d	40		 inc	 eax
  0004e	50		 push	 eax
  0004f	8b 44 24 18	 mov	 eax, DWORD PTR _name$[esp+12]
  00053	52		 push	 edx
  00054	6a 01		 push	 1
  00056	6a 00		 push	 0
  00058	50		 push	 eax
  00059	51		 push	 ecx
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24

; 229  : 	RegCloseKey (hkey);

  00060	8b 54 24 04	 mov	 edx, DWORD PTR _hkey$[esp+12]
  00064	52		 push	 edx
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  0006b	5e		 pop	 esi
$LN2@WriteRegis@2:

; 230  : }

  0006c	83 c4 08	 add	 esp, 8
  0006f	c3		 ret	 0
_WriteRegistryString ENDP
_TEXT	ENDS
PUBLIC	_WriteRegistryBytes
; Function compile flags: /Ogtpy
;	COMDAT _WriteRegistryBytes
_TEXT	SEGMENT
_hkey$ = -8						; size = 4
_disp$ = -4						; size = 4
_path$ = 8						; size = 4
_name$ = 12						; size = 4
_str$ = 16						; size = 4
_size$ = 20						; size = 4
_WriteRegistryBytes PROC				; COMDAT

; 233  : {

  00000	83 ec 08	 sub	 esp, 8

; 234  : 	HKEY hkey = 0;
; 235  : 	DWORD disp;
; 236  : 	BOOL res;
; 237  : 
; 238  : 	if (RegCreateKeyEx (HKEY_CURRENT_USER, path,
; 239  : 		0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &disp) != ERROR_SUCCESS)

  00003	8b 54 24 0c	 mov	 edx, DWORD PTR _path$[esp+4]
  00007	8d 44 24 04	 lea	 eax, DWORD PTR _disp$[esp+8]
  0000b	50		 push	 eax
  0000c	8d 4c 24 04	 lea	 ecx, DWORD PTR _hkey$[esp+12]
  00010	51		 push	 ecx
  00011	6a 00		 push	 0
  00013	68 06 00 02 00	 push	 131078			; 00020006H
  00018	6a 00		 push	 0
  0001a	6a 00		 push	 0
  0001c	6a 00		 push	 0
  0001e	52		 push	 edx
  0001f	68 01 00 00 80	 push	 -2147483647		; 80000001H
  00024	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _hkey$[esp+44], 0
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCreateKeyExA@36
  00032	85 c0		 test	 eax, eax
  00034	74 06		 je	 SHORT $LN1@WriteRegis@3

; 240  : 		return FALSE;

  00036	33 c0		 xor	 eax, eax

; 245  : }

  00038	83 c4 08	 add	 esp, 8
  0003b	c3		 ret	 0
$LN1@WriteRegis@3:

; 241  : 
; 242  : 	res = RegSetValueEx (hkey, name, 0, REG_BINARY, (BYTE *) str, size);

  0003c	8b 44 24 18	 mov	 eax, DWORD PTR _size$[esp+4]
  00040	8b 4c 24 14	 mov	 ecx, DWORD PTR _str$[esp+4]
  00044	8b 54 24 10	 mov	 edx, DWORD PTR _name$[esp+4]
  00048	56		 push	 esi
  00049	50		 push	 eax
  0004a	8b 44 24 08	 mov	 eax, DWORD PTR _hkey$[esp+16]
  0004e	51		 push	 ecx
  0004f	6a 03		 push	 3
  00051	6a 00		 push	 0
  00053	52		 push	 edx
  00054	50		 push	 eax
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24

; 243  : 	RegCloseKey (hkey);

  0005b	8b 4c 24 04	 mov	 ecx, DWORD PTR _hkey$[esp+12]
  0005f	51		 push	 ecx
  00060	8b f0		 mov	 esi, eax
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 244  : 	return res == ERROR_SUCCESS;

  00068	33 c0		 xor	 eax, eax
  0006a	85 f6		 test	 esi, esi
  0006c	0f 94 c0	 sete	 al
  0006f	5e		 pop	 esi

; 245  : }

  00070	83 c4 08	 add	 esp, 8
  00073	c3		 ret	 0
_WriteRegistryBytes ENDP
_TEXT	ENDS
PUBLIC	_DeleteLocalMachineRegistryKey
EXTRN	__imp__RegDeleteKeyA@8:PROC
; Function compile flags: /Ogtpy
;	COMDAT _DeleteLocalMachineRegistryKey
_TEXT	SEGMENT
_hkey$ = -4						; size = 4
_parentKey$ = 8						; size = 4
_subKeyToDelete$ = 12					; size = 4
_DeleteLocalMachineRegistryKey PROC			; COMDAT

; 248  : {

  00000	51		 push	 ecx

; 249  : 	LONG status;
; 250  : 	HKEY hkey = 0;
; 251  : 
; 252  : 	if ((status = RegOpenKeyEx (HKEY_LOCAL_MACHINE, parentKey, 0, KEY_WRITE, &hkey)) != ERROR_SUCCESS)

  00001	8b 4c 24 08	 mov	 ecx, DWORD PTR _parentKey$[esp]
  00005	8d 04 24	 lea	 eax, DWORD PTR _hkey$[esp+4]
  00008	50		 push	 eax
  00009	68 06 00 02 00	 push	 131078			; 00020006H
  0000e	6a 00		 push	 0
  00010	51		 push	 ecx
  00011	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00016	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _hkey$[esp+24], 0
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  00024	85 c0		 test	 eax, eax
  00026	74 0b		 je	 SHORT $LN2@DeleteLoca

; 253  : 	{
; 254  : 		SetLastError (status);

  00028	50		 push	 eax
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 255  : 		return FALSE;

  0002f	33 c0		 xor	 eax, eax

; 267  : }

  00031	59		 pop	 ecx
  00032	c3		 ret	 0
$LN2@DeleteLoca:

; 256  : 	}
; 257  : 
; 258  : 	if ((status = RegDeleteKey (hkey, subKeyToDelete)) != ERROR_SUCCESS)

  00033	8b 54 24 0c	 mov	 edx, DWORD PTR _subKeyToDelete$[esp]
  00037	8b 04 24	 mov	 eax, DWORD PTR _hkey$[esp+4]
  0003a	56		 push	 esi
  0003b	52		 push	 edx
  0003c	50		 push	 eax
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegDeleteKeyA@8
  00043	8b f0		 mov	 esi, eax
  00045	85 f6		 test	 esi, esi
  00047	74 17		 je	 SHORT $LN1@DeleteLoca

; 259  : 	{
; 260  : 		RegCloseKey (hkey);

  00049	8b 4c 24 04	 mov	 ecx, DWORD PTR _hkey$[esp+8]
  0004d	51		 push	 ecx
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 261  : 		SetLastError (status);

  00054	56		 push	 esi
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 262  : 		return FALSE;

  0005b	33 c0		 xor	 eax, eax
  0005d	5e		 pop	 esi

; 267  : }

  0005e	59		 pop	 ecx
  0005f	c3		 ret	 0
$LN1@DeleteLoca:

; 263  : 	}
; 264  : 
; 265  : 	RegCloseKey (hkey);

  00060	8b 54 24 04	 mov	 edx, DWORD PTR _hkey$[esp+8]
  00064	52		 push	 edx
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 266  : 	return TRUE;

  0006b	b8 01 00 00 00	 mov	 eax, 1
  00070	5e		 pop	 esi

; 267  : }

  00071	59		 pop	 ecx
  00072	c3		 ret	 0
_DeleteLocalMachineRegistryKey ENDP
_TEXT	ENDS
PUBLIC	_DeleteRegistryValue
EXTRN	__imp__RegDeleteValueA@8:PROC
; Function compile flags: /Ogtpy
;	COMDAT _DeleteRegistryValue
_TEXT	SEGMENT
_hkey$ = -4						; size = 4
_subKey$ = 8						; size = 4
_name$ = 12						; size = 4
_DeleteRegistryValue PROC				; COMDAT

; 270  : {

  00000	51		 push	 ecx

; 271  : 	HKEY hkey = 0;
; 272  : 
; 273  : 	if (RegOpenKeyEx (HKEY_CURRENT_USER, subKey, 0, KEY_WRITE, &hkey) != ERROR_SUCCESS)

  00001	8b 4c 24 08	 mov	 ecx, DWORD PTR _subKey$[esp]
  00005	8d 04 24	 lea	 eax, DWORD PTR _hkey$[esp+4]
  00008	50		 push	 eax
  00009	68 06 00 02 00	 push	 131078			; 00020006H
  0000e	6a 00		 push	 0
  00010	51		 push	 ecx
  00011	68 01 00 00 80	 push	 -2147483647		; 80000001H
  00016	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _hkey$[esp+24], 0
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  00024	85 c0		 test	 eax, eax
  00026	75 19		 jne	 SHORT $LN2@DeleteRegi

; 274  : 		return;
; 275  : 
; 276  : 	RegDeleteValue (hkey, name);

  00028	8b 54 24 0c	 mov	 edx, DWORD PTR _name$[esp]
  0002c	8b 04 24	 mov	 eax, DWORD PTR _hkey$[esp+4]
  0002f	52		 push	 edx
  00030	50		 push	 eax
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegDeleteValueA@8

; 277  : 	RegCloseKey (hkey);

  00037	8b 0c 24	 mov	 ecx, DWORD PTR _hkey$[esp+4]
  0003a	51		 push	 ecx
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$LN2@DeleteRegi:

; 278  : }

  00041	59		 pop	 ecx
  00042	c3		 ret	 0
_DeleteRegistryValue ENDP
_TEXT	ENDS
PUBLIC	??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@		; `string'
PUBLIC	??_C@_0CC@HPOBEDNL@Software?2Microsoft?2Windows?2Curre@ ; `string'
PUBLIC	??_C@_0N@PGJGCAIL@tVersion?2Run?$AA@		; `string'
PUBLIC	_GetStartupRegKeyName
EXTRN	_sprintf:PROC
;	COMDAT ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
CONST	SEGMENT
??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@ DB '%s%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@HPOBEDNL@Software?2Microsoft?2Windows?2Curre@
CONST	SEGMENT
??_C@_0CC@HPOBEDNL@Software?2Microsoft?2Windows?2Curre@ DB 'Software\Micr'
	DB	'osoft\Windows\Curren', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PGJGCAIL@tVersion?2Run?$AA@
CONST	SEGMENT
??_C@_0N@PGJGCAIL@tVersion?2Run?$AA@ DB 'tVersion\Run', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _GetStartupRegKeyName
_TEXT	SEGMENT
_regk$ = 8						; size = 4
_GetStartupRegKeyName PROC				; COMDAT

; 283  : 	// The string is split in order to prevent some antivirus packages from falsely reporting  
; 284  : 	// CipherShed.exe to contain a possible Trojan horse because of this string (heuristic scan).
; 285  : 	sprintf (regk, "%s%s", "Software\\Microsoft\\Windows\\Curren", "tVersion\\Run");

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _regk$[esp-4]
  00004	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PGJGCAIL@tVersion?2Run?$AA@
  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@HPOBEDNL@Software?2Microsoft?2Windows?2Curre@
  0000e	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _sprintf
  00019	83 c4 10	 add	 esp, 16			; 00000010H

; 286  : }

  0001c	c3		 ret	 0
_GetStartupRegKeyName ENDP
_TEXT	ENDS
END
