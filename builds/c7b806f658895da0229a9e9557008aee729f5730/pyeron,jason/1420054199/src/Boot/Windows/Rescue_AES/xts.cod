;	Static Name Aliases
;
	TITLE   ..\..\..\common\xts.c
	.MODEL  SMALL
	.386p
	.387
_TEXT	SEGMENT  WORD USE16 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT  WORD USE16 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT  WORD USE16 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT  WORD USE16 PUBLIC 'BSS'
_BSS	ENDS
DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME DS: DGROUP, SS: DGROUP
EXTRN	_EncipherBlock:NEAR
EXTRN	_memcpy:NEAR
EXTRN	_DecipherBlock:NEAR
_TEXT      SEGMENT
	ASSUME	CS: _TEXT

Uint64ToLE16ByteArray	PROC NEAR	;  COMDAT
;|*** /*
;|***  Copyright (c) 2008-2010 TrueCrypt Developers Association. All rights reserved.
;|*** 
;|***  Governed by the TrueCrypt License 3.0 the full text of which is contained in
;|***  the file License.txt included in TrueCrypt binary and source code distribution
;|***  packages.
;|*** */
;|*** 
;|*** /* If native 64-bit data types are not available, define TC_NO_COMPILER_INT64. 
;|*** 
;|*** For big-endian platforms define BYTE_ORDER as BIG_ENDIAN. */
;|*** 
;|*** 
;|*** #ifdef TC_MINIMIZE_CODE_SIZE
;|*** //	Preboot/boot version
;|*** #	ifndef TC_NO_COMPILER_INT64
;|*** #		define TC_NO_COMPILER_INT64
;|*** #	endif
;|*** #	pragma optimize ("tl", on)
;|*** #endif
;|*** 
;|*** #ifdef TC_NO_COMPILER_INT64
;|*** #	include <memory.h>
;|*** #endif
;|*** 
;|*** #include "Xts.h"
;|*** 
;|*** 
;|*** #ifndef TC_NO_COMPILER_INT64
;|*** 
;|*** // length: number of bytes to encrypt; may be larger than one data unit and must be divisible by the cipher block size
;|*** // ks: the primary key schedule
;|*** // ks2: the secondary key schedule
;|*** // startDataUnitNo: The sequential number of the data unit with which the buffer starts.
;|*** // startCipherBlockNo: The sequential number of the first plaintext block to encrypt inside the data unit startDataUnitNo.
;|*** //                     When encrypting the data unit from its first block, startCipherBlockNo is 0. 
;|*** //                     The startCipherBlockNo value applies only to the first data unit in the buffer; each successive
;|*** //                     data unit is encrypted from its first block. The start of the buffer does not have to be
;|*** //                     aligned with the start of a data unit. If it is aligned, startCipherBlockNo must be 0; if it
;|*** //                     is not aligned, startCipherBlockNo must reflect the misalignment accordingly.
;|*** void EncryptBufferXTS (unsigned __int8 *buffer,
;|*** 					   TC_LARGEST_COMPILER_UINT length,
;|*** 					   const UINT64_STRUCT *startDataUnitNo,
;|*** 					   unsigned int startCipherBlockNo,
;|*** 					   unsigned __int8 *ks,
;|*** 					   unsigned __int8 *ks2,
;|*** 					   int cipher)
;|*** {
;|*** 	if (CipherSupportsIntraDataUnitParallelization (cipher))
;|*** 		EncryptBufferXTSParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);
;|*** 	else
;|*** 		EncryptBufferXTSNonParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);
;|*** }
;|*** 
;|*** 
;|*** // Optimized for encryption algorithms supporting intra-data-unit parallelization
;|*** static void EncryptBufferXTSParallel (unsigned __int8 *buffer,
;|*** 					   TC_LARGEST_COMPILER_UINT length,
;|*** 					   const UINT64_STRUCT *startDataUnitNo,
;|*** 					   unsigned int startCipherBlockNo,
;|*** 					   unsigned __int8 *ks,
;|*** 					   unsigned __int8 *ks2,
;|*** 					   int cipher)
;|*** {
;|*** 	unsigned __int8 finalCarry;
;|*** 	unsigned __int8 whiteningValues [ENCRYPTION_DATA_UNIT_SIZE];
;|*** 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
;|*** 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
;|*** 	unsigned __int64 *whiteningValuesPtr64 = (unsigned __int64 *) whiteningValues;
;|*** 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
;|*** 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
;|*** 	unsigned __int64 *dataUnitBufPtr;
;|*** 	unsigned int startBlock = startCipherBlockNo, endBlock, block;
;|*** 	unsigned __int64 *const finalInt64WhiteningValuesPtr = whiteningValuesPtr64 + sizeof (whiteningValues) / sizeof (*whiteningValuesPtr64) - 1;
;|*** 	TC_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
;|*** 
;|*** 	/* The encrypted data unit number (i.e. the resultant ciphertext block) is to be multiplied in the
;|*** 	finite field GF(2^128) by j-th power of n, where j is the sequential plaintext/ciphertext block
;|*** 	number and n is 2, a primitive element of GF(2^128). This can be (and is) simplified and implemented
;|*** 	as a left shift of the preceding whitening value by one bit (with carry propagating). In addition, if
;|*** 	the shift of the highest byte results in a carry, 135 is XORed into the lowest byte. The value 135 is
;|*** 	derived from the modulus of the Galois Field (x^128+x^7+x^2+x+1). */
;|*** 
;|*** 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
;|*** 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
;|*** 	dataUnitNo = startDataUnitNo->Value;
;|*** 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
;|*** 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
;|*** 
;|*** 	if (length % BYTES_PER_XTS_BLOCK)
;|*** 		TC_THROW_FATAL_EXCEPTION;
;|*** 
;|*** 	blockCount = length / BYTES_PER_XTS_BLOCK;
;|*** 
;|*** 	// Process all blocks in the buffer
;|*** 	while (blockCount > 0)
;|*** 	{
;|*** 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)
;|*** 			endBlock = startBlock + (unsigned int) blockCount;
;|*** 		else
;|*** 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;
;|*** 
;|*** 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
;|*** 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
;|*** 
;|*** 		// Encrypt the data unit number using the secondary key (in order to generate the first 
;|*** 		// whitening value for this data unit)
;|*** 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);
;|*** 		*(whiteningValuePtr64 + 1) = 0;
;|*** 		EncipherBlock (cipher, whiteningValue, ks2);
;|*** 
;|*** 		// Generate subsequent whitening values for blocks in this data unit. Note that all generated 128-bit
;|*** 		// whitening values are stored in memory as a sequence of 64-bit integers in reverse order.
;|*** 		for (block = 0; block < endBlock; block++)
;|*** 		{
;|*** 			if (block >= startBlock)
;|*** 			{
;|*** 				*whiteningValuesPtr64-- = *whiteningValuePtr64++;
;|*** 				*whiteningValuesPtr64-- = *whiteningValuePtr64;
;|*** 			}
;|*** 			else
;|*** 				whiteningValuePtr64++;
;|*** 
;|*** 			// Derive the next whitening value
;|*** 
;|*** #if BYTE_ORDER == LITTLE_ENDIAN
;|*** 
;|*** 			// Little-endian platforms
;|*** 
;|*** 			finalCarry = 
;|*** 				(*whiteningValuePtr64 & 0x8000000000000000) ?
;|*** 				135 : 0;
;|*** 
;|*** 			*whiteningValuePtr64-- <<= 1;
;|*** 
;|*** 			if (*whiteningValuePtr64 & 0x8000000000000000)
;|*** 				*(whiteningValuePtr64 + 1) |= 1;	
;|*** 
;|*** 			*whiteningValuePtr64 <<= 1;
;|*** #else
;|*** 
;|*** 			// Big-endian platforms
;|*** 
;|*** 			finalCarry = 
;|*** 				(*whiteningValuePtr64 & 0x80) ?
;|*** 				135 : 0;
;|*** 
;|*** 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
;|*** 
;|*** 			whiteningValuePtr64--;
;|*** 
;|*** 			if (*whiteningValuePtr64 & 0x80)
;|*** 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
;|*** 
;|*** 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
;|*** #endif
;|*** 
;|*** 			whiteningValue[0] ^= finalCarry;
;|*** 		}
;|*** 
;|*** 		dataUnitBufPtr = bufPtr;
;|*** 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
;|*** 
;|*** 		// Encrypt all blocks in this data unit
;|*** 
;|*** 		for (block = startBlock; block < endBlock; block++)
;|*** 		{
;|*** 			// Pre-whitening
;|*** 			*bufPtr++ ^= *whiteningValuesPtr64--;
;|*** 			*bufPtr++ ^= *whiteningValuesPtr64--;
;|*** 		}
;|*** 
;|*** 		// Actual encryption
;|*** 		EncipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);
;|*** 		
;|*** 		bufPtr = dataUnitBufPtr;
;|*** 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
;|*** 
;|*** 		for (block = startBlock; block < endBlock; block++)
;|*** 		{
;|*** 			// Post-whitening
;|*** 			*bufPtr++ ^= *whiteningValuesPtr64--;
;|*** 			*bufPtr++ ^= *whiteningValuesPtr64--;
;|*** 		}
;|*** 
;|*** 		blockCount -= endBlock - startBlock;
;|*** 		startBlock = 0;
;|*** 		dataUnitNo++;
;|*** 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
;|*** 	}
;|*** 
;|*** 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));
;|*** 	FAST_ERASE64 (whiteningValues, sizeof (whiteningValues));
;|*** }
;|*** 
;|*** 
;|*** // Optimized for encryption algorithms not supporting intra-data-unit parallelization
;|*** static void EncryptBufferXTSNonParallel (unsigned __int8 *buffer,
;|*** 					   TC_LARGEST_COMPILER_UINT length,
;|*** 					   const UINT64_STRUCT *startDataUnitNo,
;|*** 					   unsigned int startCipherBlockNo,
;|*** 					   unsigned __int8 *ks,
;|*** 					   unsigned __int8 *ks2,
;|*** 					   int cipher)
;|*** {
;|*** 	unsigned __int8 finalCarry;
;|*** 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
;|*** 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
;|*** 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
;|*** 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
;|*** 	unsigned int startBlock = startCipherBlockNo, endBlock, block;
;|*** 	TC_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
;|*** 
;|*** 	/* The encrypted data unit number (i.e. the resultant ciphertext block) is to be multiplied in the
;|*** 	finite field GF(2^128) by j-th power of n, where j is the sequential plaintext/ciphertext block
;|*** 	number and n is 2, a primitive element of GF(2^128). This can be (and is) simplified and implemented
;|*** 	as a left shift of the preceding whitening value by one bit (with carry propagating). In addition, if
;|*** 	the shift of the highest byte results in a carry, 135 is XORed into the lowest byte. The value 135 is
;|*** 	derived from the modulus of the Galois Field (x^128+x^7+x^2+x+1). */
;|*** 
;|*** 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
;|*** 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
;|*** 	dataUnitNo = startDataUnitNo->Value;
;|*** 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
;|*** 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
;|*** 
;|*** 	if (length % BYTES_PER_XTS_BLOCK)
;|*** 		TC_THROW_FATAL_EXCEPTION;
;|*** 
;|*** 	blockCount = length / BYTES_PER_XTS_BLOCK;
;|*** 
;|*** 	// Process all blocks in the buffer
;|*** 	while (blockCount > 0)
;|*** 	{
;|*** 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)
;|*** 			endBlock = startBlock + (unsigned int) blockCount;
;|*** 		else
;|*** 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;
;|*** 
;|*** 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
;|*** 
;|*** 		// Encrypt the data unit number using the secondary key (in order to generate the first 
;|*** 		// whitening value for this data unit)
;|*** 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);
;|*** 		*(whiteningValuePtr64 + 1) = 0;
;|*** 		EncipherBlock (cipher, whiteningValue, ks2);
;|*** 
;|*** 		// Generate (and apply) subsequent whitening values for blocks in this data unit and
;|*** 		// encrypt all relevant blocks in this data unit
;|*** 		for (block = 0; block < endBlock; block++)
;|*** 		{
;|*** 			if (block >= startBlock)
;|*** 			{
;|*** 				// Pre-whitening
;|*** 				*bufPtr++ ^= *whiteningValuePtr64++;
;|*** 				*bufPtr-- ^= *whiteningValuePtr64--;
;|*** 
;|*** 				// Actual encryption
;|*** 				EncipherBlock (cipher, bufPtr, ks);
;|*** 
;|*** 				// Post-whitening
;|*** 				*bufPtr++ ^= *whiteningValuePtr64++;
;|*** 				*bufPtr++ ^= *whiteningValuePtr64;
;|*** 			}
;|*** 			else
;|*** 				whiteningValuePtr64++;
;|*** 
;|*** 			// Derive the next whitening value
;|*** 
;|*** #if BYTE_ORDER == LITTLE_ENDIAN
;|*** 
;|*** 			// Little-endian platforms
;|*** 
;|*** 			finalCarry = 
;|*** 				(*whiteningValuePtr64 & 0x8000000000000000) ?
;|*** 				135 : 0;
;|*** 
;|*** 			*whiteningValuePtr64-- <<= 1;
;|*** 
;|*** 			if (*whiteningValuePtr64 & 0x8000000000000000)
;|*** 				*(whiteningValuePtr64 + 1) |= 1;	
;|*** 
;|*** 			*whiteningValuePtr64 <<= 1;
;|*** #else
;|*** 
;|*** 			// Big-endian platforms
;|*** 
;|*** 			finalCarry = 
;|*** 				(*whiteningValuePtr64 & 0x80) ?
;|*** 				135 : 0;
;|*** 
;|*** 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
;|*** 
;|*** 			whiteningValuePtr64--;
;|*** 
;|*** 			if (*whiteningValuePtr64 & 0x80)
;|*** 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
;|*** 
;|*** 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
;|*** #endif
;|*** 
;|*** 			whiteningValue[0] ^= finalCarry;
;|*** 		}
;|*** 
;|*** 		blockCount -= endBlock - startBlock;
;|*** 		startBlock = 0;
;|*** 		dataUnitNo++;
;|*** 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
;|*** 	}
;|*** 
;|*** 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));
;|*** }
;|*** 
;|*** 
;|*** // For descriptions of the input parameters, see EncryptBufferXTS().
;|*** void DecryptBufferXTS (unsigned __int8 *buffer,
;|*** 					   TC_LARGEST_COMPILER_UINT length,
;|*** 					   const UINT64_STRUCT *startDataUnitNo,
;|*** 					   unsigned int startCipherBlockNo,
;|*** 					   unsigned __int8 *ks,
;|*** 					   unsigned __int8 *ks2,
;|*** 					   int cipher)
;|*** {
;|*** 	if (CipherSupportsIntraDataUnitParallelization (cipher))
;|*** 		DecryptBufferXTSParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);
;|*** 	else
;|*** 		DecryptBufferXTSNonParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);
;|*** }
;|*** 
;|*** 
;|*** // Optimized for encryption algorithms supporting intra-data-unit parallelization
;|*** static void DecryptBufferXTSParallel (unsigned __int8 *buffer,
;|*** 					   TC_LARGEST_COMPILER_UINT length,
;|*** 					   const UINT64_STRUCT *startDataUnitNo,
;|*** 					   unsigned int startCipherBlockNo,
;|*** 					   unsigned __int8 *ks,
;|*** 					   unsigned __int8 *ks2,
;|*** 					   int cipher)
;|*** {
;|*** 	unsigned __int8 finalCarry;
;|*** 	unsigned __int8 whiteningValues [ENCRYPTION_DATA_UNIT_SIZE];
;|*** 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
;|*** 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
;|*** 	unsigned __int64 *whiteningValuesPtr64 = (unsigned __int64 *) whiteningValues;
;|*** 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
;|*** 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
;|*** 	unsigned __int64 *dataUnitBufPtr;
;|*** 	unsigned int startBlock = startCipherBlockNo, endBlock, block;
;|*** 	unsigned __int64 *const finalInt64WhiteningValuesPtr = whiteningValuesPtr64 + sizeof (whiteningValues) / sizeof (*whiteningValuesPtr64) - 1;
;|*** 	TC_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
;|*** 
;|*** 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
;|*** 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
;|*** 	dataUnitNo = startDataUnitNo->Value;
;|*** 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
;|*** 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
;|*** 
;|*** 	if (length % BYTES_PER_XTS_BLOCK)
;|*** 		TC_THROW_FATAL_EXCEPTION;
;|*** 
;|*** 	blockCount = length / BYTES_PER_XTS_BLOCK;
;|*** 
;|*** 	// Process all blocks in the buffer
;|*** 	while (blockCount > 0)
;|*** 	{
;|*** 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)
;|*** 			endBlock = startBlock + (unsigned int) blockCount;
;|*** 		else
;|*** 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;
;|*** 
;|*** 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
;|*** 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
;|*** 
;|*** 		// Encrypt the data unit number using the secondary key (in order to generate the first 
;|*** 		// whitening value for this data unit)
;|*** 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);
;|*** 		*(whiteningValuePtr64 + 1) = 0;
;|*** 		EncipherBlock (cipher, whiteningValue, ks2);
;|*** 
;|*** 		// Generate subsequent whitening values for blocks in this data unit. Note that all generated 128-bit
;|*** 		// whitening values are stored in memory as a sequence of 64-bit integers in reverse order.
;|*** 		for (block = 0; block < endBlock; block++)
;|*** 		{
;|*** 			if (block >= startBlock)
;|*** 			{
;|*** 				*whiteningValuesPtr64-- = *whiteningValuePtr64++;
;|*** 				*whiteningValuesPtr64-- = *whiteningValuePtr64;
;|*** 			}
;|*** 			else
;|*** 				whiteningValuePtr64++;
;|*** 
;|*** 			// Derive the next whitening value
;|*** 
;|*** #if BYTE_ORDER == LITTLE_ENDIAN
;|*** 
;|*** 			// Little-endian platforms
;|*** 
;|*** 			finalCarry = 
;|*** 				(*whiteningValuePtr64 & 0x8000000000000000) ?
;|*** 				135 : 0;
;|*** 
;|*** 			*whiteningValuePtr64-- <<= 1;
;|*** 
;|*** 			if (*whiteningValuePtr64 & 0x8000000000000000)
;|*** 				*(whiteningValuePtr64 + 1) |= 1;	
;|*** 
;|*** 			*whiteningValuePtr64 <<= 1;
;|*** 
;|*** #else
;|*** 			// Big-endian platforms
;|*** 
;|*** 			finalCarry = 
;|*** 				(*whiteningValuePtr64 & 0x80) ?
;|*** 				135 : 0;
;|*** 
;|*** 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
;|*** 
;|*** 			whiteningValuePtr64--;
;|*** 
;|*** 			if (*whiteningValuePtr64 & 0x80)
;|*** 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
;|*** 
;|*** 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
;|*** #endif
;|*** 
;|*** 			whiteningValue[0] ^= finalCarry;
;|*** 		}
;|*** 
;|*** 		dataUnitBufPtr = bufPtr;
;|*** 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
;|*** 
;|*** 		// Decrypt blocks in this data unit
;|*** 
;|*** 		for (block = startBlock; block < endBlock; block++)
;|*** 		{
;|*** 			*bufPtr++ ^= *whiteningValuesPtr64--;
;|*** 			*bufPtr++ ^= *whiteningValuesPtr64--;
;|*** 		}
;|*** 
;|*** 		DecipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);
;|*** 
;|*** 		bufPtr = dataUnitBufPtr;
;|*** 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
;|*** 
;|*** 		for (block = startBlock; block < endBlock; block++)
;|*** 		{
;|*** 			*bufPtr++ ^= *whiteningValuesPtr64--;
;|*** 			*bufPtr++ ^= *whiteningValuesPtr64--;
;|*** 		}
;|*** 
;|*** 		blockCount -= endBlock - startBlock;
;|*** 		startBlock = 0;
;|*** 		dataUnitNo++;
;|*** 
;|*** 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
;|*** 	}
;|*** 
;|*** 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));
;|*** 	FAST_ERASE64 (whiteningValues, sizeof (whiteningValues));
;|*** }
;|*** 
;|*** 
;|*** // Optimized for encryption algorithms not supporting intra-data-unit parallelization
;|*** static void DecryptBufferXTSNonParallel (unsigned __int8 *buffer,
;|*** 					   TC_LARGEST_COMPILER_UINT length,
;|*** 					   const UINT64_STRUCT *startDataUnitNo,
;|*** 					   unsigned int startCipherBlockNo,
;|*** 					   unsigned __int8 *ks,
;|*** 					   unsigned __int8 *ks2,
;|*** 					   int cipher)
;|*** {
;|*** 	unsigned __int8 finalCarry;
;|*** 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
;|*** 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
;|*** 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
;|*** 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
;|*** 	unsigned int startBlock = startCipherBlockNo, endBlock, block;
;|*** 	TC_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
;|*** 
;|*** 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
;|*** 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
;|*** 	dataUnitNo = startDataUnitNo->Value;
;|*** 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
;|*** 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
;|*** 
;|*** 	if (length % BYTES_PER_XTS_BLOCK)
;|*** 		TC_THROW_FATAL_EXCEPTION;
;|*** 
;|*** 	blockCount = length / BYTES_PER_XTS_BLOCK;
;|*** 
;|*** 	// Process all blocks in the buffer
;|*** 	while (blockCount > 0)
;|*** 	{
;|*** 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)
;|*** 			endBlock = startBlock + (unsigned int) blockCount;
;|*** 		else
;|*** 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;
;|*** 
;|*** 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
;|*** 
;|*** 		// Encrypt the data unit number using the secondary key (in order to generate the first 
;|*** 		// whitening value for this data unit)
;|*** 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);
;|*** 		*(whiteningValuePtr64 + 1) = 0;
;|*** 		EncipherBlock (cipher, whiteningValue, ks2);
;|*** 
;|*** 		// Generate (and apply) subsequent whitening values for blocks in this data unit and
;|*** 		// decrypt all relevant blocks in this data unit
;|*** 		for (block = 0; block < endBlock; block++)
;|*** 		{
;|*** 			if (block >= startBlock)
;|*** 			{
;|*** 				// Post-whitening
;|*** 				*bufPtr++ ^= *whiteningValuePtr64++;
;|*** 				*bufPtr-- ^= *whiteningValuePtr64--;
;|*** 
;|*** 				// Actual decryption
;|*** 				DecipherBlock (cipher, bufPtr, ks);
;|*** 
;|*** 				// Pre-whitening
;|*** 				*bufPtr++ ^= *whiteningValuePtr64++;
;|*** 				*bufPtr++ ^= *whiteningValuePtr64;
;|*** 			}
;|*** 			else
;|*** 				whiteningValuePtr64++;
;|*** 
;|*** 			// Derive the next whitening value
;|*** 
;|*** #if BYTE_ORDER == LITTLE_ENDIAN
;|*** 
;|*** 			// Little-endian platforms
;|*** 
;|*** 			finalCarry = 
;|*** 				(*whiteningValuePtr64 & 0x8000000000000000) ?
;|*** 				135 : 0;
;|*** 
;|*** 			*whiteningValuePtr64-- <<= 1;
;|*** 
;|*** 			if (*whiteningValuePtr64 & 0x8000000000000000)
;|*** 				*(whiteningValuePtr64 + 1) |= 1;	
;|*** 
;|*** 			*whiteningValuePtr64 <<= 1;
;|*** 
;|*** #else
;|*** 			// Big-endian platforms
;|*** 
;|*** 			finalCarry = 
;|*** 				(*whiteningValuePtr64 & 0x80) ?
;|*** 				135 : 0;
;|*** 
;|*** 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
;|*** 
;|*** 			whiteningValuePtr64--;
;|*** 
;|*** 			if (*whiteningValuePtr64 & 0x80)
;|*** 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
;|*** 
;|*** 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
;|*** #endif
;|*** 
;|*** 			whiteningValue[0] ^= finalCarry;
;|*** 		}
;|*** 
;|*** 		blockCount -= endBlock - startBlock;
;|*** 		startBlock = 0;
;|*** 		dataUnitNo++;
;|*** 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
;|*** 	}
;|*** 
;|*** 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));
;|*** }
;|*** 
;|*** 
;|*** #else	// TC_NO_COMPILER_INT64
;|*** 
;|*** /* ---- The following code is to be used only when native 64-bit data types are not available. ---- */
;|*** 
;|*** #if BYTE_ORDER == BIG_ENDIAN
;|*** #error The TC_NO_COMPILER_INT64 version of the XTS code is not compatible with big-endian platforms
;|*** #endif 
;|*** 
;|*** 
;|*** // Converts a 64-bit unsigned integer (passed as two 32-bit integers for compatibility with non-64-bit
;|*** // environments/platforms) into a little-endian 16-byte array.
;|*** static void Uint64ToLE16ByteArray (unsigned __int8 *byteBuf, unsigned __int32 highInt32, unsigned __int32 lowInt32)
;|*** {
; Line 586
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;	byteBuf = 4
;	highInt32 = 6
;	lowInt32 = 10
;	bufPtr32 = -2
	*** 000003	8b 5e 04 		mov	bx,WORD PTR [bp+4]	;byteBuf
;|*** 	unsigned __int32 *bufPtr32 = (unsigned __int32 *) byteBuf;
;|*** 
;|*** 	*bufPtr32++ = lowInt32;
; Line 589
	*** 000006	66 8b 46 0a 		mov	eax,DWORD PTR [bp+10]	;lowInt32
	*** 00000a	66 89 07 		mov	DWORD PTR [bx],eax
;|*** 	*bufPtr32++ = highInt32;
; Line 590
	*** 00000d	66 8b 46 06 		mov	eax,DWORD PTR [bp+6]	;highInt32
	*** 000011	66 89 47 04 		mov	DWORD PTR [bx+4],eax
;|*** 
;|*** 	// We're converting a 64-bit number into a little-endian 16-byte array so we can zero the last 8 bytes
;|*** 	*bufPtr32++ = 0;
; Line 593
	*** 000015	83 c3 04 		add	bx,4
	*** 000018	66 2b c0 		sub	eax,eax
	*** 00001b	66 89 47 04 		mov	DWORD PTR [bx+4],eax
;|*** 	*bufPtr32 = 0;
; Line 594
	*** 00001f	83 c3 04 		add	bx,4
	*** 000022	89 47 06 		mov	WORD PTR [bx+6],ax
	*** 000025	89 47 04 		mov	WORD PTR [bx+4],ax
;|*** }
; Line 595
	*** 000028	c9 			leave	
	*** 000029	c3 			ret	

Uint64ToLE16ByteArray	ENDP

EncryptDecryptBufferXTS32	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** // Encrypts or decrypts all blocks in the buffer in XTS mode. For descriptions of the input parameters,
;|*** // see the 64-bit version of EncryptBufferXTS().
;|*** static void EncryptDecryptBufferXTS32 (const unsigned __int8 *buffer,
;|*** 							TC_LARGEST_COMPILER_UINT length,
;|*** 							const UINT64_STRUCT *startDataUnitNo,
;|*** 							unsigned int startBlock,
;|*** 							unsigned __int8 *ks,
;|*** 							unsigned __int8 *ks2,
;|*** 							int cipher,
;|*** 							BOOL decryption)
;|*** {
; Line 608
	*** 000000	c8 36 00 00 		enter	54,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	register bx = burnc
;	buffer = 4
;	length = 6
;	startDataUnitNo = 10
;	startBlock = 12
;	ks = 14
;	ks2 = 16
;	cipher = 18
;	decryption = 20
;	blockCount = -8
;	dataUnitNo = -22
;	block = -10
;	endBlock = -12
;	byteBufUnitNo = -54
;	whiteningValue = -38
;	bufPtr32 = -14
;	whiteningValuePtr32 = -2
;	finalCarry = -3
;	finalDwordWhiteningValuePtr = -2
;	burnm = -2
;|*** 	TC_LARGEST_COMPILER_UINT blockCount;
;|*** 	UINT64_STRUCT dataUnitNo;
;|*** 	unsigned int block;
;|*** 	unsigned int endBlock;
;|*** 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
;|*** 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
;|*** 	unsigned __int32 *bufPtr32 = (unsigned __int32 *) buffer;
; Line 615
	*** 000006	8b 46 04 		mov	ax,WORD PTR [bp+4]	;buffer
	*** 000009	89 46 f2 		mov	WORD PTR [bp-14],ax	;bufPtr32
;|*** 	unsigned __int32 *whiteningValuePtr32 = (unsigned __int32 *) whiteningValue;
;|*** 	unsigned __int8 finalCarry;
;|*** 	unsigned __int32 *const finalDwordWhiteningValuePtr = whiteningValuePtr32 + sizeof (whiteningValue) / sizeof (*whiteningValuePtr32) - 1;
; Line 618
	*** 00000c	8d 46 e6 		lea	ax,WORD PTR [bp-26]
	*** 00000f	89 46 fe 		mov	WORD PTR [bp-2],ax	;whiteningValuePtr32
;|*** 
;|*** 	// Store the 64-bit data unit number in a way compatible with non-64-bit environments/platforms
;|*** 	dataUnitNo.HighPart = startDataUnitNo->HighPart;
; Line 621
	*** 000012	8b 5e 0a 		mov	bx,WORD PTR [bp+10]	;startDataUnitNo
	*** 000015	66 8b 47 04 		mov	eax,DWORD PTR [bx+4]
	*** 000019	66 89 46 ee 		mov	DWORD PTR [bp-18],eax
;|*** 	dataUnitNo.LowPart = startDataUnitNo->LowPart;
; Line 622
	*** 00001d	66 8b 07 		mov	eax,DWORD PTR [bx]
	*** 000020	66 89 46 ea 		mov	DWORD PTR [bp-22],eax	;dataUnitNo
;|*** 
;|*** 	blockCount = length / BYTES_PER_XTS_BLOCK;
; Line 624
	*** 000024	66 8b 46 06 		mov	eax,DWORD PTR [bp+6]	;length
	*** 000028	66 c1 e8 04 		shr	eax,4
	*** 00002c	66 89 46 f8 		mov	DWORD PTR [bp-8],eax	;blockCount
;|*** 
;|*** 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
;|*** 	// (Passed as two 32-bit integers for compatibility with non-64-bit environments/platforms.)
;|*** 	Uint64ToLE16ByteArray (byteBufUnitNo, dataUnitNo.HighPart, dataUnitNo.LowPart);
; Line 628
	*** 000030	66 ff 76 ea 		push	DWORD PTR [bp-22]	;dataUnitNo
	*** 000034	66 ff 76 ee 		push	DWORD PTR [bp-18]
	*** 000038	8d 4e ca 		lea	cx,WORD PTR [bp-54]	;byteBufUnitNo
	*** 00003b	51 			push	cx
	*** 00003c	e8 00 00 		call	Uint64ToLE16ByteArray
	*** 00003f	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|*** 	// Generate whitening values for all blocks in the buffer
;|*** 	while (blockCount > 0)
; Line 631
	*** 000042	66 83 7e f8 00 		cmp	DWORD PTR [bp-8],0	;blockCount
	*** 000047	0f 84 6f 01 		je	$D764
					$L816:
	*** 00004b	8b 7e 0c 		mov	di,WORD PTR [bp+12]	;startBlock
					$FC747:
;|*** 	{
;|*** 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)
;|*** 			endBlock = startBlock + (unsigned int) blockCount;
;|*** 		else
;|*** 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;
;|*** 
;|*** 		// Encrypt the data unit number using the secondary key (in order to generate the first 
;|*** 		// whitening value for this data unit)
;|*** 		memcpy (whiteningValue, byteBufUnitNo, BYTES_PER_XTS_BLOCK);
; Line 640
	*** 00004e	6a 10 			push	16	;0010H
	*** 000050	8d 46 ca 		lea	ax,WORD PTR [bp-54]	;byteBufUnitNo
	*** 000053	50 			push	ax
	*** 000054	8d 46 da 		lea	ax,WORD PTR [bp-38]	;whiteningValue
	*** 000057	50 			push	ax
	*** 000058	e8 00 00 		call	_memcpy
	*** 00005b	83 c4 06 		add	sp,6
;|*** 		EncipherBlock (cipher, whiteningValue, ks2);
; Line 641
	*** 00005e	ff 76 10 		push	WORD PTR [bp+16]	;ks2
	*** 000061	8d 46 da 		lea	ax,WORD PTR [bp-38]	;whiteningValue
	*** 000064	50 			push	ax
	*** 000065	ff 76 12 		push	WORD PTR [bp+18]	;cipher
	*** 000068	e8 00 00 		call	_EncipherBlock
	*** 00006b	83 c4 06 		add	sp,6
;|*** 
;|*** 		// Generate (and apply) subsequent whitening values for blocks in this data unit and
;|*** 		// encrypt/decrypt all relevant blocks in this data unit
;|*** 		for (block = 0; block < endBlock; block++)
; Line 645
	*** 00006e	c7 46 f6 00 00 		mov	WORD PTR [bp-10],0	;block
	*** 000073	66 83 7e f8 20 		cmp	DWORD PTR [bp-8],32	;00000020H	;blockCount
	*** 000078	73 08 			jae	SHORT $I749
	*** 00007a	8b 46 f8 		mov	ax,WORD PTR [bp-8]	;blockCount
	*** 00007d	03 c7 			add	ax,di
	*** 00007f	eb 04 			jmp	SHORT $I750
	*** 000081	90 			nop	
					$I749:
	*** 000082	b8 20 00 		mov	ax,32	;0020H
					$I750:
	*** 000085	89 46 f4 		mov	WORD PTR [bp-12],ax	;endBlock
	*** 000088	0b c0 			or	ax,ax
	*** 00008a	0f 84 eb 00 		je	$FB753
	*** 00008e	89 7e 0c 		mov	WORD PTR [bp+12],di	;startBlock
					$F751:
;|*** 		{
;|*** 			if (block >= startBlock)
; Line 647
	*** 000091	8b 46 0c 		mov	ax,WORD PTR [bp+12]	;startBlock
	*** 000094	39 46 f6 		cmp	WORD PTR [bp-10],ax	;block
	*** 000097	0f 82 90 00 		jb	$I754
	*** 00009b	8b 7e f2 		mov	di,WORD PTR [bp-14]	;bufPtr32
;|*** 			{
;|*** 				whiteningValuePtr32 = (unsigned __int32 *) whiteningValue;
;|*** 
;|*** 				// Whitening
;|*** 				*bufPtr32++ ^= *whiteningValuePtr32++;
; Line 652
	*** 00009e	66 8b 46 da 		mov	eax,DWORD PTR [bp-38]	;whiteningValue
	*** 0000a2	66 31 05 		xor	DWORD PTR [di],eax
;|*** 				*bufPtr32++ ^= *whiteningValuePtr32++;
; Line 653
	*** 0000a5	8b 46 de 		mov	ax,WORD PTR [bp-34]
	*** 0000a8	83 c7 04 		add	di,4
	*** 0000ab	8b 56 e0 		mov	dx,WORD PTR [bp-32]
	*** 0000ae	31 05 			xor	WORD PTR [di],ax
	*** 0000b0	31 55 02 		xor	WORD PTR [di+2],dx
;|*** 				*bufPtr32++ ^= *whiteningValuePtr32++;
; Line 654
	*** 0000b3	8b 46 e2 		mov	ax,WORD PTR [bp-30]
	*** 0000b6	83 c7 04 		add	di,4
	*** 0000b9	8b 56 e4 		mov	dx,WORD PTR [bp-28]
	*** 0000bc	31 05 			xor	WORD PTR [di],ax
	*** 0000be	31 55 02 		xor	WORD PTR [di+2],dx
;|*** 				*bufPtr32 ^= *whiteningValuePtr32;
; Line 655
	*** 0000c1	8b 46 e6 		mov	ax,WORD PTR [bp-26]
	*** 0000c4	83 c7 04 		add	di,4
	*** 0000c7	8b 56 e8 		mov	dx,WORD PTR [bp-24]
	*** 0000ca	31 05 			xor	WORD PTR [di],ax
	*** 0000cc	31 55 02 		xor	WORD PTR [di+2],dx
;|*** 
;|*** 				bufPtr32 -= BYTES_PER_XTS_BLOCK / sizeof (*bufPtr32) - 1;
; Line 657
	*** 0000cf	83 c7 f4 		add	di,-12	;fff4H
;|*** 
;|*** 				// Actual encryption/decryption
;|*** 				if (decryption)
; Line 660
	*** 0000d2	80 7e 14 00 		cmp	BYTE PTR [bp+20],0	;decryption
	*** 0000d6	74 0e 			je	SHORT $I755
	*** 0000d8	8b 76 0e 		mov	si,WORD PTR [bp+14]	;ks
;|*** 					DecipherBlock (cipher, bufPtr32, ks);
; Line 661
	*** 0000db	56 			push	si
	*** 0000dc	57 			push	di
	*** 0000dd	ff 76 12 		push	WORD PTR [bp+18]	;cipher
	*** 0000e0	e8 00 00 		call	_DecipherBlock
	*** 0000e3	eb 0c 			jmp	SHORT $L819
	*** 0000e5	90 			nop	
					$I755:
	*** 0000e6	8b 76 0e 		mov	si,WORD PTR [bp+14]	;ks
;|*** 				else
;|*** 					EncipherBlock (cipher, bufPtr32, ks);
; Line 663
	*** 0000e9	56 			push	si
	*** 0000ea	57 			push	di
	*** 0000eb	ff 76 12 		push	WORD PTR [bp+18]	;cipher
	*** 0000ee	e8 00 00 		call	_EncipherBlock
					$L819:
	*** 0000f1	83 c4 06 		add	sp,6
;|*** 
;|*** 				whiteningValuePtr32 = (unsigned __int32 *) whiteningValue;
;|*** 
;|*** 				// Whitening
;|*** 				*bufPtr32++ ^= *whiteningValuePtr32++;
; Line 668
	*** 0000f4	66 8b 46 da 		mov	eax,DWORD PTR [bp-38]	;whiteningValue
	*** 0000f8	66 31 05 		xor	DWORD PTR [di],eax
;|*** 				*bufPtr32++ ^= *whiteningValuePtr32++;
; Line 669
	*** 0000fb	8b 46 de 		mov	ax,WORD PTR [bp-34]
	*** 0000fe	83 c7 04 		add	di,4
	*** 000101	8b 56 e0 		mov	dx,WORD PTR [bp-32]
	*** 000104	31 05 			xor	WORD PTR [di],ax
	*** 000106	31 55 02 		xor	WORD PTR [di+2],dx
;|*** 				*bufPtr32++ ^= *whiteningValuePtr32++;
; Line 670
	*** 000109	8b 46 e2 		mov	ax,WORD PTR [bp-30]
	*** 00010c	83 c7 04 		add	di,4
	*** 00010f	8b 56 e4 		mov	dx,WORD PTR [bp-28]
	*** 000112	31 05 			xor	WORD PTR [di],ax
	*** 000114	31 55 02 		xor	WORD PTR [di+2],dx
;|*** 				*bufPtr32++ ^= *whiteningValuePtr32;
; Line 671
	*** 000117	8b 46 e6 		mov	ax,WORD PTR [bp-26]
	*** 00011a	83 c7 04 		add	di,4
	*** 00011d	8b 56 e8 		mov	dx,WORD PTR [bp-24]
	*** 000120	31 05 			xor	WORD PTR [di],ax
	*** 000122	31 55 02 		xor	WORD PTR [di+2],dx
	*** 000125	83 c7 04 		add	di,4
	*** 000128	89 7e f2 		mov	WORD PTR [bp-14],di	;bufPtr32
;|*** 			}
;|*** 
;|*** 			// Derive the next whitening value
;|*** 
;|*** 			finalCarry = 0;
; Line 676
					$I754:
	*** 00012b	c6 46 fd 00 		mov	BYTE PTR [bp-3],0	;finalCarry
;|*** 
;|*** 			for (whiteningValuePtr32 = finalDwordWhiteningValuePtr;
;|*** 				whiteningValuePtr32 >= (unsigned __int32 *) whiteningValue;
;|*** 				whiteningValuePtr32--)
; Line 680
	*** 00012f	8d 56 e6 		lea	dx,WORD PTR [bp-26]
	*** 000132	89 56 fe 		mov	WORD PTR [bp-2],dx	;whiteningValuePtr32
	*** 000135	8b f2 			mov	si,dx
					$F757:
;|*** 			{
;|*** 				if (*whiteningValuePtr32 & 0x80000000)	// If the following shift results in a carry
; Line 682
	*** 000137	f7 44 02 00 80 		test	WORD PTR [si+2],-32768	;8000H
	*** 00013c	74 12 			je	SHORT $I760
;|*** 				{
;|*** 					if (whiteningValuePtr32 != finalDwordWhiteningValuePtr)	// If not processing the highest double word
; Line 684
	*** 00013e	8d 46 e6 		lea	ax,WORD PTR [bp-26]
	*** 000141	3b f0 			cmp	si,ax
	*** 000143	74 07 			je	SHORT $I761
;|*** 					{
;|*** 						// A regular carry
;|*** 						*(whiteningValuePtr32 + 1) |= 1;
; Line 687
	*** 000145	80 4c 04 01 		or	BYTE PTR [si+4],1
;|*** 					}
;|*** 					else 
; Line 689
	*** 000149	eb 05 			jmp	SHORT $I760
	*** 00014b	90 			nop	
					$I761:
;|*** 					{
;|*** 						// The highest byte shift will result in a carry
;|*** 						finalCarry = 135;
; Line 692
	*** 00014c	c6 46 fd 87 		mov	BYTE PTR [bp-3],135	;0087H	;finalCarry
;|*** 					}
;|*** 				}
;|*** 
;|*** 				*whiteningValuePtr32 <<= 1;
; Line 696
					$I760:
	*** 000150	66 8b 04 		mov	eax,DWORD PTR [si]
	*** 000153	66 03 c0 		add	eax,eax
	*** 000156	66 89 04 		mov	DWORD PTR [si],eax
	*** 000159	83 ee 04 		sub	si,4
	*** 00015c	8d 46 da 		lea	ax,WORD PTR [bp-38]	;whiteningValue
	*** 00015f	3b f0 			cmp	si,ax
	*** 000161	73 d4 			jae	SHORT $F757
;|*** 			}
;|*** 
;|*** 			whiteningValue[0] ^= finalCarry;
; Line 699
	*** 000163	8a 46 fd 		mov	al,BYTE PTR [bp-3]	;finalCarry
	*** 000166	30 46 da 		xor	BYTE PTR [bp-38],al	;whiteningValue
	*** 000169	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;endBlock
	*** 00016c	ff 46 f6 		inc	WORD PTR [bp-10]	;block
	*** 00016f	39 46 f6 		cmp	WORD PTR [bp-10],ax	;block
	*** 000172	0f 82 1b ff 		jb	$F751
	*** 000176	8b 7e 0c 		mov	di,WORD PTR [bp+12]	;startBlock
;|*** 		}
; Line 700
					$FB753:
;|*** 
;|*** 		blockCount -= endBlock - startBlock;
; Line 702
	*** 000179	2b c7 			sub	ax,di
	*** 00017b	2b d2 			sub	dx,dx
	*** 00017d	29 46 f8 		sub	WORD PTR [bp-8],ax	;blockCount
	*** 000180	19 56 fa 		sbb	WORD PTR [bp-6],dx
;|*** 		startBlock = 0;
; Line 703
	*** 000183	33 ff 			xor	di,di
;|*** 
;|*** 		// Increase the data unit number by one
;|*** 		if (!++dataUnitNo.LowPart)
; Line 706
	*** 000185	83 46 ea 01 		add	WORD PTR [bp-22],1	;dataUnitNo
	*** 000189	11 56 ec 		adc	WORD PTR [bp-20],dx
	*** 00018c	66 83 7e ea 00 		cmp	DWORD PTR [bp-22],0	;dataUnitNo
	*** 000191	75 07 			jne	SHORT $I763
;|*** 		{
;|*** 			dataUnitNo.HighPart++;
; Line 708
	*** 000193	83 46 ee 01 		add	WORD PTR [bp-18],1
	*** 000197	11 56 f0 		adc	WORD PTR [bp-16],dx
;|*** 		}
;|*** 
;|*** 		// Convert the 64-bit data unit number into a little-endian 16-byte array. 
;|*** 		Uint64ToLE16ByteArray (byteBufUnitNo, dataUnitNo.HighPart, dataUnitNo.LowPart);
; Line 712
					$I763:
	*** 00019a	66 ff 76 ea 		push	DWORD PTR [bp-22]	;dataUnitNo
	*** 00019e	66 ff 76 ee 		push	DWORD PTR [bp-18]
	*** 0001a2	8d 46 ca 		lea	ax,WORD PTR [bp-54]	;byteBufUnitNo
	*** 0001a5	50 			push	ax
	*** 0001a6	e8 00 00 		call	Uint64ToLE16ByteArray
	*** 0001a9	83 c4 0a 		add	sp,10	;000aH
;|*** 	}
; Line 713
	*** 0001ac	39 7e fa 		cmp	WORD PTR [bp-6],di
	*** 0001af	0f 85 9b fe 		jne	$FC747
	*** 0001b3	39 7e f8 		cmp	WORD PTR [bp-8],di	;blockCount
	*** 0001b6	0f 85 94 fe 		jne	$FC747
;|*** 
;|*** 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));
; Line 715
					$D764:
	*** 0001ba	8d 46 da 		lea	ax,WORD PTR [bp-38]	;whiteningValue
	*** 0001bd	89 46 fe 		mov	WORD PTR [bp-2],ax	;whiteningValuePtr32
	*** 0001c0	bb 04 00 		mov	bx,4
	*** 0001c3	eb 0f 			jmp	SHORT $L820
	*** 0001c5	90 			nop	
					$FC770:
	*** 0001c6	8b 76 fe 		mov	si,WORD PTR [bp-2]	;whiteningValuePtr32
	*** 0001c9	66 c7 04 00 00 00 00 	mov	DWORD PTR [si],0
	*** 0001d0	83 46 fe 04 		add	WORD PTR [bp-2],4	;whiteningValuePtr32
					$L820:
	*** 0001d4	8b c3 			mov	ax,bx
	*** 0001d6	4b 			dec	bx
	*** 0001d7	0b c0 			or	ax,ax
	*** 0001d9	75 eb 			jne	SHORT $FC770
;|*** }
; Line 716
	*** 0001db	5e 			pop	si
	*** 0001dc	5f 			pop	di
	*** 0001dd	c9 			leave	
	*** 0001de	c3 			ret	

EncryptDecryptBufferXTS32	ENDP
	PUBLIC	_EncryptBufferXTS
_EncryptBufferXTS	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** // For descriptions of the input parameters, see the 64-bit version of EncryptBufferXTS() above.
;|*** void EncryptBufferXTS (unsigned __int8 *buffer,
;|*** 					   TC_LARGEST_COMPILER_UINT length,
;|*** 					   const UINT64_STRUCT *startDataUnitNo,
;|*** 					   unsigned int startCipherBlockNo,
;|*** 					   unsigned __int8 *ks,
;|*** 					   unsigned __int8 *ks2,
;|*** 					   int cipher)
;|*** {
; Line 727
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;	buffer = 4
;	length = 6
;	startDataUnitNo = 10
;	startCipherBlockNo = 12
;	ks = 14
;	ks2 = 16
;	cipher = 18
;|*** 	// Encrypt all plaintext blocks in the buffer
;|*** 	EncryptDecryptBufferXTS32 (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher, FALSE);
; Line 729
	*** 000003	6a 00 			push	0
	*** 000005	66 ff 76 10 		push	DWORD PTR [bp+16]	;ks2
	*** 000009	66 ff 76 0c 		push	DWORD PTR [bp+12]	;startCipherBlockNo
	*** 00000d	66 ff 76 08 		push	DWORD PTR [bp+8]
	*** 000011	66 ff 76 04 		push	DWORD PTR [bp+4]	;buffer
	*** 000015	e8 00 00 		call	EncryptDecryptBufferXTS32
;|*** }
; Line 730
	*** 000018	c9 			leave	
	*** 000019	c3 			ret	

_EncryptBufferXTS	ENDP
	PUBLIC	_DecryptBufferXTS
_DecryptBufferXTS	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** // For descriptions of the input parameters, see the 64-bit version of EncryptBufferXTS().
;|*** void DecryptBufferXTS (unsigned __int8 *buffer,
;|*** 					   TC_LARGEST_COMPILER_UINT length,
;|*** 					   const UINT64_STRUCT *startDataUnitNo,
;|*** 					   unsigned int startCipherBlockNo,
;|*** 					   unsigned __int8 *ks,
;|*** 					   unsigned __int8 *ks2,
;|*** 					   int cipher)
;|*** {
; Line 741
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;	buffer = 4
;	length = 6
;	startDataUnitNo = 10
;	startCipherBlockNo = 12
;	ks = 14
;	ks2 = 16
;	cipher = 18
;|*** 	// Decrypt all ciphertext blocks in the buffer
;|*** 	EncryptDecryptBufferXTS32 (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher, TRUE);
; Line 743
	*** 000003	6a 01 			push	1
	*** 000005	66 ff 76 10 		push	DWORD PTR [bp+16]	;ks2
	*** 000009	66 ff 76 0c 		push	DWORD PTR [bp+12]	;startCipherBlockNo
	*** 00000d	66 ff 76 08 		push	DWORD PTR [bp+8]
	*** 000011	66 ff 76 04 		push	DWORD PTR [bp+4]	;buffer
	*** 000015	e8 00 00 		call	EncryptDecryptBufferXTS32
;|*** }
; Line 744
	*** 000018	c9 			leave	
	*** 000019	c3 			ret	

_DecryptBufferXTS	ENDP
_TEXT	ENDS
END
;|*** 
;|*** #endif	// TC_NO_COMPILER_INT64
