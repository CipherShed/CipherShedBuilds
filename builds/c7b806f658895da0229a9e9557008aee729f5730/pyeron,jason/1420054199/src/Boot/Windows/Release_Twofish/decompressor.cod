;	Static Name Aliases
;
;	$S192_?lext@?1??codes@@9@9	EQU	?lext@?1??codes@@9@9
;	$S194_?dists@?1??codes@@9@9	EQU	?dists@?1??codes@@9@9
;	$S196_?dext@?1??codes@@9@9	EQU	?dext@?1??codes@@9@9
;	$S268_?order@?1??dynamic@@9@9	EQU	?order@?1??dynamic@@9@9
;	$S220_?virgin@?1??fixed@@9@9	EQU	?virgin@?1??fixed@@9@9
;	$S222_?lencnt@?1??fixed@@9@9	EQU	?lencnt@?1??fixed@@9@9
;	$S224_?lensym@?1??fixed@@9@9	EQU	?lensym@?1??fixed@@9@9
;	$S226_?distcnt@?1??fixed@@9@9	EQU	?distcnt@?1??fixed@@9@9
;	$S228_?distsym@?1??fixed@@9@9	EQU	?distsym@?1??fixed@@9@9
;	$S230_?lencode@?1??fixed@@9@9	EQU	?lencode@?1??fixed@@9@9
;	$S232_?distcode@?1??fixed@@9@9	EQU	?distcode@?1??fixed@@9@9
;	$S190_?lens@?1??codes@@9@9	EQU	?lens@?1??codes@@9@9
	TITLE   ..\decompressor.c
	.MODEL  SMALL
	.386p
	.387
_TEXT	SEGMENT  WORD USE16 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT  WORD USE16 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT  WORD USE16 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT  WORD USE16 PUBLIC 'BSS'
_BSS	ENDS
DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME DS: DGROUP, SS: DGROUP
EXTRN	__acrtused:ABS
EXTRN	__aNlshl:NEAR
EXTRN	__aNlshr:NEAR
_DATA      SEGMENT
$S190_?lens@?1??codes@@9@9	DW	03H
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0dH
	DW	0fH
	DW	011H
	DW	013H
	DW	017H
	DW	01bH
	DW	01fH
	DW	023H
	DW	02bH
	DW	033H
	DW	03bH
	DW	043H
	DW	053H
	DW	063H
	DW	073H
	DW	083H
	DW	0a3H
	DW	0c3H
	DW	0e3H
	DW	0102H
$S192_?lext@?1??codes@@9@9	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	00H
$S194_?dists@?1??codes@@9@9	DW	01H
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	07H
	DW	09H
	DW	0dH
	DW	011H
	DW	019H
	DW	021H
	DW	031H
	DW	041H
	DW	061H
	DW	081H
	DW	0c1H
	DW	0101H
	DW	0181H
	DW	0201H
	DW	0301H
	DW	0401H
	DW	0601H
	DW	0801H
	DW	0c01H
	DW	01001H
	DW	01801H
	DW	02001H
	DW	03001H
	DW	04001H
	DW	06001H
$S196_?dext@?1??codes@@9@9	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	03H
	DW	03H
	DW	04H
	DW	04H
	DW	05H
	DW	05H
	DW	06H
	DW	06H
	DW	07H
	DW	07H
	DW	08H
	DW	08H
	DW	09H
	DW	09H
	DW	0aH
	DW	0aH
	DW	0bH
	DW	0bH
	DW	0cH
	DW	0cH
	DW	0dH
	DW	0dH
$S220_?virgin@?1??fixed@@9@9	DW	01H
$S230_?lencode@?1??fixed@@9@9	DW	DGROUP:$S222_?lencnt@?1??fixed@@9@9
	DW	DGROUP:$S224_?lensym@?1??fixed@@9@9
$S232_?distcode@?1??fixed@@9@9	DW	DGROUP:$S226_?distcnt@?1??fixed@@9@9
	DW	DGROUP:$S228_?distsym@?1??fixed@@9@9
$S268_?order@?1??dynamic@@9@9	DW	010H
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
_DATA      ENDS
_BSS      SEGMENT
$S222_?lencnt@?1??fixed@@9@9	DW 010H DUP (?)
$S224_?lensym@?1??fixed@@9@9	DW 0120H DUP (?)
$S226_?distcnt@?1??fixed@@9@9	DW 010H DUP (?)
$S228_?distsym@?1??fixed@@9@9	DW 01eH DUP (?)
_BSS      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT

bits	PROC NEAR	;  COMDAT
;|*** /*
;|***   puff.c
;|***   Copyright (C) 2002-2004 Mark Adler, all rights reserved
;|***   version 1.8, 9 Jan 2004
;|*** 
;|***   This software is provided 'as-is', without any express or implied
;|***   warranty.  In no event will the author be held liable for any damages
;|***   arising from the use of this software.
;|*** 
;|***   Permission is granted to anyone to use this software for any purpose,
;|***   including commercial applications, and to alter it and redistribute it
;|***   freely, subject to the following restrictions:
;|*** 
;|***   1. The origin of this software must not be misrepresented; you must not
;|***      claim that you wrote the original software. If you use this software
;|***      in a product, an acknowledgment in the product documentation would be
;|***      appreciated but is not required.
;|***   2. Altered source versions must be plainly marked as such, and must not be
;|***      misrepresented as being the original software.
;|***   3. This notice may not be removed or altered from any source distribution.
;|*** 
;|***   Mark Adler    madler@alumni.caltech.edu
;|*** */
;|*** 
;|*** /* Adapted for CipherShed */
;|*** 
;|*** 
;|*** #define local static            /* for local function definitions */
;|*** #define NIL ((unsigned char *)0)        /* for no output option */
;|*** 
;|*** /*
;|***  * Maximums for allocations and loops.  It is not useful to change these --
;|***  * they are fixed by the deflate format.
;|***  */
;|*** #define MAXBITS 15              /* maximum bits in a code */
;|*** #define MAXLCODES 286           /* maximum number of literal/length codes */
;|*** #define MAXDCODES 30            /* maximum number of distance codes */
;|*** #define MAXCODES (MAXLCODES+MAXDCODES)  /* maximum codes lengths to read */
;|*** #define FIXLCODES 288           /* number of fixed literal/length codes */
;|*** 
;|*** /* input and output state */
;|*** struct state {
;|***     /* output state */
;|***     unsigned char *out;         /* output buffer */
;|***     unsigned int outlen;       /* available space at out */
;|***     unsigned int outcnt;       /* bytes written to out so far */
;|*** 
;|***     /* input state */
;|***     unsigned char *in;          /* input buffer */
;|***     unsigned int incnt;        /* bytes read so far */
;|***     int bitbuf;                 /* bit buffer */
;|***     int bitcnt;                 /* number of bits in bit buffer */
;|*** };
;|*** 
;|*** 
;|*** local int bits(struct state *s, int need)
;|*** {
; Line 57
	*** 000000	c8 06 00 00 		enter	6,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	s = 4
;	need = 6
;	val = -4
	*** 000006	8b 76 04 		mov	si,WORD PTR [bp+4]	;s
;|***     long val;           /* bit accumulator (can use up to 20 bits) */
;|*** 
;|***     /* load at least need bits into val */
;|***     val = s->bitbuf;
; Line 61
	*** 000009	66 0f bf 44 0a 		movsx	eax,WORD PTR [si+10]
	*** 00000e	66 89 46 fc 		mov	DWORD PTR [bp-4],eax	;val
	*** 000012	8b 7c 0c 		mov	di,WORD PTR [si+12]
;|***     while (s->bitcnt < need) {
; Line 62
	*** 000015	eb 1d 			jmp	SHORT $L378
					$FC109:
;|***         val |= (long)(s->in[s->incnt++]) << s->bitcnt;  /* load eight bits */
; Line 63
	*** 000017	8b 5c 06 		mov	bx,WORD PTR [si+6]
	*** 00001a	03 5c 08 		add	bx,WORD PTR [si+8]
	*** 00001d	2a e4 			sub	ah,ah
	*** 00001f	8a 07 			mov	al,BYTE PTR [bx]
	*** 000021	2b d2 			sub	dx,dx
	*** 000023	8b cf 			mov	cx,di
	*** 000025	e8 00 00 		call	__aNlshl
	*** 000028	09 46 fc 		or	WORD PTR [bp-4],ax	;val
	*** 00002b	09 56 fe 		or	WORD PTR [bp-2],dx
	*** 00002e	ff 44 08 		inc	WORD PTR [si+8]
;|***         s->bitcnt += 8;
; Line 64
	*** 000031	83 c7 08 		add	di,8
;|***     }
; Line 65
					$L378:
	*** 000034	39 7e 06 		cmp	WORD PTR [bp+6],di	;need
	*** 000037	7f de 			jg	SHORT $FC109
	*** 000039	8b 5e 04 		mov	bx,WORD PTR [bp+4]	;s
	*** 00003c	89 7f 0c 		mov	WORD PTR [bx+12],di
	*** 00003f	8b 7e 06 		mov	di,WORD PTR [bp+6]	;need
;|*** 
;|***     /* drop need bits and update buffer, always zero to seven bits left */
;|***     s->bitbuf = (int)(val >> need);
; Line 68
	*** 000042	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;val
	*** 000045	8b 56 fe 		mov	dx,WORD PTR [bp-2]
	*** 000048	8b cf 			mov	cx,di
	*** 00004a	89 7e fa 		mov	WORD PTR [bp-6],di
	*** 00004d	e8 00 00 		call	__aNlshr
	*** 000050	89 44 0a 		mov	WORD PTR [si+10],ax
;|***     s->bitcnt -= need;
; Line 69
	*** 000053	29 7c 0c 		sub	WORD PTR [si+12],di
;|*** 
;|***     /* return need bits, zeroing the bits above that */
;|***     return (int)(val & ((1L << need) - 1));
; Line 72
	*** 000056	b8 01 00 		mov	ax,1
	*** 000059	8a 4e fa 		mov	cl,BYTE PTR [bp-6]
	*** 00005c	d3 e0 			shl	ax,cl
	*** 00005e	48 			dec	ax
	*** 00005f	23 46 fc 		and	ax,WORD PTR [bp-4]	;val
;|*** }
; Line 73
	*** 000062	5e 			pop	si
	*** 000063	5f 			pop	di
	*** 000064	c9 			leave	
	*** 000065	c3 			ret	

bits	ENDP

stored	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** local int stored(struct state *s)
;|*** {
; Line 77
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
	*** 000003	57 			push	di
	*** 000004	56 			push	si
;	s = 4
;	register dx = len
	*** 000005	8b 76 04 		mov	si,WORD PTR [bp+4]	;s
	*** 000008	33 c0 			xor	ax,ax
	*** 00000a	8b 4c 08 		mov	cx,WORD PTR [si+8]
;|***     unsigned len;       /* length of stored block */
;|*** 
;|***     /* discard leftover bits from current byte (assumes s->bitcnt < 8) */
;|***     s->bitbuf = 0;
;|***     s->bitcnt = 0;
; Line 82
	*** 00000d	89 44 0a 		mov	WORD PTR [si+10],ax
	*** 000010	89 44 0c 		mov	WORD PTR [si+12],ax
;|*** 
;|***     /* get length and check against its one's complement */
;|***     len = s->in[s->incnt++];
; Line 85
	*** 000013	8b 5c 06 		mov	bx,WORD PTR [si+6]
	*** 000016	8b f9 			mov	di,cx
	*** 000018	8a 11 			mov	dl,BYTE PTR [bx][di]
	*** 00001a	2a f6 			sub	dh,dh
	*** 00001c	41 			inc	cx
;|***     len |= s->in[s->incnt++] << 8;
; Line 86
	*** 00001d	8b f9 			mov	di,cx
	*** 00001f	8a 21 			mov	ah,BYTE PTR [bx][di]
	*** 000021	0b d0 			or	dx,ax
;|***     if (s->in[s->incnt++] != (~len & 0xff) ||
;|***         s->in[s->incnt++] != ((~len >> 8) & 0xff))
; Line 88
	*** 000023	41 			inc	cx
	*** 000024	8b f9 			mov	di,cx
	*** 000026	8b c1 			mov	ax,cx
	*** 000028	40 			inc	ax
	*** 000029	8b c8 			mov	cx,ax
	*** 00002b	8b c2 			mov	ax,dx
	*** 00002d	f7 d0 			not	ax
	*** 00002f	38 01 			cmp	BYTE PTR [bx][di],al
	*** 000031	75 65 			jne	SHORT $L323
	*** 000033	8b f9 			mov	di,cx
	*** 000035	41 			inc	cx
	*** 000036	8a c6 			mov	al,dh
	*** 000038	2a e4 			sub	ah,ah
	*** 00003a	f7 d0 			not	ax
	*** 00003c	38 01 			cmp	BYTE PTR [bx][di],al
	*** 00003e	75 58 			jne	SHORT $L323
	*** 000040	89 4c 08 		mov	WORD PTR [si+8],cx
;|***         return -2;                              /* didn't match complement! */
;|*** 
;|***     /* copy len bytes from in to out */
;|***     if (s->out != NIL) {
; Line 92
	*** 000043	83 3c 00 		cmp	WORD PTR [si],0
	*** 000046	74 33 			je	SHORT $L324
;|***         if (s->outcnt + len > s->outlen)
; Line 93
	*** 000048	8b 44 04 		mov	ax,WORD PTR [si+4]
	*** 00004b	03 c2 			add	ax,dx
	*** 00004d	3b 44 02 		cmp	ax,WORD PTR [si+2]
	*** 000050	76 05 			jbe	SHORT $L320
;|***             return 1;                           /* not enough output space */
; Line 94
	*** 000052	b8 01 00 		mov	ax,1
	*** 000055	eb 4a 			jmp	SHORT $EX114
					$L320:
	*** 000057	8b 5e 04 		mov	bx,WORD PTR [bp+4]	;s
	*** 00005a	8b 4f 08 		mov	cx,WORD PTR [bx+8]
	*** 00005d	8b 7f 04 		mov	di,WORD PTR [bx+4]
	*** 000060	8b f3 			mov	si,bx
;|***         while (len--)
; Line 95
					$FC121:
	*** 000062	89 7c 04 		mov	WORD PTR [si+4],di
	*** 000065	8b c2 			mov	ax,dx
	*** 000067	4a 			dec	dx
	*** 000068	0b c0 			or	ax,ax
	*** 00006a	74 24 			je	SHORT $L325
;|***             s->out[s->outcnt++] = s->in[s->incnt++];
; Line 96
	*** 00006c	8b 5c 06 		mov	bx,WORD PTR [si+6]
	*** 00006f	03 d9 			add	bx,cx
	*** 000071	8a 07 			mov	al,BYTE PTR [bx]
	*** 000073	8b 1c 			mov	bx,WORD PTR [si]
	*** 000075	41 			inc	cx
	*** 000076	88 01 			mov	BYTE PTR [bx][di],al
	*** 000078	47 			inc	di
	*** 000079	eb e7 			jmp	SHORT $FC121
					$L324:
	*** 00007b	8b 5e 04 		mov	bx,WORD PTR [bp+4]	;s
	*** 00007e	89 4f 08 		mov	WORD PTR [bx+8],cx
;|***     }
;|***     else {                                      /* just scanning */
;|***         s->outcnt += len;
; Line 99
	*** 000081	01 54 04 		add	WORD PTR [si+4],dx
	*** 000084	8b 5c 08 		mov	bx,WORD PTR [si+8]
;|***         s->incnt += len;
; Line 100
	*** 000087	03 da 			add	bx,dx
	*** 000089	89 5c 08 		mov	WORD PTR [si+8],bx
					$I123:
;|***     }
;|*** 
;|***     /* done with a valid stored block */
;|***     return 0;
; Line 104
	*** 00008c	33 c0 			xor	ax,ax
	*** 00008e	eb 11 			jmp	SHORT $EX114
					$L325:
	*** 000090	8b 5e 04 		mov	bx,WORD PTR [bp+4]	;s
	*** 000093	89 4f 08 		mov	WORD PTR [bx+8],cx
	*** 000096	eb f4 			jmp	SHORT $I123
;|***     }
; Line 101
					$L323:
	*** 000098	8b 5e 04 		mov	bx,WORD PTR [bp+4]	;s
	*** 00009b	b8 fe ff 		mov	ax,-2	;fffeH
	*** 00009e	89 4f 08 		mov	WORD PTR [bx+8],cx
;|*** 
;|***     /* done with a valid stored block */
;|***     return 0;
;|*** }
; Line 105
					$EX114:
	*** 0000a1	5e 			pop	si
	*** 0000a2	5f 			pop	di
	*** 0000a3	c9 			leave	
	*** 0000a4	c3 			ret	

stored	ENDP

decode	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** struct huffman {
;|***     short *count;       /* number of symbols of each length */
;|***     short *symbol;      /* canonically ordered symbols */
;|*** };
;|*** 
;|*** 
;|*** #ifdef SLOW
;|*** local int decode(struct state *s, struct huffman *h)
;|*** {
;|***     int len;            /* current number of bits in code */
;|***     int code;           /* len bits being decoded */
;|***     int first;          /* first code of length len */
;|***     int count;          /* number of codes of length len */
;|***     int index;          /* index of first code of length len in symbol table */
;|*** 
;|***     code = first = index = 0;
;|***     for (len = 1; len <= MAXBITS; len++) {
;|***         code |= bits(s, 1);             /* get next bit */
;|***         count = h->count[len];
;|***         if (code < first + count)       /* if length len, return symbol */
;|***             return h->symbol[index + (code - first)];
;|***         index += count;                 /* else update for next length */
;|***         first += count;
;|***         first <<= 1;
;|***         code <<= 1;
;|***     }
;|***     return -9;                          /* ran out of codes */
;|*** }
;|*** 
;|*** /*
;|***  * A faster version of decode() for real applications of this code.   It's not
;|***  * as readable, but it makes puff() twice as fast.  And it only makes the code
;|***  * a few percent larger.
;|***  */
;|*** #else /* !SLOW */
;|*** local int decode(struct state *s, struct huffman *h)
;|*** {
; Line 144
	*** 000000	c8 10 00 00 		enter	16,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	h = 6
;	len = -8
;	code = -12
;	first = -10
;	count = -2
;	index = -14
;	bitbuf = -6
;	left = -4
;	next = -16
;	s = 4
	*** 000006	8b 4e 04 		mov	cx,WORD PTR [bp+4]	;s
;|***     int len;            /* current number of bits in code */
;|***     int code;           /* len bits being decoded */
;|***     int first;          /* first code of length len */
;|***     int count;          /* number of codes of length len */
;|***     int index;          /* index of first code of length len in symbol table */
;|***     int bitbuf;         /* bits from stream */
;|***     int left;           /* bits left in next or left to process */
;|***     short *next;        /* next number of codes */
;|*** 
;|***     bitbuf = s->bitbuf;
; Line 154
	*** 000009	8b d9 			mov	bx,cx
	*** 00000b	8b 47 0a 		mov	ax,WORD PTR [bx+10]
	*** 00000e	89 46 fa 		mov	WORD PTR [bp-6],ax	;bitbuf
;|***     left = s->bitcnt;
; Line 155
	*** 000011	8b 47 0c 		mov	ax,WORD PTR [bx+12]
	*** 000014	89 46 fc 		mov	WORD PTR [bp-4],ax	;left
;|***     code = first = index = 0;
; Line 156
	*** 000017	66 33 c0 		xor	eax,eax
	*** 00001a	89 46 f2 		mov	WORD PTR [bp-14],ax	;index
	*** 00001d	66 89 46 f4 		mov	DWORD PTR [bp-12],eax	;code
;|***     len = 1;
; Line 157
	*** 000021	c7 46 f8 01 00 		mov	WORD PTR [bp-8],1	;len
;|***     next = h->count + 1;
; Line 158
	*** 000026	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;h
	*** 000029	8b 07 			mov	ax,WORD PTR [bx]
	*** 00002b	40 			inc	ax
	*** 00002c	40 			inc	ax
	*** 00002d	89 46 f0 		mov	WORD PTR [bp-16],ax	;next
;|***     while (1) {
; Line 159
					$FC140:
	*** 000030	8b 76 f4 		mov	si,WORD PTR [bp-12]	;code
	*** 000033	8b 7e f6 		mov	di,WORD PTR [bp-10]	;first
;|***         while (left--) {
; Line 160
	*** 000036	eb 2c 			jmp	SHORT $L379
					$FC143:
;|***             code |= bitbuf & 1;
; Line 161
	*** 000038	8a 46 fa 		mov	al,BYTE PTR [bp-6]	;bitbuf
	*** 00003b	25 01 00 		and	ax,1
	*** 00003e	0b f0 			or	si,ax
;|***             bitbuf >>= 1;
; Line 162
	*** 000040	d1 7e fa 		sar	WORD PTR [bp-6],1	;bitbuf
;|***             count = *next++;
;|***             if (code < first + count) { /* if length len, return symbol */
; Line 164
	*** 000043	8b 5e f0 		mov	bx,WORD PTR [bp-16]	;next
	*** 000046	83 46 f0 02 		add	WORD PTR [bp-16],2	;next
	*** 00004a	8b 07 			mov	ax,WORD PTR [bx]
	*** 00004c	89 46 fe 		mov	WORD PTR [bp-2],ax	;count
	*** 00004f	03 c7 			add	ax,di
	*** 000051	3b c6 			cmp	ax,si
	*** 000053	7f 4d 			jg	SHORT $L329
;|***                 s->bitbuf = bitbuf;
;|***                 s->bitcnt = (s->bitcnt - len) & 7;
;|***                 return h->symbol[index + (code - first)];
;|***             }
;|***             index += count;             /* else update for next length */
; Line 169
	*** 000055	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;count
	*** 000058	01 46 f2 		add	WORD PTR [bp-14],ax	;index
;|***             first += count;
; Line 170
	*** 00005b	03 f8 			add	di,ax
;|***             first <<= 1;
; Line 171
	*** 00005d	03 ff 			add	di,di
;|***             code <<= 1;
; Line 172
	*** 00005f	03 f6 			add	si,si
;|***             len++;
; Line 173
	*** 000061	ff 46 f8 		inc	WORD PTR [bp-8]	;len
;|***         }
; Line 174
					$L379:
	*** 000064	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;left
	*** 000067	ff 4e fc 		dec	WORD PTR [bp-4]	;left
	*** 00006a	0b c0 			or	ax,ax
	*** 00006c	75 ca 			jne	SHORT $FC143
	*** 00006e	89 7e f6 		mov	WORD PTR [bp-10],di	;first
	*** 000071	89 76 f4 		mov	WORD PTR [bp-12],si	;code
;|***         left = (MAXBITS+1) - len;
;|***         if (left == 0) break;
; Line 176
	*** 000074	ba 10 00 		mov	dx,16	;0010H
	*** 000077	2b 56 f8 		sub	dx,WORD PTR [bp-8]	;len
	*** 00007a	74 50 			je	SHORT $L330
	*** 00007c	8b 4e 04 		mov	cx,WORD PTR [bp+4]	;s
;|***         bitbuf = s->in[s->incnt++];
; Line 177
	*** 00007f	8b d9 			mov	bx,cx
	*** 000081	8b f1 			mov	si,cx
	*** 000083	8b 5f 06 		mov	bx,WORD PTR [bx+6]
	*** 000086	8b 7c 08 		mov	di,WORD PTR [si+8]
	*** 000089	8a 01 			mov	al,BYTE PTR [bx][di]
	*** 00008b	2a e4 			sub	ah,ah
	*** 00008d	89 46 fa 		mov	WORD PTR [bp-6],ax	;bitbuf
	*** 000090	ff 44 08 		inc	WORD PTR [si+8]
	*** 000093	89 56 fc 		mov	WORD PTR [bp-4],dx	;left
;|***         if (left > 8) left = 8;
; Line 178
	*** 000096	83 fa 08 		cmp	dx,8
	*** 000099	7e 95 			jle	SHORT $FC140
	*** 00009b	c7 46 fc 08 00 		mov	WORD PTR [bp-4],8	;left
;|***     }
; Line 179
	*** 0000a0	eb 8e 			jmp	SHORT $FC140
					$L329:
	*** 0000a2	8b 4e 04 		mov	cx,WORD PTR [bp+4]	;s
;|***                 s->bitbuf = bitbuf;
; Line 165
	*** 0000a5	8b d9 			mov	bx,cx
	*** 0000a7	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;bitbuf
	*** 0000aa	89 47 0a 		mov	WORD PTR [bx+10],ax
;|***                 s->bitcnt = (s->bitcnt - len) & 7;
; Line 166
	*** 0000ad	8a 47 0c 		mov	al,BYTE PTR [bx+12]
	*** 0000b0	2a 46 f8 		sub	al,BYTE PTR [bp-8]	;len
	*** 0000b3	25 07 00 		and	ax,7
	*** 0000b6	89 47 0c 		mov	WORD PTR [bx+12],ax
;|***                 return h->symbol[index + (code - first)];
; Line 167
	*** 0000b9	8b de 			mov	bx,si
	*** 0000bb	2b df 			sub	bx,di
	*** 0000bd	03 5e f2 		add	bx,WORD PTR [bp-14]	;index
	*** 0000c0	8b 76 06 		mov	si,WORD PTR [bp+6]	;h
	*** 0000c3	03 db 			add	bx,bx
	*** 0000c5	8b 74 02 		mov	si,WORD PTR [si+2]
	*** 0000c8	8b 00 			mov	ax,WORD PTR [bx][si]
	*** 0000ca	eb 03 			jmp	SHORT $EX130
					$L330:
;|***             }
;|***             index += count;             /* else update for next length */
;|***             first += count;
;|***             first <<= 1;
;|***             code <<= 1;
;|***             len++;
;|***         }
;|***         left = (MAXBITS+1) - len;
;|***         if (left == 0) break;
;|***         bitbuf = s->in[s->incnt++];
;|***         if (left > 8) left = 8;
;|***     }
;|***     return -9;                          /* ran out of codes */
; Line 180
	*** 0000cc	b8 f7 ff 		mov	ax,-9	;fff7H
;|*** }
; Line 181
					$EX130:
	*** 0000cf	5e 			pop	si
	*** 0000d0	5f 			pop	di
	*** 0000d1	c9 			leave	
	*** 0000d2	c3 			ret	

decode	ENDP

construct	PROC NEAR	;  COMDAT
;|*** #endif /* SLOW */
;|*** 
;|*** 
;|*** local int construct(struct huffman *h, short *length, int n)
;|*** {
; Line 186
	*** 000000	c8 22 00 00 		enter	34,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	h = 4
;	length = 6
;	n = 8
;	register bx = symbol
;	register bx = len
;	left = -2
;	offs = -34
;|***     int symbol;         /* current symbol when stepping through length[] */
;|***     int len;            /* current length when stepping through h->count[] */
;|***     int left;           /* number of possible codes left of current length */
;|***     short offs[MAXBITS+1];      /* offsets in symbol table for each length */
;|*** 
;|***     /* count number of codes of each length */
;|***     for (len = 0; len <= MAXBITS; len++)
; Line 193
	*** 000006	33 db 			xor	bx,bx
	*** 000008	8b 7e 04 		mov	di,WORD PTR [bp+4]	;h
	*** 00000b	eb 0b 			jmp	SHORT $L380
					$F160:
;|***         h->count[len] = 0;
; Line 194
	*** 00000d	8b f3 			mov	si,bx
	*** 00000f	03 f3 			add	si,bx
	*** 000011	03 35 			add	si,WORD PTR [di]
	*** 000013	43 			inc	bx
	*** 000014	c7 04 00 00 		mov	WORD PTR [si],0
;|***     for (len = 0; len <= MAXBITS; len++)
; Line 193
					$L380:
	*** 000018	83 fb 0f 		cmp	bx,15	;000fH
	*** 00001b	7e f0 			jle	SHORT $F160
;|***         h->count[len] = 0;
;|***     for (symbol = 0; symbol < n; symbol++)
; Line 195
	*** 00001d	33 db 			xor	bx,bx
	*** 00001f	8b 56 06 		mov	dx,WORD PTR [bp+6]	;length
	*** 000022	8b 4e 08 		mov	cx,WORD PTR [bp+8]	;n
	*** 000025	eb 0f 			jmp	SHORT $L381
					$F163:
;|***         (h->count[length[symbol]])++;   /* assumes lengths are within bounds */
; Line 196
	*** 000027	8b f3 			mov	si,bx
	*** 000029	03 f3 			add	si,bx
	*** 00002b	03 f2 			add	si,dx
	*** 00002d	8b 34 			mov	si,WORD PTR [si]
	*** 00002f	03 f6 			add	si,si
	*** 000031	03 35 			add	si,WORD PTR [di]
	*** 000033	ff 04 			inc	WORD PTR [si]
;|***     for (symbol = 0; symbol < n; symbol++)
; Line 195
	*** 000035	43 			inc	bx
					$L381:
	*** 000036	3b d9 			cmp	bx,cx
	*** 000038	7c ed 			jl	SHORT $F163
;|***         (h->count[length[symbol]])++;   /* assumes lengths are within bounds */
;|***     if (h->count[0] == n)               /* no codes! */
; Line 197
	*** 00003a	8b 1d 			mov	bx,WORD PTR [di]
	*** 00003c	39 0f 			cmp	WORD PTR [bx],cx
	*** 00003e	75 05 			jne	SHORT $I166
;|***         return 0;                       /* complete, but decode() will fail */
; Line 198
	*** 000040	33 c0 			xor	ax,ax
	*** 000042	e9 87 00 		jmp	$EX155
;|*** 
;|***     /* check for an over-subscribed or incomplete set of lengths */
;|***     left = 1;                           /* one possible code of zero length */
; Line 201
					$I166:
;|***     for (len = 1; len <= MAXBITS; len++) {
; Line 202
	*** 000045	be 01 00 		mov	si,1
	*** 000048	8b fe 			mov	di,si
					$F167:
	*** 00004a	83 fe 0f 		cmp	si,15	;000fH
	*** 00004d	7f 18 			jg	SHORT $L339
;|***         left <<= 1;                     /* one more bit, double codes left */
; Line 203
	*** 00004f	8b 5e 04 		mov	bx,WORD PTR [bp+4]	;h
	*** 000052	03 ff 			add	di,di
;|***         left -= h->count[len];          /* deduct count from possible codes */
;|***         if (left < 0) return left;      /* over-subscribed--return negative */
; Line 205
	*** 000054	8b 07 			mov	ax,WORD PTR [bx]
	*** 000056	8b de 			mov	bx,si
	*** 000058	03 de 			add	bx,si
	*** 00005a	03 d8 			add	bx,ax
	*** 00005c	2b 3f 			sub	di,WORD PTR [bx]
	*** 00005e	78 03 			js	SHORT $L338
;|***     for (len = 1; len <= MAXBITS; len++) {
; Line 202
	*** 000060	46 			inc	si
	*** 000061	eb e7 			jmp	SHORT $F167
					$L338:
;|***         left <<= 1;                     /* one more bit, double codes left */
;|***         left -= h->count[len];          /* deduct count from possible codes */
;|***         if (left < 0) return left;      /* over-subscribed--return negative */
; Line 205
	*** 000063	8b c7 			mov	ax,di
	*** 000065	eb 65 			jmp	SHORT $EX155
					$L339:
	*** 000067	89 7e fe 		mov	WORD PTR [bp-2],di	;left
;|***     }                                   /* left > 0 means incomplete */
;|*** 
;|***     /* generate offsets into symbol table for each length for sorting */
;|***     offs[1] = 0;
; Line 209
	*** 00006a	c7 46 e0 00 00 		mov	WORD PTR [bp-32],0
;|***     for (len = 1; len < MAXBITS; len++)
; Line 210
	*** 00006f	bb 01 00 		mov	bx,1
					$F171:
;|***         offs[len + 1] = offs[len] + h->count[len];
; Line 211
	*** 000072	8b f3 			mov	si,bx
	*** 000074	03 f3 			add	si,bx
	*** 000076	8b 7e 04 		mov	di,WORD PTR [bp+4]	;h
	*** 000079	8b c6 			mov	ax,si
	*** 00007b	03 35 			add	si,WORD PTR [di]
	*** 00007d	8b 0c 			mov	cx,WORD PTR [si]
	*** 00007f	8b f0 			mov	si,ax
	*** 000081	03 4a de 		add	cx,WORD PTR [bp-34][si]
	*** 000084	89 4a e0 		mov	WORD PTR [bp-32][si],cx
;|***     for (len = 1; len < MAXBITS; len++)
; Line 210
	*** 000087	43 			inc	bx
	*** 000088	83 fb 0f 		cmp	bx,15	;000fH
	*** 00008b	7c e5 			jl	SHORT $F171
;|***         offs[len + 1] = offs[len] + h->count[len];
;|*** 
;|***     /*
;|***      * put symbols in table sorted by length, by symbol order within each
;|***      * length
;|***      */
;|***     for (symbol = 0; symbol < n; symbol++)
; Line 217
	*** 00008d	33 db 			xor	bx,bx
	*** 00008f	8b 56 06 		mov	dx,WORD PTR [bp+6]	;length
	*** 000092	8b 4e 08 		mov	cx,WORD PTR [bp+8]	;n
	*** 000095	8b 7e 04 		mov	di,WORD PTR [bp+4]	;h
	*** 000098	eb 2b 			jmp	SHORT $L383
					$F174:
;|***         if (length[symbol] != 0)
; Line 218
	*** 00009a	8b f3 			mov	si,bx
	*** 00009c	03 f3 			add	si,bx
	*** 00009e	03 f2 			add	si,dx
	*** 0000a0	83 3c 00 		cmp	WORD PTR [si],0
	*** 0000a3	74 1f 			je	SHORT $FC175
;|***             h->symbol[offs[length[symbol]]++] = symbol;
; Line 219
	*** 0000a5	8b f3 			mov	si,bx
	*** 0000a7	03 f3 			add	si,bx
	*** 0000a9	03 f2 			add	si,dx
	*** 0000ab	8b c6 			mov	ax,si
	*** 0000ad	8b 34 			mov	si,WORD PTR [si]
	*** 0000af	03 f6 			add	si,si
	*** 0000b1	8b 72 de 		mov	si,WORD PTR [bp-34][si]
	*** 0000b4	03 f6 			add	si,si
	*** 0000b6	03 75 02 		add	si,WORD PTR [di+2]
	*** 0000b9	89 1c 			mov	WORD PTR [si],bx
	*** 0000bb	8b f0 			mov	si,ax
	*** 0000bd	8b 34 			mov	si,WORD PTR [si]
	*** 0000bf	03 f6 			add	si,si
	*** 0000c1	ff 42 de 		inc	WORD PTR [bp-34][si]
;|***     for (symbol = 0; symbol < n; symbol++)
; Line 217
					$FC175:
	*** 0000c4	43 			inc	bx
					$L383:
	*** 0000c5	3b d9 			cmp	bx,cx
	*** 0000c7	7c d1 			jl	SHORT $F174
;|***         if (length[symbol] != 0)
;|***             h->symbol[offs[length[symbol]]++] = symbol;
;|*** 
;|***     /* return zero for complete set, positive for incomplete set */
;|***     return left;
; Line 222
	*** 0000c9	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;left
;|*** }
; Line 223
					$EX155:
	*** 0000cc	5e 			pop	si
	*** 0000cd	5f 			pop	di
	*** 0000ce	c9 			leave	
	*** 0000cf	c3 			ret	

construct	ENDP

codes	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** local int codes(struct state *s,
;|***                 struct huffman *lencode,
;|***                 struct huffman *distcode)
;|*** {
; Line 229
	*** 000000	c8 0e 00 00 		enter	14,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	s = 4
;	lencode = 6
;	distcode = 8
;	symbol = -6
;	len = -2
;	dist = -4
	*** 000006	8b 76 04 		mov	si,WORD PTR [bp+4]	;s
;|***     int symbol;         /* decoded symbol */
;|***     int len;            /* length for copy */
;|***     unsigned dist;      /* distance for copy */
;|***     static const short lens[29] = { /* Size base for length codes 257..285 */
;|***         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
;|***         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258};
;|***     static const short lext[29] = { /* Extra bits for length codes 257..285 */
;|***         0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
;|***         3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};
;|***     static const short dists[30] = { /* Offset base for distance codes 0..29 */
;|***         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
;|***         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
;|***         8193, 12289, 16385, 24577};
;|***     static const short dext[30] = { /* Extra bits for distance codes 0..29 */
;|***         0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
;|***         7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
;|***         12, 12, 13, 13};
;|*** 
;|***     /* decode literals and length/distance pairs */
;|***     do {
; Line 249
					$D197:
;|***         symbol = decode(s, lencode);
;|***         if (symbol < 0) return symbol;  /* invalid symbol */
; Line 251
	*** 000009	ff 76 06 		push	WORD PTR [bp+6]	;lencode
	*** 00000c	56 			push	si
	*** 00000d	e8 00 00 		call	decode
	*** 000010	83 c4 04 		add	sp,4
	*** 000013	8b f8 			mov	di,ax
	*** 000015	0b f8 			or	di,ax
	*** 000017	0f 8c e6 00 		jl	$L342
;|***         if (symbol < 256) {             /* literal: symbol is the byte */
; Line 252
	*** 00001b	81 ff 00 01 		cmp	di,256	;0100H
	*** 00001f	7d 1d 			jge	SHORT $I201
;|***             /* write out the literal */
;|***             if (s->out != NIL) {
; Line 254
	*** 000021	83 3c 00 		cmp	WORD PTR [si],0
	*** 000024	74 12 			je	SHORT $I202
;|***                 if (s->outcnt == s->outlen) return 1;
; Line 255
	*** 000026	8b 44 04 		mov	ax,WORD PTR [si+4]
	*** 000029	39 44 02 		cmp	WORD PTR [si+2],ax
	*** 00002c	0f 84 da 00 		je	$L344
;|***                 s->out[s->outcnt] = symbol;
; Line 256
	*** 000030	8b d8 			mov	bx,ax
	*** 000032	03 1c 			add	bx,WORD PTR [si]
	*** 000034	8b c7 			mov	ax,di
	*** 000036	88 07 			mov	BYTE PTR [bx],al
;|***             }
;|***             s->outcnt++;
; Line 258
					$I202:
	*** 000038	ff 44 04 		inc	WORD PTR [si+4]
;|***         }
;|***         else if (symbol > 256) {        /* length */
; Line 260
	*** 00003b	e9 b4 00 		jmp	$DC198
					$I201:
	*** 00003e	81 ff 00 01 		cmp	di,256	;0100H
	*** 000042	0f 8e ac 00 		jle	$DC198
;|***             /* get and compute length */
;|***             symbol -= 257;
;|***             if (symbol >= 29) return -9;        /* invalid fixed code */
; Line 263
	*** 000046	81 ef 01 01 		sub	di,257	;0101H
	*** 00004a	83 ff 1d 		cmp	di,29	;001dH
	*** 00004d	0f 8d ab 00 		jge	$L345
;|***             len = lens[symbol] + bits(s, lext[symbol]);
; Line 264
	*** 000051	8b df 			mov	bx,di
	*** 000053	03 df 			add	bx,di
	*** 000055	ff b7 00 00 		push	WORD PTR $S192_?lext@?1??codes@@9@9[bx]
	*** 000059	56 			push	si
	*** 00005a	89 5e f8 		mov	WORD PTR [bp-8],bx
	*** 00005d	e8 00 00 		call	bits
	*** 000060	8b 5e f8 		mov	bx,WORD PTR [bp-8]
	*** 000063	83 c4 04 		add	sp,4
	*** 000066	03 87 00 00 		add	ax,WORD PTR $S190_?lens@?1??codes@@9@9[bx]
	*** 00006a	89 46 fe 		mov	WORD PTR [bp-2],ax	;len
;|*** 
;|***             /* get and check distance */
;|***             symbol = decode(s, distcode);
;|***             if (symbol < 0) return symbol;      /* invalid symbol */
; Line 268
	*** 00006d	ff 76 08 		push	WORD PTR [bp+8]	;distcode
	*** 000070	56 			push	si
	*** 000071	e8 00 00 		call	decode
	*** 000074	83 c4 04 		add	sp,4
	*** 000077	8b f8 			mov	di,ax
	*** 000079	0b f8 			or	di,ax
	*** 00007b	0f 8c 82 00 		jl	$L342
;|***             dist = dists[symbol] + bits(s, dext[symbol]);
; Line 269
	*** 00007f	8b d8 			mov	bx,ax
	*** 000081	03 d8 			add	bx,ax
	*** 000083	ff b7 00 00 		push	WORD PTR $S196_?dext@?1??codes@@9@9[bx]
	*** 000087	56 			push	si
	*** 000088	89 5e f6 		mov	WORD PTR [bp-10],bx
	*** 00008b	e8 00 00 		call	bits
	*** 00008e	8b 5e f6 		mov	bx,WORD PTR [bp-10]
	*** 000091	83 c4 04 		add	sp,4
	*** 000094	03 87 00 00 		add	ax,WORD PTR $S194_?dists@?1??codes@@9@9[bx]
	*** 000098	89 46 fc 		mov	WORD PTR [bp-4],ax	;dist
;|***             if (dist > s->outcnt)
; Line 270
	*** 00009b	39 44 04 		cmp	WORD PTR [si+4],ax
	*** 00009e	72 65 			jb	SHORT $L347
;|***                 return -10;     /* distance too far back */
;|*** 
;|***             /* copy length bytes from distance bytes back */
;|***             if (s->out != NIL) {
; Line 274
	*** 0000a0	83 3c 00 		cmp	WORD PTR [si],0
	*** 0000a3	74 47 			je	SHORT $I209
;|***                 if (s->outcnt + len > s->outlen) return 1;
; Line 275
	*** 0000a5	8b 44 04 		mov	ax,WORD PTR [si+4]
	*** 0000a8	03 46 fe 		add	ax,WORD PTR [bp-2]	;len
	*** 0000ab	3b 44 02 		cmp	ax,WORD PTR [si+2]
	*** 0000ae	77 5a 			ja	SHORT $L344
	*** 0000b0	8b 56 fe 		mov	dx,WORD PTR [bp-2]	;len
	*** 0000b3	8b 76 fc 		mov	si,WORD PTR [bp-4]	;dist
;|***                 while (len--) {
; Line 276
	*** 0000b6	eb 28 			jmp	SHORT $L386
					$FC212:
;|***                     s->out[s->outcnt] = s->out[s->outcnt - dist];
; Line 277
	*** 0000b8	8b 5e 04 		mov	bx,WORD PTR [bp+4]	;s
	*** 0000bb	8b 5f 04 		mov	bx,WORD PTR [bx+4]
	*** 0000be	8b c3 			mov	ax,bx
	*** 0000c0	8b 5e 04 		mov	bx,WORD PTR [bp+4]	;s
	*** 0000c3	8b 0f 			mov	cx,WORD PTR [bx]
	*** 0000c5	89 5e f4 		mov	WORD PTR [bp-12],bx
	*** 0000c8	8b d8 			mov	bx,ax
	*** 0000ca	03 d9 			add	bx,cx
	*** 0000cc	2b de 			sub	bx,si
	*** 0000ce	89 46 f2 		mov	WORD PTR [bp-14],ax
	*** 0000d1	8a 07 			mov	al,BYTE PTR [bx]
	*** 0000d3	8b d9 			mov	bx,cx
	*** 0000d5	03 5e f2 		add	bx,WORD PTR [bp-14]
	*** 0000d8	88 07 			mov	BYTE PTR [bx],al
;|***                     s->outcnt++;
; Line 278
	*** 0000da	8b 5e f4 		mov	bx,WORD PTR [bp-12]
	*** 0000dd	ff 47 04 		inc	WORD PTR [bx+4]
;|***                 }
; Line 279
					$L386:
	*** 0000e0	8b c2 			mov	ax,dx
	*** 0000e2	4a 			dec	dx
	*** 0000e3	0b c0 			or	ax,ax
	*** 0000e5	75 d1 			jne	SHORT $FC212
	*** 0000e7	8b 76 04 		mov	si,WORD PTR [bp+4]	;s
	*** 0000ea	eb 06 			jmp	SHORT $DC198
;|***             }
;|***             else
; Line 281
					$I209:
;|***                 s->outcnt += len;
; Line 282
	*** 0000ec	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;len
	*** 0000ef	01 44 04 		add	WORD PTR [si+4],ax
;|***         }
;|***     } while (symbol != 256);            /* end of block symbol */
; Line 284
					$DC198:
	*** 0000f2	81 ff 00 01 		cmp	di,256	;0100H
	*** 0000f6	0f 85 0f ff 		jne	$D197
	*** 0000fa	eb 13 			jmp	SHORT $L343
					$L345:
;|***             if (symbol >= 29) return -9;        /* invalid fixed code */
; Line 263
	*** 0000fc	b8 f7 ff 		mov	ax,-9	;fff7H
	*** 0000ff	eb 10 			jmp	SHORT $EX185
					$L342:
;|***         if (symbol < 0) return symbol;  /* invalid symbol */
; Line 251
	*** 000101	8b c7 			mov	ax,di
	*** 000103	eb 0c 			jmp	SHORT $EX185
					$L347:
;|***         if (symbol < 256) {             /* literal: symbol is the byte */
;|***             /* write out the literal */
;|***             if (s->out != NIL) {
;|***                 if (s->outcnt == s->outlen) return 1;
;|***                 s->out[s->outcnt] = symbol;
;|***             }
;|***             s->outcnt++;
;|***         }
;|***         else if (symbol > 256) {        /* length */
;|***             /* get and compute length */
;|***             symbol -= 257;
;|***             if (symbol >= 29) return -9;        /* invalid fixed code */
;|***             len = lens[symbol] + bits(s, lext[symbol]);
;|*** 
;|***             /* get and check distance */
;|***             symbol = decode(s, distcode);
;|***             if (symbol < 0) return symbol;      /* invalid symbol */
;|***             dist = dists[symbol] + bits(s, dext[symbol]);
;|***             if (dist > s->outcnt)
;|***                 return -10;     /* distance too far back */
; Line 271
	*** 000105	b8 f6 ff 		mov	ax,-10	;fff6H
	*** 000108	eb 07 			jmp	SHORT $EX185
					$L344:
;|***                 if (s->outcnt == s->outlen) return 1;
; Line 255
	*** 00010a	b8 01 00 		mov	ax,1
	*** 00010d	eb 02 			jmp	SHORT $EX185
					$L343:
;|***                 s->out[s->outcnt] = symbol;
;|***             }
;|***             s->outcnt++;
;|***         }
;|***         else if (symbol > 256) {        /* length */
;|***             /* get and compute length */
;|***             symbol -= 257;
;|***             if (symbol >= 29) return -9;        /* invalid fixed code */
;|***             len = lens[symbol] + bits(s, lext[symbol]);
;|*** 
;|***             /* get and check distance */
;|***             symbol = decode(s, distcode);
;|***             if (symbol < 0) return symbol;      /* invalid symbol */
;|***             dist = dists[symbol] + bits(s, dext[symbol]);
;|***             if (dist > s->outcnt)
;|***                 return -10;     /* distance too far back */
;|*** 
;|***             /* copy length bytes from distance bytes back */
;|***             if (s->out != NIL) {
;|***                 if (s->outcnt + len > s->outlen) return 1;
;|***                 while (len--) {
;|***                     s->out[s->outcnt] = s->out[s->outcnt - dist];
;|***                     s->outcnt++;
;|***                 }
;|***             }
;|***             else
;|***                 s->outcnt += len;
;|***         }
;|***     } while (symbol != 256);            /* end of block symbol */
;|*** 
;|***     /* done with a valid fixed or dynamic block */
;|***     return 0;
; Line 287
	*** 00010f	33 c0 			xor	ax,ax
;|*** }
; Line 288
					$EX185:
	*** 000111	5e 			pop	si
	*** 000112	5f 			pop	di
	*** 000113	c9 			leave	
	*** 000114	c3 			ret	

codes	ENDP

fixed	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** local int fixed(struct state *s)
;|*** {
; Line 292
	*** 000000	c8 40 02 00 		enter	576,0
	*** 000004	56 			push	si
;	s = 4
;	register bx = symbol
;	lengths = -576
;|***     static int virgin = 1;
;|***     static short lencnt[MAXBITS+1], lensym[FIXLCODES];
;|***     static short distcnt[MAXBITS+1], distsym[MAXDCODES];
;|***     static struct huffman lencode = {lencnt, lensym};
;|***     static struct huffman distcode = {distcnt, distsym};
;|*** 
;|***     /* build fixed huffman tables if first call (may not be thread safe) */
;|***     if (virgin) {
; Line 300
	*** 000005	83 3e 00 00 00 		cmp	WORD PTR $S220_?virgin@?1??fixed@@9@9,0
	*** 00000a	0f 84 84 00 		je	$I233
;|***         int symbol;
;|***         short lengths[FIXLCODES];
;|*** 
;|***         /* literal/length table */
;|***         for (symbol = 0; symbol < 144; symbol++)
; Line 305
	*** 00000e	33 db 			xor	bx,bx
					$F236:
;|***             lengths[symbol] = 8;
; Line 306
	*** 000010	8b f3 			mov	si,bx
	*** 000012	03 f3 			add	si,bx
	*** 000014	c7 82 c0 fd 08 00 	mov	WORD PTR [bp-576][si],8
;|***         for (symbol = 0; symbol < 144; symbol++)
; Line 305
	*** 00001a	43 			inc	bx
	*** 00001b	81 fb 90 00 		cmp	bx,144	;0090H
	*** 00001f	7c ef 			jl	SHORT $F236
;|***             lengths[symbol] = 8;
;|***         for (; symbol < 256; symbol++)
; Line 307
	*** 000021	eb 0b 			jmp	SHORT $L388
					$F239:
;|***             lengths[symbol] = 9;
; Line 308
	*** 000023	8b f3 			mov	si,bx
	*** 000025	03 f3 			add	si,bx
	*** 000027	c7 82 c0 fd 09 00 	mov	WORD PTR [bp-576][si],9
;|***         for (; symbol < 256; symbol++)
; Line 307
	*** 00002d	43 			inc	bx
					$L388:
	*** 00002e	81 fb 00 01 		cmp	bx,256	;0100H
	*** 000032	7c ef 			jl	SHORT $F239
;|***             lengths[symbol] = 9;
;|***         for (; symbol < 280; symbol++)
; Line 309
	*** 000034	eb 0b 			jmp	SHORT $L389
					$F242:
;|***             lengths[symbol] = 7;
; Line 310
	*** 000036	8b f3 			mov	si,bx
	*** 000038	03 f3 			add	si,bx
	*** 00003a	c7 82 c0 fd 07 00 	mov	WORD PTR [bp-576][si],7
;|***         for (; symbol < 280; symbol++)
; Line 309
	*** 000040	43 			inc	bx
					$L389:
	*** 000041	81 fb 18 01 		cmp	bx,280	;0118H
	*** 000045	7c ef 			jl	SHORT $F242
;|***             lengths[symbol] = 7;
;|***         for (; symbol < FIXLCODES; symbol++)
; Line 311
	*** 000047	eb 0b 			jmp	SHORT $L390
					$F245:
;|***             lengths[symbol] = 8;
; Line 312
	*** 000049	8b f3 			mov	si,bx
	*** 00004b	03 f3 			add	si,bx
	*** 00004d	c7 82 c0 fd 08 00 	mov	WORD PTR [bp-576][si],8
;|***         for (; symbol < FIXLCODES; symbol++)
; Line 311
	*** 000053	43 			inc	bx
					$L390:
	*** 000054	81 fb 20 01 		cmp	bx,288	;0120H
	*** 000058	7c ef 			jl	SHORT $F245
;|***             lengths[symbol] = 8;
;|***         construct(&lencode, lengths, FIXLCODES);
; Line 313
	*** 00005a	68 20 01 		push	288	;0120H
	*** 00005d	8d 86 c0 fd 		lea	ax,WORD PTR [bp-576]	;lengths
	*** 000061	50 			push	ax
	*** 000062	68 00 00 		push	OFFSET DGROUP:$S230_?lencode@?1??fixed@@9@9
	*** 000065	e8 00 00 		call	construct
	*** 000068	83 c4 06 		add	sp,6
;|*** 
;|***         /* distance table */
;|***         for (symbol = 0; symbol < MAXDCODES; symbol++)
; Line 316
	*** 00006b	33 f6 			xor	si,si
					$F248:
;|***             lengths[symbol] = 5;
; Line 317
	*** 00006d	8d 9a c0 fd 		lea	bx,WORD PTR [bp-576][si]
	*** 000071	36 c7 00 05 00 		mov	WORD PTR ss:[bx][si],5
;|***         for (symbol = 0; symbol < MAXDCODES; symbol++)
; Line 316
	*** 000076	46 			inc	si
	*** 000077	83 fe 1e 		cmp	si,30	;001eH
	*** 00007a	7c f1 			jl	SHORT $F248
;|***             lengths[symbol] = 5;
;|***         construct(&distcode, lengths, MAXDCODES);
; Line 318
	*** 00007c	6a 1e 			push	30	;001eH
	*** 00007e	8d 86 c0 fd 		lea	ax,WORD PTR [bp-576]	;lengths
	*** 000082	50 			push	ax
	*** 000083	68 00 00 		push	OFFSET DGROUP:$S232_?distcode@?1??fixed@@9@9
	*** 000086	e8 00 00 		call	construct
	*** 000089	83 c4 06 		add	sp,6
;|*** 
;|***         /* do this just once */
;|***         virgin = 0;
; Line 321
	*** 00008c	c7 06 00 00 00 00 	mov	WORD PTR $S220_?virgin@?1??fixed@@9@9,0
;|***     }
;|*** 
;|***     /* decode data until end-of-block code */
;|***     return codes(s, &lencode, &distcode);
; Line 325
					$I233:
	*** 000092	68 00 00 		push	OFFSET DGROUP:$S232_?distcode@?1??fixed@@9@9
	*** 000095	68 00 00 		push	OFFSET DGROUP:$S230_?lencode@?1??fixed@@9@9
	*** 000098	ff 76 04 		push	WORD PTR [bp+4]	;s
	*** 00009b	e8 00 00 		call	codes
	*** 00009e	83 c4 06 		add	sp,6
;|*** }
; Line 326
	*** 0000a1	5e 			pop	si
	*** 0000a2	c9 			leave	
	*** 0000a3	c3 			ret	

fixed	ENDP

dynamic	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** local int dynamic(struct state *s)
;|*** {
; Line 330
	*** 000000	c8 40 05 00 		enter	1344,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	ndist = -8
;	ncode = -2
;	index = -4
;	register si = err
;	lengths = -1344
;	lencnt = -48
;	lensym = -712
;	distcnt = -80
;	distsym = -140
;	lencode = -12
;	distcode = -16
;	register di = symbol
;	len = -2
;	s = 4
;	nlen = -6
	*** 000006	8b 7e 04 		mov	di,WORD PTR [bp+4]	;s
;|***     int nlen, ndist, ncode;             /* number of lengths in descriptor */
;|***     int index;                          /* index of lengths[] */
;|***     int err;                            /* construct() return value */
;|***     short lengths[MAXCODES];            /* descriptor code lengths */
;|***     short lencnt[MAXBITS+1], lensym[MAXLCODES];         /* lencode memory */
;|***     short distcnt[MAXBITS+1], distsym[MAXDCODES];       /* distcode memory */
;|***     struct huffman lencode = {lencnt, lensym};          /* length code */
; Line 337
	*** 000009	8d 46 d0 		lea	ax,WORD PTR [bp-48]	;lencnt
	*** 00000c	89 46 f4 		mov	WORD PTR [bp-12],ax	;lencode
	*** 00000f	8d 86 38 fd 		lea	ax,WORD PTR [bp-712]	;lensym
	*** 000013	89 46 f6 		mov	WORD PTR [bp-10],ax
;|***     struct huffman distcode = {distcnt, distsym};       /* distance code */
; Line 338
	*** 000016	8d 46 b0 		lea	ax,WORD PTR [bp-80]	;distcnt
	*** 000019	89 46 f0 		mov	WORD PTR [bp-16],ax	;distcode
	*** 00001c	8d 86 74 ff 		lea	ax,WORD PTR [bp-140]	;distsym
	*** 000020	89 46 f2 		mov	WORD PTR [bp-14],ax
;|***     static const short order[19] =      /* permutation of code length codes */
;|***         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
;|*** 
;|***     /* get number of lengths in each table, check lengths */
;|***     nlen = bits(s, 5) + 257;
; Line 343
	*** 000023	6a 05 			push	5
	*** 000025	57 			push	di
	*** 000026	e8 00 00 		call	bits
	*** 000029	83 c4 04 		add	sp,4
	*** 00002c	05 01 01 		add	ax,257	;0101H
	*** 00002f	89 46 fa 		mov	WORD PTR [bp-6],ax	;nlen
;|***     ndist = bits(s, 5) + 1;
; Line 344
	*** 000032	6a 05 			push	5
	*** 000034	57 			push	di
	*** 000035	e8 00 00 		call	bits
	*** 000038	83 c4 04 		add	sp,4
	*** 00003b	8b f0 			mov	si,ax
	*** 00003d	46 			inc	si
;|***     ncode = bits(s, 4) + 4;
; Line 345
	*** 00003e	6a 04 			push	4
	*** 000040	57 			push	di
	*** 000041	e8 00 00 		call	bits
	*** 000044	83 c4 04 		add	sp,4
	*** 000047	05 04 00 		add	ax,4
	*** 00004a	89 46 fe 		mov	WORD PTR [bp-2],ax	;ncode
;|***     if (nlen > MAXLCODES || ndist > MAXDCODES)
; Line 346
	*** 00004d	81 7e fa 1e 01 		cmp	WORD PTR [bp-6],286	;011eH	;nlen
	*** 000052	7f 05 			jg	SHORT $L395
	*** 000054	83 fe 1e 		cmp	si,30	;001eH
	*** 000057	7e 03 			jle	SHORT $L394
					$L395:
	*** 000059	e9 75 01 		jmp	$I270
					$L394:
	*** 00005c	89 76 f8 		mov	WORD PTR [bp-8],si	;ndist
;|***         return -3;                      /* bad counts */
;|*** 
;|***     /* read code length code lengths (really), missing lengths are zero */
;|***     for (index = 0; index < ncode; index++)
; Line 350
	*** 00005f	33 d2 			xor	dx,dx
	*** 000061	89 56 fc 		mov	WORD PTR [bp-4],dx	;index
	*** 000064	8b f2 			mov	si,dx
	*** 000066	eb 1a 			jmp	SHORT $L392
					$F271:
;|***         lengths[order[index]] = bits(s, 3);
; Line 351
	*** 000068	6a 03 			push	3
	*** 00006a	57 			push	di
	*** 00006b	e8 00 00 		call	bits
	*** 00006e	8b de 			mov	bx,si
	*** 000070	83 c4 04 		add	sp,4
	*** 000073	8b 98 00 00 		mov	bx,WORD PTR $S268_?order@?1??dynamic@@9@9[bx][si]
	*** 000077	03 db 			add	bx,bx
	*** 000079	8d 8e c0 fa 		lea	cx,WORD PTR [bp-1344]	;lengths
	*** 00007d	03 d9 			add	bx,cx
	*** 00007f	46 			inc	si
	*** 000080	89 07 			mov	WORD PTR [bx],ax
;|***     for (index = 0; index < ncode; index++)
; Line 350
					$L392:
	*** 000082	39 76 fe 		cmp	WORD PTR [bp-2],si	;ncode
	*** 000085	7f e1 			jg	SHORT $F271
;|***         lengths[order[index]] = bits(s, 3);
;|***     for (; index < 19; index++)
; Line 352
	*** 000087	eb 0f 			jmp	SHORT $L393
					$F274:
;|***         lengths[order[index]] = 0;
; Line 353
	*** 000089	8b de 			mov	bx,si
	*** 00008b	8b b8 00 00 		mov	di,WORD PTR $S268_?order@?1??dynamic@@9@9[bx][si]
	*** 00008f	03 ff 			add	di,di
	*** 000091	c7 83 c0 fa 00 00 	mov	WORD PTR [bp-1344][di],0
;|***     for (; index < 19; index++)
; Line 352
	*** 000097	46 			inc	si
					$L393:
	*** 000098	83 fe 13 		cmp	si,19	;0013H
	*** 00009b	7c ec 			jl	SHORT $F274
;|***         lengths[order[index]] = 0;
;|*** 
;|***     /* build huffman table for code lengths codes (use lencode temporarily) */
;|***     err = construct(&lencode, lengths, 19);
;|***     if (err != 0) return -4;            /* require complete code set here */
; Line 357
	*** 00009d	6a 13 			push	19	;0013H
	*** 00009f	8d 86 c0 fa 		lea	ax,WORD PTR [bp-1344]	;lengths
	*** 0000a3	50 			push	ax
	*** 0000a4	8d 46 f4 		lea	ax,WORD PTR [bp-12]	;lencode
	*** 0000a7	50 			push	ax
	*** 0000a8	e8 00 00 		call	construct
	*** 0000ab	83 c4 06 		add	sp,6
	*** 0000ae	0b c0 			or	ax,ax
	*** 0000b0	74 06 			je	SHORT $I277
	*** 0000b2	b8 fc ff 		mov	ax,-4	;fffcH
	*** 0000b5	e9 1c 01 		jmp	$EX254
;|*** 
;|***     /* read length/literal and distance code length tables */
;|***     index = 0;
; Line 360
					$I277:
	*** 0000b8	33 f6 			xor	si,si
;|***     while (index < nlen + ndist) {
; Line 361
					$FC279:
	*** 0000ba	8b 46 f8 		mov	ax,WORD PTR [bp-8]	;ndist
	*** 0000bd	03 46 fa 		add	ax,WORD PTR [bp-6]	;nlen
	*** 0000c0	3b c6 			cmp	ax,si
	*** 0000c2	0f 8e 9b 00 		jle	$FB280
;|***         int symbol;             /* decoded value */
;|***         int len;                /* last length to repeat */
;|*** 
;|***         symbol = decode(s, &lencode);
;|***         if (symbol < 16)                /* length in 0..15 */
; Line 366
	*** 0000c6	8d 46 f4 		lea	ax,WORD PTR [bp-12]	;lencode
	*** 0000c9	50 			push	ax
	*** 0000ca	ff 76 04 		push	WORD PTR [bp+4]	;s
	*** 0000cd	e8 00 00 		call	decode
	*** 0000d0	83 c4 04 		add	sp,4
	*** 0000d3	8b f8 			mov	di,ax
	*** 0000d5	83 ff 10 		cmp	di,16	;0010H
	*** 0000d8	7d 0a 			jge	SHORT $I283
;|***             lengths[index++] = symbol;
; Line 367
	*** 0000da	8d 9a c0 fa 		lea	bx,WORD PTR [bp-1344][si]
	*** 0000de	36 89 00 		mov	WORD PTR ss:[bx][si],ax
	*** 0000e1	46 			inc	si
;|***         else {                          /* repeat instruction */
; Line 368
	*** 0000e2	eb d6 			jmp	SHORT $FC279
					$I283:
;|***             len = 0;                    /* assume repeating zeros */
; Line 369
	*** 0000e4	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;ncode
;|***             if (symbol == 16) {         /* repeat last length 3..6 times */
; Line 370
	*** 0000e9	83 ff 10 		cmp	di,16	;0010H
	*** 0000ec	75 20 			jne	SHORT $I285
;|***                 if (index == 0) return -5;      /* no last length! */
; Line 371
	*** 0000ee	0b f6 			or	si,si
	*** 0000f0	74 65 			je	SHORT $L361
;|***                 len = lengths[index - 1];       /* last length */
; Line 372
	*** 0000f2	8d 9a be fa 		lea	bx,WORD PTR [bp-1346][si]
	*** 0000f6	36 8b 00 		mov	ax,WORD PTR ss:[bx][si]
	*** 0000f9	89 46 fe 		mov	WORD PTR [bp-2],ax	;ncode
;|***                 symbol = 3 + bits(s, 2);
; Line 373
	*** 0000fc	6a 02 			push	2
	*** 0000fe	ff 76 04 		push	WORD PTR [bp+4]	;s
	*** 000101	e8 00 00 		call	bits
	*** 000104	83 c4 04 		add	sp,4
	*** 000107	8b f8 			mov	di,ax
	*** 000109	83 c7 03 		add	di,3
;|***             }
;|***             else if (symbol == 17)      /* repeat zero 3..10 times */
; Line 375
	*** 00010c	eb 25 			jmp	SHORT $I287
					$I285:
	*** 00010e	83 ff 11 		cmp	di,17	;0011H
	*** 000111	75 10 			jne	SHORT $I288
	*** 000113	6a 03 			push	3
	*** 000115	ff 76 04 		push	WORD PTR [bp+4]	;s
	*** 000118	e8 00 00 		call	bits
	*** 00011b	83 c4 04 		add	sp,4
	*** 00011e	05 03 00 		add	ax,3
	*** 000121	eb 0e 			jmp	SHORT $L364
					$I288:
	*** 000123	6a 07 			push	7
	*** 000125	ff 76 04 		push	WORD PTR [bp+4]	;s
	*** 000128	e8 00 00 		call	bits
	*** 00012b	83 c4 04 		add	sp,4
	*** 00012e	05 0b 00 		add	ax,11	;000bH
					$L364:
	*** 000131	8b f8 			mov	di,ax
;|***                 symbol = 3 + bits(s, 3);
;|***             else                        /* == 18, repeat zero 11..138 times */
;|***                 symbol = 11 + bits(s, 7);
; Line 378
					$I287:
;|***             if (index + symbol > nlen + ndist)
; Line 379
	*** 000133	8b 46 f8 		mov	ax,WORD PTR [bp-8]	;ndist
	*** 000136	03 46 fa 		add	ax,WORD PTR [bp-6]	;nlen
	*** 000139	8b cf 			mov	cx,di
	*** 00013b	03 ce 			add	cx,si
	*** 00013d	3b c1 			cmp	ax,cx
	*** 00013f	7c 1b 			jl	SHORT $L363
	*** 000141	8b 56 fe 		mov	dx,WORD PTR [bp-2]	;ncode
;|***                 return -6;              /* too many lengths! */
;|***             while (symbol--)            /* repeat last or zero symbol times */
; Line 381
					$FC292:
	*** 000144	8b c7 			mov	ax,di
	*** 000146	4f 			dec	di
	*** 000147	0b c0 			or	ax,ax
	*** 000149	0f 84 6d ff 		je	$FC279
;|***                 lengths[index++] = len;
; Line 382
	*** 00014d	8d 9a c0 fa 		lea	bx,WORD PTR [bp-1344][si]
	*** 000151	36 89 10 		mov	WORD PTR ss:[bx][si],dx
	*** 000154	46 			inc	si
	*** 000155	eb ed 			jmp	SHORT $FC292
					$L361:
;|***                 if (index == 0) return -5;      /* no last length! */
; Line 371
	*** 000157	b8 fb ff 		mov	ax,-5	;fffbH
	*** 00015a	eb 78 			jmp	SHORT $EX254
					$L363:
;|***                 len = lengths[index - 1];       /* last length */
;|***                 symbol = 3 + bits(s, 2);
;|***             }
;|***             else if (symbol == 17)      /* repeat zero 3..10 times */
;|***                 symbol = 3 + bits(s, 3);
;|***             else                        /* == 18, repeat zero 11..138 times */
;|***                 symbol = 11 + bits(s, 7);
;|***             if (index + symbol > nlen + ndist)
;|***                 return -6;              /* too many lengths! */
; Line 380
	*** 00015c	b8 fa ff 		mov	ax,-6	;fffaH
	*** 00015f	eb 73 			jmp	SHORT $EX254
;|***             while (symbol--)            /* repeat last or zero symbol times */
;|***                 lengths[index++] = len;
;|***         }
;|***     }
; Line 384
					$FB280:
;|*** 
;|***     /* build huffman table for literal/length codes */
;|***     err = construct(&lencode, lengths, nlen);
;|***     if (err < 0 || (err > 0 && nlen - lencode.count[0] != 1))
; Line 388
	*** 000161	ff 76 fa 		push	WORD PTR [bp-6]	;nlen
	*** 000164	8d 86 c0 fa 		lea	ax,WORD PTR [bp-1344]	;lengths
	*** 000168	50 			push	ax
	*** 000169	8d 46 f4 		lea	ax,WORD PTR [bp-12]	;lencode
	*** 00016c	50 			push	ax
	*** 00016d	e8 00 00 		call	construct
	*** 000170	83 c4 06 		add	sp,6
	*** 000173	8b f0 			mov	si,ax
	*** 000175	0b f0 			or	si,ax
	*** 000177	7c 53 			jl	SHORT $I295
	*** 000179	0b f6 			or	si,si
	*** 00017b	7e 0b 			jle	SHORT $I294
	*** 00017d	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;lencode
	*** 000180	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;nlen
	*** 000183	2b 07 			sub	ax,WORD PTR [bx]
	*** 000185	48 			dec	ax
	*** 000186	75 44 			jne	SHORT $I295
;|***         return -7;      /* only allow incomplete codes if just one code */
;|*** 
;|***     /* build huffman table for distance codes */
;|***     err = construct(&distcode, lengths + nlen, ndist);
; Line 392
					$I294:
	*** 000188	8b 7e f8 		mov	di,WORD PTR [bp-8]	;ndist
;|***     if (err < 0 || (err > 0 && ndist - distcode.count[0] != 1))
; Line 393
	*** 00018b	57 			push	di
	*** 00018c	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;nlen
	*** 00018f	03 c0 			add	ax,ax
	*** 000191	8d 8e c0 fa 		lea	cx,WORD PTR [bp-1344]	;lengths
	*** 000195	03 c1 			add	ax,cx
	*** 000197	50 			push	ax
	*** 000198	8d 46 f0 		lea	ax,WORD PTR [bp-16]	;distcode
	*** 00019b	50 			push	ax
	*** 00019c	e8 00 00 		call	construct
	*** 00019f	83 c4 06 		add	sp,6
	*** 0001a2	8b f0 			mov	si,ax
	*** 0001a4	0b f0 			or	si,ax
	*** 0001a6	7c 1f 			jl	SHORT $I297
	*** 0001a8	0b f6 			or	si,si
	*** 0001aa	7e 08 			jle	SHORT $I296
	*** 0001ac	8b 5e f0 		mov	bx,WORD PTR [bp-16]	;distcode
	*** 0001af	2b 3f 			sub	di,WORD PTR [bx]
	*** 0001b1	4f 			dec	di
	*** 0001b2	75 13 			jne	SHORT $I297
;|***         return -8;      /* only allow incomplete codes if just one code */
;|*** 
;|***     /* decode data until end-of-block code */
;|***     return codes(s, &lencode, &distcode);
; Line 397
					$I296:
	*** 0001b4	8d 46 f0 		lea	ax,WORD PTR [bp-16]	;distcode
	*** 0001b7	50 			push	ax
	*** 0001b8	8d 46 f4 		lea	ax,WORD PTR [bp-12]	;lencode
	*** 0001bb	50 			push	ax
	*** 0001bc	ff 76 04 		push	WORD PTR [bp+4]	;s
	*** 0001bf	e8 00 00 		call	codes
	*** 0001c2	83 c4 06 		add	sp,6
	*** 0001c5	eb 0d 			jmp	SHORT $EX254
;|***     if (err < 0 || (err > 0 && ndist - distcode.count[0] != 1))
; Line 393
					$I297:
;|***         return -8;      /* only allow incomplete codes if just one code */
; Line 394
	*** 0001c7	b8 f8 ff 		mov	ax,-8	;fff8H
	*** 0001ca	eb 08 			jmp	SHORT $EX254
;|***     if (err < 0 || (err > 0 && nlen - lencode.count[0] != 1))
; Line 388
					$I295:
;|***         return -7;      /* only allow incomplete codes if just one code */
; Line 389
	*** 0001cc	b8 f9 ff 		mov	ax,-7	;fff9H
	*** 0001cf	eb 03 			jmp	SHORT $EX254
;|***     if (nlen > MAXLCODES || ndist > MAXDCODES)
; Line 346
					$I270:
;|***         return -3;                      /* bad counts */
; Line 347
	*** 0001d1	b8 fd ff 		mov	ax,-3	;fffdH
;|*** 
;|***     /* read code length code lengths (really), missing lengths are zero */
;|***     for (index = 0; index < ncode; index++)
;|***         lengths[order[index]] = bits(s, 3);
;|***     for (; index < 19; index++)
;|***         lengths[order[index]] = 0;
;|*** 
;|***     /* build huffman table for code lengths codes (use lencode temporarily) */
;|***     err = construct(&lencode, lengths, 19);
;|***     if (err != 0) return -4;            /* require complete code set here */
;|*** 
;|***     /* read length/literal and distance code length tables */
;|***     index = 0;
;|***     while (index < nlen + ndist) {
;|***         int symbol;             /* decoded value */
;|***         int len;                /* last length to repeat */
;|*** 
;|***         symbol = decode(s, &lencode);
;|***         if (symbol < 16)                /* length in 0..15 */
;|***             lengths[index++] = symbol;
;|***         else {                          /* repeat instruction */
;|***             len = 0;                    /* assume repeating zeros */
;|***             if (symbol == 16) {         /* repeat last length 3..6 times */
;|***                 if (index == 0) return -5;      /* no last length! */
;|***                 len = lengths[index - 1];       /* last length */
;|***                 symbol = 3 + bits(s, 2);
;|***             }
;|***             else if (symbol == 17)      /* repeat zero 3..10 times */
;|***                 symbol = 3 + bits(s, 3);
;|***             else                        /* == 18, repeat zero 11..138 times */
;|***                 symbol = 11 + bits(s, 7);
;|***             if (index + symbol > nlen + ndist)
;|***                 return -6;              /* too many lengths! */
;|***             while (symbol--)            /* repeat last or zero symbol times */
;|***                 lengths[index++] = len;
;|***         }
;|***     }
;|*** 
;|***     /* build huffman table for literal/length codes */
;|***     err = construct(&lencode, lengths, nlen);
;|***     if (err < 0 || (err > 0 && nlen - lencode.count[0] != 1))
;|***         return -7;      /* only allow incomplete codes if just one code */
;|*** 
;|***     /* build huffman table for distance codes */
;|***     err = construct(&distcode, lengths + nlen, ndist);
;|***     if (err < 0 || (err > 0 && ndist - distcode.count[0] != 1))
;|***         return -8;      /* only allow incomplete codes if just one code */
;|*** 
;|***     /* decode data until end-of-block code */
;|***     return codes(s, &lencode, &distcode);
;|*** }
; Line 398
					$EX254:
	*** 0001d4	5e 			pop	si
	*** 0001d5	5f 			pop	di
	*** 0001d6	c9 			leave	
	*** 0001d7	c3 			ret	

dynamic	ENDP
	PUBLIC	__acrtused
__acrtused	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** void _acrtused () { }
; Line 401
	*** 000000	c3 			ret	

__acrtused	ENDP
	PUBLIC	_main
_main	PROC FAR	;  COMDAT
;|*** 
;|*** // Decompress deflated data
;|*** int far main (
;|***          unsigned char *dest,         /* pointer to destination pointer */
;|***          unsigned int destlen,        /* amount of output space */
;|***          unsigned char *source)       /* pointer to source data pointer */
;|*** {
; Line 408
	*** 000000	c8 10 00 00 		enter	16,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	dest = 6
;	destlen = 8
;	source = 10
;	s = -16
;	last = -2
;	register di = type
;	register si = err
;|***     struct state s;             /* input/output state */
;|***     int last, type;             /* block information */
;|***     int err;                    /* return value */
;|*** 
;|***     /* initialize output state */
;|***     s.out = dest;
; Line 414
	*** 000006	8b 46 06 		mov	ax,WORD PTR [bp+6]	;dest
	*** 000009	89 46 f0 		mov	WORD PTR [bp-16],ax	;s
;|***     s.outlen = destlen;                /* ignored if dest is NIL */
; Line 415
	*** 00000c	8b 46 08 		mov	ax,WORD PTR [bp+8]	;destlen
	*** 00000f	89 46 f2 		mov	WORD PTR [bp-14],ax
;|***     s.outcnt = 0;
;|*** 
;|***     /* initialize input state */
;|***     s.in = source;
; Line 419
	*** 000012	8b 46 0a 		mov	ax,WORD PTR [bp+10]	;source
	*** 000015	89 46 f6 		mov	WORD PTR [bp-10],ax
;|***     s.incnt = 0;
; Line 420
	*** 000018	33 c0 			xor	ax,ax
	*** 00001a	89 46 f4 		mov	WORD PTR [bp-12],ax
	*** 00001d	89 46 f8 		mov	WORD PTR [bp-8],ax
;|***     s.bitbuf = 0;
;|***     s.bitcnt = 0;
; Line 422
	*** 000020	89 46 fa 		mov	WORD PTR [bp-6],ax
	*** 000023	89 46 fc 		mov	WORD PTR [bp-4],ax
;|*** 
;|*** 	/* process blocks until last block or error */
;|*** 	do {
; Line 425
					$D312:
;|*** 		last = bits(&s, 1);         /* one if last block */
; Line 426
	*** 000026	6a 01 			push	1
	*** 000028	8d 46 f0 		lea	ax,WORD PTR [bp-16]	;s
	*** 00002b	50 			push	ax
	*** 00002c	e8 00 00 		call	bits
	*** 00002f	83 c4 04 		add	sp,4
	*** 000032	89 46 fe 		mov	WORD PTR [bp-2],ax	;last
;|*** 		type = bits(&s, 2);         /* block type 0..3 */
;|*** 		err = type == 0 ? stored(&s) :
;|*** 			(type == 1 ? fixed(&s) :
;|*** 			(type == 2 ? dynamic(&s) :
;|*** 			-1));               /* type == 3, invalid */
; Line 431
	*** 000035	6a 02 			push	2
	*** 000037	8d 46 f0 		lea	ax,WORD PTR [bp-16]	;s
	*** 00003a	50 			push	ax
	*** 00003b	e8 00 00 		call	bits
	*** 00003e	83 c4 04 		add	sp,4
	*** 000041	8b f8 			mov	di,ax
	*** 000043	0b f8 			or	di,ax
	*** 000045	75 0c 			jne	SHORT $L370
	*** 000047	8d 46 f0 		lea	ax,WORD PTR [bp-16]	;s
	*** 00004a	50 			push	ax
	*** 00004b	e8 00 00 		call	stored
					$L396:
	*** 00004e	5b 			pop	bx
	*** 00004f	8b f0 			mov	si,ax
	*** 000051	eb 1f 			jmp	SHORT $L377
					$L370:
	*** 000053	83 ff 01 		cmp	di,1
	*** 000056	75 09 			jne	SHORT $L372
	*** 000058	8d 46 f0 		lea	ax,WORD PTR [bp-16]	;s
	*** 00005b	50 			push	ax
	*** 00005c	e8 00 00 		call	fixed
	*** 00005f	eb ed 			jmp	SHORT $L396
					$L372:
	*** 000061	83 ff 02 		cmp	di,2
	*** 000064	75 09 			jne	SHORT $L374
	*** 000066	8d 46 f0 		lea	ax,WORD PTR [bp-16]	;s
	*** 000069	50 			push	ax
	*** 00006a	e8 00 00 		call	dynamic
	*** 00006d	eb df 			jmp	SHORT $L396
					$L374:
	*** 00006f	be ff ff 		mov	si,-1	;ffffH
					$L377:
;|*** 		if (err != 0) break;        /* return with error */
; Line 432
	*** 000072	0b f6 			or	si,si
	*** 000074	75 05 			jne	SHORT $DB314
;|*** 	} while (!last);
; Line 433
	*** 000076	39 76 fe 		cmp	WORD PTR [bp-2],si	;last
	*** 000079	74 ab 			je	SHORT $D312
					$DB314:
;|*** 
;|*** 	return err;
; Line 435
	*** 00007b	8b c6 			mov	ax,si
;|*** }
; Line 436
	*** 00007d	5e 			pop	si
	*** 00007e	5f 			pop	di
	*** 00007f	c9 			leave	
	*** 000080	cb 			ret	

_main	ENDP
_TEXT	ENDS
END
