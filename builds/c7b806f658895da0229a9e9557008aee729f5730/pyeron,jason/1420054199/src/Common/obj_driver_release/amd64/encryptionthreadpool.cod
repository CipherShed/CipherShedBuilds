; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	ExInitializeFastMutex
EXTRN	__imp_ExAcquireFastMutex:PROC
EXTRN	__imp_ExReleaseFastMutex:PROC
ThreadPoolRunning DD 01H DUP (?)
StopPending DD	01H DUP (?)
PUBLIC	IsEncryptionThreadPoolRunning
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed.build\src\common\encryptionthreadpool.c
;	COMDAT IsEncryptionThreadPoolRunning
_TEXT	SEGMENT
IsEncryptionThreadPoolRunning PROC			; COMDAT

; 506  : 	return ThreadPoolRunning;

  00000	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ThreadPoolRunning

; 507  : }

  00006	c3		 ret	 0
IsEncryptionThreadPoolRunning ENDP
_TEXT	ENDS
PUBLIC	GetEncryptionThreadCount
ThreadCount DD	01H DUP (?)
; Function compile flags: /Ogspy
;	COMDAT GetEncryptionThreadCount
_TEXT	SEGMENT
GetEncryptionThreadCount PROC				; COMDAT

; 494  : 	return ThreadPoolRunning ? ThreadCount : 0;

  00000	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ThreadPoolRunning
  00006	f7 d8		 neg	 eax
  00008	1b c9		 sbb	 ecx, ecx
  0000a	23 0d 00 00 00
	00		 and	 ecx, DWORD PTR ThreadCount
  00010	8b c1		 mov	 eax, ecx

; 495  : }

  00012	c3		 ret	 0
GetEncryptionThreadCount ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT SetWorkItemState
_TEXT	SEGMENT
workItem$ = 8
newState$ = 16
SetWorkItemState PROC					; COMDAT

; 119  : 	InterlockedExchange ((LONG *) &workItem->State, (LONG) newState);

  00000	87 11		 xchg	 DWORD PTR [rcx], edx

; 120  : }

  00002	c3		 ret	 0
SetWorkItemState ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT GetWorkItemState
_TEXT	SEGMENT
workItem$ = 8
GetWorkItemState PROC					; COMDAT

; 113  : 	return InterlockedExchangeAdd ((LONG *) &workItem->State, 0);

  00000	33 c0		 xor	 eax, eax
  00002	f0 0f c1 01	 lock xadd DWORD PTR [rcx], eax

; 114  : }

  00006	c3		 ret	 0
GetWorkItemState ENDP
; Function compile flags: /Ogspy
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT ExInitializeFastMutex
_TEXT	SEGMENT
FastMutex$ = 8
ExInitializeFastMutex PROC				; COMDAT

; 16363: 
; 16364:     FastMutex->Count = FM_LOCK_BIT;
; 16365:     FastMutex->Owner = NULL;

  00000	48 83 61 08 00	 and	 QWORD PTR [rcx+8], 0

; 16366:     FastMutex->Contention = 0;

  00005	83 61 10 00	 and	 DWORD PTR [rcx+16], 0
  00009	ba 01 00 00 00	 mov	 edx, 1
  0000e	89 11		 mov	 DWORD PTR [rcx], edx

; 16367:     KeInitializeEvent(&FastMutex->Event, SynchronizationEvent, FALSE);

  00010	45 33 c0	 xor	 r8d, r8d
  00013	48 83 c1 18	 add	 rcx, 24

; 16368:     return;
; 16369: }

  00017	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_KeInitializeEvent
ExInitializeFastMutex ENDP
PUBLIC	EncryptionThreadPoolBeginKeyDerivation
WorkItemReadyEvent DB 018H DUP (?)
WorkItemCompletedEvent DB 018H DUP (?)
WorkItemQueue DB 03c00H DUP (?)
EnqueuePosition DD 01H DUP (?)
EnqueueMutex DB	038H DUP (?)
;	COMDAT pdata
; File c:\home\public\desktop\projects\ciphershed.build\src\common\encryptionthreadpool.c
pdata	SEGMENT
$pdata$EncryptionThreadPoolBeginKeyDerivation DD imagerel $LN14
	DD	imagerel $LN14+348
	DD	imagerel $unwind$EncryptionThreadPoolBeginKeyDerivation
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptionThreadPoolBeginKeyDerivation DD 0a1901H
	DD	0b7419H
	DD	0a6419H
	DD	095419H
	DD	083419H
	DD	0c0155219H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EncryptionThreadPoolBeginKeyDerivation
_TEXT	SEGMENT
completionEvent$ = 64
noOutstandingWorkItemEvent$ = 72
completionFlag$ = 80
outstandingWorkItemCount$ = 88
pkcs5Prf$ = 96
password$ = 104
passwordLength$ = 112
salt$ = 120
iterationCount$ = 128
derivedKey$ = 136
EncryptionThreadPoolBeginKeyDerivation PROC		; COMDAT

; 350  : {

$LN14:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 08	 mov	 QWORD PTR [r11+8], rbx
  00007	49 89 6b 10	 mov	 QWORD PTR [r11+16], rbp
  0000b	49 89 73 18	 mov	 QWORD PTR [r11+24], rsi
  0000f	49 89 7b 20	 mov	 QWORD PTR [r11+32], rdi
  00013	41 54		 push	 r12
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 351  : 	EncryptionThreadPoolWorkItem *workItem;
; 352  : 
; 353  : 	if (!ThreadPoolRunning)

  00019	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ThreadPoolRunning
  0001f	49 8b f9	 mov	 rdi, r9
  00022	49 8b e8	 mov	 rbp, r8
  00025	48 8b f2	 mov	 rsi, rdx
  00028	4c 8b e1	 mov	 r12, rcx
  0002b	85 c0		 test	 eax, eax
  0002d	75 1d		 jne	 SHORT $LN4@Encryption

; 354  : 		TC_THROW_FATAL_EXCEPTION;

  0002f	8d 48 29	 lea	 ecx, QWORD PTR [rax+41]
  00032	45 33 c9	 xor	 r9d, r9d
  00035	45 33 c0	 xor	 r8d, r8d
  00038	ba 62 01 00 00	 mov	 edx, 354		; 00000162H
  0003d	49 c7 43 e8 43
	54 00 00	 mov	 QWORD PTR [r11-24], 21571 ; 00005443H
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  0004b	cc		 int	 3
$LN4@Encryption:

; 355  : 
; 356  : 	TC_ACQUIRE_MUTEX (&EnqueueMutex);

  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EnqueueMutex
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAcquireFastMutex

; 357  : 
; 358  : 	workItem = &WorkItemQueue[EnqueuePosition++];

  00059	48 63 1d 00 00
	00 00		 movsxd	 rbx, DWORD PTR EnqueuePosition
  00060	ff 05 00 00 00
	00		 inc	 DWORD PTR EnqueuePosition
  00066	48 6b db 78	 imul	 rbx, 120		; 00000078H
  0006a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:WorkItemQueue
  00071	48 03 d8	 add	 rbx, rax

; 359  : 	if (EnqueuePosition >= TC_ENC_THREAD_POOL_QUEUE_SIZE)

  00074	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR EnqueuePosition
  0007a	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0007f	7c 0a		 jl	 SHORT $LN11@Encryption

; 360  : 		EnqueuePosition = 0;

  00081	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR EnqueuePosition, 0
$LN11@Encryption:

; 361  : 
; 362  : 	while (GetWorkItemState (workItem) != WorkItemFree)

  0008b	33 c0		 xor	 eax, eax
  0008d	f0 0f c1 03	 lock xadd DWORD PTR [rbx], eax
  00091	85 c0		 test	 eax, eax
  00093	74 28		 je	 SHORT $LN1@Encryption
$LL2@Encryption:

; 363  : 	{
; 364  : 		TC_WAIT_EVENT (WorkItemCompletedEvent);

  00095	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  0009b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemCompletedEvent
  000a2	45 33 c9	 xor	 r9d, r9d
  000a5	45 33 c0	 xor	 r8d, r8d
  000a8	33 d2		 xor	 edx, edx
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  000b0	45 33 db	 xor	 r11d, r11d

; 361  : 
; 362  : 	while (GetWorkItemState (workItem) != WorkItemFree)

  000b3	f0 44 0f c1 1b	 lock xadd DWORD PTR [rbx], r11d
  000b8	45 85 db	 test	 r11d, r11d
  000bb	75 d8		 jne	 SHORT $LL2@Encryption
$LN1@Encryption:

; 365  : 	}
; 366  : 
; 367  : 	workItem->Type = DeriveKeyWork;
; 368  : 	workItem->KeyDerivation.CompletionEvent = completionEvent;
; 369  : 	workItem->KeyDerivation.CompletionFlag = completionFlag;
; 370  : 	workItem->KeyDerivation.DerivedKey = derivedKey;

  000bd	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR derivedKey$[rsp]
  000c5	c7 43 04 02 00
	00 00		 mov	 DWORD PTR [rbx+4], 2
  000cc	4c 89 63 30	 mov	 QWORD PTR [rbx+48], r12
  000d0	48 89 43 40	 mov	 QWORD PTR [rbx+64], rax

; 371  : 	workItem->KeyDerivation.IterationCount = iterationCount;

  000d4	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR iterationCount$[rsp]
  000db	48 89 6b 38	 mov	 QWORD PTR [rbx+56], rbp
  000df	89 43 48	 mov	 DWORD PTR [rbx+72], eax

; 372  : 	workItem->KeyDerivation.NoOutstandingWorkItemEvent = noOutstandingWorkItemEvent;
; 373  : 	workItem->KeyDerivation.OutstandingWorkItemCount = outstandingWorkItemCount;
; 374  : 	workItem->KeyDerivation.Password = password;

  000e2	48 8b 44 24 68	 mov	 rax, QWORD PTR password$[rsp]
  000e7	48 89 73 50	 mov	 QWORD PTR [rbx+80], rsi
  000eb	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax

; 375  : 	workItem->KeyDerivation.PasswordLength = passwordLength;

  000ef	8b 44 24 70	 mov	 eax, DWORD PTR passwordLength$[rsp]
  000f3	48 89 7b 58	 mov	 QWORD PTR [rbx+88], rdi
  000f7	89 43 68	 mov	 DWORD PTR [rbx+104], eax

; 376  : 	workItem->KeyDerivation.Pkcs5Prf = pkcs5Prf;

  000fa	8b 44 24 60	 mov	 eax, DWORD PTR pkcs5Prf$[rsp]
  000fe	89 43 6c	 mov	 DWORD PTR [rbx+108], eax

; 377  : 	workItem->KeyDerivation.Salt = salt;

  00101	48 8b 44 24 78	 mov	 rax, QWORD PTR salt$[rsp]
  00106	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax

; 378  : 
; 379  : 	InterlockedIncrement (outstandingWorkItemCount);

  0010a	f0 83 07 01	 lock add DWORD PTR [rdi], 1

; 380  : 	TC_CLEAR_EVENT (*noOutstandingWorkItemEvent);

  0010e	48 8b ce	 mov	 rcx, rsi
  00111	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeClearEvent

; 381  : 
; 382  : 	SetWorkItemState (workItem, WorkItemReady);
; 383  : 	TC_SET_EVENT (WorkItemReadyEvent);

  00117	45 33 c0	 xor	 r8d, r8d
  0011a	41 bb 01 00 00
	00		 mov	 r11d, 1
  00120	44 87 1b	 xchg	 DWORD PTR [rbx], r11d
  00123	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  00127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemReadyEvent
  0012e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 384  : 	TC_RELEASE_MUTEX (&EnqueueMutex);

  00134	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EnqueueMutex

; 385  : }

  0013b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00140	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00145	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0014a	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  0014f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00153	41 5c		 pop	 r12
  00155	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_ExReleaseFastMutex
$LN13@Encryption:
EncryptionThreadPoolBeginKeyDerivation ENDP
_TEXT	ENDS
PUBLIC	EncryptionThreadPoolStop
	ALIGN	8

ThreadHandles DQ 040H DUP (?)
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptionThreadPoolStop DD imagerel $LN9
	DD	imagerel $LN9+116
	DD	imagerel $unwind$EncryptionThreadPoolStop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptionThreadPoolStop DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EncryptionThreadPoolStop
_TEXT	SEGMENT
EncryptionThreadPoolStop PROC				; COMDAT

; 311  : {

$LN9:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 312  : 	size_t i;
; 313  : 
; 314  : 	if (!ThreadPoolRunning)

  00006	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ThreadPoolRunning
  0000c	85 c0		 test	 eax, eax
  0000e	74 5e		 je	 SHORT $LN5@Encryption@2

; 315  : 		return;
; 316  : 
; 317  : 	StopPending = TRUE;
; 318  : 	TC_SET_EVENT (WorkItemReadyEvent);

  00010	45 33 c0	 xor	 r8d, r8d
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemReadyEvent
  0001a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR StopPending, 1
  00024	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 319  : 
; 320  : 	for (i = 0; i < ThreadCount; ++i)

  0002e	33 db		 xor	 ebx, ebx
  00030	39 1d 00 00 00
	00		 cmp	 DWORD PTR ThreadCount, ebx
  00036	76 25		 jbe	 SHORT $LN1@Encryption@2
$LL3@Encryption@2:
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ThreadHandles

; 321  : 	{
; 322  : #ifdef DEVICE_DRIVER
; 323  : 		TCStopThread (ThreadHandles[i], &WorkItemReadyEvent);

  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:WorkItemReadyEvent
  00046	48 8b 0c d9	 mov	 rcx, QWORD PTR [rcx+rbx*8]
  0004a	e8 00 00 00 00	 call	 TCStopThread
  0004f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ThreadCount
  00055	48 ff c3	 inc	 rbx
  00058	48 3b d8	 cmp	 rbx, rax
  0005b	72 db		 jb	 SHORT $LL3@Encryption@2
$LN1@Encryption@2:

; 324  : #else
; 325  : 		TC_WAIT_EVENT (ThreadHandles[i]);
; 326  : #endif
; 327  : 	}
; 328  : 
; 329  : 	ThreadCount = 0;

  0005d	83 25 00 00 00
	00 00		 and	 DWORD PTR ThreadCount, 0

; 330  : 
; 331  : #ifndef DEVICE_DRIVER
; 332  : 	CloseHandle (DequeueMutex);
; 333  : 	CloseHandle (EnqueueMutex);
; 334  : 
; 335  : 	CloseHandle (WorkItemReadyEvent);
; 336  : 	CloseHandle (WorkItemCompletedEvent);
; 337  : 
; 338  : 	for (i = 0; i < sizeof (WorkItemQueue) / sizeof (WorkItemQueue[0]); ++i)
; 339  : 	{
; 340  : 		if (WorkItemQueue[i].ItemCompletedEvent)
; 341  : 			CloseHandle (WorkItemQueue[i].ItemCompletedEvent);
; 342  : 	}
; 343  : #endif
; 344  : 
; 345  : 	ThreadPoolRunning = FALSE;

  00064	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ThreadPoolRunning, 0
$LN5@Encryption@2:

; 346  : }

  0006e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00072	5b		 pop	 rbx
  00073	c3		 ret	 0
EncryptionThreadPoolStop ENDP
PUBLIC	EncryptionThreadPoolDoWork
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptionThreadPoolDoWork DD imagerel $LN38
	DD	imagerel $LN38+645
	DD	imagerel $unwind$EncryptionThreadPoolDoWork
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptionThreadPoolDoWork DD 0c1c01H
	DD	010641cH
	DD	0f541cH
	DD	0e341cH
	DD	0f018721cH
	DD	0d014e016H
	DD	07010c012H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EncryptionThreadPoolDoWork
_TEXT	SEGMENT
fragmentStartUnitNo$1$ = 48
type$ = 112
data$ = 120
startUnitNo$ = 128
remainder$1$ = 136
unitCount$ = 136
cryptoInfo$ = 144
EncryptionThreadPoolDoWork PROC				; COMDAT

; 389  : {

$LN38:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 390  : 	uint32 fragmentCount;
; 391  : 	uint32 unitsPerFragment;
; 392  : 	uint32 remainder;
; 393  : 
; 394  : 	byte *fragmentData;
; 395  : 	uint64 fragmentStartUnitNo;
; 396  : 
; 397  : 	EncryptionThreadPoolWorkItem *workItem;
; 398  : 	EncryptionThreadPoolWorkItem *firstFragmentWorkItem;
; 399  : 	
; 400  : 	if (unitCount == 0)

  0001c	33 db		 xor	 ebx, ebx
  0001e	4d 8b d0	 mov	 r10, r8
  00021	4c 8b fa	 mov	 r15, rdx
  00024	8b e9		 mov	 ebp, ecx
  00026	44 3b cb	 cmp	 r9d, ebx
  00029	0f 84 38 02 00
	00		 je	 $LN15@Encryption@3

; 401  : 		return;
; 402  : 	
; 403  : 	if (!ThreadPoolRunning || unitCount == 1)

  0002f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ThreadPoolRunning
  00035	8d 4b 01	 lea	 ecx, QWORD PTR [rbx+1]
  00038	3b c3		 cmp	 eax, ebx
  0003a	0f 84 d2 01 00
	00		 je	 $LN17@Encryption@3
  00040	44 3b c9	 cmp	 r9d, ecx
  00043	0f 84 c9 01 00
	00		 je	 $LN17@Encryption@3

; 417  : 		}
; 418  : 
; 419  : 		return;
; 420  : 	}
; 421  : 
; 422  : 	if (unitCount <= ThreadCount)

  00049	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ThreadCount
  0004f	44 3b ce	 cmp	 r9d, esi
  00052	77 0e		 ja	 SHORT $LN11@Encryption@3

; 423  : 	{
; 424  : 		fragmentCount = unitCount;

  00054	41 8b f1	 mov	 esi, r9d

; 425  : 		unitsPerFragment = 1;

  00057	8b f9		 mov	 edi, ecx

; 426  : 		remainder = 0;

  00059	89 9c 24 88 00
	00 00		 mov	 DWORD PTR remainder$1$[rsp], ebx

; 427  : 	}
; 428  : 	else

  00060	eb 16		 jmp	 SHORT $LN9@Encryption@3
$LN11@Encryption@3:

; 429  : 	{
; 430  : 		/* Note that it is not efficient to divide the data into fragments smaller than a few hundred bytes.
; 431  : 		The reason is that the overhead associated with thread handling would in most cases make a multi-threaded 
; 432  : 		process actually slower than a single-threaded process. */
; 433  : 
; 434  : 		fragmentCount = ThreadCount;
; 435  : 		unitsPerFragment = unitCount / ThreadCount;

  00062	33 d2		 xor	 edx, edx
  00064	41 8b c1	 mov	 eax, r9d
  00067	f7 f6		 div	 esi
  00069	89 94 24 88 00
	00 00		 mov	 DWORD PTR remainder$1$[rsp], edx
  00070	8b f8		 mov	 edi, eax

; 436  : 		remainder = unitCount % ThreadCount;
; 437  : 
; 438  : 		if (remainder > 0)

  00072	3b d3		 cmp	 edx, ebx
  00074	76 02		 jbe	 SHORT $LN9@Encryption@3

; 439  : 			++unitsPerFragment;

  00076	03 f9		 add	 edi, ecx
$LN9@Encryption@3:

; 440  : 	}
; 441  : 	
; 442  : 	fragmentData = data;
; 443  : 	fragmentStartUnitNo = startUnitNo->Value;

  00078	49 8b 00	 mov	 rax, QWORD PTR [r8]

; 444  : 
; 445  : 	TC_ACQUIRE_MUTEX (&EnqueueMutex);

  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EnqueueMutex
  00082	48 89 44 24 30	 mov	 QWORD PTR fragmentStartUnitNo$1$[rsp], rax
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAcquireFastMutex

; 446  : 	firstFragmentWorkItem = &WorkItemQueue[EnqueuePosition];

  0008d	4c 63 2d 00 00
	00 00		 movsxd	 r13, DWORD PTR EnqueuePosition
  00094	4d 6b ed 78	 imul	 r13, 120		; 00000078H
  00098	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemQueue

; 447  : 
; 448  : 	while (GetWorkItemState (firstFragmentWorkItem) != WorkItemFree)

  0009f	8b c3		 mov	 eax, ebx
  000a1	4c 03 e9	 add	 r13, rcx
  000a4	f0 41 0f c1 45
	00		 lock xadd DWORD PTR [r13], eax
  000aa	3b c3		 cmp	 eax, ebx
  000ac	74 2f		 je	 SHORT $LN7@Encryption@3
$LL8@Encryption@3:

; 449  : 	{
; 450  : 		TC_WAIT_EVENT (WorkItemCompletedEvent);

  000ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemCompletedEvent
  000b5	45 33 c9	 xor	 r9d, r9d
  000b8	45 33 c0	 xor	 r8d, r8d
  000bb	33 d2		 xor	 edx, edx
  000bd	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  000c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  000c8	44 8b db	 mov	 r11d, ebx

; 447  : 
; 448  : 	while (GetWorkItemState (firstFragmentWorkItem) != WorkItemFree)

  000cb	f0 45 0f c1 5d
	00		 lock xadd DWORD PTR [r13], r11d
  000d1	44 3b db	 cmp	 r11d, ebx
  000d4	75 d8		 jne	 SHORT $LL8@Encryption@3
  000d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemQueue
$LN7@Encryption@3:

; 451  : 	}
; 452  : 
; 453  : 	firstFragmentWorkItem->OutstandingFragmentCount = fragmentCount;

  000dd	41 89 75 28	 mov	 DWORD PTR [r13+40], esi

; 454  : 
; 455  : 	while (fragmentCount-- > 0)

  000e1	3b f3		 cmp	 esi, ebx
  000e3	0f 86 eb 00 00
	00		 jbe	 $LN35@Encryption@3
  000e9	44 8b f7	 mov	 r14d, edi
  000ec	41 c1 e6 09	 shl	 r14d, 9
$LL6@Encryption@3:

; 456  : 	{
; 457  : 		workItem = &WorkItemQueue[EnqueuePosition++];

  000f0	4c 63 25 00 00
	00 00		 movsxd	 r12, DWORD PTR EnqueuePosition
  000f7	ff 05 00 00 00
	00		 inc	 DWORD PTR EnqueuePosition

; 458  : 		if (EnqueuePosition >= TC_ENC_THREAD_POOL_QUEUE_SIZE)

  000fd	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR EnqueuePosition
  00103	4d 6b e4 78	 imul	 r12, 120		; 00000078H
  00107	4c 03 e1	 add	 r12, rcx
  0010a	ff ce		 dec	 esi
  0010c	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00111	7c 06		 jl	 SHORT $LN32@Encryption@3

; 459  : 			EnqueuePosition = 0;

  00113	89 1d 00 00 00
	00		 mov	 DWORD PTR EnqueuePosition, ebx
$LN32@Encryption@3:

; 460  : 
; 461  : 		while (GetWorkItemState (workItem) != WorkItemFree)

  00119	8b c3		 mov	 eax, ebx
  0011b	f0 41 0f c1 04
	24		 lock xadd DWORD PTR [r12], eax
  00121	3b c3		 cmp	 eax, ebx
  00123	74 28		 je	 SHORT $LN2@Encryption@3
$LL3@Encryption@3:

; 462  : 		{
; 463  : 			TC_WAIT_EVENT (WorkItemCompletedEvent);

  00125	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemCompletedEvent
  0012c	45 33 c9	 xor	 r9d, r9d
  0012f	45 33 c0	 xor	 r8d, r8d
  00132	33 d2		 xor	 edx, edx
  00134	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  0013f	44 8b db	 mov	 r11d, ebx

; 460  : 
; 461  : 		while (GetWorkItemState (workItem) != WorkItemFree)

  00142	f0 45 0f c1 1c
	24		 lock xadd DWORD PTR [r12], r11d
  00148	44 3b db	 cmp	 r11d, ebx
  0014b	75 d8		 jne	 SHORT $LL3@Encryption@3
$LN2@Encryption@3:

; 464  : 		}
; 465  : 
; 466  : 		workItem->Type = type;
; 467  : 		workItem->FirstFragment = firstFragmentWorkItem;
; 468  : 
; 469  : 		workItem->Encryption.CryptoInfo = cryptoInfo;
; 470  : 		workItem->Encryption.Data = fragmentData;
; 471  : 		workItem->Encryption.UnitCount = unitsPerFragment;
; 472  : 		workItem->Encryption.StartUnitNo.Value = fragmentStartUnitNo;

  0014d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR fragmentStartUnitNo$1$[rsp]
  00152	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  0015a	4d 89 7c 24 38	 mov	 QWORD PTR [r12+56], r15
  0015f	49 89 44 24 30	 mov	 QWORD PTR [r12+48], rax

; 473  : 
; 474  :  		fragmentData += unitsPerFragment * ENCRYPTION_DATA_UNIT_SIZE;

  00164	41 8b c6	 mov	 eax, r14d
  00167	49 89 4c 24 40	 mov	 QWORD PTR [r12+64], rcx
  0016c	4c 03 f8	 add	 r15, rax

; 475  : 		fragmentStartUnitNo += unitsPerFragment;

  0016f	8b c7		 mov	 eax, edi
  00171	41 89 6c 24 04	 mov	 DWORD PTR [r12+4], ebp
  00176	48 03 c8	 add	 rcx, rax

; 476  : 
; 477  : 		if (remainder > 0 && --remainder == 0)

  00179	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR remainder$1$[rsp]
  00180	4d 89 6c 24 20	 mov	 QWORD PTR [r12+32], r13
  00185	41 89 7c 24 48	 mov	 DWORD PTR [r12+72], edi
  0018a	48 89 4c 24 30	 mov	 QWORD PTR fragmentStartUnitNo$1$[rsp], rcx
  0018f	3b c3		 cmp	 eax, ebx
  00191	76 15		 jbe	 SHORT $LN1@Encryption@3
  00193	83 c0 ff	 add	 eax, -1			; ffffffffH
  00196	89 84 24 88 00
	00 00		 mov	 DWORD PTR remainder$1$[rsp], eax
  0019d	75 09		 jne	 SHORT $LN1@Encryption@3

; 478  : 			--unitsPerFragment;

  0019f	ff cf		 dec	 edi
  001a1	41 81 c6 00 fe
	ff ff		 add	 r14d, -512		; fffffe00H
$LN1@Encryption@3:

; 479  : 
; 480  : 		SetWorkItemState (workItem, WorkItemReady);
; 481  : 		TC_SET_EVENT (WorkItemReadyEvent);

  001a8	45 33 c0	 xor	 r8d, r8d
  001ab	b8 01 00 00 00	 mov	 eax, 1
  001b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemReadyEvent
  001b7	41 87 04 24	 xchg	 DWORD PTR [r12], eax
  001bb	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  001bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent
  001c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemQueue
  001cc	3b f3		 cmp	 esi, ebx
  001ce	0f 87 1c ff ff
	ff		 ja	 $LL6@Encryption@3
$LN35@Encryption@3:

; 482  : 	}
; 483  : 
; 484  : 	TC_RELEASE_MUTEX (&EnqueueMutex);

  001d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EnqueueMutex
  001db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExReleaseFastMutex

; 485  : 
; 486  : 	TC_WAIT_EVENT (firstFragmentWorkItem->ItemCompletedEvent);

  001e1	49 8d 4d 08	 lea	 rcx, QWORD PTR [r13+8]
  001e5	45 33 c9	 xor	 r9d, r9d
  001e8	45 33 c0	 xor	 r8d, r8d
  001eb	33 d2		 xor	 edx, edx
  001ed	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  001f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 487  : 	SetWorkItemState (firstFragmentWorkItem, WorkItemFree);

  001f8	41 87 5d 00	 xchg	 DWORD PTR [r13], ebx

; 488  : 	TC_SET_EVENT (WorkItemCompletedEvent);

  001fc	45 33 c0	 xor	 r8d, r8d
  001ff	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  00203	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemCompletedEvent
  0020a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent
  00210	eb 55		 jmp	 SHORT $LN15@Encryption@3
$LN17@Encryption@3:

; 404  : 	{
; 405  : 		switch (type)

  00212	3b eb		 cmp	 ebp, ebx
  00214	74 3b		 je	 SHORT $LN13@Encryption@3
  00216	3b e9		 cmp	 ebp, ecx
  00218	74 1f		 je	 SHORT $LN14@Encryption@3

; 413  : 			break;
; 414  : 
; 415  : 		default:
; 416  : 			TC_THROW_FATAL_EXCEPTION;

  0021a	45 33 c9	 xor	 r9d, r9d
  0021d	45 33 c0	 xor	 r8d, r8d
  00220	ba a0 01 00 00	 mov	 edx, 416		; 000001a0H
  00225	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00229	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00232	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00238	cc		 int	 3
$LN14@Encryption@3:

; 406  : 		{
; 407  : 		case DecryptDataUnitsWork:
; 408  : 			DecryptDataUnitsCurrentThread (data, startUnitNo, unitCount, cryptoInfo);

  00239	45 8b c1	 mov	 r8d, r9d
  0023c	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR cryptoInfo$[rsp]
  00244	49 8b d2	 mov	 rdx, r10
  00247	49 8b cf	 mov	 rcx, r15
  0024a	e8 00 00 00 00	 call	 DecryptDataUnitsCurrentThread

; 409  : 			break;

  0024f	eb 16		 jmp	 SHORT $LN15@Encryption@3
$LN13@Encryption@3:

; 410  : 
; 411  : 		case EncryptDataUnitsWork:
; 412  : 			EncryptDataUnitsCurrentThread (data, startUnitNo, unitCount, cryptoInfo);

  00251	45 8b c1	 mov	 r8d, r9d
  00254	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR cryptoInfo$[rsp]
  0025c	49 8b d2	 mov	 rdx, r10
  0025f	49 8b cf	 mov	 rcx, r15
  00262	e8 00 00 00 00	 call	 EncryptDataUnitsCurrentThread
$LN15@Encryption@3:

; 489  : }

  00267	4c 8d 5c 24 40	 lea	 r11, QWORD PTR [rsp+64]
  0026c	49 8b 5b 30	 mov	 rbx, QWORD PTR [r11+48]
  00270	49 8b 6b 38	 mov	 rbp, QWORD PTR [r11+56]
  00274	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  00278	49 8b e3	 mov	 rsp, r11
  0027b	41 5f		 pop	 r15
  0027d	41 5e		 pop	 r14
  0027f	41 5d		 pop	 r13
  00281	41 5c		 pop	 r12
  00283	5f		 pop	 rdi
  00284	c3		 ret	 0
$LN37@Encryption@3:
EncryptionThreadPoolDoWork ENDP
DequeuePosition DD 01H DUP (?)
DequeueMutex DB	038H DUP (?)
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptionThreadProc DD imagerel EncryptionThreadProc
	DD	imagerel EncryptionThreadProc+695
	DD	imagerel $unwind$EncryptionThreadProc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptionThreadProc DD 040a01H
	DD	0a340aH
	DD	07006720aH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EncryptionThreadProc
_TEXT	SEGMENT
threadArg$ = 80
EncryptionThreadProc PROC				; COMDAT

; 124  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 125  : 	EncryptionThreadPoolWorkItem *workItem;
; 126  : 
; 127  : 	while (!StopPending)

  0000a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR StopPending
  00010	85 c0		 test	 eax, eax
  00012	0f 85 4e 02 00
	00		 jne	 $LN39@Encryption@4
  00018	8d 78 01	 lea	 edi, QWORD PTR [rax+1]
$LL22@Encryption@4:

; 128  : 	{
; 129  : 		TC_ACQUIRE_MUTEX (&DequeueMutex);

  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:DequeueMutex
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAcquireFastMutex

; 130  : 
; 131  : 		workItem = &WorkItemQueue[DequeuePosition++];

  00028	48 63 1d 00 00
	00 00		 movsxd	 rbx, DWORD PTR DequeuePosition
  0002f	01 3d 00 00 00
	00		 add	 DWORD PTR DequeuePosition, edi
  00035	48 6b db 78	 imul	 rbx, 120		; 00000078H
  00039	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:WorkItemQueue
  00040	48 03 d8	 add	 rbx, rax

; 132  : 
; 133  : 		if (DequeuePosition >= TC_ENC_THREAD_POOL_QUEUE_SIZE)

  00043	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR DequeuePosition
  00049	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0004e	7c 0a		 jl	 SHORT $LN35@Encryption@4

; 134  : 			DequeuePosition = 0;

  00050	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR DequeuePosition, 0
$LN35@Encryption@4:

; 135  : 
; 136  : 		while (!StopPending && GetWorkItemState (workItem) != WorkItemReady)

  0005a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR StopPending
  00060	85 c0		 test	 eax, eax
  00062	75 31		 jne	 SHORT $LN18@Encryption@4
$LL19@Encryption@4:
  00064	33 c0		 xor	 eax, eax
  00066	f0 0f c1 03	 lock xadd DWORD PTR [rbx], eax
  0006a	3b c7		 cmp	 eax, edi
  0006c	74 27		 je	 SHORT $LN18@Encryption@4

; 137  : 		{
; 138  : 			TC_WAIT_EVENT (WorkItemReadyEvent);

  0006e	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00074	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemReadyEvent
  0007b	45 33 c9	 xor	 r9d, r9d
  0007e	45 33 c0	 xor	 r8d, r8d
  00081	33 d2		 xor	 edx, edx
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  00089	44 8b 1d 00 00
	00 00		 mov	 r11d, DWORD PTR StopPending
  00090	45 85 db	 test	 r11d, r11d
  00093	74 cf		 je	 SHORT $LL19@Encryption@4
$LN18@Encryption@4:

; 139  : 		}
; 140  : 
; 141  : 		SetWorkItemState (workItem, WorkItemBusy);

  00095	b8 02 00 00 00	 mov	 eax, 2

; 142  : 
; 143  : 		TC_RELEASE_MUTEX (&DequeueMutex);

  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:DequeueMutex
  000a1	87 03		 xchg	 DWORD PTR [rbx], eax
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExReleaseFastMutex

; 144  : 
; 145  : 		if (StopPending)

  000a9	44 8b 1d 00 00
	00 00		 mov	 r11d, DWORD PTR StopPending
  000b0	45 85 db	 test	 r11d, r11d
  000b3	0f 85 ad 01 00
	00		 jne	 $LN39@Encryption@4

; 146  : 			break;
; 147  : 
; 148  : 		switch (workItem->Type)

  000b9	8b 4b 04	 mov	 ecx, DWORD PTR [rbx+4]
  000bc	85 c9		 test	 ecx, ecx
  000be	0f 84 45 01 00
	00		 je	 $LN13@Encryption@4
  000c4	2b cf		 sub	 ecx, edi
  000c6	0f 84 26 01 00
	00		 je	 $LN14@Encryption@4
  000cc	3b cf		 cmp	 ecx, edi
  000ce	0f 85 c4 01 00
	00		 jne	 $LN38@Encryption@4

; 156  : 			break;
; 157  : 
; 158  : 		case DeriveKeyWork:
; 159  : 			switch (workItem->KeyDerivation.Pkcs5Prf)

  000d4	8b 4b 6c	 mov	 ecx, DWORD PTR [rbx+108]
  000d7	2b cf		 sub	 ecx, edi
  000d9	0f 84 a6 00 00
	00		 je	 $LN9@Encryption@4
  000df	2b cf		 sub	 ecx, edi
  000e1	74 71		 je	 SHORT $LN8@Encryption@4
  000e3	2b cf		 sub	 ecx, edi
  000e5	74 3c		 je	 SHORT $LN7@Encryption@4
  000e7	3b cf		 cmp	 ecx, edi
  000e9	0f 85 8a 01 00
	00		 jne	 $LN40@Encryption@4

; 175  : 
; 176  : 			case SHA1:
; 177  : 				derive_key_sha1 (workItem->KeyDerivation.Password, workItem->KeyDerivation.PasswordLength, workItem->KeyDerivation.Salt, PKCS5_SALT_SIZE,
; 178  : 					workItem->KeyDerivation.IterationCount, workItem->KeyDerivation.DerivedKey, GetMaxPkcs5OutSize());

  000ef	e8 00 00 00 00	 call	 GetMaxPkcs5OutSize
  000f4	4c 8b 43 70	 mov	 r8, QWORD PTR [rbx+112]
  000f8	8b 53 68	 mov	 edx, DWORD PTR [rbx+104]
  000fb	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  000ff	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00103	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]
  00107	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0010c	8b 43 48	 mov	 eax, DWORD PTR [rbx+72]
  0010f	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  00115	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00119	e8 00 00 00 00	 call	 derive_key_sha1

; 179  : 				break;

  0011e	e9 91 00 00 00	 jmp	 $LN10@Encryption@4
$LN7@Encryption@4:

; 170  : 
; 171  : 			case WHIRLPOOL:
; 172  : 				derive_key_whirlpool (workItem->KeyDerivation.Password, workItem->KeyDerivation.PasswordLength, workItem->KeyDerivation.Salt, PKCS5_SALT_SIZE,
; 173  : 					workItem->KeyDerivation.IterationCount, workItem->KeyDerivation.DerivedKey, GetMaxPkcs5OutSize());

  00123	e8 00 00 00 00	 call	 GetMaxPkcs5OutSize
  00128	4c 8b 43 70	 mov	 r8, QWORD PTR [rbx+112]
  0012c	8b 53 68	 mov	 edx, DWORD PTR [rbx+104]
  0012f	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00133	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00137	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]
  0013b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00140	8b 43 48	 mov	 eax, DWORD PTR [rbx+72]
  00143	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  00149	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0014d	e8 00 00 00 00	 call	 derive_key_whirlpool

; 174  : 				break;

  00152	eb 60		 jmp	 SHORT $LN10@Encryption@4
$LN8@Encryption@4:

; 164  : 				break;
; 165  : 
; 166  : 			case SHA512:
; 167  : 				derive_key_sha512 (workItem->KeyDerivation.Password, workItem->KeyDerivation.PasswordLength, workItem->KeyDerivation.Salt, PKCS5_SALT_SIZE,
; 168  : 					workItem->KeyDerivation.IterationCount, workItem->KeyDerivation.DerivedKey, GetMaxPkcs5OutSize());

  00154	e8 00 00 00 00	 call	 GetMaxPkcs5OutSize
  00159	4c 8b 43 70	 mov	 r8, QWORD PTR [rbx+112]
  0015d	8b 53 68	 mov	 edx, DWORD PTR [rbx+104]
  00160	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00164	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00168	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]
  0016c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00171	8b 43 48	 mov	 eax, DWORD PTR [rbx+72]
  00174	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  0017a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0017e	e8 00 00 00 00	 call	 derive_key_sha512

; 169  : 				break;

  00183	eb 2f		 jmp	 SHORT $LN10@Encryption@4
$LN9@Encryption@4:

; 160  : 			{
; 161  : 			case RIPEMD160:
; 162  : 				derive_key_ripemd160 (workItem->KeyDerivation.Password, workItem->KeyDerivation.PasswordLength, workItem->KeyDerivation.Salt, PKCS5_SALT_SIZE,
; 163  : 					workItem->KeyDerivation.IterationCount, workItem->KeyDerivation.DerivedKey, GetMaxPkcs5OutSize());

  00185	e8 00 00 00 00	 call	 GetMaxPkcs5OutSize
  0018a	4c 8b 43 70	 mov	 r8, QWORD PTR [rbx+112]
  0018e	8b 53 68	 mov	 edx, DWORD PTR [rbx+104]
  00191	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00195	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00199	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]
  0019d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a2	8b 43 48	 mov	 eax, DWORD PTR [rbx+72]
  001a5	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  001ab	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001af	e8 00 00 00 00	 call	 derive_key_ripemd160
$LN10@Encryption@4:

; 183  : 			} 
; 184  : 
; 185  : 			InterlockedExchange (workItem->KeyDerivation.CompletionFlag, TRUE);

  001b4	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  001b8	8b cf		 mov	 ecx, edi

; 186  : 			TC_SET_EVENT (*workItem->KeyDerivation.CompletionEvent);

  001ba	45 33 c0	 xor	 r8d, r8d
  001bd	87 08		 xchg	 DWORD PTR [rax], ecx
  001bf	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  001c3	8b d7		 mov	 edx, edi
  001c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 187  : 			
; 188  : 			if (InterlockedDecrement (workItem->KeyDerivation.OutstandingWorkItemCount) == 0)

  001cb	4c 8b 5b 58	 mov	 r11, QWORD PTR [rbx+88]
  001cf	f0 41 83 03 ff	 lock add DWORD PTR [r11], -1
  001d4	75 0f		 jne	 SHORT $LN4@Encryption@4

; 189  : 				TC_SET_EVENT (*workItem->KeyDerivation.NoOutstandingWorkItemEvent);

  001d6	48 8b 4b 50	 mov	 rcx, QWORD PTR [rbx+80]
  001da	45 33 c0	 xor	 r8d, r8d
  001dd	8b d7		 mov	 edx, edi
  001df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent
$LN4@Encryption@4:

; 190  : 
; 191  : 			SetWorkItemState (workItem, WorkItemFree);

  001e5	33 c0		 xor	 eax, eax

; 192  : 			TC_SET_EVENT (WorkItemCompletedEvent);

  001e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemCompletedEvent
  001ee	87 03		 xchg	 DWORD PTR [rbx], eax

; 193  : 			continue;

  001f0	eb 5b		 jmp	 SHORT $LN43@Encryption@4
$LN14@Encryption@4:

; 149  : 		{
; 150  : 		case DecryptDataUnitsWork:
; 151  : 			DecryptDataUnitsCurrentThread (workItem->Encryption.Data, &workItem->Encryption.StartUnitNo, workItem->Encryption.UnitCount, workItem->Encryption.CryptoInfo);

  001f2	44 8b 43 48	 mov	 r8d, DWORD PTR [rbx+72]
  001f6	4c 8b 4b 30	 mov	 r9, QWORD PTR [rbx+48]
  001fa	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  001fe	48 8d 53 40	 lea	 rdx, QWORD PTR [rbx+64]
  00202	e8 00 00 00 00	 call	 DecryptDataUnitsCurrentThread

; 152  : 			break;

  00207	eb 15		 jmp	 SHORT $LN15@Encryption@4
$LN13@Encryption@4:

; 153  : 
; 154  : 		case EncryptDataUnitsWork:
; 155  : 			EncryptDataUnitsCurrentThread (workItem->Encryption.Data, &workItem->Encryption.StartUnitNo, workItem->Encryption.UnitCount, workItem->Encryption.CryptoInfo);

  00209	44 8b 43 48	 mov	 r8d, DWORD PTR [rbx+72]
  0020d	4c 8b 4b 30	 mov	 r9, QWORD PTR [rbx+48]
  00211	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  00215	48 8d 53 40	 lea	 rdx, QWORD PTR [rbx+64]
  00219	e8 00 00 00 00	 call	 EncryptDataUnitsCurrentThread
$LN15@Encryption@4:

; 197  : 		}
; 198  : 
; 199  : 		if (workItem != workItem->FirstFragment)

  0021e	48 3b 5b 20	 cmp	 rbx, QWORD PTR [rbx+32]
  00222	74 16		 je	 SHORT $LN2@Encryption@4

; 200  : 		{
; 201  : 			SetWorkItemState (workItem, WorkItemFree);

  00224	33 c0		 xor	 eax, eax

; 202  : 			TC_SET_EVENT (WorkItemCompletedEvent);

  00226	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemCompletedEvent
  0022d	45 33 c0	 xor	 r8d, r8d
  00230	87 03		 xchg	 DWORD PTR [rbx], eax
  00232	8b d7		 mov	 edx, edi
  00234	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent
$LN2@Encryption@4:

; 203  : 		}
; 204  : 
; 205  : 		if (InterlockedDecrement (&workItem->FirstFragment->OutstandingFragmentCount) == 0)

  0023a	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  0023e	f0 83 41 28 ff	 lock add DWORD PTR [rcx+40], -1
  00243	75 13		 jne	 SHORT $LN1@Encryption@4

; 206  : 			TC_SET_EVENT (workItem->FirstFragment->ItemCompletedEvent);

  00245	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00249	48 83 c1 08	 add	 rcx, 8
$LN43@Encryption@4:
  0024d	45 33 c0	 xor	 r8d, r8d
  00250	8b d7		 mov	 edx, edi
  00252	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent
$LN1@Encryption@4:
  00258	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR StopPending
  0025e	85 c0		 test	 eax, eax
  00260	0f 84 b5 fd ff
	ff		 je	 $LL22@Encryption@4
$LN39@Encryption@4:

; 207  : 	}
; 208  : 
; 209  : #ifdef DEVICE_DRIVER
; 210  : 	PsTerminateSystemThread (STATUS_SUCCESS);

  00266	33 c9		 xor	 ecx, ecx

; 211  : #else
; 212  : 	_endthreadex (0);
; 213  :     return 0;
; 214  : #endif
; 215  : }

  00268	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0026d	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00271	5f		 pop	 rdi
  00272	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_PsTerminateSystemThread
$LN40@Encryption@4:

; 180  : 
; 181  : 			default:		
; 182  : 				TC_THROW_FATAL_EXCEPTION;

  00279	45 33 c9	 xor	 r9d, r9d
  0027c	45 33 c0	 xor	 r8d, r8d
  0027f	ba b6 00 00 00	 mov	 edx, 182		; 000000b6H
  00284	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00288	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00291	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00297	cc		 int	 3
$LN38@Encryption@4:

; 194  : 
; 195  : 		default:
; 196  : 			TC_THROW_FATAL_EXCEPTION;

  00298	45 33 c9	 xor	 r9d, r9d
  0029b	45 33 c0	 xor	 r8d, r8d
  0029e	ba c4 00 00 00	 mov	 edx, 196		; 000000c4H
  002a3	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  002a7	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  002b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  002b6	cc		 int	 3
$LN42@Encryption@4:
EncryptionThreadProc ENDP
PUBLIC	EncryptionThreadPoolStart
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$EncryptionThreadPoolStart DD imagerel $LN33
	DD	imagerel $LN33+422
	DD	imagerel $unwind$EncryptionThreadPoolStart
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptionThreadPoolStart DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed.build\src\common\encryptionthreadpool.c
xdata	ENDS
;	COMDAT EncryptionThreadPoolStart
_TEXT	SEGMENT
encryptionFreeCpuCount$ = 48
EncryptionThreadPoolStart PROC				; COMDAT

; 219  : {

$LN33:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 220  : 	size_t cpuCount, i;
; 221  : 
; 222  : 	if (ThreadPoolRunning)

  00014	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ThreadPoolRunning
  0001a	48 8b 35 00 00
	00 00		 mov	 rsi, QWORD PTR EncryptionThreadPoolFreeCpuCountLimit
  00021	85 c0		 test	 eax, eax
  00023	74 0a		 je	 SHORT $LN11@Encryption@5

; 223  : 		return TRUE;

  00025	b8 01 00 00 00	 mov	 eax, 1
  0002a	e9 59 01 00 00	 jmp	 $LN12@Encryption@5
$LN11@Encryption@5:

; 224  : 
; 225  : #ifdef DEVICE_DRIVER
; 226  : 	cpuCount = GetCpuCount();

  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeQueryActiveProcessors
  00035	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0003a	33 ff		 xor	 edi, edi
  0003c	8d 5a c1	 lea	 ebx, QWORD PTR [rdx-63]
  0003f	48 8b ca	 mov	 rcx, rdx
$LL17@Encryption@5:
  00042	48 2b cb	 sub	 rcx, rbx
  00045	84 c3		 test	 al, bl
  00047	74 03		 je	 SHORT $LN15@Encryption@5
  00049	48 03 fb	 add	 rdi, rbx
$LN15@Encryption@5:
  0004c	48 d1 e8	 shr	 rax, 1
  0004f	48 85 c9	 test	 rcx, rcx
  00052	75 ee		 jne	 SHORT $LL17@Encryption@5
  00054	48 85 ff	 test	 rdi, rdi
  00057	48 0f 44 fb	 cmove	 rdi, rbx

; 227  : #else
; 228  : 	{
; 229  : 		SYSTEM_INFO sysInfo;
; 230  : 		GetSystemInfo (&sysInfo);
; 231  : 		cpuCount = sysInfo.dwNumberOfProcessors;
; 232  : 	}
; 233  : #endif
; 234  : 
; 235  : 	if (cpuCount > encryptionFreeCpuCount)

  0005b	48 3b fe	 cmp	 rdi, rsi
  0005e	76 03		 jbe	 SHORT $LN10@Encryption@5

; 236  : 		cpuCount -= encryptionFreeCpuCount;

  00060	48 2b fe	 sub	 rdi, rsi
$LN10@Encryption@5:

; 237  : 
; 238  : 	if (cpuCount < 2)

  00063	48 83 ff 02	 cmp	 rdi, 2

; 239  : 		return TRUE;

  00067	0f 82 19 01 00
	00		 jb	 $LN32@Encryption@5

; 240  : 
; 241  : 	if (cpuCount > TC_ENC_THREAD_POOL_MAX_THREAD_COUNT)

  0006d	48 3b fa	 cmp	 rdi, rdx

; 242  : 		cpuCount = TC_ENC_THREAD_POOL_MAX_THREAD_COUNT;
; 243  : 
; 244  : 	StopPending = FALSE;

  00070	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR StopPending, 0

; 245  : 	DequeuePosition = 0;

  0007a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR DequeuePosition, 0
  00084	48 0f 47 fa	 cmova	 rdi, rdx

; 246  : 	EnqueuePosition = 0;

  00088	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR EnqueuePosition, 0

; 247  : 
; 248  : #ifdef DEVICE_DRIVER
; 249  : 	KeInitializeEvent (&WorkItemReadyEvent, SynchronizationEvent, FALSE);

  00092	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemReadyEvent
  00099	45 33 c0	 xor	 r8d, r8d
  0009c	8b d3		 mov	 edx, ebx
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 250  : 	KeInitializeEvent (&WorkItemCompletedEvent, SynchronizationEvent, FALSE);

  000a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemCompletedEvent
  000ab	45 33 c0	 xor	 r8d, r8d
  000ae	8b d3		 mov	 edx, ebx
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 251  : #else
; 252  : 	WorkItemReadyEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
; 253  : 	if (!WorkItemReadyEvent)
; 254  : 		return FALSE;
; 255  : 	
; 256  : 	WorkItemCompletedEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
; 257  : 	if (!WorkItemCompletedEvent)
; 258  : 		return FALSE;
; 259  : #endif
; 260  : 	
; 261  : #ifdef DEVICE_DRIVER
; 262  : 	ExInitializeFastMutex (&DequeueMutex);

  000b6	48 83 25 08 00
	00 00 00	 and	 QWORD PTR DequeueMutex+8, 0
  000be	83 25 10 00 00
	00 00		 and	 DWORD PTR DequeueMutex+16, 0
  000c5	89 1d 00 00 00
	00		 mov	 DWORD PTR DequeueMutex, ebx
  000cb	48 8d 0d 18 00
	00 00		 lea	 rcx, OFFSET FLAT:DequeueMutex+24
  000d2	45 33 c0	 xor	 r8d, r8d
  000d5	8b d3		 mov	 edx, ebx
  000d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 263  : 	ExInitializeFastMutex (&EnqueueMutex);

  000dd	48 83 25 08 00
	00 00 00	 and	 QWORD PTR EnqueueMutex+8, 0
  000e5	83 25 10 00 00
	00 00		 and	 DWORD PTR EnqueueMutex+16, 0
  000ec	48 8d 0d 18 00
	00 00		 lea	 rcx, OFFSET FLAT:EnqueueMutex+24
  000f3	45 33 c0	 xor	 r8d, r8d
  000f6	8b d3		 mov	 edx, ebx
  000f8	89 1d 00 00 00
	00		 mov	 DWORD PTR EnqueueMutex, ebx
  000fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 264  : #else
; 265  : 	DequeueMutex = CreateMutex (NULL, FALSE, NULL);
; 266  : 	if (!DequeueMutex)
; 267  : 		return FALSE;
; 268  : 
; 269  : 	EnqueueMutex = CreateMutex (NULL, FALSE, NULL);
; 270  : 	if (!EnqueueMutex)
; 271  : 		return FALSE;
; 272  : #endif
; 273  : 
; 274  : 	memset (WorkItemQueue, 0, sizeof (WorkItemQueue));

  00104	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemQueue
  0010b	33 d2		 xor	 edx, edx
  0010d	41 b8 00 3c 00
	00		 mov	 r8d, 15360		; 00003c00H
  00113	e8 00 00 00 00	 call	 memset
  00118	48 8d 35 08 00
	00 00		 lea	 rsi, OFFSET FLAT:WorkItemQueue+8
  0011f	bd 80 00 00 00	 mov	 ebp, 128		; 00000080H
$LL7@Encryption@5:

; 275  : 
; 276  : 	for (i = 0; i < sizeof (WorkItemQueue) / sizeof (WorkItemQueue[0]); ++i)
; 277  : 	{
; 278  : 		WorkItemQueue[i].State = WorkItemFree;

  00124	83 66 f8 00	 and	 DWORD PTR [rsi-8], 0

; 279  : 
; 280  : #ifdef DEVICE_DRIVER
; 281  : 		KeInitializeEvent (&WorkItemQueue[i].ItemCompletedEvent, SynchronizationEvent, FALSE);

  00128	45 33 c0	 xor	 r8d, r8d
  0012b	8b d3		 mov	 edx, ebx
  0012d	48 8b ce	 mov	 rcx, rsi
  00130	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent
  00136	48 83 c6 78	 add	 rsi, 120		; 00000078H
  0013a	48 2b eb	 sub	 rbp, rbx
  0013d	75 e5		 jne	 SHORT $LL7@Encryption@5

; 282  : #else
; 283  : 		WorkItemQueue[i].ItemCompletedEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
; 284  : 		if (!WorkItemQueue[i].ItemCompletedEvent)
; 285  : 		{
; 286  : 			EncryptionThreadPoolStop();
; 287  : 			return FALSE;
; 288  : 		}
; 289  : #endif
; 290  : 	}
; 291  : 
; 292  : 	for (ThreadCount = 0; ThreadCount < cpuCount; ++ThreadCount)

  0013f	33 c9		 xor	 ecx, ecx
  00141	89 0d 00 00 00
	00		 mov	 DWORD PTR ThreadCount, ecx
  00147	48 85 ff	 test	 rdi, rdi
  0014a	74 34		 je	 SHORT $LN2@Encryption@5
$LL4@Encryption@5:

; 293  : 	{
; 294  : #ifdef DEVICE_DRIVER
; 295  : 		if (!NT_SUCCESS (TCStartThread (EncryptionThreadProc, NULL, &ThreadHandles[ThreadCount])))

  0014c	8b c1		 mov	 eax, ecx
  0014e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ThreadHandles
  00155	33 d2		 xor	 edx, edx
  00157	4c 8d 04 c1	 lea	 r8, QWORD PTR [rcx+rax*8]
  0015b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionThreadProc
  00162	e8 00 00 00 00	 call	 TCStartThread
  00167	85 c0		 test	 eax, eax
  00169	78 32		 js	 SHORT $LN27@Encryption@5
  0016b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ThreadCount
  00171	03 cb		 add	 ecx, ebx
  00173	8b c1		 mov	 eax, ecx
  00175	89 0d 00 00 00
	00		 mov	 DWORD PTR ThreadCount, ecx
  0017b	48 3b c7	 cmp	 rax, rdi
  0017e	72 cc		 jb	 SHORT $LL4@Encryption@5
$LN2@Encryption@5:

; 302  : 		}
; 303  : 	}
; 304  : 
; 305  : 	ThreadPoolRunning = TRUE;

  00180	89 1d 00 00 00
	00		 mov	 DWORD PTR ThreadPoolRunning, ebx
$LN32@Encryption@5:

; 306  : 	return TRUE;

  00186	8b c3		 mov	 eax, ebx
$LN12@Encryption@5:

; 307  : }

  00188	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0018d	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00192	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00197	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0019b	5f		 pop	 rdi
  0019c	c3		 ret	 0
$LN27@Encryption@5:

; 296  : #else
; 297  : 		if (!(ThreadHandles[ThreadCount] = (HANDLE) _beginthreadex (NULL, 0, EncryptionThreadProc, NULL, 0, NULL)))
; 298  : #endif
; 299  : 		{
; 300  : 			EncryptionThreadPoolStop();

  0019d	e8 00 00 00 00	 call	 EncryptionThreadPoolStop

; 301  : 			return FALSE;

  001a2	33 c0		 xor	 eax, eax
  001a4	eb e2		 jmp	 SHORT $LN12@Encryption@5
EncryptionThreadPoolStart ENDP
END
