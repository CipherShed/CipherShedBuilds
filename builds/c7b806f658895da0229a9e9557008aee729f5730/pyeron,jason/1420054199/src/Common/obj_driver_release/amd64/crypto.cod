; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_05HJMENKNE@SHA?91?$AA@			; `string'
PUBLIC	??_C@_09HLDHDDJL@Whirlpool?$AA@			; `string'
PUBLIC	??_C@_07MEOJAOJE@SHA?9512?$AA@			; `string'
PUBLIC	??_C@_0L@PKFJAMAA@RIPEMD?9160?$AA@		; `string'
PUBLIC	??_C@_0L@NEGMAKNF@Triple?5DES?$AA@		; `string'
PUBLIC	??_C@_05LCFOLDPB@CAST5?$AA@			; `string'
PUBLIC	??_C@_08KOMAHJJD@Blowfish?$AA@			; `string'
PUBLIC	??_C@_07DABDIDEC@Twofish?$AA@			; `string'
PUBLIC	??_C@_07CCCAKGBN@Serpent?$AA@			; `string'
PUBLIC	??_C@_03BKNEFOAH@AES?$AA@			; `string'
PUBLIC	??_C@_01OGPIMHDM@?$DP?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_01JOAMLHOP@?9?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_03CKCBIPFF@XTS?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_03JFLLPGCL@LRW?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0L@NEGMAKNF@Triple?5DES?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_09GGDEEENC@Outer?9CBC?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_09CJGJEHAC@outer?9CBC?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_03PPFAJCFI@CBC?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_09KIMEMFNK@Inner?9CBC?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_09OHJJMGAK@inner?9CBC?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_09DJENBFJK@?$FLunknown?$FN?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
EXTRN	aes_encrypt:PROC
EXTRN	aes_hw_cpu_encrypt:PROC
EXTRN	aes_hw_cpu_encrypt_32_blocks:PROC
EXTRN	aes_decrypt:PROC
EXTRN	aes_hw_cpu_decrypt:PROC
EXTRN	aes_hw_cpu_decrypt_32_blocks:PROC
EXTRN	is_aes_hw_cpu_supported:PROC
HwEncryptionDisabled DD 01H DUP (?)
?state@?1??IsAesHwCpuSupported@@9@9 DD 01H DUP (?)	; `IsAesHwCpuSupported'::`2'::state
?stateValid@?1??IsAesHwCpuSupported@@9@9 DD 01H DUP (?)	; `IsAesHwCpuSupported'::`2'::stateValid
;	COMDAT ??_C@_09DJENBFJK@?$FLunknown?$FN?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09DJENBFJK@?$FLunknown?$FN?$AA@FNODOBFM@ DB '[unknown]', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_09OHJJMGAK@inner?9CBC?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09OHJJMGAK@inner?9CBC?$AA@FNODOBFM@ DB 'inner-CBC', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_09KIMEMFNK@Inner?9CBC?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09KIMEMFNK@Inner?9CBC?$AA@FNODOBFM@ DB 'Inner-CBC', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_03PPFAJCFI@CBC?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_03PPFAJCFI@CBC?$AA@FNODOBFM@ DB 'CBC', 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_09CJGJEHAC@outer?9CBC?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09CJGJEHAC@outer?9CBC?$AA@FNODOBFM@ DB 'outer-CBC', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_09GGDEEENC@Outer?9CBC?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09GGDEEENC@Outer?9CBC?$AA@FNODOBFM@ DB 'Outer-CBC', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0L@NEGMAKNF@Triple?5DES?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0L@NEGMAKNF@Triple?5DES?$AA@FNODOBFM@ DB 'Triple DES', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_03JFLLPGCL@LRW?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_03JFLLPGCL@LRW?$AA@FNODOBFM@ DB 'LRW', 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_03CKCBIPFF@XTS?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_03CKCBIPFF@XTS?$AA@FNODOBFM@ DB 'XTS', 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_01JOAMLHOP@?9?$AA@FNODOBFM@ DB '-', 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_01OGPIMHDM@?$DP?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_01OGPIMHDM@?$DP?$AA@FNODOBFM@ DB '?', 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_05HJMENKNE@SHA?91?$AA@
CONST	SEGMENT
??_C@_05HJMENKNE@SHA?91?$AA@ DB 'SHA-1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HLDHDDJL@Whirlpool?$AA@
CONST	SEGMENT
??_C@_09HLDHDDJL@Whirlpool?$AA@ DB 'Whirlpool', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07MEOJAOJE@SHA?9512?$AA@
CONST	SEGMENT
??_C@_07MEOJAOJE@SHA?9512?$AA@ DB 'SHA-512', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PKFJAMAA@RIPEMD?9160?$AA@
CONST	SEGMENT
??_C@_0L@PKFJAMAA@RIPEMD?9160?$AA@ DB 'RIPEMD-160', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NEGMAKNF@Triple?5DES?$AA@
CONST	SEGMENT
??_C@_0L@NEGMAKNF@Triple?5DES?$AA@ DB 'Triple DES', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05LCFOLDPB@CAST5?$AA@
CONST	SEGMENT
??_C@_05LCFOLDPB@CAST5?$AA@ DB 'CAST5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KOMAHJJD@Blowfish?$AA@
CONST	SEGMENT
??_C@_08KOMAHJJD@Blowfish?$AA@ DB 'Blowfish', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07DABDIDEC@Twofish?$AA@
CONST	SEGMENT
??_C@_07DABDIDEC@Twofish?$AA@ DB 'Twofish', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CCCAKGBN@Serpent?$AA@
CONST	SEGMENT
??_C@_07CCCAKGBN@Serpent?$AA@ DB 'Serpent', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BKNEFOAH@AES?$AA@
CONST	SEGMENT
??_C@_03BKNEFOAH@AES?$AA@ DB 'AES', 00H			; `string'
Ciphers	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_03BKNEFOAH@AES?$AA@
	DD	010H
	DD	020H
	DD	01e8H
	ORG $+4
	DD	02H
	ORG $+4
	DQ	FLAT:??_C@_07CCCAKGBN@Serpent?$AA@
	DD	010H
	DD	020H
	DD	0230H
	ORG $+4
	DD	03H
	ORG $+4
	DQ	FLAT:??_C@_07DABDIDEC@Twofish?$AA@
	DD	010H
	DD	020H
	DD	010b4H
	ORG $+4
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_08KOMAHJJD@Blowfish?$AA@
	DD	08H
	DD	038H
	DD	01090H
	ORG $+4
	DD	05H
	ORG $+4
	DQ	FLAT:??_C@_05LCFOLDPB@CAST5?$AA@
	DD	08H
	DD	010H
	DD	080H
	ORG $+4
	DD	06H
	ORG $+4
	DQ	FLAT:??_C@_0L@NEGMAKNF@Triple?5DES?$AA@
	DD	08H
	DD	018H
	DD	0300H
	ORG $+4
	DD	00H
	ORG $+4
	DQ	0000000000000000H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
EncryptionAlgorithms DD 00H
	DD	00H
	ORG $+8
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+8
	DD	00H
	DD	01H
	DD	00H
	ORG $+8
	DD	01H
	DD	02H
	DD	03H
	DD	00H
	ORG $+8
	DD	01H
	DD	02H
	DD	00H
	ORG $+8
	DD	01H
	DD	02H
	DD	03H
	DD	00H
	ORG $+8
	DD	01H
	DD	03H
	DD	00H
	ORG $+8
	DD	01H
	DD	02H
	DD	03H
	DD	00H
	ORG $+8
	DD	01H
	DD	03H
	DD	01H
	DD	00H
	ORG $+4
	DD	01H
	DD	02H
	DD	04H
	DD	00H
	ORG $+8
	DD	01H
	DD	02H
	DD	03H
	DD	01H
	DD	00H
	DD	01H
	DD	02H
	DD	04H
	DD	00H
	ORG $+8
	DD	01H
	DD	01H
	DD	02H
	DD	00H
	ORG $+4
	DD	01H
	DD	02H
	DD	04H
	DD	00H
	ORG $+8
	DD	01H
	DD	01H
	DD	03H
	DD	02H
	DD	00H
	DD	01H
	DD	02H
	DD	04H
	DD	00H
	ORG $+8
	DD	01H
	DD	02H
	DD	03H
	DD	00H
	ORG $+4
	DD	01H
	DD	02H
	DD	04H
	DD	00H
	ORG $+8
	DD	01H
	DD	04H
	DD	00H
	ORG $+8
	DD	02H
	DD	03H
	DD	00H
	DD	00H
	ORG $+8
	DD	00H
	DD	05H
	DD	00H
	ORG $+8
	DD	02H
	DD	03H
	DD	00H
	DD	00H
	ORG $+8
	DD	00H
	DD	06H
	DD	00H
	ORG $+8
	DD	02H
	DD	03H
	DD	00H
	DD	00H
	ORG $+8
	DD	00H
	DD	04H
	DD	01H
	DD	00H
	ORG $+4
	DD	05H
	DD	00H
	DD	00H
	DD	00H
	ORG $+8
	DD	00H
	DD	02H
	DD	04H
	DD	01H
	DD	00H
	DD	05H
	DD	00H
	DD	00H
	DD	00H
	ORG $+8
	DD	00H
	DD	00H
	DD	00H
	ORG $+8
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+8
	DD	00H
	ORG $+12
Hashes	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0L@PKFJAMAA@RIPEMD?9160?$AA@
	DD	00H
	DD	01H
	DD	02H
	ORG $+4
	DQ	FLAT:??_C@_07MEOJAOJE@SHA?9512?$AA@
	DD	00H
	DD	00H
	DD	03H
	ORG $+4
	DQ	FLAT:??_C@_09HLDHDDJL@Whirlpool?$AA@
	DD	00H
	DD	00H
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_05HJMENKNE@SHA?91?$AA@
	DD	01H
	DD	00H
	DD	00H
	ORG $+4
	DQ	0000000000000000H
	DD	00H
	ORG $+4
PUBLIC	IsHwEncryptionEnabled
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed.build\src\common\crypto.c
;	COMDAT IsHwEncryptionEnabled
_TEXT	SEGMENT
IsHwEncryptionEnabled PROC				; COMDAT

; 1868 : 	return !HwEncryptionDisabled;

  00000	33 c0		 xor	 eax, eax
  00002	39 05 00 00 00
	00		 cmp	 DWORD PTR HwEncryptionDisabled, eax
  00008	0f 94 c0	 sete	 al

; 1869 : }

  0000b	c3		 ret	 0
IsHwEncryptionEnabled ENDP
_TEXT	ENDS
PUBLIC	EnableHwEncryption
; Function compile flags: /Ogspy
;	COMDAT EnableHwEncryption
_TEXT	SEGMENT
enable$ = 8
EnableHwEncryption PROC					; COMDAT

; 1858 : #if defined (TC_WINDOWS_BOOT)
; 1859 : 	if (enable)
; 1860 : 		aes_hw_cpu_enable_sse();
; 1861 : #endif
; 1862 : 
; 1863 : 	HwEncryptionDisabled = !enable;

  00000	33 c0		 xor	 eax, eax
  00002	3b c8		 cmp	 ecx, eax
  00004	0f 94 c0	 sete	 al
  00007	89 05 00 00 00
	00		 mov	 DWORD PTR HwEncryptionDisabled, eax

; 1864 : }

  0000d	c3		 ret	 0
EnableHwEncryption ENDP
_TEXT	ENDS
PUBLIC	IsAesHwCpuSupported
;	COMDAT pdata
pdata	SEGMENT
$pdata$IsAesHwCpuSupported DD imagerel $LN7
	DD	imagerel $LN7+75
	DD	imagerel $unwind$IsAesHwCpuSupported
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IsAesHwCpuSupported DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT IsAesHwCpuSupported
_TEXT	SEGMENT
IsAesHwCpuSupported PROC				; COMDAT

; 1843 : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1844 : 	static BOOL state = FALSE;
; 1845 : 	static BOOL stateValid = FALSE;
; 1846 : 
; 1847 : 	if (!stateValid)

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?stateValid@?1??IsAesHwCpuSupported@@9@9, 0
  0000d	bb 01 00 00 00	 mov	 ebx, 1
  00012	75 1a		 jne	 SHORT $LN6@IsAesHwCpu

; 1848 : 	{
; 1849 : 		state = is_aes_hw_cpu_supported() ? TRUE : FALSE;

  00014	e8 00 00 00 00	 call	 is_aes_hw_cpu_supported
  00019	33 c9		 xor	 ecx, ecx

; 1850 : 		stateValid = TRUE;

  0001b	89 1d 00 00 00
	00		 mov	 DWORD PTR ?stateValid@?1??IsAesHwCpuSupported@@9@9, ebx
  00021	84 c0		 test	 al, al
  00023	0f 95 c1	 setne	 cl
  00026	89 0d 00 00 00
	00		 mov	 DWORD PTR ?state@?1??IsAesHwCpuSupported@@9@9, ecx
  0002c	eb 06		 jmp	 SHORT $LN1@IsAesHwCpu
$LN6@IsAesHwCpu:
  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?state@?1??IsAesHwCpuSupported@@9@9
$LN1@IsAesHwCpu:

; 1851 : 	}
; 1852 : 
; 1853 : 	return state && !HwEncryptionDisabled;

  00034	85 c9		 test	 ecx, ecx
  00036	74 09		 je	 SHORT $LN4@IsAesHwCpu
  00038	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR HwEncryptionDisabled, 0
  0003f	74 02		 je	 SHORT $LN5@IsAesHwCpu
$LN4@IsAesHwCpu:
  00041	33 db		 xor	 ebx, ebx
$LN5@IsAesHwCpu:
  00043	8b c3		 mov	 eax, ebx

; 1854 : }

  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5b		 pop	 rbx
  0004a	c3		 ret	 0
IsAesHwCpuSupported ENDP
_TEXT	ENDS
PUBLIC	DataUnit2LRWIndex
;	COMDAT pdata
pdata	SEGMENT
$pdata$DataUnit2LRWIndex DD imagerel $LN12
	DD	imagerel $LN12+96
	DD	imagerel $unwind$DataUnit2LRWIndex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DataUnit2LRWIndex DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT DataUnit2LRWIndex
_TEXT	SEGMENT
dataUnit$ = 64
blockSize$ = 72
ci$ = 80
DataUnit2LRWIndex PROC					; COMDAT

; 1342 : {

$LN12:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1343 : 	/* Deprecated/legacy */
; 1344 : 
; 1345 : 	if (ci->hiddenVolume)

  00004	41 83 b8 a0 29
	00 00 00	 cmp	 DWORD PTR [r8+10656], 0
  0000c	74 10		 je	 SHORT $LN7@DataUnit2L

; 1346 : 		dataUnit -= ci->hiddenVolumeOffset / ENCRYPTION_DATA_UNIT_SIZE;

  0000e	49 8b 80 18 44
	00 00		 mov	 rax, QWORD PTR [r8+17432]
  00015	48 c1 e8 09	 shr	 rax, 9
  00019	48 2b c8	 sub	 rcx, rax

; 1347 : 	else

  0001c	eb 03		 jmp	 SHORT $LN6@DataUnit2L
$LN7@DataUnit2L:

; 1348 : 		dataUnit -= TC_VOLUME_HEADER_SIZE_LEGACY / ENCRYPTION_DATA_UNIT_SIZE;	// Compensate for the volume header size

  0001e	48 ff c9	 dec	 rcx
$LN6@DataUnit2L:

; 1349 : 
; 1350 : 	switch (blockSize)

  00021	83 fa 08	 cmp	 edx, 8
  00024	74 2a		 je	 SHORT $LN3@DataUnit2L
  00026	83 fa 10	 cmp	 edx, 16
  00029	74 1f		 je	 SHORT $LN2@DataUnit2L

; 1357 : 
; 1358 : 	default:
; 1359 : 		TC_THROW_FATAL_EXCEPTION;

  0002b	45 33 c9	 xor	 r9d, r9d
  0002e	45 33 c0	 xor	 r8d, r8d
  00031	ba 4f 05 00 00	 mov	 edx, 1359		; 0000054fH
  00036	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  0003a	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00049	cc		 int	 3
$LN2@DataUnit2L:

; 1354 : 
; 1355 : 	case 16:
; 1356 : 		return (dataUnit << 5) | 1;

  0004a	48 c1 e1 05	 shl	 rcx, 5
  0004e	eb 04		 jmp	 SHORT $LN11@DataUnit2L
$LN3@DataUnit2L:

; 1351 : 	{
; 1352 : 	case 8:
; 1353 : 		return (dataUnit << 6) | 1;

  00050	48 c1 e1 06	 shl	 rcx, 6
$LN11@DataUnit2L:
  00054	48 83 c9 01	 or	 rcx, 1
  00058	48 8b c1	 mov	 rax, rcx

; 1360 : 	}
; 1361 : 
; 1362 : 	return 0;
; 1363 : }

  0005b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005f	c3		 ret	 0
$LN10@DataUnit2L:
DataUnit2LRWIndex ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$InitSectorIVAndWhitening DD imagerel InitSectorIVAndWhitening
	DD	imagerel InitSectorIVAndWhitening+249
	DD	imagerel $unwind$InitSectorIVAndWhitening
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$InitSectorIVAndWhitening DD 020601H
	DD	030029206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT InitSectorIVAndWhitening
_TEXT	SEGMENT
iv64$ = 48
unitNo$ = 96
blockSize$ = 104
iv$ = 112
ivSeed$ = 120
whitening$ = 128
InitSectorIVAndWhitening PROC				; COMDAT

; 1010 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 1011 : 
; 1012 : 	/* IMPORTANT: This function has been deprecated (legacy) */
; 1013 : 
; 1014 : 	unsigned __int64 iv64[4];
; 1015 : 	unsigned __int32 *iv32 = (unsigned __int32 *) iv64;
; 1016 : 
; 1017 : 	iv64[0] = ivSeed[0] ^ LE64(unitNo);

  00006	4d 8b 11	 mov	 r10, QWORD PTR [r9]

; 1018 : 	iv64[1] = ivSeed[1] ^ LE64(unitNo);

  00009	4d 8b 59 08	 mov	 r11, QWORD PTR [r9+8]

; 1019 : 	iv64[2] = ivSeed[2] ^ LE64(unitNo);

  0000d	49 8b 41 10	 mov	 rax, QWORD PTR [r9+16]
  00011	4c 33 d1	 xor	 r10, rcx
  00014	4c 33 d9	 xor	 r11, rcx
  00017	48 33 c1	 xor	 rax, rcx
  0001a	4c 89 54 24 30	 mov	 QWORD PTR iv64$[rsp], r10
  0001f	4c 89 5c 24 38	 mov	 QWORD PTR iv64$[rsp+8], r11
  00024	48 89 44 24 40	 mov	 QWORD PTR iv64$[rsp+16], rax

; 1020 : 	if (blockSize == 16)

  00029	83 fa 10	 cmp	 edx, 16
  0002c	75 0c		 jne	 SHORT $LN6@InitSector

; 1021 : 	{
; 1022 : 		iv64[3] = ivSeed[3] ^ LE64(unitNo);

  0002e	49 8b 41 18	 mov	 rax, QWORD PTR [r9+24]
  00032	48 33 c1	 xor	 rax, rcx
  00035	48 89 44 24 48	 mov	 QWORD PTR iv64$[rsp+24], rax
$LN6@InitSector:

; 1023 : 	}
; 1024 : 
; 1025 : 	iv[0] = iv32[0];
; 1026 : 	iv[1] = iv32[1];

  0003a	8b 44 24 34	 mov	 eax, DWORD PTR iv64$[rsp+4]
  0003e	45 89 10	 mov	 DWORD PTR [r8], r10d
  00041	41 89 40 04	 mov	 DWORD PTR [r8+4], eax

; 1027 : 
; 1028 : 	switch (blockSize)

  00045	83 fa 08	 cmp	 edx, 8
  00048	74 66		 je	 SHORT $LN2@InitSector
  0004a	83 fa 10	 cmp	 edx, 16
  0004d	74 1f		 je	 SHORT $LN3@InitSector

; 1047 : 		break;
; 1048 : 
; 1049 : 	default:
; 1050 : 		TC_THROW_FATAL_EXCEPTION;

  0004f	45 33 c9	 xor	 r9d, r9d
  00052	45 33 c0	 xor	 r8d, r8d
  00055	ba 1a 04 00 00	 mov	 edx, 1050		; 0000041aH
  0005a	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  0005e	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  0006d	cc		 int	 3
$LN3@InitSector:

; 1029 : 	{
; 1030 : 	case 16:
; 1031 : 
; 1032 : 		// 128-bit block
; 1033 : 
; 1034 : 		iv[2] = iv32[2];
; 1035 : 		iv[3] = iv32[3];

  0006e	8b 44 24 3c	 mov	 eax, DWORD PTR iv64$[rsp+12]

; 1036 : 
; 1037 : 		whitening[0] = LE32( crc32int ( &iv32[4] ) ^ crc32int ( &iv32[7] ) );

  00072	48 8d 4c 24 40	 lea	 rcx, QWORD PTR iv64$[rsp+16]
  00077	45 89 58 08	 mov	 DWORD PTR [r8+8], r11d
  0007b	41 89 40 0c	 mov	 DWORD PTR [r8+12], eax
  0007f	e8 00 00 00 00	 call	 crc32int
  00084	48 8d 4c 24 4c	 lea	 rcx, QWORD PTR iv64$[rsp+28]
  00089	44 8b d8	 mov	 r11d, eax
  0008c	e8 00 00 00 00	 call	 crc32int
  00091	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR whitening$[rsp]
  00099	44 33 d8	 xor	 r11d, eax

; 1038 : 		whitening[1] = LE32( crc32int ( &iv32[5] ) ^ crc32int ( &iv32[6] ) );

  0009c	48 8d 4c 24 44	 lea	 rcx, QWORD PTR iv64$[rsp+20]
  000a1	44 89 1b	 mov	 DWORD PTR [rbx], r11d
  000a4	e8 00 00 00 00	 call	 crc32int
  000a9	48 8d 4c 24 48	 lea	 rcx, QWORD PTR iv64$[rsp+24]

; 1039 : 		break;

  000ae	eb 34		 jmp	 SHORT $LN10@InitSector
$LN2@InitSector:

; 1040 : 
; 1041 : 	case 8:
; 1042 : 
; 1043 : 		// 64-bit block
; 1044 : 
; 1045 : 		whitening[0] = LE32( crc32int ( &iv32[2] ) ^ crc32int ( &iv32[5] ) );

  000b0	48 8d 4c 24 44	 lea	 rcx, QWORD PTR iv64$[rsp+20]
  000b5	e8 00 00 00 00	 call	 crc32int
  000ba	48 8d 4c 24 38	 lea	 rcx, QWORD PTR iv64$[rsp+8]
  000bf	44 8b d8	 mov	 r11d, eax
  000c2	e8 00 00 00 00	 call	 crc32int
  000c7	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR whitening$[rsp]
  000cf	44 33 d8	 xor	 r11d, eax

; 1046 : 		whitening[1] = LE32( crc32int ( &iv32[3] ) ^ crc32int ( &iv32[4] ) );

  000d2	48 8d 4c 24 40	 lea	 rcx, QWORD PTR iv64$[rsp+16]
  000d7	44 89 1b	 mov	 DWORD PTR [rbx], r11d
  000da	e8 00 00 00 00	 call	 crc32int
  000df	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR iv64$[rsp+12]
$LN10@InitSector:
  000e4	44 8b d8	 mov	 r11d, eax
  000e7	e8 00 00 00 00	 call	 crc32int
  000ec	44 33 d8	 xor	 r11d, eax
  000ef	44 89 5b 04	 mov	 DWORD PTR [rbx+4], r11d

; 1051 : 	}
; 1052 : }

  000f3	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000f7	5b		 pop	 rbx
  000f8	c3		 ret	 0
$LN9@InitSector:
InitSectorIVAndWhitening ENDP
_TEXT	ENDS
PUBLIC	Xor64
; Function compile flags: /Ogspy
;	COMDAT Xor64
_TEXT	SEGMENT
a$ = 8
b$ = 16
Xor64	PROC						; COMDAT

; 812  : 	*a ^= *b;

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	48 31 01	 xor	 QWORD PTR [rcx], rax

; 813  : }

  00006	c3		 ret	 0
Xor64	ENDP
_TEXT	ENDS
PUBLIC	Xor128
; Function compile flags: /Ogspy
;	COMDAT Xor128
_TEXT	SEGMENT
a$ = 8
b$ = 16
Xor128	PROC						; COMDAT

; 805  : 	*a++ ^= *b++;

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	48 31 01	 xor	 QWORD PTR [rcx], rax

; 806  : 	*a ^= *b;

  00006	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0000a	48 31 41 08	 xor	 QWORD PTR [rcx+8], rax

; 807  : }

  0000e	c3		 ret	 0
Xor128	ENDP
_TEXT	ENDS
PUBLIC	crypto_open
;	COMDAT pdata
pdata	SEGMENT
$pdata$crypto_open DD imagerel $LN4
	DD	imagerel $LN4+61
	DD	imagerel $unwind$crypto_open
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$crypto_open DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT crypto_open
_TEXT	SEGMENT
crypto_open PROC					; COMDAT

; 741  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 742  : #ifndef TC_WINDOWS_BOOT
; 743  : 
; 744  : 	/* Do the crt allocation */
; 745  : 	PCRYPTO_INFO cryptoInfo = (PCRYPTO_INFO) TCalloc (sizeof (CRYPTO_INFO));

  00006	ba 68 44 00 00	 mov	 edx, 17512		; 00004468H
  0000b	33 c9		 xor	 ecx, ecx
  0000d	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00019	48 8b d8	 mov	 rbx, rax

; 746  : 	if (cryptoInfo == NULL)

  0001c	48 85 c0	 test	 rax, rax
  0001f	74 16		 je	 SHORT $LN2@crypto_ope
$LN1@crypto_ope:

; 747  : 		return NULL;
; 748  : 
; 749  : 	memset (cryptoInfo, 0, sizeof (CRYPTO_INFO));

  00021	33 d2		 xor	 edx, edx
  00023	41 b8 68 44 00
	00		 mov	 r8d, 17512		; 00004468H
  00029	48 8b c8	 mov	 rcx, rax
  0002c	e8 00 00 00 00	 call	 memset

; 750  : 
; 751  : #ifndef DEVICE_DRIVER
; 752  : 	VirtualLock (cryptoInfo, sizeof (CRYPTO_INFO));
; 753  : #endif
; 754  : 
; 755  : 	cryptoInfo->ea = -1;

  00031	83 0b ff	 or	 DWORD PTR [rbx], -1

; 756  : 	return cryptoInfo;

  00034	48 8b c3	 mov	 rax, rbx
$LN2@crypto_ope:

; 757  : 
; 758  : #else // TC_WINDOWS_BOOT
; 759  : 
; 760  : #if 0
; 761  : 	if (CryptoInfoBufferInUse)
; 762  : 		TC_THROW_FATAL_EXCEPTION;
; 763  : #endif
; 764  : 	CryptoInfoBufferInUse = 1;
; 765  : 	return &CryptoInfoBuffer;
; 766  : 
; 767  : #endif // TC_WINDOWS_BOOT
; 768  : }

  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5b		 pop	 rbx
  0003c	c3		 ret	 0
crypto_open ENDP
_TEXT	ENDS
PUBLIC	EAGetPreviousCipher
; Function compile flags: /Ogspy
;	COMDAT EAGetPreviousCipher
_TEXT	SEGMENT
ea$ = 8
previousCipherId$ = 16
EAGetPreviousCipher PROC				; COMDAT

; 661  : 	int c, i = 0;
; 662  : 
; 663  : 	if (EncryptionAlgorithms[ea].Ciphers[i++] == previousCipherId)

  00000	48 63 c1	 movsxd	 rax, ecx
  00003	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:EncryptionAlgorithms
  0000a	41 b8 01 00 00
	00		 mov	 r8d, 1
  00010	4c 8b c8	 mov	 r9, rax
  00013	4d 6b c9 0b	 imul	 r9, 11
  00017	43 39 14 8b	 cmp	 DWORD PTR [r11+r9*4], edx

; 664  : 		return 0;

  0001b	74 28		 je	 SHORT $LN9@EAGetPrevi

; 665  : 
; 666  : 	while (c = EncryptionAlgorithms[ea].Ciphers[i++])

  0001d	43 8b 4c 8b 04	 mov	 ecx, DWORD PTR [r11+r9*4+4]
  00022	85 c9		 test	 ecx, ecx
  00024	74 1f		 je	 SHORT $LN9@EAGetPrevi
  00026	48 6b c0 2c	 imul	 rax, 44			; 0000002cH
  0002a	4c 8d 15 04 00
	00 00		 lea	 r10, OFFSET FLAT:EncryptionAlgorithms+4
  00031	49 03 c2	 add	 rax, r10
$LL3@EAGetPrevi:
  00034	41 ff c0	 inc	 r8d
  00037	48 83 c0 04	 add	 rax, 4

; 667  : 	{
; 668  : 		if (c == previousCipherId) 

  0003b	3b ca		 cmp	 ecx, edx
  0003d	74 09		 je	 SHORT $LN8@EAGetPrevi
  0003f	8b 08		 mov	 ecx, DWORD PTR [rax]
  00041	85 c9		 test	 ecx, ecx
  00043	75 ef		 jne	 SHORT $LL3@EAGetPrevi
$LN9@EAGetPrevi:

; 670  : 	}
; 671  : 
; 672  : 	return 0;

  00045	33 c0		 xor	 eax, eax

; 673  : }

  00047	c3		 ret	 0
$LN8@EAGetPrevi:

; 669  : 			return EncryptionAlgorithms[ea].Ciphers[i - 2];

  00048	49 63 c0	 movsxd	 rax, r8d
  0004b	49 03 c1	 add	 rax, r9
  0004e	41 8b 44 83 f8	 mov	 eax, DWORD PTR [r11+rax*4-8]

; 673  : }

  00053	c3		 ret	 0
EAGetPreviousCipher ENDP
_TEXT	ENDS
PUBLIC	EAGetNextCipher
; Function compile flags: /Ogspy
;	COMDAT EAGetNextCipher
_TEXT	SEGMENT
ea$ = 8
previousCipherId$ = 16
EAGetNextCipher PROC					; COMDAT

; 648  : 	int c, i = 0;
; 649  : 	while (c = EncryptionAlgorithms[ea].Ciphers[i++])

  00000	48 63 c1	 movsxd	 rax, ecx
  00003	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:EncryptionAlgorithms
  0000a	45 33 c0	 xor	 r8d, r8d
  0000d	4c 8b c8	 mov	 r9, rax
  00010	4d 6b c9 0b	 imul	 r9, 11
  00014	43 8b 0c 8a	 mov	 ecx, DWORD PTR [r10+r9*4]
  00018	85 c9		 test	 ecx, ecx
  0001a	74 18		 je	 SHORT $LN8@EAGetNextC
  0001c	48 6b c0 2c	 imul	 rax, 44			; 0000002cH
  00020	49 03 c2	 add	 rax, r10
$LL3@EAGetNextC:
  00023	41 ff c0	 inc	 r8d
  00026	48 83 c0 04	 add	 rax, 4

; 650  : 	{
; 651  : 		if (c == previousCipherId) 

  0002a	3b ca		 cmp	 ecx, edx
  0002c	74 09		 je	 SHORT $LN7@EAGetNextC
  0002e	8b 08		 mov	 ecx, DWORD PTR [rax]
  00030	85 c9		 test	 ecx, ecx
  00032	75 ef		 jne	 SHORT $LL3@EAGetNextC
$LN8@EAGetNextC:

; 653  : 	}
; 654  : 
; 655  : 	return 0;

  00034	33 c0		 xor	 eax, eax

; 656  : }

  00036	c3		 ret	 0
$LN7@EAGetNextC:

; 652  : 			return EncryptionAlgorithms[ea].Ciphers[i];

  00037	49 63 c0	 movsxd	 rax, r8d
  0003a	49 03 c1	 add	 rax, r9
  0003d	41 8b 04 82	 mov	 eax, DWORD PTR [r10+rax*4]

; 656  : }

  00041	c3		 ret	 0
EAGetNextCipher ENDP
_TEXT	ENDS
PUBLIC	EAGetLastCipher
; Function compile flags: /Ogspy
;	COMDAT EAGetLastCipher
_TEXT	SEGMENT
ea$ = 8
EAGetLastCipher PROC					; COMDAT

; 639  : 	int c, i = 0;

  00000	48 63 c1	 movsxd	 rax, ecx
  00003	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:EncryptionAlgorithms
  0000a	45 33 c0	 xor	 r8d, r8d
  0000d	48 8b d0	 mov	 rdx, rax
  00010	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  00014	49 03 d1	 add	 rdx, r9
$LL2@EAGetLastC:

; 640  : 	while (c = EncryptionAlgorithms[ea].Ciphers[i++]);

  00017	8b 0a		 mov	 ecx, DWORD PTR [rdx]
  00019	41 ff c0	 inc	 r8d
  0001c	48 83 c2 04	 add	 rdx, 4
  00020	85 c9		 test	 ecx, ecx
  00022	75 f3		 jne	 SHORT $LL2@EAGetLastC

; 641  : 
; 642  : 	return EncryptionAlgorithms[ea].Ciphers[i - 2];

  00024	48 6b c0 0b	 imul	 rax, 11
  00028	49 63 c8	 movsxd	 rcx, r8d
  0002b	48 03 c1	 add	 rax, rcx
  0002e	41 8b 44 81 f8	 mov	 eax, DWORD PTR [r9+rax*4-8]

; 643  : }

  00033	c3		 ret	 0
EAGetLastCipher ENDP
_TEXT	ENDS
PUBLIC	EAGetFirstCipher
; Function compile flags: /Ogspy
;	COMDAT EAGetFirstCipher
_TEXT	SEGMENT
ea$ = 8
EAGetFirstCipher PROC					; COMDAT

; 633  : 	return EncryptionAlgorithms[ea].Ciphers[0];

  00000	48 63 c1	 movsxd	 rax, ecx
  00003	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  0000a	48 6b c0 2c	 imul	 rax, 44			; 0000002cH
  0000e	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]

; 634  : }

  00011	c3		 ret	 0
EAGetFirstCipher ENDP
_TEXT	ENDS
PUBLIC	EAGetCipherCount
; Function compile flags: /Ogspy
;	COMDAT EAGetCipherCount
_TEXT	SEGMENT
ea$ = 8
EAGetCipherCount PROC					; COMDAT

; 624  : 	int i = 0;

  00000	48 63 d1	 movsxd	 rdx, ecx
  00003	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:EncryptionAlgorithms
  0000a	45 33 c0	 xor	 r8d, r8d
  0000d	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  00011	48 03 d0	 add	 rdx, rax
$LL2@EAGetCiphe:

; 625  : 	while (EncryptionAlgorithms[ea].Ciphers[i++]);

  00014	8b 02		 mov	 eax, DWORD PTR [rdx]
  00016	41 ff c0	 inc	 r8d
  00019	48 83 c2 04	 add	 rdx, 4
  0001d	85 c0		 test	 eax, eax
  0001f	75 f3		 jne	 SHORT $LL2@EAGetCiphe

; 626  : 
; 627  : 	return i - 1;

  00021	41 8d 40 ff	 lea	 eax, DWORD PTR [r8-1]

; 628  : }

  00025	c3		 ret	 0
EAGetCipherCount ENDP
_TEXT	ENDS
PUBLIC	EAGetNextMode
; Function compile flags: /Ogspy
;	COMDAT EAGetNextMode
_TEXT	SEGMENT
ea$ = 8
previousModeId$ = 16
EAGetNextMode PROC					; COMDAT

; 514  : 	int c, i = 0;
; 515  : 	while (c = EncryptionAlgorithms[ea].Modes[i++])

  00000	48 63 c1	 movsxd	 rax, ecx
  00003	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:EncryptionAlgorithms
  0000a	45 33 c0	 xor	 r8d, r8d
  0000d	4c 8b c8	 mov	 r9, rax
  00010	4d 6b c9 0b	 imul	 r9, 11
  00014	43 8b 4c 8b 10	 mov	 ecx, DWORD PTR [r11+r9*4+16]
  00019	85 c9		 test	 ecx, ecx
  0001b	74 1f		 je	 SHORT $LN8@EAGetNextM
  0001d	48 6b c0 2c	 imul	 rax, 44			; 0000002cH
  00021	4c 8d 15 10 00
	00 00		 lea	 r10, OFFSET FLAT:EncryptionAlgorithms+16
  00028	49 03 c2	 add	 rax, r10
$LL3@EAGetNextM:
  0002b	41 ff c0	 inc	 r8d
  0002e	48 83 c0 04	 add	 rax, 4

; 516  : 	{
; 517  : 		if (c == previousModeId) 

  00032	3b ca		 cmp	 ecx, edx
  00034	74 09		 je	 SHORT $LN7@EAGetNextM
  00036	8b 08		 mov	 ecx, DWORD PTR [rax]
  00038	85 c9		 test	 ecx, ecx
  0003a	75 ef		 jne	 SHORT $LL3@EAGetNextM
$LN8@EAGetNextM:

; 519  : 	}
; 520  : 
; 521  : 	return 0;

  0003c	33 c0		 xor	 eax, eax

; 522  : }

  0003e	c3		 ret	 0
$LN7@EAGetNextM:

; 518  : 			return EncryptionAlgorithms[ea].Modes[i];

  0003f	49 63 c0	 movsxd	 rax, r8d
  00042	49 03 c1	 add	 rax, r9
  00045	41 8b 44 83 10	 mov	 eax, DWORD PTR [r11+rax*4+16]

; 522  : }

  0004a	c3		 ret	 0
EAGetNextMode ENDP
_TEXT	ENDS
PUBLIC	EAGetFirstMode
; Function compile flags: /Ogspy
;	COMDAT EAGetFirstMode
_TEXT	SEGMENT
ea$ = 8
EAGetFirstMode PROC					; COMDAT

; 508  : 	return (EncryptionAlgorithms[ea].Modes[0]);

  00000	48 63 c1	 movsxd	 rax, ecx
  00003	48 8d 0d 10 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms+16
  0000a	48 6b c0 2c	 imul	 rax, 44			; 0000002cH
  0000e	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]

; 509  : }

  00011	c3		 ret	 0
EAGetFirstMode ENDP
_TEXT	ENDS
PUBLIC	EAGetNext
; Function compile flags: /Ogspy
;	COMDAT EAGetNext
_TEXT	SEGMENT
previousEA$ = 8
EAGetNext PROC						; COMDAT

; 375  : 	int id = previousEA + 1;

  00000	ff c1		 inc	 ecx

; 376  : 	if (EncryptionAlgorithms[id].Ciphers[0] != 0) return id;

  00002	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:EncryptionAlgorithms
  00009	48 63 c1	 movsxd	 rax, ecx
  0000c	48 6b c0 2c	 imul	 rax, 44			; 0000002cH
  00010	8b 04 10	 mov	 eax, DWORD PTR [rax+rdx]
  00013	f7 d8		 neg	 eax
  00015	1b c0		 sbb	 eax, eax
  00017	23 c1		 and	 eax, ecx

; 377  : 	return 0;
; 378  : }

  00019	c3		 ret	 0
EAGetNext ENDP
_TEXT	ENDS
PUBLIC	EAGetFirst
; Function compile flags: /Ogspy
;	COMDAT EAGetFirst
_TEXT	SEGMENT
EAGetFirst PROC						; COMDAT

; 358  : 	return 1;

  00000	b8 01 00 00 00	 mov	 eax, 1

; 359  : }

  00005	c3		 ret	 0
EAGetFirst ENDP
_TEXT	ENDS
PUBLIC	CipherSupportsIntraDataUnitParallelization
;	COMDAT pdata
pdata	SEGMENT
$pdata$CipherSupportsIntraDataUnitParallelization DD imagerel $LN5
	DD	imagerel $LN5+34
	DD	imagerel $unwind$CipherSupportsIntraDataUnitParallelization
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CipherSupportsIntraDataUnitParallelization DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT CipherSupportsIntraDataUnitParallelization
_TEXT	SEGMENT
cipher$ = 48
CipherSupportsIntraDataUnitParallelization PROC		; COMDAT

; 347  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 348  : 	return cipher == AES && IsAesHwCpuSupported();

  00006	bb 01 00 00 00	 mov	 ebx, 1
  0000b	3b cb		 cmp	 ecx, ebx
  0000d	75 09		 jne	 SHORT $LN3@CipherSupp
  0000f	e8 00 00 00 00	 call	 IsAesHwCpuSupported
  00014	85 c0		 test	 eax, eax
  00016	75 02		 jne	 SHORT $LN4@CipherSupp
$LN3@CipherSupp:
  00018	33 db		 xor	 ebx, ebx
$LN4@CipherSupp:
  0001a	8b c3		 mov	 eax, ebx

; 349  : }

  0001c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00020	5b		 pop	 rbx
  00021	c3		 ret	 0
CipherSupportsIntraDataUnitParallelization ENDP
_TEXT	ENDS
PUBLIC	CipherGet
; Function compile flags: /Ogspy
;	COMDAT CipherGet
_TEXT	SEGMENT
id$ = 8
CipherGet PROC						; COMDAT

; 316  : 	int i;
; 317  : 	for (i = 0; Ciphers[i].Id != 0; i++)

  00000	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR Ciphers
  00006	33 d2		 xor	 edx, edx
  00008	45 33 c0	 xor	 r8d, r8d
  0000b	85 c0		 test	 eax, eax
  0000d	74 1f		 je	 SHORT $LN2@CipherGet
  0000f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:Ciphers
$LL4@CipherGet:

; 318  : 		if (Ciphers[i].Id == id)

  00016	3b c1		 cmp	 eax, ecx
  00018	74 17		 je	 SHORT $LN8@CipherGet
  0001a	49 ff c0	 inc	 r8
  0001d	ff c2		 inc	 edx
  0001f	49 8b c0	 mov	 rax, r8
  00022	48 c1 e0 05	 shl	 rax, 5
  00026	42 8b 04 08	 mov	 eax, DWORD PTR [rax+r9]
  0002a	85 c0		 test	 eax, eax
  0002c	75 e8		 jne	 SHORT $LL4@CipherGet
$LN2@CipherGet:

; 320  : 
; 321  : 	return NULL;

  0002e	33 c0		 xor	 eax, eax

; 322  : }

  00030	c3		 ret	 0
$LN8@CipherGet:

; 319  : 			return &Ciphers[i];

  00031	48 63 c2	 movsxd	 rax, edx
  00034	48 c1 e0 05	 shl	 rax, 5
  00038	49 03 c1	 add	 rax, r9

; 322  : }

  0003b	c3		 ret	 0
CipherGet ENDP
PUBLIC	crypto_close
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$crypto_close DD imagerel $LN15
	DD	imagerel $LN15+62
	DD	imagerel $unwind$crypto_close
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$crypto_close DD 020a01H
	DD	07006320aH
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed.build\src\common\crypto.c
xdata	ENDS
;	COMDAT crypto_close
_TEXT	SEGMENT
cryptoInfo$ = 48
crypto_close PROC					; COMDAT

; 778  : {

$LN15:

; 779  : #ifndef TC_WINDOWS_BOOT
; 780  : 
; 781  : 	if (cryptoInfo != NULL)

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 38		 je	 SHORT $LN14@crypto_clo
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 778  : {

  0000a	4c 8b c1	 mov	 r8, rcx

; 782  : 	{
; 783  : 		burn (cryptoInfo, sizeof (CRYPTO_INFO));

  0000d	4c 8b c9	 mov	 r9, rcx
  00010	48 8b f9	 mov	 rdi, rcx
  00013	ba 68 44 00 00	 mov	 edx, 17512		; 00004468H
  00018	33 c0		 xor	 eax, eax
  0001a	48 8b ca	 mov	 rcx, rdx
  0001d	f3 aa		 rep stosb
$LL2@crypto_clo:
  0001f	41 88 01	 mov	 BYTE PTR [r9], al
  00022	49 ff c1	 inc	 r9
  00025	83 ea 01	 sub	 edx, 1
  00028	75 f5		 jne	 SHORT $LL2@crypto_clo

; 784  : #ifndef DEVICE_DRIVER
; 785  : 		VirtualUnlock (cryptoInfo, sizeof (CRYPTO_INFO));
; 786  : #endif
; 787  : 		TCfree (cryptoInfo);

  0002a	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  0002f	49 8b c8	 mov	 rcx, r8
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 788  : 	}
; 789  : 
; 790  : #else // TC_WINDOWS_BOOT
; 791  : 
; 792  : 	burn (&CryptoInfoBuffer, sizeof (CryptoInfoBuffer));
; 793  : 	CryptoInfoBufferInUse = FALSE;
; 794  : 
; 795  : #endif // TC_WINDOWS_BOOT
; 796  : }

  00038	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003c	5f		 pop	 rdi
$LN14@crypto_clo:
  0003d	c3		 ret	 0
crypto_close ENDP
_TEXT	ENDS
PUBLIC	crypto_loadkey
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$crypto_loadkey DD imagerel $LN13
	DD	imagerel $LN13+61
	DD	imagerel $unwind$crypto_loadkey
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$crypto_loadkey DD 020601H
	DD	070023206H
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed.build\src\common\crypto.c
xdata	ENDS
;	COMDAT crypto_loadkey
_TEXT	SEGMENT
keyInfo$ = 48
lpszUserKey$ = 56
nUserKeyLen$ = 64
crypto_loadkey PROC					; COMDAT

; 771  : {

$LN13:
  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 772  : 	keyInfo->keyLength = nUserKeyLen;
; 773  : 	burn (keyInfo->userKey, sizeof (keyInfo->userKey));

  00006	4c 8d 59 08	 lea	 r11, QWORD PTR [rcx+8]
  0000a	44 89 41 04	 mov	 DWORD PTR [rcx+4], r8d
  0000e	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  00014	49 8b fb	 mov	 rdi, r11
  00017	33 c0		 xor	 eax, eax
  00019	49 8b c9	 mov	 rcx, r9
  0001c	f3 aa		 rep stosb
  0001e	4d 8b d3	 mov	 r10, r11
$LL2@crypto_loa:
  00021	41 88 02	 mov	 BYTE PTR [r10], al
  00024	49 ff c2	 inc	 r10
  00027	41 83 e9 01	 sub	 r9d, 1
  0002b	75 f4		 jne	 SHORT $LL2@crypto_loa

; 774  : 	memcpy (keyInfo->userKey, lpszUserKey, nUserKeyLen);

  0002d	4d 63 c0	 movsxd	 r8, r8d
  00030	49 8b cb	 mov	 rcx, r11

; 775  : }

  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5f		 pop	 rdi
  00038	e9 00 00 00 00	 jmp	 memcpy
crypto_loadkey ENDP
_TEXT	ENDS
PUBLIC	EAIsModeSupported
;	COMDAT pdata
pdata	SEGMENT
$pdata$EAIsModeSupported DD imagerel $LN21
	DD	imagerel $LN21+118
	DD	imagerel $unwind$EAIsModeSupported
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EAIsModeSupported DD 040a01H
	DD	02740aH
	DD	013405H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EAIsModeSupported
_TEXT	SEGMENT
ea$ = 8
testedMode$ = 16
EAIsModeSupported PROC					; COMDAT

; 684  : {

$LN21:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 7c 24 10	 mov	 QWORD PTR [rsp+16], rdi

; 685  : 	int mode;
; 686  : 
; 687  : 	for (mode = EAGetFirstMode (ea); mode != 0; mode = EAGetNextMode (ea, mode))

  0000a	48 63 d9	 movsxd	 rbx, ecx
  0000d	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:EncryptionAlgorithms
  00014	44 8b d2	 mov	 r10d, edx
  00017	48 8b c3	 mov	 rax, rbx
  0001a	48 6b c0 2c	 imul	 rax, 44			; 0000002cH
  0001e	4c 8d 5c 38 10	 lea	 r11, QWORD PTR [rax+rdi+16]
  00023	41 8b 03	 mov	 eax, DWORD PTR [r11]
  00026	eb 2e		 jmp	 SHORT $LN20@EAIsModeSu
$LL12@EAIsModeSu:

; 688  : 	{
; 689  : 		if (mode == testedMode)

  00028	41 3b c2	 cmp	 eax, r10d
  0002b	74 42		 je	 SHORT $LN17@EAIsModeSu
  0002d	4c 8b cb	 mov	 r9, rbx
  00030	45 33 c0	 xor	 r8d, r8d
  00033	4d 6b c9 0b	 imul	 r9, 11
  00037	42 8b 54 8f 10	 mov	 edx, DWORD PTR [rdi+r9*4+16]
  0003c	85 d2		 test	 edx, edx
  0003e	74 14		 je	 SHORT $LN18@EAIsModeSu

; 685  : 	int mode;
; 686  : 
; 687  : 	for (mode = EAGetFirstMode (ea); mode != 0; mode = EAGetNextMode (ea, mode))

  00040	49 8b cb	 mov	 rcx, r11
$LL11@EAIsModeSu:
  00043	49 ff c0	 inc	 r8
  00046	48 83 c1 04	 add	 rcx, 4
  0004a	3b d0		 cmp	 edx, eax
  0004c	74 17		 je	 SHORT $LN16@EAIsModeSu
  0004e	8b 11		 mov	 edx, DWORD PTR [rcx]
  00050	85 d2		 test	 edx, edx
  00052	75 ef		 jne	 SHORT $LL11@EAIsModeSu
$LN18@EAIsModeSu:
  00054	33 c0		 xor	 eax, eax
$LN20@EAIsModeSu:
  00056	85 c0		 test	 eax, eax
  00058	75 ce		 jne	 SHORT $LL12@EAIsModeSu
$LN5@EAIsModeSu:

; 691  : 	}
; 692  : 	return FALSE;
; 693  : }

  0005a	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0005f	48 8b 7c 24 10	 mov	 rdi, QWORD PTR [rsp+16]
  00064	c3		 ret	 0
$LN16@EAIsModeSu:
  00065	4b 8d 04 01	 lea	 rax, QWORD PTR [r9+r8]
  00069	8b 44 87 10	 mov	 eax, DWORD PTR [rdi+rax*4+16]
  0006d	eb e7		 jmp	 SHORT $LN20@EAIsModeSu
$LN17@EAIsModeSu:

; 690  : 			return TRUE;

  0006f	b8 01 00 00 00	 mov	 eax, 1
  00074	eb e4		 jmp	 SHORT $LN5@EAIsModeSu
EAIsModeSupported ENDP
_TEXT	ENDS
PUBLIC	CipherGetKeyScheduleSize
;	COMDAT pdata
pdata	SEGMENT
$pdata$CipherGetKeyScheduleSize DD imagerel $LN3
	DD	imagerel $LN3+17
	DD	imagerel $unwind$CipherGetKeyScheduleSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CipherGetKeyScheduleSize DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT CipherGetKeyScheduleSize
_TEXT	SEGMENT
cipherId$ = 48
CipherGetKeyScheduleSize PROC				; COMDAT

; 340  : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 341  : 	return CipherGet (cipherId) -> KeyScheduleSize;

  00004	e8 00 00 00 00	 call	 CipherGet
  00009	8b 40 18	 mov	 eax, DWORD PTR [rax+24]

; 342  : }

  0000c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00010	c3		 ret	 0
CipherGetKeyScheduleSize ENDP
_TEXT	ENDS
PUBLIC	CipherGetKeySize
;	COMDAT pdata
pdata	SEGMENT
$pdata$CipherGetKeySize DD imagerel $LN3
	DD	imagerel $LN3+17
	DD	imagerel $unwind$CipherGetKeySize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CipherGetKeySize DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT CipherGetKeySize
_TEXT	SEGMENT
cipherId$ = 48
CipherGetKeySize PROC					; COMDAT

; 335  : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 336  : 	return CipherGet (cipherId) -> KeySize;

  00004	e8 00 00 00 00	 call	 CipherGet
  00009	8b 40 14	 mov	 eax, DWORD PTR [rax+20]

; 337  : }

  0000c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00010	c3		 ret	 0
CipherGetKeySize ENDP
_TEXT	ENDS
PUBLIC	CipherGetBlockSize
;	COMDAT pdata
pdata	SEGMENT
$pdata$CipherGetBlockSize DD imagerel $LN3
	DD	imagerel $LN3+17
	DD	imagerel $unwind$CipherGetBlockSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CipherGetBlockSize DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT CipherGetBlockSize
_TEXT	SEGMENT
cipherId$ = 48
CipherGetBlockSize PROC					; COMDAT

; 330  : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 331  : 	return CipherGet (cipherId) -> BlockSize;

  00004	e8 00 00 00 00	 call	 CipherGet
  00009	8b 40 10	 mov	 eax, DWORD PTR [rax+16]

; 332  : }

  0000c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00010	c3		 ret	 0
CipherGetBlockSize ENDP
_TEXT	ENDS
PUBLIC	CipherGetName
;	COMDAT pdata
pdata	SEGMENT
$pdata$CipherGetName DD imagerel $LN3
	DD	imagerel $LN3+18
	DD	imagerel $unwind$CipherGetName
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CipherGetName DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT CipherGetName
_TEXT	SEGMENT
cipherId$ = 48
CipherGetName PROC					; COMDAT

; 325  : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 326  : 	return CipherGet (cipherId) -> Name;

  00004	e8 00 00 00 00	 call	 CipherGet
  00009	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 327  : }

  0000d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00011	c3		 ret	 0
CipherGetName ENDP
PUBLIC	EAGetKeyScheduleSize
;	COMDAT pdata
pdata	SEGMENT
$pdata$EAGetKeyScheduleSize DD imagerel $LN15
	DD	imagerel $LN15+70
	DD	imagerel $unwind$EAGetKeyScheduleSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EAGetKeyScheduleSize DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EAGetKeyScheduleSize
_TEXT	SEGMENT
ea$ = 48
EAGetKeyScheduleSize PROC				; COMDAT

; 576  : {

$LN15:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 63 d9	 movsxd	 rbx, ecx

; 577  : 	int i = EAGetFirstCipher(ea);

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  00010	48 8b c3	 mov	 rax, rbx
  00013	48 6b c0 2c	 imul	 rax, 44			; 0000002cH
  00017	8b 0c 08	 mov	 ecx, DWORD PTR [rax+rcx]

; 578  : 	int size = CipherGetKeyScheduleSize (i);

  0001a	e8 00 00 00 00	 call	 CipherGet
  0001f	44 8b 58 18	 mov	 r11d, DWORD PTR [rax+24]

; 579  : 
; 580  : 	while (i = EAGetNextCipher(ea, i))

  00023	eb 09		 jmp	 SHORT $LN14@EAGetKeySc
$LL2@EAGetKeySc:

; 581  : 	{
; 582  : 		size += CipherGetKeyScheduleSize (i);

  00025	e8 00 00 00 00	 call	 CipherGet
  0002a	44 03 58 18	 add	 r11d, DWORD PTR [rax+24]
$LN14@EAGetKeySc:
  0002e	8b d1		 mov	 edx, ecx
  00030	8b cb		 mov	 ecx, ebx
  00032	e8 00 00 00 00	 call	 EAGetNextCipher
  00037	8b c8		 mov	 ecx, eax
  00039	85 c0		 test	 eax, eax
  0003b	75 e8		 jne	 SHORT $LL2@EAGetKeySc

; 583  : 	}
; 584  : 
; 585  : 	return size;

  0003d	41 8b c3	 mov	 eax, r11d

; 586  : }

  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	5b		 pop	 rbx
  00045	c3		 ret	 0
EAGetKeyScheduleSize ENDP
_TEXT	ENDS
PUBLIC	EAGetKeySize
;	COMDAT pdata
pdata	SEGMENT
$pdata$EAGetKeySize DD imagerel $LN15
	DD	imagerel $LN15+70
	DD	imagerel $unwind$EAGetKeySize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EAGetKeySize DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EAGetKeySize
_TEXT	SEGMENT
ea$ = 48
EAGetKeySize PROC					; COMDAT

; 492  : {

$LN15:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 63 d9	 movsxd	 rbx, ecx

; 493  : 	int i = EAGetFirstCipher (ea);

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  00010	48 8b c3	 mov	 rax, rbx
  00013	48 6b c0 2c	 imul	 rax, 44			; 0000002cH
  00017	8b 0c 08	 mov	 ecx, DWORD PTR [rax+rcx]

; 494  : 	int size = CipherGetKeySize (i);

  0001a	e8 00 00 00 00	 call	 CipherGet
  0001f	44 8b 58 14	 mov	 r11d, DWORD PTR [rax+20]

; 495  : 
; 496  : 	while (i = EAGetNextCipher (ea, i))

  00023	eb 09		 jmp	 SHORT $LN14@EAGetKeySi
$LL2@EAGetKeySi:

; 497  : 	{
; 498  : 		size += CipherGetKeySize (i);

  00025	e8 00 00 00 00	 call	 CipherGet
  0002a	44 03 58 14	 add	 r11d, DWORD PTR [rax+20]
$LN14@EAGetKeySi:
  0002e	8b d1		 mov	 edx, ecx
  00030	8b cb		 mov	 ecx, ebx
  00032	e8 00 00 00 00	 call	 EAGetNextCipher
  00037	8b c8		 mov	 ecx, eax
  00039	85 c0		 test	 eax, eax
  0003b	75 e8		 jne	 SHORT $LL2@EAGetKeySi

; 499  : 	}
; 500  : 
; 501  : 	return size;

  0003d	41 8b c3	 mov	 eax, r11d

; 502  : }

  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	5b		 pop	 rbx
  00045	c3		 ret	 0
EAGetKeySize ENDP
_TEXT	ENDS
PUBLIC	EAGetName
;	COMDAT pdata
pdata	SEGMENT
$pdata$EAGetName DD imagerel $LN19
	DD	imagerel $LN19+171
	DD	imagerel $unwind$EAGetName
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EAGetName DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EAGetName
_TEXT	SEGMENT
buf$ = 48
ea$ = 56
EAGetName PROC						; COMDAT

; 458  : {

$LN19:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f1	 mov	 rsi, rcx

; 459  : 	int i = EAGetLastCipher(ea);

  00012	8b ca		 mov	 ecx, edx
  00014	8b da		 mov	 ebx, edx
  00016	e8 00 00 00 00	 call	 EAGetLastCipher
  0001b	8b f8		 mov	 edi, eax

; 460  : 	strcpy (buf, (i != 0) ? CipherGetName (i) : "?");

  0001d	85 c0		 test	 eax, eax
  0001f	74 0d		 je	 SHORT $LN5@EAGetName
  00021	8b c8		 mov	 ecx, eax
  00023	e8 00 00 00 00	 call	 CipherGet
  00028	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0002c	eb 07		 jmp	 SHORT $LN6@EAGetName
$LN5@EAGetName:
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01OGPIMHDM@?$DP?$AA@FNODOBFM@
$LN6@EAGetName:
  00035	48 8b d6	 mov	 rdx, rsi
$LL7@EAGetName:
  00038	8a 01		 mov	 al, BYTE PTR [rcx]
  0003a	48 ff c1	 inc	 rcx
  0003d	88 02		 mov	 BYTE PTR [rdx], al
  0003f	48 ff c2	 inc	 rdx
  00042	84 c0		 test	 al, al
  00044	75 f2		 jne	 SHORT $LL7@EAGetName

; 461  : 
; 462  : 	while (i = EAGetPreviousCipher(ea, i))

  00046	8b d7		 mov	 edx, edi
  00048	eb 40		 jmp	 SHORT $LN18@EAGetName
$LL2@EAGetName:

; 463  : 	{
; 464  : 		strcat (buf, "-");

  0004a	48 83 c9 ff	 or	 rcx, -1
  0004e	33 c0		 xor	 eax, eax
  00050	48 8b fe	 mov	 rdi, rsi
  00053	f2 ae		 repne scasb
  00055	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ??_C@_01JOAMLHOP@?9?$AA@FNODOBFM@
  0005c	66 89 4f ff	 mov	 WORD PTR [rdi-1], cx

; 465  : 		strcat (buf, CipherGetName (i));

  00060	41 8b cb	 mov	 ecx, r11d
  00063	e8 00 00 00 00	 call	 CipherGet
  00068	48 83 c9 ff	 or	 rcx, -1
  0006c	48 8b fe	 mov	 rdi, rsi
  0006f	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00073	33 c0		 xor	 eax, eax
  00075	f2 ae		 repne scasb
  00077	33 c9		 xor	 ecx, ecx
$LL16@EAGetName:
  00079	8a 04 0a	 mov	 al, BYTE PTR [rdx+rcx]
  0007c	48 ff c1	 inc	 rcx
  0007f	88 44 0f fe	 mov	 BYTE PTR [rdi+rcx-2], al
  00083	84 c0		 test	 al, al
  00085	75 f2		 jne	 SHORT $LL16@EAGetName

; 461  : 
; 462  : 	while (i = EAGetPreviousCipher(ea, i))

  00087	41 8b d3	 mov	 edx, r11d
$LN18@EAGetName:
  0008a	8b cb		 mov	 ecx, ebx
  0008c	e8 00 00 00 00	 call	 EAGetPreviousCipher
  00091	44 8b d8	 mov	 r11d, eax
  00094	85 c0		 test	 eax, eax
  00096	75 b2		 jne	 SHORT $LL2@EAGetName

; 466  : 	}
; 467  : 
; 468  : 	return buf;
; 469  : }

  00098	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0009d	48 8b c6	 mov	 rax, rsi
  000a0	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000a5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a9	5f		 pop	 rdi
  000aa	c3		 ret	 0
EAGetName ENDP
_TEXT	ENDS
PUBLIC	DecipherBlock
;	COMDAT pdata
pdata	SEGMENT
$pdata$DecipherBlock DD imagerel $LN15
	DD	imagerel $LN15+186
	DD	imagerel $unwind$DecipherBlock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecipherBlock DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT DecipherBlock
_TEXT	SEGMENT
cipher$ = 64
data$ = 72
ks$ = 80
DecipherBlock PROC					; COMDAT

; 243  : {

$LN15:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 244  : 	switch (cipher)

  0000a	b8 01 00 00 00	 mov	 eax, 1
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b da	 mov	 rbx, rdx
  00015	2b c8		 sub	 ecx, eax
  00017	74 6d		 je	 SHORT $LN7@DecipherBl
  00019	2b c8		 sub	 ecx, eax
  0001b	74 5f		 je	 SHORT $LN9@DecipherBl
  0001d	2b c8		 sub	 ecx, eax
  0001f	74 4e		 je	 SHORT $LN8@DecipherBl
  00021	2b c8		 sub	 ecx, eax
  00023	74 3d		 je	 SHORT $LN4@DecipherBl
  00025	2b c8		 sub	 ecx, eax
  00027	74 2f		 je	 SHORT $LN3@DecipherBl
  00029	3b c8		 cmp	 ecx, eax
  0002b	74 1e		 je	 SHORT $LN2@DecipherBl

; 262  : #else
; 263  : 	case AES:		aes_decrypt (data, data, ks); break;
; 264  : #endif
; 265  : 	default:		TC_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID

  0002d	8d 48 28	 lea	 ecx, QWORD PTR [rax+40]
  00030	45 33 c9	 xor	 r9d, r9d
  00033	45 33 c0	 xor	 r8d, r8d
  00036	ba 09 01 00 00	 mov	 edx, 265		; 00000109H
  0003b	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  0004a	cc		 int	 3
$LN2@DecipherBl:

; 261  : 	case TRIPLEDES:	TripleDesEncrypt (data, data, ks, 0); break;	// Deprecated/legacy

  0004b	45 33 c9	 xor	 r9d, r9d
  0004e	48 8b cb	 mov	 rcx, rbx
  00051	e8 00 00 00 00	 call	 TripleDesEncrypt
  00056	eb 57		 jmp	 SHORT $LN5@DecipherBl
$LN3@DecipherBl:

; 260  : 	case CAST:		Cast5Decrypt (data, data, ks); break;			// Deprecated/legacy

  00058	48 8b cb	 mov	 rcx, rbx
  0005b	e8 00 00 00 00	 call	 Cast5Decrypt
  00060	eb 4d		 jmp	 SHORT $LN5@DecipherBl
$LN4@DecipherBl:

; 257  : 		break;
; 258  : 
; 259  : 	case BLOWFISH:	BlowfishEncryptLE (data, data, ks, 0); break;	// Deprecated/legacy

  00062	45 33 c9	 xor	 r9d, r9d
  00065	48 8b cb	 mov	 rcx, rbx
  00068	e8 00 00 00 00	 call	 BlowfishEncryptLE
  0006d	eb 40		 jmp	 SHORT $LN5@DecipherBl
$LN8@DecipherBl:

; 247  : 	case TWOFISH:	twofish_decrypt (ks, data, data); break;

  0006f	4c 8b c2	 mov	 r8, rdx
  00072	48 8b cf	 mov	 rcx, rdi
  00075	e8 00 00 00 00	 call	 twofish_decrypt
  0007a	eb 33		 jmp	 SHORT $LN5@DecipherBl
$LN9@DecipherBl:

; 245  : 	{
; 246  : 	case SERPENT:	serpent_decrypt (data, data, ks); break;

  0007c	48 8b cb	 mov	 rcx, rbx
  0007f	e8 00 00 00 00	 call	 serpent_decrypt
  00084	eb 29		 jmp	 SHORT $LN5@DecipherBl
$LN7@DecipherBl:

; 248  : #ifndef TC_WINDOWS_BOOT
; 249  : 
; 250  : 	case AES:
; 251  : #if defined (_WIN64) || !defined (TC_WINDOWS_DRIVER)
; 252  : 		if (IsAesHwCpuSupported())

  00086	e8 00 00 00 00	 call	 IsAesHwCpuSupported

; 253  : 			aes_hw_cpu_decrypt ((byte *) ks + sizeof (aes_encrypt_ctx), data);

  0008b	48 8b d3	 mov	 rdx, rbx
  0008e	85 c0		 test	 eax, eax
  00090	74 0e		 je	 SHORT $LN6@DecipherBl
  00092	48 8d 8f f4 00
	00 00		 lea	 rcx, QWORD PTR [rdi+244]
  00099	e8 00 00 00 00	 call	 aes_hw_cpu_decrypt

; 254  : 		else

  0009e	eb 0f		 jmp	 SHORT $LN5@DecipherBl
$LN6@DecipherBl:

; 255  : #endif
; 256  : 			aes_decrypt (data, data, (void *) ((char *) ks + sizeof(aes_encrypt_ctx)));

  000a0	4c 8d 87 f4 00
	00 00		 lea	 r8, QWORD PTR [rdi+244]
  000a7	48 8b cb	 mov	 rcx, rbx
  000aa	e8 00 00 00 00	 call	 aes_decrypt
$LN5@DecipherBl:

; 266  : 	}
; 267  : }

  000af	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b8	5f		 pop	 rdi
  000b9	c3		 ret	 0
$LN14@DecipherBl:
DecipherBlock ENDP
_TEXT	ENDS
PUBLIC	EncipherBlock
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncipherBlock DD imagerel $LN15
	DD	imagerel $LN15+180
	DD	imagerel $unwind$EncipherBlock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncipherBlock DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EncipherBlock
_TEXT	SEGMENT
cipher$ = 64
data$ = 72
ks$ = 80
EncipherBlock PROC					; COMDAT

; 176  : {

$LN15:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 177  : 	switch (cipher)

  0000a	41 b9 01 00 00
	00		 mov	 r9d, 1
  00010	49 8b f8	 mov	 rdi, r8
  00013	48 8b da	 mov	 rbx, rdx
  00016	41 2b c9	 sub	 ecx, r9d
  00019	74 6d		 je	 SHORT $LN9@EncipherBl
  0001b	41 2b c9	 sub	 ecx, r9d
  0001e	74 5e		 je	 SHORT $LN5@EncipherBl
  00020	41 2b c9	 sub	 ecx, r9d
  00023	74 4c		 je	 SHORT $LN6@EncipherBl
  00025	41 2b c9	 sub	 ecx, r9d
  00028	74 3d		 je	 SHORT $LN4@EncipherBl
  0002a	41 2b c9	 sub	 ecx, r9d
  0002d	74 2e		 je	 SHORT $LN3@EncipherBl
  0002f	41 3b c9	 cmp	 ecx, r9d
  00032	74 1f		 je	 SHORT $LN2@EncipherBl

; 195  : #endif
; 196  : 	default:			TC_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID

  00034	45 33 c9	 xor	 r9d, r9d
  00037	45 33 c0	 xor	 r8d, r8d
  0003a	ba c4 00 00 00	 mov	 edx, 196		; 000000c4H
  0003f	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00043	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00052	cc		 int	 3
$LN2@EncipherBl:

; 194  : 	case TRIPLEDES:		TripleDesEncrypt (data, data, ks, 1); break;	// Deprecated/legacy

  00053	48 8b cb	 mov	 rcx, rbx
  00056	e8 00 00 00 00	 call	 TripleDesEncrypt
  0005b	eb 4c		 jmp	 SHORT $LN7@EncipherBl
$LN3@EncipherBl:

; 193  : 	case CAST:			Cast5Encrypt (data, data, ks); break;			// Deprecated/legacy

  0005d	48 8b cb	 mov	 rcx, rbx
  00060	e8 00 00 00 00	 call	 Cast5Encrypt
  00065	eb 42		 jmp	 SHORT $LN7@EncipherBl
$LN4@EncipherBl:

; 191  : #ifndef TC_WINDOWS_BOOT
; 192  : 	case BLOWFISH:		BlowfishEncryptLE (data, data, ks, 1); break;	// Deprecated/legacy

  00067	48 8b cb	 mov	 rcx, rbx
  0006a	e8 00 00 00 00	 call	 BlowfishEncryptLE
  0006f	eb 38		 jmp	 SHORT $LN7@EncipherBl
$LN6@EncipherBl:

; 187  : 		break;
; 188  : 
; 189  : 	case TWOFISH:		twofish_encrypt (ks, data, data); break;

  00071	4c 8b c2	 mov	 r8, rdx
  00074	48 8b cf	 mov	 rcx, rdi
  00077	e8 00 00 00 00	 call	 twofish_encrypt
  0007c	eb 2b		 jmp	 SHORT $LN7@EncipherBl
$LN5@EncipherBl:

; 190  : 	case SERPENT:		serpent_encrypt (data, data, ks); break;

  0007e	48 8b cb	 mov	 rcx, rbx
  00081	e8 00 00 00 00	 call	 serpent_encrypt
  00086	eb 21		 jmp	 SHORT $LN7@EncipherBl
$LN9@EncipherBl:

; 178  : 	{
; 179  : 	case AES:	
; 180  : 		// In 32-bit kernel mode, due to KeSaveFloatingPointState() overhead, AES instructions can be used only when processing the whole data unit.
; 181  : #if (defined (_WIN64) || !defined (TC_WINDOWS_DRIVER)) && !defined (TC_WINDOWS_BOOT)
; 182  : 		if (IsAesHwCpuSupported())

  00088	e8 00 00 00 00	 call	 IsAesHwCpuSupported

; 183  : 			aes_hw_cpu_encrypt (ks, data);

  0008d	48 8b d3	 mov	 rdx, rbx
  00090	85 c0		 test	 eax, eax
  00092	74 0a		 je	 SHORT $LN8@EncipherBl
  00094	48 8b cf	 mov	 rcx, rdi
  00097	e8 00 00 00 00	 call	 aes_hw_cpu_encrypt

; 184  : 		else

  0009c	eb 0b		 jmp	 SHORT $LN7@EncipherBl
$LN8@EncipherBl:

; 185  : #endif
; 186  : 			aes_encrypt (data, data, ks);

  0009e	4c 8b c7	 mov	 r8, rdi
  000a1	48 8b cb	 mov	 rcx, rbx
  000a4	e8 00 00 00 00	 call	 aes_encrypt
$LN7@EncipherBl:

; 197  : 	}
; 198  : }

  000a9	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ae	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b2	5f		 pop	 rdi
  000b3	c3		 ret	 0
$LN14@EncipherBl:
EncipherBlock ENDP
_TEXT	ENDS
PUBLIC	CipherInit
;	COMDAT pdata
; File c:\home\public\desktop\projects\ciphershed.build\src\crypto\des.c
pdata	SEGMENT
$pdata$CipherInit DD imagerel $LN29
	DD	imagerel $LN29+437
	DD	imagerel $unwind$CipherInit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CipherInit DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0d0143218H
	DD	07010c012H
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed.build\src\common\crypto.c
xdata	ENDS
;	COMDAT CipherInit
_TEXT	SEGMENT
cipher$ = 64
key$ = 72
ks$ = 80
CipherInit PROC						; COMDAT

; 115  : {

$LN29:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 116  : 	int retVal = ERR_SUCCESS;

  00018	33 ed		 xor	 ebp, ebp
  0001a	49 8b f8	 mov	 rdi, r8
  0001d	48 8b f2	 mov	 rsi, rdx

; 117  : 
; 118  : 	switch (cipher)

  00020	44 8d 6d 01	 lea	 r13d, QWORD PTR [rbp+1]
  00024	41 2b cd	 sub	 ecx, r13d
  00027	0f 84 3f 01 00
	00		 je	 $LN11@CipherInit
  0002d	41 2b cd	 sub	 ecx, r13d
  00030	0f 84 19 01 00
	00		 je	 $LN8@CipherInit
  00036	41 2b cd	 sub	 ecx, r13d
  00039	0f 84 f1 00 00
	00		 je	 $LN7@CipherInit
  0003f	41 2b cd	 sub	 ecx, r13d
  00042	0f 84 ce 00 00
	00		 je	 $LN6@CipherInit
  00048	41 2b cd	 sub	 ecx, r13d
  0004b	0f 84 a8 00 00
	00		 je	 $LN5@CipherInit
  00051	41 3b cd	 cmp	 ecx, r13d

; 164  : 
; 165  : #endif	// TC_WINDOWS_BOOT
; 166  : 
; 167  : 	default:
; 168  : 		// Unknown/wrong cipher ID
; 169  : 		return ERR_CIPHER_INIT_FAILURE;

  00054	0f 85 21 01 00
	00		 jne	 $LN28@CipherInit
  0005a	41 8b cd	 mov	 ecx, r13d
  0005d	e8 00 00 00 00	 call	 RawSetKey
  00062	4c 8d 87 80 00
	00 00		 lea	 r8, QWORD PTR [rdi+128]
  00069	48 8d 56 08	 lea	 rdx, QWORD PTR [rsi+8]
  0006d	41 8b cd	 mov	 ecx, r13d
  00070	e8 00 00 00 00	 call	 RawSetKey
  00075	4c 8d 87 00 01
	00 00		 lea	 r8, QWORD PTR [rdi+256]
  0007c	48 8d 56 10	 lea	 rdx, QWORD PTR [rsi+16]
  00080	41 8b cd	 mov	 ecx, r13d
  00083	e8 00 00 00 00	 call	 RawSetKey
  00088	4c 8d 87 80 01
	00 00		 lea	 r8, QWORD PTR [rdi+384]
  0008f	48 8d 56 10	 lea	 rdx, QWORD PTR [rsi+16]
  00093	33 c9		 xor	 ecx, ecx
  00095	e8 00 00 00 00	 call	 RawSetKey
  0009a	4c 8d 87 00 02
	00 00		 lea	 r8, QWORD PTR [rdi+512]
  000a1	48 8d 56 08	 lea	 rdx, QWORD PTR [rsi+8]
  000a5	33 c9		 xor	 ecx, ecx
  000a7	e8 00 00 00 00	 call	 RawSetKey
  000ac	4c 8d 87 80 02
	00 00		 lea	 r8, QWORD PTR [rdi+640]
  000b3	48 8b d6	 mov	 rdx, rsi
  000b6	33 c9		 xor	 ecx, ecx
  000b8	e8 00 00 00 00	 call	 RawSetKey
  000bd	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000c0	48 ba fe fe fe
	fe fe fe fe fe	 mov	 rdx, -72340172838076674	; fefefefefefefefeH
  000ca	48 33 46 08	 xor	 rax, QWORD PTR [rsi+8]
  000ce	48 85 c2	 test	 rax, rdx
  000d1	74 1c		 je	 SHORT $LN2@CipherInit
  000d3	48 8b 4e 10	 mov	 rcx, QWORD PTR [rsi+16]
  000d7	48 8b c1	 mov	 rax, rcx
  000da	48 33 46 08	 xor	 rax, QWORD PTR [rsi+8]
  000de	48 85 c2	 test	 rax, rdx
  000e1	74 0c		 je	 SHORT $LN2@CipherInit
  000e3	48 33 0e	 xor	 rcx, QWORD PTR [rsi]
  000e6	48 85 ca	 test	 rcx, rdx
  000e9	0f 85 ab 00 00
	00		 jne	 $LN9@CipherInit
$LN2@CipherInit:

; 152  : 
; 153  : 	case TRIPLEDES:
; 154  : 		/* Deprecated/legacy */
; 155  : 		TripleDesSetKey (key, CipherGetKeySize (TRIPLEDES), (TDES_KEY *) ks);
; 156  : 
; 157  : 		// Verify whether all three DES keys are mutually different
; 158  : 		if (((*((__int64 *) key) ^ *((__int64 *) key+1)) & 0xFEFEFEFEFEFEFEFEULL) == 0
; 159  : 		|| ((*((__int64 *) key+1) ^ *((__int64 *) key+2)) & 0xFEFEFEFEFEFEFEFEULL) == 0
; 160  : 		|| ((*((__int64 *) key) ^ *((__int64 *) key+2)) & 0xFEFEFEFEFEFEFEFEULL) == 0)
; 161  : 			retVal = ERR_CIPHER_INIT_WEAK_KEY;		// Non-fatal error

  000ef	bd 12 00 00 00	 mov	 ebp, 18

; 162  : 
; 163  : 		break;

  000f4	e9 a1 00 00 00	 jmp	 $LN9@CipherInit
$LN5@CipherInit:

; 147  : 
; 148  : 	case CAST:
; 149  : 		/* Deprecated/legacy */
; 150  : 		Cast5SetKey ((CAST_KEY *) ks, CipherGetKeySize(CAST), key);

  000f9	b9 05 00 00 00	 mov	 ecx, 5
  000fe	e8 00 00 00 00	 call	 CipherGet
  00103	4c 8b c6	 mov	 r8, rsi
  00106	48 8b cf	 mov	 rcx, rdi
  00109	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  0010c	e8 00 00 00 00	 call	 Cast5SetKey

; 151  : 		break;

  00111	e9 84 00 00 00	 jmp	 $LN9@CipherInit
$LN6@CipherInit:

; 140  : 
; 141  : #ifndef TC_WINDOWS_BOOT
; 142  : 		
; 143  : 	case BLOWFISH:
; 144  : 		/* Deprecated/legacy */
; 145  : 		BlowfishSetKey ((BF_KEY *)ks, CipherGetKeySize(BLOWFISH), key);

  00116	b9 04 00 00 00	 mov	 ecx, 4
  0011b	e8 00 00 00 00	 call	 CipherGet
  00120	4c 8b c6	 mov	 r8, rsi
  00123	48 8b cf	 mov	 rcx, rdi
  00126	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  00129	e8 00 00 00 00	 call	 BlowfishSetKey

; 146  : 		break;

  0012e	eb 6a		 jmp	 SHORT $LN9@CipherInit
$LN7@CipherInit:

; 136  : 		
; 137  : 	case TWOFISH:
; 138  : 		twofish_set_key ((TwofishInstance *)ks, (const u4byte *)key, CipherGetKeySize(TWOFISH) * 8);

  00130	b9 03 00 00 00	 mov	 ecx, 3
  00135	e8 00 00 00 00	 call	 CipherGet
  0013a	48 8b d6	 mov	 rdx, rsi
  0013d	48 8b cf	 mov	 rcx, rdi
  00140	44 8b 40 14	 mov	 r8d, DWORD PTR [rax+20]
  00144	41 c1 e0 03	 shl	 r8d, 3
  00148	e8 00 00 00 00	 call	 twofish_set_key

; 139  : 		break;

  0014d	eb 4b		 jmp	 SHORT $LN9@CipherInit
$LN8@CipherInit:

; 127  : #else
; 128  : 		if (aes_set_key (key, (length_type) CipherGetKeySize(AES), (aes_context *) ks) != 0)
; 129  : 			return ERR_CIPHER_INIT_FAILURE;
; 130  : #endif
; 131  : 		break;
; 132  : 
; 133  : 	case SERPENT:
; 134  : 		serpent_set_key (key, CipherGetKeySize(SERPENT) * 8, ks);

  0014f	b9 02 00 00 00	 mov	 ecx, 2
  00154	e8 00 00 00 00	 call	 CipherGet
  00159	4c 8b c7	 mov	 r8, rdi
  0015c	48 8b ce	 mov	 rcx, rsi
  0015f	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  00162	c1 e2 03	 shl	 edx, 3
  00165	e8 00 00 00 00	 call	 serpent_set_key

; 135  : 		break;

  0016a	eb 2e		 jmp	 SHORT $LN9@CipherInit
$LN11@CipherInit:

; 119  : 	{
; 120  : 	case AES:
; 121  : #ifndef TC_WINDOWS_BOOT
; 122  : 		if (aes_encrypt_key256 (key, (aes_encrypt_ctx *) ks) != EXIT_SUCCESS)

  0016c	49 8b d0	 mov	 rdx, r8
  0016f	48 8b ce	 mov	 rcx, rsi
  00172	e8 00 00 00 00	 call	 aes_encrypt_key256
  00177	3b c5		 cmp	 eax, ebp
  00179	74 07		 je	 SHORT $LN10@CipherInit
$LN28@CipherInit:

; 123  : 			return ERR_CIPHER_INIT_FAILURE;

  0017b	b8 11 00 00 00	 mov	 eax, 17
  00180	eb 1a		 jmp	 SHORT $LN14@CipherInit
$LN10@CipherInit:

; 124  : 
; 125  : 		if (aes_decrypt_key256 (key, (aes_decrypt_ctx *) (ks + sizeof(aes_encrypt_ctx))) != EXIT_SUCCESS)

  00182	48 8d 97 f4 00
	00 00		 lea	 rdx, QWORD PTR [rdi+244]
  00189	48 8b ce	 mov	 rcx, rsi
  0018c	e8 00 00 00 00	 call	 aes_decrypt_key256
  00191	3b c5		 cmp	 eax, ebp

; 126  : 			return ERR_CIPHER_INIT_FAILURE;

  00193	b8 11 00 00 00	 mov	 eax, 17
  00198	75 02		 jne	 SHORT $LN14@CipherInit
$LN9@CipherInit:

; 170  : 	}
; 171  : 
; 172  : 	return retVal;

  0019a	8b c5		 mov	 eax, ebp
$LN14@CipherInit:

; 173  : }

  0019c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001a1	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  001a6	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  001ab	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001af	41 5d		 pop	 r13
  001b1	41 5c		 pop	 r12
  001b3	5f		 pop	 rdi
  001b4	c3		 ret	 0
CipherInit ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$DecryptBufferCBC DD imagerel DecryptBufferCBC
	DD	imagerel DecryptBufferCBC+514
	DD	imagerel $unwind$DecryptBufferCBC
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecryptBufferCBC DD 0a1901H
	DD	0143419H
	DD	0f015b219H
	DD	0d011e013H
	DD	0700dc00fH
	DD	0500b600cH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT DecryptBufferCBC
_TEXT	SEGMENT
bufIV$2$ = 48
ct$3$ = 52
ct$4$ = 56
ct$1$ = 60
ct$2$ = 64
ct$ = 72
bufIV$ = 72
data$ = 160
bufIV$1$ = 168
len$ = 168
ks$ = 176
iv$ = 184
whitening$ = 192
bufIV$4$ = 200
ea$ = 200
cipher$ = 208
DecryptBufferCBC PROC					; COMDAT

; 1161 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	55		 push	 rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	41 54		 push	 r12
  0000f	41 55		 push	 r13
  00011	41 56		 push	 r14
  00013	41 57		 push	 r15
  00015	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 1162 : 
; 1163 : 	/* IMPORTANT: This function has been deprecated (legacy) */
; 1164 : 
; 1165 : 	unsigned __int32 bufIV[4];
; 1166 : 	unsigned __int64 i;
; 1167 : 	unsigned __int32 ct[4];
; 1168 : 	int blockSize = CipherGetBlockSize (ea != 0 ? EAGetFirstCipher (ea) : cipher);

  00019	48 63 b4 24 c8
	00 00 00	 movsxd	 rsi, DWORD PTR ea$[rsp]
  00021	44 8b ac 24 d0
	00 00 00	 mov	 r13d, DWORD PTR cipher$[rsp]
  00029	4d 8b d1	 mov	 r10, r9
  0002c	44 8b da	 mov	 r11d, edx
  0002f	48 8b d9	 mov	 rbx, rcx
  00032	85 f6		 test	 esi, esi
  00034	74 13		 je	 SHORT $LN16@DecryptBuf@2
  00036	48 8b c6	 mov	 rax, rsi
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  00040	48 6b c0 2c	 imul	 rax, 44			; 0000002cH
  00044	8b 0c 08	 mov	 ecx, DWORD PTR [rax+rcx]
  00047	eb 03		 jmp	 SHORT $LN17@DecryptBuf@2
$LN16@DecryptBuf@2:
  00049	41 8b cd	 mov	 ecx, r13d
$LN17@DecryptBuf@2:
  0004c	e8 00 00 00 00	 call	 CipherGet

; 1169 : 
; 1170 : 	if (len % blockSize)

  00051	33 d2		 xor	 edx, edx
  00053	48 63 78 10	 movsxd	 rdi, DWORD PTR [rax+16]
  00057	41 8b c3	 mov	 eax, r11d
  0005a	f7 f7		 div	 edi
  0005c	85 d2		 test	 edx, edx
  0005e	74 1f		 je	 SHORT $LN13@DecryptBuf@2

; 1171 : 		TC_THROW_FATAL_EXCEPTION;

  00060	45 33 c9	 xor	 r9d, r9d
  00063	45 33 c0	 xor	 r8d, r8d
  00066	ba 93 04 00 00	 mov	 edx, 1171		; 00000493H
  0006b	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  0006f	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  0007e	cc		 int	 3
$LN13@DecryptBuf@2:

; 1172 : 
; 1173 : 	//  IV
; 1174 : 	bufIV[0] = iv[0];

  0007f	41 8b 12	 mov	 edx, DWORD PTR [r10]
  00082	89 94 24 a8 00
	00 00		 mov	 DWORD PTR bufIV$1$[rsp], edx

; 1175 : 	bufIV[1] = iv[1];

  00089	41 8b 52 04	 mov	 edx, DWORD PTR [r10+4]
  0008d	89 54 24 30	 mov	 DWORD PTR bufIV$2$[rsp], edx

; 1176 : 	if (blockSize == 16)

  00091	83 ff 10	 cmp	 edi, 16
  00094	75 0a		 jne	 SHORT $LN28@DecryptBuf@2

; 1177 : 	{
; 1178 : 		bufIV[2] = iv[2];

  00096	45 8b 7a 08	 mov	 r15d, DWORD PTR [r10+8]

; 1179 : 		bufIV[3] = iv[3];

  0009a	41 8b 4a 0c	 mov	 ecx, DWORD PTR [r10+12]
  0009e	eb 09		 jmp	 SHORT $LN30@DecryptBuf@2
$LN28@DecryptBuf@2:
  000a0	8b 4c 24 54	 mov	 ecx, DWORD PTR bufIV$[rsp+12]
  000a4	44 8b 7c 24 50	 mov	 r15d, DWORD PTR bufIV$[rsp+8]
$LN30@DecryptBuf@2:
  000a9	89 8c 24 c8 00
	00 00		 mov	 DWORD PTR bufIV$4$[rsp], ecx

; 1180 : 	}
; 1181 : 
; 1182 : 	// Decrypt each block
; 1183 : 	for (i = 0; i < len/blockSize; i++)

  000b0	44 8b e0	 mov	 r12d, eax
  000b3	85 c0		 test	 eax, eax
  000b5	0f 84 2f 01 00
	00		 je	 $LN9@DecryptBuf@2
  000bb	8b 4c 24 54	 mov	 ecx, DWORD PTR ct$[rsp+12]
  000bf	4c 8b b4 24 c0
	00 00 00	 mov	 r14, QWORD PTR whitening$[rsp]
  000c7	48 8b ef	 mov	 rbp, rdi
  000ca	89 4c 24 38	 mov	 DWORD PTR ct$4$[rsp], ecx
  000ce	8b 4c 24 50	 mov	 ecx, DWORD PTR ct$[rsp+8]
  000d2	48 83 e5 fc	 and	 rbp, -4
  000d6	89 4c 24 34	 mov	 DWORD PTR ct$3$[rsp], ecx
$LL11@DecryptBuf@2:

; 1184 : 	{
; 1185 : 		// Dewhitening
; 1186 : 		data[0] ^= whitening[0];

  000da	41 8b 06	 mov	 eax, DWORD PTR [r14]
  000dd	31 03		 xor	 DWORD PTR [rbx], eax

; 1187 : 		data[1] ^= whitening[1];

  000df	41 8b 46 04	 mov	 eax, DWORD PTR [r14+4]
  000e3	31 43 04	 xor	 DWORD PTR [rbx+4], eax

; 1188 : 		if (blockSize == 16)

  000e6	83 ff 10	 cmp	 edi, 16
  000e9	75 0d		 jne	 SHORT $LN8@DecryptBuf@2

; 1189 : 		{
; 1190 : 			data[2] ^= whitening[0];

  000eb	41 8b 06	 mov	 eax, DWORD PTR [r14]
  000ee	31 43 08	 xor	 DWORD PTR [rbx+8], eax

; 1191 : 			data[3] ^= whitening[1];

  000f1	41 8b 46 04	 mov	 eax, DWORD PTR [r14+4]
  000f5	31 43 0c	 xor	 DWORD PTR [rbx+12], eax
$LN8@DecryptBuf@2:

; 1192 : 		}
; 1193 : 
; 1194 : 		// CBC
; 1195 : 		ct[0] = data[0];

  000f8	8b 03		 mov	 eax, DWORD PTR [rbx]
  000fa	89 44 24 3c	 mov	 DWORD PTR ct$1$[rsp], eax

; 1196 : 		ct[1] = data[1];

  000fe	8b 43 04	 mov	 eax, DWORD PTR [rbx+4]
  00101	89 44 24 40	 mov	 DWORD PTR ct$2$[rsp], eax

; 1197 : 		if (blockSize == 16)

  00105	83 ff 10	 cmp	 edi, 16
  00108	75 0e		 jne	 SHORT $LN7@DecryptBuf@2

; 1198 : 		{
; 1199 : 			ct[2] = data[2];

  0010a	8b 43 08	 mov	 eax, DWORD PTR [rbx+8]
  0010d	89 44 24 34	 mov	 DWORD PTR ct$3$[rsp], eax

; 1200 : 			ct[3] = data[3];

  00111	8b 43 0c	 mov	 eax, DWORD PTR [rbx+12]
  00114	89 44 24 38	 mov	 DWORD PTR ct$4$[rsp], eax
$LN7@DecryptBuf@2:

; 1201 : 		}
; 1202 : 
; 1203 : 		if (ea != 0)

  00118	85 f6		 test	 esi, esi
  0011a	74 68		 je	 SHORT $LN6@DecryptBuf@2

; 1204 : 		{
; 1205 : 			// Outer-CBC
; 1206 : 			ks += EAGetKeyScheduleSize (ea);

  0011c	8b ce		 mov	 ecx, esi
  0011e	e8 00 00 00 00	 call	 EAGetKeyScheduleSize
  00123	48 63 c8	 movsxd	 rcx, eax
  00126	48 01 8c 24 b0
	00 00 00	 add	 QWORD PTR ks$[rsp], rcx

; 1207 : 			for (cipher = EAGetLastCipher (ea); cipher != 0; cipher = EAGetPreviousCipher (ea, cipher))

  0012e	8b ce		 mov	 ecx, esi
  00130	e8 00 00 00 00	 call	 EAGetLastCipher
  00135	44 8b e8	 mov	 r13d, eax
  00138	85 c0		 test	 eax, eax
  0013a	74 5b		 je	 SHORT $LN2@DecryptBuf@2
  0013c	4c 8b b4 24 b0
	00 00 00	 mov	 r14, QWORD PTR ks$[rsp]
$LL5@DecryptBuf@2:

; 1208 : 			{
; 1209 : 				ks -= CipherGetKeyScheduleSize (cipher);

  00144	41 8b cd	 mov	 ecx, r13d
  00147	e8 00 00 00 00	 call	 CipherGet

; 1210 : 				DecipherBlock (cipher, data, ks);

  0014c	48 8b d3	 mov	 rdx, rbx
  0014f	48 63 48 18	 movsxd	 rcx, DWORD PTR [rax+24]
  00153	4c 2b f1	 sub	 r14, rcx
  00156	41 8b cd	 mov	 ecx, r13d
  00159	4d 8b c6	 mov	 r8, r14
  0015c	e8 00 00 00 00	 call	 DecipherBlock
  00161	41 8b d5	 mov	 edx, r13d
  00164	8b ce		 mov	 ecx, esi
  00166	e8 00 00 00 00	 call	 EAGetPreviousCipher
  0016b	44 8b e8	 mov	 r13d, eax
  0016e	85 c0		 test	 eax, eax
  00170	75 d2		 jne	 SHORT $LL5@DecryptBuf@2
  00172	4c 89 b4 24 b0
	00 00 00	 mov	 QWORD PTR ks$[rsp], r14

; 1211 : 			}
; 1212 : 		}
; 1213 : 		else

  0017a	4c 8b b4 24 c0
	00 00 00	 mov	 r14, QWORD PTR whitening$[rsp]
  00182	eb 13		 jmp	 SHORT $LN2@DecryptBuf@2
$LN6@DecryptBuf@2:

; 1214 : 		{
; 1215 : 			// CBC/inner-CBC
; 1216 : 			DecipherBlock (cipher, data, ks);

  00184	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR ks$[rsp]
  0018c	48 8b d3	 mov	 rdx, rbx
  0018f	41 8b cd	 mov	 ecx, r13d
  00192	e8 00 00 00 00	 call	 DecipherBlock
$LN2@DecryptBuf@2:

; 1217 : 		}
; 1218 : 
; 1219 : 		// CBC
; 1220 : 		data[0] ^= bufIV[0];

  00197	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR bufIV$1$[rsp]
  0019e	31 03		 xor	 DWORD PTR [rbx], eax

; 1221 : 		data[1] ^= bufIV[1];

  001a0	8b 44 24 30	 mov	 eax, DWORD PTR bufIV$2$[rsp]
  001a4	31 43 04	 xor	 DWORD PTR [rbx+4], eax

; 1222 : 		bufIV[0] = ct[0];

  001a7	8b 44 24 3c	 mov	 eax, DWORD PTR ct$1$[rsp]
  001ab	89 84 24 a8 00
	00 00		 mov	 DWORD PTR bufIV$1$[rsp], eax

; 1223 : 		bufIV[1] = ct[1];

  001b2	8b 44 24 40	 mov	 eax, DWORD PTR ct$2$[rsp]
  001b6	89 44 24 30	 mov	 DWORD PTR bufIV$2$[rsp], eax

; 1224 : 		if (blockSize == 16)

  001ba	83 ff 10	 cmp	 edi, 16
  001bd	75 1e		 jne	 SHORT $LN1@DecryptBuf@2

; 1225 : 		{
; 1226 : 			data[2] ^= bufIV[2];
; 1227 : 			data[3] ^= bufIV[3];

  001bf	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR bufIV$4$[rsp]
  001c6	44 31 7b 08	 xor	 DWORD PTR [rbx+8], r15d

; 1228 : 			bufIV[2] = ct[2];

  001ca	44 8b 7c 24 34	 mov	 r15d, DWORD PTR ct$3$[rsp]
  001cf	31 43 0c	 xor	 DWORD PTR [rbx+12], eax

; 1229 : 			bufIV[3] = ct[3];

  001d2	8b 44 24 38	 mov	 eax, DWORD PTR ct$4$[rsp]
  001d6	89 84 24 c8 00
	00 00		 mov	 DWORD PTR bufIV$4$[rsp], eax
$LN1@DecryptBuf@2:

; 1230 : 		}
; 1231 : 
; 1232 : 		data += blockSize / sizeof(*data);

  001dd	48 03 dd	 add	 rbx, rbp
  001e0	49 83 ec 01	 sub	 r12, 1
  001e4	0f 85 f0 fe ff
	ff		 jne	 $LL11@DecryptBuf@2
$LN9@DecryptBuf@2:

; 1233 : 	}
; 1234 : }

  001ea	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+160]
  001f2	48 83 c4 60	 add	 rsp, 96			; 00000060H
  001f6	41 5f		 pop	 r15
  001f8	41 5e		 pop	 r14
  001fa	41 5d		 pop	 r13
  001fc	41 5c		 pop	 r12
  001fe	5f		 pop	 rdi
  001ff	5e		 pop	 rsi
  00200	5d		 pop	 rbp
  00201	c3		 ret	 0
$LN29@DecryptBuf@2:
DecryptBufferCBC ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptBufferCBC DD imagerel EncryptBufferCBC
	DD	imagerel EncryptBufferCBC+434
	DD	imagerel $unwind$EncryptBufferCBC
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptBufferCBC DD 0c2001H
	DD	0116420H
	DD	0f5420H
	DD	0e3420H
	DD	0f01c7220H
	DD	0d018e01aH
	DD	07014c016H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EncryptBufferCBC
_TEXT	SEGMENT
tv279 = 48
bufIV$ = 48
data$ = 112
len$ = 120
ks$ = 128
iv$ = 136
whitening$ = 144
ea$ = 152
cipher$ = 160
EncryptBufferCBC PROC					; COMDAT

; 1073 : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 20	 mov	 QWORD PTR [rax+32], rsi
  0000f	4c 89 40 18	 mov	 QWORD PTR [rax+24], r8
  00013	57		 push	 rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 56		 push	 r14
  0001a	41 57		 push	 r15
  0001c	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1074 : 	/* IMPORTANT: This function has been deprecated (legacy) */
; 1075 : 
; 1076 : 	unsigned __int32 bufIV[4];
; 1077 : 	unsigned __int64 i;
; 1078 : 	int blockSize = CipherGetBlockSize (ea != 0 ? EAGetFirstCipher (ea) : cipher);

  00020	48 63 bc 24 98
	00 00 00	 movsxd	 rdi, DWORD PTR ea$[rsp]
  00028	8b ac 24 a0 00
	00 00		 mov	 ebp, DWORD PTR cipher$[rsp]
  0002f	48 8b d9	 mov	 rbx, rcx
  00032	4d 8b d1	 mov	 r10, r9
  00035	44 8b da	 mov	 r11d, edx
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  0003f	85 ff		 test	 edi, edi
  00041	74 0c		 je	 SHORT $LN16@EncryptBuf@2
  00043	48 8b c7	 mov	 rax, rdi
  00046	48 6b c0 2c	 imul	 rax, 44			; 0000002cH
  0004a	8b 0c 08	 mov	 ecx, DWORD PTR [rax+rcx]
  0004d	eb 02		 jmp	 SHORT $LN17@EncryptBuf@2
$LN16@EncryptBuf@2:
  0004f	8b cd		 mov	 ecx, ebp
$LN17@EncryptBuf@2:
  00051	e8 00 00 00 00	 call	 CipherGet

; 1079 : 
; 1080 : 	if (len % blockSize)

  00056	33 d2		 xor	 edx, edx
  00058	48 63 70 10	 movsxd	 rsi, DWORD PTR [rax+16]
  0005c	41 8b c3	 mov	 eax, r11d
  0005f	f7 f6		 div	 esi
  00061	85 d2		 test	 edx, edx
  00063	74 1f		 je	 SHORT $LN13@EncryptBuf@2

; 1081 : 		TC_THROW_FATAL_EXCEPTION;

  00065	45 33 c9	 xor	 r9d, r9d
  00068	45 33 c0	 xor	 r8d, r8d
  0006b	ba 39 04 00 00	 mov	 edx, 1081		; 00000439H
  00070	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00074	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00083	cc		 int	 3
$LN13@EncryptBuf@2:

; 1082 : 
; 1083 : 	//  IV
; 1084 : 	bufIV[0] = iv[0];

  00084	41 8b 0a	 mov	 ecx, DWORD PTR [r10]

; 1085 : 	bufIV[1] = iv[1];

  00087	41 8b 52 04	 mov	 edx, DWORD PTR [r10+4]

; 1086 : 	if (blockSize == 16)

  0008b	83 fe 10	 cmp	 esi, 16
  0008e	75 0a		 jne	 SHORT $LN30@EncryptBuf@2

; 1087 : 	{
; 1088 : 		bufIV[2] = iv[2];

  00090	45 8b 72 08	 mov	 r14d, DWORD PTR [r10+8]

; 1089 : 		bufIV[3] = iv[3];

  00094	45 8b 7a 0c	 mov	 r15d, DWORD PTR [r10+12]
  00098	eb 0a		 jmp	 SHORT $LN12@EncryptBuf@2
$LN30@EncryptBuf@2:
  0009a	44 8b 7c 24 3c	 mov	 r15d, DWORD PTR bufIV$[rsp+12]
  0009f	44 8b 74 24 38	 mov	 r14d, DWORD PTR bufIV$[rsp+8]
$LN12@EncryptBuf@2:

; 1090 : 	}
; 1091 : 
; 1092 : 	// Encrypt each block
; 1093 : 	for (i = 0; i < len/blockSize; i++)

  000a4	44 8b e8	 mov	 r13d, eax
  000a7	85 c0		 test	 eax, eax
  000a9	0f 84 e5 00 00
	00		 je	 $LN9@EncryptBuf@2
  000af	4c 8b e6	 mov	 r12, rsi
  000b2	49 83 e4 fc	 and	 r12, -4
  000b6	4c 89 64 24 30	 mov	 QWORD PTR tv279[rsp], r12
$LL11@EncryptBuf@2:

; 1094 : 	{
; 1095 : 		// CBC
; 1096 : 		data[0] ^= bufIV[0];

  000bb	31 0b		 xor	 DWORD PTR [rbx], ecx

; 1097 : 		data[1] ^= bufIV[1];

  000bd	31 53 04	 xor	 DWORD PTR [rbx+4], edx

; 1098 : 		if (blockSize == 16)

  000c0	83 fe 10	 cmp	 esi, 16
  000c3	75 08		 jne	 SHORT $LN8@EncryptBuf@2

; 1099 : 		{
; 1100 : 			data[2] ^= bufIV[2];

  000c5	44 31 73 08	 xor	 DWORD PTR [rbx+8], r14d

; 1101 : 			data[3] ^= bufIV[3];

  000c9	44 31 7b 0c	 xor	 DWORD PTR [rbx+12], r15d
$LN8@EncryptBuf@2:

; 1102 : 		}
; 1103 : 
; 1104 : 		if (ea != 0)

  000cd	85 ff		 test	 edi, edi
  000cf	74 68		 je	 SHORT $LN7@EncryptBuf@2

; 1105 : 		{
; 1106 : 			// Outer-CBC
; 1107 : 			for (cipher = EAGetFirstCipher (ea); cipher != 0; cipher = EAGetNextCipher (ea, cipher))

  000d1	48 8b c7	 mov	 rax, rdi
  000d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  000db	48 6b c0 2c	 imul	 rax, 44			; 0000002cH
  000df	8b 2c 08	 mov	 ebp, DWORD PTR [rax+rcx]
  000e2	85 ed		 test	 ebp, ebp
  000e4	74 3f		 je	 SHORT $LN4@EncryptBuf@2
  000e6	4c 8b a4 24 80
	00 00 00	 mov	 r12, QWORD PTR ks$[rsp]
$LL6@EncryptBuf@2:

; 1108 : 			{
; 1109 : 				EncipherBlock (cipher, data, ks);

  000ee	4d 8b c4	 mov	 r8, r12
  000f1	48 8b d3	 mov	 rdx, rbx
  000f4	8b cd		 mov	 ecx, ebp
  000f6	e8 00 00 00 00	 call	 EncipherBlock

; 1110 : 				ks += CipherGetKeyScheduleSize (cipher);

  000fb	8b cd		 mov	 ecx, ebp
  000fd	e8 00 00 00 00	 call	 CipherGet
  00102	8b d5		 mov	 edx, ebp
  00104	48 63 48 18	 movsxd	 rcx, DWORD PTR [rax+24]
  00108	4c 03 e1	 add	 r12, rcx
  0010b	8b cf		 mov	 ecx, edi
  0010d	e8 00 00 00 00	 call	 EAGetNextCipher
  00112	8b e8		 mov	 ebp, eax
  00114	85 c0		 test	 eax, eax
  00116	75 d6		 jne	 SHORT $LL6@EncryptBuf@2
  00118	4c 89 a4 24 80
	00 00 00	 mov	 QWORD PTR ks$[rsp], r12
  00120	4c 8b 64 24 30	 mov	 r12, QWORD PTR tv279[rsp]
$LN4@EncryptBuf@2:

; 1111 : 			}
; 1112 : 			ks -= EAGetKeyScheduleSize (ea);

  00125	8b cf		 mov	 ecx, edi
  00127	e8 00 00 00 00	 call	 EAGetKeyScheduleSize
  0012c	48 63 c8	 movsxd	 rcx, eax
  0012f	48 29 8c 24 80
	00 00 00	 sub	 QWORD PTR ks$[rsp], rcx

; 1113 : 		}
; 1114 : 		else

  00137	eb 12		 jmp	 SHORT $LN3@EncryptBuf@2
$LN7@EncryptBuf@2:

; 1115 : 		{
; 1116 : 			// CBC/inner-CBC
; 1117 : 			EncipherBlock (cipher, data, ks);

  00139	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR ks$[rsp]
  00141	48 8b d3	 mov	 rdx, rbx
  00144	8b cd		 mov	 ecx, ebp
  00146	e8 00 00 00 00	 call	 EncipherBlock
$LN3@EncryptBuf@2:

; 1118 : 		}
; 1119 : 
; 1120 : 		// CBC
; 1121 : 		bufIV[0] = data[0];

  0014b	8b 0b		 mov	 ecx, DWORD PTR [rbx]

; 1122 : 		bufIV[1] = data[1];

  0014d	8b 53 04	 mov	 edx, DWORD PTR [rbx+4]

; 1123 : 		if (blockSize == 16)

  00150	83 fe 10	 cmp	 esi, 16
  00153	75 08		 jne	 SHORT $LN2@EncryptBuf@2

; 1124 : 		{
; 1125 : 			bufIV[2] = data[2];

  00155	44 8b 73 08	 mov	 r14d, DWORD PTR [rbx+8]

; 1126 : 			bufIV[3] = data[3];

  00159	44 8b 7b 0c	 mov	 r15d, DWORD PTR [rbx+12]
$LN2@EncryptBuf@2:

; 1127 : 		}
; 1128 : 
; 1129 : 		// Whitening
; 1130 : 		data[0] ^= whitening[0];

  0015d	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR whitening$[rsp]
  00165	41 8b 00	 mov	 eax, DWORD PTR [r8]
  00168	33 c1		 xor	 eax, ecx
  0016a	89 03		 mov	 DWORD PTR [rbx], eax

; 1131 : 		data[1] ^= whitening[1];

  0016c	8b c2		 mov	 eax, edx
  0016e	41 33 40 04	 xor	 eax, DWORD PTR [r8+4]
  00172	89 43 04	 mov	 DWORD PTR [rbx+4], eax

; 1132 : 		if (blockSize == 16)

  00175	83 fe 10	 cmp	 esi, 16
  00178	75 0d		 jne	 SHORT $LN1@EncryptBuf@2

; 1133 : 		{
; 1134 : 			data[2] ^= whitening[0];

  0017a	41 8b 00	 mov	 eax, DWORD PTR [r8]
  0017d	31 43 08	 xor	 DWORD PTR [rbx+8], eax

; 1135 : 			data[3] ^= whitening[1];

  00180	41 8b 40 04	 mov	 eax, DWORD PTR [r8+4]
  00184	31 43 0c	 xor	 DWORD PTR [rbx+12], eax
$LN1@EncryptBuf@2:

; 1136 : 		}
; 1137 : 
; 1138 : 		data += blockSize / sizeof(*data);

  00187	49 03 dc	 add	 rbx, r12
  0018a	49 83 ed 01	 sub	 r13, 1
  0018e	0f 85 27 ff ff
	ff		 jne	 $LL11@EncryptBuf@2
$LN9@EncryptBuf@2:

; 1139 : 	}
; 1140 : }

  00194	4c 8d 5c 24 40	 lea	 r11, QWORD PTR [rsp+64]
  00199	49 8b 5b 30	 mov	 rbx, QWORD PTR [r11+48]
  0019d	49 8b 6b 38	 mov	 rbp, QWORD PTR [r11+56]
  001a1	49 8b 73 48	 mov	 rsi, QWORD PTR [r11+72]
  001a5	49 8b e3	 mov	 rsp, r11
  001a8	41 5f		 pop	 r15
  001aa	41 5e		 pop	 r14
  001ac	41 5d		 pop	 r13
  001ae	41 5c		 pop	 r12
  001b0	5f		 pop	 rdi
  001b1	c3		 ret	 0
$LN31@EncryptBuf@2:
EncryptBufferCBC ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	DecryptBufferLRW64
;	COMDAT pdata
pdata	SEGMENT
$pdata$DecryptBufferLRW64 DD imagerel $LN26
	DD	imagerel $LN26+292
	DD	imagerel $unwind$DecryptBufferLRW64
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecryptBufferLRW64 DD 0a2319H
	DD	0133414H
	DD	0f0109214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
	DD	imagerel __GSHandlerCheck
	DD	040H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT DecryptBufferLRW64
_TEXT	SEGMENT
i$ = 48
t$ = 56
__$ArrayPad$ = 64
buffer$ = 144
length$ = 152
blockIndex$ = 160
cryptoInfo$ = 168
DecryptBufferLRW64 PROC					; COMDAT

; 966  : {

$LN26:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 967  : 	/* Deprecated/legacy */
; 968  : 
; 969  : 	int cipher = EAGetFirstCipher (cryptoInfo->ea);

  00023	49 63 01	 movsxd	 rax, DWORD PTR [r9]
  00026	4c 8b e1	 mov	 r12, rcx
  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  00030	4d 8b d1	 mov	 r10, r9
  00033	48 8b ea	 mov	 rbp, rdx

; 970  : 	unsigned __int8 *p = buffer;
; 971  : 	unsigned __int8 *ks = cryptoInfo->ks;

  00036	4d 8d 79 08	 lea	 r15, QWORD PTR [r9+8]
  0003a	48 6b c0 2c	 imul	 rax, 44			; 0000002cH
  0003e	44 8b 34 08	 mov	 r14d, DWORD PTR [rax+rcx]

; 972  : 	unsigned __int8 i[8];
; 973  : 	unsigned __int8 t[8];
; 974  : 	unsigned __int64 b;
; 975  : 
; 976  : 	*(unsigned __int64 *)i = BE64(blockIndex);

  00042	49 8b c8	 mov	 rcx, r8
  00045	e8 00 00 00 00	 call	 MirrorBytes64
  0004a	48 8b f8	 mov	 rdi, rax
  0004d	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax

; 977  : 
; 978  : 	if (length % 8)

  00052	40 f6 c5 07	 test	 bpl, 7
  00056	74 1f		 je	 SHORT $LN11@DecryptBuf@3

; 979  : 		TC_THROW_FATAL_EXCEPTION;

  00058	45 33 c9	 xor	 r9d, r9d
  0005b	45 33 c0	 xor	 r8d, r8d
  0005e	ba d3 03 00 00	 mov	 edx, 979		; 000003d3H
  00063	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00067	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00076	cc		 int	 3
$LN11@DecryptBuf@3:

; 980  : 
; 981  : 	for (b = 0; b < length >> 3; b++)

  00077	48 c1 ed 03	 shr	 rbp, 3
  0007b	48 85 ed	 test	 rbp, rbp
  0007e	74 76		 je	 SHORT $LN5@DecryptBuf@3
  00080	40 8a 74 24 37	 mov	 sil, BYTE PTR i$[rsp+7]
  00085	4d 8d aa a8 29
	00 00		 lea	 r13, QWORD PTR [r10+10664]
$LL10@DecryptBuf@3:

; 982  : 	{
; 983  : 		Gf64MulTab (i, t, &cryptoInfo->gf_ctx);

  0008c	48 8d 54 24 38	 lea	 rdx, QWORD PTR t$[rsp]
  00091	48 8d 4c 24 30	 lea	 rcx, QWORD PTR i$[rsp]
  00096	4d 8b c5	 mov	 r8, r13
  00099	e8 00 00 00 00	 call	 Gf64MulTab

; 984  : 		Xor64 ((unsigned __int64 *)p, (unsigned __int64 *)t);

  0009e	48 8b 5c 24 38	 mov	 rbx, QWORD PTR t$[rsp]

; 985  : 
; 986  : 		DecipherBlock (cipher, p, ks);

  000a3	4d 8b c7	 mov	 r8, r15
  000a6	49 31 1c 24	 xor	 QWORD PTR [r12], rbx
  000aa	49 8b d4	 mov	 rdx, r12
  000ad	41 8b ce	 mov	 ecx, r14d
  000b0	e8 00 00 00 00	 call	 DecipherBlock

; 987  : 
; 988  : 		Xor64 ((unsigned __int64 *)p, (unsigned __int64 *)t);

  000b5	49 31 1c 24	 xor	 QWORD PTR [r12], rbx

; 989  : 
; 990  : 		p += 8;

  000b9	49 83 c4 08	 add	 r12, 8

; 991  : 
; 992  : 		if (i[7] != 0xff)

  000bd	40 80 fe ff	 cmp	 sil, 255		; 000000ffH
  000c1	74 0f		 je	 SHORT $LN7@DecryptBuf@3

; 993  : 			i[7]++;

  000c3	40 fe c6	 inc	 sil
  000c6	40 88 74 24 37	 mov	 BYTE PTR i$[rsp+7], sil

; 994  : 		else

  000cb	48 8b 7c 24 30	 mov	 rdi, QWORD PTR i$[rsp]
  000d0	eb 1e		 jmp	 SHORT $LN9@DecryptBuf@3
$LN7@DecryptBuf@3:

; 995  : 			*(unsigned __int64 *)i = BE64 ( BE64(*(unsigned __int64 *)i) + 1 );

  000d2	48 8b cf	 mov	 rcx, rdi
  000d5	e8 00 00 00 00	 call	 MirrorBytes64
  000da	48 8d 48 01	 lea	 rcx, QWORD PTR [rax+1]
  000de	e8 00 00 00 00	 call	 MirrorBytes64
  000e3	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
  000e8	40 8a 74 24 37	 mov	 sil, BYTE PTR i$[rsp+7]
  000ed	48 8b f8	 mov	 rdi, rax
$LN9@DecryptBuf@3:

; 980  : 
; 981  : 	for (b = 0; b < length >> 3; b++)

  000f0	48 83 ed 01	 sub	 rbp, 1
  000f4	75 96		 jne	 SHORT $LL10@DecryptBuf@3
$LN5@DecryptBuf@3:

; 996  : 	}
; 997  : 
; 998  : 	FAST_ERASE64 (t, sizeof(t));

  000f6	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR t$[rsp], 0

; 999  : }

  000ff	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00104	48 33 cc	 xor	 rcx, rsp
  00107	e8 00 00 00 00	 call	 __security_check_cookie
  0010c	48 8b 9c 24 98
	00 00 00	 mov	 rbx, QWORD PTR [rsp+152]
  00114	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00118	41 5f		 pop	 r15
  0011a	41 5e		 pop	 r14
  0011c	41 5d		 pop	 r13
  0011e	41 5c		 pop	 r12
  00120	5f		 pop	 rdi
  00121	5e		 pop	 rsi
  00122	5d		 pop	 rbp
  00123	c3		 ret	 0
$LN25@DecryptBuf@3:
DecryptBufferLRW64 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	DecryptBufferLRW128
;	COMDAT pdata
pdata	SEGMENT
$pdata$DecryptBufferLRW128 DD imagerel $LN40
	DD	imagerel $LN40+480
	DD	imagerel $unwind$DecryptBufferLRW128
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecryptBufferLRW128 DD 0a2319H
	DD	0153414H
	DD	0f010b214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
	DD	imagerel __GSHandlerCheck
	DD	058H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT DecryptBufferLRW128
_TEXT	SEGMENT
cipher$1$ = 48
$T51657 = 56
i$ = 64
t$ = 72
__$ArrayPad$ = 88
buffer$ = 160
length$ = 168
blockIndex$ = 176
cryptoInfo$ = 184
DecryptBufferLRW128 PROC				; COMDAT

; 909  : {

$LN40:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00023	48 8b f2	 mov	 rsi, rdx
  00026	4d 8b e1	 mov	 r12, r9
  00029	48 8b f9	 mov	 rdi, rcx

; 910  : 	/* Deprecated/legacy */
; 911  : 
; 912  : 	int cipher = EAGetFirstCipher (cryptoInfo->ea);

  0002c	49 63 14 24	 movsxd	 rdx, DWORD PTR [r12]
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  00037	4d 8b c8	 mov	 r9, r8
  0003a	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  0003e	48 03 d1	 add	 rdx, rcx

; 913  : 	int cipherCount = EAGetCipherCount (cryptoInfo->ea);

  00041	45 33 c0	 xor	 r8d, r8d
  00044	8b 02		 mov	 eax, DWORD PTR [rdx]
  00046	89 44 24 30	 mov	 DWORD PTR cipher$1$[rsp], eax
$LL22@DecryptBuf@4:
  0004a	8b 02		 mov	 eax, DWORD PTR [rdx]
  0004c	41 ff c0	 inc	 r8d
  0004f	48 83 c2 04	 add	 rdx, 4
  00053	85 c0		 test	 eax, eax
  00055	75 f3		 jne	 SHORT $LL22@DecryptBuf@4

; 914  : 	unsigned __int8 *p = buffer;
; 915  : 	unsigned __int8 *ks = cryptoInfo->ks;
; 916  : 	unsigned __int8 i[8];
; 917  : 	unsigned __int8 t[16];
; 918  : 	unsigned __int64 b;
; 919  : 
; 920  : 	*(unsigned __int64 *)i = BE64(blockIndex);

  00057	49 8b c9	 mov	 rcx, r9
  0005a	45 8d 50 ff	 lea	 r10d, DWORD PTR [r8-1]
  0005e	4d 8d 7c 24 08	 lea	 r15, QWORD PTR [r12+8]
  00063	e8 00 00 00 00	 call	 MirrorBytes64
  00068	48 8b d8	 mov	 rbx, rax
  0006b	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax

; 921  : 
; 922  : 	if (length % 16)

  00070	40 f6 c6 0f	 test	 sil, 15
  00074	74 1f		 je	 SHORT $LN16@DecryptBuf@4

; 923  : 		TC_THROW_FATAL_EXCEPTION;

  00076	45 33 c9	 xor	 r9d, r9d
  00079	45 33 c0	 xor	 r8d, r8d
  0007c	ba 9b 03 00 00	 mov	 edx, 923		; 0000039bH
  00081	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00085	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00094	cc		 int	 3
$LN16@DecryptBuf@4:

; 924  : 
; 925  : 	// Note that the maximum supported volume size is 8589934592 GB  (i.e., 2^63 bytes).
; 926  : 
; 927  : 	for (b = 0; b < length >> 4; b++)

  00095	48 c1 ee 04	 shr	 rsi, 4

; 928  : 	{
; 929  : 		Gf128MulBy64Tab (i, t, &cryptoInfo->gf_ctx);
; 930  : 		Xor128 ((unsigned __int64 *)p, (unsigned __int64 *)t);
; 931  : 
; 932  : 		if (cipherCount > 1)

  00099	49 63 c2	 movsxd	 rax, r10d
  0009c	48 89 44 24 38	 mov	 QWORD PTR $T51657[rsp], rax
  000a1	48 85 f6	 test	 rsi, rsi
  000a4	0f 84 f7 00 00
	00		 je	 $LN5@DecryptBuf@4
  000aa	40 8a 6c 24 47	 mov	 bpl, BYTE PTR i$[rsp+7]
  000af	49 8d 84 24 a8
	29 00 00	 lea	 rax, QWORD PTR [r12+10664]
$LL15@DecryptBuf@4:
  000b7	48 8d 54 24 48	 lea	 rdx, QWORD PTR t$[rsp]
  000bc	48 8d 4c 24 40	 lea	 rcx, QWORD PTR i$[rsp]
  000c1	4c 8b c0	 mov	 r8, rax
  000c4	e8 00 00 00 00	 call	 Gf128MulBy64Tab
  000c9	4c 8b 6c 24 48	 mov	 r13, QWORD PTR t$[rsp]
  000ce	4c 8b 74 24 50	 mov	 r14, QWORD PTR t$[rsp+8]
  000d3	4c 31 2f	 xor	 QWORD PTR [rdi], r13
  000d6	4c 31 77 08	 xor	 QWORD PTR [rdi+8], r14
  000da	48 83 7c 24 38
	01		 cmp	 QWORD PTR $T51657[rsp], 1
  000e0	7e 60		 jle	 SHORT $LN12@DecryptBuf@4

; 933  : 		{
; 934  : 			// Cipher cascade
; 935  : 			ks = cryptoInfo->ks + EAGetKeyScheduleSize (cryptoInfo->ea);

  000e2	41 8b 0c 24	 mov	 ecx, DWORD PTR [r12]
  000e6	e8 00 00 00 00	 call	 EAGetKeyScheduleSize

; 936  : 
; 937  : 			for (cipher = EAGetLastCipher (cryptoInfo->ea);
; 938  : 				cipher != 0;
; 939  : 				cipher = EAGetPreviousCipher (cryptoInfo->ea, cipher))

  000eb	41 8b 0c 24	 mov	 ecx, DWORD PTR [r12]
  000ef	48 63 d0	 movsxd	 rdx, eax
  000f2	4e 8d 7c 22 08	 lea	 r15, QWORD PTR [rdx+r12+8]
  000f7	e8 00 00 00 00	 call	 EAGetLastCipher
  000fc	89 44 24 30	 mov	 DWORD PTR cipher$1$[rsp], eax
  00100	85 c0		 test	 eax, eax
  00102	74 4d		 je	 SHORT $LN8@DecryptBuf@4
  00104	44 8b e8	 mov	 r13d, eax
$LL11@DecryptBuf@4:

; 940  : 			{
; 941  : 				ks -= CipherGetKeyScheduleSize (cipher);

  00107	41 8b cd	 mov	 ecx, r13d
  0010a	e8 00 00 00 00	 call	 CipherGet

; 942  : 				DecipherBlock (cipher, p, ks);

  0010f	48 8b d7	 mov	 rdx, rdi
  00112	48 63 48 18	 movsxd	 rcx, DWORD PTR [rax+24]
  00116	4c 2b f9	 sub	 r15, rcx
  00119	41 8b cd	 mov	 ecx, r13d
  0011c	4d 8b c7	 mov	 r8, r15
  0011f	e8 00 00 00 00	 call	 DecipherBlock
  00124	41 8b 0c 24	 mov	 ecx, DWORD PTR [r12]
  00128	41 8b d5	 mov	 edx, r13d
  0012b	e8 00 00 00 00	 call	 EAGetPreviousCipher
  00130	44 8b e8	 mov	 r13d, eax
  00133	85 c0		 test	 eax, eax
  00135	75 d0		 jne	 SHORT $LL11@DecryptBuf@4

; 943  : 			}
; 944  : 		}
; 945  : 		else

  00137	4c 8b 6c 24 48	 mov	 r13, QWORD PTR t$[rsp]
  0013c	89 44 24 30	 mov	 DWORD PTR cipher$1$[rsp], eax
  00140	eb 0f		 jmp	 SHORT $LN8@DecryptBuf@4
$LN12@DecryptBuf@4:

; 946  : 		{
; 947  : 			DecipherBlock (cipher, p, ks);

  00142	8b 4c 24 30	 mov	 ecx, DWORD PTR cipher$1$[rsp]
  00146	4d 8b c7	 mov	 r8, r15
  00149	48 8b d7	 mov	 rdx, rdi
  0014c	e8 00 00 00 00	 call	 DecipherBlock
$LN8@DecryptBuf@4:

; 948  : 		}
; 949  : 
; 950  : 		Xor128 ((unsigned __int64 *)p, (unsigned __int64 *)t);

  00151	4c 31 2f	 xor	 QWORD PTR [rdi], r13
  00154	4c 31 77 08	 xor	 QWORD PTR [rdi+8], r14

; 951  : 
; 952  : 		p += 16;

  00158	48 83 c7 10	 add	 rdi, 16

; 953  : 
; 954  : 		if (i[7] != 0xff)

  0015c	40 80 fd ff	 cmp	 bpl, 255		; 000000ffH
  00160	74 0f		 je	 SHORT $LN7@DecryptBuf@4

; 955  : 			i[7]++;

  00162	40 fe c5	 inc	 bpl
  00165	40 88 6c 24 47	 mov	 BYTE PTR i$[rsp+7], bpl

; 956  : 		else

  0016a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR i$[rsp]
  0016f	eb 1e		 jmp	 SHORT $LN14@DecryptBuf@4
$LN7@DecryptBuf@4:

; 957  : 			*(unsigned __int64 *)i = BE64 ( BE64(*(unsigned __int64 *)i) + 1 );

  00171	48 8b cb	 mov	 rcx, rbx
  00174	e8 00 00 00 00	 call	 MirrorBytes64
  00179	48 8d 48 01	 lea	 rcx, QWORD PTR [rax+1]
  0017d	e8 00 00 00 00	 call	 MirrorBytes64
  00182	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
  00187	40 8a 6c 24 47	 mov	 bpl, BYTE PTR i$[rsp+7]
  0018c	48 8b d8	 mov	 rbx, rax
$LN14@DecryptBuf@4:
  0018f	48 83 ee 01	 sub	 rsi, 1
  00193	49 8d 84 24 a8
	29 00 00	 lea	 rax, QWORD PTR [r12+10664]
  0019b	0f 85 16 ff ff
	ff		 jne	 $LL15@DecryptBuf@4
$LN5@DecryptBuf@4:

; 958  : 	}
; 959  : 
; 960  : 	FAST_ERASE64 (t, sizeof(t));

  001a1	48 8d 44 24 48	 lea	 rax, QWORD PTR t$[rsp]
  001a6	b9 02 00 00 00	 mov	 ecx, 2
$LL2@DecryptBuf@4:
  001ab	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  001b2	48 83 c0 08	 add	 rax, 8
  001b6	83 e9 01	 sub	 ecx, 1
  001b9	75 f0		 jne	 SHORT $LL2@DecryptBuf@4

; 961  : }

  001bb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001c0	48 33 cc	 xor	 rcx, rsp
  001c3	e8 00 00 00 00	 call	 __security_check_cookie
  001c8	48 8b 9c 24 a8
	00 00 00	 mov	 rbx, QWORD PTR [rsp+168]
  001d0	48 83 c4 60	 add	 rsp, 96			; 00000060H
  001d4	41 5f		 pop	 r15
  001d6	41 5e		 pop	 r14
  001d8	41 5d		 pop	 r13
  001da	41 5c		 pop	 r12
  001dc	5f		 pop	 rdi
  001dd	5e		 pop	 rsi
  001de	5d		 pop	 rbp
  001df	c3		 ret	 0
$LN39@DecryptBuf@4:
DecryptBufferLRW128 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	EncryptBufferLRW64
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptBufferLRW64 DD imagerel $LN26
	DD	imagerel $LN26+292
	DD	imagerel $unwind$EncryptBufferLRW64
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptBufferLRW64 DD 0a2319H
	DD	0133414H
	DD	0f0109214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
	DD	imagerel __GSHandlerCheck
	DD	040H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EncryptBufferLRW64
_TEXT	SEGMENT
i$ = 48
t$ = 56
__$ArrayPad$ = 64
buffer$ = 144
length$ = 152
blockIndex$ = 160
cryptoInfo$ = 168
EncryptBufferLRW64 PROC					; COMDAT

; 872  : {

$LN26:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 873  : 	/* Deprecated/legacy */
; 874  : 
; 875  : 	int cipher = EAGetFirstCipher (cryptoInfo->ea);

  00023	49 63 01	 movsxd	 rax, DWORD PTR [r9]
  00026	4c 8b e1	 mov	 r12, rcx
  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  00030	4d 8b d1	 mov	 r10, r9
  00033	48 8b ea	 mov	 rbp, rdx

; 876  : 	unsigned __int8 *p = buffer;
; 877  : 	unsigned __int8 *ks = cryptoInfo->ks;

  00036	4d 8d 79 08	 lea	 r15, QWORD PTR [r9+8]
  0003a	48 6b c0 2c	 imul	 rax, 44			; 0000002cH
  0003e	44 8b 34 08	 mov	 r14d, DWORD PTR [rax+rcx]

; 878  : 	unsigned __int8 i[8];
; 879  : 	unsigned __int8 t[8];
; 880  : 	unsigned __int64 b;
; 881  : 
; 882  : 	*(unsigned __int64 *)i = BE64(blockIndex);

  00042	49 8b c8	 mov	 rcx, r8
  00045	e8 00 00 00 00	 call	 MirrorBytes64
  0004a	48 8b f8	 mov	 rdi, rax
  0004d	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax

; 883  : 
; 884  : 	if (length % 8)

  00052	40 f6 c5 07	 test	 bpl, 7
  00056	74 1f		 je	 SHORT $LN11@EncryptBuf@3

; 885  : 		TC_THROW_FATAL_EXCEPTION;

  00058	45 33 c9	 xor	 r9d, r9d
  0005b	45 33 c0	 xor	 r8d, r8d
  0005e	ba 75 03 00 00	 mov	 edx, 885		; 00000375H
  00063	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00067	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00076	cc		 int	 3
$LN11@EncryptBuf@3:

; 886  : 
; 887  : 	for (b = 0; b < length >> 3; b++)

  00077	48 c1 ed 03	 shr	 rbp, 3
  0007b	48 85 ed	 test	 rbp, rbp
  0007e	74 76		 je	 SHORT $LN5@EncryptBuf@3
  00080	40 8a 74 24 37	 mov	 sil, BYTE PTR i$[rsp+7]
  00085	4d 8d aa a8 29
	00 00		 lea	 r13, QWORD PTR [r10+10664]
$LL10@EncryptBuf@3:

; 888  : 	{
; 889  : 		Gf64MulTab (i, t, &cryptoInfo->gf_ctx);

  0008c	48 8d 54 24 38	 lea	 rdx, QWORD PTR t$[rsp]
  00091	48 8d 4c 24 30	 lea	 rcx, QWORD PTR i$[rsp]
  00096	4d 8b c5	 mov	 r8, r13
  00099	e8 00 00 00 00	 call	 Gf64MulTab

; 890  : 		Xor64 ((unsigned __int64 *)p, (unsigned __int64 *)t);

  0009e	48 8b 5c 24 38	 mov	 rbx, QWORD PTR t$[rsp]

; 891  : 
; 892  : 		EncipherBlock (cipher, p, ks);

  000a3	4d 8b c7	 mov	 r8, r15
  000a6	49 31 1c 24	 xor	 QWORD PTR [r12], rbx
  000aa	49 8b d4	 mov	 rdx, r12
  000ad	41 8b ce	 mov	 ecx, r14d
  000b0	e8 00 00 00 00	 call	 EncipherBlock

; 893  : 
; 894  : 		Xor64 ((unsigned __int64 *)p, (unsigned __int64 *)t);

  000b5	49 31 1c 24	 xor	 QWORD PTR [r12], rbx

; 895  : 
; 896  : 		p += 8;

  000b9	49 83 c4 08	 add	 r12, 8

; 897  : 
; 898  : 		if (i[7] != 0xff)

  000bd	40 80 fe ff	 cmp	 sil, 255		; 000000ffH
  000c1	74 0f		 je	 SHORT $LN7@EncryptBuf@3

; 899  : 			i[7]++;

  000c3	40 fe c6	 inc	 sil
  000c6	40 88 74 24 37	 mov	 BYTE PTR i$[rsp+7], sil

; 900  : 		else

  000cb	48 8b 7c 24 30	 mov	 rdi, QWORD PTR i$[rsp]
  000d0	eb 1e		 jmp	 SHORT $LN9@EncryptBuf@3
$LN7@EncryptBuf@3:

; 901  : 			*(unsigned __int64 *)i = BE64 ( BE64(*(unsigned __int64 *)i) + 1 );

  000d2	48 8b cf	 mov	 rcx, rdi
  000d5	e8 00 00 00 00	 call	 MirrorBytes64
  000da	48 8d 48 01	 lea	 rcx, QWORD PTR [rax+1]
  000de	e8 00 00 00 00	 call	 MirrorBytes64
  000e3	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
  000e8	40 8a 74 24 37	 mov	 sil, BYTE PTR i$[rsp+7]
  000ed	48 8b f8	 mov	 rdi, rax
$LN9@EncryptBuf@3:

; 886  : 
; 887  : 	for (b = 0; b < length >> 3; b++)

  000f0	48 83 ed 01	 sub	 rbp, 1
  000f4	75 96		 jne	 SHORT $LL10@EncryptBuf@3
$LN5@EncryptBuf@3:

; 902  : 	}
; 903  : 
; 904  : 	FAST_ERASE64 (t, sizeof(t));

  000f6	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR t$[rsp], 0

; 905  : }

  000ff	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00104	48 33 cc	 xor	 rcx, rsp
  00107	e8 00 00 00 00	 call	 __security_check_cookie
  0010c	48 8b 9c 24 98
	00 00 00	 mov	 rbx, QWORD PTR [rsp+152]
  00114	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00118	41 5f		 pop	 r15
  0011a	41 5e		 pop	 r14
  0011c	41 5d		 pop	 r13
  0011e	41 5c		 pop	 r12
  00120	5f		 pop	 rdi
  00121	5e		 pop	 rsi
  00122	5d		 pop	 rbp
  00123	c3		 ret	 0
$LN25@EncryptBuf@3:
EncryptBufferLRW64 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	EncryptBufferLRW128
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptBufferLRW128 DD imagerel $LN42
	DD	imagerel $LN42+477
	DD	imagerel $unwind$EncryptBufferLRW128
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptBufferLRW128 DD 0a2319H
	DD	0153414H
	DD	0f010b214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
	DD	imagerel __GSHandlerCheck
	DD	058H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EncryptBufferLRW128
_TEXT	SEGMENT
cipher$1$ = 48
$T51767 = 56
i$ = 64
t$ = 72
__$ArrayPad$ = 88
buffer$ = 160
length$ = 168
blockIndex$ = 176
cryptoInfo$ = 184
EncryptBufferLRW128 PROC				; COMDAT

; 817  : {

$LN42:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00023	48 8b f2	 mov	 rsi, rdx
  00026	4d 8b e1	 mov	 r12, r9
  00029	48 8b f9	 mov	 rdi, rcx

; 818  : 	/* Deprecated/legacy */
; 819  : 
; 820  : 	int cipher = EAGetFirstCipher (cryptoInfo->ea);

  0002c	49 63 14 24	 movsxd	 rdx, DWORD PTR [r12]
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  00037	4d 8b c8	 mov	 r9, r8
  0003a	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  0003e	48 03 d1	 add	 rdx, rcx

; 821  : 	int cipherCount = EAGetCipherCount (cryptoInfo->ea);

  00041	45 33 c0	 xor	 r8d, r8d
  00044	8b 02		 mov	 eax, DWORD PTR [rdx]
  00046	89 44 24 30	 mov	 DWORD PTR cipher$1$[rsp], eax
$LL22@EncryptBuf@4:
  0004a	8b 02		 mov	 eax, DWORD PTR [rdx]
  0004c	41 ff c0	 inc	 r8d
  0004f	48 83 c2 04	 add	 rdx, 4
  00053	85 c0		 test	 eax, eax
  00055	75 f3		 jne	 SHORT $LL22@EncryptBuf@4

; 822  : 	unsigned __int8 *p = buffer;
; 823  : 	unsigned __int8 *ks = cryptoInfo->ks;
; 824  : 	unsigned __int8 i[8];
; 825  : 	unsigned __int8 t[16];
; 826  : 	unsigned __int64 b;
; 827  : 
; 828  : 	*(unsigned __int64 *)i = BE64(blockIndex);

  00057	49 8b c9	 mov	 rcx, r9
  0005a	45 8d 50 ff	 lea	 r10d, DWORD PTR [r8-1]
  0005e	4d 8d 7c 24 08	 lea	 r15, QWORD PTR [r12+8]
  00063	e8 00 00 00 00	 call	 MirrorBytes64
  00068	48 8b d8	 mov	 rbx, rax
  0006b	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax

; 829  : 
; 830  : 	if (length % 16)

  00070	40 f6 c6 0f	 test	 sil, 15
  00074	74 1f		 je	 SHORT $LN16@EncryptBuf@4

; 831  : 		TC_THROW_FATAL_EXCEPTION;

  00076	45 33 c9	 xor	 r9d, r9d
  00079	45 33 c0	 xor	 r8d, r8d
  0007c	ba 3f 03 00 00	 mov	 edx, 831		; 0000033fH
  00081	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00085	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00094	cc		 int	 3
$LN16@EncryptBuf@4:

; 832  : 
; 833  : 	// Note that the maximum supported volume size is 8589934592 GB  (i.e., 2^63 bytes).
; 834  : 
; 835  : 	for (b = 0; b < length >> 4; b++)

  00095	48 c1 ee 04	 shr	 rsi, 4

; 836  : 	{
; 837  : 		Gf128MulBy64Tab (i, t, &cryptoInfo->gf_ctx);
; 838  : 		Xor128 ((unsigned __int64 *)p, (unsigned __int64 *)t);
; 839  : 
; 840  : 		if (cipherCount > 1)

  00099	49 63 c2	 movsxd	 rax, r10d
  0009c	48 89 44 24 38	 mov	 QWORD PTR $T51767[rsp], rax
  000a1	48 85 f6	 test	 rsi, rsi
  000a4	0f 84 f4 00 00
	00		 je	 $LN5@EncryptBuf@4
  000aa	40 8a 6c 24 47	 mov	 bpl, BYTE PTR i$[rsp+7]
  000af	49 8d 84 24 a8
	29 00 00	 lea	 rax, QWORD PTR [r12+10664]
$LL15@EncryptBuf@4:
  000b7	48 8d 54 24 48	 lea	 rdx, QWORD PTR t$[rsp]
  000bc	48 8d 4c 24 40	 lea	 rcx, QWORD PTR i$[rsp]
  000c1	4c 8b c0	 mov	 r8, rax
  000c4	e8 00 00 00 00	 call	 Gf128MulBy64Tab
  000c9	4c 8b 6c 24 48	 mov	 r13, QWORD PTR t$[rsp]
  000ce	4c 8b 74 24 50	 mov	 r14, QWORD PTR t$[rsp+8]
  000d3	4c 31 2f	 xor	 QWORD PTR [rdi], r13
  000d6	4c 31 77 08	 xor	 QWORD PTR [rdi+8], r14
  000da	48 83 7c 24 38
	01		 cmp	 QWORD PTR $T51767[rsp], 1
  000e0	7e 5d		 jle	 SHORT $LN12@EncryptBuf@4

; 841  : 		{
; 842  : 			// Cipher cascade
; 843  : 			for (cipher = EAGetFirstCipher (cryptoInfo->ea);
; 844  : 				cipher != 0;
; 845  : 				cipher = EAGetNextCipher (cryptoInfo->ea, cipher))

  000e2	49 63 04 24	 movsxd	 rax, DWORD PTR [r12]
  000e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  000ed	48 6b c0 2c	 imul	 rax, 44			; 0000002cH
  000f1	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]
  000f4	89 44 24 30	 mov	 DWORD PTR cipher$1$[rsp], eax
  000f8	85 c0		 test	 eax, eax
  000fa	74 3c		 je	 SHORT $LN9@EncryptBuf@4
  000fc	44 8b e8	 mov	 r13d, eax
$LL11@EncryptBuf@4:

; 846  : 			{
; 847  : 				EncipherBlock (cipher, p, ks);

  000ff	4d 8b c7	 mov	 r8, r15
  00102	48 8b d7	 mov	 rdx, rdi
  00105	41 8b cd	 mov	 ecx, r13d
  00108	e8 00 00 00 00	 call	 EncipherBlock

; 848  : 				ks += CipherGetKeyScheduleSize (cipher);

  0010d	41 8b cd	 mov	 ecx, r13d
  00110	e8 00 00 00 00	 call	 CipherGet
  00115	41 8b d5	 mov	 edx, r13d
  00118	48 63 48 18	 movsxd	 rcx, DWORD PTR [rax+24]
  0011c	4c 03 f9	 add	 r15, rcx
  0011f	41 8b 0c 24	 mov	 ecx, DWORD PTR [r12]
  00123	e8 00 00 00 00	 call	 EAGetNextCipher
  00128	44 8b e8	 mov	 r13d, eax
  0012b	85 c0		 test	 eax, eax
  0012d	75 d0		 jne	 SHORT $LL11@EncryptBuf@4
  0012f	4c 8b 6c 24 48	 mov	 r13, QWORD PTR t$[rsp]
  00134	89 44 24 30	 mov	 DWORD PTR cipher$1$[rsp], eax
$LN9@EncryptBuf@4:

; 849  : 			}
; 850  : 			ks = cryptoInfo->ks;

  00138	4d 8d 7c 24 08	 lea	 r15, QWORD PTR [r12+8]

; 851  : 		}
; 852  : 		else

  0013d	eb 0f		 jmp	 SHORT $LN8@EncryptBuf@4
$LN12@EncryptBuf@4:

; 853  : 		{
; 854  : 			EncipherBlock (cipher, p, ks);

  0013f	8b 4c 24 30	 mov	 ecx, DWORD PTR cipher$1$[rsp]
  00143	4d 8b c7	 mov	 r8, r15
  00146	48 8b d7	 mov	 rdx, rdi
  00149	e8 00 00 00 00	 call	 EncipherBlock
$LN8@EncryptBuf@4:

; 855  : 		}
; 856  : 
; 857  : 		Xor128 ((unsigned __int64 *)p, (unsigned __int64 *)t);

  0014e	4c 31 2f	 xor	 QWORD PTR [rdi], r13
  00151	4c 31 77 08	 xor	 QWORD PTR [rdi+8], r14

; 858  : 
; 859  : 		p += 16;

  00155	48 83 c7 10	 add	 rdi, 16

; 860  : 
; 861  : 		if (i[7] != 0xff)

  00159	40 80 fd ff	 cmp	 bpl, 255		; 000000ffH
  0015d	74 0f		 je	 SHORT $LN7@EncryptBuf@4

; 862  : 			i[7]++;

  0015f	40 fe c5	 inc	 bpl
  00162	40 88 6c 24 47	 mov	 BYTE PTR i$[rsp+7], bpl

; 863  : 		else

  00167	48 8b 5c 24 40	 mov	 rbx, QWORD PTR i$[rsp]
  0016c	eb 1e		 jmp	 SHORT $LN14@EncryptBuf@4
$LN7@EncryptBuf@4:

; 864  : 			*(unsigned __int64 *)i = BE64 ( BE64(*(unsigned __int64 *)i) + 1 );

  0016e	48 8b cb	 mov	 rcx, rbx
  00171	e8 00 00 00 00	 call	 MirrorBytes64
  00176	48 8d 48 01	 lea	 rcx, QWORD PTR [rax+1]
  0017a	e8 00 00 00 00	 call	 MirrorBytes64
  0017f	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
  00184	40 8a 6c 24 47	 mov	 bpl, BYTE PTR i$[rsp+7]
  00189	48 8b d8	 mov	 rbx, rax
$LN14@EncryptBuf@4:
  0018c	48 83 ee 01	 sub	 rsi, 1
  00190	49 8d 84 24 a8
	29 00 00	 lea	 rax, QWORD PTR [r12+10664]
  00198	0f 85 19 ff ff
	ff		 jne	 $LL15@EncryptBuf@4
$LN5@EncryptBuf@4:

; 865  : 	}
; 866  : 
; 867  : 	FAST_ERASE64 (t, sizeof(t));

  0019e	48 8d 44 24 48	 lea	 rax, QWORD PTR t$[rsp]
  001a3	b9 02 00 00 00	 mov	 ecx, 2
$LL2@EncryptBuf@4:
  001a8	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  001af	48 83 c0 08	 add	 rax, 8
  001b3	83 e9 01	 sub	 ecx, 1
  001b6	75 f0		 jne	 SHORT $LL2@EncryptBuf@4

; 868  : }

  001b8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001bd	48 33 cc	 xor	 rcx, rsp
  001c0	e8 00 00 00 00	 call	 __security_check_cookie
  001c5	48 8b 9c 24 a8
	00 00 00	 mov	 rbx, QWORD PTR [rsp+168]
  001cd	48 83 c4 60	 add	 rsp, 96			; 00000060H
  001d1	41 5f		 pop	 r15
  001d3	41 5e		 pop	 r14
  001d5	41 5d		 pop	 r13
  001d7	41 5c		 pop	 r12
  001d9	5f		 pop	 rdi
  001da	5e		 pop	 rsi
  001db	5d		 pop	 rbp
  001dc	c3		 ret	 0
$LN41@EncryptBuf@4:
EncryptBufferLRW128 ENDP
_TEXT	ENDS
PUBLIC	EAGetLargestKeyForMode
;	COMDAT pdata
pdata	SEGMENT
$pdata$EAGetLargestKeyForMode DD imagerel $LN15
	DD	imagerel $LN15+121
	DD	imagerel $unwind$EAGetLargestKeyForMode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EAGetLargestKeyForMode DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EAGetLargestKeyForMode
_TEXT	SEGMENT
mode$ = 48
EAGetLargestKeyForMode PROC				; COMDAT

; 591  : {

$LN15:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 592  : 	int ea, key = 0;

  00014	33 ff		 xor	 edi, edi
  00016	8b e9		 mov	 ebp, ecx

; 593  : 
; 594  : 	for (ea = EAGetFirst (); ea != 0; ea = EAGetNext (ea))

  00018	8d 5f 01	 lea	 ebx, QWORD PTR [rdi+1]
  0001b	48 8b f3	 mov	 rsi, rbx
$LL11@EAGetLarge:

; 595  : 	{
; 596  : 		if (!EAIsModeSupported (ea, mode))

  0001e	8b d5		 mov	 edx, ebp
  00020	8b cb		 mov	 ecx, ebx
  00022	e8 00 00 00 00	 call	 EAIsModeSupported
  00027	85 c0		 test	 eax, eax
  00029	74 14		 je	 SHORT $LN4@EAGetLarge

; 597  : 			continue;
; 598  : 
; 599  : 		if (EAGetKeySize (ea) >= key)

  0002b	8b cb		 mov	 ecx, ebx
  0002d	e8 00 00 00 00	 call	 EAGetKeySize
  00032	3b c7		 cmp	 eax, edi
  00034	7c 09		 jl	 SHORT $LN4@EAGetLarge

; 600  : 			key = EAGetKeySize (ea);

  00036	8b cb		 mov	 ecx, ebx
  00038	e8 00 00 00 00	 call	 EAGetKeySize
  0003d	8b f8		 mov	 edi, eax
$LN4@EAGetLarge:
  0003f	48 ff c6	 inc	 rsi
  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:EncryptionAlgorithms
  00049	48 8b ce	 mov	 rcx, rsi
  0004c	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  00050	83 3c 11 00	 cmp	 DWORD PTR [rcx+rdx], 0
  00054	74 04		 je	 SHORT $LN10@EAGetLarge

; 593  : 
; 594  : 	for (ea = EAGetFirst (); ea != 0; ea = EAGetNext (ea))

  00056	ff c3		 inc	 ebx
  00058	eb 04		 jmp	 SHORT $LN14@EAGetLarge
$LN10@EAGetLarge:
  0005a	33 db		 xor	 ebx, ebx
  0005c	33 f6		 xor	 esi, esi
$LN14@EAGetLarge:
  0005e	85 db		 test	 ebx, ebx
  00060	75 bc		 jne	 SHORT $LL11@EAGetLarge

; 601  : 	}
; 602  : 	return key;
; 603  : }

  00062	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00067	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0006c	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00071	8b c7		 mov	 eax, edi
  00073	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00077	5f		 pop	 rdi
  00078	c3		 ret	 0
EAGetLargestKeyForMode ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	EAGetByName
;	COMDAT pdata
pdata	SEGMENT
$pdata$EAGetByName DD imagerel $LN15
	DD	imagerel $LN15+164
	DD	imagerel $unwind$EAGetByName
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EAGetByName DD 092919H
	DD	01a6417H
	DD	0195417H
	DD	0183417H
	DD	0160117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EAGetByName
_TEXT	SEGMENT
n$ = 32
__$ArrayPad$ = 160
name$ = 192
EAGetByName PROC					; COMDAT

; 473  : {

$LN15:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 474  : 	int ea = EAGetFirst ();

  00029	bb 01 00 00 00	 mov	 ebx, 1
  0002e	48 8b eb	 mov	 rbp, rbx
$LL4@EAGetByNam:

; 475  : 	char n[128];
; 476  : 
; 477  : 	do
; 478  : 	{
; 479  : 		EAGetName (n, ea);

  00031	48 8d 4c 24 20	 lea	 rcx, QWORD PTR n$[rsp]
  00036	8b d3		 mov	 edx, ebx
  00038	e8 00 00 00 00	 call	 EAGetName

; 480  : 		if (strcmp (n, name) == 0)

  0003d	48 8d 74 24 20	 lea	 rsi, QWORD PTR n$[rsp]
  00042	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_03BKNEFOAH@AES?$AA@FNODOBFM@
  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	f3 a6		 repe cmpsb
  00050	74 27		 je	 SHORT $LN13@EAGetByNam

; 482  : 	}
; 483  : 	while (ea = EAGetNext (ea));

  00052	48 ff c5	 inc	 rbp
  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:EncryptionAlgorithms
  0005c	48 8b c5	 mov	 rax, rbp
  0005f	48 6b c0 2c	 imul	 rax, 44			; 0000002cH
  00063	83 3c 10 00	 cmp	 DWORD PTR [rax+rdx], 0
  00067	74 04		 je	 SHORT $LN9@EAGetByNam
  00069	ff c3		 inc	 ebx
  0006b	eb 04		 jmp	 SHORT $LN10@EAGetByNam
$LN9@EAGetByNam:
  0006d	33 db		 xor	 ebx, ebx
  0006f	33 ed		 xor	 ebp, ebp
$LN10@EAGetByNam:
  00071	85 db		 test	 ebx, ebx
  00073	75 bc		 jne	 SHORT $LL4@EAGetByNam

; 484  : 
; 485  : 	return 0;

  00075	33 c0		 xor	 eax, eax
  00077	eb 02		 jmp	 SHORT $LN5@EAGetByNam
$LN13@EAGetByNam:

; 481  : 			return ea;

  00079	8b c3		 mov	 eax, ebx
$LN5@EAGetByNam:

; 486  : }

  0007b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00083	48 33 cc	 xor	 rcx, rsp
  00086	e8 00 00 00 00	 call	 __security_check_cookie
  0008b	4c 8d 9c 24 b0
	00 00 00	 lea	 r11, QWORD PTR [rsp+176]
  00093	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00097	49 8b 6b 18	 mov	 rbp, QWORD PTR [r11+24]
  0009b	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  0009f	49 8b e3	 mov	 rsp, r11
  000a2	5f		 pop	 rdi
  000a3	c3		 ret	 0
EAGetByName ENDP
_TEXT	ENDS
PUBLIC	EAInit
;	COMDAT pdata
pdata	SEGMENT
$pdata$EAInit DD imagerel $LN19
	DD	imagerel $LN19+168
	DD	imagerel $unwind$EAInit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EAInit DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0c0153219H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EAInit
_TEXT	SEGMENT
ea$ = 48
key$ = 56
ks$ = 64
EAInit	PROC						; COMDAT

; 383  : {

$LN19:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 54		 push	 r12
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 384  : 	int c, retVal = ERR_SUCCESS;

  00019	33 db		 xor	 ebx, ebx
  0001b	49 8b e8	 mov	 rbp, r8
  0001e	4c 8b e2	 mov	 r12, rdx
  00021	48 63 f9	 movsxd	 rdi, ecx

; 385  : 
; 386  : 	if (ea == 0)

  00024	85 c9		 test	 ecx, ecx
  00026	75 07		 jne	 SHORT $LN8@EAInit
$LN2@EAInit:

; 387  : 		return ERR_CIPHER_INIT_FAILURE;

  00028	b8 11 00 00 00	 mov	 eax, 17
  0002d	eb 5e		 jmp	 SHORT $LN9@EAInit
$LN8@EAInit:

; 388  : 
; 389  : 	for (c = EAGetFirstCipher (ea); c != 0; c = EAGetNextCipher (ea, c))

  0002f	48 8b c7	 mov	 rax, rdi
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  00039	48 6b c0 2c	 imul	 rax, 44			; 0000002cH
  0003d	8b 34 08	 mov	 esi, DWORD PTR [rax+rcx]
  00040	85 f6		 test	 esi, esi
  00042	74 47		 je	 SHORT $LN5@EAInit
$LL7@EAInit:

; 390  : 	{
; 391  : 		switch (CipherInit (c, key, ks))

  00044	4c 8b c5	 mov	 r8, rbp
  00047	49 8b d4	 mov	 rdx, r12
  0004a	8b ce		 mov	 ecx, esi
  0004c	e8 00 00 00 00	 call	 CipherInit
  00051	44 8b d8	 mov	 r11d, eax
  00054	41 83 eb 11	 sub	 r11d, 17
  00058	74 ce		 je	 SHORT $LN2@EAInit
  0005a	41 83 fb 01	 cmp	 r11d, 1
  0005e	75 04		 jne	 SHORT $LN3@EAInit

; 392  : 		{
; 393  : 		case ERR_CIPHER_INIT_FAILURE:
; 394  : 			return ERR_CIPHER_INIT_FAILURE;
; 395  : 
; 396  : 		case ERR_CIPHER_INIT_WEAK_KEY:
; 397  : 			retVal = ERR_CIPHER_INIT_WEAK_KEY;		// Non-fatal error

  00060	41 8d 5b 11	 lea	 ebx, QWORD PTR [r11+17]
$LN3@EAInit:

; 398  : 			break;
; 399  : 		}
; 400  : 
; 401  : 		key += CipherGetKeySize (c);

  00064	8b ce		 mov	 ecx, esi
  00066	e8 00 00 00 00	 call	 CipherGet
  0006b	8b d6		 mov	 edx, esi
  0006d	48 8b c8	 mov	 rcx, rax
  00070	48 63 40 14	 movsxd	 rax, DWORD PTR [rax+20]
  00074	4c 03 e0	 add	 r12, rax

; 402  : 		ks += CipherGetKeyScheduleSize (c);

  00077	48 63 41 18	 movsxd	 rax, DWORD PTR [rcx+24]
  0007b	8b cf		 mov	 ecx, edi
  0007d	48 03 e8	 add	 rbp, rax
  00080	e8 00 00 00 00	 call	 EAGetNextCipher
  00085	8b f0		 mov	 esi, eax
  00087	85 c0		 test	 eax, eax
  00089	75 b9		 jne	 SHORT $LL7@EAInit
$LN5@EAInit:

; 403  : 	}
; 404  : 	return retVal;

  0008b	8b c3		 mov	 eax, ebx
$LN9@EAInit:

; 405  : }

  0008d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00092	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00097	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0009c	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000a1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a5	41 5c		 pop	 r12
  000a7	c3		 ret	 0
EAInit	ENDP
_TEXT	ENDS
PUBLIC	DecipherBlocks
;	COMDAT pdata
pdata	SEGMENT
$pdata$DecipherBlocks DD imagerel $LN16
	DD	imagerel $LN16+166
	DD	imagerel $unwind$DecipherBlocks
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecipherBlocks DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0c0153219H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT DecipherBlocks
_TEXT	SEGMENT
cipher$ = 48
dataPtr$ = 56
ks$ = 64
blockCount$ = 72
DecipherBlocks PROC					; COMDAT

; 272  : {

$LN16:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 54		 push	 r12
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00019	49 8b d9	 mov	 rbx, r9
  0001c	4d 8b e0	 mov	 r12, r8
  0001f	48 8b fa	 mov	 rdi, rdx
  00022	8b f1		 mov	 esi, ecx

; 273  : 	byte *data = dataPtr;
; 274  : #if defined (TC_WINDOWS_DRIVER) && !defined (_WIN64)
; 275  : 	KFLOATING_SAVE floatingPointState;
; 276  : #endif
; 277  : 
; 278  : 	if (cipher == AES
; 279  : 		&& (blockCount & (32 - 1)) == 0
; 280  : 		&& IsAesHwCpuSupported()
; 281  : #if defined (TC_WINDOWS_DRIVER) && !defined (_WIN64)
; 282  : 		&& NT_SUCCESS (KeSaveFloatingPointState (&floatingPointState))
; 283  : #endif
; 284  : 		)

  00024	83 f9 01	 cmp	 ecx, 1
  00027	75 3c		 jne	 SHORT $LN6@DecipherBl@2
  00029	f6 c3 1f	 test	 bl, 31
  0002c	75 37		 jne	 SHORT $LN6@DecipherBl@2
  0002e	e8 00 00 00 00	 call	 IsAesHwCpuSupported
  00033	85 c0		 test	 eax, eax
  00035	74 2e		 je	 SHORT $LN6@DecipherBl@2

; 285  : 	{
; 286  : 		while (blockCount > 0)

  00037	48 85 db	 test	 rbx, rbx
  0003a	74 4f		 je	 SHORT $LN14@DecipherBl@2
  0003c	48 ff cb	 dec	 rbx
  0003f	48 c1 eb 05	 shr	 rbx, 5
  00043	48 ff c3	 inc	 rbx
$LL5@DecipherBl@2:

; 287  : 		{
; 288  : 			aes_hw_cpu_decrypt_32_blocks ((byte *) ks + sizeof (aes_encrypt_ctx), data);

  00046	49 8d 8c 24 f4
	00 00 00	 lea	 rcx, QWORD PTR [r12+244]
  0004e	48 8b d7	 mov	 rdx, rdi
  00051	e8 00 00 00 00	 call	 aes_hw_cpu_decrypt_32_blocks

; 289  : 
; 290  : 			data += 32 * 16;

  00056	48 81 c7 00 02
	00 00		 add	 rdi, 512		; 00000200H
  0005d	48 83 eb 01	 sub	 rbx, 1
  00061	75 e3		 jne	 SHORT $LL5@DecipherBl@2

; 291  : 			blockCount -= 32;
; 292  : 		}
; 293  : 
; 294  : #if defined (TC_WINDOWS_DRIVER) && !defined (_WIN64)
; 295  : 		KeRestoreFloatingPointState (&floatingPointState);
; 296  : #endif
; 297  : 	}
; 298  : 	else

  00063	eb 26		 jmp	 SHORT $LN14@DecipherBl@2
$LN6@DecipherBl@2:

; 299  : 	{
; 300  : 		size_t blockSize = CipherGetBlockSize (cipher);

  00065	8b ce		 mov	 ecx, esi
  00067	e8 00 00 00 00	 call	 CipherGet
  0006c	48 63 68 10	 movsxd	 rbp, DWORD PTR [rax+16]

; 301  : 		while (blockCount-- > 0)

  00070	48 85 db	 test	 rbx, rbx
  00073	74 16		 je	 SHORT $LN14@DecipherBl@2
$LL2@DecipherBl@2:

; 302  : 		{
; 303  : 			DecipherBlock (cipher, data, ks);

  00075	4d 8b c4	 mov	 r8, r12
  00078	48 8b d7	 mov	 rdx, rdi
  0007b	8b ce		 mov	 ecx, esi
  0007d	e8 00 00 00 00	 call	 DecipherBlock

; 304  : 			data += blockSize;

  00082	48 03 fd	 add	 rdi, rbp
  00085	48 83 eb 01	 sub	 rbx, 1
  00089	75 ea		 jne	 SHORT $LL2@DecipherBl@2
$LN14@DecipherBl@2:

; 305  : 		}
; 306  : 	}
; 307  : }

  0008b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00090	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00095	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0009a	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0009f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a3	41 5c		 pop	 r12
  000a5	c3		 ret	 0
DecipherBlocks ENDP
_TEXT	ENDS
PUBLIC	EncipherBlocks
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncipherBlocks DD imagerel $LN16
	DD	imagerel $LN16+161
	DD	imagerel $unwind$EncipherBlocks
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncipherBlocks DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0c0153219H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EncipherBlocks
_TEXT	SEGMENT
cipher$ = 48
dataPtr$ = 56
ks$ = 64
blockCount$ = 72
EncipherBlocks PROC					; COMDAT

; 203  : {

$LN16:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 54		 push	 r12
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00019	49 8b d9	 mov	 rbx, r9
  0001c	4d 8b e0	 mov	 r12, r8
  0001f	48 8b fa	 mov	 rdi, rdx
  00022	8b f1		 mov	 esi, ecx

; 204  : 	byte *data = dataPtr;
; 205  : #if defined (TC_WINDOWS_DRIVER) && !defined (_WIN64)
; 206  : 	KFLOATING_SAVE floatingPointState;
; 207  : #endif
; 208  : 
; 209  : 	if (cipher == AES
; 210  : 		&& (blockCount & (32 - 1)) == 0
; 211  : 		&& IsAesHwCpuSupported()
; 212  : #if defined (TC_WINDOWS_DRIVER) && !defined (_WIN64)
; 213  : 		&& NT_SUCCESS (KeSaveFloatingPointState (&floatingPointState))
; 214  : #endif
; 215  : 		)

  00024	83 f9 01	 cmp	 ecx, 1
  00027	75 37		 jne	 SHORT $LN6@EncipherBl@2
  00029	f6 c3 1f	 test	 bl, 31
  0002c	75 32		 jne	 SHORT $LN6@EncipherBl@2
  0002e	e8 00 00 00 00	 call	 IsAesHwCpuSupported
  00033	85 c0		 test	 eax, eax
  00035	74 29		 je	 SHORT $LN6@EncipherBl@2

; 216  : 	{
; 217  : 		while (blockCount > 0)

  00037	48 85 db	 test	 rbx, rbx
  0003a	74 4a		 je	 SHORT $LN14@EncipherBl@2
  0003c	48 ff cb	 dec	 rbx
  0003f	48 c1 eb 05	 shr	 rbx, 5
  00043	48 ff c3	 inc	 rbx
$LL5@EncipherBl@2:

; 218  : 		{
; 219  : 			aes_hw_cpu_encrypt_32_blocks (ks, data);

  00046	48 8b d7	 mov	 rdx, rdi
  00049	49 8b cc	 mov	 rcx, r12
  0004c	e8 00 00 00 00	 call	 aes_hw_cpu_encrypt_32_blocks

; 220  : 
; 221  : 			data += 32 * 16;

  00051	48 81 c7 00 02
	00 00		 add	 rdi, 512		; 00000200H
  00058	48 83 eb 01	 sub	 rbx, 1
  0005c	75 e8		 jne	 SHORT $LL5@EncipherBl@2

; 222  : 			blockCount -= 32;
; 223  : 		}
; 224  : 
; 225  : #if defined (TC_WINDOWS_DRIVER) && !defined (_WIN64)
; 226  : 		KeRestoreFloatingPointState (&floatingPointState);
; 227  : #endif
; 228  : 	}
; 229  : 	else

  0005e	eb 26		 jmp	 SHORT $LN14@EncipherBl@2
$LN6@EncipherBl@2:

; 230  : 	{
; 231  : 		size_t blockSize = CipherGetBlockSize (cipher);

  00060	8b ce		 mov	 ecx, esi
  00062	e8 00 00 00 00	 call	 CipherGet
  00067	48 63 68 10	 movsxd	 rbp, DWORD PTR [rax+16]

; 232  : 		while (blockCount-- > 0)

  0006b	48 85 db	 test	 rbx, rbx
  0006e	74 16		 je	 SHORT $LN14@EncipherBl@2
$LL2@EncipherBl@2:

; 233  : 		{
; 234  : 			EncipherBlock (cipher, data, ks);

  00070	4d 8b c4	 mov	 r8, r12
  00073	48 8b d7	 mov	 rdx, rdi
  00076	8b ce		 mov	 ecx, esi
  00078	e8 00 00 00 00	 call	 EncipherBlock

; 235  : 			data += blockSize;

  0007d	48 03 fd	 add	 rdi, rbp
  00080	48 83 eb 01	 sub	 rbx, 1
  00084	75 ea		 jne	 SHORT $LL2@EncipherBl@2
$LN14@EncipherBl@2:

; 236  : 		}
; 237  : 	}
; 238  : }

  00086	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0008b	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00090	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00095	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0009a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009e	41 5c		 pop	 r12
  000a0	c3		 ret	 0
EncipherBlocks ENDP
PUBLIC	GetMaxPkcs5OutSize
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetMaxPkcs5OutSize DD imagerel $LN13
	DD	imagerel $LN13+165
	DD	imagerel $unwind$GetMaxPkcs5OutSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetMaxPkcs5OutSize DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GetMaxPkcs5OutSize
_TEXT	SEGMENT
GetMaxPkcs5OutSize PROC					; COMDAT

; 1721 : {

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1722 : 	int size = 32;

  00006	bb 20 00 00 00	 mov	 ebx, 32			; 00000020H

; 1723 : 
; 1724 : 	size = max (size, EAGetLargestKeyForMode (XTS) * 2);	// Sizes of primary + secondary keys

  0000b	8d 4b e1	 lea	 ecx, QWORD PTR [rbx-31]
  0000e	e8 00 00 00 00	 call	 EAGetLargestKeyForMode
  00013	03 c0		 add	 eax, eax
  00015	3b c3		 cmp	 eax, ebx
  00017	7c 0c		 jl	 SHORT $LN4@GetMaxPkcs
  00019	8d 4b e1	 lea	 ecx, QWORD PTR [rbx-31]
  0001c	e8 00 00 00 00	 call	 EAGetLargestKeyForMode
  00021	8b d8		 mov	 ebx, eax
  00023	03 db		 add	 ebx, ebx
$LN4@GetMaxPkcs:

; 1725 : 
; 1726 : #ifndef TC_WINDOWS_BOOT
; 1727 : 	size = max (size, LEGACY_VOL_IV_SIZE + EAGetLargestKeyForMode (LRW));		// Deprecated/legacy

  00025	b9 02 00 00 00	 mov	 ecx, 2
  0002a	e8 00 00 00 00	 call	 EAGetLargestKeyForMode
  0002f	83 c0 20	 add	 eax, 32			; 00000020H
  00032	3b d8		 cmp	 ebx, eax
  00034	7f 0d		 jg	 SHORT $LN6@GetMaxPkcs
  00036	b9 02 00 00 00	 mov	 ecx, 2
  0003b	e8 00 00 00 00	 call	 EAGetLargestKeyForMode
  00040	8d 58 20	 lea	 ebx, DWORD PTR [rax+32]
$LN6@GetMaxPkcs:

; 1728 : 	size = max (size, LEGACY_VOL_IV_SIZE + EAGetLargestKeyForMode (CBC));		// Deprecated/legacy

  00043	b9 03 00 00 00	 mov	 ecx, 3
  00048	e8 00 00 00 00	 call	 EAGetLargestKeyForMode
  0004d	83 c0 20	 add	 eax, 32			; 00000020H
  00050	3b d8		 cmp	 ebx, eax
  00052	7f 0d		 jg	 SHORT $LN8@GetMaxPkcs
  00054	b9 03 00 00 00	 mov	 ecx, 3
  00059	e8 00 00 00 00	 call	 EAGetLargestKeyForMode
  0005e	8d 58 20	 lea	 ebx, DWORD PTR [rax+32]
$LN8@GetMaxPkcs:

; 1729 : 	size = max (size, LEGACY_VOL_IV_SIZE + EAGetLargestKeyForMode (OUTER_CBC));	// Deprecated/legacy

  00061	b9 04 00 00 00	 mov	 ecx, 4
  00066	e8 00 00 00 00	 call	 EAGetLargestKeyForMode
  0006b	83 c0 20	 add	 eax, 32			; 00000020H
  0006e	3b d8		 cmp	 ebx, eax
  00070	7f 0d		 jg	 SHORT $LN10@GetMaxPkcs
  00072	b9 04 00 00 00	 mov	 ecx, 4
  00077	e8 00 00 00 00	 call	 EAGetLargestKeyForMode
  0007c	8d 58 20	 lea	 ebx, DWORD PTR [rax+32]
$LN10@GetMaxPkcs:

; 1730 : 	size = max (size, LEGACY_VOL_IV_SIZE + EAGetLargestKeyForMode (INNER_CBC));	// Deprecated/legacy

  0007f	b9 05 00 00 00	 mov	 ecx, 5
  00084	e8 00 00 00 00	 call	 EAGetLargestKeyForMode
  00089	83 c0 20	 add	 eax, 32			; 00000020H
  0008c	3b d8		 cmp	 ebx, eax
  0008e	7f 0d		 jg	 SHORT $LN12@GetMaxPkcs
  00090	b9 05 00 00 00	 mov	 ecx, 5
  00095	e8 00 00 00 00	 call	 EAGetLargestKeyForMode
  0009a	8d 58 20	 lea	 ebx, DWORD PTR [rax+32]
$LN12@GetMaxPkcs:

; 1731 : #endif
; 1732 : 
; 1733 : 	return size;

  0009d	8b c3		 mov	 eax, ebx

; 1734 : }

  0009f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a3	5b		 pop	 rbx
  000a4	c3		 ret	 0
GetMaxPkcs5OutSize ENDP
_TEXT	ENDS
PUBLIC	DecryptDataUnitsCurrentThread
;	COMDAT pdata
pdata	SEGMENT
$pdata$DecryptDataUnitsCurrentThread DD imagerel $LN72
	DD	imagerel $LN72+777
	DD	imagerel $unwind$DecryptDataUnitsCurrentThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecryptDataUnitsCurrentThread DD 0a1401H
	DD	0123414H
	DD	0f0109214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT DecryptDataUnitsCurrentThread
_TEXT	SEGMENT
sectorIV$ = 64
buf$ = 144
secWhitening$ = 152
structUnitNo$ = 152
nbrUnits$ = 160
iv64$1$ = 168
ci$ = 168
DecryptDataUnitsCurrentThread PROC			; COMDAT

; 1601 : {

$LN72:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 1602 : 	int ea = ci->ea;

  00014	49 63 31	 movsxd	 rsi, DWORD PTR [r9]

; 1603 : 	unsigned __int8 *ks = ci->ks;
; 1604 : 	unsigned __int8 *ks2 = ci->ks2;
; 1605 : 	int cipher;
; 1606 : 
; 1607 : #ifndef TC_NO_COMPILER_INT64
; 1608 : 	void *iv = ci->k2;									// Deprecated/legacy
; 1609 : 	unsigned __int64 unitNo = structUnitNo->Value;

  00017	48 8b 1a	 mov	 rbx, QWORD PTR [rdx]
  0001a	49 8b f8	 mov	 rdi, r8

; 1610 : 	unsigned __int64 *iv64 = (unsigned __int64 *) iv;	// Deprecated/legacy
; 1611 : 	unsigned __int32 sectorIV[4];						// Deprecated/legacy
; 1612 : 	unsigned __int32 secWhitening[2];					// Deprecated/legacy
; 1613 : #endif	// #ifndef TC_NO_COMPILER_INT64
; 1614 : 
; 1615 : 
; 1616 : 	switch (ci->mode)

  0001d	45 8b 41 04	 mov	 r8d, DWORD PTR [r9+4]
  00021	4d 8d 99 a8 42
	00 00		 lea	 r11, QWORD PTR [r9+17064]
  00028	4d 8b d1	 mov	 r10, r9
  0002b	41 83 e8 01	 sub	 r8d, 1
  0002f	4c 8b f2	 mov	 r14, rdx
  00032	48 8b e9	 mov	 rbp, rcx
  00035	4d 8d 61 08	 lea	 r12, QWORD PTR [r9+8]
  00039	4d 8d a9 d4 14
	00 00		 lea	 r13, QWORD PTR [r9+5332]
  00040	4c 89 9c 24 a8
	00 00 00	 mov	 QWORD PTR iv64$1$[rsp], r11
  00048	0f 84 39 02 00
	00		 je	 $LN20@DecryptDat
  0004e	41 83 e8 01	 sub	 r8d, 1
  00052	0f 84 72 01 00
	00		 je	 $LN16@DecryptDat
  00058	41 83 e8 01	 sub	 r8d, 1
  0005c	0f 84 b7 00 00
	00		 je	 $LN61@DecryptDat
  00062	41 83 e8 01	 sub	 r8d, 1
  00066	74 29		 je	 SHORT $LN60@DecryptDat
  00068	41 83 f8 01	 cmp	 r8d, 1
  0006c	0f 84 a7 00 00
	00		 je	 $LN61@DecryptDat

; 1710 : #endif // #ifndef TC_NO_COMPILER_INT64
; 1711 : 
; 1712 : 	default:		
; 1713 : 		// Unknown/wrong ID
; 1714 : 		TC_THROW_FATAL_EXCEPTION;

  00072	45 33 c9	 xor	 r9d, r9d
  00075	45 33 c0	 xor	 r8d, r8d
  00078	ba b2 06 00 00	 mov	 edx, 1714		; 000006b2H
  0007d	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00081	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  0008a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00090	cc		 int	 3
$LN60@DecryptDat:

; 1602 : 	int ea = ci->ea;

  00091	4c 8b f6	 mov	 r14, rsi

; 1689 : 
; 1690 : 	case OUTER_CBC:
; 1691 : 
; 1692 : 		/* Deprecated/legacy */
; 1693 : 
; 1694 : 		while (nbrUnits--)

  00094	48 85 ff	 test	 rdi, rdi
  00097	0f 84 54 02 00
	00		 je	 $LN17@DecryptDat
  0009d	4d 6b f6 2c	 imul	 r14, 44			; 0000002cH
  000a1	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:EncryptionAlgorithms
  000a8	41 bd 00 02 00
	00		 mov	 r13d, 512		; 00000200H
$LL3@DecryptDat:

; 1695 : 		{
; 1696 : 			InitSectorIVAndWhitening (unitNo, CipherGetBlockSize (EAGetFirstCipher (ea)), sectorIV, iv64, secWhitening);

  000ae	43 8b 0c 3e	 mov	 ecx, DWORD PTR [r14+r15]
  000b2	e8 00 00 00 00	 call	 CipherGet
  000b7	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR secWhitening$[rsp]
  000bf	4c 8d 44 24 40	 lea	 r8, QWORD PTR sectorIV$[rsp]
  000c4	8b 50 10	 mov	 edx, DWORD PTR [rax+16]
  000c7	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000cc	4d 8b cb	 mov	 r9, r11
  000cf	48 8b cb	 mov	 rcx, rbx
  000d2	e8 00 00 00 00	 call	 InitSectorIVAndWhitening

; 1697 : 
; 1698 : 			DecryptBufferCBC ((unsigned __int32 *) buf,
; 1699 : 				ENCRYPTION_DATA_UNIT_SIZE,
; 1700 : 				ks,
; 1701 : 				sectorIV,
; 1702 : 				secWhitening,
; 1703 : 				ea,
; 1704 : 				0);

  000d7	83 64 24 30 00	 and	 DWORD PTR [rsp+48], 0
  000dc	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR secWhitening$[rsp]
  000e4	4c 8d 4c 24 40	 lea	 r9, QWORD PTR sectorIV$[rsp]
  000e9	4d 8b c4	 mov	 r8, r12
  000ec	41 8b d5	 mov	 edx, r13d
  000ef	48 8b cd	 mov	 rcx, rbp
  000f2	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  000f6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000fb	e8 00 00 00 00	 call	 DecryptBufferCBC
  00100	4c 8b 9c 24 a8
	00 00 00	 mov	 r11, QWORD PTR iv64$1$[rsp]

; 1705 : 
; 1706 : 			buf += ENCRYPTION_DATA_UNIT_SIZE;

  00108	49 03 ed	 add	 rbp, r13

; 1707 : 			unitNo++;

  0010b	48 ff c3	 inc	 rbx
  0010e	48 83 ef 01	 sub	 rdi, 1
  00112	75 9a		 jne	 SHORT $LL3@DecryptDat

; 1708 : 		}
; 1709 : 		break;

  00114	e9 d8 01 00 00	 jmp	 $LN17@DecryptDat
$LN61@DecryptDat:

; 1662 : 
; 1663 : 	case CBC:
; 1664 : 	case INNER_CBC:
; 1665 : 
; 1666 : 		/* Deprecated/legacy */
; 1667 : 
; 1668 : 		while (nbrUnits--)

  00119	48 85 ff	 test	 rdi, rdi
  0011c	0f 84 cf 01 00
	00		 je	 $LN17@DecryptDat
  00122	41 bd 00 02 00
	00		 mov	 r13d, 512		; 00000200H
  00128	4d 8b fb	 mov	 r15, r11
$LL9@DecryptDat:

; 1669 : 		{
; 1670 : 			ks += EAGetKeyScheduleSize (ea);

  0012b	8b ce		 mov	 ecx, esi
  0012d	48 ff cf	 dec	 rdi
  00130	e8 00 00 00 00	 call	 EAGetKeyScheduleSize
  00135	48 63 c8	 movsxd	 rcx, eax
  00138	4c 03 e1	 add	 r12, rcx

; 1671 : 			for (cipher = EAGetLastCipher (ea); cipher != 0; cipher = EAGetPreviousCipher (ea, cipher))

  0013b	8b ce		 mov	 ecx, esi
  0013d	e8 00 00 00 00	 call	 EAGetLastCipher
  00142	eb 6b		 jmp	 SHORT $LN71@DecryptDat
$LL7@DecryptDat:

; 1672 : 			{
; 1673 : 				InitSectorIVAndWhitening (unitNo, CipherGetBlockSize (cipher), sectorIV, iv64, secWhitening);

  00144	41 8b ce	 mov	 ecx, r14d
  00147	e8 00 00 00 00	 call	 CipherGet
  0014c	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR secWhitening$[rsp]
  00154	4c 8d 44 24 40	 lea	 r8, QWORD PTR sectorIV$[rsp]
  00159	8b 50 10	 mov	 edx, DWORD PTR [rax+16]
  0015c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00161	4d 8b cf	 mov	 r9, r15
  00164	48 8b cb	 mov	 rcx, rbx
  00167	e8 00 00 00 00	 call	 InitSectorIVAndWhitening

; 1674 : 
; 1675 : 				ks -= CipherGetKeyScheduleSize (cipher);

  0016c	41 8b ce	 mov	 ecx, r14d
  0016f	e8 00 00 00 00	 call	 CipherGet

; 1676 : 
; 1677 : 				DecryptBufferCBC ((unsigned __int32 *) buf,
; 1678 : 					ENCRYPTION_DATA_UNIT_SIZE,
; 1679 : 					ks,
; 1680 : 					sectorIV,
; 1681 : 					secWhitening,
; 1682 : 					0,
; 1683 : 					cipher);

  00174	44 89 74 24 30	 mov	 DWORD PTR [rsp+48], r14d
  00179	83 64 24 28 00	 and	 DWORD PTR [rsp+40], 0
  0017e	48 63 48 18	 movsxd	 rcx, DWORD PTR [rax+24]
  00182	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR secWhitening$[rsp]
  0018a	4c 8d 4c 24 40	 lea	 r9, QWORD PTR sectorIV$[rsp]
  0018f	4c 2b e1	 sub	 r12, rcx
  00192	41 8b d5	 mov	 edx, r13d
  00195	48 8b cd	 mov	 rcx, rbp
  00198	4d 8b c4	 mov	 r8, r12
  0019b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a0	e8 00 00 00 00	 call	 DecryptBufferCBC
  001a5	41 8b d6	 mov	 edx, r14d
  001a8	8b ce		 mov	 ecx, esi
  001aa	e8 00 00 00 00	 call	 EAGetPreviousCipher
$LN71@DecryptDat:
  001af	44 8b f0	 mov	 r14d, eax
  001b2	85 c0		 test	 eax, eax
  001b4	75 8e		 jne	 SHORT $LL7@DecryptDat

; 1684 : 			}
; 1685 : 			buf += ENCRYPTION_DATA_UNIT_SIZE;

  001b6	49 03 ed	 add	 rbp, r13

; 1686 : 			unitNo++;

  001b9	48 ff c3	 inc	 rbx
  001bc	48 85 ff	 test	 rdi, rdi
  001bf	0f 85 66 ff ff
	ff		 jne	 $LL9@DecryptDat

; 1687 : 		}
; 1688 : 		break;

  001c5	e9 27 01 00 00	 jmp	 $LN17@DecryptDat
$LN16@DecryptDat:

; 1634 : 		}
; 1635 : 		break;
; 1636 : 
; 1637 : #ifndef TC_NO_COMPILER_INT64
; 1638 : 	case LRW:
; 1639 : 
; 1640 : 		/* Deprecated/legacy */
; 1641 : 
; 1642 : 		switch (CipherGetBlockSize (EAGetFirstCipher (ea)))

  001ca	48 8b c6	 mov	 rax, rsi
  001cd	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:EncryptionAlgorithms
  001d4	48 6b c0 2c	 imul	 rax, 44			; 0000002cH
  001d8	42 8b 0c 38	 mov	 ecx, DWORD PTR [rax+r15]
  001dc	e8 00 00 00 00	 call	 CipherGet
  001e1	83 78 10 08	 cmp	 DWORD PTR [rax+16], 8
  001e5	74 64		 je	 SHORT $LN13@DecryptDat
  001e7	83 78 10 10	 cmp	 DWORD PTR [rax+16], 16
  001eb	74 1f		 je	 SHORT $LN12@DecryptDat

; 1657 : 
; 1658 : 		default:
; 1659 : 			TC_THROW_FATAL_EXCEPTION;

  001ed	45 33 c9	 xor	 r9d, r9d
  001f0	45 33 c0	 xor	 r8d, r8d
  001f3	ba 7b 06 00 00	 mov	 edx, 1659		; 0000067bH
  001f8	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  001fc	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00205	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  0020b	cc		 int	 3
$LN12@DecryptDat:

; 1649 : 			break;
; 1650 : 
; 1651 : 		case 16:
; 1652 : 			DecryptBufferLRW128 (buf,
; 1653 : 				(unsigned __int64) nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1654 : 				DataUnit2LRWIndex (unitNo, 16, ci),
; 1655 : 				ci);

  0020c	41 83 ba a0 29
	00 00 00	 cmp	 DWORD PTR [r10+10656], 0
  00214	74 10		 je	 SHORT $LN49@DecryptDat
  00216	49 8b 82 18 44
	00 00		 mov	 rax, QWORD PTR [r10+17432]
  0021d	48 c1 e8 09	 shr	 rax, 9
  00221	48 2b d8	 sub	 rbx, rax
  00224	eb 03		 jmp	 SHORT $LN48@DecryptDat
$LN49@DecryptDat:
  00226	48 ff cb	 dec	 rbx
$LN48@DecryptDat:
  00229	48 c1 e3 05	 shl	 rbx, 5
  0022d	48 c1 e7 09	 shl	 rdi, 9
  00231	4d 8b ca	 mov	 r9, r10
  00234	48 83 cb 01	 or	 rbx, 1
  00238	48 8b d7	 mov	 rdx, rdi
  0023b	48 8b cd	 mov	 rcx, rbp
  0023e	4c 8b c3	 mov	 r8, rbx
  00241	e8 00 00 00 00	 call	 DecryptBufferLRW128

; 1656 : 			break;

  00246	e9 a6 00 00 00	 jmp	 $LN17@DecryptDat
$LN13@DecryptDat:

; 1643 : 		{
; 1644 : 		case 8:
; 1645 : 			DecryptBufferLRW64 (buf,
; 1646 : 				(unsigned __int64) nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1647 : 				DataUnit2LRWIndex (unitNo, 8, ci),
; 1648 : 				ci);

  0024b	41 83 ba a0 29
	00 00 00	 cmp	 DWORD PTR [r10+10656], 0
  00253	74 10		 je	 SHORT $LN39@DecryptDat
  00255	49 8b 82 18 44
	00 00		 mov	 rax, QWORD PTR [r10+17432]
  0025c	48 c1 e8 09	 shr	 rax, 9
  00260	48 2b d8	 sub	 rbx, rax
  00263	eb 03		 jmp	 SHORT $LN38@DecryptDat
$LN39@DecryptDat:
  00265	48 ff cb	 dec	 rbx
$LN38@DecryptDat:
  00268	48 c1 e3 06	 shl	 rbx, 6
  0026c	48 c1 e7 09	 shl	 rdi, 9
  00270	4d 8b ca	 mov	 r9, r10
  00273	48 83 cb 01	 or	 rbx, 1
  00277	48 8b d7	 mov	 rdx, rdi
  0027a	48 8b cd	 mov	 rcx, rbp
  0027d	4c 8b c3	 mov	 r8, rbx
  00280	e8 00 00 00 00	 call	 DecryptBufferLRW64

; 1660 : 		}
; 1661 : 		break;

  00285	eb 6a		 jmp	 SHORT $LN17@DecryptDat
$LN20@DecryptDat:

; 1617 : 	{
; 1618 : 	case XTS:
; 1619 : 		ks += EAGetKeyScheduleSize (ea);

  00287	8b ce		 mov	 ecx, esi
  00289	e8 00 00 00 00	 call	 EAGetKeyScheduleSize
  0028e	48 63 c8	 movsxd	 rcx, eax
  00291	4c 03 e1	 add	 r12, rcx

; 1620 : 		ks2 += EAGetKeyScheduleSize (ea);

  00294	8b ce		 mov	 ecx, esi
  00296	e8 00 00 00 00	 call	 EAGetKeyScheduleSize
  0029b	48 63 c8	 movsxd	 rcx, eax
  0029e	4c 03 e9	 add	 r13, rcx

; 1621 : 
; 1622 : 		for (cipher = EAGetLastCipher (ea); cipher != 0; cipher = EAGetPreviousCipher (ea, cipher))

  002a1	8b ce		 mov	 ecx, esi
  002a3	e8 00 00 00 00	 call	 EAGetLastCipher
  002a8	8b d8		 mov	 ebx, eax
  002aa	85 c0		 test	 eax, eax
  002ac	74 43		 je	 SHORT $LN17@DecryptDat
  002ae	48 c1 e7 09	 shl	 rdi, 9
$LL19@DecryptDat:

; 1623 : 		{
; 1624 : 			ks -= CipherGetKeyScheduleSize (cipher);

  002b2	8b cb		 mov	 ecx, ebx
  002b4	e8 00 00 00 00	 call	 CipherGet

; 1625 : 			ks2 -= CipherGetKeyScheduleSize (cipher);
; 1626 : 
; 1627 : 			DecryptBufferXTS (buf,
; 1628 : 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1629 : 				structUnitNo,
; 1630 : 				0,
; 1631 : 				ks,
; 1632 : 				ks2,
; 1633 : 				cipher);

  002b9	89 5c 24 30	 mov	 DWORD PTR [rsp+48], ebx
  002bd	45 33 c9	 xor	 r9d, r9d
  002c0	48 63 48 18	 movsxd	 rcx, DWORD PTR [rax+24]
  002c4	4d 8b c6	 mov	 r8, r14
  002c7	48 8b d7	 mov	 rdx, rdi
  002ca	4c 2b e9	 sub	 r13, rcx
  002cd	4c 2b e1	 sub	 r12, rcx
  002d0	48 8b cd	 mov	 rcx, rbp
  002d3	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  002d8	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  002dd	e8 00 00 00 00	 call	 DecryptBufferXTS
  002e2	8b d3		 mov	 edx, ebx
  002e4	8b ce		 mov	 ecx, esi
  002e6	e8 00 00 00 00	 call	 EAGetPreviousCipher
  002eb	8b d8		 mov	 ebx, eax
  002ed	85 c0		 test	 eax, eax
  002ef	75 c1		 jne	 SHORT $LL19@DecryptDat
$LN17@DecryptDat:

; 1715 : 	}
; 1716 : }

  002f1	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
  002f9	48 83 c4 50	 add	 rsp, 80			; 00000050H
  002fd	41 5f		 pop	 r15
  002ff	41 5e		 pop	 r14
  00301	41 5d		 pop	 r13
  00303	41 5c		 pop	 r12
  00305	5f		 pop	 rdi
  00306	5e		 pop	 rsi
  00307	5d		 pop	 rbp
  00308	c3		 ret	 0
$LN70@DecryptDat:
DecryptDataUnitsCurrentThread ENDP
_TEXT	ENDS
PUBLIC	DecryptBuffer
;	COMDAT pdata
pdata	SEGMENT
$pdata$DecryptBuffer DD imagerel $LN37
	DD	imagerel $LN37+514
	DD	imagerel $unwind$DecryptBuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecryptBuffer DD 0a1601H
	DD	0f5416H
	DD	0e3416H
	DD	0e0127216H
	DD	0c00ed010H
	DD	0600b700cH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT DecryptBuffer
_TEXT	SEGMENT
buf$ = 112
len$ = 120
dataUnitNo$29429 = 128
cryptoInfo$ = 128
DecryptBuffer PROC					; COMDAT

; 1497 : {

$LN37:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 55		 push	 r13
  00010	41 56		 push	 r14
  00012	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00016	49 8b d8	 mov	 rbx, r8

; 1498 : 	switch (cryptoInfo->mode)

  00019	45 8b 40 04	 mov	 r8d, DWORD PTR [r8+4]
  0001d	41 ba 01 00 00
	00		 mov	 r10d, 1
  00023	45 2b c2	 sub	 r8d, r10d
  00026	48 8b fa	 mov	 rdi, rdx
  00029	48 8b f1	 mov	 rsi, rcx
  0002c	0f 84 3b 01 00
	00		 je	 $LN16@DecryptBuf@7
  00032	45 2b c2	 sub	 r8d, r10d
  00035	0f 84 c8 00 00
	00		 je	 $LN12@DecryptBuf@7
  0003b	45 2b c2	 sub	 r8d, r10d
  0003e	74 58		 je	 SHORT $LN6@DecryptBuf@7
  00040	45 2b c2	 sub	 r8d, r10d
  00043	74 24		 je	 SHORT $LN2@DecryptBuf@7
  00045	45 3b c2	 cmp	 r8d, r10d
  00048	74 4e		 je	 SHORT $LN6@DecryptBuf@7

; 1582 : #endif	// #ifndef TC_NO_COMPILER_INT64
; 1583 : 
; 1584 : 	default:		
; 1585 : 		// Unknown/wrong ID
; 1586 : 		TC_THROW_FATAL_EXCEPTION;

  0004a	41 8d 4a 28	 lea	 ecx, QWORD PTR [r10+40]
  0004e	45 33 c9	 xor	 r9d, r9d
  00051	45 33 c0	 xor	 r8d, r8d
  00054	ba 32 06 00 00	 mov	 edx, 1586		; 00000632H
  00059	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00068	cc		 int	 3
$LN2@DecryptBuf@7:

; 1568 : 
; 1569 : 	case OUTER_CBC:
; 1570 : 
; 1571 : 		/* Deprecated/legacy */
; 1572 : 
; 1573 : 		DecryptBufferCBC ((unsigned __int32 *) buf,
; 1574 : 			(unsigned int) len,
; 1575 : 			cryptoInfo->ks,
; 1576 : 			(unsigned __int32 *) cryptoInfo->k2,
; 1577 : 			(unsigned __int32 *) &cryptoInfo->k2[8],
; 1578 : 			cryptoInfo->ea,
; 1579 : 			0);

  00069	83 64 24 30 00	 and	 DWORD PTR [rsp+48], 0
  0006e	8b 03		 mov	 eax, DWORD PTR [rbx]
  00070	48 8d 8b b0 42
	00 00		 lea	 rcx, QWORD PTR [rbx+17072]
  00077	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0007b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00080	4c 8d 8b a8 42
	00 00		 lea	 r9, QWORD PTR [rbx+17064]
  00087	4c 8d 43 08	 lea	 r8, QWORD PTR [rbx+8]
  0008b	48 8b ce	 mov	 rcx, rsi
  0008e	e8 00 00 00 00	 call	 DecryptBufferCBC

; 1580 : 
; 1581 : 		break;

  00093	e9 53 01 00 00	 jmp	 $LN13@DecryptBuf@7
$LN6@DecryptBuf@7:

; 1544 : 
; 1545 : 	case CBC:
; 1546 : 	case INNER_CBC:
; 1547 : 		{
; 1548 : 			/* Deprecated/legacy */
; 1549 : 
; 1550 : 			unsigned __int8 *ks = cryptoInfo->ks + EAGetKeyScheduleSize (cryptoInfo->ea);

  00098	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  0009a	e8 00 00 00 00	 call	 EAGetKeyScheduleSize

; 1551 : 			int cipher;
; 1552 : 			for (cipher = EAGetLastCipher (cryptoInfo->ea);
; 1553 : 				cipher != 0;
; 1554 : 				cipher = EAGetPreviousCipher (cryptoInfo->ea, cipher))

  0009f	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  000a1	48 63 d0	 movsxd	 rdx, eax
  000a4	4c 8d 74 1a 08	 lea	 r14, QWORD PTR [rdx+rbx+8]
  000a9	e8 00 00 00 00	 call	 EAGetLastCipher
  000ae	8b e8		 mov	 ebp, eax
  000b0	85 c0		 test	 eax, eax
  000b2	0f 84 33 01 00
	00		 je	 $LN13@DecryptBuf@7
  000b8	4c 8d a3 b0 42
	00 00		 lea	 r12, QWORD PTR [rbx+17072]
$LL5@DecryptBuf@7:

; 1555 : 			{
; 1556 : 				ks -= CipherGetKeyScheduleSize (cipher);

  000bf	8b cd		 mov	 ecx, ebp
  000c1	e8 00 00 00 00	 call	 CipherGet

; 1557 : 
; 1558 : 				DecryptBufferCBC ((unsigned __int32 *) buf,
; 1559 : 					(unsigned int) len,
; 1560 : 					ks,
; 1561 : 					(unsigned __int32 *) cryptoInfo->k2,
; 1562 : 					(unsigned __int32 *) &cryptoInfo->k2[8],
; 1563 : 					0,
; 1564 : 					cipher);

  000c6	89 6c 24 30	 mov	 DWORD PTR [rsp+48], ebp
  000ca	83 64 24 28 00	 and	 DWORD PTR [rsp+40], 0
  000cf	48 63 48 18	 movsxd	 rcx, DWORD PTR [rax+24]
  000d3	4c 8d 8b a8 42
	00 00		 lea	 r9, QWORD PTR [rbx+17064]
  000da	8b d7		 mov	 edx, edi
  000dc	4c 2b f1	 sub	 r14, rcx
  000df	48 8b ce	 mov	 rcx, rsi
  000e2	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  000e7	4d 8b c6	 mov	 r8, r14
  000ea	e8 00 00 00 00	 call	 DecryptBufferCBC
  000ef	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  000f1	8b d5		 mov	 edx, ebp
  000f3	e8 00 00 00 00	 call	 EAGetPreviousCipher
  000f8	8b e8		 mov	 ebp, eax
  000fa	85 c0		 test	 eax, eax
  000fc	75 c1		 jne	 SHORT $LL5@DecryptBuf@7

; 1565 : 			}
; 1566 : 		}
; 1567 : 		break;

  000fe	e9 e8 00 00 00	 jmp	 $LN13@DecryptBuf@7
$LN12@DecryptBuf@7:

; 1521 : 			}
; 1522 : 		}
; 1523 : 		break;
; 1524 : 
; 1525 : #ifndef TC_NO_COMPILER_INT64
; 1526 : 	case LRW:
; 1527 : 
; 1528 : 		/* Deprecated/legacy */
; 1529 : 
; 1530 : 		switch (CipherGetBlockSize (EAGetFirstCipher (cryptoInfo->ea)))

  00103	48 63 03	 movsxd	 rax, DWORD PTR [rbx]
  00106	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  0010d	48 6b c0 2c	 imul	 rax, 44			; 0000002cH
  00111	8b 0c 08	 mov	 ecx, DWORD PTR [rax+rcx]
  00114	e8 00 00 00 00	 call	 CipherGet
  00119	83 78 10 08	 cmp	 DWORD PTR [rax+16], 8
  0011d	74 3b		 je	 SHORT $LN9@DecryptBuf@7
  0011f	83 78 10 10	 cmp	 DWORD PTR [rax+16], 16
  00123	74 1f		 je	 SHORT $LN8@DecryptBuf@7

; 1539 : 
; 1540 : 		default:
; 1541 : 			TC_THROW_FATAL_EXCEPTION;

  00125	45 33 c9	 xor	 r9d, r9d
  00128	45 33 c0	 xor	 r8d, r8d
  0012b	ba 05 06 00 00	 mov	 edx, 1541		; 00000605H
  00130	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00134	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  0013d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00143	cc		 int	 3
$LN8@DecryptBuf@7:

; 1534 : 			break;
; 1535 : 
; 1536 : 		case 16:
; 1537 : 			DecryptBufferLRW128 (buf, (unsigned __int64) len, 1, cryptoInfo);

  00144	4c 8b cb	 mov	 r9, rbx
  00147	4d 8b c2	 mov	 r8, r10
  0014a	48 8b d7	 mov	 rdx, rdi
  0014d	48 8b ce	 mov	 rcx, rsi
  00150	e8 00 00 00 00	 call	 DecryptBufferLRW128

; 1538 : 			break;

  00155	e9 91 00 00 00	 jmp	 $LN13@DecryptBuf@7
$LN9@DecryptBuf@7:

; 1531 : 		{
; 1532 : 		case 8:
; 1533 : 			DecryptBufferLRW64 (buf, (unsigned __int64) len, 1, cryptoInfo);

  0015a	4c 8b cb	 mov	 r9, rbx
  0015d	4d 8b c2	 mov	 r8, r10
  00160	48 8b d7	 mov	 rdx, rdi
  00163	48 8b ce	 mov	 rcx, rsi
  00166	e8 00 00 00 00	 call	 DecryptBufferLRW64

; 1542 : 		}
; 1543 : 		break;

  0016b	eb 7e		 jmp	 SHORT $LN13@DecryptBuf@7
$LN16@DecryptBuf@7:

; 1499 : 	{
; 1500 : 	case XTS:
; 1501 : 		{
; 1502 : 			unsigned __int8 *ks = cryptoInfo->ks + EAGetKeyScheduleSize (cryptoInfo->ea);

  0016d	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  0016f	e8 00 00 00 00	 call	 EAGetKeyScheduleSize

; 1503 : 			unsigned __int8 *ks2 = cryptoInfo->ks2 + EAGetKeyScheduleSize (cryptoInfo->ea);

  00174	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00176	48 63 d0	 movsxd	 rdx, eax
  00179	4c 8d 64 1a 08	 lea	 r12, QWORD PTR [rdx+rbx+8]
  0017e	e8 00 00 00 00	 call	 EAGetKeyScheduleSize

; 1504 : 			UINT64_STRUCT dataUnitNo;
; 1505 : 			int cipher;
; 1506 : 
; 1507 : 			// When encrypting/decrypting a buffer (typically a volume header) the sequential number
; 1508 : 			// of the first XTS data unit in the buffer is always 0 and the start of the buffer is
; 1509 : 			// always assumed to be aligned with the start of the data unit 0.
; 1510 : 			dataUnitNo.LowPart = 0;
; 1511 : 			dataUnitNo.HighPart = 0;
; 1512 : 
; 1513 : 			for (cipher = EAGetLastCipher (cryptoInfo->ea);
; 1514 : 				cipher != 0;
; 1515 : 				cipher = EAGetPreviousCipher (cryptoInfo->ea, cipher))

  00183	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00185	83 a4 24 80 00
	00 00 00	 and	 DWORD PTR dataUnitNo$29429[rsp], 0
  0018d	83 a4 24 84 00
	00 00 00	 and	 DWORD PTR dataUnitNo$29429[rsp+4], 0
  00195	48 63 d0	 movsxd	 rdx, eax
  00198	4c 8d ac 1a d4
	14 00 00	 lea	 r13, QWORD PTR [rdx+rbx+5332]
  001a0	e8 00 00 00 00	 call	 EAGetLastCipher
  001a5	eb 3e		 jmp	 SHORT $LN36@DecryptBuf@7
$LL15@DecryptBuf@7:

; 1516 : 			{
; 1517 : 				ks -= CipherGetKeyScheduleSize (cipher);

  001a7	8b cd		 mov	 ecx, ebp
  001a9	e8 00 00 00 00	 call	 CipherGet

; 1518 : 				ks2 -= CipherGetKeyScheduleSize (cipher);
; 1519 : 
; 1520 : 				DecryptBufferXTS (buf, len, &dataUnitNo, 0, ks, ks2, cipher);

  001ae	89 6c 24 30	 mov	 DWORD PTR [rsp+48], ebp
  001b2	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR dataUnitNo$29429[rsp]
  001ba	48 63 48 18	 movsxd	 rcx, DWORD PTR [rax+24]
  001be	45 33 c9	 xor	 r9d, r9d
  001c1	48 8b d7	 mov	 rdx, rdi
  001c4	4c 2b e9	 sub	 r13, rcx
  001c7	4c 2b e1	 sub	 r12, rcx
  001ca	48 8b ce	 mov	 rcx, rsi
  001cd	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  001d2	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  001d7	e8 00 00 00 00	 call	 DecryptBufferXTS
  001dc	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  001de	8b d5		 mov	 edx, ebp
  001e0	e8 00 00 00 00	 call	 EAGetPreviousCipher
$LN36@DecryptBuf@7:
  001e5	8b e8		 mov	 ebp, eax
  001e7	85 c0		 test	 eax, eax
  001e9	75 bc		 jne	 SHORT $LL15@DecryptBuf@7
$LN13@DecryptBuf@7:

; 1587 : 	}
; 1588 : }

  001eb	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  001f0	48 8b 6c 24 78	 mov	 rbp, QWORD PTR [rsp+120]
  001f5	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001f9	41 5e		 pop	 r14
  001fb	41 5d		 pop	 r13
  001fd	41 5c		 pop	 r12
  001ff	5f		 pop	 rdi
  00200	5e		 pop	 rsi
  00201	c3		 ret	 0
$LN35@DecryptBuf@7:
DecryptBuffer ENDP
_TEXT	ENDS
PUBLIC	EncryptDataUnitsCurrentThread
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptDataUnitsCurrentThread DD imagerel $LN75
	DD	imagerel $LN75+788
	DD	imagerel $unwind$EncryptDataUnitsCurrentThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptDataUnitsCurrentThread DD 0a1901H
	DD	0143419H
	DD	0f015b219H
	DD	0d011e013H
	DD	0700dc00fH
	DD	0500b600cH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EncryptDataUnitsCurrentThread
_TEXT	SEGMENT
iv64$1$ = 64
$T52580 = 72
sectorIV$ = 80
buf$ = 160
structUnitNo$ = 168
nbrUnits$ = 176
secWhitening$ = 184
ci$ = 184
EncryptDataUnitsCurrentThread PROC			; COMDAT

; 1378 : {

$LN75:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	41 54		 push	 r12
  0000f	41 55		 push	 r13
  00011	41 56		 push	 r14
  00013	41 57		 push	 r15
  00015	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 1379 : 	int ea = ci->ea;

  00019	4d 63 39	 movsxd	 r15, DWORD PTR [r9]

; 1380 : 	unsigned __int8 *ks = ci->ks;
; 1381 : 	unsigned __int8 *ks2 = ci->ks2;
; 1382 : 	int cipher;
; 1383 : 
; 1384 : #ifndef TC_NO_COMPILER_INT64
; 1385 : 	void *iv = ci->k2;									// Deprecated/legacy
; 1386 : 	unsigned __int64 unitNo = structUnitNo->Value;

  0001c	48 8b 1a	 mov	 rbx, QWORD PTR [rdx]
  0001f	49 8b f8	 mov	 rdi, r8

; 1387 : 	unsigned __int64 *iv64 = (unsigned __int64 *) iv;	// Deprecated/legacy
; 1388 : 	unsigned __int32 sectorIV[4];						// Deprecated/legacy
; 1389 : 	unsigned __int32 secWhitening[2];					// Deprecated/legacy
; 1390 : #endif
; 1391 : 
; 1392 : 	switch (ci->mode)

  00022	45 8b 41 04	 mov	 r8d, DWORD PTR [r9+4]
  00026	4d 8d 99 a8 42
	00 00		 lea	 r11, QWORD PTR [r9+17064]
  0002d	4d 8b d1	 mov	 r10, r9
  00030	41 83 e8 01	 sub	 r8d, 1
  00034	4c 8b e1	 mov	 r12, rcx
  00037	4d 8d 69 08	 lea	 r13, QWORD PTR [r9+8]
  0003b	4d 8d b1 d4 14
	00 00		 lea	 r14, QWORD PTR [r9+5332]
  00042	4c 89 5c 24 40	 mov	 QWORD PTR iv64$1$[rsp], r11
  00047	49 8b f7	 mov	 rsi, r15
  0004a	0f 84 4e 02 00
	00		 je	 $LN20@EncryptDat
  00050	41 83 e8 01	 sub	 r8d, 1
  00054	0f 84 8b 01 00
	00		 je	 $LN16@EncryptDat
  0005a	41 83 e8 01	 sub	 r8d, 1
  0005e	0f 84 b1 00 00
	00		 je	 $LN65@EncryptDat
  00064	41 83 e8 01	 sub	 r8d, 1
  00068	74 29		 je	 SHORT $LN64@EncryptDat
  0006a	41 83 f8 01	 cmp	 r8d, 1
  0006e	0f 84 a1 00 00
	00		 je	 $LN65@EncryptDat

; 1483 : #endif	// #ifndef TC_NO_COMPILER_INT64
; 1484 : 
; 1485 : 	default:		
; 1486 : 		// Unknown/wrong ID
; 1487 : 		TC_THROW_FATAL_EXCEPTION;

  00074	45 33 c9	 xor	 r9d, r9d
  00077	45 33 c0	 xor	 r8d, r8d
  0007a	ba cf 05 00 00	 mov	 edx, 1487		; 000005cfH
  0007f	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00083	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00092	cc		 int	 3
$LN64@EncryptDat:

; 1462 : 
; 1463 : 	case OUTER_CBC:
; 1464 : 
; 1465 : 		/* Deprecated/legacy */
; 1466 : 
; 1467 : 		while (nbrUnits--)

  00093	48 85 ff	 test	 rdi, rdi
  00096	0f 84 60 02 00
	00		 je	 $LN17@EncryptDat
  0009c	48 6b f6 2c	 imul	 rsi, 44			; 0000002cH
  000a0	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:EncryptionAlgorithms
  000a7	41 be 00 02 00
	00		 mov	 r14d, 512		; 00000200H
$LL3@EncryptDat:

; 1468 : 		{
; 1469 : 			InitSectorIVAndWhitening (unitNo, CipherGetBlockSize (EAGetFirstCipher (ea)), sectorIV, iv64, secWhitening);

  000ad	8b 0c 2e	 mov	 ecx, DWORD PTR [rsi+rbp]
  000b0	e8 00 00 00 00	 call	 CipherGet
  000b5	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR secWhitening$[rsp]
  000bd	4c 8d 44 24 50	 lea	 r8, QWORD PTR sectorIV$[rsp]
  000c2	8b 50 10	 mov	 edx, DWORD PTR [rax+16]
  000c5	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000ca	4d 8b cb	 mov	 r9, r11
  000cd	48 8b cb	 mov	 rcx, rbx
  000d0	e8 00 00 00 00	 call	 InitSectorIVAndWhitening

; 1470 : 
; 1471 : 			EncryptBufferCBC ((unsigned __int32 *) buf,
; 1472 : 				ENCRYPTION_DATA_UNIT_SIZE,
; 1473 : 				ks,
; 1474 : 				sectorIV,
; 1475 : 				secWhitening,
; 1476 : 				ea,
; 1477 : 				0);

  000d5	83 64 24 30 00	 and	 DWORD PTR [rsp+48], 0
  000da	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR secWhitening$[rsp]
  000e2	4c 8d 4c 24 50	 lea	 r9, QWORD PTR sectorIV$[rsp]
  000e7	4d 8b c5	 mov	 r8, r13
  000ea	41 8b d6	 mov	 edx, r14d
  000ed	49 8b cc	 mov	 rcx, r12
  000f0	44 89 7c 24 28	 mov	 DWORD PTR [rsp+40], r15d
  000f5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000fa	e8 00 00 00 00	 call	 EncryptBufferCBC
  000ff	4c 8b 5c 24 40	 mov	 r11, QWORD PTR iv64$1$[rsp]

; 1478 : 
; 1479 : 			buf += ENCRYPTION_DATA_UNIT_SIZE;

  00104	4d 03 e6	 add	 r12, r14

; 1480 : 			unitNo++;

  00107	48 ff c3	 inc	 rbx
  0010a	48 83 ef 01	 sub	 rdi, 1
  0010e	75 9d		 jne	 SHORT $LL3@EncryptDat

; 1481 : 		}
; 1482 : 		break;

  00110	e9 e7 01 00 00	 jmp	 $LN17@EncryptDat
$LN65@EncryptDat:

; 1435 : 
; 1436 : 	case CBC:
; 1437 : 	case INNER_CBC:
; 1438 : 
; 1439 : 		/* Deprecated/legacy */
; 1440 : 
; 1441 : 		while (nbrUnits--)

  00115	48 85 ff	 test	 rdi, rdi
  00118	0f 84 de 01 00
	00		 je	 $LN17@EncryptDat
  0011e	48 6b f6 2c	 imul	 rsi, 44			; 0000002cH
  00122	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:EncryptionAlgorithms
  00129	41 be 00 02 00
	00		 mov	 r14d, 512		; 00000200H
  0012f	48 89 74 24 48	 mov	 QWORD PTR $T52580[rsp], rsi
$LL9@EncryptDat:

; 1442 : 		{
; 1443 : 			for (cipher = EAGetFirstCipher (ea); cipher != 0; cipher = EAGetNextCipher (ea, cipher))

  00134	8b 04 2e	 mov	 eax, DWORD PTR [rsi+rbp]
  00137	48 ff cf	 dec	 rdi
  0013a	85 c0		 test	 eax, eax
  0013c	0f 84 81 00 00
	00		 je	 $LN5@EncryptDat
  00142	48 8b 74 24 40	 mov	 rsi, QWORD PTR iv64$1$[rsp]
  00147	8b e8		 mov	 ebp, eax
$LL7@EncryptDat:

; 1444 : 			{
; 1445 : 				InitSectorIVAndWhitening (unitNo, CipherGetBlockSize (cipher), sectorIV, iv64, secWhitening);

  00149	8b cd		 mov	 ecx, ebp
  0014b	e8 00 00 00 00	 call	 CipherGet
  00150	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR secWhitening$[rsp]
  00158	4c 8d 44 24 50	 lea	 r8, QWORD PTR sectorIV$[rsp]
  0015d	8b 50 10	 mov	 edx, DWORD PTR [rax+16]
  00160	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00165	4c 8b ce	 mov	 r9, rsi
  00168	48 8b cb	 mov	 rcx, rbx
  0016b	e8 00 00 00 00	 call	 InitSectorIVAndWhitening

; 1446 : 
; 1447 : 				EncryptBufferCBC ((unsigned __int32 *) buf,
; 1448 : 					ENCRYPTION_DATA_UNIT_SIZE,
; 1449 : 					ks,
; 1450 : 					sectorIV,
; 1451 : 					secWhitening,
; 1452 : 					0,
; 1453 : 					cipher);

  00170	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR secWhitening$[rsp]
  00178	89 6c 24 30	 mov	 DWORD PTR [rsp+48], ebp
  0017c	83 64 24 28 00	 and	 DWORD PTR [rsp+40], 0
  00181	4c 8d 4c 24 50	 lea	 r9, QWORD PTR sectorIV$[rsp]
  00186	4d 8b c5	 mov	 r8, r13
  00189	41 8b d6	 mov	 edx, r14d
  0018c	49 8b cc	 mov	 rcx, r12
  0018f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00194	e8 00 00 00 00	 call	 EncryptBufferCBC

; 1454 : 
; 1455 : 				ks += CipherGetKeyScheduleSize (cipher);

  00199	8b cd		 mov	 ecx, ebp
  0019b	e8 00 00 00 00	 call	 CipherGet
  001a0	8b d5		 mov	 edx, ebp
  001a2	48 63 48 18	 movsxd	 rcx, DWORD PTR [rax+24]
  001a6	4c 03 e9	 add	 r13, rcx
  001a9	41 8b cf	 mov	 ecx, r15d
  001ac	e8 00 00 00 00	 call	 EAGetNextCipher
  001b1	8b e8		 mov	 ebp, eax
  001b3	85 c0		 test	 eax, eax
  001b5	75 92		 jne	 SHORT $LL7@EncryptDat
  001b7	48 8b 74 24 48	 mov	 rsi, QWORD PTR $T52580[rsp]
  001bc	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:EncryptionAlgorithms
$LN5@EncryptDat:

; 1456 : 			}
; 1457 : 			ks -= EAGetKeyScheduleSize (ea);

  001c3	41 8b cf	 mov	 ecx, r15d
  001c6	e8 00 00 00 00	 call	 EAGetKeyScheduleSize

; 1458 : 			buf += ENCRYPTION_DATA_UNIT_SIZE;

  001cb	4d 03 e6	 add	 r12, r14

; 1459 : 			unitNo++;

  001ce	48 ff c3	 inc	 rbx
  001d1	48 63 c8	 movsxd	 rcx, eax
  001d4	4c 2b e9	 sub	 r13, rcx
  001d7	48 85 ff	 test	 rdi, rdi
  001da	0f 85 54 ff ff
	ff		 jne	 $LL9@EncryptDat

; 1460 : 		}
; 1461 : 		break;

  001e0	e9 17 01 00 00	 jmp	 $LN17@EncryptDat
$LN16@EncryptDat:

; 1407 : 		}
; 1408 : 		break;
; 1409 : 
; 1410 : #ifndef TC_NO_COMPILER_INT64
; 1411 : 	case LRW:
; 1412 : 
; 1413 : 		/* Deprecated/legacy */
; 1414 : 
; 1415 : 		switch (CipherGetBlockSize (EAGetFirstCipher (ea)))

  001e5	48 6b f6 2c	 imul	 rsi, 44			; 0000002cH
  001e9	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:EncryptionAlgorithms
  001f0	8b 0c 2e	 mov	 ecx, DWORD PTR [rsi+rbp]
  001f3	e8 00 00 00 00	 call	 CipherGet
  001f8	83 78 10 08	 cmp	 DWORD PTR [rax+16], 8
  001fc	74 64		 je	 SHORT $LN13@EncryptDat
  001fe	83 78 10 10	 cmp	 DWORD PTR [rax+16], 16
  00202	74 1f		 je	 SHORT $LN12@EncryptDat

; 1430 : 
; 1431 : 		default:
; 1432 : 			TC_THROW_FATAL_EXCEPTION;

  00204	45 33 c9	 xor	 r9d, r9d
  00207	45 33 c0	 xor	 r8d, r8d
  0020a	ba 98 05 00 00	 mov	 edx, 1432		; 00000598H
  0020f	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00213	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  0021c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00222	cc		 int	 3
$LN12@EncryptDat:

; 1422 : 			break;
; 1423 : 
; 1424 : 		case 16:
; 1425 : 			EncryptBufferLRW128 (buf,
; 1426 : 				(unsigned __int64) nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1427 : 				DataUnit2LRWIndex (unitNo, 16, ci),
; 1428 : 				ci);

  00223	41 83 ba a0 29
	00 00 00	 cmp	 DWORD PTR [r10+10656], 0
  0022b	74 10		 je	 SHORT $LN51@EncryptDat
  0022d	49 8b 82 18 44
	00 00		 mov	 rax, QWORD PTR [r10+17432]
  00234	48 c1 e8 09	 shr	 rax, 9
  00238	48 2b d8	 sub	 rbx, rax
  0023b	eb 03		 jmp	 SHORT $LN50@EncryptDat
$LN51@EncryptDat:
  0023d	48 ff cb	 dec	 rbx
$LN50@EncryptDat:
  00240	48 c1 e3 05	 shl	 rbx, 5
  00244	48 c1 e7 09	 shl	 rdi, 9
  00248	4d 8b ca	 mov	 r9, r10
  0024b	48 83 cb 01	 or	 rbx, 1
  0024f	48 8b d7	 mov	 rdx, rdi
  00252	49 8b cc	 mov	 rcx, r12
  00255	4c 8b c3	 mov	 r8, rbx
  00258	e8 00 00 00 00	 call	 EncryptBufferLRW128

; 1429 : 			break;

  0025d	e9 9a 00 00 00	 jmp	 $LN17@EncryptDat
$LN13@EncryptDat:

; 1416 : 		{
; 1417 : 		case 8:
; 1418 : 			EncryptBufferLRW64 (buf,
; 1419 : 				(unsigned __int64) nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1420 : 				DataUnit2LRWIndex (unitNo, 8, ci),
; 1421 : 				ci);

  00262	41 83 ba a0 29
	00 00 00	 cmp	 DWORD PTR [r10+10656], 0
  0026a	74 10		 je	 SHORT $LN41@EncryptDat
  0026c	49 8b 82 18 44
	00 00		 mov	 rax, QWORD PTR [r10+17432]
  00273	48 c1 e8 09	 shr	 rax, 9
  00277	48 2b d8	 sub	 rbx, rax
  0027a	eb 03		 jmp	 SHORT $LN40@EncryptDat
$LN41@EncryptDat:
  0027c	48 ff cb	 dec	 rbx
$LN40@EncryptDat:
  0027f	48 c1 e3 06	 shl	 rbx, 6
  00283	48 c1 e7 09	 shl	 rdi, 9
  00287	4d 8b ca	 mov	 r9, r10
  0028a	48 83 cb 01	 or	 rbx, 1
  0028e	48 8b d7	 mov	 rdx, rdi
  00291	49 8b cc	 mov	 rcx, r12
  00294	4c 8b c3	 mov	 r8, rbx
  00297	e8 00 00 00 00	 call	 EncryptBufferLRW64

; 1433 : 		}
; 1434 : 		break;

  0029c	eb 5e		 jmp	 SHORT $LN17@EncryptDat
$LN20@EncryptDat:

; 1393 : 	{
; 1394 : 	case XTS:
; 1395 : 		for (cipher = EAGetFirstCipher (ea); cipher != 0; cipher = EAGetNextCipher (ea, cipher))

  0029e	48 6b f6 2c	 imul	 rsi, 44			; 0000002cH
  002a2	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:EncryptionAlgorithms
  002a9	8b 1c 2e	 mov	 ebx, DWORD PTR [rsi+rbp]
  002ac	85 db		 test	 ebx, ebx
  002ae	74 4c		 je	 SHORT $LN17@EncryptDat
  002b0	48 c1 e7 09	 shl	 rdi, 9
$LL19@EncryptDat:

; 1396 : 		{
; 1397 : 			EncryptBufferXTS (buf,
; 1398 : 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1399 : 				structUnitNo,
; 1400 : 				0,
; 1401 : 				ks,
; 1402 : 				ks2,
; 1403 : 				cipher);

  002b4	4c 8b c2	 mov	 r8, rdx
  002b7	89 5c 24 30	 mov	 DWORD PTR [rsp+48], ebx
  002bb	45 33 c9	 xor	 r9d, r9d
  002be	48 8b d7	 mov	 rdx, rdi
  002c1	49 8b cc	 mov	 rcx, r12
  002c4	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  002c9	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  002ce	e8 00 00 00 00	 call	 EncryptBufferXTS

; 1404 : 
; 1405 : 			ks += CipherGetKeyScheduleSize (cipher);

  002d3	8b cb		 mov	 ecx, ebx
  002d5	e8 00 00 00 00	 call	 CipherGet
  002da	8b d3		 mov	 edx, ebx
  002dc	48 63 48 18	 movsxd	 rcx, DWORD PTR [rax+24]
  002e0	4c 03 e9	 add	 r13, rcx

; 1406 : 			ks2 += CipherGetKeyScheduleSize (cipher);

  002e3	4c 03 f1	 add	 r14, rcx
  002e6	41 8b cf	 mov	 ecx, r15d
  002e9	e8 00 00 00 00	 call	 EAGetNextCipher
  002ee	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR structUnitNo$[rsp]
  002f6	8b d8		 mov	 ebx, eax
  002f8	85 c0		 test	 eax, eax
  002fa	75 b8		 jne	 SHORT $LL19@EncryptDat
$LN17@EncryptDat:

; 1488 : 	}
; 1489 : }

  002fc	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+160]
  00304	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00308	41 5f		 pop	 r15
  0030a	41 5e		 pop	 r14
  0030c	41 5d		 pop	 r13
  0030e	41 5c		 pop	 r12
  00310	5f		 pop	 rdi
  00311	5e		 pop	 rsi
  00312	5d		 pop	 rbp
  00313	c3		 ret	 0
$LN74@EncryptDat:
EncryptDataUnitsCurrentThread ENDP
_TEXT	ENDS
PUBLIC	EncryptBuffer
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptBuffer DD imagerel $LN40
	DD	imagerel $LN40+501
	DD	imagerel $unwind$EncryptBuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptBuffer DD 0a1601H
	DD	0f5416H
	DD	0e3416H
	DD	0e0127216H
	DD	0c00ed010H
	DD	0600b700cH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EncryptBuffer
_TEXT	SEGMENT
buf$ = 112
len$ = 120
dataUnitNo$29301 = 128
cryptoInfo$ = 128
EncryptBuffer PROC					; COMDAT

; 1244 : {

$LN40:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 55		 push	 r13
  00010	41 56		 push	 r14
  00012	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00016	49 8b d8	 mov	 rbx, r8

; 1245 : 	switch (cryptoInfo->mode)

  00019	45 8b 40 04	 mov	 r8d, DWORD PTR [r8+4]
  0001d	41 ba 01 00 00
	00		 mov	 r10d, 1
  00023	45 2b c2	 sub	 r8d, r10d
  00026	48 8b fa	 mov	 rdi, rdx
  00029	48 8b f1	 mov	 rsi, rcx
  0002c	0f 84 38 01 00
	00		 je	 $LN16@EncryptBuf@7
  00032	45 2b c2	 sub	 r8d, r10d
  00035	0f 84 c5 00 00
	00		 je	 $LN12@EncryptBuf@7
  0003b	45 2b c2	 sub	 r8d, r10d
  0003e	74 58		 je	 SHORT $LN6@EncryptBuf@7
  00040	45 2b c2	 sub	 r8d, r10d
  00043	74 24		 je	 SHORT $LN2@EncryptBuf@7
  00045	45 3b c2	 cmp	 r8d, r10d
  00048	74 4e		 je	 SHORT $LN6@EncryptBuf@7

; 1330 : #endif	// #ifndef TC_NO_COMPILER_INT64
; 1331 : 
; 1332 : 	default:		
; 1333 : 		// Unknown/wrong ID
; 1334 : 		TC_THROW_FATAL_EXCEPTION;

  0004a	41 8d 4a 28	 lea	 ecx, QWORD PTR [r10+40]
  0004e	45 33 c9	 xor	 r9d, r9d
  00051	45 33 c0	 xor	 r8d, r8d
  00054	ba 36 05 00 00	 mov	 edx, 1334		; 00000536H
  00059	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00068	cc		 int	 3
$LN2@EncryptBuf@7:

; 1316 : 
; 1317 : 	case OUTER_CBC:
; 1318 : 
; 1319 : 		/* Deprecated/legacy */
; 1320 : 
; 1321 : 		EncryptBufferCBC ((unsigned __int32 *) buf,
; 1322 : 			(unsigned int) len,
; 1323 : 			cryptoInfo->ks,
; 1324 : 			(unsigned __int32 *) cryptoInfo->k2,
; 1325 : 			(unsigned __int32 *) &cryptoInfo->k2[8],
; 1326 : 			cryptoInfo->ea,
; 1327 : 			0);

  00069	83 64 24 30 00	 and	 DWORD PTR [rsp+48], 0
  0006e	8b 03		 mov	 eax, DWORD PTR [rbx]
  00070	48 8d 8b b0 42
	00 00		 lea	 rcx, QWORD PTR [rbx+17072]
  00077	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0007b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00080	4c 8d 8b a8 42
	00 00		 lea	 r9, QWORD PTR [rbx+17064]
  00087	4c 8d 43 08	 lea	 r8, QWORD PTR [rbx+8]
  0008b	48 8b ce	 mov	 rcx, rsi
  0008e	e8 00 00 00 00	 call	 EncryptBufferCBC

; 1328 : 
; 1329 : 		break;

  00093	e9 46 01 00 00	 jmp	 $LN13@EncryptBuf@7
$LN6@EncryptBuf@7:

; 1291 : 
; 1292 : 	case CBC:
; 1293 : 	case INNER_CBC:
; 1294 : 		{
; 1295 : 			/* Deprecated/legacy */
; 1296 : 
; 1297 : 			unsigned __int8 *ks = cryptoInfo->ks;
; 1298 : 			int cipher;
; 1299 : 
; 1300 : 			for (cipher = EAGetFirstCipher (cryptoInfo->ea);
; 1301 : 				cipher != 0;
; 1302 : 				cipher = EAGetNextCipher (cryptoInfo->ea, cipher))

  00098	48 63 03	 movsxd	 rax, DWORD PTR [rbx]
  0009b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  000a2	4c 8d 63 08	 lea	 r12, QWORD PTR [rbx+8]
  000a6	48 6b c0 2c	 imul	 rax, 44			; 0000002cH
  000aa	8b 2c 08	 mov	 ebp, DWORD PTR [rax+rcx]
  000ad	85 ed		 test	 ebp, ebp
  000af	0f 84 29 01 00
	00		 je	 $LN13@EncryptBuf@7
  000b5	4c 8d ab b0 42
	00 00		 lea	 r13, QWORD PTR [rbx+17072]
$LL5@EncryptBuf@7:

; 1303 : 			{
; 1304 : 				EncryptBufferCBC ((unsigned __int32 *) buf,
; 1305 : 					(unsigned int) len,
; 1306 : 					ks,
; 1307 : 					(unsigned __int32 *) cryptoInfo->k2,
; 1308 : 					(unsigned __int32 *) &cryptoInfo->k2[8],
; 1309 : 					0,
; 1310 : 					cipher);

  000bc	89 6c 24 30	 mov	 DWORD PTR [rsp+48], ebp
  000c0	83 64 24 28 00	 and	 DWORD PTR [rsp+40], 0
  000c5	4c 8d 8b a8 42
	00 00		 lea	 r9, QWORD PTR [rbx+17064]
  000cc	4d 8b c4	 mov	 r8, r12
  000cf	8b d7		 mov	 edx, edi
  000d1	48 8b ce	 mov	 rcx, rsi
  000d4	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  000d9	e8 00 00 00 00	 call	 EncryptBufferCBC

; 1311 : 
; 1312 : 				ks += CipherGetKeyScheduleSize (cipher);

  000de	8b cd		 mov	 ecx, ebp
  000e0	e8 00 00 00 00	 call	 CipherGet
  000e5	8b d5		 mov	 edx, ebp
  000e7	48 63 48 18	 movsxd	 rcx, DWORD PTR [rax+24]
  000eb	4c 03 e1	 add	 r12, rcx
  000ee	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  000f0	e8 00 00 00 00	 call	 EAGetNextCipher
  000f5	8b e8		 mov	 ebp, eax
  000f7	85 c0		 test	 eax, eax
  000f9	75 c1		 jne	 SHORT $LL5@EncryptBuf@7

; 1313 : 			}
; 1314 : 		}
; 1315 : 		break;

  000fb	e9 de 00 00 00	 jmp	 $LN13@EncryptBuf@7
$LN12@EncryptBuf@7:

; 1268 : 			}
; 1269 : 		}
; 1270 : 		break;
; 1271 : 
; 1272 : #ifndef TC_NO_COMPILER_INT64
; 1273 : 	case LRW:
; 1274 : 
; 1275 : 		/* Deprecated/legacy */
; 1276 : 
; 1277 : 		switch (CipherGetBlockSize (EAGetFirstCipher (cryptoInfo->ea)))

  00100	48 63 03	 movsxd	 rax, DWORD PTR [rbx]
  00103	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  0010a	48 6b c0 2c	 imul	 rax, 44			; 0000002cH
  0010e	8b 0c 08	 mov	 ecx, DWORD PTR [rax+rcx]
  00111	e8 00 00 00 00	 call	 CipherGet
  00116	83 78 10 08	 cmp	 DWORD PTR [rax+16], 8
  0011a	74 3b		 je	 SHORT $LN9@EncryptBuf@7
  0011c	83 78 10 10	 cmp	 DWORD PTR [rax+16], 16
  00120	74 1f		 je	 SHORT $LN8@EncryptBuf@7

; 1286 : 
; 1287 : 		default:
; 1288 : 			TC_THROW_FATAL_EXCEPTION;

  00122	45 33 c9	 xor	 r9d, r9d
  00125	45 33 c0	 xor	 r8d, r8d
  00128	ba 08 05 00 00	 mov	 edx, 1288		; 00000508H
  0012d	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00131	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  0013a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00140	cc		 int	 3
$LN8@EncryptBuf@7:

; 1281 : 			break;
; 1282 : 
; 1283 : 		case 16:
; 1284 : 			EncryptBufferLRW128 ((unsigned __int8 *)buf, (unsigned __int64) len, 1, cryptoInfo);

  00141	4c 8b cb	 mov	 r9, rbx
  00144	4d 8b c2	 mov	 r8, r10
  00147	48 8b d7	 mov	 rdx, rdi
  0014a	48 8b ce	 mov	 rcx, rsi
  0014d	e8 00 00 00 00	 call	 EncryptBufferLRW128

; 1285 : 			break;

  00152	e9 87 00 00 00	 jmp	 $LN13@EncryptBuf@7
$LN9@EncryptBuf@7:

; 1278 : 		{
; 1279 : 		case 8:
; 1280 : 			EncryptBufferLRW64 ((unsigned __int8 *)buf, (unsigned __int64) len, 1, cryptoInfo);

  00157	4c 8b cb	 mov	 r9, rbx
  0015a	4d 8b c2	 mov	 r8, r10
  0015d	48 8b d7	 mov	 rdx, rdi
  00160	48 8b ce	 mov	 rcx, rsi
  00163	e8 00 00 00 00	 call	 EncryptBufferLRW64

; 1289 : 		}
; 1290 : 		break;

  00168	eb 74		 jmp	 SHORT $LN13@EncryptBuf@7
$LN16@EncryptBuf@7:

; 1246 : 	{
; 1247 : 	case XTS:
; 1248 : 		{
; 1249 : 			unsigned __int8 *ks = cryptoInfo->ks;
; 1250 : 			unsigned __int8 *ks2 = cryptoInfo->ks2;
; 1251 : 			UINT64_STRUCT dataUnitNo;
; 1252 : 			int cipher;
; 1253 : 
; 1254 : 			// When encrypting/decrypting a buffer (typically a volume header) the sequential number
; 1255 : 			// of the first XTS data unit in the buffer is always 0 and the start of the buffer is
; 1256 : 			// always assumed to be aligned with the start of a data unit.
; 1257 : 			dataUnitNo.LowPart = 0;
; 1258 : 			dataUnitNo.HighPart = 0;
; 1259 : 
; 1260 : 			for (cipher = EAGetFirstCipher (cryptoInfo->ea);
; 1261 : 				cipher != 0;
; 1262 : 				cipher = EAGetNextCipher (cryptoInfo->ea, cipher))

  0016a	48 63 03	 movsxd	 rax, DWORD PTR [rbx]
  0016d	83 a4 24 80 00
	00 00 00	 and	 DWORD PTR dataUnitNo$29301[rsp], 0
  00175	83 a4 24 84 00
	00 00 00	 and	 DWORD PTR dataUnitNo$29301[rsp+4], 0
  0017d	48 6b c0 2c	 imul	 rax, 44			; 0000002cH
  00181	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  00188	4c 8d 63 08	 lea	 r12, QWORD PTR [rbx+8]
  0018c	4c 8d ab d4 14
	00 00		 lea	 r13, QWORD PTR [rbx+5332]
  00193	8b 2c 08	 mov	 ebp, DWORD PTR [rax+rcx]
  00196	85 ed		 test	 ebp, ebp
  00198	74 44		 je	 SHORT $LN13@EncryptBuf@7
$LL15@EncryptBuf@7:

; 1263 : 			{
; 1264 : 				EncryptBufferXTS (buf, len, &dataUnitNo, 0, ks, ks2, cipher);

  0019a	89 6c 24 30	 mov	 DWORD PTR [rsp+48], ebp
  0019e	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR dataUnitNo$29301[rsp]
  001a6	45 33 c9	 xor	 r9d, r9d
  001a9	48 8b d7	 mov	 rdx, rdi
  001ac	48 8b ce	 mov	 rcx, rsi
  001af	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  001b4	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  001b9	e8 00 00 00 00	 call	 EncryptBufferXTS

; 1265 : 
; 1266 : 				ks += CipherGetKeyScheduleSize (cipher);

  001be	8b cd		 mov	 ecx, ebp
  001c0	e8 00 00 00 00	 call	 CipherGet
  001c5	8b d5		 mov	 edx, ebp
  001c7	48 63 48 18	 movsxd	 rcx, DWORD PTR [rax+24]
  001cb	4c 03 e1	 add	 r12, rcx

; 1267 : 				ks2 += CipherGetKeyScheduleSize (cipher);

  001ce	4c 03 e9	 add	 r13, rcx
  001d1	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  001d3	e8 00 00 00 00	 call	 EAGetNextCipher
  001d8	8b e8		 mov	 ebp, eax
  001da	85 c0		 test	 eax, eax
  001dc	75 bc		 jne	 SHORT $LL15@EncryptBuf@7
$LN13@EncryptBuf@7:

; 1335 : 	}
; 1336 : }

  001de	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  001e3	48 8b 6c 24 78	 mov	 rbp, QWORD PTR [rsp+120]
  001e8	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001ec	41 5e		 pop	 r14
  001ee	41 5d		 pop	 r13
  001f0	41 5c		 pop	 r12
  001f2	5f		 pop	 rdi
  001f3	5e		 pop	 rsi
  001f4	c3		 ret	 0
$LN39@EncryptBuf@7:
EncryptBuffer ENDP
_TEXT	ENDS
PUBLIC	EAInitMode
;	COMDAT pdata
pdata	SEGMENT
$pdata$EAInitMode DD imagerel $LN20
	DD	imagerel $LN20+213
	DD	imagerel $unwind$EAInitMode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EAInitMode DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EAInitMode
_TEXT	SEGMENT
ci$ = 64
EAInitMode PROC						; COMDAT

; 411  : {

$LN20:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	4c 8b d1	 mov	 r10, rcx

; 412  : 	switch (ci->mode)

  00007	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  0000a	b8 01 00 00 00	 mov	 eax, 1
  0000f	3b c8		 cmp	 ecx, eax
  00011	0f 84 9a 00 00
	00		 je	 $LN10@EAInitMode
  00017	83 f9 02	 cmp	 ecx, 2
  0001a	74 2a		 je	 SHORT $LN8@EAInitMode
  0001c	83 c1 fd	 add	 ecx, -3			; fffffffdH
  0001f	83 f9 02	 cmp	 ecx, 2

; 438  : 		}
; 439  : 
; 440  : 		break;
; 441  : 
; 442  : 	case CBC:
; 443  : 	case INNER_CBC:
; 444  : 	case OUTER_CBC:
; 445  : 		// The mode does not need to be initialized or is initialized elsewhere 
; 446  : 		return TRUE;

  00022	0f 86 a8 00 00
	00		 jbe	 $LN9@EAInitMode

; 447  : 
; 448  : 	default:		
; 449  : 		// Unknown/wrong ID
; 450  : 		TC_THROW_FATAL_EXCEPTION;

  00028	8d 48 28	 lea	 ecx, QWORD PTR [rax+40]
  0002b	45 33 c9	 xor	 r9d, r9d
  0002e	45 33 c0	 xor	 r8d, r8d
  00031	ba c2 01 00 00	 mov	 edx, 450		; 000001c2H
  00036	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00045	cc		 int	 3
$LN8@EAInitMode:

; 417  : 			return FALSE;
; 418  : 
; 419  : 		/* Note: XTS mode could potentially be initialized with a weak key causing all blocks in one data unit
; 420  : 		on the volume to be tweaked with zero tweaks (i.e. 512 bytes of the volume would be encrypted in ECB
; 421  : 		mode). However, to create a CipherShed volume with such a weak key, each human being on Earth would have
; 422  : 		to create approximately 11,378,125,361,078,862 (about eleven quadrillion) CipherShed volumes (provided 
; 423  : 		that the size of each of the volumes is 1024 terabytes). */
; 424  : 		break;
; 425  : 
; 426  : 	case LRW:
; 427  : 		switch (CipherGetBlockSize (EAGetFirstCipher (ci->ea)))

  00046	49 63 02	 movsxd	 rax, DWORD PTR [r10]
  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  00050	48 6b c0 2c	 imul	 rax, 44			; 0000002cH
  00054	8b 0c 08	 mov	 ecx, DWORD PTR [rax+rcx]
  00057	e8 00 00 00 00	 call	 CipherGet
  0005c	83 78 10 08	 cmp	 DWORD PTR [rax+16], 8
  00060	74 3a		 je	 SHORT $LN5@EAInitMode
  00062	83 78 10 10	 cmp	 DWORD PTR [rax+16], 16
  00066	74 1f		 je	 SHORT $LN4@EAInitMode

; 435  : 
; 436  : 		default:
; 437  : 			TC_THROW_FATAL_EXCEPTION;

  00068	45 33 c9	 xor	 r9d, r9d
  0006b	45 33 c0	 xor	 r8d, r8d
  0006e	ba b5 01 00 00	 mov	 edx, 437		; 000001b5H
  00073	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00077	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00080	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00086	cc		 int	 3
$LN4@EAInitMode:

; 432  : 
; 433  : 		case 16:
; 434  : 			return Gf128Tab64Init (ci->k2, &ci->gf_ctx);

  00087	49 8d 92 a8 29
	00 00		 lea	 rdx, QWORD PTR [r10+10664]
  0008e	49 8d 8a a8 42
	00 00		 lea	 rcx, QWORD PTR [r10+17064]
  00095	e8 00 00 00 00	 call	 Gf128Tab64Init
  0009a	eb 34		 jmp	 SHORT $LN9@EAInitMode
$LN5@EAInitMode:

; 428  : 		{
; 429  : 		case 8:
; 430  : 			/* Deprecated/legacy */
; 431  : 			return Gf64TabInit (ci->k2, &ci->gf_ctx);

  0009c	49 8d 92 a8 29
	00 00		 lea	 rdx, QWORD PTR [r10+10664]
  000a3	49 8d 8a a8 42
	00 00		 lea	 rcx, QWORD PTR [r10+17064]
  000aa	e8 00 00 00 00	 call	 Gf64TabInit
  000af	eb 1f		 jmp	 SHORT $LN9@EAInitMode
$LN10@EAInitMode:

; 413  : 	{
; 414  : 	case XTS:
; 415  : 		// Secondary key schedule
; 416  : 		if (EAInit (ci->ea, ci->k2, ci->ks2) != ERR_SUCCESS)

  000b1	41 8b 0a	 mov	 ecx, DWORD PTR [r10]
  000b4	4d 8d 82 d4 14
	00 00		 lea	 r8, QWORD PTR [r10+5332]
  000bb	49 8d 92 a8 42
	00 00		 lea	 rdx, QWORD PTR [r10+17064]
  000c2	e8 00 00 00 00	 call	 EAInit
  000c7	33 c9		 xor	 ecx, ecx
  000c9	3b c1		 cmp	 eax, ecx
  000cb	0f 94 c1	 sete	 cl
  000ce	8b c1		 mov	 eax, ecx
$LN9@EAInitMode:

; 451  : 	}
; 452  : 	return TRUE;
; 453  : }

  000d0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d4	c3		 ret	 0
$LN19@EAInitMode:
EAInitMode ENDP
PUBLIC	DecryptDataUnits
;	COMDAT pdata
pdata	SEGMENT
$pdata$DecryptDataUnits DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$DecryptDataUnits
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecryptDataUnits DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT DecryptDataUnits
_TEXT	SEGMENT
buf$ = 64
structUnitNo$ = 72
nbrUnits$ = 80
ci$ = 88
DecryptDataUnits PROC					; COMDAT

; 1595 : {

$LN3:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1596 : 	EncryptionThreadPoolDoWork (DecryptDataUnitsWork, buf, structUnitNo, nbrUnits, ci);

  00004	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00009	45 8b c8	 mov	 r9d, r8d
  0000c	4c 8b c2	 mov	 r8, rdx
  0000f	48 8b d1	 mov	 rdx, rcx
  00012	b9 01 00 00 00	 mov	 ecx, 1
  00017	e8 00 00 00 00	 call	 EncryptionThreadPoolDoWork

; 1597 : }

  0001c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00020	c3		 ret	 0
DecryptDataUnits ENDP
_TEXT	ENDS
PUBLIC	EncryptDataUnits
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptDataUnits DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$EncryptDataUnits
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptDataUnits DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EncryptDataUnits
_TEXT	SEGMENT
buf$ = 64
structUnitNo$ = 72
nbrUnits$ = 80
ci$ = 88
EncryptDataUnits PROC					; COMDAT

; 1372 : {

$LN3:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1373 : 	EncryptionThreadPoolDoWork (EncryptDataUnitsWork, buf, structUnitNo, nbrUnits, ci);

  00004	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00009	45 8b c8	 mov	 r9d, r8d
  0000c	4c 8b c2	 mov	 r8, rdx
  0000f	48 8b d1	 mov	 rdx, rcx
  00012	33 c9		 xor	 ecx, ecx
  00014	e8 00 00 00 00	 call	 EncryptionThreadPoolDoWork

; 1374 : }

  00019	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0001d	c3		 ret	 0
EncryptDataUnits ENDP
END
