; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	ProbingHostDeviceForWrite
PUBLIC	??_C@_0ED@EAABHCEJ@ZwQueryInformationFile?5failed?5wh@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DF@LEPAODFF@File?5?$CC?$CFls?$CC?5is?5marked?5as?5compress@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BP@BKDGGJEA@Trying?5to?5open?5volume?5type?5?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CA@IGALEGOK@Reading?5volume?5header?5at?5?$CFI64d?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DM@FMJIKGBL@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAH?$AAa?$AAr?$AAd?$AAd?$AAi?$AAs?$AAk?$AA?$CF?$AAd?$AA?2?$AAP?$AAa?$AAr?$AAt?$AAi?$AAt?$AAi?$AAo?$AAn?$AA0?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0FD@BKFNIFNN@Mounting?5partition?5within?5scope?5@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BB@IPFFEHBJ@Cannot?5open?5?$CFls?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BO@FHFPMFGI@Read?5failed?3?5NTSTATUS?50x?$CF08x?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BO@DBKGEMGK@Read?5didn?8t?5read?5enough?5data?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BJ@JCBFCEPL@Volume?5header?5decrypted?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BP@GNIOJEAD@Required?5program?5version?5?$DN?5?$CFx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BE@LHJMDIKA@Legacy?5volume?5?$DN?5?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BO@HCAAKCJO@Hidden?5volume?5offset?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BM@CHOGCNPN@Hidden?5volume?5size?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BL@DBKGLLJI@Hidden?5volume?5end?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DG@NLAOEFNO@Hidden?5volume?5protection?5active?3@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BM@CDNAEGGM@Volume?5data?5offset?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BK@BIKGCOPF@Volume?5data?5size?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BJ@MEKDGODO@Volume?5data?5end?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BH@JONGPBLO@Incorrect?5volume?5size?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BC@MAMPPFNN@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AAU?$AAN?$AAC?$AA?2?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BA@GIIKONIJ@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EE@JIJFFNGM@ZwQueryInformationFile?5failed?5in@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EC@JFODFBAB@ZwSetInformationFile?5failed?5in?5R@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp_wcsncpy:PROC
EXTRN	__imp_wcsstr:PROC
EXTRN	IoFileObjectType:QWORD
EXTRN	__imp__snwprintf:PROC
EXTRN	__imp_ZwQueryInformationFile:PROC
EXTRN	__imp_ZwSetInformationFile:PROC
ProbingHostDeviceForWrite DD 01H DUP (?)
;	COMDAT ??_C@_0EC@JFODFBAB@ZwSetInformationFile?5failed?5in?5R@FNODOBFM@
text$s	SEGMENT
??_C@_0EC@JFODFBAB@ZwSetInformationFile?5failed?5in?5R@FNODOBFM@ DB 'ZwSe'
	DB	'tInformationFile failed in RestoreTimeStamp: NTSTATUS 0x%08x', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EE@JIJFFNGM@ZwQueryInformationFile?5failed?5in@FNODOBFM@
text$s	SEGMENT
??_C@_0EE@JIJFFNGM@ZwQueryInformationFile?5failed?5in@FNODOBFM@ DB 'ZwQue'
	DB	'ryInformationFile failed in RestoreTimeStamp: NTSTATUS 0x%08x'
	DB	0aH, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BA@GIIKONIJ@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BA@GIIKONIJ@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, '?', 00H, '?', 00H, '\', 00H, '\', 00H, '%', 00H, 's', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BC@MAMPPFNN@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AAU?$AAN?$AAC?$AA?2?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BC@MAMPPFNN@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AAU?$AAN?$AAC?$AA?2?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, '?', 00H, '?', 00H, '\', 00H, 'U', 00H, 'N', 00H, 'C', 00H
	DB	'\', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BH@JONGPBLO@Incorrect?5volume?5size?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BH@JONGPBLO@Incorrect?5volume?5size?6?$AA@FNODOBFM@ DB 'Incorrect '
	DB	'volume size', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BJ@MEKDGODO@Volume?5data?5end?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BJ@MEKDGODO@Volume?5data?5end?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@ DB 'V'
	DB	'olume data end = %I64d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BK@BIKGCOPF@Volume?5data?5size?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BK@BIKGCOPF@Volume?5data?5size?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@ DB 'V'
	DB	'olume data size = %I64d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BM@CDNAEGGM@Volume?5data?5offset?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BM@CDNAEGGM@Volume?5data?5offset?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@ DB 'V'
	DB	'olume data offset = %I64d', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DG@NLAOEFNO@Hidden?5volume?5protection?5active?3@FNODOBFM@
text$s	SEGMENT
??_C@_0DG@NLAOEFNO@Hidden?5volume?5protection?5active?3@FNODOBFM@ DB 'Hid'
	DB	'den volume protection active: %I64d-%I64d (%I64d)', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BL@DBKGLLJI@Hidden?5volume?5end?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BL@DBKGLLJI@Hidden?5volume?5end?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@ DB 'H'
	DB	'idden volume end = %I64d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BM@CHOGCNPN@Hidden?5volume?5size?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BM@CHOGCNPN@Hidden?5volume?5size?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@ DB 'H'
	DB	'idden volume size = %I64d', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BO@HCAAKCJO@Hidden?5volume?5offset?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BO@HCAAKCJO@Hidden?5volume?5offset?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@ DB 'H'
	DB	'idden volume offset = %I64d', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BE@LHJMDIKA@Legacy?5volume?5?$DN?5?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BE@LHJMDIKA@Legacy?5volume?5?$DN?5?$CFd?6?$AA@FNODOBFM@ DB 'Legacy'
	DB	' volume = %d', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BP@GNIOJEAD@Required?5program?5version?5?$DN?5?$CFx?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BP@GNIOJEAD@Required?5program?5version?5?$DN?5?$CFx?6?$AA@FNODOBFM@ DB 'R'
	DB	'equired program version = %x', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BJ@JCBFCEPL@Volume?5header?5decrypted?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BJ@JCBFCEPL@Volume?5header?5decrypted?6?$AA@FNODOBFM@ DB 'Volume h'
	DB	'eader decrypted', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BO@DBKGEMGK@Read?5didn?8t?5read?5enough?5data?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BO@DBKGEMGK@Read?5didn?8t?5read?5enough?5data?6?$AA@FNODOBFM@ DB 'R'
	DB	'ead didn''t read enough data', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BO@FHFPMFGI@Read?5failed?3?5NTSTATUS?50x?$CF08x?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BO@FHFPMFGI@Read?5failed?3?5NTSTATUS?50x?$CF08x?6?$AA@FNODOBFM@ DB 'R'
	DB	'ead failed: NTSTATUS 0x%08x', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BB@IPFFEHBJ@Cannot?5open?5?$CFls?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BB@IPFFEHBJ@Cannot?5open?5?$CFls?6?$AA@FNODOBFM@ DB 'Cannot open %'
	DB	'ls', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0FD@BKFNIFNN@Mounting?5partition?5within?5scope?5@FNODOBFM@
text$s	SEGMENT
??_C@_0FD@BKFNIFNN@Mounting?5partition?5within?5scope?5@FNODOBFM@ DB 'Mou'
	DB	'nting partition within scope of system encryption (reading ke'
	DB	'y data from: %ls)', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DM@FMJIKGBL@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAH?$AAa?$AAr?$AAd?$AAd?$AAi?$AAs?$AAk?$AA?$CF?$AAd?$AA?2?$AAP?$AAa?$AAr?$AAt?$AAi?$AAt?$AAi?$AAo?$AAn?$AA0?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DM@FMJIKGBL@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAH?$AAa?$AAr?$AAd?$AAd?$AAi?$AAs?$AAk?$AA?$CF?$AAd?$AA?2?$AAP?$AAa?$AAr?$AAt?$AAi?$AAt?$AAi?$AAo?$AAn?$AA0?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'H', 00H, 'a', 00H, 'r', 00H, 'd', 00H, 'd', 00H, 'i'
	DB	00H, 's', 00H, 'k', 00H, '%', 00H, 'd', 00H, '\', 00H, 'P', 00H
	DB	'a', 00H, 'r', 00H, 't', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'o'
	DB	00H, 'n', 00H, '0', 00H, 00H, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CA@IGALEGOK@Reading?5volume?5header?5at?5?$CFI64d?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0CA@IGALEGOK@Reading?5volume?5header?5at?5?$CFI64d?6?$AA@FNODOBFM@ DB 'R'
	DB	'eading volume header at %I64d', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BP@BKDGGJEA@Trying?5to?5open?5volume?5type?5?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BP@BKDGGJEA@Trying?5to?5open?5volume?5type?5?$CFd?6?$AA@FNODOBFM@ DB 'T'
	DB	'rying to open volume type %d', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DF@LEPAODFF@File?5?$CC?$CFls?$CC?5is?5marked?5as?5compress@FNODOBFM@
text$s	SEGMENT
??_C@_0DF@LEPAODFF@File?5?$CC?$CFls?$CC?5is?5marked?5as?5compress@FNODOBFM@ DB 'F'
	DB	'ile "%ls" is marked as compressed - not supported!', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0ED@EAABHCEJ@ZwQueryInformationFile?5failed?5wh@FNODOBFM@
text$s	SEGMENT
??_C@_0ED@EAABHCEJ@ZwQueryInformationFile?5failed?5wh@FNODOBFM@ DB 'ZwQue'
	DB	'ryInformationFile failed while opening file: NTSTATUS 0x%08x', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
;	COMDAT pdata
; File c:\home\public\desktop\projects\ciphershed.build\src\driver\ntvol.c
pdata	SEGMENT
$pdata$RestoreTimeStamp DD imagerel RestoreTimeStamp
	DD	imagerel RestoreTimeStamp+319
	DD	imagerel $unwind$RestoreTimeStamp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RestoreTimeStamp DD 010901H
	DD	0e209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT RestoreTimeStamp
_TEXT	SEGMENT
IoStatusBlock$ = 48
FileBasicInfo$ = 64
ntStatus$ = 104
Extension$ = 128
RestoreTimeStamp PROC					; COMDAT

; 823  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 824  : 	NTSTATUS ntStatus;
; 825  : 	FILE_BASIC_INFORMATION FileBasicInfo;
; 826  : 	IO_STATUS_BLOCK IoStatusBlock;
; 827  : 
; 828  : 	if (Extension->hDeviceFile != NULL 
; 829  : 		&& Extension->bRawDevice == FALSE 
; 830  : 		&& Extension->bReadOnly == FALSE
; 831  : 		&& Extension->bTimeStampValid)

  00009	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00011	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  00016	0f 84 1e 01 00
	00		 je	 $LN4@RestoreTim
  0001c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00024	83 b8 a4 03 00
	00 00		 cmp	 DWORD PTR [rax+932], 0
  0002b	0f 85 09 01 00
	00		 jne	 $LN4@RestoreTim
  00031	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00039	83 b8 98 03 00
	00 00		 cmp	 DWORD PTR [rax+920], 0
  00040	0f 85 f4 00 00
	00		 jne	 $LN4@RestoreTim
  00046	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  0004e	83 b8 d8 05 00
	00 00		 cmp	 DWORD PTR [rax+1496], 0
  00055	0f 84 df 00 00
	00		 je	 $LN4@RestoreTim

; 832  : 	{
; 833  : 		ntStatus = ZwQueryInformationFile (Extension->hDeviceFile,
; 834  : 			&IoStatusBlock,
; 835  : 			&FileBasicInfo,
; 836  : 			sizeof (FileBasicInfo),
; 837  : 			FileBasicInformation); 

  0005b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00063	41 b9 28 00 00
	00		 mov	 r9d, 40			; 00000028H
  00069	4c 8d 44 24 40	 lea	 r8, QWORD PTR FileBasicInfo$[rsp]
  0006e	48 8d 54 24 30	 lea	 rdx, QWORD PTR IoStatusBlock$[rsp]
  00073	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  0007b	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwQueryInformationFile
  00085	89 44 24 68	 mov	 DWORD PTR ntStatus$[rsp], eax

; 838  : 
; 839  : 		if (!NT_SUCCESS (ntStatus))

  00089	83 7c 24 68 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  0008e	7d 15		 jge	 SHORT $LN3@RestoreTim

; 840  : 		{
; 841  : 			Dump ("ZwQueryInformationFile failed in RestoreTimeStamp: NTSTATUS 0x%08x\n",
; 842  : 				ntStatus);

  00090	8b 54 24 68	 mov	 edx, DWORD PTR ntStatus$[rsp]
  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EE@JIJFFNGM@ZwQueryInformationFile?5failed?5in@FNODOBFM@
  0009b	e8 00 00 00 00	 call	 DbgPrint

; 843  : 		}
; 844  : 		else

  000a0	e9 95 00 00 00	 jmp	 $LN2@RestoreTim
$LN3@RestoreTim:

; 845  : 		{
; 846  : 			FileBasicInfo.CreationTime = Extension->fileCreationTime;

  000a5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  000ad	48 8b 80 b8 05
	00 00		 mov	 rax, QWORD PTR [rax+1464]
  000b4	48 89 44 24 40	 mov	 QWORD PTR FileBasicInfo$[rsp], rax

; 847  : 			FileBasicInfo.LastAccessTime = Extension->fileLastAccessTime;

  000b9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  000c1	48 8b 80 c0 05
	00 00		 mov	 rax, QWORD PTR [rax+1472]
  000c8	48 89 44 24 48	 mov	 QWORD PTR FileBasicInfo$[rsp+8], rax

; 848  : 			FileBasicInfo.LastWriteTime = Extension->fileLastWriteTime;

  000cd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  000d5	48 8b 80 c8 05
	00 00		 mov	 rax, QWORD PTR [rax+1480]
  000dc	48 89 44 24 50	 mov	 QWORD PTR FileBasicInfo$[rsp+16], rax

; 849  : 			FileBasicInfo.ChangeTime = Extension->fileLastChangeTime;

  000e1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  000e9	48 8b 80 d0 05
	00 00		 mov	 rax, QWORD PTR [rax+1488]
  000f0	48 89 44 24 58	 mov	 QWORD PTR FileBasicInfo$[rsp+24], rax

; 850  : 
; 851  : 			ntStatus = ZwSetInformationFile(
; 852  : 				Extension->hDeviceFile,
; 853  : 				&IoStatusBlock,
; 854  : 				&FileBasicInfo,
; 855  : 				sizeof (FileBasicInfo),
; 856  : 				FileBasicInformation); 

  000f5	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000fd	41 b9 28 00 00
	00		 mov	 r9d, 40			; 00000028H
  00103	4c 8d 44 24 40	 lea	 r8, QWORD PTR FileBasicInfo$[rsp]
  00108	48 8d 54 24 30	 lea	 rdx, QWORD PTR IoStatusBlock$[rsp]
  0010d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00115	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  00119	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwSetInformationFile
  0011f	89 44 24 68	 mov	 DWORD PTR ntStatus$[rsp], eax

; 857  : 
; 858  : 			if (!NT_SUCCESS (ntStatus))

  00123	83 7c 24 68 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  00128	7d 10		 jge	 SHORT $LN1@RestoreTim

; 859  : 				Dump ("ZwSetInformationFile failed in RestoreTimeStamp: NTSTATUS 0x%08x\n",ntStatus);

  0012a	8b 54 24 68	 mov	 edx, DWORD PTR ntStatus$[rsp]
  0012e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EC@JFODFBAB@ZwSetInformationFile?5failed?5in?5R@FNODOBFM@
  00135	e8 00 00 00 00	 call	 DbgPrint
$LN1@RestoreTim:
$LN2@RestoreTim:
$LN4@RestoreTim:

; 860  : 		}
; 861  : 	}
; 862  : }

  0013a	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0013e	c3		 ret	 0
RestoreTimeStamp ENDP
_TEXT	ENDS
PUBLIC	COMPLETE_IRP
;	COMDAT pdata
pdata	SEGMENT
$pdata$COMPLETE_IRP DD imagerel $LN4
	DD	imagerel $LN4+72
	DD	imagerel $unwind$COMPLETE_IRP
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$COMPLETE_IRP DD 011801H
	DD	04218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT COMPLETE_IRP
_TEXT	SEGMENT
DeviceObject$ = 48
Irp$ = 56
IrpStatus$ = 64
IrpInformation$ = 72
COMPLETE_IRP PROC					; COMDAT

; 797  : {

$LN4:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 798  : 	Irp->IoStatus.Status = IrpStatus;

  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Irp$[rsp]
  0001d	8b 44 24 40	 mov	 eax, DWORD PTR IrpStatus$[rsp]
  00021	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 799  : 	Irp->IoStatus.Information = IrpInformation;

  00024	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Irp$[rsp]
  00029	48 8b 44 24 48	 mov	 rax, QWORD PTR IrpInformation$[rsp]
  0002e	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 800  : 
; 801  : 	if (DeviceObject);	/* Remove compiler warning */
; 802  : 
; 803  : #if EXTRA_INFO
; 804  : 	if (!NT_SUCCESS (IrpStatus))
; 805  : 	{
; 806  : 		PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);
; 807  : 		Dump ("COMPLETE_IRP FAILING IRP %ls Flags 0x%08x vpb 0x%08x NTSTATUS 0x%08x\n", TCTranslateCode (irpSp->MajorFunction),
; 808  : 		      (ULONG) DeviceObject->Flags, (ULONG) DeviceObject->Vpb->Flags, IrpStatus);
; 809  : 	}
; 810  : 	else
; 811  : 	{
; 812  : 		PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);
; 813  : 		Dump ("COMPLETE_IRP SUCCESS IRP %ls Flags 0x%08x vpb 0x%08x NTSTATUS 0x%08x\n", TCTranslateCode (irpSp->MajorFunction),
; 814  : 		      (ULONG) DeviceObject->Flags, (ULONG) DeviceObject->Vpb->Flags, IrpStatus);
; 815  : 	}
; 816  : #endif
; 817  : 	IoCompleteRequest (Irp, IO_NO_INCREMENT);

  00032	33 d2		 xor	 edx, edx
  00034	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Irp$[rsp]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 818  : 	return IrpStatus;

  0003f	8b 44 24 40	 mov	 eax, DWORD PTR IrpStatus$[rsp]

; 819  : }

  00043	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00047	c3		 ret	 0
COMPLETE_IRP ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCSendHostDeviceIoControlRequest DD imagerel TCSendHostDeviceIoControlRequest
	DD	imagerel TCSendHostDeviceIoControlRequest+299
	DD	imagerel $unwind$TCSendHostDeviceIoControlRequest
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCSendHostDeviceIoControlRequest DD 011801H
	DD	0e218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT TCSendHostDeviceIoControlRequest
_TEXT	SEGMENT
Irp$ = 80
IoStatusBlock$ = 88
ntStatus$ = 104
DeviceObject$ = 128
Extension$ = 136
IoControlCode$ = 144
OutputBuffer$ = 152
OutputBufferSize$ = 160
TCSendHostDeviceIoControlRequest PROC			; COMDAT

; 757  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 758  : 	IO_STATUS_BLOCK IoStatusBlock;
; 759  : 	NTSTATUS ntStatus;
; 760  : 	PIRP Irp;
; 761  : 
; 762  : 	if (DeviceObject);	/* Remove compiler warning */
; 763  : 
; 764  : 	KeClearEvent (&Extension->keVolumeEvent);

  00018	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00020	48 81 c1 c8 00
	00 00		 add	 rcx, 200		; 000000c8H
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeClearEvent

; 765  : 
; 766  : 	Irp = IoBuildDeviceIoControlRequest (IoControlCode,
; 767  : 					     Extension->pFsdDevice,
; 768  : 					     NULL, 0,
; 769  : 					     OutputBuffer, OutputBufferSize,
; 770  : 					     FALSE,
; 771  : 					     &Extension->keVolumeEvent,
; 772  : 					     &IoStatusBlock);

  0002d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00035	48 81 c1 c8 00
	00 00		 add	 rcx, 200		; 000000c8H
  0003c	48 8d 44 24 58	 lea	 rax, QWORD PTR IoStatusBlock$[rsp]
  00041	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00046	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0004b	c6 44 24 30 00	 mov	 BYTE PTR [rsp+48], 0
  00050	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR OutputBufferSize$[rsp]
  00057	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0005b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR OutputBuffer$[rsp]
  00063	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00068	45 33 c9	 xor	 r9d, r9d
  0006b	45 33 c0	 xor	 r8d, r8d
  0006e	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR Extension$[rsp]
  00076	48 8b 92 88 00
	00 00		 mov	 rdx, QWORD PTR [rdx+136]
  0007d	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR IoControlCode$[rsp]
  00084	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoBuildDeviceIoControlRequest
  0008a	48 89 44 24 50	 mov	 QWORD PTR Irp$[rsp], rax

; 773  : 
; 774  : 	if (Irp == NULL)

  0008f	48 83 7c 24 50
	00		 cmp	 QWORD PTR Irp$[rsp], 0
  00095	75 13		 jne	 SHORT $LN2@TCSendHost

; 775  : 	{
; 776  : 		Dump ("IRP allocation failed\n");

  00097	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@BPCEMJJB@IRP?5allocation?5failed?6?$AA@FNODOBFM@
  0009e	e8 00 00 00 00	 call	 DbgPrint

; 777  : 		return STATUS_INSUFFICIENT_RESOURCES;

  000a3	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  000a8	eb 7c		 jmp	 SHORT $LN4@TCSendHost
$LN2@TCSendHost:

; 778  : 	}
; 779  : 
; 780  : 	// Disk device may be used by filesystem driver which needs file object
; 781  : 	IoGetNextIrpStackLocation (Irp) -> FileObject = Extension->pfoDeviceFile;

  000aa	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Irp$[rsp]
  000af	e8 00 00 00 00	 call	 IoGetNextIrpStackLocation
  000b4	4c 8b d8	 mov	 r11, rax
  000b7	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  000bf	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000c6	49 89 43 30	 mov	 QWORD PTR [r11+48], rax

; 782  : 
; 783  : 	ntStatus = IoCallDriver (Extension->pFsdDevice, Irp);

  000ca	48 8b 54 24 50	 mov	 rdx, QWORD PTR Irp$[rsp]
  000cf	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  000d7	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  000de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCallDriver
  000e4	89 44 24 68	 mov	 DWORD PTR ntStatus$[rsp], eax

; 784  : 	if (ntStatus == STATUS_PENDING)

  000e8	81 7c 24 68 03
	01 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 259 ; 00000103H
  000f0	75 30		 jne	 SHORT $LN1@TCSendHost

; 785  : 	{
; 786  : 		KeWaitForSingleObject (&Extension->keVolumeEvent, Executive, KernelMode, FALSE, NULL);

  000f2	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  000fa	48 81 c1 c8 00
	00 00		 add	 rcx, 200		; 000000c8H
  00101	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0010a	45 33 c9	 xor	 r9d, r9d
  0010d	45 33 c0	 xor	 r8d, r8d
  00110	33 d2		 xor	 edx, edx
  00112	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 787  : 		ntStatus = IoStatusBlock.Status;

  00118	44 8b 5c 24 58	 mov	 r11d, DWORD PTR IoStatusBlock$[rsp]
  0011d	44 89 5c 24 68	 mov	 DWORD PTR ntStatus$[rsp], r11d
$LN1@TCSendHost:

; 788  : 	}
; 789  : 
; 790  : 	return ntStatus;

  00122	8b 44 24 68	 mov	 eax, DWORD PTR ntStatus$[rsp]
$LN4@TCSendHost:

; 791  : }

  00126	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0012a	c3		 ret	 0
TCSendHostDeviceIoControlRequest ENDP
_TEXT	ENDS
PUBLIC	TCCloseVolume
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCCloseVolume DD imagerel $LN6
	DD	imagerel $LN6+119
	DD	imagerel $unwind$TCCloseVolume
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCCloseVolume DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT TCCloseVolume
_TEXT	SEGMENT
DeviceObject$ = 48
Extension$ = 56
TCCloseVolume PROC					; COMDAT

; 735  : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 736  : 	if (DeviceObject);	/* Remove compiler warning */
; 737  : 
; 738  : 	if (Extension->hDeviceFile != NULL)

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR Extension$[rsp]
  00013	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  00018	74 35		 je	 SHORT $LN2@TCCloseVol

; 739  : 	{
; 740  : 		if (Extension->bRawDevice == FALSE
; 741  : 			&& Extension->bTimeStampValid)

  0001a	48 8b 44 24 38	 mov	 rax, QWORD PTR Extension$[rsp]
  0001f	83 b8 a4 03 00
	00 00		 cmp	 DWORD PTR [rax+932], 0
  00026	75 18		 jne	 SHORT $LN1@TCCloseVol
  00028	48 8b 44 24 38	 mov	 rax, QWORD PTR Extension$[rsp]
  0002d	83 b8 d8 05 00
	00 00		 cmp	 DWORD PTR [rax+1496], 0
  00034	74 0a		 je	 SHORT $LN1@TCCloseVol

; 742  : 		{
; 743  : 			RestoreTimeStamp (Extension);

  00036	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  0003b	e8 00 00 00 00	 call	 RestoreTimeStamp
$LN1@TCCloseVol:

; 744  : 		}
; 745  : 		ZwClose (Extension->hDeviceFile);

  00040	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  00045	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
$LN2@TCCloseVol:

; 746  : 	}
; 747  : 	ObDereferenceObject (Extension->pfoDeviceFile);

  0004f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  00054	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 748  : 	crypto_close (Extension->cryptoInfo);

  00061	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  00066	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  0006d	e8 00 00 00 00	 call	 crypto_close

; 749  : }

  00072	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00076	c3		 ret	 0
TCCloseVolume ENDP
PUBLIC	__$ArrayPad$
PUBLIC	TCOpenVolume
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCOpenVolume DD imagerel $LN141
	DD	imagerel $LN141+7161
	DD	imagerel $unwind$TCOpenVolume
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCOpenVolume DD 032e19H
	DD	068011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0338H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT TCOpenVolume
_TEXT	SEGMENT
exclusiveAccess$ = 96
FullFileName$ = 104
cryptoInfoPtr$ = 120
IoStatusBlock$ = 128
oaFileAttributes$ = 144
FileBasicInfo$ = 192
disableBuffering$ = 232
readBuffer$ = 240
forceAccessCheck$ = 248
lDiskLength$ = 256
FileStandardInfo$ = 264
volumeType$ = 288
ntStatus$ = 292
partitionStartingOffset$ = 296
tmpCryptoInfo$ = 304
pix$30876 = 320
diskLengthInfo$30877 = 464
pi$30875 = 472
dg$30878 = 504
pfoTmpDeviceFile$30931 = 528
headerOffset$30953 = 536
parentDrivePath$30971 = 560
parentKeyDataOffset$30976 = 656
oaParentFileAttributes$30975 = 664
hParentDeviceFile$30972 = 712
FullParentPath$30974 = 720
tv67 = 736
tv75 = 740
tv205 = 744
tv228 = 748
tv234 = 752
tv252 = 756
tv258 = 760
tv348 = 764
tv368 = 768
tv372 = 776
tv377 = 784
tv395 = 792
tv397 = 796
tv474 = 800
tv519 = 804
tv597 = 808
tv625 = 816
__$ArrayPad$ = 824
DeviceObject$ = 848
Extension$ = 856
mount$ = 864
pwszMountVolume$ = 872
bRawDevice$ = 880
TCOpenVolume PROC					; COMDAT

; 41   : {

$LN141:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 40 03
	00 00		 sub	 rsp, 832		; 00000340H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 38
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 42   : 	FILE_STANDARD_INFORMATION FileStandardInfo;
; 43   : 	FILE_BASIC_INFORMATION FileBasicInfo;
; 44   : 	OBJECT_ATTRIBUTES oaFileAttributes;
; 45   : 	UNICODE_STRING FullFileName;
; 46   : 	IO_STATUS_BLOCK IoStatusBlock;
; 47   : 	PCRYPTO_INFO cryptoInfoPtr = NULL;

  0002e	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR cryptoInfoPtr$[rsp], 0

; 48   : 	PCRYPTO_INFO tmpCryptoInfo = NULL;

  00037	48 c7 84 24 30
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tmpCryptoInfo$[rsp], 0

; 49   : 	LARGE_INTEGER lDiskLength;
; 50   : 	__int64 partitionStartingOffset = 0;

  00043	48 c7 84 24 28
	01 00 00 00 00
	00 00		 mov	 QWORD PTR partitionStartingOffset$[rsp], 0

; 51   : 	int volumeType;
; 52   : 	char *readBuffer = 0;

  0004f	48 c7 84 24 f0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR readBuffer$[rsp], 0

; 53   : 	NTSTATUS ntStatus = 0;

  0005b	c7 84 24 24 01
	00 00 00 00 00
	00		 mov	 DWORD PTR ntStatus$[rsp], 0

; 54   : 	BOOL forceAccessCheck = (!bRawDevice && !(OsMajorVersion == 5 &&OsMinorVersion == 0)); // Windows 2000 does not support OBJ_FORCE_ACCESS_CHECK attribute

  00066	83 bc 24 70 03
	00 00 00	 cmp	 DWORD PTR bRawDevice$[rsp], 0
  0006e	75 1f		 jne	 SHORT $LN111@TCOpenVolu
  00070	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR OsMajorVersion, 5
  00077	75 09		 jne	 SHORT $LN110@TCOpenVolu
  00079	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR OsMinorVersion, 0
  00080	74 0d		 je	 SHORT $LN111@TCOpenVolu
$LN110@TCOpenVolu:
  00082	c7 84 24 e0 02
	00 00 01 00 00
	00		 mov	 DWORD PTR tv67[rsp], 1
  0008d	eb 0b		 jmp	 SHORT $LN112@TCOpenVolu
$LN111@TCOpenVolu:
  0008f	c7 84 24 e0 02
	00 00 00 00 00
	00		 mov	 DWORD PTR tv67[rsp], 0
$LN112@TCOpenVolu:
  0009a	8b 84 24 e0 02
	00 00		 mov	 eax, DWORD PTR tv67[rsp]
  000a1	89 84 24 f8 00
	00 00		 mov	 DWORD PTR forceAccessCheck$[rsp], eax

; 55   : 	BOOL disableBuffering = TRUE;

  000a8	c7 84 24 e8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR disableBuffering$[rsp], 1

; 56   : 	BOOL exclusiveAccess = mount->bExclusiveAccess;

  000b3	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  000bb	8b 80 74 02 00
	00		 mov	 eax, DWORD PTR [rax+628]
  000c1	89 44 24 60	 mov	 DWORD PTR exclusiveAccess$[rsp], eax

; 57   : 
; 58   : 	Extension->pfoDeviceFile = NULL;

  000c5	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  000cd	48 c7 80 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+128], 0

; 59   : 	Extension->hDeviceFile = NULL;

  000d8	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  000e0	48 c7 40 78 00
	00 00 00	 mov	 QWORD PTR [rax+120], 0

; 60   : 	Extension->bTimeStampValid = FALSE;

  000e8	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  000f0	c7 80 d8 05 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1496], 0

; 61   : 
; 62   : 	RtlInitUnicodeString (&FullFileName, pwszMountVolume);

  000fa	48 8b 94 24 68
	03 00 00	 mov	 rdx, QWORD PTR pwszMountVolume$[rsp]
  00102	48 8d 4c 24 68	 lea	 rcx, QWORD PTR FullFileName$[rsp]
  00107	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 63   : 	InitializeObjectAttributes (&oaFileAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | (forceAccessCheck ? OBJ_FORCE_ACCESS_CHECK : 0) | OBJ_KERNEL_HANDLE, NULL, NULL);

  0010d	c7 84 24 90 00
	00 00 30 00 00
	00		 mov	 DWORD PTR oaFileAttributes$[rsp], 48 ; 00000030H
  00118	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR oaFileAttributes$[rsp+8], 0
  00124	83 bc 24 f8 00
	00 00 00	 cmp	 DWORD PTR forceAccessCheck$[rsp], 0
  0012c	74 0d		 je	 SHORT $LN113@TCOpenVolu
  0012e	c7 84 24 e4 02
	00 00 00 04 00
	00		 mov	 DWORD PTR tv75[rsp], 1024 ; 00000400H
  00139	eb 0b		 jmp	 SHORT $LN114@TCOpenVolu
$LN113@TCOpenVolu:
  0013b	c7 84 24 e4 02
	00 00 00 00 00
	00		 mov	 DWORD PTR tv75[rsp], 0
$LN114@TCOpenVolu:
  00146	8b 84 24 e4 02
	00 00		 mov	 eax, DWORD PTR tv75[rsp]
  0014d	83 c8 40	 or	 eax, 64			; 00000040H
  00150	0d 00 02 00 00	 or	 eax, 512		; 00000200H
  00155	89 84 24 a8 00
	00 00		 mov	 DWORD PTR oaFileAttributes$[rsp+24], eax
  0015c	48 8d 44 24 68	 lea	 rax, QWORD PTR FullFileName$[rsp]
  00161	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR oaFileAttributes$[rsp+16], rax
  00169	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR oaFileAttributes$[rsp+32], 0
  00175	48 c7 84 24 b8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR oaFileAttributes$[rsp+40], 0

; 64   : 	KeInitializeEvent (&Extension->keVolumeEvent, NotificationEvent, FALSE);

  00181	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00189	48 81 c1 c8 00
	00 00		 add	 rcx, 200		; 000000c8H
  00190	45 33 c0	 xor	 r8d, r8d
  00193	33 d2		 xor	 edx, edx
  00195	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 65   : 
; 66   : 	if (Extension->SecurityClientContextValid)

  0019b	48 8b 94 24 58
	03 00 00	 mov	 rdx, QWORD PTR Extension$[rsp]
  001a3	83 ba e8 05 00
	00 00		 cmp	 DWORD PTR [rdx+1512], 0
  001aa	74 2d		 je	 SHORT $LN107@TCOpenVolu

; 67   : 	{
; 68   : 		ntStatus = SeImpersonateClientEx (&Extension->SecurityClientContext, NULL);

  001ac	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  001b4	48 81 c1 f0 05
	00 00		 add	 rcx, 1520		; 000005f0H
  001bb	33 d2		 xor	 edx, edx
  001bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeImpersonateClientEx
  001c3	89 84 24 24 01
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 69   : 		if (!NT_SUCCESS (ntStatus))

  001ca	83 bc 24 24 01
	00 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  001d2	7d 05		 jge	 SHORT $LN106@TCOpenVolu

; 70   : 			goto error;

  001d4	e9 04 19 00 00	 jmp	 $error$30873
$LN106@TCOpenVolu:
$LN107@TCOpenVolu:

; 71   : 	}
; 72   : 
; 73   : 	mount->VolumeMountedReadOnlyAfterDeviceWriteProtected = FALSE;

  001d9	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  001e1	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 74   : 
; 75   : 	// If we are opening a device, query its size first
; 76   : 	if (bRawDevice)

  001e8	83 bc 24 70 03
	00 00 00	 cmp	 DWORD PTR bRawDevice$[rsp], 0
  001f0	0f 84 6c 02 00
	00		 je	 $LN105@TCOpenVolu

; 77   : 	{
; 78   : 		PARTITION_INFORMATION pi;
; 79   : 		PARTITION_INFORMATION_EX pix;
; 80   : 		LARGE_INTEGER diskLengthInfo;
; 81   : 		DISK_GEOMETRY dg;
; 82   : 
; 83   : 		ntStatus = IoGetDeviceObjectPointer (&FullFileName,
; 84   : 			FILE_READ_DATA | FILE_READ_ATTRIBUTES,
; 85   : 			&Extension->pfoDeviceFile,
; 86   : 			&Extension->pFsdDevice);

  001f6	4c 8b 8c 24 58
	03 00 00	 mov	 r9, QWORD PTR Extension$[rsp]
  001fe	49 81 c1 88 00
	00 00		 add	 r9, 136			; 00000088H
  00205	4c 8b 84 24 58
	03 00 00	 mov	 r8, QWORD PTR Extension$[rsp]
  0020d	49 81 c0 80 00
	00 00		 add	 r8, 128			; 00000080H
  00214	ba 81 00 00 00	 mov	 edx, 129		; 00000081H
  00219	48 8d 4c 24 68	 lea	 rcx, QWORD PTR FullFileName$[rsp]
  0021e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetDeviceObjectPointer
  00224	89 84 24 24 01
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 87   : 
; 88   : 		if (!NT_SUCCESS (ntStatus))

  0022b	83 bc 24 24 01
	00 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  00233	7d 05		 jge	 SHORT $LN104@TCOpenVolu

; 89   : 			goto error;

  00235	e9 a3 18 00 00	 jmp	 $error$30873
$LN104@TCOpenVolu:

; 90   : 
; 91   : 		ntStatus = TCSendHostDeviceIoControlRequest (DeviceObject, Extension, IOCTL_DISK_GET_DRIVE_GEOMETRY, (char *) &dg, sizeof (dg));

  0023a	c7 44 24 20 18
	00 00 00	 mov	 DWORD PTR [rsp+32], 24
  00242	4c 8d 8c 24 f8
	01 00 00	 lea	 r9, QWORD PTR dg$30878[rsp]
  0024a	41 b8 00 00 07
	00		 mov	 r8d, 458752		; 00070000H
  00250	48 8b 94 24 58
	03 00 00	 mov	 rdx, QWORD PTR Extension$[rsp]
  00258	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  00260	e8 00 00 00 00	 call	 TCSendHostDeviceIoControlRequest
  00265	89 84 24 24 01
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 92   : 		if (!NT_SUCCESS (ntStatus))

  0026c	83 bc 24 24 01
	00 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  00274	7d 05		 jge	 SHORT $LN103@TCOpenVolu

; 93   : 			goto error;

  00276	e9 62 18 00 00	 jmp	 $error$30873
$LN103@TCOpenVolu:

; 94   : 
; 95   : 		lDiskLength.QuadPart = dg.Cylinders.QuadPart * dg.SectorsPerTrack * dg.TracksPerCylinder * dg.BytesPerSector;

  0027b	8b 8c 24 08 02
	00 00		 mov	 ecx, DWORD PTR dg$30878[rsp+16]
  00282	48 8b 84 24 f8
	01 00 00	 mov	 rax, QWORD PTR dg$30878[rsp]
  0028a	48 0f af c1	 imul	 rax, rcx
  0028e	8b 8c 24 04 02
	00 00		 mov	 ecx, DWORD PTR dg$30878[rsp+12]
  00295	48 0f af c1	 imul	 rax, rcx
  00299	8b 8c 24 0c 02
	00 00		 mov	 ecx, DWORD PTR dg$30878[rsp+20]
  002a0	48 0f af c1	 imul	 rax, rcx
  002a4	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR lDiskLength$[rsp], rax

; 96   : 		Extension->HostBytesPerSector = dg.BytesPerSector;

  002ac	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  002b4	8b 84 24 0c 02
	00 00		 mov	 eax, DWORD PTR dg$30878[rsp+20]
  002bb	89 81 c0 00 00
	00		 mov	 DWORD PTR [rcx+192], eax

; 97   : 
; 98   : 		// Drive geometry is used only when IOCTL_DISK_GET_PARTITION_INFO fails
; 99   : 		if (NT_SUCCESS (TCSendHostDeviceIoControlRequest (DeviceObject, Extension, IOCTL_DISK_GET_PARTITION_INFO_EX, (char *) &pix, sizeof (pix))))

  002c1	c7 44 24 20 90
	00 00 00	 mov	 DWORD PTR [rsp+32], 144	; 00000090H
  002c9	4c 8d 8c 24 40
	01 00 00	 lea	 r9, QWORD PTR pix$30876[rsp]
  002d1	41 b8 48 00 07
	00		 mov	 r8d, 458824		; 00070048H
  002d7	48 8b 94 24 58
	03 00 00	 mov	 rdx, QWORD PTR Extension$[rsp]
  002df	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  002e7	e8 00 00 00 00	 call	 TCSendHostDeviceIoControlRequest
  002ec	85 c0		 test	 eax, eax
  002ee	7c 25		 jl	 SHORT $LN102@TCOpenVolu

; 100  : 		{
; 101  : 			lDiskLength.QuadPart = pix.PartitionLength.QuadPart;

  002f0	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR pix$30876[rsp+16]
  002f8	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR lDiskLength$[rsp], rax

; 102  : 			partitionStartingOffset = pix.StartingOffset.QuadPart;

  00300	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR pix$30876[rsp+8]
  00308	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR partitionStartingOffset$[rsp], rax
  00310	e9 90 00 00 00	 jmp	 $LN101@TCOpenVolu
$LN102@TCOpenVolu:

; 103  : 		}
; 104  : 		// Windows 2000 does not support IOCTL_DISK_GET_PARTITION_INFO_EX
; 105  : 		else if (NT_SUCCESS (TCSendHostDeviceIoControlRequest (DeviceObject, Extension, IOCTL_DISK_GET_PARTITION_INFO, (char *) &pi, sizeof (pi))))

  00315	c7 44 24 20 20
	00 00 00	 mov	 DWORD PTR [rsp+32], 32	; 00000020H
  0031d	4c 8d 8c 24 d8
	01 00 00	 lea	 r9, QWORD PTR pi$30875[rsp]
  00325	41 b8 04 40 07
	00		 mov	 r8d, 475140		; 00074004H
  0032b	48 8b 94 24 58
	03 00 00	 mov	 rdx, QWORD PTR Extension$[rsp]
  00333	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  0033b	e8 00 00 00 00	 call	 TCSendHostDeviceIoControlRequest
  00340	85 c0		 test	 eax, eax
  00342	7c 22		 jl	 SHORT $LN100@TCOpenVolu

; 106  : 		{
; 107  : 			lDiskLength.QuadPart = pi.PartitionLength.QuadPart;

  00344	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pi$30875[rsp+8]
  0034c	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR lDiskLength$[rsp], rax

; 108  : 			partitionStartingOffset = pi.StartingOffset.QuadPart;

  00354	48 8b 84 24 d8
	01 00 00	 mov	 rax, QWORD PTR pi$30875[rsp]
  0035c	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR partitionStartingOffset$[rsp], rax
  00364	eb 3f		 jmp	 SHORT $LN99@TCOpenVolu
$LN100@TCOpenVolu:

; 109  : 		}
; 110  : 		else if (NT_SUCCESS (TCSendHostDeviceIoControlRequest (DeviceObject, Extension, IOCTL_DISK_GET_LENGTH_INFO, &diskLengthInfo, sizeof (diskLengthInfo))))

  00366	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  0036e	4c 8d 8c 24 d0
	01 00 00	 lea	 r9, QWORD PTR diskLengthInfo$30877[rsp]
  00376	41 b8 5c 40 07
	00		 mov	 r8d, 475228		; 0007405cH
  0037c	48 8b 94 24 58
	03 00 00	 mov	 rdx, QWORD PTR Extension$[rsp]
  00384	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  0038c	e8 00 00 00 00	 call	 TCSendHostDeviceIoControlRequest
  00391	85 c0		 test	 eax, eax
  00393	7c 10		 jl	 SHORT $LN98@TCOpenVolu

; 111  : 		{
; 112  : 			lDiskLength = diskLengthInfo;

  00395	48 8b 84 24 d0
	01 00 00	 mov	 rax, QWORD PTR diskLengthInfo$30877[rsp]
  0039d	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR lDiskLength$[rsp], rax
$LN98@TCOpenVolu:
$LN99@TCOpenVolu:
$LN101@TCOpenVolu:

; 113  : 		}
; 114  : 
; 115  : 		ProbingHostDeviceForWrite = TRUE;

  003a5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ProbingHostDeviceForWrite, 1

; 116  : 
; 117  : 		if (!mount->bMountReadOnly
; 118  : 			&& TCSendHostDeviceIoControlRequest (DeviceObject, Extension,
; 119  : 				IsHiddenSystemRunning() ? TC_IOCTL_DISK_IS_WRITABLE : IOCTL_DISK_IS_WRITABLE, NULL, 0) == STATUS_MEDIA_WRITE_PROTECTED)

  003af	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  003b7	83 b8 6c 02 00
	00 00		 cmp	 DWORD PTR [rax+620], 0
  003be	0f 85 8a 00 00
	00		 jne	 $LN97@TCOpenVolu
  003c4	e8 00 00 00 00	 call	 IsHiddenSystemRunning
  003c9	85 c0		 test	 eax, eax
  003cb	74 0d		 je	 SHORT $LN115@TCOpenVolu
  003cd	c7 84 24 e8 02
	00 00 74 20 22
	00		 mov	 DWORD PTR tv205[rsp], 2236532 ; 00222074H
  003d8	eb 0b		 jmp	 SHORT $LN116@TCOpenVolu
$LN115@TCOpenVolu:
  003da	c7 84 24 e8 02
	00 00 24 00 07
	00		 mov	 DWORD PTR tv205[rsp], 458788 ; 00070024H
$LN116@TCOpenVolu:
  003e5	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  003ed	45 33 c9	 xor	 r9d, r9d
  003f0	44 8b 84 24 e8
	02 00 00	 mov	 r8d, DWORD PTR tv205[rsp]
  003f8	48 8b 94 24 58
	03 00 00	 mov	 rdx, QWORD PTR Extension$[rsp]
  00400	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  00408	e8 00 00 00 00	 call	 TCSendHostDeviceIoControlRequest
  0040d	3d a2 00 00 c0	 cmp	 eax, -1073741662	; ffffffffc00000a2H
  00412	75 3a		 jne	 SHORT $LN97@TCOpenVolu

; 120  : 		{
; 121  : 			mount->bMountReadOnly = TRUE;

  00414	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  0041c	c7 80 6c 02 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+620], 1

; 122  : 			DeviceObject->Characteristics |= FILE_READ_ONLY_DEVICE;

  00426	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  0042e	8b 48 34	 mov	 ecx, DWORD PTR [rax+52]
  00431	83 c9 02	 or	 ecx, 2
  00434	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  0043c	89 48 34	 mov	 DWORD PTR [rax+52], ecx

; 123  : 			mount->VolumeMountedReadOnlyAfterDeviceWriteProtected = TRUE;

  0043f	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  00447	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [rax+12], 1
$LN97@TCOpenVolu:

; 124  : 		}
; 125  : 
; 126  : 		ProbingHostDeviceForWrite = FALSE;

  0044e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ProbingHostDeviceForWrite, 0

; 127  : 
; 128  : 		// Some Windows tools (e.g. diskmgmt, diskpart, vssadmin) fail or experience timeouts when there is a raw device
; 129  : 		// open for exclusive access. Therefore, exclusive access is used only for file-hosted volumes.
; 130  : 		// Applications requiring a consistent device image need to acquire exclusive write access first. This is prevented
; 131  : 		// when a device-hosted volume is mounted.
; 132  : 
; 133  : 		exclusiveAccess = FALSE;

  00458	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR exclusiveAccess$[rsp], 0

; 134  : 	}
; 135  : 	else

  00460	eb 61		 jmp	 SHORT $LN96@TCOpenVolu
$LN105@TCOpenVolu:

; 136  : 	{
; 137  : 		// Limit the maximum required buffer size
; 138  : 		if (mount->BytesPerSector > 128 * BYTES_PER_KB)

  00462	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  0046a	8b 80 68 02 00
	00		 mov	 eax, DWORD PTR [rax+616]
  00470	48 3d 00 00 02
	00		 cmp	 rax, 131072		; 00020000H
  00476	7e 10		 jle	 SHORT $LN95@TCOpenVolu

; 139  : 		{
; 140  : 			ntStatus = STATUS_INVALID_PARAMETER;

  00478	c7 84 24 24 01
	00 00 0d 00 00
	c0		 mov	 DWORD PTR ntStatus$[rsp], -1073741811 ; ffffffffc000000dH

; 141  : 			goto error;

  00483	e9 55 16 00 00	 jmp	 $error$30873
$LN95@TCOpenVolu:

; 142  : 		}
; 143  : 
; 144  : 		Extension->HostBytesPerSector = mount->BytesPerSector;

  00488	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00490	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  00498	8b 80 68 02 00
	00		 mov	 eax, DWORD PTR [rax+616]
  0049e	89 81 c0 00 00
	00		 mov	 DWORD PTR [rcx+192], eax

; 145  : 
; 146  : 		if (Extension->HostBytesPerSector != TC_SECTOR_SIZE_FILE_HOSTED_VOLUME)

  004a4	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  004ac	81 b8 c0 00 00
	00 00 02 00 00	 cmp	 DWORD PTR [rax+192], 512 ; 00000200H
  004b6	74 0b		 je	 SHORT $LN94@TCOpenVolu

; 147  : 			disableBuffering = FALSE;

  004b8	c7 84 24 e8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR disableBuffering$[rsp], 0
$LN94@TCOpenVolu:
$LN96@TCOpenVolu:

; 148  : 	}
; 149  : 
; 150  : 	// Open the volume hosting file/device
; 151  : 	if (!mount->bMountReadOnly)

  004c3	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  004cb	83 b8 6c 02 00
	00 00		 cmp	 DWORD PTR [rax+620], 0
  004d2	0f 85 b7 00 00
	00		 jne	 $LN93@TCOpenVolu

; 152  : 	{
; 153  : 		ntStatus = ZwCreateFile (&Extension->hDeviceFile,
; 154  : 			GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
; 155  : 			&oaFileAttributes,
; 156  : 			&IoStatusBlock,
; 157  : 			NULL,
; 158  : 			FILE_ATTRIBUTE_NORMAL |
; 159  : 			FILE_ATTRIBUTE_SYSTEM,
; 160  : 			exclusiveAccess ? 0 : FILE_SHARE_READ | FILE_SHARE_WRITE,
; 161  : 			FILE_OPEN,
; 162  : 			FILE_RANDOM_ACCESS |
; 163  : 			FILE_WRITE_THROUGH |
; 164  : 			(disableBuffering ? FILE_NO_INTERMEDIATE_BUFFERING : 0) |
; 165  : 			FILE_SYNCHRONOUS_IO_NONALERT,
; 166  : 			NULL,
; 167  : 			0);

  004d8	83 bc 24 e8 00
	00 00 00	 cmp	 DWORD PTR disableBuffering$[rsp], 0
  004e0	74 0d		 je	 SHORT $LN117@TCOpenVolu
  004e2	c7 84 24 ec 02
	00 00 08 00 00
	00		 mov	 DWORD PTR tv228[rsp], 8
  004ed	eb 0b		 jmp	 SHORT $LN118@TCOpenVolu
$LN117@TCOpenVolu:
  004ef	c7 84 24 ec 02
	00 00 00 00 00
	00		 mov	 DWORD PTR tv228[rsp], 0
$LN118@TCOpenVolu:
  004fa	83 7c 24 60 00	 cmp	 DWORD PTR exclusiveAccess$[rsp], 0
  004ff	74 0d		 je	 SHORT $LN119@TCOpenVolu
  00501	c7 84 24 f0 02
	00 00 00 00 00
	00		 mov	 DWORD PTR tv234[rsp], 0
  0050c	eb 0b		 jmp	 SHORT $LN120@TCOpenVolu
$LN119@TCOpenVolu:
  0050e	c7 84 24 f0 02
	00 00 03 00 00
	00		 mov	 DWORD PTR tv234[rsp], 3
$LN120@TCOpenVolu:
  00519	8b 84 24 ec 02
	00 00		 mov	 eax, DWORD PTR tv228[rsp]
  00520	0d 02 08 00 00	 or	 eax, 2050		; 00000802H
  00525	83 c8 20	 or	 eax, 32			; 00000020H
  00528	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00530	48 83 c1 78	 add	 rcx, 120		; 00000078H
  00534	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR [rsp+80], 0
  0053c	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR [rsp+72], 0
  00545	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00549	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR [rsp+56], 1
  00551	8b 84 24 f0 02
	00 00		 mov	 eax, DWORD PTR tv234[rsp]
  00558	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0055c	c7 44 24 28 84
	00 00 00	 mov	 DWORD PTR [rsp+40], 132	; 00000084H
  00564	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0056d	4c 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR IoStatusBlock$[rsp]
  00575	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR oaFileAttributes$[rsp]
  0057d	ba 00 00 10 c0	 mov	 edx, -1072693248	; c0100000H
  00582	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwCreateFile
  00588	89 84 24 24 01
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax
$LN93@TCOpenVolu:

; 168  : 	}
; 169  : 
; 170  : 	/* 26-4-99 NT for some partitions returns this code, it is really a	access denied */
; 171  : 	if (ntStatus == 0xc000001b)

  0058f	81 bc 24 24 01
	00 00 1b 00 00
	c0		 cmp	 DWORD PTR ntStatus$[rsp], -1073741797 ; c000001bH
  0059a	75 0b		 jne	 SHORT $LN92@TCOpenVolu

; 172  : 		ntStatus = STATUS_ACCESS_DENIED;

  0059c	c7 84 24 24 01
	00 00 22 00 00
	c0		 mov	 DWORD PTR ntStatus$[rsp], -1073741790 ; ffffffffc0000022H
$LN92@TCOpenVolu:

; 173  : 
; 174  : 	mount->VolumeMountedReadOnlyAfterAccessDenied = FALSE;

  005a7	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  005af	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 175  : 
; 176  : 	if (mount->bMountReadOnly || ntStatus == STATUS_ACCESS_DENIED)

  005b6	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  005be	83 b8 6c 02 00
	00 00		 cmp	 DWORD PTR [rax+620], 0
  005c5	75 11		 jne	 SHORT $LN90@TCOpenVolu
  005c7	81 bc 24 24 01
	00 00 22 00 00
	c0		 cmp	 DWORD PTR ntStatus$[rsp], -1073741790 ; ffffffffc0000022H
  005d2	0f 85 0e 01 00
	00		 jne	 $LN91@TCOpenVolu
$LN90@TCOpenVolu:

; 177  : 	{
; 178  : 		ntStatus = ZwCreateFile (&Extension->hDeviceFile,
; 179  : 			GENERIC_READ | SYNCHRONIZE,
; 180  : 			&oaFileAttributes,
; 181  : 			&IoStatusBlock,
; 182  : 			NULL,
; 183  : 			FILE_ATTRIBUTE_NORMAL |
; 184  : 			FILE_ATTRIBUTE_SYSTEM,
; 185  : 			exclusiveAccess ? FILE_SHARE_READ : FILE_SHARE_READ | FILE_SHARE_WRITE,
; 186  : 			FILE_OPEN,
; 187  : 			FILE_RANDOM_ACCESS |
; 188  : 			FILE_WRITE_THROUGH |
; 189  : 			(disableBuffering ? FILE_NO_INTERMEDIATE_BUFFERING : 0) |
; 190  : 			FILE_SYNCHRONOUS_IO_NONALERT,
; 191  : 			NULL,
; 192  : 			0);

  005d8	83 bc 24 e8 00
	00 00 00	 cmp	 DWORD PTR disableBuffering$[rsp], 0
  005e0	74 0d		 je	 SHORT $LN121@TCOpenVolu
  005e2	c7 84 24 f4 02
	00 00 08 00 00
	00		 mov	 DWORD PTR tv252[rsp], 8
  005ed	eb 0b		 jmp	 SHORT $LN122@TCOpenVolu
$LN121@TCOpenVolu:
  005ef	c7 84 24 f4 02
	00 00 00 00 00
	00		 mov	 DWORD PTR tv252[rsp], 0
$LN122@TCOpenVolu:
  005fa	83 7c 24 60 00	 cmp	 DWORD PTR exclusiveAccess$[rsp], 0
  005ff	74 0d		 je	 SHORT $LN123@TCOpenVolu
  00601	c7 84 24 f8 02
	00 00 01 00 00
	00		 mov	 DWORD PTR tv258[rsp], 1
  0060c	eb 0b		 jmp	 SHORT $LN124@TCOpenVolu
$LN123@TCOpenVolu:
  0060e	c7 84 24 f8 02
	00 00 03 00 00
	00		 mov	 DWORD PTR tv258[rsp], 3
$LN124@TCOpenVolu:
  00619	8b 84 24 f4 02
	00 00		 mov	 eax, DWORD PTR tv252[rsp]
  00620	0d 02 08 00 00	 or	 eax, 2050		; 00000802H
  00625	83 c8 20	 or	 eax, 32			; 00000020H
  00628	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00630	48 83 c1 78	 add	 rcx, 120		; 00000078H
  00634	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR [rsp+80], 0
  0063c	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR [rsp+72], 0
  00645	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00649	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR [rsp+56], 1
  00651	8b 84 24 f8 02
	00 00		 mov	 eax, DWORD PTR tv258[rsp]
  00658	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0065c	c7 44 24 28 84
	00 00 00	 mov	 DWORD PTR [rsp+40], 132	; 00000084H
  00664	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0066d	4c 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR IoStatusBlock$[rsp]
  00675	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR oaFileAttributes$[rsp]
  0067d	ba 00 00 10 80	 mov	 edx, -2146435072	; 80100000H
  00682	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwCreateFile
  00688	89 84 24 24 01
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 193  : 
; 194  : 		if (NT_SUCCESS (ntStatus) && !mount->bMountReadOnly)

  0068f	83 bc 24 24 01
	00 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  00697	7c 20		 jl	 SHORT $LN89@TCOpenVolu
  00699	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  006a1	83 b8 6c 02 00
	00 00		 cmp	 DWORD PTR [rax+620], 0
  006a8	75 0f		 jne	 SHORT $LN89@TCOpenVolu

; 195  : 			mount->VolumeMountedReadOnlyAfterAccessDenied = TRUE;

  006aa	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  006b2	c7 40 08 01 00
	00 00		 mov	 DWORD PTR [rax+8], 1
$LN89@TCOpenVolu:

; 196  : 
; 197  : 		Extension->bReadOnly = TRUE;

  006b9	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  006c1	c7 80 98 03 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+920], 1

; 198  : 		DeviceObject->Characteristics |= FILE_READ_ONLY_DEVICE;

  006cb	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  006d3	8b 48 34	 mov	 ecx, DWORD PTR [rax+52]
  006d6	83 c9 02	 or	 ecx, 2
  006d9	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  006e1	89 48 34	 mov	 DWORD PTR [rax+52], ecx

; 199  : 	}
; 200  : 	else

  006e4	eb 12		 jmp	 SHORT $LN88@TCOpenVolu
$LN91@TCOpenVolu:

; 201  : 		Extension->bReadOnly = FALSE;

  006e6	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  006ee	c7 80 98 03 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+920], 0
$LN88@TCOpenVolu:

; 202  : 
; 203  : 	/* 26-4-99 NT for some partitions returns this code, it is really a
; 204  : 	access denied */
; 205  : 	if (ntStatus == 0xc000001b)

  006f8	81 bc 24 24 01
	00 00 1b 00 00
	c0		 cmp	 DWORD PTR ntStatus$[rsp], -1073741797 ; c000001bH
  00703	75 0b		 jne	 SHORT $LN87@TCOpenVolu

; 206  : 	{
; 207  : 		/* Partitions which return this code can still be opened with
; 208  : 		FILE_SHARE_READ but this causes NT problems elsewhere in
; 209  : 		particular if you do FILE_SHARE_READ NT will die later if
; 210  : 		anyone even tries to open the partition (or file for that
; 211  : 		matter...)  */
; 212  : 		ntStatus = STATUS_SHARING_VIOLATION;

  00705	c7 84 24 24 01
	00 00 43 00 00
	c0		 mov	 DWORD PTR ntStatus$[rsp], -1073741757 ; ffffffffc0000043H
$LN87@TCOpenVolu:

; 213  : 	}
; 214  : 
; 215  : 	if (!NT_SUCCESS (ntStatus))

  00710	83 bc 24 24 01
	00 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  00718	7d 05		 jge	 SHORT $LN86@TCOpenVolu

; 216  : 	{
; 217  : 		goto error;

  0071a	e9 be 13 00 00	 jmp	 $error$30873
$LN86@TCOpenVolu:

; 218  : 	}
; 219  : 
; 220  : 	// If we have opened a file, query its size now
; 221  : 	if (bRawDevice == FALSE)

  0071f	83 bc 24 70 03
	00 00 00	 cmp	 DWORD PTR bRawDevice$[rsp], 0
  00727	0f 85 f1 01 00
	00		 jne	 $LN85@TCOpenVolu

; 222  : 	{
; 223  : 		ntStatus = ZwQueryInformationFile (Extension->hDeviceFile,
; 224  : 			&IoStatusBlock,
; 225  : 			&FileBasicInfo,
; 226  : 			sizeof (FileBasicInfo),
; 227  : 			FileBasicInformation);

  0072d	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00735	41 b9 28 00 00
	00		 mov	 r9d, 40			; 00000028H
  0073b	4c 8d 84 24 c0
	00 00 00	 lea	 r8, QWORD PTR FileBasicInfo$[rsp]
  00743	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR IoStatusBlock$[rsp]
  0074b	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00753	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  00757	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwQueryInformationFile
  0075d	89 84 24 24 01
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 228  : 
; 229  : 		if (NT_SUCCESS (ntStatus))

  00764	83 bc 24 24 01
	00 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  0076c	0f 8c b6 00 00
	00		 jl	 $LN84@TCOpenVolu

; 230  : 		{
; 231  : 			if (mount->bPreserveTimestamp)

  00772	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  0077a	83 b8 7c 02 00
	00 00		 cmp	 DWORD PTR [rax+636], 0
  00781	74 6e		 je	 SHORT $LN83@TCOpenVolu

; 232  : 			{
; 233  : 				Extension->fileCreationTime = FileBasicInfo.CreationTime;

  00783	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  0078b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR FileBasicInfo$[rsp]
  00793	48 89 81 b8 05
	00 00		 mov	 QWORD PTR [rcx+1464], rax

; 234  : 				Extension->fileLastAccessTime = FileBasicInfo.LastAccessTime;

  0079a	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  007a2	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR FileBasicInfo$[rsp+8]
  007aa	48 89 81 c0 05
	00 00		 mov	 QWORD PTR [rcx+1472], rax

; 235  : 				Extension->fileLastWriteTime = FileBasicInfo.LastWriteTime;

  007b1	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  007b9	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR FileBasicInfo$[rsp+16]
  007c1	48 89 81 c8 05
	00 00		 mov	 QWORD PTR [rcx+1480], rax

; 236  : 				Extension->fileLastChangeTime = FileBasicInfo.ChangeTime;

  007c8	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  007d0	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR FileBasicInfo$[rsp+24]
  007d8	48 89 81 d0 05
	00 00		 mov	 QWORD PTR [rcx+1488], rax

; 237  : 				Extension->bTimeStampValid = TRUE;

  007df	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  007e7	c7 80 d8 05 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1496], 1
$LN83@TCOpenVolu:

; 238  : 			}
; 239  : 
; 240  : 			ntStatus = ZwQueryInformationFile (Extension->hDeviceFile,
; 241  : 				&IoStatusBlock,
; 242  : 				&FileStandardInfo,
; 243  : 				sizeof (FileStandardInfo),
; 244  : 				FileStandardInformation);

  007f1	c7 44 24 20 05
	00 00 00	 mov	 DWORD PTR [rsp+32], 5
  007f9	41 b9 18 00 00
	00		 mov	 r9d, 24
  007ff	4c 8d 84 24 08
	01 00 00	 lea	 r8, QWORD PTR FileStandardInfo$[rsp]
  00807	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR IoStatusBlock$[rsp]
  0080f	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00817	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  0081b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwQueryInformationFile
  00821	89 84 24 24 01
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax
$LN84@TCOpenVolu:

; 245  : 		}
; 246  : 
; 247  : 		if (!NT_SUCCESS (ntStatus))

  00828	83 bc 24 24 01
	00 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  00830	7d 18		 jge	 SHORT $LN82@TCOpenVolu

; 248  : 		{
; 249  : 			Dump ("ZwQueryInformationFile failed while opening file: NTSTATUS 0x%08x\n",
; 250  : 				ntStatus);

  00832	8b 94 24 24 01
	00 00		 mov	 edx, DWORD PTR ntStatus$[rsp]
  00839	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0ED@EAABHCEJ@ZwQueryInformationFile?5failed?5wh@FNODOBFM@
  00840	e8 00 00 00 00	 call	 DbgPrint

; 251  : 			goto error;

  00845	e9 93 12 00 00	 jmp	 $error$30873
$LN82@TCOpenVolu:

; 252  : 		}
; 253  : 
; 254  : 		lDiskLength.QuadPart = FileStandardInfo.EndOfFile.QuadPart;

  0084a	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR FileStandardInfo$[rsp+8]
  00852	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR lDiskLength$[rsp], rax

; 255  : 
; 256  : 		if (FileBasicInfo.FileAttributes & FILE_ATTRIBUTE_COMPRESSED)

  0085a	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR FileBasicInfo$[rsp+32]
  00861	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  00866	85 c0		 test	 eax, eax
  00868	74 32		 je	 SHORT $LN81@TCOpenVolu

; 257  : 		{
; 258  : 			Dump ("File \"%ls\" is marked as compressed - not supported!\n", pwszMountVolume);

  0086a	48 8b 94 24 68
	03 00 00	 mov	 rdx, QWORD PTR pwszMountVolume$[rsp]
  00872	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DF@LEPAODFF@File?5?$CC?$CFls?$CC?5is?5marked?5as?5compress@FNODOBFM@
  00879	e8 00 00 00 00	 call	 DbgPrint

; 259  : 			mount->nReturnCode = ERR_COMPRESSION_NOT_SUPPORTED;

  0087e	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR mount$[rsp]
  00886	c7 02 08 00 00
	00		 mov	 DWORD PTR [rdx], 8

; 260  : 			ntStatus = STATUS_SUCCESS;

  0088c	c7 84 24 24 01
	00 00 00 00 00
	00		 mov	 DWORD PTR ntStatus$[rsp], 0

; 261  : 			goto error;

  00897	e9 41 12 00 00	 jmp	 $error$30873
$LN81@TCOpenVolu:

; 262  : 		}
; 263  : 
; 264  : 		ntStatus = ObReferenceObjectByHandle (Extension->hDeviceFile,
; 265  : 			FILE_ALL_ACCESS,
; 266  : 			*IoFileObjectType,
; 267  : 			KernelMode,
; 268  : 			&Extension->pfoDeviceFile,
; 269  : 			0);

  0089c	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  008a4	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  008aa	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  008b3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008b8	45 33 c9	 xor	 r9d, r9d
  008bb	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR IoFileObjectType
  008c2	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  008c5	ba ff 01 1f 00	 mov	 edx, 2032127		; 001f01ffH
  008ca	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  008d2	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  008d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObReferenceObjectByHandle
  008dc	89 84 24 24 01
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 270  : 
; 271  : 		if (!NT_SUCCESS (ntStatus))

  008e3	83 bc 24 24 01
	00 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  008eb	7d 05		 jge	 SHORT $LN80@TCOpenVolu

; 272  : 		{
; 273  : 			goto error;

  008ed	e9 eb 11 00 00	 jmp	 $error$30873
$LN80@TCOpenVolu:

; 274  : 		}
; 275  : 
; 276  : 		/* Get the FSD device for the file (probably either NTFS or	FAT) */
; 277  : 		Extension->pFsdDevice = IoGetRelatedDeviceObject (Extension->pfoDeviceFile);

  008f2	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  008fa	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00901	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetRelatedDeviceObject
  00907	48 8b d0	 mov	 rdx, rax
  0090a	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00912	48 89 90 88 00
	00 00		 mov	 QWORD PTR [rax+136], rdx

; 278  : 	}
; 279  : 	else

  00919	e9 8c 00 00 00	 jmp	 $LN79@TCOpenVolu
$LN85@TCOpenVolu:

; 280  : 	{
; 281  : 		// Try to gain "raw" access to the partition in case there is a live filesystem on it (otherwise, 
; 282  : 		// the NTFS driver guards hidden sectors and prevents mounting using a backup header e.g. after the user 
; 283  : 		// accidentally quick-formats a dismounted partition-hosted CipherShed volume as NTFS).
; 284  : 
; 285  : 		PFILE_OBJECT pfoTmpDeviceFile = NULL;

  0091e	48 c7 84 24 10
	02 00 00 00 00
	00 00		 mov	 QWORD PTR pfoTmpDeviceFile$30931[rsp], 0

; 286  : 
; 287  : 		if (NT_SUCCESS (ObReferenceObjectByHandle (Extension->hDeviceFile, FILE_ALL_ACCESS, *IoFileObjectType, KernelMode, &pfoTmpDeviceFile, NULL))
; 288  : 			&& pfoTmpDeviceFile != NULL)

  0092a	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00933	48 8d 84 24 10
	02 00 00	 lea	 rax, QWORD PTR pfoTmpDeviceFile$30931[rsp]
  0093b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00940	45 33 c9	 xor	 r9d, r9d
  00943	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR IoFileObjectType
  0094a	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  0094d	ba ff 01 1f 00	 mov	 edx, 2032127		; 001f01ffH
  00952	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  0095a	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  0095e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObReferenceObjectByHandle
  00964	85 c0		 test	 eax, eax
  00966	7c 42		 jl	 SHORT $LN78@TCOpenVolu
  00968	48 83 bc 24 10
	02 00 00 00	 cmp	 QWORD PTR pfoTmpDeviceFile$30931[rsp], 0
  00971	74 37		 je	 SHORT $LN78@TCOpenVolu

; 289  : 		{
; 290  : 			TCFsctlCall (pfoTmpDeviceFile, FSCTL_ALLOW_EXTENDED_DASD_IO, NULL, 0, NULL, 0);

  00973	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0097b	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00984	45 33 c9	 xor	 r9d, r9d
  00987	45 33 c0	 xor	 r8d, r8d
  0098a	ba 83 00 09 00	 mov	 edx, 589955		; 00090083H
  0098f	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR pfoTmpDeviceFile$30931[rsp]
  00997	e8 00 00 00 00	 call	 TCFsctlCall

; 291  : 			ObDereferenceObject (pfoTmpDeviceFile);

  0099c	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR pfoTmpDeviceFile$30931[rsp]
  009a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject
$LN78@TCOpenVolu:
$LN79@TCOpenVolu:

; 292  : 		}
; 293  : 	}
; 294  : 
; 295  : 	// Check volume size
; 296  : 	if (lDiskLength.QuadPart < TC_MIN_VOLUME_SIZE_LEGACY || lDiskLength.QuadPart > TC_MAX_VOLUME_SIZE)

  009aa	48 81 bc 24 00
	01 00 00 00 4a
	00 00		 cmp	 QWORD PTR lDiskLength$[rsp], 18944 ; 00004a00H
  009b6	7c 14		 jl	 SHORT $LN76@TCOpenVolu
  009b8	48 b8 00 00 00
	00 00 00 04 00	 mov	 rax, 1125899906842624	; 0004000000000000H
  009c2	48 39 84 24 00
	01 00 00	 cmp	 QWORD PTR lDiskLength$[rsp], rax
  009ca	7e 1e		 jle	 SHORT $LN77@TCOpenVolu
$LN76@TCOpenVolu:

; 297  : 	{
; 298  : 		mount->nReturnCode = ERR_VOL_SIZE_WRONG;

  009cc	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  009d4	c7 00 07 00 00
	00		 mov	 DWORD PTR [rax], 7

; 299  : 		ntStatus = STATUS_SUCCESS;

  009da	c7 84 24 24 01
	00 00 00 00 00
	00		 mov	 DWORD PTR ntStatus$[rsp], 0

; 300  : 		goto error;

  009e5	e9 f3 10 00 00	 jmp	 $error$30873
$LN77@TCOpenVolu:

; 301  : 	}
; 302  : 
; 303  : 	Extension->DiskLength = lDiskLength.QuadPart;

  009ea	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  009f2	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR lDiskLength$[rsp]
  009fa	48 89 81 a0 00
	00 00		 mov	 QWORD PTR [rcx+160], rax

; 304  : 	Extension->HostLength = lDiskLength.QuadPart;

  00a01	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00a09	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR lDiskLength$[rsp]
  00a11	48 89 81 98 00
	00 00		 mov	 QWORD PTR [rcx+152], rax

; 305  : 
; 306  : 	readBuffer = TCalloc (max (max (TC_VOLUME_HEADER_EFFECTIVE_SIZE, PAGE_SIZE), Extension->HostBytesPerSector));

  00a18	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00a20	81 b8 c0 00 00
	00 00 10 00 00	 cmp	 DWORD PTR [rax+192], 4096 ; 00001000H
  00a2a	73 0d		 jae	 SHORT $LN125@TCOpenVolu
  00a2c	c7 84 24 fc 02
	00 00 00 10 00
	00		 mov	 DWORD PTR tv348[rsp], 4096 ; 00001000H
  00a37	eb 15		 jmp	 SHORT $LN126@TCOpenVolu
$LN125@TCOpenVolu:
  00a39	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00a41	8b 80 c0 00 00
	00		 mov	 eax, DWORD PTR [rax+192]
  00a47	89 84 24 fc 02
	00 00		 mov	 DWORD PTR tv348[rsp], eax
$LN126@TCOpenVolu:
  00a4e	8b 94 24 fc 02
	00 00		 mov	 edx, DWORD PTR tv348[rsp]
  00a55	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  00a5b	33 c9		 xor	 ecx, ecx
  00a5d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00a63	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR readBuffer$[rsp], rax

; 307  : 	if (readBuffer == NULL)

  00a6b	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR readBuffer$[rsp], 0
  00a74	75 10		 jne	 SHORT $LN75@TCOpenVolu

; 308  : 	{
; 309  : 		ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00a76	c7 84 24 24 01
	00 00 9a 00 00
	c0		 mov	 DWORD PTR ntStatus$[rsp], -1073741670 ; ffffffffc000009aH

; 310  : 		goto error;

  00a81	e9 57 10 00 00	 jmp	 $error$30873
$LN75@TCOpenVolu:

; 311  : 	}
; 312  : 
; 313  : 	// Go through all volume types (e.g., normal, hidden)
; 314  : 	for (volumeType = TC_VOLUME_TYPE_NORMAL;
; 315  : 		volumeType < TC_VOLUME_TYPE_COUNT;
; 316  : 		volumeType++)	

  00a86	c7 84 24 20 01
	00 00 00 00 00
	00		 mov	 DWORD PTR volumeType$[rsp], 0
  00a91	eb 11		 jmp	 SHORT $LN74@TCOpenVolu
$LN73@TCOpenVolu:
  00a93	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR volumeType$[rsp]
  00a9a	83 c0 01	 add	 eax, 1
  00a9d	89 84 24 20 01
	00 00		 mov	 DWORD PTR volumeType$[rsp], eax
$LN74@TCOpenVolu:
  00aa4	83 bc 24 20 01
	00 00 03	 cmp	 DWORD PTR volumeType$[rsp], 3
  00aac	0f 8d 06 10 00
	00		 jge	 $LN72@TCOpenVolu

; 317  : 	{
; 318  : 		Dump ("Trying to open volume type %d\n", volumeType);

  00ab2	8b 94 24 20 01
	00 00		 mov	 edx, DWORD PTR volumeType$[rsp]
  00ab9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@BKDGGJEA@Trying?5to?5open?5volume?5type?5?$CFd?6?$AA@FNODOBFM@
  00ac0	e8 00 00 00 00	 call	 DbgPrint

; 319  : 
; 320  : 		if (mount->bPartitionInInactiveSysEncScope
; 321  : 			&& volumeType == TC_VOLUME_TYPE_HIDDEN_LEGACY)

  00ac5	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR mount$[rsp]
  00acd	83 ba 80 02 00
	00 00		 cmp	 DWORD PTR [rdx+640], 0
  00ad4	74 0c		 je	 SHORT $LN71@TCOpenVolu
  00ad6	83 bc 24 20 01
	00 00 02	 cmp	 DWORD PTR volumeType$[rsp], 2
  00ade	75 02		 jne	 SHORT $LN71@TCOpenVolu

; 322  : 			continue;		

  00ae0	eb b1		 jmp	 SHORT $LN73@TCOpenVolu
$LN71@TCOpenVolu:

; 323  : 
; 324  : 		/* Read the volume header */
; 325  : 
; 326  : 		if (!mount->bPartitionInInactiveSysEncScope
; 327  : 			|| (mount->bPartitionInInactiveSysEncScope && volumeType == TC_VOLUME_TYPE_HIDDEN))

  00ae2	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  00aea	83 b8 80 02 00
	00 00		 cmp	 DWORD PTR [rax+640], 0
  00af1	74 23		 je	 SHORT $LN69@TCOpenVolu
  00af3	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  00afb	83 b8 80 02 00
	00 00		 cmp	 DWORD PTR [rax+640], 0
  00b02	0f 84 2a 02 00
	00		 je	 $LN70@TCOpenVolu
  00b08	83 bc 24 20 01
	00 00 01	 cmp	 DWORD PTR volumeType$[rsp], 1
  00b10	0f 85 1c 02 00
	00		 jne	 $LN70@TCOpenVolu
$LN69@TCOpenVolu:

; 328  : 		{
; 329  : 			// Header of a volume that is not within the scope of system encryption, or
; 330  : 			// header of a system hidden volume (containing a hidden OS)
; 331  : 
; 332  : 			LARGE_INTEGER headerOffset;
; 333  : 
; 334  : 			if (mount->UseBackupHeader && lDiskLength.QuadPart <= TC_TOTAL_VOLUME_HEADERS_SIZE)

  00b16	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  00b1e	83 b8 d8 02 00
	00 00		 cmp	 DWORD PTR [rax+728], 0
  00b25	74 13		 je	 SHORT $LN68@TCOpenVolu
  00b27	48 81 bc 24 00
	01 00 00 00 00
	04 00		 cmp	 QWORD PTR lDiskLength$[rsp], 262144 ; 00040000H
  00b33	7f 05		 jg	 SHORT $LN68@TCOpenVolu

; 335  : 				continue;

  00b35	e9 59 ff ff ff	 jmp	 $LN73@TCOpenVolu
$LN68@TCOpenVolu:

; 336  : 
; 337  : 			switch (volumeType)

  00b3a	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR volumeType$[rsp]
  00b41	89 84 24 00 03
	00 00		 mov	 DWORD PTR tv368[rsp], eax
  00b48	83 bc 24 00 03
	00 00 00	 cmp	 DWORD PTR tv368[rsp], 0
  00b50	74 1d		 je	 SHORT $LN65@TCOpenVolu
  00b52	83 bc 24 00 03
	00 00 01	 cmp	 DWORD PTR tv368[rsp], 1
  00b5a	74 5d		 je	 SHORT $LN64@TCOpenVolu
  00b5c	83 bc 24 00 03
	00 00 02	 cmp	 DWORD PTR tv368[rsp], 2
  00b64	0f 84 a9 00 00
	00		 je	 $LN62@TCOpenVolu
  00b6a	e9 f3 00 00 00	 jmp	 $LN66@TCOpenVolu
$LN65@TCOpenVolu:

; 338  : 			{
; 339  : 			case TC_VOLUME_TYPE_NORMAL:
; 340  : 				headerOffset.QuadPart = mount->UseBackupHeader ? lDiskLength.QuadPart - TC_VOLUME_HEADER_GROUP_SIZE : TC_VOLUME_HEADER_OFFSET;

  00b6f	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  00b77	83 b8 d8 02 00
	00 00		 cmp	 DWORD PTR [rax+728], 0
  00b7e	74 18		 je	 SHORT $LN127@TCOpenVolu
  00b80	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR lDiskLength$[rsp]
  00b88	48 2d 00 00 02
	00		 sub	 rax, 131072		; 00020000H
  00b8e	48 89 84 24 08
	03 00 00	 mov	 QWORD PTR tv372[rsp], rax
  00b96	eb 0c		 jmp	 SHORT $LN128@TCOpenVolu
$LN127@TCOpenVolu:
  00b98	48 c7 84 24 08
	03 00 00 00 00
	00 00		 mov	 QWORD PTR tv372[rsp], 0
$LN128@TCOpenVolu:
  00ba4	48 8b 84 24 08
	03 00 00	 mov	 rax, QWORD PTR tv372[rsp]
  00bac	48 89 84 24 18
	02 00 00	 mov	 QWORD PTR headerOffset$30953[rsp], rax

; 341  : 				break;

  00bb4	e9 a9 00 00 00	 jmp	 $LN66@TCOpenVolu
$LN64@TCOpenVolu:

; 342  : 
; 343  : 			case TC_VOLUME_TYPE_HIDDEN:
; 344  : 				if (lDiskLength.QuadPart <= TC_VOLUME_HEADER_GROUP_SIZE)

  00bb9	48 81 bc 24 00
	01 00 00 00 00
	02 00		 cmp	 QWORD PTR lDiskLength$[rsp], 131072 ; 00020000H
  00bc5	7f 05		 jg	 SHORT $LN63@TCOpenVolu

; 345  : 					continue;

  00bc7	e9 c7 fe ff ff	 jmp	 $LN73@TCOpenVolu
$LN63@TCOpenVolu:

; 346  : 
; 347  : 				headerOffset.QuadPart = mount->UseBackupHeader ? lDiskLength.QuadPart - TC_HIDDEN_VOLUME_HEADER_OFFSET : TC_HIDDEN_VOLUME_HEADER_OFFSET;

  00bcc	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  00bd4	83 b8 d8 02 00
	00 00		 cmp	 DWORD PTR [rax+728], 0
  00bdb	74 18		 je	 SHORT $LN129@TCOpenVolu
  00bdd	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR lDiskLength$[rsp]
  00be5	48 2d 00 00 01
	00		 sub	 rax, 65536		; 00010000H
  00beb	48 89 84 24 10
	03 00 00	 mov	 QWORD PTR tv377[rsp], rax
  00bf3	eb 0c		 jmp	 SHORT $LN130@TCOpenVolu
$LN129@TCOpenVolu:
  00bf5	48 c7 84 24 10
	03 00 00 00 00
	01 00		 mov	 QWORD PTR tv377[rsp], 65536 ; 00010000H
$LN130@TCOpenVolu:
  00c01	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR tv377[rsp]
  00c09	48 89 84 24 18
	02 00 00	 mov	 QWORD PTR headerOffset$30953[rsp], rax

; 348  : 				break;

  00c11	eb 4f		 jmp	 SHORT $LN66@TCOpenVolu
$LN62@TCOpenVolu:

; 349  : 
; 350  : 			case TC_VOLUME_TYPE_HIDDEN_LEGACY:
; 351  : 				if (mount->UseBackupHeader)

  00c13	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  00c1b	83 b8 d8 02 00
	00 00		 cmp	 DWORD PTR [rax+728], 0
  00c22	74 05		 je	 SHORT $LN61@TCOpenVolu

; 352  : 					continue;

  00c24	e9 6a fe ff ff	 jmp	 $LN73@TCOpenVolu
$LN61@TCOpenVolu:

; 353  : 
; 354  : 				if (bRawDevice && Extension->HostBytesPerSector != TC_SECTOR_SIZE_LEGACY)

  00c29	83 bc 24 70 03
	00 00 00	 cmp	 DWORD PTR bRawDevice$[rsp], 0
  00c31	74 19		 je	 SHORT $LN60@TCOpenVolu
  00c33	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00c3b	81 b8 c0 00 00
	00 00 02 00 00	 cmp	 DWORD PTR [rax+192], 512 ; 00000200H
  00c45	74 05		 je	 SHORT $LN60@TCOpenVolu

; 355  : 					continue;

  00c47	e9 47 fe ff ff	 jmp	 $LN73@TCOpenVolu
$LN60@TCOpenVolu:

; 356  : 
; 357  : 				headerOffset.QuadPart = lDiskLength.QuadPart - TC_HIDDEN_VOLUME_HEADER_OFFSET_LEGACY;

  00c4c	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR lDiskLength$[rsp]
  00c54	48 2d 00 06 00
	00		 sub	 rax, 1536		; 00000600H
  00c5a	48 89 84 24 18
	02 00 00	 mov	 QWORD PTR headerOffset$30953[rsp], rax
$LN66@TCOpenVolu:

; 358  : 				break;
; 359  : 			}
; 360  : 
; 361  : 			Dump ("Reading volume header at %I64d\n", headerOffset.QuadPart);

  00c62	48 8b 94 24 18
	02 00 00	 mov	 rdx, QWORD PTR headerOffset$30953[rsp]
  00c6a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@IGALEGOK@Reading?5volume?5header?5at?5?$CFI64d?6?$AA@FNODOBFM@
  00c71	e8 00 00 00 00	 call	 DbgPrint

; 362  : 
; 363  : 			ntStatus = ZwReadFile (Extension->hDeviceFile,
; 364  : 			NULL,
; 365  : 			NULL,
; 366  : 			NULL,
; 367  : 			&IoStatusBlock,
; 368  : 			readBuffer,
; 369  : 			bRawDevice ? max (TC_VOLUME_HEADER_EFFECTIVE_SIZE, Extension->HostBytesPerSector) : TC_VOLUME_HEADER_EFFECTIVE_SIZE,
; 370  : 			&headerOffset,
; 371  : 			NULL);

  00c76	83 bc 24 70 03
	00 00 00	 cmp	 DWORD PTR bRawDevice$[rsp], 0
  00c7e	74 46		 je	 SHORT $LN133@TCOpenVolu
  00c80	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00c88	81 b8 c0 00 00
	00 00 02 00 00	 cmp	 DWORD PTR [rax+192], 512 ; 00000200H
  00c92	73 0d		 jae	 SHORT $LN131@TCOpenVolu
  00c94	c7 84 24 18 03
	00 00 00 02 00
	00		 mov	 DWORD PTR tv395[rsp], 512 ; 00000200H
  00c9f	eb 15		 jmp	 SHORT $LN132@TCOpenVolu
$LN131@TCOpenVolu:
  00ca1	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00ca9	8b 80 c0 00 00
	00		 mov	 eax, DWORD PTR [rax+192]
  00caf	89 84 24 18 03
	00 00		 mov	 DWORD PTR tv395[rsp], eax
$LN132@TCOpenVolu:
  00cb6	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR tv395[rsp]
  00cbd	89 84 24 1c 03
	00 00		 mov	 DWORD PTR tv397[rsp], eax
  00cc4	eb 0b		 jmp	 SHORT $LN134@TCOpenVolu
$LN133@TCOpenVolu:
  00cc6	c7 84 24 1c 03
	00 00 00 02 00
	00		 mov	 DWORD PTR tv397[rsp], 512 ; 00000200H
$LN134@TCOpenVolu:
  00cd1	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00cda	48 8d 84 24 18
	02 00 00	 lea	 rax, QWORD PTR headerOffset$30953[rsp]
  00ce2	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00ce7	8b 84 24 1c 03
	00 00		 mov	 eax, DWORD PTR tv397[rsp]
  00cee	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00cf2	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR readBuffer$[rsp]
  00cfa	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00cff	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR IoStatusBlock$[rsp]
  00d07	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d0c	45 33 c9	 xor	 r9d, r9d
  00d0f	45 33 c0	 xor	 r8d, r8d
  00d12	33 d2		 xor	 edx, edx
  00d14	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00d1c	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  00d20	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwReadFile
  00d26	89 84 24 24 01
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 372  : 		}
; 373  : 		else

  00d2d	e9 17 02 00 00	 jmp	 $LN59@TCOpenVolu
$LN70@TCOpenVolu:

; 374  : 		{
; 375  : 			// Header of a partition that is within the scope of system encryption
; 376  : 
; 377  : 			WCHAR parentDrivePath [47+1] = {0};

  00d32	33 c0		 xor	 eax, eax
  00d34	66 89 84 24 30
	02 00 00	 mov	 WORD PTR parentDrivePath$30971[rsp], ax
  00d3c	48 8d bc 24 32
	02 00 00	 lea	 rdi, QWORD PTR parentDrivePath$30971[rsp+2]
  00d44	33 c0		 xor	 eax, eax
  00d46	b9 5e 00 00 00	 mov	 ecx, 94			; 0000005eH
  00d4b	f3 aa		 rep stosb

; 378  : 			HANDLE hParentDeviceFile = NULL;

  00d4d	48 c7 84 24 c8
	02 00 00 00 00
	00 00		 mov	 QWORD PTR hParentDeviceFile$30972[rsp], 0

; 379  : 			UNICODE_STRING FullParentPath;
; 380  : 			OBJECT_ATTRIBUTES oaParentFileAttributes;
; 381  : 			LARGE_INTEGER parentKeyDataOffset;
; 382  : 
; 383  : 			_snwprintf (parentDrivePath,
; 384  : 				sizeof (parentDrivePath) / sizeof (WCHAR) - 1,
; 385  : 				WIDE ("\\Device\\Harddisk%d\\Partition0"),
; 386  : 				mount->nPartitionInInactiveSysEncScopeDriveNo);

  00d59	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  00d61	44 8b 88 84 02
	00 00		 mov	 r9d, DWORD PTR [rax+644]
  00d68	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1DM@FMJIKGBL@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAH?$AAa?$AAr?$AAd?$AAd?$AAi?$AAs?$AAk?$AA?$CF?$AAd?$AA?2?$AAP?$AAa?$AAr?$AAt?$AAi?$AAt?$AAi?$AAo?$AAn?$AA0?$AA?$AA@FNODOBFM@
  00d6f	ba 2f 00 00 00	 mov	 edx, 47			; 0000002fH
  00d74	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR parentDrivePath$30971[rsp]
  00d7c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__snwprintf

; 387  : 
; 388  : 			Dump ("Mounting partition within scope of system encryption (reading key data from: %ls)\n", parentDrivePath);

  00d82	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR parentDrivePath$30971[rsp]
  00d8a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0FD@BKFNIFNN@Mounting?5partition?5within?5scope?5@FNODOBFM@
  00d91	e8 00 00 00 00	 call	 DbgPrint

; 389  : 
; 390  : 			RtlInitUnicodeString (&FullParentPath, parentDrivePath);

  00d96	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR parentDrivePath$30971[rsp]
  00d9e	48 8d 8c 24 d0
	02 00 00	 lea	 rcx, QWORD PTR FullParentPath$30974[rsp]
  00da6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 391  : 			InitializeObjectAttributes (&oaParentFileAttributes, &FullParentPath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,	NULL, NULL);

  00dac	c7 84 24 98 02
	00 00 30 00 00
	00		 mov	 DWORD PTR oaParentFileAttributes$30975[rsp], 48 ; 00000030H
  00db7	48 c7 84 24 a0
	02 00 00 00 00
	00 00		 mov	 QWORD PTR oaParentFileAttributes$30975[rsp+8], 0
  00dc3	c7 84 24 b0 02
	00 00 40 02 00
	00		 mov	 DWORD PTR oaParentFileAttributes$30975[rsp+24], 576 ; 00000240H
  00dce	48 8d 84 24 d0
	02 00 00	 lea	 rax, QWORD PTR FullParentPath$30974[rsp]
  00dd6	48 89 84 24 a8
	02 00 00	 mov	 QWORD PTR oaParentFileAttributes$30975[rsp+16], rax
  00dde	48 c7 84 24 b8
	02 00 00 00 00
	00 00		 mov	 QWORD PTR oaParentFileAttributes$30975[rsp+32], 0
  00dea	48 c7 84 24 c0
	02 00 00 00 00
	00 00		 mov	 QWORD PTR oaParentFileAttributes$30975[rsp+40], 0

; 392  : 
; 393  : 			ntStatus = ZwCreateFile (&hParentDeviceFile,
; 394  : 				GENERIC_READ | SYNCHRONIZE,
; 395  : 				&oaParentFileAttributes,
; 396  : 				&IoStatusBlock,
; 397  : 				NULL,
; 398  : 				FILE_ATTRIBUTE_NORMAL |
; 399  : 				FILE_ATTRIBUTE_SYSTEM,
; 400  : 				FILE_SHARE_READ | FILE_SHARE_WRITE,
; 401  : 				FILE_OPEN,
; 402  : 				FILE_RANDOM_ACCESS |
; 403  : 				FILE_WRITE_THROUGH |
; 404  : 				FILE_NO_INTERMEDIATE_BUFFERING |
; 405  : 				FILE_SYNCHRONOUS_IO_NONALERT,
; 406  : 				NULL,
; 407  : 				0);

  00df6	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR [rsp+80], 0
  00dfe	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR [rsp+72], 0
  00e07	c7 44 24 40 2a
	08 00 00	 mov	 DWORD PTR [rsp+64], 2090 ; 0000082aH
  00e0f	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR [rsp+56], 1
  00e17	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR [rsp+48], 3
  00e1f	c7 44 24 28 84
	00 00 00	 mov	 DWORD PTR [rsp+40], 132	; 00000084H
  00e27	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00e30	4c 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR IoStatusBlock$[rsp]
  00e38	4c 8d 84 24 98
	02 00 00	 lea	 r8, QWORD PTR oaParentFileAttributes$30975[rsp]
  00e40	ba 00 00 10 80	 mov	 edx, -2146435072	; 80100000H
  00e45	48 8d 8c 24 c8
	02 00 00	 lea	 rcx, QWORD PTR hParentDeviceFile$30972[rsp]
  00e4d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwCreateFile
  00e53	89 84 24 24 01
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 408  : 
; 409  : 			if (!NT_SUCCESS (ntStatus))

  00e5a	83 bc 24 24 01
	00 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  00e62	7d 32		 jge	 SHORT $LN58@TCOpenVolu

; 410  : 			{
; 411  : 				if (hParentDeviceFile != NULL)

  00e64	48 83 bc 24 c8
	02 00 00 00	 cmp	 QWORD PTR hParentDeviceFile$30972[rsp], 0
  00e6d	74 0e		 je	 SHORT $LN57@TCOpenVolu

; 412  : 					ZwClose (hParentDeviceFile);

  00e6f	48 8b 8c 24 c8
	02 00 00	 mov	 rcx, QWORD PTR hParentDeviceFile$30972[rsp]
  00e77	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
$LN57@TCOpenVolu:

; 413  : 
; 414  : 				Dump ("Cannot open %ls\n", parentDrivePath);

  00e7d	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR parentDrivePath$30971[rsp]
  00e85	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@IPFFEHBJ@Cannot?5open?5?$CFls?6?$AA@FNODOBFM@
  00e8c	e8 00 00 00 00	 call	 DbgPrint

; 415  : 
; 416  : 				goto error;

  00e91	e9 47 0c 00 00	 jmp	 $error$30873
$LN58@TCOpenVolu:

; 417  : 			}
; 418  : 
; 419  : 			parentKeyDataOffset.QuadPart = TC_BOOT_VOLUME_HEADER_SECTOR_OFFSET;

  00e96	48 c7 84 24 90
	02 00 00 00 7c
	00 00		 mov	 QWORD PTR parentKeyDataOffset$30976[rsp], 31744 ; 00007c00H

; 420  : 
; 421  : 			ntStatus = ZwReadFile (hParentDeviceFile,
; 422  : 				NULL,
; 423  : 				NULL,
; 424  : 				NULL,
; 425  : 				&IoStatusBlock,
; 426  : 				readBuffer,
; 427  : 				max (TC_VOLUME_HEADER_EFFECTIVE_SIZE, Extension->HostBytesPerSector),
; 428  : 				&parentKeyDataOffset,
; 429  : 				NULL);

  00ea2	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00eaa	81 b8 c0 00 00
	00 00 02 00 00	 cmp	 DWORD PTR [rax+192], 512 ; 00000200H
  00eb4	73 0d		 jae	 SHORT $LN135@TCOpenVolu
  00eb6	c7 84 24 20 03
	00 00 00 02 00
	00		 mov	 DWORD PTR tv474[rsp], 512 ; 00000200H
  00ec1	eb 15		 jmp	 SHORT $LN136@TCOpenVolu
$LN135@TCOpenVolu:
  00ec3	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00ecb	8b 80 c0 00 00
	00		 mov	 eax, DWORD PTR [rax+192]
  00ed1	89 84 24 20 03
	00 00		 mov	 DWORD PTR tv474[rsp], eax
$LN136@TCOpenVolu:
  00ed8	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00ee1	48 8d 84 24 90
	02 00 00	 lea	 rax, QWORD PTR parentKeyDataOffset$30976[rsp]
  00ee9	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00eee	8b 84 24 20 03
	00 00		 mov	 eax, DWORD PTR tv474[rsp]
  00ef5	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00ef9	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR readBuffer$[rsp]
  00f01	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00f06	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR IoStatusBlock$[rsp]
  00f0e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f13	45 33 c9	 xor	 r9d, r9d
  00f16	45 33 c0	 xor	 r8d, r8d
  00f19	33 d2		 xor	 edx, edx
  00f1b	48 8b 8c 24 c8
	02 00 00	 mov	 rcx, QWORD PTR hParentDeviceFile$30972[rsp]
  00f23	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwReadFile
  00f29	89 84 24 24 01
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 430  : 
; 431  : 			if (hParentDeviceFile != NULL)

  00f30	48 83 bc 24 c8
	02 00 00 00	 cmp	 QWORD PTR hParentDeviceFile$30972[rsp], 0
  00f39	74 0e		 je	 SHORT $LN56@TCOpenVolu

; 432  : 				ZwClose (hParentDeviceFile);

  00f3b	48 8b 8c 24 c8
	02 00 00	 mov	 rcx, QWORD PTR hParentDeviceFile$30972[rsp]
  00f43	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
$LN56@TCOpenVolu:
$LN59@TCOpenVolu:

; 433  : 		}
; 434  : 
; 435  : 		if (!NT_SUCCESS (ntStatus) && ntStatus != STATUS_END_OF_FILE)

  00f49	83 bc 24 24 01
	00 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  00f51	7d 25		 jge	 SHORT $LN55@TCOpenVolu
  00f53	81 bc 24 24 01
	00 00 11 00 00
	c0		 cmp	 DWORD PTR ntStatus$[rsp], -1073741807 ; ffffffffc0000011H
  00f5e	74 18		 je	 SHORT $LN55@TCOpenVolu

; 436  : 		{
; 437  : 			Dump ("Read failed: NTSTATUS 0x%08x\n", ntStatus);

  00f60	8b 94 24 24 01
	00 00		 mov	 edx, DWORD PTR ntStatus$[rsp]
  00f67	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@FHFPMFGI@Read?5failed?3?5NTSTATUS?50x?$CF08x?6?$AA@FNODOBFM@
  00f6e	e8 00 00 00 00	 call	 DbgPrint

; 438  : 			goto error;

  00f73	e9 65 0b 00 00	 jmp	 $error$30873
$LN55@TCOpenVolu:

; 439  : 		}
; 440  : 
; 441  : 		if (ntStatus == STATUS_END_OF_FILE || IoStatusBlock.Information < TC_VOLUME_HEADER_EFFECTIVE_SIZE)

  00f78	81 bc 24 24 01
	00 00 11 00 00
	c0		 cmp	 DWORD PTR ntStatus$[rsp], -1073741807 ; ffffffffc0000011H
  00f83	74 0e		 je	 SHORT $LN53@TCOpenVolu
  00f85	48 81 bc 24 88
	00 00 00 00 02
	00 00		 cmp	 QWORD PTR IoStatusBlock$[rsp+8], 512 ; 00000200H
  00f91	73 1d		 jae	 SHORT $LN54@TCOpenVolu
$LN53@TCOpenVolu:

; 442  : 		{
; 443  : 			Dump ("Read didn't read enough data\n");

  00f93	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@DBKGEMGK@Read?5didn?8t?5read?5enough?5data?6?$AA@FNODOBFM@
  00f9a	e8 00 00 00 00	 call	 DbgPrint

; 444  : 
; 445  : 			// If FSCTL_ALLOW_EXTENDED_DASD_IO failed and there is a live filesystem on the partition, then the
; 446  : 			// filesystem driver may report EOF when we are reading hidden sectors (when the filesystem is 
; 447  : 			// shorter than the partition). This can happen for example after the user quick-formats a dismounted
; 448  : 			// partition-hosted CipherShed volume and then tries to mount the volume using the embedded backup header.
; 449  : 			memset (readBuffer, 0, TC_VOLUME_HEADER_EFFECTIVE_SIZE);

  00f9f	48 8b bc 24 f0
	00 00 00	 mov	 rdi, QWORD PTR readBuffer$[rsp]
  00fa7	33 c0		 xor	 eax, eax
  00fa9	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00fae	f3 aa		 rep stosb
$LN54@TCOpenVolu:

; 450  : 		}
; 451  : 
; 452  : 		/* Attempt to recognize the volume (decrypt the header) */
; 453  : 
; 454  : 		ReadVolumeHeaderRecoveryMode = mount->RecoveryMode;

  00fb0	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  00fb8	8b 80 dc 02 00
	00		 mov	 eax, DWORD PTR [rax+732]
  00fbe	89 05 00 00 00
	00		 mov	 DWORD PTR ReadVolumeHeaderRecoveryMode, eax

; 455  : 
; 456  : 		if ((volumeType == TC_VOLUME_TYPE_HIDDEN || volumeType == TC_VOLUME_TYPE_HIDDEN_LEGACY) && mount->bProtectHiddenVolume)

  00fc4	83 bc 24 20 01
	00 00 01	 cmp	 DWORD PTR volumeType$[rsp], 1
  00fcc	74 0a		 je	 SHORT $LN51@TCOpenVolu
  00fce	83 bc 24 20 01
	00 00 02	 cmp	 DWORD PTR volumeType$[rsp], 2
  00fd6	75 5b		 jne	 SHORT $LN52@TCOpenVolu
$LN51@TCOpenVolu:
  00fd8	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  00fe0	83 b8 8c 02 00
	00 00		 cmp	 DWORD PTR [rax+652], 0
  00fe7	74 4a		 je	 SHORT $LN52@TCOpenVolu

; 457  : 		{
; 458  : 			mount->nReturnCode = ReadVolumeHeaderWCache (
; 459  : 				FALSE,
; 460  : 				mount->bCache,
; 461  : 				readBuffer,
; 462  : 				&mount->ProtectedHidVolPassword,
; 463  : 				&tmpCryptoInfo);

  00fe9	4c 8b 8c 24 60
	03 00 00	 mov	 r9, QWORD PTR mount$[rsp]
  00ff1	49 81 c1 90 02
	00 00		 add	 r9, 656			; 00000290H
  00ff8	48 8d 84 24 30
	01 00 00	 lea	 rax, QWORD PTR tmpCryptoInfo$[rsp]
  01000	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01005	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR readBuffer$[rsp]
  0100d	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  01015	8b 90 60 02 00
	00		 mov	 edx, DWORD PTR [rax+608]
  0101b	33 c9		 xor	 ecx, ecx
  0101d	e8 00 00 00 00	 call	 ReadVolumeHeaderWCache
  01022	8b d0		 mov	 edx, eax
  01024	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  0102c	89 10		 mov	 DWORD PTR [rax], edx

; 464  : 		}
; 465  : 		else

  0102e	e9 83 00 00 00	 jmp	 $LN50@TCOpenVolu
$LN52@TCOpenVolu:

; 466  : 		{
; 467  : 			mount->nReturnCode = ReadVolumeHeaderWCache (
; 468  : 				mount->bPartitionInInactiveSysEncScope && volumeType == TC_VOLUME_TYPE_NORMAL,
; 469  : 				mount->bCache,
; 470  : 				readBuffer,
; 471  : 				&mount->VolumePassword,
; 472  : 				&Extension->cryptoInfo);

  01033	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  0103b	83 b8 80 02 00
	00 00		 cmp	 DWORD PTR [rax+640], 0
  01042	74 17		 je	 SHORT $LN137@TCOpenVolu
  01044	83 bc 24 20 01
	00 00 00	 cmp	 DWORD PTR volumeType$[rsp], 0
  0104c	75 0d		 jne	 SHORT $LN137@TCOpenVolu
  0104e	c7 84 24 24 03
	00 00 01 00 00
	00		 mov	 DWORD PTR tv519[rsp], 1
  01059	eb 0b		 jmp	 SHORT $LN138@TCOpenVolu
$LN137@TCOpenVolu:
  0105b	c7 84 24 24 03
	00 00 00 00 00
	00		 mov	 DWORD PTR tv519[rsp], 0
$LN138@TCOpenVolu:
  01066	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  0106e	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  01074	4c 8b 8c 24 60
	03 00 00	 mov	 r9, QWORD PTR mount$[rsp]
  0107c	49 81 c1 18 02
	00 00		 add	 r9, 536			; 00000218H
  01083	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01088	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR readBuffer$[rsp]
  01090	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  01098	8b 90 60 02 00
	00		 mov	 edx, DWORD PTR [rax+608]
  0109e	8b 8c 24 24 03
	00 00		 mov	 ecx, DWORD PTR tv519[rsp]
  010a5	e8 00 00 00 00	 call	 ReadVolumeHeaderWCache
  010aa	8b d0		 mov	 edx, eax
  010ac	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  010b4	89 10		 mov	 DWORD PTR [rax], edx
$LN50@TCOpenVolu:

; 473  : 		}
; 474  : 
; 475  : 		ReadVolumeHeaderRecoveryMode = FALSE;

  010b6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ReadVolumeHeaderRecoveryMode, 0

; 476  : 
; 477  : 		if (mount->nReturnCode == 0 || mount->nReturnCode == ERR_CIPHER_INIT_WEAK_KEY)

  010c0	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  010c8	83 38 00	 cmp	 DWORD PTR [rax], 0
  010cb	74 11		 je	 SHORT $LN48@TCOpenVolu
  010cd	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  010d5	83 38 12	 cmp	 DWORD PTR [rax], 18
  010d8	0f 85 ab 09 00
	00		 jne	 $LN49@TCOpenVolu
$LN48@TCOpenVolu:

; 478  : 		{
; 479  : 			/* Volume header successfully decrypted */
; 480  : 
; 481  : 			Dump ("Volume header decrypted\n");

  010de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@JCBFCEPL@Volume?5header?5decrypted?6?$AA@FNODOBFM@
  010e5	e8 00 00 00 00	 call	 DbgPrint

; 482  : 			Dump ("Required program version = %x\n", (int) Extension->cryptoInfo->RequiredProgramVersion);

  010ea	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  010f2	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  010f9	0f b7 90 38 44
	00 00		 movzx	 edx, WORD PTR [rax+17464]
  01100	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@GNIOJEAD@Required?5program?5version?5?$DN?5?$CFx?6?$AA@FNODOBFM@
  01107	e8 00 00 00 00	 call	 DbgPrint

; 483  : 			Dump ("Legacy volume = %d\n", (int) Extension->cryptoInfo->LegacyVolume);

  0110c	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  01114	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0111b	8b 90 3c 44 00
	00		 mov	 edx, DWORD PTR [rax+17468]
  01121	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@LHJMDIKA@Legacy?5volume?5?$DN?5?$CFd?6?$AA@FNODOBFM@
  01128	e8 00 00 00 00	 call	 DbgPrint

; 484  : 
; 485  : 			if (IsHiddenSystemRunning() && !Extension->cryptoInfo->hiddenVolume)

  0112d	e8 00 00 00 00	 call	 IsHiddenSystemRunning
  01132	85 c0		 test	 eax, eax
  01134	74 4b		 je	 SHORT $LN47@TCOpenVolu
  01136	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  0113e	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  01145	83 b8 a0 29 00
	00 00		 cmp	 DWORD PTR [rax+10656], 0
  0114c	75 33		 jne	 SHORT $LN47@TCOpenVolu

; 486  : 			{
; 487  : 				Extension->bReadOnly = mount->bMountReadOnly = TRUE;

  0114e	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  01156	c7 80 6c 02 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+620], 1
  01160	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  01168	c7 80 98 03 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+920], 1

; 488  : 				HiddenSysLeakProtectionCount++;

  01172	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR HiddenSysLeakProtectionCount
  01178	83 c0 01	 add	 eax, 1
  0117b	89 05 00 00 00
	00		 mov	 DWORD PTR HiddenSysLeakProtectionCount, eax
$LN47@TCOpenVolu:

; 489  : 			}
; 490  : 
; 491  : 			Extension->cryptoInfo->bProtectHiddenVolume = FALSE;

  01181	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  01189	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  01190	c7 80 00 44 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+17408], 0

; 492  : 			Extension->cryptoInfo->bHiddenVolProtectionAction = FALSE;

  0119a	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  011a2	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  011a9	c7 80 04 44 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+17412], 0

; 493  : 
; 494  : 			Extension->cryptoInfo->bPartitionInInactiveSysEncScope = mount->bPartitionInInactiveSysEncScope;

  011b3	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  011bb	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  011c2	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  011ca	8b 80 80 02 00
	00		 mov	 eax, DWORD PTR [rax+640]
  011d0	89 81 28 44 00
	00		 mov	 DWORD PTR [rcx+17448], eax

; 495  : 
; 496  : 			if (volumeType == TC_VOLUME_TYPE_NORMAL)

  011d6	83 bc 24 20 01
	00 00 00	 cmp	 DWORD PTR volumeType$[rsp], 0
  011de	0f 85 3f 01 00
	00		 jne	 $LN46@TCOpenVolu

; 497  : 			{
; 498  : 				if (mount->bPartitionInInactiveSysEncScope)

  011e4	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  011ec	83 b8 80 02 00
	00 00		 cmp	 DWORD PTR [rax+640], 0
  011f3	0f 84 c2 00 00
	00		 je	 $LN45@TCOpenVolu

; 499  : 				{
; 500  : 					if (Extension->cryptoInfo->EncryptedAreaStart.Value > (unsigned __int64) partitionStartingOffset
; 501  : 						|| Extension->cryptoInfo->EncryptedAreaStart.Value + Extension->cryptoInfo->VolumeSize.Value <= (unsigned __int64) partitionStartingOffset)

  011f9	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  01201	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  01208	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR partitionStartingOffset$[rsp]
  01210	48 39 81 50 44
	00 00		 cmp	 QWORD PTR [rcx+17488], rax
  01217	77 36		 ja	 SHORT $LN43@TCOpenVolu
  01219	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  01221	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  01228	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  01230	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  01237	48 8b 80 50 44
	00 00		 mov	 rax, QWORD PTR [rax+17488]
  0123e	48 03 81 48 44
	00 00		 add	 rax, QWORD PTR [rcx+17480]
  01245	48 3b 84 24 28
	01 00 00	 cmp	 rax, QWORD PTR partitionStartingOffset$[rsp]
  0124d	77 1e		 ja	 SHORT $LN44@TCOpenVolu
$LN43@TCOpenVolu:

; 502  : 					{
; 503  : 						// The partition is not within the key scope of system encryption
; 504  : 						mount->nReturnCode = ERR_PASSWORD_WRONG;

  0124f	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  01257	c7 00 03 00 00
	00		 mov	 DWORD PTR [rax], 3

; 505  : 						ntStatus = STATUS_SUCCESS;

  0125d	c7 84 24 24 01
	00 00 00 00 00
	00		 mov	 DWORD PTR ntStatus$[rsp], 0

; 506  : 						goto error;

  01268	e9 70 08 00 00	 jmp	 $error$30873
$LN44@TCOpenVolu:

; 507  : 					}
; 508  : 
; 509  : 					if (Extension->cryptoInfo->EncryptedAreaLength.Value != Extension->cryptoInfo->VolumeSize.Value)

  0126d	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  01275	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  0127c	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  01284	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0128b	48 8b 80 48 44
	00 00		 mov	 rax, QWORD PTR [rax+17480]
  01292	48 39 81 58 44
	00 00		 cmp	 QWORD PTR [rcx+17496], rax
  01299	74 1e		 je	 SHORT $LN42@TCOpenVolu

; 510  : 					{
; 511  : 						// Partial encryption is not supported for volumes mounted as regular
; 512  : 						mount->nReturnCode = ERR_ENCRYPTION_NOT_COMPLETED;

  0129b	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  012a3	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 513  : 						ntStatus = STATUS_SUCCESS;

  012a9	c7 84 24 24 01
	00 00 00 00 00
	00		 mov	 DWORD PTR ntStatus$[rsp], 0

; 514  : 						goto error;

  012b4	e9 24 08 00 00	 jmp	 $error$30873
$LN42@TCOpenVolu:

; 515  : 					}

  012b9	eb 68		 jmp	 SHORT $LN41@TCOpenVolu
$LN45@TCOpenVolu:

; 516  : 				}
; 517  : 				else if (Extension->cryptoInfo->HeaderFlags & TC_HEADER_FLAG_NONSYS_INPLACE_ENC)

  012bb	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  012c3	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  012ca	8b 80 60 44 00
	00		 mov	 eax, DWORD PTR [rax+17504]
  012d0	83 e0 02	 and	 eax, 2
  012d3	85 c0		 test	 eax, eax
  012d5	74 4c		 je	 SHORT $LN40@TCOpenVolu

; 518  : 				{
; 519  : 					if (Extension->cryptoInfo->EncryptedAreaLength.Value != Extension->cryptoInfo->VolumeSize.Value)

  012d7	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  012df	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  012e6	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  012ee	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  012f5	48 8b 80 48 44
	00 00		 mov	 rax, QWORD PTR [rax+17480]
  012fc	48 39 81 58 44
	00 00		 cmp	 QWORD PTR [rcx+17496], rax
  01303	74 1e		 je	 SHORT $LN39@TCOpenVolu

; 520  : 					{
; 521  : 						// Non-system in-place encryption process has not been completed on this volume
; 522  : 						mount->nReturnCode = ERR_NONSYS_INPLACE_ENC_INCOMPLETE;

  01305	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  0130d	c7 00 20 00 00
	00		 mov	 DWORD PTR [rax], 32	; 00000020H

; 523  : 						ntStatus = STATUS_SUCCESS;

  01313	c7 84 24 24 01
	00 00 00 00 00
	00		 mov	 DWORD PTR ntStatus$[rsp], 0

; 524  : 						goto error;

  0131e	e9 ba 07 00 00	 jmp	 $error$30873
$LN39@TCOpenVolu:
$LN40@TCOpenVolu:
$LN41@TCOpenVolu:
$LN46@TCOpenVolu:

; 525  : 					}
; 526  : 				}
; 527  : 			}
; 528  : 
; 529  : 			Extension->cryptoInfo->FirstDataUnitNo.Value = 0;

  01323	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  0132b	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  01332	48 c7 80 30 44
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+17456], 0

; 530  : 
; 531  : 			if (Extension->cryptoInfo->hiddenVolume && IsHiddenSystemRunning())

  0133d	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  01345	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0134c	83 b8 a0 29 00
	00 00		 cmp	 DWORD PTR [rax+10656], 0
  01353	74 71		 je	 SHORT $LN38@TCOpenVolu
  01355	e8 00 00 00 00	 call	 IsHiddenSystemRunning
  0135a	85 c0		 test	 eax, eax
  0135c	74 68		 je	 SHORT $LN38@TCOpenVolu

; 532  : 			{
; 533  : 				// Prevent mount of a hidden system partition if the system hosted on it is currently running
; 534  : 				if (memcmp (Extension->cryptoInfo->master_keydata, GetSystemDriveCryptoInfo()->master_keydata, EAGetKeySize (Extension->cryptoInfo->ea)) == 0)

  0135e	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  01366	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0136d	8b 08		 mov	 ecx, DWORD PTR [rax]
  0136f	e8 00 00 00 00	 call	 EAGetKeySize
  01374	48 63 f8	 movsxd	 rdi, eax
  01377	e8 00 00 00 00	 call	 GetSystemDriveCryptoInfo
  0137c	48 8b d0	 mov	 rdx, rax
  0137f	48 81 c2 a8 41
	00 00		 add	 rdx, 16808		; 000041a8H
  01386	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  0138e	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  01395	48 81 c1 a8 41
	00 00		 add	 rcx, 16808		; 000041a8H
  0139c	4c 8b c7	 mov	 r8, rdi
  0139f	e8 00 00 00 00	 call	 memcmp
  013a4	85 c0		 test	 eax, eax
  013a6	75 1e		 jne	 SHORT $LN37@TCOpenVolu

; 535  : 				{
; 536  : 					mount->nReturnCode = ERR_VOL_ALREADY_MOUNTED;

  013a8	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  013b0	c7 00 15 00 00
	00		 mov	 DWORD PTR [rax], 21

; 537  : 					ntStatus = STATUS_SUCCESS;

  013b6	c7 84 24 24 01
	00 00 00 00 00
	00		 mov	 DWORD PTR ntStatus$[rsp], 0

; 538  : 					goto error;

  013c1	e9 17 07 00 00	 jmp	 $error$30873
$LN37@TCOpenVolu:
$LN38@TCOpenVolu:

; 539  : 				}
; 540  : 			}
; 541  : 
; 542  : 			switch (volumeType)

  013c6	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR volumeType$[rsp]
  013cd	89 84 24 28 03
	00 00		 mov	 DWORD PTR tv597[rsp], eax
  013d4	83 bc 24 28 03
	00 00 00	 cmp	 DWORD PTR tv597[rsp], 0
  013dc	74 21		 je	 SHORT $LN34@TCOpenVolu
  013de	83 bc 24 28 03
	00 00 00	 cmp	 DWORD PTR tv597[rsp], 0
  013e6	0f 8e 18 04 00
	00		 jle	 $LN35@TCOpenVolu
  013ec	83 bc 24 28 03
	00 00 02	 cmp	 DWORD PTR tv597[rsp], 2
  013f4	0f 8e 3e 01 00
	00		 jle	 $LN29@TCOpenVolu
  013fa	e9 05 04 00 00	 jmp	 $LN35@TCOpenVolu
$LN34@TCOpenVolu:

; 543  : 			{
; 544  : 			case TC_VOLUME_TYPE_NORMAL:
; 545  : 
; 546  : 				Extension->cryptoInfo->hiddenVolume = FALSE;

  013ff	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  01407	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0140e	c7 80 a0 29 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+10656], 0

; 547  : 
; 548  : 				if (mount->bPartitionInInactiveSysEncScope)

  01418	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  01420	83 b8 80 02 00
	00 00		 cmp	 DWORD PTR [rax+640], 0
  01427	74 67		 je	 SHORT $LN33@TCOpenVolu

; 549  : 				{
; 550  : 					Extension->cryptoInfo->volDataAreaOffset = 0;

  01429	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  01431	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  01438	48 c7 80 08 44
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+17416], 0

; 551  : 					Extension->DiskLength = lDiskLength.QuadPart;

  01443	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  0144b	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR lDiskLength$[rsp]
  01453	48 89 81 a0 00
	00 00		 mov	 QWORD PTR [rcx+160], rax

; 552  : 					Extension->cryptoInfo->FirstDataUnitNo.Value = partitionStartingOffset / ENCRYPTION_DATA_UNIT_SIZE;

  0145a	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR partitionStartingOffset$[rsp]
  01462	48 99		 cdq
  01464	48 81 e2 ff 01
	00 00		 and	 rdx, 511		; 000001ffH
  0146b	48 03 c2	 add	 rax, rdx
  0146e	48 c1 f8 09	 sar	 rax, 9
  01472	48 8b c8	 mov	 rcx, rax
  01475	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  0147d	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  01484	48 89 88 30 44
	00 00		 mov	 QWORD PTR [rax+17456], rcx
  0148b	e9 a3 00 00 00	 jmp	 $LN32@TCOpenVolu
$LN33@TCOpenVolu:

; 553  : 				}
; 554  : 				else if (Extension->cryptoInfo->LegacyVolume)

  01490	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  01498	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0149f	83 b8 3c 44 00
	00 00		 cmp	 DWORD PTR [rax+17468], 0
  014a6	74 3a		 je	 SHORT $LN31@TCOpenVolu

; 555  : 				{
; 556  : 					Extension->cryptoInfo->volDataAreaOffset = TC_VOLUME_HEADER_SIZE_LEGACY;

  014a8	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  014b0	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  014b7	48 c7 80 08 44
	00 00 00 02 00
	00		 mov	 QWORD PTR [rax+17416], 512 ; 00000200H

; 557  : 					Extension->DiskLength = lDiskLength.QuadPart - TC_VOLUME_HEADER_SIZE_LEGACY;

  014c2	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR lDiskLength$[rsp]
  014ca	48 81 e9 00 02
	00 00		 sub	 rcx, 512		; 00000200H
  014d1	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  014d9	48 89 88 a0 00
	00 00		 mov	 QWORD PTR [rax+160], rcx

; 558  : 				}
; 559  : 				else

  014e0	eb 51		 jmp	 SHORT $LN30@TCOpenVolu
$LN31@TCOpenVolu:

; 560  : 				{
; 561  : 					Extension->cryptoInfo->volDataAreaOffset = Extension->cryptoInfo->EncryptedAreaStart.Value;

  014e2	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  014ea	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  014f1	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  014f9	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  01500	48 8b 80 50 44
	00 00		 mov	 rax, QWORD PTR [rax+17488]
  01507	48 89 81 08 44
	00 00		 mov	 QWORD PTR [rcx+17416], rax

; 562  : 					Extension->DiskLength = Extension->cryptoInfo->VolumeSize.Value;

  0150e	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  01516	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0151d	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  01525	48 8b 80 48 44
	00 00		 mov	 rax, QWORD PTR [rax+17480]
  0152c	48 89 81 a0 00
	00 00		 mov	 QWORD PTR [rcx+160], rax
$LN30@TCOpenVolu:
$LN32@TCOpenVolu:

; 563  : 				}
; 564  : 
; 565  : 				break;

  01533	e9 cc 02 00 00	 jmp	 $LN35@TCOpenVolu
$LN29@TCOpenVolu:

; 566  : 
; 567  : 			case TC_VOLUME_TYPE_HIDDEN:
; 568  : 			case TC_VOLUME_TYPE_HIDDEN_LEGACY:
; 569  : 
; 570  : 				cryptoInfoPtr = mount->bProtectHiddenVolume ? tmpCryptoInfo : Extension->cryptoInfo;

  01538	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  01540	83 b8 8c 02 00
	00 00		 cmp	 DWORD PTR [rax+652], 0
  01547	74 12		 je	 SHORT $LN139@TCOpenVolu
  01549	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tmpCryptoInfo$[rsp]
  01551	48 89 84 24 30
	03 00 00	 mov	 QWORD PTR tv625[rsp], rax
  01559	eb 17		 jmp	 SHORT $LN140@TCOpenVolu
$LN139@TCOpenVolu:
  0155b	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  01563	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0156a	48 89 84 24 30
	03 00 00	 mov	 QWORD PTR tv625[rsp], rax
$LN140@TCOpenVolu:
  01572	48 8b 84 24 30
	03 00 00	 mov	 rax, QWORD PTR tv625[rsp]
  0157a	48 89 44 24 78	 mov	 QWORD PTR cryptoInfoPtr$[rsp], rax

; 571  : 
; 572  : 				if (volumeType == TC_VOLUME_TYPE_HIDDEN_LEGACY)

  0157f	83 bc 24 20 01
	00 00 02	 cmp	 DWORD PTR volumeType$[rsp], 2
  01587	75 36		 jne	 SHORT $LN28@TCOpenVolu

; 573  : 					Extension->cryptoInfo->hiddenVolumeOffset = lDiskLength.QuadPart - cryptoInfoPtr->hiddenVolumeSize - TC_HIDDEN_VOLUME_HEADER_OFFSET_LEGACY;

  01589	48 8b 44 24 78	 mov	 rax, QWORD PTR cryptoInfoPtr$[rsp]
  0158e	48 8b 80 10 44
	00 00		 mov	 rax, QWORD PTR [rax+17424]
  01595	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR lDiskLength$[rsp]
  0159d	48 2b c8	 sub	 rcx, rax
  015a0	48 81 e9 00 06
	00 00		 sub	 rcx, 1536		; 00000600H
  015a7	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  015af	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  015b6	48 89 88 18 44
	00 00		 mov	 QWORD PTR [rax+17432], rcx

; 574  : 				else

  015bd	eb 22		 jmp	 SHORT $LN27@TCOpenVolu
$LN28@TCOpenVolu:

; 575  : 					Extension->cryptoInfo->hiddenVolumeOffset = cryptoInfoPtr->EncryptedAreaStart.Value;

  015bf	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  015c7	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  015ce	48 8b 44 24 78	 mov	 rax, QWORD PTR cryptoInfoPtr$[rsp]
  015d3	48 8b 80 50 44
	00 00		 mov	 rax, QWORD PTR [rax+17488]
  015da	48 89 81 18 44
	00 00		 mov	 QWORD PTR [rcx+17432], rax
$LN27@TCOpenVolu:

; 576  : 
; 577  : 				Dump ("Hidden volume offset = %I64d\n", Extension->cryptoInfo->hiddenVolumeOffset);

  015e1	48 8b 94 24 58
	03 00 00	 mov	 rdx, QWORD PTR Extension$[rsp]
  015e9	48 8b 92 90 00
	00 00		 mov	 rdx, QWORD PTR [rdx+144]
  015f0	48 8b 92 18 44
	00 00		 mov	 rdx, QWORD PTR [rdx+17432]
  015f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@HCAAKCJO@Hidden?5volume?5offset?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@
  015fe	e8 00 00 00 00	 call	 DbgPrint

; 578  : 				Dump ("Hidden volume size = %I64d\n", cryptoInfoPtr->hiddenVolumeSize);

  01603	48 8b 54 24 78	 mov	 rdx, QWORD PTR cryptoInfoPtr$[rsp]
  01608	48 8b 92 10 44
	00 00		 mov	 rdx, QWORD PTR [rdx+17424]
  0160f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@CHOGCNPN@Hidden?5volume?5size?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@
  01616	e8 00 00 00 00	 call	 DbgPrint

; 579  : 				Dump ("Hidden volume end = %I64d\n", Extension->cryptoInfo->hiddenVolumeOffset + cryptoInfoPtr->hiddenVolumeSize - 1);

  0161b	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  01623	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  0162a	48 8b 89 18 44
	00 00		 mov	 rcx, QWORD PTR [rcx+17432]
  01631	48 8b 44 24 78	 mov	 rax, QWORD PTR cryptoInfoPtr$[rsp]
  01636	48 8b 80 10 44
	00 00		 mov	 rax, QWORD PTR [rax+17424]
  0163d	48 8d 54 01 ff	 lea	 rdx, QWORD PTR [rcx+rax-1]
  01642	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@DBKGLLJI@Hidden?5volume?5end?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@
  01649	e8 00 00 00 00	 call	 DbgPrint

; 580  : 
; 581  : 				// Validate the offset
; 582  : 				if (Extension->cryptoInfo->hiddenVolumeOffset % ENCRYPTION_DATA_UNIT_SIZE != 0)

  0164e	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  01656	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0165d	33 d2		 xor	 edx, edx
  0165f	48 8b 80 18 44
	00 00		 mov	 rax, QWORD PTR [rax+17432]
  01666	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0166b	48 f7 f1	 div	 rcx
  0166e	48 85 d2	 test	 rdx, rdx
  01671	74 1e		 je	 SHORT $LN26@TCOpenVolu

; 583  : 				{
; 584  : 					mount->nReturnCode = ERR_VOL_SIZE_WRONG;

  01673	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  0167b	c7 00 07 00 00
	00		 mov	 DWORD PTR [rax], 7

; 585  : 					ntStatus = STATUS_SUCCESS;

  01681	c7 84 24 24 01
	00 00 00 00 00
	00		 mov	 DWORD PTR ntStatus$[rsp], 0

; 586  : 					goto error;

  0168c	e9 4c 04 00 00	 jmp	 $error$30873
$LN26@TCOpenVolu:

; 587  : 				}
; 588  : 
; 589  : 				// If we are supposed to actually mount the hidden volume (not just to protect it)
; 590  : 				if (!mount->bProtectHiddenVolume)	

  01691	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  01699	83 b8 8c 02 00
	00 00		 cmp	 DWORD PTR [rax+652], 0
  016a0	75 65		 jne	 SHORT $LN25@TCOpenVolu

; 591  : 				{
; 592  : 					Extension->DiskLength = cryptoInfoPtr->hiddenVolumeSize;

  016a2	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  016aa	48 8b 44 24 78	 mov	 rax, QWORD PTR cryptoInfoPtr$[rsp]
  016af	48 8b 80 10 44
	00 00		 mov	 rax, QWORD PTR [rax+17424]
  016b6	48 89 81 a0 00
	00 00		 mov	 QWORD PTR [rcx+160], rax

; 593  : 					Extension->cryptoInfo->hiddenVolume = TRUE;

  016bd	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  016c5	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  016cc	c7 80 a0 29 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+10656], 1

; 594  : 					Extension->cryptoInfo->volDataAreaOffset = Extension->cryptoInfo->hiddenVolumeOffset;

  016d6	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  016de	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  016e5	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  016ed	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  016f4	48 8b 80 18 44
	00 00		 mov	 rax, QWORD PTR [rax+17432]
  016fb	48 89 81 08 44
	00 00		 mov	 QWORD PTR [rcx+17416], rax

; 595  : 				}
; 596  : 				else

  01702	e9 fd 00 00 00	 jmp	 $LN24@TCOpenVolu
$LN25@TCOpenVolu:

; 597  : 				{
; 598  : 					// Hidden volume protection
; 599  : 					Extension->cryptoInfo->hiddenVolume = FALSE;

  01707	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  0170f	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  01716	c7 80 a0 29 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+10656], 0

; 600  : 					Extension->cryptoInfo->bProtectHiddenVolume = TRUE;

  01720	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  01728	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0172f	c7 80 00 44 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+17408], 1

; 601  : 					
; 602  : 					Extension->cryptoInfo->hiddenVolumeProtectedSize = tmpCryptoInfo->hiddenVolumeSize;

  01739	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  01741	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  01748	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tmpCryptoInfo$[rsp]
  01750	48 8b 80 10 44
	00 00		 mov	 rax, QWORD PTR [rax+17424]
  01757	48 89 81 20 44
	00 00		 mov	 QWORD PTR [rcx+17440], rax

; 603  : 
; 604  : 					if (volumeType == TC_VOLUME_TYPE_HIDDEN_LEGACY)

  0175e	83 bc 24 20 01
	00 00 02	 cmp	 DWORD PTR volumeType$[rsp], 2
  01766	75 33		 jne	 SHORT $LN23@TCOpenVolu

; 605  : 						Extension->cryptoInfo->hiddenVolumeProtectedSize += TC_VOLUME_HEADER_SIZE_LEGACY;

  01768	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  01770	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  01777	48 8b 89 20 44
	00 00		 mov	 rcx, QWORD PTR [rcx+17440]
  0177e	48 81 c1 00 02
	00 00		 add	 rcx, 512		; 00000200H
  01785	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  0178d	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  01794	48 89 88 20 44
	00 00		 mov	 QWORD PTR [rax+17440], rcx
$LN23@TCOpenVolu:

; 606  : 
; 607  : 					Dump ("Hidden volume protection active: %I64d-%I64d (%I64d)\n", Extension->cryptoInfo->hiddenVolumeOffset, Extension->cryptoInfo->hiddenVolumeProtectedSize + Extension->cryptoInfo->hiddenVolumeOffset - 1, Extension->cryptoInfo->hiddenVolumeProtectedSize);

  0179b	4c 8b 8c 24 58
	03 00 00	 mov	 r9, QWORD PTR Extension$[rsp]
  017a3	4d 8b 89 90 00
	00 00		 mov	 r9, QWORD PTR [r9+144]
  017aa	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  017b2	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  017b9	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  017c1	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  017c8	48 8b 89 20 44
	00 00		 mov	 rcx, QWORD PTR [rcx+17440]
  017cf	48 8b 80 18 44
	00 00		 mov	 rax, QWORD PTR [rax+17432]
  017d6	4c 8d 44 01 ff	 lea	 r8, QWORD PTR [rcx+rax-1]
  017db	48 8b 94 24 58
	03 00 00	 mov	 rdx, QWORD PTR Extension$[rsp]
  017e3	48 8b 92 90 00
	00 00		 mov	 rdx, QWORD PTR [rdx+144]
  017ea	4d 8b 89 20 44
	00 00		 mov	 r9, QWORD PTR [r9+17440]
  017f1	48 8b 92 18 44
	00 00		 mov	 rdx, QWORD PTR [rdx+17432]
  017f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DG@NLAOEFNO@Hidden?5volume?5protection?5active?3@FNODOBFM@
  017ff	e8 00 00 00 00	 call	 DbgPrint
$LN24@TCOpenVolu:
$LN35@TCOpenVolu:

; 608  : 				}
; 609  : 
; 610  : 				break;
; 611  : 			}
; 612  : 
; 613  : 			Dump ("Volume data offset = %I64d\n", Extension->cryptoInfo->volDataAreaOffset);

  01804	48 8b 94 24 58
	03 00 00	 mov	 rdx, QWORD PTR Extension$[rsp]
  0180c	48 8b 92 90 00
	00 00		 mov	 rdx, QWORD PTR [rdx+144]
  01813	48 8b 92 08 44
	00 00		 mov	 rdx, QWORD PTR [rdx+17416]
  0181a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@CDNAEGGM@Volume?5data?5offset?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@
  01821	e8 00 00 00 00	 call	 DbgPrint

; 614  : 			Dump ("Volume data size = %I64d\n", Extension->DiskLength);

  01826	48 8b 94 24 58
	03 00 00	 mov	 rdx, QWORD PTR Extension$[rsp]
  0182e	48 8b 92 a0 00
	00 00		 mov	 rdx, QWORD PTR [rdx+160]
  01835	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BIKGCOPF@Volume?5data?5size?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@
  0183c	e8 00 00 00 00	 call	 DbgPrint

; 615  : 			Dump ("Volume data end = %I64d\n", Extension->cryptoInfo->volDataAreaOffset + Extension->DiskLength - 1);

  01841	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  01849	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  01850	48 8b 89 08 44
	00 00		 mov	 rcx, QWORD PTR [rcx+17416]
  01857	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  0185f	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  01866	48 8d 54 01 ff	 lea	 rdx, QWORD PTR [rcx+rax-1]
  0186b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@MEKDGODO@Volume?5data?5end?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@
  01872	e8 00 00 00 00	 call	 DbgPrint

; 616  : 
; 617  : 			if (Extension->DiskLength == 0)

  01877	48 8b 94 24 58
	03 00 00	 mov	 rdx, QWORD PTR Extension$[rsp]
  0187f	48 83 ba a0 00
	00 00 00	 cmp	 QWORD PTR [rdx+160], 0
  01887	75 11		 jne	 SHORT $LN22@TCOpenVolu

; 618  : 			{
; 619  : 				Dump ("Incorrect volume size\n");

  01889	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@JONGPBLO@Incorrect?5volume?5size?6?$AA@FNODOBFM@
  01890	e8 00 00 00 00	 call	 DbgPrint

; 620  : 				continue;

  01895	e9 f9 f1 ff ff	 jmp	 $LN73@TCOpenVolu
$LN22@TCOpenVolu:

; 621  : 			}
; 622  : 
; 623  : 			// If this is a hidden volume, make sure we are supposed to actually
; 624  : 			// mount it (i.e. not just to protect it)
; 625  : 			if (volumeType == TC_VOLUME_TYPE_NORMAL || !mount->bProtectHiddenVolume)	

  0189a	83 bc 24 20 01
	00 00 00	 cmp	 DWORD PTR volumeType$[rsp], 0
  018a2	74 15		 je	 SHORT $LN20@TCOpenVolu
  018a4	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  018ac	83 b8 8c 02 00
	00 00		 cmp	 DWORD PTR [rax+652], 0
  018b3	0f 85 75 01 00
	00		 jne	 $LN21@TCOpenVolu
$LN20@TCOpenVolu:

; 626  : 			{
; 627  : 				// Validate sector size
; 628  : 				if (bRawDevice && Extension->cryptoInfo->SectorSize != Extension->HostBytesPerSector)

  018b9	83 bc 24 70 03
	00 00 00	 cmp	 DWORD PTR bRawDevice$[rsp], 0
  018c1	74 43		 je	 SHORT $LN19@TCOpenVolu
  018c3	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  018cb	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  018d2	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  018da	8b 80 c0 00 00
	00		 mov	 eax, DWORD PTR [rax+192]
  018e0	39 81 40 44 00
	00		 cmp	 DWORD PTR [rcx+17472], eax
  018e6	74 1e		 je	 SHORT $LN19@TCOpenVolu

; 629  : 				{
; 630  : 					mount->nReturnCode = ERR_PARAMETER_INCORRECT;

  018e8	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  018f0	c7 00 1e 00 00
	00		 mov	 DWORD PTR [rax], 30

; 631  : 					ntStatus = STATUS_SUCCESS;

  018f6	c7 84 24 24 01
	00 00 00 00 00
	00		 mov	 DWORD PTR ntStatus$[rsp], 0

; 632  : 					goto error;

  01901	e9 d7 01 00 00	 jmp	 $error$30873
$LN19@TCOpenVolu:

; 633  : 				}
; 634  : 
; 635  : 				// Calculate virtual volume geometry
; 636  : 				Extension->TracksPerCylinder = 1;

  01906	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  0190e	c7 80 b0 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+176], 1

; 637  : 				Extension->SectorsPerTrack = 1;

  01918	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  01920	c7 80 b4 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+180], 1

; 638  : 				Extension->BytesPerSector = Extension->cryptoInfo->SectorSize;

  0192a	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  01932	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  01939	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  01941	8b 80 40 44 00
	00		 mov	 eax, DWORD PTR [rax+17472]
  01947	89 81 b8 00 00
	00		 mov	 DWORD PTR [rcx+184], eax

; 639  : 				Extension->NumberOfCylinders = Extension->DiskLength / Extension->BytesPerSector;

  0194d	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  01955	8b 88 b8 00 00
	00		 mov	 ecx, DWORD PTR [rax+184]
  0195b	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  01963	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  0196a	48 99		 cdq
  0196c	48 f7 f9	 idiv	 rcx
  0196f	48 8b c8	 mov	 rcx, rax
  01972	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  0197a	48 89 88 a8 00
	00 00		 mov	 QWORD PTR [rax+168], rcx

; 640  : 				Extension->PartitionType = 0;

  01981	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  01989	c6 80 bc 00 00
	00 00		 mov	 BYTE PTR [rax+188], 0

; 641  : 
; 642  : 				Extension->bRawDevice = bRawDevice;

  01990	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  01998	8b 84 24 70 03
	00 00		 mov	 eax, DWORD PTR bRawDevice$[rsp]
  0199f	89 81 a4 03 00
	00		 mov	 DWORD PTR [rcx+932], eax

; 643  : 				
; 644  : 				memset (Extension->wszVolume, 0, sizeof (Extension->wszVolume));

  019a5	48 8b bc 24 58
	03 00 00	 mov	 rdi, QWORD PTR Extension$[rsp]
  019ad	48 81 c7 b0 03
	00 00		 add	 rdi, 944		; 000003b0H
  019b4	33 c0		 xor	 eax, eax
  019b6	b9 08 02 00 00	 mov	 ecx, 520		; 00000208H
  019bb	f3 aa		 rep stosb

; 645  : 				if (wcsstr (pwszMountVolume, WIDE ("\\??\\UNC\\")) == pwszMountVolume)

  019bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1BC@MAMPPFNN@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AAU?$AAN?$AAC?$AA?2?$AA?$AA@FNODOBFM@
  019c4	48 8b 8c 24 68
	03 00 00	 mov	 rcx, QWORD PTR pwszMountVolume$[rsp]
  019cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsstr
  019d2	48 3b 84 24 68
	03 00 00	 cmp	 rax, QWORD PTR pwszMountVolume$[rsp]
  019da	75 2f		 jne	 SHORT $LN18@TCOpenVolu

; 646  : 				{
; 647  : 					/* UNC path */
; 648  : 					_snwprintf (Extension->wszVolume,
; 649  : 						sizeof (Extension->wszVolume) / sizeof (WCHAR) - 1,
; 650  : 						WIDE ("\\??\\\\%s"),
; 651  : 						pwszMountVolume + 7);

  019dc	4c 8b 8c 24 68
	03 00 00	 mov	 r9, QWORD PTR pwszMountVolume$[rsp]
  019e4	49 83 c1 0e	 add	 r9, 14
  019e8	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  019f0	48 81 c1 b0 03
	00 00		 add	 rcx, 944		; 000003b0H
  019f7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1BA@GIIKONIJ@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@
  019fe	ba 03 01 00 00	 mov	 edx, 259		; 00000103H
  01a03	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__snwprintf

; 652  : 				}
; 653  : 				else

  01a09	eb 23		 jmp	 SHORT $LN17@TCOpenVolu
$LN18@TCOpenVolu:

; 654  : 				{
; 655  : 					wcsncpy (Extension->wszVolume, pwszMountVolume, sizeof (Extension->wszVolume) / sizeof (WCHAR) - 1);

  01a0b	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  01a13	48 81 c1 b0 03
	00 00		 add	 rcx, 944		; 000003b0H
  01a1a	41 b8 03 01 00
	00		 mov	 r8d, 259		; 00000103H
  01a20	48 8b 94 24 68
	03 00 00	 mov	 rdx, QWORD PTR pwszMountVolume$[rsp]
  01a28	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncpy
$LN17@TCOpenVolu:
$LN21@TCOpenVolu:

; 656  : 				}
; 657  : 			}
; 658  : 
; 659  : 			// If we are to protect a hidden volume we cannot exit yet, for we must also
; 660  : 			// decrypt the hidden volume header.
; 661  : 			if (!(volumeType == TC_VOLUME_TYPE_NORMAL && mount->bProtectHiddenVolume))

  01a2e	83 bc 24 20 01
	00 00 00	 cmp	 DWORD PTR volumeType$[rsp], 0
  01a36	75 11		 jne	 SHORT $LN15@TCOpenVolu
  01a38	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  01a40	83 b8 8c 02 00
	00 00		 cmp	 DWORD PTR [rax+652], 0
  01a47	75 3e		 jne	 SHORT $LN16@TCOpenVolu
$LN15@TCOpenVolu:

; 662  : 			{
; 663  : 				TCfree (readBuffer);

  01a49	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  01a4e	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR readBuffer$[rsp]
  01a56	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 664  : 
; 665  : 				if (tmpCryptoInfo != NULL)

  01a5c	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR tmpCryptoInfo$[rsp], 0
  01a65	74 19		 je	 SHORT $LN14@TCOpenVolu

; 666  : 				{
; 667  : 					crypto_close (tmpCryptoInfo);

  01a67	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tmpCryptoInfo$[rsp]
  01a6f	e8 00 00 00 00	 call	 crypto_close

; 668  : 					tmpCryptoInfo = NULL;

  01a74	48 c7 84 24 30
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tmpCryptoInfo$[rsp], 0
$LN14@TCOpenVolu:

; 669  : 				}
; 670  : 				
; 671  : 				return STATUS_SUCCESS;

  01a80	33 c0		 xor	 eax, eax
  01a82	e9 59 01 00 00	 jmp	 $LN108@TCOpenVolu
$LN16@TCOpenVolu:

; 672  : 			}
; 673  : 		}
; 674  : 		else if ((mount->bProtectHiddenVolume && volumeType == TC_VOLUME_TYPE_NORMAL)

  01a87	eb 2a		 jmp	 SHORT $LN13@TCOpenVolu
$LN49@TCOpenVolu:

; 675  : 			  || mount->nReturnCode != ERR_PASSWORD_WRONG)

  01a89	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  01a91	83 b8 8c 02 00
	00 00		 cmp	 DWORD PTR [rax+652], 0
  01a98	74 0a		 je	 SHORT $LN10@TCOpenVolu
  01a9a	83 bc 24 20 01
	00 00 00	 cmp	 DWORD PTR volumeType$[rsp], 0
  01aa2	74 0d		 je	 SHORT $LN11@TCOpenVolu
$LN10@TCOpenVolu:
  01aa4	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  01aac	83 38 03	 cmp	 DWORD PTR [rax], 3
  01aaf	74 02		 je	 SHORT $LN12@TCOpenVolu
$LN11@TCOpenVolu:

; 676  : 		{
; 677  : 			 /* If we are not supposed to protect a hidden volume, the only error that is
; 678  : 				tolerated is ERR_PASSWORD_WRONG (to allow mounting a possible hidden volume). 
; 679  : 
; 680  : 				If we _are_ supposed to protect a hidden volume, we do not tolerate any error
; 681  : 				(both volume headers must be successfully decrypted). */
; 682  : 
; 683  : 			break;

  01ab1	eb 05		 jmp	 SHORT $LN72@TCOpenVolu
$LN12@TCOpenVolu:
$LN13@TCOpenVolu:

; 684  : 		}
; 685  : 	}

  01ab3	e9 db ef ff ff	 jmp	 $LN73@TCOpenVolu
$LN72@TCOpenVolu:

; 686  : 
; 687  : 	/* Failed due to some non-OS reason so we drop through and return NT
; 688  : 	   SUCCESS then nReturnCode is checked later in user-mode */
; 689  : 
; 690  : 	if (mount->nReturnCode == ERR_OUTOFMEMORY)

  01ab8	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  01ac0	83 38 02	 cmp	 DWORD PTR [rax], 2
  01ac3	75 0d		 jne	 SHORT $LN9@TCOpenVolu

; 691  : 		ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  01ac5	c7 84 24 24 01
	00 00 9a 00 00
	c0		 mov	 DWORD PTR ntStatus$[rsp], -1073741670 ; ffffffffc000009aH

; 692  : 	else

  01ad0	eb 0b		 jmp	 SHORT $LN8@TCOpenVolu
$LN9@TCOpenVolu:

; 693  : 		ntStatus = STATUS_SUCCESS;

  01ad2	c7 84 24 24 01
	00 00 00 00 00
	00		 mov	 DWORD PTR ntStatus$[rsp], 0
$LN8@TCOpenVolu:
$error$30873:

; 694  : 
; 695  : error:
; 696  : 	if (mount->nReturnCode == ERR_SUCCESS)

  01add	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  01ae5	83 38 00	 cmp	 DWORD PTR [rax], 0
  01ae8	75 0e		 jne	 SHORT $LN7@TCOpenVolu

; 697  : 		mount->nReturnCode = ERR_PASSWORD_WRONG;

  01aea	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  01af2	c7 00 03 00 00
	00		 mov	 DWORD PTR [rax], 3
$LN7@TCOpenVolu:

; 698  : 
; 699  : 	if (tmpCryptoInfo != NULL)

  01af8	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR tmpCryptoInfo$[rsp], 0
  01b01	74 19		 je	 SHORT $LN6@TCOpenVolu

; 700  : 	{
; 701  : 		crypto_close (tmpCryptoInfo);

  01b03	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tmpCryptoInfo$[rsp]
  01b0b	e8 00 00 00 00	 call	 crypto_close

; 702  : 		tmpCryptoInfo = NULL;

  01b10	48 c7 84 24 30
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tmpCryptoInfo$[rsp], 0
$LN6@TCOpenVolu:

; 703  : 	}
; 704  : 
; 705  : 	if (Extension->cryptoInfo)

  01b1c	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  01b24	48 83 b8 90 00
	00 00 00	 cmp	 QWORD PTR [rax+144], 0
  01b2c	74 27		 je	 SHORT $LN5@TCOpenVolu

; 706  : 	{
; 707  : 		crypto_close (Extension->cryptoInfo);

  01b2e	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  01b36	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  01b3d	e8 00 00 00 00	 call	 crypto_close

; 708  : 		Extension->cryptoInfo = NULL;

  01b42	48 8b 94 24 58
	03 00 00	 mov	 rdx, QWORD PTR Extension$[rsp]
  01b4a	48 c7 82 90 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rdx+144], 0
$LN5@TCOpenVolu:

; 709  : 	}
; 710  : 
; 711  : 	if (Extension->bTimeStampValid)

  01b55	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  01b5d	83 b8 d8 05 00
	00 00		 cmp	 DWORD PTR [rax+1496], 0
  01b64	74 0d		 je	 SHORT $LN4@TCOpenVolu

; 712  : 	{
; 713  : 		RestoreTimeStamp (Extension);

  01b66	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  01b6e	e8 00 00 00 00	 call	 RestoreTimeStamp
$LN4@TCOpenVolu:

; 714  : 	}
; 715  : 
; 716  : 	/* Close the hDeviceFile */
; 717  : 	if (Extension->hDeviceFile != NULL)

  01b73	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  01b7b	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  01b80	74 12		 je	 SHORT $LN3@TCOpenVolu

; 718  : 		ZwClose (Extension->hDeviceFile);

  01b82	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  01b8a	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  01b8e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
$LN3@TCOpenVolu:

; 719  : 
; 720  : 	/* The cryptoInfo pointer is deallocated if the readheader routines
; 721  : 	   fail so there is no need to deallocate here  */
; 722  : 
; 723  : 	/* Dereference the user-mode file object */
; 724  : 	if (Extension->pfoDeviceFile != NULL)

  01b94	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  01b9c	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  01ba4	74 15		 je	 SHORT $LN2@TCOpenVolu

; 725  : 		ObDereferenceObject (Extension->pfoDeviceFile);

  01ba6	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  01bae	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  01bb5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject
$LN2@TCOpenVolu:

; 726  : 
; 727  : 	/* Free the tmp IO buffers */
; 728  : 	if (readBuffer != NULL)

  01bbb	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR readBuffer$[rsp], 0
  01bc4	74 13		 je	 SHORT $LN1@TCOpenVolu

; 729  : 		TCfree (readBuffer);

  01bc6	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  01bcb	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR readBuffer$[rsp]
  01bd3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN1@TCOpenVolu:

; 730  : 
; 731  : 	return ntStatus;

  01bd9	8b 84 24 24 01
	00 00		 mov	 eax, DWORD PTR ntStatus$[rsp]
$LN108@TCOpenVolu:

; 732  : }

  01be0	48 8b 8c 24 38
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01be8	48 33 cc	 xor	 rcx, rsp
  01beb	e8 00 00 00 00	 call	 __security_check_cookie
  01bf0	48 81 c4 40 03
	00 00		 add	 rsp, 832		; 00000340H
  01bf7	5f		 pop	 rdi
  01bf8	c3		 ret	 0
TCOpenVolume ENDP
END
