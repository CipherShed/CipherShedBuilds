; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\users\public\desktop\projects\ciphershed\src\common\encryptionthreadpool.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
_ThreadPoolRunning DD 01H DUP (?)
_StopPending DD	01H DUP (?)
_BSS	ENDS
PUBLIC	_EncryptionThreadPoolStop@0
PUBLIC	_ExInitializeFastMutex@4
PUBLIC	_EncryptionThreadPoolStart@4
EXTRN	_TCStartThread@12:PROC
EXTRN	__imp__KeInitializeEvent@12:PROC
EXTRN	_GetCpuCount@0:PROC
EXTRN	_memset:PROC
_BSS	SEGMENT
_ThreadHandles DD 040H DUP (?)
_ThreadCount DD	01H DUP (?)
_WorkItemQueue DB 02400H DUP (?)
_EnqueueMutex DB 020H DUP (?)
_DequeueMutex DB 020H DUP (?)
_WorkItemCompletedEvent DB 010H DUP (?)
_WorkItemReadyEvent DB 010H DUP (?)
_EnqueuePosition DD 01H DUP (?)
_DequeuePosition DD 01H DUP (?)
; Function compile flags: /Odtp
; File c:\users\public\desktop\projects\ciphershed\src\common\encryptionthreadpool.c
_BSS	ENDS
;	COMDAT _EncryptionThreadPoolStart@4
_TEXT	SEGMENT
_cpuCount$ = -8						; size = 4
_i$ = -4						; size = 4
_encryptionFreeCpuCount$ = 8				; size = 4
_EncryptionThreadPoolStart@4 PROC			; COMDAT

; 219  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 220  : 	size_t cpuCount, i;
; 221  : 
; 222  : 	if (ThreadPoolRunning)

  00008	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ThreadPoolRunning, 0
  0000f	74 0a		 je	 SHORT $LN11@Encryption

; 223  : 		return TRUE;

  00011	b8 01 00 00 00	 mov	 eax, 1
  00016	e9 3b 01 00 00	 jmp	 $LN12@Encryption
$LN11@Encryption:

; 224  : 
; 225  : #ifdef DEVICE_DRIVER
; 226  : 	cpuCount = GetCpuCount();

  0001b	e8 00 00 00 00	 call	 _GetCpuCount@0
  00020	89 45 f8	 mov	 DWORD PTR _cpuCount$[ebp], eax

; 227  : #else
; 228  : 	{
; 229  : 		SYSTEM_INFO sysInfo;
; 230  : 		GetSystemInfo (&sysInfo);
; 231  : 		cpuCount = sysInfo.dwNumberOfProcessors;
; 232  : 	}
; 233  : #endif
; 234  : 
; 235  : 	if (cpuCount > encryptionFreeCpuCount)

  00023	8b 45 f8	 mov	 eax, DWORD PTR _cpuCount$[ebp]
  00026	3b 45 08	 cmp	 eax, DWORD PTR _encryptionFreeCpuCount$[ebp]
  00029	76 09		 jbe	 SHORT $LN10@Encryption

; 236  : 		cpuCount -= encryptionFreeCpuCount;

  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _cpuCount$[ebp]
  0002e	2b 4d 08	 sub	 ecx, DWORD PTR _encryptionFreeCpuCount$[ebp]
  00031	89 4d f8	 mov	 DWORD PTR _cpuCount$[ebp], ecx
$LN10@Encryption:

; 237  : 
; 238  : 	if (cpuCount < 2)

  00034	83 7d f8 02	 cmp	 DWORD PTR _cpuCount$[ebp], 2
  00038	73 0a		 jae	 SHORT $LN9@Encryption

; 239  : 		return TRUE;

  0003a	b8 01 00 00 00	 mov	 eax, 1
  0003f	e9 12 01 00 00	 jmp	 $LN12@Encryption
$LN9@Encryption:

; 240  : 
; 241  : 	if (cpuCount > TC_ENC_THREAD_POOL_MAX_THREAD_COUNT)

  00044	83 7d f8 40	 cmp	 DWORD PTR _cpuCount$[ebp], 64 ; 00000040H
  00048	76 07		 jbe	 SHORT $LN8@Encryption

; 242  : 		cpuCount = TC_ENC_THREAD_POOL_MAX_THREAD_COUNT;

  0004a	c7 45 f8 40 00
	00 00		 mov	 DWORD PTR _cpuCount$[ebp], 64 ; 00000040H
$LN8@Encryption:

; 243  : 
; 244  : 	StopPending = FALSE;

  00051	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _StopPending, 0

; 245  : 	DequeuePosition = 0;

  0005b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _DequeuePosition, 0

; 246  : 	EnqueuePosition = 0;

  00065	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _EnqueuePosition, 0

; 247  : 
; 248  : #ifdef DEVICE_DRIVER
; 249  : 	KeInitializeEvent (&WorkItemReadyEvent, SynchronizationEvent, FALSE);

  0006f	6a 00		 push	 0
  00071	6a 01		 push	 1
  00073	68 00 00 00 00	 push	 OFFSET _WorkItemReadyEvent
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 250  : 	KeInitializeEvent (&WorkItemCompletedEvent, SynchronizationEvent, FALSE);

  0007e	6a 00		 push	 0
  00080	6a 01		 push	 1
  00082	68 00 00 00 00	 push	 OFFSET _WorkItemCompletedEvent
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 251  : #else
; 252  : 	WorkItemReadyEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
; 253  : 	if (!WorkItemReadyEvent)
; 254  : 		return FALSE;
; 255  : 	
; 256  : 	WorkItemCompletedEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
; 257  : 	if (!WorkItemCompletedEvent)
; 258  : 		return FALSE;
; 259  : #endif
; 260  : 	
; 261  : #ifdef DEVICE_DRIVER
; 262  : 	ExInitializeFastMutex (&DequeueMutex);

  0008d	68 00 00 00 00	 push	 OFFSET _DequeueMutex
  00092	e8 00 00 00 00	 call	 _ExInitializeFastMutex@4

; 263  : 	ExInitializeFastMutex (&EnqueueMutex);

  00097	68 00 00 00 00	 push	 OFFSET _EnqueueMutex
  0009c	e8 00 00 00 00	 call	 _ExInitializeFastMutex@4

; 264  : #else
; 265  : 	DequeueMutex = CreateMutex (NULL, FALSE, NULL);
; 266  : 	if (!DequeueMutex)
; 267  : 		return FALSE;
; 268  : 
; 269  : 	EnqueueMutex = CreateMutex (NULL, FALSE, NULL);
; 270  : 	if (!EnqueueMutex)
; 271  : 		return FALSE;
; 272  : #endif
; 273  : 
; 274  : 	memset (WorkItemQueue, 0, sizeof (WorkItemQueue));

  000a1	68 00 24 00 00	 push	 9216			; 00002400H
  000a6	6a 00		 push	 0
  000a8	68 00 00 00 00	 push	 OFFSET _WorkItemQueue
  000ad	e8 00 00 00 00	 call	 _memset
  000b2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 275  : 
; 276  : 	for (i = 0; i < sizeof (WorkItemQueue) / sizeof (WorkItemQueue[0]); ++i)

  000b5	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000bc	eb 09		 jmp	 SHORT $LN7@Encryption
$LN6@Encryption:
  000be	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000c1	83 c2 01	 add	 edx, 1
  000c4	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN7@Encryption:
  000c7	81 7d fc 80 00
	00 00		 cmp	 DWORD PTR _i$[ebp], 128	; 00000080H
  000ce	73 29		 jae	 SHORT $LN5@Encryption

; 277  : 	{
; 278  : 		WorkItemQueue[i].State = WorkItemFree;

  000d0	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000d3	6b c0 48	 imul	 eax, 72			; 00000048H
  000d6	c7 80 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _WorkItemQueue[eax], 0

; 279  : 
; 280  : #ifdef DEVICE_DRIVER
; 281  : 		KeInitializeEvent (&WorkItemQueue[i].ItemCompletedEvent, SynchronizationEvent, FALSE);

  000e0	6a 00		 push	 0
  000e2	6a 01		 push	 1
  000e4	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000e7	6b c9 48	 imul	 ecx, 72			; 00000048H
  000ea	81 c1 08 00 00
	00		 add	 ecx, OFFSET _WorkItemQueue+8
  000f0	51		 push	 ecx
  000f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 282  : #else
; 283  : 		WorkItemQueue[i].ItemCompletedEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
; 284  : 		if (!WorkItemQueue[i].ItemCompletedEvent)
; 285  : 		{
; 286  : 			EncryptionThreadPoolStop();
; 287  : 			return FALSE;
; 288  : 		}
; 289  : #endif
; 290  : 	}

  000f7	eb c5		 jmp	 SHORT $LN6@Encryption
$LN5@Encryption:

; 291  : 
; 292  : 	for (ThreadCount = 0; ThreadCount < cpuCount; ++ThreadCount)

  000f9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ThreadCount, 0
  00103	eb 0f		 jmp	 SHORT $LN4@Encryption
$LN3@Encryption:
  00105	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ThreadCount
  0010b	83 c2 01	 add	 edx, 1
  0010e	89 15 00 00 00
	00		 mov	 DWORD PTR _ThreadCount, edx
$LN4@Encryption:
  00114	a1 00 00 00 00	 mov	 eax, DWORD PTR _ThreadCount
  00119	3b 45 f8	 cmp	 eax, DWORD PTR _cpuCount$[ebp]
  0011c	73 29		 jae	 SHORT $LN2@Encryption

; 293  : 	{
; 294  : #ifdef DEVICE_DRIVER
; 295  : 		if (!NT_SUCCESS (TCStartThread (EncryptionThreadProc, NULL, &ThreadHandles[ThreadCount])))

  0011e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ThreadCount
  00124	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR _ThreadHandles[ecx*4]
  0012b	52		 push	 edx
  0012c	6a 00		 push	 0
  0012e	68 00 00 00 00	 push	 OFFSET _EncryptionThreadProc@4
  00133	e8 00 00 00 00	 call	 _TCStartThread@12
  00138	85 c0		 test	 eax, eax
  0013a	7d 09		 jge	 SHORT $LN1@Encryption

; 296  : #else
; 297  : 		if (!(ThreadHandles[ThreadCount] = (HANDLE) _beginthreadex (NULL, 0, EncryptionThreadProc, NULL, 0, NULL)))
; 298  : #endif
; 299  : 		{
; 300  : 			EncryptionThreadPoolStop();

  0013c	e8 00 00 00 00	 call	 _EncryptionThreadPoolStop@0

; 301  : 			return FALSE;

  00141	33 c0		 xor	 eax, eax
  00143	eb 11		 jmp	 SHORT $LN12@Encryption
$LN1@Encryption:

; 302  : 		}
; 303  : 	}

  00145	eb be		 jmp	 SHORT $LN3@Encryption
$LN2@Encryption:

; 304  : 
; 305  : 	ThreadPoolRunning = TRUE;

  00147	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _ThreadPoolRunning, 1

; 306  : 	return TRUE;

  00151	b8 01 00 00 00	 mov	 eax, 1
$LN12@Encryption:

; 307  : }

  00156	8b e5		 mov	 esp, ebp
  00158	5d		 pop	 ebp
  00159	c2 04 00	 ret	 4
_EncryptionThreadPoolStart@4 ENDP
; Function compile flags: /Odtp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT _ExInitializeFastMutex@4
_TEXT	SEGMENT
_FastMutex$ = 8						; size = 4
_ExInitializeFastMutex@4 PROC				; COMDAT

; 16362: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 16363: 
; 16364:     FastMutex->Count = FM_LOCK_BIT;

  00005	8b 45 08	 mov	 eax, DWORD PTR _FastMutex$[ebp]
  00008	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 16365:     FastMutex->Owner = NULL;

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _FastMutex$[ebp]
  00011	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 16366:     FastMutex->Contention = 0;

  00018	8b 55 08	 mov	 edx, DWORD PTR _FastMutex$[ebp]
  0001b	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 16367:     KeInitializeEvent(&FastMutex->Event, SynchronizationEvent, FALSE);

  00022	6a 00		 push	 0
  00024	6a 01		 push	 1
  00026	8b 45 08	 mov	 eax, DWORD PTR _FastMutex$[ebp]
  00029	83 c0 0c	 add	 eax, 12			; 0000000cH
  0002c	50		 push	 eax
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 16368:     return;
; 16369: }

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
_ExInitializeFastMutex@4 ENDP
_TEXT	ENDS
EXTRN	__imp__PsTerminateSystemThread@4:PROC
EXTRN	__imp__KeSetEvent@12:PROC
EXTRN	__imp__KeBugCheckEx@20:PROC
EXTRN	_derive_key_sha1@28:PROC
EXTRN	_derive_key_whirlpool@28:PROC
EXTRN	_derive_key_sha512@28:PROC
EXTRN	_derive_key_ripemd160@28:PROC
EXTRN	_GetMaxPkcs5OutSize@0:PROC
EXTRN	_EncryptDataUnitsCurrentThread@20:PROC
EXTRN	_DecryptDataUnitsCurrentThread@20:PROC
EXTRN	__imp_@ExReleaseFastMutex@4:PROC
EXTRN	__imp__KeWaitForSingleObject@20:PROC
EXTRN	__imp_@ExAcquireFastMutex@4:PROC
; Function compile flags: /Odtp
; File c:\users\public\desktop\projects\ciphershed\src\common\encryptionthreadpool.c
;	COMDAT _EncryptionThreadProc@4
_TEXT	SEGMENT
tv142 = -12						; size = 4
tv90 = -8						; size = 4
_workItem$ = -4						; size = 4
_threadArg$ = 8						; size = 4
_EncryptionThreadProc@4 PROC				; COMDAT

; 124  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH
$LN22@Encryption@2:

; 125  : 	EncryptionThreadPoolWorkItem *workItem;
; 126  : 
; 127  : 	while (!StopPending)

  00008	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _StopPending, 0
  0000f	0f 85 ce 02 00
	00		 jne	 $LN21@Encryption@2

; 128  : 	{
; 129  : 		TC_ACQUIRE_MUTEX (&DequeueMutex);

  00015	b9 00 00 00 00	 mov	 ecx, OFFSET _DequeueMutex
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExAcquireFastMutex@4

; 130  : 
; 131  : 		workItem = &WorkItemQueue[DequeuePosition++];

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR _DequeuePosition
  00025	6b c0 48	 imul	 eax, 72			; 00000048H
  00028	05 00 00 00 00	 add	 eax, OFFSET _WorkItemQueue
  0002d	89 45 fc	 mov	 DWORD PTR _workItem$[ebp], eax
  00030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _DequeuePosition
  00036	83 c1 01	 add	 ecx, 1
  00039	89 0d 00 00 00
	00		 mov	 DWORD PTR _DequeuePosition, ecx

; 132  : 
; 133  : 		if (DequeuePosition >= TC_ENC_THREAD_POOL_QUEUE_SIZE)

  0003f	81 3d 00 00 00
	00 80 00 00 00	 cmp	 DWORD PTR _DequeuePosition, 128 ; 00000080H
  00049	7c 0a		 jl	 SHORT $LN19@Encryption@2

; 134  : 			DequeuePosition = 0;

  0004b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _DequeuePosition, 0
$LN19@Encryption@2:

; 135  : 
; 136  : 		while (!StopPending && GetWorkItemState (workItem) != WorkItemReady)

  00055	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _StopPending, 0
  0005c	75 23		 jne	 SHORT $LN18@Encryption@2
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 _GetWorkItemState@4
  00067	83 f8 01	 cmp	 eax, 1
  0006a	74 15		 je	 SHORT $LN18@Encryption@2

; 137  : 		{
; 138  : 			TC_WAIT_EVENT (WorkItemReadyEvent);

  0006c	6a 00		 push	 0
  0006e	6a 00		 push	 0
  00070	6a 00		 push	 0
  00072	6a 00		 push	 0
  00074	68 00 00 00 00	 push	 OFFSET _WorkItemReadyEvent
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 139  : 		}

  0007f	eb d4		 jmp	 SHORT $LN19@Encryption@2
$LN18@Encryption@2:

; 140  : 
; 141  : 		SetWorkItemState (workItem, WorkItemBusy);

  00081	6a 02		 push	 2
  00083	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 _SetWorkItemState@8

; 142  : 
; 143  : 		TC_RELEASE_MUTEX (&DequeueMutex);

  0008c	b9 00 00 00 00	 mov	 ecx, OFFSET _DequeueMutex
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExReleaseFastMutex@4

; 144  : 
; 145  : 		if (StopPending)

  00097	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _StopPending, 0
  0009e	74 05		 je	 SHORT $LN17@Encryption@2

; 146  : 			break;

  000a0	e9 3e 02 00 00	 jmp	 $LN21@Encryption@2
$LN17@Encryption@2:

; 147  : 
; 148  : 		switch (workItem->Type)

  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  000a8	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ab	89 55 f8	 mov	 DWORD PTR tv90[ebp], edx
  000ae	83 7d f8 00	 cmp	 DWORD PTR tv90[ebp], 0
  000b2	74 3a		 je	 SHORT $LN13@Encryption@2
  000b4	83 7d f8 01	 cmp	 DWORD PTR tv90[ebp], 1
  000b8	74 0b		 je	 SHORT $LN14@Encryption@2
  000ba	83 7d f8 02	 cmp	 DWORD PTR tv90[ebp], 2
  000be	74 57		 je	 SHORT $LN12@Encryption@2
  000c0	e9 b7 01 00 00	 jmp	 $LN3@Encryption@2
$LN14@Encryption@2:

; 149  : 		{
; 150  : 		case DecryptDataUnitsWork:
; 151  : 			DecryptDataUnitsCurrentThread (workItem->Encryption.Data, &workItem->Encryption.StartUnitNo, workItem->Encryption.UnitCount, workItem->Encryption.CryptoInfo);

  000c5	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  000c8	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000cb	51		 push	 ecx
  000cc	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  000cf	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  000d2	33 c9		 xor	 ecx, ecx
  000d4	51		 push	 ecx
  000d5	50		 push	 eax
  000d6	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  000d9	83 c2 28	 add	 edx, 40			; 00000028H
  000dc	52		 push	 edx
  000dd	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  000e0	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000e3	51		 push	 ecx
  000e4	e8 00 00 00 00	 call	 _DecryptDataUnitsCurrentThread@20

; 152  : 			break;

  000e9	e9 a4 01 00 00	 jmp	 $LN15@Encryption@2
$LN13@Encryption@2:

; 153  : 
; 154  : 		case EncryptDataUnitsWork:
; 155  : 			EncryptDataUnitsCurrentThread (workItem->Encryption.Data, &workItem->Encryption.StartUnitNo, workItem->Encryption.UnitCount, workItem->Encryption.CryptoInfo);

  000ee	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  000f1	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  000f4	50		 push	 eax
  000f5	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  000f8	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000fb	33 c0		 xor	 eax, eax
  000fd	50		 push	 eax
  000fe	52		 push	 edx
  000ff	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  00102	83 c1 28	 add	 ecx, 40			; 00000028H
  00105	51		 push	 ecx
  00106	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  00109	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 _EncryptDataUnitsCurrentThread@20

; 156  : 			break;

  00112	e9 7b 01 00 00	 jmp	 $LN15@Encryption@2
$LN12@Encryption@2:

; 157  : 
; 158  : 		case DeriveKeyWork:
; 159  : 			switch (workItem->KeyDerivation.Pkcs5Prf)

  00117	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  0011a	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  0011d	89 55 f4	 mov	 DWORD PTR tv142[ebp], edx
  00120	8b 45 f4	 mov	 eax, DWORD PTR tv142[ebp]
  00123	83 e8 01	 sub	 eax, 1
  00126	89 45 f4	 mov	 DWORD PTR tv142[ebp], eax
  00129	83 7d f4 03	 cmp	 DWORD PTR tv142[ebp], 3
  0012d	0f 87 d5 00 00
	00		 ja	 $LN5@Encryption@2
  00133	8b 4d f4	 mov	 ecx, DWORD PTR tv142[ebp]
  00136	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN26@Encryption@2[ecx*4]
$LN9@Encryption@2:

; 160  : 			{
; 161  : 			case RIPEMD160:
; 162  : 				derive_key_ripemd160 (workItem->KeyDerivation.Password, workItem->KeyDerivation.PasswordLength, workItem->KeyDerivation.Salt, PKCS5_SALT_SIZE,
; 163  : 					workItem->KeyDerivation.IterationCount, workItem->KeyDerivation.DerivedKey, GetMaxPkcs5OutSize());

  0013d	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize@0
  00142	50		 push	 eax
  00143	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  00146	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00149	50		 push	 eax
  0014a	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  0014d	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00150	52		 push	 edx
  00151	6a 40		 push	 64			; 00000040H
  00153	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  00156	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00159	51		 push	 ecx
  0015a	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  0015d	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00160	50		 push	 eax
  00161	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  00164	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00167	52		 push	 edx
  00168	e8 00 00 00 00	 call	 _derive_key_ripemd160@28

; 164  : 				break;

  0016d	e9 ac 00 00 00	 jmp	 $LN10@Encryption@2
$LN8@Encryption@2:

; 165  : 
; 166  : 			case SHA512:
; 167  : 				derive_key_sha512 (workItem->KeyDerivation.Password, workItem->KeyDerivation.PasswordLength, workItem->KeyDerivation.Salt, PKCS5_SALT_SIZE,
; 168  : 					workItem->KeyDerivation.IterationCount, workItem->KeyDerivation.DerivedKey, GetMaxPkcs5OutSize());

  00172	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize@0
  00177	50		 push	 eax
  00178	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  0017b	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0017e	51		 push	 ecx
  0017f	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  00182	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00185	50		 push	 eax
  00186	6a 40		 push	 64			; 00000040H
  00188	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  0018b	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  0018e	52		 push	 edx
  0018f	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  00192	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00195	51		 push	 ecx
  00196	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  00199	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0019c	50		 push	 eax
  0019d	e8 00 00 00 00	 call	 _derive_key_sha512@28

; 169  : 				break;

  001a2	eb 7a		 jmp	 SHORT $LN10@Encryption@2
$LN7@Encryption@2:

; 170  : 
; 171  : 			case WHIRLPOOL:
; 172  : 				derive_key_whirlpool (workItem->KeyDerivation.Password, workItem->KeyDerivation.PasswordLength, workItem->KeyDerivation.Salt, PKCS5_SALT_SIZE,
; 173  : 					workItem->KeyDerivation.IterationCount, workItem->KeyDerivation.DerivedKey, GetMaxPkcs5OutSize());

  001a4	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize@0
  001a9	50		 push	 eax
  001aa	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  001ad	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  001b0	52		 push	 edx
  001b1	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  001b4	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  001b7	51		 push	 ecx
  001b8	6a 40		 push	 64			; 00000040H
  001ba	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  001bd	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  001c0	50		 push	 eax
  001c1	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  001c4	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  001c7	52		 push	 edx
  001c8	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  001cb	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  001ce	51		 push	 ecx
  001cf	e8 00 00 00 00	 call	 _derive_key_whirlpool@28

; 174  : 				break;

  001d4	eb 48		 jmp	 SHORT $LN10@Encryption@2
$LN6@Encryption@2:

; 175  : 
; 176  : 			case SHA1:
; 177  : 				derive_key_sha1 (workItem->KeyDerivation.Password, workItem->KeyDerivation.PasswordLength, workItem->KeyDerivation.Salt, PKCS5_SALT_SIZE,
; 178  : 					workItem->KeyDerivation.IterationCount, workItem->KeyDerivation.DerivedKey, GetMaxPkcs5OutSize());

  001d6	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize@0
  001db	50		 push	 eax
  001dc	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  001df	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  001e2	50		 push	 eax
  001e3	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  001e6	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  001e9	52		 push	 edx
  001ea	6a 40		 push	 64			; 00000040H
  001ec	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  001ef	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  001f2	51		 push	 ecx
  001f3	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  001f6	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  001f9	50		 push	 eax
  001fa	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  001fd	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00200	52		 push	 edx
  00201	e8 00 00 00 00	 call	 _derive_key_sha1@28

; 179  : 				break;

  00206	eb 16		 jmp	 SHORT $LN10@Encryption@2
$LN5@Encryption@2:

; 180  : 
; 181  : 			default:		
; 182  : 				TC_THROW_FATAL_EXCEPTION;

  00208	68 43 54 00 00	 push	 21571			; 00005443H
  0020d	6a 00		 push	 0
  0020f	6a 00		 push	 0
  00211	68 b6 00 00 00	 push	 182			; 000000b6H
  00216	6a 29		 push	 41			; 00000029H
  00218	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN10@Encryption@2:

; 183  : 			} 
; 184  : 
; 185  : 			InterlockedExchange (workItem->KeyDerivation.CompletionFlag, TRUE);

  0021e	b8 01 00 00 00	 mov	 eax, 1
  00223	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  00226	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00229	87 02		 xchg	 DWORD PTR [edx], eax

; 186  : 			TC_SET_EVENT (*workItem->KeyDerivation.CompletionEvent);

  0022b	6a 00		 push	 0
  0022d	6a 01		 push	 1
  0022f	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  00232	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00235	51		 push	 ecx
  00236	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 187  : 			
; 188  : 			if (InterlockedDecrement (workItem->KeyDerivation.OutstandingWorkItemCount) == 0)

  0023c	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  0023f	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00242	83 c9 ff	 or	 ecx, -1
  00245	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00249	49		 dec	 ecx
  0024a	75 11		 jne	 SHORT $LN4@Encryption@2

; 189  : 				TC_SET_EVENT (*workItem->KeyDerivation.NoOutstandingWorkItemEvent);

  0024c	6a 00		 push	 0
  0024e	6a 01		 push	 1
  00250	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  00253	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00256	50		 push	 eax
  00257	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
$LN4@Encryption@2:

; 190  : 
; 191  : 			SetWorkItemState (workItem, WorkItemFree);

  0025d	6a 00		 push	 0
  0025f	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  00262	51		 push	 ecx
  00263	e8 00 00 00 00	 call	 _SetWorkItemState@8

; 192  : 			TC_SET_EVENT (WorkItemCompletedEvent);

  00268	6a 00		 push	 0
  0026a	6a 01		 push	 1
  0026c	68 00 00 00 00	 push	 OFFSET _WorkItemCompletedEvent
  00271	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 193  : 			continue;

  00277	e9 8c fd ff ff	 jmp	 $LN22@Encryption@2
$LN3@Encryption@2:

; 194  : 
; 195  : 		default:
; 196  : 			TC_THROW_FATAL_EXCEPTION;

  0027c	68 43 54 00 00	 push	 21571			; 00005443H
  00281	6a 00		 push	 0
  00283	6a 00		 push	 0
  00285	68 c4 00 00 00	 push	 196			; 000000c4H
  0028a	6a 29		 push	 41			; 00000029H
  0028c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN15@Encryption@2:

; 197  : 		}
; 198  : 
; 199  : 		if (workItem != workItem->FirstFragment)

  00292	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  00295	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  00298	3b 42 18	 cmp	 eax, DWORD PTR [edx+24]
  0029b	74 1a		 je	 SHORT $LN2@Encryption@2

; 200  : 		{
; 201  : 			SetWorkItemState (workItem, WorkItemFree);

  0029d	6a 00		 push	 0
  0029f	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  002a2	51		 push	 ecx
  002a3	e8 00 00 00 00	 call	 _SetWorkItemState@8

; 202  : 			TC_SET_EVENT (WorkItemCompletedEvent);

  002a8	6a 00		 push	 0
  002aa	6a 01		 push	 1
  002ac	68 00 00 00 00	 push	 OFFSET _WorkItemCompletedEvent
  002b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
$LN2@Encryption@2:

; 203  : 		}
; 204  : 
; 205  : 		if (InterlockedDecrement (&workItem->FirstFragment->OutstandingFragmentCount) == 0)

  002b7	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  002ba	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  002bd	83 c0 1c	 add	 eax, 28			; 0000001cH
  002c0	83 c9 ff	 or	 ecx, -1
  002c3	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  002c7	49		 dec	 ecx
  002c8	75 14		 jne	 SHORT $LN1@Encryption@2

; 206  : 			TC_SET_EVENT (workItem->FirstFragment->ItemCompletedEvent);

  002ca	6a 00		 push	 0
  002cc	6a 01		 push	 1
  002ce	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  002d1	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  002d4	83 c0 08	 add	 eax, 8
  002d7	50		 push	 eax
  002d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
$LN1@Encryption@2:

; 207  : 	}

  002de	e9 25 fd ff ff	 jmp	 $LN22@Encryption@2
$LN21@Encryption@2:

; 208  : 
; 209  : #ifdef DEVICE_DRIVER
; 210  : 	PsTerminateSystemThread (STATUS_SUCCESS);

  002e3	6a 00		 push	 0
  002e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsTerminateSystemThread@4
$LN24@Encryption@2:

; 211  : #else
; 212  : 	_endthreadex (0);
; 213  :     return 0;
; 214  : #endif
; 215  : }

  002eb	8b e5		 mov	 esp, ebp
  002ed	5d		 pop	 ebp
  002ee	c2 04 00	 ret	 4
  002f1	8d 49 00	 npad	 3
$LN26@Encryption@2:
  002f4	00 00 00 00	 DD	 $LN9@Encryption@2
  002f8	00 00 00 00	 DD	 $LN8@Encryption@2
  002fc	00 00 00 00	 DD	 $LN7@Encryption@2
  00300	00 00 00 00	 DD	 $LN6@Encryption@2
_EncryptionThreadProc@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _GetWorkItemState@4
_TEXT	SEGMENT
_workItem$ = 8						; size = 4
_GetWorkItemState@4 PROC				; COMDAT

; 112  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 113  : 	return InterlockedExchangeAdd ((LONG *) &workItem->State, 0);

  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _workItem$[ebp]
  0000a	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax

; 114  : }

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
_GetWorkItemState@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _SetWorkItemState@8
_TEXT	SEGMENT
_workItem$ = 8						; size = 4
_newState$ = 12						; size = 4
_SetWorkItemState@8 PROC				; COMDAT

; 118  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 119  : 	InterlockedExchange ((LONG *) &workItem->State, (LONG) newState);

  00005	8b 45 0c	 mov	 eax, DWORD PTR _newState$[ebp]
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _workItem$[ebp]
  0000b	87 01		 xchg	 DWORD PTR [ecx], eax

; 120  : }

  0000d	5d		 pop	 ebp
  0000e	c2 08 00	 ret	 8
_SetWorkItemState@8 ENDP
_TEXT	ENDS
EXTRN	_TCStopThread@8:PROC
; Function compile flags: /Odtp
;	COMDAT _EncryptionThreadPoolStop@0
_TEXT	SEGMENT
_i$ = -4						; size = 4
_EncryptionThreadPoolStop@0 PROC			; COMDAT

; 311  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 312  : 	size_t i;
; 313  : 
; 314  : 	if (!ThreadPoolRunning)

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ThreadPoolRunning, 0
  0000d	75 02		 jne	 SHORT $LN4@Encryption@3

; 315  : 		return;

  0000f	eb 61		 jmp	 SHORT $LN5@Encryption@3
$LN4@Encryption@3:

; 316  : 
; 317  : 	StopPending = TRUE;

  00011	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _StopPending, 1

; 318  : 	TC_SET_EVENT (WorkItemReadyEvent);

  0001b	6a 00		 push	 0
  0001d	6a 01		 push	 1
  0001f	68 00 00 00 00	 push	 OFFSET _WorkItemReadyEvent
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 319  : 
; 320  : 	for (i = 0; i < ThreadCount; ++i)

  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00031	eb 09		 jmp	 SHORT $LN3@Encryption@3
$LN2@Encryption@3:
  00033	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00036	83 c0 01	 add	 eax, 1
  00039	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN3@Encryption@3:
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0003f	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _ThreadCount
  00045	73 17		 jae	 SHORT $LN1@Encryption@3

; 321  : 	{
; 322  : #ifdef DEVICE_DRIVER
; 323  : 		TCStopThread (ThreadHandles[i], &WorkItemReadyEvent);

  00047	68 00 00 00 00	 push	 OFFSET _WorkItemReadyEvent
  0004c	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0004f	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _ThreadHandles[edx*4]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 _TCStopThread@8

; 324  : #else
; 325  : 		TC_WAIT_EVENT (ThreadHandles[i]);
; 326  : #endif
; 327  : 	}

  0005c	eb d5		 jmp	 SHORT $LN2@Encryption@3
$LN1@Encryption@3:

; 328  : 
; 329  : 	ThreadCount = 0;

  0005e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ThreadCount, 0

; 330  : 
; 331  : #ifndef DEVICE_DRIVER
; 332  : 	CloseHandle (DequeueMutex);
; 333  : 	CloseHandle (EnqueueMutex);
; 334  : 
; 335  : 	CloseHandle (WorkItemReadyEvent);
; 336  : 	CloseHandle (WorkItemCompletedEvent);
; 337  : 
; 338  : 	for (i = 0; i < sizeof (WorkItemQueue) / sizeof (WorkItemQueue[0]); ++i)
; 339  : 	{
; 340  : 		if (WorkItemQueue[i].ItemCompletedEvent)
; 341  : 			CloseHandle (WorkItemQueue[i].ItemCompletedEvent);
; 342  : 	}
; 343  : #endif
; 344  : 
; 345  : 	ThreadPoolRunning = FALSE;

  00068	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ThreadPoolRunning, 0
$LN5@Encryption@3:

; 346  : }

  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
_EncryptionThreadPoolStop@0 ENDP
_TEXT	ENDS
PUBLIC	_EncryptionThreadPoolBeginKeyDerivation@40
EXTRN	__imp__KeClearEvent@4:PROC
; Function compile flags: /Odtp
;	COMDAT _EncryptionThreadPoolBeginKeyDerivation@40
_TEXT	SEGMENT
_workItem$ = -4						; size = 4
_completionEvent$ = 8					; size = 4
_noOutstandingWorkItemEvent$ = 12			; size = 4
_completionFlag$ = 16					; size = 4
_outstandingWorkItemCount$ = 20				; size = 4
_pkcs5Prf$ = 24						; size = 4
_password$ = 28						; size = 4
_passwordLength$ = 32					; size = 4
_salt$ = 36						; size = 4
_iterationCount$ = 40					; size = 4
_derivedKey$ = 44					; size = 4
_EncryptionThreadPoolBeginKeyDerivation@40 PROC		; COMDAT

; 350  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 351  : 	EncryptionThreadPoolWorkItem *workItem;
; 352  : 
; 353  : 	if (!ThreadPoolRunning)

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ThreadPoolRunning, 0
  0000d	75 16		 jne	 SHORT $LN4@Encryption@4

; 354  : 		TC_THROW_FATAL_EXCEPTION;

  0000f	68 43 54 00 00	 push	 21571			; 00005443H
  00014	6a 00		 push	 0
  00016	6a 00		 push	 0
  00018	68 62 01 00 00	 push	 354			; 00000162H
  0001d	6a 29		 push	 41			; 00000029H
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN4@Encryption@4:

; 355  : 
; 356  : 	TC_ACQUIRE_MUTEX (&EnqueueMutex);

  00025	b9 00 00 00 00	 mov	 ecx, OFFSET _EnqueueMutex
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExAcquireFastMutex@4

; 357  : 
; 358  : 	workItem = &WorkItemQueue[EnqueuePosition++];

  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR _EnqueuePosition
  00035	6b c0 48	 imul	 eax, 72			; 00000048H
  00038	05 00 00 00 00	 add	 eax, OFFSET _WorkItemQueue
  0003d	89 45 fc	 mov	 DWORD PTR _workItem$[ebp], eax
  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _EnqueuePosition
  00046	83 c1 01	 add	 ecx, 1
  00049	89 0d 00 00 00
	00		 mov	 DWORD PTR _EnqueuePosition, ecx

; 359  : 	if (EnqueuePosition >= TC_ENC_THREAD_POOL_QUEUE_SIZE)

  0004f	81 3d 00 00 00
	00 80 00 00 00	 cmp	 DWORD PTR _EnqueuePosition, 128 ; 00000080H
  00059	7c 0a		 jl	 SHORT $LN2@Encryption@4

; 360  : 		EnqueuePosition = 0;

  0005b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _EnqueuePosition, 0
$LN2@Encryption@4:

; 361  : 
; 362  : 	while (GetWorkItemState (workItem) != WorkItemFree)

  00065	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  00068	52		 push	 edx
  00069	e8 00 00 00 00	 call	 _GetWorkItemState@4
  0006e	85 c0		 test	 eax, eax
  00070	74 15		 je	 SHORT $LN1@Encryption@4

; 363  : 	{
; 364  : 		TC_WAIT_EVENT (WorkItemCompletedEvent);

  00072	6a 00		 push	 0
  00074	6a 00		 push	 0
  00076	6a 00		 push	 0
  00078	6a 00		 push	 0
  0007a	68 00 00 00 00	 push	 OFFSET _WorkItemCompletedEvent
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 365  : 	}

  00085	eb de		 jmp	 SHORT $LN2@Encryption@4
$LN1@Encryption@4:

; 366  : 
; 367  : 	workItem->Type = DeriveKeyWork;

  00087	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  0008a	c7 40 04 02 00
	00 00		 mov	 DWORD PTR [eax+4], 2

; 368  : 	workItem->KeyDerivation.CompletionEvent = completionEvent;

  00091	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  00094	8b 55 08	 mov	 edx, DWORD PTR _completionEvent$[ebp]
  00097	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 369  : 	workItem->KeyDerivation.CompletionFlag = completionFlag;

  0009a	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  0009d	8b 4d 10	 mov	 ecx, DWORD PTR _completionFlag$[ebp]
  000a0	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 370  : 	workItem->KeyDerivation.DerivedKey = derivedKey;

  000a3	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  000a6	8b 45 2c	 mov	 eax, DWORD PTR _derivedKey$[ebp]
  000a9	89 42 28	 mov	 DWORD PTR [edx+40], eax

; 371  : 	workItem->KeyDerivation.IterationCount = iterationCount;

  000ac	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  000af	8b 55 28	 mov	 edx, DWORD PTR _iterationCount$[ebp]
  000b2	89 51 2c	 mov	 DWORD PTR [ecx+44], edx

; 372  : 	workItem->KeyDerivation.NoOutstandingWorkItemEvent = noOutstandingWorkItemEvent;

  000b5	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  000b8	8b 4d 0c	 mov	 ecx, DWORD PTR _noOutstandingWorkItemEvent$[ebp]
  000bb	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 373  : 	workItem->KeyDerivation.OutstandingWorkItemCount = outstandingWorkItemCount;

  000be	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  000c1	8b 45 14	 mov	 eax, DWORD PTR _outstandingWorkItemCount$[ebp]
  000c4	89 42 34	 mov	 DWORD PTR [edx+52], eax

; 374  : 	workItem->KeyDerivation.Password = password;

  000c7	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  000ca	8b 55 1c	 mov	 edx, DWORD PTR _password$[ebp]
  000cd	89 51 38	 mov	 DWORD PTR [ecx+56], edx

; 375  : 	workItem->KeyDerivation.PasswordLength = passwordLength;

  000d0	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  000d3	8b 4d 20	 mov	 ecx, DWORD PTR _passwordLength$[ebp]
  000d6	89 48 3c	 mov	 DWORD PTR [eax+60], ecx

; 376  : 	workItem->KeyDerivation.Pkcs5Prf = pkcs5Prf;

  000d9	8b 55 fc	 mov	 edx, DWORD PTR _workItem$[ebp]
  000dc	8b 45 18	 mov	 eax, DWORD PTR _pkcs5Prf$[ebp]
  000df	89 42 40	 mov	 DWORD PTR [edx+64], eax

; 377  : 	workItem->KeyDerivation.Salt = salt;

  000e2	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$[ebp]
  000e5	8b 55 24	 mov	 edx, DWORD PTR _salt$[ebp]
  000e8	89 51 44	 mov	 DWORD PTR [ecx+68], edx

; 378  : 
; 379  : 	InterlockedIncrement (outstandingWorkItemCount);

  000eb	8b 45 14	 mov	 eax, DWORD PTR _outstandingWorkItemCount$[ebp]
  000ee	b9 01 00 00 00	 mov	 ecx, 1
  000f3	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx

; 380  : 	TC_CLEAR_EVENT (*noOutstandingWorkItemEvent);

  000f7	8b 55 0c	 mov	 edx, DWORD PTR _noOutstandingWorkItemEvent$[ebp]
  000fa	52		 push	 edx
  000fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeClearEvent@4

; 381  : 
; 382  : 	SetWorkItemState (workItem, WorkItemReady);

  00101	6a 01		 push	 1
  00103	8b 45 fc	 mov	 eax, DWORD PTR _workItem$[ebp]
  00106	50		 push	 eax
  00107	e8 00 00 00 00	 call	 _SetWorkItemState@8

; 383  : 	TC_SET_EVENT (WorkItemReadyEvent);

  0010c	6a 00		 push	 0
  0010e	6a 01		 push	 1
  00110	68 00 00 00 00	 push	 OFFSET _WorkItemReadyEvent
  00115	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 384  : 	TC_RELEASE_MUTEX (&EnqueueMutex);

  0011b	b9 00 00 00 00	 mov	 ecx, OFFSET _EnqueueMutex
  00120	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExReleaseFastMutex@4
$LN6@Encryption@4:

; 385  : }

  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c2 28 00	 ret	 40			; 00000028H
_EncryptionThreadPoolBeginKeyDerivation@40 ENDP
_TEXT	ENDS
PUBLIC	_EncryptionThreadPoolDoWork@20
; Function compile flags: /Odtp
;	COMDAT _EncryptionThreadPoolDoWork@20
_TEXT	SEGMENT
tv68 = -40						; size = 4
_firstFragmentWorkItem$ = -36				; size = 4
_fragmentStartUnitNo$ = -32				; size = 8
_fragmentData$ = -20					; size = 4
_fragmentCount$ = -16					; size = 4
_unitsPerFragment$ = -12				; size = 4
_workItem$ = -8						; size = 4
_remainder$ = -4					; size = 4
_type$ = 8						; size = 4
_data$ = 12						; size = 4
_startUnitNo$ = 16					; size = 4
_unitCount$ = 20					; size = 4
_cryptoInfo$ = 24					; size = 4
_EncryptionThreadPoolDoWork@20 PROC			; COMDAT

; 389  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 28	 sub	 esp, 40			; 00000028H

; 390  : 	uint32 fragmentCount;
; 391  : 	uint32 unitsPerFragment;
; 392  : 	uint32 remainder;
; 393  : 
; 394  : 	byte *fragmentData;
; 395  : 	uint64 fragmentStartUnitNo;
; 396  : 
; 397  : 	EncryptionThreadPoolWorkItem *workItem;
; 398  : 	EncryptionThreadPoolWorkItem *firstFragmentWorkItem;
; 399  : 	
; 400  : 	if (unitCount == 0)

  00008	83 7d 14 00	 cmp	 DWORD PTR _unitCount$[ebp], 0
  0000c	75 05		 jne	 SHORT $LN19@Encryption@5

; 401  : 		return;

  0000e	e9 5e 02 00 00	 jmp	 $LN21@Encryption@5
$LN19@Encryption@5:

; 402  : 	
; 403  : 	if (!ThreadPoolRunning || unitCount == 1)

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ThreadPoolRunning, 0
  0001a	74 06		 je	 SHORT $LN17@Encryption@5
  0001c	83 7d 14 01	 cmp	 DWORD PTR _unitCount$[ebp], 1
  00020	75 63		 jne	 SHORT $LN18@Encryption@5
$LN17@Encryption@5:

; 404  : 	{
; 405  : 		switch (type)

  00022	8b 45 08	 mov	 eax, DWORD PTR _type$[ebp]
  00025	89 45 d8	 mov	 DWORD PTR tv68[ebp], eax
  00028	83 7d d8 00	 cmp	 DWORD PTR tv68[ebp], 0
  0002c	74 22		 je	 SHORT $LN13@Encryption@5
  0002e	83 7d d8 01	 cmp	 DWORD PTR tv68[ebp], 1
  00032	74 02		 je	 SHORT $LN14@Encryption@5
  00034	eb 34		 jmp	 SHORT $LN12@Encryption@5
$LN14@Encryption@5:

; 406  : 		{
; 407  : 		case DecryptDataUnitsWork:
; 408  : 			DecryptDataUnitsCurrentThread (data, startUnitNo, unitCount, cryptoInfo);

  00036	8b 4d 18	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00039	51		 push	 ecx
  0003a	8b 55 14	 mov	 edx, DWORD PTR _unitCount$[ebp]
  0003d	33 c0		 xor	 eax, eax
  0003f	50		 push	 eax
  00040	52		 push	 edx
  00041	8b 4d 10	 mov	 ecx, DWORD PTR _startUnitNo$[ebp]
  00044	51		 push	 ecx
  00045	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 _DecryptDataUnitsCurrentThread@20

; 409  : 			break;

  0004e	eb 30		 jmp	 SHORT $LN15@Encryption@5
$LN13@Encryption@5:

; 410  : 
; 411  : 		case EncryptDataUnitsWork:
; 412  : 			EncryptDataUnitsCurrentThread (data, startUnitNo, unitCount, cryptoInfo);

  00050	8b 45 18	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00053	50		 push	 eax
  00054	8b 4d 14	 mov	 ecx, DWORD PTR _unitCount$[ebp]
  00057	33 d2		 xor	 edx, edx
  00059	52		 push	 edx
  0005a	51		 push	 ecx
  0005b	8b 45 10	 mov	 eax, DWORD PTR _startUnitNo$[ebp]
  0005e	50		 push	 eax
  0005f	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00062	51		 push	 ecx
  00063	e8 00 00 00 00	 call	 _EncryptDataUnitsCurrentThread@20

; 413  : 			break;

  00068	eb 16		 jmp	 SHORT $LN15@Encryption@5
$LN12@Encryption@5:

; 414  : 
; 415  : 		default:
; 416  : 			TC_THROW_FATAL_EXCEPTION;

  0006a	68 43 54 00 00	 push	 21571			; 00005443H
  0006f	6a 00		 push	 0
  00071	6a 00		 push	 0
  00073	68 a0 01 00 00	 push	 416			; 000001a0H
  00078	6a 29		 push	 41			; 00000029H
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN15@Encryption@5:

; 417  : 		}
; 418  : 
; 419  : 		return;

  00080	e9 ec 01 00 00	 jmp	 $LN21@Encryption@5
$LN18@Encryption@5:

; 420  : 	}
; 421  : 
; 422  : 	if (unitCount <= ThreadCount)

  00085	8b 55 14	 mov	 edx, DWORD PTR _unitCount$[ebp]
  00088	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _ThreadCount
  0008e	77 16		 ja	 SHORT $LN11@Encryption@5

; 423  : 	{
; 424  : 		fragmentCount = unitCount;

  00090	8b 45 14	 mov	 eax, DWORD PTR _unitCount$[ebp]
  00093	89 45 f0	 mov	 DWORD PTR _fragmentCount$[ebp], eax

; 425  : 		unitsPerFragment = 1;

  00096	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _unitsPerFragment$[ebp], 1

; 426  : 		remainder = 0;

  0009d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _remainder$[ebp], 0

; 427  : 	}
; 428  : 	else

  000a4	eb 34		 jmp	 SHORT $LN10@Encryption@5
$LN11@Encryption@5:

; 429  : 	{
; 430  : 		/* Note that it is not efficient to divide the data into fragments smaller than a few hundred bytes.
; 431  : 		The reason is that the overhead associated with thread handling would in most cases make a multi-threaded 
; 432  : 		process actually slower than a single-threaded process. */
; 433  : 
; 434  : 		fragmentCount = ThreadCount;

  000a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ThreadCount
  000ac	89 4d f0	 mov	 DWORD PTR _fragmentCount$[ebp], ecx

; 435  : 		unitsPerFragment = unitCount / ThreadCount;

  000af	8b 45 14	 mov	 eax, DWORD PTR _unitCount$[ebp]
  000b2	33 d2		 xor	 edx, edx
  000b4	f7 35 00 00 00
	00		 div	 DWORD PTR _ThreadCount
  000ba	89 45 f4	 mov	 DWORD PTR _unitsPerFragment$[ebp], eax

; 436  : 		remainder = unitCount % ThreadCount;

  000bd	8b 45 14	 mov	 eax, DWORD PTR _unitCount$[ebp]
  000c0	33 d2		 xor	 edx, edx
  000c2	f7 35 00 00 00
	00		 div	 DWORD PTR _ThreadCount
  000c8	89 55 fc	 mov	 DWORD PTR _remainder$[ebp], edx

; 437  : 
; 438  : 		if (remainder > 0)

  000cb	83 7d fc 00	 cmp	 DWORD PTR _remainder$[ebp], 0
  000cf	76 09		 jbe	 SHORT $LN10@Encryption@5

; 439  : 			++unitsPerFragment;

  000d1	8b 55 f4	 mov	 edx, DWORD PTR _unitsPerFragment$[ebp]
  000d4	83 c2 01	 add	 edx, 1
  000d7	89 55 f4	 mov	 DWORD PTR _unitsPerFragment$[ebp], edx
$LN10@Encryption@5:

; 440  : 	}
; 441  : 	
; 442  : 	fragmentData = data;

  000da	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  000dd	89 45 ec	 mov	 DWORD PTR _fragmentData$[ebp], eax

; 443  : 	fragmentStartUnitNo = startUnitNo->Value;

  000e0	8b 4d 10	 mov	 ecx, DWORD PTR _startUnitNo$[ebp]
  000e3	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e5	89 55 e0	 mov	 DWORD PTR _fragmentStartUnitNo$[ebp], edx
  000e8	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000eb	89 45 e4	 mov	 DWORD PTR _fragmentStartUnitNo$[ebp+4], eax

; 444  : 
; 445  : 	TC_ACQUIRE_MUTEX (&EnqueueMutex);

  000ee	b9 00 00 00 00	 mov	 ecx, OFFSET _EnqueueMutex
  000f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExAcquireFastMutex@4

; 446  : 	firstFragmentWorkItem = &WorkItemQueue[EnqueuePosition];

  000f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _EnqueuePosition
  000ff	6b c9 48	 imul	 ecx, 72			; 00000048H
  00102	81 c1 00 00 00
	00		 add	 ecx, OFFSET _WorkItemQueue
  00108	89 4d dc	 mov	 DWORD PTR _firstFragmentWorkItem$[ebp], ecx
$LN8@Encryption@5:

; 447  : 
; 448  : 	while (GetWorkItemState (firstFragmentWorkItem) != WorkItemFree)

  0010b	8b 55 dc	 mov	 edx, DWORD PTR _firstFragmentWorkItem$[ebp]
  0010e	52		 push	 edx
  0010f	e8 00 00 00 00	 call	 _GetWorkItemState@4
  00114	85 c0		 test	 eax, eax
  00116	74 15		 je	 SHORT $LN7@Encryption@5

; 449  : 	{
; 450  : 		TC_WAIT_EVENT (WorkItemCompletedEvent);

  00118	6a 00		 push	 0
  0011a	6a 00		 push	 0
  0011c	6a 00		 push	 0
  0011e	6a 00		 push	 0
  00120	68 00 00 00 00	 push	 OFFSET _WorkItemCompletedEvent
  00125	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 451  : 	}

  0012b	eb de		 jmp	 SHORT $LN8@Encryption@5
$LN7@Encryption@5:

; 452  : 
; 453  : 	firstFragmentWorkItem->OutstandingFragmentCount = fragmentCount;

  0012d	8b 45 dc	 mov	 eax, DWORD PTR _firstFragmentWorkItem$[ebp]
  00130	8b 4d f0	 mov	 ecx, DWORD PTR _fragmentCount$[ebp]
  00133	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$LN6@Encryption@5:

; 454  : 
; 455  : 	while (fragmentCount-- > 0)

  00136	8b 55 f0	 mov	 edx, DWORD PTR _fragmentCount$[ebp]
  00139	8b 45 f0	 mov	 eax, DWORD PTR _fragmentCount$[ebp]
  0013c	83 e8 01	 sub	 eax, 1
  0013f	89 45 f0	 mov	 DWORD PTR _fragmentCount$[ebp], eax
  00142	85 d2		 test	 edx, edx
  00144	0f 86 ed 00 00
	00		 jbe	 $LN5@Encryption@5

; 456  : 	{
; 457  : 		workItem = &WorkItemQueue[EnqueuePosition++];

  0014a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _EnqueuePosition
  00150	6b c9 48	 imul	 ecx, 72			; 00000048H
  00153	81 c1 00 00 00
	00		 add	 ecx, OFFSET _WorkItemQueue
  00159	89 4d f8	 mov	 DWORD PTR _workItem$[ebp], ecx
  0015c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _EnqueuePosition
  00162	83 c2 01	 add	 edx, 1
  00165	89 15 00 00 00
	00		 mov	 DWORD PTR _EnqueuePosition, edx

; 458  : 		if (EnqueuePosition >= TC_ENC_THREAD_POOL_QUEUE_SIZE)

  0016b	81 3d 00 00 00
	00 80 00 00 00	 cmp	 DWORD PTR _EnqueuePosition, 128 ; 00000080H
  00175	7c 0a		 jl	 SHORT $LN3@Encryption@5

; 459  : 			EnqueuePosition = 0;

  00177	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _EnqueuePosition, 0
$LN3@Encryption@5:

; 460  : 
; 461  : 		while (GetWorkItemState (workItem) != WorkItemFree)

  00181	8b 45 f8	 mov	 eax, DWORD PTR _workItem$[ebp]
  00184	50		 push	 eax
  00185	e8 00 00 00 00	 call	 _GetWorkItemState@4
  0018a	85 c0		 test	 eax, eax
  0018c	74 15		 je	 SHORT $LN2@Encryption@5

; 462  : 		{
; 463  : 			TC_WAIT_EVENT (WorkItemCompletedEvent);

  0018e	6a 00		 push	 0
  00190	6a 00		 push	 0
  00192	6a 00		 push	 0
  00194	6a 00		 push	 0
  00196	68 00 00 00 00	 push	 OFFSET _WorkItemCompletedEvent
  0019b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 464  : 		}

  001a1	eb de		 jmp	 SHORT $LN3@Encryption@5
$LN2@Encryption@5:

; 465  : 
; 466  : 		workItem->Type = type;

  001a3	8b 4d f8	 mov	 ecx, DWORD PTR _workItem$[ebp]
  001a6	8b 55 08	 mov	 edx, DWORD PTR _type$[ebp]
  001a9	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 467  : 		workItem->FirstFragment = firstFragmentWorkItem;

  001ac	8b 45 f8	 mov	 eax, DWORD PTR _workItem$[ebp]
  001af	8b 4d dc	 mov	 ecx, DWORD PTR _firstFragmentWorkItem$[ebp]
  001b2	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 468  : 
; 469  : 		workItem->Encryption.CryptoInfo = cryptoInfo;

  001b5	8b 55 f8	 mov	 edx, DWORD PTR _workItem$[ebp]
  001b8	8b 45 18	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  001bb	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 470  : 		workItem->Encryption.Data = fragmentData;

  001be	8b 4d f8	 mov	 ecx, DWORD PTR _workItem$[ebp]
  001c1	8b 55 ec	 mov	 edx, DWORD PTR _fragmentData$[ebp]
  001c4	89 51 24	 mov	 DWORD PTR [ecx+36], edx

; 471  : 		workItem->Encryption.UnitCount = unitsPerFragment;

  001c7	8b 45 f8	 mov	 eax, DWORD PTR _workItem$[ebp]
  001ca	8b 4d f4	 mov	 ecx, DWORD PTR _unitsPerFragment$[ebp]
  001cd	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 472  : 		workItem->Encryption.StartUnitNo.Value = fragmentStartUnitNo;

  001d0	8b 55 f8	 mov	 edx, DWORD PTR _workItem$[ebp]
  001d3	8b 45 e0	 mov	 eax, DWORD PTR _fragmentStartUnitNo$[ebp]
  001d6	89 42 28	 mov	 DWORD PTR [edx+40], eax
  001d9	8b 4d e4	 mov	 ecx, DWORD PTR _fragmentStartUnitNo$[ebp+4]
  001dc	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx

; 473  : 
; 474  :  		fragmentData += unitsPerFragment * ENCRYPTION_DATA_UNIT_SIZE;

  001df	8b 55 f4	 mov	 edx, DWORD PTR _unitsPerFragment$[ebp]
  001e2	c1 e2 09	 shl	 edx, 9
  001e5	03 55 ec	 add	 edx, DWORD PTR _fragmentData$[ebp]
  001e8	89 55 ec	 mov	 DWORD PTR _fragmentData$[ebp], edx

; 475  : 		fragmentStartUnitNo += unitsPerFragment;

  001eb	8b 45 f4	 mov	 eax, DWORD PTR _unitsPerFragment$[ebp]
  001ee	33 c9		 xor	 ecx, ecx
  001f0	03 45 e0	 add	 eax, DWORD PTR _fragmentStartUnitNo$[ebp]
  001f3	8b 55 e4	 mov	 edx, DWORD PTR _fragmentStartUnitNo$[ebp+4]
  001f6	13 d1		 adc	 edx, ecx
  001f8	89 45 e0	 mov	 DWORD PTR _fragmentStartUnitNo$[ebp], eax
  001fb	89 55 e4	 mov	 DWORD PTR _fragmentStartUnitNo$[ebp+4], edx

; 476  : 
; 477  : 		if (remainder > 0 && --remainder == 0)

  001fe	83 7d fc 00	 cmp	 DWORD PTR _remainder$[ebp], 0
  00202	76 14		 jbe	 SHORT $LN1@Encryption@5
  00204	8b 45 fc	 mov	 eax, DWORD PTR _remainder$[ebp]
  00207	83 e8 01	 sub	 eax, 1
  0020a	89 45 fc	 mov	 DWORD PTR _remainder$[ebp], eax
  0020d	75 09		 jne	 SHORT $LN1@Encryption@5

; 478  : 			--unitsPerFragment;

  0020f	8b 4d f4	 mov	 ecx, DWORD PTR _unitsPerFragment$[ebp]
  00212	83 e9 01	 sub	 ecx, 1
  00215	89 4d f4	 mov	 DWORD PTR _unitsPerFragment$[ebp], ecx
$LN1@Encryption@5:

; 479  : 
; 480  : 		SetWorkItemState (workItem, WorkItemReady);

  00218	6a 01		 push	 1
  0021a	8b 55 f8	 mov	 edx, DWORD PTR _workItem$[ebp]
  0021d	52		 push	 edx
  0021e	e8 00 00 00 00	 call	 _SetWorkItemState@8

; 481  : 		TC_SET_EVENT (WorkItemReadyEvent);

  00223	6a 00		 push	 0
  00225	6a 01		 push	 1
  00227	68 00 00 00 00	 push	 OFFSET _WorkItemReadyEvent
  0022c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 482  : 	}

  00232	e9 ff fe ff ff	 jmp	 $LN6@Encryption@5
$LN5@Encryption@5:

; 483  : 
; 484  : 	TC_RELEASE_MUTEX (&EnqueueMutex);

  00237	b9 00 00 00 00	 mov	 ecx, OFFSET _EnqueueMutex
  0023c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExReleaseFastMutex@4

; 485  : 
; 486  : 	TC_WAIT_EVENT (firstFragmentWorkItem->ItemCompletedEvent);

  00242	6a 00		 push	 0
  00244	6a 00		 push	 0
  00246	6a 00		 push	 0
  00248	6a 00		 push	 0
  0024a	8b 45 dc	 mov	 eax, DWORD PTR _firstFragmentWorkItem$[ebp]
  0024d	83 c0 08	 add	 eax, 8
  00250	50		 push	 eax
  00251	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 487  : 	SetWorkItemState (firstFragmentWorkItem, WorkItemFree);

  00257	6a 00		 push	 0
  00259	8b 4d dc	 mov	 ecx, DWORD PTR _firstFragmentWorkItem$[ebp]
  0025c	51		 push	 ecx
  0025d	e8 00 00 00 00	 call	 _SetWorkItemState@8

; 488  : 	TC_SET_EVENT (WorkItemCompletedEvent);

  00262	6a 00		 push	 0
  00264	6a 01		 push	 1
  00266	68 00 00 00 00	 push	 OFFSET _WorkItemCompletedEvent
  0026b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
$LN21@Encryption@5:

; 489  : }

  00271	8b e5		 mov	 esp, ebp
  00273	5d		 pop	 ebp
  00274	c2 14 00	 ret	 20			; 00000014H
_EncryptionThreadPoolDoWork@20 ENDP
_TEXT	ENDS
PUBLIC	_GetEncryptionThreadCount@0
; Function compile flags: /Odtp
;	COMDAT _GetEncryptionThreadCount@0
_TEXT	SEGMENT
_GetEncryptionThreadCount@0 PROC			; COMDAT

; 493  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 494  : 	return ThreadPoolRunning ? ThreadCount : 0;

  00005	a1 00 00 00 00	 mov	 eax, DWORD PTR _ThreadPoolRunning
  0000a	f7 d8		 neg	 eax
  0000c	1b c0		 sbb	 eax, eax
  0000e	23 05 00 00 00
	00		 and	 eax, DWORD PTR _ThreadCount

; 495  : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
_GetEncryptionThreadCount@0 ENDP
_TEXT	ENDS
PUBLIC	_GetMaxEncryptionThreadCount@0
; Function compile flags: /Odtp
;	COMDAT _GetMaxEncryptionThreadCount@0
_TEXT	SEGMENT
_GetMaxEncryptionThreadCount@0 PROC			; COMDAT

; 499  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 500  : 	return TC_ENC_THREAD_POOL_MAX_THREAD_COUNT;

  00005	b8 40 00 00 00	 mov	 eax, 64			; 00000040H

; 501  : }

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
_GetMaxEncryptionThreadCount@0 ENDP
_TEXT	ENDS
PUBLIC	_IsEncryptionThreadPoolRunning@0
; Function compile flags: /Odtp
;	COMDAT _IsEncryptionThreadPoolRunning@0
_TEXT	SEGMENT
_IsEncryptionThreadPoolRunning@0 PROC			; COMDAT

; 505  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 506  : 	return ThreadPoolRunning;

  00005	a1 00 00 00 00	 mov	 eax, DWORD PTR _ThreadPoolRunning

; 507  : }

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
_IsEncryptionThreadPoolRunning@0 ENDP
_TEXT	ENDS
END
