; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\users\public\desktop\projects\ciphershed\src\common\cache.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_cacheEmpty
_DATA	SEGMENT
COMM	_CachedPasswords:BYTE:0120H
_DATA	ENDS
_BSS	SEGMENT
_nPasswordIdx DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_cacheEmpty DD	01H
_DATA	ENDS
PUBLIC	_ReadVolumeHeaderWCache@20
EXTRN	_ReadVolumeHeader@20:PROC
; Function compile flags: /Odtp
; File c:\users\public\desktop\projects\ciphershed\src\common\cache.c
;	COMDAT _ReadVolumeHeaderWCache@20
_TEXT	SEGMENT
_i$ = -8						; size = 4
_nReturnCode$ = -4					; size = 4
_bBoot$ = 8						; size = 4
_bCache$ = 12						; size = 4
_header$ = 16						; size = 4
_password$ = 20						; size = 4
_retInfo$ = 24						; size = 4
_ReadVolumeHeaderWCache@20 PROC				; COMDAT

; 25   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8
  00008	56		 push	 esi
  00009	57		 push	 edi

; 26   : 	int nReturnCode = ERR_PASSWORD_WRONG;

  0000a	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR _nReturnCode$[ebp], 3

; 27   : 	int i;
; 28   : 
; 29   : 	/* Attempt to recognize volume using mount password */
; 30   : 	if (password->Length > 0)

  00011	8b 45 14	 mov	 eax, DWORD PTR _password$[ebp]
  00014	83 38 00	 cmp	 DWORD PTR [eax], 0
  00017	0f 86 ad 00 00
	00		 jbe	 $LN15@ReadVolume

; 31   : 	{
; 32   : 		nReturnCode = ReadVolumeHeader (bBoot, header, password, retInfo, NULL);

  0001d	6a 00		 push	 0
  0001f	8b 4d 18	 mov	 ecx, DWORD PTR _retInfo$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 14	 mov	 edx, DWORD PTR _password$[ebp]
  00026	52		 push	 edx
  00027	8b 45 10	 mov	 eax, DWORD PTR _header$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _bBoot$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 _ReadVolumeHeader@20
  00034	89 45 fc	 mov	 DWORD PTR _nReturnCode$[ebp], eax

; 33   : 
; 34   : 		/* Save mount passwords back into cache if asked to do so */
; 35   : 		if (bCache && (nReturnCode == 0 || nReturnCode == ERR_CIPHER_INIT_WEAK_KEY))

  00037	83 7d 0c 00	 cmp	 DWORD PTR _bCache$[ebp], 0
  0003b	0f 84 87 00 00
	00		 je	 $LN14@ReadVolume
  00041	83 7d fc 00	 cmp	 DWORD PTR _nReturnCode$[ebp], 0
  00045	74 06		 je	 SHORT $LN13@ReadVolume
  00047	83 7d fc 12	 cmp	 DWORD PTR _nReturnCode$[ebp], 18 ; 00000012H
  0004b	75 7b		 jne	 SHORT $LN14@ReadVolume
$LN13@ReadVolume:

; 36   : 		{
; 37   : 			for (i = 0; i < CACHE_SIZE; i++)

  0004d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00054	eb 09		 jmp	 SHORT $LN12@ReadVolume
$LN11@ReadVolume:
  00056	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00059	83 c2 01	 add	 edx, 1
  0005c	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$LN12@ReadVolume:
  0005f	83 7d f8 04	 cmp	 DWORD PTR _i$[ebp], 4
  00063	7d 1e		 jge	 SHORT $LN10@ReadVolume

; 38   : 			{
; 39   : 				if (memcmp (&CachedPasswords[i], password, sizeof (Password)) == 0)

  00065	b9 12 00 00 00	 mov	 ecx, 18			; 00000012H
  0006a	8b 7d 14	 mov	 edi, DWORD PTR _password$[ebp]
  0006d	8b 75 f8	 mov	 esi, DWORD PTR _i$[ebp]
  00070	6b f6 48	 imul	 esi, 72			; 00000048H
  00073	81 c6 00 00 00
	00		 add	 esi, OFFSET _CachedPasswords
  00079	33 c0		 xor	 eax, eax
  0007b	f3 a7		 repe cmpsd
  0007d	75 02		 jne	 SHORT $LN9@ReadVolume

; 40   : 					break;

  0007f	eb 02		 jmp	 SHORT $LN10@ReadVolume
$LN9@ReadVolume:

; 41   : 			}

  00081	eb d3		 jmp	 SHORT $LN11@ReadVolume
$LN10@ReadVolume:

; 42   : 
; 43   : 			if (i == CACHE_SIZE)

  00083	83 7d f8 04	 cmp	 DWORD PTR _i$[ebp], 4
  00087	75 3f		 jne	 SHORT $LN14@ReadVolume

; 44   : 			{
; 45   : 				/* Store the password */
; 46   : 				CachedPasswords[nPasswordIdx] = *password;

  00089	8b 75 14	 mov	 esi, DWORD PTR _password$[ebp]
  0008c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _nPasswordIdx
  00092	6b ff 48	 imul	 edi, 72			; 00000048H
  00095	81 c7 00 00 00
	00		 add	 edi, OFFSET _CachedPasswords
  0009b	b9 12 00 00 00	 mov	 ecx, 18			; 00000012H
  000a0	f3 a5		 rep movsd

; 47   : 
; 48   : 				/* Try another slot */
; 49   : 				nPasswordIdx = (nPasswordIdx + 1) % CACHE_SIZE;

  000a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nPasswordIdx
  000a8	83 c1 01	 add	 ecx, 1
  000ab	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  000b1	79 05		 jns	 SHORT $LN19@ReadVolume
  000b3	49		 dec	 ecx
  000b4	83 c9 fc	 or	 ecx, -4			; fffffffcH
  000b7	41		 inc	 ecx
$LN19@ReadVolume:
  000b8	89 0d 00 00 00
	00		 mov	 DWORD PTR _nPasswordIdx, ecx

; 50   : 
; 51   : 				cacheEmpty = 0;

  000be	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _cacheEmpty, 0
$LN14@ReadVolume:

; 52   : 			}
; 53   : 		}

  000c8	eb 5d		 jmp	 SHORT $LN7@ReadVolume
$LN15@ReadVolume:

; 54   : 	}
; 55   : 	else if (!cacheEmpty)

  000ca	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cacheEmpty, 0
  000d1	75 54		 jne	 SHORT $LN7@ReadVolume

; 56   : 	{
; 57   : 		/* Attempt to recognize volume using cached passwords */
; 58   : 		for (i = 0; i < CACHE_SIZE; i++)

  000d3	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000da	eb 09		 jmp	 SHORT $LN5@ReadVolume
$LN4@ReadVolume:
  000dc	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000df	83 c2 01	 add	 edx, 1
  000e2	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$LN5@ReadVolume:
  000e5	83 7d f8 04	 cmp	 DWORD PTR _i$[ebp], 4
  000e9	7d 3c		 jge	 SHORT $LN7@ReadVolume

; 59   : 		{
; 60   : 			if (CachedPasswords[i].Length > 0)

  000eb	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000ee	6b c0 48	 imul	 eax, 72			; 00000048H
  000f1	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _CachedPasswords[eax], 0
  000f8	76 2b		 jbe	 SHORT $LN2@ReadVolume

; 61   : 			{
; 62   : 				nReturnCode = ReadVolumeHeader (bBoot, header, &CachedPasswords[i], retInfo, NULL);

  000fa	6a 00		 push	 0
  000fc	8b 4d 18	 mov	 ecx, DWORD PTR _retInfo$[ebp]
  000ff	51		 push	 ecx
  00100	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00103	6b d2 48	 imul	 edx, 72			; 00000048H
  00106	81 c2 00 00 00
	00		 add	 edx, OFFSET _CachedPasswords
  0010c	52		 push	 edx
  0010d	8b 45 10	 mov	 eax, DWORD PTR _header$[ebp]
  00110	50		 push	 eax
  00111	8b 4d 08	 mov	 ecx, DWORD PTR _bBoot$[ebp]
  00114	51		 push	 ecx
  00115	e8 00 00 00 00	 call	 _ReadVolumeHeader@20
  0011a	89 45 fc	 mov	 DWORD PTR _nReturnCode$[ebp], eax

; 63   : 
; 64   : 				if (nReturnCode != ERR_PASSWORD_WRONG)

  0011d	83 7d fc 03	 cmp	 DWORD PTR _nReturnCode$[ebp], 3
  00121	74 02		 je	 SHORT $LN2@ReadVolume

; 65   : 					break;

  00123	eb 02		 jmp	 SHORT $LN7@ReadVolume
$LN2@ReadVolume:

; 66   : 			}
; 67   : 		}

  00125	eb b5		 jmp	 SHORT $LN4@ReadVolume
$LN7@ReadVolume:

; 68   : 	}
; 69   : 
; 70   : 	return nReturnCode;

  00127	8b 45 fc	 mov	 eax, DWORD PTR _nReturnCode$[ebp]

; 71   : }

  0012a	5f		 pop	 edi
  0012b	5e		 pop	 esi
  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c2 14 00	 ret	 20			; 00000014H
_ReadVolumeHeaderWCache@20 ENDP
_TEXT	ENDS
PUBLIC	_AddPasswordToCache@4
; Function compile flags: /Odtp
;	COMDAT _AddPasswordToCache@4
_TEXT	SEGMENT
_i$ = -4						; size = 4
_password$ = 8						; size = 4
_AddPasswordToCache@4 PROC				; COMDAT

; 75   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	56		 push	 esi
  00007	57		 push	 edi

; 76   : 	int i;
; 77   : 	for (i = 0; i < CACHE_SIZE; i++)

  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000f	eb 09		 jmp	 SHORT $LN4@AddPasswor
$LN3@AddPasswor:
  00011	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00014	83 c0 01	 add	 eax, 1
  00017	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@AddPasswor:
  0001a	83 7d fc 04	 cmp	 DWORD PTR _i$[ebp], 4
  0001e	7d 1e		 jge	 SHORT $LN2@AddPasswor

; 78   : 	{
; 79   : 		if (memcmp (&CachedPasswords[i], password, sizeof (Password)) == 0)

  00020	b9 12 00 00 00	 mov	 ecx, 18			; 00000012H
  00025	8b 7d 08	 mov	 edi, DWORD PTR _password$[ebp]
  00028	8b 75 fc	 mov	 esi, DWORD PTR _i$[ebp]
  0002b	6b f6 48	 imul	 esi, 72			; 00000048H
  0002e	81 c6 00 00 00
	00		 add	 esi, OFFSET _CachedPasswords
  00034	33 d2		 xor	 edx, edx
  00036	f3 a7		 repe cmpsd
  00038	75 02		 jne	 SHORT $LN1@AddPasswor

; 80   : 			return;

  0003a	eb 3e		 jmp	 SHORT $LN5@AddPasswor
$LN1@AddPasswor:

; 81   : 	}

  0003c	eb d3		 jmp	 SHORT $LN3@AddPasswor
$LN2@AddPasswor:

; 82   : 
; 83   : 	CachedPasswords[nPasswordIdx] = *password;

  0003e	8b 75 08	 mov	 esi, DWORD PTR _password$[ebp]
  00041	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _nPasswordIdx
  00047	6b ff 48	 imul	 edi, 72			; 00000048H
  0004a	81 c7 00 00 00
	00		 add	 edi, OFFSET _CachedPasswords
  00050	b9 12 00 00 00	 mov	 ecx, 18			; 00000012H
  00055	f3 a5		 rep movsd

; 84   : 	nPasswordIdx = (nPasswordIdx + 1) % CACHE_SIZE;

  00057	a1 00 00 00 00	 mov	 eax, DWORD PTR _nPasswordIdx
  0005c	83 c0 01	 add	 eax, 1
  0005f	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00064	79 05		 jns	 SHORT $LN8@AddPasswor
  00066	48		 dec	 eax
  00067	83 c8 fc	 or	 eax, -4			; fffffffcH
  0006a	40		 inc	 eax
$LN8@AddPasswor:
  0006b	a3 00 00 00 00	 mov	 DWORD PTR _nPasswordIdx, eax

; 85   : 	cacheEmpty = 0;

  00070	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _cacheEmpty, 0
$LN5@AddPasswor:

; 86   : }

  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c2 04 00	 ret	 4
_AddPasswordToCache@4 ENDP
_TEXT	ENDS
PUBLIC	_RtlSecureZeroMemory@8
PUBLIC	_WipeCache@0
; Function compile flags: /Odtp
;	COMDAT _WipeCache@0
_TEXT	SEGMENT
_burnm$27159 = -8					; size = 4
_burnc$27161 = -4					; size = 4
_WipeCache@0 PROC					; COMDAT

; 90   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8
$LN5@WipeCache:

; 91   : 	burn (CachedPasswords, sizeof (CachedPasswords));

  00008	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _burnm$27159[ebp], OFFSET _CachedPasswords
  0000f	c7 45 fc 20 01
	00 00		 mov	 DWORD PTR _burnc$27161[ebp], 288 ; 00000120H
  00016	68 20 01 00 00	 push	 288			; 00000120H
  0001b	68 00 00 00 00	 push	 OFFSET _CachedPasswords
  00020	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@WipeCache:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _burnc$27161[ebp]
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _burnc$27161[ebp]
  0002b	83 e9 01	 sub	 ecx, 1
  0002e	89 4d fc	 mov	 DWORD PTR _burnc$27161[ebp], ecx
  00031	85 c0		 test	 eax, eax
  00033	74 11		 je	 SHORT $LN4@WipeCache
  00035	8b 55 f8	 mov	 edx, DWORD PTR _burnm$27159[ebp]
  00038	c6 02 00	 mov	 BYTE PTR [edx], 0
  0003b	8b 45 f8	 mov	 eax, DWORD PTR _burnm$27159[ebp]
  0003e	83 c0 01	 add	 eax, 1
  00041	89 45 f8	 mov	 DWORD PTR _burnm$27159[ebp], eax
  00044	eb df		 jmp	 SHORT $LN2@WipeCache
$LN4@WipeCache:
  00046	33 c9		 xor	 ecx, ecx
  00048	75 be		 jne	 SHORT $LN5@WipeCache

; 92   : 	nPasswordIdx = 0;

  0004a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _nPasswordIdx, 0

; 93   : 	cacheEmpty = 1;

  00054	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _cacheEmpty, 1

; 94   : }

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_WipeCache@0 ENDP
; Function compile flags: /Odtp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT _RtlSecureZeroMemory@8
_TEXT	SEGMENT
_vptr$ = -4						; size = 4
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory@8 PROC				; COMDAT

; 8322 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 8323 :     volatile char *vptr = (volatile char *)ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _vptr$[ebp], eax
$LN2@RtlSecureZ:

; 8324 : 
; 8325 : #if defined(_M_AMD64)
; 8326 : 
; 8327 :         __stosb((PUCHAR)((ULONG64)vptr), 0, cnt);
; 8328 : 
; 8329 : #else
; 8330 : 
; 8331 :     while (cnt) {

  0000c	83 7d 0c 00	 cmp	 DWORD PTR _cnt$[ebp], 0
  00010	74 1a		 je	 SHORT $LN1@RtlSecureZ

; 8332 :         *vptr = 0;

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _vptr$[ebp]
  00015	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 8333 :         vptr++;

  00018	8b 55 fc	 mov	 edx, DWORD PTR _vptr$[ebp]
  0001b	83 c2 01	 add	 edx, 1
  0001e	89 55 fc	 mov	 DWORD PTR _vptr$[ebp], edx

; 8334 :         cnt--;

  00021	8b 45 0c	 mov	 eax, DWORD PTR _cnt$[ebp]
  00024	83 e8 01	 sub	 eax, 1
  00027	89 45 0c	 mov	 DWORD PTR _cnt$[ebp], eax

; 8335 :     }

  0002a	eb e0		 jmp	 SHORT $LN2@RtlSecureZ
$LN1@RtlSecureZ:

; 8336 : 
; 8337 : #endif
; 8338 : 
; 8339 :     return ptr;

  0002c	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]

; 8340 : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
_RtlSecureZeroMemory@8 ENDP
_TEXT	ENDS
END
