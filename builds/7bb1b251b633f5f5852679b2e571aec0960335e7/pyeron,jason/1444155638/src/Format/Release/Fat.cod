; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\Public\Desktop\projects\ciphershed\src\Common\Fat.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_RtlSecureZeroMemory
; Function compile flags: /Ogtpy
; File c:\program files\microsoft sdks\windows\v7.0\include\winnt.h
;	COMDAT _RtlSecureZeroMemory
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory PROC				; COMDAT

; 13070:     volatile char *vptr = (volatile char *)ptr;
; 13071: 
; 13072: #if defined(_M_AMD64)
; 13073: 
; 13074:         __stosb((PBYTE )((DWORD64)vptr), 0, cnt);
; 13075: 
; 13076: #else
; 13077: 
; 13078:     while (cnt) {

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _cnt$[esp-4]
  00004	8b 44 24 04	 mov	 eax, DWORD PTR _ptr$[esp-4]
  00008	8b c8		 mov	 ecx, eax
  0000a	85 d2		 test	 edx, edx
  0000c	74 0b		 je	 SHORT $LN1@RtlSecureZ
  0000e	8b ff		 npad	 2
$LL2@RtlSecureZ:

; 13079:         *vptr = 0;

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 13080:         vptr++;

  00013	41		 inc	 ecx

; 13081:         cnt--;

  00014	83 ea 01	 sub	 edx, 1
  00017	75 f7		 jne	 SHORT $LL2@RtlSecureZ
$LN1@RtlSecureZ:

; 13082:     }
; 13083: 
; 13084: #endif
; 13085: 
; 13086:     return ptr;
; 13087: }

  00019	c3		 ret	 0
_RtlSecureZeroMemory ENDP
_TEXT	ENDS
PUBLIC	_GetFatParams
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
; Function compile flags: /Ogtpy
; File c:\users\public\desktop\projects\ciphershed\src\common\fat.c
;	COMDAT _GetFatParams
_TEXT	SEGMENT
tv420 = -16						; size = 8
tv477 = -8						; size = 8
_ft$ = 8						; size = 4
_GetFatParams PROC					; COMDAT

; 28   : {

  00000	83 ec 10	 sub	 esp, 16			; 00000010H
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi

; 29   : 	uint64 volumeSize = (uint64) ft->num_sectors * ft->sector_size;

  00006	8b 74 24 20	 mov	 esi, DWORD PTR _ft$[esp+24]
  0000a	0f b7 46 32	 movzx	 eax, WORD PTR [esi+50]
  0000e	57		 push	 edi
  0000f	0f b7 f8	 movzx	 edi, ax
  00012	8b c7		 mov	 eax, edi
  00014	99		 cdq
  00015	8b c8		 mov	 ecx, eax
  00017	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0001a	52		 push	 edx
  0001b	51		 push	 ecx
  0001c	6a 00		 push	 0
  0001e	50		 push	 eax
  0001f	89 4c 24 20	 mov	 DWORD PTR tv420[esp+48], ecx
  00023	89 54 24 24	 mov	 DWORD PTR tv420[esp+52], edx
  00027	e8 00 00 00 00	 call	 __allmul

; 30   : 	unsigned int fatsecs;
; 31   : 
; 32   : 	if(ft->cluster_size == 0)	// 'Default' cluster size

  0002c	83 7e 28 00	 cmp	 DWORD PTR [esi+40], 0
  00030	8b e8		 mov	 ebp, eax
  00032	8b da		 mov	 ebx, edx
  00034	0f 85 fb 00 00
	00		 jne	 $LN47@GetFatPara

; 33   : 	{
; 34   : 		uint32 clusterSize;
; 35   : 
; 36   : 		// Determine optimal cluster size to minimize FAT size (mounting delay), maximize number of files, keep 4 KB alignment, etc.
; 37   : 		if (volumeSize >= 2 * BYTES_PER_TB)

  0003a	81 fb 00 02 00
	00		 cmp	 ebx, 512		; 00000200H
  00040	72 10		 jb	 SHORT $LN31@GetFatPara
  00042	77 04		 ja	 SHORT $LN36@GetFatPara
  00044	85 ed		 test	 ebp, ebp
  00046	72 0a		 jb	 SHORT $LN31@GetFatPara
$LN36@GetFatPara:

; 38   : 			clusterSize = 256 * BYTES_PER_KB;

  00048	b8 00 00 04 00	 mov	 eax, 262144		; 00040000H
  0004d	e9 9e 00 00 00	 jmp	 $LN14@GetFatPara
$LN31@GetFatPara:

; 39   : 		else if (volumeSize >= 512 * BYTES_PER_GB)

  00052	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H
  00058	72 10		 jb	 SHORT $LN29@GetFatPara
  0005a	77 04		 ja	 SHORT $LN37@GetFatPara
  0005c	85 ed		 test	 ebp, ebp
  0005e	72 0a		 jb	 SHORT $LN29@GetFatPara
$LN37@GetFatPara:

; 40   : 			clusterSize = 128 * BYTES_PER_KB;

  00060	b8 00 00 02 00	 mov	 eax, 131072		; 00020000H
  00065	e9 86 00 00 00	 jmp	 $LN14@GetFatPara
$LN29@GetFatPara:

; 41   : 		else if (volumeSize >= 128 * BYTES_PER_GB)

  0006a	83 fb 20	 cmp	 ebx, 32			; 00000020H
  0006d	72 0d		 jb	 SHORT $LN27@GetFatPara
  0006f	77 04		 ja	 SHORT $LN38@GetFatPara
  00071	85 ed		 test	 ebp, ebp
  00073	72 07		 jb	 SHORT $LN27@GetFatPara
$LN38@GetFatPara:

; 42   : 			clusterSize = 64 * BYTES_PER_KB;

  00075	b8 00 00 01 00	 mov	 eax, 65536		; 00010000H
  0007a	eb 74		 jmp	 SHORT $LN14@GetFatPara
$LN27@GetFatPara:

; 43   : 		else if (volumeSize >= 64 * BYTES_PER_GB)

  0007c	83 fb 10	 cmp	 ebx, 16			; 00000010H
  0007f	72 0d		 jb	 SHORT $LN25@GetFatPara
  00081	77 04		 ja	 SHORT $LN39@GetFatPara
  00083	85 ed		 test	 ebp, ebp
  00085	72 07		 jb	 SHORT $LN25@GetFatPara
$LN39@GetFatPara:

; 44   : 			clusterSize = 32 * BYTES_PER_KB;

  00087	b8 00 80 00 00	 mov	 eax, 32768		; 00008000H
  0008c	eb 62		 jmp	 SHORT $LN14@GetFatPara
$LN25@GetFatPara:

; 45   : 		else if (volumeSize >= 32 * BYTES_PER_GB)

  0008e	83 fb 08	 cmp	 ebx, 8
  00091	72 0d		 jb	 SHORT $LN23@GetFatPara
  00093	77 04		 ja	 SHORT $LN40@GetFatPara
  00095	85 ed		 test	 ebp, ebp
  00097	72 07		 jb	 SHORT $LN23@GetFatPara
$LN40@GetFatPara:

; 46   : 			clusterSize = 16 * BYTES_PER_KB;

  00099	b8 00 40 00 00	 mov	 eax, 16384		; 00004000H
  0009e	eb 50		 jmp	 SHORT $LN14@GetFatPara
$LN23@GetFatPara:

; 47   : 		else if (volumeSize >= 16 * BYTES_PER_GB)

  000a0	83 fb 04	 cmp	 ebx, 4
  000a3	72 0d		 jb	 SHORT $LN21@GetFatPara
  000a5	77 04		 ja	 SHORT $LN41@GetFatPara
  000a7	85 ed		 test	 ebp, ebp
  000a9	72 07		 jb	 SHORT $LN21@GetFatPara
$LN41@GetFatPara:

; 48   : 			clusterSize = 8 * BYTES_PER_KB;

  000ab	b8 00 20 00 00	 mov	 eax, 8192		; 00002000H
  000b0	eb 3e		 jmp	 SHORT $LN14@GetFatPara
$LN21@GetFatPara:

; 49   : 		else if (volumeSize >= 512 * BYTES_PER_MB)

  000b2	85 db		 test	 ebx, ebx
  000b4	77 08		 ja	 SHORT $LN42@GetFatPara
  000b6	81 fd 00 00 00
	20		 cmp	 ebp, 536870912		; 20000000H
  000bc	72 07		 jb	 SHORT $LN19@GetFatPara
$LN42@GetFatPara:

; 50   : 			clusterSize = 4 * BYTES_PER_KB;

  000be	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  000c3	eb 2b		 jmp	 SHORT $LN14@GetFatPara
$LN19@GetFatPara:

; 51   : 		else if (volumeSize >= 256 * BYTES_PER_MB)

  000c5	85 db		 test	 ebx, ebx
  000c7	77 08		 ja	 SHORT $LN43@GetFatPara
  000c9	81 fd 00 00 00
	10		 cmp	 ebp, 268435456		; 10000000H
  000cf	72 07		 jb	 SHORT $LN17@GetFatPara
$LN43@GetFatPara:

; 52   : 			clusterSize = 2 * BYTES_PER_KB;

  000d1	b8 00 08 00 00	 mov	 eax, 2048		; 00000800H
  000d6	eb 18		 jmp	 SHORT $LN14@GetFatPara
$LN17@GetFatPara:

; 53   : 		else if (volumeSize >= 1 * BYTES_PER_MB)

  000d8	85 db		 test	 ebx, ebx
  000da	77 08		 ja	 SHORT $LN49@GetFatPara
  000dc	81 fd 00 00 10
	00		 cmp	 ebp, 1048576		; 00100000H
  000e2	72 07		 jb	 SHORT $LN15@GetFatPara
$LN49@GetFatPara:

; 54   : 			clusterSize = 1 * BYTES_PER_KB;

  000e4	b8 00 04 00 00	 mov	 eax, 1024		; 00000400H

; 55   : 		else

  000e9	eb 05		 jmp	 SHORT $LN14@GetFatPara
$LN15@GetFatPara:

; 56   : 			clusterSize = 512;

  000eb	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
$LN14@GetFatPara:

; 57   : 
; 58   : 		ft->cluster_size = clusterSize / ft->sector_size;

  000f0	33 d2		 xor	 edx, edx
  000f2	f7 f7		 div	 edi
  000f4	89 46 28	 mov	 DWORD PTR [esi+40], eax

; 59   : 		
; 60   : 		if (ft->cluster_size == 0)

  000f7	85 c0		 test	 eax, eax
  000f9	75 07		 jne	 SHORT $LN46@GetFatPara

; 61   : 			ft->cluster_size = 1;

  000fb	c7 46 28 01 00
	00 00		 mov	 DWORD PTR [esi+40], 1
$LN46@GetFatPara:

; 62   : 
; 63   : 		if (ft->cluster_size * ft->sector_size > TC_MAX_FAT_CLUSTER_SIZE)

  00102	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00105	0f af c7	 imul	 eax, edi
  00108	3d 00 00 04 00	 cmp	 eax, 262144		; 00040000H
  0010d	7e 19		 jle	 SHORT $LN12@GetFatPara

; 64   : 			ft->cluster_size = TC_MAX_FAT_CLUSTER_SIZE / ft->sector_size;

  0010f	8b 4c 24 14	 mov	 ecx, DWORD PTR tv420[esp+36]
  00113	8b 54 24 10	 mov	 edx, DWORD PTR tv420[esp+32]
  00117	51		 push	 ecx
  00118	52		 push	 edx
  00119	6a 00		 push	 0
  0011b	68 00 00 04 00	 push	 262144			; 00040000H
  00120	e8 00 00 00 00	 call	 __alldiv
  00125	89 46 28	 mov	 DWORD PTR [esi+40], eax
$LN12@GetFatPara:

; 65   : 
; 66   : 		if (ft->cluster_size > 128)

  00128	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  0012d	39 46 28	 cmp	 DWORD PTR [esi+40], eax
  00130	7e 03		 jle	 SHORT $LN47@GetFatPara

; 67   : 			ft->cluster_size = 128;

  00132	89 46 28	 mov	 DWORD PTR [esi+40], eax
$LN47@GetFatPara:

; 68   : 	}
; 69   : 
; 70   : 	if (volumeSize <= TC_MAX_FAT_CLUSTER_SIZE * 4)

  00135	85 db		 test	 ebx, ebx
  00137	77 11		 ja	 SHORT $LN51@GetFatPara
  00139	72 08		 jb	 SHORT $LN45@GetFatPara
  0013b	81 fd 00 00 10
	00		 cmp	 ebp, 1048576		; 00100000H
  00141	77 07		 ja	 SHORT $LN51@GetFatPara
$LN45@GetFatPara:

; 71   : 		ft->cluster_size = 1;

  00143	c7 46 28 01 00
	00 00		 mov	 DWORD PTR [esi+40], 1
$LN51@GetFatPara:

; 72   : 
; 73   : 	// Geometry always set to SECTORS/1/1
; 74   : 	ft->secs_track = 1; 
; 75   : 	ft->heads = 1; 
; 76   : 
; 77   : 	ft->dir_entries = 512;
; 78   : 	ft->fats = 2;
; 79   : 	ft->media = 0xf8;
; 80   : 	ft->hidden = 0;
; 81   : 
; 82   : 	ft->size_root_dir = ft->dir_entries * 32;
; 83   : 
; 84   : 	// FAT12
; 85   : 	ft->size_fat = 12;
; 86   : 	ft->reserved = 2;
; 87   : 	fatsecs = ft->num_sectors - (ft->size_root_dir + ft->sector_size - 1) / ft->sector_size - ft->reserved;
; 88   : 	ft->cluster_count = (int) (((__int64) fatsecs * ft->sector_size) / (ft->cluster_size * ft->sector_size));

  0014a	8b 5e 28	 mov	 ebx, DWORD PTR [esi+40]
  0014d	0f af df	 imul	 ebx, edi
  00150	b8 01 00 00 00	 mov	 eax, 1
  00155	8b c8		 mov	 ecx, eax
  00157	66 89 46 42	 mov	 WORD PTR [esi+66], ax
  0015b	b8 02 00 00 00	 mov	 eax, 2
  00160	66 89 46 38	 mov	 WORD PTR [esi+56], ax
  00164	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  00169	66 89 56 30	 mov	 WORD PTR [esi+48], dx
  0016d	8b c3		 mov	 eax, ebx
  0016f	99		 cdq
  00170	8b e8		 mov	 ebp, eax
  00172	89 54 24 1c	 mov	 DWORD PTR tv477[esp+36], edx
  00176	8d 87 ff 3f 00
	00		 lea	 eax, DWORD PTR [edi+16383]
  0017c	99		 cdq
  0017d	f7 ff		 idiv	 edi
  0017f	8b 54 24 14	 mov	 edx, DWORD PTR tv420[esp+36]
  00183	66 89 4e 40	 mov	 WORD PTR [esi+64], cx
  00187	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0018a	52		 push	 edx
  0018b	c7 46 20 02 00
	00 00		 mov	 DWORD PTR [esi+32], 2
  00192	c7 46 24 f8 00
	00 00		 mov	 DWORD PTR [esi+36], 248	; 000000f8H
  00199	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0
  001a0	c7 46 18 00 40
	00 00		 mov	 DWORD PTR [esi+24], 16384 ; 00004000H
  001a7	c7 46 1c 0c 00
	00 00		 mov	 DWORD PTR [esi+28], 12	; 0000000cH
  001ae	89 6c 24 1c	 mov	 DWORD PTR tv477[esp+36], ebp
  001b2	2b c8		 sub	 ecx, eax
  001b4	8b 44 24 14	 mov	 eax, DWORD PTR tv420[esp+36]
  001b8	50		 push	 eax
  001b9	83 e9 02	 sub	 ecx, 2
  001bc	6a 00		 push	 0
  001be	51		 push	 ecx
  001bf	e8 00 00 00 00	 call	 __allmul
  001c4	8b 4c 24 1c	 mov	 ecx, DWORD PTR tv477[esp+36]
  001c8	51		 push	 ecx
  001c9	55		 push	 ebp
  001ca	52		 push	 edx
  001cb	50		 push	 eax
  001cc	e8 00 00 00 00	 call	 __alldiv
  001d1	8b c8		 mov	 ecx, eax

; 89   : 	ft->fat_length = (((ft->cluster_count * 3 + 1) >> 1) + ft->sector_size - 1) / ft->sector_size;

  001d3	8d 54 49 01	 lea	 edx, DWORD PTR [ecx+ecx*2+1]
  001d7	d1 fa		 sar	 edx, 1
  001d9	8d 44 3a ff	 lea	 eax, DWORD PTR [edx+edi-1]
  001dd	99		 cdq
  001de	f7 ff		 idiv	 edi

; 90   : 
; 91   : 	if (ft->cluster_count >= 4085) // FAT16

  001e0	81 f9 f5 0f 00
	00		 cmp	 ecx, 4085		; 00000ff5H
  001e6	89 4e 14	 mov	 DWORD PTR [esi+20], ecx
  001e9	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  001ec	7c 1d		 jl	 SHORT $LN9@GetFatPara

; 92   : 	{
; 93   : 		ft->size_fat = 16;
; 94   : 		ft->reserved = 2;

  001ee	b8 02 00 00 00	 mov	 eax, 2
  001f3	66 89 46 38	 mov	 WORD PTR [esi+56], ax

; 95   : 		fatsecs = ft->num_sectors - (ft->size_root_dir + ft->sector_size - 1) / ft->sector_size - ft->reserved;
; 96   : 		ft->cluster_count = (int) (((__int64) fatsecs * ft->sector_size) / (ft->cluster_size * ft->sector_size));
; 97   : 		ft->fat_length = (ft->cluster_count * 2 + ft->sector_size - 1) / ft->sector_size;

  001f7	8d 44 4f ff	 lea	 eax, DWORD PTR [edi+ecx*2-1]
  001fb	99		 cdq
  001fc	f7 ff		 idiv	 edi
  001fe	c7 46 1c 10 00
	00 00		 mov	 DWORD PTR [esi+28], 16	; 00000010H
  00205	89 4e 14	 mov	 DWORD PTR [esi+20], ecx
  00208	89 46 2c	 mov	 DWORD PTR [esi+44], eax
$LN9@GetFatPara:

; 98   : 	}
; 99   : 	
; 100  : 	if(ft->cluster_count >= 65525) // FAT32

  0020b	81 f9 f5 ff 00
	00		 cmp	 ecx, 65525		; 0000fff5H
  00211	7c 78		 jl	 SHORT $LN5@GetFatPara

; 101  : 	{
; 102  : 		ft->size_fat = 32;
; 103  : 		ft->reserved = 32 - 1;

  00213	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  00218	c7 46 1c 20 00
	00 00		 mov	 DWORD PTR [esi+28], 32	; 00000020H
  0021f	66 89 4e 38	 mov	 WORD PTR [esi+56], cx
$LL7@GetFatPara:

; 104  : 
; 105  : 		do
; 106  : 		{
; 107  : 			ft->reserved++;

  00223	66 ff 46 38	 inc	 WORD PTR [esi+56]
  00227	0f b7 46 38	 movzx	 eax, WORD PTR [esi+56]

; 108  : 
; 109  : 			fatsecs = ft->num_sectors - ft->reserved;
; 110  : 			ft->size_root_dir = ft->cluster_size * ft->sector_size;
; 111  : 			ft->cluster_count = (int) (((__int64) fatsecs * ft->sector_size) / (ft->cluster_size * ft->sector_size));

  0022b	8b 4c 24 10	 mov	 ecx, DWORD PTR tv420[esp+32]
  0022f	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00232	0f bf e8	 movsx	 ebp, ax
  00235	8b 44 24 14	 mov	 eax, DWORD PTR tv420[esp+36]
  00239	50		 push	 eax
  0023a	51		 push	 ecx
  0023b	2b d5		 sub	 edx, ebp
  0023d	6a 00		 push	 0
  0023f	52		 push	 edx
  00240	89 5e 18	 mov	 DWORD PTR [esi+24], ebx
  00243	e8 00 00 00 00	 call	 __allmul
  00248	8b 4c 24 1c	 mov	 ecx, DWORD PTR tv477[esp+36]
  0024c	51		 push	 ecx
  0024d	8b 4c 24 1c	 mov	 ecx, DWORD PTR tv477[esp+36]
  00251	51		 push	 ecx
  00252	52		 push	 edx
  00253	50		 push	 eax
  00254	e8 00 00 00 00	 call	 __alldiv
  00259	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 112  : 			ft->fat_length = (ft->cluster_count * 4 + ft->sector_size - 1) / ft->sector_size;

  0025c	8d 44 87 ff	 lea	 eax, DWORD PTR [edi+eax*4-1]
  00260	99		 cdq
  00261	f7 ff		 idiv	 edi

; 113  : 
; 114  : 		// Align data area on TC_MAX_VOLUME_SECTOR_SIZE
; 115  : 
; 116  : 		} while (ft->sector_size == TC_SECTOR_SIZE_LEGACY
; 117  : 				&& (ft->reserved * ft->sector_size + ft->fat_length * ft->fats * ft->sector_size) % TC_MAX_VOLUME_SECTOR_SIZE != 0);

  00263	0f b7 4e 32	 movzx	 ecx, WORD PTR [esi+50]
  00267	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  0026c	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  0026f	66 3b ca	 cmp	 cx, dx
  00272	75 17		 jne	 SHORT $LN5@GetFatPara
  00274	8d 44 45 00	 lea	 eax, DWORD PTR [ebp+eax*2]
  00278	0f af c7	 imul	 eax, edi
  0027b	25 ff 0f 00 80	 and	 eax, -2147479553	; 80000fffH
  00280	79 07		 jns	 SHORT $LN52@GetFatPara
  00282	48		 dec	 eax
  00283	0d 00 f0 ff ff	 or	 eax, -4096		; fffff000H
  00288	40		 inc	 eax
$LN52@GetFatPara:
  00289	75 98		 jne	 SHORT $LL7@GetFatPara
$LN5@GetFatPara:

; 118  : 	}
; 119  : 
; 120  : 	ft->cluster_count -= ft->fat_length * ft->fats / ft->cluster_size;

  0028b	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0028e	f7 d8		 neg	 eax
  00290	03 c0		 add	 eax, eax
  00292	99		 cdq
  00293	f7 7e 28	 idiv	 DWORD PTR [esi+40]
  00296	01 46 14	 add	 DWORD PTR [esi+20], eax

; 121  : 
; 122  : 	if (ft->num_sectors >= 65536 || ft->size_fat == 32)

  00299	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0029c	3d 00 00 01 00	 cmp	 eax, 65536		; 00010000H
  002a1	73 1c		 jae	 SHORT $LN2@GetFatPara
  002a3	83 7e 1c 20	 cmp	 DWORD PTR [esi+28], 32	; 00000020H
  002a7	74 16		 je	 SHORT $LN2@GetFatPara
  002a9	5f		 pop	 edi

; 126  : 	}
; 127  : 	else
; 128  : 	{
; 129  : 		ft->sectors = (uint16) ft->num_sectors;

  002aa	66 8b c8	 mov	 cx, ax
  002ad	66 89 4e 3a	 mov	 WORD PTR [esi+58], cx

; 130  : 		ft->total_sect = 0;

  002b1	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0
  002b8	5e		 pop	 esi
  002b9	5d		 pop	 ebp
  002ba	5b		 pop	 ebx

; 131  : 	}
; 132  : }

  002bb	83 c4 10	 add	 esp, 16			; 00000010H
  002be	c3		 ret	 0
$LN2@GetFatPara:
  002bf	5f		 pop	 edi

; 123  : 	{
; 124  : 		ft->sectors = 0;

  002c0	33 d2		 xor	 edx, edx
  002c2	66 89 56 3a	 mov	 WORD PTR [esi+58], dx

; 125  : 		ft->total_sect = ft->num_sectors;

  002c6	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  002c9	5e		 pop	 esi
  002ca	5d		 pop	 ebp
  002cb	5b		 pop	 ebx

; 131  : 	}
; 132  : }

  002cc	83 c4 10	 add	 esp, 16			; 00000010H
  002cf	c3		 ret	 0
_GetFatParams ENDP
_TEXT	ENDS
PUBLIC	??_C@_08JPOPGMJJ@FAT12?5?5?5?$AA@		; `string'
PUBLIC	??_C@_08GKGPMKFJ@FAT16?5?5?5?$AA@		; `string'
PUBLIC	??_C@_08NCCHMNJC@FAT32?5?5?5?$AA@		; `string'
PUBLIC	??_C@_08PGBLPCGG@MSDOS5?40?$AA@			; `string'
PUBLIC	_PutBoot
EXTRN	_memset:PROC
;	COMDAT ??_C@_08JPOPGMJJ@FAT12?5?5?5?$AA@
CONST	SEGMENT
??_C@_08JPOPGMJJ@FAT12?5?5?5?$AA@ DB 'FAT12   ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08GKGPMKFJ@FAT16?5?5?5?$AA@
CONST	SEGMENT
??_C@_08GKGPMKFJ@FAT16?5?5?5?$AA@ DB 'FAT16   ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08NCCHMNJC@FAT32?5?5?5?$AA@
CONST	SEGMENT
??_C@_08NCCHMNJC@FAT32?5?5?5?$AA@ DB 'FAT32   ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08PGBLPCGG@MSDOS5?40?$AA@
CONST	SEGMENT
??_C@_08PGBLPCGG@MSDOS5?40?$AA@ DB 'MSDOS5.0', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PutBoot
_TEXT	SEGMENT
_ft$ = 8						; size = 4
_boot$ = 12						; size = 4
_PutBoot PROC						; COMDAT

; 136  : {

  00000	53		 push	 ebx

; 137  : 	int cnt = 0;
; 138  : 
; 139  : 	boot[cnt++] = 0xeb;	/* boot jump */
; 140  : 	boot[cnt++] = 0x3c;
; 141  : 	boot[cnt++] = 0x90;
; 142  : 	memcpy (boot + cnt, "MSDOS5.0", 8); /* system id */
; 143  : 	cnt += 8;
; 144  : 	*(__int16 *)(boot + cnt) = LE16(ft->sector_size);	/* bytes per sector */

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _ft$[esp]
  00005	56		 push	 esi
  00006	8b 74 24 10	 mov	 esi, DWORD PTR _boot$[esp+4]
  0000a	c6 06 eb	 mov	 BYTE PTR [esi], 235	; 000000ebH
  0000d	c6 46 01 3c	 mov	 BYTE PTR [esi+1], 60	; 0000003cH
  00011	c6 46 02 90	 mov	 BYTE PTR [esi+2], 144	; 00000090H
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_08PGBLPCGG@MSDOS5?40?$AA@
  0001a	89 46 03	 mov	 DWORD PTR [esi+3], eax
  0001d	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_08PGBLPCGG@MSDOS5?40?$AA@+4
  00023	89 4e 07	 mov	 DWORD PTR [esi+7], ecx
  00026	66 8b 53 32	 mov	 dx, WORD PTR [ebx+50]
  0002a	66 89 56 0b	 mov	 WORD PTR [esi+11], dx

; 145  : 	cnt += 2;
; 146  : 	boot[cnt++] = (__int8) ft->cluster_size;			/* sectors per cluster */

  0002e	8a 43 28	 mov	 al, BYTE PTR [ebx+40]
  00031	88 46 0d	 mov	 BYTE PTR [esi+13], al

; 147  : 	*(__int16 *)(boot + cnt) = LE16(ft->reserved);		/* reserved sectors */

  00034	66 8b 4b 38	 mov	 cx, WORD PTR [ebx+56]
  00038	66 89 4e 0e	 mov	 WORD PTR [esi+14], cx

; 148  : 	cnt += 2;
; 149  : 	boot[cnt++] = (__int8) ft->fats;					/* 2 fats */

  0003c	8a 53 20	 mov	 dl, BYTE PTR [ebx+32]
  0003f	88 56 10	 mov	 BYTE PTR [esi+16], dl

; 150  : 
; 151  : 	if(ft->size_fat == 32)

  00042	33 c0		 xor	 eax, eax
  00044	83 7b 1c 20	 cmp	 DWORD PTR [ebx+28], 32	; 00000020H
  00048	57		 push	 edi
  00049	75 08		 jne	 SHORT $LN10@PutBoot

; 152  : 	{
; 153  : 		boot[cnt++] = 0x00;

  0004b	88 46 11	 mov	 BYTE PTR [esi+17], al

; 154  : 		boot[cnt++] = 0x00;

  0004e	88 46 12	 mov	 BYTE PTR [esi+18], al

; 155  : 	}
; 156  : 	else

  00051	eb 08		 jmp	 SHORT $LN9@PutBoot
$LN10@PutBoot:

; 157  : 	{
; 158  : 		*(__int16 *)(boot + cnt) = LE16(ft->dir_entries);	/* 512 root entries */

  00053	66 8b 4b 30	 mov	 cx, WORD PTR [ebx+48]
  00057	66 89 4e 11	 mov	 WORD PTR [esi+17], cx
$LN9@PutBoot:

; 159  : 		cnt += 2;
; 160  : 	}
; 161  : 
; 162  : 	*(__int16 *)(boot + cnt) = LE16(ft->sectors);		/* # sectors */

  0005b	66 8b 53 3a	 mov	 dx, WORD PTR [ebx+58]
  0005f	66 89 56 13	 mov	 WORD PTR [esi+19], dx

; 163  : 	cnt += 2;
; 164  : 	boot[cnt++] = (__int8) ft->media;					/* media byte */

  00063	8a 4b 24	 mov	 cl, BYTE PTR [ebx+36]
  00066	88 4e 15	 mov	 BYTE PTR [esi+21], cl

; 165  : 
; 166  : 	if(ft->size_fat == 32)	

  00069	83 7b 1c 20	 cmp	 DWORD PTR [ebx+28], 32	; 00000020H
  0006d	75 08		 jne	 SHORT $LN8@PutBoot

; 167  : 	{
; 168  : 		boot[cnt++] = 0x00;

  0006f	88 46 16	 mov	 BYTE PTR [esi+22], al

; 169  : 		boot[cnt++] = 0x00;

  00072	88 46 17	 mov	 BYTE PTR [esi+23], al

; 170  : 	}
; 171  : 	else 

  00075	eb 08		 jmp	 SHORT $LN7@PutBoot
$LN8@PutBoot:

; 172  : 	{ 
; 173  : 		*(__int16 *)(boot + cnt) = LE16((uint16) ft->fat_length);	/* fat size */

  00077	66 8b 53 2c	 mov	 dx, WORD PTR [ebx+44]
  0007b	66 89 56 16	 mov	 WORD PTR [esi+22], dx
$LN7@PutBoot:

; 174  : 		cnt += 2;
; 175  : 	}
; 176  : 
; 177  : 	*(__int16 *)(boot + cnt) = LE16(ft->secs_track);	/* # sectors per track */

  0007f	66 8b 4b 42	 mov	 cx, WORD PTR [ebx+66]
  00083	66 89 4e 18	 mov	 WORD PTR [esi+24], cx

; 178  : 	cnt += 2;
; 179  : 	*(__int16 *)(boot + cnt) = LE16(ft->heads);			/* # heads */

  00087	66 8b 53 40	 mov	 dx, WORD PTR [ebx+64]
  0008b	66 89 56 1a	 mov	 WORD PTR [esi+26], dx

; 180  : 	cnt += 2;
; 181  : 	*(__int32 *)(boot + cnt) = LE32(ft->hidden);		/* # hidden sectors */

  0008f	8b 4b 34	 mov	 ecx, DWORD PTR [ebx+52]
  00092	89 4e 1c	 mov	 DWORD PTR [esi+28], ecx

; 182  : 	cnt += 4;
; 183  : 	*(__int32 *)(boot + cnt) = LE32(ft->total_sect);	/* # huge sectors */

  00095	8b 53 3c	 mov	 edx, DWORD PTR [ebx+60]
  00098	89 56 20	 mov	 DWORD PTR [esi+32], edx

; 184  : 	cnt += 4;
; 185  : 
; 186  : 	if(ft->size_fat == 32)

  0009b	83 7b 1c 20	 cmp	 DWORD PTR [ebx+28], 32	; 00000020H
  0009f	bf 24 00 00 00	 mov	 edi, 36			; 00000024H
  000a4	75 3b		 jne	 SHORT $LN6@PutBoot

; 187  : 	{
; 188  : 		*(__int32 *)(boot + cnt) = LE32(ft->fat_length); cnt += 4;	/* fat size 32 */

  000a6	8b 4b 2c	 mov	 ecx, DWORD PTR [ebx+44]
  000a9	89 4e 24	 mov	 DWORD PTR [esi+36], ecx

; 189  : 		boot[cnt++] = 0x00;	/* ExtFlags */

  000ac	88 46 28	 mov	 BYTE PTR [esi+40], al

; 190  : 		boot[cnt++] = 0x00;

  000af	88 46 29	 mov	 BYTE PTR [esi+41], al

; 191  : 		boot[cnt++] = 0x00;	/* FSVer */

  000b2	88 46 2a	 mov	 BYTE PTR [esi+42], al

; 192  : 		boot[cnt++] = 0x00;

  000b5	88 46 2b	 mov	 BYTE PTR [esi+43], al

; 193  : 		boot[cnt++] = 0x02;	/* RootClus */

  000b8	c6 46 2c 02	 mov	 BYTE PTR [esi+44], 2

; 194  : 		boot[cnt++] = 0x00;

  000bc	88 46 2d	 mov	 BYTE PTR [esi+45], al

; 195  : 		boot[cnt++] = 0x00;

  000bf	88 46 2e	 mov	 BYTE PTR [esi+46], al

; 196  : 		boot[cnt++] = 0x00;

  000c2	88 46 2f	 mov	 BYTE PTR [esi+47], al

; 197  : 		boot[cnt++] = 0x01;	/* FSInfo */

  000c5	c6 46 30 01	 mov	 BYTE PTR [esi+48], 1

; 198  : 		boot[cnt++] = 0x00;

  000c9	88 46 31	 mov	 BYTE PTR [esi+49], al

; 199  : 		boot[cnt++] = 0x06;	/* BkBootSec */

  000cc	c6 46 32 06	 mov	 BYTE PTR [esi+50], 6

; 200  : 		boot[cnt++] = 0x00;

  000d0	88 46 33	 mov	 BYTE PTR [esi+51], al

; 201  : 		memset(boot+cnt, 0, 12); cnt+=12;	/* Reserved */

  000d3	89 46 34	 mov	 DWORD PTR [esi+52], eax
  000d6	89 46 38	 mov	 DWORD PTR [esi+56], eax
  000d9	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  000dc	bf 40 00 00 00	 mov	 edi, 64			; 00000040H
$LN6@PutBoot:

; 202  : 	}
; 203  : 
; 204  : 	boot[cnt++] = 0x00;	/* drive number */   // FIXED 80 > 00

  000e1	88 04 37	 mov	 BYTE PTR [edi+esi], al

; 205  : 	boot[cnt++] = 0x00;	/* reserved */

  000e4	88 44 37 01	 mov	 BYTE PTR [edi+esi+1], al
  000e8	47		 inc	 edi

; 206  : 	boot[cnt++] = 0x29;	/* boot sig */

  000e9	c6 44 37 01 29	 mov	 BYTE PTR [edi+esi+1], 41 ; 00000029H

; 207  : 
; 208  : 	memcpy (boot + cnt, ft->volume_id, 4);		/* vol id */

  000ee	8b 53 0b	 mov	 edx, DWORD PTR [ebx+11]
  000f1	47		 inc	 edi
  000f2	89 54 37 01	 mov	 DWORD PTR [edi+esi+1], edx

; 209  : 	cnt += 4;
; 210  : 
; 211  : 	memcpy (boot + cnt, ft->volume_name, 11);	/* vol title */

  000f6	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000f8	47		 inc	 edi
  000f9	83 c7 04	 add	 edi, 4
  000fc	89 0c 37	 mov	 DWORD PTR [edi+esi], ecx
  000ff	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00102	89 54 37 04	 mov	 DWORD PTR [edi+esi+4], edx
  00106	66 8b 4b 08	 mov	 cx, WORD PTR [ebx+8]
  0010a	66 89 4c 37 08	 mov	 WORD PTR [edi+esi+8], cx
  0010f	8a 53 0a	 mov	 dl, BYTE PTR [ebx+10]
  00112	88 54 37 0a	 mov	 BYTE PTR [edi+esi+10], dl

; 212  : 	cnt += 11;
; 213  : 
; 214  : 	switch(ft->size_fat) /* filesystem type */

  00116	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  00119	83 c7 0b	 add	 edi, 11			; 0000000bH
  0011c	83 f9 0c	 cmp	 ecx, 12			; 0000000cH
  0011f	74 2c		 je	 SHORT $LN3@PutBoot
  00121	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00124	74 16		 je	 SHORT $LN2@PutBoot
  00126	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00129	75 35		 jne	 SHORT $LN4@PutBoot

; 218  : 		case 32: memcpy (boot + cnt, "FAT32   ", 8); break;

  0012b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_08NCCHMNJC@FAT32?5?5?5?$AA@
  00131	89 0c 37	 mov	 DWORD PTR [edi+esi], ecx
  00134	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ??_C@_08NCCHMNJC@FAT32?5?5?5?$AA@+4
  0013a	eb 20		 jmp	 SHORT $LN13@PutBoot
$LN2@PutBoot:

; 217  : 		case 16: memcpy (boot + cnt, "FAT16   ", 8); break;

  0013c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_08GKGPMKFJ@FAT16?5?5?5?$AA@
  00142	89 0c 37	 mov	 DWORD PTR [edi+esi], ecx
  00145	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ??_C@_08GKGPMKFJ@FAT16?5?5?5?$AA@+4
  0014b	eb 0f		 jmp	 SHORT $LN13@PutBoot
$LN3@PutBoot:

; 215  : 	{
; 216  : 		case 12: memcpy (boot + cnt, "FAT12   ", 8); break;

  0014d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_08JPOPGMJJ@FAT12?5?5?5?$AA@
  00153	89 0c 37	 mov	 DWORD PTR [edi+esi], ecx
  00156	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ??_C@_08JPOPGMJJ@FAT12?5?5?5?$AA@+4
$LN13@PutBoot:
  0015c	89 54 37 04	 mov	 DWORD PTR [edi+esi+4], edx
$LN4@PutBoot:

; 219  : 	}
; 220  : 	cnt += 8;
; 221  : 
; 222  : 	memset (boot + cnt, 0, ft->size_fat==32 ? 420:448);	/* boot code */

  00160	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  00163	83 e9 20	 sub	 ecx, 32			; 00000020H
  00166	83 c7 08	 add	 edi, 8
  00169	f7 d9		 neg	 ecx
  0016b	1b c9		 sbb	 ecx, ecx
  0016d	83 e1 1c	 and	 ecx, 28			; 0000001cH
  00170	81 c1 a4 01 00
	00		 add	 ecx, 420		; 000001a4H
  00176	51		 push	 ecx
  00177	50		 push	 eax
  00178	8d 14 37	 lea	 edx, DWORD PTR [edi+esi]
  0017b	52		 push	 edx
  0017c	e8 00 00 00 00	 call	 _memset

; 223  : 	cnt += ft->size_fat==32 ? 420:448;

  00181	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  00184	83 e8 20	 sub	 eax, 32			; 00000020H
  00187	83 c4 0c	 add	 esp, 12			; 0000000cH
  0018a	f7 d8		 neg	 eax
  0018c	1b c0		 sbb	 eax, eax
  0018e	83 e0 1c	 and	 eax, 28			; 0000001cH
  00191	05 a4 01 00 00	 add	 eax, 420		; 000001a4H
  00196	03 f8		 add	 edi, eax

; 224  : 	boot[cnt++] = 0x55;

  00198	c6 04 37 55	 mov	 BYTE PTR [edi+esi], 85	; 00000055H

; 225  : 	boot[cnt++] = 0xaa;	/* boot sig */

  0019c	c6 44 37 01 aa	 mov	 BYTE PTR [edi+esi+1], 170 ; 000000aaH
  001a1	5f		 pop	 edi
  001a2	5e		 pop	 esi
  001a3	5b		 pop	 ebx

; 226  : }

  001a4	c3		 ret	 0
_PutBoot ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _PutFSInfo
_TEXT	SEGMENT
_PutFSInfo PROC						; COMDAT
; _sector$ = esi
; _ft$ = edi

; 232  : 	memset (sector, 0, ft->sector_size);

  00000	0f b7 47 32	 movzx	 eax, WORD PTR [edi+50]
  00004	50		 push	 eax
  00005	6a 00		 push	 0
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 _memset

; 233  : 	sector[3]=0x41; /* LeadSig */
; 234  : 	sector[2]=0x61; 

  0000d	b0 61		 mov	 al, 97			; 00000061H
  0000f	88 46 02	 mov	 BYTE PTR [esi+2], al

; 235  : 	sector[1]=0x52; 
; 236  : 	sector[0]=0x52; 
; 237  : 	sector[484+3]=0x61; /* StrucSig */

  00012	88 86 e7 01 00
	00		 mov	 BYTE PTR [esi+487], al
  00018	b1 41		 mov	 cl, 65			; 00000041H

; 238  : 	sector[484+2]=0x41; 
; 239  : 	sector[484+1]=0x72; 

  0001a	b0 72		 mov	 al, 114			; 00000072H
  0001c	88 86 e5 01 00
	00		 mov	 BYTE PTR [esi+485], al

; 240  : 	sector[484+0]=0x72; 

  00022	88 86 e4 01 00
	00		 mov	 BYTE PTR [esi+484], al
  00028	88 4e 03	 mov	 BYTE PTR [esi+3], cl
  0002b	c6 46 01 52	 mov	 BYTE PTR [esi+1], 82	; 00000052H
  0002f	c6 06 52	 mov	 BYTE PTR [esi], 82	; 00000052H
  00032	88 8e e6 01 00
	00		 mov	 BYTE PTR [esi+486], cl

; 241  : 
; 242  : 	// Free cluster count
; 243  : 	*(uint32 *)(sector + 488) = LE32 (ft->cluster_count - ft->size_root_dir / ft->sector_size / ft->cluster_size);

  00038	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  0003b	0f b7 4f 32	 movzx	 ecx, WORD PTR [edi+50]
  0003f	99		 cdq
  00040	f7 f9		 idiv	 ecx
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
  00045	99		 cdq
  00046	f7 7f 28	 idiv	 DWORD PTR [edi+40]
  00049	8b 57 14	 mov	 edx, DWORD PTR [edi+20]

; 244  : 
; 245  : 	// Next free cluster
; 246  : 	*(uint32 *)(sector + 492) = LE32 (2);

  0004c	c7 86 ec 01 00
	00 02 00 00 00	 mov	 DWORD PTR [esi+492], 2

; 247  : 
; 248  : 	sector[508+3]=0xaa; /* TrailSig */

  00056	c6 86 ff 01 00
	00 aa		 mov	 BYTE PTR [esi+511], 170	; 000000aaH

; 249  : 	sector[508+2]=0x55;

  0005d	c6 86 fe 01 00
	00 55		 mov	 BYTE PTR [esi+510], 85	; 00000055H

; 250  : 	sector[508+1]=0x00;

  00064	c6 86 fd 01 00
	00 00		 mov	 BYTE PTR [esi+509], 0

; 251  : 	sector[508+0]=0x00;

  0006b	c6 86 fc 01 00
	00 00		 mov	 BYTE PTR [esi+508], 0
  00072	2b d0		 sub	 edx, eax
  00074	89 96 e8 01 00
	00		 mov	 DWORD PTR [esi+488], edx

; 252  : }

  0007a	c3		 ret	 0
_PutFSInfo ENDP
_TEXT	ENDS
PUBLIC	_cryptoInfo$GSCopy$
PUBLIC	_dev$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_FormatFat
EXTRN	_free:PROC
EXTRN	_UpdateProgressBar:PROC
EXTRN	_EAInitMode:PROC
EXTRN	_EAInit:PROC
EXTRN	_EAGetKeySize:PROC
EXTRN	_FlushFormatWriteBuffer:PROC
EXTRN	_WriteSector:PROC
EXTRN	_RandgetBytes:PROC
EXTRN	_malloc:PROC
EXTRN	_FormatWriteBufferSize:DWORD
EXTRN	__imp__SetFilePointerEx@20:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
; Function compile flags: /Ogtpy
;	COMDAT _FormatFat
_TEXT	SEGMENT
_write_buf_cnt$ = -4404					; size = 4
_cryptoInfo$GSCopy$ = -4400				; size = 4
_nSecNo$ = -4396					; size = 8
_dev$GSCopy$ = -4388					; size = 4
_write_buf$ = -4384					; size = 4
_startOffset$ = -4384					; size = 8
_newOffset$ = -4376					; size = 8
tv638 = -4368						; size = 8
_fat_sig$79192 = -4368					; size = 12
_temporaryKey$ = -4356					; size = 256
_sector$ = -4100					; size = 4096
__$ArrayPad$ = -4					; size = 4
_startSector$ = 8					; size = 8
_ft$ = 16						; size = 4
_dev$ = 20						; size = 4
_cryptoInfo$ = 24					; size = 4
_quickFormat$ = 28					; size = 4
_FormatFat PROC						; COMDAT

; 257  : {

  00000	b8 34 11 00 00	 mov	 eax, 4404		; 00001134H
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000f	33 c4		 xor	 eax, esp
  00011	89 84 24 30 11
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+4404], eax

; 437  : 	burn (temporaryKey, sizeof(temporaryKey));

  00018	8b 84 24 44 11
	00 00		 mov	 eax, DWORD PTR _dev$[esp+4400]
  0001f	8b 8c 24 48 11
	00 00		 mov	 ecx, DWORD PTR _cryptoInfo$[esp+4400]
  00026	53		 push	 ebx
  00027	8b 9c 24 3c 11
	00 00		 mov	 ebx, DWORD PTR _startSector$[esp+4404]
  0002e	55		 push	 ebp
  0002f	8b ac 24 44 11
	00 00		 mov	 ebp, DWORD PTR _startSector$[esp+4412]
  00036	56		 push	 esi
  00037	57		 push	 edi
  00038	8b bc 24 50 11
	00 00		 mov	 edi, DWORD PTR _ft$[esp+4416]
  0003f	89 44 24 20	 mov	 DWORD PTR _dev$GSCopy$[esp+4420], eax
  00043	0f b7 47 32	 movzx	 eax, WORD PTR [edi+50]
  00047	55		 push	 ebp
  00048	99		 cdq
  00049	53		 push	 ebx
  0004a	52		 push	 edx
  0004b	50		 push	 eax
  0004c	89 4c 24 24	 mov	 DWORD PTR _cryptoInfo$GSCopy$[esp+4436], ecx
  00050	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _write_buf_cnt$[esp+4436], 0
  00058	89 5c 24 28	 mov	 DWORD PTR _nSecNo$[esp+4436], ebx
  0005c	89 6c 24 2c	 mov	 DWORD PTR _nSecNo$[esp+4440], ebp
  00060	e8 00 00 00 00	 call	 __allmul
  00065	8b 4c 24 20	 mov	 ecx, DWORD PTR _dev$GSCopy$[esp+4420]
  00069	6a 00		 push	 0
  0006b	8b f0		 mov	 esi, eax
  0006d	8d 44 24 30	 lea	 eax, DWORD PTR _newOffset$[esp+4424]
  00071	50		 push	 eax
  00072	52		 push	 edx
  00073	56		 push	 esi
  00074	51		 push	 ecx
  00075	89 54 24 3c	 mov	 DWORD PTR _startOffset$[esp+4444], edx
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  0007f	85 c0		 test	 eax, eax
  00081	0f 84 f7 05 00
	00		 je	 $LN61@FormatFat
  00087	8b 54 24 2c	 mov	 edx, DWORD PTR _newOffset$[esp+4420]
  0008b	3b d6		 cmp	 edx, esi
  0008d	0f 85 eb 05 00
	00		 jne	 $LN61@FormatFat
  00093	8b 44 24 30	 mov	 eax, DWORD PTR _newOffset$[esp+4424]
  00097	3b 44 24 28	 cmp	 eax, DWORD PTR _startOffset$[esp+4424]
  0009b	0f 85 dd 05 00
	00		 jne	 $LN61@FormatFat
  000a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _FormatWriteBufferSize
  000a7	51		 push	 ecx
  000a8	e8 00 00 00 00	 call	 _malloc
  000ad	8b f0		 mov	 esi, eax
  000af	83 c4 04	 add	 esp, 4
  000b2	89 74 24 24	 mov	 DWORD PTR _write_buf$[esp+4420], esi
  000b6	85 f6		 test	 esi, esi
  000b8	75 08		 jne	 SHORT $LN60@FormatFat

; 274  : 	}
; 275  : 
; 276  : 	/* Write the data area */
; 277  : 
; 278  : 	write_buf = (char *)TCalloc (FormatWriteBufferSize);
; 279  : 	if (!write_buf)
; 280  : 		return ERR_OUTOFMEMORY;

  000ba	8d 46 02	 lea	 eax, DWORD PTR [esi+2]
  000bd	e9 c1 05 00 00	 jmp	 $LN63@FormatFat
$LN60@FormatFat:

; 281  : 
; 282  : 	memset (sector, 0, ft->sector_size);

  000c2	0f b7 57 32	 movzx	 edx, WORD PTR [edi+50]
  000c6	52		 push	 edx
  000c7	8d 84 24 44 01
	00 00		 lea	 eax, DWORD PTR _sector$[esp+4424]
  000ce	6a 00		 push	 0
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 _memset

; 283  : 
; 284  : 	RandgetBytes (ft->volume_id, sizeof (ft->volume_id), FALSE);

  000d6	6a 00		 push	 0
  000d8	8d 4f 0b	 lea	 ecx, DWORD PTR [edi+11]
  000db	6a 04		 push	 4
  000dd	51		 push	 ecx
  000de	e8 00 00 00 00	 call	 _RandgetBytes

; 285  : 
; 286  : 	PutBoot (ft, (unsigned char *) sector);

  000e3	8d 94 24 58 01
	00 00		 lea	 edx, DWORD PTR _sector$[esp+4444]
  000ea	52		 push	 edx
  000eb	57		 push	 edi
  000ec	e8 00 00 00 00	 call	 _PutBoot

; 287  : 	if (WriteSector (dev, sector, write_buf, &write_buf_cnt, &nSecNo,
; 288  : 		cryptoInfo) == FALSE)

  000f1	8b 44 24 34	 mov	 eax, DWORD PTR _cryptoInfo$GSCopy$[esp+4452]
  000f5	50		 push	 eax
  000f6	8d 4c 24 3c	 lea	 ecx, DWORD PTR _nSecNo$[esp+4456]
  000fa	51		 push	 ecx
  000fb	8b 4c 24 48	 mov	 ecx, DWORD PTR _dev$GSCopy$[esp+4460]
  000ff	8d 54 24 38	 lea	 edx, DWORD PTR _write_buf_cnt$[esp+4460]
  00103	52		 push	 edx
  00104	56		 push	 esi
  00105	8d 84 24 70 01
	00 00		 lea	 eax, DWORD PTR _sector$[esp+4468]
  0010c	50		 push	 eax
  0010d	51		 push	 ecx
  0010e	e8 00 00 00 00	 call	 _WriteSector
  00113	83 c4 38	 add	 esp, 56			; 00000038H
  00116	85 c0		 test	 eax, eax
  00118	0f 84 f4 04 00
	00		 je	 $fail$79168

; 289  : 		goto fail;
; 290  : 
; 291  : 	/* fat32 boot area */
; 292  : 	if (ft->size_fat == 32)				

  0011e	83 7f 1c 20	 cmp	 DWORD PTR [edi+28], 32	; 00000020H
  00122	0f 85 47 01 00
	00		 jne	 $LN82@FormatFat

; 293  : 	{
; 294  : 		/* fsinfo */
; 295  : 		PutFSInfo((unsigned char *) sector, ft);

  00128	8d b4 24 40 01
	00 00		 lea	 esi, DWORD PTR _sector$[esp+4420]
  0012f	e8 00 00 00 00	 call	 _PutFSInfo

; 296  : 		if (WriteSector (dev, sector, write_buf, &write_buf_cnt, &nSecNo,
; 297  : 			cryptoInfo) == FALSE)

  00134	8b 54 24 14	 mov	 edx, DWORD PTR _cryptoInfo$GSCopy$[esp+4420]
  00138	52		 push	 edx
  00139	8b 54 24 28	 mov	 edx, DWORD PTR _write_buf$[esp+4424]
  0013d	8d 44 24 1c	 lea	 eax, DWORD PTR _nSecNo$[esp+4424]
  00141	50		 push	 eax
  00142	8d 4c 24 18	 lea	 ecx, DWORD PTR _write_buf_cnt$[esp+4428]
  00146	51		 push	 ecx
  00147	52		 push	 edx
  00148	8b c6		 mov	 eax, esi
  0014a	8b 74 24 30	 mov	 esi, DWORD PTR _dev$GSCopy$[esp+4436]
  0014e	50		 push	 eax
  0014f	56		 push	 esi
  00150	e8 00 00 00 00	 call	 _WriteSector
  00155	83 c4 18	 add	 esp, 24			; 00000018H
  00158	85 c0		 test	 eax, eax
  0015a	0f 84 b2 04 00
	00		 je	 $fail$79168

; 298  : 			goto fail;
; 299  : 
; 300  : 		/* reserved */
; 301  : 		while (nSecNo - startSector < 6)

  00160	8b 4c 24 18	 mov	 ecx, DWORD PTR _nSecNo$[esp+4420]
  00164	8b 44 24 1c	 mov	 eax, DWORD PTR _nSecNo$[esp+4424]
  00168	2b cb		 sub	 ecx, ebx
  0016a	1b c5		 sbb	 eax, ebp
  0016c	85 c0		 test	 eax, eax
  0016e	77 78		 ja	 SHORT $LN147@FormatFat
  00170	72 0e		 jb	 SHORT $LL56@FormatFat
  00172	83 f9 06	 cmp	 ecx, 6
  00175	73 71		 jae	 SHORT $LN147@FormatFat
  00177	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL56@FormatFat:

; 302  : 		{
; 303  : 			memset (sector, 0, ft->sector_size);

  00180	0f b7 4f 32	 movzx	 ecx, WORD PTR [edi+50]
  00184	51		 push	 ecx
  00185	8d 94 24 44 01
	00 00		 lea	 edx, DWORD PTR _sector$[esp+4424]
  0018c	6a 00		 push	 0
  0018e	52		 push	 edx
  0018f	e8 00 00 00 00	 call	 _memset

; 304  : 			sector[508+3]=0xaa; /* TrailSig */
; 305  : 			sector[508+2]=0x55;
; 306  : 			if (WriteSector (dev, sector, write_buf, &write_buf_cnt, &nSecNo,
; 307  : 				cryptoInfo) == FALSE)

  00194	8b 44 24 20	 mov	 eax, DWORD PTR _cryptoInfo$GSCopy$[esp+4432]
  00198	50		 push	 eax
  00199	8b 44 24 34	 mov	 eax, DWORD PTR _write_buf$[esp+4436]
  0019d	8d 4c 24 28	 lea	 ecx, DWORD PTR _nSecNo$[esp+4436]
  001a1	51		 push	 ecx
  001a2	8d 54 24 24	 lea	 edx, DWORD PTR _write_buf_cnt$[esp+4440]
  001a6	52		 push	 edx
  001a7	50		 push	 eax
  001a8	8d 8c 24 5c 01
	00 00		 lea	 ecx, DWORD PTR _sector$[esp+4448]
  001af	51		 push	 ecx
  001b0	56		 push	 esi
  001b1	c6 84 24 63 03
	00 00 aa	 mov	 BYTE PTR _sector$[esp+4967], -86 ; ffffffaaH
  001b9	c6 84 24 62 03
	00 00 55	 mov	 BYTE PTR _sector$[esp+4966], 85 ; 00000055H
  001c1	e8 00 00 00 00	 call	 _WriteSector
  001c6	83 c4 24	 add	 esp, 36			; 00000024H
  001c9	85 c0		 test	 eax, eax
  001cb	0f 84 41 04 00
	00		 je	 $fail$79168
  001d1	8b 44 24 18	 mov	 eax, DWORD PTR _nSecNo$[esp+4420]
  001d5	8b 54 24 1c	 mov	 edx, DWORD PTR _nSecNo$[esp+4424]
  001d9	2b c3		 sub	 eax, ebx
  001db	1b d5		 sbb	 edx, ebp
  001dd	89 54 24 38	 mov	 DWORD PTR tv638[esp+4424], edx
  001e1	75 05		 jne	 SHORT $LN147@FormatFat

; 298  : 			goto fail;
; 299  : 
; 300  : 		/* reserved */
; 301  : 		while (nSecNo - startSector < 6)

  001e3	83 f8 06	 cmp	 eax, 6
  001e6	72 98		 jb	 SHORT $LL56@FormatFat
$LN147@FormatFat:

; 308  : 				goto fail;
; 309  : 		}
; 310  : 		
; 311  : 		/* bootsector backup */
; 312  : 		memset (sector, 0, ft->sector_size);

  001e8	0f b7 47 32	 movzx	 eax, WORD PTR [edi+50]
  001ec	50		 push	 eax
  001ed	8d 8c 24 44 01
	00 00		 lea	 ecx, DWORD PTR _sector$[esp+4424]
  001f4	6a 00		 push	 0
  001f6	51		 push	 ecx
  001f7	e8 00 00 00 00	 call	 _memset

; 313  : 		PutBoot (ft, (unsigned char *) sector);

  001fc	8d 94 24 4c 01
	00 00		 lea	 edx, DWORD PTR _sector$[esp+4432]
  00203	52		 push	 edx
  00204	57		 push	 edi
  00205	e8 00 00 00 00	 call	 _PutBoot

; 314  : 		if (WriteSector (dev, sector, write_buf, &write_buf_cnt, &nSecNo,
; 315  : 				 cryptoInfo) == FALSE)

  0020a	8b 44 24 28	 mov	 eax, DWORD PTR _cryptoInfo$GSCopy$[esp+4440]
  0020e	50		 push	 eax
  0020f	8b 44 24 3c	 mov	 eax, DWORD PTR _write_buf$[esp+4444]
  00213	8d 4c 24 30	 lea	 ecx, DWORD PTR _nSecNo$[esp+4444]
  00217	51		 push	 ecx
  00218	8d 54 24 2c	 lea	 edx, DWORD PTR _write_buf_cnt$[esp+4448]
  0021c	52		 push	 edx
  0021d	50		 push	 eax
  0021e	8d 8c 24 64 01
	00 00		 lea	 ecx, DWORD PTR _sector$[esp+4456]
  00225	51		 push	 ecx
  00226	56		 push	 esi
  00227	e8 00 00 00 00	 call	 _WriteSector
  0022c	83 c4 2c	 add	 esp, 44			; 0000002cH
  0022f	85 c0		 test	 eax, eax
  00231	0f 84 db 03 00
	00		 je	 $fail$79168

; 316  : 			goto fail;
; 317  : 
; 318  : 		PutFSInfo((unsigned char *) sector, ft);

  00237	8d b4 24 40 01
	00 00		 lea	 esi, DWORD PTR _sector$[esp+4420]
  0023e	e8 00 00 00 00	 call	 _PutFSInfo

; 319  : 		if (WriteSector (dev, sector, write_buf, &write_buf_cnt, &nSecNo,
; 320  : 			cryptoInfo) == FALSE)

  00243	8b 54 24 14	 mov	 edx, DWORD PTR _cryptoInfo$GSCopy$[esp+4420]
  00247	52		 push	 edx
  00248	8b 54 24 28	 mov	 edx, DWORD PTR _write_buf$[esp+4424]
  0024c	8d 44 24 1c	 lea	 eax, DWORD PTR _nSecNo$[esp+4424]
  00250	50		 push	 eax
  00251	8d 4c 24 18	 lea	 ecx, DWORD PTR _write_buf_cnt$[esp+4428]
  00255	51		 push	 ecx
  00256	8b 4c 24 2c	 mov	 ecx, DWORD PTR _dev$GSCopy$[esp+4432]
  0025a	52		 push	 edx
  0025b	8b c6		 mov	 eax, esi
  0025d	50		 push	 eax
  0025e	51		 push	 ecx
  0025f	e8 00 00 00 00	 call	 _WriteSector
  00264	83 c4 18	 add	 esp, 24			; 00000018H
  00267	85 c0		 test	 eax, eax
  00269	0f 84 a3 03 00
	00		 je	 $fail$79168
$LN82@FormatFat:

; 321  : 			goto fail;
; 322  : 	}
; 323  : 
; 324  : 	/* reserved */
; 325  : 	while (nSecNo - startSector < (unsigned int)ft->reserved)

  0026f	8b 4c 24 18	 mov	 ecx, DWORD PTR _nSecNo$[esp+4420]
  00273	8b 44 24 1c	 mov	 eax, DWORD PTR _nSecNo$[esp+4424]
  00277	0f bf 77 38	 movsx	 esi, WORD PTR [edi+56]
  0027b	2b cb		 sub	 ecx, ebx
  0027d	1b c5		 sbb	 eax, ebp
  0027f	33 d2		 xor	 edx, edx
  00281	3b c2		 cmp	 eax, edx
  00283	77 6c		 ja	 SHORT $LN149@FormatFat
  00285	72 09		 jb	 SHORT $LL51@FormatFat
  00287	3b ce		 cmp	 ecx, esi
  00289	73 66		 jae	 SHORT $LN149@FormatFat
  0028b	eb 03 8d 49 00	 npad	 5
$LL51@FormatFat:

; 326  : 	{
; 327  : 		memset (sector, 0, ft->sector_size);

  00290	0f b7 57 32	 movzx	 edx, WORD PTR [edi+50]
  00294	52		 push	 edx
  00295	8d 84 24 44 01
	00 00		 lea	 eax, DWORD PTR _sector$[esp+4424]
  0029c	6a 00		 push	 0
  0029e	50		 push	 eax
  0029f	e8 00 00 00 00	 call	 _memset

; 328  : 		if (WriteSector (dev, sector, write_buf, &write_buf_cnt, &nSecNo,
; 329  : 			cryptoInfo) == FALSE)

  002a4	8b 4c 24 20	 mov	 ecx, DWORD PTR _cryptoInfo$GSCopy$[esp+4432]
  002a8	51		 push	 ecx
  002a9	8b 4c 24 34	 mov	 ecx, DWORD PTR _write_buf$[esp+4436]
  002ad	8d 54 24 28	 lea	 edx, DWORD PTR _nSecNo$[esp+4436]
  002b1	52		 push	 edx
  002b2	8d 44 24 24	 lea	 eax, DWORD PTR _write_buf_cnt$[esp+4440]
  002b6	50		 push	 eax
  002b7	8b 44 24 38	 mov	 eax, DWORD PTR _dev$GSCopy$[esp+4444]
  002bb	51		 push	 ecx
  002bc	8d 94 24 5c 01
	00 00		 lea	 edx, DWORD PTR _sector$[esp+4448]
  002c3	52		 push	 edx
  002c4	50		 push	 eax
  002c5	e8 00 00 00 00	 call	 _WriteSector
  002ca	83 c4 24	 add	 esp, 36			; 00000024H
  002cd	85 c0		 test	 eax, eax
  002cf	0f 84 3d 03 00
	00		 je	 $fail$79168
  002d5	8b 4c 24 18	 mov	 ecx, DWORD PTR _nSecNo$[esp+4420]
  002d9	8b 44 24 1c	 mov	 eax, DWORD PTR _nSecNo$[esp+4424]
  002dd	0f bf 77 38	 movsx	 esi, WORD PTR [edi+56]
  002e1	2b cb		 sub	 ecx, ebx
  002e3	1b c5		 sbb	 eax, ebp
  002e5	33 d2		 xor	 edx, edx
  002e7	3b c2		 cmp	 eax, edx
  002e9	72 a5		 jb	 SHORT $LL51@FormatFat

; 321  : 			goto fail;
; 322  : 	}
; 323  : 
; 324  : 	/* reserved */
; 325  : 	while (nSecNo - startSector < (unsigned int)ft->reserved)

  002eb	77 04		 ja	 SHORT $LN149@FormatFat
  002ed	3b ce		 cmp	 ecx, esi
  002ef	72 9f		 jb	 SHORT $LL51@FormatFat
$LN149@FormatFat:

; 330  : 			goto fail;
; 331  : 	}
; 332  : 
; 333  : 	/* write fat */
; 334  : 	for (x = 1; x <= ft->fats; x++)

  002f1	bd 01 00 00 00	 mov	 ebp, 1
  002f6	39 6f 20	 cmp	 DWORD PTR [edi+32], ebp
  002f9	0f 8c 0c 01 00
	00		 jl	 $LN157@FormatFat
  002ff	b3 ff		 mov	 bl, 255			; 000000ffH
$LL48@FormatFat:

; 335  : 	{
; 336  : 		for (n = 0; n < ft->fat_length; n++)

  00301	33 f6		 xor	 esi, esi
  00303	39 77 2c	 cmp	 DWORD PTR [edi+44], esi
  00306	0f 8e f5 00 00
	00		 jle	 $LN47@FormatFat
  0030c	8d 64 24 00	 npad	 4
$LL160@FormatFat:

; 337  : 		{
; 338  : 			memset (sector, 0, ft->sector_size);

  00310	0f b7 4f 32	 movzx	 ecx, WORD PTR [edi+50]
  00314	51		 push	 ecx
  00315	8d 94 24 44 01
	00 00		 lea	 edx, DWORD PTR _sector$[esp+4424]
  0031c	6a 00		 push	 0
  0031e	52		 push	 edx
  0031f	e8 00 00 00 00	 call	 _memset
  00324	83 c4 0c	 add	 esp, 12			; 0000000cH

; 339  : 
; 340  : 			if (n == 0)

  00327	85 f6		 test	 esi, esi
  00329	0f 85 97 00 00
	00		 jne	 $LN37@FormatFat

; 341  : 			{
; 342  : 				unsigned char fat_sig[12];
; 343  : 				if (ft->size_fat == 32)

  0032f	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00332	83 f8 20	 cmp	 eax, 32			; 00000020H
  00335	75 46		 jne	 SHORT $LN41@FormatFat

; 344  : 				{
; 345  : 					fat_sig[0] = (unsigned char) ft->media;

  00337	8a 47 24	 mov	 al, BYTE PTR [edi+36]
  0033a	88 44 24 34	 mov	 BYTE PTR _fat_sig$79192[esp+4420], al

; 346  : 					fat_sig[1] = fat_sig[2] = 0xff;
; 347  : 					fat_sig[3] = 0x0f;
; 348  : 					fat_sig[4] = fat_sig[5] = fat_sig[6] = 0xff;

  0033e	88 5c 24 3a	 mov	 BYTE PTR _fat_sig$79192[esp+4426], bl
  00342	88 5c 24 39	 mov	 BYTE PTR _fat_sig$79192[esp+4425], bl
  00346	88 5c 24 38	 mov	 BYTE PTR _fat_sig$79192[esp+4424], bl

; 349  : 					fat_sig[7] = 0x0f;

  0034a	c6 44 24 3b 0f	 mov	 BYTE PTR _fat_sig$79192[esp+4427], 15 ; 0000000fH

; 350  : 					fat_sig[8] = fat_sig[9] = fat_sig[10] = 0xff;
; 351  : 					fat_sig[11] = 0x0f;
; 352  : 					memcpy (sector, fat_sig, 12);

  0034f	8b 54 24 38	 mov	 edx, DWORD PTR _fat_sig$79192[esp+4424]
  00353	88 5c 24 3e	 mov	 BYTE PTR _fat_sig$79192[esp+4430], bl
  00357	88 5c 24 3d	 mov	 BYTE PTR _fat_sig$79192[esp+4429], bl
  0035b	88 5c 24 3c	 mov	 BYTE PTR _fat_sig$79192[esp+4428], bl
  0035f	c6 44 24 3f 0f	 mov	 BYTE PTR _fat_sig$79192[esp+4431], 15 ; 0000000fH
  00364	8b 44 24 3c	 mov	 eax, DWORD PTR _fat_sig$79192[esp+4428]
  00368	c6 44 24 37 0f	 mov	 BYTE PTR _fat_sig$79192[esp+4423], 15 ; 0000000fH
  0036d	89 94 24 44 01
	00 00		 mov	 DWORD PTR _sector$[esp+4424], edx
  00374	89 84 24 48 01
	00 00		 mov	 DWORD PTR _sector$[esp+4428], eax
  0037b	eb 36		 jmp	 SHORT $LN177@FormatFat
$LN41@FormatFat:

; 353  : 				}				
; 354  : 				else if (ft->size_fat == 16)

  0037d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00380	75 20		 jne	 SHORT $LN39@FormatFat

; 355  : 				{
; 356  : 					fat_sig[0] = (unsigned char) ft->media;

  00382	8a 4f 24	 mov	 cl, BYTE PTR [edi+36]
  00385	88 4c 24 34	 mov	 BYTE PTR _fat_sig$79192[esp+4420], cl

; 357  : 					fat_sig[1] = 0xff;

  00389	88 5c 24 35	 mov	 BYTE PTR _fat_sig$79192[esp+4421], bl

; 358  : 					fat_sig[2] = 0xff;

  0038d	88 5c 24 36	 mov	 BYTE PTR _fat_sig$79192[esp+4422], bl

; 359  : 					fat_sig[3] = 0xff;

  00391	88 5c 24 37	 mov	 BYTE PTR _fat_sig$79192[esp+4423], bl

; 360  : 					memcpy (sector, fat_sig, 4);

  00395	8b 54 24 34	 mov	 edx, DWORD PTR _fat_sig$79192[esp+4420]
  00399	89 94 24 40 01
	00 00		 mov	 DWORD PTR _sector$[esp+4420], edx
  003a0	eb 24		 jmp	 SHORT $LN37@FormatFat
$LN39@FormatFat:

; 361  : 				}
; 362  : 				else if (ft->size_fat == 12)

  003a2	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  003a5	75 1f		 jne	 SHORT $LN37@FormatFat

; 363  : 				{
; 364  : 					fat_sig[0] = (unsigned char) ft->media;

  003a7	8a 47 24	 mov	 al, BYTE PTR [edi+36]
  003aa	88 44 24 34	 mov	 BYTE PTR _fat_sig$79192[esp+4420], al

; 365  : 					fat_sig[1] = 0xff;
; 366  : 					fat_sig[2] = 0xff;
; 367  : 					fat_sig[3] = 0x00;

  003ae	c6 44 24 37 00	 mov	 BYTE PTR _fat_sig$79192[esp+4423], 0
$LN177@FormatFat:
  003b3	88 5c 24 35	 mov	 BYTE PTR _fat_sig$79192[esp+4421], bl
  003b7	88 5c 24 36	 mov	 BYTE PTR _fat_sig$79192[esp+4422], bl

; 368  : 					memcpy (sector, fat_sig, 4);

  003bb	8b 4c 24 34	 mov	 ecx, DWORD PTR _fat_sig$79192[esp+4420]
  003bf	89 8c 24 40 01
	00 00		 mov	 DWORD PTR _sector$[esp+4420], ecx
$LN37@FormatFat:

; 369  : 				}
; 370  : 			}
; 371  : 
; 372  : 			if (WriteSector (dev, sector, write_buf, &write_buf_cnt, &nSecNo,
; 373  : 				    cryptoInfo) == FALSE)

  003c6	8b 54 24 14	 mov	 edx, DWORD PTR _cryptoInfo$GSCopy$[esp+4420]
  003ca	52		 push	 edx
  003cb	8b 54 24 28	 mov	 edx, DWORD PTR _write_buf$[esp+4424]
  003cf	8d 44 24 1c	 lea	 eax, DWORD PTR _nSecNo$[esp+4424]
  003d3	50		 push	 eax
  003d4	8d 4c 24 18	 lea	 ecx, DWORD PTR _write_buf_cnt$[esp+4428]
  003d8	51		 push	 ecx
  003d9	8b 4c 24 2c	 mov	 ecx, DWORD PTR _dev$GSCopy$[esp+4432]
  003dd	52		 push	 edx
  003de	8d 84 24 50 01
	00 00		 lea	 eax, DWORD PTR _sector$[esp+4436]
  003e5	50		 push	 eax
  003e6	51		 push	 ecx
  003e7	e8 00 00 00 00	 call	 _WriteSector
  003ec	83 c4 18	 add	 esp, 24			; 00000018H
  003ef	85 c0		 test	 eax, eax
  003f1	0f 84 1b 02 00
	00		 je	 $fail$79168
  003f7	46		 inc	 esi
  003f8	3b 77 2c	 cmp	 esi, DWORD PTR [edi+44]
  003fb	0f 8c 0f ff ff
	ff		 jl	 $LL160@FormatFat
$LN47@FormatFat:

; 330  : 			goto fail;
; 331  : 	}
; 332  : 
; 333  : 	/* write fat */
; 334  : 	for (x = 1; x <= ft->fats; x++)

  00401	45		 inc	 ebp
  00402	3b 6f 20	 cmp	 ebp, DWORD PTR [edi+32]
  00405	0f 8e f6 fe ff
	ff		 jle	 $LL48@FormatFat
$LN157@FormatFat:

; 374  : 				goto fail;
; 375  : 		}
; 376  : 	}
; 377  : 
; 378  : 
; 379  : 	/* write rootdir */
; 380  : 	for (x = 0; x < ft->size_root_dir / ft->sector_size; x++)

  0040b	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  0040e	0f b7 4f 32	 movzx	 ecx, WORD PTR [edi+50]
  00412	99		 cdq
  00413	f7 f9		 idiv	 ecx
  00415	33 db		 xor	 ebx, ebx
  00417	85 c0		 test	 eax, eax
  00419	7e 57		 jle	 SHORT $LN158@FormatFat
  0041b	eb 03 8d 49 00	 npad	 5
$LL35@FormatFat:

; 381  : 	{
; 382  : 		memset (sector, 0, ft->sector_size);

  00420	51		 push	 ecx
  00421	8d 94 24 44 01
	00 00		 lea	 edx, DWORD PTR _sector$[esp+4424]
  00428	6a 00		 push	 0
  0042a	52		 push	 edx
  0042b	e8 00 00 00 00	 call	 _memset

; 383  : 		if (WriteSector (dev, sector, write_buf, &write_buf_cnt, &nSecNo,
; 384  : 				 cryptoInfo) == FALSE)

  00430	8b 74 24 20	 mov	 esi, DWORD PTR _cryptoInfo$GSCopy$[esp+4432]
  00434	8b 54 24 30	 mov	 edx, DWORD PTR _write_buf$[esp+4432]
  00438	56		 push	 esi
  00439	8d 44 24 28	 lea	 eax, DWORD PTR _nSecNo$[esp+4436]
  0043d	50		 push	 eax
  0043e	8d 4c 24 24	 lea	 ecx, DWORD PTR _write_buf_cnt$[esp+4440]
  00442	51		 push	 ecx
  00443	8b 4c 24 38	 mov	 ecx, DWORD PTR _dev$GSCopy$[esp+4444]
  00447	52		 push	 edx
  00448	8d 84 24 5c 01
	00 00		 lea	 eax, DWORD PTR _sector$[esp+4448]
  0044f	50		 push	 eax
  00450	51		 push	 ecx
  00451	e8 00 00 00 00	 call	 _WriteSector
  00456	83 c4 24	 add	 esp, 36			; 00000024H
  00459	85 c0		 test	 eax, eax
  0045b	0f 84 b1 01 00
	00		 je	 $fail$79168
  00461	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00464	0f b7 4f 32	 movzx	 ecx, WORD PTR [edi+50]
  00468	99		 cdq
  00469	f7 f9		 idiv	 ecx
  0046b	43		 inc	 ebx
  0046c	3b d8		 cmp	 ebx, eax
  0046e	7c b0		 jl	 SHORT $LL35@FormatFat

; 374  : 				goto fail;
; 375  : 		}
; 376  : 	}
; 377  : 
; 378  : 
; 379  : 	/* write rootdir */
; 380  : 	for (x = 0; x < ft->size_root_dir / ft->sector_size; x++)

  00470	eb 04		 jmp	 SHORT $LN33@FormatFat
$LN158@FormatFat:
  00472	8b 74 24 14	 mov	 esi, DWORD PTR _cryptoInfo$GSCopy$[esp+4420]
$LN33@FormatFat:

; 385  : 			goto fail;
; 386  : 
; 387  : 	}
; 388  : 
; 389  : 	/* Fill the rest of the data area with random data */
; 390  : 
; 391  : 	if(!quickFormat)

  00476	83 bc 24 5c 11
	00 00 00	 cmp	 DWORD PTR _quickFormat$[esp+4416], 0
  0047e	0f 85 51 01 00
	00		 jne	 $LN31@FormatFat

; 392  : 	{
; 393  : 		if (!FlushFormatWriteBuffer (dev, write_buf, &write_buf_cnt, &nSecNo, cryptoInfo))

  00484	8b 4c 24 24	 mov	 ecx, DWORD PTR _write_buf$[esp+4420]
  00488	56		 push	 esi
  00489	8d 54 24 1c	 lea	 edx, DWORD PTR _nSecNo$[esp+4424]
  0048d	52		 push	 edx
  0048e	8b 54 24 28	 mov	 edx, DWORD PTR _dev$GSCopy$[esp+4428]
  00492	8d 44 24 18	 lea	 eax, DWORD PTR _write_buf_cnt$[esp+4428]
  00496	50		 push	 eax
  00497	51		 push	 ecx
  00498	52		 push	 edx
  00499	e8 00 00 00 00	 call	 _FlushFormatWriteBuffer
  0049e	83 c4 14	 add	 esp, 20			; 00000014H
  004a1	85 c0		 test	 eax, eax
  004a3	0f 84 69 01 00
	00		 je	 $fail$79168

; 394  : 			goto fail;
; 395  : 
; 396  : 		/* Generate a random temporary key set to be used for "dummy" encryption that will fill
; 397  : 		the free disk space (data area) with random data.  This is necessary for plausible
; 398  : 		deniability of hidden volumes (and also reduces the amount of predictable plaintext
; 399  : 		within the volume). */
; 400  : 
; 401  : 		// Temporary master key
; 402  : 		if (!RandgetBytes (temporaryKey, EAGetKeySize (cryptoInfo->ea), FALSE))

  004a9	8b 06		 mov	 eax, DWORD PTR [esi]
  004ab	6a 00		 push	 0
  004ad	50		 push	 eax
  004ae	e8 00 00 00 00	 call	 _EAGetKeySize
  004b3	83 c4 04	 add	 esp, 4
  004b6	50		 push	 eax
  004b7	8d 4c 24 48	 lea	 ecx, DWORD PTR _temporaryKey$[esp+4428]
  004bb	51		 push	 ecx
  004bc	e8 00 00 00 00	 call	 _RandgetBytes
  004c1	83 c4 0c	 add	 esp, 12			; 0000000cH
  004c4	85 c0		 test	 eax, eax
  004c6	0f 84 46 01 00
	00		 je	 $fail$79168

; 403  : 			goto fail;
; 404  : 
; 405  : 		// Temporary secondary key (XTS mode)
; 406  : 		if (!RandgetBytes (cryptoInfo->k2, sizeof cryptoInfo->k2, FALSE))		

  004cc	6a 00		 push	 0
  004ce	8d 96 a8 42 00
	00		 lea	 edx, DWORD PTR [esi+17064]
  004d4	68 00 01 00 00	 push	 256			; 00000100H
  004d9	52		 push	 edx
  004da	e8 00 00 00 00	 call	 _RandgetBytes
  004df	83 c4 0c	 add	 esp, 12			; 0000000cH
  004e2	85 c0		 test	 eax, eax
  004e4	0f 84 28 01 00
	00		 je	 $fail$79168

; 407  : 			goto fail;
; 408  : 
; 409  : 		retVal = EAInit (cryptoInfo->ea, temporaryKey, cryptoInfo->ks);

  004ea	8b 16		 mov	 edx, DWORD PTR [esi]
  004ec	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  004ef	50		 push	 eax
  004f0	8d 4c 24 44	 lea	 ecx, DWORD PTR _temporaryKey$[esp+4424]
  004f4	51		 push	 ecx
  004f5	52		 push	 edx
  004f6	e8 00 00 00 00	 call	 _EAInit
  004fb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 410  : 		if (retVal != ERR_SUCCESS)

  004fe	85 c0		 test	 eax, eax
  00500	74 2c		 je	 SHORT $LN27@FormatFat

; 411  : 		{
; 412  : 			burn (temporaryKey, sizeof(temporaryKey));

  00502	8d 74 24 40	 lea	 esi, DWORD PTR _temporaryKey$[esp+4420]
  00506	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0050b	8b fa		 mov	 edi, edx
  0050d	8b ce		 mov	 ecx, esi
  0050f	90		 npad	 1
$LL66@FormatFat:
  00510	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00513	41		 inc	 ecx
  00514	83 ef 01	 sub	 edi, 1
  00517	75 f7		 jne	 SHORT $LL66@FormatFat
  00519	8d a4 24 00 00
	00 00		 npad	 7
$LL23@FormatFat:
  00520	4a		 dec	 edx
  00521	c6 06 00	 mov	 BYTE PTR [esi], 0
  00524	46		 inc	 esi
  00525	85 d2		 test	 edx, edx
  00527	75 f7		 jne	 SHORT $LL23@FormatFat

; 413  : 			return retVal;

  00529	e9 55 01 00 00	 jmp	 $LN63@FormatFat
$LN27@FormatFat:

; 414  : 		}
; 415  : 		if (!EAInitMode (cryptoInfo))

  0052e	56		 push	 esi
  0052f	e8 00 00 00 00	 call	 _EAInitMode
  00534	83 c4 04	 add	 esp, 4
  00537	85 c0		 test	 eax, eax
  00539	75 27		 jne	 SHORT $LN21@FormatFat

; 416  : 		{
; 417  : 			burn (temporaryKey, sizeof(temporaryKey));

  0053b	8d 54 24 40	 lea	 edx, DWORD PTR _temporaryKey$[esp+4420]
  0053f	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00544	8b f1		 mov	 esi, ecx
  00546	8b c2		 mov	 eax, edx
$LL70@FormatFat:
  00548	c6 00 00	 mov	 BYTE PTR [eax], 0
  0054b	40		 inc	 eax
  0054c	83 ee 01	 sub	 esi, 1
  0054f	75 f7		 jne	 SHORT $LL70@FormatFat
$LL17@FormatFat:
  00551	49		 dec	 ecx
  00552	c6 02 00	 mov	 BYTE PTR [edx], 0
  00555	42		 inc	 edx
  00556	85 c9		 test	 ecx, ecx
  00558	75 f7		 jne	 SHORT $LL17@FormatFat

; 418  : 			return ERR_MODE_INIT_FAILED;

  0055a	8d 41 1b	 lea	 eax, DWORD PTR [ecx+27]
  0055d	e9 21 01 00 00	 jmp	 $LN63@FormatFat
$LN21@FormatFat:

; 419  : 		}
; 420  : 
; 421  : 		x = ft->num_sectors - ft->reserved - ft->size_root_dir / ft->sector_size - ft->fat_length * 2;

  00562	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00565	0f b7 4f 32	 movzx	 ecx, WORD PTR [edi+50]
  00569	99		 cdq
  0056a	f7 f9		 idiv	 ecx
  0056c	8b 77 2c	 mov	 esi, DWORD PTR [edi+44]
  0056f	0f bf 57 38	 movsx	 edx, WORD PTR [edi+56]
  00573	f7 de		 neg	 esi
  00575	03 f6		 add	 esi, esi
  00577	2b f0		 sub	 esi, eax
  00579	03 77 10	 add	 esi, DWORD PTR [edi+16]
  0057c	2b f2		 sub	 esi, edx

; 422  : 		while (x--)

  0057e	74 32		 je	 SHORT $LN161@FormatFat
$LL15@FormatFat:

; 423  : 		{
; 424  : 			if (WriteSector (dev, sector, write_buf, &write_buf_cnt, &nSecNo,
; 425  : 				cryptoInfo) == FALSE)

  00580	8b 44 24 14	 mov	 eax, DWORD PTR _cryptoInfo$GSCopy$[esp+4420]
  00584	50		 push	 eax
  00585	8b 44 24 28	 mov	 eax, DWORD PTR _write_buf$[esp+4424]
  00589	8d 4c 24 1c	 lea	 ecx, DWORD PTR _nSecNo$[esp+4424]
  0058d	51		 push	 ecx
  0058e	8d 54 24 18	 lea	 edx, DWORD PTR _write_buf_cnt$[esp+4428]
  00592	52		 push	 edx
  00593	8b 54 24 2c	 mov	 edx, DWORD PTR _dev$GSCopy$[esp+4432]
  00597	50		 push	 eax
  00598	8d 8c 24 50 01
	00 00		 lea	 ecx, DWORD PTR _sector$[esp+4436]
  0059f	51		 push	 ecx
  005a0	52		 push	 edx
  005a1	4e		 dec	 esi
  005a2	e8 00 00 00 00	 call	 _WriteSector
  005a7	83 c4 18	 add	 esp, 24			; 00000018H
  005aa	85 c0		 test	 eax, eax
  005ac	74 64		 je	 SHORT $fail$79168

; 422  : 		while (x--)

  005ae	85 f6		 test	 esi, esi
  005b0	75 ce		 jne	 SHORT $LL15@FormatFat
$LN161@FormatFat:

; 426  : 				goto fail;
; 427  : 		}
; 428  : 		UpdateProgressBar (nSecNo * ft->sector_size);

  005b2	8b 4c 24 1c	 mov	 ecx, DWORD PTR _nSecNo$[esp+4424]
  005b6	0f b7 47 32	 movzx	 eax, WORD PTR [edi+50]
  005ba	51		 push	 ecx
  005bb	8b 4c 24 1c	 mov	 ecx, DWORD PTR _nSecNo$[esp+4424]
  005bf	99		 cdq
  005c0	51		 push	 ecx
  005c1	52		 push	 edx
  005c2	50		 push	 eax
  005c3	e8 00 00 00 00	 call	 __allmul
  005c8	52		 push	 edx
  005c9	50		 push	 eax
  005ca	e8 00 00 00 00	 call	 _UpdateProgressBar

; 429  : 	}
; 430  : 	else

  005cf	8b 74 24 1c	 mov	 esi, DWORD PTR _cryptoInfo$GSCopy$[esp+4428]
  005d3	eb 19		 jmp	 SHORT $LN178@FormatFat
$LN31@FormatFat:

; 431  : 		UpdateProgressBar ((uint64) ft->num_sectors * ft->sector_size);

  005d5	0f b7 47 32	 movzx	 eax, WORD PTR [edi+50]
  005d9	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  005dc	99		 cdq
  005dd	52		 push	 edx
  005de	50		 push	 eax
  005df	6a 00		 push	 0
  005e1	51		 push	 ecx
  005e2	e8 00 00 00 00	 call	 __allmul
  005e7	52		 push	 edx
  005e8	50		 push	 eax
  005e9	e8 00 00 00 00	 call	 _UpdateProgressBar
$LN178@FormatFat:

; 432  : 
; 433  : 	if (!FlushFormatWriteBuffer (dev, write_buf, &write_buf_cnt, &nSecNo, cryptoInfo))

  005ee	8b 4c 24 2c	 mov	 ecx, DWORD PTR _write_buf$[esp+4428]
  005f2	83 c4 08	 add	 esp, 8
  005f5	56		 push	 esi
  005f6	8d 54 24 1c	 lea	 edx, DWORD PTR _nSecNo$[esp+4424]
  005fa	52		 push	 edx
  005fb	8b 54 24 28	 mov	 edx, DWORD PTR _dev$GSCopy$[esp+4428]
  005ff	8d 44 24 18	 lea	 eax, DWORD PTR _write_buf_cnt$[esp+4428]
  00603	50		 push	 eax
  00604	51		 push	 ecx
  00605	52		 push	 edx
  00606	e8 00 00 00 00	 call	 _FlushFormatWriteBuffer
  0060b	83 c4 14	 add	 esp, 20			; 00000014H
  0060e	85 c0		 test	 eax, eax
  00610	75 3c		 jne	 SHORT $LN11@FormatFat
$fail$79168:

; 439  : 
; 440  : fail:
; 441  : 
; 442  : 	TCfree (write_buf);

  00612	8b 44 24 24	 mov	 eax, DWORD PTR _write_buf$[esp+4420]
  00616	50		 push	 eax
  00617	e8 00 00 00 00	 call	 _free

; 443  : 	burn (temporaryKey, sizeof(temporaryKey));

  0061c	8d 54 24 44	 lea	 edx, DWORD PTR _temporaryKey$[esp+4424]
  00620	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00625	83 c4 04	 add	 esp, 4
  00628	8b f1		 mov	 esi, ecx
  0062a	8b c2		 mov	 eax, edx
  0062c	8d 64 24 00	 npad	 4
$LL78@FormatFat:
  00630	c6 00 00	 mov	 BYTE PTR [eax], 0
  00633	40		 inc	 eax
  00634	83 ee 01	 sub	 esi, 1
  00637	75 f7		 jne	 SHORT $LL78@FormatFat
  00639	8d a4 24 00 00
	00 00		 npad	 7
$LL2@FormatFat:
  00640	49		 dec	 ecx
  00641	c6 02 00	 mov	 BYTE PTR [edx], 0
  00644	42		 inc	 edx
  00645	85 c9		 test	 ecx, ecx
  00647	75 f7		 jne	 SHORT $LL2@FormatFat

; 444  : 	return ERR_OS_ERROR;

  00649	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0064c	eb 35		 jmp	 SHORT $LN63@FormatFat
$LN11@FormatFat:

; 434  : 		goto fail;
; 435  : 
; 436  : 	TCfree (write_buf);

  0064e	8b 4c 24 24	 mov	 ecx, DWORD PTR _write_buf$[esp+4420]
  00652	51		 push	 ecx
  00653	e8 00 00 00 00	 call	 _free

; 437  : 	burn (temporaryKey, sizeof(temporaryKey));

  00658	8d 54 24 44	 lea	 edx, DWORD PTR _temporaryKey$[esp+4424]
  0065c	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00661	83 c4 04	 add	 esp, 4
  00664	8b f1		 mov	 esi, ecx
  00666	8b c2		 mov	 eax, edx
$LL74@FormatFat:
  00668	c6 00 00	 mov	 BYTE PTR [eax], 0
  0066b	40		 inc	 eax
  0066c	83 ee 01	 sub	 esi, 1
  0066f	75 f7		 jne	 SHORT $LL74@FormatFat
$LL7@FormatFat:
  00671	49		 dec	 ecx
  00672	c6 02 00	 mov	 BYTE PTR [edx], 0
  00675	42		 inc	 edx
  00676	85 c9		 test	 ecx, ecx
  00678	75 f7		 jne	 SHORT $LL7@FormatFat

; 438  : 	return 0;

  0067a	33 c0		 xor	 eax, eax
  0067c	eb 05		 jmp	 SHORT $LN63@FormatFat
$LN61@FormatFat:

; 258  : 	int write_buf_cnt = 0;
; 259  : 	char sector[TC_MAX_VOLUME_SECTOR_SIZE], *write_buf;
; 260  : 	unsigned __int64 nSecNo = startSector;
; 261  : 	int x, n;
; 262  : 	int retVal;
; 263  : 	char temporaryKey[MASTER_KEYDATA_SIZE];
; 264  : 
; 265  : 	LARGE_INTEGER startOffset;
; 266  : 	LARGE_INTEGER newOffset;
; 267  : 
; 268  : 	// Seek to start sector
; 269  : 	startOffset.QuadPart = startSector * ft->sector_size;
; 270  : 	if (!SetFilePointerEx ((HANDLE) dev, startOffset, &newOffset, FILE_BEGIN)
; 271  : 		|| newOffset.QuadPart != startOffset.QuadPart)
; 272  : 	{
; 273  : 		return ERR_VOL_SEEKING;

  0067e	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
$LN63@FormatFat:

; 445  : }

  00683	8b 8c 24 40 11
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+4420]
  0068a	5f		 pop	 edi
  0068b	5e		 pop	 esi
  0068c	5d		 pop	 ebp
  0068d	5b		 pop	 ebx
  0068e	33 cc		 xor	 ecx, esp
  00690	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00695	81 c4 34 11 00
	00		 add	 esp, 4404		; 00001134H
  0069b	c3		 ret	 0
_FormatFat ENDP
_TEXT	ENDS
END
