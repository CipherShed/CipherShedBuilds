; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\Public\Desktop\projects\ciphershed\src\Common\EncryptionThreadPool.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
_ThreadPoolRunning DD 01H DUP (?)
_StopPending DD	01H DUP (?)
_BSS	ENDS
EXTRN	__imp__InterlockedExchangeAdd@8:PROC
; Function compile flags: /Ogtpy
; File c:\users\public\desktop\projects\ciphershed\src\common\encryptionthreadpool.c
;	COMDAT _GetWorkItemState
_TEXT	SEGMENT
_GetWorkItemState PROC					; COMDAT
; _workItem$ = eax

; 113  : 	return InterlockedExchangeAdd ((LONG *) &workItem->State, 0);

  00000	6a 00		 push	 0
  00002	50		 push	 eax
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchangeAdd@8

; 114  : }

  00009	c3		 ret	 0
_GetWorkItemState ENDP
_TEXT	ENDS
EXTRN	__imp__InterlockedExchange@8:PROC
; Function compile flags: /Ogtpy
;	COMDAT _SetWorkItemState
_TEXT	SEGMENT
_SetWorkItemState PROC					; COMDAT
; _workItem$ = ecx
; _newState$ = eax

; 119  : 	InterlockedExchange ((LONG *) &workItem->State, (LONG) newState);

  00000	50		 push	 eax
  00001	51		 push	 ecx
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 120  : }

  00008	c3		 ret	 0
_SetWorkItemState ENDP
_TEXT	ENDS
EXTRN	__endthreadex:PROC
EXTRN	_EncryptDataUnitsCurrentThread:PROC
EXTRN	_DecryptDataUnitsCurrentThread:PROC
EXTRN	__imp__InterlockedDecrement@4:PROC
EXTRN	_derive_key_sha1:PROC
EXTRN	_derive_key_whirlpool:PROC
EXTRN	_derive_key_sha512:PROC
EXTRN	_derive_key_ripemd160:PROC
EXTRN	_GetMaxPkcs5OutSize:PROC
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	__imp__SetEvent@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
_BSS	SEGMENT
_WorkItemCompletedEvent DD 01H DUP (?)
_WorkItemReadyEvent DD 01H DUP (?)
_WorkItemQueue DB 02000H DUP (?)
_DequeuePosition DD 01H DUP (?)
_DequeueMutex DD 01H DUP (?)
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _EncryptionThreadProc@4
_TEXT	SEGMENT
_threadArg$ = 8						; size = 4
_EncryptionThreadProc@4 PROC				; COMDAT

; 125  : 	EncryptionThreadPoolWorkItem *workItem;
; 126  : 
; 127  : 	while (!StopPending)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _StopPending
  00005	85 c0		 test	 eax, eax
  00007	0f 85 15 02 00
	00		 jne	 $LN36@Encryption
  0000d	53		 push	 ebx
  0000e	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__WaitForSingleObject@8
  00014	55		 push	 ebp
  00015	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__SetEvent@4
  0001b	57		 push	 edi
  0001c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__InterlockedExchange@8
  00022	56		 push	 esi
$LL22@Encryption:

; 128  : 	{
; 129  : 		TC_ACQUIRE_MUTEX (&DequeueMutex);

  00023	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _DequeueMutex
  00029	6a ff		 push	 -1
  0002b	51		 push	 ecx
  0002c	ff d3		 call	 ebx

; 130  : 
; 131  : 		workItem = &WorkItemQueue[DequeuePosition++];

  0002e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _DequeuePosition
  00034	ff 05 00 00 00
	00		 inc	 DWORD PTR _DequeuePosition

; 132  : 
; 133  : 		if (DequeuePosition >= TC_ENC_THREAD_POOL_QUEUE_SIZE)

  0003a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _DequeuePosition
  00040	c1 e6 06	 shl	 esi, 6
  00043	81 c6 00 00 00
	00		 add	 esi, OFFSET _WorkItemQueue
  00049	81 fa 80 00 00
	00		 cmp	 edx, 128		; 00000080H
  0004f	7c 0a		 jl	 SHORT $LN38@Encryption

; 134  : 			DequeuePosition = 0;

  00051	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _DequeuePosition, 0
$LN38@Encryption:

; 135  : 
; 136  : 		while (!StopPending && GetWorkItemState (workItem) != WorkItemReady)

  0005b	a1 00 00 00 00	 mov	 eax, DWORD PTR _StopPending
  00060	85 c0		 test	 eax, eax
  00062	75 23		 jne	 SHORT $LN18@Encryption
$LL19@Encryption:
  00064	6a 00		 push	 0
  00066	56		 push	 esi
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchangeAdd@8
  0006d	83 f8 01	 cmp	 eax, 1
  00070	74 15		 je	 SHORT $LN18@Encryption

; 137  : 		{
; 138  : 			TC_WAIT_EVENT (WorkItemReadyEvent);

  00072	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WorkItemReadyEvent
  00078	6a ff		 push	 -1
  0007a	51		 push	 ecx
  0007b	ff d3		 call	 ebx
  0007d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _StopPending
  00083	85 d2		 test	 edx, edx
  00085	74 dd		 je	 SHORT $LL19@Encryption
$LN18@Encryption:

; 139  : 		}
; 140  : 
; 141  : 		SetWorkItemState (workItem, WorkItemBusy);

  00087	6a 02		 push	 2
  00089	56		 push	 esi
  0008a	ff d7		 call	 edi

; 142  : 
; 143  : 		TC_RELEASE_MUTEX (&DequeueMutex);

  0008c	a1 00 00 00 00	 mov	 eax, DWORD PTR _DequeueMutex
  00091	50		 push	 eax
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 144  : 
; 145  : 		if (StopPending)

  00098	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _StopPending
  0009e	85 c9		 test	 ecx, ecx
  000a0	0f 85 78 01 00
	00		 jne	 $LN43@Encryption

; 146  : 			break;
; 147  : 
; 148  : 		switch (workItem->Type)

  000a6	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000a9	2b c1		 sub	 eax, ecx
  000ab	0f 84 18 01 00
	00		 je	 $LN13@Encryption
  000b1	83 e8 01	 sub	 eax, 1
  000b4	0f 84 f6 00 00
	00		 je	 $LN14@Encryption
  000ba	83 e8 01	 sub	 eax, 1
  000bd	74 0b		 je	 SHORT $LN12@Encryption

; 194  : 
; 195  : 		default:
; 196  : 			TC_THROW_FATAL_EXCEPTION;

  000bf	88 0d 00 00 00
	00		 mov	 BYTE PTR ds:0, cl
  000c5	e9 19 01 00 00	 jmp	 $LN15@Encryption
$LN12@Encryption:

; 156  : 			break;
; 157  : 
; 158  : 		case DeriveKeyWork:
; 159  : 			switch (workItem->KeyDerivation.Pkcs5Prf)

  000ca	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  000cd	48		 dec	 eax
  000ce	83 f8 03	 cmp	 eax, 3
  000d1	0f 87 9f 00 00
	00		 ja	 $LN5@Encryption
  000d7	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN46@Encryption[eax*4]
$LN9@Encryption:

; 160  : 			{
; 161  : 			case RIPEMD160:
; 162  : 				derive_key_ripemd160 (workItem->KeyDerivation.Password, workItem->KeyDerivation.PasswordLength, workItem->KeyDerivation.Salt, PKCS5_SALT_SIZE,
; 163  : 					workItem->KeyDerivation.IterationCount, workItem->KeyDerivation.DerivedKey, GetMaxPkcs5OutSize());

  000de	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize
  000e3	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  000e6	8b 4e 3c	 mov	 ecx, DWORD PTR [esi+60]
  000e9	50		 push	 eax
  000ea	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  000ed	52		 push	 edx
  000ee	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  000f1	50		 push	 eax
  000f2	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  000f5	6a 40		 push	 64			; 00000040H
  000f7	51		 push	 ecx
  000f8	52		 push	 edx
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 _derive_key_ripemd160
  000ff	83 c4 1c	 add	 esp, 28			; 0000001cH

; 164  : 				break;

  00102	eb 79		 jmp	 SHORT $LN10@Encryption
$LN8@Encryption:

; 165  : 
; 166  : 			case SHA512:
; 167  : 				derive_key_sha512 (workItem->KeyDerivation.Password, workItem->KeyDerivation.PasswordLength, workItem->KeyDerivation.Salt, PKCS5_SALT_SIZE,
; 168  : 					workItem->KeyDerivation.IterationCount, workItem->KeyDerivation.DerivedKey, GetMaxPkcs5OutSize());

  00104	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize
  00109	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  0010c	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  0010f	50		 push	 eax
  00110	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  00113	51		 push	 ecx
  00114	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  00117	52		 push	 edx
  00118	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  0011b	6a 40		 push	 64			; 00000040H
  0011d	50		 push	 eax
  0011e	51		 push	 ecx
  0011f	52		 push	 edx
  00120	e8 00 00 00 00	 call	 _derive_key_sha512
  00125	83 c4 1c	 add	 esp, 28			; 0000001cH

; 169  : 				break;

  00128	eb 53		 jmp	 SHORT $LN10@Encryption
$LN7@Encryption:

; 170  : 
; 171  : 			case WHIRLPOOL:
; 172  : 				derive_key_whirlpool (workItem->KeyDerivation.Password, workItem->KeyDerivation.PasswordLength, workItem->KeyDerivation.Salt, PKCS5_SALT_SIZE,
; 173  : 					workItem->KeyDerivation.IterationCount, workItem->KeyDerivation.DerivedKey, GetMaxPkcs5OutSize());

  0012a	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize
  0012f	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00132	8b 56 3c	 mov	 edx, DWORD PTR [esi+60]
  00135	50		 push	 eax
  00136	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00139	50		 push	 eax
  0013a	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0013d	51		 push	 ecx
  0013e	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00141	6a 40		 push	 64			; 00000040H
  00143	52		 push	 edx
  00144	50		 push	 eax
  00145	51		 push	 ecx
  00146	e8 00 00 00 00	 call	 _derive_key_whirlpool
  0014b	83 c4 1c	 add	 esp, 28			; 0000001cH

; 174  : 				break;

  0014e	eb 2d		 jmp	 SHORT $LN10@Encryption
$LN6@Encryption:

; 175  : 
; 176  : 			case SHA1:
; 177  : 				derive_key_sha1 (workItem->KeyDerivation.Password, workItem->KeyDerivation.PasswordLength, workItem->KeyDerivation.Salt, PKCS5_SALT_SIZE,
; 178  : 					workItem->KeyDerivation.IterationCount, workItem->KeyDerivation.DerivedKey, GetMaxPkcs5OutSize());

  00150	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize
  00155	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  00158	8b 4e 3c	 mov	 ecx, DWORD PTR [esi+60]
  0015b	50		 push	 eax
  0015c	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0015f	52		 push	 edx
  00160	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  00163	50		 push	 eax
  00164	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00167	6a 40		 push	 64			; 00000040H
  00169	51		 push	 ecx
  0016a	52		 push	 edx
  0016b	50		 push	 eax
  0016c	e8 00 00 00 00	 call	 _derive_key_sha1
  00171	83 c4 1c	 add	 esp, 28			; 0000001cH

; 179  : 				break;

  00174	eb 07		 jmp	 SHORT $LN10@Encryption
$LN5@Encryption:

; 180  : 
; 181  : 			default:		
; 182  : 				TC_THROW_FATAL_EXCEPTION;

  00176	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
$LN10@Encryption:

; 183  : 			} 
; 184  : 
; 185  : 			InterlockedExchange (workItem->KeyDerivation.CompletionFlag, TRUE);

  0017d	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00180	6a 01		 push	 1
  00182	51		 push	 ecx
  00183	ff d7		 call	 edi

; 186  : 			TC_SET_EVENT (*workItem->KeyDerivation.CompletionEvent);

  00185	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  00188	8b 02		 mov	 eax, DWORD PTR [edx]
  0018a	50		 push	 eax
  0018b	ff d5		 call	 ebp

; 187  : 			
; 188  : 			if (InterlockedDecrement (workItem->KeyDerivation.OutstandingWorkItemCount) == 0)

  0018d	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  00190	51		 push	 ecx
  00191	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedDecrement@4
  00197	85 c0		 test	 eax, eax
  00199	75 08		 jne	 SHORT $LN4@Encryption

; 189  : 				TC_SET_EVENT (*workItem->KeyDerivation.NoOutstandingWorkItemEvent);

  0019b	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  0019e	8b 02		 mov	 eax, DWORD PTR [edx]
  001a0	50		 push	 eax
  001a1	ff d5		 call	 ebp
$LN4@Encryption:

; 190  : 
; 191  : 			SetWorkItemState (workItem, WorkItemFree);

  001a3	6a 00		 push	 0
  001a5	56		 push	 esi
  001a6	ff d7		 call	 edi

; 192  : 			TC_SET_EVENT (WorkItemCompletedEvent);

  001a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WorkItemCompletedEvent

; 193  : 			continue;

  001ae	eb 5d		 jmp	 SHORT $LN44@Encryption
$LN14@Encryption:

; 149  : 		{
; 150  : 		case DecryptDataUnitsWork:
; 151  : 			DecryptDataUnitsCurrentThread (workItem->Encryption.Data, &workItem->Encryption.StartUnitNo, workItem->Encryption.UnitCount, workItem->Encryption.CryptoInfo);

  001b0	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  001b3	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  001b6	52		 push	 edx
  001b7	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  001ba	6a 00		 push	 0
  001bc	50		 push	 eax
  001bd	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  001c0	51		 push	 ecx
  001c1	52		 push	 edx
  001c2	e8 00 00 00 00	 call	 _DecryptDataUnitsCurrentThread

; 152  : 			break;

  001c7	eb 17		 jmp	 SHORT $LN45@Encryption
$LN13@Encryption:

; 153  : 
; 154  : 		case EncryptDataUnitsWork:
; 155  : 			EncryptDataUnitsCurrentThread (workItem->Encryption.Data, &workItem->Encryption.StartUnitNo, workItem->Encryption.UnitCount, workItem->Encryption.CryptoInfo);

  001c9	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  001cc	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  001cf	50		 push	 eax
  001d0	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  001d3	6a 00		 push	 0
  001d5	51		 push	 ecx
  001d6	8d 56 20	 lea	 edx, DWORD PTR [esi+32]
  001d9	52		 push	 edx
  001da	50		 push	 eax
  001db	e8 00 00 00 00	 call	 _EncryptDataUnitsCurrentThread
$LN45@Encryption:
  001e0	83 c4 14	 add	 esp, 20			; 00000014H
$LN15@Encryption:

; 197  : 		}
; 198  : 
; 199  : 		if (workItem != workItem->FirstFragment)

  001e3	3b 76 0c	 cmp	 esi, DWORD PTR [esi+12]
  001e6	74 0e		 je	 SHORT $LN2@Encryption

; 200  : 		{
; 201  : 			SetWorkItemState (workItem, WorkItemFree);

  001e8	6a 00		 push	 0
  001ea	56		 push	 esi
  001eb	ff d7		 call	 edi

; 202  : 			TC_SET_EVENT (WorkItemCompletedEvent);

  001ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WorkItemCompletedEvent
  001f3	51		 push	 ecx
  001f4	ff d5		 call	 ebp
$LN2@Encryption:

; 203  : 		}
; 204  : 
; 205  : 		if (InterlockedDecrement (&workItem->FirstFragment->OutstandingFragmentCount) == 0)

  001f6	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  001f9	83 c2 10	 add	 edx, 16			; 00000010H
  001fc	52		 push	 edx
  001fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedDecrement@4
  00203	85 c0		 test	 eax, eax
  00205	75 09		 jne	 SHORT $LN1@Encryption

; 206  : 			TC_SET_EVENT (workItem->FirstFragment->ItemCompletedEvent);

  00207	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0020a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
$LN44@Encryption:
  0020d	51		 push	 ecx
  0020e	ff d5		 call	 ebp
$LN1@Encryption:
  00210	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _StopPending
  00216	85 d2		 test	 edx, edx
  00218	0f 84 05 fe ff
	ff		 je	 $LL22@Encryption
$LN43@Encryption:
  0021e	5e		 pop	 esi
  0021f	5f		 pop	 edi
  00220	5d		 pop	 ebp
  00221	5b		 pop	 ebx
$LN36@Encryption:

; 207  : 	}
; 208  : 
; 209  : #ifdef DEVICE_DRIVER
; 210  : 	PsTerminateSystemThread (STATUS_SUCCESS);
; 211  : #else
; 212  : 	_endthreadex (0);

  00222	6a 00		 push	 0
  00224	e8 00 00 00 00	 call	 __endthreadex
  00229	83 c4 04	 add	 esp, 4

; 213  :     return 0;

  0022c	33 c0		 xor	 eax, eax

; 214  : #endif
; 215  : }

  0022e	c2 04 00	 ret	 4
  00231	8d 49 00	 npad	 3
$LN46@Encryption:
  00234	00 00 00 00	 DD	 $LN9@Encryption
  00238	00 00 00 00	 DD	 $LN8@Encryption
  0023c	00 00 00 00	 DD	 $LN7@Encryption
  00240	00 00 00 00	 DD	 $LN6@Encryption
_EncryptionThreadProc@4 ENDP
_TEXT	ENDS
PUBLIC	_EncryptionThreadPoolStop
EXTRN	__imp__CloseHandle@4:PROC
_BSS	SEGMENT
_EnqueueMutex DD 01H DUP (?)
_ThreadHandles DD 040H DUP (?)
_ThreadCount DD	01H DUP (?)
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _EncryptionThreadPoolStop
_TEXT	SEGMENT
_EncryptionThreadPoolStop PROC				; COMDAT

; 312  : 	size_t i;
; 313  : 
; 314  : 	if (!ThreadPoolRunning)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _ThreadPoolRunning
  00005	85 c0		 test	 eax, eax
  00007	0f 84 97 00 00
	00		 je	 $LN9@Encryption@2

; 315  : 		return;
; 316  : 
; 317  : 	StopPending = TRUE;
; 318  : 	TC_SET_EVENT (WorkItemReadyEvent);

  0000d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WorkItemReadyEvent
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	51		 push	 ecx
  00016	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _StopPending, 1
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 319  : 
; 320  : 	for (i = 0; i < ThreadCount; ++i)

  00026	33 f6		 xor	 esi, esi
  00028	39 35 00 00 00
	00		 cmp	 DWORD PTR _ThreadCount, esi
  0002e	76 1b		 jbe	 SHORT $LN5@Encryption@2
  00030	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__WaitForSingleObject@8
$LL7@Encryption@2:

; 321  : 	{
; 322  : #ifdef DEVICE_DRIVER
; 323  : 		TCStopThread (ThreadHandles[i], &WorkItemReadyEvent);
; 324  : #else
; 325  : 		TC_WAIT_EVENT (ThreadHandles[i]);

  00036	8b 14 b5 00 00
	00 00		 mov	 edx, DWORD PTR _ThreadHandles[esi*4]
  0003d	6a ff		 push	 -1
  0003f	52		 push	 edx
  00040	ff d7		 call	 edi
  00042	46		 inc	 esi
  00043	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR _ThreadCount
  00049	72 eb		 jb	 SHORT $LL7@Encryption@2
$LN5@Encryption@2:

; 326  : #endif
; 327  : 	}
; 328  : 
; 329  : 	ThreadCount = 0;
; 330  : 
; 331  : #ifndef DEVICE_DRIVER
; 332  : 	CloseHandle (DequeueMutex);

  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR _DequeueMutex
  00050	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__CloseHandle@4
  00056	50		 push	 eax
  00057	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ThreadCount, 0
  00061	ff d7		 call	 edi

; 333  : 	CloseHandle (EnqueueMutex);

  00063	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _EnqueueMutex
  00069	51		 push	 ecx
  0006a	ff d7		 call	 edi

; 334  : 
; 335  : 	CloseHandle (WorkItemReadyEvent);

  0006c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WorkItemReadyEvent
  00072	52		 push	 edx
  00073	ff d7		 call	 edi

; 336  : 	CloseHandle (WorkItemCompletedEvent);

  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR _WorkItemCompletedEvent
  0007a	50		 push	 eax
  0007b	ff d7		 call	 edi

; 337  : 
; 338  : 	for (i = 0; i < sizeof (WorkItemQueue) / sizeof (WorkItemQueue[0]); ++i)

  0007d	33 f6		 xor	 esi, esi
  0007f	90		 npad	 1
$LL4@Encryption@2:

; 339  : 	{
; 340  : 		if (WorkItemQueue[i].ItemCompletedEvent)

  00080	8b 86 08 00 00
	00		 mov	 eax, DWORD PTR _WorkItemQueue[esi+8]
  00086	85 c0		 test	 eax, eax
  00088	74 03		 je	 SHORT $LN3@Encryption@2

; 341  : 			CloseHandle (WorkItemQueue[i].ItemCompletedEvent);

  0008a	50		 push	 eax
  0008b	ff d7		 call	 edi
$LN3@Encryption@2:
  0008d	83 c6 40	 add	 esi, 64			; 00000040H
  00090	81 fe 00 20 00
	00		 cmp	 esi, 8192		; 00002000H
  00096	72 e8		 jb	 SHORT $LL4@Encryption@2
  00098	5f		 pop	 edi

; 342  : 	}
; 343  : #endif
; 344  : 
; 345  : 	ThreadPoolRunning = FALSE;

  00099	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ThreadPoolRunning, 0
  000a3	5e		 pop	 esi
$LN9@Encryption@2:

; 346  : }

  000a4	c3		 ret	 0
_EncryptionThreadPoolStop ENDP
_TEXT	ENDS
PUBLIC	_EncryptionThreadPoolBeginKeyDerivation
EXTRN	__imp__ResetEvent@4:PROC
EXTRN	__imp__InterlockedIncrement@4:PROC
_BSS	SEGMENT
_EnqueuePosition DD 01H DUP (?)
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _EncryptionThreadPoolBeginKeyDerivation
_TEXT	SEGMENT
_completionEvent$ = 8					; size = 4
_noOutstandingWorkItemEvent$ = 12			; size = 4
_completionFlag$ = 16					; size = 4
_outstandingWorkItemCount$ = 20				; size = 4
_pkcs5Prf$ = 24						; size = 4
_password$ = 28						; size = 4
_passwordLength$ = 32					; size = 4
_salt$ = 36						; size = 4
_iterationCount$ = 40					; size = 4
_derivedKey$ = 44					; size = 4
_EncryptionThreadPoolBeginKeyDerivation PROC		; COMDAT

; 351  : 	EncryptionThreadPoolWorkItem *workItem;
; 352  : 
; 353  : 	if (!ThreadPoolRunning)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _ThreadPoolRunning
  00005	85 c0		 test	 eax, eax
  00007	75 05		 jne	 SHORT $LN4@Encryption@3

; 354  : 		TC_THROW_FATAL_EXCEPTION;

  00009	a2 00 00 00 00	 mov	 BYTE PTR ds:0, al
$LN4@Encryption@3:

; 355  : 
; 356  : 	TC_ACQUIRE_MUTEX (&EnqueueMutex);

  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _EnqueueMutex
  00014	53		 push	 ebx
  00015	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__WaitForSingleObject@8
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	6a ff		 push	 -1
  0001f	51		 push	 ecx
  00020	ff d3		 call	 ebx

; 357  : 
; 358  : 	workItem = &WorkItemQueue[EnqueuePosition++];

  00022	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _EnqueuePosition
  00028	ff 05 00 00 00
	00		 inc	 DWORD PTR _EnqueuePosition

; 359  : 	if (EnqueuePosition >= TC_ENC_THREAD_POOL_QUEUE_SIZE)

  0002e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _EnqueuePosition
  00034	c1 e6 06	 shl	 esi, 6
  00037	81 c6 00 00 00
	00		 add	 esi, OFFSET _WorkItemQueue
  0003d	81 fa 80 00 00
	00		 cmp	 edx, 128		; 00000080H
  00043	7c 0a		 jl	 SHORT $LN13@Encryption@3

; 360  : 		EnqueuePosition = 0;

  00045	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _EnqueuePosition, 0
$LN13@Encryption@3:

; 361  : 
; 362  : 	while (GetWorkItemState (workItem) != WorkItemFree)

  0004f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__InterlockedExchangeAdd@8
  00055	6a 00		 push	 0
  00057	56		 push	 esi
  00058	ff d7		 call	 edi
  0005a	85 c0		 test	 eax, eax
  0005c	74 15		 je	 SHORT $LN1@Encryption@3
  0005e	8b ff		 npad	 2
$LL2@Encryption@3:

; 363  : 	{
; 364  : 		TC_WAIT_EVENT (WorkItemCompletedEvent);

  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR _WorkItemCompletedEvent
  00065	6a ff		 push	 -1
  00067	50		 push	 eax
  00068	ff d3		 call	 ebx
  0006a	6a 00		 push	 0
  0006c	56		 push	 esi
  0006d	ff d7		 call	 edi
  0006f	85 c0		 test	 eax, eax
  00071	75 ed		 jne	 SHORT $LL2@Encryption@3
$LN1@Encryption@3:

; 365  : 	}
; 366  : 
; 367  : 	workItem->Type = DeriveKeyWork;
; 368  : 	workItem->KeyDerivation.CompletionEvent = completionEvent;

  00073	8b 4c 24 10	 mov	 ecx, DWORD PTR _completionEvent$[esp+8]

; 369  : 	workItem->KeyDerivation.CompletionFlag = completionFlag;

  00077	8b 54 24 18	 mov	 edx, DWORD PTR _completionFlag$[esp+8]

; 370  : 	workItem->KeyDerivation.DerivedKey = derivedKey;

  0007b	8b 44 24 34	 mov	 eax, DWORD PTR _derivedKey$[esp+8]

; 371  : 	workItem->KeyDerivation.IterationCount = iterationCount;
; 372  : 	workItem->KeyDerivation.NoOutstandingWorkItemEvent = noOutstandingWorkItemEvent;

  0007f	8b 7c 24 14	 mov	 edi, DWORD PTR _noOutstandingWorkItemEvent$[esp+8]
  00083	89 4e 18	 mov	 DWORD PTR [esi+24], ecx
  00086	8b 4c 24 30	 mov	 ecx, DWORD PTR _iterationCount$[esp+8]
  0008a	89 56 1c	 mov	 DWORD PTR [esi+28], edx

; 373  : 	workItem->KeyDerivation.OutstandingWorkItemCount = outstandingWorkItemCount;
; 374  : 	workItem->KeyDerivation.Password = password;

  0008d	8b 54 24 24	 mov	 edx, DWORD PTR _password$[esp+8]
  00091	89 4e 24	 mov	 DWORD PTR [esi+36], ecx

; 375  : 	workItem->KeyDerivation.PasswordLength = passwordLength;

  00094	8b 4c 24 28	 mov	 ecx, DWORD PTR _passwordLength$[esp+8]
  00098	89 46 20	 mov	 DWORD PTR [esi+32], eax
  0009b	8b 44 24 1c	 mov	 eax, DWORD PTR _outstandingWorkItemCount$[esp+8]
  0009f	89 56 30	 mov	 DWORD PTR [esi+48], edx

; 376  : 	workItem->KeyDerivation.Pkcs5Prf = pkcs5Prf;

  000a2	8b 54 24 20	 mov	 edx, DWORD PTR _pkcs5Prf$[esp+8]
  000a6	89 4e 34	 mov	 DWORD PTR [esi+52], ecx

; 377  : 	workItem->KeyDerivation.Salt = salt;

  000a9	8b 4c 24 2c	 mov	 ecx, DWORD PTR _salt$[esp+8]

; 378  : 
; 379  : 	InterlockedIncrement (outstandingWorkItemCount);

  000ad	50		 push	 eax
  000ae	c7 46 04 02 00
	00 00		 mov	 DWORD PTR [esi+4], 2
  000b5	89 7e 28	 mov	 DWORD PTR [esi+40], edi
  000b8	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  000bb	89 56 38	 mov	 DWORD PTR [esi+56], edx
  000be	89 4e 3c	 mov	 DWORD PTR [esi+60], ecx
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedIncrement@4

; 380  : 	TC_CLEAR_EVENT (*noOutstandingWorkItemEvent);

  000c7	8b 17		 mov	 edx, DWORD PTR [edi]
  000c9	52		 push	 edx
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ResetEvent@4

; 381  : 
; 382  : 	SetWorkItemState (workItem, WorkItemReady);

  000d0	6a 01		 push	 1
  000d2	56		 push	 esi
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 383  : 	TC_SET_EVENT (WorkItemReadyEvent);

  000d9	a1 00 00 00 00	 mov	 eax, DWORD PTR _WorkItemReadyEvent
  000de	50		 push	 eax
  000df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 384  : 	TC_RELEASE_MUTEX (&EnqueueMutex);

  000e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _EnqueueMutex
  000eb	51		 push	 ecx
  000ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4
  000f2	5f		 pop	 edi
  000f3	5e		 pop	 esi
  000f4	5b		 pop	 ebx

; 385  : }

  000f5	c3		 ret	 0
_EncryptionThreadPoolBeginKeyDerivation ENDP
_TEXT	ENDS
PUBLIC	_EncryptionThreadPoolDoWork
; Function compile flags: /Ogtpy
;	COMDAT _EncryptionThreadPoolDoWork
_TEXT	SEGMENT
_remainder$ = -16					; size = 4
tv281 = -12						; size = 4
_fragmentStartUnitNo$ = -8				; size = 8
_type$ = 8						; size = 4
_data$ = 12						; size = 4
_startUnitNo$ = 16					; size = 4
_fragmentCount$ = 20					; size = 4
_unitCount$ = 20					; size = 4
_cryptoInfo$ = 24					; size = 4
_EncryptionThreadPoolDoWork PROC			; COMDAT

; 390  : 	uint32 fragmentCount;
; 391  : 	uint32 unitsPerFragment;
; 392  : 	uint32 remainder;
; 393  : 
; 394  : 	byte *fragmentData;
; 395  : 	uint64 fragmentStartUnitNo;
; 396  : 
; 397  : 	EncryptionThreadPoolWorkItem *workItem;
; 398  : 	EncryptionThreadPoolWorkItem *firstFragmentWorkItem;
; 399  : 	
; 400  : 	if (unitCount == 0)

  00000	8b 44 24 10	 mov	 eax, DWORD PTR _unitCount$[esp-4]
  00004	83 ec 10	 sub	 esp, 16			; 00000010H
  00007	85 c0		 test	 eax, eax
  00009	0f 84 15 02 00
	00		 je	 $LN15@Encryption@4

; 401  : 		return;
; 402  : 	
; 403  : 	if (!ThreadPoolRunning || unitCount == 1)

  0000f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ThreadPoolRunning
  00015	85 c9		 test	 ecx, ecx
  00017	0f 84 b6 01 00
	00		 je	 $LN41@Encryption@4
  0001d	83 f8 01	 cmp	 eax, 1
  00020	0f 84 ad 01 00
	00		 je	 $LN41@Encryption@4

; 417  : 		}
; 418  : 
; 419  : 		return;
; 420  : 	}
; 421  : 
; 422  : 	if (unitCount <= ThreadCount)

  00026	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ThreadCount
  0002c	53		 push	 ebx
  0002d	55		 push	 ebp
  0002e	56		 push	 esi
  0002f	57		 push	 edi
  00030	3b c1		 cmp	 eax, ecx
  00032	77 13		 ja	 SHORT $LN11@Encryption@4

; 423  : 	{
; 424  : 		fragmentCount = unitCount;

  00034	89 44 24 30	 mov	 DWORD PTR _fragmentCount$[esp+28], eax

; 425  : 		unitsPerFragment = 1;

  00038	bd 01 00 00 00	 mov	 ebp, 1

; 426  : 		remainder = 0;

  0003d	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _remainder$[esp+32], 0

; 427  : 	}
; 428  : 	else

  00045	eb 13		 jmp	 SHORT $LN37@Encryption@4
$LN11@Encryption@4:

; 429  : 	{
; 430  : 		/* Note that it is not efficient to divide the data into fragments smaller than a few hundred bytes.
; 431  : 		The reason is that the overhead associated with thread handling would in most cases make a multi-threaded 
; 432  : 		process actually slower than a single-threaded process. */
; 433  : 
; 434  : 		fragmentCount = ThreadCount;
; 435  : 		unitsPerFragment = unitCount / ThreadCount;

  00047	33 d2		 xor	 edx, edx
  00049	f7 f1		 div	 ecx
  0004b	89 4c 24 30	 mov	 DWORD PTR _fragmentCount$[esp+28], ecx
  0004f	8b e8		 mov	 ebp, eax

; 436  : 		remainder = unitCount % ThreadCount;

  00051	89 54 24 10	 mov	 DWORD PTR _remainder$[esp+32], edx

; 437  : 
; 438  : 		if (remainder > 0)

  00055	85 d2		 test	 edx, edx
  00057	76 01		 jbe	 SHORT $LN37@Encryption@4

; 439  : 			++unitsPerFragment;

  00059	45		 inc	 ebp
$LN37@Encryption@4:

; 440  : 	}
; 441  : 	
; 442  : 	fragmentData = data;
; 443  : 	fragmentStartUnitNo = startUnitNo->Value;

  0005a	8b 44 24 2c	 mov	 eax, DWORD PTR _startUnitNo$[esp+28]
  0005e	8b 10		 mov	 edx, DWORD PTR [eax]

; 444  : 
; 445  : 	TC_ACQUIRE_MUTEX (&EnqueueMutex);

  00060	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _EnqueueMutex
  00066	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00069	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__WaitForSingleObject@8
  0006f	8b 5c 24 28	 mov	 ebx, DWORD PTR _data$[esp+28]
  00073	6a ff		 push	 -1
  00075	51		 push	 ecx
  00076	89 54 24 20	 mov	 DWORD PTR _fragmentStartUnitNo$[esp+40], edx
  0007a	89 44 24 24	 mov	 DWORD PTR _fragmentStartUnitNo$[esp+44], eax
  0007e	ff d6		 call	 esi

; 446  : 	firstFragmentWorkItem = &WorkItemQueue[EnqueuePosition];

  00080	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _EnqueuePosition
  00086	c1 e7 06	 shl	 edi, 6

; 447  : 
; 448  : 	while (GetWorkItemState (firstFragmentWorkItem) != WorkItemFree)

  00089	6a 00		 push	 0
  0008b	81 c7 00 00 00
	00		 add	 edi, OFFSET _WorkItemQueue
  00091	57		 push	 edi
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchangeAdd@8
  00098	85 c0		 test	 eax, eax
  0009a	74 1c		 je	 SHORT $LN7@Encryption@4
  0009c	8d 64 24 00	 npad	 4
$LL8@Encryption@4:

; 449  : 	{
; 450  : 		TC_WAIT_EVENT (WorkItemCompletedEvent);

  000a0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WorkItemCompletedEvent
  000a6	6a ff		 push	 -1
  000a8	52		 push	 edx
  000a9	ff d6		 call	 esi
  000ab	6a 00		 push	 0
  000ad	57		 push	 edi
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchangeAdd@8
  000b4	85 c0		 test	 eax, eax
  000b6	75 e8		 jne	 SHORT $LL8@Encryption@4
$LN7@Encryption@4:

; 451  : 	}
; 452  : 
; 453  : 	firstFragmentWorkItem->OutstandingFragmentCount = fragmentCount;

  000b8	8b 44 24 30	 mov	 eax, DWORD PTR _fragmentCount$[esp+28]
  000bc	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 454  : 
; 455  : 	while (fragmentCount-- > 0)

  000bf	85 c0		 test	 eax, eax
  000c1	0f 86 d9 00 00
	00		 jbe	 $LN35@Encryption@4
  000c7	8b c5		 mov	 eax, ebp
  000c9	c1 e0 09	 shl	 eax, 9
  000cc	89 44 24 14	 mov	 DWORD PTR tv281[esp+32], eax
$LL6@Encryption@4:

; 456  : 	{
; 457  : 		workItem = &WorkItemQueue[EnqueuePosition++];

  000d0	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _EnqueuePosition
  000d6	ff 05 00 00 00
	00		 inc	 DWORD PTR _EnqueuePosition

; 458  : 		if (EnqueuePosition >= TC_ENC_THREAD_POOL_QUEUE_SIZE)

  000dc	a1 00 00 00 00	 mov	 eax, DWORD PTR _EnqueuePosition
  000e1	ff 4c 24 30	 dec	 DWORD PTR _fragmentCount$[esp+28]
  000e5	c1 e6 06	 shl	 esi, 6
  000e8	81 c6 00 00 00
	00		 add	 esi, OFFSET _WorkItemQueue
  000ee	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  000f3	7c 0a		 jl	 SHORT $LN39@Encryption@4

; 459  : 			EnqueuePosition = 0;

  000f5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _EnqueuePosition, 0
$LN39@Encryption@4:

; 460  : 
; 461  : 		while (GetWorkItemState (workItem) != WorkItemFree)

  000ff	6a 00		 push	 0
  00101	56		 push	 esi
  00102	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchangeAdd@8
  00108	85 c0		 test	 eax, eax
  0010a	74 20		 je	 SHORT $LN2@Encryption@4
  0010c	8d 64 24 00	 npad	 4
$LL3@Encryption@4:

; 462  : 		{
; 463  : 			TC_WAIT_EVENT (WorkItemCompletedEvent);

  00110	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WorkItemCompletedEvent
  00116	6a ff		 push	 -1
  00118	51		 push	 ecx
  00119	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  0011f	6a 00		 push	 0
  00121	56		 push	 esi
  00122	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchangeAdd@8
  00128	85 c0		 test	 eax, eax
  0012a	75 e4		 jne	 SHORT $LL3@Encryption@4
$LN2@Encryption@4:

; 464  : 		}
; 465  : 
; 466  : 		workItem->Type = type;
; 467  : 		workItem->FirstFragment = firstFragmentWorkItem;
; 468  : 
; 469  : 		workItem->Encryption.CryptoInfo = cryptoInfo;

  0012c	8b 44 24 34	 mov	 eax, DWORD PTR _cryptoInfo$[esp+28]

; 470  : 		workItem->Encryption.Data = fragmentData;
; 471  : 		workItem->Encryption.UnitCount = unitsPerFragment;
; 472  : 		workItem->Encryption.StartUnitNo.Value = fragmentStartUnitNo;

  00130	8b 4c 24 1c	 mov	 ecx, DWORD PTR _fragmentStartUnitNo$[esp+36]
  00134	8b 54 24 24	 mov	 edx, DWORD PTR _type$[esp+28]
  00138	89 46 18	 mov	 DWORD PTR [esi+24], eax
  0013b	8b 44 24 18	 mov	 eax, DWORD PTR _fragmentStartUnitNo$[esp+32]
  0013f	89 5e 1c	 mov	 DWORD PTR [esi+28], ebx

; 473  : 
; 474  :  		fragmentData += unitsPerFragment * ENCRYPTION_DATA_UNIT_SIZE;

  00142	03 5c 24 14	 add	 ebx, DWORD PTR tv281[esp+32]
  00146	89 46 20	 mov	 DWORD PTR [esi+32], eax

; 475  : 		fragmentStartUnitNo += unitsPerFragment;

  00149	03 c5		 add	 eax, ebp
  0014b	89 4e 24	 mov	 DWORD PTR [esi+36], ecx
  0014e	83 d1 00	 adc	 ecx, 0

; 476  : 
; 477  : 		if (remainder > 0 && --remainder == 0)

  00151	83 7c 24 10 00	 cmp	 DWORD PTR _remainder$[esp+32], 0
  00156	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00159	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  0015c	89 6e 28	 mov	 DWORD PTR [esi+40], ebp
  0015f	89 44 24 18	 mov	 DWORD PTR _fragmentStartUnitNo$[esp+32], eax
  00163	89 4c 24 1c	 mov	 DWORD PTR _fragmentStartUnitNo$[esp+36], ecx
  00167	76 10		 jbe	 SHORT $LN40@Encryption@4
  00169	83 6c 24 10 01	 sub	 DWORD PTR _remainder$[esp+32], 1
  0016e	75 09		 jne	 SHORT $LN40@Encryption@4

; 478  : 			--unitsPerFragment;

  00170	4d		 dec	 ebp
  00171	81 6c 24 14 00
	02 00 00	 sub	 DWORD PTR tv281[esp+32], 512 ; 00000200H
$LN40@Encryption@4:

; 479  : 
; 480  : 		SetWorkItemState (workItem, WorkItemReady);

  00179	6a 01		 push	 1
  0017b	56		 push	 esi
  0017c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 481  : 		TC_SET_EVENT (WorkItemReadyEvent);

  00182	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WorkItemReadyEvent
  00188	51		 push	 ecx
  00189	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
  0018f	83 7c 24 30 00	 cmp	 DWORD PTR _fragmentCount$[esp+28], 0
  00194	0f 87 36 ff ff
	ff		 ja	 $LL6@Encryption@4

; 454  : 
; 455  : 	while (fragmentCount-- > 0)

  0019a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__WaitForSingleObject@8
$LN35@Encryption@4:

; 482  : 	}
; 483  : 
; 484  : 	TC_RELEASE_MUTEX (&EnqueueMutex);

  001a0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _EnqueueMutex
  001a6	52		 push	 edx
  001a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 485  : 
; 486  : 	TC_WAIT_EVENT (firstFragmentWorkItem->ItemCompletedEvent);

  001ad	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  001b0	6a ff		 push	 -1
  001b2	50		 push	 eax
  001b3	ff d6		 call	 esi

; 487  : 	SetWorkItemState (firstFragmentWorkItem, WorkItemFree);

  001b5	6a 00		 push	 0
  001b7	57		 push	 edi
  001b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 488  : 	TC_SET_EVENT (WorkItemCompletedEvent);

  001be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WorkItemCompletedEvent
  001c4	51		 push	 ecx
  001c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
  001cb	5f		 pop	 edi
  001cc	5e		 pop	 esi
  001cd	5d		 pop	 ebp
  001ce	5b		 pop	 ebx

; 489  : }

  001cf	83 c4 10	 add	 esp, 16			; 00000010H
  001d2	c3		 ret	 0
$LN41@Encryption@4:

; 404  : 	{
; 405  : 		switch (type)

  001d3	8b 4c 24 14	 mov	 ecx, DWORD PTR _type$[esp+12]
  001d7	83 e9 00	 sub	 ecx, 0
  001da	74 2e		 je	 SHORT $LN13@Encryption@4
  001dc	83 e9 01	 sub	 ecx, 1
  001df	74 0b		 je	 SHORT $LN14@Encryption@4

; 413  : 			break;
; 414  : 
; 415  : 		default:
; 416  : 			TC_THROW_FATAL_EXCEPTION;

  001e1	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0

; 489  : }

  001e8	83 c4 10	 add	 esp, 16			; 00000010H
  001eb	c3		 ret	 0
$LN14@Encryption@4:

; 406  : 		{
; 407  : 		case DecryptDataUnitsWork:
; 408  : 			DecryptDataUnitsCurrentThread (data, startUnitNo, unitCount, cryptoInfo);

  001ec	8b 54 24 24	 mov	 edx, DWORD PTR _cryptoInfo$[esp+12]
  001f0	8b 4c 24 18	 mov	 ecx, DWORD PTR _data$[esp+12]
  001f4	52		 push	 edx
  001f5	6a 00		 push	 0
  001f7	50		 push	 eax
  001f8	8b 44 24 28	 mov	 eax, DWORD PTR _startUnitNo$[esp+24]
  001fc	50		 push	 eax
  001fd	51		 push	 ecx
  001fe	e8 00 00 00 00	 call	 _DecryptDataUnitsCurrentThread

; 409  : 			break;
; 410  : 
; 411  : 		case EncryptDataUnitsWork:
; 412  : 			EncryptDataUnitsCurrentThread (data, startUnitNo, unitCount, cryptoInfo);

  00203	83 c4 14	 add	 esp, 20			; 00000014H

; 489  : }

  00206	83 c4 10	 add	 esp, 16			; 00000010H
  00209	c3		 ret	 0
$LN13@Encryption@4:

; 409  : 			break;
; 410  : 
; 411  : 		case EncryptDataUnitsWork:
; 412  : 			EncryptDataUnitsCurrentThread (data, startUnitNo, unitCount, cryptoInfo);

  0020a	8b 54 24 24	 mov	 edx, DWORD PTR _cryptoInfo$[esp+12]
  0020e	8b 4c 24 18	 mov	 ecx, DWORD PTR _data$[esp+12]
  00212	52		 push	 edx
  00213	6a 00		 push	 0
  00215	50		 push	 eax
  00216	8b 44 24 28	 mov	 eax, DWORD PTR _startUnitNo$[esp+24]
  0021a	50		 push	 eax
  0021b	51		 push	 ecx
  0021c	e8 00 00 00 00	 call	 _EncryptDataUnitsCurrentThread
  00221	83 c4 14	 add	 esp, 20			; 00000014H
$LN15@Encryption@4:

; 489  : }

  00224	83 c4 10	 add	 esp, 16			; 00000010H
  00227	c3		 ret	 0
_EncryptionThreadPoolDoWork ENDP
_TEXT	ENDS
PUBLIC	_GetEncryptionThreadCount
; Function compile flags: /Ogtpy
;	COMDAT _GetEncryptionThreadCount
_TEXT	SEGMENT
_GetEncryptionThreadCount PROC				; COMDAT

; 494  : 	return ThreadPoolRunning ? ThreadCount : 0;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _ThreadPoolRunning
  00005	f7 d8		 neg	 eax
  00007	1b c0		 sbb	 eax, eax
  00009	23 05 00 00 00
	00		 and	 eax, DWORD PTR _ThreadCount

; 495  : }

  0000f	c3		 ret	 0
_GetEncryptionThreadCount ENDP
_TEXT	ENDS
PUBLIC	_GetMaxEncryptionThreadCount
; Function compile flags: /Ogtpy
;	COMDAT _GetMaxEncryptionThreadCount
_TEXT	SEGMENT
_GetMaxEncryptionThreadCount PROC			; COMDAT

; 500  : 	return TC_ENC_THREAD_POOL_MAX_THREAD_COUNT;

  00000	b8 40 00 00 00	 mov	 eax, 64			; 00000040H

; 501  : }

  00005	c3		 ret	 0
_GetMaxEncryptionThreadCount ENDP
_TEXT	ENDS
PUBLIC	_IsEncryptionThreadPoolRunning
; Function compile flags: /Ogtpy
;	COMDAT _IsEncryptionThreadPoolRunning
_TEXT	SEGMENT
_IsEncryptionThreadPoolRunning PROC			; COMDAT

; 506  : 	return ThreadPoolRunning;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _ThreadPoolRunning

; 507  : }

  00005	c3		 ret	 0
_IsEncryptionThreadPoolRunning ENDP
_TEXT	ENDS
PUBLIC	_EncryptionThreadPoolStart
EXTRN	__beginthreadex:PROC
EXTRN	__imp__CreateMutexA@12:PROC
EXTRN	__imp__CreateEventA@16:PROC
EXTRN	__imp__GetSystemInfo@4:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogtpy
;	COMDAT _EncryptionThreadPoolStart
_TEXT	SEGMENT
_sysInfo$78687 = -36					; size = 36
_encryptionFreeCpuCount$ = 8				; size = 4
_EncryptionThreadPoolStart PROC				; COMDAT

; 220  : 	size_t cpuCount, i;
; 221  : 
; 222  : 	if (ThreadPoolRunning)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _ThreadPoolRunning
  00005	83 ec 24	 sub	 esp, 36			; 00000024H
  00008	85 c0		 test	 eax, eax
  0000a	74 09		 je	 SHORT $LN16@Encryption@5

; 223  : 		return TRUE;

  0000c	b8 01 00 00 00	 mov	 eax, 1

; 307  : }

  00011	83 c4 24	 add	 esp, 36			; 00000024H
  00014	c3		 ret	 0
$LN16@Encryption@5:
  00015	55		 push	 ebp

; 224  : 
; 225  : #ifdef DEVICE_DRIVER
; 226  : 	cpuCount = GetCpuCount();
; 227  : #else
; 228  : 	{
; 229  : 		SYSTEM_INFO sysInfo;
; 230  : 		GetSystemInfo (&sysInfo);

  00016	8d 4c 24 04	 lea	 ecx, DWORD PTR _sysInfo$78687[esp+40]
  0001a	51		 push	 ecx
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemInfo@4

; 231  : 		cpuCount = sysInfo.dwNumberOfProcessors;

  00021	8b 44 24 18	 mov	 eax, DWORD PTR _sysInfo$78687[esp+60]

; 232  : 	}
; 233  : #endif
; 234  : 
; 235  : 	if (cpuCount > encryptionFreeCpuCount)

  00025	8b 4c 24 2c	 mov	 ecx, DWORD PTR _encryptionFreeCpuCount$[esp+36]
  00029	8b e8		 mov	 ebp, eax
  0002b	3b c1		 cmp	 eax, ecx
  0002d	76 04		 jbe	 SHORT $LN15@Encryption@5

; 236  : 		cpuCount -= encryptionFreeCpuCount;

  0002f	2b c1		 sub	 eax, ecx
  00031	8b e8		 mov	 ebp, eax
$LN15@Encryption@5:

; 237  : 
; 238  : 	if (cpuCount < 2)

  00033	83 fd 02	 cmp	 ebp, 2
  00036	73 0a		 jae	 SHORT $LN14@Encryption@5

; 239  : 		return TRUE;

  00038	b8 01 00 00 00	 mov	 eax, 1
  0003d	5d		 pop	 ebp

; 307  : }

  0003e	83 c4 24	 add	 esp, 36			; 00000024H
  00041	c3		 ret	 0
$LN14@Encryption@5:

; 240  : 
; 241  : 	if (cpuCount > TC_ENC_THREAD_POOL_MAX_THREAD_COUNT)

  00042	83 fd 40	 cmp	 ebp, 64			; 00000040H
  00045	76 05		 jbe	 SHORT $LN13@Encryption@5

; 242  : 		cpuCount = TC_ENC_THREAD_POOL_MAX_THREAD_COUNT;

  00047	bd 40 00 00 00	 mov	 ebp, 64			; 00000040H
$LN13@Encryption@5:
  0004c	53		 push	 ebx

; 243  : 
; 244  : 	StopPending = FALSE;

  0004d	33 db		 xor	 ebx, ebx
  0004f	57		 push	 edi

; 245  : 	DequeuePosition = 0;
; 246  : 	EnqueuePosition = 0;
; 247  : 
; 248  : #ifdef DEVICE_DRIVER
; 249  : 	KeInitializeEvent (&WorkItemReadyEvent, SynchronizationEvent, FALSE);
; 250  : 	KeInitializeEvent (&WorkItemCompletedEvent, SynchronizationEvent, FALSE);
; 251  : #else
; 252  : 	WorkItemReadyEvent = CreateEvent (NULL, FALSE, FALSE, NULL);

  00050	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__CreateEventA@16
  00056	53		 push	 ebx
  00057	53		 push	 ebx
  00058	89 1d 00 00 00
	00		 mov	 DWORD PTR _StopPending, ebx
  0005e	53		 push	 ebx
  0005f	89 1d 00 00 00
	00		 mov	 DWORD PTR _DequeuePosition, ebx
  00065	53		 push	 ebx
  00066	89 1d 00 00 00
	00		 mov	 DWORD PTR _EnqueuePosition, ebx
  0006c	ff d7		 call	 edi
  0006e	a3 00 00 00 00	 mov	 DWORD PTR _WorkItemReadyEvent, eax

; 253  : 	if (!WorkItemReadyEvent)

  00073	3b c3		 cmp	 eax, ebx

; 254  : 		return FALSE;

  00075	74 0f		 je	 SHORT $LN30@Encryption@5

; 255  : 	
; 256  : 	WorkItemCompletedEvent = CreateEvent (NULL, FALSE, FALSE, NULL);

  00077	53		 push	 ebx
  00078	53		 push	 ebx
  00079	53		 push	 ebx
  0007a	53		 push	 ebx
  0007b	ff d7		 call	 edi
  0007d	a3 00 00 00 00	 mov	 DWORD PTR _WorkItemCompletedEvent, eax

; 257  : 	if (!WorkItemCompletedEvent)

  00082	3b c3		 cmp	 eax, ebx
  00084	75 09		 jne	 SHORT $LN11@Encryption@5
$LN30@Encryption@5:
  00086	5f		 pop	 edi
  00087	5b		 pop	 ebx

; 258  : 		return FALSE;

  00088	33 c0		 xor	 eax, eax
  0008a	5d		 pop	 ebp

; 307  : }

  0008b	83 c4 24	 add	 esp, 36			; 00000024H
  0008e	c3		 ret	 0
$LN11@Encryption@5:
  0008f	56		 push	 esi

; 259  : #endif
; 260  : 	
; 261  : #ifdef DEVICE_DRIVER
; 262  : 	ExInitializeFastMutex (&DequeueMutex);
; 263  : 	ExInitializeFastMutex (&EnqueueMutex);
; 264  : #else
; 265  : 	DequeueMutex = CreateMutex (NULL, FALSE, NULL);

  00090	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CreateMutexA@12
  00096	53		 push	 ebx
  00097	53		 push	 ebx
  00098	53		 push	 ebx
  00099	ff d6		 call	 esi
  0009b	a3 00 00 00 00	 mov	 DWORD PTR _DequeueMutex, eax

; 266  : 	if (!DequeueMutex)

  000a0	3b c3		 cmp	 eax, ebx

; 267  : 		return FALSE;

  000a2	0f 84 a2 00 00
	00		 je	 $LN29@Encryption@5

; 268  : 
; 269  : 	EnqueueMutex = CreateMutex (NULL, FALSE, NULL);

  000a8	53		 push	 ebx
  000a9	53		 push	 ebx
  000aa	53		 push	 ebx
  000ab	ff d6		 call	 esi
  000ad	a3 00 00 00 00	 mov	 DWORD PTR _EnqueueMutex, eax

; 270  : 	if (!EnqueueMutex)

  000b2	3b c3		 cmp	 eax, ebx

; 271  : 		return FALSE;

  000b4	0f 84 90 00 00
	00		 je	 $LN29@Encryption@5

; 272  : #endif
; 273  : 
; 274  : 	memset (WorkItemQueue, 0, sizeof (WorkItemQueue));

  000ba	68 00 20 00 00	 push	 8192			; 00002000H
  000bf	53		 push	 ebx
  000c0	68 00 00 00 00	 push	 OFFSET _WorkItemQueue
  000c5	e8 00 00 00 00	 call	 _memset
  000ca	83 c4 0c	 add	 esp, 12			; 0000000cH

; 275  : 
; 276  : 	for (i = 0; i < sizeof (WorkItemQueue) / sizeof (WorkItemQueue[0]); ++i)

  000cd	33 f6		 xor	 esi, esi
  000cf	90		 npad	 1
$LL8@Encryption@5:

; 277  : 	{
; 278  : 		WorkItemQueue[i].State = WorkItemFree;
; 279  : 
; 280  : #ifdef DEVICE_DRIVER
; 281  : 		KeInitializeEvent (&WorkItemQueue[i].ItemCompletedEvent, SynchronizationEvent, FALSE);
; 282  : #else
; 283  : 		WorkItemQueue[i].ItemCompletedEvent = CreateEvent (NULL, FALSE, FALSE, NULL);

  000d0	53		 push	 ebx
  000d1	53		 push	 ebx
  000d2	53		 push	 ebx
  000d3	53		 push	 ebx
  000d4	89 9e 00 00 00
	00		 mov	 DWORD PTR _WorkItemQueue[esi], ebx
  000da	ff d7		 call	 edi
  000dc	89 86 08 00 00
	00		 mov	 DWORD PTR _WorkItemQueue[esi+8], eax

; 284  : 		if (!WorkItemQueue[i].ItemCompletedEvent)

  000e2	3b c3		 cmp	 eax, ebx
  000e4	74 5f		 je	 SHORT $LN22@Encryption@5
  000e6	83 c6 40	 add	 esi, 64			; 00000040H
  000e9	81 fe 00 20 00
	00		 cmp	 esi, 8192		; 00002000H
  000ef	72 df		 jb	 SHORT $LL8@Encryption@5

; 285  : 		{
; 286  : 			EncryptionThreadPoolStop();
; 287  : 			return FALSE;
; 288  : 		}
; 289  : #endif
; 290  : 	}
; 291  : 
; 292  : 	for (ThreadCount = 0; ThreadCount < cpuCount; ++ThreadCount)

  000f1	89 1d 00 00 00
	00		 mov	 DWORD PTR _ThreadCount, ebx
  000f7	3b eb		 cmp	 ebp, ebx
  000f9	76 33		 jbe	 SHORT $LN2@Encryption@5
  000fb	eb 03 8d 49 00	 npad	 5
$LL4@Encryption@5:

; 293  : 	{
; 294  : #ifdef DEVICE_DRIVER
; 295  : 		if (!NT_SUCCESS (TCStartThread (EncryptionThreadProc, NULL, &ThreadHandles[ThreadCount])))
; 296  : #else
; 297  : 		if (!(ThreadHandles[ThreadCount] = (HANDLE) _beginthreadex (NULL, 0, EncryptionThreadProc, NULL, 0, NULL)))

  00100	53		 push	 ebx
  00101	53		 push	 ebx
  00102	53		 push	 ebx
  00103	68 00 00 00 00	 push	 OFFSET _EncryptionThreadProc@4
  00108	53		 push	 ebx
  00109	53		 push	 ebx
  0010a	e8 00 00 00 00	 call	 __beginthreadex
  0010f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ThreadCount
  00115	83 c4 18	 add	 esp, 24			; 00000018H
  00118	89 04 8d 00 00
	00 00		 mov	 DWORD PTR _ThreadHandles[ecx*4], eax
  0011f	3b c3		 cmp	 eax, ebx
  00121	74 22		 je	 SHORT $LN22@Encryption@5
  00123	41		 inc	 ecx
  00124	89 0d 00 00 00
	00		 mov	 DWORD PTR _ThreadCount, ecx
  0012a	3b cd		 cmp	 ecx, ebp
  0012c	72 d2		 jb	 SHORT $LL4@Encryption@5
$LN2@Encryption@5:
  0012e	5e		 pop	 esi
  0012f	5f		 pop	 edi
  00130	5b		 pop	 ebx

; 302  : 		}
; 303  : 	}
; 304  : 
; 305  : 	ThreadPoolRunning = TRUE;

  00131	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _ThreadPoolRunning, 1

; 306  : 	return TRUE;

  0013b	b8 01 00 00 00	 mov	 eax, 1
  00140	5d		 pop	 ebp

; 307  : }

  00141	83 c4 24	 add	 esp, 36			; 00000024H
  00144	c3		 ret	 0
$LN22@Encryption@5:

; 298  : #endif
; 299  : 		{
; 300  : 			EncryptionThreadPoolStop();

  00145	e8 00 00 00 00	 call	 _EncryptionThreadPoolStop
$LN29@Encryption@5:
  0014a	5e		 pop	 esi
  0014b	5f		 pop	 edi
  0014c	5b		 pop	 ebx

; 301  : 			return FALSE;

  0014d	33 c0		 xor	 eax, eax
  0014f	5d		 pop	 ebp

; 307  : }

  00150	83 c4 24	 add	 esp, 36			; 00000024H
  00153	c3		 ret	 0
_EncryptionThreadPoolStart ENDP
_TEXT	ENDS
END
