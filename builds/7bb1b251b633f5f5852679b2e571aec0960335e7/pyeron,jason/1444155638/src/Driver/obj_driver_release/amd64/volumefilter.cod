; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	HiddenSysLeakProtectionCount
HiddenSysLeakProtectionCount DD 01H DUP (?)
PUBLIC	VolumeFilterAddDevice
;	COMDAT pdata
; File c:\users\public\desktop\projects\ciphershed\src\driver\volumefilter.c
pdata	SEGMENT
$pdata$VolumeFilterAddDevice DD imagerel $LN7
	DD	imagerel $LN7+291
	DD	imagerel $unwind$VolumeFilterAddDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$VolumeFilterAddDevice DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT VolumeFilterAddDevice
_TEXT	SEGMENT
driverObject$ = 80
pdo$ = 88
filterDeviceObject$ = 96
VolumeFilterAddDevice PROC				; COMDAT

; 23   : {

$LN7:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 24   : 	VolumeFilterExtension *Extension;
; 25   : 	NTSTATUS status;
; 26   : 	PDEVICE_OBJECT filterDeviceObject = NULL;

  0000f	48 83 64 24 60
	00		 and	 QWORD PTR filterDeviceObject$[rsp], 0
  00015	48 8b f9	 mov	 rdi, rcx

; 27   : 	PDEVICE_OBJECT attachedDeviceObject;
; 28   : 
; 29   : 	Dump ("VolumeFilterAddDevice pdo=%p\n", pdo);
; 30   : 
; 31   : 	attachedDeviceObject = IoGetAttachedDeviceReference (pdo);

  00018	48 8b ca	 mov	 rcx, rdx
  0001b	48 8b f2	 mov	 rsi, rdx
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetAttachedDeviceReference

; 32   : 	status = IoCreateDevice (driverObject, sizeof (VolumeFilterExtension), NULL, attachedDeviceObject->DeviceType, 0, FALSE, &filterDeviceObject);

  00024	45 33 c0	 xor	 r8d, r8d
  00027	48 8b d8	 mov	 rbx, rax
  0002a	48 8d 44 24 60	 lea	 rax, QWORD PTR filterDeviceObject$[rsp]
  0002f	ba e8 02 00 00	 mov	 edx, 744		; 000002e8H
  00034	44 8b 4b 48	 mov	 r9d, DWORD PTR [rbx+72]
  00038	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0003d	48 8b cf	 mov	 rcx, rdi
  00040	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00045	83 64 24 20 00	 and	 DWORD PTR [rsp+32], 0
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateDevice

; 33   : 
; 34   : 	ObDereferenceObject (attachedDeviceObject);

  00050	48 8b cb	 mov	 rcx, rbx
  00053	8b f8		 mov	 edi, eax
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 35   : 
; 36   : 	if (!NT_SUCCESS (status))

  0005b	85 ff		 test	 edi, edi

; 37   : 	{
; 38   : 		filterDeviceObject = NULL;
; 39   : 		goto err;

  0005d	0f 88 ae 00 00
	00		 js	 $LN2@VolumeFilt

; 40   : 	}
; 41   : 
; 42   : 	Extension = (VolumeFilterExtension *) filterDeviceObject->DeviceExtension;

  00063	48 8b 4c 24 60	 mov	 rcx, QWORD PTR filterDeviceObject$[rsp]

; 43   : 	memset (Extension, 0, sizeof (VolumeFilterExtension));

  00068	33 d2		 xor	 edx, edx
  0006a	41 b8 e8 02 00
	00		 mov	 r8d, 744		; 000002e8H
  00070	48 8b 59 40	 mov	 rbx, QWORD PTR [rcx+64]
  00074	48 8b cb	 mov	 rcx, rbx
  00077	e8 00 00 00 00	 call	 memset

; 44   : 
; 45   : 	Extension->LowerDeviceObject = IoAttachDeviceToDeviceStack (filterDeviceObject, pdo);  // IoAttachDeviceToDeviceStackSafe() is not required in AddDevice routine and is also unavailable on Windows 2000 SP4

  0007c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR filterDeviceObject$[rsp]
  00081	48 8b d6	 mov	 rdx, rsi
  00084	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAttachDeviceToDeviceStack
  0008a	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 46   : 	if (!Extension->LowerDeviceObject)

  0008e	48 85 c0	 test	 rax, rax
  00091	75 2a		 jne	 SHORT $LN3@VolumeFilt

; 60   : 
; 61   : 	return status;
; 62   : 
; 63   : err:
; 64   : 	if (filterDeviceObject)

  00093	48 8b 4c 24 60	 mov	 rcx, QWORD PTR filterDeviceObject$[rsp]
  00098	bf b6 02 00 c0	 mov	 edi, -1073741130	; ffffffffc00002b6H
$err$29367:
  0009d	48 85 c9	 test	 rcx, rcx
  000a0	74 6f		 je	 SHORT $LN2@VolumeFilt

; 65   : 	{
; 66   : 		if (Extension->LowerDeviceObject)

  000a2	48 3b c0	 cmp	 rax, rax
  000a5	74 0e		 je	 SHORT $LN1@VolumeFilt

; 67   : 			IoDetachDevice (Extension->LowerDeviceObject);

  000a7	48 8b c8	 mov	 rcx, rax
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDetachDevice
  000b0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR filterDeviceObject$[rsp]
$LN1@VolumeFilt:

; 68   : 
; 69   : 		IoDeleteDevice (filterDeviceObject);

  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteDevice
  000bb	eb 54		 jmp	 SHORT $LN2@VolumeFilt
$LN3@VolumeFilt:

; 47   : 	{
; 48   : 		status = STATUS_DEVICE_REMOVED;
; 49   : 		goto err;
; 50   : 	}
; 51   : 	
; 52   : 	Extension->IsVolumeFilterDevice = TRUE;

  000bd	c7 43 0c 01 00
	00 00		 mov	 DWORD PTR [rbx+12], 1

; 53   : 	Extension->DeviceObject = filterDeviceObject;

  000c4	48 8b 44 24 60	 mov	 rax, QWORD PTR filterDeviceObject$[rsp]

; 54   : 	Extension->Pdo = pdo;
; 55   : 
; 56   : 	IoInitializeRemoveLock (&Extension->Queue.RemoveLock, 'LRCT', 0, 0);

  000c9	48 8d 8b f0 00
	00 00		 lea	 rcx, QWORD PTR [rbx+240]
  000d0	45 33 c9	 xor	 r9d, r9d
  000d3	45 33 c0	 xor	 r8d, r8d
  000d6	ba 54 43 52 4c	 mov	 edx, 1280459604		; 4c524354H
  000db	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax
  000df	48 89 73 28	 mov	 QWORD PTR [rbx+40], rsi
  000e3	c7 44 24 20 20
	00 00 00	 mov	 DWORD PTR [rsp+32], 32	; 00000020H
  000eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoInitializeRemoveLockEx

; 57   : 
; 58   : 	filterDeviceObject->Flags |= Extension->LowerDeviceObject->Flags & (DO_DIRECT_IO | DO_BUFFERED_IO | DO_POWER_PAGABLE);

  000f1	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000f5	4c 8b 5c 24 60	 mov	 r11, QWORD PTR filterDeviceObject$[rsp]
  000fa	8b 48 30	 mov	 ecx, DWORD PTR [rax+48]
  000fd	81 e1 14 20 00
	00		 and	 ecx, 8212		; 00002014H
  00103	41 09 4b 30	 or	 DWORD PTR [r11+48], ecx

; 59   : 	filterDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

  00107	48 8b 44 24 60	 mov	 rax, QWORD PTR filterDeviceObject$[rsp]
  0010c	0f ba 70 30 07	 btr	 DWORD PTR [rax+48], 7
$LN2@VolumeFilt:

; 70   : 	}
; 71   : 
; 72   : 	return status;
; 73   : }

  00111	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00116	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  0011b	8b c7		 mov	 eax, edi
  0011d	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00121	5f		 pop	 rdi
  00122	c3		 ret	 0
VolumeFilterAddDevice ENDP
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$DispatchPower DD imagerel DispatchPower
	DD	imagerel DispatchPower+170
	DD	imagerel $unwind$DispatchPower
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DispatchPower DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogspy
; File c:\users\public\desktop\projects\ciphershed\src\driver\volumefilter.c
xdata	ENDS
;	COMDAT DispatchPower
_TEXT	SEGMENT
DeviceObject$ = 64
Irp$ = 72
Extension$ = 80
irpSp$ = 88
DispatchPower PROC					; COMDAT

; 245  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 246  : 	NTSTATUS status;
; 247  : 	PoStartNextPowerIrp (Irp);

  00014	48 8b ca	 mov	 rcx, rdx
  00017	49 8b f0	 mov	 rsi, r8
  0001a	48 8b fa	 mov	 rdi, rdx
  0001d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PoStartNextPowerIrp

; 248  : 
; 249  : 	status = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00023	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@FNODOBFM@
  0002a	48 8d 8e f0 00
	00 00		 lea	 rcx, QWORD PTR [rsi+240]
  00031	41 b9 01 00 00
	00		 mov	 r9d, 1
  00037	48 8b d7	 mov	 rdx, rdi
  0003a	c7 44 24 20 20
	00 00 00	 mov	 DWORD PTR [rsp+32], 32	; 00000020H
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAcquireRemoveLockEx
  00048	8b d8		 mov	 ebx, eax

; 250  : 	if (!NT_SUCCESS (status))

  0004a	85 c0		 test	 eax, eax
  0004c	79 15		 jns	 SHORT $LN1@DispatchPo

; 251  : 		return TCCompleteIrp (Irp, status, 0);

  0004e	48 83 67 38 00	 and	 QWORD PTR [rdi+56], 0
  00053	33 d2		 xor	 edx, edx
  00055	48 8b cf	 mov	 rcx, rdi
  00058	89 47 30	 mov	 DWORD PTR [rdi+48], eax
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest
  00061	eb 30		 jmp	 SHORT $LN8@DispatchPo
$LN1@DispatchPo:

; 252  : 
; 253  : 	IoSkipCurrentIrpStackLocation (Irp);

  00063	fe 47 43	 inc	 BYTE PTR [rdi+67]
  00066	48 83 87 b8 00
	00 00 48	 add	 QWORD PTR [rdi+184], 72	; 00000048H

; 254  : 	status = PoCallDriver (Extension->LowerDeviceObject, Irp);

  0006e	48 8b 4e 20	 mov	 rcx, QWORD PTR [rsi+32]
  00072	48 8b d7	 mov	 rdx, rdi
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PoCallDriver

; 255  : 
; 256  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  0007b	48 8d 8e f0 00
	00 00		 lea	 rcx, QWORD PTR [rsi+240]
  00082	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  00088	48 8b d7	 mov	 rdx, rdi
  0008b	8b d8		 mov	 ebx, eax
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx
$LN8@DispatchPo:

; 257  : 	return status;
; 258  : }

  00093	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00098	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0009d	8b c3		 mov	 eax, ebx
  0009f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a8	5f		 pop	 rdi
  000a9	c3		 ret	 0
DispatchPower ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT PassIrp
_TEXT	SEGMENT
deviceObject$ = 8
irp$ = 16
PassIrp	PROC						; COMDAT

; 78   : 	IoSkipCurrentIrpStackLocation (irp);

  00000	fe 42 43	 inc	 BYTE PTR [rdx+67]
  00003	48 83 82 b8 00
	00 00 48	 add	 QWORD PTR [rdx+184], 72	; 00000048H

; 79   : 	return IoCallDriver (deviceObject, irp);
; 80   : }

  0000b	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_IofCallDriver
PassIrp	ENDP
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$DispatchControl DD imagerel DispatchControl
	DD	imagerel DispatchControl+601
	DD	imagerel $unwind$DispatchControl
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DispatchControl DD 0d2001H
	DD	0217420H
	DD	0206420H
	DD	01f5420H
	DD	01e3420H
	DD	01a0120H
	DD	0d017e019H
	DD	0c015H
; Function compile flags: /Ogspy
; File c:\users\public\desktop\projects\ciphershed\src\driver\volumefilter.c
xdata	ENDS
;	COMDAT DispatchControl
_TEXT	SEGMENT
storageDeviceNumber$29439 = 48
partition$29447 = 64
DeviceObject$ = 240
Irp$ = 248
Extension$ = 256
irpSp$ = 264
DispatchControl PROC					; COMDAT

; 121  : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 54		 push	 r12
  00015	41 55		 push	 r13
  00017	41 56		 push	 r14
  00019	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  00020	49 8b e8	 mov	 rbp, r8

; 122  : 	NTSTATUS status = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00023	41 be 20 00 00
	00		 mov	 r14d, 32		; 00000020H
  00029	4d 8b e1	 mov	 r12, r9
  0002c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@FNODOBFM@
  00033	45 8d 4e e1	 lea	 r9d, QWORD PTR [r14-31]
  00037	48 8d 8d f0 00
	00 00		 lea	 rcx, QWORD PTR [rbp+240]
  0003e	48 8b fa	 mov	 rdi, rdx
  00041	44 89 74 24 20	 mov	 DWORD PTR [rsp+32], r14d
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAcquireRemoveLockEx

; 123  : 	if (!NT_SUCCESS (status))

  0004c	45 33 ed	 xor	 r13d, r13d
  0004f	8b d8		 mov	 ebx, eax
  00051	41 3b c5	 cmp	 eax, r13d
  00054	7d 08		 jge	 SHORT $LN13@DispatchCo

; 124  : 		return TCCompleteIrp (Irp, status, 0);

  00056	89 47 30	 mov	 DWORD PTR [rdi+48], eax
  00059	e9 f4 01 00 00	 jmp	 $LN39@DispatchCo
$LN13@DispatchCo:

; 125  : 
; 126  : 	if (IsHiddenSystemRunning())

  0005e	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR BootDriveFilterExtension
  00065	49 3b dd	 cmp	 rbx, r13
  00068	74 33		 je	 SHORT $LN10@DispatchCo
  0006a	44 39 ab e0 02
	00 00		 cmp	 DWORD PTR [rbx+736], r13d
  00071	74 2a		 je	 SHORT $LN10@DispatchCo

; 127  : 	{
; 128  : 		switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  00073	41 81 7c 24 18
	24 00 07 00	 cmp	 DWORD PTR [r12+24], 458788 ; 00070024H
  0007c	0f 84 ec 00 00
	00		 je	 $LN9@DispatchCo
  00082	ba 74 20 22 00	 mov	 edx, 2236532		; 00222074H
  00087	41 39 54 24 18	 cmp	 DWORD PTR [r12+24], edx
  0008c	74 60		 je	 SHORT $LN5@DispatchCo
  0008e	41 81 7c 24 18
	04 94 2d 00	 cmp	 DWORD PTR [r12+24], 2987012 ; 002d9404H
  00097	0f 84 63 01 00
	00		 je	 $LN43@DispatchCo
$LN10@DispatchCo:

; 181  : 
; 182  : 		case IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES:
; 183  : 
; 184  : 			// Filter IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES to enable potential future use of hidden systems on drives that use the trim operation but not wear-leveling (if any appear in future). The documentation forbids users to create hidden volumes/systems on drives that use wear-leveling and consequently also on drives that use trim (as trim is used only by drives that use wear-leveling, as of 2010).
; 185  : 
; 186  : 			IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);
; 187  : 			return TCCompleteDiskIrp (Irp, STATUS_SUCCESS, 0);
; 188  : 		}
; 189  : 	}
; 190  : 
; 191  : 	status = PassIrp (Extension->LowerDeviceObject, Irp);

  0009d	48 8b 4d 20	 mov	 rcx, QWORD PTR [rbp+32]
  000a1	fe 47 43	 inc	 BYTE PTR [rdi+67]
  000a4	48 83 87 b8 00
	00 00 48	 add	 QWORD PTR [rdi+184], 72	; 00000048H
  000ac	48 8b d7	 mov	 rdx, rdi
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCallDriver

; 192  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  000b5	48 8d 8d f0 00
	00 00		 lea	 rcx, QWORD PTR [rbp+240]
  000bc	45 8b c6	 mov	 r8d, r14d
  000bf	48 8b d7	 mov	 rdx, rdi
  000c2	8b d8		 mov	 ebx, eax
  000c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx
$LN41@DispatchCo:

; 193  : 	return status;

  000ca	8b c3		 mov	 eax, ebx
$LN14@DispatchCo:

; 194  : }

  000cc	4c 8d 9c 24 d0
	00 00 00	 lea	 r11, QWORD PTR [rsp+208]
  000d4	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  000d8	49 8b 6b 28	 mov	 rbp, QWORD PTR [r11+40]
  000dc	49 8b 73 30	 mov	 rsi, QWORD PTR [r11+48]
  000e0	49 8b 7b 38	 mov	 rdi, QWORD PTR [r11+56]
  000e4	49 8b e3	 mov	 rsp, r11
  000e7	41 5e		 pop	 r14
  000e9	41 5d		 pop	 r13
  000eb	41 5c		 pop	 r12
  000ed	c3		 ret	 0
$LN5@DispatchCo:

; 158  : 			}
; 159  : 
; 160  : 		case TC_IOCTL_DISK_IS_WRITABLE:
; 161  : 			Dump ("TC_IOCTL_DISK_IS_WRITABLE pdo=%p\n", Extension->Pdo);
; 162  : 
; 163  : 			if (!ProbingHostDeviceForWrite)

  000ee	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ProbingHostDeviceForWrite
  000f4	41 3b c5	 cmp	 eax, r13d
  000f7	74 a4		 je	 SHORT $LN10@DispatchCo

; 164  : 				break;
; 165  : 
; 166  : 			// Probe the real state of the device as the user is mounting a CipherShed volume.
; 167  : 
; 168  : 			// Volume filter may be attached to a merged drive+volume PDO. First test if TC_IOCTL_DISK_IS_WRITABLE works for the underlying device.
; 169  : 			status = SendDeviceIoControlRequest (Extension->LowerDeviceObject, TC_IOCTL_DISK_IS_WRITABLE, NULL, 0, NULL, 0);

  000f9	48 8b 4d 20	 mov	 rcx, QWORD PTR [rbp+32]
  000fd	45 33 c9	 xor	 r9d, r9d
  00100	45 33 c0	 xor	 r8d, r8d
  00103	44 89 6c 24 28	 mov	 DWORD PTR [rsp+40], r13d
  00108	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  0010d	e8 00 00 00 00	 call	 SendDeviceIoControlRequest

; 170  : 
; 171  : 			if (NT_SUCCESS (status) || status == STATUS_MEDIA_WRITE_PROTECTED)

  00112	41 3b c5	 cmp	 eax, r13d
  00115	8b d8		 mov	 ebx, eax
  00117	7d 27		 jge	 SHORT $LN2@DispatchCo
  00119	3d a2 00 00 c0	 cmp	 eax, -1073741662	; ffffffffc00000a2H
  0011e	74 20		 je	 SHORT $LN2@DispatchCo

; 172  : 			{
; 173  : 				IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);
; 174  : 				return TCCompleteDiskIrp (Irp, status, 0);
; 175  : 			}
; 176  : 
; 177  : 			status = SendDeviceIoControlRequest (Extension->LowerDeviceObject, IOCTL_DISK_IS_WRITABLE, NULL, 0, NULL, 0);

  00120	48 8b 4d 20	 mov	 rcx, QWORD PTR [rbp+32]
  00124	45 33 c9	 xor	 r9d, r9d
  00127	45 33 c0	 xor	 r8d, r8d
  0012a	ba 24 00 07 00	 mov	 edx, 458788		; 00070024H
  0012f	44 89 6c 24 28	 mov	 DWORD PTR [rsp+40], r13d
  00134	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  00139	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  0013e	8b d8		 mov	 ebx, eax
$LN2@DispatchCo:

; 178  : 
; 179  : 			IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00140	48 8d 8d f0 00
	00 00		 lea	 rcx, QWORD PTR [rbp+240]
  00147	45 8b c6	 mov	 r8d, r14d
  0014a	48 8b d7	 mov	 rdx, rdi
  0014d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 180  : 			return TCCompleteDiskIrp (Irp, status, 0);

  00153	41 3b dd	 cmp	 ebx, r13d
  00156	89 5f 30	 mov	 DWORD PTR [rdi+48], ebx
  00159	0f 9d c2	 setge	 dl
$LN44@DispatchCo:
  0015c	48 8b cf	 mov	 rcx, rdi
  0015f	4c 89 6f 38	 mov	 QWORD PTR [rdi+56], r13
  00163	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest
  00169	e9 5c ff ff ff	 jmp	 $LN41@DispatchCo
$LN9@DispatchCo:

; 129  : 		{
; 130  : 		case IOCTL_DISK_IS_WRITABLE:
; 131  : 			{
; 132  : 				// All volumes except the system volume must be read-only
; 133  : 
; 134  : 				DriveFilterExtension *bootDriveExtension = GetBootDriveFilterExtension();
; 135  : 				STORAGE_DEVICE_NUMBER storageDeviceNumber;
; 136  : 
; 137  : 				if (!bootDriveExtension->SystemStorageDeviceNumberValid)

  0016e	44 39 6b 34	 cmp	 DWORD PTR [rbx+52], r13d
  00172	75 22		 jne	 SHORT $LN8@DispatchCo

; 138  : 					TC_BUG_CHECK (STATUS_INVALID_PARAMETER);

  00174	ba 8a 00 00 00	 mov	 edx, 138		; 0000008aH
  00179	45 33 c9	 xor	 r9d, r9d
  0017c	49 c7 c0 0d 00
	00 c0		 mov	 r8, -1073741811		; ffffffffc000000dH
  00183	8d 4a 9f	 lea	 ecx, QWORD PTR [rdx-97]
  00186	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  0018f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00195	cc		 int	 3
$LN8@DispatchCo:

; 139  : 
; 140  : 				status = SendDeviceIoControlRequest (Extension->LowerDeviceObject, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0, &storageDeviceNumber, sizeof (storageDeviceNumber));

  00196	48 8b 4d 20	 mov	 rcx, QWORD PTR [rbp+32]
  0019a	48 8d 44 24 30	 lea	 rax, QWORD PTR storageDeviceNumber$29439[rsp]
  0019f	45 33 c9	 xor	 r9d, r9d
  001a2	45 33 c0	 xor	 r8d, r8d
  001a5	ba 80 10 2d 00	 mov	 edx, 2953344		; 002d1080H
  001aa	c7 44 24 28 0c
	00 00 00	 mov	 DWORD PTR [rsp+40], 12
  001b2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b7	e8 00 00 00 00	 call	 SendDeviceIoControlRequest

; 141  : 
; 142  : 				if (NT_SUCCESS (status) && bootDriveExtension->SystemStorageDeviceNumber == storageDeviceNumber.DeviceNumber)

  001bc	41 3b c5	 cmp	 eax, r13d
  001bf	7c 6c		 jl	 SHORT $LN6@DispatchCo
  001c1	8b 44 24 34	 mov	 eax, DWORD PTR storageDeviceNumber$29439[rsp+4]
  001c5	39 43 30	 cmp	 DWORD PTR [rbx+48], eax
  001c8	75 63		 jne	 SHORT $LN6@DispatchCo

; 143  : 				{
; 144  : 					PARTITION_INFORMATION_EX partition;
; 145  : 					status = SendDeviceIoControlRequest (Extension->LowerDeviceObject, IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0, &partition, sizeof (partition));

  001ca	48 8b 4d 20	 mov	 rcx, QWORD PTR [rbp+32]
  001ce	48 8d 44 24 40	 lea	 rax, QWORD PTR partition$29447[rsp]
  001d3	45 33 c9	 xor	 r9d, r9d
  001d6	45 33 c0	 xor	 r8d, r8d
  001d9	ba 48 00 07 00	 mov	 edx, 458824		; 00070048H
  001de	c7 44 24 28 90
	00 00 00	 mov	 DWORD PTR [rsp+40], 144	; 00000090H
  001e6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001eb	e8 00 00 00 00	 call	 SendDeviceIoControlRequest

; 146  : 
; 147  : 					if (NT_SUCCESS (status) && partition.StartingOffset.QuadPart == bootDriveExtension->ConfiguredEncryptedAreaStart)

  001f0	41 3b c5	 cmp	 eax, r13d
  001f3	7c 38		 jl	 SHORT $LN6@DispatchCo
  001f5	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  001f9	48 39 44 24 48	 cmp	 QWORD PTR partition$29447[rsp+8], rax
  001fe	75 2d		 jne	 SHORT $LN6@DispatchCo
$LN43@DispatchCo:

; 148  : 					{
; 149  : 						IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00200	48 8d 8d f0 00
	00 00		 lea	 rcx, QWORD PTR [rbp+240]
  00207	45 8b c6	 mov	 r8d, r14d
  0020a	48 8b d7	 mov	 rdx, rdi
  0020d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 150  : 						return TCCompleteDiskIrp (Irp, STATUS_SUCCESS, 0);

  00213	b2 01		 mov	 dl, 1
  00215	48 8b cf	 mov	 rcx, rdi
  00218	44 89 6f 30	 mov	 DWORD PTR [rdi+48], r13d
  0021c	4c 89 6f 38	 mov	 QWORD PTR [rdi+56], r13
  00220	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest
  00226	33 c0		 xor	 eax, eax
  00228	e9 9f fe ff ff	 jmp	 $LN14@DispatchCo
$LN6@DispatchCo:

; 151  : 					}
; 152  : 				}
; 153  : 
; 154  : 				IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  0022d	48 8d 8d f0 00
	00 00		 lea	 rcx, QWORD PTR [rbp+240]
  00234	45 8b c6	 mov	 r8d, r14d
  00237	48 8b d7	 mov	 rdx, rdi
  0023a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 155  : 
; 156  : 				++HiddenSysLeakProtectionCount;

  00240	ff 05 00 00 00
	00		 inc	 DWORD PTR HiddenSysLeakProtectionCount

; 157  : 				return TCCompleteDiskIrp (Irp, STATUS_MEDIA_WRITE_PROTECTED, 0);

  00246	c7 47 30 a2 00
	00 c0		 mov	 DWORD PTR [rdi+48], -1073741662 ; ffffffffc00000a2H
  0024d	bb a2 00 00 c0	 mov	 ebx, -1073741662	; ffffffffc00000a2H
$LN39@DispatchCo:

; 124  : 		return TCCompleteIrp (Irp, status, 0);

  00252	33 d2		 xor	 edx, edx
  00254	e9 03 ff ff ff	 jmp	 $LN44@DispatchCo
$LN40@DispatchCo:
DispatchControl ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$OnStartDeviceCompleted DD imagerel OnStartDeviceCompleted
	DD	imagerel OnStartDeviceCompleted+61
	DD	imagerel $unwind$OnStartDeviceCompleted
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$OnStartDeviceCompleted DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
; File c:\users\public\desktop\projects\ciphershed\src\driver\volumefilter.c
xdata	ENDS
;	COMDAT OnStartDeviceCompleted
_TEXT	SEGMENT
filterDeviceObject$ = 48
Irp$ = 56
Extension$ = 64
OnStartDeviceCompleted PROC				; COMDAT

; 108  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 109  : 	if (Irp->PendingReturned)

  00004	80 7a 41 00	 cmp	 BYTE PTR [rdx+65], 0
  00008	74 0b		 je	 SHORT $LN5@OnStartDev

; 110  : 		IoMarkIrpPending (Irp);

  0000a	48 8b 82 b8 00
	00 00		 mov	 rax, QWORD PTR [rdx+184]
  00011	80 48 03 01	 or	 BYTE PTR [rax+3], 1
$LN5@OnStartDev:

; 111  : 
; 112  : 	if (Extension->LowerDeviceObject->Characteristics & FILE_REMOVABLE_MEDIA)

  00015	49 8b 40 20	 mov	 rax, QWORD PTR [r8+32]
  00019	f6 40 34 01	 test	 BYTE PTR [rax+52], 1
  0001d	74 04		 je	 SHORT $LN1@OnStartDev

; 113  : 		filterDeviceObject->Characteristics |= FILE_REMOVABLE_MEDIA;

  0001f	83 49 34 01	 or	 DWORD PTR [rcx+52], 1
$LN1@OnStartDev:

; 114  : 
; 115  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00023	49 8d 88 f0 00
	00 00		 lea	 rcx, QWORD PTR [r8+240]
  0002a	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 116  : 	return STATUS_CONTINUE_COMPLETION;

  00036	33 c0		 xor	 eax, eax

; 117  : }

  00038	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003c	c3		 ret	 0
OnStartDeviceCompleted ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$OnDeviceUsageNotificationCompleted DD imagerel OnDeviceUsageNotificationCompleted
	DD	imagerel OnDeviceUsageNotificationCompleted+63
	DD	imagerel $unwind$OnDeviceUsageNotificationCompleted
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$OnDeviceUsageNotificationCompleted DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
; File c:\users\public\desktop\projects\ciphershed\src\driver\volumefilter.c
xdata	ENDS
;	COMDAT OnDeviceUsageNotificationCompleted
_TEXT	SEGMENT
filterDeviceObject$ = 48
Irp$ = 56
Extension$ = 64
OnDeviceUsageNotificationCompleted PROC			; COMDAT

; 95   : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 96   : 	if (Irp->PendingReturned)

  00004	80 7a 41 00	 cmp	 BYTE PTR [rdx+65], 0
  00008	74 0b		 je	 SHORT $LN5@OnDeviceUs

; 97   : 		IoMarkIrpPending (Irp);

  0000a	48 8b 82 b8 00
	00 00		 mov	 rax, QWORD PTR [rdx+184]
  00011	80 48 03 01	 or	 BYTE PTR [rax+3], 1
$LN5@OnDeviceUs:

; 98   : 
; 99   : 	if (!(Extension->LowerDeviceObject->Flags & DO_POWER_PAGABLE))

  00015	49 8b 40 20	 mov	 rax, QWORD PTR [r8+32]
  00019	0f ba 60 30 0d	 bt	 DWORD PTR [rax+48], 13
  0001e	72 05		 jb	 SHORT $LN1@OnDeviceUs

; 100  : 		filterDeviceObject->Flags &= ~DO_POWER_PAGABLE;

  00020	0f ba 71 30 0d	 btr	 DWORD PTR [rcx+48], 13
$LN1@OnDeviceUs:

; 101  : 
; 102  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00025	49 8d 88 f0 00
	00 00		 lea	 rcx, QWORD PTR [r8+240]
  0002c	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 103  : 	return STATUS_CONTINUE_COMPLETION;

  00038	33 c0		 xor	 eax, eax

; 104  : }

  0003a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003e	c3		 ret	 0
OnDeviceUsageNotificationCompleted ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$PassFilteredIrp DD imagerel PassFilteredIrp
	DD	imagerel PassFilteredIrp+129
	DD	imagerel $unwind$PassFilteredIrp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PassFilteredIrp DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0c0153219H
; Function compile flags: /Ogspy
; File c:\users\public\desktop\projects\ciphershed\src\driver\volumefilter.c
xdata	ENDS
;	COMDAT PassFilteredIrp
_TEXT	SEGMENT
deviceObject$ = 48
irp$ = 56
completionRoutine$ = 64
completionRoutineArg$ = 72
PassFilteredIrp PROC					; COMDAT

; 84   : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 54		 push	 r12
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00019	48 8b fa	 mov	 rdi, rdx

; 85   : 	IoCopyCurrentIrpStackLocationToNext (irp);

  0001c	48 8b 92 b8 00
	00 00		 mov	 rdx, QWORD PTR [rdx+184]
  00023	49 8b f0	 mov	 rsi, r8
  00026	48 8d 5a b8	 lea	 rbx, QWORD PTR [rdx-72]
  0002a	48 8b e9	 mov	 rbp, rcx
  0002d	41 b8 38 00 00
	00		 mov	 r8d, 56			; 00000038H
  00033	48 8b cb	 mov	 rcx, rbx
  00036	4d 8b e1	 mov	 r12, r9
  00039	e8 00 00 00 00	 call	 memcpy
  0003e	c6 43 03 00	 mov	 BYTE PTR [rbx+3], 0

; 86   : 
; 87   : 	if (completionRoutine)

  00042	48 85 f6	 test	 rsi, rsi
  00045	74 13		 je	 SHORT $LN10@PassFilter

; 88   : 		IoSetCompletionRoutine (irp, completionRoutine, completionRoutineArg, TRUE, TRUE, TRUE);

  00047	48 8b 87 b8 00
	00 00		 mov	 rax, QWORD PTR [rdi+184]
  0004e	48 89 70 f0	 mov	 QWORD PTR [rax-16], rsi
  00052	4c 89 60 f8	 mov	 QWORD PTR [rax-8], r12
  00056	c6 40 bb e0	 mov	 BYTE PTR [rax-69], 224	; 000000e0H
$LN10@PassFilter:

; 89   : 
; 90   : 	return IoCallDriver (deviceObject, irp);

  0005a	48 8b d7	 mov	 rdx, rdi
  0005d	48 8b cd	 mov	 rcx, rbp

; 91   : }

  00060	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00065	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0006a	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0006f	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00074	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00078	41 5c		 pop	 r12
  0007a	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_IofCallDriver
PassFilteredIrp ENDP
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$DispatchPnp DD imagerel DispatchPnp
	DD	imagerel DispatchPnp+335
	DD	imagerel $unwind$DispatchPnp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DispatchPnp DD 0a1801H
	DD	0c6418H
	DD	0b5418H
	DD	0a3418H
	DD	0d0145218H
	DD	07010c012H
; Function compile flags: /Ogspy
; File c:\users\public\desktop\projects\ciphershed\src\driver\volumefilter.c
xdata	ENDS
;	COMDAT DispatchPnp
_TEXT	SEGMENT
DeviceObject$ = 80
Irp$ = 88
Extension$ = 96
irpSp$ = 104
DispatchPnp PROC					; COMDAT

; 198  : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00018	49 8b e8	 mov	 rbp, r8
  0001b	48 8b f1	 mov	 rsi, rcx
  0001e	4d 8b e1	 mov	 r12, r9

; 199  : 	NTSTATUS status;
; 200  : 
; 201  : 	status = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00021	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@FNODOBFM@
  00028	48 8d 8d f0 00
	00 00		 lea	 rcx, QWORD PTR [rbp+240]
  0002f	41 b9 01 00 00
	00		 mov	 r9d, 1
  00035	48 8b fa	 mov	 rdi, rdx
  00038	c7 40 d8 20 00
	00 00		 mov	 DWORD PTR [rax-40], 32	; 00000020H
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAcquireRemoveLockEx
  00045	8b d8		 mov	 ebx, eax

; 202  : 	if (!NT_SUCCESS (status))

  00047	85 c0		 test	 eax, eax
  00049	79 1a		 jns	 SHORT $LN9@DispatchPn

; 203  : 		return TCCompleteIrp (Irp, status, 0);

  0004b	48 83 67 38 00	 and	 QWORD PTR [rdi+56], 0
  00050	33 d2		 xor	 edx, edx
  00052	48 8b cf	 mov	 rcx, rdi
  00055	89 47 30	 mov	 DWORD PTR [rdi+48], eax
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest
$LN23@DispatchPn:
  0005e	8b c3		 mov	 eax, ebx
  00060	e9 d1 00 00 00	 jmp	 $LN10@DispatchPn
$LN9@DispatchPn:

; 204  : 
; 205  : 	switch (irpSp->MinorFunction)

  00065	41 8a 44 24 01	 mov	 al, BYTE PTR [r12+1]
  0006a	84 c0		 test	 al, al
  0006c	0f 84 ae 00 00
	00		 je	 $LN6@DispatchPn
  00072	3c 02		 cmp	 al, 2
  00074	74 62		 je	 SHORT $LN2@DispatchPn
  00076	3c 16		 cmp	 al, 22
  00078	74 32		 je	 SHORT $LN5@DispatchPn

; 234  : 
; 235  : 	default:
; 236  : 		status = PassIrp (Extension->LowerDeviceObject, Irp);

  0007a	48 8b 4d 20	 mov	 rcx, QWORD PTR [rbp+32]
  0007e	fe 47 43	 inc	 BYTE PTR [rdi+67]
  00081	48 83 87 b8 00
	00 00 48	 add	 QWORD PTR [rdi+184], 72	; 00000048H
  00089	48 8b d7	 mov	 rdx, rdi
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCallDriver

; 237  : 		IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00092	48 8d 8d f0 00
	00 00		 lea	 rcx, QWORD PTR [rbp+240]
  00099	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  0009f	48 8b d7	 mov	 rdx, rdi
  000a2	8b d8		 mov	 ebx, eax
  000a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 238  : 	}
; 239  : 
; 240  : 	return status;

  000aa	eb b2		 jmp	 SHORT $LN23@DispatchPn
$LN5@DispatchPn:

; 210  : 
; 211  : 	case IRP_MN_DEVICE_USAGE_NOTIFICATION:
; 212  : 		{
; 213  : 			PDEVICE_OBJECT attachedDevice = IoGetAttachedDeviceReference (DeviceObject);

  000ac	48 8b ce	 mov	 rcx, rsi
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetAttachedDeviceReference

; 214  : 
; 215  : 			if (attachedDevice == DeviceObject || (attachedDevice->Flags & DO_POWER_PAGABLE))

  000b5	48 3b c6	 cmp	 rax, rsi
  000b8	74 07		 je	 SHORT $LN3@DispatchPn
  000ba	0f ba 60 30 0d	 bt	 DWORD PTR [rax+48], 13
  000bf	73 05		 jae	 SHORT $LN4@DispatchPn
$LN3@DispatchPn:

; 216  : 				DeviceObject->Flags |= DO_POWER_PAGABLE;

  000c1	0f ba 6e 30 0d	 bts	 DWORD PTR [rsi+48], 13
$LN4@DispatchPn:

; 217  : 
; 218  : 			ObDereferenceObject (attachedDevice);

  000c6	48 8b c8	 mov	 rcx, rax
  000c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 219  : 		}
; 220  : 
; 221  : 		return PassFilteredIrp (Extension->LowerDeviceObject, Irp, OnDeviceUsageNotificationCompleted, Extension);

  000cf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:OnDeviceUsageNotificationCompleted
  000d6	eb 4f		 jmp	 SHORT $LN22@DispatchPn
$LN2@DispatchPn:

; 222  : 
; 223  : 
; 224  : 	case IRP_MN_REMOVE_DEVICE:
; 225  : 		Dump ("IRP_MN_REMOVE_DEVICE volume pdo=%p\n", Extension->Pdo);
; 226  : 
; 227  : 		IoReleaseRemoveLockAndWait (&Extension->Queue.RemoveLock, Irp);

  000d8	48 8d 8d f0 00
	00 00		 lea	 rcx, QWORD PTR [rbp+240]
  000df	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  000e5	48 8b d7	 mov	 rdx, rdi
  000e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockAndWaitEx

; 228  : 		status = PassIrp (Extension->LowerDeviceObject, Irp);

  000ee	48 8b 4d 20	 mov	 rcx, QWORD PTR [rbp+32]
  000f2	fe 47 43	 inc	 BYTE PTR [rdi+67]
  000f5	48 83 87 b8 00
	00 00 48	 add	 QWORD PTR [rdi+184], 72	; 00000048H
  000fd	48 8b d7	 mov	 rdx, rdi
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCallDriver

; 229  : 
; 230  : 		IoDetachDevice (Extension->LowerDeviceObject);

  00106	48 8b 4d 20	 mov	 rcx, QWORD PTR [rbp+32]
  0010a	8b d8		 mov	 ebx, eax
  0010c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDetachDevice

; 231  : 
; 232  : 		IoDeleteDevice (DeviceObject);

  00112	48 8b ce	 mov	 rcx, rsi
  00115	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteDevice

; 233  : 		return status;

  0011b	e9 3e ff ff ff	 jmp	 $LN23@DispatchPn
$LN6@DispatchPn:

; 206  : 	{
; 207  : 	case IRP_MN_START_DEVICE:
; 208  : 		Dump ("IRP_MN_START_DEVICE volume pdo=%p\n", Extension->Pdo);
; 209  : 		return PassFilteredIrp (Extension->LowerDeviceObject, Irp, OnStartDeviceCompleted, Extension);

  00120	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:OnStartDeviceCompleted
$LN22@DispatchPn:
  00127	48 8b 4d 20	 mov	 rcx, QWORD PTR [rbp+32]
  0012b	4c 8b cd	 mov	 r9, rbp
  0012e	48 8b d7	 mov	 rdx, rdi
  00131	e8 00 00 00 00	 call	 PassFilteredIrp
$LN10@DispatchPn:

; 241  : }

  00136	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0013b	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00140	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00145	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00149	41 5d		 pop	 r13
  0014b	41 5c		 pop	 r12
  0014d	5f		 pop	 rdi
  0014e	c3		 ret	 0
DispatchPnp ENDP
PUBLIC	VolumeFilterDispatchIrp
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$VolumeFilterDispatchIrp DD imagerel $LN27
	DD	imagerel $LN27+290
	DD	imagerel $unwind$VolumeFilterDispatchIrp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$VolumeFilterDispatchIrp DD 081501H
	DD	0a7415H
	DD	096415H
	DD	083415H
	DD	0c0115215H
; Function compile flags: /Ogspy
; File c:\users\public\desktop\projects\ciphershed\src\driver\volumefilter.c
xdata	ENDS
;	COMDAT VolumeFilterDispatchIrp
_TEXT	SEGMENT
DeviceObject$ = 64
Irp$ = 72
VolumeFilterDispatchIrp PROC				; COMDAT

; 262  : {

$LN27:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0000b	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi
  0000f	41 54		 push	 r12
  00011	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 263  : 	VolumeFilterExtension *Extension = (VolumeFilterExtension *) DeviceObject->DeviceExtension;
; 264  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);

  00015	4c 8b 8a b8 00
	00 00		 mov	 r9, QWORD PTR [rdx+184]
  0001c	48 8b 71 40	 mov	 rsi, QWORD PTR [rcx+64]
  00020	48 8b fa	 mov	 rdi, rdx

; 265  : 	NTSTATUS status;
; 266  : 
; 267  : 	ASSERT (!Extension->bRootDevice && Extension->IsVolumeFilterDevice);
; 268  : 
; 269  : 	switch (irpSp->MajorFunction)

  00023	41 80 39 0e	 cmp	 BYTE PTR [r9], 14
  00027	0f 84 d7 00 00
	00		 je	 $LN5@VolumeFilt@2
  0002d	41 80 39 16	 cmp	 BYTE PTR [r9], 22
  00031	74 54		 je	 SHORT $LN3@VolumeFilt@2
  00033	41 80 39 1b	 cmp	 BYTE PTR [r9], 27
  00037	74 41		 je	 SHORT $LN4@VolumeFilt@2

; 279  : 
; 280  : 	default:
; 281  : 		status = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00039	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@FNODOBFM@
  00040	48 8d 8e f0 00
	00 00		 lea	 rcx, QWORD PTR [rsi+240]
  00047	41 b9 01 00 00
	00		 mov	 r9d, 1
  0004d	c7 40 e8 20 00
	00 00		 mov	 DWORD PTR [rax-24], 32	; 00000020H
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAcquireRemoveLockEx
  0005a	8b d8		 mov	 ebx, eax

; 282  : 		if (!NT_SUCCESS (status))

  0005c	85 c0		 test	 eax, eax

; 283  : 			return TCCompleteIrp (Irp, status, 0);

  0005e	78 5b		 js	 SHORT $LN26@VolumeFilt@2

; 284  : 
; 285  : 		status = PassIrp (Extension->LowerDeviceObject, Irp);

  00060	48 8b 4e 20	 mov	 rcx, QWORD PTR [rsi+32]
  00064	fe 47 43	 inc	 BYTE PTR [rdi+67]
  00067	48 83 87 b8 00
	00 00 48	 add	 QWORD PTR [rdi+184], 72	; 00000048H
  0006f	48 8b d7	 mov	 rdx, rdi
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCallDriver

; 286  : 
; 287  : 		IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);
; 288  : 		return status;

  00078	eb 6e		 jmp	 SHORT $LN25@VolumeFilt@2
$LN4@VolumeFilt@2:

; 273  : 
; 274  : 	case IRP_MJ_PNP:
; 275  : 		return DispatchPnp (DeviceObject, Irp, Extension, irpSp);

  0007a	4c 8b c6	 mov	 r8, rsi
  0007d	e8 00 00 00 00	 call	 DispatchPnp
  00082	e9 85 00 00 00	 jmp	 $LN6@VolumeFilt@2
$LN3@VolumeFilt@2:

; 276  : 
; 277  : 	case IRP_MJ_POWER:
; 278  : 		return DispatchPower (DeviceObject, Irp, Extension, irpSp);

  00087	48 8b ca	 mov	 rcx, rdx
  0008a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PoStartNextPowerIrp
  00090	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@FNODOBFM@
  00097	48 8d 8e f0 00
	00 00		 lea	 rcx, QWORD PTR [rsi+240]
  0009e	41 b9 01 00 00
	00		 mov	 r9d, 1
  000a4	48 8b d7	 mov	 rdx, rdi
  000a7	c7 44 24 20 20
	00 00 00	 mov	 DWORD PTR [rsp+32], 32	; 00000020H
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAcquireRemoveLockEx
  000b5	8b d8		 mov	 ebx, eax
  000b7	85 c0		 test	 eax, eax
  000b9	79 15		 jns	 SHORT $LN12@VolumeFilt@2
$LN26@VolumeFilt@2:
  000bb	48 83 67 38 00	 and	 QWORD PTR [rdi+56], 0
  000c0	33 d2		 xor	 edx, edx
  000c2	48 8b cf	 mov	 rcx, rdi
  000c5	89 47 30	 mov	 DWORD PTR [rdi+48], eax
  000c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest
  000ce	eb 30		 jmp	 SHORT $LN13@VolumeFilt@2
$LN12@VolumeFilt@2:
  000d0	fe 47 43	 inc	 BYTE PTR [rdi+67]
  000d3	48 83 87 b8 00
	00 00 48	 add	 QWORD PTR [rdi+184], 72	; 00000048H
  000db	48 8b 4e 20	 mov	 rcx, QWORD PTR [rsi+32]
  000df	48 8b d7	 mov	 rdx, rdi
  000e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PoCallDriver
$LN25@VolumeFilt@2:
  000e8	48 8d 8e f0 00
	00 00		 lea	 rcx, QWORD PTR [rsi+240]
  000ef	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  000f5	48 8b d7	 mov	 rdx, rdi
  000f8	8b d8		 mov	 ebx, eax
  000fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx
$LN13@VolumeFilt@2:
  00100	8b c3		 mov	 eax, ebx
  00102	eb 08		 jmp	 SHORT $LN6@VolumeFilt@2
$LN5@VolumeFilt@2:

; 270  : 	{
; 271  : 	case IRP_MJ_DEVICE_CONTROL:
; 272  : 		return DispatchControl (DeviceObject, Irp, Extension, irpSp);

  00104	4c 8b c6	 mov	 r8, rsi
  00107	e8 00 00 00 00	 call	 DispatchControl
$LN6@VolumeFilt@2:

; 289  : 	}
; 290  : }

  0010c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00111	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00116	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  0011b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0011f	41 5c		 pop	 r12
  00121	c3		 ret	 0
VolumeFilterDispatchIrp ENDP
END
