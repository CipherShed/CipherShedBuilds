; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\home\public\Desktop\projects\ciphershed.build\src\Common\dialog\errors.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0P@GHFPNOJB@bad?5allocation?$AA@		; `string'
PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	_Silent
_BSS	SEGMENT
_Silent	DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
_DATA	ENDS
;	COMDAT ??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
CONST	SEGMENT
??_C@_0P@GHFPNOJB@bad?5allocation?$AA@ DB 'bad allocation', 00H ; `string'
CONST	ENDS
EXTRN	__vswprintf_c_l:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\swprintf.inl
;	COMDAT _swprintf
_TEXT	SEGMENT
__String$ = 8						; size = 4
__Format$ = 12						; size = 4
_swprintf PROC						; COMDAT
; __Count$ = edx

; 38   :     va_list _Arglist;
; 39   :     int _Ret;
; 40   :     _crt_va_start(_Arglist, _Format);
; 41   :     _Ret = _vswprintf_c_l(_String, _Count, _Format, NULL, _Arglist);

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Format$[esp-4]
  00004	8d 44 24 0c	 lea	 eax, DWORD PTR __Format$[esp]
  00008	50		 push	 eax
  00009	8b 44 24 08	 mov	 eax, DWORD PTR __String$[esp]
  0000d	6a 00		 push	 0
  0000f	51		 push	 ecx
  00010	52		 push	 edx
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 __vswprintf_c_l
  00017	83 c4 14	 add	 esp, 20			; 00000014H

; 42   :     _crt_va_end(_Arglist);
; 43   :     return _Ret;
; 44   : }

  0001a	c3		 ret	 0
_swprintf ENDP
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

  00000	56		 push	 esi
  00001	8d 44 24 08	 lea	 eax, DWORD PTR __Message$[esp]
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

  00006	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00009	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000e	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  00013	74 09		 je	 SHORT $LN6@scalar
  00015	56		 push	 esi
  00016	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001b	83 c4 04	 add	 esp, 4
$LN6@scalar:
  0001e	8b c6		 mov	 eax, esi
  00020	5e		 pop	 esi
  00021	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	_wmemcpy_s
EXTRN	_memcpy_s:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\wchar.h
;	COMDAT _wmemcpy_s
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__N1$ = 12						; size = 4
__S2$ = 16						; size = 4
__N$ = 20						; size = 4
_wmemcpy_s PROC						; COMDAT

; 1232 : #pragma warning( push )
; 1233 : #pragma warning( disable : 6386 )
; 1234 :             return memcpy_s(_S1, _N1*sizeof(wchar_t), _S2, _N*sizeof(wchar_t));

  00000	8b 44 24 10	 mov	 eax, DWORD PTR __N$[esp-4]
  00004	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00007	89 4c 24 10	 mov	 DWORD PTR __N$[esp-4], ecx
  0000b	8b 44 24 08	 mov	 eax, DWORD PTR __N1$[esp-4]
  0000f	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00012	89 4c 24 08	 mov	 DWORD PTR __N1$[esp-4], ecx
  00016	e9 00 00 00 00	 jmp	 _memcpy_s
_wmemcpy_s ENDP
_TEXT	ENDS
PUBLIC	_wmemmove_s
EXTRN	_memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT _wmemmove_s
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__N1$ = 12						; size = 4
__S2$ = 16						; size = 4
__N$ = 20						; size = 4
_wmemmove_s PROC					; COMDAT

; 1252 : #pragma warning( push )
; 1253 : #pragma warning( disable : 6386 )
; 1254 :             return memmove_s(_S1, _N1*sizeof(wchar_t), _S2, _N*sizeof(wchar_t));

  00000	8b 44 24 10	 mov	 eax, DWORD PTR __N$[esp-4]
  00004	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00007	89 4c 24 10	 mov	 DWORD PTR __N$[esp-4], ecx
  0000b	8b 44 24 08	 mov	 eax, DWORD PTR __N1$[esp-4]
  0000f	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00012	89 4c 24 08	 mov	 DWORD PTR __N1$[esp-4], ecx
  00016	e9 00 00 00 00	 jmp	 _memmove_s
_wmemmove_s ENDP
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z	; std::char_traits<wchar_t>::assign
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z PROC	; std::char_traits<wchar_t>::assign, COMDAT

; 310  : 		_Left = _Right;

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Right$[esp-4]
  00004	66 8b 08	 mov	 cx, WORD PTR [eax]
  00007	8b 54 24 04	 mov	 edx, DWORD PTR __Left$[esp-4]
  0000b	66 89 0a	 mov	 WORD PTR [edx], cx

; 311  : 		}

  0000e	c3		 ret	 0
?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ENDP	; std::char_traits<wchar_t>::assign
_TEXT	ENDS
PUBLIC	?length@?$char_traits@_W@std@@SAIPB_W@Z		; std::char_traits<wchar_t>::length
; Function compile flags: /Ogtpy
;	COMDAT ?length@?$char_traits@_W@std@@SAIPB_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@_W@std@@SAIPB_W@Z PROC		; std::char_traits<wchar_t>::length, COMDAT

; 333  : //		_DEBUG_POINTER(_First);
; 334  : 		return (::wcslen(_First));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
$LL3@length:
  00007	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000a	83 c0 02	 add	 eax, 2
  0000d	66 85 c9	 test	 cx, cx
  00010	75 f5		 jne	 SHORT $LL3@length
  00012	2b c2		 sub	 eax, edx
  00014	d1 f8		 sar	 eax, 1

; 335  : 		}

  00016	c3		 ret	 0
?length@?$char_traits@_W@std@@SAIPB_W@Z ENDP		; std::char_traits<wchar_t>::length
_TEXT	ENDS
PUBLIC	?_Copy_s@?$char_traits@_W@std@@SAPA_WPA_WIPB_WI@Z ; std::char_traits<wchar_t>::_Copy_s
; Function compile flags: /Ogtpy
;	COMDAT ?_Copy_s@?$char_traits@_W@std@@SAPA_WPA_WIPB_WI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size_in_words$ = 12					; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
?_Copy_s@?$char_traits@_W@std@@SAPA_WPA_WIPB_WI@Z PROC	; std::char_traits<wchar_t>::_Copy_s, COMDAT

; 348  : //		_DEBUG_POINTER(_First1);
; 349  : //		_DEBUG_POINTER(_First2);
; 350  : 		_CRT_SECURE_WMEMCPY(_First1, _Size_in_words, _First2, _Count);

  00000	8b 44 24 10	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8b 54 24 0c	 mov	 edx, DWORD PTR __First2$[esp-4]
  00008	56		 push	 esi
  00009	8b 74 24 08	 mov	 esi, DWORD PTR __First1$[esp]
  0000d	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00010	8b 44 24 0c	 mov	 eax, DWORD PTR __Size_in_words$[esp]
  00014	51		 push	 ecx
  00015	52		 push	 edx
  00016	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00019	51		 push	 ecx
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 _memcpy_s
  00020	83 c4 10	 add	 esp, 16			; 00000010H

; 351  : 		return _First1;

  00023	8b c6		 mov	 eax, esi
  00025	5e		 pop	 esi

; 352  : 		}

  00026	c3		 ret	 0
?_Copy_s@?$char_traits@_W@std@@SAPA_WPA_WIPB_WI@Z ENDP	; std::char_traits<wchar_t>::_Copy_s
_TEXT	ENDS
PUBLIC	?_Move_s@?$char_traits@_W@std@@SAPA_WPA_WIPB_WI@Z ; std::char_traits<wchar_t>::_Move_s
; Function compile flags: /Ogtpy
;	COMDAT ?_Move_s@?$char_traits@_W@std@@SAPA_WPA_WIPB_WI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size_in_words$ = 12					; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
?_Move_s@?$char_traits@_W@std@@SAPA_WPA_WIPB_WI@Z PROC	; std::char_traits<wchar_t>::_Move_s, COMDAT

; 372  : //		_DEBUG_POINTER(_First1);
; 373  : //		_DEBUG_POINTER(_First2);
; 374  : 		_CRT_SECURE_WMEMMOVE(_First1, _Size_in_words, _First2, _Count);

  00000	8b 44 24 10	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8b 54 24 0c	 mov	 edx, DWORD PTR __First2$[esp-4]
  00008	56		 push	 esi
  00009	8b 74 24 08	 mov	 esi, DWORD PTR __First1$[esp]
  0000d	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00010	8b 44 24 0c	 mov	 eax, DWORD PTR __Size_in_words$[esp]
  00014	51		 push	 ecx
  00015	52		 push	 edx
  00016	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00019	51		 push	 ecx
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 _memmove_s
  00020	83 c4 10	 add	 esp, 16			; 00000010H

; 375  : 		return (_Elem *)_First1;

  00023	8b c6		 mov	 eax, esi
  00025	5e		 pop	 esi

; 376  : 		}

  00026	c3		 ret	 0
?_Move_s@?$char_traits@_W@std@@SAPA_WPA_WIPB_WI@Z ENDP	; std::char_traits<wchar_t>::_Move_s
_TEXT	ENDS
PUBLIC	_translateWin32Error
EXTRN	__imp__SetLastError@4:PROC
EXTRN	__imp__FormatMessageW@28:PROC
EXTRN	__imp__GetLastError@0:PROC
; Function compile flags: /Ogtpy
; File c:\home\public\desktop\projects\ciphershed.build\src\common\dialog\errors.cpp
;	COMDAT _translateWin32Error
_TEXT	SEGMENT
_lpszMsgBuf$ = 8					; size = 4
_nWSizeOfBuf$ = 12					; size = 4
_translateWin32Error PROC				; COMDAT

; 74   : {

  00000	56		 push	 esi

; 75   : 	DWORD dwError = GetLastError ();

  00001	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 76   : 
; 77   : 	if (FormatMessageW (FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwError,
; 78   : 			   MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT),	/* Default language */
; 79   : 			   (LPWSTR)lpszMsgBuf, nWSizeOfBuf, NULL))

  00007	8b 4c 24 08	 mov	 ecx, DWORD PTR _lpszMsgBuf$[esp]
  0000b	6a 00		 push	 0
  0000d	8b f0		 mov	 esi, eax
  0000f	8b 44 24 10	 mov	 eax, DWORD PTR _nWSizeOfBuf$[esp+4]
  00013	50		 push	 eax
  00014	51		 push	 ecx
  00015	68 00 04 00 00	 push	 1024			; 00000400H
  0001a	56		 push	 esi
  0001b	6a 00		 push	 0
  0001d	68 00 10 00 00	 push	 4096			; 00001000H
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FormatMessageW@28

; 80   : 	{
; 81   : 		SetLastError (dwError);		// Preserve the original error code

  00028	56		 push	 esi
  00029	85 c0		 test	 eax, eax
  0002b	74 0d		 je	 SHORT $LN1@translateW
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 82   : 		return TRUE;

  00033	b8 01 00 00 00	 mov	 eax, 1
  00038	5e		 pop	 esi

; 87   : }

  00039	c3		 ret	 0
$LN1@translateW:

; 83   : 	}
; 84   : 
; 85   : 	SetLastError (dwError);			// Preserve the original error code

  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 86   : 	return FALSE;

  00040	33 c0		 xor	 eax, eax
  00042	5e		 pop	 esi

; 87   : }

  00043	c3		 ret	 0
_translateWin32Error ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?TaskBarIconDisplayBalloonTooltip@@YAXPAUHWND__@@PB_W1H@Z ; TaskBarIconDisplayBalloonTooltip
EXTRN	__imp__Shell_NotifyIconW@8:PROC
EXTRN	_wcsncpy:PROC
EXTRN	_IsOSAtLeast:PROC
EXTRN	__imp__MessageBoxW@16:PROC
EXTRN	_MainDlg:DWORD
EXTRN	_nCurrentOS:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?TaskBarIconDisplayBalloonTooltip@@YAXPAUHWND__@@PB_W1H@Z
_TEXT	SEGMENT
_tnid$ = -960						; size = 956
__$ArrayPad$ = -4					; size = 4
_hwnd$ = 8						; size = 4
_headline$ = 12						; size = 4
_text$ = 16						; size = 4
_warning$ = 20						; size = 4
?TaskBarIconDisplayBalloonTooltip@@YAXPAUHWND__@@PB_W1H@Z PROC ; TaskBarIconDisplayBalloonTooltip, COMDAT

; 228  : {

  00000	81 ec c0 03 00
	00		 sub	 esp, 960		; 000003c0H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 bc 03
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+960], eax

; 229  : 	if (nCurrentOS == WIN_2000)

  00014	83 3d 00 00 00
	00 07		 cmp	 DWORD PTR _nCurrentOS, 7
  0001b	53		 push	 ebx
  0001c	8b 9c 24 c8 03
	00 00		 mov	 ebx, DWORD PTR _hwnd$[esp+960]
  00023	56		 push	 esi
  00024	8b b4 24 d0 03
	00 00		 mov	 esi, DWORD PTR _headline$[esp+964]
  0002b	57		 push	 edi
  0002c	8b bc 24 d8 03
	00 00		 mov	 edi, DWORD PTR _text$[esp+968]
  00033	75 39		 jne	 SHORT $LN1@TaskBarIco

; 230  : 	{
; 231  : 		MessageBoxW (MainDlg, (LPCWSTR)text, (LPCWSTR)headline, warning ? MB_ICONWARNING : MB_ICONINFORMATION);

  00035	8b 84 24 dc 03
	00 00		 mov	 eax, DWORD PTR _warning$[esp+968]
  0003c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _MainDlg
  00042	f7 d8		 neg	 eax
  00044	1b c0		 sbb	 eax, eax
  00046	83 e0 f0	 and	 eax, -16		; fffffff0H
  00049	83 c0 40	 add	 eax, 64			; 00000040H
  0004c	50		 push	 eax
  0004d	56		 push	 esi
  0004e	57		 push	 edi
  0004f	51		 push	 ecx
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx

; 256  : }

  00059	8b 8c 24 bc 03
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+960]
  00060	33 cc		 xor	 ecx, esp
  00062	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00067	81 c4 c0 03 00
	00		 add	 esp, 960		; 000003c0H
  0006d	c3		 ret	 0
$LN1@TaskBarIco:

; 232  : 		return;
; 233  : 	}
; 234  : 
; 235  : 	NOTIFYICONDATAW tnid; 
; 236  : 
; 237  : 	ZeroMemory (&tnid, sizeof (tnid));

  0006e	68 bc 03 00 00	 push	 956			; 000003bcH
  00073	8d 54 24 10	 lea	 edx, DWORD PTR _tnid$[esp+976]
  00077	6a 00		 push	 0
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 _memset

; 238  : 
; 239  : 	tnid.cbSize = sizeof (tnid); 
; 240  : 	tnid.hWnd = hwnd; 
; 241  : 	tnid.uID = IDI_CIPHERSHED_ICON; 
; 242  : 	//tnid.uVersion = (IsOSAtLeast (WIN_VISTA) ? NOTIFYICON_VERSION_4 : NOTIFYICON_VERSION);
; 243  : 
; 244  : 	//Shell_NotifyIconW (NIM_SETVERSION, &tnid);
; 245  : 
; 246  : 	tnid.uFlags = NIF_INFO; 
; 247  : 	tnid.dwInfoFlags = (warning ? NIIF_WARNING : NIIF_INFO);

  0007f	33 c0		 xor	 eax, eax
  00081	39 84 24 e8 03
	00 00		 cmp	 DWORD PTR _warning$[esp+980], eax

; 248  : 	tnid.uTimeout = (IsOSAtLeast (WIN_VISTA) ? 1000 : 5000); // in ms

  00088	6a 0b		 push	 11			; 0000000bH
  0008a	0f 95 c0	 setne	 al
  0008d	c7 44 24 1c bc
	03 00 00	 mov	 DWORD PTR _tnid$[esp+988], 956 ; 000003bcH
  00095	89 5c 24 20	 mov	 DWORD PTR _tnid$[esp+992], ebx
  00099	c7 44 24 24 f5
	01 00 00	 mov	 DWORD PTR _tnid$[esp+996], 501 ; 000001f5H
  000a1	c7 44 24 28 10
	00 00 00	 mov	 DWORD PTR _tnid$[esp+1000], 16 ; 00000010H
  000a9	40		 inc	 eax
  000aa	89 84 24 c0 03
	00 00		 mov	 DWORD PTR _tnid$[esp+1920], eax
  000b1	e8 00 00 00 00	 call	 _IsOSAtLeast
  000b6	f7 d8		 neg	 eax
  000b8	1b c0		 sbb	 eax, eax

; 249  : 
; 250  : 	wcsncpy ((wchar_t*)tnid.szInfoTitle, headline, ARRAYSIZE (tnid.szInfoTitle) - 1);

  000ba	6a 3f		 push	 63			; 0000003fH
  000bc	25 60 f0 ff ff	 and	 eax, -4000		; fffff060H
  000c1	8d 8c 24 44 03
	00 00		 lea	 ecx, DWORD PTR _tnid$[esp+1796]
  000c8	05 88 13 00 00	 add	 eax, 5000		; 00001388H
  000cd	56		 push	 esi
  000ce	51		 push	 ecx
  000cf	89 84 24 48 03
	00 00		 mov	 DWORD PTR _tnid$[esp+1800], eax
  000d6	e8 00 00 00 00	 call	 _wcsncpy

; 251  : 	wcsncpy ((wchar_t*)tnid.szInfo, text, ARRAYSIZE (tnid.szInfo) - 1);

  000db	68 ff 00 00 00	 push	 255			; 000000ffH
  000e0	8d 94 24 4c 01
	00 00		 lea	 edx, DWORD PTR _tnid$[esp+1292]
  000e7	57		 push	 edi
  000e8	52		 push	 edx
  000e9	e8 00 00 00 00	 call	 _wcsncpy

; 252  : 
; 253  : 	// Display the balloon tooltip quickly twice in a row to avoid the slow and unwanted "fade-in" phase
; 254  : 	Shell_NotifyIconW (NIM_MODIFY, &tnid);

  000ee	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__Shell_NotifyIconW@8
  000f4	83 c4 28	 add	 esp, 40			; 00000028H
  000f7	8d 44 24 0c	 lea	 eax, DWORD PTR _tnid$[esp+972]
  000fb	50		 push	 eax
  000fc	6a 01		 push	 1
  000fe	ff d6		 call	 esi

; 255  : 	Shell_NotifyIconW (NIM_MODIFY, &tnid);

  00100	8d 4c 24 0c	 lea	 ecx, DWORD PTR _tnid$[esp+972]
  00104	51		 push	 ecx
  00105	6a 01		 push	 1
  00107	ff d6		 call	 esi

; 256  : }

  00109	8b 8c 24 c8 03
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+972]
  00110	5f		 pop	 edi
  00111	5e		 pop	 esi
  00112	5b		 pop	 ebx
  00113	33 cc		 xor	 ecx, esp
  00115	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011a	81 c4 c0 03 00
	00		 add	 esp, 960		; 000003c0H
  00120	c3		 ret	 0
?TaskBarIconDisplayBalloonTooltip@@YAXPAUHWND__@@PB_W1H@Z ENDP ; TaskBarIconDisplayBalloonTooltip
_TEXT	ENDS
PUBLIC	??_C@_1BG@INDNNNCG@?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@		; `string'
PUBLIC	_InfoBalloon
EXTRN	_GetString:PROC
;	COMDAT ??_C@_1BG@INDNNNCG@?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@INDNNNCG@?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AA?$AA@ DB 'C'
	DB	00H, 'i', 00H, 'p', 00H, 'h', 00H, 'e', 00H, 'r', 00H, 'S', 00H
	DB	'h', 00H, 'e', 00H, 'd', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@ DB ' ', 00H, 00H, 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _InfoBalloon
_TEXT	SEGMENT
_headingStringId$ = 8					; size = 4
_textStringId$ = 12					; size = 4
_InfoBalloon PROC					; COMDAT

; 262  : 	if (Silent) 

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	75 58		 jne	 SHORT $LN2@InfoBalloo

; 263  : 		return;
; 264  : 
; 265  : 	TaskBarIconDisplayBalloonTooltip (MainDlg,
; 266  : 		headingStringId == NULL ? L"CipherShed" : GetString (headingStringId), 
; 267  : 		textStringId == NULL ? L" " : GetString (textStringId), 
; 268  : 		FALSE);

  00009	8b 44 24 08	 mov	 eax, DWORD PTR _textStringId$[esp-4]
  0000d	56		 push	 esi
  0000e	85 c0		 test	 eax, eax
  00010	75 07		 jne	 SHORT $LN4@InfoBalloo
  00012	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@
  00017	eb 0b		 jmp	 SHORT $LN5@InfoBalloo
$LN4@InfoBalloo:
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _GetString
  0001f	83 c4 04	 add	 esp, 4
  00022	8b f0		 mov	 esi, eax
$LN5@InfoBalloo:
  00024	8b 44 24 08	 mov	 eax, DWORD PTR _headingStringId$[esp]
  00028	85 c0		 test	 eax, eax
  0002a	75 19		 jne	 SHORT $LN6@InfoBalloo
  0002c	6a 00		 push	 0
  0002e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1BG@INDNNNCG@?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AA?$AA@
  00033	56		 push	 esi
  00034	50		 push	 eax
  00035	a1 00 00 00 00	 mov	 eax, DWORD PTR _MainDlg
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ?TaskBarIconDisplayBalloonTooltip@@YAXPAUHWND__@@PB_W1H@Z ; TaskBarIconDisplayBalloonTooltip
  00040	83 c4 10	 add	 esp, 16			; 00000010H
  00043	5e		 pop	 esi

; 269  : }

  00044	c3		 ret	 0
$LN6@InfoBalloo:

; 263  : 		return;
; 264  : 
; 265  : 	TaskBarIconDisplayBalloonTooltip (MainDlg,
; 266  : 		headingStringId == NULL ? L"CipherShed" : GetString (headingStringId), 
; 267  : 		textStringId == NULL ? L" " : GetString (textStringId), 
; 268  : 		FALSE);

  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 _GetString
  0004b	83 c4 04	 add	 esp, 4
  0004e	6a 00		 push	 0
  00050	56		 push	 esi
  00051	50		 push	 eax
  00052	a1 00 00 00 00	 mov	 eax, DWORD PTR _MainDlg
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ?TaskBarIconDisplayBalloonTooltip@@YAXPAUHWND__@@PB_W1H@Z ; TaskBarIconDisplayBalloonTooltip
  0005d	83 c4 10	 add	 esp, 16			; 00000010H
  00060	5e		 pop	 esi
$LN2@InfoBalloo:

; 269  : }

  00061	c3		 ret	 0
_InfoBalloon ENDP
_TEXT	ENDS
PUBLIC	_InfoBalloonDirect
; Function compile flags: /Ogtpy
;	COMDAT _InfoBalloonDirect
_TEXT	SEGMENT
_headingString$ = 8					; size = 4
_textString$ = 12					; size = 4
_InfoBalloonDirect PROC					; COMDAT

; 275  : 	if (Silent) 

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	75 2e		 jne	 SHORT $LN2@InfoBalloo@2

; 276  : 		return;
; 277  : 
; 278  : 	TaskBarIconDisplayBalloonTooltip (MainDlg,
; 279  : 		headingString == NULL ? L"CipherShed" : headingString, 
; 280  : 		textString == NULL ? L" " : textString, 
; 281  : 		FALSE);

  00009	8b 44 24 08	 mov	 eax, DWORD PTR _textString$[esp-4]
  0000d	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@
  00012	85 c0		 test	 eax, eax
  00014	74 02		 je	 SHORT $LN5@InfoBalloo@2
  00016	8b c8		 mov	 ecx, eax
$LN5@InfoBalloo@2:
  00018	8b 44 24 04	 mov	 eax, DWORD PTR _headingString$[esp-4]
  0001c	85 c0		 test	 eax, eax
  0001e	75 05		 jne	 SHORT $LN6@InfoBalloo@2
  00020	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1BG@INDNNNCG@?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AA?$AA@
$LN6@InfoBalloo@2:
  00025	6a 00		 push	 0
  00027	51		 push	 ecx
  00028	50		 push	 eax
  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR _MainDlg
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ?TaskBarIconDisplayBalloonTooltip@@YAXPAUHWND__@@PB_W1H@Z ; TaskBarIconDisplayBalloonTooltip
  00034	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@InfoBalloo@2:

; 282  : }

  00037	c3		 ret	 0
_InfoBalloonDirect ENDP
_TEXT	ENDS
PUBLIC	_WarningBalloon
; Function compile flags: /Ogtpy
;	COMDAT _WarningBalloon
_TEXT	SEGMENT
_headingStringId$ = 8					; size = 4
_textStringId$ = 12					; size = 4
_WarningBalloon PROC					; COMDAT

; 288  : 	if (Silent) 

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	75 58		 jne	 SHORT $LN2@WarningBal

; 289  : 		return;
; 290  : 
; 291  : 	TaskBarIconDisplayBalloonTooltip (MainDlg,
; 292  : 		headingStringId == NULL ? L"CipherShed" : GetString (headingStringId), 
; 293  : 		textStringId == NULL ? L" " : GetString (textStringId), 
; 294  : 		TRUE);

  00009	8b 44 24 08	 mov	 eax, DWORD PTR _textStringId$[esp-4]
  0000d	56		 push	 esi
  0000e	85 c0		 test	 eax, eax
  00010	75 07		 jne	 SHORT $LN4@WarningBal
  00012	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@
  00017	eb 0b		 jmp	 SHORT $LN5@WarningBal
$LN4@WarningBal:
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _GetString
  0001f	83 c4 04	 add	 esp, 4
  00022	8b f0		 mov	 esi, eax
$LN5@WarningBal:
  00024	8b 44 24 08	 mov	 eax, DWORD PTR _headingStringId$[esp]
  00028	85 c0		 test	 eax, eax
  0002a	75 19		 jne	 SHORT $LN6@WarningBal
  0002c	6a 01		 push	 1
  0002e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1BG@INDNNNCG@?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AA?$AA@
  00033	56		 push	 esi
  00034	50		 push	 eax
  00035	a1 00 00 00 00	 mov	 eax, DWORD PTR _MainDlg
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ?TaskBarIconDisplayBalloonTooltip@@YAXPAUHWND__@@PB_W1H@Z ; TaskBarIconDisplayBalloonTooltip
  00040	83 c4 10	 add	 esp, 16			; 00000010H
  00043	5e		 pop	 esi

; 295  : }

  00044	c3		 ret	 0
$LN6@WarningBal:

; 289  : 		return;
; 290  : 
; 291  : 	TaskBarIconDisplayBalloonTooltip (MainDlg,
; 292  : 		headingStringId == NULL ? L"CipherShed" : GetString (headingStringId), 
; 293  : 		textStringId == NULL ? L" " : GetString (textStringId), 
; 294  : 		TRUE);

  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 _GetString
  0004b	83 c4 04	 add	 esp, 4
  0004e	6a 01		 push	 1
  00050	56		 push	 esi
  00051	50		 push	 eax
  00052	a1 00 00 00 00	 mov	 eax, DWORD PTR _MainDlg
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ?TaskBarIconDisplayBalloonTooltip@@YAXPAUHWND__@@PB_W1H@Z ; TaskBarIconDisplayBalloonTooltip
  0005d	83 c4 10	 add	 esp, 16			; 00000010H
  00060	5e		 pop	 esi
$LN2@WarningBal:

; 295  : }

  00061	c3		 ret	 0
_WarningBalloon ENDP
_TEXT	ENDS
PUBLIC	_WarningBalloonDirect
; Function compile flags: /Ogtpy
;	COMDAT _WarningBalloonDirect
_TEXT	SEGMENT
_headingString$ = 8					; size = 4
_textString$ = 12					; size = 4
_WarningBalloonDirect PROC				; COMDAT

; 301  : 	if (Silent) 

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	75 2e		 jne	 SHORT $LN2@WarningBal@2

; 302  : 		return;
; 303  : 
; 304  : 	TaskBarIconDisplayBalloonTooltip (MainDlg,
; 305  : 		headingString == NULL ? L"CipherShed" : headingString, 
; 306  : 		textString == NULL ? L" " : textString, 
; 307  : 		TRUE);

  00009	8b 44 24 08	 mov	 eax, DWORD PTR _textString$[esp-4]
  0000d	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@
  00012	85 c0		 test	 eax, eax
  00014	74 02		 je	 SHORT $LN5@WarningBal@2
  00016	8b c8		 mov	 ecx, eax
$LN5@WarningBal@2:
  00018	8b 44 24 04	 mov	 eax, DWORD PTR _headingString$[esp-4]
  0001c	85 c0		 test	 eax, eax
  0001e	75 05		 jne	 SHORT $LN6@WarningBal@2
  00020	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1BG@INDNNNCG@?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AA?$AA@
$LN6@WarningBal@2:
  00025	6a 01		 push	 1
  00027	51		 push	 ecx
  00028	50		 push	 eax
  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR _MainDlg
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ?TaskBarIconDisplayBalloonTooltip@@YAXPAUHWND__@@PB_W1H@Z ; TaskBarIconDisplayBalloonTooltip
  00034	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@WarningBal@2:

; 308  : }

  00037	c3		 ret	 0
_WarningBalloonDirect ENDP
_TEXT	ENDS
PUBLIC	_Info
EXTRN	_lpszTitle:DWORD
; Function compile flags: /Ogtpy
;	COMDAT _Info
_TEXT	SEGMENT
_stringId$ = 8						; size = 4
_Info	PROC						; COMDAT

; 313  : 	if (Silent) return 0;

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	74 03		 je	 SHORT $LN1@Info
  00009	33 c0		 xor	 eax, eax

; 315  : }

  0000b	c3		 ret	 0
$LN1@Info:

; 314  : 	return MessageBoxW (MainDlg, (LPCWSTR)GetString (stringId), (LPCWSTR)lpszTitle, MB_ICONINFORMATION);

  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  00011	8b 4c 24 04	 mov	 ecx, DWORD PTR _stringId$[esp-4]
  00015	6a 40		 push	 64			; 00000040H
  00017	50		 push	 eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _GetString
  0001e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  00024	83 c4 04	 add	 esp, 4
  00027	50		 push	 eax
  00028	52		 push	 edx
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 315  : }

  0002f	c3		 ret	 0
_Info	ENDP
_TEXT	ENDS
PUBLIC	_InfoTopMost
; Function compile flags: /Ogtpy
;	COMDAT _InfoTopMost
_TEXT	SEGMENT
_stringId$ = 8						; size = 4
_InfoTopMost PROC					; COMDAT

; 320  : 	if (Silent) return 0;

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	74 03		 je	 SHORT $LN1@InfoTopMos
  00009	33 c0		 xor	 eax, eax

; 322  : }

  0000b	c3		 ret	 0
$LN1@InfoTopMos:

; 321  : 	return MessageBoxW (MainDlg, (LPCWSTR)GetString (stringId), (LPCWSTR)lpszTitle, MB_ICONINFORMATION | MB_SETFOREGROUND | MB_TOPMOST);

  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  00011	8b 4c 24 04	 mov	 ecx, DWORD PTR _stringId$[esp-4]
  00015	68 40 00 05 00	 push	 327744			; 00050040H
  0001a	50		 push	 eax
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 _GetString
  00021	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  00027	83 c4 04	 add	 esp, 4
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 322  : }

  00032	c3		 ret	 0
_InfoTopMost ENDP
_TEXT	ENDS
PUBLIC	_InfoDirect
; Function compile flags: /Ogtpy
;	COMDAT _InfoDirect
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_InfoDirect PROC					; COMDAT

; 327  : 	if (Silent) return 0;

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	74 03		 je	 SHORT $LN1@InfoDirect
  00009	33 c0		 xor	 eax, eax

; 329  : }

  0000b	c3		 ret	 0
$LN1@InfoDirect:

; 328  : 	return MessageBoxW (MainDlg, (LPCWSTR)msg, (LPCWSTR)lpszTitle, MB_ICONINFORMATION);

  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  00011	8b 4c 24 04	 mov	 ecx, DWORD PTR _msg$[esp-4]
  00015	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  0001b	6a 40		 push	 64			; 00000040H
  0001d	50		 push	 eax
  0001e	51		 push	 ecx
  0001f	52		 push	 edx
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 329  : }

  00026	c3		 ret	 0
_InfoDirect ENDP
_TEXT	ENDS
PUBLIC	_Warning
; Function compile flags: /Ogtpy
;	COMDAT _Warning
_TEXT	SEGMENT
_stringId$ = 8						; size = 4
_Warning PROC						; COMDAT

; 334  : 	if (Silent) return 0;

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	74 03		 je	 SHORT $LN1@Warning
  00009	33 c0		 xor	 eax, eax

; 336  : }

  0000b	c3		 ret	 0
$LN1@Warning:

; 335  : 	return MessageBoxW (MainDlg, (LPCWSTR)GetString (stringId), (LPCWSTR)lpszTitle, MB_ICONWARNING);

  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  00011	8b 4c 24 04	 mov	 ecx, DWORD PTR _stringId$[esp-4]
  00015	6a 30		 push	 48			; 00000030H
  00017	50		 push	 eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _GetString
  0001e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  00024	83 c4 04	 add	 esp, 4
  00027	50		 push	 eax
  00028	52		 push	 edx
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 336  : }

  0002f	c3		 ret	 0
_Warning ENDP
_TEXT	ENDS
PUBLIC	_WarningTopMost
; Function compile flags: /Ogtpy
;	COMDAT _WarningTopMost
_TEXT	SEGMENT
_stringId$ = 8						; size = 4
_WarningTopMost PROC					; COMDAT

; 341  : 	if (Silent) return 0;

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	74 03		 je	 SHORT $LN1@WarningTop
  00009	33 c0		 xor	 eax, eax

; 343  : }

  0000b	c3		 ret	 0
$LN1@WarningTop:

; 342  : 	return MessageBoxW (MainDlg, (LPCWSTR)GetString (stringId), (LPCWSTR)lpszTitle, MB_ICONWARNING | MB_SETFOREGROUND | MB_TOPMOST);

  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  00011	8b 4c 24 04	 mov	 ecx, DWORD PTR _stringId$[esp-4]
  00015	68 30 00 05 00	 push	 327728			; 00050030H
  0001a	50		 push	 eax
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 _GetString
  00021	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  00027	83 c4 04	 add	 esp, 4
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 343  : }

  00032	c3		 ret	 0
_WarningTopMost ENDP
_TEXT	ENDS
PUBLIC	_WarningDirect
; Function compile flags: /Ogtpy
;	COMDAT _WarningDirect
_TEXT	SEGMENT
_warnMsg$ = 8						; size = 4
_WarningDirect PROC					; COMDAT

; 348  : 	if (Silent) return 0;

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	74 03		 je	 SHORT $LN1@WarningDir
  00009	33 c0		 xor	 eax, eax

; 350  : }

  0000b	c3		 ret	 0
$LN1@WarningDir:

; 349  : 	return MessageBoxW (MainDlg, (LPCWSTR)warnMsg, (LPCWSTR)lpszTitle, MB_ICONWARNING);

  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  00011	8b 4c 24 04	 mov	 ecx, DWORD PTR _warnMsg$[esp-4]
  00015	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  0001b	6a 30		 push	 48			; 00000030H
  0001d	50		 push	 eax
  0001e	51		 push	 ecx
  0001f	52		 push	 edx
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 350  : }

  00026	c3		 ret	 0
_WarningDirect ENDP
_TEXT	ENDS
PUBLIC	_Error
; Function compile flags: /Ogtpy
;	COMDAT _Error
_TEXT	SEGMENT
_stringId$ = 8						; size = 4
_Error	PROC						; COMDAT

; 355  : 	if (Silent) return 0;

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	74 03		 je	 SHORT $LN1@Error
  00009	33 c0		 xor	 eax, eax

; 357  : }

  0000b	c3		 ret	 0
$LN1@Error:

; 356  : 	return MessageBoxW (MainDlg, (LPCWSTR)GetString (stringId), (LPCWSTR)lpszTitle, MB_ICONERROR);

  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  00011	8b 4c 24 04	 mov	 ecx, DWORD PTR _stringId$[esp-4]
  00015	6a 10		 push	 16			; 00000010H
  00017	50		 push	 eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _GetString
  0001e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  00024	83 c4 04	 add	 esp, 4
  00027	50		 push	 eax
  00028	52		 push	 edx
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 357  : }

  0002f	c3		 ret	 0
_Error	ENDP
_TEXT	ENDS
PUBLIC	_ErrorTopMost
; Function compile flags: /Ogtpy
;	COMDAT _ErrorTopMost
_TEXT	SEGMENT
_stringId$ = 8						; size = 4
_ErrorTopMost PROC					; COMDAT

; 362  : 	if (Silent) return 0;

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	74 03		 je	 SHORT $LN1@ErrorTopMo
  00009	33 c0		 xor	 eax, eax

; 364  : }

  0000b	c3		 ret	 0
$LN1@ErrorTopMo:

; 363  : 	return MessageBoxW (MainDlg, (LPCWSTR)GetString (stringId), (LPCWSTR)lpszTitle, MB_ICONERROR | MB_SETFOREGROUND | MB_TOPMOST);

  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  00011	8b 4c 24 04	 mov	 ecx, DWORD PTR _stringId$[esp-4]
  00015	68 10 00 05 00	 push	 327696			; 00050010H
  0001a	50		 push	 eax
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 _GetString
  00021	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  00027	83 c4 04	 add	 esp, 4
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 364  : }

  00032	c3		 ret	 0
_ErrorTopMost ENDP
_TEXT	ENDS
PUBLIC	_ErrorDirectTitle
; Function compile flags: /Ogtpy
;	COMDAT _ErrorDirectTitle
_TEXT	SEGMENT
_errMsg$ = 8						; size = 4
_title$ = 12						; size = 4
_ErrorDirectTitle PROC					; COMDAT

; 374  : 	if (Silent) return 0;

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	74 03		 je	 SHORT $LN1@ErrorDirec
  00009	33 c0		 xor	 eax, eax

; 376  : }

  0000b	c3		 ret	 0
$LN1@ErrorDirec:

; 375  : 	return MessageBoxW (MainDlg, (LPCWSTR)errMsg, (LPCWSTR)title, MB_ICONERROR);

  0000c	8b 44 24 08	 mov	 eax, DWORD PTR _title$[esp-4]
  00010	8b 4c 24 04	 mov	 ecx, DWORD PTR _errMsg$[esp-4]
  00014	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  0001a	6a 10		 push	 16			; 00000010H
  0001c	50		 push	 eax
  0001d	51		 push	 ecx
  0001e	52		 push	 edx
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 376  : }

  00025	c3		 ret	 0
_ErrorDirectTitle ENDP
_TEXT	ENDS
PUBLIC	_AskYesNo
; Function compile flags: /Ogtpy
;	COMDAT _AskYesNo
_TEXT	SEGMENT
_stringId$ = 8						; size = 4
_AskYesNo PROC						; COMDAT

; 381  : 	if (Silent) return IDNO;

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	74 06		 je	 SHORT $LN1@AskYesNo
  00009	b8 07 00 00 00	 mov	 eax, 7

; 383  : }

  0000e	c3		 ret	 0
$LN1@AskYesNo:

; 382  : 	return MessageBoxW (MainDlg, (LPCWSTR)GetString (stringId), (LPCWSTR)lpszTitle, MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON1);

  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  00014	8b 4c 24 04	 mov	 ecx, DWORD PTR _stringId$[esp-4]
  00018	6a 24		 push	 36			; 00000024H
  0001a	50		 push	 eax
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 _GetString
  00021	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  00027	83 c4 04	 add	 esp, 4
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 383  : }

  00032	c3		 ret	 0
_AskYesNo ENDP
_TEXT	ENDS
PUBLIC	_AskYesNoString
; Function compile flags: /Ogtpy
;	COMDAT _AskYesNoString
_TEXT	SEGMENT
_str$ = 8						; size = 4
_AskYesNoString PROC					; COMDAT

; 388  : 	if (Silent) return IDNO;

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	74 06		 je	 SHORT $LN1@AskYesNoSt
  00009	b8 07 00 00 00	 mov	 eax, 7

; 390  : }

  0000e	c3		 ret	 0
$LN1@AskYesNoSt:

; 389  : 	return MessageBoxW (MainDlg, (LPCWSTR)str, (LPCWSTR)lpszTitle, MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON1);

  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  00014	8b 4c 24 04	 mov	 ecx, DWORD PTR _str$[esp-4]
  00018	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  0001e	6a 24		 push	 36			; 00000024H
  00020	50		 push	 eax
  00021	51		 push	 ecx
  00022	52		 push	 edx
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 390  : }

  00029	c3		 ret	 0
_AskYesNoString ENDP
_TEXT	ENDS
PUBLIC	_AskYesNoTopmost
; Function compile flags: /Ogtpy
;	COMDAT _AskYesNoTopmost
_TEXT	SEGMENT
_stringId$ = 8						; size = 4
_AskYesNoTopmost PROC					; COMDAT

; 395  : 	if (Silent) return IDNO;

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	74 06		 je	 SHORT $LN1@AskYesNoTo
  00009	b8 07 00 00 00	 mov	 eax, 7

; 397  : }

  0000e	c3		 ret	 0
$LN1@AskYesNoTo:

; 396  : 	return MessageBoxW (MainDlg, (LPCWSTR)GetString (stringId), (LPCWSTR)lpszTitle, MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON1 | MB_SETFOREGROUND | MB_TOPMOST);

  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  00014	8b 4c 24 04	 mov	 ecx, DWORD PTR _stringId$[esp-4]
  00018	68 24 00 05 00	 push	 327716			; 00050024H
  0001d	50		 push	 eax
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 _GetString
  00024	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	52		 push	 edx
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 397  : }

  00035	c3		 ret	 0
_AskYesNoTopmost ENDP
_TEXT	ENDS
PUBLIC	_AskNoYes
; Function compile flags: /Ogtpy
;	COMDAT _AskNoYes
_TEXT	SEGMENT
_stringId$ = 8						; size = 4
_AskNoYes PROC						; COMDAT

; 402  : 	if (Silent) return IDNO;

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	74 06		 je	 SHORT $LN1@AskNoYes
  00009	b8 07 00 00 00	 mov	 eax, 7

; 404  : }

  0000e	c3		 ret	 0
$LN1@AskNoYes:

; 403  : 	return MessageBoxW (MainDlg, (LPCWSTR)GetString (stringId), (LPCWSTR)lpszTitle, MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2);

  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  00014	8b 4c 24 04	 mov	 ecx, DWORD PTR _stringId$[esp-4]
  00018	68 24 01 00 00	 push	 292			; 00000124H
  0001d	50		 push	 eax
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 _GetString
  00024	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	52		 push	 edx
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 404  : }

  00035	c3		 ret	 0
_AskNoYes ENDP
_TEXT	ENDS
PUBLIC	_AskOkCancel
; Function compile flags: /Ogtpy
;	COMDAT _AskOkCancel
_TEXT	SEGMENT
_stringId$ = 8						; size = 4
_AskOkCancel PROC					; COMDAT

; 409  : 	if (Silent) return IDCANCEL;

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	74 06		 je	 SHORT $LN1@AskOkCance
  00009	b8 02 00 00 00	 mov	 eax, 2

; 411  : }

  0000e	c3		 ret	 0
$LN1@AskOkCance:

; 410  : 	return MessageBoxW (MainDlg, (LPCWSTR)GetString (stringId), (LPCWSTR)lpszTitle, MB_ICONQUESTION | MB_OKCANCEL | MB_DEFBUTTON1);

  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  00014	8b 4c 24 04	 mov	 ecx, DWORD PTR _stringId$[esp-4]
  00018	6a 21		 push	 33			; 00000021H
  0001a	50		 push	 eax
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 _GetString
  00021	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  00027	83 c4 04	 add	 esp, 4
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 411  : }

  00032	c3		 ret	 0
_AskOkCancel ENDP
_TEXT	ENDS
PUBLIC	_AskWarnYesNoTitle
; Function compile flags: /Ogtpy
;	COMDAT _AskWarnYesNoTitle
_TEXT	SEGMENT
_stringId$ = 8						; size = 4
_title$ = 12						; size = 4
_AskWarnYesNoTitle PROC					; COMDAT

; 421  : 	if (Silent) return IDNO;

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	74 06		 je	 SHORT $LN1@AskWarnYes
  00009	b8 07 00 00 00	 mov	 eax, 7

; 423  : }

  0000e	c3		 ret	 0
$LN1@AskWarnYes:

; 422  : 	return MessageBoxW (MainDlg, (LPCWSTR)GetString (stringId), (LPCWSTR)title, MB_ICONWARNING | MB_YESNO | MB_DEFBUTTON1);

  0000f	8b 44 24 08	 mov	 eax, DWORD PTR _title$[esp-4]
  00013	8b 4c 24 04	 mov	 ecx, DWORD PTR _stringId$[esp-4]
  00017	6a 34		 push	 52			; 00000034H
  00019	50		 push	 eax
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 _GetString
  00020	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  00026	83 c4 04	 add	 esp, 4
  00029	50		 push	 eax
  0002a	52		 push	 edx
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 423  : }

  00031	c3		 ret	 0
_AskWarnYesNoTitle ENDP
_TEXT	ENDS
PUBLIC	_AskWarnYesNoString
; Function compile flags: /Ogtpy
;	COMDAT _AskWarnYesNoString
_TEXT	SEGMENT
_string$ = 8						; size = 4
_AskWarnYesNoString PROC				; COMDAT

; 428  : 	if (Silent) return IDNO;

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	74 06		 je	 SHORT $LN1@AskWarnYes@2
  00009	b8 07 00 00 00	 mov	 eax, 7

; 430  : }

  0000e	c3		 ret	 0
$LN1@AskWarnYes@2:

; 429  : 	return MessageBoxW (MainDlg, (LPCWSTR)string, (LPCWSTR)lpszTitle, MB_ICONWARNING | MB_YESNO | MB_DEFBUTTON1);

  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  00014	8b 4c 24 04	 mov	 ecx, DWORD PTR _string$[esp-4]
  00018	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  0001e	6a 34		 push	 52			; 00000034H
  00020	50		 push	 eax
  00021	51		 push	 ecx
  00022	52		 push	 edx
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 430  : }

  00029	c3		 ret	 0
_AskWarnYesNoString ENDP
_TEXT	ENDS
PUBLIC	_AskWarnYesNoTopmost
; Function compile flags: /Ogtpy
;	COMDAT _AskWarnYesNoTopmost
_TEXT	SEGMENT
_stringId$ = 8						; size = 4
_AskWarnYesNoTopmost PROC				; COMDAT

; 435  : 	if (Silent) return IDNO;

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	74 06		 je	 SHORT $LN1@AskWarnYes@3
  00009	b8 07 00 00 00	 mov	 eax, 7

; 437  : }

  0000e	c3		 ret	 0
$LN1@AskWarnYes@3:

; 436  : 	return MessageBoxW (MainDlg, (LPCWSTR)GetString (stringId), (LPCWSTR)lpszTitle, MB_ICONWARNING | MB_YESNO | MB_DEFBUTTON1 | MB_SETFOREGROUND | MB_TOPMOST);

  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  00014	8b 4c 24 04	 mov	 ecx, DWORD PTR _stringId$[esp-4]
  00018	68 34 00 05 00	 push	 327732			; 00050034H
  0001d	50		 push	 eax
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 _GetString
  00024	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	52		 push	 edx
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 437  : }

  00035	c3		 ret	 0
_AskWarnYesNoTopmost ENDP
_TEXT	ENDS
PUBLIC	_AskWarnYesNoStringTopmost
; Function compile flags: /Ogtpy
;	COMDAT _AskWarnYesNoStringTopmost
_TEXT	SEGMENT
_string$ = 8						; size = 4
_AskWarnYesNoStringTopmost PROC				; COMDAT

; 442  : 	if (Silent) return IDNO;

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	74 06		 je	 SHORT $LN1@AskWarnYes@4
  00009	b8 07 00 00 00	 mov	 eax, 7

; 444  : }

  0000e	c3		 ret	 0
$LN1@AskWarnYes@4:

; 443  : 	return MessageBoxW (MainDlg, (LPCWSTR)string, (LPCWSTR)lpszTitle, MB_ICONWARNING | MB_YESNO | MB_DEFBUTTON1 | MB_SETFOREGROUND | MB_TOPMOST);

  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  00014	8b 4c 24 04	 mov	 ecx, DWORD PTR _string$[esp-4]
  00018	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  0001e	68 34 00 05 00	 push	 327732			; 00050034H
  00023	50		 push	 eax
  00024	51		 push	 ecx
  00025	52		 push	 edx
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 444  : }

  0002c	c3		 ret	 0
_AskWarnYesNoStringTopmost ENDP
_TEXT	ENDS
PUBLIC	_AskWarnNoYes
; Function compile flags: /Ogtpy
;	COMDAT _AskWarnNoYes
_TEXT	SEGMENT
_stringId$ = 8						; size = 4
_AskWarnNoYes PROC					; COMDAT

; 449  : 	if (Silent) return IDNO;

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	74 06		 je	 SHORT $LN1@AskWarnNoY
  00009	b8 07 00 00 00	 mov	 eax, 7

; 451  : }

  0000e	c3		 ret	 0
$LN1@AskWarnNoY:

; 450  : 	return MessageBoxW (MainDlg, (LPCWSTR)GetString (stringId), (LPCWSTR)lpszTitle, MB_ICONWARNING | MB_YESNO | MB_DEFBUTTON2);

  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  00014	8b 4c 24 04	 mov	 ecx, DWORD PTR _stringId$[esp-4]
  00018	68 34 01 00 00	 push	 308			; 00000134H
  0001d	50		 push	 eax
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 _GetString
  00024	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	52		 push	 edx
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 451  : }

  00035	c3		 ret	 0
_AskWarnNoYes ENDP
_TEXT	ENDS
PUBLIC	_AskWarnNoYesString
; Function compile flags: /Ogtpy
;	COMDAT _AskWarnNoYesString
_TEXT	SEGMENT
_string$ = 8						; size = 4
_AskWarnNoYesString PROC				; COMDAT

; 456  : 	if (Silent) return IDNO;

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	74 06		 je	 SHORT $LN1@AskWarnNoY@2
  00009	b8 07 00 00 00	 mov	 eax, 7

; 458  : }

  0000e	c3		 ret	 0
$LN1@AskWarnNoY@2:

; 457  : 	return MessageBoxW (MainDlg, (LPCWSTR)string, (LPCWSTR)lpszTitle, MB_ICONWARNING | MB_YESNO | MB_DEFBUTTON2);

  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  00014	8b 4c 24 04	 mov	 ecx, DWORD PTR _string$[esp-4]
  00018	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  0001e	68 34 01 00 00	 push	 308			; 00000134H
  00023	50		 push	 eax
  00024	51		 push	 ecx
  00025	52		 push	 edx
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 458  : }

  0002c	c3		 ret	 0
_AskWarnNoYesString ENDP
_TEXT	ENDS
PUBLIC	_AskWarnNoYesTopmost
; Function compile flags: /Ogtpy
;	COMDAT _AskWarnNoYesTopmost
_TEXT	SEGMENT
_stringId$ = 8						; size = 4
_AskWarnNoYesTopmost PROC				; COMDAT

; 463  : 	if (Silent) return IDNO;

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	74 06		 je	 SHORT $LN1@AskWarnNoY@3
  00009	b8 07 00 00 00	 mov	 eax, 7

; 465  : }

  0000e	c3		 ret	 0
$LN1@AskWarnNoY@3:

; 464  : 	return MessageBoxW (MainDlg, (LPCWSTR)GetString (stringId), (LPCWSTR)lpszTitle, MB_ICONWARNING | MB_YESNO | MB_DEFBUTTON2 | MB_SETFOREGROUND | MB_TOPMOST);

  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  00014	8b 4c 24 04	 mov	 ecx, DWORD PTR _stringId$[esp-4]
  00018	68 34 01 05 00	 push	 327988			; 00050134H
  0001d	50		 push	 eax
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 _GetString
  00024	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	52		 push	 edx
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 465  : }

  00035	c3		 ret	 0
_AskWarnNoYesTopmost ENDP
_TEXT	ENDS
PUBLIC	_AskWarnOkCancel
; Function compile flags: /Ogtpy
;	COMDAT _AskWarnOkCancel
_TEXT	SEGMENT
_stringId$ = 8						; size = 4
_AskWarnOkCancel PROC					; COMDAT

; 470  : 	if (Silent) return IDCANCEL;

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	74 06		 je	 SHORT $LN1@AskWarnOkC
  00009	b8 02 00 00 00	 mov	 eax, 2

; 472  : }

  0000e	c3		 ret	 0
$LN1@AskWarnOkC:

; 471  : 	return MessageBoxW (MainDlg, (LPCWSTR)GetString (stringId), (LPCWSTR)lpszTitle, MB_ICONWARNING | MB_OKCANCEL | MB_DEFBUTTON1);

  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  00014	8b 4c 24 04	 mov	 ecx, DWORD PTR _stringId$[esp-4]
  00018	6a 31		 push	 49			; 00000031H
  0001a	50		 push	 eax
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 _GetString
  00021	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  00027	83 c4 04	 add	 esp, 4
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 472  : }

  00032	c3		 ret	 0
_AskWarnOkCancel ENDP
_TEXT	ENDS
PUBLIC	_AskWarnCancelOk
; Function compile flags: /Ogtpy
;	COMDAT _AskWarnCancelOk
_TEXT	SEGMENT
_stringId$ = 8						; size = 4
_AskWarnCancelOk PROC					; COMDAT

; 477  : 	if (Silent) return IDCANCEL;

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	74 06		 je	 SHORT $LN1@AskWarnCan
  00009	b8 02 00 00 00	 mov	 eax, 2

; 479  : }

  0000e	c3		 ret	 0
$LN1@AskWarnCan:

; 478  : 	return MessageBoxW (MainDlg, (LPCWSTR)GetString (stringId), (LPCWSTR)lpszTitle, MB_ICONWARNING | MB_OKCANCEL | MB_DEFBUTTON2);

  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  00014	8b 4c 24 04	 mov	 ecx, DWORD PTR _stringId$[esp-4]
  00018	68 31 01 00 00	 push	 305			; 00000131H
  0001d	50		 push	 eax
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 _GetString
  00024	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	52		 push	 edx
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 479  : }

  00035	c3		 ret	 0
_AskWarnCancelOk ENDP
_TEXT	ENDS
PUBLIC	_AskErrYesNo
; Function compile flags: /Ogtpy
;	COMDAT _AskErrYesNo
_TEXT	SEGMENT
_stringId$ = 8						; size = 4
_AskErrYesNo PROC					; COMDAT

; 484  : 	if (Silent) return IDNO;

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	74 06		 je	 SHORT $LN1@AskErrYesN
  00009	b8 07 00 00 00	 mov	 eax, 7

; 486  : }

  0000e	c3		 ret	 0
$LN1@AskErrYesN:

; 485  : 	return MessageBoxW (MainDlg, (LPCWSTR)GetString (stringId), (LPCWSTR)lpszTitle, MB_ICONERROR | MB_YESNO | MB_DEFBUTTON1);

  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  00014	8b 4c 24 04	 mov	 ecx, DWORD PTR _stringId$[esp-4]
  00018	6a 14		 push	 20			; 00000014H
  0001a	50		 push	 eax
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 _GetString
  00021	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  00027	83 c4 04	 add	 esp, 4
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 486  : }

  00032	c3		 ret	 0
_AskErrYesNo ENDP
_TEXT	ENDS
PUBLIC	_AskErrNoYes
; Function compile flags: /Ogtpy
;	COMDAT _AskErrNoYes
_TEXT	SEGMENT
_stringId$ = 8						; size = 4
_AskErrNoYes PROC					; COMDAT

; 491  : 	if (Silent) return IDNO;

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	74 06		 je	 SHORT $LN1@AskErrNoYe
  00009	b8 07 00 00 00	 mov	 eax, 7

; 493  : }

  0000e	c3		 ret	 0
$LN1@AskErrNoYe:

; 492  : 	return MessageBoxW (MainDlg, (LPCWSTR)GetString (stringId), (LPCWSTR)lpszTitle, MB_ICONERROR | MB_YESNO | MB_DEFBUTTON2);

  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  00014	8b 4c 24 04	 mov	 ecx, DWORD PTR _stringId$[esp-4]
  00018	68 14 01 00 00	 push	 276			; 00000114H
  0001d	50		 push	 eax
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 _GetString
  00024	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	52		 push	 edx
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 493  : }

  00035	c3		 ret	 0
_AskErrNoYes ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@GEMJKNEE@INCONSISTENCY_RESOLVED?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_InconsistencyResolved
EXTRN	__chkstk:PROC
;	COMDAT ??_C@_0BH@GEMJKNEE@INCONSISTENCY_RESOLVED?$AA@
CONST	SEGMENT
??_C@_0BH@GEMJKNEE@INCONSISTENCY_RESOLVED?$AA@ DB 'INCONSISTENCY_RESOLVED'
	DB	00H						; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _InconsistencyResolved
_TEXT	SEGMENT
_finalMsg$ = -16052					; size = 16048
__$ArrayPad$ = -4					; size = 4
_techInfo$ = 8						; size = 4
_InconsistencyResolved PROC				; COMDAT

; 496  : {

  00000	b8 b4 3e 00 00	 mov	 eax, 16052		; 00003eb4H
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000f	33 c4		 xor	 eax, esp
  00011	89 84 24 b0 3e
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16052], eax
  00018	8b 84 24 b8 3e
	00 00		 mov	 eax, DWORD PTR _techInfo$[esp+16048]

; 497  : 	wchar_t finalMsg[8024];
; 498  : 
; 499  : 	swprintf (finalMsg, ARRAYSIZE(finalMsg), GetString ("INCONSISTENCY_RESOLVED"), techInfo);

  0001f	50		 push	 eax
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@GEMJKNEE@INCONSISTENCY_RESOLVED?$AA@
  00025	e8 00 00 00 00	 call	 _GetString
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8d 44 24 08	 lea	 eax, DWORD PTR _finalMsg$[esp+16060]
  00032	50		 push	 eax
  00033	ba 58 1f 00 00	 mov	 edx, 8024		; 00001f58H
  00038	e8 00 00 00 00	 call	 _swprintf

; 500  : 	MessageBoxW (MainDlg, (LPCWSTR)finalMsg, (LPCWSTR)lpszTitle, MB_ICONWARNING | MB_SETFOREGROUND | MB_TOPMOST);

  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpszTitle
  00043	a1 00 00 00 00	 mov	 eax, DWORD PTR _MainDlg
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004b	68 30 00 05 00	 push	 327728			; 00050030H
  00050	51		 push	 ecx
  00051	8d 54 24 08	 lea	 edx, DWORD PTR _finalMsg$[esp+16060]
  00055	52		 push	 edx
  00056	50		 push	 eax
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 501  : }

  0005d	8b 8c 24 b0 3e
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16052]
  00064	33 cc		 xor	 ecx, esp
  00066	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006b	81 c4 b4 3e 00
	00		 add	 esp, 16052		; 00003eb4H
  00071	c3		 ret	 0
_InconsistencyResolved ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@FLLBKCCB@UNEXPECTED_STATE?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_ReportUnexpectedState
;	COMDAT ??_C@_0BB@FLLBKCCB@UNEXPECTED_STATE?$AA@
CONST	SEGMENT
??_C@_0BB@FLLBKCCB@UNEXPECTED_STATE?$AA@ DB 'UNEXPECTED_STATE', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _ReportUnexpectedState
_TEXT	SEGMENT
_finalMsg$ = -16052					; size = 16048
__$ArrayPad$ = -4					; size = 4
_techInfo$ = 8						; size = 4
_ReportUnexpectedState PROC				; COMDAT

; 505  : {

  00000	b8 b4 3e 00 00	 mov	 eax, 16052		; 00003eb4H
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000f	33 c4		 xor	 eax, esp
  00011	89 84 24 b0 3e
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16052], eax
  00018	8b 84 24 b8 3e
	00 00		 mov	 eax, DWORD PTR _techInfo$[esp+16048]

; 506  : 	wchar_t finalMsg[8024];
; 507  : 
; 508  : 	swprintf (finalMsg, ARRAYSIZE(finalMsg), GetString ("UNEXPECTED_STATE"), techInfo);

  0001f	50		 push	 eax
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FLLBKCCB@UNEXPECTED_STATE?$AA@
  00025	e8 00 00 00 00	 call	 _GetString
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8d 44 24 08	 lea	 eax, DWORD PTR _finalMsg$[esp+16060]
  00032	50		 push	 eax
  00033	ba 58 1f 00 00	 mov	 edx, 8024		; 00001f58H
  00038	e8 00 00 00 00	 call	 _swprintf

; 509  : 	MessageBoxW (MainDlg, (LPCWSTR)finalMsg, (LPCWSTR)lpszTitle, MB_ICONERROR | MB_SETFOREGROUND | MB_TOPMOST);

  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpszTitle
  00043	a1 00 00 00 00	 mov	 eax, DWORD PTR _MainDlg
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004b	68 10 00 05 00	 push	 327696			; 00050010H
  00050	51		 push	 ecx
  00051	8d 54 24 08	 lea	 edx, DWORD PTR _finalMsg$[esp+16060]
  00055	52		 push	 edx
  00056	50		 push	 eax
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 510  : }

  0005d	8b 8c 24 b0 3e
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16052]
  00064	33 cc		 xor	 ecx, esp
  00066	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006b	81 c4 b4 3e 00
	00		 add	 esp, 16052		; 00003eb4H
  00071	c3		 ret	 0
_ReportUnexpectedState ENDP
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Myptr
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ?_Myptr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IBEPB_WXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IBEPB_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 2175 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  00000	83 79 18 08	 cmp	 DWORD PTR [ecx+24], 8
  00004	72 04		 jb	 SHORT $LN3@Myptr
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 2176 : 		}

  00009	c3		 ret	 0
$LN3@Myptr:

; 2175 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  0000a	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 2176 : 		}

  0000d	c3		 ret	 0
?_Myptr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IBEPB_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Myptr
_TEXT	ENDS
PUBLIC	??0?$allocator@_W@std@@QAE@XZ			; std::allocator<wchar_t>::allocator<wchar_t>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@_W@std@@QAE@XZ PROC			; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

  00002	c3		 ret	 0
??0?$allocator@_W@std@@QAE@XZ ENDP			; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
PUBLIC	?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size, COMDAT
; _this$ = ecx

; 1666 : 		return (_Mysize);

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 1667 : 		}

  00003	c3		 ret	 0
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEPA_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Myptr
; Function compile flags: /Ogtpy
;	COMDAT ?_Myptr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEPA_WXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEPA_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 2170 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  00000	83 79 18 08	 cmp	 DWORD PTR [ecx+24], 8
  00004	72 04		 jb	 SHORT $LN3@Myptr@2
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 2171 : 		}

  00009	c3		 ret	 0
$LN3@Myptr@2:

; 2170 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  0000a	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 2171 : 		}

  0000d	c3		 ret	 0
?_Myptr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEPA_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Myptr
_TEXT	ENDS
PUBLIC	??0?$allocator@_W@std@@QAE@ABV01@@Z		; std::allocator<wchar_t>::allocator<wchar_t>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@_W@std@@QAE@ABV01@@Z PROC		; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@_W@std@@QAE@ABV01@@Z ENDP		; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z	; std::allocator<wchar_t>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z PROC	; std::allocator<wchar_t>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 141  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ENDP	; std::allocator<wchar_t>::deallocate
_TEXT	ENDS
PUBLIC	?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAE_NPB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAE_NPB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside, COMDAT
; _this$ = ecx

; 2133 : 		{	// test if _Ptr points inside string

  00000	56		 push	 esi
  00001	57		 push	 edi

; 2134 : 		if (_Ptr == 0 || _Ptr < _Myptr() || _Myptr() + _Mysize <= _Ptr)

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR __Ptr$[esp+4]
  00006	85 ff		 test	 edi, edi
  00008	74 2d		 je	 SHORT $LN2@Inside
  0000a	8b 71 18	 mov	 esi, DWORD PTR [ecx+24]
  0000d	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00010	83 fe 08	 cmp	 esi, 8
  00013	72 04		 jb	 SHORT $LN8@Inside
  00015	8b 10		 mov	 edx, DWORD PTR [eax]
  00017	eb 02		 jmp	 SHORT $LN9@Inside
$LN8@Inside:
  00019	8b d0		 mov	 edx, eax
$LN9@Inside:
  0001b	3b fa		 cmp	 edi, edx
  0001d	72 18		 jb	 SHORT $LN2@Inside
  0001f	83 fe 08	 cmp	 esi, 8
  00022	72 02		 jb	 SHORT $LN12@Inside
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
$LN12@Inside:
  00026	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00029	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  0002c	3b d7		 cmp	 edx, edi
  0002e	76 07		 jbe	 SHORT $LN2@Inside
  00030	5f		 pop	 edi

; 2136 : 		else
; 2137 : 			return (true);

  00031	b0 01		 mov	 al, 1
  00033	5e		 pop	 esi

; 2138 : 		}

  00034	c2 04 00	 ret	 4
$LN2@Inside:
  00037	5f		 pop	 edi

; 2135 : 			return (false);	// don't ask

  00038	32 c0		 xor	 al, al
  0003a	5e		 pop	 esi

; 2138 : 		}

  0003b	c2 04 00	 ret	 4
?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAE_NPB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@_W@std@@QBEIXZ		; std::allocator<wchar_t>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@_W@std@@QBEIXZ PROC		; std::allocator<wchar_t>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 167  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@_W@std@@QBEIXZ ENDP		; std::allocator<wchar_t>::max_size
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@_W@std@@YAPA_WIPA_W@Z		; std::_Allocate<wchar_t>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT
$T88830 = -12						; size = 12
$T88835 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@_W@std@@YAPA_WIPA_W@Z PROC			; std::_Allocate<wchar_t>, COMDAT

; 37   : 	if (_Count <= 0)

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00007	85 c9		 test	 ecx, ecx
  00009	77 12		 ja	 SHORT $LN3@Allocate

; 38   : 		_Count = 0;

  0000b	33 c9		 xor	 ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

  0000d	8d 14 09	 lea	 edx, DWORD PTR [ecx+ecx]
  00010	52		 push	 edx
  00011	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00016	83 c4 04	 add	 esp, 4

; 44   : 	}

  00019	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001c	c3		 ret	 0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

  0001d	83 c8 ff	 or	 eax, -1
  00020	33 d2		 xor	 edx, edx
  00022	f7 f1		 div	 ecx
  00024	83 f8 02	 cmp	 eax, 2
  00027	73 e4		 jae	 SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

  00029	8d 44 24 10	 lea	 eax, DWORD PTR $T88835[esp+8]
  0002d	50		 push	 eax
  0002e	8d 4c 24 04	 lea	 ecx, DWORD PTR $T88830[esp+16]
  00032	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR $T88835[esp+12], 0
  0003a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003f	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00044	8d 4c 24 04	 lea	 ecx, DWORD PTR $T88830[esp+16]
  00048	51		 push	 ecx
  00049	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR $T88830[esp+20], OFFSET ??_7bad_alloc@std@@6B@
  00051	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN8@Allocate:
  00056	cc		 int	 3
??$_Allocate@_W@std@@YAPA_WIPA_W@Z ENDP			; std::_Allocate<wchar_t>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___that$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$_Char_traits_cat@U?$char_traits@_W@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ ; std::_Char_traits_cat<std::char_traits<wchar_t> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\iosfwd
;	COMDAT ??$_Char_traits_cat@U?$char_traits@_W@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ
_TEXT	SEGMENT
__Secure$ = -1						; size = 1
??$_Char_traits_cat@U?$char_traits@_W@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ PROC ; std::_Char_traits_cat<std::char_traits<wchar_t> >, COMDAT

; 575  : 	{

  00000	51		 push	 ecx

; 576  : 		typename _Char_traits_category<_Traits>::_Secure_char_traits _Secure;
; 577  : 		return (_Secure);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Secure$[esp+4]

; 578  : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Char_traits_cat@U?$char_traits@_W@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ ENDP ; std::_Char_traits_cat<std::char_traits<wchar_t> >
_TEXT	ENDS
PUBLIC	??$copy_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WIU_Secure_char_traits_tag@1@@Z ; std::_Traits_helper::copy_s<std::char_traits<wchar_t> >
; Function compile flags: /Ogtpy
;	COMDAT ??$copy_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WIU_Secure_char_traits_tag@1@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
___formal$ = 24						; size = 1
??$copy_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WIU_Secure_char_traits_tag@1@@Z PROC ; std::_Traits_helper::copy_s<std::char_traits<wchar_t> >, COMDAT

; 597  : 		return _Traits::_Copy_s(_First1, _Size, _First2, _Count);

  00000	8b 44 24 10	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8b 54 24 0c	 mov	 edx, DWORD PTR __First2$[esp-4]
  00008	56		 push	 esi
  00009	8b 74 24 08	 mov	 esi, DWORD PTR __First1$[esp]
  0000d	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00010	8b 44 24 0c	 mov	 eax, DWORD PTR __Size$[esp]
  00014	51		 push	 ecx
  00015	52		 push	 edx
  00016	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00019	51		 push	 ecx
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 _memcpy_s
  00020	83 c4 10	 add	 esp, 16			; 00000010H
  00023	8b c6		 mov	 eax, esi
  00025	5e		 pop	 esi

; 598  : 	}

  00026	c3		 ret	 0
??$copy_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WIU_Secure_char_traits_tag@1@@Z ENDP ; std::_Traits_helper::copy_s<std::char_traits<wchar_t> >
_TEXT	ENDS
PUBLIC	??$move_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WIU_Secure_char_traits_tag@1@@Z ; std::_Traits_helper::move_s<std::char_traits<wchar_t> >
; Function compile flags: /Ogtpy
;	COMDAT ??$move_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WIU_Secure_char_traits_tag@1@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
___formal$ = 24						; size = 1
??$move_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WIU_Secure_char_traits_tag@1@@Z PROC ; std::_Traits_helper::move_s<std::char_traits<wchar_t> >, COMDAT

; 624  : 		return _Traits::_Move_s(_First1, _Size, _First2, _Count);

  00000	8b 44 24 10	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8b 54 24 0c	 mov	 edx, DWORD PTR __First2$[esp-4]
  00008	56		 push	 esi
  00009	8b 74 24 08	 mov	 esi, DWORD PTR __First1$[esp]
  0000d	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00010	8b 44 24 0c	 mov	 eax, DWORD PTR __Size$[esp]
  00014	51		 push	 ecx
  00015	52		 push	 edx
  00016	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00019	51		 push	 ecx
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 _memmove_s
  00020	83 c4 10	 add	 esp, 16			; 00000010H
  00023	8b c6		 mov	 eax, esi
  00025	5e		 pop	 esi

; 625  : 	}

  00026	c3		 ret	 0
??$move_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WIU_Secure_char_traits_tag@1@@Z ENDP ; std::_Traits_helper::move_s<std::char_traits<wchar_t> >
_TEXT	ENDS
PUBLIC	??_C@_0BD@NLNANBEJ@ERR_HARDWARE_ERROR?$AA@	; `string'
PUBLIC	??_C@_0BC@GIPDODAO@ERR_ACCESS_DENIED?$AA@	; `string'
PUBLIC	_handleWin32Error
EXTRN	_HandleDriveNotReadyError:PROC
EXTRN	_IsDiskError:PROC
EXTRN	__imp__LocalFree@4:PROC
EXTRN	_IsAdmin:PROC
;	COMDAT ??_C@_0BD@NLNANBEJ@ERR_HARDWARE_ERROR?$AA@
; File c:\home\public\desktop\projects\ciphershed.build\src\common\dialog\errors.cpp
CONST	SEGMENT
??_C@_0BD@NLNANBEJ@ERR_HARDWARE_ERROR?$AA@ DB 'ERR_HARDWARE_ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GIPDODAO@ERR_ACCESS_DENIED?$AA@
CONST	SEGMENT
??_C@_0BC@GIPDODAO@ERR_ACCESS_DENIED?$AA@ DB 'ERR_ACCESS_DENIED', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _handleWin32Error
_TEXT	SEGMENT
_lpMsgBuf$ = -4						; size = 4
_hwndDlg$ = 8						; size = 4
_handleWin32Error PROC					; COMDAT

; 32   : {

  00000	51		 push	 ecx
  00001	56		 push	 esi

; 33   : 	PWSTR lpMsgBuf;
; 34   : 	DWORD dwError = GetLastError ();

  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 35   : 
; 36   : 	if (Silent || dwError == 0 || dwError == ERROR_INVALID_WINDOW_HANDLE)

  00008	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  0000f	8b f0		 mov	 esi, eax
  00011	0f 85 a8 00 00
	00		 jne	 $LN6@handleWin3
  00017	85 f6		 test	 esi, esi
  00019	0f 84 a0 00 00
	00		 je	 $LN6@handleWin3
  0001f	81 fe 78 05 00
	00		 cmp	 esi, 1400		; 00000578H
  00025	0f 84 94 00 00
	00		 je	 $LN6@handleWin3

; 37   : 		return dwError;
; 38   : 
; 39   : 	// Access denied
; 40   : 	if (dwError == ERROR_ACCESS_DENIED && !IsAdmin ())

  0002b	83 fe 05	 cmp	 esi, 5
  0002e	75 22		 jne	 SHORT $LN3@handleWin3
  00030	e8 00 00 00 00	 call	 _IsAdmin
  00035	85 c0		 test	 eax, eax
  00037	75 19		 jne	 SHORT $LN3@handleWin3

; 41   : 	{
; 42   : 		Error ("ERR_ACCESS_DENIED");

  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@GIPDODAO@ERR_ACCESS_DENIED?$AA@
  0003e	e8 00 00 00 00	 call	 _Error
  00043	83 c4 04	 add	 esp, 4

; 43   : 		SetLastError (dwError);		// Preserve the original error code

  00046	56		 push	 esi
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 44   : 		return dwError;

  0004d	8b c6		 mov	 eax, esi
  0004f	5e		 pop	 esi

; 71   : }

  00050	59		 pop	 ecx
  00051	c3		 ret	 0
$LN3@handleWin3:

; 45   : 	}
; 46   : 
; 47   : 	FormatMessageW (
; 48   : 		FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
; 49   : 			      NULL,
; 50   : 			      dwError,
; 51   : 			      MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT),	/* Default language */
; 52   : 			      (PWSTR) &lpMsgBuf,
; 53   : 			      0,
; 54   : 			      NULL
; 55   : 	    );

  00052	6a 00		 push	 0
  00054	6a 00		 push	 0
  00056	8d 44 24 0c	 lea	 eax, DWORD PTR _lpMsgBuf$[esp+16]
  0005a	50		 push	 eax
  0005b	68 00 04 00 00	 push	 1024			; 00000400H
  00060	56		 push	 esi
  00061	6a 00		 push	 0
  00063	68 00 11 00 00	 push	 4352			; 00001100H
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FormatMessageW@28

; 56   : 
; 57   : 	MessageBoxW (hwndDlg, lpMsgBuf, (LPCWSTR)lpszTitle, ICON_HAND);

  0006e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpszTitle
  00074	8b 54 24 04	 mov	 edx, DWORD PTR _lpMsgBuf$[esp+8]
  00078	8b 44 24 0c	 mov	 eax, DWORD PTR _hwndDlg$[esp+4]
  0007c	6a 10		 push	 16			; 00000010H
  0007e	51		 push	 ecx
  0007f	52		 push	 edx
  00080	50		 push	 eax
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 58   : 	LocalFree (lpMsgBuf);

  00087	8b 4c 24 04	 mov	 ecx, DWORD PTR _lpMsgBuf$[esp+8]
  0008b	51		 push	 ecx
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalFree@4

; 59   : 
; 60   : 	// User-friendly hardware error explanation
; 61   : 	if (IsDiskError (dwError))

  00092	56		 push	 esi
  00093	e8 00 00 00 00	 call	 _IsDiskError
  00098	83 c4 04	 add	 esp, 4
  0009b	85 c0		 test	 eax, eax
  0009d	74 0d		 je	 SHORT $LN2@handleWin3

; 62   : 		Error ("ERR_HARDWARE_ERROR");

  0009f	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@NLNANBEJ@ERR_HARDWARE_ERROR?$AA@
  000a4	e8 00 00 00 00	 call	 _Error
  000a9	83 c4 04	 add	 esp, 4
$LN2@handleWin3:

; 63   : 
; 64   : 	// Device not ready
; 65   : 	if (dwError == ERROR_NOT_READY)

  000ac	83 fe 15	 cmp	 esi, 21			; 00000015H
  000af	75 05		 jne	 SHORT $LN1@handleWin3

; 66   : 		HandleDriveNotReadyError();

  000b1	e8 00 00 00 00	 call	 _HandleDriveNotReadyError
$LN1@handleWin3:

; 67   : 
; 68   : 	SetLastError (dwError);		// Preserve the original error code

  000b6	56		 push	 esi
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 69   : 
; 70   : 	return dwError;

  000bd	8b c6		 mov	 eax, esi
$LN6@handleWin3:
  000bf	5e		 pop	 esi

; 71   : }

  000c0	59		 pop	 ecx
  000c1	c3		 ret	 0
_handleWin32Error ENDP
_TEXT	ENDS
PUBLIC	_ErrorDirect
; Function compile flags: /Ogtpy
;	COMDAT _ErrorDirect
_TEXT	SEGMENT
_errMsg$ = 8						; size = 4
_ErrorDirect PROC					; COMDAT

; 369  : 	return ErrorDirectTitle(errMsg, lpszTitle);

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	74 03		 je	 SHORT $LN3@ErrorDirec@2
  00009	33 c0		 xor	 eax, eax

; 370  : }

  0000b	c3		 ret	 0

; 369  : 	return ErrorDirectTitle(errMsg, lpszTitle);

$LN3@ErrorDirec@2:
  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  00011	8b 4c 24 04	 mov	 ecx, DWORD PTR _errMsg$[esp-4]
  00015	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  0001b	6a 10		 push	 16			; 00000010H
  0001d	50		 push	 eax
  0001e	51		 push	 ecx
  0001f	52		 push	 edx
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 370  : }

  00026	c3		 ret	 0
_ErrorDirect ENDP
_TEXT	ENDS
PUBLIC	_AskWarnYesNo
; Function compile flags: /Ogtpy
;	COMDAT _AskWarnYesNo
_TEXT	SEGMENT
_stringId$ = 8						; size = 4
_AskWarnYesNo PROC					; COMDAT

; 416  : 	return AskWarnYesNoTitle(stringId, lpszTitle);

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  00007	74 06		 je	 SHORT $LN3@AskWarnYes@5
  00009	b8 07 00 00 00	 mov	 eax, 7

; 417  : }

  0000e	c3		 ret	 0

; 416  : 	return AskWarnYesNoTitle(stringId, lpszTitle);

$LN3@AskWarnYes@5:
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  00014	8b 4c 24 04	 mov	 ecx, DWORD PTR _stringId$[esp-4]
  00018	6a 34		 push	 52			; 00000034H
  0001a	50		 push	 eax
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 _GetString
  00021	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  00027	83 c4 04	 add	 esp, 4
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 417  : }

  00032	c3		 ret	 0
_AskWarnYesNo ENDP
_TEXT	ENDS
PUBLIC	?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str, COMDAT
; _this$ = ecx

; 1651 : 		return (_Myptr());

  00000	83 79 18 08	 cmp	 DWORD PTR [ecx+24], 8
  00004	72 04		 jb	 SHORT $LN5@c_str
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1652 : 		}

  00009	c3		 ret	 0

; 1651 : 		return (_Myptr());

$LN5@c_str:
  0000a	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 1652 : 		}

  0000d	c3		 ret	 0
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
_TEXT	ENDS
PUBLIC	??0?$_String_val@_WV?$allocator@_W@std@@@std@@IAE@V?$allocator@_W@1@@Z ; std::_String_val<wchar_t,std::allocator<wchar_t> >::_String_val<wchar_t,std::allocator<wchar_t> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_String_val@_WV?$allocator@_W@std@@@std@@IAE@V?$allocator@_W@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_String_val@_WV?$allocator@_W@std@@@std@@IAE@V?$allocator@_W@1@@Z PROC ; std::_String_val<wchar_t,std::allocator<wchar_t> >::_String_val<wchar_t,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 472  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 473  : 		}

  00002	c2 04 00	 ret	 4
??0?$_String_val@_WV?$allocator@_W@std@@@std@@IAE@V?$allocator@_W@1@@Z ENDP ; std::_String_val<wchar_t,std::allocator<wchar_t> >::_String_val<wchar_t,std::allocator<wchar_t> >
_TEXT	ENDS
PUBLIC	??0?$_String_val@_WV?$allocator@_W@std@@@std@@QAE@ABV01@@Z ; std::_String_val<wchar_t,std::allocator<wchar_t> >::_String_val<wchar_t,std::allocator<wchar_t> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_String_val@_WV?$allocator@_W@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_String_val@_WV?$allocator@_W@std@@@std@@QAE@ABV01@@Z PROC ; std::_String_val<wchar_t,std::allocator<wchar_t> >::_String_val<wchar_t,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 478  : 		{	// copy constructor

  00000	8b c1		 mov	 eax, ecx

; 479  : #if defined(_DEBUG)
; 480  : 		if (_Right._Myfirstiter == _IGNORE_MYITERLIST)
; 481  : 			{
; 482  : 			this->_Myfirstiter = _IGNORE_MYITERLIST;
; 483  : 			}
; 484  : #endif
; 485  : 		}

  00002	c2 04 00	 ret	 4
??0?$_String_val@_WV?$allocator@_W@std@@@std@@QAE@ABV01@@Z ENDP ; std::_String_val<wchar_t,std::allocator<wchar_t> >::_String_val<wchar_t,std::allocator<wchar_t> >
_TEXT	ENDS
PUBLIC	?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
; Function compile flags: /Ogtpy
;	COMDAT ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos, COMDAT
; _this$ = ecx

; 2114 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Newsize$[esp-4]
  00004	33 d2		 xor	 edx, edx
  00006	83 79 18 08	 cmp	 DWORD PTR [ecx+24], 8
  0000a	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  0000d	72 0a		 jb	 SHORT $LN5@Eos
  0000f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00012	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 2115 : 		}

  00016	c2 04 00	 ret	 4

; 2114 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

$LN5@Eos:
  00019	66 89 54 41 04	 mov	 WORD PTR [ecx+eax*2+4], dx

; 2115 : 		}

  0001e	c2 04 00	 ret	 4
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
_TEXT	ENDS
PUBLIC	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size, COMDAT
; _this$ = ecx

; 1671 : 		size_type _Num = _Mybase::_Alval.max_size();
; 1672 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH

; 1673 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@_W@std@@QAEPA_WI@Z	; std::allocator<wchar_t>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@_W@std@@QAEPA_WI@Z PROC		; std::allocator<wchar_t>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	6a 00		 push	 0
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z ; std::_Allocate<wchar_t>
  0000c	83 c4 08	 add	 esp, 8

; 146  : 		}

  0000f	c2 04 00	 ret	 4
?allocate@?$allocator@_W@std@@QAEPA_WI@Z ENDP		; std::allocator<wchar_t>::allocate
_TEXT	ENDS
PUBLIC	??$copy_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WI@Z ; std::_Traits_helper::copy_s<std::char_traits<wchar_t> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\iosfwd
;	COMDAT ??$copy_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
??$copy_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WI@Z PROC ; std::_Traits_helper::copy_s<std::char_traits<wchar_t> >, COMDAT

; 589  : 		return copy_s<_Traits>(_First1, _Size, _First2, _Count, _Char_traits_cat<_Traits>());

  00000	8b 44 24 10	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8b 54 24 0c	 mov	 edx, DWORD PTR __First2$[esp-4]
  00008	56		 push	 esi
  00009	8b 74 24 08	 mov	 esi, DWORD PTR __First1$[esp]
  0000d	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00010	8b 44 24 0c	 mov	 eax, DWORD PTR __Size$[esp]
  00014	51		 push	 ecx
  00015	52		 push	 edx
  00016	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00019	51		 push	 ecx
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 _memcpy_s
  00020	83 c4 10	 add	 esp, 16			; 00000010H
  00023	8b c6		 mov	 eax, esi
  00025	5e		 pop	 esi

; 590  : 	}

  00026	c3		 ret	 0
??$copy_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WI@Z ENDP ; std::_Traits_helper::copy_s<std::char_traits<wchar_t> >
_TEXT	ENDS
PUBLIC	??$move_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WI@Z ; std::_Traits_helper::move_s<std::char_traits<wchar_t> >
; Function compile flags: /Ogtpy
;	COMDAT ??$move_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
??$move_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WI@Z PROC ; std::_Traits_helper::move_s<std::char_traits<wchar_t> >, COMDAT

; 616  : 		return move_s<_Traits>(_First1, _Size, _First2, _Count, _Char_traits_cat<_Traits>());

  00000	8b 44 24 10	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8b 54 24 0c	 mov	 edx, DWORD PTR __First2$[esp-4]
  00008	56		 push	 esi
  00009	8b 74 24 08	 mov	 esi, DWORD PTR __First1$[esp]
  0000d	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00010	8b 44 24 0c	 mov	 eax, DWORD PTR __Size$[esp]
  00014	51		 push	 ecx
  00015	52		 push	 edx
  00016	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00019	51		 push	 ecx
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 _memmove_s
  00020	83 c4 10	 add	 esp, 16			; 00000010H
  00023	8b c6		 mov	 eax, esi
  00025	5e		 pop	 esi

; 617  : 	}

  00026	c3		 ret	 0
??$move_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WI@Z ENDP ; std::_Traits_helper::move_s<std::char_traits<wchar_t> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEX_NI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy, COMDAT
; _this$ = ecx

; 2149 : 		if (!_Built)

  00000	80 7c 24 04 00	 cmp	 BYTE PTR __Built$[esp-4], 0
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b 7c 24 10	 mov	 edi, DWORD PTR __Newsize$[esp+4]
  0000b	8b f1		 mov	 esi, ecx
  0000d	74 2a		 je	 SHORT $LN17@Tidy

; 2150 : 			;
; 2151 : 		else if (_BUF_SIZE <= _Myres)

  0000f	83 7e 18 08	 cmp	 DWORD PTR [esi+24], 8
  00013	72 24		 jb	 SHORT $LN17@Tidy

; 2152 : 			{	// copy any leftovers to small buffer and deallocate
; 2153 : 			_Elem *_Ptr = _Bx._Ptr;

  00015	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00018	53		 push	 ebx
  00019	8b 18		 mov	 ebx, DWORD PTR [eax]

; 2154 : 			if (0 < _Newsize)

  0001b	85 ff		 test	 edi, edi
  0001d	76 10		 jbe	 SHORT $LN15@Tidy

; 2155 : 				_Traits_helper::copy_s<_Traits>(_Bx._Buf, _BUF_SIZE, _Ptr, _Newsize);

  0001f	8d 0c 3f	 lea	 ecx, DWORD PTR [edi+edi]
  00022	51		 push	 ecx
  00023	53		 push	 ebx
  00024	6a 10		 push	 16			; 00000010H
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 _memcpy_s
  0002c	83 c4 10	 add	 esp, 16			; 00000010H
$LN15@Tidy:

; 2156 : 			_Mybase::_Alval.deallocate(_Ptr, _Myres + 1);

  0002f	53		 push	 ebx
  00030	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00035	83 c4 04	 add	 esp, 4
  00038	5b		 pop	 ebx
$LN17@Tidy:

; 2157 : 			}
; 2158 : 		_Myres = _BUF_SIZE - 1;
; 2159 : 		_Eos(_Newsize);

  00039	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  0003c	c7 46 18 07 00
	00 00		 mov	 DWORD PTR [esi+24], 7
  00043	33 d2		 xor	 edx, edx
  00045	66 89 54 7e 04	 mov	 WORD PTR [esi+edi*2+4], dx
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi

; 2160 : 		}

  0004c	c2 08 00	 ret	 8
?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEX_NI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
EXTRN	?_Xran@_String_base@std@@SAXXZ:PROC		; std::_String_base::_Xran
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
tv133 = 8						; size = 4
__Off$ = 8						; size = 4
tv139 = 12						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase, COMDAT
; _this$ = ecx

; 1262 : 		{	// erase elements [_Off, _Off + _Count)

  00000	53		 push	 ebx

; 1263 : 		if (_Mysize < _Off)

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR __Off$[esp]
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	57		 push	 edi
  00009	39 5e 14	 cmp	 DWORD PTR [esi+20], ebx
  0000c	73 05		 jae	 SHORT $LN3@erase

; 1264 : 			_String_base::_Xran();	// _Off off end

  0000e	e8 00 00 00 00	 call	 ?_Xran@_String_base@std@@SAXXZ ; std::_String_base::_Xran
$LN3@erase:

; 1265 : 		if (_Mysize - _Off < _Count)

  00013	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00016	8b 7c 24 14	 mov	 edi, DWORD PTR __Count$[esp+8]
  0001a	2b c3		 sub	 eax, ebx
  0001c	3b c7		 cmp	 eax, edi
  0001e	73 02		 jae	 SHORT $LN2@erase

; 1266 : 			_Count = _Mysize - _Off;	// trim _Count

  00020	8b f8		 mov	 edi, eax
$LN2@erase:

; 1267 : 		if (0 < _Count)

  00022	85 ff		 test	 edi, edi
  00024	76 69		 jbe	 SHORT $LN32@erase

; 1268 : 			{	// move elements down
; 1269 : 			_Traits_helper::move_s<_Traits>(_Myptr() + _Off, _Myres - _Off, _Myptr() + _Off + _Count,
; 1270 : 				_Mysize - _Off - _Count);

  00026	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00029	55		 push	 ebp
  0002a	8d 6e 04	 lea	 ebp, DWORD PTR [esi+4]
  0002d	83 f9 08	 cmp	 ecx, 8
  00030	72 09		 jb	 SHORT $LN8@erase
  00032	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  00035	89 54 24 14	 mov	 DWORD PTR tv133[esp+12], edx
  00039	eb 04		 jmp	 SHORT $LN9@erase
$LN8@erase:
  0003b	89 6c 24 14	 mov	 DWORD PTR tv133[esp+12], ebp
$LN9@erase:
  0003f	83 f9 08	 cmp	 ecx, 8
  00042	72 09		 jb	 SHORT $LN12@erase
  00044	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  00047	89 54 24 18	 mov	 DWORD PTR tv139[esp+12], edx
  0004b	eb 04		 jmp	 SHORT $LN13@erase
$LN12@erase:
  0004d	89 6c 24 18	 mov	 DWORD PTR tv139[esp+12], ebp
$LN13@erase:
  00051	8b 54 24 14	 mov	 edx, DWORD PTR tv133[esp+12]
  00055	2b c7		 sub	 eax, edi
  00057	03 c0		 add	 eax, eax
  00059	50		 push	 eax
  0005a	8d 04 3b	 lea	 eax, DWORD PTR [ebx+edi]
  0005d	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00060	2b cb		 sub	 ecx, ebx
  00062	50		 push	 eax
  00063	03 c9		 add	 ecx, ecx
  00065	51		 push	 ecx
  00066	8b 4c 24 24	 mov	 ecx, DWORD PTR tv139[esp+24]
  0006a	8d 14 59	 lea	 edx, DWORD PTR [ecx+ebx*2]
  0006d	52		 push	 edx
  0006e	e8 00 00 00 00	 call	 _memmove_s

; 1271 : 			size_type _Newsize = _Mysize - _Count;

  00073	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00076	2b c7		 sub	 eax, edi
  00078	83 c4 10	 add	 esp, 16			; 00000010H

; 1272 : 			_Eos(_Newsize);

  0007b	83 7e 18 08	 cmp	 DWORD PTR [esi+24], 8
  0007f	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00082	72 03		 jb	 SHORT $LN28@erase
  00084	8b 6d 00	 mov	 ebp, DWORD PTR [ebp]
$LN28@erase:
  00087	33 c9		 xor	 ecx, ecx
  00089	66 89 4c 45 00	 mov	 WORD PTR [ebp+eax*2], cx
  0008e	5d		 pop	 ebp
$LN32@erase:
  0008f	5f		 pop	 edi

; 1273 : 			}
; 1274 : 		return (*this);

  00090	8b c6		 mov	 eax, esi
  00092	5e		 pop	 esi
  00093	5b		 pop	 ebx

; 1275 : 		}

  00094	c2 08 00	 ret	 8
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
_TEXT	ENDS
PUBLIC	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z$0
__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z
_TEXT	SEGMENT
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newres$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy, COMDAT
; _this$ = ecx

; 2083 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx
  0002d	89 7d ec	 mov	 DWORD PTR _this$[ebp], edi

; 2084 : 		size_type _Newres = _Newsize | _ALLOC_MASK;

  00030	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00033	8b f0		 mov	 esi, eax
  00035	83 ce 07	 or	 esi, 7

; 2085 : 		if (max_size() < _Newres)

  00038	81 fe fe ff ff
	7f		 cmp	 esi, 2147483646		; 7ffffffeH
  0003e	76 04		 jbe	 SHORT $LN6@Copy

; 2086 : 			_Newres = _Newsize;	// undo roundup if too big

  00040	8b f0		 mov	 esi, eax

; 2087 : 		else if (_Newres / 3 < _Myres / 2

  00042	eb 22		 jmp	 SHORT $LN4@Copy
$LN6@Copy:

; 2088 : 			&& _Myres <= max_size() - _Myres / 2)

  00044	8b 5f 18	 mov	 ebx, DWORD PTR [edi+24]
  00047	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0004c	f7 e6		 mul	 esi
  0004e	8b cb		 mov	 ecx, ebx
  00050	d1 e9		 shr	 ecx, 1
  00052	d1 ea		 shr	 edx, 1
  00054	3b d1		 cmp	 edx, ecx
  00056	73 0e		 jae	 SHORT $LN4@Copy
  00058	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH
  0005d	2b c1		 sub	 eax, ecx
  0005f	3b d8		 cmp	 ebx, eax
  00061	77 03		 ja	 SHORT $LN4@Copy

; 2089 : 			_Newres = _Myres + _Myres / 2;	// grow exponentially if possible

  00063	8d 34 19	 lea	 esi, DWORD PTR [ecx+ebx]
$LN4@Copy:

; 2090 : 		_Elem *_Ptr = 0;
; 2091 : 
; 2092 : 		_TRY_BEGIN
; 2093 : 			_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

  00066	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  00069	6a 00		 push	 0
  0006b	51		 push	 ecx
  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00073	e8 00 00 00 00	 call	 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z ; std::_Allocate<wchar_t>
  00078	83 c4 08	 add	 esp, 8
  0007b	8b d8		 mov	 ebx, eax
  0007d	eb 2b		 jmp	 SHORT $LN16@Copy
__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z$0:

; 2094 : 		_CATCH_ALL
; 2095 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  0007f	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00082	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00085	89 45 08	 mov	 DWORD PTR __Newres$[ebp], eax

; 2096 : 			_TRY_BEGIN
; 2097 : 				_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

  00088	40		 inc	 eax
  00089	6a 00		 push	 0
  0008b	50		 push	 eax
  0008c	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00090	e8 00 00 00 00	 call	 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z ; std::_Allocate<wchar_t>
  00095	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
  00098	83 c4 08	 add	 esp, 8

; 2101 : 			_CATCH_END
; 2102 : 		_CATCH_END

  0009b	b8 00 00 00 00	 mov	 eax, $LN112@Copy
  000a0	c3		 ret	 0
$LN112@Copy:
  000a1	8b 7d ec	 mov	 edi, DWORD PTR _this$[ebp]
  000a4	8b 75 08	 mov	 esi, DWORD PTR __Newres$[ebp]
  000a7	8b 5d e8	 mov	 ebx, DWORD PTR __Ptr$[ebp]
$LN16@Copy:

; 2103 : 
; 2104 : 		if (0 < _Oldlen)

  000aa	8b 4d 0c	 mov	 ecx, DWORD PTR __Oldlen$[ebp]
  000ad	85 c9		 test	 ecx, ecx
  000af	76 24		 jbe	 SHORT $LN75@Copy

; 2105 : 			_Traits_helper::copy_s<_Traits>(_Ptr, _Newres + 1, _Myptr(), _Oldlen);	// copy existing elements

  000b1	83 7f 18 08	 cmp	 DWORD PTR [edi+24], 8
  000b5	72 05		 jb	 SHORT $LN65@Copy
  000b7	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000ba	eb 03		 jmp	 SHORT $LN66@Copy
$LN65@Copy:
  000bc	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
$LN66@Copy:
  000bf	8d 14 09	 lea	 edx, DWORD PTR [ecx+ecx]
  000c2	52		 push	 edx
  000c3	50		 push	 eax
  000c4	8d 44 36 02	 lea	 eax, DWORD PTR [esi+esi+2]
  000c8	50		 push	 eax
  000c9	53		 push	 ebx
  000ca	e8 00 00 00 00	 call	 _memcpy_s
  000cf	8b 4d 0c	 mov	 ecx, DWORD PTR __Oldlen$[ebp]
  000d2	83 c4 10	 add	 esp, 16			; 00000010H
$LN75@Copy:

; 2106 : 		_Tidy(true);

  000d5	83 7f 18 08	 cmp	 DWORD PTR [edi+24], 8
  000d9	72 0f		 jb	 SHORT $LN93@Copy
  000db	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000de	51		 push	 ecx
  000df	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000e4	8b 4d 0c	 mov	 ecx, DWORD PTR __Oldlen$[ebp]
  000e7	83 c4 04	 add	 esp, 4
$LN93@Copy:
  000ea	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  000ed	33 d2		 xor	 edx, edx

; 2107 : 		_Bx._Ptr = _Ptr;

  000ef	89 18		 mov	 DWORD PTR [eax], ebx

; 2108 : 		_Myres = _Newres;

  000f1	89 77 18	 mov	 DWORD PTR [edi+24], esi

; 2109 : 		_Eos(_Oldlen);

  000f4	89 4f 14	 mov	 DWORD PTR [edi+20], ecx
  000f7	83 fe 08	 cmp	 esi, 8
  000fa	72 02		 jb	 SHORT $LN107@Copy
  000fc	8b c3		 mov	 eax, ebx
$LN107@Copy:
  000fe	33 d2		 xor	 edx, edx
  00100	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx

; 2110 : 		}

  00104	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00107	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0010e	59		 pop	 ecx
  0010f	5f		 pop	 edi
  00110	5e		 pop	 esi
  00111	5b		 pop	 ebx
  00112	8b e5		 mov	 esp, ebp
  00114	5d		 pop	 ebp
  00115	c2 08 00	 ret	 8
__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z$1:

; 2098 : 			_CATCH_ALL
; 2099 : 			_Tidy(true);	// failed again, discard storage and reraise

  00118	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  0011b	83 7e 18 08	 cmp	 DWORD PTR [esi+24], 8
  0011f	72 0c		 jb	 SHORT $LN53@Copy
  00121	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00124	50		 push	 eax
  00125	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0012a	83 c4 04	 add	 esp, 4
$LN53@Copy:
  0012d	33 c9		 xor	 ecx, ecx

; 2100 : 			_RERAISE;

  0012f	51		 push	 ecx
  00130	c7 46 18 07 00
	00 00		 mov	 DWORD PTR [esi+24], 7
  00137	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  0013e	51		 push	 ecx
  0013f	66 89 4e 04	 mov	 WORD PTR [esi+4], cx
  00143	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN115@Copy:
  00148	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 905  : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 906  : 		_Tidy(true);

  00003	83 7e 18 08	 cmp	 DWORD PTR [esi+24], 8
  00007	72 0c		 jb	 SHORT $LN19@basic_stri
  00009	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00012	83 c4 04	 add	 esp, 4
$LN19@basic_stri:
  00015	c7 46 18 07 00
	00 00		 mov	 DWORD PTR [esi+24], 7
  0001c	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00023	33 c9		 xor	 ecx, ecx
  00025	66 89 4e 04	 mov	 WORD PTR [esi+4], cx
  00029	5e		 pop	 esi

; 907  : 		}

  0002a	c3		 ret	 0
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
PUBLIC	?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
EXTRN	?_Xlen@_String_base@std@@SAXXZ:PROC		; std::_String_base::_Xlen
; Function compile flags: /Ogtpy
;	COMDAT ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAE_NI_N@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow, COMDAT
; _this$ = ecx

; 2119 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp

; 2120 : 			if (max_size() < _Newsize)

  00001	8b 6c 24 08	 mov	 ebp, DWORD PTR __Newsize$[esp]
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	81 fd fe ff ff
	7f		 cmp	 ebp, 2147483646		; 7ffffffeH
  0000e	76 05		 jbe	 SHORT $LN6@Grow

; 2121 : 			_String_base::_Xlen();	// result too long

  00010	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@SAXXZ ; std::_String_base::_Xlen
$LN6@Grow:

; 2122 : 		if (_Myres < _Newsize)

  00015	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00018	3b c5		 cmp	 eax, ebp
  0001a	73 19		 jae	 SHORT $LN5@Grow

; 2123 : 			_Copy(_Newsize, _Mysize);	// reallocate to grow

  0001c	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0001f	50		 push	 eax
  00020	55		 push	 ebp
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy

; 2129 : 		return (0 < _Newsize);	// return true only if more work to do

  00028	33 c9		 xor	 ecx, ecx
  0002a	3b cd		 cmp	 ecx, ebp
  0002c	1b c0		 sbb	 eax, eax
  0002e	5e		 pop	 esi
  0002f	f7 d8		 neg	 eax
  00031	5d		 pop	 ebp

; 2130 : 		}

  00032	c2 08 00	 ret	 8
$LN5@Grow:

; 2124 : 		else if (_Trim && _Newsize < _BUF_SIZE)

  00035	80 7c 24 10 00	 cmp	 BYTE PTR __Trim$[esp+4], 0
  0003a	74 57		 je	 SHORT $LN3@Grow
  0003c	83 fd 08	 cmp	 ebp, 8
  0003f	73 52		 jae	 SHORT $LN3@Grow
  00041	57		 push	 edi

; 2125 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2126 : 				_Newsize < _Mysize ? _Newsize : _Mysize);

  00042	8b 7e 14	 mov	 edi, DWORD PTR [esi+20]
  00045	3b ef		 cmp	 ebp, edi
  00047	73 02		 jae	 SHORT $LN9@Grow
  00049	8b fd		 mov	 edi, ebp
$LN9@Grow:
  0004b	83 f8 08	 cmp	 eax, 8
  0004e	72 24		 jb	 SHORT $LN35@Grow
  00050	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00053	53		 push	 ebx
  00054	8b 18		 mov	 ebx, DWORD PTR [eax]
  00056	85 ff		 test	 edi, edi
  00058	76 10		 jbe	 SHORT $LN33@Grow
  0005a	8d 0c 3f	 lea	 ecx, DWORD PTR [edi+edi]
  0005d	51		 push	 ecx
  0005e	53		 push	 ebx
  0005f	6a 10		 push	 16			; 00000010H
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 _memcpy_s
  00067	83 c4 10	 add	 esp, 16			; 00000010H
$LN33@Grow:
  0006a	53		 push	 ebx
  0006b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00070	83 c4 04	 add	 esp, 4
  00073	5b		 pop	 ebx
$LN35@Grow:
  00074	33 d2		 xor	 edx, edx
  00076	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00079	c7 46 18 07 00
	00 00		 mov	 DWORD PTR [esi+24], 7

; 2129 : 		return (0 < _Newsize);	// return true only if more work to do

  00080	33 c9		 xor	 ecx, ecx
  00082	66 89 54 7e 04	 mov	 WORD PTR [esi+edi*2+4], dx
  00087	3b cd		 cmp	 ecx, ebp
  00089	5f		 pop	 edi
  0008a	1b c0		 sbb	 eax, eax
  0008c	5e		 pop	 esi
  0008d	f7 d8		 neg	 eax
  0008f	5d		 pop	 ebp

; 2130 : 		}

  00090	c2 08 00	 ret	 8
$LN3@Grow:

; 2127 : 		else if (_Newsize == 0)

  00093	85 ed		 test	 ebp, ebp
  00095	75 25		 jne	 SHORT $LN51@Grow

; 2128 : 			_Eos(0);	// new size is zero, just null terminate

  00097	89 6e 14	 mov	 DWORD PTR [esi+20], ebp
  0009a	83 f8 08	 cmp	 eax, 8
  0009d	72 15		 jb	 SHORT $LN49@Grow
  0009f	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  000a2	33 c0		 xor	 eax, eax

; 2129 : 		return (0 < _Newsize);	// return true only if more work to do

  000a4	33 c9		 xor	 ecx, ecx
  000a6	3b cd		 cmp	 ecx, ebp
  000a8	66 89 06	 mov	 WORD PTR [esi], ax
  000ab	1b c0		 sbb	 eax, eax
  000ad	5e		 pop	 esi
  000ae	f7 d8		 neg	 eax
  000b0	5d		 pop	 ebp

; 2130 : 		}

  000b1	c2 08 00	 ret	 8

; 2128 : 			_Eos(0);	// new size is zero, just null terminate

$LN49@Grow:
  000b4	83 c6 04	 add	 esi, 4
  000b7	33 c0		 xor	 eax, eax
  000b9	66 89 06	 mov	 WORD PTR [esi], ax
$LN51@Grow:

; 2129 : 		return (0 < _Newsize);	// return true only if more work to do

  000bc	33 c9		 xor	 ecx, ecx
  000be	3b cd		 cmp	 ecx, ebp
  000c0	1b c0		 sbb	 eax, eax
  000c2	5e		 pop	 esi
  000c3	f7 d8		 neg	 eax
  000c5	5d		 pop	 ebp

; 2130 : 		}

  000c6	c2 08 00	 ret	 8
?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAE_NI_N@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; Function compile flags: /Ogtpy
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1046 : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	53		 push	 ebx

; 1047 : 		if (_Right.size() < _Roff)

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR __Roff$[esp]
  00005	55		 push	 ebp
  00006	8b 6c 24 0c	 mov	 ebp, DWORD PTR __Right$[esp+4]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f1		 mov	 esi, ecx
  0000e	39 5d 14	 cmp	 DWORD PTR [ebp+20], ebx
  00011	73 05		 jae	 SHORT $LN5@assign

; 1048 : 			_String_base::_Xran();	// _Roff off end

  00013	e8 00 00 00 00	 call	 ?_Xran@_String_base@std@@SAXXZ ; std::_String_base::_Xran
$LN5@assign:

; 1049 : 		size_type _Num = _Right.size() - _Roff;

  00018	8b 7d 14	 mov	 edi, DWORD PTR [ebp+20]

; 1050 : 		if (_Count < _Num)

  0001b	8b 44 24 1c	 mov	 eax, DWORD PTR __Count$[esp+12]
  0001f	2b fb		 sub	 edi, ebx
  00021	3b c7		 cmp	 eax, edi
  00023	73 02		 jae	 SHORT $LN4@assign

; 1051 : 			_Num = _Count;	// trim _Num to size

  00025	8b f8		 mov	 edi, eax
$LN4@assign:

; 1052 : 
; 1053 : 		if (this == &_Right)

  00027	3b f5		 cmp	 esi, ebp
  00029	75 1f		 jne	 SHORT $LN3@assign

; 1054 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  0002b	6a ff		 push	 -1
  0002d	03 fb		 add	 edi, ebx
  0002f	57		 push	 edi
  00030	8b ce		 mov	 ecx, esi
  00032	e8 00 00 00 00	 call	 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
  00037	53		 push	 ebx
  00038	6a 00		 push	 0
  0003a	8b ce		 mov	 ecx, esi
  0003c	e8 00 00 00 00	 call	 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
  00041	5f		 pop	 edi

; 1059 : 			}
; 1060 : 		return (*this);

  00042	8b c6		 mov	 eax, esi
  00044	5e		 pop	 esi
  00045	5d		 pop	 ebp
  00046	5b		 pop	 ebx

; 1061 : 		}

  00047	c2 0c 00	 ret	 12			; 0000000cH
$LN3@assign:

; 1055 : 		else if (_Grow(_Num))

  0004a	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00050	76 05		 jbe	 SHORT $LN17@assign
  00052	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@SAXXZ ; std::_String_base::_Xlen
$LN17@assign:
  00057	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0005a	3b c7		 cmp	 eax, edi
  0005c	73 1b		 jae	 SHORT $LN16@assign
  0005e	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00061	50		 push	 eax
  00062	57		 push	 edi
  00063	8b ce		 mov	 ecx, esi
  00065	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  0006a	85 ff		 test	 edi, edi
$LN91@assign:
  0006c	76 7a		 jbe	 SHORT $LN90@assign

; 1056 : 			{	// make room and assign new stuff
; 1057 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Right._Myptr() + _Roff, _Num);

  0006e	83 7d 18 08	 cmp	 DWORD PTR [ebp+24], 8
  00072	72 33		 jb	 SHORT $LN66@assign
  00074	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  00077	eb 31		 jmp	 SHORT $LN67@assign

; 1055 : 		else if (_Grow(_Num))

$LN16@assign:
  00079	85 ff		 test	 edi, edi
  0007b	75 ef		 jne	 SHORT $LN91@assign
  0007d	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00080	83 f8 08	 cmp	 eax, 8
  00083	72 11		 jb	 SHORT $LN60@assign
  00085	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00088	33 c9		 xor	 ecx, ecx
  0008a	5f		 pop	 edi
  0008b	66 89 08	 mov	 WORD PTR [eax], cx

; 1059 : 			}
; 1060 : 		return (*this);

  0008e	8b c6		 mov	 eax, esi
  00090	5e		 pop	 esi
  00091	5d		 pop	 ebp
  00092	5b		 pop	 ebx

; 1061 : 		}

  00093	c2 0c 00	 ret	 12			; 0000000cH

; 1055 : 		else if (_Grow(_Num))

$LN60@assign:
  00096	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00099	33 c9		 xor	 ecx, ecx
  0009b	5f		 pop	 edi
  0009c	66 89 08	 mov	 WORD PTR [eax], cx

; 1059 : 			}
; 1060 : 		return (*this);

  0009f	8b c6		 mov	 eax, esi
  000a1	5e		 pop	 esi
  000a2	5d		 pop	 ebp
  000a3	5b		 pop	 ebx

; 1061 : 		}

  000a4	c2 0c 00	 ret	 12			; 0000000cH

; 1056 : 			{	// make room and assign new stuff
; 1057 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Right._Myptr() + _Roff, _Num);

$LN66@assign:
  000a7	8d 4d 04	 lea	 ecx, DWORD PTR [ebp+4]
$LN67@assign:
  000aa	83 7e 18 08	 cmp	 DWORD PTR [esi+24], 8
  000ae	8d 6e 04	 lea	 ebp, DWORD PTR [esi+4]
  000b1	72 05		 jb	 SHORT $LN70@assign
  000b3	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  000b6	eb 02		 jmp	 SHORT $LN71@assign
$LN70@assign:
  000b8	8b c5		 mov	 eax, ebp
$LN71@assign:
  000ba	8b 54 24 18	 mov	 edx, DWORD PTR __Roff$[esp+12]
  000be	8d 0c 51	 lea	 ecx, DWORD PTR [ecx+edx*2]
  000c1	8d 1c 3f	 lea	 ebx, DWORD PTR [edi+edi]
  000c4	53		 push	 ebx
  000c5	51		 push	 ecx
  000c6	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  000c9	8d 14 09	 lea	 edx, DWORD PTR [ecx+ecx]
  000cc	52		 push	 edx
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 _memcpy_s
  000d3	83 c4 10	 add	 esp, 16			; 00000010H

; 1058 : 			_Eos(_Num);

  000d6	83 7e 18 08	 cmp	 DWORD PTR [esi+24], 8
  000da	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  000dd	72 03		 jb	 SHORT $LN86@assign
  000df	8b 6d 00	 mov	 ebp, DWORD PTR [ebp]
$LN86@assign:
  000e2	33 c0		 xor	 eax, eax
  000e4	66 89 04 2b	 mov	 WORD PTR [ebx+ebp], ax
$LN90@assign:
  000e8	5f		 pop	 edi

; 1059 : 			}
; 1060 : 		return (*this);

  000e9	8b c6		 mov	 eax, esi
  000eb	5e		 pop	 esi
  000ec	5d		 pop	 ebp
  000ed	5b		 pop	 ebx

; 1061 : 		}

  000ee	c2 0c 00	 ret	 12			; 0000000cH
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; Function compile flags: /Ogtpy
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1064 : 		{	// assign [_Ptr, _Ptr + _Count)

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 1065 : 
; 1066 :  #if _HAS_ITERATOR_DEBUGGING
; 1067 : 		if (_Count != 0)
; 1068 : 			_DEBUG_POINTER(_Ptr);
; 1069 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1070 : 
; 1071 : 		if (_Inside(_Ptr))

  00004	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Ptr$[esp+4]
  00008	57		 push	 edi
  00009	85 c9		 test	 ecx, ecx
  0000b	74 49		 je	 SHORT $LN97@assign@2
  0000d	8b 7e 18	 mov	 edi, DWORD PTR [esi+24]
  00010	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00013	83 ff 08	 cmp	 edi, 8
  00016	72 04		 jb	 SHORT $LN12@assign@2
  00018	8b 10		 mov	 edx, DWORD PTR [eax]
  0001a	eb 02		 jmp	 SHORT $LN13@assign@2
$LN12@assign@2:
  0001c	8b d0		 mov	 edx, eax
$LN13@assign@2:
  0001e	3b ca		 cmp	 ecx, edx
  00020	72 34		 jb	 SHORT $LN97@assign@2
  00022	83 ff 08	 cmp	 edi, 8
  00025	72 04		 jb	 SHORT $LN16@assign@2
  00027	8b 10		 mov	 edx, DWORD PTR [eax]
  00029	eb 02		 jmp	 SHORT $LN17@assign@2
$LN16@assign@2:
  0002b	8b d0		 mov	 edx, eax
$LN17@assign@2:
  0002d	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  00030	8d 14 5a	 lea	 edx, DWORD PTR [edx+ebx*2]
  00033	3b d1		 cmp	 edx, ecx
  00035	76 1f		 jbe	 SHORT $LN97@assign@2

; 1072 : 			return (assign(*this, _Ptr - _Myptr(), _Count));	// substring

  00037	83 ff 08	 cmp	 edi, 8
  0003a	72 02		 jb	 SHORT $LN20@assign@2
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN20@assign@2:
  0003e	8b 54 24 14	 mov	 edx, DWORD PTR __Count$[esp+8]
  00042	2b c8		 sub	 ecx, eax
  00044	52		 push	 edx
  00045	d1 f9		 sar	 ecx, 1
  00047	51		 push	 ecx
  00048	56		 push	 esi
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx

; 1080 : 		}

  00053	c2 08 00	 ret	 8
$LN97@assign@2:

; 1073 : 
; 1074 : 		if (_Grow(_Count))

  00056	8b 7c 24 14	 mov	 edi, DWORD PTR __Count$[esp+8]
  0005a	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00060	76 05		 jbe	 SHORT $LN27@assign@2
  00062	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@SAXXZ ; std::_String_base::_Xlen
$LN27@assign@2:
  00067	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0006a	3b c7		 cmp	 eax, edi
  0006c	73 21		 jae	 SHORT $LN26@assign@2
  0006e	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00071	50		 push	 eax
  00072	57		 push	 edi
  00073	8b ce		 mov	 ecx, esi
  00075	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  0007a	85 ff		 test	 edi, edi
$LN98@assign@2:
  0007c	76 67		 jbe	 SHORT $LN94@assign@2

; 1075 : 			{	// make room and assign new stuff
; 1076 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Ptr, _Count);

  0007e	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00081	55		 push	 ebp
  00082	8d 6e 04	 lea	 ebp, DWORD PTR [esi+4]
  00085	83 f9 08	 cmp	 ecx, 8
  00088	72 31		 jb	 SHORT $LN76@assign@2
  0008a	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  0008d	eb 2e		 jmp	 SHORT $LN77@assign@2

; 1073 : 
; 1074 : 		if (_Grow(_Count))

$LN26@assign@2:
  0008f	85 ff		 test	 edi, edi
  00091	75 e9		 jne	 SHORT $LN98@assign@2
  00093	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00096	83 f8 08	 cmp	 eax, 8
  00099	72 10		 jb	 SHORT $LN70@assign@2
  0009b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009e	33 c9		 xor	 ecx, ecx
  000a0	5f		 pop	 edi
  000a1	66 89 08	 mov	 WORD PTR [eax], cx

; 1078 : 			}
; 1079 : 		return (*this);

  000a4	8b c6		 mov	 eax, esi
  000a6	5e		 pop	 esi
  000a7	5b		 pop	 ebx

; 1080 : 		}

  000a8	c2 08 00	 ret	 8

; 1073 : 
; 1074 : 		if (_Grow(_Count))

$LN70@assign@2:
  000ab	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  000ae	33 c9		 xor	 ecx, ecx
  000b0	5f		 pop	 edi
  000b1	66 89 08	 mov	 WORD PTR [eax], cx

; 1078 : 			}
; 1079 : 		return (*this);

  000b4	8b c6		 mov	 eax, esi
  000b6	5e		 pop	 esi
  000b7	5b		 pop	 ebx

; 1080 : 		}

  000b8	c2 08 00	 ret	 8

; 1075 : 			{	// make room and assign new stuff
; 1076 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Ptr, _Count);

$LN76@assign@2:
  000bb	8b c5		 mov	 eax, ebp
$LN77@assign@2:
  000bd	8b 54 24 14	 mov	 edx, DWORD PTR __Ptr$[esp+12]
  000c1	8d 1c 3f	 lea	 ebx, DWORD PTR [edi+edi]
  000c4	53		 push	 ebx
  000c5	52		 push	 edx
  000c6	03 c9		 add	 ecx, ecx
  000c8	51		 push	 ecx
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 _memcpy_s
  000cf	83 c4 10	 add	 esp, 16			; 00000010H

; 1077 : 			_Eos(_Count);

  000d2	83 7e 18 08	 cmp	 DWORD PTR [esi+24], 8
  000d6	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  000d9	72 03		 jb	 SHORT $LN92@assign@2
  000db	8b 6d 00	 mov	 ebp, DWORD PTR [ebp]
$LN92@assign@2:
  000de	33 d2		 xor	 edx, edx
  000e0	66 89 14 2b	 mov	 WORD PTR [ebx+ebp], dx
  000e4	5d		 pop	 ebp
$LN94@assign@2:
  000e5	5f		 pop	 edi

; 1078 : 			}
; 1079 : 		return (*this);

  000e6	8b c6		 mov	 eax, esi
  000e8	5e		 pop	 esi
  000e9	5b		 pop	 ebx

; 1080 : 		}

  000ea	c2 08 00	 ret	 8
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 721  : 		{	// construct by copying _Right

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 722  : 		_Tidy();
; 723  : 		assign(_Right, 0, npos);

  00003	8b 4c 24 08	 mov	 ecx, DWORD PTR __Right$[esp]
  00007	33 c0		 xor	 eax, eax
  00009	6a ff		 push	 -1
  0000b	50		 push	 eax
  0000c	51		 push	 ecx
  0000d	c7 46 18 07 00
	00 00		 mov	 DWORD PTR [esi+24], 7
  00014	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  0001b	8b ce		 mov	 ecx, esi
  0001d	66 89 46 04	 mov	 WORD PTR [esi+4], ax
  00021	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 724  : 		}

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	c2 04 00	 ret	 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; Function compile flags: /Ogtpy
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1083 : 		{	// assign [_Ptr, <null>)

  00000	56		 push	 esi

; 1084 : 		_DEBUG_POINTER(_Ptr);
; 1085 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00001	8b 74 24 08	 mov	 esi, DWORD PTR __Ptr$[esp]
  00005	8b c6		 mov	 eax, esi
  00007	57		 push	 edi
  00008	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
  0000b	eb 03 8d 49 00	 npad	 5
$LL5@assign@3:
  00010	66 8b 10	 mov	 dx, WORD PTR [eax]
  00013	83 c0 02	 add	 eax, 2
  00016	66 85 d2	 test	 dx, dx
  00019	75 f5		 jne	 SHORT $LL5@assign@3
  0001b	2b c7		 sub	 eax, edi
  0001d	d1 f8		 sar	 eax, 1
  0001f	50		 push	 eax
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi

; 1086 : 		}

  00028	c2 04 00	 ret	 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 652  : 		_Tidy();
; 653  : 		assign(_Ptr);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR __Ptr$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	33 c0		 xor	 eax, eax
  00009	c7 46 18 07 00
	00 00		 mov	 DWORD PTR [esi+24], 7
  00010	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00017	66 89 46 04	 mov	 WORD PTR [esi+4], ax
  0001b	8b c2		 mov	 eax, edx
  0001d	57		 push	 edi
  0001e	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
$LL39@basic_stri@2:
  00021	66 8b 08	 mov	 cx, WORD PTR [eax]
  00024	83 c0 02	 add	 eax, 2
  00027	66 85 c9	 test	 cx, cx
  0002a	75 f5		 jne	 SHORT $LL39@basic_stri@2
  0002c	2b c7		 sub	 eax, edi
  0002e	d1 f8		 sar	 eax, 1
  00030	50		 push	 eax
  00031	52		 push	 edx
  00032	8b ce		 mov	 ecx, esi
  00034	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00039	5f		 pop	 edi

; 654  : 		}

  0003a	8b c6		 mov	 eax, esi
  0003c	5e		 pop	 esi
  0003d	c2 04 00	 ret	 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
PUBLIC	??_C@_0BL@JMLKAJFL@PASSWORD_WRONG_CAPSLOCK_ON?$AA@ ; `string'
PUBLIC	??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@		; `string'
PUBLIC	??_C@_0P@MKGPOAFK@PASSWORD_WRONG?$AA@		; `string'
PUBLIC	??_C@_0BK@LAEGKAMJ@PASSWORD_OR_KEYFILE_WRONG?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?GetWrongPasswordErrorMessage@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHWND__@@@Z ; GetWrongPasswordErrorMessage
EXTRN	_CheckCapsLock:PROC
EXTRN	_KeyFilesEnable:DWORD
;	COMDAT ??_C@_0BL@JMLKAJFL@PASSWORD_WRONG_CAPSLOCK_ON?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\iosfwd
CONST	SEGMENT
??_C@_0BL@JMLKAJFL@PASSWORD_WRONG_CAPSLOCK_ON?$AA@ DB 'PASSWORD_WRONG_CAP'
	DB	'SLOCK_ON', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ DB '%', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MKGPOAFK@PASSWORD_WRONG?$AA@
CONST	SEGMENT
??_C@_0P@MKGPOAFK@PASSWORD_WRONG?$AA@ DB 'PASSWORD_WRONG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LAEGKAMJ@PASSWORD_OR_KEYFILE_WRONG?$AA@
CONST	SEGMENT
??_C@_0BK@LAEGKAMJ@PASSWORD_OR_KEYFILE_WRONG?$AA@ DB 'PASSWORD_OR_KEYFILE'
	DB	'_WRONG', 00H				; `string'
; Function compile flags: /Ogtpy
; File c:\home\public\desktop\projects\ciphershed.build\src\common\dialog\errors.cpp
CONST	ENDS
;	COMDAT ?GetWrongPasswordErrorMessage@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHWND__@@@Z
_TEXT	SEGMENT
$T90444 = -16392					; size = 4
_szTmp$ = -16388					; size = 16384
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_hwndDlg$ = 12						; size = 4
?GetWrongPasswordErrorMessage@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHWND__@@@Z PROC ; GetWrongPasswordErrorMessage, COMDAT

; 90   : {

  00000	b8 08 40 00 00	 mov	 eax, 16392		; 00004008H
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000f	33 c4		 xor	 eax, esp
  00011	89 84 24 04 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16392], eax

; 91   : 	WCHAR szTmp[8192];
; 92   : 
; 93   : 	swprintf ((wchar_t*)szTmp, ARRAYSIZE(szTmp), L"%s", GetString (KeyFilesEnable ? "PASSWORD_OR_KEYFILE_WRONG" : "PASSWORD_WRONG"));

  00018	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _KeyFilesEnable, 0
  0001f	53		 push	 ebx
  00020	8b 9c 24 10 40
	00 00		 mov	 ebx, DWORD PTR ___$ReturnUdt$[esp+16392]
  00027	56		 push	 esi
  00028	8b b4 24 18 40
	00 00		 mov	 esi, DWORD PTR _hwndDlg$[esp+16396]
  0002f	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR $T90444[esp+16400], 0
  00037	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BK@LAEGKAMJ@PASSWORD_OR_KEYFILE_WRONG?$AA@
  0003c	75 05		 jne	 SHORT $LN5@GetWrongPa
  0003e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0P@MKGPOAFK@PASSWORD_WRONG?$AA@
$LN5@GetWrongPa:
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 _GetString
  00049	50		 push	 eax
  0004a	8d 44 24 14	 lea	 eax, DWORD PTR _szTmp$[esp+16408]
  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
  00053	50		 push	 eax
  00054	ba 00 20 00 00	 mov	 edx, 8192		; 00002000H
  00059	e8 00 00 00 00	 call	 _swprintf

; 94   : 	if (CheckCapsLock (hwndDlg, TRUE))

  0005e	6a 01		 push	 1
  00060	56		 push	 esi
  00061	e8 00 00 00 00	 call	 _CheckCapsLock
  00066	83 c4 18	 add	 esp, 24			; 00000018H
  00069	85 c0		 test	 eax, eax
  0006b	74 45		 je	 SHORT $LN1@GetWrongPa

; 95   : 		wcscat ((wchar_t*)szTmp, GetString ("PASSWORD_WRONG_CAPSLOCK_ON"));

  0006d	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@JMLKAJFL@PASSWORD_WRONG_CAPSLOCK_ON?$AA@
  00072	e8 00 00 00 00	 call	 _GetString
  00077	83 c4 04	 add	 esp, 4
  0007a	8b d0		 mov	 edx, eax
  0007c	8d 64 24 00	 npad	 4
$LL46@GetWrongPa:
  00080	66 8b 08	 mov	 cx, WORD PTR [eax]
  00083	83 c0 02	 add	 eax, 2
  00086	66 85 c9	 test	 cx, cx
  00089	75 f5		 jne	 SHORT $LL46@GetWrongPa
  0008b	57		 push	 edi
  0008c	8d 7c 24 10	 lea	 edi, DWORD PTR _szTmp$[esp+16404]
  00090	2b c2		 sub	 eax, edx
  00092	83 c7 fe	 add	 edi, -2			; fffffffeH
$LL47@GetWrongPa:
  00095	66 8b 4f 02	 mov	 cx, WORD PTR [edi+2]
  00099	83 c7 02	 add	 edi, 2
  0009c	66 85 c9	 test	 cx, cx
  0009f	75 f4		 jne	 SHORT $LL47@GetWrongPa
  000a1	8b c8		 mov	 ecx, eax
  000a3	c1 e9 02	 shr	 ecx, 2
  000a6	8b f2		 mov	 esi, edx
  000a8	f3 a5		 rep movsd
  000aa	8b c8		 mov	 ecx, eax
  000ac	83 e1 03	 and	 ecx, 3
  000af	f3 a4		 rep movsb
  000b1	5f		 pop	 edi
$LN1@GetWrongPa:

; 96   : 
; 97   : #ifdef TCMOUNT 
; 98   : 	if (TCBootLoaderOnInactiveSysEncDrive ())
; 99   : 	{
; 100  : 		swprintf (szTmp, GetString (KeyFilesEnable ? "PASSWORD_OR_KEYFILE_OR_MODE_WRONG" : "PASSWORD_OR_MODE_WRONG"));
; 101  : 
; 102  : 		if (CheckCapsLock (hwndDlg, TRUE))
; 103  : 			wcscat (szTmp, GetString ("PASSWORD_WRONG_CAPSLOCK_ON"));
; 104  : 
; 105  : 		wcscat (szTmp, GetString ("SYSENC_MOUNT_WITHOUT_PBA_NOTE"));
; 106  : 	}
; 107  : #endif
; 108  : 
; 109  : 	std::wstring msg = (wchar_t*)szTmp;

  000b2	33 c9		 xor	 ecx, ecx
  000b4	8d 44 24 0c	 lea	 eax, DWORD PTR _szTmp$[esp+16400]
  000b8	c7 43 18 07 00
	00 00		 mov	 DWORD PTR [ebx+24], 7
  000bf	c7 43 14 00 00
	00 00		 mov	 DWORD PTR [ebx+20], 0
  000c6	66 89 4b 04	 mov	 WORD PTR [ebx+4], cx
  000ca	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
  000cd	8d 49 00	 npad	 3
$LL48@GetWrongPa:
  000d0	66 8b 08	 mov	 cx, WORD PTR [eax]
  000d3	83 c0 02	 add	 eax, 2
  000d6	66 85 c9	 test	 cx, cx
  000d9	75 f5		 jne	 SHORT $LL48@GetWrongPa
  000db	2b c2		 sub	 eax, edx
  000dd	d1 f8		 sar	 eax, 1
  000df	50		 push	 eax
  000e0	8d 54 24 10	 lea	 edx, DWORD PTR _szTmp$[esp+16404]
  000e4	52		 push	 edx
  000e5	8b cb		 mov	 ecx, ebx
  000e7	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 110  : 
; 111  : #ifdef TCMOUNT
; 112  : 	if (KeyFilesEnable && HiddenFilesPresentInKeyfilePath)
; 113  : 	{
; 114  : 		msg += GetString ("HIDDEN_FILES_PRESENT_IN_KEYFILE_PATH");
; 115  : 		HiddenFilesPresentInKeyfilePath = FALSE;
; 116  : 	}
; 117  : #endif
; 118  : 
; 119  : 	return msg;
; 120  : }

  000ec	8b 8c 24 0c 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16400]
  000f3	5e		 pop	 esi
  000f4	8b c3		 mov	 eax, ebx
  000f6	5b		 pop	 ebx
  000f7	33 cc		 xor	 ecx, esp
  000f9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fe	81 c4 08 40 00
	00		 add	 esp, 16392		; 00004008H
  00104	c3		 ret	 0
?GetWrongPasswordErrorMessage@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHWND__@@@Z ENDP ; GetWrongPasswordErrorMessage
_TEXT	ENDS
PUBLIC	??_C@_0M@FDOCLIJD@ERR_UNKNOWN?$AA@		; `string'
PUBLIC	??_C@_0BI@NIGJHOFH@ERR_PARAMETER_INCORRECT?$AA@	; `string'
PUBLIC	??_C@_0CF@MBJPLKGL@ERR_SYS_HIDVOL_HEAD_REENC_MODE_W@ ; `string'
PUBLIC	??_C@_0CC@BGLNMIMN@ERR_NONSYS_INPLACE_ENC_INCOMPLET@ ; `string'
PUBLIC	??_C@_0BN@JLJPGHCL@ERR_ENCRYPTION_NOT_COMPLETED?$AA@ ; `string'
PUBLIC	??_C@_0BD@GJIBONDI@ERR_VOL_FORMAT_BAD?$AA@	; `string'
PUBLIC	??_C@_0BG@DKEEGIEL@ERR_SELF_TESTS_FAILED?$AA@	; `string'
PUBLIC	??_C@_0BF@LDKGLOCG@NEW_VERSION_REQUIRED?$AA@	; `string'
PUBLIC	??_C@_0P@LICKOHFP@DRIVER_VERSION?$AA@		; `string'
PUBLIC	??_C@_0O@ILOHOCOF@ACCESS_DENIED?$AA@		; `string'
PUBLIC	??_C@_0P@ECPPAAM@NO_FREE_DRIVES?$AA@		; `string'
PUBLIC	??_C@_0BB@JCPIJGNN@VOL_MOUNT_FAILED?$AA@	; `string'
PUBLIC	??_C@_0BB@GLPAMHI@FILE_OPEN_FAILED?$AA@		; `string'
PUBLIC	??_C@_0BE@NEFDJEPG@VOL_ALREADY_MOUNTED?$AA@	; `string'
PUBLIC	??_C@_0BJ@DGGCCNCK@ERR_CIPHER_INIT_WEAK_KEY?$AA@ ; `string'
PUBLIC	??_C@_0BI@BFLHAGLK@ERR_CIPHER_INIT_FAILURE?$AA@	; `string'
PUBLIC	??_C@_0M@KFLNHABP@VOL_SEEKING?$AA@		; `string'
PUBLIC	??_C@_0P@BKLABIJI@WRONG_VOL_TYPE?$AA@		; `string'
PUBLIC	??_C@_0BK@FLKCANLN@COMPRESSION_NOT_SUPPORTED?$AA@ ; `string'
PUBLIC	??_C@_0P@HPMGPOAF@VOL_SIZE_WRONG?$AA@		; `string'
PUBLIC	??_C@_0P@DNONBLBD@OPENFILES_LOCK?$AA@		; `string'
PUBLIC	??_C@_0BB@HBDCANKP@OPENFILES_DRIVER?$AA@	; `string'
PUBLIC	??_C@_09IILMPLJM@NOT_FOUND?$AA@			; `string'
PUBLIC	??_C@_0M@IMAOAGMP@OUTOFMEMORY?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_handleError
;	COMDAT ??_C@_0M@FDOCLIJD@ERR_UNKNOWN?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
CONST	SEGMENT
??_C@_0M@FDOCLIJD@ERR_UNKNOWN?$AA@ DB 'ERR_UNKNOWN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NIGJHOFH@ERR_PARAMETER_INCORRECT?$AA@
CONST	SEGMENT
??_C@_0BI@NIGJHOFH@ERR_PARAMETER_INCORRECT?$AA@ DB 'ERR_PARAMETER_INCORRE'
	DB	'CT', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MBJPLKGL@ERR_SYS_HIDVOL_HEAD_REENC_MODE_W@
CONST	SEGMENT
??_C@_0CF@MBJPLKGL@ERR_SYS_HIDVOL_HEAD_REENC_MODE_W@ DB 'ERR_SYS_HIDVOL_H'
	DB	'EAD_REENC_MODE_WRONG', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@BGLNMIMN@ERR_NONSYS_INPLACE_ENC_INCOMPLET@
CONST	SEGMENT
??_C@_0CC@BGLNMIMN@ERR_NONSYS_INPLACE_ENC_INCOMPLET@ DB 'ERR_NONSYS_INPLA'
	DB	'CE_ENC_INCOMPLETE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JLJPGHCL@ERR_ENCRYPTION_NOT_COMPLETED?$AA@
CONST	SEGMENT
??_C@_0BN@JLJPGHCL@ERR_ENCRYPTION_NOT_COMPLETED?$AA@ DB 'ERR_ENCRYPTION_N'
	DB	'OT_COMPLETED', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GJIBONDI@ERR_VOL_FORMAT_BAD?$AA@
CONST	SEGMENT
??_C@_0BD@GJIBONDI@ERR_VOL_FORMAT_BAD?$AA@ DB 'ERR_VOL_FORMAT_BAD', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DKEEGIEL@ERR_SELF_TESTS_FAILED?$AA@
CONST	SEGMENT
??_C@_0BG@DKEEGIEL@ERR_SELF_TESTS_FAILED?$AA@ DB 'ERR_SELF_TESTS_FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LDKGLOCG@NEW_VERSION_REQUIRED?$AA@
CONST	SEGMENT
??_C@_0BF@LDKGLOCG@NEW_VERSION_REQUIRED?$AA@ DB 'NEW_VERSION_REQUIRED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LICKOHFP@DRIVER_VERSION?$AA@
CONST	SEGMENT
??_C@_0P@LICKOHFP@DRIVER_VERSION?$AA@ DB 'DRIVER_VERSION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ILOHOCOF@ACCESS_DENIED?$AA@
CONST	SEGMENT
??_C@_0O@ILOHOCOF@ACCESS_DENIED?$AA@ DB 'ACCESS_DENIED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ECPPAAM@NO_FREE_DRIVES?$AA@
CONST	SEGMENT
??_C@_0P@ECPPAAM@NO_FREE_DRIVES?$AA@ DB 'NO_FREE_DRIVES', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JCPIJGNN@VOL_MOUNT_FAILED?$AA@
CONST	SEGMENT
??_C@_0BB@JCPIJGNN@VOL_MOUNT_FAILED?$AA@ DB 'VOL_MOUNT_FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GLPAMHI@FILE_OPEN_FAILED?$AA@
CONST	SEGMENT
??_C@_0BB@GLPAMHI@FILE_OPEN_FAILED?$AA@ DB 'FILE_OPEN_FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NEFDJEPG@VOL_ALREADY_MOUNTED?$AA@
CONST	SEGMENT
??_C@_0BE@NEFDJEPG@VOL_ALREADY_MOUNTED?$AA@ DB 'VOL_ALREADY_MOUNTED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DGGCCNCK@ERR_CIPHER_INIT_WEAK_KEY?$AA@
CONST	SEGMENT
??_C@_0BJ@DGGCCNCK@ERR_CIPHER_INIT_WEAK_KEY?$AA@ DB 'ERR_CIPHER_INIT_WEAK'
	DB	'_KEY', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BFLHAGLK@ERR_CIPHER_INIT_FAILURE?$AA@
CONST	SEGMENT
??_C@_0BI@BFLHAGLK@ERR_CIPHER_INIT_FAILURE?$AA@ DB 'ERR_CIPHER_INIT_FAILU'
	DB	'RE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KFLNHABP@VOL_SEEKING?$AA@
CONST	SEGMENT
??_C@_0M@KFLNHABP@VOL_SEEKING?$AA@ DB 'VOL_SEEKING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BKLABIJI@WRONG_VOL_TYPE?$AA@
CONST	SEGMENT
??_C@_0P@BKLABIJI@WRONG_VOL_TYPE?$AA@ DB 'WRONG_VOL_TYPE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FLKCANLN@COMPRESSION_NOT_SUPPORTED?$AA@
CONST	SEGMENT
??_C@_0BK@FLKCANLN@COMPRESSION_NOT_SUPPORTED?$AA@ DB 'COMPRESSION_NOT_SUP'
	DB	'PORTED', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HPMGPOAF@VOL_SIZE_WRONG?$AA@
CONST	SEGMENT
??_C@_0P@HPMGPOAF@VOL_SIZE_WRONG?$AA@ DB 'VOL_SIZE_WRONG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DNONBLBD@OPENFILES_LOCK?$AA@
CONST	SEGMENT
??_C@_0P@DNONBLBD@OPENFILES_LOCK?$AA@ DB 'OPENFILES_LOCK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HBDCANKP@OPENFILES_DRIVER?$AA@
CONST	SEGMENT
??_C@_0BB@HBDCANKP@OPENFILES_DRIVER?$AA@ DB 'OPENFILES_DRIVER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09IILMPLJM@NOT_FOUND?$AA@
CONST	SEGMENT
??_C@_09IILMPLJM@NOT_FOUND?$AA@ DB 'NOT_FOUND', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IMAOAGMP@OUTOFMEMORY?$AA@
CONST	SEGMENT
??_C@_0M@IMAOAGMP@OUTOFMEMORY?$AA@ DB 'OUTOFMEMORY', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\home\public\desktop\projects\ciphershed.build\src\common\dialog\errors.cpp
CONST	ENDS
;	COMDAT _handleError
_TEXT	SEGMENT
$T90610 = -8224						; size = 28
_szTmp$ = -8196						; size = 8192
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_code$ = 12						; size = 4
_handleError PROC					; COMDAT

; 123  : {

  00000	b8 20 20 00 00	 mov	 eax, 8224		; 00002020H
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000f	33 c4		 xor	 eax, esp
  00011	89 84 24 1c 20
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+8224], eax

; 124  : 	WCHAR szTmp[4096];
; 125  : 
; 126  : 	if (Silent) return;

  00018	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Silent, 0
  0001f	56		 push	 esi
  00020	8b b4 24 28 20
	00 00		 mov	 esi, DWORD PTR _hwndDlg$[esp+8224]
  00027	0f 85 6a 03 00
	00		 jne	 $LN28@handleErro

; 127  : 
; 128  : 	switch (code)

  0002d	8b 8c 24 2c 20
	00 00		 mov	 ecx, DWORD PTR _code$[esp+8224]
  00034	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00037	83 f8 20	 cmp	 eax, 32			; 00000020H
  0003a	0f 87 21 03 00
	00		 ja	 $LN1@handleErro
  00040	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN40@handleErro[eax*4]
$LN27@handleErro:

; 129  : 	{
; 130  : 	case ERR_OS_ERROR:
; 131  : 		handleWin32Error (hwndDlg);

  00047	56		 push	 esi
  00048	e8 00 00 00 00	 call	 _handleWin32Error
  0004d	83 c4 04	 add	 esp, 4
  00050	5e		 pop	 esi

; 224  : 	}
; 225  : }

  00051	8b 8c 24 1c 20
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+8224]
  00058	33 cc		 xor	 ecx, esp
  0005a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005f	81 c4 20 20 00
	00		 add	 esp, 8224		; 00002020H
  00065	c3		 ret	 0
$LN26@handleErro:

; 132  : 		break;
; 133  : 	case ERR_OUTOFMEMORY:
; 134  : 		MessageBoxW (hwndDlg, (LPCWSTR)GetString ("OUTOFMEMORY"), (LPCWSTR)lpszTitle, ICON_HAND);

  00066	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  0006b	6a 10		 push	 16			; 00000010H
  0006d	50		 push	 eax
  0006e	68 00 00 00 00	 push	 OFFSET ??_C@_0M@IMAOAGMP@OUTOFMEMORY?$AA@
  00073	e8 00 00 00 00	 call	 _GetString
  00078	83 c4 04	 add	 esp, 4
  0007b	50		 push	 eax

; 135  : 		break;

  0007c	e9 0f 03 00 00	 jmp	 $LN39@handleErro
$LN25@handleErro:

; 136  : 
; 137  : 	case ERR_PASSWORD_WRONG:
; 138  : 		MessageBoxW (hwndDlg, (LPCWSTR)GetWrongPasswordErrorMessage (hwndDlg).c_str(), (LPCWSTR)lpszTitle, MB_ICONWARNING);

  00081	8d 4c 24 04	 lea	 ecx, DWORD PTR $T90610[esp+8228]
  00085	56		 push	 esi
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ?GetWrongPasswordErrorMessage@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHWND__@@@Z ; GetWrongPasswordErrorMessage
  0008c	83 c4 08	 add	 esp, 8
  0008f	83 78 18 08	 cmp	 DWORD PTR [eax+24], 8
  00093	72 05		 jb	 SHORT $LN37@handleErro
  00095	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00098	eb 03		 jmp	 SHORT $LN38@handleErro
$LN37@handleErro:
  0009a	83 c0 04	 add	 eax, 4
$LN38@handleErro:
  0009d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lpszTitle
  000a3	6a 30		 push	 48			; 00000030H
  000a5	52		 push	 edx
  000a6	50		 push	 eax
  000a7	56		 push	 esi
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
  000ae	8d 4c 24 04	 lea	 ecx, DWORD PTR $T90610[esp+8228]
  000b2	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  000b7	5e		 pop	 esi

; 224  : 	}
; 225  : }

  000b8	8b 8c 24 1c 20
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+8224]
  000bf	33 cc		 xor	 ecx, esp
  000c1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c6	81 c4 20 20 00
	00		 add	 esp, 8224		; 00002020H
  000cc	c3		 ret	 0
$LN24@handleErro:

; 139  : 		break;
; 140  : 
; 141  : 	case ERR_DRIVE_NOT_FOUND:
; 142  : 		MessageBoxW (hwndDlg, (LPCWSTR)GetString ("NOT_FOUND"), (LPCWSTR)lpszTitle, ICON_HAND);

  000cd	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  000d2	6a 10		 push	 16			; 00000010H
  000d4	50		 push	 eax
  000d5	68 00 00 00 00	 push	 OFFSET ??_C@_09IILMPLJM@NOT_FOUND?$AA@
  000da	e8 00 00 00 00	 call	 _GetString
  000df	83 c4 04	 add	 esp, 4
  000e2	50		 push	 eax

; 143  : 		break;

  000e3	e9 a8 02 00 00	 jmp	 $LN39@handleErro
$LN23@handleErro:

; 144  : 	case ERR_FILES_OPEN:
; 145  : 		MessageBoxW (hwndDlg, (LPCWSTR)GetString ("OPENFILES_DRIVER"), (LPCWSTR)lpszTitle, ICON_HAND);

  000e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpszTitle
  000ee	6a 10		 push	 16			; 00000010H
  000f0	51		 push	 ecx
  000f1	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@HBDCANKP@OPENFILES_DRIVER?$AA@
  000f6	e8 00 00 00 00	 call	 _GetString
  000fb	83 c4 04	 add	 esp, 4
  000fe	50		 push	 eax

; 146  : 		break;

  000ff	e9 8c 02 00 00	 jmp	 $LN39@handleErro
$LN22@handleErro:

; 147  : 	case ERR_FILES_OPEN_LOCK:
; 148  : 		MessageBoxW (hwndDlg, (LPCWSTR)GetString ("OPENFILES_LOCK"), (LPCWSTR)lpszTitle, ICON_HAND);

  00104	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lpszTitle
  0010a	6a 10		 push	 16			; 00000010H
  0010c	52		 push	 edx
  0010d	68 00 00 00 00	 push	 OFFSET ??_C@_0P@DNONBLBD@OPENFILES_LOCK?$AA@
  00112	e8 00 00 00 00	 call	 _GetString
  00117	83 c4 04	 add	 esp, 4
  0011a	50		 push	 eax

; 149  : 		break;

  0011b	e9 70 02 00 00	 jmp	 $LN39@handleErro
$LN21@handleErro:

; 150  : 	case ERR_VOL_SIZE_WRONG:
; 151  : 		MessageBoxW (hwndDlg, (LPCWSTR)GetString ("VOL_SIZE_WRONG"), (LPCWSTR)lpszTitle, ICON_HAND);

  00120	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  00125	6a 10		 push	 16			; 00000010H
  00127	50		 push	 eax
  00128	68 00 00 00 00	 push	 OFFSET ??_C@_0P@HPMGPOAF@VOL_SIZE_WRONG?$AA@
  0012d	e8 00 00 00 00	 call	 _GetString
  00132	83 c4 04	 add	 esp, 4
  00135	50		 push	 eax

; 152  : 		break;

  00136	e9 55 02 00 00	 jmp	 $LN39@handleErro
$LN20@handleErro:

; 153  : 	case ERR_COMPRESSION_NOT_SUPPORTED:
; 154  : 		MessageBoxW (hwndDlg, (LPCWSTR)GetString ("COMPRESSION_NOT_SUPPORTED"), (LPCWSTR)lpszTitle, ICON_HAND);

  0013b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpszTitle
  00141	6a 10		 push	 16			; 00000010H
  00143	51		 push	 ecx
  00144	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@FLKCANLN@COMPRESSION_NOT_SUPPORTED?$AA@
  00149	e8 00 00 00 00	 call	 _GetString
  0014e	83 c4 04	 add	 esp, 4
  00151	50		 push	 eax

; 155  : 		break;

  00152	e9 39 02 00 00	 jmp	 $LN39@handleErro
$LN19@handleErro:

; 156  : 	case ERR_PASSWORD_CHANGE_VOL_TYPE:
; 157  : 		MessageBoxW (hwndDlg, (LPCWSTR)GetString ("WRONG_VOL_TYPE"), (LPCWSTR)lpszTitle, ICON_HAND);

  00157	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lpszTitle
  0015d	6a 10		 push	 16			; 00000010H
  0015f	52		 push	 edx
  00160	68 00 00 00 00	 push	 OFFSET ??_C@_0P@BKLABIJI@WRONG_VOL_TYPE?$AA@
  00165	e8 00 00 00 00	 call	 _GetString
  0016a	83 c4 04	 add	 esp, 4
  0016d	50		 push	 eax

; 158  : 		break;

  0016e	e9 1d 02 00 00	 jmp	 $LN39@handleErro
$LN18@handleErro:

; 159  : 	case ERR_VOL_SEEKING:
; 160  : 		MessageBoxW (hwndDlg, (LPCWSTR)GetString ("VOL_SEEKING"), (LPCWSTR)lpszTitle, ICON_HAND);

  00173	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  00178	6a 10		 push	 16			; 00000010H
  0017a	50		 push	 eax
  0017b	68 00 00 00 00	 push	 OFFSET ??_C@_0M@KFLNHABP@VOL_SEEKING?$AA@
  00180	e8 00 00 00 00	 call	 _GetString
  00185	83 c4 04	 add	 esp, 4
  00188	50		 push	 eax

; 161  : 		break;

  00189	e9 02 02 00 00	 jmp	 $LN39@handleErro
$LN17@handleErro:

; 162  : 	case ERR_CIPHER_INIT_FAILURE:
; 163  : 		MessageBoxW (hwndDlg, (LPCWSTR)GetString ("ERR_CIPHER_INIT_FAILURE"), (LPCWSTR)lpszTitle, ICON_HAND);

  0018e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpszTitle
  00194	6a 10		 push	 16			; 00000010H
  00196	51		 push	 ecx
  00197	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@BFLHAGLK@ERR_CIPHER_INIT_FAILURE?$AA@
  0019c	e8 00 00 00 00	 call	 _GetString
  001a1	83 c4 04	 add	 esp, 4
  001a4	50		 push	 eax

; 164  : 		break;

  001a5	e9 e6 01 00 00	 jmp	 $LN39@handleErro
$LN16@handleErro:

; 165  : 	case ERR_CIPHER_INIT_WEAK_KEY:
; 166  : 		MessageBoxW (hwndDlg, (LPCWSTR)GetString ("ERR_CIPHER_INIT_WEAK_KEY"), (LPCWSTR)lpszTitle, ICON_HAND);

  001aa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lpszTitle
  001b0	6a 10		 push	 16			; 00000010H
  001b2	52		 push	 edx
  001b3	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DGGCCNCK@ERR_CIPHER_INIT_WEAK_KEY?$AA@
  001b8	e8 00 00 00 00	 call	 _GetString
  001bd	83 c4 04	 add	 esp, 4
  001c0	50		 push	 eax

; 167  : 		break;

  001c1	e9 ca 01 00 00	 jmp	 $LN39@handleErro
$LN15@handleErro:

; 168  : 	case ERR_VOL_ALREADY_MOUNTED:
; 169  : 		MessageBoxW (hwndDlg, (LPCWSTR)GetString ("VOL_ALREADY_MOUNTED"), (LPCWSTR)lpszTitle, ICON_HAND);

  001c6	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  001cb	6a 10		 push	 16			; 00000010H
  001cd	50		 push	 eax
  001ce	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@NEFDJEPG@VOL_ALREADY_MOUNTED?$AA@
  001d3	e8 00 00 00 00	 call	 _GetString
  001d8	83 c4 04	 add	 esp, 4
  001db	50		 push	 eax

; 170  : 		break;

  001dc	e9 af 01 00 00	 jmp	 $LN39@handleErro
$LN14@handleErro:

; 171  : 	case ERR_FILE_OPEN_FAILED:
; 172  : 		MessageBoxW (hwndDlg, (LPCWSTR)GetString ("FILE_OPEN_FAILED"), (LPCWSTR)lpszTitle, ICON_HAND);

  001e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpszTitle
  001e7	6a 10		 push	 16			; 00000010H
  001e9	51		 push	 ecx
  001ea	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@GLPAMHI@FILE_OPEN_FAILED?$AA@
  001ef	e8 00 00 00 00	 call	 _GetString
  001f4	83 c4 04	 add	 esp, 4
  001f7	50		 push	 eax

; 173  : 		break;

  001f8	e9 93 01 00 00	 jmp	 $LN39@handleErro
$LN13@handleErro:

; 174  : 	case ERR_VOL_MOUNT_FAILED:
; 175  : 		MessageBoxW (hwndDlg, (LPCWSTR)GetString  ("VOL_MOUNT_FAILED"), (LPCWSTR)lpszTitle, ICON_HAND);

  001fd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lpszTitle
  00203	6a 10		 push	 16			; 00000010H
  00205	52		 push	 edx
  00206	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@JCPIJGNN@VOL_MOUNT_FAILED?$AA@
  0020b	e8 00 00 00 00	 call	 _GetString
  00210	83 c4 04	 add	 esp, 4
  00213	50		 push	 eax

; 176  : 		break;

  00214	e9 77 01 00 00	 jmp	 $LN39@handleErro
$LN12@handleErro:

; 177  : 	case ERR_NO_FREE_DRIVES:
; 178  : 		MessageBoxW (hwndDlg, (LPCWSTR)GetString ("NO_FREE_DRIVES"), (LPCWSTR)lpszTitle, ICON_HAND);

  00219	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  0021e	6a 10		 push	 16			; 00000010H
  00220	50		 push	 eax
  00221	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ECPPAAM@NO_FREE_DRIVES?$AA@
  00226	e8 00 00 00 00	 call	 _GetString
  0022b	83 c4 04	 add	 esp, 4
  0022e	50		 push	 eax

; 179  : 		break;

  0022f	e9 5c 01 00 00	 jmp	 $LN39@handleErro
$LN11@handleErro:

; 180  : 	case ERR_ACCESS_DENIED:
; 181  : 		MessageBoxW (hwndDlg, (LPCWSTR)GetString ("ACCESS_DENIED"), (LPCWSTR)lpszTitle, ICON_HAND);

  00234	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpszTitle
  0023a	6a 10		 push	 16			; 00000010H
  0023c	51		 push	 ecx
  0023d	68 00 00 00 00	 push	 OFFSET ??_C@_0O@ILOHOCOF@ACCESS_DENIED?$AA@
  00242	e8 00 00 00 00	 call	 _GetString
  00247	83 c4 04	 add	 esp, 4
  0024a	50		 push	 eax

; 182  : 		break;

  0024b	e9 40 01 00 00	 jmp	 $LN39@handleErro
$LN10@handleErro:

; 183  : 
; 184  : 	case ERR_DRIVER_VERSION:
; 185  : 		Error ("DRIVER_VERSION");

  00250	68 00 00 00 00	 push	 OFFSET ??_C@_0P@LICKOHFP@DRIVER_VERSION?$AA@
  00255	e8 00 00 00 00	 call	 _Error
  0025a	83 c4 04	 add	 esp, 4
  0025d	5e		 pop	 esi

; 224  : 	}
; 225  : }

  0025e	8b 8c 24 1c 20
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+8224]
  00265	33 cc		 xor	 ecx, esp
  00267	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0026c	81 c4 20 20 00
	00		 add	 esp, 8224		; 00002020H
  00272	c3		 ret	 0
$LN9@handleErro:

; 186  : 		break;
; 187  : 
; 188  : 	case ERR_NEW_VERSION_REQUIRED:
; 189  : 		MessageBoxW (hwndDlg, (LPCWSTR)GetString ("NEW_VERSION_REQUIRED"), (LPCWSTR)lpszTitle, ICON_HAND);

  00273	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lpszTitle
  00279	6a 10		 push	 16			; 00000010H
  0027b	52		 push	 edx
  0027c	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@LDKGLOCG@NEW_VERSION_REQUIRED?$AA@
  00281	e8 00 00 00 00	 call	 _GetString
  00286	83 c4 04	 add	 esp, 4
  00289	50		 push	 eax

; 190  : 		break;

  0028a	e9 01 01 00 00	 jmp	 $LN39@handleErro
$LN8@handleErro:

; 191  : 
; 192  : 	case ERR_SELF_TESTS_FAILED:
; 193  : 		Error ("ERR_SELF_TESTS_FAILED");

  0028f	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@DKEEGIEL@ERR_SELF_TESTS_FAILED?$AA@
  00294	e8 00 00 00 00	 call	 _Error
  00299	83 c4 04	 add	 esp, 4
  0029c	5e		 pop	 esi

; 224  : 	}
; 225  : }

  0029d	8b 8c 24 1c 20
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+8224]
  002a4	33 cc		 xor	 ecx, esp
  002a6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002ab	81 c4 20 20 00
	00		 add	 esp, 8224		; 00002020H
  002b1	c3		 ret	 0
$LN7@handleErro:

; 194  : 		break;
; 195  : 
; 196  : 	case ERR_VOL_FORMAT_BAD:
; 197  : 		Error ("ERR_VOL_FORMAT_BAD");

  002b2	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@GJIBONDI@ERR_VOL_FORMAT_BAD?$AA@
  002b7	e8 00 00 00 00	 call	 _Error
  002bc	83 c4 04	 add	 esp, 4
  002bf	5e		 pop	 esi

; 224  : 	}
; 225  : }

  002c0	8b 8c 24 1c 20
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+8224]
  002c7	33 cc		 xor	 ecx, esp
  002c9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002ce	81 c4 20 20 00
	00		 add	 esp, 8224		; 00002020H
  002d4	c3		 ret	 0
$LN6@handleErro:

; 198  : 		break;
; 199  : 
; 200  : 	case ERR_ENCRYPTION_NOT_COMPLETED:
; 201  : 		Error ("ERR_ENCRYPTION_NOT_COMPLETED");

  002d5	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JLJPGHCL@ERR_ENCRYPTION_NOT_COMPLETED?$AA@
  002da	e8 00 00 00 00	 call	 _Error
  002df	83 c4 04	 add	 esp, 4
  002e2	5e		 pop	 esi

; 224  : 	}
; 225  : }

  002e3	8b 8c 24 1c 20
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+8224]
  002ea	33 cc		 xor	 ecx, esp
  002ec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002f1	81 c4 20 20 00
	00		 add	 esp, 8224		; 00002020H
  002f7	c3		 ret	 0
$LN5@handleErro:

; 202  : 		break;
; 203  : 
; 204  : 	case ERR_NONSYS_INPLACE_ENC_INCOMPLETE:
; 205  : 		Error ("ERR_NONSYS_INPLACE_ENC_INCOMPLETE");

  002f8	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@BGLNMIMN@ERR_NONSYS_INPLACE_ENC_INCOMPLET@
  002fd	e8 00 00 00 00	 call	 _Error
  00302	83 c4 04	 add	 esp, 4
  00305	5e		 pop	 esi

; 224  : 	}
; 225  : }

  00306	8b 8c 24 1c 20
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+8224]
  0030d	33 cc		 xor	 ecx, esp
  0030f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00314	81 c4 20 20 00
	00		 add	 esp, 8224		; 00002020H
  0031a	c3		 ret	 0
$LN4@handleErro:

; 206  : 		break;
; 207  : 
; 208  : 	case ERR_SYS_HIDVOL_HEAD_REENC_MODE_WRONG:
; 209  : 		Error ("ERR_SYS_HIDVOL_HEAD_REENC_MODE_WRONG");

  0031b	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@MBJPLKGL@ERR_SYS_HIDVOL_HEAD_REENC_MODE_W@
  00320	e8 00 00 00 00	 call	 _Error
  00325	83 c4 04	 add	 esp, 4
  00328	5e		 pop	 esi

; 224  : 	}
; 225  : }

  00329	8b 8c 24 1c 20
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+8224]
  00330	33 cc		 xor	 ecx, esp
  00332	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00337	81 c4 20 20 00
	00		 add	 esp, 8224		; 00002020H
  0033d	c3		 ret	 0
$LN3@handleErro:

; 210  : 		break;
; 211  : 
; 212  : 	case ERR_PARAMETER_INCORRECT:
; 213  : 		Error ("ERR_PARAMETER_INCORRECT");

  0033e	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@NIGJHOFH@ERR_PARAMETER_INCORRECT?$AA@
  00343	e8 00 00 00 00	 call	 _Error
  00348	83 c4 04	 add	 esp, 4
  0034b	5e		 pop	 esi

; 224  : 	}
; 225  : }

  0034c	8b 8c 24 1c 20
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+8224]
  00353	33 cc		 xor	 ecx, esp
  00355	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0035a	81 c4 20 20 00
	00		 add	 esp, 8224		; 00002020H
  00360	c3		 ret	 0
$LN1@handleErro:

; 214  : 		break;
; 215  : 
; 216  : 	case ERR_USER_ABORT:
; 217  : 	case ERR_DONT_REPORT:
; 218  : 		// A non-error
; 219  : 		break;
; 220  : 
; 221  : 	default:
; 222  : 		swprintf ((wchar_t*)szTmp, ARRAYSIZE(szTmp), GetString ("ERR_UNKNOWN"), code);

  00361	51		 push	 ecx
  00362	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FDOCLIJD@ERR_UNKNOWN?$AA@
  00367	e8 00 00 00 00	 call	 _GetString
  0036c	83 c4 04	 add	 esp, 4
  0036f	50		 push	 eax
  00370	8d 44 24 28	 lea	 eax, DWORD PTR _szTmp$[esp+8236]
  00374	50		 push	 eax
  00375	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  0037a	e8 00 00 00 00	 call	 _swprintf

; 223  : 		MessageBoxW (hwndDlg, (LPCWSTR)szTmp, (LPCWSTR)lpszTitle, ICON_HAND);

  0037f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpszTitle
  00385	83 c4 0c	 add	 esp, 12			; 0000000cH
  00388	6a 10		 push	 16			; 00000010H
  0038a	51		 push	 ecx
  0038b	8d 54 24 28	 lea	 edx, DWORD PTR _szTmp$[esp+8236]
  0038f	52		 push	 edx
$LN39@handleErro:
  00390	56		 push	 esi
  00391	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
$LN28@handleErro:

; 224  : 	}
; 225  : }

  00397	8b 8c 24 20 20
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+8228]
  0039e	5e		 pop	 esi
  0039f	33 cc		 xor	 ecx, esp
  003a1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003a6	81 c4 20 20 00
	00		 add	 esp, 8224		; 00002020H
  003ac	c3		 ret	 0
  003ad	8d 49 00	 npad	 3
$LN40@handleErro:
  003b0	00 00 00 00	 DD	 $LN27@handleErro
  003b4	00 00 00 00	 DD	 $LN26@handleErro
  003b8	00 00 00 00	 DD	 $LN25@handleErro
  003bc	00 00 00 00	 DD	 $LN7@handleErro
  003c0	00 00 00 00	 DD	 $LN24@handleErro
  003c4	00 00 00 00	 DD	 $LN23@handleErro
  003c8	00 00 00 00	 DD	 $LN21@handleErro
  003cc	00 00 00 00	 DD	 $LN20@handleErro
  003d0	00 00 00 00	 DD	 $LN19@handleErro
  003d4	00 00 00 00	 DD	 $LN1@handleErro
  003d8	00 00 00 00	 DD	 $LN18@handleErro
  003dc	00 00 00 00	 DD	 $LN1@handleErro
  003e0	00 00 00 00	 DD	 $LN22@handleErro
  003e4	00 00 00 00	 DD	 $LN1@handleErro
  003e8	00 00 00 00	 DD	 $LN10@handleErro
  003ec	00 00 00 00	 DD	 $LN9@handleErro
  003f0	00 00 00 00	 DD	 $LN17@handleErro
  003f4	00 00 00 00	 DD	 $LN16@handleErro
  003f8	00 00 00 00	 DD	 $LN8@handleErro
  003fc	00 00 00 00	 DD	 $LN1@handleErro
  00400	00 00 00 00	 DD	 $LN15@handleErro
  00404	00 00 00 00	 DD	 $LN12@handleErro
  00408	00 00 00 00	 DD	 $LN14@handleErro
  0040c	00 00 00 00	 DD	 $LN13@handleErro
  00410	00 00 00 00	 DD	 $LN1@handleErro
  00414	00 00 00 00	 DD	 $LN11@handleErro
  00418	00 00 00 00	 DD	 $LN1@handleErro
  0041c	00 00 00 00	 DD	 $LN28@handleErro
  00420	00 00 00 00	 DD	 $LN6@handleErro
  00424	00 00 00 00	 DD	 $LN3@handleErro
  00428	00 00 00 00	 DD	 $LN4@handleErro
  0042c	00 00 00 00	 DD	 $LN5@handleErro
  00430	00 00 00 00	 DD	 $LN28@handleErro
_handleError ENDP
_TEXT	ENDS
END
