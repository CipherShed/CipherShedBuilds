; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\home\public\desktop\projects\ciphershed.build\src\driver\volumefilter.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_HiddenSysLeakProtectionCount
_BSS	SEGMENT
_HiddenSysLeakProtectionCount DD 01H DUP (?)
_BSS	ENDS
PUBLIC	??_C@_0BO@INEJHKOL@VolumeFilterAddDevice?5pdo?$DN?$CFp?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_VolumeFilterAddDevice@8
EXTRN	__imp__IoDeleteDevice@4:PROC
EXTRN	__imp__IoDetachDevice@4:PROC
EXTRN	__imp__IoInitializeRemoveLockEx@20:PROC
EXTRN	__imp__IoAttachDeviceToDeviceStack@8:PROC
EXTRN	__imp_@ObfDereferenceObject@4:PROC
EXTRN	__imp__IoCreateDevice@28:PROC
EXTRN	__imp__IoGetAttachedDeviceReference@4:PROC
EXTRN	_DbgPrint:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_0BO@INEJHKOL@VolumeFilterAddDevice?5pdo?$DN?$CFp?6?$AA@FNODOBFM@
; File c:\home\public\desktop\projects\ciphershed.build\src\driver\volumefilter.c
text$s	SEGMENT
??_C@_0BO@INEJHKOL@VolumeFilterAddDevice?5pdo?$DN?$CFp?6?$AA@FNODOBFM@ DB 'V'
	DB	'olumeFilterAddDevice pdo=%p', 0aH, 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _VolumeFilterAddDevice@8
_TEXT	SEGMENT
_filterDeviceObject$ = -16				; size = 4
_status$ = -12						; size = 4
_attachedDeviceObject$ = -8				; size = 4
_Extension$ = -4					; size = 4
_driverObject$ = 8					; size = 4
_pdo$ = 12						; size = 4
_VolumeFilterAddDevice@8 PROC				; COMDAT

; 23   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 10	 sub	 esp, 16			; 00000010H

; 24   : 	VolumeFilterExtension *Extension;
; 25   : 	NTSTATUS status;
; 26   : 	PDEVICE_OBJECT filterDeviceObject = NULL;

  00008	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _filterDeviceObject$[ebp], 0

; 27   : 	PDEVICE_OBJECT attachedDeviceObject;
; 28   : 
; 29   : 	Dump ("VolumeFilterAddDevice pdo=%p\n", pdo);

  0000f	8b 45 0c	 mov	 eax, DWORD PTR _pdo$[ebp]
  00012	50		 push	 eax
  00013	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@INEJHKOL@VolumeFilterAddDevice?5pdo?$DN?$CFp?6?$AA@FNODOBFM@
  00018	e8 00 00 00 00	 call	 _DbgPrint
  0001d	83 c4 08	 add	 esp, 8

; 30   : 
; 31   : 	attachedDeviceObject = IoGetAttachedDeviceReference (pdo);

  00020	8b 4d 0c	 mov	 ecx, DWORD PTR _pdo$[ebp]
  00023	51		 push	 ecx
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoGetAttachedDeviceReference@4
  0002a	89 45 f8	 mov	 DWORD PTR _attachedDeviceObject$[ebp], eax

; 32   : 	status = IoCreateDevice (driverObject, sizeof (VolumeFilterExtension), NULL, attachedDeviceObject->DeviceType, 0, FALSE, &filterDeviceObject);

  0002d	8d 55 f0	 lea	 edx, DWORD PTR _filterDeviceObject$[ebp]
  00030	52		 push	 edx
  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8b 45 f8	 mov	 eax, DWORD PTR _attachedDeviceObject$[ebp]
  00038	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0003b	51		 push	 ecx
  0003c	6a 00		 push	 0
  0003e	68 50 02 00 00	 push	 592			; 00000250H
  00043	8b 55 08	 mov	 edx, DWORD PTR _driverObject$[ebp]
  00046	52		 push	 edx
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoCreateDevice@28
  0004d	89 45 f4	 mov	 DWORD PTR _status$[ebp], eax

; 33   : 
; 34   : 	ObDereferenceObject (attachedDeviceObject);

  00050	8b 4d f8	 mov	 ecx, DWORD PTR _attachedDeviceObject$[ebp]
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 35   : 
; 36   : 	if (!NT_SUCCESS (status))

  00059	83 7d f4 00	 cmp	 DWORD PTR _status$[ebp], 0
  0005d	7d 0c		 jge	 SHORT $LN4@VolumeFilt

; 37   : 	{
; 38   : 		filterDeviceObject = NULL;

  0005f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _filterDeviceObject$[ebp], 0

; 39   : 		goto err;

  00066	e9 a9 00 00 00	 jmp	 $err$27755
$LN4@VolumeFilt:

; 40   : 	}
; 41   : 
; 42   : 	Extension = (VolumeFilterExtension *) filterDeviceObject->DeviceExtension;

  0006b	8b 45 f0	 mov	 eax, DWORD PTR _filterDeviceObject$[ebp]
  0006e	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00071	89 4d fc	 mov	 DWORD PTR _Extension$[ebp], ecx

; 43   : 	memset (Extension, 0, sizeof (VolumeFilterExtension));

  00074	68 50 02 00 00	 push	 592			; 00000250H
  00079	6a 00		 push	 0
  0007b	8b 55 fc	 mov	 edx, DWORD PTR _Extension$[ebp]
  0007e	52		 push	 edx
  0007f	e8 00 00 00 00	 call	 _memset
  00084	83 c4 0c	 add	 esp, 12			; 0000000cH

; 44   : 
; 45   : 	Extension->LowerDeviceObject = IoAttachDeviceToDeviceStack (filterDeviceObject, pdo);  // IoAttachDeviceToDeviceStackSafe() is not required in AddDevice routine and is also unavailable on Windows 2000 SP4

  00087	8b 45 0c	 mov	 eax, DWORD PTR _pdo$[ebp]
  0008a	50		 push	 eax
  0008b	8b 4d f0	 mov	 ecx, DWORD PTR _filterDeviceObject$[ebp]
  0008e	51		 push	 ecx
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAttachDeviceToDeviceStack@8
  00095	8b 55 fc	 mov	 edx, DWORD PTR _Extension$[ebp]
  00098	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 46   : 	if (!Extension->LowerDeviceObject)

  0009b	8b 45 fc	 mov	 eax, DWORD PTR _Extension$[ebp]
  0009e	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  000a2	75 09		 jne	 SHORT $LN3@VolumeFilt

; 47   : 	{
; 48   : 		status = STATUS_DEVICE_REMOVED;

  000a4	c7 45 f4 b6 02
	00 c0		 mov	 DWORD PTR _status$[ebp], -1073741130 ; c00002b6H

; 49   : 		goto err;

  000ab	eb 67		 jmp	 SHORT $err$27755
$LN3@VolumeFilt:

; 50   : 	}
; 51   : 	
; 52   : 	Extension->IsVolumeFilterDevice = TRUE;

  000ad	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  000b0	c7 41 0c 01 00
	00 00		 mov	 DWORD PTR [ecx+12], 1

; 53   : 	Extension->DeviceObject = filterDeviceObject;

  000b7	8b 55 fc	 mov	 edx, DWORD PTR _Extension$[ebp]
  000ba	8b 45 f0	 mov	 eax, DWORD PTR _filterDeviceObject$[ebp]
  000bd	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 54   : 	Extension->Pdo = pdo;

  000c0	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  000c3	8b 55 0c	 mov	 edx, DWORD PTR _pdo$[ebp]
  000c6	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 55   : 
; 56   : 	IoInitializeRemoveLock (&Extension->Queue.RemoveLock, 'LRCT', 0, 0);

  000c9	6a 58		 push	 88			; 00000058H
  000cb	6a 00		 push	 0
  000cd	6a 00		 push	 0
  000cf	68 54 43 52 4c	 push	 1280459604		; 4c524354H
  000d4	8b 45 fc	 mov	 eax, DWORD PTR _Extension$[ebp]
  000d7	05 b8 00 00 00	 add	 eax, 184		; 000000b8H
  000dc	50		 push	 eax
  000dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoInitializeRemoveLockEx@20

; 57   : 
; 58   : 	filterDeviceObject->Flags |= Extension->LowerDeviceObject->Flags & (DO_DIRECT_IO | DO_BUFFERED_IO | DO_POWER_PAGABLE);

  000e3	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  000e6	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  000e9	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000ec	25 14 20 00 00	 and	 eax, 8212		; 00002014H
  000f1	8b 4d f0	 mov	 ecx, DWORD PTR _filterDeviceObject$[ebp]
  000f4	0b 41 1c	 or	 eax, DWORD PTR [ecx+28]
  000f7	8b 55 f0	 mov	 edx, DWORD PTR _filterDeviceObject$[ebp]
  000fa	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 59   : 	filterDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

  000fd	8b 45 f0	 mov	 eax, DWORD PTR _filterDeviceObject$[ebp]
  00100	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00103	81 e1 7f ff ff
	ff		 and	 ecx, -129		; ffffff7fH
  00109	8b 55 f0	 mov	 edx, DWORD PTR _filterDeviceObject$[ebp]
  0010c	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 60   : 
; 61   : 	return status;

  0010f	8b 45 f4	 mov	 eax, DWORD PTR _status$[ebp]
  00112	eb 29		 jmp	 SHORT $LN5@VolumeFilt
$err$27755:

; 62   : 
; 63   : err:
; 64   : 	if (filterDeviceObject)

  00114	83 7d f0 00	 cmp	 DWORD PTR _filterDeviceObject$[ebp], 0
  00118	74 20		 je	 SHORT $LN2@VolumeFilt

; 65   : 	{
; 66   : 		if (Extension->LowerDeviceObject)

  0011a	8b 45 fc	 mov	 eax, DWORD PTR _Extension$[ebp]
  0011d	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00121	74 0d		 je	 SHORT $LN1@VolumeFilt

; 67   : 			IoDetachDevice (Extension->LowerDeviceObject);

  00123	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00126	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00129	52		 push	 edx
  0012a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDetachDevice@4
$LN1@VolumeFilt:

; 68   : 
; 69   : 		IoDeleteDevice (filterDeviceObject);

  00130	8b 45 f0	 mov	 eax, DWORD PTR _filterDeviceObject$[ebp]
  00133	50		 push	 eax
  00134	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteDevice@4
$LN2@VolumeFilt:

; 70   : 	}
; 71   : 
; 72   : 	return status;

  0013a	8b 45 f4	 mov	 eax, DWORD PTR _status$[ebp]
$LN5@VolumeFilt:

; 73   : }

  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	c2 08 00	 ret	 8
_VolumeFilterAddDevice@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DL@GNELLIFI@?$CBExtension?9?$DObRootDevice?5?$CG?$CG?5Exten@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EL@KFIMJNPM@c?3?2home?2public?2desktop?2projects?2@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_IoGetCurrentIrpStackLocation@4
PUBLIC	_VolumeFilterDispatchIrp@8
EXTRN	__imp__IoReleaseRemoveLockEx@12:PROC
EXTRN	_TCCompleteIrp@12:PROC
EXTRN	__imp__IoAcquireRemoveLockEx@20:PROC
EXTRN	__imp__RtlAssert@16:PROC
;	COMDAT ??_C@_0DL@GNELLIFI@?$CBExtension?9?$DObRootDevice?5?$CG?$CG?5Exten@FNODOBFM@
text$s	SEGMENT
??_C@_0DL@GNELLIFI@?$CBExtension?9?$DObRootDevice?5?$CG?$CG?5Exten@FNODOBFM@ DB '!'
	DB	'Extension->bRootDevice && Extension->IsVolumeFilterDevice', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EL@KFIMJNPM@c?3?2home?2public?2desktop?2projects?2@FNODOBFM@
text$s	SEGMENT
??_C@_0EL@KFIMJNPM@c?3?2home?2public?2desktop?2projects?2@FNODOBFM@ DB 'c'
	DB	':\home\public\desktop\projects\ciphershed.build\src\driver\vo'
	DB	'lumefilter.c', 00H				;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _VolumeFilterDispatchIrp@8
_TEXT	SEGMENT
tv76 = -20						; size = 4
tv74 = -16						; size = 4
_irpSp$ = -12						; size = 4
_status$ = -8						; size = 4
_Extension$ = -4					; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_VolumeFilterDispatchIrp@8 PROC				; COMDAT

; 262  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 14	 sub	 esp, 20			; 00000014H

; 263  : 	VolumeFilterExtension *Extension = (VolumeFilterExtension *) DeviceObject->DeviceExtension;

  00008	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  0000b	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0000e	89 4d fc	 mov	 DWORD PTR _Extension$[ebp], ecx

; 264  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);

  00011	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _IoGetCurrentIrpStackLocation@4
  0001a	89 45 f4	 mov	 DWORD PTR _irpSp$[ebp], eax

; 265  : 	NTSTATUS status;
; 266  : 
; 267  : 	ASSERT (!Extension->bRootDevice && Extension->IsVolumeFilterDevice);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _Extension$[ebp]
  00020	83 38 00	 cmp	 DWORD PTR [eax], 0
  00023	75 12		 jne	 SHORT $LN10@VolumeFilt@2
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00028	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  0002c	74 09		 je	 SHORT $LN10@VolumeFilt@2
  0002e	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
  00035	eb 1e		 jmp	 SHORT $LN11@VolumeFilt@2
$LN10@VolumeFilt@2:
  00037	6a 00		 push	 0
  00039	68 0b 01 00 00	 push	 267			; 0000010bH
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@KFIMJNPM@c?3?2home?2public?2desktop?2projects?2@FNODOBFM@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@GNELLIFI@?$CBExtension?9?$DObRootDevice?5?$CG?$CG?5Exten@FNODOBFM@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  0004e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN11@VolumeFilt@2:

; 268  : 
; 269  : 	switch (irpSp->MajorFunction)

  00055	8b 55 f4	 mov	 edx, DWORD PTR _irpSp$[ebp]
  00058	8a 02		 mov	 al, BYTE PTR [edx]
  0005a	88 45 ec	 mov	 BYTE PTR tv76[ebp], al
  0005d	80 7d ec 0e	 cmp	 BYTE PTR tv76[ebp], 14	; 0000000eH
  00061	74 0e		 je	 SHORT $LN5@VolumeFilt@2
  00063	80 7d ec 16	 cmp	 BYTE PTR tv76[ebp], 22	; 00000016H
  00067	74 39		 je	 SHORT $LN3@VolumeFilt@2
  00069	80 7d ec 1b	 cmp	 BYTE PTR tv76[ebp], 27	; 0000001bH
  0006d	74 1c		 je	 SHORT $LN4@VolumeFilt@2
  0006f	eb 48		 jmp	 SHORT $LN2@VolumeFilt@2
$LN5@VolumeFilt@2:

; 270  : 	{
; 271  : 	case IRP_MJ_DEVICE_CONTROL:
; 272  : 		return DispatchControl (DeviceObject, Irp, Extension, irpSp);

  00071	8b 4d f4	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  00074	51		 push	 ecx
  00075	8b 55 fc	 mov	 edx, DWORD PTR _Extension$[ebp]
  00078	52		 push	 edx
  00079	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  0007c	50		 push	 eax
  0007d	8b 4d 08	 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  00080	51		 push	 ecx
  00081	e8 00 00 00 00	 call	 _DispatchControl@16
  00086	e9 93 00 00 00	 jmp	 $LN8@VolumeFilt@2
$LN4@VolumeFilt@2:

; 273  : 
; 274  : 	case IRP_MJ_PNP:
; 275  : 		return DispatchPnp (DeviceObject, Irp, Extension, irpSp);

  0008b	8b 55 f4	 mov	 edx, DWORD PTR _irpSp$[ebp]
  0008e	52		 push	 edx
  0008f	8b 45 fc	 mov	 eax, DWORD PTR _Extension$[ebp]
  00092	50		 push	 eax
  00093	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00096	51		 push	 ecx
  00097	8b 55 08	 mov	 edx, DWORD PTR _DeviceObject$[ebp]
  0009a	52		 push	 edx
  0009b	e8 00 00 00 00	 call	 _DispatchPnp@16
  000a0	eb 7c		 jmp	 SHORT $LN8@VolumeFilt@2
$LN3@VolumeFilt@2:

; 276  : 
; 277  : 	case IRP_MJ_POWER:
; 278  : 		return DispatchPower (DeviceObject, Irp, Extension, irpSp);

  000a2	8b 45 f4	 mov	 eax, DWORD PTR _irpSp$[ebp]
  000a5	50		 push	 eax
  000a6	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  000a9	51		 push	 ecx
  000aa	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  000ad	52		 push	 edx
  000ae	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 _DispatchPower@16
  000b7	eb 65		 jmp	 SHORT $LN8@VolumeFilt@2
$LN2@VolumeFilt@2:

; 279  : 
; 280  : 	default:
; 281  : 		status = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  000b9	6a 58		 push	 88			; 00000058H
  000bb	68 19 01 00 00	 push	 281			; 00000119H
  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@KFIMJNPM@c?3?2home?2public?2desktop?2projects?2@FNODOBFM@
  000c5	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  000c8	51		 push	 ecx
  000c9	8b 55 fc	 mov	 edx, DWORD PTR _Extension$[ebp]
  000cc	81 c2 b8 00 00
	00		 add	 edx, 184		; 000000b8H
  000d2	52		 push	 edx
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAcquireRemoveLockEx@20
  000d9	89 45 f8	 mov	 DWORD PTR _status$[ebp], eax

; 282  : 		if (!NT_SUCCESS (status))

  000dc	83 7d f8 00	 cmp	 DWORD PTR _status$[ebp], 0
  000e0	7d 11		 jge	 SHORT $LN1@VolumeFilt@2

; 283  : 			return TCCompleteIrp (Irp, status, 0);

  000e2	6a 00		 push	 0
  000e4	8b 45 f8	 mov	 eax, DWORD PTR _status$[ebp]
  000e7	50		 push	 eax
  000e8	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  000eb	51		 push	 ecx
  000ec	e8 00 00 00 00	 call	 _TCCompleteIrp@12
  000f1	eb 2b		 jmp	 SHORT $LN8@VolumeFilt@2
$LN1@VolumeFilt@2:

; 284  : 
; 285  : 		status = PassIrp (Extension->LowerDeviceObject, Irp);

  000f3	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  000f6	52		 push	 edx
  000f7	8b 45 fc	 mov	 eax, DWORD PTR _Extension$[ebp]
  000fa	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000fd	51		 push	 ecx
  000fe	e8 00 00 00 00	 call	 _PassIrp@8
  00103	89 45 f8	 mov	 DWORD PTR _status$[ebp], eax

; 286  : 
; 287  : 		IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00106	6a 58		 push	 88			; 00000058H
  00108	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  0010b	52		 push	 edx
  0010c	8b 45 fc	 mov	 eax, DWORD PTR _Extension$[ebp]
  0010f	05 b8 00 00 00	 add	 eax, 184		; 000000b8H
  00114	50		 push	 eax
  00115	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 288  : 		return status;

  0011b	8b 45 f8	 mov	 eax, DWORD PTR _status$[ebp]
$LN8@VolumeFilt@2:

; 289  : 	}
; 290  : }

  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c2 08 00	 ret	 8
_VolumeFilterDispatchIrp@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
text$s	SEGMENT
??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ DB 'I'
	DB	'rp->CurrentLocation <= Irp->StackCount + 1', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@
text$s	SEGMENT
??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@ DB 'c'
	DB	':\winddk\7600.16385.1\inc\ddk\wdm.h', 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _IoGetCurrentIrpStackLocation@4
_TEXT	SEGMENT
tv74 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoGetCurrentIrpStackLocation@4 PROC			; COMDAT

; 23316: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 23317:     ASSERT(Irp->CurrentLocation <= Irp->StackCount + 1);

  00006	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00009	0f be 48 23	 movsx	 ecx, BYTE PTR [eax+35]
  0000d	8b 55 08	 mov	 edx, DWORD PTR _Irp$[ebp]
  00010	0f be 42 22	 movsx	 eax, BYTE PTR [edx+34]
  00014	83 c0 01	 add	 eax, 1
  00017	3b c8		 cmp	 ecx, eax
  00019	7e 20		 jle	 SHORT $LN3@IoGetCurre
  0001b	6a 00		 push	 0
  0001d	68 15 5b 00 00	 push	 23317			; 00005b15H
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
  00039	eb 07		 jmp	 SHORT $LN4@IoGetCurre
$LN3@IoGetCurre:
  0003b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
$LN4@IoGetCurre:

; 23318:     return Irp->Tail.Overlay.CurrentStackLocation;

  00042	8b 4d 08	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00045	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]

; 23319: }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
_IoGetCurrentIrpStackLocation@4 ENDP
_TEXT	ENDS
PUBLIC	_IoSkipCurrentIrpStackLocation@4
EXTRN	__imp_@IofCallDriver@8:PROC
; Function compile flags: /Odtp
; File c:\home\public\desktop\projects\ciphershed.build\src\driver\volumefilter.c
;	COMDAT _PassIrp@8
_TEXT	SEGMENT
_deviceObject$ = 8					; size = 4
_irp$ = 12						; size = 4
_PassIrp@8 PROC						; COMDAT

; 77   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 78   : 	IoSkipCurrentIrpStackLocation (irp);

  00005	8b 45 0c	 mov	 eax, DWORD PTR _irp$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IoSkipCurrentIrpStackLocation@4

; 79   : 	return IoCallDriver (deviceObject, irp);

  0000e	8b 55 0c	 mov	 edx, DWORD PTR _irp$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _deviceObject$[ebp]
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8

; 80   : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
_PassIrp@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CI@HDMHMCGD@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0CI@HDMHMCGD@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
text$s	SEGMENT
??_C@_0CI@HDMHMCGD@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ DB 'I'
	DB	'rp->CurrentLocation <= Irp->StackCount', 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _IoSkipCurrentIrpStackLocation@4
_TEXT	SEGMENT
tv73 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoSkipCurrentIrpStackLocation@4 PROC			; COMDAT

; 23945: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 23946:     ASSERT(Irp->CurrentLocation <= Irp->StackCount);

  00006	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00009	0f be 48 23	 movsx	 ecx, BYTE PTR [eax+35]
  0000d	8b 55 08	 mov	 edx, DWORD PTR _Irp$[ebp]
  00010	0f be 42 22	 movsx	 eax, BYTE PTR [edx+34]
  00014	3b c8		 cmp	 ecx, eax
  00016	7e 20		 jle	 SHORT $LN3@IoSkipCurr
  00018	6a 00		 push	 0
  0001a	68 8a 5d 00 00	 push	 23946			; 00005d8aH
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@HDMHMCGD@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00036	eb 07		 jmp	 SHORT $LN4@IoSkipCurr
$LN3@IoSkipCurr:
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv73[ebp], 1
$LN4@IoSkipCurr:

; 23947:     Irp->CurrentLocation++;

  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00042	8a 51 23	 mov	 dl, BYTE PTR [ecx+35]
  00045	80 c2 01	 add	 dl, 1
  00048	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  0004b	88 50 23	 mov	 BYTE PTR [eax+35], dl

; 23948:     Irp->Tail.Overlay.CurrentStackLocation++;

  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00051	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00054	83 c2 24	 add	 edx, 36			; 00000024H
  00057	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  0005a	89 50 60	 mov	 DWORD PTR [eax+96], edx

; 23949: }

  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
_IoSkipCurrentIrpStackLocation@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@FPKIEKIL@TC_IOCTL_DISK_IS_WRITABLE?5pdo?$DN?$CFp@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	_ProbingHostDeviceForWrite:DWORD
EXTRN	_TCCompleteDiskIrp@12:PROC
EXTRN	_SendDeviceIoControlRequest@24:PROC
EXTRN	__imp__KeBugCheckEx@20:PROC
EXTRN	_GetBootDriveFilterExtension@0:PROC
EXTRN	_IsHiddenSystemRunning@0:PROC
;	COMDAT ??_C@_0CC@FPKIEKIL@TC_IOCTL_DISK_IS_WRITABLE?5pdo?$DN?$CFp@FNODOBFM@
; File c:\home\public\desktop\projects\ciphershed.build\src\driver\volumefilter.c
text$s	SEGMENT
??_C@_0CC@FPKIEKIL@TC_IOCTL_DISK_IS_WRITABLE?5pdo?$DN?$CFp@FNODOBFM@ DB 'T'
	DB	'C_IOCTL_DISK_IS_WRITABLE pdo=%p', 0aH, 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _DispatchControl@16
_TEXT	SEGMENT
tv240 = -176						; size = 4
tv79 = -172						; size = 4
_partition$27834 = -168					; size = 144
_storageDeviceNumber$27826 = -20			; size = 12
_bootDriveExtension$27825 = -8				; size = 4
_status$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_Extension$ = 16					; size = 4
_irpSp$ = 20						; size = 4
_DispatchControl@16 PROC				; COMDAT

; 121  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec b0 00 00
	00		 sub	 esp, 176		; 000000b0H

; 122  : 	NTSTATUS status = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  0000b	6a 58		 push	 88			; 00000058H
  0000d	6a 7a		 push	 122			; 0000007aH
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@KFIMJNPM@c?3?2home?2public?2desktop?2projects?2@FNODOBFM@
  00014	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00017	50		 push	 eax
  00018	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0001b	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  00021	51		 push	 ecx
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAcquireRemoveLockEx@20
  00028	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 123  : 	if (!NT_SUCCESS (status))

  0002b	83 7d fc 00	 cmp	 DWORD PTR _status$[ebp], 0
  0002f	7d 14		 jge	 SHORT $LN13@DispatchCo

; 124  : 		return TCCompleteIrp (Irp, status, 0);

  00031	6a 00		 push	 0
  00033	8b 55 fc	 mov	 edx, DWORD PTR _status$[ebp]
  00036	52		 push	 edx
  00037	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 _TCCompleteIrp@12
  00040	e9 65 02 00 00	 jmp	 $LN15@DispatchCo
$LN13@DispatchCo:

; 125  : 
; 126  : 	if (IsHiddenSystemRunning())

  00045	e8 00 00 00 00	 call	 _IsHiddenSystemRunning@0
  0004a	85 c0		 test	 eax, eax
  0004c	0f 84 2d 02 00
	00		 je	 $LN12@DispatchCo

; 127  : 	{
; 128  : 		switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  00052	8b 4d 14	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  00055	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00058	89 95 54 ff ff
	ff		 mov	 DWORD PTR tv79[ebp], edx
  0005e	81 bd 54 ff ff
	ff 24 00 07 00	 cmp	 DWORD PTR tv79[ebp], 458788 ; 00070024H
  00068	74 25		 je	 SHORT $LN9@DispatchCo
  0006a	81 bd 54 ff ff
	ff 74 20 22 00	 cmp	 DWORD PTR tv79[ebp], 2236532 ; 00222074H
  00074	0f 84 27 01 00
	00		 je	 $LN5@DispatchCo
  0007a	81 bd 54 ff ff
	ff 04 94 2d 00	 cmp	 DWORD PTR tv79[ebp], 2987012 ; 002d9404H
  00084	0f 84 d1 01 00
	00		 je	 $LN1@DispatchCo
  0008a	e9 f0 01 00 00	 jmp	 $LN12@DispatchCo
$LN9@DispatchCo:

; 129  : 		{
; 130  : 		case IOCTL_DISK_IS_WRITABLE:
; 131  : 			{
; 132  : 				// All volumes except the system volume must be read-only
; 133  : 
; 134  : 				DriveFilterExtension *bootDriveExtension = GetBootDriveFilterExtension();

  0008f	e8 00 00 00 00	 call	 _GetBootDriveFilterExtension@0
  00094	89 45 f8	 mov	 DWORD PTR _bootDriveExtension$27825[ebp], eax

; 135  : 				STORAGE_DEVICE_NUMBER storageDeviceNumber;
; 136  : 
; 137  : 				if (!bootDriveExtension->SystemStorageDeviceNumberValid)

  00097	8b 45 f8	 mov	 eax, DWORD PTR _bootDriveExtension$27825[ebp]
  0009a	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  0009e	75 19		 jne	 SHORT $LN8@DispatchCo

; 138  : 					TC_BUG_CHECK (STATUS_INVALID_PARAMETER);

  000a0	68 43 54 00 00	 push	 21571			; 00005443H
  000a5	6a 00		 push	 0
  000a7	68 0d 00 00 c0	 push	 -1073741811		; c000000dH
  000ac	68 8a 00 00 00	 push	 138			; 0000008aH
  000b1	6a 29		 push	 41			; 00000029H
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN8@DispatchCo:

; 139  : 
; 140  : 				status = SendDeviceIoControlRequest (Extension->LowerDeviceObject, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0, &storageDeviceNumber, sizeof (storageDeviceNumber));

  000b9	6a 0c		 push	 12			; 0000000cH
  000bb	8d 4d ec	 lea	 ecx, DWORD PTR _storageDeviceNumber$27826[ebp]
  000be	51		 push	 ecx
  000bf	6a 00		 push	 0
  000c1	6a 00		 push	 0
  000c3	68 80 10 2d 00	 push	 2953344			; 002d1080H
  000c8	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  000cb	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000ce	50		 push	 eax
  000cf	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  000d4	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 141  : 
; 142  : 				if (NT_SUCCESS (status) && bootDriveExtension->SystemStorageDeviceNumber == storageDeviceNumber.DeviceNumber)

  000d7	83 7d fc 00	 cmp	 DWORD PTR _status$[ebp], 0
  000db	0f 8c 87 00 00
	00		 jl	 $LN7@DispatchCo
  000e1	8b 4d f8	 mov	 ecx, DWORD PTR _bootDriveExtension$27825[ebp]
  000e4	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000e7	3b 55 f0	 cmp	 edx, DWORD PTR _storageDeviceNumber$27826[ebp+4]
  000ea	75 7c		 jne	 SHORT $LN7@DispatchCo

; 143  : 				{
; 144  : 					PARTITION_INFORMATION_EX partition;
; 145  : 					status = SendDeviceIoControlRequest (Extension->LowerDeviceObject, IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0, &partition, sizeof (partition));

  000ec	68 90 00 00 00	 push	 144			; 00000090H
  000f1	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _partition$27834[ebp]
  000f7	50		 push	 eax
  000f8	6a 00		 push	 0
  000fa	6a 00		 push	 0
  000fc	68 48 00 07 00	 push	 458824			; 00070048H
  00101	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00104	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00107	52		 push	 edx
  00108	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  0010d	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 146  : 
; 147  : 					if (NT_SUCCESS (status) && partition.StartingOffset.QuadPart == bootDriveExtension->ConfiguredEncryptedAreaStart)

  00110	83 7d fc 00	 cmp	 DWORD PTR _status$[ebp], 0
  00114	7c 52		 jl	 SHORT $LN7@DispatchCo
  00116	8b 45 f8	 mov	 eax, DWORD PTR _bootDriveExtension$27825[ebp]
  00119	89 85 50 ff ff
	ff		 mov	 DWORD PTR tv240[ebp], eax
  0011f	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR tv240[ebp]
  00125	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _partition$27834[ebp+8]
  0012b	3b 51 30	 cmp	 edx, DWORD PTR [ecx+48]
  0012e	75 38		 jne	 SHORT $LN7@DispatchCo
  00130	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR tv240[ebp]
  00136	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _partition$27834[ebp+12]
  0013c	3b 48 34	 cmp	 ecx, DWORD PTR [eax+52]
  0013f	75 27		 jne	 SHORT $LN7@DispatchCo

; 148  : 					{
; 149  : 						IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00141	6a 58		 push	 88			; 00000058H
  00143	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  00146	52		 push	 edx
  00147	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  0014a	05 b8 00 00 00	 add	 eax, 184		; 000000b8H
  0014f	50		 push	 eax
  00150	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 150  : 						return TCCompleteDiskIrp (Irp, STATUS_SUCCESS, 0);

  00156	6a 00		 push	 0
  00158	6a 00		 push	 0
  0015a	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  0015d	51		 push	 ecx
  0015e	e8 00 00 00 00	 call	 _TCCompleteDiskIrp@12
  00163	e9 42 01 00 00	 jmp	 $LN15@DispatchCo
$LN7@DispatchCo:

; 151  : 					}
; 152  : 				}
; 153  : 
; 154  : 				IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00168	6a 58		 push	 88			; 00000058H
  0016a	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  0016d	52		 push	 edx
  0016e	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  00171	05 b8 00 00 00	 add	 eax, 184		; 000000b8H
  00176	50		 push	 eax
  00177	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 155  : 
; 156  : 				++HiddenSysLeakProtectionCount;

  0017d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _HiddenSysLeakProtectionCount
  00183	83 c1 01	 add	 ecx, 1
  00186	89 0d 00 00 00
	00		 mov	 DWORD PTR _HiddenSysLeakProtectionCount, ecx

; 157  : 				return TCCompleteDiskIrp (Irp, STATUS_MEDIA_WRITE_PROTECTED, 0);

  0018c	6a 00		 push	 0
  0018e	68 a2 00 00 c0	 push	 -1073741662		; c00000a2H
  00193	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  00196	52		 push	 edx
  00197	e8 00 00 00 00	 call	 _TCCompleteDiskIrp@12
  0019c	e9 09 01 00 00	 jmp	 $LN15@DispatchCo
$LN5@DispatchCo:

; 158  : 			}
; 159  : 
; 160  : 		case TC_IOCTL_DISK_IS_WRITABLE:
; 161  : 			Dump ("TC_IOCTL_DISK_IS_WRITABLE pdo=%p\n", Extension->Pdo);

  001a1	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  001a4	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  001a7	51		 push	 ecx
  001a8	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@FPKIEKIL@TC_IOCTL_DISK_IS_WRITABLE?5pdo?$DN?$CFp@FNODOBFM@
  001ad	e8 00 00 00 00	 call	 _DbgPrint
  001b2	83 c4 08	 add	 esp, 8

; 162  : 
; 163  : 			if (!ProbingHostDeviceForWrite)

  001b5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ProbingHostDeviceForWrite, 0
  001bc	75 05		 jne	 SHORT $LN4@DispatchCo

; 164  : 				break;

  001be	e9 bc 00 00 00	 jmp	 $LN12@DispatchCo
$LN4@DispatchCo:

; 165  : 
; 166  : 			// Probe the real state of the device as the user is mounting a CipherShed volume.
; 167  : 
; 168  : 			// Volume filter may be attached to a merged drive+volume PDO. First test if TC_IOCTL_DISK_IS_WRITABLE works for the underlying device.
; 169  : 			status = SendDeviceIoControlRequest (Extension->LowerDeviceObject, TC_IOCTL_DISK_IS_WRITABLE, NULL, 0, NULL, 0);

  001c3	6a 00		 push	 0
  001c5	6a 00		 push	 0
  001c7	6a 00		 push	 0
  001c9	6a 00		 push	 0
  001cb	68 74 20 22 00	 push	 2236532			; 00222074H
  001d0	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  001d3	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  001d6	50		 push	 eax
  001d7	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  001dc	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 170  : 
; 171  : 			if (NT_SUCCESS (status) || status == STATUS_MEDIA_WRITE_PROTECTED)

  001df	83 7d fc 00	 cmp	 DWORD PTR _status$[ebp], 0
  001e3	7d 09		 jge	 SHORT $LN2@DispatchCo
  001e5	81 7d fc a2 00
	00 c0		 cmp	 DWORD PTR _status$[ebp], -1073741662 ; c00000a2H
  001ec	75 2a		 jne	 SHORT $LN3@DispatchCo
$LN2@DispatchCo:

; 172  : 			{
; 173  : 				IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  001ee	6a 58		 push	 88			; 00000058H
  001f0	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  001f3	51		 push	 ecx
  001f4	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  001f7	81 c2 b8 00 00
	00		 add	 edx, 184		; 000000b8H
  001fd	52		 push	 edx
  001fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 174  : 				return TCCompleteDiskIrp (Irp, status, 0);

  00204	6a 00		 push	 0
  00206	8b 45 fc	 mov	 eax, DWORD PTR _status$[ebp]
  00209	50		 push	 eax
  0020a	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  0020d	51		 push	 ecx
  0020e	e8 00 00 00 00	 call	 _TCCompleteDiskIrp@12
  00213	e9 92 00 00 00	 jmp	 $LN15@DispatchCo
$LN3@DispatchCo:

; 175  : 			}
; 176  : 
; 177  : 			status = SendDeviceIoControlRequest (Extension->LowerDeviceObject, IOCTL_DISK_IS_WRITABLE, NULL, 0, NULL, 0);

  00218	6a 00		 push	 0
  0021a	6a 00		 push	 0
  0021c	6a 00		 push	 0
  0021e	6a 00		 push	 0
  00220	68 24 00 07 00	 push	 458788			; 00070024H
  00225	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  00228	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0022b	50		 push	 eax
  0022c	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  00231	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 178  : 
; 179  : 			IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00234	6a 58		 push	 88			; 00000058H
  00236	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00239	51		 push	 ecx
  0023a	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  0023d	81 c2 b8 00 00
	00		 add	 edx, 184		; 000000b8H
  00243	52		 push	 edx
  00244	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 180  : 			return TCCompleteDiskIrp (Irp, status, 0);

  0024a	6a 00		 push	 0
  0024c	8b 45 fc	 mov	 eax, DWORD PTR _status$[ebp]
  0024f	50		 push	 eax
  00250	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00253	51		 push	 ecx
  00254	e8 00 00 00 00	 call	 _TCCompleteDiskIrp@12
  00259	eb 4f		 jmp	 SHORT $LN15@DispatchCo
$LN1@DispatchCo:

; 181  : 
; 182  : 		case IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES:
; 183  : 
; 184  : 			// Filter IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES to enable potential future use of hidden systems on drives that use the trim operation but not wear-leveling (if any appear in future). The documentation forbids users to create hidden volumes/systems on drives that use wear-leveling and consequently also on drives that use trim (as trim is used only by drives that use wear-leveling, as of 2010).
; 185  : 
; 186  : 			IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  0025b	6a 58		 push	 88			; 00000058H
  0025d	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  00260	52		 push	 edx
  00261	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  00264	05 b8 00 00 00	 add	 eax, 184		; 000000b8H
  00269	50		 push	 eax
  0026a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 187  : 			return TCCompleteDiskIrp (Irp, STATUS_SUCCESS, 0);

  00270	6a 00		 push	 0
  00272	6a 00		 push	 0
  00274	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00277	51		 push	 ecx
  00278	e8 00 00 00 00	 call	 _TCCompleteDiskIrp@12
  0027d	eb 2b		 jmp	 SHORT $LN15@DispatchCo
$LN12@DispatchCo:

; 188  : 		}
; 189  : 	}
; 190  : 
; 191  : 	status = PassIrp (Extension->LowerDeviceObject, Irp);

  0027f	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  00282	52		 push	 edx
  00283	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  00286	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00289	51		 push	 ecx
  0028a	e8 00 00 00 00	 call	 _PassIrp@8
  0028f	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 192  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00292	6a 58		 push	 88			; 00000058H
  00294	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  00297	52		 push	 edx
  00298	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  0029b	05 b8 00 00 00	 add	 eax, 184		; 000000b8H
  002a0	50		 push	 eax
  002a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 193  : 	return status;

  002a7	8b 45 fc	 mov	 eax, DWORD PTR _status$[ebp]
$LN15@DispatchCo:

; 194  : }

  002aa	8b e5		 mov	 esp, ebp
  002ac	5d		 pop	 ebp
  002ad	c2 10 00	 ret	 16			; 00000010H
_DispatchControl@16 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@GJODMOBD@IRP_MN_REMOVE_DEVICE?5volume?5pdo?$DN@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CD@BENKCDLN@IRP_MN_START_DEVICE?5volume?5pdo?$DN?$CF@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp__IoReleaseRemoveLockAndWaitEx@12:PROC
;	COMDAT ??_C@_0CE@GJODMOBD@IRP_MN_REMOVE_DEVICE?5volume?5pdo?$DN@FNODOBFM@
text$s	SEGMENT
??_C@_0CE@GJODMOBD@IRP_MN_REMOVE_DEVICE?5volume?5pdo?$DN@FNODOBFM@ DB 'IR'
	DB	'P_MN_REMOVE_DEVICE volume pdo=%p', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CD@BENKCDLN@IRP_MN_START_DEVICE?5volume?5pdo?$DN?$CF@FNODOBFM@
text$s	SEGMENT
??_C@_0CD@BENKCDLN@IRP_MN_START_DEVICE?5volume?5pdo?$DN?$CF@FNODOBFM@ DB 'I'
	DB	'RP_MN_START_DEVICE volume pdo=%p', 0aH, 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _DispatchPnp@16
_TEXT	SEGMENT
tv78 = -12						; size = 4
_attachedDevice$27880 = -8				; size = 4
_status$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_Extension$ = 16					; size = 4
_irpSp$ = 20						; size = 4
_DispatchPnp@16 PROC					; COMDAT

; 198  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 199  : 	NTSTATUS status;
; 200  : 
; 201  : 	status = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00008	6a 58		 push	 88			; 00000058H
  0000a	68 c9 00 00 00	 push	 201			; 000000c9H
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@KFIMJNPM@c?3?2home?2public?2desktop?2projects?2@FNODOBFM@
  00014	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00017	50		 push	 eax
  00018	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0001b	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  00021	51		 push	 ecx
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAcquireRemoveLockEx@20
  00028	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 202  : 	if (!NT_SUCCESS (status))

  0002b	83 7d fc 00	 cmp	 DWORD PTR _status$[ebp], 0
  0002f	7d 14		 jge	 SHORT $LN9@DispatchPn

; 203  : 		return TCCompleteIrp (Irp, status, 0);

  00031	6a 00		 push	 0
  00033	8b 55 fc	 mov	 edx, DWORD PTR _status$[ebp]
  00036	52		 push	 edx
  00037	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 _TCCompleteIrp@12
  00040	e9 36 01 00 00	 jmp	 $LN10@DispatchPn
$LN9@DispatchPn:

; 204  : 
; 205  : 	switch (irpSp->MinorFunction)

  00045	8b 4d 14	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  00048	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  0004b	88 55 f4	 mov	 BYTE PTR tv78[ebp], dl
  0004e	80 7d f4 00	 cmp	 BYTE PTR tv78[ebp], 0
  00052	74 15		 je	 SHORT $LN6@DispatchPn
  00054	80 7d f4 02	 cmp	 BYTE PTR tv78[ebp], 2
  00058	0f 84 98 00 00
	00		 je	 $LN2@DispatchPn
  0005e	80 7d f4 16	 cmp	 BYTE PTR tv78[ebp], 22	; 00000016H
  00062	74 37		 je	 SHORT $LN5@DispatchPn
  00064	e9 e6 00 00 00	 jmp	 $LN1@DispatchPn
$LN6@DispatchPn:

; 206  : 	{
; 207  : 	case IRP_MN_START_DEVICE:
; 208  : 		Dump ("IRP_MN_START_DEVICE volume pdo=%p\n", Extension->Pdo);

  00069	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  0006c	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0006f	51		 push	 ecx
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@BENKCDLN@IRP_MN_START_DEVICE?5volume?5pdo?$DN?$CF@FNODOBFM@
  00075	e8 00 00 00 00	 call	 _DbgPrint
  0007a	83 c4 08	 add	 esp, 8

; 209  : 		return PassFilteredIrp (Extension->LowerDeviceObject, Irp, OnStartDeviceCompleted, Extension);

  0007d	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  00080	52		 push	 edx
  00081	68 00 00 00 00	 push	 OFFSET _OnStartDeviceCompleted@12
  00086	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00089	50		 push	 eax
  0008a	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0008d	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00090	52		 push	 edx
  00091	e8 00 00 00 00	 call	 _PassFilteredIrp@16
  00096	e9 e0 00 00 00	 jmp	 $LN10@DispatchPn
$LN5@DispatchPn:

; 210  : 
; 211  : 	case IRP_MN_DEVICE_USAGE_NOTIFICATION:
; 212  : 		{
; 213  : 			PDEVICE_OBJECT attachedDevice = IoGetAttachedDeviceReference (DeviceObject);

  0009b	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  0009e	50		 push	 eax
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoGetAttachedDeviceReference@4
  000a5	89 45 f8	 mov	 DWORD PTR _attachedDevice$27880[ebp], eax

; 214  : 
; 215  : 			if (attachedDevice == DeviceObject || (attachedDevice->Flags & DO_POWER_PAGABLE))

  000a8	8b 4d f8	 mov	 ecx, DWORD PTR _attachedDevice$27880[ebp]
  000ab	3b 4d 08	 cmp	 ecx, DWORD PTR _DeviceObject$[ebp]
  000ae	74 0d		 je	 SHORT $LN3@DispatchPn
  000b0	8b 55 f8	 mov	 edx, DWORD PTR _attachedDevice$27880[ebp]
  000b3	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000b6	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  000bb	74 12		 je	 SHORT $LN4@DispatchPn
$LN3@DispatchPn:

; 216  : 				DeviceObject->Flags |= DO_POWER_PAGABLE;

  000bd	8b 4d 08	 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  000c0	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  000c3	81 ca 00 20 00
	00		 or	 edx, 8192		; 00002000H
  000c9	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  000cc	89 50 1c	 mov	 DWORD PTR [eax+28], edx
$LN4@DispatchPn:

; 217  : 
; 218  : 			ObDereferenceObject (attachedDevice);

  000cf	8b 4d f8	 mov	 ecx, DWORD PTR _attachedDevice$27880[ebp]
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 219  : 		}
; 220  : 
; 221  : 		return PassFilteredIrp (Extension->LowerDeviceObject, Irp, OnDeviceUsageNotificationCompleted, Extension);

  000d8	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  000db	51		 push	 ecx
  000dc	68 00 00 00 00	 push	 OFFSET _OnDeviceUsageNotificationCompleted@12
  000e1	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  000e4	52		 push	 edx
  000e5	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  000e8	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000eb	51		 push	 ecx
  000ec	e8 00 00 00 00	 call	 _PassFilteredIrp@16
  000f1	e9 85 00 00 00	 jmp	 $LN10@DispatchPn
$LN2@DispatchPn:

; 222  : 
; 223  : 
; 224  : 	case IRP_MN_REMOVE_DEVICE:
; 225  : 		Dump ("IRP_MN_REMOVE_DEVICE volume pdo=%p\n", Extension->Pdo);

  000f6	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  000f9	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  000fc	50		 push	 eax
  000fd	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@GJODMOBD@IRP_MN_REMOVE_DEVICE?5volume?5pdo?$DN@FNODOBFM@
  00102	e8 00 00 00 00	 call	 _DbgPrint
  00107	83 c4 08	 add	 esp, 8

; 226  : 
; 227  : 		IoReleaseRemoveLockAndWait (&Extension->Queue.RemoveLock, Irp);

  0010a	6a 58		 push	 88			; 00000058H
  0010c	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  0010f	51		 push	 ecx
  00110	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  00113	81 c2 b8 00 00
	00		 add	 edx, 184		; 000000b8H
  00119	52		 push	 edx
  0011a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockAndWaitEx@12

; 228  : 		status = PassIrp (Extension->LowerDeviceObject, Irp);

  00120	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00123	50		 push	 eax
  00124	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00127	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0012a	52		 push	 edx
  0012b	e8 00 00 00 00	 call	 _PassIrp@8
  00130	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 229  : 
; 230  : 		IoDetachDevice (Extension->LowerDeviceObject);

  00133	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  00136	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00139	51		 push	 ecx
  0013a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDetachDevice@4

; 231  : 
; 232  : 		IoDeleteDevice (DeviceObject);

  00140	8b 55 08	 mov	 edx, DWORD PTR _DeviceObject$[ebp]
  00143	52		 push	 edx
  00144	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteDevice@4

; 233  : 		return status;

  0014a	8b 45 fc	 mov	 eax, DWORD PTR _status$[ebp]
  0014d	eb 2c		 jmp	 SHORT $LN10@DispatchPn
$LN1@DispatchPn:

; 234  : 
; 235  : 	default:
; 236  : 		status = PassIrp (Extension->LowerDeviceObject, Irp);

  0014f	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00152	50		 push	 eax
  00153	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00156	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00159	52		 push	 edx
  0015a	e8 00 00 00 00	 call	 _PassIrp@8
  0015f	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 237  : 		IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00162	6a 58		 push	 88			; 00000058H
  00164	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00167	50		 push	 eax
  00168	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0016b	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  00171	51		 push	 ecx
  00172	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 238  : 	}
; 239  : 
; 240  : 	return status;

  00178	8b 45 fc	 mov	 eax, DWORD PTR _status$[ebp]
$LN10@DispatchPn:

; 241  : }

  0017b	8b e5		 mov	 esp, ebp
  0017d	5d		 pop	 ebp
  0017e	c2 10 00	 ret	 16			; 00000010H
_DispatchPnp@16 ENDP
_TEXT	ENDS
PUBLIC	_IoSetCompletionRoutine@24
PUBLIC	_IoCopyCurrentIrpStackLocationToNext@4
; Function compile flags: /Odtp
;	COMDAT _PassFilteredIrp@16
_TEXT	SEGMENT
_deviceObject$ = 8					; size = 4
_irp$ = 12						; size = 4
_completionRoutine$ = 16				; size = 4
_completionRoutineArg$ = 20				; size = 4
_PassFilteredIrp@16 PROC				; COMDAT

; 84   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 85   : 	IoCopyCurrentIrpStackLocationToNext (irp);

  00005	8b 45 0c	 mov	 eax, DWORD PTR _irp$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IoCopyCurrentIrpStackLocationToNext@4

; 86   : 
; 87   : 	if (completionRoutine)

  0000e	83 7d 10 00	 cmp	 DWORD PTR _completionRoutine$[ebp], 0
  00012	74 17		 je	 SHORT $LN1@PassFilter

; 88   : 		IoSetCompletionRoutine (irp, completionRoutine, completionRoutineArg, TRUE, TRUE, TRUE);

  00014	6a 01		 push	 1
  00016	6a 01		 push	 1
  00018	6a 01		 push	 1
  0001a	8b 4d 14	 mov	 ecx, DWORD PTR _completionRoutineArg$[ebp]
  0001d	51		 push	 ecx
  0001e	8b 55 10	 mov	 edx, DWORD PTR _completionRoutine$[ebp]
  00021	52		 push	 edx
  00022	8b 45 0c	 mov	 eax, DWORD PTR _irp$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _IoSetCompletionRoutine@24
$LN1@PassFilter:

; 89   : 
; 90   : 	return IoCallDriver (deviceObject, irp);

  0002b	8b 55 0c	 mov	 edx, DWORD PTR _irp$[ebp]
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _deviceObject$[ebp]
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8

; 91   : }

  00037	5d		 pop	 ebp
  00038	c2 10 00	 ret	 16			; 00000010H
_PassFilteredIrp@16 ENDP
_TEXT	ENDS
PUBLIC	_IoGetNextIrpStackLocation@4
PUBLIC	??_C@_0FK@JAEDPCKJ@?$CIInvokeOnSuccess?5?$HM?$HM?5InvokeOnErro@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0FK@JAEDPCKJ@?$CIInvokeOnSuccess?5?$HM?$HM?5InvokeOnErro@FNODOBFM@
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
text$s	SEGMENT
??_C@_0FK@JAEDPCKJ@?$CIInvokeOnSuccess?5?$HM?$HM?5InvokeOnErro@FNODOBFM@ DB '('
	DB	'InvokeOnSuccess || InvokeOnError || InvokeOnCancel) ? (Comple'
	DB	'tionRoutine != NULL) : TRUE', 00H		;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _IoSetCompletionRoutine@24
_TEXT	SEGMENT
tv78 = -12						; size = 4
tv72 = -8						; size = 4
_irpSp$ = -4						; size = 4
_Irp$ = 8						; size = 4
_CompletionRoutine$ = 12				; size = 4
_Context$ = 16						; size = 4
_InvokeOnSuccess$ = 20					; size = 1
_InvokeOnError$ = 24					; size = 1
_InvokeOnCancel$ = 28					; size = 1
_IoSetCompletionRoutine@24 PROC				; COMDAT

; 23820: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 23821:     PIO_STACK_LOCATION irpSp;
; 23822:     ASSERT( (InvokeOnSuccess || InvokeOnError || InvokeOnCancel) ? (CompletionRoutine != NULL) : TRUE );

  00008	0f b6 45 14	 movzx	 eax, BYTE PTR _InvokeOnSuccess$[ebp]
  0000c	85 c0		 test	 eax, eax
  0000e	75 19		 jne	 SHORT $LN6@IoSetCompl
  00010	0f b6 4d 18	 movzx	 ecx, BYTE PTR _InvokeOnError$[ebp]
  00014	85 c9		 test	 ecx, ecx
  00016	75 11		 jne	 SHORT $LN6@IoSetCompl
  00018	0f b6 55 1c	 movzx	 edx, BYTE PTR _InvokeOnCancel$[ebp]
  0001c	85 d2		 test	 edx, edx
  0001e	75 09		 jne	 SHORT $LN6@IoSetCompl
  00020	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv72[ebp], 1
  00027	eb 0c		 jmp	 SHORT $LN7@IoSetCompl
$LN6@IoSetCompl:
  00029	33 c0		 xor	 eax, eax
  0002b	83 7d 0c 00	 cmp	 DWORD PTR _CompletionRoutine$[ebp], 0
  0002f	0f 95 c0	 setne	 al
  00032	89 45 f8	 mov	 DWORD PTR tv72[ebp], eax
$LN7@IoSetCompl:
  00035	83 7d f8 00	 cmp	 DWORD PTR tv72[ebp], 0
  00039	75 20		 jne	 SHORT $LN8@IoSetCompl
  0003b	6a 00		 push	 0
  0003d	68 0e 5d 00 00	 push	 23822			; 00005d0eH
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@JAEDPCKJ@?$CIInvokeOnSuccess?5?$HM?$HM?5InvokeOnErro@FNODOBFM@
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  00052	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
  00059	eb 07		 jmp	 SHORT $LN9@IoSetCompl
$LN8@IoSetCompl:
  0005b	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
$LN9@IoSetCompl:

; 23823:     irpSp = IoGetNextIrpStackLocation(Irp);

  00062	8b 4d 08	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 _IoGetNextIrpStackLocation@4
  0006b	89 45 fc	 mov	 DWORD PTR _irpSp$[ebp], eax

; 23824:     irpSp->CompletionRoutine = CompletionRoutine;

  0006e	8b 55 fc	 mov	 edx, DWORD PTR _irpSp$[ebp]
  00071	8b 45 0c	 mov	 eax, DWORD PTR _CompletionRoutine$[ebp]
  00074	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 23825:     irpSp->Context = Context;

  00077	8b 4d fc	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  0007a	8b 55 10	 mov	 edx, DWORD PTR _Context$[ebp]
  0007d	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 23826:     irpSp->Control = 0;

  00080	8b 45 fc	 mov	 eax, DWORD PTR _irpSp$[ebp]
  00083	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0

; 23827: 
; 23828:     if (InvokeOnSuccess) {

  00087	0f b6 4d 14	 movzx	 ecx, BYTE PTR _InvokeOnSuccess$[ebp]
  0008b	85 c9		 test	 ecx, ecx
  0008d	74 07		 je	 SHORT $LN3@IoSetCompl

; 23829:         irpSp->Control = SL_INVOKE_ON_SUCCESS;

  0008f	8b 55 fc	 mov	 edx, DWORD PTR _irpSp$[ebp]
  00092	c6 42 03 40	 mov	 BYTE PTR [edx+3], 64	; 00000040H
$LN3@IoSetCompl:

; 23830:     }
; 23831: 
; 23832:     if (InvokeOnError) {

  00096	0f b6 45 18	 movzx	 eax, BYTE PTR _InvokeOnError$[ebp]
  0009a	85 c0		 test	 eax, eax
  0009c	74 13		 je	 SHORT $LN2@IoSetCompl

; 23833:         irpSp->Control |= SL_INVOKE_ON_ERROR;

  0009e	8b 4d fc	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  000a1	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  000a5	81 ca 80 00 00
	00		 or	 edx, 128		; 00000080H
  000ab	8b 45 fc	 mov	 eax, DWORD PTR _irpSp$[ebp]
  000ae	88 50 03	 mov	 BYTE PTR [eax+3], dl
$LN2@IoSetCompl:

; 23834:     }
; 23835: 
; 23836:     if (InvokeOnCancel) {

  000b1	0f b6 4d 1c	 movzx	 ecx, BYTE PTR _InvokeOnCancel$[ebp]
  000b5	85 c9		 test	 ecx, ecx
  000b7	74 10		 je	 SHORT $LN4@IoSetCompl

; 23837:         irpSp->Control |= SL_INVOKE_ON_CANCEL;

  000b9	8b 55 fc	 mov	 edx, DWORD PTR _irpSp$[ebp]
  000bc	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  000c0	83 c8 20	 or	 eax, 32			; 00000020H
  000c3	8b 4d fc	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  000c6	88 41 03	 mov	 BYTE PTR [ecx+3], al
$LN4@IoSetCompl:

; 23838:     }
; 23839: }

  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c2 18 00	 ret	 24			; 00000018H
_IoSetCompletionRoutine@24 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@ DB 'Irp'
	DB	'->CurrentLocation > 0', 00H			;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _IoGetNextIrpStackLocation@4
_TEXT	SEGMENT
tv71 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoGetNextIrpStackLocation@4 PROC			; COMDAT

; 23479: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 23480:     ASSERT(Irp->CurrentLocation > 0);

  00006	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00009	0f be 48 23	 movsx	 ecx, BYTE PTR [eax+35]
  0000d	85 c9		 test	 ecx, ecx
  0000f	7f 20		 jg	 SHORT $LN3@IoGetNextI
  00011	6a 00		 push	 0
  00013	68 b8 5b 00 00	 push	 23480			; 00005bb8H
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
  0002f	eb 07		 jmp	 SHORT $LN4@IoGetNextI
$LN3@IoGetNextI:
  00031	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
$LN4@IoGetNextI:

; 23481: 
; 23482:     return ((Irp)->Tail.Overlay.CurrentStackLocation - 1 );

  00038	8b 55 08	 mov	 edx, DWORD PTR _Irp$[ebp]
  0003b	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  0003e	83 e8 24	 sub	 eax, 36			; 00000024H

; 23483: }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
_IoGetNextIrpStackLocation@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _IoCopyCurrentIrpStackLocationToNext@4
_TEXT	SEGMENT
_irpSp$ = -8						; size = 4
_nextIrpSp$ = -4					; size = 4
_Irp$ = 8						; size = 4
_IoCopyCurrentIrpStackLocationToNext@4 PROC		; COMDAT

; 23912: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8
  00008	56		 push	 esi
  00009	57		 push	 edi

; 23913:     PIO_STACK_LOCATION irpSp;
; 23914:     PIO_STACK_LOCATION nextIrpSp;
; 23915:     irpSp = IoGetCurrentIrpStackLocation(Irp);

  0000a	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 _IoGetCurrentIrpStackLocation@4
  00013	89 45 f8	 mov	 DWORD PTR _irpSp$[ebp], eax

; 23916:     nextIrpSp = IoGetNextIrpStackLocation(Irp);

  00016	8b 4d 08	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 _IoGetNextIrpStackLocation@4
  0001f	89 45 fc	 mov	 DWORD PTR _nextIrpSp$[ebp], eax

; 23917:     RtlCopyMemory( nextIrpSp, irpSp, FIELD_OFFSET(IO_STACK_LOCATION, CompletionRoutine));

  00022	b9 07 00 00 00	 mov	 ecx, 7
  00027	8b 75 f8	 mov	 esi, DWORD PTR _irpSp$[ebp]
  0002a	8b 7d fc	 mov	 edi, DWORD PTR _nextIrpSp$[ebp]
  0002d	f3 a5		 rep movsd

; 23918:     nextIrpSp->Control = 0;

  0002f	8b 55 fc	 mov	 edx, DWORD PTR _nextIrpSp$[ebp]
  00032	c6 42 03 00	 mov	 BYTE PTR [edx+3], 0

; 23919: }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
_IoCopyCurrentIrpStackLocationToNext@4 ENDP
_TEXT	ENDS
PUBLIC	_IoMarkIrpPending@4
; Function compile flags: /Odtp
; File c:\home\public\desktop\projects\ciphershed.build\src\driver\volumefilter.c
;	COMDAT _OnDeviceUsageNotificationCompleted@12
_TEXT	SEGMENT
_filterDeviceObject$ = 8				; size = 4
_Irp$ = 12						; size = 4
_Extension$ = 16					; size = 4
_OnDeviceUsageNotificationCompleted@12 PROC		; COMDAT

; 95   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 96   : 	if (Irp->PendingReturned)

  00005	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00008	0f b6 48 21	 movzx	 ecx, BYTE PTR [eax+33]
  0000c	85 c9		 test	 ecx, ecx
  0000e	74 09		 je	 SHORT $LN2@OnDeviceUs

; 97   : 		IoMarkIrpPending (Irp);

  00010	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  00013	52		 push	 edx
  00014	e8 00 00 00 00	 call	 _IoMarkIrpPending@4
$LN2@OnDeviceUs:

; 98   : 
; 99   : 	if (!(Extension->LowerDeviceObject->Flags & DO_POWER_PAGABLE))

  00019	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  0001c	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0001f	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00022	81 e2 00 20 00
	00		 and	 edx, 8192		; 00002000H
  00028	75 12		 jne	 SHORT $LN1@OnDeviceUs

; 100  : 		filterDeviceObject->Flags &= ~DO_POWER_PAGABLE;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _filterDeviceObject$[ebp]
  0002d	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00030	81 e1 ff df ff
	ff		 and	 ecx, -8193		; ffffdfffH
  00036	8b 55 08	 mov	 edx, DWORD PTR _filterDeviceObject$[ebp]
  00039	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx
$LN1@OnDeviceUs:

; 101  : 
; 102  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  0003c	6a 58		 push	 88			; 00000058H
  0003e	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00041	50		 push	 eax
  00042	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00045	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  0004b	51		 push	 ecx
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 103  : 	return STATUS_CONTINUE_COMPLETION;

  00052	33 c0		 xor	 eax, eax

; 104  : }

  00054	5d		 pop	 ebp
  00055	c2 0c 00	 ret	 12			; 0000000cH
_OnDeviceUsageNotificationCompleted@12 ENDP
; Function compile flags: /Odtp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT _IoMarkIrpPending@4
_TEXT	SEGMENT
tv67 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoMarkIrpPending@4 PROC				; COMDAT

; 23667: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 23668:     IoGetCurrentIrpStackLocation( (Irp) )->Control |= SL_PENDING_RETURNED;

  00006	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _IoGetCurrentIrpStackLocation@4
  0000f	83 c0 03	 add	 eax, 3
  00012	89 45 fc	 mov	 DWORD PTR tv67[ebp], eax
  00015	8b 4d fc	 mov	 ecx, DWORD PTR tv67[ebp]
  00018	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0001b	83 ca 01	 or	 edx, 1
  0001e	8b 45 fc	 mov	 eax, DWORD PTR tv67[ebp]
  00021	88 10		 mov	 BYTE PTR [eax], dl

; 23669: }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
_IoMarkIrpPending@4 ENDP
; Function compile flags: /Odtp
; File c:\home\public\desktop\projects\ciphershed.build\src\driver\volumefilter.c
_TEXT	ENDS
;	COMDAT _OnStartDeviceCompleted@12
_TEXT	SEGMENT
_filterDeviceObject$ = 8				; size = 4
_Irp$ = 12						; size = 4
_Extension$ = 16					; size = 4
_OnStartDeviceCompleted@12 PROC				; COMDAT

; 108  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 109  : 	if (Irp->PendingReturned)

  00005	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00008	0f b6 48 21	 movzx	 ecx, BYTE PTR [eax+33]
  0000c	85 c9		 test	 ecx, ecx
  0000e	74 09		 je	 SHORT $LN2@OnStartDev

; 110  : 		IoMarkIrpPending (Irp);

  00010	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  00013	52		 push	 edx
  00014	e8 00 00 00 00	 call	 _IoMarkIrpPending@4
$LN2@OnStartDev:

; 111  : 
; 112  : 	if (Extension->LowerDeviceObject->Characteristics & FILE_REMOVABLE_MEDIA)

  00019	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  0001c	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0001f	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00022	83 e2 01	 and	 edx, 1
  00025	74 0f		 je	 SHORT $LN1@OnStartDev

; 113  : 		filterDeviceObject->Characteristics |= FILE_REMOVABLE_MEDIA;

  00027	8b 45 08	 mov	 eax, DWORD PTR _filterDeviceObject$[ebp]
  0002a	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0002d	83 c9 01	 or	 ecx, 1
  00030	8b 55 08	 mov	 edx, DWORD PTR _filterDeviceObject$[ebp]
  00033	89 4a 20	 mov	 DWORD PTR [edx+32], ecx
$LN1@OnStartDev:

; 114  : 
; 115  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00036	6a 58		 push	 88			; 00000058H
  00038	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0003f	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  00045	51		 push	 ecx
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 116  : 	return STATUS_CONTINUE_COMPLETION;

  0004c	33 c0		 xor	 eax, eax

; 117  : }

  0004e	5d		 pop	 ebp
  0004f	c2 0c 00	 ret	 12			; 0000000cH
_OnStartDeviceCompleted@12 ENDP
_TEXT	ENDS
EXTRN	__imp__PoCallDriver@8:PROC
EXTRN	__imp__PoStartNextPowerIrp@4:PROC
; Function compile flags: /Odtp
;	COMDAT _DispatchPower@16
_TEXT	SEGMENT
_status$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_Extension$ = 16					; size = 4
_irpSp$ = 20						; size = 4
_DispatchPower@16 PROC					; COMDAT

; 245  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 246  : 	NTSTATUS status;
; 247  : 	PoStartNextPowerIrp (Irp);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoStartNextPowerIrp@4

; 248  : 
; 249  : 	status = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00010	6a 58		 push	 88			; 00000058H
  00012	68 f9 00 00 00	 push	 249			; 000000f9H
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@KFIMJNPM@c?3?2home?2public?2desktop?2projects?2@FNODOBFM@
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  00023	81 c2 b8 00 00
	00		 add	 edx, 184		; 000000b8H
  00029	52		 push	 edx
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAcquireRemoveLockEx@20
  00030	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 250  : 	if (!NT_SUCCESS (status))

  00033	83 7d fc 00	 cmp	 DWORD PTR _status$[ebp], 0
  00037	7d 11		 jge	 SHORT $LN1@DispatchPo

; 251  : 		return TCCompleteIrp (Irp, status, 0);

  00039	6a 00		 push	 0
  0003b	8b 45 fc	 mov	 eax, DWORD PTR _status$[ebp]
  0003e	50		 push	 eax
  0003f	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00042	51		 push	 ecx
  00043	e8 00 00 00 00	 call	 _TCCompleteIrp@12
  00048	eb 36		 jmp	 SHORT $LN2@DispatchPo
$LN1@DispatchPo:

; 252  : 
; 253  : 	IoSkipCurrentIrpStackLocation (Irp);

  0004a	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  0004d	52		 push	 edx
  0004e	e8 00 00 00 00	 call	 _IoSkipCurrentIrpStackLocation@4

; 254  : 	status = PoCallDriver (Extension->LowerDeviceObject, Irp);

  00053	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00056	50		 push	 eax
  00057	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0005a	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0005d	52		 push	 edx
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoCallDriver@8
  00064	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 255  : 
; 256  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00067	6a 58		 push	 88			; 00000058H
  00069	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  0006c	50		 push	 eax
  0006d	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00070	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  00076	51		 push	 ecx
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 257  : 	return status;

  0007d	8b 45 fc	 mov	 eax, DWORD PTR _status$[ebp]
$LN2@DispatchPo:

; 258  : }

  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 10 00	 ret	 16			; 00000010H
_DispatchPower@16 ENDP
_TEXT	ENDS
END
