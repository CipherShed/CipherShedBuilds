; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\home\public\desktop\projects\ciphershed.build\src\common\crypto.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_05HJMENKNE@SHA?91?$AA@			; `string'
PUBLIC	??_C@_09HLDHDDJL@Whirlpool?$AA@			; `string'
PUBLIC	??_C@_07MEOJAOJE@SHA?9512?$AA@			; `string'
PUBLIC	??_C@_0L@PKFJAMAA@RIPEMD?9160?$AA@		; `string'
PUBLIC	??_C@_0L@NEGMAKNF@Triple?5DES?$AA@		; `string'
PUBLIC	??_C@_05LCFOLDPB@CAST5?$AA@			; `string'
PUBLIC	??_C@_08KOMAHJJD@Blowfish?$AA@			; `string'
PUBLIC	??_C@_07DABDIDEC@Twofish?$AA@			; `string'
PUBLIC	??_C@_07CCCAKGBN@Serpent?$AA@			; `string'
PUBLIC	??_C@_03BKNEFOAH@AES?$AA@			; `string'
_BSS	SEGMENT
_HwEncryptionDisabled DD 01H DUP (?)
?state@?1??IsAesHwCpuSupported@@9@9 DD 01H DUP (?)	; `IsAesHwCpuSupported'::`2'::state
?stateValid@?1??IsAesHwCpuSupported@@9@9 DD 01H DUP (?)	; `IsAesHwCpuSupported'::`2'::stateValid
_BSS	ENDS
;	COMDAT ??_C@_05HJMENKNE@SHA?91?$AA@
CONST	SEGMENT
??_C@_05HJMENKNE@SHA?91?$AA@ DB 'SHA-1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HLDHDDJL@Whirlpool?$AA@
CONST	SEGMENT
??_C@_09HLDHDDJL@Whirlpool?$AA@ DB 'Whirlpool', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07MEOJAOJE@SHA?9512?$AA@
CONST	SEGMENT
??_C@_07MEOJAOJE@SHA?9512?$AA@ DB 'SHA-512', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PKFJAMAA@RIPEMD?9160?$AA@
CONST	SEGMENT
??_C@_0L@PKFJAMAA@RIPEMD?9160?$AA@ DB 'RIPEMD-160', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
_Ciphers DD	01H
	DD	FLAT:??_C@_03BKNEFOAH@AES?$AA@
	DD	010H
	DD	020H
	DD	01e8H
	DD	02H
	DD	FLAT:??_C@_07CCCAKGBN@Serpent?$AA@
	DD	010H
	DD	020H
	DD	0230H
	DD	03H
	DD	FLAT:??_C@_07DABDIDEC@Twofish?$AA@
	DD	010H
	DD	020H
	DD	010b4H
	DD	04H
	DD	FLAT:??_C@_08KOMAHJJD@Blowfish?$AA@
	DD	08H
	DD	038H
	DD	01090H
	DD	05H
	DD	FLAT:??_C@_05LCFOLDPB@CAST5?$AA@
	DD	08H
	DD	010H
	DD	080H
	DD	06H
	DD	FLAT:??_C@_0L@NEGMAKNF@Triple?5DES?$AA@
	DD	08H
	DD	018H
	DD	0300H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
_EncryptionAlgorithms DD 00H
	DD	00H
	ORG $+8
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+8
	DD	00H
	DD	01H
	DD	00H
	ORG $+8
	DD	01H
	DD	02H
	DD	03H
	DD	00H
	ORG $+8
	DD	01H
	DD	02H
	DD	00H
	ORG $+8
	DD	01H
	DD	02H
	DD	03H
	DD	00H
	ORG $+8
	DD	01H
	DD	03H
	DD	00H
	ORG $+8
	DD	01H
	DD	02H
	DD	03H
	DD	00H
	ORG $+8
	DD	01H
	DD	03H
	DD	01H
	DD	00H
	ORG $+4
	DD	01H
	DD	02H
	DD	04H
	DD	00H
	ORG $+8
	DD	01H
	DD	02H
	DD	03H
	DD	01H
	DD	00H
	DD	01H
	DD	02H
	DD	04H
	DD	00H
	ORG $+8
	DD	01H
	DD	01H
	DD	02H
	DD	00H
	ORG $+4
	DD	01H
	DD	02H
	DD	04H
	DD	00H
	ORG $+8
	DD	01H
	DD	01H
	DD	03H
	DD	02H
	DD	00H
	DD	01H
	DD	02H
	DD	04H
	DD	00H
	ORG $+8
	DD	01H
	DD	02H
	DD	03H
	DD	00H
	ORG $+4
	DD	01H
	DD	02H
	DD	04H
	DD	00H
	ORG $+8
	DD	01H
	DD	04H
	DD	00H
	ORG $+8
	DD	02H
	DD	03H
	DD	00H
	DD	00H
	ORG $+8
	DD	00H
	DD	05H
	DD	00H
	ORG $+8
	DD	02H
	DD	03H
	DD	00H
	DD	00H
	ORG $+8
	DD	00H
	DD	06H
	DD	00H
	ORG $+8
	DD	02H
	DD	03H
	DD	00H
	DD	00H
	ORG $+8
	DD	00H
	DD	04H
	DD	01H
	DD	00H
	ORG $+4
	DD	05H
	DD	00H
	DD	00H
	DD	00H
	ORG $+8
	DD	00H
	DD	02H
	DD	04H
	DD	01H
	DD	00H
	DD	05H
	DD	00H
	DD	00H
	DD	00H
	ORG $+8
	DD	00H
	DD	00H
	DD	00H
	ORG $+8
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+8
	DD	00H
	ORG $+4
_Hashes	DD	01H
	DD	FLAT:??_C@_0L@PKFJAMAA@RIPEMD?9160?$AA@
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:??_C@_07MEOJAOJE@SHA?9512?$AA@
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:??_C@_09HLDHDDJL@Whirlpool?$AA@
	DD	00H
	DD	00H
	DD	04H
	DD	FLAT:??_C@_05HJMENKNE@SHA?91?$AA@
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
_DATA	ENDS
;	COMDAT ??_C@_0L@NEGMAKNF@Triple?5DES?$AA@
CONST	SEGMENT
??_C@_0L@NEGMAKNF@Triple?5DES?$AA@ DB 'Triple DES', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05LCFOLDPB@CAST5?$AA@
CONST	SEGMENT
??_C@_05LCFOLDPB@CAST5?$AA@ DB 'CAST5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KOMAHJJD@Blowfish?$AA@
CONST	SEGMENT
??_C@_08KOMAHJJD@Blowfish?$AA@ DB 'Blowfish', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07DABDIDEC@Twofish?$AA@
CONST	SEGMENT
??_C@_07DABDIDEC@Twofish?$AA@ DB 'Twofish', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CCCAKGBN@Serpent?$AA@
CONST	SEGMENT
??_C@_07CCCAKGBN@Serpent?$AA@ DB 'Serpent', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BKNEFOAH@AES?$AA@
CONST	SEGMENT
??_C@_03BKNEFOAH@AES?$AA@ DB 'AES', 00H			; `string'
CONST	ENDS
PUBLIC	_CipherGetKeySize@4
PUBLIC	_CipherInit@12
EXTRN	_TripleDesSetKey@12:PROC
EXTRN	_Cast5SetKey@12:PROC
EXTRN	_BlowfishSetKey@12:PROC
EXTRN	_twofish_set_key@12:PROC
EXTRN	_serpent_set_key@12:PROC
EXTRN	_aes_decrypt_key256@8:PROC
EXTRN	_aes_encrypt_key256@8:PROC
; Function compile flags: /Odtp
; File c:\home\public\desktop\projects\ciphershed.build\src\common\crypto.c
;	COMDAT _CipherInit@12
_TEXT	SEGMENT
tv216 = -32						; size = 8
tv200 = -24						; size = 8
tv184 = -16						; size = 8
tv64 = -8						; size = 4
_retVal$ = -4						; size = 4
_cipher$ = 8						; size = 4
_key$ = 12						; size = 4
_ks$ = 16						; size = 4
_CipherInit@12 PROC					; COMDAT

; 115  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 20	 sub	 esp, 32			; 00000020H

; 116  : 	int retVal = ERR_SUCCESS;

  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _retVal$[ebp], 0

; 117  : 
; 118  : 	switch (cipher)

  0000f	8b 45 08	 mov	 eax, DWORD PTR _cipher$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR tv64[ebp], eax
  00015	8b 4d f8	 mov	 ecx, DWORD PTR tv64[ebp]
  00018	83 e9 01	 sub	 ecx, 1
  0001b	89 4d f8	 mov	 DWORD PTR tv64[ebp], ecx
  0001e	83 7d f8 05	 cmp	 DWORD PTR tv64[ebp], 5
  00022	0f 87 57 01 00
	00		 ja	 $LN1@CipherInit
  00028	8b 55 f8	 mov	 edx, DWORD PTR tv64[ebp]
  0002b	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN16@CipherInit[edx*4]
$LN11@CipherInit:

; 119  : 	{
; 120  : 	case AES:
; 121  : #ifndef TC_WINDOWS_BOOT
; 122  : 		if (aes_encrypt_key256 (key, (aes_encrypt_ctx *) ks) != EXIT_SUCCESS)

  00032	8b 45 10	 mov	 eax, DWORD PTR _ks$[ebp]
  00035	50		 push	 eax
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR _key$[ebp]
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 _aes_encrypt_key256@8
  0003f	85 c0		 test	 eax, eax
  00041	74 0a		 je	 SHORT $LN10@CipherInit

; 123  : 			return ERR_CIPHER_INIT_FAILURE;

  00043	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  00048	e9 3c 01 00 00	 jmp	 $LN14@CipherInit
$LN10@CipherInit:

; 124  : 
; 125  : 		if (aes_decrypt_key256 (key, (aes_decrypt_ctx *) (ks + sizeof(aes_encrypt_ctx))) != EXIT_SUCCESS)

  0004d	8b 55 10	 mov	 edx, DWORD PTR _ks$[ebp]
  00050	81 c2 f4 00 00
	00		 add	 edx, 244		; 000000f4H
  00056	52		 push	 edx
  00057	8b 45 0c	 mov	 eax, DWORD PTR _key$[ebp]
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 _aes_decrypt_key256@8
  00060	85 c0		 test	 eax, eax
  00062	74 0a		 je	 SHORT $LN9@CipherInit

; 126  : 			return ERR_CIPHER_INIT_FAILURE;

  00064	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  00069	e9 1b 01 00 00	 jmp	 $LN14@CipherInit
$LN9@CipherInit:

; 127  : #else
; 128  : 		if (aes_set_key (key, (length_type) CipherGetKeySize(AES), (aes_context *) ks) != 0)
; 129  : 			return ERR_CIPHER_INIT_FAILURE;
; 130  : #endif
; 131  : 		break;

  0006e	e9 13 01 00 00	 jmp	 $LN12@CipherInit
$LN8@CipherInit:

; 132  : 
; 133  : 	case SERPENT:
; 134  : 		serpent_set_key (key, CipherGetKeySize(SERPENT) * 8, ks);

  00073	8b 4d 10	 mov	 ecx, DWORD PTR _ks$[ebp]
  00076	51		 push	 ecx
  00077	6a 02		 push	 2
  00079	e8 00 00 00 00	 call	 _CipherGetKeySize@4
  0007e	c1 e0 03	 shl	 eax, 3
  00081	50		 push	 eax
  00082	8b 55 0c	 mov	 edx, DWORD PTR _key$[ebp]
  00085	52		 push	 edx
  00086	e8 00 00 00 00	 call	 _serpent_set_key@12

; 135  : 		break;

  0008b	e9 f6 00 00 00	 jmp	 $LN12@CipherInit
$LN7@CipherInit:

; 136  : 		
; 137  : 	case TWOFISH:
; 138  : 		twofish_set_key ((TwofishInstance *)ks, (const u4byte *)key, CipherGetKeySize(TWOFISH) * 8);

  00090	6a 03		 push	 3
  00092	e8 00 00 00 00	 call	 _CipherGetKeySize@4
  00097	c1 e0 03	 shl	 eax, 3
  0009a	50		 push	 eax
  0009b	8b 45 0c	 mov	 eax, DWORD PTR _key$[ebp]
  0009e	50		 push	 eax
  0009f	8b 4d 10	 mov	 ecx, DWORD PTR _ks$[ebp]
  000a2	51		 push	 ecx
  000a3	e8 00 00 00 00	 call	 _twofish_set_key@12

; 139  : 		break;

  000a8	e9 d9 00 00 00	 jmp	 $LN12@CipherInit
$LN6@CipherInit:

; 140  : 
; 141  : #ifndef TC_WINDOWS_BOOT
; 142  : 		
; 143  : 	case BLOWFISH:
; 144  : 		/* Deprecated/legacy */
; 145  : 		BlowfishSetKey ((BF_KEY *)ks, CipherGetKeySize(BLOWFISH), key);

  000ad	8b 55 0c	 mov	 edx, DWORD PTR _key$[ebp]
  000b0	52		 push	 edx
  000b1	6a 04		 push	 4
  000b3	e8 00 00 00 00	 call	 _CipherGetKeySize@4
  000b8	50		 push	 eax
  000b9	8b 45 10	 mov	 eax, DWORD PTR _ks$[ebp]
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 _BlowfishSetKey@12

; 146  : 		break;

  000c2	e9 bf 00 00 00	 jmp	 $LN12@CipherInit
$LN5@CipherInit:

; 147  : 
; 148  : 	case CAST:
; 149  : 		/* Deprecated/legacy */
; 150  : 		Cast5SetKey ((CAST_KEY *) ks, CipherGetKeySize(CAST), key);

  000c7	8b 4d 0c	 mov	 ecx, DWORD PTR _key$[ebp]
  000ca	51		 push	 ecx
  000cb	6a 05		 push	 5
  000cd	e8 00 00 00 00	 call	 _CipherGetKeySize@4
  000d2	50		 push	 eax
  000d3	8b 55 10	 mov	 edx, DWORD PTR _ks$[ebp]
  000d6	52		 push	 edx
  000d7	e8 00 00 00 00	 call	 _Cast5SetKey@12

; 151  : 		break;

  000dc	e9 a5 00 00 00	 jmp	 $LN12@CipherInit
$LN4@CipherInit:

; 152  : 
; 153  : 	case TRIPLEDES:
; 154  : 		/* Deprecated/legacy */
; 155  : 		TripleDesSetKey (key, CipherGetKeySize (TRIPLEDES), (TDES_KEY *) ks);

  000e1	8b 45 10	 mov	 eax, DWORD PTR _ks$[ebp]
  000e4	50		 push	 eax
  000e5	6a 06		 push	 6
  000e7	e8 00 00 00 00	 call	 _CipherGetKeySize@4
  000ec	50		 push	 eax
  000ed	8b 4d 0c	 mov	 ecx, DWORD PTR _key$[ebp]
  000f0	51		 push	 ecx
  000f1	e8 00 00 00 00	 call	 _TripleDesSetKey@12

; 156  : 
; 157  : 		// Verify whether all three DES keys are mutually different
; 158  : 		if (((*((__int64 *) key) ^ *((__int64 *) key+1)) & 0xFEFEFEFEFEFEFEFEULL) == 0
; 159  : 		|| ((*((__int64 *) key+1) ^ *((__int64 *) key+2)) & 0xFEFEFEFEFEFEFEFEULL) == 0
; 160  : 		|| ((*((__int64 *) key) ^ *((__int64 *) key+2)) & 0xFEFEFEFEFEFEFEFEULL) == 0)

  000f6	8b 55 0c	 mov	 edx, DWORD PTR _key$[ebp]
  000f9	8b 45 0c	 mov	 eax, DWORD PTR _key$[ebp]
  000fc	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000fe	33 48 08	 xor	 ecx, DWORD PTR [eax+8]
  00101	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00104	33 50 0c	 xor	 edx, DWORD PTR [eax+12]
  00107	81 e1 fe fe fe
	fe		 and	 ecx, -16843010		; fefefefeH
  0010d	81 e2 fe fe fe
	fe		 and	 edx, -16843010		; fefefefeH
  00113	89 4d f0	 mov	 DWORD PTR tv184[ebp], ecx
  00116	89 55 f4	 mov	 DWORD PTR tv184[ebp+4], edx
  00119	8b 45 f0	 mov	 eax, DWORD PTR tv184[ebp]
  0011c	0b 45 f4	 or	 eax, DWORD PTR tv184[ebp+4]
  0011f	74 55		 je	 SHORT $LN2@CipherInit
  00121	8b 4d 0c	 mov	 ecx, DWORD PTR _key$[ebp]
  00124	8b 55 0c	 mov	 edx, DWORD PTR _key$[ebp]
  00127	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0012a	33 42 10	 xor	 eax, DWORD PTR [edx+16]
  0012d	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00130	33 4a 14	 xor	 ecx, DWORD PTR [edx+20]
  00133	25 fe fe fe fe	 and	 eax, -16843010		; fefefefeH
  00138	81 e1 fe fe fe
	fe		 and	 ecx, -16843010		; fefefefeH
  0013e	89 45 e8	 mov	 DWORD PTR tv200[ebp], eax
  00141	89 4d ec	 mov	 DWORD PTR tv200[ebp+4], ecx
  00144	8b 55 e8	 mov	 edx, DWORD PTR tv200[ebp]
  00147	0b 55 ec	 or	 edx, DWORD PTR tv200[ebp+4]
  0014a	74 2a		 je	 SHORT $LN2@CipherInit
  0014c	8b 45 0c	 mov	 eax, DWORD PTR _key$[ebp]
  0014f	8b 4d 0c	 mov	 ecx, DWORD PTR _key$[ebp]
  00152	8b 10		 mov	 edx, DWORD PTR [eax]
  00154	33 51 10	 xor	 edx, DWORD PTR [ecx+16]
  00157	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0015a	33 41 14	 xor	 eax, DWORD PTR [ecx+20]
  0015d	81 e2 fe fe fe
	fe		 and	 edx, -16843010		; fefefefeH
  00163	25 fe fe fe fe	 and	 eax, -16843010		; fefefefeH
  00168	89 55 e0	 mov	 DWORD PTR tv216[ebp], edx
  0016b	89 45 e4	 mov	 DWORD PTR tv216[ebp+4], eax
  0016e	8b 4d e0	 mov	 ecx, DWORD PTR tv216[ebp]
  00171	0b 4d e4	 or	 ecx, DWORD PTR tv216[ebp+4]
  00174	75 07		 jne	 SHORT $LN3@CipherInit
$LN2@CipherInit:

; 161  : 			retVal = ERR_CIPHER_INIT_WEAK_KEY;		// Non-fatal error

  00176	c7 45 fc 12 00
	00 00		 mov	 DWORD PTR _retVal$[ebp], 18 ; 00000012H
$LN3@CipherInit:

; 162  : 
; 163  : 		break;

  0017d	eb 07		 jmp	 SHORT $LN12@CipherInit
$LN1@CipherInit:

; 164  : 
; 165  : #endif	// TC_WINDOWS_BOOT
; 166  : 
; 167  : 	default:
; 168  : 		// Unknown/wrong cipher ID
; 169  : 		return ERR_CIPHER_INIT_FAILURE;

  0017f	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  00184	eb 03		 jmp	 SHORT $LN14@CipherInit
$LN12@CipherInit:

; 170  : 	}
; 171  : 
; 172  : 	return retVal;

  00186	8b 45 fc	 mov	 eax, DWORD PTR _retVal$[ebp]
$LN14@CipherInit:

; 173  : }

  00189	8b e5		 mov	 esp, ebp
  0018b	5d		 pop	 ebp
  0018c	c2 0c 00	 ret	 12			; 0000000cH
  0018f	90		 npad	 1
$LN16@CipherInit:
  00190	00 00 00 00	 DD	 $LN11@CipherInit
  00194	00 00 00 00	 DD	 $LN8@CipherInit
  00198	00 00 00 00	 DD	 $LN7@CipherInit
  0019c	00 00 00 00	 DD	 $LN6@CipherInit
  001a0	00 00 00 00	 DD	 $LN5@CipherInit
  001a4	00 00 00 00	 DD	 $LN4@CipherInit
_CipherInit@12 ENDP
_TEXT	ENDS
PUBLIC	_EncipherBlock@12
EXTRN	__imp__KeBugCheckEx@20:PROC
EXTRN	_TripleDesEncrypt@16:PROC
EXTRN	_Cast5Encrypt@12:PROC
EXTRN	_BlowfishEncryptLE@16:PROC
EXTRN	_serpent_encrypt@12:PROC
EXTRN	_twofish_encrypt@12:PROC
EXTRN	_aes_encrypt@12:PROC
; Function compile flags: /Odtp
;	COMDAT _EncipherBlock@12
_TEXT	SEGMENT
tv64 = -4						; size = 4
_cipher$ = 8						; size = 4
_data$ = 12						; size = 4
_ks$ = 16						; size = 4
_EncipherBlock@12 PROC					; COMDAT

; 176  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 177  : 	switch (cipher)

  00006	8b 45 08	 mov	 eax, DWORD PTR _cipher$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR tv64[ebp], eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR tv64[ebp]
  0000f	83 e9 01	 sub	 ecx, 1
  00012	89 4d fc	 mov	 DWORD PTR tv64[ebp], ecx
  00015	83 7d fc 05	 cmp	 DWORD PTR tv64[ebp], 5
  00019	0f 87 80 00 00
	00		 ja	 $LN1@EncipherBl
  0001f	8b 55 fc	 mov	 edx, DWORD PTR tv64[ebp]
  00022	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN12@EncipherBl[edx*4]
$LN7@EncipherBl:

; 178  : 	{
; 179  : 	case AES:	
; 180  : 		// In 32-bit kernel mode, due to KeSaveFloatingPointState() overhead, AES instructions can be used only when processing the whole data unit.
; 181  : #if (defined (_WIN64) || !defined (TC_WINDOWS_DRIVER)) && !defined (TC_WINDOWS_BOOT)
; 182  : 		if (IsAesHwCpuSupported())
; 183  : 			aes_hw_cpu_encrypt (ks, data);
; 184  : 		else
; 185  : #endif
; 186  : 			aes_encrypt (data, data, ks);

  00029	8b 45 10	 mov	 eax, DWORD PTR _ks$[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00030	51		 push	 ecx
  00031	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 _aes_encrypt@12

; 187  : 		break;

  0003a	eb 79		 jmp	 SHORT $LN11@EncipherBl
$LN6@EncipherBl:

; 188  : 
; 189  : 	case TWOFISH:		twofish_encrypt (ks, data, data); break;

  0003c	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0003f	50		 push	 eax
  00040	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00043	51		 push	 ecx
  00044	8b 55 10	 mov	 edx, DWORD PTR _ks$[ebp]
  00047	52		 push	 edx
  00048	e8 00 00 00 00	 call	 _twofish_encrypt@12
  0004d	eb 66		 jmp	 SHORT $LN11@EncipherBl
$LN5@EncipherBl:

; 190  : 	case SERPENT:		serpent_encrypt (data, data, ks); break;

  0004f	8b 45 10	 mov	 eax, DWORD PTR _ks$[ebp]
  00052	50		 push	 eax
  00053	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00056	51		 push	 ecx
  00057	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  0005a	52		 push	 edx
  0005b	e8 00 00 00 00	 call	 _serpent_encrypt@12
  00060	eb 53		 jmp	 SHORT $LN11@EncipherBl
$LN4@EncipherBl:

; 191  : #ifndef TC_WINDOWS_BOOT
; 192  : 	case BLOWFISH:		BlowfishEncryptLE (data, data, ks, 1); break;	// Deprecated/legacy

  00062	6a 01		 push	 1
  00064	8b 45 10	 mov	 eax, DWORD PTR _ks$[ebp]
  00067	50		 push	 eax
  00068	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0006b	51		 push	 ecx
  0006c	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  0006f	52		 push	 edx
  00070	e8 00 00 00 00	 call	 _BlowfishEncryptLE@16
  00075	eb 3e		 jmp	 SHORT $LN11@EncipherBl
$LN3@EncipherBl:

; 193  : 	case CAST:			Cast5Encrypt (data, data, ks); break;			// Deprecated/legacy

  00077	8b 45 10	 mov	 eax, DWORD PTR _ks$[ebp]
  0007a	50		 push	 eax
  0007b	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  00082	52		 push	 edx
  00083	e8 00 00 00 00	 call	 _Cast5Encrypt@12
  00088	eb 2b		 jmp	 SHORT $LN11@EncipherBl
$LN2@EncipherBl:

; 194  : 	case TRIPLEDES:		TripleDesEncrypt (data, data, ks, 1); break;	// Deprecated/legacy

  0008a	6a 01		 push	 1
  0008c	8b 45 10	 mov	 eax, DWORD PTR _ks$[ebp]
  0008f	50		 push	 eax
  00090	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00093	51		 push	 ecx
  00094	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  00097	52		 push	 edx
  00098	e8 00 00 00 00	 call	 _TripleDesEncrypt@16
  0009d	eb 16		 jmp	 SHORT $LN11@EncipherBl
$LN1@EncipherBl:

; 195  : #endif
; 196  : 	default:			TC_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID

  0009f	68 43 54 00 00	 push	 21571			; 00005443H
  000a4	6a 00		 push	 0
  000a6	6a 00		 push	 0
  000a8	68 c4 00 00 00	 push	 196			; 000000c4H
  000ad	6a 29		 push	 41			; 00000029H
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN11@EncipherBl:

; 197  : 	}
; 198  : }

  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c2 0c 00	 ret	 12			; 0000000cH
  000bb	90		 npad	 1
$LN12@EncipherBl:
  000bc	00 00 00 00	 DD	 $LN7@EncipherBl
  000c0	00 00 00 00	 DD	 $LN5@EncipherBl
  000c4	00 00 00 00	 DD	 $LN6@EncipherBl
  000c8	00 00 00 00	 DD	 $LN4@EncipherBl
  000cc	00 00 00 00	 DD	 $LN3@EncipherBl
  000d0	00 00 00 00	 DD	 $LN2@EncipherBl
_EncipherBlock@12 ENDP
_TEXT	ENDS
PUBLIC	_CipherGetBlockSize@4
PUBLIC	_IsAesHwCpuSupported@0
PUBLIC	_EncipherBlocks@16
EXTRN	__imp__KeRestoreFloatingPointState@4:PROC
EXTRN	_aes_hw_cpu_encrypt_32_blocks@8:PROC
EXTRN	__imp__KeSaveFloatingPointState@4:PROC
; Function compile flags: /Odtp
;	COMDAT _EncipherBlocks@16
_TEXT	SEGMENT
_blockSize$27050 = -40					; size = 4
_data$ = -36						; size = 4
_floatingPointState$ = -32				; size = 32
_cipher$ = 8						; size = 4
_dataPtr$ = 12						; size = 4
_ks$ = 16						; size = 4
_blockCount$ = 20					; size = 4
_EncipherBlocks@16 PROC					; COMDAT

; 203  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 28	 sub	 esp, 40			; 00000028H

; 204  : 	byte *data = dataPtr;

  00008	8b 45 0c	 mov	 eax, DWORD PTR _dataPtr$[ebp]
  0000b	89 45 dc	 mov	 DWORD PTR _data$[ebp], eax

; 205  : #if defined (TC_WINDOWS_DRIVER) && !defined (_WIN64)
; 206  : 	KFLOATING_SAVE floatingPointState;
; 207  : #endif
; 208  : 
; 209  : 	if (cipher == AES
; 210  : 		&& (blockCount & (32 - 1)) == 0
; 211  : 		&& IsAesHwCpuSupported()
; 212  : #if defined (TC_WINDOWS_DRIVER) && !defined (_WIN64)
; 213  : 		&& NT_SUCCESS (KeSaveFloatingPointState (&floatingPointState))
; 214  : #endif
; 215  : 		)

  0000e	83 7d 08 01	 cmp	 DWORD PTR _cipher$[ebp], 1
  00012	75 55		 jne	 SHORT $LN6@EncipherBl@2
  00014	8b 4d 14	 mov	 ecx, DWORD PTR _blockCount$[ebp]
  00017	83 e1 1f	 and	 ecx, 31			; 0000001fH
  0001a	75 4d		 jne	 SHORT $LN6@EncipherBl@2
  0001c	e8 00 00 00 00	 call	 _IsAesHwCpuSupported@0
  00021	85 c0		 test	 eax, eax
  00023	74 44		 je	 SHORT $LN6@EncipherBl@2
  00025	8d 55 e0	 lea	 edx, DWORD PTR _floatingPointState$[ebp]
  00028	52		 push	 edx
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSaveFloatingPointState@4
  0002f	85 c0		 test	 eax, eax
  00031	7c 36		 jl	 SHORT $LN6@EncipherBl@2
$LN5@EncipherBl@2:

; 216  : 	{
; 217  : 		while (blockCount > 0)

  00033	83 7d 14 00	 cmp	 DWORD PTR _blockCount$[ebp], 0
  00037	76 24		 jbe	 SHORT $LN4@EncipherBl@2

; 218  : 		{
; 219  : 			aes_hw_cpu_encrypt_32_blocks (ks, data);

  00039	8b 45 dc	 mov	 eax, DWORD PTR _data$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d 10	 mov	 ecx, DWORD PTR _ks$[ebp]
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 _aes_hw_cpu_encrypt_32_blocks@8

; 220  : 
; 221  : 			data += 32 * 16;

  00046	8b 55 dc	 mov	 edx, DWORD PTR _data$[ebp]
  00049	81 c2 00 02 00
	00		 add	 edx, 512		; 00000200H
  0004f	89 55 dc	 mov	 DWORD PTR _data$[ebp], edx

; 222  : 			blockCount -= 32;

  00052	8b 45 14	 mov	 eax, DWORD PTR _blockCount$[ebp]
  00055	83 e8 20	 sub	 eax, 32			; 00000020H
  00058	89 45 14	 mov	 DWORD PTR _blockCount$[ebp], eax

; 223  : 		}

  0005b	eb d6		 jmp	 SHORT $LN5@EncipherBl@2
$LN4@EncipherBl@2:

; 224  : 
; 225  : #if defined (TC_WINDOWS_DRIVER) && !defined (_WIN64)
; 226  : 		KeRestoreFloatingPointState (&floatingPointState);

  0005d	8d 4d e0	 lea	 ecx, DWORD PTR _floatingPointState$[ebp]
  00060	51		 push	 ecx
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeRestoreFloatingPointState@4

; 227  : #endif
; 228  : 	}
; 229  : 	else

  00067	eb 38		 jmp	 SHORT $LN7@EncipherBl@2
$LN6@EncipherBl@2:

; 230  : 	{
; 231  : 		size_t blockSize = CipherGetBlockSize (cipher);

  00069	8b 55 08	 mov	 edx, DWORD PTR _cipher$[ebp]
  0006c	52		 push	 edx
  0006d	e8 00 00 00 00	 call	 _CipherGetBlockSize@4
  00072	89 45 d8	 mov	 DWORD PTR _blockSize$27050[ebp], eax
$LN2@EncipherBl@2:

; 232  : 		while (blockCount-- > 0)

  00075	8b 45 14	 mov	 eax, DWORD PTR _blockCount$[ebp]
  00078	8b 4d 14	 mov	 ecx, DWORD PTR _blockCount$[ebp]
  0007b	83 e9 01	 sub	 ecx, 1
  0007e	89 4d 14	 mov	 DWORD PTR _blockCount$[ebp], ecx
  00081	85 c0		 test	 eax, eax
  00083	76 1c		 jbe	 SHORT $LN7@EncipherBl@2

; 233  : 		{
; 234  : 			EncipherBlock (cipher, data, ks);

  00085	8b 55 10	 mov	 edx, DWORD PTR _ks$[ebp]
  00088	52		 push	 edx
  00089	8b 45 dc	 mov	 eax, DWORD PTR _data$[ebp]
  0008c	50		 push	 eax
  0008d	8b 4d 08	 mov	 ecx, DWORD PTR _cipher$[ebp]
  00090	51		 push	 ecx
  00091	e8 00 00 00 00	 call	 _EncipherBlock@12

; 235  : 			data += blockSize;

  00096	8b 55 dc	 mov	 edx, DWORD PTR _data$[ebp]
  00099	03 55 d8	 add	 edx, DWORD PTR _blockSize$27050[ebp]
  0009c	89 55 dc	 mov	 DWORD PTR _data$[ebp], edx

; 236  : 		}

  0009f	eb d4		 jmp	 SHORT $LN2@EncipherBl@2
$LN7@EncipherBl@2:

; 237  : 	}
; 238  : }

  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c2 10 00	 ret	 16			; 00000010H
_EncipherBlocks@16 ENDP
_TEXT	ENDS
PUBLIC	_DecipherBlock@12
EXTRN	_Cast5Decrypt@12:PROC
EXTRN	_aes_decrypt@12:PROC
EXTRN	_twofish_decrypt@12:PROC
EXTRN	_serpent_decrypt@12:PROC
; Function compile flags: /Odtp
;	COMDAT _DecipherBlock@12
_TEXT	SEGMENT
tv64 = -4						; size = 4
_cipher$ = 8						; size = 4
_data$ = 12						; size = 4
_ks$ = 16						; size = 4
_DecipherBlock@12 PROC					; COMDAT

; 243  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 244  : 	switch (cipher)

  00006	8b 45 08	 mov	 eax, DWORD PTR _cipher$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR tv64[ebp], eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR tv64[ebp]
  0000f	83 e9 01	 sub	 ecx, 1
  00012	89 4d fc	 mov	 DWORD PTR tv64[ebp], ecx
  00015	83 7d fc 05	 cmp	 DWORD PTR tv64[ebp], 5
  00019	0f 87 85 00 00
	00		 ja	 $LN1@DecipherBl
  0001f	8b 55 fc	 mov	 edx, DWORD PTR tv64[ebp]
  00022	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN12@DecipherBl[edx*4]
$LN7@DecipherBl:

; 245  : 	{
; 246  : 	case SERPENT:	serpent_decrypt (data, data, ks); break;

  00029	8b 45 10	 mov	 eax, DWORD PTR _ks$[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00030	51		 push	 ecx
  00031	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 _serpent_decrypt@12
  0003a	eb 7e		 jmp	 SHORT $LN11@DecipherBl
$LN6@DecipherBl:

; 247  : 	case TWOFISH:	twofish_decrypt (ks, data, data); break;

  0003c	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0003f	50		 push	 eax
  00040	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00043	51		 push	 ecx
  00044	8b 55 10	 mov	 edx, DWORD PTR _ks$[ebp]
  00047	52		 push	 edx
  00048	e8 00 00 00 00	 call	 _twofish_decrypt@12
  0004d	eb 6b		 jmp	 SHORT $LN11@DecipherBl
$LN5@DecipherBl:

; 248  : #ifndef TC_WINDOWS_BOOT
; 249  : 
; 250  : 	case AES:
; 251  : #if defined (_WIN64) || !defined (TC_WINDOWS_DRIVER)
; 252  : 		if (IsAesHwCpuSupported())
; 253  : 			aes_hw_cpu_decrypt ((byte *) ks + sizeof (aes_encrypt_ctx), data);
; 254  : 		else
; 255  : #endif
; 256  : 			aes_decrypt (data, data, (void *) ((char *) ks + sizeof(aes_encrypt_ctx)));

  0004f	8b 45 10	 mov	 eax, DWORD PTR _ks$[ebp]
  00052	05 f4 00 00 00	 add	 eax, 244		; 000000f4H
  00057	50		 push	 eax
  00058	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0005b	51		 push	 ecx
  0005c	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  0005f	52		 push	 edx
  00060	e8 00 00 00 00	 call	 _aes_decrypt@12

; 257  : 		break;

  00065	eb 53		 jmp	 SHORT $LN11@DecipherBl
$LN4@DecipherBl:

; 258  : 
; 259  : 	case BLOWFISH:	BlowfishEncryptLE (data, data, ks, 0); break;	// Deprecated/legacy

  00067	6a 00		 push	 0
  00069	8b 45 10	 mov	 eax, DWORD PTR _ks$[ebp]
  0006c	50		 push	 eax
  0006d	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00070	51		 push	 ecx
  00071	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  00074	52		 push	 edx
  00075	e8 00 00 00 00	 call	 _BlowfishEncryptLE@16
  0007a	eb 3e		 jmp	 SHORT $LN11@DecipherBl
$LN3@DecipherBl:

; 260  : 	case CAST:		Cast5Decrypt (data, data, ks); break;			// Deprecated/legacy

  0007c	8b 45 10	 mov	 eax, DWORD PTR _ks$[ebp]
  0007f	50		 push	 eax
  00080	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00083	51		 push	 ecx
  00084	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  00087	52		 push	 edx
  00088	e8 00 00 00 00	 call	 _Cast5Decrypt@12
  0008d	eb 2b		 jmp	 SHORT $LN11@DecipherBl
$LN2@DecipherBl:

; 261  : 	case TRIPLEDES:	TripleDesEncrypt (data, data, ks, 0); break;	// Deprecated/legacy

  0008f	6a 00		 push	 0
  00091	8b 45 10	 mov	 eax, DWORD PTR _ks$[ebp]
  00094	50		 push	 eax
  00095	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00098	51		 push	 ecx
  00099	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  0009c	52		 push	 edx
  0009d	e8 00 00 00 00	 call	 _TripleDesEncrypt@16
  000a2	eb 16		 jmp	 SHORT $LN11@DecipherBl
$LN1@DecipherBl:

; 262  : #else
; 263  : 	case AES:		aes_decrypt (data, data, ks); break;
; 264  : #endif
; 265  : 	default:		TC_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID

  000a4	68 43 54 00 00	 push	 21571			; 00005443H
  000a9	6a 00		 push	 0
  000ab	6a 00		 push	 0
  000ad	68 09 01 00 00	 push	 265			; 00000109H
  000b2	6a 29		 push	 41			; 00000029H
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN11@DecipherBl:

; 266  : 	}
; 267  : }

  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c2 0c 00	 ret	 12			; 0000000cH
$LN12@DecipherBl:
  000c0	00 00 00 00	 DD	 $LN5@DecipherBl
  000c4	00 00 00 00	 DD	 $LN7@DecipherBl
  000c8	00 00 00 00	 DD	 $LN6@DecipherBl
  000cc	00 00 00 00	 DD	 $LN4@DecipherBl
  000d0	00 00 00 00	 DD	 $LN3@DecipherBl
  000d4	00 00 00 00	 DD	 $LN2@DecipherBl
_DecipherBlock@12 ENDP
_TEXT	ENDS
PUBLIC	_DecipherBlocks@16
EXTRN	_aes_hw_cpu_decrypt_32_blocks@8:PROC
; Function compile flags: /Odtp
;	COMDAT _DecipherBlocks@16
_TEXT	SEGMENT
_blockSize$27095 = -40					; size = 4
_data$ = -36						; size = 4
_floatingPointState$ = -32				; size = 32
_cipher$ = 8						; size = 4
_dataPtr$ = 12						; size = 4
_ks$ = 16						; size = 4
_blockCount$ = 20					; size = 4
_DecipherBlocks@16 PROC					; COMDAT

; 272  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 28	 sub	 esp, 40			; 00000028H

; 273  : 	byte *data = dataPtr;

  00008	8b 45 0c	 mov	 eax, DWORD PTR _dataPtr$[ebp]
  0000b	89 45 dc	 mov	 DWORD PTR _data$[ebp], eax

; 274  : #if defined (TC_WINDOWS_DRIVER) && !defined (_WIN64)
; 275  : 	KFLOATING_SAVE floatingPointState;
; 276  : #endif
; 277  : 
; 278  : 	if (cipher == AES
; 279  : 		&& (blockCount & (32 - 1)) == 0
; 280  : 		&& IsAesHwCpuSupported()
; 281  : #if defined (TC_WINDOWS_DRIVER) && !defined (_WIN64)
; 282  : 		&& NT_SUCCESS (KeSaveFloatingPointState (&floatingPointState))
; 283  : #endif
; 284  : 		)

  0000e	83 7d 08 01	 cmp	 DWORD PTR _cipher$[ebp], 1
  00012	75 5b		 jne	 SHORT $LN6@DecipherBl@2
  00014	8b 4d 14	 mov	 ecx, DWORD PTR _blockCount$[ebp]
  00017	83 e1 1f	 and	 ecx, 31			; 0000001fH
  0001a	75 53		 jne	 SHORT $LN6@DecipherBl@2
  0001c	e8 00 00 00 00	 call	 _IsAesHwCpuSupported@0
  00021	85 c0		 test	 eax, eax
  00023	74 4a		 je	 SHORT $LN6@DecipherBl@2
  00025	8d 55 e0	 lea	 edx, DWORD PTR _floatingPointState$[ebp]
  00028	52		 push	 edx
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSaveFloatingPointState@4
  0002f	85 c0		 test	 eax, eax
  00031	7c 3c		 jl	 SHORT $LN6@DecipherBl@2
$LN5@DecipherBl@2:

; 285  : 	{
; 286  : 		while (blockCount > 0)

  00033	83 7d 14 00	 cmp	 DWORD PTR _blockCount$[ebp], 0
  00037	76 2a		 jbe	 SHORT $LN4@DecipherBl@2

; 287  : 		{
; 288  : 			aes_hw_cpu_decrypt_32_blocks ((byte *) ks + sizeof (aes_encrypt_ctx), data);

  00039	8b 45 dc	 mov	 eax, DWORD PTR _data$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d 10	 mov	 ecx, DWORD PTR _ks$[ebp]
  00040	81 c1 f4 00 00
	00		 add	 ecx, 244		; 000000f4H
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 _aes_hw_cpu_decrypt_32_blocks@8

; 289  : 
; 290  : 			data += 32 * 16;

  0004c	8b 55 dc	 mov	 edx, DWORD PTR _data$[ebp]
  0004f	81 c2 00 02 00
	00		 add	 edx, 512		; 00000200H
  00055	89 55 dc	 mov	 DWORD PTR _data$[ebp], edx

; 291  : 			blockCount -= 32;

  00058	8b 45 14	 mov	 eax, DWORD PTR _blockCount$[ebp]
  0005b	83 e8 20	 sub	 eax, 32			; 00000020H
  0005e	89 45 14	 mov	 DWORD PTR _blockCount$[ebp], eax

; 292  : 		}

  00061	eb d0		 jmp	 SHORT $LN5@DecipherBl@2
$LN4@DecipherBl@2:

; 293  : 
; 294  : #if defined (TC_WINDOWS_DRIVER) && !defined (_WIN64)
; 295  : 		KeRestoreFloatingPointState (&floatingPointState);

  00063	8d 4d e0	 lea	 ecx, DWORD PTR _floatingPointState$[ebp]
  00066	51		 push	 ecx
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeRestoreFloatingPointState@4

; 296  : #endif
; 297  : 	}
; 298  : 	else

  0006d	eb 38		 jmp	 SHORT $LN7@DecipherBl@2
$LN6@DecipherBl@2:

; 299  : 	{
; 300  : 		size_t blockSize = CipherGetBlockSize (cipher);

  0006f	8b 55 08	 mov	 edx, DWORD PTR _cipher$[ebp]
  00072	52		 push	 edx
  00073	e8 00 00 00 00	 call	 _CipherGetBlockSize@4
  00078	89 45 d8	 mov	 DWORD PTR _blockSize$27095[ebp], eax
$LN2@DecipherBl@2:

; 301  : 		while (blockCount-- > 0)

  0007b	8b 45 14	 mov	 eax, DWORD PTR _blockCount$[ebp]
  0007e	8b 4d 14	 mov	 ecx, DWORD PTR _blockCount$[ebp]
  00081	83 e9 01	 sub	 ecx, 1
  00084	89 4d 14	 mov	 DWORD PTR _blockCount$[ebp], ecx
  00087	85 c0		 test	 eax, eax
  00089	76 1c		 jbe	 SHORT $LN7@DecipherBl@2

; 302  : 		{
; 303  : 			DecipherBlock (cipher, data, ks);

  0008b	8b 55 10	 mov	 edx, DWORD PTR _ks$[ebp]
  0008e	52		 push	 edx
  0008f	8b 45 dc	 mov	 eax, DWORD PTR _data$[ebp]
  00092	50		 push	 eax
  00093	8b 4d 08	 mov	 ecx, DWORD PTR _cipher$[ebp]
  00096	51		 push	 ecx
  00097	e8 00 00 00 00	 call	 _DecipherBlock@12

; 304  : 			data += blockSize;

  0009c	8b 55 dc	 mov	 edx, DWORD PTR _data$[ebp]
  0009f	03 55 d8	 add	 edx, DWORD PTR _blockSize$27095[ebp]
  000a2	89 55 dc	 mov	 DWORD PTR _data$[ebp], edx

; 305  : 		}

  000a5	eb d4		 jmp	 SHORT $LN2@DecipherBl@2
$LN7@DecipherBl@2:

; 306  : 	}
; 307  : }

  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c2 10 00	 ret	 16			; 00000010H
_DecipherBlocks@16 ENDP
_TEXT	ENDS
PUBLIC	_CipherGet@4
; Function compile flags: /Odtp
;	COMDAT _CipherGet@4
_TEXT	SEGMENT
_i$ = -4						; size = 4
_id$ = 8						; size = 4
_CipherGet@4 PROC					; COMDAT

; 315  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 316  : 	int i;
; 317  : 	for (i = 0; Ciphers[i].Id != 0; i++)

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000d	eb 09		 jmp	 SHORT $LN4@CipherGet
$LN3@CipherGet:
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00012	83 c0 01	 add	 eax, 1
  00015	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@CipherGet:
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0001b	6b c9 14	 imul	 ecx, 20			; 00000014H
  0001e	83 b9 00 00 00
	00 00		 cmp	 DWORD PTR _Ciphers[ecx], 0
  00025	74 20		 je	 SHORT $LN2@CipherGet

; 318  : 		if (Ciphers[i].Id == id)

  00027	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0002a	6b d2 14	 imul	 edx, 20			; 00000014H
  0002d	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _Ciphers[edx]
  00033	3b 45 08	 cmp	 eax, DWORD PTR _id$[ebp]
  00036	75 0d		 jne	 SHORT $LN1@CipherGet

; 319  : 			return &Ciphers[i];

  00038	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0003b	6b c0 14	 imul	 eax, 20			; 00000014H
  0003e	05 00 00 00 00	 add	 eax, OFFSET _Ciphers
  00043	eb 04		 jmp	 SHORT $LN5@CipherGet
$LN1@CipherGet:

; 320  : 
; 321  : 	return NULL;

  00045	eb c8		 jmp	 SHORT $LN3@CipherGet
$LN2@CipherGet:
  00047	33 c0		 xor	 eax, eax
$LN5@CipherGet:

; 322  : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
_CipherGet@4 ENDP
_TEXT	ENDS
PUBLIC	_CipherGetName@4
; Function compile flags: /Odtp
;	COMDAT _CipherGetName@4
_TEXT	SEGMENT
_cipherId$ = 8						; size = 4
_CipherGetName@4 PROC					; COMDAT

; 325  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 326  : 	return CipherGet (cipherId) -> Name;

  00005	8b 45 08	 mov	 eax, DWORD PTR _cipherId$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _CipherGet@4
  0000e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 327  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
_CipherGetName@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _CipherGetBlockSize@4
_TEXT	SEGMENT
_cipherId$ = 8						; size = 4
_CipherGetBlockSize@4 PROC				; COMDAT

; 330  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 331  : 	return CipherGet (cipherId) -> BlockSize;

  00005	8b 45 08	 mov	 eax, DWORD PTR _cipherId$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _CipherGet@4
  0000e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 332  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
_CipherGetBlockSize@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _CipherGetKeySize@4
_TEXT	SEGMENT
_cipherId$ = 8						; size = 4
_CipherGetKeySize@4 PROC				; COMDAT

; 335  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 336  : 	return CipherGet (cipherId) -> KeySize;

  00005	8b 45 08	 mov	 eax, DWORD PTR _cipherId$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _CipherGet@4
  0000e	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 337  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
_CipherGetKeySize@4 ENDP
_TEXT	ENDS
PUBLIC	_CipherGetKeyScheduleSize@4
; Function compile flags: /Odtp
;	COMDAT _CipherGetKeyScheduleSize@4
_TEXT	SEGMENT
_cipherId$ = 8						; size = 4
_CipherGetKeyScheduleSize@4 PROC			; COMDAT

; 340  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 341  : 	return CipherGet (cipherId) -> KeyScheduleSize;

  00005	8b 45 08	 mov	 eax, DWORD PTR _cipherId$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _CipherGet@4
  0000e	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 342  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
_CipherGetKeyScheduleSize@4 ENDP
_TEXT	ENDS
PUBLIC	_CipherSupportsIntraDataUnitParallelization@4
; Function compile flags: /Odtp
;	COMDAT _CipherSupportsIntraDataUnitParallelization@4
_TEXT	SEGMENT
tv67 = -4						; size = 4
_cipher$ = 8						; size = 4
_CipherSupportsIntraDataUnitParallelization@4 PROC	; COMDAT

; 347  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 348  : 	return cipher == AES && IsAesHwCpuSupported();

  00006	83 7d 08 01	 cmp	 DWORD PTR _cipher$[ebp], 1
  0000a	75 12		 jne	 SHORT $LN3@CipherSupp
  0000c	e8 00 00 00 00	 call	 _IsAesHwCpuSupported@0
  00011	85 c0		 test	 eax, eax
  00013	74 09		 je	 SHORT $LN3@CipherSupp
  00015	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  0001c	eb 07		 jmp	 SHORT $LN4@CipherSupp
$LN3@CipherSupp:
  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$LN4@CipherSupp:
  00025	8b 45 fc	 mov	 eax, DWORD PTR tv67[ebp]

; 349  : }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
_CipherSupportsIntraDataUnitParallelization@4 ENDP
_TEXT	ENDS
PUBLIC	_EAGetFirst@0
; Function compile flags: /Odtp
;	COMDAT _EAGetFirst@0
_TEXT	SEGMENT
_EAGetFirst@0 PROC					; COMDAT

; 357  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 358  : 	return 1;

  00005	b8 01 00 00 00	 mov	 eax, 1

; 359  : }

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
_EAGetFirst@0 ENDP
_TEXT	ENDS
PUBLIC	_EAGetNext@4
PUBLIC	_EAGetCount@0
; Function compile flags: /Odtp
;	COMDAT _EAGetCount@0
_TEXT	SEGMENT
_ea$ = -8						; size = 4
_count$ = -4						; size = 4
_EAGetCount@0 PROC					; COMDAT

; 363  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 364  : 	int ea, count = 0;

  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 365  : 
; 366  : 	for (ea = EAGetFirst (); ea != 0; ea = EAGetNext (ea))

  0000f	e8 00 00 00 00	 call	 _EAGetFirst@0
  00014	89 45 f8	 mov	 DWORD PTR _ea$[ebp], eax
  00017	eb 0c		 jmp	 SHORT $LN3@EAGetCount
$LN2@EAGetCount:
  00019	8b 45 f8	 mov	 eax, DWORD PTR _ea$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _EAGetNext@4
  00022	89 45 f8	 mov	 DWORD PTR _ea$[ebp], eax
$LN3@EAGetCount:
  00025	83 7d f8 00	 cmp	 DWORD PTR _ea$[ebp], 0
  00029	74 0b		 je	 SHORT $LN1@EAGetCount

; 367  : 	{
; 368  : 		count++;

  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  0002e	83 c1 01	 add	 ecx, 1
  00031	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx

; 369  : 	}

  00034	eb e3		 jmp	 SHORT $LN2@EAGetCount
$LN1@EAGetCount:

; 370  : 	return count;

  00036	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]

; 371  : }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
_EAGetCount@0 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _EAGetNext@4
_TEXT	SEGMENT
_id$ = -4						; size = 4
_previousEA$ = 8					; size = 4
_EAGetNext@4 PROC					; COMDAT

; 374  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 375  : 	int id = previousEA + 1;

  00006	8b 45 08	 mov	 eax, DWORD PTR _previousEA$[ebp]
  00009	83 c0 01	 add	 eax, 1
  0000c	89 45 fc	 mov	 DWORD PTR _id$[ebp], eax

; 376  : 	if (EncryptionAlgorithms[id].Ciphers[0] != 0) return id;

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _id$[ebp]
  00012	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  00015	83 b9 00 00 00
	00 00		 cmp	 DWORD PTR _EncryptionAlgorithms[ecx], 0
  0001c	74 05		 je	 SHORT $LN1@EAGetNext
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _id$[ebp]
  00021	eb 02		 jmp	 SHORT $LN2@EAGetNext
$LN1@EAGetNext:

; 377  : 	return 0;

  00023	33 c0		 xor	 eax, eax
$LN2@EAGetNext:

; 378  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
_EAGetNext@4 ENDP
_TEXT	ENDS
PUBLIC	_EAGetNextCipher@8
PUBLIC	_EAGetFirstCipher@4
PUBLIC	_EAInit@12
; Function compile flags: /Odtp
;	COMDAT _EAInit@12
_TEXT	SEGMENT
tv75 = -12						; size = 4
_c$ = -8						; size = 4
_retVal$ = -4						; size = 4
_ea$ = 8						; size = 4
_key$ = 12						; size = 4
_ks$ = 16						; size = 4
_EAInit@12 PROC						; COMDAT

; 383  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 384  : 	int c, retVal = ERR_SUCCESS;

  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _retVal$[ebp], 0

; 385  : 
; 386  : 	if (ea == 0)

  0000f	83 7d 08 00	 cmp	 DWORD PTR _ea$[ebp], 0
  00013	75 07		 jne	 SHORT $LN8@EAInit

; 387  : 		return ERR_CIPHER_INIT_FAILURE;

  00015	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  0001a	eb 77		 jmp	 SHORT $LN9@EAInit
$LN8@EAInit:

; 388  : 
; 389  : 	for (c = EAGetFirstCipher (ea); c != 0; c = EAGetNextCipher (ea, c))

  0001c	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  00025	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax
  00028	eb 10		 jmp	 SHORT $LN7@EAInit
$LN6@EAInit:
  0002a	8b 4d f8	 mov	 ecx, DWORD PTR _c$[ebp]
  0002d	51		 push	 ecx
  0002e	8b 55 08	 mov	 edx, DWORD PTR _ea$[ebp]
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  00037	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax
$LN7@EAInit:
  0003a	83 7d f8 00	 cmp	 DWORD PTR _c$[ebp], 0
  0003e	74 50		 je	 SHORT $LN5@EAInit

; 390  : 	{
; 391  : 		switch (CipherInit (c, key, ks))

  00040	8b 45 10	 mov	 eax, DWORD PTR _ks$[ebp]
  00043	50		 push	 eax
  00044	8b 4d 0c	 mov	 ecx, DWORD PTR _key$[ebp]
  00047	51		 push	 ecx
  00048	8b 55 f8	 mov	 edx, DWORD PTR _c$[ebp]
  0004b	52		 push	 edx
  0004c	e8 00 00 00 00	 call	 _CipherInit@12
  00051	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
  00054	83 7d f4 11	 cmp	 DWORD PTR tv75[ebp], 17	; 00000011H
  00058	74 08		 je	 SHORT $LN2@EAInit
  0005a	83 7d f4 12	 cmp	 DWORD PTR tv75[ebp], 18	; 00000012H
  0005e	74 09		 je	 SHORT $LN1@EAInit
  00060	eb 0e		 jmp	 SHORT $LN3@EAInit
$LN2@EAInit:

; 392  : 		{
; 393  : 		case ERR_CIPHER_INIT_FAILURE:
; 394  : 			return ERR_CIPHER_INIT_FAILURE;

  00062	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  00067	eb 2a		 jmp	 SHORT $LN9@EAInit
$LN1@EAInit:

; 395  : 
; 396  : 		case ERR_CIPHER_INIT_WEAK_KEY:
; 397  : 			retVal = ERR_CIPHER_INIT_WEAK_KEY;		// Non-fatal error

  00069	c7 45 fc 12 00
	00 00		 mov	 DWORD PTR _retVal$[ebp], 18 ; 00000012H
$LN3@EAInit:

; 398  : 			break;
; 399  : 		}
; 400  : 
; 401  : 		key += CipherGetKeySize (c);

  00070	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 _CipherGetKeySize@4
  00079	03 45 0c	 add	 eax, DWORD PTR _key$[ebp]
  0007c	89 45 0c	 mov	 DWORD PTR _key$[ebp], eax

; 402  : 		ks += CipherGetKeyScheduleSize (c);

  0007f	8b 4d f8	 mov	 ecx, DWORD PTR _c$[ebp]
  00082	51		 push	 ecx
  00083	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  00088	03 45 10	 add	 eax, DWORD PTR _ks$[ebp]
  0008b	89 45 10	 mov	 DWORD PTR _ks$[ebp], eax

; 403  : 	}

  0008e	eb 9a		 jmp	 SHORT $LN6@EAInit
$LN5@EAInit:

; 404  : 	return retVal;

  00090	8b 45 fc	 mov	 eax, DWORD PTR _retVal$[ebp]
$LN9@EAInit:

; 405  : }

  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c2 0c 00	 ret	 12			; 0000000cH
_EAInit@12 ENDP
_TEXT	ENDS
PUBLIC	_EAInitMode@4
EXTRN	_Gf128Tab64Init@8:PROC
EXTRN	_Gf64TabInit@8:PROC
; Function compile flags: /Odtp
;	COMDAT _EAInitMode@4
_TEXT	SEGMENT
tv77 = -8						; size = 4
tv65 = -4						; size = 4
_ci$ = 8						; size = 4
_EAInitMode@4 PROC					; COMDAT

; 411  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 412  : 	switch (ci->mode)

  00008	8b 45 08	 mov	 eax, DWORD PTR _ci$[ebp]
  0000b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000e	89 4d fc	 mov	 DWORD PTR tv65[ebp], ecx
  00011	8b 55 fc	 mov	 edx, DWORD PTR tv65[ebp]
  00014	83 ea 01	 sub	 edx, 1
  00017	89 55 fc	 mov	 DWORD PTR tv65[ebp], edx
  0001a	83 7d fc 04	 cmp	 DWORD PTR tv65[ebp], 4
  0001e	0f 87 af 00 00
	00		 ja	 $LN1@EAInitMode
  00024	8b 45 fc	 mov	 eax, DWORD PTR tv65[ebp]
  00027	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN15@EAInitMode[eax*4]
$LN10@EAInitMode:

; 413  : 	{
; 414  : 	case XTS:
; 415  : 		// Secondary key schedule
; 416  : 		if (EAInit (ci->ea, ci->k2, ci->ks2) != ERR_SUCCESS)

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _ci$[ebp]
  00031	81 c1 d4 14 00
	00		 add	 ecx, 5332		; 000014d4H
  00037	51		 push	 ecx
  00038	8b 55 08	 mov	 edx, DWORD PTR _ci$[ebp]
  0003b	81 c2 a8 42 00
	00		 add	 edx, 17064		; 000042a8H
  00041	52		 push	 edx
  00042	8b 45 08	 mov	 eax, DWORD PTR _ci$[ebp]
  00045	8b 08		 mov	 ecx, DWORD PTR [eax]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 _EAInit@12
  0004d	85 c0		 test	 eax, eax
  0004f	74 07		 je	 SHORT $LN9@EAInitMode

; 417  : 			return FALSE;

  00051	33 c0		 xor	 eax, eax
  00053	e9 96 00 00 00	 jmp	 $LN14@EAInitMode
$LN9@EAInitMode:

; 418  : 
; 419  : 		/* Note: XTS mode could potentially be initialized with a weak key causing all blocks in one data unit
; 420  : 		on the volume to be tweaked with zero tweaks (i.e. 512 bytes of the volume would be encrypted in ECB
; 421  : 		mode). However, to create a CipherShed volume with such a weak key, each human being on Earth would have
; 422  : 		to create approximately 11,378,125,361,078,862 (about eleven quadrillion) CipherShed volumes (provided 
; 423  : 		that the size of each of the volumes is 1024 terabytes). */
; 424  : 		break;

  00058	e9 8c 00 00 00	 jmp	 $LN11@EAInitMode
$LN8@EAInitMode:

; 425  : 
; 426  : 	case LRW:
; 427  : 		switch (CipherGetBlockSize (EAGetFirstCipher (ci->ea)))

  0005d	8b 55 08	 mov	 edx, DWORD PTR _ci$[ebp]
  00060	8b 02		 mov	 eax, DWORD PTR [edx]
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 _CipherGetBlockSize@4
  0006e	89 45 f8	 mov	 DWORD PTR tv77[ebp], eax
  00071	83 7d f8 08	 cmp	 DWORD PTR tv77[ebp], 8
  00075	74 08		 je	 SHORT $LN5@EAInitMode
  00077	83 7d f8 10	 cmp	 DWORD PTR tv77[ebp], 16	; 00000010H
  0007b	74 1d		 je	 SHORT $LN4@EAInitMode
  0007d	eb 35		 jmp	 SHORT $LN3@EAInitMode
$LN5@EAInitMode:

; 428  : 		{
; 429  : 		case 8:
; 430  : 			/* Deprecated/legacy */
; 431  : 			return Gf64TabInit (ci->k2, &ci->gf_ctx);

  0007f	8b 4d 08	 mov	 ecx, DWORD PTR _ci$[ebp]
  00082	81 c1 a8 29 00
	00		 add	 ecx, 10664		; 000029a8H
  00088	51		 push	 ecx
  00089	8b 55 08	 mov	 edx, DWORD PTR _ci$[ebp]
  0008c	81 c2 a8 42 00
	00		 add	 edx, 17064		; 000042a8H
  00092	52		 push	 edx
  00093	e8 00 00 00 00	 call	 _Gf64TabInit@8
  00098	eb 54		 jmp	 SHORT $LN14@EAInitMode
$LN4@EAInitMode:

; 432  : 
; 433  : 		case 16:
; 434  : 			return Gf128Tab64Init (ci->k2, &ci->gf_ctx);

  0009a	8b 45 08	 mov	 eax, DWORD PTR _ci$[ebp]
  0009d	05 a8 29 00 00	 add	 eax, 10664		; 000029a8H
  000a2	50		 push	 eax
  000a3	8b 4d 08	 mov	 ecx, DWORD PTR _ci$[ebp]
  000a6	81 c1 a8 42 00
	00		 add	 ecx, 17064		; 000042a8H
  000ac	51		 push	 ecx
  000ad	e8 00 00 00 00	 call	 _Gf128Tab64Init@8
  000b2	eb 3a		 jmp	 SHORT $LN14@EAInitMode
$LN3@EAInitMode:

; 435  : 
; 436  : 		default:
; 437  : 			TC_THROW_FATAL_EXCEPTION;

  000b4	68 43 54 00 00	 push	 21571			; 00005443H
  000b9	6a 00		 push	 0
  000bb	6a 00		 push	 0
  000bd	68 b5 01 00 00	 push	 437			; 000001b5H
  000c2	6a 29		 push	 41			; 00000029H
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20

; 438  : 		}
; 439  : 
; 440  : 		break;

  000ca	eb 1d		 jmp	 SHORT $LN11@EAInitMode
$LN2@EAInitMode:

; 441  : 
; 442  : 	case CBC:
; 443  : 	case INNER_CBC:
; 444  : 	case OUTER_CBC:
; 445  : 		// The mode does not need to be initialized or is initialized elsewhere 
; 446  : 		return TRUE;

  000cc	b8 01 00 00 00	 mov	 eax, 1
  000d1	eb 1b		 jmp	 SHORT $LN14@EAInitMode
$LN1@EAInitMode:

; 447  : 
; 448  : 	default:		
; 449  : 		// Unknown/wrong ID
; 450  : 		TC_THROW_FATAL_EXCEPTION;

  000d3	68 43 54 00 00	 push	 21571			; 00005443H
  000d8	6a 00		 push	 0
  000da	6a 00		 push	 0
  000dc	68 c2 01 00 00	 push	 450			; 000001c2H
  000e1	6a 29		 push	 41			; 00000029H
  000e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN11@EAInitMode:

; 451  : 	}
; 452  : 	return TRUE;

  000e9	b8 01 00 00 00	 mov	 eax, 1
$LN14@EAInitMode:

; 453  : }

  000ee	8b e5		 mov	 esp, ebp
  000f0	5d		 pop	 ebp
  000f1	c2 04 00	 ret	 4
$LN15@EAInitMode:
  000f4	00 00 00 00	 DD	 $LN10@EAInitMode
  000f8	00 00 00 00	 DD	 $LN8@EAInitMode
  000fc	00 00 00 00	 DD	 $LN2@EAInitMode
  00100	00 00 00 00	 DD	 $LN2@EAInitMode
  00104	00 00 00 00	 DD	 $LN2@EAInitMode
_EAInitMode@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_01JOAMLHOP@?9?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	_EAGetPreviousCipher@8
PUBLIC	??_C@_01OGPIMHDM@?$DP?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	_EAGetLastCipher@4
PUBLIC	_EAGetName@8
;	COMDAT ??_C@_01JOAMLHOP@?9?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_01JOAMLHOP@?9?$AA@FNODOBFM@ DB '-', 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_01OGPIMHDM@?$DP?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_01OGPIMHDM@?$DP?$AA@FNODOBFM@ DB '?', 00H		;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _EAGetName@8
_TEXT	SEGMENT
tv171 = -57						; size = 1
tv168 = -56						; size = 4
tv165 = -52						; size = 4
tv164 = -48						; size = 4
tv159 = -41						; size = 1
tv156 = -40						; size = 4
tv154 = -36						; size = 4
tv145 = -29						; size = 1
tv142 = -28						; size = 4
tv74 = -21						; size = 1
tv73 = -20						; size = 4
tv72 = -16						; size = 4
tv71 = -12						; size = 4
tv70 = -8						; size = 4
_i$ = -4						; size = 4
_buf$ = 8						; size = 4
_ea$ = 12						; size = 4
_EAGetName@8 PROC					; COMDAT

; 458  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00008	56		 push	 esi
  00009	57		 push	 edi

; 459  : 	int i = EAGetLastCipher(ea);

  0000a	8b 45 0c	 mov	 eax, DWORD PTR _ea$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 _EAGetLastCipher@4
  00013	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 460  : 	strcpy (buf, (i != 0) ? CipherGetName (i) : "?");

  00016	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  0001a	74 0e		 je	 SHORT $LN5@EAGetName
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 _CipherGetName@4
  00025	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
  00028	eb 07		 jmp	 SHORT $LN6@EAGetName
$LN5@EAGetName:
  0002a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], OFFSET ??_C@_01OGPIMHDM@?$DP?$AA@FNODOBFM@
$LN6@EAGetName:
  00031	8b 55 f8	 mov	 edx, DWORD PTR tv70[ebp]
  00034	89 55 f4	 mov	 DWORD PTR tv71[ebp], edx
  00037	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0003a	89 45 f0	 mov	 DWORD PTR tv72[ebp], eax
  0003d	8b 4d f0	 mov	 ecx, DWORD PTR tv72[ebp]
  00040	89 4d ec	 mov	 DWORD PTR tv73[ebp], ecx
$LN7@EAGetName:
  00043	8b 55 f4	 mov	 edx, DWORD PTR tv71[ebp]
  00046	8a 02		 mov	 al, BYTE PTR [edx]
  00048	88 45 eb	 mov	 BYTE PTR tv74[ebp], al
  0004b	8b 4d f0	 mov	 ecx, DWORD PTR tv72[ebp]
  0004e	8a 55 eb	 mov	 dl, BYTE PTR tv74[ebp]
  00051	88 11		 mov	 BYTE PTR [ecx], dl
  00053	8b 45 f4	 mov	 eax, DWORD PTR tv71[ebp]
  00056	83 c0 01	 add	 eax, 1
  00059	89 45 f4	 mov	 DWORD PTR tv71[ebp], eax
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR tv72[ebp]
  0005f	83 c1 01	 add	 ecx, 1
  00062	89 4d f0	 mov	 DWORD PTR tv72[ebp], ecx
  00065	80 7d eb 00	 cmp	 BYTE PTR tv74[ebp], 0
  00069	75 d8		 jne	 SHORT $LN7@EAGetName
$LN2@EAGetName:

; 461  : 
; 462  : 	while (i = EAGetPreviousCipher(ea, i))

  0006b	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0006e	52		 push	 edx
  0006f	8b 45 0c	 mov	 eax, DWORD PTR _ea$[ebp]
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 _EAGetPreviousCipher@8
  00078	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  0007b	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  0007f	0f 84 94 00 00
	00		 je	 $LN1@EAGetName

; 463  : 	{
; 464  : 		strcat (buf, "-");

  00085	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00088	83 c1 ff	 add	 ecx, -1
  0008b	89 4d e4	 mov	 DWORD PTR tv142[ebp], ecx
$LL8@EAGetName:
  0008e	8b 55 e4	 mov	 edx, DWORD PTR tv142[ebp]
  00091	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  00094	88 45 e3	 mov	 BYTE PTR tv145[ebp], al
  00097	83 45 e4 01	 add	 DWORD PTR tv142[ebp], 1
  0009b	80 7d e3 00	 cmp	 BYTE PTR tv145[ebp], 0
  0009f	75 ed		 jne	 SHORT $LL8@EAGetName
  000a1	8b 7d e4	 mov	 edi, DWORD PTR tv142[ebp]
  000a4	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR ??_C@_01JOAMLHOP@?9?$AA@FNODOBFM@
  000ab	66 89 0f	 mov	 WORD PTR [edi], cx

; 465  : 		strcat (buf, CipherGetName (i));

  000ae	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000b1	52		 push	 edx
  000b2	e8 00 00 00 00	 call	 _CipherGetName@4
  000b7	89 45 dc	 mov	 DWORD PTR tv154[ebp], eax
  000ba	8b 45 dc	 mov	 eax, DWORD PTR tv154[ebp]
  000bd	89 45 d8	 mov	 DWORD PTR tv156[ebp], eax
$LL9@EAGetName:
  000c0	8b 4d dc	 mov	 ecx, DWORD PTR tv154[ebp]
  000c3	8a 11		 mov	 dl, BYTE PTR [ecx]
  000c5	88 55 d7	 mov	 BYTE PTR tv159[ebp], dl
  000c8	83 45 dc 01	 add	 DWORD PTR tv154[ebp], 1
  000cc	80 7d d7 00	 cmp	 BYTE PTR tv159[ebp], 0
  000d0	75 ee		 jne	 SHORT $LL9@EAGetName
  000d2	8b 45 dc	 mov	 eax, DWORD PTR tv154[ebp]
  000d5	2b 45 d8	 sub	 eax, DWORD PTR tv156[ebp]
  000d8	8b 4d d8	 mov	 ecx, DWORD PTR tv156[ebp]
  000db	89 4d d0	 mov	 DWORD PTR tv164[ebp], ecx
  000de	89 45 cc	 mov	 DWORD PTR tv165[ebp], eax
  000e1	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  000e4	83 c2 ff	 add	 edx, -1
  000e7	89 55 c8	 mov	 DWORD PTR tv168[ebp], edx
$LL10@EAGetName:
  000ea	8b 45 c8	 mov	 eax, DWORD PTR tv168[ebp]
  000ed	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  000f0	88 4d c7	 mov	 BYTE PTR tv171[ebp], cl
  000f3	83 45 c8 01	 add	 DWORD PTR tv168[ebp], 1
  000f7	80 7d c7 00	 cmp	 BYTE PTR tv171[ebp], 0
  000fb	75 ed		 jne	 SHORT $LL10@EAGetName
  000fd	8b 7d c8	 mov	 edi, DWORD PTR tv168[ebp]
  00100	8b 75 d0	 mov	 esi, DWORD PTR tv164[ebp]
  00103	8b 55 cc	 mov	 edx, DWORD PTR tv165[ebp]
  00106	8b ca		 mov	 ecx, edx
  00108	c1 e9 02	 shr	 ecx, 2
  0010b	f3 a5		 rep movsd
  0010d	8b ca		 mov	 ecx, edx
  0010f	83 e1 03	 and	 ecx, 3
  00112	f3 a4		 rep movsb

; 466  : 	}

  00114	e9 52 ff ff ff	 jmp	 $LN2@EAGetName
$LN1@EAGetName:

; 467  : 
; 468  : 	return buf;

  00119	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]

; 469  : }

  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi
  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c2 08 00	 ret	 8
_EAGetName@8 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_EAGetByName@4
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Odtp
;	COMDAT _EAGetByName@4
_TEXT	SEGMENT
tv70 = -160						; size = 4
tv128 = -156						; size = 4
tv91 = -150						; size = 1
tv84 = -149						; size = 1
tv78 = -148						; size = 4
tv80 = -144						; size = 4
_ea$ = -140						; size = 4
_n$ = -136						; size = 128
__$ArrayPad$ = -4					; size = 4
_name$ = 8						; size = 4
_EAGetByName@4 PROC					; COMDAT

; 473  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 474  : 	int ea = EAGetFirst ();

  00015	e8 00 00 00 00	 call	 _EAGetFirst@0
  0001a	89 85 74 ff ff
	ff		 mov	 DWORD PTR _ea$[ebp], eax
$LN4@EAGetByNam:

; 475  : 	char n[128];
; 476  : 
; 477  : 	do
; 478  : 	{
; 479  : 		EAGetName (n, ea);

  00020	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _ea$[ebp]
  00026	50		 push	 eax
  00027	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _n$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 _EAGetName@8

; 480  : 		if (strcmp (n, name) == 0)

  00033	8b 55 08	 mov	 edx, DWORD PTR _name$[ebp]
  00036	89 95 70 ff ff
	ff		 mov	 DWORD PTR tv80[ebp], edx
  0003c	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _n$[ebp]
  00042	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv78[ebp], eax
$LL7@EAGetByNam:
  00048	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv78[ebp]
  0004e	8a 11		 mov	 dl, BYTE PTR [ecx]
  00050	88 95 6b ff ff
	ff		 mov	 BYTE PTR tv84[ebp], dl
  00056	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv80[ebp]
  0005c	3a 10		 cmp	 dl, BYTE PTR [eax]
  0005e	75 46		 jne	 SHORT $LN8@EAGetByNam
  00060	80 bd 6b ff ff
	ff 00		 cmp	 BYTE PTR tv84[ebp], 0
  00067	74 31		 je	 SHORT $LN9@EAGetByNam
  00069	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv78[ebp]
  0006f	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  00072	88 95 6a ff ff
	ff		 mov	 BYTE PTR tv91[ebp], dl
  00078	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv80[ebp]
  0007e	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  00081	75 23		 jne	 SHORT $LN8@EAGetByNam
  00083	83 85 6c ff ff
	ff 02		 add	 DWORD PTR tv78[ebp], 2
  0008a	83 85 70 ff ff
	ff 02		 add	 DWORD PTR tv80[ebp], 2
  00091	80 bd 6a ff ff
	ff 00		 cmp	 BYTE PTR tv91[ebp], 0
  00098	75 ae		 jne	 SHORT $LL7@EAGetByNam
$LN9@EAGetByNam:
  0009a	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv128[ebp], 0
  000a4	eb 0b		 jmp	 SHORT $LN10@EAGetByNam
$LN8@EAGetByNam:
  000a6	1b c9		 sbb	 ecx, ecx
  000a8	83 d9 ff	 sbb	 ecx, -1
  000ab	89 8d 64 ff ff
	ff		 mov	 DWORD PTR tv128[ebp], ecx
$LN10@EAGetByNam:
  000b1	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv128[ebp]
  000b7	89 95 60 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], edx
  000bd	83 bd 60 ff ff
	ff 00		 cmp	 DWORD PTR tv70[ebp], 0
  000c4	75 08		 jne	 SHORT $LN3@EAGetByNam

; 481  : 			return ea;

  000c6	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _ea$[ebp]
  000cc	eb 21		 jmp	 SHORT $LN5@EAGetByNam
$LN3@EAGetByNam:

; 482  : 	}
; 483  : 	while (ea = EAGetNext (ea));

  000ce	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _ea$[ebp]
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 _EAGetNext@4
  000da	89 85 74 ff ff
	ff		 mov	 DWORD PTR _ea$[ebp], eax
  000e0	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _ea$[ebp], 0
  000e7	0f 85 33 ff ff
	ff		 jne	 $LN4@EAGetByNam

; 484  : 
; 485  : 	return 0;

  000ed	33 c0		 xor	 eax, eax
$LN5@EAGetByNam:

; 486  : }

  000ef	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f2	33 cd		 xor	 ecx, ebp
  000f4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c2 04 00	 ret	 4
_EAGetByName@4 ENDP
_TEXT	ENDS
PUBLIC	_EAGetKeySize@4
; Function compile flags: /Odtp
;	COMDAT _EAGetKeySize@4
_TEXT	SEGMENT
_size$ = -8						; size = 4
_i$ = -4						; size = 4
_ea$ = 8						; size = 4
_EAGetKeySize@4 PROC					; COMDAT

; 492  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 493  : 	int i = EAGetFirstCipher (ea);

  00008	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  00011	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 494  : 	int size = CipherGetKeySize (i);

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _CipherGetKeySize@4
  0001d	89 45 f8	 mov	 DWORD PTR _size$[ebp], eax
$LN2@EAGetKeySi:

; 495  : 
; 496  : 	while (i = EAGetNextCipher (ea, i))

  00020	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00023	52		 push	 edx
  00024	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  0002d	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00030	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  00034	74 11		 je	 SHORT $LN1@EAGetKeySi

; 497  : 	{
; 498  : 		size += CipherGetKeySize (i);

  00036	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 _CipherGetKeySize@4
  0003f	03 45 f8	 add	 eax, DWORD PTR _size$[ebp]
  00042	89 45 f8	 mov	 DWORD PTR _size$[ebp], eax

; 499  : 	}

  00045	eb d9		 jmp	 SHORT $LN2@EAGetKeySi
$LN1@EAGetKeySi:

; 500  : 
; 501  : 	return size;

  00047	8b 45 f8	 mov	 eax, DWORD PTR _size$[ebp]

; 502  : }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
_EAGetKeySize@4 ENDP
_TEXT	ENDS
PUBLIC	_EAGetFirstMode@4
; Function compile flags: /Odtp
;	COMDAT _EAGetFirstMode@4
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_EAGetFirstMode@4 PROC					; COMDAT

; 507  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 508  : 	return (EncryptionAlgorithms[ea].Modes[0]);

  00005	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00008	6b c0 2c	 imul	 eax, 44			; 0000002cH
  0000b	8b 80 10 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax+16]

; 509  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
_EAGetFirstMode@4 ENDP
_TEXT	ENDS
PUBLIC	_EAGetNextMode@8
; Function compile flags: /Odtp
;	COMDAT _EAGetNextMode@8
_TEXT	SEGMENT
_c$ = -8						; size = 4
_i$ = -4						; size = 4
_ea$ = 8						; size = 4
_previousModeId$ = 12					; size = 4
_EAGetNextMode@8 PROC					; COMDAT

; 513  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 514  : 	int c, i = 0;

  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN3@EAGetNextM:

; 515  : 	while (c = EncryptionAlgorithms[ea].Modes[i++])

  0000f	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00012	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00018	8b 94 88 10 00
	00 00		 mov	 edx, DWORD PTR _EncryptionAlgorithms[eax+ecx*4+16]
  0001f	89 55 f8	 mov	 DWORD PTR _c$[ebp], edx
  00022	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00028	83 c1 01	 add	 ecx, 1
  0002b	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  0002e	85 c0		 test	 eax, eax
  00030	74 1c		 je	 SHORT $LN2@EAGetNextM

; 516  : 	{
; 517  : 		if (c == previousModeId) 

  00032	8b 55 f8	 mov	 edx, DWORD PTR _c$[ebp]
  00035	3b 55 0c	 cmp	 edx, DWORD PTR _previousModeId$[ebp]
  00038	75 12		 jne	 SHORT $LN1@EAGetNextM

; 518  : 			return EncryptionAlgorithms[ea].Modes[i];

  0003a	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  0003d	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00040	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00043	8b 84 88 10 00
	00 00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax+ecx*4+16]
  0004a	eb 04		 jmp	 SHORT $LN4@EAGetNextM
$LN1@EAGetNextM:

; 519  : 	}

  0004c	eb c1		 jmp	 SHORT $LN3@EAGetNextM
$LN2@EAGetNextM:

; 520  : 
; 521  : 	return 0;

  0004e	33 c0		 xor	 eax, eax
$LN4@EAGetNextM:

; 522  : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
_EAGetNextMode@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_09DJENBFJK@?$FLunknown?$FN?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_09OHJJMGAK@inner?9CBC?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_09KIMEMFNK@Inner?9CBC?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_03PPFAJCFI@CBC?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_09CJGJEHAC@outer?9CBC?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_09GGDEEENC@Outer?9CBC?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0L@NEGMAKNF@Triple?5DES?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_03JFLLPGCL@LRW?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_03CKCBIPFF@XTS?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	__$ArrayPad$
PUBLIC	_EAGetModeName@12
;	COMDAT ??_C@_09DJENBFJK@?$FLunknown?$FN?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09DJENBFJK@?$FLunknown?$FN?$AA@FNODOBFM@ DB '[unknown]', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_09OHJJMGAK@inner?9CBC?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09OHJJMGAK@inner?9CBC?$AA@FNODOBFM@ DB 'inner-CBC', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_09KIMEMFNK@Inner?9CBC?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09KIMEMFNK@Inner?9CBC?$AA@FNODOBFM@ DB 'Inner-CBC', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_03PPFAJCFI@CBC?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_03PPFAJCFI@CBC?$AA@FNODOBFM@ DB 'CBC', 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_09CJGJEHAC@outer?9CBC?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09CJGJEHAC@outer?9CBC?$AA@FNODOBFM@ DB 'outer-CBC', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_09GGDEEENC@Outer?9CBC?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09GGDEEENC@Outer?9CBC?$AA@FNODOBFM@ DB 'Outer-CBC', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0L@NEGMAKNF@Triple?5DES?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0L@NEGMAKNF@Triple?5DES?$AA@FNODOBFM@ DB 'Triple DES', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_03JFLLPGCL@LRW?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_03JFLLPGCL@LRW?$AA@FNODOBFM@ DB 'LRW', 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_03CKCBIPFF@XTS?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_03CKCBIPFF@XTS?$AA@FNODOBFM@ DB 'XTS', 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _EAGetModeName@12
_TEXT	SEGMENT
tv77 = -148						; size = 4
tv75 = -144						; size = 4
tv73 = -140						; size = 4
tv70 = -136						; size = 4
tv136 = -132						; size = 4
tv131 = -126						; size = 1
tv92 = -125						; size = 1
tv87 = -124						; size = 4
tv89 = -120						; size = 4
tv64 = -116						; size = 4
_eaName$27235 = -112					; size = 100
__$ArrayPad$ = -4					; size = 4
_ea$ = 8						; size = 4
_mode$ = 12						; size = 4
_capitalLetters$ = 16					; size = 4
_EAGetModeName@12 PROC					; COMDAT

; 529  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 530  : 	switch (mode)

  00015	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  00018	89 45 8c	 mov	 DWORD PTR tv64[ebp], eax
  0001b	8b 4d 8c	 mov	 ecx, DWORD PTR tv64[ebp]
  0001e	83 e9 01	 sub	 ecx, 1
  00021	89 4d 8c	 mov	 DWORD PTR tv64[ebp], ecx
  00024	83 7d 8c 04	 cmp	 DWORD PTR tv64[ebp], 4
  00028	0f 87 0b 01 00
	00		 ja	 $LN7@EAGetModeN
  0002e	8b 55 8c	 mov	 edx, DWORD PTR tv64[ebp]
  00031	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN21@EAGetModeN[edx*4]
$LN6@EAGetModeN:

; 531  : 	{
; 532  : 	case XTS:
; 533  : 
; 534  : 		return "XTS";

  00038	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03CKCBIPFF@XTS?$AA@FNODOBFM@
  0003d	e9 fc 00 00 00	 jmp	 $LN9@EAGetModeN
$LN5@EAGetModeN:

; 535  : 
; 536  : 	case LRW:
; 537  : 
; 538  : 		/* Deprecated/legacy */
; 539  : 
; 540  : 		return "LRW";

  00042	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JFLLPGCL@LRW?$AA@FNODOBFM@
  00047	e9 f2 00 00 00	 jmp	 $LN9@EAGetModeN
$LN4@EAGetModeN:

; 541  : 
; 542  : 	case CBC:
; 543  : 		{
; 544  : 			/* Deprecated/legacy */
; 545  : 
; 546  : 			char eaName[100];
; 547  : 			EAGetName (eaName, ea);

  0004c	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  0004f	50		 push	 eax
  00050	8d 4d 90	 lea	 ecx, DWORD PTR _eaName$27235[ebp]
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 _EAGetName@8

; 548  : 
; 549  : 			if (strcmp (eaName, "Triple DES") == 0)

  00059	c7 45 88 00 00
	00 00		 mov	 DWORD PTR tv89[ebp], OFFSET ??_C@_0L@NEGMAKNF@Triple?5DES?$AA@FNODOBFM@
  00060	8d 55 90	 lea	 edx, DWORD PTR _eaName$27235[ebp]
  00063	89 55 84	 mov	 DWORD PTR tv87[ebp], edx
$LL17@EAGetModeN:
  00066	8b 45 84	 mov	 eax, DWORD PTR tv87[ebp]
  00069	8a 08		 mov	 cl, BYTE PTR [eax]
  0006b	88 4d 83	 mov	 BYTE PTR tv92[ebp], cl
  0006e	8b 55 88	 mov	 edx, DWORD PTR tv89[ebp]
  00071	3a 0a		 cmp	 cl, BYTE PTR [edx]
  00073	75 31		 jne	 SHORT $LN18@EAGetModeN
  00075	80 7d 83 00	 cmp	 BYTE PTR tv92[ebp], 0
  00079	74 1f		 je	 SHORT $LN19@EAGetModeN
  0007b	8b 45 84	 mov	 eax, DWORD PTR tv87[ebp]
  0007e	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00081	88 4d 82	 mov	 BYTE PTR tv131[ebp], cl
  00084	8b 55 88	 mov	 edx, DWORD PTR tv89[ebp]
  00087	3a 4a 01	 cmp	 cl, BYTE PTR [edx+1]
  0008a	75 1a		 jne	 SHORT $LN18@EAGetModeN
  0008c	83 45 84 02	 add	 DWORD PTR tv87[ebp], 2
  00090	83 45 88 02	 add	 DWORD PTR tv89[ebp], 2
  00094	80 7d 82 00	 cmp	 BYTE PTR tv131[ebp], 0
  00098	75 cc		 jne	 SHORT $LL17@EAGetModeN
$LN19@EAGetModeN:
  0009a	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv136[ebp], 0
  000a4	eb 0b		 jmp	 SHORT $LN20@EAGetModeN
$LN18@EAGetModeN:
  000a6	1b c0		 sbb	 eax, eax
  000a8	83 d8 ff	 sbb	 eax, -1
  000ab	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv136[ebp], eax
$LN20@EAGetModeN:
  000b1	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR tv136[ebp]
  000b7	89 8d 78 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], ecx
  000bd	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR tv70[ebp], 0
  000c4	75 24		 jne	 SHORT $LN3@EAGetModeN

; 550  : 				return capitalLetters ? "Outer-CBC" : "outer-CBC";

  000c6	83 7d 10 00	 cmp	 DWORD PTR _capitalLetters$[ebp], 0
  000ca	74 0c		 je	 SHORT $LN11@EAGetModeN
  000cc	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv73[ebp], OFFSET ??_C@_09GGDEEENC@Outer?9CBC?$AA@FNODOBFM@
  000d6	eb 0a		 jmp	 SHORT $LN12@EAGetModeN
$LN11@EAGetModeN:
  000d8	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv73[ebp], OFFSET ??_C@_09CJGJEHAC@outer?9CBC?$AA@FNODOBFM@
$LN12@EAGetModeN:
  000e2	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv73[ebp]
  000e8	eb 54		 jmp	 SHORT $LN9@EAGetModeN
$LN3@EAGetModeN:

; 551  : 
; 552  : 			return "CBC";

  000ea	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03PPFAJCFI@CBC?$AA@FNODOBFM@
  000ef	eb 4d		 jmp	 SHORT $LN9@EAGetModeN
$LN2@EAGetModeN:

; 553  : 		}
; 554  : 
; 555  : 	case OUTER_CBC:
; 556  : 
; 557  : 		/* Deprecated/legacy */
; 558  : 
; 559  : 		return  capitalLetters ? "Outer-CBC" : "outer-CBC";

  000f1	83 7d 10 00	 cmp	 DWORD PTR _capitalLetters$[ebp], 0
  000f5	74 0c		 je	 SHORT $LN13@EAGetModeN
  000f7	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv75[ebp], OFFSET ??_C@_09GGDEEENC@Outer?9CBC?$AA@FNODOBFM@
  00101	eb 0a		 jmp	 SHORT $LN14@EAGetModeN
$LN13@EAGetModeN:
  00103	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv75[ebp], OFFSET ??_C@_09CJGJEHAC@outer?9CBC?$AA@FNODOBFM@
$LN14@EAGetModeN:
  0010d	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv75[ebp]
  00113	eb 29		 jmp	 SHORT $LN9@EAGetModeN
$LN1@EAGetModeN:

; 560  : 
; 561  : 	case INNER_CBC:
; 562  : 
; 563  : 		/* Deprecated/legacy */
; 564  : 
; 565  : 		return capitalLetters ? "Inner-CBC" : "inner-CBC";

  00115	83 7d 10 00	 cmp	 DWORD PTR _capitalLetters$[ebp], 0
  00119	74 0c		 je	 SHORT $LN15@EAGetModeN
  0011b	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv77[ebp], OFFSET ??_C@_09KIMEMFNK@Inner?9CBC?$AA@FNODOBFM@
  00125	eb 0a		 jmp	 SHORT $LN16@EAGetModeN
$LN15@EAGetModeN:
  00127	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv77[ebp], OFFSET ??_C@_09OHJJMGAK@inner?9CBC?$AA@FNODOBFM@
$LN16@EAGetModeN:
  00131	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR tv77[ebp]
  00137	eb 05		 jmp	 SHORT $LN9@EAGetModeN
$LN7@EAGetModeN:

; 566  : 
; 567  : 	}
; 568  : 	return "[unknown]";

  00139	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09DJENBFJK@?$FLunknown?$FN?$AA@FNODOBFM@
$LN9@EAGetModeN:

; 569  : }

  0013e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00141	33 cd		 xor	 ecx, ebp
  00143	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00148	8b e5		 mov	 esp, ebp
  0014a	5d		 pop	 ebp
  0014b	c2 0c 00	 ret	 12			; 0000000cH
  0014e	8b ff		 npad	 2
$LN21@EAGetModeN:
  00150	00 00 00 00	 DD	 $LN6@EAGetModeN
  00154	00 00 00 00	 DD	 $LN5@EAGetModeN
  00158	00 00 00 00	 DD	 $LN4@EAGetModeN
  0015c	00 00 00 00	 DD	 $LN2@EAGetModeN
  00160	00 00 00 00	 DD	 $LN1@EAGetModeN
_EAGetModeName@12 ENDP
_TEXT	ENDS
PUBLIC	_EAGetKeyScheduleSize@4
; Function compile flags: /Odtp
;	COMDAT _EAGetKeyScheduleSize@4
_TEXT	SEGMENT
_size$ = -8						; size = 4
_i$ = -4						; size = 4
_ea$ = 8						; size = 4
_EAGetKeyScheduleSize@4 PROC				; COMDAT

; 576  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 577  : 	int i = EAGetFirstCipher(ea);

  00008	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  00011	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 578  : 	int size = CipherGetKeyScheduleSize (i);

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  0001d	89 45 f8	 mov	 DWORD PTR _size$[ebp], eax
$LN2@EAGetKeySc:

; 579  : 
; 580  : 	while (i = EAGetNextCipher(ea, i))

  00020	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00023	52		 push	 edx
  00024	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  0002d	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00030	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  00034	74 11		 je	 SHORT $LN1@EAGetKeySc

; 581  : 	{
; 582  : 		size += CipherGetKeyScheduleSize (i);

  00036	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  0003f	03 45 f8	 add	 eax, DWORD PTR _size$[ebp]
  00042	89 45 f8	 mov	 DWORD PTR _size$[ebp], eax

; 583  : 	}

  00045	eb d9		 jmp	 SHORT $LN2@EAGetKeySc
$LN1@EAGetKeySc:

; 584  : 
; 585  : 	return size;

  00047	8b 45 f8	 mov	 eax, DWORD PTR _size$[ebp]

; 586  : }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
_EAGetKeyScheduleSize@4 ENDP
_TEXT	ENDS
PUBLIC	_EAIsModeSupported@8
PUBLIC	_EAGetLargestKeyForMode@4
; Function compile flags: /Odtp
;	COMDAT _EAGetLargestKeyForMode@4
_TEXT	SEGMENT
_ea$ = -8						; size = 4
_key$ = -4						; size = 4
_mode$ = 8						; size = 4
_EAGetLargestKeyForMode@4 PROC				; COMDAT

; 591  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 592  : 	int ea, key = 0;

  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _key$[ebp], 0

; 593  : 
; 594  : 	for (ea = EAGetFirst (); ea != 0; ea = EAGetNext (ea))

  0000f	e8 00 00 00 00	 call	 _EAGetFirst@0
  00014	89 45 f8	 mov	 DWORD PTR _ea$[ebp], eax
  00017	eb 0c		 jmp	 SHORT $LN5@EAGetLarge
$LN4@EAGetLarge:
  00019	8b 45 f8	 mov	 eax, DWORD PTR _ea$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _EAGetNext@4
  00022	89 45 f8	 mov	 DWORD PTR _ea$[ebp], eax
$LN5@EAGetLarge:
  00025	83 7d f8 00	 cmp	 DWORD PTR _ea$[ebp], 0
  00029	74 2f		 je	 SHORT $LN3@EAGetLarge

; 595  : 	{
; 596  : 		if (!EAIsModeSupported (ea, mode))

  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _mode$[ebp]
  0002e	51		 push	 ecx
  0002f	8b 55 f8	 mov	 edx, DWORD PTR _ea$[ebp]
  00032	52		 push	 edx
  00033	e8 00 00 00 00	 call	 _EAIsModeSupported@8
  00038	85 c0		 test	 eax, eax
  0003a	75 02		 jne	 SHORT $LN2@EAGetLarge

; 597  : 			continue;

  0003c	eb db		 jmp	 SHORT $LN4@EAGetLarge
$LN2@EAGetLarge:

; 598  : 
; 599  : 		if (EAGetKeySize (ea) >= key)

  0003e	8b 45 f8	 mov	 eax, DWORD PTR _ea$[ebp]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 _EAGetKeySize@4
  00047	3b 45 fc	 cmp	 eax, DWORD PTR _key$[ebp]
  0004a	7c 0c		 jl	 SHORT $LN1@EAGetLarge

; 600  : 			key = EAGetKeySize (ea);

  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _ea$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 _EAGetKeySize@4
  00055	89 45 fc	 mov	 DWORD PTR _key$[ebp], eax
$LN1@EAGetLarge:

; 601  : 	}

  00058	eb bf		 jmp	 SHORT $LN4@EAGetLarge
$LN3@EAGetLarge:

; 602  : 	return key;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _key$[ebp]

; 603  : }

  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
_EAGetLargestKeyForMode@4 ENDP
_TEXT	ENDS
PUBLIC	_EAGetLargestKey@0
; Function compile flags: /Odtp
;	COMDAT _EAGetLargestKey@0
_TEXT	SEGMENT
_ea$ = -8						; size = 4
_key$ = -4						; size = 4
_EAGetLargestKey@0 PROC					; COMDAT

; 608  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 609  : 	int ea, key = 0;

  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _key$[ebp], 0

; 610  : 
; 611  : 	for (ea = EAGetFirst (); ea != 0; ea = EAGetNext (ea))

  0000f	e8 00 00 00 00	 call	 _EAGetFirst@0
  00014	89 45 f8	 mov	 DWORD PTR _ea$[ebp], eax
  00017	eb 0c		 jmp	 SHORT $LN4@EAGetLarge@2
$LN3@EAGetLarge@2:
  00019	8b 45 f8	 mov	 eax, DWORD PTR _ea$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _EAGetNext@4
  00022	89 45 f8	 mov	 DWORD PTR _ea$[ebp], eax
$LN4@EAGetLarge@2:
  00025	83 7d f8 00	 cmp	 DWORD PTR _ea$[ebp], 0
  00029	74 1c		 je	 SHORT $LN2@EAGetLarge@2

; 612  : 	{
; 613  : 		if (EAGetKeySize (ea) >= key)

  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _ea$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 _EAGetKeySize@4
  00034	3b 45 fc	 cmp	 eax, DWORD PTR _key$[ebp]
  00037	7c 0c		 jl	 SHORT $LN1@EAGetLarge@2

; 614  : 			key = EAGetKeySize (ea);

  00039	8b 55 f8	 mov	 edx, DWORD PTR _ea$[ebp]
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 _EAGetKeySize@4
  00042	89 45 fc	 mov	 DWORD PTR _key$[ebp], eax
$LN1@EAGetLarge@2:

; 615  : 	}

  00045	eb d2		 jmp	 SHORT $LN3@EAGetLarge@2
$LN2@EAGetLarge@2:

; 616  : 
; 617  : 	return key;

  00047	8b 45 fc	 mov	 eax, DWORD PTR _key$[ebp]

; 618  : }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_EAGetLargestKey@0 ENDP
_TEXT	ENDS
PUBLIC	_EAGetCipherCount@4
; Function compile flags: /Odtp
;	COMDAT _EAGetCipherCount@4
_TEXT	SEGMENT
_i$ = -4						; size = 4
_ea$ = 8						; size = 4
_EAGetCipherCount@4 PROC				; COMDAT

; 623  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 624  : 	int i = 0;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN2@EAGetCiphe:

; 625  : 	while (EncryptionAlgorithms[ea].Ciphers[i++]);

  0000d	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00010	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00016	8b 94 88 00 00
	00 00		 mov	 edx, DWORD PTR _EncryptionAlgorithms[eax+ecx*4]
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00020	83 c0 01	 add	 eax, 1
  00023	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00026	85 d2		 test	 edx, edx
  00028	74 02		 je	 SHORT $LN1@EAGetCiphe
  0002a	eb e1		 jmp	 SHORT $LN2@EAGetCiphe
$LN1@EAGetCiphe:

; 626  : 
; 627  : 	return i - 1;

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0002f	83 e8 01	 sub	 eax, 1

; 628  : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
_EAGetCipherCount@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _EAGetFirstCipher@4
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_EAGetFirstCipher@4 PROC				; COMDAT

; 632  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 633  : 	return EncryptionAlgorithms[ea].Ciphers[0];

  00005	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00008	6b c0 2c	 imul	 eax, 44			; 0000002cH
  0000b	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax]

; 634  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
_EAGetFirstCipher@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _EAGetLastCipher@4
_TEXT	SEGMENT
_c$ = -8						; size = 4
_i$ = -4						; size = 4
_ea$ = 8						; size = 4
_EAGetLastCipher@4 PROC					; COMDAT

; 638  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 639  : 	int c, i = 0;

  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN2@EAGetLastC:

; 640  : 	while (c = EncryptionAlgorithms[ea].Ciphers[i++]);

  0000f	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00012	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00018	8b 94 88 00 00
	00 00		 mov	 edx, DWORD PTR _EncryptionAlgorithms[eax+ecx*4]
  0001f	89 55 f8	 mov	 DWORD PTR _c$[ebp], edx
  00022	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00028	83 c1 01	 add	 ecx, 1
  0002b	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  0002e	85 c0		 test	 eax, eax
  00030	74 02		 je	 SHORT $LN1@EAGetLastC
  00032	eb db		 jmp	 SHORT $LN2@EAGetLastC
$LN1@EAGetLastC:

; 641  : 
; 642  : 	return EncryptionAlgorithms[ea].Ciphers[i - 2];

  00034	8b 55 08	 mov	 edx, DWORD PTR _ea$[ebp]
  00037	6b d2 2c	 imul	 edx, 44			; 0000002cH
  0003a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0003d	8b 84 82 f8 ff
	ff ff		 mov	 eax, DWORD PTR _EncryptionAlgorithms[edx+eax*4-8]

; 643  : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
_EAGetLastCipher@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _EAGetNextCipher@8
_TEXT	SEGMENT
_c$ = -8						; size = 4
_i$ = -4						; size = 4
_ea$ = 8						; size = 4
_previousCipherId$ = 12					; size = 4
_EAGetNextCipher@8 PROC					; COMDAT

; 647  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 648  : 	int c, i = 0;

  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN3@EAGetNextC:

; 649  : 	while (c = EncryptionAlgorithms[ea].Ciphers[i++])

  0000f	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00012	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00018	8b 94 88 00 00
	00 00		 mov	 edx, DWORD PTR _EncryptionAlgorithms[eax+ecx*4]
  0001f	89 55 f8	 mov	 DWORD PTR _c$[ebp], edx
  00022	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00028	83 c1 01	 add	 ecx, 1
  0002b	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  0002e	85 c0		 test	 eax, eax
  00030	74 1c		 je	 SHORT $LN2@EAGetNextC

; 650  : 	{
; 651  : 		if (c == previousCipherId) 

  00032	8b 55 f8	 mov	 edx, DWORD PTR _c$[ebp]
  00035	3b 55 0c	 cmp	 edx, DWORD PTR _previousCipherId$[ebp]
  00038	75 12		 jne	 SHORT $LN1@EAGetNextC

; 652  : 			return EncryptionAlgorithms[ea].Ciphers[i];

  0003a	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  0003d	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00040	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00043	8b 84 88 00 00
	00 00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax+ecx*4]
  0004a	eb 04		 jmp	 SHORT $LN4@EAGetNextC
$LN1@EAGetNextC:

; 653  : 	}

  0004c	eb c1		 jmp	 SHORT $LN3@EAGetNextC
$LN2@EAGetNextC:

; 654  : 
; 655  : 	return 0;

  0004e	33 c0		 xor	 eax, eax
$LN4@EAGetNextC:

; 656  : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
_EAGetNextCipher@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _EAGetPreviousCipher@8
_TEXT	SEGMENT
_c$ = -8						; size = 4
_i$ = -4						; size = 4
_ea$ = 8						; size = 4
_previousCipherId$ = 12					; size = 4
_EAGetPreviousCipher@8 PROC				; COMDAT

; 660  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 661  : 	int c, i = 0;

  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 662  : 
; 663  : 	if (EncryptionAlgorithms[ea].Ciphers[i++] == previousCipherId)

  0000f	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00012	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00018	8b 94 88 00 00
	00 00		 mov	 edx, DWORD PTR _EncryptionAlgorithms[eax+ecx*4]
  0001f	8b 45 0c	 mov	 eax, DWORD PTR _previousCipherId$[ebp]
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00025	83 c1 01	 add	 ecx, 1
  00028	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  0002b	3b d0		 cmp	 edx, eax
  0002d	75 04		 jne	 SHORT $LN3@EAGetPrevi

; 664  : 		return 0;

  0002f	33 c0		 xor	 eax, eax
  00031	eb 41		 jmp	 SHORT $LN5@EAGetPrevi
$LN3@EAGetPrevi:

; 665  : 
; 666  : 	while (c = EncryptionAlgorithms[ea].Ciphers[i++])

  00033	8b 55 08	 mov	 edx, DWORD PTR _ea$[ebp]
  00036	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00039	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0003c	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR _EncryptionAlgorithms[edx+eax*4]
  00043	89 4d f8	 mov	 DWORD PTR _c$[ebp], ecx
  00046	8b 55 f8	 mov	 edx, DWORD PTR _c$[ebp]
  00049	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0004c	83 c0 01	 add	 eax, 1
  0004f	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00052	85 d2		 test	 edx, edx
  00054	74 1c		 je	 SHORT $LN2@EAGetPrevi

; 667  : 	{
; 668  : 		if (c == previousCipherId) 

  00056	8b 4d f8	 mov	 ecx, DWORD PTR _c$[ebp]
  00059	3b 4d 0c	 cmp	 ecx, DWORD PTR _previousCipherId$[ebp]
  0005c	75 12		 jne	 SHORT $LN1@EAGetPrevi

; 669  : 			return EncryptionAlgorithms[ea].Ciphers[i - 2];

  0005e	8b 55 08	 mov	 edx, DWORD PTR _ea$[ebp]
  00061	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00064	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00067	8b 84 82 f8 ff
	ff ff		 mov	 eax, DWORD PTR _EncryptionAlgorithms[edx+eax*4-8]
  0006e	eb 04		 jmp	 SHORT $LN5@EAGetPrevi
$LN1@EAGetPrevi:

; 670  : 	}

  00070	eb c1		 jmp	 SHORT $LN3@EAGetPrevi
$LN2@EAGetPrevi:

; 671  : 
; 672  : 	return 0;

  00072	33 c0		 xor	 eax, eax
$LN5@EAGetPrevi:

; 673  : }

  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 08 00	 ret	 8
_EAGetPreviousCipher@8 ENDP
_TEXT	ENDS
PUBLIC	_EAIsFormatEnabled@4
; Function compile flags: /Odtp
;	COMDAT _EAIsFormatEnabled@4
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_EAIsFormatEnabled@4 PROC				; COMDAT

; 677  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 678  : 	return EncryptionAlgorithms[ea].FormatEnabled;

  00005	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00008	6b c0 2c	 imul	 eax, 44			; 0000002cH
  0000b	8b 80 28 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax+40]

; 679  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
_EAIsFormatEnabled@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _EAIsModeSupported@8
_TEXT	SEGMENT
_mode$ = -4						; size = 4
_ea$ = 8						; size = 4
_testedMode$ = 12					; size = 4
_EAIsModeSupported@8 PROC				; COMDAT

; 684  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 685  : 	int mode;
; 686  : 
; 687  : 	for (mode = EAGetFirstMode (ea); mode != 0; mode = EAGetNextMode (ea, mode))

  00006	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _EAGetFirstMode@4
  0000f	89 45 fc	 mov	 DWORD PTR _mode$[ebp], eax
  00012	eb 10		 jmp	 SHORT $LN4@EAIsModeSu
$LN3@EAIsModeSu:
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _mode$[ebp]
  00017	51		 push	 ecx
  00018	8b 55 08	 mov	 edx, DWORD PTR _ea$[ebp]
  0001b	52		 push	 edx
  0001c	e8 00 00 00 00	 call	 _EAGetNextMode@8
  00021	89 45 fc	 mov	 DWORD PTR _mode$[ebp], eax
$LN4@EAIsModeSu:
  00024	83 7d fc 00	 cmp	 DWORD PTR _mode$[ebp], 0
  00028	74 11		 je	 SHORT $LN2@EAIsModeSu

; 688  : 	{
; 689  : 		if (mode == testedMode)

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _mode$[ebp]
  0002d	3b 45 0c	 cmp	 eax, DWORD PTR _testedMode$[ebp]
  00030	75 07		 jne	 SHORT $LN1@EAIsModeSu

; 690  : 			return TRUE;

  00032	b8 01 00 00 00	 mov	 eax, 1
  00037	eb 04		 jmp	 SHORT $LN5@EAIsModeSu
$LN1@EAIsModeSu:

; 691  : 	}

  00039	eb d9		 jmp	 SHORT $LN3@EAIsModeSu
$LN2@EAIsModeSu:

; 692  : 	return FALSE;

  0003b	33 c0		 xor	 eax, eax
$LN5@EAIsModeSu:

; 693  : }

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 08 00	 ret	 8
_EAIsModeSupported@8 ENDP
_TEXT	ENDS
PUBLIC	_HashGet@4
; Function compile flags: /Odtp
;	COMDAT _HashGet@4
_TEXT	SEGMENT
_i$ = -4						; size = 4
_id$ = 8						; size = 4
_HashGet@4 PROC						; COMDAT

; 697  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 698  : 	int i;
; 699  : 	for (i = 0; Hashes[i].Id != 0; i++)

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000d	eb 09		 jmp	 SHORT $LN4@HashGet
$LN3@HashGet:
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00012	83 c0 01	 add	 eax, 1
  00015	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@HashGet:
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0001b	c1 e1 04	 shl	 ecx, 4
  0001e	83 b9 00 00 00
	00 00		 cmp	 DWORD PTR _Hashes[ecx], 0
  00025	74 20		 je	 SHORT $LN2@HashGet

; 700  : 		if (Hashes[i].Id == id)

  00027	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0002a	c1 e2 04	 shl	 edx, 4
  0002d	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _Hashes[edx]
  00033	3b 45 08	 cmp	 eax, DWORD PTR _id$[ebp]
  00036	75 0d		 jne	 SHORT $LN1@HashGet

; 701  : 			return &Hashes[i];

  00038	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0003b	c1 e0 04	 shl	 eax, 4
  0003e	05 00 00 00 00	 add	 eax, OFFSET _Hashes
  00043	eb 04		 jmp	 SHORT $LN5@HashGet
$LN1@HashGet:

; 702  : 
; 703  : 	return 0;

  00045	eb c8		 jmp	 SHORT $LN3@HashGet
$LN2@HashGet:
  00047	33 c0		 xor	 eax, eax
$LN5@HashGet:

; 704  : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
_HashGet@4 ENDP
_TEXT	ENDS
PUBLIC	_HashGetIdByName@4
; Function compile flags: /Odtp
;	COMDAT _HashGetIdByName@4
_TEXT	SEGMENT
tv74 = -24						; size = 4
tv131 = -20						; size = 4
tv94 = -14						; size = 1
tv87 = -13						; size = 1
tv81 = -12						; size = 4
tv83 = -8						; size = 4
_i$ = -4						; size = 4
_name$ = 8						; size = 4
_HashGetIdByName@4 PROC					; COMDAT

; 708  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 18	 sub	 esp, 24			; 00000018H

; 709  : 	int i;
; 710  : 	for (i = 0; Hashes[i].Id != 0; i++)

  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000f	eb 09		 jmp	 SHORT $LN4@HashGetIdB
$LN3@HashGetIdB:
  00011	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00014	83 c0 01	 add	 eax, 1
  00017	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@HashGetIdB:
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0001d	c1 e1 04	 shl	 ecx, 4
  00020	83 b9 00 00 00
	00 00		 cmp	 DWORD PTR _Hashes[ecx], 0
  00027	74 79		 je	 SHORT $LN2@HashGetIdB

; 711  : 		if (strcmp (Hashes[i].Name, name) == 0)

  00029	8b 55 08	 mov	 edx, DWORD PTR _name$[ebp]
  0002c	89 55 f8	 mov	 DWORD PTR tv83[ebp], edx
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00032	c1 e0 04	 shl	 eax, 4
  00035	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR _Hashes[eax+4]
  0003b	89 4d f4	 mov	 DWORD PTR tv81[ebp], ecx
$LL7@HashGetIdB:
  0003e	8b 55 f4	 mov	 edx, DWORD PTR tv81[ebp]
  00041	8a 02		 mov	 al, BYTE PTR [edx]
  00043	88 45 f3	 mov	 BYTE PTR tv87[ebp], al
  00046	8b 4d f8	 mov	 ecx, DWORD PTR tv83[ebp]
  00049	3a 01		 cmp	 al, BYTE PTR [ecx]
  0004b	75 2e		 jne	 SHORT $LN8@HashGetIdB
  0004d	80 7d f3 00	 cmp	 BYTE PTR tv87[ebp], 0
  00051	74 1f		 je	 SHORT $LN9@HashGetIdB
  00053	8b 55 f4	 mov	 edx, DWORD PTR tv81[ebp]
  00056	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  00059	88 45 f2	 mov	 BYTE PTR tv94[ebp], al
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR tv83[ebp]
  0005f	3a 41 01	 cmp	 al, BYTE PTR [ecx+1]
  00062	75 17		 jne	 SHORT $LN8@HashGetIdB
  00064	83 45 f4 02	 add	 DWORD PTR tv81[ebp], 2
  00068	83 45 f8 02	 add	 DWORD PTR tv83[ebp], 2
  0006c	80 7d f2 00	 cmp	 BYTE PTR tv94[ebp], 0
  00070	75 cc		 jne	 SHORT $LL7@HashGetIdB
$LN9@HashGetIdB:
  00072	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv131[ebp], 0
  00079	eb 08		 jmp	 SHORT $LN10@HashGetIdB
$LN8@HashGetIdB:
  0007b	1b d2		 sbb	 edx, edx
  0007d	83 da ff	 sbb	 edx, -1
  00080	89 55 ec	 mov	 DWORD PTR tv131[ebp], edx
$LN10@HashGetIdB:
  00083	8b 45 ec	 mov	 eax, DWORD PTR tv131[ebp]
  00086	89 45 e8	 mov	 DWORD PTR tv74[ebp], eax
  00089	83 7d e8 00	 cmp	 DWORD PTR tv74[ebp], 0
  0008d	75 0e		 jne	 SHORT $LN1@HashGetIdB

; 712  : 			return Hashes[i].Id;

  0008f	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00092	c1 e1 04	 shl	 ecx, 4
  00095	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _Hashes[ecx]
  0009b	eb 07		 jmp	 SHORT $LN5@HashGetIdB
$LN1@HashGetIdB:

; 713  : 
; 714  : 	return 0;

  0009d	e9 6f ff ff ff	 jmp	 $LN3@HashGetIdB
$LN2@HashGetIdB:
  000a2	33 c0		 xor	 eax, eax
$LN5@HashGetIdB:

; 715  : }

  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 04 00	 ret	 4
_HashGetIdByName@4 ENDP
_TEXT	ENDS
PUBLIC	_HashGetName@4
; Function compile flags: /Odtp
;	COMDAT _HashGetName@4
_TEXT	SEGMENT
_hashId$ = 8						; size = 4
_HashGetName@4 PROC					; COMDAT

; 719  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 720  : 	return HashGet (hashId) -> Name;

  00005	8b 45 08	 mov	 eax, DWORD PTR _hashId$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _HashGet@4
  0000e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 721  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
_HashGetName@4 ENDP
_TEXT	ENDS
PUBLIC	_HashIsDeprecated@4
; Function compile flags: /Odtp
;	COMDAT _HashIsDeprecated@4
_TEXT	SEGMENT
_hashId$ = 8						; size = 4
_HashIsDeprecated@4 PROC				; COMDAT

; 725  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 726  : 	return HashGet (hashId) -> Deprecated;

  00005	8b 45 08	 mov	 eax, DWORD PTR _hashId$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _HashGet@4
  0000e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 727  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
_HashIsDeprecated@4 ENDP
_TEXT	ENDS
PUBLIC	_crypto_open@0
EXTRN	__imp__ExAllocatePoolWithTag@12:PROC
EXTRN	_memset:PROC
; Function compile flags: /Odtp
;	COMDAT _crypto_open@0
_TEXT	SEGMENT
_cryptoInfo$ = -4					; size = 4
_crypto_open@0 PROC					; COMDAT

; 741  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 742  : #ifndef TC_WINDOWS_BOOT
; 743  : 
; 744  : 	/* Do the crt allocation */
; 745  : 	PCRYPTO_INFO cryptoInfo = (PCRYPTO_INFO) TCalloc (sizeof (CRYPTO_INFO));

  00006	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0000b	68 68 44 00 00	 push	 17512			; 00004468H
  00010	6a 00		 push	 0
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00018	89 45 fc	 mov	 DWORD PTR _cryptoInfo$[ebp], eax

; 746  : 	if (cryptoInfo == NULL)

  0001b	83 7d fc 00	 cmp	 DWORD PTR _cryptoInfo$[ebp], 0
  0001f	75 04		 jne	 SHORT $LN1@crypto_ope

; 747  : 		return NULL;

  00021	33 c0		 xor	 eax, eax
  00023	eb 1f		 jmp	 SHORT $LN2@crypto_ope
$LN1@crypto_ope:

; 748  : 
; 749  : 	memset (cryptoInfo, 0, sizeof (CRYPTO_INFO));

  00025	68 68 44 00 00	 push	 17512			; 00004468H
  0002a	6a 00		 push	 0
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 _memset
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH

; 750  : 
; 751  : #ifndef DEVICE_DRIVER
; 752  : 	VirtualLock (cryptoInfo, sizeof (CRYPTO_INFO));
; 753  : #endif
; 754  : 
; 755  : 	cryptoInfo->ea = -1;

  00038	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  0003b	c7 01 ff ff ff
	ff		 mov	 DWORD PTR [ecx], -1

; 756  : 	return cryptoInfo;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
$LN2@crypto_ope:

; 757  : 
; 758  : #else // TC_WINDOWS_BOOT
; 759  : 
; 760  : #if 0
; 761  : 	if (CryptoInfoBufferInUse)
; 762  : 		TC_THROW_FATAL_EXCEPTION;
; 763  : #endif
; 764  : 	CryptoInfoBufferInUse = 1;
; 765  : 	return &CryptoInfoBuffer;
; 766  : 
; 767  : #endif // TC_WINDOWS_BOOT
; 768  : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_crypto_open@0 ENDP
_TEXT	ENDS
PUBLIC	_RtlSecureZeroMemory@8
PUBLIC	_crypto_loadkey@12
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
;	COMDAT _crypto_loadkey@12
_TEXT	SEGMENT
_burnm$27368 = -8					; size = 4
_burnc$27370 = -4					; size = 4
_keyInfo$ = 8						; size = 4
_lpszUserKey$ = 12					; size = 4
_nUserKeyLen$ = 16					; size = 4
_crypto_loadkey@12 PROC					; COMDAT

; 771  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 772  : 	keyInfo->keyLength = nUserKeyLen;

  00008	8b 45 08	 mov	 eax, DWORD PTR _keyInfo$[ebp]
  0000b	8b 4d 10	 mov	 ecx, DWORD PTR _nUserKeyLen$[ebp]
  0000e	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN5@crypto_loa:

; 773  : 	burn (keyInfo->userKey, sizeof (keyInfo->userKey));

  00011	8b 55 08	 mov	 edx, DWORD PTR _keyInfo$[ebp]
  00014	83 c2 08	 add	 edx, 8
  00017	89 55 f8	 mov	 DWORD PTR _burnm$27368[ebp], edx
  0001a	c7 45 fc 40 00
	00 00		 mov	 DWORD PTR _burnc$27370[ebp], 64 ; 00000040H
  00021	6a 40		 push	 64			; 00000040H
  00023	8b 45 08	 mov	 eax, DWORD PTR _keyInfo$[ebp]
  00026	83 c0 08	 add	 eax, 8
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@crypto_loa:
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _burnc$27370[ebp]
  00032	8b 55 fc	 mov	 edx, DWORD PTR _burnc$27370[ebp]
  00035	83 ea 01	 sub	 edx, 1
  00038	89 55 fc	 mov	 DWORD PTR _burnc$27370[ebp], edx
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 11		 je	 SHORT $LN4@crypto_loa
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _burnm$27368[ebp]
  00042	c6 00 00	 mov	 BYTE PTR [eax], 0
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _burnm$27368[ebp]
  00048	83 c1 01	 add	 ecx, 1
  0004b	89 4d f8	 mov	 DWORD PTR _burnm$27368[ebp], ecx
  0004e	eb df		 jmp	 SHORT $LN2@crypto_loa
$LN4@crypto_loa:
  00050	33 d2		 xor	 edx, edx
  00052	75 bd		 jne	 SHORT $LN5@crypto_loa

; 774  : 	memcpy (keyInfo->userKey, lpszUserKey, nUserKeyLen);

  00054	8b 45 10	 mov	 eax, DWORD PTR _nUserKeyLen$[ebp]
  00057	50		 push	 eax
  00058	8b 4d 0c	 mov	 ecx, DWORD PTR _lpszUserKey$[ebp]
  0005b	51		 push	 ecx
  0005c	8b 55 08	 mov	 edx, DWORD PTR _keyInfo$[ebp]
  0005f	83 c2 08	 add	 edx, 8
  00062	52		 push	 edx
  00063	e8 00 00 00 00	 call	 _memcpy
  00068	83 c4 0c	 add	 esp, 12			; 0000000cH

; 775  : }

  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 0c 00	 ret	 12			; 0000000cH
_crypto_loadkey@12 ENDP
; Function compile flags: /Odtp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT _RtlSecureZeroMemory@8
_TEXT	SEGMENT
_vptr$ = -4						; size = 4
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory@8 PROC				; COMDAT

; 8322 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 8323 :     volatile char *vptr = (volatile char *)ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _vptr$[ebp], eax
$LN2@RtlSecureZ:

; 8324 : 
; 8325 : #if defined(_M_AMD64)
; 8326 : 
; 8327 :         __stosb((PUCHAR)((ULONG64)vptr), 0, cnt);
; 8328 : 
; 8329 : #else
; 8330 : 
; 8331 :     while (cnt) {

  0000c	83 7d 0c 00	 cmp	 DWORD PTR _cnt$[ebp], 0
  00010	74 1a		 je	 SHORT $LN1@RtlSecureZ

; 8332 :         *vptr = 0;

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _vptr$[ebp]
  00015	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 8333 :         vptr++;

  00018	8b 55 fc	 mov	 edx, DWORD PTR _vptr$[ebp]
  0001b	83 c2 01	 add	 edx, 1
  0001e	89 55 fc	 mov	 DWORD PTR _vptr$[ebp], edx

; 8334 :         cnt--;

  00021	8b 45 0c	 mov	 eax, DWORD PTR _cnt$[ebp]
  00024	83 e8 01	 sub	 eax, 1
  00027	89 45 0c	 mov	 DWORD PTR _cnt$[ebp], eax

; 8335 :     }

  0002a	eb e0		 jmp	 SHORT $LN2@RtlSecureZ
$LN1@RtlSecureZ:

; 8336 : 
; 8337 : #endif
; 8338 : 
; 8339 :     return ptr;

  0002c	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]

; 8340 : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
_RtlSecureZeroMemory@8 ENDP
_TEXT	ENDS
PUBLIC	_crypto_close@4
EXTRN	__imp__ExFreePoolWithTag@8:PROC
; Function compile flags: /Odtp
; File c:\home\public\desktop\projects\ciphershed.build\src\common\crypto.c
;	COMDAT _crypto_close@4
_TEXT	SEGMENT
_burnm$27382 = -8					; size = 4
_burnc$27384 = -4					; size = 4
_cryptoInfo$ = 8					; size = 4
_crypto_close@4 PROC					; COMDAT

; 778  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 779  : #ifndef TC_WINDOWS_BOOT
; 780  : 
; 781  : 	if (cryptoInfo != NULL)

  00008	83 7d 08 00	 cmp	 DWORD PTR _cryptoInfo$[ebp], 0
  0000c	74 4f		 je	 SHORT $LN7@crypto_clo
$LN5@crypto_clo:

; 782  : 	{
; 783  : 		burn (cryptoInfo, sizeof (CRYPTO_INFO));

  0000e	8b 45 08	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00011	89 45 f8	 mov	 DWORD PTR _burnm$27382[ebp], eax
  00014	c7 45 fc 68 44
	00 00		 mov	 DWORD PTR _burnc$27384[ebp], 17512 ; 00004468H
  0001b	68 68 44 00 00	 push	 17512			; 00004468H
  00020	8b 4d 08	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@crypto_clo:
  00029	8b 55 fc	 mov	 edx, DWORD PTR _burnc$27384[ebp]
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _burnc$27384[ebp]
  0002f	83 e8 01	 sub	 eax, 1
  00032	89 45 fc	 mov	 DWORD PTR _burnc$27384[ebp], eax
  00035	85 d2		 test	 edx, edx
  00037	74 11		 je	 SHORT $LN4@crypto_clo
  00039	8b 4d f8	 mov	 ecx, DWORD PTR _burnm$27382[ebp]
  0003c	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0003f	8b 55 f8	 mov	 edx, DWORD PTR _burnm$27382[ebp]
  00042	83 c2 01	 add	 edx, 1
  00045	89 55 f8	 mov	 DWORD PTR _burnm$27382[ebp], edx
  00048	eb df		 jmp	 SHORT $LN2@crypto_clo
$LN4@crypto_clo:
  0004a	33 c0		 xor	 eax, eax
  0004c	75 c0		 jne	 SHORT $LN5@crypto_clo

; 784  : #ifndef DEVICE_DRIVER
; 785  : 		VirtualUnlock (cryptoInfo, sizeof (CRYPTO_INFO));
; 786  : #endif
; 787  : 		TCfree (cryptoInfo);

  0004e	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00053	8b 4d 08	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00056	51		 push	 ecx
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN7@crypto_clo:

; 788  : 	}
; 789  : 
; 790  : #else // TC_WINDOWS_BOOT
; 791  : 
; 792  : 	burn (&CryptoInfoBuffer, sizeof (CryptoInfoBuffer));
; 793  : 	CryptoInfoBufferInUse = FALSE;
; 794  : 
; 795  : #endif // TC_WINDOWS_BOOT
; 796  : }

  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
_crypto_close@4 ENDP
_TEXT	ENDS
PUBLIC	_Xor128@8
; Function compile flags: /Odtp
;	COMDAT _Xor128@8
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_Xor128@8 PROC						; COMDAT

; 804  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 805  : 	*a++ ^= *b++;

  00005	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  0000b	8b 10		 mov	 edx, DWORD PTR [eax]
  0000d	33 11		 xor	 edx, DWORD PTR [ecx]
  0000f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00012	33 41 04	 xor	 eax, DWORD PTR [ecx+4]
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00018	89 11		 mov	 DWORD PTR [ecx], edx
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0001d	8b 55 0c	 mov	 edx, DWORD PTR _b$[ebp]
  00020	83 c2 08	 add	 edx, 8
  00023	89 55 0c	 mov	 DWORD PTR _b$[ebp], edx
  00026	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00029	83 c0 08	 add	 eax, 8
  0002c	89 45 08	 mov	 DWORD PTR _a$[ebp], eax

; 806  : 	*a ^= *b;

  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00032	8b 55 0c	 mov	 edx, DWORD PTR _b$[ebp]
  00035	8b 01		 mov	 eax, DWORD PTR [ecx]
  00037	33 02		 xor	 eax, DWORD PTR [edx]
  00039	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0003c	33 4a 04	 xor	 ecx, DWORD PTR [edx+4]
  0003f	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00042	89 02		 mov	 DWORD PTR [edx], eax
  00044	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 807  : }

  00047	5d		 pop	 ebp
  00048	c2 08 00	 ret	 8
_Xor128@8 ENDP
_TEXT	ENDS
PUBLIC	_Xor64@8
; Function compile flags: /Odtp
;	COMDAT _Xor64@8
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_Xor64@8 PROC						; COMDAT

; 811  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 812  : 	*a ^= *b;

  00005	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  0000b	8b 10		 mov	 edx, DWORD PTR [eax]
  0000d	33 11		 xor	 edx, DWORD PTR [ecx]
  0000f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00012	33 41 04	 xor	 eax, DWORD PTR [ecx+4]
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00018	89 11		 mov	 DWORD PTR [ecx], edx
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 813  : }

  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
_Xor64@8 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_EncryptBufferLRW128@24
EXTRN	_Gf128MulBy64Tab@12:PROC
EXTRN	_MirrorBytes64@8:PROC
EXTRN	__aullshr:PROC
EXTRN	__aullrem:PROC
; Function compile flags: /Odtp
;	COMDAT _EncryptBufferLRW128@24
_TEXT	SEGMENT
tv205 = -76						; size = 8
tv185 = -68						; size = 8
_burnm$27440 = -60					; size = 4
_burnc$27442 = -56					; size = 4
_cipher$ = -52						; size = 4
_cipherCount$ = -48					; size = 4
_t$ = -44						; size = 16
_ks$ = -28						; size = 4
_b$ = -24						; size = 8
_i$ = -16						; size = 8
__$ArrayPad$ = -8					; size = 4
_p$ = -4						; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_blockIndex$ = 20					; size = 8
_cryptoInfo$ = 28					; size = 4
_EncryptBufferLRW128@24 PROC				; COMDAT

; 817  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 818  : 	/* Deprecated/legacy */
; 819  : 
; 820  : 	int cipher = EAGetFirstCipher (cryptoInfo->ea);

  00012	8b 45 1c	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  0001d	89 45 cc	 mov	 DWORD PTR _cipher$[ebp], eax

; 821  : 	int cipherCount = EAGetCipherCount (cryptoInfo->ea);

  00020	8b 55 1c	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00023	8b 02		 mov	 eax, DWORD PTR [edx]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _EAGetCipherCount@4
  0002b	89 45 d0	 mov	 DWORD PTR _cipherCount$[ebp], eax

; 822  : 	unsigned __int8 *p = buffer;

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00031	89 4d fc	 mov	 DWORD PTR _p$[ebp], ecx

; 823  : 	unsigned __int8 *ks = cryptoInfo->ks;

  00034	8b 55 1c	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00037	83 c2 08	 add	 edx, 8
  0003a	89 55 e4	 mov	 DWORD PTR _ks$[ebp], edx

; 824  : 	unsigned __int8 i[8];
; 825  : 	unsigned __int8 t[16];
; 826  : 	unsigned __int64 b;
; 827  : 
; 828  : 	*(unsigned __int64 *)i = BE64(blockIndex);

  0003d	8b 45 18	 mov	 eax, DWORD PTR _blockIndex$[ebp+4]
  00040	50		 push	 eax
  00041	8b 4d 14	 mov	 ecx, DWORD PTR _blockIndex$[ebp]
  00044	51		 push	 ecx
  00045	e8 00 00 00 00	 call	 _MirrorBytes64@8
  0004a	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
  0004d	89 55 f4	 mov	 DWORD PTR _i$[ebp+4], edx

; 829  : 
; 830  : 	if (length % 16)

  00050	6a 00		 push	 0
  00052	6a 10		 push	 16			; 00000010H
  00054	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp+4]
  00057	52		 push	 edx
  00058	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 __aullrem
  00061	89 45 bc	 mov	 DWORD PTR tv185[ebp], eax
  00064	89 55 c0	 mov	 DWORD PTR tv185[ebp+4], edx
  00067	8b 4d bc	 mov	 ecx, DWORD PTR tv185[ebp]
  0006a	0b 4d c0	 or	 ecx, DWORD PTR tv185[ebp+4]
  0006d	74 16		 je	 SHORT $LN16@EncryptBuf

; 831  : 		TC_THROW_FATAL_EXCEPTION;

  0006f	68 43 54 00 00	 push	 21571			; 00005443H
  00074	6a 00		 push	 0
  00076	6a 00		 push	 0
  00078	68 3f 03 00 00	 push	 831			; 0000033fH
  0007d	6a 29		 push	 41			; 00000029H
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN16@EncryptBuf:

; 832  : 
; 833  : 	// Note that the maximum supported volume size is 8589934592 GB  (i.e., 2^63 bytes).
; 834  : 
; 835  : 	for (b = 0; b < length >> 4; b++)

  00085	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _b$[ebp], 0
  0008c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _b$[ebp+4], 0
  00093	eb 12		 jmp	 SHORT $LN15@EncryptBuf
$LN14@EncryptBuf:
  00095	8b 55 e8	 mov	 edx, DWORD PTR _b$[ebp]
  00098	83 c2 01	 add	 edx, 1
  0009b	8b 45 ec	 mov	 eax, DWORD PTR _b$[ebp+4]
  0009e	83 d0 00	 adc	 eax, 0
  000a1	89 55 e8	 mov	 DWORD PTR _b$[ebp], edx
  000a4	89 45 ec	 mov	 DWORD PTR _b$[ebp+4], eax
$LN15@EncryptBuf:
  000a7	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  000aa	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp+4]
  000ad	b1 04		 mov	 cl, 4
  000af	e8 00 00 00 00	 call	 __aullshr
  000b4	89 45 b4	 mov	 DWORD PTR tv205[ebp], eax
  000b7	89 55 b8	 mov	 DWORD PTR tv205[ebp+4], edx
  000ba	8b 4d ec	 mov	 ecx, DWORD PTR _b$[ebp+4]
  000bd	3b 4d b8	 cmp	 ecx, DWORD PTR tv205[ebp+4]
  000c0	0f 87 ee 00 00
	00		 ja	 $LN5@EncryptBuf
  000c6	72 0c		 jb	 SHORT $LN19@EncryptBuf
  000c8	8b 55 e8	 mov	 edx, DWORD PTR _b$[ebp]
  000cb	3b 55 b4	 cmp	 edx, DWORD PTR tv205[ebp]
  000ce	0f 83 e0 00 00
	00		 jae	 $LN5@EncryptBuf
$LN19@EncryptBuf:

; 836  : 	{
; 837  : 		Gf128MulBy64Tab (i, t, &cryptoInfo->gf_ctx);

  000d4	8b 45 1c	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  000d7	05 a8 29 00 00	 add	 eax, 10664		; 000029a8H
  000dc	50		 push	 eax
  000dd	8d 4d d4	 lea	 ecx, DWORD PTR _t$[ebp]
  000e0	51		 push	 ecx
  000e1	8d 55 f0	 lea	 edx, DWORD PTR _i$[ebp]
  000e4	52		 push	 edx
  000e5	e8 00 00 00 00	 call	 _Gf128MulBy64Tab@12

; 838  : 		Xor128 ((unsigned __int64 *)p, (unsigned __int64 *)t);

  000ea	8d 45 d4	 lea	 eax, DWORD PTR _t$[ebp]
  000ed	50		 push	 eax
  000ee	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  000f1	51		 push	 ecx
  000f2	e8 00 00 00 00	 call	 _Xor128@8

; 839  : 
; 840  : 		if (cipherCount > 1)

  000f7	83 7d d0 01	 cmp	 DWORD PTR _cipherCount$[ebp], 1
  000fb	7e 55		 jle	 SHORT $LN12@EncryptBuf

; 841  : 		{
; 842  : 			// Cipher cascade
; 843  : 			for (cipher = EAGetFirstCipher (cryptoInfo->ea);
; 844  : 				cipher != 0;
; 845  : 				cipher = EAGetNextCipher (cryptoInfo->ea, cipher))

  000fd	8b 55 1c	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00100	8b 02		 mov	 eax, DWORD PTR [edx]
  00102	50		 push	 eax
  00103	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  00108	89 45 cc	 mov	 DWORD PTR _cipher$[ebp], eax
  0010b	eb 12		 jmp	 SHORT $LN11@EncryptBuf
$LN10@EncryptBuf:
  0010d	8b 4d cc	 mov	 ecx, DWORD PTR _cipher$[ebp]
  00110	51		 push	 ecx
  00111	8b 55 1c	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00114	8b 02		 mov	 eax, DWORD PTR [edx]
  00116	50		 push	 eax
  00117	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  0011c	89 45 cc	 mov	 DWORD PTR _cipher$[ebp], eax
$LN11@EncryptBuf:
  0011f	83 7d cc 00	 cmp	 DWORD PTR _cipher$[ebp], 0
  00123	74 22		 je	 SHORT $LN9@EncryptBuf

; 846  : 			{
; 847  : 				EncipherBlock (cipher, p, ks);

  00125	8b 4d e4	 mov	 ecx, DWORD PTR _ks$[ebp]
  00128	51		 push	 ecx
  00129	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  0012c	52		 push	 edx
  0012d	8b 45 cc	 mov	 eax, DWORD PTR _cipher$[ebp]
  00130	50		 push	 eax
  00131	e8 00 00 00 00	 call	 _EncipherBlock@12

; 848  : 				ks += CipherGetKeyScheduleSize (cipher);

  00136	8b 4d cc	 mov	 ecx, DWORD PTR _cipher$[ebp]
  00139	51		 push	 ecx
  0013a	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  0013f	03 45 e4	 add	 eax, DWORD PTR _ks$[ebp]
  00142	89 45 e4	 mov	 DWORD PTR _ks$[ebp], eax

; 849  : 			}

  00145	eb c6		 jmp	 SHORT $LN10@EncryptBuf
$LN9@EncryptBuf:

; 850  : 			ks = cryptoInfo->ks;

  00147	8b 55 1c	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  0014a	83 c2 08	 add	 edx, 8
  0014d	89 55 e4	 mov	 DWORD PTR _ks$[ebp], edx

; 851  : 		}
; 852  : 		else

  00150	eb 11		 jmp	 SHORT $LN8@EncryptBuf
$LN12@EncryptBuf:

; 853  : 		{
; 854  : 			EncipherBlock (cipher, p, ks);

  00152	8b 45 e4	 mov	 eax, DWORD PTR _ks$[ebp]
  00155	50		 push	 eax
  00156	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  00159	51		 push	 ecx
  0015a	8b 55 cc	 mov	 edx, DWORD PTR _cipher$[ebp]
  0015d	52		 push	 edx
  0015e	e8 00 00 00 00	 call	 _EncipherBlock@12
$LN8@EncryptBuf:

; 855  : 		}
; 856  : 
; 857  : 		Xor128 ((unsigned __int64 *)p, (unsigned __int64 *)t);

  00163	8d 45 d4	 lea	 eax, DWORD PTR _t$[ebp]
  00166	50		 push	 eax
  00167	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  0016a	51		 push	 ecx
  0016b	e8 00 00 00 00	 call	 _Xor128@8

; 858  : 
; 859  : 		p += 16;

  00170	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  00173	83 c2 10	 add	 edx, 16			; 00000010H
  00176	89 55 fc	 mov	 DWORD PTR _p$[ebp], edx

; 860  : 
; 861  : 		if (i[7] != 0xff)

  00179	0f b6 45 f7	 movzx	 eax, BYTE PTR _i$[ebp+7]
  0017d	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00182	74 0b		 je	 SHORT $LN7@EncryptBuf

; 862  : 			i[7]++;

  00184	8a 4d f7	 mov	 cl, BYTE PTR _i$[ebp+7]
  00187	80 c1 01	 add	 cl, 1
  0018a	88 4d f7	 mov	 BYTE PTR _i$[ebp+7], cl

; 863  : 		else

  0018d	eb 20		 jmp	 SHORT $LN6@EncryptBuf
$LN7@EncryptBuf:

; 864  : 			*(unsigned __int64 *)i = BE64 ( BE64(*(unsigned __int64 *)i) + 1 );

  0018f	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp+4]
  00192	52		 push	 edx
  00193	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00196	50		 push	 eax
  00197	e8 00 00 00 00	 call	 _MirrorBytes64@8
  0019c	83 c0 01	 add	 eax, 1
  0019f	83 d2 00	 adc	 edx, 0
  001a2	52		 push	 edx
  001a3	50		 push	 eax
  001a4	e8 00 00 00 00	 call	 _MirrorBytes64@8
  001a9	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
  001ac	89 55 f4	 mov	 DWORD PTR _i$[ebp+4], edx
$LN6@EncryptBuf:

; 865  : 	}

  001af	e9 e1 fe ff ff	 jmp	 $LN14@EncryptBuf
$LN5@EncryptBuf:

; 866  : 
; 867  : 	FAST_ERASE64 (t, sizeof(t));

  001b4	8d 4d d4	 lea	 ecx, DWORD PTR _t$[ebp]
  001b7	89 4d c4	 mov	 DWORD PTR _burnm$27440[ebp], ecx
  001ba	c7 45 c8 02 00
	00 00		 mov	 DWORD PTR _burnc$27442[ebp], 2
$LN2@EncryptBuf:
  001c1	8b 55 c8	 mov	 edx, DWORD PTR _burnc$27442[ebp]
  001c4	8b 45 c8	 mov	 eax, DWORD PTR _burnc$27442[ebp]
  001c7	83 e8 01	 sub	 eax, 1
  001ca	89 45 c8	 mov	 DWORD PTR _burnc$27442[ebp], eax
  001cd	85 d2		 test	 edx, edx
  001cf	74 1b		 je	 SHORT $LN4@EncryptBuf
  001d1	8b 4d c4	 mov	 ecx, DWORD PTR _burnm$27440[ebp]
  001d4	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  001da	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  001e1	8b 55 c4	 mov	 edx, DWORD PTR _burnm$27440[ebp]
  001e4	83 c2 08	 add	 edx, 8
  001e7	89 55 c4	 mov	 DWORD PTR _burnm$27440[ebp], edx
  001ea	eb d5		 jmp	 SHORT $LN2@EncryptBuf
$LN4@EncryptBuf:
  001ec	33 c0		 xor	 eax, eax
  001ee	75 c4		 jne	 SHORT $LN5@EncryptBuf
$LN18@EncryptBuf:

; 868  : }

  001f0	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f3	33 cd		 xor	 ecx, ebp
  001f5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001fa	8b e5		 mov	 esp, ebp
  001fc	5d		 pop	 ebp
  001fd	c2 18 00	 ret	 24			; 00000018H
_EncryptBufferLRW128@24 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_EncryptBufferLRW64@24
EXTRN	_Gf64MulTab@12:PROC
; Function compile flags: /Odtp
;	COMDAT _EncryptBufferLRW64@24
_TEXT	SEGMENT
tv186 = -64						; size = 8
tv166 = -56						; size = 8
_burnm$27478 = -48					; size = 4
_burnc$27480 = -44					; size = 4
_cipher$ = -40						; size = 4
_t$ = -36						; size = 8
_ks$ = -28						; size = 4
_b$ = -24						; size = 8
_i$ = -16						; size = 8
__$ArrayPad$ = -8					; size = 4
_p$ = -4						; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_blockIndex$ = 20					; size = 8
_cryptoInfo$ = 28					; size = 4
_EncryptBufferLRW64@24 PROC				; COMDAT

; 872  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 40	 sub	 esp, 64			; 00000040H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 873  : 	/* Deprecated/legacy */
; 874  : 
; 875  : 	int cipher = EAGetFirstCipher (cryptoInfo->ea);

  00012	8b 45 1c	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  0001d	89 45 d8	 mov	 DWORD PTR _cipher$[ebp], eax

; 876  : 	unsigned __int8 *p = buffer;

  00020	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00023	89 55 fc	 mov	 DWORD PTR _p$[ebp], edx

; 877  : 	unsigned __int8 *ks = cryptoInfo->ks;

  00026	8b 45 1c	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00029	83 c0 08	 add	 eax, 8
  0002c	89 45 e4	 mov	 DWORD PTR _ks$[ebp], eax

; 878  : 	unsigned __int8 i[8];
; 879  : 	unsigned __int8 t[8];
; 880  : 	unsigned __int64 b;
; 881  : 
; 882  : 	*(unsigned __int64 *)i = BE64(blockIndex);

  0002f	8b 4d 18	 mov	 ecx, DWORD PTR _blockIndex$[ebp+4]
  00032	51		 push	 ecx
  00033	8b 55 14	 mov	 edx, DWORD PTR _blockIndex$[ebp]
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 _MirrorBytes64@8
  0003c	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
  0003f	89 55 f4	 mov	 DWORD PTR _i$[ebp+4], edx

; 883  : 
; 884  : 	if (length % 8)

  00042	6a 00		 push	 0
  00044	6a 08		 push	 8
  00046	8b 45 10	 mov	 eax, DWORD PTR _length$[ebp+4]
  00049	50		 push	 eax
  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR _length$[ebp]
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 __aullrem
  00053	89 45 c8	 mov	 DWORD PTR tv166[ebp], eax
  00056	89 55 cc	 mov	 DWORD PTR tv166[ebp+4], edx
  00059	8b 55 c8	 mov	 edx, DWORD PTR tv166[ebp]
  0005c	0b 55 cc	 or	 edx, DWORD PTR tv166[ebp+4]
  0005f	74 16		 je	 SHORT $LN11@EncryptBuf@2

; 885  : 		TC_THROW_FATAL_EXCEPTION;

  00061	68 43 54 00 00	 push	 21571			; 00005443H
  00066	6a 00		 push	 0
  00068	6a 00		 push	 0
  0006a	68 75 03 00 00	 push	 885			; 00000375H
  0006f	6a 29		 push	 41			; 00000029H
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN11@EncryptBuf@2:

; 886  : 
; 887  : 	for (b = 0; b < length >> 3; b++)

  00077	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _b$[ebp], 0
  0007e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _b$[ebp+4], 0
  00085	eb 12		 jmp	 SHORT $LN10@EncryptBuf@2
$LN9@EncryptBuf@2:
  00087	8b 45 e8	 mov	 eax, DWORD PTR _b$[ebp]
  0008a	83 c0 01	 add	 eax, 1
  0008d	8b 4d ec	 mov	 ecx, DWORD PTR _b$[ebp+4]
  00090	83 d1 00	 adc	 ecx, 0
  00093	89 45 e8	 mov	 DWORD PTR _b$[ebp], eax
  00096	89 4d ec	 mov	 DWORD PTR _b$[ebp+4], ecx
$LN10@EncryptBuf@2:
  00099	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  0009c	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp+4]
  0009f	b1 03		 mov	 cl, 3
  000a1	e8 00 00 00 00	 call	 __aullshr
  000a6	89 45 c0	 mov	 DWORD PTR tv186[ebp], eax
  000a9	89 55 c4	 mov	 DWORD PTR tv186[ebp+4], edx
  000ac	8b 55 ec	 mov	 edx, DWORD PTR _b$[ebp+4]
  000af	3b 55 c4	 cmp	 edx, DWORD PTR tv186[ebp+4]
  000b2	0f 87 94 00 00
	00		 ja	 $LN5@EncryptBuf@2
  000b8	72 0c		 jb	 SHORT $LN14@EncryptBuf@2
  000ba	8b 45 e8	 mov	 eax, DWORD PTR _b$[ebp]
  000bd	3b 45 c0	 cmp	 eax, DWORD PTR tv186[ebp]
  000c0	0f 83 86 00 00
	00		 jae	 $LN5@EncryptBuf@2
$LN14@EncryptBuf@2:

; 888  : 	{
; 889  : 		Gf64MulTab (i, t, &cryptoInfo->gf_ctx);

  000c6	8b 4d 1c	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  000c9	81 c1 a8 29 00
	00		 add	 ecx, 10664		; 000029a8H
  000cf	51		 push	 ecx
  000d0	8d 55 dc	 lea	 edx, DWORD PTR _t$[ebp]
  000d3	52		 push	 edx
  000d4	8d 45 f0	 lea	 eax, DWORD PTR _i$[ebp]
  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 _Gf64MulTab@12

; 890  : 		Xor64 ((unsigned __int64 *)p, (unsigned __int64 *)t);

  000dd	8d 4d dc	 lea	 ecx, DWORD PTR _t$[ebp]
  000e0	51		 push	 ecx
  000e1	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  000e4	52		 push	 edx
  000e5	e8 00 00 00 00	 call	 _Xor64@8

; 891  : 
; 892  : 		EncipherBlock (cipher, p, ks);

  000ea	8b 45 e4	 mov	 eax, DWORD PTR _ks$[ebp]
  000ed	50		 push	 eax
  000ee	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  000f1	51		 push	 ecx
  000f2	8b 55 d8	 mov	 edx, DWORD PTR _cipher$[ebp]
  000f5	52		 push	 edx
  000f6	e8 00 00 00 00	 call	 _EncipherBlock@12

; 893  : 
; 894  : 		Xor64 ((unsigned __int64 *)p, (unsigned __int64 *)t);

  000fb	8d 45 dc	 lea	 eax, DWORD PTR _t$[ebp]
  000fe	50		 push	 eax
  000ff	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  00102	51		 push	 ecx
  00103	e8 00 00 00 00	 call	 _Xor64@8

; 895  : 
; 896  : 		p += 8;

  00108	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  0010b	83 c2 08	 add	 edx, 8
  0010e	89 55 fc	 mov	 DWORD PTR _p$[ebp], edx

; 897  : 
; 898  : 		if (i[7] != 0xff)

  00111	0f b6 45 f7	 movzx	 eax, BYTE PTR _i$[ebp+7]
  00115	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0011a	74 0b		 je	 SHORT $LN7@EncryptBuf@2

; 899  : 			i[7]++;

  0011c	8a 4d f7	 mov	 cl, BYTE PTR _i$[ebp+7]
  0011f	80 c1 01	 add	 cl, 1
  00122	88 4d f7	 mov	 BYTE PTR _i$[ebp+7], cl

; 900  : 		else

  00125	eb 20		 jmp	 SHORT $LN6@EncryptBuf@2
$LN7@EncryptBuf@2:

; 901  : 			*(unsigned __int64 *)i = BE64 ( BE64(*(unsigned __int64 *)i) + 1 );

  00127	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp+4]
  0012a	52		 push	 edx
  0012b	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0012e	50		 push	 eax
  0012f	e8 00 00 00 00	 call	 _MirrorBytes64@8
  00134	83 c0 01	 add	 eax, 1
  00137	83 d2 00	 adc	 edx, 0
  0013a	52		 push	 edx
  0013b	50		 push	 eax
  0013c	e8 00 00 00 00	 call	 _MirrorBytes64@8
  00141	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
  00144	89 55 f4	 mov	 DWORD PTR _i$[ebp+4], edx
$LN6@EncryptBuf@2:

; 902  : 	}

  00147	e9 3b ff ff ff	 jmp	 $LN9@EncryptBuf@2
$LN5@EncryptBuf@2:

; 903  : 
; 904  : 	FAST_ERASE64 (t, sizeof(t));

  0014c	8d 4d dc	 lea	 ecx, DWORD PTR _t$[ebp]
  0014f	89 4d d0	 mov	 DWORD PTR _burnm$27478[ebp], ecx
  00152	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _burnc$27480[ebp], 1
$LN2@EncryptBuf@2:
  00159	8b 55 d4	 mov	 edx, DWORD PTR _burnc$27480[ebp]
  0015c	8b 45 d4	 mov	 eax, DWORD PTR _burnc$27480[ebp]
  0015f	83 e8 01	 sub	 eax, 1
  00162	89 45 d4	 mov	 DWORD PTR _burnc$27480[ebp], eax
  00165	85 d2		 test	 edx, edx
  00167	74 1b		 je	 SHORT $LN4@EncryptBuf@2
  00169	8b 4d d0	 mov	 ecx, DWORD PTR _burnm$27478[ebp]
  0016c	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00172	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00179	8b 55 d0	 mov	 edx, DWORD PTR _burnm$27478[ebp]
  0017c	83 c2 08	 add	 edx, 8
  0017f	89 55 d0	 mov	 DWORD PTR _burnm$27478[ebp], edx
  00182	eb d5		 jmp	 SHORT $LN2@EncryptBuf@2
$LN4@EncryptBuf@2:
  00184	33 c0		 xor	 eax, eax
  00186	75 c4		 jne	 SHORT $LN5@EncryptBuf@2
$LN13@EncryptBuf@2:

; 905  : }

  00188	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018b	33 cd		 xor	 ecx, ebp
  0018d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00192	8b e5		 mov	 esp, ebp
  00194	5d		 pop	 ebp
  00195	c2 18 00	 ret	 24			; 00000018H
_EncryptBufferLRW64@24 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_DecryptBufferLRW128@24
; Function compile flags: /Odtp
;	COMDAT _DecryptBufferLRW128@24
_TEXT	SEGMENT
tv208 = -76						; size = 8
tv188 = -68						; size = 8
_burnm$27522 = -60					; size = 4
_burnc$27524 = -56					; size = 4
_cipher$ = -52						; size = 4
_cipherCount$ = -48					; size = 4
_t$ = -44						; size = 16
_ks$ = -28						; size = 4
_b$ = -24						; size = 8
_i$ = -16						; size = 8
__$ArrayPad$ = -8					; size = 4
_p$ = -4						; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_blockIndex$ = 20					; size = 8
_cryptoInfo$ = 28					; size = 4
_DecryptBufferLRW128@24 PROC				; COMDAT

; 909  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 910  : 	/* Deprecated/legacy */
; 911  : 
; 912  : 	int cipher = EAGetFirstCipher (cryptoInfo->ea);

  00012	8b 45 1c	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  0001d	89 45 cc	 mov	 DWORD PTR _cipher$[ebp], eax

; 913  : 	int cipherCount = EAGetCipherCount (cryptoInfo->ea);

  00020	8b 55 1c	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00023	8b 02		 mov	 eax, DWORD PTR [edx]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _EAGetCipherCount@4
  0002b	89 45 d0	 mov	 DWORD PTR _cipherCount$[ebp], eax

; 914  : 	unsigned __int8 *p = buffer;

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00031	89 4d fc	 mov	 DWORD PTR _p$[ebp], ecx

; 915  : 	unsigned __int8 *ks = cryptoInfo->ks;

  00034	8b 55 1c	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00037	83 c2 08	 add	 edx, 8
  0003a	89 55 e4	 mov	 DWORD PTR _ks$[ebp], edx

; 916  : 	unsigned __int8 i[8];
; 917  : 	unsigned __int8 t[16];
; 918  : 	unsigned __int64 b;
; 919  : 
; 920  : 	*(unsigned __int64 *)i = BE64(blockIndex);

  0003d	8b 45 18	 mov	 eax, DWORD PTR _blockIndex$[ebp+4]
  00040	50		 push	 eax
  00041	8b 4d 14	 mov	 ecx, DWORD PTR _blockIndex$[ebp]
  00044	51		 push	 ecx
  00045	e8 00 00 00 00	 call	 _MirrorBytes64@8
  0004a	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
  0004d	89 55 f4	 mov	 DWORD PTR _i$[ebp+4], edx

; 921  : 
; 922  : 	if (length % 16)

  00050	6a 00		 push	 0
  00052	6a 10		 push	 16			; 00000010H
  00054	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp+4]
  00057	52		 push	 edx
  00058	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 __aullrem
  00061	89 45 bc	 mov	 DWORD PTR tv188[ebp], eax
  00064	89 55 c0	 mov	 DWORD PTR tv188[ebp+4], edx
  00067	8b 4d bc	 mov	 ecx, DWORD PTR tv188[ebp]
  0006a	0b 4d c0	 or	 ecx, DWORD PTR tv188[ebp+4]
  0006d	74 16		 je	 SHORT $LN16@DecryptBuf

; 923  : 		TC_THROW_FATAL_EXCEPTION;

  0006f	68 43 54 00 00	 push	 21571			; 00005443H
  00074	6a 00		 push	 0
  00076	6a 00		 push	 0
  00078	68 9b 03 00 00	 push	 923			; 0000039bH
  0007d	6a 29		 push	 41			; 00000029H
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN16@DecryptBuf:

; 924  : 
; 925  : 	// Note that the maximum supported volume size is 8589934592 GB  (i.e., 2^63 bytes).
; 926  : 
; 927  : 	for (b = 0; b < length >> 4; b++)

  00085	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _b$[ebp], 0
  0008c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _b$[ebp+4], 0
  00093	eb 12		 jmp	 SHORT $LN15@DecryptBuf
$LN14@DecryptBuf:
  00095	8b 55 e8	 mov	 edx, DWORD PTR _b$[ebp]
  00098	83 c2 01	 add	 edx, 1
  0009b	8b 45 ec	 mov	 eax, DWORD PTR _b$[ebp+4]
  0009e	83 d0 00	 adc	 eax, 0
  000a1	89 55 e8	 mov	 DWORD PTR _b$[ebp], edx
  000a4	89 45 ec	 mov	 DWORD PTR _b$[ebp+4], eax
$LN15@DecryptBuf:
  000a7	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  000aa	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp+4]
  000ad	b1 04		 mov	 cl, 4
  000af	e8 00 00 00 00	 call	 __aullshr
  000b4	89 45 b4	 mov	 DWORD PTR tv208[ebp], eax
  000b7	89 55 b8	 mov	 DWORD PTR tv208[ebp+4], edx
  000ba	8b 4d ec	 mov	 ecx, DWORD PTR _b$[ebp+4]
  000bd	3b 4d b8	 cmp	 ecx, DWORD PTR tv208[ebp+4]
  000c0	0f 87 fc 00 00
	00		 ja	 $LN5@DecryptBuf
  000c6	72 0c		 jb	 SHORT $LN19@DecryptBuf
  000c8	8b 55 e8	 mov	 edx, DWORD PTR _b$[ebp]
  000cb	3b 55 b4	 cmp	 edx, DWORD PTR tv208[ebp]
  000ce	0f 83 ee 00 00
	00		 jae	 $LN5@DecryptBuf
$LN19@DecryptBuf:

; 928  : 	{
; 929  : 		Gf128MulBy64Tab (i, t, &cryptoInfo->gf_ctx);

  000d4	8b 45 1c	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  000d7	05 a8 29 00 00	 add	 eax, 10664		; 000029a8H
  000dc	50		 push	 eax
  000dd	8d 4d d4	 lea	 ecx, DWORD PTR _t$[ebp]
  000e0	51		 push	 ecx
  000e1	8d 55 f0	 lea	 edx, DWORD PTR _i$[ebp]
  000e4	52		 push	 edx
  000e5	e8 00 00 00 00	 call	 _Gf128MulBy64Tab@12

; 930  : 		Xor128 ((unsigned __int64 *)p, (unsigned __int64 *)t);

  000ea	8d 45 d4	 lea	 eax, DWORD PTR _t$[ebp]
  000ed	50		 push	 eax
  000ee	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  000f1	51		 push	 ecx
  000f2	e8 00 00 00 00	 call	 _Xor128@8

; 931  : 
; 932  : 		if (cipherCount > 1)

  000f7	83 7d d0 01	 cmp	 DWORD PTR _cipherCount$[ebp], 1
  000fb	7e 63		 jle	 SHORT $LN12@DecryptBuf

; 933  : 		{
; 934  : 			// Cipher cascade
; 935  : 			ks = cryptoInfo->ks + EAGetKeyScheduleSize (cryptoInfo->ea);

  000fd	8b 55 1c	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00100	8b 02		 mov	 eax, DWORD PTR [edx]
  00102	50		 push	 eax
  00103	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4
  00108	8b 4d 1c	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  0010b	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  0010f	89 55 e4	 mov	 DWORD PTR _ks$[ebp], edx

; 936  : 
; 937  : 			for (cipher = EAGetLastCipher (cryptoInfo->ea);
; 938  : 				cipher != 0;
; 939  : 				cipher = EAGetPreviousCipher (cryptoInfo->ea, cipher))

  00112	8b 45 1c	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00115	8b 08		 mov	 ecx, DWORD PTR [eax]
  00117	51		 push	 ecx
  00118	e8 00 00 00 00	 call	 _EAGetLastCipher@4
  0011d	89 45 cc	 mov	 DWORD PTR _cipher$[ebp], eax
  00120	eb 12		 jmp	 SHORT $LN11@DecryptBuf
$LN10@DecryptBuf:
  00122	8b 55 cc	 mov	 edx, DWORD PTR _cipher$[ebp]
  00125	52		 push	 edx
  00126	8b 45 1c	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00129	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012b	51		 push	 ecx
  0012c	e8 00 00 00 00	 call	 _EAGetPreviousCipher@8
  00131	89 45 cc	 mov	 DWORD PTR _cipher$[ebp], eax
$LN11@DecryptBuf:
  00134	83 7d cc 00	 cmp	 DWORD PTR _cipher$[ebp], 0
  00138	74 24		 je	 SHORT $LN9@DecryptBuf

; 940  : 			{
; 941  : 				ks -= CipherGetKeyScheduleSize (cipher);

  0013a	8b 55 cc	 mov	 edx, DWORD PTR _cipher$[ebp]
  0013d	52		 push	 edx
  0013e	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  00143	8b 4d e4	 mov	 ecx, DWORD PTR _ks$[ebp]
  00146	2b c8		 sub	 ecx, eax
  00148	89 4d e4	 mov	 DWORD PTR _ks$[ebp], ecx

; 942  : 				DecipherBlock (cipher, p, ks);

  0014b	8b 55 e4	 mov	 edx, DWORD PTR _ks$[ebp]
  0014e	52		 push	 edx
  0014f	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00152	50		 push	 eax
  00153	8b 4d cc	 mov	 ecx, DWORD PTR _cipher$[ebp]
  00156	51		 push	 ecx
  00157	e8 00 00 00 00	 call	 _DecipherBlock@12

; 943  : 			}

  0015c	eb c4		 jmp	 SHORT $LN10@DecryptBuf
$LN9@DecryptBuf:

; 944  : 		}
; 945  : 		else

  0015e	eb 11		 jmp	 SHORT $LN8@DecryptBuf
$LN12@DecryptBuf:

; 946  : 		{
; 947  : 			DecipherBlock (cipher, p, ks);

  00160	8b 55 e4	 mov	 edx, DWORD PTR _ks$[ebp]
  00163	52		 push	 edx
  00164	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00167	50		 push	 eax
  00168	8b 4d cc	 mov	 ecx, DWORD PTR _cipher$[ebp]
  0016b	51		 push	 ecx
  0016c	e8 00 00 00 00	 call	 _DecipherBlock@12
$LN8@DecryptBuf:

; 948  : 		}
; 949  : 
; 950  : 		Xor128 ((unsigned __int64 *)p, (unsigned __int64 *)t);

  00171	8d 55 d4	 lea	 edx, DWORD PTR _t$[ebp]
  00174	52		 push	 edx
  00175	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00178	50		 push	 eax
  00179	e8 00 00 00 00	 call	 _Xor128@8

; 951  : 
; 952  : 		p += 16;

  0017e	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  00181	83 c1 10	 add	 ecx, 16			; 00000010H
  00184	89 4d fc	 mov	 DWORD PTR _p$[ebp], ecx

; 953  : 
; 954  : 		if (i[7] != 0xff)

  00187	0f b6 55 f7	 movzx	 edx, BYTE PTR _i$[ebp+7]
  0018b	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  00191	74 0a		 je	 SHORT $LN7@DecryptBuf

; 955  : 			i[7]++;

  00193	8a 45 f7	 mov	 al, BYTE PTR _i$[ebp+7]
  00196	04 01		 add	 al, 1
  00198	88 45 f7	 mov	 BYTE PTR _i$[ebp+7], al

; 956  : 		else

  0019b	eb 20		 jmp	 SHORT $LN6@DecryptBuf
$LN7@DecryptBuf:

; 957  : 			*(unsigned __int64 *)i = BE64 ( BE64(*(unsigned __int64 *)i) + 1 );

  0019d	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp+4]
  001a0	51		 push	 ecx
  001a1	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  001a4	52		 push	 edx
  001a5	e8 00 00 00 00	 call	 _MirrorBytes64@8
  001aa	83 c0 01	 add	 eax, 1
  001ad	83 d2 00	 adc	 edx, 0
  001b0	52		 push	 edx
  001b1	50		 push	 eax
  001b2	e8 00 00 00 00	 call	 _MirrorBytes64@8
  001b7	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
  001ba	89 55 f4	 mov	 DWORD PTR _i$[ebp+4], edx
$LN6@DecryptBuf:

; 958  : 	}

  001bd	e9 d3 fe ff ff	 jmp	 $LN14@DecryptBuf
$LN5@DecryptBuf:

; 959  : 
; 960  : 	FAST_ERASE64 (t, sizeof(t));

  001c2	8d 45 d4	 lea	 eax, DWORD PTR _t$[ebp]
  001c5	89 45 c4	 mov	 DWORD PTR _burnm$27522[ebp], eax
  001c8	c7 45 c8 02 00
	00 00		 mov	 DWORD PTR _burnc$27524[ebp], 2
$LN2@DecryptBuf:
  001cf	8b 4d c8	 mov	 ecx, DWORD PTR _burnc$27524[ebp]
  001d2	8b 55 c8	 mov	 edx, DWORD PTR _burnc$27524[ebp]
  001d5	83 ea 01	 sub	 edx, 1
  001d8	89 55 c8	 mov	 DWORD PTR _burnc$27524[ebp], edx
  001db	85 c9		 test	 ecx, ecx
  001dd	74 1b		 je	 SHORT $LN4@DecryptBuf
  001df	8b 45 c4	 mov	 eax, DWORD PTR _burnm$27522[ebp]
  001e2	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  001e8	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  001ef	8b 4d c4	 mov	 ecx, DWORD PTR _burnm$27522[ebp]
  001f2	83 c1 08	 add	 ecx, 8
  001f5	89 4d c4	 mov	 DWORD PTR _burnm$27522[ebp], ecx
  001f8	eb d5		 jmp	 SHORT $LN2@DecryptBuf
$LN4@DecryptBuf:
  001fa	33 d2		 xor	 edx, edx
  001fc	75 c4		 jne	 SHORT $LN5@DecryptBuf
$LN18@DecryptBuf:

; 961  : }

  001fe	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00201	33 cd		 xor	 ecx, ebp
  00203	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00208	8b e5		 mov	 esp, ebp
  0020a	5d		 pop	 ebp
  0020b	c2 18 00	 ret	 24			; 00000018H
_DecryptBufferLRW128@24 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_DecryptBufferLRW64@24
; Function compile flags: /Odtp
;	COMDAT _DecryptBufferLRW64@24
_TEXT	SEGMENT
tv186 = -64						; size = 8
tv166 = -56						; size = 8
_burnm$27560 = -48					; size = 4
_burnc$27562 = -44					; size = 4
_cipher$ = -40						; size = 4
_t$ = -36						; size = 8
_ks$ = -28						; size = 4
_b$ = -24						; size = 8
_i$ = -16						; size = 8
__$ArrayPad$ = -8					; size = 4
_p$ = -4						; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_blockIndex$ = 20					; size = 8
_cryptoInfo$ = 28					; size = 4
_DecryptBufferLRW64@24 PROC				; COMDAT

; 966  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 40	 sub	 esp, 64			; 00000040H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 967  : 	/* Deprecated/legacy */
; 968  : 
; 969  : 	int cipher = EAGetFirstCipher (cryptoInfo->ea);

  00012	8b 45 1c	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  0001d	89 45 d8	 mov	 DWORD PTR _cipher$[ebp], eax

; 970  : 	unsigned __int8 *p = buffer;

  00020	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00023	89 55 fc	 mov	 DWORD PTR _p$[ebp], edx

; 971  : 	unsigned __int8 *ks = cryptoInfo->ks;

  00026	8b 45 1c	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00029	83 c0 08	 add	 eax, 8
  0002c	89 45 e4	 mov	 DWORD PTR _ks$[ebp], eax

; 972  : 	unsigned __int8 i[8];
; 973  : 	unsigned __int8 t[8];
; 974  : 	unsigned __int64 b;
; 975  : 
; 976  : 	*(unsigned __int64 *)i = BE64(blockIndex);

  0002f	8b 4d 18	 mov	 ecx, DWORD PTR _blockIndex$[ebp+4]
  00032	51		 push	 ecx
  00033	8b 55 14	 mov	 edx, DWORD PTR _blockIndex$[ebp]
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 _MirrorBytes64@8
  0003c	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
  0003f	89 55 f4	 mov	 DWORD PTR _i$[ebp+4], edx

; 977  : 
; 978  : 	if (length % 8)

  00042	6a 00		 push	 0
  00044	6a 08		 push	 8
  00046	8b 45 10	 mov	 eax, DWORD PTR _length$[ebp+4]
  00049	50		 push	 eax
  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR _length$[ebp]
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 __aullrem
  00053	89 45 c8	 mov	 DWORD PTR tv166[ebp], eax
  00056	89 55 cc	 mov	 DWORD PTR tv166[ebp+4], edx
  00059	8b 55 c8	 mov	 edx, DWORD PTR tv166[ebp]
  0005c	0b 55 cc	 or	 edx, DWORD PTR tv166[ebp+4]
  0005f	74 16		 je	 SHORT $LN11@DecryptBuf@2

; 979  : 		TC_THROW_FATAL_EXCEPTION;

  00061	68 43 54 00 00	 push	 21571			; 00005443H
  00066	6a 00		 push	 0
  00068	6a 00		 push	 0
  0006a	68 d3 03 00 00	 push	 979			; 000003d3H
  0006f	6a 29		 push	 41			; 00000029H
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN11@DecryptBuf@2:

; 980  : 
; 981  : 	for (b = 0; b < length >> 3; b++)

  00077	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _b$[ebp], 0
  0007e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _b$[ebp+4], 0
  00085	eb 12		 jmp	 SHORT $LN10@DecryptBuf@2
$LN9@DecryptBuf@2:
  00087	8b 45 e8	 mov	 eax, DWORD PTR _b$[ebp]
  0008a	83 c0 01	 add	 eax, 1
  0008d	8b 4d ec	 mov	 ecx, DWORD PTR _b$[ebp+4]
  00090	83 d1 00	 adc	 ecx, 0
  00093	89 45 e8	 mov	 DWORD PTR _b$[ebp], eax
  00096	89 4d ec	 mov	 DWORD PTR _b$[ebp+4], ecx
$LN10@DecryptBuf@2:
  00099	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  0009c	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp+4]
  0009f	b1 03		 mov	 cl, 3
  000a1	e8 00 00 00 00	 call	 __aullshr
  000a6	89 45 c0	 mov	 DWORD PTR tv186[ebp], eax
  000a9	89 55 c4	 mov	 DWORD PTR tv186[ebp+4], edx
  000ac	8b 55 ec	 mov	 edx, DWORD PTR _b$[ebp+4]
  000af	3b 55 c4	 cmp	 edx, DWORD PTR tv186[ebp+4]
  000b2	0f 87 94 00 00
	00		 ja	 $LN5@DecryptBuf@2
  000b8	72 0c		 jb	 SHORT $LN14@DecryptBuf@2
  000ba	8b 45 e8	 mov	 eax, DWORD PTR _b$[ebp]
  000bd	3b 45 c0	 cmp	 eax, DWORD PTR tv186[ebp]
  000c0	0f 83 86 00 00
	00		 jae	 $LN5@DecryptBuf@2
$LN14@DecryptBuf@2:

; 982  : 	{
; 983  : 		Gf64MulTab (i, t, &cryptoInfo->gf_ctx);

  000c6	8b 4d 1c	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  000c9	81 c1 a8 29 00
	00		 add	 ecx, 10664		; 000029a8H
  000cf	51		 push	 ecx
  000d0	8d 55 dc	 lea	 edx, DWORD PTR _t$[ebp]
  000d3	52		 push	 edx
  000d4	8d 45 f0	 lea	 eax, DWORD PTR _i$[ebp]
  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 _Gf64MulTab@12

; 984  : 		Xor64 ((unsigned __int64 *)p, (unsigned __int64 *)t);

  000dd	8d 4d dc	 lea	 ecx, DWORD PTR _t$[ebp]
  000e0	51		 push	 ecx
  000e1	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  000e4	52		 push	 edx
  000e5	e8 00 00 00 00	 call	 _Xor64@8

; 985  : 
; 986  : 		DecipherBlock (cipher, p, ks);

  000ea	8b 45 e4	 mov	 eax, DWORD PTR _ks$[ebp]
  000ed	50		 push	 eax
  000ee	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  000f1	51		 push	 ecx
  000f2	8b 55 d8	 mov	 edx, DWORD PTR _cipher$[ebp]
  000f5	52		 push	 edx
  000f6	e8 00 00 00 00	 call	 _DecipherBlock@12

; 987  : 
; 988  : 		Xor64 ((unsigned __int64 *)p, (unsigned __int64 *)t);

  000fb	8d 45 dc	 lea	 eax, DWORD PTR _t$[ebp]
  000fe	50		 push	 eax
  000ff	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  00102	51		 push	 ecx
  00103	e8 00 00 00 00	 call	 _Xor64@8

; 989  : 
; 990  : 		p += 8;

  00108	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  0010b	83 c2 08	 add	 edx, 8
  0010e	89 55 fc	 mov	 DWORD PTR _p$[ebp], edx

; 991  : 
; 992  : 		if (i[7] != 0xff)

  00111	0f b6 45 f7	 movzx	 eax, BYTE PTR _i$[ebp+7]
  00115	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0011a	74 0b		 je	 SHORT $LN7@DecryptBuf@2

; 993  : 			i[7]++;

  0011c	8a 4d f7	 mov	 cl, BYTE PTR _i$[ebp+7]
  0011f	80 c1 01	 add	 cl, 1
  00122	88 4d f7	 mov	 BYTE PTR _i$[ebp+7], cl

; 994  : 		else

  00125	eb 20		 jmp	 SHORT $LN6@DecryptBuf@2
$LN7@DecryptBuf@2:

; 995  : 			*(unsigned __int64 *)i = BE64 ( BE64(*(unsigned __int64 *)i) + 1 );

  00127	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp+4]
  0012a	52		 push	 edx
  0012b	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0012e	50		 push	 eax
  0012f	e8 00 00 00 00	 call	 _MirrorBytes64@8
  00134	83 c0 01	 add	 eax, 1
  00137	83 d2 00	 adc	 edx, 0
  0013a	52		 push	 edx
  0013b	50		 push	 eax
  0013c	e8 00 00 00 00	 call	 _MirrorBytes64@8
  00141	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
  00144	89 55 f4	 mov	 DWORD PTR _i$[ebp+4], edx
$LN6@DecryptBuf@2:

; 996  : 	}

  00147	e9 3b ff ff ff	 jmp	 $LN9@DecryptBuf@2
$LN5@DecryptBuf@2:

; 997  : 
; 998  : 	FAST_ERASE64 (t, sizeof(t));

  0014c	8d 4d dc	 lea	 ecx, DWORD PTR _t$[ebp]
  0014f	89 4d d0	 mov	 DWORD PTR _burnm$27560[ebp], ecx
  00152	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _burnc$27562[ebp], 1
$LN2@DecryptBuf@2:
  00159	8b 55 d4	 mov	 edx, DWORD PTR _burnc$27562[ebp]
  0015c	8b 45 d4	 mov	 eax, DWORD PTR _burnc$27562[ebp]
  0015f	83 e8 01	 sub	 eax, 1
  00162	89 45 d4	 mov	 DWORD PTR _burnc$27562[ebp], eax
  00165	85 d2		 test	 edx, edx
  00167	74 1b		 je	 SHORT $LN4@DecryptBuf@2
  00169	8b 4d d0	 mov	 ecx, DWORD PTR _burnm$27560[ebp]
  0016c	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00172	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00179	8b 55 d0	 mov	 edx, DWORD PTR _burnm$27560[ebp]
  0017c	83 c2 08	 add	 edx, 8
  0017f	89 55 d0	 mov	 DWORD PTR _burnm$27560[ebp], edx
  00182	eb d5		 jmp	 SHORT $LN2@DecryptBuf@2
$LN4@DecryptBuf@2:
  00184	33 c0		 xor	 eax, eax
  00186	75 c4		 jne	 SHORT $LN5@DecryptBuf@2
$LN13@DecryptBuf@2:

; 999  : }

  00188	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018b	33 cd		 xor	 ecx, ebp
  0018d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00192	8b e5		 mov	 esp, ebp
  00194	5d		 pop	 ebp
  00195	c2 18 00	 ret	 24			; 00000018H
_DecryptBufferLRW64@24 ENDP
_TEXT	ENDS
PUBLIC	_EncryptBuffer@16
EXTRN	_EncryptBufferXTS@32:PROC
; Function compile flags: /Odtp
;	COMDAT _EncryptBuffer@16
_TEXT	SEGMENT
tv91 = -40						; size = 4
tv65 = -36						; size = 4
_cipher$27691 = -32					; size = 4
_ks$27690 = -28						; size = 4
_ks2$27670 = -24					; size = 4
_cipher$27672 = -20					; size = 4
_dataUnitNo$27671 = -16					; size = 8
_ks$27669 = -4						; size = 4
_buf$ = 8						; size = 4
_len$ = 12						; size = 8
_cryptoInfo$ = 20					; size = 4
_EncryptBuffer@16 PROC					; COMDAT

; 1244 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 28	 sub	 esp, 40			; 00000028H

; 1245 : 	switch (cryptoInfo->mode)

  00008	8b 45 14	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  0000b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000e	89 4d dc	 mov	 DWORD PTR tv65[ebp], ecx
  00011	8b 55 dc	 mov	 edx, DWORD PTR tv65[ebp]
  00014	83 ea 01	 sub	 edx, 1
  00017	89 55 dc	 mov	 DWORD PTR tv65[ebp], edx
  0001a	83 7d dc 04	 cmp	 DWORD PTR tv65[ebp], 4
  0001e	0f 87 b0 01 00
	00		 ja	 $LN1@EncryptBuf@3
  00024	8b 45 dc	 mov	 eax, DWORD PTR tv65[ebp]
  00027	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN21@EncryptBuf@3[eax*4]
$LN16@EncryptBuf@3:

; 1246 : 	{
; 1247 : 	case XTS:
; 1248 : 		{
; 1249 : 			unsigned __int8 *ks = cryptoInfo->ks;

  0002e	8b 4d 14	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00031	83 c1 08	 add	 ecx, 8
  00034	89 4d fc	 mov	 DWORD PTR _ks$27669[ebp], ecx

; 1250 : 			unsigned __int8 *ks2 = cryptoInfo->ks2;

  00037	8b 55 14	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  0003a	81 c2 d4 14 00
	00		 add	 edx, 5332		; 000014d4H
  00040	89 55 e8	 mov	 DWORD PTR _ks2$27670[ebp], edx

; 1251 : 			UINT64_STRUCT dataUnitNo;
; 1252 : 			int cipher;
; 1253 : 
; 1254 : 			// When encrypting/decrypting a buffer (typically a volume header) the sequential number
; 1255 : 			// of the first XTS data unit in the buffer is always 0 and the start of the buffer is
; 1256 : 			// always assumed to be aligned with the start of a data unit.
; 1257 : 			dataUnitNo.LowPart = 0;

  00043	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dataUnitNo$27671[ebp], 0

; 1258 : 			dataUnitNo.HighPart = 0;

  0004a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dataUnitNo$27671[ebp+4], 0

; 1259 : 
; 1260 : 			for (cipher = EAGetFirstCipher (cryptoInfo->ea);
; 1261 : 				cipher != 0;
; 1262 : 				cipher = EAGetNextCipher (cryptoInfo->ea, cipher))

  00051	8b 45 14	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	51		 push	 ecx
  00057	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  0005c	89 45 ec	 mov	 DWORD PTR _cipher$27672[ebp], eax
  0005f	eb 12		 jmp	 SHORT $LN15@EncryptBuf@3
$LN14@EncryptBuf@3:
  00061	8b 55 ec	 mov	 edx, DWORD PTR _cipher$27672[ebp]
  00064	52		 push	 edx
  00065	8b 45 14	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00068	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006a	51		 push	 ecx
  0006b	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  00070	89 45 ec	 mov	 DWORD PTR _cipher$27672[ebp], eax
$LN15@EncryptBuf@3:
  00073	83 7d ec 00	 cmp	 DWORD PTR _cipher$27672[ebp], 0
  00077	74 43		 je	 SHORT $LN13@EncryptBuf@3

; 1263 : 			{
; 1264 : 				EncryptBufferXTS (buf, len, &dataUnitNo, 0, ks, ks2, cipher);

  00079	8b 55 ec	 mov	 edx, DWORD PTR _cipher$27672[ebp]
  0007c	52		 push	 edx
  0007d	8b 45 e8	 mov	 eax, DWORD PTR _ks2$27670[ebp]
  00080	50		 push	 eax
  00081	8b 4d fc	 mov	 ecx, DWORD PTR _ks$27669[ebp]
  00084	51		 push	 ecx
  00085	6a 00		 push	 0
  00087	8d 55 f0	 lea	 edx, DWORD PTR _dataUnitNo$27671[ebp]
  0008a	52		 push	 edx
  0008b	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp+4]
  0008e	50		 push	 eax
  0008f	8b 4d 0c	 mov	 ecx, DWORD PTR _len$[ebp]
  00092	51		 push	 ecx
  00093	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00096	52		 push	 edx
  00097	e8 00 00 00 00	 call	 _EncryptBufferXTS@32

; 1265 : 
; 1266 : 				ks += CipherGetKeyScheduleSize (cipher);

  0009c	8b 45 ec	 mov	 eax, DWORD PTR _cipher$27672[ebp]
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  000a5	03 45 fc	 add	 eax, DWORD PTR _ks$27669[ebp]
  000a8	89 45 fc	 mov	 DWORD PTR _ks$27669[ebp], eax

; 1267 : 				ks2 += CipherGetKeyScheduleSize (cipher);

  000ab	8b 4d ec	 mov	 ecx, DWORD PTR _cipher$27672[ebp]
  000ae	51		 push	 ecx
  000af	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  000b4	03 45 e8	 add	 eax, DWORD PTR _ks2$27670[ebp]
  000b7	89 45 e8	 mov	 DWORD PTR _ks2$27670[ebp], eax

; 1268 : 			}

  000ba	eb a5		 jmp	 SHORT $LN14@EncryptBuf@3
$LN13@EncryptBuf@3:

; 1269 : 		}
; 1270 : 		break;

  000bc	e9 29 01 00 00	 jmp	 $LN20@EncryptBuf@3
$LN12@EncryptBuf@3:

; 1271 : 
; 1272 : #ifndef TC_NO_COMPILER_INT64
; 1273 : 	case LRW:
; 1274 : 
; 1275 : 		/* Deprecated/legacy */
; 1276 : 
; 1277 : 		switch (CipherGetBlockSize (EAGetFirstCipher (cryptoInfo->ea)))

  000c1	8b 55 14	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  000c4	8b 02		 mov	 eax, DWORD PTR [edx]
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 _CipherGetBlockSize@4
  000d2	89 45 d8	 mov	 DWORD PTR tv91[ebp], eax
  000d5	83 7d d8 08	 cmp	 DWORD PTR tv91[ebp], 8
  000d9	74 08		 je	 SHORT $LN9@EncryptBuf@3
  000db	83 7d d8 10	 cmp	 DWORD PTR tv91[ebp], 16	; 00000010H
  000df	74 1d		 je	 SHORT $LN8@EncryptBuf@3
  000e1	eb 36		 jmp	 SHORT $LN7@EncryptBuf@3
$LN9@EncryptBuf@3:

; 1278 : 		{
; 1279 : 		case 8:
; 1280 : 			EncryptBufferLRW64 ((unsigned __int8 *)buf, (unsigned __int64) len, 1, cryptoInfo);

  000e3	8b 4d 14	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  000e6	51		 push	 ecx
  000e7	6a 00		 push	 0
  000e9	6a 01		 push	 1
  000eb	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp+4]
  000ee	52		 push	 edx
  000ef	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  000f2	50		 push	 eax
  000f3	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  000f6	51		 push	 ecx
  000f7	e8 00 00 00 00	 call	 _EncryptBufferLRW64@24

; 1281 : 			break;

  000fc	eb 31		 jmp	 SHORT $LN10@EncryptBuf@3
$LN8@EncryptBuf@3:

; 1282 : 
; 1283 : 		case 16:
; 1284 : 			EncryptBufferLRW128 ((unsigned __int8 *)buf, (unsigned __int64) len, 1, cryptoInfo);

  000fe	8b 55 14	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00101	52		 push	 edx
  00102	6a 00		 push	 0
  00104	6a 01		 push	 1
  00106	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp+4]
  00109	50		 push	 eax
  0010a	8b 4d 0c	 mov	 ecx, DWORD PTR _len$[ebp]
  0010d	51		 push	 ecx
  0010e	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00111	52		 push	 edx
  00112	e8 00 00 00 00	 call	 _EncryptBufferLRW128@24

; 1285 : 			break;

  00117	eb 16		 jmp	 SHORT $LN10@EncryptBuf@3
$LN7@EncryptBuf@3:

; 1286 : 
; 1287 : 		default:
; 1288 : 			TC_THROW_FATAL_EXCEPTION;

  00119	68 43 54 00 00	 push	 21571			; 00005443H
  0011e	6a 00		 push	 0
  00120	6a 00		 push	 0
  00122	68 08 05 00 00	 push	 1288			; 00000508H
  00127	6a 29		 push	 41			; 00000029H
  00129	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN10@EncryptBuf@3:

; 1289 : 		}
; 1290 : 		break;

  0012f	e9 b6 00 00 00	 jmp	 $LN20@EncryptBuf@3
$LN6@EncryptBuf@3:

; 1291 : 
; 1292 : 	case CBC:
; 1293 : 	case INNER_CBC:
; 1294 : 		{
; 1295 : 			/* Deprecated/legacy */
; 1296 : 
; 1297 : 			unsigned __int8 *ks = cryptoInfo->ks;

  00134	8b 45 14	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00137	83 c0 08	 add	 eax, 8
  0013a	89 45 e4	 mov	 DWORD PTR _ks$27690[ebp], eax

; 1298 : 			int cipher;
; 1299 : 
; 1300 : 			for (cipher = EAGetFirstCipher (cryptoInfo->ea);
; 1301 : 				cipher != 0;
; 1302 : 				cipher = EAGetNextCipher (cryptoInfo->ea, cipher))

  0013d	8b 4d 14	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00140	8b 11		 mov	 edx, DWORD PTR [ecx]
  00142	52		 push	 edx
  00143	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  00148	89 45 e0	 mov	 DWORD PTR _cipher$27691[ebp], eax
  0014b	eb 12		 jmp	 SHORT $LN5@EncryptBuf@3
$LN4@EncryptBuf@3:
  0014d	8b 45 e0	 mov	 eax, DWORD PTR _cipher$27691[ebp]
  00150	50		 push	 eax
  00151	8b 4d 14	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00154	8b 11		 mov	 edx, DWORD PTR [ecx]
  00156	52		 push	 edx
  00157	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  0015c	89 45 e0	 mov	 DWORD PTR _cipher$27691[ebp], eax
$LN5@EncryptBuf@3:
  0015f	83 7d e0 00	 cmp	 DWORD PTR _cipher$27691[ebp], 0
  00163	74 3c		 je	 SHORT $LN3@EncryptBuf@3

; 1303 : 			{
; 1304 : 				EncryptBufferCBC ((unsigned __int32 *) buf,
; 1305 : 					(unsigned int) len,
; 1306 : 					ks,
; 1307 : 					(unsigned __int32 *) cryptoInfo->k2,
; 1308 : 					(unsigned __int32 *) &cryptoInfo->k2[8],
; 1309 : 					0,
; 1310 : 					cipher);

  00165	8b 45 e0	 mov	 eax, DWORD PTR _cipher$27691[ebp]
  00168	50		 push	 eax
  00169	6a 00		 push	 0
  0016b	8b 4d 14	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  0016e	81 c1 b0 42 00
	00		 add	 ecx, 17072		; 000042b0H
  00174	51		 push	 ecx
  00175	8b 55 14	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00178	81 c2 a8 42 00
	00		 add	 edx, 17064		; 000042a8H
  0017e	52		 push	 edx
  0017f	8b 45 e4	 mov	 eax, DWORD PTR _ks$27690[ebp]
  00182	50		 push	 eax
  00183	8b 4d 0c	 mov	 ecx, DWORD PTR _len$[ebp]
  00186	51		 push	 ecx
  00187	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  0018a	52		 push	 edx
  0018b	e8 00 00 00 00	 call	 _EncryptBufferCBC@28

; 1311 : 
; 1312 : 				ks += CipherGetKeyScheduleSize (cipher);

  00190	8b 45 e0	 mov	 eax, DWORD PTR _cipher$27691[ebp]
  00193	50		 push	 eax
  00194	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  00199	03 45 e4	 add	 eax, DWORD PTR _ks$27690[ebp]
  0019c	89 45 e4	 mov	 DWORD PTR _ks$27690[ebp], eax

; 1313 : 			}

  0019f	eb ac		 jmp	 SHORT $LN4@EncryptBuf@3
$LN3@EncryptBuf@3:

; 1314 : 		}
; 1315 : 		break;

  001a1	eb 47		 jmp	 SHORT $LN20@EncryptBuf@3
$LN2@EncryptBuf@3:

; 1316 : 
; 1317 : 	case OUTER_CBC:
; 1318 : 
; 1319 : 		/* Deprecated/legacy */
; 1320 : 
; 1321 : 		EncryptBufferCBC ((unsigned __int32 *) buf,
; 1322 : 			(unsigned int) len,
; 1323 : 			cryptoInfo->ks,
; 1324 : 			(unsigned __int32 *) cryptoInfo->k2,
; 1325 : 			(unsigned __int32 *) &cryptoInfo->k2[8],
; 1326 : 			cryptoInfo->ea,
; 1327 : 			0);

  001a3	6a 00		 push	 0
  001a5	8b 4d 14	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  001a8	8b 11		 mov	 edx, DWORD PTR [ecx]
  001aa	52		 push	 edx
  001ab	8b 45 14	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  001ae	05 b0 42 00 00	 add	 eax, 17072		; 000042b0H
  001b3	50		 push	 eax
  001b4	8b 4d 14	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  001b7	81 c1 a8 42 00
	00		 add	 ecx, 17064		; 000042a8H
  001bd	51		 push	 ecx
  001be	8b 55 14	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  001c1	83 c2 08	 add	 edx, 8
  001c4	52		 push	 edx
  001c5	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  001c8	50		 push	 eax
  001c9	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  001cc	51		 push	 ecx
  001cd	e8 00 00 00 00	 call	 _EncryptBufferCBC@28

; 1328 : 
; 1329 : 		break;

  001d2	eb 16		 jmp	 SHORT $LN20@EncryptBuf@3
$LN1@EncryptBuf@3:

; 1330 : #endif	// #ifndef TC_NO_COMPILER_INT64
; 1331 : 
; 1332 : 	default:		
; 1333 : 		// Unknown/wrong ID
; 1334 : 		TC_THROW_FATAL_EXCEPTION;

  001d4	68 43 54 00 00	 push	 21571			; 00005443H
  001d9	6a 00		 push	 0
  001db	6a 00		 push	 0
  001dd	68 36 05 00 00	 push	 1334			; 00000536H
  001e2	6a 29		 push	 41			; 00000029H
  001e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN20@EncryptBuf@3:

; 1335 : 	}
; 1336 : }

  001ea	8b e5		 mov	 esp, ebp
  001ec	5d		 pop	 ebp
  001ed	c2 10 00	 ret	 16			; 00000010H
$LN21@EncryptBuf@3:
  001f0	00 00 00 00	 DD	 $LN16@EncryptBuf@3
  001f4	00 00 00 00	 DD	 $LN12@EncryptBuf@3
  001f8	00 00 00 00	 DD	 $LN6@EncryptBuf@3
  001fc	00 00 00 00	 DD	 $LN2@EncryptBuf@3
  00200	00 00 00 00	 DD	 $LN6@EncryptBuf@3
_EncryptBuffer@16 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _EncryptBufferCBC@28
_TEXT	SEGMENT
tv202 = -40						; size = 8
tv68 = -32						; size = 4
_blockSize$ = -28					; size = 4
_bufIV$ = -24						; size = 16
_i$ = -8						; size = 8
_data$ = 8						; size = 4
_len$ = 12						; size = 4
_ks$ = 16						; size = 4
_iv$ = 20						; size = 4
_whitening$ = 24					; size = 4
_ea$ = 28						; size = 4
_cipher$ = 32						; size = 4
_EncryptBufferCBC@28 PROC				; COMDAT

; 1073 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 28	 sub	 esp, 40			; 00000028H

; 1074 : 	/* IMPORTANT: This function has been deprecated (legacy) */
; 1075 : 
; 1076 : 	unsigned __int32 bufIV[4];
; 1077 : 	unsigned __int64 i;
; 1078 : 	int blockSize = CipherGetBlockSize (ea != 0 ? EAGetFirstCipher (ea) : cipher);

  00008	83 7d 1c 00	 cmp	 DWORD PTR _ea$[ebp], 0
  0000c	74 0e		 je	 SHORT $LN16@EncryptBuf@4
  0000e	8b 45 1c	 mov	 eax, DWORD PTR _ea$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  00017	89 45 e0	 mov	 DWORD PTR tv68[ebp], eax
  0001a	eb 06		 jmp	 SHORT $LN17@EncryptBuf@4
$LN16@EncryptBuf@4:
  0001c	8b 4d 20	 mov	 ecx, DWORD PTR _cipher$[ebp]
  0001f	89 4d e0	 mov	 DWORD PTR tv68[ebp], ecx
$LN17@EncryptBuf@4:
  00022	8b 55 e0	 mov	 edx, DWORD PTR tv68[ebp]
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 _CipherGetBlockSize@4
  0002b	89 45 e4	 mov	 DWORD PTR _blockSize$[ebp], eax

; 1079 : 
; 1080 : 	if (len % blockSize)

  0002e	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  00031	33 d2		 xor	 edx, edx
  00033	f7 75 e4	 div	 DWORD PTR _blockSize$[ebp]
  00036	85 d2		 test	 edx, edx
  00038	74 16		 je	 SHORT $LN13@EncryptBuf@4

; 1081 : 		TC_THROW_FATAL_EXCEPTION;

  0003a	68 43 54 00 00	 push	 21571			; 00005443H
  0003f	6a 00		 push	 0
  00041	6a 00		 push	 0
  00043	68 39 04 00 00	 push	 1081			; 00000439H
  00048	6a 29		 push	 41			; 00000029H
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN13@EncryptBuf@4:

; 1082 : 
; 1083 : 	//  IV
; 1084 : 	bufIV[0] = iv[0];

  00050	8b 45 14	 mov	 eax, DWORD PTR _iv$[ebp]
  00053	8b 08		 mov	 ecx, DWORD PTR [eax]
  00055	89 4d e8	 mov	 DWORD PTR _bufIV$[ebp], ecx

; 1085 : 	bufIV[1] = iv[1];

  00058	8b 55 14	 mov	 edx, DWORD PTR _iv$[ebp]
  0005b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0005e	89 45 ec	 mov	 DWORD PTR _bufIV$[ebp+4], eax

; 1086 : 	if (blockSize == 16)

  00061	83 7d e4 10	 cmp	 DWORD PTR _blockSize$[ebp], 16 ; 00000010H
  00065	75 12		 jne	 SHORT $LN12@EncryptBuf@4

; 1087 : 	{
; 1088 : 		bufIV[2] = iv[2];

  00067	8b 4d 14	 mov	 ecx, DWORD PTR _iv$[ebp]
  0006a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0006d	89 55 f0	 mov	 DWORD PTR _bufIV$[ebp+8], edx

; 1089 : 		bufIV[3] = iv[3];

  00070	8b 45 14	 mov	 eax, DWORD PTR _iv$[ebp]
  00073	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00076	89 4d f4	 mov	 DWORD PTR _bufIV$[ebp+12], ecx
$LN12@EncryptBuf@4:

; 1090 : 	}
; 1091 : 
; 1092 : 	// Encrypt each block
; 1093 : 	for (i = 0; i < len/blockSize; i++)

  00079	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00080	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp+4], 0
  00087	eb 12		 jmp	 SHORT $LN11@EncryptBuf@4
$LN10@EncryptBuf@4:
  00089	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0008c	83 c2 01	 add	 edx, 1
  0008f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp+4]
  00092	83 d0 00	 adc	 eax, 0
  00095	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
  00098	89 45 fc	 mov	 DWORD PTR _i$[ebp+4], eax
$LN11@EncryptBuf@4:
  0009b	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  0009e	33 d2		 xor	 edx, edx
  000a0	f7 75 e4	 div	 DWORD PTR _blockSize$[ebp]
  000a3	33 c9		 xor	 ecx, ecx
  000a5	89 45 d8	 mov	 DWORD PTR tv202[ebp], eax
  000a8	89 4d dc	 mov	 DWORD PTR tv202[ebp+4], ecx
  000ab	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp+4]
  000ae	3b 55 dc	 cmp	 edx, DWORD PTR tv202[ebp+4]
  000b1	0f 87 45 01 00
	00		 ja	 $LN15@EncryptBuf@4
  000b7	72 0c		 jb	 SHORT $LN18@EncryptBuf@4
  000b9	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000bc	3b 45 d8	 cmp	 eax, DWORD PTR tv202[ebp]
  000bf	0f 83 37 01 00
	00		 jae	 $LN15@EncryptBuf@4
$LN18@EncryptBuf@4:

; 1094 : 	{
; 1095 : 		// CBC
; 1096 : 		data[0] ^= bufIV[0];

  000c5	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  000c8	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ca	33 55 e8	 xor	 edx, DWORD PTR _bufIV$[ebp]
  000cd	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  000d0	89 10		 mov	 DWORD PTR [eax], edx

; 1097 : 		data[1] ^= bufIV[1];

  000d2	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  000d5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d8	33 55 ec	 xor	 edx, DWORD PTR _bufIV$[ebp+4]
  000db	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  000de	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1098 : 		if (blockSize == 16)

  000e1	83 7d e4 10	 cmp	 DWORD PTR _blockSize$[ebp], 16 ; 00000010H
  000e5	75 1e		 jne	 SHORT $LN8@EncryptBuf@4

; 1099 : 		{
; 1100 : 			data[2] ^= bufIV[2];

  000e7	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  000ea	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000ed	33 55 f0	 xor	 edx, DWORD PTR _bufIV$[ebp+8]
  000f0	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  000f3	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1101 : 			data[3] ^= bufIV[3];

  000f6	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  000f9	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000fc	33 55 f4	 xor	 edx, DWORD PTR _bufIV$[ebp+12]
  000ff	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  00102	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$LN8@EncryptBuf@4:

; 1102 : 		}
; 1103 : 
; 1104 : 		if (ea != 0)

  00105	83 7d 1c 00	 cmp	 DWORD PTR _ea$[ebp], 0
  00109	74 59		 je	 SHORT $LN7@EncryptBuf@4

; 1105 : 		{
; 1106 : 			// Outer-CBC
; 1107 : 			for (cipher = EAGetFirstCipher (ea); cipher != 0; cipher = EAGetNextCipher (ea, cipher))

  0010b	8b 4d 1c	 mov	 ecx, DWORD PTR _ea$[ebp]
  0010e	51		 push	 ecx
  0010f	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  00114	89 45 20	 mov	 DWORD PTR _cipher$[ebp], eax
  00117	eb 10		 jmp	 SHORT $LN6@EncryptBuf@4
$LN5@EncryptBuf@4:
  00119	8b 55 20	 mov	 edx, DWORD PTR _cipher$[ebp]
  0011c	52		 push	 edx
  0011d	8b 45 1c	 mov	 eax, DWORD PTR _ea$[ebp]
  00120	50		 push	 eax
  00121	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  00126	89 45 20	 mov	 DWORD PTR _cipher$[ebp], eax
$LN6@EncryptBuf@4:
  00129	83 7d 20 00	 cmp	 DWORD PTR _cipher$[ebp], 0
  0012d	74 22		 je	 SHORT $LN4@EncryptBuf@4

; 1108 : 			{
; 1109 : 				EncipherBlock (cipher, data, ks);

  0012f	8b 4d 10	 mov	 ecx, DWORD PTR _ks$[ebp]
  00132	51		 push	 ecx
  00133	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  00136	52		 push	 edx
  00137	8b 45 20	 mov	 eax, DWORD PTR _cipher$[ebp]
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 _EncipherBlock@12

; 1110 : 				ks += CipherGetKeyScheduleSize (cipher);

  00140	8b 4d 20	 mov	 ecx, DWORD PTR _cipher$[ebp]
  00143	51		 push	 ecx
  00144	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  00149	03 45 10	 add	 eax, DWORD PTR _ks$[ebp]
  0014c	89 45 10	 mov	 DWORD PTR _ks$[ebp], eax

; 1111 : 			}

  0014f	eb c8		 jmp	 SHORT $LN5@EncryptBuf@4
$LN4@EncryptBuf@4:

; 1112 : 			ks -= EAGetKeyScheduleSize (ea);

  00151	8b 55 1c	 mov	 edx, DWORD PTR _ea$[ebp]
  00154	52		 push	 edx
  00155	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4
  0015a	8b 4d 10	 mov	 ecx, DWORD PTR _ks$[ebp]
  0015d	2b c8		 sub	 ecx, eax
  0015f	89 4d 10	 mov	 DWORD PTR _ks$[ebp], ecx

; 1113 : 		}
; 1114 : 		else

  00162	eb 11		 jmp	 SHORT $LN3@EncryptBuf@4
$LN7@EncryptBuf@4:

; 1115 : 		{
; 1116 : 			// CBC/inner-CBC
; 1117 : 			EncipherBlock (cipher, data, ks);

  00164	8b 55 10	 mov	 edx, DWORD PTR _ks$[ebp]
  00167	52		 push	 edx
  00168	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  0016b	50		 push	 eax
  0016c	8b 4d 20	 mov	 ecx, DWORD PTR _cipher$[ebp]
  0016f	51		 push	 ecx
  00170	e8 00 00 00 00	 call	 _EncipherBlock@12
$LN3@EncryptBuf@4:

; 1118 : 		}
; 1119 : 
; 1120 : 		// CBC
; 1121 : 		bufIV[0] = data[0];

  00175	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  00178	8b 02		 mov	 eax, DWORD PTR [edx]
  0017a	89 45 e8	 mov	 DWORD PTR _bufIV$[ebp], eax

; 1122 : 		bufIV[1] = data[1];

  0017d	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00180	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00183	89 55 ec	 mov	 DWORD PTR _bufIV$[ebp+4], edx

; 1123 : 		if (blockSize == 16)

  00186	83 7d e4 10	 cmp	 DWORD PTR _blockSize$[ebp], 16 ; 00000010H
  0018a	75 12		 jne	 SHORT $LN2@EncryptBuf@4

; 1124 : 		{
; 1125 : 			bufIV[2] = data[2];

  0018c	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  0018f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00192	89 4d f0	 mov	 DWORD PTR _bufIV$[ebp+8], ecx

; 1126 : 			bufIV[3] = data[3];

  00195	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  00198	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0019b	89 45 f4	 mov	 DWORD PTR _bufIV$[ebp+12], eax
$LN2@EncryptBuf@4:

; 1127 : 		}
; 1128 : 
; 1129 : 		// Whitening
; 1130 : 		data[0] ^= whitening[0];

  0019e	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  001a1	8b 55 18	 mov	 edx, DWORD PTR _whitening$[ebp]
  001a4	8b 01		 mov	 eax, DWORD PTR [ecx]
  001a6	33 02		 xor	 eax, DWORD PTR [edx]
  001a8	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  001ab	89 01		 mov	 DWORD PTR [ecx], eax

; 1131 : 		data[1] ^= whitening[1];

  001ad	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  001b0	8b 45 18	 mov	 eax, DWORD PTR _whitening$[ebp]
  001b3	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001b6	33 48 04	 xor	 ecx, DWORD PTR [eax+4]
  001b9	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  001bc	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1132 : 		if (blockSize == 16)

  001bf	83 7d e4 10	 cmp	 DWORD PTR _blockSize$[ebp], 16 ; 00000010H
  001c3	75 23		 jne	 SHORT $LN1@EncryptBuf@4

; 1133 : 		{
; 1134 : 			data[2] ^= whitening[0];

  001c5	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  001c8	8b 4d 18	 mov	 ecx, DWORD PTR _whitening$[ebp]
  001cb	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001ce	33 11		 xor	 edx, DWORD PTR [ecx]
  001d0	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  001d3	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1135 : 			data[3] ^= whitening[1];

  001d6	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  001d9	8b 55 18	 mov	 edx, DWORD PTR _whitening$[ebp]
  001dc	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  001df	33 42 04	 xor	 eax, DWORD PTR [edx+4]
  001e2	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  001e5	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$LN1@EncryptBuf@4:

; 1136 : 		}
; 1137 : 
; 1138 : 		data += blockSize / sizeof(*data);

  001e8	8b 55 e4	 mov	 edx, DWORD PTR _blockSize$[ebp]
  001eb	c1 ea 02	 shr	 edx, 2
  001ee	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  001f1	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  001f4	89 4d 08	 mov	 DWORD PTR _data$[ebp], ecx

; 1139 : 	}

  001f7	e9 8d fe ff ff	 jmp	 $LN10@EncryptBuf@4
$LN15@EncryptBuf@4:

; 1140 : }

  001fc	8b e5		 mov	 esp, ebp
  001fe	5d		 pop	 ebp
  001ff	c2 1c 00	 ret	 28			; 0000001cH
_EncryptBufferCBC@28 ENDP
_TEXT	ENDS
PUBLIC	_DataUnit2LRWIndex@16
EXTRN	__allshl:PROC
EXTRN	__aulldiv:PROC
; Function compile flags: /Odtp
;	COMDAT _DataUnit2LRWIndex@16
_TEXT	SEGMENT
tv70 = -4						; size = 4
_dataUnit$ = 8						; size = 8
_blockSize$ = 16					; size = 4
_ci$ = 20						; size = 4
_DataUnit2LRWIndex@16 PROC				; COMDAT

; 1342 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 1343 : 	/* Deprecated/legacy */
; 1344 : 
; 1345 : 	if (ci->hiddenVolume)

  00006	8b 45 14	 mov	 eax, DWORD PTR _ci$[ebp]
  00009	83 b8 a0 29 00
	00 00		 cmp	 DWORD PTR [eax+10656], 0
  00010	74 2f		 je	 SHORT $LN7@DataUnit2L

; 1346 : 		dataUnit -= ci->hiddenVolumeOffset / ENCRYPTION_DATA_UNIT_SIZE;

  00012	8b 4d 14	 mov	 ecx, DWORD PTR _ci$[ebp]
  00015	6a 00		 push	 0
  00017	68 00 02 00 00	 push	 512			; 00000200H
  0001c	8b 91 1c 44 00
	00		 mov	 edx, DWORD PTR [ecx+17436]
  00022	52		 push	 edx
  00023	8b 81 18 44 00
	00		 mov	 eax, DWORD PTR [ecx+17432]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 __aulldiv
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _dataUnit$[ebp]
  00032	2b c8		 sub	 ecx, eax
  00034	8b 45 0c	 mov	 eax, DWORD PTR _dataUnit$[ebp+4]
  00037	1b c2		 sbb	 eax, edx
  00039	89 4d 08	 mov	 DWORD PTR _dataUnit$[ebp], ecx
  0003c	89 45 0c	 mov	 DWORD PTR _dataUnit$[ebp+4], eax

; 1347 : 	else

  0003f	eb 12		 jmp	 SHORT $LN6@DataUnit2L
$LN7@DataUnit2L:

; 1348 : 		dataUnit -= TC_VOLUME_HEADER_SIZE_LEGACY / ENCRYPTION_DATA_UNIT_SIZE;	// Compensate for the volume header size

  00041	8b 4d 08	 mov	 ecx, DWORD PTR _dataUnit$[ebp]
  00044	83 e9 01	 sub	 ecx, 1
  00047	8b 55 0c	 mov	 edx, DWORD PTR _dataUnit$[ebp+4]
  0004a	83 da 00	 sbb	 edx, 0
  0004d	89 4d 08	 mov	 DWORD PTR _dataUnit$[ebp], ecx
  00050	89 55 0c	 mov	 DWORD PTR _dataUnit$[ebp+4], edx
$LN6@DataUnit2L:

; 1349 : 
; 1350 : 	switch (blockSize)

  00053	8b 45 10	 mov	 eax, DWORD PTR _blockSize$[ebp]
  00056	89 45 fc	 mov	 DWORD PTR tv70[ebp], eax
  00059	83 7d fc 08	 cmp	 DWORD PTR tv70[ebp], 8
  0005d	74 08		 je	 SHORT $LN3@DataUnit2L
  0005f	83 7d fc 10	 cmp	 DWORD PTR tv70[ebp], 16	; 00000010H
  00063	74 14		 je	 SHORT $LN2@DataUnit2L
  00065	eb 24		 jmp	 SHORT $LN1@DataUnit2L
$LN3@DataUnit2L:

; 1351 : 	{
; 1352 : 	case 8:
; 1353 : 		return (dataUnit << 6) | 1;

  00067	8b 45 08	 mov	 eax, DWORD PTR _dataUnit$[ebp]
  0006a	8b 55 0c	 mov	 edx, DWORD PTR _dataUnit$[ebp+4]
  0006d	b1 06		 mov	 cl, 6
  0006f	e8 00 00 00 00	 call	 __allshl
  00074	83 c8 01	 or	 eax, 1
  00077	eb 2c		 jmp	 SHORT $LN9@DataUnit2L
$LN2@DataUnit2L:

; 1354 : 
; 1355 : 	case 16:
; 1356 : 		return (dataUnit << 5) | 1;

  00079	8b 45 08	 mov	 eax, DWORD PTR _dataUnit$[ebp]
  0007c	8b 55 0c	 mov	 edx, DWORD PTR _dataUnit$[ebp+4]
  0007f	b1 05		 mov	 cl, 5
  00081	e8 00 00 00 00	 call	 __allshl
  00086	83 c8 01	 or	 eax, 1
  00089	eb 1a		 jmp	 SHORT $LN9@DataUnit2L
$LN1@DataUnit2L:

; 1357 : 
; 1358 : 	default:
; 1359 : 		TC_THROW_FATAL_EXCEPTION;

  0008b	68 43 54 00 00	 push	 21571			; 00005443H
  00090	6a 00		 push	 0
  00092	6a 00		 push	 0
  00094	68 4f 05 00 00	 push	 1359			; 0000054fH
  00099	6a 29		 push	 41			; 00000029H
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20

; 1360 : 	}
; 1361 : 
; 1362 : 	return 0;

  000a1	33 c0		 xor	 eax, eax
  000a3	33 d2		 xor	 edx, edx
$LN9@DataUnit2L:

; 1363 : }

  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c2 10 00	 ret	 16			; 00000010H
_DataUnit2LRWIndex@16 ENDP
_TEXT	ENDS
PUBLIC	_EncryptDataUnits@16
EXTRN	_EncryptionThreadPoolDoWork@20:PROC
; Function compile flags: /Odtp
;	COMDAT _EncryptDataUnits@16
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_structUnitNo$ = 12					; size = 4
_nbrUnits$ = 16						; size = 4
_ci$ = 20						; size = 4
_EncryptDataUnits@16 PROC				; COMDAT

; 1372 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1373 : 	EncryptionThreadPoolDoWork (EncryptDataUnitsWork, buf, structUnitNo, nbrUnits, ci);

  00005	8b 45 14	 mov	 eax, DWORD PTR _ci$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 10	 mov	 ecx, DWORD PTR _nbrUnits$[ebp]
  0000c	51		 push	 ecx
  0000d	8b 55 0c	 mov	 edx, DWORD PTR _structUnitNo$[ebp]
  00010	52		 push	 edx
  00011	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00014	50		 push	 eax
  00015	6a 00		 push	 0
  00017	e8 00 00 00 00	 call	 _EncryptionThreadPoolDoWork@20

; 1374 : }

  0001c	5d		 pop	 ebp
  0001d	c2 10 00	 ret	 16			; 00000010H
_EncryptDataUnits@16 ENDP
_TEXT	ENDS
PUBLIC	_EncryptDataUnitsCurrentThread@20
EXTRN	__allmul:PROC
; Function compile flags: /Odtp
;	COMDAT _EncryptDataUnitsCurrentThread@20
_TEXT	SEGMENT
tv364 = -84						; size = 8
tv320 = -76						; size = 8
tv93 = -68						; size = 4
tv68 = -64						; size = 4
_ks2$ = -60						; size = 4
_cipher$ = -56						; size = 4
_ks$ = -52						; size = 4
_iv$ = -48						; size = 4
_ea$ = -44						; size = 4
_unitNo$ = -40						; size = 8
_sectorIV$ = -28					; size = 16
_iv64$ = -12						; size = 4
_secWhitening$ = -8					; size = 8
_buf$ = 8						; size = 4
_structUnitNo$ = 12					; size = 4
_nbrUnits$ = 16						; size = 8
_ci$ = 24						; size = 4
_EncryptDataUnitsCurrentThread@20 PROC			; COMDAT

; 1378 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 54	 sub	 esp, 84			; 00000054H
  00008	56		 push	 esi

; 1379 : 	int ea = ci->ea;

  00009	8b 45 18	 mov	 eax, DWORD PTR _ci$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d d4	 mov	 DWORD PTR _ea$[ebp], ecx

; 1380 : 	unsigned __int8 *ks = ci->ks;

  00011	8b 55 18	 mov	 edx, DWORD PTR _ci$[ebp]
  00014	83 c2 08	 add	 edx, 8
  00017	89 55 cc	 mov	 DWORD PTR _ks$[ebp], edx

; 1381 : 	unsigned __int8 *ks2 = ci->ks2;

  0001a	8b 45 18	 mov	 eax, DWORD PTR _ci$[ebp]
  0001d	05 d4 14 00 00	 add	 eax, 5332		; 000014d4H
  00022	89 45 c4	 mov	 DWORD PTR _ks2$[ebp], eax

; 1382 : 	int cipher;
; 1383 : 
; 1384 : #ifndef TC_NO_COMPILER_INT64
; 1385 : 	void *iv = ci->k2;									// Deprecated/legacy

  00025	8b 4d 18	 mov	 ecx, DWORD PTR _ci$[ebp]
  00028	81 c1 a8 42 00
	00		 add	 ecx, 17064		; 000042a8H
  0002e	89 4d d0	 mov	 DWORD PTR _iv$[ebp], ecx

; 1386 : 	unsigned __int64 unitNo = structUnitNo->Value;

  00031	8b 55 0c	 mov	 edx, DWORD PTR _structUnitNo$[ebp]
  00034	8b 02		 mov	 eax, DWORD PTR [edx]
  00036	89 45 d8	 mov	 DWORD PTR _unitNo$[ebp], eax
  00039	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0003c	89 4d dc	 mov	 DWORD PTR _unitNo$[ebp+4], ecx

; 1387 : 	unsigned __int64 *iv64 = (unsigned __int64 *) iv;	// Deprecated/legacy

  0003f	8b 55 d0	 mov	 edx, DWORD PTR _iv$[ebp]
  00042	89 55 f4	 mov	 DWORD PTR _iv64$[ebp], edx

; 1388 : 	unsigned __int32 sectorIV[4];						// Deprecated/legacy
; 1389 : 	unsigned __int32 secWhitening[2];					// Deprecated/legacy
; 1390 : #endif
; 1391 : 
; 1392 : 	switch (ci->mode)

  00045	8b 45 18	 mov	 eax, DWORD PTR _ci$[ebp]
  00048	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004b	89 4d c0	 mov	 DWORD PTR tv68[ebp], ecx
  0004e	8b 55 c0	 mov	 edx, DWORD PTR tv68[ebp]
  00051	83 ea 01	 sub	 edx, 1
  00054	89 55 c0	 mov	 DWORD PTR tv68[ebp], edx
  00057	83 7d c0 04	 cmp	 DWORD PTR tv68[ebp], 4
  0005b	0f 87 a2 02 00
	00		 ja	 $LN1@EncryptDat
  00061	8b 45 c0	 mov	 eax, DWORD PTR tv68[ebp]
  00064	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN25@EncryptDat[eax*4]
$LN20@EncryptDat:

; 1393 : 	{
; 1394 : 	case XTS:
; 1395 : 		for (cipher = EAGetFirstCipher (ea); cipher != 0; cipher = EAGetNextCipher (ea, cipher))

  0006b	8b 4d d4	 mov	 ecx, DWORD PTR _ea$[ebp]
  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  00074	89 45 c8	 mov	 DWORD PTR _cipher$[ebp], eax
  00077	eb 10		 jmp	 SHORT $LN19@EncryptDat
$LN18@EncryptDat:
  00079	8b 55 c8	 mov	 edx, DWORD PTR _cipher$[ebp]
  0007c	52		 push	 edx
  0007d	8b 45 d4	 mov	 eax, DWORD PTR _ea$[ebp]
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  00086	89 45 c8	 mov	 DWORD PTR _cipher$[ebp], eax
$LN19@EncryptDat:
  00089	83 7d c8 00	 cmp	 DWORD PTR _cipher$[ebp], 0
  0008d	74 51		 je	 SHORT $LN17@EncryptDat

; 1396 : 		{
; 1397 : 			EncryptBufferXTS (buf,
; 1398 : 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1399 : 				structUnitNo,
; 1400 : 				0,
; 1401 : 				ks,
; 1402 : 				ks2,
; 1403 : 				cipher);

  0008f	8b 4d c8	 mov	 ecx, DWORD PTR _cipher$[ebp]
  00092	51		 push	 ecx
  00093	8b 55 c4	 mov	 edx, DWORD PTR _ks2$[ebp]
  00096	52		 push	 edx
  00097	8b 45 cc	 mov	 eax, DWORD PTR _ks$[ebp]
  0009a	50		 push	 eax
  0009b	6a 00		 push	 0
  0009d	8b 4d 0c	 mov	 ecx, DWORD PTR _structUnitNo$[ebp]
  000a0	51		 push	 ecx
  000a1	6a 00		 push	 0
  000a3	68 00 02 00 00	 push	 512			; 00000200H
  000a8	8b 55 14	 mov	 edx, DWORD PTR _nbrUnits$[ebp+4]
  000ab	52		 push	 edx
  000ac	8b 45 10	 mov	 eax, DWORD PTR _nbrUnits$[ebp]
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 __allmul
  000b5	52		 push	 edx
  000b6	50		 push	 eax
  000b7	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  000ba	51		 push	 ecx
  000bb	e8 00 00 00 00	 call	 _EncryptBufferXTS@32

; 1404 : 
; 1405 : 			ks += CipherGetKeyScheduleSize (cipher);

  000c0	8b 55 c8	 mov	 edx, DWORD PTR _cipher$[ebp]
  000c3	52		 push	 edx
  000c4	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  000c9	03 45 cc	 add	 eax, DWORD PTR _ks$[ebp]
  000cc	89 45 cc	 mov	 DWORD PTR _ks$[ebp], eax

; 1406 : 			ks2 += CipherGetKeyScheduleSize (cipher);

  000cf	8b 45 c8	 mov	 eax, DWORD PTR _cipher$[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  000d8	03 45 c4	 add	 eax, DWORD PTR _ks2$[ebp]
  000db	89 45 c4	 mov	 DWORD PTR _ks2$[ebp], eax

; 1407 : 		}

  000de	eb 99		 jmp	 SHORT $LN18@EncryptDat
$LN17@EncryptDat:

; 1408 : 		break;

  000e0	e9 34 02 00 00	 jmp	 $LN24@EncryptDat
$LN16@EncryptDat:

; 1409 : 
; 1410 : #ifndef TC_NO_COMPILER_INT64
; 1411 : 	case LRW:
; 1412 : 
; 1413 : 		/* Deprecated/legacy */
; 1414 : 
; 1415 : 		switch (CipherGetBlockSize (EAGetFirstCipher (ea)))

  000e5	8b 4d d4	 mov	 ecx, DWORD PTR _ea$[ebp]
  000e8	51		 push	 ecx
  000e9	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 _CipherGetBlockSize@4
  000f4	89 45 bc	 mov	 DWORD PTR tv93[ebp], eax
  000f7	83 7d bc 08	 cmp	 DWORD PTR tv93[ebp], 8
  000fb	74 08		 je	 SHORT $LN13@EncryptDat
  000fd	83 7d bc 10	 cmp	 DWORD PTR tv93[ebp], 16	; 00000010H
  00101	74 3c		 je	 SHORT $LN12@EncryptDat
  00103	eb 74		 jmp	 SHORT $LN11@EncryptDat
$LN13@EncryptDat:

; 1416 : 		{
; 1417 : 		case 8:
; 1418 : 			EncryptBufferLRW64 (buf,
; 1419 : 				(unsigned __int64) nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1420 : 				DataUnit2LRWIndex (unitNo, 8, ci),
; 1421 : 				ci);

  00105	8b 55 18	 mov	 edx, DWORD PTR _ci$[ebp]
  00108	52		 push	 edx
  00109	8b 45 18	 mov	 eax, DWORD PTR _ci$[ebp]
  0010c	50		 push	 eax
  0010d	6a 08		 push	 8
  0010f	8b 4d dc	 mov	 ecx, DWORD PTR _unitNo$[ebp+4]
  00112	51		 push	 ecx
  00113	8b 55 d8	 mov	 edx, DWORD PTR _unitNo$[ebp]
  00116	52		 push	 edx
  00117	e8 00 00 00 00	 call	 _DataUnit2LRWIndex@16
  0011c	52		 push	 edx
  0011d	50		 push	 eax
  0011e	6a 00		 push	 0
  00120	68 00 02 00 00	 push	 512			; 00000200H
  00125	8b 45 14	 mov	 eax, DWORD PTR _nbrUnits$[ebp+4]
  00128	50		 push	 eax
  00129	8b 4d 10	 mov	 ecx, DWORD PTR _nbrUnits$[ebp]
  0012c	51		 push	 ecx
  0012d	e8 00 00 00 00	 call	 __allmul
  00132	52		 push	 edx
  00133	50		 push	 eax
  00134	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00137	52		 push	 edx
  00138	e8 00 00 00 00	 call	 _EncryptBufferLRW64@24

; 1422 : 			break;

  0013d	eb 50		 jmp	 SHORT $LN14@EncryptDat
$LN12@EncryptDat:

; 1423 : 
; 1424 : 		case 16:
; 1425 : 			EncryptBufferLRW128 (buf,
; 1426 : 				(unsigned __int64) nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1427 : 				DataUnit2LRWIndex (unitNo, 16, ci),
; 1428 : 				ci);

  0013f	8b 45 18	 mov	 eax, DWORD PTR _ci$[ebp]
  00142	50		 push	 eax
  00143	8b 4d 18	 mov	 ecx, DWORD PTR _ci$[ebp]
  00146	51		 push	 ecx
  00147	6a 10		 push	 16			; 00000010H
  00149	8b 55 dc	 mov	 edx, DWORD PTR _unitNo$[ebp+4]
  0014c	52		 push	 edx
  0014d	8b 45 d8	 mov	 eax, DWORD PTR _unitNo$[ebp]
  00150	50		 push	 eax
  00151	e8 00 00 00 00	 call	 _DataUnit2LRWIndex@16
  00156	52		 push	 edx
  00157	50		 push	 eax
  00158	6a 00		 push	 0
  0015a	68 00 02 00 00	 push	 512			; 00000200H
  0015f	8b 4d 14	 mov	 ecx, DWORD PTR _nbrUnits$[ebp+4]
  00162	51		 push	 ecx
  00163	8b 55 10	 mov	 edx, DWORD PTR _nbrUnits$[ebp]
  00166	52		 push	 edx
  00167	e8 00 00 00 00	 call	 __allmul
  0016c	52		 push	 edx
  0016d	50		 push	 eax
  0016e	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00171	50		 push	 eax
  00172	e8 00 00 00 00	 call	 _EncryptBufferLRW128@24

; 1429 : 			break;

  00177	eb 16		 jmp	 SHORT $LN14@EncryptDat
$LN11@EncryptDat:

; 1430 : 
; 1431 : 		default:
; 1432 : 			TC_THROW_FATAL_EXCEPTION;

  00179	68 43 54 00 00	 push	 21571			; 00005443H
  0017e	6a 00		 push	 0
  00180	6a 00		 push	 0
  00182	68 98 05 00 00	 push	 1432			; 00000598H
  00187	6a 29		 push	 41			; 00000029H
  00189	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN14@EncryptDat:

; 1433 : 		}
; 1434 : 		break;

  0018f	e9 85 01 00 00	 jmp	 $LN24@EncryptDat
$LN9@EncryptDat:

; 1435 : 
; 1436 : 	case CBC:
; 1437 : 	case INNER_CBC:
; 1438 : 
; 1439 : 		/* Deprecated/legacy */
; 1440 : 
; 1441 : 		while (nbrUnits--)

  00194	8b 4d 10	 mov	 ecx, DWORD PTR _nbrUnits$[ebp]
  00197	8b 55 14	 mov	 edx, DWORD PTR _nbrUnits$[ebp+4]
  0019a	8b 45 10	 mov	 eax, DWORD PTR _nbrUnits$[ebp]
  0019d	83 e8 01	 sub	 eax, 1
  001a0	8b 75 14	 mov	 esi, DWORD PTR _nbrUnits$[ebp+4]
  001a3	83 de 00	 sbb	 esi, 0
  001a6	89 45 10	 mov	 DWORD PTR _nbrUnits$[ebp], eax
  001a9	89 75 14	 mov	 DWORD PTR _nbrUnits$[ebp+4], esi
  001ac	89 4d b4	 mov	 DWORD PTR tv320[ebp], ecx
  001af	89 55 b8	 mov	 DWORD PTR tv320[ebp+4], edx
  001b2	8b 4d b4	 mov	 ecx, DWORD PTR tv320[ebp]
  001b5	0b 4d b8	 or	 ecx, DWORD PTR tv320[ebp+4]
  001b8	0f 84 ac 00 00
	00		 je	 $LN8@EncryptDat

; 1442 : 		{
; 1443 : 			for (cipher = EAGetFirstCipher (ea); cipher != 0; cipher = EAGetNextCipher (ea, cipher))

  001be	8b 55 d4	 mov	 edx, DWORD PTR _ea$[ebp]
  001c1	52		 push	 edx
  001c2	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  001c7	89 45 c8	 mov	 DWORD PTR _cipher$[ebp], eax
  001ca	eb 10		 jmp	 SHORT $LN7@EncryptDat
$LN6@EncryptDat:
  001cc	8b 45 c8	 mov	 eax, DWORD PTR _cipher$[ebp]
  001cf	50		 push	 eax
  001d0	8b 4d d4	 mov	 ecx, DWORD PTR _ea$[ebp]
  001d3	51		 push	 ecx
  001d4	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  001d9	89 45 c8	 mov	 DWORD PTR _cipher$[ebp], eax
$LN7@EncryptDat:
  001dc	83 7d c8 00	 cmp	 DWORD PTR _cipher$[ebp], 0
  001e0	74 54		 je	 SHORT $LN5@EncryptDat

; 1444 : 			{
; 1445 : 				InitSectorIVAndWhitening (unitNo, CipherGetBlockSize (cipher), sectorIV, iv64, secWhitening);

  001e2	8d 55 f8	 lea	 edx, DWORD PTR _secWhitening$[ebp]
  001e5	52		 push	 edx
  001e6	8b 45 f4	 mov	 eax, DWORD PTR _iv64$[ebp]
  001e9	50		 push	 eax
  001ea	8d 4d e4	 lea	 ecx, DWORD PTR _sectorIV$[ebp]
  001ed	51		 push	 ecx
  001ee	8b 55 c8	 mov	 edx, DWORD PTR _cipher$[ebp]
  001f1	52		 push	 edx
  001f2	e8 00 00 00 00	 call	 _CipherGetBlockSize@4
  001f7	50		 push	 eax
  001f8	8b 45 dc	 mov	 eax, DWORD PTR _unitNo$[ebp+4]
  001fb	50		 push	 eax
  001fc	8b 4d d8	 mov	 ecx, DWORD PTR _unitNo$[ebp]
  001ff	51		 push	 ecx
  00200	e8 00 00 00 00	 call	 _InitSectorIVAndWhitening@24

; 1446 : 
; 1447 : 				EncryptBufferCBC ((unsigned __int32 *) buf,
; 1448 : 					ENCRYPTION_DATA_UNIT_SIZE,
; 1449 : 					ks,
; 1450 : 					sectorIV,
; 1451 : 					secWhitening,
; 1452 : 					0,
; 1453 : 					cipher);

  00205	8b 55 c8	 mov	 edx, DWORD PTR _cipher$[ebp]
  00208	52		 push	 edx
  00209	6a 00		 push	 0
  0020b	8d 45 f8	 lea	 eax, DWORD PTR _secWhitening$[ebp]
  0020e	50		 push	 eax
  0020f	8d 4d e4	 lea	 ecx, DWORD PTR _sectorIV$[ebp]
  00212	51		 push	 ecx
  00213	8b 55 cc	 mov	 edx, DWORD PTR _ks$[ebp]
  00216	52		 push	 edx
  00217	68 00 02 00 00	 push	 512			; 00000200H
  0021c	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0021f	50		 push	 eax
  00220	e8 00 00 00 00	 call	 _EncryptBufferCBC@28

; 1454 : 
; 1455 : 				ks += CipherGetKeyScheduleSize (cipher);

  00225	8b 4d c8	 mov	 ecx, DWORD PTR _cipher$[ebp]
  00228	51		 push	 ecx
  00229	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  0022e	03 45 cc	 add	 eax, DWORD PTR _ks$[ebp]
  00231	89 45 cc	 mov	 DWORD PTR _ks$[ebp], eax

; 1456 : 			}

  00234	eb 96		 jmp	 SHORT $LN6@EncryptDat
$LN5@EncryptDat:

; 1457 : 			ks -= EAGetKeyScheduleSize (ea);

  00236	8b 55 d4	 mov	 edx, DWORD PTR _ea$[ebp]
  00239	52		 push	 edx
  0023a	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4
  0023f	8b 4d cc	 mov	 ecx, DWORD PTR _ks$[ebp]
  00242	2b c8		 sub	 ecx, eax
  00244	89 4d cc	 mov	 DWORD PTR _ks$[ebp], ecx

; 1458 : 			buf += ENCRYPTION_DATA_UNIT_SIZE;

  00247	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  0024a	81 c2 00 02 00
	00		 add	 edx, 512		; 00000200H
  00250	89 55 08	 mov	 DWORD PTR _buf$[ebp], edx

; 1459 : 			unitNo++;

  00253	8b 45 d8	 mov	 eax, DWORD PTR _unitNo$[ebp]
  00256	83 c0 01	 add	 eax, 1
  00259	8b 4d dc	 mov	 ecx, DWORD PTR _unitNo$[ebp+4]
  0025c	83 d1 00	 adc	 ecx, 0
  0025f	89 45 d8	 mov	 DWORD PTR _unitNo$[ebp], eax
  00262	89 4d dc	 mov	 DWORD PTR _unitNo$[ebp+4], ecx

; 1460 : 		}

  00265	e9 2a ff ff ff	 jmp	 $LN9@EncryptDat
$LN8@EncryptDat:

; 1461 : 		break;

  0026a	e9 aa 00 00 00	 jmp	 $LN24@EncryptDat
$LN3@EncryptDat:

; 1462 : 
; 1463 : 	case OUTER_CBC:
; 1464 : 
; 1465 : 		/* Deprecated/legacy */
; 1466 : 
; 1467 : 		while (nbrUnits--)

  0026f	8b 55 10	 mov	 edx, DWORD PTR _nbrUnits$[ebp]
  00272	8b 45 14	 mov	 eax, DWORD PTR _nbrUnits$[ebp+4]
  00275	8b 4d 10	 mov	 ecx, DWORD PTR _nbrUnits$[ebp]
  00278	83 e9 01	 sub	 ecx, 1
  0027b	8b 75 14	 mov	 esi, DWORD PTR _nbrUnits$[ebp+4]
  0027e	83 de 00	 sbb	 esi, 0
  00281	89 4d 10	 mov	 DWORD PTR _nbrUnits$[ebp], ecx
  00284	89 75 14	 mov	 DWORD PTR _nbrUnits$[ebp+4], esi
  00287	89 55 ac	 mov	 DWORD PTR tv364[ebp], edx
  0028a	89 45 b0	 mov	 DWORD PTR tv364[ebp+4], eax
  0028d	8b 55 ac	 mov	 edx, DWORD PTR tv364[ebp]
  00290	0b 55 b0	 or	 edx, DWORD PTR tv364[ebp+4]
  00293	74 6c		 je	 SHORT $LN2@EncryptDat

; 1468 : 		{
; 1469 : 			InitSectorIVAndWhitening (unitNo, CipherGetBlockSize (EAGetFirstCipher (ea)), sectorIV, iv64, secWhitening);

  00295	8d 45 f8	 lea	 eax, DWORD PTR _secWhitening$[ebp]
  00298	50		 push	 eax
  00299	8b 4d f4	 mov	 ecx, DWORD PTR _iv64$[ebp]
  0029c	51		 push	 ecx
  0029d	8d 55 e4	 lea	 edx, DWORD PTR _sectorIV$[ebp]
  002a0	52		 push	 edx
  002a1	8b 45 d4	 mov	 eax, DWORD PTR _ea$[ebp]
  002a4	50		 push	 eax
  002a5	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  002aa	50		 push	 eax
  002ab	e8 00 00 00 00	 call	 _CipherGetBlockSize@4
  002b0	50		 push	 eax
  002b1	8b 4d dc	 mov	 ecx, DWORD PTR _unitNo$[ebp+4]
  002b4	51		 push	 ecx
  002b5	8b 55 d8	 mov	 edx, DWORD PTR _unitNo$[ebp]
  002b8	52		 push	 edx
  002b9	e8 00 00 00 00	 call	 _InitSectorIVAndWhitening@24

; 1470 : 
; 1471 : 			EncryptBufferCBC ((unsigned __int32 *) buf,
; 1472 : 				ENCRYPTION_DATA_UNIT_SIZE,
; 1473 : 				ks,
; 1474 : 				sectorIV,
; 1475 : 				secWhitening,
; 1476 : 				ea,
; 1477 : 				0);

  002be	6a 00		 push	 0
  002c0	8b 45 d4	 mov	 eax, DWORD PTR _ea$[ebp]
  002c3	50		 push	 eax
  002c4	8d 4d f8	 lea	 ecx, DWORD PTR _secWhitening$[ebp]
  002c7	51		 push	 ecx
  002c8	8d 55 e4	 lea	 edx, DWORD PTR _sectorIV$[ebp]
  002cb	52		 push	 edx
  002cc	8b 45 cc	 mov	 eax, DWORD PTR _ks$[ebp]
  002cf	50		 push	 eax
  002d0	68 00 02 00 00	 push	 512			; 00000200H
  002d5	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  002d8	51		 push	 ecx
  002d9	e8 00 00 00 00	 call	 _EncryptBufferCBC@28

; 1478 : 
; 1479 : 			buf += ENCRYPTION_DATA_UNIT_SIZE;

  002de	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  002e1	81 c2 00 02 00
	00		 add	 edx, 512		; 00000200H
  002e7	89 55 08	 mov	 DWORD PTR _buf$[ebp], edx

; 1480 : 			unitNo++;

  002ea	8b 45 d8	 mov	 eax, DWORD PTR _unitNo$[ebp]
  002ed	83 c0 01	 add	 eax, 1
  002f0	8b 4d dc	 mov	 ecx, DWORD PTR _unitNo$[ebp+4]
  002f3	83 d1 00	 adc	 ecx, 0
  002f6	89 45 d8	 mov	 DWORD PTR _unitNo$[ebp], eax
  002f9	89 4d dc	 mov	 DWORD PTR _unitNo$[ebp+4], ecx

; 1481 : 		}

  002fc	e9 6e ff ff ff	 jmp	 $LN3@EncryptDat
$LN2@EncryptDat:

; 1482 : 		break;

  00301	eb 16		 jmp	 SHORT $LN24@EncryptDat
$LN1@EncryptDat:

; 1483 : #endif	// #ifndef TC_NO_COMPILER_INT64
; 1484 : 
; 1485 : 	default:		
; 1486 : 		// Unknown/wrong ID
; 1487 : 		TC_THROW_FATAL_EXCEPTION;

  00303	68 43 54 00 00	 push	 21571			; 00005443H
  00308	6a 00		 push	 0
  0030a	6a 00		 push	 0
  0030c	68 cf 05 00 00	 push	 1487			; 000005cfH
  00311	6a 29		 push	 41			; 00000029H
  00313	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN24@EncryptDat:

; 1488 : 	}
; 1489 : }

  00319	5e		 pop	 esi
  0031a	8b e5		 mov	 esp, ebp
  0031c	5d		 pop	 ebp
  0031d	c2 14 00	 ret	 20			; 00000014H
$LN25@EncryptDat:
  00320	00 00 00 00	 DD	 $LN20@EncryptDat
  00324	00 00 00 00	 DD	 $LN16@EncryptDat
  00328	00 00 00 00	 DD	 $LN9@EncryptDat
  0032c	00 00 00 00	 DD	 $LN3@EncryptDat
  00330	00 00 00 00	 DD	 $LN9@EncryptDat
_EncryptDataUnitsCurrentThread@20 ENDP
_TEXT	ENDS
EXTRN	_crc32int@4:PROC
; Function compile flags: /Odtp
;	COMDAT _InitSectorIVAndWhitening@24
_TEXT	SEGMENT
tv77 = -40						; size = 4
_iv32$ = -36						; size = 4
_iv64$ = -32						; size = 32
_unitNo$ = 8						; size = 8
_blockSize$ = 16					; size = 4
_iv$ = 20						; size = 4
_ivSeed$ = 24						; size = 4
_whitening$ = 28					; size = 4
_InitSectorIVAndWhitening@24 PROC			; COMDAT

; 1010 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 28	 sub	 esp, 40			; 00000028H
  00008	56		 push	 esi

; 1011 : 
; 1012 : 	/* IMPORTANT: This function has been deprecated (legacy) */
; 1013 : 
; 1014 : 	unsigned __int64 iv64[4];
; 1015 : 	unsigned __int32 *iv32 = (unsigned __int32 *) iv64;

  00009	8d 45 e0	 lea	 eax, DWORD PTR _iv64$[ebp]
  0000c	89 45 dc	 mov	 DWORD PTR _iv32$[ebp], eax

; 1016 : 
; 1017 : 	iv64[0] = ivSeed[0] ^ LE64(unitNo);

  0000f	8b 4d 18	 mov	 ecx, DWORD PTR _ivSeed$[ebp]
  00012	8b 11		 mov	 edx, DWORD PTR [ecx]
  00014	33 55 08	 xor	 edx, DWORD PTR _unitNo$[ebp]
  00017	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0001a	33 45 0c	 xor	 eax, DWORD PTR _unitNo$[ebp+4]
  0001d	89 55 e0	 mov	 DWORD PTR _iv64$[ebp], edx
  00020	89 45 e4	 mov	 DWORD PTR _iv64$[ebp+4], eax

; 1018 : 	iv64[1] = ivSeed[1] ^ LE64(unitNo);

  00023	8b 4d 18	 mov	 ecx, DWORD PTR _ivSeed$[ebp]
  00026	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00029	33 55 08	 xor	 edx, DWORD PTR _unitNo$[ebp]
  0002c	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0002f	33 45 0c	 xor	 eax, DWORD PTR _unitNo$[ebp+4]
  00032	89 55 e8	 mov	 DWORD PTR _iv64$[ebp+8], edx
  00035	89 45 ec	 mov	 DWORD PTR _iv64$[ebp+12], eax

; 1019 : 	iv64[2] = ivSeed[2] ^ LE64(unitNo);

  00038	8b 4d 18	 mov	 ecx, DWORD PTR _ivSeed$[ebp]
  0003b	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0003e	33 55 08	 xor	 edx, DWORD PTR _unitNo$[ebp]
  00041	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00044	33 45 0c	 xor	 eax, DWORD PTR _unitNo$[ebp+4]
  00047	89 55 f0	 mov	 DWORD PTR _iv64$[ebp+16], edx
  0004a	89 45 f4	 mov	 DWORD PTR _iv64$[ebp+20], eax

; 1020 : 	if (blockSize == 16)

  0004d	83 7d 10 10	 cmp	 DWORD PTR _blockSize$[ebp], 16 ; 00000010H
  00051	75 15		 jne	 SHORT $LN6@InitSector

; 1021 : 	{
; 1022 : 		iv64[3] = ivSeed[3] ^ LE64(unitNo);

  00053	8b 4d 18	 mov	 ecx, DWORD PTR _ivSeed$[ebp]
  00056	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00059	33 55 08	 xor	 edx, DWORD PTR _unitNo$[ebp]
  0005c	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0005f	33 45 0c	 xor	 eax, DWORD PTR _unitNo$[ebp+4]
  00062	89 55 f8	 mov	 DWORD PTR _iv64$[ebp+24], edx
  00065	89 45 fc	 mov	 DWORD PTR _iv64$[ebp+28], eax
$LN6@InitSector:

; 1023 : 	}
; 1024 : 
; 1025 : 	iv[0] = iv32[0];

  00068	8b 4d 14	 mov	 ecx, DWORD PTR _iv$[ebp]
  0006b	8b 55 dc	 mov	 edx, DWORD PTR _iv32$[ebp]
  0006e	8b 02		 mov	 eax, DWORD PTR [edx]
  00070	89 01		 mov	 DWORD PTR [ecx], eax

; 1026 : 	iv[1] = iv32[1];

  00072	8b 4d 14	 mov	 ecx, DWORD PTR _iv$[ebp]
  00075	8b 55 dc	 mov	 edx, DWORD PTR _iv32$[ebp]
  00078	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0007b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1027 : 
; 1028 : 	switch (blockSize)

  0007e	8b 4d 10	 mov	 ecx, DWORD PTR _blockSize$[ebp]
  00081	89 4d d8	 mov	 DWORD PTR tv77[ebp], ecx
  00084	83 7d d8 08	 cmp	 DWORD PTR tv77[ebp], 8
  00088	74 68		 je	 SHORT $LN2@InitSector
  0008a	83 7d d8 10	 cmp	 DWORD PTR tv77[ebp], 16	; 00000010H
  0008e	74 05		 je	 SHORT $LN3@InitSector
  00090	e9 a2 00 00 00	 jmp	 $LN1@InitSector
$LN3@InitSector:

; 1029 : 	{
; 1030 : 	case 16:
; 1031 : 
; 1032 : 		// 128-bit block
; 1033 : 
; 1034 : 		iv[2] = iv32[2];

  00095	8b 55 14	 mov	 edx, DWORD PTR _iv$[ebp]
  00098	8b 45 dc	 mov	 eax, DWORD PTR _iv32$[ebp]
  0009b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0009e	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1035 : 		iv[3] = iv32[3];

  000a1	8b 55 14	 mov	 edx, DWORD PTR _iv$[ebp]
  000a4	8b 45 dc	 mov	 eax, DWORD PTR _iv32$[ebp]
  000a7	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000aa	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 1036 : 
; 1037 : 		whitening[0] = LE32( crc32int ( &iv32[4] ) ^ crc32int ( &iv32[7] ) );

  000ad	8b 55 dc	 mov	 edx, DWORD PTR _iv32$[ebp]
  000b0	83 c2 10	 add	 edx, 16			; 00000010H
  000b3	52		 push	 edx
  000b4	e8 00 00 00 00	 call	 _crc32int@4
  000b9	8b f0		 mov	 esi, eax
  000bb	8b 45 dc	 mov	 eax, DWORD PTR _iv32$[ebp]
  000be	83 c0 1c	 add	 eax, 28			; 0000001cH
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 _crc32int@4
  000c7	33 f0		 xor	 esi, eax
  000c9	8b 4d 1c	 mov	 ecx, DWORD PTR _whitening$[ebp]
  000cc	89 31		 mov	 DWORD PTR [ecx], esi

; 1038 : 		whitening[1] = LE32( crc32int ( &iv32[5] ) ^ crc32int ( &iv32[6] ) );

  000ce	8b 55 dc	 mov	 edx, DWORD PTR _iv32$[ebp]
  000d1	83 c2 14	 add	 edx, 20			; 00000014H
  000d4	52		 push	 edx
  000d5	e8 00 00 00 00	 call	 _crc32int@4
  000da	8b f0		 mov	 esi, eax
  000dc	8b 45 dc	 mov	 eax, DWORD PTR _iv32$[ebp]
  000df	83 c0 18	 add	 eax, 24			; 00000018H
  000e2	50		 push	 eax
  000e3	e8 00 00 00 00	 call	 _crc32int@4
  000e8	33 f0		 xor	 esi, eax
  000ea	8b 4d 1c	 mov	 ecx, DWORD PTR _whitening$[ebp]
  000ed	89 71 04	 mov	 DWORD PTR [ecx+4], esi

; 1039 : 		break;

  000f0	eb 5b		 jmp	 SHORT $LN8@InitSector
$LN2@InitSector:

; 1040 : 
; 1041 : 	case 8:
; 1042 : 
; 1043 : 		// 64-bit block
; 1044 : 
; 1045 : 		whitening[0] = LE32( crc32int ( &iv32[2] ) ^ crc32int ( &iv32[5] ) );

  000f2	8b 55 dc	 mov	 edx, DWORD PTR _iv32$[ebp]
  000f5	83 c2 08	 add	 edx, 8
  000f8	52		 push	 edx
  000f9	e8 00 00 00 00	 call	 _crc32int@4
  000fe	8b f0		 mov	 esi, eax
  00100	8b 45 dc	 mov	 eax, DWORD PTR _iv32$[ebp]
  00103	83 c0 14	 add	 eax, 20			; 00000014H
  00106	50		 push	 eax
  00107	e8 00 00 00 00	 call	 _crc32int@4
  0010c	33 f0		 xor	 esi, eax
  0010e	8b 4d 1c	 mov	 ecx, DWORD PTR _whitening$[ebp]
  00111	89 31		 mov	 DWORD PTR [ecx], esi

; 1046 : 		whitening[1] = LE32( crc32int ( &iv32[3] ) ^ crc32int ( &iv32[4] ) );

  00113	8b 55 dc	 mov	 edx, DWORD PTR _iv32$[ebp]
  00116	83 c2 0c	 add	 edx, 12			; 0000000cH
  00119	52		 push	 edx
  0011a	e8 00 00 00 00	 call	 _crc32int@4
  0011f	8b f0		 mov	 esi, eax
  00121	8b 45 dc	 mov	 eax, DWORD PTR _iv32$[ebp]
  00124	83 c0 10	 add	 eax, 16			; 00000010H
  00127	50		 push	 eax
  00128	e8 00 00 00 00	 call	 _crc32int@4
  0012d	33 f0		 xor	 esi, eax
  0012f	8b 4d 1c	 mov	 ecx, DWORD PTR _whitening$[ebp]
  00132	89 71 04	 mov	 DWORD PTR [ecx+4], esi

; 1047 : 		break;

  00135	eb 16		 jmp	 SHORT $LN8@InitSector
$LN1@InitSector:

; 1048 : 
; 1049 : 	default:
; 1050 : 		TC_THROW_FATAL_EXCEPTION;

  00137	68 43 54 00 00	 push	 21571			; 00005443H
  0013c	6a 00		 push	 0
  0013e	6a 00		 push	 0
  00140	68 1a 04 00 00	 push	 1050			; 0000041aH
  00145	6a 29		 push	 41			; 00000029H
  00147	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN8@InitSector:

; 1051 : 	}
; 1052 : }

  0014d	5e		 pop	 esi
  0014e	8b e5		 mov	 esp, ebp
  00150	5d		 pop	 ebp
  00151	c2 18 00	 ret	 24			; 00000018H
_InitSectorIVAndWhitening@24 ENDP
_TEXT	ENDS
PUBLIC	_DecryptBuffer@16
EXTRN	_DecryptBufferXTS@32:PROC
; Function compile flags: /Odtp
;	COMDAT _DecryptBuffer@16
_TEXT	SEGMENT
tv129 = -40						; size = 4
tv65 = -36						; size = 4
_cipher$27817 = -32					; size = 4
_ks$27816 = -28						; size = 4
_ks2$27798 = -24					; size = 4
_cipher$27800 = -20					; size = 4
_dataUnitNo$27799 = -16					; size = 8
_ks$27797 = -4						; size = 4
_buf$ = 8						; size = 4
_len$ = 12						; size = 8
_cryptoInfo$ = 20					; size = 4
_DecryptBuffer@16 PROC					; COMDAT

; 1497 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 28	 sub	 esp, 40			; 00000028H

; 1498 : 	switch (cryptoInfo->mode)

  00008	8b 45 14	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  0000b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000e	89 4d dc	 mov	 DWORD PTR tv65[ebp], ecx
  00011	8b 55 dc	 mov	 edx, DWORD PTR tv65[ebp]
  00014	83 ea 01	 sub	 edx, 1
  00017	89 55 dc	 mov	 DWORD PTR tv65[ebp], edx
  0001a	83 7d dc 04	 cmp	 DWORD PTR tv65[ebp], 4
  0001e	0f 87 da 01 00
	00		 ja	 $LN1@DecryptBuf@3
  00024	8b 45 dc	 mov	 eax, DWORD PTR tv65[ebp]
  00027	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN21@DecryptBuf@3[eax*4]
$LN16@DecryptBuf@3:

; 1499 : 	{
; 1500 : 	case XTS:
; 1501 : 		{
; 1502 : 			unsigned __int8 *ks = cryptoInfo->ks + EAGetKeyScheduleSize (cryptoInfo->ea);

  0002e	8b 4d 14	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00031	8b 11		 mov	 edx, DWORD PTR [ecx]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4
  00039	8b 4d 14	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  0003c	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  00040	89 55 fc	 mov	 DWORD PTR _ks$27797[ebp], edx

; 1503 : 			unsigned __int8 *ks2 = cryptoInfo->ks2 + EAGetKeyScheduleSize (cryptoInfo->ea);

  00043	8b 45 14	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00046	8b 08		 mov	 ecx, DWORD PTR [eax]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4
  0004e	8b 55 14	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00051	8d 84 02 d4 14
	00 00		 lea	 eax, DWORD PTR [edx+eax+5332]
  00058	89 45 e8	 mov	 DWORD PTR _ks2$27798[ebp], eax

; 1504 : 			UINT64_STRUCT dataUnitNo;
; 1505 : 			int cipher;
; 1506 : 
; 1507 : 			// When encrypting/decrypting a buffer (typically a volume header) the sequential number
; 1508 : 			// of the first XTS data unit in the buffer is always 0 and the start of the buffer is
; 1509 : 			// always assumed to be aligned with the start of the data unit 0.
; 1510 : 			dataUnitNo.LowPart = 0;

  0005b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dataUnitNo$27799[ebp], 0

; 1511 : 			dataUnitNo.HighPart = 0;

  00062	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dataUnitNo$27799[ebp+4], 0

; 1512 : 
; 1513 : 			for (cipher = EAGetLastCipher (cryptoInfo->ea);
; 1514 : 				cipher != 0;
; 1515 : 				cipher = EAGetPreviousCipher (cryptoInfo->ea, cipher))

  00069	8b 4d 14	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  0006c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006e	52		 push	 edx
  0006f	e8 00 00 00 00	 call	 _EAGetLastCipher@4
  00074	89 45 ec	 mov	 DWORD PTR _cipher$27800[ebp], eax
  00077	eb 12		 jmp	 SHORT $LN15@DecryptBuf@3
$LN14@DecryptBuf@3:
  00079	8b 45 ec	 mov	 eax, DWORD PTR _cipher$27800[ebp]
  0007c	50		 push	 eax
  0007d	8b 4d 14	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00080	8b 11		 mov	 edx, DWORD PTR [ecx]
  00082	52		 push	 edx
  00083	e8 00 00 00 00	 call	 _EAGetPreviousCipher@8
  00088	89 45 ec	 mov	 DWORD PTR _cipher$27800[ebp], eax
$LN15@DecryptBuf@3:
  0008b	83 7d ec 00	 cmp	 DWORD PTR _cipher$27800[ebp], 0
  0008f	74 47		 je	 SHORT $LN13@DecryptBuf@3

; 1516 : 			{
; 1517 : 				ks -= CipherGetKeyScheduleSize (cipher);

  00091	8b 45 ec	 mov	 eax, DWORD PTR _cipher$27800[ebp]
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  0009a	8b 4d fc	 mov	 ecx, DWORD PTR _ks$27797[ebp]
  0009d	2b c8		 sub	 ecx, eax
  0009f	89 4d fc	 mov	 DWORD PTR _ks$27797[ebp], ecx

; 1518 : 				ks2 -= CipherGetKeyScheduleSize (cipher);

  000a2	8b 55 ec	 mov	 edx, DWORD PTR _cipher$27800[ebp]
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  000ab	8b 4d e8	 mov	 ecx, DWORD PTR _ks2$27798[ebp]
  000ae	2b c8		 sub	 ecx, eax
  000b0	89 4d e8	 mov	 DWORD PTR _ks2$27798[ebp], ecx

; 1519 : 
; 1520 : 				DecryptBufferXTS (buf, len, &dataUnitNo, 0, ks, ks2, cipher);

  000b3	8b 55 ec	 mov	 edx, DWORD PTR _cipher$27800[ebp]
  000b6	52		 push	 edx
  000b7	8b 45 e8	 mov	 eax, DWORD PTR _ks2$27798[ebp]
  000ba	50		 push	 eax
  000bb	8b 4d fc	 mov	 ecx, DWORD PTR _ks$27797[ebp]
  000be	51		 push	 ecx
  000bf	6a 00		 push	 0
  000c1	8d 55 f0	 lea	 edx, DWORD PTR _dataUnitNo$27799[ebp]
  000c4	52		 push	 edx
  000c5	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp+4]
  000c8	50		 push	 eax
  000c9	8b 4d 0c	 mov	 ecx, DWORD PTR _len$[ebp]
  000cc	51		 push	 ecx
  000cd	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  000d0	52		 push	 edx
  000d1	e8 00 00 00 00	 call	 _DecryptBufferXTS@32

; 1521 : 			}

  000d6	eb a1		 jmp	 SHORT $LN14@DecryptBuf@3
$LN13@DecryptBuf@3:

; 1522 : 		}
; 1523 : 		break;

  000d8	e9 37 01 00 00	 jmp	 $LN20@DecryptBuf@3
$LN12@DecryptBuf@3:

; 1524 : 
; 1525 : #ifndef TC_NO_COMPILER_INT64
; 1526 : 	case LRW:
; 1527 : 
; 1528 : 		/* Deprecated/legacy */
; 1529 : 
; 1530 : 		switch (CipherGetBlockSize (EAGetFirstCipher (cryptoInfo->ea)))

  000dd	8b 45 14	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  000e0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e2	51		 push	 ecx
  000e3	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  000e8	50		 push	 eax
  000e9	e8 00 00 00 00	 call	 _CipherGetBlockSize@4
  000ee	89 45 d8	 mov	 DWORD PTR tv129[ebp], eax
  000f1	83 7d d8 08	 cmp	 DWORD PTR tv129[ebp], 8
  000f5	74 08		 je	 SHORT $LN9@DecryptBuf@3
  000f7	83 7d d8 10	 cmp	 DWORD PTR tv129[ebp], 16 ; 00000010H
  000fb	74 1d		 je	 SHORT $LN8@DecryptBuf@3
  000fd	eb 36		 jmp	 SHORT $LN7@DecryptBuf@3
$LN9@DecryptBuf@3:

; 1531 : 		{
; 1532 : 		case 8:
; 1533 : 			DecryptBufferLRW64 (buf, (unsigned __int64) len, 1, cryptoInfo);

  000ff	8b 55 14	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00102	52		 push	 edx
  00103	6a 00		 push	 0
  00105	6a 01		 push	 1
  00107	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp+4]
  0010a	50		 push	 eax
  0010b	8b 4d 0c	 mov	 ecx, DWORD PTR _len$[ebp]
  0010e	51		 push	 ecx
  0010f	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00112	52		 push	 edx
  00113	e8 00 00 00 00	 call	 _DecryptBufferLRW64@24

; 1534 : 			break;

  00118	eb 31		 jmp	 SHORT $LN10@DecryptBuf@3
$LN8@DecryptBuf@3:

; 1535 : 
; 1536 : 		case 16:
; 1537 : 			DecryptBufferLRW128 (buf, (unsigned __int64) len, 1, cryptoInfo);

  0011a	8b 45 14	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  0011d	50		 push	 eax
  0011e	6a 00		 push	 0
  00120	6a 01		 push	 1
  00122	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp+4]
  00125	51		 push	 ecx
  00126	8b 55 0c	 mov	 edx, DWORD PTR _len$[ebp]
  00129	52		 push	 edx
  0012a	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0012d	50		 push	 eax
  0012e	e8 00 00 00 00	 call	 _DecryptBufferLRW128@24

; 1538 : 			break;

  00133	eb 16		 jmp	 SHORT $LN10@DecryptBuf@3
$LN7@DecryptBuf@3:

; 1539 : 
; 1540 : 		default:
; 1541 : 			TC_THROW_FATAL_EXCEPTION;

  00135	68 43 54 00 00	 push	 21571			; 00005443H
  0013a	6a 00		 push	 0
  0013c	6a 00		 push	 0
  0013e	68 05 06 00 00	 push	 1541			; 00000605H
  00143	6a 29		 push	 41			; 00000029H
  00145	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN10@DecryptBuf@3:

; 1542 : 		}
; 1543 : 		break;

  0014b	e9 c4 00 00 00	 jmp	 $LN20@DecryptBuf@3
$LN6@DecryptBuf@3:

; 1544 : 
; 1545 : 	case CBC:
; 1546 : 	case INNER_CBC:
; 1547 : 		{
; 1548 : 			/* Deprecated/legacy */
; 1549 : 
; 1550 : 			unsigned __int8 *ks = cryptoInfo->ks + EAGetKeyScheduleSize (cryptoInfo->ea);

  00150	8b 4d 14	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00153	8b 11		 mov	 edx, DWORD PTR [ecx]
  00155	52		 push	 edx
  00156	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4
  0015b	8b 4d 14	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  0015e	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  00162	89 55 e4	 mov	 DWORD PTR _ks$27816[ebp], edx

; 1551 : 			int cipher;
; 1552 : 			for (cipher = EAGetLastCipher (cryptoInfo->ea);
; 1553 : 				cipher != 0;
; 1554 : 				cipher = EAGetPreviousCipher (cryptoInfo->ea, cipher))

  00165	8b 45 14	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00168	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016a	51		 push	 ecx
  0016b	e8 00 00 00 00	 call	 _EAGetLastCipher@4
  00170	89 45 e0	 mov	 DWORD PTR _cipher$27817[ebp], eax
  00173	eb 12		 jmp	 SHORT $LN5@DecryptBuf@3
$LN4@DecryptBuf@3:
  00175	8b 55 e0	 mov	 edx, DWORD PTR _cipher$27817[ebp]
  00178	52		 push	 edx
  00179	8b 45 14	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  0017c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0017e	51		 push	 ecx
  0017f	e8 00 00 00 00	 call	 _EAGetPreviousCipher@8
  00184	89 45 e0	 mov	 DWORD PTR _cipher$27817[ebp], eax
$LN5@DecryptBuf@3:
  00187	83 7d e0 00	 cmp	 DWORD PTR _cipher$27817[ebp], 0
  0018b	74 3d		 je	 SHORT $LN3@DecryptBuf@3

; 1555 : 			{
; 1556 : 				ks -= CipherGetKeyScheduleSize (cipher);

  0018d	8b 55 e0	 mov	 edx, DWORD PTR _cipher$27817[ebp]
  00190	52		 push	 edx
  00191	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  00196	8b 4d e4	 mov	 ecx, DWORD PTR _ks$27816[ebp]
  00199	2b c8		 sub	 ecx, eax
  0019b	89 4d e4	 mov	 DWORD PTR _ks$27816[ebp], ecx

; 1557 : 
; 1558 : 				DecryptBufferCBC ((unsigned __int32 *) buf,
; 1559 : 					(unsigned int) len,
; 1560 : 					ks,
; 1561 : 					(unsigned __int32 *) cryptoInfo->k2,
; 1562 : 					(unsigned __int32 *) &cryptoInfo->k2[8],
; 1563 : 					0,
; 1564 : 					cipher);

  0019e	8b 55 e0	 mov	 edx, DWORD PTR _cipher$27817[ebp]
  001a1	52		 push	 edx
  001a2	6a 00		 push	 0
  001a4	8b 45 14	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  001a7	05 b0 42 00 00	 add	 eax, 17072		; 000042b0H
  001ac	50		 push	 eax
  001ad	8b 4d 14	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  001b0	81 c1 a8 42 00
	00		 add	 ecx, 17064		; 000042a8H
  001b6	51		 push	 ecx
  001b7	8b 55 e4	 mov	 edx, DWORD PTR _ks$27816[ebp]
  001ba	52		 push	 edx
  001bb	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  001be	50		 push	 eax
  001bf	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  001c2	51		 push	 ecx
  001c3	e8 00 00 00 00	 call	 _DecryptBufferCBC@28

; 1565 : 			}

  001c8	eb ab		 jmp	 SHORT $LN4@DecryptBuf@3
$LN3@DecryptBuf@3:

; 1566 : 		}
; 1567 : 		break;

  001ca	eb 48		 jmp	 SHORT $LN20@DecryptBuf@3
$LN2@DecryptBuf@3:

; 1568 : 
; 1569 : 	case OUTER_CBC:
; 1570 : 
; 1571 : 		/* Deprecated/legacy */
; 1572 : 
; 1573 : 		DecryptBufferCBC ((unsigned __int32 *) buf,
; 1574 : 			(unsigned int) len,
; 1575 : 			cryptoInfo->ks,
; 1576 : 			(unsigned __int32 *) cryptoInfo->k2,
; 1577 : 			(unsigned __int32 *) &cryptoInfo->k2[8],
; 1578 : 			cryptoInfo->ea,
; 1579 : 			0);

  001cc	6a 00		 push	 0
  001ce	8b 55 14	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  001d1	8b 02		 mov	 eax, DWORD PTR [edx]
  001d3	50		 push	 eax
  001d4	8b 4d 14	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  001d7	81 c1 b0 42 00
	00		 add	 ecx, 17072		; 000042b0H
  001dd	51		 push	 ecx
  001de	8b 55 14	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  001e1	81 c2 a8 42 00
	00		 add	 edx, 17064		; 000042a8H
  001e7	52		 push	 edx
  001e8	8b 45 14	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  001eb	83 c0 08	 add	 eax, 8
  001ee	50		 push	 eax
  001ef	8b 4d 0c	 mov	 ecx, DWORD PTR _len$[ebp]
  001f2	51		 push	 ecx
  001f3	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  001f6	52		 push	 edx
  001f7	e8 00 00 00 00	 call	 _DecryptBufferCBC@28

; 1580 : 
; 1581 : 		break;

  001fc	eb 16		 jmp	 SHORT $LN20@DecryptBuf@3
$LN1@DecryptBuf@3:

; 1582 : #endif	// #ifndef TC_NO_COMPILER_INT64
; 1583 : 
; 1584 : 	default:		
; 1585 : 		// Unknown/wrong ID
; 1586 : 		TC_THROW_FATAL_EXCEPTION;

  001fe	68 43 54 00 00	 push	 21571			; 00005443H
  00203	6a 00		 push	 0
  00205	6a 00		 push	 0
  00207	68 32 06 00 00	 push	 1586			; 00000632H
  0020c	6a 29		 push	 41			; 00000029H
  0020e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN20@DecryptBuf@3:

; 1587 : 	}
; 1588 : }

  00214	8b e5		 mov	 esp, ebp
  00216	5d		 pop	 ebp
  00217	c2 10 00	 ret	 16			; 00000010H
  0021a	8b ff		 npad	 2
$LN21@DecryptBuf@3:
  0021c	00 00 00 00	 DD	 $LN16@DecryptBuf@3
  00220	00 00 00 00	 DD	 $LN12@DecryptBuf@3
  00224	00 00 00 00	 DD	 $LN6@DecryptBuf@3
  00228	00 00 00 00	 DD	 $LN2@DecryptBuf@3
  0022c	00 00 00 00	 DD	 $LN6@DecryptBuf@3
_DecryptBuffer@16 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _DecryptBufferCBC@28
_TEXT	SEGMENT
tv208 = -56						; size = 8
tv68 = -48						; size = 4
_blockSize$ = -44					; size = 4
_bufIV$ = -40						; size = 16
_i$ = -24						; size = 8
_ct$ = -16						; size = 16
_data$ = 8						; size = 4
_len$ = 12						; size = 4
_ks$ = 16						; size = 4
_iv$ = 20						; size = 4
_whitening$ = 24					; size = 4
_ea$ = 28						; size = 4
_cipher$ = 32						; size = 4
_DecryptBufferCBC@28 PROC				; COMDAT

; 1161 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 38	 sub	 esp, 56			; 00000038H

; 1162 : 
; 1163 : 	/* IMPORTANT: This function has been deprecated (legacy) */
; 1164 : 
; 1165 : 	unsigned __int32 bufIV[4];
; 1166 : 	unsigned __int64 i;
; 1167 : 	unsigned __int32 ct[4];
; 1168 : 	int blockSize = CipherGetBlockSize (ea != 0 ? EAGetFirstCipher (ea) : cipher);

  00008	83 7d 1c 00	 cmp	 DWORD PTR _ea$[ebp], 0
  0000c	74 0e		 je	 SHORT $LN16@DecryptBuf@4
  0000e	8b 45 1c	 mov	 eax, DWORD PTR _ea$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  00017	89 45 d0	 mov	 DWORD PTR tv68[ebp], eax
  0001a	eb 06		 jmp	 SHORT $LN17@DecryptBuf@4
$LN16@DecryptBuf@4:
  0001c	8b 4d 20	 mov	 ecx, DWORD PTR _cipher$[ebp]
  0001f	89 4d d0	 mov	 DWORD PTR tv68[ebp], ecx
$LN17@DecryptBuf@4:
  00022	8b 55 d0	 mov	 edx, DWORD PTR tv68[ebp]
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 _CipherGetBlockSize@4
  0002b	89 45 d4	 mov	 DWORD PTR _blockSize$[ebp], eax

; 1169 : 
; 1170 : 	if (len % blockSize)

  0002e	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  00031	33 d2		 xor	 edx, edx
  00033	f7 75 d4	 div	 DWORD PTR _blockSize$[ebp]
  00036	85 d2		 test	 edx, edx
  00038	74 16		 je	 SHORT $LN13@DecryptBuf@4

; 1171 : 		TC_THROW_FATAL_EXCEPTION;

  0003a	68 43 54 00 00	 push	 21571			; 00005443H
  0003f	6a 00		 push	 0
  00041	6a 00		 push	 0
  00043	68 93 04 00 00	 push	 1171			; 00000493H
  00048	6a 29		 push	 41			; 00000029H
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN13@DecryptBuf@4:

; 1172 : 
; 1173 : 	//  IV
; 1174 : 	bufIV[0] = iv[0];

  00050	8b 45 14	 mov	 eax, DWORD PTR _iv$[ebp]
  00053	8b 08		 mov	 ecx, DWORD PTR [eax]
  00055	89 4d d8	 mov	 DWORD PTR _bufIV$[ebp], ecx

; 1175 : 	bufIV[1] = iv[1];

  00058	8b 55 14	 mov	 edx, DWORD PTR _iv$[ebp]
  0005b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0005e	89 45 dc	 mov	 DWORD PTR _bufIV$[ebp+4], eax

; 1176 : 	if (blockSize == 16)

  00061	83 7d d4 10	 cmp	 DWORD PTR _blockSize$[ebp], 16 ; 00000010H
  00065	75 12		 jne	 SHORT $LN12@DecryptBuf@4

; 1177 : 	{
; 1178 : 		bufIV[2] = iv[2];

  00067	8b 4d 14	 mov	 ecx, DWORD PTR _iv$[ebp]
  0006a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0006d	89 55 e0	 mov	 DWORD PTR _bufIV$[ebp+8], edx

; 1179 : 		bufIV[3] = iv[3];

  00070	8b 45 14	 mov	 eax, DWORD PTR _iv$[ebp]
  00073	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00076	89 4d e4	 mov	 DWORD PTR _bufIV$[ebp+12], ecx
$LN12@DecryptBuf@4:

; 1180 : 	}
; 1181 : 
; 1182 : 	// Decrypt each block
; 1183 : 	for (i = 0; i < len/blockSize; i++)

  00079	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00080	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp+4], 0
  00087	eb 12		 jmp	 SHORT $LN11@DecryptBuf@4
$LN10@DecryptBuf@4:
  00089	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  0008c	83 c2 01	 add	 edx, 1
  0008f	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp+4]
  00092	83 d0 00	 adc	 eax, 0
  00095	89 55 e8	 mov	 DWORD PTR _i$[ebp], edx
  00098	89 45 ec	 mov	 DWORD PTR _i$[ebp+4], eax
$LN11@DecryptBuf@4:
  0009b	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  0009e	33 d2		 xor	 edx, edx
  000a0	f7 75 d4	 div	 DWORD PTR _blockSize$[ebp]
  000a3	33 c9		 xor	 ecx, ecx
  000a5	89 45 c8	 mov	 DWORD PTR tv208[ebp], eax
  000a8	89 4d cc	 mov	 DWORD PTR tv208[ebp+4], ecx
  000ab	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp+4]
  000ae	3b 55 cc	 cmp	 edx, DWORD PTR tv208[ebp+4]
  000b1	0f 87 5d 01 00
	00		 ja	 $LN15@DecryptBuf@4
  000b7	72 0c		 jb	 SHORT $LN18@DecryptBuf@4
  000b9	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  000bc	3b 45 c8	 cmp	 eax, DWORD PTR tv208[ebp]
  000bf	0f 83 4f 01 00
	00		 jae	 $LN15@DecryptBuf@4
$LN18@DecryptBuf@4:

; 1184 : 	{
; 1185 : 		// Dewhitening
; 1186 : 		data[0] ^= whitening[0];

  000c5	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  000c8	8b 55 18	 mov	 edx, DWORD PTR _whitening$[ebp]
  000cb	8b 01		 mov	 eax, DWORD PTR [ecx]
  000cd	33 02		 xor	 eax, DWORD PTR [edx]
  000cf	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  000d2	89 01		 mov	 DWORD PTR [ecx], eax

; 1187 : 		data[1] ^= whitening[1];

  000d4	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  000d7	8b 45 18	 mov	 eax, DWORD PTR _whitening$[ebp]
  000da	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000dd	33 48 04	 xor	 ecx, DWORD PTR [eax+4]
  000e0	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  000e3	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1188 : 		if (blockSize == 16)

  000e6	83 7d d4 10	 cmp	 DWORD PTR _blockSize$[ebp], 16 ; 00000010H
  000ea	75 23		 jne	 SHORT $LN8@DecryptBuf@4

; 1189 : 		{
; 1190 : 			data[2] ^= whitening[0];

  000ec	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  000ef	8b 4d 18	 mov	 ecx, DWORD PTR _whitening$[ebp]
  000f2	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000f5	33 11		 xor	 edx, DWORD PTR [ecx]
  000f7	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  000fa	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1191 : 			data[3] ^= whitening[1];

  000fd	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00100	8b 55 18	 mov	 edx, DWORD PTR _whitening$[ebp]
  00103	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00106	33 42 04	 xor	 eax, DWORD PTR [edx+4]
  00109	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  0010c	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$LN8@DecryptBuf@4:

; 1192 : 		}
; 1193 : 
; 1194 : 		// CBC
; 1195 : 		ct[0] = data[0];

  0010f	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  00112	8b 02		 mov	 eax, DWORD PTR [edx]
  00114	89 45 f0	 mov	 DWORD PTR _ct$[ebp], eax

; 1196 : 		ct[1] = data[1];

  00117	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  0011a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0011d	89 55 f4	 mov	 DWORD PTR _ct$[ebp+4], edx

; 1197 : 		if (blockSize == 16)

  00120	83 7d d4 10	 cmp	 DWORD PTR _blockSize$[ebp], 16 ; 00000010H
  00124	75 12		 jne	 SHORT $LN7@DecryptBuf@4

; 1198 : 		{
; 1199 : 			ct[2] = data[2];

  00126	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  00129	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0012c	89 4d f8	 mov	 DWORD PTR _ct$[ebp+8], ecx

; 1200 : 			ct[3] = data[3];

  0012f	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  00132	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00135	89 45 fc	 mov	 DWORD PTR _ct$[ebp+12], eax
$LN7@DecryptBuf@4:

; 1201 : 		}
; 1202 : 
; 1203 : 		if (ea != 0)

  00138	83 7d 1c 00	 cmp	 DWORD PTR _ea$[ebp], 0
  0013c	74 59		 je	 SHORT $LN6@DecryptBuf@4

; 1204 : 		{
; 1205 : 			// Outer-CBC
; 1206 : 			ks += EAGetKeyScheduleSize (ea);

  0013e	8b 4d 1c	 mov	 ecx, DWORD PTR _ea$[ebp]
  00141	51		 push	 ecx
  00142	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4
  00147	03 45 10	 add	 eax, DWORD PTR _ks$[ebp]
  0014a	89 45 10	 mov	 DWORD PTR _ks$[ebp], eax

; 1207 : 			for (cipher = EAGetLastCipher (ea); cipher != 0; cipher = EAGetPreviousCipher (ea, cipher))

  0014d	8b 55 1c	 mov	 edx, DWORD PTR _ea$[ebp]
  00150	52		 push	 edx
  00151	e8 00 00 00 00	 call	 _EAGetLastCipher@4
  00156	89 45 20	 mov	 DWORD PTR _cipher$[ebp], eax
  00159	eb 10		 jmp	 SHORT $LN5@DecryptBuf@4
$LN4@DecryptBuf@4:
  0015b	8b 45 20	 mov	 eax, DWORD PTR _cipher$[ebp]
  0015e	50		 push	 eax
  0015f	8b 4d 1c	 mov	 ecx, DWORD PTR _ea$[ebp]
  00162	51		 push	 ecx
  00163	e8 00 00 00 00	 call	 _EAGetPreviousCipher@8
  00168	89 45 20	 mov	 DWORD PTR _cipher$[ebp], eax
$LN5@DecryptBuf@4:
  0016b	83 7d 20 00	 cmp	 DWORD PTR _cipher$[ebp], 0
  0016f	74 24		 je	 SHORT $LN3@DecryptBuf@4

; 1208 : 			{
; 1209 : 				ks -= CipherGetKeyScheduleSize (cipher);

  00171	8b 55 20	 mov	 edx, DWORD PTR _cipher$[ebp]
  00174	52		 push	 edx
  00175	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  0017a	8b 4d 10	 mov	 ecx, DWORD PTR _ks$[ebp]
  0017d	2b c8		 sub	 ecx, eax
  0017f	89 4d 10	 mov	 DWORD PTR _ks$[ebp], ecx

; 1210 : 				DecipherBlock (cipher, data, ks);

  00182	8b 55 10	 mov	 edx, DWORD PTR _ks$[ebp]
  00185	52		 push	 edx
  00186	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  00189	50		 push	 eax
  0018a	8b 4d 20	 mov	 ecx, DWORD PTR _cipher$[ebp]
  0018d	51		 push	 ecx
  0018e	e8 00 00 00 00	 call	 _DecipherBlock@12

; 1211 : 			}

  00193	eb c6		 jmp	 SHORT $LN4@DecryptBuf@4
$LN3@DecryptBuf@4:

; 1212 : 		}
; 1213 : 		else

  00195	eb 11		 jmp	 SHORT $LN2@DecryptBuf@4
$LN6@DecryptBuf@4:

; 1214 : 		{
; 1215 : 			// CBC/inner-CBC
; 1216 : 			DecipherBlock (cipher, data, ks);

  00197	8b 55 10	 mov	 edx, DWORD PTR _ks$[ebp]
  0019a	52		 push	 edx
  0019b	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  0019e	50		 push	 eax
  0019f	8b 4d 20	 mov	 ecx, DWORD PTR _cipher$[ebp]
  001a2	51		 push	 ecx
  001a3	e8 00 00 00 00	 call	 _DecipherBlock@12
$LN2@DecryptBuf@4:

; 1217 : 		}
; 1218 : 
; 1219 : 		// CBC
; 1220 : 		data[0] ^= bufIV[0];

  001a8	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  001ab	8b 02		 mov	 eax, DWORD PTR [edx]
  001ad	33 45 d8	 xor	 eax, DWORD PTR _bufIV$[ebp]
  001b0	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  001b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1221 : 		data[1] ^= bufIV[1];

  001b5	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  001b8	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001bb	33 45 dc	 xor	 eax, DWORD PTR _bufIV$[ebp+4]
  001be	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  001c1	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1222 : 		bufIV[0] = ct[0];

  001c4	8b 55 f0	 mov	 edx, DWORD PTR _ct$[ebp]
  001c7	89 55 d8	 mov	 DWORD PTR _bufIV$[ebp], edx

; 1223 : 		bufIV[1] = ct[1];

  001ca	8b 45 f4	 mov	 eax, DWORD PTR _ct$[ebp+4]
  001cd	89 45 dc	 mov	 DWORD PTR _bufIV$[ebp+4], eax

; 1224 : 		if (blockSize == 16)

  001d0	83 7d d4 10	 cmp	 DWORD PTR _blockSize$[ebp], 16 ; 00000010H
  001d4	75 2a		 jne	 SHORT $LN1@DecryptBuf@4

; 1225 : 		{
; 1226 : 			data[2] ^= bufIV[2];

  001d6	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  001d9	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  001dc	33 55 e0	 xor	 edx, DWORD PTR _bufIV$[ebp+8]
  001df	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  001e2	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1227 : 			data[3] ^= bufIV[3];

  001e5	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  001e8	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  001eb	33 55 e4	 xor	 edx, DWORD PTR _bufIV$[ebp+12]
  001ee	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  001f1	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 1228 : 			bufIV[2] = ct[2];

  001f4	8b 4d f8	 mov	 ecx, DWORD PTR _ct$[ebp+8]
  001f7	89 4d e0	 mov	 DWORD PTR _bufIV$[ebp+8], ecx

; 1229 : 			bufIV[3] = ct[3];

  001fa	8b 55 fc	 mov	 edx, DWORD PTR _ct$[ebp+12]
  001fd	89 55 e4	 mov	 DWORD PTR _bufIV$[ebp+12], edx
$LN1@DecryptBuf@4:

; 1230 : 		}
; 1231 : 
; 1232 : 		data += blockSize / sizeof(*data);

  00200	8b 45 d4	 mov	 eax, DWORD PTR _blockSize$[ebp]
  00203	c1 e8 02	 shr	 eax, 2
  00206	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00209	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  0020c	89 55 08	 mov	 DWORD PTR _data$[ebp], edx

; 1233 : 	}

  0020f	e9 75 fe ff ff	 jmp	 $LN10@DecryptBuf@4
$LN15@DecryptBuf@4:

; 1234 : }

  00214	8b e5		 mov	 esp, ebp
  00216	5d		 pop	 ebp
  00217	c2 1c 00	 ret	 28			; 0000001cH
_DecryptBufferCBC@28 ENDP
_TEXT	ENDS
PUBLIC	_DecryptDataUnits@16
; Function compile flags: /Odtp
;	COMDAT _DecryptDataUnits@16
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_structUnitNo$ = 12					; size = 4
_nbrUnits$ = 16						; size = 4
_ci$ = 20						; size = 4
_DecryptDataUnits@16 PROC				; COMDAT

; 1595 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1596 : 	EncryptionThreadPoolDoWork (DecryptDataUnitsWork, buf, structUnitNo, nbrUnits, ci);

  00005	8b 45 14	 mov	 eax, DWORD PTR _ci$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 10	 mov	 ecx, DWORD PTR _nbrUnits$[ebp]
  0000c	51		 push	 ecx
  0000d	8b 55 0c	 mov	 edx, DWORD PTR _structUnitNo$[ebp]
  00010	52		 push	 edx
  00011	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00014	50		 push	 eax
  00015	6a 01		 push	 1
  00017	e8 00 00 00 00	 call	 _EncryptionThreadPoolDoWork@20

; 1597 : }

  0001c	5d		 pop	 ebp
  0001d	c2 10 00	 ret	 16			; 00000010H
_DecryptDataUnits@16 ENDP
_TEXT	ENDS
PUBLIC	_DecryptDataUnitsCurrentThread@20
; Function compile flags: /Odtp
;	COMDAT _DecryptDataUnitsCurrentThread@20
_TEXT	SEGMENT
tv376 = -84						; size = 8
tv332 = -76						; size = 8
tv131 = -68						; size = 4
tv68 = -64						; size = 4
_ks2$ = -60						; size = 4
_cipher$ = -56						; size = 4
_ks$ = -52						; size = 4
_iv$ = -48						; size = 4
_ea$ = -44						; size = 4
_unitNo$ = -40						; size = 8
_sectorIV$ = -28					; size = 16
_iv64$ = -12						; size = 4
_secWhitening$ = -8					; size = 8
_buf$ = 8						; size = 4
_structUnitNo$ = 12					; size = 4
_nbrUnits$ = 16						; size = 8
_ci$ = 24						; size = 4
_DecryptDataUnitsCurrentThread@20 PROC			; COMDAT

; 1601 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 54	 sub	 esp, 84			; 00000054H
  00008	56		 push	 esi

; 1602 : 	int ea = ci->ea;

  00009	8b 45 18	 mov	 eax, DWORD PTR _ci$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d d4	 mov	 DWORD PTR _ea$[ebp], ecx

; 1603 : 	unsigned __int8 *ks = ci->ks;

  00011	8b 55 18	 mov	 edx, DWORD PTR _ci$[ebp]
  00014	83 c2 08	 add	 edx, 8
  00017	89 55 cc	 mov	 DWORD PTR _ks$[ebp], edx

; 1604 : 	unsigned __int8 *ks2 = ci->ks2;

  0001a	8b 45 18	 mov	 eax, DWORD PTR _ci$[ebp]
  0001d	05 d4 14 00 00	 add	 eax, 5332		; 000014d4H
  00022	89 45 c4	 mov	 DWORD PTR _ks2$[ebp], eax

; 1605 : 	int cipher;
; 1606 : 
; 1607 : #ifndef TC_NO_COMPILER_INT64
; 1608 : 	void *iv = ci->k2;									// Deprecated/legacy

  00025	8b 4d 18	 mov	 ecx, DWORD PTR _ci$[ebp]
  00028	81 c1 a8 42 00
	00		 add	 ecx, 17064		; 000042a8H
  0002e	89 4d d0	 mov	 DWORD PTR _iv$[ebp], ecx

; 1609 : 	unsigned __int64 unitNo = structUnitNo->Value;

  00031	8b 55 0c	 mov	 edx, DWORD PTR _structUnitNo$[ebp]
  00034	8b 02		 mov	 eax, DWORD PTR [edx]
  00036	89 45 d8	 mov	 DWORD PTR _unitNo$[ebp], eax
  00039	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0003c	89 4d dc	 mov	 DWORD PTR _unitNo$[ebp+4], ecx

; 1610 : 	unsigned __int64 *iv64 = (unsigned __int64 *) iv;	// Deprecated/legacy

  0003f	8b 55 d0	 mov	 edx, DWORD PTR _iv$[ebp]
  00042	89 55 f4	 mov	 DWORD PTR _iv64$[ebp], edx

; 1611 : 	unsigned __int32 sectorIV[4];						// Deprecated/legacy
; 1612 : 	unsigned __int32 secWhitening[2];					// Deprecated/legacy
; 1613 : #endif	// #ifndef TC_NO_COMPILER_INT64
; 1614 : 
; 1615 : 
; 1616 : 	switch (ci->mode)

  00045	8b 45 18	 mov	 eax, DWORD PTR _ci$[ebp]
  00048	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004b	89 4d c0	 mov	 DWORD PTR tv68[ebp], ecx
  0004e	8b 55 c0	 mov	 edx, DWORD PTR tv68[ebp]
  00051	83 ea 01	 sub	 edx, 1
  00054	89 55 c0	 mov	 DWORD PTR tv68[ebp], edx
  00057	83 7d c0 04	 cmp	 DWORD PTR tv68[ebp], 4
  0005b	0f 87 c4 02 00
	00		 ja	 $LN1@DecryptDat
  00061	8b 45 c0	 mov	 eax, DWORD PTR tv68[ebp]
  00064	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN25@DecryptDat[eax*4]
$LN20@DecryptDat:

; 1617 : 	{
; 1618 : 	case XTS:
; 1619 : 		ks += EAGetKeyScheduleSize (ea);

  0006b	8b 4d d4	 mov	 ecx, DWORD PTR _ea$[ebp]
  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4
  00074	03 45 cc	 add	 eax, DWORD PTR _ks$[ebp]
  00077	89 45 cc	 mov	 DWORD PTR _ks$[ebp], eax

; 1620 : 		ks2 += EAGetKeyScheduleSize (ea);

  0007a	8b 55 d4	 mov	 edx, DWORD PTR _ea$[ebp]
  0007d	52		 push	 edx
  0007e	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4
  00083	03 45 c4	 add	 eax, DWORD PTR _ks2$[ebp]
  00086	89 45 c4	 mov	 DWORD PTR _ks2$[ebp], eax

; 1621 : 
; 1622 : 		for (cipher = EAGetLastCipher (ea); cipher != 0; cipher = EAGetPreviousCipher (ea, cipher))

  00089	8b 45 d4	 mov	 eax, DWORD PTR _ea$[ebp]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 _EAGetLastCipher@4
  00092	89 45 c8	 mov	 DWORD PTR _cipher$[ebp], eax
  00095	eb 10		 jmp	 SHORT $LN19@DecryptDat
$LN18@DecryptDat:
  00097	8b 4d c8	 mov	 ecx, DWORD PTR _cipher$[ebp]
  0009a	51		 push	 ecx
  0009b	8b 55 d4	 mov	 edx, DWORD PTR _ea$[ebp]
  0009e	52		 push	 edx
  0009f	e8 00 00 00 00	 call	 _EAGetPreviousCipher@8
  000a4	89 45 c8	 mov	 DWORD PTR _cipher$[ebp], eax
$LN19@DecryptDat:
  000a7	83 7d c8 00	 cmp	 DWORD PTR _cipher$[ebp], 0
  000ab	74 55		 je	 SHORT $LN17@DecryptDat

; 1623 : 		{
; 1624 : 			ks -= CipherGetKeyScheduleSize (cipher);

  000ad	8b 45 c8	 mov	 eax, DWORD PTR _cipher$[ebp]
  000b0	50		 push	 eax
  000b1	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  000b6	8b 4d cc	 mov	 ecx, DWORD PTR _ks$[ebp]
  000b9	2b c8		 sub	 ecx, eax
  000bb	89 4d cc	 mov	 DWORD PTR _ks$[ebp], ecx

; 1625 : 			ks2 -= CipherGetKeyScheduleSize (cipher);

  000be	8b 55 c8	 mov	 edx, DWORD PTR _cipher$[ebp]
  000c1	52		 push	 edx
  000c2	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  000c7	8b 4d c4	 mov	 ecx, DWORD PTR _ks2$[ebp]
  000ca	2b c8		 sub	 ecx, eax
  000cc	89 4d c4	 mov	 DWORD PTR _ks2$[ebp], ecx

; 1626 : 
; 1627 : 			DecryptBufferXTS (buf,
; 1628 : 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1629 : 				structUnitNo,
; 1630 : 				0,
; 1631 : 				ks,
; 1632 : 				ks2,
; 1633 : 				cipher);

  000cf	8b 55 c8	 mov	 edx, DWORD PTR _cipher$[ebp]
  000d2	52		 push	 edx
  000d3	8b 45 c4	 mov	 eax, DWORD PTR _ks2$[ebp]
  000d6	50		 push	 eax
  000d7	8b 4d cc	 mov	 ecx, DWORD PTR _ks$[ebp]
  000da	51		 push	 ecx
  000db	6a 00		 push	 0
  000dd	8b 55 0c	 mov	 edx, DWORD PTR _structUnitNo$[ebp]
  000e0	52		 push	 edx
  000e1	6a 00		 push	 0
  000e3	68 00 02 00 00	 push	 512			; 00000200H
  000e8	8b 45 14	 mov	 eax, DWORD PTR _nbrUnits$[ebp+4]
  000eb	50		 push	 eax
  000ec	8b 4d 10	 mov	 ecx, DWORD PTR _nbrUnits$[ebp]
  000ef	51		 push	 ecx
  000f0	e8 00 00 00 00	 call	 __allmul
  000f5	52		 push	 edx
  000f6	50		 push	 eax
  000f7	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  000fa	52		 push	 edx
  000fb	e8 00 00 00 00	 call	 _DecryptBufferXTS@32

; 1634 : 		}

  00100	eb 95		 jmp	 SHORT $LN18@DecryptDat
$LN17@DecryptDat:

; 1635 : 		break;

  00102	e9 34 02 00 00	 jmp	 $LN24@DecryptDat
$LN16@DecryptDat:

; 1636 : 
; 1637 : #ifndef TC_NO_COMPILER_INT64
; 1638 : 	case LRW:
; 1639 : 
; 1640 : 		/* Deprecated/legacy */
; 1641 : 
; 1642 : 		switch (CipherGetBlockSize (EAGetFirstCipher (ea)))

  00107	8b 45 d4	 mov	 eax, DWORD PTR _ea$[ebp]
  0010a	50		 push	 eax
  0010b	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  00110	50		 push	 eax
  00111	e8 00 00 00 00	 call	 _CipherGetBlockSize@4
  00116	89 45 bc	 mov	 DWORD PTR tv131[ebp], eax
  00119	83 7d bc 08	 cmp	 DWORD PTR tv131[ebp], 8
  0011d	74 08		 je	 SHORT $LN13@DecryptDat
  0011f	83 7d bc 10	 cmp	 DWORD PTR tv131[ebp], 16 ; 00000010H
  00123	74 3c		 je	 SHORT $LN12@DecryptDat
  00125	eb 74		 jmp	 SHORT $LN11@DecryptDat
$LN13@DecryptDat:

; 1643 : 		{
; 1644 : 		case 8:
; 1645 : 			DecryptBufferLRW64 (buf,
; 1646 : 				(unsigned __int64) nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1647 : 				DataUnit2LRWIndex (unitNo, 8, ci),
; 1648 : 				ci);

  00127	8b 4d 18	 mov	 ecx, DWORD PTR _ci$[ebp]
  0012a	51		 push	 ecx
  0012b	8b 55 18	 mov	 edx, DWORD PTR _ci$[ebp]
  0012e	52		 push	 edx
  0012f	6a 08		 push	 8
  00131	8b 45 dc	 mov	 eax, DWORD PTR _unitNo$[ebp+4]
  00134	50		 push	 eax
  00135	8b 4d d8	 mov	 ecx, DWORD PTR _unitNo$[ebp]
  00138	51		 push	 ecx
  00139	e8 00 00 00 00	 call	 _DataUnit2LRWIndex@16
  0013e	52		 push	 edx
  0013f	50		 push	 eax
  00140	6a 00		 push	 0
  00142	68 00 02 00 00	 push	 512			; 00000200H
  00147	8b 55 14	 mov	 edx, DWORD PTR _nbrUnits$[ebp+4]
  0014a	52		 push	 edx
  0014b	8b 45 10	 mov	 eax, DWORD PTR _nbrUnits$[ebp]
  0014e	50		 push	 eax
  0014f	e8 00 00 00 00	 call	 __allmul
  00154	52		 push	 edx
  00155	50		 push	 eax
  00156	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00159	51		 push	 ecx
  0015a	e8 00 00 00 00	 call	 _DecryptBufferLRW64@24

; 1649 : 			break;

  0015f	eb 50		 jmp	 SHORT $LN14@DecryptDat
$LN12@DecryptDat:

; 1650 : 
; 1651 : 		case 16:
; 1652 : 			DecryptBufferLRW128 (buf,
; 1653 : 				(unsigned __int64) nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1654 : 				DataUnit2LRWIndex (unitNo, 16, ci),
; 1655 : 				ci);

  00161	8b 55 18	 mov	 edx, DWORD PTR _ci$[ebp]
  00164	52		 push	 edx
  00165	8b 45 18	 mov	 eax, DWORD PTR _ci$[ebp]
  00168	50		 push	 eax
  00169	6a 10		 push	 16			; 00000010H
  0016b	8b 4d dc	 mov	 ecx, DWORD PTR _unitNo$[ebp+4]
  0016e	51		 push	 ecx
  0016f	8b 55 d8	 mov	 edx, DWORD PTR _unitNo$[ebp]
  00172	52		 push	 edx
  00173	e8 00 00 00 00	 call	 _DataUnit2LRWIndex@16
  00178	52		 push	 edx
  00179	50		 push	 eax
  0017a	6a 00		 push	 0
  0017c	68 00 02 00 00	 push	 512			; 00000200H
  00181	8b 45 14	 mov	 eax, DWORD PTR _nbrUnits$[ebp+4]
  00184	50		 push	 eax
  00185	8b 4d 10	 mov	 ecx, DWORD PTR _nbrUnits$[ebp]
  00188	51		 push	 ecx
  00189	e8 00 00 00 00	 call	 __allmul
  0018e	52		 push	 edx
  0018f	50		 push	 eax
  00190	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00193	52		 push	 edx
  00194	e8 00 00 00 00	 call	 _DecryptBufferLRW128@24

; 1656 : 			break;

  00199	eb 16		 jmp	 SHORT $LN14@DecryptDat
$LN11@DecryptDat:

; 1657 : 
; 1658 : 		default:
; 1659 : 			TC_THROW_FATAL_EXCEPTION;

  0019b	68 43 54 00 00	 push	 21571			; 00005443H
  001a0	6a 00		 push	 0
  001a2	6a 00		 push	 0
  001a4	68 7b 06 00 00	 push	 1659			; 0000067bH
  001a9	6a 29		 push	 41			; 00000029H
  001ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN14@DecryptDat:

; 1660 : 		}
; 1661 : 		break;

  001b1	e9 85 01 00 00	 jmp	 $LN24@DecryptDat
$LN9@DecryptDat:

; 1662 : 
; 1663 : 	case CBC:
; 1664 : 	case INNER_CBC:
; 1665 : 
; 1666 : 		/* Deprecated/legacy */
; 1667 : 
; 1668 : 		while (nbrUnits--)

  001b6	8b 45 10	 mov	 eax, DWORD PTR _nbrUnits$[ebp]
  001b9	8b 4d 14	 mov	 ecx, DWORD PTR _nbrUnits$[ebp+4]
  001bc	8b 55 10	 mov	 edx, DWORD PTR _nbrUnits$[ebp]
  001bf	83 ea 01	 sub	 edx, 1
  001c2	8b 75 14	 mov	 esi, DWORD PTR _nbrUnits$[ebp+4]
  001c5	83 de 00	 sbb	 esi, 0
  001c8	89 55 10	 mov	 DWORD PTR _nbrUnits$[ebp], edx
  001cb	89 75 14	 mov	 DWORD PTR _nbrUnits$[ebp+4], esi
  001ce	89 45 b4	 mov	 DWORD PTR tv332[ebp], eax
  001d1	89 4d b8	 mov	 DWORD PTR tv332[ebp+4], ecx
  001d4	8b 45 b4	 mov	 eax, DWORD PTR tv332[ebp]
  001d7	0b 45 b8	 or	 eax, DWORD PTR tv332[ebp+4]
  001da	0f 84 ac 00 00
	00		 je	 $LN8@DecryptDat

; 1669 : 		{
; 1670 : 			ks += EAGetKeyScheduleSize (ea);

  001e0	8b 4d d4	 mov	 ecx, DWORD PTR _ea$[ebp]
  001e3	51		 push	 ecx
  001e4	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4
  001e9	03 45 cc	 add	 eax, DWORD PTR _ks$[ebp]
  001ec	89 45 cc	 mov	 DWORD PTR _ks$[ebp], eax

; 1671 : 			for (cipher = EAGetLastCipher (ea); cipher != 0; cipher = EAGetPreviousCipher (ea, cipher))

  001ef	8b 55 d4	 mov	 edx, DWORD PTR _ea$[ebp]
  001f2	52		 push	 edx
  001f3	e8 00 00 00 00	 call	 _EAGetLastCipher@4
  001f8	89 45 c8	 mov	 DWORD PTR _cipher$[ebp], eax
  001fb	eb 10		 jmp	 SHORT $LN7@DecryptDat
$LN6@DecryptDat:
  001fd	8b 45 c8	 mov	 eax, DWORD PTR _cipher$[ebp]
  00200	50		 push	 eax
  00201	8b 4d d4	 mov	 ecx, DWORD PTR _ea$[ebp]
  00204	51		 push	 ecx
  00205	e8 00 00 00 00	 call	 _EAGetPreviousCipher@8
  0020a	89 45 c8	 mov	 DWORD PTR _cipher$[ebp], eax
$LN7@DecryptDat:
  0020d	83 7d c8 00	 cmp	 DWORD PTR _cipher$[ebp], 0
  00211	74 56		 je	 SHORT $LN5@DecryptDat

; 1672 : 			{
; 1673 : 				InitSectorIVAndWhitening (unitNo, CipherGetBlockSize (cipher), sectorIV, iv64, secWhitening);

  00213	8d 55 f8	 lea	 edx, DWORD PTR _secWhitening$[ebp]
  00216	52		 push	 edx
  00217	8b 45 f4	 mov	 eax, DWORD PTR _iv64$[ebp]
  0021a	50		 push	 eax
  0021b	8d 4d e4	 lea	 ecx, DWORD PTR _sectorIV$[ebp]
  0021e	51		 push	 ecx
  0021f	8b 55 c8	 mov	 edx, DWORD PTR _cipher$[ebp]
  00222	52		 push	 edx
  00223	e8 00 00 00 00	 call	 _CipherGetBlockSize@4
  00228	50		 push	 eax
  00229	8b 45 dc	 mov	 eax, DWORD PTR _unitNo$[ebp+4]
  0022c	50		 push	 eax
  0022d	8b 4d d8	 mov	 ecx, DWORD PTR _unitNo$[ebp]
  00230	51		 push	 ecx
  00231	e8 00 00 00 00	 call	 _InitSectorIVAndWhitening@24

; 1674 : 
; 1675 : 				ks -= CipherGetKeyScheduleSize (cipher);

  00236	8b 55 c8	 mov	 edx, DWORD PTR _cipher$[ebp]
  00239	52		 push	 edx
  0023a	e8 00 00 00 00	 call	 _CipherGetKeyScheduleSize@4
  0023f	8b 4d cc	 mov	 ecx, DWORD PTR _ks$[ebp]
  00242	2b c8		 sub	 ecx, eax
  00244	89 4d cc	 mov	 DWORD PTR _ks$[ebp], ecx

; 1676 : 
; 1677 : 				DecryptBufferCBC ((unsigned __int32 *) buf,
; 1678 : 					ENCRYPTION_DATA_UNIT_SIZE,
; 1679 : 					ks,
; 1680 : 					sectorIV,
; 1681 : 					secWhitening,
; 1682 : 					0,
; 1683 : 					cipher);

  00247	8b 55 c8	 mov	 edx, DWORD PTR _cipher$[ebp]
  0024a	52		 push	 edx
  0024b	6a 00		 push	 0
  0024d	8d 45 f8	 lea	 eax, DWORD PTR _secWhitening$[ebp]
  00250	50		 push	 eax
  00251	8d 4d e4	 lea	 ecx, DWORD PTR _sectorIV$[ebp]
  00254	51		 push	 ecx
  00255	8b 55 cc	 mov	 edx, DWORD PTR _ks$[ebp]
  00258	52		 push	 edx
  00259	68 00 02 00 00	 push	 512			; 00000200H
  0025e	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00261	50		 push	 eax
  00262	e8 00 00 00 00	 call	 _DecryptBufferCBC@28

; 1684 : 			}

  00267	eb 94		 jmp	 SHORT $LN6@DecryptDat
$LN5@DecryptDat:

; 1685 : 			buf += ENCRYPTION_DATA_UNIT_SIZE;

  00269	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  0026c	81 c1 00 02 00
	00		 add	 ecx, 512		; 00000200H
  00272	89 4d 08	 mov	 DWORD PTR _buf$[ebp], ecx

; 1686 : 			unitNo++;

  00275	8b 55 d8	 mov	 edx, DWORD PTR _unitNo$[ebp]
  00278	83 c2 01	 add	 edx, 1
  0027b	8b 45 dc	 mov	 eax, DWORD PTR _unitNo$[ebp+4]
  0027e	83 d0 00	 adc	 eax, 0
  00281	89 55 d8	 mov	 DWORD PTR _unitNo$[ebp], edx
  00284	89 45 dc	 mov	 DWORD PTR _unitNo$[ebp+4], eax

; 1687 : 		}

  00287	e9 2a ff ff ff	 jmp	 $LN9@DecryptDat
$LN8@DecryptDat:

; 1688 : 		break;

  0028c	e9 aa 00 00 00	 jmp	 $LN24@DecryptDat
$LN3@DecryptDat:

; 1689 : 
; 1690 : 	case OUTER_CBC:
; 1691 : 
; 1692 : 		/* Deprecated/legacy */
; 1693 : 
; 1694 : 		while (nbrUnits--)

  00291	8b 4d 10	 mov	 ecx, DWORD PTR _nbrUnits$[ebp]
  00294	8b 55 14	 mov	 edx, DWORD PTR _nbrUnits$[ebp+4]
  00297	8b 45 10	 mov	 eax, DWORD PTR _nbrUnits$[ebp]
  0029a	83 e8 01	 sub	 eax, 1
  0029d	8b 75 14	 mov	 esi, DWORD PTR _nbrUnits$[ebp+4]
  002a0	83 de 00	 sbb	 esi, 0
  002a3	89 45 10	 mov	 DWORD PTR _nbrUnits$[ebp], eax
  002a6	89 75 14	 mov	 DWORD PTR _nbrUnits$[ebp+4], esi
  002a9	89 4d ac	 mov	 DWORD PTR tv376[ebp], ecx
  002ac	89 55 b0	 mov	 DWORD PTR tv376[ebp+4], edx
  002af	8b 4d ac	 mov	 ecx, DWORD PTR tv376[ebp]
  002b2	0b 4d b0	 or	 ecx, DWORD PTR tv376[ebp+4]
  002b5	74 6c		 je	 SHORT $LN2@DecryptDat

; 1695 : 		{
; 1696 : 			InitSectorIVAndWhitening (unitNo, CipherGetBlockSize (EAGetFirstCipher (ea)), sectorIV, iv64, secWhitening);

  002b7	8d 55 f8	 lea	 edx, DWORD PTR _secWhitening$[ebp]
  002ba	52		 push	 edx
  002bb	8b 45 f4	 mov	 eax, DWORD PTR _iv64$[ebp]
  002be	50		 push	 eax
  002bf	8d 4d e4	 lea	 ecx, DWORD PTR _sectorIV$[ebp]
  002c2	51		 push	 ecx
  002c3	8b 55 d4	 mov	 edx, DWORD PTR _ea$[ebp]
  002c6	52		 push	 edx
  002c7	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  002cc	50		 push	 eax
  002cd	e8 00 00 00 00	 call	 _CipherGetBlockSize@4
  002d2	50		 push	 eax
  002d3	8b 45 dc	 mov	 eax, DWORD PTR _unitNo$[ebp+4]
  002d6	50		 push	 eax
  002d7	8b 4d d8	 mov	 ecx, DWORD PTR _unitNo$[ebp]
  002da	51		 push	 ecx
  002db	e8 00 00 00 00	 call	 _InitSectorIVAndWhitening@24

; 1697 : 
; 1698 : 			DecryptBufferCBC ((unsigned __int32 *) buf,
; 1699 : 				ENCRYPTION_DATA_UNIT_SIZE,
; 1700 : 				ks,
; 1701 : 				sectorIV,
; 1702 : 				secWhitening,
; 1703 : 				ea,
; 1704 : 				0);

  002e0	6a 00		 push	 0
  002e2	8b 55 d4	 mov	 edx, DWORD PTR _ea$[ebp]
  002e5	52		 push	 edx
  002e6	8d 45 f8	 lea	 eax, DWORD PTR _secWhitening$[ebp]
  002e9	50		 push	 eax
  002ea	8d 4d e4	 lea	 ecx, DWORD PTR _sectorIV$[ebp]
  002ed	51		 push	 ecx
  002ee	8b 55 cc	 mov	 edx, DWORD PTR _ks$[ebp]
  002f1	52		 push	 edx
  002f2	68 00 02 00 00	 push	 512			; 00000200H
  002f7	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  002fa	50		 push	 eax
  002fb	e8 00 00 00 00	 call	 _DecryptBufferCBC@28

; 1705 : 
; 1706 : 			buf += ENCRYPTION_DATA_UNIT_SIZE;

  00300	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00303	81 c1 00 02 00
	00		 add	 ecx, 512		; 00000200H
  00309	89 4d 08	 mov	 DWORD PTR _buf$[ebp], ecx

; 1707 : 			unitNo++;

  0030c	8b 55 d8	 mov	 edx, DWORD PTR _unitNo$[ebp]
  0030f	83 c2 01	 add	 edx, 1
  00312	8b 45 dc	 mov	 eax, DWORD PTR _unitNo$[ebp+4]
  00315	83 d0 00	 adc	 eax, 0
  00318	89 55 d8	 mov	 DWORD PTR _unitNo$[ebp], edx
  0031b	89 45 dc	 mov	 DWORD PTR _unitNo$[ebp+4], eax

; 1708 : 		}

  0031e	e9 6e ff ff ff	 jmp	 $LN3@DecryptDat
$LN2@DecryptDat:

; 1709 : 		break;

  00323	eb 16		 jmp	 SHORT $LN24@DecryptDat
$LN1@DecryptDat:

; 1710 : #endif // #ifndef TC_NO_COMPILER_INT64
; 1711 : 
; 1712 : 	default:		
; 1713 : 		// Unknown/wrong ID
; 1714 : 		TC_THROW_FATAL_EXCEPTION;

  00325	68 43 54 00 00	 push	 21571			; 00005443H
  0032a	6a 00		 push	 0
  0032c	6a 00		 push	 0
  0032e	68 b2 06 00 00	 push	 1714			; 000006b2H
  00333	6a 29		 push	 41			; 00000029H
  00335	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN24@DecryptDat:

; 1715 : 	}
; 1716 : }

  0033b	5e		 pop	 esi
  0033c	8b e5		 mov	 esp, ebp
  0033e	5d		 pop	 ebp
  0033f	c2 14 00	 ret	 20			; 00000014H
  00342	8b ff		 npad	 2
$LN25@DecryptDat:
  00344	00 00 00 00	 DD	 $LN20@DecryptDat
  00348	00 00 00 00	 DD	 $LN16@DecryptDat
  0034c	00 00 00 00	 DD	 $LN9@DecryptDat
  00350	00 00 00 00	 DD	 $LN3@DecryptDat
  00354	00 00 00 00	 DD	 $LN9@DecryptDat
_DecryptDataUnitsCurrentThread@20 ENDP
_TEXT	ENDS
PUBLIC	_GetMaxPkcs5OutSize@0
; Function compile flags: /Odtp
;	COMDAT _GetMaxPkcs5OutSize@0
_TEXT	SEGMENT
tv135 = -24						; size = 4
tv95 = -20						; size = 4
tv87 = -16						; size = 4
tv79 = -12						; size = 4
tv71 = -8						; size = 4
_size$ = -4						; size = 4
_GetMaxPkcs5OutSize@0 PROC				; COMDAT

; 1721 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 18	 sub	 esp, 24			; 00000018H

; 1722 : 	int size = 32;

  00008	c7 45 fc 20 00
	00 00		 mov	 DWORD PTR _size$[ebp], 32 ; 00000020H

; 1723 : 
; 1724 : 	size = max (size, EAGetLargestKeyForMode (XTS) * 2);	// Sizes of primary + secondary keys

  0000f	6a 01		 push	 1
  00011	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode@4
  00016	d1 e0		 shl	 eax, 1
  00018	39 45 fc	 cmp	 DWORD PTR _size$[ebp], eax
  0001b	7e 08		 jle	 SHORT $LN3@GetMaxPkcs
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _size$[ebp]
  00020	89 45 f8	 mov	 DWORD PTR tv71[ebp], eax
  00023	eb 0c		 jmp	 SHORT $LN4@GetMaxPkcs
$LN3@GetMaxPkcs:
  00025	6a 01		 push	 1
  00027	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode@4
  0002c	d1 e0		 shl	 eax, 1
  0002e	89 45 f8	 mov	 DWORD PTR tv71[ebp], eax
$LN4@GetMaxPkcs:
  00031	8b 4d f8	 mov	 ecx, DWORD PTR tv71[ebp]
  00034	89 4d fc	 mov	 DWORD PTR _size$[ebp], ecx

; 1725 : 
; 1726 : #ifndef TC_WINDOWS_BOOT
; 1727 : 	size = max (size, LEGACY_VOL_IV_SIZE + EAGetLargestKeyForMode (LRW));		// Deprecated/legacy

  00037	6a 02		 push	 2
  00039	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode@4
  0003e	83 c0 20	 add	 eax, 32			; 00000020H
  00041	39 45 fc	 cmp	 DWORD PTR _size$[ebp], eax
  00044	7e 08		 jle	 SHORT $LN5@GetMaxPkcs
  00046	8b 55 fc	 mov	 edx, DWORD PTR _size$[ebp]
  00049	89 55 f4	 mov	 DWORD PTR tv79[ebp], edx
  0004c	eb 0d		 jmp	 SHORT $LN6@GetMaxPkcs
$LN5@GetMaxPkcs:
  0004e	6a 02		 push	 2
  00050	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode@4
  00055	83 c0 20	 add	 eax, 32			; 00000020H
  00058	89 45 f4	 mov	 DWORD PTR tv79[ebp], eax
$LN6@GetMaxPkcs:
  0005b	8b 45 f4	 mov	 eax, DWORD PTR tv79[ebp]
  0005e	89 45 fc	 mov	 DWORD PTR _size$[ebp], eax

; 1728 : 	size = max (size, LEGACY_VOL_IV_SIZE + EAGetLargestKeyForMode (CBC));		// Deprecated/legacy

  00061	6a 03		 push	 3
  00063	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode@4
  00068	83 c0 20	 add	 eax, 32			; 00000020H
  0006b	39 45 fc	 cmp	 DWORD PTR _size$[ebp], eax
  0006e	7e 08		 jle	 SHORT $LN7@GetMaxPkcs
  00070	8b 4d fc	 mov	 ecx, DWORD PTR _size$[ebp]
  00073	89 4d f0	 mov	 DWORD PTR tv87[ebp], ecx
  00076	eb 0d		 jmp	 SHORT $LN8@GetMaxPkcs
$LN7@GetMaxPkcs:
  00078	6a 03		 push	 3
  0007a	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode@4
  0007f	83 c0 20	 add	 eax, 32			; 00000020H
  00082	89 45 f0	 mov	 DWORD PTR tv87[ebp], eax
$LN8@GetMaxPkcs:
  00085	8b 55 f0	 mov	 edx, DWORD PTR tv87[ebp]
  00088	89 55 fc	 mov	 DWORD PTR _size$[ebp], edx

; 1729 : 	size = max (size, LEGACY_VOL_IV_SIZE + EAGetLargestKeyForMode (OUTER_CBC));	// Deprecated/legacy

  0008b	6a 04		 push	 4
  0008d	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode@4
  00092	83 c0 20	 add	 eax, 32			; 00000020H
  00095	39 45 fc	 cmp	 DWORD PTR _size$[ebp], eax
  00098	7e 08		 jle	 SHORT $LN9@GetMaxPkcs
  0009a	8b 45 fc	 mov	 eax, DWORD PTR _size$[ebp]
  0009d	89 45 ec	 mov	 DWORD PTR tv95[ebp], eax
  000a0	eb 0d		 jmp	 SHORT $LN10@GetMaxPkcs
$LN9@GetMaxPkcs:
  000a2	6a 04		 push	 4
  000a4	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode@4
  000a9	83 c0 20	 add	 eax, 32			; 00000020H
  000ac	89 45 ec	 mov	 DWORD PTR tv95[ebp], eax
$LN10@GetMaxPkcs:
  000af	8b 4d ec	 mov	 ecx, DWORD PTR tv95[ebp]
  000b2	89 4d fc	 mov	 DWORD PTR _size$[ebp], ecx

; 1730 : 	size = max (size, LEGACY_VOL_IV_SIZE + EAGetLargestKeyForMode (INNER_CBC));	// Deprecated/legacy

  000b5	6a 05		 push	 5
  000b7	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode@4
  000bc	83 c0 20	 add	 eax, 32			; 00000020H
  000bf	39 45 fc	 cmp	 DWORD PTR _size$[ebp], eax
  000c2	7e 08		 jle	 SHORT $LN11@GetMaxPkcs
  000c4	8b 55 fc	 mov	 edx, DWORD PTR _size$[ebp]
  000c7	89 55 e8	 mov	 DWORD PTR tv135[ebp], edx
  000ca	eb 0d		 jmp	 SHORT $LN12@GetMaxPkcs
$LN11@GetMaxPkcs:
  000cc	6a 05		 push	 5
  000ce	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode@4
  000d3	83 c0 20	 add	 eax, 32			; 00000020H
  000d6	89 45 e8	 mov	 DWORD PTR tv135[ebp], eax
$LN12@GetMaxPkcs:
  000d9	8b 45 e8	 mov	 eax, DWORD PTR tv135[ebp]
  000dc	89 45 fc	 mov	 DWORD PTR _size$[ebp], eax

; 1731 : #endif
; 1732 : 
; 1733 : 	return size;

  000df	8b 45 fc	 mov	 eax, DWORD PTR _size$[ebp]

; 1734 : }

  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c3		 ret	 0
_GetMaxPkcs5OutSize@0 ENDP
_TEXT	ENDS
EXTRN	_is_aes_hw_cpu_supported@0:PROC
; Function compile flags: /Odtp
;	COMDAT _IsAesHwCpuSupported@0
_TEXT	SEGMENT
tv71 = -4						; size = 4
_IsAesHwCpuSupported@0 PROC				; COMDAT

; 1843 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 1844 : 	static BOOL state = FALSE;
; 1845 : 	static BOOL stateValid = FALSE;
; 1846 : 
; 1847 : 	if (!stateValid)

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?stateValid@?1??IsAesHwCpuSupported@@9@9, 0
  0000d	75 1d		 jne	 SHORT $LN1@IsAesHwCpu

; 1848 : 	{
; 1849 : 		state = is_aes_hw_cpu_supported() ? TRUE : FALSE;

  0000f	e8 00 00 00 00	 call	 _is_aes_hw_cpu_supported@0
  00014	0f b6 c0	 movzx	 eax, al
  00017	f7 d8		 neg	 eax
  00019	1b c0		 sbb	 eax, eax
  0001b	f7 d8		 neg	 eax
  0001d	a3 00 00 00 00	 mov	 DWORD PTR ?state@?1??IsAesHwCpuSupported@@9@9, eax

; 1850 : 		stateValid = TRUE;

  00022	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?stateValid@?1??IsAesHwCpuSupported@@9@9, 1
$LN1@IsAesHwCpu:

; 1851 : 	}
; 1852 : 
; 1853 : 	return state && !HwEncryptionDisabled;

  0002c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?state@?1??IsAesHwCpuSupported@@9@9, 0
  00033	74 12		 je	 SHORT $LN4@IsAesHwCpu
  00035	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _HwEncryptionDisabled, 0
  0003c	75 09		 jne	 SHORT $LN4@IsAesHwCpu
  0003e	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
  00045	eb 07		 jmp	 SHORT $LN5@IsAesHwCpu
$LN4@IsAesHwCpu:
  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN5@IsAesHwCpu:
  0004e	8b 45 fc	 mov	 eax, DWORD PTR tv71[ebp]

; 1854 : }

  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
_IsAesHwCpuSupported@0 ENDP
_TEXT	ENDS
PUBLIC	_EnableHwEncryption@4
; Function compile flags: /Odtp
;	COMDAT _EnableHwEncryption@4
_TEXT	SEGMENT
_enable$ = 8						; size = 4
_EnableHwEncryption@4 PROC				; COMDAT

; 1857 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1858 : #if defined (TC_WINDOWS_BOOT)
; 1859 : 	if (enable)
; 1860 : 		aes_hw_cpu_enable_sse();
; 1861 : #endif
; 1862 : 
; 1863 : 	HwEncryptionDisabled = !enable;

  00005	33 c0		 xor	 eax, eax
  00007	83 7d 08 00	 cmp	 DWORD PTR _enable$[ebp], 0
  0000b	0f 94 c0	 sete	 al
  0000e	a3 00 00 00 00	 mov	 DWORD PTR _HwEncryptionDisabled, eax

; 1864 : }

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
_EnableHwEncryption@4 ENDP
_TEXT	ENDS
PUBLIC	_IsHwEncryptionEnabled@0
; Function compile flags: /Odtp
;	COMDAT _IsHwEncryptionEnabled@0
_TEXT	SEGMENT
_IsHwEncryptionEnabled@0 PROC				; COMDAT

; 1867 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1868 : 	return !HwEncryptionDisabled;

  00005	33 c0		 xor	 eax, eax
  00007	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _HwEncryptionDisabled, 0
  0000e	0f 94 c0	 sete	 al

; 1869 : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
_IsHwEncryptionEnabled@0 ENDP
_TEXT	ENDS
END
