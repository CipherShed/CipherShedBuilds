; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\Public\Desktop\projects\ciphershed\src\Common\dialog\userperms.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0P@GHFPNOJB@bad?5allocation?$AA@		; `string'
PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
PUBLIC	_UacElevated
_BSS	SEGMENT
_UacElevated DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
_DATA	ENDS
;	COMDAT ??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
CONST	SEGMENT
??_C@_0P@GHFPNOJB@bad?5allocation?$AA@ DB 'bad allocation', 00H ; `string'
CONST	ENDS
PUBLIC	_IsOSVersionAtLeast
EXTRN	_CurrentOSServicePack:DWORD
EXTRN	_CurrentOSMinor:DWORD
EXTRN	_CurrentOSMajor:DWORD
; Function compile flags: /Ogtpy
; File c:\users\public\desktop\projects\ciphershed\src\common\dialog\userperms.cpp
;	COMDAT _IsOSVersionAtLeast
_TEXT	SEGMENT
_reqMinOS$ = 8						; size = 4
_reqMinServicePack$ = 12				; size = 4
_IsOSVersionAtLeast PROC				; COMDAT

; 72   : 	/* When updating this function, update IsOSAtLeast() in Ntdriver.c too. */
; 73   : 
; 74   : 	int major = 0, minor = 0;
; 75   : 
; 76   : 	if (CurrentOSMajor <= 0)

  00000	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _CurrentOSMajor
  00006	33 c0		 xor	 eax, eax
  00008	33 c9		 xor	 ecx, ecx
  0000a	85 d2		 test	 edx, edx
  0000c	7f 0b		 jg	 SHORT $LN11@IsOSVersio

; 77   : 		TC_THROW_FATAL_EXCEPTION;

  0000e	a2 00 00 00 00	 mov	 BYTE PTR ds:0, al
  00013	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _CurrentOSMajor
$LN11@IsOSVersio:
  00019	56		 push	 esi

; 78   : 
; 79   : 	switch (reqMinOS)

  0001a	8b 74 24 08	 mov	 esi, DWORD PTR _reqMinOS$[esp]
  0001e	83 c6 f9	 add	 esi, -7			; fffffff9H
  00021	83 fe 0c	 cmp	 esi, 12			; 0000000cH
  00024	77 4b		 ja	 SHORT $LN1@IsOSVersio
  00026	ff 24 b5 00 00
	00 00		 jmp	 DWORD PTR $LN14@IsOSVersio[esi*4]
$LN8@IsOSVersio:

; 80   : 	{
; 81   : 	case WIN_2000:			major = 5; minor = 0; break;

  0002d	b8 05 00 00 00	 mov	 eax, 5
  00032	33 c9		 xor	 ecx, ecx
  00034	eb 46		 jmp	 SHORT $LN9@IsOSVersio
$LN7@IsOSVersio:

; 82   : 	case WIN_XP:			major = 5; minor = 1; break;

  00036	b8 05 00 00 00	 mov	 eax, 5
  0003b	8d 48 fc	 lea	 ecx, DWORD PTR [eax-4]
  0003e	eb 3c		 jmp	 SHORT $LN9@IsOSVersio
$LN6@IsOSVersio:

; 83   : 	case WIN_SERVER_2003:	major = 5; minor = 2; break;

  00040	b8 05 00 00 00	 mov	 eax, 5
  00045	8d 48 fd	 lea	 ecx, DWORD PTR [eax-3]
  00048	eb 32		 jmp	 SHORT $LN9@IsOSVersio
$LN5@IsOSVersio:

; 84   : 	case WIN_VISTA:			major = 6; minor = 0; break;

  0004a	b8 06 00 00 00	 mov	 eax, 6
  0004f	33 c9		 xor	 ecx, ecx
  00051	eb 29		 jmp	 SHORT $LN9@IsOSVersio
$LN4@IsOSVersio:

; 85   : 	case WIN_7:				major = 6; minor = 1; break;

  00053	b8 06 00 00 00	 mov	 eax, 6
  00058	8d 48 fb	 lea	 ecx, DWORD PTR [eax-5]
  0005b	eb 1f		 jmp	 SHORT $LN9@IsOSVersio
$LN3@IsOSVersio:

; 86   : 	case WIN_8:				major = 6; minor = 2; break;

  0005d	b8 06 00 00 00	 mov	 eax, 6
  00062	8d 48 fc	 lea	 ecx, DWORD PTR [eax-4]
  00065	eb 15		 jmp	 SHORT $LN9@IsOSVersio
$LN2@IsOSVersio:

; 87   : 	case WIN_10:			major = 6; minor = 4; break;

  00067	b8 06 00 00 00	 mov	 eax, 6
  0006c	8d 48 fe	 lea	 ecx, DWORD PTR [eax-2]
  0006f	eb 0b		 jmp	 SHORT $LN9@IsOSVersio
$LN1@IsOSVersio:

; 88   : 
; 89   : 	default:
; 90   : 		TC_THROW_FATAL_EXCEPTION;

  00071	a2 00 00 00 00	 mov	 BYTE PTR ds:0, al
  00076	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _CurrentOSMajor
$LN9@IsOSVersio:

; 91   : 		break;
; 92   : 	}
; 93   : 
; 94   : 	return ((CurrentOSMajor << 16 | CurrentOSMinor << 8 | CurrentOSServicePack)
; 95   : 		>= (major << 16 | minor << 8 | reqMinServicePack));

  0007c	c1 e2 08	 shl	 edx, 8
  0007f	0b 15 00 00 00
	00		 or	 edx, DWORD PTR _CurrentOSMinor
  00085	c1 e0 08	 shl	 eax, 8
  00088	0b c1		 or	 eax, ecx
  0008a	c1 e0 08	 shl	 eax, 8
  0008d	0b 44 24 0c	 or	 eax, DWORD PTR _reqMinServicePack$[esp]
  00091	c1 e2 08	 shl	 edx, 8
  00094	0b 15 00 00 00
	00		 or	 edx, DWORD PTR _CurrentOSServicePack
  0009a	33 c9		 xor	 ecx, ecx
  0009c	3b d0		 cmp	 edx, eax
  0009e	0f 9d c1	 setge	 cl
  000a1	5e		 pop	 esi
  000a2	8b c1		 mov	 eax, ecx

; 96   : }

  000a4	c3		 ret	 0
  000a5	8d 49 00	 npad	 3
$LN14@IsOSVersio:
  000a8	00 00 00 00	 DD	 $LN8@IsOSVersio
  000ac	00 00 00 00	 DD	 $LN7@IsOSVersio
  000b0	00 00 00 00	 DD	 $LN1@IsOSVersio
  000b4	00 00 00 00	 DD	 $LN6@IsOSVersio
  000b8	00 00 00 00	 DD	 $LN5@IsOSVersio
  000bc	00 00 00 00	 DD	 $LN1@IsOSVersio
  000c0	00 00 00 00	 DD	 $LN4@IsOSVersio
  000c4	00 00 00 00	 DD	 $LN1@IsOSVersio
  000c8	00 00 00 00	 DD	 $LN3@IsOSVersio
  000cc	00 00 00 00	 DD	 $LN1@IsOSVersio
  000d0	00 00 00 00	 DD	 $LN1@IsOSVersio
  000d4	00 00 00 00	 DD	 $LN1@IsOSVersio
  000d8	00 00 00 00	 DD	 $LN2@IsOSVersio
_IsOSVersionAtLeast ENDP
_TEXT	ENDS
PUBLIC	??_C@_08PNLNEKOB@kernel32?$AA@			; `string'
PUBLIC	??_C@_0P@LKABJJMO@IsWow64Process?$AA@		; `string'
PUBLIC	_Is64BitOs
EXTRN	__imp__GetCurrentProcess@0:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__GetModuleHandleA@4:PROC
;	COMDAT ?isWow64@?1??Is64BitOs@@9@4HA
_BSS	SEGMENT
?isWow64@?1??Is64BitOs@@9@4HA DD 01H DUP (?)		; `Is64BitOs'::`2'::isWow64
_BSS	ENDS
;	COMDAT ?valid@?1??Is64BitOs@@9@4HA
_BSS	SEGMENT
?valid@?1??Is64BitOs@@9@4HA DD 01H DUP (?)		; `Is64BitOs'::`2'::valid
_BSS	ENDS
;	COMDAT ??_C@_08PNLNEKOB@kernel32?$AA@
CONST	SEGMENT
??_C@_08PNLNEKOB@kernel32?$AA@ DB 'kernel32', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LKABJJMO@IsWow64Process?$AA@
CONST	SEGMENT
??_C@_0P@LKABJJMO@IsWow64Process?$AA@ DB 'IsWow64Process', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Is64BitOs
_TEXT	SEGMENT
_Is64BitOs PROC						; COMDAT

; 104  :     static BOOL isWow64 = FALSE;
; 105  : 	static BOOL valid = FALSE;
; 106  : 	LPFN_ISWOW64PROCESS fnIsWow64Process;
; 107  : 
; 108  : 	if (valid)

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?valid@?1??Is64BitOs@@9@4HA, 0

; 109  : 		return isWow64;

  00007	75 40		 jne	 SHORT $LN7@Is64BitOs
  00009	56		 push	 esi

; 110  : 
; 111  : 	fnIsWow64Process = (LPFN_ISWOW64PROCESS) GetProcAddress (GetModuleHandleA("kernel32"), "IsWow64Process");

  0000a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@LKABJJMO@IsWow64Process?$AA@
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_08PNLNEKOB@kernel32?$AA@
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  0001a	50		 push	 eax
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00021	8b f0		 mov	 esi, eax

; 112  : 
; 113  :     if (fnIsWow64Process != NULL)

  00023	85 f6		 test	 esi, esi
  00025	74 17		 je	 SHORT $LN6@Is64BitOs

; 114  :         if (!fnIsWow64Process (GetCurrentProcess(), &isWow64))

  00027	68 00 00 00 00	 push	 OFFSET ?isWow64@?1??Is64BitOs@@9@4HA
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcess@0
  00032	50		 push	 eax
  00033	ff d6		 call	 esi
  00035	85 c0		 test	 eax, eax
  00037	75 05		 jne	 SHORT $LN6@Is64BitOs

; 115  : 			isWow64 = FALSE;

  00039	a3 00 00 00 00	 mov	 DWORD PTR ?isWow64@?1??Is64BitOs@@9@4HA, eax
$LN6@Is64BitOs:

; 116  : 
; 117  : 	valid = TRUE;

  0003e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?valid@?1??Is64BitOs@@9@4HA, 1
  00048	5e		 pop	 esi
$LN7@Is64BitOs:

; 118  :     return isWow64;

  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR ?isWow64@?1??Is64BitOs@@9@4HA

; 119  : }

  0004e	c3		 ret	 0
_Is64BitOs ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_IsServerOS
EXTRN	__imp__GetVersionExA@4:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT _IsServerOS
_TEXT	SEGMENT
_osVer$ = -160						; size = 156
__$ArrayPad$ = -4					; size = 4
_IsServerOS PROC					; COMDAT

; 123  : {

  00000	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 9c 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+160], eax

; 124  : 	OSVERSIONINFOEXA osVer;
; 125  : 	osVer.dwOSVersionInfoSize = sizeof (OSVERSIONINFOEXA);
; 126  : 	GetVersionExA ((LPOSVERSIONINFOA) &osVer);

  00014	8d 04 24	 lea	 eax, DWORD PTR _osVer$[esp+160]
  00017	50		 push	 eax
  00018	c7 44 24 04 9c
	00 00 00	 mov	 DWORD PTR _osVer$[esp+164], 156 ; 0000009cH
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersionExA@4

; 127  : 
; 128  : 	return (osVer.wProductType == VER_NT_SERVER || osVer.wProductType == VER_NT_DOMAIN_CONTROLLER);

  00026	8a 84 24 9a 00
	00 00		 mov	 al, BYTE PTR _osVer$[esp+314]
  0002d	3c 03		 cmp	 al, 3
  0002f	74 1b		 je	 SHORT $LN3@IsServerOS
  00031	3c 02		 cmp	 al, 2
  00033	74 17		 je	 SHORT $LN3@IsServerOS
  00035	33 c0		 xor	 eax, eax

; 129  : }

  00037	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+160]
  0003e	33 cc		 xor	 ecx, esp
  00040	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00045	81 c4 a0 00 00
	00		 add	 esp, 160		; 000000a0H
  0004b	c3		 ret	 0
$LN3@IsServerOS:
  0004c	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+160]
  00053	33 cc		 xor	 ecx, esp
  00055	b8 01 00 00 00	 mov	 eax, 1
  0005a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005f	81 c4 a0 00 00
	00		 add	 esp, 160		; 000000a0H
  00065	c3		 ret	 0
_IsServerOS ENDP
_TEXT	ENDS
EXTRN	__imp__DefWindowProcA@16:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?EnableElevatedCursorChangeWndProc@@YGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_hWnd$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?EnableElevatedCursorChangeWndProc@@YGJPAUHWND__@@IIJ@Z PROC ; EnableElevatedCursorChangeWndProc, COMDAT

; 133  : 	return DefWindowProc (hWnd, message, wParam, lParam);

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp__DefWindowProcA@16
?EnableElevatedCursorChangeWndProc@@YGJPAUHWND__@@IIJ@Z ENDP ; EnableElevatedCursorChangeWndProc
_TEXT	ENDS
PUBLIC	??_C@_0P@DJAFHMO@CipherShed?5UAC?$AA@		; `string'
PUBLIC	??_C@_0CF@DPFBLAAK@CipherShedEnableElevatedCursorCh@ ; `string'
PUBLIC	_EnableElevatedCursorChange
EXTRN	__imp__UnregisterClassA@8:PROC
EXTRN	__imp__DestroyWindow@4:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__SetLayeredWindowAttributes@16:PROC
EXTRN	__imp__CreateWindowExA@48:PROC
EXTRN	__imp__GetSystemMetrics@4:PROC
EXTRN	__imp__RegisterClassExA@4:PROC
EXTRN	_hInst:DWORD
EXTRN	_memset:PROC
;	COMDAT ??_C@_0P@DJAFHMO@CipherShed?5UAC?$AA@
CONST	SEGMENT
??_C@_0P@DJAFHMO@CipherShed?5UAC?$AA@ DB 'CipherShed UAC', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DPFBLAAK@CipherShedEnableElevatedCursorCh@
CONST	SEGMENT
??_C@_0CF@DPFBLAAK@CipherShedEnableElevatedCursorCh@ DB 'CipherShedEnable'
	DB	'ElevatedCursorChange', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _EnableElevatedCursorChange
_TEXT	SEGMENT
_winClass$135261 = -48					; size = 48
_parent$ = 8						; size = 4
_EnableElevatedCursorChange PROC			; COMDAT

; 137  : {

  00000	83 ec 30	 sub	 esp, 48			; 00000030H

; 138  : 	// Create a transparent window to work around a UAC issue preventing change of the cursor
; 139  : 	if (UacElevated)

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _UacElevated, 0
  0000a	0f 84 ab 00 00
	00		 je	 $LN1@EnableElev
  00010	56		 push	 esi

; 140  : 	{
; 141  : 		const char *className = "CipherShedEnableElevatedCursorChange";
; 142  : 		WNDCLASSEXA winClass;
; 143  : 		HWND hWnd;
; 144  : 
; 145  : 		memset (&winClass, 0, sizeof (winClass));

  00011	6a 30		 push	 48			; 00000030H
  00013	8d 44 24 08	 lea	 eax, DWORD PTR _winClass$135261[esp+56]
  00017	6a 00		 push	 0
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _memset

; 146  : 		winClass.cbSize = sizeof (WNDCLASSEX); 
; 147  : 		winClass.lpfnWndProc = (WNDPROC) EnableElevatedCursorChangeWndProc;
; 148  : 		winClass.hInstance = hInst;

  0001f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hInst
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH

; 149  : 		winClass.lpszClassName = className;
; 150  : 		RegisterClassExA(&winClass);

  00028	8d 54 24 04	 lea	 edx, DWORD PTR _winClass$135261[esp+52]
  0002c	52		 push	 edx
  0002d	c7 44 24 08 30
	00 00 00	 mov	 DWORD PTR _winClass$135261[esp+56], 48 ; 00000030H
  00035	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _winClass$135261[esp+64], OFFSET ?EnableElevatedCursorChangeWndProc@@YGJPAUHWND__@@IIJ@Z ; EnableElevatedCursorChangeWndProc
  0003d	89 4c 24 1c	 mov	 DWORD PTR _winClass$135261[esp+76], ecx
  00041	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR _winClass$135261[esp+96], OFFSET ??_C@_0CF@DPFBLAAK@CipherShedEnableElevatedCursorCh@
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterClassExA@4

; 151  : 
; 152  : 		hWnd = CreateWindowExA(WS_EX_TOOLWINDOW | WS_EX_LAYERED, className, "CipherShed UAC", 0, 0, 0, GetSystemMetrics (SM_CXSCREEN), GetSystemMetrics (SM_CYSCREEN), parent, NULL, hInst, NULL);

  0004f	a1 00 00 00 00	 mov	 eax, DWORD PTR _hInst
  00054	8b 4c 24 38	 mov	 ecx, DWORD PTR _parent$[esp+48]
  00058	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetSystemMetrics@4
  0005e	6a 00		 push	 0
  00060	50		 push	 eax
  00061	6a 00		 push	 0
  00063	51		 push	 ecx
  00064	6a 01		 push	 1
  00066	ff d6		 call	 esi
  00068	50		 push	 eax
  00069	6a 00		 push	 0
  0006b	ff d6		 call	 esi
  0006d	50		 push	 eax
  0006e	6a 00		 push	 0
  00070	6a 00		 push	 0
  00072	6a 00		 push	 0
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_0P@DJAFHMO@CipherShed?5UAC?$AA@
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@DPFBLAAK@CipherShedEnableElevatedCursorCh@
  0007e	68 80 00 08 00	 push	 524416			; 00080080H
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateWindowExA@48

; 153  : 		SetLayeredWindowAttributes (hWnd, 0, 1, LWA_ALPHA);

  00089	6a 02		 push	 2
  0008b	6a 01		 push	 1
  0008d	8b f0		 mov	 esi, eax
  0008f	6a 00		 push	 0
  00091	56		 push	 esi
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLayeredWindowAttributes@16

; 154  : 		ShowWindow (hWnd, SW_SHOWNORMAL);

  00098	6a 01		 push	 1
  0009a	56		 push	 esi
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8

; 155  : 
; 156  : 		DestroyWindow (hWnd);

  000a1	56		 push	 esi
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4

; 157  : 		UnregisterClassA(className, hInst);

  000a8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hInst
  000ae	52		 push	 edx
  000af	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@DPFBLAAK@CipherShedEnableElevatedCursorCh@
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnregisterClassA@8
  000ba	5e		 pop	 esi
$LN1@EnableElev:

; 158  : 	}
; 159  : }

  000bb	83 c4 30	 add	 esp, 48			; 00000030H
  000be	c3		 ret	 0
_EnableElevatedCursorChange ENDP
_TEXT	ENDS
PUBLIC	_IsAdmin
EXTRN	__imp__IsUserAnAdmin@0:PROC
; Function compile flags: /Ogtpy
;	COMDAT _IsAdmin
_TEXT	SEGMENT
_IsAdmin PROC						; COMDAT

; 163  : 	return IsUserAnAdmin ();

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp__IsUserAnAdmin@0
_IsAdmin ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0Finally175@?3??IsBuiltInAdmin@@9@QAE@PAX@Z
_TEXT	SEGMENT
??0Finally175@?3??IsBuiltInAdmin@@9@QAE@PAX@Z PROC	; `IsBuiltInAdmin'::`4'::Finally175::Finally175, COMDAT
; _this$ = eax
; _a$ = ecx

; 175  : 	finally_do_arg (HANDLE, procToken, { CloseHandle (finally_arg); });

  00000	89 08		 mov	 DWORD PTR [eax], ecx
  00002	c3		 ret	 0
??0Finally175@?3??IsBuiltInAdmin@@9@QAE@PAX@Z ENDP	; `IsBuiltInAdmin'::`4'::Finally175::Finally175
_TEXT	ENDS
EXTRN	__imp__CloseHandle@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1Finally175@?3??IsBuiltInAdmin@@9@QAE@XZ
_TEXT	SEGMENT
??1Finally175@?3??IsBuiltInAdmin@@9@QAE@XZ PROC		; `IsBuiltInAdmin'::`4'::Finally175::~Finally175, COMDAT
; _this$ = eax

; 175  : 	finally_do_arg (HANDLE, procToken, { CloseHandle (finally_arg); });

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	51		 push	 ecx
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  00009	c3		 ret	 0
??1Finally175@?3??IsBuiltInAdmin@@9@QAE@XZ ENDP		; `IsBuiltInAdmin'::`4'::Finally175::~Finally175
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0Finally184@?8??IsBuiltInAdmin@@9@QAE@PAX@Z
_TEXT	SEGMENT
??0Finally184@?8??IsBuiltInAdmin@@9@QAE@PAX@Z PROC	; `IsBuiltInAdmin'::`9'::Finally184::Finally184, COMDAT
; _this$ = eax
; _a$ = ecx

; 184  : 	finally_do_arg (void *, tokenUser, { free (finally_arg); });

  00000	89 08		 mov	 DWORD PTR [eax], ecx
  00002	c3		 ret	 0
??0Finally184@?8??IsBuiltInAdmin@@9@QAE@PAX@Z ENDP	; `IsBuiltInAdmin'::`9'::Finally184::Finally184
_TEXT	ENDS
EXTRN	_free:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1Finally184@?8??IsBuiltInAdmin@@9@QAE@XZ
_TEXT	SEGMENT
??1Finally184@?8??IsBuiltInAdmin@@9@QAE@XZ PROC		; `IsBuiltInAdmin'::`9'::Finally184::~Finally184, COMDAT
; _this$ = eax

; 184  : 	finally_do_arg (void *, tokenUser, { free (finally_arg); });

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	51		 push	 ecx
  00003	e8 00 00 00 00	 call	 _free
  00008	59		 pop	 ecx
  00009	c3		 ret	 0
??1Finally184@?8??IsBuiltInAdmin@@9@QAE@XZ ENDP		; `IsBuiltInAdmin'::`9'::Finally184::~Finally184
_TEXT	ENDS
PUBLIC	_IsOSAtLeast
; Function compile flags: /Ogtpy
;	COMDAT _IsOSAtLeast
_TEXT	SEGMENT
_reqMinOS$ = 8						; size = 4
_IsOSAtLeast PROC					; COMDAT

; 63   : 	return IsOSVersionAtLeast (reqMinOS, 0);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _reqMinOS$[esp-4]
  00004	6a 00		 push	 0
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _IsOSVersionAtLeast
  0000c	83 c4 08	 add	 esp, 8

; 64   : }

  0000f	c3		 ret	 0
_IsOSAtLeast ENDP
_TEXT	ENDS
PUBLIC	_IsBuiltInAdmin
EXTRN	__imp__IsWellKnownSid@8:PROC
EXTRN	_malloc:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__GetTokenInformation@20:PROC
EXTRN	__imp__OpenProcessToken@12:PROC
; Function compile flags: /Ogtpy
;	COMDAT _IsBuiltInAdmin
_TEXT	SEGMENT
_finally175$ = -16					; size = 4
_size$ = -12						; size = 4
_procToken$ = -8					; size = 4
_finally184$ = -4					; size = 4
_IsBuiltInAdmin PROC					; COMDAT

; 168  : {

  00000	83 ec 10	 sub	 esp, 16			; 00000010H

; 169  : 	HANDLE procToken;
; 170  : 	DWORD size;
; 171  : 
; 172  : 	if (!IsAdmin() || !OpenProcessToken (GetCurrentProcess(), TOKEN_QUERY, &procToken))

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsUserAnAdmin@0
  00009	85 c0		 test	 eax, eax
  0000b	0f 84 c9 00 00
	00		 je	 $LN5@IsBuiltInA
  00011	8d 44 24 08	 lea	 eax, DWORD PTR _procToken$[esp+16]
  00015	50		 push	 eax
  00016	6a 08		 push	 8
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcess@0
  0001e	50		 push	 eax
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenProcessToken@12
  00025	85 c0		 test	 eax, eax
  00027	0f 84 ad 00 00
	00		 je	 $LN5@IsBuiltInA

; 174  : 
; 175  : 	finally_do_arg (HANDLE, procToken, { CloseHandle (finally_arg); });

  0002d	8b 44 24 08	 mov	 eax, DWORD PTR _procToken$[esp+16]
  00031	57		 push	 edi

; 176  : 
; 177  : 	if (GetTokenInformation (procToken, TokenUser, NULL, 0, &size) || GetLastError() != ERROR_INSUFFICIENT_BUFFER)

  00032	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetTokenInformation@20
  00038	8d 4c 24 08	 lea	 ecx, DWORD PTR _size$[esp+20]
  0003c	51		 push	 ecx
  0003d	6a 00		 push	 0
  0003f	6a 00		 push	 0
  00041	6a 01		 push	 1
  00043	50		 push	 eax
  00044	89 44 24 18	 mov	 DWORD PTR _finally175$[esp+40], eax
  00048	ff d7		 call	 edi
  0004a	85 c0		 test	 eax, eax
  0004c	75 7c		 jne	 SHORT $LN3@IsBuiltInA
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00054	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  00057	75 71		 jne	 SHORT $LN3@IsBuiltInA

; 179  : 
; 180  : 	TOKEN_USER *tokenUser = (TOKEN_USER *) malloc (size);

  00059	8b 54 24 08	 mov	 edx, DWORD PTR _size$[esp+20]
  0005d	56		 push	 esi
  0005e	52		 push	 edx
  0005f	e8 00 00 00 00	 call	 _malloc
  00064	8b f0		 mov	 esi, eax
  00066	83 c4 04	 add	 esp, 4

; 181  : 	if (!tokenUser)

  00069	85 f6		 test	 esi, esi

; 182  : 		return FALSE;

  0006b	74 25		 je	 SHORT $LN17@IsBuiltInA

; 183  : 
; 184  : 	finally_do_arg (void *, tokenUser, { free (finally_arg); });
; 185  : 
; 186  : 	if (!GetTokenInformation (procToken, TokenUser, tokenUser, size, &size))

  0006d	8b 4c 24 0c	 mov	 ecx, DWORD PTR _size$[esp+24]
  00071	8b 54 24 10	 mov	 edx, DWORD PTR _procToken$[esp+24]
  00075	8d 44 24 0c	 lea	 eax, DWORD PTR _size$[esp+24]
  00079	50		 push	 eax
  0007a	51		 push	 ecx
  0007b	56		 push	 esi
  0007c	6a 01		 push	 1
  0007e	52		 push	 edx
  0007f	89 74 24 28	 mov	 DWORD PTR _finally184$[esp+44], esi
  00083	ff d7		 call	 edi
  00085	85 c0		 test	 eax, eax
  00087	75 1a		 jne	 SHORT $LN1@IsBuiltInA

; 187  : 		return FALSE;

  00089	8d 44 24 14	 lea	 eax, DWORD PTR _finally184$[esp+24]
  0008d	e8 00 00 00 00	 call	 ??1Finally184@?8??IsBuiltInAdmin@@9@QAE@XZ ; `IsBuiltInAdmin'::`9'::Finally184::~Finally184
$LN17@IsBuiltInA:
  00092	8d 44 24 08	 lea	 eax, DWORD PTR _finally175$[esp+24]
  00096	e8 00 00 00 00	 call	 ??1Finally175@?3??IsBuiltInAdmin@@9@QAE@XZ ; `IsBuiltInAdmin'::`4'::Finally175::~Finally175
  0009b	5e		 pop	 esi
  0009c	33 c0		 xor	 eax, eax
  0009e	5f		 pop	 edi

; 190  : }

  0009f	83 c4 10	 add	 esp, 16			; 00000010H
  000a2	c3		 ret	 0
$LN1@IsBuiltInA:

; 188  : 
; 189  : 	return IsWellKnownSid (tokenUser->User.Sid, WinAccountAdministratorSid);

  000a3	8b 06		 mov	 eax, DWORD PTR [esi]
  000a5	6a 26		 push	 38			; 00000026H
  000a7	50		 push	 eax
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsWellKnownSid@8
  000ae	8b f0		 mov	 esi, eax
  000b0	8d 44 24 14	 lea	 eax, DWORD PTR _finally184$[esp+24]
  000b4	e8 00 00 00 00	 call	 ??1Finally184@?8??IsBuiltInAdmin@@9@QAE@XZ ; `IsBuiltInAdmin'::`9'::Finally184::~Finally184
  000b9	8d 44 24 08	 lea	 eax, DWORD PTR _finally175$[esp+24]
  000bd	e8 00 00 00 00	 call	 ??1Finally175@?3??IsBuiltInAdmin@@9@QAE@XZ ; `IsBuiltInAdmin'::`4'::Finally175::~Finally175
  000c2	8b c6		 mov	 eax, esi
  000c4	5e		 pop	 esi
  000c5	5f		 pop	 edi

; 190  : }

  000c6	83 c4 10	 add	 esp, 16			; 00000010H
  000c9	c3		 ret	 0
$LN3@IsBuiltInA:

; 178  : 		return FALSE;

  000ca	8d 44 24 04	 lea	 eax, DWORD PTR _finally175$[esp+20]
  000ce	e8 00 00 00 00	 call	 ??1Finally175@?3??IsBuiltInAdmin@@9@QAE@XZ ; `IsBuiltInAdmin'::`4'::Finally175::~Finally175
  000d3	33 c0		 xor	 eax, eax
  000d5	5f		 pop	 edi

; 190  : }

  000d6	83 c4 10	 add	 esp, 16			; 00000010H
  000d9	c3		 ret	 0
$LN5@IsBuiltInA:

; 173  : 		return FALSE;

  000da	33 c0		 xor	 eax, eax

; 190  : }

  000dc	83 c4 10	 add	 esp, 16			; 00000010H
  000df	c3		 ret	 0
_IsBuiltInAdmin ENDP
_TEXT	ENDS
PUBLIC	??_C@_09IMBMLODE@EnableLUA?$AA@			; `string'
PUBLIC	??_C@_0DK@IFNHFOHB@Software?2Microsoft?2Windows?2Curre@ ; `string'
PUBLIC	_IsUacSupported
EXTRN	__imp__RegCloseKey@4:PROC
EXTRN	__imp__RegQueryValueExA@24:PROC
EXTRN	__imp__RegOpenKeyExA@20:PROC
;	COMDAT ??_C@_09IMBMLODE@EnableLUA?$AA@
CONST	SEGMENT
??_C@_09IMBMLODE@EnableLUA?$AA@ DB 'EnableLUA', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@IFNHFOHB@Software?2Microsoft?2Windows?2Curre@
CONST	SEGMENT
??_C@_0DK@IFNHFOHB@Software?2Microsoft?2Windows?2Curre@ DB 'Software\Micr'
	DB	'osoft\Windows\CurrentVersion\Policies\System', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _IsUacSupported
_TEXT	SEGMENT
_value$ = -12						; size = 4
_hkey$ = -8						; size = 4
_size$ = -4						; size = 4
_IsUacSupported PROC					; COMDAT

; 43   : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 44   : 	HKEY hkey;
; 45   : 	DWORD value = 1, size = sizeof (DWORD);
; 46   : 
; 47   : 	if (!IsOSAtLeast (WIN_VISTA))

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentOSMajor
  00008	c7 04 24 01 00
	00 00		 mov	 DWORD PTR _value$[esp+12], 1
  0000f	c7 44 24 08 04
	00 00 00	 mov	 DWORD PTR _size$[esp+12], 4
  00017	85 c0		 test	 eax, eax
  00019	7f 0c		 jg	 SHORT $LN18@IsUacSuppo
  0001b	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentOSMajor
$LN18@IsUacSuppo:
  00027	c1 e0 08	 shl	 eax, 8
  0002a	0b 05 00 00 00
	00		 or	 eax, DWORD PTR _CurrentOSMinor
  00030	c1 e0 08	 shl	 eax, 8
  00033	0b 05 00 00 00
	00		 or	 eax, DWORD PTR _CurrentOSServicePack
  00039	3d 00 00 06 00	 cmp	 eax, 393216		; 00060000H
  0003e	7d 06		 jge	 SHORT $LN3@IsUacSuppo

; 48   : 		return FALSE;

  00040	33 c0		 xor	 eax, eax

; 59   : }

  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
  00045	c3		 ret	 0
$LN3@IsUacSuppo:

; 49   : 
; 50   : 	if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System", 0, KEY_READ, &hkey) == ERROR_SUCCESS)

  00046	8d 44 24 04	 lea	 eax, DWORD PTR _hkey$[esp+12]
  0004a	50		 push	 eax
  0004b	68 19 00 02 00	 push	 131097			; 00020019H
  00050	6a 00		 push	 0
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@IFNHFOHB@Software?2Microsoft?2Windows?2Curre@
  00057	68 02 00 00 80	 push	 -2147483646		; 80000002H
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  00062	85 c0		 test	 eax, eax
  00064	75 32		 jne	 SHORT $LN2@IsUacSuppo

; 51   : 	{
; 52   : 		if (RegQueryValueExA(hkey, "EnableLUA", 0, 0, (LPBYTE) &value, &size) != ERROR_SUCCESS)

  00066	8d 4c 24 08	 lea	 ecx, DWORD PTR _size$[esp+12]
  0006a	51		 push	 ecx
  0006b	8d 54 24 04	 lea	 edx, DWORD PTR _value$[esp+16]
  0006f	52		 push	 edx
  00070	50		 push	 eax
  00071	50		 push	 eax
  00072	8b 44 24 14	 mov	 eax, DWORD PTR _hkey$[esp+28]
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_09IMBMLODE@EnableLUA?$AA@
  0007b	50		 push	 eax
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  00082	85 c0		 test	 eax, eax
  00084	74 07		 je	 SHORT $LN1@IsUacSuppo

; 53   : 			value = 1;

  00086	c7 04 24 01 00
	00 00		 mov	 DWORD PTR _value$[esp+12], 1
$LN1@IsUacSuppo:

; 54   : 
; 55   : 		RegCloseKey (hkey);

  0008d	8b 4c 24 04	 mov	 ecx, DWORD PTR _hkey$[esp+12]
  00091	51		 push	 ecx
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$LN2@IsUacSuppo:

; 56   : 	}
; 57   : 
; 58   : 	return value != 0;

  00098	33 c0		 xor	 eax, eax
  0009a	39 04 24	 cmp	 DWORD PTR _value$[esp+12], eax
  0009d	0f 95 c0	 setne	 al

; 59   : }

  000a0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a3	c3		 ret	 0
_IsUacSupported ENDP
_TEXT	ENDS
END
