; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\Public\Desktop\projects\ciphershed\src\Common\Inflate.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_mask_bits
_DATA	SEGMENT
COMM	_redirSlide:BYTE:08000H
COMM	_G:BYTE:02cH
_DATA	ENDS
CONST	SEGMENT
_border	DD	010H
	DD	011H
	DD	012H
	DD	00H
	DD	08H
	DD	07H
	DD	09H
	DD	06H
	DD	0aH
	DD	05H
	DD	0bH
	DD	04H
	DD	0cH
	DD	03H
	DD	0dH
	DD	02H
	DD	0eH
	DD	01H
	DD	0fH
_cplens	DW	03H
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0dH
	DW	0fH
	DW	011H
	DW	013H
	DW	017H
	DW	01bH
	DW	01fH
	DW	023H
	DW	02bH
	DW	033H
	DW	03bH
	DW	043H
	DW	053H
	DW	063H
	DW	073H
	DW	083H
	DW	0a3H
	DW	0c3H
	DW	0e3H
	DW	0102H
	DW	00H
	DW	00H
	ORG $+2
_cplext	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	00H
	DW	063H
	DW	063H
	ORG $+2
_cpdist	DW	01H
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	07H
	DW	09H
	DW	0dH
	DW	011H
	DW	019H
	DW	021H
	DW	031H
	DW	041H
	DW	061H
	DW	081H
	DW	0c1H
	DW	0101H
	DW	0181H
	DW	0201H
	DW	0301H
	DW	0401H
	DW	0601H
	DW	0801H
	DW	0c01H
	DW	01001H
	DW	01801H
	DW	02001H
	DW	03001H
	DW	04001H
	DW	06001H
_cpdext	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	03H
	DW	03H
	DW	04H
	DW	04H
	DW	05H
	DW	05H
	DW	06H
	DW	06H
	DW	07H
	DW	07H
	DW	08H
	DW	08H
	DW	09H
	DW	09H
	DW	0aH
	DW	0aH
	DW	0bH
	DW	0bH
	DW	0cH
	DW	0cH
	DW	0dH
	DW	0dH
_mask_bits DW	00H
	DW	01H
	DW	03H
	DW	07H
	DW	0fH
	DW	01fH
	DW	03fH
	DW	07fH
	DW	0ffH
	DW	01ffH
	DW	03ffH
	DW	07ffH
	DW	0fffH
	DW	01fffH
	DW	03fffH
	DW	07fffH
	DW	0ffffH
	ORG $+2
_lbits	DD	09H
_dbits	DD	06H
CONST	ENDS
PUBLIC	_inflate_codes
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
; File c:\users\public\desktop\projects\ciphershed\src\common\inflate.c
;	COMDAT _inflate_codes
_TEXT	SEGMENT
_w$ = -16						; size = 4
_n$ = -12						; size = 4
_ml$ = -8						; size = 4
_md$ = -4						; size = 4
_tl$ = 8						; size = 4
_td$ = 12						; size = 4
_bl$ = 16						; size = 4
_bd$ = 20						; size = 4
_inflate_codes PROC					; COMDAT

; 536  : {

  00000	83 ec 10	 sub	 esp, 16			; 00000010H

; 537  :   register unsigned e;  /* table entry flag/number of extra bits */
; 538  :   unsigned n, d;        /* length and index for copy */
; 539  :   unsigned w;           /* current window position */
; 540  :   struct huft *t;       /* pointer to table entry */
; 541  :   unsigned ml, md;      /* masks for bl and bd bits */
; 542  :   register ulg b;       /* bit buffer */
; 543  :   register unsigned k;  /* number of bits in bit buffer */
; 544  : 
; 545  : 
; 546  :   /* make local copies of globals */
; 547  :   b = G.bb;                       /* initialize bit buffer */
; 548  :   k = G.bk;
; 549  :   w = G.wp;                       /* initialize window position */

  00003	a1 24 00 00 00	 mov	 eax, DWORD PTR _G+36

; 550  : 
; 551  : 
; 552  :   /* inflate the coded data */
; 553  :   ml = mask_bits[bl];           /* precompute masks for speed */

  00008	8b 4c 24 1c	 mov	 ecx, DWORD PTR _bl$[esp+12]
  0000c	0f b7 14 4d 00
	00 00 00	 movzx	 edx, WORD PTR _mask_bits[ecx*2]
  00014	53		 push	 ebx
  00015	89 44 24 04	 mov	 DWORD PTR _w$[esp+20], eax

; 554  :   md = mask_bits[bd];

  00019	8b 44 24 24	 mov	 eax, DWORD PTR _bd$[esp+16]
  0001d	0f b7 0c 45 00
	00 00 00	 movzx	 ecx, WORD PTR _mask_bits[eax*2]
  00025	55		 push	 ebp
  00026	8b 2d 28 00 00
	00		 mov	 ebp, DWORD PTR _G+40
  0002c	56		 push	 esi
  0002d	8b 35 20 00 00
	00		 mov	 esi, DWORD PTR _G+32
  00033	57		 push	 edi
  00034	89 54 24 18	 mov	 DWORD PTR _ml$[esp+32], edx
  00038	89 4c 24 1c	 mov	 DWORD PTR _md$[esp+32], ecx
$LN110@inflate_co:
  0003c	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _G
$LL43@inflate_co:

; 555  :   while (1)                     /* do until end of block */
; 556  :   {
; 557  :     NEEDBITS((unsigned)bl)

  00042	8b 54 24 2c	 mov	 edx, DWORD PTR _bl$[esp+28]
  00046	3b f2		 cmp	 esi, edx
  00048	73 3b		 jae	 SHORT $LN92@inflate_co
  0004a	8d 9b 00 00 00
	00		 npad	 6
$LL41@inflate_co:
  00050	a1 08 00 00 00	 mov	 eax, DWORD PTR _G+8
  00055	8b c8		 mov	 ecx, eax
  00057	48		 dec	 eax
  00058	a3 08 00 00 00	 mov	 DWORD PTR _G+8, eax
  0005d	85 c9		 test	 ecx, ecx
  0005f	0f 8c 66 03 00
	00		 jl	 $LN103@inflate_co
  00065	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00068	43		 inc	 ebx
  00069	89 1d 00 00 00
	00		 mov	 DWORD PTR _G, ebx
  0006f	83 f8 ff	 cmp	 eax, -1
  00072	0f 84 53 03 00
	00		 je	 $LN103@inflate_co
  00078	8b ce		 mov	 ecx, esi
  0007a	d3 e0		 shl	 eax, cl
  0007c	83 c6 08	 add	 esi, 8
  0007f	0b e8		 or	 ebp, eax
  00081	3b f2		 cmp	 esi, edx
  00083	72 cb		 jb	 SHORT $LL41@inflate_co
$LN92@inflate_co:

; 558  :     if ((e = (t = tl + ((unsigned)b & ml))->e) > 16)

  00085	8b 54 24 18	 mov	 edx, DWORD PTR _ml$[esp+32]
  00089	8b 44 24 24	 mov	 eax, DWORD PTR _tl$[esp+28]
  0008d	23 d5		 and	 edx, ebp
  0008f	8d 3c d0	 lea	 edi, DWORD PTR [eax+edx*8]
  00092	0f b6 47 01	 movzx	 eax, BYTE PTR [edi+1]
  00096	83 f8 10	 cmp	 eax, 16			; 00000010H
  00099	76 6c		 jbe	 SHORT $LN35@inflate_co
  0009b	eb 03 8d 49 00	 npad	 5
$LL37@inflate_co:

; 559  :       do {
; 560  :         if (e == 99)

  000a0	83 f8 63	 cmp	 eax, 99			; 00000063H
  000a3	0f 84 22 03 00
	00		 je	 $LN103@inflate_co

; 561  :           return 1;
; 562  :         DUMPBITS(t->b)

  000a9	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  000ac	2b f1		 sub	 esi, ecx

; 563  :         e -= 16;

  000ae	83 e8 10	 sub	 eax, 16			; 00000010H
  000b1	d3 ed		 shr	 ebp, cl

; 564  :         NEEDBITS(e)

  000b3	3b f0		 cmp	 esi, eax
  000b5	73 37		 jae	 SHORT $LN36@inflate_co
$LL33@inflate_co:
  000b7	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR _G+8
  000bd	8b d1		 mov	 edx, ecx
  000bf	49		 dec	 ecx
  000c0	89 0d 08 00 00
	00		 mov	 DWORD PTR _G+8, ecx
  000c6	85 d2		 test	 edx, edx
  000c8	0f 8c fd 02 00
	00		 jl	 $LN103@inflate_co
  000ce	0f b6 13	 movzx	 edx, BYTE PTR [ebx]
  000d1	43		 inc	 ebx
  000d2	89 1d 00 00 00
	00		 mov	 DWORD PTR _G, ebx
  000d8	83 fa ff	 cmp	 edx, -1
  000db	0f 84 ea 02 00
	00		 je	 $LN103@inflate_co
  000e1	8b ce		 mov	 ecx, esi
  000e3	d3 e2		 shl	 edx, cl
  000e5	83 c6 08	 add	 esi, 8
  000e8	0b ea		 or	 ebp, edx
  000ea	3b f0		 cmp	 esi, eax
  000ec	72 c9		 jb	 SHORT $LL33@inflate_co
$LN36@inflate_co:

; 565  :       } while ((e = (t = t->v.t + ((unsigned)b & mask_bits[e]))->e) > 16);

  000ee	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR _mask_bits[eax*2]
  000f6	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000f9	23 c5		 and	 eax, ebp
  000fb	8d 3c c1	 lea	 edi, DWORD PTR [ecx+eax*8]
  000fe	0f b6 47 01	 movzx	 eax, BYTE PTR [edi+1]
  00102	83 f8 10	 cmp	 eax, 16			; 00000010H
  00105	77 99		 ja	 SHORT $LL37@inflate_co
$LN35@inflate_co:

; 566  :     DUMPBITS(t->b)

  00107	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  0010a	d3 ed		 shr	 ebp, cl
  0010c	2b f1		 sub	 esi, ecx

; 567  :     if (e == 16)                /* then it's a literal */

  0010e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00111	75 4c		 jne	 SHORT $LN30@inflate_co

; 568  :     {
; 569  :       redirSlide[w++] = (uch)t->v.n;

  00113	8b 44 24 10	 mov	 eax, DWORD PTR _w$[esp+32]
  00117	8a 57 04	 mov	 dl, BYTE PTR [edi+4]
  0011a	88 90 00 00 00
	00		 mov	 BYTE PTR _redirSlide[eax], dl
  00120	40		 inc	 eax
  00121	89 44 24 10	 mov	 DWORD PTR _w$[esp+32], eax

; 570  :       if (w == wsize)

  00125	3d 00 80 00 00	 cmp	 eax, 32768		; 00008000H
  0012a	0f 85 12 ff ff
	ff		 jne	 $LL43@inflate_co

; 571  :       {
; 572  :         FLUSH(w);

  00130	8b f8		 mov	 edi, eax
  00132	a1 04 00 00 00	 mov	 eax, DWORD PTR _G+4
  00137	57		 push	 edi
  00138	68 00 00 00 00	 push	 OFFSET _redirSlide
  0013d	50		 push	 eax
  0013e	e8 00 00 00 00	 call	 _memcpy
  00143	01 3d 04 00 00
	00		 add	 DWORD PTR _G+4, edi
  00149	83 c4 0c	 add	 esp, 12			; 0000000cH
  0014c	01 3d 0c 00 00
	00		 add	 DWORD PTR _G+12, edi

; 573  :         w = 0;

  00152	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _w$[esp+32], 0

; 574  :       }
; 575  :     }
; 576  :     else                        /* it's an EOB or a length */

  0015a	e9 dd fe ff ff	 jmp	 $LN110@inflate_co
$LN30@inflate_co:

; 577  :     {
; 578  :       /* exit if end of block */
; 579  :       if (e == 15)

  0015f	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00162	0f 84 44 02 00
	00		 je	 $LN82@inflate_co

; 580  :         break;
; 581  : 
; 582  :       /* get length of block to copy */
; 583  :       NEEDBITS(e)

  00168	3b f0		 cmp	 esi, eax
  0016a	73 3b		 jae	 SHORT $LN107@inflate_co
  0016c	8d 64 24 00	 npad	 4
$LL26@inflate_co:
  00170	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR _G+8
  00176	8b d1		 mov	 edx, ecx
  00178	49		 dec	 ecx
  00179	89 0d 08 00 00
	00		 mov	 DWORD PTR _G+8, ecx
  0017f	85 d2		 test	 edx, edx
  00181	0f 8c 44 02 00
	00		 jl	 $LN103@inflate_co
  00187	0f b6 13	 movzx	 edx, BYTE PTR [ebx]
  0018a	43		 inc	 ebx
  0018b	89 1d 00 00 00
	00		 mov	 DWORD PTR _G, ebx
  00191	83 fa ff	 cmp	 edx, -1
  00194	0f 84 31 02 00
	00		 je	 $LN103@inflate_co
  0019a	8b ce		 mov	 ecx, esi
  0019c	d3 e2		 shl	 edx, cl
  0019e	83 c6 08	 add	 esi, 8
  001a1	0b ea		 or	 ebp, edx
  001a3	3b f0		 cmp	 esi, eax
  001a5	72 c9		 jb	 SHORT $LL26@inflate_co
$LN107@inflate_co:

; 584  :       n = t->v.n + ((unsigned)b & mask_bits[e]);

  001a7	0f b7 0c 45 00
	00 00 00	 movzx	 ecx, WORD PTR _mask_bits[eax*2]
  001af	0f b7 7f 04	 movzx	 edi, WORD PTR [edi+4]
  001b3	8b 54 24 30	 mov	 edx, DWORD PTR _bd$[esp+28]
  001b7	23 cd		 and	 ecx, ebp
  001b9	03 cf		 add	 ecx, edi
  001bb	89 4c 24 14	 mov	 DWORD PTR _n$[esp+32], ecx

; 585  :       DUMPBITS(e);

  001bf	8b c8		 mov	 ecx, eax
  001c1	2b f0		 sub	 esi, eax
  001c3	d3 ed		 shr	 ebp, cl

; 586  : 
; 587  :       /* decode distance of block to copy */
; 588  :       NEEDBITS((unsigned)bd)

  001c5	3b f2		 cmp	 esi, edx
  001c7	73 3c		 jae	 SHORT $LN22@inflate_co
  001c9	8d a4 24 00 00
	00 00		 npad	 7
$LL23@inflate_co:
  001d0	a1 08 00 00 00	 mov	 eax, DWORD PTR _G+8
  001d5	8b c8		 mov	 ecx, eax
  001d7	48		 dec	 eax
  001d8	a3 08 00 00 00	 mov	 DWORD PTR _G+8, eax
  001dd	85 c9		 test	 ecx, ecx
  001df	0f 8c e6 01 00
	00		 jl	 $LN103@inflate_co
  001e5	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  001e8	43		 inc	 ebx
  001e9	89 1d 00 00 00
	00		 mov	 DWORD PTR _G, ebx
  001ef	83 f8 ff	 cmp	 eax, -1
  001f2	0f 84 d3 01 00
	00		 je	 $LN103@inflate_co
  001f8	8b ce		 mov	 ecx, esi
  001fa	d3 e0		 shl	 eax, cl
  001fc	83 c6 08	 add	 esi, 8
  001ff	0b e8		 or	 ebp, eax
  00201	3b f2		 cmp	 esi, edx
  00203	72 cb		 jb	 SHORT $LL23@inflate_co
$LN22@inflate_co:

; 589  :       if ((e = (t = td + ((unsigned)b & md))->e) > 16)

  00205	8b 54 24 1c	 mov	 edx, DWORD PTR _md$[esp+32]
  00209	8b 44 24 28	 mov	 eax, DWORD PTR _td$[esp+28]
  0020d	23 d5		 and	 edx, ebp
  0020f	8d 3c d0	 lea	 edi, DWORD PTR [eax+edx*8]
  00212	0f b6 47 01	 movzx	 eax, BYTE PTR [edi+1]
  00216	83 f8 10	 cmp	 eax, 16			; 00000010H
  00219	76 6c		 jbe	 SHORT $LN17@inflate_co
  0021b	eb 03 8d 49 00	 npad	 5
$LL19@inflate_co:

; 590  :         do {
; 591  :           if (e == 99)

  00220	83 f8 63	 cmp	 eax, 99			; 00000063H
  00223	0f 84 a2 01 00
	00		 je	 $LN103@inflate_co

; 592  :             return 1;
; 593  :           DUMPBITS(t->b)

  00229	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  0022c	2b f1		 sub	 esi, ecx

; 594  :           e -= 16;

  0022e	83 e8 10	 sub	 eax, 16			; 00000010H
  00231	d3 ed		 shr	 ebp, cl

; 595  :           NEEDBITS(e)

  00233	3b f0		 cmp	 esi, eax
  00235	73 37		 jae	 SHORT $LN18@inflate_co
$LL15@inflate_co:
  00237	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR _G+8
  0023d	8b d1		 mov	 edx, ecx
  0023f	49		 dec	 ecx
  00240	89 0d 08 00 00
	00		 mov	 DWORD PTR _G+8, ecx
  00246	85 d2		 test	 edx, edx
  00248	0f 8c 7d 01 00
	00		 jl	 $LN103@inflate_co
  0024e	0f b6 13	 movzx	 edx, BYTE PTR [ebx]
  00251	43		 inc	 ebx
  00252	89 1d 00 00 00
	00		 mov	 DWORD PTR _G, ebx
  00258	83 fa ff	 cmp	 edx, -1
  0025b	0f 84 6a 01 00
	00		 je	 $LN103@inflate_co
  00261	8b ce		 mov	 ecx, esi
  00263	d3 e2		 shl	 edx, cl
  00265	83 c6 08	 add	 esi, 8
  00268	0b ea		 or	 ebp, edx
  0026a	3b f0		 cmp	 esi, eax
  0026c	72 c9		 jb	 SHORT $LL15@inflate_co
$LN18@inflate_co:

; 596  :         } while ((e = (t = t->v.t + ((unsigned)b & mask_bits[e]))->e) > 16);

  0026e	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR _mask_bits[eax*2]
  00276	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00279	23 c5		 and	 eax, ebp
  0027b	8d 3c c1	 lea	 edi, DWORD PTR [ecx+eax*8]
  0027e	0f b6 47 01	 movzx	 eax, BYTE PTR [edi+1]
  00282	83 f8 10	 cmp	 eax, 16			; 00000010H
  00285	77 99		 ja	 SHORT $LL19@inflate_co
$LN17@inflate_co:

; 597  :       DUMPBITS(t->b)

  00287	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  0028a	2b f1		 sub	 esi, ecx
  0028c	d3 ed		 shr	 ebp, cl

; 598  :       NEEDBITS(e)

  0028e	3b f0		 cmp	 esi, eax
  00290	73 37		 jae	 SHORT $LN108@inflate_co
$LL12@inflate_co:
  00292	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR _G+8
  00298	8b d1		 mov	 edx, ecx
  0029a	49		 dec	 ecx
  0029b	89 0d 08 00 00
	00		 mov	 DWORD PTR _G+8, ecx
  002a1	85 d2		 test	 edx, edx
  002a3	0f 8c 22 01 00
	00		 jl	 $LN103@inflate_co
  002a9	0f b6 13	 movzx	 edx, BYTE PTR [ebx]
  002ac	43		 inc	 ebx
  002ad	89 1d 00 00 00
	00		 mov	 DWORD PTR _G, ebx
  002b3	83 fa ff	 cmp	 edx, -1
  002b6	0f 84 0f 01 00
	00		 je	 $LN103@inflate_co
  002bc	8b ce		 mov	 ecx, esi
  002be	d3 e2		 shl	 edx, cl
  002c0	83 c6 08	 add	 esi, 8
  002c3	0b ea		 or	 ebp, edx
  002c5	3b f0		 cmp	 esi, eax
  002c7	72 c9		 jb	 SHORT $LL12@inflate_co
$LN108@inflate_co:

; 599  :       d = w - t->v.n - ((unsigned)b & mask_bits[e]);

  002c9	0f b7 0c 45 00
	00 00 00	 movzx	 ecx, WORD PTR _mask_bits[eax*2]
  002d1	8b 54 24 10	 mov	 edx, DWORD PTR _w$[esp+32]
  002d5	23 cd		 and	 ecx, ebp
  002d7	8b da		 mov	 ebx, edx
  002d9	2b d9		 sub	 ebx, ecx
  002db	0f b7 4f 04	 movzx	 ecx, WORD PTR [edi+4]
  002df	2b d9		 sub	 ebx, ecx

; 600  :       DUMPBITS(e)

  002e1	8b c8		 mov	 ecx, eax
  002e3	d3 ed		 shr	 ebp, cl
  002e5	2b f0		 sub	 esi, eax
  002e7	eb 0b		 jmp	 SHORT $LN9@inflate_co
  002e9	8d a4 24 00 00
	00 00		 npad	 7
$LL94@inflate_co:
  002f0	8b 54 24 10	 mov	 edx, DWORD PTR _w$[esp+32]
$LN9@inflate_co:

; 601  : 
; 602  :       /* do the copy */
; 603  :       do {
; 604  : #if (defined(DLL) && !defined(NO_SLIDE_REDIR))
; 605  :         if (G.redirect_slide) {/* &= w/ wsize unnecessary & wrong if redirect */
; 606  :           if (d >= wsize)
; 607  :             return 1;           /* invalid compressed data */
; 608  :           n -= (e = (e = wsize - (d > w ? d : w)) > n ? n : e);
; 609  :         }
; 610  :         else
; 611  : #endif
; 612  :           n -= (e = (e = wsize - ((d &= wsize-1) > w ? d : w)) > n ? n : e);

  002f4	81 e3 ff 7f 00
	00		 and	 ebx, 32767		; 00007fffH
  002fa	8b c3		 mov	 eax, ebx
  002fc	3b da		 cmp	 ebx, edx
  002fe	77 02		 ja	 SHORT $LN59@inflate_co
  00300	8b c2		 mov	 eax, edx
$LN59@inflate_co:
  00302	bf 00 80 00 00	 mov	 edi, 32768		; 00008000H
  00307	2b f8		 sub	 edi, eax
  00309	8b 44 24 14	 mov	 eax, DWORD PTR _n$[esp+32]
  0030d	3b f8		 cmp	 edi, eax
  0030f	76 02		 jbe	 SHORT $LN60@inflate_co
  00311	8b f8		 mov	 edi, eax
$LN60@inflate_co:
  00313	2b c7		 sub	 eax, edi
  00315	89 44 24 14	 mov	 DWORD PTR _n$[esp+32], eax

; 613  : #ifndef NOMEMCPY
; 614  :         if (w - d >= e)         /* (this test assumes unsigned comparison) */

  00319	8b 44 24 10	 mov	 eax, DWORD PTR _w$[esp+32]
  0031d	8b d0		 mov	 edx, eax
  0031f	2b d3		 sub	 edx, ebx
  00321	3b d7		 cmp	 edx, edi
  00323	72 2b		 jb	 SHORT $LL4@inflate_co

; 615  :         {
; 616  :           memcpy(redirSlide + w, redirSlide + d, e);

  00325	57		 push	 edi
  00326	8d 8b 00 00 00
	00		 lea	 ecx, DWORD PTR _redirSlide[ebx]
  0032c	51		 push	 ecx
  0032d	8d 90 00 00 00
	00		 lea	 edx, DWORD PTR _redirSlide[eax]
  00333	52		 push	 edx
  00334	e8 00 00 00 00	 call	 _memcpy

; 617  :           w += e;

  00339	01 7c 24 1c	 add	 DWORD PTR _w$[esp+44], edi

; 618  :           d += e;
; 619  :         }
; 620  :         else                    /* do it slowly to avoid memcpy() overlap */

  0033d	8b 44 24 1c	 mov	 eax, DWORD PTR _w$[esp+44]
  00341	83 c4 0c	 add	 esp, 12			; 0000000cH
  00344	03 df		 add	 ebx, edi
  00346	eb 1f		 jmp	 SHORT $LN2@inflate_co
  00348	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL4@inflate_co:

; 621  : #endif /* !NOMEMCPY */
; 622  :           do {
; 623  :             redirSlide[w++] = redirSlide[d++];

  00350	8a 8b 00 00 00
	00		 mov	 cl, BYTE PTR _redirSlide[ebx]
  00356	88 88 00 00 00
	00		 mov	 BYTE PTR _redirSlide[eax], cl
  0035c	40		 inc	 eax
  0035d	43		 inc	 ebx

; 624  :           } while (--e);

  0035e	83 ef 01	 sub	 edi, 1
  00361	75 ed		 jne	 SHORT $LL4@inflate_co

; 621  : #endif /* !NOMEMCPY */
; 622  :           do {
; 623  :             redirSlide[w++] = redirSlide[d++];

  00363	89 44 24 10	 mov	 DWORD PTR _w$[esp+32], eax
$LN2@inflate_co:

; 625  :         if (w == wsize)

  00367	3d 00 80 00 00	 cmp	 eax, 32768		; 00008000H
  0036c	75 2e		 jne	 SHORT $LN8@inflate_co

; 626  :         {
; 627  :           FLUSH(w);

  0036e	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _G+4
  00374	50		 push	 eax
  00375	68 00 00 00 00	 push	 OFFSET _redirSlide
  0037a	52		 push	 edx
  0037b	e8 00 00 00 00	 call	 _memcpy
  00380	b8 00 80 00 00	 mov	 eax, 32768		; 00008000H
  00385	01 05 04 00 00
	00		 add	 DWORD PTR _G+4, eax
  0038b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0038e	01 05 0c 00 00
	00		 add	 DWORD PTR _G+12, eax

; 628  :           w = 0;

  00394	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _w$[esp+32], 0
$LN8@inflate_co:

; 629  :         }
; 630  :       } while (n);

  0039c	83 7c 24 14 00	 cmp	 DWORD PTR _n$[esp+32], 0
  003a1	0f 85 49 ff ff
	ff		 jne	 $LL94@inflate_co

; 631  :     }
; 632  :   }

  003a7	e9 90 fc ff ff	 jmp	 $LN110@inflate_co
$LN82@inflate_co:

; 633  : 
; 634  : 
; 635  :   /* restore the globals from the locals */
; 636  :   G.wp = w;                       /* restore global window pointer */

  003ac	8b 44 24 10	 mov	 eax, DWORD PTR _w$[esp+32]
  003b0	5f		 pop	 edi

; 637  :   G.bb = b;                       /* restore global bit buffer */
; 638  :   G.bk = k;

  003b1	89 35 20 00 00
	00		 mov	 DWORD PTR _G+32, esi
  003b7	5e		 pop	 esi
  003b8	89 2d 28 00 00
	00		 mov	 DWORD PTR _G+40, ebp
  003be	5d		 pop	 ebp
  003bf	a3 24 00 00 00	 mov	 DWORD PTR _G+36, eax

; 639  : 
; 640  : 
; 641  :   /* done */
; 642  :   return 0;

  003c4	33 c0		 xor	 eax, eax
  003c6	5b		 pop	 ebx

; 643  : }

  003c7	83 c4 10	 add	 esp, 16			; 00000010H
  003ca	c3		 ret	 0
$LN103@inflate_co:
  003cb	5f		 pop	 edi
  003cc	5e		 pop	 esi
  003cd	5d		 pop	 ebp

; 598  :       NEEDBITS(e)

  003ce	b8 01 00 00 00	 mov	 eax, 1
  003d3	5b		 pop	 ebx

; 643  : }

  003d4	83 c4 10	 add	 esp, 16			; 00000010H
  003d7	c3		 ret	 0
_inflate_codes ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _inflate_stored
_TEXT	SEGMENT
_inflate_stored PROC					; COMDAT

; 653  :   unsigned n;           /* number of bytes in block */
; 654  :   unsigned w;           /* current window position */
; 655  :   register ulg b;       /* bit buffer */
; 656  :   register unsigned k;  /* number of bits in bit buffer */
; 657  : 
; 658  : 
; 659  :   /* make local copies of globals */
; 660  :   Trace((stderr, "\nstored block"));
; 661  :   b = G.bb;                       /* initialize bit buffer */
; 662  :   k = G.bk;
; 663  :   w = G.wp;                       /* initialize window position */
; 664  : 
; 665  : 
; 666  :   /* go to byte boundary */
; 667  :   n = k & 7;
; 668  :   DUMPBITS(n);
; 669  : 
; 670  : 
; 671  :   /* get the length and its complement */
; 672  :   NEEDBITS(16)

  00000	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _G
  00006	53		 push	 ebx
  00007	8b 1d 28 00 00
	00		 mov	 ebx, DWORD PTR _G+40
  0000d	56		 push	 esi
  0000e	8b 35 20 00 00
	00		 mov	 esi, DWORD PTR _G+32
  00014	8b ce		 mov	 ecx, esi
  00016	83 e1 07	 and	 ecx, 7
  00019	2b f1		 sub	 esi, ecx
  0001b	d3 eb		 shr	 ebx, cl
  0001d	57		 push	 edi
  0001e	8b 3d 24 00 00
	00		 mov	 edi, DWORD PTR _G+36
  00024	83 fe 10	 cmp	 esi, 16			; 00000010H
  00027	73 3d		 jae	 SHORT $LN38@inflate_st
  00029	8d a4 24 00 00
	00 00		 npad	 7
$LL13@inflate_st:
  00030	a1 08 00 00 00	 mov	 eax, DWORD PTR _G+8
  00035	8b c8		 mov	 ecx, eax
  00037	48		 dec	 eax
  00038	a3 08 00 00 00	 mov	 DWORD PTR _G+8, eax
  0003d	85 c9		 test	 ecx, ecx
  0003f	0f 8c 20 01 00
	00		 jl	 $LN26@inflate_st
  00045	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00048	42		 inc	 edx
  00049	89 15 00 00 00
	00		 mov	 DWORD PTR _G, edx
  0004f	83 f8 ff	 cmp	 eax, -1
  00052	0f 84 0d 01 00
	00		 je	 $LN26@inflate_st
  00058	8b ce		 mov	 ecx, esi
  0005a	d3 e0		 shl	 eax, cl
  0005c	83 c6 08	 add	 esi, 8
  0005f	0b d8		 or	 ebx, eax
  00061	83 fe 10	 cmp	 esi, 16			; 00000010H
  00064	72 ca		 jb	 SHORT $LL13@inflate_st
$LN38@inflate_st:
  00066	55		 push	 ebp

; 673  :   n = ((unsigned)b & 0xffff);

  00067	0f b7 eb	 movzx	 ebp, bx

; 674  :   DUMPBITS(16)

  0006a	83 ee 10	 sub	 esi, 16			; 00000010H
  0006d	c1 eb 10	 shr	 ebx, 16			; 00000010H

; 675  :   NEEDBITS(16)

  00070	83 fe 10	 cmp	 esi, 16			; 00000010H
  00073	73 36		 jae	 SHORT $LN40@inflate_st
$LL10@inflate_st:
  00075	a1 08 00 00 00	 mov	 eax, DWORD PTR _G+8
  0007a	8b c8		 mov	 ecx, eax
  0007c	48		 dec	 eax
  0007d	a3 08 00 00 00	 mov	 DWORD PTR _G+8, eax
  00082	85 c9		 test	 ecx, ecx
  00084	0f 8c e4 00 00
	00		 jl	 $LN41@inflate_st
  0008a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0008d	42		 inc	 edx
  0008e	89 15 00 00 00
	00		 mov	 DWORD PTR _G, edx
  00094	83 f8 ff	 cmp	 eax, -1
  00097	0f 84 d1 00 00
	00		 je	 $LN41@inflate_st
  0009d	8b ce		 mov	 ecx, esi
  0009f	d3 e0		 shl	 eax, cl
  000a1	83 c6 08	 add	 esi, 8
  000a4	0b d8		 or	 ebx, eax
  000a6	83 fe 10	 cmp	 esi, 16			; 00000010H
  000a9	72 ca		 jb	 SHORT $LL10@inflate_st
$LN40@inflate_st:

; 676  :   if (n != (unsigned)((~b) & 0xffff))

  000ab	8b c3		 mov	 eax, ebx
  000ad	f7 d0		 not	 eax
  000af	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000b4	3b e8		 cmp	 ebp, eax

; 677  :     return 1;                   /* error in compressed data */

  000b6	0f 85 b2 00 00
	00		 jne	 $LN41@inflate_st

; 678  :   DUMPBITS(16)

  000bc	c1 eb 10	 shr	 ebx, 16			; 00000010H
  000bf	83 ee 10	 sub	 esi, 16			; 00000010H

; 679  : 
; 680  : 
; 681  :   /* read and output the compressed data */
; 682  :   while (n--)

  000c2	85 ed		 test	 ebp, ebp
  000c4	0f 84 82 00 00
	00		 je	 $LN32@inflate_st
  000ca	8d 9b 00 00 00
	00		 npad	 6
$LL6@inflate_st:
  000d0	4d		 dec	 ebp

; 683  :   {
; 684  :     NEEDBITS(8)

  000d1	83 fe 08	 cmp	 esi, 8
  000d4	73 32		 jae	 SHORT $LN3@inflate_st
$LL4@inflate_st:
  000d6	a1 08 00 00 00	 mov	 eax, DWORD PTR _G+8
  000db	8b c8		 mov	 ecx, eax
  000dd	48		 dec	 eax
  000de	a3 08 00 00 00	 mov	 DWORD PTR _G+8, eax
  000e3	85 c9		 test	 ecx, ecx
  000e5	0f 8c 83 00 00
	00		 jl	 $LN41@inflate_st
  000eb	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000ee	42		 inc	 edx
  000ef	89 15 00 00 00
	00		 mov	 DWORD PTR _G, edx
  000f5	83 f8 ff	 cmp	 eax, -1
  000f8	74 74		 je	 SHORT $LN41@inflate_st
  000fa	8b ce		 mov	 ecx, esi
  000fc	d3 e0		 shl	 eax, cl
  000fe	83 c6 08	 add	 esi, 8
  00101	0b d8		 or	 ebx, eax
  00103	83 fe 08	 cmp	 esi, 8
  00106	72 ce		 jb	 SHORT $LL4@inflate_st
$LN3@inflate_st:

; 685  :     redirSlide[w++] = (uch)b;

  00108	88 9f 00 00 00
	00		 mov	 BYTE PTR _redirSlide[edi], bl
  0010e	47		 inc	 edi

; 686  :     if (w == wsize)

  0010f	81 ff 00 80 00
	00		 cmp	 edi, 32768		; 00008000H
  00115	75 2b		 jne	 SHORT $LN1@inflate_st

; 687  :     {
; 688  :       FLUSH(w);

  00117	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _G+4
  0011d	57		 push	 edi
  0011e	68 00 00 00 00	 push	 OFFSET _redirSlide
  00123	52		 push	 edx
  00124	e8 00 00 00 00	 call	 _memcpy

; 689  :       w = 0;

  00129	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _G
  0012f	8b c7		 mov	 eax, edi
  00131	01 05 04 00 00
	00		 add	 DWORD PTR _G+4, eax
  00137	01 05 0c 00 00
	00		 add	 DWORD PTR _G+12, eax
  0013d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00140	33 ff		 xor	 edi, edi
$LN1@inflate_st:

; 690  :     }
; 691  :     DUMPBITS(8)

  00142	c1 eb 08	 shr	 ebx, 8
  00145	83 ee 08	 sub	 esi, 8
  00148	85 ed		 test	 ebp, ebp
  0014a	75 84		 jne	 SHORT $LL6@inflate_st
$LN32@inflate_st:
  0014c	5d		 pop	 ebp

; 692  :   }
; 693  : 
; 694  : 
; 695  :   /* restore the globals from the locals */
; 696  :   G.wp = w;                       /* restore global window pointer */

  0014d	89 3d 24 00 00
	00		 mov	 DWORD PTR _G+36, edi
  00153	5f		 pop	 edi

; 697  :   G.bb = b;                       /* restore global bit buffer */
; 698  :   G.bk = k;

  00154	89 35 20 00 00
	00		 mov	 DWORD PTR _G+32, esi
  0015a	5e		 pop	 esi
  0015b	89 1d 28 00 00
	00		 mov	 DWORD PTR _G+40, ebx

; 699  :   return 0;

  00161	33 c0		 xor	 eax, eax
  00163	5b		 pop	 ebx

; 700  : }

  00164	c3		 ret	 0
$LN26@inflate_st:
  00165	5f		 pop	 edi
  00166	5e		 pop	 esi

; 653  :   unsigned n;           /* number of bytes in block */
; 654  :   unsigned w;           /* current window position */
; 655  :   register ulg b;       /* bit buffer */
; 656  :   register unsigned k;  /* number of bits in bit buffer */
; 657  : 
; 658  : 
; 659  :   /* make local copies of globals */
; 660  :   Trace((stderr, "\nstored block"));
; 661  :   b = G.bb;                       /* initialize bit buffer */
; 662  :   k = G.bk;
; 663  :   w = G.wp;                       /* initialize window position */
; 664  : 
; 665  : 
; 666  :   /* go to byte boundary */
; 667  :   n = k & 7;
; 668  :   DUMPBITS(n);
; 669  : 
; 670  : 
; 671  :   /* get the length and its complement */
; 672  :   NEEDBITS(16)

  00167	b8 01 00 00 00	 mov	 eax, 1
  0016c	5b		 pop	 ebx

; 700  : }

  0016d	c3		 ret	 0
$LN41@inflate_st:
  0016e	5d		 pop	 ebp
  0016f	5f		 pop	 edi
  00170	5e		 pop	 esi

; 683  :   {
; 684  :     NEEDBITS(8)

  00171	b8 01 00 00 00	 mov	 eax, 1
  00176	5b		 pop	 ebx

; 700  : }

  00177	c3		 ret	 0
_inflate_stored ENDP
_TEXT	ENDS
PUBLIC	_huft_free
EXTRN	_free:PROC
; Function compile flags: /Ogtpy
;	COMDAT _huft_free
_TEXT	SEGMENT
_t$ = 8							; size = 4
_huft_free PROC						; COMDAT

; 1277 :   register struct huft *p, *q;
; 1278 : 
; 1279 : 
; 1280 :   /* Go through linked list, freeing from the malloced (t[-1]) address. */
; 1281 :   p = t;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _t$[esp-4]

; 1282 :   while (p != (struct huft *)NULL)

  00004	85 c0		 test	 eax, eax
  00006	74 1e		 je	 SHORT $LN7@huft_free
  00008	56		 push	 esi
  00009	8d a4 24 00 00
	00 00		 npad	 7
$LL2@huft_free:

; 1283 :   {
; 1284 :     q = (--p)->v.t;

  00010	8b 70 fc	 mov	 esi, DWORD PTR [eax-4]
  00013	83 e8 08	 sub	 eax, 8

; 1285 :     free((zvoid *)p);

  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 _free
  0001c	83 c4 04	 add	 esp, 4

; 1286 :     p = q;

  0001f	8b c6		 mov	 eax, esi
  00021	85 f6		 test	 esi, esi
  00023	75 eb		 jne	 SHORT $LL2@huft_free
  00025	5e		 pop	 esi
$LN7@huft_free:

; 1287 :   }
; 1288 :   return 0;

  00026	33 c0		 xor	 eax, eax

; 1289 : }

  00028	c3		 ret	 0
_huft_free ENDP
_TEXT	ENDS
PUBLIC	_inflate_free
; Function compile flags: /Ogtpy
;	COMDAT _inflate_free
_TEXT	SEGMENT
_inflate_free PROC					; COMDAT

; 1041 :   if (G.fixed_tl != (struct huft *)NULL)

  00000	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR _G+16, 0
  00007	74 52		 je	 SHORT $LN16@inflate_fr

; 1042 :   {
; 1043 :     huft_free(G.fixed_td);

  00009	a1 14 00 00 00	 mov	 eax, DWORD PTR _G+20
  0000e	56		 push	 esi
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN4@inflate_fr
$LL5@inflate_fr:
  00013	8b 70 fc	 mov	 esi, DWORD PTR [eax-4]
  00016	83 e8 08	 sub	 eax, 8
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _free
  0001f	83 c4 04	 add	 esp, 4
  00022	8b c6		 mov	 eax, esi
  00024	85 f6		 test	 esi, esi
  00026	75 eb		 jne	 SHORT $LL5@inflate_fr
$LN4@inflate_fr:

; 1044 :     huft_free(G.fixed_tl);

  00028	a1 10 00 00 00	 mov	 eax, DWORD PTR _G+16
  0002d	85 c0		 test	 eax, eax
  0002f	74 15		 je	 SHORT $LN8@inflate_fr
$LL9@inflate_fr:
  00031	8b 70 fc	 mov	 esi, DWORD PTR [eax-4]
  00034	83 e8 08	 sub	 eax, 8
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 _free
  0003d	83 c4 04	 add	 esp, 4
  00040	8b c6		 mov	 eax, esi
  00042	85 f6		 test	 esi, esi
  00044	75 eb		 jne	 SHORT $LL9@inflate_fr
$LN8@inflate_fr:

; 1045 :     G.fixed_td = G.fixed_tl = (struct huft *)NULL;

  00046	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR _G+16, 0
  00050	c7 05 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR _G+20, 0
  0005a	5e		 pop	 esi
$LN16@inflate_fr:

; 1046 :   }
; 1047 :   return 0;

  0005b	33 c0		 xor	 eax, eax

; 1048 : }

  0005d	c3		 ret	 0
_inflate_free ENDP
_TEXT	ENDS
PUBLIC	_huft_build
EXTRN	_malloc:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogtpy
;	COMDAT _huft_build
_TEXT	SEGMENT
_k$ = -1476						; size = 4
_p$ = -1472						; size = 4
_a$ = -1468						; size = 4
_r$ = -1464						; size = 8
tv1200 = -1456						; size = 4
_i$ = -1452						; size = 4
_g$ = -1448						; size = 4
tv1186 = -1444						; size = 4
_w$ = -1440						; size = 4
_el$ = -1436						; size = 4
_q$ = -1432						; size = 4
tv1068 = -1428						; size = 4
_y$ = -1424						; size = 4
_c$ = -1420						; size = 68
_lx$ = -1352						; size = 68
_x$ = -1284						; size = 68
_u$ = -1216						; size = 64
_v$ = -1152						; size = 1152
_b$ = 8							; size = 4
_n$ = 12						; size = 4
_s$ = 16						; size = 4
_d$ = 20						; size = 4
_e$ = 24						; size = 4
_t$ = 28						; size = 4
_m$ = 32						; size = 4
_huft_build PROC					; COMDAT

; 1082 : {

  00000	81 ec c4 05 00
	00		 sub	 esp, 1476		; 000005c4H
  00006	53		 push	 ebx
  00007	55		 push	 ebp

; 1083 :   unsigned a;                   /* counter for codes of length k */
; 1084 :   unsigned c[BMAX+1];           /* bit length count table */
; 1085 :   unsigned el;                  /* length of EOB code (value 256) */
; 1086 :   unsigned f;                   /* i repeats in table every f entries */
; 1087 :   int g;                        /* maximum code length */
; 1088 :   int h;                        /* table level */
; 1089 :   register unsigned i;          /* counter, current code */
; 1090 :   register unsigned j;          /* counter */
; 1091 :   register int k;               /* number of bits in current code */
; 1092 :   int lx[BMAX+1];               /* memory for l[-1..BMAX-1] */
; 1093 :   int *l = lx+1;                /* stack of bits per table */
; 1094 :   register unsigned *p;         /* pointer into c[], b[], or v[] */
; 1095 :   register struct huft *q;      /* points to current table */
; 1096 :   struct huft r;                /* table entry for structure assignment */
; 1097 :   struct huft *u[BMAX];         /* table stack */
; 1098 :   unsigned v[N_MAX];            /* values in order of bit length */
; 1099 :   register int w;               /* bits before this table == (l * h) */
; 1100 :   unsigned x[BMAX+1];           /* bit offsets, then code stack */
; 1101 :   unsigned *xp;                 /* pointer into x */
; 1102 :   int y;                        /* number of dummy codes added */
; 1103 :   unsigned z;                   /* number of entries in current table */
; 1104 : 
; 1105 : 
; 1106 :   /* Generate counts for each bit length */
; 1107 :   el = n > 256 ? b[256] : BMAX; /* set length of EOB code, if any */

  00008	8b ac 24 d4 05
	00 00		 mov	 ebp, DWORD PTR _n$[esp+1480]
  0000f	56		 push	 esi
  00010	8b b4 24 d4 05
	00 00		 mov	 esi, DWORD PTR _b$[esp+1484]
  00017	81 fd 00 01 00
	00		 cmp	 ebp, 256		; 00000100H
  0001d	76 0c		 jbe	 SHORT $LN55@huft_build
  0001f	8b 86 00 04 00
	00		 mov	 eax, DWORD PTR [esi+1024]
  00025	89 44 24 34	 mov	 DWORD PTR _el$[esp+1488], eax
  00029	eb 08		 jmp	 SHORT $LN56@huft_build
$LN55@huft_build:
  0002b	c7 44 24 34 10
	00 00 00	 mov	 DWORD PTR _el$[esp+1488], 16 ; 00000010H
$LN56@huft_build:

; 1108 :   memset(c, 0, sizeof(c));

  00033	6a 44		 push	 68			; 00000044H
  00035	33 db		 xor	 ebx, ebx
  00037	8d 4c 24 48	 lea	 ecx, DWORD PTR _c$[esp+1492]
  0003b	53		 push	 ebx
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 _memset
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1109 :   p = (unsigned *)b;  i = n;

  00045	8b ce		 mov	 ecx, esi
  00047	8b d5		 mov	 edx, ebp
  00049	8d a4 24 00 00
	00 00		 npad	 7
$LL52@huft_build:

; 1110 :   do {
; 1111 :     c[*p]++; p++;               /* assume all entries <= BMAX */

  00050	8b 01		 mov	 eax, DWORD PTR [ecx]
  00052	ff 44 84 44	 inc	 DWORD PTR _c$[esp+eax*4+1488]
  00056	8d 44 84 44	 lea	 eax, DWORD PTR _c$[esp+eax*4+1488]
  0005a	83 c1 04	 add	 ecx, 4

; 1112 :   } while (--i);

  0005d	83 ea 01	 sub	 edx, 1
  00060	75 ee		 jne	 SHORT $LL52@huft_build

; 1113 :   if (c[0] == n)                /* null input--all zero length codes */

  00062	39 6c 24 44	 cmp	 DWORD PTR _c$[esp+1488], ebp
  00066	75 1e		 jne	 SHORT $LN49@huft_build

; 1114 :   {
; 1115 :     *t = (struct huft *)NULL;

  00068	8b 94 24 e8 05
	00 00		 mov	 edx, DWORD PTR _t$[esp+1484]

; 1116 :     *m = 0;

  0006f	8b 84 24 ec 05
	00 00		 mov	 eax, DWORD PTR _m$[esp+1484]
  00076	5e		 pop	 esi
  00077	89 1a		 mov	 DWORD PTR [edx], ebx
  00079	89 18		 mov	 DWORD PTR [eax], ebx
  0007b	5d		 pop	 ebp

; 1117 :     return 0;

  0007c	33 c0		 xor	 eax, eax
  0007e	5b		 pop	 ebx

; 1267 : }

  0007f	81 c4 c4 05 00
	00		 add	 esp, 1476		; 000005c4H
  00085	c3		 ret	 0
$LN49@huft_build:

; 1118 :   }
; 1119 : 
; 1120 : 
; 1121 :   /* Find minimum and maximum length, bound *m by those */
; 1122 :   for (j = 1; j <= BMAX; j++)

  00086	b9 01 00 00 00	 mov	 ecx, 1
  0008b	eb 03 8d 49 00	 npad	 5
$LL48@huft_build:

; 1123 :     if (c[j])

  00090	39 5c 8c 44	 cmp	 DWORD PTR _c$[esp+ecx*4+1488], ebx
  00094	75 06		 jne	 SHORT $LN103@huft_build
  00096	41		 inc	 ecx
  00097	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0009a	76 f4		 jbe	 SHORT $LL48@huft_build
$LN103@huft_build:

; 1124 :       break;
; 1125 :   k = j;                        /* minimum code length */
; 1126 :   if ((unsigned)*m < j)

  0009c	8b 94 24 ec 05
	00 00		 mov	 edx, DWORD PTR _m$[esp+1484]
  000a3	89 4c 24 0c	 mov	 DWORD PTR _k$[esp+1488], ecx
  000a7	39 0a		 cmp	 DWORD PTR [edx], ecx
  000a9	73 02		 jae	 SHORT $LN44@huft_build

; 1127 :     *m = j;

  000ab	89 0a		 mov	 DWORD PTR [edx], ecx
$LN44@huft_build:

; 1128 :   for (i = BMAX; i; i--)

  000ad	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
$LL43@huft_build:

; 1129 :     if (c[i])

  000b2	39 5c 84 44	 cmp	 DWORD PTR _c$[esp+eax*4+1488], ebx
  000b6	75 05		 jne	 SHORT $LN80@huft_build

; 1128 :   for (i = BMAX; i; i--)

  000b8	83 e8 01	 sub	 eax, 1
  000bb	75 f5		 jne	 SHORT $LL43@huft_build
$LN80@huft_build:

; 1130 :       break;
; 1131 :   g = i;                        /* maximum code length */

  000bd	89 44 24 28	 mov	 DWORD PTR _g$[esp+1488], eax

; 1132 :   if ((unsigned)*m > i)

  000c1	39 02		 cmp	 DWORD PTR [edx], eax
  000c3	76 02		 jbe	 SHORT $LN39@huft_build

; 1133 :     *m = i;

  000c5	89 02		 mov	 DWORD PTR [edx], eax
$LN39@huft_build:

; 1134 : 
; 1135 : 
; 1136 :   /* Adjust last length count to fill out codes, if needed */
; 1137 :   for (y = 1 << j; j < i; j++, y <<= 1)

  000c7	ba 01 00 00 00	 mov	 edx, 1
  000cc	d3 e2		 shl	 edx, cl
  000ce	3b c8		 cmp	 ecx, eax
  000d0	73 0d		 jae	 SHORT $LN36@huft_build
$LL38@huft_build:

; 1138 :     if ((y -= c[j]) < 0)

  000d2	2b 54 8c 44	 sub	 edx, DWORD PTR _c$[esp+ecx*4+1488]
  000d6	78 2b		 js	 SHORT $LN81@huft_build
  000d8	41		 inc	 ecx
  000d9	03 d2		 add	 edx, edx
  000db	3b c8		 cmp	 ecx, eax
  000dd	72 f3		 jb	 SHORT $LL38@huft_build
$LN36@huft_build:
  000df	57		 push	 edi

; 1140 :   if ((y -= c[i]) < 0)

  000e0	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
  000e7	8b 4c 3c 48	 mov	 ecx, DWORD PTR _c$[esp+edi+1492]
  000eb	2b d1		 sub	 edx, ecx
  000ed	89 54 24 44	 mov	 DWORD PTR _y$[esp+1492], edx
  000f1	79 1f		 jns	 SHORT $LN34@huft_build
  000f3	5f		 pop	 edi
  000f4	5e		 pop	 esi
  000f5	5d		 pop	 ebp

; 1141 :     return 2;

  000f6	b8 02 00 00 00	 mov	 eax, 2
  000fb	5b		 pop	 ebx

; 1267 : }

  000fc	81 c4 c4 05 00
	00		 add	 esp, 1476		; 000005c4H
  00102	c3		 ret	 0
$LN81@huft_build:
  00103	5e		 pop	 esi
  00104	5d		 pop	 ebp

; 1139 :       return 2;                 /* bad input: more codes than bits */

  00105	b8 02 00 00 00	 mov	 eax, 2
  0010a	5b		 pop	 ebx

; 1267 : }

  0010b	81 c4 c4 05 00
	00		 add	 esp, 1476		; 000005c4H
  00111	c3		 ret	 0
$LN34@huft_build:

; 1142 :   c[i] += y;

  00112	03 ca		 add	 ecx, edx
  00114	89 4c 3c 48	 mov	 DWORD PTR _c$[esp+edi+1492], ecx

; 1143 : 
; 1144 : 
; 1145 :   /* Generate starting offsets into the value table for each length */
; 1146 :   x[1] = j = 0;

  00118	33 c9		 xor	 ecx, ecx

; 1147 :   p = c + 1;  xp = x + 2;
; 1148 :   while (--i) {                 /* note that i == g from above */

  0011a	83 e8 01	 sub	 eax, 1
  0011d	89 9c 24 d4 00
	00 00		 mov	 DWORD PTR _x$[esp+1496], ebx
  00124	74 1d		 je	 SHORT $LN32@huft_build
  00126	33 d2		 xor	 edx, edx
  00128	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL33@huft_build:

; 1149 :     *xp++ = (j += *p++);

  00130	03 4c 14 4c	 add	 ecx, DWORD PTR _c$[esp+edx+1496]
  00134	83 c2 04	 add	 edx, 4
  00137	83 e8 01	 sub	 eax, 1
  0013a	89 8c 14 d4 00
	00 00		 mov	 DWORD PTR _x$[esp+edx+1496], ecx
  00141	75 ed		 jne	 SHORT $LL33@huft_build
$LN32@huft_build:

; 1150 :   }
; 1151 : 
; 1152 : 
; 1153 :   /* Make a table of values in order of bit lengths */
; 1154 :   memset(v, 0, sizeof(v));

  00143	68 80 04 00 00	 push	 1152			; 00000480H
  00148	8d 8c 24 58 01
	00 00		 lea	 ecx, DWORD PTR _v$[esp+1496]
  0014f	53		 push	 ebx
  00150	51		 push	 ecx
  00151	e8 00 00 00 00	 call	 _memset
  00156	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1155 :   p = (unsigned *)b;  i = 0;

  00159	33 d2		 xor	 edx, edx
  0015b	eb 03 8d 49 00	 npad	 5
$LL31@huft_build:

; 1156 :   do {
; 1157 :     if ((j = *p++) != 0)

  00160	8b 06		 mov	 eax, DWORD PTR [esi]
  00162	83 c6 04	 add	 esi, 4
  00165	3b c3		 cmp	 eax, ebx
  00167	74 18		 je	 SHORT $LN30@huft_build

; 1158 :       v[x[j]++] = i;

  00169	8b 8c 84 d0 00
	00 00		 mov	 ecx, DWORD PTR _x$[esp+eax*4+1492]
  00170	8d 84 84 d0 00
	00 00		 lea	 eax, DWORD PTR _x$[esp+eax*4+1492]
  00177	89 94 8c 54 01
	00 00		 mov	 DWORD PTR _v$[esp+ecx*4+1492], edx
  0017e	41		 inc	 ecx
  0017f	89 08		 mov	 DWORD PTR [eax], ecx
$LN30@huft_build:

; 1159 :   } while (++i < n);

  00181	42		 inc	 edx
  00182	3b d5		 cmp	 edx, ebp
  00184	72 da		 jb	 SHORT $LL31@huft_build

; 1160 :   n = x[g];                     /* set n to length of v */

  00186	8b 94 3c d0 00
	00 00		 mov	 edx, DWORD PTR _x$[esp+edi+1492]

; 1161 : 
; 1162 : 
; 1163 :   /* Generate the Huffman codes and for each, make the table entries */
; 1164 :   x[0] = i = 0;                 /* first Huffman code is zero */
; 1165 :   p = v;                        /* grab values in bit order */
; 1166 :   h = -1;                       /* no tables yet--level -1 */
; 1167 :   w = l[-1] = 0;                /* no bits decoded yet */
; 1168 :   u[0] = (struct huft *)NULL;   /* just to keep compilers happy */
; 1169 :   q = (struct huft *)NULL;      /* ditto */
; 1170 :   z = 0;                        /* ditto */
; 1171 : 
; 1172 :   /* go through the bit lengths (k already is bits in shortest code) */
; 1173 :   for (; k <= g; k++)

  0018d	8b 4c 24 10	 mov	 ecx, DWORD PTR _k$[esp+1492]
  00191	8d 84 24 54 01
	00 00		 lea	 eax, DWORD PTR _v$[esp+1492]
  00198	89 44 24 14	 mov	 DWORD PTR _p$[esp+1492], eax
  0019c	8b 44 24 2c	 mov	 eax, DWORD PTR _g$[esp+1492]
  001a0	33 ff		 xor	 edi, edi
  001a2	83 ce ff	 or	 esi, -1
  001a5	33 ed		 xor	 ebp, ebp
  001a7	3b c8		 cmp	 ecx, eax
  001a9	89 94 24 dc 05
	00 00		 mov	 DWORD PTR _n$[esp+1488], edx
  001b0	89 7c 24 28	 mov	 DWORD PTR _i$[esp+1492], edi
  001b4	89 9c 24 d0 00
	00 00		 mov	 DWORD PTR _x$[esp+1492], ebx
  001bb	89 9c 24 8c 00
	00 00		 mov	 DWORD PTR _lx$[esp+1492], ebx
  001c2	89 9c 24 14 01
	00 00		 mov	 DWORD PTR _u$[esp+1492], ebx
  001c9	89 5c 24 3c	 mov	 DWORD PTR _q$[esp+1492], ebx
  001cd	0f 8f a6 02 00
	00		 jg	 $LN100@huft_build
  001d3	8d 51 ff	 lea	 edx, DWORD PTR [ecx-1]
  001d6	89 54 24 30	 mov	 DWORD PTR tv1186[esp+1492], edx
  001da	8d 54 8c 48	 lea	 edx, DWORD PTR _c$[esp+ecx*4+1492]
  001de	89 54 24 24	 mov	 DWORD PTR tv1200[esp+1492], edx
$LL101@huft_build:

; 1174 :   {
; 1175 :     a = c[k];

  001e2	8b 54 24 24	 mov	 edx, DWORD PTR tv1200[esp+1492]
  001e6	8b 12		 mov	 edx, DWORD PTR [edx]
  001e8	89 54 24 18	 mov	 DWORD PTR _a$[esp+1492], edx

; 1176 :     while (a--)

  001ec	85 d2		 test	 edx, edx
  001ee	0f 84 6f 02 00
	00		 je	 $LN102@huft_build
  001f4	eb 0a 8d a4 24
	00 00 00 00 8d
	49 00		 npad	 12
$LL24@huft_build:

; 1177 :     {
; 1178 :       /* here i is the Huffman code of length k bits for value *p */
; 1179 :       /* make tables up to required level */
; 1180 :       while (k > w + l[h])

  00200	8b 84 b4 90 00
	00 00		 mov	 eax, DWORD PTR _lx$[esp+esi*4+1496]
  00207	ff 4c 24 18	 dec	 DWORD PTR _a$[esp+1492]
  0020b	03 c3		 add	 eax, ebx
  0020d	3b c8		 cmp	 ecx, eax
  0020f	0f 8e 36 01 00
	00		 jle	 $LN21@huft_build
  00215	8d 94 24 14 01
	00 00		 lea	 edx, DWORD PTR _u$[esp+1492]
  0021c	83 ea 04	 sub	 edx, 4
  0021f	89 54 24 40	 mov	 DWORD PTR tv1068[esp+1492], edx
$LL22@huft_build:

; 1181 :       {
; 1182 :         w += l[h++];            /* add bits already decoded */
; 1183 : 
; 1184 :         /* compute minimum size table less than or equal to *m bits */
; 1185 :         z = (z = g - w) > (unsigned)*m ? *m : z;        /* upper limit */

  00223	8b 54 24 2c	 mov	 edx, DWORD PTR _g$[esp+1492]
  00227	8b e8		 mov	 ebp, eax
  00229	8b 84 24 f0 05
	00 00		 mov	 eax, DWORD PTR _m$[esp+1488]
  00230	8b 00		 mov	 eax, DWORD PTR [eax]
  00232	2b d5		 sub	 edx, ebp
  00234	46		 inc	 esi
  00235	89 6c 24 34	 mov	 DWORD PTR _w$[esp+1492], ebp
  00239	3b d0		 cmp	 edx, eax
  0023b	76 02		 jbe	 SHORT $LN57@huft_build
  0023d	8b d0		 mov	 edx, eax
$LN57@huft_build:

; 1186 :         if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */

  0023f	8b d9		 mov	 ebx, ecx
  00241	2b dd		 sub	 ebx, ebp
  00243	8b cb		 mov	 ecx, ebx
  00245	b8 01 00 00 00	 mov	 eax, 1
  0024a	d3 e0		 shl	 eax, cl
  0024c	8b 4c 24 18	 mov	 ecx, DWORD PTR _a$[esp+1492]
  00250	41		 inc	 ecx
  00251	3b c1		 cmp	 eax, ecx
  00253	76 29		 jbe	 SHORT $LN82@huft_build

; 1187 :         {                       /* too few codes for k-w bit table */
; 1188 :           f -= a + 1;           /* deduct codes from patterns left */
; 1189 :           xp = c + k;

  00255	8b 7c 24 24	 mov	 edi, DWORD PTR tv1200[esp+1492]
  00259	83 c9 ff	 or	 ecx, -1
  0025c	2b 4c 24 18	 sub	 ecx, DWORD PTR _a$[esp+1492]

; 1190 :           while (++j < z)       /* try smaller tables up to z bits */

  00260	43		 inc	 ebx
  00261	03 c1		 add	 eax, ecx
  00263	3b da		 cmp	 ebx, edx
  00265	73 13		 jae	 SHORT $LN97@huft_build
$LL19@huft_build:

; 1191 :           {
; 1192 :             if ((f <<= 1) <= *++xp)

  00267	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0026a	83 c7 04	 add	 edi, 4
  0026d	03 c0		 add	 eax, eax
  0026f	3b c1		 cmp	 eax, ecx
  00271	76 07		 jbe	 SHORT $LN97@huft_build
  00273	43		 inc	 ebx

; 1193 :               break;            /* enough codes to use up j bits */
; 1194 :             f -= *xp;           /* else deduct codes from patterns */

  00274	2b c1		 sub	 eax, ecx
  00276	3b da		 cmp	 ebx, edx
  00278	72 ed		 jb	 SHORT $LL19@huft_build
$LN97@huft_build:

; 1190 :           while (++j < z)       /* try smaller tables up to z bits */

  0027a	8b 7c 24 28	 mov	 edi, DWORD PTR _i$[esp+1492]
$LN82@huft_build:

; 1195 :           }
; 1196 :         }
; 1197 :         if ((unsigned)w + j > el && (unsigned)w < el)

  0027e	8b 44 24 38	 mov	 eax, DWORD PTR _el$[esp+1492]
  00282	8d 14 2b	 lea	 edx, DWORD PTR [ebx+ebp]
  00285	3b d0		 cmp	 edx, eax
  00287	76 08		 jbe	 SHORT $LN16@huft_build
  00289	3b e8		 cmp	 ebp, eax
  0028b	73 04		 jae	 SHORT $LN16@huft_build

; 1198 :           j = el - w;           /* make EOB code end at table */

  0028d	8b d8		 mov	 ebx, eax
  0028f	2b dd		 sub	 ebx, ebp
$LN16@huft_build:

; 1199 :         z = 1 << j;             /* table entries for j-bit table */

  00291	8b cb		 mov	 ecx, ebx
  00293	bd 01 00 00 00	 mov	 ebp, 1
  00298	d3 e5		 shl	 ebp, cl

; 1200 :         l[h] = j;               /* set table size in stack */

  0029a	89 9c b4 90 00
	00 00		 mov	 DWORD PTR _lx$[esp+esi*4+1496], ebx

; 1201 : 
; 1202 :         /* allocate and link in new table */
; 1203 :         if ((q = (struct huft *)malloc((z + 1)*sizeof(struct huft))) ==
; 1204 :             (struct huft *)NULL)

  002a1	8d 04 ed 08 00
	00 00		 lea	 eax, DWORD PTR [ebp*8+8]
  002a8	50		 push	 eax
  002a9	e8 00 00 00 00	 call	 _malloc
  002ae	83 c4 04	 add	 esp, 4
  002b1	85 c0		 test	 eax, eax
  002b3	0f 84 ec 01 00
	00		 je	 $LN83@huft_build

; 1209 :         }
; 1210 : //#ifdef DEBUG
; 1211 : //        G.hufts += z + 1;         /* track memory usage */
; 1212 : //#endif
; 1213 :         *t = q + 1;             /* link to list for huft_free() */

  002b9	8b 94 24 ec 05
	00 00		 mov	 edx, DWORD PTR _t$[esp+1488]
  002c0	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]

; 1214 :         *(t = &(q->v.t)) = (struct huft *)NULL;

  002c3	83 c0 04	 add	 eax, 4
  002c6	89 0a		 mov	 DWORD PTR [edx], ecx

; 1215 :         u[h] = ++q;             /* table starts after link */
; 1216 : 
; 1217 :         /* connect to last table, if there is one */
; 1218 :         if (h)
; 1219 :         {
; 1220 :           x[h] = i;             /* save pattern for backing up */
; 1221 :           r.b = (uch)l[h-1];    /* bits to dump before this table */
; 1222 :           r.e = (uch)(16 + j);  /* bits in this table */
; 1223 :           r.v.t = q;            /* pointer to this table */
; 1224 :           j = (i & ((1 << w) - 1)) >> (w - l[h-1]);

  002c8	8b 54 24 34	 mov	 edx, DWORD PTR _w$[esp+1492]
  002cc	89 84 24 ec 05
	00 00		 mov	 DWORD PTR _t$[esp+1488], eax
  002d3	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  002d9	89 4c 24 3c	 mov	 DWORD PTR _q$[esp+1492], ecx
  002dd	89 8c b4 14 01
	00 00		 mov	 DWORD PTR _u$[esp+esi*4+1492], ecx
  002e4	85 f6		 test	 esi, esi
  002e6	74 4a		 je	 SHORT $LN13@huft_build
  002e8	8a 84 b4 8c 00
	00 00		 mov	 al, BYTE PTR _lx$[esp+esi*4+1492]
  002ef	88 44 24 1c	 mov	 BYTE PTR _r$[esp+1492], al
  002f3	80 c3 10	 add	 bl, 16			; 00000010H
  002f6	88 5c 24 1d	 mov	 BYTE PTR _r$[esp+1493], bl
  002fa	8b d9		 mov	 ebx, ecx
  002fc	8b ca		 mov	 ecx, edx
  002fe	b8 01 00 00 00	 mov	 eax, 1
  00303	d3 e0		 shl	 eax, cl
  00305	2b 8c b4 8c 00
	00 00		 sub	 ecx, DWORD PTR _lx$[esp+esi*4+1492]
  0030c	89 bc b4 d0 00
	00 00		 mov	 DWORD PTR _x$[esp+esi*4+1492], edi
  00313	89 5c 24 20	 mov	 DWORD PTR _r$[esp+1496], ebx
  00317	48		 dec	 eax
  00318	23 c7		 and	 eax, edi

; 1225 :           u[h-1][j] = r;        /* connect to last table */

  0031a	8b 7c 24 1c	 mov	 edi, DWORD PTR _r$[esp+1492]
  0031e	d3 e8		 shr	 eax, cl
  00320	8b 4c 24 40	 mov	 ecx, DWORD PTR tv1068[esp+1492]
  00324	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  00327	89 3c c1	 mov	 DWORD PTR [ecx+eax*8], edi
  0032a	8b 7c 24 28	 mov	 edi, DWORD PTR _i$[esp+1492]
  0032e	89 5c c1 04	 mov	 DWORD PTR [ecx+eax*8+4], ebx
$LN13@huft_build:
  00332	8b 84 b4 90 00
	00 00		 mov	 eax, DWORD PTR _lx$[esp+esi*4+1496]
  00339	8b 4c 24 10	 mov	 ecx, DWORD PTR _k$[esp+1492]
  0033d	03 c2		 add	 eax, edx
  0033f	3b c8		 cmp	 ecx, eax
  00341	0f 8f dc fe ff
	ff		 jg	 $LL22@huft_build

; 1177 :     {
; 1178 :       /* here i is the Huffman code of length k bits for value *p */
; 1179 :       /* make tables up to required level */
; 1180 :       while (k > w + l[h])

  00347	8b 5c 24 34	 mov	 ebx, DWORD PTR _w$[esp+1492]
$LN21@huft_build:

; 1226 :         }
; 1227 :       }
; 1228 : 
; 1229 :       /* set up table entry in r */
; 1230 :       r.b = (uch)(k - w);
; 1231 :       if (p >= v + n)

  0034b	8b 84 24 dc 05
	00 00		 mov	 eax, DWORD PTR _n$[esp+1488]
  00352	8a d1		 mov	 dl, cl
  00354	2a d3		 sub	 dl, bl
  00356	88 54 24 1c	 mov	 BYTE PTR _r$[esp+1492], dl
  0035a	8d 94 84 54 01
	00 00		 lea	 edx, DWORD PTR _v$[esp+eax*4+1492]
  00361	8b 44 24 14	 mov	 eax, DWORD PTR _p$[esp+1492]
  00365	3b c2		 cmp	 eax, edx
  00367	72 07		 jb	 SHORT $LN12@huft_build

; 1232 :         r.e = 99;               /* out of values--invalid code */

  00369	c6 44 24 1d 63	 mov	 BYTE PTR _r$[esp+1493], 99 ; 00000063H
  0036e	eb 57		 jmp	 SHORT $LN9@huft_build
$LN12@huft_build:

; 1233 :       else if (*p < s)

  00370	8b 00		 mov	 eax, DWORD PTR [eax]
  00372	8b 94 24 e0 05
	00 00		 mov	 edx, DWORD PTR _s$[esp+1488]
  00379	3b c2		 cmp	 eax, edx
  0037b	73 23		 jae	 SHORT $LN10@huft_build

; 1234 :       {
; 1235 :         r.e = (uch)(*p < 256 ? 16 : 15);  /* 256 is end-of-block code */

  0037d	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00382	0f 92 c0	 setb	 al
  00385	04 0f		 add	 al, 15			; 0000000fH
  00387	88 44 24 1d	 mov	 BYTE PTR _r$[esp+1493], al

; 1236 :         r.v.n = (ush)*p++;                /* simple code is just the value */

  0038b	8b 44 24 14	 mov	 eax, DWORD PTR _p$[esp+1492]
  0038f	66 8b 10	 mov	 dx, WORD PTR [eax]
  00392	83 c0 04	 add	 eax, 4
  00395	66 89 54 24 20	 mov	 WORD PTR _r$[esp+1496], dx
  0039a	89 44 24 14	 mov	 DWORD PTR _p$[esp+1492], eax

; 1237 :       }
; 1238 :       else

  0039e	eb 27		 jmp	 SHORT $LN9@huft_build
$LN10@huft_build:

; 1239 :       {
; 1240 :         r.e = (uch)e[*p - s];   /* non-simple--look up in lists */

  003a0	2b c2		 sub	 eax, edx
  003a2	8b 94 24 e8 05
	00 00		 mov	 edx, DWORD PTR _e$[esp+1488]
  003a9	03 c0		 add	 eax, eax
  003ab	8a 14 10	 mov	 dl, BYTE PTR [eax+edx]

; 1241 :         r.v.n = d[*p++ - s];

  003ae	83 44 24 14 04	 add	 DWORD PTR _p$[esp+1492], 4
  003b3	88 54 24 1d	 mov	 BYTE PTR _r$[esp+1493], dl
  003b7	8b 94 24 e4 05
	00 00		 mov	 edx, DWORD PTR _d$[esp+1488]
  003be	66 8b 04 10	 mov	 ax, WORD PTR [eax+edx]
  003c2	66 89 44 24 20	 mov	 WORD PTR _r$[esp+1496], ax
$LN9@huft_build:

; 1242 :       }
; 1243 : 
; 1244 :       /* fill code-like entries with r */
; 1245 :       f = 1 << (k - w);

  003c7	2b cb		 sub	 ecx, ebx
  003c9	ba 01 00 00 00	 mov	 edx, 1
  003ce	d3 e2		 shl	 edx, cl

; 1246 :       for (j = i >> w; j < z; j += f)

  003d0	8b c7		 mov	 eax, edi
  003d2	8b cb		 mov	 ecx, ebx
  003d4	d3 e8		 shr	 eax, cl
  003d6	3b c5		 cmp	 eax, ebp
  003d8	73 27		 jae	 SHORT $LN6@huft_build
  003da	8b 4c 24 3c	 mov	 ecx, DWORD PTR _q$[esp+1492]
  003de	8d 0c c1	 lea	 ecx, DWORD PTR [ecx+eax*8]
$LL99@huft_build:

; 1247 :         q[j] = r;

  003e1	8b 7c 24 1c	 mov	 edi, DWORD PTR _r$[esp+1492]
  003e5	89 39		 mov	 DWORD PTR [ecx], edi
  003e7	8b 7c 24 20	 mov	 edi, DWORD PTR _r$[esp+1496]
  003eb	89 79 04	 mov	 DWORD PTR [ecx+4], edi
  003ee	8d 3c d5 00 00
	00 00		 lea	 edi, DWORD PTR [edx*8]
  003f5	03 c2		 add	 eax, edx
  003f7	03 cf		 add	 ecx, edi
  003f9	3b c5		 cmp	 eax, ebp
  003fb	72 e4		 jb	 SHORT $LL99@huft_build

; 1246 :       for (j = i >> w; j < z; j += f)

  003fd	8b 7c 24 28	 mov	 edi, DWORD PTR _i$[esp+1492]
$LN6@huft_build:

; 1248 : 
; 1249 :       /* backwards increment the k-bit code i */
; 1250 :       for (j = 1 << (k - 1); i & j; j >>= 1)

  00401	8b 4c 24 30	 mov	 ecx, DWORD PTR tv1186[esp+1492]
  00405	b8 01 00 00 00	 mov	 eax, 1
  0040a	d3 e0		 shl	 eax, cl
  0040c	85 c7		 test	 eax, edi
  0040e	74 08		 je	 SHORT $LN3@huft_build
$LL5@huft_build:

; 1251 :         i ^= j;

  00410	33 f8		 xor	 edi, eax
  00412	d1 e8		 shr	 eax, 1
  00414	85 c7		 test	 eax, edi
  00416	75 f8		 jne	 SHORT $LL5@huft_build
$LN3@huft_build:

; 1252 :       i ^= j;
; 1253 : 
; 1254 :       /* backup over finished tables */
; 1255 :       while ((i & ((1 << w) - 1)) != x[h])

  00418	ba 01 00 00 00	 mov	 edx, 1
  0041d	8b cb		 mov	 ecx, ebx
  0041f	d3 e2		 shl	 edx, cl
  00421	33 f8		 xor	 edi, eax
  00423	89 7c 24 28	 mov	 DWORD PTR _i$[esp+1492], edi
  00427	4a		 dec	 edx
  00428	23 d7		 and	 edx, edi
  0042a	3b 94 b4 d0 00
	00 00		 cmp	 edx, DWORD PTR _x$[esp+esi*4+1492]
  00431	74 1d		 je	 SHORT $LN1@huft_build
$LL2@huft_build:

; 1256 :         w -= l[--h];            /* don't need to update q */

  00433	2b 9c b4 8c 00
	00 00		 sub	 ebx, DWORD PTR _lx$[esp+esi*4+1492]
  0043a	4e		 dec	 esi
  0043b	b8 01 00 00 00	 mov	 eax, 1
  00440	8b cb		 mov	 ecx, ebx
  00442	d3 e0		 shl	 eax, cl
  00444	48		 dec	 eax
  00445	23 c7		 and	 eax, edi
  00447	3b 84 b4 d0 00
	00 00		 cmp	 eax, DWORD PTR _x$[esp+esi*4+1492]
  0044e	75 e3		 jne	 SHORT $LL2@huft_build
$LN1@huft_build:

; 1176 :     while (a--)

  00450	83 7c 24 18 00	 cmp	 DWORD PTR _a$[esp+1492], 0
  00455	8b 4c 24 10	 mov	 ecx, DWORD PTR _k$[esp+1492]
  00459	0f 85 a1 fd ff
	ff		 jne	 $LL24@huft_build
  0045f	8b 44 24 2c	 mov	 eax, DWORD PTR _g$[esp+1492]
$LN102@huft_build:

; 1161 : 
; 1162 : 
; 1163 :   /* Generate the Huffman codes and for each, make the table entries */
; 1164 :   x[0] = i = 0;                 /* first Huffman code is zero */
; 1165 :   p = v;                        /* grab values in bit order */
; 1166 :   h = -1;                       /* no tables yet--level -1 */
; 1167 :   w = l[-1] = 0;                /* no bits decoded yet */
; 1168 :   u[0] = (struct huft *)NULL;   /* just to keep compilers happy */
; 1169 :   q = (struct huft *)NULL;      /* ditto */
; 1170 :   z = 0;                        /* ditto */
; 1171 : 
; 1172 :   /* go through the bit lengths (k already is bits in shortest code) */
; 1173 :   for (; k <= g; k++)

  00463	83 44 24 24 04	 add	 DWORD PTR tv1200[esp+1492], 4
  00468	ff 44 24 30	 inc	 DWORD PTR tv1186[esp+1492]
  0046c	41		 inc	 ecx
  0046d	3b c8		 cmp	 ecx, eax
  0046f	89 4c 24 10	 mov	 DWORD PTR _k$[esp+1492], ecx
  00473	0f 8e 69 fd ff
	ff		 jle	 $LL101@huft_build
$LN100@huft_build:

; 1257 :     }
; 1258 :   }
; 1259 : 
; 1260 : 
; 1261 :   /* return actual size of base table */
; 1262 :   *m = l[0];
; 1263 : 
; 1264 : 
; 1265 :   /* Return true (1) if we were given an incomplete table */
; 1266 :   return y != 0 && g != 1;

  00479	83 7c 24 44 00	 cmp	 DWORD PTR _y$[esp+1492], 0
  0047e	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR _lx$[esp+1496]
  00485	8b 94 24 f0 05
	00 00		 mov	 edx, DWORD PTR _m$[esp+1488]
  0048c	89 0a		 mov	 DWORD PTR [edx], ecx
  0048e	74 49		 je	 SHORT $LN59@huft_build
  00490	83 f8 01	 cmp	 eax, 1
  00493	74 44		 je	 SHORT $LN59@huft_build
  00495	5f		 pop	 edi
  00496	5e		 pop	 esi
  00497	5d		 pop	 ebp
  00498	b8 01 00 00 00	 mov	 eax, 1
  0049d	5b		 pop	 ebx

; 1267 : }

  0049e	81 c4 c4 05 00
	00		 add	 esp, 1476		; 000005c4H
  004a4	c3		 ret	 0
$LN83@huft_build:

; 1205 :         {
; 1206 :           if (h)

  004a5	85 f6		 test	 esi, esi
  004a7	74 20		 je	 SHORT $LN61@huft_build

; 1207 :             huft_free(u[0]);

  004a9	8b 84 24 14 01
	00 00		 mov	 eax, DWORD PTR _u$[esp+1492]
  004b0	85 c0		 test	 eax, eax
  004b2	74 15		 je	 SHORT $LN61@huft_build
$LL62@huft_build:
  004b4	8b 70 fc	 mov	 esi, DWORD PTR [eax-4]
  004b7	83 e8 08	 sub	 eax, 8
  004ba	50		 push	 eax
  004bb	e8 00 00 00 00	 call	 _free
  004c0	83 c4 04	 add	 esp, 4
  004c3	8b c6		 mov	 eax, esi
  004c5	85 f6		 test	 esi, esi
  004c7	75 eb		 jne	 SHORT $LL62@huft_build
$LN61@huft_build:
  004c9	5f		 pop	 edi
  004ca	5e		 pop	 esi
  004cb	5d		 pop	 ebp

; 1208 :           return 3;             /* not enough memory */

  004cc	b8 03 00 00 00	 mov	 eax, 3
  004d1	5b		 pop	 ebx

; 1267 : }

  004d2	81 c4 c4 05 00
	00		 add	 esp, 1476		; 000005c4H
  004d8	c3		 ret	 0
$LN59@huft_build:
  004d9	5f		 pop	 edi
  004da	5e		 pop	 esi
  004db	5d		 pop	 ebp

; 1257 :     }
; 1258 :   }
; 1259 : 
; 1260 : 
; 1261 :   /* return actual size of base table */
; 1262 :   *m = l[0];
; 1263 : 
; 1264 : 
; 1265 :   /* Return true (1) if we were given an incomplete table */
; 1266 :   return y != 0 && g != 1;

  004dc	33 c0		 xor	 eax, eax
  004de	5b		 pop	 ebx

; 1267 : }

  004df	81 c4 c4 05 00
	00		 add	 esp, 1476		; 000005c4H
  004e5	c3		 ret	 0
_huft_build ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _inflate_fixed
_TEXT	SEGMENT
_l$81274 = -1152					; size = 1152
_inflate_fixed PROC					; COMDAT

; 716  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec 80 04 00
	00		 sub	 esp, 1152		; 00000480H

; 717  :   /* if first time, set up tables for fixed blocks */
; 718  :   Trace((stderr, "\nliteral block"));
; 719  :   if (G.fixed_tl == (struct huft *)NULL)

  0000c	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR _G+16, 0
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	0f 85 4c 02 00
	00		 jne	 $LN1@inflate_fi

; 720  :   {
; 721  :     int i;                /* temporary variable */
; 722  :     unsigned l[288];      /* length list for huft_build */
; 723  : 
; 724  :     /* literal table */
; 725  :     for (i = 0; i < 144; i++)
; 726  :       l[i] = 8;
; 727  :     for (; i < 256; i++)
; 728  :       l[i] = 9;
; 729  :     for (; i < 280; i++)
; 730  :       l[i] = 7;
; 731  :     for (; i < 288; i++)          /* make a complete, but wrong code set */
; 732  :       l[i] = 8;
; 733  :     G.fixed_bl = 7;
; 734  :     if ((i = huft_build(__G__ l, 288, 257, cplens, cplext,
; 735  :                         &G.fixed_tl, &G.fixed_bl)) != 0)

  0001b	68 18 00 00 00	 push	 OFFSET _G+24
  00020	b8 08 00 00 00	 mov	 eax, 8
  00025	b9 90 00 00 00	 mov	 ecx, 144		; 00000090H
  0002a	8d 7c 24 0c	 lea	 edi, DWORD PTR _l$81274[esp+1164]
  0002e	f3 ab		 rep stosd
  00030	68 10 00 00 00	 push	 OFFSET _G+16
  00035	b8 09 00 00 00	 mov	 eax, 9
  0003a	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  0003f	8d bc 24 50 02
	00 00		 lea	 edi, DWORD PTR _l$81274[esp+1744]
  00046	f3 ab		 rep stosd
  00048	b8 07 00 00 00	 mov	 eax, 7
  0004d	68 00 00 00 00	 push	 OFFSET _cplext
  00052	89 84 24 14 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2196], eax
  00059	89 84 24 18 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2200], eax
  00060	89 84 24 1c 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2204], eax
  00067	89 84 24 20 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2208], eax
  0006e	89 84 24 24 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2212], eax
  00075	89 84 24 28 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2216], eax
  0007c	89 84 24 2c 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2220], eax
  00083	89 84 24 30 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2224], eax
  0008a	89 84 24 34 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2228], eax
  00091	89 84 24 38 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2232], eax
  00098	89 84 24 3c 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2236], eax
  0009f	89 84 24 40 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2240], eax
  000a6	89 84 24 44 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2244], eax
  000ad	89 84 24 48 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2248], eax
  000b4	89 84 24 4c 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2252], eax
  000bb	89 84 24 50 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2256], eax
  000c2	89 84 24 54 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2260], eax
  000c9	89 84 24 58 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2264], eax
  000d0	89 84 24 5c 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2268], eax
  000d7	89 84 24 60 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2272], eax
  000de	89 84 24 64 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2276], eax
  000e5	89 84 24 68 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2280], eax
  000ec	89 84 24 6c 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2284], eax
  000f3	89 84 24 70 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2288], eax
  000fa	b8 08 00 00 00	 mov	 eax, 8
  000ff	68 00 00 00 00	 push	 OFFSET _cplens
  00104	68 01 01 00 00	 push	 257			; 00000101H
  00109	89 84 24 7c 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2300], eax
  00110	89 84 24 80 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2304], eax
  00117	89 84 24 84 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2308], eax
  0011e	89 84 24 88 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2312], eax
  00125	89 84 24 8c 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2316], eax
  0012c	89 84 24 90 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2320], eax
  00133	89 84 24 94 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2324], eax
  0013a	89 84 24 98 04
	00 00		 mov	 DWORD PTR _l$81274[esp+2328], eax
  00141	8d 44 24 1c	 lea	 eax, DWORD PTR _l$81274[esp+1180]
  00145	68 20 01 00 00	 push	 288			; 00000120H
  0014a	50		 push	 eax
  0014b	c7 05 18 00 00
	00 07 00 00 00	 mov	 DWORD PTR _G+24, 7
  00155	e8 00 00 00 00	 call	 _huft_build
  0015a	83 c4 1c	 add	 esp, 28			; 0000001cH
  0015d	85 c0		 test	 eax, eax
  0015f	74 10		 je	 SHORT $LN5@inflate_fi

; 736  :     {
; 737  :       G.fixed_tl = (struct huft *)NULL;

  00161	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR _G+16, 0

; 757  : }

  0016b	5f		 pop	 edi
  0016c	5e		 pop	 esi
  0016d	8b e5		 mov	 esp, ebp
  0016f	5d		 pop	 ebp
  00170	c3		 ret	 0
$LN5@inflate_fi:

; 738  :       return i;
; 739  :     }
; 740  : 
; 741  :     /* distance table */
; 742  :     for (i = 0; i < 30; i++)      /* make an incomplete code set */
; 743  :       l[i] = 5;

  00171	b8 05 00 00 00	 mov	 eax, 5

; 744  :     G.fixed_bd = 5;
; 745  :     if ((i = huft_build(__G__ l, 30, 0, cpdist, cpdext,
; 746  :                         &G.fixed_td, &G.fixed_bd)) > 1)

  00176	68 1c 00 00 00	 push	 OFFSET _G+28
  0017b	68 14 00 00 00	 push	 OFFSET _G+20
  00180	68 00 00 00 00	 push	 OFFSET _cpdext
  00185	68 00 00 00 00	 push	 OFFSET _cpdist
  0018a	6a 00		 push	 0
  0018c	8d 4c 24 1c	 lea	 ecx, DWORD PTR _l$81274[esp+1180]
  00190	6a 1e		 push	 30			; 0000001eH
  00192	51		 push	 ecx
  00193	89 44 24 24	 mov	 DWORD PTR _l$81274[esp+1188], eax
  00197	89 44 24 28	 mov	 DWORD PTR _l$81274[esp+1192], eax
  0019b	89 44 24 2c	 mov	 DWORD PTR _l$81274[esp+1196], eax
  0019f	89 44 24 30	 mov	 DWORD PTR _l$81274[esp+1200], eax
  001a3	89 44 24 34	 mov	 DWORD PTR _l$81274[esp+1204], eax
  001a7	89 44 24 38	 mov	 DWORD PTR _l$81274[esp+1208], eax
  001ab	89 44 24 3c	 mov	 DWORD PTR _l$81274[esp+1212], eax
  001af	89 44 24 40	 mov	 DWORD PTR _l$81274[esp+1216], eax
  001b3	89 44 24 44	 mov	 DWORD PTR _l$81274[esp+1220], eax
  001b7	89 44 24 48	 mov	 DWORD PTR _l$81274[esp+1224], eax
  001bb	89 44 24 4c	 mov	 DWORD PTR _l$81274[esp+1228], eax
  001bf	89 44 24 50	 mov	 DWORD PTR _l$81274[esp+1232], eax
  001c3	89 44 24 54	 mov	 DWORD PTR _l$81274[esp+1236], eax
  001c7	89 44 24 58	 mov	 DWORD PTR _l$81274[esp+1240], eax
  001cb	89 44 24 5c	 mov	 DWORD PTR _l$81274[esp+1244], eax
  001cf	89 44 24 60	 mov	 DWORD PTR _l$81274[esp+1248], eax
  001d3	89 44 24 64	 mov	 DWORD PTR _l$81274[esp+1252], eax
  001d7	89 44 24 68	 mov	 DWORD PTR _l$81274[esp+1256], eax
  001db	89 44 24 6c	 mov	 DWORD PTR _l$81274[esp+1260], eax
  001df	89 44 24 70	 mov	 DWORD PTR _l$81274[esp+1264], eax
  001e3	89 44 24 74	 mov	 DWORD PTR _l$81274[esp+1268], eax
  001e7	89 44 24 78	 mov	 DWORD PTR _l$81274[esp+1272], eax
  001eb	89 44 24 7c	 mov	 DWORD PTR _l$81274[esp+1276], eax
  001ef	89 84 24 80 00
	00 00		 mov	 DWORD PTR _l$81274[esp+1280], eax
  001f6	89 84 24 84 00
	00 00		 mov	 DWORD PTR _l$81274[esp+1284], eax
  001fd	89 84 24 88 00
	00 00		 mov	 DWORD PTR _l$81274[esp+1288], eax
  00204	89 84 24 8c 00
	00 00		 mov	 DWORD PTR _l$81274[esp+1292], eax
  0020b	89 84 24 90 00
	00 00		 mov	 DWORD PTR _l$81274[esp+1296], eax
  00212	89 84 24 94 00
	00 00		 mov	 DWORD PTR _l$81274[esp+1300], eax
  00219	89 84 24 98 00
	00 00		 mov	 DWORD PTR _l$81274[esp+1304], eax
  00220	a3 1c 00 00 00	 mov	 DWORD PTR _G+28, eax
  00225	e8 00 00 00 00	 call	 _huft_build
  0022a	8b f8		 mov	 edi, eax
  0022c	83 c4 1c	 add	 esp, 28			; 0000001cH
  0022f	83 ff 01	 cmp	 edi, 1
  00232	7e 33		 jle	 SHORT $LN1@inflate_fi

; 747  :     {
; 748  :       huft_free(G.fixed_tl);

  00234	a1 10 00 00 00	 mov	 eax, DWORD PTR _G+16
  00239	85 c0		 test	 eax, eax
  0023b	74 18		 je	 SHORT $LN21@inflate_fi
  0023d	8d 49 00	 npad	 3
$LL22@inflate_fi:
  00240	8b 70 fc	 mov	 esi, DWORD PTR [eax-4]
  00243	83 e8 08	 sub	 eax, 8
  00246	50		 push	 eax
  00247	e8 00 00 00 00	 call	 _free
  0024c	83 c4 04	 add	 esp, 4
  0024f	8b c6		 mov	 eax, esi
  00251	85 f6		 test	 esi, esi
  00253	75 eb		 jne	 SHORT $LL22@inflate_fi
$LN21@inflate_fi:

; 749  :       G.fixed_tl = (struct huft *)NULL;

  00255	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR _G+16, 0

; 750  :       return i;

  0025f	8b c7		 mov	 eax, edi

; 757  : }

  00261	5f		 pop	 edi
  00262	5e		 pop	 esi
  00263	8b e5		 mov	 esp, ebp
  00265	5d		 pop	 ebp
  00266	c3		 ret	 0
$LN1@inflate_fi:

; 751  :     }
; 752  :   }
; 753  : 
; 754  :   /* decompress until an end-of-block code */
; 755  :   return inflate_codes(__G__ G.fixed_tl, G.fixed_td,
; 756  :                              G.fixed_bl, G.fixed_bd) != 0;

  00267	8b 15 1c 00 00
	00		 mov	 edx, DWORD PTR _G+28
  0026d	a1 18 00 00 00	 mov	 eax, DWORD PTR _G+24
  00272	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR _G+20
  00278	52		 push	 edx
  00279	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR _G+16
  0027f	50		 push	 eax
  00280	51		 push	 ecx
  00281	52		 push	 edx
  00282	e8 00 00 00 00	 call	 _inflate_codes
  00287	83 c4 10	 add	 esp, 16			; 00000010H
  0028a	f7 d8		 neg	 eax
  0028c	1b c0		 sbb	 eax, eax

; 757  : }

  0028e	5f		 pop	 edi
  0028f	f7 d8		 neg	 eax
  00291	5e		 pop	 esi
  00292	8b e5		 mov	 esp, ebp
  00294	5d		 pop	 ebp
  00295	c3		 ret	 0
_inflate_fixed ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@CMHGGAOF@?$CIincomplete?5d?9tree?$CJ?5?5?$AA@ ; `string'
PUBLIC	??_C@_0BG@DPKBCABB@?$CIincomplete?5l?9tree?$CJ?5?5?$AA@ ; `string'
EXTRN	_fprintf:PROC
EXTRN	___iob_func:PROC
;	COMDAT ??_C@_0BG@CMHGGAOF@?$CIincomplete?5d?9tree?$CJ?5?5?$AA@
CONST	SEGMENT
??_C@_0BG@CMHGGAOF@?$CIincomplete?5d?9tree?$CJ?5?5?$AA@ DB '(incomplete d'
	DB	'-tree)  ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DPKBCABB@?$CIincomplete?5l?9tree?$CJ?5?5?$AA@
CONST	SEGMENT
??_C@_0BG@DPKBCABB@?$CIincomplete?5l?9tree?$CJ?5?5?$AA@ DB '(incomplete l'
	DB	'-tree)  ', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _inflate_dynamic
_TEXT	SEGMENT
_tl$ = -1296						; size = 4
_bd$ = -1292						; size = 4
_nl$ = -1292						; size = 4
_bl$ = -1288						; size = 4
_n$ = -1284						; size = 4
_l$ = -1280						; size = 4
_nd$ = -1276						; size = 4
_td$ = -1272						; size = 4
_m$ = -1268						; size = 4
_ll$ = -1264						; size = 1264
_inflate_dynamic PROC					; COMDAT

; 764  : {

  00000	81 ec 10 05 00
	00		 sub	 esp, 1296		; 00000510H
  00006	53		 push	 ebx

; 765  :   int i;                /* temporary variables */
; 766  :   unsigned j;
; 767  :   unsigned l;           /* last length */
; 768  :   unsigned m;           /* mask for bit lengths table */
; 769  :   unsigned n;           /* number of lengths to get */
; 770  :   struct huft *tl;      /* literal/length code table */
; 771  :   struct huft *td;      /* distance code table */
; 772  :   int bl;               /* lookup bits for tl */
; 773  :   int bd;               /* lookup bits for td */
; 774  :   unsigned nb;          /* number of bit length codes */
; 775  :   unsigned nl;          /* number of literal/length codes */
; 776  :   unsigned nd;          /* number of distance codes */
; 777  : #ifdef PKZIP_BUG_WORKAROUND
; 778  :   unsigned ll[288+32]; /* literal/length and distance code lengths */
; 779  : #else
; 780  :   unsigned ll[286+30]; /* literal/length and distance code lengths */
; 781  : #endif
; 782  :   register ulg b;       /* bit buffer */
; 783  :   register unsigned k;  /* number of bits in bit buffer */
; 784  : 
; 785  : 
; 786  :   /* make local bit buffer */
; 787  :   Trace((stderr, "\ndynamic block"));
; 788  :   b = G.bb;

  00007	8b 1d 28 00 00
	00		 mov	 ebx, DWORD PTR _G+40
  0000d	55		 push	 ebp

; 789  :   k = G.bk;
; 790  : 
; 791  : 
; 792  :   /* read in table lengths */
; 793  :   NEEDBITS(5)

  0000e	8b 2d 08 00 00
	00		 mov	 ebp, DWORD PTR _G+8
  00014	56		 push	 esi
  00015	8b 35 20 00 00
	00		 mov	 esi, DWORD PTR _G+32
  0001b	57		 push	 edi
  0001c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _G
  00022	83 fe 05	 cmp	 esi, 5
  00025	73 32		 jae	 SHORT $LN58@inflate_dy
$LL59@inflate_dy:
  00027	8b c5		 mov	 eax, ebp
  00029	4d		 dec	 ebp
  0002a	89 2d 08 00 00
	00		 mov	 DWORD PTR _G+8, ebp
  00030	85 c0		 test	 eax, eax
  00032	0f 8c 9a 04 00
	00		 jl	 $LN49@inflate_dy
  00038	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0003b	47		 inc	 edi
  0003c	89 3d 00 00 00
	00		 mov	 DWORD PTR _G, edi
  00042	83 f8 ff	 cmp	 eax, -1
  00045	0f 84 87 04 00
	00		 je	 $LN49@inflate_dy
  0004b	8b ce		 mov	 ecx, esi
  0004d	d3 e0		 shl	 eax, cl
  0004f	83 c6 08	 add	 esi, 8
  00052	0b d8		 or	 ebx, eax
  00054	83 fe 05	 cmp	 esi, 5
  00057	72 ce		 jb	 SHORT $LL59@inflate_dy
$LN58@inflate_dy:

; 794  :   nl = 257 + ((unsigned)b & 0x1f);      /* number of literal/length codes */

  00059	8b c3		 mov	 eax, ebx
  0005b	83 e0 1f	 and	 eax, 31			; 0000001fH
  0005e	05 01 01 00 00	 add	 eax, 257		; 00000101H

; 795  :   DUMPBITS(5)

  00063	83 ee 05	 sub	 esi, 5
  00066	c1 eb 05	 shr	 ebx, 5
  00069	89 44 24 14	 mov	 DWORD PTR _nl$[esp+1312], eax

; 796  :   NEEDBITS(5)

  0006d	83 fe 05	 cmp	 esi, 5
  00070	73 32		 jae	 SHORT $LN55@inflate_dy
$LL56@inflate_dy:
  00072	8b cd		 mov	 ecx, ebp
  00074	4d		 dec	 ebp
  00075	89 2d 08 00 00
	00		 mov	 DWORD PTR _G+8, ebp
  0007b	85 c9		 test	 ecx, ecx
  0007d	0f 8c 4f 04 00
	00		 jl	 $LN49@inflate_dy
  00083	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00086	47		 inc	 edi
  00087	89 3d 00 00 00
	00		 mov	 DWORD PTR _G, edi
  0008d	83 f8 ff	 cmp	 eax, -1
  00090	0f 84 3c 04 00
	00		 je	 $LN49@inflate_dy
  00096	8b ce		 mov	 ecx, esi
  00098	d3 e0		 shl	 eax, cl
  0009a	83 c6 08	 add	 esi, 8
  0009d	0b d8		 or	 ebx, eax
  0009f	83 fe 05	 cmp	 esi, 5
  000a2	72 ce		 jb	 SHORT $LL56@inflate_dy
$LN55@inflate_dy:

; 797  :   nd = 1 + ((unsigned)b & 0x1f);        /* number of distance codes */

  000a4	8b d3		 mov	 edx, ebx
  000a6	83 e2 1f	 and	 edx, 31			; 0000001fH
  000a9	42		 inc	 edx

; 798  :   DUMPBITS(5)

  000aa	83 ee 05	 sub	 esi, 5
  000ad	c1 eb 05	 shr	 ebx, 5
  000b0	89 54 24 24	 mov	 DWORD PTR _nd$[esp+1312], edx

; 799  :   NEEDBITS(4)

  000b4	83 fe 04	 cmp	 esi, 4
  000b7	73 39		 jae	 SHORT $LN52@inflate_dy
  000b9	8d a4 24 00 00
	00 00		 npad	 7
$LL53@inflate_dy:
  000c0	8b c5		 mov	 eax, ebp
  000c2	4d		 dec	 ebp
  000c3	89 2d 08 00 00
	00		 mov	 DWORD PTR _G+8, ebp
  000c9	85 c0		 test	 eax, eax
  000cb	0f 8c 01 04 00
	00		 jl	 $LN49@inflate_dy
  000d1	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  000d4	47		 inc	 edi
  000d5	89 3d 00 00 00
	00		 mov	 DWORD PTR _G, edi
  000db	83 f8 ff	 cmp	 eax, -1
  000de	0f 84 ee 03 00
	00		 je	 $LN49@inflate_dy
  000e4	8b ce		 mov	 ecx, esi
  000e6	d3 e0		 shl	 eax, cl
  000e8	83 c6 08	 add	 esi, 8
  000eb	0b d8		 or	 ebx, eax
  000ed	83 fe 04	 cmp	 esi, 4
  000f0	72 ce		 jb	 SHORT $LL53@inflate_dy
$LN52@inflate_dy:

; 800  :   nb = 4 + ((unsigned)b & 0xf);         /* number of bit length codes */

  000f2	8b eb		 mov	 ebp, ebx
  000f4	83 e5 0f	 and	 ebp, 15			; 0000000fH
  000f7	83 c5 04	 add	 ebp, 4

; 801  :   DUMPBITS(4)

  000fa	c1 eb 04	 shr	 ebx, 4
  000fd	83 ee 04	 sub	 esi, 4

; 802  : #ifdef PKZIP_BUG_WORKAROUND
; 803  :   if (nl > 288 || nd > 32)
; 804  : #else
; 805  :   if (nl > 286 || nd > 30)

  00100	81 7c 24 14 1e
	01 00 00	 cmp	 DWORD PTR _nl$[esp+1312], 286 ; 0000011eH
  00108	0f 87 c4 03 00
	00		 ja	 $LN49@inflate_dy
  0010e	83 fa 1e	 cmp	 edx, 30			; 0000001eH
  00111	0f 87 bb 03 00
	00		 ja	 $LN49@inflate_dy

; 806  : #endif
; 807  :     return 1;                   /* bad lengths */
; 808  : 
; 809  : 
; 810  :   /* read in bit-length-code lengths */
; 811  :   for (j = 0; j < nb; j++)

  00117	33 d2		 xor	 edx, edx
  00119	85 ed		 test	 ebp, ebp
  0011b	76 5e		 jbe	 SHORT $LN152@inflate_dy
  0011d	8d 49 00	 npad	 3
$LL48@inflate_dy:

; 812  :   {
; 813  :     NEEDBITS(3)

  00120	83 fe 03	 cmp	 esi, 3
  00123	73 36		 jae	 SHORT $LN44@inflate_dy
$LL45@inflate_dy:
  00125	a1 08 00 00 00	 mov	 eax, DWORD PTR _G+8
  0012a	8b c8		 mov	 ecx, eax
  0012c	48		 dec	 eax
  0012d	a3 08 00 00 00	 mov	 DWORD PTR _G+8, eax
  00132	85 c9		 test	 ecx, ecx
  00134	0f 8c 98 03 00
	00		 jl	 $LN49@inflate_dy
  0013a	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0013d	47		 inc	 edi
  0013e	89 3d 00 00 00
	00		 mov	 DWORD PTR _G, edi
  00144	83 f8 ff	 cmp	 eax, -1
  00147	0f 84 85 03 00
	00		 je	 $LN49@inflate_dy
  0014d	8b ce		 mov	 ecx, esi
  0014f	d3 e0		 shl	 eax, cl
  00151	83 c6 08	 add	 esi, 8
  00154	0b d8		 or	 ebx, eax
  00156	83 fe 03	 cmp	 esi, 3
  00159	72 ca		 jb	 SHORT $LL45@inflate_dy
$LN44@inflate_dy:

; 814  :     ll[border[j]] = (unsigned)b & 7;

  0015b	8b 0c 95 00 00
	00 00		 mov	 ecx, DWORD PTR _border[edx*4]
  00162	8b c3		 mov	 eax, ebx
  00164	83 e0 07	 and	 eax, 7
  00167	42		 inc	 edx

; 815  :     DUMPBITS(3)

  00168	c1 eb 03	 shr	 ebx, 3
  0016b	83 ee 03	 sub	 esi, 3
  0016e	89 44 8c 30	 mov	 DWORD PTR _ll$[esp+ecx*4+1312], eax
  00172	3b d5		 cmp	 edx, ebp
  00174	72 aa		 jb	 SHORT $LL48@inflate_dy

; 816  :   }
; 817  :   for (; j < 19; j++)

  00176	83 fa 13	 cmp	 edx, 19			; 00000013H
  00179	73 16		 jae	 SHORT $LN40@inflate_dy
$LN152@inflate_dy:
  0017b	33 c0		 xor	 eax, eax
  0017d	8d 49 00	 npad	 3
$LL138@inflate_dy:

; 818  :     ll[border[j]] = 0;

  00180	8b 0c 95 00 00
	00 00		 mov	 ecx, DWORD PTR _border[edx*4]
  00187	42		 inc	 edx
  00188	89 44 8c 30	 mov	 DWORD PTR _ll$[esp+ecx*4+1312], eax
  0018c	83 fa 13	 cmp	 edx, 19			; 00000013H
  0018f	72 ef		 jb	 SHORT $LL138@inflate_dy
$LN40@inflate_dy:

; 819  : 
; 820  : 
; 821  :   /* build decoding table for trees--single level, 7 bit lookup */
; 822  :   bl = 7;
; 823  :   i = huft_build(__G__ ll, 19, 19, NULL, NULL, &tl, &bl);

  00191	8d 54 24 18	 lea	 edx, DWORD PTR _bl$[esp+1312]
  00195	52		 push	 edx
  00196	8d 44 24 14	 lea	 eax, DWORD PTR _tl$[esp+1316]
  0019a	50		 push	 eax
  0019b	6a 00		 push	 0
  0019d	6a 00		 push	 0
  0019f	6a 13		 push	 19			; 00000013H
  001a1	8d 4c 24 44	 lea	 ecx, DWORD PTR _ll$[esp+1332]
  001a5	6a 13		 push	 19			; 00000013H
  001a7	51		 push	 ecx
  001a8	c7 44 24 34 07
	00 00 00	 mov	 DWORD PTR _bl$[esp+1340], 7
  001b0	e8 00 00 00 00	 call	 _huft_build

; 824  :   if (bl == 0)                        /* no bit lengths */

  001b5	8b 4c 24 34	 mov	 ecx, DWORD PTR _bl$[esp+1340]
  001b9	83 c4 1c	 add	 esp, 28			; 0000001cH
  001bc	8b f8		 mov	 edi, eax
  001be	85 c9		 test	 ecx, ecx
  001c0	75 1d		 jne	 SHORT $LN39@inflate_dy

; 829  :       huft_free(tl);

  001c2	8b 54 24 10	 mov	 edx, DWORD PTR _tl$[esp+1312]
  001c6	52		 push	 edx
  001c7	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
  001ca	e8 00 00 00 00	 call	 _huft_free
  001cf	83 c4 04	 add	 esp, 4

; 830  :     return i;                   /* incomplete code set */

  001d2	8b c7		 mov	 eax, edi
  001d4	5f		 pop	 edi
  001d5	5e		 pop	 esi
  001d6	5d		 pop	 ebp
  001d7	5b		 pop	 ebx

; 938  : }

  001d8	81 c4 10 05 00
	00		 add	 esp, 1296		; 00000510H
  001de	c3		 ret	 0
$LN39@inflate_dy:

; 825  :     i = 1;
; 826  :   if (i)

  001df	85 ff		 test	 edi, edi
  001e1	74 1f		 je	 SHORT $LN38@inflate_dy

; 827  :   {
; 828  :     if (i == 1)

  001e3	83 ff 01	 cmp	 edi, 1
  001e6	75 0d		 jne	 SHORT $LN37@inflate_dy

; 829  :       huft_free(tl);

  001e8	8b 54 24 10	 mov	 edx, DWORD PTR _tl$[esp+1312]
  001ec	52		 push	 edx
  001ed	e8 00 00 00 00	 call	 _huft_free
  001f2	83 c4 04	 add	 esp, 4
$LN37@inflate_dy:

; 830  :     return i;                   /* incomplete code set */

  001f5	8b c7		 mov	 eax, edi
  001f7	5f		 pop	 edi
  001f8	5e		 pop	 esi
  001f9	5d		 pop	 ebp
  001fa	5b		 pop	 ebx

; 938  : }

  001fb	81 c4 10 05 00
	00		 add	 esp, 1296		; 00000510H
  00201	c3		 ret	 0
$LN38@inflate_dy:

; 831  :   }
; 832  : 
; 833  : 
; 834  :   /* read in literal and distance code lengths */
; 835  :   n = nl + nd;

  00202	8b 44 24 14	 mov	 eax, DWORD PTR _nl$[esp+1312]
  00206	8b 54 24 24	 mov	 edx, DWORD PTR _nd$[esp+1312]

; 836  :   m = mask_bits[bl];

  0020a	0f b7 0c 4d 00
	00 00 00	 movzx	 ecx, WORD PTR _mask_bits[ecx*2]
  00212	03 c2		 add	 eax, edx

; 837  :   i = l = 0;

  00214	33 ff		 xor	 edi, edi
  00216	89 44 24 1c	 mov	 DWORD PTR _n$[esp+1312], eax
  0021a	89 4c 24 2c	 mov	 DWORD PTR _m$[esp+1312], ecx
  0021e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _l$[esp+1312], 0

; 838  :   while ((unsigned)i < n)

  00226	85 c0		 test	 eax, eax
  00228	0f 86 b4 01 00
	00		 jbe	 $LN153@inflate_dy
  0022e	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR _G
$LL36@inflate_dy:

; 839  :   {
; 840  :     NEEDBITS((unsigned)bl)

  00234	8b 44 24 18	 mov	 eax, DWORD PTR _bl$[esp+1312]
  00238	3b f0		 cmp	 esi, eax
  0023a	73 3c		 jae	 SHORT $LN159@inflate_dy
  0023c	8d 64 24 00	 npad	 4
$LL34@inflate_dy:
  00240	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR _G+8
  00246	8b d1		 mov	 edx, ecx
  00248	49		 dec	 ecx
  00249	89 0d 08 00 00
	00		 mov	 DWORD PTR _G+8, ecx
  0024f	85 d2		 test	 edx, edx
  00251	0f 8c 7b 02 00
	00		 jl	 $LN49@inflate_dy
  00257	0f b6 55 00	 movzx	 edx, BYTE PTR [ebp]
  0025b	45		 inc	 ebp
  0025c	89 2d 00 00 00
	00		 mov	 DWORD PTR _G, ebp
  00262	83 fa ff	 cmp	 edx, -1
  00265	0f 84 67 02 00
	00		 je	 $LN49@inflate_dy
  0026b	8b ce		 mov	 ecx, esi
  0026d	d3 e2		 shl	 edx, cl
  0026f	83 c6 08	 add	 esi, 8
  00272	0b da		 or	 ebx, edx
  00274	3b f0		 cmp	 esi, eax
  00276	72 c8		 jb	 SHORT $LL34@inflate_dy
$LN159@inflate_dy:

; 841  :     j = (td = tl + ((unsigned)b & m))->b;

  00278	8b 44 24 2c	 mov	 eax, DWORD PTR _m$[esp+1312]
  0027c	8b 4c 24 10	 mov	 ecx, DWORD PTR _tl$[esp+1312]
  00280	23 c3		 and	 eax, ebx
  00282	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00285	0f b6 0a	 movzx	 ecx, BYTE PTR [edx]

; 842  :     DUMPBITS(j)

  00288	d3 eb		 shr	 ebx, cl
  0028a	2b f1		 sub	 esi, ecx

; 843  :     j = td->v.n;

  0028c	0f b7 4a 04	 movzx	 ecx, WORD PTR [edx+4]
  00290	89 54 24 28	 mov	 DWORD PTR _td$[esp+1312], edx

; 844  :     if (j < 16)                 /* length of code in bits (0..15) */

  00294	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00297	73 0e		 jae	 SHORT $LN162@inflate_dy

; 845  :       ll[i++] = l = j;          /* save last length in l */

  00299	89 4c bc 30	 mov	 DWORD PTR _ll$[esp+edi*4+1312], ecx
  0029d	89 4c 24 20	 mov	 DWORD PTR _l$[esp+1312], ecx
  002a1	47		 inc	 edi
  002a2	e9 31 01 00 00	 jmp	 $LN156@inflate_dy
$LN162@inflate_dy:

; 846  :     else if (j == 16)           /* repeat last length 3 to 6 times */

  002a7	75 70		 jne	 SHORT $LN29@inflate_dy

; 847  :     {
; 848  :       NEEDBITS(2)

  002a9	83 fe 02	 cmp	 esi, 2
  002ac	73 37		 jae	 SHORT $LN27@inflate_dy
  002ae	a1 08 00 00 00	 mov	 eax, DWORD PTR _G+8
$LL28@inflate_dy:
  002b3	8b d0		 mov	 edx, eax
  002b5	48		 dec	 eax
  002b6	a3 08 00 00 00	 mov	 DWORD PTR _G+8, eax
  002bb	85 d2		 test	 edx, edx
  002bd	0f 8c 0f 02 00
	00		 jl	 $LN49@inflate_dy
  002c3	0f b6 55 00	 movzx	 edx, BYTE PTR [ebp]
  002c7	45		 inc	 ebp
  002c8	89 2d 00 00 00
	00		 mov	 DWORD PTR _G, ebp
  002ce	83 fa ff	 cmp	 edx, -1
  002d1	0f 84 fb 01 00
	00		 je	 $LN49@inflate_dy
  002d7	8b ce		 mov	 ecx, esi
  002d9	d3 e2		 shl	 edx, cl
  002db	83 c6 08	 add	 esi, 8
  002de	0b da		 or	 ebx, edx
  002e0	83 fe 02	 cmp	 esi, 2
  002e3	72 ce		 jb	 SHORT $LL28@inflate_dy
$LN27@inflate_dy:

; 849  :       j = 3 + ((unsigned)b & 3);

  002e5	8b cb		 mov	 ecx, ebx
  002e7	83 e1 03	 and	 ecx, 3
  002ea	83 c1 03	 add	 ecx, 3

; 850  :       DUMPBITS(2)
; 851  :       if ((unsigned)i + j > n)

  002ed	8d 14 0f	 lea	 edx, DWORD PTR [edi+ecx]
  002f0	c1 eb 02	 shr	 ebx, 2
  002f3	83 ee 02	 sub	 esi, 2
  002f6	3b 54 24 1c	 cmp	 edx, DWORD PTR _n$[esp+1312]
  002fa	0f 87 d2 01 00
	00		 ja	 $LN49@inflate_dy

; 852  :         return 1;
; 853  :       while (j--)

  00300	85 c9		 test	 ecx, ecx
  00302	0f 84 d0 00 00
	00		 je	 $LN156@inflate_dy
  00308	8b 44 24 20	 mov	 eax, DWORD PTR _l$[esp+1312]
  0030c	8d 7c bc 30	 lea	 edi, DWORD PTR _ll$[esp+edi*4+1312]
  00310	f3 ab		 rep stosd
  00312	8b fa		 mov	 edi, edx

; 854  :         ll[i++] = l;
; 855  :     }
; 856  :     else if (j == 17)           /* 3 to 10 zero length codes */

  00314	e9 bf 00 00 00	 jmp	 $LN156@inflate_dy
$LN29@inflate_dy:
  00319	83 f9 11	 cmp	 ecx, 17			; 00000011H
  0031c	75 4c		 jne	 SHORT $LN90@inflate_dy

; 857  :     {
; 858  :       NEEDBITS(3)

  0031e	83 fe 03	 cmp	 esi, 3
  00321	73 37		 jae	 SHORT $LN161@inflate_dy
$LL20@inflate_dy:
  00323	a1 08 00 00 00	 mov	 eax, DWORD PTR _G+8
  00328	8b c8		 mov	 ecx, eax
  0032a	48		 dec	 eax
  0032b	a3 08 00 00 00	 mov	 DWORD PTR _G+8, eax
  00330	85 c9		 test	 ecx, ecx
  00332	0f 8c 9a 01 00
	00		 jl	 $LN49@inflate_dy
  00338	0f b6 45 00	 movzx	 eax, BYTE PTR [ebp]
  0033c	45		 inc	 ebp
  0033d	89 2d 00 00 00
	00		 mov	 DWORD PTR _G, ebp
  00343	83 f8 ff	 cmp	 eax, -1
  00346	0f 84 86 01 00
	00		 je	 $LN49@inflate_dy
  0034c	8b ce		 mov	 ecx, esi
  0034e	d3 e0		 shl	 eax, cl
  00350	83 c6 08	 add	 esi, 8
  00353	0b d8		 or	 ebx, eax
  00355	83 fe 03	 cmp	 esi, 3
  00358	72 c9		 jb	 SHORT $LL20@inflate_dy
$LN161@inflate_dy:

; 859  :       j = 3 + ((unsigned)b & 7);

  0035a	8b cb		 mov	 ecx, ebx
  0035c	83 e1 07	 and	 ecx, 7
  0035f	83 c1 03	 add	 ecx, 3

; 860  :       DUMPBITS(3)

  00362	c1 eb 03	 shr	 ebx, 3
  00365	83 ee 03	 sub	 esi, 3

; 861  :       if ((unsigned)i + j > n)
; 862  :         return 1;
; 863  :       while (j--)
; 864  :         ll[i++] = 0;
; 865  :       l = 0;
; 866  :     }
; 867  :     else                        /* j == 18: 11 to 138 zero length codes */

  00368	eb 4b		 jmp	 SHORT $LN167@inflate_dy
$LN90@inflate_dy:

; 868  :     {
; 869  :       NEEDBITS(7)

  0036a	83 fe 07	 cmp	 esi, 7
  0036d	73 38		 jae	 SHORT $LN12@inflate_dy
  0036f	90		 npad	 1
$LL13@inflate_dy:
  00370	a1 08 00 00 00	 mov	 eax, DWORD PTR _G+8
  00375	8b d0		 mov	 edx, eax
  00377	48		 dec	 eax
  00378	a3 08 00 00 00	 mov	 DWORD PTR _G+8, eax
  0037d	85 d2		 test	 edx, edx
  0037f	0f 8c 4d 01 00
	00		 jl	 $LN49@inflate_dy
  00385	0f b6 45 00	 movzx	 eax, BYTE PTR [ebp]
  00389	45		 inc	 ebp
  0038a	89 2d 00 00 00
	00		 mov	 DWORD PTR _G, ebp
  00390	83 f8 ff	 cmp	 eax, -1
  00393	0f 84 39 01 00
	00		 je	 $LN49@inflate_dy
  00399	8b ce		 mov	 ecx, esi
  0039b	d3 e0		 shl	 eax, cl
  0039d	83 c6 08	 add	 esi, 8
  003a0	0b d8		 or	 ebx, eax
  003a2	83 fe 07	 cmp	 esi, 7
  003a5	72 c9		 jb	 SHORT $LL13@inflate_dy
$LN12@inflate_dy:

; 870  :       j = 11 + ((unsigned)b & 0x7f);

  003a7	8b cb		 mov	 ecx, ebx
  003a9	83 e1 7f	 and	 ecx, 127		; 0000007fH
  003ac	83 c1 0b	 add	 ecx, 11			; 0000000bH

; 871  :       DUMPBITS(7)

  003af	c1 eb 07	 shr	 ebx, 7
  003b2	83 ee 07	 sub	 esi, 7
$LN167@inflate_dy:

; 872  :       if ((unsigned)i + j > n)

  003b5	8d 14 0f	 lea	 edx, DWORD PTR [edi+ecx]
  003b8	3b 54 24 1c	 cmp	 edx, DWORD PTR _n$[esp+1312]
  003bc	0f 87 10 01 00
	00		 ja	 $LN49@inflate_dy

; 873  :         return 1;
; 874  :       while (j--)

  003c2	85 c9		 test	 ecx, ecx
  003c4	74 0a		 je	 SHORT $LN9@inflate_dy
  003c6	8d 7c bc 30	 lea	 edi, DWORD PTR _ll$[esp+edi*4+1312]
  003ca	33 c0		 xor	 eax, eax
  003cc	f3 ab		 rep stosd
  003ce	8b fa		 mov	 edi, edx
$LN9@inflate_dy:

; 875  :         ll[i++] = 0;
; 876  :       l = 0;

  003d0	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _l$[esp+1312], 0
$LN156@inflate_dy:

; 838  :   while ((unsigned)i < n)

  003d8	3b 7c 24 1c	 cmp	 edi, DWORD PTR _n$[esp+1312]
  003dc	0f 82 52 fe ff
	ff		 jb	 $LL36@inflate_dy
$LN153@inflate_dy:

; 877  :     }
; 878  :   }
; 879  : 
; 880  : 
; 881  :   /* free decoding table for trees */
; 882  :   huft_free(tl);

  003e2	8b 44 24 10	 mov	 eax, DWORD PTR _tl$[esp+1312]
  003e6	50		 push	 eax
  003e7	e8 00 00 00 00	 call	 _huft_free

; 883  : 
; 884  : 
; 885  :   /* restore the global bit buffer */
; 886  :   G.bb = b;
; 887  :   G.bk = k;
; 888  : 
; 889  : 
; 890  :   /* build the decoding tables for literal/length and distance codes */
; 891  :   bl = lbits;
; 892  :   i = huft_build(__G__ ll, nl, 257, cplens, cplext, &tl, &bl);

  003ec	8b 7c 24 18	 mov	 edi, DWORD PTR _nl$[esp+1316]
  003f0	8d 4c 24 1c	 lea	 ecx, DWORD PTR _bl$[esp+1316]
  003f4	51		 push	 ecx
  003f5	8d 54 24 18	 lea	 edx, DWORD PTR _tl$[esp+1320]
  003f9	52		 push	 edx
  003fa	68 00 00 00 00	 push	 OFFSET _cplext
  003ff	68 00 00 00 00	 push	 OFFSET _cplens
  00404	68 01 01 00 00	 push	 257			; 00000101H
  00409	8d 44 24 48	 lea	 eax, DWORD PTR _ll$[esp+1336]
  0040d	57		 push	 edi
  0040e	50		 push	 eax
  0040f	89 1d 28 00 00
	00		 mov	 DWORD PTR _G+40, ebx
  00415	89 35 20 00 00
	00		 mov	 DWORD PTR _G+32, esi
  0041b	c7 44 24 38 09
	00 00 00	 mov	 DWORD PTR _bl$[esp+1344], 9
  00423	e8 00 00 00 00	 call	 _huft_build

; 893  :   if (bl == 0)                        /* no literals or lengths */

  00428	8b 6c 24 38	 mov	 ebp, DWORD PTR _bl$[esp+1344]
  0042c	83 c4 20	 add	 esp, 32			; 00000020H
  0042f	8b f0		 mov	 esi, eax
  00431	85 ed		 test	 ebp, ebp
  00433	75 05		 jne	 SHORT $LN7@inflate_dy

; 894  :     i = 1;

  00435	8d 75 01	 lea	 esi, DWORD PTR [ebp+1]

; 895  :   if (i)

  00438	eb 09		 jmp	 SHORT $LN123@inflate_dy
$LN7@inflate_dy:
  0043a	85 f6		 test	 esi, esi
  0043c	74 32		 je	 SHORT $LN6@inflate_dy

; 896  :   {
; 897  :     if (i == 1) {

  0043e	83 fe 01	 cmp	 esi, 1
  00441	75 20		 jne	 SHORT $LN5@inflate_dy
$LN123@inflate_dy:

; 898  :       //if (!uO.qflag)
; 899  :         MESSAGE((uch *)"(incomplete l-tree)  ", 21L, 1);

  00443	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@DPKBCABB@?$CIincomplete?5l?9tree?$CJ?5?5?$AA@
  00448	e8 00 00 00 00	 call	 ___iob_func
  0044d	83 c0 40	 add	 eax, 64			; 00000040H
  00450	50		 push	 eax
  00451	e8 00 00 00 00	 call	 _fprintf

; 900  :       huft_free(tl);

  00456	8b 4c 24 18	 mov	 ecx, DWORD PTR _tl$[esp+1320]
  0045a	51		 push	 ecx
  0045b	e8 00 00 00 00	 call	 _huft_free
  00460	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@inflate_dy:
  00463	5f		 pop	 edi

; 901  :     }
; 902  :     return i;                   /* incomplete code set */

  00464	8b c6		 mov	 eax, esi
  00466	5e		 pop	 esi
  00467	5d		 pop	 ebp
  00468	5b		 pop	 ebx

; 938  : }

  00469	81 c4 10 05 00
	00		 add	 esp, 1296		; 00000510H
  0046f	c3		 ret	 0
$LN6@inflate_dy:

; 903  :   }
; 904  :   bd = dbits;
; 905  :   i = huft_build(__G__ ll + nl, nd, 0, cpdist, cpdext, &td, &bd);

  00470	8b 4c 24 24	 mov	 ecx, DWORD PTR _nd$[esp+1312]
  00474	8d 54 24 14	 lea	 edx, DWORD PTR _bd$[esp+1312]
  00478	52		 push	 edx
  00479	8d 44 24 2c	 lea	 eax, DWORD PTR _td$[esp+1316]
  0047d	50		 push	 eax
  0047e	68 00 00 00 00	 push	 OFFSET _cpdext
  00483	68 00 00 00 00	 push	 OFFSET _cpdist
  00488	6a 00		 push	 0
  0048a	51		 push	 ecx
  0048b	8d 54 bc 48	 lea	 edx, DWORD PTR _ll$[esp+edi*4+1336]
  0048f	52		 push	 edx
  00490	c7 44 24 30 06
	00 00 00	 mov	 DWORD PTR _bd$[esp+1340], 6
  00498	e8 00 00 00 00	 call	 _huft_build

; 906  :   if (bd == 0 && nl > 257)    /* lengths but no distances */

  0049d	8b 5c 24 30	 mov	 ebx, DWORD PTR _bd$[esp+1340]
  004a1	83 c4 1c	 add	 esp, 28			; 0000001cH
  004a4	8b f0		 mov	 esi, eax
  004a6	85 db		 test	 ebx, ebx
  004a8	75 38		 jne	 SHORT $LN4@inflate_dy
  004aa	81 ff 01 01 00
	00		 cmp	 edi, 257		; 00000101H
  004b0	76 30		 jbe	 SHORT $LN4@inflate_dy

; 907  :   {
; 908  :     //if (!uO.qflag)
; 909  :       MESSAGE((uch *)"(incomplete d-tree)  ", 21L, 1);

  004b2	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@CMHGGAOF@?$CIincomplete?5d?9tree?$CJ?5?5?$AA@
  004b7	e8 00 00 00 00	 call	 ___iob_func
  004bc	83 c0 40	 add	 eax, 64			; 00000040H
  004bf	50		 push	 eax
  004c0	e8 00 00 00 00	 call	 _fprintf

; 910  :     huft_free(tl);

  004c5	8b 44 24 18	 mov	 eax, DWORD PTR _tl$[esp+1320]
  004c9	50		 push	 eax
  004ca	e8 00 00 00 00	 call	 _huft_free
  004cf	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN49@inflate_dy:
  004d2	5f		 pop	 edi
  004d3	5e		 pop	 esi
  004d4	5d		 pop	 ebp
  004d5	b8 01 00 00 00	 mov	 eax, 1
  004da	5b		 pop	 ebx

; 938  : }

  004db	81 c4 10 05 00
	00		 add	 esp, 1296		; 00000510H
  004e1	c3		 ret	 0
$LN4@inflate_dy:

; 911  :     return 1;
; 912  :   }
; 913  :   if (i == 1) {

  004e2	8b 7c 24 28	 mov	 edi, DWORD PTR _td$[esp+1312]
  004e6	83 fe 01	 cmp	 esi, 1
  004e9	75 1c		 jne	 SHORT $LN3@inflate_dy

; 914  : #ifdef PKZIP_BUG_WORKAROUND
; 915  :     i = 0;
; 916  : #else
; 917  :     //if (!uO.qflag)
; 918  :       MESSAGE((uch *)"(incomplete d-tree)  ", 21L, 1);

  004eb	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@CMHGGAOF@?$CIincomplete?5d?9tree?$CJ?5?5?$AA@
  004f0	e8 00 00 00 00	 call	 ___iob_func
  004f5	83 c0 40	 add	 eax, 64			; 00000040H
  004f8	50		 push	 eax
  004f9	e8 00 00 00 00	 call	 _fprintf

; 919  :     huft_free(td);

  004fe	57		 push	 edi
  004ff	e8 00 00 00 00	 call	 _huft_free
  00504	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@inflate_dy:

; 920  : #endif
; 921  :   }
; 922  :   if (i)

  00507	85 f6		 test	 esi, esi
  00509	74 1a		 je	 SHORT $LN2@inflate_dy

; 923  :   {
; 924  :     huft_free(tl);

  0050b	8b 4c 24 10	 mov	 ecx, DWORD PTR _tl$[esp+1312]
  0050f	51		 push	 ecx
  00510	e8 00 00 00 00	 call	 _huft_free
  00515	83 c4 04	 add	 esp, 4
  00518	5f		 pop	 edi

; 925  :     return i;

  00519	8b c6		 mov	 eax, esi
  0051b	5e		 pop	 esi
  0051c	5d		 pop	 ebp
  0051d	5b		 pop	 ebx

; 938  : }

  0051e	81 c4 10 05 00
	00		 add	 esp, 1296		; 00000510H
  00524	c3		 ret	 0
$LN2@inflate_dy:

; 926  :   }
; 927  : 
; 928  : 
; 929  :   /* decompress until an end-of-block code */
; 930  :   if (inflate_codes(__G__ tl, td, bl, bd))

  00525	8b 74 24 10	 mov	 esi, DWORD PTR _tl$[esp+1312]
  00529	53		 push	 ebx
  0052a	55		 push	 ebp
  0052b	57		 push	 edi
  0052c	56		 push	 esi
  0052d	e8 00 00 00 00	 call	 _inflate_codes
  00532	83 c4 10	 add	 esp, 16			; 00000010H
  00535	85 c0		 test	 eax, eax

; 931  :     return 1;

  00537	75 99		 jne	 SHORT $LN49@inflate_dy

; 932  : 
; 933  : 
; 934  :   /* free the decoding tables, return */
; 935  :   huft_free(tl);

  00539	56		 push	 esi
  0053a	e8 00 00 00 00	 call	 _huft_free

; 936  :   huft_free(td);

  0053f	57		 push	 edi
  00540	e8 00 00 00 00	 call	 _huft_free
  00545	83 c4 08	 add	 esp, 8
  00548	5f		 pop	 edi
  00549	5e		 pop	 esi
  0054a	5d		 pop	 ebp

; 937  :   return 0;

  0054b	33 c0		 xor	 eax, eax
  0054d	5b		 pop	 ebx

; 938  : }

  0054e	81 c4 10 05 00
	00		 add	 esp, 1296		; 00000510H
  00554	c3		 ret	 0
_inflate_dynamic ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _inflate_block
_TEXT	SEGMENT
_e$ = 8							; size = 4
_inflate_block PROC					; COMDAT

; 947  :   unsigned t;           /* block type */
; 948  :   register ulg b;       /* bit buffer */
; 949  :   register unsigned k;  /* number of bits in bit buffer */
; 950  : 
; 951  : 
; 952  :   /* make local bit buffer */
; 953  :   b = G.bb;
; 954  :   k = G.bk;

  00000	8b 0d 20 00 00
	00		 mov	 ecx, DWORD PTR _G+32
  00006	8b 15 28 00 00
	00		 mov	 edx, DWORD PTR _G+40
  0000c	56		 push	 esi
  0000d	57		 push	 edi

; 955  : 
; 956  : 
; 957  :   /* read in last block bit */
; 958  :   NEEDBITS(1)

  0000e	83 f9 01	 cmp	 ecx, 1
  00011	73 39		 jae	 SHORT $LN8@inflate_bl
  00013	8b 3d 08 00 00
	00		 mov	 edi, DWORD PTR _G+8
  00019	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _G
  0001f	90		 npad	 1
$LL9@inflate_bl:
  00020	8b c7		 mov	 eax, edi
  00022	4f		 dec	 edi
  00023	89 3d 08 00 00
	00		 mov	 DWORD PTR _G+8, edi
  00029	85 c0		 test	 eax, eax
  0002b	0f 8c 8a 00 00
	00		 jl	 $LN18@inflate_bl
  00031	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00034	46		 inc	 esi
  00035	89 35 00 00 00
	00		 mov	 DWORD PTR _G, esi
  0003b	83 f8 ff	 cmp	 eax, -1
  0003e	74 7b		 je	 SHORT $LN18@inflate_bl
  00040	d3 e0		 shl	 eax, cl
  00042	83 c1 08	 add	 ecx, 8
  00045	0b d0		 or	 edx, eax
  00047	83 f9 01	 cmp	 ecx, 1
  0004a	72 d4		 jb	 SHORT $LL9@inflate_bl
$LN8@inflate_bl:

; 959  :   *e = (int)b & 1;

  0004c	8b 74 24 0c	 mov	 esi, DWORD PTR _e$[esp+4]
  00050	8b c2		 mov	 eax, edx
  00052	83 e0 01	 and	 eax, 1

; 960  :   DUMPBITS(1)

  00055	49		 dec	 ecx
  00056	d1 ea		 shr	 edx, 1
  00058	89 06		 mov	 DWORD PTR [esi], eax

; 961  : 
; 962  : 
; 963  :   /* read in block type */
; 964  :   NEEDBITS(2)

  0005a	83 f9 02	 cmp	 ecx, 2
  0005d	73 39		 jae	 SHORT $LN5@inflate_bl
  0005f	8b 3d 08 00 00
	00		 mov	 edi, DWORD PTR _G+8
  00065	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _G
  0006b	eb 03 8d 49 00	 npad	 5
$LL6@inflate_bl:
  00070	8b c7		 mov	 eax, edi
  00072	4f		 dec	 edi
  00073	89 3d 08 00 00
	00		 mov	 DWORD PTR _G+8, edi
  00079	85 c0		 test	 eax, eax
  0007b	7c 3e		 jl	 SHORT $LN18@inflate_bl
  0007d	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00080	46		 inc	 esi
  00081	89 35 00 00 00
	00		 mov	 DWORD PTR _G, esi
  00087	83 f8 ff	 cmp	 eax, -1
  0008a	74 2f		 je	 SHORT $LN18@inflate_bl
  0008c	d3 e0		 shl	 eax, cl
  0008e	83 c1 08	 add	 ecx, 8
  00091	0b d0		 or	 edx, eax
  00093	83 f9 02	 cmp	 ecx, 2
  00096	72 d8		 jb	 SHORT $LL6@inflate_bl
$LN5@inflate_bl:

; 965  :   t = (unsigned)b & 3;

  00098	8b c2		 mov	 eax, edx
  0009a	83 e0 03	 and	 eax, 3

; 966  :   DUMPBITS(2)

  0009d	c1 ea 02	 shr	 edx, 2
  000a0	83 c1 fe	 add	 ecx, -2			; fffffffeH

; 967  : 
; 968  : 
; 969  :   /* restore the global bit buffer */
; 970  :   G.bb = b;

  000a3	89 15 28 00 00
	00		 mov	 DWORD PTR _G+40, edx

; 971  :   G.bk = k;

  000a9	89 0d 20 00 00
	00		 mov	 DWORD PTR _G+32, ecx

; 972  : 
; 973  : 
; 974  :   /* inflate that block type */
; 975  :   if (t == 2)

  000af	83 f8 02	 cmp	 eax, 2
  000b2	75 0f		 jne	 SHORT $LN3@inflate_bl
  000b4	5f		 pop	 edi
  000b5	5e		 pop	 esi

; 976  :     return inflate_dynamic(__G);

  000b6	e9 00 00 00 00	 jmp	 _inflate_dynamic
$LN18@inflate_bl:
  000bb	5f		 pop	 edi

; 955  : 
; 956  : 
; 957  :   /* read in last block bit */
; 958  :   NEEDBITS(1)

  000bc	b8 01 00 00 00	 mov	 eax, 1
  000c1	5e		 pop	 esi

; 985  : }

  000c2	c3		 ret	 0
$LN3@inflate_bl:

; 977  :   if (t == 0)

  000c3	85 c0		 test	 eax, eax
  000c5	75 07		 jne	 SHORT $LN2@inflate_bl
  000c7	5f		 pop	 edi
  000c8	5e		 pop	 esi

; 978  :     return inflate_stored(__G);

  000c9	e9 00 00 00 00	 jmp	 _inflate_stored
$LN2@inflate_bl:

; 979  :   if (t == 1)

  000ce	83 f8 01	 cmp	 eax, 1
  000d1	75 07		 jne	 SHORT $LN1@inflate_bl
  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi

; 980  :     return inflate_fixed(__G);

  000d5	e9 00 00 00 00	 jmp	 _inflate_fixed
$LN1@inflate_bl:
  000da	5f		 pop	 edi

; 981  : 
; 982  : 
; 983  :   /* bad block type */
; 984  :   return 2;

  000db	b8 02 00 00 00	 mov	 eax, 2
  000e0	5e		 pop	 esi

; 985  : }

  000e1	c3		 ret	 0
_inflate_block ENDP
_TEXT	ENDS
PUBLIC	_inflate
; Function compile flags: /Ogtpy
;	COMDAT _inflate
_TEXT	SEGMENT
_e$ = -4						; size = 4
_inflate PROC						; COMDAT

; 992  : {

  00000	51		 push	 ecx

; 993  :   int e;                /* last block flag */
; 994  :   int r;                /* result code */
; 995  : //#ifdef DEBUG
; 996  : //  unsigned h = 0;       /* maximum struct huft's malloc'ed */
; 997  : //#endif
; 998  : 
; 999  : #if (defined(DLL) && !defined(NO_SLIDE_REDIR))
; 1000 :   if (G.redirect_slide)
; 1001 :     wsize = G.redirect_size, redirSlide = G.redirect_buffer;
; 1002 :   else
; 1003 :     wsize = WSIZE, redirSlide = slide;   /* how they're #defined if !DLL */
; 1004 : #endif
; 1005 : 
; 1006 :   /* initialize window, bit buffer */
; 1007 :   G.wp = 0;

  00001	c7 05 24 00 00
	00 00 00 00 00	 mov	 DWORD PTR _G+36, 0

; 1008 :   G.bk = 0;

  0000b	c7 05 20 00 00
	00 00 00 00 00	 mov	 DWORD PTR _G+32, 0

; 1009 :   G.bb = 0;

  00015	c7 05 28 00 00
	00 00 00 00 00	 mov	 DWORD PTR _G+40, 0
  0001f	90		 npad	 1
$LL4@inflate:

; 1010 : 
; 1011 : 
; 1012 :   /* decompress until the last block */
; 1013 :   do {
; 1014 : //#ifdef DEBUG
; 1015 : //    G.hufts = 0;
; 1016 : //#endif
; 1017 :     if ((r = inflate_block(__G__ &e)) != 0)

  00020	8d 04 24	 lea	 eax, DWORD PTR _e$[esp+4]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 _inflate_block
  00029	83 c4 04	 add	 esp, 4
  0002c	85 c0		 test	 eax, eax
  0002e	75 33		 jne	 SHORT $LN5@inflate

; 1018 :       return r;
; 1019 : //#ifdef DEBUG
; 1020 : //    if (G.hufts > h)
; 1021 : //      h = G.hufts;
; 1022 : //#endif
; 1023 :   } while (!e);

  00030	39 04 24	 cmp	 DWORD PTR _e$[esp+4], eax
  00033	74 eb		 je	 SHORT $LL4@inflate

; 1024 : 
; 1025 : 
; 1026 :   /* flush out redirSlide */
; 1027 :   FLUSH(G.wp);

  00035	8b 0d 24 00 00
	00		 mov	 ecx, DWORD PTR _G+36
  0003b	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _G+4
  00041	51		 push	 ecx
  00042	68 00 00 00 00	 push	 OFFSET _redirSlide
  00047	52		 push	 edx
  00048	e8 00 00 00 00	 call	 _memcpy
  0004d	a1 24 00 00 00	 mov	 eax, DWORD PTR _G+36
  00052	01 05 04 00 00
	00		 add	 DWORD PTR _G+4, eax
  00058	01 05 0c 00 00
	00		 add	 DWORD PTR _G+12, eax
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1028 : 
; 1029 : 
; 1030 :   /* return success */
; 1031 :   //Trace((stderr, "\n%u bytes in Huffman tables (%d/entry)\n",
; 1032 :   //       h * sizeof(struct huft), sizeof(struct huft)));
; 1033 :   return 0;

  00061	33 c0		 xor	 eax, eax
$LN5@inflate:

; 1034 : }

  00063	59		 pop	 ecx
  00064	c3		 ret	 0
_inflate ENDP
_TEXT	ENDS
PUBLIC	_DecompressDeflatedData
; Function compile flags: /Ogtpy
;	COMDAT _DecompressDeflatedData
_TEXT	SEGMENT
_out$ = 8						; size = 4
_in$ = 12						; size = 4
_inLength$ = 16						; size = 4
_DecompressDeflatedData PROC				; COMDAT

; 1296 : 	G.outbufptr = out;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _out$[esp-4]

; 1297 :     G.inptr = in;

  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR _in$[esp-4]

; 1298 :     G.incnt = inLength;

  00008	8b 54 24 0c	 mov	 edx, DWORD PTR _inLength$[esp-4]
  0000c	a3 04 00 00 00	 mov	 DWORD PTR _G+4, eax
  00011	89 0d 00 00 00
	00		 mov	 DWORD PTR _G, ecx
  00017	89 15 08 00 00
	00		 mov	 DWORD PTR _G+8, edx

; 1299 : 	G.outCounter = 0;

  0001d	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR _G+12, 0

; 1300 : 
; 1301 : 	if (inflate(__G) != 0) 

  00027	e8 00 00 00 00	 call	 _inflate
  0002c	f7 d8		 neg	 eax
  0002e	1b c0		 sbb	 eax, eax
  00030	f7 d0		 not	 eax
  00032	23 05 0c 00 00
	00		 and	 eax, DWORD PTR _G+12

; 1302 : 	{
; 1303 : 		// Error decompressing
; 1304 : 		return 0;
; 1305 : 	}
; 1306 : 	return G.outCounter;
; 1307 : }

  00038	c3		 ret	 0
_DecompressDeflatedData ENDP
_TEXT	ENDS
END
