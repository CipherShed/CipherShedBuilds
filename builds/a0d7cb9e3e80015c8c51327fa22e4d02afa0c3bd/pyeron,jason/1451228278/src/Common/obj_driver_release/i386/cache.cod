; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\users\public\desktop\projects\ciphershed\src\common\cache.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_cacheEmpty
_DATA	SEGMENT
COMM	_CachedPasswords:BYTE:0120H
_DATA	ENDS
_BSS	SEGMENT
_nPasswordIdx DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_cacheEmpty DD	01H
_DATA	ENDS
PUBLIC	_RtlSecureZeroMemory@8
; Function compile flags: /Ogsp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
;	COMDAT _RtlSecureZeroMemory@8
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory@8 PROC				; COMDAT

; 8322 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 8323 :     volatile char *vptr = (volatile char *)ptr;
; 8324 : 
; 8325 : #if defined(_M_AMD64)
; 8326 : 
; 8327 :         __stosb((PUCHAR)((ULONG64)vptr), 0, cnt);
; 8328 : 
; 8329 : #else
; 8330 : 
; 8331 :     while (cnt) {

  00005	83 7d 0c 00	 cmp	 DWORD PTR _cnt$[ebp], 0
  00009	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  0000c	74 09		 je	 SHORT $LN1@RtlSecureZ
$LL2@RtlSecureZ:

; 8332 :         *vptr = 0;

  0000e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 8333 :         vptr++;

  00011	40		 inc	 eax

; 8334 :         cnt--;

  00012	ff 4d 0c	 dec	 DWORD PTR _cnt$[ebp]
  00015	75 f7		 jne	 SHORT $LL2@RtlSecureZ
$LN1@RtlSecureZ:

; 8335 :     }
; 8336 : 
; 8337 : #endif
; 8338 : 
; 8339 :     return ptr;

  00017	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]

; 8340 : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
_RtlSecureZeroMemory@8 ENDP
_TEXT	ENDS
PUBLIC	_ReadVolumeHeaderWCache@20
EXTRN	_ReadVolumeHeader@20:PROC
; Function compile flags: /Ogsp
; File c:\users\public\desktop\projects\ciphershed\src\common\cache.c
;	COMDAT _ReadVolumeHeaderWCache@20
_TEXT	SEGMENT
_nReturnCode$ = -4					; size = 4
_bBoot$ = 8						; size = 4
_bCache$ = 12						; size = 4
_header$ = 16						; size = 4
_password$ = 20						; size = 4
_i$ = 24						; size = 4
_retInfo$ = 24						; size = 4
_ReadVolumeHeaderWCache@20 PROC				; COMDAT

; 25   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 26   : 	int nReturnCode = ERR_PASSWORD_WRONG;
; 27   : 	int i;
; 28   : 
; 29   : 	/* Attempt to recognize volume using mount password */
; 30   : 	if (password->Length > 0)

  00006	8b 45 14	 mov	 eax, DWORD PTR _password$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	6a 03		 push	 3
  0000e	33 ff		 xor	 edi, edi
  00010	5b		 pop	 ebx
  00011	89 5d fc	 mov	 DWORD PTR _nReturnCode$[ebp], ebx
  00014	39 38		 cmp	 DWORD PTR [eax], edi
  00016	0f 86 87 00 00
	00		 jbe	 $LN15@ReadVolume

; 31   : 	{
; 32   : 		nReturnCode = ReadVolumeHeader (bBoot, header, password, retInfo, NULL);

  0001c	57		 push	 edi
  0001d	ff 75 18	 push	 DWORD PTR _retInfo$[ebp]
  00020	50		 push	 eax
  00021	ff 75 10	 push	 DWORD PTR _header$[ebp]
  00024	ff 75 08	 push	 DWORD PTR _bBoot$[ebp]
  00027	e8 00 00 00 00	 call	 _ReadVolumeHeader@20
  0002c	89 45 fc	 mov	 DWORD PTR _nReturnCode$[ebp], eax

; 33   : 
; 34   : 		/* Save mount passwords back into cache if asked to do so */
; 35   : 		if (bCache && (nReturnCode == 0 || nReturnCode == ERR_CIPHER_INIT_WEAK_KEY))

  0002f	39 7d 0c	 cmp	 DWORD PTR _bCache$[ebp], edi
  00032	0f 84 9e 00 00
	00		 je	 $LN27@ReadVolume
  00038	3b c7		 cmp	 eax, edi
  0003a	74 09		 je	 SHORT $LN13@ReadVolume
  0003c	83 f8 12	 cmp	 eax, 18			; 00000012H
  0003f	0f 85 91 00 00
	00		 jne	 $LN27@ReadVolume
$LN13@ReadVolume:

; 36   : 		{
; 37   : 			for (i = 0; i < CACHE_SIZE; i++)

  00045	b8 00 00 00 00	 mov	 eax, OFFSET _CachedPasswords
  0004a	89 7d 18	 mov	 DWORD PTR _i$[ebp], edi
  0004d	8b d0		 mov	 edx, eax
$LL25@ReadVolume:

; 38   : 			{
; 39   : 				if (memcmp (&CachedPasswords[i], password, sizeof (Password)) == 0)

  0004f	8b 7d 14	 mov	 edi, DWORD PTR _password$[ebp]
  00052	6a 12		 push	 18			; 00000012H
  00054	59		 pop	 ecx
  00055	8b f2		 mov	 esi, edx
  00057	33 db		 xor	 ebx, ebx
  00059	f3 a7		 repe cmpsd
  0005b	74 0e		 je	 SHORT $LN26@ReadVolume
  0005d	ff 45 18	 inc	 DWORD PTR _i$[ebp]
  00060	83 c2 48	 add	 edx, 72			; 00000048H
  00063	81 fa 20 01 00
	00		 cmp	 edx, OFFSET _CachedPasswords+288
  00069	7c e4		 jl	 SHORT $LL25@ReadVolume
$LN26@ReadVolume:

; 40   : 					break;
; 41   : 			}
; 42   : 
; 43   : 			if (i == CACHE_SIZE)

  0006b	83 7d 18 04	 cmp	 DWORD PTR _i$[ebp], 4
  0006f	75 65		 jne	 SHORT $LN27@ReadVolume

; 44   : 			{
; 45   : 				/* Store the password */
; 46   : 				CachedPasswords[nPasswordIdx] = *password;

  00071	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _nPasswordIdx
  00077	8b 75 14	 mov	 esi, DWORD PTR _password$[ebp]
  0007a	8b fa		 mov	 edi, edx
  0007c	6b ff 48	 imul	 edi, 72			; 00000048H
  0007f	03 f8		 add	 edi, eax
  00081	6a 12		 push	 18			; 00000012H

; 47   : 
; 48   : 				/* Try another slot */
; 49   : 				nPasswordIdx = (nPasswordIdx + 1) % CACHE_SIZE;

  00083	42		 inc	 edx
  00084	81 e2 03 00 00
	80		 and	 edx, -2147483645	; 80000003H
  0008a	59		 pop	 ecx
  0008b	f3 a5		 rep movsd
  0008d	79 05		 jns	 SHORT $LN28@ReadVolume
  0008f	4a		 dec	 edx
  00090	83 ca fc	 or	 edx, -4			; fffffffcH
  00093	42		 inc	 edx
$LN28@ReadVolume:

; 50   : 
; 51   : 				cacheEmpty = 0;

  00094	83 25 00 00 00
	00 00		 and	 DWORD PTR _cacheEmpty, 0
  0009b	89 15 00 00 00
	00		 mov	 DWORD PTR _nPasswordIdx, edx

; 52   : 			}
; 53   : 		}

  000a1	eb 33		 jmp	 SHORT $LN27@ReadVolume
$LN15@ReadVolume:

; 54   : 	}
; 55   : 	else if (!cacheEmpty)

  000a3	39 3d 00 00 00
	00		 cmp	 DWORD PTR _cacheEmpty, edi
  000a9	75 2b		 jne	 SHORT $LN27@ReadVolume

; 56   : 	{
; 57   : 		/* Attempt to recognize volume using cached passwords */
; 58   : 		for (i = 0; i < CACHE_SIZE; i++)

  000ab	be 00 00 00 00	 mov	 esi, OFFSET _CachedPasswords
$LL5@ReadVolume:

; 59   : 		{
; 60   : 			if (CachedPasswords[i].Length > 0)

  000b0	39 3e		 cmp	 DWORD PTR [esi], edi
  000b2	76 17		 jbe	 SHORT $LN4@ReadVolume

; 61   : 			{
; 62   : 				nReturnCode = ReadVolumeHeader (bBoot, header, &CachedPasswords[i], retInfo, NULL);

  000b4	57		 push	 edi
  000b5	ff 75 18	 push	 DWORD PTR _retInfo$[ebp]
  000b8	56		 push	 esi
  000b9	ff 75 10	 push	 DWORD PTR _header$[ebp]
  000bc	ff 75 08	 push	 DWORD PTR _bBoot$[ebp]
  000bf	e8 00 00 00 00	 call	 _ReadVolumeHeader@20
  000c4	89 45 fc	 mov	 DWORD PTR _nReturnCode$[ebp], eax

; 63   : 
; 64   : 				if (nReturnCode != ERR_PASSWORD_WRONG)

  000c7	3b c3		 cmp	 eax, ebx
  000c9	75 0b		 jne	 SHORT $LN27@ReadVolume
$LN4@ReadVolume:

; 56   : 	{
; 57   : 		/* Attempt to recognize volume using cached passwords */
; 58   : 		for (i = 0; i < CACHE_SIZE; i++)

  000cb	83 c6 48	 add	 esi, 72			; 00000048H
  000ce	81 fe 20 01 00
	00		 cmp	 esi, OFFSET _CachedPasswords+288
  000d4	7c da		 jl	 SHORT $LL5@ReadVolume
$LN27@ReadVolume:

; 65   : 					break;
; 66   : 			}
; 67   : 		}
; 68   : 	}
; 69   : 
; 70   : 	return nReturnCode;

  000d6	8b 45 fc	 mov	 eax, DWORD PTR _nReturnCode$[ebp]
  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi
  000db	5b		 pop	 ebx

; 71   : }

  000dc	c9		 leave
  000dd	c2 14 00	 ret	 20			; 00000014H
_ReadVolumeHeaderWCache@20 ENDP
_TEXT	ENDS
PUBLIC	_AddPasswordToCache@4
; Function compile flags: /Ogsp
;	COMDAT _AddPasswordToCache@4
_TEXT	SEGMENT
_password$ = 8						; size = 4
_AddPasswordToCache@4 PROC				; COMDAT

; 75   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	53		 push	 ebx

; 76   : 	int i;
; 77   : 	for (i = 0; i < CACHE_SIZE; i++)

  00006	ba 00 00 00 00	 mov	 edx, OFFSET _CachedPasswords
  0000b	56		 push	 esi
  0000c	8b c2		 mov	 eax, edx
  0000e	57		 push	 edi
$LL11@AddPasswor:

; 78   : 	{
; 79   : 		if (memcmp (&CachedPasswords[i], password, sizeof (Password)) == 0)

  0000f	8b 7d 08	 mov	 edi, DWORD PTR _password$[ebp]
  00012	6a 12		 push	 18			; 00000012H
  00014	59		 pop	 ecx
  00015	8b f0		 mov	 esi, eax
  00017	33 db		 xor	 ebx, ebx
  00019	f3 a7		 repe cmpsd
  0001b	74 37		 je	 SHORT $LN5@AddPasswor
  0001d	83 c0 48	 add	 eax, 72			; 00000048H
  00020	3d 20 01 00 00	 cmp	 eax, OFFSET _CachedPasswords+288
  00025	7c e8		 jl	 SHORT $LL11@AddPasswor

; 80   : 			return;
; 81   : 	}
; 82   : 
; 83   : 	CachedPasswords[nPasswordIdx] = *password;

  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR _nPasswordIdx
  0002c	8b 75 08	 mov	 esi, DWORD PTR _password$[ebp]
  0002f	8b f8		 mov	 edi, eax
  00031	6b ff 48	 imul	 edi, 72			; 00000048H
  00034	03 fa		 add	 edi, edx
  00036	6a 12		 push	 18			; 00000012H

; 84   : 	nPasswordIdx = (nPasswordIdx + 1) % CACHE_SIZE;

  00038	40		 inc	 eax
  00039	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  0003e	59		 pop	 ecx
  0003f	f3 a5		 rep movsd
  00041	79 05		 jns	 SHORT $LN12@AddPasswor
  00043	48		 dec	 eax
  00044	83 c8 fc	 or	 eax, -4			; fffffffcH
  00047	40		 inc	 eax
$LN12@AddPasswor:

; 85   : 	cacheEmpty = 0;

  00048	83 25 00 00 00
	00 00		 and	 DWORD PTR _cacheEmpty, 0
  0004f	a3 00 00 00 00	 mov	 DWORD PTR _nPasswordIdx, eax
$LN5@AddPasswor:
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx

; 86   : }

  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
_AddPasswordToCache@4 ENDP
_TEXT	ENDS
PUBLIC	_WipeCache@0
; Function compile flags: /Ogsp
;	COMDAT _WipeCache@0
_TEXT	SEGMENT
_WipeCache@0 PROC					; COMDAT

; 91   : 	burn (CachedPasswords, sizeof (CachedPasswords));

  00000	b8 00 00 00 00	 mov	 eax, OFFSET _CachedPasswords
  00005	b9 20 01 00 00	 mov	 ecx, 288		; 00000120H
  0000a	56		 push	 esi
  0000b	8b d0		 mov	 edx, eax
  0000d	8b f1		 mov	 esi, ecx
$LL9@WipeCache:
  0000f	c6 00 00	 mov	 BYTE PTR [eax], 0
  00012	40		 inc	 eax
  00013	49		 dec	 ecx
  00014	75 f9		 jne	 SHORT $LL9@WipeCache
$LL2@WipeCache:
  00016	4e		 dec	 esi
  00017	c6 02 00	 mov	 BYTE PTR [edx], 0
  0001a	42		 inc	 edx
  0001b	85 f6		 test	 esi, esi
  0001d	75 f7		 jne	 SHORT $LL2@WipeCache

; 92   : 	nPasswordIdx = 0;

  0001f	21 35 00 00 00
	00		 and	 DWORD PTR _nPasswordIdx, esi

; 93   : 	cacheEmpty = 1;

  00025	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _cacheEmpty, 1
  0002f	5e		 pop	 esi

; 94   : }

  00030	c3		 ret	 0
_WipeCache@0 ENDP
_TEXT	ENDS
END
