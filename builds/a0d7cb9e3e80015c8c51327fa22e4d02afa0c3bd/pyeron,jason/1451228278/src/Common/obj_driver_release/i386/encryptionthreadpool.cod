; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\users\public\desktop\projects\ciphershed\src\common\encryptionthreadpool.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
_ThreadPoolRunning DD 01H DUP (?)
_StopPending DD	01H DUP (?)
_BSS	ENDS
PUBLIC	_ExInitializeFastMutex@4
EXTRN	__imp__KeInitializeEvent@12:PROC
; Function compile flags: /Ogsp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
;	COMDAT _ExInitializeFastMutex@4
_TEXT	SEGMENT
_FastMutex$ = 8						; size = 4
_ExInitializeFastMutex@4 PROC				; COMDAT

; 16362: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 16363: 
; 16364:     FastMutex->Count = FM_LOCK_BIT;

  00005	8b 45 08	 mov	 eax, DWORD PTR _FastMutex$[ebp]

; 16365:     FastMutex->Owner = NULL;

  00008	33 d2		 xor	 edx, edx
  0000a	33 c9		 xor	 ecx, ecx
  0000c	41		 inc	 ecx

; 16366:     FastMutex->Contention = 0;
; 16367:     KeInitializeEvent(&FastMutex->Event, SynchronizationEvent, FALSE);

  0000d	52		 push	 edx
  0000e	89 08		 mov	 DWORD PTR [eax], ecx
  00010	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00013	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00016	51		 push	 ecx
  00017	83 c0 0c	 add	 eax, 12			; 0000000cH
  0001a	50		 push	 eax
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 16368:     return;
; 16369: }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
_ExInitializeFastMutex@4 ENDP
; Function compile flags: /Ogsp
; File c:\users\public\desktop\projects\ciphershed\src\common\encryptionthreadpool.c
_TEXT	ENDS
;	COMDAT _GetWorkItemState@4
_TEXT	SEGMENT
_GetWorkItemState@4 PROC				; COMDAT
; _workItem$ = ecx

; 113  : 	return InterlockedExchangeAdd ((LONG *) &workItem->State, 0);

  00000	33 c0		 xor	 eax, eax
  00002	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax

; 114  : }

  00006	c3		 ret	 0
_GetWorkItemState@4 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _SetWorkItemState@8
_TEXT	SEGMENT
_SetWorkItemState@8 PROC				; COMDAT
; _workItem$ = ecx
; _newState$ = eax

; 119  : 	InterlockedExchange ((LONG *) &workItem->State, (LONG) newState);

  00000	87 01		 xchg	 DWORD PTR [ecx], eax

; 120  : }

  00002	c3		 ret	 0
_SetWorkItemState@8 ENDP
_TEXT	ENDS
EXTRN	__imp__KeBugCheckEx@20:PROC
EXTRN	__imp__PsTerminateSystemThread@4:PROC
EXTRN	_EncryptDataUnitsCurrentThread@20:PROC
EXTRN	_DecryptDataUnitsCurrentThread@20:PROC
EXTRN	_derive_key_ripemd160@28:PROC
EXTRN	_derive_key_sha512@28:PROC
EXTRN	_derive_key_whirlpool@28:PROC
EXTRN	_derive_key_sha1@28:PROC
EXTRN	_GetMaxPkcs5OutSize@0:PROC
EXTRN	__imp_@ExReleaseFastMutex@4:PROC
EXTRN	__imp__KeWaitForSingleObject@20:PROC
EXTRN	__imp_@ExAcquireFastMutex@4:PROC
EXTRN	__imp__KeSetEvent@12:PROC
_BSS	SEGMENT
_WorkItemCompletedEvent DB 010H DUP (?)
_WorkItemReadyEvent DB 010H DUP (?)
_WorkItemQueue DB 02400H DUP (?)
_DequeuePosition DD 01H DUP (?)
_DequeueMutex DB 020H DUP (?)
; Function compile flags: /Ogsp
_BSS	ENDS
;	COMDAT _EncryptionThreadProc@4
_TEXT	SEGMENT
_threadArg$ = 8						; size = 4
_EncryptionThreadProc@4 PROC				; COMDAT

; 125  : 	EncryptionThreadPoolWorkItem *workItem;
; 126  : 
; 127  : 	while (!StopPending)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _StopPending
  00005	53		 push	 ebx
  00006	33 db		 xor	 ebx, ebx
  00008	85 c0		 test	 eax, eax
  0000a	0f 85 bb 01 00
	00		 jne	 $LN21@Encryption
  00010	57		 push	 edi
  00011	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__KeSetEvent@12
  00017	56		 push	 esi
$LL22@Encryption:

; 128  : 	{
; 129  : 		TC_ACQUIRE_MUTEX (&DequeueMutex);

  00018	b9 00 00 00 00	 mov	 ecx, OFFSET _DequeueMutex
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExAcquireFastMutex@4

; 130  : 
; 131  : 		workItem = &WorkItemQueue[DequeuePosition++];

  00023	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _DequeuePosition
  00029	6b f6 48	 imul	 esi, 72			; 00000048H
  0002c	81 c6 00 00 00
	00		 add	 esi, OFFSET _WorkItemQueue
  00032	ff 05 00 00 00
	00		 inc	 DWORD PTR _DequeuePosition

; 132  : 
; 133  : 		if (DequeuePosition >= TC_ENC_THREAD_POOL_QUEUE_SIZE)

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _DequeuePosition
  0003d	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00042	7c 24		 jl	 SHORT $LN35@Encryption

; 134  : 			DequeuePosition = 0;

  00044	89 1d 00 00 00
	00		 mov	 DWORD PTR _DequeuePosition, ebx

; 135  : 
; 136  : 		while (!StopPending && GetWorkItemState (workItem) != WorkItemReady)

  0004a	eb 1c		 jmp	 SHORT $LN35@Encryption
$LL19@Encryption:
  0004c	33 c0		 xor	 eax, eax
  0004e	8b ce		 mov	 ecx, esi
  00050	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  00054	83 f8 01	 cmp	 eax, 1
  00057	74 18		 je	 SHORT $LN18@Encryption

; 137  : 		{
; 138  : 			TC_WAIT_EVENT (WorkItemReadyEvent);

  00059	53		 push	 ebx
  0005a	53		 push	 ebx
  0005b	53		 push	 ebx
  0005c	53		 push	 ebx
  0005d	68 00 00 00 00	 push	 OFFSET _WorkItemReadyEvent
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
$LN35@Encryption:
  00068	a1 00 00 00 00	 mov	 eax, DWORD PTR _StopPending
  0006d	85 c0		 test	 eax, eax
  0006f	74 db		 je	 SHORT $LL19@Encryption
$LN18@Encryption:

; 139  : 		}
; 140  : 
; 141  : 		SetWorkItemState (workItem, WorkItemBusy);

  00071	6a 02		 push	 2
  00073	58		 pop	 eax
  00074	8b ce		 mov	 ecx, esi
  00076	87 01		 xchg	 DWORD PTR [ecx], eax

; 142  : 
; 143  : 		TC_RELEASE_MUTEX (&DequeueMutex);

  00078	b9 00 00 00 00	 mov	 ecx, OFFSET _DequeueMutex
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExReleaseFastMutex@4

; 144  : 
; 145  : 		if (StopPending)

  00083	a1 00 00 00 00	 mov	 eax, DWORD PTR _StopPending
  00088	85 c0		 test	 eax, eax
  0008a	0f 85 39 01 00
	00		 jne	 $LN42@Encryption

; 146  : 			break;
; 147  : 
; 148  : 		switch (workItem->Type)

  00090	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00093	2b c3		 sub	 eax, ebx
  00095	0f 84 de 00 00
	00		 je	 $LN13@Encryption
  0009b	48		 dec	 eax
  0009c	0f 84 c2 00 00
	00		 je	 $LN14@Encryption
  000a2	48		 dec	 eax
  000a3	0f 85 2d 01 00
	00		 jne	 $LN3@Encryption

; 156  : 			break;
; 157  : 
; 158  : 		case DeriveKeyWork:
; 159  : 			switch (workItem->KeyDerivation.Pkcs5Prf)

  000a9	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  000ac	48		 dec	 eax
  000ad	74 67		 je	 SHORT $LN9@Encryption
  000af	48		 dec	 eax
  000b0	74 46		 je	 SHORT $LN8@Encryption
  000b2	48		 dec	 eax
  000b3	74 25		 je	 SHORT $LN7@Encryption
  000b5	48		 dec	 eax
  000b6	0f 85 2e 01 00
	00		 jne	 $LN5@Encryption

; 175  : 
; 176  : 			case SHA1:
; 177  : 				derive_key_sha1 (workItem->KeyDerivation.Password, workItem->KeyDerivation.PasswordLength, workItem->KeyDerivation.Salt, PKCS5_SALT_SIZE,
; 178  : 					workItem->KeyDerivation.IterationCount, workItem->KeyDerivation.DerivedKey, GetMaxPkcs5OutSize());

  000bc	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize@0
  000c1	50		 push	 eax
  000c2	ff 76 28	 push	 DWORD PTR [esi+40]
  000c5	ff 76 2c	 push	 DWORD PTR [esi+44]
  000c8	6a 40		 push	 64			; 00000040H
  000ca	ff 76 44	 push	 DWORD PTR [esi+68]
  000cd	ff 76 3c	 push	 DWORD PTR [esi+60]
  000d0	ff 76 38	 push	 DWORD PTR [esi+56]
  000d3	e8 00 00 00 00	 call	 _derive_key_sha1@28

; 179  : 				break;

  000d8	eb 58		 jmp	 SHORT $LN10@Encryption
$LN7@Encryption:

; 170  : 
; 171  : 			case WHIRLPOOL:
; 172  : 				derive_key_whirlpool (workItem->KeyDerivation.Password, workItem->KeyDerivation.PasswordLength, workItem->KeyDerivation.Salt, PKCS5_SALT_SIZE,
; 173  : 					workItem->KeyDerivation.IterationCount, workItem->KeyDerivation.DerivedKey, GetMaxPkcs5OutSize());

  000da	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize@0
  000df	50		 push	 eax
  000e0	ff 76 28	 push	 DWORD PTR [esi+40]
  000e3	ff 76 2c	 push	 DWORD PTR [esi+44]
  000e6	6a 40		 push	 64			; 00000040H
  000e8	ff 76 44	 push	 DWORD PTR [esi+68]
  000eb	ff 76 3c	 push	 DWORD PTR [esi+60]
  000ee	ff 76 38	 push	 DWORD PTR [esi+56]
  000f1	e8 00 00 00 00	 call	 _derive_key_whirlpool@28

; 174  : 				break;

  000f6	eb 3a		 jmp	 SHORT $LN10@Encryption
$LN8@Encryption:

; 164  : 				break;
; 165  : 
; 166  : 			case SHA512:
; 167  : 				derive_key_sha512 (workItem->KeyDerivation.Password, workItem->KeyDerivation.PasswordLength, workItem->KeyDerivation.Salt, PKCS5_SALT_SIZE,
; 168  : 					workItem->KeyDerivation.IterationCount, workItem->KeyDerivation.DerivedKey, GetMaxPkcs5OutSize());

  000f8	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize@0
  000fd	50		 push	 eax
  000fe	ff 76 28	 push	 DWORD PTR [esi+40]
  00101	ff 76 2c	 push	 DWORD PTR [esi+44]
  00104	6a 40		 push	 64			; 00000040H
  00106	ff 76 44	 push	 DWORD PTR [esi+68]
  00109	ff 76 3c	 push	 DWORD PTR [esi+60]
  0010c	ff 76 38	 push	 DWORD PTR [esi+56]
  0010f	e8 00 00 00 00	 call	 _derive_key_sha512@28

; 169  : 				break;

  00114	eb 1c		 jmp	 SHORT $LN10@Encryption
$LN9@Encryption:

; 160  : 			{
; 161  : 			case RIPEMD160:
; 162  : 				derive_key_ripemd160 (workItem->KeyDerivation.Password, workItem->KeyDerivation.PasswordLength, workItem->KeyDerivation.Salt, PKCS5_SALT_SIZE,
; 163  : 					workItem->KeyDerivation.IterationCount, workItem->KeyDerivation.DerivedKey, GetMaxPkcs5OutSize());

  00116	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize@0
  0011b	50		 push	 eax
  0011c	ff 76 28	 push	 DWORD PTR [esi+40]
  0011f	ff 76 2c	 push	 DWORD PTR [esi+44]
  00122	6a 40		 push	 64			; 00000040H
  00124	ff 76 44	 push	 DWORD PTR [esi+68]
  00127	ff 76 3c	 push	 DWORD PTR [esi+60]
  0012a	ff 76 38	 push	 DWORD PTR [esi+56]
  0012d	e8 00 00 00 00	 call	 _derive_key_ripemd160@28
$LN10@Encryption:

; 183  : 			} 
; 184  : 
; 185  : 			InterlockedExchange (workItem->KeyDerivation.CompletionFlag, TRUE);

  00132	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00135	33 c0		 xor	 eax, eax
  00137	40		 inc	 eax
  00138	87 01		 xchg	 DWORD PTR [ecx], eax

; 186  : 			TC_SET_EVENT (*workItem->KeyDerivation.CompletionEvent);

  0013a	53		 push	 ebx
  0013b	6a 01		 push	 1
  0013d	ff 76 20	 push	 DWORD PTR [esi+32]
  00140	ff d7		 call	 edi

; 187  : 			
; 188  : 			if (InterlockedDecrement (workItem->KeyDerivation.OutstandingWorkItemCount) == 0)

  00142	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00145	83 c9 ff	 or	 ecx, -1
  00148	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  0014c	75 08		 jne	 SHORT $LN4@Encryption

; 189  : 				TC_SET_EVENT (*workItem->KeyDerivation.NoOutstandingWorkItemEvent);

  0014e	53		 push	 ebx
  0014f	6a 01		 push	 1
  00151	ff 76 30	 push	 DWORD PTR [esi+48]
  00154	ff d7		 call	 edi
$LN4@Encryption:

; 190  : 
; 191  : 			SetWorkItemState (workItem, WorkItemFree);

  00156	33 c0		 xor	 eax, eax
  00158	87 06		 xchg	 DWORD PTR [esi], eax

; 192  : 			TC_SET_EVENT (WorkItemCompletedEvent);

  0015a	53		 push	 ebx
  0015b	6a 01		 push	 1
  0015d	68 00 00 00 00	 push	 OFFSET _WorkItemCompletedEvent

; 193  : 			continue;

  00162	eb 56		 jmp	 SHORT $LN45@Encryption
$LN14@Encryption:

; 149  : 		{
; 150  : 		case DecryptDataUnitsWork:
; 151  : 			DecryptDataUnitsCurrentThread (workItem->Encryption.Data, &workItem->Encryption.StartUnitNo, workItem->Encryption.UnitCount, workItem->Encryption.CryptoInfo);

  00164	ff 76 20	 push	 DWORD PTR [esi+32]
  00167	8d 46 28	 lea	 eax, DWORD PTR [esi+40]
  0016a	53		 push	 ebx
  0016b	ff 76 30	 push	 DWORD PTR [esi+48]
  0016e	50		 push	 eax
  0016f	ff 76 24	 push	 DWORD PTR [esi+36]
  00172	e8 00 00 00 00	 call	 _DecryptDataUnitsCurrentThread@20

; 152  : 			break;

  00177	eb 13		 jmp	 SHORT $LN15@Encryption
$LN13@Encryption:

; 153  : 
; 154  : 		case EncryptDataUnitsWork:
; 155  : 			EncryptDataUnitsCurrentThread (workItem->Encryption.Data, &workItem->Encryption.StartUnitNo, workItem->Encryption.UnitCount, workItem->Encryption.CryptoInfo);

  00179	ff 76 20	 push	 DWORD PTR [esi+32]
  0017c	8d 46 28	 lea	 eax, DWORD PTR [esi+40]
  0017f	53		 push	 ebx
  00180	ff 76 30	 push	 DWORD PTR [esi+48]
  00183	50		 push	 eax
  00184	ff 76 24	 push	 DWORD PTR [esi+36]
  00187	e8 00 00 00 00	 call	 _EncryptDataUnitsCurrentThread@20
$LN15@Encryption:

; 194  : 
; 195  : 		default:
; 196  : 			TC_THROW_FATAL_EXCEPTION;
; 197  : 		}
; 198  : 
; 199  : 		if (workItem != workItem->FirstFragment)

  0018c	3b 76 18	 cmp	 esi, DWORD PTR [esi+24]
  0018f	74 10		 je	 SHORT $LN2@Encryption

; 200  : 		{
; 201  : 			SetWorkItemState (workItem, WorkItemFree);

  00191	33 c0		 xor	 eax, eax
  00193	8b ce		 mov	 ecx, esi
  00195	87 01		 xchg	 DWORD PTR [ecx], eax

; 202  : 			TC_SET_EVENT (WorkItemCompletedEvent);

  00197	53		 push	 ebx
  00198	6a 01		 push	 1
  0019a	68 00 00 00 00	 push	 OFFSET _WorkItemCompletedEvent
  0019f	ff d7		 call	 edi
$LN2@Encryption:

; 203  : 		}
; 204  : 
; 205  : 		if (InterlockedDecrement (&workItem->FirstFragment->OutstandingFragmentCount) == 0)

  001a1	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  001a4	83 c0 1c	 add	 eax, 28			; 0000001cH
  001a7	83 c9 ff	 or	 ecx, -1
  001aa	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  001ae	75 0c		 jne	 SHORT $LN1@Encryption

; 206  : 			TC_SET_EVENT (workItem->FirstFragment->ItemCompletedEvent);

  001b0	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  001b3	53		 push	 ebx
  001b4	6a 01		 push	 1
  001b6	83 c0 08	 add	 eax, 8
  001b9	50		 push	 eax
$LN45@Encryption:
  001ba	ff d7		 call	 edi
$LN1@Encryption:

; 125  : 	EncryptionThreadPoolWorkItem *workItem;
; 126  : 
; 127  : 	while (!StopPending)

  001bc	a1 00 00 00 00	 mov	 eax, DWORD PTR _StopPending
  001c1	85 c0		 test	 eax, eax
  001c3	0f 84 4f fe ff
	ff		 je	 $LL22@Encryption
$LN42@Encryption:
  001c9	5e		 pop	 esi
  001ca	5f		 pop	 edi
$LN21@Encryption:

; 207  : 	}
; 208  : 
; 209  : #ifdef DEVICE_DRIVER
; 210  : 	PsTerminateSystemThread (STATUS_SUCCESS);

  001cb	53		 push	 ebx
  001cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsTerminateSystemThread@4
  001d2	5b		 pop	 ebx

; 211  : #else
; 212  : 	_endthreadex (0);
; 213  :     return 0;
; 214  : #endif
; 215  : }

  001d3	c2 04 00	 ret	 4
$LN3@Encryption:
  001d6	68 43 54 00 00	 push	 21571			; 00005443H
  001db	53		 push	 ebx
  001dc	53		 push	 ebx
  001dd	68 c4 00 00 00	 push	 196			; 000000c4H
$LN46@Encryption:
  001e2	6a 29		 push	 41			; 00000029H
  001e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN47@Encryption:
$LN5@Encryption:

; 180  : 
; 181  : 			default:		
; 182  : 				TC_THROW_FATAL_EXCEPTION;

  001ea	68 43 54 00 00	 push	 21571			; 00005443H
  001ef	53		 push	 ebx
  001f0	53		 push	 ebx
  001f1	68 b6 00 00 00	 push	 182			; 000000b6H
  001f6	eb ea		 jmp	 SHORT $LN46@Encryption
$LN43@Encryption:
_EncryptionThreadProc@4 ENDP
_TEXT	ENDS
PUBLIC	_EncryptionThreadPoolStop@0
EXTRN	_TCStopThread@8:PROC
_BSS	SEGMENT
_ThreadHandles DD 040H DUP (?)
_ThreadCount DD	01H DUP (?)
; Function compile flags: /Ogsp
_BSS	ENDS
;	COMDAT _EncryptionThreadPoolStop@0
_TEXT	SEGMENT
_EncryptionThreadPoolStop@0 PROC			; COMDAT

; 312  : 	size_t i;
; 313  : 
; 314  : 	if (!ThreadPoolRunning)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _ThreadPoolRunning
  00005	85 c0		 test	 eax, eax
  00007	74 4c		 je	 SHORT $LN5@Encryption@2
  00009	56		 push	 esi
  0000a	57		 push	 edi

; 315  : 		return;
; 316  : 
; 317  : 	StopPending = TRUE;

  0000b	33 c0		 xor	 eax, eax
  0000d	40		 inc	 eax

; 318  : 	TC_SET_EVENT (WorkItemReadyEvent);

  0000e	6a 00		 push	 0
  00010	50		 push	 eax
  00011	be 00 00 00 00	 mov	 esi, OFFSET _WorkItemReadyEvent
  00016	56		 push	 esi
  00017	a3 00 00 00 00	 mov	 DWORD PTR _StopPending, eax
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 319  : 
; 320  : 	for (i = 0; i < ThreadCount; ++i)

  00022	33 ff		 xor	 edi, edi
  00024	39 3d 00 00 00
	00		 cmp	 DWORD PTR _ThreadCount, edi
  0002a	76 16		 jbe	 SHORT $LN1@Encryption@2
$LL3@Encryption@2:

; 321  : 	{
; 322  : #ifdef DEVICE_DRIVER
; 323  : 		TCStopThread (ThreadHandles[i], &WorkItemReadyEvent);

  0002c	56		 push	 esi
  0002d	ff 34 bd 00 00
	00 00		 push	 DWORD PTR _ThreadHandles[edi*4]
  00034	e8 00 00 00 00	 call	 _TCStopThread@8
  00039	47		 inc	 edi
  0003a	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR _ThreadCount
  00040	72 ea		 jb	 SHORT $LL3@Encryption@2
$LN1@Encryption@2:

; 324  : #else
; 325  : 		TC_WAIT_EVENT (ThreadHandles[i]);
; 326  : #endif
; 327  : 	}
; 328  : 
; 329  : 	ThreadCount = 0;

  00042	83 25 00 00 00
	00 00		 and	 DWORD PTR _ThreadCount, 0
  00049	5f		 pop	 edi

; 330  : 
; 331  : #ifndef DEVICE_DRIVER
; 332  : 	CloseHandle (DequeueMutex);
; 333  : 	CloseHandle (EnqueueMutex);
; 334  : 
; 335  : 	CloseHandle (WorkItemReadyEvent);
; 336  : 	CloseHandle (WorkItemCompletedEvent);
; 337  : 
; 338  : 	for (i = 0; i < sizeof (WorkItemQueue) / sizeof (WorkItemQueue[0]); ++i)
; 339  : 	{
; 340  : 		if (WorkItemQueue[i].ItemCompletedEvent)
; 341  : 			CloseHandle (WorkItemQueue[i].ItemCompletedEvent);
; 342  : 	}
; 343  : #endif
; 344  : 
; 345  : 	ThreadPoolRunning = FALSE;

  0004a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ThreadPoolRunning, 0
  00054	5e		 pop	 esi
$LN5@Encryption@2:

; 346  : }

  00055	c3		 ret	 0
_EncryptionThreadPoolStop@0 ENDP
_TEXT	ENDS
PUBLIC	_EncryptionThreadPoolBeginKeyDerivation@40
EXTRN	__imp__KeClearEvent@4:PROC
_BSS	SEGMENT
_EnqueuePosition DD 01H DUP (?)
_EnqueueMutex DB 020H DUP (?)
; Function compile flags: /Ogsp
_BSS	ENDS
;	COMDAT _EncryptionThreadPoolBeginKeyDerivation@40
_TEXT	SEGMENT
_completionEvent$ = 8					; size = 4
_noOutstandingWorkItemEvent$ = 12			; size = 4
_completionFlag$ = 16					; size = 4
_outstandingWorkItemCount$ = 20				; size = 4
_pkcs5Prf$ = 24						; size = 4
_password$ = 28						; size = 4
_passwordLength$ = 32					; size = 4
_salt$ = 36						; size = 4
_iterationCount$ = 40					; size = 4
_derivedKey$ = 44					; size = 4
_EncryptionThreadPoolBeginKeyDerivation@40 PROC		; COMDAT

; 350  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 351  : 	EncryptionThreadPoolWorkItem *workItem;
; 352  : 
; 353  : 	if (!ThreadPoolRunning)

  00005	a1 00 00 00 00	 mov	 eax, DWORD PTR _ThreadPoolRunning
  0000a	53		 push	 ebx
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	85 c0		 test	 eax, eax
  0000f	75 16		 jne	 SHORT $LN4@Encryption@3

; 354  : 		TC_THROW_FATAL_EXCEPTION;

  00011	68 43 54 00 00	 push	 21571			; 00005443H
  00016	33 db		 xor	 ebx, ebx
  00018	53		 push	 ebx
  00019	53		 push	 ebx
  0001a	68 62 01 00 00	 push	 354			; 00000162H
  0001f	6a 29		 push	 41			; 00000029H
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN15@Encryption@3:
$LN4@Encryption@3:

; 355  : 
; 356  : 	TC_ACQUIRE_MUTEX (&EnqueueMutex);

  00027	bf 00 00 00 00	 mov	 edi, OFFSET _EnqueueMutex
  0002c	8b cf		 mov	 ecx, edi
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExAcquireFastMutex@4

; 357  : 
; 358  : 	workItem = &WorkItemQueue[EnqueuePosition++];

  00034	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _EnqueuePosition
  0003a	6b f6 48	 imul	 esi, 72			; 00000048H
  0003d	81 c6 00 00 00
	00		 add	 esi, OFFSET _WorkItemQueue
  00043	ff 05 00 00 00
	00		 inc	 DWORD PTR _EnqueuePosition

; 359  : 	if (EnqueuePosition >= TC_ENC_THREAD_POOL_QUEUE_SIZE)

  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR _EnqueuePosition
  0004e	33 db		 xor	 ebx, ebx
  00050	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00055	7c 17		 jl	 SHORT $LN11@Encryption@3

; 360  : 		EnqueuePosition = 0;

  00057	89 1d 00 00 00
	00		 mov	 DWORD PTR _EnqueuePosition, ebx

; 361  : 
; 362  : 	while (GetWorkItemState (workItem) != WorkItemFree)

  0005d	eb 0f		 jmp	 SHORT $LN11@Encryption@3
$LL2@Encryption@3:

; 363  : 	{
; 364  : 		TC_WAIT_EVENT (WorkItemCompletedEvent);

  0005f	53		 push	 ebx
  00060	53		 push	 ebx
  00061	53		 push	 ebx
  00062	53		 push	 ebx
  00063	68 00 00 00 00	 push	 OFFSET _WorkItemCompletedEvent
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
$LN11@Encryption@3:
  0006e	8b ce		 mov	 ecx, esi
  00070	33 c0		 xor	 eax, eax
  00072	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  00076	85 c0		 test	 eax, eax
  00078	75 e5		 jne	 SHORT $LL2@Encryption@3

; 365  : 	}
; 366  : 
; 367  : 	workItem->Type = DeriveKeyWork;
; 368  : 	workItem->KeyDerivation.CompletionEvent = completionEvent;

  0007a	8b 45 08	 mov	 eax, DWORD PTR _completionEvent$[ebp]

; 369  : 	workItem->KeyDerivation.CompletionFlag = completionFlag;
; 370  : 	workItem->KeyDerivation.DerivedKey = derivedKey;
; 371  : 	workItem->KeyDerivation.IterationCount = iterationCount;
; 372  : 	workItem->KeyDerivation.NoOutstandingWorkItemEvent = noOutstandingWorkItemEvent;
; 373  : 	workItem->KeyDerivation.OutstandingWorkItemCount = outstandingWorkItemCount;
; 374  : 	workItem->KeyDerivation.Password = password;

  0007d	8b 55 1c	 mov	 edx, DWORD PTR _password$[ebp]
  00080	8b 4d 14	 mov	 ecx, DWORD PTR _outstandingWorkItemCount$[ebp]
  00083	89 56 38	 mov	 DWORD PTR [esi+56], edx

; 375  : 	workItem->KeyDerivation.PasswordLength = passwordLength;

  00086	8b 55 20	 mov	 edx, DWORD PTR _passwordLength$[ebp]
  00089	89 46 20	 mov	 DWORD PTR [esi+32], eax
  0008c	8b 45 10	 mov	 eax, DWORD PTR _completionFlag$[ebp]
  0008f	89 56 3c	 mov	 DWORD PTR [esi+60], edx

; 376  : 	workItem->KeyDerivation.Pkcs5Prf = pkcs5Prf;

  00092	8b 55 18	 mov	 edx, DWORD PTR _pkcs5Prf$[ebp]
  00095	89 46 24	 mov	 DWORD PTR [esi+36], eax
  00098	8b 45 2c	 mov	 eax, DWORD PTR _derivedKey$[ebp]
  0009b	89 56 40	 mov	 DWORD PTR [esi+64], edx

; 377  : 	workItem->KeyDerivation.Salt = salt;

  0009e	8b 55 24	 mov	 edx, DWORD PTR _salt$[ebp]
  000a1	89 46 28	 mov	 DWORD PTR [esi+40], eax
  000a4	8b 45 28	 mov	 eax, DWORD PTR _iterationCount$[ebp]
  000a7	89 56 44	 mov	 DWORD PTR [esi+68], edx
  000aa	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  000ad	8b 45 0c	 mov	 eax, DWORD PTR _noOutstandingWorkItemEvent$[ebp]

; 378  : 
; 379  : 	InterlockedIncrement (outstandingWorkItemCount);

  000b0	33 d2		 xor	 edx, edx
  000b2	c7 46 04 02 00
	00 00		 mov	 DWORD PTR [esi+4], 2
  000b9	89 46 30	 mov	 DWORD PTR [esi+48], eax
  000bc	89 4e 34	 mov	 DWORD PTR [esi+52], ecx
  000bf	42		 inc	 edx
  000c0	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx

; 380  : 	TC_CLEAR_EVENT (*noOutstandingWorkItemEvent);

  000c4	50		 push	 eax
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeClearEvent@4

; 381  : 
; 382  : 	SetWorkItemState (workItem, WorkItemReady);

  000cb	33 c0		 xor	 eax, eax
  000cd	40		 inc	 eax
  000ce	87 06		 xchg	 DWORD PTR [esi], eax

; 383  : 	TC_SET_EVENT (WorkItemReadyEvent);

  000d0	53		 push	 ebx
  000d1	6a 01		 push	 1
  000d3	68 00 00 00 00	 push	 OFFSET _WorkItemReadyEvent
  000d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 384  : 	TC_RELEASE_MUTEX (&EnqueueMutex);

  000de	8b cf		 mov	 ecx, edi
  000e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExReleaseFastMutex@4
  000e6	5f		 pop	 edi
  000e7	5e		 pop	 esi
  000e8	5b		 pop	 ebx

; 385  : }

  000e9	5d		 pop	 ebp
  000ea	c2 28 00	 ret	 40			; 00000028H
$LN13@Encryption@3:
_EncryptionThreadPoolBeginKeyDerivation@40 ENDP
_TEXT	ENDS
PUBLIC	_EncryptionThreadPoolDoWork@20
; Function compile flags: /Ogsp
;	COMDAT _EncryptionThreadPoolDoWork@20
_TEXT	SEGMENT
_fragmentStartUnitNo$ = -16				; size = 8
_remainder$ = -8					; size = 4
_fragmentCount$ = -4					; size = 4
_type$ = 8						; size = 4
_fragmentData$ = 12					; size = 4
_data$ = 12						; size = 4
tv304 = 16						; size = 4
_startUnitNo$ = 16					; size = 4
_unitsPerFragment$ = 20					; size = 4
_unitCount$ = 20					; size = 4
_cryptoInfo$ = 24					; size = 4
_EncryptionThreadPoolDoWork@20 PROC			; COMDAT

; 389  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 390  : 	uint32 fragmentCount;
; 391  : 	uint32 unitsPerFragment;
; 392  : 	uint32 remainder;
; 393  : 
; 394  : 	byte *fragmentData;
; 395  : 	uint64 fragmentStartUnitNo;
; 396  : 
; 397  : 	EncryptionThreadPoolWorkItem *workItem;
; 398  : 	EncryptionThreadPoolWorkItem *firstFragmentWorkItem;
; 399  : 	
; 400  : 	if (unitCount == 0)

  00005	8b 45 14	 mov	 eax, DWORD PTR _unitCount$[ebp]
  00008	83 ec 10	 sub	 esp, 16			; 00000010H
  0000b	53		 push	 ebx
  0000c	33 db		 xor	 ebx, ebx
  0000e	3b c3		 cmp	 eax, ebx
  00010	0f 84 bf 01 00
	00		 je	 $LN15@Encryption@4

; 401  : 		return;
; 402  : 	
; 403  : 	if (!ThreadPoolRunning || unitCount == 1)

  00016	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ThreadPoolRunning
  0001c	85 c9		 test	 ecx, ecx
  0001e	0f 84 71 01 00
	00		 je	 $LN17@Encryption@4
  00024	33 d2		 xor	 edx, edx
  00026	42		 inc	 edx
  00027	3b c2		 cmp	 eax, edx
  00029	0f 84 66 01 00
	00		 je	 $LN17@Encryption@4

; 417  : 		}
; 418  : 
; 419  : 		return;
; 420  : 	}
; 421  : 
; 422  : 	if (unitCount <= ThreadCount)

  0002f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ThreadCount
  00035	3b c1		 cmp	 eax, ecx
  00037	77 0b		 ja	 SHORT $LN11@Encryption@4

; 423  : 	{
; 424  : 		fragmentCount = unitCount;

  00039	89 45 fc	 mov	 DWORD PTR _fragmentCount$[ebp], eax

; 425  : 		unitsPerFragment = 1;

  0003c	89 55 14	 mov	 DWORD PTR _unitsPerFragment$[ebp], edx

; 426  : 		remainder = 0;

  0003f	89 5d f8	 mov	 DWORD PTR _remainder$[ebp], ebx

; 427  : 	}
; 428  : 	else

  00042	eb 14		 jmp	 SHORT $LN37@Encryption@4
$LN11@Encryption@4:

; 429  : 	{
; 430  : 		/* Note that it is not efficient to divide the data into fragments smaller than a few hundred bytes.
; 431  : 		The reason is that the overhead associated with thread handling would in most cases make a multi-threaded 
; 432  : 		process actually slower than a single-threaded process. */
; 433  : 
; 434  : 		fragmentCount = ThreadCount;
; 435  : 		unitsPerFragment = unitCount / ThreadCount;

  00044	33 d2		 xor	 edx, edx
  00046	f7 f1		 div	 ecx
  00048	89 4d fc	 mov	 DWORD PTR _fragmentCount$[ebp], ecx
  0004b	89 45 14	 mov	 DWORD PTR _unitsPerFragment$[ebp], eax

; 436  : 		remainder = unitCount % ThreadCount;

  0004e	89 55 f8	 mov	 DWORD PTR _remainder$[ebp], edx

; 437  : 
; 438  : 		if (remainder > 0)

  00051	3b d3		 cmp	 edx, ebx
  00053	76 03		 jbe	 SHORT $LN37@Encryption@4

; 439  : 			++unitsPerFragment;

  00055	ff 45 14	 inc	 DWORD PTR _unitsPerFragment$[ebp]
$LN37@Encryption@4:

; 440  : 	}
; 441  : 	
; 442  : 	fragmentData = data;

  00058	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0005b	89 45 0c	 mov	 DWORD PTR _fragmentData$[ebp], eax

; 443  : 	fragmentStartUnitNo = startUnitNo->Value;

  0005e	8b 45 10	 mov	 eax, DWORD PTR _startUnitNo$[ebp]
  00061	8b 08		 mov	 ecx, DWORD PTR [eax]
  00063	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00066	89 4d f0	 mov	 DWORD PTR _fragmentStartUnitNo$[ebp], ecx
  00069	57		 push	 edi

; 444  : 
; 445  : 	TC_ACQUIRE_MUTEX (&EnqueueMutex);

  0006a	b9 00 00 00 00	 mov	 ecx, OFFSET _EnqueueMutex
  0006f	89 45 f4	 mov	 DWORD PTR _fragmentStartUnitNo$[ebp+4], eax
  00072	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExAcquireFastMutex@4

; 446  : 	firstFragmentWorkItem = &WorkItemQueue[EnqueuePosition];

  00078	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _EnqueuePosition
  0007e	6b ff 48	 imul	 edi, 72			; 00000048H
  00081	81 c7 00 00 00
	00		 add	 edi, OFFSET _WorkItemQueue

; 447  : 
; 448  : 	while (GetWorkItemState (firstFragmentWorkItem) != WorkItemFree)

  00087	eb 0f		 jmp	 SHORT $LN41@Encryption@4
$LL8@Encryption@4:

; 449  : 	{
; 450  : 		TC_WAIT_EVENT (WorkItemCompletedEvent);

  00089	53		 push	 ebx
  0008a	53		 push	 ebx
  0008b	53		 push	 ebx
  0008c	53		 push	 ebx
  0008d	68 00 00 00 00	 push	 OFFSET _WorkItemCompletedEvent
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
$LN41@Encryption@4:
  00098	8b cf		 mov	 ecx, edi
  0009a	33 c0		 xor	 eax, eax
  0009c	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  000a0	85 c0		 test	 eax, eax
  000a2	75 e5		 jne	 SHORT $LL8@Encryption@4

; 451  : 	}
; 452  : 
; 453  : 	firstFragmentWorkItem->OutstandingFragmentCount = fragmentCount;

  000a4	8b 45 fc	 mov	 eax, DWORD PTR _fragmentCount$[ebp]
  000a7	89 47 1c	 mov	 DWORD PTR [edi+28], eax

; 454  : 
; 455  : 	while (fragmentCount-- > 0)

  000aa	3b c3		 cmp	 eax, ebx
  000ac	0f 86 b5 00 00
	00		 jbe	 $LN35@Encryption@4
  000b2	8b 45 14	 mov	 eax, DWORD PTR _unitsPerFragment$[ebp]
  000b5	c1 e0 09	 shl	 eax, 9
  000b8	89 45 10	 mov	 DWORD PTR tv304[ebp], eax
  000bb	56		 push	 esi
$LL6@Encryption@4:

; 456  : 	{
; 457  : 		workItem = &WorkItemQueue[EnqueuePosition++];

  000bc	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _EnqueuePosition
  000c2	ff 4d fc	 dec	 DWORD PTR _fragmentCount$[ebp]
  000c5	6b f6 48	 imul	 esi, 72			; 00000048H
  000c8	81 c6 00 00 00
	00		 add	 esi, OFFSET _WorkItemQueue
  000ce	ff 05 00 00 00
	00		 inc	 DWORD PTR _EnqueuePosition

; 458  : 		if (EnqueuePosition >= TC_ENC_THREAD_POOL_QUEUE_SIZE)

  000d4	a1 00 00 00 00	 mov	 eax, DWORD PTR _EnqueuePosition
  000d9	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  000de	7c 17		 jl	 SHORT $LN32@Encryption@4

; 459  : 			EnqueuePosition = 0;

  000e0	89 1d 00 00 00
	00		 mov	 DWORD PTR _EnqueuePosition, ebx

; 460  : 
; 461  : 		while (GetWorkItemState (workItem) != WorkItemFree)

  000e6	eb 0f		 jmp	 SHORT $LN32@Encryption@4
$LL3@Encryption@4:

; 462  : 		{
; 463  : 			TC_WAIT_EVENT (WorkItemCompletedEvent);

  000e8	53		 push	 ebx
  000e9	53		 push	 ebx
  000ea	53		 push	 ebx
  000eb	53		 push	 ebx
  000ec	68 00 00 00 00	 push	 OFFSET _WorkItemCompletedEvent
  000f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
$LN32@Encryption@4:
  000f7	8b ce		 mov	 ecx, esi
  000f9	33 c0		 xor	 eax, eax
  000fb	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  000ff	85 c0		 test	 eax, eax
  00101	75 e5		 jne	 SHORT $LL3@Encryption@4

; 464  : 		}
; 465  : 
; 466  : 		workItem->Type = type;

  00103	8b 45 08	 mov	 eax, DWORD PTR _type$[ebp]

; 467  : 		workItem->FirstFragment = firstFragmentWorkItem;
; 468  : 
; 469  : 		workItem->Encryption.CryptoInfo = cryptoInfo;
; 470  : 		workItem->Encryption.Data = fragmentData;
; 471  : 		workItem->Encryption.UnitCount = unitsPerFragment;
; 472  : 		workItem->Encryption.StartUnitNo.Value = fragmentStartUnitNo;

  00106	8b 4d f0	 mov	 ecx, DWORD PTR _fragmentStartUnitNo$[ebp]
  00109	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0010c	8b 45 18	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  0010f	89 4e 28	 mov	 DWORD PTR [esi+40], ecx
  00112	8b 4d f4	 mov	 ecx, DWORD PTR _fragmentStartUnitNo$[ebp+4]
  00115	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00118	8b 45 0c	 mov	 eax, DWORD PTR _fragmentData$[ebp]
  0011b	89 4e 2c	 mov	 DWORD PTR [esi+44], ecx

; 473  : 
; 474  :  		fragmentData += unitsPerFragment * ENCRYPTION_DATA_UNIT_SIZE;

  0011e	8b 4d 10	 mov	 ecx, DWORD PTR tv304[ebp]
  00121	01 4d 0c	 add	 DWORD PTR _fragmentData$[ebp], ecx
  00124	89 46 24	 mov	 DWORD PTR [esi+36], eax
  00127	8b 45 14	 mov	 eax, DWORD PTR _unitsPerFragment$[ebp]

; 475  : 		fragmentStartUnitNo += unitsPerFragment;

  0012a	01 45 f0	 add	 DWORD PTR _fragmentStartUnitNo$[ebp], eax
  0012d	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  00130	89 46 30	 mov	 DWORD PTR [esi+48], eax
  00133	11 5d f4	 adc	 DWORD PTR _fragmentStartUnitNo$[ebp+4], ebx

; 476  : 
; 477  : 		if (remainder > 0 && --remainder == 0)

  00136	39 5d f8	 cmp	 DWORD PTR _remainder$[ebp], ebx
  00139	76 0f		 jbe	 SHORT $LN1@Encryption@4
  0013b	ff 4d f8	 dec	 DWORD PTR _remainder$[ebp]
  0013e	75 0a		 jne	 SHORT $LN1@Encryption@4

; 478  : 			--unitsPerFragment;

  00140	ff 4d 14	 dec	 DWORD PTR _unitsPerFragment$[ebp]
  00143	81 6d 10 00 02
	00 00		 sub	 DWORD PTR tv304[ebp], 512 ; 00000200H
$LN1@Encryption@4:

; 479  : 
; 480  : 		SetWorkItemState (workItem, WorkItemReady);

  0014a	33 c0		 xor	 eax, eax
  0014c	40		 inc	 eax
  0014d	87 06		 xchg	 DWORD PTR [esi], eax

; 481  : 		TC_SET_EVENT (WorkItemReadyEvent);

  0014f	53		 push	 ebx
  00150	6a 01		 push	 1
  00152	68 00 00 00 00	 push	 OFFSET _WorkItemReadyEvent
  00157	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
  0015d	39 5d fc	 cmp	 DWORD PTR _fragmentCount$[ebp], ebx
  00160	0f 87 56 ff ff
	ff		 ja	 $LL6@Encryption@4
  00166	5e		 pop	 esi
$LN35@Encryption@4:

; 482  : 	}
; 483  : 
; 484  : 	TC_RELEASE_MUTEX (&EnqueueMutex);

  00167	b9 00 00 00 00	 mov	 ecx, OFFSET _EnqueueMutex
  0016c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExReleaseFastMutex@4

; 485  : 
; 486  : 	TC_WAIT_EVENT (firstFragmentWorkItem->ItemCompletedEvent);

  00172	53		 push	 ebx
  00173	53		 push	 ebx
  00174	53		 push	 ebx
  00175	53		 push	 ebx
  00176	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  00179	50		 push	 eax
  0017a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 487  : 	SetWorkItemState (firstFragmentWorkItem, WorkItemFree);

  00180	33 c0		 xor	 eax, eax
  00182	87 07		 xchg	 DWORD PTR [edi], eax

; 488  : 	TC_SET_EVENT (WorkItemCompletedEvent);

  00184	53		 push	 ebx
  00185	6a 01		 push	 1
  00187	68 00 00 00 00	 push	 OFFSET _WorkItemCompletedEvent
  0018c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
  00192	5f		 pop	 edi
  00193	eb 40		 jmp	 SHORT $LN15@Encryption@4
$LN17@Encryption@4:

; 404  : 	{
; 405  : 		switch (type)

  00195	8b 4d 08	 mov	 ecx, DWORD PTR _type$[ebp]
  00198	2b cb		 sub	 ecx, ebx
  0019a	74 29		 je	 SHORT $LN13@Encryption@4
  0019c	49		 dec	 ecx
  0019d	74 14		 je	 SHORT $LN14@Encryption@4

; 413  : 			break;
; 414  : 
; 415  : 		default:
; 416  : 			TC_THROW_FATAL_EXCEPTION;

  0019f	68 43 54 00 00	 push	 21571			; 00005443H
  001a4	53		 push	 ebx
  001a5	53		 push	 ebx
  001a6	68 a0 01 00 00	 push	 416			; 000001a0H
  001ab	6a 29		 push	 41			; 00000029H
  001ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN43@Encryption@4:
$LN14@Encryption@4:

; 406  : 		{
; 407  : 		case DecryptDataUnitsWork:
; 408  : 			DecryptDataUnitsCurrentThread (data, startUnitNo, unitCount, cryptoInfo);

  001b3	ff 75 18	 push	 DWORD PTR _cryptoInfo$[ebp]
  001b6	53		 push	 ebx
  001b7	50		 push	 eax
  001b8	ff 75 10	 push	 DWORD PTR _startUnitNo$[ebp]
  001bb	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  001be	e8 00 00 00 00	 call	 _DecryptDataUnitsCurrentThread@20

; 409  : 			break;

  001c3	eb 10		 jmp	 SHORT $LN15@Encryption@4
$LN13@Encryption@4:

; 410  : 
; 411  : 		case EncryptDataUnitsWork:
; 412  : 			EncryptDataUnitsCurrentThread (data, startUnitNo, unitCount, cryptoInfo);

  001c5	ff 75 18	 push	 DWORD PTR _cryptoInfo$[ebp]
  001c8	53		 push	 ebx
  001c9	50		 push	 eax
  001ca	ff 75 10	 push	 DWORD PTR _startUnitNo$[ebp]
  001cd	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  001d0	e8 00 00 00 00	 call	 _EncryptDataUnitsCurrentThread@20
$LN15@Encryption@4:
  001d5	5b		 pop	 ebx

; 489  : }

  001d6	c9		 leave
  001d7	c2 14 00	 ret	 20			; 00000014H
$LN39@Encryption@4:
_EncryptionThreadPoolDoWork@20 ENDP
_TEXT	ENDS
PUBLIC	_GetEncryptionThreadCount@0
; Function compile flags: /Ogsp
;	COMDAT _GetEncryptionThreadCount@0
_TEXT	SEGMENT
_GetEncryptionThreadCount@0 PROC			; COMDAT

; 494  : 	return ThreadPoolRunning ? ThreadCount : 0;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _ThreadPoolRunning
  00005	f7 d8		 neg	 eax
  00007	1b c0		 sbb	 eax, eax
  00009	23 05 00 00 00
	00		 and	 eax, DWORD PTR _ThreadCount

; 495  : }

  0000f	c3		 ret	 0
_GetEncryptionThreadCount@0 ENDP
_TEXT	ENDS
PUBLIC	_GetMaxEncryptionThreadCount@0
; Function compile flags: /Ogsp
;	COMDAT _GetMaxEncryptionThreadCount@0
_TEXT	SEGMENT
_GetMaxEncryptionThreadCount@0 PROC			; COMDAT

; 500  : 	return TC_ENC_THREAD_POOL_MAX_THREAD_COUNT;

  00000	6a 40		 push	 64			; 00000040H
  00002	58		 pop	 eax

; 501  : }

  00003	c3		 ret	 0
_GetMaxEncryptionThreadCount@0 ENDP
_TEXT	ENDS
PUBLIC	_IsEncryptionThreadPoolRunning@0
; Function compile flags: /Ogsp
;	COMDAT _IsEncryptionThreadPoolRunning@0
_TEXT	SEGMENT
_IsEncryptionThreadPoolRunning@0 PROC			; COMDAT

; 506  : 	return ThreadPoolRunning;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _ThreadPoolRunning

; 507  : }

  00005	c3		 ret	 0
_IsEncryptionThreadPoolRunning@0 ENDP
_TEXT	ENDS
PUBLIC	_EncryptionThreadPoolStart@4
EXTRN	_TCStartThread@12:PROC
EXTRN	_GetCpuCount@0:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogsp
;	COMDAT _EncryptionThreadPoolStart@4
_TEXT	SEGMENT
tv230 = -8						; size = 4
_cpuCount$ = -4						; size = 4
tv205 = 8						; size = 4
_encryptionFreeCpuCount$ = 8				; size = 4
_EncryptionThreadPoolStart@4 PROC			; COMDAT

; 219  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	51		 push	 ecx

; 220  : 	size_t cpuCount, i;
; 221  : 
; 222  : 	if (ThreadPoolRunning)

  00007	a1 00 00 00 00	 mov	 eax, DWORD PTR _ThreadPoolRunning
  0000c	85 c0		 test	 eax, eax
  0000e	74 08		 je	 SHORT $LN11@Encryption@5
$LN26@Encryption@5:

; 223  : 		return TRUE;

  00010	33 c0		 xor	 eax, eax
  00012	40		 inc	 eax
  00013	e9 fd 00 00 00	 jmp	 $LN12@Encryption@5
$LN11@Encryption@5:

; 224  : 
; 225  : #ifdef DEVICE_DRIVER
; 226  : 	cpuCount = GetCpuCount();

  00018	e8 00 00 00 00	 call	 _GetCpuCount@0
  0001d	89 45 fc	 mov	 DWORD PTR _cpuCount$[ebp], eax

; 227  : #else
; 228  : 	{
; 229  : 		SYSTEM_INFO sysInfo;
; 230  : 		GetSystemInfo (&sysInfo);
; 231  : 		cpuCount = sysInfo.dwNumberOfProcessors;
; 232  : 	}
; 233  : #endif
; 234  : 
; 235  : 	if (cpuCount > encryptionFreeCpuCount)

  00020	3b 45 08	 cmp	 eax, DWORD PTR _encryptionFreeCpuCount$[ebp]
  00023	76 06		 jbe	 SHORT $LN10@Encryption@5

; 236  : 		cpuCount -= encryptionFreeCpuCount;

  00025	2b 45 08	 sub	 eax, DWORD PTR _encryptionFreeCpuCount$[ebp]
  00028	89 45 fc	 mov	 DWORD PTR _cpuCount$[ebp], eax
$LN10@Encryption@5:

; 237  : 
; 238  : 	if (cpuCount < 2)

  0002b	83 f8 02	 cmp	 eax, 2

; 239  : 		return TRUE;

  0002e	72 e0		 jb	 SHORT $LN26@Encryption@5

; 240  : 
; 241  : 	if (cpuCount > TC_ENC_THREAD_POOL_MAX_THREAD_COUNT)

  00030	6a 40		 push	 64			; 00000040H
  00032	59		 pop	 ecx
  00033	3b c1		 cmp	 eax, ecx
  00035	76 03		 jbe	 SHORT $LN8@Encryption@5

; 242  : 		cpuCount = TC_ENC_THREAD_POOL_MAX_THREAD_COUNT;

  00037	89 4d fc	 mov	 DWORD PTR _cpuCount$[ebp], ecx
$LN8@Encryption@5:
  0003a	53		 push	 ebx
  0003b	56		 push	 esi

; 243  : 
; 244  : 	StopPending = FALSE;
; 245  : 	DequeuePosition = 0;
; 246  : 	EnqueuePosition = 0;
; 247  : 
; 248  : #ifdef DEVICE_DRIVER
; 249  : 	KeInitializeEvent (&WorkItemReadyEvent, SynchronizationEvent, FALSE);

  0003c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__KeInitializeEvent@12
  00042	57		 push	 edi
  00043	33 ff		 xor	 edi, edi
  00045	57		 push	 edi
  00046	33 db		 xor	 ebx, ebx
  00048	43		 inc	 ebx
  00049	89 3d 00 00 00
	00		 mov	 DWORD PTR _StopPending, edi
  0004f	53		 push	 ebx
  00050	89 3d 00 00 00
	00		 mov	 DWORD PTR _DequeuePosition, edi
  00056	89 3d 00 00 00
	00		 mov	 DWORD PTR _EnqueuePosition, edi
  0005c	68 00 00 00 00	 push	 OFFSET _WorkItemReadyEvent
  00061	ff d6		 call	 esi

; 250  : 	KeInitializeEvent (&WorkItemCompletedEvent, SynchronizationEvent, FALSE);

  00063	57		 push	 edi
  00064	53		 push	 ebx
  00065	68 00 00 00 00	 push	 OFFSET _WorkItemCompletedEvent
  0006a	ff d6		 call	 esi

; 251  : #else
; 252  : 	WorkItemReadyEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
; 253  : 	if (!WorkItemReadyEvent)
; 254  : 		return FALSE;
; 255  : 	
; 256  : 	WorkItemCompletedEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
; 257  : 	if (!WorkItemCompletedEvent)
; 258  : 		return FALSE;
; 259  : #endif
; 260  : 	
; 261  : #ifdef DEVICE_DRIVER
; 262  : 	ExInitializeFastMutex (&DequeueMutex);

  0006c	57		 push	 edi
  0006d	53		 push	 ebx
  0006e	89 1d 00 00 00
	00		 mov	 DWORD PTR _DequeueMutex, ebx
  00074	68 0c 00 00 00	 push	 OFFSET _DequeueMutex+12
  00079	89 3d 04 00 00
	00		 mov	 DWORD PTR _DequeueMutex+4, edi
  0007f	89 3d 08 00 00
	00		 mov	 DWORD PTR _DequeueMutex+8, edi
  00085	ff d6		 call	 esi

; 263  : 	ExInitializeFastMutex (&EnqueueMutex);

  00087	57		 push	 edi
  00088	53		 push	 ebx
  00089	68 0c 00 00 00	 push	 OFFSET _EnqueueMutex+12
  0008e	89 1d 00 00 00
	00		 mov	 DWORD PTR _EnqueueMutex, ebx
  00094	89 3d 04 00 00
	00		 mov	 DWORD PTR _EnqueueMutex+4, edi
  0009a	89 3d 08 00 00
	00		 mov	 DWORD PTR _EnqueueMutex+8, edi
  000a0	ff d6		 call	 esi

; 264  : #else
; 265  : 	DequeueMutex = CreateMutex (NULL, FALSE, NULL);
; 266  : 	if (!DequeueMutex)
; 267  : 		return FALSE;
; 268  : 
; 269  : 	EnqueueMutex = CreateMutex (NULL, FALSE, NULL);
; 270  : 	if (!EnqueueMutex)
; 271  : 		return FALSE;
; 272  : #endif
; 273  : 
; 274  : 	memset (WorkItemQueue, 0, sizeof (WorkItemQueue));

  000a2	68 00 24 00 00	 push	 9216			; 00002400H
  000a7	57		 push	 edi
  000a8	68 00 00 00 00	 push	 OFFSET _WorkItemQueue
  000ad	e8 00 00 00 00	 call	 _memset
  000b2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b5	c7 45 08 08 00
	00 00		 mov	 DWORD PTR tv205[ebp], OFFSET _WorkItemQueue+8
  000bc	c7 45 f8 80 00
	00 00		 mov	 DWORD PTR tv230[ebp], 128 ; 00000080H
$LL23@Encryption@5:

; 275  : 
; 276  : 	for (i = 0; i < sizeof (WorkItemQueue) / sizeof (WorkItemQueue[0]); ++i)
; 277  : 	{
; 278  : 		WorkItemQueue[i].State = WorkItemFree;

  000c3	8b 45 08	 mov	 eax, DWORD PTR tv205[ebp]

; 279  : 
; 280  : #ifdef DEVICE_DRIVER
; 281  : 		KeInitializeEvent (&WorkItemQueue[i].ItemCompletedEvent, SynchronizationEvent, FALSE);

  000c6	57		 push	 edi
  000c7	53		 push	 ebx
  000c8	50		 push	 eax
  000c9	89 78 f8	 mov	 DWORD PTR [eax-8], edi
  000cc	ff d6		 call	 esi
  000ce	83 45 08 48	 add	 DWORD PTR tv205[ebp], 72 ; 00000048H
  000d2	ff 4d f8	 dec	 DWORD PTR tv230[ebp]
  000d5	75 ec		 jne	 SHORT $LL23@Encryption@5

; 282  : #else
; 283  : 		WorkItemQueue[i].ItemCompletedEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
; 284  : 		if (!WorkItemQueue[i].ItemCompletedEvent)
; 285  : 		{
; 286  : 			EncryptionThreadPoolStop();
; 287  : 			return FALSE;
; 288  : 		}
; 289  : #endif
; 290  : 	}
; 291  : 
; 292  : 	for (ThreadCount = 0; ThreadCount < cpuCount; ++ThreadCount)

  000d7	33 c0		 xor	 eax, eax
  000d9	a3 00 00 00 00	 mov	 DWORD PTR _ThreadCount, eax
  000de	39 7d fc	 cmp	 DWORD PTR _cpuCount$[ebp], edi
  000e1	76 27		 jbe	 SHORT $LN2@Encryption@5
$LL4@Encryption@5:

; 293  : 	{
; 294  : #ifdef DEVICE_DRIVER
; 295  : 		if (!NT_SUCCESS (TCStartThread (EncryptionThreadProc, NULL, &ThreadHandles[ThreadCount])))

  000e3	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR _ThreadHandles[eax*4]
  000ea	50		 push	 eax
  000eb	57		 push	 edi
  000ec	68 00 00 00 00	 push	 OFFSET _EncryptionThreadProc@4
  000f1	e8 00 00 00 00	 call	 _TCStartThread@12
  000f6	85 c0		 test	 eax, eax
  000f8	7c 1f		 jl	 SHORT $LN20@Encryption@5
  000fa	a1 00 00 00 00	 mov	 eax, DWORD PTR _ThreadCount
  000ff	40		 inc	 eax
  00100	a3 00 00 00 00	 mov	 DWORD PTR _ThreadCount, eax
  00105	3b 45 fc	 cmp	 eax, DWORD PTR _cpuCount$[ebp]
  00108	72 d9		 jb	 SHORT $LL4@Encryption@5
$LN2@Encryption@5:

; 302  : 		}
; 303  : 	}
; 304  : 
; 305  : 	ThreadPoolRunning = TRUE;

  0010a	89 1d 00 00 00
	00		 mov	 DWORD PTR _ThreadPoolRunning, ebx

; 306  : 	return TRUE;

  00110	8b c3		 mov	 eax, ebx
$LN24@Encryption@5:
  00112	5f		 pop	 edi
  00113	5e		 pop	 esi
  00114	5b		 pop	 ebx
$LN12@Encryption@5:

; 307  : }

  00115	c9		 leave
  00116	c2 04 00	 ret	 4
$LN20@Encryption@5:

; 296  : #else
; 297  : 		if (!(ThreadHandles[ThreadCount] = (HANDLE) _beginthreadex (NULL, 0, EncryptionThreadProc, NULL, 0, NULL)))
; 298  : #endif
; 299  : 		{
; 300  : 			EncryptionThreadPoolStop();

  00119	e8 00 00 00 00	 call	 _EncryptionThreadPoolStop@0

; 301  : 			return FALSE;

  0011e	33 c0		 xor	 eax, eax
  00120	eb f0		 jmp	 SHORT $LN24@Encryption@5
_EncryptionThreadPoolStart@4 ENDP
_TEXT	ENDS
END
