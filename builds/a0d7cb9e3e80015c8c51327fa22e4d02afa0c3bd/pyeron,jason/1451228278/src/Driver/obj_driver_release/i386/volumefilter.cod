; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\users\public\desktop\projects\ciphershed\src\driver\volumefilter.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_HiddenSysLeakProtectionCount
_BSS	SEGMENT
_HiddenSysLeakProtectionCount DD 01H DUP (?)
_BSS	ENDS
PUBLIC	_IoGetCurrentIrpStackLocation@4
; Function compile flags: /Ogsp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
;	COMDAT _IoGetCurrentIrpStackLocation@4
_TEXT	SEGMENT
_Irp$ = 8						; size = 4
_IoGetCurrentIrpStackLocation@4 PROC			; COMDAT

; 23316: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 23317:     ASSERT(Irp->CurrentLocation <= Irp->StackCount + 1);
; 23318:     return Irp->Tail.Overlay.CurrentStackLocation;

  00005	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00008	8b 40 60	 mov	 eax, DWORD PTR [eax+96]

; 23319: }

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
_IoGetCurrentIrpStackLocation@4 ENDP
_TEXT	ENDS
PUBLIC	_IoGetNextIrpStackLocation@4
; Function compile flags: /Ogsp
;	COMDAT _IoGetNextIrpStackLocation@4
_TEXT	SEGMENT
_Irp$ = 8						; size = 4
_IoGetNextIrpStackLocation@4 PROC			; COMDAT

; 23479: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 23480:     ASSERT(Irp->CurrentLocation > 0);
; 23481: 
; 23482:     return ((Irp)->Tail.Overlay.CurrentStackLocation - 1 );

  00005	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00008	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  0000b	83 e8 24	 sub	 eax, 36			; 00000024H

; 23483: }

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
_IoGetNextIrpStackLocation@4 ENDP
_TEXT	ENDS
PUBLIC	_IoMarkIrpPending@4
; Function compile flags: /Ogsp
;	COMDAT _IoMarkIrpPending@4
_TEXT	SEGMENT
_Irp$ = 8						; size = 4
_IoMarkIrpPending@4 PROC				; COMDAT

; 23667: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 23668:     IoGetCurrentIrpStackLocation( (Irp) )->Control |= SL_PENDING_RETURNED;

  00005	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00008	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  0000b	80 48 03 01	 or	 BYTE PTR [eax+3], 1

; 23669: }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
_IoMarkIrpPending@4 ENDP
_TEXT	ENDS
PUBLIC	_IoSetCompletionRoutine@24
; Function compile flags: /Ogsp
;	COMDAT _IoSetCompletionRoutine@24
_TEXT	SEGMENT
_Irp$ = 8						; size = 4
_CompletionRoutine$ = 12				; size = 4
_Context$ = 16						; size = 4
_InvokeOnSuccess$ = 20					; size = 1
_InvokeOnError$ = 24					; size = 1
_InvokeOnCancel$ = 28					; size = 1
_IoSetCompletionRoutine@24 PROC				; COMDAT

; 23820: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 23821:     PIO_STACK_LOCATION irpSp;
; 23822:     ASSERT( (InvokeOnSuccess || InvokeOnError || InvokeOnCancel) ? (CompletionRoutine != NULL) : TRUE );
; 23823:     irpSp = IoGetNextIrpStackLocation(Irp);

  00005	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00008	8b 40 60	 mov	 eax, DWORD PTR [eax+96]

; 23824:     irpSp->CompletionRoutine = CompletionRoutine;

  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR _CompletionRoutine$[ebp]
  0000e	83 e8 24	 sub	 eax, 36			; 00000024H
  00011	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 23825:     irpSp->Context = Context;

  00014	8b 4d 10	 mov	 ecx, DWORD PTR _Context$[ebp]
  00017	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 23826:     irpSp->Control = 0;

  0001a	32 c9		 xor	 cl, cl
  0001c	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 23827: 
; 23828:     if (InvokeOnSuccess) {

  0001f	38 4d 14	 cmp	 BYTE PTR _InvokeOnSuccess$[ebp], cl
  00022	74 04		 je	 SHORT $LN3@IoSetCompl

; 23829:         irpSp->Control = SL_INVOKE_ON_SUCCESS;

  00024	c6 40 03 40	 mov	 BYTE PTR [eax+3], 64	; 00000040H
$LN3@IoSetCompl:

; 23830:     }
; 23831: 
; 23832:     if (InvokeOnError) {

  00028	38 4d 18	 cmp	 BYTE PTR _InvokeOnError$[ebp], cl
  0002b	74 04		 je	 SHORT $LN2@IoSetCompl

; 23833:         irpSp->Control |= SL_INVOKE_ON_ERROR;

  0002d	80 48 03 80	 or	 BYTE PTR [eax+3], 128	; 00000080H
$LN2@IoSetCompl:

; 23834:     }
; 23835: 
; 23836:     if (InvokeOnCancel) {

  00031	38 4d 1c	 cmp	 BYTE PTR _InvokeOnCancel$[ebp], cl
  00034	74 04		 je	 SHORT $LN1@IoSetCompl

; 23837:         irpSp->Control |= SL_INVOKE_ON_CANCEL;

  00036	80 48 03 20	 or	 BYTE PTR [eax+3], 32	; 00000020H
$LN1@IoSetCompl:

; 23838:     }
; 23839: }

  0003a	5d		 pop	 ebp
  0003b	c2 18 00	 ret	 24			; 00000018H
_IoSetCompletionRoutine@24 ENDP
_TEXT	ENDS
PUBLIC	_IoCopyCurrentIrpStackLocationToNext@4
; Function compile flags: /Ogsp
;	COMDAT _IoCopyCurrentIrpStackLocationToNext@4
_TEXT	SEGMENT
_Irp$ = 8						; size = 4
_IoCopyCurrentIrpStackLocationToNext@4 PROC		; COMDAT

; 23912: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 23913:     PIO_STACK_LOCATION irpSp;
; 23914:     PIO_STACK_LOCATION nextIrpSp;
; 23915:     irpSp = IoGetCurrentIrpStackLocation(Irp);

  00005	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00008	56		 push	 esi
  00009	8b 70 60	 mov	 esi, DWORD PTR [eax+96]
  0000c	57		 push	 edi

; 23916:     nextIrpSp = IoGetNextIrpStackLocation(Irp);

  0000d	8d 46 dc	 lea	 eax, DWORD PTR [esi-36]

; 23917:     RtlCopyMemory( nextIrpSp, irpSp, FIELD_OFFSET(IO_STACK_LOCATION, CompletionRoutine));

  00010	6a 07		 push	 7
  00012	59		 pop	 ecx
  00013	8b f8		 mov	 edi, eax
  00015	f3 a5		 rep movsd
  00017	5f		 pop	 edi

; 23918:     nextIrpSp->Control = 0;

  00018	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0
  0001c	5e		 pop	 esi

; 23919: }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
_IoCopyCurrentIrpStackLocationToNext@4 ENDP
_TEXT	ENDS
PUBLIC	_IoSkipCurrentIrpStackLocation@4
; Function compile flags: /Ogsp
;	COMDAT _IoSkipCurrentIrpStackLocation@4
_TEXT	SEGMENT
_Irp$ = 8						; size = 4
_IoSkipCurrentIrpStackLocation@4 PROC			; COMDAT

; 23945: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 23946:     ASSERT(Irp->CurrentLocation <= Irp->StackCount);
; 23947:     Irp->CurrentLocation++;

  00005	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00008	fe 40 23	 inc	 BYTE PTR [eax+35]

; 23948:     Irp->Tail.Overlay.CurrentStackLocation++;

  0000b	83 40 60 24	 add	 DWORD PTR [eax+96], 36	; 00000024H

; 23949: }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
_IoSkipCurrentIrpStackLocation@4 ENDP
_TEXT	ENDS
PUBLIC	_VolumeFilterAddDevice@8
EXTRN	__imp__IoInitializeRemoveLockEx@20:PROC
EXTRN	__imp__IoDeleteDevice@4:PROC
EXTRN	__imp__IoDetachDevice@4:PROC
EXTRN	__imp__IoAttachDeviceToDeviceStack@8:PROC
EXTRN	__imp_@ObfDereferenceObject@4:PROC
EXTRN	__imp__IoCreateDevice@28:PROC
EXTRN	__imp__IoGetAttachedDeviceReference@4:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogsp
; File c:\users\public\desktop\projects\ciphershed\src\driver\volumefilter.c
;	COMDAT _VolumeFilterAddDevice@8
_TEXT	SEGMENT
_filterDeviceObject$ = -4				; size = 4
_status$ = 8						; size = 4
_driverObject$ = 8					; size = 4
_pdo$ = 12						; size = 4
_VolumeFilterAddDevice@8 PROC				; COMDAT

; 23   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 24   : 	VolumeFilterExtension *Extension;
; 25   : 	NTSTATUS status;
; 26   : 	PDEVICE_OBJECT filterDeviceObject = NULL;
; 27   : 	PDEVICE_OBJECT attachedDeviceObject;
; 28   : 
; 29   : 	Dump ("VolumeFilterAddDevice pdo=%p\n", pdo);
; 30   : 
; 31   : 	attachedDeviceObject = IoGetAttachedDeviceReference (pdo);

  00009	ff 75 0c	 push	 DWORD PTR _pdo$[ebp]
  0000c	33 db		 xor	 ebx, ebx
  0000e	89 5d fc	 mov	 DWORD PTR _filterDeviceObject$[ebp], ebx
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoGetAttachedDeviceReference@4
  00017	8b f0		 mov	 esi, eax

; 32   : 	status = IoCreateDevice (driverObject, sizeof (VolumeFilterExtension), NULL, attachedDeviceObject->DeviceType, 0, FALSE, &filterDeviceObject);

  00019	8d 45 fc	 lea	 eax, DWORD PTR _filterDeviceObject$[ebp]
  0001c	50		 push	 eax
  0001d	53		 push	 ebx
  0001e	53		 push	 ebx
  0001f	ff 76 2c	 push	 DWORD PTR [esi+44]
  00022	bf 10 02 00 00	 mov	 edi, 528		; 00000210H
  00027	53		 push	 ebx
  00028	57		 push	 edi
  00029	ff 75 08	 push	 DWORD PTR _driverObject$[ebp]
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoCreateDevice@28

; 33   : 
; 34   : 	ObDereferenceObject (attachedDeviceObject);

  00032	8b ce		 mov	 ecx, esi
  00034	89 45 08	 mov	 DWORD PTR _status$[ebp], eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 35   : 
; 36   : 	if (!NT_SUCCESS (status))

  0003d	39 5d 08	 cmp	 DWORD PTR _status$[ebp], ebx

; 37   : 	{
; 38   : 		filterDeviceObject = NULL;
; 39   : 		goto err;

  00040	0f 8c 8b 00 00
	00		 jl	 $LN7@VolumeFilt

; 40   : 	}
; 41   : 
; 42   : 	Extension = (VolumeFilterExtension *) filterDeviceObject->DeviceExtension;

  00046	8b 45 fc	 mov	 eax, DWORD PTR _filterDeviceObject$[ebp]
  00049	8b 70 28	 mov	 esi, DWORD PTR [eax+40]

; 43   : 	memset (Extension, 0, sizeof (VolumeFilterExtension));

  0004c	57		 push	 edi
  0004d	53		 push	 ebx
  0004e	56		 push	 esi
  0004f	e8 00 00 00 00	 call	 _memset

; 44   : 
; 45   : 	Extension->LowerDeviceObject = IoAttachDeviceToDeviceStack (filterDeviceObject, pdo);  // IoAttachDeviceToDeviceStackSafe() is not required in AddDevice routine and is also unavailable on Windows 2000 SP4

  00054	8b 7d 0c	 mov	 edi, DWORD PTR _pdo$[ebp]
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	57		 push	 edi
  0005b	ff 75 fc	 push	 DWORD PTR _filterDeviceObject$[ebp]
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAttachDeviceToDeviceStack@8
  00064	89 46 1c	 mov	 DWORD PTR [esi+28], eax

; 46   : 	if (!Extension->LowerDeviceObject)

  00067	3b c3		 cmp	 eax, ebx
  00069	75 24		 jne	 SHORT $LN3@VolumeFilt

; 47   : 	{
; 48   : 		status = STATUS_DEVICE_REMOVED;

  0006b	c7 45 08 b6 02
	00 c0		 mov	 DWORD PTR _status$[ebp], -1073741130 ; c00002b6H
$err$27746:

; 62   : 
; 63   : err:
; 64   : 	if (filterDeviceObject)

  00072	39 5d fc	 cmp	 DWORD PTR _filterDeviceObject$[ebp], ebx
  00075	74 5a		 je	 SHORT $LN7@VolumeFilt

; 65   : 	{
; 66   : 		if (Extension->LowerDeviceObject)

  00077	8b f0		 mov	 esi, eax
  00079	3b f3		 cmp	 esi, ebx
  0007b	74 07		 je	 SHORT $LN1@VolumeFilt

; 67   : 			IoDetachDevice (Extension->LowerDeviceObject);

  0007d	56		 push	 esi
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDetachDevice@4
$LN1@VolumeFilt:

; 68   : 
; 69   : 		IoDeleteDevice (filterDeviceObject);

  00084	ff 75 fc	 push	 DWORD PTR _filterDeviceObject$[ebp]
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteDevice@4

; 70   : 	}
; 71   : 
; 72   : 	return status;

  0008d	eb 42		 jmp	 SHORT $LN7@VolumeFilt
$LN3@VolumeFilt:

; 49   : 		goto err;
; 50   : 	}
; 51   : 	
; 52   : 	Extension->IsVolumeFilterDevice = TRUE;
; 53   : 	Extension->DeviceObject = filterDeviceObject;
; 54   : 	Extension->Pdo = pdo;
; 55   : 
; 56   : 	IoInitializeRemoveLock (&Extension->Queue.RemoveLock, 'LRCT', 0, 0);

  0008f	6a 18		 push	 24			; 00000018H
  00091	53		 push	 ebx
  00092	c7 46 0c 01 00
	00 00		 mov	 DWORD PTR [esi+12], 1
  00099	8b 45 fc	 mov	 eax, DWORD PTR _filterDeviceObject$[ebp]
  0009c	53		 push	 ebx
  0009d	89 46 18	 mov	 DWORD PTR [esi+24], eax
  000a0	68 54 43 52 4c	 push	 1280459604		; 4c524354H
  000a5	8d 86 b8 00 00
	00		 lea	 eax, DWORD PTR [esi+184]
  000ab	50		 push	 eax
  000ac	89 7e 20	 mov	 DWORD PTR [esi+32], edi
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoInitializeRemoveLockEx@20

; 57   : 
; 58   : 	filterDeviceObject->Flags |= Extension->LowerDeviceObject->Flags & (DO_DIRECT_IO | DO_BUFFERED_IO | DO_POWER_PAGABLE);

  000b5	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  000b8	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  000bb	8b 45 fc	 mov	 eax, DWORD PTR _filterDeviceObject$[ebp]
  000be	81 e1 14 20 00
	00		 and	 ecx, 8212		; 00002014H
  000c4	09 48 1c	 or	 DWORD PTR [eax+28], ecx

; 59   : 	filterDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

  000c7	8b 45 fc	 mov	 eax, DWORD PTR _filterDeviceObject$[ebp]
  000ca	81 60 1c 7f ff
	ff ff		 and	 DWORD PTR [eax+28], -129 ; ffffff7fH
$LN7@VolumeFilt:

; 60   : 
; 61   : 	return status;

  000d1	8b 45 08	 mov	 eax, DWORD PTR _status$[ebp]
  000d4	5f		 pop	 edi
  000d5	5e		 pop	 esi
  000d6	5b		 pop	 ebx

; 73   : }

  000d7	c9		 leave
  000d8	c2 08 00	 ret	 8
_VolumeFilterAddDevice@8 ENDP
_TEXT	ENDS
EXTRN	__imp_@IofCallDriver@8:PROC
; Function compile flags: /Ogsp
;	COMDAT _PassIrp@8
_TEXT	SEGMENT
_PassIrp@8 PROC						; COMDAT
; _deviceObject$ = ecx
; _irp$ = edx

; 78   : 	IoSkipCurrentIrpStackLocation (irp);

  00000	fe 42 23	 inc	 BYTE PTR [edx+35]
  00003	83 42 60 24	 add	 DWORD PTR [edx+96], 36	; 00000024H

; 79   : 	return IoCallDriver (deviceObject, irp);

  00007	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_@IofCallDriver@8
_PassIrp@8 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _PassFilteredIrp@16
_TEXT	SEGMENT
_deviceObject$ = 8					; size = 4
_completionRoutineArg$ = 12				; size = 4
_PassFilteredIrp@16 PROC				; COMDAT
; _irp$ = edx
; _completionRoutine$ = ebx

; 84   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 85   : 	IoCopyCurrentIrpStackLocationToNext (irp);

  00006	8b 72 60	 mov	 esi, DWORD PTR [edx+96]
  00009	57		 push	 edi
  0000a	8d 46 dc	 lea	 eax, DWORD PTR [esi-36]
  0000d	6a 07		 push	 7
  0000f	59		 pop	 ecx
  00010	8b f8		 mov	 edi, eax
  00012	f3 a5		 rep movsd
  00014	5f		 pop	 edi
  00015	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0
  00019	5e		 pop	 esi

; 86   : 
; 87   : 	if (completionRoutine)

  0001a	85 db		 test	 ebx, ebx
  0001c	74 13		 je	 SHORT $LN10@PassFilter

; 88   : 		IoSetCompletionRoutine (irp, completionRoutine, completionRoutineArg, TRUE, TRUE, TRUE);

  0001e	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00021	8b 4d 0c	 mov	 ecx, DWORD PTR _completionRoutineArg$[ebp]
  00024	83 e8 24	 sub	 eax, 36			; 00000024H
  00027	89 58 1c	 mov	 DWORD PTR [eax+28], ebx
  0002a	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  0002d	c6 40 03 e0	 mov	 BYTE PTR [eax+3], 224	; 000000e0H
$LN10@PassFilter:

; 89   : 
; 90   : 	return IoCallDriver (deviceObject, irp);

  00031	8b 4d 08	 mov	 ecx, DWORD PTR _deviceObject$[ebp]
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8

; 91   : }

  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
_PassFilteredIrp@16 ENDP
_TEXT	ENDS
EXTRN	__imp__IoReleaseRemoveLockEx@12:PROC
; Function compile flags: /Ogsp
;	COMDAT _OnDeviceUsageNotificationCompleted@12
_TEXT	SEGMENT
_filterDeviceObject$ = 8				; size = 4
_Irp$ = 12						; size = 4
_Extension$ = 16					; size = 4
_OnDeviceUsageNotificationCompleted@12 PROC		; COMDAT

; 95   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 96   : 	if (Irp->PendingReturned)

  00005	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00008	80 79 21 00	 cmp	 BYTE PTR [ecx+33], 0
  0000c	74 07		 je	 SHORT $LN5@OnDeviceUs

; 97   : 		IoMarkIrpPending (Irp);

  0000e	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]
  00011	80 48 03 01	 or	 BYTE PTR [eax+3], 1
$LN5@OnDeviceUs:

; 98   : 
; 99   : 	if (!(Extension->LowerDeviceObject->Flags & DO_POWER_PAGABLE))

  00015	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  00018	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  0001b	f7 42 1c 00 20
	00 00		 test	 DWORD PTR [edx+28], 8192 ; 00002000H
  00022	75 0a		 jne	 SHORT $LN1@OnDeviceUs

; 100  : 		filterDeviceObject->Flags &= ~DO_POWER_PAGABLE;

  00024	8b 55 08	 mov	 edx, DWORD PTR _filterDeviceObject$[ebp]
  00027	81 62 1c ff df
	ff ff		 and	 DWORD PTR [edx+28], -8193 ; ffffdfffH
$LN1@OnDeviceUs:

; 101  : 
; 102  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  0002e	6a 18		 push	 24			; 00000018H
  00030	51		 push	 ecx
  00031	05 b8 00 00 00	 add	 eax, 184		; 000000b8H
  00036	50		 push	 eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 103  : 	return STATUS_CONTINUE_COMPLETION;

  0003d	33 c0		 xor	 eax, eax

; 104  : }

  0003f	5d		 pop	 ebp
  00040	c2 0c 00	 ret	 12			; 0000000cH
_OnDeviceUsageNotificationCompleted@12 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _OnStartDeviceCompleted@12
_TEXT	SEGMENT
_filterDeviceObject$ = 8				; size = 4
_Irp$ = 12						; size = 4
_Extension$ = 16					; size = 4
_OnStartDeviceCompleted@12 PROC				; COMDAT

; 108  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 109  : 	if (Irp->PendingReturned)

  00005	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00008	80 79 21 00	 cmp	 BYTE PTR [ecx+33], 0
  0000c	74 07		 je	 SHORT $LN5@OnStartDev

; 110  : 		IoMarkIrpPending (Irp);

  0000e	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]
  00011	80 48 03 01	 or	 BYTE PTR [eax+3], 1
$LN5@OnStartDev:

; 111  : 
; 112  : 	if (Extension->LowerDeviceObject->Characteristics & FILE_REMOVABLE_MEDIA)

  00015	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  00018	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0001b	f6 40 20 01	 test	 BYTE PTR [eax+32], 1
  0001f	74 07		 je	 SHORT $LN1@OnStartDev

; 113  : 		filterDeviceObject->Characteristics |= FILE_REMOVABLE_MEDIA;

  00021	8b 45 08	 mov	 eax, DWORD PTR _filterDeviceObject$[ebp]
  00024	83 48 20 01	 or	 DWORD PTR [eax+32], 1
$LN1@OnStartDev:

; 114  : 
; 115  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00028	6a 18		 push	 24			; 00000018H
  0002a	51		 push	 ecx
  0002b	81 c2 b8 00 00
	00		 add	 edx, 184		; 000000b8H
  00031	52		 push	 edx
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 116  : 	return STATUS_CONTINUE_COMPLETION;

  00038	33 c0		 xor	 eax, eax

; 117  : }

  0003a	5d		 pop	 ebp
  0003b	c2 0c 00	 ret	 12			; 0000000cH
_OnStartDeviceCompleted@12 ENDP
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@FNODOBFM@			;  ?? ::FNODOBFM::`string'
EXTRN	_TCCompleteDiskIrp@12:PROC
EXTRN	__imp__KeBugCheckEx@20:PROC
EXTRN	_GetBootDriveFilterExtension@0:PROC
EXTRN	_SendDeviceIoControlRequest@24:PROC
EXTRN	_ProbingHostDeviceForWrite:DWORD
EXTRN	_IsHiddenSystemRunning@0:PROC
EXTRN	_TCCompleteIrp@12:PROC
EXTRN	__imp__IoAcquireRemoveLockEx@20:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@FNODOBFM@
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
text$s	SEGMENT
??_C@_00CNPNBAHC@?$AA@FNODOBFM@ DB 00H			;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
; File c:\users\public\desktop\projects\ciphershed\src\driver\volumefilter.c
text$s	ENDS
;	COMDAT _DispatchControl@16
_TEXT	SEGMENT
_partition$27826 = -160					; size = 144
_storageDeviceNumber$27818 = -16			; size = 12
tv256 = -4						; size = 4
_bootDriveExtension$27817 = 8				; size = 4
_status$ = 8						; size = 4
_irpSp$ = 8						; size = 4
_DispatchControl@16 PROC				; COMDAT
; _Irp$ = esi
; _Extension$ = eax

; 121  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  0000b	53		 push	 ebx
  0000c	57		 push	 edi

; 122  : 	NTSTATUS status = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  0000d	6a 18		 push	 24			; 00000018H
  0000f	6a 01		 push	 1
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@FNODOBFM@
  00016	8b d8		 mov	 ebx, eax
  00018	8d 83 b8 00 00
	00		 lea	 eax, DWORD PTR [ebx+184]
  0001e	56		 push	 esi
  0001f	50		 push	 eax
  00020	89 45 fc	 mov	 DWORD PTR tv256[ebp], eax
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAcquireRemoveLockEx@20

; 123  : 	if (!NT_SUCCESS (status))

  00029	33 ff		 xor	 edi, edi
  0002b	3b c7		 cmp	 eax, edi
  0002d	7d 0a		 jge	 SHORT $LN13@DispatchCo

; 124  : 		return TCCompleteIrp (Irp, status, 0);

  0002f	57		 push	 edi
  00030	50		 push	 eax
  00031	56		 push	 esi
  00032	e8 00 00 00 00	 call	 _TCCompleteIrp@12
  00037	eb 52		 jmp	 SHORT $LN14@DispatchCo
$LN13@DispatchCo:

; 125  : 
; 126  : 	if (IsHiddenSystemRunning())

  00039	e8 00 00 00 00	 call	 _IsHiddenSystemRunning@0
  0003e	85 c0		 test	 eax, eax
  00040	74 27		 je	 SHORT $LN10@DispatchCo

; 127  : 	{
; 128  : 		switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  00042	8b 45 08	 mov	 eax, DWORD PTR _irpSp$[ebp]
  00045	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00048	81 f9 24 00 07
	00		 cmp	 ecx, 458788		; 00070024H
  0004e	0f 84 9d 00 00
	00		 je	 $LN9@DispatchCo
  00054	b8 74 20 22 00	 mov	 eax, 2236532		; 00222074H
  00059	3b c8		 cmp	 ecx, eax
  0005b	74 34		 je	 SHORT $LN5@DispatchCo
  0005d	81 f9 04 94 2d
	00		 cmp	 ecx, 2987012		; 002d9404H
  00063	0f 84 09 01 00
	00		 je	 $LN22@DispatchCo
$LN10@DispatchCo:

; 181  : 
; 182  : 		case IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES:
; 183  : 
; 184  : 			// Filter IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES to enable potential future use of hidden systems on drives that use the trim operation but not wear-leveling (if any appear in future). The documentation forbids users to create hidden volumes/systems on drives that use wear-leveling and consequently also on drives that use trim (as trim is used only by drives that use wear-leveling, as of 2010).
; 185  : 
; 186  : 			IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);
; 187  : 			return TCCompleteDiskIrp (Irp, STATUS_SUCCESS, 0);
; 188  : 		}
; 189  : 	}
; 190  : 
; 191  : 	status = PassIrp (Extension->LowerDeviceObject, Irp);

  00069	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  0006c	fe 46 23	 inc	 BYTE PTR [esi+35]
  0006f	83 46 60 24	 add	 DWORD PTR [esi+96], 36	; 00000024H
  00073	8b d6		 mov	 edx, esi
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8

; 192  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  0007b	6a 18		 push	 24			; 00000018H
  0007d	56		 push	 esi
  0007e	ff 75 fc	 push	 DWORD PTR tv256[ebp]
  00081	8b f8		 mov	 edi, eax
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 193  : 	return status;

  00089	8b c7		 mov	 eax, edi
$LN14@DispatchCo:
  0008b	5f		 pop	 edi
  0008c	5b		 pop	 ebx

; 194  : }

  0008d	c9		 leave
  0008e	c2 04 00	 ret	 4
$LN5@DispatchCo:

; 158  : 			}
; 159  : 
; 160  : 		case TC_IOCTL_DISK_IS_WRITABLE:
; 161  : 			Dump ("TC_IOCTL_DISK_IS_WRITABLE pdo=%p\n", Extension->Pdo);
; 162  : 
; 163  : 			if (!ProbingHostDeviceForWrite)

  00091	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ProbingHostDeviceForWrite
  00097	85 c9		 test	 ecx, ecx
  00099	74 ce		 je	 SHORT $LN10@DispatchCo

; 164  : 				break;
; 165  : 
; 166  : 			// Probe the real state of the device as the user is mounting a CipherShed volume.
; 167  : 
; 168  : 			// Volume filter may be attached to a merged drive+volume PDO. First test if TC_IOCTL_DISK_IS_WRITABLE works for the underlying device.
; 169  : 			status = SendDeviceIoControlRequest (Extension->LowerDeviceObject, TC_IOCTL_DISK_IS_WRITABLE, NULL, 0, NULL, 0);

  0009b	57		 push	 edi
  0009c	57		 push	 edi
  0009d	57		 push	 edi
  0009e	57		 push	 edi
  0009f	50		 push	 eax
  000a0	ff 73 1c	 push	 DWORD PTR [ebx+28]
  000a3	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24

; 170  : 
; 171  : 			if (NT_SUCCESS (status) || status == STATUS_MEDIA_WRITE_PROTECTED)

  000a8	3b c7		 cmp	 eax, edi
  000aa	89 45 08	 mov	 DWORD PTR _status$[ebp], eax
  000ad	7d 2d		 jge	 SHORT $LN2@DispatchCo
  000af	3d a2 00 00 c0	 cmp	 eax, -1073741662	; c00000a2H
  000b4	74 26		 je	 SHORT $LN2@DispatchCo

; 175  : 			}
; 176  : 
; 177  : 			status = SendDeviceIoControlRequest (Extension->LowerDeviceObject, IOCTL_DISK_IS_WRITABLE, NULL, 0, NULL, 0);

  000b6	57		 push	 edi
  000b7	57		 push	 edi
  000b8	57		 push	 edi
  000b9	57		 push	 edi
  000ba	68 24 00 07 00	 push	 458788			; 00070024H
  000bf	ff 73 1c	 push	 DWORD PTR [ebx+28]
  000c2	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24

; 178  : 
; 179  : 			IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  000c7	6a 18		 push	 24			; 00000018H
  000c9	56		 push	 esi
  000ca	ff 75 fc	 push	 DWORD PTR tv256[ebp]
  000cd	8b d8		 mov	 ebx, eax
  000cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 180  : 			return TCCompleteDiskIrp (Irp, status, 0);

  000d5	57		 push	 edi
  000d6	53		 push	 ebx
  000d7	e9 a4 00 00 00	 jmp	 $LN21@DispatchCo
$LN2@DispatchCo:

; 172  : 			{
; 173  : 				IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  000dc	6a 18		 push	 24			; 00000018H
  000de	56		 push	 esi
  000df	ff 75 fc	 push	 DWORD PTR tv256[ebp]
  000e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 174  : 				return TCCompleteDiskIrp (Irp, status, 0);

  000e8	57		 push	 edi
  000e9	ff 75 08	 push	 DWORD PTR _status$[ebp]
  000ec	e9 8f 00 00 00	 jmp	 $LN21@DispatchCo
$LN9@DispatchCo:

; 129  : 		{
; 130  : 		case IOCTL_DISK_IS_WRITABLE:
; 131  : 			{
; 132  : 				// All volumes except the system volume must be read-only
; 133  : 
; 134  : 				DriveFilterExtension *bootDriveExtension = GetBootDriveFilterExtension();

  000f1	e8 00 00 00 00	 call	 _GetBootDriveFilterExtension@0
  000f6	89 45 08	 mov	 DWORD PTR _bootDriveExtension$27817[ebp], eax

; 135  : 				STORAGE_DEVICE_NUMBER storageDeviceNumber;
; 136  : 
; 137  : 				if (!bootDriveExtension->SystemStorageDeviceNumberValid)

  000f9	39 78 28	 cmp	 DWORD PTR [eax+40], edi
  000fc	75 18		 jne	 SHORT $LN8@DispatchCo

; 138  : 					TC_BUG_CHECK (STATUS_INVALID_PARAMETER);

  000fe	68 43 54 00 00	 push	 21571			; 00005443H
  00103	57		 push	 edi
  00104	68 0d 00 00 c0	 push	 -1073741811		; c000000dH
  00109	68 8a 00 00 00	 push	 138			; 0000008aH
  0010e	6a 29		 push	 41			; 00000029H
  00110	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN23@DispatchCo:
$LN8@DispatchCo:

; 139  : 
; 140  : 				status = SendDeviceIoControlRequest (Extension->LowerDeviceObject, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0, &storageDeviceNumber, sizeof (storageDeviceNumber));

  00116	6a 0c		 push	 12			; 0000000cH
  00118	8d 45 f0	 lea	 eax, DWORD PTR _storageDeviceNumber$27818[ebp]
  0011b	50		 push	 eax
  0011c	57		 push	 edi
  0011d	57		 push	 edi
  0011e	68 80 10 2d 00	 push	 2953344			; 002d1080H
  00123	ff 73 1c	 push	 DWORD PTR [ebx+28]
  00126	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24

; 141  : 
; 142  : 				if (NT_SUCCESS (status) && bootDriveExtension->SystemStorageDeviceNumber == storageDeviceNumber.DeviceNumber)

  0012b	85 c0		 test	 eax, eax
  0012d	7c 5c		 jl	 SHORT $LN6@DispatchCo
  0012f	8b 45 08	 mov	 eax, DWORD PTR _bootDriveExtension$27817[ebp]
  00132	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00135	3b 45 f4	 cmp	 eax, DWORD PTR _storageDeviceNumber$27818[ebp+4]
  00138	75 51		 jne	 SHORT $LN6@DispatchCo

; 143  : 				{
; 144  : 					PARTITION_INFORMATION_EX partition;
; 145  : 					status = SendDeviceIoControlRequest (Extension->LowerDeviceObject, IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0, &partition, sizeof (partition));

  0013a	68 90 00 00 00	 push	 144			; 00000090H
  0013f	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _partition$27826[ebp]
  00145	50		 push	 eax
  00146	57		 push	 edi
  00147	57		 push	 edi
  00148	68 48 00 07 00	 push	 458824			; 00070048H
  0014d	ff 73 1c	 push	 DWORD PTR [ebx+28]
  00150	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24

; 146  : 
; 147  : 					if (NT_SUCCESS (status) && partition.StartingOffset.QuadPart == bootDriveExtension->ConfiguredEncryptedAreaStart)

  00155	85 c0		 test	 eax, eax
  00157	7c 32		 jl	 SHORT $LN6@DispatchCo
  00159	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _partition$27826[ebp+8]
  0015f	8b 45 08	 mov	 eax, DWORD PTR _bootDriveExtension$27817[ebp]
  00162	3b 48 30	 cmp	 ecx, DWORD PTR [eax+48]
  00165	75 24		 jne	 SHORT $LN6@DispatchCo
  00167	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _partition$27826[ebp+12]
  0016d	3b 48 34	 cmp	 ecx, DWORD PTR [eax+52]
  00170	75 19		 jne	 SHORT $LN6@DispatchCo
$LN22@DispatchCo:

; 148  : 					{
; 149  : 						IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00172	6a 18		 push	 24			; 00000018H
  00174	56		 push	 esi
  00175	ff 75 fc	 push	 DWORD PTR tv256[ebp]
  00178	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 150  : 						return TCCompleteDiskIrp (Irp, STATUS_SUCCESS, 0);

  0017e	57		 push	 edi
  0017f	57		 push	 edi
$LN21@DispatchCo:
  00180	56		 push	 esi
  00181	e8 00 00 00 00	 call	 _TCCompleteDiskIrp@12
  00186	e9 00 ff ff ff	 jmp	 $LN14@DispatchCo
$LN6@DispatchCo:

; 151  : 					}
; 152  : 				}
; 153  : 
; 154  : 				IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  0018b	6a 18		 push	 24			; 00000018H
  0018d	56		 push	 esi
  0018e	ff 75 fc	 push	 DWORD PTR tv256[ebp]
  00191	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 155  : 
; 156  : 				++HiddenSysLeakProtectionCount;

  00197	ff 05 00 00 00
	00		 inc	 DWORD PTR _HiddenSysLeakProtectionCount

; 157  : 				return TCCompleteDiskIrp (Irp, STATUS_MEDIA_WRITE_PROTECTED, 0);

  0019d	57		 push	 edi
  0019e	68 a2 00 00 c0	 push	 -1073741662		; c00000a2H
  001a3	eb db		 jmp	 SHORT $LN21@DispatchCo
$LN20@DispatchCo:
_DispatchControl@16 ENDP
_TEXT	ENDS
EXTRN	__imp__IoReleaseRemoveLockAndWaitEx@12:PROC
; Function compile flags: /Ogsp
;	COMDAT _DispatchPnp@16
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_irpSp$ = 12						; size = 4
_DispatchPnp@16 PROC					; COMDAT
; _Irp$ = ecx
; _Extension$ = eax

; 198  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	53		 push	 ebx
  00006	56		 push	 esi
  00007	57		 push	 edi

; 199  : 	NTSTATUS status;
; 200  : 
; 201  : 	status = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00008	6a 18		 push	 24			; 00000018H
  0000a	6a 01		 push	 1
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@FNODOBFM@
  00011	8b f8		 mov	 edi, eax
  00013	8b f1		 mov	 esi, ecx
  00015	56		 push	 esi
  00016	8d 9f b8 00 00
	00		 lea	 ebx, DWORD PTR [edi+184]
  0001c	53		 push	 ebx
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAcquireRemoveLockEx@20

; 202  : 	if (!NT_SUCCESS (status))

  00023	85 c0		 test	 eax, eax
  00025	7d 0e		 jge	 SHORT $LN9@DispatchPn

; 203  : 		return TCCompleteIrp (Irp, status, 0);

  00027	6a 00		 push	 0
  00029	50		 push	 eax
  0002a	56		 push	 esi
  0002b	e8 00 00 00 00	 call	 _TCCompleteIrp@12
  00030	e9 a9 00 00 00	 jmp	 $LN10@DispatchPn
$LN9@DispatchPn:

; 204  : 
; 205  : 	switch (irpSp->MinorFunction)

  00035	8b 45 0c	 mov	 eax, DWORD PTR _irpSp$[ebp]
  00038	0f b6 40 01	 movzx	 eax, BYTE PTR [eax+1]
  0003c	83 e8 00	 sub	 eax, 0
  0003f	0f 84 89 00 00
	00		 je	 $LN6@DispatchPn
  00045	48		 dec	 eax
  00046	48		 dec	 eax
  00047	74 51		 je	 SHORT $LN2@DispatchPn
  00049	83 e8 14	 sub	 eax, 20			; 00000014H
  0004c	74 22		 je	 SHORT $LN5@DispatchPn

; 234  : 
; 235  : 	default:
; 236  : 		status = PassIrp (Extension->LowerDeviceObject, Irp);

  0004e	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  00051	fe 46 23	 inc	 BYTE PTR [esi+35]
  00054	83 46 60 24	 add	 DWORD PTR [esi+96], 36	; 00000024H
  00058	8b d6		 mov	 edx, esi
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8

; 237  : 		IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00060	6a 18		 push	 24			; 00000018H
  00062	56		 push	 esi
  00063	53		 push	 ebx
  00064	8b f8		 mov	 edi, eax
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 238  : 	}
; 239  : 
; 240  : 	return status;

  0006c	8b c7		 mov	 eax, edi
  0006e	eb 6e		 jmp	 SHORT $LN10@DispatchPn
$LN5@DispatchPn:

; 210  : 
; 211  : 	case IRP_MN_DEVICE_USAGE_NOTIFICATION:
; 212  : 		{
; 213  : 			PDEVICE_OBJECT attachedDevice = IoGetAttachedDeviceReference (DeviceObject);

  00070	8b 5d 08	 mov	 ebx, DWORD PTR _DeviceObject$[ebp]
  00073	53		 push	 ebx
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoGetAttachedDeviceReference@4

; 214  : 
; 215  : 			if (attachedDevice == DeviceObject || (attachedDevice->Flags & DO_POWER_PAGABLE))

  0007a	ba 00 20 00 00	 mov	 edx, 8192		; 00002000H
  0007f	3b c3		 cmp	 eax, ebx
  00081	74 05		 je	 SHORT $LN3@DispatchPn
  00083	85 50 1c	 test	 DWORD PTR [eax+28], edx
  00086	74 03		 je	 SHORT $LN4@DispatchPn
$LN3@DispatchPn:

; 216  : 				DeviceObject->Flags |= DO_POWER_PAGABLE;

  00088	09 53 1c	 or	 DWORD PTR [ebx+28], edx
$LN4@DispatchPn:

; 217  : 
; 218  : 			ObDereferenceObject (attachedDevice);

  0008b	8b c8		 mov	 ecx, eax
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 219  : 		}
; 220  : 
; 221  : 		return PassFilteredIrp (Extension->LowerDeviceObject, Irp, OnDeviceUsageNotificationCompleted, Extension);

  00093	bb 00 00 00 00	 mov	 ebx, OFFSET _OnDeviceUsageNotificationCompleted@12
  00098	eb 39		 jmp	 SHORT $LN20@DispatchPn
$LN2@DispatchPn:

; 222  : 
; 223  : 
; 224  : 	case IRP_MN_REMOVE_DEVICE:
; 225  : 		Dump ("IRP_MN_REMOVE_DEVICE volume pdo=%p\n", Extension->Pdo);
; 226  : 
; 227  : 		IoReleaseRemoveLockAndWait (&Extension->Queue.RemoveLock, Irp);

  0009a	6a 18		 push	 24			; 00000018H
  0009c	56		 push	 esi
  0009d	53		 push	 ebx
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockAndWaitEx@12

; 228  : 		status = PassIrp (Extension->LowerDeviceObject, Irp);

  000a4	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  000a7	fe 46 23	 inc	 BYTE PTR [esi+35]
  000aa	83 46 60 24	 add	 DWORD PTR [esi+96], 36	; 00000024H
  000ae	8b d6		 mov	 edx, esi
  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8

; 229  : 
; 230  : 		IoDetachDevice (Extension->LowerDeviceObject);

  000b6	ff 77 1c	 push	 DWORD PTR [edi+28]
  000b9	8b f0		 mov	 esi, eax
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDetachDevice@4

; 231  : 
; 232  : 		IoDeleteDevice (DeviceObject);

  000c1	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteDevice@4

; 233  : 		return status;

  000ca	8b c6		 mov	 eax, esi
  000cc	eb 10		 jmp	 SHORT $LN10@DispatchPn
$LN6@DispatchPn:

; 206  : 	{
; 207  : 	case IRP_MN_START_DEVICE:
; 208  : 		Dump ("IRP_MN_START_DEVICE volume pdo=%p\n", Extension->Pdo);
; 209  : 		return PassFilteredIrp (Extension->LowerDeviceObject, Irp, OnStartDeviceCompleted, Extension);

  000ce	bb 00 00 00 00	 mov	 ebx, OFFSET _OnStartDeviceCompleted@12
$LN20@DispatchPn:
  000d3	57		 push	 edi
  000d4	ff 77 1c	 push	 DWORD PTR [edi+28]
  000d7	8b d6		 mov	 edx, esi
  000d9	e8 00 00 00 00	 call	 _PassFilteredIrp@16
$LN10@DispatchPn:
  000de	5f		 pop	 edi
  000df	5e		 pop	 esi
  000e0	5b		 pop	 ebx

; 241  : }

  000e1	5d		 pop	 ebp
  000e2	c2 08 00	 ret	 8
_DispatchPnp@16 ENDP
_TEXT	ENDS
EXTRN	__imp__PoCallDriver@8:PROC
EXTRN	__imp__PoStartNextPowerIrp@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _DispatchPower@16
_TEXT	SEGMENT
_DispatchPower@16 PROC					; COMDAT
; _Irp$ = esi
; _Extension$ = eax

; 245  : {

  00000	8b ff		 npad	 2
  00002	53		 push	 ebx
  00003	57		 push	 edi

; 246  : 	NTSTATUS status;
; 247  : 	PoStartNextPowerIrp (Irp);

  00004	56		 push	 esi
  00005	8b f8		 mov	 edi, eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoStartNextPowerIrp@4

; 248  : 
; 249  : 	status = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  0000d	6a 18		 push	 24			; 00000018H
  0000f	6a 01		 push	 1
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@FNODOBFM@
  00016	56		 push	 esi
  00017	8d 9f b8 00 00
	00		 lea	 ebx, DWORD PTR [edi+184]
  0001d	53		 push	 ebx
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAcquireRemoveLockEx@20

; 250  : 	if (!NT_SUCCESS (status))

  00024	85 c0		 test	 eax, eax
  00026	7d 0b		 jge	 SHORT $LN1@DispatchPo

; 251  : 		return TCCompleteIrp (Irp, status, 0);

  00028	6a 00		 push	 0
  0002a	50		 push	 eax
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 _TCCompleteIrp@12
  00031	eb 1f		 jmp	 SHORT $LN2@DispatchPo
$LN1@DispatchPo:

; 252  : 
; 253  : 	IoSkipCurrentIrpStackLocation (Irp);

  00033	fe 46 23	 inc	 BYTE PTR [esi+35]
  00036	83 46 60 24	 add	 DWORD PTR [esi+96], 36	; 00000024H

; 254  : 	status = PoCallDriver (Extension->LowerDeviceObject, Irp);

  0003a	56		 push	 esi
  0003b	ff 77 1c	 push	 DWORD PTR [edi+28]
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoCallDriver@8

; 255  : 
; 256  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00044	6a 18		 push	 24			; 00000018H
  00046	56		 push	 esi
  00047	53		 push	 ebx
  00048	8b f8		 mov	 edi, eax
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 257  : 	return status;

  00050	8b c7		 mov	 eax, edi
$LN2@DispatchPo:
  00052	5f		 pop	 edi
  00053	5b		 pop	 ebx

; 258  : }

  00054	c3		 ret	 0
_DispatchPower@16 ENDP
_TEXT	ENDS
PUBLIC	_VolumeFilterDispatchIrp@8
; Function compile flags: /Ogsp
;	COMDAT _VolumeFilterDispatchIrp@8
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_VolumeFilterDispatchIrp@8 PROC				; COMDAT

; 262  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 263  : 	VolumeFilterExtension *Extension = (VolumeFilterExtension *) DeviceObject->DeviceExtension;

  00005	8b 55 08	 mov	 edx, DWORD PTR _DeviceObject$[ebp]
  00008	53		 push	 ebx
  00009	56		 push	 esi

; 264  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);

  0000a	8b 75 0c	 mov	 esi, DWORD PTR _Irp$[ebp]
  0000d	8b 46 60	 mov	 eax, DWORD PTR [esi+96]

; 265  : 	NTSTATUS status;
; 266  : 
; 267  : 	ASSERT (!Extension->bRootDevice && Extension->IsVolumeFilterDevice);
; 268  : 
; 269  : 	switch (irpSp->MajorFunction)

  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	57		 push	 edi
  00013	8b 7a 28	 mov	 edi, DWORD PTR [edx+40]
  00016	80 f9 0e	 cmp	 cl, 14			; 0000000eH
  00019	74 68		 je	 SHORT $LN5@VolumeFilt@2
  0001b	80 f9 16	 cmp	 cl, 22			; 00000016H
  0001e	74 5a		 je	 SHORT $LN3@VolumeFilt@2
  00020	80 f9 1b	 cmp	 cl, 27			; 0000001bH
  00023	74 48		 je	 SHORT $LN4@VolumeFilt@2

; 279  : 
; 280  : 	default:
; 281  : 		status = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00025	6a 18		 push	 24			; 00000018H
  00027	6a 01		 push	 1
  00029	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@FNODOBFM@
  0002e	56		 push	 esi
  0002f	8d 9f b8 00 00
	00		 lea	 ebx, DWORD PTR [edi+184]
  00035	53		 push	 ebx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAcquireRemoveLockEx@20

; 282  : 		if (!NT_SUCCESS (status))

  0003c	85 c0		 test	 eax, eax
  0003e	7d 0b		 jge	 SHORT $LN1@VolumeFilt@2

; 283  : 			return TCCompleteIrp (Irp, status, 0);

  00040	6a 00		 push	 0
  00042	50		 push	 eax
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 _TCCompleteIrp@12
  00049	eb 40		 jmp	 SHORT $LN6@VolumeFilt@2
$LN1@VolumeFilt@2:

; 284  : 
; 285  : 		status = PassIrp (Extension->LowerDeviceObject, Irp);

  0004b	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  0004e	fe 46 23	 inc	 BYTE PTR [esi+35]
  00051	83 46 60 24	 add	 DWORD PTR [esi+96], 36	; 00000024H
  00055	8b d6		 mov	 edx, esi
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8

; 286  : 
; 287  : 		IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  0005d	6a 18		 push	 24			; 00000018H
  0005f	56		 push	 esi
  00060	53		 push	 ebx
  00061	8b f8		 mov	 edi, eax
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 288  : 		return status;

  00069	8b c7		 mov	 eax, edi
  0006b	eb 1e		 jmp	 SHORT $LN6@VolumeFilt@2
$LN4@VolumeFilt@2:

; 273  : 
; 274  : 	case IRP_MJ_PNP:
; 275  : 		return DispatchPnp (DeviceObject, Irp, Extension, irpSp);

  0006d	50		 push	 eax
  0006e	52		 push	 edx
  0006f	8b c7		 mov	 eax, edi
  00071	8b ce		 mov	 ecx, esi
  00073	e8 00 00 00 00	 call	 _DispatchPnp@16
  00078	eb 11		 jmp	 SHORT $LN6@VolumeFilt@2
$LN3@VolumeFilt@2:

; 276  : 
; 277  : 	case IRP_MJ_POWER:
; 278  : 		return DispatchPower (DeviceObject, Irp, Extension, irpSp);

  0007a	8b c7		 mov	 eax, edi
  0007c	e8 00 00 00 00	 call	 _DispatchPower@16
  00081	eb 08		 jmp	 SHORT $LN6@VolumeFilt@2
$LN5@VolumeFilt@2:

; 270  : 	{
; 271  : 	case IRP_MJ_DEVICE_CONTROL:
; 272  : 		return DispatchControl (DeviceObject, Irp, Extension, irpSp);

  00083	50		 push	 eax
  00084	8b c7		 mov	 eax, edi
  00086	e8 00 00 00 00	 call	 _DispatchControl@16
$LN6@VolumeFilt@2:
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx

; 289  : 	}
; 290  : }

  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
_VolumeFilterDispatchIrp@8 ENDP
_TEXT	ENDS
END
