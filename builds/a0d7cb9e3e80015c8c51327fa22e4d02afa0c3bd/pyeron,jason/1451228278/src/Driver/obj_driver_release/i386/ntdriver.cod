; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\users\public\desktop\projects\ciphershed\src\driver\ntdriver.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_RootDeviceObject
PUBLIC	_DriverShuttingDown
PUBLIC	_OsMajorVersion
PUBLIC	_DriverUnloadDisabled
PUBLIC	_PortableMode
PUBLIC	_VolumeClassFilterRegistered
PUBLIC	_CacheBootPassword
PUBLIC	_NonAdminSystemFavoritesAccessDisabled
_DATA	SEGMENT
COMM	_VirtualVolumeDeviceObjects:DWORD:01aH
COMM	_TCDriverObject:DWORD
COMM	_LastUniqueVolumeId:DWORD
COMM	_OsMinorVersion:DWORD
COMM	_SelfTestsPassed:DWORD
_DATA	ENDS
_BSS	SEGMENT
_RootDeviceObject DD 01H DUP (?)
_DriverShuttingDown DD 01H DUP (?)
_OsMajorVersion DD 01H DUP (?)
_DriverUnloadDisabled DD 01H DUP (?)
_PortableMode DD 01H DUP (?)
_VolumeClassFilterRegistered DD 01H DUP (?)
_CacheBootPassword DD 01H DUP (?)
_NonAdminSystemFavoritesAccessDisabled DD 01H DUP (?)
_EncryptionThreadPoolFreeCpuCountLimit DD 01H DUP (?)
_SystemFavoriteVolumeDirty DD 01H DUP (?)
_PagingFileCreationPrevented DD 01H DUP (?)
_BSS	ENDS
PUBLIC	_InitializeListHead@4
; Function compile flags: /Ogsp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
;	COMDAT _InitializeListHead@4
_TEXT	SEGMENT
_ListHead$ = 8						; size = 4
_InitializeListHead@4 PROC				; COMDAT

; 7550 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 7551 :     ListHead->Flink = ListHead->Blink = ListHead;

  00005	8b 45 08	 mov	 eax, DWORD PTR _ListHead$[ebp]
  00008	89 40 04	 mov	 DWORD PTR [eax+4], eax
  0000b	89 00		 mov	 DWORD PTR [eax], eax

; 7552 : }

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
_InitializeListHead@4 ENDP
_TEXT	ENDS
PUBLIC	_RtlSecureZeroMemory@8
; Function compile flags: /Ogsp
;	COMDAT _RtlSecureZeroMemory@8
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory@8 PROC				; COMDAT

; 8322 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 8323 :     volatile char *vptr = (volatile char *)ptr;
; 8324 : 
; 8325 : #if defined(_M_AMD64)
; 8326 : 
; 8327 :         __stosb((PUCHAR)((ULONG64)vptr), 0, cnt);
; 8328 : 
; 8329 : #else
; 8330 : 
; 8331 :     while (cnt) {

  00005	83 7d 0c 00	 cmp	 DWORD PTR _cnt$[ebp], 0
  00009	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  0000c	74 09		 je	 SHORT $LN1@RtlSecureZ
$LL2@RtlSecureZ:

; 8332 :         *vptr = 0;

  0000e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 8333 :         vptr++;

  00011	40		 inc	 eax

; 8334 :         cnt--;

  00012	ff 4d 0c	 dec	 DWORD PTR _cnt$[ebp]
  00015	75 f7		 jne	 SHORT $LL2@RtlSecureZ
$LN1@RtlSecureZ:

; 8335 :     }
; 8336 : 
; 8337 : #endif
; 8338 : 
; 8339 :     return ptr;

  00017	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]

; 8340 : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
_RtlSecureZeroMemory@8 ENDP
_TEXT	ENDS
PUBLIC	_KeInitializeSpinLock@4
; Function compile flags: /Ogsp
;	COMDAT _KeInitializeSpinLock@4
_TEXT	SEGMENT
_SpinLock$ = 8						; size = 4
_KeInitializeSpinLock@4 PROC				; COMDAT

; 15095: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 15096: 
; 15097:     *SpinLock = 0;

  00005	8b 45 08	 mov	 eax, DWORD PTR _SpinLock$[ebp]
  00008	83 20 00	 and	 DWORD PTR [eax], 0

; 15098:     return;
; 15099: }

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
_KeInitializeSpinLock@4 ENDP
_TEXT	ENDS
PUBLIC	_PsGetCurrentThread@0
EXTRN	__imp__KeGetCurrentThread@0:PROC
; Function compile flags: /Ogsp
;	COMDAT _PsGetCurrentThread@0
_TEXT	SEGMENT
_PsGetCurrentThread@0 PROC				; COMDAT

; 19989: 
; 19990:     return (PETHREAD)KeGetCurrentThread();

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp__KeGetCurrentThread@0
_PsGetCurrentThread@0 ENDP
_TEXT	ENDS
PUBLIC	_IoGetCurrentIrpStackLocation@4
; Function compile flags: /Ogsp
;	COMDAT _IoGetCurrentIrpStackLocation@4
_TEXT	SEGMENT
_Irp$ = 8						; size = 4
_IoGetCurrentIrpStackLocation@4 PROC			; COMDAT

; 23316: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 23317:     ASSERT(Irp->CurrentLocation <= Irp->StackCount + 1);
; 23318:     return Irp->Tail.Overlay.CurrentStackLocation;

  00005	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00008	8b 40 60	 mov	 eax, DWORD PTR [eax+96]

; 23319: }

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
_IoGetCurrentIrpStackLocation@4 ENDP
_TEXT	ENDS
PUBLIC	_IoGetNextIrpStackLocation@4
; Function compile flags: /Ogsp
;	COMDAT _IoGetNextIrpStackLocation@4
_TEXT	SEGMENT
_Irp$ = 8						; size = 4
_IoGetNextIrpStackLocation@4 PROC			; COMDAT

; 23479: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 23480:     ASSERT(Irp->CurrentLocation > 0);
; 23481: 
; 23482:     return ((Irp)->Tail.Overlay.CurrentStackLocation - 1 );

  00005	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00008	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  0000b	83 e8 24	 sub	 eax, 36			; 00000024H

; 23483: }

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
_IoGetNextIrpStackLocation@4 ENDP
_TEXT	ENDS
PUBLIC	_IoMarkIrpPending@4
; Function compile flags: /Ogsp
;	COMDAT _IoMarkIrpPending@4
_TEXT	SEGMENT
_Irp$ = 8						; size = 4
_IoMarkIrpPending@4 PROC				; COMDAT

; 23667: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 23668:     IoGetCurrentIrpStackLocation( (Irp) )->Control |= SL_PENDING_RETURNED;

  00005	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00008	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  0000b	80 48 03 01	 or	 BYTE PTR [eax+3], 1

; 23669: }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
_IoMarkIrpPending@4 ENDP
_TEXT	ENDS
PUBLIC	_DriverAddDevice@8
EXTRN	_DriveFilterAddDevice@8:PROC
EXTRN	_VolumeFilterAddDevice@8:PROC
EXTRN	__imp__ExFreePoolWithTag@8:PROC
EXTRN	__imp__IoGetDeviceInterfaces@16:PROC
EXTRN	_GUID_DEVINTERFACE_VOLUME:BYTE
EXTRN	_BootArgs:BYTE
EXTRN	_BootArgsValid:DWORD
; Function compile flags: /Ogsp
; File c:\users\public\desktop\projects\ciphershed\src\driver\ntdriver.c
;	COMDAT _DriverAddDevice@8
_TEXT	SEGMENT
_interfaceLinks$29763 = -4				; size = 4
_driverObject$ = 8					; size = 4
_pdo$ = 12						; size = 4
_DriverAddDevice@8 PROC					; COMDAT

; 112  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	56		 push	 esi

; 113  : #ifdef DEBUG
; 114  : 	char nameInfoBuffer[128];
; 115  : 	POBJECT_NAME_INFORMATION nameInfo = (POBJECT_NAME_INFORMATION) nameInfoBuffer;
; 116  : 	ULONG nameInfoSize;
; 117  : 	Dump ("AddDevice pdo=%p type=%x name=%ws\n", pdo, pdo->DeviceType, NT_SUCCESS (ObQueryNameString (pdo, nameInfo, sizeof (nameInfoBuffer), &nameInfoSize)) ? nameInfo->Name.Buffer : L"?");
; 118  : #endif
; 119  : 
; 120  : 	if (VolumeClassFilterRegistered && BootArgsValid && BootArgs.HiddenSystemPartitionStart != 0)

  00007	33 f6		 xor	 esi, esi
  00009	39 35 00 00 00
	00		 cmp	 DWORD PTR _VolumeClassFilterRegistered, esi
  0000f	74 50		 je	 SHORT $LN2@DriverAddD
  00011	39 35 00 00 00
	00		 cmp	 DWORD PTR _BootArgsValid, esi
  00017	74 48		 je	 SHORT $LN2@DriverAddD
  00019	a1 5a 00 00 00	 mov	 eax, DWORD PTR _BootArgs+90
  0001e	0b 05 5e 00 00
	00		 or	 eax, DWORD PTR _BootArgs+94
  00024	74 3b		 je	 SHORT $LN2@DriverAddD

; 121  : 	{
; 122  : 		PWSTR interfaceLinks;
; 123  : 		if (NT_SUCCESS (IoGetDeviceInterfaces (&GUID_DEVINTERFACE_VOLUME, pdo, DEVICE_INTERFACE_INCLUDE_NONACTIVE, &interfaceLinks)))

  00026	8d 45 fc	 lea	 eax, DWORD PTR _interfaceLinks$29763[ebp]
  00029	50		 push	 eax
  0002a	6a 01		 push	 1
  0002c	ff 75 0c	 push	 DWORD PTR _pdo$[ebp]
  0002f	68 00 00 00 00	 push	 OFFSET _GUID_DEVINTERFACE_VOLUME
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoGetDeviceInterfaces@16
  0003a	85 c0		 test	 eax, eax
  0003c	7c 23		 jl	 SHORT $LN2@DriverAddD

; 124  : 		{
; 125  : 			if (interfaceLinks[0] != UNICODE_NULL)

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _interfaceLinks$29763[ebp]

; 126  : 			{
; 127  : 				Dump ("Volume pdo=%p interface=%ws\n", pdo, interfaceLinks);
; 128  : 				ExFreePool (interfaceLinks);

  00041	56		 push	 esi
  00042	50		 push	 eax
  00043	66 39 30	 cmp	 WORD PTR [eax], si
  00046	74 13		 je	 SHORT $LN1@DriverAddD
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 129  : 
; 130  : 				return VolumeFilterAddDevice (driverObject, pdo);

  0004e	ff 75 0c	 push	 DWORD PTR _pdo$[ebp]
  00051	ff 75 08	 push	 DWORD PTR _driverObject$[ebp]
  00054	e8 00 00 00 00	 call	 _VolumeFilterAddDevice@8
  00059	eb 11		 jmp	 SHORT $LN4@DriverAddD
$LN1@DriverAddD:

; 131  : 			}
; 132  : 
; 133  : 			ExFreePool (interfaceLinks);

  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN2@DriverAddD:

; 134  : 		}
; 135  : 	}
; 136  : 
; 137  : 	return DriveFilterAddDevice (driverObject, pdo);

  00061	ff 75 0c	 push	 DWORD PTR _pdo$[ebp]
  00064	ff 75 08	 push	 DWORD PTR _driverObject$[ebp]
  00067	e8 00 00 00 00	 call	 _DriveFilterAddDevice@8
$LN4@DriverAddD:
  0006c	5e		 pop	 esi

; 138  : }

  0006d	c9		 leave
  0006e	c2 08 00	 ret	 8
_DriverAddDevice@8 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_DumpMemory@8
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _DumpMemory@8
_TEXT	SEGMENT
_str$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_mem$ = 8						; size = 4
_size$ = 12						; size = 4
_DumpMemory@8 PROC					; COMDAT

; 143  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 18	 sub	 esp, 24			; 00000018H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 144  : 	unsigned char str[20];
; 145  : 	unsigned char *m = mem;
; 146  : 	int i,j;
; 147  : 
; 148  : 	for (j = 0; j < size / 8; j++)

  00012	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  00015	99		 cdq
  00016	83 e2 07	 and	 edx, 7
  00019	03 c2		 add	 eax, edx
  0001b	c1 f8 03	 sar	 eax, 3
  0001e	56		 push	 esi
  0001f	8b 75 08	 mov	 esi, DWORD PTR _mem$[ebp]
  00022	85 c0		 test	 eax, eax
  00024	7e 2a		 jle	 SHORT $LN6@DumpMemory
  00026	8d 4d e8	 lea	 ecx, DWORD PTR _str$[ebp]
  00029	57		 push	 edi
  0002a	2b ce		 sub	 ecx, esi
  0002c	8b f8		 mov	 edi, eax
$LL8@DumpMemory:

; 149  : 	{
; 150  : 		memset (str,0,sizeof str);
; 151  : 		for (i = 0; i < 8; i++) 

  0002e	6a 08		 push	 8
  00030	8b c6		 mov	 eax, esi
  00032	5e		 pop	 esi
$LL5@DumpMemory:

; 152  : 		{
; 153  : 			if (m[i] > ' ' && m[i] <= '~')

  00033	8a 10		 mov	 dl, BYTE PTR [eax]
  00035	80 fa 20	 cmp	 dl, 32			; 00000020H
  00038	76 05		 jbe	 SHORT $LN2@DumpMemory
  0003a	80 fa 7e	 cmp	 dl, 126			; 0000007eH

; 154  : 				str[i]=m[i];
; 155  : 			else

  0003d	76 04		 jbe	 SHORT $LN4@DumpMemory
$LN2@DumpMemory:

; 156  : 				str[i]='.';

  0003f	c6 04 01 2e	 mov	 BYTE PTR [ecx+eax], 46	; 0000002eH
$LN4@DumpMemory:

; 149  : 	{
; 150  : 		memset (str,0,sizeof str);
; 151  : 		for (i = 0; i < 8; i++) 

  00043	40		 inc	 eax
  00044	4e		 dec	 esi
  00045	75 ec		 jne	 SHORT $LL5@DumpMemory

; 157  : 		}
; 158  : 
; 159  : 		Dump ("0x%08p  %02x %02x %02x %02x %02x %02x %02x %02x  %s\n",
; 160  : 			m, m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], str);
; 161  : 
; 162  : 		m+=8;

  00047	83 e9 08	 sub	 ecx, 8
  0004a	4f		 dec	 edi
  0004b	8b f0		 mov	 esi, eax
  0004d	75 df		 jne	 SHORT $LL8@DumpMemory
  0004f	5f		 pop	 edi
$LN6@DumpMemory:

; 163  : 	}
; 164  : }

  00050	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00053	33 cd		 xor	 ecx, ebp
  00055	5e		 pop	 esi
  00056	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005b	c9		 leave
  0005c	c2 08 00	 ret	 8
_DumpMemory@8 ENDP
_TEXT	ENDS
PUBLIC	_ValidateIOBufferSize@12
EXTRN	_memset:PROC
; Function compile flags: /Ogsp
;	COMDAT _ValidateIOBufferSize@12
_TEXT	SEGMENT
_irp$ = 8						; size = 4
_requiredBufferSize$ = 12				; size = 4
_type$ = 16						; size = 4
_ValidateIOBufferSize@12 PROC				; COMDAT

; 168  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 169  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (irp);
; 170  : 	BOOL input = (type == ValidateInput || type == ValidateInputOutput);

  00005	8b 55 10	 mov	 edx, DWORD PTR _type$[ebp]
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _irp$[ebp]
  0000b	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	85 d2		 test	 edx, edx
  00012	74 09		 je	 SHORT $LN7@ValidateIO
  00014	83 fa 02	 cmp	 edx, 2
  00017	74 04		 je	 SHORT $LN7@ValidateIO
  00019	33 ff		 xor	 edi, edi
  0001b	eb 03		 jmp	 SHORT $LN8@ValidateIO
$LN7@ValidateIO:
  0001d	33 ff		 xor	 edi, edi
  0001f	47		 inc	 edi
$LN8@ValidateIO:

; 171  : 	BOOL output = (type == ValidateOutput || type == ValidateInputOutput);

  00020	83 fa 01	 cmp	 edx, 1
  00023	74 09		 je	 SHORT $LN9@ValidateIO
  00025	83 fa 02	 cmp	 edx, 2
  00028	74 04		 je	 SHORT $LN9@ValidateIO
  0002a	33 f6		 xor	 esi, esi
  0002c	eb 03		 jmp	 SHORT $LN10@ValidateIO
$LN9@ValidateIO:
  0002e	33 f6		 xor	 esi, esi
  00030	46		 inc	 esi
$LN10@ValidateIO:

; 172  : 
; 173  : 	if ((input && irpSp->Parameters.DeviceIoControl.InputBufferLength < requiredBufferSize)
; 174  : 		|| (output && irpSp->Parameters.DeviceIoControl.OutputBufferLength < requiredBufferSize))

  00031	8b 55 0c	 mov	 edx, DWORD PTR _requiredBufferSize$[ebp]
  00034	85 ff		 test	 edi, edi
  00036	74 05		 je	 SHORT $LN2@ValidateIO
  00038	39 50 08	 cmp	 DWORD PTR [eax+8], edx
  0003b	72 09		 jb	 SHORT $LN3@ValidateIO
$LN2@ValidateIO:
  0003d	85 f6		 test	 esi, esi
  0003f	74 14		 je	 SHORT $LN4@ValidateIO
  00041	39 50 04	 cmp	 DWORD PTR [eax+4], edx
  00044	73 0f		 jae	 SHORT $LN4@ValidateIO
$LN3@ValidateIO:

; 175  : 	{
; 176  : 		Dump ("STATUS_BUFFER_TOO_SMALL ioctl=0x%x,%d in=%d out=%d reqsize=%d insize=%d outsize=%d\n", (int) (irpSp->Parameters.DeviceIoControl.IoControlCode >> 16), (int) ((irpSp->Parameters.DeviceIoControl.IoControlCode & 0x1FFF) >> 2), input, output, requiredBufferSize, irpSp->Parameters.DeviceIoControl.InputBufferLength, irpSp->Parameters.DeviceIoControl.OutputBufferLength);
; 177  : 
; 178  : 		irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
; 179  : 		irp->IoStatus.Information = 0;

  00046	83 61 1c 00	 and	 DWORD PTR [ecx+28], 0
  0004a	c7 41 18 23 00
	00 c0		 mov	 DWORD PTR [ecx+24], -1073741789 ; c0000023H

; 180  : 		return FALSE;

  00051	33 c0		 xor	 eax, eax
  00053	eb 1a		 jmp	 SHORT $LN5@ValidateIO
$LN4@ValidateIO:

; 181  : 	}
; 182  : 
; 183  : 	if (!input && output)

  00055	85 ff		 test	 edi, edi
  00057	75 13		 jne	 SHORT $LN1@ValidateIO
  00059	85 f6		 test	 esi, esi
  0005b	74 0f		 je	 SHORT $LN1@ValidateIO

; 184  : 		memset (irp->AssociatedIrp.SystemBuffer, 0, irpSp->Parameters.DeviceIoControl.OutputBufferLength);

  0005d	ff 70 04	 push	 DWORD PTR [eax+4]
  00060	57		 push	 edi
  00061	ff 71 0c	 push	 DWORD PTR [ecx+12]
  00064	e8 00 00 00 00	 call	 _memset
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@ValidateIO:

; 185  : 
; 186  : 	return TRUE;

  0006c	33 c0		 xor	 eax, eax
  0006e	40		 inc	 eax
$LN5@ValidateIO:
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi

; 187  : }

  00071	5d		 pop	 ebp
  00072	c2 0c 00	 ret	 12			; 0000000cH
_ValidateIOBufferSize@12 ENDP
_TEXT	ENDS
PUBLIC	_GetVirtualVolumeDeviceObject@4
; Function compile flags: /Ogsp
;	COMDAT _GetVirtualVolumeDeviceObject@4
_TEXT	SEGMENT
_driveNumber$ = 8					; size = 4
_GetVirtualVolumeDeviceObject@4 PROC			; COMDAT

; 191  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 192  : 	if (driveNumber < MIN_MOUNTED_VOLUME_DRIVE_NUMBER || driveNumber > MAX_MOUNTED_VOLUME_DRIVE_NUMBER)

  00005	8b 45 08	 mov	 eax, DWORD PTR _driveNumber$[ebp]
  00008	83 f8 19	 cmp	 eax, 25			; 00000019H
  0000b	77 09		 ja	 SHORT $LN1@GetVirtual

; 194  : 
; 195  : 	return VirtualVolumeDeviceObjects[driveNumber];

  0000d	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _VirtualVolumeDeviceObjects[eax*4]
  00014	eb 02		 jmp	 SHORT $LN3@GetVirtual
$LN1@GetVirtual:

; 193  : 		return NULL;

  00016	33 c0		 xor	 eax, eax
$LN3@GetVirtual:

; 196  : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
_GetVirtualVolumeDeviceObject@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	__$ArrayPad$
PUBLIC	_TCCreateRootDeviceObject@4
EXTRN	__imp__IoRegisterShutdownNotification@4:PROC
EXTRN	__imp__IoDeleteDevice@4:PROC
EXTRN	__imp__IoCreateSymbolicLink@8:PROC
EXTRN	__imp__KeInitializeMutex@8:PROC
EXTRN	__imp__IoCreateDevice@28:PROC
EXTRN	__imp__RtlInitUnicodeString@8:PROC
_BSS	SEGMENT
_RootDeviceControlMutex DB 020H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'T', 00H, 'r', 00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r'
	DB	00H, 'y', 00H, 'p', 00H, 't', 00H, 00H, 00H	;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'T', 00H, 'r'
	DB	00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r', 00H, 'y', 00H, 'p', 00H
	DB	't', 00H, 00H, 00H				;  ?? ::PBOPGDP::`string'
; Function compile flags: /Ogsp
INIT$s	ENDS
;	COMDAT _TCCreateRootDeviceObject@4
INIT	SEGMENT
_Win32NameString$ = -152				; size = 8
_ntUnicodeString$ = -144				; size = 8
_DeviceObject$ = -136					; size = 4
_ntname$ = -132						; size = 64
_dosname$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_DriverObject$ = 8					; size = 4
_TCCreateRootDeviceObject@4 PROC			; COMDAT

; 354  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	8b 7d 08	 mov	 edi, DWORD PTR _DriverObject$[ebp]

; 355  : 	UNICODE_STRING Win32NameString, ntUnicodeString;
; 356  : 	WCHAR dosname[32], ntname[32];
; 357  : 	PDEVICE_OBJECT DeviceObject;
; 358  : 	NTSTATUS ntStatus;
; 359  : 	BOOL *bRootExtension;
; 360  : 
; 361  : 	Dump ("TCCreateRootDeviceObject BEGIN\n");
; 362  : 	ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);
; 363  : 
; 364  : 	wcscpy (dosname, (LPWSTR) DOS_ROOT_PREFIX);

  0001a	33 c0		 xor	 eax, eax
$LL5@TCCreateRo:
  0001c	0f b7 88 00 00
	00 00		 movzx	 ecx, WORD PTR ??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@[eax]
  00023	66 89 4c 05 bc	 mov	 WORD PTR _dosname$[ebp+eax], cx
  00028	40		 inc	 eax
  00029	40		 inc	 eax
  0002a	66 85 c9	 test	 cx, cx
  0002d	75 ed		 jne	 SHORT $LL5@TCCreateRo

; 365  : 	wcscpy (ntname, (LPWSTR) NT_ROOT_PREFIX);

  0002f	33 c0		 xor	 eax, eax
$LL6@TCCreateRo:
  00031	0f b7 88 00 00
	00 00		 movzx	 ecx, WORD PTR ??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@[eax]
  00038	66 89 8c 05 7c
	ff ff ff	 mov	 WORD PTR _ntname$[ebp+eax], cx
  00040	40		 inc	 eax
  00041	40		 inc	 eax
  00042	66 85 c9	 test	 cx, cx
  00045	75 ea		 jne	 SHORT $LL6@TCCreateRo

; 366  : 	RtlInitUnicodeString (&ntUnicodeString, ntname);

  00047	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__RtlInitUnicodeString@8
  0004d	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _ntname$[ebp]
  00053	50		 push	 eax
  00054	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _ntUnicodeString$[ebp]
  0005a	50		 push	 eax
  0005b	ff d6		 call	 esi

; 367  : 	RtlInitUnicodeString (&Win32NameString, dosname);

  0005d	8d 45 bc	 lea	 eax, DWORD PTR _dosname$[ebp]
  00060	50		 push	 eax
  00061	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _Win32NameString$[ebp]
  00067	50		 push	 eax
  00068	ff d6		 call	 esi

; 368  : 
; 369  : 	Dump ("Creating root device nt=%ls dos=%ls\n", ntname, dosname);
; 370  : 	
; 371  : 	ntStatus = IoCreateDevice (
; 372  : 					  DriverObject,
; 373  : 					  sizeof (BOOL),
; 374  : 					  &ntUnicodeString,
; 375  : 					  FILE_DEVICE_UNKNOWN,
; 376  : 					  FILE_DEVICE_SECURE_OPEN,
; 377  : 					  FALSE,
; 378  : 					  &DeviceObject);

  0006a	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _DeviceObject$[ebp]
  00070	50		 push	 eax
  00071	6a 00		 push	 0
  00073	68 00 01 00 00	 push	 256			; 00000100H
  00078	6a 22		 push	 34			; 00000022H
  0007a	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _ntUnicodeString$[ebp]
  00080	50		 push	 eax
  00081	6a 04		 push	 4
  00083	57		 push	 edi
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoCreateDevice@28

; 379  : 
; 380  : 	if (!NT_SUCCESS (ntStatus))

  0008a	85 c0		 test	 eax, eax

; 381  : 	{
; 382  : 		Dump ("TCCreateRootDeviceObject NTSTATUS = 0x%08x END\n", ntStatus);
; 383  : 		return ntStatus;/* Failed to create DeviceObject */

  0008c	7c 6b		 jl	 SHORT $LN3@TCCreateRo

; 384  : 	}
; 385  : 
; 386  : 	DeviceObject->Flags |= DO_DIRECT_IO;

  0008e	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00094	83 48 1c 10	 or	 DWORD PTR [eax+28], 16	; 00000010H

; 387  : 	DeviceObject->AlignmentRequirement = FILE_WORD_ALIGNMENT;

  00098	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  0009e	33 c0		 xor	 eax, eax
  000a0	40		 inc	 eax
  000a1	89 41 5c	 mov	 DWORD PTR [ecx+92], eax

; 388  : 
; 389  : 	/* Setup the device extension */
; 390  : 	bRootExtension = (BOOL *) DeviceObject->DeviceExtension;

  000a4	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  000aa	8b 49 28	 mov	 ecx, DWORD PTR [ecx+40]

; 391  : 	*bRootExtension = TRUE;
; 392  : 
; 393  : 	KeInitializeMutex (&RootDeviceControlMutex, 0);

  000ad	6a 00		 push	 0
  000af	68 00 00 00 00	 push	 OFFSET _RootDeviceControlMutex
  000b4	89 01		 mov	 DWORD PTR [ecx], eax
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeMutex@8

; 394  : 
; 395  : 	ntStatus = IoCreateSymbolicLink (&Win32NameString, &ntUnicodeString);

  000bc	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _ntUnicodeString$[ebp]
  000c2	50		 push	 eax
  000c3	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _Win32NameString$[ebp]
  000c9	50		 push	 eax
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoCreateSymbolicLink@8

; 396  : 
; 397  : 	if (!NT_SUCCESS (ntStatus))
; 398  : 	{
; 399  : 		Dump ("TCCreateRootDeviceObject NTSTATUS = 0x%08x END\n", ntStatus);
; 400  : 		IoDeleteDevice (DeviceObject);

  000d0	ff b5 78 ff ff
	ff		 push	 DWORD PTR _DeviceObject$[ebp]
  000d6	8b f0		 mov	 esi, eax
  000d8	85 f6		 test	 esi, esi
  000da	7d 0a		 jge	 SHORT $LN1@TCCreateRo
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteDevice@4

; 401  : 		return ntStatus;

  000e2	8b c6		 mov	 eax, esi
  000e4	eb 13		 jmp	 SHORT $LN3@TCCreateRo
$LN1@TCCreateRo:

; 402  : 	}
; 403  : 
; 404  : 	IoRegisterShutdownNotification (DeviceObject);

  000e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoRegisterShutdownNotification@4

; 405  : 	RootDeviceObject = DeviceObject;

  000ec	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  000f2	a3 00 00 00 00	 mov	 DWORD PTR _RootDeviceObject, eax

; 406  : 
; 407  : 	Dump ("TCCreateRootDeviceObject STATUS_SUCCESS END\n");
; 408  : 	return STATUS_SUCCESS;

  000f7	33 c0		 xor	 eax, eax
$LN3@TCCreateRo:

; 409  : }

  000f9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fc	5f		 pop	 edi
  000fd	33 cd		 xor	 ecx, ebp
  000ff	5e		 pop	 esi
  00100	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00105	c9		 leave
  00106	c2 04 00	 ret	 4
_TCCreateRootDeviceObject@4 ENDP
INIT	ENDS
PUBLIC	_RootDeviceControlMutexAcquireNoWait@0
EXTRN	__imp__KeWaitForSingleObject@20:PROC
; Function compile flags: /Ogsp
;	COMDAT _RootDeviceControlMutexAcquireNoWait@0
_TEXT	SEGMENT
_timeout$ = -8						; size = 8
_RootDeviceControlMutexAcquireNoWait@0 PROC		; COMDAT

; 479  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	51		 push	 ecx
  00007	56		 push	 esi

; 480  : 	NTSTATUS status;
; 481  : 	LARGE_INTEGER timeout;
; 482  : 	timeout.QuadPart = 0;

  00008	33 f6		 xor	 esi, esi

; 483  : 
; 484  : 	status = KeWaitForMutexObject (&RootDeviceControlMutex, Executive, KernelMode, FALSE, &timeout);

  0000a	8d 45 f8	 lea	 eax, DWORD PTR _timeout$[ebp]
  0000d	50		 push	 eax
  0000e	56		 push	 esi
  0000f	56		 push	 esi
  00010	56		 push	 esi
  00011	68 00 00 00 00	 push	 OFFSET _RootDeviceControlMutex
  00016	89 75 f8	 mov	 DWORD PTR _timeout$[ebp], esi
  00019	89 75 fc	 mov	 DWORD PTR _timeout$[ebp+4], esi
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 485  : 	return NT_SUCCESS (status) && status != STATUS_TIMEOUT;

  00022	3b c6		 cmp	 eax, esi
  00024	7c 0c		 jl	 SHORT $LN3@RootDevice
  00026	3d 02 01 00 00	 cmp	 eax, 258		; 00000102H
  0002b	74 05		 je	 SHORT $LN3@RootDevice
  0002d	33 c0		 xor	 eax, eax
  0002f	40		 inc	 eax
  00030	eb 02		 jmp	 SHORT $LN4@RootDevice
$LN3@RootDevice:
  00032	33 c0		 xor	 eax, eax
$LN4@RootDevice:
  00034	5e		 pop	 esi

; 486  : }

  00035	c9		 leave
  00036	c3		 ret	 0
_RootDeviceControlMutexAcquireNoWait@0 ENDP
_TEXT	ENDS
PUBLIC	_RootDeviceControlMutexRelease@0
EXTRN	__imp__KeReleaseMutex@8:PROC
; Function compile flags: /Ogsp
;	COMDAT _RootDeviceControlMutexRelease@0
_TEXT	SEGMENT
_RootDeviceControlMutexRelease@0 PROC			; COMDAT

; 491  : 	KeReleaseMutex (&RootDeviceControlMutex, FALSE);

  00000	6a 00		 push	 0
  00002	68 00 00 00 00	 push	 OFFSET _RootDeviceControlMutex
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeReleaseMutex@8

; 492  : }

  0000d	c3		 ret	 0
_RootDeviceControlMutexRelease@0 ENDP
_TEXT	ENDS
PUBLIC	_TCStartThreadInProcess@16
EXTRN	__imp__ZwClose@4:PROC
EXTRN	__imp__ObReferenceObjectByHandle@24:PROC
EXTRN	__imp__PsCreateSystemThread@28:PROC
EXTRN	__imp__ObOpenObjectByPointer@28:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCStartThreadInProcess@16
_TEXT	SEGMENT
_threadObjAttributes$ = -28				; size = 24
_processHandle$ = -4					; size = 4
_threadProc$ = 8					; size = 4
_threadArg$ = 12					; size = 4
_kThread$ = 16						; size = 4
_threadHandle$ = 20					; size = 4
_process$ = 20						; size = 4
_TCStartThreadInProcess@16 PROC				; COMDAT

; 1594 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00008	56		 push	 esi

; 1595 : 	NTSTATUS status;
; 1596 : 	HANDLE threadHandle;
; 1597 : 	HANDLE processHandle = NULL;

  00009	33 f6		 xor	 esi, esi
  0000b	57		 push	 edi
  0000c	89 75 fc	 mov	 DWORD PTR _processHandle$[ebp], esi

; 1598 : 	OBJECT_ATTRIBUTES threadObjAttributes;
; 1599 : 
; 1600 : 	if (process)

  0000f	bf 00 02 00 00	 mov	 edi, 512		; 00000200H
  00014	39 75 14	 cmp	 DWORD PTR _process$[ebp], esi
  00017	74 16		 je	 SHORT $LN8@TCStartThr

; 1601 : 	{
; 1602 : 		status = ObOpenObjectByPointer (process, OBJ_KERNEL_HANDLE, NULL, 0, NULL, KernelMode, &processHandle);

  00019	8d 45 fc	 lea	 eax, DWORD PTR _processHandle$[ebp]
  0001c	50		 push	 eax
  0001d	56		 push	 esi
  0001e	56		 push	 esi
  0001f	56		 push	 esi
  00020	56		 push	 esi
  00021	57		 push	 edi
  00022	ff 75 14	 push	 DWORD PTR _process$[ebp]
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ObOpenObjectByPointer@28

; 1603 : 		if (!NT_SUCCESS (status))

  0002b	3b c6		 cmp	 eax, esi

; 1604 : 			return status;

  0002d	7c 77		 jl	 SHORT $LN6@TCStartThr
$LN8@TCStartThr:

; 1605 : 	}
; 1606 : 
; 1607 : 	InitializeObjectAttributes (&threadObjAttributes, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);
; 1608 : 	
; 1609 : 	status = PsCreateSystemThread (&threadHandle, THREAD_ALL_ACCESS, &threadObjAttributes, processHandle, NULL, threadProc, threadArg);

  0002f	ff 75 0c	 push	 DWORD PTR _threadArg$[ebp]
  00032	8d 45 e4	 lea	 eax, DWORD PTR _threadObjAttributes$[ebp]
  00035	ff 75 08	 push	 DWORD PTR _threadProc$[ebp]
  00038	89 7d f0	 mov	 DWORD PTR _threadObjAttributes$[ebp+12], edi
  0003b	56		 push	 esi
  0003c	ff 75 fc	 push	 DWORD PTR _processHandle$[ebp]
  0003f	bf ff 03 1f 00	 mov	 edi, 2032639		; 001f03ffH
  00044	50		 push	 eax
  00045	57		 push	 edi
  00046	8d 45 14	 lea	 eax, DWORD PTR _threadHandle$[ebp]
  00049	50		 push	 eax
  0004a	c7 45 e4 18 00
	00 00		 mov	 DWORD PTR _threadObjAttributes$[ebp], 24 ; 00000018H
  00051	89 75 e8	 mov	 DWORD PTR _threadObjAttributes$[ebp+4], esi
  00054	89 75 ec	 mov	 DWORD PTR _threadObjAttributes$[ebp+8], esi
  00057	89 75 f4	 mov	 DWORD PTR _threadObjAttributes$[ebp+16], esi
  0005a	89 75 f8	 mov	 DWORD PTR _threadObjAttributes$[ebp+20], esi
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsCreateSystemThread@28

; 1610 : 	if (!NT_SUCCESS (status))

  00063	3b c6		 cmp	 eax, esi

; 1611 : 		return status;

  00065	7c 3f		 jl	 SHORT $LN6@TCStartThr
  00067	53		 push	 ebx

; 1612 : 
; 1613 : 	status = ObReferenceObjectByHandle (threadHandle, THREAD_ALL_ACCESS, NULL, KernelMode, (PVOID *) kThread, NULL);

  00068	8b 5d 10	 mov	 ebx, DWORD PTR _kThread$[ebp]
  0006b	56		 push	 esi
  0006c	53		 push	 ebx
  0006d	56		 push	 esi
  0006e	56		 push	 esi
  0006f	57		 push	 edi
  00070	ff 75 14	 push	 DWORD PTR _threadHandle$[ebp]
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ObReferenceObjectByHandle@24
  00079	8b f8		 mov	 edi, eax

; 1614 : 	if (!NT_SUCCESS (status))

  0007b	3b fe		 cmp	 edi, esi
  0007d	7d 0f		 jge	 SHORT $LN2@TCStartThr

; 1615 : 	{
; 1616 : 		ZwClose (threadHandle);

  0007f	ff 75 14	 push	 DWORD PTR _threadHandle$[ebp]
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 1617 : 		*kThread = NULL;

  00088	89 33		 mov	 DWORD PTR [ebx], esi

; 1618 : 		return status;

  0008a	8b c7		 mov	 eax, edi
  0008c	eb 17		 jmp	 SHORT $LN9@TCStartThr
$LN2@TCStartThr:

; 1619 : 	}
; 1620 : 
; 1621 : 	if (processHandle)

  0008e	39 75 fc	 cmp	 DWORD PTR _processHandle$[ebp], esi
  00091	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__ZwClose@4
  00097	74 05		 je	 SHORT $LN1@TCStartThr

; 1622 : 		ZwClose (processHandle);

  00099	ff 75 fc	 push	 DWORD PTR _processHandle$[ebp]
  0009c	ff d6		 call	 esi
$LN1@TCStartThr:

; 1623 : 
; 1624 : 	ZwClose (threadHandle);

  0009e	ff 75 14	 push	 DWORD PTR _threadHandle$[ebp]
  000a1	ff d6		 call	 esi

; 1625 : 	return STATUS_SUCCESS;

  000a3	33 c0		 xor	 eax, eax
$LN9@TCStartThr:
  000a5	5b		 pop	 ebx
$LN6@TCStartThr:
  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi

; 1626 : }

  000a8	c9		 leave
  000a9	c2 10 00	 ret	 16			; 00000010H
_TCStartThreadInProcess@16 ENDP
_TEXT	ENDS
PUBLIC	_TCStopThread@8
EXTRN	__imp_@ObfDereferenceObject@4:PROC
EXTRN	__imp__KeSetEvent@12:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCStopThread@8
_TEXT	SEGMENT
_kThread$ = 8						; size = 4
_wakeUpEvent$ = 12					; size = 4
_TCStopThread@8 PROC					; COMDAT

; 1630 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 1631 : 	if (wakeUpEvent)

  00006	33 f6		 xor	 esi, esi
  00008	39 75 0c	 cmp	 DWORD PTR _wakeUpEvent$[ebp], esi
  0000b	74 0b		 je	 SHORT $LN1@TCStopThre

; 1632 : 		KeSetEvent (wakeUpEvent, 0, FALSE);

  0000d	56		 push	 esi
  0000e	56		 push	 esi
  0000f	ff 75 0c	 push	 DWORD PTR _wakeUpEvent$[ebp]
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
$LN1@TCStopThre:

; 1633 : 
; 1634 : 	KeWaitForSingleObject (kThread, Executive, KernelMode, FALSE, NULL);

  00018	56		 push	 esi
  00019	56		 push	 esi
  0001a	56		 push	 esi
  0001b	56		 push	 esi
  0001c	ff 75 08	 push	 DWORD PTR _kThread$[ebp]
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 1635 : 	ObDereferenceObject (kThread);

  00025	8b 4d 08	 mov	 ecx, DWORD PTR _kThread$[ebp]
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4
  0002e	5e		 pop	 esi

; 1636 : }

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
_TCStopThread@8 ENDP
_TEXT	ENDS
PUBLIC	_TCStopVolumeThread@8
EXTRN	__imp__KeReleaseSemaphore@16:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCStopVolumeThread@8
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_Extension$ = 12					; size = 4
_TCStopVolumeThread@8 PROC				; COMDAT

; 1717 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 1718 : 	NTSTATUS ntStatus;
; 1719 : 
; 1720 : 	if (DeviceObject);	/* Remove compiler warning */
; 1721 : 
; 1722 : 	Dump ("Signalling thread to quit...\n");
; 1723 : 
; 1724 : 	Extension->bThreadShouldQuit = TRUE;

  00006	8b 75 0c	 mov	 esi, DWORD PTR _Extension$[ebp]
  00009	57		 push	 edi
  0000a	33 c0		 xor	 eax, eax
  0000c	40		 inc	 eax

; 1725 : 
; 1726 : 	KeReleaseSemaphore (&Extension->RequestSemaphore,
; 1727 : 			    0,
; 1728 : 			    1,
; 1729 : 			    TRUE);

  0000d	50		 push	 eax
  0000e	50		 push	 eax
  0000f	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  00012	33 ff		 xor	 edi, edi
  00014	57		 push	 edi
  00015	8d 46 40	 lea	 eax, DWORD PTR [esi+64]
  00018	50		 push	 eax
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeReleaseSemaphore@16

; 1730 : 
; 1731 : 	ntStatus = KeWaitForSingleObject (Extension->peThread,
; 1732 : 					  Executive,
; 1733 : 					  KernelMode,
; 1734 : 					  FALSE,
; 1735 : 					  NULL);

  0001f	57		 push	 edi
  00020	57		 push	 edi
  00021	57		 push	 edi
  00022	57		 push	 edi
  00023	ff 76 20	 push	 DWORD PTR [esi+32]
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 1736 : 
; 1737 : 	ASSERT (NT_SUCCESS (ntStatus));
; 1738 : 
; 1739 : 	ObDereferenceObject (Extension->peThread);

  0002c	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 1740 : 	Extension->peThread = NULL;

  00035	89 7e 20	 mov	 DWORD PTR [esi+32], edi
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi

; 1741 : 
; 1742 : 	Dump ("Thread exited\n");
; 1743 : }

  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
_TCStopVolumeThread@8 ENDP
_TEXT	ENDS
PUBLIC	_TCSleep@4
EXTRN	__imp__KeSetTimerEx@20:PROC
EXTRN	__imp__KeInitializeTimerEx@8:PROC
EXTRN	__imp__ExAllocatePoolWithTag@12:PROC
EXTRN	__allmul:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCSleep@4
_TEXT	SEGMENT
_duetime$ = -8						; size = 8
_milliSeconds$ = 8					; size = 4
_TCSleep@4 PROC						; COMDAT

; 1748 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	51		 push	 ecx
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi

; 1749 : 	PKTIMER timer = (PKTIMER) TCalloc (sizeof (KTIMER));

  0000a	bf 54 43 4d 4d	 mov	 edi, 1296909140		; 4d4d4354H
  0000f	57		 push	 edi
  00010	6a 28		 push	 40			; 00000028H
  00012	33 f6		 xor	 esi, esi
  00014	56		 push	 esi
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0001b	8b d8		 mov	 ebx, eax

; 1750 : 	LARGE_INTEGER duetime;
; 1751 : 
; 1752 : 	if (!timer)

  0001d	3b de		 cmp	 ebx, esi
  0001f	74 42		 je	 SHORT $LN2@TCSleep

; 1753 : 		return;
; 1754 : 
; 1755 : 	duetime.QuadPart = (__int64) milliSeconds * -10000;

  00021	8b 45 08	 mov	 eax, DWORD PTR _milliSeconds$[ebp]
  00024	6a ff		 push	 -1
  00026	99		 cdq
  00027	68 f0 d8 ff ff	 push	 -10000			; ffffd8f0H
  0002c	52		 push	 edx
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 __allmul

; 1756 : 	KeInitializeTimerEx(timer, NotificationTimer);

  00033	56		 push	 esi
  00034	53		 push	 ebx
  00035	89 45 f8	 mov	 DWORD PTR _duetime$[ebp], eax
  00038	89 55 fc	 mov	 DWORD PTR _duetime$[ebp+4], edx
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeTimerEx@8

; 1757 : 	KeSetTimerEx(timer, duetime, 0, NULL);

  00041	56		 push	 esi
  00042	56		 push	 esi
  00043	ff 75 fc	 push	 DWORD PTR _duetime$[ebp+4]
  00046	ff 75 f8	 push	 DWORD PTR _duetime$[ebp]
  00049	53		 push	 ebx
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetTimerEx@20

; 1758 : 
; 1759 : 	KeWaitForSingleObject (timer, Executive, KernelMode, FALSE, NULL);

  00050	56		 push	 esi
  00051	56		 push	 esi
  00052	56		 push	 esi
  00053	56		 push	 esi
  00054	53		 push	 ebx
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 1760 : 
; 1761 : 	TCfree (timer);

  0005b	57		 push	 edi
  0005c	53		 push	 ebx
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN2@TCSleep:
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx

; 1762 : }

  00066	c9		 leave
  00067	c2 04 00	 ret	 4
_TCSleep@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DA@GMJGMIMP@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	__$ArrayPad$
PUBLIC	_TCGetNTNameFromNumber@8
EXTRN	__imp__wcsncat:PROC
;	COMDAT ??_C@_1DA@GMJGMIMP@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DA@GMJGMIMP@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'T', 00H, 'r', 00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r'
	DB	00H, 'y', 00H, 'p', 00H, 't', 00H, 'V', 00H, 'o', 00H, 'l', 00H
	DB	'u', 00H, 'm', 00H, 'e', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
text$s	ENDS
;	COMDAT _TCGetNTNameFromNumber@8
_TEXT	SEGMENT
_tmp$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
_ntname$ = 8						; size = 4
_nDriveNo$ = 12						; size = 4
_TCGetNTNameFromNumber@8 PROC				; COMDAT

; 1873 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00012	56		 push	 esi
  00013	8b 75 08	 mov	 esi, DWORD PTR _ntname$[ebp]

; 1874 : 	WCHAR tmp[3] =
; 1875 : 	{0, ':', 0};

  00016	6a 3a		 push	 58			; 0000003aH
  00018	58		 pop	 eax
  00019	66 89 45 f6	 mov	 WORD PTR _tmp$[ebp+2], ax
  0001d	33 c0		 xor	 eax, eax
  0001f	66 89 45 f8	 mov	 WORD PTR _tmp$[ebp+4], ax

; 1876 : 	int j = nDriveNo + (WCHAR) 'A';

  00023	8b 45 0c	 mov	 eax, DWORD PTR _nDriveNo$[ebp]
  00026	83 c0 41	 add	 eax, 65			; 00000041H

; 1877 : 
; 1878 : 	tmp[0] = (short) j;

  00029	66 89 45 f4	 mov	 WORD PTR _tmp$[ebp], ax

; 1879 : 	wcscpy (ntname, (LPWSTR) NT_MOUNT_PREFIX);

  0002d	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DA@GMJGMIMP@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@FNODOBFM@
  00032	8b d6		 mov	 edx, esi
  00034	2b d0		 sub	 edx, eax
$LL3@TCGetNTNam:
  00036	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00039	66 89 0c 02	 mov	 WORD PTR [edx+eax], cx
  0003d	40		 inc	 eax
  0003e	40		 inc	 eax
  0003f	66 85 c9	 test	 cx, cx
  00042	75 f2		 jne	 SHORT $LL3@TCGetNTNam

; 1880 : 	wcsncat (ntname, tmp, 1);

  00044	6a 01		 push	 1
  00046	8d 45 f4	 lea	 eax, DWORD PTR _tmp$[ebp]
  00049	50		 push	 eax
  0004a	56		 push	 esi
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcsncat

; 1881 : }

  00051	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
  00057	33 cd		 xor	 ecx, ebp
  00059	5e		 pop	 esi
  0005a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005f	c9		 leave
  00060	c2 08 00	 ret	 8
_TCGetNTNameFromNumber@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	__$ArrayPad$
PUBLIC	_TCGetDosNameFromNumber@8
;	COMDAT ??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
text$s	ENDS
;	COMDAT _TCGetDosNameFromNumber@8
_TEXT	SEGMENT
_tmp$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
_dosname$ = 8						; size = 4
_nDriveNo$ = 12						; size = 4
_TCGetDosNameFromNumber@8 PROC				; COMDAT

; 1884 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _dosname$[ebp]
  00015	56		 push	 esi
  00016	57		 push	 edi

; 1885 : 	WCHAR tmp[3] =
; 1886 : 	{0, ':', 0};

  00017	6a 3a		 push	 58			; 0000003aH
  00019	58		 pop	 eax
  0001a	66 89 45 f6	 mov	 WORD PTR _tmp$[ebp+2], ax
  0001e	33 c0		 xor	 eax, eax
  00020	66 89 45 f8	 mov	 WORD PTR _tmp$[ebp+4], ax

; 1887 : 	int j = nDriveNo + (WCHAR) 'A';

  00024	8b 45 0c	 mov	 eax, DWORD PTR _nDriveNo$[ebp]
  00027	83 c0 41	 add	 eax, 65			; 00000041H

; 1888 : 
; 1889 : 	tmp[0] = (short) j;

  0002a	66 89 45 f4	 mov	 WORD PTR _tmp$[ebp], ax

; 1890 : 	//This is a risk point from CVE-2015-7358, there are global and per user mounts, need more logic here.
; 1891 : 	wcscpy (dosname, (LPWSTR) DOS_MOUNT_PREFIX);

  0002e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@FNODOBFM@
  00033	8b f1		 mov	 esi, ecx
  00035	2b f0		 sub	 esi, eax
$LL3@TCGetDosNa:
  00037	0f b7 10	 movzx	 edx, WORD PTR [eax]
  0003a	66 89 14 06	 mov	 WORD PTR [esi+eax], dx
  0003e	40		 inc	 eax
  0003f	40		 inc	 eax
  00040	66 85 d2	 test	 dx, dx
  00043	75 f2		 jne	 SHORT $LL3@TCGetDosNa

; 1892 : 	wcscat (dosname, tmp);

  00045	8d 45 f4	 lea	 eax, DWORD PTR _tmp$[ebp]
  00048	8b f0		 mov	 esi, eax
$LL5@TCGetDosNa:
  0004a	66 8b 10	 mov	 dx, WORD PTR [eax]
  0004d	40		 inc	 eax
  0004e	40		 inc	 eax
  0004f	66 85 d2	 test	 dx, dx
  00052	75 f6		 jne	 SHORT $LL5@TCGetDosNa
  00054	2b c6		 sub	 eax, esi
  00056	49		 dec	 ecx
  00057	49		 dec	 ecx
$LL6@TCGetDosNa:
  00058	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  0005c	41		 inc	 ecx
  0005d	41		 inc	 ecx
  0005e	66 85 d2	 test	 dx, dx
  00061	75 f5		 jne	 SHORT $LL6@TCGetDosNa
  00063	8b f9		 mov	 edi, ecx
  00065	8b c8		 mov	 ecx, eax
  00067	c1 e9 02	 shr	 ecx, 2
  0006a	f3 a5		 rep movsd
  0006c	8b c8		 mov	 ecx, eax
  0006e	83 e1 03	 and	 ecx, 3
  00071	f3 a4		 rep movsb

; 1893 : }

  00073	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00076	5f		 pop	 edi
  00077	33 cd		 xor	 ecx, ebp
  00079	5e		 pop	 esi
  0007a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007f	c9		 leave
  00080	c2 08 00	 ret	 8
_TCGetDosNameFromNumber@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EA@FPAPEGHJ@?$AAP?$AAs?$AAD?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAI?$AAm?$AAp?$AAe?$AAr?$AAs?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAk?$AAe?$AAn?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_TCDeleteDeviceObject@8
EXTRN	__imp__SeTokenType@4:PROC
EXTRN	__imp__KeBugCheckEx@20:PROC
EXTRN	__imp__MmGetSystemRoutineAddress@4:PROC
EXTRN	__imp__IoDeleteSymbolicLink@4:PROC
;	COMDAT ??_C@_1EA@FPAPEGHJ@?$AAP?$AAs?$AAD?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAI?$AAm?$AAp?$AAe?$AAr?$AAs?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAk?$AAe?$AAn?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1EA@FPAPEGHJ@?$AAP?$AAs?$AAD?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAI?$AAm?$AAp?$AAe?$AAr?$AAs?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAk?$AAe?$AAn?$AA?$AA@FNODOBFM@ DB 'P'
	DB	00H, 's', 00H, 'D', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H
	DB	'e', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, 'I'
	DB	00H, 'm', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 's', 00H, 'o', 00H
	DB	'n', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'T'
	DB	00H, 'o', 00H, 'k', 00H, 'e', 00H, 'n', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'T', 00H, 'r'
	DB	00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r', 00H, 'y', 00H, 'p', 00H
	DB	't', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
text$s	ENDS
;	COMDAT _TCDeleteDeviceObject@8
_TEXT	SEGMENT
_name$30637 = -16					; size = 8
_Win32NameString$ = -8					; size = 8
_DeviceObject$ = 8					; size = 4
_Extension$ = 12					; size = 4
_TCDeleteDeviceObject@8 PROC				; COMDAT

; 2061 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 10	 sub	 esp, 16			; 00000010H
  00008	56		 push	 esi

; 2062 : 	UNICODE_STRING Win32NameString;
; 2063 : 	NTSTATUS ntStatus;
; 2064 : 
; 2065 : 	Dump ("TCDeleteDeviceObject BEGIN\n");
; 2066 : 
; 2067 : 	if (Extension->bRootDevice)

  00009	8b 75 0c	 mov	 esi, DWORD PTR _Extension$[ebp]
  0000c	57		 push	 edi
  0000d	33 ff		 xor	 edi, edi
  0000f	39 3e		 cmp	 DWORD PTR [esi], edi
  00011	74 24		 je	 SHORT $LN11@TCDeleteDe

; 2068 : 	{
; 2069 : 		RtlInitUnicodeString (&Win32NameString, (LPWSTR) DOS_ROOT_PREFIX);

  00013	68 00 00 00 00	 push	 OFFSET ??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
  00018	8d 45 f8	 lea	 eax, DWORD PTR _Win32NameString$[ebp]
  0001b	50		 push	 eax
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 2070 : 		ntStatus = IoDeleteSymbolicLink (&Win32NameString);

  00022	8d 45 f8	 lea	 eax, DWORD PTR _Win32NameString$[ebp]
  00025	50		 push	 eax
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteSymbolicLink@4

; 2071 : 		if (!NT_SUCCESS (ntStatus))
; 2072 : 			Dump ("IoDeleteSymbolicLink failed ntStatus = 0x%08x\n", ntStatus);
; 2073 : 
; 2074 : 		RootDeviceObject = NULL;

  0002c	89 3d 00 00 00
	00		 mov	 DWORD PTR _RootDeviceObject, edi

; 2075 : 	}
; 2076 : 	else

  00032	e9 a7 00 00 00	 jmp	 $LN9@TCDeleteDe
$LN11@TCDeleteDe:

; 2077 : 	{
; 2078 : 		if (Extension->peThread != NULL)

  00037	39 7e 20	 cmp	 DWORD PTR [esi+32], edi
  0003a	74 09		 je	 SHORT $LN14@TCDeleteDe

; 2079 : 			TCStopVolumeThread (DeviceObject, Extension);

  0003c	56		 push	 esi
  0003d	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  00040	e8 00 00 00 00	 call	 _TCStopVolumeThread@8
$LN14@TCDeleteDe:

; 2080 : 
; 2081 : 		if (Extension->UserSid)

  00045	8b 86 8c 04 00
	00		 mov	 eax, DWORD PTR [esi+1164]
  0004b	3b c7		 cmp	 eax, edi
  0004d	74 0c		 je	 SHORT $LN7@TCDeleteDe

; 2082 : 			TCfree (Extension->UserSid);

  0004f	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00054	50		 push	 eax
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN7@TCDeleteDe:

; 2083 : 
; 2084 : 		if (Extension->SecurityClientContextValid)

  0005b	39 be 90 04 00
	00		 cmp	 DWORD PTR [esi+1168], edi
  00061	74 71		 je	 SHORT $LN1@TCDeleteDe

; 2085 : 		{
; 2086 : 			if (OsMajorVersion == 5 && OsMinorVersion == 0)

  00063	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR _OsMajorVersion, 5
  0006a	75 16		 jne	 SHORT $LN5@TCDeleteDe
  0006c	39 3d 00 00 00
	00		 cmp	 DWORD PTR _OsMinorVersion, edi
  00072	75 0e		 jne	 SHORT $LN5@TCDeleteDe

; 2087 : 			{
; 2088 : 				ObDereferenceObject (Extension->SecurityClientContext.ClientToken);

  00074	8b 8e a0 04 00
	00		 mov	 ecx, DWORD PTR [esi+1184]
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 2089 : 			}
; 2090 : 			else

  00080	eb 52		 jmp	 SHORT $LN1@TCDeleteDe
$LN5@TCDeleteDe:
  00082	53		 push	 ebx

; 2091 : 			{
; 2092 : 				// Windows 2000 does not support PsDereferenceImpersonationToken() used by SeDeleteClientSecurity().
; 2093 : 				// TODO: Use only SeDeleteClientSecurity() once support for Windows 2000 is dropped.
; 2094 : 
; 2095 : 				VOID (*PsDereferenceImpersonationTokenD) (PACCESS_TOKEN ImpersonationToken);
; 2096 : 				UNICODE_STRING name;
; 2097 : 				RtlInitUnicodeString (&name, L"PsDereferenceImpersonationToken");

  00083	68 00 00 00 00	 push	 OFFSET ??_C@_1EA@FPAPEGHJ@?$AAP?$AAs?$AAD?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAI?$AAm?$AAp?$AAe?$AAr?$AAs?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAk?$AAe?$AAn?$AA?$AA@FNODOBFM@
  00088	8d 45 f0	 lea	 eax, DWORD PTR _name$30637[ebp]
  0008b	50		 push	 eax
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 2098 : 
; 2099 : 				PsDereferenceImpersonationTokenD = MmGetSystemRoutineAddress (&name);

  00092	8d 45 f0	 lea	 eax, DWORD PTR _name$30637[ebp]
  00095	50		 push	 eax
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmGetSystemRoutineAddress@4
  0009c	8b d8		 mov	 ebx, eax

; 2100 : 				if (!PsDereferenceImpersonationTokenD)

  0009e	3b df		 cmp	 ebx, edi
  000a0	75 18		 jne	 SHORT $LN3@TCDeleteDe

; 2101 : 					TC_BUG_CHECK (STATUS_NOT_IMPLEMENTED);

  000a2	68 43 54 00 00	 push	 21571			; 00005443H
  000a7	57		 push	 edi
  000a8	68 02 00 00 c0	 push	 -1073741822		; c0000002H
  000ad	68 35 08 00 00	 push	 2101			; 00000835H
  000b2	6a 29		 push	 41			; 00000029H
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN18@TCDeleteDe:
$LN3@TCDeleteDe:

; 2102 : 				
; 2103 : #				define PsDereferencePrimaryToken
; 2104 : #				define PsDereferenceImpersonationToken PsDereferenceImpersonationTokenD
; 2105 : 
; 2106 : 				SeDeleteClientSecurity (&Extension->SecurityClientContext);

  000ba	8d be a0 04 00
	00		 lea	 edi, DWORD PTR [esi+1184]
  000c0	ff 37		 push	 DWORD PTR [edi]
  000c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeTokenType@4
  000c8	83 f8 01	 cmp	 eax, 1
  000cb	74 04		 je	 SHORT $LN15@TCDeleteDe
  000cd	ff 37		 push	 DWORD PTR [edi]
  000cf	ff d3		 call	 ebx
$LN15@TCDeleteDe:
  000d1	33 ff		 xor	 edi, edi
  000d3	5b		 pop	 ebx
$LN1@TCDeleteDe:

; 2107 : 
; 2108 : #				undef PsDereferencePrimaryToken
; 2109 : #				undef PsDereferenceImpersonationToken
; 2110 : 			}
; 2111 : 		}
; 2112 : 
; 2113 : 		VirtualVolumeDeviceObjects[Extension->nDosDriveNo] = NULL;

  000d4	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000d7	89 3c 85 00 00
	00 00		 mov	 DWORD PTR _VirtualVolumeDeviceObjects[eax*4], edi
$LN9@TCDeleteDe:

; 2114 : 	}
; 2115 : 
; 2116 : 	IoDeleteDevice (DeviceObject);

  000de	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  000e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteDevice@4
  000e7	5f		 pop	 edi
  000e8	5e		 pop	 esi

; 2117 : 
; 2118 : 	Dump ("TCDeleteDeviceObject END\n");
; 2119 : }

  000e9	c9		 leave
  000ea	c2 08 00	 ret	 8
$LN17@TCDeleteDe:
_TCDeleteDeviceObject@8 ENDP
_TEXT	ENDS
PUBLIC	_TCDeviceIoControl@24
EXTRN	__imp_@IofCallDriver@8:PROC
EXTRN	__imp__IoBuildDeviceIoControlRequest@36:PROC
EXTRN	__imp__KeInitializeEvent@12:PROC
EXTRN	__imp__IoGetDeviceObjectPointer@16:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCDeviceIoControl@24
_TEXT	SEGMENT
_event$ = -36						; size = 16
_ioStatusBlock$ = -20					; size = 8
_name$ = -12						; size = 8
_fileObject$ = -4					; size = 4
_deviceObject$ = 8					; size = 4
_deviceName$ = 8					; size = 4
_IoControlCode$ = 12					; size = 4
_InputBuffer$ = 16					; size = 4
_InputBufferSize$ = 20					; size = 4
_OutputBuffer$ = 24					; size = 4
_OutputBufferSize$ = 28					; size = 4
_TCDeviceIoControl@24 PROC				; COMDAT

; 2152 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 24	 sub	 esp, 36			; 00000024H
  00008	57		 push	 edi

; 2153 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2154 : 	NTSTATUS ntStatus;
; 2155 : 	PIRP irp;
; 2156 : 	PFILE_OBJECT fileObject;
; 2157 : 	PDEVICE_OBJECT deviceObject;
; 2158 : 	KEVENT event;
; 2159 : 	UNICODE_STRING name;
; 2160 : 
; 2161 : 	RtlInitUnicodeString(&name, deviceName);

  00009	ff 75 08	 push	 DWORD PTR _deviceName$[ebp]
  0000c	8d 45 f4	 lea	 eax, DWORD PTR _name$[ebp]
  0000f	50		 push	 eax
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 2162 : 	ntStatus = IoGetDeviceObjectPointer (&name, FILE_READ_ATTRIBUTES, &fileObject, &deviceObject);

  00016	8d 45 08	 lea	 eax, DWORD PTR _deviceObject$[ebp]
  00019	50		 push	 eax
  0001a	8d 45 fc	 lea	 eax, DWORD PTR _fileObject$[ebp]
  0001d	50		 push	 eax
  0001e	68 80 00 00 00	 push	 128			; 00000080H
  00023	8d 45 f4	 lea	 eax, DWORD PTR _name$[ebp]
  00026	50		 push	 eax
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoGetDeviceObjectPointer@16

; 2163 : 
; 2164 : 	if (!NT_SUCCESS (ntStatus))

  0002d	33 ff		 xor	 edi, edi
  0002f	3b c7		 cmp	 eax, edi

; 2165 : 		return ntStatus;

  00031	7c 74		 jl	 SHORT $LN4@TCDeviceIo
  00033	56		 push	 esi

; 2166 : 
; 2167 : 	KeInitializeEvent(&event, NotificationEvent, FALSE);

  00034	57		 push	 edi
  00035	57		 push	 edi
  00036	8d 45 dc	 lea	 eax, DWORD PTR _event$[ebp]
  00039	50		 push	 eax
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 2168 : 
; 2169 : 	irp = IoBuildDeviceIoControlRequest (IoControlCode,
; 2170 : 					     deviceObject,
; 2171 : 					     InputBuffer, InputBufferSize,
; 2172 : 					     OutputBuffer, OutputBufferSize,
; 2173 : 					     FALSE,
; 2174 : 					     &event,
; 2175 : 					     &ioStatusBlock);

  00040	8d 45 ec	 lea	 eax, DWORD PTR _ioStatusBlock$[ebp]
  00043	50		 push	 eax
  00044	8d 45 dc	 lea	 eax, DWORD PTR _event$[ebp]
  00047	50		 push	 eax
  00048	57		 push	 edi
  00049	ff 75 1c	 push	 DWORD PTR _OutputBufferSize$[ebp]
  0004c	ff 75 18	 push	 DWORD PTR _OutputBuffer$[ebp]
  0004f	ff 75 14	 push	 DWORD PTR _InputBufferSize$[ebp]
  00052	ff 75 10	 push	 DWORD PTR _InputBuffer$[ebp]
  00055	ff 75 08	 push	 DWORD PTR _deviceObject$[ebp]
  00058	ff 75 0c	 push	 DWORD PTR _IoControlCode$[ebp]
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 2176 : 
; 2177 : 	if (irp == NULL)

  00061	3b c7		 cmp	 eax, edi
  00063	75 07		 jne	 SHORT $LN2@TCDeviceIo

; 2178 : 	{
; 2179 : 		Dump ("IRP allocation failed\n");
; 2180 : 		ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00065	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH

; 2181 : 		goto ret;

  0006a	eb 2f		 jmp	 SHORT $ret$30692
$LN2@TCDeviceIo:

; 2182 : 	}
; 2183 : 
; 2184 : 	IoGetNextIrpStackLocation (irp)->FileObject = fileObject;

  0006c	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0006f	8b 55 fc	 mov	 edx, DWORD PTR _fileObject$[ebp]
  00072	89 51 f4	 mov	 DWORD PTR [ecx-12], edx

; 2185 : 
; 2186 : 	ntStatus = IoCallDriver (deviceObject, irp);

  00075	8b 4d 08	 mov	 ecx, DWORD PTR _deviceObject$[ebp]
  00078	8b d0		 mov	 edx, eax
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8
  00080	8b f0		 mov	 esi, eax

; 2187 : 	if (ntStatus == STATUS_PENDING)

  00082	81 fe 03 01 00
	00		 cmp	 esi, 259		; 00000103H
  00088	75 11		 jne	 SHORT $ret$30692

; 2188 : 	{
; 2189 : 		KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);

  0008a	57		 push	 edi
  0008b	57		 push	 edi
  0008c	57		 push	 edi
  0008d	57		 push	 edi
  0008e	8d 45 dc	 lea	 eax, DWORD PTR _event$[ebp]
  00091	50		 push	 eax
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 2190 : 		ntStatus = ioStatusBlock.Status;

  00098	8b 75 ec	 mov	 esi, DWORD PTR _ioStatusBlock$[ebp]
$ret$30692:

; 2191 : 	}
; 2192 : 
; 2193 : ret:
; 2194 : 	ObDereferenceObject (fileObject);

  0009b	8b 4d fc	 mov	 ecx, DWORD PTR _fileObject$[ebp]
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 2195 : 	return ntStatus;

  000a4	8b c6		 mov	 eax, esi
  000a6	5e		 pop	 esi
$LN4@TCDeviceIo:
  000a7	5f		 pop	 edi

; 2196 : }

  000a8	c9		 leave
  000a9	c2 18 00	 ret	 24			; 00000018H
_TCDeviceIoControl@24 ENDP
_TEXT	ENDS
PUBLIC	_SendDeviceIoControlRequest@24
; Function compile flags: /Ogsp
;	COMDAT _SendDeviceIoControlRequestWorkItemRoutine@8
_TEXT	SEGMENT
_rootDeviceObject$ = 8					; size = 4
_arg$ = 12						; size = 4
_SendDeviceIoControlRequestWorkItemRoutine@8 PROC	; COMDAT

; 2208 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 2209 : 	arg->Status = SendDeviceIoControlRequest (arg->deviceObject, arg->ioControlCode, arg->inputBuffer, arg->inputBufferSize, arg->outputBuffer, arg->outputBufferSize);

  00006	8b 75 0c	 mov	 esi, DWORD PTR _arg$[ebp]
  00009	ff 76 14	 push	 DWORD PTR [esi+20]
  0000c	ff 76 10	 push	 DWORD PTR [esi+16]
  0000f	ff 76 0c	 push	 DWORD PTR [esi+12]
  00012	ff 76 08	 push	 DWORD PTR [esi+8]
  00015	ff 76 04	 push	 DWORD PTR [esi+4]
  00018	ff 36		 push	 DWORD PTR [esi]
  0001a	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24

; 2210 : 	KeSetEvent (&arg->WorkItemCompletedEvent, IO_NO_INCREMENT, FALSE);

  0001f	6a 00		 push	 0
  00021	89 46 18	 mov	 DWORD PTR [esi+24], eax
  00024	6a 00		 push	 0
  00026	83 c6 1c	 add	 esi, 28			; 0000001cH
  00029	56		 push	 esi
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
  00030	5e		 pop	 esi

; 2211 : }

  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
_SendDeviceIoControlRequestWorkItemRoutine@8 ENDP
_TEXT	ENDS
EXTRN	__imp_@ObfReferenceObject@4:PROC
EXTRN	__imp__IoFreeWorkItem@4:PROC
EXTRN	__imp__IoQueueWorkItem@16:PROC
EXTRN	__imp__IoAllocateWorkItem@4:PROC
EXTRN	__imp__KeGetCurrentIrql@0:PROC
; Function compile flags: /Ogsp
;	COMDAT _SendDeviceIoControlRequest@24
_TEXT	SEGMENT
_args$30730 = -68					; size = 44
_event$ = -24						; size = 16
_ioStatusBlock$ = -8					; size = 8
_deviceObject$ = 8					; size = 4
_ioControlCode$ = 12					; size = 4
_inputBuffer$ = 16					; size = 4
_inputBufferSize$ = 20					; size = 4
_outputBuffer$ = 24					; size = 4
_outputBufferSize$ = 28					; size = 4
_SendDeviceIoControlRequest@24 PROC			; COMDAT

; 2215 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 44	 sub	 esp, 68			; 00000044H
  00008	56		 push	 esi
  00009	57		 push	 edi

; 2216 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2217 : 	NTSTATUS status;
; 2218 : 	PIRP irp;
; 2219 : 	KEVENT event;
; 2220 : 
; 2221 : 	if (KeGetCurrentIrql() > APC_LEVEL)

  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeGetCurrentIrql@0
  00010	3c 01		 cmp	 al, 1
  00012	76 7b		 jbe	 SHORT $LN4@SendDevice

; 2222 : 	{
; 2223 : 		SendDeviceIoControlRequestWorkItemArgs args;
; 2224 : 
; 2225 : 		PIO_WORKITEM workItem = IoAllocateWorkItem (RootDeviceObject);

  00014	ff 35 00 00 00
	00		 push	 DWORD PTR _RootDeviceObject
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAllocateWorkItem@4
  00020	8b f8		 mov	 edi, eax

; 2226 : 		if (!workItem)

  00022	33 f6		 xor	 esi, esi
  00024	3b fe		 cmp	 edi, esi
  00026	75 0a		 jne	 SHORT $LN3@SendDevice

; 2227 : 			return STATUS_INSUFFICIENT_RESOURCES;

  00028	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  0002d	e9 d3 00 00 00	 jmp	 $LN5@SendDevice
$LN3@SendDevice:

; 2228 : 
; 2229 : 		args.deviceObject = deviceObject;

  00032	8b 45 08	 mov	 eax, DWORD PTR _deviceObject$[ebp]
  00035	89 45 bc	 mov	 DWORD PTR _args$30730[ebp], eax

; 2230 : 		args.ioControlCode = ioControlCode;

  00038	8b 45 0c	 mov	 eax, DWORD PTR _ioControlCode$[ebp]
  0003b	89 45 c0	 mov	 DWORD PTR _args$30730[ebp+4], eax

; 2231 : 		args.inputBuffer = inputBuffer;

  0003e	8b 45 10	 mov	 eax, DWORD PTR _inputBuffer$[ebp]
  00041	89 45 c4	 mov	 DWORD PTR _args$30730[ebp+8], eax

; 2232 : 		args.inputBufferSize = inputBufferSize;

  00044	8b 45 14	 mov	 eax, DWORD PTR _inputBufferSize$[ebp]
  00047	89 45 c8	 mov	 DWORD PTR _args$30730[ebp+12], eax

; 2233 : 		args.outputBuffer = outputBuffer;

  0004a	8b 45 18	 mov	 eax, DWORD PTR _outputBuffer$[ebp]
  0004d	89 45 cc	 mov	 DWORD PTR _args$30730[ebp+16], eax

; 2234 : 		args.outputBufferSize = outputBufferSize;

  00050	8b 45 1c	 mov	 eax, DWORD PTR _outputBufferSize$[ebp]

; 2235 : 
; 2236 : 		KeInitializeEvent (&args.WorkItemCompletedEvent, SynchronizationEvent, FALSE);

  00053	56		 push	 esi
  00054	89 45 d0	 mov	 DWORD PTR _args$30730[ebp+20], eax
  00057	6a 01		 push	 1
  00059	8d 45 d8	 lea	 eax, DWORD PTR _args$30730[ebp+28]
  0005c	50		 push	 eax
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 2237 : 		IoQueueWorkItem (workItem, SendDeviceIoControlRequestWorkItemRoutine, DelayedWorkQueue, &args); 

  00063	8d 45 bc	 lea	 eax, DWORD PTR _args$30730[ebp]
  00066	50		 push	 eax
  00067	6a 01		 push	 1
  00069	68 00 00 00 00	 push	 OFFSET _SendDeviceIoControlRequestWorkItemRoutine@8
  0006e	57		 push	 edi
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoQueueWorkItem@16

; 2238 : 
; 2239 : 		KeWaitForSingleObject (&args.WorkItemCompletedEvent, Executive, KernelMode, FALSE, NULL);

  00075	56		 push	 esi
  00076	56		 push	 esi
  00077	56		 push	 esi
  00078	56		 push	 esi
  00079	8d 45 d8	 lea	 eax, DWORD PTR _args$30730[ebp+28]
  0007c	50		 push	 eax
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 2240 : 		IoFreeWorkItem (workItem);

  00083	57		 push	 edi
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoFreeWorkItem@4

; 2241 :  
; 2242 : 		return args.Status;

  0008a	8b 45 d4	 mov	 eax, DWORD PTR _args$30730[ebp+24]
  0008d	eb 76		 jmp	 SHORT $LN5@SendDevice
$LN4@SendDevice:
  0008f	53		 push	 ebx

; 2243 : 	}
; 2244 : 
; 2245 : 	KeInitializeEvent (&event, NotificationEvent, FALSE);

  00090	33 f6		 xor	 esi, esi
  00092	56		 push	 esi
  00093	56		 push	 esi
  00094	8d 45 e8	 lea	 eax, DWORD PTR _event$[ebp]
  00097	50		 push	 eax
  00098	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 2246 : 
; 2247 : 	irp = IoBuildDeviceIoControlRequest (ioControlCode, deviceObject, inputBuffer, inputBufferSize,
; 2248 : 		outputBuffer, outputBufferSize, FALSE, &event, &ioStatusBlock);

  0009e	8b 5d 08	 mov	 ebx, DWORD PTR _deviceObject$[ebp]
  000a1	8d 45 f8	 lea	 eax, DWORD PTR _ioStatusBlock$[ebp]
  000a4	50		 push	 eax
  000a5	8d 45 e8	 lea	 eax, DWORD PTR _event$[ebp]
  000a8	50		 push	 eax
  000a9	56		 push	 esi
  000aa	ff 75 1c	 push	 DWORD PTR _outputBufferSize$[ebp]
  000ad	ff 75 18	 push	 DWORD PTR _outputBuffer$[ebp]
  000b0	ff 75 14	 push	 DWORD PTR _inputBufferSize$[ebp]
  000b3	ff 75 10	 push	 DWORD PTR _inputBuffer$[ebp]
  000b6	53		 push	 ebx
  000b7	ff 75 0c	 push	 DWORD PTR _ioControlCode$[ebp]
  000ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36
  000c0	8b f8		 mov	 edi, eax

; 2249 : 
; 2250 : 	if (!irp)

  000c2	3b fe		 cmp	 edi, esi
  000c4	75 07		 jne	 SHORT $LN2@SendDevice

; 2251 : 		return STATUS_INSUFFICIENT_RESOURCES;

  000c6	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  000cb	eb 37		 jmp	 SHORT $LN7@SendDevice
$LN2@SendDevice:

; 2252 : 
; 2253 : 	ObReferenceObject (deviceObject);

  000cd	8b cb		 mov	 ecx, ebx
  000cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfReferenceObject@4

; 2254 : 
; 2255 : 	status = IoCallDriver (deviceObject, irp);

  000d5	8b d7		 mov	 edx, edi
  000d7	8b cb		 mov	 ecx, ebx
  000d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8
  000df	8b f8		 mov	 edi, eax

; 2256 : 	if (status == STATUS_PENDING)

  000e1	81 ff 03 01 00
	00		 cmp	 edi, 259		; 00000103H
  000e7	75 11		 jne	 SHORT $LN1@SendDevice

; 2257 : 	{
; 2258 : 		KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);

  000e9	56		 push	 esi
  000ea	56		 push	 esi
  000eb	56		 push	 esi
  000ec	56		 push	 esi
  000ed	8d 45 e8	 lea	 eax, DWORD PTR _event$[ebp]
  000f0	50		 push	 eax
  000f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 2259 : 		status = ioStatusBlock.Status;

  000f7	8b 7d f8	 mov	 edi, DWORD PTR _ioStatusBlock$[ebp]
$LN1@SendDevice:

; 2260 : 	}
; 2261 : 
; 2262 : 	ObDereferenceObject (deviceObject);

  000fa	8b cb		 mov	 ecx, ebx
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 2263 : 	return status;

  00102	8b c7		 mov	 eax, edi
$LN7@SendDevice:
  00104	5b		 pop	 ebx
$LN5@SendDevice:
  00105	5f		 pop	 edi
  00106	5e		 pop	 esi

; 2264 : }

  00107	c9		 leave
  00108	c2 18 00	 ret	 24			; 00000018H
_SendDeviceIoControlRequest@24 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_TCOpenFsVolume@12
EXTRN	__imp__ZwCreateFile@44:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCOpenFsVolume@12
_TEXT	SEGMENT
_ioStatus$ = -564					; size = 8
_fullFileName$ = -556					; size = 8
_objectAttributes$ = -548				; size = 24
_volumeName$ = -524					; size = 520
__$ArrayPad$ = -4					; size = 4
_Extension$ = 8						; size = 4
_volumeHandle$ = 12					; size = 4
_fileObject$ = 16					; size = 4
_TCOpenFsVolume@12 PROC					; COMDAT

; 2320 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 34 02 00
	00		 sub	 esp, 564		; 00000234H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2321 : 	NTSTATUS ntStatus;
; 2322 : 	OBJECT_ATTRIBUTES objectAttributes;
; 2323 : 	UNICODE_STRING fullFileName;
; 2324 : 	IO_STATUS_BLOCK ioStatus;
; 2325 : 	WCHAR volumeName[TC_MAX_PATH];
; 2326 : 
; 2327 : 	TCGetNTNameFromNumber (volumeName, Extension->nDosDriveNo);

  00015	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  00018	53		 push	 ebx
  00019	8b 5d 10	 mov	 ebx, DWORD PTR _fileObject$[ebp]
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	ff 70 14	 push	 DWORD PTR [eax+20]
  00021	8b 7d 0c	 mov	 edi, DWORD PTR _volumeHandle$[ebp]
  00024	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _volumeName$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 _TCGetNTNameFromNumber@8

; 2328 : 	RtlInitUnicodeString (&fullFileName, volumeName);

  00030	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _volumeName$[ebp]
  00036	50		 push	 eax
  00037	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _fullFileName$[ebp]
  0003d	50		 push	 eax
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 2329 : 	InitializeObjectAttributes (&objectAttributes, &fullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

  00044	33 f6		 xor	 esi, esi

; 2330 : 
; 2331 : 	ntStatus = ZwCreateFile (volumeHandle,
; 2332 : 		SYNCHRONIZE | GENERIC_READ,
; 2333 : 		&objectAttributes,
; 2334 : 		&ioStatus,
; 2335 : 		NULL,
; 2336 : 		FILE_ATTRIBUTE_NORMAL,
; 2337 : 		FILE_SHARE_READ | FILE_SHARE_WRITE,
; 2338 : 		FILE_OPEN,
; 2339 : 		FILE_SYNCHRONOUS_IO_NONALERT,
; 2340 : 		NULL,
; 2341 : 		0);

  00046	56		 push	 esi
  00047	56		 push	 esi
  00048	6a 20		 push	 32			; 00000020H
  0004a	6a 01		 push	 1
  0004c	6a 03		 push	 3
  0004e	68 80 00 00 00	 push	 128			; 00000080H
  00053	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _fullFileName$[ebp]
  00059	56		 push	 esi
  0005a	89 85 e4 fd ff
	ff		 mov	 DWORD PTR _objectAttributes$[ebp+8], eax
  00060	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _ioStatus$[ebp]
  00066	50		 push	 eax
  00067	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _objectAttributes$[ebp]
  0006d	50		 push	 eax
  0006e	68 00 00 10 80	 push	 -2146435072		; 80100000H
  00073	57		 push	 edi
  00074	c7 85 dc fd ff
	ff 18 00 00 00	 mov	 DWORD PTR _objectAttributes$[ebp], 24 ; 00000018H
  0007e	89 b5 e0 fd ff
	ff		 mov	 DWORD PTR _objectAttributes$[ebp+4], esi
  00084	c7 85 e8 fd ff
	ff 40 02 00 00	 mov	 DWORD PTR _objectAttributes$[ebp+12], 576 ; 00000240H
  0008e	89 b5 ec fd ff
	ff		 mov	 DWORD PTR _objectAttributes$[ebp+16], esi
  00094	89 b5 f0 fd ff
	ff		 mov	 DWORD PTR _objectAttributes$[ebp+20], esi
  0009a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwCreateFile@44

; 2342 : 
; 2343 : 	Dump ("Volume %ls open NTSTATUS 0x%08x\n", volumeName, ntStatus);
; 2344 : 
; 2345 : 	if (!NT_SUCCESS (ntStatus))

  000a0	3b c6		 cmp	 eax, esi

; 2346 : 		return ntStatus;

  000a2	7c 1e		 jl	 SHORT $LN3@TCOpenFsVo

; 2347 : 
; 2348 : 	ntStatus = ObReferenceObjectByHandle (*volumeHandle,
; 2349 : 		FILE_READ_DATA,
; 2350 : 		NULL,
; 2351 : 		KernelMode,
; 2352 : 		fileObject,
; 2353 : 		NULL);

  000a4	56		 push	 esi
  000a5	53		 push	 ebx
  000a6	56		 push	 esi
  000a7	56		 push	 esi
  000a8	6a 01		 push	 1
  000aa	ff 37		 push	 DWORD PTR [edi]
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ObReferenceObjectByHandle@24
  000b2	8b d8		 mov	 ebx, eax

; 2354 : 
; 2355 : 	if (!NT_SUCCESS (ntStatus))

  000b4	3b de		 cmp	 ebx, esi
  000b6	7d 08		 jge	 SHORT $LN1@TCOpenFsVo

; 2356 : 		ZwClose (*volumeHandle);

  000b8	ff 37		 push	 DWORD PTR [edi]
  000ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4
$LN1@TCOpenFsVo:

; 2357 : 
; 2358 : 	return ntStatus;

  000c0	8b c3		 mov	 eax, ebx
$LN3@TCOpenFsVo:

; 2359 : }

  000c2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c5	5f		 pop	 edi
  000c6	5e		 pop	 esi
  000c7	33 cd		 xor	 ecx, ebp
  000c9	5b		 pop	 ebx
  000ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cf	c9		 leave
  000d0	c2 0c 00	 ret	 12			; 0000000cH
_TCOpenFsVolume@12 ENDP
_TEXT	ENDS
PUBLIC	_TCCloseFsVolume@8
; Function compile flags: /Ogsp
;	COMDAT _TCCloseFsVolume@8
_TEXT	SEGMENT
_volumeHandle$ = 8					; size = 4
_fileObject$ = 12					; size = 4
_TCCloseFsVolume@8 PROC					; COMDAT

; 2363 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 2364 : 	ObDereferenceObject (fileObject);

  00005	8b 4d 0c	 mov	 ecx, DWORD PTR _fileObject$[ebp]
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 2365 : 	ZwClose (volumeHandle);

  0000e	ff 75 08	 push	 DWORD PTR _volumeHandle$[ebp]
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 2366 : }

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
_TCCloseFsVolume@8 ENDP
_TEXT	ENDS
EXTRN	__imp__IoBuildSynchronousFsdRequest@28:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCReadWriteDevice@24
_TEXT	SEGMENT
_completionEvent$ = -24					; size = 16
_ioStatusBlock$ = -8					; size = 8
_write$ = 8						; size = 4
_buffer$ = 12						; size = 4
_offset$ = 16						; size = 8
_length$ = 24						; size = 4
_TCReadWriteDevice@24 PROC				; COMDAT
; _deviceObject$ = ebx

; 2370 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 18	 sub	 esp, 24			; 00000018H
  00008	56		 push	 esi
  00009	57		 push	 edi

; 2371 : 	NTSTATUS status;
; 2372 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2373 : 	PIRP irp;
; 2374 : 	KEVENT completionEvent;
; 2375 : 
; 2376 : 	ASSERT (KeGetCurrentIrql() <= APC_LEVEL);
; 2377 : 
; 2378 : 	KeInitializeEvent (&completionEvent, NotificationEvent, FALSE);

  0000a	33 f6		 xor	 esi, esi
  0000c	56		 push	 esi
  0000d	56		 push	 esi
  0000e	8d 45 e8	 lea	 eax, DWORD PTR _completionEvent$[ebp]
  00011	50		 push	 eax
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 2379 : 	irp = IoBuildSynchronousFsdRequest (write ? IRP_MJ_WRITE : IRP_MJ_READ, deviceObject, buffer, length, &offset, &completionEvent, &ioStatusBlock);

  00018	8d 45 f8	 lea	 eax, DWORD PTR _ioStatusBlock$[ebp]
  0001b	50		 push	 eax
  0001c	8d 45 e8	 lea	 eax, DWORD PTR _completionEvent$[ebp]
  0001f	50		 push	 eax
  00020	8d 45 10	 lea	 eax, DWORD PTR _offset$[ebp]
  00023	50		 push	 eax
  00024	ff 75 18	 push	 DWORD PTR _length$[ebp]
  00027	33 c0		 xor	 eax, eax
  00029	39 75 08	 cmp	 DWORD PTR _write$[ebp], esi
  0002c	ff 75 0c	 push	 DWORD PTR _buffer$[ebp]
  0002f	0f 95 c0	 setne	 al
  00032	53		 push	 ebx
  00033	83 c0 03	 add	 eax, 3
  00036	50		 push	 eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildSynchronousFsdRequest@28
  0003d	8b f8		 mov	 edi, eax

; 2380 : 	if (!irp)

  0003f	3b fe		 cmp	 edi, esi
  00041	75 07		 jne	 SHORT $LN3@TCReadWrit

; 2381 : 		return STATUS_INSUFFICIENT_RESOURCES;

  00043	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  00048	eb 3d		 jmp	 SHORT $LN4@TCReadWrit
$LN3@TCReadWrit:

; 2382 : 
; 2383 : 	ObReferenceObject (deviceObject);

  0004a	8b cb		 mov	 ecx, ebx
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfReferenceObject@4

; 2384 : 	status = IoCallDriver (deviceObject, irp);

  00052	8b d7		 mov	 edx, edi
  00054	8b cb		 mov	 ecx, ebx
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8
  0005c	8b f8		 mov	 edi, eax

; 2385 : 
; 2386 : 	if (status == STATUS_PENDING)

  0005e	81 ff 03 01 00
	00		 cmp	 edi, 259		; 00000103H
  00064	75 17		 jne	 SHORT $LN1@TCReadWrit

; 2387 : 	{
; 2388 : 		status = KeWaitForSingleObject (&completionEvent, Executive, KernelMode, FALSE, NULL);

  00066	56		 push	 esi
  00067	56		 push	 esi
  00068	56		 push	 esi
  00069	56		 push	 esi
  0006a	8d 45 e8	 lea	 eax, DWORD PTR _completionEvent$[ebp]
  0006d	50		 push	 eax
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
  00074	8b f8		 mov	 edi, eax

; 2389 : 		if (NT_SUCCESS (status))

  00076	3b fe		 cmp	 edi, esi
  00078	7c 03		 jl	 SHORT $LN1@TCReadWrit

; 2390 : 			status = ioStatusBlock.Status;

  0007a	8b 7d f8	 mov	 edi, DWORD PTR _ioStatusBlock$[ebp]
$LN1@TCReadWrit:

; 2391 : 	}
; 2392 : 
; 2393 : 	ObDereferenceObject (deviceObject);

  0007d	8b cb		 mov	 ecx, ebx
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 2394 : 	return status;

  00085	8b c7		 mov	 eax, edi
$LN4@TCReadWrit:
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi

; 2395 : }

  00089	c9		 leave
  0008a	c2 14 00	 ret	 20			; 00000014H
_TCReadWriteDevice@24 ENDP
_TEXT	ENDS
PUBLIC	_TCReadDevice@20
; Function compile flags: /Ogsp
;	COMDAT _TCReadDevice@20
_TEXT	SEGMENT
_deviceObject$ = 8					; size = 4
_buffer$ = 12						; size = 4
_offset$ = 16						; size = 8
_length$ = 24						; size = 4
_TCReadDevice@20 PROC					; COMDAT

; 2399 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	53		 push	 ebx

; 2400 : 	return TCReadWriteDevice (FALSE, deviceObject, buffer, offset, length);

  00006	ff 75 18	 push	 DWORD PTR _length$[ebp]
  00009	8b 5d 08	 mov	 ebx, DWORD PTR _deviceObject$[ebp]
  0000c	ff 75 14	 push	 DWORD PTR _offset$[ebp+4]
  0000f	ff 75 10	 push	 DWORD PTR _offset$[ebp]
  00012	ff 75 0c	 push	 DWORD PTR _buffer$[ebp]
  00015	6a 00		 push	 0
  00017	e8 00 00 00 00	 call	 _TCReadWriteDevice@24
  0001c	5b		 pop	 ebx

; 2401 : }

  0001d	5d		 pop	 ebp
  0001e	c2 14 00	 ret	 20			; 00000014H
_TCReadDevice@20 ENDP
_TEXT	ENDS
PUBLIC	_TCWriteDevice@20
; Function compile flags: /Ogsp
;	COMDAT _TCWriteDevice@20
_TEXT	SEGMENT
_deviceObject$ = 8					; size = 4
_buffer$ = 12						; size = 4
_offset$ = 16						; size = 8
_length$ = 24						; size = 4
_TCWriteDevice@20 PROC					; COMDAT

; 2405 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	53		 push	 ebx

; 2406 : 	return TCReadWriteDevice (TRUE, deviceObject, buffer, offset, length);

  00006	ff 75 18	 push	 DWORD PTR _length$[ebp]
  00009	8b 5d 08	 mov	 ebx, DWORD PTR _deviceObject$[ebp]
  0000c	ff 75 14	 push	 DWORD PTR _offset$[ebp+4]
  0000f	ff 75 10	 push	 DWORD PTR _offset$[ebp]
  00012	ff 75 0c	 push	 DWORD PTR _buffer$[ebp]
  00015	6a 01		 push	 1
  00017	e8 00 00 00 00	 call	 _TCReadWriteDevice@24
  0001c	5b		 pop	 ebx

; 2407 : }

  0001d	5d		 pop	 ebp
  0001e	c2 14 00	 ret	 20			; 00000014H
_TCWriteDevice@20 ENDP
_TEXT	ENDS
PUBLIC	_TCFsctlCall@24
EXTRN	__imp__IoGetRelatedDeviceObject@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCFsctlCall@24
_TEXT	SEGMENT
_event$ = -24						; size = 16
_ioStatusBlock$ = -8					; size = 8
_fileObject$ = 8					; size = 4
_IoControlCode$ = 12					; size = 4
_InputBuffer$ = 16					; size = 4
_InputBufferSize$ = 20					; size = 4
_OutputBuffer$ = 24					; size = 4
_OutputBufferSize$ = 28					; size = 4
_TCFsctlCall@24 PROC					; COMDAT

; 2412 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 18	 sub	 esp, 24			; 00000018H
  00008	53		 push	 ebx
  00009	56		 push	 esi

; 2413 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2414 : 	NTSTATUS ntStatus;
; 2415 : 	PIRP irp;
; 2416 : 	KEVENT event;
; 2417 : 	PIO_STACK_LOCATION stack;
; 2418 : 	PDEVICE_OBJECT deviceObject = IoGetRelatedDeviceObject (fileObject);

  0000a	8b 75 08	 mov	 esi, DWORD PTR _fileObject$[ebp]
  0000d	57		 push	 edi
  0000e	56		 push	 esi
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoGetRelatedDeviceObject@4

; 2419 : 
; 2420 : 	KeInitializeEvent(&event, NotificationEvent, FALSE);

  00015	33 db		 xor	 ebx, ebx
  00017	53		 push	 ebx
  00018	8b f8		 mov	 edi, eax
  0001a	53		 push	 ebx
  0001b	8d 45 e8	 lea	 eax, DWORD PTR _event$[ebp]
  0001e	50		 push	 eax
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 2421 : 
; 2422 : 	irp = IoBuildDeviceIoControlRequest (IoControlCode,
; 2423 : 					     deviceObject,
; 2424 : 					     InputBuffer, InputBufferSize,
; 2425 : 					     OutputBuffer, OutputBufferSize,
; 2426 : 					     FALSE,
; 2427 : 					     &event,
; 2428 : 					     &ioStatusBlock);

  00025	8d 45 f8	 lea	 eax, DWORD PTR _ioStatusBlock$[ebp]
  00028	50		 push	 eax
  00029	8d 45 e8	 lea	 eax, DWORD PTR _event$[ebp]
  0002c	50		 push	 eax
  0002d	53		 push	 ebx
  0002e	ff 75 1c	 push	 DWORD PTR _OutputBufferSize$[ebp]
  00031	ff 75 18	 push	 DWORD PTR _OutputBuffer$[ebp]
  00034	ff 75 14	 push	 DWORD PTR _InputBufferSize$[ebp]
  00037	ff 75 10	 push	 DWORD PTR _InputBuffer$[ebp]
  0003a	57		 push	 edi
  0003b	ff 75 0c	 push	 DWORD PTR _IoControlCode$[ebp]
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 2429 : 
; 2430 : 	if (irp == NULL)

  00044	3b c3		 cmp	 eax, ebx
  00046	75 07		 jne	 SHORT $LN2@TCFsctlCal

; 2431 : 		return STATUS_INSUFFICIENT_RESOURCES;

  00048	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  0004d	eb 31		 jmp	 SHORT $LN3@TCFsctlCal
$LN2@TCFsctlCal:

; 2432 : 
; 2433 : 	stack = IoGetNextIrpStackLocation(irp);

  0004f	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00052	83 e9 24	 sub	 ecx, 36			; 00000024H

; 2434 : 	
; 2435 : 	stack->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;

  00055	c6 01 0d	 mov	 BYTE PTR [ecx], 13	; 0000000dH

; 2436 : 	stack->MinorFunction = IRP_MN_USER_FS_REQUEST;

  00058	88 59 01	 mov	 BYTE PTR [ecx+1], bl

; 2437 : 	stack->FileObject = fileObject;

  0005b	89 71 18	 mov	 DWORD PTR [ecx+24], esi

; 2438 : 
; 2439 : 	ntStatus = IoCallDriver (deviceObject, irp);

  0005e	8b d0		 mov	 edx, eax
  00060	8b cf		 mov	 ecx, edi
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8

; 2440 : 	if (ntStatus == STATUS_PENDING)

  00068	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  0006d	75 11		 jne	 SHORT $LN3@TCFsctlCal

; 2441 : 	{
; 2442 : 		KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);

  0006f	53		 push	 ebx
  00070	53		 push	 ebx
  00071	53		 push	 ebx
  00072	53		 push	 ebx
  00073	8d 45 e8	 lea	 eax, DWORD PTR _event$[ebp]
  00076	50		 push	 eax
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 2443 : 		ntStatus = ioStatusBlock.Status;

  0007d	8b 45 f8	 mov	 eax, DWORD PTR _ioStatusBlock$[ebp]
$LN3@TCFsctlCal:
  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx

; 2444 : 	}
; 2445 : 
; 2446 : 	return ntStatus;
; 2447 : }

  00083	c9		 leave
  00084	c2 18 00	 ret	 24			; 00000018H
_TCFsctlCall@24 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_CreateDriveLink@4
; Function compile flags: /Ogsp
;	COMDAT _CreateDriveLink@4
_TEXT	SEGMENT
_deviceName$ = -532					; size = 8
_symLink$ = -524					; size = 8
_dev$ = -516						; size = 256
_link$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_nDosDriveNo$ = 8					; size = 4
_CreateDriveLink@4 PROC					; COMDAT

; 2451 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 14 02 00
	00		 sub	 esp, 532		; 00000214H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi

; 2452 : 	WCHAR dev[128], link[128];
; 2453 : 	UNICODE_STRING deviceName, symLink;
; 2454 : 	NTSTATUS ntStatus;
; 2455 : 
; 2456 : 	TCGetNTNameFromNumber (dev, nDosDriveNo);

  00016	ff 75 08	 push	 DWORD PTR _nDosDriveNo$[ebp]
  00019	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _dev$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _TCGetNTNameFromNumber@8

; 2457 : 	TCGetDosNameFromNumber (link, nDosDriveNo);

  00025	ff 75 08	 push	 DWORD PTR _nDosDriveNo$[ebp]
  00028	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _link$[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _TCGetDosNameFromNumber@8

; 2458 : 
; 2459 : 	RtlInitUnicodeString (&deviceName, dev);

  00034	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__RtlInitUnicodeString@8
  0003a	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _dev$[ebp]
  00040	50		 push	 eax
  00041	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _deviceName$[ebp]
  00047	50		 push	 eax
  00048	ff d6		 call	 esi

; 2460 : 	RtlInitUnicodeString (&symLink, link);

  0004a	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _link$[ebp]
  00050	50		 push	 eax
  00051	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _symLink$[ebp]
  00057	50		 push	 eax
  00058	ff d6		 call	 esi

; 2461 : 
; 2462 : 	ntStatus = IoCreateSymbolicLink (&symLink, &deviceName);

  0005a	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _deviceName$[ebp]
  00060	50		 push	 eax
  00061	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _symLink$[ebp]
  00067	50		 push	 eax
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoCreateSymbolicLink@8

; 2463 : 	Dump ("IoCreateSymbolicLink returned %X\n", ntStatus);
; 2464 : 	return ntStatus;
; 2465 : }

  0006e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00071	33 cd		 xor	 ecx, ebp
  00073	5e		 pop	 esi
  00074	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00079	c9		 leave
  0007a	c2 04 00	 ret	 4
_CreateDriveLink@4 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_RemoveDriveLink@4
; Function compile flags: /Ogsp
;	COMDAT _RemoveDriveLink@4
_TEXT	SEGMENT
_symLink$ = -524					; size = 8
_link$ = -516						; size = 512
__$ArrayPad$ = -4					; size = 4
_nDosDriveNo$ = 8					; size = 4
_RemoveDriveLink@4 PROC					; COMDAT

; 2469 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 0c 02 00
	00		 sub	 esp, 524		; 0000020cH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2470 : 	WCHAR link[256];
; 2471 : 	UNICODE_STRING symLink;
; 2472 : 	NTSTATUS ntStatus;
; 2473 : 
; 2474 : 	TCGetDosNameFromNumber (link, nDosDriveNo);

  00015	ff 75 08	 push	 DWORD PTR _nDosDriveNo$[ebp]
  00018	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _link$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 _TCGetDosNameFromNumber@8

; 2475 : 	RtlInitUnicodeString (&symLink, link);

  00024	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _link$[ebp]
  0002a	50		 push	 eax
  0002b	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _symLink$[ebp]
  00031	50		 push	 eax
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 2476 : 
; 2477 : 	ntStatus = IoDeleteSymbolicLink (&symLink);

  00038	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _symLink$[ebp]
  0003e	50		 push	 eax
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteSymbolicLink@4

; 2478 : 	Dump ("IoDeleteSymbolicLink returned %X\n", ntStatus);
; 2479 : 	return ntStatus;
; 2480 : }

  00045	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00048	33 cd		 xor	 ecx, ebp
  0004a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004f	c9		 leave
  00050	c2 04 00	 ret	 4
_RemoveDriveLink@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	__$ArrayPad$
PUBLIC	_MountManagerMount@4
;	COMDAT ??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'M', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, 'P'
	DB	00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'M', 00H, 'a', 00H
	DB	'n', 00H, 'a', 00H, 'g', 00H, 'e', 00H, 'r', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
text$s	ENDS
;	COMDAT _MountManagerMount@4
_TEXT	SEGMENT
_symName$ = -732					; size = 8
_devName$ = -724					; size = 8
_arrVolume$ = -716					; size = 512
_buf$ = -204						; size = 200
__$ArrayPad$ = -4					; size = 4
_mount$ = 8						; size = 4
_MountManagerMount@4 PROC				; COMDAT

; 2484 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec dc 02 00
	00		 sub	 esp, 732		; 000002dcH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi

; 2485 : 	NTSTATUS ntStatus; 
; 2486 : 	WCHAR arrVolume[256];
; 2487 : 	char buf[200];
; 2488 : 	PMOUNTMGR_TARGET_NAME in = (PMOUNTMGR_TARGET_NAME) buf;
; 2489 : 	PMOUNTMGR_CREATE_POINT_INPUT point = (PMOUNTMGR_CREATE_POINT_INPUT) buf;
; 2490 : 	UNICODE_STRING symName, devName;
; 2491 : 
; 2492 : 	TCGetNTNameFromNumber (arrVolume, mount->nDosDriveNo);

  00018	8b 7d 08	 mov	 edi, DWORD PTR _mount$[ebp]
  0001b	ff b7 64 02 00
	00		 push	 DWORD PTR [edi+612]
  00021	8d 85 34 fd ff
	ff		 lea	 eax, DWORD PTR _arrVolume$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _TCGetNTNameFromNumber@8

; 2493 : 	in->DeviceNameLength = (USHORT) wcslen (arrVolume) * 2;

  0002d	8d 85 34 fd ff
	ff		 lea	 eax, DWORD PTR _arrVolume$[ebp]
  00033	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
$LL5@MountManag:
  00036	66 8b 08	 mov	 cx, WORD PTR [eax]
  00039	40		 inc	 eax
  0003a	40		 inc	 eax
  0003b	66 85 c9	 test	 cx, cx
  0003e	75 f6		 jne	 SHORT $LL5@MountManag
  00040	2b c2		 sub	 eax, edx
  00042	d1 f8		 sar	 eax, 1
  00044	03 c0		 add	 eax, eax
  00046	66 89 85 34 ff
	ff ff		 mov	 WORD PTR _buf$[ebp], ax

; 2494 : 	wcscpy(in->DeviceName, arrVolume);

  0004d	33 f6		 xor	 esi, esi
  0004f	33 c0		 xor	 eax, eax
$LL3@MountManag:
  00051	0f b7 8c 05 34
	fd ff ff	 movzx	 ecx, WORD PTR _arrVolume$[ebp+eax]
  00059	66 89 8c 05 36
	ff ff ff	 mov	 WORD PTR _buf$[ebp+eax+2], cx
  00061	40		 inc	 eax
  00062	40		 inc	 eax
  00063	66 3b ce	 cmp	 cx, si
  00066	75 e9		 jne	 SHORT $LL3@MountManag

; 2495 : 
; 2496 : 	ntStatus = TCDeviceIoControl (MOUNTMGR_DEVICE_NAME, IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION,
; 2497 : 		in, (ULONG) (sizeof (in->DeviceNameLength) + wcslen (arrVolume) * 2), 0, 0);

  00068	8d 85 34 fd ff
	ff		 lea	 eax, DWORD PTR _arrVolume$[ebp]
  0006e	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
$LL6@MountManag:
  00071	66 8b 08	 mov	 cx, WORD PTR [eax]
  00074	40		 inc	 eax
  00075	40		 inc	 eax
  00076	66 3b ce	 cmp	 cx, si
  00079	75 f6		 jne	 SHORT $LL6@MountManag
  0007b	2b c2		 sub	 eax, edx
  0007d	56		 push	 esi
  0007e	d1 f8		 sar	 eax, 1
  00080	56		 push	 esi
  00081	8d 44 00 02	 lea	 eax, DWORD PTR [eax+eax+2]
  00085	50		 push	 eax
  00086	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  0008c	50		 push	 eax
  0008d	68 2c 40 6d 00	 push	 7159852			; 006d402cH
  00092	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
  00097	53		 push	 ebx
  00098	e8 00 00 00 00	 call	 _TCDeviceIoControl@24

; 2498 : 
; 2499 : 	memset (buf, 0, sizeof buf);

  0009d	68 c8 00 00 00	 push	 200			; 000000c8H
  000a2	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  000a8	56		 push	 esi
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 _memset
  000af	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2500 : 	TCGetDosNameFromNumber ((PWSTR) &point[1], mount->nDosDriveNo);

  000b2	ff b7 64 02 00
	00		 push	 DWORD PTR [edi+612]
  000b8	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp+8]
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 _TCGetDosNameFromNumber@8

; 2501 : 
; 2502 : 	point->SymbolicLinkNameOffset = sizeof (MOUNTMGR_CREATE_POINT_INPUT);

  000c4	6a 08		 push	 8
  000c6	58		 pop	 eax
  000c7	66 89 85 34 ff
	ff ff		 mov	 WORD PTR _buf$[ebp], ax

; 2503 : 	point->SymbolicLinkNameLength = (USHORT) wcslen ((PWSTR) &point[1]) * 2;

  000ce	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp+8]
  000d4	8d 48 02	 lea	 ecx, DWORD PTR [eax+2]
$LL7@MountManag:
  000d7	66 8b 10	 mov	 dx, WORD PTR [eax]
  000da	40		 inc	 eax
  000db	40		 inc	 eax
  000dc	66 3b d6	 cmp	 dx, si
  000df	75 f6		 jne	 SHORT $LL7@MountManag

; 2504 : 
; 2505 : 	RtlInitUnicodeString(&symName, (PWSTR) (buf + point->SymbolicLinkNameOffset));

  000e1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__RtlInitUnicodeString@8
  000e7	2b c1		 sub	 eax, ecx
  000e9	d1 f8		 sar	 eax, 1
  000eb	03 c0		 add	 eax, eax
  000ed	66 89 85 36 ff
	ff ff		 mov	 WORD PTR _buf$[ebp+2], ax
  000f4	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp+8]
  000fa	50		 push	 eax
  000fb	8d 85 24 fd ff
	ff		 lea	 eax, DWORD PTR _symName$[ebp]
  00101	50		 push	 eax
  00102	ff d6		 call	 esi

; 2506 : 
; 2507 : 	point->DeviceNameOffset = point->SymbolicLinkNameOffset + point->SymbolicLinkNameLength;

  00104	8b 85 36 ff ff
	ff		 mov	 eax, DWORD PTR _buf$[ebp+2]
  0010a	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _buf$[ebp]

; 2508 : 	TCGetNTNameFromNumber ((PWSTR) (buf + point->DeviceNameOffset), mount->nDosDriveNo);

  00110	ff b7 64 02 00
	00		 push	 DWORD PTR [edi+612]
  00116	03 c1		 add	 eax, ecx
  00118	66 89 85 38 ff
	ff ff		 mov	 WORD PTR _buf$[ebp+4], ax
  0011f	0f b7 c0	 movzx	 eax, ax
  00122	8d 84 05 34 ff
	ff ff		 lea	 eax, DWORD PTR _buf$[ebp+eax]
  00129	50		 push	 eax
  0012a	e8 00 00 00 00	 call	 _TCGetNTNameFromNumber@8

; 2509 : 	point->DeviceNameLength = (USHORT) wcslen ((PWSTR) (buf + point->DeviceNameOffset)) * 2;

  0012f	0f b7 8d 38 ff
	ff ff		 movzx	 ecx, WORD PTR _buf$[ebp+4]
  00136	8d 8c 0d 34 ff
	ff ff		 lea	 ecx, DWORD PTR _buf$[ebp+ecx]
  0013d	8b c1		 mov	 eax, ecx
  0013f	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
$LL8@MountManag:
  00142	66 8b 38	 mov	 di, WORD PTR [eax]
  00145	40		 inc	 eax
  00146	40		 inc	 eax
  00147	66 85 ff	 test	 di, di
  0014a	75 f6		 jne	 SHORT $LL8@MountManag
  0014c	2b c2		 sub	 eax, edx
  0014e	d1 f8		 sar	 eax, 1
  00150	03 c0		 add	 eax, eax
  00152	66 89 85 3a ff
	ff ff		 mov	 WORD PTR _buf$[ebp+6], ax

; 2510 : 
; 2511 : 	RtlInitUnicodeString(&devName, (PWSTR) (buf + point->DeviceNameOffset));

  00159	51		 push	 ecx
  0015a	8d 85 2c fd ff
	ff		 lea	 eax, DWORD PTR _devName$[ebp]
  00160	50		 push	 eax
  00161	ff d6		 call	 esi

; 2512 : 
; 2513 : 	ntStatus = TCDeviceIoControl (MOUNTMGR_DEVICE_NAME, IOCTL_MOUNTMGR_CREATE_POINT, point,
; 2514 : 		point->DeviceNameOffset + point->DeviceNameLength, 0, 0);
; 2515 : 
; 2516 : 	return ntStatus;

  00163	0f b7 85 3a ff
	ff ff		 movzx	 eax, WORD PTR _buf$[ebp+6]
  0016a	0f b7 8d 38 ff
	ff ff		 movzx	 ecx, WORD PTR _buf$[ebp+4]
  00171	6a 00		 push	 0
  00173	6a 00		 push	 0
  00175	03 c1		 add	 eax, ecx
  00177	50		 push	 eax
  00178	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  0017e	50		 push	 eax
  0017f	68 00 c0 6d 00	 push	 7192576			; 006dc000H
  00184	53		 push	 ebx
  00185	e8 00 00 00 00	 call	 _TCDeviceIoControl@24

; 2517 : }

  0018a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018d	5f		 pop	 edi
  0018e	5e		 pop	 esi
  0018f	33 cd		 xor	 ecx, ebp
  00191	5b		 pop	 ebx
  00192	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00197	c9		 leave
  00198	c2 04 00	 ret	 4
_MountManagerMount@4 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_MountManagerUnmount@4
; Function compile flags: /Ogsp
;	COMDAT _MountManagerUnmount@4
_TEXT	SEGMENT
_out$ = -560						; size = 300
_buf$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_nDosDriveNo$ = 8					; size = 4
_MountManagerUnmount@4 PROC				; COMDAT

; 2521 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 30 02 00
	00		 sub	 esp, 560		; 00000230H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2522 : 	NTSTATUS ntStatus; 
; 2523 : 	char buf[256], out[300];
; 2524 : 	PMOUNTMGR_MOUNT_POINT in = (PMOUNTMGR_MOUNT_POINT) buf;
; 2525 : 
; 2526 : 	memset (buf, 0, sizeof buf);

  00015	68 00 01 00 00	 push	 256			; 00000100H
  0001a	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  00020	6a 00		 push	 0
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 _memset
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2527 : 
; 2528 : 	TCGetDosNameFromNumber ((PWSTR) &in[1], nDosDriveNo);

  0002b	ff 75 08	 push	 DWORD PTR _nDosDriveNo$[ebp]
  0002e	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp+24]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _TCGetDosNameFromNumber@8

; 2529 : 
; 2530 : 	// Only symbolic link can be deleted with IOCTL_MOUNTMGR_DELETE_POINTS. If any other entry is specified, the mount manager will ignore subsequent IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION for the same volume ID.
; 2531 : 	in->SymbolicLinkNameOffset = sizeof (MOUNTMGR_MOUNT_POINT);

  0003a	6a 18		 push	 24			; 00000018H
  0003c	5a		 pop	 edx

; 2532 : 	in->SymbolicLinkNameLength = (USHORT) wcslen ((PWCHAR) &in[1]) * 2;

  0003d	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp+24]
  00043	89 95 fc fe ff
	ff		 mov	 DWORD PTR _buf$[ebp], edx
  00049	8d 48 02	 lea	 ecx, DWORD PTR [eax+2]
  0004c	56		 push	 esi
$LL3@MountManag@2:
  0004d	66 8b 30	 mov	 si, WORD PTR [eax]
  00050	40		 inc	 eax
  00051	40		 inc	 eax
  00052	66 85 f6	 test	 si, si
  00055	75 f6		 jne	 SHORT $LL3@MountManag@2
  00057	2b c1		 sub	 eax, ecx
  00059	d1 f8		 sar	 eax, 1
  0005b	03 c0		 add	 eax, eax
  0005d	66 89 85 00 ff
	ff ff		 mov	 WORD PTR _buf$[ebp+4], ax

; 2533 : 
; 2534 : 	ntStatus = TCDeviceIoControl (MOUNTMGR_DEVICE_NAME, IOCTL_MOUNTMGR_DELETE_POINTS,
; 2535 : 		in, sizeof(MOUNTMGR_MOUNT_POINT) + in->SymbolicLinkNameLength, out, sizeof out);

  00064	68 2c 01 00 00	 push	 300			; 0000012cH

; 2536 : 
; 2537 : 	Dump ("IOCTL_MOUNTMGR_DELETE_POINTS returned 0x%08x\n", ntStatus);
; 2538 : 
; 2539 : 	return ntStatus;

  00069	0f b7 c0	 movzx	 eax, ax
  0006c	8d 8d d0 fd ff
	ff		 lea	 ecx, DWORD PTR _out$[ebp]
  00072	51		 push	 ecx
  00073	03 c2		 add	 eax, edx
  00075	50		 push	 eax
  00076	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  0007c	50		 push	 eax
  0007d	68 04 c0 6d 00	 push	 7192580			; 006dc004H
  00082	68 00 00 00 00	 push	 OFFSET ??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
  00087	e8 00 00 00 00	 call	 _TCDeviceIoControl@24

; 2540 : }

  0008c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008f	33 cd		 xor	 ecx, ebp
  00091	5e		 pop	 esi
  00092	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00097	c9		 leave
  00098	c2 04 00	 ret	 4
_MountManagerUnmount@4 ENDP
_TEXT	ENDS
PUBLIC	_getToken@4
; Function compile flags: /Ogsp
;	COMDAT _getToken@4
_TEXT	SEGMENT
_psubContext$ = 8					; size = 4
_getToken@4 PROC					; COMDAT

; 2548 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 2549 : 	if (!psubContext) 

  00005	8b 4d 08	 mov	 ecx, DWORD PTR _psubContext$[ebp]
  00008	85 c9		 test	 ecx, ecx
  0000a	75 04		 jne	 SHORT $LN4@getToken

; 2550 : 	{
; 2551 : 		return NULL;

  0000c	33 c0		 xor	 eax, eax
  0000e	eb 0f		 jmp	 SHORT $LN1@getToken
$LN4@getToken:

; 2552 : 	}
; 2553 : 	else if (psubContext->ClientToken && psubContext->ImpersonationLevel >= SecurityImpersonation)

  00010	8b 01		 mov	 eax, DWORD PTR [ecx]
  00012	85 c0		 test	 eax, eax
  00014	74 06		 je	 SHORT $LN2@getToken
  00016	83 79 04 02	 cmp	 DWORD PTR [ecx+4], 2

; 2554 : 	{
; 2555 : 		return psubContext->ClientToken;

  0001a	7d 03		 jge	 SHORT $LN1@getToken
$LN2@getToken:

; 2556 : 	}
; 2557 : 	else
; 2558 : 	{
; 2559 : 		return psubContext->PrimaryToken;

  0001c	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
$LN1@getToken:

; 2560 : 	}
; 2561 : }

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
_getToken@4 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _FindVolumeWithHighestUniqueId@4
_TEXT	SEGMENT
_maxUniqueId$ = 8					; size = 4
_FindVolumeWithHighestUniqueId@4 PROC			; COMDAT

; 2785 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi
  00006	57		 push	 edi

; 2786 : 	PDEVICE_OBJECT highestIdDevice = NULL;

  00007	33 ff		 xor	 edi, edi

; 2787 : 	int highestId = -1;

  00009	83 ca ff	 or	 edx, -1

; 2788 : 	int drive;
; 2789 : 
; 2790 : 	for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)

  0000c	33 f6		 xor	 esi, esi
$LL5@FindVolume:

; 2791 : 	{
; 2792 : 		PDEVICE_OBJECT device = GetVirtualVolumeDeviceObject (drive);

  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _GetVirtualVolumeDeviceObject@4

; 2793 : 		if (device)

  00014	85 c0		 test	 eax, eax
  00016	74 13		 je	 SHORT $LN4@FindVolume

; 2794 : 		{
; 2795 : 			PEXTENSION extension = (PEXTENSION) device->DeviceExtension;

  00018	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]

; 2796 : 			if (extension->UniqueVolumeId > highestId && extension->UniqueVolumeId <= maxUniqueId)

  0001b	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0001e	3b ca		 cmp	 ecx, edx
  00020	7e 09		 jle	 SHORT $LN4@FindVolume
  00022	3b 4d 08	 cmp	 ecx, DWORD PTR _maxUniqueId$[ebp]
  00025	7f 04		 jg	 SHORT $LN4@FindVolume

; 2797 : 			{
; 2798 : 				highestId = extension->UniqueVolumeId;

  00027	8b d1		 mov	 edx, ecx

; 2799 : 				highestIdDevice = device;

  00029	8b f8		 mov	 edi, eax
$LN4@FindVolume:
  0002b	46		 inc	 esi
  0002c	83 fe 19	 cmp	 esi, 25			; 00000019H
  0002f	7e dd		 jle	 SHORT $LL5@FindVolume

; 2800 : 			}
; 2801 : 		}
; 2802 : 	}
; 2803 : 
; 2804 : 	return highestIdDevice;

  00031	8b c7		 mov	 eax, edi
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi

; 2805 : }

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
_FindVolumeWithHighestUniqueId@4 ENDP
_TEXT	ENDS
PUBLIC	_SymbolicLinkToTarget@12
EXTRN	__imp__ZwQuerySymbolicLinkObject@12:PROC
EXTRN	__imp__ZwOpenSymbolicLinkObject@12:PROC
; Function compile flags: /Ogsp
;	COMDAT _SymbolicLinkToTarget@12
_TEXT	SEGMENT
_objectAttributes$ = -40				; size = 24
_fullFileName$ = -16					; size = 8
_target$31072 = -8					; size = 8
_handle$ = 8						; size = 4
_symlinkName$ = 8					; size = 4
_targetName$ = 12					; size = 4
_maxTargetNameLength$ = 16				; size = 2
_SymbolicLinkToTarget@12 PROC				; COMDAT

; 2845 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 28	 sub	 esp, 40			; 00000028H
  00008	56		 push	 esi
  00009	57		 push	 edi

; 2846 : 	NTSTATUS ntStatus;
; 2847 : 	OBJECT_ATTRIBUTES objectAttributes;
; 2848 : 	UNICODE_STRING fullFileName;
; 2849 : 	HANDLE handle;
; 2850 : 
; 2851 : 	RtlInitUnicodeString (&fullFileName, symlinkName);

  0000a	ff 75 08	 push	 DWORD PTR _symlinkName$[ebp]
  0000d	8d 45 f0	 lea	 eax, DWORD PTR _fullFileName$[ebp]
  00010	50		 push	 eax
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 2852 : 	InitializeObjectAttributes (&objectAttributes, &fullFileName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

  00017	8d 45 f0	 lea	 eax, DWORD PTR _fullFileName$[ebp]
  0001a	89 45 e0	 mov	 DWORD PTR _objectAttributes$[ebp+8], eax

; 2853 : 
; 2854 : 	ntStatus = ZwOpenSymbolicLinkObject (&handle, GENERIC_READ, &objectAttributes);

  0001d	8d 45 d8	 lea	 eax, DWORD PTR _objectAttributes$[ebp]
  00020	50		 push	 eax
  00021	33 f6		 xor	 esi, esi
  00023	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00028	8d 45 08	 lea	 eax, DWORD PTR _handle$[ebp]
  0002b	50		 push	 eax
  0002c	c7 45 d8 18 00
	00 00		 mov	 DWORD PTR _objectAttributes$[ebp], 24 ; 00000018H
  00033	89 75 dc	 mov	 DWORD PTR _objectAttributes$[ebp+4], esi
  00036	c7 45 e4 40 02
	00 00		 mov	 DWORD PTR _objectAttributes$[ebp+12], 576 ; 00000240H
  0003d	89 75 e8	 mov	 DWORD PTR _objectAttributes$[ebp+16], esi
  00040	89 75 ec	 mov	 DWORD PTR _objectAttributes$[ebp+20], esi
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwOpenSymbolicLinkObject@12
  00049	8b f8		 mov	 edi, eax

; 2855 : 
; 2856 : 	if (NT_SUCCESS (ntStatus))

  0004b	3b fe		 cmp	 edi, esi
  0004d	7c 3b		 jl	 SHORT $LN1@SymbolicLi

; 2857 : 	{
; 2858 : 		UNICODE_STRING target;
; 2859 : 		target.Buffer = targetName;

  0004f	8b 45 0c	 mov	 eax, DWORD PTR _targetName$[ebp]

; 2860 : 		target.Length = 0;

  00052	33 c9		 xor	 ecx, ecx
  00054	66 89 4d f8	 mov	 WORD PTR _target$31072[ebp], cx

; 2861 : 		target.MaximumLength = maxTargetNameLength;

  00058	66 8b 4d 10	 mov	 cx, WORD PTR _maxTargetNameLength$[ebp]
  0005c	66 89 4d fa	 mov	 WORD PTR _target$31072[ebp+2], cx

; 2862 : 		memset (targetName, 0, maxTargetNameLength);

  00060	0f b7 c9	 movzx	 ecx, cx
  00063	51		 push	 ecx
  00064	56		 push	 esi
  00065	50		 push	 eax
  00066	89 45 fc	 mov	 DWORD PTR _target$31072[ebp+4], eax
  00069	e8 00 00 00 00	 call	 _memset
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2863 : 
; 2864 : 		ntStatus = ZwQuerySymbolicLinkObject (handle, &target, NULL);

  00071	56		 push	 esi
  00072	8d 45 f8	 lea	 eax, DWORD PTR _target$31072[ebp]
  00075	50		 push	 eax
  00076	ff 75 08	 push	 DWORD PTR _handle$[ebp]
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwQuerySymbolicLinkObject@12

; 2865 : 
; 2866 : 		ZwClose (handle);

  0007f	ff 75 08	 push	 DWORD PTR _handle$[ebp]
  00082	8b f8		 mov	 edi, eax
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4
$LN1@SymbolicLi:

; 2867 : 	}
; 2868 : 
; 2869 : 	return ntStatus;

  0008a	8b c7		 mov	 eax, edi
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi

; 2870 : }

  0008e	c9		 leave
  0008f	c2 0c 00	 ret	 12			; 0000000cH
_SymbolicLinkToTarget@12 ENDP
_TEXT	ENDS
PUBLIC	_RegionsOverlap@32
; Function compile flags: /Ogsp
;	COMDAT _RegionsOverlap@32
_TEXT	SEGMENT
_start1$ = 8						; size = 8
_end1$ = 16						; size = 8
_start2$ = 24						; size = 8
_end2$ = 32						; size = 8
_RegionsOverlap@32 PROC					; COMDAT

; 2875 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 2876 : 	return (start1 < start2) ? (end1 >= start2) : (start1 <= end2);

  00005	8b 45 0c	 mov	 eax, DWORD PTR _start1$[ebp+4]
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _start1$[ebp]
  0000b	3b 45 1c	 cmp	 eax, DWORD PTR _start2$[ebp+4]
  0000e	77 1f		 ja	 SHORT $LN7@RegionsOve
  00010	72 05		 jb	 SHORT $LN9@RegionsOve
  00012	3b 4d 18	 cmp	 ecx, DWORD PTR _start2$[ebp]
  00015	73 18		 jae	 SHORT $LN7@RegionsOve
$LN9@RegionsOve:
  00017	8b 45 14	 mov	 eax, DWORD PTR _end1$[ebp+4]
  0001a	3b 45 1c	 cmp	 eax, DWORD PTR _start2$[ebp+4]
  0001d	72 0a		 jb	 SHORT $LN3@RegionsOve
  0001f	77 1a		 ja	 SHORT $LN11@RegionsOve
  00021	8b 45 10	 mov	 eax, DWORD PTR _end1$[ebp]
  00024	3b 45 18	 cmp	 eax, DWORD PTR _start2$[ebp]
  00027	73 12		 jae	 SHORT $LN11@RegionsOve
$LN3@RegionsOve:
  00029	33 c0		 xor	 eax, eax
$LN4@RegionsOve:

; 2877 : }

  0002b	5d		 pop	 ebp
  0002c	c2 20 00	 ret	 32			; 00000020H
$LN7@RegionsOve:

; 2876 : 	return (start1 < start2) ? (end1 >= start2) : (start1 <= end2);

  0002f	3b 45 24	 cmp	 eax, DWORD PTR _end2$[ebp+4]
  00032	77 f5		 ja	 SHORT $LN3@RegionsOve
  00034	72 05		 jb	 SHORT $LN11@RegionsOve
  00036	3b 4d 20	 cmp	 ecx, DWORD PTR _end2$[ebp]
  00039	77 ee		 ja	 SHORT $LN3@RegionsOve
$LN11@RegionsOve:
  0003b	33 c0		 xor	 eax, eax
  0003d	40		 inc	 eax
  0003e	eb eb		 jmp	 SHORT $LN4@RegionsOve
_RegionsOverlap@32 ENDP
_TEXT	ENDS
PUBLIC	_GetIntersection@36
; Function compile flags: /Ogsp
;	COMDAT _GetIntersection@36
_TEXT	SEGMENT
_start1$ = 8						; size = 8
_length1$ = 16						; size = 4
_start2$ = 20						; size = 8
tv74 = 28						; size = 8
_end2$ = 28						; size = 8
_intersectStart$ = 36					; size = 4
_intersectLength$ = 40					; size = 4
_GetIntersection@36 PROC				; COMDAT

; 2881 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 2882 : 	uint64 end1 = start1 + length1 - 1;

  00005	8b 45 10	 mov	 eax, DWORD PTR _length1$[ebp]

; 2883 : 	uint64 intersectEnd = (end1 <= end2) ? end1 : end2;

  00008	8b 55 1c	 mov	 edx, DWORD PTR _end2$[ebp]
  0000b	33 c9		 xor	 ecx, ecx
  0000d	03 45 08	 add	 eax, DWORD PTR _start1$[ebp]
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _start1$[ebp+4]
  00014	13 cb		 adc	 ecx, ebx
  00016	83 c0 ff	 add	 eax, -1
  00019	83 d1 ff	 adc	 ecx, -1
  0001c	3b 4d 20	 cmp	 ecx, DWORD PTR _end2$[ebp+4]
  0001f	77 0a		 ja	 SHORT $LN4@GetInterse
  00021	72 04		 jb	 SHORT $LN10@GetInterse
  00023	3b c2		 cmp	 eax, edx
  00025	77 04		 ja	 SHORT $LN4@GetInterse
$LN10@GetInterse:
  00027	8b d0		 mov	 edx, eax
  00029	eb 03		 jmp	 SHORT $LN5@GetInterse
$LN4@GetInterse:
  0002b	8b 4d 20	 mov	 ecx, DWORD PTR _end2$[ebp+4]
$LN5@GetInterse:
  0002e	56		 push	 esi

; 2884 : 	
; 2885 : 	*intersectStart = (start1 >= start2) ? start1 : start2;

  0002f	8b 75 14	 mov	 esi, DWORD PTR _start2$[ebp]
  00032	57		 push	 edi
  00033	8b 7d 18	 mov	 edi, DWORD PTR _start2$[ebp+4]
  00036	3b df		 cmp	 ebx, edi
  00038	72 0c		 jb	 SHORT $LN6@GetInterse
  0003a	77 05		 ja	 SHORT $LN13@GetInterse
  0003c	39 75 08	 cmp	 DWORD PTR _start1$[ebp], esi
  0003f	72 05		 jb	 SHORT $LN6@GetInterse
$LN13@GetInterse:
  00041	8b 75 08	 mov	 esi, DWORD PTR _start1$[ebp]
  00044	8b fb		 mov	 edi, ebx
$LN6@GetInterse:
  00046	8b 45 24	 mov	 eax, DWORD PTR _intersectStart$[ebp]
  00049	89 78 04	 mov	 DWORD PTR [eax+4], edi
  0004c	89 30		 mov	 DWORD PTR [eax], esi

; 2886 : 	*intersectLength = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);

  0004e	8b fe		 mov	 edi, esi
  00050	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00053	3b f1		 cmp	 esi, ecx
  00055	72 0d		 jb	 SHORT $LN8@GetInterse
  00057	77 04		 ja	 SHORT $LN12@GetInterse
  00059	3b fa		 cmp	 edi, edx
  0005b	76 07		 jbe	 SHORT $LN8@GetInterse
$LN12@GetInterse:
  0005d	33 d2		 xor	 edx, edx
  0005f	21 55 20	 and	 DWORD PTR tv74[ebp+4], edx
  00062	eb 0d		 jmp	 SHORT $LN9@GetInterse
$LN8@GetInterse:
  00064	2b d7		 sub	 edx, edi
  00066	1b ce		 sbb	 ecx, esi
  00068	83 c2 01	 add	 edx, 1
  0006b	83 d1 00	 adc	 ecx, 0
  0006e	89 4d 20	 mov	 DWORD PTR tv74[ebp+4], ecx
$LN9@GetInterse:
  00071	8b 4d 28	 mov	 ecx, DWORD PTR _intersectLength$[ebp]
  00074	5f		 pop	 edi
  00075	89 11		 mov	 DWORD PTR [ecx], edx
  00077	5e		 pop	 esi

; 2887 : 	
; 2888 : 	if (*intersectLength == 0)

  00078	85 d2		 test	 edx, edx
  0007a	75 08		 jne	 SHORT $LN1@GetInterse

; 2889 : 		*intersectStart = start1;

  0007c	8b 4d 08	 mov	 ecx, DWORD PTR _start1$[ebp]
  0007f	89 08		 mov	 DWORD PTR [eax], ecx
  00081	89 58 04	 mov	 DWORD PTR [eax+4], ebx
$LN1@GetInterse:
  00084	5b		 pop	 ebx

; 2890 : }

  00085	5d		 pop	 ebp
  00086	c2 24 00	 ret	 36			; 00000024H
_GetIntersection@36 ENDP
_TEXT	ENDS
PUBLIC	_IsAccessibleByUser@8
; Function compile flags: /Ogsp
;	COMDAT _IsAccessibleByUser@8
_TEXT	SEGMENT
_fileObjAttributes$ = -32				; size = 24
_ioStatusBlock$ = -8					; size = 8
_fileHandle$ = 8					; size = 4
_objectFileName$ = 8					; size = 4
_readOnly$ = 12						; size = 4
_IsAccessibleByUser@8 PROC				; COMDAT

; 2894 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 20	 sub	 esp, 32			; 00000020H

; 2895 : 	OBJECT_ATTRIBUTES fileObjAttributes;
; 2896 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2897 : 	HANDLE fileHandle;
; 2898 : 	NTSTATUS status;
; 2899 : 
; 2900 : 	ASSERT (!IoIsSystemThread (PsGetCurrentThread()));
; 2901 : 
; 2902 : 	InitializeObjectAttributes (&fileObjAttributes, objectFileName, OBJ_CASE_INSENSITIVE | OBJ_FORCE_ACCESS_CHECK | OBJ_KERNEL_HANDLE, NULL, NULL);

  00008	8b 4d 08	 mov	 ecx, DWORD PTR _objectFileName$[ebp]
  0000b	33 c0		 xor	 eax, eax

; 2903 : 	
; 2904 : 	status = ZwCreateFile (&fileHandle,
; 2905 : 		readOnly ? GENERIC_READ : GENERIC_READ | GENERIC_WRITE,
; 2906 : 		&fileObjAttributes,
; 2907 : 		&ioStatusBlock,
; 2908 : 		NULL,
; 2909 : 		FILE_ATTRIBUTE_NORMAL,
; 2910 : 		FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
; 2911 : 		FILE_OPEN,
; 2912 : 		FILE_SYNCHRONOUS_IO_NONALERT,
; 2913 : 		NULL,
; 2914 : 		0);

  0000d	50		 push	 eax
  0000e	50		 push	 eax
  0000f	6a 20		 push	 32			; 00000020H
  00011	6a 01		 push	 1
  00013	6a 07		 push	 7
  00015	68 80 00 00 00	 push	 128			; 00000080H
  0001a	50		 push	 eax
  0001b	89 45 e4	 mov	 DWORD PTR _fileObjAttributes$[ebp+4], eax
  0001e	89 45 f0	 mov	 DWORD PTR _fileObjAttributes$[ebp+16], eax
  00021	89 45 f4	 mov	 DWORD PTR _fileObjAttributes$[ebp+20], eax
  00024	89 4d e8	 mov	 DWORD PTR _fileObjAttributes$[ebp+8], ecx
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _readOnly$[ebp]
  0002a	8d 45 f8	 lea	 eax, DWORD PTR _ioStatusBlock$[ebp]
  0002d	50		 push	 eax
  0002e	f7 d9		 neg	 ecx
  00030	8d 45 e0	 lea	 eax, DWORD PTR _fileObjAttributes$[ebp]
  00033	50		 push	 eax
  00034	1b c9		 sbb	 ecx, ecx
  00036	b8 00 00 00 c0	 mov	 eax, -1073741824	; c0000000H
  0003b	23 c8		 and	 ecx, eax
  0003d	03 c8		 add	 ecx, eax
  0003f	51		 push	 ecx
  00040	8d 45 08	 lea	 eax, DWORD PTR _fileHandle$[ebp]
  00043	50		 push	 eax
  00044	c7 45 e0 18 00
	00 00		 mov	 DWORD PTR _fileObjAttributes$[ebp], 24 ; 00000018H
  0004b	c7 45 ec 40 06
	00 00		 mov	 DWORD PTR _fileObjAttributes$[ebp+12], 1600 ; 00000640H
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwCreateFile@44

; 2915 : 
; 2916 : 	if (NT_SUCCESS (status))

  00058	85 c0		 test	 eax, eax
  0005a	7c 0e		 jl	 SHORT $LN1@IsAccessib

; 2917 : 	{
; 2918 : 		ZwClose (fileHandle);

  0005c	ff 75 08	 push	 DWORD PTR _fileHandle$[ebp]
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 2919 : 		return TRUE;

  00065	33 c0		 xor	 eax, eax
  00067	40		 inc	 eax
  00068	eb 02		 jmp	 SHORT $LN2@IsAccessib
$LN1@IsAccessib:

; 2920 : 	}
; 2921 : 
; 2922 : 	return FALSE;

  0006a	33 c0		 xor	 eax, eax
$LN2@IsAccessib:

; 2923 : }

  0006c	c9		 leave
  0006d	c2 08 00	 ret	 8
_IsAccessibleByUser@8 ENDP
_TEXT	ENDS
PUBLIC	_UserCanAccessDriveDevice@0
; Function compile flags: /Ogsp
;	COMDAT _UserCanAccessDriveDevice@0
_TEXT	SEGMENT
_name$ = -8						; size = 8
_UserCanAccessDriveDevice@0 PROC			; COMDAT

; 2927 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	51		 push	 ecx

; 2928 : 	UNICODE_STRING name;
; 2929 : 	RtlInitUnicodeString (&name, L"\\Device\\MountPointManager");

  00007	68 00 00 00 00	 push	 OFFSET ??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
  0000c	8d 45 f8	 lea	 eax, DWORD PTR _name$[ebp]
  0000f	50		 push	 eax
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 2930 : 
; 2931 : 	return IsAccessibleByUser (&name, FALSE);

  00016	6a 00		 push	 0
  00018	8d 45 f8	 lea	 eax, DWORD PTR _name$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _IsAccessibleByUser@8

; 2932 : }

  00021	c9		 leave
  00022	c3		 ret	 0
_UserCanAccessDriveDevice@0 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_IsDriveLetterAvailable@4
; Function compile flags: /Ogsp
;	COMDAT _IsDriveLetterAvailable@4
_TEXT	SEGMENT
_objectName$ = -296					; size = 8
_objectAttributes$ = -288				; size = 24
_handle$ = -264						; size = 4
_link$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_nDosDriveNo$ = 8					; size = 4
_IsDriveLetterAvailable@4 PROC				; COMDAT

; 2942 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 28 01 00
	00		 sub	 esp, 296		; 00000128H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2943 : 	OBJECT_ATTRIBUTES objectAttributes;
; 2944 : 	UNICODE_STRING objectName;
; 2945 : 	WCHAR link[128];
; 2946 : 	HANDLE handle;
; 2947 : 	NTSTATUS ntStatus;
; 2948 : 
; 2949 : 	TCGetDosNameFromNumber (link, nDosDriveNo);

  00015	ff 75 08	 push	 DWORD PTR _nDosDriveNo$[ebp]
  00018	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _link$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 _TCGetDosNameFromNumber@8

; 2950 : 	RtlInitUnicodeString (&objectName, link);

  00024	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _link$[ebp]
  0002a	50		 push	 eax
  0002b	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _objectName$[ebp]
  00031	50		 push	 eax
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 2951 : 	InitializeObjectAttributes (&objectAttributes, &objectName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

  00038	83 a5 e4 fe ff
	ff 00		 and	 DWORD PTR _objectAttributes$[ebp+4], 0
  0003f	83 a5 f0 fe ff
	ff 00		 and	 DWORD PTR _objectAttributes$[ebp+16], 0
  00046	83 a5 f4 fe ff
	ff 00		 and	 DWORD PTR _objectAttributes$[ebp+20], 0
  0004d	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _objectName$[ebp]
  00053	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _objectAttributes$[ebp+8], eax

; 2952 : 
; 2953 : 	ntStatus=ZwOpenSymbolicLinkObject (&handle, GENERIC_READ, &objectAttributes);

  00059	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _objectAttributes$[ebp]
  0005f	50		 push	 eax
  00060	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00065	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _handle$[ebp]
  0006b	50		 push	 eax
  0006c	c7 85 e0 fe ff
	ff 18 00 00 00	 mov	 DWORD PTR _objectAttributes$[ebp], 24 ; 00000018H
  00076	c7 85 ec fe ff
	ff 40 02 00 00	 mov	 DWORD PTR _objectAttributes$[ebp+12], 576 ; 00000240H
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwOpenSymbolicLinkObject@12

; 2954 : 	if (NT_SUCCESS (ntStatus))

  00086	85 c0		 test	 eax, eax
  00088	7c 10		 jl	 SHORT $LN4@IsDriveLet

; 2955 : 	{
; 2956 : 		ZwClose (handle);

  0008a	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _handle$[ebp]
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 2957 : 		return FALSE;

  00096	33 c0		 xor	 eax, eax
  00098	eb 0c		 jmp	 SHORT $LN2@IsDriveLet
$LN4@IsDriveLet:

; 2958 : 	}
; 2959 : 	else if (ntStatus == STATUS_OBJECT_NAME_NOT_FOUND)

  0009a	33 c9		 xor	 ecx, ecx
  0009c	3d 34 00 00 c0	 cmp	 eax, -1073741772	; c0000034H
  000a1	0f 94 c1	 sete	 cl
  000a4	8b c1		 mov	 eax, ecx
$LN2@IsDriveLet:

; 2960 : 	{
; 2961 : 		return TRUE;
; 2962 : 	}
; 2963 : 	else
; 2964 : 	{
; 2965 : 		return FALSE;
; 2966 : 	}
; 2967 : }

  000a6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a9	33 cd		 xor	 ecx, ebp
  000ab	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b0	c9		 leave
  000b1	c2 04 00	 ret	 4
_IsDriveLetterAvailable@4 ENDP
_TEXT	ENDS
PUBLIC	_TCCompleteIrp@12
EXTRN	__imp_@IofCompleteRequest@8:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCCompleteIrp@12
_TEXT	SEGMENT
_irp$ = 8						; size = 4
_status$ = 12						; size = 4
_information$ = 16					; size = 4
_TCCompleteIrp@12 PROC					; COMDAT

; 2971 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 2972 : 	irp->IoStatus.Status = status;

  00005	8b 4d 08	 mov	 ecx, DWORD PTR _irp$[ebp]

; 2973 : 	irp->IoStatus.Information = information;

  00008	8b 45 10	 mov	 eax, DWORD PTR _information$[ebp]
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR _status$[ebp]

; 2974 : 	IoCompleteRequest (irp, IO_NO_INCREMENT);

  0000f	32 d2		 xor	 dl, dl
  00011	89 71 18	 mov	 DWORD PTR [ecx+24], esi
  00014	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 2975 : 	return status;

  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi

; 2976 : }

  00020	5d		 pop	 ebp
  00021	c2 0c 00	 ret	 12			; 0000000cH
_TCCompleteIrp@12 ENDP
_TEXT	ENDS
PUBLIC	_TCCompleteDiskIrp@12
; Function compile flags: /Ogsp
;	COMDAT _TCCompleteDiskIrp@12
_TEXT	SEGMENT
_irp$ = 8						; size = 4
_status$ = 12						; size = 4
_information$ = 16					; size = 4
_TCCompleteDiskIrp@12 PROC				; COMDAT

; 2980 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 2981 : 	irp->IoStatus.Status = status;

  00005	8b 4d 08	 mov	 ecx, DWORD PTR _irp$[ebp]

; 2982 : 	irp->IoStatus.Information = information;

  00008	8b 45 10	 mov	 eax, DWORD PTR _information$[ebp]
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR _status$[ebp]

; 2983 : 	IoCompleteRequest (irp, NT_SUCCESS (status) ? IO_DISK_INCREMENT : IO_NO_INCREMENT);

  0000f	85 f6		 test	 esi, esi
  00011	0f 9d c2	 setge	 dl
  00014	89 71 18	 mov	 DWORD PTR [ecx+24], esi
  00017	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 2984 : 	return status;

  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi

; 2985 : }

  00023	5d		 pop	 ebp
  00024	c2 0c 00	 ret	 12			; 0000000cH
_TCCompleteDiskIrp@12 ENDP
_TEXT	ENDS
PUBLIC	_GetCpuCount@0
EXTRN	__imp__KeQueryActiveProcessors@0:PROC
; Function compile flags: /Ogsp
;	COMDAT _GetCpuCount@0
_TEXT	SEGMENT
_GetCpuCount@0 PROC					; COMDAT

; 2990 : 	KAFFINITY activeCpuMap = KeQueryActiveProcessors();

  00000	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeQueryActiveProcessors@0

; 2991 : 	size_t mapSize = sizeof (activeCpuMap) * 8;

  00006	6a 20		 push	 32			; 00000020H
  00008	59		 pop	 ecx

; 2992 : 	size_t cpuCount = 0;

  00009	33 d2		 xor	 edx, edx
$LL4@GetCpuCoun@2:

; 2993 : 
; 2994 : 	while (mapSize--)

  0000b	49		 dec	 ecx

; 2995 : 	{
; 2996 : 		if (activeCpuMap & 1)

  0000c	a8 01		 test	 al, 1
  0000e	74 01		 je	 SHORT $LN2@GetCpuCoun@2

; 2997 : 			++cpuCount;

  00010	42		 inc	 edx
$LN2@GetCpuCoun@2:

; 2998 : 
; 2999 : 		activeCpuMap >>= 1;

  00011	d1 e8		 shr	 eax, 1
  00013	85 c9		 test	 ecx, ecx
  00015	75 f4		 jne	 SHORT $LL4@GetCpuCoun@2

; 3000 : 	}
; 3001 : 
; 3002 : 	if (cpuCount == 0)

  00017	85 d2		 test	 edx, edx
  00019	75 04		 jne	 SHORT $LN1@GetCpuCoun@2

; 3003 : 		return 1;

  0001b	33 c0		 xor	 eax, eax
  0001d	40		 inc	 eax

; 3006 : }

  0001e	c3		 ret	 0
$LN1@GetCpuCoun@2:

; 3004 : 
; 3005 : 	return cpuCount;

  0001f	8b c2		 mov	 eax, edx

; 3006 : }

  00021	c3		 ret	 0
_GetCpuCount@0 ENDP
_TEXT	ENDS
PUBLIC	_EnsureNullTerminatedString@8
; Function compile flags: /Ogsp
;	COMDAT _EnsureNullTerminatedString@8
_TEXT	SEGMENT
_str$ = 8						; size = 4
_maxSizeInBytes$ = 12					; size = 4
_EnsureNullTerminatedString@8 PROC			; COMDAT

; 3010 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 3011 : 	ASSERT ((maxSizeInBytes & 1) == 0);
; 3012 : 	str[maxSizeInBytes / sizeof (wchar_t) - 1] = 0;

  00005	8b 45 0c	 mov	 eax, DWORD PTR _maxSizeInBytes$[ebp]
  00008	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  0000b	d1 e8		 shr	 eax, 1
  0000d	33 c9		 xor	 ecx, ecx
  0000f	66 89 4c 42 fe	 mov	 WORD PTR [edx+eax*2-2], cx

; 3013 : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
_EnsureNullTerminatedString@8 ENDP
_TEXT	ENDS
PUBLIC	_AllocateMemoryWithTimeout@12
EXTRN	__imp__KeDelayExecutionThread@12:PROC
; Function compile flags: /Ogsp
;	COMDAT _AllocateMemoryWithTimeout@12
_TEXT	SEGMENT
_waitInterval$ = -8					; size = 8
_size$ = 8						; size = 4
_retryDelay$ = 12					; size = 4
_timeout$ = 16						; size = 4
_AllocateMemoryWithTimeout@12 PROC			; COMDAT

; 3017 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	51		 push	 ecx

; 3018 : 	LARGE_INTEGER waitInterval;
; 3019 : 	waitInterval.QuadPart = retryDelay * -10000;

  00007	8b 45 0c	 mov	 eax, DWORD PTR _retryDelay$[ebp]
  0000a	69 c0 f0 d8 ff
	ff		 imul	 eax, -10000		; ffffd8f0H
  00010	56		 push	 esi

; 3020 : 
; 3021 : 	ASSERT (KeGetCurrentIrql() <= APC_LEVEL);
; 3022 : 	ASSERT (retryDelay > 0 && retryDelay <= timeout);
; 3023 : 
; 3024 : 	while (TRUE)
; 3025 : 	{
; 3026 : 		void *memory = TCalloc (size);

  00011	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__ExAllocatePoolWithTag@12
  00017	99		 cdq
  00018	57		 push	 edi
  00019	89 45 f8	 mov	 DWORD PTR _waitInterval$[ebp], eax
  0001c	89 55 fc	 mov	 DWORD PTR _waitInterval$[ebp+4], edx
  0001f	bf 54 43 4d 4d	 mov	 edi, 1296909140		; 4d4d4354H
  00024	eb 1b		 jmp	 SHORT $LN13@AllocateMe
$LL4@AllocateMe:

; 3029 : 
; 3030 : 		timeout -= retryDelay;

  00026	8b 45 10	 mov	 eax, DWORD PTR _timeout$[ebp]
  00029	2b 45 0c	 sub	 eax, DWORD PTR _retryDelay$[ebp]
  0002c	89 45 10	 mov	 DWORD PTR _timeout$[ebp], eax

; 3031 : 		if (timeout <= 0)

  0002f	85 c0		 test	 eax, eax
  00031	7e 1c		 jle	 SHORT $LN10@AllocateMe

; 3032 : 			break;
; 3033 : 
; 3034 : 		KeDelayExecutionThread (KernelMode, FALSE, &waitInterval);

  00033	8d 45 f8	 lea	 eax, DWORD PTR _waitInterval$[ebp]
  00036	50		 push	 eax
  00037	6a 00		 push	 0
  00039	6a 00		 push	 0
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeDelayExecutionThread@12
$LN13@AllocateMe:
  00041	57		 push	 edi
  00042	ff 75 08	 push	 DWORD PTR _size$[ebp]
  00045	6a 00		 push	 0
  00047	ff d6		 call	 esi
  00049	85 c0		 test	 eax, eax
  0004b	74 d9		 je	 SHORT $LL4@AllocateMe

; 3027 : 		if (memory)
; 3028 : 			return memory;

  0004d	eb 02		 jmp	 SHORT $LN5@AllocateMe
$LN10@AllocateMe:

; 3035 : 	}
; 3036 : 
; 3037 : 	return NULL;

  0004f	33 c0		 xor	 eax, eax
$LN5@AllocateMe:
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi

; 3038 : }

  00053	c9		 leave
  00054	c2 0c 00	 ret	 12			; 0000000cH
_AllocateMemoryWithTimeout@12 ENDP
_TEXT	ENDS
PUBLIC	_TCReadRegistryKey@12
EXTRN	__imp__ZwQueryValueKey@24:PROC
EXTRN	__imp__ZwOpenKey@12:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCReadRegistryKey@12
_TEXT	SEGMENT
_regObjAttribs$ = -40					; size = 24
_valName$ = -16						; size = 8
_resultSize$ = -8					; size = 4
_size$ = -4						; size = 4
_regKeyHandle$ = 8					; size = 4
_keyPath$ = 8						; size = 4
_keyValueName$ = 12					; size = 4
_keyData$ = 16						; size = 4
_TCReadRegistryKey@12 PROC				; COMDAT

; 3042 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 28	 sub	 esp, 40			; 00000028H

; 3043 : 	OBJECT_ATTRIBUTES regObjAttribs;
; 3044 : 	HANDLE regKeyHandle;
; 3045 : 	NTSTATUS status;
; 3046 : 	UNICODE_STRING valName;
; 3047 : 	ULONG size = 0;
; 3048 : 	ULONG resultSize;
; 3049 : 
; 3050 : 	InitializeObjectAttributes (&regObjAttribs, keyPath, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

  00008	8b 45 08	 mov	 eax, DWORD PTR _keyPath$[ebp]
  0000b	57		 push	 edi
  0000c	89 45 e0	 mov	 DWORD PTR _regObjAttribs$[ebp+8], eax

; 3051 : 	status = ZwOpenKey (&regKeyHandle, KEY_READ, &regObjAttribs);

  0000f	8d 45 d8	 lea	 eax, DWORD PTR _regObjAttribs$[ebp]
  00012	50		 push	 eax
  00013	33 ff		 xor	 edi, edi
  00015	68 19 00 02 00	 push	 131097			; 00020019H
  0001a	8d 45 08	 lea	 eax, DWORD PTR _regKeyHandle$[ebp]
  0001d	50		 push	 eax
  0001e	89 7d fc	 mov	 DWORD PTR _size$[ebp], edi
  00021	c7 45 d8 18 00
	00 00		 mov	 DWORD PTR _regObjAttribs$[ebp], 24 ; 00000018H
  00028	89 7d dc	 mov	 DWORD PTR _regObjAttribs$[ebp+4], edi
  0002b	c7 45 e4 40 02
	00 00		 mov	 DWORD PTR _regObjAttribs$[ebp+12], 576 ; 00000240H
  00032	89 7d e8	 mov	 DWORD PTR _regObjAttribs$[ebp+16], edi
  00035	89 7d ec	 mov	 DWORD PTR _regObjAttribs$[ebp+20], edi
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwOpenKey@12

; 3052 : 	if (!NT_SUCCESS (status))

  0003e	3b c7		 cmp	 eax, edi

; 3053 : 		return status;

  00040	7c 45		 jl	 SHORT $LN5@TCReadRegi
  00042	56		 push	 esi

; 3054 : 
; 3055 : 	RtlInitUnicodeString (&valName, keyValueName);

  00043	ff 75 0c	 push	 DWORD PTR _keyValueName$[ebp]
  00046	8d 45 f0	 lea	 eax, DWORD PTR _valName$[ebp]
  00049	50		 push	 eax
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 3056 : 	status = ZwQueryValueKey (regKeyHandle, &valName, KeyValuePartialInformation, NULL, 0, &size);

  00050	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__ZwQueryValueKey@24
  00056	8d 45 fc	 lea	 eax, DWORD PTR _size$[ebp]
  00059	50		 push	 eax
  0005a	57		 push	 edi
  0005b	57		 push	 edi
  0005c	6a 02		 push	 2
  0005e	8d 45 f0	 lea	 eax, DWORD PTR _valName$[ebp]
  00061	50		 push	 eax
  00062	ff 75 08	 push	 DWORD PTR _regKeyHandle$[ebp]
  00065	ff d6		 call	 esi

; 3057 : 		
; 3058 : 	if (!NT_SUCCESS (status) && status != STATUS_BUFFER_OVERFLOW && status != STATUS_BUFFER_TOO_SMALL)

  00067	3b c7		 cmp	 eax, edi
  00069	7d 21		 jge	 SHORT $LN3@TCReadRegi
  0006b	3d 05 00 00 80	 cmp	 eax, -2147483643	; 80000005H
  00070	74 1a		 je	 SHORT $LN3@TCReadRegi
  00072	3d 23 00 00 c0	 cmp	 eax, -1073741789	; c0000023H
  00077	74 13		 je	 SHORT $LN3@TCReadRegi
$LN9@TCReadRegi:
  00079	8b f0		 mov	 esi, eax
$LN7@TCReadRegi:

; 3059 : 	{
; 3060 : 		ZwClose (regKeyHandle);

  0007b	ff 75 08	 push	 DWORD PTR _regKeyHandle$[ebp]
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 3061 : 		return status;

  00084	8b c6		 mov	 eax, esi
  00086	5e		 pop	 esi
$LN5@TCReadRegi:
  00087	5f		 pop	 edi

; 3078 : 
; 3079 : 	ZwClose (regKeyHandle);
; 3080 : 	return status;
; 3081 : }

  00088	c9		 leave
  00089	c2 0c 00	 ret	 12			; 0000000cH
$LN3@TCReadRegi:

; 3062 : 	}
; 3063 : 
; 3064 : 	if (size == 0)

  0008c	39 7d fc	 cmp	 DWORD PTR _size$[ebp], edi
  0008f	75 07		 jne	 SHORT $LN2@TCReadRegi
  00091	be 22 00 00 80	 mov	 esi, -2147483614	; 80000022H
  00096	eb e3		 jmp	 SHORT $LN7@TCReadRegi
$LN2@TCReadRegi:

; 3065 : 	{
; 3066 : 		ZwClose (regKeyHandle);
; 3067 : 		return STATUS_NO_DATA_DETECTED;
; 3068 : 	}
; 3069 : 
; 3070 : 	*keyData = (PKEY_VALUE_PARTIAL_INFORMATION) TCalloc (size);

  00098	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0009d	ff 75 fc	 push	 DWORD PTR _size$[ebp]
  000a0	57		 push	 edi
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  000a7	8b 4d 10	 mov	 ecx, DWORD PTR _keyData$[ebp]
  000aa	89 01		 mov	 DWORD PTR [ecx], eax

; 3071 : 	if (!*keyData)

  000ac	3b c7		 cmp	 eax, edi
  000ae	75 07		 jne	 SHORT $LN1@TCReadRegi
  000b0	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH
  000b5	eb c4		 jmp	 SHORT $LN7@TCReadRegi
$LN1@TCReadRegi:

; 3072 : 	{
; 3073 : 		ZwClose (regKeyHandle);
; 3074 : 		return STATUS_INSUFFICIENT_RESOURCES;
; 3075 : 	}
; 3076 : 
; 3077 : 	status = ZwQueryValueKey (regKeyHandle, &valName, KeyValuePartialInformation, *keyData, size, &resultSize);

  000b7	8d 4d f8	 lea	 ecx, DWORD PTR _resultSize$[ebp]
  000ba	51		 push	 ecx
  000bb	ff 75 fc	 push	 DWORD PTR _size$[ebp]
  000be	50		 push	 eax
  000bf	6a 02		 push	 2
  000c1	8d 45 f0	 lea	 eax, DWORD PTR _valName$[ebp]
  000c4	50		 push	 eax
  000c5	ff 75 08	 push	 DWORD PTR _regKeyHandle$[ebp]
  000c8	ff d6		 call	 esi
  000ca	eb ad		 jmp	 SHORT $LN9@TCReadRegi
_TCReadRegistryKey@12 ENDP
_TEXT	ENDS
PUBLIC	_TCWriteRegistryKey@20
EXTRN	__imp__ZwSetValueKey@24:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCWriteRegistryKey@20
_TEXT	SEGMENT
_regObjAttribs$ = -32					; size = 24
_valName$ = -8						; size = 8
_regKeyHandle$ = 8					; size = 4
_keyPath$ = 8						; size = 4
_keyValueName$ = 12					; size = 4
_keyValueType$ = 16					; size = 4
_valueData$ = 20					; size = 4
_valueSize$ = 24					; size = 4
_TCWriteRegistryKey@20 PROC				; COMDAT

; 3085 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 20	 sub	 esp, 32			; 00000020H

; 3086 : 	OBJECT_ATTRIBUTES regObjAttribs;
; 3087 : 	HANDLE regKeyHandle;
; 3088 : 	NTSTATUS status;
; 3089 : 	UNICODE_STRING valName;
; 3090 : 
; 3091 : 	InitializeObjectAttributes (&regObjAttribs, keyPath, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

  00008	8b 45 08	 mov	 eax, DWORD PTR _keyPath$[ebp]
  0000b	56		 push	 esi
  0000c	89 45 e8	 mov	 DWORD PTR _regObjAttribs$[ebp+8], eax

; 3092 : 	status = ZwOpenKey (&regKeyHandle, KEY_READ | KEY_WRITE, &regObjAttribs);

  0000f	8d 45 e0	 lea	 eax, DWORD PTR _regObjAttribs$[ebp]
  00012	50		 push	 eax
  00013	33 f6		 xor	 esi, esi
  00015	68 1f 00 02 00	 push	 131103			; 0002001fH
  0001a	8d 45 08	 lea	 eax, DWORD PTR _regKeyHandle$[ebp]
  0001d	50		 push	 eax
  0001e	c7 45 e0 18 00
	00 00		 mov	 DWORD PTR _regObjAttribs$[ebp], 24 ; 00000018H
  00025	89 75 e4	 mov	 DWORD PTR _regObjAttribs$[ebp+4], esi
  00028	c7 45 ec 40 02
	00 00		 mov	 DWORD PTR _regObjAttribs$[ebp+12], 576 ; 00000240H
  0002f	89 75 f0	 mov	 DWORD PTR _regObjAttribs$[ebp+16], esi
  00032	89 75 f4	 mov	 DWORD PTR _regObjAttribs$[ebp+20], esi
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwOpenKey@12

; 3093 : 	if (!NT_SUCCESS (status))

  0003b	3b c6		 cmp	 eax, esi

; 3094 : 		return status;

  0003d	7c 31		 jl	 SHORT $LN2@TCWriteReg

; 3095 : 
; 3096 : 	RtlInitUnicodeString (&valName, keyValueName);

  0003f	ff 75 0c	 push	 DWORD PTR _keyValueName$[ebp]
  00042	8d 45 f8	 lea	 eax, DWORD PTR _valName$[ebp]
  00045	50		 push	 eax
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 3097 : 
; 3098 : 	status = ZwSetValueKey (regKeyHandle, &valName, 0, keyValueType, valueData, valueSize);

  0004c	ff 75 18	 push	 DWORD PTR _valueSize$[ebp]
  0004f	8d 45 f8	 lea	 eax, DWORD PTR _valName$[ebp]
  00052	ff 75 14	 push	 DWORD PTR _valueData$[ebp]
  00055	ff 75 10	 push	 DWORD PTR _keyValueType$[ebp]
  00058	56		 push	 esi
  00059	50		 push	 eax
  0005a	ff 75 08	 push	 DWORD PTR _regKeyHandle$[ebp]
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwSetValueKey@24

; 3099 : 
; 3100 : 	ZwClose (regKeyHandle);

  00063	ff 75 08	 push	 DWORD PTR _regKeyHandle$[ebp]
  00066	8b f0		 mov	 esi, eax
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 3101 : 	return status;

  0006e	8b c6		 mov	 eax, esi
$LN2@TCWriteReg:
  00070	5e		 pop	 esi

; 3102 : }

  00071	c9		 leave
  00072	c2 14 00	 ret	 20			; 00000014H
_TCWriteRegistryKey@20 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BE@OBOIPPHP@?$AAt?$AAr?$AAu?$AAe?$AAc?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BK@FNJCPENK@?$AAU?$AAp?$AAp?$AAe?$AAr?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAs?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1MA@BNNNAGDA@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_IsVolumeClassFilterRegistered@0
;	COMDAT ??_C@_1BE@OBOIPPHP@?$AAt?$AAr?$AAu?$AAe?$AAc?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BE@OBOIPPHP@?$AAt?$AAr?$AAu?$AAe?$AAc?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ DB 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 'c', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BK@FNJCPENK@?$AAU?$AAp?$AAp?$AAe?$AAr?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAs?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BK@FNJCPENK@?$AAU?$AAp?$AAp?$AAe?$AAr?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAs?$AA?$AA@FNODOBFM@ DB 'U'
	DB	00H, 'p', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'F', 00H, 'i', 00H
	DB	'l', 00H, 't', 00H, 'e', 00H, 'r', 00H, 's', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1MA@BNNNAGDA@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
text$s	SEGMENT
??_C@_1MA@BNNNAGDA@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@ DB '\'
	DB	00H, 'R', 00H, 'E', 00H, 'G', 00H, 'I', 00H, 'S', 00H, 'T', 00H
	DB	'R', 00H, 'Y', 00H, '\', 00H, 'M', 00H, 'A', 00H, 'C', 00H, 'H'
	DB	00H, 'I', 00H, 'N', 00H, 'E', 00H, '\', 00H, 'S', 00H, 'Y', 00H
	DB	'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '\', 00H, 'C', 00H, 'u'
	DB	00H, 'r', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'C', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, 'r', 00H, 'o', 00H, 'l', 00H, 'S'
	DB	00H, 'e', 00H, 't', 00H, '\', 00H, 'C', 00H, 'o', 00H, 'n', 00H
	DB	't', 00H, 'r', 00H, 'o', 00H, 'l', 00H, '\', 00H, 'C', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, '\', 00H, '{', 00H, '7', 00H
	DB	'1', 00H, 'A', 00H, '2', 00H, '7', 00H, 'C', 00H, 'D', 00H, 'D'
	DB	00H, '-', 00H, '8', 00H, '1', 00H, '2', 00H, 'A', 00H, '-', 00H
	DB	'1', 00H, '1', 00H, 'D', 00H, '0', 00H, '-', 00H, 'B', 00H, 'E'
	DB	00H, 'C', 00H, '7', 00H, '-', 00H, '0', 00H, '8', 00H, '0', 00H
	DB	'0', 00H, '2', 00H, 'B', 00H, 'E', 00H, '2', 00H, '0', 00H, '9'
	DB	00H, '2', 00H, 'F', 00H, '}', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
text$s	ENDS
;	COMDAT _IsVolumeClassFilterRegistered@0
_TEXT	SEGMENT
_name$ = -16						; size = 8
_data$ = -8						; size = 4
_registered$ = -4					; size = 4
_IsVolumeClassFilterRegistered@0 PROC			; COMDAT

; 3106 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 10	 sub	 esp, 16			; 00000010H

; 3107 : 	UNICODE_STRING name;
; 3108 : 	NTSTATUS status;
; 3109 : 	BOOL registered = FALSE;

  00008	83 65 fc 00	 and	 DWORD PTR _registered$[ebp], 0

; 3110 : 
; 3111 : 	PKEY_VALUE_PARTIAL_INFORMATION data;
; 3112 : 
; 3113 : 	/*
; 3114 : 	 * Note: Do not change the "Storage Volumes" guid (System-Defined Device Setup Classes).
; 3115 : 	 * This class includes storage volumes as defined by the system-supplied
; 3116 : 	 * logical volume manager and class drivers that create device objects to
; 3117 : 	 * represent storage volumes, such as the system disk class driver.
; 3118 : 	 * @see	http://msdn.microsoft.com/en-us/library/windows/hardware/ff553426%28v=vs.85%29.aspx
; 3119 : 	 */
; 3120 : 	RtlInitUnicodeString (&name, L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class\\{71A27CDD-812A-11D0-BEC7-08002BE2092F}");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_1MA@BNNNAGDA@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
  00011	8d 45 f0	 lea	 eax, DWORD PTR _name$[ebp]
  00014	50		 push	 eax
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 3121 : 	status = TCReadRegistryKey (&name, L"UpperFilters", &data);

  0001b	8d 45 f8	 lea	 eax, DWORD PTR _data$[ebp]
  0001e	50		 push	 eax
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@FNJCPENK@?$AAU?$AAp?$AAp?$AAe?$AAr?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAs?$AA?$AA@FNODOBFM@
  00024	8d 45 f0	 lea	 eax, DWORD PTR _name$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _TCReadRegistryKey@12

; 3122 : 
; 3123 : 	if (NT_SUCCESS (status))

  0002d	85 c0		 test	 eax, eax
  0002f	7c 4a		 jl	 SHORT $LN6@IsVolumeCl

; 3124 : 	{
; 3125 : 		if (data->Type == REG_MULTI_SZ && data->DataLength >= 9 * sizeof (wchar_t))

  00031	8b 55 f8	 mov	 edx, DWORD PTR _data$[ebp]
  00034	83 7a 04 07	 cmp	 DWORD PTR [edx+4], 7
  00038	75 35		 jne	 SHORT $LN2@IsVolumeCl
  0003a	83 7a 08 12	 cmp	 DWORD PTR [edx+8], 18	; 00000012H
  0003e	72 2f		 jb	 SHORT $LN2@IsVolumeCl
  00040	53		 push	 ebx
  00041	56		 push	 esi

; 3126 : 		{
; 3127 : 			// Search for the string "truecrypt"
; 3128 : 			ULONG i;
; 3129 : 			for (i = 0; i <= data->DataLength - 9 * sizeof (wchar_t); ++i)

  00042	33 c0		 xor	 eax, eax
  00044	57		 push	 edi
$LL4@IsVolumeCl:

; 3130 : 			{
; 3131 : 				if (memcmp (data->Data + i, L"truecrypt", 9 * sizeof (wchar_t)) == 0)

  00045	6a 09		 push	 9
  00047	59		 pop	 ecx
  00048	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_1BE@OBOIPPHP@?$AAt?$AAr?$AAu?$AAe?$AAc?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
  0004d	8d 74 02 0c	 lea	 esi, DWORD PTR [edx+eax+12]
  00051	33 db		 xor	 ebx, ebx
  00053	66 f3 a7	 repe cmpsw
  00056	74 0d		 je	 SHORT $LN10@IsVolumeCl
  00058	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0005b	40		 inc	 eax
  0005c	83 c1 ee	 add	 ecx, -18		; ffffffeeH
  0005f	3b c1		 cmp	 eax, ecx
  00061	76 e2		 jbe	 SHORT $LL4@IsVolumeCl
  00063	eb 07		 jmp	 SHORT $LN13@IsVolumeCl
$LN10@IsVolumeCl:

; 3132 : 				{
; 3133 : 					Dump ("Volume class filter active\n");
; 3134 : 					registered = TRUE;

  00065	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _registered$[ebp], 1
$LN13@IsVolumeCl:
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
$LN2@IsVolumeCl:

; 3135 : 					break;
; 3136 : 				}
; 3137 : 			}
; 3138 : 		}
; 3139 : 
; 3140 : 		TCfree (data);

  0006f	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00074	52		 push	 edx
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN6@IsVolumeCl:

; 3141 : 	}
; 3142 : 
; 3143 : 	return registered;

  0007b	8b 45 fc	 mov	 eax, DWORD PTR _registered$[ebp]

; 3144 : }

  0007e	c9		 leave
  0007f	c3		 ret	 0
_IsVolumeClassFilterRegistered@0 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EA@CEOJFLPD@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAE?$AAn?$AAc?$AAr?$AAy?$AAp?$AAt?$AAi?$AAo?$AAn?$AAF?$AAr?$AAe?$AAe?$AAC?$AAp?$AAu?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CA@LGEHFLCO@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1HM@GLBNDPGI@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_ReadRegistryConfigFlags@4
EXTRN	_EnableHwEncryption@4:PROC
;	COMDAT ??_C@_1EA@CEOJFLPD@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAE?$AAn?$AAc?$AAr?$AAy?$AAp?$AAt?$AAi?$AAo?$AAn?$AAF?$AAr?$AAe?$AAe?$AAC?$AAp?$AAu?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1EA@CEOJFLPD@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAE?$AAn?$AAc?$AAr?$AAy?$AAp?$AAt?$AAi?$AAo?$AAn?$AAF?$AAr?$AAe?$AAe?$AAC?$AAp?$AAu?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, 'E', 00H, 'n', 00H, 'c', 00H, 'r', 00H, 'y'
	DB	00H, 'p', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'F', 00H
	DB	'r', 00H, 'e', 00H, 'e', 00H, 'C', 00H, 'p', 00H, 'u', 00H, 'C'
	DB	00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CA@LGEHFLCO@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CA@LGEHFLCO@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 'f', 00H, 'i'
	DB	00H, 'g', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1HM@GLBNDPGI@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
text$s	SEGMENT
??_C@_1HM@GLBNDPGI@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@ DB '\'
	DB	00H, 'R', 00H, 'E', 00H, 'G', 00H, 'I', 00H, 'S', 00H, 'T', 00H
	DB	'R', 00H, 'Y', 00H, '\', 00H, 'M', 00H, 'A', 00H, 'C', 00H, 'H'
	DB	00H, 'I', 00H, 'N', 00H, 'E', 00H, '\', 00H, 'S', 00H, 'Y', 00H
	DB	'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '\', 00H, 'C', 00H, 'u'
	DB	00H, 'r', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'C', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, 'r', 00H, 'o', 00H, 'l', 00H, 'S'
	DB	00H, 'e', 00H, 't', 00H, '\', 00H, 'S', 00H, 'e', 00H, 'r', 00H
	DB	'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 'c', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
text$s	ENDS
;	COMDAT _ReadRegistryConfigFlags@4
_TEXT	SEGMENT
_name$ = -16						; size = 8
_status$ = -8						; size = 4
_data$ = -4						; size = 4
_driverEntry$ = 8					; size = 4
_ReadRegistryConfigFlags@4 PROC				; COMDAT

; 3148 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 10	 sub	 esp, 16			; 00000010H
  00008	53		 push	 ebx
  00009	57		 push	 edi

; 3149 : 	PKEY_VALUE_PARTIAL_INFORMATION data;
; 3150 : 	UNICODE_STRING name;
; 3151 : 	NTSTATUS status;
; 3152 : 	uint32 flags = 0;
; 3153 : 
; 3154 : 	RtlInitUnicodeString (&name, L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\truecrypt");

  0000a	68 00 00 00 00	 push	 OFFSET ??_C@_1HM@GLBNDPGI@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
  0000f	8d 45 f0	 lea	 eax, DWORD PTR _name$[ebp]
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 3155 : 	status = TCReadRegistryKey (&name, TC_DRIVER_CONFIG_REG_VALUE_NAME, &data);

  00019	8d 45 fc	 lea	 eax, DWORD PTR _data$[ebp]
  0001c	50		 push	 eax
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_1CA@LGEHFLCO@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@
  00022	8d 45 f0	 lea	 eax, DWORD PTR _name$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _TCReadRegistryKey@12

; 3156 : 
; 3157 : 	if (NT_SUCCESS (status))

  0002b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__ExFreePoolWithTag@8
  00031	89 45 f8	 mov	 DWORD PTR _status$[ebp], eax
  00034	bb 54 43 4d 4d	 mov	 ebx, 1296909140		; 4d4d4354H
  00039	85 c0		 test	 eax, eax
  0003b	7c 45		 jl	 SHORT $LN8@ReadRegist
  0003d	56		 push	 esi

; 3158 : 	{
; 3159 : 		if (data->Type == REG_DWORD)

  0003e	8b 75 fc	 mov	 esi, DWORD PTR _data$[ebp]
  00041	83 7e 04 04	 cmp	 DWORD PTR [esi+4], 4
  00045	75 2f		 jne	 SHORT $LN7@ReadRegist

; 3160 : 		{
; 3161 : 			flags = *(uint32 *) data->Data;

  00047	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]

; 3162 : 			Dump ("Configuration flags = 0x%x\n", flags);
; 3163 : 
; 3164 : 			if (driverEntry)

  0004a	33 c9		 xor	 ecx, ecx
  0004c	41		 inc	 ecx
  0004d	83 7d 08 00	 cmp	 DWORD PTR _driverEntry$[ebp], 0
  00051	74 14		 je	 SHORT $LN4@ReadRegist

; 3165 : 			{
; 3166 : 				if (flags & (TC_DRIVER_CONFIG_CACHE_BOOT_PASSWORD | TC_DRIVER_CONFIG_CACHE_BOOT_PASSWORD_FOR_SYS_FAVORITES))

  00053	a8 03		 test	 al, 3
  00055	74 06		 je	 SHORT $LN5@ReadRegist

; 3167 : 					CacheBootPassword = TRUE;

  00057	89 0d 00 00 00
	00		 mov	 DWORD PTR _CacheBootPassword, ecx
$LN5@ReadRegist:

; 3168 : 
; 3169 : 				if (flags & TC_DRIVER_CONFIG_DISABLE_NONADMIN_SYS_FAVORITES_ACCESS)

  0005d	a8 04		 test	 al, 4
  0005f	74 06		 je	 SHORT $LN4@ReadRegist

; 3170 : 					NonAdminSystemFavoritesAccessDisabled = TRUE;

  00061	89 0d 00 00 00
	00		 mov	 DWORD PTR _NonAdminSystemFavoritesAccessDisabled, ecx
$LN4@ReadRegist:

; 3171 : 			}
; 3172 : 
; 3173 : 			EnableHwEncryption ((flags & TC_DRIVER_CONFIG_DISABLE_HARDWARE_ENCRYPTION) ? FALSE : TRUE);

  00067	c1 e8 03	 shr	 eax, 3
  0006a	f7 d0		 not	 eax
  0006c	23 c1		 and	 eax, ecx
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _EnableHwEncryption@4

; 3174 : 		}
; 3175 : 		else

  00074	eb 07		 jmp	 SHORT $LN3@ReadRegist
$LN7@ReadRegist:

; 3176 : 			status = STATUS_INVALID_PARAMETER;

  00076	c7 45 f8 0d 00
	00 c0		 mov	 DWORD PTR _status$[ebp], -1073741811 ; c000000dH
$LN3@ReadRegist:

; 3177 : 
; 3178 : 		TCfree (data);

  0007d	53		 push	 ebx
  0007e	56		 push	 esi
  0007f	ff d7		 call	 edi
  00081	5e		 pop	 esi
$LN8@ReadRegist:

; 3179 : 	}
; 3180 : 
; 3181 : 	if (driverEntry && NT_SUCCESS (TCReadRegistryKey (&name, TC_ENCRYPTION_FREE_CPU_COUNT_REG_VALUE_NAME, &data)))

  00082	83 7d 08 00	 cmp	 DWORD PTR _driverEntry$[ebp], 0
  00086	74 2c		 je	 SHORT $LN11@ReadRegist
  00088	8d 45 fc	 lea	 eax, DWORD PTR _data$[ebp]
  0008b	50		 push	 eax
  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_1EA@CEOJFLPD@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAE?$AAn?$AAc?$AAr?$AAy?$AAp?$AAt?$AAi?$AAo?$AAn?$AAF?$AAr?$AAe?$AAe?$AAC?$AAp?$AAu?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@FNODOBFM@
  00091	8d 45 f0	 lea	 eax, DWORD PTR _name$[ebp]
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 _TCReadRegistryKey@12
  0009a	85 c0		 test	 eax, eax
  0009c	7c 16		 jl	 SHORT $LN11@ReadRegist

; 3182 : 	{
; 3183 : 		if (data->Type == REG_DWORD)

  0009e	8b 45 fc	 mov	 eax, DWORD PTR _data$[ebp]
  000a1	83 78 04 04	 cmp	 DWORD PTR [eax+4], 4
  000a5	75 09		 jne	 SHORT $LN1@ReadRegist

; 3184 : 			EncryptionThreadPoolFreeCpuCountLimit = *(uint32 *) data->Data;

  000a7	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000aa	89 0d 00 00 00
	00		 mov	 DWORD PTR _EncryptionThreadPoolFreeCpuCountLimit, ecx
$LN1@ReadRegist:

; 3185 : 
; 3186 : 		TCfree (data);

  000b0	53		 push	 ebx
  000b1	50		 push	 eax
  000b2	ff d7		 call	 edi
$LN11@ReadRegist:

; 3187 : 	}
; 3188 : 
; 3189 : 	return status;

  000b4	8b 45 f8	 mov	 eax, DWORD PTR _status$[ebp]
  000b7	5f		 pop	 edi
  000b8	5b		 pop	 ebx

; 3190 : }

  000b9	c9		 leave
  000ba	c2 04 00	 ret	 4
_ReadRegistryConfigFlags@4 ENDP
_TEXT	ENDS
PUBLIC	_WriteRegistryConfigFlags@4
; Function compile flags: /Ogsp
;	COMDAT _WriteRegistryConfigFlags@4
_TEXT	SEGMENT
_name$ = -8						; size = 8
_flags$ = 8						; size = 4
_WriteRegistryConfigFlags@4 PROC			; COMDAT

; 3194 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	51		 push	 ecx

; 3195 : 	UNICODE_STRING name;
; 3196 : 	RtlInitUnicodeString (&name, L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\truecrypt");

  00007	68 00 00 00 00	 push	 OFFSET ??_C@_1HM@GLBNDPGI@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
  0000c	8d 45 f8	 lea	 eax, DWORD PTR _name$[ebp]
  0000f	50		 push	 eax
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 3197 : 
; 3198 : 	return TCWriteRegistryKey (&name, TC_DRIVER_CONFIG_REG_VALUE_NAME, REG_DWORD, &flags, sizeof (flags));

  00016	6a 04		 push	 4
  00018	8d 45 08	 lea	 eax, DWORD PTR _flags$[ebp]
  0001b	50		 push	 eax
  0001c	6a 04		 push	 4
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_1CA@LGEHFLCO@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@
  00023	8d 45 f8	 lea	 eax, DWORD PTR _name$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 _TCWriteRegistryKey@20

; 3199 : }

  0002c	c9		 leave
  0002d	c2 04 00	 ret	 4
_WriteRegistryConfigFlags@4 ENDP
_TEXT	ENDS
PUBLIC	_GetDeviceSectorSize@8
; Function compile flags: /Ogsp
;	COMDAT _GetDeviceSectorSize@8
_TEXT	SEGMENT
_geometry$ = -24					; size = 24
_deviceObject$ = 8					; size = 4
_bytesPerSector$ = 12					; size = 4
_GetDeviceSectorSize@8 PROC				; COMDAT

; 3203 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 18	 sub	 esp, 24			; 00000018H

; 3204 : 	NTSTATUS status;
; 3205 : 	DISK_GEOMETRY geometry;
; 3206 : 
; 3207 : 	status = SendDeviceIoControlRequest (deviceObject, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &geometry, sizeof (geometry));

  00008	6a 18		 push	 24			; 00000018H
  0000a	8d 45 e8	 lea	 eax, DWORD PTR _geometry$[ebp]
  0000d	50		 push	 eax
  0000e	6a 00		 push	 0
  00010	6a 00		 push	 0
  00012	68 00 00 07 00	 push	 458752			; 00070000H
  00017	ff 75 08	 push	 DWORD PTR _deviceObject$[ebp]
  0001a	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24

; 3208 : 
; 3209 : 	if (!NT_SUCCESS (status))

  0001f	85 c0		 test	 eax, eax

; 3210 : 		return status;

  00021	7c 0a		 jl	 SHORT $LN2@GetDeviceS

; 3211 : 
; 3212 : 	*bytesPerSector = geometry.BytesPerSector;

  00023	8b 45 0c	 mov	 eax, DWORD PTR _bytesPerSector$[ebp]
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _geometry$[ebp+20]
  00029	89 08		 mov	 DWORD PTR [eax], ecx

; 3213 : 	return STATUS_SUCCESS;

  0002b	33 c0		 xor	 eax, eax
$LN2@GetDeviceS:

; 3214 : }

  0002d	c9		 leave
  0002e	c2 08 00	 ret	 8
_GetDeviceSectorSize@8 ENDP
_TEXT	ENDS
PUBLIC	_ZeroUnreadableSectors@20
; Function compile flags: /Ogsp
;	COMDAT _ZeroUnreadableSectors@20
_TEXT	SEGMENT
_status$ = -4						; size = 4
_deviceObject$ = 8					; size = 4
_startOffset$ = 12					; size = 8
_sectorCount$ = 20					; size = 4
_size$ = 20						; size = 4
_sectorSize$ = 24					; size = 4
_sectorBuffer$ = 24					; size = 4
_zeroedSectorCount$ = 24				; size = 4
_ZeroUnreadableSectors@20 PROC				; COMDAT

; 3218 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 3219 : 	NTSTATUS status;
; 3220 : 	ULONG sectorSize;
; 3221 : 	ULONG sectorCount;
; 3222 : 	byte *sectorBuffer = NULL;
; 3223 : 
; 3224 : 	*zeroedSectorCount = 0;

  00008	8b 75 18	 mov	 esi, DWORD PTR _zeroedSectorCount$[ebp]

; 3225 : 
; 3226 : 	status = GetDeviceSectorSize (deviceObject, &sectorSize);

  0000b	8d 45 18	 lea	 eax, DWORD PTR _sectorSize$[ebp]
  0000e	50		 push	 eax
  0000f	ff 75 08	 push	 DWORD PTR _deviceObject$[ebp]
  00012	33 db		 xor	 ebx, ebx
  00014	89 1e		 mov	 DWORD PTR [esi], ebx
  00016	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  00019	e8 00 00 00 00	 call	 _GetDeviceSectorSize@8

; 3227 : 	if (!NT_SUCCESS (status))

  0001e	3b c3		 cmp	 eax, ebx

; 3228 : 		return status;

  00020	0f 8c 92 00 00
	00		 jl	 $LN9@ZeroUnread
  00026	57		 push	 edi

; 3229 : 
; 3230 : 	sectorBuffer = TCalloc (sectorSize);

  00027	8b 7d 18	 mov	 edi, DWORD PTR _sectorSize$[ebp]
  0002a	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0002f	57		 push	 edi
  00030	53		 push	 ebx
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00037	89 45 18	 mov	 DWORD PTR _sectorBuffer$[ebp], eax

; 3231 : 	if (!sectorBuffer)

  0003a	3b c3		 cmp	 eax, ebx
  0003c	75 07		 jne	 SHORT $LN7@ZeroUnread

; 3232 : 		return STATUS_INSUFFICIENT_RESOURCES;

  0003e	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  00043	eb 72		 jmp	 SHORT $LN16@ZeroUnread
$LN7@ZeroUnread:

; 3233 : 
; 3234 : 	for (sectorCount = size / sectorSize; sectorCount > 0; --sectorCount, startOffset.QuadPart += sectorSize)

  00045	8b 45 14	 mov	 eax, DWORD PTR _size$[ebp]
  00048	33 d2		 xor	 edx, edx
  0004a	f7 f7		 div	 edi
  0004c	89 45 14	 mov	 DWORD PTR _sectorCount$[ebp], eax
  0004f	3b c3		 cmp	 eax, ebx
  00051	76 50		 jbe	 SHORT $LN4@ZeroUnread
$LL14@ZeroUnread:

; 3235 : 	{
; 3236 : 		status = TCReadDevice (deviceObject, sectorBuffer, startOffset, sectorSize);

  00053	57		 push	 edi
  00054	ff 75 10	 push	 DWORD PTR _startOffset$[ebp+4]
  00057	ff 75 0c	 push	 DWORD PTR _startOffset$[ebp]
  0005a	ff 75 18	 push	 DWORD PTR _sectorBuffer$[ebp]
  0005d	ff 75 08	 push	 DWORD PTR _deviceObject$[ebp]
  00060	e8 00 00 00 00	 call	 _TCReadDevice@20

; 3237 : 		if (!NT_SUCCESS (status))

  00065	85 c0		 test	 eax, eax
  00067	7d 2c		 jge	 SHORT $LN5@ZeroUnread

; 3238 : 		{
; 3239 : 			Dump ("Zeroing sector at %I64d\n", startOffset.QuadPart);
; 3240 : 			memset (sectorBuffer, 0, sectorSize);

  00069	57		 push	 edi
  0006a	53		 push	 ebx
  0006b	ff 75 18	 push	 DWORD PTR _sectorBuffer$[ebp]
  0006e	e8 00 00 00 00	 call	 _memset
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3241 : 
; 3242 : 			status = TCWriteDevice (deviceObject, sectorBuffer, startOffset, sectorSize);

  00076	57		 push	 edi
  00077	ff 75 10	 push	 DWORD PTR _startOffset$[ebp+4]
  0007a	ff 75 0c	 push	 DWORD PTR _startOffset$[ebp]
  0007d	ff 75 18	 push	 DWORD PTR _sectorBuffer$[ebp]
  00080	ff 75 08	 push	 DWORD PTR _deviceObject$[ebp]
  00083	e8 00 00 00 00	 call	 _TCWriteDevice@20

; 3243 : 			if (!NT_SUCCESS (status))

  00088	3b c3		 cmp	 eax, ebx
  0008a	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax
  0008d	7c 17		 jl	 SHORT $err$31324

; 3244 : 				goto err;
; 3245 : 
; 3246 : 			++(*zeroedSectorCount);

  0008f	83 06 01	 add	 DWORD PTR [esi], 1
  00092	11 5e 04	 adc	 DWORD PTR [esi+4], ebx
$LN5@ZeroUnread:
  00095	ff 4d 14	 dec	 DWORD PTR _sectorCount$[ebp]
  00098	01 7d 0c	 add	 DWORD PTR _startOffset$[ebp], edi
  0009b	11 5d 10	 adc	 DWORD PTR _startOffset$[ebp+4], ebx
  0009e	39 5d 14	 cmp	 DWORD PTR _sectorCount$[ebp], ebx
  000a1	77 b0		 ja	 SHORT $LL14@ZeroUnread
$LN4@ZeroUnread:

; 3247 : 		}
; 3248 : 	}
; 3249 : 
; 3250 : 	status = STATUS_SUCCESS;

  000a3	89 5d fc	 mov	 DWORD PTR _status$[ebp], ebx
$err$31324:

; 3251 : 
; 3252 : err:
; 3253 : 	if (sectorBuffer)
; 3254 : 		TCfree (sectorBuffer);

  000a6	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  000ab	ff 75 18	 push	 DWORD PTR _sectorBuffer$[ebp]
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 3255 : 
; 3256 : 	return status;

  000b4	8b 45 fc	 mov	 eax, DWORD PTR _status$[ebp]
$LN16@ZeroUnread:
  000b7	5f		 pop	 edi
$LN9@ZeroUnread:
  000b8	5e		 pop	 esi
  000b9	5b		 pop	 ebx

; 3257 : }

  000ba	c9		 leave
  000bb	c2 14 00	 ret	 20			; 00000014H
_ZeroUnreadableSectors@20 ENDP
_TEXT	ENDS
PUBLIC	_ReadDeviceSkipUnreadableSectors@24
; Function compile flags: /Ogsp
;	COMDAT _ReadDeviceSkipUnreadableSectors@24
_TEXT	SEGMENT
_deviceObject$ = 8					; size = 4
_buffer$ = 12						; size = 4
_startOffset$ = 16					; size = 8
_size$ = 24						; size = 4
_sectorCount$ = 28					; size = 4
_sectorSize$ = 28					; size = 4
_badSectorCount$ = 28					; size = 4
_ReadDeviceSkipUnreadableSectors@24 PROC		; COMDAT

; 3261 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	53		 push	 ebx
  00006	56		 push	 esi

; 3262 : 	NTSTATUS status;
; 3263 : 	ULONG sectorSize;
; 3264 : 	ULONG sectorCount;
; 3265 : 
; 3266 : 	*badSectorCount = 0;

  00007	8b 75 1c	 mov	 esi, DWORD PTR _badSectorCount$[ebp]

; 3267 : 
; 3268 : 	status = GetDeviceSectorSize (deviceObject, &sectorSize);

  0000a	8d 45 1c	 lea	 eax, DWORD PTR _sectorSize$[ebp]
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR _deviceObject$[ebp]
  00011	33 db		 xor	 ebx, ebx
  00013	89 1e		 mov	 DWORD PTR [esi], ebx
  00015	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  00018	e8 00 00 00 00	 call	 _GetDeviceSectorSize@8

; 3269 : 	if (!NT_SUCCESS (status))

  0001d	3b c3		 cmp	 eax, ebx

; 3270 : 		return status;

  0001f	7c 52		 jl	 SHORT $LN6@ReadDevice

; 3271 : 
; 3272 : 	for (sectorCount = size / sectorSize; sectorCount > 0; --sectorCount, startOffset.QuadPart += sectorSize, buffer += sectorSize)

  00021	8b 45 18	 mov	 eax, DWORD PTR _size$[ebp]
  00024	57		 push	 edi
  00025	8b 7d 1c	 mov	 edi, DWORD PTR _sectorSize$[ebp]
  00028	33 d2		 xor	 edx, edx
  0002a	f7 f7		 div	 edi
  0002c	89 45 1c	 mov	 DWORD PTR _sectorCount$[ebp], eax
  0002f	3b c3		 cmp	 eax, ebx
  00031	76 3d		 jbe	 SHORT $LN2@ReadDevice
$LL4@ReadDevice:

; 3273 : 	{
; 3274 : 		status = TCReadDevice (deviceObject, buffer, startOffset, sectorSize);

  00033	57		 push	 edi
  00034	ff 75 14	 push	 DWORD PTR _startOffset$[ebp+4]
  00037	ff 75 10	 push	 DWORD PTR _startOffset$[ebp]
  0003a	ff 75 0c	 push	 DWORD PTR _buffer$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR _deviceObject$[ebp]
  00040	e8 00 00 00 00	 call	 _TCReadDevice@20

; 3275 : 		if (!NT_SUCCESS (status))

  00045	85 c0		 test	 eax, eax
  00047	7d 13		 jge	 SHORT $LN3@ReadDevice

; 3276 : 		{
; 3277 : 			Dump ("Skipping bad sector at %I64d\n", startOffset.QuadPart);
; 3278 : 			memset (buffer, 0, sectorSize);

  00049	57		 push	 edi
  0004a	53		 push	 ebx
  0004b	ff 75 0c	 push	 DWORD PTR _buffer$[ebp]
  0004e	e8 00 00 00 00	 call	 _memset
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3279 : 			++(*badSectorCount);

  00056	83 06 01	 add	 DWORD PTR [esi], 1
  00059	11 5e 04	 adc	 DWORD PTR [esi+4], ebx
$LN3@ReadDevice:
  0005c	ff 4d 1c	 dec	 DWORD PTR _sectorCount$[ebp]
  0005f	01 7d 10	 add	 DWORD PTR _startOffset$[ebp], edi
  00062	6a 00		 push	 0
  00064	58		 pop	 eax
  00065	11 45 14	 adc	 DWORD PTR _startOffset$[ebp+4], eax
  00068	01 7d 0c	 add	 DWORD PTR _buffer$[ebp], edi
  0006b	39 5d 1c	 cmp	 DWORD PTR _sectorCount$[ebp], ebx
  0006e	77 c3		 ja	 SHORT $LL4@ReadDevice
$LN2@ReadDevice:

; 3280 : 		}
; 3281 : 	}
; 3282 : 
; 3283 : 	return STATUS_SUCCESS;

  00070	33 c0		 xor	 eax, eax
  00072	5f		 pop	 edi
$LN6@ReadDevice:
  00073	5e		 pop	 esi
  00074	5b		 pop	 ebx

; 3284 : }

  00075	5d		 pop	 ebp
  00076	c2 18 00	 ret	 24			; 00000018H
_ReadDeviceSkipUnreadableSectors@24 ENDP
_TEXT	ENDS
PUBLIC	_IsVolumeAccessibleByCurrentUser@4
EXTRN	__imp__SeReleaseSubjectContext@4:PROC
EXTRN	__imp__SeUnlockSubjectContext@4:PROC
EXTRN	__imp__RtlEqualSid@8:PROC
EXTRN	__imp__SeQueryInformationToken@12:PROC
EXTRN	__imp__SeTokenIsAdmin@4:PROC
EXTRN	__imp__SeLockSubjectContext@4:PROC
EXTRN	__imp__SeCaptureSubjectContext@4:PROC
EXTRN	__imp__IoIsSystemThread@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _IsVolumeAccessibleByCurrentUser@4
_TEXT	SEGMENT
_subContext$ = -24					; size = 16
_tokenUser$ = -8					; size = 4
_result$ = -4						; size = 4
_volumeDeviceExtension$ = 8				; size = 4
_IsVolumeAccessibleByCurrentUser@4 PROC			; COMDAT

; 3288 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 18	 sub	 esp, 24			; 00000018H
  00008	53		 push	 ebx

; 3289 : 	SECURITY_SUBJECT_CONTEXT subContext;
; 3290 : 	PACCESS_TOKEN accessToken;
; 3291 : 	PTOKEN_USER tokenUser;
; 3292 : 	BOOL result = FALSE;

  00009	33 db		 xor	 ebx, ebx
  0000b	56		 push	 esi
  0000c	89 5d fc	 mov	 DWORD PTR _result$[ebp], ebx

; 3293 : 
; 3294 : 	if (IoIsSystemThread (PsGetCurrentThread())
; 3295 : 		|| UserCanAccessDriveDevice()
; 3296 : 		|| !volumeDeviceExtension->UserSid
; 3297 : 		|| (volumeDeviceExtension->SystemFavorite && !NonAdminSystemFavoritesAccessDisabled))

  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeGetCurrentThread@0
  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoIsSystemThread@4
  0001c	84 c0		 test	 al, al
  0001e	0f 85 b4 00 00
	00		 jne	 $LN4@IsVolumeAc
  00024	e8 00 00 00 00	 call	 _UserCanAccessDriveDevice@0
  00029	85 c0		 test	 eax, eax
  0002b	0f 85 a7 00 00
	00		 jne	 $LN4@IsVolumeAc
  00031	8b 75 08	 mov	 esi, DWORD PTR _volumeDeviceExtension$[ebp]
  00034	39 9e 8c 04 00
	00		 cmp	 DWORD PTR [esi+1164], ebx
  0003a	0f 84 98 00 00
	00		 je	 $LN4@IsVolumeAc
  00040	39 9e 5c 02 00
	00		 cmp	 DWORD PTR [esi+604], ebx
  00046	74 0c		 je	 SHORT $LN5@IsVolumeAc
  00048	39 1d 00 00 00
	00		 cmp	 DWORD PTR _NonAdminSystemFavoritesAccessDisabled, ebx
  0004e	0f 84 84 00 00
	00		 je	 $LN4@IsVolumeAc
$LN5@IsVolumeAc:
  00054	57		 push	 edi

; 3300 : 	}
; 3301 : 
; 3302 : 	SeCaptureSubjectContext (&subContext);

  00055	8d 45 e8	 lea	 eax, DWORD PTR _subContext$[ebp]
  00058	50		 push	 eax
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeCaptureSubjectContext@4

; 3303 : 	SeLockSubjectContext(&subContext);

  0005f	8d 45 e8	 lea	 eax, DWORD PTR _subContext$[ebp]
  00062	50		 push	 eax
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeLockSubjectContext@4

; 3304 : 	accessToken = getToken(&subContext);

  00069	8d 45 e8	 lea	 eax, DWORD PTR _subContext$[ebp]
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 _getToken@4
  00072	8b f8		 mov	 edi, eax

; 3305 : 
; 3306 : 	if (!accessToken)

  00074	3b fb		 cmp	 edi, ebx
  00076	74 46		 je	 SHORT $ret$31359

; 3307 : 		goto ret;
; 3308 : 	
; 3309 : 	if (SeTokenIsAdmin (accessToken))

  00078	57		 push	 edi
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeTokenIsAdmin@4
  0007f	84 c0		 test	 al, al
  00081	74 09		 je	 SHORT $LN2@IsVolumeAc

; 3310 : 	{
; 3311 : 		result = TRUE;

  00083	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _result$[ebp], 1

; 3312 : 		goto ret;

  0008a	eb 32		 jmp	 SHORT $ret$31359
$LN2@IsVolumeAc:

; 3313 : 	}
; 3314 : 
; 3315 : 	if (!NT_SUCCESS (SeQueryInformationToken (accessToken, TokenUser, &tokenUser)))

  0008c	8d 45 f8	 lea	 eax, DWORD PTR _tokenUser$[ebp]
  0008f	50		 push	 eax
  00090	6a 01		 push	 1
  00092	57		 push	 edi
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeQueryInformationToken@12
  00099	85 c0		 test	 eax, eax
  0009b	7c 21		 jl	 SHORT $ret$31359

; 3316 : 		goto ret;
; 3317 : 
; 3318 : 	result = RtlEqualSid (volumeDeviceExtension->UserSid, tokenUser->User.Sid);

  0009d	8b 45 f8	 mov	 eax, DWORD PTR _tokenUser$[ebp]
  000a0	ff 30		 push	 DWORD PTR [eax]
  000a2	ff b6 8c 04 00
	00		 push	 DWORD PTR [esi+1164]
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEqualSid@8
  000ae	0f b6 c0	 movzx	 eax, al

; 3319 : 	ExFreePool (tokenUser);		// Documented in newer versions of WDK

  000b1	53		 push	 ebx
  000b2	ff 75 f8	 push	 DWORD PTR _tokenUser$[ebp]
  000b5	89 45 fc	 mov	 DWORD PTR _result$[ebp], eax
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$ret$31359:

; 3320 : 
; 3321 : ret:
; 3322 : 	SeUnlockSubjectContext(&subContext);

  000be	8d 45 e8	 lea	 eax, DWORD PTR _subContext$[ebp]
  000c1	50		 push	 eax
  000c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeUnlockSubjectContext@4

; 3323 : 	SeReleaseSubjectContext (&subContext);

  000c8	8d 45 e8	 lea	 eax, DWORD PTR _subContext$[ebp]
  000cb	50		 push	 eax
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeReleaseSubjectContext@4

; 3324 : 	return result;

  000d2	8b 45 fc	 mov	 eax, DWORD PTR _result$[ebp]
  000d5	5f		 pop	 edi
  000d6	eb 03		 jmp	 SHORT $LN6@IsVolumeAc
$LN4@IsVolumeAc:

; 3298 : 	{
; 3299 : 		return TRUE;

  000d8	33 c0		 xor	 eax, eax
  000da	40		 inc	 eax
$LN6@IsVolumeAc:
  000db	5e		 pop	 esi
  000dc	5b		 pop	 ebx

; 3325 : }

  000dd	c9		 leave
  000de	c2 04 00	 ret	 4
_IsVolumeAccessibleByCurrentUser@4 ENDP
_TEXT	ENDS
PUBLIC	_GetElapsedTimeInit@4
EXTRN	__imp__KeQueryPerformanceCounter@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _GetElapsedTimeInit@4
_TEXT	SEGMENT
_lastPerfCounter$ = 8					; size = 4
_GetElapsedTimeInit@4 PROC				; COMDAT

; 3329 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 3330 : 	*lastPerfCounter = KeQueryPerformanceCounter (NULL);

  00005	6a 00		 push	 0
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeQueryPerformanceCounter@4
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _lastPerfCounter$[ebp]
  00010	89 01		 mov	 DWORD PTR [ecx], eax
  00012	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 3331 : }

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
_GetElapsedTimeInit@4 ENDP
_TEXT	ENDS
PUBLIC	_GetElapsedTime@4
EXTRN	__alldiv:PROC
; Function compile flags: /Ogsp
;	COMDAT _GetElapsedTime@4
_TEXT	SEGMENT
_freq$ = -8						; size = 8
_lastPerfCounter$ = 8					; size = 4
_GetElapsedTime@4 PROC					; COMDAT

; 3336 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	51		 push	 ecx
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi

; 3337 : 	LARGE_INTEGER freq;
; 3338 : 	LARGE_INTEGER counter = KeQueryPerformanceCounter (&freq);

  0000a	8d 45 f8	 lea	 eax, DWORD PTR _freq$[ebp]
  0000d	50		 push	 eax
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeQueryPerformanceCounter@4

; 3339 : 
; 3340 : 	int64 elapsed = (counter.QuadPart - lastPerfCounter->QuadPart) * 1000000LL / freq.QuadPart;

  00014	8b 75 08	 mov	 esi, DWORD PTR _lastPerfCounter$[ebp]
  00017	8b f8		 mov	 edi, eax
  00019	2b 06		 sub	 eax, DWORD PTR [esi]
  0001b	8b da		 mov	 ebx, edx
  0001d	6a 00		 push	 0
  0001f	8b cb		 mov	 ecx, ebx
  00021	1b 4e 04	 sbb	 ecx, DWORD PTR [esi+4]
  00024	68 40 42 0f 00	 push	 1000000			; 000f4240H
  00029	51		 push	 ecx
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 __allmul
  00030	ff 75 fc	 push	 DWORD PTR _freq$[ebp+4]
  00033	ff 75 f8	 push	 DWORD PTR _freq$[ebp]
  00036	52		 push	 edx
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 __alldiv

; 3341 : 	*lastPerfCounter = counter;

  0003d	89 3e		 mov	 DWORD PTR [esi], edi
  0003f	5f		 pop	 edi
  00040	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx

; 3342 : 
; 3343 : 	return elapsed;
; 3344 : }

  00045	c9		 leave
  00046	c2 04 00	 ret	 4
_GetElapsedTime@4 ENDP
_TEXT	ENDS
PUBLIC	_IsOSAtLeast@4
; Function compile flags: /Ogsp
;	COMDAT _IsOSAtLeast@4
_TEXT	SEGMENT
_reqMinOS$ = 8						; size = 4
_IsOSAtLeast@4 PROC					; COMDAT

; 3348 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 3349 : 	/* When updating this function, update IsOSVersionAtLeast() in Dlgcode.c too. */
; 3350 : 
; 3351 : 	ULONG major = 0, minor = 0;
; 3352 : 
; 3353 : 	ASSERT (OsMajorVersion != 0);
; 3354 : 
; 3355 : 	switch (reqMinOS)

  00005	8b 45 08	 mov	 eax, DWORD PTR _reqMinOS$[ebp]
  00008	83 e8 07	 sub	 eax, 7
  0000b	74 49		 je	 SHORT $LN8@IsOSAtLeas
  0000d	48		 dec	 eax
  0000e	74 42		 je	 SHORT $LN7@IsOSAtLeas
  00010	6a 02		 push	 2
  00012	59		 pop	 ecx
  00013	2b c1		 sub	 eax, ecx
  00015	74 37		 je	 SHORT $LN6@IsOSAtLeas
  00017	48		 dec	 eax
  00018	74 30		 je	 SHORT $LN5@IsOSAtLeas
  0001a	2b c1		 sub	 eax, ecx
  0001c	74 25		 je	 SHORT $LN4@IsOSAtLeas
  0001e	2b c1		 sub	 eax, ecx
  00020	74 1d		 je	 SHORT $LN2@IsOSAtLeas
  00022	6a 04		 push	 4
  00024	59		 pop	 ecx
  00025	2b c1		 sub	 eax, ecx
  00027	74 16		 je	 SHORT $LN2@IsOSAtLeas

; 3364 : 
; 3365 : 	default:
; 3366 : 		TC_THROW_FATAL_EXCEPTION;

  00029	68 43 54 00 00	 push	 21571			; 00005443H
  0002e	6a 00		 push	 0
  00030	6a 00		 push	 0
  00032	68 26 0d 00 00	 push	 3366			; 00000d26H
  00037	6a 29		 push	 41			; 00000029H
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN17@IsOSAtLeas:
$LN2@IsOSAtLeas:

; 3362 : 	case WIN_8:				major = 6; minor = 2; break;
; 3363 : 	case WIN_10:			major = 6; minor = 4; break;

  0003f	6a 06		 push	 6
  00041	eb 17		 jmp	 SHORT $LN14@IsOSAtLeas
$LN4@IsOSAtLeas:

; 3361 : 	case WIN_7:				major = 6; minor = 1; break;

  00043	6a 06		 push	 6
$LN16@IsOSAtLeas:
  00045	33 c9		 xor	 ecx, ecx
  00047	41		 inc	 ecx
  00048	eb 10		 jmp	 SHORT $LN14@IsOSAtLeas
$LN5@IsOSAtLeas:

; 3360 : 	case WIN_VISTA:			major = 6; minor = 0; break;

  0004a	6a 06		 push	 6
  0004c	eb 0a		 jmp	 SHORT $LN15@IsOSAtLeas
$LN6@IsOSAtLeas:

; 3359 : 	case WIN_SERVER_2003:	major = 5; minor = 2; break;

  0004e	6a 05		 push	 5
  00050	eb 08		 jmp	 SHORT $LN14@IsOSAtLeas
$LN7@IsOSAtLeas:

; 3358 : 	case WIN_XP:			major = 5; minor = 1; break;

  00052	6a 05		 push	 5
  00054	eb ef		 jmp	 SHORT $LN16@IsOSAtLeas
$LN8@IsOSAtLeas:

; 3356 : 	{
; 3357 : 	case WIN_2000:			major = 5; minor = 0; break;

  00056	6a 05		 push	 5
$LN15@IsOSAtLeas:
  00058	33 c9		 xor	 ecx, ecx
$LN14@IsOSAtLeas:

; 3367 : 		break;
; 3368 : 	}
; 3369 : 
; 3370 : 	return ((OsMajorVersion << 16 | OsMinorVersion << 8)
; 3371 : 		>= (major << 16 | minor << 8));

  0005a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _OsMajorVersion
  00060	c1 e2 08	 shl	 edx, 8
  00063	0b 15 00 00 00
	00		 or	 edx, DWORD PTR _OsMinorVersion
  00069	58		 pop	 eax
  0006a	c1 e0 08	 shl	 eax, 8
  0006d	0b c1		 or	 eax, ecx
  0006f	b9 ff ff ff 00	 mov	 ecx, 16777215		; 00ffffffH
  00074	23 c1		 and	 eax, ecx
  00076	23 d1		 and	 edx, ecx
  00078	3b d0		 cmp	 edx, eax
  0007a	1b c0		 sbb	 eax, eax
  0007c	40		 inc	 eax

; 3372 : }

  0007d	5d		 pop	 ebp
  0007e	c2 04 00	 ret	 4
$LN13@IsOSAtLeas:
_IsOSAtLeast@4 ENDP
_TEXT	ENDS
PUBLIC	_DriverObject$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_TCCreateDeviceObject@12
EXTRN	__imp__IoInitializeRemoveLockEx@20:PROC
EXTRN	__imp__KeInitializeSemaphore@12:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCCreateDeviceObject@12
_TEXT	SEGMENT
_Win32NameString$ = -152				; size = 8
_ntUnicodeString$ = -144				; size = 8
_DriverObject$GSCopy$ = -136				; size = 4
_ntname$ = -132						; size = 64
_dosname$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_DriverObject$ = 8					; size = 4
_ppDeviceObject$ = 12					; size = 4
_mount$ = 16						; size = 4
_TCCreateDeviceObject@12 PROC				; COMDAT

; 414  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	8b 45 08	 mov	 eax, DWORD PTR _DriverObject$[ebp]
  00018	53		 push	 ebx
  00019	8b 5d 0c	 mov	 ebx, DWORD PTR _ppDeviceObject$[ebp]
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8b 7d 10	 mov	 edi, DWORD PTR _mount$[ebp]

; 415  : 	UNICODE_STRING Win32NameString, ntUnicodeString;
; 416  : 	WCHAR dosname[32], ntname[32];
; 417  : 	PEXTENSION Extension;
; 418  : 	NTSTATUS ntStatus;
; 419  : 	ULONG devChars = 0;
; 420  : 
; 421  : 	Dump ("TCCreateDeviceObject BEGIN\n");
; 422  : 	ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);
; 423  : 
; 424  : 	TCGetDosNameFromNumber (dosname, mount->nDosDriveNo);

  00021	ff b7 64 02 00
	00		 push	 DWORD PTR [edi+612]
  00027	89 85 78 ff ff
	ff		 mov	 DWORD PTR _DriverObject$GSCopy$[ebp], eax
  0002d	8d 45 bc	 lea	 eax, DWORD PTR _dosname$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 _TCGetDosNameFromNumber@8

; 425  : 	TCGetNTNameFromNumber (ntname, mount->nDosDriveNo);

  00036	ff b7 64 02 00
	00		 push	 DWORD PTR [edi+612]
  0003c	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _ntname$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 _TCGetNTNameFromNumber@8

; 426  : 	RtlInitUnicodeString (&ntUnicodeString, ntname);

  00048	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__RtlInitUnicodeString@8
  0004e	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _ntname$[ebp]
  00054	50		 push	 eax
  00055	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _ntUnicodeString$[ebp]
  0005b	50		 push	 eax
  0005c	ff d6		 call	 esi

; 427  : 	RtlInitUnicodeString (&Win32NameString, dosname);

  0005e	8d 45 bc	 lea	 eax, DWORD PTR _dosname$[ebp]
  00061	50		 push	 eax
  00062	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _Win32NameString$[ebp]
  00068	50		 push	 eax
  00069	ff d6		 call	 esi

; 428  : 
; 429  : 	devChars = FILE_DEVICE_SECURE_OPEN;
; 430  : 	devChars |= mount->bMountReadOnly ? FILE_READ_ONLY_DEVICE : 0;

  0006b	8b 87 6c 02 00
	00		 mov	 eax, DWORD PTR [edi+620]
  00071	f7 d8		 neg	 eax
  00073	1b c0		 sbb	 eax, eax
  00075	83 e0 02	 and	 eax, 2

; 431  : 	devChars |= mount->bMountRemovable ? FILE_REMOVABLE_MEDIA : 0;

  00078	33 c9		 xor	 ecx, ecx
  0007a	39 8f 70 02 00
	00		 cmp	 DWORD PTR [edi+624], ecx

; 432  : 
; 433  : 	Dump ("Creating device nt=%ls dos=%ls\n", ntname, dosname);
; 434  : 
; 435  : 	ntStatus = IoCreateDevice (
; 436  : 					  DriverObject,			/* Our Driver Object */
; 437  : 					  sizeof (EXTENSION),	/* Size of state information */
; 438  : 					  &ntUnicodeString,		/* Device name "\Device\Name" */
; 439  : 					  FILE_DEVICE_DISK,		/* Device type */
; 440  : 					  devChars,				/* Device characteristics */
; 441  : 					  FALSE,				/* Exclusive device */
; 442  : 					  ppDeviceObject);		/* Returned ptr to Device Object */

  00080	53		 push	 ebx
  00081	0f 95 c1	 setne	 cl
  00084	6a 00		 push	 0
  00086	0b c1		 or	 eax, ecx
  00088	0d 00 01 00 00	 or	 eax, 256		; 00000100H
  0008d	50		 push	 eax
  0008e	6a 07		 push	 7
  00090	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _ntUnicodeString$[ebp]
  00096	50		 push	 eax
  00097	68 d0 04 00 00	 push	 1232			; 000004d0H
  0009c	ff b5 78 ff ff
	ff		 push	 DWORD PTR _DriverObject$GSCopy$[ebp]
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoCreateDevice@28

; 443  : 
; 444  : 	if (!NT_SUCCESS (ntStatus))

  000a8	85 c0		 test	 eax, eax

; 445  : 	{
; 446  : 		Dump ("TCCreateDeviceObject NTSTATUS = 0x%08x END\n", ntStatus);
; 447  : 		return ntStatus;/* Failed to create DeviceObject */

  000aa	0f 8c a6 00 00
	00		 jl	 $LN2@TCCreateDe

; 448  : 	}
; 449  : 	/* Initialize device object and extension. */
; 450  : 
; 451  : 	(*ppDeviceObject)->Flags |= DO_DIRECT_IO;

  000b0	8b 03		 mov	 eax, DWORD PTR [ebx]
  000b2	83 48 1c 10	 or	 DWORD PTR [eax+28], 16	; 00000010H

; 452  : 	(*ppDeviceObject)->StackSize += 6;		// Reduce occurrence of NO_MORE_IRP_STACK_LOCATIONS bug check caused by buggy drivers

  000b6	8b 03		 mov	 eax, DWORD PTR [ebx]
  000b8	80 40 30 06	 add	 BYTE PTR [eax+48], 6

; 453  : 
; 454  : 	/* Setup the device extension */
; 455  : 	Extension = (PEXTENSION) (*ppDeviceObject)->DeviceExtension;

  000bc	8b 03		 mov	 eax, DWORD PTR [ebx]
  000be	8b 70 28	 mov	 esi, DWORD PTR [eax+40]

; 456  : 	memset (Extension, 0, sizeof (EXTENSION));

  000c1	68 d0 04 00 00	 push	 1232			; 000004d0H
  000c6	6a 00		 push	 0
  000c8	56		 push	 esi
  000c9	e8 00 00 00 00	 call	 _memset

; 457  : 
; 458  : 	Extension->IsVolumeDevice = TRUE;

  000ce	33 c0		 xor	 eax, eax
  000d0	40		 inc	 eax
  000d1	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 459  : 	Extension->nDosDriveNo = mount->nDosDriveNo;

  000d4	8b 8f 64 02 00
	00		 mov	 ecx, DWORD PTR [edi+612]
  000da	89 4e 14	 mov	 DWORD PTR [esi+20], ecx

; 460  : 	Extension->bRemovable = mount->bMountRemovable;

  000dd	8b 8f 70 02 00
	00		 mov	 ecx, DWORD PTR [edi+624]
  000e3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e6	89 8e 4c 02 00
	00		 mov	 DWORD PTR [esi+588], ecx

; 461  : 	Extension->PartitionInInactiveSysEncScope = mount->bPartitionInInactiveSysEncScope;

  000ec	8b 8f 80 02 00
	00		 mov	 ecx, DWORD PTR [edi+640]

; 462  : 	Extension->SystemFavorite = mount->SystemFavorite;
; 463  : 
; 464  : 	KeInitializeEvent (&Extension->keCreateEvent, SynchronizationEvent, FALSE);

  000f2	6a 00		 push	 0
  000f4	50		 push	 eax
  000f5	89 8e 50 02 00
	00		 mov	 DWORD PTR [esi+592], ecx
  000fb	8b 8f 88 02 00
	00		 mov	 ecx, DWORD PTR [edi+648]
  00101	8d 46 24	 lea	 eax, DWORD PTR [esi+36]
  00104	50		 push	 eax
  00105	89 8e 5c 02 00
	00		 mov	 DWORD PTR [esi+604], ecx
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 465  : 	KeInitializeSemaphore (&Extension->RequestSemaphore, 0L, MAXLONG);

  00111	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  00116	6a 00		 push	 0
  00118	8d 46 40	 lea	 eax, DWORD PTR [esi+64]
  0011b	50		 push	 eax
  0011c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeSemaphore@12

; 466  : 	KeInitializeSpinLock (&Extension->ListSpinLock);
; 467  : 	InitializeListHead (&Extension->ListEntry);
; 468  : 	IoInitializeRemoveLock (&Extension->Queue.RemoveLock, 'LRCT', 0, 0);

  00122	6a 18		 push	 24			; 00000018H
  00124	33 c9		 xor	 ecx, ecx
  00126	51		 push	 ecx
  00127	89 4e 34	 mov	 DWORD PTR [esi+52], ecx
  0012a	8d 46 38	 lea	 eax, DWORD PTR [esi+56]
  0012d	51		 push	 ecx
  0012e	68 54 43 52 4c	 push	 1280459604		; 4c524354H
  00133	81 c6 18 01 00
	00		 add	 esi, 280		; 00000118H
  00139	56		 push	 esi
  0013a	89 40 04	 mov	 DWORD PTR [eax+4], eax
  0013d	89 00		 mov	 DWORD PTR [eax], eax
  0013f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoInitializeRemoveLockEx@20

; 469  : 
; 470  : 	VirtualVolumeDeviceObjects[mount->nDosDriveNo] = *ppDeviceObject;

  00145	8b 87 64 02 00
	00		 mov	 eax, DWORD PTR [edi+612]
  0014b	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0014d	89 0c 85 00 00
	00 00		 mov	 DWORD PTR _VirtualVolumeDeviceObjects[eax*4], ecx

; 471  : 
; 472  : 	Dump ("TCCreateDeviceObject STATUS_SUCCESS END\n");
; 473  : 
; 474  : 	return STATUS_SUCCESS;

  00154	33 c0		 xor	 eax, eax
$LN2@TCCreateDe:

; 475  : }

  00156	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00159	5f		 pop	 edi
  0015a	5e		 pop	 esi
  0015b	33 cd		 xor	 ecx, ebp
  0015d	5b		 pop	 ebx
  0015e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00163	c9		 leave
  00164	c2 0c 00	 ret	 12			; 0000000cH
_TCCreateDeviceObject@12 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	_Extension$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_ProcessVolumeDeviceControlIrp@12
EXTRN	__imp__ZwReadFile@36:PROC
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@FNODOBFM@
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
text$s	SEGMENT
??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@FNODOBFM@ DB 'TrueCryptVolume', 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
; File c:\users\public\desktop\projects\ciphershed\src\driver\ntdriver.c
text$s	ENDS
;	COMDAT _ProcessVolumeDeviceControlIrp@12
_TEXT	SEGMENT
_ioStatus$30037 = -664					; size = 8
_Extension$GSCopy$ = -660				; size = 4
_offset$30043 = -656					; size = 8
_ntUnicodeString$29976 = -656				; size = 8
_ntUnicodeString$29943 = -656				; size = 8
_irpSp$ = -652						; size = 4
_buffer$30038 = -648					; size = 4
_outputBuffer$29978 = -648				; size = 4
_tmp$29961 = -648					; size = 2
_outputBuffer$29945 = -648				; size = 4
_ntName$29977 = -644					; size = 512
_ntName$29944 = -644					; size = 512
_volId$29960 = -132					; size = 128
__$ArrayPad$ = -4					; size = 4
_DeviceObject$ = 8					; size = 4
_Extension$ = 12					; size = 4
_Irp$ = 16						; size = 4
_ProcessVolumeDeviceControlIrp@12 PROC			; COMDAT

; 496  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 98 02 00
	00		 sub	 esp, 664		; 00000298H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	53		 push	 ebx
  00016	8b 5d 10	 mov	 ebx, DWORD PTR _Irp$[ebp]
  00019	56		 push	 esi

; 497  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);

  0001a	8b 73 60	 mov	 esi, DWORD PTR [ebx+96]

; 498  : 
; 499  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  0001d	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00020	57		 push	 edi
  00021	8b 7d 0c	 mov	 edi, DWORD PTR _Extension$[ebp]
  00024	b8 5c 40 07 00	 mov	 eax, 475228		; 0007405cH
  00029	89 bd 6c fd ff
	ff		 mov	 DWORD PTR _Extension$GSCopy$[ebp], edi
  0002f	89 b5 74 fd ff
	ff		 mov	 DWORD PTR _irpSp$[ebp], esi
  00035	3b c8		 cmp	 ecx, eax
  00037	0f 87 db 02 00
	00		 ja	 $LN50@ProcessVol
  0003d	0f 84 a6 02 00
	00		 je	 $LN22@ProcessVol
  00043	81 e9 00 00 07
	00		 sub	 ecx, 458752		; 00070000H
  00049	0f 84 48 02 00
	00		 je	 $LN30@ProcessVol
  0004f	83 e9 14	 sub	 ecx, 20			; 00000014H
  00052	0f 84 40 01 00
	00		 je	 $LN19@ProcessVol
  00058	83 e9 10	 sub	 ecx, 16			; 00000010H
  0005b	0f 84 20 01 00
	00		 je	 $LN10@ProcessVol
  00061	83 e9 24	 sub	 ecx, 36			; 00000024H
  00064	0f 84 ca 00 00
	00		 je	 $LN26@ProcessVol
  0006a	81 e9 b8 0b 00
	00		 sub	 ecx, 3000		; 00000bb8H
  00070	0f 84 21 02 00
	00		 je	 $LN30@ProcessVol
  00076	81 e9 04 34 00
	00		 sub	 ecx, 13316		; 00003404H
  0007c	74 66		 je	 SHORT $LN28@ProcessVol
  0007e	83 e9 08	 sub	 ecx, 8
  00081	0f 85 d3 02 00
	00		 jne	 $LN1@ProcessVol

; 665  : 
; 666  : 	case IOCTL_DISK_GET_DRIVE_LAYOUT:
; 667  : 		if (ValidateIOBufferSize (Irp, sizeof (DRIVE_LAYOUT_INFORMATION), ValidateOutput))

  00087	33 f6		 xor	 esi, esi
  00089	46		 inc	 esi
  0008a	56		 push	 esi
  0008b	6a 28		 push	 40			; 00000028H
  0008d	53		 push	 ebx
  0008e	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00093	85 c0		 test	 eax, eax
  00095	0f 84 1e 05 00
	00		 je	 $LN11@ProcessVol

; 668  : 		{
; 669  : 			PDRIVE_LAYOUT_INFORMATION outputBuffer = (PDRIVE_LAYOUT_INFORMATION)
; 670  : 			Irp->AssociatedIrp.SystemBuffer;

  0009b	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]

; 671  : 
; 672  : 			outputBuffer->PartitionCount = 1;

  0009e	89 30		 mov	 DWORD PTR [eax], esi

; 673  : 			outputBuffer->Signature = 0;

  000a0	33 f6		 xor	 esi, esi
  000a2	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 674  : 
; 675  : 			outputBuffer->PartitionEntry->PartitionType = Extension->PartitionType;

  000a5	8a 8f 8c 00 00
	00		 mov	 cl, BYTE PTR [edi+140]
  000ab	88 48 20	 mov	 BYTE PTR [eax+32], cl

; 676  : 			outputBuffer->PartitionEntry->BootIndicator = FALSE;

  000ae	c6 40 21 00	 mov	 BYTE PTR [eax+33], 0

; 677  : 			outputBuffer->PartitionEntry->RecognizedPartition = TRUE;

  000b2	c6 40 22 01	 mov	 BYTE PTR [eax+34], 1

; 678  : 			outputBuffer->PartitionEntry->RewritePartition = FALSE;

  000b6	c6 40 23 00	 mov	 BYTE PTR [eax+35], 0

; 679  : 			outputBuffer->PartitionEntry->StartingOffset.QuadPart = Extension->BytesPerSector;

  000ba	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  000c0	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000c3	89 70 0c	 mov	 DWORD PTR [eax+12], esi

; 680  : 			outputBuffer->PartitionEntry->PartitionLength.QuadPart = Extension->DiskLength;

  000c6	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  000c9	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  000cc	8b 4f 74	 mov	 ecx, DWORD PTR [edi+116]
  000cf	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 681  : 			outputBuffer->PartitionEntry->HiddenSectors = 0;

  000d2	89 70 18	 mov	 DWORD PTR [eax+24], esi

; 682  : 
; 683  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  000d5	89 73 18	 mov	 DWORD PTR [ebx+24], esi

; 684  : 			Irp->IoStatus.Information = sizeof (PARTITION_INFORMATION);

  000d8	c7 43 1c 20 00
	00 00		 mov	 DWORD PTR [ebx+28], 32	; 00000020H

; 685  : 		}
; 686  : 		break;

  000df	e9 d5 04 00 00	 jmp	 $LN11@ProcessVol
$LN28@ProcessVol:

; 629  : 
; 630  : 	case IOCTL_DISK_GET_PARTITION_INFO:
; 631  : 		if (ValidateIOBufferSize (Irp, sizeof (PARTITION_INFORMATION), ValidateOutput))

  000e4	6a 01		 push	 1
  000e6	6a 20		 push	 32			; 00000020H
  000e8	5e		 pop	 esi
  000e9	56		 push	 esi
  000ea	53		 push	 ebx
  000eb	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  000f0	85 c0		 test	 eax, eax
  000f2	0f 84 c1 04 00
	00		 je	 $LN11@ProcessVol

; 632  : 		{
; 633  : 			PPARTITION_INFORMATION outputBuffer = (PPARTITION_INFORMATION)
; 634  : 			Irp->AssociatedIrp.SystemBuffer;
; 635  : 
; 636  : 			outputBuffer->PartitionType = Extension->PartitionType;

  000f8	8a 8f 8c 00 00
	00		 mov	 cl, BYTE PTR [edi+140]
  000fe	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00101	88 48 18	 mov	 BYTE PTR [eax+24], cl

; 637  : 			outputBuffer->BootIndicator = FALSE;

  00104	c6 40 19 00	 mov	 BYTE PTR [eax+25], 0

; 638  : 			outputBuffer->RecognizedPartition = TRUE;

  00108	c6 40 1a 01	 mov	 BYTE PTR [eax+26], 1

; 639  : 			outputBuffer->RewritePartition = FALSE;

  0010c	c6 40 1b 00	 mov	 BYTE PTR [eax+27], 0

; 640  : 			outputBuffer->StartingOffset.QuadPart = Extension->BytesPerSector;

  00110	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  00116	89 08		 mov	 DWORD PTR [eax], ecx
  00118	33 c9		 xor	 ecx, ecx
  0011a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 641  : 			outputBuffer->PartitionLength.QuadPart= Extension->DiskLength;

  0011d	8b 57 70	 mov	 edx, DWORD PTR [edi+112]
  00120	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00123	8b 57 74	 mov	 edx, DWORD PTR [edi+116]
  00126	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 642  : 			outputBuffer->HiddenSectors = 0;

  00129	89 48 10	 mov	 DWORD PTR [eax+16], ecx
$LN66@ProcessVol:

; 643  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  0012c	89 4b 18	 mov	 DWORD PTR [ebx+24], ecx

; 644  : 			Irp->IoStatus.Information = sizeof (PARTITION_INFORMATION);
; 645  : 		}
; 646  : 		break;

  0012f	e9 68 04 00 00	 jmp	 $LN65@ProcessVol
$LN26@ProcessVol:

; 647  : 
; 648  : 	case IOCTL_DISK_GET_PARTITION_INFO_EX:
; 649  : 		if (ValidateIOBufferSize (Irp, sizeof (PARTITION_INFORMATION_EX), ValidateOutput))

  00134	6a 01		 push	 1
  00136	be 90 00 00 00	 mov	 esi, 144		; 00000090H
  0013b	56		 push	 esi
  0013c	53		 push	 ebx
  0013d	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00142	85 c0		 test	 eax, eax
  00144	0f 84 6f 04 00
	00		 je	 $LN11@ProcessVol

; 650  : 		{
; 651  : 			PPARTITION_INFORMATION_EX outputBuffer = (PPARTITION_INFORMATION_EX) Irp->AssociatedIrp.SystemBuffer;

  0014a	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]

; 652  : 
; 653  : 			outputBuffer->PartitionStyle = PARTITION_STYLE_MBR;

  0014d	33 c9		 xor	 ecx, ecx
  0014f	89 08		 mov	 DWORD PTR [eax], ecx

; 654  : 			outputBuffer->RewritePartition = FALSE;

  00151	88 48 1c	 mov	 BYTE PTR [eax+28], cl

; 655  : 			outputBuffer->StartingOffset.QuadPart = Extension->BytesPerSector;

  00154	8b 97 88 00 00
	00		 mov	 edx, DWORD PTR [edi+136]
  0015a	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0015d	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 656  : 			outputBuffer->PartitionLength.QuadPart= Extension->DiskLength;

  00160	8b 57 70	 mov	 edx, DWORD PTR [edi+112]
  00163	89 50 10	 mov	 DWORD PTR [eax+16], edx
  00166	8b 57 74	 mov	 edx, DWORD PTR [edi+116]
  00169	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 657  : 			outputBuffer->Mbr.PartitionType = Extension->PartitionType;

  0016c	8a 97 8c 00 00
	00		 mov	 dl, BYTE PTR [edi+140]
  00172	88 50 20	 mov	 BYTE PTR [eax+32], dl

; 658  : 			outputBuffer->Mbr.BootIndicator = FALSE;

  00175	88 48 21	 mov	 BYTE PTR [eax+33], cl

; 659  : 			outputBuffer->Mbr.RecognizedPartition = TRUE;

  00178	c6 40 22 01	 mov	 BYTE PTR [eax+34], 1

; 660  : 			outputBuffer->Mbr.HiddenSectors = 0;

  0017c	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 661  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 662  : 			Irp->IoStatus.Information = sizeof (PARTITION_INFORMATION_EX);
; 663  : 		}
; 664  : 		break;

  0017f	eb ab		 jmp	 SHORT $LN66@ProcessVol
$LN10@ProcessVol:

; 748  : 			}
; 749  : 		}
; 750  : 		break;
; 751  : 
; 752  : 	case IOCTL_DISK_IS_WRITABLE:
; 753  : 		{
; 754  : 			if (Extension->bReadOnly)

  00181	8b 87 48 02 00
	00		 mov	 eax, DWORD PTR [edi+584]
  00187	f7 d8		 neg	 eax
  00189	1b c0		 sbb	 eax, eax
  0018b	25 a2 00 00 c0	 and	 eax, -1073741662	; c00000a2H
  00190	89 43 18	 mov	 DWORD PTR [ebx+24], eax

; 755  : 				Irp->IoStatus.Status = STATUS_MEDIA_WRITE_PROTECTED;
; 756  : 			else
; 757  : 				Irp->IoStatus.Status = STATUS_SUCCESS;
; 758  : 			Irp->IoStatus.Information = 0;
; 759  : 
; 760  : 		}
; 761  : 		break;

  00193	e9 3d 02 00 00	 jmp	 $LN60@ProcessVol
$LN19@ProcessVol:

; 703  : 
; 704  : 	case IOCTL_DISK_VERIFY:
; 705  : 		if (ValidateIOBufferSize (Irp, sizeof (VERIFY_INFORMATION), ValidateInput))

  00198	6a 00		 push	 0
  0019a	6a 10		 push	 16			; 00000010H
  0019c	53		 push	 ebx
  0019d	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  001a2	85 c0		 test	 eax, eax
  001a4	0f 84 0f 04 00
	00		 je	 $LN11@ProcessVol

; 706  : 		{
; 707  : 			PVERIFY_INFORMATION pVerifyInformation;
; 708  : 			pVerifyInformation = (PVERIFY_INFORMATION) Irp->AssociatedIrp.SystemBuffer;

  001aa	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]

; 709  : 
; 710  : 			if (pVerifyInformation->StartingOffset.QuadPart + pVerifyInformation->Length > Extension->DiskLength)

  001ad	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  001b0	33 c0		 xor	 eax, eax
  001b2	8b ca		 mov	 ecx, edx
  001b4	03 0e		 add	 ecx, DWORD PTR [esi]
  001b6	13 46 04	 adc	 eax, DWORD PTR [esi+4]
  001b9	3b 47 74	 cmp	 eax, DWORD PTR [edi+116]
  001bc	7c 0f		 jl	 SHORT $LN17@ProcessVol
  001be	0f 8f 0a 02 00
	00		 jg	 $LN53@ProcessVol
  001c4	3b 4f 70	 cmp	 ecx, DWORD PTR [edi+112]

; 711  : 				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
; 712  : 			else

  001c7	0f 87 01 02 00
	00		 ja	 $LN53@ProcessVol
$LN17@ProcessVol:

; 713  : 			{
; 714  : 				IO_STATUS_BLOCK ioStatus;
; 715  : 				PVOID buffer = TCalloc (max (pVerifyInformation->Length, PAGE_SIZE));

  001cd	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  001d2	3b d0		 cmp	 edx, eax
  001d4	76 02		 jbe	 SHORT $LN46@ProcessVol
  001d6	8b c2		 mov	 eax, edx
$LN46@ProcessVol:
  001d8	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  001dd	50		 push	 eax
  001de	6a 00		 push	 0
  001e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  001e6	89 85 78 fd ff
	ff		 mov	 DWORD PTR _buffer$30038[ebp], eax

; 716  : 				
; 717  : 				if (!buffer)

  001ec	85 c0		 test	 eax, eax
  001ee	75 0c		 jne	 SHORT $LN15@ProcessVol

; 718  : 				{
; 719  : 					Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

  001f0	c7 43 18 9a 00
	00 c0		 mov	 DWORD PTR [ebx+24], -1073741670 ; c000009aH

; 720  : 				}
; 721  : 				else

  001f7	e9 d9 01 00 00	 jmp	 $LN60@ProcessVol
$LN15@ProcessVol:

; 722  : 				{
; 723  : 					LARGE_INTEGER offset = pVerifyInformation->StartingOffset;

  001fc	8b 06		 mov	 eax, DWORD PTR [esi]
  001fe	89 85 70 fd ff
	ff		 mov	 DWORD PTR _offset$30043[ebp], eax
  00204	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00207	89 85 74 fd ff
	ff		 mov	 DWORD PTR _offset$30043[ebp+4], eax

; 724  : 					offset.QuadPart += Extension->cryptoInfo->hiddenVolume ? Extension->cryptoInfo->hiddenVolumeOffset : Extension->cryptoInfo->volDataAreaOffset;

  0020d	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  00210	83 b8 a0 29 00
	00 00		 cmp	 DWORD PTR [eax+10656], 0
  00217	74 0e		 je	 SHORT $LN48@ProcessVol
  00219	8b 88 18 44 00
	00		 mov	 ecx, DWORD PTR [eax+17432]
  0021f	8b 80 1c 44 00
	00		 mov	 eax, DWORD PTR [eax+17436]
  00225	eb 0c		 jmp	 SHORT $LN49@ProcessVol
$LN48@ProcessVol:
  00227	8b 88 08 44 00
	00		 mov	 ecx, DWORD PTR [eax+17416]
  0022d	8b 80 0c 44 00
	00		 mov	 eax, DWORD PTR [eax+17420]
$LN49@ProcessVol:
  00233	01 8d 70 fd ff
	ff		 add	 DWORD PTR _offset$30043[ebp], ecx

; 725  : 
; 726  : 					Irp->IoStatus.Status = ZwReadFile (Extension->hDeviceFile, NULL, NULL, NULL, &ioStatus, buffer, pVerifyInformation->Length, &offset, NULL);

  00239	8d 8d 70 fd ff
	ff		 lea	 ecx, DWORD PTR _offset$30043[ebp]
  0023f	11 85 74 fd ff
	ff		 adc	 DWORD PTR _offset$30043[ebp+4], eax
  00245	33 c0		 xor	 eax, eax
  00247	50		 push	 eax
  00248	51		 push	 ecx
  00249	ff 76 08	 push	 DWORD PTR [esi+8]
  0024c	8d 8d 68 fd ff
	ff		 lea	 ecx, DWORD PTR _ioStatus$30037[ebp]
  00252	ff b5 78 fd ff
	ff		 push	 DWORD PTR _buffer$30038[ebp]
  00258	51		 push	 ecx
  00259	50		 push	 eax
  0025a	50		 push	 eax
  0025b	50		 push	 eax
  0025c	ff 77 54	 push	 DWORD PTR [edi+84]
  0025f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwReadFile@36

; 727  : 					TCfree (buffer);

  00265	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0026a	ff b5 78 fd ff
	ff		 push	 DWORD PTR _buffer$30038[ebp]
  00270	89 43 18	 mov	 DWORD PTR [ebx+24], eax
  00273	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 728  : 
; 729  : 					if (NT_SUCCESS (Irp->IoStatus.Status) && ioStatus.Information != pVerifyInformation->Length)

  00279	83 7b 18 00	 cmp	 DWORD PTR [ebx+24], 0
  0027d	0f 8c 52 01 00
	00		 jl	 $LN60@ProcessVol
  00283	8b 85 6c fd ff
	ff		 mov	 eax, DWORD PTR _ioStatus$30037[ebp+4]
  00289	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0028c	0f 84 43 01 00
	00		 je	 $LN60@ProcessVol

; 730  : 						Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
; 731  : 				}
; 732  : 			}
; 733  : 
; 734  : 			Irp->IoStatus.Information = 0;
; 735  : 		}
; 736  : 		break;

  00292	e9 37 01 00 00	 jmp	 $LN53@ProcessVol
$LN30@ProcessVol:

; 610  : 
; 611  : 	case IOCTL_DISK_GET_MEDIA_TYPES:
; 612  : 	case IOCTL_DISK_GET_DRIVE_GEOMETRY:
; 613  : 		/* Return the drive geometry for the disk.  Note that we
; 614  : 		   return values which were made up to suit the disk size.  */
; 615  : 		if (ValidateIOBufferSize (Irp, sizeof (DISK_GEOMETRY), ValidateOutput))

  00297	6a 01		 push	 1
  00299	6a 18		 push	 24			; 00000018H
  0029b	5e		 pop	 esi
  0029c	56		 push	 esi
  0029d	53		 push	 ebx
  0029e	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  002a3	85 c0		 test	 eax, eax
  002a5	0f 84 0e 03 00
	00		 je	 $LN11@ProcessVol

; 616  : 		{
; 617  : 			PDISK_GEOMETRY outputBuffer = (PDISK_GEOMETRY)
; 618  : 			Irp->AssociatedIrp.SystemBuffer;
; 619  : 
; 620  : 			outputBuffer->MediaType = Extension->bRemovable ? RemovableMedia : FixedMedia;

  002ab	8b 8f 4c 02 00
	00		 mov	 ecx, DWORD PTR [edi+588]
  002b1	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  002b4	f7 d9		 neg	 ecx
  002b6	1b c9		 sbb	 ecx, ecx
  002b8	83 c1 0c	 add	 ecx, 12			; 0000000cH
  002bb	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 621  : 			outputBuffer->Cylinders.QuadPart = Extension->NumberOfCylinders;

  002be	8b 4f 78	 mov	 ecx, DWORD PTR [edi+120]
  002c1	89 08		 mov	 DWORD PTR [eax], ecx
  002c3	8b 4f 7c	 mov	 ecx, DWORD PTR [edi+124]
  002c6	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 622  : 			outputBuffer->TracksPerCylinder = Extension->TracksPerCylinder;

  002c9	8b 8f 80 00 00
	00		 mov	 ecx, DWORD PTR [edi+128]
  002cf	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 623  : 			outputBuffer->SectorsPerTrack = Extension->SectorsPerTrack;

  002d2	8b 8f 84 00 00
	00		 mov	 ecx, DWORD PTR [edi+132]
  002d8	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 624  : 			outputBuffer->BytesPerSector = Extension->BytesPerSector;

  002db	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  002e1	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 625  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 626  : 			Irp->IoStatus.Information = sizeof (DISK_GEOMETRY);
; 627  : 		}
; 628  : 		break;

  002e4	e9 af 02 00 00	 jmp	 $LN64@ProcessVol
$LN22@ProcessVol:

; 687  : 
; 688  : 	case IOCTL_DISK_GET_LENGTH_INFO:
; 689  : 		if (!ValidateIOBufferSize (Irp, sizeof (GET_LENGTH_INFORMATION), ValidateOutput))

  002e9	6a 01		 push	 1
  002eb	6a 08		 push	 8
  002ed	5e		 pop	 esi
  002ee	56		 push	 esi
  002ef	53		 push	 ebx
  002f0	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  002f5	85 c0		 test	 eax, eax
  002f7	75 0c		 jne	 SHORT $LN21@ProcessVol

; 690  : 		{
; 691  : 			Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

  002f9	c7 43 18 05 00
	00 80		 mov	 DWORD PTR [ebx+24], -2147483643 ; 80000005H

; 692  : 			Irp->IoStatus.Information = sizeof (GET_LENGTH_INFORMATION);
; 693  : 		}
; 694  : 		else

  00300	e9 97 02 00 00	 jmp	 $LN65@ProcessVol
$LN21@ProcessVol:

; 695  : 		{
; 696  : 			PGET_LENGTH_INFORMATION outputBuffer = (PGET_LENGTH_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
; 697  : 
; 698  : 			outputBuffer->Length.QuadPart = Extension->DiskLength;

  00305	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  00308	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0030b	89 08		 mov	 DWORD PTR [eax], ecx
  0030d	8b 4f 74	 mov	 ecx, DWORD PTR [edi+116]
  00310	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 699  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 700  : 			Irp->IoStatus.Information = sizeof (GET_LENGTH_INFORMATION);
; 701  : 		}
; 702  : 		break;

  00313	e9 80 02 00 00	 jmp	 $LN64@ProcessVol
$LN50@ProcessVol:

; 498  : 
; 499  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  00318	81 e9 00 48 07
	00		 sub	 ecx, 477184		; 00074800H
  0031e	0f 84 7d 02 00
	00		 je	 $LN12@ProcessVol
  00324	81 e9 00 00 26
	00		 sub	 ecx, 2490368		; 00260000H
  0032a	0f 84 71 02 00
	00		 je	 $LN12@ProcessVol
  00330	81 e9 00 b8 1f
	00		 sub	 ecx, 2078720		; 001fb800H
  00336	0f 84 90 01 00
	00		 je	 $LN37@ProcessVol
  0033c	83 e9 08	 sub	 ecx, 8
  0033f	0f 84 fc 00 00
	00		 je	 $LN41@ProcessVol
  00345	83 e9 04	 sub	 ecx, 4
  00348	74 6d		 je	 SHORT $LN33@ProcessVol
  0034a	81 e9 f4 ff 08
	00		 sub	 ecx, 589812		; 0008fff4H
  00350	74 20		 je	 SHORT $LN6@ProcessVol
  00352	81 e9 08 c0 00
	00		 sub	 ecx, 49160		; 0000c008H
  00358	74 12		 je	 SHORT $LN7@ProcessVol
$LN1@ProcessVol:

; 788  : 
; 789  : 	default:
; 790  : 		return TCCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);

  0035a	6a 00		 push	 0
  0035c	68 10 00 00 c0	 push	 -1073741808		; c0000010H
  00361	53		 push	 ebx
  00362	e8 00 00 00 00	 call	 _TCCompleteIrp@12
  00367	e9 59 02 00 00	 jmp	 $LN44@ProcessVol
$LN7@ProcessVol:

; 762  : 		
; 763  : 	case IOCTL_VOLUME_ONLINE:
; 764  : 		Irp->IoStatus.Status = STATUS_SUCCESS;

  0036c	83 63 18 00	 and	 DWORD PTR [ebx+24], 0

; 765  : 		Irp->IoStatus.Information = 0;
; 766  : 		break;

  00370	eb 63		 jmp	 SHORT $LN60@ProcessVol
$LN6@ProcessVol:

; 767  : 
; 768  : 	case IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS:
; 769  : 
; 770  : 		// Vista's filesystem defragmenter fails if IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS does not succeed.
; 771  : 		if (!(OsMajorVersion == 6 && OsMinorVersion == 0))

  00372	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _OsMajorVersion, 6
  00379	75 33		 jne	 SHORT $LN59@ProcessVol
  0037b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _OsMinorVersion, 0
  00382	75 2a		 jne	 SHORT $LN59@ProcessVol

; 774  : 			Irp->IoStatus.Information = 0;
; 775  : 		}
; 776  : 		else if (ValidateIOBufferSize (Irp, sizeof (VOLUME_DISK_EXTENTS), ValidateOutput))

  00384	6a 01		 push	 1
  00386	6a 20		 push	 32			; 00000020H
  00388	5e		 pop	 esi
  00389	56		 push	 esi
  0038a	53		 push	 ebx
  0038b	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00390	85 c0		 test	 eax, eax
  00392	0f 84 21 02 00
	00		 je	 $LN11@ProcessVol

; 777  : 		{
; 778  : 			VOLUME_DISK_EXTENTS *extents = (VOLUME_DISK_EXTENTS *) Irp->AssociatedIrp.SystemBuffer;

  00398	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]

; 779  : 
; 780  : 			// No extent data can be returned as this is not a physical drive.
; 781  : 			memset (extents, 0, sizeof (*extents));

  0039b	6a 08		 push	 8
  0039d	33 c0		 xor	 eax, eax
  0039f	59		 pop	 ecx
  003a0	8b fa		 mov	 edi, edx
  003a2	f3 ab		 rep stosd

; 782  : 			extents->NumberOfDiskExtents = 0;

  003a4	21 02		 and	 DWORD PTR [edx], eax

; 783  : 
; 784  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  003a6	21 43 18	 and	 DWORD PTR [ebx+24], eax

; 785  : 			Irp->IoStatus.Information = sizeof (*extents);

  003a9	e9 ee 01 00 00	 jmp	 $LN65@ProcessVol
$LN59@ProcessVol:

; 772  : 		{
; 773  : 			Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;

  003ae	c7 43 18 10 00
	00 c0		 mov	 DWORD PTR [ebx+24], -1073741808 ; c0000010H

; 786  : 		}
; 787  : 		break;

  003b5	eb 1e		 jmp	 SHORT $LN60@ProcessVol
$LN33@ProcessVol:

; 572  : 
; 573  : 	case IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME:
; 574  : 		{
; 575  : 			ULONG outLength;
; 576  : 			UNICODE_STRING ntUnicodeString;
; 577  : 			WCHAR ntName[256];
; 578  : 			PMOUNTDEV_SUGGESTED_LINK_NAME outputBuffer = (PMOUNTDEV_SUGGESTED_LINK_NAME) Irp->AssociatedIrp.SystemBuffer;

  003b7	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]

; 579  : 
; 580  : 			if (!ValidateIOBufferSize (Irp, sizeof (MOUNTDEV_SUGGESTED_LINK_NAME), ValidateOutput))

  003ba	6a 01		 push	 1
  003bc	6a 06		 push	 6
  003be	53		 push	 ebx
  003bf	89 85 78 fd ff
	ff		 mov	 DWORD PTR _outputBuffer$29978[ebp], eax
  003c5	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  003ca	85 c0		 test	 eax, eax
  003cc	75 10		 jne	 SHORT $LN32@ProcessVol
$LN53@ProcessVol:

; 581  : 			{
; 582  : 				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  003ce	c7 43 18 0d 00
	00 c0		 mov	 DWORD PTR [ebx+24], -1073741811 ; c000000dH
$LN60@ProcessVol:

; 583  : 				Irp->IoStatus.Information = 0;

  003d5	83 63 1c 00	 and	 DWORD PTR [ebx+28], 0

; 584  : 				break; 

  003d9	e9 db 01 00 00	 jmp	 $LN11@ProcessVol
$LN32@ProcessVol:

; 585  : 			}
; 586  : 
; 587  : 			TCGetDosNameFromNumber (ntName, Extension->nDosDriveNo);

  003de	ff 77 14	 push	 DWORD PTR [edi+20]
  003e1	8d 85 7c fd ff
	ff		 lea	 eax, DWORD PTR _ntName$29977[ebp]
  003e7	50		 push	 eax
  003e8	e8 00 00 00 00	 call	 _TCGetDosNameFromNumber@8

; 588  : 			RtlInitUnicodeString (&ntUnicodeString, ntName);

  003ed	8d 85 7c fd ff
	ff		 lea	 eax, DWORD PTR _ntName$29977[ebp]
  003f3	50		 push	 eax
  003f4	8d 85 70 fd ff
	ff		 lea	 eax, DWORD PTR _ntUnicodeString$29976[ebp]
  003fa	50		 push	 eax
  003fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 589  : 
; 590  : 			outLength = FIELD_OFFSET(MOUNTDEV_SUGGESTED_LINK_NAME,Name) + ntUnicodeString.Length;

  00401	0f b7 bd 70 fd
	ff ff		 movzx	 edi, WORD PTR _ntUnicodeString$29976[ebp]

; 591  : 
; 592  : 			outputBuffer->UseOnlyIfThereAreNoOtherLinks = FALSE;

  00408	8b 85 78 fd ff
	ff		 mov	 eax, DWORD PTR _outputBuffer$29978[ebp]
  0040e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 593  : 			outputBuffer->NameLength = ntUnicodeString.Length;

  00411	66 8b 8d 70 fd
	ff ff		 mov	 cx, WORD PTR _ntUnicodeString$29976[ebp]
  00418	83 c7 04	 add	 edi, 4
  0041b	66 89 48 02	 mov	 WORD PTR [eax+2], cx

; 594  : 
; 595  : 			if(irpSp->Parameters.DeviceIoControl.OutputBufferLength < outLength)

  0041f	39 7e 04	 cmp	 DWORD PTR [esi+4], edi
  00422	73 09		 jae	 SHORT $LN31@ProcessVol

; 596  : 			{
; 597  : 				Irp->IoStatus.Information = sizeof (MOUNTDEV_SUGGESTED_LINK_NAME);

  00424	c7 43 1c 06 00
	00 00		 mov	 DWORD PTR [ebx+28], 6

; 598  : 				Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
; 599  : 				break;

  0042b	eb 74		 jmp	 SHORT $LN62@ProcessVol
$LN31@ProcessVol:

; 600  : 			}
; 601  : 
; 602  : 			RtlCopyMemory ((PCHAR)outputBuffer->Name,ntUnicodeString.Buffer, ntUnicodeString.Length);

  0042d	0f b7 8d 70 fd
	ff ff		 movzx	 ecx, WORD PTR _ntUnicodeString$29976[ebp]
  00434	51		 push	 ecx
  00435	ff b5 74 fd ff
	ff		 push	 DWORD PTR _ntUnicodeString$29976[ebp+4]
  0043b	83 c0 04	 add	 eax, 4
  0043e	50		 push	 eax

; 603  : 		
; 604  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 605  : 			Irp->IoStatus.Information = outLength;
; 606  : 
; 607  : 			Dump ("link = %ls\n",ntName);
; 608  : 		}
; 609  : 		break;

  0043f	eb 77		 jmp	 SHORT $LN63@ProcessVol
$LN41@ProcessVol:

; 500  : 	{
; 501  : 
; 502  : 	case IOCTL_MOUNTDEV_QUERY_DEVICE_NAME:
; 503  : 		if (!ValidateIOBufferSize (Irp, sizeof (MOUNTDEV_NAME), ValidateOutput))

  00441	6a 01		 push	 1
  00443	6a 04		 push	 4
  00445	53		 push	 ebx
  00446	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  0044b	85 c0		 test	 eax, eax

; 504  : 		{
; 505  : 			Irp->IoStatus.Information = sizeof (MOUNTDEV_NAME);
; 506  : 			Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
; 507  : 		}
; 508  : 		else

  0044d	74 4b		 je	 SHORT $LN61@ProcessVol

; 509  : 		{
; 510  : 			ULONG outLength;
; 511  : 			UNICODE_STRING ntUnicodeString;
; 512  : 			WCHAR ntName[256];
; 513  : 			PMOUNTDEV_NAME outputBuffer = (PMOUNTDEV_NAME) Irp->AssociatedIrp.SystemBuffer;

  0044f	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]

; 514  : 
; 515  : 			TCGetNTNameFromNumber (ntName, Extension->nDosDriveNo);

  00452	ff 77 14	 push	 DWORD PTR [edi+20]
  00455	89 85 78 fd ff
	ff		 mov	 DWORD PTR _outputBuffer$29945[ebp], eax
  0045b	8d 85 7c fd ff
	ff		 lea	 eax, DWORD PTR _ntName$29944[ebp]
  00461	50		 push	 eax
  00462	e8 00 00 00 00	 call	 _TCGetNTNameFromNumber@8

; 516  : 			RtlInitUnicodeString (&ntUnicodeString, ntName);

  00467	8d 85 7c fd ff
	ff		 lea	 eax, DWORD PTR _ntName$29944[ebp]
  0046d	50		 push	 eax
  0046e	8d 85 70 fd ff
	ff		 lea	 eax, DWORD PTR _ntUnicodeString$29943[ebp]
  00474	50		 push	 eax
  00475	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 517  : 
; 518  : 			outputBuffer->NameLength = ntUnicodeString.Length;

  0047b	66 8b 85 70 fd
	ff ff		 mov	 ax, WORD PTR _ntUnicodeString$29943[ebp]
  00482	8b 8d 78 fd ff
	ff		 mov	 ecx, DWORD PTR _outputBuffer$29945[ebp]
  00488	66 89 01	 mov	 WORD PTR [ecx], ax

; 519  : 			outLength = ntUnicodeString.Length + sizeof(USHORT);

  0048b	0f b7 85 70 fd
	ff ff		 movzx	 eax, WORD PTR _ntUnicodeString$29943[ebp]
  00492	8d 78 02	 lea	 edi, DWORD PTR [eax+2]

; 520  : 
; 521  : 			if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < outLength)

  00495	39 7e 04	 cmp	 DWORD PTR [esi+4], edi
  00498	73 13		 jae	 SHORT $LN38@ProcessVol
$LN61@ProcessVol:

; 522  : 			{
; 523  : 				Irp->IoStatus.Information = sizeof (MOUNTDEV_NAME);

  0049a	c7 43 1c 04 00
	00 00		 mov	 DWORD PTR [ebx+28], 4
$LN62@ProcessVol:

; 524  : 				Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

  004a1	c7 43 18 05 00
	00 80		 mov	 DWORD PTR [ebx+24], -2147483643 ; 80000005H

; 525  : 
; 526  : 				break;

  004a8	e9 0c 01 00 00	 jmp	 $LN11@ProcessVol
$LN38@ProcessVol:

; 527  : 			}
; 528  : 
; 529  : 			RtlCopyMemory ((PCHAR)outputBuffer->Name,ntUnicodeString.Buffer, ntUnicodeString.Length);

  004ad	50		 push	 eax
  004ae	ff b5 74 fd ff
	ff		 push	 DWORD PTR _ntUnicodeString$29943[ebp+4]
  004b4	83 c1 02	 add	 ecx, 2
  004b7	51		 push	 ecx
$LN63@ProcessVol:
  004b8	e8 00 00 00 00	 call	 _memcpy
  004bd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 530  : 
; 531  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  004c0	83 63 18 00	 and	 DWORD PTR [ebx+24], 0

; 532  : 			Irp->IoStatus.Information = outLength;

  004c4	89 7b 1c	 mov	 DWORD PTR [ebx+28], edi

; 533  : 
; 534  : 			Dump ("name = %ls\n",ntName);
; 535  : 		}
; 536  : 		break;

  004c7	e9 ed 00 00 00	 jmp	 $LN11@ProcessVol
$LN37@ProcessVol:

; 537  : 
; 538  : 	case IOCTL_MOUNTDEV_QUERY_UNIQUE_ID:
; 539  : 		if (!ValidateIOBufferSize (Irp, sizeof (MOUNTDEV_UNIQUE_ID), ValidateOutput))

  004cc	6a 01		 push	 1
  004ce	6a 04		 push	 4
  004d0	5e		 pop	 esi
  004d1	56		 push	 esi
  004d2	53		 push	 ebx
  004d3	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  004d8	85 c0		 test	 eax, eax
  004da	75 05		 jne	 SHORT $LN36@ProcessVol

; 540  : 		{
; 541  : 			Irp->IoStatus.Information = sizeof (MOUNTDEV_UNIQUE_ID);

  004dc	89 73 1c	 mov	 DWORD PTR [ebx+28], esi

; 542  : 			Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
; 543  : 		}
; 544  : 		else

  004df	eb c0		 jmp	 SHORT $LN62@ProcessVol
$LN36@ProcessVol:

; 545  : 		{
; 546  : 			ULONG outLength;
; 547  : 			UCHAR volId[128], tmp[] = { 0,0 };
; 548  : 			PMOUNTDEV_UNIQUE_ID outputBuffer = (PMOUNTDEV_UNIQUE_ID) Irp->AssociatedIrp.SystemBuffer;
; 549  : 
; 550  : 			strcpy (volId, TC_UNIQUE_ID_PREFIX); 
; 551  : 			tmp[0] = 'A' + (UCHAR) Extension->nDosDriveNo;

  004e1	8b 85 6c fd ff
	ff		 mov	 eax, DWORD PTR _Extension$GSCopy$[ebp]
  004e7	8a 40 14	 mov	 al, BYTE PTR [eax+20]
  004ea	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]
  004ed	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@FNODOBFM@
  004f2	8d bd 7c ff ff
	ff		 lea	 edi, DWORD PTR _volId$29960[ebp]
  004f8	a5		 movsd
  004f9	a5		 movsd
  004fa	a5		 movsd
  004fb	04 41		 add	 al, 65			; 00000041H
  004fd	88 85 78 fd ff
	ff		 mov	 BYTE PTR _tmp$29961[ebp], al

; 552  : 			strcat (volId, tmp);

  00503	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR _tmp$29961[ebp]
  00509	a5		 movsd
  0050a	c6 85 79 fd ff
	ff 00		 mov	 BYTE PTR _tmp$29961[ebp+1], 0
  00511	8b f0		 mov	 esi, eax
$LL54@ProcessVol:
  00513	8a 08		 mov	 cl, BYTE PTR [eax]
  00515	40		 inc	 eax
  00516	84 c9		 test	 cl, cl
  00518	75 f9		 jne	 SHORT $LL54@ProcessVol
  0051a	8d bd 7c ff ff
	ff		 lea	 edi, DWORD PTR _volId$29960[ebp]
  00520	2b c6		 sub	 eax, esi
  00522	4f		 dec	 edi
$LL55@ProcessVol:
  00523	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00526	47		 inc	 edi
  00527	84 c9		 test	 cl, cl
  00529	75 f8		 jne	 SHORT $LL55@ProcessVol
  0052b	8b c8		 mov	 ecx, eax
  0052d	c1 e9 02	 shr	 ecx, 2
  00530	f3 a5		 rep movsd
  00532	8b c8		 mov	 ecx, eax
  00534	83 e1 03	 and	 ecx, 3

; 553  : 			
; 554  : 			outputBuffer->UniqueIdLength = (USHORT) strlen (volId);

  00537	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _volId$29960[ebp]
  0053d	f3 a4		 rep movsb
  0053f	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$LL56@ProcessVol:
  00542	8a 08		 mov	 cl, BYTE PTR [eax]
  00544	40		 inc	 eax
  00545	84 c9		 test	 cl, cl
  00547	75 f9		 jne	 SHORT $LL56@ProcessVol
  00549	2b c6		 sub	 eax, esi
  0054b	66 89 02	 mov	 WORD PTR [edx], ax

; 555  : 			outLength = (ULONG) (strlen (volId) + sizeof (USHORT));

  0054e	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _volId$29960[ebp]
  00554	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$LL57@ProcessVol:
  00557	8a 08		 mov	 cl, BYTE PTR [eax]
  00559	40		 inc	 eax
  0055a	84 c9		 test	 cl, cl
  0055c	75 f9		 jne	 SHORT $LL57@ProcessVol
  0055e	2b c6		 sub	 eax, esi
  00560	8d 70 02	 lea	 esi, DWORD PTR [eax+2]

; 556  : 
; 557  : 			if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < outLength)

  00563	8b 85 74 fd ff
	ff		 mov	 eax, DWORD PTR _irpSp$[ebp]
  00569	39 70 04	 cmp	 DWORD PTR [eax+4], esi

; 558  : 			{
; 559  : 				Irp->IoStatus.Information = sizeof (MOUNTDEV_UNIQUE_ID);
; 560  : 				Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
; 561  : 				break;

  0056c	0f 82 28 ff ff
	ff		 jb	 $LN61@ProcessVol

; 562  : 			}
; 563  : 
; 564  : 			RtlCopyMemory ((PCHAR)outputBuffer->UniqueId, volId, strlen (volId));

  00572	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _volId$29960[ebp]
  00578	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
$LL58@ProcessVol:
  0057b	8a 08		 mov	 cl, BYTE PTR [eax]
  0057d	40		 inc	 eax
  0057e	84 c9		 test	 cl, cl
  00580	75 f9		 jne	 SHORT $LL58@ProcessVol
  00582	2b c7		 sub	 eax, edi
  00584	50		 push	 eax
  00585	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _volId$29960[ebp]
  0058b	50		 push	 eax
  0058c	83 c2 02	 add	 edx, 2
  0058f	52		 push	 edx
  00590	e8 00 00 00 00	 call	 _memcpy
  00595	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN64@ProcessVol:

; 565  : 
; 566  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00598	83 63 18 00	 and	 DWORD PTR [ebx+24], 0
$LN65@ProcessVol:

; 567  : 			Irp->IoStatus.Information = outLength;

  0059c	89 73 1c	 mov	 DWORD PTR [ebx+28], esi

; 568  : 
; 569  : 			Dump ("id = %s\n",volId);
; 570  : 		}
; 571  : 		break;

  0059f	eb 18		 jmp	 SHORT $LN11@ProcessVol
$LN12@ProcessVol:

; 737  : 
; 738  : 	case IOCTL_DISK_CHECK_VERIFY:
; 739  : 	case IOCTL_STORAGE_CHECK_VERIFY:
; 740  : 		{
; 741  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  005a1	33 c9		 xor	 ecx, ecx

; 742  : 			Irp->IoStatus.Information = 0;
; 743  : 
; 744  : 			if (irpSp->Parameters.DeviceIoControl.OutputBufferLength >= sizeof (ULONG))

  005a3	6a 04		 push	 4
  005a5	58		 pop	 eax
  005a6	89 4b 18	 mov	 DWORD PTR [ebx+24], ecx
  005a9	89 4b 1c	 mov	 DWORD PTR [ebx+28], ecx
  005ac	39 46 04	 cmp	 DWORD PTR [esi+4], eax
  005af	72 08		 jb	 SHORT $LN11@ProcessVol

; 745  : 			{
; 746  : 				*((ULONG *) Irp->AssociatedIrp.SystemBuffer) = 0;

  005b1	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]
  005b4	89 0a		 mov	 DWORD PTR [edx], ecx

; 747  : 				Irp->IoStatus.Information = sizeof (ULONG);

  005b6	89 43 1c	 mov	 DWORD PTR [ebx+28], eax
$LN11@ProcessVol:

; 791  : 	}
; 792  : 
; 793  : #ifdef DEBUG
; 794  : 	if (!NT_SUCCESS (Irp->IoStatus.Status))
; 795  : 	{
; 796  : 		Dump ("IOCTL error 0x%08x (0x%x %d)\n",
; 797  : 			Irp->IoStatus.Status,
; 798  : 			(int) (irpSp->Parameters.DeviceIoControl.IoControlCode >> 16),
; 799  : 			(int) ((irpSp->Parameters.DeviceIoControl.IoControlCode & 0x1FFF) >> 2));
; 800  : 	}
; 801  : #endif
; 802  : 
; 803  : 	return TCCompleteDiskIrp (Irp, Irp->IoStatus.Status, Irp->IoStatus.Information);

  005b9	ff 73 1c	 push	 DWORD PTR [ebx+28]
  005bc	ff 73 18	 push	 DWORD PTR [ebx+24]
  005bf	53		 push	 ebx
  005c0	e8 00 00 00 00	 call	 _TCCompleteDiskIrp@12
$LN44@ProcessVol:

; 804  : }

  005c5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005c8	5f		 pop	 edi
  005c9	5e		 pop	 esi
  005ca	33 cd		 xor	 ecx, ebp
  005cc	5b		 pop	 ebx
  005cd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005d2	c9		 leave
  005d3	c2 0c 00	 ret	 12			; 0000000cH
_ProcessVolumeDeviceControlIrp@12 ENDP
_TEXT	ENDS
PUBLIC	_TCStartThread@12
; Function compile flags: /Ogsp
;	COMDAT _TCStartThread@12
_TEXT	SEGMENT
_threadProc$ = 8					; size = 4
_threadArg$ = 12					; size = 4
_kThread$ = 16						; size = 4
_TCStartThread@12 PROC					; COMDAT

; 1588 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1589 : 	return TCStartThreadInProcess (threadProc, threadArg, kThread, NULL);

  00005	6a 00		 push	 0
  00007	ff 75 10	 push	 DWORD PTR _kThread$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR _threadArg$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR _threadProc$[ebp]
  00010	e8 00 00 00 00	 call	 _TCStartThreadInProcess@16

; 1590 : }

  00015	5d		 pop	 ebp
  00016	c2 0c 00	 ret	 12			; 0000000cH
_TCStartThread@12 ENDP
_TEXT	ENDS
PUBLIC	??_C@_19JHEHLFPM@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BA@CCLAPIHO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_VolumeThreadProc@4
EXTRN	_EncryptedIoQueueStop@4:PROC
EXTRN	__imp__IoReleaseRemoveLockEx@12:PROC
EXTRN	__imp_@ExfInterlockedRemoveHeadList@8:PROC
EXTRN	_TCCloseVolume@8:PROC
EXTRN	_EncryptedIoQueueStart@4:PROC
EXTRN	__imp__PsTerminateSystemThread@4:PROC
EXTRN	_TCOpenVolume@20:PROC
EXTRN	__imp__KeSetPriorityThread@8:PROC
;	COMDAT ??_C@_19JHEHLFPM@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$AA@FNODOBFM@
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
text$s	SEGMENT
??_C@_19JHEHLFPM@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$AA@FNODOBFM@ DB '\', 00H
	DB	'?', 00H, '?', 00H, '\', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BA@CCLAPIHO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BA@CCLAPIHO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
; File c:\users\public\desktop\projects\ciphershed\src\driver\ntdriver.c
text$s	ENDS
;	COMDAT _VolumeThreadProc@4
_TEXT	SEGMENT
tv375 = -8						; size = 4
_DeviceObject$ = -4					; size = 4
_irp$30578 = 8						; size = 4
_Context$ = 8						; size = 4
_VolumeThreadProc@4 PROC				; COMDAT

; 1768 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	51		 push	 ecx
  00007	53		 push	 ebx
  00008	56		 push	 esi

; 1769 : 	PTHREAD_BLOCK pThreadBlock = (PTHREAD_BLOCK) Context;
; 1770 : 	PDEVICE_OBJECT DeviceObject = pThreadBlock->DeviceObject;

  00009	8b 75 08	 mov	 esi, DWORD PTR _Context$[ebp]
  0000c	8b 06		 mov	 eax, DWORD PTR [esi]

; 1771 : 	PEXTENSION Extension = (PEXTENSION) DeviceObject->DeviceExtension;

  0000e	8b 58 28	 mov	 ebx, DWORD PTR [eax+40]
  00011	57		 push	 edi

; 1772 : 	BOOL bDevice;
; 1773 : 
; 1774 : 	/* Set thread priority to lowest realtime level. */
; 1775 : 	KeSetPriorityThread (KeGetCurrentThread (), LOW_REALTIME_PRIORITY);

  00012	6a 10		 push	 16			; 00000010H
  00014	89 45 fc	 mov	 DWORD PTR _DeviceObject$[ebp], eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeGetCurrentThread@0
  0001d	50		 push	 eax
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetPriorityThread@8

; 1776 : 
; 1777 : 	Dump ("Mount THREAD OPENING VOLUME BEGIN\n");
; 1778 : 
; 1779 : 	if (memcmp (pThreadBlock->mount->wszVolume, WIDE ("\\Device"), 14) != 0)

  00024	8b 86 20 02 00
	00		 mov	 eax, DWORD PTR [esi+544]
  0002a	6a 07		 push	 7
  0002c	83 c0 10	 add	 eax, 16			; 00000010H
  0002f	59		 pop	 ecx
  00030	33 d2		 xor	 edx, edx
  00032	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_1BA@CCLAPIHO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@
  00037	8b f0		 mov	 esi, eax
  00039	52		 push	 edx
  0003a	66 f3 a7	 repe cmpsw
  0003d	5f		 pop	 edi
  0003e	74 3d		 je	 SHORT $LN13@VolumeThre

; 1780 : 	{
; 1781 : 		wcscpy (pThreadBlock->wszMountVolume, WIDE ("\\??\\"));

  00040	8b 75 08	 mov	 esi, DWORD PTR _Context$[ebp]
  00043	8d 56 08	 lea	 edx, DWORD PTR [esi+8]
  00046	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_19JHEHLFPM@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$AA@FNODOBFM@
  0004b	89 55 f8	 mov	 DWORD PTR tv375[ebp], edx
  0004e	2b d0		 sub	 edx, eax
$LL16@VolumeThre:
  00050	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00053	66 89 0c 02	 mov	 WORD PTR [edx+eax], cx
  00057	40		 inc	 eax
  00058	40		 inc	 eax
  00059	66 3b cf	 cmp	 cx, di
  0005c	75 f2		 jne	 SHORT $LL16@VolumeThre

; 1782 : 		wcsncat (pThreadBlock->wszMountVolume, pThreadBlock->mount->wszVolume,
; 1783 : 			sizeof (pThreadBlock->wszMountVolume) / 2 - 5);

  0005e	8b 86 20 02 00
	00		 mov	 eax, DWORD PTR [esi+544]
  00064	68 07 01 00 00	 push	 263			; 00000107H
  00069	83 c0 10	 add	 eax, 16			; 00000010H
  0006c	50		 push	 eax
  0006d	ff 75 f8	 push	 DWORD PTR tv375[ebp]
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcsncat
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1784 : 		bDevice = FALSE;

  00079	33 c0		 xor	 eax, eax

; 1785 : 	}
; 1786 : 	else

  0007b	eb 24		 jmp	 SHORT $LN12@VolumeThre
$LN13@VolumeThre:

; 1787 : 	{
; 1788 : 		pThreadBlock->wszMountVolume[0] = 0;

  0007d	8b 4d 08	 mov	 ecx, DWORD PTR _Context$[ebp]
  00080	83 c1 08	 add	 ecx, 8

; 1789 : 		wcsncat (pThreadBlock->wszMountVolume, pThreadBlock->mount->wszVolume,
; 1790 : 			sizeof (pThreadBlock->wszMountVolume) / 2 - 1);

  00083	68 0b 01 00 00	 push	 267			; 0000010bH
  00088	50		 push	 eax
  00089	33 d2		 xor	 edx, edx
  0008b	51		 push	 ecx
  0008c	89 4d f8	 mov	 DWORD PTR tv375[ebp], ecx
  0008f	66 89 11	 mov	 WORD PTR [ecx], dx
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcsncat

; 1791 : 		bDevice = TRUE;

  00098	8b 75 08	 mov	 esi, DWORD PTR _Context$[ebp]
  0009b	33 c0		 xor	 eax, eax
  0009d	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a0	40		 inc	 eax
$LN12@VolumeThre:

; 1792 : 	}
; 1793 : 
; 1794 : 	Dump ("Mount THREAD request for File %ls DriveNumber %d Device = %d\n",
; 1795 : 	      pThreadBlock->wszMountVolume, pThreadBlock->mount->nDosDriveNo, bDevice);
; 1796 : 
; 1797 : 	pThreadBlock->ntCreateStatus = TCOpenVolume (DeviceObject,
; 1798 : 		Extension,
; 1799 : 		pThreadBlock->mount,
; 1800 : 		pThreadBlock->wszMountVolume,
; 1801 : 		bDevice);

  000a1	50		 push	 eax
  000a2	ff 75 f8	 push	 DWORD PTR tv375[ebp]
  000a5	ff b6 20 02 00
	00		 push	 DWORD PTR [esi+544]
  000ab	53		 push	 ebx
  000ac	ff 75 fc	 push	 DWORD PTR _DeviceObject$[ebp]
  000af	e8 00 00 00 00	 call	 _TCOpenVolume@20

; 1802 : 
; 1803 : 	if (!NT_SUCCESS (pThreadBlock->ntCreateStatus) || pThreadBlock->mount->nReturnCode != 0)

  000b4	3b c7		 cmp	 eax, edi
  000b6	89 46 04	 mov	 DWORD PTR [esi+4], eax
  000b9	7c 0a		 jl	 SHORT $LN10@VolumeThre
  000bb	8b 86 20 02 00
	00		 mov	 eax, DWORD PTR [esi+544]
  000c1	39 38		 cmp	 DWORD PTR [eax], edi
  000c3	74 13		 je	 SHORT $LN11@VolumeThre
$LN10@VolumeThre:

; 1804 : 	{
; 1805 : 		KeSetEvent (&Extension->keCreateEvent, 0, FALSE);

  000c5	57		 push	 edi
  000c6	57		 push	 edi
  000c7	8d 43 24	 lea	 eax, DWORD PTR [ebx+36]
  000ca	50		 push	 eax
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 1806 : 		PsTerminateSystemThread (STATUS_SUCCESS);

  000d1	57		 push	 edi
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsTerminateSystemThread@4
$LN11@VolumeThre:

; 1807 : 	}
; 1808 : 
; 1809 : 	// Start IO queue
; 1810 : 	Extension->Queue.IsFilterDevice = FALSE;
; 1811 : 	Extension->Queue.DeviceObject = DeviceObject;

  000d8	8b 4d fc	 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  000db	8d 83 a8 00 00
	00		 lea	 eax, DWORD PTR [ebx+168]
  000e1	89 08		 mov	 DWORD PTR [eax], ecx

; 1812 : 	Extension->Queue.CryptoInfo = Extension->cryptoInfo;

  000e3	8b 4b 60	 mov	 ecx, DWORD PTR [ebx+96]
  000e6	89 8b d0 00 00
	00		 mov	 DWORD PTR [ebx+208], ecx

; 1813 : 	Extension->Queue.HostFileHandle = Extension->hDeviceFile;

  000ec	8b 4b 54	 mov	 ecx, DWORD PTR [ebx+84]
  000ef	89 8b d4 00 00
	00		 mov	 DWORD PTR [ebx+212], ecx

; 1814 : 	Extension->Queue.VirtualDeviceLength = Extension->DiskLength;

  000f5	8b 4b 70	 mov	 ecx, DWORD PTR [ebx+112]
  000f8	89 8b d8 00 00
	00		 mov	 DWORD PTR [ebx+216], ecx
  000fe	8b 4b 74	 mov	 ecx, DWORD PTR [ebx+116]
  00101	89 8b dc 00 00
	00		 mov	 DWORD PTR [ebx+220], ecx

; 1815 : 	Extension->Queue.MaxReadAheadOffset.QuadPart = Extension->HostLength;

  00107	8b 4b 68	 mov	 ecx, DWORD PTR [ebx+104]
  0010a	89 8b e0 01 00
	00		 mov	 DWORD PTR [ebx+480], ecx
  00110	8b 4b 6c	 mov	 ecx, DWORD PTR [ebx+108]
  00113	89 bb e4 00 00
	00		 mov	 DWORD PTR [ebx+228], edi
  00119	89 8b e4 01 00
	00		 mov	 DWORD PTR [ebx+484], ecx

; 1816 : 
; 1817 : 	if (Extension->SecurityClientContextValid)

  0011f	39 bb 90 04 00
	00		 cmp	 DWORD PTR [ebx+1168], edi
  00125	74 0e		 je	 SHORT $LN9@VolumeThre

; 1818 : 		Extension->Queue.SecurityClientContext = &Extension->SecurityClientContext;

  00127	8d 8b 94 04 00
	00		 lea	 ecx, DWORD PTR [ebx+1172]
  0012d	89 8b e0 00 00
	00		 mov	 DWORD PTR [ebx+224], ecx

; 1819 : 	else

  00133	eb 06		 jmp	 SHORT $LN8@VolumeThre
$LN9@VolumeThre:

; 1820 : 		Extension->Queue.SecurityClientContext = NULL;

  00135	89 bb e0 00 00
	00		 mov	 DWORD PTR [ebx+224], edi
$LN8@VolumeThre:

; 1821 : 
; 1822 : 	pThreadBlock->ntCreateStatus = EncryptedIoQueueStart (&Extension->Queue);

  0013b	50		 push	 eax
  0013c	e8 00 00 00 00	 call	 _EncryptedIoQueueStart@4

; 1823 : 
; 1824 : 	if (!NT_SUCCESS (pThreadBlock->ntCreateStatus))

  00141	3b c7		 cmp	 eax, edi
  00143	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00146	7d 28		 jge	 SHORT $LN7@VolumeThre

; 1825 : 	{
; 1826 : 		TCCloseVolume (DeviceObject, Extension);

  00148	53		 push	 ebx
  00149	ff 75 fc	 push	 DWORD PTR _DeviceObject$[ebp]
  0014c	e8 00 00 00 00	 call	 _TCCloseVolume@8

; 1827 : 
; 1828 : 		pThreadBlock->mount->nReturnCode = ERR_OS_ERROR;

  00151	8b 86 20 02 00
	00		 mov	 eax, DWORD PTR [esi+544]

; 1829 : 		KeSetEvent (&Extension->keCreateEvent, 0, FALSE);

  00157	57		 push	 edi
  00158	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
  0015e	57		 push	 edi
  0015f	8d 43 24	 lea	 eax, DWORD PTR [ebx+36]
  00162	50		 push	 eax
  00163	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 1830 : 		PsTerminateSystemThread (STATUS_SUCCESS);

  00169	57		 push	 edi
  0016a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsTerminateSystemThread@4
$LN7@VolumeThre:

; 1831 : 	}
; 1832 : 
; 1833 : 	KeSetEvent (&Extension->keCreateEvent, 0, FALSE);

  00170	57		 push	 edi
  00171	57		 push	 edi
  00172	8d 43 24	 lea	 eax, DWORD PTR [ebx+36]
  00175	50		 push	 eax
  00176	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
  0017c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_@ExfInterlockedRemoveHeadList@8
$LL6@VolumeThre:

; 1834 : 	/* From this point on pThreadBlock cannot be used as it will have been released! */
; 1835 : 	pThreadBlock = NULL;
; 1836 : 
; 1837 : 	for (;;)
; 1838 : 	{
; 1839 : 		/* Wait for a request from the dispatch routines. */
; 1840 : 		KeWaitForSingleObject ((PVOID) & Extension->RequestSemaphore, Executive, KernelMode, FALSE, NULL);

  00182	57		 push	 edi
  00183	57		 push	 edi
  00184	57		 push	 edi
  00185	57		 push	 edi
  00186	8d 43 40	 lea	 eax, DWORD PTR [ebx+64]
  00189	50		 push	 eax
  0018a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 1841 : 
; 1842 : 		for (;;)
; 1843 : 		{
; 1844 : 			PIO_STACK_LOCATION irpSp;
; 1845 : 			PLIST_ENTRY request;
; 1846 : 			PIRP irp;
; 1847 : 
; 1848 : 			request = ExInterlockedRemoveHeadList (&Extension->ListEntry, &Extension->ListSpinLock);

  00190	eb 22		 jmp	 SHORT $LN28@VolumeThre
$LL4@VolumeThre:

; 1849 : 			if (request == NULL)
; 1850 : 				break;
; 1851 : 
; 1852 : 			irp = CONTAINING_RECORD (request, IRP, Tail.Overlay.ListEntry);

  00192	83 c0 a8	 add	 eax, -88		; ffffffa8H

; 1853 : 			irpSp = IoGetCurrentIrpStackLocation (irp);
; 1854 : 
; 1855 : 			ASSERT (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL);
; 1856 : 
; 1857 : 			ProcessVolumeDeviceControlIrp (DeviceObject, Extension, irp);

  00195	50		 push	 eax
  00196	53		 push	 ebx
  00197	ff 75 fc	 push	 DWORD PTR _DeviceObject$[ebp]
  0019a	89 45 08	 mov	 DWORD PTR _irp$30578[ebp], eax
  0019d	e8 00 00 00 00	 call	 _ProcessVolumeDeviceControlIrp@12

; 1858 : 			IoReleaseRemoveLock (&Extension->Queue.RemoveLock, irp);

  001a2	6a 18		 push	 24			; 00000018H
  001a4	ff 75 08	 push	 DWORD PTR _irp$30578[ebp]
  001a7	8d 83 18 01 00
	00		 lea	 eax, DWORD PTR [ebx+280]
  001ad	50		 push	 eax
  001ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12
$LN28@VolumeThre:
  001b4	8d 53 34	 lea	 edx, DWORD PTR [ebx+52]
  001b7	8d 4b 38	 lea	 ecx, DWORD PTR [ebx+56]
  001ba	ff d6		 call	 esi
  001bc	3b c7		 cmp	 eax, edi
  001be	75 d2		 jne	 SHORT $LL4@VolumeThre

; 1859 : 		}
; 1860 : 
; 1861 : 		if (Extension->bThreadShouldQuit)

  001c0	39 7b 1c	 cmp	 DWORD PTR [ebx+28], edi
  001c3	74 bd		 je	 SHORT $LL6@VolumeThre

; 1862 : 		{
; 1863 : 			Dump ("Closing volume\n");
; 1864 : 			EncryptedIoQueueStop (&Extension->Queue);

  001c5	8d 83 a8 00 00
	00		 lea	 eax, DWORD PTR [ebx+168]
  001cb	50		 push	 eax
  001cc	e8 00 00 00 00	 call	 _EncryptedIoQueueStop@4

; 1865 : 
; 1866 : 			TCCloseVolume (DeviceObject, Extension);

  001d1	53		 push	 ebx
  001d2	ff 75 fc	 push	 DWORD PTR _DeviceObject$[ebp]
  001d5	e8 00 00 00 00	 call	 _TCCloseVolume@8

; 1867 : 			PsTerminateSystemThread (STATUS_SUCCESS);

  001da	57		 push	 edi
  001db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsTerminateSystemThread@4
  001e1	eb 9f		 jmp	 SHORT $LL6@VolumeThre
_VolumeThreadProc@4 ENDP
_TEXT	ENDS
PUBLIC	_OnShutdownPending@0
; Function compile flags: /Ogsp
;	COMDAT _OnShutdownPending@0
_TEXT	SEGMENT
_unmount$ = -16						; size = 16
_OnShutdownPending@0 PROC				; COMDAT

; 2139 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 10	 sub	 esp, 16			; 00000010H
  00008	56		 push	 esi
  00009	57		 push	 edi

; 2140 : 	UNMOUNT_STRUCT unmount;
; 2141 : 	memset (&unmount, 0, sizeof (unmount));

  0000a	33 c0		 xor	 eax, eax
  0000c	8d 7d f0	 lea	 edi, DWORD PTR _unmount$[ebp]
  0000f	ab		 stosd
  00010	ab		 stosd
  00011	ab		 stosd
  00012	ab		 stosd

; 2142 : 	unmount.ignoreOpenFiles = TRUE;

  00013	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _unmount$[ebp+4], 1
  0001a	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH
  0001f	33 ff		 xor	 edi, edi
$LL5@OnShutdown:

; 2143 : 
; 2144 : 	while (SendDeviceIoControlRequest (RootDeviceObject, TC_IOCTL_DISMOUNT_ALL_VOLUMES, &unmount, sizeof (unmount), &unmount, sizeof (unmount)) == STATUS_INSUFFICIENT_RESOURCES || unmount.HiddenVolumeProtectionTriggered)

  00021	6a 10		 push	 16			; 00000010H
  00023	8d 45 f0	 lea	 eax, DWORD PTR _unmount$[ebp]
  00026	50		 push	 eax
  00027	6a 10		 push	 16			; 00000010H
  00029	50		 push	 eax
  0002a	68 14 20 22 00	 push	 2236436			; 00222014H
  0002f	ff 35 00 00 00
	00		 push	 DWORD PTR _RootDeviceObject
  00035	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  0003a	3b c6		 cmp	 eax, esi
  0003c	74 05		 je	 SHORT $LN3@OnShutdown
  0003e	39 7d f8	 cmp	 DWORD PTR _unmount$[ebp+8], edi
  00041	74 05		 je	 SHORT $LL2@OnShutdown
$LN3@OnShutdown:

; 2145 : 		unmount.HiddenVolumeProtectionTriggered = FALSE;

  00043	89 7d f8	 mov	 DWORD PTR _unmount$[ebp+8], edi
  00046	eb d9		 jmp	 SHORT $LL5@OnShutdown
$LL2@OnShutdown:

; 2146 : 
; 2147 : 	while (SendDeviceIoControlRequest (RootDeviceObject, TC_IOCTL_WIPE_PASSWORD_CACHE, NULL, 0, NULL, 0) == STATUS_INSUFFICIENT_RESOURCES);

  00048	57		 push	 edi
  00049	57		 push	 edi
  0004a	57		 push	 edi
  0004b	57		 push	 edi
  0004c	68 30 20 22 00	 push	 2236464			; 00222030H
  00051	ff 35 00 00 00
	00		 push	 DWORD PTR _RootDeviceObject
  00057	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  0005c	3b c6		 cmp	 eax, esi
  0005e	74 e8		 je	 SHORT $LL2@OnShutdown
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi

; 2148 : }

  00062	c9		 leave
  00063	c3		 ret	 0
_OnShutdownPending@0 ENDP
_TEXT	ENDS
PUBLIC	_ProbeRealDriveSize@8
EXTRN	__imp__KeQueryInterruptTime@0:PROC
; Function compile flags: /Ogsp
;	COMDAT _ProbeRealDriveSize@8
_TEXT	SEGMENT
_startTime$ = -20					; size = 8
_sysLength$ = -12					; size = 8
_sectorBuffer$ = -4					; size = 4
_driveDeviceObject$ = 8					; size = 4
_driveSize$ = 12					; size = 4
_ProbeRealDriveSize@8 PROC				; COMDAT

; 2268 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 14	 sub	 esp, 20			; 00000014H

; 2269 : 	NTSTATUS status;
; 2270 : 	LARGE_INTEGER sysLength;
; 2271 : 	LARGE_INTEGER offset;
; 2272 : 	byte *sectorBuffer;
; 2273 : 	ULONGLONG startTime;
; 2274 : 
; 2275 : 	if (!UserCanAccessDriveDevice())

  00008	e8 00 00 00 00	 call	 _UserCanAccessDriveDevice@0
  0000d	85 c0		 test	 eax, eax
  0000f	75 07		 jne	 SHORT $LN9@ProbeRealD

; 2276 : 		return STATUS_ACCESS_DENIED;

  00011	b8 22 00 00 c0	 mov	 eax, -1073741790	; c0000022H
  00016	eb 24		 jmp	 SHORT $LN4@ProbeRealD
$LN9@ProbeRealD:
  00018	56		 push	 esi
  00019	57		 push	 edi

; 2277 : 
; 2278 : 	sectorBuffer = TCalloc (TC_SECTOR_SIZE_BIOS);

  0001a	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0001f	be 00 02 00 00	 mov	 esi, 512		; 00000200H
  00024	56		 push	 esi
  00025	33 ff		 xor	 edi, edi
  00027	57		 push	 edi
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0002e	89 45 fc	 mov	 DWORD PTR _sectorBuffer$[ebp], eax

; 2279 : 	if (!sectorBuffer)

  00031	3b c7		 cmp	 eax, edi
  00033	75 0b		 jne	 SHORT $LN8@ProbeRealD

; 2280 : 		return STATUS_INSUFFICIENT_RESOURCES;

  00035	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
$LN19@ProbeRealD:
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
$LN4@ProbeRealD:

; 2312 : 			TCfree (sectorBuffer);
; 2313 : 			return STATUS_TIMEOUT;
; 2314 : 		}
; 2315 : 	}
; 2316 : }

  0003c	c9		 leave
  0003d	c2 08 00	 ret	 8
$LN8@ProbeRealD:
  00040	53		 push	 ebx

; 2281 : 
; 2282 : 	status = SendDeviceIoControlRequest (driveDeviceObject, IOCTL_DISK_GET_LENGTH_INFO,
; 2283 : 		NULL, 0, &sysLength, sizeof (sysLength));

  00041	6a 08		 push	 8
  00043	8d 45 f4	 lea	 eax, DWORD PTR _sysLength$[ebp]
  00046	50		 push	 eax
  00047	57		 push	 edi
  00048	57		 push	 edi
  00049	68 5c 40 07 00	 push	 475228			; 0007405cH
  0004e	ff 75 08	 push	 DWORD PTR _driveDeviceObject$[ebp]
  00051	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24

; 2284 : 
; 2285 : 	if (!NT_SUCCESS (status))

  00056	3b c7		 cmp	 eax, edi
  00058	7d 15		 jge	 SHORT $LN7@ProbeRealD
  0005a	8b f0		 mov	 esi, eax
$LN16@ProbeRealD:

; 2286 : 	{
; 2287 : 		Dump ("Failed to get drive size - error %x\n", status);
; 2288 : 		TCfree (sectorBuffer);

  0005c	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00061	ff 75 fc	 push	 DWORD PTR _sectorBuffer$[ebp]
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 2289 : 		return status;

  0006a	8b c6		 mov	 eax, esi
  0006c	5b		 pop	 ebx
  0006d	eb cb		 jmp	 SHORT $LN19@ProbeRealD
$LN7@ProbeRealD:

; 2290 : 	}
; 2291 : 
; 2292 : 	startTime = KeQueryInterruptTime ();

  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeQueryInterruptTime@0

; 2293 : 	for (offset.QuadPart = sysLength.QuadPart; ; offset.QuadPart += TC_SECTOR_SIZE_BIOS)

  00075	8b 7d f4	 mov	 edi, DWORD PTR _sysLength$[ebp]
  00078	8b 5d f8	 mov	 ebx, DWORD PTR _sysLength$[ebp+4]
  0007b	89 45 ec	 mov	 DWORD PTR _startTime$[ebp], eax
  0007e	89 55 f0	 mov	 DWORD PTR _startTime$[ebp+4], edx
$LL6@ProbeRealD:

; 2294 : 	{
; 2295 : 		status = TCReadDevice (driveDeviceObject, sectorBuffer, offset, TC_SECTOR_SIZE_BIOS);

  00081	56		 push	 esi
  00082	53		 push	 ebx
  00083	57		 push	 edi
  00084	ff 75 fc	 push	 DWORD PTR _sectorBuffer$[ebp]
  00087	ff 75 08	 push	 DWORD PTR _driveDeviceObject$[ebp]
  0008a	e8 00 00 00 00	 call	 _TCReadDevice@20

; 2296 : 		
; 2297 : 		if (NT_SUCCESS (status))

  0008f	85 c0		 test	 eax, eax
  00091	7c 32		 jl	 SHORT $LN18@ProbeRealD

; 2298 : 			status = TCWriteDevice (driveDeviceObject, sectorBuffer, offset, TC_SECTOR_SIZE_BIOS);

  00093	56		 push	 esi
  00094	53		 push	 ebx
  00095	57		 push	 edi
  00096	ff 75 fc	 push	 DWORD PTR _sectorBuffer$[ebp]
  00099	ff 75 08	 push	 DWORD PTR _driveDeviceObject$[ebp]
  0009c	e8 00 00 00 00	 call	 _TCWriteDevice@20

; 2299 : 
; 2300 : 		if (!NT_SUCCESS (status))

  000a1	85 c0		 test	 eax, eax
  000a3	7c 20		 jl	 SHORT $LN18@ProbeRealD

; 2303 : 			Dump ("Real drive size = %I64d bytes (%I64d hidden)\n", driveSize->QuadPart, driveSize->QuadPart - sysLength.QuadPart);
; 2304 : 			TCfree (sectorBuffer);
; 2305 : 			return STATUS_SUCCESS;
; 2306 : 		}
; 2307 : 
; 2308 : 		if (KeQueryInterruptTime() - startTime > 3ULL * 60 * 1000 * 1000 * 10)

  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeQueryInterruptTime@0
  000ab	2b 45 ec	 sub	 eax, DWORD PTR _startTime$[ebp]
  000ae	1b 55 f0	 sbb	 edx, DWORD PTR _startTime$[ebp+4]
  000b1	85 d2		 test	 edx, edx
  000b3	77 1c		 ja	 SHORT $LN15@ProbeRealD
  000b5	72 07		 jb	 SHORT $LN17@ProbeRealD
  000b7	3d 00 d2 49 6b	 cmp	 eax, 1800000000		; 6b49d200H
  000bc	77 13		 ja	 SHORT $LN15@ProbeRealD
$LN17@ProbeRealD:

; 2293 : 	for (offset.QuadPart = sysLength.QuadPart; ; offset.QuadPart += TC_SECTOR_SIZE_BIOS)

  000be	03 fe		 add	 edi, esi
  000c0	83 d3 00	 adc	 ebx, 0
  000c3	eb bc		 jmp	 SHORT $LL6@ProbeRealD
$LN18@ProbeRealD:

; 2301 : 		{
; 2302 : 			driveSize->QuadPart = offset.QuadPart;

  000c5	8b 45 0c	 mov	 eax, DWORD PTR _driveSize$[ebp]
  000c8	89 38		 mov	 DWORD PTR [eax], edi
  000ca	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  000cd	33 f6		 xor	 esi, esi
  000cf	eb 8b		 jmp	 SHORT $LN16@ProbeRealD
$LN15@ProbeRealD:

; 2309 : 		{
; 2310 : 			// Abort if probing for more than 3 minutes
; 2311 : 			driveSize->QuadPart = sysLength.QuadPart;

  000d1	8b 4d f4	 mov	 ecx, DWORD PTR _sysLength$[ebp]
  000d4	8b 45 0c	 mov	 eax, DWORD PTR _driveSize$[ebp]
  000d7	89 08		 mov	 DWORD PTR [eax], ecx
  000d9	8b 4d f8	 mov	 ecx, DWORD PTR _sysLength$[ebp+4]
  000dc	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  000df	be 02 01 00 00	 mov	 esi, 258		; 00000102H
  000e4	e9 73 ff ff ff	 jmp	 $LN16@ProbeRealD
_ProbeRealDriveSize@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@FNODOBFM@			;  ?? ::FNODOBFM::`string'
PUBLIC	_UnmountDevice@12
EXTRN	__imp__IoReleaseRemoveLockAndWaitEx@12:PROC
EXTRN	__imp__IoAcquireRemoveLockEx@20:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_00CNPNBAHC@?$AA@FNODOBFM@ DB 00H			;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
text$s	ENDS
;	COMDAT _UnmountDevice@12
_TEXT	SEGMENT
_ntfsData$30986 = -108					; size = 96
_dismountRetry$30984 = -12				; size = 4
_volumeHandle$ = -8					; size = 4
_volumeFileObject$ = -4					; size = 4
_unmountRequest$ = 8					; size = 4
_deviceObject$ = 12					; size = 4
_ignoreOpenFiles$ = 16					; size = 4
_UnmountDevice@12 PROC					; COMDAT

; 2698 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 2699 : 	PEXTENSION extension = deviceObject->DeviceExtension;

  00005	8b 45 0c	 mov	 eax, DWORD PTR _deviceObject$[ebp]
  00008	83 ec 6c	 sub	 esp, 108		; 0000006cH
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	8b 70 28	 mov	 esi, DWORD PTR [eax+40]
  00010	57		 push	 edi

; 2700 : 	NTSTATUS ntStatus;
; 2701 : 	HANDLE volumeHandle;
; 2702 : 	PFILE_OBJECT volumeFileObject;
; 2703 : 
; 2704 : 	Dump ("UnmountDevice %d\n", extension->nDosDriveNo);
; 2705 : 
; 2706 : 	ntStatus = TCOpenFsVolume (extension, &volumeHandle, &volumeFileObject);

  00011	8d 45 fc	 lea	 eax, DWORD PTR _volumeFileObject$[ebp]
  00014	50		 push	 eax
  00015	8d 45 f8	 lea	 eax, DWORD PTR _volumeHandle$[ebp]
  00018	50		 push	 eax
  00019	56		 push	 esi
  0001a	e8 00 00 00 00	 call	 _TCOpenFsVolume@12

; 2707 : 
; 2708 : 	if (NT_SUCCESS (ntStatus))

  0001f	33 db		 xor	 ebx, ebx
  00021	43		 inc	 ebx
  00022	85 c0		 test	 eax, eax
  00024	0f 8c 9a 00 00
	00		 jl	 $LN16@UnmountDev

; 2709 : 	{
; 2710 : 		int dismountRetry;
; 2711 : 
; 2712 : 		// Dismounting a writable NTFS filesystem prevents the driver from being unloaded on Windows 7
; 2713 : 		if (IsOSAtLeast (WIN_7) && !extension->bReadOnly)

  0002a	6a 0d		 push	 13			; 0000000dH
  0002c	e8 00 00 00 00	 call	 _IsOSAtLeast@4
  00031	33 ff		 xor	 edi, edi
  00033	85 c0		 test	 eax, eax
  00035	74 27		 je	 SHORT $LN14@UnmountDev
  00037	39 be 48 02 00
	00		 cmp	 DWORD PTR [esi+584], edi
  0003d	75 1f		 jne	 SHORT $LN14@UnmountDev

; 2714 : 		{
; 2715 : 			NTFS_VOLUME_DATA_BUFFER ntfsData;
; 2716 : 
; 2717 : 			if (NT_SUCCESS (TCFsctlCall (volumeFileObject, FSCTL_GET_NTFS_VOLUME_DATA, NULL, 0, &ntfsData, sizeof (ntfsData))))

  0003f	6a 60		 push	 96			; 00000060H
  00041	8d 45 94	 lea	 eax, DWORD PTR _ntfsData$30986[ebp]
  00044	50		 push	 eax
  00045	57		 push	 edi
  00046	57		 push	 edi
  00047	68 64 00 09 00	 push	 589924			; 00090064H
  0004c	ff 75 fc	 push	 DWORD PTR _volumeFileObject$[ebp]
  0004f	e8 00 00 00 00	 call	 _TCFsctlCall@24
  00054	85 c0		 test	 eax, eax
  00056	7c 06		 jl	 SHORT $LN14@UnmountDev

; 2718 : 				DriverUnloadDisabled = TRUE;

  00058	89 1d 00 00 00
	00		 mov	 DWORD PTR _DriverUnloadDisabled, ebx
$LN14@UnmountDev:

; 2719 : 		}
; 2720 : 
; 2721 : 		// Lock volume
; 2722 : 		ntStatus = TCFsctlCall (volumeFileObject, FSCTL_LOCK_VOLUME, NULL, 0, NULL, 0);

  0005e	57		 push	 edi
  0005f	57		 push	 edi
  00060	57		 push	 edi
  00061	57		 push	 edi
  00062	68 18 00 09 00	 push	 589848			; 00090018H
  00067	ff 75 fc	 push	 DWORD PTR _volumeFileObject$[ebp]
  0006a	e8 00 00 00 00	 call	 _TCFsctlCall@24

; 2723 : 		Dump ("FSCTL_LOCK_VOLUME returned %X\n", ntStatus);
; 2724 : 
; 2725 : 		if (!NT_SUCCESS (ntStatus) && !ignoreOpenFiles)

  0006f	85 c0		 test	 eax, eax
  00071	7d 18		 jge	 SHORT $LN13@UnmountDev
  00073	39 7d 10	 cmp	 DWORD PTR _ignoreOpenFiles$[ebp], edi
  00076	75 13		 jne	 SHORT $LN13@UnmountDev
$LN23@UnmountDev:

; 2726 : 		{
; 2727 : 			TCCloseFsVolume (volumeHandle, volumeFileObject);

  00078	ff 75 fc	 push	 DWORD PTR _volumeFileObject$[ebp]
  0007b	ff 75 f8	 push	 DWORD PTR _volumeHandle$[ebp]
  0007e	e8 00 00 00 00	 call	 _TCCloseFsVolume@8
$LN26@UnmountDev:

; 2728 : 			return ERR_FILES_OPEN;

  00083	6a 06		 push	 6
  00085	58		 pop	 eax
  00086	e9 be 00 00 00	 jmp	 $LN17@UnmountDev
$LN13@UnmountDev:

; 2729 : 		}
; 2730 : 
; 2731 : 		// Dismount volume
; 2732 : 		for (dismountRetry = 0; dismountRetry < 200; ++dismountRetry)

  0008b	89 7d f4	 mov	 DWORD PTR _dismountRetry$30984[ebp], edi
$LL12@UnmountDev:

; 2733 : 		{
; 2734 : 			ntStatus = TCFsctlCall (volumeFileObject, FSCTL_DISMOUNT_VOLUME, NULL, 0, NULL, 0);

  0008e	57		 push	 edi
  0008f	57		 push	 edi
  00090	57		 push	 edi
  00091	57		 push	 edi
  00092	68 20 00 09 00	 push	 589856			; 00090020H
  00097	ff 75 fc	 push	 DWORD PTR _volumeFileObject$[ebp]
  0009a	e8 00 00 00 00	 call	 _TCFsctlCall@24

; 2735 : 			Dump ("FSCTL_DISMOUNT_VOLUME returned %X\n", ntStatus);
; 2736 : 
; 2737 : 			if (NT_SUCCESS (ntStatus) || ntStatus == STATUS_VOLUME_DISMOUNTED)

  0009f	3b c7		 cmp	 eax, edi
  000a1	7d 2b		 jge	 SHORT $LN4@UnmountDev
  000a3	3d 6e 02 00 c0	 cmp	 eax, -1073741202	; c000026eH
  000a8	74 24		 je	 SHORT $LN4@UnmountDev

; 2738 : 				break;
; 2739 : 
; 2740 : 			if (!ignoreOpenFiles)

  000aa	39 7d 10	 cmp	 DWORD PTR _ignoreOpenFiles$[ebp], edi
  000ad	74 c9		 je	 SHORT $LN23@UnmountDev

; 2741 : 			{
; 2742 : 				TCCloseFsVolume (volumeHandle, volumeFileObject);
; 2743 : 				return ERR_FILES_OPEN;
; 2744 : 			}
; 2745 : 
; 2746 : 			TCSleep (100);

  000af	6a 64		 push	 100			; 00000064H
  000b1	e8 00 00 00 00	 call	 _TCSleep@4
  000b6	ff 45 f4	 inc	 DWORD PTR _dismountRetry$30984[ebp]
  000b9	81 7d f4 c8 00
	00 00		 cmp	 DWORD PTR _dismountRetry$30984[ebp], 200 ; 000000c8H
  000c0	7c cc		 jl	 SHORT $LL12@UnmountDev

; 2738 : 				break;
; 2739 : 
; 2740 : 			if (!ignoreOpenFiles)

  000c2	eb 0a		 jmp	 SHORT $LN4@UnmountDev
$LN16@UnmountDev:

; 2747 : 		}
; 2748 : 	}
; 2749 : 	else 
; 2750 : 	{
; 2751 : 		// Volume cannot be opened => force dismount if allowed
; 2752 : 		if (!ignoreOpenFiles)

  000c4	33 ff		 xor	 edi, edi
  000c6	39 7d 10	 cmp	 DWORD PTR _ignoreOpenFiles$[ebp], edi

; 2753 : 			return ERR_FILES_OPEN;

  000c9	74 b8		 je	 SHORT $LN26@UnmountDev

; 2754 : 		else
; 2755 : 			volumeHandle = NULL;

  000cb	89 7d f8	 mov	 DWORD PTR _volumeHandle$[ebp], edi
$LN4@UnmountDev:

; 2756 : 	}
; 2757 : 
; 2758 : 	if (extension->bMountManager)

  000ce	39 be 58 02 00
	00		 cmp	 DWORD PTR [esi+600], edi
  000d4	74 08		 je	 SHORT $LN3@UnmountDev

; 2759 : 		MountManagerUnmount (extension->nDosDriveNo);

  000d6	ff 76 14	 push	 DWORD PTR [esi+20]
  000d9	e8 00 00 00 00	 call	 _MountManagerUnmount@4
$LN3@UnmountDev:

; 2760 : 
; 2761 : 	// We always remove symbolic link as mount manager might fail to do so
; 2762 : 	RemoveDriveLink (extension->nDosDriveNo);

  000de	ff 76 14	 push	 DWORD PTR [esi+20]
  000e1	e8 00 00 00 00	 call	 _RemoveDriveLink@4

; 2763 : 
; 2764 : 	extension->bShuttingDown = TRUE;
; 2765 : 
; 2766 : 	ntStatus = IoAcquireRemoveLock (&extension->Queue.RemoveLock, NULL);

  000e6	6a 18		 push	 24			; 00000018H
  000e8	53		 push	 ebx
  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@FNODOBFM@
  000ee	89 5e 18	 mov	 DWORD PTR [esi+24], ebx
  000f1	57		 push	 edi
  000f2	81 c6 18 01 00
	00		 add	 esi, 280		; 00000118H
  000f8	56		 push	 esi
  000f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAcquireRemoveLockEx@20

; 2767 : 	ASSERT (NT_SUCCESS (ntStatus));
; 2768 : 	IoReleaseRemoveLockAndWait (&extension->Queue.RemoveLock, NULL);

  000ff	6a 18		 push	 24			; 00000018H
  00101	57		 push	 edi
  00102	56		 push	 esi
  00103	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockAndWaitEx@12

; 2769 : 
; 2770 : 	if (volumeHandle != NULL)

  00109	39 7d f8	 cmp	 DWORD PTR _volumeHandle$[ebp], edi
  0010c	74 0b		 je	 SHORT $LN2@UnmountDev

; 2771 : 		TCCloseFsVolume (volumeHandle, volumeFileObject);

  0010e	ff 75 fc	 push	 DWORD PTR _volumeFileObject$[ebp]
  00111	ff 75 f8	 push	 DWORD PTR _volumeHandle$[ebp]
  00114	e8 00 00 00 00	 call	 _TCCloseFsVolume@8
$LN2@UnmountDev:

; 2772 : 
; 2773 : 	if (unmountRequest)

  00119	8b 55 08	 mov	 edx, DWORD PTR _unmountRequest$[ebp]

; 2774 : 	{
; 2775 : 		PCRYPTO_INFO cryptoInfo = ((PEXTENSION) deviceObject->DeviceExtension)->cryptoInfo;

  0011c	8b 4d 0c	 mov	 ecx, DWORD PTR _deviceObject$[ebp]
  0011f	3b d7		 cmp	 edx, edi
  00121	74 1b		 je	 SHORT $LN1@UnmountDev
  00123	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00126	8b 40 60	 mov	 eax, DWORD PTR [eax+96]

; 2776 : 		unmountRequest->HiddenVolumeProtectionTriggered = (cryptoInfo->bProtectHiddenVolume && cryptoInfo->bHiddenVolProtectionAction);

  00129	39 b8 00 44 00
	00		 cmp	 DWORD PTR [eax+17408], edi
  0012f	74 0a		 je	 SHORT $LN19@UnmountDev
  00131	39 b8 04 44 00
	00		 cmp	 DWORD PTR [eax+17412], edi
  00137	74 02		 je	 SHORT $LN19@UnmountDev
  00139	8b fb		 mov	 edi, ebx
$LN19@UnmountDev:
  0013b	89 7a 08	 mov	 DWORD PTR [edx+8], edi
$LN1@UnmountDev:

; 2777 : 	}
; 2778 : 
; 2779 : 	TCDeleteDeviceObject (deviceObject, (PEXTENSION) deviceObject->DeviceExtension);

  0013e	ff 71 28	 push	 DWORD PTR [ecx+40]
  00141	51		 push	 ecx
  00142	e8 00 00 00 00	 call	 _TCDeleteDeviceObject@8

; 2780 : 	return 0;

  00147	33 c0		 xor	 eax, eax
$LN17@UnmountDev:
  00149	5f		 pop	 edi
  0014a	5e		 pop	 esi
  0014b	5b		 pop	 ebx

; 2781 : }

  0014c	c9		 leave
  0014d	c2 0c 00	 ret	 12			; 0000000cH
_UnmountDevice@12 ENDP
_TEXT	ENDS
PUBLIC	_UnmountAllDevices@8
; Function compile flags: /Ogsp
;	COMDAT _UnmountAllDevices@8
_TEXT	SEGMENT
_status$ = -4						; size = 4
_unmountRequest$ = 8					; size = 4
_ignoreOpenFiles$ = 12					; size = 4
_UnmountAllDevices@8 PROC				; COMDAT

; 2809 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 2810 : 	NTSTATUS status = 0;
; 2811 : 	PDEVICE_OBJECT ListDevice;
; 2812 : 	int maxUniqueId = LastUniqueVolumeId;
; 2813 : 
; 2814 : 	Dump ("Unmounting all volumes\n");
; 2815 : 
; 2816 : 	if (unmountRequest)

  00006	8b 45 08	 mov	 eax, DWORD PTR _unmountRequest$[ebp]
  00009	83 65 fc 00	 and	 DWORD PTR _status$[ebp], 0
  0000d	53		 push	 ebx
  0000e	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _LastUniqueVolumeId
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	85 c0		 test	 eax, eax
  00018	74 04		 je	 SHORT $LL5@UnmountAll

; 2817 : 		unmountRequest->HiddenVolumeProtectionTriggered = FALSE;

  0001a	83 60 08 00	 and	 DWORD PTR [eax+8], 0
$LL5@UnmountAll:

; 2818 : 
; 2819 : 	// Dismount volumes in the reverse order they were mounted to properly dismount nested volumes
; 2820 : 	while ((ListDevice = FindVolumeWithHighestUniqueId (maxUniqueId)) != NULL)

  0001e	33 ff		 xor	 edi, edi
  00020	83 ca ff	 or	 edx, -1
  00023	33 f6		 xor	 esi, esi
$LL28@UnmountAll:
  00025	56		 push	 esi
  00026	e8 00 00 00 00	 call	 _GetVirtualVolumeDeviceObject@4
  0002b	85 c0		 test	 eax, eax
  0002d	74 12		 je	 SHORT $LN14@UnmountAll
  0002f	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00032	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00035	3b ca		 cmp	 ecx, edx
  00037	7e 08		 jle	 SHORT $LN14@UnmountAll
  00039	3b cb		 cmp	 ecx, ebx
  0003b	7f 04		 jg	 SHORT $LN14@UnmountAll
  0003d	8b d1		 mov	 edx, ecx
  0003f	8b f8		 mov	 edi, eax
$LN14@UnmountAll:
  00041	46		 inc	 esi
  00042	83 fe 19	 cmp	 esi, 25			; 00000019H
  00045	7e de		 jle	 SHORT $LL28@UnmountAll
  00047	85 ff		 test	 edi, edi
  00049	74 3d		 je	 SHORT $LN20@UnmountAll

; 2821 : 	{
; 2822 : 		PEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;

  0004b	8b 77 28	 mov	 esi, DWORD PTR [edi+40]

; 2823 : 		maxUniqueId = ListExtension->UniqueVolumeId - 1;

  0004e	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]

; 2824 : 
; 2825 : 		if (IsVolumeAccessibleByCurrentUser (ListExtension))

  00051	56		 push	 esi
  00052	4b		 dec	 ebx
  00053	e8 00 00 00 00	 call	 _IsVolumeAccessibleByCurrentUser@4
  00058	85 c0		 test	 eax, eax
  0005a	74 c2		 je	 SHORT $LL5@UnmountAll

; 2826 : 		{
; 2827 : 			NTSTATUS ntStatus;
; 2828 : 
; 2829 : 			if (unmountRequest)

  0005c	8b 45 08	 mov	 eax, DWORD PTR _unmountRequest$[ebp]
  0005f	85 c0		 test	 eax, eax
  00061	74 05		 je	 SHORT $LN2@UnmountAll

; 2830 : 				unmountRequest->nDosDriveNo = ListExtension->nDosDriveNo;

  00063	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00066	89 08		 mov	 DWORD PTR [eax], ecx
$LN2@UnmountAll:

; 2831 : 
; 2832 : 			ntStatus = UnmountDevice (unmountRequest, ListDevice, ignoreOpenFiles);

  00068	ff 75 0c	 push	 DWORD PTR _ignoreOpenFiles$[ebp]
  0006b	57		 push	 edi
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 _UnmountDevice@12

; 2833 : 			status = ntStatus == 0 ? status : ntStatus;

  00072	85 c0		 test	 eax, eax
  00074	74 03		 je	 SHORT $LN10@UnmountAll
  00076	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax
$LN10@UnmountAll:

; 2834 : 
; 2835 : 			if (unmountRequest && unmountRequest->HiddenVolumeProtectionTriggered)

  00079	83 7d 08 00	 cmp	 DWORD PTR _unmountRequest$[ebp], 0
  0007d	74 9f		 je	 SHORT $LL5@UnmountAll
  0007f	8b 45 08	 mov	 eax, DWORD PTR _unmountRequest$[ebp]
  00082	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0

; 2836 : 				break;
; 2837 : 		}
; 2838 : 	}

  00086	74 96		 je	 SHORT $LL5@UnmountAll
$LN20@UnmountAll:

; 2839 : 
; 2840 : 	return status;

  00088	8b 45 fc	 mov	 eax, DWORD PTR _status$[ebp]
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx

; 2841 : }

  0008e	c9		 leave
  0008f	c2 08 00	 ret	 8
_UnmountAllDevices@8 ENDP
_TEXT	ENDS
PUBLIC	_TCStartVolumeThread@12
EXTRN	__imp__SeCreateClientSecurity@16:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCStartVolumeThread@12
_TEXT	SEGMENT
_threadObjAttributes$ = -40				; size = 24
_qos$ = -16						; size = 12
_hThread$ = -4						; size = 4
_ntStatus$ = 8						; size = 4
_DeviceObject$ = 8					; size = 4
_Extension$ = 12					; size = 4
_mount$ = 16						; size = 4
_TCStartVolumeThread@12 PROC				; COMDAT

; 1640 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 28	 sub	 esp, 40			; 00000028H
  00008	53		 push	 ebx
  00009	57		 push	 edi

; 1641 : 	PTHREAD_BLOCK pThreadBlock = TCalloc (sizeof (THREAD_BLOCK));

  0000a	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0000f	68 24 02 00 00	 push	 548			; 00000224H
  00014	33 db		 xor	 ebx, ebx
  00016	53		 push	 ebx
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0001d	8b f8		 mov	 edi, eax

; 1642 : 	HANDLE hThread;
; 1643 : 	NTSTATUS ntStatus;
; 1644 : 	OBJECT_ATTRIBUTES threadObjAttributes;
; 1645 : 	SECURITY_QUALITY_OF_SERVICE qos;
; 1646 : 
; 1647 : 	Dump ("Starting thread...\n");
; 1648 : 
; 1649 : 	if (pThreadBlock == NULL)

  0001f	3b fb		 cmp	 edi, ebx
  00021	75 0a		 jne	 SHORT $LN5@TCStartVol

; 1650 : 	{
; 1651 : 		return STATUS_INSUFFICIENT_RESOURCES;

  00023	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  00028	e9 de 00 00 00	 jmp	 $LN6@TCStartVol
$LN5@TCStartVol:

; 1652 : 	}
; 1653 : 	else
; 1654 : 	{
; 1655 : 		pThreadBlock->DeviceObject = DeviceObject;

  0002d	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00030	89 07		 mov	 DWORD PTR [edi], eax

; 1656 : 		pThreadBlock->mount = mount;

  00032	8b 45 10	 mov	 eax, DWORD PTR _mount$[ebp]
  00035	89 87 20 02 00
	00		 mov	 DWORD PTR [edi+544], eax
  0003b	56		 push	 esi

; 1657 : 	}
; 1658 : 
; 1659 : 	qos.Length = sizeof (qos);

  0003c	c7 45 f0 0c 00
	00 00		 mov	 DWORD PTR _qos$[ebp], 12 ; 0000000cH

; 1660 : 	qos.ContextTrackingMode = SECURITY_STATIC_TRACKING;

  00043	88 5d f8	 mov	 BYTE PTR _qos$[ebp+8], bl

; 1661 : 	qos.EffectiveOnly = TRUE;

  00046	c6 45 f9 01	 mov	 BYTE PTR _qos$[ebp+9], 1

; 1662 : 	qos.ImpersonationLevel = SecurityImpersonation;

  0004a	c7 45 f4 02 00
	00 00		 mov	 DWORD PTR _qos$[ebp+4], 2

; 1663 : 
; 1664 : 	ntStatus = SeCreateClientSecurity (PsGetCurrentThread(), &qos, FALSE, &Extension->SecurityClientContext);

  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeGetCurrentThread@0
  00057	8b 75 0c	 mov	 esi, DWORD PTR _Extension$[ebp]
  0005a	8d 8e 94 04 00
	00		 lea	 ecx, DWORD PTR [esi+1172]
  00060	51		 push	 ecx
  00061	53		 push	 ebx
  00062	8d 4d f0	 lea	 ecx, DWORD PTR _qos$[ebp]
  00065	51		 push	 ecx
  00066	50		 push	 eax
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeCreateClientSecurity@16

; 1665 : 	if (!NT_SUCCESS (ntStatus))

  0006d	3b c3		 cmp	 eax, ebx
  0006f	89 45 08	 mov	 DWORD PTR _ntStatus$[ebp], eax
  00072	0f 8c 83 00 00
	00		 jl	 $ret$30505

; 1666 : 		goto ret;
; 1667 : 
; 1668 : 	Extension->SecurityClientContextValid = TRUE;
; 1669 : 
; 1670 : 	Extension->bThreadShouldQuit = FALSE;
; 1671 : 
; 1672 : 	InitializeObjectAttributes (&threadObjAttributes, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);
; 1673 : 
; 1674 : 	ntStatus = PsCreateSystemThread (&hThread,
; 1675 : 					 THREAD_ALL_ACCESS,
; 1676 : 					 &threadObjAttributes,
; 1677 : 					 NULL,
; 1678 : 					 NULL,
; 1679 : 					 VolumeThreadProc,
; 1680 : 					 pThreadBlock);

  00078	57		 push	 edi
  00079	68 00 00 00 00	 push	 OFFSET _VolumeThreadProc@4
  0007e	53		 push	 ebx
  0007f	53		 push	 ebx
  00080	8d 45 d8	 lea	 eax, DWORD PTR _threadObjAttributes$[ebp]
  00083	50		 push	 eax
  00084	68 ff 03 1f 00	 push	 2032639			; 001f03ffH
  00089	8d 45 fc	 lea	 eax, DWORD PTR _hThread$[ebp]
  0008c	50		 push	 eax
  0008d	c7 86 90 04 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+1168], 1
  00097	89 5e 1c	 mov	 DWORD PTR [esi+28], ebx
  0009a	c7 45 d8 18 00
	00 00		 mov	 DWORD PTR _threadObjAttributes$[ebp], 24 ; 00000018H
  000a1	89 5d dc	 mov	 DWORD PTR _threadObjAttributes$[ebp+4], ebx
  000a4	c7 45 e4 00 02
	00 00		 mov	 DWORD PTR _threadObjAttributes$[ebp+12], 512 ; 00000200H
  000ab	89 5d e0	 mov	 DWORD PTR _threadObjAttributes$[ebp+8], ebx
  000ae	89 5d e8	 mov	 DWORD PTR _threadObjAttributes$[ebp+16], ebx
  000b1	89 5d ec	 mov	 DWORD PTR _threadObjAttributes$[ebp+20], ebx
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsCreateSystemThread@28

; 1681 : 
; 1682 : 	if (!NT_SUCCESS (ntStatus))

  000ba	3b c3		 cmp	 eax, ebx
  000bc	89 45 08	 mov	 DWORD PTR _ntStatus$[ebp], eax
  000bf	7c 3a		 jl	 SHORT $ret$30505

; 1683 : 	{
; 1684 : 		Dump ("PsCreateSystemThread Failed END\n");
; 1685 : 		goto ret;
; 1686 : 	}
; 1687 : 
; 1688 : 	ntStatus = ObReferenceObjectByHandle (hThread,
; 1689 : 				   THREAD_ALL_ACCESS,
; 1690 : 				   NULL,
; 1691 : 				   KernelMode,
; 1692 : 				   &Extension->peThread,
; 1693 : 				   NULL);

  000c1	53		 push	 ebx
  000c2	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  000c5	50		 push	 eax
  000c6	53		 push	 ebx
  000c7	53		 push	 ebx
  000c8	68 ff 03 1f 00	 push	 2032639			; 001f03ffH
  000cd	ff 75 fc	 push	 DWORD PTR _hThread$[ebp]
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ObReferenceObjectByHandle@24

; 1694 : 
; 1695 : 	ZwClose (hThread);

  000d6	ff 75 fc	 push	 DWORD PTR _hThread$[ebp]
  000d9	89 45 08	 mov	 DWORD PTR _ntStatus$[ebp], eax
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 1696 : 
; 1697 : 	if (!NT_SUCCESS (ntStatus))

  000e2	39 5d 08	 cmp	 DWORD PTR _ntStatus$[ebp], ebx
  000e5	7c 14		 jl	 SHORT $ret$30505

; 1698 : 		goto ret;
; 1699 : 
; 1700 : 	Dump ("Waiting for thread to initialize...\n");
; 1701 : 
; 1702 : 	KeWaitForSingleObject (&Extension->keCreateEvent,
; 1703 : 			       Executive,
; 1704 : 			       KernelMode,
; 1705 : 			       FALSE,
; 1706 : 			       NULL);

  000e7	53		 push	 ebx
  000e8	53		 push	 ebx
  000e9	53		 push	 ebx
  000ea	53		 push	 ebx
  000eb	83 c6 24	 add	 esi, 36			; 00000024H
  000ee	56		 push	 esi
  000ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 1707 : 
; 1708 : 	Dump ("Waiting completed! Thread returns 0x%08x\n", pThreadBlock->ntCreateStatus);
; 1709 : 	ntStatus = pThreadBlock->ntCreateStatus;

  000f5	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000f8	89 45 08	 mov	 DWORD PTR _ntStatus$[ebp], eax
$ret$30505:

; 1710 : 
; 1711 : ret:
; 1712 : 	TCfree (pThreadBlock);

  000fb	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00100	57		 push	 edi
  00101	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 1713 : 	return ntStatus;

  00107	8b 45 08	 mov	 eax, DWORD PTR _ntStatus$[ebp]
  0010a	5e		 pop	 esi
$LN6@TCStartVol:
  0010b	5f		 pop	 edi
  0010c	5b		 pop	 ebx

; 1714 : }

  0010d	c9		 leave
  0010e	c2 0c 00	 ret	 12			; 0000000cH
_TCStartVolumeThread@12 ENDP
_TEXT	ENDS
PUBLIC	_TCUnloadDriver@4
EXTRN	_EncryptionThreadPoolStop@0:PROC
EXTRN	_IsBootDriveMounted@0:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCUnloadDriver@4
_TEXT	SEGMENT
_DriverObject$ = 8					; size = 4
_TCUnloadDriver@4 PROC					; COMDAT

; 2124 : 	Dump ("TCUnloadDriver BEGIN\n");
; 2125 : 
; 2126 : 	OnShutdownPending();

  00000	e8 00 00 00 00	 call	 _OnShutdownPending@0

; 2127 : 
; 2128 : 	if (IsBootDriveMounted())

  00005	e8 00 00 00 00	 call	 _IsBootDriveMounted@0
  0000a	85 c0		 test	 eax, eax
  0000c	74 19		 je	 SHORT $LN1@TCUnloadDr

; 2129 : 		TC_BUG_CHECK (STATUS_INVALID_DEVICE_STATE);

  0000e	68 43 54 00 00	 push	 21571			; 00005443H
  00013	6a 00		 push	 0
  00015	68 84 01 00 c0	 push	 -1073741436		; c0000184H
  0001a	68 51 08 00 00	 push	 2129			; 00000851H
  0001f	6a 29		 push	 41			; 00000029H
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN5@TCUnloadDr:
$LN1@TCUnloadDr:

; 2130 : 
; 2131 : 	EncryptionThreadPoolStop();

  00027	e8 00 00 00 00	 call	 _EncryptionThreadPoolStop@0

; 2132 : 	TCDeleteDeviceObject (RootDeviceObject, (PEXTENSION) RootDeviceObject->DeviceExtension);

  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR _RootDeviceObject
  00031	ff 70 28	 push	 DWORD PTR [eax+40]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _TCDeleteDeviceObject@8

; 2133 : 
; 2134 : 	Dump ("TCUnloadDriver END\n");
; 2135 : }

  0003a	c2 04 00	 ret	 4
$LN4@TCUnloadDr:
_TCUnloadDriver@4 ENDP
_TEXT	ENDS
PUBLIC	_MountDevice@8
EXTRN	__imp__RtlCopySid@12:PROC
EXTRN	__imp__RtlLengthSid@4:PROC
EXTRN	__SEH_epilog4:PROC
EXTRN	__except_handler4:PROC
EXTRN	__SEH_prolog4:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$_MountDevice@8 DD 0fffffffeH
	DD	00H
	DD	0ffffffbcH
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN24@MountDevic
	DD	FLAT:$LN25@MountDevic
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT _MountDevice@8
_TEXT	SEGMENT
_subContext$30939 = -52					; size = 16
_volumeHandle$30958 = -36				; size = 4
_fsStatus$30965 = -32					; size = 4
_NewDeviceObject$ = -28					; size = 4
__$SEHRec$ = -24					; size = 24
_volumeFileObject$30959 = 8				; size = 4
_tokenUser$30944 = 8					; size = 4
_DeviceObject$ = 8					; size = 4
_mount$ = 12						; size = 4
_MountDevice@8 PROC					; COMDAT

; 2564 : {

  00000	6a 24		 push	 36			; 00000024H
  00002	68 00 00 00 00	 push	 OFFSET __sehtable$_MountDevice@8
  00007	e8 00 00 00 00	 call	 __SEH_prolog4

; 2565 : 	PDEVICE_OBJECT NewDeviceObject;
; 2566 : 	NTSTATUS ntStatus;
; 2567 : 
; 2568 : 	// Make sure the user is asking for a reasonable nDosDriveNo
; 2569 : 	if (mount->nDosDriveNo >= 0 && mount->nDosDriveNo <= 25 && IsDriveLetterAvailable (mount->nDosDriveNo))

  0000c	8b 75 0c	 mov	 esi, DWORD PTR _mount$[ebp]
  0000f	8b 86 64 02 00
	00		 mov	 eax, DWORD PTR [esi+612]
  00015	85 c0		 test	 eax, eax
  00017	0f 8c c7 01 00
	00		 jl	 $LN20@MountDevic
  0001d	83 f8 19	 cmp	 eax, 25			; 00000019H
  00020	0f 8f be 01 00
	00		 jg	 $LN20@MountDevic
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 _IsDriveLetterAvailable@4
  0002c	85 c0		 test	 eax, eax
  0002e	0f 84 b0 01 00
	00		 je	 $LN20@MountDevic

; 2577 : 		return ERR_DRIVE_NOT_FOUND;
; 2578 : 	}
; 2579 : 
; 2580 : 	if (!SelfTestsPassed)

  00034	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SelfTestsPassed, 0
  0003b	75 07		 jne	 SHORT $LN18@MountDevic

; 2581 : 	{
; 2582 : 		mount->nReturnCode = ERR_SELF_TESTS_FAILED;

  0003d	6a 13		 push	 19			; 00000013H

; 2583 : 		return ERR_SELF_TESTS_FAILED;

  0003f	e9 a2 01 00 00	 jmp	 $LN29@MountDevic
$LN18@MountDevic:

; 2584 : 	}
; 2585 : 
; 2586 : 	ntStatus = TCCreateDeviceObject (DeviceObject->DriverObject, &NewDeviceObject, mount);

  00044	56		 push	 esi
  00045	8d 45 e4	 lea	 eax, DWORD PTR _NewDeviceObject$[ebp]
  00048	50		 push	 eax
  00049	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  0004c	ff 70 08	 push	 DWORD PTR [eax+8]
  0004f	e8 00 00 00 00	 call	 _TCCreateDeviceObject@12

; 2587 : 
; 2588 : 	if (!NT_SUCCESS (ntStatus))

  00054	85 c0		 test	 eax, eax

; 2589 : 	{
; 2590 : 		Dump ("Mount CREATE DEVICE ERROR, ntStatus = 0x%08x\n", ntStatus);
; 2591 : 		return ntStatus;

  00056	0f 8c 8d 01 00
	00		 jl	 $LN8@MountDevic

; 2592 : 	}
; 2593 : 	else
; 2594 : 	{
; 2595 : 		PEXTENSION NewExtension = (PEXTENSION) NewDeviceObject->DeviceExtension;

  0005c	8b 45 e4	 mov	 eax, DWORD PTR _NewDeviceObject$[ebp]
  0005f	8b 78 28	 mov	 edi, DWORD PTR [eax+40]

; 2596 : 		SECURITY_SUBJECT_CONTEXT subContext;
; 2597 : 		PACCESS_TOKEN accessToken;
; 2598 : 
; 2599 : 		SeCaptureSubjectContext (&subContext);

  00062	8d 45 cc	 lea	 eax, DWORD PTR _subContext$30939[ebp]
  00065	50		 push	 eax
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeCaptureSubjectContext@4

; 2600 : 		SeLockSubjectContext(&subContext);

  0006c	8d 45 cc	 lea	 eax, DWORD PTR _subContext$30939[ebp]
  0006f	50		 push	 eax
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeLockSubjectContext@4

; 2601 : 		accessToken=getToken(&subContext);

  00076	8d 45 cc	 lea	 eax, DWORD PTR _subContext$30939[ebp]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 _getToken@4

; 2602 : 
; 2603 : 		if (!accessToken)

  0007f	85 c0		 test	 eax, eax
  00081	75 07		 jne	 SHORT $LN15@MountDevic

; 2604 : 		{
; 2605 : 			ntStatus = STATUS_INVALID_PARAMETER;

  00083	bb 0d 00 00 c0	 mov	 ebx, -1073741811	; c000000dH

; 2606 : 		}
; 2607 : 		else

  00088	eb 59		 jmp	 SHORT $LN13@MountDevic
$LN15@MountDevic:

; 2608 : 		{
; 2609 : 			PTOKEN_USER tokenUser;
; 2610 : 
; 2611 : 			ntStatus = SeQueryInformationToken (accessToken, TokenUser, &tokenUser);

  0008a	8d 4d 08	 lea	 ecx, DWORD PTR _tokenUser$30944[ebp]
  0008d	51		 push	 ecx
  0008e	6a 01		 push	 1
  00090	50		 push	 eax
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeQueryInformationToken@12
  00097	8b d8		 mov	 ebx, eax

; 2612 : 			if (NT_SUCCESS (ntStatus))

  00099	85 db		 test	 ebx, ebx
  0009b	7c 46		 jl	 SHORT $LN13@MountDevic

; 2613 : 			{
; 2614 : 				ULONG sidLength = RtlLengthSid (tokenUser->User.Sid);

  0009d	8b 45 08	 mov	 eax, DWORD PTR _tokenUser$30944[ebp]
  000a0	ff 30		 push	 DWORD PTR [eax]
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLengthSid@4
  000a8	8b d8		 mov	 ebx, eax

; 2615 : 
; 2616 : 				NewExtension->UserSid = TCalloc (sidLength);

  000aa	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  000af	53		 push	 ebx
  000b0	6a 00		 push	 0
  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  000b8	89 87 8c 04 00
	00		 mov	 DWORD PTR [edi+1164], eax

; 2617 : 				if (!NewExtension->UserSid)

  000be	85 c0		 test	 eax, eax
  000c0	75 07		 jne	 SHORT $LN12@MountDevic

; 2618 : 					ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  000c2	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 2619 : 				else

  000c7	eb 0f		 jmp	 SHORT $LN11@MountDevic
$LN12@MountDevic:

; 2620 : 					ntStatus = RtlCopySid (sidLength, NewExtension->UserSid, tokenUser->User.Sid);

  000c9	8b 4d 08	 mov	 ecx, DWORD PTR _tokenUser$30944[ebp]
  000cc	ff 31		 push	 DWORD PTR [ecx]
  000ce	50		 push	 eax
  000cf	53		 push	 ebx
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlCopySid@12
  000d6	8b d8		 mov	 ebx, eax
$LN11@MountDevic:

; 2621 : 
; 2622 : 				ExFreePool (tokenUser);		// Documented in newer versions of WDK

  000d8	6a 00		 push	 0
  000da	ff 75 08	 push	 DWORD PTR _tokenUser$30944[ebp]
  000dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN13@MountDevic:

; 2623 : 			}
; 2624 : 		}
; 2625 : 
; 2626 : 		SeUnlockSubjectContext(&subContext);

  000e3	8d 45 cc	 lea	 eax, DWORD PTR _subContext$30939[ebp]
  000e6	50		 push	 eax
  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeUnlockSubjectContext@4

; 2627 : 		SeReleaseSubjectContext (&subContext);

  000ed	8d 45 cc	 lea	 eax, DWORD PTR _subContext$30939[ebp]
  000f0	50		 push	 eax
  000f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeReleaseSubjectContext@4

; 2628 : 
; 2629 : 		if (NT_SUCCESS (ntStatus))

  000f7	85 db		 test	 ebx, ebx
  000f9	7c 10		 jl	 SHORT $LN31@MountDevic

; 2630 : 			ntStatus = TCStartVolumeThread (NewDeviceObject, NewExtension, mount);

  000fb	56		 push	 esi
  000fc	57		 push	 edi
  000fd	ff 75 e4	 push	 DWORD PTR _NewDeviceObject$[ebp]
  00100	e8 00 00 00 00	 call	 _TCStartVolumeThread@12
  00105	8b d8		 mov	 ebx, eax

; 2631 : 
; 2632 : 		if (!NT_SUCCESS (ntStatus))

  00107	85 db		 test	 ebx, ebx
  00109	7d 10		 jge	 SHORT $LN9@MountDevic
$LN31@MountDevic:

; 2633 : 		{
; 2634 : 			Dump ("Mount FAILURE NT ERROR, ntStatus = 0x%08x\n", ntStatus);
; 2635 : 			TCDeleteDeviceObject (NewDeviceObject, NewExtension);

  0010b	57		 push	 edi
  0010c	ff 75 e4	 push	 DWORD PTR _NewDeviceObject$[ebp]
  0010f	e8 00 00 00 00	 call	 _TCDeleteDeviceObject@8

; 2636 : 			return ntStatus;

  00114	8b c3		 mov	 eax, ebx
  00116	e9 ce 00 00 00	 jmp	 $LN8@MountDevic
$LN9@MountDevic:

; 2637 : 		}
; 2638 : 		else
; 2639 : 		{
; 2640 : 			if (mount->nReturnCode == 0)

  0011b	83 3e 00	 cmp	 DWORD PTR [esi], 0
  0011e	0f 85 b3 00 00
	00		 jne	 $LN7@MountDevic

; 2641 : 			{
; 2642 : 				HANDLE volumeHandle;
; 2643 : 				PFILE_OBJECT volumeFileObject;
; 2644 : 
; 2645 : 				Dump ("Mount SUCCESS TC code = 0x%08x READ-ONLY = %d\n", mount->nReturnCode, NewExtension->bReadOnly);
; 2646 : 
; 2647 : 				if (NewExtension->bReadOnly)

  00124	83 bf 48 02 00
	00 00		 cmp	 DWORD PTR [edi+584], 0
  0012b	74 07		 je	 SHORT $LN6@MountDevic

; 2648 : 					NewDeviceObject->Characteristics |= FILE_READ_ONLY_DEVICE;

  0012d	8b 45 e4	 mov	 eax, DWORD PTR _NewDeviceObject$[ebp]
  00130	83 48 20 02	 or	 DWORD PTR [eax+32], 2
$LN6@MountDevic:

; 2649 : 
; 2650 : 				NewDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

  00134	8b 45 e4	 mov	 eax, DWORD PTR _NewDeviceObject$[ebp]
  00137	81 60 1c 7f ff
	ff ff		 and	 DWORD PTR [eax+28], -129 ; ffffff7fH

; 2651 : 
; 2652 : 				NewExtension->UniqueVolumeId = LastUniqueVolumeId++;

  0013e	a1 00 00 00 00	 mov	 eax, DWORD PTR _LastUniqueVolumeId
  00143	89 47 10	 mov	 DWORD PTR [edi+16], eax
  00146	ff 05 00 00 00
	00		 inc	 DWORD PTR _LastUniqueVolumeId

; 2653 : 
; 2654 : 				if (mount->bMountManager)

  0014c	8d 9e 78 02 00
	00		 lea	 ebx, DWORD PTR [esi+632]
  00152	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  00155	74 06		 je	 SHORT $LN5@MountDevic

; 2655 : 					MountManagerMount (mount);

  00157	56		 push	 esi
  00158	e8 00 00 00 00	 call	 _MountManagerMount@4
$LN5@MountDevic:

; 2656 : 
; 2657 : 				NewExtension->bMountManager = mount->bMountManager;

  0015d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0015f	89 87 58 02 00
	00		 mov	 DWORD PTR [edi+600], eax

; 2658 : 
; 2659 : 				// We create symbolic link even if mount manager is notified of
; 2660 : 				// arriving volume as it apparently sometimes fails to create the link
; 2661 : 				CreateDriveLink (mount->nDosDriveNo);

  00165	ff b6 64 02 00
	00		 push	 DWORD PTR [esi+612]
  0016b	e8 00 00 00 00	 call	 _CreateDriveLink@4

; 2662 : 
; 2663 : 				mount->FilesystemDirty = FALSE;

  00170	33 db		 xor	 ebx, ebx
  00172	89 5e 04	 mov	 DWORD PTR [esi+4], ebx

; 2664 : 
; 2665 : 				if (NT_SUCCESS (TCOpenFsVolume (NewExtension, &volumeHandle, &volumeFileObject)))

  00175	8d 45 08	 lea	 eax, DWORD PTR _volumeFileObject$30959[ebp]
  00178	50		 push	 eax
  00179	8d 45 dc	 lea	 eax, DWORD PTR _volumeHandle$30958[ebp]
  0017c	50		 push	 eax
  0017d	57		 push	 edi
  0017e	e8 00 00 00 00	 call	 _TCOpenFsVolume@12
  00183	85 c0		 test	 eax, eax
  00185	7c 59		 jl	 SHORT $LN1@MountDevic

; 2666 : 				{
; 2667 : 					__try

  00187	89 5d fc	 mov	 DWORD PTR __$SEHRec$[ebp+20], ebx

; 2668 : 					{
; 2669 : 						ULONG fsStatus;
; 2670 : 
; 2671 : 						if (NT_SUCCESS (TCFsctlCall (volumeFileObject, FSCTL_IS_VOLUME_DIRTY, NULL, 0, &fsStatus, sizeof (fsStatus)))
; 2672 : 							&& (fsStatus & VOLUME_IS_DIRTY))

  0018a	6a 04		 push	 4
  0018c	8d 45 e0	 lea	 eax, DWORD PTR _fsStatus$30965[ebp]
  0018f	50		 push	 eax
  00190	53		 push	 ebx
  00191	53		 push	 ebx
  00192	68 78 00 09 00	 push	 589944			; 00090078H
  00197	ff 75 08	 push	 DWORD PTR _volumeFileObject$30959[ebp]
  0019a	e8 00 00 00 00	 call	 _TCFsctlCall@24
  0019f	85 c0		 test	 eax, eax
  001a1	7c 20		 jl	 SHORT $LN2@MountDevic
  001a3	f6 45 e0 01	 test	 BYTE PTR _fsStatus$30965[ebp], 1
  001a7	74 1a		 je	 SHORT $LN2@MountDevic

; 2673 : 						{
; 2674 : 							mount->FilesystemDirty = TRUE;

  001a9	c7 46 04 01 00
	00 00		 mov	 DWORD PTR [esi+4], 1

; 2675 : 						}
; 2676 : 					}

  001b0	eb 11		 jmp	 SHORT $LN2@MountDevic
$LN24@MountDevic:
$LN32@MountDevic:

; 2677 : 					__except (EXCEPTION_EXECUTE_HANDLER)

  001b2	33 c0		 xor	 eax, eax
  001b4	40		 inc	 eax
$LN28@MountDevic:
$LN26@MountDevic:
  001b5	c3		 ret	 0
$LN25@MountDevic:
  001b6	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 2678 : 					{
; 2679 : 						mount->FilesystemDirty = TRUE;

  001b9	8b 45 0c	 mov	 eax, DWORD PTR _mount$[ebp]
  001bc	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [eax+4], 1
$LN2@MountDevic:

; 2680 : 					}

  001c3	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH

; 2681 : 
; 2682 : 
; 2683 : 					TCCloseFsVolume (volumeHandle, volumeFileObject);

  001ca	ff 75 08	 push	 DWORD PTR _volumeFileObject$30959[ebp]
  001cd	ff 75 dc	 push	 DWORD PTR _volumeHandle$30958[ebp]
  001d0	e8 00 00 00 00	 call	 _TCCloseFsVolume@8

; 2684 : 				}
; 2685 : 			}
; 2686 : 			else

  001d5	eb 09		 jmp	 SHORT $LN1@MountDevic
$LN7@MountDevic:

; 2687 : 			{
; 2688 : 				Dump ("Mount FAILURE TC code = 0x%08x\n", mount->nReturnCode);
; 2689 : 				TCDeleteDeviceObject (NewDeviceObject, NewExtension);

  001d7	57		 push	 edi
  001d8	ff 75 e4	 push	 DWORD PTR _NewDeviceObject$[ebp]
  001db	e8 00 00 00 00	 call	 _TCDeleteDeviceObject@8
$LN1@MountDevic:

; 2690 : 			}
; 2691 : 			
; 2692 : 			return STATUS_SUCCESS;

  001e0	33 c0		 xor	 eax, eax
  001e2	eb 05		 jmp	 SHORT $LN8@MountDevic
$LN20@MountDevic:

; 2570 : 	{
; 2571 : 		Dump ("Mount request looks valid\n");
; 2572 : 	}
; 2573 : 	else
; 2574 : 	{
; 2575 : 		Dump ("WARNING: MOUNT DRIVE LETTER INVALID\n");
; 2576 : 		mount->nReturnCode = ERR_DRIVE_NOT_FOUND;

  001e4	6a 05		 push	 5
$LN29@MountDevic:
  001e6	58		 pop	 eax
  001e7	89 06		 mov	 DWORD PTR [esi], eax
$LN8@MountDevic:

; 2693 : 		}
; 2694 : 	}
; 2695 : }

  001e9	e8 00 00 00 00	 call	 __SEH_epilog4
  001ee	c2 08 00	 ret	 8
_MountDevice@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_09EMKKFGIH@TrueCrypt?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0L@FEEFGEIL@CipherShed?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	_DeviceObject$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_ProcessMainDeviceControlIrp@12
EXTRN	_IsHwEncryptionEnabled@0:PROC
EXTRN	_GetBootDriveFilterExtension@0:PROC
EXTRN	_WriteBootDriveSector@8:PROC
EXTRN	_StartDecoySystemWipe@12:PROC
EXTRN	_AbortDecoySystemWipe@0:PROC
EXTRN	_GetDecoySystemWipeStatus@8:PROC
EXTRN	_GetDecoySystemWipeResult@0:PROC
EXTRN	_MirrorBytes16@4:PROC
EXTRN	_GetBootEncryptionAlgorithmName@8:PROC
EXTRN	_IsHiddenSystemRunning@0:PROC
EXTRN	_ReopenBootVolumeHeader@8:PROC
EXTRN	_StartBootEncryptionSetup@12:PROC
EXTRN	_AbortBootEncryptionSetup@0:PROC
EXTRN	_GetSetupResult@0:PROC
EXTRN	_GetBootDriveVolumeProperties@8:PROC
EXTRN	_GetBootEncryptionStatus@8:PROC
EXTRN	_MirrorBytes64@8:PROC
EXTRN	__imp__IoEnumerateDeviceObjectList@16:PROC
EXTRN	_cacheEmpty:DWORD
EXTRN	_WipeCache@0:PROC
EXTRN	_GetBootLoaderVersion@8:PROC
;	COMDAT ??_C@_09EMKKFGIH@TrueCrypt?$AA@FNODOBFM@
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
text$s	SEGMENT
??_C@_09EMKKFGIH@TrueCrypt?$AA@FNODOBFM@ DB 'TrueCrypt', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0L@FEEFGEIL@CipherShed?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0L@FEEFGEIL@CipherShed?$AA@FNODOBFM@ DB 'CipherShed', 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
; File c:\users\public\desktop\projects\ciphershed\src\driver\ntdriver.c
text$s	ENDS
;	COMDAT _ProcessMainDeviceControlIrp@12
_TEXT	SEGMENT
_pi$30298 = -796					; size = 144
_name$30332 = -652					; size = 8
_FullFileName$30131 = -644				; size = 8
_FullFileName$30189 = -636				; size = 8
_IoStatus$30190 = -628					; size = 8
_ObjectAttributes$30187 = -620				; size = 24
_ObjectAttributes$30129 = -596				; size = 24
_offset$30133 = -572					; size = 8
_offset$30191 = -564					; size = 8
_lengthInfo$30308 = -556				; size = 8
_deviceObject$30334 = -548				; size = 4
_fileObject$30333 = -544				; size = 4
_IoStatus$30132 = -540					; size = 8
tv1455 = -532						; size = 4
_NtFileHandle$30130 = -532				; size = 4
_NtFileHandle$30188 = -528				; size = 4
_opentest$30127 = -528					; size = 4
_DeviceObject$GSCopy$ = -524				; size = 4
_ntStatus$ = -524					; size = 4
_access$30134 = -524					; size = 4
_deviceObjectCount$30104 = -524				; size = 4
tv1118 = -520						; size = 4
_ntStatus$30299 = -520					; size = 4
_drive$30250 = -520					; size = 4
_request$30185 = -520					; size = 4
_readBuffer$30149 = -520				; size = 4
_readBuffer$30192 = -516				; size = 512
__$ArrayPad$ = -4					; size = 4
_DeviceObject$ = 8					; size = 4
_Extension$ = 12					; size = 4
_Irp$ = 16						; size = 4
_ProcessMainDeviceControlIrp@12 PROC			; COMDAT

; 808  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 1c 03 00
	00		 sub	 esp, 796		; 0000031cH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	8b 55 08	 mov	 edx, DWORD PTR _DeviceObject$[ebp]
  00018	53		 push	 ebx
  00019	8b 5d 10	 mov	 ebx, DWORD PTR _Irp$[ebp]
  0001c	56		 push	 esi
  0001d	57		 push	 edi

; 809  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);

  0001e	8b 7b 60	 mov	 edi, DWORD PTR [ebx+96]

; 810  : 	NTSTATUS ntStatus;
; 811  : 
; 812  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  00021	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00024	b9 48 20 22 00	 mov	 ecx, 2236488		; 00222048H

; 1390 : 			}
; 1391 : 
; 1392 : 			EnsureNullTerminatedString (mount->wszVolume, sizeof (mount->wszVolume));

  00029	89 95 f4 fd ff
	ff		 mov	 DWORD PTR _DeviceObject$GSCopy$[ebp], edx
  0002f	3b c1		 cmp	 eax, ecx
  00031	0f 87 dc 0a 00
	00		 ja	 $LN163@ProcessMai

; 810  : 	NTSTATUS ntStatus;
; 811  : 
; 812  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  00037	0f 84 ca 0a 00
	00		 je	 $LN24@ProcessMai
  0003d	83 c1 d8	 add	 ecx, -40		; ffffffd8H
  00040	3b c1		 cmp	 eax, ecx
  00042	0f 87 6e 04 00
	00		 ja	 $LN164@ProcessMai
  00048	0f 84 41 04 00
	00		 je	 $LN152@ProcessMai
  0004e	b9 0c 20 22 00	 mov	 ecx, 2236428		; 0022200cH
  00053	3b c1		 cmp	 eax, ecx
  00055	0f 87 1f 01 00
	00		 ja	 $LN165@ProcessMai
  0005b	0f 84 85 00 00
	00		 je	 $LN46@ProcessMai
  00061	2d 04 20 07 00	 sub	 eax, 466948		; 00072004H
  00066	74 47		 je	 SHORT $LN74@ProcessMai
  00068	83 e8 14	 sub	 eax, 20			; 00000014H
  0006b	74 1c		 je	 SHORT $LN154@ProcessMai
  0006d	2d ec ff 1a 00	 sub	 eax, 1769452		; 001affecH
  00072	74 15		 je	 SHORT $LN154@ProcessMai
  00074	83 e8 04	 sub	 eax, 4
  00077	0f 85 37 0e 00
	00		 jne	 $LN1@ProcessMai

; 1457 : 
; 1458 : 	case TC_IOCTL_GET_BOOT_LOADER_VERSION:
; 1459 : 		GetBootLoaderVersion (Irp, irpSp);

  0007d	57		 push	 edi
  0007e	53		 push	 ebx
  0007f	e8 00 00 00 00	 call	 _GetBootLoaderVersion@8

; 1460 : 		break;

  00084	e9 e4 0e 00 00	 jmp	 $LN10@ProcessMai
$LN154@ProcessMai:

; 813  : 	{
; 814  : 	case TC_IOCTL_GET_DRIVER_VERSION:
; 815  : 	case TC_IOCTL_LEGACY_GET_DRIVER_VERSION:
; 816  : 		if (ValidateIOBufferSize (Irp, sizeof (LONG), ValidateOutput))

  00089	6a 01		 push	 1
  0008b	6a 04		 push	 4
  0008d	5e		 pop	 esi
  0008e	56		 push	 esi
  0008f	53		 push	 ebx
  00090	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00095	85 c0		 test	 eax, eax
  00097	0f 84 d0 0e 00
	00		 je	 $LN10@ProcessMai

; 817  : 		{
; 818  : 			LONG tmp = VERSION_NUM;
; 819  : 			memcpy (Irp->AssociatedIrp.SystemBuffer, &tmp, 4);

  0009d	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  000a0	c7 00 30 07 00
	00		 mov	 DWORD PTR [eax], 1840	; 00000730H
$LN285@ProcessMai:

; 820  : 			Irp->IoStatus.Information = sizeof (LONG);
; 821  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  000a6	83 63 18 00	 and	 DWORD PTR [ebx+24], 0

; 822  : 		}
; 823  : 		break;

  000aa	e9 bb 0e 00 00	 jmp	 $LN283@ProcessMai
$LN74@ProcessMai:

; 1174 : 
; 1175 : 	case TC_IOCTL_LEGACY_GET_MOUNTED_VOLUMES:
; 1176 : 		if (ValidateIOBufferSize (Irp, sizeof (uint32), ValidateOutput))

  000af	6a 01		 push	 1
  000b1	6a 04		 push	 4
  000b3	53		 push	 ebx
  000b4	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  000b9	85 c0		 test	 eax, eax
  000bb	0f 84 ac 0e 00
	00		 je	 $LN10@ProcessMai

; 1177 : 		{
; 1178 : 			// Prevent the user from downgrading to versions lower than 5.0 by faking mounted volumes.
; 1179 : 			// The user could render the system unbootable by downgrading when boot encryption
; 1180 : 			// is active or being set up.
; 1181 : 
; 1182 : 			memset (Irp->AssociatedIrp.SystemBuffer, 0, irpSp->Parameters.DeviceIoControl.OutputBufferLength);

  000c1	ff 77 04	 push	 DWORD PTR [edi+4]
  000c4	6a 00		 push	 0
  000c6	ff 73 0c	 push	 DWORD PTR [ebx+12]
  000c9	e8 00 00 00 00	 call	 _memset

; 1183 : 			*(uint32 *) Irp->AssociatedIrp.SystemBuffer = 0xffffFFFF;

  000ce	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  000d1	83 08 ff	 or	 DWORD PTR [eax], -1
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1184 : 
; 1185 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  000d7	83 63 18 00	 and	 DWORD PTR [ebx+24], 0

; 1186 : 			Irp->IoStatus.Information = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

  000db	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000de	89 43 1c	 mov	 DWORD PTR [ebx+28], eax

; 1187 : 		}
; 1188 : 		break;

  000e1	e9 87 0e 00 00	 jmp	 $LN10@ProcessMai
$LN46@ProcessMai:

; 1379 : 
; 1380 : 	case TC_IOCTL_MOUNT_VOLUME:
; 1381 : 		if (ValidateIOBufferSize (Irp, sizeof (MOUNT_STRUCT), ValidateInputOutput))

  000e6	6a 02		 push	 2
  000e8	bf e0 02 00 00	 mov	 edi, 736		; 000002e0H
  000ed	57		 push	 edi
  000ee	53		 push	 ebx
  000ef	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  000f4	85 c0		 test	 eax, eax
  000f6	0f 84 71 0e 00
	00		 je	 $LN10@ProcessMai

; 1382 : 		{
; 1383 : 			MOUNT_STRUCT *mount = (MOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  000fc	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]

; 1384 : 
; 1385 : 			if (mount->VolumePassword.Length > MAX_PASSWORD || mount->ProtectedHidVolPassword.Length > MAX_PASSWORD)

  000ff	8d b0 18 02 00
	00		 lea	 esi, DWORD PTR [eax+536]
  00105	83 3e 40	 cmp	 DWORD PTR [esi], 64	; 00000040H
  00108	77 64		 ja	 SHORT $LN43@ProcessMai
  0010a	8d 88 90 02 00
	00		 lea	 ecx, DWORD PTR [eax+656]
  00110	83 39 40	 cmp	 DWORD PTR [ecx], 64	; 00000040H
  00113	89 8d f8 fd ff
	ff		 mov	 DWORD PTR tv1118[ebp], ecx
  00119	77 53		 ja	 SHORT $LN43@ProcessMai

; 1393 : 
; 1394 : 			Irp->IoStatus.Information = sizeof (MOUNT_STRUCT);
; 1395 : 			Irp->IoStatus.Status = MountDevice (DeviceObject, mount);

  0011b	50		 push	 eax
  0011c	ff b5 f4 fd ff
	ff		 push	 DWORD PTR _DeviceObject$GSCopy$[ebp]
  00122	33 c9		 xor	 ecx, ecx
  00124	66 89 88 16 02
	00 00		 mov	 WORD PTR [eax+534], cx
  0012b	89 7b 1c	 mov	 DWORD PTR [ebx+28], edi
  0012e	e8 00 00 00 00	 call	 _MountDevice@8

; 1396 : 
; 1397 : 			burn (&mount->VolumePassword, sizeof (mount->VolumePassword));

  00133	6a 48		 push	 72			; 00000048H
  00135	89 43 18	 mov	 DWORD PTR [ebx+24], eax
  00138	58		 pop	 eax
  00139	8b ce		 mov	 ecx, esi
  0013b	8b d0		 mov	 edx, eax
  0013d	8b f8		 mov	 edi, eax
$LL187@ProcessMai:
  0013f	c6 06 00	 mov	 BYTE PTR [esi], 0
  00142	46		 inc	 esi
  00143	4f		 dec	 edi
  00144	75 f9		 jne	 SHORT $LL187@ProcessMai
$LL39@ProcessMai:
  00146	4a		 dec	 edx
  00147	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0014a	41		 inc	 ecx
  0014b	85 d2		 test	 edx, edx
  0014d	75 f7		 jne	 SHORT $LL39@ProcessMai

; 1398 : 			burn (&mount->ProtectedHidVolPassword, sizeof (mount->ProtectedHidVolPassword));

  0014f	8b 95 f8 fd ff
	ff		 mov	 edx, DWORD PTR tv1118[ebp]
  00155	8b f0		 mov	 esi, eax
  00157	8b ca		 mov	 ecx, edx
$LL191@ProcessMai:
  00159	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0015c	41		 inc	 ecx
  0015d	48		 dec	 eax
  0015e	75 f9		 jne	 SHORT $LL191@ProcessMai
$LL34@ProcessMai:
  00160	4e		 dec	 esi
  00161	c6 02 00	 mov	 BYTE PTR [edx], 0
  00164	42		 inc	 edx
  00165	85 f6		 test	 esi, esi
  00167	75 f7		 jne	 SHORT $LL34@ProcessMai

; 1143 : 
; 1144 : 			for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)

  00169	e9 ff 0d 00 00	 jmp	 $LN10@ProcessMai
$LN43@ProcessMai:

; 1386 : 			{
; 1387 : 				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  0016e	c7 43 18 0d 00
	00 c0		 mov	 DWORD PTR [ebx+24], -1073741811 ; c000000dH

; 1388 : 				Irp->IoStatus.Information = 0;
; 1389 : 				break;

  00175	e9 76 03 00 00	 jmp	 $LN288@ProcessMai
$LN165@ProcessMai:

; 810  : 	NTSTATUS ntStatus;
; 811  : 
; 812  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  0017a	2d 10 20 22 00	 sub	 eax, 2236432		; 00222010H
  0017f	0f 84 b8 02 00
	00		 je	 $LN32@ProcessMai
  00185	6a 04		 push	 4
  00187	5e		 pop	 esi
  00188	2b c6		 sub	 eax, esi
  0018a	0f 84 85 02 00
	00		 je	 $LN28@ProcessMai
  00190	2b c6		 sub	 eax, esi
  00192	0f 84 6e 01 00
	00		 je	 $LN87@ProcessMai
  00198	2b c6		 sub	 eax, esi
  0019a	0f 85 14 0d 00
	00		 jne	 $LN1@ProcessMai

; 1189 : 
; 1190 : 	case TC_IOCTL_GET_VOLUME_PROPERTIES:
; 1191 : 		if (ValidateIOBufferSize (Irp, sizeof (VOLUME_PROPERTIES_STRUCT), ValidateInputOutput))

  001a0	6a 02		 push	 2
  001a2	68 54 02 00 00	 push	 596			; 00000254H
  001a7	53		 push	 ebx
  001a8	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  001ad	85 c0		 test	 eax, eax
  001af	0f 84 b8 0d 00
	00		 je	 $LN10@ProcessMai

; 1192 : 		{
; 1193 : 			VOLUME_PROPERTIES_STRUCT *prop = (VOLUME_PROPERTIES_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  001b5	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]

; 1194 : 			PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject (prop->driveNo);

  001b8	ff 36		 push	 DWORD PTR [esi]
  001ba	e8 00 00 00 00	 call	 _GetVirtualVolumeDeviceObject@4

; 1195 : 
; 1196 : 			Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
; 1197 : 			Irp->IoStatus.Information = 0;

  001bf	83 63 1c 00	 and	 DWORD PTR [ebx+28], 0
  001c3	c7 43 18 0d 00
	00 c0		 mov	 DWORD PTR [ebx+24], -1073741811 ; c000000dH

; 1198 : 
; 1199 : 			if (ListDevice)

  001ca	85 c0		 test	 eax, eax
  001cc	0f 84 9b 0d 00
	00		 je	 $LN10@ProcessMai

; 1200 : 			{
; 1201 : 				PEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;

  001d2	8b 78 28	 mov	 edi, DWORD PTR [eax+40]

; 1202 : 				if (IsVolumeAccessibleByCurrentUser (ListExtension))

  001d5	57		 push	 edi
  001d6	e8 00 00 00 00	 call	 _IsVolumeAccessibleByCurrentUser@4
  001db	85 c0		 test	 eax, eax
  001dd	0f 84 8a 0d 00
	00		 je	 $LN10@ProcessMai

; 1203 : 				{
; 1204 : 					prop->uniqueId = ListExtension->UniqueVolumeId;

  001e3	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  001e6	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1205 : 					wcscpy (prop->wszVolume, ListExtension->wszVolume);

  001e9	8d 87 60 02 00
	00		 lea	 eax, DWORD PTR [edi+608]
  001ef	8d 56 08	 lea	 edx, DWORD PTR [esi+8]
  001f2	2b d0		 sub	 edx, eax
$LL162@ProcessMai:
  001f4	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  001f7	66 89 0c 02	 mov	 WORD PTR [edx+eax], cx
  001fb	40		 inc	 eax
  001fc	40		 inc	 eax
  001fd	66 85 c9	 test	 cx, cx
  00200	75 f2		 jne	 SHORT $LL162@ProcessMai

; 1206 : 					prop->diskLength = ListExtension->DiskLength;

  00202	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  00205	89 86 10 02 00
	00		 mov	 DWORD PTR [esi+528], eax
  0020b	8b 47 74	 mov	 eax, DWORD PTR [edi+116]
  0020e	89 86 14 02 00
	00		 mov	 DWORD PTR [esi+532], eax

; 1207 : 					prop->ea = ListExtension->cryptoInfo->ea;

  00214	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  00217	8b 00		 mov	 eax, DWORD PTR [eax]
  00219	89 86 18 02 00
	00		 mov	 DWORD PTR [esi+536], eax

; 1208 : 					prop->mode = ListExtension->cryptoInfo->mode;

  0021f	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  00222	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00225	89 86 1c 02 00
	00		 mov	 DWORD PTR [esi+540], eax

; 1209 : 					prop->pkcs5 = ListExtension->cryptoInfo->pkcs5;

  0022b	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  0022e	8b 80 ec 43 00
	00		 mov	 eax, DWORD PTR [eax+17388]
  00234	89 86 20 02 00
	00		 mov	 DWORD PTR [esi+544], eax

; 1210 : 					prop->pkcs5Iterations = ListExtension->cryptoInfo->noIterations;

  0023a	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  0023d	8b 80 e8 43 00
	00		 mov	 eax, DWORD PTR [eax+17384]
  00243	89 86 24 02 00
	00		 mov	 DWORD PTR [esi+548], eax

; 1211 : #if 0
; 1212 : 					prop->volumeCreationTime = ListExtension->cryptoInfo->volume_creation_time;
; 1213 : 					prop->headerCreationTime = ListExtension->cryptoInfo->header_creation_time;
; 1214 : #endif
; 1215 : 					prop->volumeHeaderFlags = ListExtension->cryptoInfo->HeaderFlags;

  00249	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  0024c	8b 80 60 44 00
	00		 mov	 eax, DWORD PTR [eax+17504]
  00252	89 86 38 02 00
	00		 mov	 DWORD PTR [esi+568], eax

; 1216 : 					prop->readOnly = ListExtension->bReadOnly;

  00258	8b 87 48 02 00
	00		 mov	 eax, DWORD PTR [edi+584]
  0025e	89 86 2c 02 00
	00		 mov	 DWORD PTR [esi+556], eax

; 1217 : 					prop->removable = ListExtension->bRemovable;

  00264	8b 87 4c 02 00
	00		 mov	 eax, DWORD PTR [edi+588]
  0026a	89 86 30 02 00
	00		 mov	 DWORD PTR [esi+560], eax

; 1218 : 					prop->partitionInInactiveSysEncScope = ListExtension->PartitionInInactiveSysEncScope;

  00270	8b 87 50 02 00
	00		 mov	 eax, DWORD PTR [edi+592]
  00276	89 86 34 02 00
	00		 mov	 DWORD PTR [esi+564], eax

; 1219 : 					prop->hiddenVolume = ListExtension->cryptoInfo->hiddenVolume;

  0027c	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  0027f	8b 80 a0 29 00
	00		 mov	 eax, DWORD PTR [eax+10656]
  00285	89 86 28 02 00
	00		 mov	 DWORD PTR [esi+552], eax

; 1220 : 
; 1221 : 					if (ListExtension->cryptoInfo->bProtectHiddenVolume)

  0028b	8b 4f 60	 mov	 ecx, DWORD PTR [edi+96]
  0028e	33 c0		 xor	 eax, eax
  00290	39 81 00 44 00
	00		 cmp	 DWORD PTR [ecx+17408], eax
  00296	74 14		 je	 SHORT $LN68@ProcessMai

; 1222 : 						prop->hiddenVolProtection = ListExtension->cryptoInfo->bHiddenVolProtectionAction ? HIDVOL_PROT_STATUS_ACTION_TAKEN : HIDVOL_PROT_STATUS_ACTIVE;

  00298	33 d2		 xor	 edx, edx
  0029a	39 81 04 44 00
	00		 cmp	 DWORD PTR [ecx+17412], eax
  002a0	0f 95 c2	 setne	 dl
  002a3	42		 inc	 edx
  002a4	89 96 4c 02 00
	00		 mov	 DWORD PTR [esi+588], edx

; 1223 : 					else

  002aa	eb 06		 jmp	 SHORT $LN67@ProcessMai
$LN68@ProcessMai:

; 1224 : 						prop->hiddenVolProtection = HIDVOL_PROT_STATUS_NONE;

  002ac	89 86 4c 02 00
	00		 mov	 DWORD PTR [esi+588], eax
$LN67@ProcessMai:

; 1225 : 
; 1226 : 					prop->totalBytesRead = ListExtension->Queue.TotalBytesRead;

  002b2	8b 8f 10 02 00
	00		 mov	 ecx, DWORD PTR [edi+528]
  002b8	89 8e 3c 02 00
	00		 mov	 DWORD PTR [esi+572], ecx
  002be	8b 8f 14 02 00
	00		 mov	 ecx, DWORD PTR [edi+532]
  002c4	89 8e 40 02 00
	00		 mov	 DWORD PTR [esi+576], ecx

; 1227 : 					prop->totalBytesWritten = ListExtension->Queue.TotalBytesWritten;

  002ca	8b 8f 18 02 00
	00		 mov	 ecx, DWORD PTR [edi+536]
  002d0	89 8e 44 02 00
	00		 mov	 DWORD PTR [esi+580], ecx
  002d6	8b 8f 1c 02 00
	00		 mov	 ecx, DWORD PTR [edi+540]
  002dc	89 8e 48 02 00
	00		 mov	 DWORD PTR [esi+584], ecx

; 1228 : 
; 1229 : 					prop->volFormatVersion = ListExtension->cryptoInfo->LegacyVolume ? TC_VOLUME_FORMAT_VERSION_PRE_6_0 : TC_VOLUME_FORMAT_VERSION;

  002e2	8b 4f 60	 mov	 ecx, DWORD PTR [edi+96]
  002e5	33 d2		 xor	 edx, edx
  002e7	39 81 3c 44 00
	00		 cmp	 DWORD PTR [ecx+17468], eax
  002ed	0f 94 c2	 sete	 dl
  002f0	42		 inc	 edx
  002f1	89 96 50 02 00
	00		 mov	 DWORD PTR [esi+592], edx

; 1230 : 
; 1231 : 					Irp->IoStatus.Status = STATUS_SUCCESS;

  002f7	89 43 18	 mov	 DWORD PTR [ebx+24], eax

; 1232 : 					Irp->IoStatus.Information = sizeof (VOLUME_PROPERTIES_STRUCT);

  002fa	c7 43 1c 54 02
	00 00		 mov	 DWORD PTR [ebx+28], 596	; 00000254H

; 1233 : 				}
; 1234 : 			}
; 1235 : 		}
; 1236 : 		break;

  00301	e9 67 0c 00 00	 jmp	 $LN10@ProcessMai
$LN87@ProcessMai:

; 1133 : 
; 1134 : 	case TC_IOCTL_GET_MOUNTED_VOLUMES:
; 1135 : 
; 1136 : 		if (ValidateIOBufferSize (Irp, sizeof (MOUNT_LIST_STRUCT), ValidateOutput))

  00306	6a 01		 push	 1
  00308	68 74 36 00 00	 push	 13940			; 00003674H
  0030d	53		 push	 ebx
  0030e	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00313	85 c0		 test	 eax, eax
  00315	0f 84 52 0c 00
	00		 je	 $LN10@ProcessMai

; 1137 : 		{
; 1138 : 			MOUNT_LIST_STRUCT *list = (MOUNT_LIST_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  0031b	8b 7b 0c	 mov	 edi, DWORD PTR [ebx+12]

; 1139 : 			PDEVICE_OBJECT ListDevice;
; 1140 : 			int drive;
; 1141 : 
; 1142 : 			list->ulMountedDrives = 0;

  0031e	83 27 00	 and	 DWORD PTR [edi], 0

; 1143 : 
; 1144 : 			for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)

  00321	83 a5 f8 fd ff
	ff 00		 and	 DWORD PTR _drive$30250[ebp], 0
$LL270@ProcessMai:

; 1145 : 			{
; 1146 : 				PEXTENSION ListExtension;
; 1147 : 				
; 1148 : 				ListDevice = GetVirtualVolumeDeviceObject (drive);

  00328	ff b5 f8 fd ff
	ff		 push	 DWORD PTR _drive$30250[ebp]
  0032e	e8 00 00 00 00	 call	 _GetVirtualVolumeDeviceObject@4

; 1149 : 				if (!ListDevice)

  00333	85 c0		 test	 eax, eax
  00335	0f 84 b7 00 00
	00		 je	 $LN84@ProcessMai

; 1150 : 					continue;
; 1151 : 
; 1152 : 				ListExtension = (PEXTENSION) ListDevice->DeviceExtension;

  0033b	8b 70 28	 mov	 esi, DWORD PTR [eax+40]

; 1153 : 				if (IsVolumeAccessibleByCurrentUser (ListExtension))

  0033e	56		 push	 esi
  0033f	e8 00 00 00 00	 call	 _IsVolumeAccessibleByCurrentUser@4
  00344	85 c0		 test	 eax, eax
  00346	0f 84 a6 00 00
	00		 je	 $LN84@ProcessMai

; 1154 : 				{
; 1155 : 					list->ulMountedDrives |= (1 << ListExtension->nDosDriveNo);

  0034c	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0034f	33 c0		 xor	 eax, eax
  00351	40		 inc	 eax
  00352	d3 e0		 shl	 eax, cl

; 1156 : 					wcscpy (list->wszVolume[ListExtension->nDosDriveNo], ListExtension->wszVolume);

  00354	8d 8e 60 02 00
	00		 lea	 ecx, DWORD PTR [esi+608]
  0035a	09 07		 or	 DWORD PTR [edi], eax
  0035c	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0035f	69 c0 08 02 00
	00		 imul	 eax, 520		; 00000208H
  00365	8d 54 38 04	 lea	 edx, DWORD PTR [eax+edi+4]
$LL161@ProcessMai:
  00369	0f b7 01	 movzx	 eax, WORD PTR [ecx]
  0036c	41		 inc	 ecx
  0036d	66 89 02	 mov	 WORD PTR [edx], ax
  00370	41		 inc	 ecx
  00371	42		 inc	 edx
  00372	42		 inc	 edx
  00373	66 85 c0	 test	 ax, ax
  00376	75 f1		 jne	 SHORT $LL161@ProcessMai

; 1157 : 					list->diskLength[ListExtension->nDosDriveNo] = ListExtension->DiskLength;

  00378	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0037b	8b 4e 70	 mov	 ecx, DWORD PTR [esi+112]
  0037e	89 8c c7 d4 34
	00 00		 mov	 DWORD PTR [edi+eax*8+13524], ecx
  00385	8b 4e 74	 mov	 ecx, DWORD PTR [esi+116]
  00388	89 8c c7 d8 34
	00 00		 mov	 DWORD PTR [edi+eax*8+13528], ecx

; 1158 : 					list->ea[ListExtension->nDosDriveNo] = ListExtension->cryptoInfo->ea;

  0038f	8b 46 60	 mov	 eax, DWORD PTR [esi+96]
  00392	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00395	8b 00		 mov	 eax, DWORD PTR [eax]
  00397	89 84 8f a4 35
	00 00		 mov	 DWORD PTR [edi+ecx*4+13732], eax

; 1159 : 					if (ListExtension->cryptoInfo->hiddenVolume)

  0039e	8b 46 60	 mov	 eax, DWORD PTR [esi+96]
  003a1	33 c9		 xor	 ecx, ecx
  003a3	39 88 a0 29 00
	00		 cmp	 DWORD PTR [eax+10656], ecx
  003a9	74 10		 je	 SHORT $LN80@ProcessMai

; 1160 : 						list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_HIDDEN;	// Hidden volume

  003ab	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  003ae	c7 84 87 0c 36
	00 00 01 00 00
	00		 mov	 DWORD PTR [edi+eax*4+13836], 1
  003b9	eb 37		 jmp	 SHORT $LN84@ProcessMai
$LN80@ProcessMai:

; 1161 : 					else if (ListExtension->cryptoInfo->bHiddenVolProtectionAction)

  003bb	39 88 04 44 00
	00		 cmp	 DWORD PTR [eax+17412], ecx
  003c1	74 10		 je	 SHORT $LN78@ProcessMai

; 1162 : 						list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_OUTER_VOL_WRITE_PREVENTED;	// Normal/outer volume (hidden volume protected AND write already prevented)

  003c3	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  003c6	c7 84 87 0c 36
	00 00 03 00 00
	00		 mov	 DWORD PTR [edi+eax*4+13836], 3
  003d1	eb 1f		 jmp	 SHORT $LN84@ProcessMai
$LN78@ProcessMai:

; 1163 : 					else if (ListExtension->cryptoInfo->bProtectHiddenVolume)

  003d3	39 88 00 44 00
	00		 cmp	 DWORD PTR [eax+17408], ecx

; 1164 : 						list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_OUTER;	// Normal/outer volume (hidden volume protected)

  003d9	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  003dc	74 0d		 je	 SHORT $LN76@ProcessMai
  003de	c7 84 87 0c 36
	00 00 02 00 00
	00		 mov	 DWORD PTR [edi+eax*4+13836], 2

; 1165 : 					else

  003e9	eb 07		 jmp	 SHORT $LN84@ProcessMai
$LN76@ProcessMai:

; 1166 : 						list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_NORMAL;	// Normal volume

  003eb	89 8c 87 0c 36
	00 00		 mov	 DWORD PTR [edi+eax*4+13836], ecx
$LN84@ProcessMai:

; 1143 : 
; 1144 : 			for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)

  003f2	ff 85 f8 fd ff
	ff		 inc	 DWORD PTR _drive$30250[ebp]
  003f8	83 bd f8 fd ff
	ff 19		 cmp	 DWORD PTR _drive$30250[ebp], 25 ; 00000019H
  003ff	0f 8e 23 ff ff
	ff		 jle	 $LL270@ProcessMai

; 1167 : 				}
; 1168 : 			}
; 1169 : 
; 1170 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00405	83 63 18 00	 and	 DWORD PTR [ebx+24], 0

; 1171 : 			Irp->IoStatus.Information = sizeof (MOUNT_LIST_STRUCT);

  00409	c7 43 1c 74 36
	00 00		 mov	 DWORD PTR [ebx+28], 13940 ; 00003674H

; 1172 : 		}
; 1173 : 		break;

  00410	e9 58 0b 00 00	 jmp	 $LN10@ProcessMai
$LN28@ProcessMai:

; 1422 : 
; 1423 : 	case TC_IOCTL_DISMOUNT_ALL_VOLUMES:
; 1424 : 		if (ValidateIOBufferSize (Irp, sizeof (UNMOUNT_STRUCT), ValidateInputOutput))

  00415	6a 02		 push	 2
  00417	6a 10		 push	 16			; 00000010H
  00419	5f		 pop	 edi
  0041a	57		 push	 edi
  0041b	53		 push	 ebx
  0041c	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00421	85 c0		 test	 eax, eax
  00423	0f 84 44 0b 00
	00		 je	 $LN10@ProcessMai

; 1425 : 		{
; 1426 : 			UNMOUNT_STRUCT *unmount = (UNMOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  00429	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]

; 1427 : 
; 1428 : 			unmount->nReturnCode = UnmountAllDevices (unmount, unmount->ignoreOpenFiles);

  0042c	ff 76 04	 push	 DWORD PTR [esi+4]
  0042f	56		 push	 esi
  00430	e8 00 00 00 00	 call	 _UnmountAllDevices@8
  00435	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 1429 : 
; 1430 : 			Irp->IoStatus.Information = sizeof (UNMOUNT_STRUCT);

  00438	89 7b 1c	 mov	 DWORD PTR [ebx+28], edi

; 1431 : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 1432 : 		}
; 1433 : 		break;

  0043b	eb 49		 jmp	 SHORT $LN290@ProcessMai
$LN32@ProcessMai:

; 1399 : 		}
; 1400 : 		break;
; 1401 : 
; 1402 : 	case TC_IOCTL_DISMOUNT_VOLUME:
; 1403 : 		if (ValidateIOBufferSize (Irp, sizeof (UNMOUNT_STRUCT), ValidateInputOutput))

  0043d	6a 02		 push	 2
  0043f	6a 10		 push	 16			; 00000010H
  00441	53		 push	 ebx
  00442	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00447	85 c0		 test	 eax, eax
  00449	0f 84 1e 0b 00
	00		 je	 $LN10@ProcessMai

; 1404 : 		{
; 1405 : 			UNMOUNT_STRUCT *unmount = (UNMOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  0044f	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]

; 1406 : 			PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject (unmount->nDosDriveNo);

  00452	ff 36		 push	 DWORD PTR [esi]
  00454	e8 00 00 00 00	 call	 _GetVirtualVolumeDeviceObject@4
  00459	8b f8		 mov	 edi, eax

; 1407 : 
; 1408 : 			unmount->nReturnCode = ERR_DRIVE_NOT_FOUND;

  0045b	c7 46 0c 05 00
	00 00		 mov	 DWORD PTR [esi+12], 5

; 1409 : 
; 1410 : 			if (ListDevice)

  00462	85 ff		 test	 edi, edi
  00464	74 19		 je	 SHORT $LN267@ProcessMai

; 1411 : 			{
; 1412 : 				PEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;
; 1413 : 
; 1414 : 				if (IsVolumeAccessibleByCurrentUser (ListExtension))

  00466	ff 77 28	 push	 DWORD PTR [edi+40]
  00469	e8 00 00 00 00	 call	 _IsVolumeAccessibleByCurrentUser@4
  0046e	85 c0		 test	 eax, eax
  00470	74 0d		 je	 SHORT $LN267@ProcessMai

; 1415 : 					unmount->nReturnCode = UnmountDevice (unmount, ListDevice, unmount->ignoreOpenFiles);

  00472	ff 76 04	 push	 DWORD PTR [esi+4]
  00475	57		 push	 edi
  00476	56		 push	 esi
  00477	e8 00 00 00 00	 call	 _UnmountDevice@12
  0047c	89 46 0c	 mov	 DWORD PTR [esi+12], eax
$LN267@ProcessMai:

; 1416 : 			}
; 1417 : 
; 1418 : 			Irp->IoStatus.Information = sizeof (UNMOUNT_STRUCT);

  0047f	c7 43 1c 10 00
	00 00		 mov	 DWORD PTR [ebx+28], 16	; 00000010H
$LN290@ProcessMai:

; 1419 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00486	83 63 18 00	 and	 DWORD PTR [ebx+24], 0

; 1420 : 		}
; 1421 : 		break;

  0048a	e9 de 0a 00 00	 jmp	 $LN10@ProcessMai
$LN152@ProcessMai:

; 824  : 
; 825  : 	case TC_IOCTL_GET_DEVICE_REFCOUNT:
; 826  : 		if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))

  0048f	6a 01		 push	 1
  00491	6a 04		 push	 4
  00493	5e		 pop	 esi
  00494	56		 push	 esi
  00495	53		 push	 ebx
  00496	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  0049b	85 c0		 test	 eax, eax
  0049d	0f 84 ca 0a 00
	00		 je	 $LN10@ProcessMai

; 827  : 		{
; 828  : 			*(int *) Irp->AssociatedIrp.SystemBuffer = DeviceObject->ReferenceCount;

  004a3	8b 8d f4 fd ff
	ff		 mov	 ecx, DWORD PTR _DeviceObject$GSCopy$[ebp]
  004a9	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  004ac	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  004af	89 08		 mov	 DWORD PTR [eax], ecx

; 829  : 			Irp->IoStatus.Information = sizeof (int);
; 830  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 831  : 		}
; 832  : 		break;

  004b1	e9 f0 fb ff ff	 jmp	 $LN285@ProcessMai
$LN164@ProcessMai:

; 810  : 	NTSTATUS ntStatus;
; 811  : 
; 812  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  004b6	b9 34 20 22 00	 mov	 ecx, 2236468		; 00222034H
  004bb	3b c1		 cmp	 eax, ecx
  004bd	0f 87 78 03 00
	00		 ja	 $LN166@ProcessMai
  004c3	0f 84 e2 00 00
	00		 je	 $LN140@ProcessMai
  004c9	2d 24 20 22 00	 sub	 eax, 2236452		; 00222024H
  004ce	0f 84 80 00 00
	00		 je	 $LN150@ProcessMai
  004d4	6a 04		 push	 4
  004d6	5e		 pop	 esi
  004d7	2b c6		 sub	 eax, esi
  004d9	74 31		 je	 SHORT $LN147@ProcessMai
  004db	2b c6		 sub	 eax, esi
  004dd	74 1a		 je	 SHORT $LN92@ProcessMai
  004df	2b c6		 sub	 eax, esi
  004e1	0f 85 cd 09 00
	00		 jne	 $LN1@ProcessMai

; 1097 : 			{
; 1098 : 				Irp->IoStatus.Status = ntStatus;
; 1099 : 				Irp->IoStatus.Information = 0;
; 1100 : 			}
; 1101 : 		}
; 1102 : 		break;
; 1103 : 
; 1104 : 	case TC_IOCTL_WIPE_PASSWORD_CACHE:
; 1105 : 		WipeCache ();

  004e7	e8 00 00 00 00	 call	 _WipeCache@0
$LN293@ProcessMai:

; 1106 : 
; 1107 : 		Irp->IoStatus.Status = STATUS_SUCCESS;

  004ec	83 63 18 00	 and	 DWORD PTR [ebx+24], 0
$LN288@ProcessMai:

; 1108 : 		Irp->IoStatus.Information = 0;

  004f0	83 63 1c 00	 and	 DWORD PTR [ebx+28], 0

; 1109 : 		break;

  004f4	e9 74 0a 00 00	 jmp	 $LN10@ProcessMai
$LN92@ProcessMai:

; 1110 : 
; 1111 : 	case TC_IOCTL_GET_PASSWORD_CACHE_STATUS:
; 1112 : 		Irp->IoStatus.Status = cacheEmpty ? STATUS_PIPE_EMPTY : STATUS_SUCCESS;

  004f9	a1 00 00 00 00	 mov	 eax, DWORD PTR _cacheEmpty
  004fe	f7 d8		 neg	 eax
  00500	1b c0		 sbb	 eax, eax
  00502	25 d9 00 00 c0	 and	 eax, -1073741607	; c00000d9H
$LN292@ProcessMai:
  00507	89 43 18	 mov	 DWORD PTR [ebx+24], eax

; 1113 : 		Irp->IoStatus.Information = 0;
; 1114 : 		break;

  0050a	eb e4		 jmp	 SHORT $LN288@ProcessMai
$LN147@ProcessMai:

; 848  : 
; 849  : 	case TC_IOCTL_IS_ANY_VOLUME_MOUNTED:
; 850  : 		if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))

  0050c	33 ff		 xor	 edi, edi
  0050e	47		 inc	 edi
  0050f	57		 push	 edi
  00510	56		 push	 esi
  00511	53		 push	 ebx
  00512	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00517	85 c0		 test	 eax, eax
  00519	0f 84 4e 0a 00
	00		 je	 $LN10@ProcessMai

; 851  : 		{
; 852  : 			int drive;
; 853  : 			*(int *) Irp->AssociatedIrp.SystemBuffer = 0;

  0051f	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00522	33 c9		 xor	 ecx, ecx
  00524	89 08		 mov	 DWORD PTR [eax], ecx
$LL145@ProcessMai:

; 854  : 
; 855  : 			for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)
; 856  : 			{
; 857  : 				if (GetVirtualVolumeDeviceObject (drive))

  00526	51		 push	 ecx
  00527	e8 00 00 00 00	 call	 _GetVirtualVolumeDeviceObject@4
  0052c	85 c0		 test	 eax, eax
  0052e	75 08		 jne	 SHORT $LN207@ProcessMai
  00530	41		 inc	 ecx
  00531	83 f9 19	 cmp	 ecx, 25			; 00000019H
  00534	7e f0		 jle	 SHORT $LL145@ProcessMai

; 1069 : 					{
; 1070 : 						if (memcmp (readBuffer + i, TC_APP_NAME_LEGACY, strlen (TC_APP_NAME_LEGACY)) == 0)

  00536	eb 05		 jmp	 SHORT $LN143@ProcessMai
$LN207@ProcessMai:

; 858  : 				{
; 859  : 					*(int *) Irp->AssociatedIrp.SystemBuffer = 1;

  00538	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0053b	89 38		 mov	 DWORD PTR [eax], edi
$LN143@ProcessMai:

; 860  : 					break;
; 861  : 				}
; 862  : 			}
; 863  : 
; 864  : 			if (IsBootDriveMounted())

  0053d	e8 00 00 00 00	 call	 _IsBootDriveMounted@0
  00542	85 c0		 test	 eax, eax
  00544	0f 84 5c fb ff
	ff		 je	 $LN285@ProcessMai
$LN291@ProcessMai:

; 865  : 				*(int *) Irp->AssociatedIrp.SystemBuffer = 1;

  0054a	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0054d	89 38		 mov	 DWORD PTR [eax], edi

; 866  : 
; 867  : 			Irp->IoStatus.Information = sizeof (int);
; 868  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 869  : 		}
; 870  : 		break;

  0054f	e9 52 fb ff ff	 jmp	 $LN285@ProcessMai
$LN150@ProcessMai:

; 833  : 
; 834  : 	case TC_IOCTL_IS_DRIVER_UNLOAD_DISABLED:
; 835  : 		if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))

  00554	33 ff		 xor	 edi, edi
  00556	47		 inc	 edi
  00557	57		 push	 edi
  00558	6a 04		 push	 4
  0055a	5e		 pop	 esi
  0055b	56		 push	 esi
  0055c	53		 push	 ebx
  0055d	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00562	85 c0		 test	 eax, eax
  00564	0f 84 03 0a 00
	00		 je	 $LN10@ProcessMai

; 836  : 		{
; 837  : 			LONG deviceObjectCount = 0;
; 838  : 
; 839  : 			*(int *) Irp->AssociatedIrp.SystemBuffer = DriverUnloadDisabled;

  0056a	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  0056d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _DriverUnloadDisabled
  00573	33 c0		 xor	 eax, eax
  00575	89 85 f4 fd ff
	ff		 mov	 DWORD PTR _deviceObjectCount$30104[ebp], eax
  0057b	89 11		 mov	 DWORD PTR [ecx], edx

; 840  : 
; 841  : 			if (IoEnumerateDeviceObjectList (TCDriverObject, NULL, 0, &deviceObjectCount) == STATUS_BUFFER_TOO_SMALL && deviceObjectCount > 1)

  0057d	8d 8d f4 fd ff
	ff		 lea	 ecx, DWORD PTR _deviceObjectCount$30104[ebp]
  00583	51		 push	 ecx
  00584	50		 push	 eax
  00585	50		 push	 eax
  00586	ff 35 00 00 00
	00		 push	 DWORD PTR _TCDriverObject
  0058c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoEnumerateDeviceObjectList@16
  00592	3d 23 00 00 c0	 cmp	 eax, -1073741789	; c0000023H
  00597	0f 85 09 fb ff
	ff		 jne	 $LN285@ProcessMai
  0059d	39 bd f4 fd ff
	ff		 cmp	 DWORD PTR _deviceObjectCount$30104[ebp], edi
  005a3	0f 8e fd fa ff
	ff		 jle	 $LN285@ProcessMai

; 842  : 				*(int *) Irp->AssociatedIrp.SystemBuffer = TRUE;
; 843  : 
; 844  : 			Irp->IoStatus.Information = sizeof (int);
; 845  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 846  : 		}
; 847  : 		break;

  005a9	eb 9f		 jmp	 SHORT $LN291@ProcessMai
$LN140@ProcessMai:

; 871  : 
; 872  : 	case TC_IOCTL_OPEN_TEST:
; 873  : 		{
; 874  : 			OPEN_TEST_STRUCT *opentest = (OPEN_TEST_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  005ab	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]

; 875  : 			OBJECT_ATTRIBUTES ObjectAttributes;
; 876  : 			HANDLE NtFileHandle;
; 877  : 			UNICODE_STRING FullFileName;
; 878  : 			IO_STATUS_BLOCK IoStatus;
; 879  : 			LARGE_INTEGER offset;
; 880  : 			ACCESS_MASK access = FILE_READ_ATTRIBUTES;
; 881  : 
; 882  : 			if (!ValidateIOBufferSize (Irp, sizeof (OPEN_TEST_STRUCT), ValidateInputOutput))

  005ae	6a 02		 push	 2
  005b0	68 18 02 00 00	 push	 536			; 00000218H
  005b5	53		 push	 ebx
  005b6	89 b5 f0 fd ff
	ff		 mov	 DWORD PTR _opentest$30127[ebp], esi
  005bc	c7 85 f4 fd ff
	ff 80 00 00 00	 mov	 DWORD PTR _access$30134[ebp], 128 ; 00000080H
  005c6	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  005cb	85 c0		 test	 eax, eax
  005cd	0f 84 9a 09 00
	00		 je	 $LN10@ProcessMai

; 883  : 				break;
; 884  : 
; 885  : 			EnsureNullTerminatedString (opentest->wszFileName, sizeof (opentest->wszFileName));

  005d3	33 c0		 xor	 eax, eax
  005d5	66 89 86 06 02
	00 00		 mov	 WORD PTR [esi+518], ax

; 886  : 			RtlInitUnicodeString (&FullFileName, opentest->wszFileName);

  005dc	56		 push	 esi
  005dd	8d 85 7c fd ff
	ff		 lea	 eax, DWORD PTR _FullFileName$30131[ebp]
  005e3	50		 push	 eax
  005e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 887  : 
; 888  : 			InitializeObjectAttributes (&ObjectAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

  005ea	33 ff		 xor	 edi, edi
  005ec	8d 85 7c fd ff
	ff		 lea	 eax, DWORD PTR _FullFileName$30131[ebp]
  005f2	c7 85 ac fd ff
	ff 18 00 00 00	 mov	 DWORD PTR _ObjectAttributes$30129[ebp], 24 ; 00000018H
  005fc	89 bd b0 fd ff
	ff		 mov	 DWORD PTR _ObjectAttributes$30129[ebp+4], edi
  00602	c7 85 b8 fd ff
	ff 40 02 00 00	 mov	 DWORD PTR _ObjectAttributes$30129[ebp+12], 576 ; 00000240H
  0060c	89 85 b4 fd ff
	ff		 mov	 DWORD PTR _ObjectAttributes$30129[ebp+8], eax
  00612	89 bd bc fd ff
	ff		 mov	 DWORD PTR _ObjectAttributes$30129[ebp+16], edi
  00618	89 bd c0 fd ff
	ff		 mov	 DWORD PTR _ObjectAttributes$30129[ebp+20], edi

; 889  : 
; 890  : 			if (opentest->bDetectTCBootLoader || opentest->DetectFilesystem)

  0061e	39 be 08 02 00
	00		 cmp	 DWORD PTR [esi+520], edi
  00624	75 08		 jne	 SHORT $LN137@ProcessMai
  00626	39 be 10 02 00
	00		 cmp	 DWORD PTR [esi+528], edi
  0062c	74 0a		 je	 SHORT $LN138@ProcessMai
$LN137@ProcessMai:

; 891  : 				access |= FILE_READ_DATA;

  0062e	c7 85 f4 fd ff
	ff 81 00 00 00	 mov	 DWORD PTR _access$30134[ebp], 129 ; 00000081H
$LN138@ProcessMai:

; 892  : 
; 893  : 			ntStatus = ZwCreateFile (&NtFileHandle,
; 894  : 						 SYNCHRONIZE | access, &ObjectAttributes, &IoStatus, NULL,
; 895  : 						 0, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);

  00638	57		 push	 edi
  00639	57		 push	 edi
  0063a	6a 20		 push	 32			; 00000020H
  0063c	6a 01		 push	 1
  0063e	6a 03		 push	 3
  00640	57		 push	 edi
  00641	57		 push	 edi
  00642	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _IoStatus$30132[ebp]
  00648	50		 push	 eax
  00649	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR _ObjectAttributes$30129[ebp]
  0064f	50		 push	 eax
  00650	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _access$30134[ebp]
  00656	0d 00 00 10 00	 or	 eax, 1048576		; 00100000H
  0065b	50		 push	 eax
  0065c	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _NtFileHandle$30130[ebp]
  00662	50		 push	 eax
  00663	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwCreateFile@44

; 896  : 
; 897  : 			if (NT_SUCCESS (ntStatus))

  00669	3b c7		 cmp	 eax, edi
  0066b	89 85 f4 fd ff
	ff		 mov	 DWORD PTR _ntStatus$[ebp], eax
  00671	0f 8c b3 01 00
	00		 jl	 $LN264@ProcessMai

; 898  : 			{
; 899  : 				opentest->TCBootLoaderDetected = FALSE;

  00677	89 be 0c 02 00
	00		 mov	 DWORD PTR [esi+524], edi

; 900  : 				opentest->FilesystemDetected = FALSE;

  0067d	89 be 14 02 00
	00		 mov	 DWORD PTR [esi+532], edi

; 901  : 
; 902  : 				if (opentest->bDetectTCBootLoader || opentest->DetectFilesystem)

  00683	39 be 08 02 00
	00		 cmp	 DWORD PTR [esi+520], edi
  00689	75 0c		 jne	 SHORT $LN134@ProcessMai
  0068b	39 be 10 02 00
	00		 cmp	 DWORD PTR [esi+528], edi
  00691	0f 84 7a 01 00
	00		 je	 $LN263@ProcessMai
$LN134@ProcessMai:

; 903  : 				{
; 904  : 					byte *readBuffer = TCalloc (TC_MAX_VOLUME_SECTOR_SIZE);

  00697	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0069c	68 00 10 00 00	 push	 4096			; 00001000H
  006a1	57		 push	 edi
  006a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  006a8	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _readBuffer$30149[ebp], eax

; 905  : 					if (!readBuffer)

  006ae	3b c7		 cmp	 eax, edi
  006b0	75 0f		 jne	 SHORT $LN133@ProcessMai

; 906  : 					{
; 907  : 						ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  006b2	c7 85 f4 fd ff
	ff 9a 00 00 c0	 mov	 DWORD PTR _ntStatus$[ebp], -1073741670 ; c000009aH

; 908  : 					}
; 909  : 					else

  006bc	e9 50 01 00 00	 jmp	 $LN263@ProcessMai
$LN133@ProcessMai:

; 910  : 					{
; 911  : 						// Determine if the first sector contains a portion of the TrueCrypt Boot Loader
; 912  : 
; 913  : 						offset.QuadPart = 0;
; 914  : 
; 915  : 						ntStatus = ZwReadFile (NtFileHandle,
; 916  : 							NULL,
; 917  : 							NULL,
; 918  : 							NULL,
; 919  : 							&IoStatus,
; 920  : 							readBuffer,
; 921  : 							TC_MAX_VOLUME_SECTOR_SIZE,
; 922  : 							&offset,
; 923  : 							NULL);

  006c1	57		 push	 edi
  006c2	8d 85 c4 fd ff
	ff		 lea	 eax, DWORD PTR _offset$30133[ebp]
  006c8	50		 push	 eax
  006c9	68 00 10 00 00	 push	 4096			; 00001000H
  006ce	ff b5 f8 fd ff
	ff		 push	 DWORD PTR _readBuffer$30149[ebp]
  006d4	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _IoStatus$30132[ebp]
  006da	50		 push	 eax
  006db	57		 push	 edi
  006dc	57		 push	 edi
  006dd	57		 push	 edi
  006de	ff b5 ec fd ff
	ff		 push	 DWORD PTR _NtFileHandle$30130[ebp]
  006e4	89 bd c4 fd ff
	ff		 mov	 DWORD PTR _offset$30133[ebp], edi
  006ea	89 bd c8 fd ff
	ff		 mov	 DWORD PTR _offset$30133[ebp+4], edi
  006f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwReadFile@36

; 924  : 
; 925  : 						if (NT_SUCCESS (ntStatus))

  006f6	3b c7		 cmp	 eax, edi
  006f8	89 85 f4 fd ff
	ff		 mov	 DWORD PTR _ntStatus$[ebp], eax
  006fe	0f 8c fc 00 00
	00		 jl	 $LN258@ProcessMai

; 926  : 						{
; 927  : 							size_t i;
; 928  : 
; 929  : 							if (opentest->bDetectTCBootLoader && IoStatus.Information >= TC_SECTOR_SIZE_BIOS)

  00704	39 be 08 02 00
	00		 cmp	 DWORD PTR [esi+520], edi
  0070a	0f 84 82 00 00
	00		 je	 $LN257@ProcessMai
  00710	81 bd e8 fd ff
	ff 00 02 00 00	 cmp	 DWORD PTR _IoStatus$30132[ebp+4], 512 ; 00000200H
  0071a	72 76		 jb	 SHORT $LN257@ProcessMai

; 930  : 							{
; 931  : 								// Search for the string "CipherShed"
; 932  : 								for (i = 0; i < TC_SECTOR_SIZE_BIOS - strlen (TC_APP_NAME); ++i)

  0071c	33 c0		 xor	 eax, eax
$LL129@ProcessMai:

; 933  : 								{
; 934  : 									if (memcmp (readBuffer + i, TC_APP_NAME, strlen (TC_APP_NAME)) == 0)

  0071e	8b 95 f8 fd ff
	ff		 mov	 edx, DWORD PTR _readBuffer$30149[ebp]
  00724	6a 05		 push	 5
  00726	8d 34 10	 lea	 esi, DWORD PTR [eax+edx]
  00729	59		 pop	 ecx
  0072a	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_0L@FEEFGEIL@CipherShed?$AA@FNODOBFM@
  0072f	33 d2		 xor	 edx, edx
  00731	66 f3 a7	 repe cmpsw
  00734	74 0a		 je	 SHORT $LN208@ProcessMai
  00736	40		 inc	 eax
  00737	3d f6 01 00 00	 cmp	 eax, 502		; 000001f6H
  0073c	72 e0		 jb	 SHORT $LL129@ProcessMai

; 1069 : 					{
; 1070 : 						if (memcmp (readBuffer + i, TC_APP_NAME_LEGACY, strlen (TC_APP_NAME_LEGACY)) == 0)

  0073e	eb 10		 jmp	 SHORT $LN127@ProcessMai
$LN208@ProcessMai:

; 935  : 									{
; 936  : 										opentest->TCBootLoaderDetected = TRUE;

  00740	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _opentest$30127[ebp]
  00746	c7 80 0c 02 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+524], 1
$LN127@ProcessMai:

; 937  : 										break;
; 938  : 									}
; 939  : 								}
; 940  : 
; 941  : 								// Search for the string "TrueCrypt"
; 942  : 								if (!(opentest->TCBootLoaderDetected))

  00750	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _opentest$30127[ebp]
  00756	83 b8 0c 02 00
	00 00		 cmp	 DWORD PTR [eax+524], 0
  0075d	75 33		 jne	 SHORT $LN257@ProcessMai

; 943  : 								for (i = 0; i < TC_SECTOR_SIZE_BIOS - strlen (TC_APP_NAME_LEGACY); ++i)

  0075f	33 c0		 xor	 eax, eax
$LL268@ProcessMai:

; 944  : 								{
; 945  : 									if (memcmp (readBuffer + i, TC_APP_NAME_LEGACY, strlen (TC_APP_NAME_LEGACY)) == 0)

  00761	8b 95 f8 fd ff
	ff		 mov	 edx, DWORD PTR _readBuffer$30149[ebp]
  00767	6a 09		 push	 9
  00769	8d 34 10	 lea	 esi, DWORD PTR [eax+edx]
  0076c	59		 pop	 ecx
  0076d	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_09EMKKFGIH@TrueCrypt?$AA@FNODOBFM@
  00772	33 d2		 xor	 edx, edx
  00774	f3 a6		 repe cmpsb
  00776	74 0a		 je	 SHORT $LN209@ProcessMai
  00778	40		 inc	 eax
  00779	3d f7 01 00 00	 cmp	 eax, 503		; 000001f7H
  0077e	72 e1		 jb	 SHORT $LL268@ProcessMai

; 1069 : 					{
; 1070 : 						if (memcmp (readBuffer + i, TC_APP_NAME_LEGACY, strlen (TC_APP_NAME_LEGACY)) == 0)

  00780	eb 10		 jmp	 SHORT $LN257@ProcessMai
$LN209@ProcessMai:

; 946  : 									{
; 947  : 										opentest->TCBootLoaderDetected = TRUE;

  00782	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _opentest$30127[ebp]
  00788	c7 80 0c 02 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+524], 1
$LN257@ProcessMai:

; 948  : 										break;
; 949  : 									}
; 950  : 								}
; 951  : 							}
; 952  : 
; 953  : 							if (opentest->DetectFilesystem && IoStatus.Information >= sizeof (int64))

  00792	8b b5 f0 fd ff
	ff		 mov	 esi, DWORD PTR _opentest$30127[ebp]
  00798	33 ff		 xor	 edi, edi
  0079a	39 be 10 02 00
	00		 cmp	 DWORD PTR [esi+528], edi
  007a0	74 5e		 je	 SHORT $LN258@ProcessMai
  007a2	83 bd e8 fd ff
	ff 08		 cmp	 DWORD PTR _IoStatus$30132[ebp+4], 8
  007a9	72 55		 jb	 SHORT $LN258@ProcessMai

; 954  : 							{
; 955  : 								switch (BE64 (*(uint64 *) readBuffer))

  007ab	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR _readBuffer$30149[ebp]
  007b1	ff 70 04	 push	 DWORD PTR [eax+4]
  007b4	ff 30		 push	 DWORD PTR [eax]
  007b6	e8 00 00 00 00	 call	 _MirrorBytes64@8
  007bb	b9 53 4f 44 53	 mov	 ecx, 1396985683		; 53444f53H
  007c0	3b c1		 cmp	 eax, ecx
  007c2	75 08		 jne	 SHORT $LN240@ProcessMai
  007c4	81 fa 4d 90 3c
	eb		 cmp	 edx, -348352435		; eb3c904dH
  007ca	74 2a		 je	 SHORT $LN117@ProcessMai
$LN240@ProcessMai:
  007cc	3d 20 53 46 54	 cmp	 eax, 1413894944		; 54465320H
  007d1	75 08		 jne	 SHORT $LN241@ProcessMai
  007d3	81 fa 4e 90 52
	eb		 cmp	 edx, -346910642		; eb52904eH
  007d9	74 1b		 je	 SHORT $LN117@ProcessMai
$LN241@ProcessMai:
  007db	3b c1		 cmp	 eax, ecx
  007dd	75 08		 jne	 SHORT $LN242@ProcessMai
  007df	81 fa 4d 90 58
	eb		 cmp	 edx, -346517427		; eb58904dH
  007e5	74 0f		 je	 SHORT $LN117@ProcessMai
$LN242@ProcessMai:
  007e7	3d 54 41 46 58	 cmp	 eax, 1480999252		; 58464154H
  007ec	75 12		 jne	 SHORT $LN258@ProcessMai
  007ee	81 fa 45 90 76
	eb		 cmp	 edx, -344551355		; eb769045H
  007f4	75 0a		 jne	 SHORT $LN258@ProcessMai
$LN117@ProcessMai:

; 956  : 								{
; 957  : 								case 0xEB52904E54465320: // NTFS
; 958  : 								case 0xEB3C904D53444F53: // FAT16
; 959  : 								case 0xEB58904D53444F53: // FAT32
; 960  : 								case 0xEB76904558464154: // exFAT
; 961  : 
; 962  : 									opentest->FilesystemDetected = TRUE;

  007f6	c7 86 14 02 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+532], 1
$LN258@ProcessMai:

; 963  : 									break;
; 964  : 								}
; 965  : 							}
; 966  : 						}
; 967  : 
; 968  : 						TCfree (readBuffer);

  00800	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00805	ff b5 f8 fd ff
	ff		 push	 DWORD PTR _readBuffer$30149[ebp]
  0080b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN263@ProcessMai:

; 969  : 					}
; 970  : 				}
; 971  : 
; 972  : 				ZwClose (NtFileHandle);

  00811	ff b5 ec fd ff
	ff		 push	 DWORD PTR _NtFileHandle$30130[ebp]
  00817	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 973  : 				Dump ("Open test on file %ls success.\n", opentest->wszFileName);
; 974  : 			}
; 975  : 			else
; 976  : 			{
; 977  : #if 0
; 978  : 				Dump ("Open test on file %ls failed NTSTATUS 0x%08x\n", opentest->wszFileName, ntStatus);
; 979  : #endif
; 980  : 			}
; 981  : 
; 982  : 			Irp->IoStatus.Information = NT_SUCCESS (ntStatus) ? sizeof (OPEN_TEST_STRUCT) : 0;

  0081d	39 bd f4 fd ff
	ff		 cmp	 DWORD PTR _ntStatus$[ebp], edi
  00823	7c 05		 jl	 SHORT $LN264@ProcessMai
  00825	bf 18 02 00 00	 mov	 edi, 536		; 00000218H
$LN264@ProcessMai:

; 983  : 			Irp->IoStatus.Status = ntStatus;

  0082a	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _ntStatus$[ebp]
  00830	89 7b 1c	 mov	 DWORD PTR [ebx+28], edi
$LN287@ProcessMai:
  00833	89 43 18	 mov	 DWORD PTR [ebx+24], eax

; 984  : 		}
; 985  : 		break;

  00836	e9 32 07 00 00	 jmp	 $LN10@ProcessMai
$LN166@ProcessMai:

; 810  : 	NTSTATUS ntStatus;
; 811  : 
; 812  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  0083b	2d 38 20 22 00	 sub	 eax, 2236472		; 00222038H
  00840	0f 84 4c 01 00
	00		 je	 $LN64@ProcessMai
  00846	6a 04		 push	 4
  00848	5e		 pop	 esi
  00849	2b c6		 sub	 eax, esi
  0084b	0f 84 02 01 00
	00		 je	 $LN55@ProcessMai
  00851	2b c6		 sub	 eax, esi
  00853	74 44		 je	 SHORT $LN53@ProcessMai
  00855	2b c6		 sub	 eax, esi
  00857	0f 85 57 06 00
	00		 jne	 $LN1@ProcessMai

; 1237 : 
; 1238 : 	case TC_IOCTL_GET_RESOLVED_SYMLINK:
; 1239 : 		if (ValidateIOBufferSize (Irp, sizeof (RESOLVE_SYMLINK_STRUCT), ValidateInputOutput))

  0085d	6a 02		 push	 2
  0085f	be 10 04 00 00	 mov	 esi, 1040		; 00000410H
  00864	56		 push	 esi
  00865	53		 push	 ebx
  00866	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  0086b	85 c0		 test	 eax, eax
  0086d	0f 84 fa 06 00
	00		 je	 $LN10@ProcessMai

; 1240 : 		{
; 1241 : 			RESOLVE_SYMLINK_STRUCT *resolve = (RESOLVE_SYMLINK_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  00873	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]

; 1242 : 			{
; 1243 : 				NTSTATUS ntStatus;
; 1244 : 
; 1245 : 				EnsureNullTerminatedString (resolve->symLinkName, sizeof (resolve->symLinkName));

  00876	33 c9		 xor	 ecx, ecx
  00878	66 89 88 06 02
	00 00		 mov	 WORD PTR [eax+518], cx

; 1246 : 
; 1247 : 				ntStatus = SymbolicLinkToTarget (resolve->symLinkName,
; 1248 : 					resolve->targetName,
; 1249 : 					sizeof (resolve->targetName));

  0087f	68 08 02 00 00	 push	 520			; 00000208H
  00884	8d 88 08 02 00
	00		 lea	 ecx, DWORD PTR [eax+520]
  0088a	51		 push	 ecx
  0088b	50		 push	 eax
  0088c	e8 00 00 00 00	 call	 _SymbolicLinkToTarget@12
$LN286@ProcessMai:

; 1250 : 
; 1251 : 				Irp->IoStatus.Information = sizeof (RESOLVE_SYMLINK_STRUCT);
; 1252 : 				Irp->IoStatus.Status = ntStatus;

  00891	89 43 18	 mov	 DWORD PTR [ebx+24], eax

; 1253 : 			}
; 1254 : 		}
; 1255 : 		break;

  00894	e9 d1 06 00 00	 jmp	 $LN283@ProcessMai
$LN53@ProcessMai:

; 1336 : 
; 1337 : 	case TC_IOCTL_PROBE_REAL_DRIVE_SIZE:
; 1338 : 		if (ValidateIOBufferSize (Irp, sizeof (ProbeRealDriveSizeRequest), ValidateInputOutput))

  00899	6a 02		 push	 2
  0089b	68 14 02 00 00	 push	 532			; 00000214H
  008a0	53		 push	 ebx
  008a1	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  008a6	85 c0		 test	 eax, eax
  008a8	0f 84 bf 06 00
	00		 je	 $LN10@ProcessMai

; 1339 : 		{
; 1340 : 			ProbeRealDriveSizeRequest *request = (ProbeRealDriveSizeRequest *) Irp->AssociatedIrp.SystemBuffer;

  008ae	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]

; 1341 : 			NTSTATUS status;
; 1342 : 			UNICODE_STRING name;
; 1343 : 			PFILE_OBJECT fileObject;
; 1344 : 			PDEVICE_OBJECT deviceObject;
; 1345 : 
; 1346 : 			EnsureNullTerminatedString (request->DeviceName, sizeof (request->DeviceName));

  008b1	33 c0		 xor	 eax, eax
  008b3	66 89 86 06 02
	00 00		 mov	 WORD PTR [esi+518], ax

; 1347 : 
; 1348 : 			RtlInitUnicodeString (&name, request->DeviceName);

  008ba	56		 push	 esi
  008bb	8d 85 74 fd ff
	ff		 lea	 eax, DWORD PTR _name$30332[ebp]
  008c1	50		 push	 eax
  008c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 1349 : 			status = IoGetDeviceObjectPointer (&name, FILE_READ_ATTRIBUTES, &fileObject, &deviceObject);

  008c8	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _deviceObject$30334[ebp]
  008ce	50		 push	 eax
  008cf	8d 85 e0 fd ff
	ff		 lea	 eax, DWORD PTR _fileObject$30333[ebp]
  008d5	50		 push	 eax
  008d6	68 80 00 00 00	 push	 128			; 00000080H
  008db	8d 85 74 fd ff
	ff		 lea	 eax, DWORD PTR _name$30332[ebp]
  008e1	50		 push	 eax
  008e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoGetDeviceObjectPointer@16

; 1350 : 			if (!NT_SUCCESS (status))

  008e8	85 c0		 test	 eax, eax
  008ea	7d 09		 jge	 SHORT $LN51@ProcessMai

; 1351 : 			{
; 1352 : 				Irp->IoStatus.Information = 0;

  008ec	83 63 1c 00	 and	 DWORD PTR [ebx+28], 0

; 1353 : 				Irp->IoStatus.Status = status;
; 1354 : 				break;

  008f0	e9 3e ff ff ff	 jmp	 $LN287@ProcessMai
$LN51@ProcessMai:

; 1355 : 			}
; 1356 : 
; 1357 : 			status = ProbeRealDriveSize (deviceObject, &request->RealDriveSize);

  008f5	8d 86 08 02 00
	00		 lea	 eax, DWORD PTR [esi+520]
  008fb	50		 push	 eax
  008fc	ff b5 dc fd ff
	ff		 push	 DWORD PTR _deviceObject$30334[ebp]
  00902	e8 00 00 00 00	 call	 _ProbeRealDriveSize@8

; 1358 : 			ObDereferenceObject (fileObject);

  00907	8b 8d e0 fd ff
	ff		 mov	 ecx, DWORD PTR _fileObject$30333[ebp]
  0090d	8b f8		 mov	 edi, eax
  0090f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 1359 : 
; 1360 : 			if (status == STATUS_TIMEOUT)

  00915	81 ff 02 01 00
	00		 cmp	 edi, 258		; 00000102H
  0091b	75 16		 jne	 SHORT $LN50@ProcessMai

; 1361 : 			{
; 1362 : 				request->TimeOut = TRUE;

  0091d	c7 86 10 02 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+528], 1

; 1363 : 				Irp->IoStatus.Information = sizeof (ProbeRealDriveSizeRequest);

  00927	c7 43 1c 14 02
	00 00		 mov	 DWORD PTR [ebx+28], 532	; 00000214H

; 1364 : 				Irp->IoStatus.Status = STATUS_SUCCESS;

  0092e	e9 53 fb ff ff	 jmp	 $LN290@ProcessMai
$LN50@ProcessMai:

; 1365 : 			}
; 1366 : 			else if (!NT_SUCCESS (status))

  00933	85 ff		 test	 edi, edi
  00935	7d 06		 jge	 SHORT $LN48@ProcessMai

; 1367 : 			{
; 1368 : 				Irp->IoStatus.Information = 0;

  00937	83 63 1c 00	 and	 DWORD PTR [ebx+28], 0

; 1369 : 				Irp->IoStatus.Status = status;
; 1370 : 			}
; 1371 : 			else

  0093b	eb 0e		 jmp	 SHORT $LN289@ProcessMai
$LN48@ProcessMai:

; 1372 : 			{
; 1373 : 				request->TimeOut = FALSE;

  0093d	83 a6 10 02 00
	00 00		 and	 DWORD PTR [esi+528], 0

; 1374 : 				Irp->IoStatus.Information = sizeof (ProbeRealDriveSizeRequest);

  00944	c7 43 1c 14 02
	00 00		 mov	 DWORD PTR [ebx+28], 532	; 00000214H
$LN289@ProcessMai:

; 1375 : 				Irp->IoStatus.Status = status;

  0094b	89 7b 18	 mov	 DWORD PTR [ebx+24], edi

; 1376 : 			}
; 1377 : 		}
; 1378 : 		break;

  0094e	e9 1a 06 00 00	 jmp	 $LN10@ProcessMai
$LN55@ProcessMai:

; 1317 : 
; 1318 : 	case TC_IOCTL_GET_DRIVE_GEOMETRY:
; 1319 : 		if (ValidateIOBufferSize (Irp, sizeof (DISK_GEOMETRY_STRUCT), ValidateInputOutput))

  00953	6a 02		 push	 2
  00955	be 20 02 00 00	 mov	 esi, 544		; 00000220H
  0095a	56		 push	 esi
  0095b	53		 push	 ebx
  0095c	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00961	85 c0		 test	 eax, eax
  00963	0f 84 04 06 00
	00		 je	 $LN10@ProcessMai

; 1320 : 		{
; 1321 : 			DISK_GEOMETRY_STRUCT *g = (DISK_GEOMETRY_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  00969	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]

; 1322 : 			{
; 1323 : 				NTSTATUS ntStatus;
; 1324 : 
; 1325 : 				EnsureNullTerminatedString (g->deviceName, sizeof (g->deviceName));

  0096c	33 c9		 xor	 ecx, ecx

; 1326 : 
; 1327 : 				ntStatus = TCDeviceIoControl (g->deviceName,
; 1328 : 					IOCTL_DISK_GET_DRIVE_GEOMETRY,
; 1329 : 					NULL, 0, &g->diskGeometry, sizeof (g->diskGeometry));

  0096e	6a 18		 push	 24			; 00000018H
  00970	66 89 88 06 02
	00 00		 mov	 WORD PTR [eax+518], cx
  00977	8d 88 08 02 00
	00		 lea	 ecx, DWORD PTR [eax+520]
  0097d	51		 push	 ecx
  0097e	6a 00		 push	 0
  00980	6a 00		 push	 0
  00982	68 00 00 07 00	 push	 458752			; 00070000H
  00987	50		 push	 eax
  00988	e8 00 00 00 00	 call	 _TCDeviceIoControl@24

; 1330 : 
; 1331 : 				Irp->IoStatus.Information = sizeof (DISK_GEOMETRY_STRUCT);
; 1332 : 				Irp->IoStatus.Status = ntStatus;
; 1333 : 			}
; 1334 : 		}
; 1335 : 		break;

  0098d	e9 ff fe ff ff	 jmp	 $LN286@ProcessMai
$LN64@ProcessMai:

; 1256 : 
; 1257 : 	case TC_IOCTL_GET_DRIVE_PARTITION_INFO:
; 1258 : 		if (ValidateIOBufferSize (Irp, sizeof (DISK_PARTITION_INFO_STRUCT), ValidateInputOutput))

  00992	6a 02		 push	 2
  00994	68 30 02 00 00	 push	 560			; 00000230H
  00999	53		 push	 ebx
  0099a	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  0099f	85 c0		 test	 eax, eax
  009a1	0f 84 c6 05 00
	00		 je	 $LN10@ProcessMai

; 1259 : 		{
; 1260 : 			DISK_PARTITION_INFO_STRUCT *info = (DISK_PARTITION_INFO_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  009a7	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]

; 1261 : 			{
; 1262 : 				PARTITION_INFORMATION_EX pi;
; 1263 : 				NTSTATUS ntStatus;
; 1264 : 
; 1265 : 				EnsureNullTerminatedString (info->deviceName, sizeof (info->deviceName));

  009aa	33 c0		 xor	 eax, eax

; 1266 : 
; 1267 : 				ntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0, &pi, sizeof (pi));

  009ac	68 90 00 00 00	 push	 144			; 00000090H
  009b1	66 89 86 06 02
	00 00		 mov	 WORD PTR [esi+518], ax
  009b8	8d 85 e4 fc ff
	ff		 lea	 eax, DWORD PTR _pi$30298[ebp]
  009be	50		 push	 eax
  009bf	33 ff		 xor	 edi, edi
  009c1	57		 push	 edi
  009c2	57		 push	 edi
  009c3	68 48 00 07 00	 push	 458824			; 00070048H
  009c8	56		 push	 esi
  009c9	e8 00 00 00 00	 call	 _TCDeviceIoControl@24

; 1268 : 				if (NT_SUCCESS(ntStatus))

  009ce	3b c7		 cmp	 eax, edi
  009d0	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _ntStatus$30299[ebp], eax
  009d6	7c 79		 jl	 SHORT $LN62@ProcessMai

; 1269 : 				{
; 1270 : 					memset (&info->partInfo, 0, sizeof (info->partInfo));

  009d8	33 c0		 xor	 eax, eax

; 1271 : 
; 1272 : 					info->partInfo.PartitionLength = pi.PartitionLength;
; 1273 : 					info->partInfo.PartitionNumber = pi.PartitionNumber;
; 1274 : 					info->partInfo.StartingOffset = pi.StartingOffset;
; 1275 : 
; 1276 : 					if (pi.PartitionStyle == PARTITION_STYLE_MBR)

  009da	83 bd e4 fc ff
	ff 00		 cmp	 DWORD PTR _pi$30298[ebp], 0
  009e1	8d 96 08 02 00
	00		 lea	 edx, DWORD PTR [esi+520]
  009e7	6a 08		 push	 8
  009e9	59		 pop	 ecx
  009ea	8b fa		 mov	 edi, edx
  009ec	f3 ab		 rep stosd
  009ee	8b 85 f4 fc ff
	ff		 mov	 eax, DWORD PTR _pi$30298[ebp+16]
  009f4	89 86 10 02 00
	00		 mov	 DWORD PTR [esi+528], eax
  009fa	8b 85 f8 fc ff
	ff		 mov	 eax, DWORD PTR _pi$30298[ebp+20]
  00a00	89 86 14 02 00
	00		 mov	 DWORD PTR [esi+532], eax
  00a06	8b 85 fc fc ff
	ff		 mov	 eax, DWORD PTR _pi$30298[ebp+24]
  00a0c	89 86 1c 02 00
	00		 mov	 DWORD PTR [esi+540], eax
  00a12	8b 85 ec fc ff
	ff		 mov	 eax, DWORD PTR _pi$30298[ebp+8]
  00a18	89 02		 mov	 DWORD PTR [edx], eax
  00a1a	8b 85 f0 fc ff
	ff		 mov	 eax, DWORD PTR _pi$30298[ebp+12]
  00a20	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00a23	75 18		 jne	 SHORT $LN61@ProcessMai

; 1277 : 					{
; 1278 : 						info->partInfo.PartitionType = pi.Mbr.PartitionType;

  00a25	8a 85 04 fd ff
	ff		 mov	 al, BYTE PTR _pi$30298[ebp+32]
  00a2b	88 86 20 02 00
	00		 mov	 BYTE PTR [esi+544], al

; 1279 : 						info->partInfo.BootIndicator = pi.Mbr.BootIndicator;

  00a31	8a 85 05 fd ff
	ff		 mov	 al, BYTE PTR _pi$30298[ebp+33]
  00a37	88 86 21 02 00
	00		 mov	 BYTE PTR [esi+545], al
$LN61@ProcessMai:

; 1280 : 					}
; 1281 : 
; 1282 : 					info->IsGPT = pi.PartitionStyle == PARTITION_STYLE_GPT;

  00a3d	33 c0		 xor	 eax, eax
  00a3f	83 bd e4 fc ff
	ff 01		 cmp	 DWORD PTR _pi$30298[ebp], 1
  00a46	0f 94 c0	 sete	 al
  00a49	89 86 28 02 00
	00		 mov	 DWORD PTR [esi+552], eax

; 1283 : 				}
; 1284 : 				else

  00a4f	eb 22		 jmp	 SHORT $LN60@ProcessMai
$LN62@ProcessMai:

; 1285 : 				{
; 1286 : 					// Windows 2000 does not support IOCTL_DISK_GET_PARTITION_INFO_EX
; 1287 : 					ntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0, &info->partInfo, sizeof (info->partInfo));

  00a51	6a 20		 push	 32			; 00000020H
  00a53	8d 86 08 02 00
	00		 lea	 eax, DWORD PTR [esi+520]
  00a59	50		 push	 eax
  00a5a	57		 push	 edi
  00a5b	57		 push	 edi
  00a5c	68 04 40 07 00	 push	 475140			; 00074004H
  00a61	56		 push	 esi
  00a62	e8 00 00 00 00	 call	 _TCDeviceIoControl@24
  00a67	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _ntStatus$30299[ebp], eax

; 1288 : 					info->IsGPT = FALSE;

  00a6d	89 be 28 02 00
	00		 mov	 DWORD PTR [esi+552], edi
$LN60@ProcessMai:

; 1289 : 				}
; 1290 : 
; 1291 : 				if (!NT_SUCCESS (ntStatus))

  00a73	83 bd f8 fd ff
	ff 00		 cmp	 DWORD PTR _ntStatus$30299[ebp], 0
  00a7a	7d 47		 jge	 SHORT $LN260@ProcessMai

; 1292 : 				{
; 1293 : 					GET_LENGTH_INFORMATION lengthInfo;
; 1294 : 					ntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_LENGTH_INFO, NULL, 0, &lengthInfo, sizeof (lengthInfo));

  00a7c	6a 08		 push	 8
  00a7e	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _lengthInfo$30308[ebp]
  00a84	50		 push	 eax
  00a85	6a 00		 push	 0
  00a87	6a 00		 push	 0
  00a89	68 5c 40 07 00	 push	 475228			; 0007405cH
  00a8e	56		 push	 esi
  00a8f	e8 00 00 00 00	 call	 _TCDeviceIoControl@24
  00a94	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _ntStatus$30299[ebp], eax

; 1295 : 
; 1296 : 					if (NT_SUCCESS (ntStatus))

  00a9a	85 c0		 test	 eax, eax
  00a9c	7c 25		 jl	 SHORT $LN260@ProcessMai

; 1297 : 					{
; 1298 : 						memset (&info->partInfo, 0, sizeof (info->partInfo));

  00a9e	6a 08		 push	 8
  00aa0	33 c0		 xor	 eax, eax
  00aa2	59		 pop	 ecx
  00aa3	8d be 08 02 00
	00		 lea	 edi, DWORD PTR [esi+520]
  00aa9	f3 ab		 rep stosd

; 1299 : 						info->partInfo.PartitionLength = lengthInfo.Length;

  00aab	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _lengthInfo$30308[ebp]
  00ab1	89 86 10 02 00
	00		 mov	 DWORD PTR [esi+528], eax
  00ab7	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _lengthInfo$30308[ebp+4]
  00abd	89 86 14 02 00
	00		 mov	 DWORD PTR [esi+532], eax
$LN260@ProcessMai:

; 1300 : 					}
; 1301 : 				}
; 1302 : 
; 1303 : 				info->IsDynamic = FALSE;

  00ac3	33 c0		 xor	 eax, eax

; 1304 : 
; 1305 : 				if (NT_SUCCESS (ntStatus) && OsMajorVersion >= 6)

  00ac5	39 85 f8 fd ff
	ff		 cmp	 DWORD PTR _ntStatus$30299[ebp], eax
  00acb	8d be 2c 02 00
	00		 lea	 edi, DWORD PTR [esi+556]
  00ad1	89 07		 mov	 DWORD PTR [edi], eax
  00ad3	7c 20		 jl	 SHORT $LN265@ProcessMai
  00ad5	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _OsMajorVersion, 6
  00adc	72 17		 jb	 SHORT $LN265@ProcessMai

; 1306 : 				{
; 1307 : #					define IOCTL_VOLUME_IS_DYNAMIC CTL_CODE(IOCTL_VOLUME_BASE, 18, METHOD_BUFFERED, FILE_ANY_ACCESS)
; 1308 : 					if (!NT_SUCCESS (TCDeviceIoControl (info->deviceName, IOCTL_VOLUME_IS_DYNAMIC, NULL, 0, &info->IsDynamic, sizeof (info->IsDynamic))))

  00ade	6a 04		 push	 4
  00ae0	57		 push	 edi
  00ae1	50		 push	 eax
  00ae2	50		 push	 eax
  00ae3	68 48 00 56 00	 push	 5636168			; 00560048H
  00ae8	56		 push	 esi
  00ae9	e8 00 00 00 00	 call	 _TCDeviceIoControl@24
  00aee	85 c0		 test	 eax, eax
  00af0	7d 03		 jge	 SHORT $LN265@ProcessMai

; 1309 : 						info->IsDynamic = FALSE;

  00af2	83 27 00	 and	 DWORD PTR [edi], 0
$LN265@ProcessMai:

; 1310 : 				}
; 1311 : 
; 1312 : 				Irp->IoStatus.Information = sizeof (DISK_PARTITION_INFO_STRUCT);
; 1313 : 				Irp->IoStatus.Status = ntStatus;

  00af5	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR _ntStatus$30299[ebp]
  00afb	c7 43 1c 30 02
	00 00		 mov	 DWORD PTR [ebx+28], 560	; 00000230H

; 1314 : 			}
; 1315 : 		}
; 1316 : 		break;

  00b02	e9 2c fd ff ff	 jmp	 $LN287@ProcessMai
$LN24@ProcessMai:

; 1444 : 
; 1445 : 	case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS:
; 1446 : 		GetBootEncryptionStatus (Irp, irpSp);

  00b07	57		 push	 edi
  00b08	53		 push	 ebx
  00b09	e8 00 00 00 00	 call	 _GetBootEncryptionStatus@8

; 1447 : 		break;

  00b0e	e9 5a 04 00 00	 jmp	 $LN10@ProcessMai
$LN163@ProcessMai:

; 810  : 	NTSTATUS ntStatus;
; 811  : 
; 812  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  00b13	b9 70 20 22 00	 mov	 ecx, 2236528		; 00222070H
  00b18	3b c1		 cmp	 eax, ecx
  00b1a	0f 87 20 03 00
	00		 ja	 $LN167@ProcessMai
  00b20	0f 84 e0 00 00
	00		 je	 $LN115@ProcessMai
  00b26	83 c1 ec	 add	 ecx, -20		; ffffffecH
  00b29	3b c1		 cmp	 eax, ecx
  00b2b	77 59		 ja	 SHORT $LN168@ProcessMai
  00b2d	74 4b		 je	 SHORT $LN20@ProcessMai
  00b2f	2d 4c 20 22 00	 sub	 eax, 2236492		; 0022204cH
  00b34	74 37		 je	 SHORT $LN26@ProcessMai
  00b36	6a 04		 push	 4
  00b38	5e		 pop	 esi
  00b39	2b c6		 sub	 eax, esi
  00b3b	74 26		 je	 SHORT $LN25@ProcessMai
  00b3d	2b c6		 sub	 eax, esi
  00b3f	74 14		 je	 SHORT $LN23@ProcessMai
  00b41	2b c6		 sub	 eax, esi
  00b43	0f 85 6b 03 00
	00		 jne	 $LN1@ProcessMai

; 1453 : 
; 1454 : 	case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:
; 1455 : 		GetBootDriveVolumeProperties (Irp, irpSp);

  00b49	57		 push	 edi
  00b4a	53		 push	 ebx
  00b4b	e8 00 00 00 00	 call	 _GetBootDriveVolumeProperties@8

; 1456 : 		break;

  00b50	e9 18 04 00 00	 jmp	 $LN10@ProcessMai
$LN23@ProcessMai:

; 1448 : 
; 1449 : 	case TC_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT:
; 1450 : 		Irp->IoStatus.Information = 0;

  00b55	83 63 1c 00	 and	 DWORD PTR [ebx+28], 0

; 1451 : 		Irp->IoStatus.Status = GetSetupResult();

  00b59	e8 00 00 00 00	 call	 _GetSetupResult@0

; 1452 : 		break;

  00b5e	e9 d0 fc ff ff	 jmp	 $LN287@ProcessMai
$LN25@ProcessMai:

; 1439 : 
; 1440 : 	case TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP:
; 1441 : 		Irp->IoStatus.Status = AbortBootEncryptionSetup();

  00b63	e8 00 00 00 00	 call	 _AbortBootEncryptionSetup@0

; 1442 : 		Irp->IoStatus.Information = 0;
; 1443 : 		break;

  00b68	e9 9a f9 ff ff	 jmp	 $LN292@ProcessMai
$LN26@ProcessMai:

; 1434 : 
; 1435 : 	case TC_IOCTL_BOOT_ENCRYPTION_SETUP:
; 1436 : 		Irp->IoStatus.Status = StartBootEncryptionSetup (DeviceObject, Irp, irpSp);

  00b6d	57		 push	 edi
  00b6e	53		 push	 ebx
  00b6f	52		 push	 edx
  00b70	e8 00 00 00 00	 call	 _StartBootEncryptionSetup@12

; 1437 : 		Irp->IoStatus.Information = 0;
; 1438 : 		break;

  00b75	e9 8d f9 ff ff	 jmp	 $LN292@ProcessMai
$LN20@ProcessMai:

; 1461 : 
; 1462 : 	case TC_IOCTL_REOPEN_BOOT_VOLUME_HEADER:
; 1463 : 		ReopenBootVolumeHeader (Irp, irpSp);

  00b7a	57		 push	 edi
  00b7b	53		 push	 ebx
  00b7c	e8 00 00 00 00	 call	 _ReopenBootVolumeHeader@8

; 1464 : 		break;

  00b81	e9 e7 03 00 00	 jmp	 $LN10@ProcessMai
$LN168@ProcessMai:

; 810  : 	NTSTATUS ntStatus;
; 811  : 
; 812  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  00b86	2d 60 20 22 00	 sub	 eax, 2236512		; 00222060H
  00b8b	74 6d		 je	 SHORT $LN19@ProcessMai
  00b8d	6a 04		 push	 4
  00b8f	5e		 pop	 esi
  00b90	2b c6		 sub	 eax, esi
  00b92	74 4e		 je	 SHORT $LN88@ProcessMai
  00b94	2b c6		 sub	 eax, esi
  00b96	74 2e		 je	 SHORT $LN91@ProcessMai
  00b98	2b c6		 sub	 eax, esi
  00b9a	0f 85 14 03 00
	00		 jne	 $LN1@ProcessMai

; 1469 : 
; 1470 : 	case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:
; 1471 : 		if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))

  00ba0	6a 01		 push	 1
  00ba2	56		 push	 esi
  00ba3	53		 push	 ebx
  00ba4	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00ba9	85 c0		 test	 eax, eax
  00bab	0f 84 bc 03 00
	00		 je	 $LN10@ProcessMai

; 1472 : 		{
; 1473 : 			*(int *) Irp->AssociatedIrp.SystemBuffer = IsHiddenSystemRunning() ? 1 : 0;

  00bb1	e8 00 00 00 00	 call	 _IsHiddenSystemRunning@0
  00bb6	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00bb9	f7 d8		 neg	 eax
  00bbb	1b c0		 sbb	 eax, eax
  00bbd	f7 d8		 neg	 eax
  00bbf	89 01		 mov	 DWORD PTR [ecx], eax

; 1474 : 			Irp->IoStatus.Information = sizeof (int);
; 1475 : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 1476 : 		}
; 1477 : 		break;

  00bc1	e9 e0 f4 ff ff	 jmp	 $LN285@ProcessMai
$LN91@ProcessMai:

; 1115 : 
; 1116 : 	case TC_IOCTL_SET_PORTABLE_MODE_STATUS:
; 1117 : 		if (!UserCanAccessDriveDevice())

  00bc6	e8 00 00 00 00	 call	 _UserCanAccessDriveDevice@0
  00bcb	85 c0		 test	 eax, eax

; 1118 : 		{
; 1119 : 			Irp->IoStatus.Status = STATUS_ACCESS_DENIED;
; 1120 : 			Irp->IoStatus.Information = 0;
; 1121 : 		}
; 1122 : 		else

  00bcd	0f 84 56 03 00
	00		 je	 $LN8@ProcessMai

; 1123 : 		{
; 1124 : 			PortableMode = TRUE;

  00bd3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _PortableMode, 1

; 1125 : 			Dump ("Setting portable mode\n");
; 1126 : 		}
; 1127 : 		break;

  00bdd	e9 8b 03 00 00	 jmp	 $LN10@ProcessMai
$LN88@ProcessMai:

; 1128 : 
; 1129 : 	case TC_IOCTL_GET_PORTABLE_MODE_STATUS:
; 1130 : 		Irp->IoStatus.Status = PortableMode ? STATUS_SUCCESS : STATUS_PIPE_EMPTY;

  00be2	a1 00 00 00 00	 mov	 eax, DWORD PTR _PortableMode
  00be7	f7 d8		 neg	 eax
  00be9	1b c0		 sbb	 eax, eax
  00beb	25 27 ff ff 3f	 and	 eax, 1073741607		; 3fffff27H
  00bf0	05 d9 00 00 c0	 add	 eax, -1073741607	; c00000d9H

; 1131 : 		Irp->IoStatus.Information = 0;
; 1132 : 		break;

  00bf5	e9 0d f9 ff ff	 jmp	 $LN292@ProcessMai
$LN19@ProcessMai:

; 1465 : 
; 1466 : 	case TC_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME:
; 1467 : 		GetBootEncryptionAlgorithmName (Irp, irpSp);

  00bfa	57		 push	 edi
  00bfb	53		 push	 ebx
  00bfc	e8 00 00 00 00	 call	 _GetBootEncryptionAlgorithmName@8

; 1468 : 		break;

  00c01	e9 67 03 00 00	 jmp	 $LN10@ProcessMai
$LN115@ProcessMai:

; 986  : 
; 987  : 	case TC_IOCTL_GET_SYSTEM_DRIVE_CONFIG:
; 988  : 		{
; 989  : 			GetSystemDriveConfigurationRequest *request = (GetSystemDriveConfigurationRequest *) Irp->AssociatedIrp.SystemBuffer;

  00c06	8b 7b 0c	 mov	 edi, DWORD PTR [ebx+12]

; 990  : 			OBJECT_ATTRIBUTES ObjectAttributes;
; 991  : 			HANDLE NtFileHandle;
; 992  : 			UNICODE_STRING FullFileName;
; 993  : 			IO_STATUS_BLOCK IoStatus;
; 994  : 			LARGE_INTEGER offset;
; 995  : 			byte readBuffer [TC_SECTOR_SIZE_BIOS];
; 996  : 
; 997  : 			if (!ValidateIOBufferSize (Irp, sizeof (GetSystemDriveConfigurationRequest), ValidateInputOutput))

  00c09	6a 02		 push	 2
  00c0b	68 29 02 00 00	 push	 553			; 00000229H
  00c10	53		 push	 ebx
  00c11	89 bd f8 fd ff
	ff		 mov	 DWORD PTR _request$30185[ebp], edi
  00c17	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00c1c	85 c0		 test	 eax, eax
  00c1e	0f 84 49 03 00
	00		 je	 $LN10@ProcessMai

; 998  : 				break;
; 999  : 
; 1000 : 			EnsureNullTerminatedString (request->DevicePath, sizeof (request->DevicePath));

  00c24	33 c0		 xor	 eax, eax
  00c26	66 89 87 06 02
	00 00		 mov	 WORD PTR [edi+518], ax

; 1001 : 			RtlInitUnicodeString (&FullFileName, request->DevicePath);

  00c2d	57		 push	 edi
  00c2e	8d 85 84 fd ff
	ff		 lea	 eax, DWORD PTR _FullFileName$30189[ebp]
  00c34	50		 push	 eax
  00c35	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 1002 : 
; 1003 : 			InitializeObjectAttributes (&ObjectAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

  00c3b	33 f6		 xor	 esi, esi

; 1004 : 
; 1005 : 			ntStatus = ZwCreateFile (&NtFileHandle,
; 1006 : 				SYNCHRONIZE | GENERIC_READ, &ObjectAttributes, &IoStatus, NULL,
; 1007 : 				FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS, NULL, 0);

  00c3d	56		 push	 esi
  00c3e	56		 push	 esi
  00c3f	68 20 08 00 00	 push	 2080			; 00000820H
  00c44	6a 01		 push	 1
  00c46	6a 03		 push	 3
  00c48	68 80 00 00 00	 push	 128			; 00000080H
  00c4d	8d 85 84 fd ff
	ff		 lea	 eax, DWORD PTR _FullFileName$30189[ebp]
  00c53	89 85 9c fd ff
	ff		 mov	 DWORD PTR _ObjectAttributes$30187[ebp+8], eax
  00c59	56		 push	 esi
  00c5a	8d 85 8c fd ff
	ff		 lea	 eax, DWORD PTR _IoStatus$30190[ebp]
  00c60	50		 push	 eax
  00c61	8d 85 94 fd ff
	ff		 lea	 eax, DWORD PTR _ObjectAttributes$30187[ebp]
  00c67	50		 push	 eax
  00c68	68 00 00 10 80	 push	 -2146435072		; 80100000H
  00c6d	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _NtFileHandle$30188[ebp]
  00c73	50		 push	 eax
  00c74	c7 85 94 fd ff
	ff 18 00 00 00	 mov	 DWORD PTR _ObjectAttributes$30187[ebp], 24 ; 00000018H
  00c7e	89 b5 98 fd ff
	ff		 mov	 DWORD PTR _ObjectAttributes$30187[ebp+4], esi
  00c84	c7 85 a0 fd ff
	ff 40 02 00 00	 mov	 DWORD PTR _ObjectAttributes$30187[ebp+12], 576 ; 00000240H
  00c8e	89 b5 a4 fd ff
	ff		 mov	 DWORD PTR _ObjectAttributes$30187[ebp+16], esi
  00c94	89 b5 a8 fd ff
	ff		 mov	 DWORD PTR _ObjectAttributes$30187[ebp+20], esi
  00c9a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwCreateFile@44

; 1008 : 
; 1009 : 			if (NT_SUCCESS (ntStatus))

  00ca0	3b c6		 cmp	 eax, esi
  00ca2	0f 8c e9 fb ff
	ff		 jl	 $LN286@ProcessMai

; 1010 : 			{
; 1011 : 				// Determine if the first sector contains a portion of the TrueCrypt Boot Loader
; 1012 : 				offset.QuadPart = 0;	// MBR
; 1013 : 
; 1014 : 				ntStatus = ZwReadFile (NtFileHandle,
; 1015 : 					NULL,
; 1016 : 					NULL,
; 1017 : 					NULL,
; 1018 : 					&IoStatus,
; 1019 : 					readBuffer,
; 1020 : 					sizeof(readBuffer),
; 1021 : 					&offset,
; 1022 : 					NULL);

  00ca8	56		 push	 esi
  00ca9	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _offset$30191[ebp]
  00caf	50		 push	 eax
  00cb0	68 00 02 00 00	 push	 512			; 00000200H
  00cb5	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _readBuffer$30192[ebp]
  00cbb	50		 push	 eax
  00cbc	8d 85 8c fd ff
	ff		 lea	 eax, DWORD PTR _IoStatus$30190[ebp]
  00cc2	50		 push	 eax
  00cc3	56		 push	 esi
  00cc4	56		 push	 esi
  00cc5	56		 push	 esi
  00cc6	ff b5 f0 fd ff
	ff		 push	 DWORD PTR _NtFileHandle$30188[ebp]
  00ccc	89 b5 cc fd ff
	ff		 mov	 DWORD PTR _offset$30191[ebp], esi
  00cd2	89 b5 d0 fd ff
	ff		 mov	 DWORD PTR _offset$30191[ebp+4], esi
  00cd8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwReadFile@36

; 1023 : 
; 1024 : 				if (NT_SUCCESS (ntStatus))

  00cde	3b c6		 cmp	 eax, esi
  00ce0	0f 8c 43 01 00
	00		 jl	 $LN112@ProcessMai

; 1025 : 				{
; 1026 : 					size_t i;
; 1027 : 
; 1028 : 					// Check for dynamic drive
; 1029 : 					request->DriveIsDynamic = FALSE;

  00ce6	89 b7 09 02 00
	00		 mov	 DWORD PTR [edi+521], esi

; 1030 : 
; 1031 : 					if (readBuffer[510] == 0x55 && readBuffer[511] == 0xaa)

  00cec	80 7d fa 55	 cmp	 BYTE PTR _readBuffer$30192[ebp+510], 85 ; 00000055H
  00cf0	75 27		 jne	 SHORT $LN108@ProcessMai
  00cf2	80 7d fb aa	 cmp	 BYTE PTR _readBuffer$30192[ebp+511], 170 ; 000000aaH
  00cf6	75 21		 jne	 SHORT $LN108@ProcessMai

; 1032 : 					{
; 1033 : 						int i;
; 1034 : 						for (i = 0; i < 4; ++i)

  00cf8	6a 04		 push	 4
  00cfa	33 c9		 xor	 ecx, ecx
  00cfc	8d 45 be	 lea	 eax, DWORD PTR _readBuffer$30192[ebp+450]
  00cff	5e		 pop	 esi
$LL110@ProcessMai:

; 1035 : 						{
; 1036 : 							if (readBuffer[446 + i * 16 + 4] == PARTITION_LDM)

  00d00	80 38 42	 cmp	 BYTE PTR [eax], 66	; 00000042H
  00d03	74 0a		 je	 SHORT $LN210@ProcessMai
  00d05	41		 inc	 ecx
  00d06	83 c0 10	 add	 eax, 16			; 00000010H
  00d09	3b ce		 cmp	 ecx, esi
  00d0b	7c f3		 jl	 SHORT $LL110@ProcessMai

; 1069 : 					{
; 1070 : 						if (memcmp (readBuffer + i, TC_APP_NAME_LEGACY, strlen (TC_APP_NAME_LEGACY)) == 0)

  00d0d	eb 0a		 jmp	 SHORT $LN108@ProcessMai
$LN210@ProcessMai:

; 1037 : 							{
; 1038 : 								request->DriveIsDynamic = TRUE;

  00d0f	c7 87 09 02 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+521], 1
$LN108@ProcessMai:

; 1039 : 								break;
; 1040 : 							}
; 1041 : 						}
; 1042 : 					}
; 1043 : 
; 1044 : 					request->BootLoaderVersion = 0;

  00d19	33 c0		 xor	 eax, eax
  00d1b	66 89 87 0d 02
	00 00		 mov	 WORD PTR [edi+525], ax

; 1045 : 					request->Configuration = 0;

  00d22	88 87 08 02 00
	00		 mov	 BYTE PTR [edi+520], al

; 1046 : 					request->UserConfiguration = 0;

  00d28	88 87 0f 02 00
	00		 mov	 BYTE PTR [edi+527], al

; 1047 : 					request->CustomUserMessage[0] = 0;

  00d2e	8d 87 10 02 00
	00		 lea	 eax, DWORD PTR [edi+528]
  00d34	89 85 ec fd ff
	ff		 mov	 DWORD PTR tv1455[ebp], eax
  00d3a	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1048 : 
; 1049 : 					// Search for the string "CipherShed"
; 1050 : 					for (i = 0; i < sizeof (readBuffer) - strlen (TC_APP_NAME); ++i)

  00d3d	33 c0		 xor	 eax, eax
$LL266@ProcessMai:

; 1051 : 					{
; 1052 : 						if (memcmp (readBuffer + i, TC_APP_NAME, strlen (TC_APP_NAME)) == 0)

  00d3f	6a 05		 push	 5
  00d41	59		 pop	 ecx
  00d42	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_0L@FEEFGEIL@CipherShed?$AA@FNODOBFM@
  00d47	8d b4 05 fc fd
	ff ff		 lea	 esi, DWORD PTR _readBuffer$30192[ebp+eax]
  00d4e	33 d2		 xor	 edx, edx
  00d50	66 f3 a7	 repe cmpsw
  00d53	74 0a		 je	 SHORT $LN211@ProcessMai
  00d55	40		 inc	 eax
  00d56	3d f6 01 00 00	 cmp	 eax, 502		; 000001f6H
  00d5b	72 e2		 jb	 SHORT $LL266@ProcessMai

; 1069 : 					{
; 1070 : 						if (memcmp (readBuffer + i, TC_APP_NAME_LEGACY, strlen (TC_APP_NAME_LEGACY)) == 0)

  00d5d	eb 46		 jmp	 SHORT $LN102@ProcessMai
$LN211@ProcessMai:

; 1053 : 						{
; 1054 : 							request->BootLoaderVersion = BE16 (*(uint16 *) (readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET));

  00d5f	ff 75 aa	 push	 DWORD PTR _readBuffer$30192[ebp+430]
  00d62	e8 00 00 00 00	 call	 _MirrorBytes16@4
  00d67	8b b5 f8 fd ff
	ff		 mov	 esi, DWORD PTR _request$30185[ebp]
  00d6d	66 89 86 0d 02
	00 00		 mov	 WORD PTR [esi+525], ax

; 1055 : 							request->Configuration = readBuffer[TC_BOOT_SECTOR_CONFIG_OFFSET];

  00d74	8a 4d b3	 mov	 cl, BYTE PTR _readBuffer$30192[ebp+439]
  00d77	88 8e 08 02 00
	00		 mov	 BYTE PTR [esi+520], cl

; 1056 : 
; 1057 : 							if (request->BootLoaderVersion != 0 && request->BootLoaderVersion <= VERSION_NUM)

  00d7d	66 85 c0	 test	 ax, ax
  00d80	74 23		 je	 SHORT $LN102@ProcessMai
  00d82	b9 30 07 00 00	 mov	 ecx, 1840		; 00000730H
  00d87	66 3b c1	 cmp	 ax, cx
  00d8a	77 19		 ja	 SHORT $LN102@ProcessMai

; 1058 : 							{
; 1059 : 								request->UserConfiguration = readBuffer[TC_BOOT_SECTOR_USER_CONFIG_OFFSET];

  00d8c	8a 45 b2	 mov	 al, BYTE PTR _readBuffer$30192[ebp+438]

; 1060 : 								memcpy (request->CustomUserMessage, readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET, TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH);

  00d8f	8b bd ec fd ff
	ff		 mov	 edi, DWORD PTR tv1455[ebp]
  00d95	8b ce		 mov	 ecx, esi
  00d97	88 81 0f 02 00
	00		 mov	 BYTE PTR [ecx+527], al
  00d9d	6a 06		 push	 6
  00d9f	59		 pop	 ecx
  00da0	8d 75 92	 lea	 esi, DWORD PTR _readBuffer$30192[ebp+406]
  00da3	f3 a5		 rep movsd
$LN102@ProcessMai:

; 1061 : 							}
; 1062 : 							break;
; 1063 : 						}
; 1064 : 					}
; 1065 : 
; 1066 : 					// Search for the string "TrueCrypt"
; 1067 : 					if (!request->BootLoaderVersion) //CipherShed not found

  00da5	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR _request$30185[ebp]
  00dab	66 83 b8 0d 02
	00 00 00	 cmp	 WORD PTR [eax+525], 0
  00db3	75 67		 jne	 SHORT $LN96@ProcessMai

; 1068 : 					for (i = 0; i < sizeof (readBuffer) - strlen (TC_APP_NAME_LEGACY); ++i)

  00db5	33 c0		 xor	 eax, eax
$LL100@ProcessMai:

; 1069 : 					{
; 1070 : 						if (memcmp (readBuffer + i, TC_APP_NAME_LEGACY, strlen (TC_APP_NAME_LEGACY)) == 0)

  00db7	6a 09		 push	 9
  00db9	59		 pop	 ecx
  00dba	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_09EMKKFGIH@TrueCrypt?$AA@FNODOBFM@
  00dbf	8d b4 05 fc fd
	ff ff		 lea	 esi, DWORD PTR _readBuffer$30192[ebp+eax]
  00dc6	33 d2		 xor	 edx, edx
  00dc8	f3 a6		 repe cmpsb
  00dca	74 0a		 je	 SHORT $LN212@ProcessMai
  00dcc	40		 inc	 eax
  00dcd	3d f7 01 00 00	 cmp	 eax, 503		; 000001f7H
  00dd2	72 e3		 jb	 SHORT $LL100@ProcessMai
  00dd4	eb 46		 jmp	 SHORT $LN96@ProcessMai
$LN212@ProcessMai:

; 1071 : 						{
; 1072 : 							request->BootLoaderVersion = BE16 (*(uint16 *) (readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET));

  00dd6	ff 75 aa	 push	 DWORD PTR _readBuffer$30192[ebp+430]
  00dd9	e8 00 00 00 00	 call	 _MirrorBytes16@4
  00dde	8b b5 f8 fd ff
	ff		 mov	 esi, DWORD PTR _request$30185[ebp]
  00de4	66 89 86 0d 02
	00 00		 mov	 WORD PTR [esi+525], ax

; 1073 : 							request->Configuration = readBuffer[TC_BOOT_SECTOR_CONFIG_OFFSET];

  00deb	8a 4d b3	 mov	 cl, BYTE PTR _readBuffer$30192[ebp+439]
  00dee	88 8e 08 02 00
	00		 mov	 BYTE PTR [esi+520], cl

; 1074 : 
; 1075 : 							if (request->BootLoaderVersion != 0 && request->BootLoaderVersion <= VERSION_NUM)

  00df4	66 85 c0	 test	 ax, ax
  00df7	74 23		 je	 SHORT $LN96@ProcessMai
  00df9	b9 30 07 00 00	 mov	 ecx, 1840		; 00000730H
  00dfe	66 3b c1	 cmp	 ax, cx
  00e01	77 19		 ja	 SHORT $LN96@ProcessMai

; 1076 : 							{
; 1077 : 								request->UserConfiguration = readBuffer[TC_BOOT_SECTOR_USER_CONFIG_OFFSET];

  00e03	8a 45 b2	 mov	 al, BYTE PTR _readBuffer$30192[ebp+438]

; 1078 : 								memcpy (request->CustomUserMessage, readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET, TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH);

  00e06	8b bd ec fd ff
	ff		 mov	 edi, DWORD PTR tv1455[ebp]
  00e0c	8b ce		 mov	 ecx, esi
  00e0e	88 81 0f 02 00
	00		 mov	 BYTE PTR [ecx+527], al
  00e14	6a 06		 push	 6
  00e16	59		 pop	 ecx
  00e17	8d 75 92	 lea	 esi, DWORD PTR _readBuffer$30192[ebp+406]
  00e1a	f3 a5		 rep movsd
$LN96@ProcessMai:

; 1079 : 							}
; 1080 : 							break;
; 1081 : 						}
; 1082 : 					}
; 1083 : 
; 1084 : 					Irp->IoStatus.Status = STATUS_SUCCESS;

  00e1c	83 63 18 00	 and	 DWORD PTR [ebx+24], 0

; 1085 : 					Irp->IoStatus.Information = sizeof (*request);

  00e20	c7 43 1c 29 02
	00 00		 mov	 DWORD PTR [ebx+28], 553	; 00000229H

; 1086 : 				}
; 1087 : 				else

  00e27	eb 06		 jmp	 SHORT $LN95@ProcessMai
$LN112@ProcessMai:

; 1088 : 				{
; 1089 : 					Irp->IoStatus.Status = ntStatus;

  00e29	89 43 18	 mov	 DWORD PTR [ebx+24], eax

; 1090 : 					Irp->IoStatus.Information = 0;

  00e2c	89 73 1c	 mov	 DWORD PTR [ebx+28], esi
$LN95@ProcessMai:

; 1091 : 				}
; 1092 : 
; 1093 : 				ZwClose (NtFileHandle);

  00e2f	ff b5 f0 fd ff
	ff		 push	 DWORD PTR _NtFileHandle$30188[ebp]
  00e35	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 1094 : 
; 1095 : 			}
; 1096 : 			else

  00e3b	e9 2d 01 00 00	 jmp	 $LN10@ProcessMai
$LN167@ProcessMai:

; 810  : 	NTSTATUS ntStatus;
; 811  : 
; 812  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  00e40	b9 88 20 22 00	 mov	 ecx, 2236552		; 00222088H
  00e45	3b c1		 cmp	 eax, ecx
  00e47	77 51		 ja	 SHORT $LN169@ProcessMai
  00e49	74 43		 je	 SHORT $LN12@ProcessMai
  00e4b	2d 78 20 22 00	 sub	 eax, 2236536		; 00222078H
  00e50	74 2f		 je	 SHORT $LN16@ProcessMai
  00e52	6a 04		 push	 4
  00e54	5e		 pop	 esi
  00e55	2b c6		 sub	 eax, esi
  00e57	74 1e		 je	 SHORT $LN15@ProcessMai
  00e59	2b c6		 sub	 eax, esi
  00e5b	74 0e		 je	 SHORT $LN13@ProcessMai
  00e5d	2b c6		 sub	 eax, esi
  00e5f	75 53		 jne	 SHORT $LN1@ProcessMai

; 1488 : 
; 1489 : 	case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT:
; 1490 : 		Irp->IoStatus.Status = GetDecoySystemWipeResult();

  00e61	e8 00 00 00 00	 call	 _GetDecoySystemWipeResult@0

; 1491 : 		Irp->IoStatus.Information = 0;
; 1492 : 		break;

  00e66	e9 9c f6 ff ff	 jmp	 $LN292@ProcessMai
$LN13@ProcessMai:

; 1493 : 
; 1494 : 	case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS:
; 1495 : 		GetDecoySystemWipeStatus (Irp, irpSp);

  00e6b	57		 push	 edi
  00e6c	53		 push	 ebx
  00e6d	e8 00 00 00 00	 call	 _GetDecoySystemWipeStatus@8

; 1496 : 		break;

  00e72	e9 f6 00 00 00	 jmp	 $LN10@ProcessMai
$LN15@ProcessMai:

; 1483 : 
; 1484 : 	case TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE:
; 1485 : 		Irp->IoStatus.Status = AbortDecoySystemWipe();

  00e77	e8 00 00 00 00	 call	 _AbortDecoySystemWipe@0

; 1486 : 		Irp->IoStatus.Information = 0;
; 1487 : 		break;

  00e7c	e9 86 f6 ff ff	 jmp	 $LN292@ProcessMai
$LN16@ProcessMai:

; 1478 : 
; 1479 : 	case TC_IOCTL_START_DECOY_SYSTEM_WIPE:
; 1480 : 		Irp->IoStatus.Status = StartDecoySystemWipe (DeviceObject, Irp, irpSp);

  00e81	57		 push	 edi
  00e82	53		 push	 ebx
  00e83	52		 push	 edx
  00e84	e8 00 00 00 00	 call	 _StartDecoySystemWipe@12

; 1481 : 		Irp->IoStatus.Information = 0;
; 1482 : 		break;

  00e89	e9 79 f6 ff ff	 jmp	 $LN292@ProcessMai
$LN12@ProcessMai:

; 1497 : 
; 1498 : 	case TC_IOCTL_WRITE_BOOT_DRIVE_SECTOR:
; 1499 : 		Irp->IoStatus.Status = WriteBootDriveSector (Irp, irpSp);

  00e8e	57		 push	 edi
  00e8f	53		 push	 ebx
  00e90	e8 00 00 00 00	 call	 _WriteBootDriveSector@8

; 1500 : 		Irp->IoStatus.Information = 0;
; 1501 : 		break;

  00e95	e9 6d f6 ff ff	 jmp	 $LN292@ProcessMai
$LN169@ProcessMai:

; 810  : 	NTSTATUS ntStatus;
; 811  : 
; 812  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  00e9a	2d 8c 20 22 00	 sub	 eax, 2236556		; 0022208cH
  00e9f	0f 84 90 00 00
	00		 je	 $LN11@ProcessMai
  00ea5	6a 04		 push	 4
  00ea7	5e		 pop	 esi
  00ea8	2b c6		 sub	 eax, esi
  00eaa	74 65		 je	 SHORT $LN9@ProcessMai
  00eac	2b c6		 sub	 eax, esi
  00eae	74 55		 je	 SHORT $LN6@ProcessMai
  00eb0	2b c6		 sub	 eax, esi
  00eb2	74 0c		 je	 SHORT $LN5@ProcessMai
$LN1@ProcessMai:

; 1548 : 			{
; 1549 : 				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
; 1550 : 				Irp->IoStatus.Information = 0;
; 1551 : 			}
; 1552 : 		}
; 1553 : 		break;
; 1554 : 
; 1555 : 	default:
; 1556 : 		return TCCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);

  00eb4	6a 00		 push	 0
  00eb6	68 10 00 00 c0	 push	 -1073741808		; c0000010H
  00ebb	e9 b3 00 00 00	 jmp	 $LN284@ProcessMai
$LN5@ProcessMai:

; 1534 : 
; 1535 : 	case TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG:
; 1536 : 		if (ValidateIOBufferSize (Irp, sizeof (GetSystemDriveDumpConfigRequest), ValidateOutput))

  00ec0	6a 01		 push	 1
  00ec2	6a 08		 push	 8
  00ec4	5f		 pop	 edi
  00ec5	57		 push	 edi
  00ec6	53		 push	 ebx
  00ec7	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00ecc	85 c0		 test	 eax, eax
  00ece	0f 84 99 00 00
	00		 je	 $LN10@ProcessMai

; 1537 : 		{
; 1538 : 			GetSystemDriveDumpConfigRequest *request = (GetSystemDriveDumpConfigRequest *) Irp->AssociatedIrp.SystemBuffer;

  00ed4	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]

; 1539 : 
; 1540 : 			request->BootDriveFilterExtension = GetBootDriveFilterExtension();

  00ed7	e8 00 00 00 00	 call	 _GetBootDriveFilterExtension@0
  00edc	89 06		 mov	 DWORD PTR [esi], eax

; 1541 : 			if (IsBootDriveMounted() && request->BootDriveFilterExtension)

  00ede	e8 00 00 00 00	 call	 _IsBootDriveMounted@0
  00ee3	85 c0		 test	 eax, eax
  00ee5	0f 84 83 f2 ff
	ff		 je	 $LN43@ProcessMai
  00eeb	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00eee	0f 84 7a f2 ff
	ff		 je	 $LN43@ProcessMai

; 1542 : 			{
; 1543 : 				request->HwEncryptionEnabled = IsHwEncryptionEnabled();

  00ef4	e8 00 00 00 00	 call	 _IsHwEncryptionEnabled@0
  00ef9	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1544 : 				Irp->IoStatus.Status = STATUS_SUCCESS;

  00efc	83 63 18 00	 and	 DWORD PTR [ebx+24], 0

; 1545 : 				Irp->IoStatus.Information = sizeof (*request);

  00f00	89 7b 1c	 mov	 DWORD PTR [ebx+28], edi

; 1546 : 			}
; 1547 : 			else

  00f03	eb 68		 jmp	 SHORT $LN10@ProcessMai
$LN6@ProcessMai:

; 1529 : 
; 1530 : 	case TC_IOCTL_REREAD_DRIVER_CONFIG:
; 1531 : 		Irp->IoStatus.Status = ReadRegistryConfigFlags (FALSE);

  00f05	6a 00		 push	 0
  00f07	e8 00 00 00 00	 call	 _ReadRegistryConfigFlags@4

; 1532 : 		Irp->IoStatus.Information = 0;
; 1533 : 		break;

  00f0c	e9 f6 f5 ff ff	 jmp	 $LN292@ProcessMai
$LN9@ProcessMai:

; 1515 : 		}
; 1516 : 		break;
; 1517 : 
; 1518 : 	case TC_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY:
; 1519 : 		if (UserCanAccessDriveDevice())

  00f11	e8 00 00 00 00	 call	 _UserCanAccessDriveDevice@0
  00f16	85 c0		 test	 eax, eax
  00f18	74 0f		 je	 SHORT $LN8@ProcessMai

; 1520 : 		{
; 1521 : 			SystemFavoriteVolumeDirty = TRUE;

  00f1a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _SystemFavoriteVolumeDirty, 1

; 1522 : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 1523 : 		}
; 1524 : 		else

  00f24	e9 c3 f5 ff ff	 jmp	 $LN293@ProcessMai
$LN8@ProcessMai:

; 1525 : 			Irp->IoStatus.Status = STATUS_ACCESS_DENIED;

  00f29	c7 43 18 22 00
	00 c0		 mov	 DWORD PTR [ebx+24], -1073741790 ; c0000022H

; 1526 : 
; 1527 : 		Irp->IoStatus.Information = 0;
; 1528 : 		break;

  00f30	e9 bb f5 ff ff	 jmp	 $LN288@ProcessMai
$LN11@ProcessMai:

; 1502 : 
; 1503 : 	case TC_IOCTL_GET_WARNING_FLAGS:
; 1504 : 		if (ValidateIOBufferSize (Irp, sizeof (GetWarningFlagsRequest), ValidateOutput))

  00f35	6a 01		 push	 1
  00f37	6a 08		 push	 8
  00f39	5e		 pop	 esi
  00f3a	56		 push	 esi
  00f3b	53		 push	 ebx
  00f3c	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00f41	85 c0		 test	 eax, eax
  00f43	74 28		 je	 SHORT $LN10@ProcessMai

; 1505 : 		{
; 1506 : 			GetWarningFlagsRequest *flags = (GetWarningFlagsRequest *) Irp->AssociatedIrp.SystemBuffer;
; 1507 : 
; 1508 : 			flags->PagingFileCreationPrevented = PagingFileCreationPrevented;

  00f45	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _PagingFileCreationPrevented
  00f4b	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]

; 1509 : 			PagingFileCreationPrevented = FALSE;
; 1510 : 			flags->SystemFavoriteVolumeDirty = SystemFavoriteVolumeDirty;

  00f4e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SystemFavoriteVolumeDirty
  00f54	89 08		 mov	 DWORD PTR [eax], ecx
  00f56	33 c9		 xor	 ecx, ecx
  00f58	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00f5b	89 0d 00 00 00
	00		 mov	 DWORD PTR _PagingFileCreationPrevented, ecx

; 1511 : 			SystemFavoriteVolumeDirty = FALSE;

  00f61	89 0d 00 00 00
	00		 mov	 DWORD PTR _SystemFavoriteVolumeDirty, ecx

; 1514 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00f67	89 4b 18	 mov	 DWORD PTR [ebx+24], ecx
$LN283@ProcessMai:

; 1512 : 
; 1513 : 			Irp->IoStatus.Information = sizeof (GetWarningFlagsRequest);

  00f6a	89 73 1c	 mov	 DWORD PTR [ebx+28], esi
$LN10@ProcessMai:

; 1557 : 	}
; 1558 : 
; 1559 : 	
; 1560 : #ifdef DEBUG
; 1561 : 	if (!NT_SUCCESS (Irp->IoStatus.Status))
; 1562 : 	{
; 1563 : 		switch (irpSp->Parameters.DeviceIoControl.IoControlCode)
; 1564 : 		{
; 1565 : 		case TC_IOCTL_GET_MOUNTED_VOLUMES:
; 1566 : 		case TC_IOCTL_GET_PASSWORD_CACHE_STATUS:
; 1567 : 		case TC_IOCTL_GET_PORTABLE_MODE_STATUS:
; 1568 : 		case TC_IOCTL_SET_PORTABLE_MODE_STATUS:
; 1569 : 		case TC_IOCTL_OPEN_TEST:
; 1570 : 		case TC_IOCTL_GET_RESOLVED_SYMLINK:
; 1571 : 		case TC_IOCTL_GET_DRIVE_PARTITION_INFO:
; 1572 : 		case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:
; 1573 : 		case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS:
; 1574 : 		case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:
; 1575 : 			break;
; 1576 : 
; 1577 : 		default:
; 1578 : 			Dump ("IOCTL error 0x%08x\n", Irp->IoStatus.Status);
; 1579 : 		}
; 1580 : 	}
; 1581 : #endif
; 1582 : 
; 1583 : 	return TCCompleteIrp (Irp, Irp->IoStatus.Status, Irp->IoStatus.Information);

  00f6d	ff 73 1c	 push	 DWORD PTR [ebx+28]
  00f70	ff 73 18	 push	 DWORD PTR [ebx+24]
$LN284@ProcessMai:
  00f73	53		 push	 ebx
  00f74	e8 00 00 00 00	 call	 _TCCompleteIrp@12

; 1584 : }

  00f79	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00f7c	5f		 pop	 edi
  00f7d	5e		 pop	 esi
  00f7e	33 cd		 xor	 ecx, ebp
  00f80	5b		 pop	 ebx
  00f81	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00f86	c9		 leave
  00f87	c2 0c 00	 ret	 12			; 0000000cH
_ProcessMainDeviceControlIrp@12 ENDP
_TEXT	ENDS
PUBLIC	_TCDispatchQueueIRP@8
EXTRN	_COMPLETE_IRP@16:PROC
EXTRN	_DecoySystemWipeThread:DWORD
EXTRN	_EncryptionSetupThread:DWORD
EXTRN	_EncryptedIoQueueAddIrp@8:PROC
EXTRN	__imp_@ExfInterlockedInsertTailList@12:PROC
EXTRN	_VolumeFilterDispatchIrp@8:PROC
EXTRN	_DriveFilterDispatchIrp@8:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCDispatchQueueIRP@8
_TEXT	SEGMENT
tv306 = -1						; size = 1
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_TCDispatchQueueIRP@8 PROC				; COMDAT

; 202  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 203  : 	PEXTENSION Extension = (PEXTENSION) DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b 70 28	 mov	 esi, DWORD PTR [eax+40]

; 204  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);
; 205  : 	NTSTATUS ntStatus;
; 206  : 
; 207  : #ifdef _DEBUG
; 208  : 	if (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL && (Extension->bRootDevice || Extension->IsVolumeDevice))
; 209  : 	{
; 210  : 		switch (irpSp->Parameters.DeviceIoControl.IoControlCode)
; 211  : 		{
; 212  : 		case TC_IOCTL_GET_MOUNTED_VOLUMES:
; 213  : 		case TC_IOCTL_GET_PASSWORD_CACHE_STATUS:
; 214  : 		case TC_IOCTL_GET_PORTABLE_MODE_STATUS:
; 215  : 		case TC_IOCTL_SET_PORTABLE_MODE_STATUS:
; 216  : 		case TC_IOCTL_OPEN_TEST:
; 217  : 		case TC_IOCTL_GET_RESOLVED_SYMLINK:
; 218  : 		case TC_IOCTL_GET_DEVICE_REFCOUNT:
; 219  : 		case TC_IOCTL_GET_DRIVE_PARTITION_INFO:
; 220  : 		case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:
; 221  : 		case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS:
; 222  : 		case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS:
; 223  : 		case TC_IOCTL_GET_WARNING_FLAGS:
; 224  : 		case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:
; 225  : 		case IOCTL_DISK_CHECK_VERIFY:
; 226  : 			break;
; 227  : 
; 228  : 		default:
; 229  : 			Dump ("%ls (0x%x %d)\n",
; 230  : 				TCTranslateCode (irpSp->Parameters.DeviceIoControl.IoControlCode),
; 231  : 				(int) (irpSp->Parameters.DeviceIoControl.IoControlCode >> 16),
; 232  : 				(int) ((irpSp->Parameters.DeviceIoControl.IoControlCode & 0x1FFF) >> 2));
; 233  : 		}
; 234  : 	}
; 235  : #endif
; 236  : 
; 237  : 	if (!Extension->bRootDevice)

  0000e	8b 16		 mov	 edx, DWORD PTR [esi]
  00010	57		 push	 edi
  00011	8b 7d 0c	 mov	 edi, DWORD PTR _Irp$[ebp]
  00014	8b 4f 60	 mov	 ecx, DWORD PTR [edi+96]
  00017	33 db		 xor	 ebx, ebx
  00019	3b d3		 cmp	 edx, ebx
  0001b	75 22		 jne	 SHORT $LN27@TCDispatch

; 238  : 	{
; 239  : 		// Drive filter IRP
; 240  : 		if (Extension->IsDriveFilterDevice)

  0001d	39 5e 08	 cmp	 DWORD PTR [esi+8], ebx
  00020	74 0c		 je	 SHORT $LN28@TCDispatch

; 241  : 			return DriveFilterDispatchIrp (DeviceObject, Irp);

  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 _DriveFilterDispatchIrp@8
  00029	e9 13 02 00 00	 jmp	 $LN30@TCDispatch
$LN28@TCDispatch:

; 242  : 
; 243  : 		// Volume filter IRP
; 244  : 		if (Extension->IsVolumeFilterDevice)

  0002e	39 5e 0c	 cmp	 DWORD PTR [esi+12], ebx
  00031	74 0c		 je	 SHORT $LN27@TCDispatch

; 245  : 			return VolumeFilterDispatchIrp (DeviceObject, Irp);

  00033	57		 push	 edi
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _VolumeFilterDispatchIrp@8
  0003a	e9 02 02 00 00	 jmp	 $LN30@TCDispatch
$LN27@TCDispatch:

; 246  : 	}
; 247  : 
; 248  : 	switch (irpSp->MajorFunction)

  0003f	8a 01		 mov	 al, BYTE PTR [ecx]
  00041	88 45 ff	 mov	 BYTE PTR tv306[ebp], al
  00044	0f b6 c0	 movzx	 eax, al
  00047	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  0004a	0f 8f 47 01 00
	00		 jg	 $LN32@TCDispatch
  00050	74 25		 je	 SHORT $LN15@TCDispatch
  00052	3b c3		 cmp	 eax, ebx
  00054	0f 84 dc 01 00
	00		 je	 $LN22@TCDispatch
  0005a	83 f8 02	 cmp	 eax, 2
  0005d	0f 84 d3 01 00
	00		 je	 $LN22@TCDispatch
  00063	0f 8e 6a 01 00
	00		 jle	 $LN1@TCDispatch
  00069	83 f8 04	 cmp	 eax, 4
  0006c	7e 09		 jle	 SHORT $LN15@TCDispatch
  0006e	83 f8 09	 cmp	 eax, 9
  00071	0f 85 5c 01 00
	00		 jne	 $LN1@TCDispatch
$LN15@TCDispatch:

; 271  : 
; 272  : 	case IRP_MJ_FLUSH_BUFFERS:
; 273  : 	case IRP_MJ_READ:
; 274  : 	case IRP_MJ_WRITE:
; 275  : 	case IRP_MJ_DEVICE_CONTROL:
; 276  : 
; 277  : 		if (Extension->bRootDevice)

  00077	3b d3		 cmp	 edx, ebx
  00079	74 3f		 je	 SHORT $LN14@TCDispatch

; 278  : 		{
; 279  : 			if (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL)

  0007b	80 7d ff 0e	 cmp	 BYTE PTR tv306[ebp], 14	; 0000000eH
  0007f	0f 85 4e 01 00
	00		 jne	 $LN1@TCDispatch

; 280  : 			{
; 281  : 				NTSTATUS status = KeWaitForMutexObject (&RootDeviceControlMutex, Executive, KernelMode, FALSE, NULL);

  00085	53		 push	 ebx
  00086	53		 push	 ebx
  00087	53		 push	 ebx
  00088	53		 push	 ebx
  00089	bf 00 00 00 00	 mov	 edi, OFFSET _RootDeviceControlMutex
  0008e	57		 push	 edi
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 282  : 				if (!NT_SUCCESS (status))

  00095	3b c3		 cmp	 eax, ebx

; 283  : 					return status;

  00097	0f 8c a4 01 00
	00		 jl	 $LN30@TCDispatch

; 284  : 
; 285  : 				status = ProcessMainDeviceControlIrp (DeviceObject, Extension, Irp);

  0009d	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  000a0	56		 push	 esi
  000a1	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  000a4	e8 00 00 00 00	 call	 _ProcessMainDeviceControlIrp@12

; 286  : 
; 287  : 				KeReleaseMutex (&RootDeviceControlMutex, FALSE);

  000a9	53		 push	 ebx
  000aa	57		 push	 edi
  000ab	8b f0		 mov	 esi, eax
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeReleaseMutex@8
$LN6@TCDispatch:

; 288  : 				return status;

  000b3	8b c6		 mov	 eax, esi
  000b5	e9 87 01 00 00	 jmp	 $LN30@TCDispatch
$LN14@TCDispatch:

; 289  : 			}
; 290  : 			break;
; 291  : 		}
; 292  : 
; 293  : 		if (Extension->bShuttingDown)

  000ba	39 5e 18	 cmp	 DWORD PTR [esi+24], ebx
  000bd	74 11		 je	 SHORT $LN11@TCDispatch

; 294  : 		{
; 295  : 			Dump ("Device %d shutting down: STATUS_DELETE_PENDING\n", Extension->nDosDriveNo);
; 296  : 			return TCCompleteDiskIrp (Irp, STATUS_DELETE_PENDING, 0);

  000bf	53		 push	 ebx
  000c0	68 56 00 00 c0	 push	 -1073741738		; c0000056H
$LN42@TCDispatch:
  000c5	57		 push	 edi
  000c6	e8 00 00 00 00	 call	 _TCCompleteDiskIrp@12
  000cb	e9 71 01 00 00	 jmp	 $LN30@TCDispatch
$LN11@TCDispatch:

; 297  : 		}
; 298  : 
; 299  : 		if (Extension->bRemovable
; 300  : 			&& (DeviceObject->Flags & DO_VERIFY_VOLUME)
; 301  : 			&& !(irpSp->Flags & SL_OVERRIDE_VERIFY_VOLUME)
; 302  : 			&& irpSp->MajorFunction != IRP_MJ_FLUSH_BUFFERS)

  000d0	39 9e 4c 02 00
	00		 cmp	 DWORD PTR [esi+588], ebx
  000d6	74 1d		 je	 SHORT $LN41@TCDispatch
  000d8	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  000db	f6 40 1c 02	 test	 BYTE PTR [eax+28], 2
  000df	74 14		 je	 SHORT $LN41@TCDispatch
  000e1	f6 41 02 02	 test	 BYTE PTR [ecx+2], 2
  000e5	75 0e		 jne	 SHORT $LN41@TCDispatch
  000e7	80 7d ff 09	 cmp	 BYTE PTR tv306[ebp], 9
  000eb	74 08		 je	 SHORT $LN41@TCDispatch

; 303  : 		{
; 304  : 			Dump ("Removable device %d has DO_VERIFY_VOLUME flag: STATUS_DEVICE_NOT_READY\n", Extension->nDosDriveNo);
; 305  : 			return TCCompleteDiskIrp (Irp, STATUS_DEVICE_NOT_READY, 0);

  000ed	53		 push	 ebx
  000ee	68 a3 00 00 c0	 push	 -1073741661		; c00000a3H
  000f3	eb d0		 jmp	 SHORT $LN42@TCDispatch
$LN41@TCDispatch:

; 306  : 		}
; 307  : 
; 308  : 		switch (irpSp->MajorFunction)

  000f5	8a 45 ff	 mov	 al, BYTE PTR tv306[ebp]
  000f8	3c 03		 cmp	 al, 3
  000fa	0f 82 d3 00 00
	00		 jb	 $LN1@TCDispatch
  00100	3c 04		 cmp	 al, 4
  00102	76 6b		 jbe	 SHORT $LN7@TCDispatch
  00104	3c 09		 cmp	 al, 9
  00106	74 60		 je	 SHORT $LN3@TCDispatch
  00108	3c 0e		 cmp	 al, 14			; 0000000eH
  0010a	0f 85 c3 00 00
	00		 jne	 $LN1@TCDispatch

; 318  : 
; 319  : 		case IRP_MJ_DEVICE_CONTROL:
; 320  : 			ntStatus = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00110	6a 18		 push	 24			; 00000018H
  00112	6a 01		 push	 1
  00114	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@FNODOBFM@
  00119	57		 push	 edi
  0011a	8d 86 18 01 00
	00		 lea	 eax, DWORD PTR [esi+280]
  00120	50		 push	 eax
  00121	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAcquireRemoveLockEx@20

; 321  : 			if (!NT_SUCCESS (ntStatus))

  00127	3b c3		 cmp	 eax, ebx
  00129	7d 0d		 jge	 SHORT $LN4@TCDispatch

; 322  : 				return TCCompleteIrp (Irp, ntStatus, 0);

  0012b	53		 push	 ebx
  0012c	50		 push	 eax
$LN43@TCDispatch:
  0012d	57		 push	 edi
  0012e	e8 00 00 00 00	 call	 _TCCompleteIrp@12
  00133	e9 09 01 00 00	 jmp	 $LN30@TCDispatch
$LN4@TCDispatch:

; 323  : 
; 324  : 			IoMarkIrpPending (Irp);

  00138	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  0013b	80 48 03 01	 or	 BYTE PTR [eax+3], 1

; 325  : 			
; 326  : 			ExInterlockedInsertTailList (&Extension->ListEntry, &Irp->Tail.Overlay.ListEntry, &Extension->ListSpinLock);

  0013f	8d 46 34	 lea	 eax, DWORD PTR [esi+52]
  00142	50		 push	 eax
  00143	8d 57 58	 lea	 edx, DWORD PTR [edi+88]
  00146	8d 4e 38	 lea	 ecx, DWORD PTR [esi+56]
  00149	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExfInterlockedInsertTailList@12

; 327  : 			KeReleaseSemaphore (&Extension->RequestSemaphore, IO_DISK_INCREMENT, 1, FALSE);

  0014f	53		 push	 ebx
  00150	6a 01		 push	 1
  00152	6a 01		 push	 1
  00154	83 c6 40	 add	 esi, 64			; 00000040H
  00157	56		 push	 esi
  00158	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeReleaseSemaphore@16

; 328  : 			
; 329  : 			return STATUS_PENDING;

  0015e	b8 03 01 00 00	 mov	 eax, 259		; 00000103H
  00163	e9 d9 00 00 00	 jmp	 $LN30@TCDispatch
$LN3@TCDispatch:

; 330  : 
; 331  : 		case IRP_MJ_FLUSH_BUFFERS:
; 332  : 			return TCCompleteDiskIrp (Irp, STATUS_SUCCESS, 0);

  00168	53		 push	 ebx
  00169	53		 push	 ebx
  0016a	e9 56 ff ff ff	 jmp	 $LN42@TCDispatch
$LN7@TCDispatch:

; 309  : 		{
; 310  : 		case IRP_MJ_READ:
; 311  : 		case IRP_MJ_WRITE:
; 312  : 			ntStatus = EncryptedIoQueueAddIrp (&Extension->Queue, Irp);

  0016f	57		 push	 edi
  00170	81 c6 a8 00 00
	00		 add	 esi, 168		; 000000a8H
  00176	56		 push	 esi
  00177	e8 00 00 00 00	 call	 _EncryptedIoQueueAddIrp@8
  0017c	8b f0		 mov	 esi, eax

; 313  : 
; 314  : 			if (ntStatus != STATUS_PENDING)

  0017e	81 fe 03 01 00
	00		 cmp	 esi, 259		; 00000103H
  00184	0f 84 29 ff ff
	ff		 je	 $LN6@TCDispatch

; 315  : 				TCCompleteDiskIrp (Irp, ntStatus, 0);

  0018a	53		 push	 ebx
  0018b	56		 push	 esi
  0018c	57		 push	 edi
  0018d	e8 00 00 00 00	 call	 _TCCompleteDiskIrp@12

; 316  : 
; 317  : 			return ntStatus;

  00192	e9 1c ff ff ff	 jmp	 $LN6@TCDispatch
$LN32@TCDispatch:

; 246  : 	}
; 247  : 
; 248  : 	switch (irpSp->MajorFunction)

  00197	83 e8 10	 sub	 eax, 16			; 00000010H
  0019a	74 42		 je	 SHORT $LN23@TCDispatch
  0019c	48		 dec	 eax
  0019d	48		 dec	 eax
  0019e	0f 84 92 00 00
	00		 je	 $LN22@TCDispatch
  001a4	83 e8 09	 sub	 eax, 9
  001a7	75 2a		 jne	 SHORT $LN1@TCDispatch

; 333  : 		}
; 334  : 
; 335  : 		break;
; 336  : 
; 337  : 	case IRP_MJ_PNP:
; 338  : 		if (!Extension->bRootDevice
; 339  : 			&& Extension->IsVolumeDevice
; 340  : 			&& irpSp->MinorFunction == IRP_MN_DEVICE_USAGE_NOTIFICATION
; 341  : 			&& irpSp->Parameters.UsageNotification.Type == DeviceUsageTypePaging
; 342  : 			&& irpSp->Parameters.UsageNotification.InPath)

  001a9	3b d3		 cmp	 edx, ebx
  001ab	75 26		 jne	 SHORT $LN1@TCDispatch
  001ad	39 5e 04	 cmp	 DWORD PTR [esi+4], ebx
  001b0	74 21		 je	 SHORT $LN1@TCDispatch
  001b2	80 79 01 16	 cmp	 BYTE PTR [ecx+1], 22	; 00000016H
  001b6	75 1b		 jne	 SHORT $LN1@TCDispatch
  001b8	40		 inc	 eax
  001b9	39 41 08	 cmp	 DWORD PTR [ecx+8], eax
  001bc	75 15		 jne	 SHORT $LN1@TCDispatch
  001be	38 59 04	 cmp	 BYTE PTR [ecx+4], bl
  001c1	74 10		 je	 SHORT $LN1@TCDispatch

; 343  : 		{
; 344  : 			PagingFileCreationPrevented = TRUE;
; 345  : 			return TCCompleteIrp (Irp, STATUS_UNSUCCESSFUL, 0);

  001c3	53		 push	 ebx
  001c4	a3 00 00 00 00	 mov	 DWORD PTR _PagingFileCreationPrevented, eax
  001c9	68 01 00 00 c0	 push	 -1073741823		; c0000001H
  001ce	e9 5a ff ff ff	 jmp	 $LN43@TCDispatch
$LN1@TCDispatch:

; 346  : 		}
; 347  : 		break;
; 348  : 	}
; 349  : 
; 350  : 	return TCCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);

  001d3	53		 push	 ebx
  001d4	68 10 00 00 c0	 push	 -1073741808		; c0000010H
  001d9	e9 4f ff ff ff	 jmp	 $LN43@TCDispatch
$LN23@TCDispatch:

; 249  : 	{
; 250  : 	case IRP_MJ_CLOSE:
; 251  : 	case IRP_MJ_CREATE:
; 252  : 	case IRP_MJ_CLEANUP:
; 253  : 		return COMPLETE_IRP (DeviceObject, Irp, STATUS_SUCCESS, 0);
; 254  : 
; 255  : 	case IRP_MJ_SHUTDOWN:
; 256  : 		if (Extension->bRootDevice)

  001de	3b d3		 cmp	 edx, ebx
  001e0	74 54		 je	 SHORT $LN22@TCDispatch

; 257  : 		{
; 258  : 			Dump ("Driver shutting down\n");
; 259  : 			DriverShuttingDown = TRUE;

  001e2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _DriverShuttingDown, 1

; 260  : 
; 261  : 			if (EncryptionSetupThread)

  001ec	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH
  001f1	39 1d 00 00 00
	00		 cmp	 DWORD PTR _EncryptionSetupThread, ebx
  001f7	74 18		 je	 SHORT $LN19@TCDispatch
$LL20@TCDispatch:

; 262  : 				while (SendDeviceIoControlRequest (RootDeviceObject, TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP, NULL, 0, NULL, 0) == STATUS_INSUFFICIENT_RESOURCES);

  001f9	53		 push	 ebx
  001fa	53		 push	 ebx
  001fb	53		 push	 ebx
  001fc	53		 push	 ebx
  001fd	68 50 20 22 00	 push	 2236496			; 00222050H
  00202	ff 35 00 00 00
	00		 push	 DWORD PTR _RootDeviceObject
  00208	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  0020d	3b c6		 cmp	 eax, esi
  0020f	74 e8		 je	 SHORT $LL20@TCDispatch
$LN19@TCDispatch:

; 263  : 
; 264  : 			if (DecoySystemWipeThread)

  00211	39 1d 00 00 00
	00		 cmp	 DWORD PTR _DecoySystemWipeThread, ebx
  00217	74 18		 je	 SHORT $LN16@TCDispatch
$LL17@TCDispatch:

; 265  : 				while (SendDeviceIoControlRequest (RootDeviceObject, TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE, NULL, 0, NULL, 0) == STATUS_INSUFFICIENT_RESOURCES);

  00219	53		 push	 ebx
  0021a	53		 push	 ebx
  0021b	53		 push	 ebx
  0021c	53		 push	 ebx
  0021d	68 7c 20 22 00	 push	 2236540			; 0022207cH
  00222	ff 35 00 00 00
	00		 push	 DWORD PTR _RootDeviceObject
  00228	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  0022d	3b c6		 cmp	 eax, esi
  0022f	74 e8		 je	 SHORT $LL17@TCDispatch
$LN16@TCDispatch:

; 266  : 
; 267  : 			OnShutdownPending();

  00231	e8 00 00 00 00	 call	 _OnShutdownPending@0
$LN22@TCDispatch:

; 268  : 		}
; 269  : 
; 270  : 		return COMPLETE_IRP (DeviceObject, Irp, STATUS_SUCCESS, 0);

  00236	53		 push	 ebx
  00237	53		 push	 ebx
  00238	57		 push	 edi
  00239	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  0023c	e8 00 00 00 00	 call	 _COMPLETE_IRP@16
$LN30@TCDispatch:
  00241	5f		 pop	 edi
  00242	5e		 pop	 esi
  00243	5b		 pop	 ebx

; 351  : }

  00244	c9		 leave
  00245	c2 08 00	 ret	 8
_TCDispatchQueueIRP@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1M@IOJLKPKK@?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	_DriverEntry@8
EXTRN	_LoadBootArguments@0:PROC
EXTRN	_AutoTestAlgorithms@0:PROC
EXTRN	_EncryptionThreadPoolStart@4:PROC
EXTRN	_DumpFilterEntry@8:PROC
EXTRN	__imp__PsGetVersion@16:PROC
;	COMDAT ??_C@_1M@IOJLKPKK@?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_1M@IOJLKPKK@?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@PBOPGDP@ DB 'S', 00H, 't'
	DB	00H, 'a', 00H, 'r', 00H, 't', 00H, 00H, 00H	;  ?? ::PBOPGDP::`string'
; Function compile flags: /Ogsp
INIT$s	ENDS
;	COMDAT _DriverEntry@8
INIT	SEGMENT
_version$ = -4						; size = 4
_startKeyValue$ = 8					; size = 4
_DriverObject$ = 8					; size = 4
_RegistryPath$ = 12					; size = 4
_DriverEntry@8 PROC					; COMDAT

; 63   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	57		 push	 edi

; 64   : 	PKEY_VALUE_PARTIAL_INFORMATION startKeyValue;
; 65   : 	LONG version;
; 66   : 	int i;
; 67   : 
; 68   : 	Dump ("DriverEntry " TC_APP_NAME " " VERSION_STRING "\n");
; 69   : 
; 70   : 	PsGetVersion (&OsMajorVersion, &OsMinorVersion, NULL, NULL);

  00007	33 ff		 xor	 edi, edi
  00009	57		 push	 edi
  0000a	57		 push	 edi
  0000b	68 00 00 00 00	 push	 OFFSET _OsMinorVersion
  00010	68 00 00 00 00	 push	 OFFSET _OsMajorVersion
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsGetVersion@16

; 71   : 
; 72   : 	// Load dump filter if the main driver is already loaded
; 73   : 	if (NT_SUCCESS (TCDeviceIoControl (NT_ROOT_PREFIX, TC_IOCTL_GET_DRIVER_VERSION, NULL, 0, &version, sizeof (version))))

  0001b	6a 04		 push	 4
  0001d	8d 45 fc	 lea	 eax, DWORD PTR _version$[ebp]
  00020	50		 push	 eax
  00021	57		 push	 edi
  00022	57		 push	 edi
  00023	68 04 20 22 00	 push	 2236420			; 00222004H
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@
  0002d	e8 00 00 00 00	 call	 _TCDeviceIoControl@24
  00032	85 c0		 test	 eax, eax
  00034	7c 10		 jl	 SHORT $LN7@DriverEntr

; 74   : 		return DumpFilterEntry ((PFILTER_EXTENSION) DriverObject, (PFILTER_INITIALIZATION_DATA) RegistryPath);

  00036	ff 75 0c	 push	 DWORD PTR _RegistryPath$[ebp]
  00039	ff 75 08	 push	 DWORD PTR _DriverObject$[ebp]
  0003c	e8 00 00 00 00	 call	 _DumpFilterEntry@8
  00041	e9 b8 00 00 00	 jmp	 $LN8@DriverEntr
$LN7@DriverEntr:
  00046	56		 push	 esi

; 75   : 
; 76   : 	TCDriverObject = DriverObject;

  00047	8b 75 08	 mov	 esi, DWORD PTR _DriverObject$[ebp]

; 77   : 	memset (VirtualVolumeDeviceObjects, 0, sizeof (VirtualVolumeDeviceObjects));

  0004a	6a 68		 push	 104			; 00000068H
  0004c	57		 push	 edi
  0004d	68 00 00 00 00	 push	 OFFSET _VirtualVolumeDeviceObjects
  00052	89 35 00 00 00
	00		 mov	 DWORD PTR _TCDriverObject, esi
  00058	e8 00 00 00 00	 call	 _memset
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 78   : 
; 79   : 	ReadRegistryConfigFlags (TRUE);

  00060	6a 01		 push	 1
  00062	e8 00 00 00 00	 call	 _ReadRegistryConfigFlags@4

; 80   : 	EncryptionThreadPoolStart (EncryptionThreadPoolFreeCpuCountLimit);

  00067	ff 35 00 00 00
	00		 push	 DWORD PTR _EncryptionThreadPoolFreeCpuCountLimit
  0006d	e8 00 00 00 00	 call	 _EncryptionThreadPoolStart@4

; 81   : 	SelfTestsPassed = AutoTestAlgorithms();

  00072	e8 00 00 00 00	 call	 _AutoTestAlgorithms@0
  00077	a3 00 00 00 00	 mov	 DWORD PTR _SelfTestsPassed, eax

; 82   : 
; 83   : 	// Enable device class filters and load boot arguments if the driver is set to start at system boot
; 84   : 		
; 85   : 	if (NT_SUCCESS (TCReadRegistryKey (RegistryPath, L"Start", &startKeyValue)))

  0007c	8d 45 08	 lea	 eax, DWORD PTR _startKeyValue$[ebp]
  0007f	50		 push	 eax
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_1M@IOJLKPKK@?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@PBOPGDP@
  00085	ff 75 0c	 push	 DWORD PTR _RegistryPath$[ebp]
  00088	e8 00 00 00 00	 call	 _TCReadRegistryKey@12
  0008d	85 c0		 test	 eax, eax
  0008f	7c 52		 jl	 SHORT $LN6@DriverEntr
  00091	53		 push	 ebx

; 86   : 	{
; 87   : 		if (startKeyValue->Type == REG_DWORD && *((uint32 *) startKeyValue->Data) == SERVICE_BOOT_START)

  00092	8b 5d 08	 mov	 ebx, DWORD PTR _startKeyValue$[ebp]
  00095	83 7b 04 04	 cmp	 DWORD PTR [ebx+4], 4
  00099	75 3b		 jne	 SHORT $LN5@DriverEntr
  0009b	39 7b 0c	 cmp	 DWORD PTR [ebx+12], edi
  0009e	75 36		 jne	 SHORT $LN5@DriverEntr

; 88   : 		{
; 89   : 			if (!SelfTestsPassed)

  000a0	39 3d 00 00 00
	00		 cmp	 DWORD PTR _SelfTestsPassed, edi
  000a6	75 15		 jne	 SHORT $LN4@DriverEntr

; 90   : 				TC_BUG_CHECK (STATUS_INVALID_PARAMETER);

  000a8	68 43 54 00 00	 push	 21571			; 00005443H
  000ad	57		 push	 edi
  000ae	68 0d 00 00 c0	 push	 -1073741811		; c000000dH
  000b3	6a 5a		 push	 90			; 0000005aH
  000b5	6a 29		 push	 41			; 00000029H
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN13@DriverEntr:
$LN4@DriverEntr:

; 91   : 
; 92   : 			LoadBootArguments();

  000bd	e8 00 00 00 00	 call	 _LoadBootArguments@0

; 93   : 			VolumeClassFilterRegistered = IsVolumeClassFilterRegistered();

  000c2	e8 00 00 00 00	 call	 _IsVolumeClassFilterRegistered@0
  000c7	a3 00 00 00 00	 mov	 DWORD PTR _VolumeClassFilterRegistered, eax

; 94   : 
; 95   : 			DriverObject->DriverExtension->AddDevice = DriverAddDevice;

  000cc	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  000cf	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET _DriverAddDevice@8
$LN5@DriverEntr:

; 96   : 		}
; 97   : 
; 98   : 		TCfree (startKeyValue);

  000d6	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  000db	53		 push	 ebx
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
  000e2	5b		 pop	 ebx
$LN6@DriverEntr:

; 99   : 	}
; 100  : 
; 101  : 	for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; ++i)
; 102  : 	{
; 103  : 		DriverObject->MajorFunction[i] = TCDispatchQueueIRP;

  000e3	6a 1c		 push	 28			; 0000001cH
  000e5	59		 pop	 ecx
  000e6	b8 00 00 00 00	 mov	 eax, OFFSET _TCDispatchQueueIRP@8
  000eb	8d 7e 38	 lea	 edi, DWORD PTR [esi+56]
  000ee	f3 ab		 rep stosd

; 104  : 	}
; 105  : 
; 106  : 	DriverObject->DriverUnload = TCUnloadDriver;
; 107  : 	return TCCreateRootDeviceObject (DriverObject);

  000f0	56		 push	 esi
  000f1	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], OFFSET _TCUnloadDriver@4
  000f8	e8 00 00 00 00	 call	 _TCCreateRootDeviceObject@4
  000fd	5e		 pop	 esi
$LN8@DriverEntr:
  000fe	5f		 pop	 edi

; 108  : }

  000ff	c9		 leave
  00100	c2 08 00	 ret	 8
$LN12@DriverEntr:
_DriverEntry@8 ENDP
INIT	ENDS
END
