; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\users\public\desktop\projects\ciphershed\src\driver\ntdriver.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_RootDeviceObject
PUBLIC	_DriverShuttingDown
PUBLIC	_OsMajorVersion
PUBLIC	_DriverUnloadDisabled
PUBLIC	_PortableMode
PUBLIC	_VolumeClassFilterRegistered
PUBLIC	_CacheBootPassword
PUBLIC	_NonAdminSystemFavoritesAccessDisabled
_DATA	SEGMENT
COMM	_VirtualVolumeDeviceObjects:DWORD:01aH
COMM	_TCDriverObject:DWORD
COMM	_LastUniqueVolumeId:DWORD
COMM	_OsMinorVersion:DWORD
COMM	_SelfTestsPassed:DWORD
_DATA	ENDS
_BSS	SEGMENT
_RootDeviceObject DD 01H DUP (?)
_DriverShuttingDown DD 01H DUP (?)
_OsMajorVersion DD 01H DUP (?)
_DriverUnloadDisabled DD 01H DUP (?)
_PortableMode DD 01H DUP (?)
_VolumeClassFilterRegistered DD 01H DUP (?)
_CacheBootPassword DD 01H DUP (?)
_NonAdminSystemFavoritesAccessDisabled DD 01H DUP (?)
_EncryptionThreadPoolFreeCpuCountLimit DD 01H DUP (?)
_SystemFavoriteVolumeDirty DD 01H DUP (?)
_PagingFileCreationPrevented DD 01H DUP (?)
_BSS	ENDS
PUBLIC	_TCCreateRootDeviceObject@4
PUBLIC	_TCUnloadDriver@4
PUBLIC	_TCDispatchQueueIRP@8
PUBLIC	_DriverAddDevice@8
PUBLIC	_IsVolumeClassFilterRegistered@0
PUBLIC	_TCReadRegistryKey@12
PUBLIC	??_C@_1M@IOJLKPKK@?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	_ReadRegistryConfigFlags@4
PUBLIC	_TCDeviceIoControl@24
PUBLIC	??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0BO@OAMALJLL@DriverEntry?5CipherShed?50?47?43?6?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	_DriverEntry@8
EXTRN	__imp__ExFreePoolWithTag@8:PROC
EXTRN	_LoadBootArguments@0:PROC
EXTRN	__imp__KeBugCheckEx@20:PROC
EXTRN	_AutoTestAlgorithms@0:PROC
EXTRN	_EncryptionThreadPoolStart@4:PROC
EXTRN	_DumpFilterEntry@8:PROC
EXTRN	__imp__PsGetVersion@16:PROC
EXTRN	_DbgPrint:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_1M@IOJLKPKK@?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@PBOPGDP@
; File c:\users\public\desktop\projects\ciphershed\src\driver\ntdriver.c
INIT$s	SEGMENT
??_C@_1M@IOJLKPKK@?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@PBOPGDP@ DB 'S', 00H, 't'
	DB	00H, 'a', 00H, 'r', 00H, 't', 00H, 00H, 00H	;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'T', 00H, 'r', 00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r'
	DB	00H, 'y', 00H, 'p', 00H, 't', 00H, 00H, 00H	;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0BO@OAMALJLL@DriverEntry?5CipherShed?50?47?43?6?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_0BO@OAMALJLL@DriverEntry?5CipherShed?50?47?43?6?$AA@PBOPGDP@ DB 'Dr'
	DB	'iverEntry CipherShed 0.7.3', 0aH, 00H	;  ?? ::PBOPGDP::`string'
; Function compile flags: /Odtp
INIT$s	ENDS
;	COMDAT _DriverEntry@8
INIT	SEGMENT
_version$ = -12						; size = 4
_startKeyValue$ = -8					; size = 4
_i$ = -4						; size = 4
_DriverObject$ = 8					; size = 4
_RegistryPath$ = 12					; size = 4
_DriverEntry@8 PROC					; COMDAT

; 63   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 64   : 	PKEY_VALUE_PARTIAL_INFORMATION startKeyValue;
; 65   : 	LONG version;
; 66   : 	int i;
; 67   : 
; 68   : 	Dump ("DriverEntry " TC_APP_NAME " " VERSION_STRING "\n");

  00008	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@OAMALJLL@DriverEntry?5CipherShed?50?47?43?6?$AA@PBOPGDP@
  0000d	e8 00 00 00 00	 call	 _DbgPrint
  00012	83 c4 04	 add	 esp, 4

; 69   : 
; 70   : 	PsGetVersion (&OsMajorVersion, &OsMinorVersion, NULL, NULL);

  00015	6a 00		 push	 0
  00017	6a 00		 push	 0
  00019	68 00 00 00 00	 push	 OFFSET _OsMinorVersion
  0001e	68 00 00 00 00	 push	 OFFSET _OsMajorVersion
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsGetVersion@16

; 71   : 
; 72   : 	// Load dump filter if the main driver is already loaded
; 73   : 	if (NT_SUCCESS (TCDeviceIoControl (NT_ROOT_PREFIX, TC_IOCTL_GET_DRIVER_VERSION, NULL, 0, &version, sizeof (version))))

  00029	6a 04		 push	 4
  0002b	8d 45 f4	 lea	 eax, DWORD PTR _version$[ebp]
  0002e	50		 push	 eax
  0002f	6a 00		 push	 0
  00031	6a 00		 push	 0
  00033	68 04 20 22 00	 push	 2236420			; 00222004H
  00038	68 00 00 00 00	 push	 OFFSET ??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@
  0003d	e8 00 00 00 00	 call	 _TCDeviceIoControl@24
  00042	85 c0		 test	 eax, eax
  00044	7c 12		 jl	 SHORT $LN7@DriverEntr

; 74   : 		return DumpFilterEntry ((PFILTER_EXTENSION) DriverObject, (PFILTER_INITIALIZATION_DATA) RegistryPath);

  00046	8b 4d 0c	 mov	 ecx, DWORD PTR _RegistryPath$[ebp]
  00049	51		 push	 ecx
  0004a	8b 55 08	 mov	 edx, DWORD PTR _DriverObject$[ebp]
  0004d	52		 push	 edx
  0004e	e8 00 00 00 00	 call	 _DumpFilterEntry@8
  00053	e9 e3 00 00 00	 jmp	 $LN9@DriverEntr
$LN7@DriverEntr:

; 75   : 
; 76   : 	TCDriverObject = DriverObject;

  00058	8b 45 08	 mov	 eax, DWORD PTR _DriverObject$[ebp]
  0005b	a3 00 00 00 00	 mov	 DWORD PTR _TCDriverObject, eax

; 77   : 	memset (VirtualVolumeDeviceObjects, 0, sizeof (VirtualVolumeDeviceObjects));

  00060	6a 68		 push	 104			; 00000068H
  00062	6a 00		 push	 0
  00064	68 00 00 00 00	 push	 OFFSET _VirtualVolumeDeviceObjects
  00069	e8 00 00 00 00	 call	 _memset
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 78   : 
; 79   : 	ReadRegistryConfigFlags (TRUE);

  00071	6a 01		 push	 1
  00073	e8 00 00 00 00	 call	 _ReadRegistryConfigFlags@4

; 80   : 	EncryptionThreadPoolStart (EncryptionThreadPoolFreeCpuCountLimit);

  00078	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _EncryptionThreadPoolFreeCpuCountLimit
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 _EncryptionThreadPoolStart@4

; 81   : 	SelfTestsPassed = AutoTestAlgorithms();

  00084	e8 00 00 00 00	 call	 _AutoTestAlgorithms@0
  00089	a3 00 00 00 00	 mov	 DWORD PTR _SelfTestsPassed, eax

; 82   : 
; 83   : 	// Enable device class filters and load boot arguments if the driver is set to start at system boot
; 84   : 		
; 85   : 	if (NT_SUCCESS (TCReadRegistryKey (RegistryPath, L"Start", &startKeyValue)))

  0008e	8d 55 f8	 lea	 edx, DWORD PTR _startKeyValue$[ebp]
  00091	52		 push	 edx
  00092	68 00 00 00 00	 push	 OFFSET ??_C@_1M@IOJLKPKK@?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@PBOPGDP@
  00097	8b 45 0c	 mov	 eax, DWORD PTR _RegistryPath$[ebp]
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 _TCReadRegistryKey@12
  000a0	85 c0		 test	 eax, eax
  000a2	7c 5c		 jl	 SHORT $LN6@DriverEntr

; 86   : 	{
; 87   : 		if (startKeyValue->Type == REG_DWORD && *((uint32 *) startKeyValue->Data) == SERVICE_BOOT_START)

  000a4	8b 4d f8	 mov	 ecx, DWORD PTR _startKeyValue$[ebp]
  000a7	83 79 04 04	 cmp	 DWORD PTR [ecx+4], 4
  000ab	75 44		 jne	 SHORT $LN5@DriverEntr
  000ad	8b 55 f8	 mov	 edx, DWORD PTR _startKeyValue$[ebp]
  000b0	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  000b4	75 3b		 jne	 SHORT $LN5@DriverEntr

; 88   : 		{
; 89   : 			if (!SelfTestsPassed)

  000b6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SelfTestsPassed, 0
  000bd	75 16		 jne	 SHORT $LN4@DriverEntr

; 90   : 				TC_BUG_CHECK (STATUS_INVALID_PARAMETER);

  000bf	68 43 54 00 00	 push	 21571			; 00005443H
  000c4	6a 00		 push	 0
  000c6	68 0d 00 00 c0	 push	 -1073741811		; c000000dH
  000cb	6a 5a		 push	 90			; 0000005aH
  000cd	6a 29		 push	 41			; 00000029H
  000cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN4@DriverEntr:

; 91   : 
; 92   : 			LoadBootArguments();

  000d5	e8 00 00 00 00	 call	 _LoadBootArguments@0

; 93   : 			VolumeClassFilterRegistered = IsVolumeClassFilterRegistered();

  000da	e8 00 00 00 00	 call	 _IsVolumeClassFilterRegistered@0
  000df	a3 00 00 00 00	 mov	 DWORD PTR _VolumeClassFilterRegistered, eax

; 94   : 
; 95   : 			DriverObject->DriverExtension->AddDevice = DriverAddDevice;

  000e4	8b 45 08	 mov	 eax, DWORD PTR _DriverObject$[ebp]
  000e7	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000ea	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET _DriverAddDevice@8
$LN5@DriverEntr:

; 96   : 		}
; 97   : 
; 98   : 		TCfree (startKeyValue);

  000f1	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  000f6	8b 55 f8	 mov	 edx, DWORD PTR _startKeyValue$[ebp]
  000f9	52		 push	 edx
  000fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN6@DriverEntr:

; 99   : 	}
; 100  : 
; 101  : 	for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; ++i)

  00100	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00107	eb 09		 jmp	 SHORT $LN3@DriverEntr
$LN2@DriverEntr:
  00109	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0010c	83 c0 01	 add	 eax, 1
  0010f	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN3@DriverEntr:
  00112	83 7d fc 1b	 cmp	 DWORD PTR _i$[ebp], 27	; 0000001bH
  00116	7f 10		 jg	 SHORT $LN1@DriverEntr

; 102  : 	{
; 103  : 		DriverObject->MajorFunction[i] = TCDispatchQueueIRP;

  00118	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0011b	8b 55 08	 mov	 edx, DWORD PTR _DriverObject$[ebp]
  0011e	c7 44 8a 38 00
	00 00 00	 mov	 DWORD PTR [edx+ecx*4+56], OFFSET _TCDispatchQueueIRP@8

; 104  : 	}

  00126	eb e1		 jmp	 SHORT $LN2@DriverEntr
$LN1@DriverEntr:

; 105  : 
; 106  : 	DriverObject->DriverUnload = TCUnloadDriver;

  00128	8b 45 08	 mov	 eax, DWORD PTR _DriverObject$[ebp]
  0012b	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], OFFSET _TCUnloadDriver@4

; 107  : 	return TCCreateRootDeviceObject (DriverObject);

  00132	8b 4d 08	 mov	 ecx, DWORD PTR _DriverObject$[ebp]
  00135	51		 push	 ecx
  00136	e8 00 00 00 00	 call	 _TCCreateRootDeviceObject@4
$LN9@DriverEntr:

; 108  : }

  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c2 08 00	 ret	 8
_DriverEntry@8 ENDP
INIT	ENDS
PUBLIC	??_C@_0BN@PIELMKDH@Volume?5pdo?$DN?$CFp?5interface?$DN?$CFws?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CD@FCIMJPEM@AddDevice?5pdo?$DN?$CFp?5type?$DN?$CFx?5name?$DN?$CFw@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_13HGPDMIBE@?$AA?$DP?$AA?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	__$ArrayPad$
EXTRN	_DriveFilterAddDevice@8:PROC
EXTRN	_VolumeFilterAddDevice@8:PROC
EXTRN	__imp__IoGetDeviceInterfaces@16:PROC
EXTRN	_GUID_DEVINTERFACE_VOLUME:BYTE
EXTRN	_BootArgs:BYTE
EXTRN	_BootArgsValid:DWORD
EXTRN	__imp__ObQueryNameString@16:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0BN@PIELMKDH@Volume?5pdo?$DN?$CFp?5interface?$DN?$CFws?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BN@PIELMKDH@Volume?5pdo?$DN?$CFp?5interface?$DN?$CFws?6?$AA@FNODOBFM@ DB 'V'
	DB	'olume pdo=%p interface=%ws', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CD@FCIMJPEM@AddDevice?5pdo?$DN?$CFp?5type?$DN?$CFx?5name?$DN?$CFw@FNODOBFM@
text$s	SEGMENT
??_C@_0CD@FCIMJPEM@AddDevice?5pdo?$DN?$CFp?5type?$DN?$CFx?5name?$DN?$CFw@FNODOBFM@ DB 'A'
	DB	'ddDevice pdo=%p type=%x name=%ws', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_13HGPDMIBE@?$AA?$DP?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_13HGPDMIBE@?$AA?$DP?$AA?$AA@FNODOBFM@ DB '?', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _DriverAddDevice@8
_TEXT	SEGMENT
tv72 = -152						; size = 4
_interfaceLinks$29779 = -148				; size = 4
_nameInfo$ = -144					; size = 4
_nameInfoSize$ = -140					; size = 4
_nameInfoBuffer$ = -136					; size = 128
__$ArrayPad$ = -4					; size = 4
_driverObject$ = 8					; size = 4
_pdo$ = 12						; size = 4
_DriverAddDevice@8 PROC					; COMDAT

; 112  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 113  : #ifdef DEBUG
; 114  : 	char nameInfoBuffer[128];
; 115  : 	POBJECT_NAME_INFORMATION nameInfo = (POBJECT_NAME_INFORMATION) nameInfoBuffer;

  00015	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _nameInfoBuffer$[ebp]
  0001b	89 85 70 ff ff
	ff		 mov	 DWORD PTR _nameInfo$[ebp], eax

; 116  : 	ULONG nameInfoSize;
; 117  : 	Dump ("AddDevice pdo=%p type=%x name=%ws\n", pdo, pdo->DeviceType, NT_SUCCESS (ObQueryNameString (pdo, nameInfo, sizeof (nameInfoBuffer), &nameInfoSize)) ? nameInfo->Name.Buffer : L"?");

  00021	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _nameInfoSize$[ebp]
  00027	51		 push	 ecx
  00028	68 80 00 00 00	 push	 128			; 00000080H
  0002d	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _nameInfo$[ebp]
  00033	52		 push	 edx
  00034	8b 45 0c	 mov	 eax, DWORD PTR _pdo$[ebp]
  00037	50		 push	 eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ObQueryNameString@16
  0003e	85 c0		 test	 eax, eax
  00040	7c 11		 jl	 SHORT $LN6@DriverAddD
  00042	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _nameInfo$[ebp]
  00048	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0004b	89 95 68 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
  00051	eb 0a		 jmp	 SHORT $LN7@DriverAddD
$LN6@DriverAddD:
  00053	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv72[ebp], OFFSET ??_C@_13HGPDMIBE@?$AA?$DP?$AA?$AA@FNODOBFM@
$LN7@DriverAddD:
  0005d	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00063	50		 push	 eax
  00064	8b 4d 0c	 mov	 ecx, DWORD PTR _pdo$[ebp]
  00067	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  0006a	52		 push	 edx
  0006b	8b 45 0c	 mov	 eax, DWORD PTR _pdo$[ebp]
  0006e	50		 push	 eax
  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@FCIMJPEM@AddDevice?5pdo?$DN?$CFp?5type?$DN?$CFx?5name?$DN?$CFw@FNODOBFM@
  00074	e8 00 00 00 00	 call	 _DbgPrint
  00079	83 c4 10	 add	 esp, 16			; 00000010H

; 118  : #endif
; 119  : 
; 120  : 	if (VolumeClassFilterRegistered && BootArgsValid && BootArgs.HiddenSystemPartitionStart != 0)

  0007c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _VolumeClassFilterRegistered, 0
  00083	0f 84 85 00 00
	00		 je	 $LN3@DriverAddD
  00089	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _BootArgsValid, 0
  00090	74 7c		 je	 SHORT $LN3@DriverAddD
  00092	8b 0d 5a 00 00
	00		 mov	 ecx, DWORD PTR _BootArgs+90
  00098	0b 0d 5e 00 00
	00		 or	 ecx, DWORD PTR _BootArgs+94
  0009e	74 6e		 je	 SHORT $LN3@DriverAddD

; 121  : 	{
; 122  : 		PWSTR interfaceLinks;
; 123  : 		if (NT_SUCCESS (IoGetDeviceInterfaces (&GUID_DEVINTERFACE_VOLUME, pdo, DEVICE_INTERFACE_INCLUDE_NONACTIVE, &interfaceLinks)))

  000a0	8d 95 6c ff ff
	ff		 lea	 edx, DWORD PTR _interfaceLinks$29779[ebp]
  000a6	52		 push	 edx
  000a7	6a 01		 push	 1
  000a9	8b 45 0c	 mov	 eax, DWORD PTR _pdo$[ebp]
  000ac	50		 push	 eax
  000ad	68 00 00 00 00	 push	 OFFSET _GUID_DEVINTERFACE_VOLUME
  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoGetDeviceInterfaces@16
  000b8	85 c0		 test	 eax, eax
  000ba	7c 52		 jl	 SHORT $LN3@DriverAddD

; 124  : 		{
; 125  : 			if (interfaceLinks[0] != UNICODE_NULL)

  000bc	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _interfaceLinks$29779[ebp]
  000c2	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  000c5	85 d2		 test	 edx, edx
  000c7	74 36		 je	 SHORT $LN1@DriverAddD

; 126  : 			{
; 127  : 				Dump ("Volume pdo=%p interface=%ws\n", pdo, interfaceLinks);

  000c9	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _interfaceLinks$29779[ebp]
  000cf	50		 push	 eax
  000d0	8b 4d 0c	 mov	 ecx, DWORD PTR _pdo$[ebp]
  000d3	51		 push	 ecx
  000d4	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@PIELMKDH@Volume?5pdo?$DN?$CFp?5interface?$DN?$CFws?6?$AA@FNODOBFM@
  000d9	e8 00 00 00 00	 call	 _DbgPrint
  000de	83 c4 0c	 add	 esp, 12			; 0000000cH

; 128  : 				ExFreePool (interfaceLinks);

  000e1	6a 00		 push	 0
  000e3	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _interfaceLinks$29779[ebp]
  000e9	52		 push	 edx
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 129  : 
; 130  : 				return VolumeFilterAddDevice (driverObject, pdo);

  000f0	8b 45 0c	 mov	 eax, DWORD PTR _pdo$[ebp]
  000f3	50		 push	 eax
  000f4	8b 4d 08	 mov	 ecx, DWORD PTR _driverObject$[ebp]
  000f7	51		 push	 ecx
  000f8	e8 00 00 00 00	 call	 _VolumeFilterAddDevice@8
  000fd	eb 1c		 jmp	 SHORT $LN4@DriverAddD
$LN1@DriverAddD:

; 131  : 			}
; 132  : 
; 133  : 			ExFreePool (interfaceLinks);

  000ff	6a 00		 push	 0
  00101	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _interfaceLinks$29779[ebp]
  00107	52		 push	 edx
  00108	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN3@DriverAddD:

; 134  : 		}
; 135  : 	}
; 136  : 
; 137  : 	return DriveFilterAddDevice (driverObject, pdo);

  0010e	8b 45 0c	 mov	 eax, DWORD PTR _pdo$[ebp]
  00111	50		 push	 eax
  00112	8b 4d 08	 mov	 ecx, DWORD PTR _driverObject$[ebp]
  00115	51		 push	 ecx
  00116	e8 00 00 00 00	 call	 _DriveFilterAddDevice@8
$LN4@DriverAddD:

; 138  : }

  0011b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011e	33 cd		 xor	 ecx, ebp
  00120	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00125	8b e5		 mov	 esp, ebp
  00127	5d		 pop	 ebp
  00128	c2 08 00	 ret	 8
_DriverAddDevice@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DF@IHIBAGEA@0x?$CF08p?5?5?$CF02x?5?$CF02x?5?$CF02x?5?$CF02x?5?$CF02x@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	__$ArrayPad$
PUBLIC	_DumpMemory@8
;	COMDAT ??_C@_0DF@IHIBAGEA@0x?$CF08p?5?5?$CF02x?5?$CF02x?5?$CF02x?5?$CF02x?5?$CF02x@FNODOBFM@
text$s	SEGMENT
??_C@_0DF@IHIBAGEA@0x?$CF08p?5?5?$CF02x?5?$CF02x?5?$CF02x?5?$CF02x?5?$CF02x@FNODOBFM@ DB '0'
	DB	'x%08p  %02x %02x %02x %02x %02x %02x %02x %02x  %s', 0aH, 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _DumpMemory@8
_TEXT	SEGMENT
_str$ = -36						; size = 20
__$ArrayPad$ = -16					; size = 4
_m$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_mem$ = 8						; size = 4
_size$ = 12						; size = 4
_DumpMemory@8 PROC					; COMDAT

; 143  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 24	 sub	 esp, 36			; 00000024H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 144  : 	unsigned char str[20];
; 145  : 	unsigned char *m = mem;

  00012	8b 45 08	 mov	 eax, DWORD PTR _mem$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR _m$[ebp], eax

; 146  : 	int i,j;
; 147  : 
; 148  : 	for (j = 0; j < size / 8; j++)

  00018	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  0001f	eb 09		 jmp	 SHORT $LN8@DumpMemory
$LN7@DumpMemory:
  00021	8b 4d f8	 mov	 ecx, DWORD PTR _j$[ebp]
  00024	83 c1 01	 add	 ecx, 1
  00027	89 4d f8	 mov	 DWORD PTR _j$[ebp], ecx
$LN8@DumpMemory:
  0002a	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  0002d	99		 cdq
  0002e	83 e2 07	 and	 edx, 7
  00031	03 c2		 add	 eax, edx
  00033	c1 f8 03	 sar	 eax, 3
  00036	39 45 f8	 cmp	 DWORD PTR _j$[ebp], eax
  00039	0f 8d c2 00 00
	00		 jge	 $LN9@DumpMemory

; 149  : 	{
; 150  : 		memset (str,0,sizeof str);

  0003f	33 d2		 xor	 edx, edx
  00041	89 55 dc	 mov	 DWORD PTR _str$[ebp], edx
  00044	89 55 e0	 mov	 DWORD PTR _str$[ebp+4], edx
  00047	89 55 e4	 mov	 DWORD PTR _str$[ebp+8], edx
  0004a	89 55 e8	 mov	 DWORD PTR _str$[ebp+12], edx
  0004d	89 55 ec	 mov	 DWORD PTR _str$[ebp+16], edx

; 151  : 		for (i = 0; i < 8; i++) 

  00050	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00057	eb 09		 jmp	 SHORT $LN5@DumpMemory
$LN4@DumpMemory:
  00059	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0005c	83 c0 01	 add	 eax, 1
  0005f	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN5@DumpMemory:
  00062	83 7d fc 08	 cmp	 DWORD PTR _i$[ebp], 8
  00066	7d 37		 jge	 SHORT $LN3@DumpMemory

; 152  : 		{
; 153  : 			if (m[i] > ' ' && m[i] <= '~')

  00068	8b 4d f4	 mov	 ecx, DWORD PTR _m$[ebp]
  0006b	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  0006e	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00071	83 fa 20	 cmp	 edx, 32			; 00000020H
  00074	7e 1f		 jle	 SHORT $LN2@DumpMemory
  00076	8b 45 f4	 mov	 eax, DWORD PTR _m$[ebp]
  00079	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0007c	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0007f	83 f9 7e	 cmp	 ecx, 126		; 0000007eH
  00082	7f 11		 jg	 SHORT $LN2@DumpMemory

; 154  : 				str[i]=m[i];

  00084	8b 55 f4	 mov	 edx, DWORD PTR _m$[ebp]
  00087	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  0008a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0008d	8a 0a		 mov	 cl, BYTE PTR [edx]
  0008f	88 4c 05 dc	 mov	 BYTE PTR _str$[ebp+eax], cl

; 155  : 			else

  00093	eb 08		 jmp	 SHORT $LN1@DumpMemory
$LN2@DumpMemory:

; 156  : 				str[i]='.';

  00095	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00098	c6 44 15 dc 2e	 mov	 BYTE PTR _str$[ebp+edx], 46 ; 0000002eH
$LN1@DumpMemory:

; 157  : 		}

  0009d	eb ba		 jmp	 SHORT $LN4@DumpMemory
$LN3@DumpMemory:

; 158  : 
; 159  : 		Dump ("0x%08p  %02x %02x %02x %02x %02x %02x %02x %02x  %s\n",
; 160  : 			m, m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], str);

  0009f	8d 45 dc	 lea	 eax, DWORD PTR _str$[ebp]
  000a2	50		 push	 eax
  000a3	8b 4d f4	 mov	 ecx, DWORD PTR _m$[ebp]
  000a6	0f b6 51 07	 movzx	 edx, BYTE PTR [ecx+7]
  000aa	52		 push	 edx
  000ab	8b 45 f4	 mov	 eax, DWORD PTR _m$[ebp]
  000ae	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  000b2	51		 push	 ecx
  000b3	8b 55 f4	 mov	 edx, DWORD PTR _m$[ebp]
  000b6	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  000ba	50		 push	 eax
  000bb	8b 4d f4	 mov	 ecx, DWORD PTR _m$[ebp]
  000be	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  000c2	52		 push	 edx
  000c3	8b 45 f4	 mov	 eax, DWORD PTR _m$[ebp]
  000c6	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  000ca	51		 push	 ecx
  000cb	8b 55 f4	 mov	 edx, DWORD PTR _m$[ebp]
  000ce	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  000d2	50		 push	 eax
  000d3	8b 4d f4	 mov	 ecx, DWORD PTR _m$[ebp]
  000d6	0f b6 51 01	 movzx	 edx, BYTE PTR [ecx+1]
  000da	52		 push	 edx
  000db	8b 45 f4	 mov	 eax, DWORD PTR _m$[ebp]
  000de	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000e1	51		 push	 ecx
  000e2	8b 55 f4	 mov	 edx, DWORD PTR _m$[ebp]
  000e5	52		 push	 edx
  000e6	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@IHIBAGEA@0x?$CF08p?5?5?$CF02x?5?$CF02x?5?$CF02x?5?$CF02x?5?$CF02x@FNODOBFM@
  000eb	e8 00 00 00 00	 call	 _DbgPrint
  000f0	83 c4 2c	 add	 esp, 44			; 0000002cH

; 161  : 
; 162  : 		m+=8;

  000f3	8b 45 f4	 mov	 eax, DWORD PTR _m$[ebp]
  000f6	83 c0 08	 add	 eax, 8
  000f9	89 45 f4	 mov	 DWORD PTR _m$[ebp], eax

; 163  : 	}

  000fc	e9 20 ff ff ff	 jmp	 $LN7@DumpMemory
$LN9@DumpMemory:

; 164  : }

  00101	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00104	33 cd		 xor	 ecx, ebp
  00106	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010b	8b e5		 mov	 esp, ebp
  0010d	5d		 pop	 ebp
  0010e	c2 08 00	 ret	 8
_DumpMemory@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0FE@HIDEPCAO@STATUS_BUFFER_TOO_SMALL?5ioctl?$DN0x@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_IoGetCurrentIrpStackLocation@4
PUBLIC	_ValidateIOBufferSize@12
;	COMDAT ??_C@_0FE@HIDEPCAO@STATUS_BUFFER_TOO_SMALL?5ioctl?$DN0x@FNODOBFM@
text$s	SEGMENT
??_C@_0FE@HIDEPCAO@STATUS_BUFFER_TOO_SMALL?5ioctl?$DN0x@FNODOBFM@ DB 'STA'
	DB	'TUS_BUFFER_TOO_SMALL ioctl=0x%x,%d in=%d out=%d reqsize=%d in'
	DB	'size=%d outsize=%d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _ValidateIOBufferSize@12
_TEXT	SEGMENT
tv71 = -20						; size = 4
tv68 = -16						; size = 4
_irpSp$ = -12						; size = 4
_input$ = -8						; size = 4
_output$ = -4						; size = 4
_irp$ = 8						; size = 4
_requiredBufferSize$ = 12				; size = 4
_type$ = 16						; size = 4
_ValidateIOBufferSize@12 PROC				; COMDAT

; 168  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 14	 sub	 esp, 20			; 00000014H

; 169  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (irp);

  00008	8b 45 08	 mov	 eax, DWORD PTR _irp$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IoGetCurrentIrpStackLocation@4
  00011	89 45 f4	 mov	 DWORD PTR _irpSp$[ebp], eax

; 170  : 	BOOL input = (type == ValidateInput || type == ValidateInputOutput);

  00014	83 7d 10 00	 cmp	 DWORD PTR _type$[ebp], 0
  00018	74 0f		 je	 SHORT $LN7@ValidateIO
  0001a	83 7d 10 02	 cmp	 DWORD PTR _type$[ebp], 2
  0001e	74 09		 je	 SHORT $LN7@ValidateIO
  00020	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  00027	eb 07		 jmp	 SHORT $LN8@ValidateIO
$LN7@ValidateIO:
  00029	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
$LN8@ValidateIO:
  00030	8b 4d f0	 mov	 ecx, DWORD PTR tv68[ebp]
  00033	89 4d f8	 mov	 DWORD PTR _input$[ebp], ecx

; 171  : 	BOOL output = (type == ValidateOutput || type == ValidateInputOutput);

  00036	83 7d 10 01	 cmp	 DWORD PTR _type$[ebp], 1
  0003a	74 0f		 je	 SHORT $LN9@ValidateIO
  0003c	83 7d 10 02	 cmp	 DWORD PTR _type$[ebp], 2
  00040	74 09		 je	 SHORT $LN9@ValidateIO
  00042	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
  00049	eb 07		 jmp	 SHORT $LN10@ValidateIO
$LN9@ValidateIO:
  0004b	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
$LN10@ValidateIO:
  00052	8b 55 ec	 mov	 edx, DWORD PTR tv71[ebp]
  00055	89 55 fc	 mov	 DWORD PTR _output$[ebp], edx

; 172  : 
; 173  : 	if ((input && irpSp->Parameters.DeviceIoControl.InputBufferLength < requiredBufferSize)
; 174  : 		|| (output && irpSp->Parameters.DeviceIoControl.OutputBufferLength < requiredBufferSize))

  00058	83 7d f8 00	 cmp	 DWORD PTR _input$[ebp], 0
  0005c	74 0b		 je	 SHORT $LN2@ValidateIO
  0005e	8b 45 f4	 mov	 eax, DWORD PTR _irpSp$[ebp]
  00061	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00064	3b 4d 0c	 cmp	 ecx, DWORD PTR _requiredBufferSize$[ebp]
  00067	72 11		 jb	 SHORT $LN3@ValidateIO
$LN2@ValidateIO:
  00069	83 7d fc 00	 cmp	 DWORD PTR _output$[ebp], 0
  0006d	74 63		 je	 SHORT $LN4@ValidateIO
  0006f	8b 55 f4	 mov	 edx, DWORD PTR _irpSp$[ebp]
  00072	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00075	3b 45 0c	 cmp	 eax, DWORD PTR _requiredBufferSize$[ebp]
  00078	73 58		 jae	 SHORT $LN4@ValidateIO
$LN3@ValidateIO:

; 175  : 	{
; 176  : 		Dump ("STATUS_BUFFER_TOO_SMALL ioctl=0x%x,%d in=%d out=%d reqsize=%d insize=%d outsize=%d\n", (int) (irpSp->Parameters.DeviceIoControl.IoControlCode >> 16), (int) ((irpSp->Parameters.DeviceIoControl.IoControlCode & 0x1FFF) >> 2), input, output, requiredBufferSize, irpSp->Parameters.DeviceIoControl.InputBufferLength, irpSp->Parameters.DeviceIoControl.OutputBufferLength);

  0007a	8b 4d f4	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  0007d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00080	52		 push	 edx
  00081	8b 45 f4	 mov	 eax, DWORD PTR _irpSp$[ebp]
  00084	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00087	51		 push	 ecx
  00088	8b 55 0c	 mov	 edx, DWORD PTR _requiredBufferSize$[ebp]
  0008b	52		 push	 edx
  0008c	8b 45 fc	 mov	 eax, DWORD PTR _output$[ebp]
  0008f	50		 push	 eax
  00090	8b 4d f8	 mov	 ecx, DWORD PTR _input$[ebp]
  00093	51		 push	 ecx
  00094	8b 55 f4	 mov	 edx, DWORD PTR _irpSp$[ebp]
  00097	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0009a	25 ff 1f 00 00	 and	 eax, 8191		; 00001fffH
  0009f	c1 e8 02	 shr	 eax, 2
  000a2	50		 push	 eax
  000a3	8b 4d f4	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  000a6	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000a9	c1 ea 10	 shr	 edx, 16			; 00000010H
  000ac	52		 push	 edx
  000ad	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@HIDEPCAO@STATUS_BUFFER_TOO_SMALL?5ioctl?$DN0x@FNODOBFM@
  000b2	e8 00 00 00 00	 call	 _DbgPrint
  000b7	83 c4 20	 add	 esp, 32			; 00000020H

; 177  : 
; 178  : 		irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;

  000ba	8b 45 08	 mov	 eax, DWORD PTR _irp$[ebp]
  000bd	c7 40 18 23 00
	00 c0		 mov	 DWORD PTR [eax+24], -1073741789 ; c0000023H

; 179  : 		irp->IoStatus.Information = 0;

  000c4	8b 4d 08	 mov	 ecx, DWORD PTR _irp$[ebp]
  000c7	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 180  : 		return FALSE;

  000ce	33 c0		 xor	 eax, eax
  000d0	eb 29		 jmp	 SHORT $LN5@ValidateIO
$LN4@ValidateIO:

; 181  : 	}
; 182  : 
; 183  : 	if (!input && output)

  000d2	83 7d f8 00	 cmp	 DWORD PTR _input$[ebp], 0
  000d6	75 1e		 jne	 SHORT $LN1@ValidateIO
  000d8	83 7d fc 00	 cmp	 DWORD PTR _output$[ebp], 0
  000dc	74 18		 je	 SHORT $LN1@ValidateIO

; 184  : 		memset (irp->AssociatedIrp.SystemBuffer, 0, irpSp->Parameters.DeviceIoControl.OutputBufferLength);

  000de	8b 55 f4	 mov	 edx, DWORD PTR _irpSp$[ebp]
  000e1	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000e4	50		 push	 eax
  000e5	6a 00		 push	 0
  000e7	8b 4d 08	 mov	 ecx, DWORD PTR _irp$[ebp]
  000ea	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000ed	52		 push	 edx
  000ee	e8 00 00 00 00	 call	 _memset
  000f3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@ValidateIO:

; 185  : 
; 186  : 	return TRUE;

  000f6	b8 01 00 00 00	 mov	 eax, 1
$LN5@ValidateIO:

; 187  : }

  000fb	8b e5		 mov	 esp, ebp
  000fd	5d		 pop	 ebp
  000fe	c2 0c 00	 ret	 12			; 0000000cH
_ValidateIOBufferSize@12 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp__RtlAssert@16:PROC
;	COMDAT ??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
text$s	SEGMENT
??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ DB 'I'
	DB	'rp->CurrentLocation <= Irp->StackCount + 1', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@
text$s	SEGMENT
??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@ DB 'c'
	DB	':\winddk\7600.16385.1\inc\ddk\wdm.h', 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _IoGetCurrentIrpStackLocation@4
_TEXT	SEGMENT
tv74 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoGetCurrentIrpStackLocation@4 PROC			; COMDAT

; 23316: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 23317:     ASSERT(Irp->CurrentLocation <= Irp->StackCount + 1);

  00006	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00009	0f be 48 23	 movsx	 ecx, BYTE PTR [eax+35]
  0000d	8b 55 08	 mov	 edx, DWORD PTR _Irp$[ebp]
  00010	0f be 42 22	 movsx	 eax, BYTE PTR [edx+34]
  00014	83 c0 01	 add	 eax, 1
  00017	3b c8		 cmp	 ecx, eax
  00019	7e 20		 jle	 SHORT $LN3@IoGetCurre
  0001b	6a 00		 push	 0
  0001d	68 15 5b 00 00	 push	 23317			; 00005b15H
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
  00039	eb 07		 jmp	 SHORT $LN4@IoGetCurre
$LN3@IoGetCurre:
  0003b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
$LN4@IoGetCurre:

; 23318:     return Irp->Tail.Overlay.CurrentStackLocation;

  00042	8b 4d 08	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00045	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]

; 23319: }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
_IoGetCurrentIrpStackLocation@4 ENDP
_TEXT	ENDS
PUBLIC	_GetVirtualVolumeDeviceObject@4
; Function compile flags: /Odtp
; File c:\users\public\desktop\projects\ciphershed\src\driver\ntdriver.c
;	COMDAT _GetVirtualVolumeDeviceObject@4
_TEXT	SEGMENT
_driveNumber$ = 8					; size = 4
_GetVirtualVolumeDeviceObject@4 PROC			; COMDAT

; 191  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 192  : 	if (driveNumber < MIN_MOUNTED_VOLUME_DRIVE_NUMBER || driveNumber > MAX_MOUNTED_VOLUME_DRIVE_NUMBER)

  00005	83 7d 08 00	 cmp	 DWORD PTR _driveNumber$[ebp], 0
  00009	7c 06		 jl	 SHORT $LN1@GetVirtual
  0000b	83 7d 08 19	 cmp	 DWORD PTR _driveNumber$[ebp], 25 ; 00000019H
  0000f	7e 04		 jle	 SHORT $LN2@GetVirtual
$LN1@GetVirtual:

; 193  : 		return NULL;

  00011	33 c0		 xor	 eax, eax
  00013	eb 0a		 jmp	 SHORT $LN3@GetVirtual
$LN2@GetVirtual:

; 194  : 
; 195  : 	return VirtualVolumeDeviceObjects[driveNumber];

  00015	8b 45 08	 mov	 eax, DWORD PTR _driveNumber$[ebp]
  00018	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _VirtualVolumeDeviceObjects[eax*4]
$LN3@GetVirtual:

; 196  : }

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
_GetVirtualVolumeDeviceObject@4 ENDP
_TEXT	ENDS
PUBLIC	_IoMarkIrpPending@4
PUBLIC	_TCCompleteIrp@12
PUBLIC	??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EI@NJLFEPKD@Removable?5device?5?$CFd?5has?5DO_VERIF@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_TCCompleteDiskIrp@12
PUBLIC	??_C@_0DA@HGPNLENJ@Device?5?$CFd?5shutting?5down?3?5STATUS_@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_ProcessMainDeviceControlIrp@12
PUBLIC	_OnShutdownPending@0
PUBLIC	_SendDeviceIoControlRequest@24
PUBLIC	??_C@_0BG@JHFMBFJC@Driver?5shutting?5down?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0P@CMDFIGFB@?$CFls?5?$CI0x?$CFx?5?$CFd?$CJ?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_TCTranslateCode@4
EXTRN	__imp__KeReleaseSemaphore@16:PROC
EXTRN	__imp_@ExfInterlockedInsertTailList@12:PROC
EXTRN	__imp__IoAcquireRemoveLockEx@20:PROC
EXTRN	_EncryptedIoQueueAddIrp@8:PROC
EXTRN	__imp__KeReleaseMutex@8:PROC
EXTRN	__imp__KeWaitForSingleObject@20:PROC
EXTRN	_DecoySystemWipeThread:DWORD
EXTRN	_EncryptionSetupThread:DWORD
EXTRN	_COMPLETE_IRP@16:PROC
EXTRN	_VolumeFilterDispatchIrp@8:PROC
EXTRN	_DriveFilterDispatchIrp@8:PROC
_BSS	SEGMENT
_RootDeviceControlMutex DB 020H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@FNODOBFM@
text$s	SEGMENT
??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@FNODOBFM@ DB 'c:'
	DB	'\users\public\desktop\projects\ciphershed\src\driver\ntdriver'
	DB	'.c', 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EI@NJLFEPKD@Removable?5device?5?$CFd?5has?5DO_VERIF@FNODOBFM@
text$s	SEGMENT
??_C@_0EI@NJLFEPKD@Removable?5device?5?$CFd?5has?5DO_VERIF@FNODOBFM@ DB 'R'
	DB	'emovable device %d has DO_VERIFY_VOLUME flag: STATUS_DEVICE_N'
	DB	'OT_READY', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DA@HGPNLENJ@Device?5?$CFd?5shutting?5down?3?5STATUS_@FNODOBFM@
text$s	SEGMENT
??_C@_0DA@HGPNLENJ@Device?5?$CFd?5shutting?5down?3?5STATUS_@FNODOBFM@ DB 'D'
	DB	'evice %d shutting down: STATUS_DELETE_PENDING', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BG@JHFMBFJC@Driver?5shutting?5down?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BG@JHFMBFJC@Driver?5shutting?5down?6?$AA@FNODOBFM@ DB 'Driver shut'
	DB	'ting down', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0P@CMDFIGFB@?$CFls?5?$CI0x?$CFx?5?$CFd?$CJ?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0P@CMDFIGFB@?$CFls?5?$CI0x?$CFx?5?$CFd?$CJ?6?$AA@FNODOBFM@ DB '%ls '
	DB	'(0x%x %d)', 0aH, 00H			;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _TCDispatchQueueIRP@8
_TEXT	SEGMENT
tv210 = -28						; size = 4
tv135 = -24						; size = 4
tv73 = -20						; size = 4
_status$29878 = -16					; size = 4
_irpSp$ = -12						; size = 4
_ntStatus$ = -8						; size = 4
_Extension$ = -4					; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_TCDispatchQueueIRP@8 PROC				; COMDAT

; 202  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 203  : 	PEXTENSION Extension = (PEXTENSION) DeviceObject->DeviceExtension;

  00008	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  0000b	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0000e	89 4d fc	 mov	 DWORD PTR _Extension$[ebp], ecx

; 204  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);

  00011	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _IoGetCurrentIrpStackLocation@4
  0001a	89 45 f4	 mov	 DWORD PTR _irpSp$[ebp], eax

; 205  : 	NTSTATUS ntStatus;
; 206  : 
; 207  : #ifdef _DEBUG
; 208  : 	if (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL && (Extension->bRootDevice || Extension->IsVolumeDevice))

  0001d	8b 45 f4	 mov	 eax, DWORD PTR _irpSp$[ebp]
  00020	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00023	83 f9 0e	 cmp	 ecx, 14			; 0000000eH
  00026	0f 85 8f 00 00
	00		 jne	 $LN35@TCDispatch
  0002c	8b 55 fc	 mov	 edx, DWORD PTR _Extension$[ebp]
  0002f	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00032	75 09		 jne	 SHORT $LN34@TCDispatch
  00034	8b 45 fc	 mov	 eax, DWORD PTR _Extension$[ebp]
  00037	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0003b	74 7e		 je	 SHORT $LN35@TCDispatch
$LN34@TCDispatch:

; 209  : 	{
; 210  : 		switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  0003d	8b 4d f4	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  00040	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00043	89 55 ec	 mov	 DWORD PTR tv73[ebp], edx
  00046	81 7d ec 18 20
	22 00		 cmp	 DWORD PTR tv73[ebp], 2236440 ; 00222018H
  0004d	77 14		 ja	 SHORT $LN38@TCDispatch
  0004f	81 7d ec 18 20
	22 00		 cmp	 DWORD PTR tv73[ebp], 2236440 ; 00222018H
  00056	74 2d		 je	 SHORT $LN31@TCDispatch
  00058	81 7d ec 00 48
	07 00		 cmp	 DWORD PTR tv73[ebp], 477184 ; 00074800H
  0005f	74 24		 je	 SHORT $LN31@TCDispatch
  00061	eb 24		 jmp	 SHORT $LN30@TCDispatch
$LN38@TCDispatch:
  00063	8b 45 ec	 mov	 eax, DWORD PTR tv73[ebp]
  00066	2d 20 20 22 00	 sub	 eax, 2236448		; 00222020H
  0006b	89 45 ec	 mov	 DWORD PTR tv73[ebp], eax
  0006e	83 7d ec 6c	 cmp	 DWORD PTR tv73[ebp], 108 ; 0000006cH
  00072	77 13		 ja	 SHORT $LN30@TCDispatch
  00074	8b 4d ec	 mov	 ecx, DWORD PTR tv73[ebp]
  00077	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN39@TCDispatch[ecx]
  0007e	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN42@TCDispatch[edx*4]
$LN31@TCDispatch:

; 211  : 		{
; 212  : 		case TC_IOCTL_GET_MOUNTED_VOLUMES:
; 213  : 		case TC_IOCTL_GET_PASSWORD_CACHE_STATUS:
; 214  : 		case TC_IOCTL_GET_PORTABLE_MODE_STATUS:
; 215  : 		case TC_IOCTL_SET_PORTABLE_MODE_STATUS:
; 216  : 		case TC_IOCTL_OPEN_TEST:
; 217  : 		case TC_IOCTL_GET_RESOLVED_SYMLINK:
; 218  : 		case TC_IOCTL_GET_DEVICE_REFCOUNT:
; 219  : 		case TC_IOCTL_GET_DRIVE_PARTITION_INFO:
; 220  : 		case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:
; 221  : 		case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS:
; 222  : 		case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS:
; 223  : 		case TC_IOCTL_GET_WARNING_FLAGS:
; 224  : 		case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:
; 225  : 		case IOCTL_DISK_CHECK_VERIFY:
; 226  : 			break;

  00085	eb 34		 jmp	 SHORT $LN35@TCDispatch
$LN30@TCDispatch:

; 227  : 
; 228  : 		default:
; 229  : 			Dump ("%ls (0x%x %d)\n",
; 230  : 				TCTranslateCode (irpSp->Parameters.DeviceIoControl.IoControlCode),
; 231  : 				(int) (irpSp->Parameters.DeviceIoControl.IoControlCode >> 16),
; 232  : 				(int) ((irpSp->Parameters.DeviceIoControl.IoControlCode & 0x1FFF) >> 2));

  00087	8b 45 f4	 mov	 eax, DWORD PTR _irpSp$[ebp]
  0008a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0008d	81 e1 ff 1f 00
	00		 and	 ecx, 8191		; 00001fffH
  00093	c1 e9 02	 shr	 ecx, 2
  00096	51		 push	 ecx
  00097	8b 55 f4	 mov	 edx, DWORD PTR _irpSp$[ebp]
  0009a	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0009d	c1 e8 10	 shr	 eax, 16			; 00000010H
  000a0	50		 push	 eax
  000a1	8b 4d f4	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  000a4	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000a7	52		 push	 edx
  000a8	e8 00 00 00 00	 call	 _TCTranslateCode@4
  000ad	50		 push	 eax
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_0P@CMDFIGFB@?$CFls?5?$CI0x?$CFx?5?$CFd?$CJ?6?$AA@FNODOBFM@
  000b3	e8 00 00 00 00	 call	 _DbgPrint
  000b8	83 c4 10	 add	 esp, 16			; 00000010H
$LN35@TCDispatch:

; 233  : 		}
; 234  : 	}
; 235  : #endif
; 236  : 
; 237  : 	if (!Extension->bRootDevice)

  000bb	8b 45 fc	 mov	 eax, DWORD PTR _Extension$[ebp]
  000be	83 38 00	 cmp	 DWORD PTR [eax], 0
  000c1	75 36		 jne	 SHORT $LN29@TCDispatch

; 238  : 	{
; 239  : 		// Drive filter IRP
; 240  : 		if (Extension->IsDriveFilterDevice)

  000c3	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  000c6	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  000ca	74 12		 je	 SHORT $LN28@TCDispatch

; 241  : 			return DriveFilterDispatchIrp (DeviceObject, Irp);

  000cc	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  000cf	52		 push	 edx
  000d0	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  000d3	50		 push	 eax
  000d4	e8 00 00 00 00	 call	 _DriveFilterDispatchIrp@8
  000d9	e9 1b 03 00 00	 jmp	 $LN36@TCDispatch
$LN28@TCDispatch:

; 242  : 
; 243  : 		// Volume filter IRP
; 244  : 		if (Extension->IsVolumeFilterDevice)

  000de	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  000e1	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  000e5	74 12		 je	 SHORT $LN29@TCDispatch

; 245  : 			return VolumeFilterDispatchIrp (DeviceObject, Irp);

  000e7	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  000ea	52		 push	 edx
  000eb	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 _VolumeFilterDispatchIrp@8
  000f4	e9 00 03 00 00	 jmp	 $LN36@TCDispatch
$LN29@TCDispatch:

; 246  : 	}
; 247  : 
; 248  : 	switch (irpSp->MajorFunction)

  000f9	8b 4d f4	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  000fc	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  000ff	89 55 e8	 mov	 DWORD PTR tv135[ebp], edx
  00102	83 7d e8 1b	 cmp	 DWORD PTR tv135[ebp], 27 ; 0000001bH
  00106	0f 87 dd 02 00
	00		 ja	 $LN25@TCDispatch
  0010c	8b 45 e8	 mov	 eax, DWORD PTR tv135[ebp]
  0010f	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN40@TCDispatch[eax]
  00116	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN43@TCDispatch[ecx*4]
$LN24@TCDispatch:

; 249  : 	{
; 250  : 	case IRP_MJ_CLOSE:
; 251  : 	case IRP_MJ_CREATE:
; 252  : 	case IRP_MJ_CLEANUP:
; 253  : 		return COMPLETE_IRP (DeviceObject, Irp, STATUS_SUCCESS, 0);

  0011d	6a 00		 push	 0
  0011f	6a 00		 push	 0
  00121	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  00124	52		 push	 edx
  00125	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00128	50		 push	 eax
  00129	e8 00 00 00 00	 call	 _COMPLETE_IRP@16
  0012e	e9 c6 02 00 00	 jmp	 $LN36@TCDispatch
$LN23@TCDispatch:

; 254  : 
; 255  : 	case IRP_MJ_SHUTDOWN:
; 256  : 		if (Extension->bRootDevice)

  00133	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00136	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00139	74 71		 je	 SHORT $LN22@TCDispatch

; 257  : 		{
; 258  : 			Dump ("Driver shutting down\n");

  0013b	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@JHFMBFJC@Driver?5shutting?5down?6?$AA@FNODOBFM@
  00140	e8 00 00 00 00	 call	 _DbgPrint
  00145	83 c4 04	 add	 esp, 4

; 259  : 			DriverShuttingDown = TRUE;

  00148	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _DriverShuttingDown, 1

; 260  : 
; 261  : 			if (EncryptionSetupThread)

  00152	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _EncryptionSetupThread, 0
  00159	74 22		 je	 SHORT $LN21@TCDispatch
$LN20@TCDispatch:

; 262  : 				while (SendDeviceIoControlRequest (RootDeviceObject, TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP, NULL, 0, NULL, 0) == STATUS_INSUFFICIENT_RESOURCES);

  0015b	6a 00		 push	 0
  0015d	6a 00		 push	 0
  0015f	6a 00		 push	 0
  00161	6a 00		 push	 0
  00163	68 50 20 22 00	 push	 2236496			; 00222050H
  00168	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _RootDeviceObject
  0016e	52		 push	 edx
  0016f	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  00174	3d 9a 00 00 c0	 cmp	 eax, -1073741670	; c000009aH
  00179	75 02		 jne	 SHORT $LN21@TCDispatch
  0017b	eb de		 jmp	 SHORT $LN20@TCDispatch
$LN21@TCDispatch:

; 263  : 
; 264  : 			if (DecoySystemWipeThread)

  0017d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _DecoySystemWipeThread, 0
  00184	74 21		 je	 SHORT $LN18@TCDispatch
$LN17@TCDispatch:

; 265  : 				while (SendDeviceIoControlRequest (RootDeviceObject, TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE, NULL, 0, NULL, 0) == STATUS_INSUFFICIENT_RESOURCES);

  00186	6a 00		 push	 0
  00188	6a 00		 push	 0
  0018a	6a 00		 push	 0
  0018c	6a 00		 push	 0
  0018e	68 7c 20 22 00	 push	 2236540			; 0022207cH
  00193	a1 00 00 00 00	 mov	 eax, DWORD PTR _RootDeviceObject
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  0019e	3d 9a 00 00 c0	 cmp	 eax, -1073741670	; c000009aH
  001a3	75 02		 jne	 SHORT $LN18@TCDispatch
  001a5	eb df		 jmp	 SHORT $LN17@TCDispatch
$LN18@TCDispatch:

; 266  : 
; 267  : 			OnShutdownPending();

  001a7	e8 00 00 00 00	 call	 _OnShutdownPending@0
$LN22@TCDispatch:

; 268  : 		}
; 269  : 
; 270  : 		return COMPLETE_IRP (DeviceObject, Irp, STATUS_SUCCESS, 0);

  001ac	6a 00		 push	 0
  001ae	6a 00		 push	 0
  001b0	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  001b3	51		 push	 ecx
  001b4	8b 55 08	 mov	 edx, DWORD PTR _DeviceObject$[ebp]
  001b7	52		 push	 edx
  001b8	e8 00 00 00 00	 call	 _COMPLETE_IRP@16
  001bd	e9 37 02 00 00	 jmp	 $LN36@TCDispatch
$LN15@TCDispatch:

; 271  : 
; 272  : 	case IRP_MJ_FLUSH_BUFFERS:
; 273  : 	case IRP_MJ_READ:
; 274  : 	case IRP_MJ_WRITE:
; 275  : 	case IRP_MJ_DEVICE_CONTROL:
; 276  : 
; 277  : 		if (Extension->bRootDevice)

  001c2	8b 45 fc	 mov	 eax, DWORD PTR _Extension$[ebp]
  001c5	83 38 00	 cmp	 DWORD PTR [eax], 0
  001c8	74 5d		 je	 SHORT $LN14@TCDispatch

; 278  : 		{
; 279  : 			if (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL)

  001ca	8b 4d f4	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  001cd	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  001d0	83 fa 0e	 cmp	 edx, 14			; 0000000eH
  001d3	75 4d		 jne	 SHORT $LN13@TCDispatch

; 280  : 			{
; 281  : 				NTSTATUS status = KeWaitForMutexObject (&RootDeviceControlMutex, Executive, KernelMode, FALSE, NULL);

  001d5	6a 00		 push	 0
  001d7	6a 00		 push	 0
  001d9	6a 00		 push	 0
  001db	6a 00		 push	 0
  001dd	68 00 00 00 00	 push	 OFFSET _RootDeviceControlMutex
  001e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
  001e8	89 45 f0	 mov	 DWORD PTR _status$29878[ebp], eax

; 282  : 				if (!NT_SUCCESS (status))

  001eb	83 7d f0 00	 cmp	 DWORD PTR _status$29878[ebp], 0
  001ef	7d 08		 jge	 SHORT $LN12@TCDispatch

; 283  : 					return status;

  001f1	8b 45 f0	 mov	 eax, DWORD PTR _status$29878[ebp]
  001f4	e9 00 02 00 00	 jmp	 $LN36@TCDispatch
$LN12@TCDispatch:

; 284  : 
; 285  : 				status = ProcessMainDeviceControlIrp (DeviceObject, Extension, Irp);

  001f9	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  001fc	50		 push	 eax
  001fd	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00200	51		 push	 ecx
  00201	8b 55 08	 mov	 edx, DWORD PTR _DeviceObject$[ebp]
  00204	52		 push	 edx
  00205	e8 00 00 00 00	 call	 _ProcessMainDeviceControlIrp@12
  0020a	89 45 f0	 mov	 DWORD PTR _status$29878[ebp], eax

; 286  : 
; 287  : 				KeReleaseMutex (&RootDeviceControlMutex, FALSE);

  0020d	6a 00		 push	 0
  0020f	68 00 00 00 00	 push	 OFFSET _RootDeviceControlMutex
  00214	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeReleaseMutex@8

; 288  : 				return status;

  0021a	8b 45 f0	 mov	 eax, DWORD PTR _status$29878[ebp]
  0021d	e9 d7 01 00 00	 jmp	 $LN36@TCDispatch
$LN13@TCDispatch:

; 289  : 			}
; 290  : 			break;

  00222	e9 c2 01 00 00	 jmp	 $LN25@TCDispatch
$LN14@TCDispatch:

; 291  : 		}
; 292  : 
; 293  : 		if (Extension->bShuttingDown)

  00227	8b 45 fc	 mov	 eax, DWORD PTR _Extension$[ebp]
  0022a	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  0022e	74 29		 je	 SHORT $LN11@TCDispatch

; 294  : 		{
; 295  : 			Dump ("Device %d shutting down: STATUS_DELETE_PENDING\n", Extension->nDosDriveNo);

  00230	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00233	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00236	52		 push	 edx
  00237	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@HGPNLENJ@Device?5?$CFd?5shutting?5down?3?5STATUS_@FNODOBFM@
  0023c	e8 00 00 00 00	 call	 _DbgPrint
  00241	83 c4 08	 add	 esp, 8

; 296  : 			return TCCompleteDiskIrp (Irp, STATUS_DELETE_PENDING, 0);

  00244	6a 00		 push	 0
  00246	68 56 00 00 c0	 push	 -1073741738		; c0000056H
  0024b	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  0024e	50		 push	 eax
  0024f	e8 00 00 00 00	 call	 _TCCompleteDiskIrp@12
  00254	e9 a0 01 00 00	 jmp	 $LN36@TCDispatch
$LN11@TCDispatch:

; 297  : 		}
; 298  : 
; 299  : 		if (Extension->bRemovable
; 300  : 			&& (DeviceObject->Flags & DO_VERIFY_VOLUME)
; 301  : 			&& !(irpSp->Flags & SL_OVERRIDE_VERIFY_VOLUME)
; 302  : 			&& irpSp->MajorFunction != IRP_MJ_FLUSH_BUFFERS)

  00259	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0025c	83 b9 8c 02 00
	00 00		 cmp	 DWORD PTR [ecx+652], 0
  00263	74 4b		 je	 SHORT $LN10@TCDispatch
  00265	8b 55 08	 mov	 edx, DWORD PTR _DeviceObject$[ebp]
  00268	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0026b	83 e0 02	 and	 eax, 2
  0026e	74 40		 je	 SHORT $LN10@TCDispatch
  00270	8b 4d f4	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  00273	0f b6 51 02	 movzx	 edx, BYTE PTR [ecx+2]
  00277	83 e2 02	 and	 edx, 2
  0027a	75 34		 jne	 SHORT $LN10@TCDispatch
  0027c	8b 45 f4	 mov	 eax, DWORD PTR _irpSp$[ebp]
  0027f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00282	83 f9 09	 cmp	 ecx, 9
  00285	74 29		 je	 SHORT $LN10@TCDispatch

; 303  : 		{
; 304  : 			Dump ("Removable device %d has DO_VERIFY_VOLUME flag: STATUS_DEVICE_NOT_READY\n", Extension->nDosDriveNo);

  00287	8b 55 fc	 mov	 edx, DWORD PTR _Extension$[ebp]
  0028a	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0028d	50		 push	 eax
  0028e	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@NJLFEPKD@Removable?5device?5?$CFd?5has?5DO_VERIF@FNODOBFM@
  00293	e8 00 00 00 00	 call	 _DbgPrint
  00298	83 c4 08	 add	 esp, 8

; 305  : 			return TCCompleteDiskIrp (Irp, STATUS_DEVICE_NOT_READY, 0);

  0029b	6a 00		 push	 0
  0029d	68 a3 00 00 c0	 push	 -1073741661		; c00000a3H
  002a2	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  002a5	51		 push	 ecx
  002a6	e8 00 00 00 00	 call	 _TCCompleteDiskIrp@12
  002ab	e9 49 01 00 00	 jmp	 $LN36@TCDispatch
$LN10@TCDispatch:

; 306  : 		}
; 307  : 
; 308  : 		switch (irpSp->MajorFunction)

  002b0	8b 55 f4	 mov	 edx, DWORD PTR _irpSp$[ebp]
  002b3	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  002b6	89 45 e4	 mov	 DWORD PTR tv210[ebp], eax
  002b9	8b 4d e4	 mov	 ecx, DWORD PTR tv210[ebp]
  002bc	83 e9 03	 sub	 ecx, 3
  002bf	89 4d e4	 mov	 DWORD PTR tv210[ebp], ecx
  002c2	83 7d e4 0b	 cmp	 DWORD PTR tv210[ebp], 11 ; 0000000bH
  002c6	0f 87 ce 00 00
	00		 ja	 $LN8@TCDispatch
  002cc	8b 55 e4	 mov	 edx, DWORD PTR tv210[ebp]
  002cf	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN41@TCDispatch[edx]
  002d6	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN44@TCDispatch[eax*4]
$LN7@TCDispatch:

; 309  : 		{
; 310  : 		case IRP_MJ_READ:
; 311  : 		case IRP_MJ_WRITE:
; 312  : 			ntStatus = EncryptedIoQueueAddIrp (&Extension->Queue, Irp);

  002dd	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  002e0	51		 push	 ecx
  002e1	8b 55 fc	 mov	 edx, DWORD PTR _Extension$[ebp]
  002e4	81 c2 a8 00 00
	00		 add	 edx, 168		; 000000a8H
  002ea	52		 push	 edx
  002eb	e8 00 00 00 00	 call	 _EncryptedIoQueueAddIrp@8
  002f0	89 45 f8	 mov	 DWORD PTR _ntStatus$[ebp], eax

; 313  : 
; 314  : 			if (ntStatus != STATUS_PENDING)

  002f3	81 7d f8 03 01
	00 00		 cmp	 DWORD PTR _ntStatus$[ebp], 259 ; 00000103H
  002fa	74 0f		 je	 SHORT $LN6@TCDispatch

; 315  : 				TCCompleteDiskIrp (Irp, ntStatus, 0);

  002fc	6a 00		 push	 0
  002fe	8b 45 f8	 mov	 eax, DWORD PTR _ntStatus$[ebp]
  00301	50		 push	 eax
  00302	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00305	51		 push	 ecx
  00306	e8 00 00 00 00	 call	 _TCCompleteDiskIrp@12
$LN6@TCDispatch:

; 316  : 
; 317  : 			return ntStatus;

  0030b	8b 45 f8	 mov	 eax, DWORD PTR _ntStatus$[ebp]
  0030e	e9 e6 00 00 00	 jmp	 $LN36@TCDispatch
$LN5@TCDispatch:

; 318  : 
; 319  : 		case IRP_MJ_DEVICE_CONTROL:
; 320  : 			ntStatus = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00313	6a 58		 push	 88			; 00000058H
  00315	68 40 01 00 00	 push	 320			; 00000140H
  0031a	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  0031f	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  00322	52		 push	 edx
  00323	8b 45 fc	 mov	 eax, DWORD PTR _Extension$[ebp]
  00326	05 18 01 00 00	 add	 eax, 280		; 00000118H
  0032b	50		 push	 eax
  0032c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAcquireRemoveLockEx@20
  00332	89 45 f8	 mov	 DWORD PTR _ntStatus$[ebp], eax

; 321  : 			if (!NT_SUCCESS (ntStatus))

  00335	83 7d f8 00	 cmp	 DWORD PTR _ntStatus$[ebp], 0
  00339	7d 14		 jge	 SHORT $LN4@TCDispatch

; 322  : 				return TCCompleteIrp (Irp, ntStatus, 0);

  0033b	6a 00		 push	 0
  0033d	8b 4d f8	 mov	 ecx, DWORD PTR _ntStatus$[ebp]
  00340	51		 push	 ecx
  00341	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  00344	52		 push	 edx
  00345	e8 00 00 00 00	 call	 _TCCompleteIrp@12
  0034a	e9 aa 00 00 00	 jmp	 $LN36@TCDispatch
$LN4@TCDispatch:

; 323  : 
; 324  : 			IoMarkIrpPending (Irp);

  0034f	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00352	50		 push	 eax
  00353	e8 00 00 00 00	 call	 _IoMarkIrpPending@4

; 325  : 			
; 326  : 			ExInterlockedInsertTailList (&Extension->ListEntry, &Irp->Tail.Overlay.ListEntry, &Extension->ListSpinLock);

  00358	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0035b	83 c1 34	 add	 ecx, 52			; 00000034H
  0035e	51		 push	 ecx
  0035f	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  00362	83 c2 58	 add	 edx, 88			; 00000058H
  00365	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00368	83 c1 38	 add	 ecx, 56			; 00000038H
  0036b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExfInterlockedInsertTailList@12

; 327  : 			KeReleaseSemaphore (&Extension->RequestSemaphore, IO_DISK_INCREMENT, 1, FALSE);

  00371	6a 00		 push	 0
  00373	6a 01		 push	 1
  00375	6a 01		 push	 1
  00377	8b 55 fc	 mov	 edx, DWORD PTR _Extension$[ebp]
  0037a	83 c2 40	 add	 edx, 64			; 00000040H
  0037d	52		 push	 edx
  0037e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeReleaseSemaphore@16

; 328  : 			
; 329  : 			return STATUS_PENDING;

  00384	b8 03 01 00 00	 mov	 eax, 259		; 00000103H
  00389	eb 6e		 jmp	 SHORT $LN36@TCDispatch
$LN3@TCDispatch:

; 330  : 
; 331  : 		case IRP_MJ_FLUSH_BUFFERS:
; 332  : 			return TCCompleteDiskIrp (Irp, STATUS_SUCCESS, 0);

  0038b	6a 00		 push	 0
  0038d	6a 00		 push	 0
  0038f	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00392	50		 push	 eax
  00393	e8 00 00 00 00	 call	 _TCCompleteDiskIrp@12
  00398	eb 5f		 jmp	 SHORT $LN36@TCDispatch
$LN8@TCDispatch:

; 333  : 		}
; 334  : 
; 335  : 		break;

  0039a	eb 4d		 jmp	 SHORT $LN25@TCDispatch
$LN2@TCDispatch:

; 336  : 
; 337  : 	case IRP_MJ_PNP:
; 338  : 		if (!Extension->bRootDevice
; 339  : 			&& Extension->IsVolumeDevice
; 340  : 			&& irpSp->MinorFunction == IRP_MN_DEVICE_USAGE_NOTIFICATION
; 341  : 			&& irpSp->Parameters.UsageNotification.Type == DeviceUsageTypePaging
; 342  : 			&& irpSp->Parameters.UsageNotification.InPath)

  0039c	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0039f	83 39 00	 cmp	 DWORD PTR [ecx], 0
  003a2	75 45		 jne	 SHORT $LN25@TCDispatch
  003a4	8b 55 fc	 mov	 edx, DWORD PTR _Extension$[ebp]
  003a7	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  003ab	74 3c		 je	 SHORT $LN25@TCDispatch
  003ad	8b 45 f4	 mov	 eax, DWORD PTR _irpSp$[ebp]
  003b0	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  003b4	83 f9 16	 cmp	 ecx, 22			; 00000016H
  003b7	75 30		 jne	 SHORT $LN25@TCDispatch
  003b9	8b 55 f4	 mov	 edx, DWORD PTR _irpSp$[ebp]
  003bc	83 7a 08 01	 cmp	 DWORD PTR [edx+8], 1
  003c0	75 27		 jne	 SHORT $LN25@TCDispatch
  003c2	8b 45 f4	 mov	 eax, DWORD PTR _irpSp$[ebp]
  003c5	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  003c9	85 c9		 test	 ecx, ecx
  003cb	74 1c		 je	 SHORT $LN25@TCDispatch

; 343  : 		{
; 344  : 			PagingFileCreationPrevented = TRUE;

  003cd	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _PagingFileCreationPrevented, 1

; 345  : 			return TCCompleteIrp (Irp, STATUS_UNSUCCESSFUL, 0);

  003d7	6a 00		 push	 0
  003d9	68 01 00 00 c0	 push	 -1073741823		; c0000001H
  003de	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  003e1	52		 push	 edx
  003e2	e8 00 00 00 00	 call	 _TCCompleteIrp@12
  003e7	eb 10		 jmp	 SHORT $LN36@TCDispatch
$LN25@TCDispatch:

; 346  : 		}
; 347  : 		break;
; 348  : 	}
; 349  : 
; 350  : 	return TCCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);

  003e9	6a 00		 push	 0
  003eb	68 10 00 00 c0	 push	 -1073741808		; c0000010H
  003f0	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  003f3	50		 push	 eax
  003f4	e8 00 00 00 00	 call	 _TCCompleteIrp@12
$LN36@TCDispatch:

; 351  : }

  003f9	8b e5		 mov	 esp, ebp
  003fb	5d		 pop	 ebp
  003fc	c2 08 00	 ret	 8
  003ff	90		 npad	 1
$LN42@TCDispatch:
  00400	00 00 00 00	 DD	 $LN31@TCDispatch
  00404	00 00 00 00	 DD	 $LN30@TCDispatch
$LN39@TCDispatch:
  00408	00		 DB	 0
  00409	01		 DB	 1
  0040a	01		 DB	 1
  0040b	01		 DB	 1
  0040c	01		 DB	 1
  0040d	01		 DB	 1
  0040e	01		 DB	 1
  0040f	01		 DB	 1
  00410	01		 DB	 1
  00411	01		 DB	 1
  00412	01		 DB	 1
  00413	01		 DB	 1
  00414	00		 DB	 0
  00415	01		 DB	 1
  00416	01		 DB	 1
  00417	01		 DB	 1
  00418	01		 DB	 1
  00419	01		 DB	 1
  0041a	01		 DB	 1
  0041b	01		 DB	 1
  0041c	00		 DB	 0
  0041d	01		 DB	 1
  0041e	01		 DB	 1
  0041f	01		 DB	 1
  00420	00		 DB	 0
  00421	01		 DB	 1
  00422	01		 DB	 1
  00423	01		 DB	 1
  00424	01		 DB	 1
  00425	01		 DB	 1
  00426	01		 DB	 1
  00427	01		 DB	 1
  00428	01		 DB	 1
  00429	01		 DB	 1
  0042a	01		 DB	 1
  0042b	01		 DB	 1
  0042c	00		 DB	 0
  0042d	01		 DB	 1
  0042e	01		 DB	 1
  0042f	01		 DB	 1
  00430	00		 DB	 0
  00431	01		 DB	 1
  00432	01		 DB	 1
  00433	01		 DB	 1
  00434	01		 DB	 1
  00435	01		 DB	 1
  00436	01		 DB	 1
  00437	01		 DB	 1
  00438	01		 DB	 1
  00439	01		 DB	 1
  0043a	01		 DB	 1
  0043b	01		 DB	 1
  0043c	01		 DB	 1
  0043d	01		 DB	 1
  0043e	01		 DB	 1
  0043f	01		 DB	 1
  00440	00		 DB	 0
  00441	01		 DB	 1
  00442	01		 DB	 1
  00443	01		 DB	 1
  00444	01		 DB	 1
  00445	01		 DB	 1
  00446	01		 DB	 1
  00447	01		 DB	 1
  00448	01		 DB	 1
  00449	01		 DB	 1
  0044a	01		 DB	 1
  0044b	01		 DB	 1
  0044c	00		 DB	 0
  0044d	01		 DB	 1
  0044e	01		 DB	 1
  0044f	01		 DB	 1
  00450	00		 DB	 0
  00451	01		 DB	 1
  00452	01		 DB	 1
  00453	01		 DB	 1
  00454	00		 DB	 0
  00455	01		 DB	 1
  00456	01		 DB	 1
  00457	01		 DB	 1
  00458	01		 DB	 1
  00459	01		 DB	 1
  0045a	01		 DB	 1
  0045b	01		 DB	 1
  0045c	01		 DB	 1
  0045d	01		 DB	 1
  0045e	01		 DB	 1
  0045f	01		 DB	 1
  00460	01		 DB	 1
  00461	01		 DB	 1
  00462	01		 DB	 1
  00463	01		 DB	 1
  00464	01		 DB	 1
  00465	01		 DB	 1
  00466	01		 DB	 1
  00467	01		 DB	 1
  00468	00		 DB	 0
  00469	01		 DB	 1
  0046a	01		 DB	 1
  0046b	01		 DB	 1
  0046c	01		 DB	 1
  0046d	01		 DB	 1
  0046e	01		 DB	 1
  0046f	01		 DB	 1
  00470	01		 DB	 1
  00471	01		 DB	 1
  00472	01		 DB	 1
  00473	01		 DB	 1
  00474	00		 DB	 0
  00475	8d 49 00	 npad	 3
$LN43@TCDispatch:
  00478	00 00 00 00	 DD	 $LN24@TCDispatch
  0047c	00 00 00 00	 DD	 $LN15@TCDispatch
  00480	00 00 00 00	 DD	 $LN23@TCDispatch
  00484	00 00 00 00	 DD	 $LN2@TCDispatch
  00488	00 00 00 00	 DD	 $LN25@TCDispatch
$LN40@TCDispatch:
  0048c	00		 DB	 0
  0048d	04		 DB	 4
  0048e	00		 DB	 0
  0048f	01		 DB	 1
  00490	01		 DB	 1
  00491	04		 DB	 4
  00492	04		 DB	 4
  00493	04		 DB	 4
  00494	04		 DB	 4
  00495	01		 DB	 1
  00496	04		 DB	 4
  00497	04		 DB	 4
  00498	04		 DB	 4
  00499	04		 DB	 4
  0049a	01		 DB	 1
  0049b	04		 DB	 4
  0049c	02		 DB	 2
  0049d	04		 DB	 4
  0049e	00		 DB	 0
  0049f	04		 DB	 4
  004a0	04		 DB	 4
  004a1	04		 DB	 4
  004a2	04		 DB	 4
  004a3	04		 DB	 4
  004a4	04		 DB	 4
  004a5	04		 DB	 4
  004a6	04		 DB	 4
  004a7	03		 DB	 3
$LN44@TCDispatch:
  004a8	00 00 00 00	 DD	 $LN7@TCDispatch
  004ac	00 00 00 00	 DD	 $LN3@TCDispatch
  004b0	00 00 00 00	 DD	 $LN5@TCDispatch
  004b4	00 00 00 00	 DD	 $LN8@TCDispatch
$LN41@TCDispatch:
  004b8	00		 DB	 0
  004b9	00		 DB	 0
  004ba	03		 DB	 3
  004bb	03		 DB	 3
  004bc	03		 DB	 3
  004bd	03		 DB	 3
  004be	01		 DB	 1
  004bf	03		 DB	 3
  004c0	03		 DB	 3
  004c1	03		 DB	 3
  004c2	03		 DB	 3
  004c3	02		 DB	 2
_TCDispatchQueueIRP@8 ENDP
; Function compile flags: /Odtp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT _IoMarkIrpPending@4
_TEXT	SEGMENT
tv67 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoMarkIrpPending@4 PROC				; COMDAT

; 23667: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 23668:     IoGetCurrentIrpStackLocation( (Irp) )->Control |= SL_PENDING_RETURNED;

  00006	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _IoGetCurrentIrpStackLocation@4
  0000f	83 c0 03	 add	 eax, 3
  00012	89 45 fc	 mov	 DWORD PTR tv67[ebp], eax
  00015	8b 4d fc	 mov	 ecx, DWORD PTR tv67[ebp]
  00018	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0001b	83 ca 01	 or	 edx, 1
  0001e	8b 45 fc	 mov	 eax, DWORD PTR tv67[ebp]
  00021	88 10		 mov	 BYTE PTR [eax], dl

; 23669: }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
_IoMarkIrpPending@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CN@PMFMKKNC@TCCreateRootDeviceObject?5STATUS_@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0DA@OJGNPLJ@TCCreateRootDeviceObject?5NTSTATU@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0CF@KMOPKHLE@Creating?5root?5device?5nt?$DN?$CFls?5dos?$DN@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0CE@KKOENIAD@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5PASSIVE_LE@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0CA@NGANHIBM@TCCreateRootDeviceObject?5BEGIN?6?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	__$ArrayPad$
EXTRN	__imp__IoRegisterShutdownNotification@4:PROC
EXTRN	__imp__IoDeleteDevice@4:PROC
EXTRN	__imp__IoCreateSymbolicLink@8:PROC
EXTRN	__imp__KeInitializeMutex@8:PROC
EXTRN	__imp__IoCreateDevice@28:PROC
EXTRN	__imp__RtlInitUnicodeString@8:PROC
EXTRN	__imp__KeGetCurrentIrql@0:PROC
;	COMDAT ??_C@_0CN@PMFMKKNC@TCCreateRootDeviceObject?5STATUS_@PBOPGDP@
; File c:\users\public\desktop\projects\ciphershed\src\driver\ntdriver.c
INIT$s	SEGMENT
??_C@_0CN@PMFMKKNC@TCCreateRootDeviceObject?5STATUS_@PBOPGDP@ DB 'TCCreat'
	DB	'eRootDeviceObject STATUS_SUCCESS END', 0aH, 00H ;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0DA@OJGNPLJ@TCCreateRootDeviceObject?5NTSTATU@PBOPGDP@
INIT$s	SEGMENT
??_C@_0DA@OJGNPLJ@TCCreateRootDeviceObject?5NTSTATU@PBOPGDP@ DB 'TCCreate'
	DB	'RootDeviceObject NTSTATUS = 0x%08x END', 0aH, 00H ;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0CF@KMOPKHLE@Creating?5root?5device?5nt?$DN?$CFls?5dos?$DN@PBOPGDP@
INIT$s	SEGMENT
??_C@_0CF@KMOPKHLE@Creating?5root?5device?5nt?$DN?$CFls?5dos?$DN@PBOPGDP@ DB 'C'
	DB	'reating root device nt=%ls dos=%ls', 0aH, 00H ;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'T', 00H, 'r'
	DB	00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r', 00H, 'y', 00H, 'p', 00H
	DB	't', 00H, 00H, 00H				;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0CE@KKOENIAD@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5PASSIVE_LE@PBOPGDP@
INIT$s	SEGMENT
??_C@_0CE@KKOENIAD@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5PASSIVE_LE@PBOPGDP@ DB 'K'
	DB	'eGetCurrentIrql() == PASSIVE_LEVEL', 00H	;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@PBOPGDP@
INIT$s	SEGMENT
??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@PBOPGDP@ DB 'c:\'
	DB	'users\public\desktop\projects\ciphershed\src\driver\ntdriver.'
	DB	'c', 00H					;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0CA@NGANHIBM@TCCreateRootDeviceObject?5BEGIN?6?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_0CA@NGANHIBM@TCCreateRootDeviceObject?5BEGIN?6?$AA@PBOPGDP@ DB 'TCC'
	DB	'reateRootDeviceObject BEGIN', 0aH, 00H	;  ?? ::PBOPGDP::`string'
; Function compile flags: /Odtp
INIT$s	ENDS
;	COMDAT _TCCreateRootDeviceObject@4
INIT	SEGMENT
tv85 = -198						; size = 2
tv84 = -196						; size = 4
tv83 = -192						; size = 4
tv82 = -188						; size = 4
tv77 = -182						; size = 2
tv76 = -180						; size = 4
tv75 = -176						; size = 4
tv74 = -172						; size = 4
tv72 = -168						; size = 4
_ntStatus$ = -164					; size = 4
_dosname$ = -160					; size = 64
_DeviceObject$ = -96					; size = 4
_Win32NameString$ = -92					; size = 8
_bRootExtension$ = -84					; size = 4
_ntname$ = -80						; size = 64
__$ArrayPad$ = -12					; size = 4
_ntUnicodeString$ = -8					; size = 8
_DriverObject$ = 8					; size = 4
_TCCreateRootDeviceObject@4 PROC			; COMDAT

; 354  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 f4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 355  : 	UNICODE_STRING Win32NameString, ntUnicodeString;
; 356  : 	WCHAR dosname[32], ntname[32];
; 357  : 	PDEVICE_OBJECT DeviceObject;
; 358  : 	NTSTATUS ntStatus;
; 359  : 	BOOL *bRootExtension;
; 360  : 
; 361  : 	Dump ("TCCreateRootDeviceObject BEGIN\n");

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NGANHIBM@TCCreateRootDeviceObject?5BEGIN?6?$AA@PBOPGDP@
  0001a	e8 00 00 00 00	 call	 _DbgPrint
  0001f	83 c4 04	 add	 esp, 4

; 362  : 	ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeGetCurrentIrql@0
  00028	0f b6 c0	 movzx	 eax, al
  0002b	85 c0		 test	 eax, eax
  0002d	74 23		 je	 SHORT $LN5@TCCreateRo
  0002f	6a 00		 push	 0
  00031	68 6a 01 00 00	 push	 362			; 0000016aH
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@PBOPGDP@
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@KKOENIAD@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5PASSIVE_LE@PBOPGDP@
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  00046	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv72[ebp], 0
  00050	eb 0a		 jmp	 SHORT $LN6@TCCreateRo
$LN5@TCCreateRo:
  00052	c7 85 58 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv72[ebp], 1
$LN6@TCCreateRo:

; 363  : 
; 364  : 	wcscpy (dosname, (LPWSTR) DOS_ROOT_PREFIX);

  0005c	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv74[ebp], OFFSET ??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@
  00066	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _dosname$[ebp]
  0006c	89 8d 50 ff ff
	ff		 mov	 DWORD PTR tv75[ebp], ecx
  00072	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR tv75[ebp]
  00078	89 95 4c ff ff
	ff		 mov	 DWORD PTR tv76[ebp], edx
$LN7@TCCreateRo:
  0007e	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR tv74[ebp]
  00084	66 8b 08	 mov	 cx, WORD PTR [eax]
  00087	66 89 8d 4a ff
	ff ff		 mov	 WORD PTR tv77[ebp], cx
  0008e	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR tv75[ebp]
  00094	66 8b 85 4a ff
	ff ff		 mov	 ax, WORD PTR tv77[ebp]
  0009b	66 89 02	 mov	 WORD PTR [edx], ax
  0009e	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR tv74[ebp]
  000a4	83 c1 02	 add	 ecx, 2
  000a7	89 8d 54 ff ff
	ff		 mov	 DWORD PTR tv74[ebp], ecx
  000ad	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR tv75[ebp]
  000b3	83 c2 02	 add	 edx, 2
  000b6	89 95 50 ff ff
	ff		 mov	 DWORD PTR tv75[ebp], edx
  000bc	66 83 bd 4a ff
	ff ff 00	 cmp	 WORD PTR tv77[ebp], 0
  000c4	75 b8		 jne	 SHORT $LN7@TCCreateRo

; 365  : 	wcscpy (ntname, (LPWSTR) NT_ROOT_PREFIX);

  000c6	c7 85 44 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv82[ebp], OFFSET ??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@
  000d0	8d 45 b0	 lea	 eax, DWORD PTR _ntname$[ebp]
  000d3	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv83[ebp], eax
  000d9	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR tv83[ebp]
  000df	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv84[ebp], ecx
$LN8@TCCreateRo:
  000e5	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR tv82[ebp]
  000eb	66 8b 02	 mov	 ax, WORD PTR [edx]
  000ee	66 89 85 3a ff
	ff ff		 mov	 WORD PTR tv85[ebp], ax
  000f5	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR tv83[ebp]
  000fb	66 8b 95 3a ff
	ff ff		 mov	 dx, WORD PTR tv85[ebp]
  00102	66 89 11	 mov	 WORD PTR [ecx], dx
  00105	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR tv82[ebp]
  0010b	83 c0 02	 add	 eax, 2
  0010e	89 85 44 ff ff
	ff		 mov	 DWORD PTR tv82[ebp], eax
  00114	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR tv83[ebp]
  0011a	83 c1 02	 add	 ecx, 2
  0011d	89 8d 40 ff ff
	ff		 mov	 DWORD PTR tv83[ebp], ecx
  00123	66 83 bd 3a ff
	ff ff 00	 cmp	 WORD PTR tv85[ebp], 0
  0012b	75 b8		 jne	 SHORT $LN8@TCCreateRo

; 366  : 	RtlInitUnicodeString (&ntUnicodeString, ntname);

  0012d	8d 55 b0	 lea	 edx, DWORD PTR _ntname$[ebp]
  00130	52		 push	 edx
  00131	8d 45 f8	 lea	 eax, DWORD PTR _ntUnicodeString$[ebp]
  00134	50		 push	 eax
  00135	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 367  : 	RtlInitUnicodeString (&Win32NameString, dosname);

  0013b	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _dosname$[ebp]
  00141	51		 push	 ecx
  00142	8d 55 a4	 lea	 edx, DWORD PTR _Win32NameString$[ebp]
  00145	52		 push	 edx
  00146	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 368  : 
; 369  : 	Dump ("Creating root device nt=%ls dos=%ls\n", ntname, dosname);

  0014c	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _dosname$[ebp]
  00152	50		 push	 eax
  00153	8d 4d b0	 lea	 ecx, DWORD PTR _ntname$[ebp]
  00156	51		 push	 ecx
  00157	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@KMOPKHLE@Creating?5root?5device?5nt?$DN?$CFls?5dos?$DN@PBOPGDP@
  0015c	e8 00 00 00 00	 call	 _DbgPrint
  00161	83 c4 0c	 add	 esp, 12			; 0000000cH

; 370  : 	
; 371  : 	ntStatus = IoCreateDevice (
; 372  : 					  DriverObject,
; 373  : 					  sizeof (BOOL),
; 374  : 					  &ntUnicodeString,
; 375  : 					  FILE_DEVICE_UNKNOWN,
; 376  : 					  FILE_DEVICE_SECURE_OPEN,
; 377  : 					  FALSE,
; 378  : 					  &DeviceObject);

  00164	8d 55 a0	 lea	 edx, DWORD PTR _DeviceObject$[ebp]
  00167	52		 push	 edx
  00168	6a 00		 push	 0
  0016a	68 00 01 00 00	 push	 256			; 00000100H
  0016f	6a 22		 push	 34			; 00000022H
  00171	8d 45 f8	 lea	 eax, DWORD PTR _ntUnicodeString$[ebp]
  00174	50		 push	 eax
  00175	6a 04		 push	 4
  00177	8b 4d 08	 mov	 ecx, DWORD PTR _DriverObject$[ebp]
  0017a	51		 push	 ecx
  0017b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoCreateDevice@28
  00181	89 85 5c ff ff
	ff		 mov	 DWORD PTR _ntStatus$[ebp], eax

; 379  : 
; 380  : 	if (!NT_SUCCESS (ntStatus))

  00187	83 bd 5c ff ff
	ff 00		 cmp	 DWORD PTR _ntStatus$[ebp], 0
  0018e	7d 1f		 jge	 SHORT $LN2@TCCreateRo

; 381  : 	{
; 382  : 		Dump ("TCCreateRootDeviceObject NTSTATUS = 0x%08x END\n", ntStatus);

  00190	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _ntStatus$[ebp]
  00196	52		 push	 edx
  00197	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@OJGNPLJ@TCCreateRootDeviceObject?5NTSTATU@PBOPGDP@
  0019c	e8 00 00 00 00	 call	 _DbgPrint
  001a1	83 c4 08	 add	 esp, 8

; 383  : 		return ntStatus;/* Failed to create DeviceObject */

  001a4	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _ntStatus$[ebp]
  001aa	e9 9c 00 00 00	 jmp	 $LN3@TCCreateRo
$LN2@TCCreateRo:

; 384  : 	}
; 385  : 
; 386  : 	DeviceObject->Flags |= DO_DIRECT_IO;

  001af	8b 45 a0	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  001b2	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  001b5	83 c9 10	 or	 ecx, 16			; 00000010H
  001b8	8b 55 a0	 mov	 edx, DWORD PTR _DeviceObject$[ebp]
  001bb	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 387  : 	DeviceObject->AlignmentRequirement = FILE_WORD_ALIGNMENT;

  001be	8b 45 a0	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  001c1	c7 40 5c 01 00
	00 00		 mov	 DWORD PTR [eax+92], 1

; 388  : 
; 389  : 	/* Setup the device extension */
; 390  : 	bRootExtension = (BOOL *) DeviceObject->DeviceExtension;

  001c8	8b 4d a0	 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  001cb	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  001ce	89 55 ac	 mov	 DWORD PTR _bRootExtension$[ebp], edx

; 391  : 	*bRootExtension = TRUE;

  001d1	8b 45 ac	 mov	 eax, DWORD PTR _bRootExtension$[ebp]
  001d4	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 392  : 
; 393  : 	KeInitializeMutex (&RootDeviceControlMutex, 0);

  001da	6a 00		 push	 0
  001dc	68 00 00 00 00	 push	 OFFSET _RootDeviceControlMutex
  001e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeMutex@8

; 394  : 
; 395  : 	ntStatus = IoCreateSymbolicLink (&Win32NameString, &ntUnicodeString);

  001e7	8d 4d f8	 lea	 ecx, DWORD PTR _ntUnicodeString$[ebp]
  001ea	51		 push	 ecx
  001eb	8d 55 a4	 lea	 edx, DWORD PTR _Win32NameString$[ebp]
  001ee	52		 push	 edx
  001ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoCreateSymbolicLink@8
  001f5	89 85 5c ff ff
	ff		 mov	 DWORD PTR _ntStatus$[ebp], eax

; 396  : 
; 397  : 	if (!NT_SUCCESS (ntStatus))

  001fb	83 bd 5c ff ff
	ff 00		 cmp	 DWORD PTR _ntStatus$[ebp], 0
  00202	7d 26		 jge	 SHORT $LN1@TCCreateRo

; 398  : 	{
; 399  : 		Dump ("TCCreateRootDeviceObject NTSTATUS = 0x%08x END\n", ntStatus);

  00204	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _ntStatus$[ebp]
  0020a	50		 push	 eax
  0020b	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@OJGNPLJ@TCCreateRootDeviceObject?5NTSTATU@PBOPGDP@
  00210	e8 00 00 00 00	 call	 _DbgPrint
  00215	83 c4 08	 add	 esp, 8

; 400  : 		IoDeleteDevice (DeviceObject);

  00218	8b 4d a0	 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  0021b	51		 push	 ecx
  0021c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteDevice@4

; 401  : 		return ntStatus;

  00222	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _ntStatus$[ebp]
  00228	eb 21		 jmp	 SHORT $LN3@TCCreateRo
$LN1@TCCreateRo:

; 402  : 	}
; 403  : 
; 404  : 	IoRegisterShutdownNotification (DeviceObject);

  0022a	8b 55 a0	 mov	 edx, DWORD PTR _DeviceObject$[ebp]
  0022d	52		 push	 edx
  0022e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoRegisterShutdownNotification@4

; 405  : 	RootDeviceObject = DeviceObject;

  00234	8b 45 a0	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00237	a3 00 00 00 00	 mov	 DWORD PTR _RootDeviceObject, eax

; 406  : 
; 407  : 	Dump ("TCCreateRootDeviceObject STATUS_SUCCESS END\n");

  0023c	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@PMFMKKNC@TCCreateRootDeviceObject?5STATUS_@PBOPGDP@
  00241	e8 00 00 00 00	 call	 _DbgPrint
  00246	83 c4 04	 add	 esp, 4

; 408  : 	return STATUS_SUCCESS;

  00249	33 c0		 xor	 eax, eax
$LN3@TCCreateRo:

; 409  : }

  0024b	8b 4d f4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0024e	33 cd		 xor	 ecx, ebp
  00250	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00255	8b e5		 mov	 esp, ebp
  00257	5d		 pop	 ebp
  00258	c2 04 00	 ret	 4
_TCCreateRootDeviceObject@4 ENDP
INIT	ENDS
PUBLIC	??_C@_0CJ@CAANMOOG@TCCreateDeviceObject?5STATUS_SUCC@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_InitializeListHead@4
PUBLIC	_KeInitializeSpinLock@4
PUBLIC	??_C@_0CM@DAAJFNOI@TCCreateDeviceObject?5NTSTATUS?5?$DN?5@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CA@MBKOBJGH@Creating?5device?5nt?$DN?$CFls?5dos?$DN?$CFls?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_TCGetNTNameFromNumber@8
PUBLIC	_TCGetDosNameFromNumber@8
PUBLIC	??_C@_0CE@KKOENIAD@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5PASSIVE_LE@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BM@HAIECJHN@TCCreateDeviceObject?5BEGIN?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	__$ArrayPad$
PUBLIC	_TCCreateDeviceObject@12
EXTRN	__imp__IoInitializeRemoveLockEx@20:PROC
EXTRN	__imp__KeInitializeSemaphore@12:PROC
EXTRN	__imp__KeInitializeEvent@12:PROC
;	COMDAT ??_C@_0CJ@CAANMOOG@TCCreateDeviceObject?5STATUS_SUCC@FNODOBFM@
text$s	SEGMENT
??_C@_0CJ@CAANMOOG@TCCreateDeviceObject?5STATUS_SUCC@FNODOBFM@ DB 'TCCrea'
	DB	'teDeviceObject STATUS_SUCCESS END', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CM@DAAJFNOI@TCCreateDeviceObject?5NTSTATUS?5?$DN?5@FNODOBFM@
text$s	SEGMENT
??_C@_0CM@DAAJFNOI@TCCreateDeviceObject?5NTSTATUS?5?$DN?5@FNODOBFM@ DB 'T'
	DB	'CCreateDeviceObject NTSTATUS = 0x%08x END', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CA@MBKOBJGH@Creating?5device?5nt?$DN?$CFls?5dos?$DN?$CFls?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0CA@MBKOBJGH@Creating?5device?5nt?$DN?$CFls?5dos?$DN?$CFls?6?$AA@FNODOBFM@ DB 'C'
	DB	'reating device nt=%ls dos=%ls', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CE@KKOENIAD@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5PASSIVE_LE@FNODOBFM@
text$s	SEGMENT
??_C@_0CE@KKOENIAD@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5PASSIVE_LE@FNODOBFM@ DB 'K'
	DB	'eGetCurrentIrql() == PASSIVE_LEVEL', 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BM@HAIECJHN@TCCreateDeviceObject?5BEGIN?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BM@HAIECJHN@TCCreateDeviceObject?5BEGIN?6?$AA@FNODOBFM@ DB 'TCCrea'
	DB	'teDeviceObject BEGIN', 0aH, 00H		;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _TCCreateDeviceObject@12
_TEXT	SEGMENT
tv72 = -168						; size = 4
_ntStatus$ = -164					; size = 4
_dosname$ = -160					; size = 64
_Win32NameString$ = -92					; size = 8
_Extension$ = -84					; size = 4
_ntname$ = -80						; size = 64
__$ArrayPad$ = -16					; size = 4
_ntUnicodeString$ = -12					; size = 8
_devChars$ = -4						; size = 4
_DriverObject$ = 8					; size = 4
_ppDeviceObject$ = 12					; size = 4
_mount$ = 16						; size = 4
_TCCreateDeviceObject@12 PROC				; COMDAT

; 414  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 415  : 	UNICODE_STRING Win32NameString, ntUnicodeString;
; 416  : 	WCHAR dosname[32], ntname[32];
; 417  : 	PEXTENSION Extension;
; 418  : 	NTSTATUS ntStatus;
; 419  : 	ULONG devChars = 0;

  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _devChars$[ebp], 0

; 420  : 
; 421  : 	Dump ("TCCreateDeviceObject BEGIN\n");

  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@HAIECJHN@TCCreateDeviceObject?5BEGIN?6?$AA@FNODOBFM@
  00021	e8 00 00 00 00	 call	 _DbgPrint
  00026	83 c4 04	 add	 esp, 4

; 422  : 	ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeGetCurrentIrql@0
  0002f	0f b6 c0	 movzx	 eax, al
  00032	85 c0		 test	 eax, eax
  00034	74 23		 je	 SHORT $LN4@TCCreateDe
  00036	6a 00		 push	 0
  00038	68 a6 01 00 00	 push	 422			; 000001a6H
  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@KKOENIAD@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5PASSIVE_LE@FNODOBFM@
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  0004d	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv72[ebp], 0
  00057	eb 0a		 jmp	 SHORT $LN5@TCCreateDe
$LN4@TCCreateDe:
  00059	c7 85 58 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv72[ebp], 1
$LN5@TCCreateDe:

; 423  : 
; 424  : 	TCGetDosNameFromNumber (dosname, mount->nDosDriveNo);

  00063	8b 4d 10	 mov	 ecx, DWORD PTR _mount$[ebp]
  00066	8b 91 64 02 00
	00		 mov	 edx, DWORD PTR [ecx+612]
  0006c	52		 push	 edx
  0006d	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _dosname$[ebp]
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 _TCGetDosNameFromNumber@8

; 425  : 	TCGetNTNameFromNumber (ntname, mount->nDosDriveNo);

  00079	8b 4d 10	 mov	 ecx, DWORD PTR _mount$[ebp]
  0007c	8b 91 64 02 00
	00		 mov	 edx, DWORD PTR [ecx+612]
  00082	52		 push	 edx
  00083	8d 45 b0	 lea	 eax, DWORD PTR _ntname$[ebp]
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 _TCGetNTNameFromNumber@8

; 426  : 	RtlInitUnicodeString (&ntUnicodeString, ntname);

  0008c	8d 4d b0	 lea	 ecx, DWORD PTR _ntname$[ebp]
  0008f	51		 push	 ecx
  00090	8d 55 f4	 lea	 edx, DWORD PTR _ntUnicodeString$[ebp]
  00093	52		 push	 edx
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 427  : 	RtlInitUnicodeString (&Win32NameString, dosname);

  0009a	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _dosname$[ebp]
  000a0	50		 push	 eax
  000a1	8d 4d a4	 lea	 ecx, DWORD PTR _Win32NameString$[ebp]
  000a4	51		 push	 ecx
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 428  : 
; 429  : 	devChars = FILE_DEVICE_SECURE_OPEN;

  000ab	c7 45 fc 00 01
	00 00		 mov	 DWORD PTR _devChars$[ebp], 256 ; 00000100H

; 430  : 	devChars |= mount->bMountReadOnly ? FILE_READ_ONLY_DEVICE : 0;

  000b2	8b 55 10	 mov	 edx, DWORD PTR _mount$[ebp]
  000b5	8b 82 6c 02 00
	00		 mov	 eax, DWORD PTR [edx+620]
  000bb	f7 d8		 neg	 eax
  000bd	1b c0		 sbb	 eax, eax
  000bf	83 e0 02	 and	 eax, 2
  000c2	0b 45 fc	 or	 eax, DWORD PTR _devChars$[ebp]
  000c5	89 45 fc	 mov	 DWORD PTR _devChars$[ebp], eax

; 431  : 	devChars |= mount->bMountRemovable ? FILE_REMOVABLE_MEDIA : 0;

  000c8	8b 4d 10	 mov	 ecx, DWORD PTR _mount$[ebp]
  000cb	33 d2		 xor	 edx, edx
  000cd	83 b9 70 02 00
	00 00		 cmp	 DWORD PTR [ecx+624], 0
  000d4	0f 95 c2	 setne	 dl
  000d7	0b 55 fc	 or	 edx, DWORD PTR _devChars$[ebp]
  000da	89 55 fc	 mov	 DWORD PTR _devChars$[ebp], edx

; 432  : 
; 433  : 	Dump ("Creating device nt=%ls dos=%ls\n", ntname, dosname);

  000dd	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _dosname$[ebp]
  000e3	50		 push	 eax
  000e4	8d 4d b0	 lea	 ecx, DWORD PTR _ntname$[ebp]
  000e7	51		 push	 ecx
  000e8	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@MBKOBJGH@Creating?5device?5nt?$DN?$CFls?5dos?$DN?$CFls?6?$AA@FNODOBFM@
  000ed	e8 00 00 00 00	 call	 _DbgPrint
  000f2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 434  : 
; 435  : 	ntStatus = IoCreateDevice (
; 436  : 					  DriverObject,			/* Our Driver Object */
; 437  : 					  sizeof (EXTENSION),	/* Size of state information */
; 438  : 					  &ntUnicodeString,		/* Device name "\Device\Name" */
; 439  : 					  FILE_DEVICE_DISK,		/* Device type */
; 440  : 					  devChars,				/* Device characteristics */
; 441  : 					  FALSE,				/* Exclusive device */
; 442  : 					  ppDeviceObject);		/* Returned ptr to Device Object */

  000f5	8b 55 0c	 mov	 edx, DWORD PTR _ppDeviceObject$[ebp]
  000f8	52		 push	 edx
  000f9	6a 00		 push	 0
  000fb	8b 45 fc	 mov	 eax, DWORD PTR _devChars$[ebp]
  000fe	50		 push	 eax
  000ff	6a 07		 push	 7
  00101	8d 4d f4	 lea	 ecx, DWORD PTR _ntUnicodeString$[ebp]
  00104	51		 push	 ecx
  00105	68 10 05 00 00	 push	 1296			; 00000510H
  0010a	8b 55 08	 mov	 edx, DWORD PTR _DriverObject$[ebp]
  0010d	52		 push	 edx
  0010e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoCreateDevice@28
  00114	89 85 5c ff ff
	ff		 mov	 DWORD PTR _ntStatus$[ebp], eax

; 443  : 
; 444  : 	if (!NT_SUCCESS (ntStatus))

  0011a	83 bd 5c ff ff
	ff 00		 cmp	 DWORD PTR _ntStatus$[ebp], 0
  00121	7d 1f		 jge	 SHORT $LN1@TCCreateDe

; 445  : 	{
; 446  : 		Dump ("TCCreateDeviceObject NTSTATUS = 0x%08x END\n", ntStatus);

  00123	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _ntStatus$[ebp]
  00129	50		 push	 eax
  0012a	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@DAAJFNOI@TCCreateDeviceObject?5NTSTATUS?5?$DN?5@FNODOBFM@
  0012f	e8 00 00 00 00	 call	 _DbgPrint
  00134	83 c4 08	 add	 esp, 8

; 447  : 		return ntStatus;/* Failed to create DeviceObject */

  00137	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _ntStatus$[ebp]
  0013d	e9 10 01 00 00	 jmp	 $LN2@TCCreateDe
$LN1@TCCreateDe:

; 448  : 	}
; 449  : 	/* Initialize device object and extension. */
; 450  : 
; 451  : 	(*ppDeviceObject)->Flags |= DO_DIRECT_IO;

  00142	8b 4d 0c	 mov	 ecx, DWORD PTR _ppDeviceObject$[ebp]
  00145	8b 11		 mov	 edx, DWORD PTR [ecx]
  00147	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0014a	83 c8 10	 or	 eax, 16			; 00000010H
  0014d	8b 4d 0c	 mov	 ecx, DWORD PTR _ppDeviceObject$[ebp]
  00150	8b 11		 mov	 edx, DWORD PTR [ecx]
  00152	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 452  : 	(*ppDeviceObject)->StackSize += 6;		// Reduce occurrence of NO_MORE_IRP_STACK_LOCATIONS bug check caused by buggy drivers

  00155	8b 45 0c	 mov	 eax, DWORD PTR _ppDeviceObject$[ebp]
  00158	8b 08		 mov	 ecx, DWORD PTR [eax]
  0015a	0f be 51 30	 movsx	 edx, BYTE PTR [ecx+48]
  0015e	83 c2 06	 add	 edx, 6
  00161	8b 45 0c	 mov	 eax, DWORD PTR _ppDeviceObject$[ebp]
  00164	8b 08		 mov	 ecx, DWORD PTR [eax]
  00166	88 51 30	 mov	 BYTE PTR [ecx+48], dl

; 453  : 
; 454  : 	/* Setup the device extension */
; 455  : 	Extension = (PEXTENSION) (*ppDeviceObject)->DeviceExtension;

  00169	8b 55 0c	 mov	 edx, DWORD PTR _ppDeviceObject$[ebp]
  0016c	8b 02		 mov	 eax, DWORD PTR [edx]
  0016e	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00171	89 4d ac	 mov	 DWORD PTR _Extension$[ebp], ecx

; 456  : 	memset (Extension, 0, sizeof (EXTENSION));

  00174	68 10 05 00 00	 push	 1296			; 00000510H
  00179	6a 00		 push	 0
  0017b	8b 55 ac	 mov	 edx, DWORD PTR _Extension$[ebp]
  0017e	52		 push	 edx
  0017f	e8 00 00 00 00	 call	 _memset
  00184	83 c4 0c	 add	 esp, 12			; 0000000cH

; 457  : 
; 458  : 	Extension->IsVolumeDevice = TRUE;

  00187	8b 45 ac	 mov	 eax, DWORD PTR _Extension$[ebp]
  0018a	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [eax+4], 1

; 459  : 	Extension->nDosDriveNo = mount->nDosDriveNo;

  00191	8b 4d ac	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00194	8b 55 10	 mov	 edx, DWORD PTR _mount$[ebp]
  00197	8b 82 64 02 00
	00		 mov	 eax, DWORD PTR [edx+612]
  0019d	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 460  : 	Extension->bRemovable = mount->bMountRemovable;

  001a0	8b 4d ac	 mov	 ecx, DWORD PTR _Extension$[ebp]
  001a3	8b 55 10	 mov	 edx, DWORD PTR _mount$[ebp]
  001a6	8b 82 70 02 00
	00		 mov	 eax, DWORD PTR [edx+624]
  001ac	89 81 8c 02 00
	00		 mov	 DWORD PTR [ecx+652], eax

; 461  : 	Extension->PartitionInInactiveSysEncScope = mount->bPartitionInInactiveSysEncScope;

  001b2	8b 4d ac	 mov	 ecx, DWORD PTR _Extension$[ebp]
  001b5	8b 55 10	 mov	 edx, DWORD PTR _mount$[ebp]
  001b8	8b 82 80 02 00
	00		 mov	 eax, DWORD PTR [edx+640]
  001be	89 81 90 02 00
	00		 mov	 DWORD PTR [ecx+656], eax

; 462  : 	Extension->SystemFavorite = mount->SystemFavorite;

  001c4	8b 4d ac	 mov	 ecx, DWORD PTR _Extension$[ebp]
  001c7	8b 55 10	 mov	 edx, DWORD PTR _mount$[ebp]
  001ca	8b 82 88 02 00
	00		 mov	 eax, DWORD PTR [edx+648]
  001d0	89 81 9c 02 00
	00		 mov	 DWORD PTR [ecx+668], eax

; 463  : 
; 464  : 	KeInitializeEvent (&Extension->keCreateEvent, SynchronizationEvent, FALSE);

  001d6	6a 00		 push	 0
  001d8	6a 01		 push	 1
  001da	8b 4d ac	 mov	 ecx, DWORD PTR _Extension$[ebp]
  001dd	83 c1 24	 add	 ecx, 36			; 00000024H
  001e0	51		 push	 ecx
  001e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 465  : 	KeInitializeSemaphore (&Extension->RequestSemaphore, 0L, MAXLONG);

  001e7	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  001ec	6a 00		 push	 0
  001ee	8b 55 ac	 mov	 edx, DWORD PTR _Extension$[ebp]
  001f1	83 c2 40	 add	 edx, 64			; 00000040H
  001f4	52		 push	 edx
  001f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeSemaphore@12

; 466  : 	KeInitializeSpinLock (&Extension->ListSpinLock);

  001fb	8b 45 ac	 mov	 eax, DWORD PTR _Extension$[ebp]
  001fe	83 c0 34	 add	 eax, 52			; 00000034H
  00201	50		 push	 eax
  00202	e8 00 00 00 00	 call	 _KeInitializeSpinLock@4

; 467  : 	InitializeListHead (&Extension->ListEntry);

  00207	8b 4d ac	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0020a	83 c1 38	 add	 ecx, 56			; 00000038H
  0020d	51		 push	 ecx
  0020e	e8 00 00 00 00	 call	 _InitializeListHead@4

; 468  : 	IoInitializeRemoveLock (&Extension->Queue.RemoveLock, 'LRCT', 0, 0);

  00213	6a 58		 push	 88			; 00000058H
  00215	6a 00		 push	 0
  00217	6a 00		 push	 0
  00219	68 54 43 52 4c	 push	 1280459604		; 4c524354H
  0021e	8b 55 ac	 mov	 edx, DWORD PTR _Extension$[ebp]
  00221	81 c2 18 01 00
	00		 add	 edx, 280		; 00000118H
  00227	52		 push	 edx
  00228	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoInitializeRemoveLockEx@20

; 469  : 
; 470  : 	VirtualVolumeDeviceObjects[mount->nDosDriveNo] = *ppDeviceObject;

  0022e	8b 45 10	 mov	 eax, DWORD PTR _mount$[ebp]
  00231	8b 88 64 02 00
	00		 mov	 ecx, DWORD PTR [eax+612]
  00237	8b 55 0c	 mov	 edx, DWORD PTR _ppDeviceObject$[ebp]
  0023a	8b 02		 mov	 eax, DWORD PTR [edx]
  0023c	89 04 8d 00 00
	00 00		 mov	 DWORD PTR _VirtualVolumeDeviceObjects[ecx*4], eax

; 471  : 
; 472  : 	Dump ("TCCreateDeviceObject STATUS_SUCCESS END\n");

  00243	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@CAANMOOG@TCCreateDeviceObject?5STATUS_SUCC@FNODOBFM@
  00248	e8 00 00 00 00	 call	 _DbgPrint
  0024d	83 c4 04	 add	 esp, 4

; 473  : 
; 474  : 	return STATUS_SUCCESS;

  00250	33 c0		 xor	 eax, eax
$LN2@TCCreateDe:

; 475  : }

  00252	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00255	33 cd		 xor	 ecx, ebp
  00257	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0025c	8b e5		 mov	 esp, ebp
  0025e	5d		 pop	 ebp
  0025f	c2 0c 00	 ret	 12			; 0000000cH
_TCCreateDeviceObject@12 ENDP
; Function compile flags: /Odtp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT _InitializeListHead@4
_TEXT	SEGMENT
_ListHead$ = 8						; size = 4
_InitializeListHead@4 PROC				; COMDAT

; 7550 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 7551 :     ListHead->Flink = ListHead->Blink = ListHead;

  00005	8b 45 08	 mov	 eax, DWORD PTR _ListHead$[ebp]
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _ListHead$[ebp]
  0000b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0000e	8b 55 08	 mov	 edx, DWORD PTR _ListHead$[ebp]
  00011	8b 45 08	 mov	 eax, DWORD PTR _ListHead$[ebp]
  00014	89 02		 mov	 DWORD PTR [edx], eax

; 7552 : }

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
_InitializeListHead@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _KeInitializeSpinLock@4
_TEXT	SEGMENT
_SpinLock$ = 8						; size = 4
_KeInitializeSpinLock@4 PROC				; COMDAT

; 15095: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 15096: 
; 15097:     *SpinLock = 0;

  00005	8b 45 08	 mov	 eax, DWORD PTR _SpinLock$[ebp]
  00008	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 15098:     return;
; 15099: }

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
_KeInitializeSpinLock@4 ENDP
_TEXT	ENDS
PUBLIC	_RootDeviceControlMutexAcquireNoWait@0
; Function compile flags: /Odtp
; File c:\users\public\desktop\projects\ciphershed\src\driver\ntdriver.c
;	COMDAT _RootDeviceControlMutexAcquireNoWait@0
_TEXT	SEGMENT
tv72 = -20						; size = 4
_timeout$ = -16						; size = 8
_status$ = -4						; size = 4
_RootDeviceControlMutexAcquireNoWait@0 PROC		; COMDAT

; 479  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 14	 sub	 esp, 20			; 00000014H

; 480  : 	NTSTATUS status;
; 481  : 	LARGE_INTEGER timeout;
; 482  : 	timeout.QuadPart = 0;

  00008	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _timeout$[ebp], 0
  0000f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _timeout$[ebp+4], 0

; 483  : 
; 484  : 	status = KeWaitForMutexObject (&RootDeviceControlMutex, Executive, KernelMode, FALSE, &timeout);

  00016	8d 45 f0	 lea	 eax, DWORD PTR _timeout$[ebp]
  00019	50		 push	 eax
  0001a	6a 00		 push	 0
  0001c	6a 00		 push	 0
  0001e	6a 00		 push	 0
  00020	68 00 00 00 00	 push	 OFFSET _RootDeviceControlMutex
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
  0002b	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 485  : 	return NT_SUCCESS (status) && status != STATUS_TIMEOUT;

  0002e	83 7d fc 00	 cmp	 DWORD PTR _status$[ebp], 0
  00032	7c 12		 jl	 SHORT $LN3@RootDevice
  00034	81 7d fc 02 01
	00 00		 cmp	 DWORD PTR _status$[ebp], 258 ; 00000102H
  0003b	74 09		 je	 SHORT $LN3@RootDevice
  0003d	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv72[ebp], 1
  00044	eb 07		 jmp	 SHORT $LN4@RootDevice
$LN3@RootDevice:
  00046	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
$LN4@RootDevice:
  0004d	8b 45 ec	 mov	 eax, DWORD PTR tv72[ebp]

; 486  : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
_RootDeviceControlMutexAcquireNoWait@0 ENDP
_TEXT	ENDS
PUBLIC	_RootDeviceControlMutexRelease@0
; Function compile flags: /Odtp
;	COMDAT _RootDeviceControlMutexRelease@0
_TEXT	SEGMENT
_RootDeviceControlMutexRelease@0 PROC			; COMDAT

; 490  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 491  : 	KeReleaseMutex (&RootDeviceControlMutex, FALSE);

  00005	6a 00		 push	 0
  00007	68 00 00 00 00	 push	 OFFSET _RootDeviceControlMutex
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeReleaseMutex@8

; 492  : }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
_RootDeviceControlMutexRelease@0 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@BEMMNDOD@IOCTL?5error?50x?$CF08x?5?$CI0x?$CFx?5?$CFd?$CJ?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0M@HABEOOKA@link?5?$DN?5?$CFls?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_08DALLBBIL@id?5?$DN?5?$CFs?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0M@FBJPBOL@name?5?$DN?5?$CFls?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	__$ArrayPad$
PUBLIC	_ProcessVolumeDeviceControlIrp@12
EXTRN	__imp__ZwReadFile@36:PROC
EXTRN	__imp__ExAllocatePoolWithTag@12:PROC
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_0BO@BEMMNDOD@IOCTL?5error?50x?$CF08x?5?$CI0x?$CFx?5?$CFd?$CJ?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BO@BEMMNDOD@IOCTL?5error?50x?$CF08x?5?$CI0x?$CFx?5?$CFd?$CJ?6?$AA@FNODOBFM@ DB 'I'
	DB	'OCTL error 0x%08x (0x%x %d)', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0M@HABEOOKA@link?5?$DN?5?$CFls?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0M@HABEOOKA@link?5?$DN?5?$CFls?6?$AA@FNODOBFM@ DB 'link = %ls', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_08DALLBBIL@id?5?$DN?5?$CFs?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_08DALLBBIL@id?5?$DN?5?$CFs?6?$AA@FNODOBFM@ DB 'id = %s', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@FNODOBFM@ DB 'TrueCryptVolume', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0M@FBJPBOL@name?5?$DN?5?$CFls?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0M@FBJPBOL@name?5?$DN?5?$CFls?6?$AA@FNODOBFM@ DB 'name = %ls', 0aH, 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _ProcessVolumeDeviceControlIrp@12
_TEXT	SEGMENT
tv350 = -1364						; size = 8
tv337 = -1356						; size = 4
tv721 = -1352						; size = 4
tv718 = -1348						; size = 8
tv164 = -1340						; size = 4
tv554 = -1333						; size = 1
tv551 = -1332						; size = 4
tv548 = -1328						; size = 4
tv155 = -1324						; size = 4
tv538 = -1317						; size = 1
tv535 = -1316						; size = 4
tv532 = -1312						; size = 4
tv151 = -1308						; size = 4
tv525 = -1301						; size = 1
tv522 = -1300						; size = 4
tv519 = -1296						; size = 4
tv504 = -1289						; size = 1
tv501 = -1288						; size = 4
tv498 = -1284						; size = 4
tv497 = -1280						; size = 4
tv492 = -1273						; size = 1
tv489 = -1272						; size = 4
tv487 = -1268						; size = 4
tv67 = -1264						; size = 4
_extents$30119 = -1260					; size = 4
_offset$30091 = -1256					; size = 8
_ioStatus$30085 = -1248					; size = 8
_buffer$30086 = -1240					; size = 4
_pVerifyInformation$30080 = -1236			; size = 4
_outputBuffer$30073 = -1232				; size = 4
_outputBuffer$30063 = -1228				; size = 4
_outputBuffer$30056 = -1224				; size = 4
_outputBuffer$30049 = -1220				; size = 4
_outputBuffer$30042 = -1216				; size = 4
_outLength$30022 = -1212				; size = 4
_ntName$30024 = -1208					; size = 512
_outputBuffer$30025 = -696				; size = 4
_ntUnicodeString$30023 = -692				; size = 8
_outLength$30005 = -684					; size = 4
_volId$30006 = -680					; size = 128
_tmp$30007 = -548					; size = 2
_outputBuffer$30008 = -544				; size = 4
_outLength$29987 = -540					; size = 4
_ntName$29989 = -536					; size = 512
__$ArrayPad$ = -20					; size = 4
_outputBuffer$29990 = -16				; size = 4
_ntUnicodeString$29988 = -12				; size = 8
_irpSp$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_Extension$ = 12					; size = 4
_Irp$ = 16						; size = 4
_ProcessVolumeDeviceControlIrp@12 PROC			; COMDAT

; 496  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 54 05 00
	00		 sub	 esp, 1364		; 00000554H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi
  00016	57		 push	 edi

; 497  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);

  00017	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _IoGetCurrentIrpStackLocation@4
  00020	89 45 fc	 mov	 DWORD PTR _irpSp$[ebp], eax

; 498  : 
; 499  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  00026	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00029	89 95 10 fb ff
	ff		 mov	 DWORD PTR tv67[ebp], edx
  0002f	81 bd 10 fb ff
	ff 5c 40 07 00	 cmp	 DWORD PTR tv67[ebp], 475228 ; 0007405cH
  00039	0f 87 96 00 00
	00		 ja	 $LN51@ProcessVol
  0003f	81 bd 10 fb ff
	ff 5c 40 07 00	 cmp	 DWORD PTR tv67[ebp], 475228 ; 0007405cH
  00049	0f 84 2a 08 00
	00		 je	 $LN23@ProcessVol
  0004f	81 bd 10 fb ff
	ff 48 00 07 00	 cmp	 DWORD PTR tv67[ebp], 458824 ; 00070048H
  00059	77 45		 ja	 SHORT $LN52@ProcessVol
  0005b	81 bd 10 fb ff
	ff 48 00 07 00	 cmp	 DWORD PTR tv67[ebp], 458824 ; 00070048H
  00065	0f 84 a0 06 00
	00		 je	 $LN27@ProcessVol
  0006b	81 bd 10 fb ff
	ff 00 00 07 00	 cmp	 DWORD PTR tv67[ebp], 458752 ; 00070000H
  00075	0f 84 51 05 00
	00		 je	 $LN31@ProcessVol
  0007b	81 bd 10 fb ff
	ff 14 00 07 00	 cmp	 DWORD PTR tv67[ebp], 458772 ; 00070014H
  00085	0f 84 4e 08 00
	00		 je	 $LN20@ProcessVol
  0008b	81 bd 10 fb ff
	ff 24 00 07 00	 cmp	 DWORD PTR tv67[ebp], 458788 ; 00070024H
  00095	0f 84 5a 0a 00
	00		 je	 $LN11@ProcessVol
  0009b	e9 25 0b 00 00	 jmp	 $LN2@ProcessVol
$LN52@ProcessVol:
  000a0	81 bd 10 fb ff
	ff 00 0c 07 00	 cmp	 DWORD PTR tv67[ebp], 461824 ; 00070c00H
  000aa	0f 84 1c 05 00
	00		 je	 $LN31@ProcessVol
  000b0	81 bd 10 fb ff
	ff 04 40 07 00	 cmp	 DWORD PTR tv67[ebp], 475140 ; 00074004H
  000ba	0f 84 a9 05 00
	00		 je	 $LN29@ProcessVol
  000c0	81 bd 10 fb ff
	ff 0c 40 07 00	 cmp	 DWORD PTR tv67[ebp], 475148 ; 0007400cH
  000ca	0f 84 ed 06 00
	00		 je	 $LN25@ProcessVol
  000d0	e9 f0 0a 00 00	 jmp	 $LN2@ProcessVol
$LN51@ProcessVol:
  000d5	81 bd 10 fb ff
	ff 08 00 4d 00	 cmp	 DWORD PTR tv67[ebp], 5046280 ; 004d0008H
  000df	77 41		 ja	 SHORT $LN53@ProcessVol
  000e1	81 bd 10 fb ff
	ff 08 00 4d 00	 cmp	 DWORD PTR tv67[ebp], 5046280 ; 004d0008H
  000eb	74 6a		 je	 SHORT $LN42@ProcessVol
  000ed	81 bd 10 fb ff
	ff 00 48 07 00	 cmp	 DWORD PTR tv67[ebp], 477184 ; 00074800H
  000f7	0f 84 c0 09 00
	00		 je	 $LN13@ProcessVol
  000fd	81 bd 10 fb ff
	ff 00 48 2d 00	 cmp	 DWORD PTR tv67[ebp], 2967552 ; 002d4800H
  00107	0f 84 b0 09 00
	00		 je	 $LN13@ProcessVol
  0010d	81 bd 10 fb ff
	ff 00 00 4d 00	 cmp	 DWORD PTR tv67[ebp], 5046272 ; 004d0000H
  00117	0f 84 16 01 00
	00		 je	 $LN38@ProcessVol
  0011d	e9 a3 0a 00 00	 jmp	 $LN2@ProcessVol
$LN53@ProcessVol:
  00122	81 bd 10 fb ff
	ff 0c 00 4d 00	 cmp	 DWORD PTR tv67[ebp], 5046284 ; 004d000cH
  0012c	0f 84 9c 03 00
	00		 je	 $LN34@ProcessVol
  00132	81 bd 10 fb ff
	ff 00 00 56 00	 cmp	 DWORD PTR tv67[ebp], 5636096 ; 00560000H
  0013c	0f 84 fd 09 00
	00		 je	 $LN7@ProcessVol
  00142	81 bd 10 fb ff
	ff 08 c0 56 00	 cmp	 DWORD PTR tv67[ebp], 5685256 ; 0056c008H
  0014c	0f 84 d4 09 00
	00		 je	 $LN8@ProcessVol
  00152	e9 6e 0a 00 00	 jmp	 $LN2@ProcessVol
$LN42@ProcessVol:

; 500  : 	{
; 501  : 
; 502  : 	case IOCTL_MOUNTDEV_QUERY_DEVICE_NAME:
; 503  : 		if (!ValidateIOBufferSize (Irp, sizeof (MOUNTDEV_NAME), ValidateOutput))

  00157	6a 01		 push	 1
  00159	6a 04		 push	 4
  0015b	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  0015e	50		 push	 eax
  0015f	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00164	85 c0		 test	 eax, eax
  00166	75 19		 jne	 SHORT $LN41@ProcessVol

; 504  : 		{
; 505  : 			Irp->IoStatus.Information = sizeof (MOUNTDEV_NAME);

  00168	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  0016b	c7 41 1c 04 00
	00 00		 mov	 DWORD PTR [ecx+28], 4

; 506  : 			Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

  00172	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  00175	c7 42 18 05 00
	00 80		 mov	 DWORD PTR [edx+24], -2147483643 ; 80000005H

; 507  : 		}
; 508  : 		else

  0017c	e9 ad 00 00 00	 jmp	 $LN40@ProcessVol
$LN41@ProcessVol:

; 509  : 		{
; 510  : 			ULONG outLength;
; 511  : 			UNICODE_STRING ntUnicodeString;
; 512  : 			WCHAR ntName[256];
; 513  : 			PMOUNTDEV_NAME outputBuffer = (PMOUNTDEV_NAME) Irp->AssociatedIrp.SystemBuffer;

  00181	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  00184	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00187	89 4d f0	 mov	 DWORD PTR _outputBuffer$29990[ebp], ecx

; 514  : 
; 515  : 			TCGetNTNameFromNumber (ntName, Extension->nDosDriveNo);

  0018a	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  0018d	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00190	50		 push	 eax
  00191	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _ntName$29989[ebp]
  00197	51		 push	 ecx
  00198	e8 00 00 00 00	 call	 _TCGetNTNameFromNumber@8

; 516  : 			RtlInitUnicodeString (&ntUnicodeString, ntName);

  0019d	8d 95 e8 fd ff
	ff		 lea	 edx, DWORD PTR _ntName$29989[ebp]
  001a3	52		 push	 edx
  001a4	8d 45 f4	 lea	 eax, DWORD PTR _ntUnicodeString$29988[ebp]
  001a7	50		 push	 eax
  001a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 517  : 
; 518  : 			outputBuffer->NameLength = ntUnicodeString.Length;

  001ae	8b 4d f0	 mov	 ecx, DWORD PTR _outputBuffer$29990[ebp]
  001b1	66 8b 55 f4	 mov	 dx, WORD PTR _ntUnicodeString$29988[ebp]
  001b5	66 89 11	 mov	 WORD PTR [ecx], dx

; 519  : 			outLength = ntUnicodeString.Length + sizeof(USHORT);

  001b8	0f b7 45 f4	 movzx	 eax, WORD PTR _ntUnicodeString$29988[ebp]
  001bc	83 c0 02	 add	 eax, 2
  001bf	89 85 e4 fd ff
	ff		 mov	 DWORD PTR _outLength$29987[ebp], eax

; 520  : 
; 521  : 			if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < outLength)

  001c5	8b 4d fc	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  001c8	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001cb	3b 95 e4 fd ff
	ff		 cmp	 edx, DWORD PTR _outLength$29987[ebp]
  001d1	73 19		 jae	 SHORT $LN39@ProcessVol

; 522  : 			{
; 523  : 				Irp->IoStatus.Information = sizeof (MOUNTDEV_NAME);

  001d3	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  001d6	c7 40 1c 04 00
	00 00		 mov	 DWORD PTR [eax+28], 4

; 524  : 				Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

  001dd	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  001e0	c7 41 18 05 00
	00 80		 mov	 DWORD PTR [ecx+24], -2147483643 ; 80000005H

; 525  : 
; 526  : 				break;

  001e7	e9 eb 09 00 00	 jmp	 $LN43@ProcessVol
$LN39@ProcessVol:

; 527  : 			}
; 528  : 
; 529  : 			RtlCopyMemory ((PCHAR)outputBuffer->Name,ntUnicodeString.Buffer, ntUnicodeString.Length);

  001ec	0f b7 55 f4	 movzx	 edx, WORD PTR _ntUnicodeString$29988[ebp]
  001f0	52		 push	 edx
  001f1	8b 45 f8	 mov	 eax, DWORD PTR _ntUnicodeString$29988[ebp+4]
  001f4	50		 push	 eax
  001f5	8b 4d f0	 mov	 ecx, DWORD PTR _outputBuffer$29990[ebp]
  001f8	83 c1 02	 add	 ecx, 2
  001fb	51		 push	 ecx
  001fc	e8 00 00 00 00	 call	 _memcpy
  00201	83 c4 0c	 add	 esp, 12			; 0000000cH

; 530  : 
; 531  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00204	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  00207	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 532  : 			Irp->IoStatus.Information = outLength;

  0020e	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  00211	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR _outLength$29987[ebp]
  00217	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 533  : 
; 534  : 			Dump ("name = %ls\n",ntName);

  0021a	8d 95 e8 fd ff
	ff		 lea	 edx, DWORD PTR _ntName$29989[ebp]
  00220	52		 push	 edx
  00221	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FBJPBOL@name?5?$DN?5?$CFls?6?$AA@FNODOBFM@
  00226	e8 00 00 00 00	 call	 _DbgPrint
  0022b	83 c4 08	 add	 esp, 8
$LN40@ProcessVol:

; 535  : 		}
; 536  : 		break;

  0022e	e9 a4 09 00 00	 jmp	 $LN43@ProcessVol
$LN38@ProcessVol:

; 537  : 
; 538  : 	case IOCTL_MOUNTDEV_QUERY_UNIQUE_ID:
; 539  : 		if (!ValidateIOBufferSize (Irp, sizeof (MOUNTDEV_UNIQUE_ID), ValidateOutput))

  00233	6a 01		 push	 1
  00235	6a 04		 push	 4
  00237	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  0023a	50		 push	 eax
  0023b	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00240	85 c0		 test	 eax, eax
  00242	75 19		 jne	 SHORT $LN37@ProcessVol

; 540  : 		{
; 541  : 			Irp->IoStatus.Information = sizeof (MOUNTDEV_UNIQUE_ID);

  00244	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00247	c7 41 1c 04 00
	00 00		 mov	 DWORD PTR [ecx+28], 4

; 542  : 			Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

  0024e	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  00251	c7 42 18 05 00
	00 80		 mov	 DWORD PTR [edx+24], -2147483643 ; 80000005H

; 543  : 		}
; 544  : 		else

  00258	e9 6c 02 00 00	 jmp	 $LN36@ProcessVol
$LN37@ProcessVol:

; 545  : 		{
; 546  : 			ULONG outLength;
; 547  : 			UCHAR volId[128], tmp[] = { 0,0 };

  0025d	c6 85 dc fd ff
	ff 00		 mov	 BYTE PTR _tmp$30007[ebp], 0
  00264	c6 85 dd fd ff
	ff 00		 mov	 BYTE PTR _tmp$30007[ebp+1], 0

; 548  : 			PMOUNTDEV_UNIQUE_ID outputBuffer = (PMOUNTDEV_UNIQUE_ID) Irp->AssociatedIrp.SystemBuffer;

  0026b	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  0026e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00271	89 8d e0 fd ff
	ff		 mov	 DWORD PTR _outputBuffer$30008[ebp], ecx

; 549  : 
; 550  : 			strcpy (volId, TC_UNIQUE_ID_PREFIX); 

  00277	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@FNODOBFM@
  0027d	89 95 58 fd ff
	ff		 mov	 DWORD PTR _volId$30006[ebp], edx
  00283	a1 04 00 00 00	 mov	 eax, DWORD PTR ??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@FNODOBFM@+4
  00288	89 85 5c fd ff
	ff		 mov	 DWORD PTR _volId$30006[ebp+4], eax
  0028e	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@FNODOBFM@+8
  00294	89 8d 60 fd ff
	ff		 mov	 DWORD PTR _volId$30006[ebp+8], ecx
  0029a	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@FNODOBFM@+12
  002a0	89 95 64 fd ff
	ff		 mov	 DWORD PTR _volId$30006[ebp+12], edx

; 551  : 			tmp[0] = 'A' + (UCHAR) Extension->nDosDriveNo;

  002a6	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  002a9	0f b6 48 14	 movzx	 ecx, BYTE PTR [eax+20]
  002ad	83 c1 41	 add	 ecx, 65			; 00000041H
  002b0	88 8d dc fd ff
	ff		 mov	 BYTE PTR _tmp$30007[ebp], cl

; 552  : 			strcat (volId, tmp);

  002b6	8d 95 dc fd ff
	ff		 lea	 edx, DWORD PTR _tmp$30007[ebp]
  002bc	89 95 0c fb ff
	ff		 mov	 DWORD PTR tv487[ebp], edx
  002c2	8b 85 0c fb ff
	ff		 mov	 eax, DWORD PTR tv487[ebp]
  002c8	89 85 08 fb ff
	ff		 mov	 DWORD PTR tv489[ebp], eax
$LL54@ProcessVol:
  002ce	8b 8d 0c fb ff
	ff		 mov	 ecx, DWORD PTR tv487[ebp]
  002d4	8a 11		 mov	 dl, BYTE PTR [ecx]
  002d6	88 95 07 fb ff
	ff		 mov	 BYTE PTR tv492[ebp], dl
  002dc	83 85 0c fb ff
	ff 01		 add	 DWORD PTR tv487[ebp], 1
  002e3	80 bd 07 fb ff
	ff 00		 cmp	 BYTE PTR tv492[ebp], 0
  002ea	75 e2		 jne	 SHORT $LL54@ProcessVol
  002ec	8b 85 0c fb ff
	ff		 mov	 eax, DWORD PTR tv487[ebp]
  002f2	2b 85 08 fb ff
	ff		 sub	 eax, DWORD PTR tv489[ebp]
  002f8	8b 8d 08 fb ff
	ff		 mov	 ecx, DWORD PTR tv489[ebp]
  002fe	89 8d 00 fb ff
	ff		 mov	 DWORD PTR tv497[ebp], ecx
  00304	89 85 fc fa ff
	ff		 mov	 DWORD PTR tv498[ebp], eax
  0030a	8d 95 58 fd ff
	ff		 lea	 edx, DWORD PTR _volId$30006[ebp]
  00310	83 c2 ff	 add	 edx, -1
  00313	89 95 f8 fa ff
	ff		 mov	 DWORD PTR tv501[ebp], edx
$LL55@ProcessVol:
  00319	8b 85 f8 fa ff
	ff		 mov	 eax, DWORD PTR tv501[ebp]
  0031f	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00322	88 8d f7 fa ff
	ff		 mov	 BYTE PTR tv504[ebp], cl
  00328	83 85 f8 fa ff
	ff 01		 add	 DWORD PTR tv501[ebp], 1
  0032f	80 bd f7 fa ff
	ff 00		 cmp	 BYTE PTR tv504[ebp], 0
  00336	75 e1		 jne	 SHORT $LL55@ProcessVol
  00338	8b bd f8 fa ff
	ff		 mov	 edi, DWORD PTR tv501[ebp]
  0033e	8b b5 00 fb ff
	ff		 mov	 esi, DWORD PTR tv497[ebp]
  00344	8b 95 fc fa ff
	ff		 mov	 edx, DWORD PTR tv498[ebp]
  0034a	8b ca		 mov	 ecx, edx
  0034c	c1 e9 02	 shr	 ecx, 2
  0034f	f3 a5		 rep movsd
  00351	8b ca		 mov	 ecx, edx
  00353	83 e1 03	 and	 ecx, 3
  00356	f3 a4		 rep movsb

; 553  : 			
; 554  : 			outputBuffer->UniqueIdLength = (USHORT) strlen (volId);

  00358	8d 85 58 fd ff
	ff		 lea	 eax, DWORD PTR _volId$30006[ebp]
  0035e	89 85 f0 fa ff
	ff		 mov	 DWORD PTR tv519[ebp], eax
  00364	8b 8d f0 fa ff
	ff		 mov	 ecx, DWORD PTR tv519[ebp]
  0036a	83 c1 01	 add	 ecx, 1
  0036d	89 8d ec fa ff
	ff		 mov	 DWORD PTR tv522[ebp], ecx
$LL56@ProcessVol:
  00373	8b 95 f0 fa ff
	ff		 mov	 edx, DWORD PTR tv519[ebp]
  00379	8a 02		 mov	 al, BYTE PTR [edx]
  0037b	88 85 eb fa ff
	ff		 mov	 BYTE PTR tv525[ebp], al
  00381	83 85 f0 fa ff
	ff 01		 add	 DWORD PTR tv519[ebp], 1
  00388	80 bd eb fa ff
	ff 00		 cmp	 BYTE PTR tv525[ebp], 0
  0038f	75 e2		 jne	 SHORT $LL56@ProcessVol
  00391	8b 8d f0 fa ff
	ff		 mov	 ecx, DWORD PTR tv519[ebp]
  00397	2b 8d ec fa ff
	ff		 sub	 ecx, DWORD PTR tv522[ebp]
  0039d	89 8d e4 fa ff
	ff		 mov	 DWORD PTR tv151[ebp], ecx
  003a3	8b 95 e0 fd ff
	ff		 mov	 edx, DWORD PTR _outputBuffer$30008[ebp]
  003a9	66 8b 85 e4 fa
	ff ff		 mov	 ax, WORD PTR tv151[ebp]
  003b0	66 89 02	 mov	 WORD PTR [edx], ax

; 555  : 			outLength = (ULONG) (strlen (volId) + sizeof (USHORT));

  003b3	8d 8d 58 fd ff
	ff		 lea	 ecx, DWORD PTR _volId$30006[ebp]
  003b9	89 8d e0 fa ff
	ff		 mov	 DWORD PTR tv532[ebp], ecx
  003bf	8b 95 e0 fa ff
	ff		 mov	 edx, DWORD PTR tv532[ebp]
  003c5	83 c2 01	 add	 edx, 1
  003c8	89 95 dc fa ff
	ff		 mov	 DWORD PTR tv535[ebp], edx
$LL57@ProcessVol:
  003ce	8b 85 e0 fa ff
	ff		 mov	 eax, DWORD PTR tv532[ebp]
  003d4	8a 08		 mov	 cl, BYTE PTR [eax]
  003d6	88 8d db fa ff
	ff		 mov	 BYTE PTR tv538[ebp], cl
  003dc	83 85 e0 fa ff
	ff 01		 add	 DWORD PTR tv532[ebp], 1
  003e3	80 bd db fa ff
	ff 00		 cmp	 BYTE PTR tv538[ebp], 0
  003ea	75 e2		 jne	 SHORT $LL57@ProcessVol
  003ec	8b 95 e0 fa ff
	ff		 mov	 edx, DWORD PTR tv532[ebp]
  003f2	2b 95 dc fa ff
	ff		 sub	 edx, DWORD PTR tv535[ebp]
  003f8	89 95 d4 fa ff
	ff		 mov	 DWORD PTR tv155[ebp], edx
  003fe	8b 85 d4 fa ff
	ff		 mov	 eax, DWORD PTR tv155[ebp]
  00404	83 c0 02	 add	 eax, 2
  00407	89 85 54 fd ff
	ff		 mov	 DWORD PTR _outLength$30005[ebp], eax

; 556  : 
; 557  : 			if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < outLength)

  0040d	8b 4d fc	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  00410	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00413	3b 95 54 fd ff
	ff		 cmp	 edx, DWORD PTR _outLength$30005[ebp]
  00419	73 19		 jae	 SHORT $LN35@ProcessVol

; 558  : 			{
; 559  : 				Irp->IoStatus.Information = sizeof (MOUNTDEV_UNIQUE_ID);

  0041b	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  0041e	c7 40 1c 04 00
	00 00		 mov	 DWORD PTR [eax+28], 4

; 560  : 				Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

  00425	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00428	c7 41 18 05 00
	00 80		 mov	 DWORD PTR [ecx+24], -2147483643 ; 80000005H

; 561  : 				break;

  0042f	e9 a3 07 00 00	 jmp	 $LN43@ProcessVol
$LN35@ProcessVol:

; 562  : 			}
; 563  : 
; 564  : 			RtlCopyMemory ((PCHAR)outputBuffer->UniqueId, volId, strlen (volId));

  00434	8d 95 58 fd ff
	ff		 lea	 edx, DWORD PTR _volId$30006[ebp]
  0043a	89 95 d0 fa ff
	ff		 mov	 DWORD PTR tv548[ebp], edx
  00440	8b 85 d0 fa ff
	ff		 mov	 eax, DWORD PTR tv548[ebp]
  00446	83 c0 01	 add	 eax, 1
  00449	89 85 cc fa ff
	ff		 mov	 DWORD PTR tv551[ebp], eax
$LL58@ProcessVol:
  0044f	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR tv548[ebp]
  00455	8a 11		 mov	 dl, BYTE PTR [ecx]
  00457	88 95 cb fa ff
	ff		 mov	 BYTE PTR tv554[ebp], dl
  0045d	83 85 d0 fa ff
	ff 01		 add	 DWORD PTR tv548[ebp], 1
  00464	80 bd cb fa ff
	ff 00		 cmp	 BYTE PTR tv554[ebp], 0
  0046b	75 e2		 jne	 SHORT $LL58@ProcessVol
  0046d	8b 85 d0 fa ff
	ff		 mov	 eax, DWORD PTR tv548[ebp]
  00473	2b 85 cc fa ff
	ff		 sub	 eax, DWORD PTR tv551[ebp]
  00479	89 85 c4 fa ff
	ff		 mov	 DWORD PTR tv164[ebp], eax
  0047f	8b 8d c4 fa ff
	ff		 mov	 ecx, DWORD PTR tv164[ebp]
  00485	51		 push	 ecx
  00486	8d 95 58 fd ff
	ff		 lea	 edx, DWORD PTR _volId$30006[ebp]
  0048c	52		 push	 edx
  0048d	8b 85 e0 fd ff
	ff		 mov	 eax, DWORD PTR _outputBuffer$30008[ebp]
  00493	83 c0 02	 add	 eax, 2
  00496	50		 push	 eax
  00497	e8 00 00 00 00	 call	 _memcpy
  0049c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 565  : 
; 566  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  0049f	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  004a2	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 567  : 			Irp->IoStatus.Information = outLength;

  004a9	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  004ac	8b 85 54 fd ff
	ff		 mov	 eax, DWORD PTR _outLength$30005[ebp]
  004b2	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 568  : 
; 569  : 			Dump ("id = %s\n",volId);

  004b5	8d 8d 58 fd ff
	ff		 lea	 ecx, DWORD PTR _volId$30006[ebp]
  004bb	51		 push	 ecx
  004bc	68 00 00 00 00	 push	 OFFSET ??_C@_08DALLBBIL@id?5?$DN?5?$CFs?6?$AA@FNODOBFM@
  004c1	e8 00 00 00 00	 call	 _DbgPrint
  004c6	83 c4 08	 add	 esp, 8
$LN36@ProcessVol:

; 570  : 		}
; 571  : 		break;

  004c9	e9 09 07 00 00	 jmp	 $LN43@ProcessVol
$LN34@ProcessVol:

; 572  : 
; 573  : 	case IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME:
; 574  : 		{
; 575  : 			ULONG outLength;
; 576  : 			UNICODE_STRING ntUnicodeString;
; 577  : 			WCHAR ntName[256];
; 578  : 			PMOUNTDEV_SUGGESTED_LINK_NAME outputBuffer = (PMOUNTDEV_SUGGESTED_LINK_NAME) Irp->AssociatedIrp.SystemBuffer;

  004ce	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  004d1	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  004d4	89 85 48 fd ff
	ff		 mov	 DWORD PTR _outputBuffer$30025[ebp], eax

; 579  : 
; 580  : 			if (!ValidateIOBufferSize (Irp, sizeof (MOUNTDEV_SUGGESTED_LINK_NAME), ValidateOutput))

  004da	6a 01		 push	 1
  004dc	6a 06		 push	 6
  004de	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  004e1	51		 push	 ecx
  004e2	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  004e7	85 c0		 test	 eax, eax
  004e9	75 19		 jne	 SHORT $LN33@ProcessVol

; 581  : 			{
; 582  : 				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  004eb	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  004ee	c7 42 18 0d 00
	00 c0		 mov	 DWORD PTR [edx+24], -1073741811 ; c000000dH

; 583  : 				Irp->IoStatus.Information = 0;

  004f5	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  004f8	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 584  : 				break; 

  004ff	e9 d3 06 00 00	 jmp	 $LN43@ProcessVol
$LN33@ProcessVol:

; 585  : 			}
; 586  : 
; 587  : 			TCGetDosNameFromNumber (ntName, Extension->nDosDriveNo);

  00504	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00507	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0050a	52		 push	 edx
  0050b	8d 85 48 fb ff
	ff		 lea	 eax, DWORD PTR _ntName$30024[ebp]
  00511	50		 push	 eax
  00512	e8 00 00 00 00	 call	 _TCGetDosNameFromNumber@8

; 588  : 			RtlInitUnicodeString (&ntUnicodeString, ntName);

  00517	8d 8d 48 fb ff
	ff		 lea	 ecx, DWORD PTR _ntName$30024[ebp]
  0051d	51		 push	 ecx
  0051e	8d 95 4c fd ff
	ff		 lea	 edx, DWORD PTR _ntUnicodeString$30023[ebp]
  00524	52		 push	 edx
  00525	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 589  : 
; 590  : 			outLength = FIELD_OFFSET(MOUNTDEV_SUGGESTED_LINK_NAME,Name) + ntUnicodeString.Length;

  0052b	0f b7 85 4c fd
	ff ff		 movzx	 eax, WORD PTR _ntUnicodeString$30023[ebp]
  00532	83 c0 04	 add	 eax, 4
  00535	89 85 44 fb ff
	ff		 mov	 DWORD PTR _outLength$30022[ebp], eax

; 591  : 
; 592  : 			outputBuffer->UseOnlyIfThereAreNoOtherLinks = FALSE;

  0053b	8b 8d 48 fd ff
	ff		 mov	 ecx, DWORD PTR _outputBuffer$30025[ebp]
  00541	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 593  : 			outputBuffer->NameLength = ntUnicodeString.Length;

  00544	8b 95 48 fd ff
	ff		 mov	 edx, DWORD PTR _outputBuffer$30025[ebp]
  0054a	66 8b 85 4c fd
	ff ff		 mov	 ax, WORD PTR _ntUnicodeString$30023[ebp]
  00551	66 89 42 02	 mov	 WORD PTR [edx+2], ax

; 594  : 
; 595  : 			if(irpSp->Parameters.DeviceIoControl.OutputBufferLength < outLength)

  00555	8b 4d fc	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  00558	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0055b	3b 95 44 fb ff
	ff		 cmp	 edx, DWORD PTR _outLength$30022[ebp]
  00561	73 19		 jae	 SHORT $LN32@ProcessVol

; 596  : 			{
; 597  : 				Irp->IoStatus.Information = sizeof (MOUNTDEV_SUGGESTED_LINK_NAME);

  00563	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  00566	c7 40 1c 06 00
	00 00		 mov	 DWORD PTR [eax+28], 6

; 598  : 				Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

  0056d	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00570	c7 41 18 05 00
	00 80		 mov	 DWORD PTR [ecx+24], -2147483643 ; 80000005H

; 599  : 				break;

  00577	e9 5b 06 00 00	 jmp	 $LN43@ProcessVol
$LN32@ProcessVol:

; 600  : 			}
; 601  : 
; 602  : 			RtlCopyMemory ((PCHAR)outputBuffer->Name,ntUnicodeString.Buffer, ntUnicodeString.Length);

  0057c	0f b7 95 4c fd
	ff ff		 movzx	 edx, WORD PTR _ntUnicodeString$30023[ebp]
  00583	52		 push	 edx
  00584	8b 85 50 fd ff
	ff		 mov	 eax, DWORD PTR _ntUnicodeString$30023[ebp+4]
  0058a	50		 push	 eax
  0058b	8b 8d 48 fd ff
	ff		 mov	 ecx, DWORD PTR _outputBuffer$30025[ebp]
  00591	83 c1 04	 add	 ecx, 4
  00594	51		 push	 ecx
  00595	e8 00 00 00 00	 call	 _memcpy
  0059a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 603  : 		
; 604  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  0059d	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  005a0	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 605  : 			Irp->IoStatus.Information = outLength;

  005a7	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  005aa	8b 8d 44 fb ff
	ff		 mov	 ecx, DWORD PTR _outLength$30022[ebp]
  005b0	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 606  : 
; 607  : 			Dump ("link = %ls\n",ntName);

  005b3	8d 95 48 fb ff
	ff		 lea	 edx, DWORD PTR _ntName$30024[ebp]
  005b9	52		 push	 edx
  005ba	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HABEOOKA@link?5?$DN?5?$CFls?6?$AA@FNODOBFM@
  005bf	e8 00 00 00 00	 call	 _DbgPrint
  005c4	83 c4 08	 add	 esp, 8

; 608  : 		}
; 609  : 		break;

  005c7	e9 0b 06 00 00	 jmp	 $LN43@ProcessVol
$LN31@ProcessVol:

; 610  : 
; 611  : 	case IOCTL_DISK_GET_MEDIA_TYPES:
; 612  : 	case IOCTL_DISK_GET_DRIVE_GEOMETRY:
; 613  : 		/* Return the drive geometry for the disk.  Note that we
; 614  : 		   return values which were made up to suit the disk size.  */
; 615  : 		if (ValidateIOBufferSize (Irp, sizeof (DISK_GEOMETRY), ValidateOutput))

  005cc	6a 01		 push	 1
  005ce	6a 18		 push	 24			; 00000018H
  005d0	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  005d3	50		 push	 eax
  005d4	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  005d9	85 c0		 test	 eax, eax
  005db	0f 84 83 00 00
	00		 je	 $LN30@ProcessVol

; 616  : 		{
; 617  : 			PDISK_GEOMETRY outputBuffer = (PDISK_GEOMETRY)
; 618  : 			Irp->AssociatedIrp.SystemBuffer;

  005e1	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  005e4	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  005e7	89 95 40 fb ff
	ff		 mov	 DWORD PTR _outputBuffer$30042[ebp], edx

; 619  : 
; 620  : 			outputBuffer->MediaType = Extension->bRemovable ? RemovableMedia : FixedMedia;

  005ed	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  005f0	8b 88 8c 02 00
	00		 mov	 ecx, DWORD PTR [eax+652]
  005f6	f7 d9		 neg	 ecx
  005f8	1b c9		 sbb	 ecx, ecx
  005fa	83 c1 0c	 add	 ecx, 12			; 0000000cH
  005fd	8b 95 40 fb ff
	ff		 mov	 edx, DWORD PTR _outputBuffer$30042[ebp]
  00603	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 621  : 			outputBuffer->Cylinders.QuadPart = Extension->NumberOfCylinders;

  00606	8b 85 40 fb ff
	ff		 mov	 eax, DWORD PTR _outputBuffer$30042[ebp]
  0060c	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0060f	8b 51 78	 mov	 edx, DWORD PTR [ecx+120]
  00612	89 10		 mov	 DWORD PTR [eax], edx
  00614	8b 49 7c	 mov	 ecx, DWORD PTR [ecx+124]
  00617	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 622  : 			outputBuffer->TracksPerCylinder = Extension->TracksPerCylinder;

  0061a	8b 95 40 fb ff
	ff		 mov	 edx, DWORD PTR _outputBuffer$30042[ebp]
  00620	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  00623	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  00629	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 623  : 			outputBuffer->SectorsPerTrack = Extension->SectorsPerTrack;

  0062c	8b 95 40 fb ff
	ff		 mov	 edx, DWORD PTR _outputBuffer$30042[ebp]
  00632	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  00635	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  0063b	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 624  : 			outputBuffer->BytesPerSector = Extension->BytesPerSector;

  0063e	8b 95 40 fb ff
	ff		 mov	 edx, DWORD PTR _outputBuffer$30042[ebp]
  00644	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  00647	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  0064d	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 625  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00650	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  00653	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 626  : 			Irp->IoStatus.Information = sizeof (DISK_GEOMETRY);

  0065a	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  0065d	c7 40 1c 18 00
	00 00		 mov	 DWORD PTR [eax+28], 24	; 00000018H
$LN30@ProcessVol:

; 627  : 		}
; 628  : 		break;

  00664	e9 6e 05 00 00	 jmp	 $LN43@ProcessVol
$LN29@ProcessVol:

; 629  : 
; 630  : 	case IOCTL_DISK_GET_PARTITION_INFO:
; 631  : 		if (ValidateIOBufferSize (Irp, sizeof (PARTITION_INFORMATION), ValidateOutput))

  00669	6a 01		 push	 1
  0066b	6a 20		 push	 32			; 00000020H
  0066d	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00670	51		 push	 ecx
  00671	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00676	85 c0		 test	 eax, eax
  00678	0f 84 88 00 00
	00		 je	 $LN28@ProcessVol

; 632  : 		{
; 633  : 			PPARTITION_INFORMATION outputBuffer = (PPARTITION_INFORMATION)
; 634  : 			Irp->AssociatedIrp.SystemBuffer;

  0067e	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  00681	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00684	89 85 3c fb ff
	ff		 mov	 DWORD PTR _outputBuffer$30049[ebp], eax

; 635  : 
; 636  : 			outputBuffer->PartitionType = Extension->PartitionType;

  0068a	8b 8d 3c fb ff
	ff		 mov	 ecx, DWORD PTR _outputBuffer$30049[ebp]
  00690	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  00693	8a 82 8c 00 00
	00		 mov	 al, BYTE PTR [edx+140]
  00699	88 41 18	 mov	 BYTE PTR [ecx+24], al

; 637  : 			outputBuffer->BootIndicator = FALSE;

  0069c	8b 8d 3c fb ff
	ff		 mov	 ecx, DWORD PTR _outputBuffer$30049[ebp]
  006a2	c6 41 19 00	 mov	 BYTE PTR [ecx+25], 0

; 638  : 			outputBuffer->RecognizedPartition = TRUE;

  006a6	8b 95 3c fb ff
	ff		 mov	 edx, DWORD PTR _outputBuffer$30049[ebp]
  006ac	c6 42 1a 01	 mov	 BYTE PTR [edx+26], 1

; 639  : 			outputBuffer->RewritePartition = FALSE;

  006b0	8b 85 3c fb ff
	ff		 mov	 eax, DWORD PTR _outputBuffer$30049[ebp]
  006b6	c6 40 1b 00	 mov	 BYTE PTR [eax+27], 0

; 640  : 			outputBuffer->StartingOffset.QuadPart = Extension->BytesPerSector;

  006ba	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  006bd	8b 91 88 00 00
	00		 mov	 edx, DWORD PTR [ecx+136]
  006c3	33 c0		 xor	 eax, eax
  006c5	8b 8d 3c fb ff
	ff		 mov	 ecx, DWORD PTR _outputBuffer$30049[ebp]
  006cb	89 11		 mov	 DWORD PTR [ecx], edx
  006cd	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 641  : 			outputBuffer->PartitionLength.QuadPart= Extension->DiskLength;

  006d0	8b 95 3c fb ff
	ff		 mov	 edx, DWORD PTR _outputBuffer$30049[ebp]
  006d6	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  006d9	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  006dc	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  006df	8b 40 74	 mov	 eax, DWORD PTR [eax+116]
  006e2	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 642  : 			outputBuffer->HiddenSectors = 0;

  006e5	8b 8d 3c fb ff
	ff		 mov	 ecx, DWORD PTR _outputBuffer$30049[ebp]
  006eb	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 643  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  006f2	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  006f5	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 644  : 			Irp->IoStatus.Information = sizeof (PARTITION_INFORMATION);

  006fc	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  006ff	c7 40 1c 20 00
	00 00		 mov	 DWORD PTR [eax+28], 32	; 00000020H
$LN28@ProcessVol:

; 645  : 		}
; 646  : 		break;

  00706	e9 cc 04 00 00	 jmp	 $LN43@ProcessVol
$LN27@ProcessVol:

; 647  : 
; 648  : 	case IOCTL_DISK_GET_PARTITION_INFO_EX:
; 649  : 		if (ValidateIOBufferSize (Irp, sizeof (PARTITION_INFORMATION_EX), ValidateOutput))

  0070b	6a 01		 push	 1
  0070d	68 90 00 00 00	 push	 144			; 00000090H
  00712	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00715	51		 push	 ecx
  00716	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  0071b	85 c0		 test	 eax, eax
  0071d	0f 84 95 00 00
	00		 je	 $LN26@ProcessVol

; 650  : 		{
; 651  : 			PPARTITION_INFORMATION_EX outputBuffer = (PPARTITION_INFORMATION_EX) Irp->AssociatedIrp.SystemBuffer;

  00723	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  00726	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00729	89 85 38 fb ff
	ff		 mov	 DWORD PTR _outputBuffer$30056[ebp], eax

; 652  : 
; 653  : 			outputBuffer->PartitionStyle = PARTITION_STYLE_MBR;

  0072f	8b 8d 38 fb ff
	ff		 mov	 ecx, DWORD PTR _outputBuffer$30056[ebp]
  00735	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 654  : 			outputBuffer->RewritePartition = FALSE;

  0073b	8b 95 38 fb ff
	ff		 mov	 edx, DWORD PTR _outputBuffer$30056[ebp]
  00741	c6 42 1c 00	 mov	 BYTE PTR [edx+28], 0

; 655  : 			outputBuffer->StartingOffset.QuadPart = Extension->BytesPerSector;

  00745	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  00748	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  0074e	33 d2		 xor	 edx, edx
  00750	8b 85 38 fb ff
	ff		 mov	 eax, DWORD PTR _outputBuffer$30056[ebp]
  00756	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00759	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 656  : 			outputBuffer->PartitionLength.QuadPart= Extension->DiskLength;

  0075c	8b 8d 38 fb ff
	ff		 mov	 ecx, DWORD PTR _outputBuffer$30056[ebp]
  00762	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  00765	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  00768	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0076b	8b 52 74	 mov	 edx, DWORD PTR [edx+116]
  0076e	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 657  : 			outputBuffer->Mbr.PartitionType = Extension->PartitionType;

  00771	8b 85 38 fb ff
	ff		 mov	 eax, DWORD PTR _outputBuffer$30056[ebp]
  00777	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0077a	8a 91 8c 00 00
	00		 mov	 dl, BYTE PTR [ecx+140]
  00780	88 50 20	 mov	 BYTE PTR [eax+32], dl

; 658  : 			outputBuffer->Mbr.BootIndicator = FALSE;

  00783	8b 85 38 fb ff
	ff		 mov	 eax, DWORD PTR _outputBuffer$30056[ebp]
  00789	c6 40 21 00	 mov	 BYTE PTR [eax+33], 0

; 659  : 			outputBuffer->Mbr.RecognizedPartition = TRUE;

  0078d	8b 8d 38 fb ff
	ff		 mov	 ecx, DWORD PTR _outputBuffer$30056[ebp]
  00793	c6 41 22 01	 mov	 BYTE PTR [ecx+34], 1

; 660  : 			outputBuffer->Mbr.HiddenSectors = 0;

  00797	8b 95 38 fb ff
	ff		 mov	 edx, DWORD PTR _outputBuffer$30056[ebp]
  0079d	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], 0

; 661  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  007a4	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  007a7	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 662  : 			Irp->IoStatus.Information = sizeof (PARTITION_INFORMATION_EX);

  007ae	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  007b1	c7 41 1c 90 00
	00 00		 mov	 DWORD PTR [ecx+28], 144	; 00000090H
$LN26@ProcessVol:

; 663  : 		}
; 664  : 		break;

  007b8	e9 1a 04 00 00	 jmp	 $LN43@ProcessVol
$LN25@ProcessVol:

; 665  : 
; 666  : 	case IOCTL_DISK_GET_DRIVE_LAYOUT:
; 667  : 		if (ValidateIOBufferSize (Irp, sizeof (DRIVE_LAYOUT_INFORMATION), ValidateOutput))

  007bd	6a 01		 push	 1
  007bf	6a 28		 push	 40			; 00000028H
  007c1	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  007c4	52		 push	 edx
  007c5	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  007ca	85 c0		 test	 eax, eax
  007cc	0f 84 a2 00 00
	00		 je	 $LN24@ProcessVol

; 668  : 		{
; 669  : 			PDRIVE_LAYOUT_INFORMATION outputBuffer = (PDRIVE_LAYOUT_INFORMATION)
; 670  : 			Irp->AssociatedIrp.SystemBuffer;

  007d2	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  007d5	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  007d8	89 8d 34 fb ff
	ff		 mov	 DWORD PTR _outputBuffer$30063[ebp], ecx

; 671  : 
; 672  : 			outputBuffer->PartitionCount = 1;

  007de	8b 95 34 fb ff
	ff		 mov	 edx, DWORD PTR _outputBuffer$30063[ebp]
  007e4	c7 02 01 00 00
	00		 mov	 DWORD PTR [edx], 1

; 673  : 			outputBuffer->Signature = 0;

  007ea	8b 85 34 fb ff
	ff		 mov	 eax, DWORD PTR _outputBuffer$30063[ebp]
  007f0	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 674  : 
; 675  : 			outputBuffer->PartitionEntry->PartitionType = Extension->PartitionType;

  007f7	8b 8d 34 fb ff
	ff		 mov	 ecx, DWORD PTR _outputBuffer$30063[ebp]
  007fd	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  00800	8a 82 8c 00 00
	00		 mov	 al, BYTE PTR [edx+140]
  00806	88 41 20	 mov	 BYTE PTR [ecx+32], al

; 676  : 			outputBuffer->PartitionEntry->BootIndicator = FALSE;

  00809	8b 8d 34 fb ff
	ff		 mov	 ecx, DWORD PTR _outputBuffer$30063[ebp]
  0080f	c6 41 21 00	 mov	 BYTE PTR [ecx+33], 0

; 677  : 			outputBuffer->PartitionEntry->RecognizedPartition = TRUE;

  00813	8b 95 34 fb ff
	ff		 mov	 edx, DWORD PTR _outputBuffer$30063[ebp]
  00819	c6 42 22 01	 mov	 BYTE PTR [edx+34], 1

; 678  : 			outputBuffer->PartitionEntry->RewritePartition = FALSE;

  0081d	8b 85 34 fb ff
	ff		 mov	 eax, DWORD PTR _outputBuffer$30063[ebp]
  00823	c6 40 23 00	 mov	 BYTE PTR [eax+35], 0

; 679  : 			outputBuffer->PartitionEntry->StartingOffset.QuadPart = Extension->BytesPerSector;

  00827	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0082a	8b 91 88 00 00
	00		 mov	 edx, DWORD PTR [ecx+136]
  00830	33 c0		 xor	 eax, eax
  00832	8b 8d 34 fb ff
	ff		 mov	 ecx, DWORD PTR _outputBuffer$30063[ebp]
  00838	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0083b	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 680  : 			outputBuffer->PartitionEntry->PartitionLength.QuadPart = Extension->DiskLength;

  0083e	8b 95 34 fb ff
	ff		 mov	 edx, DWORD PTR _outputBuffer$30063[ebp]
  00844	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  00847	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  0084a	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
  0084d	8b 40 74	 mov	 eax, DWORD PTR [eax+116]
  00850	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 681  : 			outputBuffer->PartitionEntry->HiddenSectors = 0;

  00853	8b 8d 34 fb ff
	ff		 mov	 ecx, DWORD PTR _outputBuffer$30063[ebp]
  00859	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 682  : 
; 683  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00860	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  00863	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 684  : 			Irp->IoStatus.Information = sizeof (PARTITION_INFORMATION);

  0086a	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  0086d	c7 40 1c 20 00
	00 00		 mov	 DWORD PTR [eax+28], 32	; 00000020H
$LN24@ProcessVol:

; 685  : 		}
; 686  : 		break;

  00874	e9 5e 03 00 00	 jmp	 $LN43@ProcessVol
$LN23@ProcessVol:

; 687  : 
; 688  : 	case IOCTL_DISK_GET_LENGTH_INFO:
; 689  : 		if (!ValidateIOBufferSize (Irp, sizeof (GET_LENGTH_INFORMATION), ValidateOutput))

  00879	6a 01		 push	 1
  0087b	6a 08		 push	 8
  0087d	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00880	51		 push	 ecx
  00881	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00886	85 c0		 test	 eax, eax
  00888	75 16		 jne	 SHORT $LN22@ProcessVol

; 690  : 		{
; 691  : 			Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

  0088a	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  0088d	c7 42 18 05 00
	00 80		 mov	 DWORD PTR [edx+24], -2147483643 ; 80000005H

; 692  : 			Irp->IoStatus.Information = sizeof (GET_LENGTH_INFORMATION);

  00894	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  00897	c7 40 1c 08 00
	00 00		 mov	 DWORD PTR [eax+28], 8

; 693  : 		}
; 694  : 		else

  0089e	eb 34		 jmp	 SHORT $LN21@ProcessVol
$LN22@ProcessVol:

; 695  : 		{
; 696  : 			PGET_LENGTH_INFORMATION outputBuffer = (PGET_LENGTH_INFORMATION) Irp->AssociatedIrp.SystemBuffer;

  008a0	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  008a3	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  008a6	89 95 30 fb ff
	ff		 mov	 DWORD PTR _outputBuffer$30073[ebp], edx

; 697  : 
; 698  : 			outputBuffer->Length.QuadPart = Extension->DiskLength;

  008ac	8b 85 30 fb ff
	ff		 mov	 eax, DWORD PTR _outputBuffer$30073[ebp]
  008b2	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  008b5	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  008b8	89 10		 mov	 DWORD PTR [eax], edx
  008ba	8b 49 74	 mov	 ecx, DWORD PTR [ecx+116]
  008bd	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 699  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  008c0	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  008c3	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 700  : 			Irp->IoStatus.Information = sizeof (GET_LENGTH_INFORMATION);

  008ca	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  008cd	c7 40 1c 08 00
	00 00		 mov	 DWORD PTR [eax+28], 8
$LN21@ProcessVol:

; 701  : 		}
; 702  : 		break;

  008d4	e9 fe 02 00 00	 jmp	 $LN43@ProcessVol
$LN20@ProcessVol:

; 703  : 
; 704  : 	case IOCTL_DISK_VERIFY:
; 705  : 		if (ValidateIOBufferSize (Irp, sizeof (VERIFY_INFORMATION), ValidateInput))

  008d9	6a 00		 push	 0
  008db	6a 10		 push	 16			; 00000010H
  008dd	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  008e0	51		 push	 ecx
  008e1	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  008e6	85 c0		 test	 eax, eax
  008e8	0f 84 ca 01 00
	00		 je	 $LN19@ProcessVol

; 706  : 		{
; 707  : 			PVERIFY_INFORMATION pVerifyInformation;
; 708  : 			pVerifyInformation = (PVERIFY_INFORMATION) Irp->AssociatedIrp.SystemBuffer;

  008ee	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  008f1	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  008f4	89 85 2c fb ff
	ff		 mov	 DWORD PTR _pVerifyInformation$30080[ebp], eax

; 709  : 
; 710  : 			if (pVerifyInformation->StartingOffset.QuadPart + pVerifyInformation->Length > Extension->DiskLength)

  008fa	8b 8d 2c fb ff
	ff		 mov	 ecx, DWORD PTR _pVerifyInformation$30080[ebp]
  00900	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00903	33 c0		 xor	 eax, eax
  00905	8b 8d 2c fb ff
	ff		 mov	 ecx, DWORD PTR _pVerifyInformation$30080[ebp]
  0090b	03 11		 add	 edx, DWORD PTR [ecx]
  0090d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00910	13 c8		 adc	 ecx, eax
  00912	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  00915	89 95 bc fa ff
	ff		 mov	 DWORD PTR tv718[ebp], edx
  0091b	89 8d c0 fa ff
	ff		 mov	 DWORD PTR tv718[ebp+4], ecx
  00921	89 85 b8 fa ff
	ff		 mov	 DWORD PTR tv721[ebp], eax
  00927	8b 8d b8 fa ff
	ff		 mov	 ecx, DWORD PTR tv721[ebp]
  0092d	8b 95 c0 fa ff
	ff		 mov	 edx, DWORD PTR tv718[ebp+4]
  00933	3b 51 74	 cmp	 edx, DWORD PTR [ecx+116]
  00936	7c 22		 jl	 SHORT $LN18@ProcessVol
  00938	7f 11		 jg	 SHORT $LN59@ProcessVol
  0093a	8b 85 b8 fa ff
	ff		 mov	 eax, DWORD PTR tv721[ebp]
  00940	8b 8d bc fa ff
	ff		 mov	 ecx, DWORD PTR tv718[ebp]
  00946	3b 48 70	 cmp	 ecx, DWORD PTR [eax+112]
  00949	76 0f		 jbe	 SHORT $LN18@ProcessVol
$LN59@ProcessVol:

; 711  : 				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  0094b	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  0094e	c7 42 18 0d 00
	00 c0		 mov	 DWORD PTR [edx+24], -1073741811 ; c000000dH

; 712  : 			else

  00955	e9 54 01 00 00	 jmp	 $LN17@ProcessVol
$LN18@ProcessVol:

; 713  : 			{
; 714  : 				IO_STATUS_BLOCK ioStatus;
; 715  : 				PVOID buffer = TCalloc (max (pVerifyInformation->Length, PAGE_SIZE));

  0095a	8b 85 2c fb ff
	ff		 mov	 eax, DWORD PTR _pVerifyInformation$30080[ebp]
  00960	81 78 08 00 10
	00 00		 cmp	 DWORD PTR [eax+8], 4096	; 00001000H
  00967	76 11		 jbe	 SHORT $LN47@ProcessVol
  00969	8b 8d 2c fb ff
	ff		 mov	 ecx, DWORD PTR _pVerifyInformation$30080[ebp]
  0096f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00972	89 95 b4 fa ff
	ff		 mov	 DWORD PTR tv337[ebp], edx
  00978	eb 0a		 jmp	 SHORT $LN48@ProcessVol
$LN47@ProcessVol:
  0097a	c7 85 b4 fa ff
	ff 00 10 00 00	 mov	 DWORD PTR tv337[ebp], 4096 ; 00001000H
$LN48@ProcessVol:
  00984	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00989	8b 85 b4 fa ff
	ff		 mov	 eax, DWORD PTR tv337[ebp]
  0098f	50		 push	 eax
  00990	6a 00		 push	 0
  00992	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00998	89 85 28 fb ff
	ff		 mov	 DWORD PTR _buffer$30086[ebp], eax

; 716  : 				
; 717  : 				if (!buffer)

  0099e	83 bd 28 fb ff
	ff 00		 cmp	 DWORD PTR _buffer$30086[ebp], 0
  009a5	75 0f		 jne	 SHORT $LN16@ProcessVol

; 718  : 				{
; 719  : 					Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

  009a7	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  009aa	c7 41 18 9a 00
	00 c0		 mov	 DWORD PTR [ecx+24], -1073741670 ; c000009aH

; 720  : 				}
; 721  : 				else

  009b1	e9 f8 00 00 00	 jmp	 $LN17@ProcessVol
$LN16@ProcessVol:

; 722  : 				{
; 723  : 					LARGE_INTEGER offset = pVerifyInformation->StartingOffset;

  009b6	8b 95 2c fb ff
	ff		 mov	 edx, DWORD PTR _pVerifyInformation$30080[ebp]
  009bc	8b 02		 mov	 eax, DWORD PTR [edx]
  009be	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  009c1	89 85 18 fb ff
	ff		 mov	 DWORD PTR _offset$30091[ebp], eax
  009c7	89 8d 1c fb ff
	ff		 mov	 DWORD PTR _offset$30091[ebp+4], ecx

; 724  : 					offset.QuadPart += Extension->cryptoInfo->hiddenVolume ? Extension->cryptoInfo->hiddenVolumeOffset : Extension->cryptoInfo->volDataAreaOffset;

  009cd	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  009d0	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  009d3	83 b8 a0 29 00
	00 00		 cmp	 DWORD PTR [eax+10656], 0
  009da	74 20		 je	 SHORT $LN49@ProcessVol
  009dc	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  009df	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  009e2	8b 82 18 44 00
	00		 mov	 eax, DWORD PTR [edx+17432]
  009e8	89 85 ac fa ff
	ff		 mov	 DWORD PTR tv350[ebp], eax
  009ee	8b 8a 1c 44 00
	00		 mov	 ecx, DWORD PTR [edx+17436]
  009f4	89 8d b0 fa ff
	ff		 mov	 DWORD PTR tv350[ebp+4], ecx
  009fa	eb 1e		 jmp	 SHORT $LN50@ProcessVol
$LN49@ProcessVol:
  009fc	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  009ff	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00a02	8b 88 08 44 00
	00		 mov	 ecx, DWORD PTR [eax+17416]
  00a08	89 8d ac fa ff
	ff		 mov	 DWORD PTR tv350[ebp], ecx
  00a0e	8b 90 0c 44 00
	00		 mov	 edx, DWORD PTR [eax+17420]
  00a14	89 95 b0 fa ff
	ff		 mov	 DWORD PTR tv350[ebp+4], edx
$LN50@ProcessVol:
  00a1a	8b 85 18 fb ff
	ff		 mov	 eax, DWORD PTR _offset$30091[ebp]
  00a20	03 85 ac fa ff
	ff		 add	 eax, DWORD PTR tv350[ebp]
  00a26	8b 8d 1c fb ff
	ff		 mov	 ecx, DWORD PTR _offset$30091[ebp+4]
  00a2c	13 8d b0 fa ff
	ff		 adc	 ecx, DWORD PTR tv350[ebp+4]
  00a32	89 85 18 fb ff
	ff		 mov	 DWORD PTR _offset$30091[ebp], eax
  00a38	89 8d 1c fb ff
	ff		 mov	 DWORD PTR _offset$30091[ebp+4], ecx

; 725  : 
; 726  : 					Irp->IoStatus.Status = ZwReadFile (Extension->hDeviceFile, NULL, NULL, NULL, &ioStatus, buffer, pVerifyInformation->Length, &offset, NULL);

  00a3e	6a 00		 push	 0
  00a40	8d 95 18 fb ff
	ff		 lea	 edx, DWORD PTR _offset$30091[ebp]
  00a46	52		 push	 edx
  00a47	8b 85 2c fb ff
	ff		 mov	 eax, DWORD PTR _pVerifyInformation$30080[ebp]
  00a4d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00a50	51		 push	 ecx
  00a51	8b 95 28 fb ff
	ff		 mov	 edx, DWORD PTR _buffer$30086[ebp]
  00a57	52		 push	 edx
  00a58	8d 85 20 fb ff
	ff		 lea	 eax, DWORD PTR _ioStatus$30085[ebp]
  00a5e	50		 push	 eax
  00a5f	6a 00		 push	 0
  00a61	6a 00		 push	 0
  00a63	6a 00		 push	 0
  00a65	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00a68	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  00a6b	52		 push	 edx
  00a6c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwReadFile@36
  00a72	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00a75	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 727  : 					TCfree (buffer);

  00a78	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00a7d	8b 95 28 fb ff
	ff		 mov	 edx, DWORD PTR _buffer$30086[ebp]
  00a83	52		 push	 edx
  00a84	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 728  : 
; 729  : 					if (NT_SUCCESS (Irp->IoStatus.Status) && ioStatus.Information != pVerifyInformation->Length)

  00a8a	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  00a8d	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00a91	7c 1b		 jl	 SHORT $LN17@ProcessVol
  00a93	8b 8d 2c fb ff
	ff		 mov	 ecx, DWORD PTR _pVerifyInformation$30080[ebp]
  00a99	8b 95 24 fb ff
	ff		 mov	 edx, DWORD PTR _ioStatus$30085[ebp+4]
  00a9f	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00aa2	74 0a		 je	 SHORT $LN17@ProcessVol

; 730  : 						Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  00aa4	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  00aa7	c7 40 18 0d 00
	00 c0		 mov	 DWORD PTR [eax+24], -1073741811 ; c000000dH
$LN17@ProcessVol:

; 731  : 				}
; 732  : 			}
; 733  : 
; 734  : 			Irp->IoStatus.Information = 0;

  00aae	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00ab1	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0
$LN19@ProcessVol:

; 735  : 		}
; 736  : 		break;

  00ab8	e9 1a 01 00 00	 jmp	 $LN43@ProcessVol
$LN13@ProcessVol:

; 737  : 
; 738  : 	case IOCTL_DISK_CHECK_VERIFY:
; 739  : 	case IOCTL_STORAGE_CHECK_VERIFY:
; 740  : 		{
; 741  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00abd	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  00ac0	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 742  : 			Irp->IoStatus.Information = 0;

  00ac7	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  00aca	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 743  : 
; 744  : 			if (irpSp->Parameters.DeviceIoControl.OutputBufferLength >= sizeof (ULONG))

  00ad1	8b 4d fc	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  00ad4	83 79 04 04	 cmp	 DWORD PTR [ecx+4], 4
  00ad8	72 16		 jb	 SHORT $LN12@ProcessVol

; 745  : 			{
; 746  : 				*((ULONG *) Irp->AssociatedIrp.SystemBuffer) = 0;

  00ada	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  00add	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00ae0	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 747  : 				Irp->IoStatus.Information = sizeof (ULONG);

  00ae6	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00ae9	c7 41 1c 04 00
	00 00		 mov	 DWORD PTR [ecx+28], 4
$LN12@ProcessVol:

; 748  : 			}
; 749  : 		}
; 750  : 		break;

  00af0	e9 e2 00 00 00	 jmp	 $LN43@ProcessVol
$LN11@ProcessVol:

; 751  : 
; 752  : 	case IOCTL_DISK_IS_WRITABLE:
; 753  : 		{
; 754  : 			if (Extension->bReadOnly)

  00af5	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  00af8	83 ba 88 02 00
	00 00		 cmp	 DWORD PTR [edx+648], 0
  00aff	74 0c		 je	 SHORT $LN10@ProcessVol

; 755  : 				Irp->IoStatus.Status = STATUS_MEDIA_WRITE_PROTECTED;

  00b01	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  00b04	c7 40 18 a2 00
	00 c0		 mov	 DWORD PTR [eax+24], -1073741662 ; c00000a2H

; 756  : 			else

  00b0b	eb 0a		 jmp	 SHORT $LN9@ProcessVol
$LN10@ProcessVol:

; 757  : 				Irp->IoStatus.Status = STATUS_SUCCESS;

  00b0d	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00b10	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
$LN9@ProcessVol:

; 758  : 			Irp->IoStatus.Information = 0;

  00b17	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  00b1a	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 759  : 
; 760  : 		}
; 761  : 		break;

  00b21	e9 b1 00 00 00	 jmp	 $LN43@ProcessVol
$LN8@ProcessVol:

; 762  : 		
; 763  : 	case IOCTL_VOLUME_ONLINE:
; 764  : 		Irp->IoStatus.Status = STATUS_SUCCESS;

  00b26	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  00b29	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 765  : 		Irp->IoStatus.Information = 0;

  00b30	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00b33	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 766  : 		break;

  00b3a	e9 98 00 00 00	 jmp	 $LN43@ProcessVol
$LN7@ProcessVol:

; 767  : 
; 768  : 	case IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS:
; 769  : 
; 770  : 		// Vista's filesystem defragmenter fails if IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS does not succeed.
; 771  : 		if (!(OsMajorVersion == 6 && OsMinorVersion == 0))

  00b3f	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _OsMajorVersion, 6
  00b46	75 09		 jne	 SHORT $LN5@ProcessVol
  00b48	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _OsMinorVersion, 0
  00b4f	74 16		 je	 SHORT $LN6@ProcessVol
$LN5@ProcessVol:

; 772  : 		{
; 773  : 			Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;

  00b51	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  00b54	c7 42 18 10 00
	00 c0		 mov	 DWORD PTR [edx+24], -1073741808 ; c0000010H

; 774  : 			Irp->IoStatus.Information = 0;

  00b5b	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  00b5e	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
  00b65	eb 5c		 jmp	 SHORT $LN4@ProcessVol
$LN6@ProcessVol:

; 775  : 		}
; 776  : 		else if (ValidateIOBufferSize (Irp, sizeof (VOLUME_DISK_EXTENTS), ValidateOutput))

  00b67	6a 01		 push	 1
  00b69	6a 20		 push	 32			; 00000020H
  00b6b	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00b6e	51		 push	 ecx
  00b6f	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00b74	85 c0		 test	 eax, eax
  00b76	74 4b		 je	 SHORT $LN4@ProcessVol

; 777  : 		{
; 778  : 			VOLUME_DISK_EXTENTS *extents = (VOLUME_DISK_EXTENTS *) Irp->AssociatedIrp.SystemBuffer;

  00b78	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  00b7b	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00b7e	89 85 14 fb ff
	ff		 mov	 DWORD PTR _extents$30119[ebp], eax

; 779  : 
; 780  : 			// No extent data can be returned as this is not a physical drive.
; 781  : 			memset (extents, 0, sizeof (*extents));

  00b84	33 c9		 xor	 ecx, ecx
  00b86	8b 95 14 fb ff
	ff		 mov	 edx, DWORD PTR _extents$30119[ebp]
  00b8c	89 0a		 mov	 DWORD PTR [edx], ecx
  00b8e	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00b91	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00b94	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00b97	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
  00b9a	89 4a 14	 mov	 DWORD PTR [edx+20], ecx
  00b9d	89 4a 18	 mov	 DWORD PTR [edx+24], ecx
  00ba0	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 782  : 			extents->NumberOfDiskExtents = 0;

  00ba3	8b 85 14 fb ff
	ff		 mov	 eax, DWORD PTR _extents$30119[ebp]
  00ba9	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 783  : 
; 784  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00baf	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00bb2	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 785  : 			Irp->IoStatus.Information = sizeof (*extents);

  00bb9	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  00bbc	c7 42 1c 20 00
	00 00		 mov	 DWORD PTR [edx+28], 32	; 00000020H
$LN4@ProcessVol:

; 786  : 		}
; 787  : 		break;

  00bc3	eb 12		 jmp	 SHORT $LN43@ProcessVol
$LN2@ProcessVol:

; 788  : 
; 789  : 	default:
; 790  : 		return TCCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);

  00bc5	6a 00		 push	 0
  00bc7	68 10 00 00 c0	 push	 -1073741808		; c0000010H
  00bcc	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  00bcf	50		 push	 eax
  00bd0	e8 00 00 00 00	 call	 _TCCompleteIrp@12
  00bd5	eb 4d		 jmp	 SHORT $LN45@ProcessVol
$LN43@ProcessVol:

; 791  : 	}
; 792  : 
; 793  : #ifdef DEBUG
; 794  : 	if (!NT_SUCCESS (Irp->IoStatus.Status))

  00bd7	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00bda	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  00bde	7d 2d		 jge	 SHORT $LN1@ProcessVol

; 795  : 	{
; 796  : 		Dump ("IOCTL error 0x%08x (0x%x %d)\n",
; 797  : 			Irp->IoStatus.Status,
; 798  : 			(int) (irpSp->Parameters.DeviceIoControl.IoControlCode >> 16),
; 799  : 			(int) ((irpSp->Parameters.DeviceIoControl.IoControlCode & 0x1FFF) >> 2));

  00be0	8b 55 fc	 mov	 edx, DWORD PTR _irpSp$[ebp]
  00be3	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00be6	25 ff 1f 00 00	 and	 eax, 8191		; 00001fffH
  00beb	c1 e8 02	 shr	 eax, 2
  00bee	50		 push	 eax
  00bef	8b 4d fc	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  00bf2	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00bf5	c1 ea 10	 shr	 edx, 16			; 00000010H
  00bf8	52		 push	 edx
  00bf9	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  00bfc	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00bff	51		 push	 ecx
  00c00	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@BEMMNDOD@IOCTL?5error?50x?$CF08x?5?$CI0x?$CFx?5?$CFd?$CJ?6?$AA@FNODOBFM@
  00c05	e8 00 00 00 00	 call	 _DbgPrint
  00c0a	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@ProcessVol:

; 800  : 	}
; 801  : #endif
; 802  : 
; 803  : 	return TCCompleteDiskIrp (Irp, Irp->IoStatus.Status, Irp->IoStatus.Information);

  00c0d	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  00c10	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00c13	50		 push	 eax
  00c14	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00c17	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00c1a	52		 push	 edx
  00c1b	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  00c1e	50		 push	 eax
  00c1f	e8 00 00 00 00	 call	 _TCCompleteDiskIrp@12
$LN45@ProcessVol:

; 804  : }

  00c24	5f		 pop	 edi
  00c25	5e		 pop	 esi
  00c26	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c29	33 cd		 xor	 ecx, ebp
  00c2b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c30	8b e5		 mov	 esp, ebp
  00c32	5d		 pop	 ebp
  00c33	c2 0c 00	 ret	 12			; 0000000cH
_ProcessVolumeDeviceControlIrp@12 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@MLCKFMJI@IOCTL?5error?50x?$CF08x?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_UnmountAllDevices@8
PUBLIC	_UnmountDevice@12
PUBLIC	_RtlSecureZeroMemory@8
PUBLIC	_MountDevice@8
PUBLIC	_ProbeRealDriveSize@8
PUBLIC	_SymbolicLinkToTarget@12
PUBLIC	_IsVolumeAccessibleByCurrentUser@4
PUBLIC	??_C@_0BH@GFMHOPFN@Setting?5portable?5mode?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_UserCanAccessDriveDevice@0
PUBLIC	??_C@_0CA@FCHCHJKN@Open?5test?5on?5file?5?$CFls?5success?4?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_09EMKKFGIH@TrueCrypt?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0L@FEEFGEIL@CipherShed?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	_EnsureNullTerminatedString@8
PUBLIC	__$ArrayPad$
EXTRN	_IsHwEncryptionEnabled@0:PROC
EXTRN	_GetBootDriveFilterExtension@0:PROC
EXTRN	_WriteBootDriveSector@8:PROC
EXTRN	_GetDecoySystemWipeStatus@8:PROC
EXTRN	_GetDecoySystemWipeResult@0:PROC
EXTRN	_AbortDecoySystemWipe@0:PROC
EXTRN	_StartDecoySystemWipe@12:PROC
EXTRN	_IsHiddenSystemRunning@0:PROC
EXTRN	_GetBootEncryptionAlgorithmName@8:PROC
EXTRN	_ReopenBootVolumeHeader@8:PROC
EXTRN	_GetBootLoaderVersion@8:PROC
EXTRN	_GetBootDriveVolumeProperties@8:PROC
EXTRN	_GetSetupResult@0:PROC
EXTRN	_GetBootEncryptionStatus@8:PROC
EXTRN	_AbortBootEncryptionSetup@0:PROC
EXTRN	_StartBootEncryptionSetup@12:PROC
EXTRN	__imp_@ObfDereferenceObject@4:PROC
EXTRN	__imp__IoGetDeviceObjectPointer@16:PROC
EXTRN	_cacheEmpty:DWORD
EXTRN	_WipeCache@0:PROC
EXTRN	_MirrorBytes16@4:PROC
EXTRN	__imp__ZwClose@4:PROC
EXTRN	_MirrorBytes64@8:PROC
EXTRN	__imp__ZwCreateFile@44:PROC
EXTRN	_IsBootDriveMounted@0:PROC
EXTRN	__imp__IoEnumerateDeviceObjectList@16:PROC
;	COMDAT ??_C@_0BE@MLCKFMJI@IOCTL?5error?50x?$CF08x?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BE@MLCKFMJI@IOCTL?5error?50x?$CF08x?6?$AA@FNODOBFM@ DB 'IOCTL erro'
	DB	'r 0x%08x', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BH@GFMHOPFN@Setting?5portable?5mode?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BH@GFMHOPFN@Setting?5portable?5mode?6?$AA@FNODOBFM@ DB 'Setting po'
	DB	'rtable mode', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CA@FCHCHJKN@Open?5test?5on?5file?5?$CFls?5success?4?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0CA@FCHCHJKN@Open?5test?5on?5file?5?$CFls?5success?4?6?$AA@FNODOBFM@ DB 'O'
	DB	'pen test on file %ls success.', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_09EMKKFGIH@TrueCrypt?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09EMKKFGIH@TrueCrypt?$AA@FNODOBFM@ DB 'TrueCrypt', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0L@FEEFGEIL@CipherShed?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0L@FEEFGEIL@CipherShed?$AA@FNODOBFM@ DB 'CipherShed', 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _ProcessMainDeviceControlIrp@12
_TEXT	SEGMENT
tv960 = -996						; size = 4
tv542 = -990						; size = 2
tv541 = -988						; size = 4
tv540 = -984						; size = 4
tv538 = -980						; size = 4
tv462 = -974						; size = 2
tv461 = -972						; size = 4
tv460 = -968						; size = 4
tv455 = -964						; size = 4
tv245 = -960						; size = 8
tv67 = -952						; size = 4
_request$30482 = -948					; size = 4
_flags$30469 = -944					; size = 4
_unmount$30443 = -940					; size = 4
_ListExtension$30435 = -936				; size = 4
_ListDevice$30433 = -932				; size = 4
_unmount$30431 = -928					; size = 4
_burnm$30422 = -924					; size = 4
_burnc$30424 = -920					; size = 4
_burnm$30413 = -916					; size = 4
_burnc$30415 = -912					; size = 4
_mount$30404 = -908					; size = 4
_status$30386 = -904					; size = 4
_request$30384 = -900					; size = 4
_name$30387 = -896					; size = 8
_fileObject$30388 = -888				; size = 4
_deviceObject$30389 = -884				; size = 4
_ntStatus$30378 = -880					; size = 4
_g$30376 = -876						; size = 4
_lengthInfo$30363 = -872				; size = 8
_ntStatus$30354 = -860					; size = 4
_pi$30353 = -856					; size = 144
_info$30351 = -712					; size = 4
_ntStatus$30346 = -708					; size = 4
_resolve$30344 = -704					; size = 4
_ListExtension$30334 = -700				; size = 4
_prop$30329 = -696					; size = 4
_ListDevice$30331 = -692				; size = 4
_ListExtension$30309 = -688				; size = 4
_ListDevice$30304 = -684				; size = 4
_drive$30305 = -680					; size = 4
_list$30302 = -676					; size = 4
_i$30265 = -672						; size = 4
_i$30263 = -668						; size = 4
_NtFileHandle$30242 = -664				; size = 4
_IoStatus$30244 = -660					; size = 8
_request$30239 = -652					; size = 4
_ObjectAttributes$30241 = -648				; size = 24
_offset$30245 = -624					; size = 8
_readBuffer$30246 = -616				; size = 512
__$ArrayPad$ = -100					; size = 4
_FullFileName$30243 = -96				; size = 8
_i$30213 = -88						; size = 4
_readBuffer$30202 = -84					; size = 4
_NtFileHandle$30183 = -80				; size = 4
_IoStatus$30185 = -76					; size = 8
_ObjectAttributes$30182 = -68				; size = 24
_opentest$30180 = -44					; size = 4
_offset$30186 = -40					; size = 8
_access$30187 = -32					; size = 4
_FullFileName$30184 = -28				; size = 8
_drive$30168 = -20					; size = 4
_deviceObjectCount$30157 = -16				; size = 4
_tmp$30145 = -12					; size = 4
_irpSp$ = -8						; size = 4
_ntStatus$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_Extension$ = 12					; size = 4
_Irp$ = 16						; size = 4
_ProcessMainDeviceControlIrp@12 PROC			; COMDAT

; 808  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec e4 03 00
	00		 sub	 esp, 996		; 000003e4H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 9c	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi
  00016	57		 push	 edi

; 809  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);

  00017	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _IoGetCurrentIrpStackLocation@4
  00020	89 45 f8	 mov	 DWORD PTR _irpSp$[ebp], eax

; 810  : 	NTSTATUS ntStatus;
; 811  : 
; 812  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  00026	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00029	89 95 48 fc ff
	ff		 mov	 DWORD PTR tv67[ebp], edx
  0002f	81 bd 48 fc ff
	ff 04 20 22 00	 cmp	 DWORD PTR tv67[ebp], 2236420 ; 00222004H
  00039	77 2d		 ja	 SHORT $LN167@ProcessMai
  0003b	81 bd 48 fc ff
	ff 04 20 22 00	 cmp	 DWORD PTR tv67[ebp], 2236420 ; 00222004H
  00045	74 56		 je	 SHORT $LN159@ProcessMai
  00047	81 bd 48 fc ff
	ff 04 20 07 00	 cmp	 DWORD PTR tv67[ebp], 466948 ; 00072004H
  00051	0f 84 bc 0b 00
	00		 je	 $LN79@ProcessMai
  00057	81 bd 48 fc ff
	ff 18 20 07 00	 cmp	 DWORD PTR tv67[ebp], 466968 ; 00072018H
  00061	74 3a		 je	 SHORT $LN159@ProcessMai
  00063	e9 41 18 00 00	 jmp	 $LN6@ProcessMai
$LN167@ProcessMai:
  00068	8b 85 48 fc ff
	ff		 mov	 eax, DWORD PTR tv67[ebp]
  0006e	2d 08 20 22 00	 sub	 eax, 2236424		; 00222008H
  00073	89 85 48 fc ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
  00079	81 bd 48 fc ff
	ff 90 00 00 00	 cmp	 DWORD PTR tv67[ebp], 144 ; 00000090H
  00083	0f 87 20 18 00
	00		 ja	 $LN6@ProcessMai
  00089	8b 8d 48 fc ff
	ff		 mov	 ecx, DWORD PTR tv67[ebp]
  0008f	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN168@ProcessMai[ecx]
  00096	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN179@ProcessMai[edx*4]
$LN159@ProcessMai:

; 813  : 	{
; 814  : 	case TC_IOCTL_GET_DRIVER_VERSION:
; 815  : 	case TC_IOCTL_LEGACY_GET_DRIVER_VERSION:
; 816  : 		if (ValidateIOBufferSize (Irp, sizeof (LONG), ValidateOutput))

  0009d	6a 01		 push	 1
  0009f	6a 04		 push	 4
  000a1	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  000aa	85 c0		 test	 eax, eax
  000ac	74 26		 je	 SHORT $LN158@ProcessMai

; 817  : 		{
; 818  : 			LONG tmp = VERSION_NUM;

  000ae	c7 45 f4 30 07
	00 00		 mov	 DWORD PTR _tmp$30145[ebp], 1840 ; 00000730H

; 819  : 			memcpy (Irp->AssociatedIrp.SystemBuffer, &tmp, 4);

  000b5	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  000b8	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000bb	8b 45 f4	 mov	 eax, DWORD PTR _tmp$30145[ebp]
  000be	89 02		 mov	 DWORD PTR [edx], eax

; 820  : 			Irp->IoStatus.Information = sizeof (LONG);

  000c0	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  000c3	c7 41 1c 04 00
	00 00		 mov	 DWORD PTR [ecx+28], 4

; 821  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  000ca	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  000cd	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0
$LN158@ProcessMai:

; 822  : 		}
; 823  : 		break;

  000d4	e9 e2 17 00 00	 jmp	 $LN160@ProcessMai
$LN157@ProcessMai:

; 824  : 
; 825  : 	case TC_IOCTL_GET_DEVICE_REFCOUNT:
; 826  : 		if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))

  000d9	6a 01		 push	 1
  000db	6a 04		 push	 4
  000dd	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  000e6	85 c0		 test	 eax, eax
  000e8	74 22		 je	 SHORT $LN156@ProcessMai

; 827  : 		{
; 828  : 			*(int *) Irp->AssociatedIrp.SystemBuffer = DeviceObject->ReferenceCount;

  000ea	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  000ed	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000f0	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  000f3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f6	89 0a		 mov	 DWORD PTR [edx], ecx

; 829  : 			Irp->IoStatus.Information = sizeof (int);

  000f8	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  000fb	c7 42 1c 04 00
	00 00		 mov	 DWORD PTR [edx+28], 4

; 830  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00102	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  00105	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
$LN156@ProcessMai:

; 831  : 		}
; 832  : 		break;

  0010c	e9 aa 17 00 00	 jmp	 $LN160@ProcessMai
$LN155@ProcessMai:

; 833  : 
; 834  : 	case TC_IOCTL_IS_DRIVER_UNLOAD_DISABLED:
; 835  : 		if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))

  00111	6a 01		 push	 1
  00113	6a 04		 push	 4
  00115	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00118	51		 push	 ecx
  00119	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  0011e	85 c0		 test	 eax, eax
  00120	74 56		 je	 SHORT $LN154@ProcessMai

; 836  : 		{
; 837  : 			LONG deviceObjectCount = 0;

  00122	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _deviceObjectCount$30157[ebp], 0

; 838  : 
; 839  : 			*(int *) Irp->AssociatedIrp.SystemBuffer = DriverUnloadDisabled;

  00129	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  0012c	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0012f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _DriverUnloadDisabled
  00135	89 08		 mov	 DWORD PTR [eax], ecx

; 840  : 
; 841  : 			if (IoEnumerateDeviceObjectList (TCDriverObject, NULL, 0, &deviceObjectCount) == STATUS_BUFFER_TOO_SMALL && deviceObjectCount > 1)

  00137	8d 55 f0	 lea	 edx, DWORD PTR _deviceObjectCount$30157[ebp]
  0013a	52		 push	 edx
  0013b	6a 00		 push	 0
  0013d	6a 00		 push	 0
  0013f	a1 00 00 00 00	 mov	 eax, DWORD PTR _TCDriverObject
  00144	50		 push	 eax
  00145	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoEnumerateDeviceObjectList@16
  0014b	3d 23 00 00 c0	 cmp	 eax, -1073741789	; c0000023H
  00150	75 12		 jne	 SHORT $LN153@ProcessMai
  00152	83 7d f0 01	 cmp	 DWORD PTR _deviceObjectCount$30157[ebp], 1
  00156	7e 0c		 jle	 SHORT $LN153@ProcessMai

; 842  : 				*(int *) Irp->AssociatedIrp.SystemBuffer = TRUE;

  00158	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  0015b	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0015e	c7 02 01 00 00
	00		 mov	 DWORD PTR [edx], 1
$LN153@ProcessMai:

; 843  : 
; 844  : 			Irp->IoStatus.Information = sizeof (int);

  00164	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  00167	c7 40 1c 04 00
	00 00		 mov	 DWORD PTR [eax+28], 4

; 845  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  0016e	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00171	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
$LN154@ProcessMai:

; 846  : 		}
; 847  : 		break;

  00178	e9 3e 17 00 00	 jmp	 $LN160@ProcessMai
$LN152@ProcessMai:

; 848  : 
; 849  : 	case TC_IOCTL_IS_ANY_VOLUME_MOUNTED:
; 850  : 		if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))

  0017d	6a 01		 push	 1
  0017f	6a 04		 push	 4
  00181	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  00184	52		 push	 edx
  00185	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  0018a	85 c0		 test	 eax, eax
  0018c	74 6a		 je	 SHORT $LN151@ProcessMai

; 851  : 		{
; 852  : 			int drive;
; 853  : 			*(int *) Irp->AssociatedIrp.SystemBuffer = 0;

  0018e	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  00191	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00194	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 854  : 
; 855  : 			for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)

  0019a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _drive$30168[ebp], 0
  001a1	eb 09		 jmp	 SHORT $LN150@ProcessMai
$LN149@ProcessMai:
  001a3	8b 55 ec	 mov	 edx, DWORD PTR _drive$30168[ebp]
  001a6	83 c2 01	 add	 edx, 1
  001a9	89 55 ec	 mov	 DWORD PTR _drive$30168[ebp], edx
$LN150@ProcessMai:
  001ac	83 7d ec 19	 cmp	 DWORD PTR _drive$30168[ebp], 25 ; 00000019H
  001b0	7f 1d		 jg	 SHORT $LN148@ProcessMai

; 856  : 			{
; 857  : 				if (GetVirtualVolumeDeviceObject (drive))

  001b2	8b 45 ec	 mov	 eax, DWORD PTR _drive$30168[ebp]
  001b5	50		 push	 eax
  001b6	e8 00 00 00 00	 call	 _GetVirtualVolumeDeviceObject@4
  001bb	85 c0		 test	 eax, eax
  001bd	74 0e		 je	 SHORT $LN147@ProcessMai

; 858  : 				{
; 859  : 					*(int *) Irp->AssociatedIrp.SystemBuffer = 1;

  001bf	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  001c2	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  001c5	c7 02 01 00 00
	00		 mov	 DWORD PTR [edx], 1

; 860  : 					break;

  001cb	eb 02		 jmp	 SHORT $LN148@ProcessMai
$LN147@ProcessMai:

; 861  : 				}
; 862  : 			}

  001cd	eb d4		 jmp	 SHORT $LN149@ProcessMai
$LN148@ProcessMai:

; 863  : 
; 864  : 			if (IsBootDriveMounted())

  001cf	e8 00 00 00 00	 call	 _IsBootDriveMounted@0
  001d4	85 c0		 test	 eax, eax
  001d6	74 0c		 je	 SHORT $LN146@ProcessMai

; 865  : 				*(int *) Irp->AssociatedIrp.SystemBuffer = 1;

  001d8	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  001db	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001de	c7 01 01 00 00
	00		 mov	 DWORD PTR [ecx], 1
$LN146@ProcessMai:

; 866  : 
; 867  : 			Irp->IoStatus.Information = sizeof (int);

  001e4	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  001e7	c7 42 1c 04 00
	00 00		 mov	 DWORD PTR [edx+28], 4

; 868  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  001ee	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  001f1	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
$LN151@ProcessMai:

; 869  : 		}
; 870  : 		break;

  001f8	e9 be 16 00 00	 jmp	 $LN160@ProcessMai
$LN145@ProcessMai:

; 871  : 
; 872  : 	case TC_IOCTL_OPEN_TEST:
; 873  : 		{
; 874  : 			OPEN_TEST_STRUCT *opentest = (OPEN_TEST_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  001fd	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00200	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00203	89 55 d4	 mov	 DWORD PTR _opentest$30180[ebp], edx

; 875  : 			OBJECT_ATTRIBUTES ObjectAttributes;
; 876  : 			HANDLE NtFileHandle;
; 877  : 			UNICODE_STRING FullFileName;
; 878  : 			IO_STATUS_BLOCK IoStatus;
; 879  : 			LARGE_INTEGER offset;
; 880  : 			ACCESS_MASK access = FILE_READ_ATTRIBUTES;

  00206	c7 45 e0 80 00
	00 00		 mov	 DWORD PTR _access$30187[ebp], 128 ; 00000080H

; 881  : 
; 882  : 			if (!ValidateIOBufferSize (Irp, sizeof (OPEN_TEST_STRUCT), ValidateInputOutput))

  0020d	6a 02		 push	 2
  0020f	68 18 02 00 00	 push	 536			; 00000218H
  00214	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  00217	50		 push	 eax
  00218	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  0021d	85 c0		 test	 eax, eax
  0021f	75 05		 jne	 SHORT $LN144@ProcessMai

; 883  : 				break;

  00221	e9 95 16 00 00	 jmp	 $LN160@ProcessMai
$LN144@ProcessMai:

; 884  : 
; 885  : 			EnsureNullTerminatedString (opentest->wszFileName, sizeof (opentest->wszFileName));

  00226	68 08 02 00 00	 push	 520			; 00000208H
  0022b	8b 4d d4	 mov	 ecx, DWORD PTR _opentest$30180[ebp]
  0022e	51		 push	 ecx
  0022f	e8 00 00 00 00	 call	 _EnsureNullTerminatedString@8

; 886  : 			RtlInitUnicodeString (&FullFileName, opentest->wszFileName);

  00234	8b 55 d4	 mov	 edx, DWORD PTR _opentest$30180[ebp]
  00237	52		 push	 edx
  00238	8d 45 e4	 lea	 eax, DWORD PTR _FullFileName$30184[ebp]
  0023b	50		 push	 eax
  0023c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 887  : 
; 888  : 			InitializeObjectAttributes (&ObjectAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

  00242	c7 45 bc 18 00
	00 00		 mov	 DWORD PTR _ObjectAttributes$30182[ebp], 24 ; 00000018H
  00249	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _ObjectAttributes$30182[ebp+4], 0
  00250	c7 45 c8 40 02
	00 00		 mov	 DWORD PTR _ObjectAttributes$30182[ebp+12], 576 ; 00000240H
  00257	8d 4d e4	 lea	 ecx, DWORD PTR _FullFileName$30184[ebp]
  0025a	89 4d c4	 mov	 DWORD PTR _ObjectAttributes$30182[ebp+8], ecx
  0025d	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _ObjectAttributes$30182[ebp+16], 0
  00264	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _ObjectAttributes$30182[ebp+20], 0

; 889  : 
; 890  : 			if (opentest->bDetectTCBootLoader || opentest->DetectFilesystem)

  0026b	8b 55 d4	 mov	 edx, DWORD PTR _opentest$30180[ebp]
  0026e	83 ba 08 02 00
	00 00		 cmp	 DWORD PTR [edx+520], 0
  00275	75 0c		 jne	 SHORT $LN142@ProcessMai
  00277	8b 45 d4	 mov	 eax, DWORD PTR _opentest$30180[ebp]
  0027a	83 b8 10 02 00
	00 00		 cmp	 DWORD PTR [eax+528], 0
  00281	74 09		 je	 SHORT $LN143@ProcessMai
$LN142@ProcessMai:

; 891  : 				access |= FILE_READ_DATA;

  00283	8b 4d e0	 mov	 ecx, DWORD PTR _access$30187[ebp]
  00286	83 c9 01	 or	 ecx, 1
  00289	89 4d e0	 mov	 DWORD PTR _access$30187[ebp], ecx
$LN143@ProcessMai:

; 892  : 
; 893  : 			ntStatus = ZwCreateFile (&NtFileHandle,
; 894  : 						 SYNCHRONIZE | access, &ObjectAttributes, &IoStatus, NULL,
; 895  : 						 0, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);

  0028c	6a 00		 push	 0
  0028e	6a 00		 push	 0
  00290	6a 20		 push	 32			; 00000020H
  00292	6a 01		 push	 1
  00294	6a 03		 push	 3
  00296	6a 00		 push	 0
  00298	6a 00		 push	 0
  0029a	8d 55 b4	 lea	 edx, DWORD PTR _IoStatus$30185[ebp]
  0029d	52		 push	 edx
  0029e	8d 45 bc	 lea	 eax, DWORD PTR _ObjectAttributes$30182[ebp]
  002a1	50		 push	 eax
  002a2	8b 4d e0	 mov	 ecx, DWORD PTR _access$30187[ebp]
  002a5	81 c9 00 00 10
	00		 or	 ecx, 1048576		; 00100000H
  002ab	51		 push	 ecx
  002ac	8d 55 b0	 lea	 edx, DWORD PTR _NtFileHandle$30183[ebp]
  002af	52		 push	 edx
  002b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwCreateFile@44
  002b6	89 45 fc	 mov	 DWORD PTR _ntStatus$[ebp], eax

; 896  : 
; 897  : 			if (NT_SUCCESS (ntStatus))

  002b9	83 7d fc 00	 cmp	 DWORD PTR _ntStatus$[ebp], 0
  002bd	0f 8c 3b 02 00
	00		 jl	 $LN121@ProcessMai

; 898  : 			{
; 899  : 				opentest->TCBootLoaderDetected = FALSE;

  002c3	8b 45 d4	 mov	 eax, DWORD PTR _opentest$30180[ebp]
  002c6	c7 80 0c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+524], 0

; 900  : 				opentest->FilesystemDetected = FALSE;

  002d0	8b 4d d4	 mov	 ecx, DWORD PTR _opentest$30180[ebp]
  002d3	c7 81 14 02 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+532], 0

; 901  : 
; 902  : 				if (opentest->bDetectTCBootLoader || opentest->DetectFilesystem)

  002dd	8b 55 d4	 mov	 edx, DWORD PTR _opentest$30180[ebp]
  002e0	83 ba 08 02 00
	00 00		 cmp	 DWORD PTR [edx+520], 0
  002e7	75 10		 jne	 SHORT $LN139@ProcessMai
  002e9	8b 45 d4	 mov	 eax, DWORD PTR _opentest$30180[ebp]
  002ec	83 b8 10 02 00
	00 00		 cmp	 DWORD PTR [eax+528], 0
  002f3	0f 84 ea 01 00
	00		 je	 $LN140@ProcessMai
$LN139@ProcessMai:

; 903  : 				{
; 904  : 					byte *readBuffer = TCalloc (TC_MAX_VOLUME_SECTOR_SIZE);

  002f9	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  002fe	68 00 10 00 00	 push	 4096			; 00001000H
  00303	6a 00		 push	 0
  00305	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0030b	89 45 ac	 mov	 DWORD PTR _readBuffer$30202[ebp], eax

; 905  : 					if (!readBuffer)

  0030e	83 7d ac 00	 cmp	 DWORD PTR _readBuffer$30202[ebp], 0
  00312	75 0c		 jne	 SHORT $LN138@ProcessMai

; 906  : 					{
; 907  : 						ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00314	c7 45 fc 9a 00
	00 c0		 mov	 DWORD PTR _ntStatus$[ebp], -1073741670 ; c000009aH

; 908  : 					}
; 909  : 					else

  0031b	e9 c3 01 00 00	 jmp	 $LN140@ProcessMai
$LN138@ProcessMai:

; 910  : 					{
; 911  : 						// Determine if the first sector contains a portion of the TrueCrypt Boot Loader
; 912  : 
; 913  : 						offset.QuadPart = 0;

  00320	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _offset$30186[ebp], 0
  00327	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _offset$30186[ebp+4], 0

; 914  : 
; 915  : 						ntStatus = ZwReadFile (NtFileHandle,
; 916  : 							NULL,
; 917  : 							NULL,
; 918  : 							NULL,
; 919  : 							&IoStatus,
; 920  : 							readBuffer,
; 921  : 							TC_MAX_VOLUME_SECTOR_SIZE,
; 922  : 							&offset,
; 923  : 							NULL);

  0032e	6a 00		 push	 0
  00330	8d 4d d8	 lea	 ecx, DWORD PTR _offset$30186[ebp]
  00333	51		 push	 ecx
  00334	68 00 10 00 00	 push	 4096			; 00001000H
  00339	8b 55 ac	 mov	 edx, DWORD PTR _readBuffer$30202[ebp]
  0033c	52		 push	 edx
  0033d	8d 45 b4	 lea	 eax, DWORD PTR _IoStatus$30185[ebp]
  00340	50		 push	 eax
  00341	6a 00		 push	 0
  00343	6a 00		 push	 0
  00345	6a 00		 push	 0
  00347	8b 4d b0	 mov	 ecx, DWORD PTR _NtFileHandle$30183[ebp]
  0034a	51		 push	 ecx
  0034b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwReadFile@36
  00351	89 45 fc	 mov	 DWORD PTR _ntStatus$[ebp], eax

; 924  : 
; 925  : 						if (NT_SUCCESS (ntStatus))

  00354	83 7d fc 00	 cmp	 DWORD PTR _ntStatus$[ebp], 0
  00358	0f 8c 76 01 00
	00		 jl	 $LN136@ProcessMai

; 926  : 						{
; 927  : 							size_t i;
; 928  : 
; 929  : 							if (opentest->bDetectTCBootLoader && IoStatus.Information >= TC_SECTOR_SIZE_BIOS)

  0035e	8b 55 d4	 mov	 edx, DWORD PTR _opentest$30180[ebp]
  00361	83 ba 08 02 00
	00 00		 cmp	 DWORD PTR [edx+520], 0
  00368	0f 84 a6 00 00
	00		 je	 $LN135@ProcessMai
  0036e	81 7d b8 00 02
	00 00		 cmp	 DWORD PTR _IoStatus$30185[ebp+4], 512 ; 00000200H
  00375	0f 82 99 00 00
	00		 jb	 $LN135@ProcessMai

; 930  : 							{
; 931  : 								// Search for the string "CipherShed"
; 932  : 								for (i = 0; i < TC_SECTOR_SIZE_BIOS - strlen (TC_APP_NAME); ++i)

  0037b	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _i$30213[ebp], 0
  00382	eb 09		 jmp	 SHORT $LN134@ProcessMai
$LN133@ProcessMai:
  00384	8b 45 a8	 mov	 eax, DWORD PTR _i$30213[ebp]
  00387	83 c0 01	 add	 eax, 1
  0038a	89 45 a8	 mov	 DWORD PTR _i$30213[ebp], eax
$LN134@ProcessMai:
  0038d	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00392	83 e9 0a	 sub	 ecx, 10			; 0000000aH
  00395	39 4d a8	 cmp	 DWORD PTR _i$30213[ebp], ecx
  00398	73 28		 jae	 SHORT $LN132@ProcessMai

; 933  : 								{
; 934  : 									if (memcmp (readBuffer + i, TC_APP_NAME, strlen (TC_APP_NAME)) == 0)

  0039a	b9 05 00 00 00	 mov	 ecx, 5
  0039f	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_0L@FEEFGEIL@CipherShed?$AA@FNODOBFM@
  003a4	8b 75 ac	 mov	 esi, DWORD PTR _readBuffer$30202[ebp]
  003a7	03 75 a8	 add	 esi, DWORD PTR _i$30213[ebp]
  003aa	33 d2		 xor	 edx, edx
  003ac	66 f3 a7	 repe cmpsw
  003af	75 0f		 jne	 SHORT $LN131@ProcessMai

; 935  : 									{
; 936  : 										opentest->TCBootLoaderDetected = TRUE;

  003b1	8b 45 d4	 mov	 eax, DWORD PTR _opentest$30180[ebp]
  003b4	c7 80 0c 02 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+524], 1

; 937  : 										break;

  003be	eb 02		 jmp	 SHORT $LN132@ProcessMai
$LN131@ProcessMai:

; 938  : 									}
; 939  : 								}

  003c0	eb c2		 jmp	 SHORT $LN133@ProcessMai
$LN132@ProcessMai:

; 940  : 
; 941  : 								// Search for the string "TrueCrypt"
; 942  : 								if (!(opentest->TCBootLoaderDetected))

  003c2	8b 4d d4	 mov	 ecx, DWORD PTR _opentest$30180[ebp]
  003c5	83 b9 0c 02 00
	00 00		 cmp	 DWORD PTR [ecx+524], 0
  003cc	75 46		 jne	 SHORT $LN135@ProcessMai

; 943  : 								for (i = 0; i < TC_SECTOR_SIZE_BIOS - strlen (TC_APP_NAME_LEGACY); ++i)

  003ce	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _i$30213[ebp], 0
  003d5	eb 09		 jmp	 SHORT $LN129@ProcessMai
$LN128@ProcessMai:
  003d7	8b 55 a8	 mov	 edx, DWORD PTR _i$30213[ebp]
  003da	83 c2 01	 add	 edx, 1
  003dd	89 55 a8	 mov	 DWORD PTR _i$30213[ebp], edx
$LN129@ProcessMai:
  003e0	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  003e5	83 e8 09	 sub	 eax, 9
  003e8	39 45 a8	 cmp	 DWORD PTR _i$30213[ebp], eax
  003eb	73 27		 jae	 SHORT $LN135@ProcessMai

; 944  : 								{
; 945  : 									if (memcmp (readBuffer + i, TC_APP_NAME_LEGACY, strlen (TC_APP_NAME_LEGACY)) == 0)

  003ed	b9 09 00 00 00	 mov	 ecx, 9
  003f2	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_09EMKKFGIH@TrueCrypt?$AA@FNODOBFM@
  003f7	8b 75 ac	 mov	 esi, DWORD PTR _readBuffer$30202[ebp]
  003fa	03 75 a8	 add	 esi, DWORD PTR _i$30213[ebp]
  003fd	33 d2		 xor	 edx, edx
  003ff	f3 a6		 repe cmpsb
  00401	75 0f		 jne	 SHORT $LN126@ProcessMai

; 946  : 									{
; 947  : 										opentest->TCBootLoaderDetected = TRUE;

  00403	8b 45 d4	 mov	 eax, DWORD PTR _opentest$30180[ebp]
  00406	c7 80 0c 02 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+524], 1

; 948  : 										break;

  00410	eb 02		 jmp	 SHORT $LN135@ProcessMai
$LN126@ProcessMai:

; 949  : 									}
; 950  : 								}

  00412	eb c3		 jmp	 SHORT $LN128@ProcessMai
$LN135@ProcessMai:

; 951  : 							}
; 952  : 
; 953  : 							if (opentest->DetectFilesystem && IoStatus.Information >= sizeof (int64))

  00414	8b 4d d4	 mov	 ecx, DWORD PTR _opentest$30180[ebp]
  00417	83 b9 10 02 00
	00 00		 cmp	 DWORD PTR [ecx+528], 0
  0041e	0f 84 b0 00 00
	00		 je	 $LN136@ProcessMai
  00424	83 7d b8 08	 cmp	 DWORD PTR _IoStatus$30185[ebp+4], 8
  00428	0f 82 a6 00 00
	00		 jb	 $LN136@ProcessMai

; 954  : 							{
; 955  : 								switch (BE64 (*(uint64 *) readBuffer))

  0042e	8b 55 ac	 mov	 edx, DWORD PTR _readBuffer$30202[ebp]
  00431	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00434	50		 push	 eax
  00435	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00437	51		 push	 ecx
  00438	e8 00 00 00 00	 call	 _MirrorBytes64@8
  0043d	89 85 40 fc ff
	ff		 mov	 DWORD PTR tv245[ebp], eax
  00443	89 95 44 fc ff
	ff		 mov	 DWORD PTR tv245[ebp+4], edx
  00449	81 bd 44 fc ff
	ff 4d 90 58 eb	 cmp	 DWORD PTR tv245[ebp+4], -346517427 ; eb58904dH
  00453	77 58		 ja	 SHORT $LN164@ProcessMai
  00455	72 0c		 jb	 SHORT $LN171@ProcessMai
  00457	81 bd 40 fc ff
	ff 53 4f 44 53	 cmp	 DWORD PTR tv245[ebp], 1396985683 ; 53444f53H
  00461	77 4a		 ja	 SHORT $LN164@ProcessMai
$LN171@ProcessMai:
  00463	81 bd 40 fc ff
	ff 53 4f 44 53	 cmp	 DWORD PTR tv245[ebp], 1396985683 ; 53444f53H
  0046d	75 0c		 jne	 SHORT $LN172@ProcessMai
  0046f	81 bd 44 fc ff
	ff 4d 90 58 eb	 cmp	 DWORD PTR tv245[ebp+4], -346517427 ; eb58904dH
  00479	74 4c		 je	 SHORT $LN122@ProcessMai
$LN172@ProcessMai:
  0047b	81 bd 40 fc ff
	ff 53 4f 44 53	 cmp	 DWORD PTR tv245[ebp], 1396985683 ; 53444f53H
  00485	75 0c		 jne	 SHORT $LN173@ProcessMai
  00487	81 bd 44 fc ff
	ff 4d 90 3c eb	 cmp	 DWORD PTR tv245[ebp+4], -348352435 ; eb3c904dH
  00491	74 34		 je	 SHORT $LN122@ProcessMai
$LN173@ProcessMai:
  00493	81 bd 40 fc ff
	ff 20 53 46 54	 cmp	 DWORD PTR tv245[ebp], 1413894944 ; 54465320H
  0049d	75 0c		 jne	 SHORT $LN174@ProcessMai
  0049f	81 bd 44 fc ff
	ff 4e 90 52 eb	 cmp	 DWORD PTR tv245[ebp+4], -346910642 ; eb52904eH
  004a9	74 1c		 je	 SHORT $LN122@ProcessMai
$LN174@ProcessMai:
  004ab	eb 27		 jmp	 SHORT $LN136@ProcessMai
$LN164@ProcessMai:
  004ad	81 bd 40 fc ff
	ff 54 41 46 58	 cmp	 DWORD PTR tv245[ebp], 1480999252 ; 58464154H
  004b7	75 0c		 jne	 SHORT $LN175@ProcessMai
  004b9	81 bd 44 fc ff
	ff 45 90 76 eb	 cmp	 DWORD PTR tv245[ebp+4], -344551355 ; eb769045H
  004c3	74 02		 je	 SHORT $LN122@ProcessMai
$LN175@ProcessMai:
  004c5	eb 0d		 jmp	 SHORT $LN136@ProcessMai
$LN122@ProcessMai:

; 956  : 								{
; 957  : 								case 0xEB52904E54465320: // NTFS
; 958  : 								case 0xEB3C904D53444F53: // FAT16
; 959  : 								case 0xEB58904D53444F53: // FAT32
; 960  : 								case 0xEB76904558464154: // exFAT
; 961  : 
; 962  : 									opentest->FilesystemDetected = TRUE;

  004c7	8b 55 d4	 mov	 edx, DWORD PTR _opentest$30180[ebp]
  004ca	c7 82 14 02 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+532], 1
$LN136@ProcessMai:

; 963  : 									break;
; 964  : 								}
; 965  : 							}
; 966  : 						}
; 967  : 
; 968  : 						TCfree (readBuffer);

  004d4	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  004d9	8b 45 ac	 mov	 eax, DWORD PTR _readBuffer$30202[ebp]
  004dc	50		 push	 eax
  004dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN140@ProcessMai:

; 969  : 					}
; 970  : 				}
; 971  : 
; 972  : 				ZwClose (NtFileHandle);

  004e3	8b 4d b0	 mov	 ecx, DWORD PTR _NtFileHandle$30183[ebp]
  004e6	51		 push	 ecx
  004e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 973  : 				Dump ("Open test on file %ls success.\n", opentest->wszFileName);

  004ed	8b 55 d4	 mov	 edx, DWORD PTR _opentest$30180[ebp]
  004f0	52		 push	 edx
  004f1	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@FCHCHJKN@Open?5test?5on?5file?5?$CFls?5success?4?6?$AA@FNODOBFM@
  004f6	e8 00 00 00 00	 call	 _DbgPrint
  004fb	83 c4 08	 add	 esp, 8
$LN121@ProcessMai:

; 974  : 			}
; 975  : 			else
; 976  : 			{
; 977  : #if 0
; 978  : 				Dump ("Open test on file %ls failed NTSTATUS 0x%08x\n", opentest->wszFileName, ntStatus);
; 979  : #endif
; 980  : 			}
; 981  : 
; 982  : 			Irp->IoStatus.Information = NT_SUCCESS (ntStatus) ? sizeof (OPEN_TEST_STRUCT) : 0;

  004fe	33 c0		 xor	 eax, eax
  00500	83 7d fc 00	 cmp	 DWORD PTR _ntStatus$[ebp], 0
  00504	0f 9c c0	 setl	 al
  00507	83 e8 01	 sub	 eax, 1
  0050a	25 18 02 00 00	 and	 eax, 536		; 00000218H
  0050f	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00512	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 983  : 			Irp->IoStatus.Status = ntStatus;

  00515	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  00518	8b 45 fc	 mov	 eax, DWORD PTR _ntStatus$[ebp]
  0051b	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 984  : 		}
; 985  : 		break;

  0051e	e9 98 13 00 00	 jmp	 $LN160@ProcessMai
$LN120@ProcessMai:

; 986  : 
; 987  : 	case TC_IOCTL_GET_SYSTEM_DRIVE_CONFIG:
; 988  : 		{
; 989  : 			GetSystemDriveConfigurationRequest *request = (GetSystemDriveConfigurationRequest *) Irp->AssociatedIrp.SystemBuffer;

  00523	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00526	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00529	89 95 74 fd ff
	ff		 mov	 DWORD PTR _request$30239[ebp], edx

; 990  : 			OBJECT_ATTRIBUTES ObjectAttributes;
; 991  : 			HANDLE NtFileHandle;
; 992  : 			UNICODE_STRING FullFileName;
; 993  : 			IO_STATUS_BLOCK IoStatus;
; 994  : 			LARGE_INTEGER offset;
; 995  : 			byte readBuffer [TC_SECTOR_SIZE_BIOS];
; 996  : 
; 997  : 			if (!ValidateIOBufferSize (Irp, sizeof (GetSystemDriveConfigurationRequest), ValidateInputOutput))

  0052f	6a 02		 push	 2
  00531	68 29 02 00 00	 push	 553			; 00000229H
  00536	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  00539	50		 push	 eax
  0053a	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  0053f	85 c0		 test	 eax, eax
  00541	75 05		 jne	 SHORT $LN119@ProcessMai

; 998  : 				break;

  00543	e9 73 13 00 00	 jmp	 $LN160@ProcessMai
$LN119@ProcessMai:

; 999  : 
; 1000 : 			EnsureNullTerminatedString (request->DevicePath, sizeof (request->DevicePath));

  00548	68 08 02 00 00	 push	 520			; 00000208H
  0054d	8b 8d 74 fd ff
	ff		 mov	 ecx, DWORD PTR _request$30239[ebp]
  00553	51		 push	 ecx
  00554	e8 00 00 00 00	 call	 _EnsureNullTerminatedString@8

; 1001 : 			RtlInitUnicodeString (&FullFileName, request->DevicePath);

  00559	8b 95 74 fd ff
	ff		 mov	 edx, DWORD PTR _request$30239[ebp]
  0055f	52		 push	 edx
  00560	8d 45 a0	 lea	 eax, DWORD PTR _FullFileName$30243[ebp]
  00563	50		 push	 eax
  00564	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 1002 : 
; 1003 : 			InitializeObjectAttributes (&ObjectAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

  0056a	c7 85 78 fd ff
	ff 18 00 00 00	 mov	 DWORD PTR _ObjectAttributes$30241[ebp], 24 ; 00000018H
  00574	c7 85 7c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _ObjectAttributes$30241[ebp+4], 0
  0057e	c7 85 84 fd ff
	ff 40 02 00 00	 mov	 DWORD PTR _ObjectAttributes$30241[ebp+12], 576 ; 00000240H
  00588	8d 4d a0	 lea	 ecx, DWORD PTR _FullFileName$30243[ebp]
  0058b	89 8d 80 fd ff
	ff		 mov	 DWORD PTR _ObjectAttributes$30241[ebp+8], ecx
  00591	c7 85 88 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _ObjectAttributes$30241[ebp+16], 0
  0059b	c7 85 8c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _ObjectAttributes$30241[ebp+20], 0

; 1004 : 
; 1005 : 			ntStatus = ZwCreateFile (&NtFileHandle,
; 1006 : 				SYNCHRONIZE | GENERIC_READ, &ObjectAttributes, &IoStatus, NULL,
; 1007 : 				FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS, NULL, 0);

  005a5	6a 00		 push	 0
  005a7	6a 00		 push	 0
  005a9	68 20 08 00 00	 push	 2080			; 00000820H
  005ae	6a 01		 push	 1
  005b0	6a 03		 push	 3
  005b2	68 80 00 00 00	 push	 128			; 00000080H
  005b7	6a 00		 push	 0
  005b9	8d 95 6c fd ff
	ff		 lea	 edx, DWORD PTR _IoStatus$30244[ebp]
  005bf	52		 push	 edx
  005c0	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR _ObjectAttributes$30241[ebp]
  005c6	50		 push	 eax
  005c7	68 00 00 10 80	 push	 -2146435072		; 80100000H
  005cc	8d 8d 68 fd ff
	ff		 lea	 ecx, DWORD PTR _NtFileHandle$30242[ebp]
  005d2	51		 push	 ecx
  005d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwCreateFile@44
  005d9	89 45 fc	 mov	 DWORD PTR _ntStatus$[ebp], eax

; 1008 : 
; 1009 : 			if (NT_SUCCESS (ntStatus))

  005dc	83 7d fc 00	 cmp	 DWORD PTR _ntStatus$[ebp], 0
  005e0	0f 8c 23 03 00
	00		 jl	 $LN118@ProcessMai

; 1010 : 			{
; 1011 : 				// Determine if the first sector contains a portion of the TrueCrypt Boot Loader
; 1012 : 				offset.QuadPart = 0;	// MBR

  005e6	c7 85 90 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _offset$30245[ebp], 0
  005f0	c7 85 94 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _offset$30245[ebp+4], 0

; 1013 : 
; 1014 : 				ntStatus = ZwReadFile (NtFileHandle,
; 1015 : 					NULL,
; 1016 : 					NULL,
; 1017 : 					NULL,
; 1018 : 					&IoStatus,
; 1019 : 					readBuffer,
; 1020 : 					sizeof(readBuffer),
; 1021 : 					&offset,
; 1022 : 					NULL);

  005fa	6a 00		 push	 0
  005fc	8d 95 90 fd ff
	ff		 lea	 edx, DWORD PTR _offset$30245[ebp]
  00602	52		 push	 edx
  00603	68 00 02 00 00	 push	 512			; 00000200H
  00608	8d 85 98 fd ff
	ff		 lea	 eax, DWORD PTR _readBuffer$30246[ebp]
  0060e	50		 push	 eax
  0060f	8d 8d 6c fd ff
	ff		 lea	 ecx, DWORD PTR _IoStatus$30244[ebp]
  00615	51		 push	 ecx
  00616	6a 00		 push	 0
  00618	6a 00		 push	 0
  0061a	6a 00		 push	 0
  0061c	8b 95 68 fd ff
	ff		 mov	 edx, DWORD PTR _NtFileHandle$30242[ebp]
  00622	52		 push	 edx
  00623	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwReadFile@36
  00629	89 45 fc	 mov	 DWORD PTR _ntStatus$[ebp], eax

; 1023 : 
; 1024 : 				if (NT_SUCCESS (ntStatus))

  0062c	83 7d fc 00	 cmp	 DWORD PTR _ntStatus$[ebp], 0
  00630	0f 8c b1 02 00
	00		 jl	 $LN117@ProcessMai

; 1025 : 				{
; 1026 : 					size_t i;
; 1027 : 
; 1028 : 					// Check for dynamic drive
; 1029 : 					request->DriveIsDynamic = FALSE;

  00636	8b 85 74 fd ff
	ff		 mov	 eax, DWORD PTR _request$30239[ebp]
  0063c	c7 80 09 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+521], 0

; 1030 : 
; 1031 : 					if (readBuffer[510] == 0x55 && readBuffer[511] == 0xaa)

  00646	0f b6 4d 96	 movzx	 ecx, BYTE PTR _readBuffer$30246[ebp+510]
  0064a	83 f9 55	 cmp	 ecx, 85			; 00000055H
  0064d	75 5a		 jne	 SHORT $LN116@ProcessMai
  0064f	0f b6 55 97	 movzx	 edx, BYTE PTR _readBuffer$30246[ebp+511]
  00653	81 fa aa 00 00
	00		 cmp	 edx, 170		; 000000aaH
  00659	75 4e		 jne	 SHORT $LN116@ProcessMai

; 1032 : 					{
; 1033 : 						int i;
; 1034 : 						for (i = 0; i < 4; ++i)

  0065b	c7 85 60 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$30265[ebp], 0
  00665	eb 0f		 jmp	 SHORT $LN115@ProcessMai
$LN114@ProcessMai:
  00667	8b 85 60 fd ff
	ff		 mov	 eax, DWORD PTR _i$30265[ebp]
  0066d	83 c0 01	 add	 eax, 1
  00670	89 85 60 fd ff
	ff		 mov	 DWORD PTR _i$30265[ebp], eax
$LN115@ProcessMai:
  00676	83 bd 60 fd ff
	ff 04		 cmp	 DWORD PTR _i$30265[ebp], 4
  0067d	7d 2a		 jge	 SHORT $LN116@ProcessMai

; 1035 : 						{
; 1036 : 							if (readBuffer[446 + i * 16 + 4] == PARTITION_LDM)

  0067f	8b 8d 60 fd ff
	ff		 mov	 ecx, DWORD PTR _i$30265[ebp]
  00685	c1 e1 04	 shl	 ecx, 4
  00688	0f b6 94 0d 5a
	ff ff ff	 movzx	 edx, BYTE PTR _readBuffer$30246[ebp+ecx+450]
  00690	83 fa 42	 cmp	 edx, 66			; 00000042H
  00693	75 12		 jne	 SHORT $LN112@ProcessMai

; 1037 : 							{
; 1038 : 								request->DriveIsDynamic = TRUE;

  00695	8b 85 74 fd ff
	ff		 mov	 eax, DWORD PTR _request$30239[ebp]
  0069b	c7 80 09 02 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+521], 1

; 1039 : 								break;

  006a5	eb 02		 jmp	 SHORT $LN116@ProcessMai
$LN112@ProcessMai:

; 1040 : 							}
; 1041 : 						}

  006a7	eb be		 jmp	 SHORT $LN114@ProcessMai
$LN116@ProcessMai:

; 1042 : 					}
; 1043 : 
; 1044 : 					request->BootLoaderVersion = 0;

  006a9	33 c9		 xor	 ecx, ecx
  006ab	8b 95 74 fd ff
	ff		 mov	 edx, DWORD PTR _request$30239[ebp]
  006b1	66 89 8a 0d 02
	00 00		 mov	 WORD PTR [edx+525], cx

; 1045 : 					request->Configuration = 0;

  006b8	8b 85 74 fd ff
	ff		 mov	 eax, DWORD PTR _request$30239[ebp]
  006be	c6 80 08 02 00
	00 00		 mov	 BYTE PTR [eax+520], 0

; 1046 : 					request->UserConfiguration = 0;

  006c5	8b 8d 74 fd ff
	ff		 mov	 ecx, DWORD PTR _request$30239[ebp]
  006cb	c6 81 0f 02 00
	00 00		 mov	 BYTE PTR [ecx+527], 0

; 1047 : 					request->CustomUserMessage[0] = 0;

  006d2	8b 95 74 fd ff
	ff		 mov	 edx, DWORD PTR _request$30239[ebp]
  006d8	c6 82 10 02 00
	00 00		 mov	 BYTE PTR [edx+528], 0

; 1048 : 
; 1049 : 					// Search for the string "CipherShed"
; 1050 : 					for (i = 0; i < sizeof (readBuffer) - strlen (TC_APP_NAME); ++i)

  006df	c7 85 64 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$30263[ebp], 0
  006e9	eb 0f		 jmp	 SHORT $LN111@ProcessMai
$LN110@ProcessMai:
  006eb	8b 85 64 fd ff
	ff		 mov	 eax, DWORD PTR _i$30263[ebp]
  006f1	83 c0 01	 add	 eax, 1
  006f4	89 85 64 fd ff
	ff		 mov	 DWORD PTR _i$30263[ebp], eax
$LN111@ProcessMai:
  006fa	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  006ff	83 e9 0a	 sub	 ecx, 10			; 0000000aH
  00702	39 8d 64 fd ff
	ff		 cmp	 DWORD PTR _i$30263[ebp], ecx
  00708	0f 83 c0 00 00
	00		 jae	 $LN109@ProcessMai

; 1051 : 					{
; 1052 : 						if (memcmp (readBuffer + i, TC_APP_NAME, strlen (TC_APP_NAME)) == 0)

  0070e	b9 05 00 00 00	 mov	 ecx, 5
  00713	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_0L@FEEFGEIL@CipherShed?$AA@FNODOBFM@
  00718	8b 95 64 fd ff
	ff		 mov	 edx, DWORD PTR _i$30263[ebp]
  0071e	8d b4 15 98 fd
	ff ff		 lea	 esi, DWORD PTR _readBuffer$30246[ebp+edx]
  00725	33 c0		 xor	 eax, eax
  00727	66 f3 a7	 repe cmpsw
  0072a	0f 85 99 00 00
	00		 jne	 $LN108@ProcessMai

; 1053 : 						{
; 1054 : 							request->BootLoaderVersion = BE16 (*(uint16 *) (readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET));

  00730	0f b7 8d 46 ff
	ff ff		 movzx	 ecx, WORD PTR _readBuffer$30246[ebp+430]
  00737	51		 push	 ecx
  00738	e8 00 00 00 00	 call	 _MirrorBytes16@4
  0073d	8b 95 74 fd ff
	ff		 mov	 edx, DWORD PTR _request$30239[ebp]
  00743	66 89 82 0d 02
	00 00		 mov	 WORD PTR [edx+525], ax

; 1055 : 							request->Configuration = readBuffer[TC_BOOT_SECTOR_CONFIG_OFFSET];

  0074a	8b 85 74 fd ff
	ff		 mov	 eax, DWORD PTR _request$30239[ebp]
  00750	8a 8d 4f ff ff
	ff		 mov	 cl, BYTE PTR _readBuffer$30246[ebp+439]
  00756	88 88 08 02 00
	00		 mov	 BYTE PTR [eax+520], cl

; 1056 : 
; 1057 : 							if (request->BootLoaderVersion != 0 && request->BootLoaderVersion <= VERSION_NUM)

  0075c	8b 95 74 fd ff
	ff		 mov	 edx, DWORD PTR _request$30239[ebp]
  00762	0f b7 82 0d 02
	00 00		 movzx	 eax, WORD PTR [edx+525]
  00769	85 c0		 test	 eax, eax
  0076b	74 5a		 je	 SHORT $LN107@ProcessMai
  0076d	8b 8d 74 fd ff
	ff		 mov	 ecx, DWORD PTR _request$30239[ebp]
  00773	0f b7 91 0d 02
	00 00		 movzx	 edx, WORD PTR [ecx+525]
  0077a	81 fa 30 07 00
	00		 cmp	 edx, 1840		; 00000730H
  00780	7f 45		 jg	 SHORT $LN107@ProcessMai

; 1058 : 							{
; 1059 : 								request->UserConfiguration = readBuffer[TC_BOOT_SECTOR_USER_CONFIG_OFFSET];

  00782	8b 85 74 fd ff
	ff		 mov	 eax, DWORD PTR _request$30239[ebp]
  00788	8a 8d 4e ff ff
	ff		 mov	 cl, BYTE PTR _readBuffer$30246[ebp+438]
  0078e	88 88 0f 02 00
	00		 mov	 BYTE PTR [eax+527], cl

; 1060 : 								memcpy (request->CustomUserMessage, readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET, TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH);

  00794	8d 95 2e ff ff
	ff		 lea	 edx, DWORD PTR _readBuffer$30246[ebp+406]
  0079a	8b 85 74 fd ff
	ff		 mov	 eax, DWORD PTR _request$30239[ebp]
  007a0	05 10 02 00 00	 add	 eax, 528		; 00000210H
  007a5	8b 0a		 mov	 ecx, DWORD PTR [edx]
  007a7	89 08		 mov	 DWORD PTR [eax], ecx
  007a9	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  007ac	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  007af	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  007b2	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  007b5	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  007b8	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  007bb	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  007be	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  007c1	8b 52 14	 mov	 edx, DWORD PTR [edx+20]
  007c4	89 50 14	 mov	 DWORD PTR [eax+20], edx
$LN107@ProcessMai:

; 1061 : 							}
; 1062 : 							break;

  007c7	eb 05		 jmp	 SHORT $LN109@ProcessMai
$LN108@ProcessMai:

; 1063 : 						}
; 1064 : 					}

  007c9	e9 1d ff ff ff	 jmp	 $LN110@ProcessMai
$LN109@ProcessMai:

; 1065 : 
; 1066 : 					// Search for the string "TrueCrypt"
; 1067 : 					if (!request->BootLoaderVersion) //CipherShed not found

  007ce	8b 85 74 fd ff
	ff		 mov	 eax, DWORD PTR _request$30239[ebp]
  007d4	0f b7 88 0d 02
	00 00		 movzx	 ecx, WORD PTR [eax+525]
  007db	85 c9		 test	 ecx, ecx
  007dd	0f 85 ee 00 00
	00		 jne	 $LN106@ProcessMai

; 1068 : 					for (i = 0; i < sizeof (readBuffer) - strlen (TC_APP_NAME_LEGACY); ++i)

  007e3	c7 85 64 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$30263[ebp], 0
  007ed	eb 0f		 jmp	 SHORT $LN105@ProcessMai
$LN104@ProcessMai:
  007ef	8b 95 64 fd ff
	ff		 mov	 edx, DWORD PTR _i$30263[ebp]
  007f5	83 c2 01	 add	 edx, 1
  007f8	89 95 64 fd ff
	ff		 mov	 DWORD PTR _i$30263[ebp], edx
$LN105@ProcessMai:
  007fe	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00803	83 e8 09	 sub	 eax, 9
  00806	39 85 64 fd ff
	ff		 cmp	 DWORD PTR _i$30263[ebp], eax
  0080c	0f 83 bf 00 00
	00		 jae	 $LN106@ProcessMai

; 1069 : 					{
; 1070 : 						if (memcmp (readBuffer + i, TC_APP_NAME_LEGACY, strlen (TC_APP_NAME_LEGACY)) == 0)

  00812	b9 09 00 00 00	 mov	 ecx, 9
  00817	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_09EMKKFGIH@TrueCrypt?$AA@FNODOBFM@
  0081c	8b 95 64 fd ff
	ff		 mov	 edx, DWORD PTR _i$30263[ebp]
  00822	8d b4 15 98 fd
	ff ff		 lea	 esi, DWORD PTR _readBuffer$30246[ebp+edx]
  00829	33 c0		 xor	 eax, eax
  0082b	f3 a6		 repe cmpsb
  0082d	0f 85 99 00 00
	00		 jne	 $LN102@ProcessMai

; 1071 : 						{
; 1072 : 							request->BootLoaderVersion = BE16 (*(uint16 *) (readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET));

  00833	0f b7 8d 46 ff
	ff ff		 movzx	 ecx, WORD PTR _readBuffer$30246[ebp+430]
  0083a	51		 push	 ecx
  0083b	e8 00 00 00 00	 call	 _MirrorBytes16@4
  00840	8b 95 74 fd ff
	ff		 mov	 edx, DWORD PTR _request$30239[ebp]
  00846	66 89 82 0d 02
	00 00		 mov	 WORD PTR [edx+525], ax

; 1073 : 							request->Configuration = readBuffer[TC_BOOT_SECTOR_CONFIG_OFFSET];

  0084d	8b 85 74 fd ff
	ff		 mov	 eax, DWORD PTR _request$30239[ebp]
  00853	8a 8d 4f ff ff
	ff		 mov	 cl, BYTE PTR _readBuffer$30246[ebp+439]
  00859	88 88 08 02 00
	00		 mov	 BYTE PTR [eax+520], cl

; 1074 : 
; 1075 : 							if (request->BootLoaderVersion != 0 && request->BootLoaderVersion <= VERSION_NUM)

  0085f	8b 95 74 fd ff
	ff		 mov	 edx, DWORD PTR _request$30239[ebp]
  00865	0f b7 82 0d 02
	00 00		 movzx	 eax, WORD PTR [edx+525]
  0086c	85 c0		 test	 eax, eax
  0086e	74 5a		 je	 SHORT $LN101@ProcessMai
  00870	8b 8d 74 fd ff
	ff		 mov	 ecx, DWORD PTR _request$30239[ebp]
  00876	0f b7 91 0d 02
	00 00		 movzx	 edx, WORD PTR [ecx+525]
  0087d	81 fa 30 07 00
	00		 cmp	 edx, 1840		; 00000730H
  00883	7f 45		 jg	 SHORT $LN101@ProcessMai

; 1076 : 							{
; 1077 : 								request->UserConfiguration = readBuffer[TC_BOOT_SECTOR_USER_CONFIG_OFFSET];

  00885	8b 85 74 fd ff
	ff		 mov	 eax, DWORD PTR _request$30239[ebp]
  0088b	8a 8d 4e ff ff
	ff		 mov	 cl, BYTE PTR _readBuffer$30246[ebp+438]
  00891	88 88 0f 02 00
	00		 mov	 BYTE PTR [eax+527], cl

; 1078 : 								memcpy (request->CustomUserMessage, readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET, TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH);

  00897	8d 95 2e ff ff
	ff		 lea	 edx, DWORD PTR _readBuffer$30246[ebp+406]
  0089d	8b 85 74 fd ff
	ff		 mov	 eax, DWORD PTR _request$30239[ebp]
  008a3	05 10 02 00 00	 add	 eax, 528		; 00000210H
  008a8	8b 0a		 mov	 ecx, DWORD PTR [edx]
  008aa	89 08		 mov	 DWORD PTR [eax], ecx
  008ac	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  008af	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  008b2	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  008b5	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  008b8	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  008bb	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  008be	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  008c1	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  008c4	8b 52 14	 mov	 edx, DWORD PTR [edx+20]
  008c7	89 50 14	 mov	 DWORD PTR [eax+20], edx
$LN101@ProcessMai:

; 1079 : 							}
; 1080 : 							break;

  008ca	eb 05		 jmp	 SHORT $LN106@ProcessMai
$LN102@ProcessMai:

; 1081 : 						}
; 1082 : 					}

  008cc	e9 1e ff ff ff	 jmp	 $LN104@ProcessMai
$LN106@ProcessMai:

; 1083 : 
; 1084 : 					Irp->IoStatus.Status = STATUS_SUCCESS;

  008d1	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  008d4	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 1085 : 					Irp->IoStatus.Information = sizeof (*request);

  008db	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  008de	c7 41 1c 29 02
	00 00		 mov	 DWORD PTR [ecx+28], 553	; 00000229H

; 1086 : 				}
; 1087 : 				else

  008e5	eb 13		 jmp	 SHORT $LN100@ProcessMai
$LN117@ProcessMai:

; 1088 : 				{
; 1089 : 					Irp->IoStatus.Status = ntStatus;

  008e7	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  008ea	8b 45 fc	 mov	 eax, DWORD PTR _ntStatus$[ebp]
  008ed	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 1090 : 					Irp->IoStatus.Information = 0;

  008f0	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  008f3	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0
$LN100@ProcessMai:

; 1091 : 				}
; 1092 : 
; 1093 : 				ZwClose (NtFileHandle);

  008fa	8b 95 68 fd ff
	ff		 mov	 edx, DWORD PTR _NtFileHandle$30242[ebp]
  00900	52		 push	 edx
  00901	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 1094 : 
; 1095 : 			}
; 1096 : 			else

  00907	eb 13		 jmp	 SHORT $LN99@ProcessMai
$LN118@ProcessMai:

; 1097 : 			{
; 1098 : 				Irp->IoStatus.Status = ntStatus;

  00909	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  0090c	8b 4d fc	 mov	 ecx, DWORD PTR _ntStatus$[ebp]
  0090f	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 1099 : 				Irp->IoStatus.Information = 0;

  00912	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  00915	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0
$LN99@ProcessMai:

; 1100 : 			}
; 1101 : 		}
; 1102 : 		break;

  0091c	e9 9a 0f 00 00	 jmp	 $LN160@ProcessMai
$LN98@ProcessMai:

; 1103 : 
; 1104 : 	case TC_IOCTL_WIPE_PASSWORD_CACHE:
; 1105 : 		WipeCache ();

  00921	e8 00 00 00 00	 call	 _WipeCache@0

; 1106 : 
; 1107 : 		Irp->IoStatus.Status = STATUS_SUCCESS;

  00926	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  00929	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 1108 : 		Irp->IoStatus.Information = 0;

  00930	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00933	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 1109 : 		break;

  0093a	e9 7c 0f 00 00	 jmp	 $LN160@ProcessMai
$LN97@ProcessMai:

; 1110 : 
; 1111 : 	case TC_IOCTL_GET_PASSWORD_CACHE_STATUS:
; 1112 : 		Irp->IoStatus.Status = cacheEmpty ? STATUS_PIPE_EMPTY : STATUS_SUCCESS;

  0093f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _cacheEmpty
  00945	f7 da		 neg	 edx
  00947	1b d2		 sbb	 edx, edx
  00949	81 e2 d9 00 00
	c0		 and	 edx, -1073741607	; c00000d9H
  0094f	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  00952	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 1113 : 		Irp->IoStatus.Information = 0;

  00955	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00958	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 1114 : 		break;

  0095f	e9 57 0f 00 00	 jmp	 $LN160@ProcessMai
$LN96@ProcessMai:

; 1115 : 
; 1116 : 	case TC_IOCTL_SET_PORTABLE_MODE_STATUS:
; 1117 : 		if (!UserCanAccessDriveDevice())

  00964	e8 00 00 00 00	 call	 _UserCanAccessDriveDevice@0
  00969	85 c0		 test	 eax, eax
  0096b	75 16		 jne	 SHORT $LN95@ProcessMai

; 1118 : 		{
; 1119 : 			Irp->IoStatus.Status = STATUS_ACCESS_DENIED;

  0096d	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  00970	c7 42 18 22 00
	00 c0		 mov	 DWORD PTR [edx+24], -1073741790 ; c0000022H

; 1120 : 			Irp->IoStatus.Information = 0;

  00977	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  0097a	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 1121 : 		}
; 1122 : 		else

  00981	eb 17		 jmp	 SHORT $LN94@ProcessMai
$LN95@ProcessMai:

; 1123 : 		{
; 1124 : 			PortableMode = TRUE;

  00983	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _PortableMode, 1

; 1125 : 			Dump ("Setting portable mode\n");

  0098d	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@GFMHOPFN@Setting?5portable?5mode?6?$AA@FNODOBFM@
  00992	e8 00 00 00 00	 call	 _DbgPrint
  00997	83 c4 04	 add	 esp, 4
$LN94@ProcessMai:

; 1126 : 		}
; 1127 : 		break;

  0099a	e9 1c 0f 00 00	 jmp	 $LN160@ProcessMai
$LN93@ProcessMai:

; 1128 : 
; 1129 : 	case TC_IOCTL_GET_PORTABLE_MODE_STATUS:
; 1130 : 		Irp->IoStatus.Status = PortableMode ? STATUS_SUCCESS : STATUS_PIPE_EMPTY;

  0099f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _PortableMode
  009a5	f7 d9		 neg	 ecx
  009a7	1b c9		 sbb	 ecx, ecx
  009a9	81 e1 27 ff ff
	3f		 and	 ecx, 1073741607		; 3fffff27H
  009af	81 c1 d9 00 00
	c0		 add	 ecx, -1073741607	; c00000d9H
  009b5	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  009b8	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 1131 : 		Irp->IoStatus.Information = 0;

  009bb	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  009be	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 1132 : 		break;

  009c5	e9 f1 0e 00 00	 jmp	 $LN160@ProcessMai
$LN92@ProcessMai:

; 1133 : 
; 1134 : 	case TC_IOCTL_GET_MOUNTED_VOLUMES:
; 1135 : 
; 1136 : 		if (ValidateIOBufferSize (Irp, sizeof (MOUNT_LIST_STRUCT), ValidateOutput))

  009ca	6a 01		 push	 1
  009cc	68 74 36 00 00	 push	 13940			; 00003674H
  009d1	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  009d4	51		 push	 ecx
  009d5	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  009da	85 c0		 test	 eax, eax
  009dc	0f 84 2c 02 00
	00		 je	 $LN91@ProcessMai

; 1137 : 		{
; 1138 : 			MOUNT_LIST_STRUCT *list = (MOUNT_LIST_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  009e2	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  009e5	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  009e8	89 85 5c fd ff
	ff		 mov	 DWORD PTR _list$30302[ebp], eax

; 1139 : 			PDEVICE_OBJECT ListDevice;
; 1140 : 			int drive;
; 1141 : 
; 1142 : 			list->ulMountedDrives = 0;

  009ee	8b 8d 5c fd ff
	ff		 mov	 ecx, DWORD PTR _list$30302[ebp]
  009f4	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1143 : 
; 1144 : 			for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)

  009fa	c7 85 58 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _drive$30305[ebp], 0
  00a04	eb 0f		 jmp	 SHORT $LN90@ProcessMai
$LN89@ProcessMai:
  00a06	8b 95 58 fd ff
	ff		 mov	 edx, DWORD PTR _drive$30305[ebp]
  00a0c	83 c2 01	 add	 edx, 1
  00a0f	89 95 58 fd ff
	ff		 mov	 DWORD PTR _drive$30305[ebp], edx
$LN90@ProcessMai:
  00a15	83 bd 58 fd ff
	ff 19		 cmp	 DWORD PTR _drive$30305[ebp], 25 ; 00000019H
  00a1c	0f 8f d8 01 00
	00		 jg	 $LN88@ProcessMai

; 1145 : 			{
; 1146 : 				PEXTENSION ListExtension;
; 1147 : 				
; 1148 : 				ListDevice = GetVirtualVolumeDeviceObject (drive);

  00a22	8b 85 58 fd ff
	ff		 mov	 eax, DWORD PTR _drive$30305[ebp]
  00a28	50		 push	 eax
  00a29	e8 00 00 00 00	 call	 _GetVirtualVolumeDeviceObject@4
  00a2e	89 85 54 fd ff
	ff		 mov	 DWORD PTR _ListDevice$30304[ebp], eax

; 1149 : 				if (!ListDevice)

  00a34	83 bd 54 fd ff
	ff 00		 cmp	 DWORD PTR _ListDevice$30304[ebp], 0
  00a3b	75 02		 jne	 SHORT $LN87@ProcessMai

; 1150 : 					continue;

  00a3d	eb c7		 jmp	 SHORT $LN89@ProcessMai
$LN87@ProcessMai:

; 1151 : 
; 1152 : 				ListExtension = (PEXTENSION) ListDevice->DeviceExtension;

  00a3f	8b 8d 54 fd ff
	ff		 mov	 ecx, DWORD PTR _ListDevice$30304[ebp]
  00a45	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00a48	89 95 50 fd ff
	ff		 mov	 DWORD PTR _ListExtension$30309[ebp], edx

; 1153 : 				if (IsVolumeAccessibleByCurrentUser (ListExtension))

  00a4e	8b 85 50 fd ff
	ff		 mov	 eax, DWORD PTR _ListExtension$30309[ebp]
  00a54	50		 push	 eax
  00a55	e8 00 00 00 00	 call	 _IsVolumeAccessibleByCurrentUser@4
  00a5a	85 c0		 test	 eax, eax
  00a5c	0f 84 93 01 00
	00		 je	 $LN86@ProcessMai

; 1154 : 				{
; 1155 : 					list->ulMountedDrives |= (1 << ListExtension->nDosDriveNo);

  00a62	8b 8d 50 fd ff
	ff		 mov	 ecx, DWORD PTR _ListExtension$30309[ebp]
  00a68	ba 01 00 00 00	 mov	 edx, 1
  00a6d	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00a70	d3 e2		 shl	 edx, cl
  00a72	8b 85 5c fd ff
	ff		 mov	 eax, DWORD PTR _list$30302[ebp]
  00a78	0b 10		 or	 edx, DWORD PTR [eax]
  00a7a	8b 8d 5c fd ff
	ff		 mov	 ecx, DWORD PTR _list$30302[ebp]
  00a80	89 11		 mov	 DWORD PTR [ecx], edx

; 1156 : 					wcscpy (list->wszVolume[ListExtension->nDosDriveNo], ListExtension->wszVolume);

  00a82	8b 95 50 fd ff
	ff		 mov	 edx, DWORD PTR _ListExtension$30309[ebp]
  00a88	81 c2 a0 02 00
	00		 add	 edx, 672		; 000002a0H
  00a8e	89 95 3c fc ff
	ff		 mov	 DWORD PTR tv455[ebp], edx
  00a94	8b 85 50 fd ff
	ff		 mov	 eax, DWORD PTR _ListExtension$30309[ebp]
  00a9a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00a9d	69 c9 08 02 00
	00		 imul	 ecx, 520		; 00000208H
  00aa3	8b 95 5c fd ff
	ff		 mov	 edx, DWORD PTR _list$30302[ebp]
  00aa9	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  00aad	89 85 38 fc ff
	ff		 mov	 DWORD PTR tv460[ebp], eax
  00ab3	8b 8d 38 fc ff
	ff		 mov	 ecx, DWORD PTR tv460[ebp]
  00ab9	89 8d 34 fc ff
	ff		 mov	 DWORD PTR tv461[ebp], ecx
$LN165@ProcessMai:
  00abf	8b 95 3c fc ff
	ff		 mov	 edx, DWORD PTR tv455[ebp]
  00ac5	66 8b 02	 mov	 ax, WORD PTR [edx]
  00ac8	66 89 85 32 fc
	ff ff		 mov	 WORD PTR tv462[ebp], ax
  00acf	8b 8d 38 fc ff
	ff		 mov	 ecx, DWORD PTR tv460[ebp]
  00ad5	66 8b 95 32 fc
	ff ff		 mov	 dx, WORD PTR tv462[ebp]
  00adc	66 89 11	 mov	 WORD PTR [ecx], dx
  00adf	8b 85 3c fc ff
	ff		 mov	 eax, DWORD PTR tv455[ebp]
  00ae5	83 c0 02	 add	 eax, 2
  00ae8	89 85 3c fc ff
	ff		 mov	 DWORD PTR tv455[ebp], eax
  00aee	8b 8d 38 fc ff
	ff		 mov	 ecx, DWORD PTR tv460[ebp]
  00af4	83 c1 02	 add	 ecx, 2
  00af7	89 8d 38 fc ff
	ff		 mov	 DWORD PTR tv460[ebp], ecx
  00afd	66 83 bd 32 fc
	ff ff 00	 cmp	 WORD PTR tv462[ebp], 0
  00b05	75 b8		 jne	 SHORT $LN165@ProcessMai

; 1157 : 					list->diskLength[ListExtension->nDosDriveNo] = ListExtension->DiskLength;

  00b07	8b 95 50 fd ff
	ff		 mov	 edx, DWORD PTR _ListExtension$30309[ebp]
  00b0d	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00b10	8b 8d 5c fd ff
	ff		 mov	 ecx, DWORD PTR _list$30302[ebp]
  00b16	8b 95 50 fd ff
	ff		 mov	 edx, DWORD PTR _ListExtension$30309[ebp]
  00b1c	8b 72 70	 mov	 esi, DWORD PTR [edx+112]
  00b1f	89 b4 c1 d4 34
	00 00		 mov	 DWORD PTR [ecx+eax*8+13524], esi
  00b26	8b 52 74	 mov	 edx, DWORD PTR [edx+116]
  00b29	89 94 c1 d8 34
	00 00		 mov	 DWORD PTR [ecx+eax*8+13528], edx

; 1158 : 					list->ea[ListExtension->nDosDriveNo] = ListExtension->cryptoInfo->ea;

  00b30	8b 85 50 fd ff
	ff		 mov	 eax, DWORD PTR _ListExtension$30309[ebp]
  00b36	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00b39	8b 95 50 fd ff
	ff		 mov	 edx, DWORD PTR _ListExtension$30309[ebp]
  00b3f	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00b42	8b 95 5c fd ff
	ff		 mov	 edx, DWORD PTR _list$30302[ebp]
  00b48	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00b4a	89 8c 82 a4 35
	00 00		 mov	 DWORD PTR [edx+eax*4+13732], ecx

; 1159 : 					if (ListExtension->cryptoInfo->hiddenVolume)

  00b51	8b 95 50 fd ff
	ff		 mov	 edx, DWORD PTR _ListExtension$30309[ebp]
  00b57	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00b5a	83 b8 a0 29 00
	00 00		 cmp	 DWORD PTR [eax+10656], 0
  00b61	74 1c		 je	 SHORT $LN85@ProcessMai

; 1160 : 						list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_HIDDEN;	// Hidden volume

  00b63	8b 8d 50 fd ff
	ff		 mov	 ecx, DWORD PTR _ListExtension$30309[ebp]
  00b69	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00b6c	8b 85 5c fd ff
	ff		 mov	 eax, DWORD PTR _list$30302[ebp]
  00b72	c7 84 90 0c 36
	00 00 01 00 00
	00		 mov	 DWORD PTR [eax+edx*4+13836], 1
  00b7d	eb 76		 jmp	 SHORT $LN86@ProcessMai
$LN85@ProcessMai:

; 1161 : 					else if (ListExtension->cryptoInfo->bHiddenVolProtectionAction)

  00b7f	8b 8d 50 fd ff
	ff		 mov	 ecx, DWORD PTR _ListExtension$30309[ebp]
  00b85	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00b88	83 ba 04 44 00
	00 00		 cmp	 DWORD PTR [edx+17412], 0
  00b8f	74 1c		 je	 SHORT $LN83@ProcessMai

; 1162 : 						list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_OUTER_VOL_WRITE_PREVENTED;	// Normal/outer volume (hidden volume protected AND write already prevented)

  00b91	8b 85 50 fd ff
	ff		 mov	 eax, DWORD PTR _ListExtension$30309[ebp]
  00b97	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00b9a	8b 95 5c fd ff
	ff		 mov	 edx, DWORD PTR _list$30302[ebp]
  00ba0	c7 84 8a 0c 36
	00 00 03 00 00
	00		 mov	 DWORD PTR [edx+ecx*4+13836], 3
  00bab	eb 48		 jmp	 SHORT $LN86@ProcessMai
$LN83@ProcessMai:

; 1163 : 					else if (ListExtension->cryptoInfo->bProtectHiddenVolume)

  00bad	8b 85 50 fd ff
	ff		 mov	 eax, DWORD PTR _ListExtension$30309[ebp]
  00bb3	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00bb6	83 b9 00 44 00
	00 00		 cmp	 DWORD PTR [ecx+17408], 0
  00bbd	74 1c		 je	 SHORT $LN81@ProcessMai

; 1164 : 						list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_OUTER;	// Normal/outer volume (hidden volume protected)

  00bbf	8b 95 50 fd ff
	ff		 mov	 edx, DWORD PTR _ListExtension$30309[ebp]
  00bc5	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00bc8	8b 8d 5c fd ff
	ff		 mov	 ecx, DWORD PTR _list$30302[ebp]
  00bce	c7 84 81 0c 36
	00 00 02 00 00
	00		 mov	 DWORD PTR [ecx+eax*4+13836], 2

; 1165 : 					else

  00bd9	eb 1a		 jmp	 SHORT $LN86@ProcessMai
$LN81@ProcessMai:

; 1166 : 						list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_NORMAL;	// Normal volume

  00bdb	8b 95 50 fd ff
	ff		 mov	 edx, DWORD PTR _ListExtension$30309[ebp]
  00be1	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00be4	8b 8d 5c fd ff
	ff		 mov	 ecx, DWORD PTR _list$30302[ebp]
  00bea	c7 84 81 0c 36
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax*4+13836], 0
$LN86@ProcessMai:

; 1167 : 				}
; 1168 : 			}

  00bf5	e9 0c fe ff ff	 jmp	 $LN89@ProcessMai
$LN88@ProcessMai:

; 1169 : 
; 1170 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00bfa	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  00bfd	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 1171 : 			Irp->IoStatus.Information = sizeof (MOUNT_LIST_STRUCT);

  00c04	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  00c07	c7 40 1c 74 36
	00 00		 mov	 DWORD PTR [eax+28], 13940 ; 00003674H
$LN91@ProcessMai:

; 1172 : 		}
; 1173 : 		break;

  00c0e	e9 a8 0c 00 00	 jmp	 $LN160@ProcessMai
$LN79@ProcessMai:

; 1174 : 
; 1175 : 	case TC_IOCTL_LEGACY_GET_MOUNTED_VOLUMES:
; 1176 : 		if (ValidateIOBufferSize (Irp, sizeof (uint32), ValidateOutput))

  00c13	6a 01		 push	 1
  00c15	6a 04		 push	 4
  00c17	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00c1a	51		 push	 ecx
  00c1b	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00c20	85 c0		 test	 eax, eax
  00c22	74 3a		 je	 SHORT $LN78@ProcessMai

; 1177 : 		{
; 1178 : 			// Prevent the user from downgrading to versions lower than 5.0 by faking mounted volumes.
; 1179 : 			// The user could render the system unbootable by downgrading when boot encryption
; 1180 : 			// is active or being set up.
; 1181 : 
; 1182 : 			memset (Irp->AssociatedIrp.SystemBuffer, 0, irpSp->Parameters.DeviceIoControl.OutputBufferLength);

  00c24	8b 55 f8	 mov	 edx, DWORD PTR _irpSp$[ebp]
  00c27	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00c2a	50		 push	 eax
  00c2b	6a 00		 push	 0
  00c2d	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00c30	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00c33	52		 push	 edx
  00c34	e8 00 00 00 00	 call	 _memset
  00c39	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1183 : 			*(uint32 *) Irp->AssociatedIrp.SystemBuffer = 0xffffFFFF;

  00c3c	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  00c3f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00c42	c7 01 ff ff ff
	ff		 mov	 DWORD PTR [ecx], -1

; 1184 : 
; 1185 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00c48	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  00c4b	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 1186 : 			Irp->IoStatus.Information = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

  00c52	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  00c55	8b 4d f8	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  00c58	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00c5b	89 50 1c	 mov	 DWORD PTR [eax+28], edx
$LN78@ProcessMai:

; 1187 : 		}
; 1188 : 		break;

  00c5e	e9 58 0c 00 00	 jmp	 $LN160@ProcessMai
$LN77@ProcessMai:

; 1189 : 
; 1190 : 	case TC_IOCTL_GET_VOLUME_PROPERTIES:
; 1191 : 		if (ValidateIOBufferSize (Irp, sizeof (VOLUME_PROPERTIES_STRUCT), ValidateInputOutput))

  00c63	6a 02		 push	 2
  00c65	68 54 02 00 00	 push	 596			; 00000254H
  00c6a	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  00c6d	50		 push	 eax
  00c6e	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00c73	85 c0		 test	 eax, eax
  00c75	0f 84 b2 02 00
	00		 je	 $LN76@ProcessMai

; 1192 : 		{
; 1193 : 			VOLUME_PROPERTIES_STRUCT *prop = (VOLUME_PROPERTIES_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  00c7b	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00c7e	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00c81	89 95 48 fd ff
	ff		 mov	 DWORD PTR _prop$30329[ebp], edx

; 1194 : 			PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject (prop->driveNo);

  00c87	8b 85 48 fd ff
	ff		 mov	 eax, DWORD PTR _prop$30329[ebp]
  00c8d	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c8f	51		 push	 ecx
  00c90	e8 00 00 00 00	 call	 _GetVirtualVolumeDeviceObject@4
  00c95	89 85 4c fd ff
	ff		 mov	 DWORD PTR _ListDevice$30331[ebp], eax

; 1195 : 
; 1196 : 			Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  00c9b	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  00c9e	c7 42 18 0d 00
	00 c0		 mov	 DWORD PTR [edx+24], -1073741811 ; c000000dH

; 1197 : 			Irp->IoStatus.Information = 0;

  00ca5	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  00ca8	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 1198 : 
; 1199 : 			if (ListDevice)

  00caf	83 bd 4c fd ff
	ff 00		 cmp	 DWORD PTR _ListDevice$30331[ebp], 0
  00cb6	0f 84 71 02 00
	00		 je	 $LN76@ProcessMai

; 1200 : 			{
; 1201 : 				PEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;

  00cbc	8b 8d 4c fd ff
	ff		 mov	 ecx, DWORD PTR _ListDevice$30331[ebp]
  00cc2	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00cc5	89 95 44 fd ff
	ff		 mov	 DWORD PTR _ListExtension$30334[ebp], edx

; 1202 : 				if (IsVolumeAccessibleByCurrentUser (ListExtension))

  00ccb	8b 85 44 fd ff
	ff		 mov	 eax, DWORD PTR _ListExtension$30334[ebp]
  00cd1	50		 push	 eax
  00cd2	e8 00 00 00 00	 call	 _IsVolumeAccessibleByCurrentUser@4
  00cd7	85 c0		 test	 eax, eax
  00cd9	0f 84 4e 02 00
	00		 je	 $LN76@ProcessMai

; 1203 : 				{
; 1204 : 					prop->uniqueId = ListExtension->UniqueVolumeId;

  00cdf	8b 8d 48 fd ff
	ff		 mov	 ecx, DWORD PTR _prop$30329[ebp]
  00ce5	8b 95 44 fd ff
	ff		 mov	 edx, DWORD PTR _ListExtension$30334[ebp]
  00ceb	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00cee	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1205 : 					wcscpy (prop->wszVolume, ListExtension->wszVolume);

  00cf1	8b 8d 44 fd ff
	ff		 mov	 ecx, DWORD PTR _ListExtension$30334[ebp]
  00cf7	81 c1 a0 02 00
	00		 add	 ecx, 672		; 000002a0H
  00cfd	89 8d 2c fc ff
	ff		 mov	 DWORD PTR tv538[ebp], ecx
  00d03	8b 95 48 fd ff
	ff		 mov	 edx, DWORD PTR _prop$30329[ebp]
  00d09	83 c2 08	 add	 edx, 8
  00d0c	89 95 28 fc ff
	ff		 mov	 DWORD PTR tv540[ebp], edx
  00d12	8b 85 28 fc ff
	ff		 mov	 eax, DWORD PTR tv540[ebp]
  00d18	89 85 24 fc ff
	ff		 mov	 DWORD PTR tv541[ebp], eax
$LN166@ProcessMai:
  00d1e	8b 8d 2c fc ff
	ff		 mov	 ecx, DWORD PTR tv538[ebp]
  00d24	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00d27	66 89 95 22 fc
	ff ff		 mov	 WORD PTR tv542[ebp], dx
  00d2e	8b 85 28 fc ff
	ff		 mov	 eax, DWORD PTR tv540[ebp]
  00d34	66 8b 8d 22 fc
	ff ff		 mov	 cx, WORD PTR tv542[ebp]
  00d3b	66 89 08	 mov	 WORD PTR [eax], cx
  00d3e	8b 95 2c fc ff
	ff		 mov	 edx, DWORD PTR tv538[ebp]
  00d44	83 c2 02	 add	 edx, 2
  00d47	89 95 2c fc ff
	ff		 mov	 DWORD PTR tv538[ebp], edx
  00d4d	8b 85 28 fc ff
	ff		 mov	 eax, DWORD PTR tv540[ebp]
  00d53	83 c0 02	 add	 eax, 2
  00d56	89 85 28 fc ff
	ff		 mov	 DWORD PTR tv540[ebp], eax
  00d5c	66 83 bd 22 fc
	ff ff 00	 cmp	 WORD PTR tv542[ebp], 0
  00d64	75 b8		 jne	 SHORT $LN166@ProcessMai

; 1206 : 					prop->diskLength = ListExtension->DiskLength;

  00d66	8b 8d 48 fd ff
	ff		 mov	 ecx, DWORD PTR _prop$30329[ebp]
  00d6c	8b 95 44 fd ff
	ff		 mov	 edx, DWORD PTR _ListExtension$30334[ebp]
  00d72	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  00d75	89 81 10 02 00
	00		 mov	 DWORD PTR [ecx+528], eax
  00d7b	8b 52 74	 mov	 edx, DWORD PTR [edx+116]
  00d7e	89 91 14 02 00
	00		 mov	 DWORD PTR [ecx+532], edx

; 1207 : 					prop->ea = ListExtension->cryptoInfo->ea;

  00d84	8b 85 44 fd ff
	ff		 mov	 eax, DWORD PTR _ListExtension$30334[ebp]
  00d8a	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00d8d	8b 95 48 fd ff
	ff		 mov	 edx, DWORD PTR _prop$30329[ebp]
  00d93	8b 01		 mov	 eax, DWORD PTR [ecx]
  00d95	89 82 18 02 00
	00		 mov	 DWORD PTR [edx+536], eax

; 1208 : 					prop->mode = ListExtension->cryptoInfo->mode;

  00d9b	8b 8d 44 fd ff
	ff		 mov	 ecx, DWORD PTR _ListExtension$30334[ebp]
  00da1	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00da4	8b 85 48 fd ff
	ff		 mov	 eax, DWORD PTR _prop$30329[ebp]
  00daa	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00dad	89 88 1c 02 00
	00		 mov	 DWORD PTR [eax+540], ecx

; 1209 : 					prop->pkcs5 = ListExtension->cryptoInfo->pkcs5;

  00db3	8b 95 44 fd ff
	ff		 mov	 edx, DWORD PTR _ListExtension$30334[ebp]
  00db9	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00dbc	8b 8d 48 fd ff
	ff		 mov	 ecx, DWORD PTR _prop$30329[ebp]
  00dc2	8b 90 ec 43 00
	00		 mov	 edx, DWORD PTR [eax+17388]
  00dc8	89 91 20 02 00
	00		 mov	 DWORD PTR [ecx+544], edx

; 1210 : 					prop->pkcs5Iterations = ListExtension->cryptoInfo->noIterations;

  00dce	8b 85 44 fd ff
	ff		 mov	 eax, DWORD PTR _ListExtension$30334[ebp]
  00dd4	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00dd7	8b 95 48 fd ff
	ff		 mov	 edx, DWORD PTR _prop$30329[ebp]
  00ddd	8b 81 e8 43 00
	00		 mov	 eax, DWORD PTR [ecx+17384]
  00de3	89 82 24 02 00
	00		 mov	 DWORD PTR [edx+548], eax

; 1211 : #if 0
; 1212 : 					prop->volumeCreationTime = ListExtension->cryptoInfo->volume_creation_time;
; 1213 : 					prop->headerCreationTime = ListExtension->cryptoInfo->header_creation_time;
; 1214 : #endif
; 1215 : 					prop->volumeHeaderFlags = ListExtension->cryptoInfo->HeaderFlags;

  00de9	8b 8d 44 fd ff
	ff		 mov	 ecx, DWORD PTR _ListExtension$30334[ebp]
  00def	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00df2	8b 85 48 fd ff
	ff		 mov	 eax, DWORD PTR _prop$30329[ebp]
  00df8	8b 8a 60 44 00
	00		 mov	 ecx, DWORD PTR [edx+17504]
  00dfe	89 88 38 02 00
	00		 mov	 DWORD PTR [eax+568], ecx

; 1216 : 					prop->readOnly = ListExtension->bReadOnly;

  00e04	8b 95 48 fd ff
	ff		 mov	 edx, DWORD PTR _prop$30329[ebp]
  00e0a	8b 85 44 fd ff
	ff		 mov	 eax, DWORD PTR _ListExtension$30334[ebp]
  00e10	8b 88 88 02 00
	00		 mov	 ecx, DWORD PTR [eax+648]
  00e16	89 8a 2c 02 00
	00		 mov	 DWORD PTR [edx+556], ecx

; 1217 : 					prop->removable = ListExtension->bRemovable;

  00e1c	8b 95 48 fd ff
	ff		 mov	 edx, DWORD PTR _prop$30329[ebp]
  00e22	8b 85 44 fd ff
	ff		 mov	 eax, DWORD PTR _ListExtension$30334[ebp]
  00e28	8b 88 8c 02 00
	00		 mov	 ecx, DWORD PTR [eax+652]
  00e2e	89 8a 30 02 00
	00		 mov	 DWORD PTR [edx+560], ecx

; 1218 : 					prop->partitionInInactiveSysEncScope = ListExtension->PartitionInInactiveSysEncScope;

  00e34	8b 95 48 fd ff
	ff		 mov	 edx, DWORD PTR _prop$30329[ebp]
  00e3a	8b 85 44 fd ff
	ff		 mov	 eax, DWORD PTR _ListExtension$30334[ebp]
  00e40	8b 88 90 02 00
	00		 mov	 ecx, DWORD PTR [eax+656]
  00e46	89 8a 34 02 00
	00		 mov	 DWORD PTR [edx+564], ecx

; 1219 : 					prop->hiddenVolume = ListExtension->cryptoInfo->hiddenVolume;

  00e4c	8b 95 44 fd ff
	ff		 mov	 edx, DWORD PTR _ListExtension$30334[ebp]
  00e52	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00e55	8b 8d 48 fd ff
	ff		 mov	 ecx, DWORD PTR _prop$30329[ebp]
  00e5b	8b 90 a0 29 00
	00		 mov	 edx, DWORD PTR [eax+10656]
  00e61	89 91 28 02 00
	00		 mov	 DWORD PTR [ecx+552], edx

; 1220 : 
; 1221 : 					if (ListExtension->cryptoInfo->bProtectHiddenVolume)

  00e67	8b 85 44 fd ff
	ff		 mov	 eax, DWORD PTR _ListExtension$30334[ebp]
  00e6d	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00e70	83 b9 00 44 00
	00 00		 cmp	 DWORD PTR [ecx+17408], 0
  00e77	74 26		 je	 SHORT $LN73@ProcessMai

; 1222 : 						prop->hiddenVolProtection = ListExtension->cryptoInfo->bHiddenVolProtectionAction ? HIDVOL_PROT_STATUS_ACTION_TAKEN : HIDVOL_PROT_STATUS_ACTIVE;

  00e79	8b 95 44 fd ff
	ff		 mov	 edx, DWORD PTR _ListExtension$30334[ebp]
  00e7f	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00e82	33 c9		 xor	 ecx, ecx
  00e84	83 b8 04 44 00
	00 00		 cmp	 DWORD PTR [eax+17412], 0
  00e8b	0f 95 c1	 setne	 cl
  00e8e	83 c1 01	 add	 ecx, 1
  00e91	8b 95 48 fd ff
	ff		 mov	 edx, DWORD PTR _prop$30329[ebp]
  00e97	89 8a 4c 02 00
	00		 mov	 DWORD PTR [edx+588], ecx

; 1223 : 					else

  00e9d	eb 10		 jmp	 SHORT $LN72@ProcessMai
$LN73@ProcessMai:

; 1224 : 						prop->hiddenVolProtection = HIDVOL_PROT_STATUS_NONE;

  00e9f	8b 85 48 fd ff
	ff		 mov	 eax, DWORD PTR _prop$30329[ebp]
  00ea5	c7 80 4c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+588], 0
$LN72@ProcessMai:

; 1225 : 
; 1226 : 					prop->totalBytesRead = ListExtension->Queue.TotalBytesRead;

  00eaf	8b 8d 48 fd ff
	ff		 mov	 ecx, DWORD PTR _prop$30329[ebp]
  00eb5	8b 95 44 fd ff
	ff		 mov	 edx, DWORD PTR _ListExtension$30334[ebp]
  00ebb	8b 82 50 02 00
	00		 mov	 eax, DWORD PTR [edx+592]
  00ec1	89 81 3c 02 00
	00		 mov	 DWORD PTR [ecx+572], eax
  00ec7	8b 92 54 02 00
	00		 mov	 edx, DWORD PTR [edx+596]
  00ecd	89 91 40 02 00
	00		 mov	 DWORD PTR [ecx+576], edx

; 1227 : 					prop->totalBytesWritten = ListExtension->Queue.TotalBytesWritten;

  00ed3	8b 85 48 fd ff
	ff		 mov	 eax, DWORD PTR _prop$30329[ebp]
  00ed9	8b 8d 44 fd ff
	ff		 mov	 ecx, DWORD PTR _ListExtension$30334[ebp]
  00edf	8b 91 58 02 00
	00		 mov	 edx, DWORD PTR [ecx+600]
  00ee5	89 90 44 02 00
	00		 mov	 DWORD PTR [eax+580], edx
  00eeb	8b 89 5c 02 00
	00		 mov	 ecx, DWORD PTR [ecx+604]
  00ef1	89 88 48 02 00
	00		 mov	 DWORD PTR [eax+584], ecx

; 1228 : 
; 1229 : 					prop->volFormatVersion = ListExtension->cryptoInfo->LegacyVolume ? TC_VOLUME_FORMAT_VERSION_PRE_6_0 : TC_VOLUME_FORMAT_VERSION;

  00ef7	8b 95 44 fd ff
	ff		 mov	 edx, DWORD PTR _ListExtension$30334[ebp]
  00efd	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00f00	8b 88 3c 44 00
	00		 mov	 ecx, DWORD PTR [eax+17468]
  00f06	f7 d9		 neg	 ecx
  00f08	1b c9		 sbb	 ecx, ecx
  00f0a	83 c1 02	 add	 ecx, 2
  00f0d	8b 95 48 fd ff
	ff		 mov	 edx, DWORD PTR _prop$30329[ebp]
  00f13	89 8a 50 02 00
	00		 mov	 DWORD PTR [edx+592], ecx

; 1230 : 
; 1231 : 					Irp->IoStatus.Status = STATUS_SUCCESS;

  00f19	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  00f1c	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 1232 : 					Irp->IoStatus.Information = sizeof (VOLUME_PROPERTIES_STRUCT);

  00f23	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00f26	c7 41 1c 54 02
	00 00		 mov	 DWORD PTR [ecx+28], 596	; 00000254H
$LN76@ProcessMai:

; 1233 : 				}
; 1234 : 			}
; 1235 : 		}
; 1236 : 		break;

  00f2d	e9 89 09 00 00	 jmp	 $LN160@ProcessMai
$LN71@ProcessMai:

; 1237 : 
; 1238 : 	case TC_IOCTL_GET_RESOLVED_SYMLINK:
; 1239 : 		if (ValidateIOBufferSize (Irp, sizeof (RESOLVE_SYMLINK_STRUCT), ValidateInputOutput))

  00f32	6a 02		 push	 2
  00f34	68 10 04 00 00	 push	 1040			; 00000410H
  00f39	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  00f3c	52		 push	 edx
  00f3d	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00f42	85 c0		 test	 eax, eax
  00f44	74 56		 je	 SHORT $LN70@ProcessMai

; 1240 : 		{
; 1241 : 			RESOLVE_SYMLINK_STRUCT *resolve = (RESOLVE_SYMLINK_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  00f46	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  00f49	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00f4c	89 8d 40 fd ff
	ff		 mov	 DWORD PTR _resolve$30344[ebp], ecx

; 1242 : 			{
; 1243 : 				NTSTATUS ntStatus;
; 1244 : 
; 1245 : 				EnsureNullTerminatedString (resolve->symLinkName, sizeof (resolve->symLinkName));

  00f52	68 08 02 00 00	 push	 520			; 00000208H
  00f57	8b 95 40 fd ff
	ff		 mov	 edx, DWORD PTR _resolve$30344[ebp]
  00f5d	52		 push	 edx
  00f5e	e8 00 00 00 00	 call	 _EnsureNullTerminatedString@8

; 1246 : 
; 1247 : 				ntStatus = SymbolicLinkToTarget (resolve->symLinkName,
; 1248 : 					resolve->targetName,
; 1249 : 					sizeof (resolve->targetName));

  00f63	68 08 02 00 00	 push	 520			; 00000208H
  00f68	8b 85 40 fd ff
	ff		 mov	 eax, DWORD PTR _resolve$30344[ebp]
  00f6e	05 08 02 00 00	 add	 eax, 520		; 00000208H
  00f73	50		 push	 eax
  00f74	8b 8d 40 fd ff
	ff		 mov	 ecx, DWORD PTR _resolve$30344[ebp]
  00f7a	51		 push	 ecx
  00f7b	e8 00 00 00 00	 call	 _SymbolicLinkToTarget@12
  00f80	89 85 3c fd ff
	ff		 mov	 DWORD PTR _ntStatus$30346[ebp], eax

; 1250 : 
; 1251 : 				Irp->IoStatus.Information = sizeof (RESOLVE_SYMLINK_STRUCT);

  00f86	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  00f89	c7 42 1c 10 04
	00 00		 mov	 DWORD PTR [edx+28], 1040 ; 00000410H

; 1252 : 				Irp->IoStatus.Status = ntStatus;

  00f90	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  00f93	8b 8d 3c fd ff
	ff		 mov	 ecx, DWORD PTR _ntStatus$30346[ebp]
  00f99	89 48 18	 mov	 DWORD PTR [eax+24], ecx
$LN70@ProcessMai:

; 1253 : 			}
; 1254 : 		}
; 1255 : 		break;

  00f9c	e9 1a 09 00 00	 jmp	 $LN160@ProcessMai
$LN69@ProcessMai:

; 1256 : 
; 1257 : 	case TC_IOCTL_GET_DRIVE_PARTITION_INFO:
; 1258 : 		if (ValidateIOBufferSize (Irp, sizeof (DISK_PARTITION_INFO_STRUCT), ValidateInputOutput))

  00fa1	6a 02		 push	 2
  00fa3	68 30 02 00 00	 push	 560			; 00000230H
  00fa8	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  00fab	52		 push	 edx
  00fac	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00fb1	85 c0		 test	 eax, eax
  00fb3	0f 84 2b 02 00
	00		 je	 $LN68@ProcessMai

; 1259 : 		{
; 1260 : 			DISK_PARTITION_INFO_STRUCT *info = (DISK_PARTITION_INFO_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  00fb9	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  00fbc	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00fbf	89 8d 38 fd ff
	ff		 mov	 DWORD PTR _info$30351[ebp], ecx

; 1261 : 			{
; 1262 : 				PARTITION_INFORMATION_EX pi;
; 1263 : 				NTSTATUS ntStatus;
; 1264 : 
; 1265 : 				EnsureNullTerminatedString (info->deviceName, sizeof (info->deviceName));

  00fc5	68 08 02 00 00	 push	 520			; 00000208H
  00fca	8b 95 38 fd ff
	ff		 mov	 edx, DWORD PTR _info$30351[ebp]
  00fd0	52		 push	 edx
  00fd1	e8 00 00 00 00	 call	 _EnsureNullTerminatedString@8

; 1266 : 
; 1267 : 				ntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0, &pi, sizeof (pi));

  00fd6	68 90 00 00 00	 push	 144			; 00000090H
  00fdb	8d 85 a8 fc ff
	ff		 lea	 eax, DWORD PTR _pi$30353[ebp]
  00fe1	50		 push	 eax
  00fe2	6a 00		 push	 0
  00fe4	6a 00		 push	 0
  00fe6	68 48 00 07 00	 push	 458824			; 00070048H
  00feb	8b 8d 38 fd ff
	ff		 mov	 ecx, DWORD PTR _info$30351[ebp]
  00ff1	51		 push	 ecx
  00ff2	e8 00 00 00 00	 call	 _TCDeviceIoControl@24
  00ff7	89 85 a4 fc ff
	ff		 mov	 DWORD PTR _ntStatus$30354[ebp], eax

; 1268 : 				if (NT_SUCCESS(ntStatus))

  00ffd	83 bd a4 fc ff
	ff 00		 cmp	 DWORD PTR _ntStatus$30354[ebp], 0
  01004	0f 8c b9 00 00
	00		 jl	 $LN67@ProcessMai

; 1269 : 				{
; 1270 : 					memset (&info->partInfo, 0, sizeof (info->partInfo));

  0100a	33 d2		 xor	 edx, edx
  0100c	8b 85 38 fd ff
	ff		 mov	 eax, DWORD PTR _info$30351[ebp]
  01012	05 08 02 00 00	 add	 eax, 520		; 00000208H
  01017	89 10		 mov	 DWORD PTR [eax], edx
  01019	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0101c	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0101f	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  01022	89 50 10	 mov	 DWORD PTR [eax+16], edx
  01025	89 50 14	 mov	 DWORD PTR [eax+20], edx
  01028	89 50 18	 mov	 DWORD PTR [eax+24], edx
  0102b	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 1271 : 
; 1272 : 					info->partInfo.PartitionLength = pi.PartitionLength;

  0102e	8b 8d 38 fd ff
	ff		 mov	 ecx, DWORD PTR _info$30351[ebp]
  01034	8b 95 b8 fc ff
	ff		 mov	 edx, DWORD PTR _pi$30353[ebp+16]
  0103a	89 91 10 02 00
	00		 mov	 DWORD PTR [ecx+528], edx
  01040	8b 85 bc fc ff
	ff		 mov	 eax, DWORD PTR _pi$30353[ebp+20]
  01046	89 81 14 02 00
	00		 mov	 DWORD PTR [ecx+532], eax

; 1273 : 					info->partInfo.PartitionNumber = pi.PartitionNumber;

  0104c	8b 8d 38 fd ff
	ff		 mov	 ecx, DWORD PTR _info$30351[ebp]
  01052	8b 95 c0 fc ff
	ff		 mov	 edx, DWORD PTR _pi$30353[ebp+24]
  01058	89 91 1c 02 00
	00		 mov	 DWORD PTR [ecx+540], edx

; 1274 : 					info->partInfo.StartingOffset = pi.StartingOffset;

  0105e	8b 85 38 fd ff
	ff		 mov	 eax, DWORD PTR _info$30351[ebp]
  01064	8b 8d b0 fc ff
	ff		 mov	 ecx, DWORD PTR _pi$30353[ebp+8]
  0106a	89 88 08 02 00
	00		 mov	 DWORD PTR [eax+520], ecx
  01070	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR _pi$30353[ebp+12]
  01076	89 90 0c 02 00
	00		 mov	 DWORD PTR [eax+524], edx

; 1275 : 
; 1276 : 					if (pi.PartitionStyle == PARTITION_STYLE_MBR)

  0107c	83 bd a8 fc ff
	ff 00		 cmp	 DWORD PTR _pi$30353[ebp], 0
  01083	75 24		 jne	 SHORT $LN66@ProcessMai

; 1277 : 					{
; 1278 : 						info->partInfo.PartitionType = pi.Mbr.PartitionType;

  01085	8b 85 38 fd ff
	ff		 mov	 eax, DWORD PTR _info$30351[ebp]
  0108b	8a 8d c8 fc ff
	ff		 mov	 cl, BYTE PTR _pi$30353[ebp+32]
  01091	88 88 20 02 00
	00		 mov	 BYTE PTR [eax+544], cl

; 1279 : 						info->partInfo.BootIndicator = pi.Mbr.BootIndicator;

  01097	8b 95 38 fd ff
	ff		 mov	 edx, DWORD PTR _info$30351[ebp]
  0109d	8a 85 c9 fc ff
	ff		 mov	 al, BYTE PTR _pi$30353[ebp+33]
  010a3	88 82 21 02 00
	00		 mov	 BYTE PTR [edx+545], al
$LN66@ProcessMai:

; 1280 : 					}
; 1281 : 
; 1282 : 					info->IsGPT = pi.PartitionStyle == PARTITION_STYLE_GPT;

  010a9	33 c9		 xor	 ecx, ecx
  010ab	83 bd a8 fc ff
	ff 01		 cmp	 DWORD PTR _pi$30353[ebp], 1
  010b2	0f 94 c1	 sete	 cl
  010b5	8b 95 38 fd ff
	ff		 mov	 edx, DWORD PTR _info$30351[ebp]
  010bb	89 8a 28 02 00
	00		 mov	 DWORD PTR [edx+552], ecx

; 1283 : 				}
; 1284 : 				else

  010c1	eb 39		 jmp	 SHORT $LN65@ProcessMai
$LN67@ProcessMai:

; 1285 : 				{
; 1286 : 					// Windows 2000 does not support IOCTL_DISK_GET_PARTITION_INFO_EX
; 1287 : 					ntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0, &info->partInfo, sizeof (info->partInfo));

  010c3	6a 20		 push	 32			; 00000020H
  010c5	8b 85 38 fd ff
	ff		 mov	 eax, DWORD PTR _info$30351[ebp]
  010cb	05 08 02 00 00	 add	 eax, 520		; 00000208H
  010d0	50		 push	 eax
  010d1	6a 00		 push	 0
  010d3	6a 00		 push	 0
  010d5	68 04 40 07 00	 push	 475140			; 00074004H
  010da	8b 8d 38 fd ff
	ff		 mov	 ecx, DWORD PTR _info$30351[ebp]
  010e0	51		 push	 ecx
  010e1	e8 00 00 00 00	 call	 _TCDeviceIoControl@24
  010e6	89 85 a4 fc ff
	ff		 mov	 DWORD PTR _ntStatus$30354[ebp], eax

; 1288 : 					info->IsGPT = FALSE;

  010ec	8b 95 38 fd ff
	ff		 mov	 edx, DWORD PTR _info$30351[ebp]
  010f2	c7 82 28 02 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+552], 0
$LN65@ProcessMai:

; 1289 : 				}
; 1290 : 
; 1291 : 				if (!NT_SUCCESS (ntStatus))

  010fc	83 bd a4 fc ff
	ff 00		 cmp	 DWORD PTR _ntStatus$30354[ebp], 0
  01103	7d 6f		 jge	 SHORT $LN64@ProcessMai

; 1292 : 				{
; 1293 : 					GET_LENGTH_INFORMATION lengthInfo;
; 1294 : 					ntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_LENGTH_INFO, NULL, 0, &lengthInfo, sizeof (lengthInfo));

  01105	6a 08		 push	 8
  01107	8d 85 98 fc ff
	ff		 lea	 eax, DWORD PTR _lengthInfo$30363[ebp]
  0110d	50		 push	 eax
  0110e	6a 00		 push	 0
  01110	6a 00		 push	 0
  01112	68 5c 40 07 00	 push	 475228			; 0007405cH
  01117	8b 8d 38 fd ff
	ff		 mov	 ecx, DWORD PTR _info$30351[ebp]
  0111d	51		 push	 ecx
  0111e	e8 00 00 00 00	 call	 _TCDeviceIoControl@24
  01123	89 85 a4 fc ff
	ff		 mov	 DWORD PTR _ntStatus$30354[ebp], eax

; 1295 : 
; 1296 : 					if (NT_SUCCESS (ntStatus))

  01129	83 bd a4 fc ff
	ff 00		 cmp	 DWORD PTR _ntStatus$30354[ebp], 0
  01130	7c 42		 jl	 SHORT $LN64@ProcessMai

; 1297 : 					{
; 1298 : 						memset (&info->partInfo, 0, sizeof (info->partInfo));

  01132	33 d2		 xor	 edx, edx
  01134	8b 85 38 fd ff
	ff		 mov	 eax, DWORD PTR _info$30351[ebp]
  0113a	05 08 02 00 00	 add	 eax, 520		; 00000208H
  0113f	89 10		 mov	 DWORD PTR [eax], edx
  01141	89 50 04	 mov	 DWORD PTR [eax+4], edx
  01144	89 50 08	 mov	 DWORD PTR [eax+8], edx
  01147	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  0114a	89 50 10	 mov	 DWORD PTR [eax+16], edx
  0114d	89 50 14	 mov	 DWORD PTR [eax+20], edx
  01150	89 50 18	 mov	 DWORD PTR [eax+24], edx
  01153	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 1299 : 						info->partInfo.PartitionLength = lengthInfo.Length;

  01156	8b 8d 38 fd ff
	ff		 mov	 ecx, DWORD PTR _info$30351[ebp]
  0115c	8b 95 98 fc ff
	ff		 mov	 edx, DWORD PTR _lengthInfo$30363[ebp]
  01162	89 91 10 02 00
	00		 mov	 DWORD PTR [ecx+528], edx
  01168	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _lengthInfo$30363[ebp+4]
  0116e	89 81 14 02 00
	00		 mov	 DWORD PTR [ecx+532], eax
$LN64@ProcessMai:

; 1300 : 					}
; 1301 : 				}
; 1302 : 
; 1303 : 				info->IsDynamic = FALSE;

  01174	8b 8d 38 fd ff
	ff		 mov	 ecx, DWORD PTR _info$30351[ebp]
  0117a	c7 81 2c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+556], 0

; 1304 : 
; 1305 : 				if (NT_SUCCESS (ntStatus) && OsMajorVersion >= 6)

  01184	83 bd a4 fc ff
	ff 00		 cmp	 DWORD PTR _ntStatus$30354[ebp], 0
  0118b	7c 41		 jl	 SHORT $LN62@ProcessMai
  0118d	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _OsMajorVersion, 6
  01194	72 38		 jb	 SHORT $LN62@ProcessMai

; 1306 : 				{
; 1307 : #					define IOCTL_VOLUME_IS_DYNAMIC CTL_CODE(IOCTL_VOLUME_BASE, 18, METHOD_BUFFERED, FILE_ANY_ACCESS)
; 1308 : 					if (!NT_SUCCESS (TCDeviceIoControl (info->deviceName, IOCTL_VOLUME_IS_DYNAMIC, NULL, 0, &info->IsDynamic, sizeof (info->IsDynamic))))

  01196	6a 04		 push	 4
  01198	8b 95 38 fd ff
	ff		 mov	 edx, DWORD PTR _info$30351[ebp]
  0119e	81 c2 2c 02 00
	00		 add	 edx, 556		; 0000022cH
  011a4	52		 push	 edx
  011a5	6a 00		 push	 0
  011a7	6a 00		 push	 0
  011a9	68 48 00 56 00	 push	 5636168			; 00560048H
  011ae	8b 85 38 fd ff
	ff		 mov	 eax, DWORD PTR _info$30351[ebp]
  011b4	50		 push	 eax
  011b5	e8 00 00 00 00	 call	 _TCDeviceIoControl@24
  011ba	85 c0		 test	 eax, eax
  011bc	7d 10		 jge	 SHORT $LN62@ProcessMai

; 1309 : 						info->IsDynamic = FALSE;

  011be	8b 8d 38 fd ff
	ff		 mov	 ecx, DWORD PTR _info$30351[ebp]
  011c4	c7 81 2c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+556], 0
$LN62@ProcessMai:

; 1310 : 				}
; 1311 : 
; 1312 : 				Irp->IoStatus.Information = sizeof (DISK_PARTITION_INFO_STRUCT);

  011ce	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  011d1	c7 42 1c 30 02
	00 00		 mov	 DWORD PTR [edx+28], 560	; 00000230H

; 1313 : 				Irp->IoStatus.Status = ntStatus;

  011d8	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  011db	8b 8d a4 fc ff
	ff		 mov	 ecx, DWORD PTR _ntStatus$30354[ebp]
  011e1	89 48 18	 mov	 DWORD PTR [eax+24], ecx
$LN68@ProcessMai:

; 1314 : 			}
; 1315 : 		}
; 1316 : 		break;

  011e4	e9 d2 06 00 00	 jmp	 $LN160@ProcessMai
$LN60@ProcessMai:

; 1317 : 
; 1318 : 	case TC_IOCTL_GET_DRIVE_GEOMETRY:
; 1319 : 		if (ValidateIOBufferSize (Irp, sizeof (DISK_GEOMETRY_STRUCT), ValidateInputOutput))

  011e9	6a 02		 push	 2
  011eb	68 20 02 00 00	 push	 544			; 00000220H
  011f0	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  011f3	52		 push	 edx
  011f4	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  011f9	85 c0		 test	 eax, eax
  011fb	74 5c		 je	 SHORT $LN59@ProcessMai

; 1320 : 		{
; 1321 : 			DISK_GEOMETRY_STRUCT *g = (DISK_GEOMETRY_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  011fd	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  01200	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  01203	89 8d 94 fc ff
	ff		 mov	 DWORD PTR _g$30376[ebp], ecx

; 1322 : 			{
; 1323 : 				NTSTATUS ntStatus;
; 1324 : 
; 1325 : 				EnsureNullTerminatedString (g->deviceName, sizeof (g->deviceName));

  01209	68 08 02 00 00	 push	 520			; 00000208H
  0120e	8b 95 94 fc ff
	ff		 mov	 edx, DWORD PTR _g$30376[ebp]
  01214	52		 push	 edx
  01215	e8 00 00 00 00	 call	 _EnsureNullTerminatedString@8

; 1326 : 
; 1327 : 				ntStatus = TCDeviceIoControl (g->deviceName,
; 1328 : 					IOCTL_DISK_GET_DRIVE_GEOMETRY,
; 1329 : 					NULL, 0, &g->diskGeometry, sizeof (g->diskGeometry));

  0121a	6a 18		 push	 24			; 00000018H
  0121c	8b 85 94 fc ff
	ff		 mov	 eax, DWORD PTR _g$30376[ebp]
  01222	05 08 02 00 00	 add	 eax, 520		; 00000208H
  01227	50		 push	 eax
  01228	6a 00		 push	 0
  0122a	6a 00		 push	 0
  0122c	68 00 00 07 00	 push	 458752			; 00070000H
  01231	8b 8d 94 fc ff
	ff		 mov	 ecx, DWORD PTR _g$30376[ebp]
  01237	51		 push	 ecx
  01238	e8 00 00 00 00	 call	 _TCDeviceIoControl@24
  0123d	89 85 90 fc ff
	ff		 mov	 DWORD PTR _ntStatus$30378[ebp], eax

; 1330 : 
; 1331 : 				Irp->IoStatus.Information = sizeof (DISK_GEOMETRY_STRUCT);

  01243	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  01246	c7 42 1c 20 02
	00 00		 mov	 DWORD PTR [edx+28], 544	; 00000220H

; 1332 : 				Irp->IoStatus.Status = ntStatus;

  0124d	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  01250	8b 8d 90 fc ff
	ff		 mov	 ecx, DWORD PTR _ntStatus$30378[ebp]
  01256	89 48 18	 mov	 DWORD PTR [eax+24], ecx
$LN59@ProcessMai:

; 1333 : 			}
; 1334 : 		}
; 1335 : 		break;

  01259	e9 5d 06 00 00	 jmp	 $LN160@ProcessMai
$LN58@ProcessMai:

; 1336 : 
; 1337 : 	case TC_IOCTL_PROBE_REAL_DRIVE_SIZE:
; 1338 : 		if (ValidateIOBufferSize (Irp, sizeof (ProbeRealDriveSizeRequest), ValidateInputOutput))

  0125e	6a 02		 push	 2
  01260	68 14 02 00 00	 push	 532			; 00000214H
  01265	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  01268	52		 push	 edx
  01269	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  0126e	85 c0		 test	 eax, eax
  01270	0f 84 1f 01 00
	00		 je	 $LN57@ProcessMai

; 1339 : 		{
; 1340 : 			ProbeRealDriveSizeRequest *request = (ProbeRealDriveSizeRequest *) Irp->AssociatedIrp.SystemBuffer;

  01276	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  01279	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0127c	89 8d 7c fc ff
	ff		 mov	 DWORD PTR _request$30384[ebp], ecx

; 1341 : 			NTSTATUS status;
; 1342 : 			UNICODE_STRING name;
; 1343 : 			PFILE_OBJECT fileObject;
; 1344 : 			PDEVICE_OBJECT deviceObject;
; 1345 : 
; 1346 : 			EnsureNullTerminatedString (request->DeviceName, sizeof (request->DeviceName));

  01282	68 08 02 00 00	 push	 520			; 00000208H
  01287	8b 95 7c fc ff
	ff		 mov	 edx, DWORD PTR _request$30384[ebp]
  0128d	52		 push	 edx
  0128e	e8 00 00 00 00	 call	 _EnsureNullTerminatedString@8

; 1347 : 
; 1348 : 			RtlInitUnicodeString (&name, request->DeviceName);

  01293	8b 85 7c fc ff
	ff		 mov	 eax, DWORD PTR _request$30384[ebp]
  01299	50		 push	 eax
  0129a	8d 8d 80 fc ff
	ff		 lea	 ecx, DWORD PTR _name$30387[ebp]
  012a0	51		 push	 ecx
  012a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 1349 : 			status = IoGetDeviceObjectPointer (&name, FILE_READ_ATTRIBUTES, &fileObject, &deviceObject);

  012a7	8d 95 8c fc ff
	ff		 lea	 edx, DWORD PTR _deviceObject$30389[ebp]
  012ad	52		 push	 edx
  012ae	8d 85 88 fc ff
	ff		 lea	 eax, DWORD PTR _fileObject$30388[ebp]
  012b4	50		 push	 eax
  012b5	68 80 00 00 00	 push	 128			; 00000080H
  012ba	8d 8d 80 fc ff
	ff		 lea	 ecx, DWORD PTR _name$30387[ebp]
  012c0	51		 push	 ecx
  012c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoGetDeviceObjectPointer@16
  012c7	89 85 78 fc ff
	ff		 mov	 DWORD PTR _status$30386[ebp], eax

; 1350 : 			if (!NT_SUCCESS (status))

  012cd	83 bd 78 fc ff
	ff 00		 cmp	 DWORD PTR _status$30386[ebp], 0
  012d4	7d 1b		 jge	 SHORT $LN56@ProcessMai

; 1351 : 			{
; 1352 : 				Irp->IoStatus.Information = 0;

  012d6	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  012d9	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 1353 : 				Irp->IoStatus.Status = status;

  012e0	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  012e3	8b 8d 78 fc ff
	ff		 mov	 ecx, DWORD PTR _status$30386[ebp]
  012e9	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 1354 : 				break;

  012ec	e9 ca 05 00 00	 jmp	 $LN160@ProcessMai
$LN56@ProcessMai:

; 1355 : 			}
; 1356 : 
; 1357 : 			status = ProbeRealDriveSize (deviceObject, &request->RealDriveSize);

  012f1	8b 95 7c fc ff
	ff		 mov	 edx, DWORD PTR _request$30384[ebp]
  012f7	81 c2 08 02 00
	00		 add	 edx, 520		; 00000208H
  012fd	52		 push	 edx
  012fe	8b 85 8c fc ff
	ff		 mov	 eax, DWORD PTR _deviceObject$30389[ebp]
  01304	50		 push	 eax
  01305	e8 00 00 00 00	 call	 _ProbeRealDriveSize@8
  0130a	89 85 78 fc ff
	ff		 mov	 DWORD PTR _status$30386[ebp], eax

; 1358 : 			ObDereferenceObject (fileObject);

  01310	8b 8d 88 fc ff
	ff		 mov	 ecx, DWORD PTR _fileObject$30388[ebp]
  01316	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 1359 : 
; 1360 : 			if (status == STATUS_TIMEOUT)

  0131c	81 bd 78 fc ff
	ff 02 01 00 00	 cmp	 DWORD PTR _status$30386[ebp], 258 ; 00000102H
  01326	75 26		 jne	 SHORT $LN55@ProcessMai

; 1361 : 			{
; 1362 : 				request->TimeOut = TRUE;

  01328	8b 8d 7c fc ff
	ff		 mov	 ecx, DWORD PTR _request$30384[ebp]
  0132e	c7 81 10 02 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+528], 1

; 1363 : 				Irp->IoStatus.Information = sizeof (ProbeRealDriveSizeRequest);

  01338	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  0133b	c7 42 1c 14 02
	00 00		 mov	 DWORD PTR [edx+28], 532	; 00000214H

; 1364 : 				Irp->IoStatus.Status = STATUS_SUCCESS;

  01342	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  01345	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
  0134c	eb 47		 jmp	 SHORT $LN57@ProcessMai
$LN55@ProcessMai:

; 1365 : 			}
; 1366 : 			else if (!NT_SUCCESS (status))

  0134e	83 bd 78 fc ff
	ff 00		 cmp	 DWORD PTR _status$30386[ebp], 0
  01355	7d 18		 jge	 SHORT $LN53@ProcessMai

; 1367 : 			{
; 1368 : 				Irp->IoStatus.Information = 0;

  01357	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  0135a	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 1369 : 				Irp->IoStatus.Status = status;

  01361	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  01364	8b 85 78 fc ff
	ff		 mov	 eax, DWORD PTR _status$30386[ebp]
  0136a	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 1370 : 			}
; 1371 : 			else

  0136d	eb 26		 jmp	 SHORT $LN57@ProcessMai
$LN53@ProcessMai:

; 1372 : 			{
; 1373 : 				request->TimeOut = FALSE;

  0136f	8b 8d 7c fc ff
	ff		 mov	 ecx, DWORD PTR _request$30384[ebp]
  01375	c7 81 10 02 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+528], 0

; 1374 : 				Irp->IoStatus.Information = sizeof (ProbeRealDriveSizeRequest);

  0137f	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  01382	c7 42 1c 14 02
	00 00		 mov	 DWORD PTR [edx+28], 532	; 00000214H

; 1375 : 				Irp->IoStatus.Status = status;

  01389	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  0138c	8b 8d 78 fc ff
	ff		 mov	 ecx, DWORD PTR _status$30386[ebp]
  01392	89 48 18	 mov	 DWORD PTR [eax+24], ecx
$LN57@ProcessMai:

; 1376 : 			}
; 1377 : 		}
; 1378 : 		break;

  01395	e9 21 05 00 00	 jmp	 $LN160@ProcessMai
$LN51@ProcessMai:

; 1379 : 
; 1380 : 	case TC_IOCTL_MOUNT_VOLUME:
; 1381 : 		if (ValidateIOBufferSize (Irp, sizeof (MOUNT_STRUCT), ValidateInputOutput))

  0139a	6a 02		 push	 2
  0139c	68 e0 02 00 00	 push	 736			; 000002e0H
  013a1	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  013a4	52		 push	 edx
  013a5	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  013aa	85 c0		 test	 eax, eax
  013ac	0f 84 43 01 00
	00		 je	 $LN50@ProcessMai

; 1382 : 		{
; 1383 : 			MOUNT_STRUCT *mount = (MOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  013b2	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  013b5	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  013b8	89 8d 74 fc ff
	ff		 mov	 DWORD PTR _mount$30404[ebp], ecx

; 1384 : 
; 1385 : 			if (mount->VolumePassword.Length > MAX_PASSWORD || mount->ProtectedHidVolPassword.Length > MAX_PASSWORD)

  013be	8b 95 74 fc ff
	ff		 mov	 edx, DWORD PTR _mount$30404[ebp]
  013c4	83 ba 18 02 00
	00 40		 cmp	 DWORD PTR [edx+536], 64	; 00000040H
  013cb	77 0f		 ja	 SHORT $LN48@ProcessMai
  013cd	8b 85 74 fc ff
	ff		 mov	 eax, DWORD PTR _mount$30404[ebp]
  013d3	83 b8 90 02 00
	00 40		 cmp	 DWORD PTR [eax+656], 64	; 00000040H
  013da	76 19		 jbe	 SHORT $LN49@ProcessMai
$LN48@ProcessMai:

; 1386 : 			{
; 1387 : 				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  013dc	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  013df	c7 41 18 0d 00
	00 c0		 mov	 DWORD PTR [ecx+24], -1073741811 ; c000000dH

; 1388 : 				Irp->IoStatus.Information = 0;

  013e6	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  013e9	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 1389 : 				break;

  013f0	e9 c6 04 00 00	 jmp	 $LN160@ProcessMai
$LN49@ProcessMai:

; 1390 : 			}
; 1391 : 
; 1392 : 			EnsureNullTerminatedString (mount->wszVolume, sizeof (mount->wszVolume));

  013f5	68 08 02 00 00	 push	 520			; 00000208H
  013fa	8b 85 74 fc ff
	ff		 mov	 eax, DWORD PTR _mount$30404[ebp]
  01400	83 c0 10	 add	 eax, 16			; 00000010H
  01403	50		 push	 eax
  01404	e8 00 00 00 00	 call	 _EnsureNullTerminatedString@8

; 1393 : 
; 1394 : 			Irp->IoStatus.Information = sizeof (MOUNT_STRUCT);

  01409	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  0140c	c7 41 1c e0 02
	00 00		 mov	 DWORD PTR [ecx+28], 736	; 000002e0H

; 1395 : 			Irp->IoStatus.Status = MountDevice (DeviceObject, mount);

  01413	8b 95 74 fc ff
	ff		 mov	 edx, DWORD PTR _mount$30404[ebp]
  01419	52		 push	 edx
  0141a	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  0141d	50		 push	 eax
  0141e	e8 00 00 00 00	 call	 _MountDevice@8
  01423	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  01426	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN47@ProcessMai:

; 1396 : 
; 1397 : 			burn (&mount->VolumePassword, sizeof (mount->VolumePassword));

  01429	8b 95 74 fc ff
	ff		 mov	 edx, DWORD PTR _mount$30404[ebp]
  0142f	81 c2 18 02 00
	00		 add	 edx, 536		; 00000218H
  01435	89 95 6c fc ff
	ff		 mov	 DWORD PTR _burnm$30413[ebp], edx
  0143b	c7 85 70 fc ff
	ff 48 00 00 00	 mov	 DWORD PTR _burnc$30415[ebp], 72 ; 00000048H
  01445	6a 48		 push	 72			; 00000048H
  01447	8b 85 74 fc ff
	ff		 mov	 eax, DWORD PTR _mount$30404[ebp]
  0144d	05 18 02 00 00	 add	 eax, 536		; 00000218H
  01452	50		 push	 eax
  01453	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN44@ProcessMai:
  01458	8b 8d 70 fc ff
	ff		 mov	 ecx, DWORD PTR _burnc$30415[ebp]
  0145e	8b 95 70 fc ff
	ff		 mov	 edx, DWORD PTR _burnc$30415[ebp]
  01464	83 ea 01	 sub	 edx, 1
  01467	89 95 70 fc ff
	ff		 mov	 DWORD PTR _burnc$30415[ebp], edx
  0146d	85 c9		 test	 ecx, ecx
  0146f	74 1a		 je	 SHORT $LN46@ProcessMai
  01471	8b 85 6c fc ff
	ff		 mov	 eax, DWORD PTR _burnm$30413[ebp]
  01477	c6 00 00	 mov	 BYTE PTR [eax], 0
  0147a	8b 8d 6c fc ff
	ff		 mov	 ecx, DWORD PTR _burnm$30413[ebp]
  01480	83 c1 01	 add	 ecx, 1
  01483	89 8d 6c fc ff
	ff		 mov	 DWORD PTR _burnm$30413[ebp], ecx
  01489	eb cd		 jmp	 SHORT $LN44@ProcessMai
$LN46@ProcessMai:
  0148b	33 d2		 xor	 edx, edx
  0148d	75 9a		 jne	 SHORT $LN47@ProcessMai
$LN42@ProcessMai:

; 1398 : 			burn (&mount->ProtectedHidVolPassword, sizeof (mount->ProtectedHidVolPassword));

  0148f	8b 85 74 fc ff
	ff		 mov	 eax, DWORD PTR _mount$30404[ebp]
  01495	05 90 02 00 00	 add	 eax, 656		; 00000290H
  0149a	89 85 64 fc ff
	ff		 mov	 DWORD PTR _burnm$30422[ebp], eax
  014a0	c7 85 68 fc ff
	ff 48 00 00 00	 mov	 DWORD PTR _burnc$30424[ebp], 72 ; 00000048H
  014aa	6a 48		 push	 72			; 00000048H
  014ac	8b 8d 74 fc ff
	ff		 mov	 ecx, DWORD PTR _mount$30404[ebp]
  014b2	81 c1 90 02 00
	00		 add	 ecx, 656		; 00000290H
  014b8	51		 push	 ecx
  014b9	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN39@ProcessMai:
  014be	8b 95 68 fc ff
	ff		 mov	 edx, DWORD PTR _burnc$30424[ebp]
  014c4	8b 85 68 fc ff
	ff		 mov	 eax, DWORD PTR _burnc$30424[ebp]
  014ca	83 e8 01	 sub	 eax, 1
  014cd	89 85 68 fc ff
	ff		 mov	 DWORD PTR _burnc$30424[ebp], eax
  014d3	85 d2		 test	 edx, edx
  014d5	74 1a		 je	 SHORT $LN41@ProcessMai
  014d7	8b 8d 64 fc ff
	ff		 mov	 ecx, DWORD PTR _burnm$30422[ebp]
  014dd	c6 01 00	 mov	 BYTE PTR [ecx], 0
  014e0	8b 95 64 fc ff
	ff		 mov	 edx, DWORD PTR _burnm$30422[ebp]
  014e6	83 c2 01	 add	 edx, 1
  014e9	89 95 64 fc ff
	ff		 mov	 DWORD PTR _burnm$30422[ebp], edx
  014ef	eb cd		 jmp	 SHORT $LN39@ProcessMai
$LN41@ProcessMai:
  014f1	33 c0		 xor	 eax, eax
  014f3	75 9a		 jne	 SHORT $LN42@ProcessMai
$LN50@ProcessMai:

; 1399 : 		}
; 1400 : 		break;

  014f5	e9 c1 03 00 00	 jmp	 $LN160@ProcessMai
$LN37@ProcessMai:

; 1401 : 
; 1402 : 	case TC_IOCTL_DISMOUNT_VOLUME:
; 1403 : 		if (ValidateIOBufferSize (Irp, sizeof (UNMOUNT_STRUCT), ValidateInputOutput))

  014fa	6a 02		 push	 2
  014fc	6a 10		 push	 16			; 00000010H
  014fe	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  01501	51		 push	 ecx
  01502	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  01507	85 c0		 test	 eax, eax
  01509	0f 84 8f 00 00
	00		 je	 $LN36@ProcessMai

; 1404 : 		{
; 1405 : 			UNMOUNT_STRUCT *unmount = (UNMOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  0150f	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  01512	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  01515	89 85 60 fc ff
	ff		 mov	 DWORD PTR _unmount$30431[ebp], eax

; 1406 : 			PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject (unmount->nDosDriveNo);

  0151b	8b 8d 60 fc ff
	ff		 mov	 ecx, DWORD PTR _unmount$30431[ebp]
  01521	8b 11		 mov	 edx, DWORD PTR [ecx]
  01523	52		 push	 edx
  01524	e8 00 00 00 00	 call	 _GetVirtualVolumeDeviceObject@4
  01529	89 85 5c fc ff
	ff		 mov	 DWORD PTR _ListDevice$30433[ebp], eax

; 1407 : 
; 1408 : 			unmount->nReturnCode = ERR_DRIVE_NOT_FOUND;

  0152f	8b 85 60 fc ff
	ff		 mov	 eax, DWORD PTR _unmount$30431[ebp]
  01535	c7 40 0c 05 00
	00 00		 mov	 DWORD PTR [eax+12], 5

; 1409 : 
; 1410 : 			if (ListDevice)

  0153c	83 bd 5c fc ff
	ff 00		 cmp	 DWORD PTR _ListDevice$30433[ebp], 0
  01543	74 45		 je	 SHORT $LN35@ProcessMai

; 1411 : 			{
; 1412 : 				PEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;

  01545	8b 8d 5c fc ff
	ff		 mov	 ecx, DWORD PTR _ListDevice$30433[ebp]
  0154b	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0154e	89 95 58 fc ff
	ff		 mov	 DWORD PTR _ListExtension$30435[ebp], edx

; 1413 : 
; 1414 : 				if (IsVolumeAccessibleByCurrentUser (ListExtension))

  01554	8b 85 58 fc ff
	ff		 mov	 eax, DWORD PTR _ListExtension$30435[ebp]
  0155a	50		 push	 eax
  0155b	e8 00 00 00 00	 call	 _IsVolumeAccessibleByCurrentUser@4
  01560	85 c0		 test	 eax, eax
  01562	74 26		 je	 SHORT $LN35@ProcessMai

; 1415 : 					unmount->nReturnCode = UnmountDevice (unmount, ListDevice, unmount->ignoreOpenFiles);

  01564	8b 8d 60 fc ff
	ff		 mov	 ecx, DWORD PTR _unmount$30431[ebp]
  0156a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0156d	52		 push	 edx
  0156e	8b 85 5c fc ff
	ff		 mov	 eax, DWORD PTR _ListDevice$30433[ebp]
  01574	50		 push	 eax
  01575	8b 8d 60 fc ff
	ff		 mov	 ecx, DWORD PTR _unmount$30431[ebp]
  0157b	51		 push	 ecx
  0157c	e8 00 00 00 00	 call	 _UnmountDevice@12
  01581	8b 95 60 fc ff
	ff		 mov	 edx, DWORD PTR _unmount$30431[ebp]
  01587	89 42 0c	 mov	 DWORD PTR [edx+12], eax
$LN35@ProcessMai:

; 1416 : 			}
; 1417 : 
; 1418 : 			Irp->IoStatus.Information = sizeof (UNMOUNT_STRUCT);

  0158a	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  0158d	c7 40 1c 10 00
	00 00		 mov	 DWORD PTR [eax+28], 16	; 00000010H

; 1419 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  01594	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  01597	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
$LN36@ProcessMai:

; 1420 : 		}
; 1421 : 		break;

  0159e	e9 18 03 00 00	 jmp	 $LN160@ProcessMai
$LN33@ProcessMai:

; 1422 : 
; 1423 : 	case TC_IOCTL_DISMOUNT_ALL_VOLUMES:
; 1424 : 		if (ValidateIOBufferSize (Irp, sizeof (UNMOUNT_STRUCT), ValidateInputOutput))

  015a3	6a 02		 push	 2
  015a5	6a 10		 push	 16			; 00000010H
  015a7	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  015aa	52		 push	 edx
  015ab	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  015b0	85 c0		 test	 eax, eax
  015b2	74 3f		 je	 SHORT $LN32@ProcessMai

; 1425 : 		{
; 1426 : 			UNMOUNT_STRUCT *unmount = (UNMOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  015b4	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  015b7	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  015ba	89 8d 54 fc ff
	ff		 mov	 DWORD PTR _unmount$30443[ebp], ecx

; 1427 : 
; 1428 : 			unmount->nReturnCode = UnmountAllDevices (unmount, unmount->ignoreOpenFiles);

  015c0	8b 95 54 fc ff
	ff		 mov	 edx, DWORD PTR _unmount$30443[ebp]
  015c6	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  015c9	50		 push	 eax
  015ca	8b 8d 54 fc ff
	ff		 mov	 ecx, DWORD PTR _unmount$30443[ebp]
  015d0	51		 push	 ecx
  015d1	e8 00 00 00 00	 call	 _UnmountAllDevices@8
  015d6	8b 95 54 fc ff
	ff		 mov	 edx, DWORD PTR _unmount$30443[ebp]
  015dc	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 1429 : 
; 1430 : 			Irp->IoStatus.Information = sizeof (UNMOUNT_STRUCT);

  015df	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  015e2	c7 40 1c 10 00
	00 00		 mov	 DWORD PTR [eax+28], 16	; 00000010H

; 1431 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  015e9	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  015ec	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
$LN32@ProcessMai:

; 1432 : 		}
; 1433 : 		break;

  015f3	e9 c3 02 00 00	 jmp	 $LN160@ProcessMai
$LN31@ProcessMai:

; 1434 : 
; 1435 : 	case TC_IOCTL_BOOT_ENCRYPTION_SETUP:
; 1436 : 		Irp->IoStatus.Status = StartBootEncryptionSetup (DeviceObject, Irp, irpSp);

  015f8	8b 55 f8	 mov	 edx, DWORD PTR _irpSp$[ebp]
  015fb	52		 push	 edx
  015fc	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  015ff	50		 push	 eax
  01600	8b 4d 08	 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  01603	51		 push	 ecx
  01604	e8 00 00 00 00	 call	 _StartBootEncryptionSetup@12
  01609	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  0160c	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 1437 : 		Irp->IoStatus.Information = 0;

  0160f	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  01612	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 1438 : 		break;

  01619	e9 9d 02 00 00	 jmp	 $LN160@ProcessMai
$LN30@ProcessMai:

; 1439 : 
; 1440 : 	case TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP:
; 1441 : 		Irp->IoStatus.Status = AbortBootEncryptionSetup();

  0161e	e8 00 00 00 00	 call	 _AbortBootEncryptionSetup@0
  01623	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  01626	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 1442 : 		Irp->IoStatus.Information = 0;

  01629	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  0162c	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 1443 : 		break;

  01633	e9 83 02 00 00	 jmp	 $LN160@ProcessMai
$LN29@ProcessMai:

; 1444 : 
; 1445 : 	case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS:
; 1446 : 		GetBootEncryptionStatus (Irp, irpSp);

  01638	8b 45 f8	 mov	 eax, DWORD PTR _irpSp$[ebp]
  0163b	50		 push	 eax
  0163c	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  0163f	51		 push	 ecx
  01640	e8 00 00 00 00	 call	 _GetBootEncryptionStatus@8

; 1447 : 		break;

  01645	e9 71 02 00 00	 jmp	 $LN160@ProcessMai
$LN28@ProcessMai:

; 1448 : 
; 1449 : 	case TC_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT:
; 1450 : 		Irp->IoStatus.Information = 0;

  0164a	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  0164d	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 1451 : 		Irp->IoStatus.Status = GetSetupResult();

  01654	e8 00 00 00 00	 call	 _GetSetupResult@0
  01659	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  0165c	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 1452 : 		break;

  0165f	e9 57 02 00 00	 jmp	 $LN160@ProcessMai
$LN27@ProcessMai:

; 1453 : 
; 1454 : 	case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:
; 1455 : 		GetBootDriveVolumeProperties (Irp, irpSp);

  01664	8b 55 f8	 mov	 edx, DWORD PTR _irpSp$[ebp]
  01667	52		 push	 edx
  01668	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  0166b	50		 push	 eax
  0166c	e8 00 00 00 00	 call	 _GetBootDriveVolumeProperties@8

; 1456 : 		break;

  01671	e9 45 02 00 00	 jmp	 $LN160@ProcessMai
$LN26@ProcessMai:

; 1457 : 
; 1458 : 	case TC_IOCTL_GET_BOOT_LOADER_VERSION:
; 1459 : 		GetBootLoaderVersion (Irp, irpSp);

  01676	8b 4d f8	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  01679	51		 push	 ecx
  0167a	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  0167d	52		 push	 edx
  0167e	e8 00 00 00 00	 call	 _GetBootLoaderVersion@8

; 1460 : 		break;

  01683	e9 33 02 00 00	 jmp	 $LN160@ProcessMai
$LN25@ProcessMai:

; 1461 : 
; 1462 : 	case TC_IOCTL_REOPEN_BOOT_VOLUME_HEADER:
; 1463 : 		ReopenBootVolumeHeader (Irp, irpSp);

  01688	8b 45 f8	 mov	 eax, DWORD PTR _irpSp$[ebp]
  0168b	50		 push	 eax
  0168c	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  0168f	51		 push	 ecx
  01690	e8 00 00 00 00	 call	 _ReopenBootVolumeHeader@8

; 1464 : 		break;

  01695	e9 21 02 00 00	 jmp	 $LN160@ProcessMai
$LN24@ProcessMai:

; 1465 : 
; 1466 : 	case TC_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME:
; 1467 : 		GetBootEncryptionAlgorithmName (Irp, irpSp);

  0169a	8b 55 f8	 mov	 edx, DWORD PTR _irpSp$[ebp]
  0169d	52		 push	 edx
  0169e	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  016a1	50		 push	 eax
  016a2	e8 00 00 00 00	 call	 _GetBootEncryptionAlgorithmName@8

; 1468 : 		break;

  016a7	e9 0f 02 00 00	 jmp	 $LN160@ProcessMai
$LN23@ProcessMai:

; 1469 : 
; 1470 : 	case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:
; 1471 : 		if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))

  016ac	6a 01		 push	 1
  016ae	6a 04		 push	 4
  016b0	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  016b3	51		 push	 ecx
  016b4	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  016b9	85 c0		 test	 eax, eax
  016bb	74 27		 je	 SHORT $LN22@ProcessMai

; 1472 : 		{
; 1473 : 			*(int *) Irp->AssociatedIrp.SystemBuffer = IsHiddenSystemRunning() ? 1 : 0;

  016bd	e8 00 00 00 00	 call	 _IsHiddenSystemRunning@0
  016c2	f7 d8		 neg	 eax
  016c4	1b c0		 sbb	 eax, eax
  016c6	f7 d8		 neg	 eax
  016c8	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  016cb	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  016ce	89 01		 mov	 DWORD PTR [ecx], eax

; 1474 : 			Irp->IoStatus.Information = sizeof (int);

  016d0	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  016d3	c7 42 1c 04 00
	00 00		 mov	 DWORD PTR [edx+28], 4

; 1475 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  016da	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  016dd	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
$LN22@ProcessMai:

; 1476 : 		}
; 1477 : 		break;

  016e4	e9 d2 01 00 00	 jmp	 $LN160@ProcessMai
$LN21@ProcessMai:

; 1478 : 
; 1479 : 	case TC_IOCTL_START_DECOY_SYSTEM_WIPE:
; 1480 : 		Irp->IoStatus.Status = StartDecoySystemWipe (DeviceObject, Irp, irpSp);

  016e9	8b 4d f8	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  016ec	51		 push	 ecx
  016ed	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  016f0	52		 push	 edx
  016f1	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  016f4	50		 push	 eax
  016f5	e8 00 00 00 00	 call	 _StartDecoySystemWipe@12
  016fa	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  016fd	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 1481 : 		Irp->IoStatus.Information = 0;

  01700	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  01703	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 1482 : 		break;

  0170a	e9 ac 01 00 00	 jmp	 $LN160@ProcessMai
$LN20@ProcessMai:

; 1483 : 
; 1484 : 	case TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE:
; 1485 : 		Irp->IoStatus.Status = AbortDecoySystemWipe();

  0170f	e8 00 00 00 00	 call	 _AbortDecoySystemWipe@0
  01714	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  01717	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 1486 : 		Irp->IoStatus.Information = 0;

  0171a	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  0171d	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 1487 : 		break;

  01724	e9 92 01 00 00	 jmp	 $LN160@ProcessMai
$LN19@ProcessMai:

; 1488 : 
; 1489 : 	case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT:
; 1490 : 		Irp->IoStatus.Status = GetDecoySystemWipeResult();

  01729	e8 00 00 00 00	 call	 _GetDecoySystemWipeResult@0
  0172e	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  01731	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 1491 : 		Irp->IoStatus.Information = 0;

  01734	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  01737	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 1492 : 		break;

  0173e	e9 78 01 00 00	 jmp	 $LN160@ProcessMai
$LN18@ProcessMai:

; 1493 : 
; 1494 : 	case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS:
; 1495 : 		GetDecoySystemWipeStatus (Irp, irpSp);

  01743	8b 45 f8	 mov	 eax, DWORD PTR _irpSp$[ebp]
  01746	50		 push	 eax
  01747	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  0174a	51		 push	 ecx
  0174b	e8 00 00 00 00	 call	 _GetDecoySystemWipeStatus@8

; 1496 : 		break;

  01750	e9 66 01 00 00	 jmp	 $LN160@ProcessMai
$LN17@ProcessMai:

; 1497 : 
; 1498 : 	case TC_IOCTL_WRITE_BOOT_DRIVE_SECTOR:
; 1499 : 		Irp->IoStatus.Status = WriteBootDriveSector (Irp, irpSp);

  01755	8b 55 f8	 mov	 edx, DWORD PTR _irpSp$[ebp]
  01758	52		 push	 edx
  01759	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  0175c	50		 push	 eax
  0175d	e8 00 00 00 00	 call	 _WriteBootDriveSector@8
  01762	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  01765	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 1500 : 		Irp->IoStatus.Information = 0;

  01768	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  0176b	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 1501 : 		break;

  01772	e9 44 01 00 00	 jmp	 $LN160@ProcessMai
$LN16@ProcessMai:

; 1502 : 
; 1503 : 	case TC_IOCTL_GET_WARNING_FLAGS:
; 1504 : 		if (ValidateIOBufferSize (Irp, sizeof (GetWarningFlagsRequest), ValidateOutput))

  01777	6a 01		 push	 1
  01779	6a 08		 push	 8
  0177b	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  0177e	50		 push	 eax
  0177f	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  01784	85 c0		 test	 eax, eax
  01786	74 50		 je	 SHORT $LN15@ProcessMai

; 1505 : 		{
; 1506 : 			GetWarningFlagsRequest *flags = (GetWarningFlagsRequest *) Irp->AssociatedIrp.SystemBuffer;

  01788	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  0178b	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0178e	89 95 50 fc ff
	ff		 mov	 DWORD PTR _flags$30469[ebp], edx

; 1507 : 
; 1508 : 			flags->PagingFileCreationPrevented = PagingFileCreationPrevented;

  01794	8b 85 50 fc ff
	ff		 mov	 eax, DWORD PTR _flags$30469[ebp]
  0179a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _PagingFileCreationPrevented
  017a0	89 08		 mov	 DWORD PTR [eax], ecx

; 1509 : 			PagingFileCreationPrevented = FALSE;

  017a2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _PagingFileCreationPrevented, 0

; 1510 : 			flags->SystemFavoriteVolumeDirty = SystemFavoriteVolumeDirty;

  017ac	8b 95 50 fc ff
	ff		 mov	 edx, DWORD PTR _flags$30469[ebp]
  017b2	a1 00 00 00 00	 mov	 eax, DWORD PTR _SystemFavoriteVolumeDirty
  017b7	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1511 : 			SystemFavoriteVolumeDirty = FALSE;

  017ba	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _SystemFavoriteVolumeDirty, 0

; 1512 : 
; 1513 : 			Irp->IoStatus.Information = sizeof (GetWarningFlagsRequest);

  017c4	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  017c7	c7 41 1c 08 00
	00 00		 mov	 DWORD PTR [ecx+28], 8

; 1514 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  017ce	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  017d1	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0
$LN15@ProcessMai:

; 1515 : 		}
; 1516 : 		break;

  017d8	e9 de 00 00 00	 jmp	 $LN160@ProcessMai
$LN14@ProcessMai:

; 1517 : 
; 1518 : 	case TC_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY:
; 1519 : 		if (UserCanAccessDriveDevice())

  017dd	e8 00 00 00 00	 call	 _UserCanAccessDriveDevice@0
  017e2	85 c0		 test	 eax, eax
  017e4	74 16		 je	 SHORT $LN13@ProcessMai

; 1520 : 		{
; 1521 : 			SystemFavoriteVolumeDirty = TRUE;

  017e6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _SystemFavoriteVolumeDirty, 1

; 1522 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  017f0	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  017f3	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 1523 : 		}
; 1524 : 		else

  017fa	eb 0a		 jmp	 SHORT $LN12@ProcessMai
$LN13@ProcessMai:

; 1525 : 			Irp->IoStatus.Status = STATUS_ACCESS_DENIED;

  017fc	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  017ff	c7 41 18 22 00
	00 c0		 mov	 DWORD PTR [ecx+24], -1073741790 ; c0000022H
$LN12@ProcessMai:

; 1526 : 
; 1527 : 		Irp->IoStatus.Information = 0;

  01806	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  01809	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 1528 : 		break;

  01810	e9 a6 00 00 00	 jmp	 $LN160@ProcessMai
$LN11@ProcessMai:

; 1529 : 
; 1530 : 	case TC_IOCTL_REREAD_DRIVER_CONFIG:
; 1531 : 		Irp->IoStatus.Status = ReadRegistryConfigFlags (FALSE);

  01815	6a 00		 push	 0
  01817	e8 00 00 00 00	 call	 _ReadRegistryConfigFlags@4
  0181c	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  0181f	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 1532 : 		Irp->IoStatus.Information = 0;

  01822	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  01825	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 1533 : 		break;

  0182c	e9 8a 00 00 00	 jmp	 $LN160@ProcessMai
$LN10@ProcessMai:

; 1534 : 
; 1535 : 	case TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG:
; 1536 : 		if (ValidateIOBufferSize (Irp, sizeof (GetSystemDriveDumpConfigRequest), ValidateOutput))

  01831	6a 01		 push	 1
  01833	6a 08		 push	 8
  01835	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  01838	50		 push	 eax
  01839	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  0183e	85 c0		 test	 eax, eax
  01840	74 65		 je	 SHORT $LN9@ProcessMai

; 1537 : 		{
; 1538 : 			GetSystemDriveDumpConfigRequest *request = (GetSystemDriveDumpConfigRequest *) Irp->AssociatedIrp.SystemBuffer;

  01842	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  01845	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  01848	89 95 4c fc ff
	ff		 mov	 DWORD PTR _request$30482[ebp], edx

; 1539 : 
; 1540 : 			request->BootDriveFilterExtension = GetBootDriveFilterExtension();

  0184e	e8 00 00 00 00	 call	 _GetBootDriveFilterExtension@0
  01853	8b 8d 4c fc ff
	ff		 mov	 ecx, DWORD PTR _request$30482[ebp]
  01859	89 01		 mov	 DWORD PTR [ecx], eax

; 1541 : 			if (IsBootDriveMounted() && request->BootDriveFilterExtension)

  0185b	e8 00 00 00 00	 call	 _IsBootDriveMounted@0
  01860	85 c0		 test	 eax, eax
  01862	74 2f		 je	 SHORT $LN8@ProcessMai
  01864	8b 95 4c fc ff
	ff		 mov	 edx, DWORD PTR _request$30482[ebp]
  0186a	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0186d	74 24		 je	 SHORT $LN8@ProcessMai

; 1542 : 			{
; 1543 : 				request->HwEncryptionEnabled = IsHwEncryptionEnabled();

  0186f	e8 00 00 00 00	 call	 _IsHwEncryptionEnabled@0
  01874	8b 8d 4c fc ff
	ff		 mov	 ecx, DWORD PTR _request$30482[ebp]
  0187a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1544 : 				Irp->IoStatus.Status = STATUS_SUCCESS;

  0187d	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  01880	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 1545 : 				Irp->IoStatus.Information = sizeof (*request);

  01887	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  0188a	c7 40 1c 08 00
	00 00		 mov	 DWORD PTR [eax+28], 8

; 1546 : 			}
; 1547 : 			else

  01891	eb 14		 jmp	 SHORT $LN9@ProcessMai
$LN8@ProcessMai:

; 1548 : 			{
; 1549 : 				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  01893	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  01896	c7 41 18 0d 00
	00 c0		 mov	 DWORD PTR [ecx+24], -1073741811 ; c000000dH

; 1550 : 				Irp->IoStatus.Information = 0;

  0189d	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  018a0	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0
$LN9@ProcessMai:

; 1551 : 			}
; 1552 : 		}
; 1553 : 		break;

  018a7	eb 12		 jmp	 SHORT $LN160@ProcessMai
$LN6@ProcessMai:

; 1554 : 
; 1555 : 	default:
; 1556 : 		return TCCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);

  018a9	6a 00		 push	 0
  018ab	68 10 00 00 c0	 push	 -1073741808		; c0000010H
  018b0	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  018b3	50		 push	 eax
  018b4	e8 00 00 00 00	 call	 _TCCompleteIrp@12
  018b9	eb 71		 jmp	 SHORT $LN162@ProcessMai
$LN160@ProcessMai:

; 1557 : 	}
; 1558 : 
; 1559 : 	
; 1560 : #ifdef DEBUG
; 1561 : 	if (!NT_SUCCESS (Irp->IoStatus.Status))

  018bb	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  018be	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  018c2	7d 51		 jge	 SHORT $LN5@ProcessMai

; 1562 : 	{
; 1563 : 		switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  018c4	8b 55 f8	 mov	 edx, DWORD PTR _irpSp$[ebp]
  018c7	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  018ca	89 85 1c fc ff
	ff		 mov	 DWORD PTR tv960[ebp], eax
  018d0	8b 8d 1c fc ff
	ff		 mov	 ecx, DWORD PTR tv960[ebp]
  018d6	81 e9 18 20 22
	00		 sub	 ecx, 2236440		; 00222018H
  018dc	89 8d 1c fc ff
	ff		 mov	 DWORD PTR tv960[ebp], ecx
  018e2	83 bd 1c fc ff
	ff 54		 cmp	 DWORD PTR tv960[ebp], 84 ; 00000054H
  018e9	77 16		 ja	 SHORT $LN1@ProcessMai
  018eb	8b 95 1c fc ff
	ff		 mov	 edx, DWORD PTR tv960[ebp]
  018f1	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN178@ProcessMai[edx]
  018f8	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN180@ProcessMai[eax*4]
$LN2@ProcessMai:

; 1564 : 		{
; 1565 : 		case TC_IOCTL_GET_MOUNTED_VOLUMES:
; 1566 : 		case TC_IOCTL_GET_PASSWORD_CACHE_STATUS:
; 1567 : 		case TC_IOCTL_GET_PORTABLE_MODE_STATUS:
; 1568 : 		case TC_IOCTL_SET_PORTABLE_MODE_STATUS:
; 1569 : 		case TC_IOCTL_OPEN_TEST:
; 1570 : 		case TC_IOCTL_GET_RESOLVED_SYMLINK:
; 1571 : 		case TC_IOCTL_GET_DRIVE_PARTITION_INFO:
; 1572 : 		case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:
; 1573 : 		case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS:
; 1574 : 		case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:
; 1575 : 			break;

  018ff	eb 14		 jmp	 SHORT $LN5@ProcessMai
$LN1@ProcessMai:

; 1576 : 
; 1577 : 		default:
; 1578 : 			Dump ("IOCTL error 0x%08x\n", Irp->IoStatus.Status);

  01901	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  01904	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  01907	52		 push	 edx
  01908	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@MLCKFMJI@IOCTL?5error?50x?$CF08x?6?$AA@FNODOBFM@
  0190d	e8 00 00 00 00	 call	 _DbgPrint
  01912	83 c4 08	 add	 esp, 8
$LN5@ProcessMai:

; 1579 : 		}
; 1580 : 	}
; 1581 : #endif
; 1582 : 
; 1583 : 	return TCCompleteIrp (Irp, Irp->IoStatus.Status, Irp->IoStatus.Information);

  01915	8b 45 10	 mov	 eax, DWORD PTR _Irp$[ebp]
  01918	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0191b	51		 push	 ecx
  0191c	8b 55 10	 mov	 edx, DWORD PTR _Irp$[ebp]
  0191f	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  01922	50		 push	 eax
  01923	8b 4d 10	 mov	 ecx, DWORD PTR _Irp$[ebp]
  01926	51		 push	 ecx
  01927	e8 00 00 00 00	 call	 _TCCompleteIrp@12
$LN162@ProcessMai:

; 1584 : }

  0192c	5f		 pop	 edi
  0192d	5e		 pop	 esi
  0192e	8b 4d 9c	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01931	33 cd		 xor	 ecx, ebp
  01933	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01938	8b e5		 mov	 esp, ebp
  0193a	5d		 pop	 ebp
  0193b	c2 0c 00	 ret	 12			; 0000000cH
  0193e	8b ff		 npad	 2
$LN179@ProcessMai:
  01940	00 00 00 00	 DD	 $LN26@ProcessMai
  01944	00 00 00 00	 DD	 $LN51@ProcessMai
  01948	00 00 00 00	 DD	 $LN37@ProcessMai
  0194c	00 00 00 00	 DD	 $LN33@ProcessMai
  01950	00 00 00 00	 DD	 $LN92@ProcessMai
  01954	00 00 00 00	 DD	 $LN77@ProcessMai
  01958	00 00 00 00	 DD	 $LN157@ProcessMai
  0195c	00 00 00 00	 DD	 $LN155@ProcessMai
  01960	00 00 00 00	 DD	 $LN152@ProcessMai
  01964	00 00 00 00	 DD	 $LN97@ProcessMai
  01968	00 00 00 00	 DD	 $LN98@ProcessMai
  0196c	00 00 00 00	 DD	 $LN145@ProcessMai
  01970	00 00 00 00	 DD	 $LN69@ProcessMai
  01974	00 00 00 00	 DD	 $LN60@ProcessMai
  01978	00 00 00 00	 DD	 $LN58@ProcessMai
  0197c	00 00 00 00	 DD	 $LN71@ProcessMai
  01980	00 00 00 00	 DD	 $LN29@ProcessMai
  01984	00 00 00 00	 DD	 $LN31@ProcessMai
  01988	00 00 00 00	 DD	 $LN30@ProcessMai
  0198c	00 00 00 00	 DD	 $LN28@ProcessMai
  01990	00 00 00 00	 DD	 $LN27@ProcessMai
  01994	00 00 00 00	 DD	 $LN25@ProcessMai
  01998	00 00 00 00	 DD	 $LN24@ProcessMai
  0199c	00 00 00 00	 DD	 $LN93@ProcessMai
  019a0	00 00 00 00	 DD	 $LN96@ProcessMai
  019a4	00 00 00 00	 DD	 $LN23@ProcessMai
  019a8	00 00 00 00	 DD	 $LN120@ProcessMai
  019ac	00 00 00 00	 DD	 $LN21@ProcessMai
  019b0	00 00 00 00	 DD	 $LN20@ProcessMai
  019b4	00 00 00 00	 DD	 $LN18@ProcessMai
  019b8	00 00 00 00	 DD	 $LN19@ProcessMai
  019bc	00 00 00 00	 DD	 $LN17@ProcessMai
  019c0	00 00 00 00	 DD	 $LN16@ProcessMai
  019c4	00 00 00 00	 DD	 $LN14@ProcessMai
  019c8	00 00 00 00	 DD	 $LN11@ProcessMai
  019cc	00 00 00 00	 DD	 $LN10@ProcessMai
  019d0	00 00 00 00	 DD	 $LN6@ProcessMai
$LN168@ProcessMai:
  019d4	00		 DB	 0
  019d5	24		 DB	 36			; 00000024H
  019d6	24		 DB	 36			; 00000024H
  019d7	24		 DB	 36			; 00000024H
  019d8	01		 DB	 1
  019d9	24		 DB	 36			; 00000024H
  019da	24		 DB	 36			; 00000024H
  019db	24		 DB	 36			; 00000024H
  019dc	02		 DB	 2
  019dd	24		 DB	 36			; 00000024H
  019de	24		 DB	 36			; 00000024H
  019df	24		 DB	 36			; 00000024H
  019e0	03		 DB	 3
  019e1	24		 DB	 36			; 00000024H
  019e2	24		 DB	 36			; 00000024H
  019e3	24		 DB	 36			; 00000024H
  019e4	04		 DB	 4
  019e5	24		 DB	 36			; 00000024H
  019e6	24		 DB	 36			; 00000024H
  019e7	24		 DB	 36			; 00000024H
  019e8	05		 DB	 5
  019e9	24		 DB	 36			; 00000024H
  019ea	24		 DB	 36			; 00000024H
  019eb	24		 DB	 36			; 00000024H
  019ec	06		 DB	 6
  019ed	24		 DB	 36			; 00000024H
  019ee	24		 DB	 36			; 00000024H
  019ef	24		 DB	 36			; 00000024H
  019f0	07		 DB	 7
  019f1	24		 DB	 36			; 00000024H
  019f2	24		 DB	 36			; 00000024H
  019f3	24		 DB	 36			; 00000024H
  019f4	08		 DB	 8
  019f5	24		 DB	 36			; 00000024H
  019f6	24		 DB	 36			; 00000024H
  019f7	24		 DB	 36			; 00000024H
  019f8	09		 DB	 9
  019f9	24		 DB	 36			; 00000024H
  019fa	24		 DB	 36			; 00000024H
  019fb	24		 DB	 36			; 00000024H
  019fc	0a		 DB	 10			; 0000000aH
  019fd	24		 DB	 36			; 00000024H
  019fe	24		 DB	 36			; 00000024H
  019ff	24		 DB	 36			; 00000024H
  01a00	0b		 DB	 11			; 0000000bH
  01a01	24		 DB	 36			; 00000024H
  01a02	24		 DB	 36			; 00000024H
  01a03	24		 DB	 36			; 00000024H
  01a04	0c		 DB	 12			; 0000000cH
  01a05	24		 DB	 36			; 00000024H
  01a06	24		 DB	 36			; 00000024H
  01a07	24		 DB	 36			; 00000024H
  01a08	0d		 DB	 13			; 0000000dH
  01a09	24		 DB	 36			; 00000024H
  01a0a	24		 DB	 36			; 00000024H
  01a0b	24		 DB	 36			; 00000024H
  01a0c	0e		 DB	 14			; 0000000eH
  01a0d	24		 DB	 36			; 00000024H
  01a0e	24		 DB	 36			; 00000024H
  01a0f	24		 DB	 36			; 00000024H
  01a10	0f		 DB	 15			; 0000000fH
  01a11	24		 DB	 36			; 00000024H
  01a12	24		 DB	 36			; 00000024H
  01a13	24		 DB	 36			; 00000024H
  01a14	10		 DB	 16			; 00000010H
  01a15	24		 DB	 36			; 00000024H
  01a16	24		 DB	 36			; 00000024H
  01a17	24		 DB	 36			; 00000024H
  01a18	11		 DB	 17			; 00000011H
  01a19	24		 DB	 36			; 00000024H
  01a1a	24		 DB	 36			; 00000024H
  01a1b	24		 DB	 36			; 00000024H
  01a1c	12		 DB	 18			; 00000012H
  01a1d	24		 DB	 36			; 00000024H
  01a1e	24		 DB	 36			; 00000024H
  01a1f	24		 DB	 36			; 00000024H
  01a20	13		 DB	 19			; 00000013H
  01a21	24		 DB	 36			; 00000024H
  01a22	24		 DB	 36			; 00000024H
  01a23	24		 DB	 36			; 00000024H
  01a24	14		 DB	 20			; 00000014H
  01a25	24		 DB	 36			; 00000024H
  01a26	24		 DB	 36			; 00000024H
  01a27	24		 DB	 36			; 00000024H
  01a28	15		 DB	 21			; 00000015H
  01a29	24		 DB	 36			; 00000024H
  01a2a	24		 DB	 36			; 00000024H
  01a2b	24		 DB	 36			; 00000024H
  01a2c	16		 DB	 22			; 00000016H
  01a2d	24		 DB	 36			; 00000024H
  01a2e	24		 DB	 36			; 00000024H
  01a2f	24		 DB	 36			; 00000024H
  01a30	17		 DB	 23			; 00000017H
  01a31	24		 DB	 36			; 00000024H
  01a32	24		 DB	 36			; 00000024H
  01a33	24		 DB	 36			; 00000024H
  01a34	18		 DB	 24			; 00000018H
  01a35	24		 DB	 36			; 00000024H
  01a36	24		 DB	 36			; 00000024H
  01a37	24		 DB	 36			; 00000024H
  01a38	19		 DB	 25			; 00000019H
  01a39	24		 DB	 36			; 00000024H
  01a3a	24		 DB	 36			; 00000024H
  01a3b	24		 DB	 36			; 00000024H
  01a3c	1a		 DB	 26			; 0000001aH
  01a3d	24		 DB	 36			; 00000024H
  01a3e	24		 DB	 36			; 00000024H
  01a3f	24		 DB	 36			; 00000024H
  01a40	24		 DB	 36			; 00000024H
  01a41	24		 DB	 36			; 00000024H
  01a42	24		 DB	 36			; 00000024H
  01a43	24		 DB	 36			; 00000024H
  01a44	1b		 DB	 27			; 0000001bH
  01a45	24		 DB	 36			; 00000024H
  01a46	24		 DB	 36			; 00000024H
  01a47	24		 DB	 36			; 00000024H
  01a48	1c		 DB	 28			; 0000001cH
  01a49	24		 DB	 36			; 00000024H
  01a4a	24		 DB	 36			; 00000024H
  01a4b	24		 DB	 36			; 00000024H
  01a4c	1d		 DB	 29			; 0000001dH
  01a4d	24		 DB	 36			; 00000024H
  01a4e	24		 DB	 36			; 00000024H
  01a4f	24		 DB	 36			; 00000024H
  01a50	1e		 DB	 30			; 0000001eH
  01a51	24		 DB	 36			; 00000024H
  01a52	24		 DB	 36			; 00000024H
  01a53	24		 DB	 36			; 00000024H
  01a54	1f		 DB	 31			; 0000001fH
  01a55	24		 DB	 36			; 00000024H
  01a56	24		 DB	 36			; 00000024H
  01a57	24		 DB	 36			; 00000024H
  01a58	20		 DB	 32			; 00000020H
  01a59	24		 DB	 36			; 00000024H
  01a5a	24		 DB	 36			; 00000024H
  01a5b	24		 DB	 36			; 00000024H
  01a5c	21		 DB	 33			; 00000021H
  01a5d	24		 DB	 36			; 00000024H
  01a5e	24		 DB	 36			; 00000024H
  01a5f	24		 DB	 36			; 00000024H
  01a60	22		 DB	 34			; 00000022H
  01a61	24		 DB	 36			; 00000024H
  01a62	24		 DB	 36			; 00000024H
  01a63	24		 DB	 36			; 00000024H
  01a64	23		 DB	 35			; 00000023H
  01a65	8d 49 00	 npad	 3
$LN180@ProcessMai:
  01a68	00 00 00 00	 DD	 $LN2@ProcessMai
  01a6c	00 00 00 00	 DD	 $LN1@ProcessMai
$LN178@ProcessMai:
  01a70	00		 DB	 0
  01a71	01		 DB	 1
  01a72	01		 DB	 1
  01a73	01		 DB	 1
  01a74	01		 DB	 1
  01a75	01		 DB	 1
  01a76	01		 DB	 1
  01a77	01		 DB	 1
  01a78	01		 DB	 1
  01a79	01		 DB	 1
  01a7a	01		 DB	 1
  01a7b	01		 DB	 1
  01a7c	01		 DB	 1
  01a7d	01		 DB	 1
  01a7e	01		 DB	 1
  01a7f	01		 DB	 1
  01a80	01		 DB	 1
  01a81	01		 DB	 1
  01a82	01		 DB	 1
  01a83	01		 DB	 1
  01a84	00		 DB	 0
  01a85	01		 DB	 1
  01a86	01		 DB	 1
  01a87	01		 DB	 1
  01a88	01		 DB	 1
  01a89	01		 DB	 1
  01a8a	01		 DB	 1
  01a8b	01		 DB	 1
  01a8c	00		 DB	 0
  01a8d	01		 DB	 1
  01a8e	01		 DB	 1
  01a8f	01		 DB	 1
  01a90	00		 DB	 0
  01a91	01		 DB	 1
  01a92	01		 DB	 1
  01a93	01		 DB	 1
  01a94	01		 DB	 1
  01a95	01		 DB	 1
  01a96	01		 DB	 1
  01a97	01		 DB	 1
  01a98	01		 DB	 1
  01a99	01		 DB	 1
  01a9a	01		 DB	 1
  01a9b	01		 DB	 1
  01a9c	00		 DB	 0
  01a9d	01		 DB	 1
  01a9e	01		 DB	 1
  01a9f	01		 DB	 1
  01aa0	00		 DB	 0
  01aa1	01		 DB	 1
  01aa2	01		 DB	 1
  01aa3	01		 DB	 1
  01aa4	01		 DB	 1
  01aa5	01		 DB	 1
  01aa6	01		 DB	 1
  01aa7	01		 DB	 1
  01aa8	01		 DB	 1
  01aa9	01		 DB	 1
  01aaa	01		 DB	 1
  01aab	01		 DB	 1
  01aac	01		 DB	 1
  01aad	01		 DB	 1
  01aae	01		 DB	 1
  01aaf	01		 DB	 1
  01ab0	00		 DB	 0
  01ab1	01		 DB	 1
  01ab2	01		 DB	 1
  01ab3	01		 DB	 1
  01ab4	01		 DB	 1
  01ab5	01		 DB	 1
  01ab6	01		 DB	 1
  01ab7	01		 DB	 1
  01ab8	01		 DB	 1
  01ab9	01		 DB	 1
  01aba	01		 DB	 1
  01abb	01		 DB	 1
  01abc	00		 DB	 0
  01abd	01		 DB	 1
  01abe	01		 DB	 1
  01abf	01		 DB	 1
  01ac0	00		 DB	 0
  01ac1	01		 DB	 1
  01ac2	01		 DB	 1
  01ac3	01		 DB	 1
  01ac4	00		 DB	 0
_ProcessMainDeviceControlIrp@12 ENDP
; Function compile flags: /Odtp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT _RtlSecureZeroMemory@8
_TEXT	SEGMENT
_vptr$ = -4						; size = 4
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory@8 PROC				; COMDAT

; 8322 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 8323 :     volatile char *vptr = (volatile char *)ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _vptr$[ebp], eax
$LN2@RtlSecureZ:

; 8324 : 
; 8325 : #if defined(_M_AMD64)
; 8326 : 
; 8327 :         __stosb((PUCHAR)((ULONG64)vptr), 0, cnt);
; 8328 : 
; 8329 : #else
; 8330 : 
; 8331 :     while (cnt) {

  0000c	83 7d 0c 00	 cmp	 DWORD PTR _cnt$[ebp], 0
  00010	74 1a		 je	 SHORT $LN1@RtlSecureZ

; 8332 :         *vptr = 0;

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _vptr$[ebp]
  00015	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 8333 :         vptr++;

  00018	8b 55 fc	 mov	 edx, DWORD PTR _vptr$[ebp]
  0001b	83 c2 01	 add	 edx, 1
  0001e	89 55 fc	 mov	 DWORD PTR _vptr$[ebp], edx

; 8334 :         cnt--;

  00021	8b 45 0c	 mov	 eax, DWORD PTR _cnt$[ebp]
  00024	83 e8 01	 sub	 eax, 1
  00027	89 45 0c	 mov	 DWORD PTR _cnt$[ebp], eax

; 8335 :     }

  0002a	eb e0		 jmp	 SHORT $LN2@RtlSecureZ
$LN1@RtlSecureZ:

; 8336 : 
; 8337 : #endif
; 8338 : 
; 8339 :     return ptr;

  0002c	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]

; 8340 : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
_RtlSecureZeroMemory@8 ENDP
_TEXT	ENDS
PUBLIC	_TCStartThreadInProcess@16
PUBLIC	_TCStartThread@12
; Function compile flags: /Odtp
; File c:\users\public\desktop\projects\ciphershed\src\driver\ntdriver.c
;	COMDAT _TCStartThread@12
_TEXT	SEGMENT
_threadProc$ = 8					; size = 4
_threadArg$ = 12					; size = 4
_kThread$ = 16						; size = 4
_TCStartThread@12 PROC					; COMDAT

; 1588 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1589 : 	return TCStartThreadInProcess (threadProc, threadArg, kThread, NULL);

  00005	6a 00		 push	 0
  00007	8b 45 10	 mov	 eax, DWORD PTR _kThread$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR _threadArg$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 08	 mov	 edx, DWORD PTR _threadProc$[ebp]
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 _TCStartThreadInProcess@16

; 1590 : }

  00018	5d		 pop	 ebp
  00019	c2 0c 00	 ret	 12			; 0000000cH
_TCStartThread@12 ENDP
_TEXT	ENDS
EXTRN	__imp__ObReferenceObjectByHandle@24:PROC
EXTRN	__imp__PsCreateSystemThread@28:PROC
EXTRN	__imp__ObOpenObjectByPointer@28:PROC
; Function compile flags: /Odtp
;	COMDAT _TCStartThreadInProcess@16
_TEXT	SEGMENT
_status$ = -36						; size = 4
_threadHandle$ = -32					; size = 4
_processHandle$ = -28					; size = 4
_threadObjAttributes$ = -24				; size = 24
_threadProc$ = 8					; size = 4
_threadArg$ = 12					; size = 4
_kThread$ = 16						; size = 4
_process$ = 20						; size = 4
_TCStartThreadInProcess@16 PROC				; COMDAT

; 1594 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 24	 sub	 esp, 36			; 00000024H

; 1595 : 	NTSTATUS status;
; 1596 : 	HANDLE threadHandle;
; 1597 : 	HANDLE processHandle = NULL;

  00008	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _processHandle$[ebp], 0

; 1598 : 	OBJECT_ATTRIBUTES threadObjAttributes;
; 1599 : 
; 1600 : 	if (process)

  0000f	83 7d 14 00	 cmp	 DWORD PTR _process$[ebp], 0
  00013	74 2c		 je	 SHORT $LN5@TCStartThr

; 1601 : 	{
; 1602 : 		status = ObOpenObjectByPointer (process, OBJ_KERNEL_HANDLE, NULL, 0, NULL, KernelMode, &processHandle);

  00015	8d 45 e4	 lea	 eax, DWORD PTR _processHandle$[ebp]
  00018	50		 push	 eax
  00019	6a 00		 push	 0
  0001b	6a 00		 push	 0
  0001d	6a 00		 push	 0
  0001f	6a 00		 push	 0
  00021	68 00 02 00 00	 push	 512			; 00000200H
  00026	8b 4d 14	 mov	 ecx, DWORD PTR _process$[ebp]
  00029	51		 push	 ecx
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ObOpenObjectByPointer@28
  00030	89 45 dc	 mov	 DWORD PTR _status$[ebp], eax

; 1603 : 		if (!NT_SUCCESS (status))

  00033	83 7d dc 00	 cmp	 DWORD PTR _status$[ebp], 0
  00037	7d 08		 jge	 SHORT $LN5@TCStartThr

; 1604 : 			return status;

  00039	8b 45 dc	 mov	 eax, DWORD PTR _status$[ebp]
  0003c	e9 af 00 00 00	 jmp	 $LN6@TCStartThr
$LN5@TCStartThr:

; 1605 : 	}
; 1606 : 
; 1607 : 	InitializeObjectAttributes (&threadObjAttributes, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);

  00041	c7 45 e8 18 00
	00 00		 mov	 DWORD PTR _threadObjAttributes$[ebp], 24 ; 00000018H
  00048	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _threadObjAttributes$[ebp+4], 0
  0004f	c7 45 f4 00 02
	00 00		 mov	 DWORD PTR _threadObjAttributes$[ebp+12], 512 ; 00000200H
  00056	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _threadObjAttributes$[ebp+8], 0
  0005d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _threadObjAttributes$[ebp+16], 0
  00064	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _threadObjAttributes$[ebp+20], 0

; 1608 : 	
; 1609 : 	status = PsCreateSystemThread (&threadHandle, THREAD_ALL_ACCESS, &threadObjAttributes, processHandle, NULL, threadProc, threadArg);

  0006b	8b 55 0c	 mov	 edx, DWORD PTR _threadArg$[ebp]
  0006e	52		 push	 edx
  0006f	8b 45 08	 mov	 eax, DWORD PTR _threadProc$[ebp]
  00072	50		 push	 eax
  00073	6a 00		 push	 0
  00075	8b 4d e4	 mov	 ecx, DWORD PTR _processHandle$[ebp]
  00078	51		 push	 ecx
  00079	8d 55 e8	 lea	 edx, DWORD PTR _threadObjAttributes$[ebp]
  0007c	52		 push	 edx
  0007d	68 ff 03 1f 00	 push	 2032639			; 001f03ffH
  00082	8d 45 e0	 lea	 eax, DWORD PTR _threadHandle$[ebp]
  00085	50		 push	 eax
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsCreateSystemThread@28
  0008c	89 45 dc	 mov	 DWORD PTR _status$[ebp], eax

; 1610 : 	if (!NT_SUCCESS (status))

  0008f	83 7d dc 00	 cmp	 DWORD PTR _status$[ebp], 0
  00093	7d 05		 jge	 SHORT $LN3@TCStartThr

; 1611 : 		return status;

  00095	8b 45 dc	 mov	 eax, DWORD PTR _status$[ebp]
  00098	eb 56		 jmp	 SHORT $LN6@TCStartThr
$LN3@TCStartThr:

; 1612 : 
; 1613 : 	status = ObReferenceObjectByHandle (threadHandle, THREAD_ALL_ACCESS, NULL, KernelMode, (PVOID *) kThread, NULL);

  0009a	6a 00		 push	 0
  0009c	8b 4d 10	 mov	 ecx, DWORD PTR _kThread$[ebp]
  0009f	51		 push	 ecx
  000a0	6a 00		 push	 0
  000a2	6a 00		 push	 0
  000a4	68 ff 03 1f 00	 push	 2032639			; 001f03ffH
  000a9	8b 55 e0	 mov	 edx, DWORD PTR _threadHandle$[ebp]
  000ac	52		 push	 edx
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ObReferenceObjectByHandle@24
  000b3	89 45 dc	 mov	 DWORD PTR _status$[ebp], eax

; 1614 : 	if (!NT_SUCCESS (status))

  000b6	83 7d dc 00	 cmp	 DWORD PTR _status$[ebp], 0
  000ba	7d 18		 jge	 SHORT $LN2@TCStartThr

; 1615 : 	{
; 1616 : 		ZwClose (threadHandle);

  000bc	8b 45 e0	 mov	 eax, DWORD PTR _threadHandle$[ebp]
  000bf	50		 push	 eax
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 1617 : 		*kThread = NULL;

  000c6	8b 4d 10	 mov	 ecx, DWORD PTR _kThread$[ebp]
  000c9	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1618 : 		return status;

  000cf	8b 45 dc	 mov	 eax, DWORD PTR _status$[ebp]
  000d2	eb 1c		 jmp	 SHORT $LN6@TCStartThr
$LN2@TCStartThr:

; 1619 : 	}
; 1620 : 
; 1621 : 	if (processHandle)

  000d4	83 7d e4 00	 cmp	 DWORD PTR _processHandle$[ebp], 0
  000d8	74 0a		 je	 SHORT $LN1@TCStartThr

; 1622 : 		ZwClose (processHandle);

  000da	8b 55 e4	 mov	 edx, DWORD PTR _processHandle$[ebp]
  000dd	52		 push	 edx
  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4
$LN1@TCStartThr:

; 1623 : 
; 1624 : 	ZwClose (threadHandle);

  000e4	8b 45 e0	 mov	 eax, DWORD PTR _threadHandle$[ebp]
  000e7	50		 push	 eax
  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 1625 : 	return STATUS_SUCCESS;

  000ee	33 c0		 xor	 eax, eax
$LN6@TCStartThr:

; 1626 : }

  000f0	8b e5		 mov	 esp, ebp
  000f2	5d		 pop	 ebp
  000f3	c2 10 00	 ret	 16			; 00000010H
_TCStartThreadInProcess@16 ENDP
_TEXT	ENDS
PUBLIC	_TCStopThread@8
EXTRN	__imp__KeSetEvent@12:PROC
; Function compile flags: /Odtp
;	COMDAT _TCStopThread@8
_TEXT	SEGMENT
_kThread$ = 8						; size = 4
_wakeUpEvent$ = 12					; size = 4
_TCStopThread@8 PROC					; COMDAT

; 1630 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1631 : 	if (wakeUpEvent)

  00005	83 7d 0c 00	 cmp	 DWORD PTR _wakeUpEvent$[ebp], 0
  00009	74 0e		 je	 SHORT $LN1@TCStopThre

; 1632 : 		KeSetEvent (wakeUpEvent, 0, FALSE);

  0000b	6a 00		 push	 0
  0000d	6a 00		 push	 0
  0000f	8b 45 0c	 mov	 eax, DWORD PTR _wakeUpEvent$[ebp]
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
$LN1@TCStopThre:

; 1633 : 
; 1634 : 	KeWaitForSingleObject (kThread, Executive, KernelMode, FALSE, NULL);

  00019	6a 00		 push	 0
  0001b	6a 00		 push	 0
  0001d	6a 00		 push	 0
  0001f	6a 00		 push	 0
  00021	8b 4d 08	 mov	 ecx, DWORD PTR _kThread$[ebp]
  00024	51		 push	 ecx
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 1635 : 	ObDereferenceObject (kThread);

  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _kThread$[ebp]
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 1636 : }

  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
_TCStopThread@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@KIOPBGEO@Waiting?5completed?$CB?5Thread?5return@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CF@DMBFEFC@Waiting?5for?5thread?5to?5initialize@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CB@DGOAIPAC@PsCreateSystemThread?5Failed?5END?6@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_VolumeThreadProc@4
PUBLIC	_PsGetCurrentThread@0
PUBLIC	??_C@_0BE@DCPHDOHD@Starting?5thread?4?4?4?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_TCStartVolumeThread@12
EXTRN	__imp__SeCreateClientSecurity@16:PROC
;	COMDAT ??_C@_0CK@KIOPBGEO@Waiting?5completed?$CB?5Thread?5return@FNODOBFM@
text$s	SEGMENT
??_C@_0CK@KIOPBGEO@Waiting?5completed?$CB?5Thread?5return@FNODOBFM@ DB 'W'
	DB	'aiting completed! Thread returns 0x%08x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CF@DMBFEFC@Waiting?5for?5thread?5to?5initialize@FNODOBFM@
text$s	SEGMENT
??_C@_0CF@DMBFEFC@Waiting?5for?5thread?5to?5initialize@FNODOBFM@ DB 'Wait'
	DB	'ing for thread to initialize...', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CB@DGOAIPAC@PsCreateSystemThread?5Failed?5END?6@FNODOBFM@
text$s	SEGMENT
??_C@_0CB@DGOAIPAC@PsCreateSystemThread?5Failed?5END?6@FNODOBFM@ DB 'PsCr'
	DB	'eateSystemThread Failed END', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BE@DCPHDOHD@Starting?5thread?4?4?4?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BE@DCPHDOHD@Starting?5thread?4?4?4?6?$AA@FNODOBFM@ DB 'Starting th'
	DB	'read...', 0aH, 00H				;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _TCStartVolumeThread@12
_TEXT	SEGMENT
_hThread$ = -48						; size = 4
_ntStatus$ = -44					; size = 4
_qos$ = -40						; size = 12
_pThreadBlock$ = -28					; size = 4
_threadObjAttributes$ = -24				; size = 24
_DeviceObject$ = 8					; size = 4
_Extension$ = 12					; size = 4
_mount$ = 16						; size = 4
_TCStartVolumeThread@12 PROC				; COMDAT

; 1640 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 30	 sub	 esp, 48			; 00000030H

; 1641 : 	PTHREAD_BLOCK pThreadBlock = TCalloc (sizeof (THREAD_BLOCK));

  00008	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0000d	68 24 02 00 00	 push	 548			; 00000224H
  00012	6a 00		 push	 0
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0001a	89 45 e4	 mov	 DWORD PTR _pThreadBlock$[ebp], eax

; 1642 : 	HANDLE hThread;
; 1643 : 	NTSTATUS ntStatus;
; 1644 : 	OBJECT_ATTRIBUTES threadObjAttributes;
; 1645 : 	SECURITY_QUALITY_OF_SERVICE qos;
; 1646 : 
; 1647 : 	Dump ("Starting thread...\n");

  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@DCPHDOHD@Starting?5thread?4?4?4?6?$AA@FNODOBFM@
  00022	e8 00 00 00 00	 call	 _DbgPrint
  00027	83 c4 04	 add	 esp, 4

; 1648 : 
; 1649 : 	if (pThreadBlock == NULL)

  0002a	83 7d e4 00	 cmp	 DWORD PTR _pThreadBlock$[ebp], 0
  0002e	75 0c		 jne	 SHORT $LN5@TCStartVol

; 1650 : 	{
; 1651 : 		return STATUS_INSUFFICIENT_RESOURCES;

  00030	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  00035	e9 51 01 00 00	 jmp	 $LN6@TCStartVol

; 1652 : 	}
; 1653 : 	else

  0003a	eb 14		 jmp	 SHORT $LN4@TCStartVol
$LN5@TCStartVol:

; 1654 : 	{
; 1655 : 		pThreadBlock->DeviceObject = DeviceObject;

  0003c	8b 45 e4	 mov	 eax, DWORD PTR _pThreadBlock$[ebp]
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  00042	89 08		 mov	 DWORD PTR [eax], ecx

; 1656 : 		pThreadBlock->mount = mount;

  00044	8b 55 e4	 mov	 edx, DWORD PTR _pThreadBlock$[ebp]
  00047	8b 45 10	 mov	 eax, DWORD PTR _mount$[ebp]
  0004a	89 82 20 02 00
	00		 mov	 DWORD PTR [edx+544], eax
$LN4@TCStartVol:

; 1657 : 	}
; 1658 : 
; 1659 : 	qos.Length = sizeof (qos);

  00050	c7 45 d8 0c 00
	00 00		 mov	 DWORD PTR _qos$[ebp], 12 ; 0000000cH

; 1660 : 	qos.ContextTrackingMode = SECURITY_STATIC_TRACKING;

  00057	c6 45 e0 00	 mov	 BYTE PTR _qos$[ebp+8], 0

; 1661 : 	qos.EffectiveOnly = TRUE;

  0005b	c6 45 e1 01	 mov	 BYTE PTR _qos$[ebp+9], 1

; 1662 : 	qos.ImpersonationLevel = SecurityImpersonation;

  0005f	c7 45 dc 02 00
	00 00		 mov	 DWORD PTR _qos$[ebp+4], 2

; 1663 : 
; 1664 : 	ntStatus = SeCreateClientSecurity (PsGetCurrentThread(), &qos, FALSE, &Extension->SecurityClientContext);

  00066	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00069	81 c1 d4 04 00
	00		 add	 ecx, 1236		; 000004d4H
  0006f	51		 push	 ecx
  00070	6a 00		 push	 0
  00072	8d 55 d8	 lea	 edx, DWORD PTR _qos$[ebp]
  00075	52		 push	 edx
  00076	e8 00 00 00 00	 call	 _PsGetCurrentThread@0
  0007b	50		 push	 eax
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeCreateClientSecurity@16
  00082	89 45 d4	 mov	 DWORD PTR _ntStatus$[ebp], eax

; 1665 : 	if (!NT_SUCCESS (ntStatus))

  00085	83 7d d4 00	 cmp	 DWORD PTR _ntStatus$[ebp], 0
  00089	7d 05		 jge	 SHORT $LN3@TCStartVol

; 1666 : 		goto ret;

  0008b	e9 e9 00 00 00	 jmp	 $ret$30570
$LN3@TCStartVol:

; 1667 : 
; 1668 : 	Extension->SecurityClientContextValid = TRUE;

  00090	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  00093	c7 80 d0 04 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+1232], 1

; 1669 : 
; 1670 : 	Extension->bThreadShouldQuit = FALSE;

  0009d	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  000a0	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 1671 : 
; 1672 : 	InitializeObjectAttributes (&threadObjAttributes, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);

  000a7	c7 45 e8 18 00
	00 00		 mov	 DWORD PTR _threadObjAttributes$[ebp], 24 ; 00000018H
  000ae	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _threadObjAttributes$[ebp+4], 0
  000b5	c7 45 f4 00 02
	00 00		 mov	 DWORD PTR _threadObjAttributes$[ebp+12], 512 ; 00000200H
  000bc	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _threadObjAttributes$[ebp+8], 0
  000c3	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _threadObjAttributes$[ebp+16], 0
  000ca	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _threadObjAttributes$[ebp+20], 0

; 1673 : 
; 1674 : 	ntStatus = PsCreateSystemThread (&hThread,
; 1675 : 					 THREAD_ALL_ACCESS,
; 1676 : 					 &threadObjAttributes,
; 1677 : 					 NULL,
; 1678 : 					 NULL,
; 1679 : 					 VolumeThreadProc,
; 1680 : 					 pThreadBlock);

  000d1	8b 55 e4	 mov	 edx, DWORD PTR _pThreadBlock$[ebp]
  000d4	52		 push	 edx
  000d5	68 00 00 00 00	 push	 OFFSET _VolumeThreadProc@4
  000da	6a 00		 push	 0
  000dc	6a 00		 push	 0
  000de	8d 45 e8	 lea	 eax, DWORD PTR _threadObjAttributes$[ebp]
  000e1	50		 push	 eax
  000e2	68 ff 03 1f 00	 push	 2032639			; 001f03ffH
  000e7	8d 4d d0	 lea	 ecx, DWORD PTR _hThread$[ebp]
  000ea	51		 push	 ecx
  000eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsCreateSystemThread@28
  000f1	89 45 d4	 mov	 DWORD PTR _ntStatus$[ebp], eax

; 1681 : 
; 1682 : 	if (!NT_SUCCESS (ntStatus))

  000f4	83 7d d4 00	 cmp	 DWORD PTR _ntStatus$[ebp], 0
  000f8	7d 0f		 jge	 SHORT $LN2@TCStartVol

; 1683 : 	{
; 1684 : 		Dump ("PsCreateSystemThread Failed END\n");

  000fa	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@DGOAIPAC@PsCreateSystemThread?5Failed?5END?6@FNODOBFM@
  000ff	e8 00 00 00 00	 call	 _DbgPrint
  00104	83 c4 04	 add	 esp, 4

; 1685 : 		goto ret;

  00107	eb 70		 jmp	 SHORT $ret$30570
$LN2@TCStartVol:

; 1686 : 	}
; 1687 : 
; 1688 : 	ntStatus = ObReferenceObjectByHandle (hThread,
; 1689 : 				   THREAD_ALL_ACCESS,
; 1690 : 				   NULL,
; 1691 : 				   KernelMode,
; 1692 : 				   &Extension->peThread,
; 1693 : 				   NULL);

  00109	6a 00		 push	 0
  0010b	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  0010e	83 c2 20	 add	 edx, 32			; 00000020H
  00111	52		 push	 edx
  00112	6a 00		 push	 0
  00114	6a 00		 push	 0
  00116	68 ff 03 1f 00	 push	 2032639			; 001f03ffH
  0011b	8b 45 d0	 mov	 eax, DWORD PTR _hThread$[ebp]
  0011e	50		 push	 eax
  0011f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ObReferenceObjectByHandle@24
  00125	89 45 d4	 mov	 DWORD PTR _ntStatus$[ebp], eax

; 1694 : 
; 1695 : 	ZwClose (hThread);

  00128	8b 4d d0	 mov	 ecx, DWORD PTR _hThread$[ebp]
  0012b	51		 push	 ecx
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 1696 : 
; 1697 : 	if (!NT_SUCCESS (ntStatus))

  00132	83 7d d4 00	 cmp	 DWORD PTR _ntStatus$[ebp], 0
  00136	7d 02		 jge	 SHORT $LN1@TCStartVol

; 1698 : 		goto ret;

  00138	eb 3f		 jmp	 SHORT $ret$30570
$LN1@TCStartVol:

; 1699 : 
; 1700 : 	Dump ("Waiting for thread to initialize...\n");

  0013a	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@DMBFEFC@Waiting?5for?5thread?5to?5initialize@FNODOBFM@
  0013f	e8 00 00 00 00	 call	 _DbgPrint
  00144	83 c4 04	 add	 esp, 4

; 1701 : 
; 1702 : 	KeWaitForSingleObject (&Extension->keCreateEvent,
; 1703 : 			       Executive,
; 1704 : 			       KernelMode,
; 1705 : 			       FALSE,
; 1706 : 			       NULL);

  00147	6a 00		 push	 0
  00149	6a 00		 push	 0
  0014b	6a 00		 push	 0
  0014d	6a 00		 push	 0
  0014f	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  00152	83 c2 24	 add	 edx, 36			; 00000024H
  00155	52		 push	 edx
  00156	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 1707 : 
; 1708 : 	Dump ("Waiting completed! Thread returns 0x%08x\n", pThreadBlock->ntCreateStatus);

  0015c	8b 45 e4	 mov	 eax, DWORD PTR _pThreadBlock$[ebp]
  0015f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00162	51		 push	 ecx
  00163	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@KIOPBGEO@Waiting?5completed?$CB?5Thread?5return@FNODOBFM@
  00168	e8 00 00 00 00	 call	 _DbgPrint
  0016d	83 c4 08	 add	 esp, 8

; 1709 : 	ntStatus = pThreadBlock->ntCreateStatus;

  00170	8b 55 e4	 mov	 edx, DWORD PTR _pThreadBlock$[ebp]
  00173	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00176	89 45 d4	 mov	 DWORD PTR _ntStatus$[ebp], eax
$ret$30570:

; 1710 : 
; 1711 : ret:
; 1712 : 	TCfree (pThreadBlock);

  00179	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0017e	8b 4d e4	 mov	 ecx, DWORD PTR _pThreadBlock$[ebp]
  00181	51		 push	 ecx
  00182	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 1713 : 	return ntStatus;

  00188	8b 45 d4	 mov	 eax, DWORD PTR _ntStatus$[ebp]
$LN6@TCStartVol:

; 1714 : }

  0018b	8b e5		 mov	 esp, ebp
  0018d	5d		 pop	 ebp
  0018e	c2 0c 00	 ret	 12			; 0000000cH
_TCStartVolumeThread@12 ENDP
_TEXT	ENDS
EXTRN	__imp__KeGetCurrentThread@0:PROC
; Function compile flags: /Odtp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
;	COMDAT _PsGetCurrentThread@0
_TEXT	SEGMENT
_PsGetCurrentThread@0 PROC				; COMDAT

; 19988: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 19989: 
; 19990:     return (PETHREAD)KeGetCurrentThread();

  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeGetCurrentThread@0

; 19991: }

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
_PsGetCurrentThread@0 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@OPFPPFJJ@Thread?5exited?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BG@MEOILBFO@NT_SUCCESS?5?$CIntStatus?$CJ?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BO@IDJGLOL@Signalling?5thread?5to?5quit?4?4?4?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_TCStopVolumeThread@8
;	COMDAT ??_C@_0P@OPFPPFJJ@Thread?5exited?6?$AA@FNODOBFM@
; File c:\users\public\desktop\projects\ciphershed\src\driver\ntdriver.c
text$s	SEGMENT
??_C@_0P@OPFPPFJJ@Thread?5exited?6?$AA@FNODOBFM@ DB 'Thread exited', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BG@MEOILBFO@NT_SUCCESS?5?$CIntStatus?$CJ?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BG@MEOILBFO@NT_SUCCESS?5?$CIntStatus?$CJ?$AA@FNODOBFM@ DB 'NT_SUCC'
	DB	'ESS (ntStatus)', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BO@IDJGLOL@Signalling?5thread?5to?5quit?4?4?4?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BO@IDJGLOL@Signalling?5thread?5to?5quit?4?4?4?6?$AA@FNODOBFM@ DB 'S'
	DB	'ignalling thread to quit...', 0aH, 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _TCStopVolumeThread@8
_TEXT	SEGMENT
tv84 = -8						; size = 4
_ntStatus$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_Extension$ = 12					; size = 4
_TCStopVolumeThread@8 PROC				; COMDAT

; 1717 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 1718 : 	NTSTATUS ntStatus;
; 1719 : 
; 1720 : 	if (DeviceObject);	/* Remove compiler warning */
; 1721 : 
; 1722 : 	Dump ("Signalling thread to quit...\n");

  00008	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@IDJGLOL@Signalling?5thread?5to?5quit?4?4?4?6?$AA@FNODOBFM@
  0000d	e8 00 00 00 00	 call	 _DbgPrint
  00012	83 c4 04	 add	 esp, 4

; 1723 : 
; 1724 : 	Extension->bThreadShouldQuit = TRUE;

  00015	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  00018	c7 40 1c 01 00
	00 00		 mov	 DWORD PTR [eax+28], 1

; 1725 : 
; 1726 : 	KeReleaseSemaphore (&Extension->RequestSemaphore,
; 1727 : 			    0,
; 1728 : 			    1,
; 1729 : 			    TRUE);

  0001f	6a 01		 push	 1
  00021	6a 01		 push	 1
  00023	6a 00		 push	 0
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00028	83 c1 40	 add	 ecx, 64			; 00000040H
  0002b	51		 push	 ecx
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeReleaseSemaphore@16

; 1730 : 
; 1731 : 	ntStatus = KeWaitForSingleObject (Extension->peThread,
; 1732 : 					  Executive,
; 1733 : 					  KernelMode,
; 1734 : 					  FALSE,
; 1735 : 					  NULL);

  00032	6a 00		 push	 0
  00034	6a 00		 push	 0
  00036	6a 00		 push	 0
  00038	6a 00		 push	 0
  0003a	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  0003d	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00040	50		 push	 eax
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
  00047	89 45 fc	 mov	 DWORD PTR _ntStatus$[ebp], eax

; 1736 : 
; 1737 : 	ASSERT (NT_SUCCESS (ntStatus));

  0004a	83 7d fc 00	 cmp	 DWORD PTR _ntStatus$[ebp], 0
  0004e	7d 20		 jge	 SHORT $LN4@TCStopVolu
  00050	6a 00		 push	 0
  00052	68 c9 06 00 00	 push	 1737			; 000006c9H
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@MEOILBFO@NT_SUCCESS?5?$CIntStatus?$CJ?$AA@FNODOBFM@
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  00067	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv84[ebp], 0
  0006e	eb 07		 jmp	 SHORT $LN5@TCStopVolu
$LN4@TCStopVolu:
  00070	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv84[ebp], 1
$LN5@TCStopVolu:

; 1738 : 
; 1739 : 	ObDereferenceObject (Extension->peThread);

  00077	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0007a	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 1740 : 	Extension->peThread = NULL;

  00083	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  00086	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], 0

; 1741 : 
; 1742 : 	Dump ("Thread exited\n");

  0008d	68 00 00 00 00	 push	 OFFSET ??_C@_0P@OPFPPFJJ@Thread?5exited?6?$AA@FNODOBFM@
  00092	e8 00 00 00 00	 call	 _DbgPrint
  00097	83 c4 04	 add	 esp, 4

; 1743 : }

  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c2 08 00	 ret	 8
_TCStopVolumeThread@8 ENDP
_TEXT	ENDS
PUBLIC	_TCSleep@4
EXTRN	__imp__KeSetTimerEx@20:PROC
EXTRN	__imp__KeInitializeTimerEx@8:PROC
EXTRN	__allmul:PROC
; Function compile flags: /Odtp
;	COMDAT _TCSleep@4
_TEXT	SEGMENT
_duetime$ = -16						; size = 8
_timer$ = -4						; size = 4
_milliSeconds$ = 8					; size = 4
_TCSleep@4 PROC						; COMDAT

; 1748 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 10	 sub	 esp, 16			; 00000010H

; 1749 : 	PKTIMER timer = (PKTIMER) TCalloc (sizeof (KTIMER));

  00008	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0000d	6a 28		 push	 40			; 00000028H
  0000f	6a 00		 push	 0
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00017	89 45 fc	 mov	 DWORD PTR _timer$[ebp], eax

; 1750 : 	LARGE_INTEGER duetime;
; 1751 : 
; 1752 : 	if (!timer)

  0001a	83 7d fc 00	 cmp	 DWORD PTR _timer$[ebp], 0
  0001e	75 02		 jne	 SHORT $LN1@TCSleep

; 1753 : 		return;

  00020	eb 5b		 jmp	 SHORT $LN2@TCSleep
$LN1@TCSleep:

; 1754 : 
; 1755 : 	duetime.QuadPart = (__int64) milliSeconds * -10000;

  00022	8b 45 08	 mov	 eax, DWORD PTR _milliSeconds$[ebp]
  00025	99		 cdq
  00026	6a ff		 push	 -1
  00028	68 f0 d8 ff ff	 push	 -10000			; ffffd8f0H
  0002d	52		 push	 edx
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 __allmul
  00034	89 45 f0	 mov	 DWORD PTR _duetime$[ebp], eax
  00037	89 55 f4	 mov	 DWORD PTR _duetime$[ebp+4], edx

; 1756 : 	KeInitializeTimerEx(timer, NotificationTimer);

  0003a	6a 00		 push	 0
  0003c	8b 45 fc	 mov	 eax, DWORD PTR _timer$[ebp]
  0003f	50		 push	 eax
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeTimerEx@8

; 1757 : 	KeSetTimerEx(timer, duetime, 0, NULL);

  00046	6a 00		 push	 0
  00048	6a 00		 push	 0
  0004a	8b 4d f4	 mov	 ecx, DWORD PTR _duetime$[ebp+4]
  0004d	51		 push	 ecx
  0004e	8b 55 f0	 mov	 edx, DWORD PTR _duetime$[ebp]
  00051	52		 push	 edx
  00052	8b 45 fc	 mov	 eax, DWORD PTR _timer$[ebp]
  00055	50		 push	 eax
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetTimerEx@20

; 1758 : 
; 1759 : 	KeWaitForSingleObject (timer, Executive, KernelMode, FALSE, NULL);

  0005c	6a 00		 push	 0
  0005e	6a 00		 push	 0
  00060	6a 00		 push	 0
  00062	6a 00		 push	 0
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _timer$[ebp]
  00067	51		 push	 ecx
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 1760 : 
; 1761 : 	TCfree (timer);

  0006e	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00073	8b 55 fc	 mov	 edx, DWORD PTR _timer$[ebp]
  00076	52		 push	 edx
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN2@TCSleep:

; 1762 : }

  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c2 04 00	 ret	 4
_TCSleep@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@OMKHINCH@Closing?5volume?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CO@PADHEFHE@irpSp?9?$DOMajorFunction?5?$DN?$DN?5IRP_MJ_D@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DO@GJJNBBEG@Mount?5THREAD?5request?5for?5File?5?$CFl@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_19JHEHLFPM@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BA@CCLAPIHO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CD@LOGBEHKH@Mount?5THREAD?5OPENING?5VOLUME?5BEGI@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	_EncryptedIoQueueStop@4:PROC
EXTRN	__imp__IoReleaseRemoveLockEx@12:PROC
EXTRN	__imp_@ExfInterlockedRemoveHeadList@8:PROC
EXTRN	_TCCloseVolume@8:PROC
EXTRN	_EncryptedIoQueueStart@4:PROC
EXTRN	__imp__PsTerminateSystemThread@4:PROC
EXTRN	_TCOpenVolume@20:PROC
EXTRN	__imp__wcsncat:PROC
EXTRN	__imp__KeSetPriorityThread@8:PROC
;	COMDAT ??_C@_0BA@OMKHINCH@Closing?5volume?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BA@OMKHINCH@Closing?5volume?6?$AA@FNODOBFM@ DB 'Closing volume', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CO@PADHEFHE@irpSp?9?$DOMajorFunction?5?$DN?$DN?5IRP_MJ_D@FNODOBFM@
text$s	SEGMENT
??_C@_0CO@PADHEFHE@irpSp?9?$DOMajorFunction?5?$DN?$DN?5IRP_MJ_D@FNODOBFM@ DB 'i'
	DB	'rpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DO@GJJNBBEG@Mount?5THREAD?5request?5for?5File?5?$CFl@FNODOBFM@
text$s	SEGMENT
??_C@_0DO@GJJNBBEG@Mount?5THREAD?5request?5for?5File?5?$CFl@FNODOBFM@ DB 'M'
	DB	'ount THREAD request for File %ls DriveNumber %d Device = %d', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_19JHEHLFPM@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_19JHEHLFPM@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$AA@FNODOBFM@ DB '\', 00H
	DB	'?', 00H, '?', 00H, '\', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BA@CCLAPIHO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BA@CCLAPIHO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CD@LOGBEHKH@Mount?5THREAD?5OPENING?5VOLUME?5BEGI@FNODOBFM@
text$s	SEGMENT
??_C@_0CD@LOGBEHKH@Mount?5THREAD?5OPENING?5VOLUME?5BEGI@FNODOBFM@ DB 'Mou'
	DB	'nt THREAD OPENING VOLUME BEGIN', 0aH, 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _VolumeThreadProc@4
_TEXT	SEGMENT
tv213 = -48						; size = 4
tv82 = -42						; size = 2
tv81 = -40						; size = 4
tv80 = -36						; size = 4
tv78 = -32						; size = 4
_irpSp$30650 = -28					; size = 4
_request$30651 = -24					; size = 4
_irp$30652 = -20					; size = 4
_DeviceObject$ = -16					; size = 4
_pThreadBlock$ = -12					; size = 4
_Extension$ = -8					; size = 4
_bDevice$ = -4						; size = 4
_Context$ = 8						; size = 4
_VolumeThreadProc@4 PROC				; COMDAT

; 1768 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 30	 sub	 esp, 48			; 00000030H
  00008	56		 push	 esi
  00009	57		 push	 edi

; 1769 : 	PTHREAD_BLOCK pThreadBlock = (PTHREAD_BLOCK) Context;

  0000a	8b 45 08	 mov	 eax, DWORD PTR _Context$[ebp]
  0000d	89 45 f4	 mov	 DWORD PTR _pThreadBlock$[ebp], eax

; 1770 : 	PDEVICE_OBJECT DeviceObject = pThreadBlock->DeviceObject;

  00010	8b 4d f4	 mov	 ecx, DWORD PTR _pThreadBlock$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	89 55 f0	 mov	 DWORD PTR _DeviceObject$[ebp], edx

; 1771 : 	PEXTENSION Extension = (PEXTENSION) DeviceObject->DeviceExtension;

  00018	8b 45 f0	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  0001b	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0001e	89 4d f8	 mov	 DWORD PTR _Extension$[ebp], ecx

; 1772 : 	BOOL bDevice;
; 1773 : 
; 1774 : 	/* Set thread priority to lowest realtime level. */
; 1775 : 	KeSetPriorityThread (KeGetCurrentThread (), LOW_REALTIME_PRIORITY);

  00021	6a 10		 push	 16			; 00000010H
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeGetCurrentThread@0
  00029	50		 push	 eax
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetPriorityThread@8

; 1776 : 
; 1777 : 	Dump ("Mount THREAD OPENING VOLUME BEGIN\n");

  00030	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@LOGBEHKH@Mount?5THREAD?5OPENING?5VOLUME?5BEGI@FNODOBFM@
  00035	e8 00 00 00 00	 call	 _DbgPrint
  0003a	83 c4 04	 add	 esp, 4

; 1778 : 
; 1779 : 	if (memcmp (pThreadBlock->mount->wszVolume, WIDE ("\\Device"), 14) != 0)

  0003d	b9 07 00 00 00	 mov	 ecx, 7
  00042	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_1BA@CCLAPIHO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@
  00047	8b 55 f4	 mov	 edx, DWORD PTR _pThreadBlock$[ebp]
  0004a	8b b2 20 02 00
	00		 mov	 esi, DWORD PTR [edx+544]
  00050	83 c6 10	 add	 esi, 16			; 00000010H
  00053	33 c0		 xor	 eax, eax
  00055	66 f3 a7	 repe cmpsw
  00058	74 6e		 je	 SHORT $LN13@VolumeThre

; 1780 : 	{
; 1781 : 		wcscpy (pThreadBlock->wszMountVolume, WIDE ("\\??\\"));

  0005a	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], OFFSET ??_C@_19JHEHLFPM@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$AA@FNODOBFM@
  00061	8b 4d f4	 mov	 ecx, DWORD PTR _pThreadBlock$[ebp]
  00064	83 c1 08	 add	 ecx, 8
  00067	89 4d dc	 mov	 DWORD PTR tv80[ebp], ecx
  0006a	8b 55 dc	 mov	 edx, DWORD PTR tv80[ebp]
  0006d	89 55 d8	 mov	 DWORD PTR tv81[ebp], edx
$LN16@VolumeThre:
  00070	8b 45 e0	 mov	 eax, DWORD PTR tv78[ebp]
  00073	66 8b 08	 mov	 cx, WORD PTR [eax]
  00076	66 89 4d d6	 mov	 WORD PTR tv82[ebp], cx
  0007a	8b 55 dc	 mov	 edx, DWORD PTR tv80[ebp]
  0007d	66 8b 45 d6	 mov	 ax, WORD PTR tv82[ebp]
  00081	66 89 02	 mov	 WORD PTR [edx], ax
  00084	8b 4d e0	 mov	 ecx, DWORD PTR tv78[ebp]
  00087	83 c1 02	 add	 ecx, 2
  0008a	89 4d e0	 mov	 DWORD PTR tv78[ebp], ecx
  0008d	8b 55 dc	 mov	 edx, DWORD PTR tv80[ebp]
  00090	83 c2 02	 add	 edx, 2
  00093	89 55 dc	 mov	 DWORD PTR tv80[ebp], edx
  00096	66 83 7d d6 00	 cmp	 WORD PTR tv82[ebp], 0
  0009b	75 d3		 jne	 SHORT $LN16@VolumeThre

; 1782 : 		wcsncat (pThreadBlock->wszMountVolume, pThreadBlock->mount->wszVolume,
; 1783 : 			sizeof (pThreadBlock->wszMountVolume) / 2 - 5);

  0009d	68 07 01 00 00	 push	 263			; 00000107H
  000a2	8b 45 f4	 mov	 eax, DWORD PTR _pThreadBlock$[ebp]
  000a5	8b 88 20 02 00
	00		 mov	 ecx, DWORD PTR [eax+544]
  000ab	83 c1 10	 add	 ecx, 16			; 00000010H
  000ae	51		 push	 ecx
  000af	8b 55 f4	 mov	 edx, DWORD PTR _pThreadBlock$[ebp]
  000b2	83 c2 08	 add	 edx, 8
  000b5	52		 push	 edx
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcsncat
  000bc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1784 : 		bDevice = FALSE;

  000bf	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _bDevice$[ebp], 0

; 1785 : 	}
; 1786 : 	else

  000c6	eb 32		 jmp	 SHORT $LN12@VolumeThre
$LN13@VolumeThre:

; 1787 : 	{
; 1788 : 		pThreadBlock->wszMountVolume[0] = 0;

  000c8	33 c0		 xor	 eax, eax
  000ca	8b 4d f4	 mov	 ecx, DWORD PTR _pThreadBlock$[ebp]
  000cd	66 89 41 08	 mov	 WORD PTR [ecx+8], ax

; 1789 : 		wcsncat (pThreadBlock->wszMountVolume, pThreadBlock->mount->wszVolume,
; 1790 : 			sizeof (pThreadBlock->wszMountVolume) / 2 - 1);

  000d1	68 0b 01 00 00	 push	 267			; 0000010bH
  000d6	8b 55 f4	 mov	 edx, DWORD PTR _pThreadBlock$[ebp]
  000d9	8b 82 20 02 00
	00		 mov	 eax, DWORD PTR [edx+544]
  000df	83 c0 10	 add	 eax, 16			; 00000010H
  000e2	50		 push	 eax
  000e3	8b 4d f4	 mov	 ecx, DWORD PTR _pThreadBlock$[ebp]
  000e6	83 c1 08	 add	 ecx, 8
  000e9	51		 push	 ecx
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcsncat
  000f0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1791 : 		bDevice = TRUE;

  000f3	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _bDevice$[ebp], 1
$LN12@VolumeThre:

; 1792 : 	}
; 1793 : 
; 1794 : 	Dump ("Mount THREAD request for File %ls DriveNumber %d Device = %d\n",
; 1795 : 	      pThreadBlock->wszMountVolume, pThreadBlock->mount->nDosDriveNo, bDevice);

  000fa	8b 55 fc	 mov	 edx, DWORD PTR _bDevice$[ebp]
  000fd	52		 push	 edx
  000fe	8b 45 f4	 mov	 eax, DWORD PTR _pThreadBlock$[ebp]
  00101	8b 88 20 02 00
	00		 mov	 ecx, DWORD PTR [eax+544]
  00107	8b 91 64 02 00
	00		 mov	 edx, DWORD PTR [ecx+612]
  0010d	52		 push	 edx
  0010e	8b 45 f4	 mov	 eax, DWORD PTR _pThreadBlock$[ebp]
  00111	83 c0 08	 add	 eax, 8
  00114	50		 push	 eax
  00115	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@GJJNBBEG@Mount?5THREAD?5request?5for?5File?5?$CFl@FNODOBFM@
  0011a	e8 00 00 00 00	 call	 _DbgPrint
  0011f	83 c4 10	 add	 esp, 16			; 00000010H

; 1796 : 
; 1797 : 	pThreadBlock->ntCreateStatus = TCOpenVolume (DeviceObject,
; 1798 : 		Extension,
; 1799 : 		pThreadBlock->mount,
; 1800 : 		pThreadBlock->wszMountVolume,
; 1801 : 		bDevice);

  00122	8b 4d fc	 mov	 ecx, DWORD PTR _bDevice$[ebp]
  00125	51		 push	 ecx
  00126	8b 55 f4	 mov	 edx, DWORD PTR _pThreadBlock$[ebp]
  00129	83 c2 08	 add	 edx, 8
  0012c	52		 push	 edx
  0012d	8b 45 f4	 mov	 eax, DWORD PTR _pThreadBlock$[ebp]
  00130	8b 88 20 02 00
	00		 mov	 ecx, DWORD PTR [eax+544]
  00136	51		 push	 ecx
  00137	8b 55 f8	 mov	 edx, DWORD PTR _Extension$[ebp]
  0013a	52		 push	 edx
  0013b	8b 45 f0	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  0013e	50		 push	 eax
  0013f	e8 00 00 00 00	 call	 _TCOpenVolume@20
  00144	8b 4d f4	 mov	 ecx, DWORD PTR _pThreadBlock$[ebp]
  00147	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1802 : 
; 1803 : 	if (!NT_SUCCESS (pThreadBlock->ntCreateStatus) || pThreadBlock->mount->nReturnCode != 0)

  0014a	8b 55 f4	 mov	 edx, DWORD PTR _pThreadBlock$[ebp]
  0014d	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00151	7c 0e		 jl	 SHORT $LN10@VolumeThre
  00153	8b 45 f4	 mov	 eax, DWORD PTR _pThreadBlock$[ebp]
  00156	8b 88 20 02 00
	00		 mov	 ecx, DWORD PTR [eax+544]
  0015c	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0015f	74 19		 je	 SHORT $LN11@VolumeThre
$LN10@VolumeThre:

; 1804 : 	{
; 1805 : 		KeSetEvent (&Extension->keCreateEvent, 0, FALSE);

  00161	6a 00		 push	 0
  00163	6a 00		 push	 0
  00165	8b 55 f8	 mov	 edx, DWORD PTR _Extension$[ebp]
  00168	83 c2 24	 add	 edx, 36			; 00000024H
  0016b	52		 push	 edx
  0016c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 1806 : 		PsTerminateSystemThread (STATUS_SUCCESS);

  00172	6a 00		 push	 0
  00174	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsTerminateSystemThread@4
$LN11@VolumeThre:

; 1807 : 	}
; 1808 : 
; 1809 : 	// Start IO queue
; 1810 : 	Extension->Queue.IsFilterDevice = FALSE;

  0017a	8b 45 f8	 mov	 eax, DWORD PTR _Extension$[ebp]
  0017d	c7 80 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+228], 0

; 1811 : 	Extension->Queue.DeviceObject = DeviceObject;

  00187	8b 4d f8	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0018a	8b 55 f0	 mov	 edx, DWORD PTR _DeviceObject$[ebp]
  0018d	89 91 a8 00 00
	00		 mov	 DWORD PTR [ecx+168], edx

; 1812 : 	Extension->Queue.CryptoInfo = Extension->cryptoInfo;

  00193	8b 45 f8	 mov	 eax, DWORD PTR _Extension$[ebp]
  00196	8b 4d f8	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00199	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  0019c	89 90 d0 00 00
	00		 mov	 DWORD PTR [eax+208], edx

; 1813 : 	Extension->Queue.HostFileHandle = Extension->hDeviceFile;

  001a2	8b 45 f8	 mov	 eax, DWORD PTR _Extension$[ebp]
  001a5	8b 4d f8	 mov	 ecx, DWORD PTR _Extension$[ebp]
  001a8	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  001ab	89 90 d4 00 00
	00		 mov	 DWORD PTR [eax+212], edx

; 1814 : 	Extension->Queue.VirtualDeviceLength = Extension->DiskLength;

  001b1	8b 45 f8	 mov	 eax, DWORD PTR _Extension$[ebp]
  001b4	8b 4d f8	 mov	 ecx, DWORD PTR _Extension$[ebp]
  001b7	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  001ba	89 90 d8 00 00
	00		 mov	 DWORD PTR [eax+216], edx
  001c0	8b 49 74	 mov	 ecx, DWORD PTR [ecx+116]
  001c3	89 88 dc 00 00
	00		 mov	 DWORD PTR [eax+220], ecx

; 1815 : 	Extension->Queue.MaxReadAheadOffset.QuadPart = Extension->HostLength;

  001c9	8b 55 f8	 mov	 edx, DWORD PTR _Extension$[ebp]
  001cc	8b 45 f8	 mov	 eax, DWORD PTR _Extension$[ebp]
  001cf	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  001d2	89 8a 20 02 00
	00		 mov	 DWORD PTR [edx+544], ecx
  001d8	8b 40 6c	 mov	 eax, DWORD PTR [eax+108]
  001db	89 82 24 02 00
	00		 mov	 DWORD PTR [edx+548], eax

; 1816 : 
; 1817 : 	if (Extension->SecurityClientContextValid)

  001e1	8b 4d f8	 mov	 ecx, DWORD PTR _Extension$[ebp]
  001e4	83 b9 d0 04 00
	00 00		 cmp	 DWORD PTR [ecx+1232], 0
  001eb	74 14		 je	 SHORT $LN9@VolumeThre

; 1818 : 		Extension->Queue.SecurityClientContext = &Extension->SecurityClientContext;

  001ed	8b 55 f8	 mov	 edx, DWORD PTR _Extension$[ebp]
  001f0	81 c2 d4 04 00
	00		 add	 edx, 1236		; 000004d4H
  001f6	8b 45 f8	 mov	 eax, DWORD PTR _Extension$[ebp]
  001f9	89 90 e0 00 00
	00		 mov	 DWORD PTR [eax+224], edx

; 1819 : 	else

  001ff	eb 0d		 jmp	 SHORT $LN8@VolumeThre
$LN9@VolumeThre:

; 1820 : 		Extension->Queue.SecurityClientContext = NULL;

  00201	8b 4d f8	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00204	c7 81 e0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+224], 0
$LN8@VolumeThre:

; 1821 : 
; 1822 : 	pThreadBlock->ntCreateStatus = EncryptedIoQueueStart (&Extension->Queue);

  0020e	8b 55 f8	 mov	 edx, DWORD PTR _Extension$[ebp]
  00211	81 c2 a8 00 00
	00		 add	 edx, 168		; 000000a8H
  00217	52		 push	 edx
  00218	e8 00 00 00 00	 call	 _EncryptedIoQueueStart@4
  0021d	8b 4d f4	 mov	 ecx, DWORD PTR _pThreadBlock$[ebp]
  00220	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1823 : 
; 1824 : 	if (!NT_SUCCESS (pThreadBlock->ntCreateStatus))

  00223	8b 55 f4	 mov	 edx, DWORD PTR _pThreadBlock$[ebp]
  00226	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  0022a	7d 35		 jge	 SHORT $LN7@VolumeThre

; 1825 : 	{
; 1826 : 		TCCloseVolume (DeviceObject, Extension);

  0022c	8b 45 f8	 mov	 eax, DWORD PTR _Extension$[ebp]
  0022f	50		 push	 eax
  00230	8b 4d f0	 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  00233	51		 push	 ecx
  00234	e8 00 00 00 00	 call	 _TCCloseVolume@8

; 1827 : 
; 1828 : 		pThreadBlock->mount->nReturnCode = ERR_OS_ERROR;

  00239	8b 55 f4	 mov	 edx, DWORD PTR _pThreadBlock$[ebp]
  0023c	8b 82 20 02 00
	00		 mov	 eax, DWORD PTR [edx+544]
  00242	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 1829 : 		KeSetEvent (&Extension->keCreateEvent, 0, FALSE);

  00248	6a 00		 push	 0
  0024a	6a 00		 push	 0
  0024c	8b 4d f8	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0024f	83 c1 24	 add	 ecx, 36			; 00000024H
  00252	51		 push	 ecx
  00253	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 1830 : 		PsTerminateSystemThread (STATUS_SUCCESS);

  00259	6a 00		 push	 0
  0025b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsTerminateSystemThread@4
$LN7@VolumeThre:

; 1831 : 	}
; 1832 : 
; 1833 : 	KeSetEvent (&Extension->keCreateEvent, 0, FALSE);

  00261	6a 00		 push	 0
  00263	6a 00		 push	 0
  00265	8b 55 f8	 mov	 edx, DWORD PTR _Extension$[ebp]
  00268	83 c2 24	 add	 edx, 36			; 00000024H
  0026b	52		 push	 edx
  0026c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 1834 : 	/* From this point on pThreadBlock cannot be used as it will have been released! */
; 1835 : 	pThreadBlock = NULL;

  00272	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pThreadBlock$[ebp], 0
$LN6@VolumeThre:

; 1836 : 
; 1837 : 	for (;;)
; 1838 : 	{
; 1839 : 		/* Wait for a request from the dispatch routines. */
; 1840 : 		KeWaitForSingleObject ((PVOID) & Extension->RequestSemaphore, Executive, KernelMode, FALSE, NULL);

  00279	6a 00		 push	 0
  0027b	6a 00		 push	 0
  0027d	6a 00		 push	 0
  0027f	6a 00		 push	 0
  00281	8b 45 f8	 mov	 eax, DWORD PTR _Extension$[ebp]
  00284	83 c0 40	 add	 eax, 64			; 00000040H
  00287	50		 push	 eax
  00288	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
$LN4@VolumeThre:

; 1841 : 
; 1842 : 		for (;;)
; 1843 : 		{
; 1844 : 			PIO_STACK_LOCATION irpSp;
; 1845 : 			PLIST_ENTRY request;
; 1846 : 			PIRP irp;
; 1847 : 
; 1848 : 			request = ExInterlockedRemoveHeadList (&Extension->ListEntry, &Extension->ListSpinLock);

  0028e	8b 55 f8	 mov	 edx, DWORD PTR _Extension$[ebp]
  00291	83 c2 34	 add	 edx, 52			; 00000034H
  00294	8b 4d f8	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00297	83 c1 38	 add	 ecx, 56			; 00000038H
  0029a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExfInterlockedRemoveHeadList@8
  002a0	89 45 e8	 mov	 DWORD PTR _request$30651[ebp], eax

; 1849 : 			if (request == NULL)

  002a3	83 7d e8 00	 cmp	 DWORD PTR _request$30651[ebp], 0
  002a7	75 02		 jne	 SHORT $LN2@VolumeThre

; 1850 : 				break;

  002a9	eb 72		 jmp	 SHORT $LN3@VolumeThre
$LN2@VolumeThre:

; 1851 : 
; 1852 : 			irp = CONTAINING_RECORD (request, IRP, Tail.Overlay.ListEntry);

  002ab	8b 4d e8	 mov	 ecx, DWORD PTR _request$30651[ebp]
  002ae	83 e9 58	 sub	 ecx, 88			; 00000058H
  002b1	89 4d ec	 mov	 DWORD PTR _irp$30652[ebp], ecx

; 1853 : 			irpSp = IoGetCurrentIrpStackLocation (irp);

  002b4	8b 55 ec	 mov	 edx, DWORD PTR _irp$30652[ebp]
  002b7	52		 push	 edx
  002b8	e8 00 00 00 00	 call	 _IoGetCurrentIrpStackLocation@4
  002bd	89 45 e4	 mov	 DWORD PTR _irpSp$30650[ebp], eax

; 1854 : 
; 1855 : 			ASSERT (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL);

  002c0	8b 45 e4	 mov	 eax, DWORD PTR _irpSp$30650[ebp]
  002c3	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  002c6	83 f9 0e	 cmp	 ecx, 14			; 0000000eH
  002c9	74 20		 je	 SHORT $LN17@VolumeThre
  002cb	6a 00		 push	 0
  002cd	68 3f 07 00 00	 push	 1855			; 0000073fH
  002d2	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  002d7	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@PADHEFHE@irpSp?9?$DOMajorFunction?5?$DN?$DN?5IRP_MJ_D@FNODOBFM@
  002dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  002e2	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR tv213[ebp], 0
  002e9	eb 07		 jmp	 SHORT $LN18@VolumeThre
$LN17@VolumeThre:
  002eb	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR tv213[ebp], 1
$LN18@VolumeThre:

; 1856 : 
; 1857 : 			ProcessVolumeDeviceControlIrp (DeviceObject, Extension, irp);

  002f2	8b 55 ec	 mov	 edx, DWORD PTR _irp$30652[ebp]
  002f5	52		 push	 edx
  002f6	8b 45 f8	 mov	 eax, DWORD PTR _Extension$[ebp]
  002f9	50		 push	 eax
  002fa	8b 4d f0	 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  002fd	51		 push	 ecx
  002fe	e8 00 00 00 00	 call	 _ProcessVolumeDeviceControlIrp@12

; 1858 : 			IoReleaseRemoveLock (&Extension->Queue.RemoveLock, irp);

  00303	6a 58		 push	 88			; 00000058H
  00305	8b 55 ec	 mov	 edx, DWORD PTR _irp$30652[ebp]
  00308	52		 push	 edx
  00309	8b 45 f8	 mov	 eax, DWORD PTR _Extension$[ebp]
  0030c	05 18 01 00 00	 add	 eax, 280		; 00000118H
  00311	50		 push	 eax
  00312	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 1859 : 		}

  00318	e9 71 ff ff ff	 jmp	 $LN4@VolumeThre
$LN3@VolumeThre:

; 1860 : 
; 1861 : 		if (Extension->bThreadShouldQuit)

  0031d	8b 4d f8	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00320	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  00324	74 31		 je	 SHORT $LN1@VolumeThre

; 1862 : 		{
; 1863 : 			Dump ("Closing volume\n");

  00326	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@OMKHINCH@Closing?5volume?6?$AA@FNODOBFM@
  0032b	e8 00 00 00 00	 call	 _DbgPrint
  00330	83 c4 04	 add	 esp, 4

; 1864 : 			EncryptedIoQueueStop (&Extension->Queue);

  00333	8b 55 f8	 mov	 edx, DWORD PTR _Extension$[ebp]
  00336	81 c2 a8 00 00
	00		 add	 edx, 168		; 000000a8H
  0033c	52		 push	 edx
  0033d	e8 00 00 00 00	 call	 _EncryptedIoQueueStop@4

; 1865 : 
; 1866 : 			TCCloseVolume (DeviceObject, Extension);

  00342	8b 45 f8	 mov	 eax, DWORD PTR _Extension$[ebp]
  00345	50		 push	 eax
  00346	8b 4d f0	 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  00349	51		 push	 ecx
  0034a	e8 00 00 00 00	 call	 _TCCloseVolume@8

; 1867 : 			PsTerminateSystemThread (STATUS_SUCCESS);

  0034f	6a 00		 push	 0
  00351	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsTerminateSystemThread@4
$LN1@VolumeThre:

; 1868 : 		}
; 1869 : 	}

  00357	e9 1d ff ff ff	 jmp	 $LN6@VolumeThre

; 1870 : }

  0035c	5f		 pop	 edi
  0035d	5e		 pop	 esi
  0035e	8b e5		 mov	 esp, ebp
  00360	5d		 pop	 ebp
  00361	c2 04 00	 ret	 4
_VolumeThreadProc@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DA@GMJGMIMP@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_1DA@GMJGMIMP@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DA@GMJGMIMP@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'T', 00H, 'r', 00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r'
	DB	00H, 'y', 00H, 'p', 00H, 't', 00H, 'V', 00H, 'o', 00H, 'l', 00H
	DB	'u', 00H, 'm', 00H, 'e', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _TCGetNTNameFromNumber@8
_TEXT	SEGMENT
tv69 = -30						; size = 2
tv68 = -28						; size = 4
tv67 = -24						; size = 4
tv66 = -20						; size = 4
_j$ = -16						; size = 4
_tmp$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
_ntname$ = 8						; size = 4
_nDriveNo$ = 12						; size = 4
_TCGetNTNameFromNumber@8 PROC				; COMDAT

; 1873 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 20	 sub	 esp, 32			; 00000020H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1874 : 	WCHAR tmp[3] =
; 1875 : 	{0, ':', 0};

  00012	33 c0		 xor	 eax, eax
  00014	66 89 45 f4	 mov	 WORD PTR _tmp$[ebp], ax
  00018	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001d	66 89 4d f6	 mov	 WORD PTR _tmp$[ebp+2], cx
  00021	33 d2		 xor	 edx, edx
  00023	66 89 55 f8	 mov	 WORD PTR _tmp$[ebp+4], dx

; 1876 : 	int j = nDriveNo + (WCHAR) 'A';

  00027	8b 45 0c	 mov	 eax, DWORD PTR _nDriveNo$[ebp]
  0002a	83 c0 41	 add	 eax, 65			; 00000041H
  0002d	89 45 f0	 mov	 DWORD PTR _j$[ebp], eax

; 1877 : 
; 1878 : 	tmp[0] = (short) j;

  00030	66 8b 4d f0	 mov	 cx, WORD PTR _j$[ebp]
  00034	66 89 4d f4	 mov	 WORD PTR _tmp$[ebp], cx

; 1879 : 	wcscpy (ntname, (LPWSTR) NT_MOUNT_PREFIX);

  00038	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], OFFSET ??_C@_1DA@GMJGMIMP@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@FNODOBFM@
  0003f	8b 55 08	 mov	 edx, DWORD PTR _ntname$[ebp]
  00042	89 55 e8	 mov	 DWORD PTR tv67[ebp], edx
  00045	8b 45 e8	 mov	 eax, DWORD PTR tv67[ebp]
  00048	89 45 e4	 mov	 DWORD PTR tv68[ebp], eax
$LN3@TCGetNTNam:
  0004b	8b 4d ec	 mov	 ecx, DWORD PTR tv66[ebp]
  0004e	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00051	66 89 55 e2	 mov	 WORD PTR tv69[ebp], dx
  00055	8b 45 e8	 mov	 eax, DWORD PTR tv67[ebp]
  00058	66 8b 4d e2	 mov	 cx, WORD PTR tv69[ebp]
  0005c	66 89 08	 mov	 WORD PTR [eax], cx
  0005f	8b 55 ec	 mov	 edx, DWORD PTR tv66[ebp]
  00062	83 c2 02	 add	 edx, 2
  00065	89 55 ec	 mov	 DWORD PTR tv66[ebp], edx
  00068	8b 45 e8	 mov	 eax, DWORD PTR tv67[ebp]
  0006b	83 c0 02	 add	 eax, 2
  0006e	89 45 e8	 mov	 DWORD PTR tv67[ebp], eax
  00071	66 83 7d e2 00	 cmp	 WORD PTR tv69[ebp], 0
  00076	75 d3		 jne	 SHORT $LN3@TCGetNTNam

; 1880 : 	wcsncat (ntname, tmp, 1);

  00078	6a 01		 push	 1
  0007a	8d 4d f4	 lea	 ecx, DWORD PTR _tmp$[ebp]
  0007d	51		 push	 ecx
  0007e	8b 55 08	 mov	 edx, DWORD PTR _ntname$[ebp]
  00081	52		 push	 edx
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcsncat
  00088	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1881 : }

  0008b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008e	33 cd		 xor	 ecx, ebp
  00090	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c2 08 00	 ret	 8
_TCGetNTNameFromNumber@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _TCGetDosNameFromNumber@8
_TEXT	SEGMENT
tv143 = -58						; size = 2
tv140 = -56						; size = 4
tv137 = -52						; size = 4
tv136 = -48						; size = 4
tv131 = -42						; size = 2
tv128 = -40						; size = 4
tv94 = -36						; size = 4
tv69 = -30						; size = 2
tv68 = -28						; size = 4
tv67 = -24						; size = 4
tv66 = -20						; size = 4
_j$ = -16						; size = 4
_tmp$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
_dosname$ = 8						; size = 4
_nDriveNo$ = 12						; size = 4
_TCGetDosNameFromNumber@8 PROC				; COMDAT

; 1884 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00012	56		 push	 esi
  00013	57		 push	 edi

; 1885 : 	WCHAR tmp[3] =
; 1886 : 	{0, ':', 0};

  00014	33 c0		 xor	 eax, eax
  00016	66 89 45 f4	 mov	 WORD PTR _tmp$[ebp], ax
  0001a	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001f	66 89 4d f6	 mov	 WORD PTR _tmp$[ebp+2], cx
  00023	33 d2		 xor	 edx, edx
  00025	66 89 55 f8	 mov	 WORD PTR _tmp$[ebp+4], dx

; 1887 : 	int j = nDriveNo + (WCHAR) 'A';

  00029	8b 45 0c	 mov	 eax, DWORD PTR _nDriveNo$[ebp]
  0002c	83 c0 41	 add	 eax, 65			; 00000041H
  0002f	89 45 f0	 mov	 DWORD PTR _j$[ebp], eax

; 1888 : 
; 1889 : 	tmp[0] = (short) j;

  00032	66 8b 4d f0	 mov	 cx, WORD PTR _j$[ebp]
  00036	66 89 4d f4	 mov	 WORD PTR _tmp$[ebp], cx

; 1890 : 	//This is a risk point from CVE-2015-7358, there are global and per user mounts, need more logic here.
; 1891 : 	wcscpy (dosname, (LPWSTR) DOS_MOUNT_PREFIX);

  0003a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], OFFSET ??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@FNODOBFM@
  00041	8b 55 08	 mov	 edx, DWORD PTR _dosname$[ebp]
  00044	89 55 e8	 mov	 DWORD PTR tv67[ebp], edx
  00047	8b 45 e8	 mov	 eax, DWORD PTR tv67[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR tv68[ebp], eax
$LN3@TCGetDosNa:
  0004d	8b 4d ec	 mov	 ecx, DWORD PTR tv66[ebp]
  00050	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00053	66 89 55 e2	 mov	 WORD PTR tv69[ebp], dx
  00057	8b 45 e8	 mov	 eax, DWORD PTR tv67[ebp]
  0005a	66 8b 4d e2	 mov	 cx, WORD PTR tv69[ebp]
  0005e	66 89 08	 mov	 WORD PTR [eax], cx
  00061	8b 55 ec	 mov	 edx, DWORD PTR tv66[ebp]
  00064	83 c2 02	 add	 edx, 2
  00067	89 55 ec	 mov	 DWORD PTR tv66[ebp], edx
  0006a	8b 45 e8	 mov	 eax, DWORD PTR tv67[ebp]
  0006d	83 c0 02	 add	 eax, 2
  00070	89 45 e8	 mov	 DWORD PTR tv67[ebp], eax
  00073	66 83 7d e2 00	 cmp	 WORD PTR tv69[ebp], 0
  00078	75 d3		 jne	 SHORT $LN3@TCGetDosNa

; 1892 : 	wcscat (dosname, tmp);

  0007a	8d 4d f4	 lea	 ecx, DWORD PTR _tmp$[ebp]
  0007d	89 4d dc	 mov	 DWORD PTR tv94[ebp], ecx
  00080	8b 55 dc	 mov	 edx, DWORD PTR tv94[ebp]
  00083	89 55 d8	 mov	 DWORD PTR tv128[ebp], edx
$LL4@TCGetDosNa:
  00086	8b 45 dc	 mov	 eax, DWORD PTR tv94[ebp]
  00089	66 8b 08	 mov	 cx, WORD PTR [eax]
  0008c	66 89 4d d6	 mov	 WORD PTR tv131[ebp], cx
  00090	83 45 dc 02	 add	 DWORD PTR tv94[ebp], 2
  00094	66 83 7d d6 00	 cmp	 WORD PTR tv131[ebp], 0
  00099	75 eb		 jne	 SHORT $LL4@TCGetDosNa
  0009b	8b 55 dc	 mov	 edx, DWORD PTR tv94[ebp]
  0009e	2b 55 d8	 sub	 edx, DWORD PTR tv128[ebp]
  000a1	8b 45 d8	 mov	 eax, DWORD PTR tv128[ebp]
  000a4	89 45 d0	 mov	 DWORD PTR tv136[ebp], eax
  000a7	89 55 cc	 mov	 DWORD PTR tv137[ebp], edx
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR _dosname$[ebp]
  000ad	83 c1 fe	 add	 ecx, -2			; fffffffeH
  000b0	89 4d c8	 mov	 DWORD PTR tv140[ebp], ecx
$LL5@TCGetDosNa:
  000b3	8b 55 c8	 mov	 edx, DWORD PTR tv140[ebp]
  000b6	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  000ba	66 89 45 c6	 mov	 WORD PTR tv143[ebp], ax
  000be	83 45 c8 02	 add	 DWORD PTR tv140[ebp], 2
  000c2	66 83 7d c6 00	 cmp	 WORD PTR tv143[ebp], 0
  000c7	75 ea		 jne	 SHORT $LL5@TCGetDosNa
  000c9	8b 7d c8	 mov	 edi, DWORD PTR tv140[ebp]
  000cc	8b 75 d0	 mov	 esi, DWORD PTR tv136[ebp]
  000cf	8b 55 cc	 mov	 edx, DWORD PTR tv137[ebp]
  000d2	8b ca		 mov	 ecx, edx
  000d4	c1 e9 02	 shr	 ecx, 2
  000d7	f3 a5		 rep movsd
  000d9	8b ca		 mov	 ecx, edx
  000db	83 e1 03	 and	 ecx, 3
  000de	f3 a4		 rep movsb

; 1893 : }

  000e0	5f		 pop	 edi
  000e1	5e		 pop	 esi
  000e2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e5	33 cd		 xor	 ecx, ebp
  000e7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c2 08 00	 ret	 8
_TCGetDosNameFromNumber@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1M@KHJOIALG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CM@DKLAEDLO@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAT?$AAR?$AAO?$AAL?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CA@FOECGGNC@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAS?$AAH?$AAU?$AAT?$AAD?$AAO?$AAW?$AAN?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CK@MCKHKFDD@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAF?$AAL?$AAU?$AAS?$AAH?$AA_?$AAB?$AAU?$AAF?$AAF?$AAE?$AAR?$AAS?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BO@GEGOKABG@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAL?$AAE?$AAA?$AAN?$AAU?$AAP?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BK@JLALPKNJ@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAL?$AAO?$AAS?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BM@KFEHBPBD@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BK@HGBIKEDO@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAW?$AAR?$AAI?$AAT?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BI@CFPHGFDN@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAR?$AAE?$AAA?$AAD?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DO@MEELNMKF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAO?$AAR?$AAA?$AAG?$AAE?$AA_?$AAS?$AAE?$AAT?$AA_?$AAH?$AAO?$AAT?$AAP?$AAL?$AAU?$AAG?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DG@MIHPHMPG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA_?$AAT?$AAY?$AAP?$AAE?$AAS?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DI@EBJJOMKC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAI?$AAN?$AAD?$AA_?$AAN?$AAE?$AAW?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AAS?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CG@BFEEHHEK@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAL?$AAE?$AAA?$AAS?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CG@MJDBKCLM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAS?$AAE?$AAR?$AAV?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CM@GNBBIMEE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAL?$AAO?$AAA?$AAD?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CO@KHEOABCH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAE?$AAJ?$AAE?$AAC?$AAT?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DC@NMJCPDJD@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA_?$AAR?$AAE?$AAM?$AAO?$AAV?$AAA?$AAL?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DA@DLMBEKMN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAC?$AAH?$AAE?$AAC?$AAK?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EC@JFOBAPGC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAN?$AAT?$AAE?$AAR?$AAN?$AAA?$AAL?$AA_?$AAC?$AAL?$AAE?$AAA?$AAR?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DO@JKPDDEIN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAN?$AAT?$AAE?$AAR?$AAN?$AAA?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CK@JCHEBCIE@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAR?$AAC?$AAV?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DC@MGFPICHJ@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAS?$AAE?$AAN?$AAD?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAC?$AAO?$AAM?$AAM?$AAA?$AAN?$AAD?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CE@PLNOGJJD@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DK@NNJOEKIN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAC?$AAO?$AAN?$AAT?$AAR?$AAO?$AAL?$AAL?$AAE?$AAR?$AA_?$AAN?$AAU?$AAM?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DA@EGLLKJNO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAQ?$AAU?$AAE?$AAS?$AAT?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DK@EFIEFEEG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAQ?$AAU?$AAE?$AAS?$AAT?$AA_?$AAS?$AAT?$AAR?$AAU?$AAC?$AAT?$AAU?$AAR?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DG@BLHGEOGG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAR?$AAE?$AAS?$AAE?$AAT?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DE@OGHADOL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DO@JMICENAF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAS?$AAT?$AAR?$AAU?$AAC?$AAT?$AAU?$AAR?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DI@LHHOILKE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAT?$AAR?$AAA?$AAC?$AAK?$AAS?$AA_?$AAE?$AAX?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CG@LCBFNDKM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAL?$AAO?$AAG?$AAG?$AAI?$AAN?$AAG?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CO@MFHKENAI@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAS?$AA_?$AAW?$AAR?$AAI?$AAT?$AAA?$AAB?$AAL?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CO@LEDAJMII@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAP?$AAE?$AAR?$AAF?$AAO?$AAR?$AAM?$AAA?$AAN?$AAC?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DG@HPLPDECO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAA?$AAS?$AAS?$AAI?$AAG?$AAN?$AA_?$AAB?$AAL?$AAO?$AAC?$AAK?$AAS?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DC@PCKIDBBB@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAT?$AAR?$AAA?$AAC?$AAK?$AAS?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CE@LGEELOJE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DO@EPIDKIKJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAS?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAL?$AAA?$AAY?$AAO?$AAU?$AAT?$AA_?$AAE?$AAX?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DI@CCDFFIEC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAL?$AAA?$AAY?$AAO?$AAU?$AAT?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DM@FAAIHMNH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAS?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EC@CAILBHJF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA_?$AAE?$AAX@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DM@LOAKHCPB@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EA@IKPNDHCL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAO?$AAR?$AAA?$AAG?$AAE?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAN?$AAU?$AAM?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DG@DLDFECDE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAL?$AAE?$AAN?$AAG?$AAT?$AAH?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1FE@EBMKFIFJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAP?$AAO?$AAI?$AAN@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1FE@CLAOKMGL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAP?$AAO?$AAI?$AAN@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DI@LFNEEBHO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAP?$AAO?$AAI?$AAN?$AAT?$AAS?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DI@BMKMBCGO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAL?$AAI?$AAN?$AAK?$AA_?$AAD?$AAE?$AAL?$AAE?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DI@HGGIOGFM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAL?$AAI?$AAN?$AAK?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CI@DJEMJCBH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAO?$AAN?$AAL?$AAI?$AAN?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DO@OGNDJPNH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAU?$AAN?$AAI?$AAQ?$AAU?$AAE?$AA_?$AAI?$AAD?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1FC@MNMCPAAJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAS?$AAU?$AAG?$AAG?$AAE?$AAS?$AAT?$AAE?$AAD?$AA_?$AAL@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EC@HFOIOEOM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAN?$AAA?$AAM?$AAE@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EC@NPAFBAMN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA_?$AAE?$AAX@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DM@KPKDNCHM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EK@FDCJEFAP@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAE?$AAX?$AAT@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EC@FOOPNHFI@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAW?$AAR?$AAI?$AAT?$AAE?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAS?$AAE?$AAC?$AAT?$AAO?$AAR@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DK@BNKDMLAM@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_?$AAP?$AAA?$AAS?$AAS?$AAW?$AAO?$AAR?$AAD?$AA_?$AAC?$AAA?$AAC?$AAH?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EC@FGBEDIDI@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAA?$AAR?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1FE@EBAIHKDI@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAF?$AAA?$AAV?$AAO?$AAR?$AAI?$AAT?$AAE?$AA_?$AAV?$AAO?$AAL@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DM@JFJLBNLP@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAR?$AAE?$AAR?$AAE?$AAA?$AAD?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EG@GGODONFK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAR?$AAE?$AAO?$AAP?$AAE?$AAN?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAH?$AAE?$AAA?$AAD@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DO@BKHLMLHN@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAP?$AAR?$AAO?$AAB?$AAE?$AA_?$AAR?$AAE?$AAA?$AAL?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CG@HPPKKEKP@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAO?$AAP?$AAE?$AAN?$AA_?$AAT?$AAE?$AAS?$AAT?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CM@HJCGFKAD@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EE@HPDOLCKH@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAH?$AAI?$AAD?$AAD?$AAE?$AAN?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAR?$AAU?$AAN?$AAN?$AAI?$AAN@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EG@HPLFHOOO@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAU?$AAN?$AAL?$AAO?$AAA?$AAD?$AA_?$AAD?$AAI?$AAS?$AAA?$AAB?$AAL@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DO@ICDMEENM@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAA?$AAN?$AAY?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DE@JNPINMHP@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAS?$AA_?$AAW?$AAR?$AAI?$AAT?$AAA?$AAB?$AAL?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DG@LBDEDPBA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAW?$AAA?$AAR?$AAN?$AAI?$AAN?$AAG?$AA_?$AAF?$AAL?$AAA?$AAG?$AAS?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DO@DMIHGGIB@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAP?$AAR?$AAO?$AAP?$AAE?$AAR?$AAT?$AAI?$AAE?$AAS?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EM@GFDNBFC@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAD?$AAU?$AAM?$AAP?$AA_?$AAC@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DM@GFCMCNDC@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAR?$AAE?$AAS?$AAO?$AAL?$AAV?$AAE?$AAD?$AA_?$AAS?$AAY?$AAM?$AAL?$AAI?$AAN?$AAK?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EE@NMKCMMBM@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAP?$AAO?$AAR?$AAT?$AAA?$AAB?$AAL?$AAE?$AA_?$AAM?$AAO?$AAD?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EE@IPNJBDEG@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAO?$AAR?$AAT?$AAA?$AAB?$AAL?$AAE?$AA_?$AAM?$AAO?$AAD?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EC@FADHDJPK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EG@LLJHBPJF@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAS?$AAS?$AAW?$AAO?$AAR?$AAD?$AA_?$AAC?$AAA?$AAC?$AAH?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DK@KJKOFIJA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAE?$AAD?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AAS?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DI@ODPPPDDO@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EE@HEELFNND@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DI@LAIAIOML@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DK@DFEJGDBK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAR?$AAE?$AAF?$AAC?$AAO?$AAU?$AAN?$AAT?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EM@LMAMOKGA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_?$AAS@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EM@OAEBJACE@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_?$AAR@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EC@OPCJHCIG@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAL?$AAO?$AAA?$AAD?$AAE?$AAR?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EI@GAKLFLAF@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAT?$AAA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1FE@OJNNCONL@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAE?$AAT@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1FI@CDJGLMPJ@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA?$AAL?$AAG@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1FE@BEJBLKBA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAP@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DC@CLEBJPLG@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DM@OLONGNGL@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAA?$AAL?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AAS?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DO@JPMJPMCJ@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAE?$AAT?$AAU?$AAP?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EC@HMNCILMA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAA?$AAB?$AAO?$AAR?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EK@CMLLEBIK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAA?$AAB?$AAO?$AAR?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_1M@KHJOIALG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1M@KHJOIALG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA?$AA@FNODOBFM@ DB 'I', 00H
	DB	'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CM@DKLAEDLO@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAT?$AAR?$AAO?$AAL?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CM@DKLAEDLO@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAT?$AAR?$AAO?$AAL?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'R', 00H, 'P', 00H, '_', 00H, 'M', 00H, 'J', 00H, '_', 00H
	DB	'D', 00H, 'E', 00H, 'V', 00H, 'I', 00H, 'C', 00H, 'E', 00H, '_'
	DB	00H, 'C', 00H, 'O', 00H, 'N', 00H, 'T', 00H, 'R', 00H, 'O', 00H
	DB	'L', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CA@FOECGGNC@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAS?$AAH?$AAU?$AAT?$AAD?$AAO?$AAW?$AAN?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CA@FOECGGNC@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAS?$AAH?$AAU?$AAT?$AAD?$AAO?$AAW?$AAN?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'R', 00H, 'P', 00H, '_', 00H, 'M', 00H, 'J', 00H, '_', 00H
	DB	'S', 00H, 'H', 00H, 'U', 00H, 'T', 00H, 'D', 00H, 'O', 00H, 'W'
	DB	00H, 'N', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CK@MCKHKFDD@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAF?$AAL?$AAU?$AAS?$AAH?$AA_?$AAB?$AAU?$AAF?$AAF?$AAE?$AAR?$AAS?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CK@MCKHKFDD@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAF?$AAL?$AAU?$AAS?$AAH?$AA_?$AAB?$AAU?$AAF?$AAF?$AAE?$AAR?$AAS?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'R', 00H, 'P', 00H, '_', 00H, 'M', 00H, 'J', 00H, '_', 00H
	DB	'F', 00H, 'L', 00H, 'U', 00H, 'S', 00H, 'H', 00H, '_', 00H, 'B'
	DB	00H, 'U', 00H, 'F', 00H, 'F', 00H, 'E', 00H, 'R', 00H, 'S', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BO@GEGOKABG@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAL?$AAE?$AAA?$AAN?$AAU?$AAP?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BO@GEGOKABG@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAL?$AAE?$AAA?$AAN?$AAU?$AAP?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'R', 00H, 'P', 00H, '_', 00H, 'M', 00H, 'J', 00H, '_', 00H
	DB	'C', 00H, 'L', 00H, 'E', 00H, 'A', 00H, 'N', 00H, 'U', 00H, 'P'
	DB	00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BK@JLALPKNJ@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAL?$AAO?$AAS?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BK@JLALPKNJ@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAL?$AAO?$AAS?$AAE?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'R', 00H, 'P', 00H, '_', 00H, 'M', 00H, 'J', 00H, '_', 00H
	DB	'C', 00H, 'L', 00H, 'O', 00H, 'S', 00H, 'E', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BM@KFEHBPBD@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BM@KFEHBPBD@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'R', 00H, 'P', 00H, '_', 00H, 'M', 00H, 'J', 00H, '_', 00H
	DB	'C', 00H, 'R', 00H, 'E', 00H, 'A', 00H, 'T', 00H, 'E', 00H, 00H
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BK@HGBIKEDO@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAW?$AAR?$AAI?$AAT?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BK@HGBIKEDO@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAW?$AAR?$AAI?$AAT?$AAE?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'R', 00H, 'P', 00H, '_', 00H, 'M', 00H, 'J', 00H, '_', 00H
	DB	'W', 00H, 'R', 00H, 'I', 00H, 'T', 00H, 'E', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BI@CFPHGFDN@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAR?$AAE?$AAA?$AAD?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BI@CFPHGFDN@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAR?$AAE?$AAA?$AAD?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'R', 00H, 'P', 00H, '_', 00H, 'M', 00H, 'J', 00H, '_', 00H
	DB	'R', 00H, 'E', 00H, 'A', 00H, 'D', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DO@MEELNMKF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAO?$AAR?$AAA?$AAG?$AAE?$AA_?$AAS?$AAE?$AAT?$AA_?$AAH?$AAO?$AAT?$AAP?$AAL?$AAU?$AAG?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DO@MEELNMKF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAO?$AAR?$AAA?$AAG?$AAE?$AA_?$AAS?$AAE?$AAT?$AA_?$AAH?$AAO?$AAT?$AAP?$AAL?$AAU?$AAG?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'S', 00H
	DB	'T', 00H, 'O', 00H, 'R', 00H, 'A', 00H, 'G', 00H, 'E', 00H, '_'
	DB	00H, 'S', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'H', 00H, 'O', 00H
	DB	'T', 00H, 'P', 00H, 'L', 00H, 'U', 00H, 'G', 00H, '_', 00H, 'I'
	DB	00H, 'N', 00H, 'F', 00H, 'O', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DG@MIHPHMPG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA_?$AAT?$AAY?$AAP?$AAE?$AAS?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DG@MIHPHMPG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA_?$AAT?$AAY?$AAP?$AAE?$AAS?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T'
	DB	00H, '_', 00H, 'M', 00H, 'E', 00H, 'D', 00H, 'I', 00H, 'A', 00H
	DB	'_', 00H, 'T', 00H, 'Y', 00H, 'P', 00H, 'E', 00H, 'S', 00H, 00H
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DI@EBJJOMKC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAI?$AAN?$AAD?$AA_?$AAN?$AAE?$AAW?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AAS?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DI@EBJJOMKC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAI?$AAN?$AAD?$AA_?$AAN?$AAE?$AAW?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AAS?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'F', 00H, 'I', 00H, 'N'
	DB	00H, 'D', 00H, '_', 00H, 'N', 00H, 'E', 00H, 'W', 00H, '_', 00H
	DB	'D', 00H, 'E', 00H, 'V', 00H, 'I', 00H, 'C', 00H, 'E', 00H, 'S'
	DB	00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CG@BFEEHHEK@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAL?$AAE?$AAA?$AAS?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CG@BFEEHHEK@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAL?$AAE?$AAA?$AAS?$AAE?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'L'
	DB	00H, 'E', 00H, 'A', 00H, 'S', 00H, 'E', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CG@MJDBKCLM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAS?$AAE?$AAR?$AAV?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CG@MJDBKCLM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAS?$AAE?$AAR?$AAV?$AAE?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'S'
	DB	00H, 'E', 00H, 'R', 00H, 'V', 00H, 'E', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CM@GNBBIMEE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAL?$AAO?$AAA?$AAD?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CM@GNBBIMEE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAL?$AAO?$AAA?$AAD?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'L', 00H, 'O', 00H, 'A'
	DB	00H, 'D', 00H, '_', 00H, 'M', 00H, 'E', 00H, 'D', 00H, 'I', 00H
	DB	'A', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CO@KHEOABCH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAE?$AAJ?$AAE?$AAC?$AAT?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CO@KHEOABCH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAE?$AAJ?$AAE?$AAC?$AAT?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'E', 00H, 'J', 00H, 'E'
	DB	00H, 'C', 00H, 'T', 00H, '_', 00H, 'M', 00H, 'E', 00H, 'D', 00H
	DB	'I', 00H, 'A', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DC@NMJCPDJD@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA_?$AAR?$AAE?$AAM?$AAO?$AAV?$AAA?$AAL?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DC@NMJCPDJD@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA_?$AAR?$AAE?$AAM?$AAO?$AAV?$AAA?$AAL?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'M', 00H, 'E', 00H, 'D'
	DB	00H, 'I', 00H, 'A', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'M', 00H
	DB	'O', 00H, 'V', 00H, 'A', 00H, 'L', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DA@DLMBEKMN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAC?$AAH?$AAE?$AAC?$AAK?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DA@DLMBEKMN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAC?$AAH?$AAE?$AAC?$AAK?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'C', 00H, 'H', 00H, 'E'
	DB	00H, 'C', 00H, 'K', 00H, '_', 00H, 'V', 00H, 'E', 00H, 'R', 00H
	DB	'I', 00H, 'F', 00H, 'Y', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EC@JFOBAPGC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAN?$AAT?$AAE?$AAR?$AAN?$AAA?$AAL?$AA_?$AAC?$AAL?$AAE?$AAA?$AAR?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY@FNODOBFM@
text$s	SEGMENT
??_C@_1EC@JFOBAPGC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAN?$AAT?$AAE?$AAR?$AAN?$AAA?$AAL?$AA_?$AAC?$AAL?$AAE?$AAA?$AAR?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'I', 00H, 'N', 00H, 'T'
	DB	00H, 'E', 00H, 'R', 00H, 'N', 00H, 'A', 00H, 'L', 00H, '_', 00H
	DB	'C', 00H, 'L', 00H, 'E', 00H, 'A', 00H, 'R', 00H, '_', 00H, 'V'
	DB	00H, 'E', 00H, 'R', 00H, 'I', 00H, 'F', 00H, 'Y', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DO@JKPDDEIN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAN?$AAT?$AAE?$AAR?$AAN?$AAA?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DO@JKPDDEIN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAN?$AAT?$AAE?$AAR?$AAN?$AAA?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'I', 00H, 'N', 00H, 'T'
	DB	00H, 'E', 00H, 'R', 00H, 'N', 00H, 'A', 00H, 'L', 00H, '_', 00H
	DB	'S', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'V', 00H, 'E', 00H, 'R'
	DB	00H, 'I', 00H, 'F', 00H, 'Y', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CK@JCHEBCIE@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAR?$AAC?$AAV?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CK@JCHEBCIE@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAR?$AAC?$AAV?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@ DB 'S'
	DB	00H, 'M', 00H, 'A', 00H, 'R', 00H, 'T', 00H, '_', 00H, 'R', 00H
	DB	'C', 00H, 'V', 00H, '_', 00H, 'D', 00H, 'R', 00H, 'I', 00H, 'V'
	DB	00H, 'E', 00H, '_', 00H, 'D', 00H, 'A', 00H, 'T', 00H, 'A', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DC@MGFPICHJ@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAS?$AAE?$AAN?$AAD?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAC?$AAO?$AAM?$AAM?$AAA?$AAN?$AAD?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DC@MGFPICHJ@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAS?$AAE?$AAN?$AAD?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAC?$AAO?$AAM?$AAM?$AAA?$AAN?$AAD?$AA?$AA@FNODOBFM@ DB 'S'
	DB	00H, 'M', 00H, 'A', 00H, 'R', 00H, 'T', 00H, '_', 00H, 'S', 00H
	DB	'E', 00H, 'N', 00H, 'D', 00H, '_', 00H, 'D', 00H, 'R', 00H, 'I'
	DB	00H, 'V', 00H, 'E', 00H, '_', 00H, 'C', 00H, 'O', 00H, 'M', 00H
	DB	'M', 00H, 'A', 00H, 'N', 00H, 'D', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CE@PLNOGJJD@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CE@PLNOGJJD@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN?$AA?$AA@FNODOBFM@ DB 'S'
	DB	00H, 'M', 00H, 'A', 00H, 'R', 00H, 'T', 00H, '_', 00H, 'G', 00H
	DB	'E', 00H, 'T', 00H, '_', 00H, 'V', 00H, 'E', 00H, 'R', 00H, 'S'
	DB	00H, 'I', 00H, 'O', 00H, 'N', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DK@NNJOEKIN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAC?$AAO?$AAN?$AAT?$AAR?$AAO?$AAL?$AAL?$AAE?$AAR?$AA_?$AAN?$AAU?$AAM?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DK@NNJOEKIN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAC?$AAO?$AAN?$AAT?$AAR?$AAO?$AAL?$AAL?$AAE?$AAR?$AA_?$AAN?$AAU?$AAM?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'C', 00H, 'O', 00H, 'N'
	DB	00H, 'T', 00H, 'R', 00H, 'O', 00H, 'L', 00H, 'L', 00H, 'E', 00H
	DB	'R', 00H, '_', 00H, 'N', 00H, 'U', 00H, 'M', 00H, 'B', 00H, 'E'
	DB	00H, 'R', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DA@EGLLKJNO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAQ?$AAU?$AAE?$AAS?$AAT?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DA@EGLLKJNO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAQ?$AAU?$AAE?$AAS?$AAT?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'Q'
	DB	00H, 'U', 00H, 'E', 00H, 'S', 00H, 'T', 00H, '_', 00H, 'D', 00H
	DB	'A', 00H, 'T', 00H, 'A', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DK@EFIEFEEG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAQ?$AAU?$AAE?$AAS?$AAT?$AA_?$AAS?$AAT?$AAR?$AAU?$AAC?$AAT?$AAU?$AAR?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DK@EFIEFEEG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAQ?$AAU?$AAE?$AAS?$AAT?$AA_?$AAS?$AAT?$AAR?$AAU?$AAC?$AAT?$AAU?$AAR?$AAE?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'Q'
	DB	00H, 'U', 00H, 'E', 00H, 'S', 00H, 'T', 00H, '_', 00H, 'S', 00H
	DB	'T', 00H, 'R', 00H, 'U', 00H, 'C', 00H, 'T', 00H, 'U', 00H, 'R'
	DB	00H, 'E', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DG@BLHGEOGG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAR?$AAE?$AAS?$AAE?$AAT?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DG@BLHGEOGG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAR?$AAE?$AAS?$AAE?$AAT?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'H', 00H, 'I', 00H, 'S'
	DB	00H, 'T', 00H, 'O', 00H, 'G', 00H, 'R', 00H, 'A', 00H, 'M', 00H
	DB	'_', 00H, 'R', 00H, 'E', 00H, 'S', 00H, 'E', 00H, 'T', 00H, 00H
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DE@OGHADOL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DE@OGHADOL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'H', 00H, 'I', 00H, 'S'
	DB	00H, 'T', 00H, 'O', 00H, 'G', 00H, 'R', 00H, 'A', 00H, 'M', 00H
	DB	'_', 00H, 'D', 00H, 'A', 00H, 'T', 00H, 'A', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DO@JMICENAF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAS?$AAT?$AAR?$AAU?$AAC?$AAT?$AAU?$AAR?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DO@JMICENAF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAS?$AAT?$AAR?$AAU?$AAC?$AAT?$AAU?$AAR?$AAE?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'H', 00H, 'I', 00H, 'S'
	DB	00H, 'T', 00H, 'O', 00H, 'G', 00H, 'R', 00H, 'A', 00H, 'M', 00H
	DB	'_', 00H, 'S', 00H, 'T', 00H, 'R', 00H, 'U', 00H, 'C', 00H, 'T'
	DB	00H, 'U', 00H, 'R', 00H, 'E', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DI@LHHOILKE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAT?$AAR?$AAA?$AAC?$AAK?$AAS?$AA_?$AAE?$AAX?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DI@LHHOILKE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAT?$AAR?$AAA?$AAC?$AAK?$AAS?$AA_?$AAE?$AAX?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'F', 00H, 'O', 00H, 'R'
	DB	00H, 'M', 00H, 'A', 00H, 'T', 00H, '_', 00H, 'T', 00H, 'R', 00H
	DB	'A', 00H, 'C', 00H, 'K', 00H, 'S', 00H, '_', 00H, 'E', 00H, 'X'
	DB	00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CG@LCBFNDKM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAL?$AAO?$AAG?$AAG?$AAI?$AAN?$AAG?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CG@LCBFNDKM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAL?$AAO?$AAG?$AAG?$AAI?$AAN?$AAG?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'L', 00H, 'O', 00H, 'G'
	DB	00H, 'G', 00H, 'I', 00H, 'N', 00H, 'G', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CO@MFHKENAI@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAS?$AA_?$AAW?$AAR?$AAI?$AAT?$AAA?$AAB?$AAL?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CO@MFHKENAI@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAS?$AA_?$AAW?$AAR?$AAI?$AAT?$AAA?$AAB?$AAL?$AAE?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_'
	DB	00H, 'W', 00H, 'R', 00H, 'I', 00H, 'T', 00H, 'A', 00H, 'B', 00H
	DB	'L', 00H, 'E', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CO@LEDAJMII@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAP?$AAE?$AAR?$AAF?$AAO?$AAR?$AAM?$AAA?$AAN?$AAC?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CO@LEDAJMII@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAP?$AAE?$AAR?$AAF?$AAO?$AAR?$AAM?$AAA?$AAN?$AAC?$AAE?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'P', 00H, 'E', 00H, 'R'
	DB	00H, 'F', 00H, 'O', 00H, 'R', 00H, 'M', 00H, 'A', 00H, 'N', 00H
	DB	'C', 00H, 'E', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DG@HPLPDECO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAA?$AAS?$AAS?$AAI?$AAG?$AAN?$AA_?$AAB?$AAL?$AAO?$AAC?$AAK?$AAS?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DG@HPLPDECO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAA?$AAS?$AAS?$AAI?$AAG?$AAN?$AA_?$AAB?$AAL?$AAO?$AAC?$AAK?$AAS?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'A'
	DB	00H, 'S', 00H, 'S', 00H, 'I', 00H, 'G', 00H, 'N', 00H, '_', 00H
	DB	'B', 00H, 'L', 00H, 'O', 00H, 'C', 00H, 'K', 00H, 'S', 00H, 00H
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DC@PCKIDBBB@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAT?$AAR?$AAA?$AAC?$AAK?$AAS?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DC@PCKIDBBB@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAT?$AAR?$AAA?$AAC?$AAK?$AAS?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'F', 00H, 'O', 00H, 'R'
	DB	00H, 'M', 00H, 'A', 00H, 'T', 00H, '_', 00H, 'T', 00H, 'R', 00H
	DB	'A', 00H, 'C', 00H, 'K', 00H, 'S', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CE@LGEELOJE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CE@LGEELOJE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'V', 00H, 'E', 00H, 'R'
	DB	00H, 'I', 00H, 'F', 00H, 'Y', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DO@EPIDKIKJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAS?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAL?$AAA?$AAY?$AAO?$AAU?$AAT?$AA_?$AAE?$AAX?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DO@EPIDKIKJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAS?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAL?$AAA?$AAY?$AAO?$AAU?$AAT?$AA_?$AAE?$AAX?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'S', 00H, 'E', 00H, 'T'
	DB	00H, '_', 00H, 'D', 00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H
	DB	'_', 00H, 'L', 00H, 'A', 00H, 'Y', 00H, 'O', 00H, 'U', 00H, 'T'
	DB	00H, '_', 00H, 'E', 00H, 'X', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DI@CCDFFIEC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAL?$AAA?$AAY?$AAO?$AAU?$AAT?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DI@CCDFFIEC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAL?$AAA?$AAY?$AAO?$AAU?$AAT?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T'
	DB	00H, '_', 00H, 'D', 00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H
	DB	'_', 00H, 'L', 00H, 'A', 00H, 'Y', 00H, 'O', 00H, 'U', 00H, 'T'
	DB	00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DM@FAAIHMNH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAS?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DM@FAAIHMNH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAS?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'S', 00H, 'E', 00H, 'T'
	DB	00H, '_', 00H, 'P', 00H, 'A', 00H, 'R', 00H, 'T', 00H, 'I', 00H
	DB	'T', 00H, 'I', 00H, 'O', 00H, 'N', 00H, '_', 00H, 'I', 00H, 'N'
	DB	00H, 'F', 00H, 'O', 00H, 00H, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EC@CAILBHJF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA_?$AAE?$AAX@FNODOBFM@
text$s	SEGMENT
??_C@_1EC@CAILBHJF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA_?$AAE?$AAX@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T'
	DB	00H, '_', 00H, 'P', 00H, 'A', 00H, 'R', 00H, 'T', 00H, 'I', 00H
	DB	'T', 00H, 'I', 00H, 'O', 00H, 'N', 00H, '_', 00H, 'I', 00H, 'N'
	DB	00H, 'F', 00H, 'O', 00H, '_', 00H, 'E', 00H, 'X', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DM@LOAKHCPB@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DM@LOAKHCPB@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T'
	DB	00H, '_', 00H, 'P', 00H, 'A', 00H, 'R', 00H, 'T', 00H, 'I', 00H
	DB	'T', 00H, 'I', 00H, 'O', 00H, 'N', 00H, '_', 00H, 'I', 00H, 'N'
	DB	00H, 'F', 00H, 'O', 00H, 00H, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EA@IKPNDHCL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAO?$AAR?$AAA?$AAG?$AAE?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAN?$AAU?$AAM?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1EA@IKPNDHCL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAO?$AAR?$AAA?$AAG?$AAE?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAN?$AAU?$AAM?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'S', 00H
	DB	'T', 00H, 'O', 00H, 'R', 00H, 'A', 00H, 'G', 00H, 'E', 00H, '_'
	DB	00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'D', 00H, 'E', 00H
	DB	'V', 00H, 'I', 00H, 'C', 00H, 'E', 00H, '_', 00H, 'N', 00H, 'U'
	DB	00H, 'M', 00H, 'B', 00H, 'E', 00H, 'R', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DG@DLDFECDE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAL?$AAE?$AAN?$AAG?$AAT?$AAH?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DG@DLDFECDE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAL?$AAE?$AAN?$AAG?$AAT?$AAH?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T'
	DB	00H, '_', 00H, 'L', 00H, 'E', 00H, 'N', 00H, 'G', 00H, 'T', 00H
	DB	'H', 00H, '_', 00H, 'I', 00H, 'N', 00H, 'F', 00H, 'O', 00H, 00H
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1FE@EBMKFIFJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAP?$AAO?$AAI?$AAN@FNODOBFM@
text$s	SEGMENT
??_C@_1FE@EBMKFIFJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAP?$AAO?$AAI?$AAN@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'M', 00H, 'G', 00H, 'R'
	DB	00H, '_', 00H, 'V', 00H, 'O', 00H, 'L', 00H, 'U', 00H, 'M', 00H
	DB	'E', 00H, '_', 00H, 'M', 00H, 'O', 00H, 'U', 00H, 'N', 00H, 'T'
	DB	00H, '_', 00H, 'P', 00H, 'O', 00H, 'I', 00H, 'N', 00H, 'T', 00H
	DB	'_', 00H, 'D', 00H, 'E', 00H, 'L', 00H, 'E', 00H, 'T', 00H, 'E'
	DB	00H, 'D', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1FE@CLAOKMGL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAP?$AAO?$AAI?$AAN@FNODOBFM@
text$s	SEGMENT
??_C@_1FE@CLAOKMGL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAP?$AAO?$AAI?$AAN@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'M', 00H, 'G', 00H, 'R'
	DB	00H, '_', 00H, 'V', 00H, 'O', 00H, 'L', 00H, 'U', 00H, 'M', 00H
	DB	'E', 00H, '_', 00H, 'M', 00H, 'O', 00H, 'U', 00H, 'N', 00H, 'T'
	DB	00H, '_', 00H, 'P', 00H, 'O', 00H, 'I', 00H, 'N', 00H, 'T', 00H
	DB	'_', 00H, 'C', 00H, 'R', 00H, 'E', 00H, 'A', 00H, 'T', 00H, 'E'
	DB	00H, 'D', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DI@LFNEEBHO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAP?$AAO?$AAI?$AAN?$AAT?$AAS?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DI@LFNEEBHO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAP?$AAO?$AAI?$AAN?$AAT?$AAS?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'M', 00H, 'G', 00H, 'R'
	DB	00H, '_', 00H, 'Q', 00H, 'U', 00H, 'E', 00H, 'R', 00H, 'Y', 00H
	DB	'_', 00H, 'P', 00H, 'O', 00H, 'I', 00H, 'N', 00H, 'T', 00H, 'S'
	DB	00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DI@BMKMBCGO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAL?$AAI?$AAN?$AAK?$AA_?$AAD?$AAE?$AAL?$AAE?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DI@BMKMBCGO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAL?$AAI?$AAN?$AAK?$AA_?$AAD?$AAE?$AAL?$AAE?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'D', 00H, 'E', 00H, 'V'
	DB	00H, '_', 00H, 'L', 00H, 'I', 00H, 'N', 00H, 'K', 00H, '_', 00H
	DB	'D', 00H, 'E', 00H, 'L', 00H, 'E', 00H, 'T', 00H, 'E', 00H, 'D'
	DB	00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DI@HGGIOGFM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAL?$AAI?$AAN?$AAK?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DI@HGGIOGFM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAL?$AAI?$AAN?$AAK?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'D', 00H, 'E', 00H, 'V'
	DB	00H, '_', 00H, 'L', 00H, 'I', 00H, 'N', 00H, 'K', 00H, '_', 00H
	DB	'C', 00H, 'R', 00H, 'E', 00H, 'A', 00H, 'T', 00H, 'E', 00H, 'D'
	DB	00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CI@DJEMJCBH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAO?$AAN?$AAL?$AAI?$AAN?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CI@DJEMJCBH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAO?$AAN?$AAL?$AAI?$AAN?$AAE?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'V', 00H
	DB	'O', 00H, 'L', 00H, 'U', 00H, 'M', 00H, 'E', 00H, '_', 00H, 'O'
	DB	00H, 'N', 00H, 'L', 00H, 'I', 00H, 'N', 00H, 'E', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DO@OGNDJPNH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAU?$AAN?$AAI?$AAQ?$AAU?$AAE?$AA_?$AAI?$AAD?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DO@OGNDJPNH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAU?$AAN?$AAI?$AAQ?$AAU?$AAE?$AA_?$AAI?$AAD?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'D', 00H, 'E', 00H, 'V'
	DB	00H, '_', 00H, 'Q', 00H, 'U', 00H, 'E', 00H, 'R', 00H, 'Y', 00H
	DB	'_', 00H, 'U', 00H, 'N', 00H, 'I', 00H, 'Q', 00H, 'U', 00H, 'E'
	DB	00H, '_', 00H, 'I', 00H, 'D', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1FC@MNMCPAAJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAS?$AAU?$AAG?$AAG?$AAE?$AAS?$AAT?$AAE?$AAD?$AA_?$AAL@FNODOBFM@
text$s	SEGMENT
??_C@_1FC@MNMCPAAJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAS?$AAU?$AAG?$AAG?$AAE?$AAS?$AAT?$AAE?$AAD?$AA_?$AAL@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'D', 00H, 'E', 00H, 'V'
	DB	00H, '_', 00H, 'Q', 00H, 'U', 00H, 'E', 00H, 'R', 00H, 'Y', 00H
	DB	'_', 00H, 'S', 00H, 'U', 00H, 'G', 00H, 'G', 00H, 'E', 00H, 'S'
	DB	00H, 'T', 00H, 'E', 00H, 'D', 00H, '_', 00H, 'L', 00H, 'I', 00H
	DB	'N', 00H, 'K', 00H, '_', 00H, 'N', 00H, 'A', 00H, 'M', 00H, 'E'
	DB	00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EC@HFOIOEOM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAN?$AAA?$AAM?$AAE@FNODOBFM@
text$s	SEGMENT
??_C@_1EC@HFOIOEOM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAN?$AAA?$AAM?$AAE@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'D', 00H, 'E', 00H, 'V'
	DB	00H, '_', 00H, 'Q', 00H, 'U', 00H, 'E', 00H, 'R', 00H, 'Y', 00H
	DB	'_', 00H, 'D', 00H, 'E', 00H, 'V', 00H, 'I', 00H, 'C', 00H, 'E'
	DB	00H, '_', 00H, 'N', 00H, 'A', 00H, 'M', 00H, 'E', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EC@NPAFBAMN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA_?$AAE?$AAX@FNODOBFM@
text$s	SEGMENT
??_C@_1EC@NPAFBAMN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA_?$AAE?$AAX@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T'
	DB	00H, '_', 00H, 'D', 00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H
	DB	'_', 00H, 'G', 00H, 'E', 00H, 'O', 00H, 'M', 00H, 'E', 00H, 'T'
	DB	00H, 'R', 00H, 'Y', 00H, '_', 00H, 'E', 00H, 'X', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DM@KPKDNCHM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DM@KPKDNCHM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T'
	DB	00H, '_', 00H, 'D', 00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H
	DB	'_', 00H, 'G', 00H, 'E', 00H, 'O', 00H, 'M', 00H, 'E', 00H, 'T'
	DB	00H, 'R', 00H, 'Y', 00H, 00H, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EK@FDCJEFAP@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAE?$AAX?$AAT@FNODOBFM@
text$s	SEGMENT
??_C@_1EK@FDCJEFAP@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAE?$AAX?$AAT@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'V', 00H
	DB	'O', 00H, 'L', 00H, 'U', 00H, 'M', 00H, 'E', 00H, '_', 00H, 'G'
	DB	00H, 'E', 00H, 'T', 00H, '_', 00H, 'V', 00H, 'O', 00H, 'L', 00H
	DB	'U', 00H, 'M', 00H, 'E', 00H, '_', 00H, 'D', 00H, 'I', 00H, 'S'
	DB	00H, 'K', 00H, '_', 00H, 'E', 00H, 'X', 00H, 'T', 00H, 'E', 00H
	DB	'N', 00H, 'T', 00H, 'S', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EC@FOOPNHFI@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAW?$AAR?$AAI?$AAT?$AAE?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAS?$AAE?$AAC?$AAT?$AAO?$AAR@FNODOBFM@
text$s	SEGMENT
??_C@_1EC@FOOPNHFI@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAW?$AAR?$AAI?$AAT?$AAE?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAS?$AAE?$AAC?$AAT?$AAO?$AAR@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'W', 00H, 'R', 00H, 'I', 00H, 'T', 00H, 'E'
	DB	00H, '_', 00H, 'B', 00H, 'O', 00H, 'O', 00H, 'T', 00H, '_', 00H
	DB	'D', 00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H, '_', 00H, 'S'
	DB	00H, 'E', 00H, 'C', 00H, 'T', 00H, 'O', 00H, 'R', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DK@BNKDMLAM@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_?$AAP?$AAA?$AAS?$AAS?$AAW?$AAO?$AAR?$AAD?$AA_?$AAC?$AAA?$AAC?$AAH?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DK@BNKDMLAM@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_?$AAP?$AAA?$AAS?$AAS?$AAW?$AAO?$AAR?$AAD?$AA_?$AAC?$AAA?$AAC?$AAH?$AAE?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'W', 00H, 'I', 00H, 'P', 00H, 'E', 00H, '_'
	DB	00H, 'P', 00H, 'A', 00H, 'S', 00H, 'S', 00H, 'W', 00H, 'O', 00H
	DB	'R', 00H, 'D', 00H, '_', 00H, 'C', 00H, 'A', 00H, 'C', 00H, 'H'
	DB	00H, 'E', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EC@FGBEDIDI@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAA?$AAR?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE@FNODOBFM@
text$s	SEGMENT
??_C@_1EC@FGBEDIDI@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAA?$AAR?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'S', 00H, 'T', 00H, 'A', 00H, 'R', 00H, 'T'
	DB	00H, '_', 00H, 'D', 00H, 'E', 00H, 'C', 00H, 'O', 00H, 'Y', 00H
	DB	'_', 00H, 'S', 00H, 'Y', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M'
	DB	00H, '_', 00H, 'W', 00H, 'I', 00H, 'P', 00H, 'E', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1FE@EBAIHKDI@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAF?$AAA?$AAV?$AAO?$AAR?$AAI?$AAT?$AAE?$AA_?$AAV?$AAO?$AAL@FNODOBFM@
text$s	SEGMENT
??_C@_1FE@EBAIHKDI@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAF?$AAA?$AAV?$AAO?$AAR?$AAI?$AAT?$AAE?$AA_?$AAV?$AAO?$AAL@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'S', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'S'
	DB	00H, 'Y', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '_', 00H
	DB	'F', 00H, 'A', 00H, 'V', 00H, 'O', 00H, 'R', 00H, 'I', 00H, 'T'
	DB	00H, 'E', 00H, '_', 00H, 'V', 00H, 'O', 00H, 'L', 00H, 'U', 00H
	DB	'M', 00H, 'E', 00H, '_', 00H, 'D', 00H, 'I', 00H, 'R', 00H, 'T'
	DB	00H, 'Y', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DM@JFJLBNLP@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAR?$AAE?$AAR?$AAE?$AAA?$AAD?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DM@JFJLBNLP@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAR?$AAE?$AAR?$AAE?$AAA?$AAD?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'R', 00H, 'E', 00H, 'A'
	DB	00H, 'D', 00H, '_', 00H, 'D', 00H, 'R', 00H, 'I', 00H, 'V', 00H
	DB	'E', 00H, 'R', 00H, '_', 00H, 'C', 00H, 'O', 00H, 'N', 00H, 'F'
	DB	00H, 'I', 00H, 'G', 00H, 00H, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EG@GGODONFK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAR?$AAE?$AAO?$AAP?$AAE?$AAN?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAH?$AAE?$AAA?$AAD@FNODOBFM@
text$s	SEGMENT
??_C@_1EG@GGODONFK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAR?$AAE?$AAO?$AAP?$AAE?$AAN?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAH?$AAE?$AAA?$AAD@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'O', 00H, 'P', 00H, 'E'
	DB	00H, 'N', 00H, '_', 00H, 'B', 00H, 'O', 00H, 'O', 00H, 'T', 00H
	DB	'_', 00H, 'V', 00H, 'O', 00H, 'L', 00H, 'U', 00H, 'M', 00H, 'E'
	DB	00H, '_', 00H, 'H', 00H, 'E', 00H, 'A', 00H, 'D', 00H, 'E', 00H
	DB	'R', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DO@BKHLMLHN@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAP?$AAR?$AAO?$AAB?$AAE?$AA_?$AAR?$AAE?$AAA?$AAL?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DO@BKHLMLHN@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAP?$AAR?$AAO?$AAB?$AAE?$AA_?$AAR?$AAE?$AAA?$AAL?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'P', 00H, 'R', 00H, 'O', 00H, 'B', 00H, 'E'
	DB	00H, '_', 00H, 'R', 00H, 'E', 00H, 'A', 00H, 'L', 00H, '_', 00H
	DB	'D', 00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H, '_', 00H, 'S'
	DB	00H, 'I', 00H, 'Z', 00H, 'E', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CG@HPPKKEKP@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAO?$AAP?$AAE?$AAN?$AA_?$AAT?$AAE?$AAS?$AAT?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CG@HPPKKEKP@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAO?$AAP?$AAE?$AAN?$AA_?$AAT?$AAE?$AAS?$AAT?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'O', 00H, 'P', 00H, 'E', 00H, 'N', 00H, '_'
	DB	00H, 'T', 00H, 'E', 00H, 'S', 00H, 'T', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CM@HJCGFKAD@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CM@HJCGFKAD@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'M', 00H, 'O', 00H, 'U', 00H, 'N', 00H, 'T'
	DB	00H, '_', 00H, 'V', 00H, 'O', 00H, 'L', 00H, 'U', 00H, 'M', 00H
	DB	'E', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EE@HPDOLCKH@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAH?$AAI?$AAD?$AAD?$AAE?$AAN?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAR?$AAU?$AAN?$AAN?$AAI?$AAN@FNODOBFM@
text$s	SEGMENT
??_C@_1EE@HPDOLCKH@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAH?$AAI?$AAD?$AAD?$AAE?$AAN?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAR?$AAU?$AAN?$AAN?$AAI?$AAN@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'H', 00H, 'I'
	DB	00H, 'D', 00H, 'D', 00H, 'E', 00H, 'N', 00H, '_', 00H, 'S', 00H
	DB	'Y', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '_', 00H, 'R'
	DB	00H, 'U', 00H, 'N', 00H, 'N', 00H, 'I', 00H, 'N', 00H, 'G', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EG@HPLFHOOO@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAU?$AAN?$AAL?$AAO?$AAA?$AAD?$AA_?$AAD?$AAI?$AAS?$AAA?$AAB?$AAL@FNODOBFM@
text$s	SEGMENT
??_C@_1EG@HPLFHOOO@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAU?$AAN?$AAL?$AAO?$AAA?$AAD?$AA_?$AAD?$AAI?$AAS?$AAA?$AAB?$AAL@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'D', 00H, 'R'
	DB	00H, 'I', 00H, 'V', 00H, 'E', 00H, 'R', 00H, '_', 00H, 'U', 00H
	DB	'N', 00H, 'L', 00H, 'O', 00H, 'A', 00H, 'D', 00H, '_', 00H, 'D'
	DB	00H, 'I', 00H, 'S', 00H, 'A', 00H, 'B', 00H, 'L', 00H, 'E', 00H
	DB	'D', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DO@ICDMEENM@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAA?$AAN?$AAY?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DO@ICDMEENM@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAA?$AAN?$AAY?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'A', 00H, 'N'
	DB	00H, 'Y', 00H, '_', 00H, 'V', 00H, 'O', 00H, 'L', 00H, 'U', 00H
	DB	'M', 00H, 'E', 00H, '_', 00H, 'M', 00H, 'O', 00H, 'U', 00H, 'N'
	DB	00H, 'T', 00H, 'E', 00H, 'D', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DE@JNPINMHP@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAS?$AA_?$AAW?$AAR?$AAI?$AAT?$AAA?$AAB?$AAL?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DE@JNPINMHP@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAS?$AA_?$AAW?$AAR?$AAI?$AAT?$AAA?$AAB?$AAL?$AAE?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'D', 00H, 'I', 00H, 'S', 00H, 'K', 00H, '_'
	DB	00H, 'I', 00H, 'S', 00H, '_', 00H, 'W', 00H, 'R', 00H, 'I', 00H
	DB	'T', 00H, 'A', 00H, 'B', 00H, 'L', 00H, 'E', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DG@LBDEDPBA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAW?$AAA?$AAR?$AAN?$AAI?$AAN?$AAG?$AA_?$AAF?$AAL?$AAA?$AAG?$AAS?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DG@LBDEDPBA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAW?$AAA?$AAR?$AAN?$AAI?$AAN?$AAG?$AA_?$AAF?$AAL?$AAA?$AAG?$AAS?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'W'
	DB	00H, 'A', 00H, 'R', 00H, 'N', 00H, 'I', 00H, 'N', 00H, 'G', 00H
	DB	'_', 00H, 'F', 00H, 'L', 00H, 'A', 00H, 'G', 00H, 'S', 00H, 00H
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DO@DMIHGGIB@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAP?$AAR?$AAO?$AAP?$AAE?$AAR?$AAT?$AAI?$AAE?$AAS?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DO@DMIHGGIB@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAP?$AAR?$AAO?$AAP?$AAE?$AAR?$AAT?$AAI?$AAE?$AAS?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'V'
	DB	00H, 'O', 00H, 'L', 00H, 'U', 00H, 'M', 00H, 'E', 00H, '_', 00H
	DB	'P', 00H, 'R', 00H, 'O', 00H, 'P', 00H, 'E', 00H, 'R', 00H, 'T'
	DB	00H, 'I', 00H, 'E', 00H, 'S', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EM@GFDNBFC@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAD?$AAU?$AAM?$AAP?$AA_?$AAC@FNODOBFM@
text$s	SEGMENT
??_C@_1EM@GFDNBFC@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAD?$AAU?$AAM?$AAP?$AA_?$AAC@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'S'
	DB	00H, 'Y', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '_', 00H
	DB	'D', 00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H, '_', 00H, 'D'
	DB	00H, 'U', 00H, 'M', 00H, 'P', 00H, '_', 00H, 'C', 00H, 'O', 00H
	DB	'N', 00H, 'F', 00H, 'I', 00H, 'G', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DM@GFCMCNDC@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAR?$AAE?$AAS?$AAO?$AAL?$AAV?$AAE?$AAD?$AA_?$AAS?$AAY?$AAM?$AAL?$AAI?$AAN?$AAK?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DM@GFCMCNDC@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAR?$AAE?$AAS?$AAO?$AAL?$AAV?$AAE?$AAD?$AA_?$AAS?$AAY?$AAM?$AAL?$AAI?$AAN?$AAK?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'S', 00H, 'O', 00H, 'L', 00H, 'V', 00H, 'E', 00H
	DB	'D', 00H, '_', 00H, 'S', 00H, 'Y', 00H, 'M', 00H, 'L', 00H, 'I'
	DB	00H, 'N', 00H, 'K', 00H, 00H, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EE@NMKCMMBM@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAP?$AAO?$AAR?$AAT?$AAA?$AAB?$AAL?$AAE?$AA_?$AAM?$AAO?$AAD?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU@FNODOBFM@
text$s	SEGMENT
??_C@_1EE@NMKCMMBM@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAP?$AAO?$AAR?$AAT?$AAA?$AAB?$AAL?$AAE?$AA_?$AAM?$AAO?$AAD?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'S', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'P'
	DB	00H, 'O', 00H, 'R', 00H, 'T', 00H, 'A', 00H, 'B', 00H, 'L', 00H
	DB	'E', 00H, '_', 00H, 'M', 00H, 'O', 00H, 'D', 00H, 'E', 00H, '_'
	DB	00H, 'S', 00H, 'T', 00H, 'A', 00H, 'T', 00H, 'U', 00H, 'S', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EE@IPNJBDEG@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAO?$AAR?$AAT?$AAA?$AAB?$AAL?$AAE?$AA_?$AAM?$AAO?$AAD?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU@FNODOBFM@
text$s	SEGMENT
??_C@_1EE@IPNJBDEG@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAO?$AAR?$AAT?$AAA?$AAB?$AAL?$AAE?$AA_?$AAM?$AAO?$AAD?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'P'
	DB	00H, 'O', 00H, 'R', 00H, 'T', 00H, 'A', 00H, 'B', 00H, 'L', 00H
	DB	'E', 00H, '_', 00H, 'M', 00H, 'O', 00H, 'D', 00H, 'E', 00H, '_'
	DB	00H, 'S', 00H, 'T', 00H, 'A', 00H, 'T', 00H, 'U', 00H, 'S', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EC@FADHDJPK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG@FNODOBFM@
text$s	SEGMENT
??_C@_1EC@FADHDJPK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'S'
	DB	00H, 'Y', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '_', 00H
	DB	'D', 00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H, '_', 00H, 'C'
	DB	00H, 'O', 00H, 'N', 00H, 'F', 00H, 'I', 00H, 'G', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EG@LLJHBPJF@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAS?$AAS?$AAW?$AAO?$AAR?$AAD?$AA_?$AAC?$AAA?$AAC?$AAH?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT@FNODOBFM@
text$s	SEGMENT
??_C@_1EG@LLJHBPJF@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAS?$AAS?$AAW?$AAO?$AAR?$AAD?$AA_?$AAC?$AAA?$AAC?$AAH?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'P'
	DB	00H, 'A', 00H, 'S', 00H, 'S', 00H, 'W', 00H, 'O', 00H, 'R', 00H
	DB	'D', 00H, '_', 00H, 'C', 00H, 'A', 00H, 'C', 00H, 'H', 00H, 'E'
	DB	00H, '_', 00H, 'S', 00H, 'T', 00H, 'A', 00H, 'T', 00H, 'U', 00H
	DB	'S', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DK@KJKOFIJA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAE?$AAD?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AAS?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DK@KJKOFIJA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAE?$AAD?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AAS?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'M'
	DB	00H, 'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'E', 00H, 'D', 00H
	DB	'_', 00H, 'V', 00H, 'O', 00H, 'L', 00H, 'U', 00H, 'M', 00H, 'E'
	DB	00H, 'S', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DI@ODPPPDDO@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DI@ODPPPDDO@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'D'
	DB	00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H, 'R', 00H, '_', 00H
	DB	'V', 00H, 'E', 00H, 'R', 00H, 'S', 00H, 'I', 00H, 'O', 00H, 'N'
	DB	00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EE@HEELFNND@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF@FNODOBFM@
text$s	SEGMENT
??_C@_1EE@HEELFNND@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'D'
	DB	00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H, '_', 00H, 'P', 00H
	DB	'A', 00H, 'R', 00H, 'T', 00H, 'I', 00H, 'T', 00H, 'I', 00H, 'O'
	DB	00H, 'N', 00H, '_', 00H, 'I', 00H, 'N', 00H, 'F', 00H, 'O', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DI@LAIAIOML@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DI@LAIAIOML@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'D'
	DB	00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H, '_', 00H, 'G', 00H
	DB	'E', 00H, 'O', 00H, 'M', 00H, 'E', 00H, 'T', 00H, 'R', 00H, 'Y'
	DB	00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DK@DFEJGDBK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAR?$AAE?$AAF?$AAC?$AAO?$AAU?$AAN?$AAT?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DK@DFEJGDBK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAR?$AAE?$AAF?$AAC?$AAO?$AAU?$AAN?$AAT?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'D'
	DB	00H, 'E', 00H, 'V', 00H, 'I', 00H, 'C', 00H, 'E', 00H, '_', 00H
	DB	'R', 00H, 'E', 00H, 'F', 00H, 'C', 00H, 'O', 00H, 'U', 00H, 'N'
	DB	00H, 'T', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EM@LMAMOKGA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_?$AAS@FNODOBFM@
text$s	SEGMENT
??_C@_1EM@LMAMOKGA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_?$AAS@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'D'
	DB	00H, 'E', 00H, 'C', 00H, 'O', 00H, 'Y', 00H, '_', 00H, 'S', 00H
	DB	'Y', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '_', 00H, 'W'
	DB	00H, 'I', 00H, 'P', 00H, 'E', 00H, '_', 00H, 'S', 00H, 'T', 00H
	DB	'A', 00H, 'T', 00H, 'U', 00H, 'S', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EM@OAEBJACE@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_?$AAR@FNODOBFM@
text$s	SEGMENT
??_C@_1EM@OAEBJACE@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_?$AAR@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'D'
	DB	00H, 'E', 00H, 'C', 00H, 'O', 00H, 'Y', 00H, '_', 00H, 'S', 00H
	DB	'Y', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '_', 00H, 'W'
	DB	00H, 'I', 00H, 'P', 00H, 'E', 00H, '_', 00H, 'R', 00H, 'E', 00H
	DB	'S', 00H, 'U', 00H, 'L', 00H, 'T', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EC@OPCJHCIG@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAL?$AAO?$AAA?$AAD?$AAE?$AAR?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN@FNODOBFM@
text$s	SEGMENT
??_C@_1EC@OPCJHCIG@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAL?$AAO?$AAA?$AAD?$AAE?$AAR?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'B'
	DB	00H, 'O', 00H, 'O', 00H, 'T', 00H, '_', 00H, 'L', 00H, 'O', 00H
	DB	'A', 00H, 'D', 00H, 'E', 00H, 'R', 00H, '_', 00H, 'V', 00H, 'E'
	DB	00H, 'R', 00H, 'S', 00H, 'I', 00H, 'O', 00H, 'N', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EI@GAKLFLAF@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAT?$AAA@FNODOBFM@
text$s	SEGMENT
??_C@_1EI@GAKLFLAF@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAT?$AAA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'B'
	DB	00H, 'O', 00H, 'O', 00H, 'T', 00H, '_', 00H, 'E', 00H, 'N', 00H
	DB	'C', 00H, 'R', 00H, 'Y', 00H, 'P', 00H, 'T', 00H, 'I', 00H, 'O'
	DB	00H, 'N', 00H, '_', 00H, 'S', 00H, 'T', 00H, 'A', 00H, 'T', 00H
	DB	'U', 00H, 'S', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1FE@OJNNCONL@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAE?$AAT@FNODOBFM@
text$s	SEGMENT
??_C@_1FE@OJNNCONL@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAE?$AAT@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'B'
	DB	00H, 'O', 00H, 'O', 00H, 'T', 00H, '_', 00H, 'E', 00H, 'N', 00H
	DB	'C', 00H, 'R', 00H, 'Y', 00H, 'P', 00H, 'T', 00H, 'I', 00H, 'O'
	DB	00H, 'N', 00H, '_', 00H, 'S', 00H, 'E', 00H, 'T', 00H, 'U', 00H
	DB	'P', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'S', 00H, 'U', 00H, 'L'
	DB	00H, 'T', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1FI@CDJGLMPJ@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA?$AAL?$AAG@FNODOBFM@
text$s	SEGMENT
??_C@_1FI@CDJGLMPJ@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA?$AAL?$AAG@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'B'
	DB	00H, 'O', 00H, 'O', 00H, 'T', 00H, '_', 00H, 'E', 00H, 'N', 00H
	DB	'C', 00H, 'R', 00H, 'Y', 00H, 'P', 00H, 'T', 00H, 'I', 00H, 'O'
	DB	00H, 'N', 00H, '_', 00H, 'A', 00H, 'L', 00H, 'G', 00H, 'O', 00H
	DB	'R', 00H, 'I', 00H, 'T', 00H, 'H', 00H, 'M', 00H, '_', 00H, 'N'
	DB	00H, 'A', 00H, 'M', 00H, 'E', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1FE@BEJBLKBA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAP@FNODOBFM@
text$s	SEGMENT
??_C@_1FE@BEJBLKBA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAP@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'B'
	DB	00H, 'O', 00H, 'O', 00H, 'T', 00H, '_', 00H, 'D', 00H, 'R', 00H
	DB	'I', 00H, 'V', 00H, 'E', 00H, '_', 00H, 'V', 00H, 'O', 00H, 'L'
	DB	00H, 'U', 00H, 'M', 00H, 'E', 00H, '_', 00H, 'P', 00H, 'R', 00H
	DB	'O', 00H, 'P', 00H, 'E', 00H, 'R', 00H, 'T', 00H, 'I', 00H, 'E'
	DB	00H, 'S', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DC@CLEBJPLG@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DC@CLEBJPLG@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'D', 00H, 'I', 00H, 'S', 00H, 'M', 00H, 'O'
	DB	00H, 'U', 00H, 'N', 00H, 'T', 00H, '_', 00H, 'V', 00H, 'O', 00H
	DB	'L', 00H, 'U', 00H, 'M', 00H, 'E', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DM@OLONGNGL@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAA?$AAL?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AAS?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DM@OLONGNGL@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAA?$AAL?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AAS?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'D', 00H, 'I', 00H, 'S', 00H, 'M', 00H, 'O'
	DB	00H, 'U', 00H, 'N', 00H, 'T', 00H, '_', 00H, 'A', 00H, 'L', 00H
	DB	'L', 00H, '_', 00H, 'V', 00H, 'O', 00H, 'L', 00H, 'U', 00H, 'M'
	DB	00H, 'E', 00H, 'S', 00H, 00H, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DO@JPMJPMCJ@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAE?$AAT?$AAU?$AAP?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DO@JPMJPMCJ@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAE?$AAT?$AAU?$AAP?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'B', 00H, 'O', 00H, 'O', 00H, 'T', 00H, '_'
	DB	00H, 'E', 00H, 'N', 00H, 'C', 00H, 'R', 00H, 'Y', 00H, 'P', 00H
	DB	'T', 00H, 'I', 00H, 'O', 00H, 'N', 00H, '_', 00H, 'S', 00H, 'E'
	DB	00H, 'T', 00H, 'U', 00H, 'P', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EC@HMNCILMA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAA?$AAB?$AAO?$AAR?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE@FNODOBFM@
text$s	SEGMENT
??_C@_1EC@HMNCILMA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAA?$AAB?$AAO?$AAR?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'A', 00H, 'B', 00H, 'O', 00H, 'R', 00H, 'T'
	DB	00H, '_', 00H, 'D', 00H, 'E', 00H, 'C', 00H, 'O', 00H, 'Y', 00H
	DB	'_', 00H, 'S', 00H, 'Y', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M'
	DB	00H, '_', 00H, 'W', 00H, 'I', 00H, 'P', 00H, 'E', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EK@CMLLEBIK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAA?$AAB?$AAO?$AAR?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS@FNODOBFM@
text$s	SEGMENT
??_C@_1EK@CMLLEBIK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAA?$AAB?$AAO?$AAR?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'A', 00H, 'B', 00H, 'O', 00H, 'R', 00H, 'T'
	DB	00H, '_', 00H, 'B', 00H, 'O', 00H, 'O', 00H, 'T', 00H, '_', 00H
	DB	'E', 00H, 'N', 00H, 'C', 00H, 'R', 00H, 'Y', 00H, 'P', 00H, 'T'
	DB	00H, 'I', 00H, 'O', 00H, 'N', 00H, '_', 00H, 'S', 00H, 'E', 00H
	DB	'T', 00H, 'U', 00H, 'P', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _TCTranslateCode@4
_TEXT	SEGMENT
tv64 = -4						; size = 4
_ulCode$ = 8						; size = 4
_TCTranslateCode@4 PROC					; COMDAT

; 1897 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 1898 : 	switch (ulCode)

  00006	8b 45 08	 mov	 eax, DWORD PTR _ulCode$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR tv64[ebp], eax
  0000c	81 7d fc 00 00
	56 00		 cmp	 DWORD PTR tv64[ebp], 5636096 ; 00560000H
  00013	77 37		 ja	 SHORT $LN150@TCTranslat
  00015	81 7d fc 00 00
	56 00		 cmp	 DWORD PTR tv64[ebp], 5636096 ; 00560000H
  0001c	0f 84 ab 01 00
	00		 je	 $LN107@TCTranslat
  00022	8b 4d fc	 mov	 ecx, DWORD PTR tv64[ebp]
  00025	81 e9 04 20 22
	00		 sub	 ecx, 2236420		; 00222004H
  0002b	89 4d fc	 mov	 DWORD PTR tv64[ebp], ecx
  0002e	81 7d fc 94 00
	00 00		 cmp	 DWORD PTR tv64[ebp], 148 ; 00000094H
  00035	0f 87 9c 01 00
	00		 ja	 $LN146@TCTranslat
  0003b	8b 55 fc	 mov	 edx, DWORD PTR tv64[ebp]
  0003e	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN151@TCTranslat[edx]
  00045	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN152@TCTranslat[eax*4]
$LN150@TCTranslat:
  0004c	e9 86 01 00 00	 jmp	 $LN146@TCTranslat
$LN145@TCTranslat:

; 1899 : 	{
; 1900 : #define TC_CASE_RET_NAME(CODE) case CODE : return L###CODE
; 1901 : 
; 1902 : 		TC_CASE_RET_NAME (TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP);

  00051	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1EK@CMLLEBIK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAA?$AAB?$AAO?$AAR?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS@FNODOBFM@
  00056	e9 2b 06 00 00	 jmp	 $LN148@TCTranslat
$LN144@TCTranslat:

; 1903 : 		TC_CASE_RET_NAME (TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE);

  0005b	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1EC@HMNCILMA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAA?$AAB?$AAO?$AAR?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE@FNODOBFM@
  00060	e9 21 06 00 00	 jmp	 $LN148@TCTranslat
$LN143@TCTranslat:

; 1904 : 		TC_CASE_RET_NAME (TC_IOCTL_BOOT_ENCRYPTION_SETUP);

  00065	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DO@JPMJPMCJ@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAE?$AAT?$AAU?$AAP?$AA?$AA@FNODOBFM@
  0006a	e9 17 06 00 00	 jmp	 $LN148@TCTranslat
$LN142@TCTranslat:

; 1905 : 		TC_CASE_RET_NAME (TC_IOCTL_DISMOUNT_ALL_VOLUMES);

  0006f	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DM@OLONGNGL@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAA?$AAL?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AAS?$AA?$AA@FNODOBFM@
  00074	e9 0d 06 00 00	 jmp	 $LN148@TCTranslat
$LN141@TCTranslat:

; 1906 : 		TC_CASE_RET_NAME (TC_IOCTL_DISMOUNT_VOLUME);

  00079	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DC@CLEBJPLG@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA?$AA@FNODOBFM@
  0007e	e9 03 06 00 00	 jmp	 $LN148@TCTranslat
$LN140@TCTranslat:

; 1907 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES);

  00083	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1FE@BEJBLKBA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAP@FNODOBFM@
  00088	e9 f9 05 00 00	 jmp	 $LN148@TCTranslat
$LN139@TCTranslat:

; 1908 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME);

  0008d	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1FI@CDJGLMPJ@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA?$AAL?$AAG@FNODOBFM@
  00092	e9 ef 05 00 00	 jmp	 $LN148@TCTranslat
$LN138@TCTranslat:

; 1909 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT);

  00097	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1FE@OJNNCONL@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAE?$AAT@FNODOBFM@
  0009c	e9 e5 05 00 00	 jmp	 $LN148@TCTranslat
$LN137@TCTranslat:

; 1910 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS);

  000a1	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1EI@GAKLFLAF@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAT?$AAA@FNODOBFM@
  000a6	e9 db 05 00 00	 jmp	 $LN148@TCTranslat
$LN136@TCTranslat:

; 1911 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_BOOT_LOADER_VERSION);

  000ab	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1EC@OPCJHCIG@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAL?$AAO?$AAA?$AAD?$AAE?$AAR?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN@FNODOBFM@
  000b0	e9 d1 05 00 00	 jmp	 $LN148@TCTranslat
$LN135@TCTranslat:

; 1912 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT);

  000b5	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1EM@OAEBJACE@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_?$AAR@FNODOBFM@
  000ba	e9 c7 05 00 00	 jmp	 $LN148@TCTranslat
$LN134@TCTranslat:

; 1913 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS);

  000bf	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1EM@LMAMOKGA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_?$AAS@FNODOBFM@
  000c4	e9 bd 05 00 00	 jmp	 $LN148@TCTranslat
$LN133@TCTranslat:

; 1914 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_DEVICE_REFCOUNT);

  000c9	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DK@DFEJGDBK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAR?$AAE?$AAF?$AAC?$AAO?$AAU?$AAN?$AAT?$AA?$AA@FNODOBFM@
  000ce	e9 b3 05 00 00	 jmp	 $LN148@TCTranslat
$LN132@TCTranslat:

; 1915 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_DRIVE_GEOMETRY);

  000d3	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DI@LAIAIOML@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA?$AA@FNODOBFM@
  000d8	e9 a9 05 00 00	 jmp	 $LN148@TCTranslat
$LN131@TCTranslat:

; 1916 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_DRIVE_PARTITION_INFO);

  000dd	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1EE@HEELFNND@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF@FNODOBFM@
  000e2	e9 9f 05 00 00	 jmp	 $LN148@TCTranslat
$LN130@TCTranslat:

; 1917 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_DRIVER_VERSION);

  000e7	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DI@ODPPPDDO@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN?$AA?$AA@FNODOBFM@
  000ec	e9 95 05 00 00	 jmp	 $LN148@TCTranslat
$LN129@TCTranslat:

; 1918 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_MOUNTED_VOLUMES);

  000f1	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DK@KJKOFIJA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAE?$AAD?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AAS?$AA?$AA@FNODOBFM@
  000f6	e9 8b 05 00 00	 jmp	 $LN148@TCTranslat
$LN128@TCTranslat:

; 1919 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_PASSWORD_CACHE_STATUS);

  000fb	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1EG@LLJHBPJF@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAS?$AAS?$AAW?$AAO?$AAR?$AAD?$AA_?$AAC?$AAA?$AAC?$AAH?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT@FNODOBFM@
  00100	e9 81 05 00 00	 jmp	 $LN148@TCTranslat
$LN127@TCTranslat:

; 1920 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_SYSTEM_DRIVE_CONFIG);

  00105	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1EC@FADHDJPK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG@FNODOBFM@
  0010a	e9 77 05 00 00	 jmp	 $LN148@TCTranslat
$LN126@TCTranslat:

; 1921 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_PORTABLE_MODE_STATUS);

  0010f	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1EE@IPNJBDEG@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAO?$AAR?$AAT?$AAA?$AAB?$AAL?$AAE?$AA_?$AAM?$AAO?$AAD?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU@FNODOBFM@
  00114	e9 6d 05 00 00	 jmp	 $LN148@TCTranslat
$LN125@TCTranslat:

; 1922 : 		TC_CASE_RET_NAME (TC_IOCTL_SET_PORTABLE_MODE_STATUS);

  00119	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1EE@NMKCMMBM@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAP?$AAO?$AAR?$AAT?$AAA?$AAB?$AAL?$AAE?$AA_?$AAM?$AAO?$AAD?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU@FNODOBFM@
  0011e	e9 63 05 00 00	 jmp	 $LN148@TCTranslat
$LN124@TCTranslat:

; 1923 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_RESOLVED_SYMLINK);

  00123	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DM@GFCMCNDC@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAR?$AAE?$AAS?$AAO?$AAL?$AAV?$AAE?$AAD?$AA_?$AAS?$AAY?$AAM?$AAL?$AAI?$AAN?$AAK?$AA?$AA@FNODOBFM@
  00128	e9 59 05 00 00	 jmp	 $LN148@TCTranslat
$LN123@TCTranslat:

; 1924 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG);

  0012d	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1EM@GFDNBFC@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAD?$AAU?$AAM?$AAP?$AA_?$AAC@FNODOBFM@
  00132	e9 4f 05 00 00	 jmp	 $LN148@TCTranslat
$LN122@TCTranslat:

; 1925 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_VOLUME_PROPERTIES);

  00137	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DO@DMIHGGIB@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAP?$AAR?$AAO?$AAP?$AAE?$AAR?$AAT?$AAI?$AAE?$AAS?$AA?$AA@FNODOBFM@
  0013c	e9 45 05 00 00	 jmp	 $LN148@TCTranslat
$LN121@TCTranslat:

; 1926 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_WARNING_FLAGS);

  00141	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DG@LBDEDPBA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAW?$AAA?$AAR?$AAN?$AAI?$AAN?$AAG?$AA_?$AAF?$AAL?$AAA?$AAG?$AAS?$AA?$AA@FNODOBFM@
  00146	e9 3b 05 00 00	 jmp	 $LN148@TCTranslat
$LN120@TCTranslat:

; 1927 : 		TC_CASE_RET_NAME (TC_IOCTL_DISK_IS_WRITABLE);

  0014b	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DE@JNPINMHP@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAS?$AA_?$AAW?$AAR?$AAI?$AAT?$AAA?$AAB?$AAL?$AAE?$AA?$AA@FNODOBFM@
  00150	e9 31 05 00 00	 jmp	 $LN148@TCTranslat
$LN119@TCTranslat:

; 1928 : 		TC_CASE_RET_NAME (TC_IOCTL_IS_ANY_VOLUME_MOUNTED);

  00155	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DO@ICDMEENM@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAA?$AAN?$AAY?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@
  0015a	e9 27 05 00 00	 jmp	 $LN148@TCTranslat
$LN118@TCTranslat:

; 1929 : 		TC_CASE_RET_NAME (TC_IOCTL_IS_DRIVER_UNLOAD_DISABLED);

  0015f	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1EG@HPLFHOOO@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAU?$AAN?$AAL?$AAO?$AAA?$AAD?$AA_?$AAD?$AAI?$AAS?$AAA?$AAB?$AAL@FNODOBFM@
  00164	e9 1d 05 00 00	 jmp	 $LN148@TCTranslat
$LN117@TCTranslat:

; 1930 : 		TC_CASE_RET_NAME (TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING);

  00169	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1EE@HPDOLCKH@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAH?$AAI?$AAD?$AAD?$AAE?$AAN?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAR?$AAU?$AAN?$AAN?$AAI?$AAN@FNODOBFM@
  0016e	e9 13 05 00 00	 jmp	 $LN148@TCTranslat
$LN116@TCTranslat:

; 1931 : 		TC_CASE_RET_NAME (TC_IOCTL_MOUNT_VOLUME);

  00173	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1CM@HJCGFKAD@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA?$AA@FNODOBFM@
  00178	e9 09 05 00 00	 jmp	 $LN148@TCTranslat
$LN115@TCTranslat:

; 1932 : 		TC_CASE_RET_NAME (TC_IOCTL_OPEN_TEST);

  0017d	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1CG@HPPKKEKP@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAO?$AAP?$AAE?$AAN?$AA_?$AAT?$AAE?$AAS?$AAT?$AA?$AA@FNODOBFM@
  00182	e9 ff 04 00 00	 jmp	 $LN148@TCTranslat
$LN114@TCTranslat:

; 1933 : 		TC_CASE_RET_NAME (TC_IOCTL_PROBE_REAL_DRIVE_SIZE);

  00187	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DO@BKHLMLHN@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAP?$AAR?$AAO?$AAB?$AAE?$AA_?$AAR?$AAE?$AAA?$AAL?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$AA@FNODOBFM@
  0018c	e9 f5 04 00 00	 jmp	 $LN148@TCTranslat
$LN113@TCTranslat:

; 1934 : 		TC_CASE_RET_NAME (TC_IOCTL_REOPEN_BOOT_VOLUME_HEADER);

  00191	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1EG@GGODONFK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAR?$AAE?$AAO?$AAP?$AAE?$AAN?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAH?$AAE?$AAA?$AAD@FNODOBFM@
  00196	e9 eb 04 00 00	 jmp	 $LN148@TCTranslat
$LN112@TCTranslat:

; 1935 : 		TC_CASE_RET_NAME (TC_IOCTL_REREAD_DRIVER_CONFIG);

  0019b	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DM@JFJLBNLP@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAR?$AAE?$AAR?$AAE?$AAA?$AAD?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA?$AA@FNODOBFM@
  001a0	e9 e1 04 00 00	 jmp	 $LN148@TCTranslat
$LN111@TCTranslat:

; 1936 : 		TC_CASE_RET_NAME (TC_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY);

  001a5	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1FE@EBAIHKDI@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAF?$AAA?$AAV?$AAO?$AAR?$AAI?$AAT?$AAE?$AA_?$AAV?$AAO?$AAL@FNODOBFM@
  001aa	e9 d7 04 00 00	 jmp	 $LN148@TCTranslat
$LN110@TCTranslat:

; 1937 : 		TC_CASE_RET_NAME (TC_IOCTL_START_DECOY_SYSTEM_WIPE);

  001af	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1EC@FGBEDIDI@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAA?$AAR?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE@FNODOBFM@
  001b4	e9 cd 04 00 00	 jmp	 $LN148@TCTranslat
$LN109@TCTranslat:

; 1938 : 		TC_CASE_RET_NAME (TC_IOCTL_WIPE_PASSWORD_CACHE);

  001b9	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DK@BNKDMLAM@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_?$AAP?$AAA?$AAS?$AAS?$AAW?$AAO?$AAR?$AAD?$AA_?$AAC?$AAA?$AAC?$AAH?$AAE?$AA?$AA@FNODOBFM@
  001be	e9 c3 04 00 00	 jmp	 $LN148@TCTranslat
$LN108@TCTranslat:

; 1939 : 		TC_CASE_RET_NAME (TC_IOCTL_WRITE_BOOT_DRIVE_SECTOR);

  001c3	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1EC@FOOPNHFI@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAW?$AAR?$AAI?$AAT?$AAE?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAS?$AAE?$AAC?$AAT?$AAO?$AAR@FNODOBFM@
  001c8	e9 b9 04 00 00	 jmp	 $LN148@TCTranslat
$LN107@TCTranslat:

; 1940 : 
; 1941 : 		TC_CASE_RET_NAME (IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS);

  001cd	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1EK@FDCJEFAP@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAE?$AAX?$AAT@FNODOBFM@
  001d2	e9 af 04 00 00	 jmp	 $LN148@TCTranslat
$LN146@TCTranslat:

; 1942 : 
; 1943 : #undef TC_CASE_RET_NAME
; 1944 : 	}
; 1945 : 
; 1946 : 	if (ulCode ==			 IOCTL_DISK_GET_DRIVE_GEOMETRY)

  001d7	81 7d 08 00 00
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 458752 ; 00070000H
  001de	75 0f		 jne	 SHORT $LN106@TCTranslat

; 1947 : 		return (LPWSTR) _T ("IOCTL_DISK_GET_DRIVE_GEOMETRY");

  001e0	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DM@KPKDNCHM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA?$AA@FNODOBFM@
  001e5	e9 9c 04 00 00	 jmp	 $LN148@TCTranslat
  001ea	e9 97 04 00 00	 jmp	 $LN148@TCTranslat
$LN106@TCTranslat:

; 1948 : 	else if (ulCode ==		 IOCTL_DISK_GET_DRIVE_GEOMETRY_EX)

  001ef	81 7d 08 a0 00
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 458912 ; 000700a0H
  001f6	75 0f		 jne	 SHORT $LN104@TCTranslat

; 1949 : 		return (LPWSTR) _T ("IOCTL_DISK_GET_DRIVE_GEOMETRY_EX");

  001f8	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1EC@NPAFBAMN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA_?$AAE?$AAX@FNODOBFM@
  001fd	e9 84 04 00 00	 jmp	 $LN148@TCTranslat
  00202	e9 7f 04 00 00	 jmp	 $LN148@TCTranslat
$LN104@TCTranslat:

; 1950 : 	else if (ulCode ==		 IOCTL_MOUNTDEV_QUERY_DEVICE_NAME)

  00207	81 7d 08 08 00
	4d 00		 cmp	 DWORD PTR _ulCode$[ebp], 5046280 ; 004d0008H
  0020e	75 0f		 jne	 SHORT $LN102@TCTranslat

; 1951 : 		return (LPWSTR) _T ("IOCTL_MOUNTDEV_QUERY_DEVICE_NAME");

  00210	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1EC@HFOIOEOM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAN?$AAA?$AAM?$AAE@FNODOBFM@
  00215	e9 6c 04 00 00	 jmp	 $LN148@TCTranslat
  0021a	e9 67 04 00 00	 jmp	 $LN148@TCTranslat
$LN102@TCTranslat:

; 1952 : 	else if (ulCode ==		 IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME)

  0021f	81 7d 08 0c 00
	4d 00		 cmp	 DWORD PTR _ulCode$[ebp], 5046284 ; 004d000cH
  00226	75 0f		 jne	 SHORT $LN100@TCTranslat

; 1953 : 		return (LPWSTR) _T ("IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME");

  00228	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1FC@MNMCPAAJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAS?$AAU?$AAG?$AAG?$AAE?$AAS?$AAT?$AAE?$AAD?$AA_?$AAL@FNODOBFM@
  0022d	e9 54 04 00 00	 jmp	 $LN148@TCTranslat
  00232	e9 4f 04 00 00	 jmp	 $LN148@TCTranslat
$LN100@TCTranslat:

; 1954 : 	else if (ulCode ==		 IOCTL_MOUNTDEV_QUERY_UNIQUE_ID)

  00237	81 7d 08 00 00
	4d 00		 cmp	 DWORD PTR _ulCode$[ebp], 5046272 ; 004d0000H
  0023e	75 0f		 jne	 SHORT $LN98@TCTranslat

; 1955 : 		return (LPWSTR) _T ("IOCTL_MOUNTDEV_QUERY_UNIQUE_ID");

  00240	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DO@OGNDJPNH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAU?$AAN?$AAI?$AAQ?$AAU?$AAE?$AA_?$AAI?$AAD?$AA?$AA@FNODOBFM@
  00245	e9 3c 04 00 00	 jmp	 $LN148@TCTranslat
  0024a	e9 37 04 00 00	 jmp	 $LN148@TCTranslat
$LN98@TCTranslat:

; 1956 : 	else if (ulCode ==		 IOCTL_VOLUME_ONLINE)

  0024f	81 7d 08 08 c0
	56 00		 cmp	 DWORD PTR _ulCode$[ebp], 5685256 ; 0056c008H
  00256	75 0f		 jne	 SHORT $LN96@TCTranslat

; 1957 : 		return (LPWSTR) _T ("IOCTL_VOLUME_ONLINE");

  00258	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1CI@DJEMJCBH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAO?$AAN?$AAL?$AAI?$AAN?$AAE?$AA?$AA@FNODOBFM@
  0025d	e9 24 04 00 00	 jmp	 $LN148@TCTranslat
  00262	e9 1f 04 00 00	 jmp	 $LN148@TCTranslat
$LN96@TCTranslat:

; 1958 : 	else if (ulCode ==		 IOCTL_MOUNTDEV_LINK_CREATED)

  00267	81 7d 08 10 c0
	4d 00		 cmp	 DWORD PTR _ulCode$[ebp], 5095440 ; 004dc010H
  0026e	75 0f		 jne	 SHORT $LN94@TCTranslat

; 1959 : 		return (LPWSTR) _T ("IOCTL_MOUNTDEV_LINK_CREATED");

  00270	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DI@HGGIOGFM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAL?$AAI?$AAN?$AAK?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@
  00275	e9 0c 04 00 00	 jmp	 $LN148@TCTranslat
  0027a	e9 07 04 00 00	 jmp	 $LN148@TCTranslat
$LN94@TCTranslat:

; 1960 : 	else if (ulCode ==		 IOCTL_MOUNTDEV_LINK_DELETED)

  0027f	81 7d 08 14 c0
	4d 00		 cmp	 DWORD PTR _ulCode$[ebp], 5095444 ; 004dc014H
  00286	75 0f		 jne	 SHORT $LN92@TCTranslat

; 1961 : 		return (LPWSTR) _T ("IOCTL_MOUNTDEV_LINK_DELETED");

  00288	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DI@BMKMBCGO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAL?$AAI?$AAN?$AAK?$AA_?$AAD?$AAE?$AAL?$AAE?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@
  0028d	e9 f4 03 00 00	 jmp	 $LN148@TCTranslat
  00292	e9 ef 03 00 00	 jmp	 $LN148@TCTranslat
$LN92@TCTranslat:

; 1962 : 	else if (ulCode ==		 IOCTL_MOUNTMGR_QUERY_POINTS)

  00297	81 7d 08 08 00
	6d 00		 cmp	 DWORD PTR _ulCode$[ebp], 7143432 ; 006d0008H
  0029e	75 0f		 jne	 SHORT $LN90@TCTranslat

; 1963 : 		return (LPWSTR) _T ("IOCTL_MOUNTMGR_QUERY_POINTS");

  002a0	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DI@LFNEEBHO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAP?$AAO?$AAI?$AAN?$AAT?$AAS?$AA?$AA@FNODOBFM@
  002a5	e9 dc 03 00 00	 jmp	 $LN148@TCTranslat
  002aa	e9 d7 03 00 00	 jmp	 $LN148@TCTranslat
$LN90@TCTranslat:

; 1964 : 	else if (ulCode ==		 IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED)

  002af	81 7d 08 18 c0
	6d 00		 cmp	 DWORD PTR _ulCode$[ebp], 7192600 ; 006dc018H
  002b6	75 0f		 jne	 SHORT $LN88@TCTranslat

; 1965 : 		return (LPWSTR) _T ("IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED");

  002b8	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1FE@CLAOKMGL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAP?$AAO?$AAI?$AAN@FNODOBFM@
  002bd	e9 c4 03 00 00	 jmp	 $LN148@TCTranslat
  002c2	e9 bf 03 00 00	 jmp	 $LN148@TCTranslat
$LN88@TCTranslat:

; 1966 : 	else if (ulCode ==		 IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED)

  002c7	81 7d 08 1c c0
	6d 00		 cmp	 DWORD PTR _ulCode$[ebp], 7192604 ; 006dc01cH
  002ce	75 0f		 jne	 SHORT $LN86@TCTranslat

; 1967 : 		return (LPWSTR) _T ("IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED");

  002d0	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1FE@EBMKFIFJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAP?$AAO?$AAI?$AAN@FNODOBFM@
  002d5	e9 ac 03 00 00	 jmp	 $LN148@TCTranslat
  002da	e9 a7 03 00 00	 jmp	 $LN148@TCTranslat
$LN86@TCTranslat:

; 1968 : 	else if (ulCode ==		 IOCTL_DISK_GET_LENGTH_INFO)

  002df	81 7d 08 5c 40
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 475228 ; 0007405cH
  002e6	75 0f		 jne	 SHORT $LN84@TCTranslat

; 1969 : 		return (LPWSTR) _T ("IOCTL_DISK_GET_LENGTH_INFO");

  002e8	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DG@DLDFECDE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAL?$AAE?$AAN?$AAG?$AAT?$AAH?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@
  002ed	e9 94 03 00 00	 jmp	 $LN148@TCTranslat
  002f2	e9 8f 03 00 00	 jmp	 $LN148@TCTranslat
$LN84@TCTranslat:

; 1970 : 	else if (ulCode ==		 IOCTL_STORAGE_GET_DEVICE_NUMBER)

  002f7	81 7d 08 80 10
	2d 00		 cmp	 DWORD PTR _ulCode$[ebp], 2953344 ; 002d1080H
  002fe	75 0f		 jne	 SHORT $LN82@TCTranslat

; 1971 : 		return (LPWSTR) _T ("IOCTL_STORAGE_GET_DEVICE_NUMBER");

  00300	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1EA@IKPNDHCL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAO?$AAR?$AAA?$AAG?$AAE?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAN?$AAU?$AAM?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@
  00305	e9 7c 03 00 00	 jmp	 $LN148@TCTranslat
  0030a	e9 77 03 00 00	 jmp	 $LN148@TCTranslat
$LN82@TCTranslat:

; 1972 : 	else if (ulCode ==		 IOCTL_DISK_GET_PARTITION_INFO)

  0030f	81 7d 08 04 40
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 475140 ; 00074004H
  00316	75 0f		 jne	 SHORT $LN80@TCTranslat

; 1973 : 		return (LPWSTR) _T ("IOCTL_DISK_GET_PARTITION_INFO");

  00318	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DM@LOAKHCPB@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@
  0031d	e9 64 03 00 00	 jmp	 $LN148@TCTranslat
  00322	e9 5f 03 00 00	 jmp	 $LN148@TCTranslat
$LN80@TCTranslat:

; 1974 : 	else if (ulCode ==		 IOCTL_DISK_GET_PARTITION_INFO_EX)

  00327	81 7d 08 48 00
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 458824 ; 00070048H
  0032e	75 0f		 jne	 SHORT $LN78@TCTranslat

; 1975 : 		return (LPWSTR) _T ("IOCTL_DISK_GET_PARTITION_INFO_EX");

  00330	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1EC@CAILBHJF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA_?$AAE?$AAX@FNODOBFM@
  00335	e9 4c 03 00 00	 jmp	 $LN148@TCTranslat
  0033a	e9 47 03 00 00	 jmp	 $LN148@TCTranslat
$LN78@TCTranslat:

; 1976 : 	else if (ulCode ==		 IOCTL_DISK_SET_PARTITION_INFO)

  0033f	81 7d 08 08 c0
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 507912 ; 0007c008H
  00346	75 0f		 jne	 SHORT $LN76@TCTranslat

; 1977 : 		return (LPWSTR) _T ("IOCTL_DISK_SET_PARTITION_INFO");

  00348	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DM@FAAIHMNH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAS?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@
  0034d	e9 34 03 00 00	 jmp	 $LN148@TCTranslat
  00352	e9 2f 03 00 00	 jmp	 $LN148@TCTranslat
$LN76@TCTranslat:

; 1978 : 	else if (ulCode ==		 IOCTL_DISK_GET_DRIVE_LAYOUT)

  00357	81 7d 08 0c 40
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 475148 ; 0007400cH
  0035e	75 0f		 jne	 SHORT $LN74@TCTranslat

; 1979 : 		return (LPWSTR) _T ("IOCTL_DISK_GET_DRIVE_LAYOUT");

  00360	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DI@CCDFFIEC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAL?$AAA?$AAY?$AAO?$AAU?$AAT?$AA?$AA@FNODOBFM@
  00365	e9 1c 03 00 00	 jmp	 $LN148@TCTranslat
  0036a	e9 17 03 00 00	 jmp	 $LN148@TCTranslat
$LN74@TCTranslat:

; 1980 : 	else if (ulCode ==		 IOCTL_DISK_SET_DRIVE_LAYOUT_EX)

  0036f	81 7d 08 54 c0
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 507988 ; 0007c054H
  00376	75 0f		 jne	 SHORT $LN72@TCTranslat

; 1981 : 		return (LPWSTR) _T ("IOCTL_DISK_SET_DRIVE_LAYOUT_EX");

  00378	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DO@EPIDKIKJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAS?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAL?$AAA?$AAY?$AAO?$AAU?$AAT?$AA_?$AAE?$AAX?$AA?$AA@FNODOBFM@
  0037d	e9 04 03 00 00	 jmp	 $LN148@TCTranslat
  00382	e9 ff 02 00 00	 jmp	 $LN148@TCTranslat
$LN72@TCTranslat:

; 1982 : 	else if (ulCode ==		 IOCTL_DISK_VERIFY)

  00387	81 7d 08 14 00
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 458772 ; 00070014H
  0038e	75 0f		 jne	 SHORT $LN70@TCTranslat

; 1983 : 		return (LPWSTR) _T ("IOCTL_DISK_VERIFY");

  00390	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1CE@LGEELOJE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@
  00395	e9 ec 02 00 00	 jmp	 $LN148@TCTranslat
  0039a	e9 e7 02 00 00	 jmp	 $LN148@TCTranslat
$LN70@TCTranslat:

; 1984 : 	else if (ulCode == IOCTL_DISK_FORMAT_TRACKS)

  0039f	81 7d 08 18 c0
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 507928 ; 0007c018H
  003a6	75 0f		 jne	 SHORT $LN68@TCTranslat

; 1985 : 		return (LPWSTR) _T ("IOCTL_DISK_FORMAT_TRACKS");

  003a8	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DC@PCKIDBBB@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAT?$AAR?$AAA?$AAC?$AAK?$AAS?$AA?$AA@FNODOBFM@
  003ad	e9 d4 02 00 00	 jmp	 $LN148@TCTranslat
  003b2	e9 cf 02 00 00	 jmp	 $LN148@TCTranslat
$LN68@TCTranslat:

; 1986 : 	else if (ulCode == IOCTL_DISK_REASSIGN_BLOCKS)

  003b7	81 7d 08 1c c0
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 507932 ; 0007c01cH
  003be	75 0f		 jne	 SHORT $LN66@TCTranslat

; 1987 : 		return (LPWSTR) _T ("IOCTL_DISK_REASSIGN_BLOCKS");

  003c0	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DG@HPLPDECO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAA?$AAS?$AAS?$AAI?$AAG?$AAN?$AA_?$AAB?$AAL?$AAO?$AAC?$AAK?$AAS?$AA?$AA@FNODOBFM@
  003c5	e9 bc 02 00 00	 jmp	 $LN148@TCTranslat
  003ca	e9 b7 02 00 00	 jmp	 $LN148@TCTranslat
$LN66@TCTranslat:

; 1988 : 	else if (ulCode == IOCTL_DISK_PERFORMANCE)

  003cf	81 7d 08 20 00
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 458784 ; 00070020H
  003d6	75 0f		 jne	 SHORT $LN64@TCTranslat

; 1989 : 		return (LPWSTR) _T ("IOCTL_DISK_PERFORMANCE");

  003d8	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1CO@LEDAJMII@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAP?$AAE?$AAR?$AAF?$AAO?$AAR?$AAM?$AAA?$AAN?$AAC?$AAE?$AA?$AA@FNODOBFM@
  003dd	e9 a4 02 00 00	 jmp	 $LN148@TCTranslat
  003e2	e9 9f 02 00 00	 jmp	 $LN148@TCTranslat
$LN64@TCTranslat:

; 1990 : 	else if (ulCode == IOCTL_DISK_IS_WRITABLE)

  003e7	81 7d 08 24 00
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 458788 ; 00070024H
  003ee	75 0f		 jne	 SHORT $LN62@TCTranslat

; 1991 : 		return (LPWSTR) _T ("IOCTL_DISK_IS_WRITABLE");

  003f0	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1CO@MFHKENAI@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAS?$AA_?$AAW?$AAR?$AAI?$AAT?$AAA?$AAB?$AAL?$AAE?$AA?$AA@FNODOBFM@
  003f5	e9 8c 02 00 00	 jmp	 $LN148@TCTranslat
  003fa	e9 87 02 00 00	 jmp	 $LN148@TCTranslat
$LN62@TCTranslat:

; 1992 : 	else if (ulCode == IOCTL_DISK_LOGGING)

  003ff	81 7d 08 28 00
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 458792 ; 00070028H
  00406	75 0f		 jne	 SHORT $LN60@TCTranslat

; 1993 : 		return (LPWSTR) _T ("IOCTL_DISK_LOGGING");

  00408	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1CG@LCBFNDKM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAL?$AAO?$AAG?$AAG?$AAI?$AAN?$AAG?$AA?$AA@FNODOBFM@
  0040d	e9 74 02 00 00	 jmp	 $LN148@TCTranslat
  00412	e9 6f 02 00 00	 jmp	 $LN148@TCTranslat
$LN60@TCTranslat:

; 1994 : 	else if (ulCode == IOCTL_DISK_FORMAT_TRACKS_EX)

  00417	81 7d 08 2c c0
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 507948 ; 0007c02cH
  0041e	75 0f		 jne	 SHORT $LN58@TCTranslat

; 1995 : 		return (LPWSTR) _T ("IOCTL_DISK_FORMAT_TRACKS_EX");

  00420	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DI@LHHOILKE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAT?$AAR?$AAA?$AAC?$AAK?$AAS?$AA_?$AAE?$AAX?$AA?$AA@FNODOBFM@
  00425	e9 5c 02 00 00	 jmp	 $LN148@TCTranslat
  0042a	e9 57 02 00 00	 jmp	 $LN148@TCTranslat
$LN58@TCTranslat:

; 1996 : 	else if (ulCode == IOCTL_DISK_HISTOGRAM_STRUCTURE)

  0042f	81 7d 08 30 00
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 458800 ; 00070030H
  00436	75 0f		 jne	 SHORT $LN56@TCTranslat

; 1997 : 		return (LPWSTR) _T ("IOCTL_DISK_HISTOGRAM_STRUCTURE");

  00438	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DO@JMICENAF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAS?$AAT?$AAR?$AAU?$AAC?$AAT?$AAU?$AAR?$AAE?$AA?$AA@FNODOBFM@
  0043d	e9 44 02 00 00	 jmp	 $LN148@TCTranslat
  00442	e9 3f 02 00 00	 jmp	 $LN148@TCTranslat
$LN56@TCTranslat:

; 1998 : 	else if (ulCode == IOCTL_DISK_HISTOGRAM_DATA)

  00447	81 7d 08 34 00
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 458804 ; 00070034H
  0044e	75 0f		 jne	 SHORT $LN54@TCTranslat

; 1999 : 		return (LPWSTR) _T ("IOCTL_DISK_HISTOGRAM_DATA");

  00450	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DE@OGHADOL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@
  00455	e9 2c 02 00 00	 jmp	 $LN148@TCTranslat
  0045a	e9 27 02 00 00	 jmp	 $LN148@TCTranslat
$LN54@TCTranslat:

; 2000 : 	else if (ulCode == IOCTL_DISK_HISTOGRAM_RESET)

  0045f	81 7d 08 38 00
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 458808 ; 00070038H
  00466	75 0f		 jne	 SHORT $LN52@TCTranslat

; 2001 : 		return (LPWSTR) _T ("IOCTL_DISK_HISTOGRAM_RESET");

  00468	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DG@BLHGEOGG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAR?$AAE?$AAS?$AAE?$AAT?$AA?$AA@FNODOBFM@
  0046d	e9 14 02 00 00	 jmp	 $LN148@TCTranslat
  00472	e9 0f 02 00 00	 jmp	 $LN148@TCTranslat
$LN52@TCTranslat:

; 2002 : 	else if (ulCode == IOCTL_DISK_REQUEST_STRUCTURE)

  00477	81 7d 08 3c 00
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 458812 ; 0007003cH
  0047e	75 0f		 jne	 SHORT $LN50@TCTranslat

; 2003 : 		return (LPWSTR) _T ("IOCTL_DISK_REQUEST_STRUCTURE");

  00480	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DK@EFIEFEEG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAQ?$AAU?$AAE?$AAS?$AAT?$AA_?$AAS?$AAT?$AAR?$AAU?$AAC?$AAT?$AAU?$AAR?$AAE?$AA?$AA@FNODOBFM@
  00485	e9 fc 01 00 00	 jmp	 $LN148@TCTranslat
  0048a	e9 f7 01 00 00	 jmp	 $LN148@TCTranslat
$LN50@TCTranslat:

; 2004 : 	else if (ulCode == IOCTL_DISK_REQUEST_DATA)

  0048f	81 7d 08 40 00
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 458816 ; 00070040H
  00496	75 0f		 jne	 SHORT $LN48@TCTranslat

; 2005 : 		return (LPWSTR) _T ("IOCTL_DISK_REQUEST_DATA");

  00498	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DA@EGLLKJNO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAQ?$AAU?$AAE?$AAS?$AAT?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@
  0049d	e9 e4 01 00 00	 jmp	 $LN148@TCTranslat
  004a2	e9 df 01 00 00	 jmp	 $LN148@TCTranslat
$LN48@TCTranslat:

; 2006 : 	else if (ulCode == IOCTL_DISK_CONTROLLER_NUMBER)

  004a7	81 7d 08 44 00
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 458820 ; 00070044H
  004ae	75 0f		 jne	 SHORT $LN46@TCTranslat

; 2007 : 		return (LPWSTR) _T ("IOCTL_DISK_CONTROLLER_NUMBER");

  004b0	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DK@NNJOEKIN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAC?$AAO?$AAN?$AAT?$AAR?$AAO?$AAL?$AAL?$AAE?$AAR?$AA_?$AAN?$AAU?$AAM?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@
  004b5	e9 cc 01 00 00	 jmp	 $LN148@TCTranslat
  004ba	e9 c7 01 00 00	 jmp	 $LN148@TCTranslat
$LN46@TCTranslat:

; 2008 : 	else if (ulCode == SMART_GET_VERSION)

  004bf	81 7d 08 80 40
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 475264 ; 00074080H
  004c6	75 0f		 jne	 SHORT $LN44@TCTranslat

; 2009 : 		return (LPWSTR) _T ("SMART_GET_VERSION");

  004c8	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1CE@PLNOGJJD@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN?$AA?$AA@FNODOBFM@
  004cd	e9 b4 01 00 00	 jmp	 $LN148@TCTranslat
  004d2	e9 af 01 00 00	 jmp	 $LN148@TCTranslat
$LN44@TCTranslat:

; 2010 : 	else if (ulCode == SMART_SEND_DRIVE_COMMAND)

  004d7	81 7d 08 84 c0
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 508036 ; 0007c084H
  004de	75 0f		 jne	 SHORT $LN42@TCTranslat

; 2011 : 		return (LPWSTR) _T ("SMART_SEND_DRIVE_COMMAND");

  004e0	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DC@MGFPICHJ@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAS?$AAE?$AAN?$AAD?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAC?$AAO?$AAM?$AAM?$AAA?$AAN?$AAD?$AA?$AA@FNODOBFM@
  004e5	e9 9c 01 00 00	 jmp	 $LN148@TCTranslat
  004ea	e9 97 01 00 00	 jmp	 $LN148@TCTranslat
$LN42@TCTranslat:

; 2012 : 	else if (ulCode == SMART_RCV_DRIVE_DATA)

  004ef	81 7d 08 88 c0
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 508040 ; 0007c088H
  004f6	75 0f		 jne	 SHORT $LN40@TCTranslat

; 2013 : 		return (LPWSTR) _T ("SMART_RCV_DRIVE_DATA");

  004f8	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1CK@JCHEBCIE@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAR?$AAC?$AAV?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@
  004fd	e9 84 01 00 00	 jmp	 $LN148@TCTranslat
  00502	e9 7f 01 00 00	 jmp	 $LN148@TCTranslat
$LN40@TCTranslat:

; 2014 : 	else if (ulCode == IOCTL_DISK_INTERNAL_SET_VERIFY)

  00507	81 7d 08 03 04
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 459779 ; 00070403H
  0050e	75 0f		 jne	 SHORT $LN38@TCTranslat

; 2015 : 		return (LPWSTR) _T ("IOCTL_DISK_INTERNAL_SET_VERIFY");

  00510	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DO@JKPDDEIN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAN?$AAT?$AAE?$AAR?$AAN?$AAA?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@
  00515	e9 6c 01 00 00	 jmp	 $LN148@TCTranslat
  0051a	e9 67 01 00 00	 jmp	 $LN148@TCTranslat
$LN38@TCTranslat:

; 2016 : 	else if (ulCode == IOCTL_DISK_INTERNAL_CLEAR_VERIFY)

  0051f	81 7d 08 07 04
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 459783 ; 00070407H
  00526	75 0f		 jne	 SHORT $LN36@TCTranslat

; 2017 : 		return (LPWSTR) _T ("IOCTL_DISK_INTERNAL_CLEAR_VERIFY");

  00528	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1EC@JFOBAPGC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAN?$AAT?$AAE?$AAR?$AAN?$AAA?$AAL?$AA_?$AAC?$AAL?$AAE?$AAA?$AAR?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY@FNODOBFM@
  0052d	e9 54 01 00 00	 jmp	 $LN148@TCTranslat
  00532	e9 4f 01 00 00	 jmp	 $LN148@TCTranslat
$LN36@TCTranslat:

; 2018 : 	else if (ulCode == IOCTL_DISK_CHECK_VERIFY)

  00537	81 7d 08 00 48
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 477184 ; 00074800H
  0053e	75 0f		 jne	 SHORT $LN34@TCTranslat

; 2019 : 		return (LPWSTR) _T ("IOCTL_DISK_CHECK_VERIFY");

  00540	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DA@DLMBEKMN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAC?$AAH?$AAE?$AAC?$AAK?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@
  00545	e9 3c 01 00 00	 jmp	 $LN148@TCTranslat
  0054a	e9 37 01 00 00	 jmp	 $LN148@TCTranslat
$LN34@TCTranslat:

; 2020 : 	else if (ulCode == IOCTL_DISK_MEDIA_REMOVAL)

  0054f	81 7d 08 04 48
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 477188 ; 00074804H
  00556	75 0f		 jne	 SHORT $LN32@TCTranslat

; 2021 : 		return (LPWSTR) _T ("IOCTL_DISK_MEDIA_REMOVAL");

  00558	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DC@NMJCPDJD@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA_?$AAR?$AAE?$AAM?$AAO?$AAV?$AAA?$AAL?$AA?$AA@FNODOBFM@
  0055d	e9 24 01 00 00	 jmp	 $LN148@TCTranslat
  00562	e9 1f 01 00 00	 jmp	 $LN148@TCTranslat
$LN32@TCTranslat:

; 2022 : 	else if (ulCode == IOCTL_DISK_EJECT_MEDIA)

  00567	81 7d 08 08 48
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 477192 ; 00074808H
  0056e	75 0f		 jne	 SHORT $LN30@TCTranslat

; 2023 : 		return (LPWSTR) _T ("IOCTL_DISK_EJECT_MEDIA");

  00570	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1CO@KHEOABCH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAE?$AAJ?$AAE?$AAC?$AAT?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA?$AA@FNODOBFM@
  00575	e9 0c 01 00 00	 jmp	 $LN148@TCTranslat
  0057a	e9 07 01 00 00	 jmp	 $LN148@TCTranslat
$LN30@TCTranslat:

; 2024 : 	else if (ulCode == IOCTL_DISK_LOAD_MEDIA)

  0057f	81 7d 08 0c 48
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 477196 ; 0007480cH
  00586	75 0f		 jne	 SHORT $LN28@TCTranslat

; 2025 : 		return (LPWSTR) _T ("IOCTL_DISK_LOAD_MEDIA");

  00588	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1CM@GNBBIMEE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAL?$AAO?$AAA?$AAD?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA?$AA@FNODOBFM@
  0058d	e9 f4 00 00 00	 jmp	 $LN148@TCTranslat
  00592	e9 ef 00 00 00	 jmp	 $LN148@TCTranslat
$LN28@TCTranslat:

; 2026 : 	else if (ulCode == IOCTL_DISK_RESERVE)

  00597	81 7d 08 10 48
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 477200 ; 00074810H
  0059e	75 0f		 jne	 SHORT $LN26@TCTranslat

; 2027 : 		return (LPWSTR) _T ("IOCTL_DISK_RESERVE");

  005a0	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1CG@MJDBKCLM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAS?$AAE?$AAR?$AAV?$AAE?$AA?$AA@FNODOBFM@
  005a5	e9 dc 00 00 00	 jmp	 $LN148@TCTranslat
  005aa	e9 d7 00 00 00	 jmp	 $LN148@TCTranslat
$LN26@TCTranslat:

; 2028 : 	else if (ulCode == IOCTL_DISK_RELEASE)

  005af	81 7d 08 14 48
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 477204 ; 00074814H
  005b6	75 0f		 jne	 SHORT $LN24@TCTranslat

; 2029 : 		return (LPWSTR) _T ("IOCTL_DISK_RELEASE");

  005b8	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1CG@BFEEHHEK@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAL?$AAE?$AAA?$AAS?$AAE?$AA?$AA@FNODOBFM@
  005bd	e9 c4 00 00 00	 jmp	 $LN148@TCTranslat
  005c2	e9 bf 00 00 00	 jmp	 $LN148@TCTranslat
$LN24@TCTranslat:

; 2030 : 	else if (ulCode == IOCTL_DISK_FIND_NEW_DEVICES)

  005c7	81 7d 08 18 48
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 477208 ; 00074818H
  005ce	75 0f		 jne	 SHORT $LN22@TCTranslat

; 2031 : 		return (LPWSTR) _T ("IOCTL_DISK_FIND_NEW_DEVICES");

  005d0	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DI@EBJJOMKC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAI?$AAN?$AAD?$AA_?$AAN?$AAE?$AAW?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AAS?$AA?$AA@FNODOBFM@
  005d5	e9 ac 00 00 00	 jmp	 $LN148@TCTranslat
  005da	e9 a7 00 00 00	 jmp	 $LN148@TCTranslat
$LN22@TCTranslat:

; 2032 : 	else if (ulCode == IOCTL_DISK_GET_MEDIA_TYPES)

  005df	81 7d 08 00 0c
	07 00		 cmp	 DWORD PTR _ulCode$[ebp], 461824 ; 00070c00H
  005e6	75 0f		 jne	 SHORT $LN20@TCTranslat

; 2033 : 		return (LPWSTR) _T ("IOCTL_DISK_GET_MEDIA_TYPES");

  005e8	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DG@MIHPHMPG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA_?$AAT?$AAY?$AAP?$AAE?$AAS?$AA?$AA@FNODOBFM@
  005ed	e9 94 00 00 00	 jmp	 $LN148@TCTranslat
  005f2	e9 8f 00 00 00	 jmp	 $LN148@TCTranslat
$LN20@TCTranslat:

; 2034 : 	else if (ulCode == IOCTL_STORAGE_SET_HOTPLUG_INFO)

  005f7	81 7d 08 18 cc
	2d 00		 cmp	 DWORD PTR _ulCode$[ebp], 3001368 ; 002dcc18H
  005fe	75 09		 jne	 SHORT $LN18@TCTranslat

; 2035 : 		return (LPWSTR) _T ("IOCTL_STORAGE_SET_HOTPLUG_INFO");

  00600	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DO@MEELNMKF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAO?$AAR?$AAA?$AAG?$AAE?$AA_?$AAS?$AAE?$AAT?$AA_?$AAH?$AAO?$AAT?$AAP?$AAL?$AAU?$AAG?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@
  00605	eb 7f		 jmp	 SHORT $LN148@TCTranslat
  00607	eb 7d		 jmp	 SHORT $LN148@TCTranslat
$LN18@TCTranslat:

; 2036 : 	else if (ulCode == IRP_MJ_READ)

  00609	83 7d 08 03	 cmp	 DWORD PTR _ulCode$[ebp], 3
  0060d	75 09		 jne	 SHORT $LN16@TCTranslat

; 2037 : 		return (LPWSTR) _T ("IRP_MJ_READ");

  0060f	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1BI@CFPHGFDN@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAR?$AAE?$AAA?$AAD?$AA?$AA@FNODOBFM@
  00614	eb 70		 jmp	 SHORT $LN148@TCTranslat
  00616	eb 6e		 jmp	 SHORT $LN148@TCTranslat
$LN16@TCTranslat:

; 2038 : 	else if (ulCode == IRP_MJ_WRITE)

  00618	83 7d 08 04	 cmp	 DWORD PTR _ulCode$[ebp], 4
  0061c	75 09		 jne	 SHORT $LN14@TCTranslat

; 2039 : 		return (LPWSTR) _T ("IRP_MJ_WRITE");

  0061e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1BK@HGBIKEDO@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAW?$AAR?$AAI?$AAT?$AAE?$AA?$AA@FNODOBFM@
  00623	eb 61		 jmp	 SHORT $LN148@TCTranslat
  00625	eb 5f		 jmp	 SHORT $LN148@TCTranslat
$LN14@TCTranslat:

; 2040 : 	else if (ulCode == IRP_MJ_CREATE)

  00627	83 7d 08 00	 cmp	 DWORD PTR _ulCode$[ebp], 0
  0062b	75 09		 jne	 SHORT $LN12@TCTranslat

; 2041 : 		return (LPWSTR) _T ("IRP_MJ_CREATE");

  0062d	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1BM@KFEHBPBD@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AA?$AA@FNODOBFM@
  00632	eb 52		 jmp	 SHORT $LN148@TCTranslat
  00634	eb 50		 jmp	 SHORT $LN148@TCTranslat
$LN12@TCTranslat:

; 2042 : 	else if (ulCode == IRP_MJ_CLOSE)

  00636	83 7d 08 02	 cmp	 DWORD PTR _ulCode$[ebp], 2
  0063a	75 09		 jne	 SHORT $LN10@TCTranslat

; 2043 : 		return (LPWSTR) _T ("IRP_MJ_CLOSE");

  0063c	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1BK@JLALPKNJ@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAL?$AAO?$AAS?$AAE?$AA?$AA@FNODOBFM@
  00641	eb 43		 jmp	 SHORT $LN148@TCTranslat
  00643	eb 41		 jmp	 SHORT $LN148@TCTranslat
$LN10@TCTranslat:

; 2044 : 	else if (ulCode == IRP_MJ_CLEANUP)

  00645	83 7d 08 12	 cmp	 DWORD PTR _ulCode$[ebp], 18 ; 00000012H
  00649	75 09		 jne	 SHORT $LN8@TCTranslat

; 2045 : 		return (LPWSTR) _T ("IRP_MJ_CLEANUP");

  0064b	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1BO@GEGOKABG@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAL?$AAE?$AAA?$AAN?$AAU?$AAP?$AA?$AA@FNODOBFM@
  00650	eb 34		 jmp	 SHORT $LN148@TCTranslat
  00652	eb 32		 jmp	 SHORT $LN148@TCTranslat
$LN8@TCTranslat:

; 2046 : 	else if (ulCode == IRP_MJ_FLUSH_BUFFERS)

  00654	83 7d 08 09	 cmp	 DWORD PTR _ulCode$[ebp], 9
  00658	75 09		 jne	 SHORT $LN6@TCTranslat

; 2047 : 		return (LPWSTR) _T ("IRP_MJ_FLUSH_BUFFERS");

  0065a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1CK@MCKHKFDD@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAF?$AAL?$AAU?$AAS?$AAH?$AA_?$AAB?$AAU?$AAF?$AAF?$AAE?$AAR?$AAS?$AA?$AA@FNODOBFM@
  0065f	eb 25		 jmp	 SHORT $LN148@TCTranslat
  00661	eb 23		 jmp	 SHORT $LN148@TCTranslat
$LN6@TCTranslat:

; 2048 : 	else if (ulCode == IRP_MJ_SHUTDOWN)

  00663	83 7d 08 10	 cmp	 DWORD PTR _ulCode$[ebp], 16 ; 00000010H
  00667	75 09		 jne	 SHORT $LN4@TCTranslat

; 2049 : 		return (LPWSTR) _T ("IRP_MJ_SHUTDOWN");

  00669	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1CA@FOECGGNC@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAS?$AAH?$AAU?$AAT?$AAD?$AAO?$AAW?$AAN?$AA?$AA@FNODOBFM@
  0066e	eb 16		 jmp	 SHORT $LN148@TCTranslat
  00670	eb 14		 jmp	 SHORT $LN148@TCTranslat
$LN4@TCTranslat:

; 2050 : 	else if (ulCode == IRP_MJ_DEVICE_CONTROL)

  00672	83 7d 08 0e	 cmp	 DWORD PTR _ulCode$[ebp], 14 ; 0000000eH
  00676	75 09		 jne	 SHORT $LN2@TCTranslat

; 2051 : 		return (LPWSTR) _T ("IRP_MJ_DEVICE_CONTROL");

  00678	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1CM@DKLAEDLO@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAT?$AAR?$AAO?$AAL?$AA?$AA@FNODOBFM@
  0067d	eb 07		 jmp	 SHORT $LN148@TCTranslat

; 2052 : 	else

  0067f	eb 05		 jmp	 SHORT $LN148@TCTranslat
$LN2@TCTranslat:

; 2053 : 	{
; 2054 : 		return (LPWSTR) _T ("IOCTL");

  00681	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1M@KHJOIALG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA?$AA@FNODOBFM@
$LN148@TCTranslat:

; 2055 : 	}
; 2056 : }

  00686	8b e5		 mov	 esp, ebp
  00688	5d		 pop	 ebp
  00689	c2 04 00	 ret	 4
$LN152@TCTranslat:
  0068c	00 00 00 00	 DD	 $LN130@TCTranslat
  00690	00 00 00 00	 DD	 $LN136@TCTranslat
  00694	00 00 00 00	 DD	 $LN116@TCTranslat
  00698	00 00 00 00	 DD	 $LN141@TCTranslat
  0069c	00 00 00 00	 DD	 $LN142@TCTranslat
  006a0	00 00 00 00	 DD	 $LN129@TCTranslat
  006a4	00 00 00 00	 DD	 $LN122@TCTranslat
  006a8	00 00 00 00	 DD	 $LN133@TCTranslat
  006ac	00 00 00 00	 DD	 $LN118@TCTranslat
  006b0	00 00 00 00	 DD	 $LN119@TCTranslat
  006b4	00 00 00 00	 DD	 $LN128@TCTranslat
  006b8	00 00 00 00	 DD	 $LN109@TCTranslat
  006bc	00 00 00 00	 DD	 $LN115@TCTranslat
  006c0	00 00 00 00	 DD	 $LN131@TCTranslat
  006c4	00 00 00 00	 DD	 $LN132@TCTranslat
  006c8	00 00 00 00	 DD	 $LN114@TCTranslat
  006cc	00 00 00 00	 DD	 $LN124@TCTranslat
  006d0	00 00 00 00	 DD	 $LN137@TCTranslat
  006d4	00 00 00 00	 DD	 $LN143@TCTranslat
  006d8	00 00 00 00	 DD	 $LN145@TCTranslat
  006dc	00 00 00 00	 DD	 $LN138@TCTranslat
  006e0	00 00 00 00	 DD	 $LN140@TCTranslat
  006e4	00 00 00 00	 DD	 $LN113@TCTranslat
  006e8	00 00 00 00	 DD	 $LN139@TCTranslat
  006ec	00 00 00 00	 DD	 $LN126@TCTranslat
  006f0	00 00 00 00	 DD	 $LN125@TCTranslat
  006f4	00 00 00 00	 DD	 $LN117@TCTranslat
  006f8	00 00 00 00	 DD	 $LN127@TCTranslat
  006fc	00 00 00 00	 DD	 $LN120@TCTranslat
  00700	00 00 00 00	 DD	 $LN110@TCTranslat
  00704	00 00 00 00	 DD	 $LN144@TCTranslat
  00708	00 00 00 00	 DD	 $LN134@TCTranslat
  0070c	00 00 00 00	 DD	 $LN135@TCTranslat
  00710	00 00 00 00	 DD	 $LN108@TCTranslat
  00714	00 00 00 00	 DD	 $LN121@TCTranslat
  00718	00 00 00 00	 DD	 $LN111@TCTranslat
  0071c	00 00 00 00	 DD	 $LN112@TCTranslat
  00720	00 00 00 00	 DD	 $LN123@TCTranslat
  00724	00 00 00 00	 DD	 $LN146@TCTranslat
$LN151@TCTranslat:
  00728	00		 DB	 0
  00729	26		 DB	 38			; 00000026H
  0072a	26		 DB	 38			; 00000026H
  0072b	26		 DB	 38			; 00000026H
  0072c	01		 DB	 1
  0072d	26		 DB	 38			; 00000026H
  0072e	26		 DB	 38			; 00000026H
  0072f	26		 DB	 38			; 00000026H
  00730	02		 DB	 2
  00731	26		 DB	 38			; 00000026H
  00732	26		 DB	 38			; 00000026H
  00733	26		 DB	 38			; 00000026H
  00734	03		 DB	 3
  00735	26		 DB	 38			; 00000026H
  00736	26		 DB	 38			; 00000026H
  00737	26		 DB	 38			; 00000026H
  00738	04		 DB	 4
  00739	26		 DB	 38			; 00000026H
  0073a	26		 DB	 38			; 00000026H
  0073b	26		 DB	 38			; 00000026H
  0073c	05		 DB	 5
  0073d	26		 DB	 38			; 00000026H
  0073e	26		 DB	 38			; 00000026H
  0073f	26		 DB	 38			; 00000026H
  00740	06		 DB	 6
  00741	26		 DB	 38			; 00000026H
  00742	26		 DB	 38			; 00000026H
  00743	26		 DB	 38			; 00000026H
  00744	07		 DB	 7
  00745	26		 DB	 38			; 00000026H
  00746	26		 DB	 38			; 00000026H
  00747	26		 DB	 38			; 00000026H
  00748	08		 DB	 8
  00749	26		 DB	 38			; 00000026H
  0074a	26		 DB	 38			; 00000026H
  0074b	26		 DB	 38			; 00000026H
  0074c	09		 DB	 9
  0074d	26		 DB	 38			; 00000026H
  0074e	26		 DB	 38			; 00000026H
  0074f	26		 DB	 38			; 00000026H
  00750	0a		 DB	 10			; 0000000aH
  00751	26		 DB	 38			; 00000026H
  00752	26		 DB	 38			; 00000026H
  00753	26		 DB	 38			; 00000026H
  00754	0b		 DB	 11			; 0000000bH
  00755	26		 DB	 38			; 00000026H
  00756	26		 DB	 38			; 00000026H
  00757	26		 DB	 38			; 00000026H
  00758	0c		 DB	 12			; 0000000cH
  00759	26		 DB	 38			; 00000026H
  0075a	26		 DB	 38			; 00000026H
  0075b	26		 DB	 38			; 00000026H
  0075c	0d		 DB	 13			; 0000000dH
  0075d	26		 DB	 38			; 00000026H
  0075e	26		 DB	 38			; 00000026H
  0075f	26		 DB	 38			; 00000026H
  00760	0e		 DB	 14			; 0000000eH
  00761	26		 DB	 38			; 00000026H
  00762	26		 DB	 38			; 00000026H
  00763	26		 DB	 38			; 00000026H
  00764	0f		 DB	 15			; 0000000fH
  00765	26		 DB	 38			; 00000026H
  00766	26		 DB	 38			; 00000026H
  00767	26		 DB	 38			; 00000026H
  00768	10		 DB	 16			; 00000010H
  00769	26		 DB	 38			; 00000026H
  0076a	26		 DB	 38			; 00000026H
  0076b	26		 DB	 38			; 00000026H
  0076c	11		 DB	 17			; 00000011H
  0076d	26		 DB	 38			; 00000026H
  0076e	26		 DB	 38			; 00000026H
  0076f	26		 DB	 38			; 00000026H
  00770	12		 DB	 18			; 00000012H
  00771	26		 DB	 38			; 00000026H
  00772	26		 DB	 38			; 00000026H
  00773	26		 DB	 38			; 00000026H
  00774	13		 DB	 19			; 00000013H
  00775	26		 DB	 38			; 00000026H
  00776	26		 DB	 38			; 00000026H
  00777	26		 DB	 38			; 00000026H
  00778	14		 DB	 20			; 00000014H
  00779	26		 DB	 38			; 00000026H
  0077a	26		 DB	 38			; 00000026H
  0077b	26		 DB	 38			; 00000026H
  0077c	15		 DB	 21			; 00000015H
  0077d	26		 DB	 38			; 00000026H
  0077e	26		 DB	 38			; 00000026H
  0077f	26		 DB	 38			; 00000026H
  00780	16		 DB	 22			; 00000016H
  00781	26		 DB	 38			; 00000026H
  00782	26		 DB	 38			; 00000026H
  00783	26		 DB	 38			; 00000026H
  00784	17		 DB	 23			; 00000017H
  00785	26		 DB	 38			; 00000026H
  00786	26		 DB	 38			; 00000026H
  00787	26		 DB	 38			; 00000026H
  00788	18		 DB	 24			; 00000018H
  00789	26		 DB	 38			; 00000026H
  0078a	26		 DB	 38			; 00000026H
  0078b	26		 DB	 38			; 00000026H
  0078c	19		 DB	 25			; 00000019H
  0078d	26		 DB	 38			; 00000026H
  0078e	26		 DB	 38			; 00000026H
  0078f	26		 DB	 38			; 00000026H
  00790	1a		 DB	 26			; 0000001aH
  00791	26		 DB	 38			; 00000026H
  00792	26		 DB	 38			; 00000026H
  00793	26		 DB	 38			; 00000026H
  00794	1b		 DB	 27			; 0000001bH
  00795	26		 DB	 38			; 00000026H
  00796	26		 DB	 38			; 00000026H
  00797	26		 DB	 38			; 00000026H
  00798	1c		 DB	 28			; 0000001cH
  00799	26		 DB	 38			; 00000026H
  0079a	26		 DB	 38			; 00000026H
  0079b	26		 DB	 38			; 00000026H
  0079c	1d		 DB	 29			; 0000001dH
  0079d	26		 DB	 38			; 00000026H
  0079e	26		 DB	 38			; 00000026H
  0079f	26		 DB	 38			; 00000026H
  007a0	1e		 DB	 30			; 0000001eH
  007a1	26		 DB	 38			; 00000026H
  007a2	26		 DB	 38			; 00000026H
  007a3	26		 DB	 38			; 00000026H
  007a4	1f		 DB	 31			; 0000001fH
  007a5	26		 DB	 38			; 00000026H
  007a6	26		 DB	 38			; 00000026H
  007a7	26		 DB	 38			; 00000026H
  007a8	20		 DB	 32			; 00000020H
  007a9	26		 DB	 38			; 00000026H
  007aa	26		 DB	 38			; 00000026H
  007ab	26		 DB	 38			; 00000026H
  007ac	21		 DB	 33			; 00000021H
  007ad	26		 DB	 38			; 00000026H
  007ae	26		 DB	 38			; 00000026H
  007af	26		 DB	 38			; 00000026H
  007b0	22		 DB	 34			; 00000022H
  007b1	26		 DB	 38			; 00000026H
  007b2	26		 DB	 38			; 00000026H
  007b3	26		 DB	 38			; 00000026H
  007b4	23		 DB	 35			; 00000023H
  007b5	26		 DB	 38			; 00000026H
  007b6	26		 DB	 38			; 00000026H
  007b7	26		 DB	 38			; 00000026H
  007b8	24		 DB	 36			; 00000024H
  007b9	26		 DB	 38			; 00000026H
  007ba	26		 DB	 38			; 00000026H
  007bb	26		 DB	 38			; 00000026H
  007bc	25		 DB	 37			; 00000025H
_TCTranslateCode@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@EIFNDPP@TCDeleteDeviceObject?5END?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EA@FPAPEGHJ@?$AAP?$AAs?$AAD?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAI?$AAm?$AAp?$AAe?$AAr?$AAs?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAk?$AAe?$AAn?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CP@NIIDLADO@IoDeleteSymbolicLink?5failed?5ntSt@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BM@GNHEHBJH@TCDeleteDeviceObject?5BEGIN?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_TCDeleteDeviceObject@8
EXTRN	__imp__SeTokenType@4:PROC
EXTRN	__imp__MmGetSystemRoutineAddress@4:PROC
EXTRN	__imp__IoDeleteSymbolicLink@4:PROC
;	COMDAT ??_C@_0BK@EIFNDPP@TCDeleteDeviceObject?5END?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BK@EIFNDPP@TCDeleteDeviceObject?5END?6?$AA@FNODOBFM@ DB 'TCDeleteD'
	DB	'eviceObject END', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EA@FPAPEGHJ@?$AAP?$AAs?$AAD?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAI?$AAm?$AAp?$AAe?$AAr?$AAs?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAk?$AAe?$AAn?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1EA@FPAPEGHJ@?$AAP?$AAs?$AAD?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAI?$AAm?$AAp?$AAe?$AAr?$AAs?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAk?$AAe?$AAn?$AA?$AA@FNODOBFM@ DB 'P'
	DB	00H, 's', 00H, 'D', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H
	DB	'e', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, 'I'
	DB	00H, 'm', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 's', 00H, 'o', 00H
	DB	'n', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'T'
	DB	00H, 'o', 00H, 'k', 00H, 'e', 00H, 'n', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CP@NIIDLADO@IoDeleteSymbolicLink?5failed?5ntSt@FNODOBFM@
text$s	SEGMENT
??_C@_0CP@NIIDLADO@IoDeleteSymbolicLink?5failed?5ntSt@FNODOBFM@ DB 'IoDel'
	DB	'eteSymbolicLink failed ntStatus = 0x%08x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'T', 00H, 'r'
	DB	00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r', 00H, 'y', 00H, 'p', 00H
	DB	't', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BM@GNHEHBJH@TCDeleteDeviceObject?5BEGIN?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BM@GNHEHBJH@TCDeleteDeviceObject?5BEGIN?6?$AA@FNODOBFM@ DB 'TCDele'
	DB	'teDeviceObject BEGIN', 0aH, 00H		;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _TCDeleteDeviceObject@8
_TEXT	SEGMENT
_PsDereferenceImpersonationTokenD$31013 = -24		; size = 4
_name$31014 = -20					; size = 8
_ntStatus$ = -12					; size = 4
_Win32NameString$ = -8					; size = 8
_DeviceObject$ = 8					; size = 4
_Extension$ = 12					; size = 4
_TCDeleteDeviceObject@8 PROC				; COMDAT

; 2061 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 18	 sub	 esp, 24			; 00000018H

; 2062 : 	UNICODE_STRING Win32NameString;
; 2063 : 	NTSTATUS ntStatus;
; 2064 : 
; 2065 : 	Dump ("TCDeleteDeviceObject BEGIN\n");

  00008	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@GNHEHBJH@TCDeleteDeviceObject?5BEGIN?6?$AA@FNODOBFM@
  0000d	e8 00 00 00 00	 call	 _DbgPrint
  00012	83 c4 04	 add	 esp, 4

; 2066 : 
; 2067 : 	if (Extension->bRootDevice)

  00015	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  00018	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001b	74 42		 je	 SHORT $LN11@TCDeleteDe

; 2068 : 	{
; 2069 : 		RtlInitUnicodeString (&Win32NameString, (LPWSTR) DOS_ROOT_PREFIX);

  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
  00022	8d 4d f8	 lea	 ecx, DWORD PTR _Win32NameString$[ebp]
  00025	51		 push	 ecx
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 2070 : 		ntStatus = IoDeleteSymbolicLink (&Win32NameString);

  0002c	8d 55 f8	 lea	 edx, DWORD PTR _Win32NameString$[ebp]
  0002f	52		 push	 edx
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteSymbolicLink@4
  00036	89 45 f4	 mov	 DWORD PTR _ntStatus$[ebp], eax

; 2071 : 		if (!NT_SUCCESS (ntStatus))

  00039	83 7d f4 00	 cmp	 DWORD PTR _ntStatus$[ebp], 0
  0003d	7d 11		 jge	 SHORT $LN10@TCDeleteDe

; 2072 : 			Dump ("IoDeleteSymbolicLink failed ntStatus = 0x%08x\n", ntStatus);

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _ntStatus$[ebp]
  00042	50		 push	 eax
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@NIIDLADO@IoDeleteSymbolicLink?5failed?5ntSt@FNODOBFM@
  00048	e8 00 00 00 00	 call	 _DbgPrint
  0004d	83 c4 08	 add	 esp, 8
$LN10@TCDeleteDe:

; 2073 : 
; 2074 : 		RootDeviceObject = NULL;

  00050	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _RootDeviceObject, 0

; 2075 : 	}
; 2076 : 	else

  0005a	e9 da 00 00 00	 jmp	 $LN9@TCDeleteDe
$LN11@TCDeleteDe:

; 2077 : 	{
; 2078 : 		if (Extension->peThread != NULL)

  0005f	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00062	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  00066	74 0d		 je	 SHORT $LN8@TCDeleteDe

; 2079 : 			TCStopVolumeThread (DeviceObject, Extension);

  00068	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  0006b	52		 push	 edx
  0006c	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 _TCStopVolumeThread@8
$LN8@TCDeleteDe:

; 2080 : 
; 2081 : 		if (Extension->UserSid)

  00075	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00078	83 b9 cc 04 00
	00 00		 cmp	 DWORD PTR [ecx+1228], 0
  0007f	74 15		 je	 SHORT $LN7@TCDeleteDe

; 2082 : 			TCfree (Extension->UserSid);

  00081	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00086	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  00089	8b 82 cc 04 00
	00		 mov	 eax, DWORD PTR [edx+1228]
  0008f	50		 push	 eax
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN7@TCDeleteDe:

; 2083 : 
; 2084 : 		if (Extension->SecurityClientContextValid)

  00096	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00099	83 b9 d0 04 00
	00 00		 cmp	 DWORD PTR [ecx+1232], 0
  000a0	0f 84 82 00 00
	00		 je	 $LN6@TCDeleteDe

; 2085 : 		{
; 2086 : 			if (OsMajorVersion == 5 && OsMinorVersion == 0)

  000a6	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR _OsMajorVersion, 5
  000ad	75 1a		 jne	 SHORT $LN5@TCDeleteDe
  000af	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _OsMinorVersion, 0
  000b6	75 11		 jne	 SHORT $LN5@TCDeleteDe

; 2087 : 			{
; 2088 : 				ObDereferenceObject (Extension->SecurityClientContext.ClientToken);

  000b8	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  000bb	8b 8a e0 04 00
	00		 mov	 ecx, DWORD PTR [edx+1248]
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 2089 : 			}
; 2090 : 			else

  000c7	eb 5f		 jmp	 SHORT $LN6@TCDeleteDe
$LN5@TCDeleteDe:

; 2091 : 			{
; 2092 : 				// Windows 2000 does not support PsDereferenceImpersonationToken() used by SeDeleteClientSecurity().
; 2093 : 				// TODO: Use only SeDeleteClientSecurity() once support for Windows 2000 is dropped.
; 2094 : 
; 2095 : 				VOID (*PsDereferenceImpersonationTokenD) (PACCESS_TOKEN ImpersonationToken);
; 2096 : 				UNICODE_STRING name;
; 2097 : 				RtlInitUnicodeString (&name, L"PsDereferenceImpersonationToken");

  000c9	68 00 00 00 00	 push	 OFFSET ??_C@_1EA@FPAPEGHJ@?$AAP?$AAs?$AAD?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAI?$AAm?$AAp?$AAe?$AAr?$AAs?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAk?$AAe?$AAn?$AA?$AA@FNODOBFM@
  000ce	8d 45 ec	 lea	 eax, DWORD PTR _name$31014[ebp]
  000d1	50		 push	 eax
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 2098 : 
; 2099 : 				PsDereferenceImpersonationTokenD = MmGetSystemRoutineAddress (&name);

  000d8	8d 4d ec	 lea	 ecx, DWORD PTR _name$31014[ebp]
  000db	51		 push	 ecx
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmGetSystemRoutineAddress@4
  000e2	89 45 e8	 mov	 DWORD PTR _PsDereferenceImpersonationTokenD$31013[ebp], eax

; 2100 : 				if (!PsDereferenceImpersonationTokenD)

  000e5	83 7d e8 00	 cmp	 DWORD PTR _PsDereferenceImpersonationTokenD$31013[ebp], 0
  000e9	75 19		 jne	 SHORT $LN3@TCDeleteDe

; 2101 : 					TC_BUG_CHECK (STATUS_NOT_IMPLEMENTED);

  000eb	68 43 54 00 00	 push	 21571			; 00005443H
  000f0	6a 00		 push	 0
  000f2	68 02 00 00 c0	 push	 -1073741822		; c0000002H
  000f7	68 35 08 00 00	 push	 2101			; 00000835H
  000fc	6a 29		 push	 41			; 00000029H
  000fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN3@TCDeleteDe:

; 2102 : 				
; 2103 : #				define PsDereferencePrimaryToken
; 2104 : #				define PsDereferenceImpersonationToken PsDereferenceImpersonationTokenD
; 2105 : 
; 2106 : 				SeDeleteClientSecurity (&Extension->SecurityClientContext);

  00104	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  00107	8b 82 e0 04 00
	00		 mov	 eax, DWORD PTR [edx+1248]
  0010d	50		 push	 eax
  0010e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeTokenType@4
  00114	83 f8 01	 cmp	 eax, 1
  00117	75 02		 jne	 SHORT $LN2@TCDeleteDe
  00119	eb 0d		 jmp	 SHORT $LN6@TCDeleteDe
$LN2@TCDeleteDe:
  0011b	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0011e	8b 91 e0 04 00
	00		 mov	 edx, DWORD PTR [ecx+1248]
  00124	52		 push	 edx
  00125	ff 55 e8	 call	 DWORD PTR _PsDereferenceImpersonationTokenD$31013[ebp]
$LN6@TCDeleteDe:

; 2107 : 
; 2108 : #				undef PsDereferencePrimaryToken
; 2109 : #				undef PsDereferenceImpersonationToken
; 2110 : 			}
; 2111 : 		}
; 2112 : 
; 2113 : 		VirtualVolumeDeviceObjects[Extension->nDosDriveNo] = NULL;

  00128	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  0012b	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0012e	c7 04 8d 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _VirtualVolumeDeviceObjects[ecx*4], 0
$LN9@TCDeleteDe:

; 2114 : 	}
; 2115 : 
; 2116 : 	IoDeleteDevice (DeviceObject);

  00139	8b 55 08	 mov	 edx, DWORD PTR _DeviceObject$[ebp]
  0013c	52		 push	 edx
  0013d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteDevice@4

; 2117 : 
; 2118 : 	Dump ("TCDeleteDeviceObject END\n");

  00143	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@EIFNDPP@TCDeleteDeviceObject?5END?6?$AA@FNODOBFM@
  00148	e8 00 00 00 00	 call	 _DbgPrint
  0014d	83 c4 04	 add	 esp, 4
$LN13@TCDeleteDe:

; 2119 : }

  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c2 08 00	 ret	 8
_TCDeleteDeviceObject@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@CJGLKHCK@TCUnloadDriver?5END?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BG@MGFDNIAG@TCUnloadDriver?5BEGIN?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	_EncryptionThreadPoolStop@0:PROC
;	COMDAT ??_C@_0BE@CJGLKHCK@TCUnloadDriver?5END?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BE@CJGLKHCK@TCUnloadDriver?5END?6?$AA@FNODOBFM@ DB 'TCUnloadDriver'
	DB	' END', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BG@MGFDNIAG@TCUnloadDriver?5BEGIN?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BG@MGFDNIAG@TCUnloadDriver?5BEGIN?6?$AA@FNODOBFM@ DB 'TCUnloadDriv'
	DB	'er BEGIN', 0aH, 00H				;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _TCUnloadDriver@4
_TEXT	SEGMENT
_DriverObject$ = 8					; size = 4
_TCUnloadDriver@4 PROC					; COMDAT

; 2123 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 2124 : 	Dump ("TCUnloadDriver BEGIN\n");

  00005	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@MGFDNIAG@TCUnloadDriver?5BEGIN?6?$AA@FNODOBFM@
  0000a	e8 00 00 00 00	 call	 _DbgPrint
  0000f	83 c4 04	 add	 esp, 4

; 2125 : 
; 2126 : 	OnShutdownPending();

  00012	e8 00 00 00 00	 call	 _OnShutdownPending@0

; 2127 : 
; 2128 : 	if (IsBootDriveMounted())

  00017	e8 00 00 00 00	 call	 _IsBootDriveMounted@0
  0001c	85 c0		 test	 eax, eax
  0001e	74 19		 je	 SHORT $LN1@TCUnloadDr

; 2129 : 		TC_BUG_CHECK (STATUS_INVALID_DEVICE_STATE);

  00020	68 43 54 00 00	 push	 21571			; 00005443H
  00025	6a 00		 push	 0
  00027	68 84 01 00 c0	 push	 -1073741436		; c0000184H
  0002c	68 51 08 00 00	 push	 2129			; 00000851H
  00031	6a 29		 push	 41			; 00000029H
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN1@TCUnloadDr:

; 2130 : 
; 2131 : 	EncryptionThreadPoolStop();

  00039	e8 00 00 00 00	 call	 _EncryptionThreadPoolStop@0

; 2132 : 	TCDeleteDeviceObject (RootDeviceObject, (PEXTENSION) RootDeviceObject->DeviceExtension);

  0003e	a1 00 00 00 00	 mov	 eax, DWORD PTR _RootDeviceObject
  00043	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00046	51		 push	 ecx
  00047	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _RootDeviceObject
  0004d	52		 push	 edx
  0004e	e8 00 00 00 00	 call	 _TCDeleteDeviceObject@8

; 2133 : 
; 2134 : 	Dump ("TCUnloadDriver END\n");

  00053	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@CJGLKHCK@TCUnloadDriver?5END?6?$AA@FNODOBFM@
  00058	e8 00 00 00 00	 call	 _DbgPrint
  0005d	83 c4 04	 add	 esp, 4
$LN3@TCUnloadDr:

; 2135 : }

  00060	5d		 pop	 ebp
  00061	c2 04 00	 ret	 4
_TCUnloadDriver@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _OnShutdownPending@0
_TEXT	SEGMENT
_unmount$ = -16						; size = 16
_OnShutdownPending@0 PROC				; COMDAT

; 2139 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 10	 sub	 esp, 16			; 00000010H

; 2140 : 	UNMOUNT_STRUCT unmount;
; 2141 : 	memset (&unmount, 0, sizeof (unmount));

  00008	33 c0		 xor	 eax, eax
  0000a	89 45 f0	 mov	 DWORD PTR _unmount$[ebp], eax
  0000d	89 45 f4	 mov	 DWORD PTR _unmount$[ebp+4], eax
  00010	89 45 f8	 mov	 DWORD PTR _unmount$[ebp+8], eax
  00013	89 45 fc	 mov	 DWORD PTR _unmount$[ebp+12], eax

; 2142 : 	unmount.ignoreOpenFiles = TRUE;

  00016	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _unmount$[ebp+4], 1
$LN5@OnShutdown:

; 2143 : 
; 2144 : 	while (SendDeviceIoControlRequest (RootDeviceObject, TC_IOCTL_DISMOUNT_ALL_VOLUMES, &unmount, sizeof (unmount), &unmount, sizeof (unmount)) == STATUS_INSUFFICIENT_RESOURCES || unmount.HiddenVolumeProtectionTriggered)

  0001d	6a 10		 push	 16			; 00000010H
  0001f	8d 4d f0	 lea	 ecx, DWORD PTR _unmount$[ebp]
  00022	51		 push	 ecx
  00023	6a 10		 push	 16			; 00000010H
  00025	8d 55 f0	 lea	 edx, DWORD PTR _unmount$[ebp]
  00028	52		 push	 edx
  00029	68 14 20 22 00	 push	 2236436			; 00222014H
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR _RootDeviceObject
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  00039	3d 9a 00 00 c0	 cmp	 eax, -1073741670	; c000009aH
  0003e	74 06		 je	 SHORT $LN3@OnShutdown
  00040	83 7d f8 00	 cmp	 DWORD PTR _unmount$[ebp+8], 0
  00044	74 09		 je	 SHORT $LN2@OnShutdown
$LN3@OnShutdown:

; 2145 : 		unmount.HiddenVolumeProtectionTriggered = FALSE;

  00046	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _unmount$[ebp+8], 0
  0004d	eb ce		 jmp	 SHORT $LN5@OnShutdown
$LN2@OnShutdown:

; 2146 : 
; 2147 : 	while (SendDeviceIoControlRequest (RootDeviceObject, TC_IOCTL_WIPE_PASSWORD_CACHE, NULL, 0, NULL, 0) == STATUS_INSUFFICIENT_RESOURCES);

  0004f	6a 00		 push	 0
  00051	6a 00		 push	 0
  00053	6a 00		 push	 0
  00055	6a 00		 push	 0
  00057	68 30 20 22 00	 push	 2236464			; 00222030H
  0005c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _RootDeviceObject
  00062	51		 push	 ecx
  00063	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  00068	3d 9a 00 00 c0	 cmp	 eax, -1073741670	; c000009aH
  0006d	75 02		 jne	 SHORT $LN6@OnShutdown
  0006f	eb de		 jmp	 SHORT $LN2@OnShutdown
$LN6@OnShutdown:

; 2148 : }

  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
_OnShutdownPending@0 ENDP
_TEXT	ENDS
PUBLIC	_IoGetNextIrpStackLocation@4
PUBLIC	??_C@_0BH@BPCEMJJB@IRP?5allocation?5failed?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp_@IofCallDriver@8:PROC
EXTRN	__imp__IoBuildDeviceIoControlRequest@36:PROC
;	COMDAT ??_C@_0BH@BPCEMJJB@IRP?5allocation?5failed?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BH@BPCEMJJB@IRP?5allocation?5failed?6?$AA@FNODOBFM@ DB 'IRP alloca'
	DB	'tion failed', 0aH, 00H			;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _TCDeviceIoControl@24
_TEXT	SEGMENT
_event$ = -48						; size = 16
_ioStatusBlock$ = -32					; size = 8
_ntStatus$ = -24					; size = 4
_irp$ = -20						; size = 4
_name$ = -16						; size = 8
_fileObject$ = -8					; size = 4
_deviceObject$ = -4					; size = 4
_deviceName$ = 8					; size = 4
_IoControlCode$ = 12					; size = 4
_InputBuffer$ = 16					; size = 4
_InputBufferSize$ = 20					; size = 4
_OutputBuffer$ = 24					; size = 4
_OutputBufferSize$ = 28					; size = 4
_TCDeviceIoControl@24 PROC				; COMDAT

; 2152 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 30	 sub	 esp, 48			; 00000030H

; 2153 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2154 : 	NTSTATUS ntStatus;
; 2155 : 	PIRP irp;
; 2156 : 	PFILE_OBJECT fileObject;
; 2157 : 	PDEVICE_OBJECT deviceObject;
; 2158 : 	KEVENT event;
; 2159 : 	UNICODE_STRING name;
; 2160 : 
; 2161 : 	RtlInitUnicodeString(&name, deviceName);

  00008	8b 45 08	 mov	 eax, DWORD PTR _deviceName$[ebp]
  0000b	50		 push	 eax
  0000c	8d 4d f0	 lea	 ecx, DWORD PTR _name$[ebp]
  0000f	51		 push	 ecx
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 2162 : 	ntStatus = IoGetDeviceObjectPointer (&name, FILE_READ_ATTRIBUTES, &fileObject, &deviceObject);

  00016	8d 55 fc	 lea	 edx, DWORD PTR _deviceObject$[ebp]
  00019	52		 push	 edx
  0001a	8d 45 f8	 lea	 eax, DWORD PTR _fileObject$[ebp]
  0001d	50		 push	 eax
  0001e	68 80 00 00 00	 push	 128			; 00000080H
  00023	8d 4d f0	 lea	 ecx, DWORD PTR _name$[ebp]
  00026	51		 push	 ecx
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoGetDeviceObjectPointer@16
  0002d	89 45 e8	 mov	 DWORD PTR _ntStatus$[ebp], eax

; 2163 : 
; 2164 : 	if (!NT_SUCCESS (ntStatus))

  00030	83 7d e8 00	 cmp	 DWORD PTR _ntStatus$[ebp], 0
  00034	7d 08		 jge	 SHORT $LN3@TCDeviceIo

; 2165 : 		return ntStatus;

  00036	8b 45 e8	 mov	 eax, DWORD PTR _ntStatus$[ebp]
  00039	e9 a0 00 00 00	 jmp	 $LN4@TCDeviceIo
$LN3@TCDeviceIo:

; 2166 : 
; 2167 : 	KeInitializeEvent(&event, NotificationEvent, FALSE);

  0003e	6a 00		 push	 0
  00040	6a 00		 push	 0
  00042	8d 55 d0	 lea	 edx, DWORD PTR _event$[ebp]
  00045	52		 push	 edx
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 2168 : 
; 2169 : 	irp = IoBuildDeviceIoControlRequest (IoControlCode,
; 2170 : 					     deviceObject,
; 2171 : 					     InputBuffer, InputBufferSize,
; 2172 : 					     OutputBuffer, OutputBufferSize,
; 2173 : 					     FALSE,
; 2174 : 					     &event,
; 2175 : 					     &ioStatusBlock);

  0004c	8d 45 e0	 lea	 eax, DWORD PTR _ioStatusBlock$[ebp]
  0004f	50		 push	 eax
  00050	8d 4d d0	 lea	 ecx, DWORD PTR _event$[ebp]
  00053	51		 push	 ecx
  00054	6a 00		 push	 0
  00056	8b 55 1c	 mov	 edx, DWORD PTR _OutputBufferSize$[ebp]
  00059	52		 push	 edx
  0005a	8b 45 18	 mov	 eax, DWORD PTR _OutputBuffer$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d 14	 mov	 ecx, DWORD PTR _InputBufferSize$[ebp]
  00061	51		 push	 ecx
  00062	8b 55 10	 mov	 edx, DWORD PTR _InputBuffer$[ebp]
  00065	52		 push	 edx
  00066	8b 45 fc	 mov	 eax, DWORD PTR _deviceObject$[ebp]
  00069	50		 push	 eax
  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR _IoControlCode$[ebp]
  0006d	51		 push	 ecx
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36
  00074	89 45 ec	 mov	 DWORD PTR _irp$[ebp], eax

; 2176 : 
; 2177 : 	if (irp == NULL)

  00077	83 7d ec 00	 cmp	 DWORD PTR _irp$[ebp], 0
  0007b	75 16		 jne	 SHORT $LN2@TCDeviceIo

; 2178 : 	{
; 2179 : 		Dump ("IRP allocation failed\n");

  0007d	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@BPCEMJJB@IRP?5allocation?5failed?6?$AA@FNODOBFM@
  00082	e8 00 00 00 00	 call	 _DbgPrint
  00087	83 c4 04	 add	 esp, 4

; 2180 : 		ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0008a	c7 45 e8 9a 00
	00 c0		 mov	 DWORD PTR _ntStatus$[ebp], -1073741670 ; c000009aH

; 2181 : 		goto ret;

  00091	eb 3f		 jmp	 SHORT $ret$31073
$LN2@TCDeviceIo:

; 2182 : 	}
; 2183 : 
; 2184 : 	IoGetNextIrpStackLocation (irp)->FileObject = fileObject;

  00093	8b 55 ec	 mov	 edx, DWORD PTR _irp$[ebp]
  00096	52		 push	 edx
  00097	e8 00 00 00 00	 call	 _IoGetNextIrpStackLocation@4
  0009c	8b 4d f8	 mov	 ecx, DWORD PTR _fileObject$[ebp]
  0009f	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 2185 : 
; 2186 : 	ntStatus = IoCallDriver (deviceObject, irp);

  000a2	8b 55 ec	 mov	 edx, DWORD PTR _irp$[ebp]
  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _deviceObject$[ebp]
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8
  000ae	89 45 e8	 mov	 DWORD PTR _ntStatus$[ebp], eax

; 2187 : 	if (ntStatus == STATUS_PENDING)

  000b1	81 7d e8 03 01
	00 00		 cmp	 DWORD PTR _ntStatus$[ebp], 259 ; 00000103H
  000b8	75 18		 jne	 SHORT $ret$31073

; 2188 : 	{
; 2189 : 		KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);

  000ba	6a 00		 push	 0
  000bc	6a 00		 push	 0
  000be	6a 00		 push	 0
  000c0	6a 00		 push	 0
  000c2	8d 55 d0	 lea	 edx, DWORD PTR _event$[ebp]
  000c5	52		 push	 edx
  000c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 2190 : 		ntStatus = ioStatusBlock.Status;

  000cc	8b 45 e0	 mov	 eax, DWORD PTR _ioStatusBlock$[ebp]
  000cf	89 45 e8	 mov	 DWORD PTR _ntStatus$[ebp], eax
$ret$31073:

; 2191 : 	}
; 2192 : 
; 2193 : ret:
; 2194 : 	ObDereferenceObject (fileObject);

  000d2	8b 4d f8	 mov	 ecx, DWORD PTR _fileObject$[ebp]
  000d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 2195 : 	return ntStatus;

  000db	8b 45 e8	 mov	 eax, DWORD PTR _ntStatus$[ebp]
$LN4@TCDeviceIo:

; 2196 : }

  000de	8b e5		 mov	 esp, ebp
  000e0	5d		 pop	 ebp
  000e1	c2 18 00	 ret	 24			; 00000018H
_TCDeviceIoControl@24 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
text$s	SEGMENT
??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@ DB 'Irp'
	DB	'->CurrentLocation > 0', 00H			;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _IoGetNextIrpStackLocation@4
_TEXT	SEGMENT
tv71 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoGetNextIrpStackLocation@4 PROC			; COMDAT

; 23479: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 23480:     ASSERT(Irp->CurrentLocation > 0);

  00006	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00009	0f be 48 23	 movsx	 ecx, BYTE PTR [eax+35]
  0000d	85 c9		 test	 ecx, ecx
  0000f	7f 20		 jg	 SHORT $LN3@IoGetNextI
  00011	6a 00		 push	 0
  00013	68 b8 5b 00 00	 push	 23480			; 00005bb8H
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
  0002f	eb 07		 jmp	 SHORT $LN4@IoGetNextI
$LN3@IoGetNextI:
  00031	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
$LN4@IoGetNextI:

; 23481: 
; 23482:     return ((Irp)->Tail.Overlay.CurrentStackLocation - 1 );

  00038	8b 55 08	 mov	 edx, DWORD PTR _Irp$[ebp]
  0003b	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  0003e	83 e8 24	 sub	 eax, 36			; 00000024H

; 23483: }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
_IoGetNextIrpStackLocation@4 ENDP
_TEXT	ENDS
EXTRN	__imp_@ObfReferenceObject@4:PROC
EXTRN	__imp__IoFreeWorkItem@4:PROC
EXTRN	__imp__IoQueueWorkItem@16:PROC
EXTRN	__imp__IoAllocateWorkItem@4:PROC
; Function compile flags: /Odtp
; File c:\users\public\desktop\projects\ciphershed\src\driver\ntdriver.c
;	COMDAT _SendDeviceIoControlRequest@24
_TEXT	SEGMENT
_workItem$31112 = -80					; size = 4
_args$31111 = -76					; size = 44
_status$ = -32						; size = 4
_event$ = -28						; size = 16
_ioStatusBlock$ = -12					; size = 8
_irp$ = -4						; size = 4
_deviceObject$ = 8					; size = 4
_ioControlCode$ = 12					; size = 4
_inputBuffer$ = 16					; size = 4
_inputBufferSize$ = 20					; size = 4
_outputBuffer$ = 24					; size = 4
_outputBufferSize$ = 28					; size = 4
_SendDeviceIoControlRequest@24 PROC			; COMDAT

; 2215 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 50	 sub	 esp, 80			; 00000050H

; 2216 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2217 : 	NTSTATUS status;
; 2218 : 	PIRP irp;
; 2219 : 	KEVENT event;
; 2220 : 
; 2221 : 	if (KeGetCurrentIrql() > APC_LEVEL)

  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeGetCurrentIrql@0
  0000e	0f b6 c0	 movzx	 eax, al
  00011	83 f8 01	 cmp	 eax, 1
  00014	0f 8e 8b 00 00
	00		 jle	 $LN4@SendDevice

; 2222 : 	{
; 2223 : 		SendDeviceIoControlRequestWorkItemArgs args;
; 2224 : 
; 2225 : 		PIO_WORKITEM workItem = IoAllocateWorkItem (RootDeviceObject);

  0001a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _RootDeviceObject
  00020	51		 push	 ecx
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAllocateWorkItem@4
  00027	89 45 b0	 mov	 DWORD PTR _workItem$31112[ebp], eax

; 2226 : 		if (!workItem)

  0002a	83 7d b0 00	 cmp	 DWORD PTR _workItem$31112[ebp], 0
  0002e	75 0a		 jne	 SHORT $LN3@SendDevice

; 2227 : 			return STATUS_INSUFFICIENT_RESOURCES;

  00030	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  00035	e9 f6 00 00 00	 jmp	 $LN5@SendDevice
$LN3@SendDevice:

; 2228 : 
; 2229 : 		args.deviceObject = deviceObject;

  0003a	8b 55 08	 mov	 edx, DWORD PTR _deviceObject$[ebp]
  0003d	89 55 b4	 mov	 DWORD PTR _args$31111[ebp], edx

; 2230 : 		args.ioControlCode = ioControlCode;

  00040	8b 45 0c	 mov	 eax, DWORD PTR _ioControlCode$[ebp]
  00043	89 45 b8	 mov	 DWORD PTR _args$31111[ebp+4], eax

; 2231 : 		args.inputBuffer = inputBuffer;

  00046	8b 4d 10	 mov	 ecx, DWORD PTR _inputBuffer$[ebp]
  00049	89 4d bc	 mov	 DWORD PTR _args$31111[ebp+8], ecx

; 2232 : 		args.inputBufferSize = inputBufferSize;

  0004c	8b 55 14	 mov	 edx, DWORD PTR _inputBufferSize$[ebp]
  0004f	89 55 c0	 mov	 DWORD PTR _args$31111[ebp+12], edx

; 2233 : 		args.outputBuffer = outputBuffer;

  00052	8b 45 18	 mov	 eax, DWORD PTR _outputBuffer$[ebp]
  00055	89 45 c4	 mov	 DWORD PTR _args$31111[ebp+16], eax

; 2234 : 		args.outputBufferSize = outputBufferSize;

  00058	8b 4d 1c	 mov	 ecx, DWORD PTR _outputBufferSize$[ebp]
  0005b	89 4d c8	 mov	 DWORD PTR _args$31111[ebp+20], ecx

; 2235 : 
; 2236 : 		KeInitializeEvent (&args.WorkItemCompletedEvent, SynchronizationEvent, FALSE);

  0005e	6a 00		 push	 0
  00060	6a 01		 push	 1
  00062	8d 55 d0	 lea	 edx, DWORD PTR _args$31111[ebp+28]
  00065	52		 push	 edx
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 2237 : 		IoQueueWorkItem (workItem, SendDeviceIoControlRequestWorkItemRoutine, DelayedWorkQueue, &args); 

  0006c	8d 45 b4	 lea	 eax, DWORD PTR _args$31111[ebp]
  0006f	50		 push	 eax
  00070	6a 01		 push	 1
  00072	68 00 00 00 00	 push	 OFFSET _SendDeviceIoControlRequestWorkItemRoutine@8
  00077	8b 4d b0	 mov	 ecx, DWORD PTR _workItem$31112[ebp]
  0007a	51		 push	 ecx
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoQueueWorkItem@16

; 2238 : 
; 2239 : 		KeWaitForSingleObject (&args.WorkItemCompletedEvent, Executive, KernelMode, FALSE, NULL);

  00081	6a 00		 push	 0
  00083	6a 00		 push	 0
  00085	6a 00		 push	 0
  00087	6a 00		 push	 0
  00089	8d 55 d0	 lea	 edx, DWORD PTR _args$31111[ebp+28]
  0008c	52		 push	 edx
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 2240 : 		IoFreeWorkItem (workItem);

  00093	8b 45 b0	 mov	 eax, DWORD PTR _workItem$31112[ebp]
  00096	50		 push	 eax
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoFreeWorkItem@4

; 2241 :  
; 2242 : 		return args.Status;

  0009d	8b 45 cc	 mov	 eax, DWORD PTR _args$31111[ebp+24]
  000a0	e9 8b 00 00 00	 jmp	 $LN5@SendDevice
$LN4@SendDevice:

; 2243 : 	}
; 2244 : 
; 2245 : 	KeInitializeEvent (&event, NotificationEvent, FALSE);

  000a5	6a 00		 push	 0
  000a7	6a 00		 push	 0
  000a9	8d 4d e4	 lea	 ecx, DWORD PTR _event$[ebp]
  000ac	51		 push	 ecx
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 2246 : 
; 2247 : 	irp = IoBuildDeviceIoControlRequest (ioControlCode, deviceObject, inputBuffer, inputBufferSize,
; 2248 : 		outputBuffer, outputBufferSize, FALSE, &event, &ioStatusBlock);

  000b3	8d 55 f4	 lea	 edx, DWORD PTR _ioStatusBlock$[ebp]
  000b6	52		 push	 edx
  000b7	8d 45 e4	 lea	 eax, DWORD PTR _event$[ebp]
  000ba	50		 push	 eax
  000bb	6a 00		 push	 0
  000bd	8b 4d 1c	 mov	 ecx, DWORD PTR _outputBufferSize$[ebp]
  000c0	51		 push	 ecx
  000c1	8b 55 18	 mov	 edx, DWORD PTR _outputBuffer$[ebp]
  000c4	52		 push	 edx
  000c5	8b 45 14	 mov	 eax, DWORD PTR _inputBufferSize$[ebp]
  000c8	50		 push	 eax
  000c9	8b 4d 10	 mov	 ecx, DWORD PTR _inputBuffer$[ebp]
  000cc	51		 push	 ecx
  000cd	8b 55 08	 mov	 edx, DWORD PTR _deviceObject$[ebp]
  000d0	52		 push	 edx
  000d1	8b 45 0c	 mov	 eax, DWORD PTR _ioControlCode$[ebp]
  000d4	50		 push	 eax
  000d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36
  000db	89 45 fc	 mov	 DWORD PTR _irp$[ebp], eax

; 2249 : 
; 2250 : 	if (!irp)

  000de	83 7d fc 00	 cmp	 DWORD PTR _irp$[ebp], 0
  000e2	75 07		 jne	 SHORT $LN2@SendDevice

; 2251 : 		return STATUS_INSUFFICIENT_RESOURCES;

  000e4	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  000e9	eb 45		 jmp	 SHORT $LN5@SendDevice
$LN2@SendDevice:

; 2252 : 
; 2253 : 	ObReferenceObject (deviceObject);

  000eb	8b 4d 08	 mov	 ecx, DWORD PTR _deviceObject$[ebp]
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfReferenceObject@4

; 2254 : 
; 2255 : 	status = IoCallDriver (deviceObject, irp);

  000f4	8b 55 fc	 mov	 edx, DWORD PTR _irp$[ebp]
  000f7	8b 4d 08	 mov	 ecx, DWORD PTR _deviceObject$[ebp]
  000fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8
  00100	89 45 e0	 mov	 DWORD PTR _status$[ebp], eax

; 2256 : 	if (status == STATUS_PENDING)

  00103	81 7d e0 03 01
	00 00		 cmp	 DWORD PTR _status$[ebp], 259 ; 00000103H
  0010a	75 18		 jne	 SHORT $LN1@SendDevice

; 2257 : 	{
; 2258 : 		KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);

  0010c	6a 00		 push	 0
  0010e	6a 00		 push	 0
  00110	6a 00		 push	 0
  00112	6a 00		 push	 0
  00114	8d 4d e4	 lea	 ecx, DWORD PTR _event$[ebp]
  00117	51		 push	 ecx
  00118	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 2259 : 		status = ioStatusBlock.Status;

  0011e	8b 55 f4	 mov	 edx, DWORD PTR _ioStatusBlock$[ebp]
  00121	89 55 e0	 mov	 DWORD PTR _status$[ebp], edx
$LN1@SendDevice:

; 2260 : 	}
; 2261 : 
; 2262 : 	ObDereferenceObject (deviceObject);

  00124	8b 4d 08	 mov	 ecx, DWORD PTR _deviceObject$[ebp]
  00127	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 2263 : 	return status;

  0012d	8b 45 e0	 mov	 eax, DWORD PTR _status$[ebp]
$LN5@SendDevice:

; 2264 : }

  00130	8b e5		 mov	 esp, ebp
  00132	5d		 pop	 ebp
  00133	c2 18 00	 ret	 24			; 00000018H
_SendDeviceIoControlRequest@24 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _SendDeviceIoControlRequestWorkItemRoutine@8
_TEXT	SEGMENT
_rootDeviceObject$ = 8					; size = 4
_arg$ = 12						; size = 4
_SendDeviceIoControlRequestWorkItemRoutine@8 PROC	; COMDAT

; 2208 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 2209 : 	arg->Status = SendDeviceIoControlRequest (arg->deviceObject, arg->ioControlCode, arg->inputBuffer, arg->inputBufferSize, arg->outputBuffer, arg->outputBufferSize);

  00005	8b 45 0c	 mov	 eax, DWORD PTR _arg$[ebp]
  00008	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0000b	51		 push	 ecx
  0000c	8b 55 0c	 mov	 edx, DWORD PTR _arg$[ebp]
  0000f	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _arg$[ebp]
  00016	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00019	52		 push	 edx
  0001a	8b 45 0c	 mov	 eax, DWORD PTR _arg$[ebp]
  0001d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00020	51		 push	 ecx
  00021	8b 55 0c	 mov	 edx, DWORD PTR _arg$[ebp]
  00024	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00027	50		 push	 eax
  00028	8b 4d 0c	 mov	 ecx, DWORD PTR _arg$[ebp]
  0002b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  00033	8b 4d 0c	 mov	 ecx, DWORD PTR _arg$[ebp]
  00036	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 2210 : 	KeSetEvent (&arg->WorkItemCompletedEvent, IO_NO_INCREMENT, FALSE);

  00039	6a 00		 push	 0
  0003b	6a 00		 push	 0
  0003d	8b 55 0c	 mov	 edx, DWORD PTR _arg$[ebp]
  00040	83 c2 1c	 add	 edx, 28			; 0000001cH
  00043	52		 push	 edx
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 2211 : }

  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
_SendDeviceIoControlRequestWorkItemRoutine@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CO@FHHNLLNJ@Real?5drive?5size?5?$DN?5?$CFI64d?5bytes?5?$CI?$CF@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_TCWriteDevice@20
PUBLIC	_TCReadDevice@20
PUBLIC	??_C@_0CF@BFNPLHIK@Failed?5to?5get?5drive?5size?5?9?5error@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp__KeQueryInterruptTime@0:PROC
;	COMDAT ??_C@_0CO@FHHNLLNJ@Real?5drive?5size?5?$DN?5?$CFI64d?5bytes?5?$CI?$CF@FNODOBFM@
text$s	SEGMENT
??_C@_0CO@FHHNLLNJ@Real?5drive?5size?5?$DN?5?$CFI64d?5bytes?5?$CI?$CF@FNODOBFM@ DB 'R'
	DB	'eal drive size = %I64d bytes (%I64d hidden)', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CF@BFNPLHIK@Failed?5to?5get?5drive?5size?5?9?5error@FNODOBFM@
text$s	SEGMENT
??_C@_0CF@BFNPLHIK@Failed?5to?5get?5drive?5size?5?9?5error@FNODOBFM@ DB 'F'
	DB	'ailed to get drive size - error %x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _ProbeRealDriveSize@8
_TEXT	SEGMENT
tv205 = -44						; size = 8
_status$ = -36						; size = 4
_startTime$ = -32					; size = 8
_offset$ = -24						; size = 8
_sectorBuffer$ = -12					; size = 4
_sysLength$ = -8					; size = 8
_driveDeviceObject$ = 8					; size = 4
_driveSize$ = 12					; size = 4
_ProbeRealDriveSize@8 PROC				; COMDAT

; 2268 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 2269 : 	NTSTATUS status;
; 2270 : 	LARGE_INTEGER sysLength;
; 2271 : 	LARGE_INTEGER offset;
; 2272 : 	byte *sectorBuffer;
; 2273 : 	ULONGLONG startTime;
; 2274 : 
; 2275 : 	if (!UserCanAccessDriveDevice())

  00008	e8 00 00 00 00	 call	 _UserCanAccessDriveDevice@0
  0000d	85 c0		 test	 eax, eax
  0000f	75 0a		 jne	 SHORT $LN9@ProbeRealD

; 2276 : 		return STATUS_ACCESS_DENIED;

  00011	b8 22 00 00 c0	 mov	 eax, -1073741790	; c0000022H
  00016	e9 74 01 00 00	 jmp	 $LN10@ProbeRealD
$LN9@ProbeRealD:

; 2277 : 
; 2278 : 	sectorBuffer = TCalloc (TC_SECTOR_SIZE_BIOS);

  0001b	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00020	68 00 02 00 00	 push	 512			; 00000200H
  00025	6a 00		 push	 0
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0002d	89 45 f4	 mov	 DWORD PTR _sectorBuffer$[ebp], eax

; 2279 : 	if (!sectorBuffer)

  00030	83 7d f4 00	 cmp	 DWORD PTR _sectorBuffer$[ebp], 0
  00034	75 0a		 jne	 SHORT $LN8@ProbeRealD

; 2280 : 		return STATUS_INSUFFICIENT_RESOURCES;

  00036	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  0003b	e9 4f 01 00 00	 jmp	 $LN10@ProbeRealD
$LN8@ProbeRealD:

; 2281 : 
; 2282 : 	status = SendDeviceIoControlRequest (driveDeviceObject, IOCTL_DISK_GET_LENGTH_INFO,
; 2283 : 		NULL, 0, &sysLength, sizeof (sysLength));

  00040	6a 08		 push	 8
  00042	8d 45 f8	 lea	 eax, DWORD PTR _sysLength$[ebp]
  00045	50		 push	 eax
  00046	6a 00		 push	 0
  00048	6a 00		 push	 0
  0004a	68 5c 40 07 00	 push	 475228			; 0007405cH
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _driveDeviceObject$[ebp]
  00052	51		 push	 ecx
  00053	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  00058	89 45 dc	 mov	 DWORD PTR _status$[ebp], eax

; 2284 : 
; 2285 : 	if (!NT_SUCCESS (status))

  0005b	83 7d dc 00	 cmp	 DWORD PTR _status$[ebp], 0
  0005f	7d 28		 jge	 SHORT $LN7@ProbeRealD

; 2286 : 	{
; 2287 : 		Dump ("Failed to get drive size - error %x\n", status);

  00061	8b 55 dc	 mov	 edx, DWORD PTR _status$[ebp]
  00064	52		 push	 edx
  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@BFNPLHIK@Failed?5to?5get?5drive?5size?5?9?5error@FNODOBFM@
  0006a	e8 00 00 00 00	 call	 _DbgPrint
  0006f	83 c4 08	 add	 esp, 8

; 2288 : 		TCfree (sectorBuffer);

  00072	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00077	8b 45 f4	 mov	 eax, DWORD PTR _sectorBuffer$[ebp]
  0007a	50		 push	 eax
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 2289 : 		return status;

  00081	8b 45 dc	 mov	 eax, DWORD PTR _status$[ebp]
  00084	e9 06 01 00 00	 jmp	 $LN10@ProbeRealD
$LN7@ProbeRealD:

; 2290 : 	}
; 2291 : 
; 2292 : 	startTime = KeQueryInterruptTime ();

  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeQueryInterruptTime@0
  0008f	89 45 e0	 mov	 DWORD PTR _startTime$[ebp], eax
  00092	89 55 e4	 mov	 DWORD PTR _startTime$[ebp+4], edx

; 2293 : 	for (offset.QuadPart = sysLength.QuadPart; ; offset.QuadPart += TC_SECTOR_SIZE_BIOS)

  00095	8b 4d f8	 mov	 ecx, DWORD PTR _sysLength$[ebp]
  00098	89 4d e8	 mov	 DWORD PTR _offset$[ebp], ecx
  0009b	8b 55 fc	 mov	 edx, DWORD PTR _sysLength$[ebp+4]
  0009e	89 55 ec	 mov	 DWORD PTR _offset$[ebp+4], edx
  000a1	eb 14		 jmp	 SHORT $LN6@ProbeRealD
$LN5@ProbeRealD:
  000a3	8b 45 e8	 mov	 eax, DWORD PTR _offset$[ebp]
  000a6	05 00 02 00 00	 add	 eax, 512		; 00000200H
  000ab	8b 4d ec	 mov	 ecx, DWORD PTR _offset$[ebp+4]
  000ae	83 d1 00	 adc	 ecx, 0
  000b1	89 45 e8	 mov	 DWORD PTR _offset$[ebp], eax
  000b4	89 4d ec	 mov	 DWORD PTR _offset$[ebp+4], ecx
$LN6@ProbeRealD:

; 2294 : 	{
; 2295 : 		status = TCReadDevice (driveDeviceObject, sectorBuffer, offset, TC_SECTOR_SIZE_BIOS);

  000b7	68 00 02 00 00	 push	 512			; 00000200H
  000bc	8b 55 ec	 mov	 edx, DWORD PTR _offset$[ebp+4]
  000bf	52		 push	 edx
  000c0	8b 45 e8	 mov	 eax, DWORD PTR _offset$[ebp]
  000c3	50		 push	 eax
  000c4	8b 4d f4	 mov	 ecx, DWORD PTR _sectorBuffer$[ebp]
  000c7	51		 push	 ecx
  000c8	8b 55 08	 mov	 edx, DWORD PTR _driveDeviceObject$[ebp]
  000cb	52		 push	 edx
  000cc	e8 00 00 00 00	 call	 _TCReadDevice@20
  000d1	89 45 dc	 mov	 DWORD PTR _status$[ebp], eax

; 2296 : 		
; 2297 : 		if (NT_SUCCESS (status))

  000d4	83 7d dc 00	 cmp	 DWORD PTR _status$[ebp], 0
  000d8	7c 1d		 jl	 SHORT $LN3@ProbeRealD

; 2298 : 			status = TCWriteDevice (driveDeviceObject, sectorBuffer, offset, TC_SECTOR_SIZE_BIOS);

  000da	68 00 02 00 00	 push	 512			; 00000200H
  000df	8b 45 ec	 mov	 eax, DWORD PTR _offset$[ebp+4]
  000e2	50		 push	 eax
  000e3	8b 4d e8	 mov	 ecx, DWORD PTR _offset$[ebp]
  000e6	51		 push	 ecx
  000e7	8b 55 f4	 mov	 edx, DWORD PTR _sectorBuffer$[ebp]
  000ea	52		 push	 edx
  000eb	8b 45 08	 mov	 eax, DWORD PTR _driveDeviceObject$[ebp]
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 _TCWriteDevice@20
  000f4	89 45 dc	 mov	 DWORD PTR _status$[ebp], eax
$LN3@ProbeRealD:

; 2299 : 
; 2300 : 		if (!NT_SUCCESS (status))

  000f7	83 7d dc 00	 cmp	 DWORD PTR _status$[ebp], 0
  000fb	7d 48		 jge	 SHORT $LN2@ProbeRealD

; 2301 : 		{
; 2302 : 			driveSize->QuadPart = offset.QuadPart;

  000fd	8b 4d 0c	 mov	 ecx, DWORD PTR _driveSize$[ebp]
  00100	8b 55 e8	 mov	 edx, DWORD PTR _offset$[ebp]
  00103	89 11		 mov	 DWORD PTR [ecx], edx
  00105	8b 45 ec	 mov	 eax, DWORD PTR _offset$[ebp+4]
  00108	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 2303 : 			Dump ("Real drive size = %I64d bytes (%I64d hidden)\n", driveSize->QuadPart, driveSize->QuadPart - sysLength.QuadPart);

  0010b	8b 4d 0c	 mov	 ecx, DWORD PTR _driveSize$[ebp]
  0010e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00110	2b 55 f8	 sub	 edx, DWORD PTR _sysLength$[ebp]
  00113	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00116	1b 45 fc	 sbb	 eax, DWORD PTR _sysLength$[ebp+4]
  00119	50		 push	 eax
  0011a	52		 push	 edx
  0011b	8b 4d 0c	 mov	 ecx, DWORD PTR _driveSize$[ebp]
  0011e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00121	52		 push	 edx
  00122	8b 01		 mov	 eax, DWORD PTR [ecx]
  00124	50		 push	 eax
  00125	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@FHHNLLNJ@Real?5drive?5size?5?$DN?5?$CFI64d?5bytes?5?$CI?$CF@FNODOBFM@
  0012a	e8 00 00 00 00	 call	 _DbgPrint
  0012f	83 c4 14	 add	 esp, 20			; 00000014H

; 2304 : 			TCfree (sectorBuffer);

  00132	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00137	8b 4d f4	 mov	 ecx, DWORD PTR _sectorBuffer$[ebp]
  0013a	51		 push	 ecx
  0013b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 2305 : 			return STATUS_SUCCESS;

  00141	33 c0		 xor	 eax, eax
  00143	eb 4a		 jmp	 SHORT $LN10@ProbeRealD
$LN2@ProbeRealD:

; 2306 : 		}
; 2307 : 
; 2308 : 		if (KeQueryInterruptTime() - startTime > 3ULL * 60 * 1000 * 1000 * 10)

  00145	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeQueryInterruptTime@0
  0014b	2b 45 e0	 sub	 eax, DWORD PTR _startTime$[ebp]
  0014e	1b 55 e4	 sbb	 edx, DWORD PTR _startTime$[ebp+4]
  00151	89 45 d4	 mov	 DWORD PTR tv205[ebp], eax
  00154	89 55 d8	 mov	 DWORD PTR tv205[ebp+4], edx
  00157	83 7d d8 00	 cmp	 DWORD PTR tv205[ebp+4], 0
  0015b	77 09		 ja	 SHORT $LN12@ProbeRealD
  0015d	81 7d d4 00 d2
	49 6b		 cmp	 DWORD PTR tv205[ebp], 1800000000 ; 6b49d200H
  00164	76 24		 jbe	 SHORT $LN1@ProbeRealD
$LN12@ProbeRealD:

; 2309 : 		{
; 2310 : 			// Abort if probing for more than 3 minutes
; 2311 : 			driveSize->QuadPart = sysLength.QuadPart;

  00166	8b 55 0c	 mov	 edx, DWORD PTR _driveSize$[ebp]
  00169	8b 45 f8	 mov	 eax, DWORD PTR _sysLength$[ebp]
  0016c	89 02		 mov	 DWORD PTR [edx], eax
  0016e	8b 4d fc	 mov	 ecx, DWORD PTR _sysLength$[ebp+4]
  00171	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 2312 : 			TCfree (sectorBuffer);

  00174	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00179	8b 55 f4	 mov	 edx, DWORD PTR _sectorBuffer$[ebp]
  0017c	52		 push	 edx
  0017d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 2313 : 			return STATUS_TIMEOUT;

  00183	b8 02 01 00 00	 mov	 eax, 258		; 00000102H
  00188	eb 05		 jmp	 SHORT $LN10@ProbeRealD
$LN1@ProbeRealD:

; 2314 : 		}
; 2315 : 	}

  0018a	e9 14 ff ff ff	 jmp	 $LN5@ProbeRealD
$LN10@ProbeRealD:

; 2316 : }

  0018f	8b e5		 mov	 esp, ebp
  00191	5d		 pop	 ebp
  00192	c2 08 00	 ret	 8
_ProbeRealDriveSize@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@JIDCFMLM@Volume?5?$CFls?5open?5NTSTATUS?50x?$CF08x?6@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	__$ArrayPad$
PUBLIC	_TCOpenFsVolume@12
;	COMDAT ??_C@_0CB@JIDCFMLM@Volume?5?$CFls?5open?5NTSTATUS?50x?$CF08x?6@FNODOBFM@
text$s	SEGMENT
??_C@_0CB@JIDCFMLM@Volume?5?$CFls?5open?5NTSTATUS?50x?$CF08x?6@FNODOBFM@ DB 'V'
	DB	'olume %ls open NTSTATUS 0x%08x', 0aH, 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _TCOpenFsVolume@12
_TEXT	SEGMENT
_ioStatus$ = -572					; size = 8
_fullFileName$ = -564					; size = 8
_ntStatus$ = -556					; size = 4
_volumeName$ = -552					; size = 520
__$ArrayPad$ = -28					; size = 4
_objectAttributes$ = -24				; size = 24
_Extension$ = 8						; size = 4
_volumeHandle$ = 12					; size = 4
_fileObject$ = 16					; size = 4
_TCOpenFsVolume@12 PROC					; COMDAT

; 2320 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 3c 02 00
	00		 sub	 esp, 572		; 0000023cH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 e4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2321 : 	NTSTATUS ntStatus;
; 2322 : 	OBJECT_ATTRIBUTES objectAttributes;
; 2323 : 	UNICODE_STRING fullFileName;
; 2324 : 	IO_STATUS_BLOCK ioStatus;
; 2325 : 	WCHAR volumeName[TC_MAX_PATH];
; 2326 : 
; 2327 : 	TCGetNTNameFromNumber (volumeName, Extension->nDosDriveNo);

  00015	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  00018	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0001b	51		 push	 ecx
  0001c	8d 95 d8 fd ff
	ff		 lea	 edx, DWORD PTR _volumeName$[ebp]
  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 _TCGetNTNameFromNumber@8

; 2328 : 	RtlInitUnicodeString (&fullFileName, volumeName);

  00028	8d 85 d8 fd ff
	ff		 lea	 eax, DWORD PTR _volumeName$[ebp]
  0002e	50		 push	 eax
  0002f	8d 8d cc fd ff
	ff		 lea	 ecx, DWORD PTR _fullFileName$[ebp]
  00035	51		 push	 ecx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 2329 : 	InitializeObjectAttributes (&objectAttributes, &fullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

  0003c	c7 45 e8 18 00
	00 00		 mov	 DWORD PTR _objectAttributes$[ebp], 24 ; 00000018H
  00043	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _objectAttributes$[ebp+4], 0
  0004a	c7 45 f4 40 02
	00 00		 mov	 DWORD PTR _objectAttributes$[ebp+12], 576 ; 00000240H
  00051	8d 95 cc fd ff
	ff		 lea	 edx, DWORD PTR _fullFileName$[ebp]
  00057	89 55 f0	 mov	 DWORD PTR _objectAttributes$[ebp+8], edx
  0005a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _objectAttributes$[ebp+16], 0
  00061	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _objectAttributes$[ebp+20], 0

; 2330 : 
; 2331 : 	ntStatus = ZwCreateFile (volumeHandle,
; 2332 : 		SYNCHRONIZE | GENERIC_READ,
; 2333 : 		&objectAttributes,
; 2334 : 		&ioStatus,
; 2335 : 		NULL,
; 2336 : 		FILE_ATTRIBUTE_NORMAL,
; 2337 : 		FILE_SHARE_READ | FILE_SHARE_WRITE,
; 2338 : 		FILE_OPEN,
; 2339 : 		FILE_SYNCHRONOUS_IO_NONALERT,
; 2340 : 		NULL,
; 2341 : 		0);

  00068	6a 00		 push	 0
  0006a	6a 00		 push	 0
  0006c	6a 20		 push	 32			; 00000020H
  0006e	6a 01		 push	 1
  00070	6a 03		 push	 3
  00072	68 80 00 00 00	 push	 128			; 00000080H
  00077	6a 00		 push	 0
  00079	8d 85 c4 fd ff
	ff		 lea	 eax, DWORD PTR _ioStatus$[ebp]
  0007f	50		 push	 eax
  00080	8d 4d e8	 lea	 ecx, DWORD PTR _objectAttributes$[ebp]
  00083	51		 push	 ecx
  00084	68 00 00 10 80	 push	 -2146435072		; 80100000H
  00089	8b 55 0c	 mov	 edx, DWORD PTR _volumeHandle$[ebp]
  0008c	52		 push	 edx
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwCreateFile@44
  00093	89 85 d4 fd ff
	ff		 mov	 DWORD PTR _ntStatus$[ebp], eax

; 2342 : 
; 2343 : 	Dump ("Volume %ls open NTSTATUS 0x%08x\n", volumeName, ntStatus);

  00099	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _ntStatus$[ebp]
  0009f	50		 push	 eax
  000a0	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR _volumeName$[ebp]
  000a6	51		 push	 ecx
  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@JIDCFMLM@Volume?5?$CFls?5open?5NTSTATUS?50x?$CF08x?6@FNODOBFM@
  000ac	e8 00 00 00 00	 call	 _DbgPrint
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2344 : 
; 2345 : 	if (!NT_SUCCESS (ntStatus))

  000b4	83 bd d4 fd ff
	ff 00		 cmp	 DWORD PTR _ntStatus$[ebp], 0
  000bb	7d 08		 jge	 SHORT $LN2@TCOpenFsVo

; 2346 : 		return ntStatus;

  000bd	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _ntStatus$[ebp]
  000c3	eb 39		 jmp	 SHORT $LN3@TCOpenFsVo
$LN2@TCOpenFsVo:

; 2347 : 
; 2348 : 	ntStatus = ObReferenceObjectByHandle (*volumeHandle,
; 2349 : 		FILE_READ_DATA,
; 2350 : 		NULL,
; 2351 : 		KernelMode,
; 2352 : 		fileObject,
; 2353 : 		NULL);

  000c5	6a 00		 push	 0
  000c7	8b 55 10	 mov	 edx, DWORD PTR _fileObject$[ebp]
  000ca	52		 push	 edx
  000cb	6a 00		 push	 0
  000cd	6a 00		 push	 0
  000cf	6a 01		 push	 1
  000d1	8b 45 0c	 mov	 eax, DWORD PTR _volumeHandle$[ebp]
  000d4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d6	51		 push	 ecx
  000d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ObReferenceObjectByHandle@24
  000dd	89 85 d4 fd ff
	ff		 mov	 DWORD PTR _ntStatus$[ebp], eax

; 2354 : 
; 2355 : 	if (!NT_SUCCESS (ntStatus))

  000e3	83 bd d4 fd ff
	ff 00		 cmp	 DWORD PTR _ntStatus$[ebp], 0
  000ea	7d 0c		 jge	 SHORT $LN1@TCOpenFsVo

; 2356 : 		ZwClose (*volumeHandle);

  000ec	8b 55 0c	 mov	 edx, DWORD PTR _volumeHandle$[ebp]
  000ef	8b 02		 mov	 eax, DWORD PTR [edx]
  000f1	50		 push	 eax
  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4
$LN1@TCOpenFsVo:

; 2357 : 
; 2358 : 	return ntStatus;

  000f8	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _ntStatus$[ebp]
$LN3@TCOpenFsVo:

; 2359 : }

  000fe	8b 4d e4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00101	33 cd		 xor	 ecx, ebp
  00103	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c2 0c 00	 ret	 12			; 0000000cH
_TCOpenFsVolume@12 ENDP
_TEXT	ENDS
PUBLIC	_TCCloseFsVolume@8
; Function compile flags: /Odtp
;	COMDAT _TCCloseFsVolume@8
_TEXT	SEGMENT
_volumeHandle$ = 8					; size = 4
_fileObject$ = 12					; size = 4
_TCCloseFsVolume@8 PROC					; COMDAT

; 2363 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 2364 : 	ObDereferenceObject (fileObject);

  00005	8b 4d 0c	 mov	 ecx, DWORD PTR _fileObject$[ebp]
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 2365 : 	ZwClose (volumeHandle);

  0000e	8b 45 08	 mov	 eax, DWORD PTR _volumeHandle$[ebp]
  00011	50		 push	 eax
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 2366 : }

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
_TCCloseFsVolume@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _TCReadDevice@20
_TEXT	SEGMENT
_deviceObject$ = 8					; size = 4
_buffer$ = 12						; size = 4
_offset$ = 16						; size = 8
_length$ = 24						; size = 4
_TCReadDevice@20 PROC					; COMDAT

; 2399 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 2400 : 	return TCReadWriteDevice (FALSE, deviceObject, buffer, offset, length);

  00005	8b 45 18	 mov	 eax, DWORD PTR _length$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 14	 mov	 ecx, DWORD PTR _offset$[ebp+4]
  0000c	51		 push	 ecx
  0000d	8b 55 10	 mov	 edx, DWORD PTR _offset$[ebp]
  00010	52		 push	 edx
  00011	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  00014	50		 push	 eax
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _deviceObject$[ebp]
  00018	51		 push	 ecx
  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 _TCReadWriteDevice@24

; 2401 : }

  00020	5d		 pop	 ebp
  00021	c2 14 00	 ret	 20			; 00000014H
_TCReadDevice@20 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@MOHACMBH@KeGetCurrentIrql?$CI?$CJ?5?$DM?$DN?5APC_LEVEL?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp__IoBuildSynchronousFsdRequest@28:PROC
;	COMDAT ??_C@_0CA@MOHACMBH@KeGetCurrentIrql?$CI?$CJ?5?$DM?$DN?5APC_LEVEL?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0CA@MOHACMBH@KeGetCurrentIrql?$CI?$CJ?5?$DM?$DN?5APC_LEVEL?$AA@FNODOBFM@ DB 'K'
	DB	'eGetCurrentIrql() <= APC_LEVEL', 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _TCReadWriteDevice@24
_TEXT	SEGMENT
tv71 = -36						; size = 4
_status$ = -32						; size = 4
_ioStatusBlock$ = -28					; size = 8
_irp$ = -20						; size = 4
_completionEvent$ = -16					; size = 16
_write$ = 8						; size = 4
_deviceObject$ = 12					; size = 4
_buffer$ = 16						; size = 4
_offset$ = 20						; size = 8
_length$ = 28						; size = 4
_TCReadWriteDevice@24 PROC				; COMDAT

; 2370 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 24	 sub	 esp, 36			; 00000024H

; 2371 : 	NTSTATUS status;
; 2372 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2373 : 	PIRP irp;
; 2374 : 	KEVENT completionEvent;
; 2375 : 
; 2376 : 	ASSERT (KeGetCurrentIrql() <= APC_LEVEL);

  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeGetCurrentIrql@0
  0000e	0f b6 c0	 movzx	 eax, al
  00011	83 f8 01	 cmp	 eax, 1
  00014	7e 20		 jle	 SHORT $LN6@TCReadWrit
  00016	6a 00		 push	 0
  00018	68 48 09 00 00	 push	 2376			; 00000948H
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@MOHACMBH@KeGetCurrentIrql?$CI?$CJ?5?$DM?$DN?5APC_LEVEL?$AA@FNODOBFM@
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  0002d	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
  00034	eb 07		 jmp	 SHORT $LN7@TCReadWrit
$LN6@TCReadWrit:
  00036	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
$LN7@TCReadWrit:

; 2377 : 
; 2378 : 	KeInitializeEvent (&completionEvent, NotificationEvent, FALSE);

  0003d	6a 00		 push	 0
  0003f	6a 00		 push	 0
  00041	8d 4d f0	 lea	 ecx, DWORD PTR _completionEvent$[ebp]
  00044	51		 push	 ecx
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 2379 : 	irp = IoBuildSynchronousFsdRequest (write ? IRP_MJ_WRITE : IRP_MJ_READ, deviceObject, buffer, length, &offset, &completionEvent, &ioStatusBlock);

  0004b	8d 55 e4	 lea	 edx, DWORD PTR _ioStatusBlock$[ebp]
  0004e	52		 push	 edx
  0004f	8d 45 f0	 lea	 eax, DWORD PTR _completionEvent$[ebp]
  00052	50		 push	 eax
  00053	8d 4d 14	 lea	 ecx, DWORD PTR _offset$[ebp]
  00056	51		 push	 ecx
  00057	8b 55 1c	 mov	 edx, DWORD PTR _length$[ebp]
  0005a	52		 push	 edx
  0005b	8b 45 10	 mov	 eax, DWORD PTR _buffer$[ebp]
  0005e	50		 push	 eax
  0005f	8b 4d 0c	 mov	 ecx, DWORD PTR _deviceObject$[ebp]
  00062	51		 push	 ecx
  00063	33 d2		 xor	 edx, edx
  00065	83 7d 08 00	 cmp	 DWORD PTR _write$[ebp], 0
  00069	0f 95 c2	 setne	 dl
  0006c	83 c2 03	 add	 edx, 3
  0006f	52		 push	 edx
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildSynchronousFsdRequest@28
  00076	89 45 ec	 mov	 DWORD PTR _irp$[ebp], eax

; 2380 : 	if (!irp)

  00079	83 7d ec 00	 cmp	 DWORD PTR _irp$[ebp], 0
  0007d	75 07		 jne	 SHORT $LN3@TCReadWrit

; 2381 : 		return STATUS_INSUFFICIENT_RESOURCES;

  0007f	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  00084	eb 4e		 jmp	 SHORT $LN4@TCReadWrit
$LN3@TCReadWrit:

; 2382 : 
; 2383 : 	ObReferenceObject (deviceObject);

  00086	8b 4d 0c	 mov	 ecx, DWORD PTR _deviceObject$[ebp]
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfReferenceObject@4

; 2384 : 	status = IoCallDriver (deviceObject, irp);

  0008f	8b 55 ec	 mov	 edx, DWORD PTR _irp$[ebp]
  00092	8b 4d 0c	 mov	 ecx, DWORD PTR _deviceObject$[ebp]
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8
  0009b	89 45 e0	 mov	 DWORD PTR _status$[ebp], eax

; 2385 : 
; 2386 : 	if (status == STATUS_PENDING)

  0009e	81 7d e0 03 01
	00 00		 cmp	 DWORD PTR _status$[ebp], 259 ; 00000103H
  000a5	75 21		 jne	 SHORT $LN2@TCReadWrit

; 2387 : 	{
; 2388 : 		status = KeWaitForSingleObject (&completionEvent, Executive, KernelMode, FALSE, NULL);

  000a7	6a 00		 push	 0
  000a9	6a 00		 push	 0
  000ab	6a 00		 push	 0
  000ad	6a 00		 push	 0
  000af	8d 45 f0	 lea	 eax, DWORD PTR _completionEvent$[ebp]
  000b2	50		 push	 eax
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
  000b9	89 45 e0	 mov	 DWORD PTR _status$[ebp], eax

; 2389 : 		if (NT_SUCCESS (status))

  000bc	83 7d e0 00	 cmp	 DWORD PTR _status$[ebp], 0
  000c0	7c 06		 jl	 SHORT $LN2@TCReadWrit

; 2390 : 			status = ioStatusBlock.Status;

  000c2	8b 4d e4	 mov	 ecx, DWORD PTR _ioStatusBlock$[ebp]
  000c5	89 4d e0	 mov	 DWORD PTR _status$[ebp], ecx
$LN2@TCReadWrit:

; 2391 : 	}
; 2392 : 
; 2393 : 	ObDereferenceObject (deviceObject);

  000c8	8b 4d 0c	 mov	 ecx, DWORD PTR _deviceObject$[ebp]
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 2394 : 	return status;

  000d1	8b 45 e0	 mov	 eax, DWORD PTR _status$[ebp]
$LN4@TCReadWrit:

; 2395 : }

  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c2 18 00	 ret	 24			; 00000018H
_TCReadWriteDevice@24 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _TCWriteDevice@20
_TEXT	SEGMENT
_deviceObject$ = 8					; size = 4
_buffer$ = 12						; size = 4
_offset$ = 16						; size = 8
_length$ = 24						; size = 4
_TCWriteDevice@20 PROC					; COMDAT

; 2405 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 2406 : 	return TCReadWriteDevice (TRUE, deviceObject, buffer, offset, length);

  00005	8b 45 18	 mov	 eax, DWORD PTR _length$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 14	 mov	 ecx, DWORD PTR _offset$[ebp+4]
  0000c	51		 push	 ecx
  0000d	8b 55 10	 mov	 edx, DWORD PTR _offset$[ebp]
  00010	52		 push	 edx
  00011	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  00014	50		 push	 eax
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _deviceObject$[ebp]
  00018	51		 push	 ecx
  00019	6a 01		 push	 1
  0001b	e8 00 00 00 00	 call	 _TCReadWriteDevice@24

; 2407 : }

  00020	5d		 pop	 ebp
  00021	c2 14 00	 ret	 20			; 00000014H
_TCWriteDevice@20 ENDP
_TEXT	ENDS
PUBLIC	_TCFsctlCall@24
EXTRN	__imp__IoGetRelatedDeviceObject@4:PROC
; Function compile flags: /Odtp
;	COMDAT _TCFsctlCall@24
_TEXT	SEGMENT
_event$ = -40						; size = 16
_ioStatusBlock$ = -24					; size = 8
_ntStatus$ = -16					; size = 4
_stack$ = -12						; size = 4
_irp$ = -8						; size = 4
_deviceObject$ = -4					; size = 4
_fileObject$ = 8					; size = 4
_IoControlCode$ = 12					; size = 4
_InputBuffer$ = 16					; size = 4
_InputBufferSize$ = 20					; size = 4
_OutputBuffer$ = 24					; size = 4
_OutputBufferSize$ = 28					; size = 4
_TCFsctlCall@24 PROC					; COMDAT

; 2412 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 28	 sub	 esp, 40			; 00000028H

; 2413 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2414 : 	NTSTATUS ntStatus;
; 2415 : 	PIRP irp;
; 2416 : 	KEVENT event;
; 2417 : 	PIO_STACK_LOCATION stack;
; 2418 : 	PDEVICE_OBJECT deviceObject = IoGetRelatedDeviceObject (fileObject);

  00008	8b 45 08	 mov	 eax, DWORD PTR _fileObject$[ebp]
  0000b	50		 push	 eax
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoGetRelatedDeviceObject@4
  00012	89 45 fc	 mov	 DWORD PTR _deviceObject$[ebp], eax

; 2419 : 
; 2420 : 	KeInitializeEvent(&event, NotificationEvent, FALSE);

  00015	6a 00		 push	 0
  00017	6a 00		 push	 0
  00019	8d 4d d8	 lea	 ecx, DWORD PTR _event$[ebp]
  0001c	51		 push	 ecx
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 2421 : 
; 2422 : 	irp = IoBuildDeviceIoControlRequest (IoControlCode,
; 2423 : 					     deviceObject,
; 2424 : 					     InputBuffer, InputBufferSize,
; 2425 : 					     OutputBuffer, OutputBufferSize,
; 2426 : 					     FALSE,
; 2427 : 					     &event,
; 2428 : 					     &ioStatusBlock);

  00023	8d 55 e8	 lea	 edx, DWORD PTR _ioStatusBlock$[ebp]
  00026	52		 push	 edx
  00027	8d 45 d8	 lea	 eax, DWORD PTR _event$[ebp]
  0002a	50		 push	 eax
  0002b	6a 00		 push	 0
  0002d	8b 4d 1c	 mov	 ecx, DWORD PTR _OutputBufferSize$[ebp]
  00030	51		 push	 ecx
  00031	8b 55 18	 mov	 edx, DWORD PTR _OutputBuffer$[ebp]
  00034	52		 push	 edx
  00035	8b 45 14	 mov	 eax, DWORD PTR _InputBufferSize$[ebp]
  00038	50		 push	 eax
  00039	8b 4d 10	 mov	 ecx, DWORD PTR _InputBuffer$[ebp]
  0003c	51		 push	 ecx
  0003d	8b 55 fc	 mov	 edx, DWORD PTR _deviceObject$[ebp]
  00040	52		 push	 edx
  00041	8b 45 0c	 mov	 eax, DWORD PTR _IoControlCode$[ebp]
  00044	50		 push	 eax
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36
  0004b	89 45 f8	 mov	 DWORD PTR _irp$[ebp], eax

; 2429 : 
; 2430 : 	if (irp == NULL)

  0004e	83 7d f8 00	 cmp	 DWORD PTR _irp$[ebp], 0
  00052	75 07		 jne	 SHORT $LN2@TCFsctlCal

; 2431 : 		return STATUS_INSUFFICIENT_RESOURCES;

  00054	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  00059	eb 55		 jmp	 SHORT $LN3@TCFsctlCal
$LN2@TCFsctlCal:

; 2432 : 
; 2433 : 	stack = IoGetNextIrpStackLocation(irp);

  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _irp$[ebp]
  0005e	51		 push	 ecx
  0005f	e8 00 00 00 00	 call	 _IoGetNextIrpStackLocation@4
  00064	89 45 f4	 mov	 DWORD PTR _stack$[ebp], eax

; 2434 : 	
; 2435 : 	stack->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;

  00067	8b 55 f4	 mov	 edx, DWORD PTR _stack$[ebp]
  0006a	c6 02 0d	 mov	 BYTE PTR [edx], 13	; 0000000dH

; 2436 : 	stack->MinorFunction = IRP_MN_USER_FS_REQUEST;

  0006d	8b 45 f4	 mov	 eax, DWORD PTR _stack$[ebp]
  00070	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 2437 : 	stack->FileObject = fileObject;

  00074	8b 4d f4	 mov	 ecx, DWORD PTR _stack$[ebp]
  00077	8b 55 08	 mov	 edx, DWORD PTR _fileObject$[ebp]
  0007a	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 2438 : 
; 2439 : 	ntStatus = IoCallDriver (deviceObject, irp);

  0007d	8b 55 f8	 mov	 edx, DWORD PTR _irp$[ebp]
  00080	8b 4d fc	 mov	 ecx, DWORD PTR _deviceObject$[ebp]
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8
  00089	89 45 f0	 mov	 DWORD PTR _ntStatus$[ebp], eax

; 2440 : 	if (ntStatus == STATUS_PENDING)

  0008c	81 7d f0 03 01
	00 00		 cmp	 DWORD PTR _ntStatus$[ebp], 259 ; 00000103H
  00093	75 18		 jne	 SHORT $LN1@TCFsctlCal

; 2441 : 	{
; 2442 : 		KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);

  00095	6a 00		 push	 0
  00097	6a 00		 push	 0
  00099	6a 00		 push	 0
  0009b	6a 00		 push	 0
  0009d	8d 45 d8	 lea	 eax, DWORD PTR _event$[ebp]
  000a0	50		 push	 eax
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 2443 : 		ntStatus = ioStatusBlock.Status;

  000a7	8b 4d e8	 mov	 ecx, DWORD PTR _ioStatusBlock$[ebp]
  000aa	89 4d f0	 mov	 DWORD PTR _ntStatus$[ebp], ecx
$LN1@TCFsctlCal:

; 2444 : 	}
; 2445 : 
; 2446 : 	return ntStatus;

  000ad	8b 45 f0	 mov	 eax, DWORD PTR _ntStatus$[ebp]
$LN3@TCFsctlCal:

; 2447 : }

  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 18 00	 ret	 24			; 00000018H
_TCFsctlCall@24 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@INHNDJGI@IoCreateSymbolicLink?5returned?5?$CFX@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	__$ArrayPad$
PUBLIC	_CreateDriveLink@4
;	COMDAT ??_C@_0CC@INHNDJGI@IoCreateSymbolicLink?5returned?5?$CFX@FNODOBFM@
text$s	SEGMENT
??_C@_0CC@INHNDJGI@IoCreateSymbolicLink?5returned?5?$CFX@FNODOBFM@ DB 'Io'
	DB	'CreateSymbolicLink returned %X', 0aH, 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _CreateDriveLink@4
_TEXT	SEGMENT
_dev$ = -536						; size = 256
_link$ = -280						; size = 256
__$ArrayPad$ = -24					; size = 4
_ntStatus$ = -20					; size = 4
_deviceName$ = -16					; size = 8
_symLink$ = -8						; size = 8
_nDosDriveNo$ = 8					; size = 4
_CreateDriveLink@4 PROC					; COMDAT

; 2451 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 18 02 00
	00		 sub	 esp, 536		; 00000218H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 e8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2452 : 	WCHAR dev[128], link[128];
; 2453 : 	UNICODE_STRING deviceName, symLink;
; 2454 : 	NTSTATUS ntStatus;
; 2455 : 
; 2456 : 	TCGetNTNameFromNumber (dev, nDosDriveNo);

  00015	8b 45 08	 mov	 eax, DWORD PTR _nDosDriveNo$[ebp]
  00018	50		 push	 eax
  00019	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _dev$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 _TCGetNTNameFromNumber@8

; 2457 : 	TCGetDosNameFromNumber (link, nDosDriveNo);

  00025	8b 55 08	 mov	 edx, DWORD PTR _nDosDriveNo$[ebp]
  00028	52		 push	 edx
  00029	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _link$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 _TCGetDosNameFromNumber@8

; 2458 : 
; 2459 : 	RtlInitUnicodeString (&deviceName, dev);

  00035	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _dev$[ebp]
  0003b	51		 push	 ecx
  0003c	8d 55 f0	 lea	 edx, DWORD PTR _deviceName$[ebp]
  0003f	52		 push	 edx
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 2460 : 	RtlInitUnicodeString (&symLink, link);

  00046	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _link$[ebp]
  0004c	50		 push	 eax
  0004d	8d 4d f8	 lea	 ecx, DWORD PTR _symLink$[ebp]
  00050	51		 push	 ecx
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 2461 : 
; 2462 : 	ntStatus = IoCreateSymbolicLink (&symLink, &deviceName);

  00057	8d 55 f0	 lea	 edx, DWORD PTR _deviceName$[ebp]
  0005a	52		 push	 edx
  0005b	8d 45 f8	 lea	 eax, DWORD PTR _symLink$[ebp]
  0005e	50		 push	 eax
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoCreateSymbolicLink@8
  00065	89 45 ec	 mov	 DWORD PTR _ntStatus$[ebp], eax

; 2463 : 	Dump ("IoCreateSymbolicLink returned %X\n", ntStatus);

  00068	8b 4d ec	 mov	 ecx, DWORD PTR _ntStatus$[ebp]
  0006b	51		 push	 ecx
  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@INHNDJGI@IoCreateSymbolicLink?5returned?5?$CFX@FNODOBFM@
  00071	e8 00 00 00 00	 call	 _DbgPrint
  00076	83 c4 08	 add	 esp, 8

; 2464 : 	return ntStatus;

  00079	8b 45 ec	 mov	 eax, DWORD PTR _ntStatus$[ebp]

; 2465 : }

  0007c	8b 4d e8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007f	33 cd		 xor	 ecx, ebp
  00081	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c2 04 00	 ret	 4
_CreateDriveLink@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@KAFJKDAC@IoDeleteSymbolicLink?5returned?5?$CFX@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	__$ArrayPad$
PUBLIC	_RemoveDriveLink@4
;	COMDAT ??_C@_0CC@KAFJKDAC@IoDeleteSymbolicLink?5returned?5?$CFX@FNODOBFM@
text$s	SEGMENT
??_C@_0CC@KAFJKDAC@IoDeleteSymbolicLink?5returned?5?$CFX@FNODOBFM@ DB 'Io'
	DB	'DeleteSymbolicLink returned %X', 0aH, 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _RemoveDriveLink@4
_TEXT	SEGMENT
_link$ = -528						; size = 512
__$ArrayPad$ = -16					; size = 4
_ntStatus$ = -12					; size = 4
_symLink$ = -8						; size = 8
_nDosDriveNo$ = 8					; size = 4
_RemoveDriveLink@4 PROC					; COMDAT

; 2469 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 10 02 00
	00		 sub	 esp, 528		; 00000210H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2470 : 	WCHAR link[256];
; 2471 : 	UNICODE_STRING symLink;
; 2472 : 	NTSTATUS ntStatus;
; 2473 : 
; 2474 : 	TCGetDosNameFromNumber (link, nDosDriveNo);

  00015	8b 45 08	 mov	 eax, DWORD PTR _nDosDriveNo$[ebp]
  00018	50		 push	 eax
  00019	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _link$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 _TCGetDosNameFromNumber@8

; 2475 : 	RtlInitUnicodeString (&symLink, link);

  00025	8d 95 f0 fd ff
	ff		 lea	 edx, DWORD PTR _link$[ebp]
  0002b	52		 push	 edx
  0002c	8d 45 f8	 lea	 eax, DWORD PTR _symLink$[ebp]
  0002f	50		 push	 eax
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 2476 : 
; 2477 : 	ntStatus = IoDeleteSymbolicLink (&symLink);

  00036	8d 4d f8	 lea	 ecx, DWORD PTR _symLink$[ebp]
  00039	51		 push	 ecx
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteSymbolicLink@4
  00040	89 45 f4	 mov	 DWORD PTR _ntStatus$[ebp], eax

; 2478 : 	Dump ("IoDeleteSymbolicLink returned %X\n", ntStatus);

  00043	8b 55 f4	 mov	 edx, DWORD PTR _ntStatus$[ebp]
  00046	52		 push	 edx
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@KAFJKDAC@IoDeleteSymbolicLink?5returned?5?$CFX@FNODOBFM@
  0004c	e8 00 00 00 00	 call	 _DbgPrint
  00051	83 c4 08	 add	 esp, 8

; 2479 : 	return ntStatus;

  00054	8b 45 f4	 mov	 eax, DWORD PTR _ntStatus$[ebp]

; 2480 : }

  00057	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005a	33 cd		 xor	 ecx, ebp
  0005c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
_RemoveDriveLink@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	__$ArrayPad$
PUBLIC	_MountManagerMount@4
;	COMDAT ??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'M', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, 'P'
	DB	00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'M', 00H, 'a', 00H
	DB	'n', 00H, 'a', 00H, 'g', 00H, 'e', 00H, 'r', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _MountManagerMount@4
_TEXT	SEGMENT
tv165 = -828						; size = 4
tv266 = -822						; size = 2
tv263 = -820						; size = 4
tv260 = -816						; size = 4
tv138 = -812						; size = 4
tv244 = -806						; size = 2
tv241 = -804						; size = 4
tv238 = -800						; size = 4
tv88 = -796						; size = 4
tv221 = -790						; size = 2
tv218 = -788						; size = 4
tv215 = -784						; size = 4
tv79 = -778						; size = 2
tv78 = -776						; size = 4
tv77 = -772						; size = 4
tv75 = -768						; size = 4
tv69 = -764						; size = 4
tv199 = -758						; size = 2
tv196 = -756						; size = 4
tv193 = -752						; size = 4
_symName$ = -748					; size = 8
_ntStatus$ = -740					; size = 4
_devName$ = -736					; size = 8
_buf$ = -728						; size = 200
_arrVolume$ = -528					; size = 512
__$ArrayPad$ = -12					; size = 4
_in$ = -8						; size = 4
_point$ = -4						; size = 4
_mount$ = 8						; size = 4
_MountManagerMount@4 PROC				; COMDAT

; 2484 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 3c 03 00
	00		 sub	 esp, 828		; 0000033cH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 f4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2485 : 	NTSTATUS ntStatus; 
; 2486 : 	WCHAR arrVolume[256];
; 2487 : 	char buf[200];
; 2488 : 	PMOUNTMGR_TARGET_NAME in = (PMOUNTMGR_TARGET_NAME) buf;

  00015	8d 85 28 fd ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  0001b	89 45 f8	 mov	 DWORD PTR _in$[ebp], eax

; 2489 : 	PMOUNTMGR_CREATE_POINT_INPUT point = (PMOUNTMGR_CREATE_POINT_INPUT) buf;

  0001e	8d 8d 28 fd ff
	ff		 lea	 ecx, DWORD PTR _buf$[ebp]
  00024	89 4d fc	 mov	 DWORD PTR _point$[ebp], ecx

; 2490 : 	UNICODE_STRING symName, devName;
; 2491 : 
; 2492 : 	TCGetNTNameFromNumber (arrVolume, mount->nDosDriveNo);

  00027	8b 55 08	 mov	 edx, DWORD PTR _mount$[ebp]
  0002a	8b 82 64 02 00
	00		 mov	 eax, DWORD PTR [edx+612]
  00030	50		 push	 eax
  00031	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _arrVolume$[ebp]
  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 _TCGetNTNameFromNumber@8

; 2493 : 	in->DeviceNameLength = (USHORT) wcslen (arrVolume) * 2;

  0003d	8d 95 f0 fd ff
	ff		 lea	 edx, DWORD PTR _arrVolume$[ebp]
  00043	89 95 10 fd ff
	ff		 mov	 DWORD PTR tv193[ebp], edx
  00049	8b 85 10 fd ff
	ff		 mov	 eax, DWORD PTR tv193[ebp]
  0004f	83 c0 02	 add	 eax, 2
  00052	89 85 0c fd ff
	ff		 mov	 DWORD PTR tv196[ebp], eax
$LL4@MountManag:
  00058	8b 8d 10 fd ff
	ff		 mov	 ecx, DWORD PTR tv193[ebp]
  0005e	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00061	66 89 95 0a fd
	ff ff		 mov	 WORD PTR tv199[ebp], dx
  00068	83 85 10 fd ff
	ff 02		 add	 DWORD PTR tv193[ebp], 2
  0006f	66 83 bd 0a fd
	ff ff 00	 cmp	 WORD PTR tv199[ebp], 0
  00077	75 df		 jne	 SHORT $LL4@MountManag
  00079	8b 85 10 fd ff
	ff		 mov	 eax, DWORD PTR tv193[ebp]
  0007f	2b 85 0c fd ff
	ff		 sub	 eax, DWORD PTR tv196[ebp]
  00085	d1 f8		 sar	 eax, 1
  00087	89 85 04 fd ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
  0008d	0f b7 8d 04 fd
	ff ff		 movzx	 ecx, WORD PTR tv69[ebp]
  00094	d1 e1		 shl	 ecx, 1
  00096	8b 55 f8	 mov	 edx, DWORD PTR _in$[ebp]
  00099	66 89 0a	 mov	 WORD PTR [edx], cx

; 2494 : 	wcscpy(in->DeviceName, arrVolume);

  0009c	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _arrVolume$[ebp]
  000a2	89 85 00 fd ff
	ff		 mov	 DWORD PTR tv75[ebp], eax
  000a8	8b 4d f8	 mov	 ecx, DWORD PTR _in$[ebp]
  000ab	83 c1 02	 add	 ecx, 2
  000ae	89 8d fc fc ff
	ff		 mov	 DWORD PTR tv77[ebp], ecx
  000b4	8b 95 fc fc ff
	ff		 mov	 edx, DWORD PTR tv77[ebp]
  000ba	89 95 f8 fc ff
	ff		 mov	 DWORD PTR tv78[ebp], edx
$LN3@MountManag:
  000c0	8b 85 00 fd ff
	ff		 mov	 eax, DWORD PTR tv75[ebp]
  000c6	66 8b 08	 mov	 cx, WORD PTR [eax]
  000c9	66 89 8d f6 fc
	ff ff		 mov	 WORD PTR tv79[ebp], cx
  000d0	8b 95 fc fc ff
	ff		 mov	 edx, DWORD PTR tv77[ebp]
  000d6	66 8b 85 f6 fc
	ff ff		 mov	 ax, WORD PTR tv79[ebp]
  000dd	66 89 02	 mov	 WORD PTR [edx], ax
  000e0	8b 8d 00 fd ff
	ff		 mov	 ecx, DWORD PTR tv75[ebp]
  000e6	83 c1 02	 add	 ecx, 2
  000e9	89 8d 00 fd ff
	ff		 mov	 DWORD PTR tv75[ebp], ecx
  000ef	8b 95 fc fc ff
	ff		 mov	 edx, DWORD PTR tv77[ebp]
  000f5	83 c2 02	 add	 edx, 2
  000f8	89 95 fc fc ff
	ff		 mov	 DWORD PTR tv77[ebp], edx
  000fe	66 83 bd f6 fc
	ff ff 00	 cmp	 WORD PTR tv79[ebp], 0
  00106	75 b8		 jne	 SHORT $LN3@MountManag

; 2495 : 
; 2496 : 	ntStatus = TCDeviceIoControl (MOUNTMGR_DEVICE_NAME, IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION,
; 2497 : 		in, (ULONG) (sizeof (in->DeviceNameLength) + wcslen (arrVolume) * 2), 0, 0);

  00108	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _arrVolume$[ebp]
  0010e	89 85 f0 fc ff
	ff		 mov	 DWORD PTR tv215[ebp], eax
  00114	8b 8d f0 fc ff
	ff		 mov	 ecx, DWORD PTR tv215[ebp]
  0011a	83 c1 02	 add	 ecx, 2
  0011d	89 8d ec fc ff
	ff		 mov	 DWORD PTR tv218[ebp], ecx
$LL5@MountManag:
  00123	8b 95 f0 fc ff
	ff		 mov	 edx, DWORD PTR tv215[ebp]
  00129	66 8b 02	 mov	 ax, WORD PTR [edx]
  0012c	66 89 85 ea fc
	ff ff		 mov	 WORD PTR tv221[ebp], ax
  00133	83 85 f0 fc ff
	ff 02		 add	 DWORD PTR tv215[ebp], 2
  0013a	66 83 bd ea fc
	ff ff 00	 cmp	 WORD PTR tv221[ebp], 0
  00142	75 df		 jne	 SHORT $LL5@MountManag
  00144	8b 8d f0 fc ff
	ff		 mov	 ecx, DWORD PTR tv215[ebp]
  0014a	2b 8d ec fc ff
	ff		 sub	 ecx, DWORD PTR tv218[ebp]
  00150	d1 f9		 sar	 ecx, 1
  00152	89 8d e4 fc ff
	ff		 mov	 DWORD PTR tv88[ebp], ecx
  00158	6a 00		 push	 0
  0015a	6a 00		 push	 0
  0015c	8b 95 e4 fc ff
	ff		 mov	 edx, DWORD PTR tv88[ebp]
  00162	8d 44 12 02	 lea	 eax, DWORD PTR [edx+edx+2]
  00166	50		 push	 eax
  00167	8b 4d f8	 mov	 ecx, DWORD PTR _in$[ebp]
  0016a	51		 push	 ecx
  0016b	68 2c 40 6d 00	 push	 7159852			; 006d402cH
  00170	68 00 00 00 00	 push	 OFFSET ??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
  00175	e8 00 00 00 00	 call	 _TCDeviceIoControl@24
  0017a	89 85 1c fd ff
	ff		 mov	 DWORD PTR _ntStatus$[ebp], eax

; 2498 : 
; 2499 : 	memset (buf, 0, sizeof buf);

  00180	68 c8 00 00 00	 push	 200			; 000000c8H
  00185	6a 00		 push	 0
  00187	8d 95 28 fd ff
	ff		 lea	 edx, DWORD PTR _buf$[ebp]
  0018d	52		 push	 edx
  0018e	e8 00 00 00 00	 call	 _memset
  00193	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2500 : 	TCGetDosNameFromNumber ((PWSTR) &point[1], mount->nDosDriveNo);

  00196	8b 45 08	 mov	 eax, DWORD PTR _mount$[ebp]
  00199	8b 88 64 02 00
	00		 mov	 ecx, DWORD PTR [eax+612]
  0019f	51		 push	 ecx
  001a0	8b 55 fc	 mov	 edx, DWORD PTR _point$[ebp]
  001a3	83 c2 08	 add	 edx, 8
  001a6	52		 push	 edx
  001a7	e8 00 00 00 00	 call	 _TCGetDosNameFromNumber@8

; 2501 : 
; 2502 : 	point->SymbolicLinkNameOffset = sizeof (MOUNTMGR_CREATE_POINT_INPUT);

  001ac	b8 08 00 00 00	 mov	 eax, 8
  001b1	8b 4d fc	 mov	 ecx, DWORD PTR _point$[ebp]
  001b4	66 89 01	 mov	 WORD PTR [ecx], ax

; 2503 : 	point->SymbolicLinkNameLength = (USHORT) wcslen ((PWSTR) &point[1]) * 2;

  001b7	8b 55 fc	 mov	 edx, DWORD PTR _point$[ebp]
  001ba	83 c2 08	 add	 edx, 8
  001bd	89 95 e0 fc ff
	ff		 mov	 DWORD PTR tv238[ebp], edx
  001c3	8b 85 e0 fc ff
	ff		 mov	 eax, DWORD PTR tv238[ebp]
  001c9	83 c0 02	 add	 eax, 2
  001cc	89 85 dc fc ff
	ff		 mov	 DWORD PTR tv241[ebp], eax
$LL6@MountManag:
  001d2	8b 8d e0 fc ff
	ff		 mov	 ecx, DWORD PTR tv238[ebp]
  001d8	66 8b 11	 mov	 dx, WORD PTR [ecx]
  001db	66 89 95 da fc
	ff ff		 mov	 WORD PTR tv244[ebp], dx
  001e2	83 85 e0 fc ff
	ff 02		 add	 DWORD PTR tv238[ebp], 2
  001e9	66 83 bd da fc
	ff ff 00	 cmp	 WORD PTR tv244[ebp], 0
  001f1	75 df		 jne	 SHORT $LL6@MountManag
  001f3	8b 85 e0 fc ff
	ff		 mov	 eax, DWORD PTR tv238[ebp]
  001f9	2b 85 dc fc ff
	ff		 sub	 eax, DWORD PTR tv241[ebp]
  001ff	d1 f8		 sar	 eax, 1
  00201	89 85 d4 fc ff
	ff		 mov	 DWORD PTR tv138[ebp], eax
  00207	0f b7 8d d4 fc
	ff ff		 movzx	 ecx, WORD PTR tv138[ebp]
  0020e	d1 e1		 shl	 ecx, 1
  00210	8b 55 fc	 mov	 edx, DWORD PTR _point$[ebp]
  00213	66 89 4a 02	 mov	 WORD PTR [edx+2], cx

; 2504 : 
; 2505 : 	RtlInitUnicodeString(&symName, (PWSTR) (buf + point->SymbolicLinkNameOffset));

  00217	8b 45 fc	 mov	 eax, DWORD PTR _point$[ebp]
  0021a	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0021d	8d 94 0d 28 fd
	ff ff		 lea	 edx, DWORD PTR _buf$[ebp+ecx]
  00224	52		 push	 edx
  00225	8d 85 14 fd ff
	ff		 lea	 eax, DWORD PTR _symName$[ebp]
  0022b	50		 push	 eax
  0022c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 2506 : 
; 2507 : 	point->DeviceNameOffset = point->SymbolicLinkNameOffset + point->SymbolicLinkNameLength;

  00232	8b 4d fc	 mov	 ecx, DWORD PTR _point$[ebp]
  00235	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00238	8b 45 fc	 mov	 eax, DWORD PTR _point$[ebp]
  0023b	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  0023f	03 d1		 add	 edx, ecx
  00241	8b 45 fc	 mov	 eax, DWORD PTR _point$[ebp]
  00244	66 89 50 04	 mov	 WORD PTR [eax+4], dx

; 2508 : 	TCGetNTNameFromNumber ((PWSTR) (buf + point->DeviceNameOffset), mount->nDosDriveNo);

  00248	8b 4d 08	 mov	 ecx, DWORD PTR _mount$[ebp]
  0024b	8b 91 64 02 00
	00		 mov	 edx, DWORD PTR [ecx+612]
  00251	52		 push	 edx
  00252	8b 45 fc	 mov	 eax, DWORD PTR _point$[ebp]
  00255	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  00259	8d 94 0d 28 fd
	ff ff		 lea	 edx, DWORD PTR _buf$[ebp+ecx]
  00260	52		 push	 edx
  00261	e8 00 00 00 00	 call	 _TCGetNTNameFromNumber@8

; 2509 : 	point->DeviceNameLength = (USHORT) wcslen ((PWSTR) (buf + point->DeviceNameOffset)) * 2;

  00266	8b 45 fc	 mov	 eax, DWORD PTR _point$[ebp]
  00269	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  0026d	8d 94 0d 28 fd
	ff ff		 lea	 edx, DWORD PTR _buf$[ebp+ecx]
  00274	89 95 d0 fc ff
	ff		 mov	 DWORD PTR tv260[ebp], edx
  0027a	8b 85 d0 fc ff
	ff		 mov	 eax, DWORD PTR tv260[ebp]
  00280	83 c0 02	 add	 eax, 2
  00283	89 85 cc fc ff
	ff		 mov	 DWORD PTR tv263[ebp], eax
$LL7@MountManag:
  00289	8b 8d d0 fc ff
	ff		 mov	 ecx, DWORD PTR tv260[ebp]
  0028f	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00292	66 89 95 ca fc
	ff ff		 mov	 WORD PTR tv266[ebp], dx
  00299	83 85 d0 fc ff
	ff 02		 add	 DWORD PTR tv260[ebp], 2
  002a0	66 83 bd ca fc
	ff ff 00	 cmp	 WORD PTR tv266[ebp], 0
  002a8	75 df		 jne	 SHORT $LL7@MountManag
  002aa	8b 85 d0 fc ff
	ff		 mov	 eax, DWORD PTR tv260[ebp]
  002b0	2b 85 cc fc ff
	ff		 sub	 eax, DWORD PTR tv263[ebp]
  002b6	d1 f8		 sar	 eax, 1
  002b8	89 85 c4 fc ff
	ff		 mov	 DWORD PTR tv165[ebp], eax
  002be	0f b7 8d c4 fc
	ff ff		 movzx	 ecx, WORD PTR tv165[ebp]
  002c5	d1 e1		 shl	 ecx, 1
  002c7	8b 55 fc	 mov	 edx, DWORD PTR _point$[ebp]
  002ca	66 89 4a 06	 mov	 WORD PTR [edx+6], cx

; 2510 : 
; 2511 : 	RtlInitUnicodeString(&devName, (PWSTR) (buf + point->DeviceNameOffset));

  002ce	8b 45 fc	 mov	 eax, DWORD PTR _point$[ebp]
  002d1	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  002d5	8d 94 0d 28 fd
	ff ff		 lea	 edx, DWORD PTR _buf$[ebp+ecx]
  002dc	52		 push	 edx
  002dd	8d 85 20 fd ff
	ff		 lea	 eax, DWORD PTR _devName$[ebp]
  002e3	50		 push	 eax
  002e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 2512 : 
; 2513 : 	ntStatus = TCDeviceIoControl (MOUNTMGR_DEVICE_NAME, IOCTL_MOUNTMGR_CREATE_POINT, point,
; 2514 : 		point->DeviceNameOffset + point->DeviceNameLength, 0, 0);

  002ea	6a 00		 push	 0
  002ec	6a 00		 push	 0
  002ee	8b 4d fc	 mov	 ecx, DWORD PTR _point$[ebp]
  002f1	0f b7 51 04	 movzx	 edx, WORD PTR [ecx+4]
  002f5	8b 45 fc	 mov	 eax, DWORD PTR _point$[ebp]
  002f8	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  002fc	03 d1		 add	 edx, ecx
  002fe	52		 push	 edx
  002ff	8b 55 fc	 mov	 edx, DWORD PTR _point$[ebp]
  00302	52		 push	 edx
  00303	68 00 c0 6d 00	 push	 7192576			; 006dc000H
  00308	68 00 00 00 00	 push	 OFFSET ??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
  0030d	e8 00 00 00 00	 call	 _TCDeviceIoControl@24
  00312	89 85 1c fd ff
	ff		 mov	 DWORD PTR _ntStatus$[ebp], eax

; 2515 : 
; 2516 : 	return ntStatus;

  00318	8b 85 1c fd ff
	ff		 mov	 eax, DWORD PTR _ntStatus$[ebp]

; 2517 : }

  0031e	8b 4d f4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00321	33 cd		 xor	 ecx, ebp
  00323	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00328	8b e5		 mov	 esp, ebp
  0032a	5d		 pop	 ebp
  0032b	c2 04 00	 ret	 4
_MountManagerMount@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CO@FHIENMIJ@IOCTL_MOUNTMGR_DELETE_POINTS?5ret@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	__$ArrayPad$
PUBLIC	_MountManagerUnmount@4
;	COMDAT ??_C@_0CO@FHIENMIJ@IOCTL_MOUNTMGR_DELETE_POINTS?5ret@FNODOBFM@
text$s	SEGMENT
??_C@_0CO@FHIENMIJ@IOCTL_MOUNTMGR_DELETE_POINTS?5ret@FNODOBFM@ DB 'IOCTL_'
	DB	'MOUNTMGR_DELETE_POINTS returned 0x%08x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _MountManagerUnmount@4
_TEXT	SEGMENT
tv74 = -592						; size = 4
tv136 = -586						; size = 2
tv133 = -584						; size = 4
tv130 = -580						; size = 4
_out$ = -576						; size = 300
_ntStatus$ = -268					; size = 4
_buf$ = -264						; size = 256
__$ArrayPad$ = -8					; size = 4
_in$ = -4						; size = 4
_nDosDriveNo$ = 8					; size = 4
_MountManagerUnmount@4 PROC				; COMDAT

; 2521 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 50 02 00
	00		 sub	 esp, 592		; 00000250H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2522 : 	NTSTATUS ntStatus; 
; 2523 : 	char buf[256], out[300];
; 2524 : 	PMOUNTMGR_MOUNT_POINT in = (PMOUNTMGR_MOUNT_POINT) buf;

  00015	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR _in$[ebp], eax

; 2525 : 
; 2526 : 	memset (buf, 0, sizeof buf);

  0001e	68 00 01 00 00	 push	 256			; 00000100H
  00023	6a 00		 push	 0
  00025	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _buf$[ebp]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 _memset
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2527 : 
; 2528 : 	TCGetDosNameFromNumber ((PWSTR) &in[1], nDosDriveNo);

  00034	8b 55 08	 mov	 edx, DWORD PTR _nDosDriveNo$[ebp]
  00037	52		 push	 edx
  00038	8b 45 fc	 mov	 eax, DWORD PTR _in$[ebp]
  0003b	83 c0 18	 add	 eax, 24			; 00000018H
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 _TCGetDosNameFromNumber@8

; 2529 : 
; 2530 : 	// Only symbolic link can be deleted with IOCTL_MOUNTMGR_DELETE_POINTS. If any other entry is specified, the mount manager will ignore subsequent IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION for the same volume ID.
; 2531 : 	in->SymbolicLinkNameOffset = sizeof (MOUNTMGR_MOUNT_POINT);

  00044	8b 4d fc	 mov	 ecx, DWORD PTR _in$[ebp]
  00047	c7 01 18 00 00
	00		 mov	 DWORD PTR [ecx], 24	; 00000018H

; 2532 : 	in->SymbolicLinkNameLength = (USHORT) wcslen ((PWCHAR) &in[1]) * 2;

  0004d	8b 55 fc	 mov	 edx, DWORD PTR _in$[ebp]
  00050	83 c2 18	 add	 edx, 24			; 00000018H
  00053	89 95 bc fd ff
	ff		 mov	 DWORD PTR tv130[ebp], edx
  00059	8b 85 bc fd ff
	ff		 mov	 eax, DWORD PTR tv130[ebp]
  0005f	83 c0 02	 add	 eax, 2
  00062	89 85 b8 fd ff
	ff		 mov	 DWORD PTR tv133[ebp], eax
$LL3@MountManag@2:
  00068	8b 8d bc fd ff
	ff		 mov	 ecx, DWORD PTR tv130[ebp]
  0006e	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00071	66 89 95 b6 fd
	ff ff		 mov	 WORD PTR tv136[ebp], dx
  00078	83 85 bc fd ff
	ff 02		 add	 DWORD PTR tv130[ebp], 2
  0007f	66 83 bd b6 fd
	ff ff 00	 cmp	 WORD PTR tv136[ebp], 0
  00087	75 df		 jne	 SHORT $LL3@MountManag@2
  00089	8b 85 bc fd ff
	ff		 mov	 eax, DWORD PTR tv130[ebp]
  0008f	2b 85 b8 fd ff
	ff		 sub	 eax, DWORD PTR tv133[ebp]
  00095	d1 f8		 sar	 eax, 1
  00097	89 85 b0 fd ff
	ff		 mov	 DWORD PTR tv74[ebp], eax
  0009d	0f b7 8d b0 fd
	ff ff		 movzx	 ecx, WORD PTR tv74[ebp]
  000a4	d1 e1		 shl	 ecx, 1
  000a6	8b 55 fc	 mov	 edx, DWORD PTR _in$[ebp]
  000a9	66 89 4a 04	 mov	 WORD PTR [edx+4], cx

; 2533 : 
; 2534 : 	ntStatus = TCDeviceIoControl (MOUNTMGR_DEVICE_NAME, IOCTL_MOUNTMGR_DELETE_POINTS,
; 2535 : 		in, sizeof(MOUNTMGR_MOUNT_POINT) + in->SymbolicLinkNameLength, out, sizeof out);

  000ad	68 2c 01 00 00	 push	 300			; 0000012cH
  000b2	8d 85 c0 fd ff
	ff		 lea	 eax, DWORD PTR _out$[ebp]
  000b8	50		 push	 eax
  000b9	8b 4d fc	 mov	 ecx, DWORD PTR _in$[ebp]
  000bc	0f b7 51 04	 movzx	 edx, WORD PTR [ecx+4]
  000c0	83 c2 18	 add	 edx, 24			; 00000018H
  000c3	52		 push	 edx
  000c4	8b 45 fc	 mov	 eax, DWORD PTR _in$[ebp]
  000c7	50		 push	 eax
  000c8	68 04 c0 6d 00	 push	 7192580			; 006dc004H
  000cd	68 00 00 00 00	 push	 OFFSET ??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
  000d2	e8 00 00 00 00	 call	 _TCDeviceIoControl@24
  000d7	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _ntStatus$[ebp], eax

; 2536 : 
; 2537 : 	Dump ("IOCTL_MOUNTMGR_DELETE_POINTS returned 0x%08x\n", ntStatus);

  000dd	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _ntStatus$[ebp]
  000e3	51		 push	 ecx
  000e4	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@FHIENMIJ@IOCTL_MOUNTMGR_DELETE_POINTS?5ret@FNODOBFM@
  000e9	e8 00 00 00 00	 call	 _DbgPrint
  000ee	83 c4 08	 add	 esp, 8

; 2538 : 
; 2539 : 	return ntStatus;

  000f1	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _ntStatus$[ebp]

; 2540 : }

  000f7	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fa	33 cd		 xor	 ecx, ebp
  000fc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00101	8b e5		 mov	 esp, ebp
  00103	5d		 pop	 ebp
  00104	c2 04 00	 ret	 4
_MountManagerUnmount@4 ENDP
_TEXT	ENDS
PUBLIC	_getToken@4
; Function compile flags: /Odtp
;	COMDAT _getToken@4
_TEXT	SEGMENT
_psubContext$ = 8					; size = 4
_getToken@4 PROC					; COMDAT

; 2548 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 2549 : 	if (!psubContext) 

  00005	83 7d 08 00	 cmp	 DWORD PTR _psubContext$[ebp], 0
  00009	75 06		 jne	 SHORT $LN4@getToken

; 2550 : 	{
; 2551 : 		return NULL;

  0000b	33 c0		 xor	 eax, eax
  0000d	eb 22		 jmp	 SHORT $LN5@getToken
  0000f	eb 20		 jmp	 SHORT $LN5@getToken
$LN4@getToken:

; 2552 : 	}
; 2553 : 	else if (psubContext->ClientToken && psubContext->ImpersonationLevel >= SecurityImpersonation)

  00011	8b 45 08	 mov	 eax, DWORD PTR _psubContext$[ebp]
  00014	83 38 00	 cmp	 DWORD PTR [eax], 0
  00017	74 12		 je	 SHORT $LN2@getToken
  00019	8b 4d 08	 mov	 ecx, DWORD PTR _psubContext$[ebp]
  0001c	83 79 04 02	 cmp	 DWORD PTR [ecx+4], 2
  00020	7c 09		 jl	 SHORT $LN2@getToken

; 2554 : 	{
; 2555 : 		return psubContext->ClientToken;

  00022	8b 55 08	 mov	 edx, DWORD PTR _psubContext$[ebp]
  00025	8b 02		 mov	 eax, DWORD PTR [edx]
  00027	eb 08		 jmp	 SHORT $LN5@getToken

; 2556 : 	}
; 2557 : 	else

  00029	eb 06		 jmp	 SHORT $LN5@getToken
$LN2@getToken:

; 2558 : 	{
; 2559 : 		return psubContext->PrimaryToken;

  0002b	8b 45 08	 mov	 eax, DWORD PTR _psubContext$[ebp]
  0002e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$LN5@getToken:

; 2560 : 	}
; 2561 : }

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
_getToken@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@IJMBHFOD@Mount?5FAILURE?5TC?5code?5?$DN?50x?$CF08x?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CP@DBOFILAH@Mount?5SUCCESS?5TC?5code?5?$DN?50x?$CF08x?5R@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CL@KIIHMHE@Mount?5FAILURE?5NT?5ERROR?0?5ntStatus@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CO@NNHGPFIJ@Mount?5CREATE?5DEVICE?5ERROR?0?5ntSta@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CF@CGPMKDKJ@WARNING?3?5MOUNT?5DRIVE?5LETTER?5INVA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BL@PIKDDHEP@Mount?5request?5looks?5valid?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_IsDriveLetterAvailable@4
EXTRN	__imp__SeReleaseSubjectContext@4:PROC
EXTRN	__imp__SeUnlockSubjectContext@4:PROC
EXTRN	__imp__RtlCopySid@12:PROC
EXTRN	__imp__RtlLengthSid@4:PROC
EXTRN	__imp__SeQueryInformationToken@12:PROC
EXTRN	__imp__SeLockSubjectContext@4:PROC
EXTRN	__imp__SeCaptureSubjectContext@4:PROC
EXTRN	__except_handler4:PROC
;	COMDAT ??_C@_0CA@IJMBHFOD@Mount?5FAILURE?5TC?5code?5?$DN?50x?$CF08x?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0CA@IJMBHFOD@Mount?5FAILURE?5TC?5code?5?$DN?50x?$CF08x?6?$AA@FNODOBFM@ DB 'M'
	DB	'ount FAILURE TC code = 0x%08x', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CP@DBOFILAH@Mount?5SUCCESS?5TC?5code?5?$DN?50x?$CF08x?5R@FNODOBFM@
text$s	SEGMENT
??_C@_0CP@DBOFILAH@Mount?5SUCCESS?5TC?5code?5?$DN?50x?$CF08x?5R@FNODOBFM@ DB 'M'
	DB	'ount SUCCESS TC code = 0x%08x READ-ONLY = %d', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CL@KIIHMHE@Mount?5FAILURE?5NT?5ERROR?0?5ntStatus@FNODOBFM@
text$s	SEGMENT
??_C@_0CL@KIIHMHE@Mount?5FAILURE?5NT?5ERROR?0?5ntStatus@FNODOBFM@ DB 'Mou'
	DB	'nt FAILURE NT ERROR, ntStatus = 0x%08x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CO@NNHGPFIJ@Mount?5CREATE?5DEVICE?5ERROR?0?5ntSta@FNODOBFM@
text$s	SEGMENT
??_C@_0CO@NNHGPFIJ@Mount?5CREATE?5DEVICE?5ERROR?0?5ntSta@FNODOBFM@ DB 'Mo'
	DB	'unt CREATE DEVICE ERROR, ntStatus = 0x%08x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CF@CGPMKDKJ@WARNING?3?5MOUNT?5DRIVE?5LETTER?5INVA@FNODOBFM@
text$s	SEGMENT
??_C@_0CF@CGPMKDKJ@WARNING?3?5MOUNT?5DRIVE?5LETTER?5INVA@FNODOBFM@ DB 'WA'
	DB	'RNING: MOUNT DRIVE LETTER INVALID', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BL@PIKDDHEP@Mount?5request?5looks?5valid?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BL@PIKDDHEP@Mount?5request?5looks?5valid?6?$AA@FNODOBFM@ DB 'Mount'
	DB	' request looks valid', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$_MountDevice@8 DD 0fffffffeH
	DD	00H
	DD	0ffffffa4H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN24@MountDevic
	DD	FLAT:$LN25@MountDevic
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT _MountDevice@8
_TEXT	SEGMENT
_fsStatus$31358 = -76					; size = 4
_volumeHandle$31350 = -72				; size = 4
_volumeFileObject$31351 = -68				; size = 4
_sidLength$31338 = -64					; size = 4
_tokenUser$31335 = -60					; size = 4
_subContext$31330 = -56					; size = 16
_NewExtension$31328 = -40				; size = 4
_accessToken$31331 = -36				; size = 4
_ntStatus$ = -32					; size = 4
_NewDeviceObject$ = -28					; size = 4
__$SEHRec$ = -24					; size = 24
_DeviceObject$ = 8					; size = 4
_mount$ = 12						; size = 4
_MountDevice@8 PROC					; COMDAT

; 2564 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	6a fe		 push	 -2			; fffffffeH
  00007	68 00 00 00 00	 push	 OFFSET __sehtable$_MountDevice@8
  0000c	68 00 00 00 00	 push	 OFFSET __except_handler4
  00011	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00017	50		 push	 eax
  00018	83 c4 c4	 add	 esp, -60		; ffffffc4H
  0001b	53		 push	 ebx
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00026	33 c5		 xor	 eax, ebp
  00028	50		 push	 eax
  00029	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00032	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp

; 2565 : 	PDEVICE_OBJECT NewDeviceObject;
; 2566 : 	NTSTATUS ntStatus;
; 2567 : 
; 2568 : 	// Make sure the user is asking for a reasonable nDosDriveNo
; 2569 : 	if (mount->nDosDriveNo >= 0 && mount->nDosDriveNo <= 25 && IsDriveLetterAvailable (mount->nDosDriveNo))

  00035	8b 45 0c	 mov	 eax, DWORD PTR _mount$[ebp]
  00038	83 b8 64 02 00
	00 00		 cmp	 DWORD PTR [eax+612], 0
  0003f	7c 2e		 jl	 SHORT $LN20@MountDevic
  00041	8b 4d 0c	 mov	 ecx, DWORD PTR _mount$[ebp]
  00044	83 b9 64 02 00
	00 19		 cmp	 DWORD PTR [ecx+612], 25	; 00000019H
  0004b	7f 22		 jg	 SHORT $LN20@MountDevic
  0004d	8b 55 0c	 mov	 edx, DWORD PTR _mount$[ebp]
  00050	8b 82 64 02 00
	00		 mov	 eax, DWORD PTR [edx+612]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 _IsDriveLetterAvailable@4
  0005c	85 c0		 test	 eax, eax
  0005e	74 0f		 je	 SHORT $LN20@MountDevic

; 2570 : 	{
; 2571 : 		Dump ("Mount request looks valid\n");

  00060	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@PIKDDHEP@Mount?5request?5looks?5valid?6?$AA@FNODOBFM@
  00065	e8 00 00 00 00	 call	 _DbgPrint
  0006a	83 c4 04	 add	 esp, 4

; 2572 : 	}
; 2573 : 	else

  0006d	eb 20		 jmp	 SHORT $LN19@MountDevic
$LN20@MountDevic:

; 2574 : 	{
; 2575 : 		Dump ("WARNING: MOUNT DRIVE LETTER INVALID\n");

  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@CGPMKDKJ@WARNING?3?5MOUNT?5DRIVE?5LETTER?5INVA@FNODOBFM@
  00074	e8 00 00 00 00	 call	 _DbgPrint
  00079	83 c4 04	 add	 esp, 4

; 2576 : 		mount->nReturnCode = ERR_DRIVE_NOT_FOUND;

  0007c	8b 4d 0c	 mov	 ecx, DWORD PTR _mount$[ebp]
  0007f	c7 01 05 00 00
	00		 mov	 DWORD PTR [ecx], 5

; 2577 : 		return ERR_DRIVE_NOT_FOUND;

  00085	b8 05 00 00 00	 mov	 eax, 5
  0008a	e9 be 02 00 00	 jmp	 $LN23@MountDevic
$LN19@MountDevic:

; 2578 : 	}
; 2579 : 
; 2580 : 	if (!SelfTestsPassed)

  0008f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SelfTestsPassed, 0
  00096	75 13		 jne	 SHORT $LN18@MountDevic

; 2581 : 	{
; 2582 : 		mount->nReturnCode = ERR_SELF_TESTS_FAILED;

  00098	8b 55 0c	 mov	 edx, DWORD PTR _mount$[ebp]
  0009b	c7 02 13 00 00
	00		 mov	 DWORD PTR [edx], 19	; 00000013H

; 2583 : 		return ERR_SELF_TESTS_FAILED;

  000a1	b8 13 00 00 00	 mov	 eax, 19			; 00000013H
  000a6	e9 a2 02 00 00	 jmp	 $LN23@MountDevic
$LN18@MountDevic:

; 2584 : 	}
; 2585 : 
; 2586 : 	ntStatus = TCCreateDeviceObject (DeviceObject->DriverObject, &NewDeviceObject, mount);

  000ab	8b 45 0c	 mov	 eax, DWORD PTR _mount$[ebp]
  000ae	50		 push	 eax
  000af	8d 4d e4	 lea	 ecx, DWORD PTR _NewDeviceObject$[ebp]
  000b2	51		 push	 ecx
  000b3	8b 55 08	 mov	 edx, DWORD PTR _DeviceObject$[ebp]
  000b6	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 _TCCreateDeviceObject@12
  000bf	89 45 e0	 mov	 DWORD PTR _ntStatus$[ebp], eax

; 2587 : 
; 2588 : 	if (!NT_SUCCESS (ntStatus))

  000c2	83 7d e0 00	 cmp	 DWORD PTR _ntStatus$[ebp], 0
  000c6	7d 1e		 jge	 SHORT $LN17@MountDevic

; 2589 : 	{
; 2590 : 		Dump ("Mount CREATE DEVICE ERROR, ntStatus = 0x%08x\n", ntStatus);

  000c8	8b 4d e0	 mov	 ecx, DWORD PTR _ntStatus$[ebp]
  000cb	51		 push	 ecx
  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@NNHGPFIJ@Mount?5CREATE?5DEVICE?5ERROR?0?5ntSta@FNODOBFM@
  000d1	e8 00 00 00 00	 call	 _DbgPrint
  000d6	83 c4 08	 add	 esp, 8

; 2591 : 		return ntStatus;

  000d9	8b 45 e0	 mov	 eax, DWORD PTR _ntStatus$[ebp]
  000dc	e9 6c 02 00 00	 jmp	 $LN23@MountDevic

; 2592 : 	}
; 2593 : 	else

  000e1	e9 67 02 00 00	 jmp	 $LN23@MountDevic
$LN17@MountDevic:

; 2594 : 	{
; 2595 : 		PEXTENSION NewExtension = (PEXTENSION) NewDeviceObject->DeviceExtension;

  000e6	8b 55 e4	 mov	 edx, DWORD PTR _NewDeviceObject$[ebp]
  000e9	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  000ec	89 45 d8	 mov	 DWORD PTR _NewExtension$31328[ebp], eax

; 2596 : 		SECURITY_SUBJECT_CONTEXT subContext;
; 2597 : 		PACCESS_TOKEN accessToken;
; 2598 : 
; 2599 : 		SeCaptureSubjectContext (&subContext);

  000ef	8d 4d c8	 lea	 ecx, DWORD PTR _subContext$31330[ebp]
  000f2	51		 push	 ecx
  000f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeCaptureSubjectContext@4

; 2600 : 		SeLockSubjectContext(&subContext);

  000f9	8d 55 c8	 lea	 edx, DWORD PTR _subContext$31330[ebp]
  000fc	52		 push	 edx
  000fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeLockSubjectContext@4

; 2601 : 		accessToken=getToken(&subContext);

  00103	8d 45 c8	 lea	 eax, DWORD PTR _subContext$31330[ebp]
  00106	50		 push	 eax
  00107	e8 00 00 00 00	 call	 _getToken@4
  0010c	89 45 dc	 mov	 DWORD PTR _accessToken$31331[ebp], eax

; 2602 : 
; 2603 : 		if (!accessToken)

  0010f	83 7d dc 00	 cmp	 DWORD PTR _accessToken$31331[ebp], 0
  00113	75 0c		 jne	 SHORT $LN15@MountDevic

; 2604 : 		{
; 2605 : 			ntStatus = STATUS_INVALID_PARAMETER;

  00115	c7 45 e0 0d 00
	00 c0		 mov	 DWORD PTR _ntStatus$[ebp], -1073741811 ; c000000dH

; 2606 : 		}
; 2607 : 		else

  0011c	e9 80 00 00 00	 jmp	 $LN14@MountDevic
$LN15@MountDevic:

; 2608 : 		{
; 2609 : 			PTOKEN_USER tokenUser;
; 2610 : 
; 2611 : 			ntStatus = SeQueryInformationToken (accessToken, TokenUser, &tokenUser);

  00121	8d 4d c4	 lea	 ecx, DWORD PTR _tokenUser$31335[ebp]
  00124	51		 push	 ecx
  00125	6a 01		 push	 1
  00127	8b 55 dc	 mov	 edx, DWORD PTR _accessToken$31331[ebp]
  0012a	52		 push	 edx
  0012b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeQueryInformationToken@12
  00131	89 45 e0	 mov	 DWORD PTR _ntStatus$[ebp], eax

; 2612 : 			if (NT_SUCCESS (ntStatus))

  00134	83 7d e0 00	 cmp	 DWORD PTR _ntStatus$[ebp], 0
  00138	7c 67		 jl	 SHORT $LN14@MountDevic

; 2613 : 			{
; 2614 : 				ULONG sidLength = RtlLengthSid (tokenUser->User.Sid);

  0013a	8b 45 c4	 mov	 eax, DWORD PTR _tokenUser$31335[ebp]
  0013d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013f	51		 push	 ecx
  00140	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLengthSid@4
  00146	89 45 c0	 mov	 DWORD PTR _sidLength$31338[ebp], eax

; 2615 : 
; 2616 : 				NewExtension->UserSid = TCalloc (sidLength);

  00149	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0014e	8b 55 c0	 mov	 edx, DWORD PTR _sidLength$31338[ebp]
  00151	52		 push	 edx
  00152	6a 00		 push	 0
  00154	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0015a	8b 4d d8	 mov	 ecx, DWORD PTR _NewExtension$31328[ebp]
  0015d	89 81 cc 04 00
	00		 mov	 DWORD PTR [ecx+1228], eax

; 2617 : 				if (!NewExtension->UserSid)

  00163	8b 55 d8	 mov	 edx, DWORD PTR _NewExtension$31328[ebp]
  00166	83 ba cc 04 00
	00 00		 cmp	 DWORD PTR [edx+1228], 0
  0016d	75 09		 jne	 SHORT $LN12@MountDevic

; 2618 : 					ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0016f	c7 45 e0 9a 00
	00 c0		 mov	 DWORD PTR _ntStatus$[ebp], -1073741670 ; c000009aH

; 2619 : 				else

  00176	eb 1d		 jmp	 SHORT $LN11@MountDevic
$LN12@MountDevic:

; 2620 : 					ntStatus = RtlCopySid (sidLength, NewExtension->UserSid, tokenUser->User.Sid);

  00178	8b 45 c4	 mov	 eax, DWORD PTR _tokenUser$31335[ebp]
  0017b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0017d	51		 push	 ecx
  0017e	8b 55 d8	 mov	 edx, DWORD PTR _NewExtension$31328[ebp]
  00181	8b 82 cc 04 00
	00		 mov	 eax, DWORD PTR [edx+1228]
  00187	50		 push	 eax
  00188	8b 4d c0	 mov	 ecx, DWORD PTR _sidLength$31338[ebp]
  0018b	51		 push	 ecx
  0018c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlCopySid@12
  00192	89 45 e0	 mov	 DWORD PTR _ntStatus$[ebp], eax
$LN11@MountDevic:

; 2621 : 
; 2622 : 				ExFreePool (tokenUser);		// Documented in newer versions of WDK

  00195	6a 00		 push	 0
  00197	8b 55 c4	 mov	 edx, DWORD PTR _tokenUser$31335[ebp]
  0019a	52		 push	 edx
  0019b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN14@MountDevic:

; 2623 : 			}
; 2624 : 		}
; 2625 : 
; 2626 : 		SeUnlockSubjectContext(&subContext);

  001a1	8d 45 c8	 lea	 eax, DWORD PTR _subContext$31330[ebp]
  001a4	50		 push	 eax
  001a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeUnlockSubjectContext@4

; 2627 : 		SeReleaseSubjectContext (&subContext);

  001ab	8d 4d c8	 lea	 ecx, DWORD PTR _subContext$31330[ebp]
  001ae	51		 push	 ecx
  001af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeReleaseSubjectContext@4

; 2628 : 
; 2629 : 		if (NT_SUCCESS (ntStatus))

  001b5	83 7d e0 00	 cmp	 DWORD PTR _ntStatus$[ebp], 0
  001b9	7c 14		 jl	 SHORT $LN10@MountDevic

; 2630 : 			ntStatus = TCStartVolumeThread (NewDeviceObject, NewExtension, mount);

  001bb	8b 55 0c	 mov	 edx, DWORD PTR _mount$[ebp]
  001be	52		 push	 edx
  001bf	8b 45 d8	 mov	 eax, DWORD PTR _NewExtension$31328[ebp]
  001c2	50		 push	 eax
  001c3	8b 4d e4	 mov	 ecx, DWORD PTR _NewDeviceObject$[ebp]
  001c6	51		 push	 ecx
  001c7	e8 00 00 00 00	 call	 _TCStartVolumeThread@12
  001cc	89 45 e0	 mov	 DWORD PTR _ntStatus$[ebp], eax
$LN10@MountDevic:

; 2631 : 
; 2632 : 		if (!NT_SUCCESS (ntStatus))

  001cf	83 7d e0 00	 cmp	 DWORD PTR _ntStatus$[ebp], 0
  001d3	7d 2b		 jge	 SHORT $LN9@MountDevic

; 2633 : 		{
; 2634 : 			Dump ("Mount FAILURE NT ERROR, ntStatus = 0x%08x\n", ntStatus);

  001d5	8b 55 e0	 mov	 edx, DWORD PTR _ntStatus$[ebp]
  001d8	52		 push	 edx
  001d9	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@KIIHMHE@Mount?5FAILURE?5NT?5ERROR?0?5ntStatus@FNODOBFM@
  001de	e8 00 00 00 00	 call	 _DbgPrint
  001e3	83 c4 08	 add	 esp, 8

; 2635 : 			TCDeleteDeviceObject (NewDeviceObject, NewExtension);

  001e6	8b 45 d8	 mov	 eax, DWORD PTR _NewExtension$31328[ebp]
  001e9	50		 push	 eax
  001ea	8b 4d e4	 mov	 ecx, DWORD PTR _NewDeviceObject$[ebp]
  001ed	51		 push	 ecx
  001ee	e8 00 00 00 00	 call	 _TCDeleteDeviceObject@8

; 2636 : 			return ntStatus;

  001f3	8b 45 e0	 mov	 eax, DWORD PTR _ntStatus$[ebp]
  001f6	e9 52 01 00 00	 jmp	 $LN23@MountDevic

; 2637 : 		}
; 2638 : 		else

  001fb	e9 4d 01 00 00	 jmp	 $LN23@MountDevic
$LN9@MountDevic:

; 2639 : 		{
; 2640 : 			if (mount->nReturnCode == 0)

  00200	8b 55 0c	 mov	 edx, DWORD PTR _mount$[ebp]
  00203	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00206	0f 85 1f 01 00
	00		 jne	 $LN7@MountDevic

; 2641 : 			{
; 2642 : 				HANDLE volumeHandle;
; 2643 : 				PFILE_OBJECT volumeFileObject;
; 2644 : 
; 2645 : 				Dump ("Mount SUCCESS TC code = 0x%08x READ-ONLY = %d\n", mount->nReturnCode, NewExtension->bReadOnly);

  0020c	8b 45 d8	 mov	 eax, DWORD PTR _NewExtension$31328[ebp]
  0020f	8b 88 88 02 00
	00		 mov	 ecx, DWORD PTR [eax+648]
  00215	51		 push	 ecx
  00216	8b 55 0c	 mov	 edx, DWORD PTR _mount$[ebp]
  00219	8b 02		 mov	 eax, DWORD PTR [edx]
  0021b	50		 push	 eax
  0021c	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@DBOFILAH@Mount?5SUCCESS?5TC?5code?5?$DN?50x?$CF08x?5R@FNODOBFM@
  00221	e8 00 00 00 00	 call	 _DbgPrint
  00226	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2646 : 
; 2647 : 				if (NewExtension->bReadOnly)

  00229	8b 4d d8	 mov	 ecx, DWORD PTR _NewExtension$31328[ebp]
  0022c	83 b9 88 02 00
	00 00		 cmp	 DWORD PTR [ecx+648], 0
  00233	74 0f		 je	 SHORT $LN6@MountDevic

; 2648 : 					NewDeviceObject->Characteristics |= FILE_READ_ONLY_DEVICE;

  00235	8b 55 e4	 mov	 edx, DWORD PTR _NewDeviceObject$[ebp]
  00238	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0023b	83 c8 02	 or	 eax, 2
  0023e	8b 4d e4	 mov	 ecx, DWORD PTR _NewDeviceObject$[ebp]
  00241	89 41 20	 mov	 DWORD PTR [ecx+32], eax
$LN6@MountDevic:

; 2649 : 
; 2650 : 				NewDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

  00244	8b 55 e4	 mov	 edx, DWORD PTR _NewDeviceObject$[ebp]
  00247	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0024a	25 7f ff ff ff	 and	 eax, -129		; ffffff7fH
  0024f	8b 4d e4	 mov	 ecx, DWORD PTR _NewDeviceObject$[ebp]
  00252	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 2651 : 
; 2652 : 				NewExtension->UniqueVolumeId = LastUniqueVolumeId++;

  00255	8b 55 d8	 mov	 edx, DWORD PTR _NewExtension$31328[ebp]
  00258	a1 00 00 00 00	 mov	 eax, DWORD PTR _LastUniqueVolumeId
  0025d	89 42 10	 mov	 DWORD PTR [edx+16], eax
  00260	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _LastUniqueVolumeId
  00266	83 c1 01	 add	 ecx, 1
  00269	89 0d 00 00 00
	00		 mov	 DWORD PTR _LastUniqueVolumeId, ecx

; 2653 : 
; 2654 : 				if (mount->bMountManager)

  0026f	8b 55 0c	 mov	 edx, DWORD PTR _mount$[ebp]
  00272	83 ba 78 02 00
	00 00		 cmp	 DWORD PTR [edx+632], 0
  00279	74 09		 je	 SHORT $LN5@MountDevic

; 2655 : 					MountManagerMount (mount);

  0027b	8b 45 0c	 mov	 eax, DWORD PTR _mount$[ebp]
  0027e	50		 push	 eax
  0027f	e8 00 00 00 00	 call	 _MountManagerMount@4
$LN5@MountDevic:

; 2656 : 
; 2657 : 				NewExtension->bMountManager = mount->bMountManager;

  00284	8b 4d d8	 mov	 ecx, DWORD PTR _NewExtension$31328[ebp]
  00287	8b 55 0c	 mov	 edx, DWORD PTR _mount$[ebp]
  0028a	8b 82 78 02 00
	00		 mov	 eax, DWORD PTR [edx+632]
  00290	89 81 98 02 00
	00		 mov	 DWORD PTR [ecx+664], eax

; 2658 : 
; 2659 : 				// We create symbolic link even if mount manager is notified of
; 2660 : 				// arriving volume as it apparently sometimes fails to create the link
; 2661 : 				CreateDriveLink (mount->nDosDriveNo);

  00296	8b 4d 0c	 mov	 ecx, DWORD PTR _mount$[ebp]
  00299	8b 91 64 02 00
	00		 mov	 edx, DWORD PTR [ecx+612]
  0029f	52		 push	 edx
  002a0	e8 00 00 00 00	 call	 _CreateDriveLink@4

; 2662 : 
; 2663 : 				mount->FilesystemDirty = FALSE;

  002a5	8b 45 0c	 mov	 eax, DWORD PTR _mount$[ebp]
  002a8	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 2664 : 
; 2665 : 				if (NT_SUCCESS (TCOpenFsVolume (NewExtension, &volumeHandle, &volumeFileObject)))

  002af	8d 4d bc	 lea	 ecx, DWORD PTR _volumeFileObject$31351[ebp]
  002b2	51		 push	 ecx
  002b3	8d 55 b8	 lea	 edx, DWORD PTR _volumeHandle$31350[ebp]
  002b6	52		 push	 edx
  002b7	8b 45 d8	 mov	 eax, DWORD PTR _NewExtension$31328[ebp]
  002ba	50		 push	 eax
  002bb	e8 00 00 00 00	 call	 _TCOpenFsVolume@12
  002c0	85 c0		 test	 eax, eax
  002c2	7c 65		 jl	 SHORT $LN4@MountDevic

; 2666 : 				{
; 2667 : 					__try

  002c4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 2668 : 					{
; 2669 : 						ULONG fsStatus;
; 2670 : 
; 2671 : 						if (NT_SUCCESS (TCFsctlCall (volumeFileObject, FSCTL_IS_VOLUME_DIRTY, NULL, 0, &fsStatus, sizeof (fsStatus)))
; 2672 : 							&& (fsStatus & VOLUME_IS_DIRTY))

  002cb	6a 04		 push	 4
  002cd	8d 4d b4	 lea	 ecx, DWORD PTR _fsStatus$31358[ebp]
  002d0	51		 push	 ecx
  002d1	6a 00		 push	 0
  002d3	6a 00		 push	 0
  002d5	68 78 00 09 00	 push	 589944			; 00090078H
  002da	8b 55 bc	 mov	 edx, DWORD PTR _volumeFileObject$31351[ebp]
  002dd	52		 push	 edx
  002de	e8 00 00 00 00	 call	 _TCFsctlCall@24
  002e3	85 c0		 test	 eax, eax
  002e5	7c 12		 jl	 SHORT $LN3@MountDevic
  002e7	8b 45 b4	 mov	 eax, DWORD PTR _fsStatus$31358[ebp]
  002ea	83 e0 01	 and	 eax, 1
  002ed	74 0a		 je	 SHORT $LN3@MountDevic

; 2673 : 						{
; 2674 : 							mount->FilesystemDirty = TRUE;

  002ef	8b 4d 0c	 mov	 ecx, DWORD PTR _mount$[ebp]
  002f2	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [ecx+4], 1
$LN3@MountDevic:

; 2675 : 						}
; 2676 : 					}

  002f9	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  00300	eb 1a		 jmp	 SHORT $LN27@MountDevic
$LN24@MountDevic:
$LN29@MountDevic:

; 2677 : 					__except (EXCEPTION_EXECUTE_HANDLER)

  00302	b8 01 00 00 00	 mov	 eax, 1
$LN26@MountDevic:
$LN28@MountDevic:
  00307	c3		 ret	 0
$LN25@MountDevic:
  00308	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 2678 : 					{
; 2679 : 						mount->FilesystemDirty = TRUE;

  0030b	8b 55 0c	 mov	 edx, DWORD PTR _mount$[ebp]
  0030e	c7 42 04 01 00
	00 00		 mov	 DWORD PTR [edx+4], 1

; 2680 : 					}

  00315	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
$LN27@MountDevic:

; 2681 : 
; 2682 : 
; 2683 : 					TCCloseFsVolume (volumeHandle, volumeFileObject);

  0031c	8b 45 bc	 mov	 eax, DWORD PTR _volumeFileObject$31351[ebp]
  0031f	50		 push	 eax
  00320	8b 4d b8	 mov	 ecx, DWORD PTR _volumeHandle$31350[ebp]
  00323	51		 push	 ecx
  00324	e8 00 00 00 00	 call	 _TCCloseFsVolume@8
$LN4@MountDevic:

; 2684 : 				}
; 2685 : 			}
; 2686 : 			else

  00329	eb 20		 jmp	 SHORT $LN1@MountDevic
$LN7@MountDevic:

; 2687 : 			{
; 2688 : 				Dump ("Mount FAILURE TC code = 0x%08x\n", mount->nReturnCode);

  0032b	8b 55 0c	 mov	 edx, DWORD PTR _mount$[ebp]
  0032e	8b 02		 mov	 eax, DWORD PTR [edx]
  00330	50		 push	 eax
  00331	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@IJMBHFOD@Mount?5FAILURE?5TC?5code?5?$DN?50x?$CF08x?6?$AA@FNODOBFM@
  00336	e8 00 00 00 00	 call	 _DbgPrint
  0033b	83 c4 08	 add	 esp, 8

; 2689 : 				TCDeleteDeviceObject (NewDeviceObject, NewExtension);

  0033e	8b 4d d8	 mov	 ecx, DWORD PTR _NewExtension$31328[ebp]
  00341	51		 push	 ecx
  00342	8b 55 e4	 mov	 edx, DWORD PTR _NewDeviceObject$[ebp]
  00345	52		 push	 edx
  00346	e8 00 00 00 00	 call	 _TCDeleteDeviceObject@8
$LN1@MountDevic:

; 2690 : 			}
; 2691 : 			
; 2692 : 			return STATUS_SUCCESS;

  0034b	33 c0		 xor	 eax, eax
$LN23@MountDevic:

; 2693 : 		}
; 2694 : 	}
; 2695 : }

  0034d	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00350	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00357	59		 pop	 ecx
  00358	5f		 pop	 edi
  00359	5e		 pop	 esi
  0035a	5b		 pop	 ebx
  0035b	8b e5		 mov	 esp, ebp
  0035d	5d		 pop	 ebp
  0035e	c2 08 00	 ret	 8
_MountDevice@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@FFMFJFAI@FSCTL_DISMOUNT_VOLUME?5returned?5?$CF@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BP@EOHNIHMK@FSCTL_LOCK_VOLUME?5returned?5?$CFX?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_IsOSAtLeast@4
PUBLIC	??_C@_0BC@FNOALNCB@UnmountDevice?5?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp__IoReleaseRemoveLockAndWaitEx@12:PROC
;	COMDAT ??_C@_0CD@FFMFJFAI@FSCTL_DISMOUNT_VOLUME?5returned?5?$CF@FNODOBFM@
text$s	SEGMENT
??_C@_0CD@FFMFJFAI@FSCTL_DISMOUNT_VOLUME?5returned?5?$CF@FNODOBFM@ DB 'FS'
	DB	'CTL_DISMOUNT_VOLUME returned %X', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BP@EOHNIHMK@FSCTL_LOCK_VOLUME?5returned?5?$CFX?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BP@EOHNIHMK@FSCTL_LOCK_VOLUME?5returned?5?$CFX?6?$AA@FNODOBFM@ DB 'F'
	DB	'SCTL_LOCK_VOLUME returned %X', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BC@FNOALNCB@UnmountDevice?5?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BC@FNOALNCB@UnmountDevice?5?$CFd?6?$AA@FNODOBFM@ DB 'UnmountDevice'
	DB	' %d', 0aH, 00H				;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _UnmountDevice@12
_TEXT	SEGMENT
tv184 = -132						; size = 4
tv168 = -128						; size = 4
_cryptoInfo$31415 = -124				; size = 4
_ntfsData$31381 = -120					; size = 96
_dismountRetry$31379 = -20				; size = 4
_ntStatus$ = -16					; size = 4
_extension$ = -12					; size = 4
_volumeHandle$ = -8					; size = 4
_volumeFileObject$ = -4					; size = 4
_unmountRequest$ = 8					; size = 4
_deviceObject$ = 12					; size = 4
_ignoreOpenFiles$ = 16					; size = 4
_UnmountDevice@12 PROC					; COMDAT

; 2698 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H

; 2699 : 	PEXTENSION extension = deviceObject->DeviceExtension;

  0000b	8b 45 0c	 mov	 eax, DWORD PTR _deviceObject$[ebp]
  0000e	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00011	89 4d f4	 mov	 DWORD PTR _extension$[ebp], ecx

; 2700 : 	NTSTATUS ntStatus;
; 2701 : 	HANDLE volumeHandle;
; 2702 : 	PFILE_OBJECT volumeFileObject;
; 2703 : 
; 2704 : 	Dump ("UnmountDevice %d\n", extension->nDosDriveNo);

  00014	8b 55 f4	 mov	 edx, DWORD PTR _extension$[ebp]
  00017	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0001a	50		 push	 eax
  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@FNOALNCB@UnmountDevice?5?$CFd?6?$AA@FNODOBFM@
  00020	e8 00 00 00 00	 call	 _DbgPrint
  00025	83 c4 08	 add	 esp, 8

; 2705 : 
; 2706 : 	ntStatus = TCOpenFsVolume (extension, &volumeHandle, &volumeFileObject);

  00028	8d 4d fc	 lea	 ecx, DWORD PTR _volumeFileObject$[ebp]
  0002b	51		 push	 ecx
  0002c	8d 55 f8	 lea	 edx, DWORD PTR _volumeHandle$[ebp]
  0002f	52		 push	 edx
  00030	8b 45 f4	 mov	 eax, DWORD PTR _extension$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _TCOpenFsVolume@12
  00039	89 45 f0	 mov	 DWORD PTR _ntStatus$[ebp], eax

; 2707 : 
; 2708 : 	if (NT_SUCCESS (ntStatus))

  0003c	83 7d f0 00	 cmp	 DWORD PTR _ntStatus$[ebp], 0
  00040	0f 8c 08 01 00
	00		 jl	 $LN16@UnmountDev

; 2709 : 	{
; 2710 : 		int dismountRetry;
; 2711 : 
; 2712 : 		// Dismounting a writable NTFS filesystem prevents the driver from being unloaded on Windows 7
; 2713 : 		if (IsOSAtLeast (WIN_7) && !extension->bReadOnly)

  00046	6a 0d		 push	 13			; 0000000dH
  00048	e8 00 00 00 00	 call	 _IsOSAtLeast@4
  0004d	85 c0		 test	 eax, eax
  0004f	74 32		 je	 SHORT $LN15@UnmountDev
  00051	8b 4d f4	 mov	 ecx, DWORD PTR _extension$[ebp]
  00054	83 b9 88 02 00
	00 00		 cmp	 DWORD PTR [ecx+648], 0
  0005b	75 26		 jne	 SHORT $LN15@UnmountDev

; 2714 : 		{
; 2715 : 			NTFS_VOLUME_DATA_BUFFER ntfsData;
; 2716 : 
; 2717 : 			if (NT_SUCCESS (TCFsctlCall (volumeFileObject, FSCTL_GET_NTFS_VOLUME_DATA, NULL, 0, &ntfsData, sizeof (ntfsData))))

  0005d	6a 60		 push	 96			; 00000060H
  0005f	8d 55 88	 lea	 edx, DWORD PTR _ntfsData$31381[ebp]
  00062	52		 push	 edx
  00063	6a 00		 push	 0
  00065	6a 00		 push	 0
  00067	68 64 00 09 00	 push	 589924			; 00090064H
  0006c	8b 45 fc	 mov	 eax, DWORD PTR _volumeFileObject$[ebp]
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 _TCFsctlCall@24
  00075	85 c0		 test	 eax, eax
  00077	7c 0a		 jl	 SHORT $LN15@UnmountDev

; 2718 : 				DriverUnloadDisabled = TRUE;

  00079	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _DriverUnloadDisabled, 1
$LN15@UnmountDev:

; 2719 : 		}
; 2720 : 
; 2721 : 		// Lock volume
; 2722 : 		ntStatus = TCFsctlCall (volumeFileObject, FSCTL_LOCK_VOLUME, NULL, 0, NULL, 0);

  00083	6a 00		 push	 0
  00085	6a 00		 push	 0
  00087	6a 00		 push	 0
  00089	6a 00		 push	 0
  0008b	68 18 00 09 00	 push	 589848			; 00090018H
  00090	8b 4d fc	 mov	 ecx, DWORD PTR _volumeFileObject$[ebp]
  00093	51		 push	 ecx
  00094	e8 00 00 00 00	 call	 _TCFsctlCall@24
  00099	89 45 f0	 mov	 DWORD PTR _ntStatus$[ebp], eax

; 2723 : 		Dump ("FSCTL_LOCK_VOLUME returned %X\n", ntStatus);

  0009c	8b 55 f0	 mov	 edx, DWORD PTR _ntStatus$[ebp]
  0009f	52		 push	 edx
  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@EOHNIHMK@FSCTL_LOCK_VOLUME?5returned?5?$CFX?6?$AA@FNODOBFM@
  000a5	e8 00 00 00 00	 call	 _DbgPrint
  000aa	83 c4 08	 add	 esp, 8

; 2724 : 
; 2725 : 		if (!NT_SUCCESS (ntStatus) && !ignoreOpenFiles)

  000ad	83 7d f0 00	 cmp	 DWORD PTR _ntStatus$[ebp], 0
  000b1	7d 1d		 jge	 SHORT $LN13@UnmountDev
  000b3	83 7d 10 00	 cmp	 DWORD PTR _ignoreOpenFiles$[ebp], 0
  000b7	75 17		 jne	 SHORT $LN13@UnmountDev

; 2726 : 		{
; 2727 : 			TCCloseFsVolume (volumeHandle, volumeFileObject);

  000b9	8b 45 fc	 mov	 eax, DWORD PTR _volumeFileObject$[ebp]
  000bc	50		 push	 eax
  000bd	8b 4d f8	 mov	 ecx, DWORD PTR _volumeHandle$[ebp]
  000c0	51		 push	 ecx
  000c1	e8 00 00 00 00	 call	 _TCCloseFsVolume@8

; 2728 : 			return ERR_FILES_OPEN;

  000c6	b8 06 00 00 00	 mov	 eax, 6
  000cb	e9 98 01 00 00	 jmp	 $LN17@UnmountDev
$LN13@UnmountDev:

; 2729 : 		}
; 2730 : 
; 2731 : 		// Dismount volume
; 2732 : 		for (dismountRetry = 0; dismountRetry < 200; ++dismountRetry)

  000d0	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _dismountRetry$31379[ebp], 0
  000d7	eb 09		 jmp	 SHORT $LN12@UnmountDev
$LN11@UnmountDev:
  000d9	8b 55 ec	 mov	 edx, DWORD PTR _dismountRetry$31379[ebp]
  000dc	83 c2 01	 add	 edx, 1
  000df	89 55 ec	 mov	 DWORD PTR _dismountRetry$31379[ebp], edx
$LN12@UnmountDev:
  000e2	81 7d ec c8 00
	00 00		 cmp	 DWORD PTR _dismountRetry$31379[ebp], 200 ; 000000c8H
  000e9	7d 61		 jge	 SHORT $LN10@UnmountDev

; 2733 : 		{
; 2734 : 			ntStatus = TCFsctlCall (volumeFileObject, FSCTL_DISMOUNT_VOLUME, NULL, 0, NULL, 0);

  000eb	6a 00		 push	 0
  000ed	6a 00		 push	 0
  000ef	6a 00		 push	 0
  000f1	6a 00		 push	 0
  000f3	68 20 00 09 00	 push	 589856			; 00090020H
  000f8	8b 45 fc	 mov	 eax, DWORD PTR _volumeFileObject$[ebp]
  000fb	50		 push	 eax
  000fc	e8 00 00 00 00	 call	 _TCFsctlCall@24
  00101	89 45 f0	 mov	 DWORD PTR _ntStatus$[ebp], eax

; 2735 : 			Dump ("FSCTL_DISMOUNT_VOLUME returned %X\n", ntStatus);

  00104	8b 4d f0	 mov	 ecx, DWORD PTR _ntStatus$[ebp]
  00107	51		 push	 ecx
  00108	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@FFMFJFAI@FSCTL_DISMOUNT_VOLUME?5returned?5?$CF@FNODOBFM@
  0010d	e8 00 00 00 00	 call	 _DbgPrint
  00112	83 c4 08	 add	 esp, 8

; 2736 : 
; 2737 : 			if (NT_SUCCESS (ntStatus) || ntStatus == STATUS_VOLUME_DISMOUNTED)

  00115	83 7d f0 00	 cmp	 DWORD PTR _ntStatus$[ebp], 0
  00119	7d 09		 jge	 SHORT $LN8@UnmountDev
  0011b	81 7d f0 6e 02
	00 c0		 cmp	 DWORD PTR _ntStatus$[ebp], -1073741202 ; c000026eH
  00122	75 02		 jne	 SHORT $LN9@UnmountDev
$LN8@UnmountDev:

; 2738 : 				break;

  00124	eb 26		 jmp	 SHORT $LN10@UnmountDev
$LN9@UnmountDev:

; 2739 : 
; 2740 : 			if (!ignoreOpenFiles)

  00126	83 7d 10 00	 cmp	 DWORD PTR _ignoreOpenFiles$[ebp], 0
  0012a	75 17		 jne	 SHORT $LN7@UnmountDev

; 2741 : 			{
; 2742 : 				TCCloseFsVolume (volumeHandle, volumeFileObject);

  0012c	8b 55 fc	 mov	 edx, DWORD PTR _volumeFileObject$[ebp]
  0012f	52		 push	 edx
  00130	8b 45 f8	 mov	 eax, DWORD PTR _volumeHandle$[ebp]
  00133	50		 push	 eax
  00134	e8 00 00 00 00	 call	 _TCCloseFsVolume@8

; 2743 : 				return ERR_FILES_OPEN;

  00139	b8 06 00 00 00	 mov	 eax, 6
  0013e	e9 25 01 00 00	 jmp	 $LN17@UnmountDev
$LN7@UnmountDev:

; 2744 : 			}
; 2745 : 
; 2746 : 			TCSleep (100);

  00143	6a 64		 push	 100			; 00000064H
  00145	e8 00 00 00 00	 call	 _TCSleep@4

; 2747 : 		}

  0014a	eb 8d		 jmp	 SHORT $LN11@UnmountDev
$LN10@UnmountDev:

; 2748 : 	}
; 2749 : 	else 

  0014c	eb 19		 jmp	 SHORT $LN6@UnmountDev
$LN16@UnmountDev:

; 2750 : 	{
; 2751 : 		// Volume cannot be opened => force dismount if allowed
; 2752 : 		if (!ignoreOpenFiles)

  0014e	83 7d 10 00	 cmp	 DWORD PTR _ignoreOpenFiles$[ebp], 0
  00152	75 0c		 jne	 SHORT $LN5@UnmountDev

; 2753 : 			return ERR_FILES_OPEN;

  00154	b8 06 00 00 00	 mov	 eax, 6
  00159	e9 0a 01 00 00	 jmp	 $LN17@UnmountDev

; 2754 : 		else

  0015e	eb 07		 jmp	 SHORT $LN6@UnmountDev
$LN5@UnmountDev:

; 2755 : 			volumeHandle = NULL;

  00160	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _volumeHandle$[ebp], 0
$LN6@UnmountDev:

; 2756 : 	}
; 2757 : 
; 2758 : 	if (extension->bMountManager)

  00167	8b 4d f4	 mov	 ecx, DWORD PTR _extension$[ebp]
  0016a	83 b9 98 02 00
	00 00		 cmp	 DWORD PTR [ecx+664], 0
  00171	74 0c		 je	 SHORT $LN3@UnmountDev

; 2759 : 		MountManagerUnmount (extension->nDosDriveNo);

  00173	8b 55 f4	 mov	 edx, DWORD PTR _extension$[ebp]
  00176	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00179	50		 push	 eax
  0017a	e8 00 00 00 00	 call	 _MountManagerUnmount@4
$LN3@UnmountDev:

; 2760 : 
; 2761 : 	// We always remove symbolic link as mount manager might fail to do so
; 2762 : 	RemoveDriveLink (extension->nDosDriveNo);

  0017f	8b 4d f4	 mov	 ecx, DWORD PTR _extension$[ebp]
  00182	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00185	52		 push	 edx
  00186	e8 00 00 00 00	 call	 _RemoveDriveLink@4

; 2763 : 
; 2764 : 	extension->bShuttingDown = TRUE;

  0018b	8b 45 f4	 mov	 eax, DWORD PTR _extension$[ebp]
  0018e	c7 40 18 01 00
	00 00		 mov	 DWORD PTR [eax+24], 1

; 2765 : 
; 2766 : 	ntStatus = IoAcquireRemoveLock (&extension->Queue.RemoveLock, NULL);

  00195	6a 58		 push	 88			; 00000058H
  00197	68 ce 0a 00 00	 push	 2766			; 00000aceH
  0019c	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  001a1	6a 00		 push	 0
  001a3	8b 4d f4	 mov	 ecx, DWORD PTR _extension$[ebp]
  001a6	81 c1 18 01 00
	00		 add	 ecx, 280		; 00000118H
  001ac	51		 push	 ecx
  001ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAcquireRemoveLockEx@20
  001b3	89 45 f0	 mov	 DWORD PTR _ntStatus$[ebp], eax

; 2767 : 	ASSERT (NT_SUCCESS (ntStatus));

  001b6	83 7d f0 00	 cmp	 DWORD PTR _ntStatus$[ebp], 0
  001ba	7d 20		 jge	 SHORT $LN19@UnmountDev
  001bc	6a 00		 push	 0
  001be	68 cf 0a 00 00	 push	 2767			; 00000acfH
  001c3	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  001c8	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@MEOILBFO@NT_SUCCESS?5?$CIntStatus?$CJ?$AA@FNODOBFM@
  001cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  001d3	c7 45 80 00 00
	00 00		 mov	 DWORD PTR tv168[ebp], 0
  001da	eb 07		 jmp	 SHORT $LN20@UnmountDev
$LN19@UnmountDev:
  001dc	c7 45 80 01 00
	00 00		 mov	 DWORD PTR tv168[ebp], 1
$LN20@UnmountDev:

; 2768 : 	IoReleaseRemoveLockAndWait (&extension->Queue.RemoveLock, NULL);

  001e3	6a 58		 push	 88			; 00000058H
  001e5	6a 00		 push	 0
  001e7	8b 55 f4	 mov	 edx, DWORD PTR _extension$[ebp]
  001ea	81 c2 18 01 00
	00		 add	 edx, 280		; 00000118H
  001f0	52		 push	 edx
  001f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockAndWaitEx@12

; 2769 : 
; 2770 : 	if (volumeHandle != NULL)

  001f7	83 7d f8 00	 cmp	 DWORD PTR _volumeHandle$[ebp], 0
  001fb	74 0d		 je	 SHORT $LN2@UnmountDev

; 2771 : 		TCCloseFsVolume (volumeHandle, volumeFileObject);

  001fd	8b 45 fc	 mov	 eax, DWORD PTR _volumeFileObject$[ebp]
  00200	50		 push	 eax
  00201	8b 4d f8	 mov	 ecx, DWORD PTR _volumeHandle$[ebp]
  00204	51		 push	 ecx
  00205	e8 00 00 00 00	 call	 _TCCloseFsVolume@8
$LN2@UnmountDev:

; 2772 : 
; 2773 : 	if (unmountRequest)

  0020a	83 7d 08 00	 cmp	 DWORD PTR _unmountRequest$[ebp], 0
  0020e	74 46		 je	 SHORT $LN1@UnmountDev

; 2774 : 	{
; 2775 : 		PCRYPTO_INFO cryptoInfo = ((PEXTENSION) deviceObject->DeviceExtension)->cryptoInfo;

  00210	8b 55 0c	 mov	 edx, DWORD PTR _deviceObject$[ebp]
  00213	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00216	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00219	89 4d 84	 mov	 DWORD PTR _cryptoInfo$31415[ebp], ecx

; 2776 : 		unmountRequest->HiddenVolumeProtectionTriggered = (cryptoInfo->bProtectHiddenVolume && cryptoInfo->bHiddenVolProtectionAction);

  0021c	8b 55 84	 mov	 edx, DWORD PTR _cryptoInfo$31415[ebp]
  0021f	83 ba 00 44 00
	00 00		 cmp	 DWORD PTR [edx+17408], 0
  00226	74 18		 je	 SHORT $LN21@UnmountDev
  00228	8b 45 84	 mov	 eax, DWORD PTR _cryptoInfo$31415[ebp]
  0022b	83 b8 04 44 00
	00 00		 cmp	 DWORD PTR [eax+17412], 0
  00232	74 0c		 je	 SHORT $LN21@UnmountDev
  00234	c7 85 7c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv184[ebp], 1
  0023e	eb 0a		 jmp	 SHORT $LN22@UnmountDev
$LN21@UnmountDev:
  00240	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv184[ebp], 0
$LN22@UnmountDev:
  0024a	8b 4d 08	 mov	 ecx, DWORD PTR _unmountRequest$[ebp]
  0024d	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR tv184[ebp]
  00253	89 51 08	 mov	 DWORD PTR [ecx+8], edx
$LN1@UnmountDev:

; 2777 : 	}
; 2778 : 
; 2779 : 	TCDeleteDeviceObject (deviceObject, (PEXTENSION) deviceObject->DeviceExtension);

  00256	8b 45 0c	 mov	 eax, DWORD PTR _deviceObject$[ebp]
  00259	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0025c	51		 push	 ecx
  0025d	8b 55 0c	 mov	 edx, DWORD PTR _deviceObject$[ebp]
  00260	52		 push	 edx
  00261	e8 00 00 00 00	 call	 _TCDeleteDeviceObject@8

; 2780 : 	return 0;

  00266	33 c0		 xor	 eax, eax
$LN17@UnmountDev:

; 2781 : }

  00268	8b e5		 mov	 esp, ebp
  0026a	5d		 pop	 ebp
  0026b	c2 0c 00	 ret	 12			; 0000000cH
_UnmountDevice@12 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@OJEECLJN@Unmounting?5all?5volumes?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0BI@OJEECLJN@Unmounting?5all?5volumes?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BI@OJEECLJN@Unmounting?5all?5volumes?6?$AA@FNODOBFM@ DB 'Unmountin'
	DB	'g all volumes', 0aH, 00H			;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _UnmountAllDevices@8
_TEXT	SEGMENT
tv83 = -24						; size = 4
_ntStatus$31451 = -20					; size = 4
_ListExtension$31448 = -16				; size = 4
_maxUniqueId$ = -12					; size = 4
_status$ = -8						; size = 4
_ListDevice$ = -4					; size = 4
_unmountRequest$ = 8					; size = 4
_ignoreOpenFiles$ = 12					; size = 4
_UnmountAllDevices@8 PROC				; COMDAT

; 2809 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 18	 sub	 esp, 24			; 00000018H

; 2810 : 	NTSTATUS status = 0;

  00008	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _status$[ebp], 0

; 2811 : 	PDEVICE_OBJECT ListDevice;
; 2812 : 	int maxUniqueId = LastUniqueVolumeId;

  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR _LastUniqueVolumeId
  00014	89 45 f4	 mov	 DWORD PTR _maxUniqueId$[ebp], eax

; 2813 : 
; 2814 : 	Dump ("Unmounting all volumes\n");

  00017	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@OJEECLJN@Unmounting?5all?5volumes?6?$AA@FNODOBFM@
  0001c	e8 00 00 00 00	 call	 _DbgPrint
  00021	83 c4 04	 add	 esp, 4

; 2815 : 
; 2816 : 	if (unmountRequest)

  00024	83 7d 08 00	 cmp	 DWORD PTR _unmountRequest$[ebp], 0
  00028	74 0a		 je	 SHORT $LN5@UnmountAll

; 2817 : 		unmountRequest->HiddenVolumeProtectionTriggered = FALSE;

  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _unmountRequest$[ebp]
  0002d	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
$LN5@UnmountAll:

; 2818 : 
; 2819 : 	// Dismount volumes in the reverse order they were mounted to properly dismount nested volumes
; 2820 : 	while ((ListDevice = FindVolumeWithHighestUniqueId (maxUniqueId)) != NULL)

  00034	8b 55 f4	 mov	 edx, DWORD PTR _maxUniqueId$[ebp]
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 _FindVolumeWithHighestUniqueId@4
  0003d	89 45 fc	 mov	 DWORD PTR _ListDevice$[ebp], eax
  00040	83 7d fc 00	 cmp	 DWORD PTR _ListDevice$[ebp], 0
  00044	74 77		 je	 SHORT $LN4@UnmountAll

; 2821 : 	{
; 2822 : 		PEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;

  00046	8b 45 fc	 mov	 eax, DWORD PTR _ListDevice$[ebp]
  00049	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0004c	89 4d f0	 mov	 DWORD PTR _ListExtension$31448[ebp], ecx

; 2823 : 		maxUniqueId = ListExtension->UniqueVolumeId - 1;

  0004f	8b 55 f0	 mov	 edx, DWORD PTR _ListExtension$31448[ebp]
  00052	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00055	83 e8 01	 sub	 eax, 1
  00058	89 45 f4	 mov	 DWORD PTR _maxUniqueId$[ebp], eax

; 2824 : 
; 2825 : 		if (IsVolumeAccessibleByCurrentUser (ListExtension))

  0005b	8b 4d f0	 mov	 ecx, DWORD PTR _ListExtension$31448[ebp]
  0005e	51		 push	 ecx
  0005f	e8 00 00 00 00	 call	 _IsVolumeAccessibleByCurrentUser@4
  00064	85 c0		 test	 eax, eax
  00066	74 50		 je	 SHORT $LN3@UnmountAll

; 2826 : 		{
; 2827 : 			NTSTATUS ntStatus;
; 2828 : 
; 2829 : 			if (unmountRequest)

  00068	83 7d 08 00	 cmp	 DWORD PTR _unmountRequest$[ebp], 0
  0006c	74 0b		 je	 SHORT $LN2@UnmountAll

; 2830 : 				unmountRequest->nDosDriveNo = ListExtension->nDosDriveNo;

  0006e	8b 55 08	 mov	 edx, DWORD PTR _unmountRequest$[ebp]
  00071	8b 45 f0	 mov	 eax, DWORD PTR _ListExtension$31448[ebp]
  00074	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00077	89 0a		 mov	 DWORD PTR [edx], ecx
$LN2@UnmountAll:

; 2831 : 
; 2832 : 			ntStatus = UnmountDevice (unmountRequest, ListDevice, ignoreOpenFiles);

  00079	8b 55 0c	 mov	 edx, DWORD PTR _ignoreOpenFiles$[ebp]
  0007c	52		 push	 edx
  0007d	8b 45 fc	 mov	 eax, DWORD PTR _ListDevice$[ebp]
  00080	50		 push	 eax
  00081	8b 4d 08	 mov	 ecx, DWORD PTR _unmountRequest$[ebp]
  00084	51		 push	 ecx
  00085	e8 00 00 00 00	 call	 _UnmountDevice@12
  0008a	89 45 ec	 mov	 DWORD PTR _ntStatus$31451[ebp], eax

; 2833 : 			status = ntStatus == 0 ? status : ntStatus;

  0008d	83 7d ec 00	 cmp	 DWORD PTR _ntStatus$31451[ebp], 0
  00091	75 08		 jne	 SHORT $LN9@UnmountAll
  00093	8b 55 f8	 mov	 edx, DWORD PTR _status$[ebp]
  00096	89 55 e8	 mov	 DWORD PTR tv83[ebp], edx
  00099	eb 06		 jmp	 SHORT $LN10@UnmountAll
$LN9@UnmountAll:
  0009b	8b 45 ec	 mov	 eax, DWORD PTR _ntStatus$31451[ebp]
  0009e	89 45 e8	 mov	 DWORD PTR tv83[ebp], eax
$LN10@UnmountAll:
  000a1	8b 4d e8	 mov	 ecx, DWORD PTR tv83[ebp]
  000a4	89 4d f8	 mov	 DWORD PTR _status$[ebp], ecx

; 2834 : 
; 2835 : 			if (unmountRequest && unmountRequest->HiddenVolumeProtectionTriggered)

  000a7	83 7d 08 00	 cmp	 DWORD PTR _unmountRequest$[ebp], 0
  000ab	74 0b		 je	 SHORT $LN3@UnmountAll
  000ad	8b 55 08	 mov	 edx, DWORD PTR _unmountRequest$[ebp]
  000b0	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  000b4	74 02		 je	 SHORT $LN3@UnmountAll

; 2836 : 				break;

  000b6	eb 05		 jmp	 SHORT $LN4@UnmountAll
$LN3@UnmountAll:

; 2837 : 		}
; 2838 : 	}

  000b8	e9 77 ff ff ff	 jmp	 $LN5@UnmountAll
$LN4@UnmountAll:

; 2839 : 
; 2840 : 	return status;

  000bd	8b 45 f8	 mov	 eax, DWORD PTR _status$[ebp]

; 2841 : }

  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c2 08 00	 ret	 8
_UnmountAllDevices@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _FindVolumeWithHighestUniqueId@4
_TEXT	SEGMENT
_extension$31431 = -20					; size = 4
_device$31429 = -16					; size = 4
_highestIdDevice$ = -12					; size = 4
_drive$ = -8						; size = 4
_highestId$ = -4					; size = 4
_maxUniqueId$ = 8					; size = 4
_FindVolumeWithHighestUniqueId@4 PROC			; COMDAT

; 2785 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 14	 sub	 esp, 20			; 00000014H

; 2786 : 	PDEVICE_OBJECT highestIdDevice = NULL;

  00008	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _highestIdDevice$[ebp], 0

; 2787 : 	int highestId = -1;

  0000f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _highestId$[ebp], -1

; 2788 : 	int drive;
; 2789 : 
; 2790 : 	for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)

  00016	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _drive$[ebp], 0
  0001d	eb 09		 jmp	 SHORT $LN5@FindVolume
$LN4@FindVolume:
  0001f	8b 45 f8	 mov	 eax, DWORD PTR _drive$[ebp]
  00022	83 c0 01	 add	 eax, 1
  00025	89 45 f8	 mov	 DWORD PTR _drive$[ebp], eax
$LN5@FindVolume:
  00028	83 7d f8 19	 cmp	 DWORD PTR _drive$[ebp], 25 ; 00000019H
  0002c	7f 42		 jg	 SHORT $LN3@FindVolume

; 2791 : 	{
; 2792 : 		PDEVICE_OBJECT device = GetVirtualVolumeDeviceObject (drive);

  0002e	8b 4d f8	 mov	 ecx, DWORD PTR _drive$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _GetVirtualVolumeDeviceObject@4
  00037	89 45 f0	 mov	 DWORD PTR _device$31429[ebp], eax

; 2793 : 		if (device)

  0003a	83 7d f0 00	 cmp	 DWORD PTR _device$31429[ebp], 0
  0003e	74 2e		 je	 SHORT $LN2@FindVolume

; 2794 : 		{
; 2795 : 			PEXTENSION extension = (PEXTENSION) device->DeviceExtension;

  00040	8b 55 f0	 mov	 edx, DWORD PTR _device$31429[ebp]
  00043	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00046	89 45 ec	 mov	 DWORD PTR _extension$31431[ebp], eax

; 2796 : 			if (extension->UniqueVolumeId > highestId && extension->UniqueVolumeId <= maxUniqueId)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _extension$31431[ebp]
  0004c	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0004f	3b 55 fc	 cmp	 edx, DWORD PTR _highestId$[ebp]
  00052	7e 1a		 jle	 SHORT $LN2@FindVolume
  00054	8b 45 ec	 mov	 eax, DWORD PTR _extension$31431[ebp]
  00057	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0005a	3b 4d 08	 cmp	 ecx, DWORD PTR _maxUniqueId$[ebp]
  0005d	7f 0f		 jg	 SHORT $LN2@FindVolume

; 2797 : 			{
; 2798 : 				highestId = extension->UniqueVolumeId;

  0005f	8b 55 ec	 mov	 edx, DWORD PTR _extension$31431[ebp]
  00062	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00065	89 45 fc	 mov	 DWORD PTR _highestId$[ebp], eax

; 2799 : 				highestIdDevice = device;

  00068	8b 4d f0	 mov	 ecx, DWORD PTR _device$31429[ebp]
  0006b	89 4d f4	 mov	 DWORD PTR _highestIdDevice$[ebp], ecx
$LN2@FindVolume:

; 2800 : 			}
; 2801 : 		}
; 2802 : 	}

  0006e	eb af		 jmp	 SHORT $LN4@FindVolume
$LN3@FindVolume:

; 2803 : 
; 2804 : 	return highestIdDevice;

  00070	8b 45 f4	 mov	 eax, DWORD PTR _highestIdDevice$[ebp]

; 2805 : }

  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c2 04 00	 ret	 4
_FindVolumeWithHighestUniqueId@4 ENDP
_TEXT	ENDS
EXTRN	__imp__ZwQuerySymbolicLinkObject@12:PROC
EXTRN	__imp__ZwOpenSymbolicLinkObject@12:PROC
; Function compile flags: /Odtp
;	COMDAT _SymbolicLinkToTarget@12
_TEXT	SEGMENT
_target$31471 = -48					; size = 8
_handle$ = -40						; size = 4
_fullFileName$ = -36					; size = 8
_ntStatus$ = -28					; size = 4
_objectAttributes$ = -24				; size = 24
_symlinkName$ = 8					; size = 4
_targetName$ = 12					; size = 4
_maxTargetNameLength$ = 16				; size = 2
_SymbolicLinkToTarget@12 PROC				; COMDAT

; 2845 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 30	 sub	 esp, 48			; 00000030H

; 2846 : 	NTSTATUS ntStatus;
; 2847 : 	OBJECT_ATTRIBUTES objectAttributes;
; 2848 : 	UNICODE_STRING fullFileName;
; 2849 : 	HANDLE handle;
; 2850 : 
; 2851 : 	RtlInitUnicodeString (&fullFileName, symlinkName);

  00008	8b 45 08	 mov	 eax, DWORD PTR _symlinkName$[ebp]
  0000b	50		 push	 eax
  0000c	8d 4d dc	 lea	 ecx, DWORD PTR _fullFileName$[ebp]
  0000f	51		 push	 ecx
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 2852 : 	InitializeObjectAttributes (&objectAttributes, &fullFileName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

  00016	c7 45 e8 18 00
	00 00		 mov	 DWORD PTR _objectAttributes$[ebp], 24 ; 00000018H
  0001d	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _objectAttributes$[ebp+4], 0
  00024	c7 45 f4 40 02
	00 00		 mov	 DWORD PTR _objectAttributes$[ebp+12], 576 ; 00000240H
  0002b	8d 55 dc	 lea	 edx, DWORD PTR _fullFileName$[ebp]
  0002e	89 55 f0	 mov	 DWORD PTR _objectAttributes$[ebp+8], edx
  00031	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _objectAttributes$[ebp+16], 0
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _objectAttributes$[ebp+20], 0

; 2853 : 
; 2854 : 	ntStatus = ZwOpenSymbolicLinkObject (&handle, GENERIC_READ, &objectAttributes);

  0003f	8d 45 e8	 lea	 eax, DWORD PTR _objectAttributes$[ebp]
  00042	50		 push	 eax
  00043	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00048	8d 4d d8	 lea	 ecx, DWORD PTR _handle$[ebp]
  0004b	51		 push	 ecx
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwOpenSymbolicLinkObject@12
  00052	89 45 e4	 mov	 DWORD PTR _ntStatus$[ebp], eax

; 2855 : 
; 2856 : 	if (NT_SUCCESS (ntStatus))

  00055	83 7d e4 00	 cmp	 DWORD PTR _ntStatus$[ebp], 0
  00059	7c 44		 jl	 SHORT $LN1@SymbolicLi

; 2857 : 	{
; 2858 : 		UNICODE_STRING target;
; 2859 : 		target.Buffer = targetName;

  0005b	8b 55 0c	 mov	 edx, DWORD PTR _targetName$[ebp]
  0005e	89 55 d4	 mov	 DWORD PTR _target$31471[ebp+4], edx

; 2860 : 		target.Length = 0;

  00061	33 c0		 xor	 eax, eax
  00063	66 89 45 d0	 mov	 WORD PTR _target$31471[ebp], ax

; 2861 : 		target.MaximumLength = maxTargetNameLength;

  00067	66 8b 4d 10	 mov	 cx, WORD PTR _maxTargetNameLength$[ebp]
  0006b	66 89 4d d2	 mov	 WORD PTR _target$31471[ebp+2], cx

; 2862 : 		memset (targetName, 0, maxTargetNameLength);

  0006f	0f b7 55 10	 movzx	 edx, WORD PTR _maxTargetNameLength$[ebp]
  00073	52		 push	 edx
  00074	6a 00		 push	 0
  00076	8b 45 0c	 mov	 eax, DWORD PTR _targetName$[ebp]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 _memset
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2863 : 
; 2864 : 		ntStatus = ZwQuerySymbolicLinkObject (handle, &target, NULL);

  00082	6a 00		 push	 0
  00084	8d 4d d0	 lea	 ecx, DWORD PTR _target$31471[ebp]
  00087	51		 push	 ecx
  00088	8b 55 d8	 mov	 edx, DWORD PTR _handle$[ebp]
  0008b	52		 push	 edx
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwQuerySymbolicLinkObject@12
  00092	89 45 e4	 mov	 DWORD PTR _ntStatus$[ebp], eax

; 2865 : 
; 2866 : 		ZwClose (handle);

  00095	8b 45 d8	 mov	 eax, DWORD PTR _handle$[ebp]
  00098	50		 push	 eax
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4
$LN1@SymbolicLi:

; 2867 : 	}
; 2868 : 
; 2869 : 	return ntStatus;

  0009f	8b 45 e4	 mov	 eax, DWORD PTR _ntStatus$[ebp]

; 2870 : }

  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c2 0c 00	 ret	 12			; 0000000cH
_SymbolicLinkToTarget@12 ENDP
_TEXT	ENDS
PUBLIC	_RegionsOverlap@32
; Function compile flags: /Odtp
;	COMDAT _RegionsOverlap@32
_TEXT	SEGMENT
tv67 = -12						; size = 4
tv69 = -8						; size = 4
tv68 = -4						; size = 4
_start1$ = 8						; size = 8
_end1$ = 16						; size = 8
_start2$ = 24						; size = 8
_end2$ = 32						; size = 8
_RegionsOverlap@32 PROC					; COMDAT

; 2875 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2876 : 	return (start1 < start2) ? (end1 >= start2) : (start1 <= end2);

  00008	8b 45 0c	 mov	 eax, DWORD PTR _start1$[ebp+4]
  0000b	3b 45 1c	 cmp	 eax, DWORD PTR _start2$[ebp+4]
  0000e	77 34		 ja	 SHORT $LN7@RegionsOve
  00010	72 08		 jb	 SHORT $LN9@RegionsOve
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _start1$[ebp]
  00015	3b 4d 18	 cmp	 ecx, DWORD PTR _start2$[ebp]
  00018	73 2a		 jae	 SHORT $LN7@RegionsOve
$LN9@RegionsOve:
  0001a	8b 55 14	 mov	 edx, DWORD PTR _end1$[ebp+4]
  0001d	3b 55 1c	 cmp	 edx, DWORD PTR _start2$[ebp+4]
  00020	72 13		 jb	 SHORT $LN5@RegionsOve
  00022	77 08		 ja	 SHORT $LN10@RegionsOve
  00024	8b 45 10	 mov	 eax, DWORD PTR _end1$[ebp]
  00027	3b 45 18	 cmp	 eax, DWORD PTR _start2$[ebp]
  0002a	72 09		 jb	 SHORT $LN5@RegionsOve
$LN10@RegionsOve:
  0002c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00033	eb 07		 jmp	 SHORT $LN6@RegionsOve
$LN5@RegionsOve:
  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN6@RegionsOve:
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR tv68[ebp]
  0003f	89 4d f8	 mov	 DWORD PTR tv69[ebp], ecx
  00042	eb 28		 jmp	 SHORT $LN8@RegionsOve
$LN7@RegionsOve:
  00044	8b 55 0c	 mov	 edx, DWORD PTR _start1$[ebp+4]
  00047	3b 55 24	 cmp	 edx, DWORD PTR _end2$[ebp+4]
  0004a	77 13		 ja	 SHORT $LN3@RegionsOve
  0004c	72 08		 jb	 SHORT $LN11@RegionsOve
  0004e	8b 45 08	 mov	 eax, DWORD PTR _start1$[ebp]
  00051	3b 45 20	 cmp	 eax, DWORD PTR _end2$[ebp]
  00054	77 09		 ja	 SHORT $LN3@RegionsOve
$LN11@RegionsOve:
  00056	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  0005d	eb 07		 jmp	 SHORT $LN4@RegionsOve
$LN3@RegionsOve:
  0005f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$LN4@RegionsOve:
  00066	8b 4d f4	 mov	 ecx, DWORD PTR tv67[ebp]
  00069	89 4d f8	 mov	 DWORD PTR tv69[ebp], ecx
$LN8@RegionsOve:
  0006c	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 2877 : }

  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c2 20 00	 ret	 32			; 00000020H
_RegionsOverlap@32 ENDP
_TEXT	ENDS
PUBLIC	_GetIntersection@36
; Function compile flags: /Odtp
;	COMDAT _GetIntersection@36
_TEXT	SEGMENT
tv74 = -44						; size = 8
tv145 = -36						; size = 4
tv70 = -32						; size = 8
tv68 = -24						; size = 8
_end1$ = -16						; size = 8
_intersectEnd$ = -8					; size = 8
_start1$ = 8						; size = 8
_length1$ = 16						; size = 4
_start2$ = 20						; size = 8
_end2$ = 28						; size = 8
_intersectStart$ = 36					; size = 4
_intersectLength$ = 40					; size = 4
_GetIntersection@36 PROC				; COMDAT

; 2881 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 2882 : 	uint64 end1 = start1 + length1 - 1;

  00008	8b 45 10	 mov	 eax, DWORD PTR _length1$[ebp]
  0000b	33 c9		 xor	 ecx, ecx
  0000d	03 45 08	 add	 eax, DWORD PTR _start1$[ebp]
  00010	8b 55 0c	 mov	 edx, DWORD PTR _start1$[ebp+4]
  00013	13 d1		 adc	 edx, ecx
  00015	83 e8 01	 sub	 eax, 1
  00018	83 da 00	 sbb	 edx, 0
  0001b	89 45 f0	 mov	 DWORD PTR _end1$[ebp], eax
  0001e	89 55 f4	 mov	 DWORD PTR _end1$[ebp+4], edx

; 2883 : 	uint64 intersectEnd = (end1 <= end2) ? end1 : end2;

  00021	8b 45 f4	 mov	 eax, DWORD PTR _end1$[ebp+4]
  00024	3b 45 20	 cmp	 eax, DWORD PTR _end2$[ebp+4]
  00027	77 18		 ja	 SHORT $LN4@GetInterse
  00029	72 08		 jb	 SHORT $LN10@GetInterse
  0002b	8b 4d f0	 mov	 ecx, DWORD PTR _end1$[ebp]
  0002e	3b 4d 1c	 cmp	 ecx, DWORD PTR _end2$[ebp]
  00031	77 0e		 ja	 SHORT $LN4@GetInterse
$LN10@GetInterse:
  00033	8b 55 f0	 mov	 edx, DWORD PTR _end1$[ebp]
  00036	89 55 e8	 mov	 DWORD PTR tv68[ebp], edx
  00039	8b 45 f4	 mov	 eax, DWORD PTR _end1$[ebp+4]
  0003c	89 45 ec	 mov	 DWORD PTR tv68[ebp+4], eax
  0003f	eb 0c		 jmp	 SHORT $LN5@GetInterse
$LN4@GetInterse:
  00041	8b 4d 1c	 mov	 ecx, DWORD PTR _end2$[ebp]
  00044	89 4d e8	 mov	 DWORD PTR tv68[ebp], ecx
  00047	8b 55 20	 mov	 edx, DWORD PTR _end2$[ebp+4]
  0004a	89 55 ec	 mov	 DWORD PTR tv68[ebp+4], edx
$LN5@GetInterse:
  0004d	8b 45 e8	 mov	 eax, DWORD PTR tv68[ebp]
  00050	89 45 f8	 mov	 DWORD PTR _intersectEnd$[ebp], eax
  00053	8b 4d ec	 mov	 ecx, DWORD PTR tv68[ebp+4]
  00056	89 4d fc	 mov	 DWORD PTR _intersectEnd$[ebp+4], ecx

; 2884 : 	
; 2885 : 	*intersectStart = (start1 >= start2) ? start1 : start2;

  00059	8b 55 0c	 mov	 edx, DWORD PTR _start1$[ebp+4]
  0005c	3b 55 18	 cmp	 edx, DWORD PTR _start2$[ebp+4]
  0005f	72 18		 jb	 SHORT $LN6@GetInterse
  00061	77 08		 ja	 SHORT $LN11@GetInterse
  00063	8b 45 08	 mov	 eax, DWORD PTR _start1$[ebp]
  00066	3b 45 14	 cmp	 eax, DWORD PTR _start2$[ebp]
  00069	72 0e		 jb	 SHORT $LN6@GetInterse
$LN11@GetInterse:
  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _start1$[ebp]
  0006e	89 4d e0	 mov	 DWORD PTR tv70[ebp], ecx
  00071	8b 55 0c	 mov	 edx, DWORD PTR _start1$[ebp+4]
  00074	89 55 e4	 mov	 DWORD PTR tv70[ebp+4], edx
  00077	eb 0c		 jmp	 SHORT $LN7@GetInterse
$LN6@GetInterse:
  00079	8b 45 14	 mov	 eax, DWORD PTR _start2$[ebp]
  0007c	89 45 e0	 mov	 DWORD PTR tv70[ebp], eax
  0007f	8b 4d 18	 mov	 ecx, DWORD PTR _start2$[ebp+4]
  00082	89 4d e4	 mov	 DWORD PTR tv70[ebp+4], ecx
$LN7@GetInterse:
  00085	8b 55 24	 mov	 edx, DWORD PTR _intersectStart$[ebp]
  00088	8b 45 e0	 mov	 eax, DWORD PTR tv70[ebp]
  0008b	89 02		 mov	 DWORD PTR [edx], eax
  0008d	8b 4d e4	 mov	 ecx, DWORD PTR tv70[ebp+4]
  00090	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 2886 : 	*intersectLength = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);

  00093	8b 55 24	 mov	 edx, DWORD PTR _intersectStart$[ebp]
  00096	89 55 dc	 mov	 DWORD PTR tv145[ebp], edx
  00099	8b 45 dc	 mov	 eax, DWORD PTR tv145[ebp]
  0009c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009f	3b 4d fc	 cmp	 ecx, DWORD PTR _intersectEnd$[ebp+4]
  000a2	72 1c		 jb	 SHORT $LN8@GetInterse
  000a4	77 0a		 ja	 SHORT $LN12@GetInterse
  000a6	8b 55 dc	 mov	 edx, DWORD PTR tv145[ebp]
  000a9	8b 02		 mov	 eax, DWORD PTR [edx]
  000ab	3b 45 f8	 cmp	 eax, DWORD PTR _intersectEnd$[ebp]
  000ae	76 10		 jbe	 SHORT $LN8@GetInterse
$LN12@GetInterse:
  000b0	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
  000b7	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv74[ebp+4], 0
  000be	eb 1a		 jmp	 SHORT $LN9@GetInterse
$LN8@GetInterse:
  000c0	8b 4d f8	 mov	 ecx, DWORD PTR _intersectEnd$[ebp]
  000c3	83 c1 01	 add	 ecx, 1
  000c6	8b 55 fc	 mov	 edx, DWORD PTR _intersectEnd$[ebp+4]
  000c9	83 d2 00	 adc	 edx, 0
  000cc	8b 45 24	 mov	 eax, DWORD PTR _intersectStart$[ebp]
  000cf	2b 08		 sub	 ecx, DWORD PTR [eax]
  000d1	1b 50 04	 sbb	 edx, DWORD PTR [eax+4]
  000d4	89 4d d4	 mov	 DWORD PTR tv74[ebp], ecx
  000d7	89 55 d8	 mov	 DWORD PTR tv74[ebp+4], edx
$LN9@GetInterse:
  000da	8b 4d d4	 mov	 ecx, DWORD PTR tv74[ebp]
  000dd	8b 55 28	 mov	 edx, DWORD PTR _intersectLength$[ebp]
  000e0	89 0a		 mov	 DWORD PTR [edx], ecx

; 2887 : 	
; 2888 : 	if (*intersectLength == 0)

  000e2	8b 45 28	 mov	 eax, DWORD PTR _intersectLength$[ebp]
  000e5	83 38 00	 cmp	 DWORD PTR [eax], 0
  000e8	75 0e		 jne	 SHORT $LN2@GetInterse

; 2889 : 		*intersectStart = start1;

  000ea	8b 4d 24	 mov	 ecx, DWORD PTR _intersectStart$[ebp]
  000ed	8b 55 08	 mov	 edx, DWORD PTR _start1$[ebp]
  000f0	89 11		 mov	 DWORD PTR [ecx], edx
  000f2	8b 45 0c	 mov	 eax, DWORD PTR _start1$[ebp+4]
  000f5	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN2@GetInterse:

; 2890 : }

  000f8	8b e5		 mov	 esp, ebp
  000fa	5d		 pop	 ebp
  000fb	c2 24 00	 ret	 36			; 00000024H
_GetIntersection@36 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@KBGIGBCB@?$CBIoIsSystemThread?5?$CIPsGetCurrentT@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_IsAccessibleByUser@8
EXTRN	__imp__IoIsSystemThread@4:PROC
;	COMDAT ??_C@_0CJ@KBGIGBCB@?$CBIoIsSystemThread?5?$CIPsGetCurrentT@FNODOBFM@
text$s	SEGMENT
??_C@_0CJ@KBGIGBCB@?$CBIoIsSystemThread?5?$CIPsGetCurrentT@FNODOBFM@ DB '!'
	DB	'IoIsSystemThread (PsGetCurrentThread())', 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _IsAccessibleByUser@8
_TEXT	SEGMENT
tv73 = -44						; size = 4
_fileObjAttributes$ = -40				; size = 24
_status$ = -16						; size = 4
_ioStatusBlock$ = -12					; size = 8
_fileHandle$ = -4					; size = 4
_objectFileName$ = 8					; size = 4
_readOnly$ = 12						; size = 4
_IsAccessibleByUser@8 PROC				; COMDAT

; 2894 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 2895 : 	OBJECT_ATTRIBUTES fileObjAttributes;
; 2896 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2897 : 	HANDLE fileHandle;
; 2898 : 	NTSTATUS status;
; 2899 : 
; 2900 : 	ASSERT (!IoIsSystemThread (PsGetCurrentThread()));

  00008	e8 00 00 00 00	 call	 _PsGetCurrentThread@0
  0000d	50		 push	 eax
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoIsSystemThread@4
  00014	0f b6 c0	 movzx	 eax, al
  00017	85 c0		 test	 eax, eax
  00019	74 20		 je	 SHORT $LN4@IsAccessib
  0001b	6a 00		 push	 0
  0001d	68 54 0b 00 00	 push	 2900			; 00000b54H
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@KBGIGBCB@?$CBIoIsSystemThread?5?$CIPsGetCurrentT@FNODOBFM@
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  00032	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00039	eb 07		 jmp	 SHORT $LN5@IsAccessib
$LN4@IsAccessib:
  0003b	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR tv73[ebp], 1
$LN5@IsAccessib:

; 2901 : 
; 2902 : 	InitializeObjectAttributes (&fileObjAttributes, objectFileName, OBJ_CASE_INSENSITIVE | OBJ_FORCE_ACCESS_CHECK | OBJ_KERNEL_HANDLE, NULL, NULL);

  00042	c7 45 d8 18 00
	00 00		 mov	 DWORD PTR _fileObjAttributes$[ebp], 24 ; 00000018H
  00049	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _fileObjAttributes$[ebp+4], 0
  00050	c7 45 e4 40 06
	00 00		 mov	 DWORD PTR _fileObjAttributes$[ebp+12], 1600 ; 00000640H
  00057	8b 4d 08	 mov	 ecx, DWORD PTR _objectFileName$[ebp]
  0005a	89 4d e0	 mov	 DWORD PTR _fileObjAttributes$[ebp+8], ecx
  0005d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _fileObjAttributes$[ebp+16], 0
  00064	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _fileObjAttributes$[ebp+20], 0

; 2903 : 	
; 2904 : 	status = ZwCreateFile (&fileHandle,
; 2905 : 		readOnly ? GENERIC_READ : GENERIC_READ | GENERIC_WRITE,
; 2906 : 		&fileObjAttributes,
; 2907 : 		&ioStatusBlock,
; 2908 : 		NULL,
; 2909 : 		FILE_ATTRIBUTE_NORMAL,
; 2910 : 		FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
; 2911 : 		FILE_OPEN,
; 2912 : 		FILE_SYNCHRONOUS_IO_NONALERT,
; 2913 : 		NULL,
; 2914 : 		0);

  0006b	6a 00		 push	 0
  0006d	6a 00		 push	 0
  0006f	6a 20		 push	 32			; 00000020H
  00071	6a 01		 push	 1
  00073	6a 07		 push	 7
  00075	68 80 00 00 00	 push	 128			; 00000080H
  0007a	6a 00		 push	 0
  0007c	8d 55 f4	 lea	 edx, DWORD PTR _ioStatusBlock$[ebp]
  0007f	52		 push	 edx
  00080	8d 45 d8	 lea	 eax, DWORD PTR _fileObjAttributes$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 0c	 mov	 ecx, DWORD PTR _readOnly$[ebp]
  00087	f7 d9		 neg	 ecx
  00089	1b c9		 sbb	 ecx, ecx
  0008b	81 e1 00 00 00
	c0		 and	 ecx, -1073741824	; c0000000H
  00091	81 c1 00 00 00
	c0		 add	 ecx, -1073741824	; c0000000H
  00097	51		 push	 ecx
  00098	8d 55 fc	 lea	 edx, DWORD PTR _fileHandle$[ebp]
  0009b	52		 push	 edx
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwCreateFile@44
  000a2	89 45 f0	 mov	 DWORD PTR _status$[ebp], eax

; 2915 : 
; 2916 : 	if (NT_SUCCESS (status))

  000a5	83 7d f0 00	 cmp	 DWORD PTR _status$[ebp], 0
  000a9	7c 11		 jl	 SHORT $LN1@IsAccessib

; 2917 : 	{
; 2918 : 		ZwClose (fileHandle);

  000ab	8b 45 fc	 mov	 eax, DWORD PTR _fileHandle$[ebp]
  000ae	50		 push	 eax
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 2919 : 		return TRUE;

  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	eb 02		 jmp	 SHORT $LN2@IsAccessib
$LN1@IsAccessib:

; 2920 : 	}
; 2921 : 
; 2922 : 	return FALSE;

  000bc	33 c0		 xor	 eax, eax
$LN2@IsAccessib:

; 2923 : }

  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c2 08 00	 ret	 8
_IsAccessibleByUser@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _UserCanAccessDriveDevice@0
_TEXT	SEGMENT
_name$ = -8						; size = 8
_UserCanAccessDriveDevice@0 PROC			; COMDAT

; 2927 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 2928 : 	UNICODE_STRING name;
; 2929 : 	RtlInitUnicodeString (&name, L"\\Device\\MountPointManager");

  00008	68 00 00 00 00	 push	 OFFSET ??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
  0000d	8d 45 f8	 lea	 eax, DWORD PTR _name$[ebp]
  00010	50		 push	 eax
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 2930 : 
; 2931 : 	return IsAccessibleByUser (&name, FALSE);

  00017	6a 00		 push	 0
  00019	8d 4d f8	 lea	 ecx, DWORD PTR _name$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 _IsAccessibleByUser@8

; 2932 : }

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
_UserCanAccessDriveDevice@0 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp
;	COMDAT _IsDriveLetterAvailable@4
_TEXT	SEGMENT
_handle$ = -300						; size = 4
_objectName$ = -296					; size = 8
_link$ = -288						; size = 256
__$ArrayPad$ = -32					; size = 4
_ntStatus$ = -28					; size = 4
_objectAttributes$ = -24				; size = 24
_nDosDriveNo$ = 8					; size = 4
_IsDriveLetterAvailable@4 PROC				; COMDAT

; 2942 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 e0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2943 : 	OBJECT_ATTRIBUTES objectAttributes;
; 2944 : 	UNICODE_STRING objectName;
; 2945 : 	WCHAR link[128];
; 2946 : 	HANDLE handle;
; 2947 : 	NTSTATUS ntStatus;
; 2948 : 
; 2949 : 	TCGetDosNameFromNumber (link, nDosDriveNo);

  00015	8b 45 08	 mov	 eax, DWORD PTR _nDosDriveNo$[ebp]
  00018	50		 push	 eax
  00019	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _link$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 _TCGetDosNameFromNumber@8

; 2950 : 	RtlInitUnicodeString (&objectName, link);

  00025	8d 95 e0 fe ff
	ff		 lea	 edx, DWORD PTR _link$[ebp]
  0002b	52		 push	 edx
  0002c	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _objectName$[ebp]
  00032	50		 push	 eax
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 2951 : 	InitializeObjectAttributes (&objectAttributes, &objectName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

  00039	c7 45 e8 18 00
	00 00		 mov	 DWORD PTR _objectAttributes$[ebp], 24 ; 00000018H
  00040	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _objectAttributes$[ebp+4], 0
  00047	c7 45 f4 40 02
	00 00		 mov	 DWORD PTR _objectAttributes$[ebp+12], 576 ; 00000240H
  0004e	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _objectName$[ebp]
  00054	89 4d f0	 mov	 DWORD PTR _objectAttributes$[ebp+8], ecx
  00057	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _objectAttributes$[ebp+16], 0
  0005e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _objectAttributes$[ebp+20], 0

; 2952 : 
; 2953 : 	ntStatus=ZwOpenSymbolicLinkObject (&handle, GENERIC_READ, &objectAttributes);

  00065	8d 55 e8	 lea	 edx, DWORD PTR _objectAttributes$[ebp]
  00068	52		 push	 edx
  00069	68 00 00 00 80	 push	 -2147483648		; 80000000H
  0006e	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _handle$[ebp]
  00074	50		 push	 eax
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwOpenSymbolicLinkObject@12
  0007b	89 45 e4	 mov	 DWORD PTR _ntStatus$[ebp], eax

; 2954 : 	if (NT_SUCCESS (ntStatus))

  0007e	83 7d e4 00	 cmp	 DWORD PTR _ntStatus$[ebp], 0
  00082	7c 13		 jl	 SHORT $LN4@IsDriveLet

; 2955 : 	{
; 2956 : 		ZwClose (handle);

  00084	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _handle$[ebp]
  0008a	51		 push	 ecx
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 2957 : 		return FALSE;

  00091	33 c0		 xor	 eax, eax
  00093	eb 16		 jmp	 SHORT $LN5@IsDriveLet
  00095	eb 14		 jmp	 SHORT $LN5@IsDriveLet
$LN4@IsDriveLet:

; 2958 : 	}
; 2959 : 	else if (ntStatus == STATUS_OBJECT_NAME_NOT_FOUND)

  00097	81 7d e4 34 00
	00 c0		 cmp	 DWORD PTR _ntStatus$[ebp], -1073741772 ; c0000034H
  0009e	75 09		 jne	 SHORT $LN2@IsDriveLet

; 2960 : 	{
; 2961 : 		return TRUE;

  000a0	b8 01 00 00 00	 mov	 eax, 1
  000a5	eb 04		 jmp	 SHORT $LN5@IsDriveLet

; 2962 : 	}
; 2963 : 	else

  000a7	eb 02		 jmp	 SHORT $LN5@IsDriveLet
$LN2@IsDriveLet:

; 2964 : 	{
; 2965 : 		return FALSE;

  000a9	33 c0		 xor	 eax, eax
$LN5@IsDriveLet:

; 2966 : 	}
; 2967 : }

  000ab	8b 4d e0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ae	33 cd		 xor	 ecx, ebp
  000b0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c2 04 00	 ret	 4
_IsDriveLetterAvailable@4 ENDP
_TEXT	ENDS
EXTRN	__imp_@IofCompleteRequest@8:PROC
; Function compile flags: /Odtp
;	COMDAT _TCCompleteIrp@12
_TEXT	SEGMENT
_irp$ = 8						; size = 4
_status$ = 12						; size = 4
_information$ = 16					; size = 4
_TCCompleteIrp@12 PROC					; COMDAT

; 2971 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 2972 : 	irp->IoStatus.Status = status;

  00005	8b 45 08	 mov	 eax, DWORD PTR _irp$[ebp]
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR _status$[ebp]
  0000b	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 2973 : 	irp->IoStatus.Information = information;

  0000e	8b 55 08	 mov	 edx, DWORD PTR _irp$[ebp]
  00011	8b 45 10	 mov	 eax, DWORD PTR _information$[ebp]
  00014	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 2974 : 	IoCompleteRequest (irp, IO_NO_INCREMENT);

  00017	32 d2		 xor	 dl, dl
  00019	8b 4d 08	 mov	 ecx, DWORD PTR _irp$[ebp]
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 2975 : 	return status;

  00022	8b 45 0c	 mov	 eax, DWORD PTR _status$[ebp]

; 2976 : }

  00025	5d		 pop	 ebp
  00026	c2 0c 00	 ret	 12			; 0000000cH
_TCCompleteIrp@12 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _TCCompleteDiskIrp@12
_TEXT	SEGMENT
_irp$ = 8						; size = 4
_status$ = 12						; size = 4
_information$ = 16					; size = 4
_TCCompleteDiskIrp@12 PROC				; COMDAT

; 2980 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 2981 : 	irp->IoStatus.Status = status;

  00005	8b 45 08	 mov	 eax, DWORD PTR _irp$[ebp]
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR _status$[ebp]
  0000b	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 2982 : 	irp->IoStatus.Information = information;

  0000e	8b 55 08	 mov	 edx, DWORD PTR _irp$[ebp]
  00011	8b 45 10	 mov	 eax, DWORD PTR _information$[ebp]
  00014	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 2983 : 	IoCompleteRequest (irp, NT_SUCCESS (status) ? IO_DISK_INCREMENT : IO_NO_INCREMENT);

  00017	33 d2		 xor	 edx, edx
  00019	83 7d 0c 00	 cmp	 DWORD PTR _status$[ebp], 0
  0001d	0f 9d c2	 setge	 dl
  00020	8b 4d 08	 mov	 ecx, DWORD PTR _irp$[ebp]
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 2984 : 	return status;

  00029	8b 45 0c	 mov	 eax, DWORD PTR _status$[ebp]

; 2985 : }

  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
_TCCompleteDiskIrp@12 ENDP
_TEXT	ENDS
PUBLIC	_GetCpuCount@0
EXTRN	__imp__KeQueryActiveProcessors@0:PROC
; Function compile flags: /Odtp
;	COMDAT _GetCpuCount@0
_TEXT	SEGMENT
_cpuCount$ = -12					; size = 4
_activeCpuMap$ = -8					; size = 4
_mapSize$ = -4						; size = 4
_GetCpuCount@0 PROC					; COMDAT

; 2989 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2990 : 	KAFFINITY activeCpuMap = KeQueryActiveProcessors();

  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeQueryActiveProcessors@0
  0000e	89 45 f8	 mov	 DWORD PTR _activeCpuMap$[ebp], eax

; 2991 : 	size_t mapSize = sizeof (activeCpuMap) * 8;

  00011	c7 45 fc 20 00
	00 00		 mov	 DWORD PTR _mapSize$[ebp], 32 ; 00000020H

; 2992 : 	size_t cpuCount = 0;

  00018	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _cpuCount$[ebp], 0
$LN4@GetCpuCoun@2:

; 2993 : 
; 2994 : 	while (mapSize--)

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _mapSize$[ebp]
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _mapSize$[ebp]
  00025	83 e9 01	 sub	 ecx, 1
  00028	89 4d fc	 mov	 DWORD PTR _mapSize$[ebp], ecx
  0002b	85 c0		 test	 eax, eax
  0002d	74 1b		 je	 SHORT $LN3@GetCpuCoun@2

; 2995 : 	{
; 2996 : 		if (activeCpuMap & 1)

  0002f	8b 55 f8	 mov	 edx, DWORD PTR _activeCpuMap$[ebp]
  00032	83 e2 01	 and	 edx, 1
  00035	74 09		 je	 SHORT $LN2@GetCpuCoun@2

; 2997 : 			++cpuCount;

  00037	8b 45 f4	 mov	 eax, DWORD PTR _cpuCount$[ebp]
  0003a	83 c0 01	 add	 eax, 1
  0003d	89 45 f4	 mov	 DWORD PTR _cpuCount$[ebp], eax
$LN2@GetCpuCoun@2:

; 2998 : 
; 2999 : 		activeCpuMap >>= 1;

  00040	8b 4d f8	 mov	 ecx, DWORD PTR _activeCpuMap$[ebp]
  00043	d1 e9		 shr	 ecx, 1
  00045	89 4d f8	 mov	 DWORD PTR _activeCpuMap$[ebp], ecx

; 3000 : 	}

  00048	eb d5		 jmp	 SHORT $LN4@GetCpuCoun@2
$LN3@GetCpuCoun@2:

; 3001 : 
; 3002 : 	if (cpuCount == 0)

  0004a	83 7d f4 00	 cmp	 DWORD PTR _cpuCount$[ebp], 0
  0004e	75 07		 jne	 SHORT $LN1@GetCpuCoun@2

; 3003 : 		return 1;

  00050	b8 01 00 00 00	 mov	 eax, 1
  00055	eb 03		 jmp	 SHORT $LN5@GetCpuCoun@2
$LN1@GetCpuCoun@2:

; 3004 : 
; 3005 : 	return cpuCount;

  00057	8b 45 f4	 mov	 eax, DWORD PTR _cpuCount$[ebp]
$LN5@GetCpuCoun@2:

; 3006 : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_GetCpuCount@0 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@BGEEJMHD@?$CImaxSizeInBytes?5?$CG?51?$CJ?5?$DN?$DN?50?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0BK@BGEEJMHD@?$CImaxSizeInBytes?5?$CG?51?$CJ?5?$DN?$DN?50?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BK@BGEEJMHD@?$CImaxSizeInBytes?5?$CG?51?$CJ?5?$DN?$DN?50?$AA@FNODOBFM@ DB '('
	DB	'maxSizeInBytes & 1) == 0', 00H		;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _EnsureNullTerminatedString@8
_TEXT	SEGMENT
tv70 = -4						; size = 4
_str$ = 8						; size = 4
_maxSizeInBytes$ = 12					; size = 4
_EnsureNullTerminatedString@8 PROC			; COMDAT

; 3010 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 3011 : 	ASSERT ((maxSizeInBytes & 1) == 0);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _maxSizeInBytes$[ebp]
  00009	83 e0 01	 and	 eax, 1
  0000c	74 20		 je	 SHORT $LN3@EnsureNull
  0000e	6a 00		 push	 0
  00010	68 c3 0b 00 00	 push	 3011			; 00000bc3H
  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@BGEEJMHD@?$CImaxSizeInBytes?5?$CG?51?$CJ?5?$DN?$DN?50?$AA@FNODOBFM@
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  0002c	eb 07		 jmp	 SHORT $LN4@EnsureNull
$LN3@EnsureNull:
  0002e	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv70[ebp], 1
$LN4@EnsureNull:

; 3012 : 	str[maxSizeInBytes / sizeof (wchar_t) - 1] = 0;

  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _maxSizeInBytes$[ebp]
  00038	d1 e9		 shr	 ecx, 1
  0003a	33 d2		 xor	 edx, edx
  0003c	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  0003f	66 89 54 48 fe	 mov	 WORD PTR [eax+ecx*2-2], dx

; 3013 : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 08 00	 ret	 8
_EnsureNullTerminatedString@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CI@OFAMGLPO@retryDelay?5?$DO?50?5?$CG?$CG?5retryDelay?5?$DM?$DN?5@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_AllocateMemoryWithTimeout@12
EXTRN	__imp__KeDelayExecutionThread@12:PROC
;	COMDAT ??_C@_0CI@OFAMGLPO@retryDelay?5?$DO?50?5?$CG?$CG?5retryDelay?5?$DM?$DN?5@FNODOBFM@
text$s	SEGMENT
??_C@_0CI@OFAMGLPO@retryDelay?5?$DO?50?5?$CG?$CG?5retryDelay?5?$DM?$DN?5@FNODOBFM@ DB 'r'
	DB	'etryDelay > 0 && retryDelay <= timeout', 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _AllocateMemoryWithTimeout@12
_TEXT	SEGMENT
tv80 = -20						; size = 4
tv73 = -16						; size = 4
_memory$31584 = -12					; size = 4
_waitInterval$ = -8					; size = 8
_size$ = 8						; size = 4
_retryDelay$ = 12					; size = 4
_timeout$ = 16						; size = 4
_AllocateMemoryWithTimeout@12 PROC			; COMDAT

; 3017 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 14	 sub	 esp, 20			; 00000014H

; 3018 : 	LARGE_INTEGER waitInterval;
; 3019 : 	waitInterval.QuadPart = retryDelay * -10000;

  00008	8b 45 0c	 mov	 eax, DWORD PTR _retryDelay$[ebp]
  0000b	69 c0 f0 d8 ff
	ff		 imul	 eax, -10000		; ffffd8f0H
  00011	99		 cdq
  00012	89 45 f8	 mov	 DWORD PTR _waitInterval$[ebp], eax
  00015	89 55 fc	 mov	 DWORD PTR _waitInterval$[ebp+4], edx

; 3020 : 
; 3021 : 	ASSERT (KeGetCurrentIrql() <= APC_LEVEL);

  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeGetCurrentIrql@0
  0001e	0f b6 c0	 movzx	 eax, al
  00021	83 f8 01	 cmp	 eax, 1
  00024	7e 20		 jle	 SHORT $LN7@AllocateMe
  00026	6a 00		 push	 0
  00028	68 cd 0b 00 00	 push	 3021			; 00000bcdH
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@MOHACMBH@KeGetCurrentIrql?$CI?$CJ?5?$DM?$DN?5APC_LEVEL?$AA@FNODOBFM@
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  0003d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00044	eb 07		 jmp	 SHORT $LN8@AllocateMe
$LN7@AllocateMe:
  00046	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv73[ebp], 1
$LN8@AllocateMe:

; 3022 : 	ASSERT (retryDelay > 0 && retryDelay <= timeout);

  0004d	83 7d 0c 00	 cmp	 DWORD PTR _retryDelay$[ebp], 0
  00051	7e 11		 jle	 SHORT $LN9@AllocateMe
  00053	8b 4d 0c	 mov	 ecx, DWORD PTR _retryDelay$[ebp]
  00056	3b 4d 10	 cmp	 ecx, DWORD PTR _timeout$[ebp]
  00059	7f 09		 jg	 SHORT $LN9@AllocateMe
  0005b	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
  00062	eb 1e		 jmp	 SHORT $LN4@AllocateMe
$LN9@AllocateMe:
  00064	6a 00		 push	 0
  00066	68 ce 0b 00 00	 push	 3022			; 00000bceH
  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@OFAMGLPO@retryDelay?5?$DO?50?5?$CG?$CG?5retryDelay?5?$DM?$DN?5@FNODOBFM@
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  0007b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
$LN4@AllocateMe:

; 3023 : 
; 3024 : 	while (TRUE)

  00082	ba 01 00 00 00	 mov	 edx, 1
  00087	85 d2		 test	 edx, edx
  00089	74 40		 je	 SHORT $LN3@AllocateMe

; 3025 : 	{
; 3026 : 		void *memory = TCalloc (size);

  0008b	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00090	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  00093	50		 push	 eax
  00094	6a 00		 push	 0
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0009c	89 45 f4	 mov	 DWORD PTR _memory$31584[ebp], eax

; 3027 : 		if (memory)

  0009f	83 7d f4 00	 cmp	 DWORD PTR _memory$31584[ebp], 0
  000a3	74 05		 je	 SHORT $LN2@AllocateMe

; 3028 : 			return memory;

  000a5	8b 45 f4	 mov	 eax, DWORD PTR _memory$31584[ebp]
  000a8	eb 23		 jmp	 SHORT $LN5@AllocateMe
$LN2@AllocateMe:

; 3029 : 
; 3030 : 		timeout -= retryDelay;

  000aa	8b 4d 10	 mov	 ecx, DWORD PTR _timeout$[ebp]
  000ad	2b 4d 0c	 sub	 ecx, DWORD PTR _retryDelay$[ebp]
  000b0	89 4d 10	 mov	 DWORD PTR _timeout$[ebp], ecx

; 3031 : 		if (timeout <= 0)

  000b3	83 7d 10 00	 cmp	 DWORD PTR _timeout$[ebp], 0
  000b7	7f 02		 jg	 SHORT $LN1@AllocateMe

; 3032 : 			break;

  000b9	eb 10		 jmp	 SHORT $LN3@AllocateMe
$LN1@AllocateMe:

; 3033 : 
; 3034 : 		KeDelayExecutionThread (KernelMode, FALSE, &waitInterval);

  000bb	8d 55 f8	 lea	 edx, DWORD PTR _waitInterval$[ebp]
  000be	52		 push	 edx
  000bf	6a 00		 push	 0
  000c1	6a 00		 push	 0
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeDelayExecutionThread@12

; 3035 : 	}

  000c9	eb b7		 jmp	 SHORT $LN4@AllocateMe
$LN3@AllocateMe:

; 3036 : 
; 3037 : 	return NULL;

  000cb	33 c0		 xor	 eax, eax
$LN5@AllocateMe:

; 3038 : }

  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c2 0c 00	 ret	 12			; 0000000cH
_AllocateMemoryWithTimeout@12 ENDP
_TEXT	ENDS
EXTRN	__imp__ZwQueryValueKey@24:PROC
EXTRN	__imp__ZwOpenKey@12:PROC
; Function compile flags: /Odtp
;	COMDAT _TCReadRegistryKey@12
_TEXT	SEGMENT
_resultSize$ = -48					; size = 4
_status$ = -44						; size = 4
_regKeyHandle$ = -40					; size = 4
_valName$ = -36						; size = 8
_size$ = -28						; size = 4
_regObjAttribs$ = -24					; size = 24
_keyPath$ = 8						; size = 4
_keyValueName$ = 12					; size = 4
_keyData$ = 16						; size = 4
_TCReadRegistryKey@12 PROC				; COMDAT

; 3042 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 30	 sub	 esp, 48			; 00000030H

; 3043 : 	OBJECT_ATTRIBUTES regObjAttribs;
; 3044 : 	HANDLE regKeyHandle;
; 3045 : 	NTSTATUS status;
; 3046 : 	UNICODE_STRING valName;
; 3047 : 	ULONG size = 0;

  00008	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _size$[ebp], 0

; 3048 : 	ULONG resultSize;
; 3049 : 
; 3050 : 	InitializeObjectAttributes (&regObjAttribs, keyPath, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

  0000f	c7 45 e8 18 00
	00 00		 mov	 DWORD PTR _regObjAttribs$[ebp], 24 ; 00000018H
  00016	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _regObjAttribs$[ebp+4], 0
  0001d	c7 45 f4 40 02
	00 00		 mov	 DWORD PTR _regObjAttribs$[ebp+12], 576 ; 00000240H
  00024	8b 45 08	 mov	 eax, DWORD PTR _keyPath$[ebp]
  00027	89 45 f0	 mov	 DWORD PTR _regObjAttribs$[ebp+8], eax
  0002a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _regObjAttribs$[ebp+16], 0
  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _regObjAttribs$[ebp+20], 0

; 3051 : 	status = ZwOpenKey (&regKeyHandle, KEY_READ, &regObjAttribs);

  00038	8d 4d e8	 lea	 ecx, DWORD PTR _regObjAttribs$[ebp]
  0003b	51		 push	 ecx
  0003c	68 19 00 02 00	 push	 131097			; 00020019H
  00041	8d 55 d8	 lea	 edx, DWORD PTR _regKeyHandle$[ebp]
  00044	52		 push	 edx
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwOpenKey@12
  0004b	89 45 d4	 mov	 DWORD PTR _status$[ebp], eax

; 3052 : 	if (!NT_SUCCESS (status))

  0004e	83 7d d4 00	 cmp	 DWORD PTR _status$[ebp], 0
  00052	7d 08		 jge	 SHORT $LN4@TCReadRegi

; 3053 : 		return status;

  00054	8b 45 d4	 mov	 eax, DWORD PTR _status$[ebp]
  00057	e9 c4 00 00 00	 jmp	 $LN5@TCReadRegi
$LN4@TCReadRegi:

; 3054 : 
; 3055 : 	RtlInitUnicodeString (&valName, keyValueName);

  0005c	8b 45 0c	 mov	 eax, DWORD PTR _keyValueName$[ebp]
  0005f	50		 push	 eax
  00060	8d 4d dc	 lea	 ecx, DWORD PTR _valName$[ebp]
  00063	51		 push	 ecx
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 3056 : 	status = ZwQueryValueKey (regKeyHandle, &valName, KeyValuePartialInformation, NULL, 0, &size);

  0006a	8d 55 e4	 lea	 edx, DWORD PTR _size$[ebp]
  0006d	52		 push	 edx
  0006e	6a 00		 push	 0
  00070	6a 00		 push	 0
  00072	6a 02		 push	 2
  00074	8d 45 dc	 lea	 eax, DWORD PTR _valName$[ebp]
  00077	50		 push	 eax
  00078	8b 4d d8	 mov	 ecx, DWORD PTR _regKeyHandle$[ebp]
  0007b	51		 push	 ecx
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwQueryValueKey@24
  00082	89 45 d4	 mov	 DWORD PTR _status$[ebp], eax

; 3057 : 		
; 3058 : 	if (!NT_SUCCESS (status) && status != STATUS_BUFFER_OVERFLOW && status != STATUS_BUFFER_TOO_SMALL)

  00085	83 7d d4 00	 cmp	 DWORD PTR _status$[ebp], 0
  00089	7d 21		 jge	 SHORT $LN3@TCReadRegi
  0008b	81 7d d4 05 00
	00 80		 cmp	 DWORD PTR _status$[ebp], -2147483643 ; 80000005H
  00092	74 18		 je	 SHORT $LN3@TCReadRegi
  00094	81 7d d4 23 00
	00 c0		 cmp	 DWORD PTR _status$[ebp], -1073741789 ; c0000023H
  0009b	74 0f		 je	 SHORT $LN3@TCReadRegi

; 3059 : 	{
; 3060 : 		ZwClose (regKeyHandle);

  0009d	8b 55 d8	 mov	 edx, DWORD PTR _regKeyHandle$[ebp]
  000a0	52		 push	 edx
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 3061 : 		return status;

  000a7	8b 45 d4	 mov	 eax, DWORD PTR _status$[ebp]
  000aa	eb 74		 jmp	 SHORT $LN5@TCReadRegi
$LN3@TCReadRegi:

; 3062 : 	}
; 3063 : 
; 3064 : 	if (size == 0)

  000ac	83 7d e4 00	 cmp	 DWORD PTR _size$[ebp], 0
  000b0	75 11		 jne	 SHORT $LN2@TCReadRegi

; 3065 : 	{
; 3066 : 		ZwClose (regKeyHandle);

  000b2	8b 45 d8	 mov	 eax, DWORD PTR _regKeyHandle$[ebp]
  000b5	50		 push	 eax
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 3067 : 		return STATUS_NO_DATA_DETECTED;

  000bc	b8 22 00 00 80	 mov	 eax, -2147483614	; 80000022H
  000c1	eb 5d		 jmp	 SHORT $LN5@TCReadRegi
$LN2@TCReadRegi:

; 3068 : 	}
; 3069 : 
; 3070 : 	*keyData = (PKEY_VALUE_PARTIAL_INFORMATION) TCalloc (size);

  000c3	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  000c8	8b 4d e4	 mov	 ecx, DWORD PTR _size$[ebp]
  000cb	51		 push	 ecx
  000cc	6a 00		 push	 0
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  000d4	8b 55 10	 mov	 edx, DWORD PTR _keyData$[ebp]
  000d7	89 02		 mov	 DWORD PTR [edx], eax

; 3071 : 	if (!*keyData)

  000d9	8b 45 10	 mov	 eax, DWORD PTR _keyData$[ebp]
  000dc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000df	75 11		 jne	 SHORT $LN1@TCReadRegi

; 3072 : 	{
; 3073 : 		ZwClose (regKeyHandle);

  000e1	8b 4d d8	 mov	 ecx, DWORD PTR _regKeyHandle$[ebp]
  000e4	51		 push	 ecx
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 3074 : 		return STATUS_INSUFFICIENT_RESOURCES;

  000eb	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  000f0	eb 2e		 jmp	 SHORT $LN5@TCReadRegi
$LN1@TCReadRegi:

; 3075 : 	}
; 3076 : 
; 3077 : 	status = ZwQueryValueKey (regKeyHandle, &valName, KeyValuePartialInformation, *keyData, size, &resultSize);

  000f2	8d 55 d0	 lea	 edx, DWORD PTR _resultSize$[ebp]
  000f5	52		 push	 edx
  000f6	8b 45 e4	 mov	 eax, DWORD PTR _size$[ebp]
  000f9	50		 push	 eax
  000fa	8b 4d 10	 mov	 ecx, DWORD PTR _keyData$[ebp]
  000fd	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ff	52		 push	 edx
  00100	6a 02		 push	 2
  00102	8d 45 dc	 lea	 eax, DWORD PTR _valName$[ebp]
  00105	50		 push	 eax
  00106	8b 4d d8	 mov	 ecx, DWORD PTR _regKeyHandle$[ebp]
  00109	51		 push	 ecx
  0010a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwQueryValueKey@24
  00110	89 45 d4	 mov	 DWORD PTR _status$[ebp], eax

; 3078 : 
; 3079 : 	ZwClose (regKeyHandle);

  00113	8b 55 d8	 mov	 edx, DWORD PTR _regKeyHandle$[ebp]
  00116	52		 push	 edx
  00117	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 3080 : 	return status;

  0011d	8b 45 d4	 mov	 eax, DWORD PTR _status$[ebp]
$LN5@TCReadRegi:

; 3081 : }

  00120	8b e5		 mov	 esp, ebp
  00122	5d		 pop	 ebp
  00123	c2 0c 00	 ret	 12			; 0000000cH
_TCReadRegistryKey@12 ENDP
_TEXT	ENDS
PUBLIC	_TCWriteRegistryKey@20
EXTRN	__imp__ZwSetValueKey@24:PROC
; Function compile flags: /Odtp
;	COMDAT _TCWriteRegistryKey@20
_TEXT	SEGMENT
_status$ = -40						; size = 4
_regKeyHandle$ = -36					; size = 4
_valName$ = -32						; size = 8
_regObjAttribs$ = -24					; size = 24
_keyPath$ = 8						; size = 4
_keyValueName$ = 12					; size = 4
_keyValueType$ = 16					; size = 4
_valueData$ = 20					; size = 4
_valueSize$ = 24					; size = 4
_TCWriteRegistryKey@20 PROC				; COMDAT

; 3085 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 28	 sub	 esp, 40			; 00000028H

; 3086 : 	OBJECT_ATTRIBUTES regObjAttribs;
; 3087 : 	HANDLE regKeyHandle;
; 3088 : 	NTSTATUS status;
; 3089 : 	UNICODE_STRING valName;
; 3090 : 
; 3091 : 	InitializeObjectAttributes (&regObjAttribs, keyPath, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

  00008	c7 45 e8 18 00
	00 00		 mov	 DWORD PTR _regObjAttribs$[ebp], 24 ; 00000018H
  0000f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _regObjAttribs$[ebp+4], 0
  00016	c7 45 f4 40 02
	00 00		 mov	 DWORD PTR _regObjAttribs$[ebp+12], 576 ; 00000240H
  0001d	8b 45 08	 mov	 eax, DWORD PTR _keyPath$[ebp]
  00020	89 45 f0	 mov	 DWORD PTR _regObjAttribs$[ebp+8], eax
  00023	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _regObjAttribs$[ebp+16], 0
  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _regObjAttribs$[ebp+20], 0

; 3092 : 	status = ZwOpenKey (&regKeyHandle, KEY_READ | KEY_WRITE, &regObjAttribs);

  00031	8d 4d e8	 lea	 ecx, DWORD PTR _regObjAttribs$[ebp]
  00034	51		 push	 ecx
  00035	68 1f 00 02 00	 push	 131103			; 0002001fH
  0003a	8d 55 dc	 lea	 edx, DWORD PTR _regKeyHandle$[ebp]
  0003d	52		 push	 edx
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwOpenKey@12
  00044	89 45 d8	 mov	 DWORD PTR _status$[ebp], eax

; 3093 : 	if (!NT_SUCCESS (status))

  00047	83 7d d8 00	 cmp	 DWORD PTR _status$[ebp], 0
  0004b	7d 05		 jge	 SHORT $LN1@TCWriteReg

; 3094 : 		return status;

  0004d	8b 45 d8	 mov	 eax, DWORD PTR _status$[ebp]
  00050	eb 3a		 jmp	 SHORT $LN2@TCWriteReg
$LN1@TCWriteReg:

; 3095 : 
; 3096 : 	RtlInitUnicodeString (&valName, keyValueName);

  00052	8b 45 0c	 mov	 eax, DWORD PTR _keyValueName$[ebp]
  00055	50		 push	 eax
  00056	8d 4d e0	 lea	 ecx, DWORD PTR _valName$[ebp]
  00059	51		 push	 ecx
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 3097 : 
; 3098 : 	status = ZwSetValueKey (regKeyHandle, &valName, 0, keyValueType, valueData, valueSize);

  00060	8b 55 18	 mov	 edx, DWORD PTR _valueSize$[ebp]
  00063	52		 push	 edx
  00064	8b 45 14	 mov	 eax, DWORD PTR _valueData$[ebp]
  00067	50		 push	 eax
  00068	8b 4d 10	 mov	 ecx, DWORD PTR _keyValueType$[ebp]
  0006b	51		 push	 ecx
  0006c	6a 00		 push	 0
  0006e	8d 55 e0	 lea	 edx, DWORD PTR _valName$[ebp]
  00071	52		 push	 edx
  00072	8b 45 dc	 mov	 eax, DWORD PTR _regKeyHandle$[ebp]
  00075	50		 push	 eax
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwSetValueKey@24
  0007c	89 45 d8	 mov	 DWORD PTR _status$[ebp], eax

; 3099 : 
; 3100 : 	ZwClose (regKeyHandle);

  0007f	8b 4d dc	 mov	 ecx, DWORD PTR _regKeyHandle$[ebp]
  00082	51		 push	 ecx
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 3101 : 	return status;

  00089	8b 45 d8	 mov	 eax, DWORD PTR _status$[ebp]
$LN2@TCWriteReg:

; 3102 : }

  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 14 00	 ret	 20			; 00000014H
_TCWriteRegistryKey@20 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@GOBMMLHF@Volume?5class?5filter?5active?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BE@OBOIPPHP@?$AAt?$AAr?$AAu?$AAe?$AAc?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BK@FNJCPENK@?$AAU?$AAp?$AAp?$AAe?$AAr?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAs?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1MA@BNNNAGDA@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0BM@GOBMMLHF@Volume?5class?5filter?5active?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BM@GOBMMLHF@Volume?5class?5filter?5active?6?$AA@FNODOBFM@ DB 'Volu'
	DB	'me class filter active', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BE@OBOIPPHP@?$AAt?$AAr?$AAu?$AAe?$AAc?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BE@OBOIPPHP@?$AAt?$AAr?$AAu?$AAe?$AAc?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ DB 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 'c', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BK@FNJCPENK@?$AAU?$AAp?$AAp?$AAe?$AAr?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAs?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BK@FNJCPENK@?$AAU?$AAp?$AAp?$AAe?$AAr?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAs?$AA?$AA@FNODOBFM@ DB 'U'
	DB	00H, 'p', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'F', 00H, 'i', 00H
	DB	'l', 00H, 't', 00H, 'e', 00H, 'r', 00H, 's', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1MA@BNNNAGDA@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
text$s	SEGMENT
??_C@_1MA@BNNNAGDA@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@ DB '\'
	DB	00H, 'R', 00H, 'E', 00H, 'G', 00H, 'I', 00H, 'S', 00H, 'T', 00H
	DB	'R', 00H, 'Y', 00H, '\', 00H, 'M', 00H, 'A', 00H, 'C', 00H, 'H'
	DB	00H, 'I', 00H, 'N', 00H, 'E', 00H, '\', 00H, 'S', 00H, 'Y', 00H
	DB	'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '\', 00H, 'C', 00H, 'u'
	DB	00H, 'r', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'C', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, 'r', 00H, 'o', 00H, 'l', 00H, 'S'
	DB	00H, 'e', 00H, 't', 00H, '\', 00H, 'C', 00H, 'o', 00H, 'n', 00H
	DB	't', 00H, 'r', 00H, 'o', 00H, 'l', 00H, '\', 00H, 'C', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, '\', 00H, '{', 00H, '7', 00H
	DB	'1', 00H, 'A', 00H, '2', 00H, '7', 00H, 'C', 00H, 'D', 00H, 'D'
	DB	00H, '-', 00H, '8', 00H, '1', 00H, '2', 00H, 'A', 00H, '-', 00H
	DB	'1', 00H, '1', 00H, 'D', 00H, '0', 00H, '-', 00H, 'B', 00H, 'E'
	DB	00H, 'C', 00H, '7', 00H, '-', 00H, '0', 00H, '8', 00H, '0', 00H
	DB	'0', 00H, '2', 00H, 'B', 00H, 'E', 00H, '2', 00H, '0', 00H, '9'
	DB	00H, '2', 00H, 'F', 00H, '}', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _IsVolumeClassFilterRegistered@0
_TEXT	SEGMENT
_i$31651 = -24						; size = 4
_status$ = -20						; size = 4
_data$ = -16						; size = 4
_name$ = -12						; size = 8
_registered$ = -4					; size = 4
_IsVolumeClassFilterRegistered@0 PROC			; COMDAT

; 3106 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 18	 sub	 esp, 24			; 00000018H
  00008	56		 push	 esi
  00009	57		 push	 edi

; 3107 : 	UNICODE_STRING name;
; 3108 : 	NTSTATUS status;
; 3109 : 	BOOL registered = FALSE;

  0000a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _registered$[ebp], 0

; 3110 : 
; 3111 : 	PKEY_VALUE_PARTIAL_INFORMATION data;
; 3112 : 
; 3113 : 	/*
; 3114 : 	 * Note: Do not change the "Storage Volumes" guid (System-Defined Device Setup Classes).
; 3115 : 	 * This class includes storage volumes as defined by the system-supplied
; 3116 : 	 * logical volume manager and class drivers that create device objects to
; 3117 : 	 * represent storage volumes, such as the system disk class driver.
; 3118 : 	 * @see	http://msdn.microsoft.com/en-us/library/windows/hardware/ff553426%28v=vs.85%29.aspx
; 3119 : 	 */
; 3120 : 	RtlInitUnicodeString (&name, L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class\\{71A27CDD-812A-11D0-BEC7-08002BE2092F}");

  00011	68 00 00 00 00	 push	 OFFSET ??_C@_1MA@BNNNAGDA@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
  00016	8d 45 f4	 lea	 eax, DWORD PTR _name$[ebp]
  00019	50		 push	 eax
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 3121 : 	status = TCReadRegistryKey (&name, L"UpperFilters", &data);

  00020	8d 4d f0	 lea	 ecx, DWORD PTR _data$[ebp]
  00023	51		 push	 ecx
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@FNJCPENK@?$AAU?$AAp?$AAp?$AAe?$AAr?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAs?$AA?$AA@FNODOBFM@
  00029	8d 55 f4	 lea	 edx, DWORD PTR _name$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 _TCReadRegistryKey@12
  00032	89 45 ec	 mov	 DWORD PTR _status$[ebp], eax

; 3122 : 
; 3123 : 	if (NT_SUCCESS (status))

  00035	83 7d ec 00	 cmp	 DWORD PTR _status$[ebp], 0
  00039	7c 74		 jl	 SHORT $LN6@IsVolumeCl

; 3124 : 	{
; 3125 : 		if (data->Type == REG_MULTI_SZ && data->DataLength >= 9 * sizeof (wchar_t))

  0003b	8b 45 f0	 mov	 eax, DWORD PTR _data$[ebp]
  0003e	83 78 04 07	 cmp	 DWORD PTR [eax+4], 7
  00042	75 5c		 jne	 SHORT $LN5@IsVolumeCl
  00044	8b 4d f0	 mov	 ecx, DWORD PTR _data$[ebp]
  00047	83 79 08 12	 cmp	 DWORD PTR [ecx+8], 18	; 00000012H
  0004b	72 53		 jb	 SHORT $LN5@IsVolumeCl

; 3126 : 		{
; 3127 : 			// Search for the string "truecrypt"
; 3128 : 			ULONG i;
; 3129 : 			for (i = 0; i <= data->DataLength - 9 * sizeof (wchar_t); ++i)

  0004d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$31651[ebp], 0
  00054	eb 09		 jmp	 SHORT $LN4@IsVolumeCl
$LN3@IsVolumeCl:
  00056	8b 55 e8	 mov	 edx, DWORD PTR _i$31651[ebp]
  00059	83 c2 01	 add	 edx, 1
  0005c	89 55 e8	 mov	 DWORD PTR _i$31651[ebp], edx
$LN4@IsVolumeCl:
  0005f	8b 45 f0	 mov	 eax, DWORD PTR _data$[ebp]
  00062	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00065	83 e9 12	 sub	 ecx, 18			; 00000012H
  00068	39 4d e8	 cmp	 DWORD PTR _i$31651[ebp], ecx
  0006b	77 33		 ja	 SHORT $LN5@IsVolumeCl

; 3130 : 			{
; 3131 : 				if (memcmp (data->Data + i, L"truecrypt", 9 * sizeof (wchar_t)) == 0)

  0006d	b9 09 00 00 00	 mov	 ecx, 9
  00072	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_1BE@OBOIPPHP@?$AAt?$AAr?$AAu?$AAe?$AAc?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
  00077	8b 55 e8	 mov	 edx, DWORD PTR _i$31651[ebp]
  0007a	8b 45 f0	 mov	 eax, DWORD PTR _data$[ebp]
  0007d	8d 74 10 0c	 lea	 esi, DWORD PTR [eax+edx+12]
  00081	33 d2		 xor	 edx, edx
  00083	66 f3 a7	 repe cmpsw
  00086	75 16		 jne	 SHORT $LN1@IsVolumeCl

; 3132 : 				{
; 3133 : 					Dump ("Volume class filter active\n");

  00088	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@GOBMMLHF@Volume?5class?5filter?5active?6?$AA@FNODOBFM@
  0008d	e8 00 00 00 00	 call	 _DbgPrint
  00092	83 c4 04	 add	 esp, 4

; 3134 : 					registered = TRUE;

  00095	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _registered$[ebp], 1

; 3135 : 					break;

  0009c	eb 02		 jmp	 SHORT $LN5@IsVolumeCl
$LN1@IsVolumeCl:

; 3136 : 				}
; 3137 : 			}

  0009e	eb b6		 jmp	 SHORT $LN3@IsVolumeCl
$LN5@IsVolumeCl:

; 3138 : 		}
; 3139 : 
; 3140 : 		TCfree (data);

  000a0	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  000a5	8b 45 f0	 mov	 eax, DWORD PTR _data$[ebp]
  000a8	50		 push	 eax
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN6@IsVolumeCl:

; 3141 : 	}
; 3142 : 
; 3143 : 	return registered;

  000af	8b 45 fc	 mov	 eax, DWORD PTR _registered$[ebp]

; 3144 : }

  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c3		 ret	 0
_IsVolumeClassFilterRegistered@0 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EA@CEOJFLPD@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAE?$AAn?$AAc?$AAr?$AAy?$AAp?$AAt?$AAi?$AAo?$AAn?$AAF?$AAr?$AAe?$AAe?$AAC?$AAp?$AAu?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BM@LHOAOPML@Configuration?5flags?5?$DN?50x?$CFx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CA@LGEHFLCO@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1HM@GLBNDPGI@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	_EnableHwEncryption@4:PROC
;	COMDAT ??_C@_1EA@CEOJFLPD@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAE?$AAn?$AAc?$AAr?$AAy?$AAp?$AAt?$AAi?$AAo?$AAn?$AAF?$AAr?$AAe?$AAe?$AAC?$AAp?$AAu?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1EA@CEOJFLPD@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAE?$AAn?$AAc?$AAr?$AAy?$AAp?$AAt?$AAi?$AAo?$AAn?$AAF?$AAr?$AAe?$AAe?$AAC?$AAp?$AAu?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, 'E', 00H, 'n', 00H, 'c', 00H, 'r', 00H, 'y'
	DB	00H, 'p', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'F', 00H
	DB	'r', 00H, 'e', 00H, 'e', 00H, 'C', 00H, 'p', 00H, 'u', 00H, 'C'
	DB	00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BM@LHOAOPML@Configuration?5flags?5?$DN?50x?$CFx?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BM@LHOAOPML@Configuration?5flags?5?$DN?50x?$CFx?6?$AA@FNODOBFM@ DB 'C'
	DB	'onfiguration flags = 0x%x', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CA@LGEHFLCO@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CA@LGEHFLCO@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 'f', 00H, 'i'
	DB	00H, 'g', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1HM@GLBNDPGI@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
text$s	SEGMENT
??_C@_1HM@GLBNDPGI@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@ DB '\'
	DB	00H, 'R', 00H, 'E', 00H, 'G', 00H, 'I', 00H, 'S', 00H, 'T', 00H
	DB	'R', 00H, 'Y', 00H, '\', 00H, 'M', 00H, 'A', 00H, 'C', 00H, 'H'
	DB	00H, 'I', 00H, 'N', 00H, 'E', 00H, '\', 00H, 'S', 00H, 'Y', 00H
	DB	'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '\', 00H, 'C', 00H, 'u'
	DB	00H, 'r', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'C', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, 'r', 00H, 'o', 00H, 'l', 00H, 'S'
	DB	00H, 'e', 00H, 't', 00H, '\', 00H, 'S', 00H, 'e', 00H, 'r', 00H
	DB	'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 'c', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _ReadRegistryConfigFlags@4
_TEXT	SEGMENT
_data$ = -20						; size = 4
_status$ = -16						; size = 4
_name$ = -12						; size = 8
_flags$ = -4						; size = 4
_driverEntry$ = 8					; size = 4
_ReadRegistryConfigFlags@4 PROC				; COMDAT

; 3148 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 14	 sub	 esp, 20			; 00000014H

; 3149 : 	PKEY_VALUE_PARTIAL_INFORMATION data;
; 3150 : 	UNICODE_STRING name;
; 3151 : 	NTSTATUS status;
; 3152 : 	uint32 flags = 0;

  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _flags$[ebp], 0

; 3153 : 
; 3154 : 	RtlInitUnicodeString (&name, L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\truecrypt");

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_1HM@GLBNDPGI@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
  00014	8d 45 f4	 lea	 eax, DWORD PTR _name$[ebp]
  00017	50		 push	 eax
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 3155 : 	status = TCReadRegistryKey (&name, TC_DRIVER_CONFIG_REG_VALUE_NAME, &data);

  0001e	8d 4d ec	 lea	 ecx, DWORD PTR _data$[ebp]
  00021	51		 push	 ecx
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_1CA@LGEHFLCO@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@
  00027	8d 55 f4	 lea	 edx, DWORD PTR _name$[ebp]
  0002a	52		 push	 edx
  0002b	e8 00 00 00 00	 call	 _TCReadRegistryKey@12
  00030	89 45 f0	 mov	 DWORD PTR _status$[ebp], eax

; 3156 : 
; 3157 : 	if (NT_SUCCESS (status))

  00033	83 7d f0 00	 cmp	 DWORD PTR _status$[ebp], 0
  00037	7c 78		 jl	 SHORT $LN8@ReadRegist

; 3158 : 	{
; 3159 : 		if (data->Type == REG_DWORD)

  00039	8b 45 ec	 mov	 eax, DWORD PTR _data$[ebp]
  0003c	83 78 04 04	 cmp	 DWORD PTR [eax+4], 4
  00040	75 59		 jne	 SHORT $LN7@ReadRegist

; 3160 : 		{
; 3161 : 			flags = *(uint32 *) data->Data;

  00042	8b 4d ec	 mov	 ecx, DWORD PTR _data$[ebp]
  00045	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00048	89 55 fc	 mov	 DWORD PTR _flags$[ebp], edx

; 3162 : 			Dump ("Configuration flags = 0x%x\n", flags);

  0004b	8b 45 fc	 mov	 eax, DWORD PTR _flags$[ebp]
  0004e	50		 push	 eax
  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@LHOAOPML@Configuration?5flags?5?$DN?50x?$CFx?6?$AA@FNODOBFM@
  00054	e8 00 00 00 00	 call	 _DbgPrint
  00059	83 c4 08	 add	 esp, 8

; 3163 : 
; 3164 : 			if (driverEntry)

  0005c	83 7d 08 00	 cmp	 DWORD PTR _driverEntry$[ebp], 0
  00060	74 24		 je	 SHORT $LN6@ReadRegist

; 3165 : 			{
; 3166 : 				if (flags & (TC_DRIVER_CONFIG_CACHE_BOOT_PASSWORD | TC_DRIVER_CONFIG_CACHE_BOOT_PASSWORD_FOR_SYS_FAVORITES))

  00062	8b 4d fc	 mov	 ecx, DWORD PTR _flags$[ebp]
  00065	83 e1 03	 and	 ecx, 3
  00068	74 0a		 je	 SHORT $LN5@ReadRegist

; 3167 : 					CacheBootPassword = TRUE;

  0006a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CacheBootPassword, 1
$LN5@ReadRegist:

; 3168 : 
; 3169 : 				if (flags & TC_DRIVER_CONFIG_DISABLE_NONADMIN_SYS_FAVORITES_ACCESS)

  00074	8b 55 fc	 mov	 edx, DWORD PTR _flags$[ebp]
  00077	83 e2 04	 and	 edx, 4
  0007a	74 0a		 je	 SHORT $LN6@ReadRegist

; 3170 : 					NonAdminSystemFavoritesAccessDisabled = TRUE;

  0007c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _NonAdminSystemFavoritesAccessDisabled, 1
$LN6@ReadRegist:

; 3171 : 			}
; 3172 : 
; 3173 : 			EnableHwEncryption ((flags & TC_DRIVER_CONFIG_DISABLE_HARDWARE_ENCRYPTION) ? FALSE : TRUE);

  00086	8b 45 fc	 mov	 eax, DWORD PTR _flags$[ebp]
  00089	83 e0 08	 and	 eax, 8
  0008c	f7 d8		 neg	 eax
  0008e	1b c0		 sbb	 eax, eax
  00090	83 c0 01	 add	 eax, 1
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 _EnableHwEncryption@4

; 3174 : 		}
; 3175 : 		else

  00099	eb 07		 jmp	 SHORT $LN3@ReadRegist
$LN7@ReadRegist:

; 3176 : 			status = STATUS_INVALID_PARAMETER;

  0009b	c7 45 f0 0d 00
	00 c0		 mov	 DWORD PTR _status$[ebp], -1073741811 ; c000000dH
$LN3@ReadRegist:

; 3177 : 
; 3178 : 		TCfree (data);

  000a2	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  000a7	8b 4d ec	 mov	 ecx, DWORD PTR _data$[ebp]
  000aa	51		 push	 ecx
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN8@ReadRegist:

; 3179 : 	}
; 3180 : 
; 3181 : 	if (driverEntry && NT_SUCCESS (TCReadRegistryKey (&name, TC_ENCRYPTION_FREE_CPU_COUNT_REG_VALUE_NAME, &data)))

  000b1	83 7d 08 00	 cmp	 DWORD PTR _driverEntry$[ebp], 0
  000b5	74 39		 je	 SHORT $LN2@ReadRegist
  000b7	8d 55 ec	 lea	 edx, DWORD PTR _data$[ebp]
  000ba	52		 push	 edx
  000bb	68 00 00 00 00	 push	 OFFSET ??_C@_1EA@CEOJFLPD@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAE?$AAn?$AAc?$AAr?$AAy?$AAp?$AAt?$AAi?$AAo?$AAn?$AAF?$AAr?$AAe?$AAe?$AAC?$AAp?$AAu?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@FNODOBFM@
  000c0	8d 45 f4	 lea	 eax, DWORD PTR _name$[ebp]
  000c3	50		 push	 eax
  000c4	e8 00 00 00 00	 call	 _TCReadRegistryKey@12
  000c9	85 c0		 test	 eax, eax
  000cb	7c 23		 jl	 SHORT $LN2@ReadRegist

; 3182 : 	{
; 3183 : 		if (data->Type == REG_DWORD)

  000cd	8b 4d ec	 mov	 ecx, DWORD PTR _data$[ebp]
  000d0	83 79 04 04	 cmp	 DWORD PTR [ecx+4], 4
  000d4	75 0b		 jne	 SHORT $LN1@ReadRegist

; 3184 : 			EncryptionThreadPoolFreeCpuCountLimit = *(uint32 *) data->Data;

  000d6	8b 55 ec	 mov	 edx, DWORD PTR _data$[ebp]
  000d9	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000dc	a3 00 00 00 00	 mov	 DWORD PTR _EncryptionThreadPoolFreeCpuCountLimit, eax
$LN1@ReadRegist:

; 3185 : 
; 3186 : 		TCfree (data);

  000e1	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  000e6	8b 4d ec	 mov	 ecx, DWORD PTR _data$[ebp]
  000e9	51		 push	 ecx
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN2@ReadRegist:

; 3187 : 	}
; 3188 : 
; 3189 : 	return status;

  000f0	8b 45 f0	 mov	 eax, DWORD PTR _status$[ebp]

; 3190 : }

  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c2 04 00	 ret	 4
_ReadRegistryConfigFlags@4 ENDP
_TEXT	ENDS
PUBLIC	_WriteRegistryConfigFlags@4
; Function compile flags: /Odtp
;	COMDAT _WriteRegistryConfigFlags@4
_TEXT	SEGMENT
_name$ = -8						; size = 8
_flags$ = 8						; size = 4
_WriteRegistryConfigFlags@4 PROC			; COMDAT

; 3194 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 3195 : 	UNICODE_STRING name;
; 3196 : 	RtlInitUnicodeString (&name, L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\truecrypt");

  00008	68 00 00 00 00	 push	 OFFSET ??_C@_1HM@GLBNDPGI@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
  0000d	8d 45 f8	 lea	 eax, DWORD PTR _name$[ebp]
  00010	50		 push	 eax
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 3197 : 
; 3198 : 	return TCWriteRegistryKey (&name, TC_DRIVER_CONFIG_REG_VALUE_NAME, REG_DWORD, &flags, sizeof (flags));

  00017	6a 04		 push	 4
  00019	8d 4d 08	 lea	 ecx, DWORD PTR _flags$[ebp]
  0001c	51		 push	 ecx
  0001d	6a 04		 push	 4
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_1CA@LGEHFLCO@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@
  00024	8d 55 f8	 lea	 edx, DWORD PTR _name$[ebp]
  00027	52		 push	 edx
  00028	e8 00 00 00 00	 call	 _TCWriteRegistryKey@20

; 3199 : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
_WriteRegistryConfigFlags@4 ENDP
_TEXT	ENDS
PUBLIC	_GetDeviceSectorSize@8
; Function compile flags: /Odtp
;	COMDAT _GetDeviceSectorSize@8
_TEXT	SEGMENT
_status$ = -28						; size = 4
_geometry$ = -24					; size = 24
_deviceObject$ = 8					; size = 4
_bytesPerSector$ = 12					; size = 4
_GetDeviceSectorSize@8 PROC				; COMDAT

; 3203 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 3204 : 	NTSTATUS status;
; 3205 : 	DISK_GEOMETRY geometry;
; 3206 : 
; 3207 : 	status = SendDeviceIoControlRequest (deviceObject, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &geometry, sizeof (geometry));

  00008	6a 18		 push	 24			; 00000018H
  0000a	8d 45 e8	 lea	 eax, DWORD PTR _geometry$[ebp]
  0000d	50		 push	 eax
  0000e	6a 00		 push	 0
  00010	6a 00		 push	 0
  00012	68 00 00 07 00	 push	 458752			; 00070000H
  00017	8b 4d 08	 mov	 ecx, DWORD PTR _deviceObject$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  00020	89 45 e4	 mov	 DWORD PTR _status$[ebp], eax

; 3208 : 
; 3209 : 	if (!NT_SUCCESS (status))

  00023	83 7d e4 00	 cmp	 DWORD PTR _status$[ebp], 0
  00027	7d 05		 jge	 SHORT $LN1@GetDeviceS

; 3210 : 		return status;

  00029	8b 45 e4	 mov	 eax, DWORD PTR _status$[ebp]
  0002c	eb 0a		 jmp	 SHORT $LN2@GetDeviceS
$LN1@GetDeviceS:

; 3211 : 
; 3212 : 	*bytesPerSector = geometry.BytesPerSector;

  0002e	8b 55 0c	 mov	 edx, DWORD PTR _bytesPerSector$[ebp]
  00031	8b 45 fc	 mov	 eax, DWORD PTR _geometry$[ebp+20]
  00034	89 02		 mov	 DWORD PTR [edx], eax

; 3213 : 	return STATUS_SUCCESS;

  00036	33 c0		 xor	 eax, eax
$LN2@GetDeviceS:

; 3214 : }

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
_GetDeviceSectorSize@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@BHMICMIC@Zeroing?5sector?5at?5?$CFI64d?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_ZeroUnreadableSectors@20
;	COMDAT ??_C@_0BJ@BHMICMIC@Zeroing?5sector?5at?5?$CFI64d?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BJ@BHMICMIC@Zeroing?5sector?5at?5?$CFI64d?6?$AA@FNODOBFM@ DB 'Zero'
	DB	'ing sector at %I64d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _ZeroUnreadableSectors@20
_TEXT	SEGMENT
_sectorCount$ = -16					; size = 4
_status$ = -12						; size = 4
_sectorBuffer$ = -8					; size = 4
_sectorSize$ = -4					; size = 4
_deviceObject$ = 8					; size = 4
_startOffset$ = 12					; size = 8
_size$ = 20						; size = 4
_zeroedSectorCount$ = 24				; size = 4
_ZeroUnreadableSectors@20 PROC				; COMDAT

; 3218 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 10	 sub	 esp, 16			; 00000010H

; 3219 : 	NTSTATUS status;
; 3220 : 	ULONG sectorSize;
; 3221 : 	ULONG sectorCount;
; 3222 : 	byte *sectorBuffer = NULL;

  00008	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _sectorBuffer$[ebp], 0

; 3223 : 
; 3224 : 	*zeroedSectorCount = 0;

  0000f	8b 45 18	 mov	 eax, DWORD PTR _zeroedSectorCount$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00018	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 3225 : 
; 3226 : 	status = GetDeviceSectorSize (deviceObject, &sectorSize);

  0001f	8d 4d fc	 lea	 ecx, DWORD PTR _sectorSize$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR _deviceObject$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 _GetDeviceSectorSize@8
  0002c	89 45 f4	 mov	 DWORD PTR _status$[ebp], eax

; 3227 : 	if (!NT_SUCCESS (status))

  0002f	83 7d f4 00	 cmp	 DWORD PTR _status$[ebp], 0
  00033	7d 08		 jge	 SHORT $LN8@ZeroUnread

; 3228 : 		return status;

  00035	8b 45 f4	 mov	 eax, DWORD PTR _status$[ebp]
  00038	e9 fe 00 00 00	 jmp	 $LN9@ZeroUnread
$LN8@ZeroUnread:

; 3229 : 
; 3230 : 	sectorBuffer = TCalloc (sectorSize);

  0003d	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00042	8b 45 fc	 mov	 eax, DWORD PTR _sectorSize$[ebp]
  00045	50		 push	 eax
  00046	6a 00		 push	 0
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0004e	89 45 f8	 mov	 DWORD PTR _sectorBuffer$[ebp], eax

; 3231 : 	if (!sectorBuffer)

  00051	83 7d f8 00	 cmp	 DWORD PTR _sectorBuffer$[ebp], 0
  00055	75 0a		 jne	 SHORT $LN7@ZeroUnread

; 3232 : 		return STATUS_INSUFFICIENT_RESOURCES;

  00057	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  0005c	e9 da 00 00 00	 jmp	 $LN9@ZeroUnread
$LN7@ZeroUnread:

; 3233 : 
; 3234 : 	for (sectorCount = size / sectorSize; sectorCount > 0; --sectorCount, startOffset.QuadPart += sectorSize)

  00061	8b 45 14	 mov	 eax, DWORD PTR _size$[ebp]
  00064	33 d2		 xor	 edx, edx
  00066	f7 75 fc	 div	 DWORD PTR _sectorSize$[ebp]
  00069	89 45 f0	 mov	 DWORD PTR _sectorCount$[ebp], eax
  0006c	eb 1c		 jmp	 SHORT $LN6@ZeroUnread
$LN5@ZeroUnread:
  0006e	8b 4d f0	 mov	 ecx, DWORD PTR _sectorCount$[ebp]
  00071	83 e9 01	 sub	 ecx, 1
  00074	89 4d f0	 mov	 DWORD PTR _sectorCount$[ebp], ecx
  00077	8b 55 fc	 mov	 edx, DWORD PTR _sectorSize$[ebp]
  0007a	33 c0		 xor	 eax, eax
  0007c	03 55 0c	 add	 edx, DWORD PTR _startOffset$[ebp]
  0007f	8b 4d 10	 mov	 ecx, DWORD PTR _startOffset$[ebp+4]
  00082	13 c8		 adc	 ecx, eax
  00084	89 55 0c	 mov	 DWORD PTR _startOffset$[ebp], edx
  00087	89 4d 10	 mov	 DWORD PTR _startOffset$[ebp+4], ecx
$LN6@ZeroUnread:
  0008a	83 7d f0 00	 cmp	 DWORD PTR _sectorCount$[ebp], 0
  0008e	0f 86 88 00 00
	00		 jbe	 $LN4@ZeroUnread

; 3235 : 	{
; 3236 : 		status = TCReadDevice (deviceObject, sectorBuffer, startOffset, sectorSize);

  00094	8b 55 fc	 mov	 edx, DWORD PTR _sectorSize$[ebp]
  00097	52		 push	 edx
  00098	8b 45 10	 mov	 eax, DWORD PTR _startOffset$[ebp+4]
  0009b	50		 push	 eax
  0009c	8b 4d 0c	 mov	 ecx, DWORD PTR _startOffset$[ebp]
  0009f	51		 push	 ecx
  000a0	8b 55 f8	 mov	 edx, DWORD PTR _sectorBuffer$[ebp]
  000a3	52		 push	 edx
  000a4	8b 45 08	 mov	 eax, DWORD PTR _deviceObject$[ebp]
  000a7	50		 push	 eax
  000a8	e8 00 00 00 00	 call	 _TCReadDevice@20
  000ad	89 45 f4	 mov	 DWORD PTR _status$[ebp], eax

; 3237 : 		if (!NT_SUCCESS (status))

  000b0	83 7d f4 00	 cmp	 DWORD PTR _status$[ebp], 0
  000b4	7d 61		 jge	 SHORT $LN3@ZeroUnread

; 3238 : 		{
; 3239 : 			Dump ("Zeroing sector at %I64d\n", startOffset.QuadPart);

  000b6	8b 4d 10	 mov	 ecx, DWORD PTR _startOffset$[ebp+4]
  000b9	51		 push	 ecx
  000ba	8b 55 0c	 mov	 edx, DWORD PTR _startOffset$[ebp]
  000bd	52		 push	 edx
  000be	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@BHMICMIC@Zeroing?5sector?5at?5?$CFI64d?6?$AA@FNODOBFM@
  000c3	e8 00 00 00 00	 call	 _DbgPrint
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3240 : 			memset (sectorBuffer, 0, sectorSize);

  000cb	8b 45 fc	 mov	 eax, DWORD PTR _sectorSize$[ebp]
  000ce	50		 push	 eax
  000cf	6a 00		 push	 0
  000d1	8b 4d f8	 mov	 ecx, DWORD PTR _sectorBuffer$[ebp]
  000d4	51		 push	 ecx
  000d5	e8 00 00 00 00	 call	 _memset
  000da	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3241 : 
; 3242 : 			status = TCWriteDevice (deviceObject, sectorBuffer, startOffset, sectorSize);

  000dd	8b 55 fc	 mov	 edx, DWORD PTR _sectorSize$[ebp]
  000e0	52		 push	 edx
  000e1	8b 45 10	 mov	 eax, DWORD PTR _startOffset$[ebp+4]
  000e4	50		 push	 eax
  000e5	8b 4d 0c	 mov	 ecx, DWORD PTR _startOffset$[ebp]
  000e8	51		 push	 ecx
  000e9	8b 55 f8	 mov	 edx, DWORD PTR _sectorBuffer$[ebp]
  000ec	52		 push	 edx
  000ed	8b 45 08	 mov	 eax, DWORD PTR _deviceObject$[ebp]
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 _TCWriteDevice@20
  000f6	89 45 f4	 mov	 DWORD PTR _status$[ebp], eax

; 3243 : 			if (!NT_SUCCESS (status))

  000f9	83 7d f4 00	 cmp	 DWORD PTR _status$[ebp], 0
  000fd	7d 02		 jge	 SHORT $LN2@ZeroUnread

; 3244 : 				goto err;

  000ff	eb 22		 jmp	 SHORT $err$31729
$LN2@ZeroUnread:

; 3245 : 
; 3246 : 			++(*zeroedSectorCount);

  00101	8b 4d 18	 mov	 ecx, DWORD PTR _zeroedSectorCount$[ebp]
  00104	8b 11		 mov	 edx, DWORD PTR [ecx]
  00106	83 c2 01	 add	 edx, 1
  00109	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0010c	83 d0 00	 adc	 eax, 0
  0010f	8b 4d 18	 mov	 ecx, DWORD PTR _zeroedSectorCount$[ebp]
  00112	89 11		 mov	 DWORD PTR [ecx], edx
  00114	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN3@ZeroUnread:

; 3247 : 		}
; 3248 : 	}

  00117	e9 52 ff ff ff	 jmp	 $LN5@ZeroUnread
$LN4@ZeroUnread:

; 3249 : 
; 3250 : 	status = STATUS_SUCCESS;

  0011c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _status$[ebp], 0
$err$31729:

; 3251 : 
; 3252 : err:
; 3253 : 	if (sectorBuffer)

  00123	83 7d f8 00	 cmp	 DWORD PTR _sectorBuffer$[ebp], 0
  00127	74 0f		 je	 SHORT $LN1@ZeroUnread

; 3254 : 		TCfree (sectorBuffer);

  00129	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0012e	8b 55 f8	 mov	 edx, DWORD PTR _sectorBuffer$[ebp]
  00131	52		 push	 edx
  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN1@ZeroUnread:

; 3255 : 
; 3256 : 	return status;

  00138	8b 45 f4	 mov	 eax, DWORD PTR _status$[ebp]
$LN9@ZeroUnread:

; 3257 : }

  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c2 14 00	 ret	 20			; 00000014H
_ZeroUnreadableSectors@20 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@NFNIJFEK@Skipping?5bad?5sector?5at?5?$CFI64d?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_ReadDeviceSkipUnreadableSectors@24
;	COMDAT ??_C@_0BO@NFNIJFEK@Skipping?5bad?5sector?5at?5?$CFI64d?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BO@NFNIJFEK@Skipping?5bad?5sector?5at?5?$CFI64d?6?$AA@FNODOBFM@ DB 'S'
	DB	'kipping bad sector at %I64d', 0aH, 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _ReadDeviceSkipUnreadableSectors@24
_TEXT	SEGMENT
_sectorCount$ = -12					; size = 4
_status$ = -8						; size = 4
_sectorSize$ = -4					; size = 4
_deviceObject$ = 8					; size = 4
_buffer$ = 12						; size = 4
_startOffset$ = 16					; size = 8
_size$ = 24						; size = 4
_badSectorCount$ = 28					; size = 4
_ReadDeviceSkipUnreadableSectors@24 PROC		; COMDAT

; 3261 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 3262 : 	NTSTATUS status;
; 3263 : 	ULONG sectorSize;
; 3264 : 	ULONG sectorCount;
; 3265 : 
; 3266 : 	*badSectorCount = 0;

  00008	8b 45 1c	 mov	 eax, DWORD PTR _badSectorCount$[ebp]
  0000b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00011	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 3267 : 
; 3268 : 	status = GetDeviceSectorSize (deviceObject, &sectorSize);

  00018	8d 4d fc	 lea	 ecx, DWORD PTR _sectorSize$[ebp]
  0001b	51		 push	 ecx
  0001c	8b 55 08	 mov	 edx, DWORD PTR _deviceObject$[ebp]
  0001f	52		 push	 edx
  00020	e8 00 00 00 00	 call	 _GetDeviceSectorSize@8
  00025	89 45 f8	 mov	 DWORD PTR _status$[ebp], eax

; 3269 : 	if (!NT_SUCCESS (status))

  00028	83 7d f8 00	 cmp	 DWORD PTR _status$[ebp], 0
  0002c	7d 08		 jge	 SHORT $LN5@ReadDevice

; 3270 : 		return status;

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _status$[ebp]
  00031	e9 9e 00 00 00	 jmp	 $LN6@ReadDevice
$LN5@ReadDevice:

; 3271 : 
; 3272 : 	for (sectorCount = size / sectorSize; sectorCount > 0; --sectorCount, startOffset.QuadPart += sectorSize, buffer += sectorSize)

  00036	8b 45 18	 mov	 eax, DWORD PTR _size$[ebp]
  00039	33 d2		 xor	 edx, edx
  0003b	f7 75 fc	 div	 DWORD PTR _sectorSize$[ebp]
  0003e	89 45 f4	 mov	 DWORD PTR _sectorCount$[ebp], eax
  00041	eb 25		 jmp	 SHORT $LN4@ReadDevice
$LN3@ReadDevice:
  00043	8b 45 f4	 mov	 eax, DWORD PTR _sectorCount$[ebp]
  00046	83 e8 01	 sub	 eax, 1
  00049	89 45 f4	 mov	 DWORD PTR _sectorCount$[ebp], eax
  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _sectorSize$[ebp]
  0004f	33 d2		 xor	 edx, edx
  00051	03 4d 10	 add	 ecx, DWORD PTR _startOffset$[ebp]
  00054	8b 45 14	 mov	 eax, DWORD PTR _startOffset$[ebp+4]
  00057	13 c2		 adc	 eax, edx
  00059	89 4d 10	 mov	 DWORD PTR _startOffset$[ebp], ecx
  0005c	89 45 14	 mov	 DWORD PTR _startOffset$[ebp+4], eax
  0005f	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00062	03 4d fc	 add	 ecx, DWORD PTR _sectorSize$[ebp]
  00065	89 4d 0c	 mov	 DWORD PTR _buffer$[ebp], ecx
$LN4@ReadDevice:
  00068	83 7d f4 00	 cmp	 DWORD PTR _sectorCount$[ebp], 0
  0006c	76 64		 jbe	 SHORT $LN2@ReadDevice

; 3273 : 	{
; 3274 : 		status = TCReadDevice (deviceObject, buffer, startOffset, sectorSize);

  0006e	8b 55 fc	 mov	 edx, DWORD PTR _sectorSize$[ebp]
  00071	52		 push	 edx
  00072	8b 45 14	 mov	 eax, DWORD PTR _startOffset$[ebp+4]
  00075	50		 push	 eax
  00076	8b 4d 10	 mov	 ecx, DWORD PTR _startOffset$[ebp]
  00079	51		 push	 ecx
  0007a	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  0007d	52		 push	 edx
  0007e	8b 45 08	 mov	 eax, DWORD PTR _deviceObject$[ebp]
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 _TCReadDevice@20
  00087	89 45 f8	 mov	 DWORD PTR _status$[ebp], eax

; 3275 : 		if (!NT_SUCCESS (status))

  0008a	83 7d f8 00	 cmp	 DWORD PTR _status$[ebp], 0
  0008e	7d 3d		 jge	 SHORT $LN1@ReadDevice

; 3276 : 		{
; 3277 : 			Dump ("Skipping bad sector at %I64d\n", startOffset.QuadPart);

  00090	8b 4d 14	 mov	 ecx, DWORD PTR _startOffset$[ebp+4]
  00093	51		 push	 ecx
  00094	8b 55 10	 mov	 edx, DWORD PTR _startOffset$[ebp]
  00097	52		 push	 edx
  00098	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@NFNIJFEK@Skipping?5bad?5sector?5at?5?$CFI64d?6?$AA@FNODOBFM@
  0009d	e8 00 00 00 00	 call	 _DbgPrint
  000a2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3278 : 			memset (buffer, 0, sectorSize);

  000a5	8b 45 fc	 mov	 eax, DWORD PTR _sectorSize$[ebp]
  000a8	50		 push	 eax
  000a9	6a 00		 push	 0
  000ab	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  000ae	51		 push	 ecx
  000af	e8 00 00 00 00	 call	 _memset
  000b4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3279 : 			++(*badSectorCount);

  000b7	8b 55 1c	 mov	 edx, DWORD PTR _badSectorCount$[ebp]
  000ba	8b 02		 mov	 eax, DWORD PTR [edx]
  000bc	83 c0 01	 add	 eax, 1
  000bf	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000c2	83 d1 00	 adc	 ecx, 0
  000c5	8b 55 1c	 mov	 edx, DWORD PTR _badSectorCount$[ebp]
  000c8	89 02		 mov	 DWORD PTR [edx], eax
  000ca	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN1@ReadDevice:

; 3280 : 		}
; 3281 : 	}

  000cd	e9 71 ff ff ff	 jmp	 $LN3@ReadDevice
$LN2@ReadDevice:

; 3282 : 
; 3283 : 	return STATUS_SUCCESS;

  000d2	33 c0		 xor	 eax, eax
$LN6@ReadDevice:

; 3284 : }

  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c2 18 00	 ret	 24			; 00000018H
_ReadDeviceSkipUnreadableSectors@24 ENDP
_TEXT	ENDS
EXTRN	__imp__RtlEqualSid@8:PROC
EXTRN	__imp__SeTokenIsAdmin@4:PROC
; Function compile flags: /Odtp
;	COMDAT _IsVolumeAccessibleByCurrentUser@4
_TEXT	SEGMENT
_result$ = -28						; size = 4
_tokenUser$ = -24					; size = 4
_subContext$ = -20					; size = 16
_accessToken$ = -4					; size = 4
_volumeDeviceExtension$ = 8				; size = 4
_IsVolumeAccessibleByCurrentUser@4 PROC			; COMDAT

; 3288 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 3289 : 	SECURITY_SUBJECT_CONTEXT subContext;
; 3290 : 	PACCESS_TOKEN accessToken;
; 3291 : 	PTOKEN_USER tokenUser;
; 3292 : 	BOOL result = FALSE;

  00008	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _result$[ebp], 0

; 3293 : 
; 3294 : 	if (IoIsSystemThread (PsGetCurrentThread())
; 3295 : 		|| UserCanAccessDriveDevice()
; 3296 : 		|| !volumeDeviceExtension->UserSid
; 3297 : 		|| (volumeDeviceExtension->SystemFavorite && !NonAdminSystemFavoritesAccessDisabled))

  0000f	e8 00 00 00 00	 call	 _PsGetCurrentThread@0
  00014	50		 push	 eax
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoIsSystemThread@4
  0001b	0f b6 c0	 movzx	 eax, al
  0001e	85 c0		 test	 eax, eax
  00020	75 2a		 jne	 SHORT $LN4@IsVolumeAc
  00022	e8 00 00 00 00	 call	 _UserCanAccessDriveDevice@0
  00027	85 c0		 test	 eax, eax
  00029	75 21		 jne	 SHORT $LN4@IsVolumeAc
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _volumeDeviceExtension$[ebp]
  0002e	83 b9 cc 04 00
	00 00		 cmp	 DWORD PTR [ecx+1228], 0
  00035	74 15		 je	 SHORT $LN4@IsVolumeAc
  00037	8b 55 08	 mov	 edx, DWORD PTR _volumeDeviceExtension$[ebp]
  0003a	83 ba 9c 02 00
	00 00		 cmp	 DWORD PTR [edx+668], 0
  00041	74 13		 je	 SHORT $LN5@IsVolumeAc
  00043	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _NonAdminSystemFavoritesAccessDisabled, 0
  0004a	75 0a		 jne	 SHORT $LN5@IsVolumeAc
$LN4@IsVolumeAc:

; 3298 : 	{
; 3299 : 		return TRUE;

  0004c	b8 01 00 00 00	 mov	 eax, 1
  00051	e9 97 00 00 00	 jmp	 $LN6@IsVolumeAc
$LN5@IsVolumeAc:

; 3300 : 	}
; 3301 : 
; 3302 : 	SeCaptureSubjectContext (&subContext);

  00056	8d 45 ec	 lea	 eax, DWORD PTR _subContext$[ebp]
  00059	50		 push	 eax
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeCaptureSubjectContext@4

; 3303 : 	SeLockSubjectContext(&subContext);

  00060	8d 4d ec	 lea	 ecx, DWORD PTR _subContext$[ebp]
  00063	51		 push	 ecx
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeLockSubjectContext@4

; 3304 : 	accessToken = getToken(&subContext);

  0006a	8d 55 ec	 lea	 edx, DWORD PTR _subContext$[ebp]
  0006d	52		 push	 edx
  0006e	e8 00 00 00 00	 call	 _getToken@4
  00073	89 45 fc	 mov	 DWORD PTR _accessToken$[ebp], eax

; 3305 : 
; 3306 : 	if (!accessToken)

  00076	83 7d fc 00	 cmp	 DWORD PTR _accessToken$[ebp], 0
  0007a	75 02		 jne	 SHORT $LN3@IsVolumeAc

; 3307 : 		goto ret;

  0007c	eb 58		 jmp	 SHORT $ret$31765
$LN3@IsVolumeAc:

; 3308 : 	
; 3309 : 	if (SeTokenIsAdmin (accessToken))

  0007e	8b 45 fc	 mov	 eax, DWORD PTR _accessToken$[ebp]
  00081	50		 push	 eax
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeTokenIsAdmin@4
  00088	0f b6 c8	 movzx	 ecx, al
  0008b	85 c9		 test	 ecx, ecx
  0008d	74 09		 je	 SHORT $LN2@IsVolumeAc

; 3310 : 	{
; 3311 : 		result = TRUE;

  0008f	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _result$[ebp], 1

; 3312 : 		goto ret;

  00096	eb 3e		 jmp	 SHORT $ret$31765
$LN2@IsVolumeAc:

; 3313 : 	}
; 3314 : 
; 3315 : 	if (!NT_SUCCESS (SeQueryInformationToken (accessToken, TokenUser, &tokenUser)))

  00098	8d 55 e8	 lea	 edx, DWORD PTR _tokenUser$[ebp]
  0009b	52		 push	 edx
  0009c	6a 01		 push	 1
  0009e	8b 45 fc	 mov	 eax, DWORD PTR _accessToken$[ebp]
  000a1	50		 push	 eax
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeQueryInformationToken@12
  000a8	85 c0		 test	 eax, eax
  000aa	7d 02		 jge	 SHORT $LN1@IsVolumeAc

; 3316 : 		goto ret;

  000ac	eb 28		 jmp	 SHORT $ret$31765
$LN1@IsVolumeAc:

; 3317 : 
; 3318 : 	result = RtlEqualSid (volumeDeviceExtension->UserSid, tokenUser->User.Sid);

  000ae	8b 4d e8	 mov	 ecx, DWORD PTR _tokenUser$[ebp]
  000b1	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b3	52		 push	 edx
  000b4	8b 45 08	 mov	 eax, DWORD PTR _volumeDeviceExtension$[ebp]
  000b7	8b 88 cc 04 00
	00		 mov	 ecx, DWORD PTR [eax+1228]
  000bd	51		 push	 ecx
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEqualSid@8
  000c4	0f b6 d0	 movzx	 edx, al
  000c7	89 55 e4	 mov	 DWORD PTR _result$[ebp], edx

; 3319 : 	ExFreePool (tokenUser);		// Documented in newer versions of WDK

  000ca	6a 00		 push	 0
  000cc	8b 45 e8	 mov	 eax, DWORD PTR _tokenUser$[ebp]
  000cf	50		 push	 eax
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$ret$31765:

; 3320 : 
; 3321 : ret:
; 3322 : 	SeUnlockSubjectContext(&subContext);

  000d6	8d 4d ec	 lea	 ecx, DWORD PTR _subContext$[ebp]
  000d9	51		 push	 ecx
  000da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeUnlockSubjectContext@4

; 3323 : 	SeReleaseSubjectContext (&subContext);

  000e0	8d 55 ec	 lea	 edx, DWORD PTR _subContext$[ebp]
  000e3	52		 push	 edx
  000e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeReleaseSubjectContext@4

; 3324 : 	return result;

  000ea	8b 45 e4	 mov	 eax, DWORD PTR _result$[ebp]
$LN6@IsVolumeAc:

; 3325 : }

  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c2 04 00	 ret	 4
_IsVolumeAccessibleByCurrentUser@4 ENDP
_TEXT	ENDS
PUBLIC	_GetElapsedTimeInit@4
EXTRN	__imp__KeQueryPerformanceCounter@4:PROC
; Function compile flags: /Odtp
;	COMDAT _GetElapsedTimeInit@4
_TEXT	SEGMENT
_lastPerfCounter$ = 8					; size = 4
_GetElapsedTimeInit@4 PROC				; COMDAT

; 3329 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 3330 : 	*lastPerfCounter = KeQueryPerformanceCounter (NULL);

  00005	6a 00		 push	 0
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeQueryPerformanceCounter@4
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _lastPerfCounter$[ebp]
  00010	89 01		 mov	 DWORD PTR [ecx], eax
  00012	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 3331 : }

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
_GetElapsedTimeInit@4 ENDP
_TEXT	ENDS
PUBLIC	_GetElapsedTime@4
EXTRN	__alldiv:PROC
; Function compile flags: /Odtp
;	COMDAT _GetElapsedTime@4
_TEXT	SEGMENT
_counter$ = -24						; size = 8
_elapsed$ = -16						; size = 8
_freq$ = -8						; size = 8
_lastPerfCounter$ = 8					; size = 4
_GetElapsedTime@4 PROC					; COMDAT

; 3336 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 18	 sub	 esp, 24			; 00000018H

; 3337 : 	LARGE_INTEGER freq;
; 3338 : 	LARGE_INTEGER counter = KeQueryPerformanceCounter (&freq);

  00008	8d 45 f8	 lea	 eax, DWORD PTR _freq$[ebp]
  0000b	50		 push	 eax
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeQueryPerformanceCounter@4
  00012	89 45 e8	 mov	 DWORD PTR _counter$[ebp], eax
  00015	89 55 ec	 mov	 DWORD PTR _counter$[ebp+4], edx

; 3339 : 
; 3340 : 	int64 elapsed = (counter.QuadPart - lastPerfCounter->QuadPart) * 1000000LL / freq.QuadPart;

  00018	8b 4d 08	 mov	 ecx, DWORD PTR _lastPerfCounter$[ebp]
  0001b	8b 55 e8	 mov	 edx, DWORD PTR _counter$[ebp]
  0001e	2b 11		 sub	 edx, DWORD PTR [ecx]
  00020	8b 45 ec	 mov	 eax, DWORD PTR _counter$[ebp+4]
  00023	1b 41 04	 sbb	 eax, DWORD PTR [ecx+4]
  00026	6a 00		 push	 0
  00028	68 40 42 0f 00	 push	 1000000			; 000f4240H
  0002d	50		 push	 eax
  0002e	52		 push	 edx
  0002f	e8 00 00 00 00	 call	 __allmul
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _freq$[ebp+4]
  00037	51		 push	 ecx
  00038	8b 4d f8	 mov	 ecx, DWORD PTR _freq$[ebp]
  0003b	51		 push	 ecx
  0003c	52		 push	 edx
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 __alldiv
  00043	89 45 f0	 mov	 DWORD PTR _elapsed$[ebp], eax
  00046	89 55 f4	 mov	 DWORD PTR _elapsed$[ebp+4], edx

; 3341 : 	*lastPerfCounter = counter;

  00049	8b 55 08	 mov	 edx, DWORD PTR _lastPerfCounter$[ebp]
  0004c	8b 45 e8	 mov	 eax, DWORD PTR _counter$[ebp]
  0004f	89 02		 mov	 DWORD PTR [edx], eax
  00051	8b 4d ec	 mov	 ecx, DWORD PTR _counter$[ebp+4]
  00054	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 3342 : 
; 3343 : 	return elapsed;

  00057	8b 45 f0	 mov	 eax, DWORD PTR _elapsed$[ebp]
  0005a	8b 55 f4	 mov	 edx, DWORD PTR _elapsed$[ebp+4]

; 3344 : }

  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
_GetElapsedTime@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@JBJOLBIB@OsMajorVersion?5?$CB?$DN?50?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0BE@JBJOLBIB@OsMajorVersion?5?$CB?$DN?50?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BE@JBJOLBIB@OsMajorVersion?5?$CB?$DN?50?$AA@FNODOBFM@ DB 'OsMajorV'
	DB	'ersion != 0', 00H				;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _IsOSAtLeast@4
_TEXT	SEGMENT
tv70 = -16						; size = 4
tv69 = -12						; size = 4
_major$ = -8						; size = 4
_minor$ = -4						; size = 4
_reqMinOS$ = 8						; size = 4
_IsOSAtLeast@4 PROC					; COMDAT

; 3348 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 10	 sub	 esp, 16			; 00000010H

; 3349 : 	/* When updating this function, update IsOSVersionAtLeast() in Dlgcode.c too. */
; 3350 : 
; 3351 : 	ULONG major = 0, minor = 0;

  00008	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _major$[ebp], 0
  0000f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _minor$[ebp], 0

; 3352 : 
; 3353 : 	ASSERT (OsMajorVersion != 0);

  00016	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _OsMajorVersion, 0
  0001d	75 20		 jne	 SHORT $LN13@IsOSAtLeas
  0001f	6a 00		 push	 0
  00021	68 19 0d 00 00	 push	 3353			; 00000d19H
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JBJOLBIB@OsMajorVersion?5?$CB?$DN?50?$AA@FNODOBFM@
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  00036	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  0003d	eb 07		 jmp	 SHORT $LN14@IsOSAtLeas
$LN13@IsOSAtLeas:
  0003f	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
$LN14@IsOSAtLeas:

; 3354 : 
; 3355 : 	switch (reqMinOS)

  00046	8b 45 08	 mov	 eax, DWORD PTR _reqMinOS$[ebp]
  00049	89 45 f0	 mov	 DWORD PTR tv70[ebp], eax
  0004c	8b 4d f0	 mov	 ecx, DWORD PTR tv70[ebp]
  0004f	83 e9 07	 sub	 ecx, 7
  00052	89 4d f0	 mov	 DWORD PTR tv70[ebp], ecx
  00055	83 7d f0 0c	 cmp	 DWORD PTR tv70[ebp], 12	; 0000000cH
  00059	77 7a		 ja	 SHORT $LN1@IsOSAtLeas
  0005b	8b 55 f0	 mov	 edx, DWORD PTR tv70[ebp]
  0005e	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN15@IsOSAtLeas[edx*4]
$LN8@IsOSAtLeas:

; 3356 : 	{
; 3357 : 	case WIN_2000:			major = 5; minor = 0; break;

  00065	c7 45 f8 05 00
	00 00		 mov	 DWORD PTR _major$[ebp], 5
  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _minor$[ebp], 0
  00073	eb 76		 jmp	 SHORT $LN9@IsOSAtLeas
$LN7@IsOSAtLeas:

; 3358 : 	case WIN_XP:			major = 5; minor = 1; break;

  00075	c7 45 f8 05 00
	00 00		 mov	 DWORD PTR _major$[ebp], 5
  0007c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _minor$[ebp], 1
  00083	eb 66		 jmp	 SHORT $LN9@IsOSAtLeas
$LN6@IsOSAtLeas:

; 3359 : 	case WIN_SERVER_2003:	major = 5; minor = 2; break;

  00085	c7 45 f8 05 00
	00 00		 mov	 DWORD PTR _major$[ebp], 5
  0008c	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR _minor$[ebp], 2
  00093	eb 56		 jmp	 SHORT $LN9@IsOSAtLeas
$LN5@IsOSAtLeas:

; 3360 : 	case WIN_VISTA:			major = 6; minor = 0; break;

  00095	c7 45 f8 06 00
	00 00		 mov	 DWORD PTR _major$[ebp], 6
  0009c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _minor$[ebp], 0
  000a3	eb 46		 jmp	 SHORT $LN9@IsOSAtLeas
$LN4@IsOSAtLeas:

; 3361 : 	case WIN_7:				major = 6; minor = 1; break;

  000a5	c7 45 f8 06 00
	00 00		 mov	 DWORD PTR _major$[ebp], 6
  000ac	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _minor$[ebp], 1
  000b3	eb 36		 jmp	 SHORT $LN9@IsOSAtLeas
$LN3@IsOSAtLeas:

; 3362 : 	case WIN_8:				major = 6; minor = 2; break;

  000b5	c7 45 f8 06 00
	00 00		 mov	 DWORD PTR _major$[ebp], 6
  000bc	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR _minor$[ebp], 2
  000c3	eb 26		 jmp	 SHORT $LN9@IsOSAtLeas
$LN2@IsOSAtLeas:

; 3363 : 	case WIN_10:			major = 6; minor = 4; break;

  000c5	c7 45 f8 06 00
	00 00		 mov	 DWORD PTR _major$[ebp], 6
  000cc	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR _minor$[ebp], 4
  000d3	eb 16		 jmp	 SHORT $LN9@IsOSAtLeas
$LN1@IsOSAtLeas:

; 3364 : 
; 3365 : 	default:
; 3366 : 		TC_THROW_FATAL_EXCEPTION;

  000d5	68 43 54 00 00	 push	 21571			; 00005443H
  000da	6a 00		 push	 0
  000dc	6a 00		 push	 0
  000de	68 26 0d 00 00	 push	 3366			; 00000d26H
  000e3	6a 29		 push	 41			; 00000029H
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN9@IsOSAtLeas:

; 3367 : 		break;
; 3368 : 	}
; 3369 : 
; 3370 : 	return ((OsMajorVersion << 16 | OsMinorVersion << 8)
; 3371 : 		>= (major << 16 | minor << 8));

  000eb	a1 00 00 00 00	 mov	 eax, DWORD PTR _OsMajorVersion
  000f0	c1 e0 10	 shl	 eax, 16			; 00000010H
  000f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _OsMinorVersion
  000f9	c1 e1 08	 shl	 ecx, 8
  000fc	0b c1		 or	 eax, ecx
  000fe	8b 55 f8	 mov	 edx, DWORD PTR _major$[ebp]
  00101	c1 e2 10	 shl	 edx, 16			; 00000010H
  00104	8b 4d fc	 mov	 ecx, DWORD PTR _minor$[ebp]
  00107	c1 e1 08	 shl	 ecx, 8
  0010a	0b d1		 or	 edx, ecx
  0010c	3b c2		 cmp	 eax, edx
  0010e	1b c0		 sbb	 eax, eax
  00110	83 c0 01	 add	 eax, 1
$LN12@IsOSAtLeas:

; 3372 : }

  00113	8b e5		 mov	 esp, ebp
  00115	5d		 pop	 ebp
  00116	c2 04 00	 ret	 4
  00119	8d 49 00	 npad	 3
$LN15@IsOSAtLeas:
  0011c	00 00 00 00	 DD	 $LN8@IsOSAtLeas
  00120	00 00 00 00	 DD	 $LN7@IsOSAtLeas
  00124	00 00 00 00	 DD	 $LN1@IsOSAtLeas
  00128	00 00 00 00	 DD	 $LN6@IsOSAtLeas
  0012c	00 00 00 00	 DD	 $LN5@IsOSAtLeas
  00130	00 00 00 00	 DD	 $LN1@IsOSAtLeas
  00134	00 00 00 00	 DD	 $LN4@IsOSAtLeas
  00138	00 00 00 00	 DD	 $LN1@IsOSAtLeas
  0013c	00 00 00 00	 DD	 $LN3@IsOSAtLeas
  00140	00 00 00 00	 DD	 $LN1@IsOSAtLeas
  00144	00 00 00 00	 DD	 $LN1@IsOSAtLeas
  00148	00 00 00 00	 DD	 $LN1@IsOSAtLeas
  0014c	00 00 00 00	 DD	 $LN2@IsOSAtLeas
_IsOSAtLeast@4 ENDP
_TEXT	ENDS
END
