; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\Public\Desktop\projects\ciphershed\src\Common\Password.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_RtlSecureZeroMemory
; Function compile flags: /Ogtpy
; File c:\program files\microsoft sdks\windows\v7.0\include\winnt.h
;	COMDAT _RtlSecureZeroMemory
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory PROC				; COMDAT

; 13070:     volatile char *vptr = (volatile char *)ptr;
; 13071: 
; 13072: #if defined(_M_AMD64)
; 13073: 
; 13074:         __stosb((PBYTE )((DWORD64)vptr), 0, cnt);
; 13075: 
; 13076: #else
; 13077: 
; 13078:     while (cnt) {

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _cnt$[esp-4]
  00004	8b 44 24 04	 mov	 eax, DWORD PTR _ptr$[esp-4]
  00008	8b c8		 mov	 ecx, eax
  0000a	85 d2		 test	 edx, edx
  0000c	74 0b		 je	 SHORT $LN1@RtlSecureZ
  0000e	8b ff		 npad	 2
$LL2@RtlSecureZ:

; 13079:         *vptr = 0;

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 13080:         vptr++;

  00013	41		 inc	 ecx

; 13081:         cnt--;

  00014	83 ea 01	 sub	 edx, 1
  00017	75 f7		 jne	 SHORT $LL2@RtlSecureZ
$LN1@RtlSecureZ:

; 13082:     }
; 13083: 
; 13084: #endif
; 13085: 
; 13086:     return ptr;
; 13087: }

  00019	c3		 ret	 0
_RtlSecureZeroMemory ENDP
_TEXT	ENDS
PUBLIC	_ConvertUTF16toUTF8s
EXTRN	_ConvertUTF16toUTF8:PROC
; Function compile flags: /Ogtpy
; File c:\users\public\desktop\projects\ciphershed\src\common\util\unicode\convertutf.h
;	COMDAT _ConvertUTF16toUTF8s
_TEXT	SEGMENT
_sourceStart$ = 8					; size = 4
_sourceLength$ = 12					; size = 4
_targetStart$ = 16					; size = 4
_targetLength$ = 20					; size = 4
_flags$ = 24						; size = 4
_ConvertUTF16toUTF8s PROC				; COMDAT

; 172  : 	return ConvertUTF16toUTF8(&sourceStart, sourceStart+sizeof(*sourceStart)*sourceLength, &targetStart, targetStart+sizeof(*targetStart)*targetLength, flags);

  00000	8b 44 24 14	 mov	 eax, DWORD PTR _flags$[esp-4]
  00004	8b 4c 24 10	 mov	 ecx, DWORD PTR _targetLength$[esp-4]
  00008	8b 54 24 0c	 mov	 edx, DWORD PTR _targetStart$[esp-4]
  0000c	50		 push	 eax
  0000d	03 d1		 add	 edx, ecx
  0000f	8b 4c 24 0c	 mov	 ecx, DWORD PTR _sourceLength$[esp]
  00013	52		 push	 edx
  00014	8b 54 24 0c	 mov	 edx, DWORD PTR _sourceStart$[esp+4]
  00018	8d 44 24 14	 lea	 eax, DWORD PTR _targetStart$[esp+4]
  0001c	50		 push	 eax
  0001d	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00020	50		 push	 eax
  00021	8d 4c 24 14	 lea	 ecx, DWORD PTR _sourceStart$[esp+12]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 _ConvertUTF16toUTF8
  0002b	83 c4 14	 add	 esp, 20			; 00000014H

; 173  : }

  0002e	c3		 ret	 0
_ConvertUTF16toUTF8s ENDP
_TEXT	ENDS
PUBLIC	_strlenw
; Function compile flags: /Ogtpy
; File c:\users\public\desktop\projects\ciphershed\src\common\password.c
;	COMDAT _strlenw
_TEXT	SEGMENT
_s$ = 8							; size = 4
_strlenw PROC						; COMDAT

; 40   : 	int len=0;
; 41   : 	if (!s) return 0;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _s$[esp-4]
  00004	33 c0		 xor	 eax, eax
  00006	85 c9		 test	 ecx, ecx
  00008	75 01		 jne	 SHORT $LN6@strlenw

; 43   : 	return len;
; 44   : }

  0000a	c3		 ret	 0
$LN6@strlenw:

; 42   : 	while (*s++) ++len;

  0000b	66 39 01	 cmp	 WORD PTR [ecx], ax
  0000e	74 0a		 je	 SHORT $LN4@strlenw
$LL2@strlenw:
  00010	83 c1 02	 add	 ecx, 2
  00013	40		 inc	 eax
  00014	66 83 39 00	 cmp	 WORD PTR [ecx], 0
  00018	75 f6		 jne	 SHORT $LL2@strlenw
$LN4@strlenw:

; 43   : 	return len;
; 44   : }

  0001a	c3		 ret	 0
_strlenw ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_CheckPasswordCharEncoding
EXTRN	__imp__GetWindowTextW@12:PROC
EXTRN	__imp__GetWindowTextLengthW@4:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT _CheckPasswordCharEncoding
_TEXT	SEGMENT
_s$80757 = -136						; size = 130
__$ArrayPad$ = -4					; size = 4
_hPassword$ = 8						; size = 4
_ptrPw$ = 12						; size = 4
_CheckPasswordCharEncoding PROC				; COMDAT

; 47   : {

  00000	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 84 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+136], eax
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	8b b4 24 94 00
	00 00		 mov	 esi, DWORD PTR _hPassword$[esp+140]

; 48   : 	int i, len;
; 49   : 
; 50   : 	//It would not make sense to have both parameters specified.
; 51   : 	if (hPassword!=NULL && ptrPw!=NULL)

  0001d	85 f6		 test	 esi, esi
  0001f	74 23		 je	 SHORT $LN40@CheckPassw
  00021	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR _ptrPw$[esp+140], 0
  00029	74 4e		 je	 SHORT $LN20@CheckPassw
$LN46@CheckPassw:
  0002b	5e		 pop	 esi

; 52   : 	{
; 53   : 		return FALSE;

  0002c	33 c0		 xor	 eax, eax
  0002e	5b		 pop	 ebx

; 117  : }

  0002f	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+136]
  00036	33 cc		 xor	 ecx, esp
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	81 c4 88 00 00
	00		 add	 esp, 136		; 00000088H
  00043	c3		 ret	 0
$LN40@CheckPassw:

; 54   : 	}
; 55   : 
; 56   : 	if (hPassword==NULL && ptrPw==NULL)

  00044	8b b4 24 98 00
	00 00		 mov	 esi, DWORD PTR _ptrPw$[esp+140]
  0004b	85 f6		 test	 esi, esi

; 57   : 	{
; 58   : 		return FALSE;

  0004d	74 dc		 je	 SHORT $LN46@CheckPassw

; 59   : 	}
; 60   : 
; 61   : 	if (hPassword == NULL)
; 62   : 	{
; 63   : 		unsigned char *pw;
; 64   : 		len = ptrPw->Length;

  0004f	8b 16		 mov	 edx, DWORD PTR [esi]

; 65   : 
; 66   : 		if (len>=sizeof(ptrPw->Text))
; 67   : 		{
; 68   : 			return FALSE;

  00051	33 c0		 xor	 eax, eax
  00053	83 fa 41	 cmp	 edx, 65			; 00000041H
  00056	0f 83 8b 00 00
	00		 jae	 $LN23@CheckPassw

; 69   : 		}
; 70   : 
; 71   : 		pw = (unsigned char *) ptrPw->Text;
; 72   : 
; 73   : 		for (i = 0; i < len; i++)

  0005c	85 d2		 test	 edx, edx
  0005e	0f 8e 7e 00 00
	00		 jle	 $LN1@CheckPassw
$LL18@CheckPassw:

; 74   : 		{
; 75   : 			//for i in `seq 32 126`; do printf "\x$(printf %x $i) "; done
; 76   : 			if (pw[i] >= 0x7f || pw[i] < 0x20)	// A non-ASCII or non-printable character?

  00064	8a 4c 30 04	 mov	 cl, BYTE PTR [eax+esi+4]
  00068	80 f9 7f	 cmp	 cl, 127			; 0000007fH
  0006b	73 be		 jae	 SHORT $LN46@CheckPassw
  0006d	80 f9 20	 cmp	 cl, 32			; 00000020H
  00070	72 b9		 jb	 SHORT $LN46@CheckPassw
  00072	40		 inc	 eax
  00073	3b c2		 cmp	 eax, edx
  00075	7c ed		 jl	 SHORT $LL18@CheckPassw

; 103  : 		{
; 104  : 			if (s[i] >= 0x7f || s[i] < 0x20)	// A non-ASCII or non-printable character?

  00077	eb 69		 jmp	 SHORT $LN1@CheckPassw
$LN20@CheckPassw:

; 77   : 			{
; 78   : 				return FALSE;
; 79   : 			}
; 80   : 		}
; 81   : 	}
; 82   : 	else
; 83   : 	{
; 84   : 		wchar_t s[MAX_PASSWORD + 1];
; 85   : 		// Below GetWindowTextW is called, ensure the same suffix functionis called 
; 86   : 		// GetWindowTextLength may be defined as GetWindowTextLengthA which would at 
; 87   : 		// best return double the length
; 88   : 		len = GetWindowTextLengthW (hPassword);

  00079	56		 push	 esi
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextLengthW@4
  00080	8b d8		 mov	 ebx, eax

; 89   : 
; 90   : 		// this is disingenuous here, because the GetWindowTextLength function docs say to use strlen 
; 91   : 		// on the return from GetWindowText because GetWindowTextLength >= strlen
; 92   : 		//
; 93   : 		// This check should happen after GetWindowText
; 94   : 		// len=strlen(s)
; 95   : 		if (len > MAX_PASSWORD)

  00082	83 fb 40	 cmp	 ebx, 64			; 00000040H

; 96   : 		{
; 97   : 			return FALSE; 

  00085	7f a4		 jg	 SHORT $LN46@CheckPassw
  00087	57		 push	 edi

; 98   : 		}
; 99   : 
; 100  : 		GetWindowTextW (hPassword, s, sizeof (s) / sizeof (wchar_t));

  00088	6a 41		 push	 65			; 00000041H
  0008a	8d 44 24 10	 lea	 eax, DWORD PTR _s$80757[esp+152]
  0008e	50		 push	 eax
  0008f	56		 push	 esi
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextW@12

; 101  : 
; 102  : 		for (i = 0; i < len; i++)

  00096	33 ff		 xor	 edi, edi
  00098	85 db		 test	 ebx, ebx
  0009a	7e 1a		 jle	 SHORT $LN6@CheckPassw
  0009c	8d 64 24 00	 npad	 4
$LL11@CheckPassw:

; 103  : 		{
; 104  : 			if (s[i] >= 0x7f || s[i] < 0x20)	// A non-ASCII or non-printable character?

  000a0	0f b7 44 7c 0c	 movzx	 eax, WORD PTR _s$80757[esp+edi*2+148]
  000a5	66 83 f8 7f	 cmp	 ax, 127			; 0000007fH
  000a9	73 0b		 jae	 SHORT $LN6@CheckPassw
  000ab	66 83 f8 20	 cmp	 ax, 32			; 00000020H
  000af	72 05		 jb	 SHORT $LN6@CheckPassw
  000b1	47		 inc	 edi
  000b2	3b fb		 cmp	 edi, ebx
  000b4	7c ea		 jl	 SHORT $LL11@CheckPassw
$LN6@CheckPassw:

; 105  : 				break;
; 106  : 		}
; 107  : 
; 108  : 		burn (s, sizeof(s));

  000b6	8d 54 24 0c	 lea	 edx, DWORD PTR _s$80757[esp+148]
  000ba	b9 82 00 00 00	 mov	 ecx, 130		; 00000082H
  000bf	8b f1		 mov	 esi, ecx
  000c1	8b c2		 mov	 eax, edx
$LL26@CheckPassw:
  000c3	c6 00 00	 mov	 BYTE PTR [eax], 0
  000c6	40		 inc	 eax
  000c7	83 ee 01	 sub	 esi, 1
  000ca	75 f7		 jne	 SHORT $LL26@CheckPassw
  000cc	8d 64 24 00	 npad	 4
$LL3@CheckPassw:
  000d0	49		 dec	 ecx
  000d1	c6 02 00	 mov	 BYTE PTR [edx], 0
  000d4	42		 inc	 edx
  000d5	85 c9		 test	 ecx, ecx
  000d7	75 f7		 jne	 SHORT $LL3@CheckPassw

; 109  : 
; 110  : 		if (i < len)

  000d9	3b fb		 cmp	 edi, ebx
  000db	5f		 pop	 edi

; 111  : 		{
; 112  : 			return FALSE; 

  000dc	0f 8c 49 ff ff
	ff		 jl	 $LN46@CheckPassw
$LN1@CheckPassw:

; 113  : 		}
; 114  : 	}
; 115  : 
; 116  : 	return TRUE;

  000e2	b8 01 00 00 00	 mov	 eax, 1
$LN23@CheckPassw:

; 117  : }

  000e7	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+144]
  000ee	5e		 pop	 esi
  000ef	5b		 pop	 ebx
  000f0	33 cc		 xor	 ecx, esp
  000f2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f7	81 c4 88 00 00
	00		 add	 esp, 136		; 00000088H
  000fd	c3		 ret	 0
_CheckPasswordCharEncoding ENDP
_TEXT	ENDS
PUBLIC	_szVerify$GSCopy$
PUBLIC	_hButton$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_VerifyPasswordAndUpdate2
EXTRN	__imp__EnableWindow@8:PROC
EXTRN	_strcmpw:PROC
; Function compile flags: /Ogtpy
;	COMDAT _VerifyPasswordAndUpdate2
_TEXT	SEGMENT
_szVerify$GSCopy$ = -288				; size = 4
$T81087 = -288						; size = 4
$T81086 = -284						; size = 4
_hButton$GSCopy$ = -280					; size = 4
$T81073 = -276						; size = 4
$T81074 = -272						; size = 4
_szTmp1$ = -268						; size = 130
_szTmp2$ = -136						; size = 130
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_hButton$ = 12						; size = 4
_hPassword$ = 16					; size = 4
_hVerify$ = 20						; size = 4
_szPassword$ = 24					; size = 4
_sizeOfPassword$ = 28					; size = 4
_szVerify$ = 32						; size = 4
_sizeOfVerify$ = 36					; size = 4
_keyFilesEnabled$ = 40					; size = 4
_VerifyPasswordAndUpdate2 PROC				; COMDAT

; 126  : {

  00000	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 1c 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+288], eax
  00014	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR _hButton$[esp+284]
  0001b	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR _szVerify$[esp+284]
  00022	53		 push	 ebx
  00023	55		 push	 ebp
  00024	8b ac 24 3c 01
	00 00		 mov	 ebp, DWORD PTR _szPassword$[esp+292]
  0002b	56		 push	 esi
  0002c	8b b4 24 38 01
	00 00		 mov	 esi, DWORD PTR _hPassword$[esp+296]
  00033	57		 push	 edi
  00034	8b bc 24 40 01
	00 00		 mov	 edi, DWORD PTR _hVerify$[esp+300]

; 127  : 	WCHAR szTmp1[MAX_PASSWORD + 1];
; 128  : 	WCHAR szTmp2[MAX_PASSWORD + 1];
; 129  : 	int k = GetWindowTextLengthW(hPassword);

  0003b	56		 push	 esi

; 152  : 		r=ConvertUTF16toUTF8s(szTmp1,len+1,szPassword,sizeOfPassword,strictConversion);

  0003c	89 44 24 1c	 mov	 DWORD PTR _hButton$GSCopy$[esp+308], eax
  00040	89 4c 24 14	 mov	 DWORD PTR _szVerify$GSCopy$[esp+308], ecx
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextLengthW@4
  0004a	6a 41		 push	 65			; 00000041H
  0004c	8d 54 24 28	 lea	 edx, DWORD PTR _szTmp1$[esp+308]
  00050	52		 push	 edx
  00051	56		 push	 esi
  00052	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetWindowTextW@12
  00058	8b d8		 mov	 ebx, eax
  0005a	ff d6		 call	 esi
  0005c	6a 41		 push	 65			; 00000041H
  0005e	8d 84 24 ac 00
	00 00		 lea	 eax, DWORD PTR _szTmp2$[esp+308]
  00065	50		 push	 eax
  00066	57		 push	 edi
  00067	ff d6		 call	 esi
  00069	8d 8c 24 a8 00
	00 00		 lea	 ecx, DWORD PTR _szTmp2$[esp+304]
  00070	51		 push	 ecx
  00071	8d 54 24 28	 lea	 edx, DWORD PTR _szTmp1$[esp+308]
  00075	52		 push	 edx
  00076	e8 00 00 00 00	 call	 _strcmpw
  0007b	83 c4 08	 add	 esp, 8
  0007e	85 c0		 test	 eax, eax
  00080	74 04		 je	 SHORT $LN19@VerifyPass

; 130  : 	BOOL bEnable = FALSE;
; 131  : 	int len;
; 132  : 	int r;
; 133  : 
; 134  : 	if (hwndDlg);		/* Remove warning */
; 135  : 
; 136  : 	GetWindowTextW(hPassword, szTmp1, sizeof (szTmp1)/sizeof(*szTmp1));
; 137  : 	GetWindowTextW(hVerify, szTmp2, sizeof (szTmp2)/sizeof(*szTmp2));
; 138  : 
; 139  : 	if (strcmpw (szTmp1, szTmp2) != 0)
; 140  : 		bEnable = FALSE;

  00082	33 ff		 xor	 edi, edi

; 141  : 	else

  00084	eb 18		 jmp	 SHORT $LN15@VerifyPass
$LN19@VerifyPass:

; 142  : 	{
; 143  : 		if (k >= MIN_PASSWORD || keyFilesEnabled)

  00086	83 fb 01	 cmp	 ebx, 1
  00089	7d 0e		 jge	 SHORT $LN16@VerifyPass
  0008b	83 bc 24 54 01
	00 00 00	 cmp	 DWORD PTR _keyFilesEnabled$[esp+300], 0
  00093	75 04		 jne	 SHORT $LN16@VerifyPass

; 145  : 		else
; 146  : 			bEnable = FALSE;

  00095	33 ff		 xor	 edi, edi
  00097	eb 05		 jmp	 SHORT $LN15@VerifyPass
$LN16@VerifyPass:

; 144  : 			bEnable = TRUE;

  00099	bf 01 00 00 00	 mov	 edi, 1
$LN15@VerifyPass:

; 147  : 	}
; 148  : 
; 149  : 	if (szPassword != NULL)

  0009e	85 ed		 test	 ebp, ebp
  000a0	74 4d		 je	 SHORT $LN70@VerifyPass

; 150  : 	{
; 151  : 		len=strlenw(szTmp1);

  000a2	33 c9		 xor	 ecx, ecx
  000a4	8d 44 24 24	 lea	 eax, DWORD PTR _szTmp1$[esp+304]
  000a8	66 39 4c 24 24	 cmp	 WORD PTR _szTmp1$[esp+304], cx
  000ad	74 0b		 je	 SHORT $LN69@VerifyPass
  000af	90		 npad	 1
$LL24@VerifyPass:
  000b0	83 c0 02	 add	 eax, 2
  000b3	41		 inc	 ecx
  000b4	66 83 38 00	 cmp	 WORD PTR [eax], 0
  000b8	75 f6		 jne	 SHORT $LL24@VerifyPass
$LN69@VerifyPass:

; 152  : 		r=ConvertUTF16toUTF8s(szTmp1,len+1,szPassword,sizeOfPassword,strictConversion);

  000ba	8b 94 24 48 01
	00 00		 mov	 edx, DWORD PTR _sizeOfPassword$[esp+300]
  000c1	6a 00		 push	 0
  000c3	89 6c 24 24	 mov	 DWORD PTR $T81074[esp+308], ebp
  000c7	8d 44 24 28	 lea	 eax, DWORD PTR _szTmp1$[esp+308]
  000cb	03 ea		 add	 ebp, edx
  000cd	89 44 24 20	 mov	 DWORD PTR $T81073[esp+308], eax
  000d1	55		 push	 ebp
  000d2	8d 44 24 28	 lea	 eax, DWORD PTR $T81074[esp+312]
  000d6	50		 push	 eax

; 153  : 		if (r!=conversionOK) bEnable=FALSE;

  000d7	8d 4c 8c 34	 lea	 ecx, DWORD PTR _szTmp1$[esp+ecx*4+320]
  000db	51		 push	 ecx
  000dc	8d 54 24 2c	 lea	 edx, DWORD PTR $T81073[esp+320]
  000e0	52		 push	 edx
  000e1	e8 00 00 00 00	 call	 _ConvertUTF16toUTF8
  000e6	83 c4 14	 add	 esp, 20			; 00000014H
  000e9	85 c0		 test	 eax, eax
  000eb	74 02		 je	 SHORT $LN70@VerifyPass
  000ed	33 ff		 xor	 edi, edi
$LN70@VerifyPass:

; 154  : 	}
; 155  : 
; 156  : 	if (szVerify != NULL)

  000ef	8b 54 24 10	 mov	 edx, DWORD PTR _szVerify$GSCopy$[esp+304]
  000f3	85 d2		 test	 edx, edx
  000f5	74 5e		 je	 SHORT $LN10@VerifyPass

; 157  : 	{
; 158  : 		len=strlenw(szTmp2);

  000f7	33 c9		 xor	 ecx, ecx
  000f9	8d 84 24 a8 00
	00 00		 lea	 eax, DWORD PTR _szTmp2$[esp+304]
  00100	66 39 8c 24 a8
	00 00 00	 cmp	 WORD PTR _szTmp2$[esp+304], cx
  00108	74 10		 je	 SHORT $LN53@VerifyPass
  0010a	8d 9b 00 00 00
	00		 npad	 6
$LL31@VerifyPass:
  00110	83 c0 02	 add	 eax, 2
  00113	41		 inc	 ecx
  00114	66 83 38 00	 cmp	 WORD PTR [eax], 0
  00118	75 f6		 jne	 SHORT $LL31@VerifyPass
$LN53@VerifyPass:

; 159  : 		r=ConvertUTF16toUTF8s(szTmp2,len+1,(UTF8*)szVerify,sizeOfVerify,strictConversion);

  0011a	8d 84 24 a8 00
	00 00		 lea	 eax, DWORD PTR _szTmp2$[esp+304]
  00121	89 44 24 14	 mov	 DWORD PTR $T81086[esp+304], eax
  00125	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR _sizeOfVerify$[esp+300]
  0012c	89 54 24 10	 mov	 DWORD PTR $T81087[esp+304], edx
  00130	6a 00		 push	 0
  00132	03 d0		 add	 edx, eax
  00134	52		 push	 edx
  00135	8d 54 24 18	 lea	 edx, DWORD PTR $T81087[esp+312]
  00139	52		 push	 edx

; 160  : 		if (r!=conversionOK) bEnable=FALSE;

  0013a	8d 84 8c b8 00
	00 00		 lea	 eax, DWORD PTR _szTmp2$[esp+ecx*4+320]
  00141	50		 push	 eax
  00142	8d 4c 24 24	 lea	 ecx, DWORD PTR $T81086[esp+320]
  00146	51		 push	 ecx
  00147	e8 00 00 00 00	 call	 _ConvertUTF16toUTF8
  0014c	83 c4 14	 add	 esp, 20			; 00000014H
  0014f	85 c0		 test	 eax, eax
  00151	74 02		 je	 SHORT $LN10@VerifyPass
  00153	33 ff		 xor	 edi, edi
$LN10@VerifyPass:

; 161  : 	}
; 162  : 
; 163  : 	//clean up memory which contains passwords or metadata (e.g. length)
; 164  : 	burn (szTmp1, sizeof (szTmp1));

  00155	8d 54 24 24	 lea	 edx, DWORD PTR _szTmp1$[esp+304]
  00159	b9 82 00 00 00	 mov	 ecx, 130		; 00000082H
  0015e	8b f1		 mov	 esi, ecx
  00160	8b c2		 mov	 eax, edx
$LL38@VerifyPass:
  00162	c6 00 00	 mov	 BYTE PTR [eax], 0
  00165	40		 inc	 eax
  00166	83 ee 01	 sub	 esi, 1
  00169	75 f7		 jne	 SHORT $LL38@VerifyPass
  0016b	eb 03 8d 49 00	 npad	 5
$LL7@VerifyPass:
  00170	49		 dec	 ecx
  00171	c6 02 00	 mov	 BYTE PTR [edx], 0
  00174	42		 inc	 edx
  00175	85 c9		 test	 ecx, ecx
  00177	75 f7		 jne	 SHORT $LL7@VerifyPass

; 165  : 	burn (szTmp2, sizeof (szTmp2));

  00179	8d 94 24 a8 00
	00 00		 lea	 edx, DWORD PTR _szTmp2$[esp+304]
  00180	b9 82 00 00 00	 mov	 ecx, 130		; 00000082H
  00185	8b f1		 mov	 esi, ecx
  00187	8b c2		 mov	 eax, edx
  00189	8d a4 24 00 00
	00 00		 npad	 7
$LL42@VerifyPass:
  00190	c6 00 00	 mov	 BYTE PTR [eax], 0
  00193	40		 inc	 eax
  00194	83 ee 01	 sub	 esi, 1
  00197	75 f7		 jne	 SHORT $LL42@VerifyPass
  00199	8d a4 24 00 00
	00 00		 npad	 7
$LL2@VerifyPass:
  001a0	49		 dec	 ecx
  001a1	c6 02 00	 mov	 BYTE PTR [edx], 0
  001a4	42		 inc	 edx
  001a5	85 c9		 test	 ecx, ecx
  001a7	75 f7		 jne	 SHORT $LL2@VerifyPass

; 166  : 	k=0;
; 167  : 	len=0;
; 168  : 
; 169  : 	EnableWindow (hButton, bEnable);

  001a9	8b 54 24 18	 mov	 edx, DWORD PTR _hButton$GSCopy$[esp+304]
  001ad	57		 push	 edi
  001ae	52		 push	 edx
  001af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 170  : }

  001b5	8b 8c 24 2c 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+304]
  001bc	5f		 pop	 edi
  001bd	5e		 pop	 esi
  001be	5d		 pop	 ebp
  001bf	5b		 pop	 ebx
  001c0	33 cc		 xor	 ecx, esp
  001c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c7	81 c4 20 01 00
	00		 add	 esp, 288		; 00000120H
  001cd	c3		 ret	 0
_VerifyPasswordAndUpdate2 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@FPFPGNBO@PASSWORD_LENGTH_WARNING?$AA@	; `string'
PUBLIC	_CheckPasswordLengthAlertTitle
EXTRN	__imp__MessageBoxW@16:PROC
EXTRN	_GetString:PROC
;	COMDAT ??_C@_0BI@FPFPGNBO@PASSWORD_LENGTH_WARNING?$AA@
CONST	SEGMENT
??_C@_0BI@FPFPGNBO@PASSWORD_LENGTH_WARNING?$AA@ DB 'PASSWORD_LENGTH_WARNI'
	DB	'NG', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _CheckPasswordLengthAlertTitle
_TEXT	SEGMENT
_hwndDlg$ = 8						; size = 4
_title$ = 12						; size = 4
_hwndItem$ = 16						; size = 4
_CheckPasswordLengthAlertTitle PROC			; COMDAT

; 179  : {

  00000	56		 push	 esi

; 180  : 	if (hwndDlg==NULL)

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _hwndDlg$[esp]
  00005	85 f6		 test	 esi, esi
  00007	75 04		 jne	 SHORT $LN4@CheckPassw@2
$LN7@CheckPassw@2:

; 181  : 	{
; 182  : 		return FALSE;

  00009	33 c0		 xor	 eax, eax
  0000b	5e		 pop	 esi

; 204  : }

  0000c	c3		 ret	 0
$LN4@CheckPassw@2:

; 183  : 	}
; 184  : 	
; 185  : 	if (hwndItem==NULL)

  0000d	8b 44 24 10	 mov	 eax, DWORD PTR _hwndItem$[esp]
  00011	85 c0		 test	 eax, eax

; 186  : 	{
; 187  : 		return FALSE;

  00013	74 f4		 je	 SHORT $LN7@CheckPassw@2

; 188  : 	}
; 189  : 
; 190  : 	// Again, this is not what this function is for, use strlen on GetWindowText, it 
; 191  : 	// can return a size twice the actual size of the string.
; 192  : 	if (GetWindowTextLengthW (hwndItem) < PASSWORD_LEN_WARNING)

  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextLengthW@4
  0001c	83 f8 14	 cmp	 eax, 20			; 00000014H
  0001f	7d 24		 jge	 SHORT $LN1@CheckPassw@2

; 193  : 	{
; 194  : //DEBUG builds do not have this dialog box prompt, and the function always returns true.
; 195  : #if !defined(_DEBUG) || defined(CS_UNITTESTING)
; 196  : 		// The MessageBoxW function is taking the title bar text from a global var "lpszTitle" in Dlgcode.c
; 197  : 		if (MessageBoxW (hwndDlg, GetString ("PASSWORD_LENGTH_WARNING"), title, MB_YESNO|MB_ICONWARNING|MB_DEFBUTTON2) != IDYES)

  00021	8b 44 24 0c	 mov	 eax, DWORD PTR _title$[esp]
  00025	68 34 01 00 00	 push	 308			; 00000134H
  0002a	50		 push	 eax
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@FPFPGNBO@PASSWORD_LENGTH_WARNING?$AA@
  00030	e8 00 00 00 00	 call	 _GetString
  00035	83 c4 04	 add	 esp, 4
  00038	50		 push	 eax
  00039	56		 push	 esi
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
  00040	83 f8 06	 cmp	 eax, 6

; 198  : 		{
; 199  : 			return FALSE;

  00043	75 c4		 jne	 SHORT $LN7@CheckPassw@2
$LN1@CheckPassw@2:

; 200  : 		}
; 201  : #endif
; 202  : 	}
; 203  : 	return TRUE;

  00045	b8 01 00 00 00	 mov	 eax, 1
  0004a	5e		 pop	 esi

; 204  : }

  0004b	c3		 ret	 0
_CheckPasswordLengthAlertTitle ENDP
_TEXT	ENDS
PUBLIC	_hwndDlg$GSCopy$
PUBLIC	_newPassword$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_ChangePwd
EXTRN	_handleError:PROC
EXTRN	_IsUacSupported:PROC
EXTRN	_UacElevated:DWORD
EXTRN	__imp__SetLastError@4:PROC
EXTRN	_RandStop:PROC
EXTRN	_RemoveFakeDosName:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__SetFileTime@16:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__FlushFileBuffers@4:PROC
EXTRN	_WriteRandomDataToReservedHeaderAreas:PROC
EXTRN	_WriteEffectiveVolumeHeader:PROC
EXTRN	_crypto_close:PROC
EXTRN	_CreateVolumeHeaderInMemory:PROC
EXTRN	_EnableElevatedCursorChange:PROC
EXTRN	_UserEnrichRandomPool:PROC
EXTRN	_NormalCursor:PROC
EXTRN	_RandSetHashFunction:PROC
EXTRN	_ReadVolumeHeader:PROC
EXTRN	_ReadEffectiveVolumeHeader:PROC
EXTRN	__imp__SetFilePointerEx@20:PROC
EXTRN	__imp__GetFileTime@16:PROC
EXTRN	_bPreserveTimestamp:DWORD
EXTRN	_Randinit:PROC
EXTRN	__imp__GetFileSizeEx@8:PROC
EXTRN	_GetPartitionInfo:PROC
EXTRN	__imp__DeviceIoControl@32:PROC
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	_FakeDosNameForDevice:PROC
EXTRN	_strcpy_s:PROC
EXTRN	_CreateFullVolumePath:PROC
EXTRN	_WaitCursor:PROC
EXTRN	_memset:PROC
EXTRN	__allmul:PROC
; Function compile flags: /Ogtpy
;	COMDAT _ChangePwd
_TEXT	SEGMENT
_cryptoInfo$ = -1444					; size = 4
_bDevice$ = -1440					; size = 4
_dev$ = -1436						; size = 4
_hostSize$ = -1432					; size = 8
_headerOffset$ = -1424					; size = 8
_volumeType$ = -1416					; size = 4
_hwndDlg$GSCopy$ = -1412				; size = 4
_ci$ = -1408						; size = 4
_nDosLinkCreated$ = -1404				; size = 4
_bTimeStampValid$ = -1400				; size = 4
_newPassword$GSCopy$ = -1396				; size = 4
_bytesRead$ = -1392					; size = 4
_fileSize$80913 = -1388					; size = 8
_driveInfo$ = -1380					; size = 24
_ftLastAccessTime$ = -1356				; size = 8
_ftCreationTime$ = -1348				; size = 8
_ftLastWriteTime$ = -1340				; size = 8
_dwResult$80904 = -1332					; size = 4
_diskInfo$80903 = -1328					; size = 32
_szDiskFile$ = -1296					; size = 260
_buffer$ = -1036					; size = 512
_szCFDevice$ = -524					; size = 260
_szDosDevice$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_lpszVolume$ = 8					; size = 4
_oldPassword$ = 12					; size = 4
_newPassword$ = 16					; size = 4
_pkcs5$ = 20						; size = 4
_hwndDlg$ = 24						; size = 4
_ChangePwd PROC						; COMDAT

; 207  : {

  00000	81 ec a4 05 00
	00		 sub	 esp, 1444		; 000005a4H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 a0 05
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1444], eax
  00014	8b 84 24 b0 05
	00 00		 mov	 eax, DWORD PTR _newPassword$[esp+1440]

; 208  : 	int nDosLinkCreated = 1, nStatus = ERR_OS_ERROR;

  0001b	8b 8c 24 b8 05
	00 00		 mov	 ecx, DWORD PTR _hwndDlg$[esp+1440]
  00022	53		 push	 ebx
  00023	55		 push	 ebp
  00024	8b ac 24 b0 05
	00 00		 mov	 ebp, DWORD PTR _lpszVolume$[esp+1448]
  0002b	56		 push	 esi

; 209  : 	char szDiskFile[TC_MAX_PATH], szCFDevice[TC_MAX_PATH];
; 210  : 	char szDosDevice[TC_MAX_PATH];
; 211  : 	char buffer[TC_VOLUME_HEADER_EFFECTIVE_SIZE];
; 212  : 	PCRYPTO_INFO cryptoInfo = NULL, ci = NULL;

  0002c	33 db		 xor	 ebx, ebx
  0002e	57		 push	 edi
  0002f	8b bc 24 bc 05
	00 00		 mov	 edi, DWORD PTR _oldPassword$[esp+1456]
  00036	be 01 00 00 00	 mov	 esi, 1
  0003b	89 44 24 40	 mov	 DWORD PTR _newPassword$GSCopy$[esp+1460], eax
  0003f	89 4c 24 30	 mov	 DWORD PTR _hwndDlg$GSCopy$[esp+1460], ecx
  00043	89 74 24 38	 mov	 DWORD PTR _nDosLinkCreated$[esp+1460], esi
  00047	89 5c 24 10	 mov	 DWORD PTR _cryptoInfo$[esp+1460], ebx
  0004b	89 5c 24 34	 mov	 DWORD PTR _ci$[esp+1460], ebx

; 213  : 	void *dev = INVALID_HANDLE_VALUE;

  0004f	c7 44 24 18 ff
	ff ff ff	 mov	 DWORD PTR _dev$[esp+1460], -1

; 214  : 	DWORD dwError;
; 215  : 	DWORD bytesRead;
; 216  : 	BOOL bDevice;
; 217  : 	unsigned __int64 hostSize = 0;
; 218  : 	int volumeType;
; 219  : 	int wipePass;
; 220  : 	FILETIME ftCreationTime;
; 221  : 	FILETIME ftLastWriteTime;
; 222  : 	FILETIME ftLastAccessTime;
; 223  : 	BOOL bTimeStampValid = FALSE;

  00057	89 5c 24 3c	 mov	 DWORD PTR _bTimeStampValid$[esp+1460], ebx

; 224  : 	LARGE_INTEGER headerOffset;
; 225  : 	BOOL backupHeader;
; 226  : 	DISK_GEOMETRY driveInfo;
; 227  : 
; 228  : 	if (oldPassword->Length == 0 || newPassword->Length == 0) return -1;

  0005b	39 1f		 cmp	 DWORD PTR [edi], ebx
  0005d	0f 84 a6 05 00
	00		 je	 $LN63@ChangePwd
  00063	39 18		 cmp	 DWORD PTR [eax], ebx
  00065	0f 84 9e 05 00
	00		 je	 $LN63@ChangePwd

; 229  : 
; 230  : 	WaitCursor ();

  0006b	e8 00 00 00 00	 call	 _WaitCursor

; 231  : 
; 232  : 	CreateFullVolumePath (szDiskFile, lpszVolume, &bDevice);

  00070	8d 54 24 14	 lea	 edx, DWORD PTR _bDevice$[esp+1460]
  00074	52		 push	 edx
  00075	8d 84 24 a8 00
	00 00		 lea	 eax, DWORD PTR _szDiskFile$[esp+1464]
  0007c	55		 push	 ebp
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 _CreateFullVolumePath
  00083	83 c4 0c	 add	 esp, 12			; 0000000cH

; 233  : 
; 234  : 	if (bDevice == FALSE)

  00086	39 5c 24 14	 cmp	 DWORD PTR _bDevice$[esp+1460], ebx
  0008a	75 1f		 jne	 SHORT $LN62@ChangePwd

; 235  : 	{
; 236  : 		strcpy_s (szCFDevice, sizeof(szCFDevice), szDiskFile);

  0008c	8d 8c 24 a4 00
	00 00		 lea	 ecx, DWORD PTR _szDiskFile$[esp+1460]
  00093	51		 push	 ecx
  00094	8d 94 24 ac 03
	00 00		 lea	 edx, DWORD PTR _szCFDevice$[esp+1464]
  0009b	68 04 01 00 00	 push	 260			; 00000104H
  000a0	52		 push	 edx
  000a1	e8 00 00 00 00	 call	 _strcpy_s
  000a6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 237  : 	}
; 238  : 	else

  000a9	eb 2d		 jmp	 SHORT $LN60@ChangePwd
$LN62@ChangePwd:

; 239  : 	{
; 240  : 		nDosLinkCreated = FakeDosNameForDevice (szDiskFile, szDosDevice, szCFDevice, FALSE);

  000ab	53		 push	 ebx
  000ac	8d 84 24 ac 03
	00 00		 lea	 eax, DWORD PTR _szCFDevice$[esp+1464]
  000b3	50		 push	 eax
  000b4	8d 8c 24 b4 04
	00 00		 lea	 ecx, DWORD PTR _szDosDevice$[esp+1468]
  000bb	51		 push	 ecx
  000bc	8d 94 24 b0 00
	00 00		 lea	 edx, DWORD PTR _szDiskFile$[esp+1472]
  000c3	52		 push	 edx
  000c4	e8 00 00 00 00	 call	 _FakeDosNameForDevice
  000c9	83 c4 10	 add	 esp, 16			; 00000010H
  000cc	89 44 24 38	 mov	 DWORD PTR _nDosLinkCreated$[esp+1460], eax

; 241  : 		
; 242  : 		if (nDosLinkCreated != 0)

  000d0	3b c3		 cmp	 eax, ebx
  000d2	0f 85 52 04 00
	00		 jne	 $error$80892
$LN60@ChangePwd:

; 243  : 			goto error;
; 244  : 	}
; 245  : 
; 246  : 	dev = CreateFile (szCFDevice, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);

  000d8	6a 00		 push	 0
  000da	6a 00		 push	 0
  000dc	6a 03		 push	 3
  000de	6a 00		 push	 0
  000e0	6a 03		 push	 3
  000e2	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  000e7	8d 84 24 c0 03
	00 00		 lea	 eax, DWORD PTR _szCFDevice$[esp+1484]
  000ee	50		 push	 eax
  000ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  000f5	8b d8		 mov	 ebx, eax
  000f7	89 5c 24 18	 mov	 DWORD PTR _dev$[esp+1460], ebx

; 247  : 
; 248  : 	if (dev == INVALID_HANDLE_VALUE) 

  000fb	83 fb ff	 cmp	 ebx, -1
  000fe	0f 84 26 04 00
	00		 je	 $error$80892

; 249  : 		goto error;
; 250  : 
; 251  : 	if (bDevice)

  00104	83 7c 24 14 00	 cmp	 DWORD PTR _bDevice$[esp+1460], 0
  00109	0f 84 89 00 00
	00		 je	 $LN58@ChangePwd

; 252  : 	{
; 253  : 		/* This is necessary to determine the hidden volume header offset */
; 254  : 
; 255  : 		if (dev == INVALID_HANDLE_VALUE)
; 256  : 		{
; 257  : 			goto error;
; 258  : 		}
; 259  : 		else
; 260  : 		{
; 261  : 			PARTITION_INFORMATION diskInfo;
; 262  : 			DWORD dwResult;
; 263  : 			BOOL bResult;
; 264  : 
; 265  : 			bResult = DeviceIoControl (dev, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0,
; 266  : 				&driveInfo, sizeof (driveInfo), &dwResult, NULL);

  0010f	6a 00		 push	 0
  00111	8d 8c 24 84 00
	00 00		 lea	 ecx, DWORD PTR _dwResult$80904[esp+1464]
  00118	51		 push	 ecx
  00119	6a 18		 push	 24			; 00000018H
  0011b	8d 54 24 5c	 lea	 edx, DWORD PTR _driveInfo$[esp+1472]
  0011f	52		 push	 edx
  00120	6a 00		 push	 0
  00122	6a 00		 push	 0
  00124	68 00 00 07 00	 push	 458752			; 00070000H
  00129	53		 push	 ebx
  0012a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32

; 267  : 
; 268  : 			if (!bResult)

  00130	85 c0		 test	 eax, eax
  00132	0f 84 f2 03 00
	00		 je	 $error$80892

; 269  : 				goto error;
; 270  : 
; 271  : 			bResult = GetPartitionInfo (lpszVolume, &diskInfo);

  00138	8d 84 24 84 00
	00 00		 lea	 eax, DWORD PTR _diskInfo$80903[esp+1460]
  0013f	50		 push	 eax
  00140	55		 push	 ebp
  00141	e8 00 00 00 00	 call	 _GetPartitionInfo
  00146	83 c4 08	 add	 esp, 8

; 272  : 
; 273  : 			if (bResult)

  00149	85 c0		 test	 eax, eax
  0014b	74 10		 je	 SHORT $LN54@ChangePwd

; 274  : 			{
; 275  : 				hostSize = diskInfo.PartitionLength.QuadPart;

  0014d	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR _diskInfo$80903[esp+1468]
  00154	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR _diskInfo$80903[esp+1472]

; 276  : 			}
; 277  : 			else

  0015b	eb 27		 jmp	 SHORT $LN102@ChangePwd
$LN54@ChangePwd:

; 278  : 			{
; 279  : 				hostSize = driveInfo.Cylinders.QuadPart * driveInfo.BytesPerSector *
; 280  : 					driveInfo.SectorsPerTrack * driveInfo.TracksPerCylinder;

  0015d	8b 44 24 5c	 mov	 eax, DWORD PTR _driveInfo$[esp+1472]
  00161	f7 64 24 60	 mul	 DWORD PTR _driveInfo$[esp+1476]
  00165	8b 4c 24 64	 mov	 ecx, DWORD PTR _driveInfo$[esp+1480]
  00169	6a 00		 push	 0
  0016b	51		 push	 ecx
  0016c	52		 push	 edx
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 __allmul
  00173	8b 4c 24 54	 mov	 ecx, DWORD PTR _driveInfo$[esp+1464]
  00177	51		 push	 ecx
  00178	8b 4c 24 54	 mov	 ecx, DWORD PTR _driveInfo$[esp+1464]
  0017c	51		 push	 ecx
  0017d	52		 push	 edx
  0017e	50		 push	 eax
  0017f	e8 00 00 00 00	 call	 __allmul
$LN102@ChangePwd:
  00184	89 44 24 1c	 mov	 DWORD PTR _hostSize$[esp+1460], eax

; 281  : 			}
; 282  : 
; 283  : 			if (hostSize == 0)

  00188	0b c2		 or	 eax, edx
  0018a	89 54 24 20	 mov	 DWORD PTR _hostSize$[esp+1464], edx
  0018e	75 2c		 jne	 SHORT $LN51@ChangePwd

; 284  : 			{
; 285  : 				nStatus = ERR_VOL_SIZE_WRONG;

  00190	8d 70 07	 lea	 esi, DWORD PTR [eax+7]

; 286  : 				goto error;

  00193	e9 92 03 00 00	 jmp	 $error$80892
$LN58@ChangePwd:

; 287  : 			}
; 288  : 		}
; 289  : 	}
; 290  : 	else
; 291  : 	{
; 292  : 		LARGE_INTEGER fileSize;
; 293  : 		if (!GetFileSizeEx (dev, &fileSize))

  00198	8d 54 24 48	 lea	 edx, DWORD PTR _fileSize$80913[esp+1460]
  0019c	52		 push	 edx
  0019d	53		 push	 ebx
  0019e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileSizeEx@8
  001a4	85 c0		 test	 eax, eax

; 294  : 		{
; 295  : 			nStatus = ERR_OS_ERROR;
; 296  : 			goto error;

  001a6	0f 84 7e 03 00
	00		 je	 $error$80892

; 297  : 		}
; 298  : 
; 299  : 		hostSize = fileSize.QuadPart;

  001ac	8b 44 24 48	 mov	 eax, DWORD PTR _fileSize$80913[esp+1460]
  001b0	8b 4c 24 4c	 mov	 ecx, DWORD PTR _fileSize$80913[esp+1464]
  001b4	89 44 24 1c	 mov	 DWORD PTR _hostSize$[esp+1460], eax
  001b8	89 4c 24 20	 mov	 DWORD PTR _hostSize$[esp+1464], ecx
$LN51@ChangePwd:

; 300  : 	}
; 301  : 
; 302  : 	if (Randinit ())

  001bc	e8 00 00 00 00	 call	 _Randinit
  001c1	85 c0		 test	 eax, eax
  001c3	0f 85 61 03 00
	00		 jne	 $error$80892

; 303  : 		goto error;
; 304  : 
; 305  : 	if (!bDevice && bPreserveTimestamp)

  001c9	39 44 24 14	 cmp	 DWORD PTR _bDevice$[esp+1460], eax
  001cd	75 28		 jne	 SHORT $LN47@ChangePwd
  001cf	39 05 00 00 00
	00		 cmp	 DWORD PTR _bPreserveTimestamp, eax
  001d5	74 20		 je	 SHORT $LN47@ChangePwd

; 306  : 	{
; 307  : 		if (GetFileTime ((HANDLE) dev, &ftCreationTime, &ftLastAccessTime, &ftLastWriteTime) == 0)

  001d7	8d 54 24 78	 lea	 edx, DWORD PTR _ftLastWriteTime$[esp+1460]
  001db	52		 push	 edx
  001dc	8d 44 24 6c	 lea	 eax, DWORD PTR _ftLastAccessTime$[esp+1464]
  001e0	50		 push	 eax
  001e1	8d 4c 24 78	 lea	 ecx, DWORD PTR _ftCreationTime$[esp+1468]
  001e5	51		 push	 ecx
  001e6	53		 push	 ebx
  001e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileTime@16
  001ed	f7 d8		 neg	 eax
  001ef	1b c0		 sbb	 eax, eax
  001f1	f7 d8		 neg	 eax
  001f3	89 44 24 3c	 mov	 DWORD PTR _bTimeStampValid$[esp+1460], eax
$LN47@ChangePwd:

; 308  : 			bTimeStampValid = FALSE;
; 309  : 		else
; 310  : 			bTimeStampValid = TRUE;
; 311  : 	}
; 312  : 
; 313  : 	for (volumeType = TC_VOLUME_TYPE_NORMAL; volumeType < TC_VOLUME_TYPE_COUNT; volumeType++)

  001f7	8b 6c 24 28	 mov	 ebp, DWORD PTR _headerOffset$[esp+1464]
  001fb	8b 5c 24 24	 mov	 ebx, DWORD PTR _headerOffset$[esp+1460]
  001ff	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR _volumeType$[esp+1460], 0
$LL45@ChangePwd:

; 314  : 	{
; 315  : 		// Seek the volume header
; 316  : 		switch (volumeType)

  00207	8b 44 24 2c	 mov	 eax, DWORD PTR _volumeType$[esp+1460]
  0020b	83 e8 00	 sub	 eax, 0
  0020e	74 53		 je	 SHORT $LN40@ChangePwd
  00210	83 e8 01	 sub	 eax, 1
  00213	74 2c		 je	 SHORT $LN39@ChangePwd
  00215	83 e8 01	 sub	 eax, 1
  00218	75 4d		 jne	 SHORT $LN41@ChangePwd

; 328  : 
; 329  : 		case TC_VOLUME_TYPE_HIDDEN_LEGACY:
; 330  : 			if (bDevice && driveInfo.BytesPerSector != TC_SECTOR_SIZE_LEGACY)

  0021a	39 44 24 14	 cmp	 DWORD PTR _bDevice$[esp+1460], eax
  0021e	74 0e		 je	 SHORT $LN36@ChangePwd
  00220	81 7c 24 64 00
	02 00 00	 cmp	 DWORD PTR _driveInfo$[esp+1480], 512 ; 00000200H
  00228	0f 85 b8 00 00
	00		 jne	 $LN44@ChangePwd
$LN36@ChangePwd:

; 331  : 				continue;
; 332  : 
; 333  : 			headerOffset.QuadPart = hostSize - TC_HIDDEN_VOLUME_HEADER_OFFSET_LEGACY;

  0022e	8b 5c 24 1c	 mov	 ebx, DWORD PTR _hostSize$[esp+1460]
  00232	8b 6c 24 20	 mov	 ebp, DWORD PTR _hostSize$[esp+1464]
  00236	81 eb 00 06 00
	00		 sub	 ebx, 1536		; 00000600H
  0023c	83 dd 00	 sbb	 ebp, 0

; 334  : 			break;

  0023f	eb 26		 jmp	 SHORT $LN41@ChangePwd
$LN39@ChangePwd:

; 320  : 			break;
; 321  : 
; 322  : 		case TC_VOLUME_TYPE_HIDDEN:
; 323  : 			if (TC_HIDDEN_VOLUME_HEADER_OFFSET + TC_VOLUME_HEADER_SIZE > hostSize)

  00241	83 7c 24 20 00	 cmp	 DWORD PTR _hostSize$[esp+1464], 0
  00246	0f 82 9a 00 00
	00		 jb	 $LN44@ChangePwd
  0024c	77 0e		 ja	 SHORT $LN95@ChangePwd
  0024e	81 7c 24 1c 00
	00 02 00	 cmp	 DWORD PTR _hostSize$[esp+1460], 131072 ; 00020000H
  00256	0f 82 8a 00 00
	00		 jb	 $LN44@ChangePwd
$LN95@ChangePwd:

; 324  : 				continue;
; 325  : 
; 326  : 			headerOffset.QuadPart = TC_HIDDEN_VOLUME_HEADER_OFFSET;

  0025c	bb 00 00 01 00	 mov	 ebx, 65536		; 00010000H

; 327  : 			break;

  00261	eb 02		 jmp	 SHORT $LN103@ChangePwd
$LN40@ChangePwd:

; 317  : 		{
; 318  : 		case TC_VOLUME_TYPE_NORMAL:
; 319  : 			headerOffset.QuadPart = TC_VOLUME_HEADER_OFFSET;

  00263	33 db		 xor	 ebx, ebx
$LN103@ChangePwd:
  00265	33 ed		 xor	 ebp, ebp
$LN41@ChangePwd:

; 335  : 		}
; 336  : 
; 337  : 		if (!SetFilePointerEx ((HANDLE) dev, headerOffset, NULL, FILE_BEGIN))

  00267	8b 74 24 18	 mov	 esi, DWORD PTR _dev$[esp+1460]
  0026b	6a 00		 push	 0
  0026d	6a 00		 push	 0
  0026f	55		 push	 ebp
  00270	53		 push	 ebx
  00271	56		 push	 esi
  00272	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  00278	85 c0		 test	 eax, eax
  0027a	0f 84 8d 00 00
	00		 je	 $LN78@ChangePwd

; 341  : 		}
; 342  : 
; 343  : 		/* Read in volume header */
; 344  : 		if (!ReadEffectiveVolumeHeader (bDevice, dev, (byte*)buffer, &bytesRead))

  00280	8b 4c 24 14	 mov	 ecx, DWORD PTR _bDevice$[esp+1460]
  00284	8d 54 24 44	 lea	 edx, DWORD PTR _bytesRead$[esp+1460]
  00288	52		 push	 edx
  00289	8d 84 24 ac 01
	00 00		 lea	 eax, DWORD PTR _buffer$[esp+1464]
  00290	50		 push	 eax
  00291	56		 push	 esi
  00292	51		 push	 ecx
  00293	e8 00 00 00 00	 call	 _ReadEffectiveVolumeHeader
  00298	83 c4 10	 add	 esp, 16			; 00000010H
  0029b	85 c0		 test	 eax, eax
  0029d	74 6e		 je	 SHORT $LN78@ChangePwd

; 345  : 		{
; 346  : 			nStatus = ERR_OS_ERROR;
; 347  : 			goto error;
; 348  : 		}
; 349  : 
; 350  : 		if (bytesRead != sizeof (buffer))

  0029f	81 7c 24 44 00
	02 00 00	 cmp	 DWORD PTR _bytesRead$[esp+1460], 512 ; 00000200H
  002a7	74 17		 je	 SHORT $LN33@ChangePwd

; 351  : 		{
; 352  : 			// Windows may report EOF when reading sectors from the last cluster of a device formatted as NTFS 
; 353  : 			memset (buffer, 0, sizeof (buffer));

  002a9	68 00 02 00 00	 push	 512			; 00000200H
  002ae	8d 94 24 ac 01
	00 00		 lea	 edx, DWORD PTR _buffer$[esp+1464]
  002b5	6a 00		 push	 0
  002b7	52		 push	 edx
  002b8	e8 00 00 00 00	 call	 _memset
  002bd	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN33@ChangePwd:

; 354  : 		}
; 355  : 
; 356  : 		/* Try to decrypt the header */
; 357  : 
; 358  : 		nStatus = ReadVolumeHeader (FALSE, buffer, oldPassword, &cryptoInfo, NULL);

  002c0	6a 00		 push	 0
  002c2	8d 44 24 14	 lea	 eax, DWORD PTR _cryptoInfo$[esp+1464]
  002c6	50		 push	 eax
  002c7	57		 push	 edi
  002c8	8d 8c 24 b4 01
	00 00		 lea	 ecx, DWORD PTR _buffer$[esp+1472]
  002cf	51		 push	 ecx
  002d0	6a 00		 push	 0
  002d2	e8 00 00 00 00	 call	 _ReadVolumeHeader
  002d7	8b f0		 mov	 esi, eax
  002d9	83 c4 14	 add	 esp, 20			; 00000014H

; 359  : 		if (nStatus == ERR_CIPHER_INIT_WEAK_KEY)

  002dc	83 fe 12	 cmp	 esi, 18			; 00000012H
  002df	74 3a		 je	 SHORT $LN99@ChangePwd

; 360  : 			nStatus = 0;	// We can ignore this error here
; 361  : 
; 362  : 		if (nStatus == ERR_PASSWORD_WRONG)

  002e1	83 fe 03	 cmp	 esi, 3
  002e4	75 12		 jne	 SHORT $LN31@ChangePwd
$LN44@ChangePwd:

; 308  : 			bTimeStampValid = FALSE;
; 309  : 		else
; 310  : 			bTimeStampValid = TRUE;
; 311  : 	}
; 312  : 
; 313  : 	for (volumeType = TC_VOLUME_TYPE_NORMAL; volumeType < TC_VOLUME_TYPE_COUNT; volumeType++)

  002e6	8b 44 24 2c	 mov	 eax, DWORD PTR _volumeType$[esp+1460]
  002ea	40		 inc	 eax
  002eb	83 f8 03	 cmp	 eax, 3
  002ee	89 44 24 2c	 mov	 DWORD PTR _volumeType$[esp+1460], eax
  002f2	0f 8c 0f ff ff
	ff		 jl	 $LL45@ChangePwd
$LN31@ChangePwd:

; 331  : 				continue;
; 332  : 
; 333  : 			headerOffset.QuadPart = hostSize - TC_HIDDEN_VOLUME_HEADER_OFFSET_LEGACY;

  002f8	89 6c 24 28	 mov	 DWORD PTR _headerOffset$[esp+1464], ebp

; 363  : 		{
; 364  : 			continue;		// Try next volume type
; 365  : 		}
; 366  : 		else if (nStatus != 0)

  002fc	85 f6		 test	 esi, esi
  002fe	74 1f		 je	 SHORT $LN27@ChangePwd

; 367  : 		{
; 368  : 			cryptoInfo = NULL;

  00300	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _cryptoInfo$[esp+1460], 0

; 369  : 			goto error;

  00308	e9 1d 02 00 00	 jmp	 $error$80892
$LN78@ChangePwd:

; 331  : 				continue;
; 332  : 
; 333  : 			headerOffset.QuadPart = hostSize - TC_HIDDEN_VOLUME_HEADER_OFFSET_LEGACY;

  0030d	89 6c 24 28	 mov	 DWORD PTR _headerOffset$[esp+1464], ebp
$LN81@ChangePwd:

; 338  : 		{
; 339  : 			nStatus = ERR_OS_ERROR;

  00311	be 01 00 00 00	 mov	 esi, 1

; 340  : 			goto error;

  00316	e9 0f 02 00 00	 jmp	 $error$80892
$LN99@ChangePwd:

; 331  : 				continue;
; 332  : 
; 333  : 			headerOffset.QuadPart = hostSize - TC_HIDDEN_VOLUME_HEADER_OFFSET_LEGACY;

  0031b	89 6c 24 28	 mov	 DWORD PTR _headerOffset$[esp+1464], ebp
$LN27@ChangePwd:

; 370  : 		}
; 371  : 		else 
; 372  : 			break;
; 373  : 	}
; 374  : 
; 375  : 	if (nStatus != 0)
; 376  : 	{
; 377  : 		cryptoInfo = NULL;
; 378  : 		goto error;
; 379  : 	}
; 380  : 
; 381  : 	if (cryptoInfo->HeaderFlags & TC_HEADER_FLAG_ENCRYPTED_SYSTEM)

  0031f	8b 44 24 10	 mov	 eax, DWORD PTR _cryptoInfo$[esp+1460]
  00323	f6 80 60 44 00
	00 01		 test	 BYTE PTR [eax+17504], 1
  0032a	74 0a		 je	 SHORT $LN26@ChangePwd

; 382  : 	{
; 383  : 		nStatus = ERR_SYS_HIDVOL_HEAD_REENC_MODE_WRONG;

  0032c	be 1f 00 00 00	 mov	 esi, 31			; 0000001fH

; 384  : 		goto error;

  00331	e9 f4 01 00 00	 jmp	 $error$80892
$LN26@ChangePwd:

; 385  : 	}
; 386  : 
; 387  : 	// Change the PKCS-5 PRF if requested by user
; 388  : 	if (pkcs5 != 0)

  00336	8b 8c 24 c4 05
	00 00		 mov	 ecx, DWORD PTR _pkcs5$[esp+1456]
  0033d	85 c9		 test	 ecx, ecx
  0033f	74 0a		 je	 SHORT $LN25@ChangePwd

; 389  : 		cryptoInfo->pkcs5 = pkcs5;

  00341	89 88 ec 43 00
	00		 mov	 DWORD PTR [eax+17388], ecx
  00347	8b 44 24 10	 mov	 eax, DWORD PTR _cryptoInfo$[esp+1460]
$LN25@ChangePwd:

; 390  : 
; 391  : 	RandSetHashFunction (cryptoInfo->pkcs5);

  0034b	8b 90 ec 43 00
	00		 mov	 edx, DWORD PTR [eax+17388]
  00351	52		 push	 edx
  00352	e8 00 00 00 00	 call	 _RandSetHashFunction

; 392  : 
; 393  : 	NormalCursor();

  00357	e8 00 00 00 00	 call	 _NormalCursor

; 394  : 	UserEnrichRandomPool (hwndDlg);

  0035c	8b 74 24 34	 mov	 esi, DWORD PTR _hwndDlg$GSCopy$[esp+1464]
  00360	56		 push	 esi
  00361	e8 00 00 00 00	 call	 _UserEnrichRandomPool

; 395  : 	EnableElevatedCursorChange (hwndDlg);

  00366	56		 push	 esi
  00367	e8 00 00 00 00	 call	 _EnableElevatedCursorChange
  0036c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 396  : 	WaitCursor();

  0036f	e8 00 00 00 00	 call	 _WaitCursor

; 397  : 
; 398  : 	/* Re-encrypt the volume header */ 
; 399  : 	backupHeader = FALSE;

  00374	8b 44 24 10	 mov	 eax, DWORD PTR _cryptoInfo$[esp+1460]
  00378	33 ff		 xor	 edi, edi

; 400  : 
; 401  : 	while (TRUE)
; 402  : 	{
; 403  : 		/* The header will be re-encrypted PRAND_DISK_WIPE_PASSES times to prevent adversaries from using 
; 404  : 		techniques such as magnetic force microscopy or magnetic force scanning tunnelling microscopy
; 405  : 		to recover the overwritten header. According to Peter Gutmann, data should be overwritten 22
; 406  : 		times (ideally, 35 times) using non-random patterns and pseudorandom data. However, as users might
; 407  : 		impatiently interupt the process (etc.) we will not use the Gutmann's patterns but will write the
; 408  : 		valid re-encrypted header, i.e. pseudorandom data, and there will be many more passes than Guttman
; 409  : 		recommends. During each pass we will write a valid working header. Each pass will use the same master
; 410  : 		key, and also the same header key, secondary key (XTS), etc., derived from the new password. The only
; 411  : 		item that will be different for each pass will be the salt. This is sufficient to cause each "version"
; 412  : 		of the header to differ substantially and in a random manner from the versions written during the
; 413  : 		other passes. */
; 414  : 
; 415  : 		for (wipePass = 0; wipePass < PRAND_DISK_WIPE_PASSES; wipePass++)

  0037a	33 ed		 xor	 ebp, ebp
  0037c	eb 06		 jmp	 SHORT $LN22@ChangePwd
  0037e	8b ff		 npad	 2
$LL97@ChangePwd:
  00380	8b 44 24 10	 mov	 eax, DWORD PTR _cryptoInfo$[esp+1460]
$LN22@ChangePwd:

; 416  : 		{
; 417  : 			// Prepare new volume header
; 418  : 			nStatus = CreateVolumeHeaderInMemory (FALSE,
; 419  : 				buffer,
; 420  : 				cryptoInfo->ea,
; 421  : 				cryptoInfo->mode,
; 422  : 				newPassword,
; 423  : 				cryptoInfo->pkcs5,
; 424  : 				(char*)cryptoInfo->master_keydata, //unsigned __int8
; 425  : 				&ci,
; 426  : 				cryptoInfo->VolumeSize.Value,
; 427  : 				(volumeType == TC_VOLUME_TYPE_HIDDEN || volumeType == TC_VOLUME_TYPE_HIDDEN_LEGACY) ? cryptoInfo->hiddenVolumeSize : 0,
; 428  : 				cryptoInfo->EncryptedAreaStart.Value,
; 429  : 				cryptoInfo->EncryptedAreaLength.Value,
; 430  : 				cryptoInfo->RequiredProgramVersion,
; 431  : 				cryptoInfo->HeaderFlags,
; 432  : 				cryptoInfo->SectorSize,
; 433  : 				wipePass < PRAND_DISK_WIPE_PASSES - 1);

  00384	8b 4c 24 2c	 mov	 ecx, DWORD PTR _volumeType$[esp+1460]
  00388	83 f9 01	 cmp	 ecx, 1
  0038b	74 0b		 je	 SHORT $LN67@ChangePwd
  0038d	83 f9 02	 cmp	 ecx, 2
  00390	74 06		 je	 SHORT $LN67@ChangePwd
  00392	33 c9		 xor	 ecx, ecx
  00394	33 f6		 xor	 esi, esi
  00396	eb 0c		 jmp	 SHORT $LN68@ChangePwd
$LN67@ChangePwd:
  00398	8b 88 10 44 00
	00		 mov	 ecx, DWORD PTR [eax+17424]
  0039e	8b b0 14 44 00
	00		 mov	 esi, DWORD PTR [eax+17428]
$LN68@ChangePwd:
  003a4	33 d2		 xor	 edx, edx
  003a6	81 fd ff 00 00
	00		 cmp	 ebp, 255		; 000000ffH
  003ac	0f 9c c2	 setl	 dl
  003af	52		 push	 edx
  003b0	8b 90 40 44 00
	00		 mov	 edx, DWORD PTR [eax+17472]
  003b6	52		 push	 edx
  003b7	8b 90 60 44 00
	00		 mov	 edx, DWORD PTR [eax+17504]
  003bd	52		 push	 edx
  003be	0f b7 90 38 44
	00 00		 movzx	 edx, WORD PTR [eax+17464]
  003c5	52		 push	 edx
  003c6	8b 90 5c 44 00
	00		 mov	 edx, DWORD PTR [eax+17500]
  003cc	52		 push	 edx
  003cd	8b 90 58 44 00
	00		 mov	 edx, DWORD PTR [eax+17496]
  003d3	52		 push	 edx
  003d4	8b 90 54 44 00
	00		 mov	 edx, DWORD PTR [eax+17492]
  003da	52		 push	 edx
  003db	8b 90 50 44 00
	00		 mov	 edx, DWORD PTR [eax+17488]
  003e1	52		 push	 edx
  003e2	8b 90 48 44 00
	00		 mov	 edx, DWORD PTR [eax+17480]
  003e8	56		 push	 esi
  003e9	51		 push	 ecx
  003ea	8b 88 4c 44 00
	00		 mov	 ecx, DWORD PTR [eax+17484]
  003f0	51		 push	 ecx
  003f1	52		 push	 edx
  003f2	8d 4c 24 64	 lea	 ecx, DWORD PTR _ci$[esp+1508]
  003f6	51		 push	 ecx
  003f7	8b 88 ec 43 00
	00		 mov	 ecx, DWORD PTR [eax+17388]
  003fd	8d 90 a8 41 00
	00		 lea	 edx, DWORD PTR [eax+16808]
  00403	52		 push	 edx
  00404	8b 54 24 78	 mov	 edx, DWORD PTR _newPassword$GSCopy$[esp+1516]
  00408	51		 push	 ecx
  00409	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0040c	52		 push	 edx
  0040d	8b 10		 mov	 edx, DWORD PTR [eax]
  0040f	51		 push	 ecx
  00410	52		 push	 edx
  00411	8d 84 24 f0 01
	00 00		 lea	 eax, DWORD PTR _buffer$[esp+1532]
  00418	50		 push	 eax
  00419	6a 00		 push	 0
  0041b	e8 00 00 00 00	 call	 _CreateVolumeHeaderInMemory
  00420	8b f0		 mov	 esi, eax

; 434  : 
; 435  : 			if (ci != NULL)

  00422	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR _ci$[esp+1540]
  00429	83 c4 50	 add	 esp, 80			; 00000050H
  0042c	85 c0		 test	 eax, eax
  0042e	74 09		 je	 SHORT $LN19@ChangePwd

; 436  : 				crypto_close (ci);

  00430	50		 push	 eax
  00431	e8 00 00 00 00	 call	 _crypto_close
  00436	83 c4 04	 add	 esp, 4
$LN19@ChangePwd:

; 437  : 
; 438  : 			if (nStatus != 0)

  00439	85 f6		 test	 esi, esi
  0043b	0f 85 e9 00 00
	00		 jne	 $error$80892

; 439  : 				goto error;
; 440  : 
; 441  : 			if (!SetFilePointerEx ((HANDLE) dev, headerOffset, NULL, FILE_BEGIN))

  00441	8b 4c 24 28	 mov	 ecx, DWORD PTR _headerOffset$[esp+1464]
  00445	56		 push	 esi
  00446	56		 push	 esi
  00447	8b 74 24 20	 mov	 esi, DWORD PTR _dev$[esp+1468]
  0044b	51		 push	 ecx
  0044c	53		 push	 ebx
  0044d	56		 push	 esi
  0044e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  00454	85 c0		 test	 eax, eax
  00456	0f 84 b5 fe ff
	ff		 je	 $LN81@ChangePwd

; 442  : 			{
; 443  : 				nStatus = ERR_OS_ERROR;
; 444  : 				goto error;
; 445  : 			}
; 446  : 
; 447  : 			if (!WriteEffectiveVolumeHeader (bDevice, dev, (byte*)buffer))

  0045c	8b 44 24 14	 mov	 eax, DWORD PTR _bDevice$[esp+1460]
  00460	8d 94 24 a8 01
	00 00		 lea	 edx, DWORD PTR _buffer$[esp+1460]
  00467	52		 push	 edx
  00468	56		 push	 esi
  00469	50		 push	 eax
  0046a	e8 00 00 00 00	 call	 _WriteEffectiveVolumeHeader
  0046f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00472	85 c0		 test	 eax, eax
  00474	0f 84 97 fe ff
	ff		 je	 $LN81@ChangePwd

; 448  : 			{
; 449  : 				nStatus = ERR_OS_ERROR;
; 450  : 				goto error;
; 451  : 			}
; 452  : 
; 453  : 			if (bDevice
; 454  : 				&& !cryptoInfo->LegacyVolume
; 455  : 				&& !cryptoInfo->hiddenVolume
; 456  : 				&& cryptoInfo->HeaderVersion == 4
; 457  : 				&& (cryptoInfo->HeaderFlags & TC_HEADER_FLAG_NONSYS_INPLACE_ENC) != 0
; 458  : 				&& (cryptoInfo->HeaderFlags & ~TC_HEADER_FLAG_NONSYS_INPLACE_ENC) == 0)

  0047a	83 7c 24 14 00	 cmp	 DWORD PTR _bDevice$[esp+1460], 0
  0047f	74 60		 je	 SHORT $LN14@ChangePwd
  00481	8b 44 24 10	 mov	 eax, DWORD PTR _cryptoInfo$[esp+1460]
  00485	83 b8 3c 44 00
	00 00		 cmp	 DWORD PTR [eax+17468], 0
  0048c	75 53		 jne	 SHORT $LN14@ChangePwd
  0048e	83 b8 a0 29 00
	00 00		 cmp	 DWORD PTR [eax+10656], 0
  00495	75 4a		 jne	 SHORT $LN14@ChangePwd
  00497	66 83 b8 a4 29
	00 00 04	 cmp	 WORD PTR [eax+10660], 4
  0049f	75 40		 jne	 SHORT $LN14@ChangePwd
  004a1	8b 88 60 44 00
	00		 mov	 ecx, DWORD PTR [eax+17504]
  004a7	f6 c1 02	 test	 cl, 2
  004aa	74 35		 je	 SHORT $LN14@ChangePwd
  004ac	f7 c1 fd ff ff
	ff		 test	 ecx, -3			; fffffffdH
  004b2	75 2d		 jne	 SHORT $LN14@ChangePwd

; 459  : 			{
; 460  : 				nStatus = WriteRandomDataToReservedHeaderAreas (dev, cryptoInfo, cryptoInfo->VolumeSize.Value, !backupHeader, backupHeader);

  004b4	8b 90 4c 44 00
	00		 mov	 edx, DWORD PTR [eax+17484]
  004ba	33 c9		 xor	 ecx, ecx
  004bc	85 ff		 test	 edi, edi
  004be	0f 94 c1	 sete	 cl
  004c1	57		 push	 edi
  004c2	51		 push	 ecx
  004c3	8b 88 48 44 00
	00		 mov	 ecx, DWORD PTR [eax+17480]
  004c9	52		 push	 edx
  004ca	51		 push	 ecx
  004cb	50		 push	 eax
  004cc	8b d6		 mov	 edx, esi
  004ce	52		 push	 edx
  004cf	e8 00 00 00 00	 call	 _WriteRandomDataToReservedHeaderAreas
  004d4	8b f0		 mov	 esi, eax
  004d6	83 c4 18	 add	 esp, 24			; 00000018H

; 461  : 				if (nStatus != ERR_SUCCESS)

  004d9	85 f6		 test	 esi, esi
  004db	75 4d		 jne	 SHORT $error$80892
  004dd	8b 74 24 18	 mov	 esi, DWORD PTR _dev$[esp+1460]
$LN14@ChangePwd:

; 462  : 					goto error;
; 463  : 			}
; 464  : 
; 465  : 			FlushFileBuffers (dev);

  004e1	56		 push	 esi
  004e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FlushFileBuffers@4
  004e8	45		 inc	 ebp
  004e9	81 fd 00 01 00
	00		 cmp	 ebp, 256		; 00000100H
  004ef	0f 8c 8b fe ff
	ff		 jl	 $LL97@ChangePwd

; 466  : 		}
; 467  : 
; 468  : 		if (backupHeader || cryptoInfo->LegacyVolume)

  004f5	85 ff		 test	 edi, edi
  004f7	75 2f		 jne	 SHORT $LN84@ChangePwd
  004f9	8b 44 24 10	 mov	 eax, DWORD PTR _cryptoInfo$[esp+1460]
  004fd	39 b8 3c 44 00
	00		 cmp	 DWORD PTR [eax+17468], edi
  00503	75 23		 jne	 SHORT $LN84@ChangePwd

; 469  : 			break;
; 470  : 			
; 471  : 		backupHeader = TRUE;
; 472  : 		headerOffset.QuadPart += hostSize - TC_VOLUME_HEADER_GROUP_SIZE;

  00505	8b 4c 24 1c	 mov	 ecx, DWORD PTR _hostSize$[esp+1460]
  00509	8b 54 24 20	 mov	 edx, DWORD PTR _hostSize$[esp+1464]
  0050d	81 e9 00 00 02
	00		 sub	 ecx, 131072		; 00020000H
  00513	83 da 00	 sbb	 edx, 0
  00516	03 d9		 add	 ebx, ecx
  00518	11 54 24 28	 adc	 DWORD PTR _headerOffset$[esp+1464], edx
  0051c	bf 01 00 00 00	 mov	 edi, 1
  00521	33 ed		 xor	 ebp, ebp
  00523	e9 5c fe ff ff	 jmp	 $LN22@ChangePwd
$LN84@ChangePwd:

; 473  : 	}
; 474  : 
; 475  : 	/* Password successfully changed */
; 476  : 	nStatus = 0;

  00528	33 f6		 xor	 esi, esi
$error$80892:

; 477  : 
; 478  : error:
; 479  : 	dwError = GetLastError ();

  0052a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 480  : 
; 481  : 	burn (buffer, sizeof (buffer));

  00530	8d 94 24 a8 01
	00 00		 lea	 edx, DWORD PTR _buffer$[esp+1460]
  00537	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0053c	8b e8		 mov	 ebp, eax
  0053e	8b f9		 mov	 edi, ecx
  00540	8b c2		 mov	 eax, edx
$LL70@ChangePwd:
  00542	c6 00 00	 mov	 BYTE PTR [eax], 0
  00545	40		 inc	 eax
  00546	83 ef 01	 sub	 edi, 1
  00549	75 f7		 jne	 SHORT $LL70@ChangePwd
  0054b	eb 03 8d 49 00	 npad	 5
$LL8@ChangePwd:
  00550	49		 dec	 ecx
  00551	c6 02 00	 mov	 BYTE PTR [edx], 0
  00554	42		 inc	 edx
  00555	85 c9		 test	 ecx, ecx
  00557	75 f7		 jne	 SHORT $LL8@ChangePwd

; 482  : 
; 483  : 	if (cryptoInfo != NULL)

  00559	8b 44 24 10	 mov	 eax, DWORD PTR _cryptoInfo$[esp+1460]
  0055d	85 c0		 test	 eax, eax
  0055f	74 09		 je	 SHORT $LN6@ChangePwd

; 484  : 		crypto_close (cryptoInfo);

  00561	50		 push	 eax
  00562	e8 00 00 00 00	 call	 _crypto_close
  00567	83 c4 04	 add	 esp, 4
$LN6@ChangePwd:

; 485  : 
; 486  : 	if (bTimeStampValid)

  0056a	83 7c 24 3c 00	 cmp	 DWORD PTR _bTimeStampValid$[esp+1460], 0

; 487  : 		SetFileTime (dev, &ftCreationTime, &ftLastAccessTime, &ftLastWriteTime);

  0056f	8b 7c 24 18	 mov	 edi, DWORD PTR _dev$[esp+1460]
  00573	74 16		 je	 SHORT $LN5@ChangePwd
  00575	8d 44 24 78	 lea	 eax, DWORD PTR _ftLastWriteTime$[esp+1460]
  00579	50		 push	 eax
  0057a	8d 4c 24 6c	 lea	 ecx, DWORD PTR _ftLastAccessTime$[esp+1464]
  0057e	51		 push	 ecx
  0057f	8d 54 24 78	 lea	 edx, DWORD PTR _ftCreationTime$[esp+1468]
  00583	52		 push	 edx
  00584	57		 push	 edi
  00585	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFileTime@16
$LN5@ChangePwd:

; 488  : 
; 489  : 	if (dev != INVALID_HANDLE_VALUE)

  0058b	83 ff ff	 cmp	 edi, -1
  0058e	74 07		 je	 SHORT $LN4@ChangePwd

; 490  : 		CloseHandle ((HANDLE) dev);

  00590	57		 push	 edi
  00591	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN4@ChangePwd:

; 491  : 
; 492  : 	if (nDosLinkCreated == 0)

  00597	83 7c 24 38 00	 cmp	 DWORD PTR _nDosLinkCreated$[esp+1460], 0
  0059c	75 18		 jne	 SHORT $LN3@ChangePwd

; 493  : 		RemoveFakeDosName (szDiskFile, szDosDevice);

  0059e	8d 84 24 ac 04
	00 00		 lea	 eax, DWORD PTR _szDosDevice$[esp+1460]
  005a5	50		 push	 eax
  005a6	8d 8c 24 a8 00
	00 00		 lea	 ecx, DWORD PTR _szDiskFile$[esp+1464]
  005ad	51		 push	 ecx
  005ae	e8 00 00 00 00	 call	 _RemoveFakeDosName
  005b3	83 c4 08	 add	 esp, 8
$LN3@ChangePwd:

; 494  : 
; 495  : 	RandStop (FALSE);

  005b6	6a 00		 push	 0
  005b8	e8 00 00 00 00	 call	 _RandStop
  005bd	83 c4 04	 add	 esp, 4

; 496  : 	NormalCursor ();

  005c0	e8 00 00 00 00	 call	 _NormalCursor

; 497  : 
; 498  : 	SetLastError (dwError);

  005c5	55		 push	 ebp
  005c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 499  : 
; 500  : 	if (nStatus == ERR_OS_ERROR && dwError == ERROR_ACCESS_DENIED
; 501  : 		&& bDevice
; 502  : 		&& !UacElevated
; 503  : 		&& IsUacSupported ())

  005cc	83 fe 01	 cmp	 esi, 1
  005cf	75 22		 jne	 SHORT $LN2@ChangePwd
  005d1	83 fd 05	 cmp	 ebp, 5
  005d4	75 21		 jne	 SHORT $LN91@ChangePwd
  005d6	83 7c 24 14 00	 cmp	 DWORD PTR _bDevice$[esp+1460], 0
  005db	74 1a		 je	 SHORT $LN91@ChangePwd
  005dd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _UacElevated, 0
  005e4	75 11		 jne	 SHORT $LN91@ChangePwd
  005e6	e8 00 00 00 00	 call	 _IsUacSupported
  005eb	85 c0		 test	 eax, eax
  005ed	74 08		 je	 SHORT $LN91@ChangePwd

; 504  : 		return nStatus;

  005ef	8b c6		 mov	 eax, esi
  005f1	eb 19		 jmp	 SHORT $LN65@ChangePwd
$LN2@ChangePwd:

; 505  : 
; 506  : 	if (nStatus != 0)

  005f3	85 f6		 test	 esi, esi
  005f5	74 0e		 je	 SHORT $LN1@ChangePwd
$LN91@ChangePwd:

; 507  : 		handleError (hwndDlg, nStatus);

  005f7	8b 54 24 30	 mov	 edx, DWORD PTR _hwndDlg$GSCopy$[esp+1460]
  005fb	56		 push	 esi
  005fc	52		 push	 edx
  005fd	e8 00 00 00 00	 call	 _handleError
  00602	83 c4 08	 add	 esp, 8
$LN1@ChangePwd:

; 508  : 
; 509  : 	return nStatus;

  00605	8b c6		 mov	 eax, esi
  00607	eb 03		 jmp	 SHORT $LN65@ChangePwd
$LN63@ChangePwd:

; 224  : 	LARGE_INTEGER headerOffset;
; 225  : 	BOOL backupHeader;
; 226  : 	DISK_GEOMETRY driveInfo;
; 227  : 
; 228  : 	if (oldPassword->Length == 0 || newPassword->Length == 0) return -1;

  00609	83 c8 ff	 or	 eax, -1
$LN65@ChangePwd:

; 510  : }

  0060c	8b 8c 24 b0 05
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1460]
  00613	5f		 pop	 edi
  00614	5e		 pop	 esi
  00615	5d		 pop	 ebp
  00616	5b		 pop	 ebx
  00617	33 cc		 xor	 ecx, esp
  00619	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0061e	81 c4 a4 05 00
	00		 add	 esp, 1444		; 000005a4H
  00624	c3		 ret	 0
_ChangePwd ENDP
_TEXT	ENDS
PUBLIC	_CheckPasswordLength
EXTRN	_lpszTitle:DWORD
; Function compile flags: /Ogtpy
;	COMDAT _CheckPasswordLength
_TEXT	SEGMENT
_hwndDlg$ = 8						; size = 4
_hwndItem$ = 12						; size = 4
_CheckPasswordLength PROC				; COMDAT

; 174  : {

  00000	56		 push	 esi

; 175  : 	return CheckPasswordLengthAlertTitle(hwndDlg, lpszTitle, hwndItem);

  00001	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _lpszTitle
  00007	57		 push	 edi
  00008	8b 7c 24 0c	 mov	 edi, DWORD PTR _hwndDlg$[esp+4]
  0000c	85 ff		 test	 edi, edi
  0000e	75 05		 jne	 SHORT $LN6@CheckPassw@3
$LN9@CheckPassw@3:
  00010	5f		 pop	 edi
  00011	33 c0		 xor	 eax, eax
  00013	5e		 pop	 esi

; 176  : }

  00014	c3		 ret	 0

; 175  : 	return CheckPasswordLengthAlertTitle(hwndDlg, lpszTitle, hwndItem);

$LN6@CheckPassw@3:
  00015	8b 44 24 10	 mov	 eax, DWORD PTR _hwndItem$[esp+4]
  00019	85 c0		 test	 eax, eax
  0001b	74 f3		 je	 SHORT $LN9@CheckPassw@3
  0001d	50		 push	 eax
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextLengthW@4
  00024	83 f8 14	 cmp	 eax, 20			; 00000014H
  00027	7d 20		 jge	 SHORT $LN3@CheckPassw@3
  00029	68 34 01 00 00	 push	 308			; 00000134H
  0002e	56		 push	 esi
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@FPFPGNBO@PASSWORD_LENGTH_WARNING?$AA@
  00034	e8 00 00 00 00	 call	 _GetString
  00039	83 c4 04	 add	 esp, 4
  0003c	50		 push	 eax
  0003d	57		 push	 edi
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
  00044	83 f8 06	 cmp	 eax, 6
  00047	75 c7		 jne	 SHORT $LN9@CheckPassw@3
$LN3@CheckPassw@3:
  00049	5f		 pop	 edi
  0004a	b8 01 00 00 00	 mov	 eax, 1
  0004f	5e		 pop	 esi

; 176  : }

  00050	c3		 ret	 0
_CheckPasswordLength ENDP
_TEXT	ENDS
END
