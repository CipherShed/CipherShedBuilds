; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\users\public\desktop\projects\ciphershed\src\crypto\des.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
_pc1	DB	039H
	DB	031H
	DB	029H
	DB	021H
	DB	019H
	DB	011H
	DB	09H
	DB	01H
	DB	03aH
	DB	032H
	DB	02aH
	DB	022H
	DB	01aH
	DB	012H
	DB	0aH
	DB	02H
	DB	03bH
	DB	033H
	DB	02bH
	DB	023H
	DB	01bH
	DB	013H
	DB	0bH
	DB	03H
	DB	03cH
	DB	034H
	DB	02cH
	DB	024H
	DB	03fH
	DB	037H
	DB	02fH
	DB	027H
	DB	01fH
	DB	017H
	DB	0fH
	DB	07H
	DB	03eH
	DB	036H
	DB	02eH
	DB	026H
	DB	01eH
	DB	016H
	DB	0eH
	DB	06H
	DB	03dH
	DB	035H
	DB	02dH
	DB	025H
	DB	01dH
	DB	015H
	DB	0dH
	DB	05H
	DB	01cH
	DB	014H
	DB	0cH
	DB	04H
_totrot	DB	01H
	DB	02H
	DB	04H
	DB	06H
	DB	08H
	DB	0aH
	DB	0cH
	DB	0eH
	DB	0fH
	DB	011H
	DB	013H
	DB	015H
	DB	017H
	DB	019H
	DB	01bH
	DB	01cH
_pc2	DB	0eH
	DB	011H
	DB	0bH
	DB	018H
	DB	01H
	DB	05H
	DB	03H
	DB	01cH
	DB	0fH
	DB	06H
	DB	015H
	DB	0aH
	DB	017H
	DB	013H
	DB	0cH
	DB	04H
	DB	01aH
	DB	08H
	DB	010H
	DB	07H
	DB	01bH
	DB	014H
	DB	0dH
	DB	02H
	DB	029H
	DB	034H
	DB	01fH
	DB	025H
	DB	02fH
	DB	037H
	DB	01eH
	DB	028H
	DB	033H
	DB	02dH
	DB	021H
	DB	030H
	DB	02cH
	DB	031H
	DB	027H
	DB	038H
	DB	022H
	DB	035H
	DB	02eH
	DB	02aH
	DB	032H
	DB	024H
	DB	01dH
	DB	020H
_bytebit DD	080H
	DD	040H
	DD	020H
	DD	010H
	DD	08H
	DD	04H
	DD	02H
	DD	01H
_Spbox	DD	01010400H
	DD	00H
	DD	010000H
	DD	01010404H
	DD	01010004H
	DD	010404H
	DD	04H
	DD	010000H
	DD	0400H
	DD	01010400H
	DD	01010404H
	DD	0400H
	DD	01000404H
	DD	01010004H
	DD	01000000H
	DD	04H
	DD	0404H
	DD	01000400H
	DD	01000400H
	DD	010400H
	DD	010400H
	DD	01010000H
	DD	01010000H
	DD	01000404H
	DD	010004H
	DD	01000004H
	DD	01000004H
	DD	010004H
	DD	00H
	DD	0404H
	DD	010404H
	DD	01000000H
	DD	010000H
	DD	01010404H
	DD	04H
	DD	01010000H
	DD	01010400H
	DD	01000000H
	DD	01000000H
	DD	0400H
	DD	01010004H
	DD	010000H
	DD	010400H
	DD	01000004H
	DD	0400H
	DD	04H
	DD	01000404H
	DD	010404H
	DD	01010404H
	DD	010004H
	DD	01010000H
	DD	01000404H
	DD	01000004H
	DD	0404H
	DD	010404H
	DD	01010400H
	DD	0404H
	DD	01000400H
	DD	01000400H
	DD	00H
	DD	010004H
	DD	010400H
	DD	00H
	DD	01010004H
	DD	080108020H
	DD	080008000H
	DD	08000H
	DD	0108020H
	DD	0100000H
	DD	020H
	DD	080100020H
	DD	080008020H
	DD	080000020H
	DD	080108020H
	DD	080108000H
	DD	080000000H
	DD	080008000H
	DD	0100000H
	DD	020H
	DD	080100020H
	DD	0108000H
	DD	0100020H
	DD	080008020H
	DD	00H
	DD	080000000H
	DD	08000H
	DD	0108020H
	DD	080100000H
	DD	0100020H
	DD	080000020H
	DD	00H
	DD	0108000H
	DD	08020H
	DD	080108000H
	DD	080100000H
	DD	08020H
	DD	00H
	DD	0108020H
	DD	080100020H
	DD	0100000H
	DD	080008020H
	DD	080100000H
	DD	080108000H
	DD	08000H
	DD	080100000H
	DD	080008000H
	DD	020H
	DD	080108020H
	DD	0108020H
	DD	020H
	DD	08000H
	DD	080000000H
	DD	08020H
	DD	080108000H
	DD	0100000H
	DD	080000020H
	DD	0100020H
	DD	080008020H
	DD	080000020H
	DD	0100020H
	DD	0108000H
	DD	00H
	DD	080008000H
	DD	08020H
	DD	080000000H
	DD	080100020H
	DD	080108020H
	DD	0108000H
	DD	0208H
	DD	08020200H
	DD	00H
	DD	08020008H
	DD	08000200H
	DD	00H
	DD	020208H
	DD	08000200H
	DD	020008H
	DD	08000008H
	DD	08000008H
	DD	020000H
	DD	08020208H
	DD	020008H
	DD	08020000H
	DD	0208H
	DD	08000000H
	DD	08H
	DD	08020200H
	DD	0200H
	DD	020200H
	DD	08020000H
	DD	08020008H
	DD	020208H
	DD	08000208H
	DD	020200H
	DD	020000H
	DD	08000208H
	DD	08H
	DD	08020208H
	DD	0200H
	DD	08000000H
	DD	08020200H
	DD	08000000H
	DD	020008H
	DD	0208H
	DD	020000H
	DD	08020200H
	DD	08000200H
	DD	00H
	DD	0200H
	DD	020008H
	DD	08020208H
	DD	08000200H
	DD	08000008H
	DD	0200H
	DD	00H
	DD	08020008H
	DD	08000208H
	DD	020000H
	DD	08000000H
	DD	08020208H
	DD	08H
	DD	020208H
	DD	020200H
	DD	08000008H
	DD	08020000H
	DD	08000208H
	DD	0208H
	DD	08020000H
	DD	020208H
	DD	08H
	DD	08020008H
	DD	020200H
	DD	0802001H
	DD	02081H
	DD	02081H
	DD	080H
	DD	0802080H
	DD	0800081H
	DD	0800001H
	DD	02001H
	DD	00H
	DD	0802000H
	DD	0802000H
	DD	0802081H
	DD	081H
	DD	00H
	DD	0800080H
	DD	0800001H
	DD	01H
	DD	02000H
	DD	0800000H
	DD	0802001H
	DD	080H
	DD	0800000H
	DD	02001H
	DD	02080H
	DD	0800081H
	DD	01H
	DD	02080H
	DD	0800080H
	DD	02000H
	DD	0802080H
	DD	0802081H
	DD	081H
	DD	0800080H
	DD	0800001H
	DD	0802000H
	DD	0802081H
	DD	081H
	DD	00H
	DD	00H
	DD	0802000H
	DD	02080H
	DD	0800080H
	DD	0800081H
	DD	01H
	DD	0802001H
	DD	02081H
	DD	02081H
	DD	080H
	DD	0802081H
	DD	081H
	DD	01H
	DD	02000H
	DD	0800001H
	DD	02001H
	DD	0802080H
	DD	0800081H
	DD	02001H
	DD	02080H
	DD	0800000H
	DD	0802001H
	DD	080H
	DD	0800000H
	DD	02000H
	DD	0802080H
	DD	0100H
	DD	02080100H
	DD	02080000H
	DD	042000100H
	DD	080000H
	DD	0100H
	DD	040000000H
	DD	02080000H
	DD	040080100H
	DD	080000H
	DD	02000100H
	DD	040080100H
	DD	042000100H
	DD	042080000H
	DD	080100H
	DD	040000000H
	DD	02000000H
	DD	040080000H
	DD	040080000H
	DD	00H
	DD	040000100H
	DD	042080100H
	DD	042080100H
	DD	02000100H
	DD	042080000H
	DD	040000100H
	DD	00H
	DD	042000000H
	DD	02080100H
	DD	02000000H
	DD	042000000H
	DD	080100H
	DD	080000H
	DD	042000100H
	DD	0100H
	DD	02000000H
	DD	040000000H
	DD	02080000H
	DD	042000100H
	DD	040080100H
	DD	02000100H
	DD	040000000H
	DD	042080000H
	DD	02080100H
	DD	040080100H
	DD	0100H
	DD	02000000H
	DD	042080000H
	DD	042080100H
	DD	080100H
	DD	042000000H
	DD	042080100H
	DD	02080000H
	DD	00H
	DD	040080000H
	DD	042000000H
	DD	080100H
	DD	02000100H
	DD	040000100H
	DD	080000H
	DD	00H
	DD	040080000H
	DD	02080100H
	DD	040000100H
	DD	020000010H
	DD	020400000H
	DD	04000H
	DD	020404010H
	DD	020400000H
	DD	010H
	DD	020404010H
	DD	0400000H
	DD	020004000H
	DD	0404010H
	DD	0400000H
	DD	020000010H
	DD	0400010H
	DD	020004000H
	DD	020000000H
	DD	04010H
	DD	00H
	DD	0400010H
	DD	020004010H
	DD	04000H
	DD	0404000H
	DD	020004010H
	DD	010H
	DD	020400010H
	DD	020400010H
	DD	00H
	DD	0404010H
	DD	020404000H
	DD	04010H
	DD	0404000H
	DD	020404000H
	DD	020000000H
	DD	020004000H
	DD	010H
	DD	020400010H
	DD	0404000H
	DD	020404010H
	DD	0400000H
	DD	04010H
	DD	020000010H
	DD	0400000H
	DD	020004000H
	DD	020000000H
	DD	04010H
	DD	020000010H
	DD	020404010H
	DD	0404000H
	DD	020400000H
	DD	0404010H
	DD	020404000H
	DD	00H
	DD	020400010H
	DD	010H
	DD	04000H
	DD	020400000H
	DD	0404010H
	DD	04000H
	DD	0400010H
	DD	020004010H
	DD	00H
	DD	020404000H
	DD	020000000H
	DD	0400010H
	DD	020004010H
	DD	0200000H
	DD	04200002H
	DD	04000802H
	DD	00H
	DD	0800H
	DD	04000802H
	DD	0200802H
	DD	04200800H
	DD	04200802H
	DD	0200000H
	DD	00H
	DD	04000002H
	DD	02H
	DD	04000000H
	DD	04200002H
	DD	0802H
	DD	04000800H
	DD	0200802H
	DD	0200002H
	DD	04000800H
	DD	04000002H
	DD	04200000H
	DD	04200800H
	DD	0200002H
	DD	04200000H
	DD	0800H
	DD	0802H
	DD	04200802H
	DD	0200800H
	DD	02H
	DD	04000000H
	DD	0200800H
	DD	04000000H
	DD	0200800H
	DD	0200000H
	DD	04000802H
	DD	04000802H
	DD	04200002H
	DD	04200002H
	DD	02H
	DD	0200002H
	DD	04000000H
	DD	04000800H
	DD	0200000H
	DD	04200800H
	DD	0802H
	DD	0200802H
	DD	04200800H
	DD	0802H
	DD	04000002H
	DD	04200802H
	DD	04200000H
	DD	0200800H
	DD	00H
	DD	02H
	DD	04200802H
	DD	00H
	DD	0200802H
	DD	04200000H
	DD	0800H
	DD	04000002H
	DD	04000800H
	DD	0800H
	DD	0200002H
	DD	010001040H
	DD	01000H
	DD	040000H
	DD	010041040H
	DD	010000000H
	DD	010001040H
	DD	040H
	DD	010000000H
	DD	040040H
	DD	010040000H
	DD	010041040H
	DD	041000H
	DD	010041000H
	DD	041040H
	DD	01000H
	DD	040H
	DD	010040000H
	DD	010000040H
	DD	010001000H
	DD	01040H
	DD	041000H
	DD	040040H
	DD	010040040H
	DD	010041000H
	DD	01040H
	DD	00H
	DD	00H
	DD	010040040H
	DD	010000040H
	DD	010001000H
	DD	041040H
	DD	040000H
	DD	041040H
	DD	040000H
	DD	010041000H
	DD	01000H
	DD	040H
	DD	010040040H
	DD	01000H
	DD	041040H
	DD	010001000H
	DD	040H
	DD	010000040H
	DD	010040000H
	DD	010040040H
	DD	010000000H
	DD	040000H
	DD	010001040H
	DD	00H
	DD	010041040H
	DD	040040H
	DD	010000040H
	DD	010040000H
	DD	010001000H
	DD	010001040H
	DD	00H
	DD	010041040H
	DD	041000H
	DD	041000H
	DD	01040H
	DD	01040H
	DD	040040H
	DD	010000000H
	DD	010041000H
CONST	ENDS
PUBLIC	_TripleDesSetKey@12
; Function compile flags: /Odtp
; File c:\users\public\desktop\projects\ciphershed\src\crypto\des.c
;	COMDAT _TripleDesSetKey@12
_TEXT	SEGMENT
_userKey$ = 8						; size = 4
_length$ = 12						; size = 4
_ks$ = 16						; size = 4
_TripleDesSetKey@12 PROC				; COMDAT

; 351  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 352  : 	RawSetKey (1, userKey + 0, ks->k1);

  00005	8b 45 10	 mov	 eax, DWORD PTR _ks$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _userKey$[ebp]
  0000c	51		 push	 ecx
  0000d	6a 01		 push	 1
  0000f	e8 00 00 00 00	 call	 _RawSetKey@12

; 353  : 	RawSetKey (1, userKey + 8, ks->k2);

  00014	8b 55 10	 mov	 edx, DWORD PTR _ks$[ebp]
  00017	81 c2 80 00 00
	00		 add	 edx, 128		; 00000080H
  0001d	52		 push	 edx
  0001e	8b 45 08	 mov	 eax, DWORD PTR _userKey$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	50		 push	 eax
  00025	6a 01		 push	 1
  00027	e8 00 00 00 00	 call	 _RawSetKey@12

; 354  : 	RawSetKey (1, userKey + 16, ks->k3);

  0002c	8b 4d 10	 mov	 ecx, DWORD PTR _ks$[ebp]
  0002f	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  00035	51		 push	 ecx
  00036	8b 55 08	 mov	 edx, DWORD PTR _userKey$[ebp]
  00039	83 c2 10	 add	 edx, 16			; 00000010H
  0003c	52		 push	 edx
  0003d	6a 01		 push	 1
  0003f	e8 00 00 00 00	 call	 _RawSetKey@12

; 355  : 	RawSetKey (0, userKey + 16, ks->k1d);

  00044	8b 45 10	 mov	 eax, DWORD PTR _ks$[ebp]
  00047	05 80 01 00 00	 add	 eax, 384		; 00000180H
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _userKey$[ebp]
  00050	83 c1 10	 add	 ecx, 16			; 00000010H
  00053	51		 push	 ecx
  00054	6a 00		 push	 0
  00056	e8 00 00 00 00	 call	 _RawSetKey@12

; 356  : 	RawSetKey (0, userKey + 8, ks->k2d);

  0005b	8b 55 10	 mov	 edx, DWORD PTR _ks$[ebp]
  0005e	81 c2 00 02 00
	00		 add	 edx, 512		; 00000200H
  00064	52		 push	 edx
  00065	8b 45 08	 mov	 eax, DWORD PTR _userKey$[ebp]
  00068	83 c0 08	 add	 eax, 8
  0006b	50		 push	 eax
  0006c	6a 00		 push	 0
  0006e	e8 00 00 00 00	 call	 _RawSetKey@12

; 357  : 	RawSetKey (0, userKey + 0, ks->k3d);

  00073	8b 4d 10	 mov	 ecx, DWORD PTR _ks$[ebp]
  00076	81 c1 80 02 00
	00		 add	 ecx, 640		; 00000280H
  0007c	51		 push	 ecx
  0007d	8b 55 08	 mov	 edx, DWORD PTR _userKey$[ebp]
  00080	52		 push	 edx
  00081	6a 00		 push	 0
  00083	e8 00 00 00 00	 call	 _RawSetKey@12

; 358  : }

  00088	5d		 pop	 ebp
  00089	c2 0c 00	 ret	 12			; 0000000cH
_TripleDesSetKey@12 ENDP
_TEXT	ENDS
PUBLIC	_RtlSecureZeroMemory@8
PUBLIC	__$ArrayPad$
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Odtp
;	COMDAT _RawSetKey@12
_TEXT	SEGMENT
tv129 = -168						; size = 4
_burnm$24850 = -164					; size = 4
_burnc$24852 = -160					; size = 4
_b$24846 = -156						; size = 4
_j$ = -152						; size = 4
_m$ = -148						; size = 4
_buffer$ = -144						; size = 120
__$ArrayPad$ = -24					; size = 4
_ks$ = -20						; size = 4
_l$ = -16						; size = 4
_pcr$ = -12						; size = 4
_i$ = -8						; size = 4
_pc1m$ = -4						; size = 4
_encryption$ = 8					; size = 4
_key$ = 12						; size = 4
_scheduledKey$ = 16					; size = 4
_RawSetKey@12 PROC					; COMDAT

; 262  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 e8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	53		 push	 ebx
  00016	56		 push	 esi

; 263  : 	byte buffer[56+56+8];
; 264  : 	byte *const pc1m=buffer;                 /* place to modify pc1 into */

  00017	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  0001d	89 45 fc	 mov	 DWORD PTR _pc1m$[ebp], eax

; 265  : 	byte *const pcr=pc1m+56;                 /* place to rotate pc1 into */

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _pc1m$[ebp]
  00023	83 c1 38	 add	 ecx, 56			; 00000038H
  00026	89 4d f4	 mov	 DWORD PTR _pcr$[ebp], ecx

; 266  : 	byte *const ks=pcr+56;

  00029	8b 55 f4	 mov	 edx, DWORD PTR _pcr$[ebp]
  0002c	83 c2 38	 add	 edx, 56			; 00000038H
  0002f	89 55 ec	 mov	 DWORD PTR _ks$[ebp], edx

; 267  : 	register int i,j,l;
; 268  : 	int m;
; 269  : 	
; 270  : 	for (j=0; j<56; j++) {          /* convert pc1 to bits of key */

  00032	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$[ebp], 0
  0003c	eb 0f		 jmp	 SHORT $LN22@RawSetKey
$LN21@RawSetKey:
  0003e	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  00044	83 c0 01	 add	 eax, 1
  00047	89 85 68 ff ff
	ff		 mov	 DWORD PTR _j$[ebp], eax
$LN22@RawSetKey:
  0004d	83 bd 68 ff ff
	ff 38		 cmp	 DWORD PTR _j$[ebp], 56	; 00000038H
  00054	7d 4c		 jge	 SHORT $LN20@RawSetKey

; 271  : 		l=pc1[j]-1;             /* integer bit location  */

  00056	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  0005c	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _pc1[ecx]
  00063	83 ea 01	 sub	 edx, 1
  00066	89 55 f0	 mov	 DWORD PTR _l$[ebp], edx

; 272  : 		m = l & 07;             /* find bit              */

  00069	8b 45 f0	 mov	 eax, DWORD PTR _l$[ebp]
  0006c	83 e0 07	 and	 eax, 7
  0006f	89 85 6c ff ff
	ff		 mov	 DWORD PTR _m$[ebp], eax

; 273  : 		pc1m[j]=(key[l>>3] &    /* find which key byte l is in */
; 274  : 			bytebit[m])     /* and which bit of that byte */
; 275  : 			? 1 : 0;        /* and store 1-bit result */

  00075	8b 4d f0	 mov	 ecx, DWORD PTR _l$[ebp]
  00078	c1 f9 03	 sar	 ecx, 3
  0007b	8b 55 0c	 mov	 edx, DWORD PTR _key$[ebp]
  0007e	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00082	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _m$[ebp]
  00088	23 04 8d 00 00
	00 00		 and	 eax, DWORD PTR _bytebit[ecx*4]
  0008f	f7 d8		 neg	 eax
  00091	1b c0		 sbb	 eax, eax
  00093	f7 d8		 neg	 eax
  00095	8b 55 fc	 mov	 edx, DWORD PTR _pc1m$[ebp]
  00098	03 95 68 ff ff
	ff		 add	 edx, DWORD PTR _j$[ebp]
  0009e	88 02		 mov	 BYTE PTR [edx], al

; 276  : 	}

  000a0	eb 9c		 jmp	 SHORT $LN21@RawSetKey
$LN20@RawSetKey:

; 277  : 	for (i=0; i<16; i++) {          /* key chunk for each iteration */

  000a2	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000a9	eb 09		 jmp	 SHORT $LN19@RawSetKey
$LN18@RawSetKey:
  000ab	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000ae	83 c0 01	 add	 eax, 1
  000b1	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN19@RawSetKey:
  000b4	83 7d f8 10	 cmp	 DWORD PTR _i$[ebp], 16	; 00000010H
  000b8	0f 8d 83 01 00
	00		 jge	 $LN17@RawSetKey

; 278  : 		memset(ks,0,8);         /* Clear key schedule */

  000be	33 c9		 xor	 ecx, ecx
  000c0	8b 55 ec	 mov	 edx, DWORD PTR _ks$[ebp]
  000c3	89 0a		 mov	 DWORD PTR [edx], ecx
  000c5	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 279  : 		for (j=0; j<56; j++)    /* rotate pc1 the right amount */

  000c8	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$[ebp], 0
  000d2	eb 0f		 jmp	 SHORT $LN16@RawSetKey
$LN15@RawSetKey:
  000d4	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  000da	83 c0 01	 add	 eax, 1
  000dd	89 85 68 ff ff
	ff		 mov	 DWORD PTR _j$[ebp], eax
$LN16@RawSetKey:
  000e3	83 bd 68 ff ff
	ff 38		 cmp	 DWORD PTR _j$[ebp], 56	; 00000038H
  000ea	7d 5c		 jge	 SHORT $LN14@RawSetKey

; 280  : 			pcr[j] = pc1m[(l=j+totrot[i])<(j<28? 28 : 56) ? l: l-28];

  000ec	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000ef	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _totrot[ecx]
  000f6	03 95 68 ff ff
	ff		 add	 edx, DWORD PTR _j$[ebp]
  000fc	89 55 f0	 mov	 DWORD PTR _l$[ebp], edx
  000ff	33 c0		 xor	 eax, eax
  00101	83 bd 68 ff ff
	ff 1c		 cmp	 DWORD PTR _j$[ebp], 28	; 0000001cH
  00108	0f 9d c0	 setge	 al
  0010b	83 e8 01	 sub	 eax, 1
  0010e	83 e0 e4	 and	 eax, -28		; ffffffe4H
  00111	83 c0 38	 add	 eax, 56			; 00000038H
  00114	39 45 f0	 cmp	 DWORD PTR _l$[ebp], eax
  00117	7d 0b		 jge	 SHORT $LN25@RawSetKey
  00119	8b 4d f0	 mov	 ecx, DWORD PTR _l$[ebp]
  0011c	89 8d 58 ff ff
	ff		 mov	 DWORD PTR tv129[ebp], ecx
  00122	eb 0c		 jmp	 SHORT $LN26@RawSetKey
$LN25@RawSetKey:
  00124	8b 55 f0	 mov	 edx, DWORD PTR _l$[ebp]
  00127	83 ea 1c	 sub	 edx, 28			; 0000001cH
  0012a	89 95 58 ff ff
	ff		 mov	 DWORD PTR tv129[ebp], edx
$LN26@RawSetKey:
  00130	8b 45 f4	 mov	 eax, DWORD PTR _pcr$[ebp]
  00133	03 85 68 ff ff
	ff		 add	 eax, DWORD PTR _j$[ebp]
  00139	8b 4d fc	 mov	 ecx, DWORD PTR _pc1m$[ebp]
  0013c	03 8d 58 ff ff
	ff		 add	 ecx, DWORD PTR tv129[ebp]
  00142	8a 11		 mov	 dl, BYTE PTR [ecx]
  00144	88 10		 mov	 BYTE PTR [eax], dl
  00146	eb 8c		 jmp	 SHORT $LN15@RawSetKey
$LN14@RawSetKey:

; 281  : 		/* rotate left and right halves independently */
; 282  : 		for (j=0; j<48; j++){   /* select bits individually */

  00148	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$[ebp], 0
  00152	eb 0f		 jmp	 SHORT $LN13@RawSetKey
$LN12@RawSetKey:
  00154	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  0015a	83 c0 01	 add	 eax, 1
  0015d	89 85 68 ff ff
	ff		 mov	 DWORD PTR _j$[ebp], eax
$LN13@RawSetKey:
  00163	83 bd 68 ff ff
	ff 30		 cmp	 DWORD PTR _j$[ebp], 48	; 00000030H
  0016a	7d 64		 jge	 SHORT $LN11@RawSetKey

; 283  : 			/* check bit that goes to ks[j] */
; 284  : 			if (pcr[pc2[j]-1]){

  0016c	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  00172	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _pc2[ecx]
  00179	8b 45 f4	 mov	 eax, DWORD PTR _pcr$[ebp]
  0017c	0f b6 4c 10 ff	 movzx	 ecx, BYTE PTR [eax+edx-1]
  00181	85 c9		 test	 ecx, ecx
  00183	74 49		 je	 SHORT $LN10@RawSetKey

; 285  : 				/* mask it in if it's there */
; 286  : 				l= j % 6;

  00185	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  0018b	99		 cdq
  0018c	b9 06 00 00 00	 mov	 ecx, 6
  00191	f7 f9		 idiv	 ecx
  00193	89 55 f0	 mov	 DWORD PTR _l$[ebp], edx

; 287  : 				ks[j/6] |= bytebit[l] >> 2;

  00196	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  0019c	99		 cdq
  0019d	b9 06 00 00 00	 mov	 ecx, 6
  001a2	f7 f9		 idiv	 ecx
  001a4	8b 55 f0	 mov	 edx, DWORD PTR _l$[ebp]
  001a7	8b 0c 95 00 00
	00 00		 mov	 ecx, DWORD PTR _bytebit[edx*4]
  001ae	c1 f9 02	 sar	 ecx, 2
  001b1	8b 55 ec	 mov	 edx, DWORD PTR _ks$[ebp]
  001b4	0f b6 1c 02	 movzx	 ebx, BYTE PTR [edx+eax]
  001b8	0b d9		 or	 ebx, ecx
  001ba	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  001c0	99		 cdq
  001c1	b9 06 00 00 00	 mov	 ecx, 6
  001c6	f7 f9		 idiv	 ecx
  001c8	8b 55 ec	 mov	 edx, DWORD PTR _ks$[ebp]
  001cb	88 1c 02	 mov	 BYTE PTR [edx+eax], bl
$LN10@RawSetKey:

; 288  : 			}
; 289  : 		}

  001ce	eb 84		 jmp	 SHORT $LN12@RawSetKey
$LN11@RawSetKey:

; 290  : 		/* Now convert to odd/even interleaved form for use in F */
; 291  : 		scheduledKey[2*i] = ((word32)ks[0] << 24)
; 292  : 			| ((word32)ks[2] << 16)
; 293  : 			| ((word32)ks[4] << 8)
; 294  : 			| ((word32)ks[6]);

  001d0	8b 45 ec	 mov	 eax, DWORD PTR _ks$[ebp]
  001d3	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  001d6	c1 e1 18	 shl	 ecx, 24			; 00000018H
  001d9	8b 55 ec	 mov	 edx, DWORD PTR _ks$[ebp]
  001dc	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  001e0	c1 e0 10	 shl	 eax, 16			; 00000010H
  001e3	0b c8		 or	 ecx, eax
  001e5	8b 55 ec	 mov	 edx, DWORD PTR _ks$[ebp]
  001e8	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  001ec	c1 e0 08	 shl	 eax, 8
  001ef	0b c8		 or	 ecx, eax
  001f1	8b 55 ec	 mov	 edx, DWORD PTR _ks$[ebp]
  001f4	0f b6 42 06	 movzx	 eax, BYTE PTR [edx+6]
  001f8	0b c8		 or	 ecx, eax
  001fa	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  001fd	d1 e2		 shl	 edx, 1
  001ff	8b 45 10	 mov	 eax, DWORD PTR _scheduledKey$[ebp]
  00202	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 295  : 		scheduledKey[2*i+1] = ((word32)ks[1] << 24)
; 296  : 			| ((word32)ks[3] << 16)
; 297  : 			| ((word32)ks[5] << 8)
; 298  : 			| ((word32)ks[7]);

  00205	8b 4d ec	 mov	 ecx, DWORD PTR _ks$[ebp]
  00208	0f b6 51 01	 movzx	 edx, BYTE PTR [ecx+1]
  0020c	c1 e2 18	 shl	 edx, 24			; 00000018H
  0020f	8b 45 ec	 mov	 eax, DWORD PTR _ks$[ebp]
  00212	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00216	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00219	0b d1		 or	 edx, ecx
  0021b	8b 45 ec	 mov	 eax, DWORD PTR _ks$[ebp]
  0021e	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00222	c1 e1 08	 shl	 ecx, 8
  00225	0b d1		 or	 edx, ecx
  00227	8b 45 ec	 mov	 eax, DWORD PTR _ks$[ebp]
  0022a	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  0022e	0b d1		 or	 edx, ecx
  00230	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00233	d1 e0		 shl	 eax, 1
  00235	8b 4d 10	 mov	 ecx, DWORD PTR _scheduledKey$[ebp]
  00238	89 54 81 04	 mov	 DWORD PTR [ecx+eax*4+4], edx

; 299  : 	}

  0023c	e9 6a fe ff ff	 jmp	 $LN18@RawSetKey
$LN17@RawSetKey:

; 300  : 	
; 301  : 	if (!encryption)     // reverse key schedule order

  00241	83 7d 08 00	 cmp	 DWORD PTR _encryption$[ebp], 0
  00245	0f 85 93 00 00
	00		 jne	 $LN5@RawSetKey

; 302  : 		for (i=0; i<16; i+=2)

  0024b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00252	eb 09		 jmp	 SHORT $LN8@RawSetKey
$LN7@RawSetKey:
  00254	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00257	83 c2 02	 add	 edx, 2
  0025a	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$LN8@RawSetKey:
  0025d	83 7d f8 10	 cmp	 DWORD PTR _i$[ebp], 16	; 00000010H
  00261	7d 7b		 jge	 SHORT $LN5@RawSetKey

; 303  : 		{
; 304  : 			word32 b = scheduledKey[i];

  00263	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00266	8b 4d 10	 mov	 ecx, DWORD PTR _scheduledKey$[ebp]
  00269	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0026c	89 95 64 ff ff
	ff		 mov	 DWORD PTR _b$24846[ebp], edx

; 305  : 			scheduledKey[i] = scheduledKey[32-2-i];

  00272	b8 1e 00 00 00	 mov	 eax, 30			; 0000001eH
  00277	2b 45 f8	 sub	 eax, DWORD PTR _i$[ebp]
  0027a	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0027d	8b 55 10	 mov	 edx, DWORD PTR _scheduledKey$[ebp]
  00280	8b 75 10	 mov	 esi, DWORD PTR _scheduledKey$[ebp]
  00283	8b 04 86	 mov	 eax, DWORD PTR [esi+eax*4]
  00286	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 306  : 			scheduledKey[32-2-i] = b;

  00289	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  0028e	2b 4d f8	 sub	 ecx, DWORD PTR _i$[ebp]
  00291	8b 55 10	 mov	 edx, DWORD PTR _scheduledKey$[ebp]
  00294	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _b$24846[ebp]
  0029a	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 307  : 
; 308  : 			b = scheduledKey[i+1];

  0029d	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  002a0	8b 55 10	 mov	 edx, DWORD PTR _scheduledKey$[ebp]
  002a3	8b 44 8a 04	 mov	 eax, DWORD PTR [edx+ecx*4+4]
  002a7	89 85 64 ff ff
	ff		 mov	 DWORD PTR _b$24846[ebp], eax

; 309  : 			scheduledKey[i+1] = scheduledKey[32-1-i];

  002ad	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  002b2	2b 4d f8	 sub	 ecx, DWORD PTR _i$[ebp]
  002b5	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  002b8	8b 45 10	 mov	 eax, DWORD PTR _scheduledKey$[ebp]
  002bb	8b 75 10	 mov	 esi, DWORD PTR _scheduledKey$[ebp]
  002be	8b 0c 8e	 mov	 ecx, DWORD PTR [esi+ecx*4]
  002c1	89 4c 90 04	 mov	 DWORD PTR [eax+edx*4+4], ecx

; 310  : 			scheduledKey[32-1-i] = b;

  002c5	ba 1f 00 00 00	 mov	 edx, 31			; 0000001fH
  002ca	2b 55 f8	 sub	 edx, DWORD PTR _i$[ebp]
  002cd	8b 45 10	 mov	 eax, DWORD PTR _scheduledKey$[ebp]
  002d0	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _b$24846[ebp]
  002d6	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 311  : 		}

  002d9	e9 76 ff ff ff	 jmp	 $LN7@RawSetKey
$LN5@RawSetKey:

; 312  : 
; 313  : 	burn (buffer, sizeof (buffer));

  002de	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR _buffer$[ebp]
  002e4	89 95 5c ff ff
	ff		 mov	 DWORD PTR _burnm$24850[ebp], edx
  002ea	c7 85 60 ff ff
	ff 78 00 00 00	 mov	 DWORD PTR _burnc$24852[ebp], 120 ; 00000078H
  002f4	6a 78		 push	 120			; 00000078H
  002f6	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  002fc	50		 push	 eax
  002fd	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@RawSetKey:
  00302	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _burnc$24852[ebp]
  00308	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _burnc$24852[ebp]
  0030e	83 ea 01	 sub	 edx, 1
  00311	89 95 60 ff ff
	ff		 mov	 DWORD PTR _burnc$24852[ebp], edx
  00317	85 c9		 test	 ecx, ecx
  00319	74 1a		 je	 SHORT $LN4@RawSetKey
  0031b	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _burnm$24850[ebp]
  00321	c6 00 00	 mov	 BYTE PTR [eax], 0
  00324	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _burnm$24850[ebp]
  0032a	83 c1 01	 add	 ecx, 1
  0032d	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _burnm$24850[ebp], ecx
  00333	eb cd		 jmp	 SHORT $LN2@RawSetKey
$LN4@RawSetKey:
  00335	33 d2		 xor	 edx, edx
  00337	75 a5		 jne	 SHORT $LN5@RawSetKey

; 314  : }

  00339	5e		 pop	 esi
  0033a	5b		 pop	 ebx
  0033b	8b 4d e8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0033e	33 cd		 xor	 ecx, ebp
  00340	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00345	8b e5		 mov	 esp, ebp
  00347	5d		 pop	 ebp
  00348	c2 0c 00	 ret	 12			; 0000000cH
_RawSetKey@12 ENDP
; Function compile flags: /Odtp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT _RtlSecureZeroMemory@8
_TEXT	SEGMENT
_vptr$ = -4						; size = 4
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory@8 PROC				; COMDAT

; 8322 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 8323 :     volatile char *vptr = (volatile char *)ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _vptr$[ebp], eax
$LN2@RtlSecureZ:

; 8324 : 
; 8325 : #if defined(_M_AMD64)
; 8326 : 
; 8327 :         __stosb((PUCHAR)((ULONG64)vptr), 0, cnt);
; 8328 : 
; 8329 : #else
; 8330 : 
; 8331 :     while (cnt) {

  0000c	83 7d 0c 00	 cmp	 DWORD PTR _cnt$[ebp], 0
  00010	74 1a		 je	 SHORT $LN1@RtlSecureZ

; 8332 :         *vptr = 0;

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _vptr$[ebp]
  00015	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 8333 :         vptr++;

  00018	8b 55 fc	 mov	 edx, DWORD PTR _vptr$[ebp]
  0001b	83 c2 01	 add	 edx, 1
  0001e	89 55 fc	 mov	 DWORD PTR _vptr$[ebp], edx

; 8334 :         cnt--;

  00021	8b 45 0c	 mov	 eax, DWORD PTR _cnt$[ebp]
  00024	83 e8 01	 sub	 eax, 1
  00027	89 45 0c	 mov	 DWORD PTR _cnt$[ebp], eax

; 8335 :     }

  0002a	eb e0		 jmp	 SHORT $LN2@RtlSecureZ
$LN1@RtlSecureZ:

; 8336 : 
; 8337 : #endif
; 8338 : 
; 8339 :     return ptr;

  0002c	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]

; 8340 : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
_RtlSecureZeroMemory@8 ENDP
_TEXT	ENDS
PUBLIC	_TripleDesEncrypt@16
EXTRN	_MirrorBytes32@4:PROC
; Function compile flags: /Odtp
; File c:\users\public\desktop\projects\ciphershed\src\crypto\des.c
;	COMDAT _TripleDesEncrypt@16
_TEXT	SEGMENT
tv155 = -24						; size = 4
tv148 = -20						; size = 4
tv141 = -16						; size = 4
_right$ = -12						; size = 4
_left$ = -8						; size = 4
_work$ = -4						; size = 4
_inBlock$ = 8						; size = 4
_outBlock$ = 12						; size = 4
_key$ = 16						; size = 4
_encrypt$ = 20						; size = 4
_TripleDesEncrypt@16 PROC				; COMDAT

; 361  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 18	 sub	 esp, 24			; 00000018H

; 362  : 	word32 left = BE32 (((word32 *)inBlock)[0]);

  00008	8b 45 08	 mov	 eax, DWORD PTR _inBlock$[ebp]
  0000b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 _MirrorBytes32@4
  00013	89 45 f8	 mov	 DWORD PTR _left$[ebp], eax

; 363  : 	word32 right = BE32 (((word32 *)inBlock)[1]);

  00016	8b 55 08	 mov	 edx, DWORD PTR _inBlock$[ebp]
  00019	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _MirrorBytes32@4
  00022	89 45 f4	 mov	 DWORD PTR _right$[ebp], eax

; 364  : 	word32 work;
; 365  : 
; 366  : 	right = rotlFixed(right, 4U);

  00025	6a 04		 push	 4
  00027	8b 4d f4	 mov	 ecx, DWORD PTR _right$[ebp]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 _rotlFixed@8
  00030	89 45 f4	 mov	 DWORD PTR _right$[ebp], eax

; 367  : 	work = (left ^ right) & 0xf0f0f0f0;

  00033	8b 55 f8	 mov	 edx, DWORD PTR _left$[ebp]
  00036	33 55 f4	 xor	 edx, DWORD PTR _right$[ebp]
  00039	81 e2 f0 f0 f0
	f0		 and	 edx, -252645136		; f0f0f0f0H
  0003f	89 55 fc	 mov	 DWORD PTR _work$[ebp], edx

; 368  : 	left ^= work;

  00042	8b 45 f8	 mov	 eax, DWORD PTR _left$[ebp]
  00045	33 45 fc	 xor	 eax, DWORD PTR _work$[ebp]
  00048	89 45 f8	 mov	 DWORD PTR _left$[ebp], eax

; 369  : 	right = rotrFixed(right^work, 20U);

  0004b	6a 14		 push	 20			; 00000014H
  0004d	8b 4d f4	 mov	 ecx, DWORD PTR _right$[ebp]
  00050	33 4d fc	 xor	 ecx, DWORD PTR _work$[ebp]
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 _rotrFixed@8
  00059	89 45 f4	 mov	 DWORD PTR _right$[ebp], eax

; 370  : 	work = (left ^ right) & 0xffff0000;

  0005c	8b 55 f8	 mov	 edx, DWORD PTR _left$[ebp]
  0005f	33 55 f4	 xor	 edx, DWORD PTR _right$[ebp]
  00062	81 e2 00 00 ff
	ff		 and	 edx, -65536		; ffff0000H
  00068	89 55 fc	 mov	 DWORD PTR _work$[ebp], edx

; 371  : 	left ^= work;

  0006b	8b 45 f8	 mov	 eax, DWORD PTR _left$[ebp]
  0006e	33 45 fc	 xor	 eax, DWORD PTR _work$[ebp]
  00071	89 45 f8	 mov	 DWORD PTR _left$[ebp], eax

; 372  : 	right = rotrFixed(right^work, 18U);

  00074	6a 12		 push	 18			; 00000012H
  00076	8b 4d f4	 mov	 ecx, DWORD PTR _right$[ebp]
  00079	33 4d fc	 xor	 ecx, DWORD PTR _work$[ebp]
  0007c	51		 push	 ecx
  0007d	e8 00 00 00 00	 call	 _rotrFixed@8
  00082	89 45 f4	 mov	 DWORD PTR _right$[ebp], eax

; 373  : 	work = (left ^ right) & 0x33333333;

  00085	8b 55 f8	 mov	 edx, DWORD PTR _left$[ebp]
  00088	33 55 f4	 xor	 edx, DWORD PTR _right$[ebp]
  0008b	81 e2 33 33 33
	33		 and	 edx, 858993459		; 33333333H
  00091	89 55 fc	 mov	 DWORD PTR _work$[ebp], edx

; 374  : 	left ^= work;

  00094	8b 45 f8	 mov	 eax, DWORD PTR _left$[ebp]
  00097	33 45 fc	 xor	 eax, DWORD PTR _work$[ebp]
  0009a	89 45 f8	 mov	 DWORD PTR _left$[ebp], eax

; 375  : 	right = rotrFixed(right^work, 6U);

  0009d	6a 06		 push	 6
  0009f	8b 4d f4	 mov	 ecx, DWORD PTR _right$[ebp]
  000a2	33 4d fc	 xor	 ecx, DWORD PTR _work$[ebp]
  000a5	51		 push	 ecx
  000a6	e8 00 00 00 00	 call	 _rotrFixed@8
  000ab	89 45 f4	 mov	 DWORD PTR _right$[ebp], eax

; 376  : 	work = (left ^ right) & 0x00ff00ff;

  000ae	8b 55 f8	 mov	 edx, DWORD PTR _left$[ebp]
  000b1	33 55 f4	 xor	 edx, DWORD PTR _right$[ebp]
  000b4	81 e2 ff 00 ff
	00		 and	 edx, 16711935		; 00ff00ffH
  000ba	89 55 fc	 mov	 DWORD PTR _work$[ebp], edx

; 377  : 	left ^= work;

  000bd	8b 45 f8	 mov	 eax, DWORD PTR _left$[ebp]
  000c0	33 45 fc	 xor	 eax, DWORD PTR _work$[ebp]
  000c3	89 45 f8	 mov	 DWORD PTR _left$[ebp], eax

; 378  : 	right = rotlFixed(right^work, 9U);

  000c6	6a 09		 push	 9
  000c8	8b 4d f4	 mov	 ecx, DWORD PTR _right$[ebp]
  000cb	33 4d fc	 xor	 ecx, DWORD PTR _work$[ebp]
  000ce	51		 push	 ecx
  000cf	e8 00 00 00 00	 call	 _rotlFixed@8
  000d4	89 45 f4	 mov	 DWORD PTR _right$[ebp], eax

; 379  : 	work = (left ^ right) & 0xaaaaaaaa;

  000d7	8b 55 f8	 mov	 edx, DWORD PTR _left$[ebp]
  000da	33 55 f4	 xor	 edx, DWORD PTR _right$[ebp]
  000dd	81 e2 aa aa aa
	aa		 and	 edx, -1431655766	; aaaaaaaaH
  000e3	89 55 fc	 mov	 DWORD PTR _work$[ebp], edx

; 380  : 	left = rotlFixed(left^work, 1U);

  000e6	6a 01		 push	 1
  000e8	8b 45 f8	 mov	 eax, DWORD PTR _left$[ebp]
  000eb	33 45 fc	 xor	 eax, DWORD PTR _work$[ebp]
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 _rotlFixed@8
  000f4	89 45 f8	 mov	 DWORD PTR _left$[ebp], eax

; 381  : 	right ^= work;

  000f7	8b 4d f4	 mov	 ecx, DWORD PTR _right$[ebp]
  000fa	33 4d fc	 xor	 ecx, DWORD PTR _work$[ebp]
  000fd	89 4d f4	 mov	 DWORD PTR _right$[ebp], ecx

; 382  : 
; 383  : 	RawProcessBlock (&left, &right, encrypt ? key->k1 : key->k1d);

  00100	83 7d 14 00	 cmp	 DWORD PTR _encrypt$[ebp], 0
  00104	74 08		 je	 SHORT $LN3@TripleDesE
  00106	8b 55 10	 mov	 edx, DWORD PTR _key$[ebp]
  00109	89 55 f0	 mov	 DWORD PTR tv141[ebp], edx
  0010c	eb 0b		 jmp	 SHORT $LN4@TripleDesE
$LN3@TripleDesE:
  0010e	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  00111	05 80 01 00 00	 add	 eax, 384		; 00000180H
  00116	89 45 f0	 mov	 DWORD PTR tv141[ebp], eax
$LN4@TripleDesE:
  00119	8b 4d f0	 mov	 ecx, DWORD PTR tv141[ebp]
  0011c	51		 push	 ecx
  0011d	8d 55 f4	 lea	 edx, DWORD PTR _right$[ebp]
  00120	52		 push	 edx
  00121	8d 45 f8	 lea	 eax, DWORD PTR _left$[ebp]
  00124	50		 push	 eax
  00125	e8 00 00 00 00	 call	 _RawProcessBlock@12

; 384  : 	RawProcessBlock (&right, &left, !encrypt ? key->k2 : key->k2d);

  0012a	83 7d 14 00	 cmp	 DWORD PTR _encrypt$[ebp], 0
  0012e	75 0e		 jne	 SHORT $LN5@TripleDesE
  00130	8b 4d 10	 mov	 ecx, DWORD PTR _key$[ebp]
  00133	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00139	89 4d ec	 mov	 DWORD PTR tv148[ebp], ecx
  0013c	eb 0c		 jmp	 SHORT $LN6@TripleDesE
$LN5@TripleDesE:
  0013e	8b 55 10	 mov	 edx, DWORD PTR _key$[ebp]
  00141	81 c2 00 02 00
	00		 add	 edx, 512		; 00000200H
  00147	89 55 ec	 mov	 DWORD PTR tv148[ebp], edx
$LN6@TripleDesE:
  0014a	8b 45 ec	 mov	 eax, DWORD PTR tv148[ebp]
  0014d	50		 push	 eax
  0014e	8d 4d f8	 lea	 ecx, DWORD PTR _left$[ebp]
  00151	51		 push	 ecx
  00152	8d 55 f4	 lea	 edx, DWORD PTR _right$[ebp]
  00155	52		 push	 edx
  00156	e8 00 00 00 00	 call	 _RawProcessBlock@12

; 385  : 	RawProcessBlock (&left, &right, encrypt ? key->k3 : key->k3d);

  0015b	83 7d 14 00	 cmp	 DWORD PTR _encrypt$[ebp], 0
  0015f	74 0d		 je	 SHORT $LN7@TripleDesE
  00161	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  00164	05 00 01 00 00	 add	 eax, 256		; 00000100H
  00169	89 45 e8	 mov	 DWORD PTR tv155[ebp], eax
  0016c	eb 0c		 jmp	 SHORT $LN8@TripleDesE
$LN7@TripleDesE:
  0016e	8b 4d 10	 mov	 ecx, DWORD PTR _key$[ebp]
  00171	81 c1 80 02 00
	00		 add	 ecx, 640		; 00000280H
  00177	89 4d e8	 mov	 DWORD PTR tv155[ebp], ecx
$LN8@TripleDesE:
  0017a	8b 55 e8	 mov	 edx, DWORD PTR tv155[ebp]
  0017d	52		 push	 edx
  0017e	8d 45 f4	 lea	 eax, DWORD PTR _right$[ebp]
  00181	50		 push	 eax
  00182	8d 4d f8	 lea	 ecx, DWORD PTR _left$[ebp]
  00185	51		 push	 ecx
  00186	e8 00 00 00 00	 call	 _RawProcessBlock@12

; 386  : 	
; 387  : 	right = rotrFixed(right, 1U);

  0018b	6a 01		 push	 1
  0018d	8b 55 f4	 mov	 edx, DWORD PTR _right$[ebp]
  00190	52		 push	 edx
  00191	e8 00 00 00 00	 call	 _rotrFixed@8
  00196	89 45 f4	 mov	 DWORD PTR _right$[ebp], eax

; 388  : 	work = (left ^ right) & 0xaaaaaaaa;

  00199	8b 45 f8	 mov	 eax, DWORD PTR _left$[ebp]
  0019c	33 45 f4	 xor	 eax, DWORD PTR _right$[ebp]
  0019f	25 aa aa aa aa	 and	 eax, -1431655766	; aaaaaaaaH
  001a4	89 45 fc	 mov	 DWORD PTR _work$[ebp], eax

; 389  : 	right ^= work;

  001a7	8b 4d f4	 mov	 ecx, DWORD PTR _right$[ebp]
  001aa	33 4d fc	 xor	 ecx, DWORD PTR _work$[ebp]
  001ad	89 4d f4	 mov	 DWORD PTR _right$[ebp], ecx

; 390  : 	left = rotrFixed(left^work, 9U);

  001b0	6a 09		 push	 9
  001b2	8b 55 f8	 mov	 edx, DWORD PTR _left$[ebp]
  001b5	33 55 fc	 xor	 edx, DWORD PTR _work$[ebp]
  001b8	52		 push	 edx
  001b9	e8 00 00 00 00	 call	 _rotrFixed@8
  001be	89 45 f8	 mov	 DWORD PTR _left$[ebp], eax

; 391  : 	work = (left ^ right) & 0x00ff00ff;

  001c1	8b 45 f8	 mov	 eax, DWORD PTR _left$[ebp]
  001c4	33 45 f4	 xor	 eax, DWORD PTR _right$[ebp]
  001c7	25 ff 00 ff 00	 and	 eax, 16711935		; 00ff00ffH
  001cc	89 45 fc	 mov	 DWORD PTR _work$[ebp], eax

; 392  : 	right ^= work;

  001cf	8b 4d f4	 mov	 ecx, DWORD PTR _right$[ebp]
  001d2	33 4d fc	 xor	 ecx, DWORD PTR _work$[ebp]
  001d5	89 4d f4	 mov	 DWORD PTR _right$[ebp], ecx

; 393  : 	left = rotlFixed(left^work, 6U);

  001d8	6a 06		 push	 6
  001da	8b 55 f8	 mov	 edx, DWORD PTR _left$[ebp]
  001dd	33 55 fc	 xor	 edx, DWORD PTR _work$[ebp]
  001e0	52		 push	 edx
  001e1	e8 00 00 00 00	 call	 _rotlFixed@8
  001e6	89 45 f8	 mov	 DWORD PTR _left$[ebp], eax

; 394  : 	work = (left ^ right) & 0x33333333;

  001e9	8b 45 f8	 mov	 eax, DWORD PTR _left$[ebp]
  001ec	33 45 f4	 xor	 eax, DWORD PTR _right$[ebp]
  001ef	25 33 33 33 33	 and	 eax, 858993459		; 33333333H
  001f4	89 45 fc	 mov	 DWORD PTR _work$[ebp], eax

; 395  : 	right ^= work;

  001f7	8b 4d f4	 mov	 ecx, DWORD PTR _right$[ebp]
  001fa	33 4d fc	 xor	 ecx, DWORD PTR _work$[ebp]
  001fd	89 4d f4	 mov	 DWORD PTR _right$[ebp], ecx

; 396  : 	left = rotlFixed(left^work, 18U);

  00200	6a 12		 push	 18			; 00000012H
  00202	8b 55 f8	 mov	 edx, DWORD PTR _left$[ebp]
  00205	33 55 fc	 xor	 edx, DWORD PTR _work$[ebp]
  00208	52		 push	 edx
  00209	e8 00 00 00 00	 call	 _rotlFixed@8
  0020e	89 45 f8	 mov	 DWORD PTR _left$[ebp], eax

; 397  : 	work = (left ^ right) & 0xffff0000;

  00211	8b 45 f8	 mov	 eax, DWORD PTR _left$[ebp]
  00214	33 45 f4	 xor	 eax, DWORD PTR _right$[ebp]
  00217	25 00 00 ff ff	 and	 eax, -65536		; ffff0000H
  0021c	89 45 fc	 mov	 DWORD PTR _work$[ebp], eax

; 398  : 	right ^= work;

  0021f	8b 4d f4	 mov	 ecx, DWORD PTR _right$[ebp]
  00222	33 4d fc	 xor	 ecx, DWORD PTR _work$[ebp]
  00225	89 4d f4	 mov	 DWORD PTR _right$[ebp], ecx

; 399  : 	left = rotlFixed(left^work, 20U);

  00228	6a 14		 push	 20			; 00000014H
  0022a	8b 55 f8	 mov	 edx, DWORD PTR _left$[ebp]
  0022d	33 55 fc	 xor	 edx, DWORD PTR _work$[ebp]
  00230	52		 push	 edx
  00231	e8 00 00 00 00	 call	 _rotlFixed@8
  00236	89 45 f8	 mov	 DWORD PTR _left$[ebp], eax

; 400  : 	work = (left ^ right) & 0xf0f0f0f0;

  00239	8b 45 f8	 mov	 eax, DWORD PTR _left$[ebp]
  0023c	33 45 f4	 xor	 eax, DWORD PTR _right$[ebp]
  0023f	25 f0 f0 f0 f0	 and	 eax, -252645136		; f0f0f0f0H
  00244	89 45 fc	 mov	 DWORD PTR _work$[ebp], eax

; 401  : 	right ^= work;

  00247	8b 4d f4	 mov	 ecx, DWORD PTR _right$[ebp]
  0024a	33 4d fc	 xor	 ecx, DWORD PTR _work$[ebp]
  0024d	89 4d f4	 mov	 DWORD PTR _right$[ebp], ecx

; 402  : 	left = rotrFixed(left^work, 4U);

  00250	6a 04		 push	 4
  00252	8b 55 f8	 mov	 edx, DWORD PTR _left$[ebp]
  00255	33 55 fc	 xor	 edx, DWORD PTR _work$[ebp]
  00258	52		 push	 edx
  00259	e8 00 00 00 00	 call	 _rotrFixed@8
  0025e	89 45 f8	 mov	 DWORD PTR _left$[ebp], eax

; 403  : 
; 404  : 	((word32 *)outBlock)[0] = BE32 (right);

  00261	8b 45 f4	 mov	 eax, DWORD PTR _right$[ebp]
  00264	50		 push	 eax
  00265	e8 00 00 00 00	 call	 _MirrorBytes32@4
  0026a	8b 4d 0c	 mov	 ecx, DWORD PTR _outBlock$[ebp]
  0026d	89 01		 mov	 DWORD PTR [ecx], eax

; 405  : 	((word32 *)outBlock)[1] = BE32 (left);

  0026f	8b 55 f8	 mov	 edx, DWORD PTR _left$[ebp]
  00272	52		 push	 edx
  00273	e8 00 00 00 00	 call	 _MirrorBytes32@4
  00278	8b 4d 0c	 mov	 ecx, DWORD PTR _outBlock$[ebp]
  0027b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 406  : }

  0027e	8b e5		 mov	 esp, ebp
  00280	5d		 pop	 ebp
  00281	c2 10 00	 ret	 16			; 00000010H
_TripleDesEncrypt@16 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _rotlFixed@8
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_rotlFixed@8 PROC					; COMDAT

; 31   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 32   : 	return (word32)((x<<y) | (x>>(sizeof(word32)*8-y)));

  00005	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  0000b	d3 e0		 shl	 eax, cl
  0000d	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00012	2b 4d 0c	 sub	 ecx, DWORD PTR _y$[ebp]
  00015	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  00018	d3 ea		 shr	 edx, cl
  0001a	0b c2		 or	 eax, edx

; 33   : }

  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
_rotlFixed@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _rotrFixed@8
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_rotrFixed@8 PROC					; COMDAT

; 36   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 37   : 	return (word32)((x>>y) | (x<<(sizeof(word32)*8-y)));

  00005	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  0000b	d3 e8		 shr	 eax, cl
  0000d	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00012	2b 4d 0c	 sub	 ecx, DWORD PTR _y$[ebp]
  00015	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  00018	d3 e2		 shl	 edx, cl
  0001a	0b c2		 or	 eax, edx

; 38   : }

  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
_rotrFixed@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _RawProcessBlock@12
_TEXT	SEGMENT
_work$24871 = -20					; size = 4
_r$ = -16						; size = 4
_l$ = -12						; size = 4
_kptr$ = -8						; size = 4
_i$ = -4						; size = 4
_l_$ = 8						; size = 4
_r_$ = 12						; size = 4
_k$ = 16						; size = 4
_RawProcessBlock@12 PROC				; COMDAT

; 317  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 14	 sub	 esp, 20			; 00000014H

; 318  : 	word32 l = *l_, r = *r_;

  00008	8b 45 08	 mov	 eax, DWORD PTR _l_$[ebp]
  0000b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000d	89 4d f4	 mov	 DWORD PTR _l$[ebp], ecx
  00010	8b 55 0c	 mov	 edx, DWORD PTR _r_$[ebp]
  00013	8b 02		 mov	 eax, DWORD PTR [edx]
  00015	89 45 f0	 mov	 DWORD PTR _r$[ebp], eax

; 319  : 	const word32 *kptr=k;

  00018	8b 4d 10	 mov	 ecx, DWORD PTR _k$[ebp]
  0001b	89 4d f8	 mov	 DWORD PTR _kptr$[ebp], ecx

; 320  : 	unsigned i;
; 321  : 
; 322  : 	for (i=0; i<8; i++)

  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00025	eb 09		 jmp	 SHORT $LN3@RawProcess
$LN2@RawProcess:
  00027	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0002a	83 c2 01	 add	 edx, 1
  0002d	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN3@RawProcess:
  00030	83 7d fc 08	 cmp	 DWORD PTR _i$[ebp], 8
  00034	0f 83 6c 01 00
	00		 jae	 $LN1@RawProcess

; 323  : 	{
; 324  : 		word32 work = rotrFixed(r, 4U) ^ kptr[4*i+0];

  0003a	6a 04		 push	 4
  0003c	8b 45 f0	 mov	 eax, DWORD PTR _r$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 _rotrFixed@8
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00048	c1 e1 02	 shl	 ecx, 2
  0004b	8b 55 f8	 mov	 edx, DWORD PTR _kptr$[ebp]
  0004e	33 04 8a	 xor	 eax, DWORD PTR [edx+ecx*4]
  00051	89 45 ec	 mov	 DWORD PTR _work$24871[ebp], eax

; 325  : 		l ^= Spbox[6][(work) & 0x3f]
; 326  : 		  ^  Spbox[4][(work >> 8) & 0x3f]
; 327  : 		  ^  Spbox[2][(work >> 16) & 0x3f]
; 328  : 		  ^  Spbox[0][(work >> 24) & 0x3f];

  00054	8b 45 ec	 mov	 eax, DWORD PTR _work$24871[ebp]
  00057	83 e0 3f	 and	 eax, 63			; 0000003fH
  0005a	8b 4d ec	 mov	 ecx, DWORD PTR _work$24871[ebp]
  0005d	c1 e9 08	 shr	 ecx, 8
  00060	83 e1 3f	 and	 ecx, 63			; 0000003fH
  00063	8b 14 85 00 06
	00 00		 mov	 edx, DWORD PTR _Spbox[eax*4+1536]
  0006a	33 14 8d 00 04
	00 00		 xor	 edx, DWORD PTR _Spbox[ecx*4+1024]
  00071	8b 45 ec	 mov	 eax, DWORD PTR _work$24871[ebp]
  00074	c1 e8 10	 shr	 eax, 16			; 00000010H
  00077	83 e0 3f	 and	 eax, 63			; 0000003fH
  0007a	33 14 85 00 02
	00 00		 xor	 edx, DWORD PTR _Spbox[eax*4+512]
  00081	8b 4d ec	 mov	 ecx, DWORD PTR _work$24871[ebp]
  00084	c1 e9 18	 shr	 ecx, 24			; 00000018H
  00087	83 e1 3f	 and	 ecx, 63			; 0000003fH
  0008a	33 14 8d 00 00
	00 00		 xor	 edx, DWORD PTR _Spbox[ecx*4]
  00091	33 55 f4	 xor	 edx, DWORD PTR _l$[ebp]
  00094	89 55 f4	 mov	 DWORD PTR _l$[ebp], edx

; 329  : 		work = r ^ kptr[4*i+1];

  00097	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0009a	c1 e2 02	 shl	 edx, 2
  0009d	8b 45 f8	 mov	 eax, DWORD PTR _kptr$[ebp]
  000a0	8b 4d f0	 mov	 ecx, DWORD PTR _r$[ebp]
  000a3	33 4c 90 04	 xor	 ecx, DWORD PTR [eax+edx*4+4]
  000a7	89 4d ec	 mov	 DWORD PTR _work$24871[ebp], ecx

; 330  : 		l ^= Spbox[7][(work) & 0x3f]
; 331  : 		  ^  Spbox[5][(work >> 8) & 0x3f]
; 332  : 		  ^  Spbox[3][(work >> 16) & 0x3f]
; 333  : 		  ^  Spbox[1][(work >> 24) & 0x3f];

  000aa	8b 55 ec	 mov	 edx, DWORD PTR _work$24871[ebp]
  000ad	83 e2 3f	 and	 edx, 63			; 0000003fH
  000b0	8b 45 ec	 mov	 eax, DWORD PTR _work$24871[ebp]
  000b3	c1 e8 08	 shr	 eax, 8
  000b6	83 e0 3f	 and	 eax, 63			; 0000003fH
  000b9	8b 0c 95 00 07
	00 00		 mov	 ecx, DWORD PTR _Spbox[edx*4+1792]
  000c0	33 0c 85 00 05
	00 00		 xor	 ecx, DWORD PTR _Spbox[eax*4+1280]
  000c7	8b 55 ec	 mov	 edx, DWORD PTR _work$24871[ebp]
  000ca	c1 ea 10	 shr	 edx, 16			; 00000010H
  000cd	83 e2 3f	 and	 edx, 63			; 0000003fH
  000d0	33 0c 95 00 03
	00 00		 xor	 ecx, DWORD PTR _Spbox[edx*4+768]
  000d7	8b 45 ec	 mov	 eax, DWORD PTR _work$24871[ebp]
  000da	c1 e8 18	 shr	 eax, 24			; 00000018H
  000dd	83 e0 3f	 and	 eax, 63			; 0000003fH
  000e0	33 0c 85 00 01
	00 00		 xor	 ecx, DWORD PTR _Spbox[eax*4+256]
  000e7	33 4d f4	 xor	 ecx, DWORD PTR _l$[ebp]
  000ea	89 4d f4	 mov	 DWORD PTR _l$[ebp], ecx

; 334  : 
; 335  : 		work = rotrFixed(l, 4U) ^ kptr[4*i+2];

  000ed	6a 04		 push	 4
  000ef	8b 4d f4	 mov	 ecx, DWORD PTR _l$[ebp]
  000f2	51		 push	 ecx
  000f3	e8 00 00 00 00	 call	 _rotrFixed@8
  000f8	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000fb	c1 e2 02	 shl	 edx, 2
  000fe	8b 4d f8	 mov	 ecx, DWORD PTR _kptr$[ebp]
  00101	33 44 91 08	 xor	 eax, DWORD PTR [ecx+edx*4+8]
  00105	89 45 ec	 mov	 DWORD PTR _work$24871[ebp], eax

; 336  : 		r ^= Spbox[6][(work) & 0x3f]
; 337  : 		  ^  Spbox[4][(work >> 8) & 0x3f]
; 338  : 		  ^  Spbox[2][(work >> 16) & 0x3f]
; 339  : 		  ^  Spbox[0][(work >> 24) & 0x3f];

  00108	8b 55 ec	 mov	 edx, DWORD PTR _work$24871[ebp]
  0010b	83 e2 3f	 and	 edx, 63			; 0000003fH
  0010e	8b 45 ec	 mov	 eax, DWORD PTR _work$24871[ebp]
  00111	c1 e8 08	 shr	 eax, 8
  00114	83 e0 3f	 and	 eax, 63			; 0000003fH
  00117	8b 0c 95 00 06
	00 00		 mov	 ecx, DWORD PTR _Spbox[edx*4+1536]
  0011e	33 0c 85 00 04
	00 00		 xor	 ecx, DWORD PTR _Spbox[eax*4+1024]
  00125	8b 55 ec	 mov	 edx, DWORD PTR _work$24871[ebp]
  00128	c1 ea 10	 shr	 edx, 16			; 00000010H
  0012b	83 e2 3f	 and	 edx, 63			; 0000003fH
  0012e	33 0c 95 00 02
	00 00		 xor	 ecx, DWORD PTR _Spbox[edx*4+512]
  00135	8b 45 ec	 mov	 eax, DWORD PTR _work$24871[ebp]
  00138	c1 e8 18	 shr	 eax, 24			; 00000018H
  0013b	83 e0 3f	 and	 eax, 63			; 0000003fH
  0013e	33 0c 85 00 00
	00 00		 xor	 ecx, DWORD PTR _Spbox[eax*4]
  00145	33 4d f0	 xor	 ecx, DWORD PTR _r$[ebp]
  00148	89 4d f0	 mov	 DWORD PTR _r$[ebp], ecx

; 340  : 		work = l ^ kptr[4*i+3];

  0014b	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0014e	c1 e1 02	 shl	 ecx, 2
  00151	8b 55 f8	 mov	 edx, DWORD PTR _kptr$[ebp]
  00154	8b 45 f4	 mov	 eax, DWORD PTR _l$[ebp]
  00157	33 44 8a 0c	 xor	 eax, DWORD PTR [edx+ecx*4+12]
  0015b	89 45 ec	 mov	 DWORD PTR _work$24871[ebp], eax

; 341  : 		r ^= Spbox[7][(work) & 0x3f]
; 342  : 		  ^  Spbox[5][(work >> 8) & 0x3f]
; 343  : 		  ^  Spbox[3][(work >> 16) & 0x3f]
; 344  : 		  ^  Spbox[1][(work >> 24) & 0x3f];

  0015e	8b 4d ec	 mov	 ecx, DWORD PTR _work$24871[ebp]
  00161	83 e1 3f	 and	 ecx, 63			; 0000003fH
  00164	8b 55 ec	 mov	 edx, DWORD PTR _work$24871[ebp]
  00167	c1 ea 08	 shr	 edx, 8
  0016a	83 e2 3f	 and	 edx, 63			; 0000003fH
  0016d	8b 04 8d 00 07
	00 00		 mov	 eax, DWORD PTR _Spbox[ecx*4+1792]
  00174	33 04 95 00 05
	00 00		 xor	 eax, DWORD PTR _Spbox[edx*4+1280]
  0017b	8b 4d ec	 mov	 ecx, DWORD PTR _work$24871[ebp]
  0017e	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00181	83 e1 3f	 and	 ecx, 63			; 0000003fH
  00184	33 04 8d 00 03
	00 00		 xor	 eax, DWORD PTR _Spbox[ecx*4+768]
  0018b	8b 55 ec	 mov	 edx, DWORD PTR _work$24871[ebp]
  0018e	c1 ea 18	 shr	 edx, 24			; 00000018H
  00191	83 e2 3f	 and	 edx, 63			; 0000003fH
  00194	33 04 95 00 01
	00 00		 xor	 eax, DWORD PTR _Spbox[edx*4+256]
  0019b	33 45 f0	 xor	 eax, DWORD PTR _r$[ebp]
  0019e	89 45 f0	 mov	 DWORD PTR _r$[ebp], eax

; 345  : 	}

  001a1	e9 81 fe ff ff	 jmp	 $LN2@RawProcess
$LN1@RawProcess:

; 346  : 
; 347  : 	*l_ = l; *r_ = r;

  001a6	8b 45 08	 mov	 eax, DWORD PTR _l_$[ebp]
  001a9	8b 4d f4	 mov	 ecx, DWORD PTR _l$[ebp]
  001ac	89 08		 mov	 DWORD PTR [eax], ecx
  001ae	8b 55 0c	 mov	 edx, DWORD PTR _r_$[ebp]
  001b1	8b 45 f0	 mov	 eax, DWORD PTR _r$[ebp]
  001b4	89 02		 mov	 DWORD PTR [edx], eax

; 348  : }

  001b6	8b e5		 mov	 esp, ebp
  001b8	5d		 pop	 ebp
  001b9	c2 0c 00	 ret	 12			; 0000000cH
_RawProcessBlock@12 ENDP
_TEXT	ENDS
END
