; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\Public\Desktop\projects\ciphershed\src\Common\Xts.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_ks$GSCopy$
PUBLIC	_ks2$GSCopy$
PUBLIC	__$ArrayPad$
EXTRN	_EncipherBlocks:PROC
EXTRN	_EncipherBlock:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtpy
; File c:\users\public\desktop\projects\ciphershed\src\common\xts.c
;	COMDAT _EncryptBufferXTSParallel
_TEXT	SEGMENT
_finalCarry$ = -569					; size = 1
_startBlock$ = -568					; size = 4
_dataUnitBufPtr$ = -564					; size = 4
_whiteningValuesPtr64$ = -564				; size = 4
_blockCount$ = -560					; size = 8
_block$ = -552						; size = 4
_dataUnitNo$ = -548					; size = 8
_ks2$GSCopy$ = -540					; size = 4
_ks$GSCopy$ = -536					; size = 4
_whiteningValue$ = -532					; size = 16
_whiteningValues$ = -516				; size = 512
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_cipher$ = 28						; size = 4
_EncryptBufferXTSParallel PROC				; COMDAT
; _ks$ = ecx
; _ks2$ = edx

; 64   : {

  00000	81 ec 3c 02 00
	00		 sub	 esp, 572		; 0000023cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 38 02
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+572], eax
  00014	8b 84 24 4c 02
	00 00		 mov	 eax, DWORD PTR _startDataUnitNo$[esp+568]
  0001b	89 54 24 20	 mov	 DWORD PTR _ks2$GSCopy$[esp+572], edx

; 65   : 	unsigned __int8 finalCarry;
; 66   : 	unsigned __int8 whiteningValues [ENCRYPTION_DATA_UNIT_SIZE];
; 67   : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 68   : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 69   : 	unsigned __int64 *whiteningValuesPtr64 = (unsigned __int64 *) whiteningValues;
; 70   : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 71   : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
; 72   : 	unsigned __int64 *dataUnitBufPtr;
; 73   : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;
; 74   : 	unsigned __int64 *const finalInt64WhiteningValuesPtr = whiteningValuesPtr64 + sizeof (whiteningValues) / sizeof (*whiteningValuesPtr64) - 1;
; 75   : 	TC_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 76   : 
; 77   : 	/* The encrypted data unit number (i.e. the resultant ciphertext block) is to be multiplied in the
; 78   : 	finite field GF(2^128) by j-th power of n, where j is the sequential plaintext/ciphertext block
; 79   : 	number and n is 2, a primitive element of GF(2^128). This can be (and is) simplified and implemented
; 80   : 	as a left shift of the preceding whitening value by one bit (with carry propagating). In addition, if
; 81   : 	the shift of the highest byte results in a carry, 135 is XORed into the lowest byte. The value 135 is
; 82   : 	derived from the modulus of the Galois Field (x^128+x^7+x^2+x+1). */
; 83   : 
; 84   : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 85   : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 86   : 	dataUnitNo = startDataUnitNo->Value;

  0001f	8b 10		 mov	 edx, DWORD PTR [eax]
  00021	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00024	89 4c 24 24	 mov	 DWORD PTR _ks$GSCopy$[esp+572], ecx
  00028	8b 8c 24 50 02
	00 00		 mov	 ecx, DWORD PTR _startCipherBlockNo$[esp+568]
  0002f	89 54 24 18	 mov	 DWORD PTR _dataUnitNo$[esp+572], edx

; 87   : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 88   : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
; 89   : 
; 90   : 	if (length % BYTES_PER_XTS_BLOCK)

  00033	8b 94 24 44 02
	00 00		 mov	 edx, DWORD PTR _length$[esp+568]
  0003a	89 44 24 1c	 mov	 DWORD PTR _dataUnitNo$[esp+576], eax
  0003e	8b c2		 mov	 eax, edx
  00040	89 4c 24 04	 mov	 DWORD PTR _startBlock$[esp+572], ecx
  00044	83 e0 0f	 and	 eax, 15			; 0000000fH
  00047	33 c9		 xor	 ecx, ecx
  00049	0b c1		 or	 eax, ecx
  0004b	57		 push	 edi
  0004c	8b bc 24 44 02
	00 00		 mov	 edi, DWORD PTR _buffer$[esp+572]
  00053	74 06		 je	 SHORT $LN27@EncryptBuf

; 91   : 		TC_THROW_FATAL_EXCEPTION;

  00055	88 0d 00 00 00
	00		 mov	 BYTE PTR ds:0, cl
$LN27@EncryptBuf:

; 92   : 
; 93   : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  0005b	8b 84 24 4c 02
	00 00		 mov	 eax, DWORD PTR _length$[esp+576]
  00062	0f ac c2 04	 shrd	 edx, eax, 4
  00066	c1 e8 04	 shr	 eax, 4
  00069	89 44 24 14	 mov	 DWORD PTR _blockCount$[esp+580], eax
  0006d	89 54 24 10	 mov	 DWORD PTR _blockCount$[esp+576], edx

; 94   : 
; 95   : 	// Process all blocks in the buffer
; 96   : 	while (blockCount > 0)

  00071	3b c1		 cmp	 eax, ecx
  00073	77 08		 ja	 SHORT $LN49@EncryptBuf
  00075	3b d1		 cmp	 edx, ecx
  00077	0f 86 f6 01 00
	00		 jbe	 $LN10@EncryptBuf
$LN49@EncryptBuf:
  0007d	53		 push	 ebx
  0007e	55		 push	 ebp
  0007f	56		 push	 esi
  00080	eb 0a		 jmp	 SHORT $LN26@EncryptBuf
$LL55@EncryptBuf:
  00082	8b 44 24 20	 mov	 eax, DWORD PTR _blockCount$[esp+592]
  00086	8b 54 24 1c	 mov	 edx, DWORD PTR _blockCount$[esp+588]
  0008a	33 c9		 xor	 ecx, ecx
$LN26@EncryptBuf:

; 97   : 	{
; 98   : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  0008c	3b c1		 cmp	 eax, ecx
  0008e	77 10		 ja	 SHORT $LN56@EncryptBuf
  00090	72 05		 jb	 SHORT $LN47@EncryptBuf
  00092	83 fa 20	 cmp	 edx, 32			; 00000020H
  00095	73 09		 jae	 SHORT $LN56@EncryptBuf
$LN47@EncryptBuf:

; 99   : 			endBlock = startBlock + (unsigned int) blockCount;

  00097	8b 44 24 14	 mov	 eax, DWORD PTR _startBlock$[esp+588]
  0009b	8d 1c 02	 lea	 ebx, DWORD PTR [edx+eax]

; 100  : 		else

  0009e	eb 05		 jmp	 SHORT $LN23@EncryptBuf
$LN56@EncryptBuf:

; 101  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  000a0	bb 20 00 00 00	 mov	 ebx, 32			; 00000020H
$LN23@EncryptBuf:

; 102  : 
; 103  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
; 104  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 105  : 
; 106  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 107  : 		// whitening value for this data unit)
; 108  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  000a5	8b 54 24 28	 mov	 edx, DWORD PTR _dataUnitNo$[esp+588]
  000a9	8b 44 24 2c	 mov	 eax, DWORD PTR _dataUnitNo$[esp+592]

; 109  : 		*(whiteningValuePtr64 + 1) = 0;

  000ad	89 4c 24 40	 mov	 DWORD PTR _whiteningValue$[esp+596], ecx
  000b1	89 4c 24 44	 mov	 DWORD PTR _whiteningValue$[esp+600], ecx

; 110  : 		EncipherBlock (cipher, whiteningValue, ks2);

  000b5	8b 4c 24 30	 mov	 ecx, DWORD PTR _ks2$GSCopy$[esp+588]
  000b9	8d 74 24 38	 lea	 esi, DWORD PTR _whiteningValue$[esp+588]
  000bd	89 54 24 38	 mov	 DWORD PTR _whiteningValue$[esp+588], edx
  000c1	51		 push	 ecx
  000c2	8b d6		 mov	 edx, esi
  000c4	89 44 24 40	 mov	 DWORD PTR _whiteningValue$[esp+596], eax
  000c8	8b 84 24 68 02
	00 00		 mov	 eax, DWORD PTR _cipher$[esp+588]
  000cf	52		 push	 edx
  000d0	8d ac 24 48 02
	00 00		 lea	 ebp, DWORD PTR _whiteningValues$[esp+1100]
  000d7	50		 push	 eax
  000d8	89 6c 24 24	 mov	 DWORD PTR _whiteningValuesPtr64$[esp+600], ebp
  000dc	e8 00 00 00 00	 call	 _EncipherBlock
  000e1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 111  : 
; 112  : 		// Generate subsequent whitening values for blocks in this data unit. Note that all generated 128-bit
; 113  : 		// whitening values are stored in memory as a sequence of 64-bit integers in reverse order.
; 114  : 		for (block = 0; block < endBlock; block++)

  000e4	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _block$[esp+588], 0
  000ec	85 db		 test	 ebx, ebx
  000ee	0f 86 b0 00 00
	00		 jbe	 $LN20@EncryptBuf
  000f4	eb 0e		 jmp	 SHORT $LN22@EncryptBuf
  000f6	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL57@EncryptBuf:
  00100	8b 6c 24 18	 mov	 ebp, DWORD PTR _whiteningValuesPtr64$[esp+588]
$LN22@EncryptBuf:

; 115  : 		{
; 116  : 			if (block >= startBlock)

  00104	8b 4c 24 24	 mov	 ecx, DWORD PTR _block$[esp+588]
  00108	3b 4c 24 14	 cmp	 ecx, DWORD PTR _startBlock$[esp+588]
  0010c	72 26		 jb	 SHORT $LN19@EncryptBuf

; 117  : 			{
; 118  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64++;

  0010e	8b 16		 mov	 edx, DWORD PTR [esi]
  00110	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 119  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64;

  00113	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00116	89 55 00	 mov	 DWORD PTR [ebp], edx
  00119	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0011c	89 45 04	 mov	 DWORD PTR [ebp+4], eax
  0011f	83 c6 08	 add	 esi, 8
  00122	83 ed 08	 sub	 ebp, 8
  00125	89 4d 00	 mov	 DWORD PTR [ebp], ecx
  00128	89 55 04	 mov	 DWORD PTR [ebp+4], edx
  0012b	83 ed 08	 sub	 ebp, 8
  0012e	89 6c 24 18	 mov	 DWORD PTR _whiteningValuesPtr64$[esp+588], ebp

; 120  : 			}
; 121  : 			else

  00132	eb 03		 jmp	 SHORT $LN18@EncryptBuf
$LN19@EncryptBuf:

; 122  : 				whiteningValuePtr64++;

  00134	83 c6 08	 add	 esi, 8
$LN18@EncryptBuf:

; 123  : 
; 124  : 			// Derive the next whitening value
; 125  : 
; 126  : #if BYTE_ORDER == LITTLE_ENDIAN
; 127  : 
; 128  : 			// Little-endian platforms
; 129  : 
; 130  : 			finalCarry = 
; 131  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 132  : 				135 : 0;

  00137	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0013a	8b 06		 mov	 eax, DWORD PTR [esi]
  0013c	8b e9		 mov	 ebp, ecx
  0013e	81 e5 00 00 00
	80		 and	 ebp, -2147483648	; 80000000H
  00144	33 d2		 xor	 edx, edx
  00146	0b d5		 or	 edx, ebp
  00148	c6 44 24 13 87	 mov	 BYTE PTR _finalCarry$[esp+588], 135 ; 00000087H
  0014d	75 05		 jne	 SHORT $LN31@EncryptBuf
  0014f	c6 44 24 13 00	 mov	 BYTE PTR _finalCarry$[esp+588], 0
$LN31@EncryptBuf:

; 133  : 
; 134  : 			*whiteningValuePtr64-- <<= 1;

  00154	0f a4 c1 01	 shld	 ecx, eax, 1
  00158	03 c0		 add	 eax, eax
  0015a	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0015d	89 06		 mov	 DWORD PTR [esi], eax

; 135  : 
; 136  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  0015f	8b 6e fc	 mov	 ebp, DWORD PTR [esi-4]
  00162	8b 46 f8	 mov	 eax, DWORD PTR [esi-8]
  00165	83 ee 08	 sub	 esi, 8
  00168	8b d5		 mov	 edx, ebp
  0016a	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H
  00170	33 c9		 xor	 ecx, ecx
  00172	0b ca		 or	 ecx, edx
  00174	74 0a		 je	 SHORT $LN58@EncryptBuf

; 137  : 				*(whiteningValuePtr64 + 1) |= 1;	

  00176	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00179	83 4e 08 01	 or	 DWORD PTR [esi+8], 1
  0017d	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
$LN58@EncryptBuf:

; 138  : 
; 139  : 			*whiteningValuePtr64 <<= 1;
; 140  : #else
; 141  : 
; 142  : 			// Big-endian platforms
; 143  : 
; 144  : 			finalCarry = 
; 145  : 				(*whiteningValuePtr64 & 0x80) ?
; 146  : 				135 : 0;
; 147  : 
; 148  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 149  : 
; 150  : 			whiteningValuePtr64--;
; 151  : 
; 152  : 			if (*whiteningValuePtr64 & 0x80)
; 153  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 154  : 
; 155  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 156  : #endif
; 157  : 
; 158  : 			whiteningValue[0] ^= finalCarry;

  00180	8a 54 24 13	 mov	 dl, BYTE PTR _finalCarry$[esp+588]
  00184	0f a4 c5 01	 shld	 ebp, eax, 1
  00188	03 c0		 add	 eax, eax
  0018a	89 06		 mov	 DWORD PTR [esi], eax
  0018c	8b 44 24 24	 mov	 eax, DWORD PTR _block$[esp+588]
  00190	40		 inc	 eax
  00191	89 6e 04	 mov	 DWORD PTR [esi+4], ebp
  00194	30 54 24 38	 xor	 BYTE PTR _whiteningValue$[esp+588], dl
  00198	89 44 24 24	 mov	 DWORD PTR _block$[esp+588], eax
  0019c	3b c3		 cmp	 eax, ebx
  0019e	0f 82 5c ff ff
	ff		 jb	 $LL57@EncryptBuf
$LN20@EncryptBuf:

; 159  : 		}
; 160  : 
; 161  : 		dataUnitBufPtr = bufPtr;
; 162  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
; 163  : 
; 164  : 		// Encrypt all blocks in this data unit
; 165  : 
; 166  : 		for (block = startBlock; block < endBlock; block++)

  001a4	8b 6c 24 14	 mov	 ebp, DWORD PTR _startBlock$[esp+588]
  001a8	8b d7		 mov	 edx, edi
  001aa	89 54 24 18	 mov	 DWORD PTR _dataUnitBufPtr$[esp+588], edx
  001ae	8d 84 24 40 02
	00 00		 lea	 eax, DWORD PTR _whiteningValues$[esp+1092]
  001b5	3b eb		 cmp	 ebp, ebx
  001b7	73 2e		 jae	 SHORT $LN14@EncryptBuf
  001b9	8b cb		 mov	 ecx, ebx
  001bb	2b cd		 sub	 ecx, ebp
  001bd	8d 49 00	 npad	 3
$LL16@EncryptBuf:

; 167  : 		{
; 168  : 			// Pre-whitening
; 169  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  001c0	8b 30		 mov	 esi, DWORD PTR [eax]
  001c2	31 37		 xor	 DWORD PTR [edi], esi
  001c4	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  001c7	31 77 04	 xor	 DWORD PTR [edi+4], esi

; 170  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  001ca	8b 70 f8	 mov	 esi, DWORD PTR [eax-8]
  001cd	31 77 08	 xor	 DWORD PTR [edi+8], esi
  001d0	8b 70 fc	 mov	 esi, DWORD PTR [eax-4]
  001d3	31 77 0c	 xor	 DWORD PTR [edi+12], esi
  001d6	83 e8 08	 sub	 eax, 8
  001d9	83 c7 08	 add	 edi, 8
  001dc	83 e8 08	 sub	 eax, 8
  001df	83 c7 08	 add	 edi, 8
  001e2	83 e9 01	 sub	 ecx, 1
  001e5	75 d9		 jne	 SHORT $LL16@EncryptBuf
$LN14@EncryptBuf:

; 171  : 		}
; 172  : 
; 173  : 		// Actual encryption
; 174  : 		EncipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);

  001e7	8b 44 24 34	 mov	 eax, DWORD PTR _ks$GSCopy$[esp+588]
  001eb	8b 8c 24 64 02
	00 00		 mov	 ecx, DWORD PTR _cipher$[esp+584]
  001f2	8b f3		 mov	 esi, ebx
  001f4	2b f5		 sub	 esi, ebp
  001f6	56		 push	 esi
  001f7	50		 push	 eax
  001f8	52		 push	 edx
  001f9	51		 push	 ecx
  001fa	e8 00 00 00 00	 call	 _EncipherBlocks

; 175  : 		
; 176  : 		bufPtr = dataUnitBufPtr;

  001ff	8b 7c 24 28	 mov	 edi, DWORD PTR _dataUnitBufPtr$[esp+604]
  00203	83 c4 10	 add	 esp, 16			; 00000010H

; 177  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  00206	8d 84 24 40 02
	00 00		 lea	 eax, DWORD PTR _whiteningValues$[esp+1092]

; 178  : 
; 179  : 		for (block = startBlock; block < endBlock; block++)

  0020d	3b eb		 cmp	 ebp, ebx
  0020f	73 29		 jae	 SHORT $LN11@EncryptBuf

; 171  : 		}
; 172  : 
; 173  : 		// Actual encryption
; 174  : 		EncipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);

  00211	8b ce		 mov	 ecx, esi
$LL13@EncryptBuf:

; 180  : 		{
; 181  : 			// Post-whitening
; 182  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00213	8b 10		 mov	 edx, DWORD PTR [eax]
  00215	31 17		 xor	 DWORD PTR [edi], edx
  00217	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0021a	31 57 04	 xor	 DWORD PTR [edi+4], edx

; 183  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  0021d	8b 50 f8	 mov	 edx, DWORD PTR [eax-8]
  00220	31 57 08	 xor	 DWORD PTR [edi+8], edx
  00223	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00226	31 57 0c	 xor	 DWORD PTR [edi+12], edx
  00229	83 e8 08	 sub	 eax, 8
  0022c	83 c7 08	 add	 edi, 8
  0022f	83 e8 08	 sub	 eax, 8
  00232	83 c7 08	 add	 edi, 8
  00235	83 e9 01	 sub	 ecx, 1
  00238	75 d9		 jne	 SHORT $LL13@EncryptBuf
$LN11@EncryptBuf:

; 184  : 		}
; 185  : 
; 186  : 		blockCount -= endBlock - startBlock;

  0023a	29 74 24 1c	 sub	 DWORD PTR _blockCount$[esp+588], esi
  0023e	8b 44 24 20	 mov	 eax, DWORD PTR _blockCount$[esp+592]
  00242	b9 00 00 00 00	 mov	 ecx, 0
  00247	1b c1		 sbb	 eax, ecx

; 187  : 		startBlock = 0;
; 188  : 		dataUnitNo++;

  00249	83 44 24 28 01	 add	 DWORD PTR _dataUnitNo$[esp+588], 1
  0024e	89 44 24 20	 mov	 DWORD PTR _blockCount$[esp+592], eax
  00252	89 4c 24 14	 mov	 DWORD PTR _startBlock$[esp+588], ecx
  00256	11 4c 24 2c	 adc	 DWORD PTR _dataUnitNo$[esp+592], ecx
  0025a	3b c1		 cmp	 eax, ecx
  0025c	0f 87 20 fe ff
	ff		 ja	 $LL55@EncryptBuf

; 94   : 
; 95   : 	// Process all blocks in the buffer
; 96   : 	while (blockCount > 0)

  00262	72 0a		 jb	 SHORT $LN59@EncryptBuf
  00264	39 4c 24 1c	 cmp	 DWORD PTR _blockCount$[esp+588], ecx
  00268	0f 87 14 fe ff
	ff		 ja	 $LL55@EncryptBuf
$LN59@EncryptBuf:
  0026e	5e		 pop	 esi
  0026f	5d		 pop	 ebp
  00270	33 c9		 xor	 ecx, ecx
  00272	5b		 pop	 ebx
$LN10@EncryptBuf:

; 189  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 190  : 	}
; 191  : 
; 192  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  00273	8d 44 24 2c	 lea	 eax, DWORD PTR _whiteningValue$[esp+576]
  00277	ba 02 00 00 00	 mov	 edx, 2
  0027c	5f		 pop	 edi
  0027d	8d 49 00	 npad	 3
$LL7@EncryptBuf:
  00280	89 08		 mov	 DWORD PTR [eax], ecx
  00282	4a		 dec	 edx
  00283	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00286	83 c0 08	 add	 eax, 8
  00289	3b d1		 cmp	 edx, ecx
  0028b	75 f3		 jne	 SHORT $LL7@EncryptBuf

; 193  : 	FAST_ERASE64 (whiteningValues, sizeof (whiteningValues));

  0028d	8d 44 24 38	 lea	 eax, DWORD PTR _whiteningValues$[esp+572]
  00291	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
$LL2@EncryptBuf:
  00296	89 08		 mov	 DWORD PTR [eax], ecx
  00298	4a		 dec	 edx
  00299	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0029c	83 c0 08	 add	 eax, 8
  0029f	3b d1		 cmp	 edx, ecx
  002a1	75 f3		 jne	 SHORT $LL2@EncryptBuf

; 194  : }

  002a3	8b 8c 24 38 02
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+572]
  002aa	33 cc		 xor	 ecx, esp
  002ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b1	81 c4 3c 02 00
	00		 add	 esp, 572		; 0000023cH
  002b7	c3		 ret	 0
_EncryptBufferXTSParallel ENDP
_TEXT	ENDS
PUBLIC	_ks$GSCopy$
PUBLIC	_ks2$GSCopy$
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogtpy
;	COMDAT _EncryptBufferXTSNonParallel
_TEXT	SEGMENT
_finalCarry$ = -53					; size = 1
_startBlock$ = -52					; size = 4
_block$ = -48						; size = 4
_blockCount$ = -44					; size = 8
_dataUnitNo$ = -36					; size = 8
_ks2$GSCopy$ = -28					; size = 4
_ks$GSCopy$ = -24					; size = 4
_whiteningValue$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_cipher$ = 28						; size = 4
_EncryptBufferXTSNonParallel PROC			; COMDAT
; _ks$ = ecx
; _ks2$ = edx

; 205  : {

  00000	83 ec 38	 sub	 esp, 56			; 00000038H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 34	 mov	 DWORD PTR __$ArrayPad$[esp+56], eax
  0000e	8b 44 24 48	 mov	 eax, DWORD PTR _startDataUnitNo$[esp+52]
  00012	89 54 24 1c	 mov	 DWORD PTR _ks2$GSCopy$[esp+56], edx

; 206  : 	unsigned __int8 finalCarry;
; 207  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 208  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 209  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 210  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
; 211  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;
; 212  : 	TC_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 213  : 
; 214  : 	/* The encrypted data unit number (i.e. the resultant ciphertext block) is to be multiplied in the
; 215  : 	finite field GF(2^128) by j-th power of n, where j is the sequential plaintext/ciphertext block
; 216  : 	number and n is 2, a primitive element of GF(2^128). This can be (and is) simplified and implemented
; 217  : 	as a left shift of the preceding whitening value by one bit (with carry propagating). In addition, if
; 218  : 	the shift of the highest byte results in a carry, 135 is XORed into the lowest byte. The value 135 is
; 219  : 	derived from the modulus of the Galois Field (x^128+x^7+x^2+x+1). */
; 220  : 
; 221  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 222  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 223  : 	dataUnitNo = startDataUnitNo->Value;

  00016	8b 10		 mov	 edx, DWORD PTR [eax]
  00018	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001b	89 4c 24 20	 mov	 DWORD PTR _ks$GSCopy$[esp+56], ecx
  0001f	8b 4c 24 4c	 mov	 ecx, DWORD PTR _startCipherBlockNo$[esp+52]
  00023	89 54 24 14	 mov	 DWORD PTR _dataUnitNo$[esp+56], edx

; 224  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 225  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
; 226  : 
; 227  : 	if (length % BYTES_PER_XTS_BLOCK)

  00027	8b 54 24 40	 mov	 edx, DWORD PTR _length$[esp+52]
  0002b	89 44 24 18	 mov	 DWORD PTR _dataUnitNo$[esp+60], eax
  0002f	8b c2		 mov	 eax, edx
  00031	89 4c 24 04	 mov	 DWORD PTR _startBlock$[esp+56], ecx
  00035	55		 push	 ebp
  00036	83 e0 0f	 and	 eax, 15			; 0000000fH
  00039	33 c9		 xor	 ecx, ecx
  0003b	0b c1		 or	 eax, ecx
  0003d	57		 push	 edi
  0003e	8b 7c 24 44	 mov	 edi, DWORD PTR _buffer$[esp+60]
  00042	74 06		 je	 SHORT $LN16@EncryptBuf@2

; 228  : 		TC_THROW_FATAL_EXCEPTION;

  00044	88 0d 00 00 00
	00		 mov	 BYTE PTR ds:0, cl
$LN16@EncryptBuf@2:

; 229  : 
; 230  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  0004a	8b 6c 24 4c	 mov	 ebp, DWORD PTR _length$[esp+64]
  0004e	0f ac ea 04	 shrd	 edx, ebp, 4
  00052	c1 ed 04	 shr	 ebp, 4
  00055	89 6c 24 18	 mov	 DWORD PTR _blockCount$[esp+68], ebp
  00059	89 54 24 14	 mov	 DWORD PTR _blockCount$[esp+64], edx

; 231  : 
; 232  : 	// Process all blocks in the buffer
; 233  : 	while (blockCount > 0)

  0005d	3b e9		 cmp	 ebp, ecx
  0005f	77 08		 ja	 SHORT $LN31@EncryptBuf@2
  00061	3b d1		 cmp	 edx, ecx
  00063	0f 86 71 01 00
	00		 jbe	 $LN5@EncryptBuf@2
$LN31@EncryptBuf@2:
  00069	53		 push	 ebx
  0006a	56		 push	 esi
  0006b	eb 09		 jmp	 SHORT $LN15@EncryptBuf@2
  0006d	8d 49 00	 npad	 3
$LL34@EncryptBuf@2:
  00070	8b 54 24 1c	 mov	 edx, DWORD PTR _blockCount$[esp+72]
  00074	33 c9		 xor	 ecx, ecx
$LN15@EncryptBuf@2:

; 234  : 	{
; 235  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  00076	3b e9		 cmp	 ebp, ecx
  00078	77 10		 ja	 SHORT $LN35@EncryptBuf@2
  0007a	72 05		 jb	 SHORT $LN29@EncryptBuf@2
  0007c	83 fa 20	 cmp	 edx, 32			; 00000020H
  0007f	73 09		 jae	 SHORT $LN35@EncryptBuf@2
$LN29@EncryptBuf@2:

; 236  : 			endBlock = startBlock + (unsigned int) blockCount;

  00081	8b 44 24 14	 mov	 eax, DWORD PTR _startBlock$[esp+72]
  00085	8d 1c 02	 lea	 ebx, DWORD PTR [edx+eax]

; 237  : 		else

  00088	eb 05		 jmp	 SHORT $LN12@EncryptBuf@2
$LN35@EncryptBuf@2:

; 238  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  0008a	bb 20 00 00 00	 mov	 ebx, 32			; 00000020H
$LN12@EncryptBuf@2:

; 239  : 
; 240  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 241  : 
; 242  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 243  : 		// whitening value for this data unit)
; 244  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  0008f	8b 54 24 24	 mov	 edx, DWORD PTR _dataUnitNo$[esp+72]
  00093	8b 44 24 28	 mov	 eax, DWORD PTR _dataUnitNo$[esp+76]

; 245  : 		*(whiteningValuePtr64 + 1) = 0;

  00097	89 4c 24 3c	 mov	 DWORD PTR _whiteningValue$[esp+80], ecx
  0009b	89 4c 24 40	 mov	 DWORD PTR _whiteningValue$[esp+84], ecx

; 246  : 		EncipherBlock (cipher, whiteningValue, ks2);

  0009f	8b 4c 24 2c	 mov	 ecx, DWORD PTR _ks2$GSCopy$[esp+72]
  000a3	8d 74 24 34	 lea	 esi, DWORD PTR _whiteningValue$[esp+72]
  000a7	89 54 24 34	 mov	 DWORD PTR _whiteningValue$[esp+72], edx
  000ab	51		 push	 ecx
  000ac	8b d6		 mov	 edx, esi
  000ae	89 44 24 3c	 mov	 DWORD PTR _whiteningValue$[esp+80], eax
  000b2	8b 44 24 64	 mov	 eax, DWORD PTR _cipher$[esp+72]
  000b6	52		 push	 edx
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _EncipherBlock

; 247  : 
; 248  : 		// Generate (and apply) subsequent whitening values for blocks in this data unit and
; 249  : 		// encrypt all relevant blocks in this data unit
; 250  : 		for (block = 0; block < endBlock; block++)

  000bd	33 c0		 xor	 eax, eax
  000bf	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c2	89 44 24 18	 mov	 DWORD PTR _block$[esp+72], eax
  000c6	3b d8		 cmp	 ebx, eax
  000c8	0f 86 d8 00 00
	00		 jbe	 $LN9@EncryptBuf@2
  000ce	8b ff		 npad	 2
$LL36@EncryptBuf@2:

; 251  : 		{
; 252  : 			if (block >= startBlock)

  000d0	8b 4c 24 18	 mov	 ecx, DWORD PTR _block$[esp+72]
  000d4	3b 4c 24 14	 cmp	 ecx, DWORD PTR _startBlock$[esp+72]
  000d8	72 56		 jb	 SHORT $LN8@EncryptBuf@2

; 253  : 			{
; 254  : 				// Pre-whitening
; 255  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  000da	8b 16		 mov	 edx, DWORD PTR [esi]
  000dc	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000df	31 17		 xor	 DWORD PTR [edi], edx
  000e1	31 47 04	 xor	 DWORD PTR [edi+4], eax

; 256  : 				*bufPtr-- ^= *whiteningValuePtr64--;

  000e4	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000e7	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  000ea	31 4f 08	 xor	 DWORD PTR [edi+8], ecx

; 257  : 
; 258  : 				// Actual encryption
; 259  : 				EncipherBlock (cipher, bufPtr, ks);

  000ed	8b 44 24 30	 mov	 eax, DWORD PTR _ks$GSCopy$[esp+72]
  000f1	31 57 0c	 xor	 DWORD PTR [edi+12], edx
  000f4	8b 4c 24 60	 mov	 ecx, DWORD PTR _cipher$[esp+68]
  000f8	83 c6 08	 add	 esi, 8
  000fb	83 c7 08	 add	 edi, 8
  000fe	50		 push	 eax
  000ff	83 ef 08	 sub	 edi, 8
  00102	57		 push	 edi
  00103	51		 push	 ecx
  00104	83 ee 08	 sub	 esi, 8
  00107	e8 00 00 00 00	 call	 _EncipherBlock

; 260  : 
; 261  : 				// Post-whitening
; 262  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  0010c	8b 16		 mov	 edx, DWORD PTR [esi]
  0010e	31 17		 xor	 DWORD PTR [edi], edx
  00110	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00113	31 47 04	 xor	 DWORD PTR [edi+4], eax

; 263  : 				*bufPtr++ ^= *whiteningValuePtr64;

  00116	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00119	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0011c	31 4f 08	 xor	 DWORD PTR [edi+8], ecx
  0011f	31 57 0c	 xor	 DWORD PTR [edi+12], edx
  00122	83 c6 08	 add	 esi, 8
  00125	83 c7 08	 add	 edi, 8
  00128	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012b	83 c7 08	 add	 edi, 8

; 264  : 			}
; 265  : 			else

  0012e	eb 03		 jmp	 SHORT $LN7@EncryptBuf@2
$LN8@EncryptBuf@2:

; 266  : 				whiteningValuePtr64++;

  00130	83 c6 08	 add	 esi, 8
$LN7@EncryptBuf@2:

; 267  : 
; 268  : 			// Derive the next whitening value
; 269  : 
; 270  : #if BYTE_ORDER == LITTLE_ENDIAN
; 271  : 
; 272  : 			// Little-endian platforms
; 273  : 
; 274  : 			finalCarry = 
; 275  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 276  : 				135 : 0;

  00133	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00136	8b 06		 mov	 eax, DWORD PTR [esi]
  00138	8b e9		 mov	 ebp, ecx
  0013a	81 e5 00 00 00
	80		 and	 ebp, -2147483648	; 80000000H
  00140	33 d2		 xor	 edx, edx
  00142	0b d5		 or	 edx, ebp
  00144	c6 44 24 13 87	 mov	 BYTE PTR _finalCarry$[esp+72], 135 ; 00000087H
  00149	75 05		 jne	 SHORT $LN20@EncryptBuf@2
  0014b	c6 44 24 13 00	 mov	 BYTE PTR _finalCarry$[esp+72], 0
$LN20@EncryptBuf@2:

; 277  : 
; 278  : 			*whiteningValuePtr64-- <<= 1;

  00150	0f a4 c1 01	 shld	 ecx, eax, 1
  00154	03 c0		 add	 eax, eax
  00156	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00159	89 06		 mov	 DWORD PTR [esi], eax

; 279  : 
; 280  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  0015b	8b 6e fc	 mov	 ebp, DWORD PTR [esi-4]
  0015e	8b 46 f8	 mov	 eax, DWORD PTR [esi-8]
  00161	83 ee 08	 sub	 esi, 8
  00164	8b d5		 mov	 edx, ebp
  00166	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H
  0016c	33 c9		 xor	 ecx, ecx
  0016e	0b ca		 or	 ecx, edx
  00170	74 0a		 je	 SHORT $LN37@EncryptBuf@2

; 281  : 				*(whiteningValuePtr64 + 1) |= 1;	

  00172	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00175	83 4e 08 01	 or	 DWORD PTR [esi+8], 1
  00179	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
$LN37@EncryptBuf@2:

; 282  : 
; 283  : 			*whiteningValuePtr64 <<= 1;
; 284  : #else
; 285  : 
; 286  : 			// Big-endian platforms
; 287  : 
; 288  : 			finalCarry = 
; 289  : 				(*whiteningValuePtr64 & 0x80) ?
; 290  : 				135 : 0;
; 291  : 
; 292  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 293  : 
; 294  : 			whiteningValuePtr64--;
; 295  : 
; 296  : 			if (*whiteningValuePtr64 & 0x80)
; 297  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 298  : 
; 299  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 300  : #endif
; 301  : 
; 302  : 			whiteningValue[0] ^= finalCarry;

  0017c	8a 54 24 13	 mov	 dl, BYTE PTR _finalCarry$[esp+72]
  00180	0f a4 c5 01	 shld	 ebp, eax, 1
  00184	03 c0		 add	 eax, eax
  00186	89 06		 mov	 DWORD PTR [esi], eax
  00188	8b 44 24 18	 mov	 eax, DWORD PTR _block$[esp+72]
  0018c	40		 inc	 eax
  0018d	89 6e 04	 mov	 DWORD PTR [esi+4], ebp
  00190	30 54 24 34	 xor	 BYTE PTR _whiteningValue$[esp+72], dl
  00194	89 44 24 18	 mov	 DWORD PTR _block$[esp+72], eax
  00198	3b c3		 cmp	 eax, ebx
  0019a	0f 82 30 ff ff
	ff		 jb	 $LL36@EncryptBuf@2
  001a0	8b 6c 24 20	 mov	 ebp, DWORD PTR _blockCount$[esp+76]
  001a4	33 c0		 xor	 eax, eax
$LN9@EncryptBuf@2:

; 303  : 		}
; 304  : 
; 305  : 		blockCount -= endBlock - startBlock;

  001a6	2b 5c 24 14	 sub	 ebx, DWORD PTR _startBlock$[esp+72]

; 306  : 		startBlock = 0;

  001aa	89 44 24 14	 mov	 DWORD PTR _startBlock$[esp+72], eax
  001ae	29 5c 24 1c	 sub	 DWORD PTR _blockCount$[esp+72], ebx
  001b2	1b e8		 sbb	 ebp, eax

; 307  : 		dataUnitNo++;

  001b4	83 44 24 24 01	 add	 DWORD PTR _dataUnitNo$[esp+72], 1
  001b9	89 6c 24 20	 mov	 DWORD PTR _blockCount$[esp+76], ebp
  001bd	11 44 24 28	 adc	 DWORD PTR _dataUnitNo$[esp+76], eax
  001c1	3b e8		 cmp	 ebp, eax
  001c3	0f 87 a7 fe ff
	ff		 ja	 $LL34@EncryptBuf@2

; 231  : 
; 232  : 	// Process all blocks in the buffer
; 233  : 	while (blockCount > 0)

  001c9	72 0b		 jb	 SHORT $LN38@EncryptBuf@2
  001cb	83 7c 24 1c 00	 cmp	 DWORD PTR _blockCount$[esp+72], 0
  001d0	0f 87 9a fe ff
	ff		 ja	 $LL34@EncryptBuf@2
$LN38@EncryptBuf@2:
  001d6	5e		 pop	 esi
  001d7	33 c9		 xor	 ecx, ecx
  001d9	5b		 pop	 ebx
$LN5@EncryptBuf@2:
  001da	5f		 pop	 edi

; 308  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 309  : 	}
; 310  : 
; 311  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  001db	8d 44 24 28	 lea	 eax, DWORD PTR _whiteningValue$[esp+60]
  001df	ba 02 00 00 00	 mov	 edx, 2
  001e4	5d		 pop	 ebp
$LL2@EncryptBuf@2:
  001e5	89 08		 mov	 DWORD PTR [eax], ecx
  001e7	4a		 dec	 edx
  001e8	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  001eb	83 c0 08	 add	 eax, 8
  001ee	3b d1		 cmp	 edx, ecx
  001f0	75 f3		 jne	 SHORT $LL2@EncryptBuf@2

; 312  : }

  001f2	8b 4c 24 34	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+56]
  001f6	33 cc		 xor	 ecx, esp
  001f8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001fd	83 c4 38	 add	 esp, 56			; 00000038H
  00200	c3		 ret	 0
_EncryptBufferXTSNonParallel ENDP
_TEXT	ENDS
PUBLIC	_ks$GSCopy$
PUBLIC	_ks2$GSCopy$
PUBLIC	__$ArrayPad$
EXTRN	_DecipherBlocks:PROC
; Function compile flags: /Ogtpy
;	COMDAT _DecryptBufferXTSParallel
_TEXT	SEGMENT
_finalCarry$ = -569					; size = 1
_startBlock$ = -568					; size = 4
_dataUnitBufPtr$ = -564					; size = 4
_whiteningValuesPtr64$ = -564				; size = 4
_blockCount$ = -560					; size = 8
_block$ = -552						; size = 4
_dataUnitNo$ = -548					; size = 8
_ks2$GSCopy$ = -540					; size = 4
_ks$GSCopy$ = -536					; size = 4
_whiteningValue$ = -532					; size = 16
_whiteningValues$ = -516				; size = 512
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_cipher$ = 28						; size = 4
_DecryptBufferXTSParallel PROC				; COMDAT
; _ks$ = ecx
; _ks2$ = edx

; 339  : {

  00000	81 ec 3c 02 00
	00		 sub	 esp, 572		; 0000023cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 38 02
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+572], eax
  00014	8b 84 24 4c 02
	00 00		 mov	 eax, DWORD PTR _startDataUnitNo$[esp+568]
  0001b	89 54 24 20	 mov	 DWORD PTR _ks2$GSCopy$[esp+572], edx

; 340  : 	unsigned __int8 finalCarry;
; 341  : 	unsigned __int8 whiteningValues [ENCRYPTION_DATA_UNIT_SIZE];
; 342  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 343  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 344  : 	unsigned __int64 *whiteningValuesPtr64 = (unsigned __int64 *) whiteningValues;
; 345  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 346  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
; 347  : 	unsigned __int64 *dataUnitBufPtr;
; 348  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;
; 349  : 	unsigned __int64 *const finalInt64WhiteningValuesPtr = whiteningValuesPtr64 + sizeof (whiteningValues) / sizeof (*whiteningValuesPtr64) - 1;
; 350  : 	TC_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 351  : 
; 352  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 353  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 354  : 	dataUnitNo = startDataUnitNo->Value;

  0001f	8b 10		 mov	 edx, DWORD PTR [eax]
  00021	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00024	89 4c 24 24	 mov	 DWORD PTR _ks$GSCopy$[esp+572], ecx
  00028	8b 8c 24 50 02
	00 00		 mov	 ecx, DWORD PTR _startCipherBlockNo$[esp+568]
  0002f	89 54 24 18	 mov	 DWORD PTR _dataUnitNo$[esp+572], edx

; 355  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 356  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
; 357  : 
; 358  : 	if (length % BYTES_PER_XTS_BLOCK)

  00033	8b 94 24 44 02
	00 00		 mov	 edx, DWORD PTR _length$[esp+568]
  0003a	89 44 24 1c	 mov	 DWORD PTR _dataUnitNo$[esp+576], eax
  0003e	8b c2		 mov	 eax, edx
  00040	89 4c 24 04	 mov	 DWORD PTR _startBlock$[esp+572], ecx
  00044	83 e0 0f	 and	 eax, 15			; 0000000fH
  00047	33 c9		 xor	 ecx, ecx
  00049	0b c1		 or	 eax, ecx
  0004b	57		 push	 edi
  0004c	8b bc 24 44 02
	00 00		 mov	 edi, DWORD PTR _buffer$[esp+572]
  00053	74 06		 je	 SHORT $LN27@DecryptBuf

; 359  : 		TC_THROW_FATAL_EXCEPTION;

  00055	88 0d 00 00 00
	00		 mov	 BYTE PTR ds:0, cl
$LN27@DecryptBuf:

; 360  : 
; 361  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  0005b	8b 84 24 4c 02
	00 00		 mov	 eax, DWORD PTR _length$[esp+576]
  00062	0f ac c2 04	 shrd	 edx, eax, 4
  00066	c1 e8 04	 shr	 eax, 4
  00069	89 44 24 14	 mov	 DWORD PTR _blockCount$[esp+580], eax
  0006d	89 54 24 10	 mov	 DWORD PTR _blockCount$[esp+576], edx

; 362  : 
; 363  : 	// Process all blocks in the buffer
; 364  : 	while (blockCount > 0)

  00071	3b c1		 cmp	 eax, ecx
  00073	77 08		 ja	 SHORT $LN49@DecryptBuf
  00075	3b d1		 cmp	 edx, ecx
  00077	0f 86 f6 01 00
	00		 jbe	 $LN10@DecryptBuf
$LN49@DecryptBuf:
  0007d	53		 push	 ebx
  0007e	55		 push	 ebp
  0007f	56		 push	 esi
  00080	eb 0a		 jmp	 SHORT $LN26@DecryptBuf
$LL55@DecryptBuf:
  00082	8b 44 24 20	 mov	 eax, DWORD PTR _blockCount$[esp+592]
  00086	8b 54 24 1c	 mov	 edx, DWORD PTR _blockCount$[esp+588]
  0008a	33 c9		 xor	 ecx, ecx
$LN26@DecryptBuf:

; 365  : 	{
; 366  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  0008c	3b c1		 cmp	 eax, ecx
  0008e	77 10		 ja	 SHORT $LN56@DecryptBuf
  00090	72 05		 jb	 SHORT $LN47@DecryptBuf
  00092	83 fa 20	 cmp	 edx, 32			; 00000020H
  00095	73 09		 jae	 SHORT $LN56@DecryptBuf
$LN47@DecryptBuf:

; 367  : 			endBlock = startBlock + (unsigned int) blockCount;

  00097	8b 44 24 14	 mov	 eax, DWORD PTR _startBlock$[esp+588]
  0009b	8d 1c 02	 lea	 ebx, DWORD PTR [edx+eax]

; 368  : 		else

  0009e	eb 05		 jmp	 SHORT $LN23@DecryptBuf
$LN56@DecryptBuf:

; 369  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  000a0	bb 20 00 00 00	 mov	 ebx, 32			; 00000020H
$LN23@DecryptBuf:

; 370  : 
; 371  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
; 372  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 373  : 
; 374  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 375  : 		// whitening value for this data unit)
; 376  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  000a5	8b 54 24 28	 mov	 edx, DWORD PTR _dataUnitNo$[esp+588]
  000a9	8b 44 24 2c	 mov	 eax, DWORD PTR _dataUnitNo$[esp+592]

; 377  : 		*(whiteningValuePtr64 + 1) = 0;

  000ad	89 4c 24 40	 mov	 DWORD PTR _whiteningValue$[esp+596], ecx
  000b1	89 4c 24 44	 mov	 DWORD PTR _whiteningValue$[esp+600], ecx

; 378  : 		EncipherBlock (cipher, whiteningValue, ks2);

  000b5	8b 4c 24 30	 mov	 ecx, DWORD PTR _ks2$GSCopy$[esp+588]
  000b9	8d 74 24 38	 lea	 esi, DWORD PTR _whiteningValue$[esp+588]
  000bd	89 54 24 38	 mov	 DWORD PTR _whiteningValue$[esp+588], edx
  000c1	51		 push	 ecx
  000c2	8b d6		 mov	 edx, esi
  000c4	89 44 24 40	 mov	 DWORD PTR _whiteningValue$[esp+596], eax
  000c8	8b 84 24 68 02
	00 00		 mov	 eax, DWORD PTR _cipher$[esp+588]
  000cf	52		 push	 edx
  000d0	8d ac 24 48 02
	00 00		 lea	 ebp, DWORD PTR _whiteningValues$[esp+1100]
  000d7	50		 push	 eax
  000d8	89 6c 24 24	 mov	 DWORD PTR _whiteningValuesPtr64$[esp+600], ebp
  000dc	e8 00 00 00 00	 call	 _EncipherBlock
  000e1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 379  : 
; 380  : 		// Generate subsequent whitening values for blocks in this data unit. Note that all generated 128-bit
; 381  : 		// whitening values are stored in memory as a sequence of 64-bit integers in reverse order.
; 382  : 		for (block = 0; block < endBlock; block++)

  000e4	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _block$[esp+588], 0
  000ec	85 db		 test	 ebx, ebx
  000ee	0f 86 b0 00 00
	00		 jbe	 $LN20@DecryptBuf
  000f4	eb 0e		 jmp	 SHORT $LN22@DecryptBuf
  000f6	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL57@DecryptBuf:
  00100	8b 6c 24 18	 mov	 ebp, DWORD PTR _whiteningValuesPtr64$[esp+588]
$LN22@DecryptBuf:

; 383  : 		{
; 384  : 			if (block >= startBlock)

  00104	8b 4c 24 24	 mov	 ecx, DWORD PTR _block$[esp+588]
  00108	3b 4c 24 14	 cmp	 ecx, DWORD PTR _startBlock$[esp+588]
  0010c	72 26		 jb	 SHORT $LN19@DecryptBuf

; 385  : 			{
; 386  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64++;

  0010e	8b 16		 mov	 edx, DWORD PTR [esi]
  00110	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 387  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64;

  00113	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00116	89 55 00	 mov	 DWORD PTR [ebp], edx
  00119	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0011c	89 45 04	 mov	 DWORD PTR [ebp+4], eax
  0011f	83 c6 08	 add	 esi, 8
  00122	83 ed 08	 sub	 ebp, 8
  00125	89 4d 00	 mov	 DWORD PTR [ebp], ecx
  00128	89 55 04	 mov	 DWORD PTR [ebp+4], edx
  0012b	83 ed 08	 sub	 ebp, 8
  0012e	89 6c 24 18	 mov	 DWORD PTR _whiteningValuesPtr64$[esp+588], ebp

; 388  : 			}
; 389  : 			else

  00132	eb 03		 jmp	 SHORT $LN18@DecryptBuf
$LN19@DecryptBuf:

; 390  : 				whiteningValuePtr64++;

  00134	83 c6 08	 add	 esi, 8
$LN18@DecryptBuf:

; 391  : 
; 392  : 			// Derive the next whitening value
; 393  : 
; 394  : #if BYTE_ORDER == LITTLE_ENDIAN
; 395  : 
; 396  : 			// Little-endian platforms
; 397  : 
; 398  : 			finalCarry = 
; 399  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 400  : 				135 : 0;

  00137	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0013a	8b 06		 mov	 eax, DWORD PTR [esi]
  0013c	8b e9		 mov	 ebp, ecx
  0013e	81 e5 00 00 00
	80		 and	 ebp, -2147483648	; 80000000H
  00144	33 d2		 xor	 edx, edx
  00146	0b d5		 or	 edx, ebp
  00148	c6 44 24 13 87	 mov	 BYTE PTR _finalCarry$[esp+588], 135 ; 00000087H
  0014d	75 05		 jne	 SHORT $LN31@DecryptBuf
  0014f	c6 44 24 13 00	 mov	 BYTE PTR _finalCarry$[esp+588], 0
$LN31@DecryptBuf:

; 401  : 
; 402  : 			*whiteningValuePtr64-- <<= 1;

  00154	0f a4 c1 01	 shld	 ecx, eax, 1
  00158	03 c0		 add	 eax, eax
  0015a	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0015d	89 06		 mov	 DWORD PTR [esi], eax

; 403  : 
; 404  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  0015f	8b 6e fc	 mov	 ebp, DWORD PTR [esi-4]
  00162	8b 46 f8	 mov	 eax, DWORD PTR [esi-8]
  00165	83 ee 08	 sub	 esi, 8
  00168	8b d5		 mov	 edx, ebp
  0016a	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H
  00170	33 c9		 xor	 ecx, ecx
  00172	0b ca		 or	 ecx, edx
  00174	74 0a		 je	 SHORT $LN58@DecryptBuf

; 405  : 				*(whiteningValuePtr64 + 1) |= 1;	

  00176	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00179	83 4e 08 01	 or	 DWORD PTR [esi+8], 1
  0017d	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
$LN58@DecryptBuf:

; 406  : 
; 407  : 			*whiteningValuePtr64 <<= 1;
; 408  : 
; 409  : #else
; 410  : 			// Big-endian platforms
; 411  : 
; 412  : 			finalCarry = 
; 413  : 				(*whiteningValuePtr64 & 0x80) ?
; 414  : 				135 : 0;
; 415  : 
; 416  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 417  : 
; 418  : 			whiteningValuePtr64--;
; 419  : 
; 420  : 			if (*whiteningValuePtr64 & 0x80)
; 421  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 422  : 
; 423  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 424  : #endif
; 425  : 
; 426  : 			whiteningValue[0] ^= finalCarry;

  00180	8a 54 24 13	 mov	 dl, BYTE PTR _finalCarry$[esp+588]
  00184	0f a4 c5 01	 shld	 ebp, eax, 1
  00188	03 c0		 add	 eax, eax
  0018a	89 06		 mov	 DWORD PTR [esi], eax
  0018c	8b 44 24 24	 mov	 eax, DWORD PTR _block$[esp+588]
  00190	40		 inc	 eax
  00191	89 6e 04	 mov	 DWORD PTR [esi+4], ebp
  00194	30 54 24 38	 xor	 BYTE PTR _whiteningValue$[esp+588], dl
  00198	89 44 24 24	 mov	 DWORD PTR _block$[esp+588], eax
  0019c	3b c3		 cmp	 eax, ebx
  0019e	0f 82 5c ff ff
	ff		 jb	 $LL57@DecryptBuf
$LN20@DecryptBuf:

; 427  : 		}
; 428  : 
; 429  : 		dataUnitBufPtr = bufPtr;
; 430  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
; 431  : 
; 432  : 		// Decrypt blocks in this data unit
; 433  : 
; 434  : 		for (block = startBlock; block < endBlock; block++)

  001a4	8b 6c 24 14	 mov	 ebp, DWORD PTR _startBlock$[esp+588]
  001a8	8b d7		 mov	 edx, edi
  001aa	89 54 24 18	 mov	 DWORD PTR _dataUnitBufPtr$[esp+588], edx
  001ae	8d 84 24 40 02
	00 00		 lea	 eax, DWORD PTR _whiteningValues$[esp+1092]
  001b5	3b eb		 cmp	 ebp, ebx
  001b7	73 2e		 jae	 SHORT $LN14@DecryptBuf
  001b9	8b cb		 mov	 ecx, ebx
  001bb	2b cd		 sub	 ecx, ebp
  001bd	8d 49 00	 npad	 3
$LL16@DecryptBuf:

; 435  : 		{
; 436  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  001c0	8b 30		 mov	 esi, DWORD PTR [eax]
  001c2	31 37		 xor	 DWORD PTR [edi], esi
  001c4	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  001c7	31 77 04	 xor	 DWORD PTR [edi+4], esi

; 437  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  001ca	8b 70 f8	 mov	 esi, DWORD PTR [eax-8]
  001cd	31 77 08	 xor	 DWORD PTR [edi+8], esi
  001d0	8b 70 fc	 mov	 esi, DWORD PTR [eax-4]
  001d3	31 77 0c	 xor	 DWORD PTR [edi+12], esi
  001d6	83 e8 08	 sub	 eax, 8
  001d9	83 c7 08	 add	 edi, 8
  001dc	83 e8 08	 sub	 eax, 8
  001df	83 c7 08	 add	 edi, 8
  001e2	83 e9 01	 sub	 ecx, 1
  001e5	75 d9		 jne	 SHORT $LL16@DecryptBuf
$LN14@DecryptBuf:

; 438  : 		}
; 439  : 
; 440  : 		DecipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);

  001e7	8b 44 24 34	 mov	 eax, DWORD PTR _ks$GSCopy$[esp+588]
  001eb	8b 8c 24 64 02
	00 00		 mov	 ecx, DWORD PTR _cipher$[esp+584]
  001f2	8b f3		 mov	 esi, ebx
  001f4	2b f5		 sub	 esi, ebp
  001f6	56		 push	 esi
  001f7	50		 push	 eax
  001f8	52		 push	 edx
  001f9	51		 push	 ecx
  001fa	e8 00 00 00 00	 call	 _DecipherBlocks

; 441  : 
; 442  : 		bufPtr = dataUnitBufPtr;

  001ff	8b 7c 24 28	 mov	 edi, DWORD PTR _dataUnitBufPtr$[esp+604]
  00203	83 c4 10	 add	 esp, 16			; 00000010H

; 443  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  00206	8d 84 24 40 02
	00 00		 lea	 eax, DWORD PTR _whiteningValues$[esp+1092]

; 444  : 
; 445  : 		for (block = startBlock; block < endBlock; block++)

  0020d	3b eb		 cmp	 ebp, ebx
  0020f	73 29		 jae	 SHORT $LN11@DecryptBuf

; 438  : 		}
; 439  : 
; 440  : 		DecipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);

  00211	8b ce		 mov	 ecx, esi
$LL13@DecryptBuf:

; 446  : 		{
; 447  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00213	8b 10		 mov	 edx, DWORD PTR [eax]
  00215	31 17		 xor	 DWORD PTR [edi], edx
  00217	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0021a	31 57 04	 xor	 DWORD PTR [edi+4], edx

; 448  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  0021d	8b 50 f8	 mov	 edx, DWORD PTR [eax-8]
  00220	31 57 08	 xor	 DWORD PTR [edi+8], edx
  00223	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00226	31 57 0c	 xor	 DWORD PTR [edi+12], edx
  00229	83 e8 08	 sub	 eax, 8
  0022c	83 c7 08	 add	 edi, 8
  0022f	83 e8 08	 sub	 eax, 8
  00232	83 c7 08	 add	 edi, 8
  00235	83 e9 01	 sub	 ecx, 1
  00238	75 d9		 jne	 SHORT $LL13@DecryptBuf
$LN11@DecryptBuf:

; 449  : 		}
; 450  : 
; 451  : 		blockCount -= endBlock - startBlock;

  0023a	29 74 24 1c	 sub	 DWORD PTR _blockCount$[esp+588], esi
  0023e	8b 44 24 20	 mov	 eax, DWORD PTR _blockCount$[esp+592]
  00242	b9 00 00 00 00	 mov	 ecx, 0
  00247	1b c1		 sbb	 eax, ecx

; 452  : 		startBlock = 0;
; 453  : 		dataUnitNo++;

  00249	83 44 24 28 01	 add	 DWORD PTR _dataUnitNo$[esp+588], 1
  0024e	89 44 24 20	 mov	 DWORD PTR _blockCount$[esp+592], eax
  00252	89 4c 24 14	 mov	 DWORD PTR _startBlock$[esp+588], ecx
  00256	11 4c 24 2c	 adc	 DWORD PTR _dataUnitNo$[esp+592], ecx
  0025a	3b c1		 cmp	 eax, ecx
  0025c	0f 87 20 fe ff
	ff		 ja	 $LL55@DecryptBuf

; 362  : 
; 363  : 	// Process all blocks in the buffer
; 364  : 	while (blockCount > 0)

  00262	72 0a		 jb	 SHORT $LN59@DecryptBuf
  00264	39 4c 24 1c	 cmp	 DWORD PTR _blockCount$[esp+588], ecx
  00268	0f 87 14 fe ff
	ff		 ja	 $LL55@DecryptBuf
$LN59@DecryptBuf:
  0026e	5e		 pop	 esi
  0026f	5d		 pop	 ebp
  00270	33 c9		 xor	 ecx, ecx
  00272	5b		 pop	 ebx
$LN10@DecryptBuf:

; 454  : 
; 455  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 456  : 	}
; 457  : 
; 458  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  00273	8d 44 24 2c	 lea	 eax, DWORD PTR _whiteningValue$[esp+576]
  00277	ba 02 00 00 00	 mov	 edx, 2
  0027c	5f		 pop	 edi
  0027d	8d 49 00	 npad	 3
$LL7@DecryptBuf:
  00280	89 08		 mov	 DWORD PTR [eax], ecx
  00282	4a		 dec	 edx
  00283	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00286	83 c0 08	 add	 eax, 8
  00289	3b d1		 cmp	 edx, ecx
  0028b	75 f3		 jne	 SHORT $LL7@DecryptBuf

; 459  : 	FAST_ERASE64 (whiteningValues, sizeof (whiteningValues));

  0028d	8d 44 24 38	 lea	 eax, DWORD PTR _whiteningValues$[esp+572]
  00291	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
$LL2@DecryptBuf:
  00296	89 08		 mov	 DWORD PTR [eax], ecx
  00298	4a		 dec	 edx
  00299	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0029c	83 c0 08	 add	 eax, 8
  0029f	3b d1		 cmp	 edx, ecx
  002a1	75 f3		 jne	 SHORT $LL2@DecryptBuf

; 460  : }

  002a3	8b 8c 24 38 02
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+572]
  002aa	33 cc		 xor	 ecx, esp
  002ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b1	81 c4 3c 02 00
	00		 add	 esp, 572		; 0000023cH
  002b7	c3		 ret	 0
_DecryptBufferXTSParallel ENDP
_TEXT	ENDS
PUBLIC	_ks$GSCopy$
PUBLIC	_ks2$GSCopy$
PUBLIC	__$ArrayPad$
EXTRN	_DecipherBlock:PROC
; Function compile flags: /Ogtpy
;	COMDAT _DecryptBufferXTSNonParallel
_TEXT	SEGMENT
_finalCarry$ = -53					; size = 1
_startBlock$ = -52					; size = 4
_block$ = -48						; size = 4
_blockCount$ = -44					; size = 8
_dataUnitNo$ = -36					; size = 8
_ks2$GSCopy$ = -28					; size = 4
_ks$GSCopy$ = -24					; size = 4
_whiteningValue$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_cipher$ = 28						; size = 4
_DecryptBufferXTSNonParallel PROC			; COMDAT
; _ks$ = ecx
; _ks2$ = edx

; 471  : {

  00000	83 ec 38	 sub	 esp, 56			; 00000038H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 34	 mov	 DWORD PTR __$ArrayPad$[esp+56], eax
  0000e	8b 44 24 48	 mov	 eax, DWORD PTR _startDataUnitNo$[esp+52]
  00012	89 54 24 1c	 mov	 DWORD PTR _ks2$GSCopy$[esp+56], edx

; 472  : 	unsigned __int8 finalCarry;
; 473  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 474  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 475  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 476  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
; 477  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;
; 478  : 	TC_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 479  : 
; 480  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 481  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 482  : 	dataUnitNo = startDataUnitNo->Value;

  00016	8b 10		 mov	 edx, DWORD PTR [eax]
  00018	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001b	89 4c 24 20	 mov	 DWORD PTR _ks$GSCopy$[esp+56], ecx
  0001f	8b 4c 24 4c	 mov	 ecx, DWORD PTR _startCipherBlockNo$[esp+52]
  00023	89 54 24 14	 mov	 DWORD PTR _dataUnitNo$[esp+56], edx

; 483  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 484  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
; 485  : 
; 486  : 	if (length % BYTES_PER_XTS_BLOCK)

  00027	8b 54 24 40	 mov	 edx, DWORD PTR _length$[esp+52]
  0002b	89 44 24 18	 mov	 DWORD PTR _dataUnitNo$[esp+60], eax
  0002f	8b c2		 mov	 eax, edx
  00031	89 4c 24 04	 mov	 DWORD PTR _startBlock$[esp+56], ecx
  00035	55		 push	 ebp
  00036	83 e0 0f	 and	 eax, 15			; 0000000fH
  00039	33 c9		 xor	 ecx, ecx
  0003b	0b c1		 or	 eax, ecx
  0003d	57		 push	 edi
  0003e	8b 7c 24 44	 mov	 edi, DWORD PTR _buffer$[esp+60]
  00042	74 06		 je	 SHORT $LN16@DecryptBuf@2

; 487  : 		TC_THROW_FATAL_EXCEPTION;

  00044	88 0d 00 00 00
	00		 mov	 BYTE PTR ds:0, cl
$LN16@DecryptBuf@2:

; 488  : 
; 489  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  0004a	8b 6c 24 4c	 mov	 ebp, DWORD PTR _length$[esp+64]
  0004e	0f ac ea 04	 shrd	 edx, ebp, 4
  00052	c1 ed 04	 shr	 ebp, 4
  00055	89 6c 24 18	 mov	 DWORD PTR _blockCount$[esp+68], ebp
  00059	89 54 24 14	 mov	 DWORD PTR _blockCount$[esp+64], edx

; 490  : 
; 491  : 	// Process all blocks in the buffer
; 492  : 	while (blockCount > 0)

  0005d	3b e9		 cmp	 ebp, ecx
  0005f	77 08		 ja	 SHORT $LN31@DecryptBuf@2
  00061	3b d1		 cmp	 edx, ecx
  00063	0f 86 71 01 00
	00		 jbe	 $LN5@DecryptBuf@2
$LN31@DecryptBuf@2:
  00069	53		 push	 ebx
  0006a	56		 push	 esi
  0006b	eb 09		 jmp	 SHORT $LN15@DecryptBuf@2
  0006d	8d 49 00	 npad	 3
$LL34@DecryptBuf@2:
  00070	8b 54 24 1c	 mov	 edx, DWORD PTR _blockCount$[esp+72]
  00074	33 c9		 xor	 ecx, ecx
$LN15@DecryptBuf@2:

; 493  : 	{
; 494  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  00076	3b e9		 cmp	 ebp, ecx
  00078	77 10		 ja	 SHORT $LN35@DecryptBuf@2
  0007a	72 05		 jb	 SHORT $LN29@DecryptBuf@2
  0007c	83 fa 20	 cmp	 edx, 32			; 00000020H
  0007f	73 09		 jae	 SHORT $LN35@DecryptBuf@2
$LN29@DecryptBuf@2:

; 495  : 			endBlock = startBlock + (unsigned int) blockCount;

  00081	8b 44 24 14	 mov	 eax, DWORD PTR _startBlock$[esp+72]
  00085	8d 1c 02	 lea	 ebx, DWORD PTR [edx+eax]

; 496  : 		else

  00088	eb 05		 jmp	 SHORT $LN12@DecryptBuf@2
$LN35@DecryptBuf@2:

; 497  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  0008a	bb 20 00 00 00	 mov	 ebx, 32			; 00000020H
$LN12@DecryptBuf@2:

; 498  : 
; 499  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 500  : 
; 501  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 502  : 		// whitening value for this data unit)
; 503  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  0008f	8b 54 24 24	 mov	 edx, DWORD PTR _dataUnitNo$[esp+72]
  00093	8b 44 24 28	 mov	 eax, DWORD PTR _dataUnitNo$[esp+76]

; 504  : 		*(whiteningValuePtr64 + 1) = 0;

  00097	89 4c 24 3c	 mov	 DWORD PTR _whiteningValue$[esp+80], ecx
  0009b	89 4c 24 40	 mov	 DWORD PTR _whiteningValue$[esp+84], ecx

; 505  : 		EncipherBlock (cipher, whiteningValue, ks2);

  0009f	8b 4c 24 2c	 mov	 ecx, DWORD PTR _ks2$GSCopy$[esp+72]
  000a3	8d 74 24 34	 lea	 esi, DWORD PTR _whiteningValue$[esp+72]
  000a7	89 54 24 34	 mov	 DWORD PTR _whiteningValue$[esp+72], edx
  000ab	51		 push	 ecx
  000ac	8b d6		 mov	 edx, esi
  000ae	89 44 24 3c	 mov	 DWORD PTR _whiteningValue$[esp+80], eax
  000b2	8b 44 24 64	 mov	 eax, DWORD PTR _cipher$[esp+72]
  000b6	52		 push	 edx
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _EncipherBlock

; 506  : 
; 507  : 		// Generate (and apply) subsequent whitening values for blocks in this data unit and
; 508  : 		// decrypt all relevant blocks in this data unit
; 509  : 		for (block = 0; block < endBlock; block++)

  000bd	33 c0		 xor	 eax, eax
  000bf	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c2	89 44 24 18	 mov	 DWORD PTR _block$[esp+72], eax
  000c6	3b d8		 cmp	 ebx, eax
  000c8	0f 86 d8 00 00
	00		 jbe	 $LN9@DecryptBuf@2
  000ce	8b ff		 npad	 2
$LL36@DecryptBuf@2:

; 510  : 		{
; 511  : 			if (block >= startBlock)

  000d0	8b 4c 24 18	 mov	 ecx, DWORD PTR _block$[esp+72]
  000d4	3b 4c 24 14	 cmp	 ecx, DWORD PTR _startBlock$[esp+72]
  000d8	72 56		 jb	 SHORT $LN8@DecryptBuf@2

; 512  : 			{
; 513  : 				// Post-whitening
; 514  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  000da	8b 16		 mov	 edx, DWORD PTR [esi]
  000dc	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000df	31 17		 xor	 DWORD PTR [edi], edx
  000e1	31 47 04	 xor	 DWORD PTR [edi+4], eax

; 515  : 				*bufPtr-- ^= *whiteningValuePtr64--;

  000e4	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000e7	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  000ea	31 4f 08	 xor	 DWORD PTR [edi+8], ecx

; 516  : 
; 517  : 				// Actual decryption
; 518  : 				DecipherBlock (cipher, bufPtr, ks);

  000ed	8b 44 24 30	 mov	 eax, DWORD PTR _ks$GSCopy$[esp+72]
  000f1	31 57 0c	 xor	 DWORD PTR [edi+12], edx
  000f4	8b 4c 24 60	 mov	 ecx, DWORD PTR _cipher$[esp+68]
  000f8	83 c6 08	 add	 esi, 8
  000fb	83 c7 08	 add	 edi, 8
  000fe	50		 push	 eax
  000ff	83 ef 08	 sub	 edi, 8
  00102	57		 push	 edi
  00103	51		 push	 ecx
  00104	83 ee 08	 sub	 esi, 8
  00107	e8 00 00 00 00	 call	 _DecipherBlock

; 519  : 
; 520  : 				// Pre-whitening
; 521  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  0010c	8b 16		 mov	 edx, DWORD PTR [esi]
  0010e	31 17		 xor	 DWORD PTR [edi], edx
  00110	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00113	31 47 04	 xor	 DWORD PTR [edi+4], eax

; 522  : 				*bufPtr++ ^= *whiteningValuePtr64;

  00116	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00119	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0011c	31 4f 08	 xor	 DWORD PTR [edi+8], ecx
  0011f	31 57 0c	 xor	 DWORD PTR [edi+12], edx
  00122	83 c6 08	 add	 esi, 8
  00125	83 c7 08	 add	 edi, 8
  00128	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012b	83 c7 08	 add	 edi, 8

; 523  : 			}
; 524  : 			else

  0012e	eb 03		 jmp	 SHORT $LN7@DecryptBuf@2
$LN8@DecryptBuf@2:

; 525  : 				whiteningValuePtr64++;

  00130	83 c6 08	 add	 esi, 8
$LN7@DecryptBuf@2:

; 526  : 
; 527  : 			// Derive the next whitening value
; 528  : 
; 529  : #if BYTE_ORDER == LITTLE_ENDIAN
; 530  : 
; 531  : 			// Little-endian platforms
; 532  : 
; 533  : 			finalCarry = 
; 534  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 535  : 				135 : 0;

  00133	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00136	8b 06		 mov	 eax, DWORD PTR [esi]
  00138	8b e9		 mov	 ebp, ecx
  0013a	81 e5 00 00 00
	80		 and	 ebp, -2147483648	; 80000000H
  00140	33 d2		 xor	 edx, edx
  00142	0b d5		 or	 edx, ebp
  00144	c6 44 24 13 87	 mov	 BYTE PTR _finalCarry$[esp+72], 135 ; 00000087H
  00149	75 05		 jne	 SHORT $LN20@DecryptBuf@2
  0014b	c6 44 24 13 00	 mov	 BYTE PTR _finalCarry$[esp+72], 0
$LN20@DecryptBuf@2:

; 536  : 
; 537  : 			*whiteningValuePtr64-- <<= 1;

  00150	0f a4 c1 01	 shld	 ecx, eax, 1
  00154	03 c0		 add	 eax, eax
  00156	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00159	89 06		 mov	 DWORD PTR [esi], eax

; 538  : 
; 539  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  0015b	8b 6e fc	 mov	 ebp, DWORD PTR [esi-4]
  0015e	8b 46 f8	 mov	 eax, DWORD PTR [esi-8]
  00161	83 ee 08	 sub	 esi, 8
  00164	8b d5		 mov	 edx, ebp
  00166	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H
  0016c	33 c9		 xor	 ecx, ecx
  0016e	0b ca		 or	 ecx, edx
  00170	74 0a		 je	 SHORT $LN37@DecryptBuf@2

; 540  : 				*(whiteningValuePtr64 + 1) |= 1;	

  00172	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00175	83 4e 08 01	 or	 DWORD PTR [esi+8], 1
  00179	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
$LN37@DecryptBuf@2:

; 541  : 
; 542  : 			*whiteningValuePtr64 <<= 1;
; 543  : 
; 544  : #else
; 545  : 			// Big-endian platforms
; 546  : 
; 547  : 			finalCarry = 
; 548  : 				(*whiteningValuePtr64 & 0x80) ?
; 549  : 				135 : 0;
; 550  : 
; 551  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 552  : 
; 553  : 			whiteningValuePtr64--;
; 554  : 
; 555  : 			if (*whiteningValuePtr64 & 0x80)
; 556  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 557  : 
; 558  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 559  : #endif
; 560  : 
; 561  : 			whiteningValue[0] ^= finalCarry;

  0017c	8a 54 24 13	 mov	 dl, BYTE PTR _finalCarry$[esp+72]
  00180	0f a4 c5 01	 shld	 ebp, eax, 1
  00184	03 c0		 add	 eax, eax
  00186	89 06		 mov	 DWORD PTR [esi], eax
  00188	8b 44 24 18	 mov	 eax, DWORD PTR _block$[esp+72]
  0018c	40		 inc	 eax
  0018d	89 6e 04	 mov	 DWORD PTR [esi+4], ebp
  00190	30 54 24 34	 xor	 BYTE PTR _whiteningValue$[esp+72], dl
  00194	89 44 24 18	 mov	 DWORD PTR _block$[esp+72], eax
  00198	3b c3		 cmp	 eax, ebx
  0019a	0f 82 30 ff ff
	ff		 jb	 $LL36@DecryptBuf@2
  001a0	8b 6c 24 20	 mov	 ebp, DWORD PTR _blockCount$[esp+76]
  001a4	33 c0		 xor	 eax, eax
$LN9@DecryptBuf@2:

; 562  : 		}
; 563  : 
; 564  : 		blockCount -= endBlock - startBlock;

  001a6	2b 5c 24 14	 sub	 ebx, DWORD PTR _startBlock$[esp+72]

; 565  : 		startBlock = 0;

  001aa	89 44 24 14	 mov	 DWORD PTR _startBlock$[esp+72], eax
  001ae	29 5c 24 1c	 sub	 DWORD PTR _blockCount$[esp+72], ebx
  001b2	1b e8		 sbb	 ebp, eax

; 566  : 		dataUnitNo++;

  001b4	83 44 24 24 01	 add	 DWORD PTR _dataUnitNo$[esp+72], 1
  001b9	89 6c 24 20	 mov	 DWORD PTR _blockCount$[esp+76], ebp
  001bd	11 44 24 28	 adc	 DWORD PTR _dataUnitNo$[esp+76], eax
  001c1	3b e8		 cmp	 ebp, eax
  001c3	0f 87 a7 fe ff
	ff		 ja	 $LL34@DecryptBuf@2

; 490  : 
; 491  : 	// Process all blocks in the buffer
; 492  : 	while (blockCount > 0)

  001c9	72 0b		 jb	 SHORT $LN38@DecryptBuf@2
  001cb	83 7c 24 1c 00	 cmp	 DWORD PTR _blockCount$[esp+72], 0
  001d0	0f 87 9a fe ff
	ff		 ja	 $LL34@DecryptBuf@2
$LN38@DecryptBuf@2:
  001d6	5e		 pop	 esi
  001d7	33 c9		 xor	 ecx, ecx
  001d9	5b		 pop	 ebx
$LN5@DecryptBuf@2:
  001da	5f		 pop	 edi

; 567  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 568  : 	}
; 569  : 
; 570  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  001db	8d 44 24 28	 lea	 eax, DWORD PTR _whiteningValue$[esp+60]
  001df	ba 02 00 00 00	 mov	 edx, 2
  001e4	5d		 pop	 ebp
$LL2@DecryptBuf@2:
  001e5	89 08		 mov	 DWORD PTR [eax], ecx
  001e7	4a		 dec	 edx
  001e8	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  001eb	83 c0 08	 add	 eax, 8
  001ee	3b d1		 cmp	 edx, ecx
  001f0	75 f3		 jne	 SHORT $LL2@DecryptBuf@2

; 571  : }

  001f2	8b 4c 24 34	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+56]
  001f6	33 cc		 xor	 ecx, esp
  001f8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001fd	83 c4 38	 add	 esp, 56			; 00000038H
  00200	c3		 ret	 0
_DecryptBufferXTSNonParallel ENDP
_TEXT	ENDS
PUBLIC	_EncryptBufferXTS
EXTRN	_CipherSupportsIntraDataUnitParallelization:PROC
; Function compile flags: /Ogtpy
;	COMDAT _EncryptBufferXTS
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_ks$ = 28						; size = 4
_ks2$ = 32						; size = 4
_cipher$ = 36						; size = 4
_EncryptBufferXTS PROC					; COMDAT

; 48   : {

  00000	56		 push	 esi

; 49   : 	if (CipherSupportsIntraDataUnitParallelization (cipher))

  00001	8b 74 24 24	 mov	 esi, DWORD PTR _cipher$[esp]
  00005	56		 push	 esi
  00006	e8 00 00 00 00	 call	 _CipherSupportsIntraDataUnitParallelization
  0000b	83 c4 04	 add	 esp, 4

; 50   : 		EncryptBufferXTSParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  0000e	56		 push	 esi
  0000f	85 c0		 test	 eax, eax
  00011	74 2b		 je	 SHORT $LN2@EncryptBuf@3
  00013	8b 44 24 1c	 mov	 eax, DWORD PTR _startCipherBlockNo$[esp+4]
  00017	8b 4c 24 18	 mov	 ecx, DWORD PTR _startDataUnitNo$[esp+4]
  0001b	8b 54 24 14	 mov	 edx, DWORD PTR _length$[esp+8]
  0001f	50		 push	 eax
  00020	8b 44 24 14	 mov	 eax, DWORD PTR _length$[esp+8]
  00024	51		 push	 ecx
  00025	8b 4c 24 14	 mov	 ecx, DWORD PTR _buffer$[esp+12]
  00029	52		 push	 edx
  0002a	8b 54 24 30	 mov	 edx, DWORD PTR _ks2$[esp+16]
  0002e	50		 push	 eax
  0002f	51		 push	 ecx
  00030	8b 4c 24 34	 mov	 ecx, DWORD PTR _ks$[esp+24]
  00034	e8 00 00 00 00	 call	 _EncryptBufferXTSParallel

; 51   : 	else
; 52   : 		EncryptBufferXTSNonParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  00039	83 c4 18	 add	 esp, 24			; 00000018H
  0003c	5e		 pop	 esi

; 53   : }

  0003d	c3		 ret	 0
$LN2@EncryptBuf@3:

; 51   : 	else
; 52   : 		EncryptBufferXTSNonParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  0003e	8b 54 24 1c	 mov	 edx, DWORD PTR _startCipherBlockNo$[esp+4]
  00042	8b 44 24 18	 mov	 eax, DWORD PTR _startDataUnitNo$[esp+4]
  00046	8b 4c 24 14	 mov	 ecx, DWORD PTR _length$[esp+8]
  0004a	52		 push	 edx
  0004b	8b 54 24 14	 mov	 edx, DWORD PTR _length$[esp+8]
  0004f	50		 push	 eax
  00050	8b 44 24 14	 mov	 eax, DWORD PTR _buffer$[esp+12]
  00054	51		 push	 ecx
  00055	8b 4c 24 2c	 mov	 ecx, DWORD PTR _ks$[esp+16]
  00059	52		 push	 edx
  0005a	8b 54 24 34	 mov	 edx, DWORD PTR _ks2$[esp+20]
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 _EncryptBufferXTSNonParallel
  00064	83 c4 18	 add	 esp, 24			; 00000018H
  00067	5e		 pop	 esi

; 53   : }

  00068	c3		 ret	 0
_EncryptBufferXTS ENDP
_TEXT	ENDS
PUBLIC	_DecryptBufferXTS
; Function compile flags: /Ogtpy
;	COMDAT _DecryptBufferXTS
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_ks$ = 28						; size = 4
_ks2$ = 32						; size = 4
_cipher$ = 36						; size = 4
_DecryptBufferXTS PROC					; COMDAT

; 323  : {

  00000	56		 push	 esi

; 324  : 	if (CipherSupportsIntraDataUnitParallelization (cipher))

  00001	8b 74 24 24	 mov	 esi, DWORD PTR _cipher$[esp]
  00005	56		 push	 esi
  00006	e8 00 00 00 00	 call	 _CipherSupportsIntraDataUnitParallelization
  0000b	83 c4 04	 add	 esp, 4

; 325  : 		DecryptBufferXTSParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  0000e	56		 push	 esi
  0000f	85 c0		 test	 eax, eax
  00011	74 2b		 je	 SHORT $LN2@DecryptBuf@3
  00013	8b 44 24 1c	 mov	 eax, DWORD PTR _startCipherBlockNo$[esp+4]
  00017	8b 4c 24 18	 mov	 ecx, DWORD PTR _startDataUnitNo$[esp+4]
  0001b	8b 54 24 14	 mov	 edx, DWORD PTR _length$[esp+8]
  0001f	50		 push	 eax
  00020	8b 44 24 14	 mov	 eax, DWORD PTR _length$[esp+8]
  00024	51		 push	 ecx
  00025	8b 4c 24 14	 mov	 ecx, DWORD PTR _buffer$[esp+12]
  00029	52		 push	 edx
  0002a	8b 54 24 30	 mov	 edx, DWORD PTR _ks2$[esp+16]
  0002e	50		 push	 eax
  0002f	51		 push	 ecx
  00030	8b 4c 24 34	 mov	 ecx, DWORD PTR _ks$[esp+24]
  00034	e8 00 00 00 00	 call	 _DecryptBufferXTSParallel

; 326  : 	else
; 327  : 		DecryptBufferXTSNonParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  00039	83 c4 18	 add	 esp, 24			; 00000018H
  0003c	5e		 pop	 esi

; 328  : }

  0003d	c3		 ret	 0
$LN2@DecryptBuf@3:

; 326  : 	else
; 327  : 		DecryptBufferXTSNonParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  0003e	8b 54 24 1c	 mov	 edx, DWORD PTR _startCipherBlockNo$[esp+4]
  00042	8b 44 24 18	 mov	 eax, DWORD PTR _startDataUnitNo$[esp+4]
  00046	8b 4c 24 14	 mov	 ecx, DWORD PTR _length$[esp+8]
  0004a	52		 push	 edx
  0004b	8b 54 24 14	 mov	 edx, DWORD PTR _length$[esp+8]
  0004f	50		 push	 eax
  00050	8b 44 24 14	 mov	 eax, DWORD PTR _buffer$[esp+12]
  00054	51		 push	 ecx
  00055	8b 4c 24 2c	 mov	 ecx, DWORD PTR _ks$[esp+16]
  00059	52		 push	 edx
  0005a	8b 54 24 34	 mov	 edx, DWORD PTR _ks2$[esp+20]
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 _DecryptBufferXTSNonParallel
  00064	83 c4 18	 add	 esp, 24			; 00000018H
  00067	5e		 pop	 esi

; 328  : }

  00068	c3		 ret	 0
_DecryptBufferXTS ENDP
_TEXT	ENDS
END
