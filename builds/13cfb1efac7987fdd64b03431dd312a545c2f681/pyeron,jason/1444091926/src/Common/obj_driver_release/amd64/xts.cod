; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	__$ArrayPad$
;	COMDAT pdata
; File c:\users\public\desktop\projects\ciphershed\src\common\xts.c
pdata	SEGMENT
$pdata$DecryptBufferXTSNonParallel DD imagerel DecryptBufferXTSNonParallel
	DD	imagerel DecryptBufferXTSNonParallel+378
	DD	imagerel $unwind$DecryptBufferXTSNonParallel
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecryptBufferXTSNonParallel DD 0c2b19H
	DD	013641cH
	DD	012541cH
	DD	011341cH
	DD	0f018921cH
	DD	0d014e016H
	DD	07010c012H
	DD	imagerel __GSHandlerCheck
	DD	048H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT DecryptBufferXTSNonParallel
_TEXT	SEGMENT
ks2$GSCopy$1$ = 48
whiteningValue$ = 56
__$ArrayPad$ = 72
buffer$ = 128
length$ = 136
startDataUnitNo$ = 144
startCipherBlockNo$ = 152
ks$ = 160
ks2$ = 168
cipher$ = 176
DecryptBufferXTSNonParallel PROC			; COMDAT

; 471  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 10	 mov	 QWORD PTR [r11+16], rbx
  00007	49 89 6b 18	 mov	 QWORD PTR [r11+24], rbp
  0000b	49 89 73 20	 mov	 QWORD PTR [r11+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0002b	4c 8b b4 24 a8
	00 00 00	 mov	 r14, QWORD PTR ks2$[rsp]
  00033	4c 8b bc 24 a0
	00 00 00	 mov	 r15, QWORD PTR ks$[rsp]

; 472  : 	unsigned __int8 finalCarry;
; 473  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 474  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 475  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 476  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
; 477  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;
; 478  : 	TC_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 479  : 
; 480  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 481  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 482  : 	dataUnitNo = startDataUnitNo->Value;

  0003b	49 8b 28	 mov	 rbp, QWORD PTR [r8]
  0003e	4c 89 74 24 30	 mov	 QWORD PTR ks2$GSCopy$1$[rsp], r14
  00043	48 8b da	 mov	 rbx, rdx
  00046	4c 8b e9	 mov	 r13, rcx

; 483  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 484  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
; 485  : 
; 486  : 	if (length % BYTES_PER_XTS_BLOCK)

  00049	f6 c2 0f	 test	 dl, 15
  0004c	74 1e		 je	 SHORT $LN16@DecryptBuf

; 487  : 		TC_THROW_FATAL_EXCEPTION;

  0004e	45 33 c9	 xor	 r9d, r9d
  00051	45 33 c0	 xor	 r8d, r8d
  00054	ba e7 01 00 00	 mov	 edx, 487		; 000001e7H
  00059	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  0005d	49 c7 43 a8 43
	54 00 00	 mov	 QWORD PTR [r11-88], 21571 ; 00005443H
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  0006b	cc		 int	 3
$LN16@DecryptBuf:

; 488  : 
; 489  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  0006c	48 c1 eb 04	 shr	 rbx, 4

; 490  : 
; 491  : 	// Process all blocks in the buffer
; 492  : 	while (blockCount > 0)

  00070	48 85 db	 test	 rbx, rbx
  00073	0f 84 bc 00 00
	00		 je	 $LN5@DecryptBuf
$LL15@DecryptBuf:

; 493  : 	{
; 494  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)
; 495  : 			endBlock = startBlock + (unsigned int) blockCount;
; 496  : 		else
; 497  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;
; 498  : 
; 499  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 500  : 
; 501  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 502  : 		// whitening value for this data unit)
; 503  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);
; 504  : 		*(whiteningValuePtr64 + 1) = 0;
; 505  : 		EncipherBlock (cipher, whiteningValue, ks2);

  00079	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  00080	bf 20 00 00 00	 mov	 edi, 32			; 00000020H
  00085	48 8d 54 24 38	 lea	 rdx, QWORD PTR whiteningValue$[rsp]
  0008a	48 3b df	 cmp	 rbx, rdi
  0008d	4d 8b c6	 mov	 r8, r14
  00090	48 8d 74 24 38	 lea	 rsi, QWORD PTR whiteningValue$[rsp]
  00095	0f 42 fb	 cmovb	 edi, ebx
  00098	48 83 64 24 40
	00		 and	 QWORD PTR whiteningValue$[rsp+8], 0
  0009e	48 89 6c 24 38	 mov	 QWORD PTR whiteningValue$[rsp], rbp
  000a3	e8 00 00 00 00	 call	 EncipherBlock

; 506  : 
; 507  : 		// Generate (and apply) subsequent whitening values for blocks in this data unit and
; 508  : 		// decrypt all relevant blocks in this data unit
; 509  : 		for (block = 0; block < endBlock; block++)

  000a8	45 33 e4	 xor	 r12d, r12d
  000ab	85 ff		 test	 edi, edi
  000ad	74 78		 je	 SHORT $LN9@DecryptBuf
  000af	49 be 00 00 00
	00 00 00 00 80	 mov	 r14, -9223372036854775808 ; 8000000000000000H
$LL11@DecryptBuf:

; 510  : 		{
; 511  : 			if (block >= startBlock)
; 512  : 			{
; 513  : 				// Post-whitening
; 514  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  000b9	48 8b 06	 mov	 rax, QWORD PTR [rsi]

; 515  : 				*bufPtr-- ^= *whiteningValuePtr64--;
; 516  : 
; 517  : 				// Actual decryption
; 518  : 				DecipherBlock (cipher, bufPtr, ks);

  000bc	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  000c3	4d 8b c7	 mov	 r8, r15
  000c6	49 31 45 00	 xor	 QWORD PTR [r13], rax
  000ca	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  000ce	49 8b d5	 mov	 rdx, r13
  000d1	49 31 45 08	 xor	 QWORD PTR [r13+8], rax
  000d5	e8 00 00 00 00	 call	 DecipherBlock

; 519  : 
; 520  : 				// Pre-whitening
; 521  : 				*bufPtr++ ^= *whiteningValuePtr64++;
; 522  : 				*bufPtr++ ^= *whiteningValuePtr64;

  000da	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  000de	4c 8b 1e	 mov	 r11, QWORD PTR [rsi]

; 523  : 			}
; 524  : 			else
; 525  : 				whiteningValuePtr64++;
; 526  : 
; 527  : 			// Derive the next whitening value
; 528  : 
; 529  : #if BYTE_ORDER == LITTLE_ENDIAN
; 530  : 
; 531  : 			// Little-endian platforms
; 532  : 
; 533  : 			finalCarry = 
; 534  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 535  : 				135 : 0;

  000e1	48 8b c8	 mov	 rcx, rax
  000e4	4d 31 5d 00	 xor	 QWORD PTR [r13], r11
  000e8	49 31 45 08	 xor	 QWORD PTR [r13+8], rax
  000ec	49 23 c6	 and	 rax, r14
  000ef	49 83 c5 10	 add	 r13, 16
  000f3	48 f7 d8	 neg	 rax

; 536  : 
; 537  : 			*whiteningValuePtr64-- <<= 1;

  000f6	48 8d 04 09	 lea	 rax, QWORD PTR [rcx+rcx]
  000fa	1a d2		 sbb	 dl, dl
  000fc	48 89 46 08	 mov	 QWORD PTR [rsi+8], rax

; 538  : 
; 539  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  00100	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00103	80 e2 87	 and	 dl, 135			; 00000087H
  00106	49 85 c6	 test	 rax, r14
  00109	74 05		 je	 SHORT $LN6@DecryptBuf

; 540  : 				*(whiteningValuePtr64 + 1) |= 1;	

  0010b	48 83 4e 08 01	 or	 QWORD PTR [rsi+8], 1
$LN6@DecryptBuf:

; 541  : 
; 542  : 			*whiteningValuePtr64 <<= 1;

  00110	48 03 c0	 add	 rax, rax
  00113	41 ff c4	 inc	 r12d
  00116	48 89 06	 mov	 QWORD PTR [rsi], rax

; 543  : 
; 544  : #else
; 545  : 			// Big-endian platforms
; 546  : 
; 547  : 			finalCarry = 
; 548  : 				(*whiteningValuePtr64 & 0x80) ?
; 549  : 				135 : 0;
; 550  : 
; 551  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 552  : 
; 553  : 			whiteningValuePtr64--;
; 554  : 
; 555  : 			if (*whiteningValuePtr64 & 0x80)
; 556  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 557  : 
; 558  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 559  : #endif
; 560  : 
; 561  : 			whiteningValue[0] ^= finalCarry;

  00119	30 54 24 38	 xor	 BYTE PTR whiteningValue$[rsp], dl
  0011d	44 3b e7	 cmp	 r12d, edi
  00120	72 97		 jb	 SHORT $LL11@DecryptBuf
  00122	4c 8b 74 24 30	 mov	 r14, QWORD PTR ks2$GSCopy$1$[rsp]
$LN9@DecryptBuf:

; 562  : 		}
; 563  : 
; 564  : 		blockCount -= endBlock - startBlock;

  00127	8b c7		 mov	 eax, edi

; 565  : 		startBlock = 0;
; 566  : 		dataUnitNo++;

  00129	48 ff c5	 inc	 rbp
  0012c	48 2b d8	 sub	 rbx, rax
  0012f	0f 85 44 ff ff
	ff		 jne	 $LL15@DecryptBuf
$LN5@DecryptBuf:

; 567  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 568  : 	}
; 569  : 
; 570  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  00135	48 8d 44 24 38	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  0013a	b9 02 00 00 00	 mov	 ecx, 2
$LL2@DecryptBuf:
  0013f	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00146	48 83 c0 08	 add	 rax, 8
  0014a	83 e9 01	 sub	 ecx, 1
  0014d	75 f0		 jne	 SHORT $LL2@DecryptBuf

; 571  : }

  0014f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00154	48 33 cc	 xor	 rcx, rsp
  00157	e8 00 00 00 00	 call	 __security_check_cookie
  0015c	4c 8d 5c 24 50	 lea	 r11, QWORD PTR [rsp+80]
  00161	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  00165	49 8b 6b 40	 mov	 rbp, QWORD PTR [r11+64]
  00169	49 8b 73 48	 mov	 rsi, QWORD PTR [r11+72]
  0016d	49 8b e3	 mov	 rsp, r11
  00170	41 5f		 pop	 r15
  00172	41 5e		 pop	 r14
  00174	41 5d		 pop	 r13
  00176	41 5c		 pop	 r12
  00178	5f		 pop	 rdi
  00179	c3		 ret	 0
$LN26@DecryptBuf:
DecryptBufferXTSNonParallel ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptBufferXTSNonParallel DD imagerel EncryptBufferXTSNonParallel
	DD	imagerel EncryptBufferXTSNonParallel+439
	DD	imagerel $unwind$EncryptBufferXTSNonParallel
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptBufferXTSNonParallel DD 0c2b19H
	DD	015641cH
	DD	014541cH
	DD	013341cH
	DD	0f018b21cH
	DD	0d014e016H
	DD	07010c012H
	DD	imagerel __GSHandlerCheck
	DD	050H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EncryptBufferXTSNonParallel
_TEXT	SEGMENT
ks2$GSCopy$1$ = 48
ks$GSCopy$1$ = 56
whiteningValue$ = 64
__$ArrayPad$ = 80
buffer$ = 144
length$ = 152
startDataUnitNo$ = 160
startCipherBlockNo$ = 168
ks$ = 176
ks2$ = 184
cipher$ = 192
EncryptBufferXTSNonParallel PROC			; COMDAT

; 205  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 10	 mov	 QWORD PTR [r11+16], rbx
  00007	49 89 6b 18	 mov	 QWORD PTR [r11+24], rbp
  0000b	49 89 73 20	 mov	 QWORD PTR [r11+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0002b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ks$[rsp]
  00033	4c 8b bc 24 b8
	00 00 00	 mov	 r15, QWORD PTR ks2$[rsp]

; 206  : 	unsigned __int8 finalCarry;
; 207  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 208  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 209  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 210  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
; 211  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;
; 212  : 	TC_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 213  : 
; 214  : 	/* The encrypted data unit number (i.e. the resultant ciphertext block) is to be multiplied in the
; 215  : 	finite field GF(2^128) by j-th power of n, where j is the sequential plaintext/ciphertext block
; 216  : 	number and n is 2, a primitive element of GF(2^128). This can be (and is) simplified and implemented
; 217  : 	as a left shift of the preceding whitening value by one bit (with carry propagating). In addition, if
; 218  : 	the shift of the highest byte results in a carry, 135 is XORed into the lowest byte. The value 135 is
; 219  : 	derived from the modulus of the Galois Field (x^128+x^7+x^2+x+1). */
; 220  : 
; 221  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 222  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 223  : 	dataUnitNo = startDataUnitNo->Value;

  0003b	4d 8b 30	 mov	 r14, QWORD PTR [r8]
  0003e	48 89 44 24 38	 mov	 QWORD PTR ks$GSCopy$1$[rsp], rax
  00043	4c 89 7c 24 30	 mov	 QWORD PTR ks2$GSCopy$1$[rsp], r15
  00048	45 8b e9	 mov	 r13d, r9d
  0004b	48 8b da	 mov	 rbx, rdx
  0004e	48 8b e9	 mov	 rbp, rcx

; 224  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 225  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
; 226  : 
; 227  : 	if (length % BYTES_PER_XTS_BLOCK)

  00051	f6 c2 0f	 test	 dl, 15
  00054	74 1e		 je	 SHORT $LN16@EncryptBuf

; 228  : 		TC_THROW_FATAL_EXCEPTION;

  00056	45 33 c9	 xor	 r9d, r9d
  00059	45 33 c0	 xor	 r8d, r8d
  0005c	ba e4 00 00 00	 mov	 edx, 228		; 000000e4H
  00061	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00065	49 c7 43 98 43
	54 00 00	 mov	 QWORD PTR [r11-104], 21571 ; 00005443H
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00073	cc		 int	 3
$LN16@EncryptBuf:

; 229  : 
; 230  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  00074	48 c1 eb 04	 shr	 rbx, 4

; 231  : 
; 232  : 	// Process all blocks in the buffer
; 233  : 	while (blockCount > 0)

  00078	48 85 db	 test	 rbx, rbx
  0007b	0f 84 f1 00 00
	00		 je	 $LN5@EncryptBuf
$LL15@EncryptBuf:

; 234  : 	{
; 235  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)
; 236  : 			endBlock = startBlock + (unsigned int) blockCount;

  00081	42 8d 34 2b	 lea	 esi, DWORD PTR [rbx+r13]
  00085	48 83 fb 20	 cmp	 rbx, 32			; 00000020H
  00089	72 05		 jb	 SHORT $LN12@EncryptBuf

; 237  : 		else
; 238  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  0008b	be 20 00 00 00	 mov	 esi, 32			; 00000020H
$LN12@EncryptBuf:

; 239  : 
; 240  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 241  : 
; 242  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 243  : 		// whitening value for this data unit)
; 244  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);
; 245  : 		*(whiteningValuePtr64 + 1) = 0;
; 246  : 		EncipherBlock (cipher, whiteningValue, ks2);

  00090	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  00097	48 83 64 24 48
	00		 and	 QWORD PTR whiteningValue$[rsp+8], 0
  0009d	48 8d 54 24 40	 lea	 rdx, QWORD PTR whiteningValue$[rsp]
  000a2	4d 8b c7	 mov	 r8, r15
  000a5	48 8d 7c 24 40	 lea	 rdi, QWORD PTR whiteningValue$[rsp]
  000aa	4c 89 74 24 40	 mov	 QWORD PTR whiteningValue$[rsp], r14
  000af	e8 00 00 00 00	 call	 EncipherBlock

; 247  : 
; 248  : 		// Generate (and apply) subsequent whitening values for blocks in this data unit and
; 249  : 		// encrypt all relevant blocks in this data unit
; 250  : 		for (block = 0; block < endBlock; block++)

  000b4	45 33 e4	 xor	 r12d, r12d
  000b7	85 f6		 test	 esi, esi
  000b9	0f 84 9f 00 00
	00		 je	 $LN9@EncryptBuf
  000bf	4c 8b 7c 24 38	 mov	 r15, QWORD PTR ks$GSCopy$1$[rsp]
  000c4	49 b8 00 00 00
	00 00 00 00 80	 mov	 r8, -9223372036854775808 ; 8000000000000000H
$LL11@EncryptBuf:

; 251  : 		{
; 252  : 			if (block >= startBlock)

  000ce	45 3b e5	 cmp	 r12d, r13d
  000d1	72 43		 jb	 SHORT $LN8@EncryptBuf

; 253  : 			{
; 254  : 				// Pre-whitening
; 255  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  000d3	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 256  : 				*bufPtr-- ^= *whiteningValuePtr64--;
; 257  : 
; 258  : 				// Actual encryption
; 259  : 				EncipherBlock (cipher, bufPtr, ks);

  000d6	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  000dd	4d 8b c7	 mov	 r8, r15
  000e0	48 31 45 00	 xor	 QWORD PTR [rbp], rax
  000e4	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  000e8	48 8b d5	 mov	 rdx, rbp
  000eb	48 31 45 08	 xor	 QWORD PTR [rbp+8], rax
  000ef	e8 00 00 00 00	 call	 EncipherBlock

; 260  : 
; 261  : 				// Post-whitening
; 262  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  000f4	4c 8b 1f	 mov	 r11, QWORD PTR [rdi]
  000f7	4c 31 5d 00	 xor	 QWORD PTR [rbp], r11
  000fb	48 83 c7 08	 add	 rdi, 8

; 263  : 				*bufPtr++ ^= *whiteningValuePtr64;
; 264  : 			}
; 265  : 			else

  000ff	49 b8 00 00 00
	00 00 00 00 80	 mov	 r8, -9223372036854775808 ; 8000000000000000H
  00109	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0010c	48 31 45 08	 xor	 QWORD PTR [rbp+8], rax
  00110	48 83 c5 10	 add	 rbp, 16
  00114	eb 04		 jmp	 SHORT $LN7@EncryptBuf
$LN8@EncryptBuf:

; 266  : 				whiteningValuePtr64++;

  00116	48 83 c7 08	 add	 rdi, 8
$LN7@EncryptBuf:

; 267  : 
; 268  : 			// Derive the next whitening value
; 269  : 
; 270  : #if BYTE_ORDER == LITTLE_ENDIAN
; 271  : 
; 272  : 			// Little-endian platforms
; 273  : 
; 274  : 			finalCarry = 
; 275  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 276  : 				135 : 0;

  0011a	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  0011d	48 8b c1	 mov	 rax, rcx
  00120	49 23 c0	 and	 rax, r8
  00123	48 f7 d8	 neg	 rax

; 277  : 
; 278  : 			*whiteningValuePtr64-- <<= 1;

  00126	48 8d 04 09	 lea	 rax, QWORD PTR [rcx+rcx]
  0012a	1a d2		 sbb	 dl, dl
  0012c	48 89 07	 mov	 QWORD PTR [rdi], rax
  0012f	48 83 ef 08	 sub	 rdi, 8

; 279  : 
; 280  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  00133	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00136	80 e2 87	 and	 dl, 135			; 00000087H
  00139	49 85 c0	 test	 rax, r8
  0013c	74 05		 je	 SHORT $LN6@EncryptBuf

; 281  : 				*(whiteningValuePtr64 + 1) |= 1;	

  0013e	48 83 4f 08 01	 or	 QWORD PTR [rdi+8], 1
$LN6@EncryptBuf:

; 282  : 
; 283  : 			*whiteningValuePtr64 <<= 1;

  00143	48 03 c0	 add	 rax, rax
  00146	41 ff c4	 inc	 r12d
  00149	48 89 07	 mov	 QWORD PTR [rdi], rax

; 284  : #else
; 285  : 
; 286  : 			// Big-endian platforms
; 287  : 
; 288  : 			finalCarry = 
; 289  : 				(*whiteningValuePtr64 & 0x80) ?
; 290  : 				135 : 0;
; 291  : 
; 292  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 293  : 
; 294  : 			whiteningValuePtr64--;
; 295  : 
; 296  : 			if (*whiteningValuePtr64 & 0x80)
; 297  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 298  : 
; 299  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 300  : #endif
; 301  : 
; 302  : 			whiteningValue[0] ^= finalCarry;

  0014c	30 54 24 40	 xor	 BYTE PTR whiteningValue$[rsp], dl
  00150	44 3b e6	 cmp	 r12d, esi
  00153	0f 82 75 ff ff
	ff		 jb	 $LL11@EncryptBuf
  00159	4c 8b 7c 24 30	 mov	 r15, QWORD PTR ks2$GSCopy$1$[rsp]
$LN9@EncryptBuf:

; 303  : 		}
; 304  : 
; 305  : 		blockCount -= endBlock - startBlock;

  0015e	41 2b f5	 sub	 esi, r13d

; 306  : 		startBlock = 0;
; 307  : 		dataUnitNo++;

  00161	49 ff c6	 inc	 r14
  00164	45 33 ed	 xor	 r13d, r13d
  00167	8b c6		 mov	 eax, esi
  00169	48 2b d8	 sub	 rbx, rax
  0016c	0f 85 0f ff ff
	ff		 jne	 $LL15@EncryptBuf
$LN5@EncryptBuf:

; 308  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 309  : 	}
; 310  : 
; 311  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  00172	48 8d 44 24 40	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  00177	b9 02 00 00 00	 mov	 ecx, 2
$LL2@EncryptBuf:
  0017c	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00183	48 83 c0 08	 add	 rax, 8
  00187	83 e9 01	 sub	 ecx, 1
  0018a	75 f0		 jne	 SHORT $LL2@EncryptBuf

; 312  : }

  0018c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00191	48 33 cc	 xor	 rcx, rsp
  00194	e8 00 00 00 00	 call	 __security_check_cookie
  00199	4c 8d 5c 24 60	 lea	 r11, QWORD PTR [rsp+96]
  0019e	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  001a2	49 8b 6b 40	 mov	 rbp, QWORD PTR [r11+64]
  001a6	49 8b 73 48	 mov	 rsi, QWORD PTR [r11+72]
  001aa	49 8b e3	 mov	 rsp, r11
  001ad	41 5f		 pop	 r15
  001af	41 5e		 pop	 r14
  001b1	41 5d		 pop	 r13
  001b3	41 5c		 pop	 r12
  001b5	5f		 pop	 rdi
  001b6	c3		 ret	 0
$LN26@EncryptBuf:
EncryptBufferXTSNonParallel ENDP
PUBLIC	__$ArrayPad$
;	COMDAT pdata
pdata	SEGMENT
$pdata$DecryptBufferXTSParallel DD imagerel DecryptBufferXTSParallel
	DD	imagerel DecryptBufferXTSParallel+484
	DD	imagerel $unwind$DecryptBufferXTSParallel
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecryptBufferXTSParallel DD 0b2919H
	DD	0543417H
	DD	04a0117H
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0240H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT DecryptBufferXTSParallel
_TEXT	SEGMENT
whiteningValue$ = 48
whiteningValues$ = 64
__$ArrayPad$ = 576
buffer$ = 656
length$ = 664
startDataUnitNo$ = 672
startCipherBlockNo$ = 680
ks$ = 688
ks2$ = 696
cipher$ = 704
DecryptBufferXTSParallel PROC				; COMDAT

; 339  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 81 ec 50 02
	00 00		 sub	 rsp, 592		; 00000250H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00029	4c 8b b4 24 b0
	02 00 00	 mov	 r14, QWORD PTR ks$[rsp]
  00031	4c 8b bc 24 b8
	02 00 00	 mov	 r15, QWORD PTR ks2$[rsp]

; 340  : 	unsigned __int8 finalCarry;
; 341  : 	unsigned __int8 whiteningValues [ENCRYPTION_DATA_UNIT_SIZE];
; 342  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 343  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 344  : 	unsigned __int64 *whiteningValuesPtr64 = (unsigned __int64 *) whiteningValues;
; 345  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 346  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
; 347  : 	unsigned __int64 *dataUnitBufPtr;
; 348  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;
; 349  : 	unsigned __int64 *const finalInt64WhiteningValuesPtr = whiteningValuesPtr64 + sizeof (whiteningValues) / sizeof (*whiteningValuesPtr64) - 1;
; 350  : 	TC_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 351  : 
; 352  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 353  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 354  : 	dataUnitNo = startDataUnitNo->Value;

  00039	4d 8b 28	 mov	 r13, QWORD PTR [r8]
  0003c	48 8b fa	 mov	 rdi, rdx
  0003f	48 8b d9	 mov	 rbx, rcx

; 355  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 356  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
; 357  : 
; 358  : 	if (length % BYTES_PER_XTS_BLOCK)

  00042	f6 c2 0f	 test	 dl, 15
  00045	74 1f		 je	 SHORT $LN27@DecryptBuf@5

; 359  : 		TC_THROW_FATAL_EXCEPTION;

  00047	45 33 c9	 xor	 r9d, r9d
  0004a	45 33 c0	 xor	 r8d, r8d
  0004d	ba 67 01 00 00	 mov	 edx, 359		; 00000167H
  00052	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00056	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00065	cc		 int	 3
$LN27@DecryptBuf@5:

; 360  : 
; 361  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  00066	48 c1 ef 04	 shr	 rdi, 4

; 362  : 
; 363  : 	// Process all blocks in the buffer
; 364  : 	while (blockCount > 0)

  0006a	48 85 ff	 test	 rdi, rdi
  0006d	0f 84 12 01 00
	00		 je	 $LN10@DecryptBuf@5
$LL26@DecryptBuf@5:

; 365  : 	{
; 366  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)
; 367  : 			endBlock = startBlock + (unsigned int) blockCount;
; 368  : 		else
; 369  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;
; 370  : 
; 371  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
; 372  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 373  : 
; 374  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 375  : 		// whitening value for this data unit)
; 376  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);
; 377  : 		*(whiteningValuePtr64 + 1) = 0;
; 378  : 		EncipherBlock (cipher, whiteningValue, ks2);

  00073	8b 8c 24 c0 02
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  0007a	be 20 00 00 00	 mov	 esi, 32			; 00000020H
  0007f	48 8d 54 24 30	 lea	 rdx, QWORD PTR whiteningValue$[rsp]
  00084	48 3b fe	 cmp	 rdi, rsi
  00087	4d 8b c7	 mov	 r8, r15
  0008a	4c 8d a4 24 38
	02 00 00	 lea	 r12, QWORD PTR whiteningValues$[rsp+504]
  00092	0f 42 f7	 cmovb	 esi, edi
  00095	48 83 64 24 38
	00		 and	 QWORD PTR whiteningValue$[rsp+8], 0
  0009b	48 8d 6c 24 30	 lea	 rbp, QWORD PTR whiteningValue$[rsp]
  000a0	4c 89 6c 24 30	 mov	 QWORD PTR whiteningValue$[rsp], r13
  000a5	e8 00 00 00 00	 call	 EncipherBlock

; 379  : 
; 380  : 		// Generate subsequent whitening values for blocks in this data unit. Note that all generated 128-bit
; 381  : 		// whitening values are stored in memory as a sequence of 64-bit integers in reverse order.
; 382  : 		for (block = 0; block < endBlock; block++)

  000aa	45 33 db	 xor	 r11d, r11d
  000ad	85 f6		 test	 esi, esi
  000af	74 56		 je	 SHORT $LN20@DecryptBuf@5
  000b1	49 b8 00 00 00
	00 00 00 00 80	 mov	 r8, -9223372036854775808 ; 8000000000000000H
$LL22@DecryptBuf@5:

; 383  : 		{
; 384  : 			if (block >= startBlock)
; 385  : 			{
; 386  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64++;

  000bb	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]
  000bf	49 89 04 24	 mov	 QWORD PTR [r12], rax

; 387  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64;

  000c3	48 8b 45 08	 mov	 rax, QWORD PTR [rbp+8]
  000c7	49 83 ec 10	 sub	 r12, 16
  000cb	49 89 44 24 08	 mov	 QWORD PTR [r12+8], rax

; 388  : 			}
; 389  : 			else
; 390  : 				whiteningValuePtr64++;
; 391  : 
; 392  : 			// Derive the next whitening value
; 393  : 
; 394  : #if BYTE_ORDER == LITTLE_ENDIAN
; 395  : 
; 396  : 			// Little-endian platforms
; 397  : 
; 398  : 			finalCarry = 
; 399  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 400  : 				135 : 0;

  000d0	48 8b c8	 mov	 rcx, rax
  000d3	49 23 c0	 and	 rax, r8
  000d6	48 f7 d8	 neg	 rax

; 401  : 
; 402  : 			*whiteningValuePtr64-- <<= 1;

  000d9	48 8d 04 09	 lea	 rax, QWORD PTR [rcx+rcx]
  000dd	1a d2		 sbb	 dl, dl
  000df	48 89 45 08	 mov	 QWORD PTR [rbp+8], rax

; 403  : 
; 404  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  000e3	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]
  000e7	80 e2 87	 and	 dl, 135			; 00000087H
  000ea	49 85 c0	 test	 rax, r8
  000ed	74 05		 je	 SHORT $LN17@DecryptBuf@5

; 405  : 				*(whiteningValuePtr64 + 1) |= 1;	

  000ef	48 83 4d 08 01	 or	 QWORD PTR [rbp+8], 1
$LN17@DecryptBuf@5:

; 406  : 
; 407  : 			*whiteningValuePtr64 <<= 1;

  000f4	48 03 c0	 add	 rax, rax
  000f7	41 ff c3	 inc	 r11d
  000fa	48 89 45 00	 mov	 QWORD PTR [rbp], rax

; 408  : 
; 409  : #else
; 410  : 			// Big-endian platforms
; 411  : 
; 412  : 			finalCarry = 
; 413  : 				(*whiteningValuePtr64 & 0x80) ?
; 414  : 				135 : 0;
; 415  : 
; 416  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 417  : 
; 418  : 			whiteningValuePtr64--;
; 419  : 
; 420  : 			if (*whiteningValuePtr64 & 0x80)
; 421  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 422  : 
; 423  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 424  : #endif
; 425  : 
; 426  : 			whiteningValue[0] ^= finalCarry;

  000fe	30 54 24 30	 xor	 BYTE PTR whiteningValue$[rsp], dl
  00102	44 3b de	 cmp	 r11d, esi
  00105	72 b4		 jb	 SHORT $LL22@DecryptBuf@5
$LN20@DecryptBuf@5:

; 427  : 		}
; 428  : 
; 429  : 		dataUnitBufPtr = bufPtr;

  00107	4c 8b e3	 mov	 r12, rbx

; 430  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  0010a	48 8d 8c 24 38
	02 00 00	 lea	 rcx, QWORD PTR whiteningValues$[rsp+504]

; 431  : 
; 432  : 		// Decrypt blocks in this data unit
; 433  : 
; 434  : 		for (block = startBlock; block < endBlock; block++)

  00112	85 f6		 test	 esi, esi
  00114	74 1e		 je	 SHORT $LN14@DecryptBuf@5

; 427  : 		}
; 428  : 
; 429  : 		dataUnitBufPtr = bufPtr;

  00116	8b d6		 mov	 edx, esi
$LL16@DecryptBuf@5:

; 435  : 		{
; 436  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00118	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 437  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  0011b	48 83 e9 10	 sub	 rcx, 16
  0011f	48 31 03	 xor	 QWORD PTR [rbx], rax
  00122	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00126	48 83 c3 10	 add	 rbx, 16
  0012a	48 31 43 f8	 xor	 QWORD PTR [rbx-8], rax
  0012e	48 83 ea 01	 sub	 rdx, 1
  00132	75 e4		 jne	 SHORT $LL16@DecryptBuf@5
$LN14@DecryptBuf@5:

; 438  : 		}
; 439  : 
; 440  : 		DecipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);

  00134	8b 8c 24 c0 02
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  0013b	44 8b ce	 mov	 r9d, esi
  0013e	4d 8b c6	 mov	 r8, r14
  00141	49 8b d4	 mov	 rdx, r12
  00144	8b ee		 mov	 ebp, esi
  00146	e8 00 00 00 00	 call	 DecipherBlocks

; 441  : 
; 442  : 		bufPtr = dataUnitBufPtr;

  0014b	49 8b dc	 mov	 rbx, r12

; 443  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  0014e	48 8d 8c 24 38
	02 00 00	 lea	 rcx, QWORD PTR whiteningValues$[rsp+504]

; 444  : 
; 445  : 		for (block = startBlock; block < endBlock; block++)

  00156	85 f6		 test	 esi, esi
  00158	74 1f		 je	 SHORT $LN11@DecryptBuf@5

; 438  : 		}
; 439  : 
; 440  : 		DecipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);

  0015a	48 8b d5	 mov	 rdx, rbp
$LL13@DecryptBuf@5:

; 446  : 		{
; 447  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  0015d	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 448  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00160	48 83 e9 10	 sub	 rcx, 16
  00164	48 31 03	 xor	 QWORD PTR [rbx], rax
  00167	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  0016b	48 83 c3 10	 add	 rbx, 16
  0016f	48 31 43 f8	 xor	 QWORD PTR [rbx-8], rax
  00173	48 83 ea 01	 sub	 rdx, 1
  00177	75 e4		 jne	 SHORT $LL13@DecryptBuf@5
$LN11@DecryptBuf@5:

; 449  : 		}
; 450  : 
; 451  : 		blockCount -= endBlock - startBlock;
; 452  : 		startBlock = 0;
; 453  : 		dataUnitNo++;

  00179	49 ff c5	 inc	 r13
  0017c	48 2b fd	 sub	 rdi, rbp
  0017f	0f 85 ee fe ff
	ff		 jne	 $LL26@DecryptBuf@5
$LN10@DecryptBuf@5:

; 454  : 
; 455  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 456  : 	}
; 457  : 
; 458  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  00185	48 8d 44 24 30	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  0018a	b9 02 00 00 00	 mov	 ecx, 2
$LL7@DecryptBuf@5:
  0018f	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00196	48 83 c0 08	 add	 rax, 8
  0019a	83 e9 01	 sub	 ecx, 1
  0019d	75 f0		 jne	 SHORT $LL7@DecryptBuf@5

; 459  : 	FAST_ERASE64 (whiteningValues, sizeof (whiteningValues));

  0019f	48 8d 44 24 40	 lea	 rax, QWORD PTR whiteningValues$[rsp]
  001a4	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
$LL2@DecryptBuf@5:
  001a9	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  001b0	48 83 c0 08	 add	 rax, 8
  001b4	83 e9 01	 sub	 ecx, 1
  001b7	75 f0		 jne	 SHORT $LL2@DecryptBuf@5

; 460  : }

  001b9	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001c1	48 33 cc	 xor	 rcx, rsp
  001c4	e8 00 00 00 00	 call	 __security_check_cookie
  001c9	48 8b 9c 24 a0
	02 00 00	 mov	 rbx, QWORD PTR [rsp+672]
  001d1	48 81 c4 50 02
	00 00		 add	 rsp, 592		; 00000250H
  001d8	41 5f		 pop	 r15
  001da	41 5e		 pop	 r14
  001dc	41 5d		 pop	 r13
  001de	41 5c		 pop	 r12
  001e0	5f		 pop	 rdi
  001e1	5e		 pop	 rsi
  001e2	5d		 pop	 rbp
  001e3	c3		 ret	 0
$LN44@DecryptBuf@5:
DecryptBufferXTSParallel ENDP
_TEXT	ENDS
PUBLIC	DecryptBufferXTS
;	COMDAT pdata
; File c:\users\public\desktop\projects\ciphershed\src\common\crypto.c
pdata	SEGMENT
$pdata$DecryptBufferXTS DD imagerel $LN10
	DD	imagerel $LN10+155
	DD	imagerel $unwind$DecryptBufferXTS
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecryptBufferXTS DD 081401H
	DD	0c6414H
	DD	0b5414H
	DD	0a3414H
	DD	070107214H
; Function compile flags: /Ogspy
; File c:\users\public\desktop\projects\ciphershed\src\common\xts.c
xdata	ENDS
;	COMDAT DecryptBufferXTS
_TEXT	SEGMENT
buffer$ = 80
length$ = 88
startDataUnitNo$ = 96
startCipherBlockNo$ = 104
ks$ = 112
ks2$ = 120
cipher$ = 128
DecryptBufferXTS PROC					; COMDAT

; 323  : {

$LN10:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 324  : 	if (CipherSupportsIntraDataUnitParallelization (cipher))

  00014	8b 9c 24 80 00
	00 00		 mov	 ebx, DWORD PTR cipher$[rsp]
  0001b	49 8b f8	 mov	 rdi, r8
  0001e	48 8b f2	 mov	 rsi, rdx
  00021	48 8b e9	 mov	 rbp, rcx
  00024	83 fb 01	 cmp	 ebx, 1
  00027	75 34		 jne	 SHORT $LN2@DecryptBuf@6
  00029	e8 00 00 00 00	 call	 IsAesHwCpuSupported
  0002e	85 c0		 test	 eax, eax
  00030	74 2b		 je	 SHORT $LN2@DecryptBuf@6

; 325  : 		DecryptBufferXTSParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  00032	48 8b 44 24 78	 mov	 rax, QWORD PTR ks2$[rsp]
  00037	89 5c 24 30	 mov	 DWORD PTR [rsp+48], ebx
  0003b	45 33 c9	 xor	 r9d, r9d
  0003e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00043	48 8b 44 24 70	 mov	 rax, QWORD PTR ks$[rsp]
  00048	4c 8b c7	 mov	 r8, rdi
  0004b	48 8b d6	 mov	 rdx, rsi
  0004e	48 8b cd	 mov	 rcx, rbp
  00051	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00056	e8 00 00 00 00	 call	 DecryptBufferXTSParallel

; 326  : 	else

  0005b	eb 29		 jmp	 SHORT $LN1@DecryptBuf@6
$LN2@DecryptBuf@6:

; 327  : 		DecryptBufferXTSNonParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  0005d	48 8b 44 24 78	 mov	 rax, QWORD PTR ks2$[rsp]
  00062	89 5c 24 30	 mov	 DWORD PTR [rsp+48], ebx
  00066	45 33 c9	 xor	 r9d, r9d
  00069	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0006e	48 8b 44 24 70	 mov	 rax, QWORD PTR ks$[rsp]
  00073	4c 8b c7	 mov	 r8, rdi
  00076	48 8b d6	 mov	 rdx, rsi
  00079	48 8b cd	 mov	 rcx, rbp
  0007c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00081	e8 00 00 00 00	 call	 DecryptBufferXTSNonParallel
$LN1@DecryptBuf@6:

; 328  : }

  00086	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0008b	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00090	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00095	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00099	5f		 pop	 rdi
  0009a	c3		 ret	 0
DecryptBufferXTS ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptBufferXTSParallel DD imagerel EncryptBufferXTSParallel
	DD	imagerel EncryptBufferXTSParallel+525
	DD	imagerel $unwind$EncryptBufferXTSParallel
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptBufferXTSParallel DD 0b2919H
	DD	0563417H
	DD	04c0117H
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0250H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT EncryptBufferXTSParallel
_TEXT	SEGMENT
ks$GSCopy$1$ = 48
whiteningValue$ = 56
whiteningValues$ = 80
__$ArrayPad$ = 592
buffer$ = 672
length$ = 680
startDataUnitNo$ = 688
startCipherBlockNo$ = 696
ks$ = 704
ks2$ = 712
cipher$ = 720
EncryptBufferXTSParallel PROC				; COMDAT

; 64   : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 81 ec 60 02
	00 00		 sub	 rsp, 608		; 00000260H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00029	48 8b 84 24 c0
	02 00 00	 mov	 rax, QWORD PTR ks$[rsp]
  00031	4c 8b bc 24 c8
	02 00 00	 mov	 r15, QWORD PTR ks2$[rsp]

; 65   : 	unsigned __int8 finalCarry;
; 66   : 	unsigned __int8 whiteningValues [ENCRYPTION_DATA_UNIT_SIZE];
; 67   : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 68   : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 69   : 	unsigned __int64 *whiteningValuesPtr64 = (unsigned __int64 *) whiteningValues;
; 70   : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 71   : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
; 72   : 	unsigned __int64 *dataUnitBufPtr;
; 73   : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;
; 74   : 	unsigned __int64 *const finalInt64WhiteningValuesPtr = whiteningValuesPtr64 + sizeof (whiteningValues) / sizeof (*whiteningValuesPtr64) - 1;
; 75   : 	TC_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 76   : 
; 77   : 	/* The encrypted data unit number (i.e. the resultant ciphertext block) is to be multiplied in the
; 78   : 	finite field GF(2^128) by j-th power of n, where j is the sequential plaintext/ciphertext block
; 79   : 	number and n is 2, a primitive element of GF(2^128). This can be (and is) simplified and implemented
; 80   : 	as a left shift of the preceding whitening value by one bit (with carry propagating). In addition, if
; 81   : 	the shift of the highest byte results in a carry, 135 is XORed into the lowest byte. The value 135 is
; 82   : 	derived from the modulus of the Galois Field (x^128+x^7+x^2+x+1). */
; 83   : 
; 84   : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 85   : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 86   : 	dataUnitNo = startDataUnitNo->Value;

  00039	4d 8b 30	 mov	 r14, QWORD PTR [r8]
  0003c	48 89 44 24 30	 mov	 QWORD PTR ks$GSCopy$1$[rsp], rax
  00041	45 8b e1	 mov	 r12d, r9d
  00044	48 8b fa	 mov	 rdi, rdx
  00047	48 8b d9	 mov	 rbx, rcx

; 87   : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 88   : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
; 89   : 
; 90   : 	if (length % BYTES_PER_XTS_BLOCK)

  0004a	f6 c2 0f	 test	 dl, 15
  0004d	74 1d		 je	 SHORT $LN27@EncryptBuf@5

; 91   : 		TC_THROW_FATAL_EXCEPTION;

  0004f	45 33 c9	 xor	 r9d, r9d
  00052	45 33 c0	 xor	 r8d, r8d
  00055	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  0005e	41 8d 51 5b	 lea	 edx, QWORD PTR [r9+91]
  00062	8d 4a ce	 lea	 ecx, QWORD PTR [rdx-50]
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  0006b	cc		 int	 3
$LN27@EncryptBuf@5:

; 92   : 
; 93   : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  0006c	48 c1 ef 04	 shr	 rdi, 4

; 94   : 
; 95   : 	// Process all blocks in the buffer
; 96   : 	while (blockCount > 0)

  00070	48 85 ff	 test	 rdi, rdi
  00073	0f 84 35 01 00
	00		 je	 $LN10@EncryptBuf@5
$LL26@EncryptBuf@5:

; 97   : 	{
; 98   : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)
; 99   : 			endBlock = startBlock + (unsigned int) blockCount;

  00079	42 8d 2c 27	 lea	 ebp, DWORD PTR [rdi+r12]
  0007d	48 83 ff 20	 cmp	 rdi, 32			; 00000020H
  00081	72 05		 jb	 SHORT $LN23@EncryptBuf@5

; 100  : 		else
; 101  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  00083	bd 20 00 00 00	 mov	 ebp, 32			; 00000020H
$LN23@EncryptBuf@5:

; 102  : 
; 103  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
; 104  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 105  : 
; 106  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 107  : 		// whitening value for this data unit)
; 108  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);
; 109  : 		*(whiteningValuePtr64 + 1) = 0;
; 110  : 		EncipherBlock (cipher, whiteningValue, ks2);

  00088	8b 8c 24 d0 02
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  0008f	48 83 64 24 40
	00		 and	 QWORD PTR whiteningValue$[rsp+8], 0
  00095	48 8d 54 24 38	 lea	 rdx, QWORD PTR whiteningValue$[rsp]
  0009a	4d 8b c7	 mov	 r8, r15
  0009d	4c 8d ac 24 48
	02 00 00	 lea	 r13, QWORD PTR whiteningValues$[rsp+504]
  000a5	48 8d 74 24 38	 lea	 rsi, QWORD PTR whiteningValue$[rsp]
  000aa	4c 89 74 24 38	 mov	 QWORD PTR whiteningValue$[rsp], r14
  000af	e8 00 00 00 00	 call	 EncipherBlock

; 111  : 
; 112  : 		// Generate subsequent whitening values for blocks in this data unit. Note that all generated 128-bit
; 113  : 		// whitening values are stored in memory as a sequence of 64-bit integers in reverse order.
; 114  : 		for (block = 0; block < endBlock; block++)

  000b4	45 33 db	 xor	 r11d, r11d
  000b7	85 ed		 test	 ebp, ebp
  000b9	74 66		 je	 SHORT $LN20@EncryptBuf@5
  000bb	49 b8 00 00 00
	00 00 00 00 80	 mov	 r8, -9223372036854775808 ; 8000000000000000H
$LL22@EncryptBuf@5:

; 115  : 		{
; 116  : 			if (block >= startBlock)

  000c5	45 3b dc	 cmp	 r11d, r12d
  000c8	72 18		 jb	 SHORT $LN19@EncryptBuf@5

; 117  : 			{
; 118  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64++;

  000ca	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000cd	48 83 c6 08	 add	 rsi, 8
  000d1	49 89 45 00	 mov	 QWORD PTR [r13], rax

; 119  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64;

  000d5	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000d8	49 83 ed 10	 sub	 r13, 16
  000dc	49 89 45 08	 mov	 QWORD PTR [r13+8], rax

; 120  : 			}
; 121  : 			else

  000e0	eb 04		 jmp	 SHORT $LN18@EncryptBuf@5
$LN19@EncryptBuf@5:

; 122  : 				whiteningValuePtr64++;

  000e2	48 83 c6 08	 add	 rsi, 8
$LN18@EncryptBuf@5:

; 123  : 
; 124  : 			// Derive the next whitening value
; 125  : 
; 126  : #if BYTE_ORDER == LITTLE_ENDIAN
; 127  : 
; 128  : 			// Little-endian platforms
; 129  : 
; 130  : 			finalCarry = 
; 131  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 132  : 				135 : 0;

  000e6	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  000e9	48 8b c1	 mov	 rax, rcx
  000ec	49 23 c0	 and	 rax, r8
  000ef	48 f7 d8	 neg	 rax

; 133  : 
; 134  : 			*whiteningValuePtr64-- <<= 1;

  000f2	48 8d 04 09	 lea	 rax, QWORD PTR [rcx+rcx]
  000f6	1a d2		 sbb	 dl, dl
  000f8	48 89 06	 mov	 QWORD PTR [rsi], rax
  000fb	48 83 ee 08	 sub	 rsi, 8

; 135  : 
; 136  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  000ff	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00102	80 e2 87	 and	 dl, 135			; 00000087H
  00105	49 85 c0	 test	 rax, r8
  00108	74 05		 je	 SHORT $LN17@EncryptBuf@5

; 137  : 				*(whiteningValuePtr64 + 1) |= 1;	

  0010a	48 83 4e 08 01	 or	 QWORD PTR [rsi+8], 1
$LN17@EncryptBuf@5:

; 138  : 
; 139  : 			*whiteningValuePtr64 <<= 1;

  0010f	48 03 c0	 add	 rax, rax
  00112	41 ff c3	 inc	 r11d
  00115	48 89 06	 mov	 QWORD PTR [rsi], rax

; 140  : #else
; 141  : 
; 142  : 			// Big-endian platforms
; 143  : 
; 144  : 			finalCarry = 
; 145  : 				(*whiteningValuePtr64 & 0x80) ?
; 146  : 				135 : 0;
; 147  : 
; 148  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 149  : 
; 150  : 			whiteningValuePtr64--;
; 151  : 
; 152  : 			if (*whiteningValuePtr64 & 0x80)
; 153  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 154  : 
; 155  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 156  : #endif
; 157  : 
; 158  : 			whiteningValue[0] ^= finalCarry;

  00118	30 54 24 38	 xor	 BYTE PTR whiteningValue$[rsp], dl
  0011c	44 3b dd	 cmp	 r11d, ebp
  0011f	72 a4		 jb	 SHORT $LL22@EncryptBuf@5
$LN20@EncryptBuf@5:

; 159  : 		}
; 160  : 
; 161  : 		dataUnitBufPtr = bufPtr;

  00121	4c 8b eb	 mov	 r13, rbx

; 162  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  00124	48 8d 8c 24 48
	02 00 00	 lea	 rcx, QWORD PTR whiteningValues$[rsp+504]

; 163  : 
; 164  : 		// Encrypt all blocks in this data unit
; 165  : 
; 166  : 		for (block = startBlock; block < endBlock; block++)

  0012c	44 3b e5	 cmp	 r12d, ebp
  0012f	73 21		 jae	 SHORT $LN14@EncryptBuf@5
  00131	8b d5		 mov	 edx, ebp
  00133	41 2b d4	 sub	 edx, r12d
$LL16@EncryptBuf@5:

; 167  : 		{
; 168  : 			// Pre-whitening
; 169  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00136	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 170  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00139	48 83 e9 10	 sub	 rcx, 16
  0013d	48 31 03	 xor	 QWORD PTR [rbx], rax
  00140	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00144	48 83 c3 10	 add	 rbx, 16
  00148	48 31 43 f8	 xor	 QWORD PTR [rbx-8], rax
  0014c	48 83 ea 01	 sub	 rdx, 1
  00150	75 e4		 jne	 SHORT $LL16@EncryptBuf@5
$LN14@EncryptBuf@5:

; 171  : 		}
; 172  : 
; 173  : 		// Actual encryption
; 174  : 		EncipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);

  00152	4c 8b 44 24 30	 mov	 r8, QWORD PTR ks$GSCopy$1$[rsp]
  00157	8b 8c 24 d0 02
	00 00		 mov	 ecx, DWORD PTR cipher$[rsp]
  0015e	8b c5		 mov	 eax, ebp
  00160	41 2b c4	 sub	 eax, r12d
  00163	49 8b d5	 mov	 rdx, r13
  00166	44 8b c8	 mov	 r9d, eax
  00169	8b f0		 mov	 esi, eax
  0016b	e8 00 00 00 00	 call	 EncipherBlocks

; 175  : 		
; 176  : 		bufPtr = dataUnitBufPtr;

  00170	49 8b dd	 mov	 rbx, r13

; 177  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  00173	48 8d 8c 24 48
	02 00 00	 lea	 rcx, QWORD PTR whiteningValues$[rsp+504]

; 178  : 
; 179  : 		for (block = startBlock; block < endBlock; block++)

  0017b	44 3b e5	 cmp	 r12d, ebp
  0017e	73 1f		 jae	 SHORT $LN11@EncryptBuf@5

; 171  : 		}
; 172  : 
; 173  : 		// Actual encryption
; 174  : 		EncipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);

  00180	48 8b d6	 mov	 rdx, rsi
$LL13@EncryptBuf@5:

; 180  : 		{
; 181  : 			// Post-whitening
; 182  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00183	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 183  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00186	48 83 e9 10	 sub	 rcx, 16
  0018a	48 31 03	 xor	 QWORD PTR [rbx], rax
  0018d	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00191	48 83 c3 10	 add	 rbx, 16
  00195	48 31 43 f8	 xor	 QWORD PTR [rbx-8], rax
  00199	48 83 ea 01	 sub	 rdx, 1
  0019d	75 e4		 jne	 SHORT $LL13@EncryptBuf@5
$LN11@EncryptBuf@5:

; 184  : 		}
; 185  : 
; 186  : 		blockCount -= endBlock - startBlock;
; 187  : 		startBlock = 0;

  0019f	45 33 e4	 xor	 r12d, r12d

; 188  : 		dataUnitNo++;

  001a2	49 ff c6	 inc	 r14
  001a5	48 2b fe	 sub	 rdi, rsi
  001a8	0f 85 cb fe ff
	ff		 jne	 $LL26@EncryptBuf@5
$LN10@EncryptBuf@5:

; 189  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 190  : 	}
; 191  : 
; 192  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  001ae	48 8d 44 24 38	 lea	 rax, QWORD PTR whiteningValue$[rsp]
  001b3	b9 02 00 00 00	 mov	 ecx, 2
$LL7@EncryptBuf@5:
  001b8	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  001bf	48 83 c0 08	 add	 rax, 8
  001c3	83 e9 01	 sub	 ecx, 1
  001c6	75 f0		 jne	 SHORT $LL7@EncryptBuf@5

; 193  : 	FAST_ERASE64 (whiteningValues, sizeof (whiteningValues));

  001c8	48 8d 44 24 50	 lea	 rax, QWORD PTR whiteningValues$[rsp]
  001cd	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
$LL2@EncryptBuf@5:
  001d2	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  001d9	48 83 c0 08	 add	 rax, 8
  001dd	83 e9 01	 sub	 ecx, 1
  001e0	75 f0		 jne	 SHORT $LL2@EncryptBuf@5

; 194  : }

  001e2	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001ea	48 33 cc	 xor	 rcx, rsp
  001ed	e8 00 00 00 00	 call	 __security_check_cookie
  001f2	48 8b 9c 24 b0
	02 00 00	 mov	 rbx, QWORD PTR [rsp+688]
  001fa	48 81 c4 60 02
	00 00		 add	 rsp, 608		; 00000260H
  00201	41 5f		 pop	 r15
  00203	41 5e		 pop	 r14
  00205	41 5d		 pop	 r13
  00207	41 5c		 pop	 r12
  00209	5f		 pop	 rdi
  0020a	5e		 pop	 rsi
  0020b	5d		 pop	 rbp
  0020c	c3		 ret	 0
$LN44@EncryptBuf@5:
EncryptBufferXTSParallel ENDP
_TEXT	ENDS
PUBLIC	EncryptBufferXTS
;	COMDAT pdata
; File c:\users\public\desktop\projects\ciphershed\src\common\crypto.c
pdata	SEGMENT
$pdata$EncryptBufferXTS DD imagerel $LN10
	DD	imagerel $LN10+169
	DD	imagerel $unwind$EncryptBufferXTS
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptBufferXTS DD 0a1901H
	DD	0d7419H
	DD	0c6419H
	DD	0b5419H
	DD	0a3419H
	DD	0c0157219H
; Function compile flags: /Ogspy
; File c:\users\public\desktop\projects\ciphershed\src\common\xts.c
xdata	ENDS
;	COMDAT EncryptBufferXTS
_TEXT	SEGMENT
buffer$ = 80
length$ = 88
startDataUnitNo$ = 96
startCipherBlockNo$ = 104
ks$ = 112
ks2$ = 120
cipher$ = 128
EncryptBufferXTS PROC					; COMDAT

; 48   : {

$LN10:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 54		 push	 r12
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 49   : 	if (CipherSupportsIntraDataUnitParallelization (cipher))

  00019	8b 9c 24 80 00
	00 00		 mov	 ebx, DWORD PTR cipher$[rsp]
  00020	41 8b f9	 mov	 edi, r9d
  00023	49 8b f0	 mov	 rsi, r8
  00026	48 8b ea	 mov	 rbp, rdx
  00029	4c 8b e1	 mov	 r12, rcx
  0002c	83 fb 01	 cmp	 ebx, 1
  0002f	75 34		 jne	 SHORT $LN2@EncryptBuf@6
  00031	e8 00 00 00 00	 call	 IsAesHwCpuSupported
  00036	85 c0		 test	 eax, eax
  00038	74 2b		 je	 SHORT $LN2@EncryptBuf@6

; 50   : 		EncryptBufferXTSParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  0003a	48 8b 44 24 78	 mov	 rax, QWORD PTR ks2$[rsp]
  0003f	89 5c 24 30	 mov	 DWORD PTR [rsp+48], ebx
  00043	44 8b cf	 mov	 r9d, edi
  00046	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0004b	48 8b 44 24 70	 mov	 rax, QWORD PTR ks$[rsp]
  00050	4c 8b c6	 mov	 r8, rsi
  00053	48 8b d5	 mov	 rdx, rbp
  00056	49 8b cc	 mov	 rcx, r12
  00059	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005e	e8 00 00 00 00	 call	 EncryptBufferXTSParallel

; 51   : 	else

  00063	eb 29		 jmp	 SHORT $LN1@EncryptBuf@6
$LN2@EncryptBuf@6:

; 52   : 		EncryptBufferXTSNonParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  00065	48 8b 44 24 78	 mov	 rax, QWORD PTR ks2$[rsp]
  0006a	89 5c 24 30	 mov	 DWORD PTR [rsp+48], ebx
  0006e	44 8b cf	 mov	 r9d, edi
  00071	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00076	48 8b 44 24 70	 mov	 rax, QWORD PTR ks$[rsp]
  0007b	4c 8b c6	 mov	 r8, rsi
  0007e	48 8b d5	 mov	 rdx, rbp
  00081	49 8b cc	 mov	 rcx, r12
  00084	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00089	e8 00 00 00 00	 call	 EncryptBufferXTSNonParallel
$LN1@EncryptBuf@6:

; 53   : }

  0008e	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00093	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00098	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0009d	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  000a2	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000a6	41 5c		 pop	 r12
  000a8	c3		 ret	 0
EncryptBufferXTS ENDP
END
