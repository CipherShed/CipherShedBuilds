; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\home\public\Desktop\projects\ciphershed.build\src\Format\InPlace.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0P@GHFPNOJB@bad?5allocation?$AA@		; `string'
PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
_DATA	ENDS
;	COMDAT ??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
CONST	SEGMENT
??_C@_0P@GHFPNOJB@bad?5allocation?$AA@ DB 'bad allocation', 00H ; `string'
CONST	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

  00000	56		 push	 esi
  00001	8d 44 24 08	 lea	 eax, DWORD PTR __Message$[esp]
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

  00006	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00009	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000e	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  00013	74 09		 je	 SHORT $LN6@scalar
  00015	56		 push	 esi
  00016	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001b	83 c4 04	 add	 esp, 4
$LN6@scalar:
  0001e	8b c6		 mov	 eax, esi
  00020	5e		 pop	 esi
  00021	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	_wmemcmp
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\wchar.h
;	COMDAT _wmemcmp
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemcmp PROC						; COMDAT

; 1216 :         {for (; 0 < _N; ++_S1, ++_S2, --_N)

  00000	8b 54 24 0c	 mov	 edx, DWORD PTR __N$[esp-4]
  00004	56		 push	 esi
  00005	85 d2		 test	 edx, edx
  00007	76 1b		 jbe	 SHORT $LN2@wmemcmp
  00009	8b 4c 24 0c	 mov	 ecx, DWORD PTR __S2$[esp]
  0000d	8b 44 24 08	 mov	 eax, DWORD PTR __S1$[esp]
$LL4@wmemcmp:

; 1217 :                 if (*_S1 != *_S2)

  00011	66 8b 30	 mov	 si, WORD PTR [eax]
  00014	66 3b 31	 cmp	 si, WORD PTR [ecx]
  00017	75 0f		 jne	 SHORT $LN8@wmemcmp
  00019	83 c0 02	 add	 eax, 2
  0001c	83 c1 02	 add	 ecx, 2
  0001f	83 ea 01	 sub	 edx, 1
  00022	75 ed		 jne	 SHORT $LL4@wmemcmp
$LN2@wmemcmp:

; 1219 :         return (0); }

  00024	33 c0		 xor	 eax, eax
  00026	5e		 pop	 esi
  00027	c3		 ret	 0
$LN8@wmemcmp:

; 1218 :                         return (*_S1 < *_S2 ? -1 : +1);

  00028	0f b7 00	 movzx	 eax, WORD PTR [eax]
  0002b	66 3b 01	 cmp	 ax, WORD PTR [ecx]
  0002e	5e		 pop	 esi
  0002f	1b c0		 sbb	 eax, eax
  00031	83 e0 fe	 and	 eax, -2			; fffffffeH
  00034	40		 inc	 eax

; 1219 :         return (0); }

  00035	c3		 ret	 0
_wmemcmp ENDP
_TEXT	ENDS
PUBLIC	_wmemcpy_s
EXTRN	_memcpy_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT _wmemcpy_s
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__N1$ = 12						; size = 4
__S2$ = 16						; size = 4
__N$ = 20						; size = 4
_wmemcpy_s PROC						; COMDAT

; 1232 : #pragma warning( push )
; 1233 : #pragma warning( disable : 6386 )
; 1234 :             return memcpy_s(_S1, _N1*sizeof(wchar_t), _S2, _N*sizeof(wchar_t));

  00000	8b 44 24 10	 mov	 eax, DWORD PTR __N$[esp-4]
  00004	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00007	89 4c 24 10	 mov	 DWORD PTR __N$[esp-4], ecx
  0000b	8b 44 24 08	 mov	 eax, DWORD PTR __N1$[esp-4]
  0000f	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00012	89 4c 24 08	 mov	 DWORD PTR __N1$[esp-4], ecx
  00016	e9 00 00 00 00	 jmp	 _memcpy_s
_wmemcpy_s ENDP
_TEXT	ENDS
PUBLIC	_wmemmove_s
EXTRN	_memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT _wmemmove_s
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__N1$ = 12						; size = 4
__S2$ = 16						; size = 4
__N$ = 20						; size = 4
_wmemmove_s PROC					; COMDAT

; 1252 : #pragma warning( push )
; 1253 : #pragma warning( disable : 6386 )
; 1254 :             return memmove_s(_S1, _N1*sizeof(wchar_t), _S2, _N*sizeof(wchar_t));

  00000	8b 44 24 10	 mov	 eax, DWORD PTR __N$[esp-4]
  00004	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00007	89 4c 24 10	 mov	 DWORD PTR __N$[esp-4], ecx
  0000b	8b 44 24 08	 mov	 eax, DWORD PTR __N1$[esp-4]
  0000f	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00012	89 4c 24 08	 mov	 DWORD PTR __N1$[esp-4], ecx
  00016	e9 00 00 00 00	 jmp	 _memmove_s
_wmemmove_s ENDP
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z	; std::char_traits<wchar_t>::assign
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z PROC	; std::char_traits<wchar_t>::assign, COMDAT

; 310  : 		_Left = _Right;

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Right$[esp-4]
  00004	66 8b 08	 mov	 cx, WORD PTR [eax]
  00007	8b 54 24 04	 mov	 edx, DWORD PTR __Left$[esp-4]
  0000b	66 89 0a	 mov	 WORD PTR [edx], cx

; 311  : 		}

  0000e	c3		 ret	 0
?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ENDP	; std::char_traits<wchar_t>::assign
_TEXT	ENDS
PUBLIC	?compare@?$char_traits@_W@std@@SAHPB_W0I@Z	; std::char_traits<wchar_t>::compare
; Function compile flags: /Ogtpy
;	COMDAT ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?compare@?$char_traits@_W@std@@SAHPB_W0I@Z PROC		; std::char_traits<wchar_t>::compare, COMDAT

; 326  : //		_DEBUG_POINTER(_First1);
; 327  : //		_DEBUG_POINTER(_First2);
; 328  : 		return (::wmemcmp(_First1, _First2, _Count));

  00000	e9 00 00 00 00	 jmp	 _wmemcmp
?compare@?$char_traits@_W@std@@SAHPB_W0I@Z ENDP		; std::char_traits<wchar_t>::compare
_TEXT	ENDS
PUBLIC	?length@?$char_traits@_W@std@@SAIPB_W@Z		; std::char_traits<wchar_t>::length
; Function compile flags: /Ogtpy
;	COMDAT ?length@?$char_traits@_W@std@@SAIPB_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@_W@std@@SAIPB_W@Z PROC		; std::char_traits<wchar_t>::length, COMDAT

; 333  : //		_DEBUG_POINTER(_First);
; 334  : 		return (::wcslen(_First));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
$LL3@length:
  00007	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000a	83 c0 02	 add	 eax, 2
  0000d	66 85 c9	 test	 cx, cx
  00010	75 f5		 jne	 SHORT $LL3@length
  00012	2b c2		 sub	 eax, edx
  00014	d1 f8		 sar	 eax, 1

; 335  : 		}

  00016	c3		 ret	 0
?length@?$char_traits@_W@std@@SAIPB_W@Z ENDP		; std::char_traits<wchar_t>::length
_TEXT	ENDS
PUBLIC	?_Copy_s@?$char_traits@_W@std@@SAPA_WPA_WIPB_WI@Z ; std::char_traits<wchar_t>::_Copy_s
; Function compile flags: /Ogtpy
;	COMDAT ?_Copy_s@?$char_traits@_W@std@@SAPA_WPA_WIPB_WI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size_in_words$ = 12					; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
?_Copy_s@?$char_traits@_W@std@@SAPA_WPA_WIPB_WI@Z PROC	; std::char_traits<wchar_t>::_Copy_s, COMDAT

; 348  : //		_DEBUG_POINTER(_First1);
; 349  : //		_DEBUG_POINTER(_First2);
; 350  : 		_CRT_SECURE_WMEMCPY(_First1, _Size_in_words, _First2, _Count);

  00000	8b 44 24 10	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8b 54 24 0c	 mov	 edx, DWORD PTR __First2$[esp-4]
  00008	56		 push	 esi
  00009	8b 74 24 08	 mov	 esi, DWORD PTR __First1$[esp]
  0000d	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00010	8b 44 24 0c	 mov	 eax, DWORD PTR __Size_in_words$[esp]
  00014	51		 push	 ecx
  00015	52		 push	 edx
  00016	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00019	51		 push	 ecx
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 _memcpy_s
  00020	83 c4 10	 add	 esp, 16			; 00000010H

; 351  : 		return _First1;

  00023	8b c6		 mov	 eax, esi
  00025	5e		 pop	 esi

; 352  : 		}

  00026	c3		 ret	 0
?_Copy_s@?$char_traits@_W@std@@SAPA_WPA_WIPB_WI@Z ENDP	; std::char_traits<wchar_t>::_Copy_s
_TEXT	ENDS
PUBLIC	?_Move_s@?$char_traits@_W@std@@SAPA_WPA_WIPB_WI@Z ; std::char_traits<wchar_t>::_Move_s
; Function compile flags: /Ogtpy
;	COMDAT ?_Move_s@?$char_traits@_W@std@@SAPA_WPA_WIPB_WI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size_in_words$ = 12					; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
?_Move_s@?$char_traits@_W@std@@SAPA_WPA_WIPB_WI@Z PROC	; std::char_traits<wchar_t>::_Move_s, COMDAT

; 372  : //		_DEBUG_POINTER(_First1);
; 373  : //		_DEBUG_POINTER(_First2);
; 374  : 		_CRT_SECURE_WMEMMOVE(_First1, _Size_in_words, _First2, _Count);

  00000	8b 44 24 10	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8b 54 24 0c	 mov	 edx, DWORD PTR __First2$[esp-4]
  00008	56		 push	 esi
  00009	8b 74 24 08	 mov	 esi, DWORD PTR __First1$[esp]
  0000d	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00010	8b 44 24 0c	 mov	 eax, DWORD PTR __Size_in_words$[esp]
  00014	51		 push	 ecx
  00015	52		 push	 edx
  00016	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00019	51		 push	 ecx
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 _memmove_s
  00020	83 c4 10	 add	 esp, 16			; 00000010H

; 375  : 		return (_Elem *)_First1;

  00023	8b c6		 mov	 eax, esi
  00025	5e		 pop	 esi

; 376  : 		}

  00026	c3		 ret	 0
?_Move_s@?$char_traits@_W@std@@SAPA_WPA_WIPB_WI@Z ENDP	; std::char_traits<wchar_t>::_Move_s
_TEXT	ENDS
PUBLIC	_RtlSecureZeroMemory
; Function compile flags: /Ogtpy
; File c:\program files\microsoft sdks\windows\v7.1\include\winnt.h
;	COMDAT _RtlSecureZeroMemory
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory PROC				; COMDAT

; 13070:     volatile char *vptr = (volatile char *)ptr;
; 13071: 
; 13072: #if defined(_M_AMD64)
; 13073: 
; 13074:         __stosb((PBYTE )((DWORD64)vptr), 0, cnt);
; 13075: 
; 13076: #else
; 13077: 
; 13078:     while (cnt) {

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _cnt$[esp-4]
  00004	8b 44 24 04	 mov	 eax, DWORD PTR _ptr$[esp-4]
  00008	8b c8		 mov	 ecx, eax
  0000a	85 d2		 test	 edx, edx
  0000c	74 0b		 je	 SHORT $LN1@RtlSecureZ
  0000e	8b ff		 npad	 2
$LL2@RtlSecureZ:

; 13079:         *vptr = 0;

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 13080:         vptr++;

  00013	41		 inc	 ecx

; 13081:         cnt--;

  00014	83 ea 01	 sub	 edx, 1
  00017	75 f7		 jne	 SHORT $LL2@RtlSecureZ
$LN1@RtlSecureZ:

; 13082:     }
; 13083: 
; 13084: #endif
; 13085: 
; 13086:     return ptr;
; 13087: }

  00019	c3		 ret	 0
_RtlSecureZeroMemory ENDP
_TEXT	ENDS
EXTRN	_handleWin32Error:PROC
EXTRN	_MainDlg:DWORD
EXTRN	__imp__DeviceIoControl@32:PROC
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
; Function compile flags: /Ogtpy
; File c:\home\public\desktop\projects\ciphershed.build\src\format\inplace.c
;	COMDAT ?NewFileSysSizeAfterShrink@@YA_JPAXPBDPA_JPAKH@Z
_TEXT	SEGMENT
_nBytesReturned$ = -100					; size = 4
_ntfsVolData$ = -96					; size = 96
_bytesPerCluster$ = 8					; size = 4
_silent$ = 12						; size = 4
?NewFileSysSizeAfterShrink@@YA_JPAXPBDPA_JPAKH@Z PROC	; NewFileSysSizeAfterShrink, COMDAT
; _dev$ = edx
; _totalClusterCount$ = ebx

; 52   : {

  00000	83 ec 64	 sub	 esp, 100		; 00000064H
  00003	55		 push	 ebp
  00004	8b 6c 24 6c	 mov	 ebp, DWORD PTR _bytesPerCluster$[esp+100]

; 53   : 	NTFS_VOLUME_DATA_BUFFER ntfsVolData;
; 54   : 	DWORD nBytesReturned;
; 55   : 	__int64 fileSysSize, desiredNbrSectors;
; 56   : 
; 57   : 	// Filesystem size and sector size
; 58   : 
; 59   : 	if (!DeviceIoControl (dev,
; 60   : 		FSCTL_GET_NTFS_VOLUME_DATA,
; 61   : 		NULL,
; 62   : 		0,
; 63   : 		(LPVOID) &ntfsVolData,
; 64   : 		sizeof (ntfsVolData),   
; 65   : 		&nBytesReturned,
; 66   : 		NULL))

  00008	6a 00		 push	 0
  0000a	8d 44 24 08	 lea	 eax, DWORD PTR _nBytesReturned$[esp+108]
  0000e	50		 push	 eax
  0000f	6a 60		 push	 96			; 00000060H
  00011	8d 4c 24 14	 lea	 ecx, DWORD PTR _ntfsVolData$[esp+116]
  00015	51		 push	 ecx
  00016	6a 00		 push	 0
  00018	6a 00		 push	 0
  0001a	68 64 00 09 00	 push	 589924			; 00090064H
  0001f	52		 push	 edx
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  00026	85 c0		 test	 eax, eax
  00028	75 1e		 jne	 SHORT $LN5@NewFileSys

; 67   : 	{
; 68   : 		if (!silent)

  0002a	39 44 24 70	 cmp	 DWORD PTR _silent$[esp+100], eax
  0002e	75 0e		 jne	 SHORT $LN4@NewFileSys

; 69   : 			handleWin32Error (MainDlg);

  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR _MainDlg
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _handleWin32Error
  0003b	83 c4 04	 add	 esp, 4
$LN4@NewFileSys:

; 70   : 
; 71   : 		return -1;

  0003e	83 c8 ff	 or	 eax, -1
  00041	0b d0		 or	 edx, eax
  00043	5d		 pop	 ebp

; 85   : 
; 86   : 	return desiredNbrSectors;
; 87   : }

  00044	83 c4 64	 add	 esp, 100		; 00000064H
  00047	c3		 ret	 0
$LN5@NewFileSys:

; 72   : 	}
; 73   : 
; 74   : 	fileSysSize = ntfsVolData.NumberSectors.QuadPart * ntfsVolData.BytesPerSector;

  00048	8b 4c 24 14	 mov	 ecx, DWORD PTR _ntfsVolData$[esp+116]
  0004c	8b 54 24 10	 mov	 edx, DWORD PTR _ntfsVolData$[esp+112]
  00050	56		 push	 esi
  00051	8b 74 24 34	 mov	 esi, DWORD PTR _ntfsVolData$[esp+148]
  00055	57		 push	 edi
  00056	51		 push	 ecx
  00057	52		 push	 edx
  00058	33 ff		 xor	 edi, edi
  0005a	57		 push	 edi
  0005b	56		 push	 esi
  0005c	e8 00 00 00 00	 call	 __allmul

; 75   : 
; 76   : 	desiredNbrSectors = (fileSysSize - TC_TOTAL_VOLUME_HEADERS_SIZE) / ntfsVolData.BytesPerSector;

  00061	57		 push	 edi
  00062	2d 00 00 04 00	 sub	 eax, 262144		; 00040000H
  00067	56		 push	 esi
  00068	1b d7		 sbb	 edx, edi
  0006a	52		 push	 edx
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 __alldiv
  00071	5f		 pop	 edi
  00072	5e		 pop	 esi

; 77   : 
; 78   : 	if (desiredNbrSectors <= 0)

  00073	85 d2		 test	 edx, edx
  00075	7f 06		 jg	 SHORT $LN3@NewFileSys
  00077	7c c5		 jl	 SHORT $LN4@NewFileSys
  00079	85 c0		 test	 eax, eax

; 79   : 		return -1;

  0007b	76 c1		 jbe	 SHORT $LN4@NewFileSys
$LN3@NewFileSys:

; 80   : 	
; 81   : 	if (totalClusterCount)

  0007d	85 db		 test	 ebx, ebx
  0007f	74 0d		 je	 SHORT $LN2@NewFileSys

; 82   : 		*totalClusterCount = ntfsVolData.TotalClusters.QuadPart;

  00081	8b 4c 24 18	 mov	 ecx, DWORD PTR _ntfsVolData$[esp+120]
  00085	89 0b		 mov	 DWORD PTR [ebx], ecx
  00087	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ntfsVolData$[esp+124]
  0008b	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
$LN2@NewFileSys:

; 83   : 	if (bytesPerCluster)

  0008e	85 ed		 test	 ebp, ebp
  00090	74 07		 je	 SHORT $LN6@NewFileSys

; 84   : 		*bytesPerCluster = ntfsVolData.BytesPerCluster;

  00092	8b 4c 24 34	 mov	 ecx, DWORD PTR _ntfsVolData$[esp+148]
  00096	89 4d 00	 mov	 DWORD PTR [ebp], ecx
$LN6@NewFileSys:
  00099	5d		 pop	 ebp

; 85   : 
; 86   : 	return desiredNbrSectors;
; 87   : }

  0009a	83 c4 64	 add	 esp, 100		; 00000064H
  0009d	c3		 ret	 0
?NewFileSysSizeAfterShrink@@YA_JPAXPBDPA_JPAKH@Z ENDP	; NewFileSysSizeAfterShrink
_TEXT	ENDS
PUBLIC	_FastVolumeHeaderUpdate
EXTRN	__imp__SetLastError@4:PROC
EXTRN	_free:PROC
EXTRN	__imp__VirtualUnlock@8:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	_WriteEffectiveVolumeHeader:PROC
EXTRN	_EncryptBuffer:PROC
EXTRN	_GetCrc32:PROC
EXTRN	_GetHeaderField32:PROC
EXTRN	_DecryptBuffer:PROC
EXTRN	_ReadEffectiveVolumeHeader:PROC
EXTRN	__imp__SetFilePointerEx@20:PROC
EXTRN	__imp__VirtualLock@8:PROC
EXTRN	_malloc:PROC
; Function compile flags: /Ogtpy
;	COMDAT _FastVolumeHeaderUpdate
_TEXT	SEGMENT
_nStatus$ = -8						; size = 4
_n$ = -4						; size = 4
_dev$ = 8						; size = 4
_headerCryptoInfo$ = 12					; size = 4
_masterCryptoInfo$ = 16					; size = 4
_deviceSize$ = 20					; size = 8
_FastVolumeHeaderUpdate PROC				; COMDAT

; 1108 : {

  00000	83 ec 08	 sub	 esp, 8
  00003	57		 push	 edi

; 1109 : 	LARGE_INTEGER offset;
; 1110 : 	DWORD n;
; 1111 : 	int nStatus = ERR_SUCCESS;
; 1112 : 	byte *header;
; 1113 : 	DWORD dwError;
; 1114 : 	uint32 headerCrc32;
; 1115 : 	byte *fieldPos;
; 1116 : 
; 1117 : 	header = (byte *) TCalloc (TC_VOLUME_HEADER_EFFECTIVE_SIZE);

  00004	68 00 02 00 00	 push	 512			; 00000200H
  00009	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR _nStatus$[esp+16], 0
  00011	e8 00 00 00 00	 call	 _malloc
  00016	8b f8		 mov	 edi, eax
  00018	83 c4 04	 add	 esp, 4

; 1118 : 
; 1119 : 	if (!header)

  0001b	85 ff		 test	 edi, edi
  0001d	75 08		 jne	 SHORT $LN15@FastVolume

; 1120 : 		return ERR_OUTOFMEMORY;

  0001f	8d 47 02	 lea	 eax, DWORD PTR [edi+2]
  00022	5f		 pop	 edi

; 1177 : }

  00023	83 c4 08	 add	 esp, 8
  00026	c3		 ret	 0
$LN15@FastVolume:
  00027	53		 push	 ebx
  00028	55		 push	 ebp
  00029	56		 push	 esi

; 1121 : 
; 1122 : 	VirtualLock (header, TC_VOLUME_HEADER_EFFECTIVE_SIZE);

  0002a	68 00 02 00 00	 push	 512			; 00000200H
  0002f	57		 push	 edi
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualLock@8

; 1123 : 
; 1124 : 
; 1125 : 	fieldPos = (byte *) header + TC_HEADER_OFFSET_ENCRYPTED_AREA_START;
; 1126 : 
; 1127 : 	offset.QuadPart = deviceSize - TC_VOLUME_HEADER_GROUP_SIZE;

  00036	8b 6c 24 28	 mov	 ebp, DWORD PTR _deviceSize$[esp+20]
  0003a	8b 5c 24 2c	 mov	 ebx, DWORD PTR _deviceSize$[esp+24]

; 1128 : 
; 1129 : 	if (SetFilePointerEx (dev, offset, NULL, FILE_BEGIN) == 0
; 1130 : 		|| !ReadEffectiveVolumeHeader (TRUE, dev, header, &n) || n < TC_VOLUME_HEADER_EFFECTIVE_SIZE)

  0003e	8b 44 24 1c	 mov	 eax, DWORD PTR _dev$[esp+20]
  00042	6a 00		 push	 0
  00044	81 ed 00 00 02
	00		 sub	 ebp, 131072		; 00020000H
  0004a	6a 00		 push	 0
  0004c	83 db 00	 sbb	 ebx, 0
  0004f	53		 push	 ebx
  00050	55		 push	 ebp
  00051	50		 push	 eax
  00052	8d 77 6c	 lea	 esi, DWORD PTR [edi+108]
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  0005b	85 c0		 test	 eax, eax
  0005d	0f 84 7e 01 00
	00		 je	 $LN13@FastVolume
  00063	8b 54 24 1c	 mov	 edx, DWORD PTR _dev$[esp+20]
  00067	8d 4c 24 14	 lea	 ecx, DWORD PTR _n$[esp+24]
  0006b	51		 push	 ecx
  0006c	57		 push	 edi
  0006d	52		 push	 edx
  0006e	6a 01		 push	 1
  00070	e8 00 00 00 00	 call	 _ReadEffectiveVolumeHeader
  00075	83 c4 10	 add	 esp, 16			; 00000010H
  00078	85 c0		 test	 eax, eax
  0007a	0f 84 61 01 00
	00		 je	 $LN13@FastVolume
  00080	81 7c 24 14 00
	02 00 00	 cmp	 DWORD PTR _n$[esp+24], 512 ; 00000200H
  00088	0f 82 53 01 00
	00		 jb	 $LN13@FastVolume

; 1133 : 		goto closing_seq;
; 1134 : 	}
; 1135 : 
; 1136 : 
; 1137 : 	DecryptBuffer (header + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, headerCryptoInfo);

  0008e	8b 4c 24 20	 mov	 ecx, DWORD PTR _headerCryptoInfo$[esp+20]
  00092	51		 push	 ecx
  00093	6a 00		 push	 0
  00095	8d 47 40	 lea	 eax, DWORD PTR [edi+64]
  00098	68 c0 01 00 00	 push	 448			; 000001c0H
  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 _DecryptBuffer

; 1138 : 
; 1139 : 	/* Modifying 'TRUE' can introduce incompatibility with previous versions. */
; 1140 : 	if (GetHeaderField32 (header, TC_HEADER_OFFSET_MAGIC) != 0x54525545)

  000a3	6a 40		 push	 64			; 00000040H
  000a5	57		 push	 edi
  000a6	e8 00 00 00 00	 call	 _GetHeaderField32
  000ab	83 c4 18	 add	 esp, 24			; 00000018H
  000ae	3d 45 55 52 54	 cmp	 eax, 1414681925		; 54525545H
  000b3	74 0d		 je	 SHORT $LN11@FastVolume

; 1141 : 	{
; 1142 : 		nStatus = ERR_PARAMETER_INCORRECT;

  000b5	c7 44 24 10 1e
	00 00 00	 mov	 DWORD PTR _nStatus$[esp+24], 30 ; 0000001eH

; 1159 : 	{
; 1160 : 		nStatus = ERR_OS_ERROR;
; 1161 : 		goto closing_seq;
; 1162 : 	}
; 1163 : 
; 1164 : 
; 1165 : closing_seq:

  000bd	e9 27 01 00 00	 jmp	 $closing_seq$119919
$LN11@FastVolume:

; 1143 : 		goto closing_seq;
; 1144 : 	}
; 1145 : 
; 1146 : 	mputInt64 (fieldPos, (masterCryptoInfo->EncryptedAreaStart.Value));

  000c2	8b 44 24 24	 mov	 eax, DWORD PTR _masterCryptoInfo$[esp+20]
  000c6	0f b6 90 57 44
	00 00		 movzx	 edx, BYTE PTR [eax+17495]
  000cd	88 16		 mov	 BYTE PTR [esi], dl
  000cf	0f b6 88 56 44
	00 00		 movzx	 ecx, BYTE PTR [eax+17494]
  000d6	88 4e 01	 mov	 BYTE PTR [esi+1], cl
  000d9	0f b6 90 55 44
	00 00		 movzx	 edx, BYTE PTR [eax+17493]
  000e0	46		 inc	 esi
  000e1	88 56 01	 mov	 BYTE PTR [esi+1], dl
  000e4	0f b6 88 54 44
	00 00		 movzx	 ecx, BYTE PTR [eax+17492]
  000eb	46		 inc	 esi
  000ec	88 4e 01	 mov	 BYTE PTR [esi+1], cl
  000ef	0f b6 90 53 44
	00 00		 movzx	 edx, BYTE PTR [eax+17491]
  000f6	46		 inc	 esi
  000f7	88 56 01	 mov	 BYTE PTR [esi+1], dl
  000fa	0f b6 88 52 44
	00 00		 movzx	 ecx, BYTE PTR [eax+17490]
  00101	46		 inc	 esi
  00102	88 4e 01	 mov	 BYTE PTR [esi+1], cl
  00105	0f b6 90 51 44
	00 00		 movzx	 edx, BYTE PTR [eax+17489]
  0010c	46		 inc	 esi
  0010d	88 56 01	 mov	 BYTE PTR [esi+1], dl
  00110	0f b6 88 50 44
	00 00		 movzx	 ecx, BYTE PTR [eax+17488]
  00117	46		 inc	 esi
  00118	88 4e 01	 mov	 BYTE PTR [esi+1], cl

; 1147 : 	mputInt64 (fieldPos, (masterCryptoInfo->EncryptedAreaLength.Value));

  0011b	0f b6 90 5f 44
	00 00		 movzx	 edx, BYTE PTR [eax+17503]
  00122	46		 inc	 esi
  00123	88 56 01	 mov	 BYTE PTR [esi+1], dl
  00126	0f b6 88 5e 44
	00 00		 movzx	 ecx, BYTE PTR [eax+17502]
  0012d	46		 inc	 esi
  0012e	88 4e 01	 mov	 BYTE PTR [esi+1], cl
  00131	0f b6 90 5d 44
	00 00		 movzx	 edx, BYTE PTR [eax+17501]
  00138	46		 inc	 esi
  00139	88 56 01	 mov	 BYTE PTR [esi+1], dl
  0013c	0f b6 88 5c 44
	00 00		 movzx	 ecx, BYTE PTR [eax+17500]
  00143	46		 inc	 esi
  00144	88 4e 01	 mov	 BYTE PTR [esi+1], cl
  00147	0f b6 90 5b 44
	00 00		 movzx	 edx, BYTE PTR [eax+17499]
  0014e	46		 inc	 esi
  0014f	88 56 01	 mov	 BYTE PTR [esi+1], dl
  00152	0f b6 88 5a 44
	00 00		 movzx	 ecx, BYTE PTR [eax+17498]
  00159	46		 inc	 esi
  0015a	88 4e 01	 mov	 BYTE PTR [esi+1], cl
  0015d	0f b6 90 59 44
	00 00		 movzx	 edx, BYTE PTR [eax+17497]
  00164	46		 inc	 esi
  00165	46		 inc	 esi
  00166	88 16		 mov	 BYTE PTR [esi], dl
  00168	8a 80 58 44 00
	00		 mov	 al, BYTE PTR [eax+17496]
  0016e	88 46 01	 mov	 BYTE PTR [esi+1], al

; 1148 : 
; 1149 : 
; 1150 : 	headerCrc32 = GetCrc32 (header + TC_HEADER_OFFSET_MAGIC, TC_HEADER_OFFSET_HEADER_CRC - TC_HEADER_OFFSET_MAGIC);

  00171	8d 47 40	 lea	 eax, DWORD PTR [edi+64]
  00174	68 bc 00 00 00	 push	 188			; 000000bcH
  00179	50		 push	 eax
  0017a	e8 00 00 00 00	 call	 _GetCrc32

; 1151 : 	fieldPos = (byte *) header + TC_HEADER_OFFSET_HEADER_CRC;
; 1152 : 	mputLong (fieldPos, headerCrc32);

  0017f	8b d0		 mov	 edx, eax
  00181	c1 ea 18	 shr	 edx, 24			; 00000018H
  00184	88 97 fc 00 00
	00		 mov	 BYTE PTR [edi+252], dl
  0018a	8d 8f fc 00 00
	00		 lea	 ecx, DWORD PTR [edi+252]
  00190	8b d0		 mov	 edx, eax
  00192	c1 ea 10	 shr	 edx, 16			; 00000010H
  00195	88 51 01	 mov	 BYTE PTR [ecx+1], dl
  00198	41		 inc	 ecx
  00199	8b d0		 mov	 edx, eax
  0019b	41		 inc	 ecx
  0019c	c1 ea 08	 shr	 edx, 8
  0019f	88 11		 mov	 BYTE PTR [ecx], dl
  001a1	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 1153 : 
; 1154 : 	EncryptBuffer (header + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, headerCryptoInfo);

  001a4	8b 44 24 28	 mov	 eax, DWORD PTR _headerCryptoInfo$[esp+28]
  001a8	50		 push	 eax
  001a9	6a 00		 push	 0
  001ab	8d 47 40	 lea	 eax, DWORD PTR [edi+64]
  001ae	68 c0 01 00 00	 push	 448			; 000001c0H
  001b3	50		 push	 eax
  001b4	e8 00 00 00 00	 call	 _EncryptBuffer

; 1155 : 
; 1156 : 
; 1157 : 	if (SetFilePointerEx (dev, offset, NULL, FILE_BEGIN) == 0
; 1158 : 		|| !WriteEffectiveVolumeHeader (TRUE, dev, header))

  001b9	8b 74 24 34	 mov	 esi, DWORD PTR _dev$[esp+44]
  001bd	83 c4 18	 add	 esp, 24			; 00000018H
  001c0	6a 00		 push	 0
  001c2	6a 00		 push	 0
  001c4	53		 push	 ebx
  001c5	55		 push	 ebp
  001c6	56		 push	 esi
  001c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  001cd	85 c0		 test	 eax, eax
  001cf	74 10		 je	 SHORT $LN13@FastVolume
  001d1	57		 push	 edi
  001d2	56		 push	 esi
  001d3	6a 01		 push	 1
  001d5	e8 00 00 00 00	 call	 _WriteEffectiveVolumeHeader
  001da	83 c4 0c	 add	 esp, 12			; 0000000cH
  001dd	85 c0		 test	 eax, eax
  001df	75 08		 jne	 SHORT $closing_seq$119919
$LN13@FastVolume:

; 1131 : 	{
; 1132 : 		nStatus = ERR_OS_ERROR;

  001e1	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR _nStatus$[esp+24], 1
$closing_seq$119919:

; 1166 : 
; 1167 : 	dwError = GetLastError();

  001e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 1168 : 
; 1169 : 	burn (header, TC_VOLUME_HEADER_EFFECTIVE_SIZE);

  001ef	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001f4	8b d8		 mov	 ebx, eax
  001f6	8b d7		 mov	 edx, edi
  001f8	8b f1		 mov	 esi, ecx
  001fa	8b c7		 mov	 eax, edi
  001fc	8d 64 24 00	 npad	 4
$LL19@FastVolume:
  00200	c6 00 00	 mov	 BYTE PTR [eax], 0
  00203	40		 inc	 eax
  00204	83 ee 01	 sub	 esi, 1
  00207	75 f7		 jne	 SHORT $LL19@FastVolume
  00209	8d a4 24 00 00
	00 00		 npad	 7
$LL3@FastVolume:
  00210	49		 dec	 ecx
  00211	c6 02 00	 mov	 BYTE PTR [edx], 0
  00214	42		 inc	 edx
  00215	85 c9		 test	 ecx, ecx
  00217	75 f7		 jne	 SHORT $LL3@FastVolume

; 1170 : 	VirtualUnlock (header, TC_VOLUME_HEADER_EFFECTIVE_SIZE);

  00219	68 00 02 00 00	 push	 512			; 00000200H
  0021e	57		 push	 edi
  0021f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualUnlock@8

; 1171 : 	TCfree (header);

  00225	57		 push	 edi
  00226	e8 00 00 00 00	 call	 _free

; 1172 : 
; 1173 : 	if (nStatus != ERR_SUCCESS)

  0022b	8b 74 24 14	 mov	 esi, DWORD PTR _nStatus$[esp+28]
  0022f	83 c4 04	 add	 esp, 4
  00232	85 f6		 test	 esi, esi
  00234	74 07		 je	 SHORT $LN1@FastVolume

; 1174 : 		SetLastError (dwError);

  00236	53		 push	 ebx
  00237	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
$LN1@FastVolume:

; 1175 : 
; 1176 : 	return nStatus;

  0023d	8b c6		 mov	 eax, esi
  0023f	5e		 pop	 esi
  00240	5d		 pop	 ebp
  00241	5b		 pop	 ebx
  00242	5f		 pop	 edi

; 1177 : }

  00243	83 c4 08	 add	 esp, 8
  00246	c3		 ret	 0
_FastVolumeHeaderUpdate ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__WriteFile@20:PROC
EXTRN	__imp__ReadFile@20:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
; Function compile flags: /Ogtpy
;	COMDAT _ConcealNTFS
_TEXT	SEGMENT
_dwError$ = -8208					; size = 4
_nbrBytesProcessed$ = -8204				; size = 4
_nbrBytesProcessed2$ = -8200				; size = 4
_buf$ = -8196						; size = 8192
__$ArrayPad$ = -4					; size = 4
_ConcealNTFS PROC					; COMDAT
; _dev$ = esi

; 1320 : {

  00000	b8 10 20 00 00	 mov	 eax, 8208		; 00002010H
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000f	33 c4		 xor	 eax, esp
  00011	89 84 24 0c 20
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+8208], eax
  00018	57		 push	 edi

; 1321 : 	char buf [TC_INITIAL_NTFS_CONCEAL_PORTION_SIZE];
; 1322 : 	DWORD nbrBytesProcessed, nbrBytesProcessed2;
; 1323 : 	int i;
; 1324 : 	LARGE_INTEGER offset;
; 1325 : 	DWORD dwError;
; 1326 : 
; 1327 : 	offset.QuadPart = 0;
; 1328 :  
; 1329 : 	if (SetFilePointerEx (dev, offset, NULL, FILE_BEGIN) == 0)

  00019	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__SetFilePointerEx@20
  0001f	33 c9		 xor	 ecx, ecx
  00021	51		 push	 ecx
  00022	51		 push	 ecx
  00023	51		 push	 ecx
  00024	33 c0		 xor	 eax, eax
  00026	50		 push	 eax
  00027	56		 push	 esi
  00028	ff d7		 call	 edi
  0002a	85 c0		 test	 eax, eax
  0002c	75 1b		 jne	 SHORT $LN13@ConcealNTF
$LN22@ConcealNTF:

; 1330 : 		return ERR_OS_ERROR;

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	5f		 pop	 edi

; 1365 : 	}
; 1366 : 
; 1367 : 	return ERR_SUCCESS;
; 1368 : }

  00034	8b 8c 24 0c 20
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+8208]
  0003b	33 cc		 xor	 ecx, esp
  0003d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00042	81 c4 10 20 00
	00		 add	 esp, 8208		; 00002010H
  00048	c3		 ret	 0
$LN13@ConcealNTF:

; 1331 : 
; 1332 : 	if (ReadFile (dev, buf, TC_INITIAL_NTFS_CONCEAL_PORTION_SIZE, &nbrBytesProcessed, NULL) == 0)

  00049	6a 00		 push	 0
  0004b	8d 44 24 0c	 lea	 eax, DWORD PTR _nbrBytesProcessed$[esp+8216]
  0004f	50		 push	 eax
  00050	68 00 20 00 00	 push	 8192			; 00002000H
  00055	8d 4c 24 1c	 lea	 ecx, DWORD PTR _buf$[esp+8224]
  00059	51		 push	 ecx
  0005a	56		 push	 esi
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20
  00061	85 c0		 test	 eax, eax

; 1333 : 		return ERR_OS_ERROR;

  00063	74 c9		 je	 SHORT $LN22@ConcealNTF

; 1334 : 
; 1335 : 	for (i = 0; i < TC_INITIAL_NTFS_CONCEAL_PORTION_SIZE; i++)

  00065	33 c0		 xor	 eax, eax
  00067	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL11@ConcealNTF:

; 1336 : 		buf[i] ^= TC_NTFS_CONCEAL_CONSTANT;

  00070	8a 54 04 10	 mov	 dl, BYTE PTR _buf$[esp+eax+8212]
  00074	f6 d2		 not	 dl
  00076	88 54 04 10	 mov	 BYTE PTR _buf$[esp+eax+8212], dl
  0007a	40		 inc	 eax
  0007b	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  00080	7c ee		 jl	 SHORT $LL11@ConcealNTF

; 1337 : 
; 1338 : 	offset.QuadPart = 0;

  00082	33 c9		 xor	 ecx, ecx

; 1339 : 
; 1340 : 	if (SetFilePointerEx (dev, offset, NULL, FILE_BEGIN) == 0)

  00084	51		 push	 ecx
  00085	51		 push	 ecx
  00086	51		 push	 ecx
  00087	33 c0		 xor	 eax, eax
  00089	50		 push	 eax
  0008a	56		 push	 esi
  0008b	ff d7		 call	 edi
  0008d	85 c0		 test	 eax, eax

; 1341 : 		return ERR_OS_ERROR;

  0008f	74 9d		 je	 SHORT $LN22@ConcealNTF

; 1342 : 
; 1343 : 	if (WriteFile (dev, buf, TC_INITIAL_NTFS_CONCEAL_PORTION_SIZE, &nbrBytesProcessed, NULL) == 0)

  00091	6a 00		 push	 0
  00093	8d 44 24 0c	 lea	 eax, DWORD PTR _nbrBytesProcessed$[esp+8216]
  00097	50		 push	 eax
  00098	68 00 20 00 00	 push	 8192			; 00002000H
  0009d	8d 4c 24 1c	 lea	 ecx, DWORD PTR _buf$[esp+8224]
  000a1	51		 push	 ecx
  000a2	56		 push	 esi
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  000a9	85 c0		 test	 eax, eax
  000ab	0f 85 88 00 00
	00		 jne	 $LN7@ConcealNTF

; 1344 : 	{
; 1345 : 		// One or more of the sectors is/are probably damaged and cause write errors.
; 1346 : 		// We must undo the modifications we made.
; 1347 : 
; 1348 : 		dwError = GetLastError();

  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000b7	89 44 24 04	 mov	 DWORD PTR _dwError$[esp+8212], eax

; 1349 : 
; 1350 : 		for (i = 0; i < TC_INITIAL_NTFS_CONCEAL_PORTION_SIZE; i++)

  000bb	33 c0		 xor	 eax, eax
  000bd	8d 49 00	 npad	 3
$LL6@ConcealNTF:

; 1351 : 			buf[i] ^= TC_NTFS_CONCEAL_CONSTANT;

  000c0	8a 54 04 10	 mov	 dl, BYTE PTR _buf$[esp+eax+8212]
  000c4	f6 d2		 not	 dl
  000c6	88 54 04 10	 mov	 BYTE PTR _buf$[esp+eax+8212], dl
  000ca	40		 inc	 eax
  000cb	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  000d0	7c ee		 jl	 SHORT $LL6@ConcealNTF
  000d2	53		 push	 ebx
  000d3	55		 push	 ebp

; 1352 : 
; 1353 : 		offset.QuadPart = 0;

  000d4	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__Sleep@4
  000da	33 ff		 xor	 edi, edi
  000dc	33 db		 xor	 ebx, ebx
  000de	8b ff		 npad	 2
$LL3@ConcealNTF:

; 1354 : 
; 1355 : 		do
; 1356 : 		{
; 1357 : 			Sleep (1);

  000e0	6a 01		 push	 1
  000e2	ff d5		 call	 ebp

; 1358 : 		}
; 1359 : 		while (SetFilePointerEx (dev, offset, NULL, FILE_BEGIN) == 0
; 1360 : 			|| WriteFile (dev, buf, TC_INITIAL_NTFS_CONCEAL_PORTION_SIZE, &nbrBytesProcessed2, NULL) == 0);

  000e4	6a 00		 push	 0
  000e6	6a 00		 push	 0
  000e8	53		 push	 ebx
  000e9	57		 push	 edi
  000ea	56		 push	 esi
  000eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  000f1	85 c0		 test	 eax, eax
  000f3	74 eb		 je	 SHORT $LL3@ConcealNTF
  000f5	6a 00		 push	 0
  000f7	8d 44 24 18	 lea	 eax, DWORD PTR _nbrBytesProcessed2$[esp+8224]
  000fb	50		 push	 eax
  000fc	68 00 20 00 00	 push	 8192			; 00002000H
  00101	8d 4c 24 24	 lea	 ecx, DWORD PTR _buf$[esp+8232]
  00105	51		 push	 ecx
  00106	56		 push	 esi
  00107	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  0010d	85 c0		 test	 eax, eax
  0010f	74 cf		 je	 SHORT $LL3@ConcealNTF

; 1361 : 
; 1362 : 		SetLastError (dwError);

  00111	8b 54 24 0c	 mov	 edx, DWORD PTR _dwError$[esp+8220]
  00115	52		 push	 edx
  00116	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
  0011c	5d		 pop	 ebp
  0011d	5b		 pop	 ebx

; 1363 : 
; 1364 : 		return ERR_OS_ERROR;

  0011e	b8 01 00 00 00	 mov	 eax, 1
  00123	5f		 pop	 edi

; 1365 : 	}
; 1366 : 
; 1367 : 	return ERR_SUCCESS;
; 1368 : }

  00124	8b 8c 24 0c 20
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+8208]
  0012b	33 cc		 xor	 ecx, esp
  0012d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00132	81 c4 10 20 00
	00		 add	 esp, 8208		; 00002010H
  00138	c3		 ret	 0
$LN7@ConcealNTF:
  00139	8b 8c 24 10 20
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+8212]
  00140	5f		 pop	 edi
  00141	33 cc		 xor	 ecx, esp
  00143	33 c0		 xor	 eax, eax
  00145	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014a	81 c4 10 20 00
	00		 add	 esp, 8208		; 00002010H
  00150	c3		 ret	 0
_ConcealNTFS ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@LGBJGGOF@INPLACE_ENC_ALTERNATIVE_STEPS?$AA@ ; `string'
PUBLIC	??_C@_17MFDLPPFM@?$AA?6?$AA?6?$AA?6?$AA?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_ShowInPlaceEncErrMsgWAltSteps
EXTRN	_WarningDirect:PROC
EXTRN	_ErrorDirect:PROC
EXTRN	_GetString:PROC
;	COMDAT ??_C@_0BO@LGBJGGOF@INPLACE_ENC_ALTERNATIVE_STEPS?$AA@
CONST	SEGMENT
??_C@_0BO@LGBJGGOF@INPLACE_ENC_ALTERNATIVE_STEPS?$AA@ DB 'INPLACE_ENC_ALT'
	DB	'ERNATIVE_STEPS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_17MFDLPPFM@?$AA?6?$AA?6?$AA?6?$AA?$AA@
CONST	SEGMENT
??_C@_17MFDLPPFM@?$AA?6?$AA?6?$AA?6?$AA?$AA@ DB 0aH, 00H, 0aH, 00H, 0aH, 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _ShowInPlaceEncErrMsgWAltSteps
_TEXT	SEGMENT
_msg$ = -60004						; size = 60000
__$ArrayPad$ = -4					; size = 4
_iniStrId$ = 8						; size = 4
_bErr$ = 12						; size = 4
_ShowInPlaceEncErrMsgWAltSteps PROC			; COMDAT

; 1372 : {

  00000	b8 64 ea 00 00	 mov	 eax, 60004		; 0000ea64H
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000f	33 c4		 xor	 eax, esp
  00011	89 84 24 60 ea
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+60004], eax
  00018	8b 84 24 68 ea
	00 00		 mov	 eax, DWORD PTR _iniStrId$[esp+60000]

; 1373 : 	wchar_t msg[30000];
; 1374 : 
; 1375 : 	wcscpy (msg, GetString (iniStrId));

  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _GetString
  00025	83 c4 04	 add	 esp, 4
  00028	8d 14 24	 lea	 edx, DWORD PTR _msg$[esp+60004]
  0002b	eb 03 8d 49 00	 npad	 5
$LL5@ShowInPlac:
  00030	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00033	66 89 0a	 mov	 WORD PTR [edx], cx
  00036	83 c0 02	 add	 eax, 2
  00039	83 c2 02	 add	 edx, 2
  0003c	66 85 c9	 test	 cx, cx
  0003f	75 ef		 jne	 SHORT $LL5@ShowInPlac

; 1376 : 
; 1377 : 	wcscat (msg, L"\n\n\n");

  00041	8d 04 24	 lea	 eax, DWORD PTR _msg$[esp+60004]
  00044	83 c0 fe	 add	 eax, -2			; fffffffeH
  00047	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL7@ShowInPlac:
  00050	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  00054	83 c0 02	 add	 eax, 2
  00057	66 85 c9	 test	 cx, cx
  0005a	75 f4		 jne	 SHORT $LL7@ShowInPlac
  0005c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_17MFDLPPFM@?$AA?6?$AA?6?$AA?6?$AA?$AA@
  00062	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ??_C@_17MFDLPPFM@?$AA?6?$AA?6?$AA?6?$AA?$AA@+4
  00068	89 08		 mov	 DWORD PTR [eax], ecx

; 1378 : 	wcscat (msg, GetString ("INPLACE_ENC_ALTERNATIVE_STEPS"));

  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@LGBJGGOF@INPLACE_ENC_ALTERNATIVE_STEPS?$AA@
  0006f	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00072	e8 00 00 00 00	 call	 _GetString
  00077	83 c4 04	 add	 esp, 4
  0007a	8b d0		 mov	 edx, eax
  0007c	8d 64 24 00	 npad	 4
$LL8@ShowInPlac:
  00080	66 8b 08	 mov	 cx, WORD PTR [eax]
  00083	83 c0 02	 add	 eax, 2
  00086	66 85 c9	 test	 cx, cx
  00089	75 f5		 jne	 SHORT $LL8@ShowInPlac
  0008b	56		 push	 esi
  0008c	57		 push	 edi
  0008d	8d 7c 24 08	 lea	 edi, DWORD PTR _msg$[esp+60012]
  00091	2b c2		 sub	 eax, edx
  00093	83 c7 fe	 add	 edi, -2			; fffffffeH
$LL9@ShowInPlac:
  00096	66 8b 4f 02	 mov	 cx, WORD PTR [edi+2]
  0009a	83 c7 02	 add	 edi, 2
  0009d	66 85 c9	 test	 cx, cx
  000a0	75 f4		 jne	 SHORT $LL9@ShowInPlac
  000a2	8b c8		 mov	 ecx, eax
  000a4	c1 e9 02	 shr	 ecx, 2
  000a7	8b f2		 mov	 esi, edx
  000a9	f3 a5		 rep movsd
  000ab	8b c8		 mov	 ecx, eax
  000ad	83 e1 03	 and	 ecx, 3

; 1379 : 
; 1380 : 	if (bErr)

  000b0	83 bc 24 74 ea
	00 00 00	 cmp	 DWORD PTR _bErr$[esp+60008], 0
  000b8	f3 a4		 rep movsb
  000ba	5f		 pop	 edi
  000bb	5e		 pop	 esi
  000bc	74 21		 je	 SHORT $LN2@ShowInPlac

; 1381 : 		ErrorDirect (msg);

  000be	8d 04 24	 lea	 eax, DWORD PTR _msg$[esp+60004]
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 _ErrorDirect

; 1382 : 	else
; 1383 : 		WarningDirect (msg);

  000c7	83 c4 04	 add	 esp, 4

; 1384 : }

  000ca	8b 8c 24 60 ea
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+60004]
  000d1	33 cc		 xor	 ecx, esp
  000d3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d8	81 c4 64 ea 00
	00		 add	 esp, 60004		; 0000ea64H
  000de	c3		 ret	 0
$LN2@ShowInPlac:

; 1382 : 	else
; 1383 : 		WarningDirect (msg);

  000df	8d 0c 24	 lea	 ecx, DWORD PTR _msg$[esp+60004]
  000e2	51		 push	 ecx
  000e3	e8 00 00 00 00	 call	 _WarningDirect

; 1384 : }

  000e8	8b 8c 24 64 ea
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+60008]
  000ef	83 c4 04	 add	 esp, 4
  000f2	33 cc		 xor	 ecx, esp
  000f4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f9	81 c4 64 ea 00
	00		 add	 esp, 60004		; 0000ea64H
  000ff	c3		 ret	 0
_ShowInPlaceEncErrMsgWAltSteps ENDP
_TEXT	ENDS
EXTRN	_NonSysInplaceEncTotalSize:QWORD
EXTRN	_NonSysInplaceEncBytesDone:QWORD
; Function compile flags: /Ogtpy
;	COMDAT _ExportProgressStats
_TEXT	SEGMENT
_bytesDone$ = 8						; size = 8
_totalSize$ = 16					; size = 8
_ExportProgressStats PROC				; COMDAT

; 1389 : 	NonSysInplaceEncBytesDone = bytesDone;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _bytesDone$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR _bytesDone$[esp]

; 1390 : 	NonSysInplaceEncTotalSize = totalSize;

  00008	8b 54 24 0c	 mov	 edx, DWORD PTR _totalSize$[esp-4]
  0000c	a3 00 00 00 00	 mov	 DWORD PTR _NonSysInplaceEncBytesDone, eax
  00011	8b 44 24 10	 mov	 eax, DWORD PTR _totalSize$[esp]
  00015	89 0d 04 00 00
	00		 mov	 DWORD PTR _NonSysInplaceEncBytesDone+4, ecx
  0001b	89 15 00 00 00
	00		 mov	 DWORD PTR _NonSysInplaceEncTotalSize, edx
  00021	a3 04 00 00 00	 mov	 DWORD PTR _NonSysInplaceEncTotalSize+4, eax

; 1391 : }

  00026	c3		 ret	 0
_ExportProgressStats ENDP
_TEXT	ENDS
PUBLIC	_SetNonSysInplaceEncUIStatus
EXTRN	_NonSysInplaceEncStatus:DWORD
; Function compile flags: /Ogtpy
;	COMDAT _SetNonSysInplaceEncUIStatus
_TEXT	SEGMENT
_nonSysInplaceEncStatus$ = 8				; size = 4
_SetNonSysInplaceEncUIStatus PROC			; COMDAT

; 1396 : 	NonSysInplaceEncStatus = nonSysInplaceEncStatus;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nonSysInplaceEncStatus$[esp-4]
  00004	a3 00 00 00 00	 mov	 DWORD PTR _NonSysInplaceEncStatus, eax

; 1397 : }

  00009	c3		 ret	 0
_SetNonSysInplaceEncUIStatus ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@NLGDPAAC@In?9Place?5Encryption?$AA@	; `string'
PUBLIC	??_C@_0BO@IBNLKCDC@In?9Place?5Encryption?5Wipe?5Algo?$AA@ ; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_SaveNonSysInPlaceEncSettings
EXTRN	_remove:PROC
EXTRN	_FileExists:PROC
EXTRN	_SaveBufferToFile:PROC
EXTRN	_GetConfigPath:PROC
EXTRN	_sprintf:PROC
EXTRN	_RemoveNonSysInPlaceEncNotifications:PROC
EXTRN	_LoadNonSysInPlaceEncSettings:PROC
;	COMDAT ??_C@_0BE@NLGDPAAC@In?9Place?5Encryption?$AA@
CONST	SEGMENT
??_C@_0BE@NLGDPAAC@In?9Place?5Encryption?$AA@ DB 'In-Place Encryption', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IBNLKCDC@In?9Place?5Encryption?5Wipe?5Algo?$AA@
CONST	SEGMENT
??_C@_0BO@IBNLKCDC@In?9Place?5Encryption?5Wipe?5Algo?$AA@ DB 'In-Place En'
	DB	'cryption Wipe Algo', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _SaveNonSysInPlaceEncSettings
_TEXT	SEGMENT
_savedWipeAlgorithm$ = -40				; size = 4
_str$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_delta$ = 8						; size = 4
_newWipeAlgorithm$ = 12					; size = 4
_SaveNonSysInPlaceEncSettings PROC			; COMDAT

; 1401 : {

  00000	83 ec 28	 sub	 esp, 40			; 00000028H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 24	 mov	 DWORD PTR __$ArrayPad$[esp+40], eax
  0000e	57		 push	 edi

; 1402 : 	int count;
; 1403 : 	char str[32];
; 1404 : 	WipeAlgorithmId savedWipeAlgorithm = TC_WIPE_NONE;
; 1405 : 
; 1406 : 	if (delta == 0)

  0000f	8b 7c 24 30	 mov	 edi, DWORD PTR _delta$[esp+40]
  00013	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR _savedWipeAlgorithm$[esp+44], 0
  0001b	85 ff		 test	 edi, edi
  0001d	75 13		 jne	 SHORT $LN6@SaveNonSys

; 1407 : 		return TRUE;

  0001f	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00022	5f		 pop	 edi

; 1432 : 	}
; 1433 : }

  00023	8b 4c 24 24	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+40]
  00027	33 cc		 xor	 ecx, esp
  00029	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002e	83 c4 28	 add	 esp, 40			; 00000028H
  00031	c3		 ret	 0
$LN6@SaveNonSys:

; 1408 : 
; 1409 : 	count = LoadNonSysInPlaceEncSettings (&savedWipeAlgorithm) + delta;

  00032	8d 44 24 04	 lea	 eax, DWORD PTR _savedWipeAlgorithm$[esp+44]
  00036	56		 push	 esi
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 _LoadNonSysInPlaceEncSettings
  0003d	8b f0		 mov	 esi, eax
  0003f	03 f7		 add	 esi, edi
  00041	83 c4 04	 add	 esp, 4

; 1410 : 
; 1411 : 	if (count < 1)

  00044	83 fe 01	 cmp	 esi, 1
  00047	7d 1b		 jge	 SHORT $LN5@SaveNonSys

; 1412 : 	{
; 1413 : 		RemoveNonSysInPlaceEncNotifications();

  00049	e8 00 00 00 00	 call	 _RemoveNonSysInPlaceEncNotifications
  0004e	5e		 pop	 esi

; 1414 : 		return TRUE;

  0004f	b8 01 00 00 00	 mov	 eax, 1
  00054	5f		 pop	 edi

; 1432 : 	}
; 1433 : }

  00055	8b 4c 24 24	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+40]
  00059	33 cc		 xor	 ecx, esp
  0005b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00060	83 c4 28	 add	 esp, 40			; 00000028H
  00063	c3		 ret	 0
$LN5@SaveNonSys:

; 1415 : 	}
; 1416 : 	else
; 1417 : 	{
; 1418 : 		if (newWipeAlgorithm != TC_WIPE_NONE)

  00064	8b 44 24 38	 mov	 eax, DWORD PTR _newWipeAlgorithm$[esp+44]
  00068	85 c0		 test	 eax, eax
  0006a	74 43		 je	 SHORT $LN3@SaveNonSys

; 1419 : 		{
; 1420 : 			sprintf (str, "%d", (int) newWipeAlgorithm);

  0006c	50		 push	 eax
  0006d	8d 4c 24 10	 lea	 ecx, DWORD PTR _str$[esp+52]
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00076	51		 push	 ecx
  00077	e8 00 00 00 00	 call	 _sprintf

; 1421 : 
; 1422 : 			SaveBufferToFile (str, GetConfigPath (TC_APPD_FILENAME_NONSYS_INPLACE_ENC_WIPE), strlen(str), FALSE);

  0007c	8d 44 24 18	 lea	 eax, DWORD PTR _str$[esp+60]
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH
  00083	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL9@SaveNonSys:
  00086	8a 08		 mov	 cl, BYTE PTR [eax]
  00088	40		 inc	 eax
  00089	84 c9		 test	 cl, cl
  0008b	75 f9		 jne	 SHORT $LL9@SaveNonSys
  0008d	2b c2		 sub	 eax, edx
  0008f	6a 00		 push	 0
  00091	50		 push	 eax
  00092	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@IBNLKCDC@In?9Place?5Encryption?5Wipe?5Algo?$AA@
  00097	e8 00 00 00 00	 call	 _GetConfigPath
  0009c	83 c4 04	 add	 esp, 4
  0009f	50		 push	 eax
  000a0	8d 54 24 18	 lea	 edx, DWORD PTR _str$[esp+60]
  000a4	52		 push	 edx
  000a5	e8 00 00 00 00	 call	 _SaveBufferToFile
  000aa	83 c4 10	 add	 esp, 16			; 00000010H
  000ad	eb 2a		 jmp	 SHORT $LN1@SaveNonSys
$LN3@SaveNonSys:

; 1423 : 		} 
; 1424 : 		else if (FileExists (GetConfigPath (TC_APPD_FILENAME_NONSYS_INPLACE_ENC_WIPE)))

  000af	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@IBNLKCDC@In?9Place?5Encryption?5Wipe?5Algo?$AA@
  000b4	e8 00 00 00 00	 call	 _GetConfigPath
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 _FileExists
  000bf	83 c4 08	 add	 esp, 8
  000c2	85 c0		 test	 eax, eax
  000c4	74 13		 je	 SHORT $LN1@SaveNonSys

; 1425 : 		{
; 1426 : 			remove (GetConfigPath (TC_APPD_FILENAME_NONSYS_INPLACE_ENC_WIPE));

  000c6	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@IBNLKCDC@In?9Place?5Encryption?5Wipe?5Algo?$AA@
  000cb	e8 00 00 00 00	 call	 _GetConfigPath
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 _remove
  000d6	83 c4 08	 add	 esp, 8
$LN1@SaveNonSys:

; 1427 : 		}
; 1428 : 
; 1429 : 		sprintf (str, "%d", count);

  000d9	56		 push	 esi
  000da	8d 44 24 10	 lea	 eax, DWORD PTR _str$[esp+52]
  000de	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  000e3	50		 push	 eax
  000e4	e8 00 00 00 00	 call	 _sprintf

; 1430 : 
; 1431 : 		return SaveBufferToFile (str, GetConfigPath (TC_APPD_FILENAME_NONSYS_INPLACE_ENC), strlen(str), FALSE);

  000e9	8d 44 24 18	 lea	 eax, DWORD PTR _str$[esp+60]
  000ed	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f0	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL10@SaveNonSys:
  000f3	8a 08		 mov	 cl, BYTE PTR [eax]
  000f5	40		 inc	 eax
  000f6	84 c9		 test	 cl, cl
  000f8	75 f9		 jne	 SHORT $LL10@SaveNonSys
  000fa	2b c2		 sub	 eax, edx
  000fc	6a 00		 push	 0
  000fe	50		 push	 eax
  000ff	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@NLGDPAAC@In?9Place?5Encryption?$AA@
  00104	e8 00 00 00 00	 call	 _GetConfigPath
  00109	83 c4 04	 add	 esp, 4
  0010c	50		 push	 eax
  0010d	8d 4c 24 18	 lea	 ecx, DWORD PTR _str$[esp+60]
  00111	51		 push	 ecx
  00112	e8 00 00 00 00	 call	 _SaveBufferToFile

; 1432 : 	}
; 1433 : }

  00117	8b 4c 24 3c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+64]
  0011b	83 c4 10	 add	 esp, 16			; 00000010H
  0011e	5e		 pop	 esi
  0011f	5f		 pop	 edi
  00120	33 cc		 xor	 ecx, esp
  00122	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00127	83 c4 28	 add	 esp, 40			; 00000028H
  0012a	c3		 ret	 0
_SaveNonSysInPlaceEncSettings ENDP
_TEXT	ENDS
PUBLIC	_ZeroUnreadableSectors
EXTRN	_memset:PROC
; Function compile flags: /Ogtpy
;	COMDAT _ZeroUnreadableSectors
_TEXT	SEGMENT
_n$ = -20						; size = 4
_sectorCount$ = -16					; size = 8
_workOffset$ = -8					; size = 8
_dev$ = 8						; size = 4
_startOffset$ = 12					; size = 8
_size$ = 20						; size = 8
_sectorSize$ = 28					; size = 4
_zeroedSectorCount$ = 32				; size = 4
_ZeroUnreadableSectors PROC				; COMDAT

; 1439 : {

  00000	83 ec 14	 sub	 esp, 20			; 00000014H

; 1440 : 	int nStatus;
; 1441 : 	DWORD n;
; 1442 : 	int64 sectorCount;
; 1443 : 	LARGE_INTEGER workOffset;
; 1444 : 	byte *sectorBuffer = NULL;
; 1445 : 	DWORD dwError;
; 1446 : 
; 1447 : 	workOffset.QuadPart = startOffset.QuadPart;

  00003	8b 44 24 20	 mov	 eax, DWORD PTR _startOffset$[esp+20]
  00007	53		 push	 ebx
  00008	8b 5c 24 20	 mov	 ebx, DWORD PTR _startOffset$[esp+20]
  0000c	56		 push	 esi

; 1448 : 
; 1449 : 	sectorBuffer = (byte *) TCalloc (sectorSize);

  0000d	8b 74 24 34	 mov	 esi, DWORD PTR _sectorSize$[esp+24]
  00011	57		 push	 edi
  00012	56		 push	 esi
  00013	89 44 24 20	 mov	 DWORD PTR _workOffset$[esp+40], eax
  00017	e8 00 00 00 00	 call	 _malloc
  0001c	8b f8		 mov	 edi, eax
  0001e	83 c4 04	 add	 esp, 4

; 1450 : 
; 1451 : 	if (!sectorBuffer)

  00021	85 ff		 test	 edi, edi
  00023	75 0a		 jne	 SHORT $LN13@ZeroUnread

; 1452 : 		return ERR_OUTOFMEMORY;

  00025	8d 47 02	 lea	 eax, DWORD PTR [edi+2]
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx

; 1497 : }

  0002b	83 c4 14	 add	 esp, 20			; 00000014H
  0002e	c3		 ret	 0
$LN13@ZeroUnread:

; 1453 : 
; 1454 : 	if (SetFilePointerEx (dev, startOffset, NULL, FILE_BEGIN) == 0)

  0002f	8b 4c 24 2c	 mov	 ecx, DWORD PTR _startOffset$[esp+32]
  00033	8b 54 24 28	 mov	 edx, DWORD PTR _startOffset$[esp+28]
  00037	55		 push	 ebp
  00038	8b 6c 24 28	 mov	 ebp, DWORD PTR _dev$[esp+32]
  0003c	6a 00		 push	 0
  0003e	6a 00		 push	 0
  00040	51		 push	 ecx
  00041	52		 push	 edx
  00042	55		 push	 ebp
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN12@ZeroUnread
$LN18@ZeroUnread:

; 1455 : 	{
; 1456 : 		nStatus = ERR_OS_ERROR;

  0004d	be 01 00 00 00	 mov	 esi, 1
  00052	e9 a5 00 00 00	 jmp	 $closing_seq$120095
$LN12@ZeroUnread:

; 1457 : 		goto closing_seq;
; 1458 : 	}
; 1459 : 
; 1460 : 
; 1461 : 	for (sectorCount = size / sectorSize; sectorCount > 0; --sectorCount)

  00057	8b 4c 24 34	 mov	 ecx, DWORD PTR _size$[esp+32]
  0005b	8b c6		 mov	 eax, esi
  0005d	99		 cdq
  0005e	52		 push	 edx
  0005f	50		 push	 eax
  00060	8b 44 24 40	 mov	 eax, DWORD PTR _size$[esp+44]
  00064	50		 push	 eax
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 __alldiv
  0006b	89 44 24 14	 mov	 DWORD PTR _sectorCount$[esp+36], eax
  0006f	89 54 24 18	 mov	 DWORD PTR _sectorCount$[esp+40], edx
  00073	85 d2		 test	 edx, edx
  00075	0f 8c 7f 00 00
	00		 jl	 $LN8@ZeroUnread
  0007b	7f 04		 jg	 SHORT $LL22@ZeroUnread
  0007d	85 c0		 test	 eax, eax
  0007f	76 79		 jbe	 SHORT $LN8@ZeroUnread
$LL22@ZeroUnread:

; 1462 : 	{
; 1463 : 		if (ReadFile (dev, sectorBuffer, sectorSize, &n, NULL) == 0)

  00081	6a 00		 push	 0
  00083	8d 54 24 14	 lea	 edx, DWORD PTR _n$[esp+40]
  00087	52		 push	 edx
  00088	56		 push	 esi
  00089	57		 push	 edi
  0008a	55		 push	 ebp
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20
  00091	85 c0		 test	 eax, eax
  00093	75 3f		 jne	 SHORT $LN24@ZeroUnread

; 1464 : 		{
; 1465 : 			memset (sectorBuffer, 0, sectorSize);

  00095	56		 push	 esi
  00096	50		 push	 eax
  00097	57		 push	 edi
  00098	e8 00 00 00 00	 call	 _memset

; 1466 : 
; 1467 : 			if (SetFilePointerEx (dev, workOffset, NULL, FILE_BEGIN) == 0)

  0009d	8b 44 24 2c	 mov	 eax, DWORD PTR _workOffset$[esp+52]
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a4	6a 00		 push	 0
  000a6	6a 00		 push	 0
  000a8	50		 push	 eax
  000a9	53		 push	 ebx
  000aa	55		 push	 ebp
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  000b1	85 c0		 test	 eax, eax
  000b3	74 98		 je	 SHORT $LN18@ZeroUnread

; 1468 : 			{
; 1469 : 				nStatus = ERR_OS_ERROR;
; 1470 : 				goto closing_seq;
; 1471 : 			}
; 1472 : 
; 1473 : 			if (WriteFile (dev, sectorBuffer, sectorSize, &n, NULL) == 0)

  000b5	6a 00		 push	 0
  000b7	8d 4c 24 14	 lea	 ecx, DWORD PTR _n$[esp+40]
  000bb	51		 push	 ecx
  000bc	56		 push	 esi
  000bd	57		 push	 edi
  000be	55		 push	 ebp
  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  000c5	85 c0		 test	 eax, eax
  000c7	74 84		 je	 SHORT $LN18@ZeroUnread

; 1474 : 			{
; 1475 : 				nStatus = ERR_OS_ERROR;
; 1476 : 				goto closing_seq;
; 1477 : 			}
; 1478 : 			++(*zeroedSectorCount);

  000c9	8b 44 24 40	 mov	 eax, DWORD PTR _zeroedSectorCount$[esp+32]
  000cd	83 00 01	 add	 DWORD PTR [eax], 1
  000d0	83 50 04 00	 adc	 DWORD PTR [eax+4], 0
$LN24@ZeroUnread:

; 1479 : 		}
; 1480 : 
; 1481 : 		workOffset.QuadPart += n;

  000d4	03 5c 24 10	 add	 ebx, DWORD PTR _n$[esp+36]
  000d8	8b 44 24 18	 mov	 eax, DWORD PTR _sectorCount$[esp+40]
  000dc	83 54 24 20 00	 adc	 DWORD PTR _workOffset$[esp+40], 0
  000e1	83 44 24 14 ff	 add	 DWORD PTR _sectorCount$[esp+36], -1
  000e6	83 d0 ff	 adc	 eax, -1
  000e9	89 44 24 18	 mov	 DWORD PTR _sectorCount$[esp+40], eax
  000ed	85 c0		 test	 eax, eax
  000ef	7f 90		 jg	 SHORT $LL22@ZeroUnread

; 1457 : 		goto closing_seq;
; 1458 : 	}
; 1459 : 
; 1460 : 
; 1461 : 	for (sectorCount = size / sectorSize; sectorCount > 0; --sectorCount)

  000f1	7c 07		 jl	 SHORT $LN8@ZeroUnread
  000f3	83 7c 24 14 00	 cmp	 DWORD PTR _sectorCount$[esp+36], 0
  000f8	77 87		 ja	 SHORT $LL22@ZeroUnread
$LN8@ZeroUnread:

; 1482 : 	}
; 1483 : 
; 1484 : 	nStatus = ERR_SUCCESS;

  000fa	33 f6		 xor	 esi, esi
$closing_seq$120095:

; 1485 : 
; 1486 : closing_seq:
; 1487 : 
; 1488 : 	dwError = GetLastError();

  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 1489 : 
; 1490 : 	if (sectorBuffer != NULL)
; 1491 : 		TCfree (sectorBuffer);

  00102	57		 push	 edi
  00103	8b d8		 mov	 ebx, eax
  00105	e8 00 00 00 00	 call	 _free
  0010a	83 c4 04	 add	 esp, 4
  0010d	5d		 pop	 ebp

; 1492 : 
; 1493 : 	if (nStatus != ERR_SUCCESS)

  0010e	85 f6		 test	 esi, esi
  00110	74 07		 je	 SHORT $LN1@ZeroUnread

; 1494 : 		SetLastError (dwError);

  00112	53		 push	 ebx
  00113	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
$LN1@ZeroUnread:
  00119	5f		 pop	 edi

; 1495 : 
; 1496 : 	return nStatus;

  0011a	8b c6		 mov	 eax, esi
  0011c	5e		 pop	 esi
  0011d	5b		 pop	 ebx

; 1497 : }

  0011e	83 c4 14	 add	 esp, 20			; 00000014H
  00121	c3		 ret	 0
_ZeroUnreadableSectors ENDP
_TEXT	ENDS
EXTRN	_ReadVolumeHeader:PROC
; Function compile flags: /Ogtpy
;	COMDAT _OpenBackupHeader
_TEXT	SEGMENT
_n$ = -4						; size = 4
_password$ = 8						; size = 4
_retMasterCryptoInfo$ = 12				; size = 4
_headerCryptoInfo$ = 16					; size = 4
_deviceSize$ = 20					; size = 8
_OpenBackupHeader PROC					; COMDAT
; _dev$ = eax

; 1501 : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 1502 : 	LARGE_INTEGER offset;
; 1503 : 	DWORD n;
; 1504 : 	int nStatus = ERR_SUCCESS;
; 1505 : 	char *header;
; 1506 : 	DWORD dwError;
; 1507 : 
; 1508 : 	header = (char *) TCalloc (TC_VOLUME_HEADER_EFFECTIVE_SIZE);

  00003	68 00 02 00 00	 push	 512			; 00000200H
  00008	8b f8		 mov	 edi, eax
  0000a	e8 00 00 00 00	 call	 _malloc
  0000f	8b f0		 mov	 esi, eax
  00011	83 c4 04	 add	 esp, 4

; 1509 : 	if (!header)

  00014	85 f6		 test	 esi, esi
  00016	75 07		 jne	 SHORT $LN12@OpenBackup
  00018	5f		 pop	 edi

; 1510 : 		return ERR_OUTOFMEMORY;

  00019	8d 46 02	 lea	 eax, DWORD PTR [esi+2]
  0001c	5e		 pop	 esi

; 1545 : }

  0001d	59		 pop	 ecx
  0001e	c3		 ret	 0
$LN12@OpenBackup:
  0001f	55		 push	 ebp

; 1511 : 
; 1512 : 	VirtualLock (header, TC_VOLUME_HEADER_EFFECTIVE_SIZE);

  00020	68 00 02 00 00	 push	 512			; 00000200H
  00025	56		 push	 esi
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualLock@8

; 1513 : 
; 1514 : 
; 1515 : 
; 1516 : 	offset.QuadPart = deviceSize - TC_VOLUME_HEADER_GROUP_SIZE;

  0002c	8b 44 24 20	 mov	 eax, DWORD PTR _deviceSize$[esp+12]
  00030	8b 4c 24 24	 mov	 ecx, DWORD PTR _deviceSize$[esp+16]

; 1517 : 
; 1518 : 	if (SetFilePointerEx (dev, offset, NULL, FILE_BEGIN) == 0
; 1519 : 		|| !ReadEffectiveVolumeHeader (TRUE, dev, (byte *) header, &n) || n < TC_VOLUME_HEADER_EFFECTIVE_SIZE)

  00034	6a 00		 push	 0
  00036	2d 00 00 02 00	 sub	 eax, 131072		; 00020000H
  0003b	6a 00		 push	 0
  0003d	83 d9 00	 sbb	 ecx, 0
  00040	51		 push	 ecx
  00041	50		 push	 eax
  00042	57		 push	 edi
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  00049	85 c0		 test	 eax, eax
  0004b	74 3d		 je	 SHORT $LN27@OpenBackup
  0004d	8d 44 24 0c	 lea	 eax, DWORD PTR _n$[esp+16]
  00051	50		 push	 eax
  00052	56		 push	 esi
  00053	57		 push	 edi
  00054	6a 01		 push	 1
  00056	e8 00 00 00 00	 call	 _ReadEffectiveVolumeHeader
  0005b	83 c4 10	 add	 esp, 16			; 00000010H
  0005e	85 c0		 test	 eax, eax
  00060	74 28		 je	 SHORT $LN27@OpenBackup
  00062	81 7c 24 0c 00
	02 00 00	 cmp	 DWORD PTR _n$[esp+16], 512 ; 00000200H
  0006a	72 1e		 jb	 SHORT $LN27@OpenBackup

; 1522 : 		goto closing_seq;
; 1523 : 	}
; 1524 : 
; 1525 : 
; 1526 : 	nStatus = ReadVolumeHeader (FALSE, header, password, retMasterCryptoInfo, headerCryptoInfo);

  0006c	8b 4c 24 1c	 mov	 ecx, DWORD PTR _headerCryptoInfo$[esp+12]
  00070	8b 54 24 18	 mov	 edx, DWORD PTR _retMasterCryptoInfo$[esp+12]
  00074	8b 44 24 14	 mov	 eax, DWORD PTR _password$[esp+12]
  00078	51		 push	 ecx
  00079	52		 push	 edx
  0007a	50		 push	 eax
  0007b	56		 push	 esi
  0007c	6a 00		 push	 0
  0007e	e8 00 00 00 00	 call	 _ReadVolumeHeader
  00083	83 c4 14	 add	 esp, 20			; 00000014H
  00086	8b e8		 mov	 ebp, eax

; 1527 : 	if (nStatus != ERR_SUCCESS)
; 1528 : 		goto closing_seq;
; 1529 : 
; 1530 : 
; 1531 : closing_seq:

  00088	eb 05		 jmp	 SHORT $closing_seq$120125
$LN27@OpenBackup:

; 1520 : 	{
; 1521 : 		nStatus = ERR_OS_ERROR;

  0008a	bd 01 00 00 00	 mov	 ebp, 1
$closing_seq$120125:
  0008f	53		 push	 ebx

; 1532 : 
; 1533 : 	dwError = GetLastError();

  00090	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetLastError@0
  00096	ff d3		 call	 ebx

; 1534 : 
; 1535 : 	burn (header, TC_VOLUME_HEADER_EFFECTIVE_SIZE);

  00098	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0009d	8b d6		 mov	 edx, esi
  0009f	8b f9		 mov	 edi, ecx
  000a1	8b c6		 mov	 eax, esi
$LL16@OpenBackup:
  000a3	c6 00 00	 mov	 BYTE PTR [eax], 0
  000a6	40		 inc	 eax
  000a7	83 ef 01	 sub	 edi, 1
  000aa	75 f7		 jne	 SHORT $LL16@OpenBackup
  000ac	8d 64 24 00	 npad	 4
$LL3@OpenBackup:
  000b0	49		 dec	 ecx
  000b1	c6 02 00	 mov	 BYTE PTR [edx], 0
  000b4	42		 inc	 edx
  000b5	85 c9		 test	 ecx, ecx
  000b7	75 f7		 jne	 SHORT $LL3@OpenBackup

; 1536 : 	VirtualUnlock (header, TC_VOLUME_HEADER_EFFECTIVE_SIZE);

  000b9	68 00 02 00 00	 push	 512			; 00000200H
  000be	56		 push	 esi
  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualUnlock@8

; 1537 : 	TCfree (header);

  000c5	56		 push	 esi
  000c6	e8 00 00 00 00	 call	 _free
  000cb	83 c4 04	 add	 esp, 4

; 1538 : 
; 1539 : 	dwError = GetLastError();

  000ce	ff d3		 call	 ebx
  000d0	5b		 pop	 ebx

; 1540 : 
; 1541 : 	if (nStatus != ERR_SUCCESS)

  000d1	85 ed		 test	 ebp, ebp
  000d3	74 07		 je	 SHORT $LN1@OpenBackup

; 1542 : 		SetLastError (dwError);

  000d5	50		 push	 eax
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
$LN1@OpenBackup:

; 1543 : 
; 1544 : 	return nStatus;

  000dc	8b c5		 mov	 eax, ebp
  000de	5d		 pop	 ebp
  000df	5f		 pop	 edi
  000e0	5e		 pop	 esi

; 1545 : }

  000e1	59		 pop	 ecx
  000e2	c3		 ret	 0
_OpenBackupHeader ENDP
_TEXT	ENDS
PUBLIC	_freeCluster$GSCopy$
PUBLIC	_volumeHandle$GSCopy$
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeClusterBeforeThreshold@@YAHPAXPA_J_J@Z
_TEXT	SEGMENT
_startLcn$ = -65592					; size = 8
_freeCluster$GSCopy$ = -65584				; size = 4
_volumeHandle$GSCopy$ = -65580				; size = 4
tv225 = -65576						; size = 8
_bytesReturned$ = -65568				; size = 4
_bitmapBuffer$ = -65564					; size = 65560
__$ArrayPad$ = -4					; size = 4
_volumeHandle$ = 8					; size = 4
_clusterThreshold$ = 12					; size = 8
?GetFreeClusterBeforeThreshold@@YAHPAXPA_J_J@Z PROC	; GetFreeClusterBeforeThreshold, COMDAT
; _freeCluster$ = ecx

; 1549 : {

  00000	b8 38 00 01 00	 mov	 eax, 65592		; 00010038H
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000f	33 c4		 xor	 eax, esp
  00011	89 84 24 34 00
	01 00		 mov	 DWORD PTR __$ArrayPad$[esp+65592], eax

; 1583 : 	}

  00018	8b 84 24 3c 00
	01 00		 mov	 eax, DWORD PTR _volumeHandle$[esp+65588]
  0001f	53		 push	 ebx
  00020	55		 push	 ebp
  00021	89 44 24 14	 mov	 DWORD PTR _volumeHandle$GSCopy$[esp+65600], eax
  00025	33 c0		 xor	 eax, eax
  00027	56		 push	 esi
  00028	89 4c 24 14	 mov	 DWORD PTR _freeCluster$GSCopy$[esp+65604], ecx
  0002c	89 44 24 0c	 mov	 DWORD PTR _startLcn$[esp+65604], eax
  00030	89 44 24 10	 mov	 DWORD PTR _startLcn$[esp+65608], eax
  00034	57		 push	 edi
$LL15@GetFreeClu:
  00035	6a 00		 push	 0
  00037	8d 54 24 2c	 lea	 edx, DWORD PTR _bytesReturned$[esp+65612]
  0003b	52		 push	 edx
  0003c	8b 54 24 24	 mov	 edx, DWORD PTR _volumeHandle$GSCopy$[esp+65616]
  00040	68 18 00 01 00	 push	 65560			; 00010018H
  00045	8d 44 24 38	 lea	 eax, DWORD PTR _bitmapBuffer$[esp+65620]
  00049	50		 push	 eax
  0004a	6a 08		 push	 8
  0004c	8d 4c 24 24	 lea	 ecx, DWORD PTR _startLcn$[esp+65628]
  00050	51		 push	 ecx
  00051	68 6f 00 09 00	 push	 589935			; 0009006fH
  00056	52		 push	 edx
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  0005d	85 c0		 test	 eax, eax
  0005f	75 11		 jne	 SHORT $LN13@GetFreeClu
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00067	3d ea 00 00 00	 cmp	 eax, 234		; 000000eaH
  0006c	0f 85 20 01 00
	00		 jne	 $err$120160
$LN13@GetFreeClu:

; 1550 : 	const int bitmapSize = 65536;
; 1551 : 	byte bitmapBuffer[bitmapSize + sizeof (VOLUME_BITMAP_BUFFER)];
; 1552 : 	VOLUME_BITMAP_BUFFER *bitmap = (VOLUME_BITMAP_BUFFER *) bitmapBuffer;
; 1553 : 	STARTING_LCN_INPUT_BUFFER startLcn;
; 1554 : 	startLcn.StartingLcn.QuadPart = 0;
; 1555 : 
; 1556 : 	DWORD bytesReturned;
; 1557 : 	while (DeviceIoControl (volumeHandle, FSCTL_GET_VOLUME_BITMAP, &startLcn, sizeof (startLcn), &bitmapBuffer, sizeof (bitmapBuffer), &bytesReturned, NULL)
; 1558 : 		|| GetLastError() == ERROR_MORE_DATA)
; 1559 : 	{
; 1560 : 		for (int64 bitmapIndex = 0; bitmapIndex < min (bitmapSize, (bitmap->BitmapSize.QuadPart / 8)); ++bitmapIndex)

  00072	8b 44 24 38	 mov	 eax, DWORD PTR _bitmapBuffer$[esp+65620]
  00076	8b 4c 24 34	 mov	 ecx, DWORD PTR _bitmapBuffer$[esp+65616]
  0007a	33 ed		 xor	 ebp, ebp
  0007c	55		 push	 ebp
  0007d	6a 08		 push	 8
  0007f	50		 push	 eax
  00080	51		 push	 ecx
  00081	33 ff		 xor	 edi, edi
  00083	e8 00 00 00 00	 call	 __alldiv
  00088	8b 5c 24 30	 mov	 ebx, DWORD PTR _bitmapBuffer$[esp+65612]
  0008c	8b f0		 mov	 esi, eax
  0008e	8b c2		 mov	 eax, edx
  00090	89 74 24 20	 mov	 DWORD PTR tv225[esp+65608], esi
  00094	89 44 24 24	 mov	 DWORD PTR tv225[esp+65612], eax
$LL12@GetFreeClu:
  00098	85 c0		 test	 eax, eax
  0009a	7c 13		 jl	 SHORT $LN18@GetFreeClu
  0009c	7f 08		 jg	 SHORT $LN34@GetFreeClu
  0009e	81 fe 00 00 01
	00		 cmp	 esi, 65536		; 00010000H
  000a4	76 09		 jbe	 SHORT $LN18@GetFreeClu
$LN34@GetFreeClu:
  000a6	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  000ab	33 c0		 xor	 eax, eax
  000ad	eb 02		 jmp	 SHORT $LN19@GetFreeClu
$LN18@GetFreeClu:
  000af	8b ce		 mov	 ecx, esi
$LN19@GetFreeClu:
  000b1	3b e8		 cmp	 ebp, eax
  000b3	7f 67		 jg	 SHORT $LN10@GetFreeClu
  000b5	7c 04		 jl	 SHORT $LN30@GetFreeClu
  000b7	3b f9		 cmp	 edi, ecx
  000b9	73 61		 jae	 SHORT $LN10@GetFreeClu
$LN30@GetFreeClu:

; 1561 : 		{
; 1562 : 			if (bitmap->StartingLcn.QuadPart + bitmapIndex * 8 >= clusterThreshold)

  000bb	6a 00		 push	 0
  000bd	6a 08		 push	 8
  000bf	55		 push	 ebp
  000c0	57		 push	 edi
  000c1	e8 00 00 00 00	 call	 __allmul
  000c6	03 44 24 2c	 add	 eax, DWORD PTR _bitmapBuffer$[esp+65608]
  000ca	13 d3		 adc	 edx, ebx
  000cc	3b 94 24 54 00
	01 00		 cmp	 edx, DWORD PTR _clusterThreshold$[esp+65608]
  000d3	0f 8f b9 00 00
	00		 jg	 $err$120160
  000d9	7c 0d		 jl	 SHORT $LN31@GetFreeClu
  000db	3b 84 24 50 00
	01 00		 cmp	 eax, DWORD PTR _clusterThreshold$[esp+65604]
  000e2	0f 83 aa 00 00
	00		 jae	 $err$120160
$LN31@GetFreeClu:

; 1563 : 				goto err;
; 1564 : 
; 1565 : 			if (bitmap->Buffer[bitmapIndex] != 0xff)

  000e8	80 7c 3c 3c ff	 cmp	 BYTE PTR _bitmapBuffer$[esp+edi+65624], 255 ; 000000ffH
  000ed	74 1e		 je	 SHORT $LN11@GetFreeClu

; 1566 : 			{
; 1567 : 				for (int bit = 0; bit < 8; ++bit)

  000ef	0f b6 44 3c 3c	 movzx	 eax, BYTE PTR _bitmapBuffer$[esp+edi+65624]
  000f4	33 f6		 xor	 esi, esi
$LL6@GetFreeClu:

; 1568 : 				{
; 1569 : 					if ((bitmap->Buffer[bitmapIndex] & (1 << bit)) == 0)

  000f6	ba 01 00 00 00	 mov	 edx, 1
  000fb	8b ce		 mov	 ecx, esi
  000fd	d3 e2		 shl	 edx, cl
  000ff	85 d0		 test	 edx, eax
  00101	74 52		 je	 SHORT $LN26@GetFreeClu
  00103	46		 inc	 esi
  00104	83 fe 08	 cmp	 esi, 8
  00107	7c ed		 jl	 SHORT $LL6@GetFreeClu

; 1566 : 			{
; 1567 : 				for (int bit = 0; bit < 8; ++bit)

  00109	8b 74 24 20	 mov	 esi, DWORD PTR tv225[esp+65608]
$LN11@GetFreeClu:

; 1550 : 	const int bitmapSize = 65536;
; 1551 : 	byte bitmapBuffer[bitmapSize + sizeof (VOLUME_BITMAP_BUFFER)];
; 1552 : 	VOLUME_BITMAP_BUFFER *bitmap = (VOLUME_BITMAP_BUFFER *) bitmapBuffer;
; 1553 : 	STARTING_LCN_INPUT_BUFFER startLcn;
; 1554 : 	startLcn.StartingLcn.QuadPart = 0;
; 1555 : 
; 1556 : 	DWORD bytesReturned;
; 1557 : 	while (DeviceIoControl (volumeHandle, FSCTL_GET_VOLUME_BITMAP, &startLcn, sizeof (startLcn), &bitmapBuffer, sizeof (bitmapBuffer), &bytesReturned, NULL)
; 1558 : 		|| GetLastError() == ERROR_MORE_DATA)
; 1559 : 	{
; 1560 : 		for (int64 bitmapIndex = 0; bitmapIndex < min (bitmapSize, (bitmap->BitmapSize.QuadPart / 8)); ++bitmapIndex)

  0010d	8b 44 24 24	 mov	 eax, DWORD PTR tv225[esp+65612]
  00111	83 c7 01	 add	 edi, 1
  00114	83 d5 00	 adc	 ebp, 0
  00117	e9 7c ff ff ff	 jmp	 $LL12@GetFreeClu
$LN10@GetFreeClu:

; 1577 : 					}
; 1578 : 				}
; 1579 : 			}
; 1580 : 		}
; 1581 : 
; 1582 : 		startLcn.StartingLcn.QuadPart += min (bitmapSize * 8, bitmap->BitmapSize.QuadPart);

  0011c	8b 4c 24 38	 mov	 ecx, DWORD PTR _bitmapBuffer$[esp+65620]
  00120	85 c9		 test	 ecx, ecx
  00122	7c 20		 jl	 SHORT $LN36@GetFreeClu
  00124	7f 0a		 jg	 SHORT $LN35@GetFreeClu
  00126	81 7c 24 34 00
	00 08 00	 cmp	 DWORD PTR _bitmapBuffer$[esp+65616], 524288 ; 00080000H
  0012e	76 14		 jbe	 SHORT $LN36@GetFreeClu
$LN35@GetFreeClu:
  00130	b8 00 00 08 00	 mov	 eax, 524288		; 00080000H
  00135	33 c9		 xor	 ecx, ecx
  00137	01 44 24 10	 add	 DWORD PTR _startLcn$[esp+65608], eax
  0013b	11 4c 24 14	 adc	 DWORD PTR _startLcn$[esp+65612], ecx

; 1583 : 	}

  0013f	e9 f1 fe ff ff	 jmp	 $LL15@GetFreeClu
$LN36@GetFreeClu:

; 1577 : 					}
; 1578 : 				}
; 1579 : 			}
; 1580 : 		}
; 1581 : 
; 1582 : 		startLcn.StartingLcn.QuadPart += min (bitmapSize * 8, bitmap->BitmapSize.QuadPart);

  00144	8b 44 24 34	 mov	 eax, DWORD PTR _bitmapBuffer$[esp+65616]
  00148	01 44 24 10	 add	 DWORD PTR _startLcn$[esp+65608], eax
  0014c	11 4c 24 14	 adc	 DWORD PTR _startLcn$[esp+65612], ecx

; 1583 : 	}

  00150	e9 e0 fe ff ff	 jmp	 $LL15@GetFreeClu
$LN26@GetFreeClu:

; 1570 : 					{
; 1571 : 						*freeCluster = bitmap->StartingLcn.QuadPart + bitmapIndex * 8 + bit;

  00155	6a 00		 push	 0
  00157	6a 08		 push	 8
  00159	55		 push	 ebp
  0015a	57		 push	 edi
  0015b	e8 00 00 00 00	 call	 __allmul
  00160	8b c8		 mov	 ecx, eax
  00162	8b fa		 mov	 edi, edx
  00164	8b c6		 mov	 eax, esi
  00166	99		 cdq
  00167	03 c8		 add	 ecx, eax
  00169	8b 44 24 18	 mov	 eax, DWORD PTR _freeCluster$GSCopy$[esp+65608]
  0016d	13 fa		 adc	 edi, edx
  0016f	03 4c 24 2c	 add	 ecx, DWORD PTR _bitmapBuffer$[esp+65608]
  00173	13 fb		 adc	 edi, ebx

; 1572 : 
; 1573 : 						if (*freeCluster >= clusterThreshold)

  00175	8b d7		 mov	 edx, edi
  00177	3b 94 24 54 00
	01 00		 cmp	 edx, DWORD PTR _clusterThreshold$[esp+65608]
  0017e	89 08		 mov	 DWORD PTR [eax], ecx
  00180	89 78 04	 mov	 DWORD PTR [eax+4], edi
  00183	7c 19		 jl	 SHORT $LN2@GetFreeClu
  00185	7f 0b		 jg	 SHORT $err$120160
  00187	8b c1		 mov	 eax, ecx
  00189	3b 84 24 50 00
	01 00		 cmp	 eax, DWORD PTR _clusterThreshold$[esp+65604]
  00190	72 0c		 jb	 SHORT $LN2@GetFreeClu
$err$120160:

; 1584 : 	
; 1585 : err:
; 1586 : 	SetLastError (ERROR_DISK_FULL);

  00192	6a 70		 push	 112			; 00000070H
  00194	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 1587 : 	return FALSE;

  0019a	33 c0		 xor	 eax, eax
  0019c	eb 05		 jmp	 SHORT $LN16@GetFreeClu
$LN2@GetFreeClu:

; 1574 : 							goto err;
; 1575 : 
; 1576 : 						return TRUE;

  0019e	b8 01 00 00 00	 mov	 eax, 1
$LN16@GetFreeClu:

; 1588 : }

  001a3	8b 8c 24 44 00
	01 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+65608]
  001aa	5f		 pop	 edi
  001ab	5e		 pop	 esi
  001ac	5d		 pop	 ebp
  001ad	5b		 pop	 ebx
  001ae	33 cc		 xor	 ecx, esp
  001b0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b5	81 c4 38 00 01
	00		 add	 esp, 65592		; 00010038H
  001bb	c3		 ret	 0
?GetFreeClusterBeforeThreshold@@YAHPAXPA_J_J@Z ENDP	; GetFreeClusterBeforeThreshold
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0Finally1599@?3??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@0@Z
_TEXT	SEGMENT
??0Finally1599@?3??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@0@Z PROC ; `MoveClustersBeforeThresholdInDir'::`4'::Finally1599::Finally1599, COMDAT
; _this$ = eax
; _a$ = ecx

; 1599 : 	finally_do_arg (HANDLE, findHandle, { FindClose (finally_arg); });

  00000	89 08		 mov	 DWORD PTR [eax], ecx
  00002	c3		 ret	 0
??0Finally1599@?3??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@0@Z ENDP ; `MoveClustersBeforeThresholdInDir'::`4'::Finally1599::Finally1599
_TEXT	ENDS
EXTRN	__imp__FindClose@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1Finally1599@?3??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@XZ
_TEXT	SEGMENT
??1Finally1599@?3??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@XZ PROC ; `MoveClustersBeforeThresholdInDir'::`4'::Finally1599::~Finally1599, COMDAT
; _this$ = eax

; 1599 : 	finally_do_arg (HANDLE, findHandle, { FindClose (finally_arg); });

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	51		 push	 ecx
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindClose@4
  00009	c3		 ret	 0
??1Finally1599@?3??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@XZ ENDP ; `MoveClustersBeforeThresholdInDir'::`4'::Finally1599::~Finally1599
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0Finally1624@?BC@??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@0@Z
_TEXT	SEGMENT
??0Finally1624@?BC@??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@0@Z PROC ; `MoveClustersBeforeThresholdInDir'::`18'::Finally1624::Finally1624, COMDAT
; _this$ = eax
; _a$ = ecx

; 1624 : 		finally_do_arg (HANDLE, fsObject, { CloseHandle (finally_arg); });

  00000	89 08		 mov	 DWORD PTR [eax], ecx
  00002	c3		 ret	 0
??0Finally1624@?BC@??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@0@Z ENDP ; `MoveClustersBeforeThresholdInDir'::`18'::Finally1624::Finally1624
_TEXT	ENDS
EXTRN	__imp__CloseHandle@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1Finally1624@?BC@??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@XZ
_TEXT	SEGMENT
??1Finally1624@?BC@??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@XZ PROC ; `MoveClustersBeforeThresholdInDir'::`18'::Finally1624::~Finally1624, COMDAT
; _this$ = eax

; 1624 : 		finally_do_arg (HANDLE, fsObject, { CloseHandle (finally_arg); });

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	51		 push	 ecx
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  00009	c3		 ret	 0
??1Finally1624@?BC@??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@XZ ENDP ; `MoveClustersBeforeThresholdInDir'::`18'::Finally1624::~Finally1624
_TEXT	ENDS
PUBLIC	?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size, COMDAT
; _this$ = ecx

; 1666 : 		return (_Mysize);

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 1667 : 		}

  00003	c3		 ret	 0
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEPA_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Myptr
; Function compile flags: /Ogtpy
;	COMDAT ?_Myptr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEPA_WXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEPA_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 2170 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  00000	83 79 18 08	 cmp	 DWORD PTR [ecx+24], 8
  00004	72 04		 jb	 SHORT $LN3@Myptr
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 2171 : 		}

  00009	c3		 ret	 0
$LN3@Myptr:

; 2170 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  0000a	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 2171 : 		}

  0000d	c3		 ret	 0
?_Myptr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEPA_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Myptr
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Myptr
; Function compile flags: /Ogtpy
;	COMDAT ?_Myptr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IBEPB_WXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IBEPB_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 2175 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  00000	83 79 18 08	 cmp	 DWORD PTR [ecx+24], 8
  00004	72 04		 jb	 SHORT $LN3@Myptr@2
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 2176 : 		}

  00009	c3		 ret	 0
$LN3@Myptr@2:

; 2175 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  0000a	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 2176 : 		}

  0000d	c3		 ret	 0
?_Myptr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IBEPB_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Myptr
_TEXT	ENDS
PUBLIC	??0?$allocator@_W@std@@QAE@XZ			; std::allocator<wchar_t>::allocator<wchar_t>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@_W@std@@QAE@XZ PROC			; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

  00002	c3		 ret	 0
??0?$allocator@_W@std@@QAE@XZ ENDP			; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
PUBLIC	?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos, COMDAT
; _this$ = ecx

; 2114 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Newsize$[esp-4]
  00004	33 d2		 xor	 edx, edx
  00006	83 79 18 08	 cmp	 DWORD PTR [ecx+24], 8
  0000a	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  0000d	72 0a		 jb	 SHORT $LN5@Eos
  0000f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00012	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 2115 : 		}

  00016	c2 04 00	 ret	 4

; 2114 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

$LN5@Eos:
  00019	66 89 54 41 04	 mov	 WORD PTR [ecx+eax*2+4], dx

; 2115 : 		}

  0001e	c2 04 00	 ret	 4
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
_TEXT	ENDS
PUBLIC	??0?$allocator@_W@std@@QAE@ABV01@@Z		; std::allocator<wchar_t>::allocator<wchar_t>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@_W@std@@QAE@ABV01@@Z PROC		; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@_W@std@@QAE@ABV01@@Z ENDP		; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z	; std::allocator<wchar_t>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z PROC	; std::allocator<wchar_t>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 141  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ENDP	; std::allocator<wchar_t>::deallocate
_TEXT	ENDS
PUBLIC	?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAE_NPB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAE_NPB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside, COMDAT
; _this$ = ecx

; 2133 : 		{	// test if _Ptr points inside string

  00000	56		 push	 esi
  00001	57		 push	 edi

; 2134 : 		if (_Ptr == 0 || _Ptr < _Myptr() || _Myptr() + _Mysize <= _Ptr)

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR __Ptr$[esp+4]
  00006	85 ff		 test	 edi, edi
  00008	74 2d		 je	 SHORT $LN2@Inside
  0000a	8b 71 18	 mov	 esi, DWORD PTR [ecx+24]
  0000d	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00010	83 fe 08	 cmp	 esi, 8
  00013	72 04		 jb	 SHORT $LN8@Inside
  00015	8b 10		 mov	 edx, DWORD PTR [eax]
  00017	eb 02		 jmp	 SHORT $LN9@Inside
$LN8@Inside:
  00019	8b d0		 mov	 edx, eax
$LN9@Inside:
  0001b	3b fa		 cmp	 edi, edx
  0001d	72 18		 jb	 SHORT $LN2@Inside
  0001f	83 fe 08	 cmp	 esi, 8
  00022	72 02		 jb	 SHORT $LN12@Inside
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
$LN12@Inside:
  00026	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00029	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  0002c	3b d7		 cmp	 edx, edi
  0002e	76 07		 jbe	 SHORT $LN2@Inside
  00030	5f		 pop	 edi

; 2136 : 		else
; 2137 : 			return (true);

  00031	b0 01		 mov	 al, 1
  00033	5e		 pop	 esi

; 2138 : 		}

  00034	c2 04 00	 ret	 4
$LN2@Inside:
  00037	5f		 pop	 edi

; 2135 : 			return (false);	// don't ask

  00038	32 c0		 xor	 al, al
  0003a	5e		 pop	 esi

; 2138 : 		}

  0003b	c2 04 00	 ret	 4
?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAE_NPB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@_W@std@@QBEIXZ		; std::allocator<wchar_t>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@_W@std@@QBEIXZ PROC		; std::allocator<wchar_t>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 167  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@_W@std@@QBEIXZ ENDP		; std::allocator<wchar_t>::max_size
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@_W@std@@YAPA_WIPA_W@Z		; std::_Allocate<wchar_t>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT
$T123143 = -12						; size = 12
$T123148 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@_W@std@@YAPA_WIPA_W@Z PROC			; std::_Allocate<wchar_t>, COMDAT

; 37   : 	if (_Count <= 0)

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00007	85 c9		 test	 ecx, ecx
  00009	77 12		 ja	 SHORT $LN3@Allocate

; 38   : 		_Count = 0;

  0000b	33 c9		 xor	 ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

  0000d	8d 14 09	 lea	 edx, DWORD PTR [ecx+ecx]
  00010	52		 push	 edx
  00011	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00016	83 c4 04	 add	 esp, 4

; 44   : 	}

  00019	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001c	c3		 ret	 0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

  0001d	83 c8 ff	 or	 eax, -1
  00020	33 d2		 xor	 edx, edx
  00022	f7 f1		 div	 ecx
  00024	83 f8 02	 cmp	 eax, 2
  00027	73 e4		 jae	 SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

  00029	8d 44 24 10	 lea	 eax, DWORD PTR $T123148[esp+8]
  0002d	50		 push	 eax
  0002e	8d 4c 24 04	 lea	 ecx, DWORD PTR $T123143[esp+16]
  00032	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR $T123148[esp+12], 0
  0003a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003f	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00044	8d 4c 24 04	 lea	 ecx, DWORD PTR $T123143[esp+16]
  00048	51		 push	 ecx
  00049	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR $T123143[esp+20], OFFSET ??_7bad_alloc@std@@6B@
  00051	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN8@Allocate:
  00056	cc		 int	 3
??$_Allocate@_W@std@@YAPA_WIPA_W@Z ENDP			; std::_Allocate<wchar_t>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___that$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::compare
EXTRN	?_Xran@_String_base@std@@SAXXZ:PROC		; std::_String_base::_Xran
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__N0$ = 12						; size = 4
__Ptr$ = 16						; size = 4
__Count$ = 20						; size = 4
?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::compare, COMDAT
; _this$ = ecx

; 2038 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)

  00000	53		 push	 ebx
  00001	55		 push	 ebp

; 2039 : 
; 2040 :  #if _HAS_ITERATOR_DEBUGGING
; 2041 : 		if (_Count != 0)
; 2042 : 			_DEBUG_POINTER(_Ptr);
; 2043 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2044 : 
; 2045 : 		if (_Mysize < _Off)

  00002	8b 6c 24 0c	 mov	 ebp, DWORD PTR __Off$[esp+4]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	39 6f 14	 cmp	 DWORD PTR [edi+20], ebp
  0000d	73 05		 jae	 SHORT $LN2@compare

; 2046 : 			_String_base::_Xran();	// _Off off end

  0000f	e8 00 00 00 00	 call	 ?_Xran@_String_base@std@@SAXXZ ; std::_String_base::_Xran
$LN2@compare:

; 2047 : 		if (_Mysize - _Off < _N0)

  00014	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00017	8b 74 24 18	 mov	 esi, DWORD PTR __N0$[esp+12]
  0001b	2b c5		 sub	 eax, ebp
  0001d	3b c6		 cmp	 eax, esi
  0001f	73 02		 jae	 SHORT $LN1@compare

; 2048 : 			_N0 = _Mysize - _Off;	// trim _N0 to size

  00021	8b f0		 mov	 esi, eax
$LN1@compare:

; 2049 : 
; 2050 : 		size_type _Ans = _Traits::compare(_Myptr() + _Off, _Ptr,
; 2051 : 			_N0 < _Count ? _N0 : _Count);

  00023	8b 5c 24 20	 mov	 ebx, DWORD PTR __Count$[esp+12]
  00027	8b c6		 mov	 eax, esi
  00029	3b f3		 cmp	 esi, ebx
  0002b	72 02		 jb	 SHORT $LN6@compare
  0002d	8b c3		 mov	 eax, ebx
$LN6@compare:
  0002f	83 7f 18 08	 cmp	 DWORD PTR [edi+24], 8
  00033	72 05		 jb	 SHORT $LN13@compare
  00035	8b 7f 04	 mov	 edi, DWORD PTR [edi+4]
  00038	eb 03		 jmp	 SHORT $LN14@compare
$LN13@compare:
  0003a	83 c7 04	 add	 edi, 4
$LN14@compare:
  0003d	50		 push	 eax
  0003e	8b 44 24 20	 mov	 eax, DWORD PTR __Ptr$[esp+16]
  00042	50		 push	 eax
  00043	8d 0c 6f	 lea	 ecx, DWORD PTR [edi+ebp*2]
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 _wmemcmp
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2052 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2053 : 			: _N0 == _Count ? 0 : +1);

  0004f	85 c0		 test	 eax, eax
  00051	75 15		 jne	 SHORT $LN8@compare
  00053	3b f3		 cmp	 esi, ebx
  00055	73 0a		 jae	 SHORT $LN7@compare
  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5d		 pop	 ebp
  0005a	83 c8 ff	 or	 eax, -1
  0005d	5b		 pop	 ebx

; 2054 : 		}

  0005e	c2 10 00	 ret	 16			; 00000010H
$LN7@compare:

; 2052 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2053 : 			: _N0 == _Count ? 0 : +1);

  00061	33 c0		 xor	 eax, eax
  00063	3b f3		 cmp	 esi, ebx
  00065	0f 95 c0	 setne	 al
$LN8@compare:
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5d		 pop	 ebp
  0006b	5b		 pop	 ebx

; 2054 : 		}

  0006c	c2 10 00	 ret	 16			; 00000010H
?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::compare
_TEXT	ENDS
PUBLIC	??0?$_String_val@_WV?$allocator@_W@std@@@std@@QAE@ABV01@@Z ; std::_String_val<wchar_t,std::allocator<wchar_t> >::_String_val<wchar_t,std::allocator<wchar_t> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_String_val@_WV?$allocator@_W@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_String_val@_WV?$allocator@_W@std@@@std@@QAE@ABV01@@Z PROC ; std::_String_val<wchar_t,std::allocator<wchar_t> >::_String_val<wchar_t,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 478  : 		{	// copy constructor

  00000	8b c1		 mov	 eax, ecx

; 479  : #if defined(_DEBUG)
; 480  : 		if (_Right._Myfirstiter == _IGNORE_MYITERLIST)
; 481  : 			{
; 482  : 			this->_Myfirstiter = _IGNORE_MYITERLIST;
; 483  : 			}
; 484  : #endif
; 485  : 		}

  00002	c2 04 00	 ret	 4
??0?$_String_val@_WV?$allocator@_W@std@@@std@@QAE@ABV01@@Z ENDP ; std::_String_val<wchar_t,std::allocator<wchar_t> >::_String_val<wchar_t,std::allocator<wchar_t> >
_TEXT	ENDS
PUBLIC	??$_Char_traits_cat@U?$char_traits@_W@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ ; std::_Char_traits_cat<std::char_traits<wchar_t> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\iosfwd
;	COMDAT ??$_Char_traits_cat@U?$char_traits@_W@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ
_TEXT	SEGMENT
__Secure$ = -1						; size = 1
??$_Char_traits_cat@U?$char_traits@_W@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ PROC ; std::_Char_traits_cat<std::char_traits<wchar_t> >, COMDAT

; 575  : 	{

  00000	51		 push	 ecx

; 576  : 		typename _Char_traits_category<_Traits>::_Secure_char_traits _Secure;
; 577  : 		return (_Secure);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Secure$[esp+4]

; 578  : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Char_traits_cat@U?$char_traits@_W@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ ENDP ; std::_Char_traits_cat<std::char_traits<wchar_t> >
_TEXT	ENDS
PUBLIC	??$copy_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WIU_Secure_char_traits_tag@1@@Z ; std::_Traits_helper::copy_s<std::char_traits<wchar_t> >
; Function compile flags: /Ogtpy
;	COMDAT ??$copy_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WIU_Secure_char_traits_tag@1@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
___formal$ = 24						; size = 1
??$copy_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WIU_Secure_char_traits_tag@1@@Z PROC ; std::_Traits_helper::copy_s<std::char_traits<wchar_t> >, COMDAT

; 597  : 		return _Traits::_Copy_s(_First1, _Size, _First2, _Count);

  00000	8b 44 24 10	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8b 54 24 0c	 mov	 edx, DWORD PTR __First2$[esp-4]
  00008	56		 push	 esi
  00009	8b 74 24 08	 mov	 esi, DWORD PTR __First1$[esp]
  0000d	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00010	8b 44 24 0c	 mov	 eax, DWORD PTR __Size$[esp]
  00014	51		 push	 ecx
  00015	52		 push	 edx
  00016	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00019	51		 push	 ecx
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 _memcpy_s
  00020	83 c4 10	 add	 esp, 16			; 00000010H
  00023	8b c6		 mov	 eax, esi
  00025	5e		 pop	 esi

; 598  : 	}

  00026	c3		 ret	 0
??$copy_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WIU_Secure_char_traits_tag@1@@Z ENDP ; std::_Traits_helper::copy_s<std::char_traits<wchar_t> >
_TEXT	ENDS
PUBLIC	??$move_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WIU_Secure_char_traits_tag@1@@Z ; std::_Traits_helper::move_s<std::char_traits<wchar_t> >
; Function compile flags: /Ogtpy
;	COMDAT ??$move_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WIU_Secure_char_traits_tag@1@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
___formal$ = 24						; size = 1
??$move_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WIU_Secure_char_traits_tag@1@@Z PROC ; std::_Traits_helper::move_s<std::char_traits<wchar_t> >, COMDAT

; 624  : 		return _Traits::_Move_s(_First1, _Size, _First2, _Count);

  00000	8b 44 24 10	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8b 54 24 0c	 mov	 edx, DWORD PTR __First2$[esp-4]
  00008	56		 push	 esi
  00009	8b 74 24 08	 mov	 esi, DWORD PTR __First1$[esp]
  0000d	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00010	8b 44 24 0c	 mov	 eax, DWORD PTR __Size$[esp]
  00014	51		 push	 ecx
  00015	52		 push	 edx
  00016	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00019	51		 push	 ecx
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 _memmove_s
  00020	83 c4 10	 add	 esp, 16			; 00000010H
  00023	8b c6		 mov	 eax, esi
  00025	5e		 pop	 esi

; 625  : 	}

  00026	c3		 ret	 0
??$move_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WIU_Secure_char_traits_tag@1@@Z ENDP ; std::_Traits_helper::move_s<std::char_traits<wchar_t> >
_TEXT	ENDS
PUBLIC	??_C@_0BK@KFDNCGEE@DEVICE_IN_USE_INPLACE_ENC?$AA@ ; `string'
PUBLIC	??_C@_0CL@CAPGNNOA@INPLACE_ENC_CANT_ACCESS_OR_GET_I@ ; `string'
PUBLIC	??_C@_0CP@BEBKAKBO@INPLACE_ENC_CANT_ACCESS_OR_GET_I@ ; `string'
EXTRN	_AskWarnNoYes:PROC
EXTRN	_Error:PROC
EXTRN	__imp__CreateFileA@28:PROC
;	COMDAT ??_C@_0BK@KFDNCGEE@DEVICE_IN_USE_INPLACE_ENC?$AA@
; File c:\home\public\desktop\projects\ciphershed.build\src\format\inplace.c
CONST	SEGMENT
??_C@_0BK@KFDNCGEE@DEVICE_IN_USE_INPLACE_ENC?$AA@ DB 'DEVICE_IN_USE_INPLA'
	DB	'CE_ENC', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@CAPGNNOA@INPLACE_ENC_CANT_ACCESS_OR_GET_I@
CONST	SEGMENT
??_C@_0CL@CAPGNNOA@INPLACE_ENC_CANT_ACCESS_OR_GET_I@ DB 'INPLACE_ENC_CANT'
	DB	'_ACCESS_OR_GET_INFO_ON_VOL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@BEBKAKBO@INPLACE_ENC_CANT_ACCESS_OR_GET_I@
CONST	SEGMENT
??_C@_0CP@BEBKAKBO@INPLACE_ENC_CANT_ACCESS_OR_GET_I@ DB 'INPLACE_ENC_CANT'
	DB	'_ACCESS_OR_GET_INFO_ON_VOL_ALT', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _OpenPartitionVolume
_TEXT	SEGMENT
_bExclusiveRequired$ = 8				; size = 4
_bSharedRequired$ = 12					; size = 4
_bSharedRequiresConfirmation$ = 16			; size = 4
_bShowAlternativeSteps$ = 20				; size = 4
_bSilent$ = 24						; size = 4
_OpenPartitionVolume PROC				; COMDAT
; _devName$ = ebx

; 1186 : {

  00000	55		 push	 ebp

; 1187 : 	HANDLE dev = INVALID_HANDLE_VALUE;
; 1188 : 	int retryCount = 0;
; 1189 : 
; 1190 : 	if (bExclusiveRequired)
; 1191 : 		bSharedRequired = FALSE;
; 1192 : 
; 1193 : 	if (bExclusiveRequired || !bSharedRequired)

  00001	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__CreateFileA@28
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	83 ce ff	 or	 esi, -1
  0000e	39 7c 24 10	 cmp	 DWORD PTR _bExclusiveRequired$[esp+8], edi
  00012	75 0c		 jne	 SHORT $LL14@OpenPartit
  00014	39 7c 24 14	 cmp	 DWORD PTR _bSharedRequired$[esp+8], edi
  00018	0f 85 8d 00 00
	00		 jne	 $LN10@OpenPartit
  0001e	8b ff		 npad	 2
$LL14@OpenPartit:

; 1194 : 	{
; 1195 : 		// Exclusive access
; 1196 : 		// Note that when exclusive access is denied, it is worth retrying (usually succeeds after a few tries).
; 1197 : 		while (dev == INVALID_HANDLE_VALUE && retryCount++ < EXCL_ACCESS_MAX_AUTO_RETRIES)

  00020	8b c7		 mov	 eax, edi
  00022	47		 inc	 edi
  00023	3d f4 01 00 00	 cmp	 eax, 500		; 000001f4H
  00028	7d 2f		 jge	 SHORT $LN13@OpenPartit

; 1198 : 		{
; 1199 : 			dev = CreateFile (devName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_WRITE_THROUGH, NULL);

  0002a	6a 00		 push	 0
  0002c	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00031	6a 03		 push	 3
  00033	6a 00		 push	 0
  00035	6a 00		 push	 0
  00037	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  0003c	53		 push	 ebx
  0003d	ff d5		 call	 ebp

; 1200 : 
; 1201 : 			if (retryCount > 1)

  0003f	83 ff 01	 cmp	 edi, 1
  00042	8b f0		 mov	 esi, eax
  00044	7e 08		 jle	 SHORT $LN12@OpenPartit

; 1202 : 				Sleep (EXCL_ACCESS_AUTO_RETRY_DELAY);

  00046	6a 0a		 push	 10			; 0000000aH
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
$LN12@OpenPartit:

; 1194 : 	{
; 1195 : 		// Exclusive access
; 1196 : 		// Note that when exclusive access is denied, it is worth retrying (usually succeeds after a few tries).
; 1197 : 		while (dev == INVALID_HANDLE_VALUE && retryCount++ < EXCL_ACCESS_MAX_AUTO_RETRIES)

  0004e	83 fe ff	 cmp	 esi, -1
  00051	74 cd		 je	 SHORT $LL14@OpenPartit
$LN4@OpenPartit:
  00053	5f		 pop	 edi

; 1242 : 				else
; 1243 : 					Error ("INPLACE_ENC_CANT_ACCESS_OR_GET_INFO_ON_VOL");
; 1244 : 			}
; 1245 : 			return INVALID_HANDLE_VALUE;
; 1246 : 		}
; 1247 : 	}
; 1248 : 
; 1249 : 	return dev;

  00054	8b c6		 mov	 eax, esi
  00056	5e		 pop	 esi
  00057	5d		 pop	 ebp

; 1250 : }

  00058	c3		 ret	 0
$LN13@OpenPartit:

; 1203 : 		}
; 1204 : 	}
; 1205 : 
; 1206 : 	if (dev == INVALID_HANDLE_VALUE)

  00059	83 fe ff	 cmp	 esi, -1
  0005c	75 f5		 jne	 SHORT $LN4@OpenPartit

; 1207 : 	{
; 1208 : 		if (bExclusiveRequired)

  0005e	83 7c 24 10 00	 cmp	 DWORD PTR _bExclusiveRequired$[esp+8], 0
  00063	74 46		 je	 SHORT $LN10@OpenPartit

; 1209 : 		{
; 1210 : 			if (!bSilent)

  00065	83 7c 24 20 00	 cmp	 DWORD PTR _bSilent$[esp+8], 0
  0006a	75 38		 jne	 SHORT $LN7@OpenPartit

; 1211 : 			{
; 1212 : 				handleWin32Error (MainDlg);

  0006c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _MainDlg
  00072	51		 push	 ecx
  00073	e8 00 00 00 00	 call	 _handleWin32Error
  00078	83 c4 04	 add	 esp, 4

; 1213 : 
; 1214 : 				if (bShowAlternativeSteps)

  0007b	83 7c 24 1c 00	 cmp	 DWORD PTR _bShowAlternativeSteps$[esp+8], 0
  00080	74 15		 je	 SHORT $LN8@OpenPartit

; 1215 : 					ShowInPlaceEncErrMsgWAltSteps ("INPLACE_ENC_CANT_ACCESS_OR_GET_INFO_ON_VOL_ALT", TRUE);

  00082	6a 01		 push	 1
  00084	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@BEBKAKBO@INPLACE_ENC_CANT_ACCESS_OR_GET_I@
  00089	e8 00 00 00 00	 call	 _ShowInPlaceEncErrMsgWAltSteps
  0008e	83 c4 08	 add	 esp, 8
  00091	5f		 pop	 edi

; 1218 : 			}
; 1219 : 			return INVALID_HANDLE_VALUE;

  00092	0b c6		 or	 eax, esi
  00094	5e		 pop	 esi
  00095	5d		 pop	 ebp

; 1250 : }

  00096	c3		 ret	 0
$LN8@OpenPartit:

; 1216 : 				else
; 1217 : 					Error ("INPLACE_ENC_CANT_ACCESS_OR_GET_INFO_ON_VOL");

  00097	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@CAPGNNOA@INPLACE_ENC_CANT_ACCESS_OR_GET_I@
  0009c	e8 00 00 00 00	 call	 _Error
  000a1	83 c4 04	 add	 esp, 4
$LN7@OpenPartit:
  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi

; 1218 : 			}
; 1219 : 			return INVALID_HANDLE_VALUE;

  000a6	83 c8 ff	 or	 eax, -1
  000a9	5d		 pop	 ebp

; 1250 : }

  000aa	c3		 ret	 0
$LN10@OpenPartit:

; 1220 : 		}
; 1221 : 
; 1222 : 		// Shared mode
; 1223 : 		dev = CreateFile (devName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_WRITE_THROUGH, NULL);

  000ab	6a 00		 push	 0
  000ad	68 00 00 00 80	 push	 -2147483648		; 80000000H
  000b2	6a 03		 push	 3
  000b4	6a 00		 push	 0
  000b6	6a 03		 push	 3
  000b8	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  000bd	53		 push	 ebx
  000be	ff d5		 call	 ebp
  000c0	8b f0		 mov	 esi, eax

; 1224 : 		if (dev != INVALID_HANDLE_VALUE)

  000c2	83 fe ff	 cmp	 esi, -1
  000c5	74 36		 je	 SHORT $LN6@OpenPartit

; 1225 : 		{
; 1226 : 			if (bSharedRequiresConfirmation 
; 1227 : 				&& !bSilent
; 1228 : 				&& AskWarnNoYes ("DEVICE_IN_USE_INPLACE_ENC") == IDNO)

  000c7	83 7c 24 18 00	 cmp	 DWORD PTR _bSharedRequiresConfirmation$[esp+8], 0
  000cc	74 85		 je	 SHORT $LN4@OpenPartit
  000ce	83 7c 24 20 00	 cmp	 DWORD PTR _bSilent$[esp+8], 0
  000d3	0f 85 7a ff ff
	ff		 jne	 $LN4@OpenPartit
  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@KFDNCGEE@DEVICE_IN_USE_INPLACE_ENC?$AA@
  000de	e8 00 00 00 00	 call	 _AskWarnNoYes
  000e3	83 c4 04	 add	 esp, 4
  000e6	83 f8 07	 cmp	 eax, 7
  000e9	0f 85 64 ff ff
	ff		 jne	 $LN4@OpenPartit

; 1229 : 			{
; 1230 : 				CloseHandle (dev);

  000ef	56		 push	 esi
  000f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  000f6	5f		 pop	 edi
  000f7	5e		 pop	 esi

; 1231 : 				return INVALID_HANDLE_VALUE;

  000f8	83 c8 ff	 or	 eax, -1
  000fb	5d		 pop	 ebp

; 1250 : }

  000fc	c3		 ret	 0
$LN6@OpenPartit:

; 1232 : 			}
; 1233 : 		}
; 1234 : 		else
; 1235 : 		{
; 1236 : 			if (!bSilent)

  000fd	83 7c 24 20 00	 cmp	 DWORD PTR _bSilent$[esp+8], 0
  00102	75 a0		 jne	 SHORT $LN7@OpenPartit

; 1237 : 			{
; 1238 : 				handleWin32Error (MainDlg);

  00104	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  0010a	52		 push	 edx
  0010b	e8 00 00 00 00	 call	 _handleWin32Error
  00110	83 c4 04	 add	 esp, 4

; 1239 : 
; 1240 : 				if (bShowAlternativeSteps)

  00113	83 7c 24 1c 00	 cmp	 DWORD PTR _bShowAlternativeSteps$[esp+8], 0
  00118	0f 84 79 ff ff
	ff		 je	 $LN8@OpenPartit

; 1241 : 					ShowInPlaceEncErrMsgWAltSteps ("INPLACE_ENC_CANT_ACCESS_OR_GET_INFO_ON_VOL_ALT", TRUE);

  0011e	6a 01		 push	 1
  00120	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@BEBKAKBO@INPLACE_ENC_CANT_ACCESS_OR_GET_I@
  00125	e8 00 00 00 00	 call	 _ShowInPlaceEncErrMsgWAltSteps
  0012a	83 c4 08	 add	 esp, 8
  0012d	5f		 pop	 edi
  0012e	5e		 pop	 esi
  0012f	83 c8 ff	 or	 eax, -1
  00132	5d		 pop	 ebp

; 1250 : }

  00133	c3		 ret	 0
_OpenPartitionVolume ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@LMIKKFBM@VOL_LOCK_FAILED_OFFER_FORCED_DIS@ ; `string'
PUBLIC	??_C@_0CK@OMIEFGPE@INPLACE_ENC_CANT_LOCK_OR_DISMOUN@ ; `string'
EXTRN	_AskWarnYesNo:PROC
EXTRN	_CloseVolumeExplorerWindows:PROC
;	COMDAT ??_C@_0CG@LMIKKFBM@VOL_LOCK_FAILED_OFFER_FORCED_DIS@
CONST	SEGMENT
??_C@_0CG@LMIKKFBM@VOL_LOCK_FAILED_OFFER_FORCED_DIS@ DB 'VOL_LOCK_FAILED_'
	DB	'OFFER_FORCED_DISMOUNT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@OMIEFGPE@INPLACE_ENC_CANT_LOCK_OR_DISMOUN@
CONST	SEGMENT
??_C@_0CK@OMIEFGPE@INPLACE_ENC_CANT_LOCK_OR_DISMOUN@ DB 'INPLACE_ENC_CANT'
	DB	'_LOCK_OR_DISMOUNT_FILESYS', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _DismountFileSystem
_TEXT	SEGMENT
_dwResult$ = -4						; size = 4
_bForcedAllowed$ = 8					; size = 4
_bForcedRequiresConfirmation$ = 12			; size = 4
_bSilent$ = 16						; size = 4
_DismountFileSystem PROC				; COMDAT
; _dev$ = esi
; _driveLetter$ = eax

; 1258 : {

  00000	51		 push	 ecx

; 1259 : 	int attempt;
; 1260 : 	BOOL bResult;
; 1261 : 	DWORD dwResult;
; 1262 : 
; 1263 : 	CloseVolumeExplorerWindows (MainDlg, driveLetter);

  00001	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _MainDlg
  00007	53		 push	 ebx
  00008	55		 push	 ebp
  00009	57		 push	 edi
  0000a	50		 push	 eax
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 _CloseVolumeExplorerWindows

; 1264 : 
; 1265 : 	attempt = UNMOUNT_MAX_AUTO_RETRIES * 10;
; 1266 : 
; 1267 : 	while (!(bResult = DeviceIoControl (dev, FSCTL_LOCK_VOLUME, NULL, 0, NULL, 0, &dwResult, NULL)) 
; 1268 : 		&& attempt > 0)

  00011	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__DeviceIoControl@32
  00017	83 c4 08	 add	 esp, 8
  0001a	6a 00		 push	 0
  0001c	8d 54 24 10	 lea	 edx, DWORD PTR _dwResult$[esp+20]
  00020	52		 push	 edx
  00021	6a 00		 push	 0
  00023	6a 00		 push	 0
  00025	6a 00		 push	 0
  00027	6a 00		 push	 0
  00029	68 18 00 09 00	 push	 589848			; 00090018H
  0002e	56		 push	 esi
  0002f	bb 2c 01 00 00	 mov	 ebx, 300		; 0000012cH
  00034	ff d7		 call	 edi
  00036	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__Sleep@4
  0003c	85 c0		 test	 eax, eax
  0003e	75 70		 jne	 SHORT $LN17@DismountFi
$LL10@DismountFi:
  00040	85 db		 test	 ebx, ebx
  00042	7e 22		 jle	 SHORT $LN9@DismountFi

; 1269 : 	{
; 1270 : 		Sleep (UNMOUNT_AUTO_RETRY_DELAY);

  00044	6a 32		 push	 50			; 00000032H
  00046	ff d5		 call	 ebp
  00048	6a 00		 push	 0
  0004a	8d 44 24 10	 lea	 eax, DWORD PTR _dwResult$[esp+20]
  0004e	50		 push	 eax
  0004f	6a 00		 push	 0
  00051	6a 00		 push	 0
  00053	6a 00		 push	 0
  00055	6a 00		 push	 0
  00057	68 18 00 09 00	 push	 589848			; 00090018H
  0005c	56		 push	 esi

; 1271 : 		attempt--;

  0005d	4b		 dec	 ebx
  0005e	ff d7		 call	 edi
  00060	85 c0		 test	 eax, eax
  00062	74 dc		 je	 SHORT $LL10@DismountFi

; 1272 : 	}
; 1273 : 
; 1274 : 	if (!bResult)

  00064	eb 4a		 jmp	 SHORT $LN17@DismountFi
$LN9@DismountFi:
  00066	85 c0		 test	 eax, eax
  00068	75 46		 jne	 SHORT $LN17@DismountFi

; 1275 : 	{
; 1276 : 		if (!bForcedAllowed)

  0006a	39 44 24 14	 cmp	 DWORD PTR _bForcedAllowed$[esp+12], eax
  0006e	75 20		 jne	 SHORT $LN7@DismountFi
$LN19@DismountFi:

; 1277 : 		{
; 1278 : 			if (!bSilent)

  00070	83 7c 24 1c 00	 cmp	 DWORD PTR _bSilent$[esp+12], 0
  00075	75 0f		 jne	 SHORT $LN6@DismountFi

; 1279 : 				ShowInPlaceEncErrMsgWAltSteps ("INPLACE_ENC_CANT_LOCK_OR_DISMOUNT_FILESYS", TRUE);

  00077	6a 01		 push	 1
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@OMIEFGPE@INPLACE_ENC_CANT_LOCK_OR_DISMOUN@
  0007e	e8 00 00 00 00	 call	 _ShowInPlaceEncErrMsgWAltSteps
  00083	83 c4 08	 add	 esp, 8
$LN6@DismountFi:
  00086	5f		 pop	 edi
  00087	5d		 pop	 ebp

; 1280 : 
; 1281 : 			return ERR_DONT_REPORT;

  00088	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  0008d	5b		 pop	 ebx

; 1312 : }

  0008e	59		 pop	 ecx
  0008f	c3		 ret	 0
$LN7@DismountFi:

; 1282 : 		}
; 1283 : 
; 1284 : 		if (bForcedRequiresConfirmation
; 1285 : 			&& !bSilent
; 1286 : 			&& AskWarnYesNo ("VOL_LOCK_FAILED_OFFER_FORCED_DISMOUNT") == IDNO)

  00090	83 7c 24 18 00	 cmp	 DWORD PTR _bForcedRequiresConfirmation$[esp+12], 0
  00095	74 19		 je	 SHORT $LN17@DismountFi
  00097	83 7c 24 1c 00	 cmp	 DWORD PTR _bSilent$[esp+12], 0
  0009c	75 12		 jne	 SHORT $LN17@DismountFi
  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@LMIKKFBM@VOL_LOCK_FAILED_OFFER_FORCED_DIS@
  000a3	e8 00 00 00 00	 call	 _AskWarnYesNo
  000a8	83 c4 04	 add	 esp, 4
  000ab	83 f8 07	 cmp	 eax, 7

; 1287 : 		{
; 1288 : 			return ERR_DONT_REPORT;

  000ae	74 d6		 je	 SHORT $LN6@DismountFi
$LN17@DismountFi:

; 1289 : 		}
; 1290 : 	}
; 1291 : 
; 1292 : 	// Dismount the volume
; 1293 : 
; 1294 : 	attempt = UNMOUNT_MAX_AUTO_RETRIES * 10;
; 1295 : 
; 1296 : 	while (!(bResult = DeviceIoControl (dev, FSCTL_DISMOUNT_VOLUME, NULL, 0, NULL, 0, &dwResult, NULL)) 
; 1297 : 		&& attempt > 0)

  000b0	6a 00		 push	 0
  000b2	8d 4c 24 10	 lea	 ecx, DWORD PTR _dwResult$[esp+20]
  000b6	51		 push	 ecx
  000b7	6a 00		 push	 0
  000b9	6a 00		 push	 0
  000bb	6a 00		 push	 0
  000bd	6a 00		 push	 0
  000bf	68 20 00 09 00	 push	 589856			; 00090020H
  000c4	56		 push	 esi
  000c5	bb 2c 01 00 00	 mov	 ebx, 300		; 0000012cH
  000ca	ff d7		 call	 edi
  000cc	85 c0		 test	 eax, eax
  000ce	75 33		 jne	 SHORT $LN2@DismountFi
$LL4@DismountFi:
  000d0	85 db		 test	 ebx, ebx
  000d2	7e 27		 jle	 SHORT $LN3@DismountFi

; 1298 : 	{
; 1299 : 		Sleep (UNMOUNT_AUTO_RETRY_DELAY);

  000d4	6a 32		 push	 50			; 00000032H
  000d6	ff d5		 call	 ebp
  000d8	6a 00		 push	 0
  000da	8d 54 24 10	 lea	 edx, DWORD PTR _dwResult$[esp+20]
  000de	52		 push	 edx
  000df	6a 00		 push	 0
  000e1	6a 00		 push	 0
  000e3	6a 00		 push	 0
  000e5	6a 00		 push	 0
  000e7	68 20 00 09 00	 push	 589856			; 00090020H
  000ec	56		 push	 esi

; 1300 : 		attempt--;

  000ed	4b		 dec	 ebx
  000ee	ff d7		 call	 edi
  000f0	85 c0		 test	 eax, eax
  000f2	74 dc		 je	 SHORT $LL4@DismountFi
  000f4	5f		 pop	 edi
  000f5	5d		 pop	 ebp

; 1309 : 	}
; 1310 : 
; 1311 : 	return ERR_SUCCESS; 

  000f6	33 c0		 xor	 eax, eax
  000f8	5b		 pop	 ebx

; 1312 : }

  000f9	59		 pop	 ecx
  000fa	c3		 ret	 0
$LN3@DismountFi:

; 1301 : 	}
; 1302 : 
; 1303 : 	if (!bResult)

  000fb	85 c0		 test	 eax, eax

; 1304 : 	{
; 1305 : 		if (!bSilent)
; 1306 : 			ShowInPlaceEncErrMsgWAltSteps ("INPLACE_ENC_CANT_LOCK_OR_DISMOUNT_FILESYS", TRUE);
; 1307 : 
; 1308 : 		return ERR_DONT_REPORT; 

  000fd	0f 84 6d ff ff
	ff		 je	 $LN19@DismountFi
$LN2@DismountFi:
  00103	5f		 pop	 edi
  00104	5d		 pop	 ebp

; 1309 : 	}
; 1310 : 
; 1311 : 	return ERR_SUCCESS; 

  00105	33 c0		 xor	 eax, eax
  00107	5b		 pop	 ebx

; 1312 : }

  00108	59		 pop	 ecx
  00109	c3		 ret	 0
_DismountFileSystem ENDP
_TEXT	ENDS
PUBLIC	??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator[]
EXTRN	__invalid_parameter_noinfo:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator[], COMDAT
; _this$ = ecx

; 1557 : 		{	// subscript mutable sequence

  00000	56		 push	 esi
  00001	57		 push	 edi

; 1558 : 
; 1559 :  #if _HAS_ITERATOR_DEBUGGING
; 1560 : 		// skip debug checks if the container is initizialed with _IGNORE_MYITERLIST
; 1561 : 		if (this->_Myfirstiter != _IGNORE_MYITERLIST)
; 1562 : 			{
; 1563 : 			if (_Mysize < _Off)
; 1564 : 				{
; 1565 : 				_DEBUG_ERROR("string subscript out of range");
; 1566 : 				_SCL_SECURE_OUT_OF_RANGE;
; 1567 : 				}
; 1568 : 			}
; 1569 :  #else
; 1570 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= _Mysize);

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR __Off$[esp+4]
  00006	8b f1		 mov	 esi, ecx
  00008	3b 7e 14	 cmp	 edi, DWORD PTR [esi+20]
  0000b	76 05		 jbe	 SHORT $LN1@operator
  0000d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1@operator:

; 1571 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1572 : 
; 1573 : 		return (_Myptr()[_Off]);

  00012	83 7e 18 08	 cmp	 DWORD PTR [esi+24], 8
  00016	72 0b		 jb	 SHORT $LN6@operator
  00018	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  0001b	8d 04 7e	 lea	 eax, DWORD PTR [esi+edi*2]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 1574 : 		}

  00020	c2 04 00	 ret	 4

; 1571 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1572 : 
; 1573 : 		return (_Myptr()[_Off]);

$LN6@operator:
  00023	8d 44 7e 04	 lea	 eax, DWORD PTR [esi+edi*2+4]
  00027	5f		 pop	 edi
  00028	5e		 pop	 esi

; 1574 : 		}

  00029	c2 04 00	 ret	 4
??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator[]
_TEXT	ENDS
PUBLIC	?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
; Function compile flags: /Ogtpy
;	COMDAT ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str, COMDAT
; _this$ = ecx

; 1651 : 		return (_Myptr());

  00000	83 79 18 08	 cmp	 DWORD PTR [ecx+24], 8
  00004	72 04		 jb	 SHORT $LN5@c_str
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1652 : 		}

  00009	c3		 ret	 0

; 1651 : 		return (_Myptr());

$LN5@c_str:
  0000a	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 1652 : 		}

  0000d	c3		 ret	 0
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
_TEXT	ENDS
PUBLIC	??0?$_String_val@_WV?$allocator@_W@std@@@std@@IAE@V?$allocator@_W@1@@Z ; std::_String_val<wchar_t,std::allocator<wchar_t> >::_String_val<wchar_t,std::allocator<wchar_t> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_String_val@_WV?$allocator@_W@std@@@std@@IAE@V?$allocator@_W@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_String_val@_WV?$allocator@_W@std@@@std@@IAE@V?$allocator@_W@1@@Z PROC ; std::_String_val<wchar_t,std::allocator<wchar_t> >::_String_val<wchar_t,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 472  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 473  : 		}

  00002	c2 04 00	 ret	 4
??0?$_String_val@_WV?$allocator@_W@std@@@std@@IAE@V?$allocator@_W@1@@Z ENDP ; std::_String_val<wchar_t,std::allocator<wchar_t> >::_String_val<wchar_t,std::allocator<wchar_t> >
_TEXT	ENDS
PUBLIC	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size, COMDAT
; _this$ = ecx

; 1671 : 		size_type _Num = _Mybase::_Alval.max_size();
; 1672 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH

; 1673 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@_W@std@@QAEPA_WI@Z	; std::allocator<wchar_t>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@_W@std@@QAEPA_WI@Z PROC		; std::allocator<wchar_t>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	6a 00		 push	 0
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z ; std::_Allocate<wchar_t>
  0000c	83 c4 08	 add	 esp, 8

; 146  : 		}

  0000f	c2 04 00	 ret	 4
?allocate@?$allocator@_W@std@@QAEPA_WI@Z ENDP		; std::allocator<wchar_t>::allocate
_TEXT	ENDS
PUBLIC	??$copy_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WI@Z ; std::_Traits_helper::copy_s<std::char_traits<wchar_t> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\iosfwd
;	COMDAT ??$copy_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
??$copy_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WI@Z PROC ; std::_Traits_helper::copy_s<std::char_traits<wchar_t> >, COMDAT

; 589  : 		return copy_s<_Traits>(_First1, _Size, _First2, _Count, _Char_traits_cat<_Traits>());

  00000	8b 44 24 10	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8b 54 24 0c	 mov	 edx, DWORD PTR __First2$[esp-4]
  00008	56		 push	 esi
  00009	8b 74 24 08	 mov	 esi, DWORD PTR __First1$[esp]
  0000d	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00010	8b 44 24 0c	 mov	 eax, DWORD PTR __Size$[esp]
  00014	51		 push	 ecx
  00015	52		 push	 edx
  00016	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00019	51		 push	 ecx
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 _memcpy_s
  00020	83 c4 10	 add	 esp, 16			; 00000010H
  00023	8b c6		 mov	 eax, esi
  00025	5e		 pop	 esi

; 590  : 	}

  00026	c3		 ret	 0
??$copy_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WI@Z ENDP ; std::_Traits_helper::copy_s<std::char_traits<wchar_t> >
_TEXT	ENDS
PUBLIC	??$move_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WI@Z ; std::_Traits_helper::move_s<std::char_traits<wchar_t> >
; Function compile flags: /Ogtpy
;	COMDAT ??$move_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
??$move_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WI@Z PROC ; std::_Traits_helper::move_s<std::char_traits<wchar_t> >, COMDAT

; 616  : 		return move_s<_Traits>(_First1, _Size, _First2, _Count, _Char_traits_cat<_Traits>());

  00000	8b 44 24 10	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8b 54 24 0c	 mov	 edx, DWORD PTR __First2$[esp-4]
  00008	56		 push	 esi
  00009	8b 74 24 08	 mov	 esi, DWORD PTR __First1$[esp]
  0000d	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00010	8b 44 24 0c	 mov	 eax, DWORD PTR __Size$[esp]
  00014	51		 push	 ecx
  00015	52		 push	 edx
  00016	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00019	51		 push	 ecx
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 _memmove_s
  00020	83 c4 10	 add	 esp, 16			; 00000010H
  00023	8b c6		 mov	 eax, esi
  00025	5e		 pop	 esi

; 617  : 	}

  00026	c3		 ret	 0
??$move_s@U?$char_traits@_W@std@@@_Traits_helper@std@@YAPA_WPA_WIPB_WI@Z ENDP ; std::_Traits_helper::move_s<std::char_traits<wchar_t> >
_TEXT	ENDS
PUBLIC	?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::compare
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::compare, COMDAT
; _this$ = ecx

; 2025 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)

  00000	56		 push	 esi

; 2026 : 		_DEBUG_POINTER(_Ptr);
; 2027 : 		return (compare(0, _Mysize, _Ptr, _Traits::length(_Ptr)));

  00001	8b 74 24 08	 mov	 esi, DWORD PTR __Ptr$[esp]
  00005	8b c6		 mov	 eax, esi
  00007	57		 push	 edi
  00008	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
  0000b	eb 03 8d 49 00	 npad	 5
$LL5@compare@2:
  00010	66 8b 10	 mov	 dx, WORD PTR [eax]
  00013	83 c0 02	 add	 eax, 2
  00016	66 85 d2	 test	 dx, dx
  00019	75 f5		 jne	 SHORT $LL5@compare@2
  0001b	2b c7		 sub	 eax, edi
  0001d	d1 f8		 sar	 eax, 1
  0001f	50		 push	 eax
  00020	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00023	56		 push	 esi
  00024	50		 push	 eax
  00025	6a 00		 push	 0
  00027	e8 00 00 00 00	 call	 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::compare
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi

; 2028 : 		}

  0002e	c2 04 00	 ret	 4
?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::compare
_TEXT	ENDS
PUBLIC	??_C@_0BI@FCILOPDD@SECTOR_SIZE_UNSUPPORTED?$AA@	; `string'
PUBLIC	??_C@_0CJ@DJNLKEPP@NOT_ENOUGH_FREE_FILESYS_SPACE_FO@ ; `string'
PUBLIC	??_C@_0CL@EKBFECDJ@PARTITION_TOO_SMALL_FOR_NONSYS_I@ ; `string'
PUBLIC	??_C@_0DC@BPGKKGKD@ONLY_MOUNTED_VOL_SUPPORTED_FOR_N@ ; `string'
PUBLIC	??_C@_0CL@COOAAIGJ@ONLY_NTFS_SUPPORTED_FOR_NONSYS_I@ ; `string'
PUBLIC	??_C@_04HPPAIJNK@NTFS?$AA@			; `string'
PUBLIC	??_C@_0BO@NAOLHLLP@ADMIN_PRIVILEGES_WARN_DEVICES?$AA@ ; `string'
PUBLIC	??_C@_0CG@BBECDHBI@RAW_DEV_NOT_SUPPORTED_FOR_INPLAC@ ; `string'
PUBLIC	??_C@_0BJ@KPKOCMJM@INPLACE_ENC_INVALID_PATH?$AA@ ; `string'
PUBLIC	??_C@_0BP@MDCLODBD@?2Device?2Harddisk?$CFd?2Partition?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BJ@IDFJMMLD@?2Device?2HarddiskVolume?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0CI@PMIJHGDI@OS_NOT_SUPPORTED_FOR_NONSYS_INPL@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_CheckRequirementsForNonSysInPlaceEnc
EXTRN	_GetDeviceSize:PROC
EXTRN	_IsDeviceMounted:PROC
EXTRN	_strncmp:PROC
EXTRN	__imp__GetVolumeInformationA@32:PROC
EXTRN	_FakeDosNameForDevice:PROC
EXTRN	_GetDiskDeviceDriveLetter:PROC
EXTRN	_ToUNICODE:PROC
EXTRN	_IsAdmin:PROC
EXTRN	_Warning:PROC
EXTRN	_sscanf:PROC
EXTRN	_CurrentOSMajor:DWORD
;	COMDAT ??_C@_0BI@FCILOPDD@SECTOR_SIZE_UNSUPPORTED?$AA@
; File c:\home\public\desktop\projects\ciphershed.build\src\format\inplace.c
CONST	SEGMENT
??_C@_0BI@FCILOPDD@SECTOR_SIZE_UNSUPPORTED?$AA@ DB 'SECTOR_SIZE_UNSUPPORT'
	DB	'ED', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@DJNLKEPP@NOT_ENOUGH_FREE_FILESYS_SPACE_FO@
CONST	SEGMENT
??_C@_0CJ@DJNLKEPP@NOT_ENOUGH_FREE_FILESYS_SPACE_FO@ DB 'NOT_ENOUGH_FREE_'
	DB	'FILESYS_SPACE_FOR_SHRINK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@EKBFECDJ@PARTITION_TOO_SMALL_FOR_NONSYS_I@
CONST	SEGMENT
??_C@_0CL@EKBFECDJ@PARTITION_TOO_SMALL_FOR_NONSYS_I@ DB 'PARTITION_TOO_SM'
	DB	'ALL_FOR_NONSYS_INPLACE_ENC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@BPGKKGKD@ONLY_MOUNTED_VOL_SUPPORTED_FOR_N@
CONST	SEGMENT
??_C@_0DC@BPGKKGKD@ONLY_MOUNTED_VOL_SUPPORTED_FOR_N@ DB 'ONLY_MOUNTED_VOL'
	DB	'_SUPPORTED_FOR_NONSYS_INPLACE_ENC', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@COOAAIGJ@ONLY_NTFS_SUPPORTED_FOR_NONSYS_I@
CONST	SEGMENT
??_C@_0CL@COOAAIGJ@ONLY_NTFS_SUPPORTED_FOR_NONSYS_I@ DB 'ONLY_NTFS_SUPPOR'
	DB	'TED_FOR_NONSYS_INPLACE_ENC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HPPAIJNK@NTFS?$AA@
CONST	SEGMENT
??_C@_04HPPAIJNK@NTFS?$AA@ DB 'NTFS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NAOLHLLP@ADMIN_PRIVILEGES_WARN_DEVICES?$AA@
CONST	SEGMENT
??_C@_0BO@NAOLHLLP@ADMIN_PRIVILEGES_WARN_DEVICES?$AA@ DB 'ADMIN_PRIVILEGE'
	DB	'S_WARN_DEVICES', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@BBECDHBI@RAW_DEV_NOT_SUPPORTED_FOR_INPLAC@
CONST	SEGMENT
??_C@_0CG@BBECDHBI@RAW_DEV_NOT_SUPPORTED_FOR_INPLAC@ DB 'RAW_DEV_NOT_SUPP'
	DB	'ORTED_FOR_INPLACE_ENC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KPKOCMJM@INPLACE_ENC_INVALID_PATH?$AA@
CONST	SEGMENT
??_C@_0BJ@KPKOCMJM@INPLACE_ENC_INVALID_PATH?$AA@ DB 'INPLACE_ENC_INVALID_'
	DB	'PATH', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MDCLODBD@?2Device?2Harddisk?$CFd?2Partition?$CFd?$AA@
CONST	SEGMENT
??_C@_0BP@MDCLODBD@?2Device?2Harddisk?$CFd?2Partition?$CFd?$AA@ DB '\Devi'
	DB	'ce\Harddisk%d\Partition%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IDFJMMLD@?2Device?2HarddiskVolume?$CFd?$AA@
CONST	SEGMENT
??_C@_0BJ@IDFJMMLD@?2Device?2HarddiskVolume?$CFd?$AA@ DB '\Device\Harddis'
	DB	'kVolume%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@PMIJHGDI@OS_NOT_SUPPORTED_FOR_NONSYS_INPL@
CONST	SEGMENT
??_C@_0CI@PMIJHGDI@OS_NOT_SUPPORTED_FOR_NONSYS_INPL@ DB 'OS_NOT_SUPPORTED'
	DB	'_FOR_NONSYS_INPLACE_ENC', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _CheckRequirementsForNonSysInPlaceEnc
_TEXT	SEGMENT
_szRootPath$ = -1412					; size = 4
_partitionNumber$ = -1408				; size = 4
_driveNumber$ = -1404					; size = 4
_nBytesReturned$ = -1400				; size = 4
_ntfsVolData$ = -1396					; size = 96
_devName$ = -1300					; size = 260
_dosDev$ = -1040					; size = 260
_szFileSysName$ = -780					; size = 256
_devPath$ = -524					; size = 520
__$ArrayPad$ = -4					; size = 4
_devicePath$ = 8					; size = 4
_silent$ = 12						; size = 4
_CheckRequirementsForNonSysInPlaceEnc PROC		; COMDAT

; 91   : {

  00000	81 ec 84 05 00
	00		 sub	 esp, 1412		; 00000584H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 80 05
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1412], eax
  00014	53		 push	 ebx
  00015	55		 push	 ebp
  00016	8b ac 24 90 05
	00 00		 mov	 ebp, DWORD PTR _devicePath$[esp+1416]

; 92   : 	NTFS_VOLUME_DATA_BUFFER ntfsVolData;
; 93   : 	DWORD nBytesReturned;
; 94   : 	HANDLE dev;
; 95   : 	char szFileSysName [256];
; 96   : 	WCHAR devPath [MAX_PATH];
; 97   : 	char dosDev [TC_MAX_PATH] = {0};

  0001d	33 db		 xor	 ebx, ebx
  0001f	68 03 01 00 00	 push	 259			; 00000103H
  00024	8d 84 24 81 01
	00 00		 lea	 eax, DWORD PTR _dosDev$[esp+1425]
  0002b	53		 push	 ebx
  0002c	50		 push	 eax
  0002d	88 9c 24 88 01
	00 00		 mov	 BYTE PTR _dosDev$[esp+1432], bl
  00034	e8 00 00 00 00	 call	 _memset

; 98   : 	char devName [MAX_PATH] = {0};

  00039	68 03 01 00 00	 push	 259			; 00000103H
  0003e	8d 8c 24 89 00
	00 00		 lea	 ecx, DWORD PTR _devName$[esp+1437]
  00045	53		 push	 ebx
  00046	51		 push	 ecx
  00047	88 9c 24 90 00
	00 00		 mov	 BYTE PTR _devName$[esp+1444], bl
  0004e	e8 00 00 00 00	 call	 _memset

; 99   : 	int driveLetterNo = -1;
; 100  : 	char szRootPath[4] = {0, ':', '\\', 0};
; 101  : 	__int64 deviceSize;
; 102  : 	int partitionNumber = -1, driveNumber = -1;

  00053	83 c8 ff	 or	 eax, -1
  00056	83 c4 18	 add	 esp, 24			; 00000018H

; 103  : 
; 104  : 
; 105  : 	/* ---------- Checks that do not require admin rights ----------- */
; 106  : 
; 107  : 
; 108  : 	/* Operating system */
; 109  : 
; 110  : 	if (CurrentOSMajor < 6)

  00059	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _CurrentOSMajor, 6
  00060	88 5c 24 08	 mov	 BYTE PTR _szRootPath$[esp+1420], bl
  00064	c6 44 24 09 3a	 mov	 BYTE PTR _szRootPath$[esp+1421], 58 ; 0000003aH
  00069	c6 44 24 0a 5c	 mov	 BYTE PTR _szRootPath$[esp+1422], 92 ; 0000005cH
  0006e	88 5c 24 0b	 mov	 BYTE PTR _szRootPath$[esp+1423], bl
  00072	89 44 24 0c	 mov	 DWORD PTR _partitionNumber$[esp+1420], eax
  00076	89 44 24 10	 mov	 DWORD PTR _driveNumber$[esp+1420], eax
  0007a	7d 30		 jge	 SHORT $LN30@CheckRequi

; 111  : 	{
; 112  : 		if (!silent)

  0007c	39 9c 24 94 05
	00 00		 cmp	 DWORD PTR _silent$[esp+1416], ebx
  00083	75 0e		 jne	 SHORT $LN29@CheckRequi

; 113  : 			ShowInPlaceEncErrMsgWAltSteps ("OS_NOT_SUPPORTED_FOR_NONSYS_INPLACE_ENC", FALSE);

  00085	53		 push	 ebx
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@PMIJHGDI@OS_NOT_SUPPORTED_FOR_NONSYS_INPL@
  0008b	e8 00 00 00 00	 call	 _ShowInPlaceEncErrMsgWAltSteps
  00090	83 c4 08	 add	 esp, 8
$LN29@CheckRequi:
  00093	5d		 pop	 ebp

; 114  : 
; 115  : 		return FALSE;

  00094	33 c0		 xor	 eax, eax
  00096	5b		 pop	 ebx

; 301  : }

  00097	8b 8c 24 80 05
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1412]
  0009e	33 cc		 xor	 ecx, esp
  000a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a5	81 c4 84 05 00
	00		 add	 esp, 1412		; 00000584H
  000ab	c3		 ret	 0
$LN30@CheckRequi:

; 116  : 	}
; 117  : 
; 118  : 
; 119  : 	/* Volume type (must be a partition or a dynamic volume) */
; 120  : 
; 121  : 	if (sscanf (devicePath, "\\Device\\HarddiskVolume%d", &partitionNumber) != 1
; 122  : 		&& sscanf (devicePath, "\\Device\\Harddisk%d\\Partition%d", &driveNumber, &partitionNumber) != 2)

  000ac	8d 54 24 0c	 lea	 edx, DWORD PTR _partitionNumber$[esp+1420]
  000b0	52		 push	 edx
  000b1	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@IDFJMMLD@?2Device?2HarddiskVolume?$CFd?$AA@
  000b6	55		 push	 ebp
  000b7	e8 00 00 00 00	 call	 _sscanf
  000bc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bf	83 f8 01	 cmp	 eax, 1
  000c2	74 4c		 je	 SHORT $LN28@CheckRequi
  000c4	8d 44 24 0c	 lea	 eax, DWORD PTR _partitionNumber$[esp+1420]
  000c8	50		 push	 eax
  000c9	8d 4c 24 14	 lea	 ecx, DWORD PTR _driveNumber$[esp+1424]
  000cd	51		 push	 ecx
  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@MDCLODBD@?2Device?2Harddisk?$CFd?2Partition?$CFd?$AA@
  000d3	55		 push	 ebp
  000d4	e8 00 00 00 00	 call	 _sscanf
  000d9	83 c4 10	 add	 esp, 16			; 00000010H
  000dc	83 f8 02	 cmp	 eax, 2
  000df	74 2f		 je	 SHORT $LN28@CheckRequi

; 123  : 	{
; 124  : 		if (!silent)

  000e1	39 9c 24 94 05
	00 00		 cmp	 DWORD PTR _silent$[esp+1416], ebx
  000e8	75 0d		 jne	 SHORT $LN27@CheckRequi

; 125  : 			Error ("INPLACE_ENC_INVALID_PATH");

  000ea	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@KPKOCMJM@INPLACE_ENC_INVALID_PATH?$AA@
  000ef	e8 00 00 00 00	 call	 _Error
  000f4	83 c4 04	 add	 esp, 4
$LN27@CheckRequi:
  000f7	5d		 pop	 ebp

; 126  : 
; 127  : 		return FALSE;

  000f8	33 c0		 xor	 eax, eax
  000fa	5b		 pop	 ebx

; 301  : }

  000fb	8b 8c 24 80 05
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1412]
  00102	33 cc		 xor	 ecx, esp
  00104	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00109	81 c4 84 05 00
	00		 add	 esp, 1412		; 00000584H
  0010f	c3		 ret	 0
$LN28@CheckRequi:

; 128  : 	}
; 129  : 
; 130  : 	if (partitionNumber == 0)

  00110	39 5c 24 0c	 cmp	 DWORD PTR _partitionNumber$[esp+1420], ebx
  00114	75 2f		 jne	 SHORT $LN26@CheckRequi

; 131  : 	{
; 132  : 		if (!silent)

  00116	39 9c 24 94 05
	00 00		 cmp	 DWORD PTR _silent$[esp+1416], ebx
  0011d	75 d8		 jne	 SHORT $LN27@CheckRequi

; 133  : 			Warning ("RAW_DEV_NOT_SUPPORTED_FOR_INPLACE_ENC");

  0011f	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@BBECDHBI@RAW_DEV_NOT_SUPPORTED_FOR_INPLAC@
  00124	e8 00 00 00 00	 call	 _Warning
  00129	83 c4 04	 add	 esp, 4
  0012c	5d		 pop	 ebp

; 134  : 
; 135  : 		return FALSE;

  0012d	33 c0		 xor	 eax, eax
  0012f	5b		 pop	 ebx

; 301  : }

  00130	8b 8c 24 80 05
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1412]
  00137	33 cc		 xor	 ecx, esp
  00139	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013e	81 c4 84 05 00
	00		 add	 esp, 1412		; 00000584H
  00144	c3		 ret	 0
$LN26@CheckRequi:
  00145	57		 push	 edi

; 136  : 	}
; 137  : 
; 138  : 
; 139  : 	/* Admin rights */
; 140  : 
; 141  : 	if (!IsAdmin())

  00146	e8 00 00 00 00	 call	 _IsAdmin

; 142  : 	{
; 143  : 		// We rely on the wizard process to call us only when the whole wizard process has been elevated (so UAC 
; 144  : 		// status can be ignored). In case the IsAdmin() detection somehow fails, we allow the user to continue.
; 145  : 
; 146  : 		if (!silent)

  0014b	8b bc 24 98 05
	00 00		 mov	 edi, DWORD PTR _silent$[esp+1420]
  00152	85 c0		 test	 eax, eax
  00154	75 11		 jne	 SHORT $LN23@CheckRequi
  00156	3b fb		 cmp	 edi, ebx
  00158	75 0d		 jne	 SHORT $LN23@CheckRequi

; 147  : 			Warning ("ADMIN_PRIVILEGES_WARN_DEVICES");

  0015a	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@NAOLHLLP@ADMIN_PRIVILEGES_WARN_DEVICES?$AA@
  0015f	e8 00 00 00 00	 call	 _Warning
  00164	83 c4 04	 add	 esp, 4
$LN23@CheckRequi:

; 148  : 	}
; 149  : 
; 150  : 
; 151  : 	/* ---------- Checks that may require admin rights ----------- */
; 152  : 
; 153  : 
; 154  : 	/* Access to the partition */
; 155  : 
; 156  : 	strcpy ((char *) devPath, devicePath);

  00167	8d 94 24 84 03
	00 00		 lea	 edx, DWORD PTR _devPath$[esp+1424]
  0016e	8b c5		 mov	 eax, ebp
  00170	2b d5		 sub	 edx, ebp
$LL33@CheckRequi:
  00172	8a 08		 mov	 cl, BYTE PTR [eax]
  00174	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00177	40		 inc	 eax
  00178	3a cb		 cmp	 cl, bl
  0017a	75 f6		 jne	 SHORT $LL33@CheckRequi

; 157  : 	ToUNICODE ((char *) devPath);

  0017c	8d 94 24 84 03
	00 00		 lea	 edx, DWORD PTR _devPath$[esp+1424]
  00183	52		 push	 edx
  00184	e8 00 00 00 00	 call	 _ToUNICODE

; 158  : 
; 159  : 	driveLetterNo = GetDiskDeviceDriveLetter (devPath);

  00189	8d 84 24 88 03
	00 00		 lea	 eax, DWORD PTR _devPath$[esp+1428]
  00190	50		 push	 eax
  00191	e8 00 00 00 00	 call	 _GetDiskDeviceDriveLetter
  00196	83 c4 08	 add	 esp, 8

; 160  : 
; 161  : 	if (driveLetterNo >= 0)

  00199	3b c3		 cmp	 eax, ebx
  0019b	7c 06		 jl	 SHORT $LN22@CheckRequi

; 162  : 		szRootPath[0] = (char) driveLetterNo + 'A';

  0019d	04 41		 add	 al, 65			; 00000041H
  0019f	88 44 24 0c	 mov	 BYTE PTR _szRootPath$[esp+1424], al
$LN22@CheckRequi:

; 163  : 
; 164  : 	if (FakeDosNameForDevice (devicePath, dosDev, devName, FALSE) != 0)

  001a3	53		 push	 ebx
  001a4	8d 8c 24 80 00
	00 00		 lea	 ecx, DWORD PTR _devName$[esp+1428]
  001ab	51		 push	 ecx
  001ac	8d 94 24 88 01
	00 00		 lea	 edx, DWORD PTR _dosDev$[esp+1432]
  001b3	52		 push	 edx
  001b4	55		 push	 ebp
  001b5	e8 00 00 00 00	 call	 _FakeDosNameForDevice
  001ba	83 c4 10	 add	 esp, 16			; 00000010H
  001bd	85 c0		 test	 eax, eax
  001bf	74 36		 je	 SHORT $LN21@CheckRequi

; 165  : 	{
; 166  : 		if (!silent)

  001c1	3b fb		 cmp	 edi, ebx
  001c3	75 18		 jne	 SHORT $LN20@CheckRequi

; 167  : 		{
; 168  : 			handleWin32Error (MainDlg);

  001c5	a1 00 00 00 00	 mov	 eax, DWORD PTR _MainDlg
  001ca	50		 push	 eax
  001cb	e8 00 00 00 00	 call	 _handleWin32Error

; 169  : 			Error ("INPLACE_ENC_CANT_ACCESS_OR_GET_INFO_ON_VOL");

  001d0	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@CAPGNNOA@INPLACE_ENC_CANT_ACCESS_OR_GET_I@
  001d5	e8 00 00 00 00	 call	 _Error
  001da	83 c4 08	 add	 esp, 8
$LN20@CheckRequi:
  001dd	5f		 pop	 edi
  001de	5d		 pop	 ebp

; 170  : 		}
; 171  : 		return FALSE;

  001df	33 c0		 xor	 eax, eax
  001e1	5b		 pop	 ebx

; 301  : }

  001e2	8b 8c 24 80 05
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1412]
  001e9	33 cc		 xor	 ecx, esp
  001eb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f0	81 c4 84 05 00
	00		 add	 esp, 1412		; 00000584H
  001f6	c3		 ret	 0
$LN21@CheckRequi:
  001f7	56		 push	 esi

; 172  : 	}
; 173  : 
; 174  : 	dev = OpenPartitionVolume (devName,
; 175  : 		FALSE,	// Do not require exclusive access
; 176  : 		TRUE,	// Require shared access (must be TRUE; otherwise, volume properties will not be possible to obtain)
; 177  : 		FALSE,	// Do not ask the user to confirm shared access (if exclusive fails)
; 178  : 		FALSE,	// Do not append alternative instructions how to encrypt the data (to applicable error messages)
; 179  : 		silent);	// Silent mode

  001f8	53		 push	 ebx
  001f9	68 00 00 00 80	 push	 -2147483648		; 80000000H
  001fe	6a 03		 push	 3
  00200	53		 push	 ebx
  00201	6a 03		 push	 3
  00203	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  00208	8d 8c 24 98 00
	00 00		 lea	 ecx, DWORD PTR _devName$[esp+1452]
  0020f	51		 push	 ecx
  00210	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00216	8b f0		 mov	 esi, eax
  00218	83 fe ff	 cmp	 esi, -1
  0021b	75 26		 jne	 SHORT $LN19@CheckRequi
  0021d	3b fb		 cmp	 edi, ebx
  0021f	0f 85 e6 01 00
	00		 jne	 $LN34@CheckRequi
  00225	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  0022b	52		 push	 edx
  0022c	e8 00 00 00 00	 call	 _handleWin32Error
  00231	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@CAPGNNOA@INPLACE_ENC_CANT_ACCESS_OR_GET_I@
  00236	e8 00 00 00 00	 call	 _Error
  0023b	83 c4 08	 add	 esp, 8

; 180  : 
; 181  : 	if (dev == INVALID_HANDLE_VALUE)
; 182  : 		return FALSE;

  0023e	e9 c8 01 00 00	 jmp	 $LN34@CheckRequi
$LN19@CheckRequi:

; 183  : 
; 184  : 
; 185  : 	/* File system type */
; 186  : 
; 187  : 	GetVolumeInformation (szRootPath, NULL, 0, NULL, NULL, NULL, szFileSysName, sizeof(szFileSysName));

  00243	68 00 01 00 00	 push	 256			; 00000100H
  00248	8d 84 24 8c 02
	00 00		 lea	 eax, DWORD PTR _szFileSysName$[esp+1432]
  0024f	50		 push	 eax
  00250	53		 push	 ebx
  00251	53		 push	 ebx
  00252	53		 push	 ebx
  00253	53		 push	 ebx
  00254	53		 push	 ebx
  00255	8d 4c 24 2c	 lea	 ecx, DWORD PTR _szRootPath$[esp+1456]
  00259	51		 push	 ecx
  0025a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVolumeInformationA@32

; 188  : 
; 189  : 	if (strncmp (szFileSysName, "NTFS", 4))

  00260	6a 04		 push	 4
  00262	8d 94 24 8c 02
	00 00		 lea	 edx, DWORD PTR _szFileSysName$[esp+1432]
  00269	68 00 00 00 00	 push	 OFFSET ??_C@_04HPPAIJNK@NTFS?$AA@
  0026e	52		 push	 edx
  0026f	e8 00 00 00 00	 call	 _strncmp
  00274	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__DeviceIoControl@32
  0027a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0027d	85 c0		 test	 eax, eax
  0027f	74 59		 je	 SHORT $LN17@CheckRequi

; 190  : 	{
; 191  : 		// The previous filesystem type detection method failed (or it's not NTFS) -- try an alternative method
; 192  : 
; 193  : 		if (!DeviceIoControl (dev,
; 194  : 			FSCTL_GET_NTFS_VOLUME_DATA,
; 195  : 			NULL,
; 196  : 			0,
; 197  : 			(LPVOID) &ntfsVolData,
; 198  : 			sizeof (ntfsVolData),   
; 199  : 			&nBytesReturned,
; 200  : 			NULL))

  00281	53		 push	 ebx
  00282	8d 44 24 20	 lea	 eax, DWORD PTR _nBytesReturned$[esp+1432]
  00286	50		 push	 eax
  00287	6a 60		 push	 96			; 00000060H
  00289	8d 4c 24 2c	 lea	 ecx, DWORD PTR _ntfsVolData$[esp+1440]
  0028d	51		 push	 ecx
  0028e	53		 push	 ebx
  0028f	53		 push	 ebx
  00290	68 64 00 09 00	 push	 589924			; 00090064H
  00295	56		 push	 esi
  00296	ff d7		 call	 edi
  00298	85 c0		 test	 eax, eax
  0029a	75 3e		 jne	 SHORT $LN17@CheckRequi

; 201  : 		{
; 202  : 			if (!silent)

  0029c	39 9c 24 9c 05
	00 00		 cmp	 DWORD PTR _silent$[esp+1424], ebx
  002a3	0f 85 5b 01 00
	00		 jne	 $LN1@CheckRequi

; 203  : 			{
; 204  : 				// The filesystem is not NTFS or the filesystem type could not be determined (or the NTFS filesystem
; 205  : 				// is dismounted).
; 206  : 
; 207  : 				if (IsDeviceMounted (devName))

  002a9	8d 94 24 80 00
	00 00		 lea	 edx, DWORD PTR _devName$[esp+1428]
  002b0	52		 push	 edx
  002b1	e8 00 00 00 00	 call	 _IsDeviceMounted
  002b6	83 c4 04	 add	 esp, 4
  002b9	85 c0		 test	 eax, eax
  002bb	74 0b		 je	 SHORT $LN15@CheckRequi

; 208  : 					ShowInPlaceEncErrMsgWAltSteps ("ONLY_NTFS_SUPPORTED_FOR_NONSYS_INPLACE_ENC", FALSE);

  002bd	53		 push	 ebx
  002be	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@COOAAIGJ@ONLY_NTFS_SUPPORTED_FOR_NONSYS_I@

; 209  : 				else

  002c3	e9 34 01 00 00	 jmp	 $LN63@CheckRequi
$LN15@CheckRequi:

; 210  : 					Warning ("ONLY_MOUNTED_VOL_SUPPORTED_FOR_NONSYS_INPLACE_ENC");

  002c8	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@BPGKKGKD@ONLY_MOUNTED_VOL_SUPPORTED_FOR_N@
  002cd	e8 00 00 00 00	 call	 _Warning
  002d2	83 c4 04	 add	 esp, 4

; 211  : 			}
; 212  : 
; 213  : 			CloseHandle (dev);
; 214  : 			return FALSE;

  002d5	e9 2a 01 00 00	 jmp	 $LN1@CheckRequi
$LN17@CheckRequi:

; 215  : 		}
; 216  : 	}
; 217  : 
; 218  : 
; 219  : 	/* Attempt to determine whether the filesystem can be safely shrunk */
; 220  : 
; 221  : 	if (NewFileSysSizeAfterShrink (dev, devicePath, NULL, NULL, silent) == -1)

  002da	8b 84 24 9c 05
	00 00		 mov	 eax, DWORD PTR _silent$[esp+1424]
  002e1	50		 push	 eax
  002e2	53		 push	 ebx
  002e3	33 db		 xor	 ebx, ebx
  002e5	8b d6		 mov	 edx, esi
  002e7	e8 00 00 00 00	 call	 ?NewFileSysSizeAfterShrink@@YA_JPAXPBDPA_JPAKH@Z ; NewFileSysSizeAfterShrink
  002ec	23 c2		 and	 eax, edx
  002ee	83 c4 08	 add	 esp, 8
  002f1	83 f8 ff	 cmp	 eax, -1
  002f4	75 19		 jne	 SHORT $LN13@CheckRequi

; 222  : 	{
; 223  : 		// Cannot determine whether shrinking is required
; 224  : 		if (!silent)

  002f6	39 9c 24 9c 05
	00 00		 cmp	 DWORD PTR _silent$[esp+1424], ebx
  002fd	0f 85 01 01 00
	00		 jne	 $LN1@CheckRequi

; 225  : 			ShowInPlaceEncErrMsgWAltSteps ("INPLACE_ENC_CANT_ACCESS_OR_GET_INFO_ON_VOL_ALT", TRUE);

  00303	6a 01		 push	 1
  00305	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@BEBKAKBO@INPLACE_ENC_CANT_ACCESS_OR_GET_I@

; 226  : 
; 227  : 		CloseHandle (dev);
; 228  : 		return FALSE;

  0030a	e9 ed 00 00 00	 jmp	 $LN63@CheckRequi
$LN13@CheckRequi:

; 229  : 	}
; 230  : 
; 231  : 
; 232  : 	/* Partition size */
; 233  : 
; 234  : 	deviceSize = GetDeviceSize (devicePath);

  0030f	55		 push	 ebp
  00310	e8 00 00 00 00	 call	 _GetDeviceSize
  00315	83 c4 04	 add	 esp, 4

; 235  : 	if (deviceSize < 0)

  00318	85 d2		 test	 edx, edx
  0031a	7f 4b		 jg	 SHORT $LN9@CheckRequi
  0031c	7c 04		 jl	 SHORT $LN57@CheckRequi
  0031e	85 c0		 test	 eax, eax
  00320	73 1f		 jae	 SHORT $LN11@CheckRequi
$LN57@CheckRequi:

; 236  : 	{
; 237  : 		// Cannot determine the size of the partition
; 238  : 		if (!silent)

  00322	39 9c 24 9c 05
	00 00		 cmp	 DWORD PTR _silent$[esp+1424], ebx
  00329	0f 85 d5 00 00
	00		 jne	 $LN1@CheckRequi

; 239  : 			Error ("INPLACE_ENC_CANT_ACCESS_OR_GET_INFO_ON_VOL");

  0032f	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@CAPGNNOA@INPLACE_ENC_CANT_ACCESS_OR_GET_I@
  00334	e8 00 00 00 00	 call	 _Error
  00339	83 c4 04	 add	 esp, 4

; 240  : 
; 241  : 		CloseHandle (dev);
; 242  : 		return FALSE;

  0033c	e9 c3 00 00 00	 jmp	 $LN1@CheckRequi
$LN11@CheckRequi:

; 243  : 	}
; 244  : 
; 245  : 	if (deviceSize < TC_NONSYS_INPLACE_ENC_MIN_VOL_SIZE)

  00341	85 d2		 test	 edx, edx
  00343	7f 22		 jg	 SHORT $LN9@CheckRequi
  00345	7c 07		 jl	 SHORT $LN58@CheckRequi
  00347	3d 00 80 72 00	 cmp	 eax, 7503872		; 00728000H
  0034c	73 19		 jae	 SHORT $LN9@CheckRequi
$LN58@CheckRequi:

; 246  : 	{
; 247  : 		// The partition is too small
; 248  : 		if (!silent)

  0034e	39 9c 24 9c 05
	00 00		 cmp	 DWORD PTR _silent$[esp+1424], ebx
  00355	0f 85 a9 00 00
	00		 jne	 $LN1@CheckRequi

; 249  : 		{
; 250  : 			ShowInPlaceEncErrMsgWAltSteps ("PARTITION_TOO_SMALL_FOR_NONSYS_INPLACE_ENC", FALSE);

  0035b	6a 00		 push	 0
  0035d	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@EKBFECDJ@PARTITION_TOO_SMALL_FOR_NONSYS_I@

; 251  : 		}
; 252  : 
; 253  : 		CloseHandle (dev);
; 254  : 		return FALSE;

  00362	e9 95 00 00 00	 jmp	 $LN63@CheckRequi
$LN9@CheckRequi:

; 255  : 	}
; 256  : 
; 257  : 
; 258  : 	/* Free space on the filesystem */
; 259  : 
; 260  : 	if (!DeviceIoControl (dev,
; 261  : 		FSCTL_GET_NTFS_VOLUME_DATA,
; 262  : 		NULL,
; 263  : 		0,
; 264  : 		(LPVOID) &ntfsVolData,
; 265  : 		sizeof (ntfsVolData),   
; 266  : 		&nBytesReturned,
; 267  : 		NULL))

  00367	6a 00		 push	 0
  00369	8d 4c 24 20	 lea	 ecx, DWORD PTR _nBytesReturned$[esp+1432]
  0036d	51		 push	 ecx
  0036e	6a 60		 push	 96			; 00000060H
  00370	8d 54 24 2c	 lea	 edx, DWORD PTR _ntfsVolData$[esp+1440]
  00374	52		 push	 edx
  00375	6a 00		 push	 0
  00377	6a 00		 push	 0
  00379	68 64 00 09 00	 push	 589924			; 00090064H
  0037e	56		 push	 esi
  0037f	ff d7		 call	 edi
  00381	85 c0		 test	 eax, eax
  00383	75 12		 jne	 SHORT $LN7@CheckRequi

; 268  : 	{
; 269  : 		if (!silent)

  00385	39 9c 24 9c 05
	00 00		 cmp	 DWORD PTR _silent$[esp+1424], ebx
  0038c	75 76		 jne	 SHORT $LN1@CheckRequi

; 270  : 			ShowInPlaceEncErrMsgWAltSteps ("INPLACE_ENC_CANT_ACCESS_OR_GET_INFO_ON_VOL", TRUE);

  0038e	6a 01		 push	 1
  00390	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@CAPGNNOA@INPLACE_ENC_CANT_ACCESS_OR_GET_I@

; 271  : 
; 272  : 		CloseHandle (dev);
; 273  : 		return FALSE;

  00395	eb 65		 jmp	 SHORT $LN63@CheckRequi
$LN7@CheckRequi:

; 274  : 	}
; 275  : 
; 276  : 	if (ntfsVolData.FreeClusters.QuadPart * ntfsVolData.BytesPerCluster < TC_TOTAL_VOLUME_HEADERS_SIZE)

  00397	8b 44 24 3c	 mov	 eax, DWORD PTR _ntfsVolData$[esp+1456]
  0039b	8b 4c 24 38	 mov	 ecx, DWORD PTR _ntfsVolData$[esp+1452]
  0039f	8b 54 24 4c	 mov	 edx, DWORD PTR _ntfsVolData$[esp+1472]
  003a3	50		 push	 eax
  003a4	51		 push	 ecx
  003a5	6a 00		 push	 0
  003a7	52		 push	 edx
  003a8	e8 00 00 00 00	 call	 __allmul
  003ad	85 d2		 test	 edx, edx
  003af	7f 1b		 jg	 SHORT $LN5@CheckRequi
  003b1	7c 07		 jl	 SHORT $LN59@CheckRequi
  003b3	3d 00 00 04 00	 cmp	 eax, 262144		; 00040000H
  003b8	73 12		 jae	 SHORT $LN5@CheckRequi
$LN59@CheckRequi:

; 277  : 	{
; 278  : 		if (!silent)

  003ba	39 9c 24 9c 05
	00 00		 cmp	 DWORD PTR _silent$[esp+1424], ebx
  003c1	75 41		 jne	 SHORT $LN1@CheckRequi

; 279  : 			ShowInPlaceEncErrMsgWAltSteps ("NOT_ENOUGH_FREE_FILESYS_SPACE_FOR_SHRINK", TRUE);

  003c3	6a 01		 push	 1
  003c5	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@DJNLKEPP@NOT_ENOUGH_FREE_FILESYS_SPACE_FO@

; 280  : 
; 281  : 		CloseHandle (dev);
; 282  : 		return FALSE;

  003ca	eb 30		 jmp	 SHORT $LN63@CheckRequi
$LN5@CheckRequi:

; 283  : 	}
; 284  : 
; 285  : 
; 286  : 	/* Filesystem sector size */
; 287  : 
; 288  : 	if (ntfsVolData.BytesPerSector > TC_MAX_VOLUME_SECTOR_SIZE
; 289  : 		|| ntfsVolData.BytesPerSector % ENCRYPTION_DATA_UNIT_SIZE != 0)

  003cc	8b 44 24 48	 mov	 eax, DWORD PTR _ntfsVolData$[esp+1468]
  003d0	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  003d5	77 15		 ja	 SHORT $LN2@CheckRequi
  003d7	a9 ff 01 00 00	 test	 eax, 511		; 000001ffH
  003dc	75 0e		 jne	 SHORT $LN2@CheckRequi

; 296  : 	}
; 297  : 
; 298  : 
; 299  : 	CloseHandle (dev);

  003de	56		 push	 esi
  003df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 300  : 	return TRUE;

  003e5	b8 01 00 00 00	 mov	 eax, 1
  003ea	eb 21		 jmp	 SHORT $LN62@CheckRequi
$LN2@CheckRequi:

; 290  : 	{
; 291  : 		if (!silent)

  003ec	39 9c 24 9c 05
	00 00		 cmp	 DWORD PTR _silent$[esp+1424], ebx
  003f3	75 0f		 jne	 SHORT $LN1@CheckRequi

; 292  : 			ShowInPlaceEncErrMsgWAltSteps ("SECTOR_SIZE_UNSUPPORTED", TRUE);

  003f5	6a 01		 push	 1
  003f7	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@FCILOPDD@SECTOR_SIZE_UNSUPPORTED?$AA@
$LN63@CheckRequi:
  003fc	e8 00 00 00 00	 call	 _ShowInPlaceEncErrMsgWAltSteps
  00401	83 c4 08	 add	 esp, 8
$LN1@CheckRequi:

; 293  : 
; 294  : 		CloseHandle (dev);

  00404	56		 push	 esi
  00405	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN34@CheckRequi:

; 295  : 		return FALSE;

  0040b	33 c0		 xor	 eax, eax
$LN62@CheckRequi:

; 301  : }

  0040d	8b 8c 24 90 05
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1428]
  00414	5e		 pop	 esi
  00415	5f		 pop	 edi
  00416	5d		 pop	 ebp
  00417	5b		 pop	 ebx
  00418	33 cc		 xor	 ecx, esp
  0041a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0041f	81 c4 84 05 00
	00		 add	 esp, 1412		; 00000584H
  00425	c3		 ret	 0
_CheckRequirementsForNonSysInPlaceEnc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@KOHPIJFG@ZEROED_BAD_SECTOR_COUNT?$AA@	; `string'
PUBLIC	??_C@_0BK@ELCHMCAJ@ENABLE_BAD_SECTOR_ZEROING?$AA@ ; `string'
PUBLIC	_dev$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_EncryptPartitionInPlaceResume
EXTRN	__imp__wsprintfW:PROC
EXTRN	_GetSizeString:PROC
EXTRN	_RemoveFakeDosName:PROC
EXTRN	_crypto_close:PROC
EXTRN	_WriteRandomDataToReservedHeaderAreas:PROC
EXTRN	_CreateVolumeHeaderInMemory:PROC
EXTRN	_DecryptDataUnits:PROC
EXTRN	_WipeBuffer:PROC
EXTRN	_GetWipePassCount:PROC
EXTRN	_EncryptDataUnits:PROC
EXTRN	_bVolTransformThreadCancel:DWORD
EXTRN	_IsDiskReadError:PROC
EXTRN	_bFirstNonSysInPlaceEncResumeDone:DWORD
EXTRN	_crypto_open:PROC
EXTRN	_bInPlaceEncNonSysResumed:DWORD
;	COMDAT ??_C@_0BI@KOHPIJFG@ZEROED_BAD_SECTOR_COUNT?$AA@
; File c:\program files\microsoft sdks\windows\v7.1\include\winnt.h
CONST	SEGMENT
??_C@_0BI@KOHPIJFG@ZEROED_BAD_SECTOR_COUNT?$AA@ DB 'ZEROED_BAD_SECTOR_COU'
	DB	'NT', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@ELCHMCAJ@ENABLE_BAD_SECTOR_ZEROING?$AA@
CONST	SEGMENT
??_C@_0BK@ELCHMCAJ@ENABLE_BAD_SECTOR_ZEROING?$AA@ DB 'ENABLE_BAD_SECTOR_Z'
	DB	'EROING', 00H				; `string'
; Function compile flags: /Ogtpy
; File c:\home\public\desktop\projects\ciphershed.build\src\format\inplace.c
CONST	ENDS
;	COMDAT _EncryptPartitionInPlaceResume
_TEXT	SEGMENT
_masterCryptoInfo$ = -62200				; size = 4
_wipePass$119831 = -62193				; size = 1
_dev$GSCopy$ = -62192					; size = 4
_headerCryptoInfo$ = -62188				; size = 4
_buf$ = -62184						; size = 4
_remainingBytes$ = -62180				; size = 8
_wipePass$119858 = -62172				; size = 4
_bPause$ = -62172					; size = 4
tv772 = -62168						; size = 4
_dwError$ = -62168					; size = 4
_dwTmpErr$119817 = -62168				; size = 4
_deviceSize$ = -62164					; size = 8
_wipeRandCharsUpdate$ = -62156				; size = 3
_header$ = -62152					; size = 4
_n$ = -62148						; size = 4
_lastHeaderUpdateDistance$ = -62144			; size = 8
_offset$ = -62136					; size = 8
_wipeBuffer$ = -62128					; size = 4
_tmpCryptoInfo$ = -62124				; size = 4
_wipeRandChars$ = -62120				; size = 3
_sectorSize$ = -62116					; size = 4
_unitNo$ = -62112					; size = 8
tv256 = -62104						; size = 4
_password$ = -62100					; size = 4
_bEncryptedAreaSizeChanged$ = -62096			; size = 4
tv744 = -62092						; size = 8
_zeroedSectorCount$ = -62084				; size = 8
_dwResult$ = -62076					; size = 4
_devicePath$ = -62072					; size = 4
_driveGeometry$ = -62068				; size = 24
_devName$ = -62044					; size = 260
_dosDev$ = -61784					; size = 260
_sizeStr$119898 = -61524				; size = 1000
_deviceName$ = -60524					; size = 520
_msg$119897 = -60004					; size = 60000
__$ArrayPad$ = -4					; size = 4
_dev$ = 8						; size = 4
_volParams$ = 12					; size = 4
_wipeAlgorithm$ = 16					; size = 4
_bTryToCorrectReadErrors$ = 20				; size = 4
_EncryptPartitionInPlaceResume PROC			; COMDAT

; 644  : {

  00000	b8 f8 f2 00 00	 mov	 eax, 62200		; 0000f2f8H
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000f	33 c4		 xor	 eax, esp
  00011	89 84 24 f4 f2
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+62200], eax
  00018	53		 push	 ebx
  00019	8b 9c 24 00 f3
	00 00		 mov	 ebx, DWORD PTR _dev$[esp+62200]
  00020	55		 push	 ebp
  00021	56		 push	 esi
  00022	8b b4 24 0c f3
	00 00		 mov	 esi, DWORD PTR _volParams$[esp+62208]
  00029	57		 push	 edi

; 645  : 	PCRYPTO_INFO masterCryptoInfo = NULL, headerCryptoInfo = NULL, tmpCryptoInfo = NULL;

  0002a	33 ff		 xor	 edi, edi

; 646  : 	UINT64_STRUCT unitNo;
; 647  : 	char *buf = NULL, *header = NULL;
; 648  : 	byte *wipeBuffer = NULL;
; 649  : 	byte wipeRandChars [TC_WIPE_RAND_CHAR_COUNT];
; 650  : 	byte wipeRandCharsUpdate [TC_WIPE_RAND_CHAR_COUNT];
; 651  : 	char dosDev[TC_MAX_PATH] = {0};

  0002c	68 03 01 00 00	 push	 259			; 00000103H
  00031	8d 84 24 b5 01
	00 00		 lea	 eax, DWORD PTR _dosDev$[esp+62221]
  00038	57		 push	 edi
  00039	50		 push	 eax
  0003a	89 5c 24 24	 mov	 DWORD PTR _dev$GSCopy$[esp+62228], ebx
  0003e	89 7c 24 1c	 mov	 DWORD PTR _masterCryptoInfo$[esp+62228], edi
  00042	89 7c 24 28	 mov	 DWORD PTR _headerCryptoInfo$[esp+62228], edi
  00046	89 7c 24 68	 mov	 DWORD PTR _tmpCryptoInfo$[esp+62228], edi
  0004a	89 7c 24 4c	 mov	 DWORD PTR _header$[esp+62228], edi
  0004e	89 7c 24 64	 mov	 DWORD PTR _wipeBuffer$[esp+62228], edi
  00052	c6 84 24 bc 01
	00 00 00	 mov	 BYTE PTR _dosDev$[esp+62228], 0
  0005a	e8 00 00 00 00	 call	 _memset

; 652  : 	char devName[MAX_PATH] = {0};

  0005f	68 03 01 00 00	 push	 259			; 00000103H
  00064	8d 8c 24 bd 00
	00 00		 lea	 ecx, DWORD PTR _devName$[esp+62233]
  0006b	57		 push	 edi
  0006c	51		 push	 ecx
  0006d	c6 84 24 c4 00
	00 00 00	 mov	 BYTE PTR _devName$[esp+62240], 0
  00075	e8 00 00 00 00	 call	 _memset

; 653  : 	WCHAR deviceName[MAX_PATH];
; 654  : 	int nStatus = ERR_SUCCESS;
; 655  : 	__int64 deviceSize;
; 656  : 	uint64 remainingBytes, lastHeaderUpdateDistance = 0, zeroedSectorCount = 0;
; 657  : 	uint32 workChunkSize;
; 658  : 	DWORD dwError, dwResult;
; 659  : 	BOOL bPause = FALSE, bEncryptedAreaSizeChanged = FALSE;
; 660  : 	LARGE_INTEGER offset;
; 661  : 	int sectorSize;
; 662  : 	int i;
; 663  : 	DWORD n;
; 664  : 	char *devicePath = volParams->volumePath;

  0007a	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]

; 665  : 	Password *password = volParams->password;

  0007d	8b 56 44	 mov	 edx, DWORD PTR [esi+68]
  00080	89 bc 24 9c 00
	00 00		 mov	 DWORD PTR _zeroedSectorCount$[esp+62240], edi
  00087	89 bc 24 a0 00
	00 00		 mov	 DWORD PTR _zeroedSectorCount$[esp+62244], edi

; 666  : 	DISK_GEOMETRY driveGeometry;
; 667  : 
; 668  : 
; 669  : 	bInPlaceEncNonSysResumed = TRUE;
; 670  : 
; 671  : 	buf = (char *) TCalloc (TC_MAX_NONSYS_INPLACE_ENC_WORK_CHUNK_SIZE);

  0008e	68 00 00 20 00	 push	 2097152			; 00200000H
  00093	89 7c 24 48	 mov	 DWORD PTR _bPause$[esp+62244], edi
  00097	89 bc 24 94 00
	00 00		 mov	 DWORD PTR _bEncryptedAreaSizeChanged$[esp+62244], edi
  0009e	89 ac 24 ac 00
	00 00		 mov	 DWORD PTR _devicePath$[esp+62244], ebp
  000a5	89 94 24 90 00
	00 00		 mov	 DWORD PTR _password$[esp+62244], edx
  000ac	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bInPlaceEncNonSysResumed, 1
  000b6	e8 00 00 00 00	 call	 _malloc
  000bb	83 c4 1c	 add	 esp, 28			; 0000001cH
  000be	89 44 24 20	 mov	 DWORD PTR _buf$[esp+62216], eax

; 672  : 	if (!buf)

  000c2	3b c7		 cmp	 eax, edi
  000c4	75 08		 jne	 SHORT $LN88@EncryptPar

; 673  : 	{
; 674  : 		nStatus = ERR_OUTOFMEMORY;

  000c6	8d 77 02	 lea	 esi, DWORD PTR [edi+2]
  000c9	e9 4f 09 00 00	 jmp	 $closing_seq$119779
$LN88@EncryptPar:

; 675  : 		goto closing_seq;
; 676  : 	}
; 677  : 
; 678  : 	header = (char *) TCalloc (TC_VOLUME_HEADER_EFFECTIVE_SIZE);

  000ce	68 00 02 00 00	 push	 512			; 00000200H
  000d3	e8 00 00 00 00	 call	 _malloc
  000d8	83 c4 04	 add	 esp, 4
  000db	89 44 24 40	 mov	 DWORD PTR _header$[esp+62216], eax

; 679  : 	if (!header)

  000df	3b c7		 cmp	 eax, edi
  000e1	75 0a		 jne	 SHORT $LN86@EncryptPar

; 680  : 	{
; 681  : 		nStatus = ERR_OUTOFMEMORY;

  000e3	be 02 00 00 00	 mov	 esi, 2

; 1028 : 	}
; 1029 : 
; 1030 : 
; 1031 : closing_seq:

  000e8	e9 30 09 00 00	 jmp	 $closing_seq$119779
$LN86@EncryptPar:

; 682  : 		goto closing_seq;
; 683  : 	}
; 684  : 
; 685  : 	VirtualLock (header, TC_VOLUME_HEADER_EFFECTIVE_SIZE);

  000ed	68 00 02 00 00	 push	 512			; 00000200H
  000f2	50		 push	 eax
  000f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualLock@8

; 686  : 
; 687  : 	if (wipeAlgorithm != TC_WIPE_NONE)

  000f9	39 bc 24 14 f3
	00 00		 cmp	 DWORD PTR _wipeAlgorithm$[esp+62212], edi
  00100	74 1f		 je	 SHORT $LN83@EncryptPar

; 688  : 	{
; 689  : 		wipeBuffer = (byte *) TCalloc (TC_MAX_NONSYS_INPLACE_ENC_WORK_CHUNK_SIZE);

  00102	68 00 00 20 00	 push	 2097152			; 00200000H
  00107	e8 00 00 00 00	 call	 _malloc
  0010c	83 c4 04	 add	 esp, 4
  0010f	89 44 24 58	 mov	 DWORD PTR _wipeBuffer$[esp+62216], eax

; 690  : 		if (!wipeBuffer)

  00113	3b c7		 cmp	 eax, edi
  00115	75 0a		 jne	 SHORT $LN83@EncryptPar

; 691  : 		{
; 692  : 			nStatus = ERR_OUTOFMEMORY;

  00117	be 02 00 00 00	 mov	 esi, 2

; 1028 : 	}
; 1029 : 
; 1030 : 
; 1031 : closing_seq:

  0011c	e9 fc 08 00 00	 jmp	 $closing_seq$119779
$LN83@EncryptPar:

; 693  : 			goto closing_seq;
; 694  : 		}
; 695  : 	}
; 696  : 
; 697  : 	headerCryptoInfo = crypto_open();

  00121	e8 00 00 00 00	 call	 _crypto_open
  00126	89 44 24 1c	 mov	 DWORD PTR _headerCryptoInfo$[esp+62216], eax

; 698  : 
; 699  : 	if (headerCryptoInfo == NULL)

  0012a	3b c7		 cmp	 eax, edi
  0012c	75 0a		 jne	 SHORT $LN81@EncryptPar

; 700  : 	{
; 701  : 		nStatus = ERR_OUTOFMEMORY;

  0012e	be 02 00 00 00	 mov	 esi, 2

; 1028 : 	}
; 1029 : 
; 1030 : 
; 1031 : closing_seq:

  00133	e9 e5 08 00 00	 jmp	 $closing_seq$119779
$LN81@EncryptPar:

; 702  : 		goto closing_seq;
; 703  : 	}
; 704  : 
; 705  : 	deviceSize = GetDeviceSize (devicePath);

  00138	55		 push	 ebp
  00139	e8 00 00 00 00	 call	 _GetDeviceSize
  0013e	8b f2		 mov	 esi, edx
  00140	83 c4 04	 add	 esp, 4

; 706  : 	if (deviceSize < 0)

  00143	3b f7		 cmp	 esi, edi
  00145	89 44 24 34	 mov	 DWORD PTR _deviceSize$[esp+62216], eax
  00149	89 74 24 38	 mov	 DWORD PTR _deviceSize$[esp+62220], esi
  0014d	7f 10		 jg	 SHORT $LN79@EncryptPar
  0014f	7c 04		 jl	 SHORT $LN167@EncryptPar
  00151	3b c7		 cmp	 eax, edi
  00153	73 0a		 jae	 SHORT $LN79@EncryptPar
$LN167@EncryptPar:

; 707  : 	{
; 708  : 		// Cannot determine the size of the partition
; 709  : 		nStatus = ERR_OS_ERROR;

  00155	be 01 00 00 00	 mov	 esi, 1

; 1028 : 	}
; 1029 : 
; 1030 : 
; 1031 : closing_seq:

  0015a	e9 be 08 00 00	 jmp	 $closing_seq$119779
$LN79@EncryptPar:

; 710  : 		goto closing_seq;
; 711  : 	}
; 712  : 
; 713  : 	if (dev == INVALID_HANDLE_VALUE)

  0015f	83 fb ff	 cmp	 ebx, -1
  00162	0f 85 25 01 00
	00		 jne	 $LN74@EncryptPar

; 714  : 	{
; 715  : 		strcpy ((char *)deviceName, devicePath);

  00168	8d 94 24 9c 06
	00 00		 lea	 edx, DWORD PTR _deviceName$[esp+62216]
  0016f	8b c5		 mov	 eax, ebp
  00171	2b d5		 sub	 edx, ebp
$LL91@EncryptPar:
  00173	8a 08		 mov	 cl, BYTE PTR [eax]
  00175	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00178	40		 inc	 eax
  00179	84 c9		 test	 cl, cl
  0017b	75 f6		 jne	 SHORT $LL91@EncryptPar

; 716  : 		ToUNICODE ((char *)deviceName);

  0017d	8d 84 24 9c 06
	00 00		 lea	 eax, DWORD PTR _deviceName$[esp+62216]
  00184	50		 push	 eax
  00185	e8 00 00 00 00	 call	 _ToUNICODE

; 717  : 
; 718  : 		if (FakeDosNameForDevice (devicePath, dosDev, devName, FALSE) != 0)

  0018a	57		 push	 edi
  0018b	8d 8c 24 b4 00
	00 00		 lea	 ecx, DWORD PTR _devName$[esp+62224]
  00192	51		 push	 ecx
  00193	8d 94 24 bc 01
	00 00		 lea	 edx, DWORD PTR _dosDev$[esp+62228]
  0019a	52		 push	 edx
  0019b	55		 push	 ebp
  0019c	e8 00 00 00 00	 call	 _FakeDosNameForDevice
  001a1	83 c4 14	 add	 esp, 20			; 00000014H
  001a4	85 c0		 test	 eax, eax
  001a6	74 0a		 je	 SHORT $LN76@EncryptPar

; 719  : 		{
; 720  : 			nStatus = ERR_OS_ERROR;

  001a8	be 01 00 00 00	 mov	 esi, 1

; 1028 : 	}
; 1029 : 
; 1030 : 
; 1031 : closing_seq:

  001ad	e9 6b 08 00 00	 jmp	 $closing_seq$119779
$LN76@EncryptPar:

; 721  : 			goto closing_seq;
; 722  : 		}
; 723  : 
; 724  : 		dev = OpenPartitionVolume (devName,
; 725  : 			FALSE,	// Do not require exclusive access
; 726  : 			FALSE,	// Do not require shared access
; 727  : 			TRUE,	// Ask the user to confirm shared access (if exclusive fails)
; 728  : 			FALSE,	// Do not append alternative instructions how to encrypt the data (to applicable error messages)
; 729  : 			FALSE);	// Non-silent mode

  001b2	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CreateFileA@28
  001b8	83 cb ff	 or	 ebx, -1
  001bb	33 ed		 xor	 ebp, ebp
  001bd	8d 49 00	 npad	 3
$LL109@EncryptPar:
  001c0	8b c5		 mov	 eax, ebp
  001c2	45		 inc	 ebp
  001c3	3d f4 01 00 00	 cmp	 eax, 500		; 000001f4H
  001c8	7d 44		 jge	 SHORT $LN108@EncryptPar
  001ca	57		 push	 edi
  001cb	68 00 00 00 80	 push	 -2147483648		; 80000000H
  001d0	6a 03		 push	 3
  001d2	57		 push	 edi
  001d3	57		 push	 edi
  001d4	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  001d9	8d 8c 24 c4 00
	00 00		 lea	 ecx, DWORD PTR _devName$[esp+62240]
  001e0	51		 push	 ecx
  001e1	ff d6		 call	 esi
  001e3	83 fd 01	 cmp	 ebp, 1
  001e6	8b d8		 mov	 ebx, eax
  001e8	7e 08		 jle	 SHORT $LN107@EncryptPar
  001ea	6a 0a		 push	 10			; 0000000aH
  001ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
$LN107@EncryptPar:
  001f2	83 fb ff	 cmp	 ebx, -1
  001f5	74 c9		 je	 SHORT $LL109@EncryptPar
$LN99@EncryptPar:
  001f7	89 5c 24 18	 mov	 DWORD PTR _dev$GSCopy$[esp+62216], ebx

; 730  : 
; 731  : 		if (dev == INVALID_HANDLE_VALUE)

  001fb	83 fb ff	 cmp	 ebx, -1
  001fe	0f 85 85 00 00
	00		 jne	 $LN202@EncryptPar

; 732  : 		{
; 733  : 			nStatus = ERR_DONT_REPORT; 

  00204	be 1c 00 00 00	 mov	 esi, 28			; 0000001cH

; 1028 : 	}
; 1029 : 
; 1030 : 
; 1031 : closing_seq:

  00209	e9 0f 08 00 00	 jmp	 $closing_seq$119779

; 721  : 			goto closing_seq;
; 722  : 		}
; 723  : 
; 724  : 		dev = OpenPartitionVolume (devName,
; 725  : 			FALSE,	// Do not require exclusive access
; 726  : 			FALSE,	// Do not require shared access
; 727  : 			TRUE,	// Ask the user to confirm shared access (if exclusive fails)
; 728  : 			FALSE,	// Do not append alternative instructions how to encrypt the data (to applicable error messages)
; 729  : 			FALSE);	// Non-silent mode

$LN108@EncryptPar:
  0020e	83 fb ff	 cmp	 ebx, -1
  00211	75 e4		 jne	 SHORT $LN99@EncryptPar
  00213	57		 push	 edi
  00214	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00219	6a 03		 push	 3
  0021b	57		 push	 edi
  0021c	6a 03		 push	 3
  0021e	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  00223	8d 94 24 c4 00
	00 00		 lea	 edx, DWORD PTR _devName$[esp+62240]
  0022a	52		 push	 edx
  0022b	ff d6		 call	 esi
  0022d	8b d8		 mov	 ebx, eax
  0022f	83 fb ff	 cmp	 ebx, -1
  00232	74 2b		 je	 SHORT $LN101@EncryptPar
  00234	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@KFDNCGEE@DEVICE_IN_USE_INPLACE_ENC?$AA@
  00239	e8 00 00 00 00	 call	 _AskWarnNoYes
  0023e	83 c4 04	 add	 esp, 4
  00241	83 f8 07	 cmp	 eax, 7
  00244	75 b1		 jne	 SHORT $LN99@EncryptPar
  00246	53		 push	 ebx
  00247	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  0024d	c7 44 24 18 ff
	ff ff ff	 mov	 DWORD PTR _dev$GSCopy$[esp+62216], -1

; 732  : 		{
; 733  : 			nStatus = ERR_DONT_REPORT; 

  00255	be 1c 00 00 00	 mov	 esi, 28			; 0000001cH

; 1028 : 	}
; 1029 : 
; 1030 : 
; 1031 : closing_seq:

  0025a	e9 be 07 00 00	 jmp	 $closing_seq$119779

; 721  : 			goto closing_seq;
; 722  : 		}
; 723  : 
; 724  : 		dev = OpenPartitionVolume (devName,
; 725  : 			FALSE,	// Do not require exclusive access
; 726  : 			FALSE,	// Do not require shared access
; 727  : 			TRUE,	// Ask the user to confirm shared access (if exclusive fails)
; 728  : 			FALSE,	// Do not append alternative instructions how to encrypt the data (to applicable error messages)
; 729  : 			FALSE);	// Non-silent mode

$LN101@EncryptPar:
  0025f	a1 00 00 00 00	 mov	 eax, DWORD PTR _MainDlg
  00264	50		 push	 eax
  00265	e8 00 00 00 00	 call	 _handleWin32Error
  0026a	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@CAPGNNOA@INPLACE_ENC_CANT_ACCESS_OR_GET_I@
  0026f	e8 00 00 00 00	 call	 _Error
  00274	83 c4 08	 add	 esp, 8
  00277	c7 44 24 18 ff
	ff ff ff	 mov	 DWORD PTR _dev$GSCopy$[esp+62216], -1

; 732  : 		{
; 733  : 			nStatus = ERR_DONT_REPORT; 

  0027f	be 1c 00 00 00	 mov	 esi, 28			; 0000001cH

; 1028 : 	}
; 1029 : 
; 1030 : 
; 1031 : closing_seq:

  00284	e9 94 07 00 00	 jmp	 $closing_seq$119779
$LN202@EncryptPar:

; 730  : 
; 731  : 		if (dev == INVALID_HANDLE_VALUE)

  00289	8b 74 24 38	 mov	 esi, DWORD PTR _deviceSize$[esp+62220]
$LN74@EncryptPar:

; 734  : 			goto closing_seq;
; 735  : 		}
; 736  : 	}
; 737  : 
; 738  : 	// This should never be needed, but is still performed for extra safety (without checking the result)
; 739  : 	DeviceIoControl (dev,
; 740  : 		FSCTL_ALLOW_EXTENDED_DASD_IO,
; 741  : 		NULL,
; 742  : 		0,   
; 743  : 		NULL,
; 744  : 		0,
; 745  : 		&dwResult,
; 746  : 		NULL);

  0028d	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__DeviceIoControl@32
  00293	57		 push	 edi
  00294	8d 8c 24 90 00
	00 00		 lea	 ecx, DWORD PTR _dwResult$[esp+62220]
  0029b	51		 push	 ecx
  0029c	57		 push	 edi
  0029d	57		 push	 edi
  0029e	57		 push	 edi
  0029f	57		 push	 edi
  002a0	68 83 00 09 00	 push	 589955			; 00090083H
  002a5	53		 push	 ebx
  002a6	ff d5		 call	 ebp

; 747  : 
; 748  : 
; 749  : 	if (!DeviceIoControl (dev, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &driveGeometry, sizeof (driveGeometry), &dwResult, NULL))

  002a8	57		 push	 edi
  002a9	8d 94 24 90 00
	00 00		 lea	 edx, DWORD PTR _dwResult$[esp+62220]
  002b0	52		 push	 edx
  002b1	6a 18		 push	 24			; 00000018H
  002b3	8d 84 24 a0 00
	00 00		 lea	 eax, DWORD PTR _driveGeometry$[esp+62228]
  002ba	50		 push	 eax
  002bb	57		 push	 edi
  002bc	57		 push	 edi
  002bd	68 00 00 07 00	 push	 458752			; 00070000H
  002c2	53		 push	 ebx
  002c3	ff d5		 call	 ebp
  002c5	85 c0		 test	 eax, eax
  002c7	75 08		 jne	 SHORT $LN72@EncryptPar

; 750  : 	{
; 751  : 		nStatus = ERR_OS_ERROR;

  002c9	8d 70 01	 lea	 esi, DWORD PTR [eax+1]

; 1028 : 	}
; 1029 : 
; 1030 : 
; 1031 : closing_seq:

  002cc	e9 4c 07 00 00	 jmp	 $closing_seq$119779
$LN72@EncryptPar:

; 752  : 		goto closing_seq;
; 753  : 	}
; 754  : 
; 755  : 	sectorSize = driveGeometry.BytesPerSector;

  002d1	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR _driveGeometry$[esp+62236]

; 756  : 
; 757  : 
; 758  : 	nStatus = OpenBackupHeader (dev, devicePath, password, &masterCryptoInfo, headerCryptoInfo, deviceSize);

  002d8	8b 54 24 34	 mov	 edx, DWORD PTR _deviceSize$[esp+62216]
  002dc	8b 44 24 1c	 mov	 eax, DWORD PTR _headerCryptoInfo$[esp+62216]
  002e0	56		 push	 esi
  002e1	52		 push	 edx
  002e2	8b 54 24 7c	 mov	 edx, DWORD PTR _password$[esp+62224]
  002e6	50		 push	 eax
  002e7	89 4c 24 70	 mov	 DWORD PTR _sectorSize$[esp+62228], ecx
  002eb	8d 4c 24 1c	 lea	 ecx, DWORD PTR _masterCryptoInfo$[esp+62228]
  002ef	51		 push	 ecx
  002f0	52		 push	 edx
  002f1	8b c3		 mov	 eax, ebx
  002f3	e8 00 00 00 00	 call	 _OpenBackupHeader
  002f8	8b f0		 mov	 esi, eax
  002fa	83 c4 14	 add	 esp, 20			; 00000014H

; 759  : 
; 760  : 	if (nStatus != ERR_SUCCESS)

  002fd	3b f7		 cmp	 esi, edi
  002ff	0f 85 18 07 00
	00		 jne	 $closing_seq$119779

; 761  : 		goto closing_seq;
; 762  : 
; 763  : 
; 764  : 
; 765  :     remainingBytes = masterCryptoInfo->VolumeSize.Value - masterCryptoInfo->EncryptedAreaLength.Value;

  00305	8b 6c 24 10	 mov	 ebp, DWORD PTR _masterCryptoInfo$[esp+62216]
  00309	8b 85 48 44 00
	00		 mov	 eax, DWORD PTR [ebp+17480]
  0030f	8b 8d 4c 44 00
	00		 mov	 ecx, DWORD PTR [ebp+17484]
  00315	8b 95 58 44 00
	00		 mov	 edx, DWORD PTR [ebp+17496]
  0031b	8b 9d 5c 44 00
	00		 mov	 ebx, DWORD PTR [ebp+17500]
  00321	8b f0		 mov	 esi, eax
  00323	2b f2		 sub	 esi, edx

; 766  : 
; 767  : 	lastHeaderUpdateDistance = 0;
; 768  : 
; 769  : 
; 770  : 	ExportProgressStats (masterCryptoInfo->EncryptedAreaLength.Value, masterCryptoInfo->VolumeSize.Value);

  00325	51		 push	 ecx
  00326	50		 push	 eax
  00327	89 74 24 2c	 mov	 DWORD PTR _remainingBytes$[esp+62224], esi
  0032b	8b f1		 mov	 esi, ecx
  0032d	1b f3		 sbb	 esi, ebx
  0032f	53		 push	 ebx
  00330	52		 push	 edx
  00331	89 74 24 38	 mov	 DWORD PTR _remainingBytes$[esp+62236], esi
  00335	89 7c 24 58	 mov	 DWORD PTR _lastHeaderUpdateDistance$[esp+62232], edi
  00339	89 7c 24 5c	 mov	 DWORD PTR _lastHeaderUpdateDistance$[esp+62236], edi
  0033d	e8 00 00 00 00	 call	 _ExportProgressStats
  00342	83 c4 10	 add	 esp, 16			; 00000010H

; 771  : 
; 772  : 	SetNonSysInplaceEncUIStatus (NONSYS_INPLACE_ENC_STATUS_ENCRYPTING);

  00345	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR _NonSysInplaceEncStatus, 3

; 773  : 
; 774  : 	bFirstNonSysInPlaceEncResumeDone = TRUE;

  0034f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bFirstNonSysInPlaceEncResumeDone, 1

; 775  : 
; 776  : 
; 777  : 	/* The in-place encryption core */
; 778  : 
; 779  : 	while (remainingBytes > 0)

  00359	3b f7		 cmp	 esi, edi
  0035b	77 0a		 ja	 SHORT $LN177@EncryptPar
  0035d	39 7c 24 24	 cmp	 DWORD PTR _remainingBytes$[esp+62216], edi
  00361	0f 86 20 05 00
	00		 jbe	 $LN200@EncryptPar
$LN177@EncryptPar:
  00367	8b 5c 24 18	 mov	 ebx, DWORD PTR _dev$GSCopy$[esp+62216]
  0036b	eb 07		 jmp	 SHORT $LN68@EncryptPar
  0036d	8d 49 00	 npad	 3
$LL187@EncryptPar:
  00370	8b 6c 24 10	 mov	 ebp, DWORD PTR _masterCryptoInfo$[esp+62216]
$LN68@EncryptPar:

; 780  : 	{
; 781  : 		workChunkSize = (uint32) min (remainingBytes, TC_MAX_NONSYS_INPLACE_ENC_WORK_CHUNK_SIZE);

  00374	8b 4c 24 28	 mov	 ecx, DWORD PTR _remainingBytes$[esp+62220]
  00378	85 c9		 test	 ecx, ecx
  0037a	77 12		 ja	 SHORT $LN189@EncryptPar
  0037c	72 0a		 jb	 SHORT $LN196@EncryptPar
  0037e	81 7c 24 24 00
	00 20 00	 cmp	 DWORD PTR _remainingBytes$[esp+62216], 2097152 ; 00200000H
  00386	73 06		 jae	 SHORT $LN189@EncryptPar
$LN196@EncryptPar:
  00388	8b 74 24 24	 mov	 esi, DWORD PTR _remainingBytes$[esp+62216]
  0038c	eb 05		 jmp	 SHORT $LN93@EncryptPar
$LN189@EncryptPar:
  0038e	be 00 00 20 00	 mov	 esi, 2097152		; 00200000H
$LN93@EncryptPar:

; 782  : 
; 783  : 		if (workChunkSize % ENCRYPTION_DATA_UNIT_SIZE != 0)

  00393	f7 c6 ff 01 00
	00		 test	 esi, 511		; 000001ffH
  00399	0f 85 d9 03 00
	00		 jne	 $LN140@EncryptPar

; 786  : 			goto closing_seq;
; 787  : 		}
; 788  : 
; 789  : 		unitNo.Value = (remainingBytes - workChunkSize + TC_VOLUME_DATA_OFFSET) / ENCRYPTION_DATA_UNIT_SIZE;

  0039f	8b 44 24 24	 mov	 eax, DWORD PTR _remainingBytes$[esp+62216]
  003a3	33 ff		 xor	 edi, edi
  003a5	2b c6		 sub	 eax, esi
  003a7	1b cf		 sbb	 ecx, edi
  003a9	89 44 24 7c	 mov	 DWORD PTR tv744[esp+62216], eax
  003ad	05 00 00 02 00	 add	 eax, 131072		; 00020000H
  003b2	89 8c 24 80 00
	00 00		 mov	 DWORD PTR tv744[esp+62220], ecx
  003b9	13 cf		 adc	 ecx, edi
  003bb	0f ac c8 09	 shrd	 eax, ecx, 9
  003bf	c1 e9 09	 shr	 ecx, 9
  003c2	89 44 24 68	 mov	 DWORD PTR _unitNo$[esp+62216], eax
  003c6	89 4c 24 6c	 mov	 DWORD PTR _unitNo$[esp+62220], ecx
  003ca	8d 9b 00 00 00
	00		 npad	 6
$inplace_enc_read$119813:

; 790  : 
; 791  : 
; 792  : 		// Read the plaintext into RAM
; 793  : 
; 794  : inplace_enc_read:
; 795  : 
; 796  : 		offset.QuadPart = masterCryptoInfo->EncryptedAreaStart.Value - workChunkSize - TC_VOLUME_DATA_OFFSET;

  003d0	8b 85 50 44 00
	00		 mov	 eax, DWORD PTR [ebp+17488]
  003d6	8b 8d 54 44 00
	00		 mov	 ecx, DWORD PTR [ebp+17492]
  003dc	2b c6		 sub	 eax, esi

; 797  : 
; 798  : 		if (SetFilePointerEx (dev, offset, NULL, FILE_BEGIN) == 0)

  003de	6a 00		 push	 0
  003e0	1b cf		 sbb	 ecx, edi
  003e2	2d 00 00 02 00	 sub	 eax, 131072		; 00020000H
  003e7	6a 00		 push	 0
  003e9	83 d9 00	 sbb	 ecx, 0
  003ec	51		 push	 ecx
  003ed	50		 push	 eax
  003ee	53		 push	 ebx
  003ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  003f5	85 c0		 test	 eax, eax
  003f7	0f 84 72 04 00
	00		 je	 $LN21@EncryptPar

; 799  : 		{
; 800  : 			nStatus = ERR_OS_ERROR;
; 801  : 			goto closing_seq;
; 802  : 		}
; 803  : 
; 804  : 		if (ReadFile (dev, buf, workChunkSize, &n, NULL) == 0)

  003fd	8b 4c 24 20	 mov	 ecx, DWORD PTR _buf$[esp+62216]
  00401	6a 00		 push	 0
  00403	8d 44 24 48	 lea	 eax, DWORD PTR _n$[esp+62220]
  00407	50		 push	 eax
  00408	56		 push	 esi
  00409	51		 push	 ecx
  0040a	53		 push	 ebx
  0040b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20
  00411	85 c0		 test	 eax, eax
  00413	0f 85 a3 00 00
	00		 jne	 $LN62@EncryptPar

; 805  : 		{
; 806  : 			// Read error
; 807  : 
; 808  : 			DWORD dwTmpErr = GetLastError ();

  00419	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0041f	8b e8		 mov	 ebp, eax

; 809  : 
; 810  : 			if (IsDiskReadError (dwTmpErr) && !bVolTransformThreadCancel)

  00421	55		 push	 ebp
  00422	89 6c 24 34	 mov	 DWORD PTR _dwTmpErr$119817[esp+62220], ebp
  00426	e8 00 00 00 00	 call	 _IsDiskReadError
  0042b	83 c4 04	 add	 esp, 4
  0042e	85 c0		 test	 eax, eax
  00430	0f 84 50 03 00
	00		 je	 $LN59@EncryptPar
  00436	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _bVolTransformThreadCancel
  0043c	85 d2		 test	 edx, edx
  0043e	0f 85 42 03 00
	00		 jne	 $LN59@EncryptPar

; 811  : 			{
; 812  : 				// Physical defect or data corruption
; 813  : 
; 814  : 				if (!*bTryToCorrectReadErrors)

  00444	8b ac 24 18 f3
	00 00		 mov	 ebp, DWORD PTR _bTryToCorrectReadErrors$[esp+62212]
  0044b	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  0044e	85 c0		 test	 eax, eax
  00450	75 18		 jne	 SHORT $LN60@EncryptPar

; 815  : 				{
; 816  : 					*bTryToCorrectReadErrors = (AskWarnYesNo ("ENABLE_BAD_SECTOR_ZEROING") == IDYES);

  00452	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@ELCHMCAJ@ENABLE_BAD_SECTOR_ZEROING?$AA@
  00457	e8 00 00 00 00	 call	 _AskWarnYesNo
  0045c	33 c9		 xor	 ecx, ecx
  0045e	83 c4 04	 add	 esp, 4
  00461	83 f8 06	 cmp	 eax, 6
  00464	0f 94 c1	 sete	 cl
  00467	89 4d 00	 mov	 DWORD PTR [ebp], ecx
$LN60@EncryptPar:

; 817  : 				}
; 818  : 
; 819  : 				if (*bTryToCorrectReadErrors)

  0046a	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  0046d	85 d2		 test	 edx, edx
  0046f	0f 84 0d 03 00
	00		 je	 $LN203@EncryptPar

; 820  : 				{
; 821  : 					// Try to correct the read errors physically
; 822  : 
; 823  : 					offset.QuadPart = masterCryptoInfo->EncryptedAreaStart.Value - workChunkSize - TC_VOLUME_DATA_OFFSET;

  00475	8b 4c 24 10	 mov	 ecx, DWORD PTR _masterCryptoInfo$[esp+62216]
  00479	8b 81 50 44 00
	00		 mov	 eax, DWORD PTR [ecx+17488]
  0047f	8b 89 54 44 00
	00		 mov	 ecx, DWORD PTR [ecx+17492]

; 824  : 
; 825  : 					nStatus = ZeroUnreadableSectors (dev, offset, workChunkSize, sectorSize, &zeroedSectorCount);

  00485	8d 94 24 84 00
	00 00		 lea	 edx, DWORD PTR _zeroedSectorCount$[esp+62216]
  0048c	52		 push	 edx
  0048d	8b 54 24 68	 mov	 edx, DWORD PTR _sectorSize$[esp+62220]
  00491	52		 push	 edx
  00492	2b c6		 sub	 eax, esi
  00494	1b cf		 sbb	 ecx, edi
  00496	57		 push	 edi
  00497	2d 00 00 02 00	 sub	 eax, 131072		; 00020000H
  0049c	56		 push	 esi
  0049d	83 d9 00	 sbb	 ecx, 0
  004a0	51		 push	 ecx
  004a1	50		 push	 eax
  004a2	53		 push	 ebx
  004a3	e8 00 00 00 00	 call	 _ZeroUnreadableSectors
  004a8	83 c4 1c	 add	 esp, 28			; 0000001cH

; 826  : 
; 827  : 					if (nStatus != ERR_SUCCESS)

  004ab	85 c0		 test	 eax, eax
  004ad	0f 85 bc 03 00
	00		 jne	 $LN21@EncryptPar

; 828  : 					{
; 829  : 						// Due to write errors, we can't correct the read errors
; 830  : 						nStatus = ERR_OS_ERROR;
; 831  : 						goto closing_seq;
; 832  : 					}
; 833  : 
; 834  : 					goto inplace_enc_read;

  004b3	8b 6c 24 10	 mov	 ebp, DWORD PTR _masterCryptoInfo$[esp+62216]
  004b7	e9 14 ff ff ff	 jmp	 $inplace_enc_read$119813
$LN62@EncryptPar:

; 841  : 			goto closing_seq;
; 842  : 		}
; 843  : 
; 844  : 		if (remainingBytes - workChunkSize < TC_INITIAL_NTFS_CONCEAL_PORTION_SIZE)

  004bc	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR tv744[esp+62220], 0
  004c4	77 46		 ja	 SHORT $LN172@EncryptPar
  004c6	72 0a		 jb	 SHORT $LN170@EncryptPar
  004c8	81 7c 24 7c 00
	20 00 00	 cmp	 DWORD PTR tv744[esp+62216], 8192 ; 00002000H
  004d0	73 3a		 jae	 SHORT $LN172@EncryptPar
$LN170@EncryptPar:

; 845  : 		{
; 846  : 			// We reached the inital portion of the filesystem, which we had concealed (in order to prevent
; 847  : 			// Windows from interfering with the volume). Now we need to undo that modification. 
; 848  : 
; 849  : 			for (i = 0; i < TC_INITIAL_NTFS_CONCEAL_PORTION_SIZE - (remainingBytes - workChunkSize); i++)

  004d2	33 c9		 xor	 ecx, ecx
  004d4	8b de		 mov	 ebx, esi
  004d6	2b 5c 24 24	 sub	 ebx, DWORD PTR _remainingBytes$[esp+62216]
  004da	8b ef		 mov	 ebp, edi
  004dc	1b 6c 24 28	 sbb	 ebp, DWORD PTR _remainingBytes$[esp+62220]
  004e0	81 c3 00 20 00
	00		 add	 ebx, 8192		; 00002000H
  004e6	13 e9		 adc	 ebp, ecx
  004e8	85 ed		 test	 ebp, ebp
  004ea	72 20		 jb	 SHORT $LN172@EncryptPar
  004ec	77 04		 ja	 SHORT $LL179@EncryptPar
  004ee	85 db		 test	 ebx, ebx
  004f0	76 1a		 jbe	 SHORT $LN172@EncryptPar
$LL179@EncryptPar:

; 850  : 				buf[i] ^= TC_NTFS_CONCEAL_CONSTANT;

  004f2	8b 44 24 20	 mov	 eax, DWORD PTR _buf$[esp+62216]
  004f6	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  004f9	f6 d2		 not	 dl
  004fb	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  004fe	41		 inc	 ecx
  004ff	8b c1		 mov	 eax, ecx
  00501	99		 cdq
  00502	3b d5		 cmp	 edx, ebp
  00504	72 ec		 jb	 SHORT $LL179@EncryptPar

; 845  : 		{
; 846  : 			// We reached the inital portion of the filesystem, which we had concealed (in order to prevent
; 847  : 			// Windows from interfering with the volume). Now we need to undo that modification. 
; 848  : 
; 849  : 			for (i = 0; i < TC_INITIAL_NTFS_CONCEAL_PORTION_SIZE - (remainingBytes - workChunkSize); i++)

  00506	77 04		 ja	 SHORT $LN172@EncryptPar
  00508	3b c3		 cmp	 eax, ebx
  0050a	72 e6		 jb	 SHORT $LL179@EncryptPar
$LN172@EncryptPar:

; 851  : 		}
; 852  : 
; 853  : 
; 854  : 		// Encrypt the plaintext in RAM
; 855  : 
; 856  : 		EncryptDataUnits ((byte *) buf, &unitNo, workChunkSize / ENCRYPTION_DATA_UNIT_SIZE, masterCryptoInfo);

  0050c	8b 4c 24 10	 mov	 ecx, DWORD PTR _masterCryptoInfo$[esp+62216]
  00510	51		 push	 ecx
  00511	8b c6		 mov	 eax, esi
  00513	c1 e8 09	 shr	 eax, 9
  00516	50		 push	 eax
  00517	8d 54 24 70	 lea	 edx, DWORD PTR _unitNo$[esp+62224]
  0051b	89 44 24 38	 mov	 DWORD PTR tv772[esp+62224], eax
  0051f	8b 44 24 28	 mov	 eax, DWORD PTR _buf$[esp+62224]
  00523	52		 push	 edx
  00524	50		 push	 eax
  00525	e8 00 00 00 00	 call	 _EncryptDataUnits

; 857  : 
; 858  : 
; 859  : 		// If enabled, wipe the area to which we will write the ciphertext
; 860  : 
; 861  : 		if (wipeAlgorithm != TC_WIPE_NONE)

  0052a	8b 94 24 24 f3
	00 00		 mov	 edx, DWORD PTR _wipeAlgorithm$[esp+62228]
  00531	83 c4 10	 add	 esp, 16			; 00000010H
  00534	85 d2		 test	 edx, edx
  00536	0f 84 1d 01 00
	00		 je	 $LN191@EncryptPar

; 862  : 		{
; 863  : 			byte wipePass;
; 864  : 
; 865  : 			offset.QuadPart = masterCryptoInfo->EncryptedAreaStart.Value - workChunkSize;

  0053c	8b 4c 24 10	 mov	 ecx, DWORD PTR _masterCryptoInfo$[esp+62216]
  00540	8b 81 50 44 00
	00		 mov	 eax, DWORD PTR [ecx+17488]
  00546	2b c6		 sub	 eax, esi
  00548	89 44 24 50	 mov	 DWORD PTR _offset$[esp+62216], eax
  0054c	8b 81 54 44 00
	00		 mov	 eax, DWORD PTR [ecx+17492]
  00552	1b c7		 sbb	 eax, edi

; 866  : 
; 867  : 			for (wipePass = 1; wipePass <= GetWipePassCount (wipeAlgorithm); ++wipePass)

  00554	52		 push	 edx
  00555	89 44 24 58	 mov	 DWORD PTR _offset$[esp+62224], eax
  00559	c6 44 24 1b 01	 mov	 BYTE PTR _wipePass$119831[esp+62220], 1
  0055e	e8 00 00 00 00	 call	 _GetWipePassCount
  00563	83 c4 04	 add	 esp, 4
  00566	83 f8 01	 cmp	 eax, 1
  00569	0f 8c d8 00 00
	00		 jl	 $LN190@EncryptPar
  0056f	8b 5c 24 58	 mov	 ebx, DWORD PTR _wipeBuffer$[esp+62216]
  00573	bd 01 00 00 00	 mov	 ebp, 1
  00578	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL195@EncryptPar:

; 868  : 			{
; 869  : 				if (!WipeBuffer (wipeAlgorithm, wipeRandChars, wipePass, wipeBuffer, workChunkSize))

  00580	8b 94 24 14 f3
	00 00		 mov	 edx, DWORD PTR _wipeAlgorithm$[esp+62212]
  00587	56		 push	 esi
  00588	53		 push	 ebx
  00589	55		 push	 ebp
  0058a	8d 4c 24 6c	 lea	 ecx, DWORD PTR _wipeRandChars$[esp+62228]
  0058e	51		 push	 ecx
  0058f	52		 push	 edx
  00590	e8 00 00 00 00	 call	 _WipeBuffer
  00595	83 c4 14	 add	 esp, 20			; 00000014H
  00598	85 c0		 test	 eax, eax
  0059a	75 4d		 jne	 SHORT $LN198@EncryptPar

; 870  : 				{
; 871  : 					ULONG i;
; 872  : 					for (i = 0; i < workChunkSize; ++i)

  0059c	85 f6		 test	 esi, esi
  0059e	76 22		 jbe	 SHORT $LN44@EncryptPar
  005a0	8b 6c 24 20	 mov	 ebp, DWORD PTR _buf$[esp+62216]
  005a4	8b c3		 mov	 eax, ebx
  005a6	2b eb		 sub	 ebp, ebx
  005a8	89 74 24 70	 mov	 DWORD PTR tv256[esp+62216], esi
  005ac	8d 64 24 00	 npad	 4
$LL46@EncryptPar:

; 873  : 					{
; 874  : 						wipeBuffer[i] = buf[i] + wipePass;

  005b0	8a 0c 28	 mov	 cl, BYTE PTR [eax+ebp]
  005b3	02 4c 24 17	 add	 cl, BYTE PTR _wipePass$119831[esp+62216]
  005b7	40		 inc	 eax
  005b8	83 6c 24 70 01	 sub	 DWORD PTR tv256[esp+62216], 1
  005bd	88 48 ff	 mov	 BYTE PTR [eax-1], cl
  005c0	75 ee		 jne	 SHORT $LL46@EncryptPar
$LN44@EncryptPar:

; 875  : 					}
; 876  : 
; 877  : 					EncryptDataUnits (wipeBuffer, &unitNo, workChunkSize / ENCRYPTION_DATA_UNIT_SIZE, masterCryptoInfo);

  005c2	8b 54 24 10	 mov	 edx, DWORD PTR _masterCryptoInfo$[esp+62216]
  005c6	8b 44 24 30	 mov	 eax, DWORD PTR tv772[esp+62216]
  005ca	52		 push	 edx
  005cb	50		 push	 eax
  005cc	8d 4c 24 70	 lea	 ecx, DWORD PTR _unitNo$[esp+62224]
  005d0	51		 push	 ecx
  005d1	53		 push	 ebx
  005d2	e8 00 00 00 00	 call	 _EncryptDataUnits

; 878  : 					memcpy (wipeRandCharsUpdate, wipeBuffer, sizeof (wipeRandCharsUpdate)); 

  005d7	66 8b 13	 mov	 dx, WORD PTR [ebx]
  005da	8a 43 02	 mov	 al, BYTE PTR [ebx+2]
  005dd	83 c4 10	 add	 esp, 16			; 00000010H
  005e0	66 89 54 24 3c	 mov	 WORD PTR _wipeRandCharsUpdate$[esp+62216], dx
  005e5	88 44 24 3e	 mov	 BYTE PTR _wipeRandCharsUpdate$[esp+62218], al
$LN198@EncryptPar:

; 879  : 				}
; 880  : 
; 881  : 				if (SetFilePointerEx (dev, offset, NULL, FILE_BEGIN) == 0
; 882  : 					|| WriteFile (dev, wipeBuffer, workChunkSize, &n, NULL) == 0)

  005e9	8b 4c 24 54	 mov	 ecx, DWORD PTR _offset$[esp+62220]
  005ed	8b 54 24 50	 mov	 edx, DWORD PTR _offset$[esp+62216]
  005f1	8b 6c 24 18	 mov	 ebp, DWORD PTR _dev$GSCopy$[esp+62216]
  005f5	6a 00		 push	 0
  005f7	6a 00		 push	 0
  005f9	51		 push	 ecx
  005fa	52		 push	 edx
  005fb	55		 push	 ebp
  005fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  00602	85 c0		 test	 eax, eax
  00604	0f 84 8d 01 00
	00		 je	 $LN139@EncryptPar
  0060a	6a 00		 push	 0
  0060c	8d 44 24 48	 lea	 eax, DWORD PTR _n$[esp+62220]
  00610	50		 push	 eax
  00611	56		 push	 esi
  00612	53		 push	 ebx
  00613	55		 push	 ebp
  00614	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  0061a	85 c0		 test	 eax, eax
  0061c	0f 84 75 01 00
	00		 je	 $LN139@EncryptPar
  00622	8a 44 24 17	 mov	 al, BYTE PTR _wipePass$119831[esp+62216]
  00626	8b 8c 24 14 f3
	00 00		 mov	 ecx, DWORD PTR _wipeAlgorithm$[esp+62212]
  0062d	fe c0		 inc	 al
  0062f	51		 push	 ecx
  00630	88 44 24 1b	 mov	 BYTE PTR _wipePass$119831[esp+62220], al
  00634	0f b6 e8	 movzx	 ebp, al
  00637	e8 00 00 00 00	 call	 _GetWipePassCount
  0063c	83 c4 04	 add	 esp, 4
  0063f	3b e8		 cmp	 ebp, eax
  00641	0f 8e 39 ff ff
	ff		 jle	 $LL195@EncryptPar
$LN190@EncryptPar:

; 896  : 					goto closing_seq;
; 897  : 				}
; 898  : 			}
; 899  : 
; 900  : 			memcpy (wipeRandChars, wipeRandCharsUpdate, sizeof (wipeRandCharsUpdate)); 

  00647	66 8b 54 24 3c	 mov	 dx, WORD PTR _wipeRandCharsUpdate$[esp+62216]
  0064c	8a 44 24 3e	 mov	 al, BYTE PTR _wipeRandCharsUpdate$[esp+62218]
  00650	66 89 54 24 60	 mov	 WORD PTR _wipeRandChars$[esp+62216], dx
  00655	88 44 24 62	 mov	 BYTE PTR _wipeRandChars$[esp+62218], al
$LN191@EncryptPar:

; 901  : 		}
; 902  : 
; 903  : 
; 904  : 		// Write the ciphertext
; 905  : 
; 906  : 		offset.QuadPart = masterCryptoInfo->EncryptedAreaStart.Value - workChunkSize;

  00659	8b 44 24 10	 mov	 eax, DWORD PTR _masterCryptoInfo$[esp+62216]
  0065d	8b a8 50 44 00
	00		 mov	 ebp, DWORD PTR [eax+17488]
  00663	8b 80 54 44 00
	00		 mov	 eax, DWORD PTR [eax+17492]
  00669	8b 5c 24 18	 mov	 ebx, DWORD PTR _dev$GSCopy$[esp+62216]

; 907  : 
; 908  : 		if (SetFilePointerEx (dev, offset, NULL, FILE_BEGIN) == 0)

  0066d	6a 00		 push	 0
  0066f	2b ee		 sub	 ebp, esi
  00671	6a 00		 push	 0
  00673	1b c7		 sbb	 eax, edi
  00675	50		 push	 eax
  00676	55		 push	 ebp
  00677	53		 push	 ebx
  00678	89 44 24 68	 mov	 DWORD PTR _offset$[esp+62240], eax
  0067c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  00682	85 c0		 test	 eax, eax
  00684	0f 84 e5 01 00
	00		 je	 $LN21@EncryptPar

; 909  : 		{
; 910  : 			nStatus = ERR_OS_ERROR;
; 911  : 			goto closing_seq;
; 912  : 		}
; 913  : 
; 914  : 		if (WriteFile (dev, buf, workChunkSize, &n, NULL) == 0)

  0068a	8b 54 24 20	 mov	 edx, DWORD PTR _buf$[esp+62216]
  0068e	6a 00		 push	 0
  00690	8d 4c 24 48	 lea	 ecx, DWORD PTR _n$[esp+62220]
  00694	51		 push	 ecx
  00695	56		 push	 esi
  00696	52		 push	 edx
  00697	53		 push	 ebx
  00698	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  0069e	85 c0		 test	 eax, eax
  006a0	0f 84 64 01 00
	00		 je	 $LN142@EncryptPar

; 928  : 			goto closing_seq;
; 929  : 		}
; 930  : 
; 931  : 
; 932  : 		masterCryptoInfo->EncryptedAreaStart.Value -= workChunkSize;

  006a6	8b 44 24 10	 mov	 eax, DWORD PTR _masterCryptoInfo$[esp+62216]

; 933  : 		masterCryptoInfo->EncryptedAreaLength.Value += workChunkSize;
; 934  : 
; 935  : 		remainingBytes -= workChunkSize;

  006aa	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv744[esp+62220]
  006b1	05 50 44 00 00	 add	 eax, 17488		; 00004450H
  006b6	29 30		 sub	 DWORD PTR [eax], esi
  006b8	89 4c 24 28	 mov	 DWORD PTR _remainingBytes$[esp+62220], ecx

; 936  : 		lastHeaderUpdateDistance += workChunkSize;
; 937  : 
; 938  : 		bEncryptedAreaSizeChanged = TRUE;

  006bc	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR _bEncryptedAreaSizeChanged$[esp+62216], 1
  006c4	19 78 04	 sbb	 DWORD PTR [eax+4], edi
  006c7	8b 44 24 10	 mov	 eax, DWORD PTR _masterCryptoInfo$[esp+62216]
  006cb	05 58 44 00 00	 add	 eax, 17496		; 00004458H
  006d0	01 30		 add	 DWORD PTR [eax], esi
  006d2	11 78 04	 adc	 DWORD PTR [eax+4], edi
  006d5	01 74 24 48	 add	 DWORD PTR _lastHeaderUpdateDistance$[esp+62216], esi
  006d9	8b 44 24 7c	 mov	 eax, DWORD PTR tv744[esp+62216]
  006dd	89 44 24 24	 mov	 DWORD PTR _remainingBytes$[esp+62216], eax
  006e1	11 7c 24 4c	 adc	 DWORD PTR _lastHeaderUpdateDistance$[esp+62220], edi

; 939  : 
; 940  : 		if (lastHeaderUpdateDistance >= TC_NONSYS_INPLACE_ENC_HEADER_UPDATE_INTERVAL)

  006e5	75 0a		 jne	 SHORT $LN173@EncryptPar
  006e7	81 7c 24 48 00
	00 00 04	 cmp	 DWORD PTR _lastHeaderUpdateDistance$[esp+62216], 67108864 ; 04000000H
  006ef	72 33		 jb	 SHORT $LN197@EncryptPar
$LN173@EncryptPar:

; 941  : 		{
; 942  : 			nStatus = FastVolumeHeaderUpdate (dev, headerCryptoInfo, masterCryptoInfo, deviceSize);

  006f1	8b 54 24 38	 mov	 edx, DWORD PTR _deviceSize$[esp+62220]
  006f5	8b 44 24 34	 mov	 eax, DWORD PTR _deviceSize$[esp+62216]
  006f9	8b 4c 24 10	 mov	 ecx, DWORD PTR _masterCryptoInfo$[esp+62216]
  006fd	52		 push	 edx
  006fe	8b 54 24 20	 mov	 edx, DWORD PTR _headerCryptoInfo$[esp+62220]
  00702	50		 push	 eax
  00703	51		 push	 ecx
  00704	52		 push	 edx
  00705	53		 push	 ebx
  00706	e8 00 00 00 00	 call	 _FastVolumeHeaderUpdate
  0070b	8b f0		 mov	 esi, eax
  0070d	83 c4 14	 add	 esp, 20			; 00000014H

; 943  : 
; 944  : 			if (nStatus != ERR_SUCCESS)

  00710	85 f6		 test	 esi, esi
  00712	0f 85 05 03 00
	00		 jne	 $closing_seq$119779

; 945  : 				goto closing_seq;
; 946  : 
; 947  : 			lastHeaderUpdateDistance = 0;

  00718	8b 5c 24 18	 mov	 ebx, DWORD PTR _dev$GSCopy$[esp+62216]
  0071c	89 44 24 48	 mov	 DWORD PTR _lastHeaderUpdateDistance$[esp+62216], eax
  00720	89 44 24 4c	 mov	 DWORD PTR _lastHeaderUpdateDistance$[esp+62220], eax
$LN197@EncryptPar:

; 948  : 		}
; 949  : 
; 950  : 		ExportProgressStats (masterCryptoInfo->EncryptedAreaLength.Value, masterCryptoInfo->VolumeSize.Value);

  00724	8b 44 24 10	 mov	 eax, DWORD PTR _masterCryptoInfo$[esp+62216]
  00728	8b 88 4c 44 00
	00		 mov	 ecx, DWORD PTR [eax+17484]
  0072e	8b 90 48 44 00
	00		 mov	 edx, DWORD PTR [eax+17480]
  00734	51		 push	 ecx
  00735	8b 88 5c 44 00
	00		 mov	 ecx, DWORD PTR [eax+17500]
  0073b	52		 push	 edx
  0073c	8b 90 58 44 00
	00		 mov	 edx, DWORD PTR [eax+17496]
  00742	51		 push	 ecx
  00743	52		 push	 edx
  00744	e8 00 00 00 00	 call	 _ExportProgressStats

; 951  : 
; 952  : 		if (bVolTransformThreadCancel)

  00749	a1 00 00 00 00	 mov	 eax, DWORD PTR _bVolTransformThreadCancel
  0074e	83 c4 10	 add	 esp, 16			; 00000010H
  00751	85 c0		 test	 eax, eax
  00753	0f 85 20 01 00
	00		 jne	 $LN144@EncryptPar

; 775  : 
; 776  : 
; 777  : 	/* The in-place encryption core */
; 778  : 
; 779  : 	while (remainingBytes > 0)

  00759	39 44 24 28	 cmp	 DWORD PTR _remainingBytes$[esp+62220], eax
  0075d	0f 87 0d fc ff
	ff		 ja	 $LL187@EncryptPar
  00763	0f 82 18 01 00
	00		 jb	 $LN174@EncryptPar
  00769	39 44 24 24	 cmp	 DWORD PTR _remainingBytes$[esp+62216], eax
  0076d	0f 87 fd fb ff
	ff		 ja	 $LL187@EncryptPar

; 1006 : 
; 1007 : 			if (nStatus != ERR_SUCCESS)

  00773	e9 09 01 00 00	 jmp	 $LN174@EncryptPar
$LN140@EncryptPar:

; 784  : 		{
; 785  : 			nStatus = ERR_PARAMETER_INCORRECT;

  00778	be 1e 00 00 00	 mov	 esi, 30			; 0000001eH

; 1028 : 	}
; 1029 : 
; 1030 : 
; 1031 : closing_seq:

  0077d	e9 9b 02 00 00	 jmp	 $closing_seq$119779
$LN203@EncryptPar:

; 841  : 			goto closing_seq;
; 842  : 		}
; 843  : 
; 844  : 		if (remainingBytes - workChunkSize < TC_INITIAL_NTFS_CONCEAL_PORTION_SIZE)

  00782	8b 6c 24 30	 mov	 ebp, DWORD PTR _dwTmpErr$119817[esp+62216]
$LN59@EncryptPar:

; 835  : 				}
; 836  : 			}
; 837  : 
; 838  : 			SetLastError (dwTmpErr);		// Preserve the original error code

  00786	55		 push	 ebp
  00787	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 839  : 
; 840  : 			nStatus = ERR_OS_ERROR;

  0078d	be 01 00 00 00	 mov	 esi, 1

; 1028 : 	}
; 1029 : 
; 1030 : 
; 1031 : closing_seq:

  00792	e9 86 02 00 00	 jmp	 $closing_seq$119779
$LN139@EncryptPar:

; 883  : 				{
; 884  : 					// Write error
; 885  : 					dwError = GetLastError();

  00797	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0079d	8b d8		 mov	 ebx, eax

; 886  : 
; 887  : 					// Undo failed write operation
; 888  : 					if (workChunkSize > TC_VOLUME_DATA_OFFSET && SetFilePointerEx (dev, offset, NULL, FILE_BEGIN))

  0079f	81 fe 00 00 02
	00		 cmp	 esi, 131072		; 00020000H
  007a5	76 52		 jbe	 SHORT $LN41@EncryptPar
  007a7	8b 4c 24 54	 mov	 ecx, DWORD PTR _offset$[esp+62220]
  007ab	8b 54 24 50	 mov	 edx, DWORD PTR _offset$[esp+62216]
  007af	6a 00		 push	 0
  007b1	6a 00		 push	 0
  007b3	51		 push	 ecx
  007b4	52		 push	 edx
  007b5	55		 push	 ebp
  007b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  007bc	85 c0		 test	 eax, eax
  007be	74 39		 je	 SHORT $LN41@EncryptPar

; 889  : 					{
; 890  : 						DecryptDataUnits ((byte *) buf, &unitNo, workChunkSize / ENCRYPTION_DATA_UNIT_SIZE, masterCryptoInfo);

  007c0	8b 44 24 10	 mov	 eax, DWORD PTR _masterCryptoInfo$[esp+62216]
  007c4	8b 7c 24 20	 mov	 edi, DWORD PTR _buf$[esp+62216]
  007c8	50		 push	 eax
  007c9	8b ce		 mov	 ecx, esi
  007cb	c1 e9 09	 shr	 ecx, 9
  007ce	51		 push	 ecx
  007cf	8d 54 24 70	 lea	 edx, DWORD PTR _unitNo$[esp+62224]
  007d3	52		 push	 edx
  007d4	57		 push	 edi
  007d5	e8 00 00 00 00	 call	 _DecryptDataUnits
  007da	83 c4 10	 add	 esp, 16			; 00000010H

; 891  : 						WriteFile (dev, buf + TC_VOLUME_DATA_OFFSET, workChunkSize - TC_VOLUME_DATA_OFFSET, &n, NULL);

  007dd	6a 00		 push	 0
  007df	8d 44 24 48	 lea	 eax, DWORD PTR _n$[esp+62220]
  007e3	50		 push	 eax
  007e4	81 c6 00 00 fe
	ff		 add	 esi, -131072		; fffe0000H
  007ea	56		 push	 esi
  007eb	81 c7 00 00 02
	00		 add	 edi, 131072		; 00020000H
  007f1	57		 push	 edi
  007f2	55		 push	 ebp
  007f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
$LN41@EncryptPar:

; 892  : 					}
; 893  : 
; 894  : 					SetLastError (dwError);

  007f9	53		 push	 ebx
  007fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 895  : 					nStatus = ERR_OS_ERROR;

  00800	be 01 00 00 00	 mov	 esi, 1

; 1028 : 	}
; 1029 : 
; 1030 : 
; 1031 : closing_seq:

  00805	e9 13 02 00 00	 jmp	 $closing_seq$119779
$LN142@EncryptPar:

; 915  : 		{
; 916  : 			// Write error
; 917  : 			dwError = GetLastError();

  0080a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00810	8b f8		 mov	 edi, eax

; 918  : 
; 919  : 			// Undo failed write operation
; 920  : 			if (workChunkSize > TC_VOLUME_DATA_OFFSET && SetFilePointerEx (dev, offset, NULL, FILE_BEGIN))

  00812	81 fe 00 00 02
	00		 cmp	 esi, 131072		; 00020000H
  00818	76 4e		 jbe	 SHORT $LN36@EncryptPar
  0081a	8b 4c 24 54	 mov	 ecx, DWORD PTR _offset$[esp+62220]
  0081e	6a 00		 push	 0
  00820	6a 00		 push	 0
  00822	51		 push	 ecx
  00823	55		 push	 ebp
  00824	53		 push	 ebx
  00825	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  0082b	85 c0		 test	 eax, eax
  0082d	74 39		 je	 SHORT $LN36@EncryptPar

; 921  : 			{
; 922  : 				DecryptDataUnits ((byte *) buf, &unitNo, workChunkSize / ENCRYPTION_DATA_UNIT_SIZE, masterCryptoInfo);

  0082f	8b 54 24 10	 mov	 edx, DWORD PTR _masterCryptoInfo$[esp+62216]
  00833	8b 6c 24 20	 mov	 ebp, DWORD PTR _buf$[esp+62216]
  00837	52		 push	 edx
  00838	8b c6		 mov	 eax, esi
  0083a	c1 e8 09	 shr	 eax, 9
  0083d	50		 push	 eax
  0083e	8d 4c 24 70	 lea	 ecx, DWORD PTR _unitNo$[esp+62224]
  00842	51		 push	 ecx
  00843	55		 push	 ebp
  00844	e8 00 00 00 00	 call	 _DecryptDataUnits
  00849	83 c4 10	 add	 esp, 16			; 00000010H

; 923  : 				WriteFile (dev, buf + TC_VOLUME_DATA_OFFSET, workChunkSize - TC_VOLUME_DATA_OFFSET, &n, NULL);

  0084c	6a 00		 push	 0
  0084e	8d 54 24 48	 lea	 edx, DWORD PTR _n$[esp+62220]
  00852	52		 push	 edx
  00853	81 c6 00 00 fe
	ff		 add	 esi, -131072		; fffe0000H
  00859	56		 push	 esi
  0085a	81 c5 00 00 02
	00		 add	 ebp, 131072		; 00020000H
  00860	55		 push	 ebp
  00861	53		 push	 ebx
  00862	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
$LN36@EncryptPar:

; 924  : 			}
; 925  : 
; 926  : 			SetLastError (dwError);

  00868	57		 push	 edi
  00869	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
$LN21@EncryptPar:

; 927  : 			nStatus = ERR_OS_ERROR;

  0086f	be 01 00 00 00	 mov	 esi, 1

; 1028 : 	}
; 1029 : 
; 1030 : 
; 1031 : closing_seq:

  00874	e9 a4 01 00 00	 jmp	 $closing_seq$119779
$LN144@EncryptPar:

; 953  : 		{
; 954  : 			bPause = TRUE;

  00879	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR _bPause$[esp+62216], 1
$LN174@EncryptPar:
  00881	8b 6c 24 10	 mov	 ebp, DWORD PTR _masterCryptoInfo$[esp+62216]
  00885	33 ff		 xor	 edi, edi
$LN200@EncryptPar:

; 955  : 			break;
; 956  : 		}
; 957  : 	}
; 958  : 
; 959  : 	nStatus = FastVolumeHeaderUpdate (dev, headerCryptoInfo, masterCryptoInfo, deviceSize);

  00887	8b 44 24 38	 mov	 eax, DWORD PTR _deviceSize$[esp+62220]
  0088b	8b 4c 24 34	 mov	 ecx, DWORD PTR _deviceSize$[esp+62216]
  0088f	8b 5c 24 1c	 mov	 ebx, DWORD PTR _headerCryptoInfo$[esp+62216]
  00893	8b 54 24 18	 mov	 edx, DWORD PTR _dev$GSCopy$[esp+62216]
  00897	50		 push	 eax
  00898	51		 push	 ecx
  00899	55		 push	 ebp
  0089a	53		 push	 ebx
  0089b	52		 push	 edx
  0089c	e8 00 00 00 00	 call	 _FastVolumeHeaderUpdate
  008a1	8b f0		 mov	 esi, eax
  008a3	83 c4 14	 add	 esp, 20			; 00000014H

; 960  : 
; 961  : 
; 962  : 	if (nStatus != ERR_SUCCESS)

  008a6	3b f7		 cmp	 esi, edi
  008a8	0f 85 6f 01 00
	00		 jne	 $closing_seq$119779

; 963  : 		goto closing_seq;
; 964  : 
; 965  : 
; 966  : 	if (!bPause)

  008ae	39 7c 24 2c	 cmp	 DWORD PTR _bPause$[esp+62216], edi
  008b2	0f 85 56 01 00
	00		 jne	 $LN28@EncryptPar

; 967  : 	{
; 968  : 		/* The data area has been fully encrypted; create and write the primary volume header */
; 969  : 
; 970  : 		SetNonSysInplaceEncUIStatus (NONSYS_INPLACE_ENC_STATUS_FINALIZING);
; 971  : 
; 972  : 		for (int wipePass = 0; wipePass < (wipeAlgorithm == TC_WIPE_NONE ? 1 : PRAND_DISK_WIPE_PASSES); wipePass++)

  008b8	8b ac 24 14 f3
	00 00		 mov	 ebp, DWORD PTR _wipeAlgorithm$[esp+62212]
  008bf	33 c0		 xor	 eax, eax
  008c1	f7 dd		 neg	 ebp
  008c3	1b ed		 sbb	 ebp, ebp
  008c5	81 e5 ff 00 00
	00		 and	 ebp, 255		; 000000ffH
  008cb	45		 inc	 ebp
  008cc	3b ef		 cmp	 ebp, edi
  008ce	c7 05 00 00 00
	00 04 00 00 00	 mov	 DWORD PTR _NonSysInplaceEncStatus, 4
  008d8	89 44 24 2c	 mov	 DWORD PTR _wipePass$119858[esp+62216], eax
  008dc	0f 8e 0c 01 00
	00		 jle	 $LN25@EncryptPar
$LL201@EncryptPar:

; 973  : 		{
; 974  : 			nStatus = CreateVolumeHeaderInMemory (FALSE,
; 975  : 				header,
; 976  : 				headerCryptoInfo->ea,
; 977  : 				headerCryptoInfo->mode,
; 978  : 				password,
; 979  : 				masterCryptoInfo->pkcs5,
; 980  : 				(char *) masterCryptoInfo->master_keydata,
; 981  : 				&tmpCryptoInfo,
; 982  : 				masterCryptoInfo->VolumeSize.Value,
; 983  : 				0,
; 984  : 				masterCryptoInfo->EncryptedAreaStart.Value,
; 985  : 				masterCryptoInfo->EncryptedAreaLength.Value,
; 986  : 				masterCryptoInfo->RequiredProgramVersion,
; 987  : 				masterCryptoInfo->HeaderFlags | TC_HEADER_FLAG_NONSYS_INPLACE_ENC,
; 988  : 				masterCryptoInfo->SectorSize,
; 989  : 				wipeAlgorithm == TC_WIPE_NONE ? FALSE : (wipePass < PRAND_DISK_WIPE_PASSES - 1));

  008e2	39 bc 24 14 f3
	00 00		 cmp	 DWORD PTR _wipeAlgorithm$[esp+62212], edi
  008e9	75 04		 jne	 SHORT $LN94@EncryptPar
  008eb	33 c0		 xor	 eax, eax
  008ed	eb 0c		 jmp	 SHORT $LN95@EncryptPar
$LN94@EncryptPar:
  008ef	33 c9		 xor	 ecx, ecx
  008f1	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  008f6	0f 9c c1	 setl	 cl
  008f9	8b c1		 mov	 eax, ecx
$LN95@EncryptPar:
  008fb	50		 push	 eax
  008fc	8b 44 24 14	 mov	 eax, DWORD PTR _masterCryptoInfo$[esp+62220]
  00900	8b 90 40 44 00
	00		 mov	 edx, DWORD PTR [eax+17472]
  00906	8b 88 60 44 00
	00		 mov	 ecx, DWORD PTR [eax+17504]
  0090c	52		 push	 edx
  0090d	0f b7 90 38 44
	00 00		 movzx	 edx, WORD PTR [eax+17464]
  00914	83 c9 02	 or	 ecx, 2
  00917	51		 push	 ecx
  00918	8b 88 5c 44 00
	00		 mov	 ecx, DWORD PTR [eax+17500]
  0091e	52		 push	 edx
  0091f	8b 90 58 44 00
	00		 mov	 edx, DWORD PTR [eax+17496]
  00925	51		 push	 ecx
  00926	8b 88 54 44 00
	00		 mov	 ecx, DWORD PTR [eax+17492]
  0092c	52		 push	 edx
  0092d	8b 90 50 44 00
	00		 mov	 edx, DWORD PTR [eax+17488]
  00933	51		 push	 ecx
  00934	8b 88 4c 44 00
	00		 mov	 ecx, DWORD PTR [eax+17484]
  0093a	52		 push	 edx
  0093b	8b 90 48 44 00
	00		 mov	 edx, DWORD PTR [eax+17480]
  00941	57		 push	 edi
  00942	57		 push	 edi
  00943	51		 push	 ecx
  00944	52		 push	 edx
  00945	8d 90 a8 41 00
	00		 lea	 edx, DWORD PTR [eax+16808]
  0094b	8b 80 ec 43 00
	00		 mov	 eax, DWORD PTR [eax+17388]
  00951	8d 8c 24 8c 00
	00 00		 lea	 ecx, DWORD PTR _tmpCryptoInfo$[esp+62264]
  00958	51		 push	 ecx
  00959	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR _password$[esp+62268]
  00960	52		 push	 edx
  00961	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00964	50		 push	 eax
  00965	8b 03		 mov	 eax, DWORD PTR [ebx]
  00967	51		 push	 ecx
  00968	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR _header$[esp+62280]
  0096f	52		 push	 edx
  00970	50		 push	 eax
  00971	51		 push	 ecx
  00972	57		 push	 edi
  00973	e8 00 00 00 00	 call	 _CreateVolumeHeaderInMemory
  00978	8b f0		 mov	 esi, eax
  0097a	83 c4 50	 add	 esp, 80			; 00000050H

; 990  : 
; 991  : 			if (nStatus != ERR_SUCCESS)

  0097d	3b f7		 cmp	 esi, edi
  0097f	0f 85 98 00 00
	00		 jne	 $closing_seq$119779

; 992  : 				goto closing_seq;
; 993  : 
; 994  : 
; 995  : 			offset.QuadPart = TC_VOLUME_HEADER_OFFSET;
; 996  : 
; 997  : 			if (SetFilePointerEx (dev, offset, NULL, FILE_BEGIN) == 0
; 998  : 				|| !WriteEffectiveVolumeHeader (TRUE, dev, (byte *) header))

  00985	8b 74 24 18	 mov	 esi, DWORD PTR _dev$GSCopy$[esp+62216]
  00989	57		 push	 edi
  0098a	57		 push	 edi
  0098b	57		 push	 edi
  0098c	33 c0		 xor	 eax, eax
  0098e	50		 push	 eax
  0098f	56		 push	 esi
  00990	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  00996	85 c0		 test	 eax, eax
  00998	0f 84 d1 fe ff
	ff		 je	 $LN21@EncryptPar
  0099e	8b 54 24 40	 mov	 edx, DWORD PTR _header$[esp+62216]
  009a2	52		 push	 edx
  009a3	56		 push	 esi
  009a4	6a 01		 push	 1
  009a6	e8 00 00 00 00	 call	 _WriteEffectiveVolumeHeader
  009ab	83 c4 0c	 add	 esp, 12			; 0000000cH
  009ae	85 c0		 test	 eax, eax
  009b0	0f 84 b9 fe ff
	ff		 je	 $LN21@EncryptPar

; 999  : 			{
; 1000 : 				nStatus = ERR_OS_ERROR;
; 1001 : 				goto closing_seq;
; 1002 : 			}
; 1003 : 
; 1004 : 			// Fill the reserved sectors of the header area with random data
; 1005 : 			nStatus = WriteRandomDataToReservedHeaderAreas (dev, headerCryptoInfo, masterCryptoInfo->VolumeSize.Value, TRUE, FALSE);

  009b6	8b 44 24 10	 mov	 eax, DWORD PTR _masterCryptoInfo$[esp+62216]
  009ba	8b 88 4c 44 00
	00		 mov	 ecx, DWORD PTR [eax+17484]
  009c0	8b 90 48 44 00
	00		 mov	 edx, DWORD PTR [eax+17480]
  009c6	57		 push	 edi
  009c7	6a 01		 push	 1
  009c9	51		 push	 ecx
  009ca	52		 push	 edx
  009cb	8b c6		 mov	 eax, esi
  009cd	53		 push	 ebx
  009ce	50		 push	 eax
  009cf	e8 00 00 00 00	 call	 _WriteRandomDataToReservedHeaderAreas
  009d4	8b f0		 mov	 esi, eax
  009d6	83 c4 18	 add	 esp, 24			; 00000018H

; 1006 : 
; 1007 : 			if (nStatus != ERR_SUCCESS)

  009d9	3b f7		 cmp	 esi, edi
  009db	75 40		 jne	 SHORT $closing_seq$119779
  009dd	8b 44 24 2c	 mov	 eax, DWORD PTR _wipePass$119858[esp+62216]
  009e1	40		 inc	 eax
  009e2	3b c5		 cmp	 eax, ebp
  009e4	89 44 24 2c	 mov	 DWORD PTR _wipePass$119858[esp+62216], eax
  009e8	0f 8c f4 fe ff
	ff		 jl	 $LL201@EncryptPar
$LN25@EncryptPar:

; 1008 : 				goto closing_seq;
; 1009 : 		}
; 1010 : 
; 1011 : 		// Update the configuration files
; 1012 : 
; 1013 : 		SaveNonSysInPlaceEncSettings (-1, wipeAlgorithm);

  009ee	8b 8c 24 14 f3
	00 00		 mov	 ecx, DWORD PTR _wipeAlgorithm$[esp+62212]
  009f5	51		 push	 ecx
  009f6	6a ff		 push	 -1
  009f8	e8 00 00 00 00	 call	 _SaveNonSysInPlaceEncSettings
  009fd	83 c4 08	 add	 esp, 8

; 1014 : 
; 1015 : 
; 1016 : 
; 1017 : 		SetNonSysInplaceEncUIStatus (NONSYS_INPLACE_ENC_STATUS_FINISHED);

  00a00	c7 05 00 00 00
	00 06 00 00 00	 mov	 DWORD PTR _NonSysInplaceEncStatus, 6

; 1018 : 
; 1019 : 		nStatus = ERR_SUCCESS;

  00a0a	33 f6		 xor	 esi, esi

; 1020 : 	}
; 1021 : 	else

  00a0c	eb 0f		 jmp	 SHORT $closing_seq$119779
$LN28@EncryptPar:

; 1022 : 	{
; 1023 : 		// The process has been paused by the user or aborted by the wizard (e.g. on app exit)
; 1024 : 
; 1025 : 		nStatus = ERR_USER_ABORT;

  00a0e	be 21 00 00 00	 mov	 esi, 33			; 00000021H

; 1026 : 
; 1027 : 		SetNonSysInplaceEncUIStatus (NONSYS_INPLACE_ENC_STATUS_PAUSED);

  00a13	c7 05 00 00 00
	00 05 00 00 00	 mov	 DWORD PTR _NonSysInplaceEncStatus, 5
$closing_seq$119779:

; 1032 : 
; 1033 : 	dwError = GetLastError();

  00a1d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 1034 : 
; 1035 : 	if (bEncryptedAreaSizeChanged
; 1036 : 		&& dev != INVALID_HANDLE_VALUE
; 1037 : 		&& masterCryptoInfo != NULL
; 1038 : 		&& headerCryptoInfo != NULL
; 1039 : 		&& deviceSize > 0)

  00a23	8b 5c 24 18	 mov	 ebx, DWORD PTR _dev$GSCopy$[esp+62216]
  00a27	33 ed		 xor	 ebp, ebp
  00a29	89 44 24 30	 mov	 DWORD PTR _dwError$[esp+62216], eax
  00a2d	39 6c 24 78	 cmp	 DWORD PTR _bEncryptedAreaSizeChanged$[esp+62216], ebp
  00a31	74 38		 je	 SHORT $LN188@EncryptPar
  00a33	83 fb ff	 cmp	 ebx, -1
  00a36	74 33		 je	 SHORT $LN188@EncryptPar
  00a38	8b 44 24 10	 mov	 eax, DWORD PTR _masterCryptoInfo$[esp+62216]
  00a3c	8b 7c 24 1c	 mov	 edi, DWORD PTR _headerCryptoInfo$[esp+62216]
  00a40	3b c5		 cmp	 eax, ebp
  00a42	74 40		 je	 SHORT $LN15@EncryptPar
  00a44	3b fd		 cmp	 edi, ebp
  00a46	74 2b		 je	 SHORT $LN16@EncryptPar
  00a48	8b 4c 24 38	 mov	 ecx, DWORD PTR _deviceSize$[esp+62220]
  00a4c	3b cd		 cmp	 ecx, ebp
  00a4e	7c 23		 jl	 SHORT $LN16@EncryptPar
  00a50	7f 06		 jg	 SHORT $LN192@EncryptPar
  00a52	39 6c 24 34	 cmp	 DWORD PTR _deviceSize$[esp+62216], ebp
  00a56	76 1b		 jbe	 SHORT $LN16@EncryptPar
$LN192@EncryptPar:

; 1040 : 	{
; 1041 : 		// Execution of the core loop may have been interrupted due to an error or user action without updating the header
; 1042 : 		FastVolumeHeaderUpdate (dev, headerCryptoInfo, masterCryptoInfo, deviceSize);

  00a58	8b 54 24 34	 mov	 edx, DWORD PTR _deviceSize$[esp+62216]
  00a5c	51		 push	 ecx
  00a5d	52		 push	 edx
  00a5e	50		 push	 eax
  00a5f	57		 push	 edi
  00a60	53		 push	 ebx
  00a61	e8 00 00 00 00	 call	 _FastVolumeHeaderUpdate
  00a66	83 c4 14	 add	 esp, 20			; 00000014H
  00a69	eb 04		 jmp	 SHORT $LN211@EncryptPar
$LN188@EncryptPar:
  00a6b	8b 7c 24 1c	 mov	 edi, DWORD PTR _headerCryptoInfo$[esp+62216]
$LN211@EncryptPar:
  00a6f	8b 44 24 10	 mov	 eax, DWORD PTR _masterCryptoInfo$[esp+62216]
$LN16@EncryptPar:

; 1043 : 	}
; 1044 : 
; 1045 : 	if (masterCryptoInfo != NULL)

  00a73	3b c5		 cmp	 eax, ebp
  00a75	74 0d		 je	 SHORT $LN15@EncryptPar

; 1046 : 	{
; 1047 : 		crypto_close (masterCryptoInfo);

  00a77	50		 push	 eax
  00a78	e8 00 00 00 00	 call	 _crypto_close
  00a7d	83 c4 04	 add	 esp, 4

; 1048 : 		masterCryptoInfo = NULL;

  00a80	89 6c 24 10	 mov	 DWORD PTR _masterCryptoInfo$[esp+62216], ebp
$LN15@EncryptPar:

; 1049 : 	}
; 1050 : 
; 1051 : 	if (headerCryptoInfo != NULL)

  00a84	3b fd		 cmp	 edi, ebp
  00a86	74 09		 je	 SHORT $LN14@EncryptPar

; 1052 : 	{
; 1053 : 		crypto_close (headerCryptoInfo);

  00a88	57		 push	 edi
  00a89	e8 00 00 00 00	 call	 _crypto_close
  00a8e	83 c4 04	 add	 esp, 4
$LN14@EncryptPar:

; 1054 : 		headerCryptoInfo = NULL;
; 1055 : 	}
; 1056 : 
; 1057 : 	if (tmpCryptoInfo != NULL)

  00a91	8b 44 24 5c	 mov	 eax, DWORD PTR _tmpCryptoInfo$[esp+62216]
  00a95	3b c5		 cmp	 eax, ebp
  00a97	74 0d		 je	 SHORT $LN13@EncryptPar

; 1058 : 	{
; 1059 : 		crypto_close (tmpCryptoInfo);

  00a99	50		 push	 eax
  00a9a	e8 00 00 00 00	 call	 _crypto_close
  00a9f	83 c4 04	 add	 esp, 4

; 1060 : 		tmpCryptoInfo = NULL;

  00aa2	89 6c 24 5c	 mov	 DWORD PTR _tmpCryptoInfo$[esp+62216], ebp
$LN13@EncryptPar:

; 1061 : 	}
; 1062 : 
; 1063 : 	if (dosDev[0])

  00aa6	80 bc 24 b0 01
	00 00 00	 cmp	 BYTE PTR _dosDev$[esp+62216], 0
  00aae	74 18		 je	 SHORT $LN12@EncryptPar

; 1064 : 		RemoveFakeDosName (devicePath, dosDev);

  00ab0	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR _devicePath$[esp+62216]
  00ab7	8d 84 24 b0 01
	00 00		 lea	 eax, DWORD PTR _dosDev$[esp+62216]
  00abe	50		 push	 eax
  00abf	51		 push	 ecx
  00ac0	e8 00 00 00 00	 call	 _RemoveFakeDosName
  00ac5	83 c4 08	 add	 esp, 8
$LN12@EncryptPar:

; 1065 : 
; 1066 : 	if (dev != INVALID_HANDLE_VALUE)

  00ac8	83 fb ff	 cmp	 ebx, -1
  00acb	74 07		 je	 SHORT $LN11@EncryptPar

; 1067 : 	{
; 1068 : 		CloseHandle (dev);

  00acd	53		 push	 ebx
  00ace	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN11@EncryptPar:

; 1069 : 		dev = INVALID_HANDLE_VALUE;
; 1070 : 	}
; 1071 : 
; 1072 : 	if (buf != NULL)

  00ad4	8b 44 24 20	 mov	 eax, DWORD PTR _buf$[esp+62216]
  00ad8	3b c5		 cmp	 eax, ebp
  00ada	74 09		 je	 SHORT $LN10@EncryptPar

; 1073 : 		TCfree (buf);

  00adc	50		 push	 eax
  00add	e8 00 00 00 00	 call	 _free
  00ae2	83 c4 04	 add	 esp, 4
$LN10@EncryptPar:

; 1074 : 
; 1075 : 	if (header != NULL)

  00ae5	8b 5c 24 40	 mov	 ebx, DWORD PTR _header$[esp+62216]
  00ae9	3b dd		 cmp	 ebx, ebp
  00aeb	74 32		 je	 SHORT $LN9@EncryptPar

; 1076 : 	{
; 1077 : 		burn (header, TC_VOLUME_HEADER_EFFECTIVE_SIZE);

  00aed	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00af2	8b d3		 mov	 edx, ebx
  00af4	8b f9		 mov	 edi, ecx
  00af6	8b c3		 mov	 eax, ebx
$LL124@EncryptPar:
  00af8	c6 00 00	 mov	 BYTE PTR [eax], 0
  00afb	40		 inc	 eax
  00afc	83 ef 01	 sub	 edi, 1
  00aff	75 f7		 jne	 SHORT $LL124@EncryptPar
$LL5@EncryptPar:
  00b01	49		 dec	 ecx
  00b02	c6 02 00	 mov	 BYTE PTR [edx], 0
  00b05	42		 inc	 edx
  00b06	3b cd		 cmp	 ecx, ebp
  00b08	75 f7		 jne	 SHORT $LL5@EncryptPar

; 1078 : 		VirtualUnlock (header, TC_VOLUME_HEADER_EFFECTIVE_SIZE);

  00b0a	68 00 02 00 00	 push	 512			; 00000200H
  00b0f	53		 push	 ebx
  00b10	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualUnlock@8

; 1079 : 		TCfree (header);

  00b16	53		 push	 ebx
  00b17	e8 00 00 00 00	 call	 _free
  00b1c	83 c4 04	 add	 esp, 4
$LN9@EncryptPar:

; 1080 : 	}
; 1081 : 
; 1082 : 	if (wipeBuffer != NULL)

  00b1f	8b 44 24 58	 mov	 eax, DWORD PTR _wipeBuffer$[esp+62216]
  00b23	3b c5		 cmp	 eax, ebp
  00b25	74 09		 je	 SHORT $LN3@EncryptPar

; 1083 : 		TCfree (wipeBuffer);

  00b27	50		 push	 eax
  00b28	e8 00 00 00 00	 call	 _free
  00b2d	83 c4 04	 add	 esp, 4
$LN3@EncryptPar:

; 1084 : 
; 1085 : 	if (zeroedSectorCount > 0)

  00b30	8b bc 24 88 00
	00 00		 mov	 edi, DWORD PTR _zeroedSectorCount$[esp+62220]
  00b37	8b 9c 24 84 00
	00 00		 mov	 ebx, DWORD PTR _zeroedSectorCount$[esp+62216]
  00b3e	3b fd		 cmp	 edi, ebp
  00b40	77 08		 ja	 SHORT $LN176@EncryptPar
  00b42	3b dd		 cmp	 ebx, ebp
  00b44	0f 86 93 00 00
	00		 jbe	 $LN2@EncryptPar
$LN176@EncryptPar:

; 1086 : 	{
; 1087 : 		wchar_t msg[30000] = {0};

  00b4a	68 5e ea 00 00	 push	 59998			; 0000ea5eH
  00b4f	8d 84 24 aa 08
	00 00		 lea	 eax, DWORD PTR _msg$119897[esp+62222]
  00b56	33 d2		 xor	 edx, edx
  00b58	55		 push	 ebp
  00b59	50		 push	 eax
  00b5a	66 89 94 24 b0
	08 00 00	 mov	 WORD PTR _msg$119897[esp+62228], dx
  00b62	e8 00 00 00 00	 call	 _memset

; 1088 : 		wchar_t sizeStr[500] = {0};

  00b67	68 e6 03 00 00	 push	 998			; 000003e6H
  00b6c	8d 94 24 c6 02
	00 00		 lea	 edx, DWORD PTR _sizeStr$119898[esp+62234]
  00b73	33 c9		 xor	 ecx, ecx
  00b75	55		 push	 ebp
  00b76	52		 push	 edx
  00b77	66 89 8c 24 cc
	02 00 00	 mov	 WORD PTR _sizeStr$119898[esp+62240], cx
  00b7f	e8 00 00 00 00	 call	 _memset
  00b84	83 c4 18	 add	 esp, 24			; 00000018H

; 1089 : 
; 1090 : 		GetSizeString (zeroedSectorCount * sectorSize, sizeStr);

  00b87	8d 84 24 b4 02
	00 00		 lea	 eax, DWORD PTR _sizeStr$119898[esp+62216]
  00b8e	50		 push	 eax
  00b8f	8b 44 24 68	 mov	 eax, DWORD PTR _sectorSize$[esp+62220]
  00b93	57		 push	 edi
  00b94	99		 cdq
  00b95	53		 push	 ebx
  00b96	52		 push	 edx
  00b97	50		 push	 eax
  00b98	e8 00 00 00 00	 call	 __allmul
  00b9d	52		 push	 edx
  00b9e	50		 push	 eax
  00b9f	e8 00 00 00 00	 call	 _GetSizeString
  00ba4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1091 : 
; 1092 : 		wsprintfW (msg, 
; 1093 : 			GetString ("ZEROED_BAD_SECTOR_COUNT"),
; 1094 : 			zeroedSectorCount,
; 1095 : 			sizeStr);

  00ba7	8d 8c 24 b4 02
	00 00		 lea	 ecx, DWORD PTR _sizeStr$119898[esp+62216]
  00bae	51		 push	 ecx
  00baf	57		 push	 edi
  00bb0	53		 push	 ebx
  00bb1	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@KOHPIJFG@ZEROED_BAD_SECTOR_COUNT?$AA@
  00bb6	e8 00 00 00 00	 call	 _GetString
  00bbb	83 c4 04	 add	 esp, 4
  00bbe	50		 push	 eax
  00bbf	8d 94 24 b4 08
	00 00		 lea	 edx, DWORD PTR _msg$119897[esp+62232]
  00bc6	52		 push	 edx
  00bc7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfW

; 1096 : 
; 1097 : 		WarningDirect (msg);

  00bcd	8d 84 24 b8 08
	00 00		 lea	 eax, DWORD PTR _msg$119897[esp+62236]
  00bd4	50		 push	 eax
  00bd5	e8 00 00 00 00	 call	 _WarningDirect
  00bda	83 c4 18	 add	 esp, 24			; 00000018H
$LN2@EncryptPar:

; 1098 : 	}
; 1099 : 
; 1100 : 	if (nStatus != ERR_SUCCESS && nStatus != ERR_USER_ABORT)

  00bdd	3b f5		 cmp	 esi, ebp
  00bdf	74 10		 je	 SHORT $LN186@EncryptPar
  00be1	83 fe 21	 cmp	 esi, 33			; 00000021H
  00be4	74 0b		 je	 SHORT $LN186@EncryptPar

; 1101 : 		SetLastError (dwError);

  00be6	8b 4c 24 30	 mov	 ecx, DWORD PTR _dwError$[esp+62216]
  00bea	51		 push	 ecx
  00beb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
$LN186@EncryptPar:

; 1102 : 
; 1103 : 	return nStatus;
; 1104 : }

  00bf1	8b 8c 24 04 f3
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+62216]
  00bf8	5f		 pop	 edi
  00bf9	8b c6		 mov	 eax, esi
  00bfb	5e		 pop	 esi
  00bfc	5d		 pop	 ebp
  00bfd	5b		 pop	 ebx
  00bfe	33 cc		 xor	 ecx, esp
  00c00	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c05	81 c4 f8 f2 00
	00		 add	 esp, 62200		; 0000f2f8H
  00c0b	c3		 ret	 0
_EncryptPartitionInPlaceResume ENDP
_TEXT	ENDS
PUBLIC	?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEX_NI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy, COMDAT
; _this$ = ecx

; 2149 : 		if (!_Built)

  00000	80 7c 24 04 00	 cmp	 BYTE PTR __Built$[esp-4], 0
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b 7c 24 10	 mov	 edi, DWORD PTR __Newsize$[esp+4]
  0000b	8b f1		 mov	 esi, ecx
  0000d	74 2a		 je	 SHORT $LN17@Tidy

; 2150 : 			;
; 2151 : 		else if (_BUF_SIZE <= _Myres)

  0000f	83 7e 18 08	 cmp	 DWORD PTR [esi+24], 8
  00013	72 24		 jb	 SHORT $LN17@Tidy

; 2152 : 			{	// copy any leftovers to small buffer and deallocate
; 2153 : 			_Elem *_Ptr = _Bx._Ptr;

  00015	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00018	53		 push	 ebx
  00019	8b 18		 mov	 ebx, DWORD PTR [eax]

; 2154 : 			if (0 < _Newsize)

  0001b	85 ff		 test	 edi, edi
  0001d	76 10		 jbe	 SHORT $LN15@Tidy

; 2155 : 				_Traits_helper::copy_s<_Traits>(_Bx._Buf, _BUF_SIZE, _Ptr, _Newsize);

  0001f	8d 0c 3f	 lea	 ecx, DWORD PTR [edi+edi]
  00022	51		 push	 ecx
  00023	53		 push	 ebx
  00024	6a 10		 push	 16			; 00000010H
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 _memcpy_s
  0002c	83 c4 10	 add	 esp, 16			; 00000010H
$LN15@Tidy:

; 2156 : 			_Mybase::_Alval.deallocate(_Ptr, _Myres + 1);

  0002f	53		 push	 ebx
  00030	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00035	83 c4 04	 add	 esp, 4
  00038	5b		 pop	 ebx
$LN17@Tidy:

; 2157 : 			}
; 2158 : 		_Myres = _BUF_SIZE - 1;
; 2159 : 		_Eos(_Newsize);

  00039	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  0003c	c7 46 18 07 00
	00 00		 mov	 DWORD PTR [esi+24], 7
  00043	33 d2		 xor	 edx, edx
  00045	66 89 54 7e 04	 mov	 WORD PTR [esi+edi*2+4], dx
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi

; 2160 : 		}

  0004c	c2 08 00	 ret	 8
?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEX_NI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
tv133 = 8						; size = 4
__Off$ = 8						; size = 4
tv139 = 12						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase, COMDAT
; _this$ = ecx

; 1262 : 		{	// erase elements [_Off, _Off + _Count)

  00000	53		 push	 ebx

; 1263 : 		if (_Mysize < _Off)

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR __Off$[esp]
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	57		 push	 edi
  00009	39 5e 14	 cmp	 DWORD PTR [esi+20], ebx
  0000c	73 05		 jae	 SHORT $LN3@erase

; 1264 : 			_String_base::_Xran();	// _Off off end

  0000e	e8 00 00 00 00	 call	 ?_Xran@_String_base@std@@SAXXZ ; std::_String_base::_Xran
$LN3@erase:

; 1265 : 		if (_Mysize - _Off < _Count)

  00013	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00016	8b 7c 24 14	 mov	 edi, DWORD PTR __Count$[esp+8]
  0001a	2b c3		 sub	 eax, ebx
  0001c	3b c7		 cmp	 eax, edi
  0001e	73 02		 jae	 SHORT $LN2@erase

; 1266 : 			_Count = _Mysize - _Off;	// trim _Count

  00020	8b f8		 mov	 edi, eax
$LN2@erase:

; 1267 : 		if (0 < _Count)

  00022	85 ff		 test	 edi, edi
  00024	76 69		 jbe	 SHORT $LN32@erase

; 1268 : 			{	// move elements down
; 1269 : 			_Traits_helper::move_s<_Traits>(_Myptr() + _Off, _Myres - _Off, _Myptr() + _Off + _Count,
; 1270 : 				_Mysize - _Off - _Count);

  00026	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00029	55		 push	 ebp
  0002a	8d 6e 04	 lea	 ebp, DWORD PTR [esi+4]
  0002d	83 f9 08	 cmp	 ecx, 8
  00030	72 09		 jb	 SHORT $LN8@erase
  00032	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  00035	89 54 24 14	 mov	 DWORD PTR tv133[esp+12], edx
  00039	eb 04		 jmp	 SHORT $LN9@erase
$LN8@erase:
  0003b	89 6c 24 14	 mov	 DWORD PTR tv133[esp+12], ebp
$LN9@erase:
  0003f	83 f9 08	 cmp	 ecx, 8
  00042	72 09		 jb	 SHORT $LN12@erase
  00044	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  00047	89 54 24 18	 mov	 DWORD PTR tv139[esp+12], edx
  0004b	eb 04		 jmp	 SHORT $LN13@erase
$LN12@erase:
  0004d	89 6c 24 18	 mov	 DWORD PTR tv139[esp+12], ebp
$LN13@erase:
  00051	8b 54 24 14	 mov	 edx, DWORD PTR tv133[esp+12]
  00055	2b c7		 sub	 eax, edi
  00057	03 c0		 add	 eax, eax
  00059	50		 push	 eax
  0005a	8d 04 3b	 lea	 eax, DWORD PTR [ebx+edi]
  0005d	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00060	2b cb		 sub	 ecx, ebx
  00062	50		 push	 eax
  00063	03 c9		 add	 ecx, ecx
  00065	51		 push	 ecx
  00066	8b 4c 24 24	 mov	 ecx, DWORD PTR tv139[esp+24]
  0006a	8d 14 59	 lea	 edx, DWORD PTR [ecx+ebx*2]
  0006d	52		 push	 edx
  0006e	e8 00 00 00 00	 call	 _memmove_s

; 1271 : 			size_type _Newsize = _Mysize - _Count;

  00073	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00076	2b c7		 sub	 eax, edi
  00078	83 c4 10	 add	 esp, 16			; 00000010H

; 1272 : 			_Eos(_Newsize);

  0007b	83 7e 18 08	 cmp	 DWORD PTR [esi+24], 8
  0007f	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00082	72 03		 jb	 SHORT $LN28@erase
  00084	8b 6d 00	 mov	 ebp, DWORD PTR [ebp]
$LN28@erase:
  00087	33 c9		 xor	 ecx, ecx
  00089	66 89 4c 45 00	 mov	 WORD PTR [ebp+eax*2], cx
  0008e	5d		 pop	 ebp
$LN32@erase:
  0008f	5f		 pop	 edi

; 1273 : 			}
; 1274 : 		return (*this);

  00090	8b c6		 mov	 eax, esi
  00092	5e		 pop	 esi
  00093	5b		 pop	 ebx

; 1275 : 		}

  00094	c2 08 00	 ret	 8
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
_TEXT	ENDS
PUBLIC	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z$0
__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z
_TEXT	SEGMENT
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newres$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy, COMDAT
; _this$ = ecx

; 2083 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx
  0002d	89 7d ec	 mov	 DWORD PTR _this$[ebp], edi

; 2084 : 		size_type _Newres = _Newsize | _ALLOC_MASK;

  00030	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00033	8b f0		 mov	 esi, eax
  00035	83 ce 07	 or	 esi, 7

; 2085 : 		if (max_size() < _Newres)

  00038	81 fe fe ff ff
	7f		 cmp	 esi, 2147483646		; 7ffffffeH
  0003e	76 04		 jbe	 SHORT $LN6@Copy@2

; 2086 : 			_Newres = _Newsize;	// undo roundup if too big

  00040	8b f0		 mov	 esi, eax

; 2087 : 		else if (_Newres / 3 < _Myres / 2

  00042	eb 22		 jmp	 SHORT $LN4@Copy@2
$LN6@Copy@2:

; 2088 : 			&& _Myres <= max_size() - _Myres / 2)

  00044	8b 5f 18	 mov	 ebx, DWORD PTR [edi+24]
  00047	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0004c	f7 e6		 mul	 esi
  0004e	8b cb		 mov	 ecx, ebx
  00050	d1 e9		 shr	 ecx, 1
  00052	d1 ea		 shr	 edx, 1
  00054	3b d1		 cmp	 edx, ecx
  00056	73 0e		 jae	 SHORT $LN4@Copy@2
  00058	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH
  0005d	2b c1		 sub	 eax, ecx
  0005f	3b d8		 cmp	 ebx, eax
  00061	77 03		 ja	 SHORT $LN4@Copy@2

; 2089 : 			_Newres = _Myres + _Myres / 2;	// grow exponentially if possible

  00063	8d 34 19	 lea	 esi, DWORD PTR [ecx+ebx]
$LN4@Copy@2:

; 2090 : 		_Elem *_Ptr = 0;
; 2091 : 
; 2092 : 		_TRY_BEGIN
; 2093 : 			_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

  00066	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  00069	6a 00		 push	 0
  0006b	51		 push	 ecx
  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00073	e8 00 00 00 00	 call	 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z ; std::_Allocate<wchar_t>
  00078	83 c4 08	 add	 esp, 8
  0007b	8b d8		 mov	 ebx, eax
  0007d	eb 2b		 jmp	 SHORT $LN16@Copy@2
__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z$0:

; 2094 : 		_CATCH_ALL
; 2095 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  0007f	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00082	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00085	89 45 08	 mov	 DWORD PTR __Newres$[ebp], eax

; 2096 : 			_TRY_BEGIN
; 2097 : 				_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

  00088	40		 inc	 eax
  00089	6a 00		 push	 0
  0008b	50		 push	 eax
  0008c	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00090	e8 00 00 00 00	 call	 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z ; std::_Allocate<wchar_t>
  00095	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
  00098	83 c4 08	 add	 esp, 8

; 2101 : 			_CATCH_END
; 2102 : 		_CATCH_END

  0009b	b8 00 00 00 00	 mov	 eax, $LN112@Copy@2
  000a0	c3		 ret	 0
$LN112@Copy@2:
  000a1	8b 7d ec	 mov	 edi, DWORD PTR _this$[ebp]
  000a4	8b 75 08	 mov	 esi, DWORD PTR __Newres$[ebp]
  000a7	8b 5d e8	 mov	 ebx, DWORD PTR __Ptr$[ebp]
$LN16@Copy@2:

; 2103 : 
; 2104 : 		if (0 < _Oldlen)

  000aa	8b 4d 0c	 mov	 ecx, DWORD PTR __Oldlen$[ebp]
  000ad	85 c9		 test	 ecx, ecx
  000af	76 24		 jbe	 SHORT $LN75@Copy@2

; 2105 : 			_Traits_helper::copy_s<_Traits>(_Ptr, _Newres + 1, _Myptr(), _Oldlen);	// copy existing elements

  000b1	83 7f 18 08	 cmp	 DWORD PTR [edi+24], 8
  000b5	72 05		 jb	 SHORT $LN65@Copy@2
  000b7	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000ba	eb 03		 jmp	 SHORT $LN66@Copy@2
$LN65@Copy@2:
  000bc	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
$LN66@Copy@2:
  000bf	8d 14 09	 lea	 edx, DWORD PTR [ecx+ecx]
  000c2	52		 push	 edx
  000c3	50		 push	 eax
  000c4	8d 44 36 02	 lea	 eax, DWORD PTR [esi+esi+2]
  000c8	50		 push	 eax
  000c9	53		 push	 ebx
  000ca	e8 00 00 00 00	 call	 _memcpy_s
  000cf	8b 4d 0c	 mov	 ecx, DWORD PTR __Oldlen$[ebp]
  000d2	83 c4 10	 add	 esp, 16			; 00000010H
$LN75@Copy@2:

; 2106 : 		_Tidy(true);

  000d5	83 7f 18 08	 cmp	 DWORD PTR [edi+24], 8
  000d9	72 0f		 jb	 SHORT $LN93@Copy@2
  000db	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000de	51		 push	 ecx
  000df	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000e4	8b 4d 0c	 mov	 ecx, DWORD PTR __Oldlen$[ebp]
  000e7	83 c4 04	 add	 esp, 4
$LN93@Copy@2:
  000ea	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  000ed	33 d2		 xor	 edx, edx

; 2107 : 		_Bx._Ptr = _Ptr;

  000ef	89 18		 mov	 DWORD PTR [eax], ebx

; 2108 : 		_Myres = _Newres;

  000f1	89 77 18	 mov	 DWORD PTR [edi+24], esi

; 2109 : 		_Eos(_Oldlen);

  000f4	89 4f 14	 mov	 DWORD PTR [edi+20], ecx
  000f7	83 fe 08	 cmp	 esi, 8
  000fa	72 02		 jb	 SHORT $LN107@Copy@2
  000fc	8b c3		 mov	 eax, ebx
$LN107@Copy@2:
  000fe	33 d2		 xor	 edx, edx
  00100	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx

; 2110 : 		}

  00104	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00107	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0010e	59		 pop	 ecx
  0010f	5f		 pop	 edi
  00110	5e		 pop	 esi
  00111	5b		 pop	 ebx
  00112	8b e5		 mov	 esp, ebp
  00114	5d		 pop	 ebp
  00115	c2 08 00	 ret	 8
__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z$1:

; 2098 : 			_CATCH_ALL
; 2099 : 			_Tidy(true);	// failed again, discard storage and reraise

  00118	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  0011b	83 7e 18 08	 cmp	 DWORD PTR [esi+24], 8
  0011f	72 0c		 jb	 SHORT $LN53@Copy@2
  00121	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00124	50		 push	 eax
  00125	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0012a	83 c4 04	 add	 esp, 4
$LN53@Copy@2:
  0012d	33 c9		 xor	 ecx, ecx

; 2100 : 			_RERAISE;

  0012f	51		 push	 ecx
  00130	c7 46 18 07 00
	00 00		 mov	 DWORD PTR [esi+24], 7
  00137	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  0013e	51		 push	 ecx
  0013f	66 89 4e 04	 mov	 WORD PTR [esi+4], cx
  00143	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN115@Copy@2:
  00148	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
PUBLIC	??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\string
;	COMDAT ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z PROC ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 94   : 	return (_Left.compare(_Right) == 0);

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Right$[esp-4]
  00004	8b c2		 mov	 eax, edx
  00006	56		 push	 esi
  00007	8d 70 02	 lea	 esi, DWORD PTR [eax+2]
  0000a	8d 9b 00 00 00
	00		 npad	 6
$LL7@operator@2:
  00010	66 8b 08	 mov	 cx, WORD PTR [eax]
  00013	83 c0 02	 add	 eax, 2
  00016	66 85 c9	 test	 cx, cx
  00019	75 f5		 jne	 SHORT $LL7@operator@2
  0001b	8b 4c 24 08	 mov	 ecx, DWORD PTR __Left$[esp]
  0001f	2b c6		 sub	 eax, esi
  00021	d1 f8		 sar	 eax, 1
  00023	50		 push	 eax
  00024	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00027	52		 push	 edx
  00028	50		 push	 eax
  00029	6a 00		 push	 0
  0002b	e8 00 00 00 00	 call	 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::compare
  00030	f7 d8		 neg	 eax
  00032	1b c0		 sbb	 eax, eax
  00034	40		 inc	 eax
  00035	5e		 pop	 esi

; 95   : 	}

  00036	c3		 ret	 0
??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ENDP ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 905  : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 906  : 		_Tidy(true);

  00003	83 7e 18 08	 cmp	 DWORD PTR [esi+24], 8
  00007	72 0c		 jb	 SHORT $LN19@basic_stri
  00009	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00012	83 c4 04	 add	 esp, 4
$LN19@basic_stri:
  00015	c7 46 18 07 00
	00 00		 mov	 DWORD PTR [esi+24], 7
  0001c	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00023	33 c9		 xor	 ecx, ecx
  00025	66 89 4e 04	 mov	 WORD PTR [esi+4], cx
  00029	5e		 pop	 esi

; 907  : 		}

  0002a	c3		 ret	 0
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
PUBLIC	?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
EXTRN	?_Xlen@_String_base@std@@SAXXZ:PROC		; std::_String_base::_Xlen
; Function compile flags: /Ogtpy
;	COMDAT ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAE_NI_N@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow, COMDAT
; _this$ = ecx

; 2119 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp

; 2120 : 			if (max_size() < _Newsize)

  00001	8b 6c 24 08	 mov	 ebp, DWORD PTR __Newsize$[esp]
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	81 fd fe ff ff
	7f		 cmp	 ebp, 2147483646		; 7ffffffeH
  0000e	76 05		 jbe	 SHORT $LN6@Grow

; 2121 : 			_String_base::_Xlen();	// result too long

  00010	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@SAXXZ ; std::_String_base::_Xlen
$LN6@Grow:

; 2122 : 		if (_Myres < _Newsize)

  00015	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00018	3b c5		 cmp	 eax, ebp
  0001a	73 19		 jae	 SHORT $LN5@Grow

; 2123 : 			_Copy(_Newsize, _Mysize);	// reallocate to grow

  0001c	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0001f	50		 push	 eax
  00020	55		 push	 ebp
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy

; 2129 : 		return (0 < _Newsize);	// return true only if more work to do

  00028	33 c9		 xor	 ecx, ecx
  0002a	3b cd		 cmp	 ecx, ebp
  0002c	1b c0		 sbb	 eax, eax
  0002e	5e		 pop	 esi
  0002f	f7 d8		 neg	 eax
  00031	5d		 pop	 ebp

; 2130 : 		}

  00032	c2 08 00	 ret	 8
$LN5@Grow:

; 2124 : 		else if (_Trim && _Newsize < _BUF_SIZE)

  00035	80 7c 24 10 00	 cmp	 BYTE PTR __Trim$[esp+4], 0
  0003a	74 57		 je	 SHORT $LN3@Grow
  0003c	83 fd 08	 cmp	 ebp, 8
  0003f	73 52		 jae	 SHORT $LN3@Grow
  00041	57		 push	 edi

; 2125 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2126 : 				_Newsize < _Mysize ? _Newsize : _Mysize);

  00042	8b 7e 14	 mov	 edi, DWORD PTR [esi+20]
  00045	3b ef		 cmp	 ebp, edi
  00047	73 02		 jae	 SHORT $LN9@Grow
  00049	8b fd		 mov	 edi, ebp
$LN9@Grow:
  0004b	83 f8 08	 cmp	 eax, 8
  0004e	72 24		 jb	 SHORT $LN35@Grow
  00050	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00053	53		 push	 ebx
  00054	8b 18		 mov	 ebx, DWORD PTR [eax]
  00056	85 ff		 test	 edi, edi
  00058	76 10		 jbe	 SHORT $LN33@Grow
  0005a	8d 0c 3f	 lea	 ecx, DWORD PTR [edi+edi]
  0005d	51		 push	 ecx
  0005e	53		 push	 ebx
  0005f	6a 10		 push	 16			; 00000010H
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 _memcpy_s
  00067	83 c4 10	 add	 esp, 16			; 00000010H
$LN33@Grow:
  0006a	53		 push	 ebx
  0006b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00070	83 c4 04	 add	 esp, 4
  00073	5b		 pop	 ebx
$LN35@Grow:
  00074	33 d2		 xor	 edx, edx
  00076	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00079	c7 46 18 07 00
	00 00		 mov	 DWORD PTR [esi+24], 7

; 2129 : 		return (0 < _Newsize);	// return true only if more work to do

  00080	33 c9		 xor	 ecx, ecx
  00082	66 89 54 7e 04	 mov	 WORD PTR [esi+edi*2+4], dx
  00087	3b cd		 cmp	 ecx, ebp
  00089	5f		 pop	 edi
  0008a	1b c0		 sbb	 eax, eax
  0008c	5e		 pop	 esi
  0008d	f7 d8		 neg	 eax
  0008f	5d		 pop	 ebp

; 2130 : 		}

  00090	c2 08 00	 ret	 8
$LN3@Grow:

; 2127 : 		else if (_Newsize == 0)

  00093	85 ed		 test	 ebp, ebp
  00095	75 25		 jne	 SHORT $LN51@Grow

; 2128 : 			_Eos(0);	// new size is zero, just null terminate

  00097	89 6e 14	 mov	 DWORD PTR [esi+20], ebp
  0009a	83 f8 08	 cmp	 eax, 8
  0009d	72 15		 jb	 SHORT $LN49@Grow
  0009f	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  000a2	33 c0		 xor	 eax, eax

; 2129 : 		return (0 < _Newsize);	// return true only if more work to do

  000a4	33 c9		 xor	 ecx, ecx
  000a6	3b cd		 cmp	 ecx, ebp
  000a8	66 89 06	 mov	 WORD PTR [esi], ax
  000ab	1b c0		 sbb	 eax, eax
  000ad	5e		 pop	 esi
  000ae	f7 d8		 neg	 eax
  000b0	5d		 pop	 ebp

; 2130 : 		}

  000b1	c2 08 00	 ret	 8

; 2128 : 			_Eos(0);	// new size is zero, just null terminate

$LN49@Grow:
  000b4	83 c6 04	 add	 esi, 4
  000b7	33 c0		 xor	 eax, eax
  000b9	66 89 06	 mov	 WORD PTR [esi], ax
$LN51@Grow:

; 2129 : 		return (0 < _Newsize);	// return true only if more work to do

  000bc	33 c9		 xor	 ecx, ecx
  000be	3b cd		 cmp	 ecx, ebp
  000c0	1b c0		 sbb	 eax, eax
  000c2	5e		 pop	 esi
  000c3	f7 d8		 neg	 eax
  000c5	5d		 pop	 ebp

; 2130 : 		}

  000c6	c2 08 00	 ret	 8
?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAE_NI_N@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
_TEXT	ENDS
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
; Function compile flags: /Ogtpy
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 951  : 		{	// append _Right [_Roff, _Roff + _Count)

  00000	53		 push	 ebx
  00001	55		 push	 ebp

; 952  : 		if (_Right.size() < _Roff)

  00002	8b 6c 24 0c	 mov	 ebp, DWORD PTR __Right$[esp+4]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b 7c 24 18	 mov	 edi, DWORD PTR __Roff$[esp+12]
  0000c	8b f1		 mov	 esi, ecx
  0000e	39 7d 14	 cmp	 DWORD PTR [ebp+20], edi
  00011	73 05		 jae	 SHORT $LN5@append

; 953  : 			_String_base::_Xran();	// _Roff off end

  00013	e8 00 00 00 00	 call	 ?_Xran@_String_base@std@@SAXXZ ; std::_String_base::_Xran
$LN5@append:

; 954  : 		size_type _Num = _Right.size() - _Roff;

  00018	8b 45 14	 mov	 eax, DWORD PTR [ebp+20]

; 955  : 		if (_Num < _Count)

  0001b	8b 5c 24 1c	 mov	 ebx, DWORD PTR __Count$[esp+12]
  0001f	2b c7		 sub	 eax, edi
  00021	3b c3		 cmp	 eax, ebx
  00023	73 02		 jae	 SHORT $LN4@append

; 956  : 			_Count = _Num;	// trim _Count to size

  00025	8b d8		 mov	 ebx, eax
$LN4@append:

; 957  : 		if (npos - _Mysize <= _Count || _Mysize + _Count < _Mysize)

  00027	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002a	83 c9 ff	 or	 ecx, -1
  0002d	2b c8		 sub	 ecx, eax
  0002f	3b cb		 cmp	 ecx, ebx
  00031	76 07		 jbe	 SHORT $LN2@append
  00033	8d 14 18	 lea	 edx, DWORD PTR [eax+ebx]
  00036	3b d0		 cmp	 edx, eax
  00038	73 05		 jae	 SHORT $LN3@append
$LN2@append:

; 958  : 			_String_base::_Xlen();	// result too long

  0003a	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@SAXXZ ; std::_String_base::_Xlen
$LN3@append:

; 959  : 
; 960  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

  0003f	85 db		 test	 ebx, ebx
  00041	0f 86 bd 00 00
	00		 jbe	 $LN91@append
  00047	8b 7e 14	 mov	 edi, DWORD PTR [esi+20]
  0004a	03 fb		 add	 edi, ebx
  0004c	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00052	76 05		 jbe	 SHORT $LN17@append
  00054	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@SAXXZ ; std::_String_base::_Xlen
$LN17@append:
  00059	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0005c	3b c7		 cmp	 eax, edi
  0005e	73 1f		 jae	 SHORT $LN16@append
  00060	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00063	50		 push	 eax
  00064	57		 push	 edi
  00065	8b ce		 mov	 ecx, esi
  00067	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  0006c	85 ff		 test	 edi, edi
$LN92@append:
  0006e	0f 86 90 00 00
	00		 jbe	 $LN91@append

; 961  : 			{	// make room and append new stuff
; 962  : 			_Traits_helper::copy_s<_Traits>(_Myptr() + _Mysize, _Myres - _Mysize,
; 963  : 				_Right._Myptr() + _Roff, _Count);

  00074	83 7d 18 08	 cmp	 DWORD PTR [ebp+24], 8
  00078	72 33		 jb	 SHORT $LN66@append
  0007a	8b 6d 04	 mov	 ebp, DWORD PTR [ebp+4]
  0007d	eb 31		 jmp	 SHORT $LN67@append

; 959  : 
; 960  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN16@append:
  0007f	85 ff		 test	 edi, edi
  00081	75 eb		 jne	 SHORT $LN92@append
  00083	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00086	83 f8 08	 cmp	 eax, 8
  00089	72 11		 jb	 SHORT $LN60@append
  0008b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0008e	33 c9		 xor	 ecx, ecx
  00090	5f		 pop	 edi
  00091	66 89 08	 mov	 WORD PTR [eax], cx

; 965  : 			}
; 966  : 		return (*this);

  00094	8b c6		 mov	 eax, esi
  00096	5e		 pop	 esi
  00097	5d		 pop	 ebp
  00098	5b		 pop	 ebx

; 967  : 		}

  00099	c2 0c 00	 ret	 12			; 0000000cH

; 959  : 
; 960  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN60@append:
  0009c	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0009f	33 c9		 xor	 ecx, ecx
  000a1	5f		 pop	 edi
  000a2	66 89 08	 mov	 WORD PTR [eax], cx

; 965  : 			}
; 966  : 		return (*this);

  000a5	8b c6		 mov	 eax, esi
  000a7	5e		 pop	 esi
  000a8	5d		 pop	 ebp
  000a9	5b		 pop	 ebx

; 967  : 		}

  000aa	c2 0c 00	 ret	 12			; 0000000cH

; 961  : 			{	// make room and append new stuff
; 962  : 			_Traits_helper::copy_s<_Traits>(_Myptr() + _Mysize, _Myres - _Mysize,
; 963  : 				_Right._Myptr() + _Roff, _Count);

$LN66@append:
  000ad	83 c5 04	 add	 ebp, 4
$LN67@append:
  000b0	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  000b3	83 f8 08	 cmp	 eax, 8
  000b6	72 05		 jb	 SHORT $LN70@append
  000b8	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  000bb	eb 03		 jmp	 SHORT $LN71@append
$LN70@append:
  000bd	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
$LN71@append:
  000c0	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  000c3	03 db		 add	 ebx, ebx
  000c5	53		 push	 ebx
  000c6	8b 5c 24 1c	 mov	 ebx, DWORD PTR __Roff$[esp+16]
  000ca	2b c1		 sub	 eax, ecx
  000cc	8d 5c 5d 00	 lea	 ebx, DWORD PTR [ebp+ebx*2]
  000d0	53		 push	 ebx
  000d1	03 c0		 add	 eax, eax
  000d3	50		 push	 eax
  000d4	8d 14 4a	 lea	 edx, DWORD PTR [edx+ecx*2]
  000d7	52		 push	 edx
  000d8	e8 00 00 00 00	 call	 _memcpy_s
  000dd	83 c4 10	 add	 esp, 16			; 00000010H

; 964  : 			_Eos(_Num);

  000e0	83 7e 18 08	 cmp	 DWORD PTR [esi+24], 8
  000e4	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  000e7	72 12		 jb	 SHORT $LN86@append
  000e9	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000ec	33 c9		 xor	 ecx, ecx
  000ee	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
  000f2	5f		 pop	 edi

; 965  : 			}
; 966  : 		return (*this);

  000f3	8b c6		 mov	 eax, esi
  000f5	5e		 pop	 esi
  000f6	5d		 pop	 ebp
  000f7	5b		 pop	 ebx

; 967  : 		}

  000f8	c2 0c 00	 ret	 12			; 0000000cH

; 964  : 			_Eos(_Num);

$LN86@append:
  000fb	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  000fe	33 c9		 xor	 ecx, ecx
  00100	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN91@append:
  00104	5f		 pop	 edi

; 965  : 			}
; 966  : 		return (*this);

  00105	8b c6		 mov	 eax, esi
  00107	5e		 pop	 esi
  00108	5d		 pop	 ebp
  00109	5b		 pop	 ebx

; 967  : 		}

  0010a	c2 0c 00	 ret	 12			; 0000000cH
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
; Function compile flags: /Ogtpy
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 970  : 		{	// append [_Ptr, _Ptr + _Count)

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 971  : 
; 972  :  #if _HAS_ITERATOR_DEBUGGING
; 973  : 		if (_Count != 0)
; 974  : 			_DEBUG_POINTER(_Ptr);
; 975  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 976  : 
; 977  : 		if (_Inside(_Ptr))

  00004	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Ptr$[esp+4]
  00008	57		 push	 edi
  00009	85 c9		 test	 ecx, ecx
  0000b	74 49		 je	 SHORT $LN4@append@2
  0000d	8b 7e 18	 mov	 edi, DWORD PTR [esi+24]
  00010	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00013	83 ff 08	 cmp	 edi, 8
  00016	72 04		 jb	 SHORT $LN14@append@2
  00018	8b 10		 mov	 edx, DWORD PTR [eax]
  0001a	eb 02		 jmp	 SHORT $LN15@append@2
$LN14@append@2:
  0001c	8b d0		 mov	 edx, eax
$LN15@append@2:
  0001e	3b ca		 cmp	 ecx, edx
  00020	72 34		 jb	 SHORT $LN4@append@2
  00022	83 ff 08	 cmp	 edi, 8
  00025	72 04		 jb	 SHORT $LN18@append@2
  00027	8b 10		 mov	 edx, DWORD PTR [eax]
  00029	eb 02		 jmp	 SHORT $LN19@append@2
$LN18@append@2:
  0002b	8b d0		 mov	 edx, eax
$LN19@append@2:
  0002d	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  00030	8d 14 5a	 lea	 edx, DWORD PTR [edx+ebx*2]
  00033	3b d1		 cmp	 edx, ecx
  00035	76 1f		 jbe	 SHORT $LN4@append@2

; 978  : 			return (append(*this, _Ptr - _Myptr(), _Count));	// substring

  00037	83 ff 08	 cmp	 edi, 8
  0003a	72 02		 jb	 SHORT $LN22@append@2
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN22@append@2:
  0003e	8b 54 24 14	 mov	 edx, DWORD PTR __Count$[esp+8]
  00042	2b c8		 sub	 ecx, eax
  00044	52		 push	 edx
  00045	d1 f9		 sar	 ecx, 1
  00047	51		 push	 ecx
  00048	56		 push	 esi
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx

; 989  : 		}

  00053	c2 08 00	 ret	 8
$LN4@append@2:

; 979  : 		if (npos - _Mysize <= _Count || _Mysize + _Count < _Mysize)

  00056	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00059	83 c9 ff	 or	 ecx, -1
  0005c	55		 push	 ebp
  0005d	8b 6c 24 18	 mov	 ebp, DWORD PTR __Count$[esp+12]
  00061	2b c8		 sub	 ecx, eax
  00063	3b cd		 cmp	 ecx, ebp
  00065	76 07		 jbe	 SHORT $LN2@append@2
  00067	8d 14 28	 lea	 edx, DWORD PTR [eax+ebp]
  0006a	3b d0		 cmp	 edx, eax
  0006c	73 05		 jae	 SHORT $LN3@append@2
$LN2@append@2:

; 980  : 			_String_base::_Xlen();	// result too long

  0006e	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@SAXXZ ; std::_String_base::_Xlen
$LN3@append@2:

; 981  : 
; 982  : 		size_type _Num;
; 983  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

  00073	85 ed		 test	 ebp, ebp
  00075	0f 86 95 00 00
	00		 jbe	 $LN96@append@2
  0007b	8b 7e 14	 mov	 edi, DWORD PTR [esi+20]
  0007e	03 fd		 add	 edi, ebp
  00080	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00086	76 05		 jbe	 SHORT $LN29@append@2
  00088	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@SAXXZ ; std::_String_base::_Xlen
$LN29@append@2:
  0008d	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00090	3b c7		 cmp	 eax, edi
  00092	73 1f		 jae	 SHORT $LN28@append@2
  00094	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00097	50		 push	 eax
  00098	57		 push	 edi
  00099	8b ce		 mov	 ecx, esi
  0009b	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  000a0	85 ff		 test	 edi, edi
$LN99@append@2:
  000a2	76 6c		 jbe	 SHORT $LN96@append@2

; 984  : 			{	// make room and append new stuff
; 985  : 			_Traits_helper::copy_s<_Traits>(_Myptr() + _Mysize, _Myres - _Mysize, _Ptr, _Count);

  000a4	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  000a7	8d 5e 04	 lea	 ebx, DWORD PTR [esi+4]
  000aa	83 f8 08	 cmp	 eax, 8
  000ad	72 32		 jb	 SHORT $LN78@append@2
  000af	8b 13		 mov	 edx, DWORD PTR [ebx]
  000b1	eb 30		 jmp	 SHORT $LN79@append@2

; 981  : 
; 982  : 		size_type _Num;
; 983  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN28@append@2:
  000b3	85 ff		 test	 edi, edi
  000b5	75 eb		 jne	 SHORT $LN99@append@2
  000b7	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  000ba	83 f8 08	 cmp	 eax, 8
  000bd	72 11		 jb	 SHORT $LN72@append@2
  000bf	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000c2	5d		 pop	 ebp
  000c3	33 c9		 xor	 ecx, ecx
  000c5	5f		 pop	 edi
  000c6	66 89 08	 mov	 WORD PTR [eax], cx

; 987  : 			}
; 988  : 		return (*this);

  000c9	8b c6		 mov	 eax, esi
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx

; 989  : 		}

  000cd	c2 08 00	 ret	 8

; 981  : 
; 982  : 		size_type _Num;
; 983  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN72@append@2:
  000d0	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  000d3	5d		 pop	 ebp
  000d4	33 c9		 xor	 ecx, ecx
  000d6	5f		 pop	 edi
  000d7	66 89 08	 mov	 WORD PTR [eax], cx

; 987  : 			}
; 988  : 		return (*this);

  000da	8b c6		 mov	 eax, esi
  000dc	5e		 pop	 esi
  000dd	5b		 pop	 ebx

; 989  : 		}

  000de	c2 08 00	 ret	 8

; 984  : 			{	// make room and append new stuff
; 985  : 			_Traits_helper::copy_s<_Traits>(_Myptr() + _Mysize, _Myres - _Mysize, _Ptr, _Count);

$LN78@append@2:
  000e1	8b d3		 mov	 edx, ebx
$LN79@append@2:
  000e3	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  000e6	03 ed		 add	 ebp, ebp
  000e8	55		 push	 ebp
  000e9	8b 6c 24 18	 mov	 ebp, DWORD PTR __Ptr$[esp+16]
  000ed	2b c1		 sub	 eax, ecx
  000ef	55		 push	 ebp
  000f0	03 c0		 add	 eax, eax
  000f2	50		 push	 eax
  000f3	8d 14 4a	 lea	 edx, DWORD PTR [edx+ecx*2]
  000f6	52		 push	 edx
  000f7	e8 00 00 00 00	 call	 _memcpy_s
  000fc	83 c4 10	 add	 esp, 16			; 00000010H

; 986  : 			_Eos(_Num);

  000ff	83 7e 18 08	 cmp	 DWORD PTR [esi+24], 8
  00103	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00106	72 02		 jb	 SHORT $LN94@append@2
  00108	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN94@append@2:
  0010a	33 c0		 xor	 eax, eax
  0010c	66 89 04 7b	 mov	 WORD PTR [ebx+edi*2], ax
$LN96@append@2:
  00110	5d		 pop	 ebp
  00111	5f		 pop	 edi

; 987  : 			}
; 988  : 		return (*this);

  00112	8b c6		 mov	 eax, esi
  00114	5e		 pop	 esi
  00115	5b		 pop	 ebx

; 989  : 		}

  00116	c2 08 00	 ret	 8
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; Function compile flags: /Ogtpy
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1046 : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	53		 push	 ebx

; 1047 : 		if (_Right.size() < _Roff)

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR __Roff$[esp]
  00005	55		 push	 ebp
  00006	8b 6c 24 0c	 mov	 ebp, DWORD PTR __Right$[esp+4]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f1		 mov	 esi, ecx
  0000e	39 5d 14	 cmp	 DWORD PTR [ebp+20], ebx
  00011	73 05		 jae	 SHORT $LN5@assign

; 1048 : 			_String_base::_Xran();	// _Roff off end

  00013	e8 00 00 00 00	 call	 ?_Xran@_String_base@std@@SAXXZ ; std::_String_base::_Xran
$LN5@assign:

; 1049 : 		size_type _Num = _Right.size() - _Roff;

  00018	8b 7d 14	 mov	 edi, DWORD PTR [ebp+20]

; 1050 : 		if (_Count < _Num)

  0001b	8b 44 24 1c	 mov	 eax, DWORD PTR __Count$[esp+12]
  0001f	2b fb		 sub	 edi, ebx
  00021	3b c7		 cmp	 eax, edi
  00023	73 02		 jae	 SHORT $LN4@assign

; 1051 : 			_Num = _Count;	// trim _Num to size

  00025	8b f8		 mov	 edi, eax
$LN4@assign:

; 1052 : 
; 1053 : 		if (this == &_Right)

  00027	3b f5		 cmp	 esi, ebp
  00029	75 1f		 jne	 SHORT $LN3@assign

; 1054 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  0002b	6a ff		 push	 -1
  0002d	03 fb		 add	 edi, ebx
  0002f	57		 push	 edi
  00030	8b ce		 mov	 ecx, esi
  00032	e8 00 00 00 00	 call	 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
  00037	53		 push	 ebx
  00038	6a 00		 push	 0
  0003a	8b ce		 mov	 ecx, esi
  0003c	e8 00 00 00 00	 call	 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
  00041	5f		 pop	 edi

; 1059 : 			}
; 1060 : 		return (*this);

  00042	8b c6		 mov	 eax, esi
  00044	5e		 pop	 esi
  00045	5d		 pop	 ebp
  00046	5b		 pop	 ebx

; 1061 : 		}

  00047	c2 0c 00	 ret	 12			; 0000000cH
$LN3@assign:

; 1055 : 		else if (_Grow(_Num))

  0004a	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00050	76 05		 jbe	 SHORT $LN17@assign
  00052	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@SAXXZ ; std::_String_base::_Xlen
$LN17@assign:
  00057	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0005a	3b c7		 cmp	 eax, edi
  0005c	73 1b		 jae	 SHORT $LN16@assign
  0005e	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00061	50		 push	 eax
  00062	57		 push	 edi
  00063	8b ce		 mov	 ecx, esi
  00065	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  0006a	85 ff		 test	 edi, edi
$LN91@assign:
  0006c	76 7a		 jbe	 SHORT $LN90@assign

; 1056 : 			{	// make room and assign new stuff
; 1057 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Right._Myptr() + _Roff, _Num);

  0006e	83 7d 18 08	 cmp	 DWORD PTR [ebp+24], 8
  00072	72 33		 jb	 SHORT $LN66@assign
  00074	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  00077	eb 31		 jmp	 SHORT $LN67@assign

; 1055 : 		else if (_Grow(_Num))

$LN16@assign:
  00079	85 ff		 test	 edi, edi
  0007b	75 ef		 jne	 SHORT $LN91@assign
  0007d	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00080	83 f8 08	 cmp	 eax, 8
  00083	72 11		 jb	 SHORT $LN60@assign
  00085	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00088	33 c9		 xor	 ecx, ecx
  0008a	5f		 pop	 edi
  0008b	66 89 08	 mov	 WORD PTR [eax], cx

; 1059 : 			}
; 1060 : 		return (*this);

  0008e	8b c6		 mov	 eax, esi
  00090	5e		 pop	 esi
  00091	5d		 pop	 ebp
  00092	5b		 pop	 ebx

; 1061 : 		}

  00093	c2 0c 00	 ret	 12			; 0000000cH

; 1055 : 		else if (_Grow(_Num))

$LN60@assign:
  00096	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00099	33 c9		 xor	 ecx, ecx
  0009b	5f		 pop	 edi
  0009c	66 89 08	 mov	 WORD PTR [eax], cx

; 1059 : 			}
; 1060 : 		return (*this);

  0009f	8b c6		 mov	 eax, esi
  000a1	5e		 pop	 esi
  000a2	5d		 pop	 ebp
  000a3	5b		 pop	 ebx

; 1061 : 		}

  000a4	c2 0c 00	 ret	 12			; 0000000cH

; 1056 : 			{	// make room and assign new stuff
; 1057 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Right._Myptr() + _Roff, _Num);

$LN66@assign:
  000a7	8d 4d 04	 lea	 ecx, DWORD PTR [ebp+4]
$LN67@assign:
  000aa	83 7e 18 08	 cmp	 DWORD PTR [esi+24], 8
  000ae	8d 6e 04	 lea	 ebp, DWORD PTR [esi+4]
  000b1	72 05		 jb	 SHORT $LN70@assign
  000b3	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  000b6	eb 02		 jmp	 SHORT $LN71@assign
$LN70@assign:
  000b8	8b c5		 mov	 eax, ebp
$LN71@assign:
  000ba	8b 54 24 18	 mov	 edx, DWORD PTR __Roff$[esp+12]
  000be	8d 0c 51	 lea	 ecx, DWORD PTR [ecx+edx*2]
  000c1	8d 1c 3f	 lea	 ebx, DWORD PTR [edi+edi]
  000c4	53		 push	 ebx
  000c5	51		 push	 ecx
  000c6	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  000c9	8d 14 09	 lea	 edx, DWORD PTR [ecx+ecx]
  000cc	52		 push	 edx
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 _memcpy_s
  000d3	83 c4 10	 add	 esp, 16			; 00000010H

; 1058 : 			_Eos(_Num);

  000d6	83 7e 18 08	 cmp	 DWORD PTR [esi+24], 8
  000da	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  000dd	72 03		 jb	 SHORT $LN86@assign
  000df	8b 6d 00	 mov	 ebp, DWORD PTR [ebp]
$LN86@assign:
  000e2	33 c0		 xor	 eax, eax
  000e4	66 89 04 2b	 mov	 WORD PTR [ebx+ebp], ax
$LN90@assign:
  000e8	5f		 pop	 edi

; 1059 : 			}
; 1060 : 		return (*this);

  000e9	8b c6		 mov	 eax, esi
  000eb	5e		 pop	 esi
  000ec	5d		 pop	 ebp
  000ed	5b		 pop	 ebx

; 1061 : 		}

  000ee	c2 0c 00	 ret	 12			; 0000000cH
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 721  : 		{	// construct by copying _Right

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 722  : 		_Tidy();
; 723  : 		assign(_Right, 0, npos);

  00003	8b 4c 24 08	 mov	 ecx, DWORD PTR __Right$[esp]
  00007	33 c0		 xor	 eax, eax
  00009	6a ff		 push	 -1
  0000b	50		 push	 eax
  0000c	51		 push	 ecx
  0000d	c7 46 18 07 00
	00 00		 mov	 DWORD PTR [esi+24], 7
  00014	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  0001b	8b ce		 mov	 ecx, esi
  0001d	66 89 46 04	 mov	 WORD PTR [esi+4], ax
  00021	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 724  : 		}

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	c2 04 00	 ret	 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
; Function compile flags: /Ogtpy
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 946  : 		return (append(_Right, 0, npos));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Right$[esp-4]
  00004	6a ff		 push	 -1
  00006	6a 00		 push	 0
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 947  : 		}

  0000e	c2 04 00	 ret	 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
; Function compile flags: /Ogtpy
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 992  : 		{	// append [_Ptr, <null>)

  00000	56		 push	 esi

; 993  : 		_DEBUG_POINTER(_Ptr);
; 994  : 		return (append(_Ptr, _Traits::length(_Ptr)));

  00001	8b 74 24 08	 mov	 esi, DWORD PTR __Ptr$[esp]
  00005	8b c6		 mov	 eax, esi
  00007	57		 push	 edi
  00008	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
  0000b	eb 03 8d 49 00	 npad	 5
$LL5@append@3:
  00010	66 8b 10	 mov	 dx, WORD PTR [eax]
  00013	83 c0 02	 add	 eax, 2
  00016	66 85 d2	 test	 dx, dx
  00019	75 f5		 jne	 SHORT $LL5@append@3
  0001b	2b c7		 sub	 eax, edi
  0001d	d1 f8		 sar	 eax, 1
  0001f	50		 push	 eax
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi

; 995  : 		}

  00028	c2 04 00	 ret	 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; Function compile flags: /Ogtpy
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1064 : 		{	// assign [_Ptr, _Ptr + _Count)

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 1065 : 
; 1066 :  #if _HAS_ITERATOR_DEBUGGING
; 1067 : 		if (_Count != 0)
; 1068 : 			_DEBUG_POINTER(_Ptr);
; 1069 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1070 : 
; 1071 : 		if (_Inside(_Ptr))

  00004	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Ptr$[esp+4]
  00008	57		 push	 edi
  00009	85 c9		 test	 ecx, ecx
  0000b	74 49		 je	 SHORT $LN97@assign@2
  0000d	8b 7e 18	 mov	 edi, DWORD PTR [esi+24]
  00010	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00013	83 ff 08	 cmp	 edi, 8
  00016	72 04		 jb	 SHORT $LN12@assign@2
  00018	8b 10		 mov	 edx, DWORD PTR [eax]
  0001a	eb 02		 jmp	 SHORT $LN13@assign@2
$LN12@assign@2:
  0001c	8b d0		 mov	 edx, eax
$LN13@assign@2:
  0001e	3b ca		 cmp	 ecx, edx
  00020	72 34		 jb	 SHORT $LN97@assign@2
  00022	83 ff 08	 cmp	 edi, 8
  00025	72 04		 jb	 SHORT $LN16@assign@2
  00027	8b 10		 mov	 edx, DWORD PTR [eax]
  00029	eb 02		 jmp	 SHORT $LN17@assign@2
$LN16@assign@2:
  0002b	8b d0		 mov	 edx, eax
$LN17@assign@2:
  0002d	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  00030	8d 14 5a	 lea	 edx, DWORD PTR [edx+ebx*2]
  00033	3b d1		 cmp	 edx, ecx
  00035	76 1f		 jbe	 SHORT $LN97@assign@2

; 1072 : 			return (assign(*this, _Ptr - _Myptr(), _Count));	// substring

  00037	83 ff 08	 cmp	 edi, 8
  0003a	72 02		 jb	 SHORT $LN20@assign@2
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN20@assign@2:
  0003e	8b 54 24 14	 mov	 edx, DWORD PTR __Count$[esp+8]
  00042	2b c8		 sub	 ecx, eax
  00044	52		 push	 edx
  00045	d1 f9		 sar	 ecx, 1
  00047	51		 push	 ecx
  00048	56		 push	 esi
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx

; 1080 : 		}

  00053	c2 08 00	 ret	 8
$LN97@assign@2:

; 1073 : 
; 1074 : 		if (_Grow(_Count))

  00056	8b 7c 24 14	 mov	 edi, DWORD PTR __Count$[esp+8]
  0005a	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00060	76 05		 jbe	 SHORT $LN27@assign@2
  00062	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@SAXXZ ; std::_String_base::_Xlen
$LN27@assign@2:
  00067	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0006a	3b c7		 cmp	 eax, edi
  0006c	73 21		 jae	 SHORT $LN26@assign@2
  0006e	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00071	50		 push	 eax
  00072	57		 push	 edi
  00073	8b ce		 mov	 ecx, esi
  00075	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  0007a	85 ff		 test	 edi, edi
$LN98@assign@2:
  0007c	76 67		 jbe	 SHORT $LN94@assign@2

; 1075 : 			{	// make room and assign new stuff
; 1076 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Ptr, _Count);

  0007e	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00081	55		 push	 ebp
  00082	8d 6e 04	 lea	 ebp, DWORD PTR [esi+4]
  00085	83 f9 08	 cmp	 ecx, 8
  00088	72 31		 jb	 SHORT $LN76@assign@2
  0008a	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  0008d	eb 2e		 jmp	 SHORT $LN77@assign@2

; 1073 : 
; 1074 : 		if (_Grow(_Count))

$LN26@assign@2:
  0008f	85 ff		 test	 edi, edi
  00091	75 e9		 jne	 SHORT $LN98@assign@2
  00093	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00096	83 f8 08	 cmp	 eax, 8
  00099	72 10		 jb	 SHORT $LN70@assign@2
  0009b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009e	33 c9		 xor	 ecx, ecx
  000a0	5f		 pop	 edi
  000a1	66 89 08	 mov	 WORD PTR [eax], cx

; 1078 : 			}
; 1079 : 		return (*this);

  000a4	8b c6		 mov	 eax, esi
  000a6	5e		 pop	 esi
  000a7	5b		 pop	 ebx

; 1080 : 		}

  000a8	c2 08 00	 ret	 8

; 1073 : 
; 1074 : 		if (_Grow(_Count))

$LN70@assign@2:
  000ab	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  000ae	33 c9		 xor	 ecx, ecx
  000b0	5f		 pop	 edi
  000b1	66 89 08	 mov	 WORD PTR [eax], cx

; 1078 : 			}
; 1079 : 		return (*this);

  000b4	8b c6		 mov	 eax, esi
  000b6	5e		 pop	 esi
  000b7	5b		 pop	 ebx

; 1080 : 		}

  000b8	c2 08 00	 ret	 8

; 1075 : 			{	// make room and assign new stuff
; 1076 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Ptr, _Count);

$LN76@assign@2:
  000bb	8b c5		 mov	 eax, ebp
$LN77@assign@2:
  000bd	8b 54 24 14	 mov	 edx, DWORD PTR __Ptr$[esp+12]
  000c1	8d 1c 3f	 lea	 ebx, DWORD PTR [edi+edi]
  000c4	53		 push	 ebx
  000c5	52		 push	 edx
  000c6	03 c9		 add	 ecx, ecx
  000c8	51		 push	 ecx
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 _memcpy_s
  000cf	83 c4 10	 add	 esp, 16			; 00000010H

; 1077 : 			_Eos(_Count);

  000d2	83 7e 18 08	 cmp	 DWORD PTR [esi+24], 8
  000d6	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  000d9	72 03		 jb	 SHORT $LN92@assign@2
  000db	8b 6d 00	 mov	 ebp, DWORD PTR [ebp]
$LN92@assign@2:
  000de	33 d2		 xor	 edx, edx
  000e0	66 89 14 2b	 mov	 WORD PTR [ebx+ebp], dx
  000e4	5d		 pop	 ebp
$LN94@assign@2:
  000e5	5f		 pop	 edi

; 1078 : 			}
; 1079 : 		return (*this);

  000e6	8b c6		 mov	 eax, esi
  000e8	5e		 pop	 esi
  000e9	5b		 pop	 ebx

; 1080 : 		}

  000ea	c2 08 00	 ret	 8
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
PUBLIC	??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=, COMDAT
; _this$ = ecx

; 931  : 		return (append(_Right));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Right$[esp-4]
  00004	6a ff		 push	 -1
  00006	6a 00		 push	 0
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 932  : 		}

  0000e	c2 04 00	 ret	 4
??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=, COMDAT
; _this$ = ecx

; 935  : 		{	// append [_Ptr, <null>)

  00000	56		 push	 esi

; 936  : 		return (append(_Ptr));

  00001	8b 74 24 08	 mov	 esi, DWORD PTR __Ptr$[esp]
  00005	8b c6		 mov	 eax, esi
  00007	57		 push	 edi
  00008	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
  0000b	eb 03 8d 49 00	 npad	 5
$LL7@operator@3:
  00010	66 8b 10	 mov	 dx, WORD PTR [eax]
  00013	83 c0 02	 add	 eax, 2
  00016	66 85 d2	 test	 dx, dx
  00019	75 f5		 jne	 SHORT $LL7@operator@3
  0001b	2b c7		 sub	 eax, edi
  0001d	d1 f8		 sar	 eax, 1
  0001f	50		 push	 eax
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi

; 937  : 		}

  00028	c2 04 00	 ret	 4
??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; Function compile flags: /Ogtpy
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1083 : 		{	// assign [_Ptr, <null>)

  00000	56		 push	 esi

; 1084 : 		_DEBUG_POINTER(_Ptr);
; 1085 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00001	8b 74 24 08	 mov	 esi, DWORD PTR __Ptr$[esp]
  00005	8b c6		 mov	 eax, esi
  00007	57		 push	 edi
  00008	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
  0000b	eb 03 8d 49 00	 npad	 5
$LL5@assign@3:
  00010	66 8b 10	 mov	 dx, WORD PTR [eax]
  00013	83 c0 02	 add	 eax, 2
  00016	66 85 d2	 test	 dx, dx
  00019	75 f5		 jne	 SHORT $LL5@assign@3
  0001b	2b c7		 sub	 eax, edi
  0001d	d1 f8		 sar	 eax, 1
  0001f	50		 push	 eax
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi

; 1086 : 		}

  00028	c2 04 00	 ret	 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z$0
__ehfuncinfo$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\string
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
_TEXT	SEGMENT
$T125452 = -44						; size = 4
$T125449 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z PROC ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 53   : 	{	// return string + NTCS

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	83 ec 20	 sub	 esp, 32			; 00000020H
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c4		 xor	 eax, esp
  0001a	50		 push	 eax
  0001b	8d 44 24 2c	 lea	 eax, DWORD PTR __$EHRec$[esp+56]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 54   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00025	8b 4c 24 40	 mov	 ecx, DWORD PTR __Left$[esp+52]
  00029	33 ff		 xor	 edi, edi
  0002b	6a ff		 push	 -1
  0002d	57		 push	 edi
  0002e	33 c0		 xor	 eax, eax
  00030	51		 push	 ecx
  00031	8d 4c 24 1c	 lea	 ecx, DWORD PTR $T125449[esp+68]
  00035	89 7c 24 18	 mov	 DWORD PTR $T125452[esp+68], edi
  00039	c7 44 24 34 07
	00 00 00	 mov	 DWORD PTR $T125449[esp+92], 7
  00041	89 7c 24 30	 mov	 DWORD PTR $T125449[esp+88], edi
  00045	66 89 44 24 20	 mov	 WORD PTR $T125449[esp+72], ax
  0004a	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  0004f	8b 54 24 44	 mov	 edx, DWORD PTR __Right$[esp+52]
  00053	8b c2		 mov	 eax, edx
  00055	89 7c 24 34	 mov	 DWORD PTR __$EHRec$[esp+64], edi
  00059	8d 70 02	 lea	 esi, DWORD PTR [eax+2]
  0005c	8d 64 24 00	 npad	 4
$LL96@operator@4:
  00060	66 8b 08	 mov	 cx, WORD PTR [eax]
  00063	83 c0 02	 add	 eax, 2
  00066	66 3b cf	 cmp	 cx, di
  00069	75 f5		 jne	 SHORT $LL96@operator@4
  0006b	2b c6		 sub	 eax, esi
  0006d	d1 f8		 sar	 eax, 1
  0006f	50		 push	 eax
  00070	52		 push	 edx
  00071	8d 4c 24 18	 lea	 ecx, DWORD PTR $T125449[esp+64]
  00075	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  0007a	8b 74 24 3c	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+52]
  0007e	6a ff		 push	 -1
  00080	57		 push	 edi
  00081	33 d2		 xor	 edx, edx
  00083	c7 46 18 07 00
	00 00		 mov	 DWORD PTR [esi+24], 7
  0008a	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  0008d	50		 push	 eax
  0008e	8b ce		 mov	 ecx, esi
  00090	66 89 56 04	 mov	 WORD PTR [esi+4], dx
  00094	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00099	83 7c 24 28 08	 cmp	 DWORD PTR $T125449[esp+80], 8
  0009e	72 0d		 jb	 SHORT $LN97@operator@4
  000a0	8b 44 24 14	 mov	 eax, DWORD PTR $T125449[esp+60]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000aa	83 c4 04	 add	 esp, 4
$LN97@operator@4:
  000ad	8b c6		 mov	 eax, esi

; 55   : 	}

  000af	8b 4c 24 2c	 mov	 ecx, DWORD PTR __$EHRec$[esp+56]
  000b3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ba	59		 pop	 ecx
  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
  000bd	83 c4 2c	 add	 esp, 44			; 0000002cH
  000c0	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T125449[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 d8	 lea	 eax, DWORD PTR [edx-40]
  0000f	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z$0
__ehfuncinfo$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\string
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z
_TEXT	SEGMENT
$T125853 = -44						; size = 4
$T125850 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z PROC ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 23   : 	{	// return string + string

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	83 ec 20	 sub	 esp, 32			; 00000020H
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c4		 xor	 eax, esp
  0001a	50		 push	 eax
  0001b	8d 44 24 2c	 lea	 eax, DWORD PTR __$EHRec$[esp+56]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 24   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00025	8b 4c 24 40	 mov	 ecx, DWORD PTR __Left$[esp+52]
  00029	33 ff		 xor	 edi, edi
  0002b	6a ff		 push	 -1
  0002d	57		 push	 edi
  0002e	33 c0		 xor	 eax, eax
  00030	51		 push	 ecx
  00031	8d 4c 24 1c	 lea	 ecx, DWORD PTR $T125850[esp+68]
  00035	89 7c 24 18	 mov	 DWORD PTR $T125853[esp+68], edi
  00039	c7 44 24 34 07
	00 00 00	 mov	 DWORD PTR $T125850[esp+92], 7
  00041	89 7c 24 30	 mov	 DWORD PTR $T125850[esp+88], edi
  00045	66 89 44 24 20	 mov	 WORD PTR $T125850[esp+72], ax
  0004a	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  0004f	8b 54 24 44	 mov	 edx, DWORD PTR __Right$[esp+52]
  00053	6a ff		 push	 -1
  00055	57		 push	 edi
  00056	52		 push	 edx
  00057	8d 4c 24 1c	 lea	 ecx, DWORD PTR $T125850[esp+68]
  0005b	89 7c 24 40	 mov	 DWORD PTR __$EHRec$[esp+76], edi
  0005f	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  00064	8b 74 24 3c	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+52]
  00068	6a ff		 push	 -1
  0006a	33 c9		 xor	 ecx, ecx
  0006c	c7 46 18 07 00
	00 00		 mov	 DWORD PTR [esi+24], 7
  00073	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00076	57		 push	 edi
  00077	66 89 4e 04	 mov	 WORD PTR [esi+4], cx
  0007b	50		 push	 eax
  0007c	8b ce		 mov	 ecx, esi
  0007e	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00083	83 7c 24 28 08	 cmp	 DWORD PTR $T125850[esp+80], 8
  00088	72 0d		 jb	 SHORT $LN94@operator@5
  0008a	8b 54 24 14	 mov	 edx, DWORD PTR $T125850[esp+60]
  0008e	52		 push	 edx
  0008f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00094	83 c4 04	 add	 esp, 4
$LN94@operator@5:
  00097	8b c6		 mov	 eax, esi

; 25   : 	}

  00099	8b 4c 24 2c	 mov	 ecx, DWORD PTR __$EHRec$[esp+56]
  0009d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a4	59		 pop	 ecx
  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	83 c4 2c	 add	 esp, 44			; 0000002cH
  000aa	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T125850[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 d8	 lea	 eax, DWORD PTR [edx-40]
  0000f	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 652  : 		_Tidy();
; 653  : 		assign(_Ptr);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR __Ptr$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	33 c0		 xor	 eax, eax
  00009	c7 46 18 07 00
	00 00		 mov	 DWORD PTR [esi+24], 7
  00010	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00017	66 89 46 04	 mov	 WORD PTR [esi+4], ax
  0001b	8b c2		 mov	 eax, edx
  0001d	57		 push	 edi
  0001e	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
$LL39@basic_stri@2:
  00021	66 8b 08	 mov	 cx, WORD PTR [eax]
  00024	83 c0 02	 add	 eax, 2
  00027	66 85 c9	 test	 cx, cx
  0002a	75 f5		 jne	 SHORT $LL39@basic_stri@2
  0002c	2b c7		 sub	 eax, edi
  0002e	d1 f8		 sar	 eax, 1
  00030	50		 push	 eax
  00031	52		 push	 edx
  00032	8b ce		 mov	 ecx, esi
  00034	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00039	5f		 pop	 edi

; 654  : 		}

  0003a	8b c6		 mov	 eax, esi
  0003c	5e		 pop	 esi
  0003d	c2 04 00	 ret	 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z$0
__ehfuncinfo$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\string
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
_TEXT	SEGMENT
$T126361 = -44						; size = 4
$T126358 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z PROC ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 33   : 	{	// return NTCS + string

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	83 ec 20	 sub	 esp, 32			; 00000020H
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c4		 xor	 eax, esp
  0001a	50		 push	 eax
  0001b	8d 44 24 2c	 lea	 eax, DWORD PTR __$EHRec$[esp+56]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 34   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00025	8b 54 24 40	 mov	 edx, DWORD PTR __Left$[esp+52]
  00029	33 ff		 xor	 edi, edi
  0002b	33 c0		 xor	 eax, eax
  0002d	66 89 44 24 14	 mov	 WORD PTR $T126358[esp+60], ax
  00032	8b c2		 mov	 eax, edx
  00034	89 7c 24 0c	 mov	 DWORD PTR $T126361[esp+56], edi
  00038	c7 44 24 28 07
	00 00 00	 mov	 DWORD PTR $T126358[esp+80], 7
  00040	89 7c 24 24	 mov	 DWORD PTR $T126358[esp+76], edi
  00044	8d 70 02	 lea	 esi, DWORD PTR [eax+2]
$LL104@operator@6:
  00047	66 8b 08	 mov	 cx, WORD PTR [eax]
  0004a	83 c0 02	 add	 eax, 2
  0004d	66 3b cf	 cmp	 cx, di
  00050	75 f5		 jne	 SHORT $LL104@operator@6
  00052	2b c6		 sub	 eax, esi
  00054	d1 f8		 sar	 eax, 1
  00056	50		 push	 eax
  00057	52		 push	 edx
  00058	8d 4c 24 18	 lea	 ecx, DWORD PTR $T126358[esp+64]
  0005c	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00061	8b 4c 24 44	 mov	 ecx, DWORD PTR __Right$[esp+52]
  00065	6a ff		 push	 -1
  00067	57		 push	 edi
  00068	51		 push	 ecx
  00069	8d 4c 24 1c	 lea	 ecx, DWORD PTR $T126358[esp+68]
  0006d	89 7c 24 40	 mov	 DWORD PTR __$EHRec$[esp+76], edi
  00071	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  00076	8b 74 24 3c	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+52]
  0007a	6a ff		 push	 -1
  0007c	57		 push	 edi
  0007d	33 d2		 xor	 edx, edx
  0007f	c7 46 18 07 00
	00 00		 mov	 DWORD PTR [esi+24], 7
  00086	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00089	50		 push	 eax
  0008a	8b ce		 mov	 ecx, esi
  0008c	66 89 56 04	 mov	 WORD PTR [esi+4], dx
  00090	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00095	83 7c 24 28 08	 cmp	 DWORD PTR $T126358[esp+80], 8
  0009a	72 0d		 jb	 SHORT $LN105@operator@6
  0009c	8b 44 24 14	 mov	 eax, DWORD PTR $T126358[esp+60]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a6	83 c4 04	 add	 esp, 4
$LN105@operator@6:
  000a9	8b c6		 mov	 eax, esi

; 35   : 	}

  000ab	8b 4c 24 2c	 mov	 ecx, DWORD PTR __$EHRec$[esp+56]
  000af	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b6	59		 pop	 ecx
  000b7	5f		 pop	 edi
  000b8	5e		 pop	 esi
  000b9	83 c4 2c	 add	 esp, 44			; 0000002cH
  000bc	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T126358[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 d8	 lea	 eax, DWORD PTR [edx-40]
  0000f	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??_C@_13FPGAJAPJ@?$AA?2?$AA?$AA@		; `string'
PUBLIC	??_C@_15DDHGOCBH@?$AA?4?$AA?4?$AA?$AA@		; `string'
PUBLIC	??_C@_13JOFGPIOO@?$AA?4?$AA?$AA@		; `string'
PUBLIC	??_C@_15PKPONJIK@?$AA?2?$AA?$CK?$AA?$AA@	; `string'
PUBLIC	??_C@_19MJCDBCKE@?$AA?2?$AA?2?$AA?$DP?$AA?2?$AA?$AA@ ; `string'
PUBLIC	??_C@_11LOCGONAA@?$AA?$AA@			; `string'
PUBLIC	_directory$GSCopy$
PUBLIC	_volumeHandle$GSCopy$
PUBLIC	__$ArrayPad$
EXTRN	__imp__FindNextFileW@8:PROC
EXTRN	__imp__CreateFileW@28:PROC
EXTRN	__imp__FindFirstFileW@8:PROC
;	COMDAT ??_C@_13FPGAJAPJ@?$AA?2?$AA?$AA@
; File c:\home\public\desktop\projects\ciphershed.build\src\format\inplace.c
CONST	SEGMENT
??_C@_13FPGAJAPJ@?$AA?2?$AA?$AA@ DB '\', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_15DDHGOCBH@?$AA?4?$AA?4?$AA?$AA@
CONST	SEGMENT
??_C@_15DDHGOCBH@?$AA?4?$AA?4?$AA?$AA@ DB '.', 00H, '.', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_13JOFGPIOO@?$AA?4?$AA?$AA@
CONST	SEGMENT
??_C@_13JOFGPIOO@?$AA?4?$AA?$AA@ DB '.', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_15PKPONJIK@?$AA?2?$AA?$CK?$AA?$AA@
CONST	SEGMENT
??_C@_15PKPONJIK@?$AA?2?$AA?$CK?$AA?$AA@ DB '\', 00H, '*', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_19MJCDBCKE@?$AA?2?$AA?2?$AA?$DP?$AA?2?$AA?$AA@
CONST	SEGMENT
??_C@_19MJCDBCKE@?$AA?2?$AA?2?$AA?$DP?$AA?2?$AA?$AA@ DB '\', 00H, '\', 00H
	DB	'?', 00H, '\', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@?$AA?$AA@
CONST	SEGMENT
??_C@_11LOCGONAA@?$AA?$AA@ DB 00H, 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z$5
	DD	01H
	DD	FLAT:__unwindfunclet$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z$6
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z
_TEXT	SEGMENT
_finally1599$ = -832					; size = 4
_retry$120305 = -828					; size = 4
_volumeHandle$GSCopy$ = -824				; size = 4
_fsObject$120268 = -820					; size = 4
_directory$GSCopy$ = -816				; size = 4
_finally1624$120287 = -812				; size = 4
_startVcn$120288 = -808					; size = 8
_extentStartCluster$120297 = -800			; size = 8
_findHandle$ = -792					; size = 4
_bytesReturned$120290 = -788				; size = 4
$T126795 = -784						; size = 28
$T126792 = -784						; size = 28
_retPointers$120289 = -756				; size = 32
_moveData$120309 = -724					; size = 32
$T126791 = -724						; size = 28
$T126789 = -692						; size = 28
$T126788 = -664						; size = 28
$T126794 = -636						; size = 28
_subDir$120229 = -636					; size = 28
_findData$ = -608					; size = 592
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_volumeHandle$ = 8					; size = 4
_directory$ = 12					; size = 4
_clusterThreshold$ = 16					; size = 8
?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z PROC ; MoveClustersBeforeThresholdInDir, COMDAT

; 1592 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	81 ec 34 03 00
	00		 sub	 esp, 820		; 00000334H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c4		 xor	 eax, esp
  0001b	89 84 24 30 03
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+832], eax
  00022	53		 push	 ebx
  00023	55		 push	 ebp
  00024	56		 push	 esi
  00025	57		 push	 edi
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c4		 xor	 eax, esp
  0002d	50		 push	 eax
  0002e	8d 84 24 48 03
	00 00		 lea	 eax, DWORD PTR __$EHRec$[esp+852]
  00035	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1607 : 
; 1608 : 			if (subDir == L"." || subDir == L"..")

  0003b	8b 84 24 58 03
	00 00		 mov	 eax, DWORD PTR _volumeHandle$[esp+848]
  00042	8b bc 24 5c 03
	00 00		 mov	 edi, DWORD PTR _directory$[esp+848]
  00049	89 44 24 1c	 mov	 DWORD PTR _volumeHandle$GSCopy$[esp+852], eax
  0004d	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00050	83 f8 03	 cmp	 eax, 3

; 1645 : 				{
; 1646 : 					// Move clusters before the threshold
; 1647 : 					for (int64 movedCluster = max (extentStartCluster, clusterThreshold); movedCluster <= extentEndCluster; ++movedCluster)

  00053	89 7c 24 24	 mov	 DWORD PTR _directory$GSCopy$[esp+852], edi
  00057	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_11LOCGONAA@?$AA?$AA@
  0005c	76 05		 jbe	 SHORT $LN29@MoveCluste

; 1593 : 	WIN32_FIND_DATAW findData;
; 1594 : 
; 1595 : 	HANDLE findHandle = FindFirstFileW (((directory.size() <= 3 ? L"" : L"\\\\?\\") + directory + L"\\*").c_str(), &findData);

  0005e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_19MJCDBCKE@?$AA?2?$AA?2?$AA?$DP?$AA?2?$AA?$AA@
$LN29@MoveCluste:
  00063	57		 push	 edi
  00064	50		 push	 eax
  00065	8d 8c 24 c4 00
	00 00		 lea	 ecx, DWORD PTR $T126788[esp+860]
  0006c	51		 push	 ecx
  0006d	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00072	68 00 00 00 00	 push	 OFFSET ??_C@_15PKPONJIK@?$AA?2?$AA?$CK?$AA?$AA@
  00077	50		 push	 eax
  00078	8d 94 24 b4 00
	00 00		 lea	 edx, DWORD PTR $T126789[esp+872]
  0007f	33 ed		 xor	 ebp, ebp
  00081	52		 push	 edx
  00082	89 ac 24 68 03
	00 00		 mov	 DWORD PTR __$EHRec$[esp+884], ebp
  00089	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0008e	bb 08 00 00 00	 mov	 ebx, 8
  00093	83 c4 18	 add	 esp, 24			; 00000018H
  00096	39 58 18	 cmp	 DWORD PTR [eax+24], ebx
  00099	72 05		 jb	 SHORT $LN47@MoveCluste
  0009b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0009e	eb 03		 jmp	 SHORT $LN48@MoveCluste
$LN47@MoveCluste:
  000a0	83 c0 04	 add	 eax, 4
$LN48@MoveCluste:
  000a3	8d 8c 24 f4 00
	00 00		 lea	 ecx, DWORD PTR _findData$[esp+852]
  000aa	51		 push	 ecx
  000ab	50		 push	 eax
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindFirstFileW@8
  000b2	8b f0		 mov	 esi, eax
  000b4	89 74 24 3c	 mov	 DWORD PTR _findHandle$[esp+852], esi
  000b8	39 9c 24 b8 00
	00 00		 cmp	 DWORD PTR $T126789[esp+876], ebx
  000bf	72 10		 jb	 SHORT $LN67@MoveCluste
  000c1	8b 94 24 a4 00
	00 00		 mov	 edx, DWORD PTR $T126789[esp+856]
  000c8	52		 push	 edx
  000c9	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000ce	83 c4 04	 add	 esp, 4
$LN67@MoveCluste:
  000d1	33 c0		 xor	 eax, eax
  000d3	c7 84 24 b8 00
	00 00 07 00 00
	00		 mov	 DWORD PTR $T126789[esp+876], 7
  000de	89 ac 24 b4 00
	00 00		 mov	 DWORD PTR $T126789[esp+872], ebp
  000e5	66 89 84 24 a4
	00 00 00	 mov	 WORD PTR $T126789[esp+856], ax
  000ed	c7 84 24 50 03
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+860], -1
  000f8	39 9c 24 d4 00
	00 00		 cmp	 DWORD PTR $T126788[esp+876], ebx
  000ff	72 10		 jb	 SHORT $LN95@MoveCluste
  00101	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR $T126788[esp+856]
  00108	51		 push	 ecx
  00109	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0010e	83 c4 04	 add	 esp, 4
$LN95@MoveCluste:
  00111	33 d2		 xor	 edx, edx
  00113	c7 84 24 d4 00
	00 00 07 00 00
	00		 mov	 DWORD PTR $T126788[esp+876], 7
  0011e	89 ac 24 d0 00
	00 00		 mov	 DWORD PTR $T126788[esp+872], ebp
  00125	66 89 94 24 c0
	00 00 00	 mov	 WORD PTR $T126788[esp+856], dx

; 1596 : 	if (findHandle == INVALID_HANDLE_VALUE)

  0012d	83 fe ff	 cmp	 esi, -1

; 1597 : 		return TRUE;	// Error ignored

  00130	0f 84 db 04 00
	00		 je	 $LN421@MoveCluste

; 1598 : 
; 1599 : 	finally_do_arg (HANDLE, findHandle, { FindClose (finally_arg); });

  00136	89 74 24 14	 mov	 DWORD PTR _finally1599$[esp+852], esi
  0013a	c7 84 24 50 03
	00 00 01 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+860], 1
  00145	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL24@MoveCluste:

; 1600 : 
; 1601 : 	// Find all files and directories
; 1602 : 	do
; 1603 : 	{
; 1604 : 		if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)

  00150	f6 84 24 f4 00
	00 00 10	 test	 BYTE PTR _findData$[esp+852], 16 ; 00000010H
  00158	0f 84 ab 01 00
	00		 je	 $LN317@MoveCluste

; 1605 : 		{
; 1606 : 			wstring subDir = findData.cFileName;

  0015e	33 c0		 xor	 eax, eax
  00160	66 89 84 24 dc
	00 00 00	 mov	 WORD PTR _subDir$120229[esp+856], ax
  00168	8d 84 24 20 01
	00 00		 lea	 eax, DWORD PTR _findData$[esp+896]
  0016f	c7 84 24 f0 00
	00 00 07 00 00
	00		 mov	 DWORD PTR _subDir$120229[esp+876], 7
  0017a	89 ac 24 ec 00
	00 00		 mov	 DWORD PTR _subDir$120229[esp+872], ebp
  00181	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
$LL399@MoveCluste:
  00184	66 8b 08	 mov	 cx, WORD PTR [eax]
  00187	83 c0 02	 add	 eax, 2
  0018a	66 3b cd	 cmp	 cx, bp
  0018d	75 f5		 jne	 SHORT $LL399@MoveCluste
  0018f	2b c2		 sub	 eax, edx
  00191	d1 f8		 sar	 eax, 1
  00193	50		 push	 eax
  00194	8d 8c 24 24 01
	00 00		 lea	 ecx, DWORD PTR _findData$[esp+900]
  0019b	51		 push	 ecx
  0019c	8d 8c 24 e0 00
	00 00		 lea	 ecx, DWORD PTR _subDir$120229[esp+860]
  001a3	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 1607 : 
; 1608 : 			if (subDir == L"." || subDir == L"..")

  001a8	8b b4 24 ec 00
	00 00		 mov	 esi, DWORD PTR _subDir$120229[esp+872]
  001af	c6 84 24 50 03
	00 00 02	 mov	 BYTE PTR __$EHRec$[esp+860], 2
  001b7	8b d6		 mov	 edx, esi
  001b9	83 fe 01	 cmp	 esi, 1
  001bc	72 05		 jb	 SHORT $LN156@MoveCluste
  001be	ba 01 00 00 00	 mov	 edx, 1
$LN156@MoveCluste:
  001c3	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR _subDir$120229[esp+856]
  001ca	39 9c 24 f0 00
	00 00		 cmp	 DWORD PTR _subDir$120229[esp+876], ebx
  001d1	73 07		 jae	 SHORT $LN164@MoveCluste
  001d3	8d 8c 24 dc 00
	00 00		 lea	 ecx, DWORD PTR _subDir$120229[esp+856]
$LN164@MoveCluste:
  001da	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_13JOFGPIOO@?$AA?4?$AA?$AA@
  001df	3b d5		 cmp	 edx, ebp
  001e1	76 25		 jbe	 SHORT $LN159@MoveCluste
$LL170@MoveCluste:
  001e3	66 8b 19	 mov	 bx, WORD PTR [ecx]
  001e6	66 3b 18	 cmp	 bx, WORD PTR [eax]
  001e9	75 0d		 jne	 SHORT $LN391@MoveCluste
  001eb	83 c1 02	 add	 ecx, 2
  001ee	83 c0 02	 add	 eax, 2
  001f1	83 ea 01	 sub	 edx, 1
  001f4	75 ed		 jne	 SHORT $LL170@MoveCluste

; 1675 : 
; 1676 : 	} while (FindNextFileW (findHandle, &findData));

  001f6	eb 10		 jmp	 SHORT $LN159@MoveCluste
$LN391@MoveCluste:

; 1607 : 
; 1608 : 			if (subDir == L"." || subDir == L"..")

  001f8	66 8b 11	 mov	 dx, WORD PTR [ecx]
  001fb	66 3b 10	 cmp	 dx, WORD PTR [eax]
  001fe	1b c0		 sbb	 eax, eax
  00200	83 e0 fe	 and	 eax, -2			; fffffffeH
  00203	40		 inc	 eax
  00204	3b c5		 cmp	 eax, ebp
  00206	75 15		 jne	 SHORT $LN398@MoveCluste
$LN159@MoveCluste:
  00208	83 fe 01	 cmp	 esi, 1
  0020b	72 10		 jb	 SHORT $LN398@MoveCluste
  0020d	33 c0		 xor	 eax, eax
  0020f	83 fe 01	 cmp	 esi, 1
  00212	0f 95 c0	 setne	 al
  00215	3b c5		 cmp	 eax, ebp
  00217	0f 84 47 01 00
	00		 je	 $LN19@MoveCluste
$LN398@MoveCluste:
  0021d	6a 02		 push	 2
  0021f	68 00 00 00 00	 push	 OFFSET ??_C@_15DDHGOCBH@?$AA?4?$AA?4?$AA?$AA@
  00224	56		 push	 esi
  00225	55		 push	 ebp
  00226	8d 8c 24 e8 00
	00 00		 lea	 ecx, DWORD PTR _subDir$120229[esp+868]
  0022d	e8 00 00 00 00	 call	 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::compare
  00232	85 c0		 test	 eax, eax
  00234	0f 84 2a 01 00
	00		 je	 $LN19@MoveCluste

; 1610 : 
; 1611 : 			if (!MoveClustersBeforeThresholdInDir (volumeHandle, directory + L"\\" + subDir, clusterThreshold))

  0023a	68 00 00 00 00	 push	 OFFSET ??_C@_13FPGAJAPJ@?$AA?2?$AA?$AA@
  0023f	8d 84 24 84 00
	00 00		 lea	 eax, DWORD PTR $T126791[esp+856]
  00246	57		 push	 edi
  00247	50		 push	 eax
  00248	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0024d	8d 8c 24 e4 00
	00 00		 lea	 ecx, DWORD PTR _subDir$120229[esp+864]
  00254	51		 push	 ecx
  00255	50		 push	 eax
  00256	8d 54 24 58	 lea	 edx, DWORD PTR $T126792[esp+872]
  0025a	52		 push	 edx
  0025b	c6 84 24 68 03
	00 00 03	 mov	 BYTE PTR __$EHRec$[esp+884], 3
  00263	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00268	8b 8c 24 7c 03
	00 00		 mov	 ecx, DWORD PTR _clusterThreshold$[esp+876]
  0026f	8b 94 24 78 03
	00 00		 mov	 edx, DWORD PTR _clusterThreshold$[esp+872]
  00276	51		 push	 ecx
  00277	52		 push	 edx
  00278	50		 push	 eax
  00279	8b 44 24 40	 mov	 eax, DWORD PTR _volumeHandle$GSCopy$[esp+888]
  0027d	50		 push	 eax
  0027e	c6 84 24 78 03
	00 00 04	 mov	 BYTE PTR __$EHRec$[esp+900], 4
  00286	e8 00 00 00 00	 call	 ?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z ; MoveClustersBeforeThresholdInDir
  0028b	83 c4 28	 add	 esp, 40			; 00000028H
  0028e	85 c0		 test	 eax, eax
  00290	be 08 00 00 00	 mov	 esi, 8
  00295	0f 94 c3	 sete	 bl
  00298	39 74 24 5c	 cmp	 DWORD PTR $T126792[esp+876], esi
  0029c	72 0d		 jb	 SHORT $LN225@MoveCluste
  0029e	8b 4c 24 48	 mov	 ecx, DWORD PTR $T126792[esp+856]
  002a2	51		 push	 ecx
  002a3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  002a8	83 c4 04	 add	 esp, 4
$LN225@MoveCluste:
  002ab	33 d2		 xor	 edx, edx
  002ad	bf 07 00 00 00	 mov	 edi, 7
  002b2	89 7c 24 5c	 mov	 DWORD PTR $T126792[esp+876], edi
  002b6	89 6c 24 58	 mov	 DWORD PTR $T126792[esp+872], ebp
  002ba	66 89 54 24 48	 mov	 WORD PTR $T126792[esp+856], dx
  002bf	c6 84 24 50 03
	00 00 02	 mov	 BYTE PTR __$EHRec$[esp+860], 2
  002c7	39 b4 24 98 00
	00 00		 cmp	 DWORD PTR $T126791[esp+876], esi
  002ce	72 10		 jb	 SHORT $LN253@MoveCluste
  002d0	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR $T126791[esp+856]
  002d7	50		 push	 eax
  002d8	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  002dd	83 c4 04	 add	 esp, 4
$LN253@MoveCluste:
  002e0	84 db		 test	 bl, bl
  002e2	0f 85 30 03 00
	00		 jne	 $LN395@MoveCluste

; 1613 : 		}

  002e8	c6 84 24 50 03
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+860], 1
  002f0	39 b4 24 f0 00
	00 00		 cmp	 DWORD PTR _subDir$120229[esp+876], esi
  002f7	72 10		 jb	 SHORT $LN317@MoveCluste
  002f9	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR _subDir$120229[esp+856]
  00300	51		 push	 ecx
  00301	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00306	83 c4 04	 add	 esp, 4
$LN317@MoveCluste:

; 1614 : 
; 1615 : 		DWORD access = FILE_READ_ATTRIBUTES;
; 1616 : 
; 1617 : 		if (findData.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED)

  00309	f7 84 24 f4 00
	00 00 00 40 00
	00		 test	 DWORD PTR _findData$[esp+852], 16384 ; 00004000H
  00314	be 80 00 00 00	 mov	 esi, 128		; 00000080H
  00319	74 05		 je	 SHORT $LN17@MoveCluste

; 1618 : 			access = FILE_READ_DATA;

  0031b	be 01 00 00 00	 mov	 esi, 1
$LN17@MoveCluste:

; 1619 : 
; 1620 : 		HANDLE fsObject = CreateFileW ((directory + L"\\" + findData.cFileName).c_str(), access, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);

  00320	8b 7c 24 24	 mov	 edi, DWORD PTR _directory$GSCopy$[esp+852]
  00324	68 00 00 00 00	 push	 OFFSET ??_C@_13FPGAJAPJ@?$AA?2?$AA?$AA@
  00329	8d 84 24 dc 00
	00 00		 lea	 eax, DWORD PTR $T126794[esp+856]
  00330	57		 push	 edi
  00331	50		 push	 eax
  00332	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00337	8d 8c 24 2c 01
	00 00		 lea	 ecx, DWORD PTR _findData$[esp+908]
  0033e	51		 push	 ecx
  0033f	50		 push	 eax
  00340	8d 54 24 58	 lea	 edx, DWORD PTR $T126795[esp+872]
  00344	52		 push	 edx
  00345	c6 84 24 68 03
	00 00 05	 mov	 BYTE PTR __$EHRec$[esp+884], 5
  0034d	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00352	bb 08 00 00 00	 mov	 ebx, 8
  00357	83 c4 18	 add	 esp, 24			; 00000018H
  0035a	39 58 18	 cmp	 DWORD PTR [eax+24], ebx
  0035d	72 34		 jb	 SHORT $LN323@MoveCluste
  0035f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00362	eb 32		 jmp	 SHORT $LN324@MoveCluste
$LN19@MoveCluste:

; 1609 : 				continue;

  00364	bb 08 00 00 00	 mov	 ebx, 8
  00369	c6 84 24 50 03
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+860], 1
  00371	39 9c 24 f0 00
	00 00		 cmp	 DWORD PTR _subDir$120229[esp+876], ebx
  00378	0f 82 6f 02 00
	00		 jb	 $LN23@MoveCluste
  0037e	8b 94 24 dc 00
	00 00		 mov	 edx, DWORD PTR _subDir$120229[esp+856]
  00385	52		 push	 edx
  00386	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0038b	83 c4 04	 add	 esp, 4
  0038e	e9 5a 02 00 00	 jmp	 $LN23@MoveCluste

; 1619 : 
; 1620 : 		HANDLE fsObject = CreateFileW ((directory + L"\\" + findData.cFileName).c_str(), access, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);

$LN323@MoveCluste:
  00393	83 c0 04	 add	 eax, 4
$LN324@MoveCluste:
  00396	55		 push	 ebp
  00397	68 00 00 00 02	 push	 33554432		; 02000000H
  0039c	6a 03		 push	 3
  0039e	55		 push	 ebp
  0039f	6a 07		 push	 7
  003a1	56		 push	 esi
  003a2	50		 push	 eax
  003a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileW@28
  003a9	8b f0		 mov	 esi, eax
  003ab	89 74 24 20	 mov	 DWORD PTR _fsObject$120268[esp+852], esi
  003af	39 5c 24 5c	 cmp	 DWORD PTR $T126795[esp+876], ebx
  003b3	72 0d		 jb	 SHORT $LN343@MoveCluste
  003b5	8b 44 24 48	 mov	 eax, DWORD PTR $T126795[esp+856]
  003b9	50		 push	 eax
  003ba	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  003bf	83 c4 04	 add	 esp, 4
$LN343@MoveCluste:
  003c2	33 c9		 xor	 ecx, ecx
  003c4	c7 44 24 5c 07
	00 00 00	 mov	 DWORD PTR $T126795[esp+876], 7
  003cc	89 6c 24 58	 mov	 DWORD PTR $T126795[esp+872], ebp
  003d0	66 89 4c 24 48	 mov	 WORD PTR $T126795[esp+856], cx
  003d5	c6 84 24 50 03
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+860], 1
  003dd	39 9c 24 f0 00
	00 00		 cmp	 DWORD PTR $T126794[esp+876], ebx
  003e4	72 10		 jb	 SHORT $LN371@MoveCluste
  003e6	8b 94 24 dc 00
	00 00		 mov	 edx, DWORD PTR $T126794[esp+856]
  003ed	52		 push	 edx
  003ee	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  003f3	83 c4 04	 add	 esp, 4
$LN371@MoveCluste:
  003f6	33 c0		 xor	 eax, eax
  003f8	c7 84 24 f0 00
	00 00 07 00 00
	00		 mov	 DWORD PTR $T126794[esp+876], 7
  00403	89 ac 24 ec 00
	00 00		 mov	 DWORD PTR $T126794[esp+872], ebp
  0040a	66 89 84 24 dc
	00 00 00	 mov	 WORD PTR $T126794[esp+856], ax

; 1621 : 		if (fsObject == INVALID_HANDLE_VALUE)

  00412	83 fe ff	 cmp	 esi, -1
  00415	0f 84 d2 01 00
	00		 je	 $LN23@MoveCluste

; 1622 : 			continue;
; 1623 : 
; 1624 : 		finally_do_arg (HANDLE, fsObject, { CloseHandle (finally_arg); });

  0041b	89 74 24 28	 mov	 DWORD PTR _finally1624$120287[esp+852], esi

; 1625 : 
; 1626 : 		STARTING_VCN_INPUT_BUFFER startVcn;
; 1627 : 		startVcn.StartingVcn.QuadPart = 0;

  0041f	89 6c 24 2c	 mov	 DWORD PTR _startVcn$120288[esp+852], ebp
  00423	89 6c 24 30	 mov	 DWORD PTR _startVcn$120288[esp+856], ebp
$LL15@MoveCluste:

; 1628 : 		RETRIEVAL_POINTERS_BUFFER retPointers;
; 1629 : 		DWORD bytesReturned;
; 1630 : 
; 1631 : 		// Find clusters allocated beyond the threshold
; 1632 : 		while (DeviceIoControl (fsObject, FSCTL_GET_RETRIEVAL_POINTERS, &startVcn, sizeof (startVcn), &retPointers, sizeof (retPointers), &bytesReturned, NULL)
; 1633 : 			|| GetLastError() == ERROR_MORE_DATA)

  00427	55		 push	 ebp
  00428	8d 4c 24 44	 lea	 ecx, DWORD PTR _bytesReturned$120290[esp+856]
  0042c	51		 push	 ecx
  0042d	6a 20		 push	 32			; 00000020H
  0042f	8d 54 24 6c	 lea	 edx, DWORD PTR _retPointers$120289[esp+864]
  00433	52		 push	 edx
  00434	53		 push	 ebx
  00435	8d 44 24 40	 lea	 eax, DWORD PTR _startVcn$120288[esp+872]
  00439	50		 push	 eax
  0043a	68 73 00 09 00	 push	 589939			; 00090073H
  0043f	56		 push	 esi
  00440	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  00446	85 c0		 test	 eax, eax
  00448	75 11		 jne	 SHORT $LN13@MoveCluste
  0044a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00450	3d ea 00 00 00	 cmp	 eax, 234		; 000000eaH
  00455	0f 85 85 01 00
	00		 jne	 $LN394@MoveCluste
$LN13@MoveCluste:

; 1634 : 		{
; 1635 : 			if (retPointers.ExtentCount == 0)

  0045b	39 6c 24 60	 cmp	 DWORD PTR _retPointers$120289[esp+852], ebp
  0045f	0f 84 7b 01 00
	00		 je	 $LN394@MoveCluste

; 1636 : 				break;
; 1637 : 
; 1638 : 			if (retPointers.Extents[0].Lcn.QuadPart != -1)

  00465	8b 7c 24 78	 mov	 edi, DWORD PTR _retPointers$120289[esp+876]
  00469	8b 74 24 7c	 mov	 esi, DWORD PTR _retPointers$120289[esp+880]
  0046d	8b cf		 mov	 ecx, edi
  0046f	23 ce		 and	 ecx, esi
  00471	83 f9 ff	 cmp	 ecx, -1
  00474	0f 84 48 01 00
	00		 je	 $LN403@MoveCluste

; 1639 : 			{
; 1640 : 				int64 extentStartCluster = retPointers.Extents[0].Lcn.QuadPart;
; 1641 : 				int64 extentLen = retPointers.Extents[0].NextVcn.QuadPart - retPointers.StartingVcn.QuadPart;
; 1642 : 				int64 extentEndCluster = extentStartCluster + extentLen - 1;

  0047a	8b 5c 24 70	 mov	 ebx, DWORD PTR _retPointers$120289[esp+868]
  0047e	2b 5c 24 68	 sub	 ebx, DWORD PTR _retPointers$120289[esp+860]
  00482	8b 6c 24 74	 mov	 ebp, DWORD PTR _retPointers$120289[esp+872]
  00486	1b 6c 24 6c	 sbb	 ebp, DWORD PTR _retPointers$120289[esp+864]
  0048a	03 df		 add	 ebx, edi
  0048c	13 ee		 adc	 ebp, esi
  0048e	83 eb 01	 sub	 ebx, 1
  00491	83 dd 00	 sbb	 ebp, 0

; 1643 : 
; 1644 : 				if (extentEndCluster >= clusterThreshold)

  00494	3b ac 24 64 03
	00 00		 cmp	 ebp, DWORD PTR _clusterThreshold$[esp+852]
  0049b	89 7c 24 34	 mov	 DWORD PTR _extentStartCluster$120297[esp+852], edi
  0049f	89 74 24 38	 mov	 DWORD PTR _extentStartCluster$120297[esp+856], esi
  004a3	0f 8c 17 01 00
	00		 jl	 $LN412@MoveCluste
  004a9	7f 0d		 jg	 SHORT $LN400@MoveCluste
  004ab	3b 9c 24 60 03
	00 00		 cmp	 ebx, DWORD PTR _clusterThreshold$[esp+848]
  004b2	0f 82 08 01 00
	00		 jb	 $LN412@MoveCluste
$LN400@MoveCluste:

; 1645 : 				{
; 1646 : 					// Move clusters before the threshold
; 1647 : 					for (int64 movedCluster = max (extentStartCluster, clusterThreshold); movedCluster <= extentEndCluster; ++movedCluster)

  004b8	8b 84 24 64 03
	00 00		 mov	 eax, DWORD PTR _clusterThreshold$[esp+852]
  004bf	3b f0		 cmp	 esi, eax
  004c1	7c 0b		 jl	 SHORT $LN30@MoveCluste
  004c3	7f 12		 jg	 SHORT $LN31@MoveCluste
  004c5	3b bc 24 60 03
	00 00		 cmp	 edi, DWORD PTR _clusterThreshold$[esp+848]
  004cc	77 09		 ja	 SHORT $LN31@MoveCluste
$LN30@MoveCluste:
  004ce	8b bc 24 60 03
	00 00		 mov	 edi, DWORD PTR _clusterThreshold$[esp+848]
  004d5	8b f0		 mov	 esi, eax
$LN31@MoveCluste:
  004d7	3b f5		 cmp	 esi, ebp
  004d9	0f 8f e1 00 00
	00		 jg	 $LN412@MoveCluste
  004df	7c 0f		 jl	 SHORT $LL402@MoveCluste
  004e1	3b fb		 cmp	 edi, ebx
  004e3	0f 87 d7 00 00
	00		 ja	 $LN412@MoveCluste
  004e9	8d a4 24 00 00
	00 00		 npad	 7
$LL402@MoveCluste:

; 1648 : 					{
; 1649 : 						for (int retry = 0; ; ++retry)

  004f0	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _retry$120305[esp+852], 0
  004f8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL6@MoveCluste:

; 1650 : 						{
; 1651 : 							MOVE_FILE_DATA moveData;
; 1652 : 
; 1653 : 							if (GetFreeClusterBeforeThreshold (volumeHandle, &moveData.StartingLcn.QuadPart, clusterThreshold))

  00500	8b 94 24 64 03
	00 00		 mov	 edx, DWORD PTR _clusterThreshold$[esp+852]
  00507	8b 84 24 60 03
	00 00		 mov	 eax, DWORD PTR _clusterThreshold$[esp+848]
  0050e	8b 4c 24 1c	 mov	 ecx, DWORD PTR _volumeHandle$GSCopy$[esp+852]
  00512	52		 push	 edx
  00513	50		 push	 eax
  00514	51		 push	 ecx
  00515	8d 8c 24 9c 00
	00 00		 lea	 ecx, DWORD PTR _moveData$120309[esp+880]
  0051c	e8 00 00 00 00	 call	 ?GetFreeClusterBeforeThreshold@@YAHPAXPA_J_J@Z ; GetFreeClusterBeforeThreshold
  00521	83 c4 0c	 add	 esp, 12			; 0000000cH
  00524	85 c0		 test	 eax, eax
  00526	74 61		 je	 SHORT $LN2@MoveCluste

; 1654 : 							{
; 1655 : 								moveData.FileHandle = fsObject;

  00528	8b 54 24 20	 mov	 edx, DWORD PTR _fsObject$120268[esp+852]

; 1656 : 								moveData.StartingVcn.QuadPart = movedCluster - extentStartCluster + retPointers.StartingVcn.QuadPart;
; 1657 : 								moveData.ClusterCount = 1;
; 1658 : 
; 1659 : 								if (DeviceIoControl (volumeHandle, FSCTL_MOVE_FILE, &moveData, sizeof (moveData), NULL, 0, &bytesReturned, NULL))

  0052c	6a 00		 push	 0
  0052e	89 94 24 84 00
	00 00		 mov	 DWORD PTR _moveData$120309[esp+856], edx
  00535	8b c7		 mov	 eax, edi
  00537	2b 44 24 38	 sub	 eax, DWORD PTR _extentStartCluster$120297[esp+856]
  0053b	8d 54 24 44	 lea	 edx, DWORD PTR _bytesReturned$120290[esp+856]
  0053f	52		 push	 edx
  00540	6a 00		 push	 0
  00542	8b ce		 mov	 ecx, esi
  00544	1b 4c 24 44	 sbb	 ecx, DWORD PTR _extentStartCluster$120297[esp+868]
  00548	03 44 24 74	 add	 eax, DWORD PTR _retPointers$120289[esp+872]
  0054c	6a 00		 push	 0
  0054e	13 4c 24 7c	 adc	 ecx, DWORD PTR _retPointers$120289[esp+880]
  00552	6a 20		 push	 32			; 00000020H
  00554	89 84 24 9c 00
	00 00		 mov	 DWORD PTR _moveData$120309[esp+880], eax
  0055b	8d 84 24 94 00
	00 00		 lea	 eax, DWORD PTR _moveData$120309[esp+872]
  00562	50		 push	 eax
  00563	89 8c 24 a4 00
	00 00		 mov	 DWORD PTR _moveData$120309[esp+888], ecx
  0056a	8b 4c 24 34	 mov	 ecx, DWORD PTR _volumeHandle$GSCopy$[esp+876]
  0056e	68 74 00 09 00	 push	 589940			; 00090074H
  00573	51		 push	 ecx
  00574	c7 84 24 b8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR _moveData$120309[esp+908], 1
  0057f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  00585	85 c0		 test	 eax, eax
  00587	75 1f		 jne	 SHORT $LN8@MoveCluste
$LN2@MoveCluste:

; 1660 : 									break;
; 1661 : 							}
; 1662 : 
; 1663 : 							if (retry > 600)

  00589	81 7c 24 18 58
	02 00 00	 cmp	 DWORD PTR _retry$120305[esp+852], 600 ; 00000258H
  00591	0f 8f b4 00 00
	00		 jg	 $LN393@MoveCluste

; 1665 : 
; 1666 : 							// There are possible race conditions as we work on a live filesystem
; 1667 : 							Sleep (100);

  00597	6a 64		 push	 100			; 00000064H
  00599	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
  0059f	ff 44 24 18	 inc	 DWORD PTR _retry$120305[esp+852]
  005a3	e9 58 ff ff ff	 jmp	 $LL6@MoveCluste
$LN8@MoveCluste:

; 1645 : 				{
; 1646 : 					// Move clusters before the threshold
; 1647 : 					for (int64 movedCluster = max (extentStartCluster, clusterThreshold); movedCluster <= extentEndCluster; ++movedCluster)

  005a8	83 c7 01	 add	 edi, 1
  005ab	83 d6 00	 adc	 esi, 0
  005ae	3b f5		 cmp	 esi, ebp
  005b0	0f 8c 3a ff ff
	ff		 jl	 $LL402@MoveCluste
  005b6	7f 08		 jg	 SHORT $LN412@MoveCluste
  005b8	3b fb		 cmp	 edi, ebx
  005ba	0f 86 30 ff ff
	ff		 jbe	 $LL402@MoveCluste
$LN412@MoveCluste:
  005c0	33 ed		 xor	 ebp, ebp
$LN403@MoveCluste:

; 1668 : 						}
; 1669 : 					}
; 1670 : 				}
; 1671 : 			}
; 1672 : 
; 1673 : 			startVcn.StartingVcn = retPointers.Extents[0].NextVcn;

  005c2	8b 54 24 70	 mov	 edx, DWORD PTR _retPointers$120289[esp+868]
  005c6	8b 44 24 74	 mov	 eax, DWORD PTR _retPointers$120289[esp+872]

; 1674 : 		}

  005ca	8b 74 24 20	 mov	 esi, DWORD PTR _fsObject$120268[esp+852]
  005ce	89 54 24 2c	 mov	 DWORD PTR _startVcn$120288[esp+852], edx
  005d2	89 44 24 30	 mov	 DWORD PTR _startVcn$120288[esp+856], eax
  005d6	bb 08 00 00 00	 mov	 ebx, 8
  005db	e9 47 fe ff ff	 jmp	 $LL15@MoveCluste
$LN394@MoveCluste:

; 1675 : 
; 1676 : 	} while (FindNextFileW (findHandle, &findData));

  005e0	8d 44 24 28	 lea	 eax, DWORD PTR _finally1624$120287[esp+852]
  005e4	e8 00 00 00 00	 call	 ??1Finally1624@?BC@??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@XZ ; `MoveClustersBeforeThresholdInDir'::`18'::Finally1624::~Finally1624
  005e9	8b 7c 24 24	 mov	 edi, DWORD PTR _directory$GSCopy$[esp+852]
$LN23@MoveCluste:
  005ed	8b 54 24 3c	 mov	 edx, DWORD PTR _findHandle$[esp+852]
  005f1	8d 8c 24 f4 00
	00 00		 lea	 ecx, DWORD PTR _findData$[esp+852]
  005f8	51		 push	 ecx
  005f9	52		 push	 edx
  005fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindNextFileW@8
  00600	85 c0		 test	 eax, eax
  00602	0f 85 48 fb ff
	ff		 jne	 $LL24@MoveCluste

; 1677 : 
; 1678 : 	return TRUE;

  00608	8d 44 24 14	 lea	 eax, DWORD PTR _finally1599$[esp+852]
  0060c	e8 00 00 00 00	 call	 ??1Finally1599@?3??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@XZ ; `MoveClustersBeforeThresholdInDir'::`4'::Finally1599::~Finally1599
$LN421@MoveCluste:
  00611	b8 01 00 00 00	 mov	 eax, 1
  00616	eb 47		 jmp	 SHORT $LN26@MoveCluste
$LN395@MoveCluste:

; 1612 : 				return FALSE;

  00618	39 b4 24 f0 00
	00 00		 cmp	 DWORD PTR _subDir$120229[esp+876], esi
  0061f	72 10		 jb	 SHORT $LN281@MoveCluste
  00621	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR _subDir$120229[esp+856]
  00628	50		 push	 eax
  00629	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0062e	83 c4 04	 add	 esp, 4
$LN281@MoveCluste:
  00631	33 c9		 xor	 ecx, ecx
  00633	89 bc 24 f0 00
	00 00		 mov	 DWORD PTR _subDir$120229[esp+876], edi
  0063a	89 ac 24 ec 00
	00 00		 mov	 DWORD PTR _subDir$120229[esp+872], ebp
  00641	66 89 8c 24 dc
	00 00 00	 mov	 WORD PTR _subDir$120229[esp+856], cx
  00649	eb 09		 jmp	 SHORT $LN420@MoveCluste
$LN393@MoveCluste:

; 1664 : 								return FALSE;

  0064b	8d 44 24 28	 lea	 eax, DWORD PTR _finally1624$120287[esp+852]
  0064f	e8 00 00 00 00	 call	 ??1Finally1624@?BC@??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@XZ ; `MoveClustersBeforeThresholdInDir'::`18'::Finally1624::~Finally1624
$LN420@MoveCluste:
  00654	8d 44 24 14	 lea	 eax, DWORD PTR _finally1599$[esp+852]
  00658	e8 00 00 00 00	 call	 ??1Finally1599@?3??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@XZ ; `MoveClustersBeforeThresholdInDir'::`4'::Finally1599::~Finally1599
  0065d	33 c0		 xor	 eax, eax
$LN26@MoveCluste:

; 1679 : }

  0065f	8b 8c 24 48 03
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+852]
  00666	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0066d	59		 pop	 ecx
  0066e	5f		 pop	 edi
  0066f	5e		 pop	 esi
  00670	5d		 pop	 ebp
  00671	5b		 pop	 ebx
  00672	8b 8c 24 30 03
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+832]
  00679	33 cc		 xor	 ecx, esp
  0067b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00680	81 c4 40 03 00
	00		 add	 esp, 832		; 00000340H
  00686	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z$0:
  00000	8d 8d 68 fd ff
	ff		 lea	 ecx, DWORD PTR $T126788[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z$2:
  0000b	8d 85 c0 fc ff
	ff		 lea	 eax, DWORD PTR _finally1599$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1Finally1599@?3??MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z@QAE@XZ ; `MoveClustersBeforeThresholdInDir'::`4'::Finally1599::~Finally1599
__unwindfunclet$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z$3:
  00016	8d 8d 84 fd ff
	ff		 lea	 ecx, DWORD PTR _subDir$120229[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z$4:
  00021	8d 8d 2c fd ff
	ff		 lea	 ecx, DWORD PTR $T126791[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z$5:
  0002c	8d 8d f0 fc ff
	ff		 lea	 ecx, DWORD PTR $T126792[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z$6:
  00037	8d 8d 84 fd ff
	ff		 lea	 ecx, DWORD PTR $T126794[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__ehhandler$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z:
  00042	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00046	8d 82 bc fc ff
	ff		 lea	 eax, DWORD PTR [edx-836]
  0004c	8b 8a b8 fc ff
	ff		 mov	 ecx, DWORD PTR [edx-840]
  00052	33 c8		 xor	 ecx, eax
  00054	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00059	83 c0 10	 add	 eax, 16			; 00000010H
  0005c	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0005f	33 c8		 xor	 ecx, eax
  00061	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00066	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z
  0006b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z ENDP ; MoveClustersBeforeThresholdInDir
PUBLIC	??_C@_15DBHGMMAD@?$AAX?$AA?3?$AA?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_MoveClustersBeforeThreshold
;	COMDAT ??_C@_15DBHGMMAD@?$AAX?$AA?3?$AA?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\iosfwd
CONST	SEGMENT
??_C@_15DBHGMMAD@?$AAX?$AA?3?$AA?$AA@ DB 'X', 00H, ':', 00H, 00H, 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\home\public\desktop\projects\ciphershed.build\src\format\inplace.c
CONST	ENDS
;	COMDAT _MoveClustersBeforeThreshold
_TEXT	SEGMENT
_volumeRoot$ = -32					; size = 28
__$ArrayPad$ = -4					; size = 4
_volumeHandle$ = 8					; size = 4
_volumeDevicePath$ = 12					; size = 4
_clusterThreshold$ = 16					; size = 8
_MoveClustersBeforeThreshold PROC			; COMDAT

; 1683 : {

  00000	83 ec 20	 sub	 esp, 32			; 00000020H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 1c	 mov	 DWORD PTR __$ArrayPad$[esp+32], eax
  0000e	8b 44 24 28	 mov	 eax, DWORD PTR _volumeDevicePath$[esp+28]
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	8b 7c 24 2c	 mov	 edi, DWORD PTR _volumeHandle$[esp+36]

; 1684 : 	int drive = GetDiskDeviceDriveLetter (volumeDevicePath);

  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _GetDiskDeviceDriveLetter
  0001e	8b f0		 mov	 esi, eax
  00020	83 c4 04	 add	 esp, 4

; 1685 : 	if (drive == -1)

  00023	83 fe ff	 cmp	 esi, -1
  00026	75 1b		 jne	 SHORT $LN1@MoveCluste@2

; 1686 : 	{
; 1687 : 		SetLastError (ERROR_INVALID_PARAMETER);

  00028	6a 57		 push	 87			; 00000057H
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
  00030	5f		 pop	 edi

; 1688 : 		return FALSE;

  00031	33 c0		 xor	 eax, eax
  00033	5e		 pop	 esi

; 1695 : }

  00034	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+32]
  00038	33 cc		 xor	 ecx, esp
  0003a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003f	83 c4 20	 add	 esp, 32			; 00000020H
  00042	c3		 ret	 0
$LN1@MoveCluste@2:

; 1689 : 	}
; 1690 : 
; 1691 : 	wstring volumeRoot = L"X:";

  00043	6a 02		 push	 2
  00045	33 c0		 xor	 eax, eax
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_15DBHGMMAD@?$AAX?$AA?3?$AA?$AA@
  0004c	8d 4c 24 10	 lea	 ecx, DWORD PTR _volumeRoot$[esp+48]
  00050	c7 44 24 28 07
	00 00 00	 mov	 DWORD PTR _volumeRoot$[esp+72], 7
  00058	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _volumeRoot$[esp+68], 0
  00060	66 89 44 24 14	 mov	 WORD PTR _volumeRoot$[esp+52], ax
  00065	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 1692 : 	volumeRoot[0] = L'A' + (wchar_t) drive;

  0006a	83 7c 24 20 08	 cmp	 DWORD PTR _volumeRoot$[esp+64], 8
  0006f	8b 44 24 0c	 mov	 eax, DWORD PTR _volumeRoot$[esp+44]
  00073	73 04		 jae	 SHORT $LN48@MoveCluste@2
  00075	8d 44 24 0c	 lea	 eax, DWORD PTR _volumeRoot$[esp+44]
$LN48@MoveCluste@2:

; 1693 : 
; 1694 : 	return MoveClustersBeforeThresholdInDir (volumeHandle, volumeRoot, clusterThreshold);

  00079	8b 4c 24 38	 mov	 ecx, DWORD PTR _clusterThreshold$[esp+40]
  0007d	8b 54 24 34	 mov	 edx, DWORD PTR _clusterThreshold$[esp+36]
  00081	51		 push	 ecx
  00082	83 c6 41	 add	 esi, 65			; 00000041H
  00085	66 89 30	 mov	 WORD PTR [eax], si
  00088	52		 push	 edx
  00089	8d 44 24 10	 lea	 eax, DWORD PTR _volumeRoot$[esp+48]
  0008d	50		 push	 eax
  0008e	57		 push	 edi
  0008f	e8 00 00 00 00	 call	 ?MoveClustersBeforeThresholdInDir@@YAHPAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J@Z ; MoveClustersBeforeThresholdInDir
  00094	83 c4 10	 add	 esp, 16			; 00000010H
  00097	83 7c 24 20 08	 cmp	 DWORD PTR _volumeRoot$[esp+64], 8
  0009c	8b f0		 mov	 esi, eax
  0009e	72 0d		 jb	 SHORT $LN67@MoveCluste@2
  000a0	8b 4c 24 0c	 mov	 ecx, DWORD PTR _volumeRoot$[esp+44]
  000a4	51		 push	 ecx
  000a5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000aa	83 c4 04	 add	 esp, 4
$LN67@MoveCluste@2:

; 1695 : }

  000ad	8b 4c 24 24	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+40]
  000b1	5f		 pop	 edi
  000b2	8b c6		 mov	 eax, esi
  000b4	5e		 pop	 esi
  000b5	33 cc		 xor	 ecx, esp
  000b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bc	83 c4 20	 add	 esp, 32			; 00000020H
  000bf	c3		 ret	 0
_MoveClustersBeforeThreshold ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DLEMDKJB@?1prinplace?$AA@		; `string'
PUBLIC	??_C@_0BG@EBLNDPCA@CANNOT_RESIZE_FILESYS?$AA@	; `string'
PUBLIC	_volParams$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_EncryptPartitionInPlaceBegin
EXTRN	_ManageStartupSeqWiz:PROC
EXTRN	_IsNonInstallMode:PROC
EXTRN	_GetVolumeDataAreaSize:PROC
;	COMDAT ??_C@_0L@DLEMDKJB@?1prinplace?$AA@
; File c:\program files\microsoft sdks\windows\v7.1\include\winnt.h
CONST	SEGMENT
??_C@_0L@DLEMDKJB@?1prinplace?$AA@ DB '/prinplace', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EBLNDPCA@CANNOT_RESIZE_FILESYS?$AA@
CONST	SEGMENT
??_C@_0BG@EBLNDPCA@CANNOT_RESIZE_FILESYS?$AA@ DB 'CANNOT_RESIZE_FILESYS', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\home\public\desktop\projects\ciphershed.build\src\format\inplace.c
CONST	ENDS
;	COMDAT _EncryptPartitionInPlaceBegin
_TEXT	SEGMENT
_cryptoInfo$ = -1132					; size = 4
_wipePass$119707 = -1128				; size = 4
_driveLetter$ = -1128					; size = 4
_cryptoInfo2$ = -1124					; size = 4
_header$ = -1120					; size = 4
_volParams$GSCopy$ = -1116				; size = 4
_dev$ = -1112						; size = 4
_dwResult$ = -1108					; size = 4
_dwResult$128640 = -1104				; size = 4
_dataAreaSize$ = -1100					; size = 8
_shrinkVolInfo$ = -1092					; size = 24
_bytesPerCluster$ = -1068				; size = 4
$T128679 = -1064					; size = 4
_deviceSize$ = -1060					; size = 8
_totalClusterCount$ = -1052				; size = 8
_devName$ = -1044					; size = 260
_dosDev$ = -784						; size = 260
_deviceName$ = -524					; size = 520
__$ArrayPad$ = -4					; size = 4
_volParams$ = 8						; size = 4
_outHandle$ = 12					; size = 4
_wipeAlgorithm$ = 16					; size = 4
_EncryptPartitionInPlaceBegin PROC			; COMDAT

; 305  : {

  00000	81 ec 6c 04 00
	00		 sub	 esp, 1132		; 0000046cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 68 04
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1132], eax
  00014	53		 push	 ebx
  00015	8b 9c 24 74 04
	00 00		 mov	 ebx, DWORD PTR _volParams$[esp+1132]
  0001c	55		 push	 ebp
  0001d	57		 push	 edi

; 306  : 	SHRINK_VOLUME_INFORMATION shrinkVolInfo;
; 307  : 	signed __int64 sizeToShrinkTo;
; 308  : 	int nStatus = ERR_SUCCESS;
; 309  : 	PCRYPTO_INFO cryptoInfo = NULL;

  0001e	33 ed		 xor	 ebp, ebp

; 310  : 	PCRYPTO_INFO cryptoInfo2 = NULL;
; 311  : 	HANDLE dev = INVALID_HANDLE_VALUE;
; 312  : 	DWORD dwError;
; 313  : 	char *header;
; 314  : 	char dosDev[TC_MAX_PATH] = {0};

  00020	68 03 01 00 00	 push	 259			; 00000103H
  00025	8d 84 24 6d 01
	00 00		 lea	 eax, DWORD PTR _dosDev$[esp+1149]
  0002c	55		 push	 ebp
  0002d	50		 push	 eax

; 489  : 
; 490  : 	if (nStatus != ERR_SUCCESS)
; 491  : 	{
; 492  : 		nStatus = ERR_DONT_REPORT; 
; 493  : 		goto closing_seq;
; 494  : 	}
; 495  : 
; 496  : 
; 497  : 
; 498  : 	/* Create header backup on the partition. Until the volume is fully encrypted, the backup header will provide 
; 499  : 	us with the master key, encrypted range, and other data for pause/resume operations. We cannot create the 
; 500  : 	primary header until the entire partition is encrypted (because we encrypt backwards and the primary header 
; 501  : 	area is occuppied by data until the very end of the process). */
; 502  : 
; 503  : 	// Prepare the backup header
; 504  : 	for (int wipePass = 0; wipePass < (wipeAlgorithm == TC_WIPE_NONE ? 1 : PRAND_DISK_WIPE_PASSES); wipePass++)

  0002e	89 5c 24 28	 mov	 DWORD PTR _volParams$GSCopy$[esp+1156], ebx
  00032	89 6c 24 18	 mov	 DWORD PTR _cryptoInfo$[esp+1156], ebp
  00036	89 6c 24 20	 mov	 DWORD PTR _cryptoInfo2$[esp+1156], ebp
  0003a	c7 44 24 2c ff
	ff ff ff	 mov	 DWORD PTR _dev$[esp+1156], -1
  00042	c6 84 24 74 01
	00 00 00	 mov	 BYTE PTR _dosDev$[esp+1156], 0
  0004a	e8 00 00 00 00	 call	 _memset
  0004f	68 03 01 00 00	 push	 259			; 00000103H
  00054	8d 4c 24 75	 lea	 ecx, DWORD PTR _devName$[esp+1161]
  00058	55		 push	 ebp
  00059	51		 push	 ecx
  0005a	c6 44 24 7c 00	 mov	 BYTE PTR _devName$[esp+1168], 0
  0005f	e8 00 00 00 00	 call	 _memset
  00064	bf 01 00 00 00	 mov	 edi, 1
  00069	89 3d 00 00 00
	00		 mov	 DWORD PTR _NonSysInplaceEncStatus, edi
  0006f	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00072	55		 push	 ebp
  00073	52		 push	 edx
  00074	e8 00 00 00 00	 call	 _CheckRequirementsForNonSysInPlaceEnc
  00079	83 c4 20	 add	 esp, 32			; 00000020H
  0007c	85 c0		 test	 eax, eax
  0007e	75 1b		 jne	 SHORT $LN56@EncryptPar@2
  00080	5f		 pop	 edi
  00081	8d 45 1c	 lea	 eax, DWORD PTR [ebp+28]
  00084	5d		 pop	 ebp
  00085	5b		 pop	 ebx

; 635  : 
; 636  : 	return nStatus;
; 637  : }

  00086	8b 8c 24 68 04
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1132]
  0008d	33 cc		 xor	 ecx, esp
  0008f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00094	81 c4 6c 04 00
	00		 add	 esp, 1132		; 0000046cH
  0009a	c3		 ret	 0
$LN56@EncryptPar@2:

; 315  : 	char devName[MAX_PATH] = {0};
; 316  : 	int driveLetter = -1;
; 317  : 	WCHAR deviceName[MAX_PATH];
; 318  : 	uint64 dataAreaSize;
; 319  : 	__int64 deviceSize;
; 320  : 	LARGE_INTEGER offset;
; 321  : 	DWORD dwResult;
; 322  : 
; 323  : 	SetNonSysInplaceEncUIStatus (NONSYS_INPLACE_ENC_STATUS_PREPARING);
; 324  : 
; 325  : 
; 326  : 	if (!CheckRequirementsForNonSysInPlaceEnc (volParams->volumePath, FALSE))
; 327  : 		return ERR_DONT_REPORT;
; 328  : 
; 329  : 
; 330  : 	header = (char *) TCalloc (TC_VOLUME_HEADER_EFFECTIVE_SIZE);

  0009b	68 00 02 00 00	 push	 512			; 00000200H
  000a0	e8 00 00 00 00	 call	 _malloc
  000a5	83 c4 04	 add	 esp, 4
  000a8	89 44 24 18	 mov	 DWORD PTR _header$[esp+1144], eax

; 331  : 	if (!header)

  000ac	3b c5		 cmp	 eax, ebp
  000ae	75 1d		 jne	 SHORT $LN55@EncryptPar@2
  000b0	5f		 pop	 edi
  000b1	5d		 pop	 ebp

; 332  : 		return ERR_OUTOFMEMORY;

  000b2	b8 02 00 00 00	 mov	 eax, 2
  000b7	5b		 pop	 ebx

; 635  : 
; 636  : 	return nStatus;
; 637  : }

  000b8	8b 8c 24 68 04
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1132]
  000bf	33 cc		 xor	 ecx, esp
  000c1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c6	81 c4 6c 04 00
	00		 add	 esp, 1132		; 0000046cH
  000cc	c3		 ret	 0
$LN55@EncryptPar@2:
  000cd	56		 push	 esi

; 333  : 
; 334  : 	VirtualLock (header, TC_VOLUME_HEADER_EFFECTIVE_SIZE);

  000ce	68 00 02 00 00	 push	 512			; 00000200H
  000d3	50		 push	 eax
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualLock@8

; 335  : 
; 336  : 	deviceSize = GetDeviceSize (volParams->volumePath);

  000da	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  000dd	50		 push	 eax
  000de	e8 00 00 00 00	 call	 _GetDeviceSize
  000e3	83 c4 04	 add	 esp, 4

; 337  : 	if (deviceSize < 0)

  000e6	3b d5		 cmp	 edx, ebp
  000e8	89 44 24 58	 mov	 DWORD PTR _deviceSize$[esp+1148], eax
  000ec	89 54 24 5c	 mov	 DWORD PTR _deviceSize$[esp+1152], edx
  000f0	7f 30		 jg	 SHORT $LN52@EncryptPar@2
  000f2	7c 04		 jl	 SHORT $LN131@EncryptPar@2
  000f4	3b c5		 cmp	 eax, ebp
  000f6	73 0a		 jae	 SHORT $LN54@EncryptPar@2
$LN131@EncryptPar@2:

; 338  : 	{
; 339  : 		// Cannot determine the size of the partition
; 340  : 		nStatus = ERR_PARAMETER_INCORRECT;

  000f8	bf 1e 00 00 00	 mov	 edi, 30			; 0000001eH
  000fd	e9 6b 05 00 00	 jmp	 $closing_seq$119670
$LN54@EncryptPar@2:

; 341  : 		goto closing_seq;
; 342  : 	}
; 343  : 
; 344  : 	if (deviceSize < TC_NONSYS_INPLACE_ENC_MIN_VOL_SIZE)

  00102	3b d5		 cmp	 edx, ebp
  00104	7f 1c		 jg	 SHORT $LN52@EncryptPar@2
  00106	7c 07		 jl	 SHORT $LN132@EncryptPar@2
  00108	3d 00 80 72 00	 cmp	 eax, 7503872		; 00728000H
  0010d	73 13		 jae	 SHORT $LN52@EncryptPar@2
$LN132@EncryptPar@2:

; 345  : 	{
; 346  : 		ShowInPlaceEncErrMsgWAltSteps ("PARTITION_TOO_SMALL_FOR_NONSYS_INPLACE_ENC", TRUE);

  0010f	57		 push	 edi
  00110	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@EKBFECDJ@PARTITION_TOO_SMALL_FOR_NONSYS_I@
  00115	e8 00 00 00 00	 call	 _ShowInPlaceEncErrMsgWAltSteps
  0011a	83 c4 08	 add	 esp, 8

; 603  : 
; 604  : 
; 605  : 	nStatus = ERR_SUCCESS;

  0011d	e9 46 05 00 00	 jmp	 $LN142@EncryptPar@2
$LN52@EncryptPar@2:

; 347  : 		nStatus = ERR_DONT_REPORT;
; 348  : 		goto closing_seq;
; 349  : 	}
; 350  : 
; 351  : 	dataAreaSize = GetVolumeDataAreaSize (volParams->hiddenVol, deviceSize);

  00122	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00125	52		 push	 edx
  00126	50		 push	 eax
  00127	51		 push	 ecx
  00128	e8 00 00 00 00	 call	 _GetVolumeDataAreaSize

; 352  : 
; 353  : 	strcpy ((char *)deviceName, volParams->volumePath);

  0012d	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00130	89 54 24 40	 mov	 DWORD PTR _dataAreaSize$[esp+1164], edx
  00134	83 c4 0c	 add	 esp, 12			; 0000000cH
  00137	89 44 24 30	 mov	 DWORD PTR _dataAreaSize$[esp+1148], eax
  0013b	8d 94 24 70 02
	00 00		 lea	 edx, DWORD PTR _deviceName$[esp+1148]
$LL59@EncryptPar@2:
  00142	8a 01		 mov	 al, BYTE PTR [ecx]
  00144	88 02		 mov	 BYTE PTR [edx], al
  00146	03 cf		 add	 ecx, edi
  00148	03 d7		 add	 edx, edi
  0014a	84 c0		 test	 al, al
  0014c	75 f4		 jne	 SHORT $LL59@EncryptPar@2

; 354  : 	ToUNICODE ((char *)deviceName);

  0014e	8d 94 24 70 02
	00 00		 lea	 edx, DWORD PTR _deviceName$[esp+1148]
  00155	52		 push	 edx
  00156	e8 00 00 00 00	 call	 _ToUNICODE

; 355  : 
; 356  : 	driveLetter = GetDiskDeviceDriveLetter (deviceName);

  0015b	8d 84 24 74 02
	00 00		 lea	 eax, DWORD PTR _deviceName$[esp+1152]
  00162	50		 push	 eax
  00163	e8 00 00 00 00	 call	 _GetDiskDeviceDriveLetter

; 357  : 
; 358  : 
; 359  : 	if (FakeDosNameForDevice (volParams->volumePath, dosDev, devName, FALSE) != 0)

  00168	55		 push	 ebp
  00169	8d 4c 24 74	 lea	 ecx, DWORD PTR _devName$[esp+1160]
  0016d	51		 push	 ecx
  0016e	8d 94 24 7c 01
	00 00		 lea	 edx, DWORD PTR _dosDev$[esp+1164]
  00175	89 44 24 24	 mov	 DWORD PTR _driveLetter$[esp+1164], eax
  00179	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0017c	52		 push	 edx
  0017d	50		 push	 eax
  0017e	e8 00 00 00 00	 call	 _FakeDosNameForDevice
  00183	83 c4 18	 add	 esp, 24			; 00000018H
  00186	85 c0		 test	 eax, eax

; 603  : 
; 604  : 
; 605  : 	nStatus = ERR_SUCCESS;

  00188	0f 85 df 04 00
	00		 jne	 $closing_seq$119670
  0018e	8d 4c 24 68	 lea	 ecx, DWORD PTR _devName$[esp+1148]
  00192	51		 push	 ecx
  00193	e8 00 00 00 00	 call	 _IsDeviceMounted
  00198	83 c4 04	 add	 esp, 4
  0019b	85 c0		 test	 eax, eax
  0019d	0f 84 b8 04 00
	00		 je	 $LN48@EncryptPar@2
  001a3	55		 push	 ebp
  001a4	68 00 00 00 80	 push	 -2147483648		; 80000000H
  001a9	6a 03		 push	 3
  001ab	55		 push	 ebp
  001ac	6a 03		 push	 3
  001ae	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  001b3	8d 94 24 80 00
	00 00		 lea	 edx, DWORD PTR _devName$[esp+1172]
  001ba	52		 push	 edx
  001bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  001c1	8b f0		 mov	 esi, eax
  001c3	83 fe ff	 cmp	 esi, -1
  001c6	75 21		 jne	 SHORT $LN71@EncryptPar@2
  001c8	a1 00 00 00 00	 mov	 eax, DWORD PTR _MainDlg
  001cd	50		 push	 eax
  001ce	e8 00 00 00 00	 call	 _handleWin32Error
  001d3	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@CAPGNNOA@INPLACE_ENC_CANT_ACCESS_OR_GET_I@
  001d8	e8 00 00 00 00	 call	 _Error
  001dd	83 c4 08	 add	 esp, 8
  001e0	89 74 24 24	 mov	 DWORD PTR _dev$[esp+1148], esi
  001e4	e9 7f 04 00 00	 jmp	 $LN142@EncryptPar@2

; 360  : 	{
; 361  : 		nStatus = ERR_OS_ERROR;
; 362  : 		goto closing_seq;
; 363  : 	}
; 364  : 
; 365  : 	if (IsDeviceMounted (devName))
; 366  : 	{
; 367  : 		dev = OpenPartitionVolume (devName,
; 368  : 			FALSE,	// Do not require exclusive access (must be FALSE; otherwise, it will not be possible to dismount the volume or obtain its properties and FSCTL_ALLOW_EXTENDED_DASD_IO will fail too)
; 369  : 			TRUE,	// Require shared access (must be TRUE; otherwise, it will not be possible to dismount the volume or obtain its properties and FSCTL_ALLOW_EXTENDED_DASD_IO will fail too)
; 370  : 			FALSE,	// Do not ask the user to confirm shared access (if exclusive fails)
; 371  : 			FALSE,	// Do not append alternative instructions how to encrypt the data (to applicable error messages)
; 372  : 			FALSE);	// Non-silent mode

$LN71@EncryptPar@2:

; 385  : 		goto closing_seq;
; 386  : 	}
; 387  : 
; 388  : 
; 389  : 	/* Gain "raw" access to the partition (the NTFS driver guards hidden sectors). */
; 390  : 
; 391  : 	if (!DeviceIoControl (dev,
; 392  : 		FSCTL_ALLOW_EXTENDED_DASD_IO,
; 393  : 		NULL,
; 394  : 		0,   
; 395  : 		NULL,
; 396  : 		0,
; 397  : 		&dwResult,
; 398  : 		NULL))

  001e9	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__DeviceIoControl@32
  001ef	55		 push	 ebp
  001f0	8d 4c 24 2c	 lea	 ecx, DWORD PTR _dwResult$[esp+1152]
  001f4	51		 push	 ecx
  001f5	55		 push	 ebp
  001f6	55		 push	 ebp
  001f7	55		 push	 ebp
  001f8	55		 push	 ebp
  001f9	68 83 00 09 00	 push	 589955			; 00090083H
  001fe	56		 push	 esi
  001ff	89 74 24 44	 mov	 DWORD PTR _dev$[esp+1180], esi
  00203	ff d7		 call	 edi
  00205	85 c0		 test	 eax, eax
  00207	75 20		 jne	 SHORT $LN43@EncryptPar@2

; 399  : 	{
; 400  : 		handleWin32Error (MainDlg);

  00209	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  0020f	52		 push	 edx
  00210	e8 00 00 00 00	 call	 _handleWin32Error

; 401  : 		ShowInPlaceEncErrMsgWAltSteps ("INPLACE_ENC_CANT_ACCESS_OR_GET_INFO_ON_VOL_ALT", TRUE);

  00215	6a 01		 push	 1
  00217	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@BEBKAKBO@INPLACE_ENC_CANT_ACCESS_OR_GET_I@
  0021c	e8 00 00 00 00	 call	 _ShowInPlaceEncErrMsgWAltSteps
  00221	83 c4 0c	 add	 esp, 12			; 0000000cH

; 603  : 
; 604  : 
; 605  : 	nStatus = ERR_SUCCESS;

  00224	e9 3f 04 00 00	 jmp	 $LN142@EncryptPar@2
$LN43@EncryptPar@2:
  00229	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]

; 402  : 		nStatus = ERR_DONT_REPORT; 
; 403  : 		goto closing_seq;
; 404  : 	}
; 405  : 
; 406  : 
; 407  : 
; 408  : 	/* Shrink the filesystem */
; 409  : 
; 410  : 	int64 totalClusterCount;
; 411  : 	DWORD bytesPerCluster;
; 412  : 
; 413  : 	sizeToShrinkTo = NewFileSysSizeAfterShrink (dev, volParams->volumePath, &totalClusterCount, &bytesPerCluster, FALSE);

  0022c	8d 4c 24 50	 lea	 ecx, DWORD PTR _bytesPerCluster$[esp+1148]
  00230	55		 push	 ebp
  00231	51		 push	 ecx
  00232	8d 5c 24 68	 lea	 ebx, DWORD PTR _totalClusterCount$[esp+1156]
  00236	8b d6		 mov	 edx, esi
  00238	e8 00 00 00 00	 call	 ?NewFileSysSizeAfterShrink@@YA_JPAXPBDPA_JPAKH@Z ; NewFileSysSizeAfterShrink

; 414  : 
; 415  : 	if (sizeToShrinkTo == -1)

  0023d	8b c8		 mov	 ecx, eax
  0023f	23 ca		 and	 ecx, edx
  00241	83 c4 08	 add	 esp, 8
  00244	83 f9 ff	 cmp	 ecx, -1
  00247	75 14		 jne	 SHORT $LN41@EncryptPar@2

; 416  : 	{
; 417  : 		ShowInPlaceEncErrMsgWAltSteps ("INPLACE_ENC_CANT_ACCESS_OR_GET_INFO_ON_VOL_ALT", TRUE);

  00249	6a 01		 push	 1
  0024b	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@BEBKAKBO@INPLACE_ENC_CANT_ACCESS_OR_GET_I@
  00250	e8 00 00 00 00	 call	 _ShowInPlaceEncErrMsgWAltSteps
  00255	83 c4 08	 add	 esp, 8

; 603  : 
; 604  : 
; 605  : 	nStatus = ERR_SUCCESS;

  00258	e9 0b 04 00 00	 jmp	 $LN142@EncryptPar@2
$LN41@EncryptPar@2:

; 418  : 		nStatus = ERR_DONT_REPORT; 
; 419  : 		goto closing_seq;
; 420  : 	}
; 421  : 
; 422  : 	SetNonSysInplaceEncUIStatus (NONSYS_INPLACE_ENC_STATUS_RESIZING);
; 423  : 
; 424  : 	memset (&shrinkVolInfo, 0, sizeof (shrinkVolInfo));

  0025d	33 c9		 xor	 ecx, ecx
  0025f	33 ed		 xor	 ebp, ebp

; 425  : 
; 426  : 	shrinkVolInfo.ShrinkRequestType = ShrinkPrepare;
; 427  : 	shrinkVolInfo.NewNumberOfSectors = sizeToShrinkTo;
; 428  : 
; 429  : 	if (!DeviceIoControl (dev,
; 430  : 		FSCTL_SHRINK_VOLUME,
; 431  : 		(LPVOID) &shrinkVolInfo,
; 432  : 		sizeof (shrinkVolInfo),   
; 433  : 		NULL,
; 434  : 		0,
; 435  : 		&dwResult,
; 436  : 		NULL))

  00261	55		 push	 ebp
  00262	89 4c 24 50	 mov	 DWORD PTR _shrinkVolInfo$[esp+1172], ecx
  00266	89 54 24 50	 mov	 DWORD PTR _shrinkVolInfo$[esp+1172], edx
  0026a	8d 54 24 2c	 lea	 edx, DWORD PTR _dwResult$[esp+1152]
  0026e	52		 push	 edx
  0026f	55		 push	 ebp
  00270	55		 push	 ebp
  00271	89 4c 24 58	 mov	 DWORD PTR _shrinkVolInfo$[esp+1180], ecx
  00275	6a 18		 push	 24			; 00000018H
  00277	89 44 24 5c	 mov	 DWORD PTR _shrinkVolInfo$[esp+1184], eax
  0027b	8d 44 24 4c	 lea	 eax, DWORD PTR _shrinkVolInfo$[esp+1168]
  0027f	50		 push	 eax
  00280	68 b0 01 09 00	 push	 590256			; 000901b0H
  00285	89 4c 24 54	 mov	 DWORD PTR _shrinkVolInfo$[esp+1176], ecx
  00289	56		 push	 esi
  0028a	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR _NonSysInplaceEncStatus, 2
  00294	89 4c 24 5c	 mov	 DWORD PTR _shrinkVolInfo$[esp+1184], ecx
  00298	89 4c 24 60	 mov	 DWORD PTR _shrinkVolInfo$[esp+1188], ecx
  0029c	89 4c 24 64	 mov	 DWORD PTR _shrinkVolInfo$[esp+1192], ecx
  002a0	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR _shrinkVolInfo$[esp+1180], 1
  002a8	ff d7		 call	 edi
  002aa	85 c0		 test	 eax, eax
  002ac	75 20		 jne	 SHORT $LN39@EncryptPar@2

; 437  : 	{
; 438  : 		handleWin32Error (MainDlg);

  002ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _MainDlg
  002b4	51		 push	 ecx
  002b5	e8 00 00 00 00	 call	 _handleWin32Error

; 439  : 		ShowInPlaceEncErrMsgWAltSteps ("CANNOT_RESIZE_FILESYS", TRUE);

  002ba	6a 01		 push	 1
  002bc	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@EBLNDPCA@CANNOT_RESIZE_FILESYS?$AA@
  002c1	e8 00 00 00 00	 call	 _ShowInPlaceEncErrMsgWAltSteps
  002c6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 603  : 
; 604  : 
; 605  : 	nStatus = ERR_SUCCESS;

  002c9	e9 9a 03 00 00	 jmp	 $LN142@EncryptPar@2
$LN39@EncryptPar@2:

; 440  : 		nStatus = ERR_DONT_REPORT; 
; 441  : 		goto closing_seq;
; 442  : 	}
; 443  : 
; 444  : 	BOOL clustersMovedBeforeVolumeEnd = FALSE;
; 445  : 
; 446  : 	while (true)
; 447  : 	{
; 448  : 		shrinkVolInfo.ShrinkRequestType = ShrinkCommit;
; 449  : 		shrinkVolInfo.NewNumberOfSectors = 0;
; 450  : 
; 451  : 		if (!DeviceIoControl (dev, FSCTL_SHRINK_VOLUME, &shrinkVolInfo, sizeof (shrinkVolInfo), NULL, 0, &dwResult, NULL))

  002ce	55		 push	 ebp
  002cf	8d 54 24 2c	 lea	 edx, DWORD PTR _dwResult$[esp+1152]
  002d3	52		 push	 edx
  002d4	55		 push	 ebp
  002d5	55		 push	 ebp
  002d6	6a 18		 push	 24			; 00000018H
  002d8	8d 44 24 4c	 lea	 eax, DWORD PTR _shrinkVolInfo$[esp+1168]
  002dc	50		 push	 eax
  002dd	68 b0 01 09 00	 push	 590256			; 000901b0H
  002e2	56		 push	 esi
  002e3	33 db		 xor	 ebx, ebx
  002e5	c7 44 24 58 02
	00 00 00	 mov	 DWORD PTR _shrinkVolInfo$[esp+1180], 2
  002ed	89 6c 24 68	 mov	 DWORD PTR _shrinkVolInfo$[esp+1196], ebp
  002f1	89 6c 24 6c	 mov	 DWORD PTR _shrinkVolInfo$[esp+1200], ebp
  002f5	ff d7		 call	 edi
  002f7	85 c0		 test	 eax, eax
  002f9	0f 85 91 00 00
	00		 jne	 $LN35@EncryptPar@2
  002ff	90		 npad	 1
$LL37@EncryptPar@2:

; 452  : 		{
; 453  : 			// If there are any occupied clusters beyond the new desired end of the volume, the call fails with
; 454  : 			// ERROR_ACCESS_DENIED (STATUS_ALREADY_COMMITTED). 
; 455  : 			if (GetLastError () == ERROR_ACCESS_DENIED)

  00300	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00306	83 f8 05	 cmp	 eax, 5
  00309	0f 85 f4 00 00
	00		 jne	 $LN34@EncryptPar@2

; 456  : 			{
; 457  : 				if (!clustersMovedBeforeVolumeEnd)

  0030f	3b dd		 cmp	 ebx, ebp
  00311	0f 85 fb 00 00
	00		 jne	 $LN31@EncryptPar@2

; 458  : 				{
; 459  : 					if (MoveClustersBeforeThreshold (dev, deviceName, totalClusterCount - (bytesPerCluster > TC_TOTAL_VOLUME_HEADERS_SIZE ? 1 : TC_TOTAL_VOLUME_HEADERS_SIZE / bytesPerCluster)))

  00317	8b 4c 24 50	 mov	 ecx, DWORD PTR _bytesPerCluster$[esp+1148]
  0031b	81 f9 00 00 04
	00		 cmp	 ecx, 262144		; 00040000H
  00321	76 07		 jbe	 SHORT $LN60@EncryptPar@2
  00323	b8 01 00 00 00	 mov	 eax, 1
  00328	eb 09		 jmp	 SHORT $LN61@EncryptPar@2
$LN60@EncryptPar@2:
  0032a	b8 00 00 04 00	 mov	 eax, 262144		; 00040000H
  0032f	33 d2		 xor	 edx, edx
  00331	f7 f1		 div	 ecx
$LN61@EncryptPar@2:
  00333	8b 54 24 60	 mov	 edx, DWORD PTR _totalClusterCount$[esp+1148]
  00337	33 c9		 xor	 ecx, ecx
  00339	2b d0		 sub	 edx, eax
  0033b	8b 44 24 64	 mov	 eax, DWORD PTR _totalClusterCount$[esp+1152]
  0033f	1b c1		 sbb	 eax, ecx
  00341	50		 push	 eax
  00342	52		 push	 edx
  00343	8d 8c 24 78 02
	00 00		 lea	 ecx, DWORD PTR _deviceName$[esp+1156]
  0034a	51		 push	 ecx
  0034b	56		 push	 esi
  0034c	e8 00 00 00 00	 call	 _MoveClustersBeforeThreshold
  00351	83 c4 10	 add	 esp, 16			; 00000010H
  00354	85 c0		 test	 eax, eax
  00356	0f 84 9e 00 00
	00		 je	 $LN32@EncryptPar@2
  0035c	55		 push	 ebp
  0035d	8d 54 24 2c	 lea	 edx, DWORD PTR _dwResult$[esp+1152]
  00361	52		 push	 edx
  00362	55		 push	 ebp
  00363	55		 push	 ebp
  00364	6a 18		 push	 24			; 00000018H
  00366	8d 44 24 4c	 lea	 eax, DWORD PTR _shrinkVolInfo$[esp+1168]
  0036a	50		 push	 eax
  0036b	68 b0 01 09 00	 push	 590256			; 000901b0H
  00370	56		 push	 esi

; 460  : 					{
; 461  : 						clustersMovedBeforeVolumeEnd = TRUE;

  00371	bb 01 00 00 00	 mov	 ebx, 1
  00376	c7 44 24 58 02
	00 00 00	 mov	 DWORD PTR _shrinkVolInfo$[esp+1180], 2
  0037e	89 6c 24 68	 mov	 DWORD PTR _shrinkVolInfo$[esp+1196], ebp
  00382	89 6c 24 6c	 mov	 DWORD PTR _shrinkVolInfo$[esp+1200], ebp
  00386	ff d7		 call	 edi
  00388	85 c0		 test	 eax, eax
  0038a	0f 84 70 ff ff
	ff		 je	 $LL37@EncryptPar@2
$LN35@EncryptPar@2:

; 472  : 			nStatus = ERR_DONT_REPORT; 
; 473  : 			goto closing_seq;
; 474  : 		}
; 475  : 
; 476  : 		break;
; 477  : 	}
; 478  : 
; 479  : 	SetNonSysInplaceEncUIStatus (NONSYS_INPLACE_ENC_STATUS_PREPARING);
; 480  : 
; 481  : 
; 482  : 	/* Gain exclusive access to the volume */
; 483  : 
; 484  : 	nStatus = DismountFileSystem (dev,
; 485  : 		driveLetter,
; 486  : 		TRUE,
; 487  : 		TRUE,
; 488  : 		FALSE);

  00390	8b 44 24 14	 mov	 eax, DWORD PTR _driveLetter$[esp+1148]
  00394	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _MainDlg
  0039a	50		 push	 eax
  0039b	51		 push	 ecx
  0039c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _NonSysInplaceEncStatus, 1
  003a6	e8 00 00 00 00	 call	 _CloseVolumeExplorerWindows
  003ab	83 c4 08	 add	 esp, 8
  003ae	6a 00		 push	 0
  003b0	8d 54 24 30	 lea	 edx, DWORD PTR _dwResult$128640[esp+1152]
  003b4	52		 push	 edx
  003b5	6a 00		 push	 0
  003b7	6a 00		 push	 0
  003b9	6a 00		 push	 0
  003bb	6a 00		 push	 0
  003bd	68 18 00 09 00	 push	 589848			; 00090018H
  003c2	56		 push	 esi
  003c3	bb 2c 01 00 00	 mov	 ebx, 300		; 0000012cH
  003c8	ff d7		 call	 edi
  003ca	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__Sleep@4
  003d0	85 c0		 test	 eax, eax
  003d2	75 6c		 jne	 SHORT $LN95@EncryptPar@2
$LL100@EncryptPar@2:
  003d4	85 db		 test	 ebx, ebx
  003d6	7e 4e		 jle	 SHORT $LN99@EncryptPar@2
  003d8	6a 32		 push	 50			; 00000032H
  003da	ff d5		 call	 ebp
  003dc	6a 00		 push	 0
  003de	8d 44 24 30	 lea	 eax, DWORD PTR _dwResult$128640[esp+1152]
  003e2	50		 push	 eax
  003e3	6a 00		 push	 0
  003e5	6a 00		 push	 0
  003e7	6a 00		 push	 0
  003e9	6a 00		 push	 0
  003eb	68 18 00 09 00	 push	 589848			; 00090018H
  003f0	56		 push	 esi
  003f1	4b		 dec	 ebx
  003f2	ff d7		 call	 edi
  003f4	85 c0		 test	 eax, eax
  003f6	74 dc		 je	 SHORT $LL100@EncryptPar@2
  003f8	eb 46		 jmp	 SHORT $LN95@EncryptPar@2
$LN32@EncryptPar@2:

; 462  : 						continue;
; 463  : 					}
; 464  : 
; 465  : 					handleWin32Error (MainDlg);

  003fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _MainDlg
  00400	51		 push	 ecx

; 466  : 				}
; 467  : 			}
; 468  : 			else

  00401	eb 07		 jmp	 SHORT $LN143@EncryptPar@2
$LN34@EncryptPar@2:

; 469  : 				handleWin32Error (MainDlg);

  00403	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  00409	52		 push	 edx
$LN143@EncryptPar@2:
  0040a	e8 00 00 00 00	 call	 _handleWin32Error
  0040f	83 c4 04	 add	 esp, 4
$LN31@EncryptPar@2:

; 470  : 
; 471  : 			ShowInPlaceEncErrMsgWAltSteps ("CANNOT_RESIZE_FILESYS", TRUE);

  00412	6a 01		 push	 1
  00414	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@EBLNDPCA@CANNOT_RESIZE_FILESYS?$AA@
  00419	e8 00 00 00 00	 call	 _ShowInPlaceEncErrMsgWAltSteps
  0041e	83 c4 08	 add	 esp, 8

; 603  : 
; 604  : 
; 605  : 	nStatus = ERR_SUCCESS;

  00421	e9 42 02 00 00	 jmp	 $LN142@EncryptPar@2

; 472  : 			nStatus = ERR_DONT_REPORT; 
; 473  : 			goto closing_seq;
; 474  : 		}
; 475  : 
; 476  : 		break;
; 477  : 	}
; 478  : 
; 479  : 	SetNonSysInplaceEncUIStatus (NONSYS_INPLACE_ENC_STATUS_PREPARING);
; 480  : 
; 481  : 
; 482  : 	/* Gain exclusive access to the volume */
; 483  : 
; 484  : 	nStatus = DismountFileSystem (dev,
; 485  : 		driveLetter,
; 486  : 		TRUE,
; 487  : 		TRUE,
; 488  : 		FALSE);

$LN99@EncryptPar@2:
  00426	85 c0		 test	 eax, eax
  00428	75 16		 jne	 SHORT $LN95@EncryptPar@2
  0042a	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@LMIKKFBM@VOL_LOCK_FAILED_OFFER_FORCED_DIS@
  0042f	e8 00 00 00 00	 call	 _AskWarnYesNo
  00434	83 c4 04	 add	 esp, 4
  00437	83 f8 07	 cmp	 eax, 7
  0043a	0f 84 28 02 00
	00		 je	 $LN142@EncryptPar@2
$LN95@EncryptPar@2:
  00440	6a 00		 push	 0
  00442	8d 4c 24 30	 lea	 ecx, DWORD PTR _dwResult$128640[esp+1152]
  00446	51		 push	 ecx
  00447	6a 00		 push	 0
  00449	6a 00		 push	 0
  0044b	6a 00		 push	 0
  0044d	6a 00		 push	 0
  0044f	68 20 00 09 00	 push	 589856			; 00090020H
  00454	56		 push	 esi
  00455	bb 2c 01 00 00	 mov	 ebx, 300		; 0000012cH
  0045a	ff d7		 call	 edi
  0045c	85 c0		 test	 eax, eax
  0045e	75 24		 jne	 SHORT $LN138@EncryptPar@2
$LL94@EncryptPar@2:
  00460	85 db		 test	 ebx, ebx
  00462	7e 75		 jle	 SHORT $LN93@EncryptPar@2
  00464	6a 32		 push	 50			; 00000032H
  00466	ff d5		 call	 ebp
  00468	6a 00		 push	 0
  0046a	8d 54 24 30	 lea	 edx, DWORD PTR _dwResult$128640[esp+1152]
  0046e	52		 push	 edx
  0046f	6a 00		 push	 0
  00471	6a 00		 push	 0
  00473	6a 00		 push	 0
  00475	6a 00		 push	 0
  00477	68 20 00 09 00	 push	 589856			; 00090020H
  0047c	56		 push	 esi
  0047d	4b		 dec	 ebx
  0047e	ff d7		 call	 edi
  00480	85 c0		 test	 eax, eax
  00482	74 dc		 je	 SHORT $LL94@EncryptPar@2
$LN138@EncryptPar@2:

; 489  : 
; 490  : 	if (nStatus != ERR_SUCCESS)
; 491  : 	{
; 492  : 		nStatus = ERR_DONT_REPORT; 
; 493  : 		goto closing_seq;
; 494  : 	}
; 495  : 
; 496  : 
; 497  : 
; 498  : 	/* Create header backup on the partition. Until the volume is fully encrypted, the backup header will provide 
; 499  : 	us with the master key, encrypted range, and other data for pause/resume operations. We cannot create the 
; 500  : 	primary header until the entire partition is encrypted (because we encrypt backwards and the primary header 
; 501  : 	area is occuppied by data until the very end of the process). */
; 502  : 
; 503  : 	// Prepare the backup header
; 504  : 	for (int wipePass = 0; wipePass < (wipeAlgorithm == TC_WIPE_NONE ? 1 : PRAND_DISK_WIPE_PASSES); wipePass++)

  00484	8b 84 24 88 04
	00 00		 mov	 eax, DWORD PTR _wipeAlgorithm$[esp+1144]
  0048b	f7 d8		 neg	 eax
  0048d	1b c0		 sbb	 eax, eax
  0048f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00494	40		 inc	 eax
  00495	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _wipePass$119707[esp+1148], 0
  0049d	89 44 24 54	 mov	 DWORD PTR $T128679[esp+1148], eax
  004a1	85 c0		 test	 eax, eax
  004a3	0f 8e 0b 01 00
	00		 jle	 $LN139@EncryptPar@2
  004a9	8b 5c 24 30	 mov	 ebx, DWORD PTR _dataAreaSize$[esp+1148]
  004ad	8b 6c 24 34	 mov	 ebp, DWORD PTR _dataAreaSize$[esp+1152]
  004b1	8b 44 24 14	 mov	 eax, DWORD PTR _wipePass$119707[esp+1148]
  004b5	81 c3 00 00 02
	00		 add	 ebx, 131072		; 00020000H
  004bb	83 d5 00	 adc	 ebp, 0
  004be	8b ff		 npad	 2
$LL134@EncryptPar@2:

; 505  : 	{
; 506  : 		nStatus = CreateVolumeHeaderInMemory (FALSE,
; 507  : 			header,
; 508  : 			volParams->ea,
; 509  : 			FIRST_MODE_OF_OPERATION_ID,
; 510  : 			volParams->password,
; 511  : 			volParams->pkcs5,
; 512  : 			wipePass == 0 ? NULL : (char *) cryptoInfo->master_keydata,
; 513  : 			&cryptoInfo,
; 514  : 			dataAreaSize,
; 515  : 			0,
; 516  : 			TC_VOLUME_DATA_OFFSET + dataAreaSize,	// Start of the encrypted area = the first byte of the backup heeader (encrypting from the end)
; 517  : 			0,	// No data is encrypted yet
; 518  : 			0,
; 519  : 			volParams->headerFlags | TC_HEADER_FLAG_NONSYS_INPLACE_ENC,
; 520  : 			volParams->sectorSize,
; 521  : 			wipeAlgorithm == TC_WIPE_NONE ? FALSE : (wipePass < PRAND_DISK_WIPE_PASSES - 1));

  004c0	33 c9		 xor	 ecx, ecx
  004c2	39 8c 24 88 04
	00 00		 cmp	 DWORD PTR _wipeAlgorithm$[esp+1144], ecx
  004c9	74 08		 je	 SHORT $LN63@EncryptPar@2
  004cb	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  004d0	0f 9c c1	 setl	 cl
$LN63@EncryptPar@2:
  004d3	85 c0		 test	 eax, eax
  004d5	75 1a		 jne	 SHORT $LN64@EncryptPar@2
  004d7	eb 21		 jmp	 SHORT $LN65@EncryptPar@2

; 472  : 			nStatus = ERR_DONT_REPORT; 
; 473  : 			goto closing_seq;
; 474  : 		}
; 475  : 
; 476  : 		break;
; 477  : 	}
; 478  : 
; 479  : 	SetNonSysInplaceEncUIStatus (NONSYS_INPLACE_ENC_STATUS_PREPARING);
; 480  : 
; 481  : 
; 482  : 	/* Gain exclusive access to the volume */
; 483  : 
; 484  : 	nStatus = DismountFileSystem (dev,
; 485  : 		driveLetter,
; 486  : 		TRUE,
; 487  : 		TRUE,
; 488  : 		FALSE);

$LN93@EncryptPar@2:
  004d9	85 c0		 test	 eax, eax
  004db	75 a7		 jne	 SHORT $LN138@EncryptPar@2
  004dd	6a 01		 push	 1
  004df	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@OMIEFGPE@INPLACE_ENC_CANT_LOCK_OR_DISMOUN@
  004e4	e8 00 00 00 00	 call	 _ShowInPlaceEncErrMsgWAltSteps
  004e9	83 c4 08	 add	 esp, 8

; 603  : 
; 604  : 
; 605  : 	nStatus = ERR_SUCCESS;

  004ec	e9 77 01 00 00	 jmp	 $LN142@EncryptPar@2
$LN64@EncryptPar@2:

; 505  : 	{
; 506  : 		nStatus = CreateVolumeHeaderInMemory (FALSE,
; 507  : 			header,
; 508  : 			volParams->ea,
; 509  : 			FIRST_MODE_OF_OPERATION_ID,
; 510  : 			volParams->password,
; 511  : 			volParams->pkcs5,
; 512  : 			wipePass == 0 ? NULL : (char *) cryptoInfo->master_keydata,
; 513  : 			&cryptoInfo,
; 514  : 			dataAreaSize,
; 515  : 			0,
; 516  : 			TC_VOLUME_DATA_OFFSET + dataAreaSize,	// Start of the encrypted area = the first byte of the backup heeader (encrypting from the end)
; 517  : 			0,	// No data is encrypted yet
; 518  : 			0,
; 519  : 			volParams->headerFlags | TC_HEADER_FLAG_NONSYS_INPLACE_ENC,
; 520  : 			volParams->sectorSize,
; 521  : 			wipeAlgorithm == TC_WIPE_NONE ? FALSE : (wipePass < PRAND_DISK_WIPE_PASSES - 1));

  004f1	8b 44 24 10	 mov	 eax, DWORD PTR _cryptoInfo$[esp+1148]
  004f5	05 a8 41 00 00	 add	 eax, 16808		; 000041a8H
$LN65@EncryptPar@2:
  004fa	51		 push	 ecx
  004fb	8b 4c 24 24	 mov	 ecx, DWORD PTR _volParams$GSCopy$[esp+1152]
  004ff	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00502	52		 push	 edx
  00503	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00506	83 ca 02	 or	 edx, 2
  00509	52		 push	 edx
  0050a	8b 54 24 40	 mov	 edx, DWORD PTR _dataAreaSize$[esp+1164]
  0050e	6a 00		 push	 0
  00510	6a 00		 push	 0
  00512	6a 00		 push	 0
  00514	55		 push	 ebp
  00515	53		 push	 ebx
  00516	6a 00		 push	 0
  00518	6a 00		 push	 0
  0051a	52		 push	 edx
  0051b	8b 54 24 5c	 mov	 edx, DWORD PTR _dataAreaSize$[esp+1192]
  0051f	52		 push	 edx
  00520	8d 54 24 40	 lea	 edx, DWORD PTR _cryptoInfo$[esp+1196]
  00524	52		 push	 edx
  00525	50		 push	 eax
  00526	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00529	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  0052c	50		 push	 eax
  0052d	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00530	8b 4c 24 58	 mov	 ecx, DWORD PTR _header$[esp+1208]
  00534	52		 push	 edx
  00535	6a 01		 push	 1
  00537	50		 push	 eax
  00538	51		 push	 ecx
  00539	6a 00		 push	 0
  0053b	e8 00 00 00 00	 call	 _CreateVolumeHeaderInMemory
  00540	8b f8		 mov	 edi, eax
  00542	83 c4 50	 add	 esp, 80			; 00000050H

; 522  : 
; 523  : 		if (nStatus != 0)

  00545	85 ff		 test	 edi, edi
  00547	0f 85 20 01 00
	00		 jne	 $closing_seq$119670

; 524  : 			goto closing_seq;
; 525  : 
; 526  : 		offset.QuadPart = TC_VOLUME_DATA_OFFSET + dataAreaSize;
; 527  : 
; 528  : 		if (!SetFilePointerEx (dev, offset, NULL, FILE_BEGIN))

  0054d	57		 push	 edi
  0054e	57		 push	 edi
  0054f	8b cd		 mov	 ecx, ebp
  00551	51		 push	 ecx
  00552	8b c3		 mov	 eax, ebx
  00554	50		 push	 eax
  00555	56		 push	 esi
  00556	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  0055c	85 c0		 test	 eax, eax
  0055e	0f 84 f0 00 00
	00		 je	 $LN117@EncryptPar@2

; 529  : 		{
; 530  : 			nStatus = ERR_OS_ERROR;
; 531  : 			goto closing_seq;
; 532  : 		}
; 533  : 
; 534  : 		// Write the backup header to the partition
; 535  : 		if (!WriteEffectiveVolumeHeader (TRUE, dev, (byte *) header))

  00564	8b 54 24 1c	 mov	 edx, DWORD PTR _header$[esp+1148]
  00568	52		 push	 edx
  00569	56		 push	 esi
  0056a	6a 01		 push	 1
  0056c	e8 00 00 00 00	 call	 _WriteEffectiveVolumeHeader
  00571	83 c4 0c	 add	 esp, 12			; 0000000cH
  00574	85 c0		 test	 eax, eax
  00576	0f 84 d8 00 00
	00		 je	 $LN117@EncryptPar@2

; 538  : 			goto closing_seq;
; 539  : 		}
; 540  : 
; 541  : 		// Fill the reserved sectors of the backup header area with random data
; 542  : 		nStatus = WriteRandomDataToReservedHeaderAreas (dev, cryptoInfo, dataAreaSize, FALSE, TRUE);

  0057c	8b 44 24 34	 mov	 eax, DWORD PTR _dataAreaSize$[esp+1152]
  00580	8b 4c 24 30	 mov	 ecx, DWORD PTR _dataAreaSize$[esp+1148]
  00584	8b 54 24 10	 mov	 edx, DWORD PTR _cryptoInfo$[esp+1148]
  00588	6a 01		 push	 1
  0058a	57		 push	 edi
  0058b	50		 push	 eax
  0058c	51		 push	 ecx
  0058d	52		 push	 edx
  0058e	56		 push	 esi
  0058f	e8 00 00 00 00	 call	 _WriteRandomDataToReservedHeaderAreas
  00594	8b f8		 mov	 edi, eax
  00596	83 c4 18	 add	 esp, 24			; 00000018H

; 543  : 
; 544  : 		if (nStatus != ERR_SUCCESS)

  00599	85 ff		 test	 edi, edi
  0059b	0f 85 cc 00 00
	00		 jne	 $closing_seq$119670
  005a1	8b 44 24 14	 mov	 eax, DWORD PTR _wipePass$119707[esp+1148]
  005a5	40		 inc	 eax
  005a6	3b 44 24 54	 cmp	 eax, DWORD PTR $T128679[esp+1148]
  005aa	89 44 24 14	 mov	 DWORD PTR _wipePass$119707[esp+1148], eax
  005ae	0f 8c 0c ff ff
	ff		 jl	 $LL134@EncryptPar@2
$LN139@EncryptPar@2:

; 603  : 
; 604  : 
; 605  : 	nStatus = ERR_SUCCESS;

  005b4	8b 44 24 20	 mov	 eax, DWORD PTR _volParams$GSCopy$[esp+1148]
  005b8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  005bb	8b 54 24 5c	 mov	 edx, DWORD PTR _deviceSize$[esp+1152]
  005bf	8b 4c 24 58	 mov	 ecx, DWORD PTR _deviceSize$[esp+1148]
  005c3	8b 40 44	 mov	 eax, DWORD PTR [eax+68]
  005c6	52		 push	 edx
  005c7	51		 push	 ecx
  005c8	6a 00		 push	 0
  005ca	8d 54 24 24	 lea	 edx, DWORD PTR _cryptoInfo2$[esp+1160]
  005ce	52		 push	 edx
  005cf	50		 push	 eax
  005d0	8b c6		 mov	 eax, esi
  005d2	e8 00 00 00 00	 call	 _OpenBackupHeader
  005d7	8b f8		 mov	 edi, eax
  005d9	83 c4 14	 add	 esp, 20			; 00000014H
  005dc	85 ff		 test	 edi, edi
  005de	0f 85 89 00 00
	00		 jne	 $closing_seq$119670
  005e4	8b 4c 24 18	 mov	 ecx, DWORD PTR _cryptoInfo2$[esp+1148]
  005e8	8b 54 24 10	 mov	 edx, DWORD PTR _cryptoInfo$[esp+1148]
  005ec	8b 81 50 44 00
	00		 mov	 eax, DWORD PTR [ecx+17488]
  005f2	8b ba 50 44 00
	00		 mov	 edi, DWORD PTR [edx+17488]
  005f8	8b 89 54 44 00
	00		 mov	 ecx, DWORD PTR [ecx+17492]
  005fe	3b f8		 cmp	 edi, eax
  00600	0f 85 f2 fa ff
	ff		 jne	 $LN131@EncryptPar@2
  00606	8b 92 54 44 00
	00		 mov	 edx, DWORD PTR [edx+17492]
  0060c	3b d1		 cmp	 edx, ecx
  0060e	0f 85 e4 fa ff
	ff		 jne	 $LN131@EncryptPar@2

; 545  : 			goto closing_seq;
; 546  : 	}
; 547  : 
; 548  : 
; 549  : 	/* Now we will try to decrypt the backup header to verify it has been correctly written. */
; 550  : 
; 551  : 	nStatus = OpenBackupHeader (dev, volParams->volumePath, volParams->password, &cryptoInfo2, NULL, deviceSize);
; 552  : 
; 553  : 	if (nStatus != ERR_SUCCESS
; 554  : 		|| cryptoInfo->EncryptedAreaStart.Value != cryptoInfo2->EncryptedAreaStart.Value
; 555  : 		|| cryptoInfo2->EncryptedAreaStart.Value == 0)

  00614	0b c1		 or	 eax, ecx
  00616	0f 84 dc fa ff
	ff		 je	 $LN131@EncryptPar@2

; 556  : 	{
; 557  : 		if (nStatus == ERR_SUCCESS)
; 558  : 			nStatus = ERR_PARAMETER_INCORRECT;
; 559  : 
; 560  : 		goto closing_seq;
; 561  : 	}
; 562  : 
; 563  : 	// The backup header is valid so we know we should be able to safely resume in-place encryption 
; 564  : 	// of this partition even if the system/app crashes.
; 565  : 
; 566  : 
; 567  : 
; 568  : 	/* Conceal the NTFS filesystem (by performing an easy-to-undo modification). This will prevent Windows 
; 569  : 	and apps from interfering with the volume until it has been fully encrypted. */
; 570  : 
; 571  : 	nStatus = ConcealNTFS (dev);

  0061c	e8 00 00 00 00	 call	 _ConcealNTFS
  00621	8b f8		 mov	 edi, eax

; 572  : 
; 573  : 	if (nStatus != ERR_SUCCESS)

  00623	85 ff		 test	 edi, edi
  00625	75 46		 jne	 SHORT $closing_seq$119670

; 574  : 		goto closing_seq;
; 575  : 
; 576  : 
; 577  : 
; 578  : 	// /* If a drive letter is assigned to the device, remove it (so that users do not try to open it, which
; 579  : 	//would cause Windows to ask them if they want to format the volume and other dangerous things). */
; 580  : 
; 581  : 	//if (driveLetter >= 0) 
; 582  : 	//{
; 583  : 	//	char rootPath[] = { driveLetter + 'A', ':', '\\', 0 };
; 584  : 
; 585  : 	//	// Try to remove the assigned drive letter
; 586  : 	//	if (DeleteVolumeMountPoint (rootPath))
; 587  : 	//		driveLetter = -1;
; 588  : 	//}
; 589  : 
; 590  : 
; 591  : 
; 592  : 	/* Update config files and app data */
; 593  : 
; 594  : 	// In the config file, increase the number of partitions where in-place encryption is in progress
; 595  : 
; 596  : 	SaveNonSysInPlaceEncSettings (1, wipeAlgorithm);

  00627	8b 84 24 88 04
	00 00		 mov	 eax, DWORD PTR _wipeAlgorithm$[esp+1144]
  0062e	50		 push	 eax
  0062f	6a 01		 push	 1
  00631	e8 00 00 00 00	 call	 _SaveNonSysInPlaceEncSettings
  00636	83 c4 08	 add	 esp, 8

; 597  : 
; 598  : 
; 599  : 	// Add the wizard to the system startup sequence if appropriate
; 600  : 
; 601  : 	if (!IsNonInstallMode ())

  00639	e8 00 00 00 00	 call	 _IsNonInstallMode
  0063e	85 c0		 test	 eax, eax
  00640	75 0e		 jne	 SHORT $LN135@EncryptPar@2

; 602  : 		ManageStartupSeqWiz (FALSE, "/prinplace");

  00642	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DLEMDKJB@?1prinplace?$AA@
  00647	50		 push	 eax
  00648	e8 00 00 00 00	 call	 _ManageStartupSeqWiz
  0064d	83 c4 08	 add	 esp, 8
$LN135@EncryptPar@2:

; 603  : 
; 604  : 
; 605  : 	nStatus = ERR_SUCCESS;

  00650	33 ff		 xor	 edi, edi
  00652	eb 19		 jmp	 SHORT $closing_seq$119670
$LN117@EncryptPar@2:

; 536  : 		{
; 537  : 			nStatus = ERR_OS_ERROR;

  00654	bf 01 00 00 00	 mov	 edi, 1

; 603  : 
; 604  : 
; 605  : 	nStatus = ERR_SUCCESS;

  00659	eb 12		 jmp	 SHORT $closing_seq$119670
$LN48@EncryptPar@2:

; 373  : 
; 374  : 		if (dev == INVALID_HANDLE_VALUE)
; 375  : 		{
; 376  : 			nStatus = ERR_DONT_REPORT; 
; 377  : 			goto closing_seq;
; 378  : 		}
; 379  : 	}
; 380  : 	else
; 381  : 	{
; 382  : 		// The volume is not mounted so we can't work with the filesystem.
; 383  : 		Error ("ONLY_MOUNTED_VOL_SUPPORTED_FOR_NONSYS_INPLACE_ENC");

  0065b	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@BPGKKGKD@ONLY_MOUNTED_VOL_SUPPORTED_FOR_N@
  00660	e8 00 00 00 00	 call	 _Error
  00665	83 c4 04	 add	 esp, 4
$LN142@EncryptPar@2:

; 384  : 		nStatus = ERR_DONT_REPORT; 

  00668	bf 1c 00 00 00	 mov	 edi, 28			; 0000001cH
$closing_seq$119670:

; 606  : 
; 607  : 
; 608  : closing_seq:
; 609  : 
; 610  : 	dwError = GetLastError();

  0066d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00673	8b e8		 mov	 ebp, eax

; 611  : 
; 612  : 	if (cryptoInfo != NULL)

  00675	8b 44 24 10	 mov	 eax, DWORD PTR _cryptoInfo$[esp+1148]
  00679	33 f6		 xor	 esi, esi
  0067b	3b c6		 cmp	 eax, esi
  0067d	74 0d		 je	 SHORT $LN9@EncryptPar@2

; 613  : 	{
; 614  : 		crypto_close (cryptoInfo);

  0067f	50		 push	 eax
  00680	e8 00 00 00 00	 call	 _crypto_close
  00685	83 c4 04	 add	 esp, 4

; 615  : 		cryptoInfo = NULL;

  00688	89 74 24 10	 mov	 DWORD PTR _cryptoInfo$[esp+1148], esi
$LN9@EncryptPar@2:

; 616  : 	}
; 617  : 
; 618  : 	if (cryptoInfo2 != NULL)

  0068c	8b 44 24 18	 mov	 eax, DWORD PTR _cryptoInfo2$[esp+1148]
  00690	3b c6		 cmp	 eax, esi
  00692	74 0d		 je	 SHORT $LN7@EncryptPar@2

; 619  : 	{
; 620  : 		crypto_close (cryptoInfo2);

  00694	50		 push	 eax
  00695	e8 00 00 00 00	 call	 _crypto_close
  0069a	83 c4 04	 add	 esp, 4

; 621  : 		cryptoInfo2 = NULL;

  0069d	89 74 24 18	 mov	 DWORD PTR _cryptoInfo2$[esp+1148], esi
$LN7@EncryptPar@2:

; 622  : 	}
; 623  : 
; 624  : 	burn (header, TC_VOLUME_HEADER_EFFECTIVE_SIZE);

  006a1	8b 5c 24 1c	 mov	 ebx, DWORD PTR _header$[esp+1148]
  006a5	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  006aa	8b d3		 mov	 edx, ebx
  006ac	8b f1		 mov	 esi, ecx
  006ae	8b c3		 mov	 eax, ebx
$LL104@EncryptPar@2:
  006b0	c6 00 00	 mov	 BYTE PTR [eax], 0
  006b3	40		 inc	 eax
  006b4	83 ee 01	 sub	 esi, 1
  006b7	75 f7		 jne	 SHORT $LL104@EncryptPar@2
  006b9	5e		 pop	 esi
  006ba	8d 9b 00 00 00
	00		 npad	 6
$LL4@EncryptPar@2:
  006c0	49		 dec	 ecx
  006c1	c6 02 00	 mov	 BYTE PTR [edx], 0
  006c4	42		 inc	 edx
  006c5	85 c9		 test	 ecx, ecx
  006c7	75 f7		 jne	 SHORT $LL4@EncryptPar@2

; 625  : 	VirtualUnlock (header, TC_VOLUME_HEADER_EFFECTIVE_SIZE);

  006c9	68 00 02 00 00	 push	 512			; 00000200H
  006ce	53		 push	 ebx
  006cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualUnlock@8

; 626  : 	TCfree (header);

  006d5	53		 push	 ebx
  006d6	e8 00 00 00 00	 call	 _free
  006db	83 c4 04	 add	 esp, 4

; 627  : 
; 628  : 	if (dosDev[0])

  006de	80 bc 24 68 01
	00 00 00	 cmp	 BYTE PTR _dosDev$[esp+1144], 0
  006e6	74 18		 je	 SHORT $LN2@EncryptPar@2

; 629  : 		RemoveFakeDosName (volParams->volumePath, dosDev);

  006e8	8b 54 24 1c	 mov	 edx, DWORD PTR _volParams$GSCopy$[esp+1144]
  006ec	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  006ef	8d 8c 24 68 01
	00 00		 lea	 ecx, DWORD PTR _dosDev$[esp+1144]
  006f6	51		 push	 ecx
  006f7	50		 push	 eax
  006f8	e8 00 00 00 00	 call	 _RemoveFakeDosName
  006fd	83 c4 08	 add	 esp, 8
$LN2@EncryptPar@2:

; 630  : 
; 631  : 	*outHandle = dev;

  00700	8b 8c 24 80 04
	00 00		 mov	 ecx, DWORD PTR _outHandle$[esp+1140]
  00707	8b 54 24 20	 mov	 edx, DWORD PTR _dev$[esp+1144]
  0070b	89 11		 mov	 DWORD PTR [ecx], edx

; 632  : 
; 633  : 	if (nStatus != ERR_SUCCESS)

  0070d	85 ff		 test	 edi, edi
  0070f	74 07		 je	 SHORT $LN1@EncryptPar@2

; 634  : 		SetLastError (dwError);

  00711	55		 push	 ebp
  00712	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
$LN1@EncryptPar@2:

; 635  : 
; 636  : 	return nStatus;
; 637  : }

  00718	8b 8c 24 74 04
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1144]
  0071f	8b c7		 mov	 eax, edi
  00721	5f		 pop	 edi
  00722	5d		 pop	 ebp
  00723	5b		 pop	 ebx
  00724	33 cc		 xor	 ecx, esp
  00726	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0072b	81 c4 6c 04 00
	00		 add	 esp, 1132		; 0000046cH
  00731	c3		 ret	 0
_EncryptPartitionInPlaceBegin ENDP
_TEXT	ENDS
END
