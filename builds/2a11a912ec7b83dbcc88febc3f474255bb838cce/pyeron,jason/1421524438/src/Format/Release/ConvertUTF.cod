; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\home\public\Desktop\projects\ciphershed.build\src\Common\util\unicode\ConvertUTF.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
_halfShift DD	0aH
_halfBase DD	010000H
_halfMask DD	03ffH
	ORG $+4
_trailingBytesForUTF8 DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
_offsetsFromUTF8 DD 00H
	DD	03080H
	DD	0e2080H
	DD	03c82080H
	DD	0fa082080H
	DD	082082080H
_firstByteMark DB 00H
	DB	00H
	DB	0c0H
	DB	0e0H
	DB	0f0H
	DB	0f8H
	DB	0fcH
CONST	ENDS
PUBLIC	_ConvertUTF32toUTF16
; Function compile flags: /Ogtpy
; File c:\home\public\desktop\projects\ciphershed.build\src\common\util\unicode\convertutf.c
;	COMDAT _ConvertUTF32toUTF16
_TEXT	SEGMENT
_sourceStart$ = 8					; size = 4
_sourceEnd$ = 12					; size = 4
_targetStart$ = 16					; size = 4
_targetEnd$ = 20					; size = 4
_flags$ = 24						; size = 4
_ConvertUTF32toUTF16 PROC				; COMDAT

; 118  :     ConversionResult result = conversionOK;
; 119  :     const UTF32* source = *sourceStart;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _sourceStart$[esp-4]

; 120  :     UTF16* target = *targetStart;

  00004	8b 54 24 0c	 mov	 edx, DWORD PTR _targetStart$[esp-4]
  00008	8b 12		 mov	 edx, DWORD PTR [edx]
  0000a	57		 push	 edi
  0000b	8b 39		 mov	 edi, DWORD PTR [ecx]
  0000d	33 c0		 xor	 eax, eax

; 121  :     while (source < sourceEnd) {

  0000f	3b 7c 24 0c	 cmp	 edi, DWORD PTR _sourceEnd$[esp]
  00013	0f 83 bb 00 00
	00		 jae	 $LN13@ConvertUTF
  00019	53		 push	 ebx
  0001a	8b 5c 24 1c	 mov	 ebx, DWORD PTR _flags$[esp+4]
  0001e	55		 push	 ebp
  0001f	56		 push	 esi
  00020	8d 72 02	 lea	 esi, DWORD PTR [edx+2]
$LL21@ConvertUTF:
  00023	8b 6c 24 20	 mov	 ebp, DWORD PTR _targetEnd$[esp+12]

; 122  :         UTF32 ch;
; 123  :         if (target >= targetEnd) {

  00027	3b d5		 cmp	 edx, ebp
  00029	0f 83 9d 00 00
	00		 jae	 $LN18@ConvertUTF

; 124  :             result = targetExhausted; break;
; 125  :         }
; 126  :         ch = *source++;

  0002f	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00031	83 c7 04	 add	 edi, 4

; 127  :         if (ch <= UNI_MAX_BMP) { /* Target is a character <= 0xFFFF */

  00034	81 f9 ff ff 00
	00		 cmp	 ecx, 65535		; 0000ffffH
  0003a	77 19		 ja	 SHORT $LN11@ConvertUTF

; 128  :             /* UTF-16 surrogate values are illegal in UTF-32; 0xffff or 0xfffe are both reserved values */
; 129  :             if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {

  0003c	8d a9 00 28 ff
	ff		 lea	 ebp, DWORD PTR [ecx-55296]
  00042	81 fd ff 07 00
	00		 cmp	 ebp, 2047		; 000007ffH
  00048	77 46		 ja	 SHORT $LN25@ConvertUTF

; 130  :                 if (flags == strictConversion) {

  0004a	85 db		 test	 ebx, ebx
  0004c	74 62		 je	 SHORT $LN19@ConvertUTF
$LN4@ConvertUTF:

; 131  :                     --source; /* return to the illegal value itself */
; 132  :                     result = sourceIllegal;
; 133  :                     break;
; 134  :                 } else {
; 135  :                     *target++ = UNI_REPLACEMENT_CHAR;

  0004e	b9 fd ff 00 00	 mov	 ecx, 65533		; 0000fffdH

; 136  :                 }
; 137  :             } else {

  00053	eb 3b		 jmp	 SHORT $LN25@ConvertUTF
$LN11@ConvertUTF:

; 138  :                 *target++ = (UTF16)ch; /* normal case */
; 139  :             }
; 140  :         } else if (ch > UNI_MAX_LEGAL_UTF32) {

  00055	81 f9 ff ff 10
	00		 cmp	 ecx, 1114111		; 0010ffffH
  0005b	76 09		 jbe	 SHORT $LN5@ConvertUTF

; 141  :             if (flags == strictConversion) {

  0005d	85 db		 test	 ebx, ebx
  0005f	75 ed		 jne	 SHORT $LN4@ConvertUTF

; 142  :                 result = sourceIllegal;

  00061	8d 43 03	 lea	 eax, DWORD PTR [ebx+3]

; 143  :             } else {

  00064	eb 33		 jmp	 SHORT $LN2@ConvertUTF
$LN5@ConvertUTF:

; 144  :                 *target++ = UNI_REPLACEMENT_CHAR;
; 145  :             }
; 146  :         } else {
; 147  :             /* target is a character in range 0xFFFF - 0x10FFFF. */
; 148  :             if (target + 1 >= targetEnd) {

  00066	3b f5		 cmp	 esi, ebp
  00068	73 5f		 jae	 SHORT $LN20@ConvertUTF

; 151  :             }
; 152  :             ch -= halfBase;

  0006a	81 e9 00 00 01
	00		 sub	 ecx, 65536		; 00010000H

; 153  :             *target++ = (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START);

  00070	8b e9		 mov	 ebp, ecx
  00072	c1 ed 0a	 shr	 ebp, 10			; 0000000aH
  00075	81 ed 00 28 00
	00		 sub	 ebp, 10240		; 00002800H
  0007b	66 89 2a	 mov	 WORD PTR [edx], bp

; 154  :             *target++ = (UTF16)((ch & halfMask) + UNI_SUR_LOW_START);

  0007e	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  00084	83 c2 02	 add	 edx, 2
  00087	83 c6 02	 add	 esi, 2
  0008a	81 e9 00 24 00
	00		 sub	 ecx, 9216		; 00002400H
$LN25@ConvertUTF:
  00090	66 89 0a	 mov	 WORD PTR [edx], cx
  00093	83 c2 02	 add	 edx, 2
  00096	83 c6 02	 add	 esi, 2
$LN2@ConvertUTF:

; 121  :     while (source < sourceEnd) {

  00099	3b 7c 24 18	 cmp	 edi, DWORD PTR _sourceEnd$[esp+12]
  0009d	72 84		 jb	 SHORT $LL21@ConvertUTF

; 155  :         }
; 156  :     }
; 157  :     *sourceStart = source;

  0009f	8b 4c 24 14	 mov	 ecx, DWORD PTR _sourceStart$[esp+12]
  000a3	5e		 pop	 esi
  000a4	5d		 pop	 ebp
  000a5	89 39		 mov	 DWORD PTR [ecx], edi

; 158  :     *targetStart = target;

  000a7	8b 4c 24 14	 mov	 ecx, DWORD PTR _targetStart$[esp+4]
  000ab	5b		 pop	 ebx
  000ac	89 11		 mov	 DWORD PTR [ecx], edx
  000ae	5f		 pop	 edi

; 159  :     return result;
; 160  : }

  000af	c3		 ret	 0
$LN19@ConvertUTF:

; 155  :         }
; 156  :     }
; 157  :     *sourceStart = source;

  000b0	8b 4c 24 14	 mov	 ecx, DWORD PTR _sourceStart$[esp+12]
  000b4	5e		 pop	 esi
  000b5	83 ef 04	 sub	 edi, 4
  000b8	5d		 pop	 ebp
  000b9	89 39		 mov	 DWORD PTR [ecx], edi

; 158  :     *targetStart = target;

  000bb	8b 4c 24 14	 mov	 ecx, DWORD PTR _targetStart$[esp+4]
  000bf	5b		 pop	 ebx
  000c0	b8 03 00 00 00	 mov	 eax, 3
  000c5	89 11		 mov	 DWORD PTR [ecx], edx
  000c7	5f		 pop	 edi

; 159  :     return result;
; 160  : }

  000c8	c3		 ret	 0
$LN20@ConvertUTF:

; 149  :                 --source; /* Back up source pointer! */

  000c9	83 ef 04	 sub	 edi, 4
$LN18@ConvertUTF:
  000cc	5e		 pop	 esi
  000cd	5d		 pop	 ebp

; 150  :                 result = targetExhausted; break;

  000ce	b8 02 00 00 00	 mov	 eax, 2
  000d3	5b		 pop	 ebx
$LN13@ConvertUTF:

; 155  :         }
; 156  :     }
; 157  :     *sourceStart = source;

  000d4	8b 4c 24 08	 mov	 ecx, DWORD PTR _sourceStart$[esp]
  000d8	89 39		 mov	 DWORD PTR [ecx], edi

; 158  :     *targetStart = target;

  000da	8b 4c 24 10	 mov	 ecx, DWORD PTR _targetStart$[esp]
  000de	89 11		 mov	 DWORD PTR [ecx], edx
  000e0	5f		 pop	 edi

; 159  :     return result;
; 160  : }

  000e1	c3		 ret	 0
_ConvertUTF32toUTF16 ENDP
_TEXT	ENDS
PUBLIC	_ConvertUTF16toUTF32
; Function compile flags: /Ogtpy
;	COMDAT _ConvertUTF16toUTF32
_TEXT	SEGMENT
_result$ = -4						; size = 4
_sourceStart$ = 8					; size = 4
_sourceEnd$ = 12					; size = 4
_targetStart$ = 16					; size = 4
_targetEnd$ = 20					; size = 4
_flags$ = 24						; size = 4
_ConvertUTF16toUTF32 PROC				; COMDAT

; 166  :         UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags) {

  00000	51		 push	 ecx

; 167  :     ConversionResult result = conversionOK;
; 168  :     const UTF16* source = *sourceStart;

  00001	8b 4c 24 08	 mov	 ecx, DWORD PTR _sourceStart$[esp]
  00005	8b 09		 mov	 ecx, DWORD PTR [ecx]

; 169  :     UTF32* target = *targetStart;

  00007	8b 54 24 10	 mov	 edx, DWORD PTR _targetStart$[esp]
  0000b	53		 push	 ebx

; 170  :     UTF32 ch, ch2;
; 171  :     while (source < sourceEnd) {

  0000c	8b 5c 24 10	 mov	 ebx, DWORD PTR _sourceEnd$[esp+4]
  00010	33 c0		 xor	 eax, eax
  00012	57		 push	 edi
  00013	8b 3a		 mov	 edi, DWORD PTR [edx]
  00015	89 44 24 08	 mov	 DWORD PTR _result$[esp+12], eax
  00019	3b cb		 cmp	 ecx, ebx
  0001b	0f 83 c2 00 00
	00		 jae	 $LN11@ConvertUTF@2
  00021	55		 push	 ebp
  00022	56		 push	 esi
$LL12@ConvertUTF@2:

; 172  :         const UTF16* oldSource = source; /*  In case we have to back up because of target overflow. */
; 173  :         ch = *source++;

  00023	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00026	8b e9		 mov	 ebp, ecx

; 174  :         /* If we have a surrogate pair, convert to UTF32 first. */
; 175  :         if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {

  00028	8d b2 00 28 ff
	ff		 lea	 esi, DWORD PTR [edx-55296]
  0002e	83 c1 02	 add	 ecx, 2
  00031	81 fe ff 03 00
	00		 cmp	 esi, 1023		; 000003ffH
  00037	77 35		 ja	 SHORT $LN10@ConvertUTF@2

; 176  :             /* If the 16 bits following the high surrogate are in the source buffer... */
; 177  :             if (source < sourceEnd) {

  00039	3b cb		 cmp	 ecx, ebx
  0003b	73 69		 jae	 SHORT $LN9@ConvertUTF@2

; 178  :                 ch2 = *source;

  0003d	0f b7 31	 movzx	 esi, WORD PTR [ecx]

; 179  :                 /* If it's a low surrogate, convert to UTF32. */
; 180  :                 if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) {

  00040	8d 86 00 24 ff
	ff		 lea	 eax, DWORD PTR [esi-56320]
  00046	3d ff 03 00 00	 cmp	 eax, 1023		; 000003ffH
  0004b	77 14		 ja	 SHORT $LN8@ConvertUTF@2

; 181  :                     ch = ((ch - UNI_SUR_HIGH_START) << halfShift)
; 182  :                         + (ch2 - UNI_SUR_LOW_START) + halfBase;
; 183  :                     ++source;

  0004d	8b 44 24 10	 mov	 eax, DWORD PTR _result$[esp+20]
  00051	81 c2 09 28 ff
	ff		 add	 edx, -55287		; ffff2809H
  00057	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  0005a	03 d6		 add	 edx, esi
  0005c	83 c1 02	 add	 ecx, 2
  0005f	eb 24		 jmp	 SHORT $LN20@ConvertUTF@2
$LN8@ConvertUTF@2:

; 184  :                 } else if (flags == strictConversion) { /* it's an unpaired high surrogate */

  00061	83 7c 24 28 00	 cmp	 DWORD PTR _flags$[esp+16], 0
  00066	74 58		 je	 SHORT $LN17@ConvertUTF@2

; 185  :                     --source; /* return to the illegal value itself */
; 186  :                     result = sourceIllegal;
; 187  :                     break;
; 188  :                 }
; 189  :             } else { /* We don't have the 16 bits following the high surrogate. */
; 190  :                 --source; /* return to the high surrogate */
; 191  :                 result = sourceExhausted;
; 192  :                 break;
; 193  :             }

  00068	8b 44 24 10	 mov	 eax, DWORD PTR _result$[esp+20]
  0006c	eb 17		 jmp	 SHORT $LN20@ConvertUTF@2
$LN10@ConvertUTF@2:

; 194  :         } else if (flags == strictConversion) {

  0006e	83 7c 24 28 00	 cmp	 DWORD PTR _flags$[esp+16], 0
  00073	75 10		 jne	 SHORT $LN20@ConvertUTF@2

; 195  :             /* UTF-16 surrogate values are illegal in UTF-32 */
; 196  :             if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) {

  00075	81 fa 00 dc 00
	00		 cmp	 edx, 56320		; 0000dc00H
  0007b	72 08		 jb	 SHORT $LN20@ConvertUTF@2
  0007d	81 fa ff df 00
	00		 cmp	 edx, 57343		; 0000dfffH
  00083	76 3b		 jbe	 SHORT $LN17@ConvertUTF@2
$LN20@ConvertUTF@2:

; 197  :                 --source; /* return to the illegal value itself */
; 198  :                 result = sourceIllegal;
; 199  :                 break;
; 200  :             }
; 201  :         }
; 202  :         if (target >= targetEnd) {

  00085	3b 7c 24 24	 cmp	 edi, DWORD PTR _targetEnd$[esp+16]
  00089	73 4f		 jae	 SHORT $LN18@ConvertUTF@2

; 205  :         }
; 206  :         *target++ = ch;

  0008b	89 17		 mov	 DWORD PTR [edi], edx
  0008d	83 c7 04	 add	 edi, 4
  00090	3b cb		 cmp	 ecx, ebx
  00092	72 8f		 jb	 SHORT $LL12@ConvertUTF@2

; 207  :     }
; 208  :     *sourceStart = source;

  00094	8b 54 24 18	 mov	 edx, DWORD PTR _sourceStart$[esp+16]
  00098	5e		 pop	 esi
  00099	89 0a		 mov	 DWORD PTR [edx], ecx

; 209  :     *targetStart = target;

  0009b	8b 4c 24 1c	 mov	 ecx, DWORD PTR _targetStart$[esp+12]
  0009f	5d		 pop	 ebp
  000a0	89 39		 mov	 DWORD PTR [ecx], edi
  000a2	5f		 pop	 edi
  000a3	5b		 pop	 ebx

; 210  :     return result;
; 211  : }

  000a4	59		 pop	 ecx
  000a5	c3		 ret	 0
$LN9@ConvertUTF@2:

; 207  :     }
; 208  :     *sourceStart = source;

  000a6	8b 54 24 18	 mov	 edx, DWORD PTR _sourceStart$[esp+16]
  000aa	83 e9 02	 sub	 ecx, 2
  000ad	5e		 pop	 esi
  000ae	89 0a		 mov	 DWORD PTR [edx], ecx

; 209  :     *targetStart = target;

  000b0	8b 4c 24 1c	 mov	 ecx, DWORD PTR _targetStart$[esp+12]
  000b4	5d		 pop	 ebp
  000b5	89 39		 mov	 DWORD PTR [ecx], edi
  000b7	5f		 pop	 edi
  000b8	b8 01 00 00 00	 mov	 eax, 1
  000bd	5b		 pop	 ebx

; 210  :     return result;
; 211  : }

  000be	59		 pop	 ecx
  000bf	c3		 ret	 0
$LN17@ConvertUTF@2:

; 207  :     }
; 208  :     *sourceStart = source;

  000c0	8b 54 24 18	 mov	 edx, DWORD PTR _sourceStart$[esp+16]
  000c4	83 e9 02	 sub	 ecx, 2
  000c7	5e		 pop	 esi
  000c8	89 0a		 mov	 DWORD PTR [edx], ecx

; 209  :     *targetStart = target;

  000ca	8b 4c 24 1c	 mov	 ecx, DWORD PTR _targetStart$[esp+12]
  000ce	5d		 pop	 ebp
  000cf	89 39		 mov	 DWORD PTR [ecx], edi
  000d1	5f		 pop	 edi
  000d2	b8 03 00 00 00	 mov	 eax, 3
  000d7	5b		 pop	 ebx

; 210  :     return result;
; 211  : }

  000d8	59		 pop	 ecx
  000d9	c3		 ret	 0
$LN18@ConvertUTF@2:
  000da	5e		 pop	 esi

; 203  :             source = oldSource; /* Back up source pointer! */

  000db	8b cd		 mov	 ecx, ebp

; 204  :             result = targetExhausted; break;

  000dd	b8 02 00 00 00	 mov	 eax, 2
  000e2	5d		 pop	 ebp
$LN11@ConvertUTF@2:

; 207  :     }
; 208  :     *sourceStart = source;

  000e3	8b 54 24 10	 mov	 edx, DWORD PTR _sourceStart$[esp+8]
  000e7	89 0a		 mov	 DWORD PTR [edx], ecx

; 209  :     *targetStart = target;

  000e9	8b 4c 24 18	 mov	 ecx, DWORD PTR _targetStart$[esp+8]
  000ed	89 39		 mov	 DWORD PTR [ecx], edi
  000ef	5f		 pop	 edi
  000f0	5b		 pop	 ebx

; 210  :     return result;
; 211  : }

  000f1	59		 pop	 ecx
  000f2	c3		 ret	 0
_ConvertUTF16toUTF32 ENDP
_TEXT	ENDS
PUBLIC	_ConvertUTF16toUTF8
; Function compile flags: /Ogtpy
;	COMDAT _ConvertUTF16toUTF8
_TEXT	SEGMENT
_sourceStart$ = 8					; size = 4
_sourceEnd$ = 12					; size = 4
_targetStart$ = 16					; size = 4
_targetEnd$ = 20					; size = 4
_flags$ = 24						; size = 4
_ConvertUTF16toUTF8 PROC				; COMDAT

; 215  :     ConversionResult result = conversionOK;
; 216  :     const UTF16* source = *sourceStart;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _sourceStart$[esp-4]

; 217  :     UTF8* target = *targetStart;

  00004	8b 54 24 0c	 mov	 edx, DWORD PTR _targetStart$[esp-4]
  00008	8b 12		 mov	 edx, DWORD PTR [edx]
  0000a	57		 push	 edi
  0000b	8b 39		 mov	 edi, DWORD PTR [ecx]
  0000d	33 c0		 xor	 eax, eax

; 218  :     while (source < sourceEnd) {

  0000f	3b 7c 24 0c	 cmp	 edi, DWORD PTR _sourceEnd$[esp]
  00013	0f 83 50 01 00
	00		 jae	 $LN25@ConvertUTF@3
  00019	53		 push	 ebx
  0001a	55		 push	 ebp
  0001b	56		 push	 esi
  0001c	8d 64 24 00	 npad	 4
$LL26@ConvertUTF@3:

; 219  :         UTF32 ch;
; 220  :         unsigned short bytesToWrite = 0;
; 221  :         const UTF32 byteMask = 0xBF;
; 222  :         const UTF32 byteMark = 0x80; 
; 223  :         const UTF16* oldSource = source; /* In case we have to back up because of target overflow. */
; 224  :         ch = *source++;

  00020	0f b7 0f	 movzx	 ecx, WORD PTR [edi]
  00023	8b df		 mov	 ebx, edi

; 225  :         /* If we have a surrogate pair, convert to UTF32 first. */
; 226  :         if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {

  00025	8d b1 00 28 ff
	ff		 lea	 esi, DWORD PTR [ecx-55296]
  0002b	83 c7 02	 add	 edi, 2
  0002e	81 fe ff 03 00
	00		 cmp	 esi, 1023		; 000003ffH
  00034	77 4a		 ja	 SHORT $LN24@ConvertUTF@3

; 227  :             /* If the 16 bits following the high surrogate are in the source buffer... */
; 228  :             if (source < sourceEnd) {

  00036	3b 7c 24 18	 cmp	 edi, DWORD PTR _sourceEnd$[esp+12]
  0003a	0f 83 01 01 00
	00		 jae	 $LN23@ConvertUTF@3

; 229  :                 UTF32 ch2 = *source;

  00040	0f b7 37	 movzx	 esi, WORD PTR [edi]

; 230  :                 /* If it's a low surrogate, convert to UTF32. */
; 231  :                 if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) {

  00043	8d ae 00 24 ff
	ff		 lea	 ebp, DWORD PTR [esi-56320]
  00049	81 fd ff 03 00
	00		 cmp	 ebp, 1023		; 000003ffH
  0004f	77 10		 ja	 SHORT $LN22@ConvertUTF@3

; 232  :                     ch = ((ch - UNI_SUR_HIGH_START) << halfShift)
; 233  :                         + (ch2 - UNI_SUR_LOW_START) + halfBase;

  00051	81 c1 09 28 ff
	ff		 add	 ecx, -55287		; ffff2809H
  00057	c1 e1 0a	 shl	 ecx, 10			; 0000000aH
  0005a	03 ce		 add	 ecx, esi

; 234  :                     ++source;

  0005c	83 c7 02	 add	 edi, 2
  0005f	eb 35		 jmp	 SHORT $LN16@ConvertUTF@3
$LN22@ConvertUTF@3:

; 235  :                 } else if (flags == strictConversion) { /* it's an unpaired high surrogate */

  00061	39 44 24 24	 cmp	 DWORD PTR _flags$[esp+12], eax
  00065	75 2f		 jne	 SHORT $LN16@ConvertUTF@3
$LN31@ConvertUTF@3:

; 274  :     }
; 275  :     *sourceStart = source;

  00067	8b 4c 24 14	 mov	 ecx, DWORD PTR _sourceStart$[esp+12]
  0006b	5e		 pop	 esi
  0006c	83 ef 02	 sub	 edi, 2
  0006f	5d		 pop	 ebp
  00070	89 39		 mov	 DWORD PTR [ecx], edi

; 276  :     *targetStart = target;

  00072	8b 4c 24 14	 mov	 ecx, DWORD PTR _targetStart$[esp+4]
  00076	5b		 pop	 ebx
  00077	b8 03 00 00 00	 mov	 eax, 3
  0007c	89 11		 mov	 DWORD PTR [ecx], edx
  0007e	5f		 pop	 edi

; 277  :     return result;
; 278  : }

  0007f	c3		 ret	 0
$LN24@ConvertUTF@3:

; 236  :                     --source; /* return to the illegal value itself */
; 237  :                     result = sourceIllegal;
; 238  :                     break;
; 239  :                 }
; 240  :             } else { /* We don't have the 16 bits following the high surrogate. */
; 241  :                 --source; /* return to the high surrogate */
; 242  :                 result = sourceExhausted;
; 243  :                 break;
; 244  :             }
; 245  :         } else if (flags == strictConversion) {

  00080	39 44 24 24	 cmp	 DWORD PTR _flags$[esp+12], eax
  00084	75 10		 jne	 SHORT $LN16@ConvertUTF@3

; 246  :             /* UTF-16 surrogate values are illegal in UTF-32 */
; 247  :             if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) {

  00086	81 f9 00 dc 00
	00		 cmp	 ecx, 56320		; 0000dc00H
  0008c	72 08		 jb	 SHORT $LN16@ConvertUTF@3
  0008e	81 f9 ff df 00
	00		 cmp	 ecx, 57343		; 0000dfffH
  00094	76 d1		 jbe	 SHORT $LN31@ConvertUTF@3
$LN16@ConvertUTF@3:

; 248  :                 --source; /* return to the illegal value itself */
; 249  :                 result = sourceIllegal;
; 250  :                 break;
; 251  :             }
; 252  :         }
; 253  :         /* Figure out how many bytes the result will require */
; 254  :         if (ch < (UTF32)0x80) {      bytesToWrite = 1;

  00096	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  0009c	73 07		 jae	 SHORT $LN15@ConvertUTF@3
  0009e	be 01 00 00 00	 mov	 esi, 1
  000a3	eb 30		 jmp	 SHORT $LN8@ConvertUTF@3
$LN15@ConvertUTF@3:

; 255  :         } else if (ch < (UTF32)0x800) {     bytesToWrite = 2;

  000a5	81 f9 00 08 00
	00		 cmp	 ecx, 2048		; 00000800H
  000ab	73 07		 jae	 SHORT $LN13@ConvertUTF@3
  000ad	be 02 00 00 00	 mov	 esi, 2
  000b2	eb 21		 jmp	 SHORT $LN8@ConvertUTF@3
$LN13@ConvertUTF@3:

; 256  :         } else if (ch < (UTF32)0x10000) {   bytesToWrite = 3;

  000b4	81 f9 00 00 01
	00		 cmp	 ecx, 65536		; 00010000H
  000ba	72 14		 jb	 SHORT $LN42@ConvertUTF@3

; 257  :         } else if (ch < (UTF32)0x110000) {  bytesToWrite = 4;

  000bc	81 f9 00 00 11
	00		 cmp	 ecx, 1114112		; 00110000H
  000c2	73 07		 jae	 SHORT $LN9@ConvertUTF@3
  000c4	be 04 00 00 00	 mov	 esi, 4
  000c9	eb 0a		 jmp	 SHORT $LN8@ConvertUTF@3
$LN9@ConvertUTF@3:

; 259  :                                             ch = UNI_REPLACEMENT_CHAR;

  000cb	b9 fd ff 00 00	 mov	 ecx, 65533		; 0000fffdH
$LN42@ConvertUTF@3:

; 258  :         } else {                            bytesToWrite = 3;

  000d0	be 03 00 00 00	 mov	 esi, 3
$LN8@ConvertUTF@3:

; 260  :         }
; 261  : 
; 262  :         target += bytesToWrite;

  000d5	0f b7 ee	 movzx	 ebp, si
  000d8	03 d5		 add	 edx, ebp

; 263  :         if (target > targetEnd) {

  000da	3b 54 24 20	 cmp	 edx, DWORD PTR _targetEnd$[esp+12]
  000de	77 7a		 ja	 SHORT $LN32@ConvertUTF@3

; 266  :         }
; 267  :         switch (bytesToWrite) { /* note: everything falls through. */

  000e0	8d 75 ff	 lea	 esi, DWORD PTR [ebp-1]
  000e3	83 fe 03	 cmp	 esi, 3
  000e6	77 3c		 ja	 SHORT $LN38@ConvertUTF@3
  000e8	ff 24 b5 00 00
	00 00		 jmp	 DWORD PTR $LN43@ConvertUTF@3[esi*4]
$LN4@ConvertUTF@3:

; 268  :             case 4: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

  000ef	8a d9		 mov	 bl, cl
  000f1	80 e3 3f	 and	 bl, 63			; 0000003fH
  000f4	4a		 dec	 edx
  000f5	80 cb 80	 or	 bl, 128			; 00000080H
  000f8	88 1a		 mov	 BYTE PTR [edx], bl
  000fa	c1 e9 06	 shr	 ecx, 6
$LN35@ConvertUTF@3:

; 269  :             case 3: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

  000fd	8a d9		 mov	 bl, cl
  000ff	80 e3 3f	 and	 bl, 63			; 0000003fH
  00102	4a		 dec	 edx
  00103	80 cb 80	 or	 bl, 128			; 00000080H
  00106	88 1a		 mov	 BYTE PTR [edx], bl
  00108	c1 e9 06	 shr	 ecx, 6
$LN36@ConvertUTF@3:

; 270  :             case 2: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

  0010b	8a d9		 mov	 bl, cl
  0010d	80 e3 3f	 and	 bl, 63			; 0000003fH
  00110	4a		 dec	 edx
  00111	80 cb 80	 or	 bl, 128			; 00000080H
  00114	88 1a		 mov	 BYTE PTR [edx], bl
  00116	c1 e9 06	 shr	 ecx, 6
$LN37@ConvertUTF@3:

; 271  :             case 1: *--target =  (UTF8)(ch | firstByteMark[bytesToWrite]);

  00119	8a 9d 00 00 00
	00		 mov	 bl, BYTE PTR _firstByteMark[ebp]
  0011f	4a		 dec	 edx
  00120	0a d9		 or	 bl, cl
  00122	88 1a		 mov	 BYTE PTR [edx], bl
$LN38@ConvertUTF@3:

; 272  :         }
; 273  :         target += bytesToWrite;

  00124	03 d5		 add	 edx, ebp
  00126	3b 7c 24 18	 cmp	 edi, DWORD PTR _sourceEnd$[esp+12]
  0012a	0f 82 f0 fe ff
	ff		 jb	 $LL26@ConvertUTF@3

; 274  :     }
; 275  :     *sourceStart = source;

  00130	8b 4c 24 14	 mov	 ecx, DWORD PTR _sourceStart$[esp+12]
  00134	5e		 pop	 esi
  00135	5d		 pop	 ebp
  00136	89 39		 mov	 DWORD PTR [ecx], edi

; 276  :     *targetStart = target;

  00138	8b 4c 24 14	 mov	 ecx, DWORD PTR _targetStart$[esp+4]
  0013c	5b		 pop	 ebx
  0013d	89 11		 mov	 DWORD PTR [ecx], edx
  0013f	5f		 pop	 edi

; 277  :     return result;
; 278  : }

  00140	c3		 ret	 0
$LN23@ConvertUTF@3:

; 274  :     }
; 275  :     *sourceStart = source;

  00141	8b 4c 24 14	 mov	 ecx, DWORD PTR _sourceStart$[esp+12]
  00145	5e		 pop	 esi
  00146	83 ef 02	 sub	 edi, 2
  00149	5d		 pop	 ebp
  0014a	89 39		 mov	 DWORD PTR [ecx], edi

; 276  :     *targetStart = target;

  0014c	8b 4c 24 14	 mov	 ecx, DWORD PTR _targetStart$[esp+4]
  00150	5b		 pop	 ebx
  00151	b8 01 00 00 00	 mov	 eax, 1
  00156	89 11		 mov	 DWORD PTR [ecx], edx
  00158	5f		 pop	 edi

; 277  :     return result;
; 278  : }

  00159	c3		 ret	 0
$LN32@ConvertUTF@3:

; 264  :             source = oldSource; /* Back up source pointer! */
; 265  :             target -= bytesToWrite; result = targetExhausted; break;

  0015a	0f b7 c6	 movzx	 eax, si
  0015d	5e		 pop	 esi
  0015e	5d		 pop	 ebp
  0015f	8b fb		 mov	 edi, ebx
  00161	2b d0		 sub	 edx, eax
  00163	b8 02 00 00 00	 mov	 eax, 2
  00168	5b		 pop	 ebx
$LN25@ConvertUTF@3:

; 274  :     }
; 275  :     *sourceStart = source;

  00169	8b 4c 24 08	 mov	 ecx, DWORD PTR _sourceStart$[esp]
  0016d	89 39		 mov	 DWORD PTR [ecx], edi

; 276  :     *targetStart = target;

  0016f	8b 4c 24 10	 mov	 ecx, DWORD PTR _targetStart$[esp]
  00173	89 11		 mov	 DWORD PTR [ecx], edx
  00175	5f		 pop	 edi

; 277  :     return result;
; 278  : }

  00176	c3		 ret	 0
  00177	90		 npad	 1
$LN43@ConvertUTF@3:
  00178	00 00 00 00	 DD	 $LN37@ConvertUTF@3
  0017c	00 00 00 00	 DD	 $LN36@ConvertUTF@3
  00180	00 00 00 00	 DD	 $LN35@ConvertUTF@3
  00184	00 00 00 00	 DD	 $LN4@ConvertUTF@3
_ConvertUTF16toUTF8 ENDP
_TEXT	ENDS
PUBLIC	_ConvertUTF32toUTF8
; Function compile flags: /Ogtpy
;	COMDAT _ConvertUTF32toUTF8
_TEXT	SEGMENT
_sourceStart$ = 8					; size = 4
_sourceEnd$ = 12					; size = 4
_targetStart$ = 16					; size = 4
_targetEnd$ = 20					; size = 4
_flags$ = 24						; size = 4
_ConvertUTF32toUTF8 PROC				; COMDAT

; 285  :     ConversionResult result = conversionOK;
; 286  :     const UTF32* source = *sourceStart;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _sourceStart$[esp-4]

; 287  :     UTF8* target = *targetStart;

  00004	8b 54 24 0c	 mov	 edx, DWORD PTR _targetStart$[esp-4]
  00008	8b 12		 mov	 edx, DWORD PTR [edx]
  0000a	55		 push	 ebp
  0000b	8b 29		 mov	 ebp, DWORD PTR [ecx]
  0000d	33 c0		 xor	 eax, eax

; 288  :     while (source < sourceEnd) {

  0000f	3b 6c 24 0c	 cmp	 ebp, DWORD PTR _sourceEnd$[esp]
  00013	0f 83 05 01 00
	00		 jae	 $LN18@ConvertUTF@4
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	8d 64 24 00	 npad	 4
$LL19@ConvertUTF@4:

; 289  :         UTF32 ch;
; 290  :         unsigned short bytesToWrite = 0;
; 291  :         const UTF32 byteMask = 0xBF;
; 292  :         const UTF32 byteMark = 0x80; 
; 293  :         ch = *source++;

  00020	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  00023	83 c5 04	 add	 ebp, 4

; 294  :         if (flags == strictConversion ) {

  00026	83 7c 24 24 00	 cmp	 DWORD PTR _flags$[esp+12], 0
  0002b	75 14		 jne	 SHORT $LN16@ConvertUTF@4

; 295  :             /* UTF-16 surrogate values are illegal in UTF-32 */
; 296  :             if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {

  0002d	81 f9 00 d8 00
	00		 cmp	 ecx, 55296		; 0000d800H
  00033	72 0c		 jb	 SHORT $LN16@ConvertUTF@4
  00035	81 f9 ff df 00
	00		 cmp	 ecx, 57343		; 0000dfffH
  0003b	0f 86 b4 00 00
	00		 jbe	 $LN23@ConvertUTF@4
$LN16@ConvertUTF@4:

; 297  :                 --source; /* return to the illegal value itself */
; 298  :                 result = sourceIllegal;
; 299  :                 break;
; 300  :             }
; 301  :         }
; 302  :         /*
; 303  :          * Figure out how many bytes the result will require. Turn any
; 304  :          * illegally large UTF32 things (> Plane 17) into replacement chars.
; 305  :          */
; 306  :         if (ch < (UTF32)0x80) {      bytesToWrite = 1;

  00041	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  00047	73 07		 jae	 SHORT $LN15@ConvertUTF@4
  00049	be 01 00 00 00	 mov	 esi, 1
  0004e	eb 39		 jmp	 SHORT $LN8@ConvertUTF@4
$LN15@ConvertUTF@4:

; 307  :         } else if (ch < (UTF32)0x800) {     bytesToWrite = 2;

  00050	81 f9 00 08 00
	00		 cmp	 ecx, 2048		; 00000800H
  00056	73 07		 jae	 SHORT $LN13@ConvertUTF@4
  00058	be 02 00 00 00	 mov	 esi, 2
  0005d	eb 2a		 jmp	 SHORT $LN8@ConvertUTF@4
$LN13@ConvertUTF@4:

; 308  :         } else if (ch < (UTF32)0x10000) {   bytesToWrite = 3;

  0005f	81 f9 00 00 01
	00		 cmp	 ecx, 65536		; 00010000H
  00065	73 07		 jae	 SHORT $LN11@ConvertUTF@4
  00067	be 03 00 00 00	 mov	 esi, 3
  0006c	eb 1b		 jmp	 SHORT $LN8@ConvertUTF@4
$LN11@ConvertUTF@4:

; 309  :         } else if (ch <= UNI_MAX_LEGAL_UTF32) {  bytesToWrite = 4;

  0006e	81 f9 ff ff 10
	00		 cmp	 ecx, 1114111		; 0010ffffH
  00074	77 07		 ja	 SHORT $LN9@ConvertUTF@4
  00076	be 04 00 00 00	 mov	 esi, 4
  0007b	eb 0c		 jmp	 SHORT $LN8@ConvertUTF@4
$LN9@ConvertUTF@4:

; 310  :         } else {                            bytesToWrite = 3;

  0007d	be 03 00 00 00	 mov	 esi, 3

; 311  :                                             ch = UNI_REPLACEMENT_CHAR;

  00082	b9 fd ff 00 00	 mov	 ecx, 65533		; 0000fffdH

; 312  :                                             result = sourceIllegal;

  00087	8b c6		 mov	 eax, esi
$LN8@ConvertUTF@4:

; 313  :         }
; 314  :         
; 315  :         target += bytesToWrite;

  00089	0f b7 fe	 movzx	 edi, si
  0008c	03 d7		 add	 edx, edi

; 316  :         if (target > targetEnd) {

  0008e	3b 54 24 20	 cmp	 edx, DWORD PTR _targetEnd$[esp+12]
  00092	77 7a		 ja	 SHORT $LN24@ConvertUTF@4

; 319  :         }
; 320  :         switch (bytesToWrite) { /* note: everything falls through. */

  00094	8d 77 ff	 lea	 esi, DWORD PTR [edi-1]
  00097	83 fe 03	 cmp	 esi, 3
  0009a	77 3c		 ja	 SHORT $LN5@ConvertUTF@4
  0009c	ff 24 b5 00 00
	00 00		 jmp	 DWORD PTR $LN30@ConvertUTF@4[esi*4]
$LN4@ConvertUTF@4:

; 321  :             case 4: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

  000a3	8a d9		 mov	 bl, cl
  000a5	80 e3 3f	 and	 bl, 63			; 0000003fH
  000a8	4a		 dec	 edx
  000a9	80 cb 80	 or	 bl, 128			; 00000080H
  000ac	88 1a		 mov	 BYTE PTR [edx], bl
  000ae	c1 e9 06	 shr	 ecx, 6
$LN3@ConvertUTF@4:

; 322  :             case 3: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

  000b1	8a d9		 mov	 bl, cl
  000b3	80 e3 3f	 and	 bl, 63			; 0000003fH
  000b6	4a		 dec	 edx
  000b7	80 cb 80	 or	 bl, 128			; 00000080H
  000ba	88 1a		 mov	 BYTE PTR [edx], bl
  000bc	c1 e9 06	 shr	 ecx, 6
$LN2@ConvertUTF@4:

; 323  :             case 2: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

  000bf	8a d9		 mov	 bl, cl
  000c1	80 e3 3f	 and	 bl, 63			; 0000003fH
  000c4	4a		 dec	 edx
  000c5	80 cb 80	 or	 bl, 128			; 00000080H
  000c8	88 1a		 mov	 BYTE PTR [edx], bl
  000ca	c1 e9 06	 shr	 ecx, 6
$LN1@ConvertUTF@4:

; 324  :             case 1: *--target = (UTF8) (ch | firstByteMark[bytesToWrite]);

  000cd	8a 9f 00 00 00
	00		 mov	 bl, BYTE PTR _firstByteMark[edi]
  000d3	4a		 dec	 edx
  000d4	0a d9		 or	 bl, cl
  000d6	88 1a		 mov	 BYTE PTR [edx], bl
$LN5@ConvertUTF@4:

; 325  :         }
; 326  :         target += bytesToWrite;

  000d8	03 d7		 add	 edx, edi
  000da	3b 6c 24 18	 cmp	 ebp, DWORD PTR _sourceEnd$[esp+12]
  000de	0f 82 3c ff ff
	ff		 jb	 $LL19@ConvertUTF@4

; 327  :     }
; 328  :     *sourceStart = source;

  000e4	8b 4c 24 14	 mov	 ecx, DWORD PTR _sourceStart$[esp+12]
  000e8	5f		 pop	 edi
  000e9	5e		 pop	 esi
  000ea	89 29		 mov	 DWORD PTR [ecx], ebp

; 329  :     *targetStart = target;

  000ec	8b 4c 24 14	 mov	 ecx, DWORD PTR _targetStart$[esp+4]
  000f0	5b		 pop	 ebx
  000f1	89 11		 mov	 DWORD PTR [ecx], edx
  000f3	5d		 pop	 ebp

; 330  :     return result;
; 331  : }

  000f4	c3		 ret	 0
$LN23@ConvertUTF@4:

; 327  :     }
; 328  :     *sourceStart = source;

  000f5	8b 4c 24 14	 mov	 ecx, DWORD PTR _sourceStart$[esp+12]
  000f9	5f		 pop	 edi
  000fa	83 ed 04	 sub	 ebp, 4
  000fd	5e		 pop	 esi
  000fe	89 29		 mov	 DWORD PTR [ecx], ebp

; 329  :     *targetStart = target;

  00100	8b 4c 24 14	 mov	 ecx, DWORD PTR _targetStart$[esp+4]
  00104	5b		 pop	 ebx
  00105	b8 03 00 00 00	 mov	 eax, 3
  0010a	89 11		 mov	 DWORD PTR [ecx], edx
  0010c	5d		 pop	 ebp

; 330  :     return result;
; 331  : }

  0010d	c3		 ret	 0
$LN24@ConvertUTF@4:

; 317  :             --source; /* Back up source pointer! */
; 318  :             target -= bytesToWrite; result = targetExhausted; break;

  0010e	0f b7 c6	 movzx	 eax, si
  00111	5f		 pop	 edi
  00112	83 ed 04	 sub	 ebp, 4
  00115	5e		 pop	 esi
  00116	2b d0		 sub	 edx, eax
  00118	b8 02 00 00 00	 mov	 eax, 2
  0011d	5b		 pop	 ebx
$LN18@ConvertUTF@4:

; 327  :     }
; 328  :     *sourceStart = source;

  0011e	8b 4c 24 08	 mov	 ecx, DWORD PTR _sourceStart$[esp]
  00122	89 29		 mov	 DWORD PTR [ecx], ebp

; 329  :     *targetStart = target;

  00124	8b 4c 24 10	 mov	 ecx, DWORD PTR _targetStart$[esp]
  00128	89 11		 mov	 DWORD PTR [ecx], edx
  0012a	5d		 pop	 ebp

; 330  :     return result;
; 331  : }

  0012b	c3		 ret	 0
$LN30@ConvertUTF@4:
  0012c	00 00 00 00	 DD	 $LN1@ConvertUTF@4
  00130	00 00 00 00	 DD	 $LN2@ConvertUTF@4
  00134	00 00 00 00	 DD	 $LN3@ConvertUTF@4
  00138	00 00 00 00	 DD	 $LN4@ConvertUTF@4
_ConvertUTF32toUTF8 ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _isLegalUTF8
_TEXT	SEGMENT
_isLegalUTF8 PROC					; COMDAT
; _source$ = edx
; _length$ = ecx

; 347  :     UTF8 a;
; 348  :     const UTF8 *srcptr = source+length;

  00000	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 349  :     switch (length) {

  00003	49		 dec	 ecx
  00004	83 f9 03	 cmp	 ecx, 3
  00007	77 50		 ja	 SHORT $LN25@isLegalUTF
  00009	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN32@isLegalUTF[ecx*4]
$LN24@isLegalUTF:

; 351  :         /* Everything else falls through when "true"... */
; 352  :     case 4: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;

  00010	8a 48 ff	 mov	 cl, BYTE PTR [eax-1]
  00013	48		 dec	 eax
  00014	80 f9 80	 cmp	 cl, 128			; 00000080H
  00017	72 40		 jb	 SHORT $LN25@isLegalUTF
  00019	80 f9 bf	 cmp	 cl, 191			; 000000bfH
  0001c	77 3b		 ja	 SHORT $LN25@isLegalUTF
$LN23@isLegalUTF:

; 353  :     case 3: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;

  0001e	8a 48 ff	 mov	 cl, BYTE PTR [eax-1]
  00021	48		 dec	 eax
  00022	80 f9 80	 cmp	 cl, 128			; 00000080H
  00025	72 32		 jb	 SHORT $LN25@isLegalUTF
  00027	80 f9 bf	 cmp	 cl, 191			; 000000bfH
  0002a	77 2d		 ja	 SHORT $LN25@isLegalUTF
$LN20@isLegalUTF:

; 354  :     case 2: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;

  0002c	8a 40 ff	 mov	 al, BYTE PTR [eax-1]
  0002f	8a c8		 mov	 cl, al
  00031	80 e9 80	 sub	 cl, -128		; ffffff80H
  00034	80 f9 3f	 cmp	 cl, 63			; 0000003fH
  00037	77 20		 ja	 SHORT $LN25@isLegalUTF

; 355  : 
; 356  :         switch (*source) {

  00039	0f b6 0a	 movzx	 ecx, BYTE PTR [edx]
  0003c	81 c1 20 ff ff
	ff		 add	 ecx, -224		; ffffff20H
  00042	83 f9 14	 cmp	 ecx, 20			; 00000014H
  00045	77 24		 ja	 SHORT $LN4@isLegalUTF
  00047	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN30@isLegalUTF[ecx]
  0004e	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN33@isLegalUTF[ecx*4]
$LN13@isLegalUTF:

; 357  :             /* no fall-through in this inner switch */
; 358  :             case 0xE0: if (a < 0xA0) return false; break;

  00055	3c a0		 cmp	 al, 160			; 000000a0H
$LN31@isLegalUTF:

; 360  :             case 0xF0: if (a < 0x90) return false; break;

  00057	73 12		 jae	 SHORT $LN4@isLegalUTF
$LN25@isLegalUTF:

; 350  :     default: return false;

  00059	33 c0		 xor	 eax, eax

; 368  :     return true;
; 369  : }

  0005b	c3		 ret	 0
$LN11@isLegalUTF:

; 359  :             case 0xED: if (a > 0x9F) return false; break;

  0005c	3c 9f		 cmp	 al, 159			; 0000009fH
  0005e	76 0b		 jbe	 SHORT $LN4@isLegalUTF

; 350  :     default: return false;

  00060	33 c0		 xor	 eax, eax

; 368  :     return true;
; 369  : }

  00062	c3		 ret	 0
$LN9@isLegalUTF:

; 360  :             case 0xF0: if (a < 0x90) return false; break;

  00063	3c 90		 cmp	 al, 144			; 00000090H
  00065	eb f0		 jmp	 SHORT $LN31@isLegalUTF
$LN7@isLegalUTF:

; 361  :             case 0xF4: if (a > 0x8F) return false; break;

  00067	3c 8f		 cmp	 al, 143			; 0000008fH
  00069	77 ee		 ja	 SHORT $LN25@isLegalUTF
$LN4@isLegalUTF:

; 362  :             default:   if (a < 0x80) return false;
; 363  :         }
; 364  : 
; 365  :     case 1: if (*source >= 0x80 && *source < 0xC2) return false;

  0006b	8a 02		 mov	 al, BYTE PTR [edx]
  0006d	3c 80		 cmp	 al, 128			; 00000080H
  0006f	72 04		 jb	 SHORT $LN2@isLegalUTF
  00071	3c c2		 cmp	 al, 194			; 000000c2H
  00073	72 e4		 jb	 SHORT $LN25@isLegalUTF
$LN2@isLegalUTF:

; 366  :     }
; 367  :     if (*source > 0xF4) return false;

  00075	b2 f4		 mov	 dl, 244			; 000000f4H
  00077	3a d0		 cmp	 dl, al
  00079	1b c0		 sbb	 eax, eax
  0007b	40		 inc	 eax

; 368  :     return true;
; 369  : }

  0007c	c3		 ret	 0
  0007d	8d 49 00	 npad	 3
$LN32@isLegalUTF:
  00080	00 00 00 00	 DD	 $LN4@isLegalUTF
  00084	00 00 00 00	 DD	 $LN20@isLegalUTF
  00088	00 00 00 00	 DD	 $LN23@isLegalUTF
  0008c	00 00 00 00	 DD	 $LN24@isLegalUTF
$LN33@isLegalUTF:
  00090	00 00 00 00	 DD	 $LN13@isLegalUTF
  00094	00 00 00 00	 DD	 $LN11@isLegalUTF
  00098	00 00 00 00	 DD	 $LN9@isLegalUTF
  0009c	00 00 00 00	 DD	 $LN7@isLegalUTF
  000a0	00 00 00 00	 DD	 $LN4@isLegalUTF
$LN30@isLegalUTF:
  000a4	00		 DB	 0
  000a5	04		 DB	 4
  000a6	04		 DB	 4
  000a7	04		 DB	 4
  000a8	04		 DB	 4
  000a9	04		 DB	 4
  000aa	04		 DB	 4
  000ab	04		 DB	 4
  000ac	04		 DB	 4
  000ad	04		 DB	 4
  000ae	04		 DB	 4
  000af	04		 DB	 4
  000b0	04		 DB	 4
  000b1	01		 DB	 1
  000b2	04		 DB	 4
  000b3	04		 DB	 4
  000b4	02		 DB	 2
  000b5	04		 DB	 4
  000b6	04		 DB	 4
  000b7	04		 DB	 4
  000b8	03		 DB	 3
_isLegalUTF8 ENDP
_TEXT	ENDS
PUBLIC	_isLegalUTF8Sequence
; Function compile flags: /Ogtpy
;	COMDAT _isLegalUTF8Sequence
_TEXT	SEGMENT
_source$ = 8						; size = 4
_sourceEnd$ = 12					; size = 4
_isLegalUTF8Sequence PROC				; COMDAT

; 378  :     int length = trailingBytesForUTF8[*source]+1;

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _source$[esp-4]
  00004	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00007	0f be 88 00 00
	00 00		 movsx	 ecx, BYTE PTR _trailingBytesForUTF8[eax]

; 379  :     if (length > sourceEnd - source) {

  0000e	8b 44 24 08	 mov	 eax, DWORD PTR _sourceEnd$[esp-4]
  00012	41		 inc	 ecx
  00013	2b c2		 sub	 eax, edx
  00015	3b c8		 cmp	 ecx, eax
  00017	7e 03		 jle	 SHORT $LN1@isLegalUTF@2

; 380  :         return false;

  00019	33 c0		 xor	 eax, eax

; 383  : }

  0001b	c3		 ret	 0
$LN1@isLegalUTF@2:

; 381  :     }
; 382  :     return isLegalUTF8(source, length);

  0001c	e9 00 00 00 00	 jmp	 _isLegalUTF8
_isLegalUTF8Sequence ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _findMaximalSubpartOfIllFormedUTF8Sequence
_TEXT	SEGMENT
_findMaximalSubpartOfIllFormedUTF8Sequence PROC		; COMDAT
; _source$ = ecx
; _sourceEnd$ = esi

; 390  :   UTF8 b1, b2, b3;
; 391  : 
; 392  :   assert(!isLegalUTF8Sequence(source, sourceEnd));
; 393  : 
; 394  :   /*
; 395  :    * Unicode 6.3.0, D93b:
; 396  :    *
; 397  :    *   Maximal subpart of an ill-formed subsequence: The longest code unit
; 398  :    *   subsequence starting at an unconvertible offset that is either:
; 399  :    *   a. the initial subsequence of a well-formed code unit sequence, or
; 400  :    *   b. a subsequence of length one.
; 401  :    */
; 402  : 
; 403  :   if (source == sourceEnd)

  00000	3b ce		 cmp	 ecx, esi
  00002	75 03		 jne	 SHORT $LN16@findMaxima

; 404  :     return 0;

  00004	33 c0		 xor	 eax, eax

; 476  : }

  00006	c3		 ret	 0
$LN16@findMaxima:

; 405  : 
; 406  :   /*
; 407  :    * Perform case analysis.  See Unicode 6.3.0, Table 3-7. Well-Formed UTF-8
; 408  :    * Byte Sequences.
; 409  :    */
; 410  : 
; 411  :   b1 = *source;

  00007	8a 11		 mov	 dl, BYTE PTR [ecx]

; 412  :   ++source;
; 413  :   if (b1 >= 0xC2 && b1 <= 0xDF) {

  00009	8a c2		 mov	 al, dl
  0000b	04 3e		 add	 al, 62			; 0000003eH
  0000d	41		 inc	 ecx
  0000e	3c 1d		 cmp	 al, 29			; 0000001dH
  00010	77 06		 ja	 SHORT $LN15@findMaxima
$LN38@findMaxima:

; 414  :     /*
; 415  :      * First byte is valid, but we know that this code unit sequence is
; 416  :      * invalid, so the maximal subpart has to end after the first byte.
; 417  :      */
; 418  :     return 1;

  00012	b8 01 00 00 00	 mov	 eax, 1

; 476  : }

  00017	c3		 ret	 0
$LN15@findMaxima:

; 419  :   }
; 420  : 
; 421  :   if (source == sourceEnd)

  00018	3b ce		 cmp	 ecx, esi

; 422  :     return 1;

  0001a	74 f6		 je	 SHORT $LN38@findMaxima

; 423  : 
; 424  :   b2 = *source;

  0001c	0f b6 01	 movzx	 eax, BYTE PTR [ecx]

; 425  :   ++source;

  0001f	41		 inc	 ecx

; 426  : 
; 427  :   if (b1 == 0xE0) {

  00020	80 fa e0	 cmp	 dl, 224			; 000000e0H
  00023	75 0c		 jne	 SHORT $LN13@findMaxima

; 428  :     return (b2 >= 0xA0 && b2 <= 0xBF) ? 2 : 1;

  00025	04 60		 add	 al, 96			; 00000060H
  00027	b1 1f		 mov	 cl, 31			; 0000001fH
  00029	3a c8		 cmp	 cl, al
  0002b	1b c0		 sbb	 eax, eax
  0002d	83 c0 02	 add	 eax, 2

; 476  : }

  00030	c3		 ret	 0
$LN13@findMaxima:
  00031	53		 push	 ebx

; 429  :   }
; 430  :   if (b1 >= 0xE1 && b1 <= 0xEC) {

  00032	8a da		 mov	 bl, dl
  00034	80 c3 1f	 add	 bl, 31			; 0000001fH
  00037	80 fb 0b	 cmp	 bl, 11			; 0000000bH

; 431  :     return (b2 >= 0x80 && b2 <= 0xBF) ? 2 : 1;

  0003a	76 1c		 jbe	 SHORT $LN37@findMaxima

; 432  :   }
; 433  :   if (b1 == 0xED) {

  0003c	80 fa ed	 cmp	 dl, 237			; 000000edH
  0003f	75 0d		 jne	 SHORT $LN11@findMaxima

; 434  :     return (b2 >= 0x80 && b2 <= 0x9F) ? 2 : 1;

  00041	2c 80		 sub	 al, -128		; ffffff80H
  00043	b1 1f		 mov	 cl, 31			; 0000001fH
  00045	3a c8		 cmp	 cl, al
  00047	5b		 pop	 ebx
  00048	1b c0		 sbb	 eax, eax
  0004a	83 c0 02	 add	 eax, 2

; 476  : }

  0004d	c3		 ret	 0
$LN11@findMaxima:

; 435  :   }
; 436  :   if (b1 >= 0xEE && b1 <= 0xEF) {

  0004e	8a da		 mov	 bl, dl
  00050	80 c3 12	 add	 bl, 18			; 00000012H
  00053	80 fb 01	 cmp	 bl, 1
  00056	77 0d		 ja	 SHORT $LN10@findMaxima
$LN37@findMaxima:

; 437  :     return (b2 >= 0x80 && b2 <= 0xBF) ? 2 : 1;

  00058	2c 80		 sub	 al, -128		; ffffff80H
  0005a	b2 3f		 mov	 dl, 63			; 0000003fH
  0005c	3a d0		 cmp	 dl, al
  0005e	5b		 pop	 ebx
  0005f	1b c0		 sbb	 eax, eax
  00061	83 c0 02	 add	 eax, 2

; 476  : }

  00064	c3		 ret	 0
$LN10@findMaxima:

; 438  :   }
; 439  :   if (b1 == 0xF0) {

  00065	80 fa f0	 cmp	 dl, 240			; 000000f0H
  00068	75 06		 jne	 SHORT $LN9@findMaxima

; 440  :     if (b2 >= 0x90 && b2 <= 0xBF) {

  0006a	04 70		 add	 al, 112			; 00000070H
  0006c	3c 2f		 cmp	 al, 47			; 0000002fH

; 441  :       if (source == sourceEnd)
; 442  :         return 2;

  0006e	eb 2d		 jmp	 SHORT $LN36@findMaxima
$LN9@findMaxima:

; 443  : 
; 444  :       b3 = *source;
; 445  :       return (b3 >= 0x80 && b3 <= 0xBF) ? 3 : 2;
; 446  :     }
; 447  :     return 1;
; 448  :   }
; 449  :   if (b1 >= 0xF1 && b1 <= 0xF3) {

  00070	8a da		 mov	 bl, dl
  00072	80 c3 0f	 add	 bl, 15			; 0000000fH
  00075	80 fb 02	 cmp	 bl, 2
  00078	77 1a		 ja	 SHORT $LN6@findMaxima

; 450  :     if (b2 >= 0x80 && b2 <= 0xBF) {

  0007a	2c 80		 sub	 al, -128		; ffffff80H
  0007c	3c 3f		 cmp	 al, 63			; 0000003fH
  0007e	77 3d		 ja	 SHORT $LN3@findMaxima

; 451  :       if (source == sourceEnd)

  00080	3b ce		 cmp	 ecx, esi

; 452  :         return 2;

  00082	74 1f		 je	 SHORT $LN35@findMaxima

; 453  : 
; 454  :       b3 = *source;

  00084	8a 09		 mov	 cl, BYTE PTR [ecx]

; 455  :       return (b3 >= 0x80 && b3 <= 0xBF) ? 3 : 2;

  00086	80 e9 80	 sub	 cl, -128		; ffffff80H
  00089	b2 3f		 mov	 dl, 63			; 0000003fH
  0008b	3a d1		 cmp	 dl, cl
  0008d	1b c0		 sbb	 eax, eax
  0008f	83 c0 03	 add	 eax, 3
  00092	5b		 pop	 ebx

; 476  : }

  00093	c3		 ret	 0
$LN6@findMaxima:

; 456  :     }
; 457  :     return 1;
; 458  :   }
; 459  :   if (b1 == 0xF4) {

  00094	80 fa f4	 cmp	 dl, 244			; 000000f4H
  00097	75 24		 jne	 SHORT $LN3@findMaxima

; 460  :     if (b2 >= 0x80 && b2 <= 0x8F) {

  00099	2c 80		 sub	 al, -128		; ffffff80H
  0009b	3c 0f		 cmp	 al, 15			; 0000000fH
$LN36@findMaxima:
  0009d	77 1e		 ja	 SHORT $LN3@findMaxima

; 461  :       if (source == sourceEnd)

  0009f	3b ce		 cmp	 ecx, esi
  000a1	75 07		 jne	 SHORT $LN1@findMaxima
$LN35@findMaxima:

; 462  :         return 2;

  000a3	b8 02 00 00 00	 mov	 eax, 2
  000a8	5b		 pop	 ebx

; 476  : }

  000a9	c3		 ret	 0
$LN1@findMaxima:

; 463  : 
; 464  :       b3 = *source;

  000aa	8a 09		 mov	 cl, BYTE PTR [ecx]

; 465  :       return (b3 >= 0x80 && b3 <= 0xBF) ? 3 : 2;

  000ac	80 e9 80	 sub	 cl, -128		; ffffff80H
  000af	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  000b4	3a c1		 cmp	 al, cl
  000b6	1b c0		 sbb	 eax, eax
  000b8	83 c0 03	 add	 eax, 3
  000bb	5b		 pop	 ebx

; 476  : }

  000bc	c3		 ret	 0
$LN3@findMaxima:

; 466  :     }
; 467  :     return 1;
; 468  :   }
; 469  : 
; 470  :   assert((b1 >= 0x80 && b1 <= 0xC1) || b1 >= 0xF5);
; 471  :   /*
; 472  :    * There are no valid sequences that start with these bytes.  Maximal subpart
; 473  :    * is defined to have length 1 in these cases.
; 474  :    */
; 475  :   return 1;

  000bd	b8 01 00 00 00	 mov	 eax, 1
  000c2	5b		 pop	 ebx

; 476  : }

  000c3	c3		 ret	 0
_findMaximalSubpartOfIllFormedUTF8Sequence ENDP
_TEXT	ENDS
PUBLIC	_getNumBytesForUTF8
; Function compile flags: /Ogtpy
;	COMDAT _getNumBytesForUTF8
_TEXT	SEGMENT
_first$ = 8						; size = 1
_getNumBytesForUTF8 PROC				; COMDAT

; 485  :   return trailingBytesForUTF8[first] + 1;

  00000	0f b6 44 24 04	 movzx	 eax, BYTE PTR _first$[esp-4]
  00005	0f be 80 00 00
	00 00		 movsx	 eax, BYTE PTR _trailingBytesForUTF8[eax]
  0000c	40		 inc	 eax

; 486  : }

  0000d	c3		 ret	 0
_getNumBytesForUTF8 ENDP
_TEXT	ENDS
PUBLIC	_isLegalUTF8String
; Function compile flags: /Ogtpy
;	COMDAT _isLegalUTF8String
_TEXT	SEGMENT
_source$ = 8						; size = 4
_sourceEnd$ = 12					; size = 4
_isLegalUTF8String PROC					; COMDAT

; 494  : int isLegalUTF8String(const UTF8 **source, const UTF8 *sourceEnd) {

  00000	53		 push	 ebx

; 495  :     while (*source != sourceEnd) {

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _source$[esp]
  00005	55		 push	 ebp
  00006	8b 6c 24 10	 mov	 ebp, DWORD PTR _sourceEnd$[esp+4]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	39 2b		 cmp	 DWORD PTR [ebx], ebp
  0000e	74 2a		 je	 SHORT $LN3@isLegalUTF@3
$LL4@isLegalUTF@3:

; 496  :         int length = trailingBytesForUTF8[**source] + 1;

  00010	8b 3b		 mov	 edi, DWORD PTR [ebx]
  00012	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00015	0f be b0 00 00
	00 00		 movsx	 esi, BYTE PTR _trailingBytesForUTF8[eax]

; 497  :         if (length > sourceEnd - *source || !isLegalUTF8(*source, length))

  0001c	8b cd		 mov	 ecx, ebp
  0001e	46		 inc	 esi
  0001f	2b cf		 sub	 ecx, edi
  00021	3b f1		 cmp	 esi, ecx
  00023	7f 1f		 jg	 SHORT $LN8@isLegalUTF@3
  00025	8b ce		 mov	 ecx, esi
  00027	8b d7		 mov	 edx, edi
  00029	e8 00 00 00 00	 call	 _isLegalUTF8
  0002e	85 c0		 test	 eax, eax
  00030	74 12		 je	 SHORT $LN8@isLegalUTF@3

; 499  :         *source += length;

  00032	03 fe		 add	 edi, esi
  00034	89 3b		 mov	 DWORD PTR [ebx], edi
  00036	3b fd		 cmp	 edi, ebp
  00038	75 d6		 jne	 SHORT $LL4@isLegalUTF@3
$LN3@isLegalUTF@3:
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5d		 pop	 ebp

; 500  :     }
; 501  :     return true;

  0003d	b8 01 00 00 00	 mov	 eax, 1
  00042	5b		 pop	 ebx

; 502  : }

  00043	c3		 ret	 0
$LN8@isLegalUTF@3:
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5d		 pop	 ebp

; 498  :             return false;

  00047	33 c0		 xor	 eax, eax
  00049	5b		 pop	 ebx

; 502  : }

  0004a	c3		 ret	 0
_isLegalUTF8String ENDP
_TEXT	ENDS
PUBLIC	_ConvertUTF8toUTF16
; Function compile flags: /Ogtpy
;	COMDAT _ConvertUTF8toUTF16
_TEXT	SEGMENT
tv368 = -16						; size = 4
tv357 = -12						; size = 4
_result$ = -8						; size = 4
_extraBytesToRead$1285 = -4				; size = 2
_sourceStart$ = 8					; size = 4
_sourceEnd$ = 12					; size = 4
_targetStart$ = 16					; size = 4
_targetEnd$ = 20					; size = 4
_flags$ = 24						; size = 4
_ConvertUTF8toUTF16 PROC				; COMDAT

; 508  :         UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags) {

  00000	83 ec 10	 sub	 esp, 16			; 00000010H

; 510  :     const UTF8* source = *sourceStart;
; 511  :     UTF16* target = *targetStart;

  00003	8b 4c 24 1c	 mov	 ecx, DWORD PTR _targetStart$[esp+12]
  00007	8b 44 24 14	 mov	 eax, DWORD PTR _sourceStart$[esp+12]
  0000b	53		 push	 ebx
  0000c	8b 19		 mov	 ebx, DWORD PTR [ecx]

; 512  :     while (source < sourceEnd) {

  0000e	8b 4c 24 1c	 mov	 ecx, DWORD PTR _sourceEnd$[esp+16]
  00012	57		 push	 edi
  00013	8b 38		 mov	 edi, DWORD PTR [eax]
  00015	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _result$[esp+24], 0
  0001d	3b f9		 cmp	 edi, ecx
  0001f	0f 83 b0 01 00
	00		 jae	 $LN23@ConvertUTF@5
  00025	55		 push	 ebp
  00026	8d 53 02	 lea	 edx, DWORD PTR [ebx+2]
  00029	2b cf		 sub	 ecx, edi
  0002b	56		 push	 esi
  0002c	89 54 24 14	 mov	 DWORD PTR tv357[esp+32], edx
  00030	89 4c 24 10	 mov	 DWORD PTR tv368[esp+32], ecx
  00034	eb 0e		 jmp	 SHORT $LN24@ConvertUTF@5
  00036	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL34@ConvertUTF@5:

; 509  :     ConversionResult result = conversionOK;

  00040	8b 4c 24 10	 mov	 ecx, DWORD PTR tv368[esp+32]
$LN24@ConvertUTF@5:

; 513  :         UTF32 ch = 0;
; 514  :         unsigned short extraBytesToRead = trailingBytesForUTF8[*source];

  00044	0f b6 2f	 movzx	 ebp, BYTE PTR [edi]
  00047	66 0f be 85 00
	00 00 00	 movsx	 ax, BYTE PTR _trailingBytesForUTF8[ebp]
  0004f	0f b7 c0	 movzx	 eax, ax
  00052	89 44 24 1c	 mov	 DWORD PTR _extraBytesToRead$1285[esp+32], eax

; 515  :         if (extraBytesToRead >= sourceEnd - source) {

  00056	0f b7 c0	 movzx	 eax, ax
  00059	33 f6		 xor	 esi, esi
  0005b	3b c1		 cmp	 eax, ecx
  0005d	0f 8d 26 01 00
	00		 jge	 $LN28@ConvertUTF@5

; 517  :         }
; 518  :         /* Do this check whether lenient or strict */
; 519  :         if (!isLegalUTF8(source, extraBytesToRead+1)) {

  00063	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  00066	8b d7		 mov	 edx, edi
  00068	e8 00 00 00 00	 call	 _isLegalUTF8
  0006d	85 c0		 test	 eax, eax
  0006f	0f 84 40 01 00
	00		 je	 $LN29@ConvertUTF@5

; 520  :             result = sourceIllegal;
; 521  :             break;
; 522  :         }
; 523  :         /*
; 524  :          * The cases all fall through. See "Note A" below.
; 525  :          */
; 526  :         switch (extraBytesToRead) {

  00075	0f b7 44 24 1c	 movzx	 eax, WORD PTR _extraBytesToRead$1285[esp+32]
  0007a	83 f8 05	 cmp	 eax, 5
  0007d	77 4f		 ja	 SHORT $LN19@ConvertUTF@5
  0007f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN42@ConvertUTF@5[eax*4]
$LN18@ConvertUTF@5:

; 527  :             case 5: ch += *source++; ch <<= 6; /* remember, illegal UTF-8 */

  00086	ff 4c 24 10	 dec	 DWORD PTR tv368[esp+32]
  0008a	8b f5		 mov	 esi, ebp
  0008c	47		 inc	 edi
  0008d	c1 e6 06	 shl	 esi, 6
$LN35@ConvertUTF@5:

; 528  :             case 4: ch += *source++; ch <<= 6; /* remember, illegal UTF-8 */

  00090	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  00093	ff 4c 24 10	 dec	 DWORD PTR tv368[esp+32]
  00097	03 f1		 add	 esi, ecx
  00099	47		 inc	 edi
  0009a	c1 e6 06	 shl	 esi, 6
$LN36@ConvertUTF@5:

; 529  :             case 3: ch += *source++; ch <<= 6;

  0009d	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  000a0	ff 4c 24 10	 dec	 DWORD PTR tv368[esp+32]
  000a4	03 f2		 add	 esi, edx
  000a6	47		 inc	 edi
  000a7	c1 e6 06	 shl	 esi, 6
$LN37@ConvertUTF@5:

; 530  :             case 2: ch += *source++; ch <<= 6;

  000aa	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  000ad	ff 4c 24 10	 dec	 DWORD PTR tv368[esp+32]
  000b1	03 f1		 add	 esi, ecx
  000b3	47		 inc	 edi
  000b4	c1 e6 06	 shl	 esi, 6
$LN38@ConvertUTF@5:

; 531  :             case 1: ch += *source++; ch <<= 6;

  000b7	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  000ba	ff 4c 24 10	 dec	 DWORD PTR tv368[esp+32]
  000be	03 f2		 add	 esi, edx
  000c0	47		 inc	 edi
  000c1	c1 e6 06	 shl	 esi, 6
$LN39@ConvertUTF@5:

; 532  :             case 0: ch += *source++;

  000c4	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  000c7	03 f1		 add	 esi, ecx
  000c9	47		 inc	 edi
  000ca	ff 4c 24 10	 dec	 DWORD PTR tv368[esp+32]
$LN19@ConvertUTF@5:

; 533  :         }
; 534  :         ch -= offsetsFromUTF8[extraBytesToRead];
; 535  : 
; 536  :         if (target >= targetEnd) {

  000ce	8b 4c 24 30	 mov	 ecx, DWORD PTR _targetEnd$[esp+28]
  000d2	2b 34 85 00 00
	00 00		 sub	 esi, DWORD PTR _offsetsFromUTF8[eax*4]
  000d9	3b d9		 cmp	 ebx, ecx
  000db	0f 83 de 00 00
	00		 jae	 $LN33@ConvertUTF@5

; 537  :             source -= (extraBytesToRead+1); /* Back up source pointer! */
; 538  :             result = targetExhausted; break;
; 539  :         }
; 540  :         if (ch <= UNI_MAX_BMP) { /* Target is a character <= 0xFFFF */

  000e1	81 fe ff ff 00
	00		 cmp	 esi, 65535		; 0000ffffH
  000e7	77 38		 ja	 SHORT $LN11@ConvertUTF@5

; 541  :             /* UTF-16 surrogate values are illegal in UTF-32 */
; 542  :             if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {

  000e9	8d 96 00 28 ff
	ff		 lea	 edx, DWORD PTR [esi-55296]
  000ef	81 fa ff 07 00
	00		 cmp	 edx, 2047		; 000007ffH
  000f5	77 1d		 ja	 SHORT $LN10@ConvertUTF@5

; 543  :                 if (flags == strictConversion) {

  000f7	83 7c 24 34 00	 cmp	 DWORD PTR _flags$[esp+28], 0
  000fc	0f 84 91 00 00
	00		 je	 $LN31@ConvertUTF@5

; 547  :                 } else {
; 548  :                     *target++ = UNI_REPLACEMENT_CHAR;

  00102	b8 fd ff 00 00	 mov	 eax, 65533		; 0000fffdH
  00107	66 89 03	 mov	 WORD PTR [ebx], ax
  0010a	83 c3 02	 add	 ebx, 2
  0010d	83 44 24 14 02	 add	 DWORD PTR tv357[esp+32], 2

; 549  :                 }
; 550  :             } else {

  00112	eb 69		 jmp	 SHORT $LN2@ConvertUTF@5
$LN10@ConvertUTF@5:

; 551  :                 *target++ = (UTF16)ch; /* normal case */

  00114	66 89 33	 mov	 WORD PTR [ebx], si
  00117	83 c3 02	 add	 ebx, 2
  0011a	83 44 24 14 02	 add	 DWORD PTR tv357[esp+32], 2

; 552  :             }

  0011f	eb 5c		 jmp	 SHORT $LN2@ConvertUTF@5
$LN11@ConvertUTF@5:

; 553  :         } else if (ch > UNI_MAX_UTF16) {

  00121	81 fe ff ff 10
	00		 cmp	 esi, 1114111		; 0010ffffH
  00127	76 19		 jbe	 SHORT $LN5@ConvertUTF@5

; 554  :             if (flags == strictConversion) {

  00129	83 7c 24 34 00	 cmp	 DWORD PTR _flags$[esp+28], 0
  0012e	74 79		 je	 SHORT $LN32@ConvertUTF@5

; 558  :             } else {
; 559  :                 *target++ = UNI_REPLACEMENT_CHAR;

  00130	b9 fd ff 00 00	 mov	 ecx, 65533		; 0000fffdH
  00135	66 89 0b	 mov	 WORD PTR [ebx], cx
  00138	83 c3 02	 add	 ebx, 2
  0013b	83 44 24 14 02	 add	 DWORD PTR tv357[esp+32], 2

; 560  :             }
; 561  :         } else {

  00140	eb 3b		 jmp	 SHORT $LN2@ConvertUTF@5
$LN5@ConvertUTF@5:

; 562  :             /* target is a character in range 0xFFFF - 0x10FFFF. */
; 563  :             if (target + 1 >= targetEnd) {

  00142	8b 44 24 14	 mov	 eax, DWORD PTR tv357[esp+32]
  00146	3b c1		 cmp	 eax, ecx
  00148	73 75		 jae	 SHORT $LN33@ConvertUTF@5

; 566  :             }
; 567  :             ch -= halfBase;

  0014a	81 ee 00 00 01
	00		 sub	 esi, 65536		; 00010000H

; 568  :             *target++ = (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START);

  00150	8b d6		 mov	 edx, esi
  00152	c1 ea 0a	 shr	 edx, 10			; 0000000aH
  00155	81 ea 00 28 00
	00		 sub	 edx, 10240		; 00002800H
  0015b	66 89 13	 mov	 WORD PTR [ebx], dx

; 569  :             *target++ = (UTF16)((ch & halfMask) + UNI_SUR_LOW_START);

  0015e	81 e6 ff 03 00
	00		 and	 esi, 1023		; 000003ffH
  00164	83 c3 02	 add	 ebx, 2
  00167	81 ee 00 24 00
	00		 sub	 esi, 9216		; 00002400H
  0016d	83 c0 02	 add	 eax, 2
  00170	66 89 33	 mov	 WORD PTR [ebx], si
  00173	83 c3 02	 add	 ebx, 2
  00176	83 c0 02	 add	 eax, 2
  00179	89 44 24 14	 mov	 DWORD PTR tv357[esp+32], eax
$LN2@ConvertUTF@5:

; 512  :     while (source < sourceEnd) {

  0017d	3b 7c 24 28	 cmp	 edi, DWORD PTR _sourceEnd$[esp+28]
  00181	0f 82 b9 fe ff
	ff		 jb	 $LL34@ConvertUTF@5

; 562  :             /* target is a character in range 0xFFFF - 0x10FFFF. */
; 563  :             if (target + 1 >= targetEnd) {

  00187	eb 4a		 jmp	 SHORT $LN40@ConvertUTF@5
$LN28@ConvertUTF@5:

; 516  :             result = sourceExhausted; break;

  00189	c7 44 24 18 01
	00 00 00	 mov	 DWORD PTR _result$[esp+32], 1
  00191	eb 40		 jmp	 SHORT $LN40@ConvertUTF@5
$LN31@ConvertUTF@5:

; 544  :                     source -= (extraBytesToRead+1); /* return to the illegal value itself */

  00193	0f b7 54 24 1c	 movzx	 edx, WORD PTR _extraBytesToRead$1285[esp+32]
  00198	83 c8 ff	 or	 eax, -1
  0019b	2b c2		 sub	 eax, edx
  0019d	03 f8		 add	 edi, eax

; 545  :                     result = sourceIllegal;

  0019f	c7 44 24 18 03
	00 00 00	 mov	 DWORD PTR _result$[esp+32], 3

; 546  :                     break;

  001a7	eb 2a		 jmp	 SHORT $LN40@ConvertUTF@5
$LN32@ConvertUTF@5:

; 556  :                 source -= (extraBytesToRead+1); /* return to the start */

  001a9	0f b7 4c 24 1c	 movzx	 ecx, WORD PTR _extraBytesToRead$1285[esp+32]
  001ae	83 ca ff	 or	 edx, -1
  001b1	2b d1		 sub	 edx, ecx
  001b3	03 fa		 add	 edi, edx
$LN29@ConvertUTF@5:

; 555  :                 result = sourceIllegal;

  001b5	c7 44 24 18 03
	00 00 00	 mov	 DWORD PTR _result$[esp+32], 3

; 557  :                 break; /* Bail out; shouldn't continue */

  001bd	eb 14		 jmp	 SHORT $LN40@ConvertUTF@5
$LN33@ConvertUTF@5:

; 564  :                 source -= (extraBytesToRead+1); /* Back up source pointer! */

  001bf	0f b7 44 24 1c	 movzx	 eax, WORD PTR _extraBytesToRead$1285[esp+32]
  001c4	83 c9 ff	 or	 ecx, -1
  001c7	2b c8		 sub	 ecx, eax

; 565  :                 result = targetExhausted; break;

  001c9	c7 44 24 18 02
	00 00 00	 mov	 DWORD PTR _result$[esp+32], 2
  001d1	03 f9		 add	 edi, ecx
$LN40@ConvertUTF@5:
  001d3	5e		 pop	 esi
  001d4	5d		 pop	 ebp
$LN23@ConvertUTF@5:

; 570  :         }
; 571  :     }
; 572  :     *sourceStart = source;

  001d5	8b 54 24 1c	 mov	 edx, DWORD PTR _sourceStart$[esp+20]

; 573  :     *targetStart = target;

  001d9	8b 44 24 24	 mov	 eax, DWORD PTR _targetStart$[esp+20]
  001dd	89 3a		 mov	 DWORD PTR [edx], edi
  001df	89 18		 mov	 DWORD PTR [eax], ebx

; 574  :     return result;

  001e1	8b 44 24 10	 mov	 eax, DWORD PTR _result$[esp+24]
  001e5	5f		 pop	 edi
  001e6	5b		 pop	 ebx

; 575  : }

  001e7	83 c4 10	 add	 esp, 16			; 00000010H
  001ea	c3		 ret	 0
  001eb	90		 npad	 1
$LN42@ConvertUTF@5:
  001ec	00 00 00 00	 DD	 $LN39@ConvertUTF@5
  001f0	00 00 00 00	 DD	 $LN38@ConvertUTF@5
  001f4	00 00 00 00	 DD	 $LN37@ConvertUTF@5
  001f8	00 00 00 00	 DD	 $LN36@ConvertUTF@5
  001fc	00 00 00 00	 DD	 $LN35@ConvertUTF@5
  00200	00 00 00 00	 DD	 $LN18@ConvertUTF@5
_ConvertUTF8toUTF16 ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _ConvertUTF8toUTF32Impl
_TEXT	SEGMENT
_result$ = -8						; size = 4
_extraBytesToRead$1342 = -4				; size = 2
_sourceStart$ = 8					; size = 4
_sourceEnd$ = 12					; size = 4
_targetStart$ = 16					; size = 4
_targetEnd$ = 20					; size = 4
_flags$ = 24						; size = 4
_InputIsPartial$ = 28					; size = 4
_ConvertUTF8toUTF32Impl PROC				; COMDAT

; 582  :         int InputIsPartial) {

  00000	83 ec 08	 sub	 esp, 8

; 583  :     ConversionResult result = conversionOK;
; 584  :     const UTF8* source = *sourceStart;
; 585  :     UTF32* target = *targetStart;

  00003	8b 4c 24 14	 mov	 ecx, DWORD PTR _targetStart$[esp+4]
  00007	8b 44 24 0c	 mov	 eax, DWORD PTR _sourceStart$[esp+4]
  0000b	55		 push	 ebp
  0000c	8b 29		 mov	 ebp, DWORD PTR [ecx]

; 586  :     while (source < sourceEnd) {

  0000e	8b 4c 24 14	 mov	 ecx, DWORD PTR _sourceEnd$[esp+8]
  00012	57		 push	 edi
  00013	8b 38		 mov	 edi, DWORD PTR [eax]
  00015	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR _result$[esp+16], 0
  0001d	3b f9		 cmp	 edi, ecx
  0001f	0f 83 11 01 00
	00		 jae	 $LN39@ConvertUTF@6
  00025	53		 push	 ebx
  00026	56		 push	 esi
  00027	eb 0b		 jmp	 SHORT $LN24@ConvertUTF@6
  00029	8d a4 24 00 00
	00 00		 npad	 7
$LL40@ConvertUTF@6:
  00030	8b 4c 24 20	 mov	 ecx, DWORD PTR _sourceEnd$[esp+20]
$LN24@ConvertUTF@6:

; 587  :         UTF32 ch = 0;
; 588  :         unsigned short extraBytesToRead = trailingBytesForUTF8[*source];

  00034	0f b6 37	 movzx	 esi, BYTE PTR [edi]
  00037	66 0f be 96 00
	00 00 00	 movsx	 dx, BYTE PTR _trailingBytesForUTF8[esi]
  0003f	0f b7 c2	 movzx	 eax, dx
  00042	89 44 24 14	 mov	 DWORD PTR _extraBytesToRead$1342[esp+24], eax

; 589  :         if (extraBytesToRead >= sourceEnd - source) {

  00046	0f b7 c0	 movzx	 eax, ax
  00049	8b d1		 mov	 edx, ecx
  0004b	2b d7		 sub	 edx, edi
  0004d	33 db		 xor	 ebx, ebx
  0004f	3b c2		 cmp	 eax, edx
  00051	7c 2c		 jl	 SHORT $LN19@ConvertUTF@6

; 590  :             if (flags == strictConversion || InputIsPartial) {

  00053	39 5c 24 2c	 cmp	 DWORD PTR _flags$[esp+20], ebx
  00057	0f 84 12 01 00
	00		 je	 $LN30@ConvertUTF@6
  0005d	39 5c 24 30	 cmp	 DWORD PTR _InputIsPartial$[esp+20], ebx
  00061	0f 85 08 01 00
	00		 jne	 $LN30@ConvertUTF@6

; 593  :             } else {
; 594  :                 result = sourceIllegal;
; 595  : 
; 596  :                 /*
; 597  :                  * Replace the maximal subpart of ill-formed sequence with
; 598  :                  * replacement character.
; 599  :                  */
; 600  :                 source += findMaximalSubpartOfIllFormedUTF8Sequence(source,
; 601  :                                                                     sourceEnd);

  00067	8b f1		 mov	 esi, ecx
  00069	8b cf		 mov	 ecx, edi
  0006b	c7 44 24 10 03
	00 00 00	 mov	 DWORD PTR _result$[esp+24], 3
  00073	e8 00 00 00 00	 call	 _findMaximalSubpartOfIllFormedUTF8Sequence
  00078	03 f8		 add	 edi, eax

; 602  :                 *target++ = UNI_REPLACEMENT_CHAR;
; 603  :                 continue;

  0007a	e9 da 00 00 00	 jmp	 $LN43@ConvertUTF@6
$LN19@ConvertUTF@6:

; 604  :             }
; 605  :         }
; 606  :         if (target >= targetEnd) {

  0007f	3b 6c 24 28	 cmp	 ebp, DWORD PTR _targetEnd$[esp+20]
  00083	0f 83 f0 00 00
	00		 jae	 $LN31@ConvertUTF@6

; 608  :         }
; 609  : 
; 610  :         /* Do this check whether lenient or strict */
; 611  :         if (!isLegalUTF8(source, extraBytesToRead+1)) {

  00089	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0008c	8b d7		 mov	 edx, edi
  0008e	e8 00 00 00 00	 call	 _isLegalUTF8
  00093	85 c0		 test	 eax, eax
  00095	75 24		 jne	 SHORT $LN15@ConvertUTF@6

; 612  :             result = sourceIllegal;

  00097	c7 44 24 10 03
	00 00 00	 mov	 DWORD PTR _result$[esp+24], 3

; 613  :             if (flags == strictConversion) {

  0009f	39 44 24 2c	 cmp	 DWORD PTR _flags$[esp+20], eax
  000a3	0f 84 8b 00 00
	00		 je	 $LN41@ConvertUTF@6

; 614  :                 /* Abort conversion. */
; 615  :                 break;
; 616  :             } else {
; 617  :                 /*
; 618  :                  * Replace the maximal subpart of ill-formed sequence with
; 619  :                  * replacement character.
; 620  :                  */
; 621  :                 source += findMaximalSubpartOfIllFormedUTF8Sequence(source,
; 622  :                                                                     sourceEnd);

  000a9	8b 74 24 20	 mov	 esi, DWORD PTR _sourceEnd$[esp+20]
  000ad	8b cf		 mov	 ecx, edi
  000af	e8 00 00 00 00	 call	 _findMaximalSubpartOfIllFormedUTF8Sequence
  000b4	03 f8		 add	 edi, eax

; 623  :                 *target++ = UNI_REPLACEMENT_CHAR;
; 624  :                 continue;

  000b6	e9 9e 00 00 00	 jmp	 $LN43@ConvertUTF@6
$LN15@ConvertUTF@6:

; 625  :             }
; 626  :         }
; 627  :         /*
; 628  :          * The cases all fall through. See "Note A" below.
; 629  :          */
; 630  :         switch (extraBytesToRead) {

  000bb	0f b7 44 24 14	 movzx	 eax, WORD PTR _extraBytesToRead$1342[esp+24]
  000c0	83 f8 05	 cmp	 eax, 5
  000c3	77 37		 ja	 SHORT $LN13@ConvertUTF@6
  000c5	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN45@ConvertUTF@6[eax*4]
$LN12@ConvertUTF@6:

; 631  :             case 5: ch += *source++; ch <<= 6;

  000cc	8b de		 mov	 ebx, esi
  000ce	47		 inc	 edi
  000cf	c1 e3 06	 shl	 ebx, 6
$LN34@ConvertUTF@6:

; 632  :             case 4: ch += *source++; ch <<= 6;

  000d2	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  000d5	03 d9		 add	 ebx, ecx
  000d7	47		 inc	 edi
  000d8	c1 e3 06	 shl	 ebx, 6
$LN35@ConvertUTF@6:

; 633  :             case 3: ch += *source++; ch <<= 6;

  000db	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  000de	03 da		 add	 ebx, edx
  000e0	47		 inc	 edi
  000e1	c1 e3 06	 shl	 ebx, 6
$LN36@ConvertUTF@6:

; 634  :             case 2: ch += *source++; ch <<= 6;

  000e4	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  000e7	03 d9		 add	 ebx, ecx
  000e9	47		 inc	 edi
  000ea	c1 e3 06	 shl	 ebx, 6
$LN37@ConvertUTF@6:

; 635  :             case 1: ch += *source++; ch <<= 6;

  000ed	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  000f0	03 da		 add	 ebx, edx
  000f2	47		 inc	 edi
  000f3	c1 e3 06	 shl	 ebx, 6
$LN38@ConvertUTF@6:

; 636  :             case 0: ch += *source++;

  000f6	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  000f9	03 d9		 add	 ebx, ecx
  000fb	47		 inc	 edi
$LN13@ConvertUTF@6:

; 637  :         }
; 638  :         ch -= offsetsFromUTF8[extraBytesToRead];

  000fc	2b 1c 85 00 00
	00 00		 sub	 ebx, DWORD PTR _offsetsFromUTF8[eax*4]

; 639  : 
; 640  :         if (ch <= UNI_MAX_LEGAL_UTF32) {

  00103	81 fb ff ff 10
	00		 cmp	 ebx, 1114111		; 0010ffffH
  00109	77 46		 ja	 SHORT $LN6@ConvertUTF@6

; 641  :             /*
; 642  :              * UTF-16 surrogate values are illegal in UTF-32, and anything
; 643  :              * over Plane 17 (> 0x10FFFF) is illegal.
; 644  :              */
; 645  :             if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {

  0010b	8d 93 00 28 ff
	ff		 lea	 edx, DWORD PTR [ebx-55296]
  00111	81 fa ff 07 00
	00		 cmp	 edx, 2047		; 000007ffH
  00117	77 33		 ja	 SHORT $LN5@ConvertUTF@6

; 646  :                 if (flags == strictConversion) {

  00119	83 7c 24 2c 00	 cmp	 DWORD PTR _flags$[esp+20], 0
  0011e	75 39		 jne	 SHORT $LN43@ConvertUTF@6

; 647  :                     source -= (extraBytesToRead+1); /* return to the illegal value itself */

  00120	0f b7 44 24 14	 movzx	 eax, WORD PTR _extraBytesToRead$1342[esp+24]
  00125	83 c9 ff	 or	 ecx, -1
  00128	2b c8		 sub	 ecx, eax
  0012a	03 f9		 add	 edi, ecx

; 648  :                     result = sourceIllegal;

  0012c	c7 44 24 10 03
	00 00 00	 mov	 DWORD PTR _result$[esp+24], 3
$LN41@ConvertUTF@6:
  00134	5e		 pop	 esi
  00135	5b		 pop	 ebx
$LN39@ConvertUTF@6:

; 659  :         }
; 660  :     }
; 661  :     *sourceStart = source;

  00136	8b 54 24 14	 mov	 edx, DWORD PTR _sourceStart$[esp+12]

; 662  :     *targetStart = target;

  0013a	8b 44 24 1c	 mov	 eax, DWORD PTR _targetStart$[esp+12]
  0013e	89 3a		 mov	 DWORD PTR [edx], edi
  00140	89 28		 mov	 DWORD PTR [eax], ebp

; 663  :     return result;

  00142	8b 44 24 08	 mov	 eax, DWORD PTR _result$[esp+16]
  00146	5f		 pop	 edi
  00147	5d		 pop	 ebp

; 664  : }

  00148	83 c4 08	 add	 esp, 8
  0014b	c3		 ret	 0
$LN5@ConvertUTF@6:

; 649  :                     break;
; 650  :                 } else {
; 651  :                     *target++ = UNI_REPLACEMENT_CHAR;
; 652  :                 }
; 653  :             } else {
; 654  :                 *target++ = ch;

  0014c	89 5d 00	 mov	 DWORD PTR [ebp], ebx

; 655  :             }
; 656  :         } else { /* i.e., ch > UNI_MAX_LEGAL_UTF32 */

  0014f	eb 0f		 jmp	 SHORT $LN44@ConvertUTF@6
$LN6@ConvertUTF@6:

; 657  :             result = sourceIllegal;

  00151	c7 44 24 10 03
	00 00 00	 mov	 DWORD PTR _result$[esp+24], 3
$LN43@ConvertUTF@6:

; 658  :             *target++ = UNI_REPLACEMENT_CHAR;

  00159	c7 45 00 fd ff
	00 00		 mov	 DWORD PTR [ebp], 65533	; 0000fffdH
$LN44@ConvertUTF@6:
  00160	83 c5 04	 add	 ebp, 4
  00163	3b 7c 24 20	 cmp	 edi, DWORD PTR _sourceEnd$[esp+20]
  00167	0f 82 c3 fe ff
	ff		 jb	 $LL40@ConvertUTF@6

; 646  :                 if (flags == strictConversion) {

  0016d	eb c5		 jmp	 SHORT $LN41@ConvertUTF@6
$LN30@ConvertUTF@6:

; 591  :                 result = sourceExhausted;

  0016f	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR _result$[esp+24], 1

; 592  :                 break;

  00177	eb bb		 jmp	 SHORT $LN41@ConvertUTF@6
$LN31@ConvertUTF@6:

; 607  :             result = targetExhausted; break;

  00179	c7 44 24 10 02
	00 00 00	 mov	 DWORD PTR _result$[esp+24], 2
  00181	eb b1		 jmp	 SHORT $LN41@ConvertUTF@6
  00183	90		 npad	 1
$LN45@ConvertUTF@6:

; 664  : }

  00184	00 00 00 00	 DD	 $LN38@ConvertUTF@6
  00188	00 00 00 00	 DD	 $LN37@ConvertUTF@6
  0018c	00 00 00 00	 DD	 $LN36@ConvertUTF@6
  00190	00 00 00 00	 DD	 $LN35@ConvertUTF@6
  00194	00 00 00 00	 DD	 $LN34@ConvertUTF@6
  00198	00 00 00 00	 DD	 $LN12@ConvertUTF@6
_ConvertUTF8toUTF32Impl ENDP
_TEXT	ENDS
PUBLIC	_ConvertUTF8toUTF32Partial
; Function compile flags: /Ogtpy
;	COMDAT _ConvertUTF8toUTF32Partial
_TEXT	SEGMENT
_sourceStart$ = 8					; size = 4
_sourceEnd$ = 12					; size = 4
_targetStart$ = 16					; size = 4
_targetEnd$ = 20					; size = 4
_flags$ = 24						; size = 4
_ConvertUTF8toUTF32Partial PROC				; COMDAT

; 671  :   return ConvertUTF8toUTF32Impl(sourceStart, sourceEnd, targetStart, targetEnd,
; 672  :                                 flags, /*InputIsPartial=*/true);

  00000	8b 44 24 14	 mov	 eax, DWORD PTR _flags$[esp-4]
  00004	8b 4c 24 10	 mov	 ecx, DWORD PTR _targetEnd$[esp-4]
  00008	8b 54 24 0c	 mov	 edx, DWORD PTR _targetStart$[esp-4]
  0000c	6a 01		 push	 1
  0000e	50		 push	 eax
  0000f	8b 44 24 10	 mov	 eax, DWORD PTR _sourceEnd$[esp+4]
  00013	51		 push	 ecx
  00014	8b 4c 24 10	 mov	 ecx, DWORD PTR _sourceStart$[esp+8]
  00018	52		 push	 edx
  00019	50		 push	 eax
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 _ConvertUTF8toUTF32Impl
  00020	83 c4 18	 add	 esp, 24			; 00000018H

; 673  : }

  00023	c3		 ret	 0
_ConvertUTF8toUTF32Partial ENDP
_TEXT	ENDS
PUBLIC	_ConvertUTF8toUTF32
; Function compile flags: /Ogtpy
;	COMDAT _ConvertUTF8toUTF32
_TEXT	SEGMENT
_sourceStart$ = 8					; size = 4
_sourceEnd$ = 12					; size = 4
_targetStart$ = 16					; size = 4
_targetEnd$ = 20					; size = 4
_flags$ = 24						; size = 4
_ConvertUTF8toUTF32 PROC				; COMDAT

; 678  :   return ConvertUTF8toUTF32Impl(sourceStart, sourceEnd, targetStart, targetEnd,
; 679  :                                 flags, /*InputIsPartial=*/false);

  00000	8b 44 24 14	 mov	 eax, DWORD PTR _flags$[esp-4]
  00004	8b 4c 24 10	 mov	 ecx, DWORD PTR _targetEnd$[esp-4]
  00008	8b 54 24 0c	 mov	 edx, DWORD PTR _targetStart$[esp-4]
  0000c	6a 00		 push	 0
  0000e	50		 push	 eax
  0000f	8b 44 24 10	 mov	 eax, DWORD PTR _sourceEnd$[esp+4]
  00013	51		 push	 ecx
  00014	8b 4c 24 10	 mov	 ecx, DWORD PTR _sourceStart$[esp+8]
  00018	52		 push	 edx
  00019	50		 push	 eax
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 _ConvertUTF8toUTF32Impl
  00020	83 c4 18	 add	 esp, 24			; 00000018H

; 680  : }

  00023	c3		 ret	 0
_ConvertUTF8toUTF32 ENDP
_TEXT	ENDS
END
