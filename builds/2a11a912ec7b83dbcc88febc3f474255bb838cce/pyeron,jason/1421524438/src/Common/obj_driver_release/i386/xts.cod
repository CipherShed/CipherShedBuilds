; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\home\public\desktop\projects\ciphershed.build\src\common\xts.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_ks2$GSCopy$
PUBLIC	_ks$GSCopy$
PUBLIC	__$ArrayPad$
EXTRN	_EncipherBlocks@16:PROC
EXTRN	_EncipherBlock@12:PROC
EXTRN	__imp__KeBugCheckEx@20:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogsp
; File c:\home\public\desktop\projects\ciphershed.build\src\common\xts.c
;	COMDAT _EncryptBufferXTSParallel@32
_TEXT	SEGMENT
_ks$GSCopy$ = -576					; size = 4
_ks2$GSCopy$ = -572					; size = 4
_dataUnitNo$ = -568					; size = 8
_startBlock$ = -560					; size = 4
_block$ = -556						; size = 4
_blockCount$ = -552					; size = 8
_dataUnitBufPtr$ = -544					; size = 4
_whiteningValuesPtr64$ = -544				; size = 4
_endBlock$ = -540					; size = 4
_finalCarry$ = -533					; size = 1
_whiteningValues$ = -532				; size = 512
_whiteningValue$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_length$ = 8						; size = 8
_startDataUnitNo$ = 16					; size = 4
_startCipherBlockNo$ = 20				; size = 4
_ks2$ = 24						; size = 4
_cipher$ = 28						; size = 4
_EncryptBufferXTSParallel@32 PROC			; COMDAT
; _buffer$ = edx
; _ks$ = ecx

; 64   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 40 02 00
	00		 sub	 esp, 576		; 00000240H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	8b 45 10	 mov	 eax, DWORD PTR _startDataUnitNo$[ebp]
  00018	89 8d c0 fd ff
	ff		 mov	 DWORD PTR _ks$GSCopy$[ebp], ecx

; 65   : 	unsigned __int8 finalCarry;
; 66   : 	unsigned __int8 whiteningValues [ENCRYPTION_DATA_UNIT_SIZE];
; 67   : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 68   : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 69   : 	unsigned __int64 *whiteningValuesPtr64 = (unsigned __int64 *) whiteningValues;
; 70   : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 71   : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
; 72   : 	unsigned __int64 *dataUnitBufPtr;
; 73   : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;

  0001e	8b 4d 18	 mov	 ecx, DWORD PTR _ks2$[ebp]
  00021	89 8d c4 fd ff
	ff		 mov	 DWORD PTR _ks2$GSCopy$[ebp], ecx
  00027	8b 4d 14	 mov	 ecx, DWORD PTR _startCipherBlockNo$[ebp]
  0002a	56		 push	 esi
  0002b	89 8d d0 fd ff
	ff		 mov	 DWORD PTR _startBlock$[ebp], ecx

; 74   : 	unsigned __int64 *const finalInt64WhiteningValuesPtr = whiteningValuesPtr64 + sizeof (whiteningValues) / sizeof (*whiteningValuesPtr64) - 1;
; 75   : 	TC_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 76   : 
; 77   : 	/* The encrypted data unit number (i.e. the resultant ciphertext block) is to be multiplied in the
; 78   : 	finite field GF(2^128) by j-th power of n, where j is the sequential plaintext/ciphertext block
; 79   : 	number and n is 2, a primitive element of GF(2^128). This can be (and is) simplified and implemented
; 80   : 	as a left shift of the preceding whitening value by one bit (with carry propagating). In addition, if
; 81   : 	the shift of the highest byte results in a carry, 135 is XORed into the lowest byte. The value 135 is
; 82   : 	derived from the modulus of the Galois Field (x^128+x^7+x^2+x+1). */
; 83   : 
; 84   : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 85   : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 86   : 	dataUnitNo = startDataUnitNo->Value;

  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00036	57		 push	 edi
  00037	8b fa		 mov	 edi, edx

; 87   : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 88   : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
; 89   : 
; 90   : 	if (length % BYTES_PER_XTS_BLOCK)

  00039	8b 55 08	 mov	 edx, DWORD PTR _length$[ebp]
  0003c	89 85 cc fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp+4], eax
  00042	8b c2		 mov	 eax, edx
  00044	89 8d c8 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp], ecx
  0004a	83 e0 0f	 and	 eax, 15			; 0000000fH
  0004d	33 c9		 xor	 ecx, ecx
  0004f	33 f6		 xor	 esi, esi
  00051	0b c1		 or	 eax, ecx
  00053	74 11		 je	 SHORT $LN27@EncryptBuf

; 91   : 		TC_THROW_FATAL_EXCEPTION;

  00055	68 43 54 00 00	 push	 21571			; 00005443H
  0005a	56		 push	 esi
  0005b	56		 push	 esi
  0005c	6a 5b		 push	 91			; 0000005bH
  0005e	6a 29		 push	 41			; 00000029H
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN61@EncryptBuf:
$LN27@EncryptBuf:

; 92   : 
; 93   : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  00066	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp+4]
  00069	0f ac c2 04	 shrd	 edx, eax, 4
  0006d	c1 e8 04	 shr	 eax, 4
  00070	89 85 dc fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp+4], eax
  00076	89 95 d8 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp], edx

; 94   : 
; 95   : 	// Process all blocks in the buffer
; 96   : 	while (blockCount > 0)

  0007c	3b c6		 cmp	 eax, esi
  0007e	77 08		 ja	 SHORT $LN49@EncryptBuf
  00080	3b d6		 cmp	 edx, esi
  00082	0f 86 09 02 00
	00		 jbe	 $LN10@EncryptBuf
$LN49@EncryptBuf:
  00088	53		 push	 ebx
  00089	eb 08		 jmp	 SHORT $LN26@EncryptBuf
$LL55@EncryptBuf:
  0008b	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _blockCount$[ebp+4]
  00091	33 f6		 xor	 esi, esi
$LN26@EncryptBuf:

; 97   : 	{
; 98   : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  00093	3b c6		 cmp	 eax, esi
  00095	77 21		 ja	 SHORT $LN56@EncryptBuf
  00097	72 09		 jb	 SHORT $LN59@EncryptBuf
  00099	83 bd d8 fd ff
	ff 20		 cmp	 DWORD PTR _blockCount$[ebp], 32 ; 00000020H
  000a0	73 16		 jae	 SHORT $LN56@EncryptBuf
$LN59@EncryptBuf:

; 99   : 			endBlock = startBlock + (unsigned int) blockCount;

  000a2	8b 85 d0 fd ff
	ff		 mov	 eax, DWORD PTR _startBlock$[ebp]
  000a8	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _blockCount$[ebp]
  000ae	03 c8		 add	 ecx, eax
  000b0	89 8d e4 fd ff
	ff		 mov	 DWORD PTR _endBlock$[ebp], ecx

; 100  : 		else

  000b6	eb 0a		 jmp	 SHORT $LN23@EncryptBuf
$LN56@EncryptBuf:

; 101  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  000b8	c7 85 e4 fd ff
	ff 20 00 00 00	 mov	 DWORD PTR _endBlock$[ebp], 32 ; 00000020H
$LN23@EncryptBuf:

; 102  : 
; 103  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
; 104  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 105  : 
; 106  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 107  : 		// whitening value for this data unit)
; 108  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  000c2	8b 85 c8 fd ff
	ff		 mov	 eax, DWORD PTR _dataUnitNo$[ebp]

; 109  : 		*(whiteningValuePtr64 + 1) = 0;
; 110  : 		EncipherBlock (cipher, whiteningValue, ks2);

  000c8	ff b5 c4 fd ff
	ff		 push	 DWORD PTR _ks2$GSCopy$[ebp]
  000ce	83 65 f4 00	 and	 DWORD PTR _whiteningValue$[ebp+8], 0
  000d2	83 65 f8 00	 and	 DWORD PTR _whiteningValue$[ebp+12], 0
  000d6	89 45 ec	 mov	 DWORD PTR _whiteningValue$[ebp], eax
  000d9	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _dataUnitNo$[ebp+4]
  000df	8d 75 ec	 lea	 esi, DWORD PTR _whiteningValue$[ebp]
  000e2	89 45 f0	 mov	 DWORD PTR _whiteningValue$[ebp+4], eax
  000e5	8b c6		 mov	 eax, esi
  000e7	50		 push	 eax
  000e8	ff 75 1c	 push	 DWORD PTR _cipher$[ebp]
  000eb	8d 5d e4	 lea	 ebx, DWORD PTR _whiteningValues$[ebp+504]
  000ee	89 9d e0 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], ebx
  000f4	e8 00 00 00 00	 call	 _EncipherBlock@12

; 111  : 
; 112  : 		// Generate subsequent whitening values for blocks in this data unit. Note that all generated 128-bit
; 113  : 		// whitening values are stored in memory as a sequence of 64-bit integers in reverse order.
; 114  : 		for (block = 0; block < endBlock; block++)

  000f9	83 a5 d4 fd ff
	ff 00		 and	 DWORD PTR _block$[ebp], 0
  00100	83 bd e4 fd ff
	ff 00		 cmp	 DWORD PTR _endBlock$[ebp], 0
  00107	0f 86 b6 00 00
	00		 jbe	 $LN20@EncryptBuf
  0010d	eb 06		 jmp	 SHORT $LN22@EncryptBuf
$LL57@EncryptBuf:
  0010f	8b 9d e0 fd ff
	ff		 mov	 ebx, DWORD PTR _whiteningValuesPtr64$[ebp]
$LN22@EncryptBuf:

; 115  : 		{
; 116  : 			if (block >= startBlock)

  00115	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _block$[ebp]
  0011b	3b 85 d0 fd ff
	ff		 cmp	 eax, DWORD PTR _startBlock$[ebp]
  00121	72 25		 jb	 SHORT $LN19@EncryptBuf

; 117  : 			{
; 118  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64++;

  00123	8b 06		 mov	 eax, DWORD PTR [esi]
  00125	89 03		 mov	 DWORD PTR [ebx], eax
  00127	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0012a	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0012d	83 c6 08	 add	 esi, 8

; 119  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64;

  00130	8b 06		 mov	 eax, DWORD PTR [esi]
  00132	83 eb 08	 sub	 ebx, 8
  00135	89 03		 mov	 DWORD PTR [ebx], eax
  00137	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0013a	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0013d	83 eb 08	 sub	 ebx, 8
  00140	89 9d e0 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], ebx

; 120  : 			}
; 121  : 			else

  00146	eb 03		 jmp	 SHORT $LN18@EncryptBuf
$LN19@EncryptBuf:

; 122  : 				whiteningValuePtr64++;

  00148	83 c6 08	 add	 esi, 8
$LN18@EncryptBuf:

; 123  : 
; 124  : 			// Derive the next whitening value
; 125  : 
; 126  : #if BYTE_ORDER == LITTLE_ENDIAN
; 127  : 
; 128  : 			// Little-endian platforms
; 129  : 
; 130  : 			finalCarry = 
; 131  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 132  : 				135 : 0;

  0014b	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0014e	8b 06		 mov	 eax, DWORD PTR [esi]
  00150	8b da		 mov	 ebx, edx
  00152	81 e3 00 00 00
	80		 and	 ebx, -2147483648	; 80000000H
  00158	33 c9		 xor	 ecx, ecx
  0015a	0b cb		 or	 ecx, ebx
  0015c	c6 85 eb fd ff
	ff 87		 mov	 BYTE PTR _finalCarry$[ebp], 135 ; 00000087H
  00163	75 07		 jne	 SHORT $LN31@EncryptBuf
  00165	c6 85 eb fd ff
	ff 00		 mov	 BYTE PTR _finalCarry$[ebp], 0
$LN31@EncryptBuf:

; 133  : 
; 134  : 			*whiteningValuePtr64-- <<= 1;

  0016c	0f a4 c2 01	 shld	 edx, eax, 1
  00170	03 c0		 add	 eax, eax
  00172	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00175	89 06		 mov	 DWORD PTR [esi], eax

; 135  : 
; 136  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  00177	8b 5e fc	 mov	 ebx, DWORD PTR [esi-4]
  0017a	83 ee 08	 sub	 esi, 8
  0017d	8b 06		 mov	 eax, DWORD PTR [esi]
  0017f	8b d3		 mov	 edx, ebx
  00181	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H
  00187	33 c9		 xor	 ecx, ecx
  00189	0b ca		 or	 ecx, edx
  0018b	74 0a		 je	 SHORT $LN17@EncryptBuf

; 137  : 				*(whiteningValuePtr64 + 1) |= 1;	

  0018d	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00190	83 4e 08 01	 or	 DWORD PTR [esi+8], 1
  00194	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
$LN17@EncryptBuf:

; 138  : 
; 139  : 			*whiteningValuePtr64 <<= 1;

  00197	0f a4 c3 01	 shld	 ebx, eax, 1
  0019b	03 c0		 add	 eax, eax
  0019d	89 06		 mov	 DWORD PTR [esi], eax

; 140  : #else
; 141  : 
; 142  : 			// Big-endian platforms
; 143  : 
; 144  : 			finalCarry = 
; 145  : 				(*whiteningValuePtr64 & 0x80) ?
; 146  : 				135 : 0;
; 147  : 
; 148  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 149  : 
; 150  : 			whiteningValuePtr64--;
; 151  : 
; 152  : 			if (*whiteningValuePtr64 & 0x80)
; 153  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 154  : 
; 155  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 156  : #endif
; 157  : 
; 158  : 			whiteningValue[0] ^= finalCarry;

  0019f	8a 85 eb fd ff
	ff		 mov	 al, BYTE PTR _finalCarry$[ebp]
  001a5	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  001a8	30 45 ec	 xor	 BYTE PTR _whiteningValue$[ebp], al
  001ab	ff 85 d4 fd ff
	ff		 inc	 DWORD PTR _block$[ebp]
  001b1	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _block$[ebp]
  001b7	3b 85 e4 fd ff
	ff		 cmp	 eax, DWORD PTR _endBlock$[ebp]
  001bd	0f 82 4c ff ff
	ff		 jb	 $LL57@EncryptBuf
$LN20@EncryptBuf:

; 162  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
; 163  : 
; 164  : 		// Encrypt all blocks in this data unit
; 165  : 
; 166  : 		for (block = startBlock; block < endBlock; block++)

  001c3	8b 9d d0 fd ff
	ff		 mov	 ebx, DWORD PTR _startBlock$[ebp]
  001c9	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR _endBlock$[ebp]
  001cf	89 bd e0 fd ff
	ff		 mov	 DWORD PTR _dataUnitBufPtr$[ebp], edi
  001d5	8d 45 e4	 lea	 eax, DWORD PTR _whiteningValues$[ebp+504]
  001d8	3b d9		 cmp	 ebx, ecx
  001da	73 24		 jae	 SHORT $LN14@EncryptBuf

; 159  : 		}
; 160  : 
; 161  : 		dataUnitBufPtr = bufPtr;

  001dc	2b cb		 sub	 ecx, ebx
$LL16@EncryptBuf:

; 167  : 		{
; 168  : 			// Pre-whitening
; 169  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  001de	8b 10		 mov	 edx, DWORD PTR [eax]
  001e0	31 17		 xor	 DWORD PTR [edi], edx
  001e2	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001e5	31 57 04	 xor	 DWORD PTR [edi+4], edx
  001e8	6a 08		 push	 8
  001ea	5a		 pop	 edx
  001eb	2b c2		 sub	 eax, edx

; 170  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  001ed	8b 30		 mov	 esi, DWORD PTR [eax]
  001ef	03 fa		 add	 edi, edx
  001f1	31 37		 xor	 DWORD PTR [edi], esi
  001f3	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  001f6	31 77 04	 xor	 DWORD PTR [edi+4], esi
  001f9	2b c2		 sub	 eax, edx
  001fb	03 fa		 add	 edi, edx
  001fd	49		 dec	 ecx
  001fe	75 de		 jne	 SHORT $LL16@EncryptBuf
$LN14@EncryptBuf:

; 171  : 		}
; 172  : 
; 173  : 		// Actual encryption
; 174  : 		EncipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);

  00200	8b b5 e4 fd ff
	ff		 mov	 esi, DWORD PTR _endBlock$[ebp]
  00206	2b f3		 sub	 esi, ebx
  00208	56		 push	 esi
  00209	ff b5 c0 fd ff
	ff		 push	 DWORD PTR _ks$GSCopy$[ebp]
  0020f	ff b5 e0 fd ff
	ff		 push	 DWORD PTR _dataUnitBufPtr$[ebp]
  00215	ff 75 1c	 push	 DWORD PTR _cipher$[ebp]
  00218	e8 00 00 00 00	 call	 _EncipherBlocks@16

; 175  : 		
; 176  : 		bufPtr = dataUnitBufPtr;

  0021d	8b bd e0 fd ff
	ff		 mov	 edi, DWORD PTR _dataUnitBufPtr$[ebp]

; 177  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  00223	8d 45 e4	 lea	 eax, DWORD PTR _whiteningValues$[ebp+504]

; 178  : 
; 179  : 		for (block = startBlock; block < endBlock; block++)

  00226	3b 9d e4 fd ff
	ff		 cmp	 ebx, DWORD PTR _endBlock$[ebp]
  0022c	73 24		 jae	 SHORT $LN11@EncryptBuf

; 171  : 		}
; 172  : 
; 173  : 		// Actual encryption
; 174  : 		EncipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);

  0022e	8b d6		 mov	 edx, esi
$LL13@EncryptBuf:

; 180  : 		{
; 181  : 			// Post-whitening
; 182  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00230	8b 08		 mov	 ecx, DWORD PTR [eax]
  00232	31 0f		 xor	 DWORD PTR [edi], ecx
  00234	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00237	31 4f 04	 xor	 DWORD PTR [edi+4], ecx
  0023a	6a 08		 push	 8
  0023c	59		 pop	 ecx
  0023d	2b c1		 sub	 eax, ecx

; 183  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  0023f	8b 18		 mov	 ebx, DWORD PTR [eax]
  00241	03 f9		 add	 edi, ecx
  00243	31 1f		 xor	 DWORD PTR [edi], ebx
  00245	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  00248	31 5f 04	 xor	 DWORD PTR [edi+4], ebx
  0024b	2b c1		 sub	 eax, ecx
  0024d	03 f9		 add	 edi, ecx
  0024f	4a		 dec	 edx
  00250	75 de		 jne	 SHORT $LL13@EncryptBuf
$LN11@EncryptBuf:

; 184  : 		}
; 185  : 
; 186  : 		blockCount -= endBlock - startBlock;

  00252	29 b5 d8 fd ff
	ff		 sub	 DWORD PTR _blockCount$[ebp], esi
  00258	6a 00		 push	 0
  0025a	58		 pop	 eax
  0025b	19 85 dc fd ff
	ff		 sbb	 DWORD PTR _blockCount$[ebp+4], eax

; 187  : 		startBlock = 0;
; 188  : 		dataUnitNo++;

  00261	83 85 c8 fd ff
	ff 01		 add	 DWORD PTR _dataUnitNo$[ebp], 1
  00268	89 85 d0 fd ff
	ff		 mov	 DWORD PTR _startBlock$[ebp], eax
  0026e	11 85 cc fd ff
	ff		 adc	 DWORD PTR _dataUnitNo$[ebp+4], eax
  00274	39 85 dc fd ff
	ff		 cmp	 DWORD PTR _blockCount$[ebp+4], eax
  0027a	0f 87 0b fe ff
	ff		 ja	 $LL55@EncryptBuf

; 94   : 
; 95   : 	// Process all blocks in the buffer
; 96   : 	while (blockCount > 0)

  00280	72 0c		 jb	 SHORT $LN58@EncryptBuf
  00282	39 85 d8 fd ff
	ff		 cmp	 DWORD PTR _blockCount$[ebp], eax
  00288	0f 87 fd fd ff
	ff		 ja	 $LL55@EncryptBuf
$LN58@EncryptBuf:
  0028e	33 f6		 xor	 esi, esi
  00290	5b		 pop	 ebx
$LN10@EncryptBuf:

; 189  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 190  : 	}
; 191  : 
; 192  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  00291	6a 02		 push	 2
  00293	8d 45 ec	 lea	 eax, DWORD PTR _whiteningValue$[ebp]
  00296	59		 pop	 ecx
$LL7@EncryptBuf:
  00297	89 30		 mov	 DWORD PTR [eax], esi
  00299	49		 dec	 ecx
  0029a	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0029d	83 c0 08	 add	 eax, 8
  002a0	3b ce		 cmp	 ecx, esi
  002a2	75 f3		 jne	 SHORT $LL7@EncryptBuf

; 193  : 	FAST_ERASE64 (whiteningValues, sizeof (whiteningValues));

  002a4	6a 40		 push	 64			; 00000040H
  002a6	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _whiteningValues$[ebp]
  002ac	59		 pop	 ecx
$LL2@EncryptBuf:
  002ad	89 30		 mov	 DWORD PTR [eax], esi
  002af	49		 dec	 ecx
  002b0	89 70 04	 mov	 DWORD PTR [eax+4], esi
  002b3	83 c0 08	 add	 eax, 8
  002b6	3b ce		 cmp	 ecx, esi
  002b8	75 f3		 jne	 SHORT $LL2@EncryptBuf

; 194  : }

  002ba	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002bd	5f		 pop	 edi
  002be	33 cd		 xor	 ecx, ebp
  002c0	5e		 pop	 esi
  002c1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002c6	c9		 leave
  002c7	c2 18 00	 ret	 24			; 00000018H
$LN60@EncryptBuf:
_EncryptBufferXTSParallel@32 ENDP
_TEXT	ENDS
PUBLIC	_ks2$GSCopy$
PUBLIC	_ks$GSCopy$
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogsp
;	COMDAT _EncryptBufferXTSNonParallel@32
_TEXT	SEGMENT
_ks$GSCopy$ = -60					; size = 4
_ks2$GSCopy$ = -56					; size = 4
_dataUnitNo$ = -52					; size = 8
_endBlock$ = -44					; size = 4
_block$ = -40						; size = 4
_startBlock$ = -36					; size = 4
_blockCount$ = -32					; size = 8
_finalCarry$ = -21					; size = 1
_whiteningValue$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_length$ = 8						; size = 8
_startDataUnitNo$ = 16					; size = 4
_startCipherBlockNo$ = 20				; size = 4
_ks2$ = 24						; size = 4
_cipher$ = 28						; size = 4
_EncryptBufferXTSNonParallel@32 PROC			; COMDAT
; _buffer$ = edx
; _ks$ = ecx

; 205  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00012	8b 45 10	 mov	 eax, DWORD PTR _startDataUnitNo$[ebp]
  00015	89 4d c4	 mov	 DWORD PTR _ks$GSCopy$[ebp], ecx

; 206  : 	unsigned __int8 finalCarry;
; 207  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 208  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 209  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 210  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
; 211  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;

  00018	8b 4d 18	 mov	 ecx, DWORD PTR _ks2$[ebp]
  0001b	89 4d c8	 mov	 DWORD PTR _ks2$GSCopy$[ebp], ecx
  0001e	8b 4d 14	 mov	 ecx, DWORD PTR _startCipherBlockNo$[ebp]
  00021	89 4d dc	 mov	 DWORD PTR _startBlock$[ebp], ecx

; 212  : 	TC_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 213  : 
; 214  : 	/* The encrypted data unit number (i.e. the resultant ciphertext block) is to be multiplied in the
; 215  : 	finite field GF(2^128) by j-th power of n, where j is the sequential plaintext/ciphertext block
; 216  : 	number and n is 2, a primitive element of GF(2^128). This can be (and is) simplified and implemented
; 217  : 	as a left shift of the preceding whitening value by one bit (with carry propagating). In addition, if
; 218  : 	the shift of the highest byte results in a carry, 135 is XORed into the lowest byte. The value 135 is
; 219  : 	derived from the modulus of the Galois Field (x^128+x^7+x^2+x+1). */
; 220  : 
; 221  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 222  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 223  : 	dataUnitNo = startDataUnitNo->Value;

  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00029	57		 push	 edi
  0002a	8b fa		 mov	 edi, edx

; 224  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 225  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
; 226  : 
; 227  : 	if (length % BYTES_PER_XTS_BLOCK)

  0002c	8b 55 08	 mov	 edx, DWORD PTR _length$[ebp]
  0002f	89 45 d0	 mov	 DWORD PTR _dataUnitNo$[ebp+4], eax
  00032	8b c2		 mov	 eax, edx
  00034	89 4d cc	 mov	 DWORD PTR _dataUnitNo$[ebp], ecx
  00037	83 e0 0f	 and	 eax, 15			; 0000000fH
  0003a	33 c9		 xor	 ecx, ecx
  0003c	0b c1		 or	 eax, ecx
  0003e	74 14		 je	 SHORT $LN16@EncryptBuf@2

; 228  : 		TC_THROW_FATAL_EXCEPTION;

  00040	68 43 54 00 00	 push	 21571			; 00005443H
  00045	51		 push	 ecx
  00046	51		 push	 ecx
  00047	68 e4 00 00 00	 push	 228			; 000000e4H
  0004c	6a 29		 push	 41			; 00000029H
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN42@EncryptBuf@2:
$LN16@EncryptBuf@2:

; 229  : 
; 230  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  00054	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp+4]
  00057	0f ac c2 04	 shrd	 edx, eax, 4
  0005b	c1 e8 04	 shr	 eax, 4
  0005e	89 45 e4	 mov	 DWORD PTR _blockCount$[ebp+4], eax
  00061	89 55 e0	 mov	 DWORD PTR _blockCount$[ebp], edx

; 231  : 
; 232  : 	// Process all blocks in the buffer
; 233  : 	while (blockCount > 0)

  00064	3b c1		 cmp	 eax, ecx
  00066	77 08		 ja	 SHORT $LN31@EncryptBuf@2
  00068	3b d1		 cmp	 edx, ecx
  0006a	0f 86 44 01 00
	00		 jbe	 $LN5@EncryptBuf@2
$LN31@EncryptBuf@2:
  00070	53		 push	 ebx
  00071	56		 push	 esi
  00072	eb 03		 jmp	 SHORT $LN15@EncryptBuf@2
$LL34@EncryptBuf@2:
  00074	8b 45 e4	 mov	 eax, DWORD PTR _blockCount$[ebp+4]
$LN15@EncryptBuf@2:

; 234  : 	{
; 235  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  00077	85 c0		 test	 eax, eax
  00079	77 16		 ja	 SHORT $LN35@EncryptBuf@2
  0007b	72 06		 jb	 SHORT $LN38@EncryptBuf@2
  0007d	83 7d e0 20	 cmp	 DWORD PTR _blockCount$[ebp], 32 ; 00000020H
  00081	73 0e		 jae	 SHORT $LN35@EncryptBuf@2
$LN38@EncryptBuf@2:

; 236  : 			endBlock = startBlock + (unsigned int) blockCount;

  00083	8b 45 dc	 mov	 eax, DWORD PTR _startBlock$[ebp]
  00086	8b 4d e0	 mov	 ecx, DWORD PTR _blockCount$[ebp]
  00089	8d 1c 01	 lea	 ebx, DWORD PTR [ecx+eax]
  0008c	89 5d d4	 mov	 DWORD PTR _endBlock$[ebp], ebx

; 237  : 		else

  0008f	eb 0a		 jmp	 SHORT $LN12@EncryptBuf@2
$LN35@EncryptBuf@2:

; 238  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  00091	c7 45 d4 20 00
	00 00		 mov	 DWORD PTR _endBlock$[ebp], 32 ; 00000020H
  00098	8b 5d d4	 mov	 ebx, DWORD PTR _endBlock$[ebp]
$LN12@EncryptBuf@2:

; 239  : 
; 240  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 241  : 
; 242  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 243  : 		// whitening value for this data unit)
; 244  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  0009b	8b 45 cc	 mov	 eax, DWORD PTR _dataUnitNo$[ebp]

; 245  : 		*(whiteningValuePtr64 + 1) = 0;
; 246  : 		EncipherBlock (cipher, whiteningValue, ks2);

  0009e	ff 75 c8	 push	 DWORD PTR _ks2$GSCopy$[ebp]
  000a1	83 65 f4 00	 and	 DWORD PTR _whiteningValue$[ebp+8], 0
  000a5	83 65 f8 00	 and	 DWORD PTR _whiteningValue$[ebp+12], 0
  000a9	89 45 ec	 mov	 DWORD PTR _whiteningValue$[ebp], eax
  000ac	8b 45 d0	 mov	 eax, DWORD PTR _dataUnitNo$[ebp+4]
  000af	8d 75 ec	 lea	 esi, DWORD PTR _whiteningValue$[ebp]
  000b2	89 45 f0	 mov	 DWORD PTR _whiteningValue$[ebp+4], eax
  000b5	8b c6		 mov	 eax, esi
  000b7	50		 push	 eax
  000b8	ff 75 1c	 push	 DWORD PTR _cipher$[ebp]
  000bb	e8 00 00 00 00	 call	 _EncipherBlock@12

; 247  : 
; 248  : 		// Generate (and apply) subsequent whitening values for blocks in this data unit and
; 249  : 		// encrypt all relevant blocks in this data unit
; 250  : 		for (block = 0; block < endBlock; block++)

  000c0	33 c0		 xor	 eax, eax
  000c2	89 45 d8	 mov	 DWORD PTR _block$[ebp], eax
  000c5	3b d8		 cmp	 ebx, eax
  000c7	0f 86 bd 00 00
	00		 jbe	 $LN9@EncryptBuf@2
$LL36@EncryptBuf@2:

; 251  : 		{
; 252  : 			if (block >= startBlock)

  000cd	8b 45 d8	 mov	 eax, DWORD PTR _block$[ebp]
  000d0	3b 45 dc	 cmp	 eax, DWORD PTR _startBlock$[ebp]
  000d3	72 47		 jb	 SHORT $LN8@EncryptBuf@2

; 253  : 			{
; 254  : 				// Pre-whitening
; 255  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  000d5	8b 06		 mov	 eax, DWORD PTR [esi]
  000d7	31 07		 xor	 DWORD PTR [edi], eax
  000d9	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000dc	31 47 04	 xor	 DWORD PTR [edi+4], eax
  000df	6a 08		 push	 8
  000e1	5b		 pop	 ebx

; 256  : 				*bufPtr-- ^= *whiteningValuePtr64--;
; 257  : 
; 258  : 				// Actual encryption
; 259  : 				EncipherBlock (cipher, bufPtr, ks);

  000e2	ff 75 c4	 push	 DWORD PTR _ks$GSCopy$[ebp]
  000e5	03 f3		 add	 esi, ebx
  000e7	8b 06		 mov	 eax, DWORD PTR [esi]
  000e9	03 fb		 add	 edi, ebx
  000eb	31 07		 xor	 DWORD PTR [edi], eax
  000ed	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000f0	31 47 04	 xor	 DWORD PTR [edi+4], eax
  000f3	2b fb		 sub	 edi, ebx
  000f5	57		 push	 edi
  000f6	ff 75 1c	 push	 DWORD PTR _cipher$[ebp]
  000f9	2b f3		 sub	 esi, ebx
  000fb	e8 00 00 00 00	 call	 _EncipherBlock@12

; 260  : 
; 261  : 				// Post-whitening
; 262  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  00100	8b 06		 mov	 eax, DWORD PTR [esi]
  00102	31 07		 xor	 DWORD PTR [edi], eax
  00104	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00107	31 47 04	 xor	 DWORD PTR [edi+4], eax
  0010a	03 f3		 add	 esi, ebx

; 263  : 				*bufPtr++ ^= *whiteningValuePtr64;

  0010c	8b 06		 mov	 eax, DWORD PTR [esi]
  0010e	03 fb		 add	 edi, ebx
  00110	31 07		 xor	 DWORD PTR [edi], eax
  00112	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00115	31 47 04	 xor	 DWORD PTR [edi+4], eax
  00118	03 fb		 add	 edi, ebx

; 264  : 			}
; 265  : 			else

  0011a	eb 03		 jmp	 SHORT $LN7@EncryptBuf@2
$LN8@EncryptBuf@2:

; 266  : 				whiteningValuePtr64++;

  0011c	83 c6 08	 add	 esi, 8
$LN7@EncryptBuf@2:

; 267  : 
; 268  : 			// Derive the next whitening value
; 269  : 
; 270  : #if BYTE_ORDER == LITTLE_ENDIAN
; 271  : 
; 272  : 			// Little-endian platforms
; 273  : 
; 274  : 			finalCarry = 
; 275  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 276  : 				135 : 0;

  0011f	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00122	8b 06		 mov	 eax, DWORD PTR [esi]
  00124	8b da		 mov	 ebx, edx
  00126	81 e3 00 00 00
	80		 and	 ebx, -2147483648	; 80000000H
  0012c	33 c9		 xor	 ecx, ecx
  0012e	0b cb		 or	 ecx, ebx
  00130	c6 45 eb 87	 mov	 BYTE PTR _finalCarry$[ebp], 135 ; 00000087H
  00134	75 04		 jne	 SHORT $LN20@EncryptBuf@2
  00136	c6 45 eb 00	 mov	 BYTE PTR _finalCarry$[ebp], 0
$LN20@EncryptBuf@2:

; 277  : 
; 278  : 			*whiteningValuePtr64-- <<= 1;

  0013a	0f a4 c2 01	 shld	 edx, eax, 1
  0013e	03 c0		 add	 eax, eax
  00140	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00143	89 06		 mov	 DWORD PTR [esi], eax

; 279  : 
; 280  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  00145	8b 5e fc	 mov	 ebx, DWORD PTR [esi-4]
  00148	83 ee 08	 sub	 esi, 8
  0014b	8b 06		 mov	 eax, DWORD PTR [esi]
  0014d	8b d3		 mov	 edx, ebx
  0014f	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H
  00155	33 c9		 xor	 ecx, ecx
  00157	0b ca		 or	 ecx, edx
  00159	74 0a		 je	 SHORT $LN6@EncryptBuf@2

; 281  : 				*(whiteningValuePtr64 + 1) |= 1;	

  0015b	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0015e	83 4e 08 01	 or	 DWORD PTR [esi+8], 1
  00162	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
$LN6@EncryptBuf@2:

; 282  : 
; 283  : 			*whiteningValuePtr64 <<= 1;

  00165	0f a4 c3 01	 shld	 ebx, eax, 1
  00169	03 c0		 add	 eax, eax
  0016b	89 06		 mov	 DWORD PTR [esi], eax

; 284  : #else
; 285  : 
; 286  : 			// Big-endian platforms
; 287  : 
; 288  : 			finalCarry = 
; 289  : 				(*whiteningValuePtr64 & 0x80) ?
; 290  : 				135 : 0;
; 291  : 
; 292  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 293  : 
; 294  : 			whiteningValuePtr64--;
; 295  : 
; 296  : 			if (*whiteningValuePtr64 & 0x80)
; 297  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 298  : 
; 299  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 300  : #endif
; 301  : 
; 302  : 			whiteningValue[0] ^= finalCarry;

  0016d	8a 45 eb	 mov	 al, BYTE PTR _finalCarry$[ebp]
  00170	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  00173	30 45 ec	 xor	 BYTE PTR _whiteningValue$[ebp], al
  00176	ff 45 d8	 inc	 DWORD PTR _block$[ebp]
  00179	8b 45 d8	 mov	 eax, DWORD PTR _block$[ebp]
  0017c	3b 45 d4	 cmp	 eax, DWORD PTR _endBlock$[ebp]
  0017f	0f 82 48 ff ff
	ff		 jb	 $LL36@EncryptBuf@2
  00185	8b 5d d4	 mov	 ebx, DWORD PTR _endBlock$[ebp]
  00188	33 c0		 xor	 eax, eax
$LN9@EncryptBuf@2:

; 303  : 		}
; 304  : 
; 305  : 		blockCount -= endBlock - startBlock;

  0018a	2b 5d dc	 sub	 ebx, DWORD PTR _startBlock$[ebp]

; 306  : 		startBlock = 0;

  0018d	89 45 dc	 mov	 DWORD PTR _startBlock$[ebp], eax
  00190	29 5d e0	 sub	 DWORD PTR _blockCount$[ebp], ebx
  00193	19 45 e4	 sbb	 DWORD PTR _blockCount$[ebp+4], eax

; 307  : 		dataUnitNo++;

  00196	83 45 cc 01	 add	 DWORD PTR _dataUnitNo$[ebp], 1
  0019a	11 45 d0	 adc	 DWORD PTR _dataUnitNo$[ebp+4], eax
  0019d	39 45 e4	 cmp	 DWORD PTR _blockCount$[ebp+4], eax
  001a0	0f 87 ce fe ff
	ff		 ja	 $LL34@EncryptBuf@2

; 231  : 
; 232  : 	// Process all blocks in the buffer
; 233  : 	while (blockCount > 0)

  001a6	72 0a		 jb	 SHORT $LN39@EncryptBuf@2
  001a8	83 7d e0 00	 cmp	 DWORD PTR _blockCount$[ebp], 0
  001ac	0f 87 c2 fe ff
	ff		 ja	 $LL34@EncryptBuf@2
$LN39@EncryptBuf@2:
  001b2	5e		 pop	 esi
  001b3	5b		 pop	 ebx
$LN5@EncryptBuf@2:

; 308  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 309  : 	}
; 310  : 
; 311  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  001b4	6a 02		 push	 2
  001b6	59		 pop	 ecx
  001b7	8d 45 ec	 lea	 eax, DWORD PTR _whiteningValue$[ebp]
  001ba	5f		 pop	 edi
$LL2@EncryptBuf@2:
  001bb	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  001c1	49		 dec	 ecx
  001c2	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  001c9	83 c0 08	 add	 eax, 8
  001cc	85 c9		 test	 ecx, ecx
  001ce	75 eb		 jne	 SHORT $LL2@EncryptBuf@2

; 312  : }

  001d0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d3	33 cd		 xor	 ecx, ebp
  001d5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001da	c9		 leave
  001db	c2 18 00	 ret	 24			; 00000018H
$LN41@EncryptBuf@2:
_EncryptBufferXTSNonParallel@32 ENDP
_TEXT	ENDS
PUBLIC	_ks2$GSCopy$
PUBLIC	_ks$GSCopy$
PUBLIC	__$ArrayPad$
EXTRN	_DecipherBlocks@16:PROC
; Function compile flags: /Ogsp
;	COMDAT _DecryptBufferXTSParallel@32
_TEXT	SEGMENT
_ks$GSCopy$ = -576					; size = 4
_ks2$GSCopy$ = -572					; size = 4
_dataUnitNo$ = -568					; size = 8
_startBlock$ = -560					; size = 4
_block$ = -556						; size = 4
_blockCount$ = -552					; size = 8
_dataUnitBufPtr$ = -544					; size = 4
_whiteningValuesPtr64$ = -544				; size = 4
_endBlock$ = -540					; size = 4
_finalCarry$ = -533					; size = 1
_whiteningValues$ = -532				; size = 512
_whiteningValue$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_length$ = 8						; size = 8
_startDataUnitNo$ = 16					; size = 4
_startCipherBlockNo$ = 20				; size = 4
_ks2$ = 24						; size = 4
_cipher$ = 28						; size = 4
_DecryptBufferXTSParallel@32 PROC			; COMDAT
; _buffer$ = edx
; _ks$ = ecx

; 339  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 40 02 00
	00		 sub	 esp, 576		; 00000240H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	8b 45 10	 mov	 eax, DWORD PTR _startDataUnitNo$[ebp]
  00018	89 8d c0 fd ff
	ff		 mov	 DWORD PTR _ks$GSCopy$[ebp], ecx

; 340  : 	unsigned __int8 finalCarry;
; 341  : 	unsigned __int8 whiteningValues [ENCRYPTION_DATA_UNIT_SIZE];
; 342  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 343  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 344  : 	unsigned __int64 *whiteningValuesPtr64 = (unsigned __int64 *) whiteningValues;
; 345  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 346  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
; 347  : 	unsigned __int64 *dataUnitBufPtr;
; 348  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;

  0001e	8b 4d 18	 mov	 ecx, DWORD PTR _ks2$[ebp]
  00021	89 8d c4 fd ff
	ff		 mov	 DWORD PTR _ks2$GSCopy$[ebp], ecx
  00027	8b 4d 14	 mov	 ecx, DWORD PTR _startCipherBlockNo$[ebp]
  0002a	56		 push	 esi
  0002b	89 8d d0 fd ff
	ff		 mov	 DWORD PTR _startBlock$[ebp], ecx

; 349  : 	unsigned __int64 *const finalInt64WhiteningValuesPtr = whiteningValuesPtr64 + sizeof (whiteningValues) / sizeof (*whiteningValuesPtr64) - 1;
; 350  : 	TC_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 351  : 
; 352  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 353  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 354  : 	dataUnitNo = startDataUnitNo->Value;

  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00036	57		 push	 edi
  00037	8b fa		 mov	 edi, edx

; 355  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 356  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
; 357  : 
; 358  : 	if (length % BYTES_PER_XTS_BLOCK)

  00039	8b 55 08	 mov	 edx, DWORD PTR _length$[ebp]
  0003c	89 85 cc fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp+4], eax
  00042	8b c2		 mov	 eax, edx
  00044	89 8d c8 fd ff
	ff		 mov	 DWORD PTR _dataUnitNo$[ebp], ecx
  0004a	83 e0 0f	 and	 eax, 15			; 0000000fH
  0004d	33 c9		 xor	 ecx, ecx
  0004f	33 f6		 xor	 esi, esi
  00051	0b c1		 or	 eax, ecx
  00053	74 14		 je	 SHORT $LN27@DecryptBuf

; 359  : 		TC_THROW_FATAL_EXCEPTION;

  00055	68 43 54 00 00	 push	 21571			; 00005443H
  0005a	56		 push	 esi
  0005b	56		 push	 esi
  0005c	68 67 01 00 00	 push	 359			; 00000167H
  00061	6a 29		 push	 41			; 00000029H
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN61@DecryptBuf:
$LN27@DecryptBuf:

; 360  : 
; 361  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  00069	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp+4]
  0006c	0f ac c2 04	 shrd	 edx, eax, 4
  00070	c1 e8 04	 shr	 eax, 4
  00073	89 85 dc fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp+4], eax
  00079	89 95 d8 fd ff
	ff		 mov	 DWORD PTR _blockCount$[ebp], edx

; 362  : 
; 363  : 	// Process all blocks in the buffer
; 364  : 	while (blockCount > 0)

  0007f	3b c6		 cmp	 eax, esi
  00081	77 08		 ja	 SHORT $LN49@DecryptBuf
  00083	3b d6		 cmp	 edx, esi
  00085	0f 86 09 02 00
	00		 jbe	 $LN10@DecryptBuf
$LN49@DecryptBuf:
  0008b	53		 push	 ebx
  0008c	eb 08		 jmp	 SHORT $LN26@DecryptBuf
$LL55@DecryptBuf:
  0008e	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _blockCount$[ebp+4]
  00094	33 f6		 xor	 esi, esi
$LN26@DecryptBuf:

; 365  : 	{
; 366  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  00096	3b c6		 cmp	 eax, esi
  00098	77 21		 ja	 SHORT $LN56@DecryptBuf
  0009a	72 09		 jb	 SHORT $LN59@DecryptBuf
  0009c	83 bd d8 fd ff
	ff 20		 cmp	 DWORD PTR _blockCount$[ebp], 32 ; 00000020H
  000a3	73 16		 jae	 SHORT $LN56@DecryptBuf
$LN59@DecryptBuf:

; 367  : 			endBlock = startBlock + (unsigned int) blockCount;

  000a5	8b 85 d0 fd ff
	ff		 mov	 eax, DWORD PTR _startBlock$[ebp]
  000ab	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _blockCount$[ebp]
  000b1	03 c8		 add	 ecx, eax
  000b3	89 8d e4 fd ff
	ff		 mov	 DWORD PTR _endBlock$[ebp], ecx

; 368  : 		else

  000b9	eb 0a		 jmp	 SHORT $LN23@DecryptBuf
$LN56@DecryptBuf:

; 369  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  000bb	c7 85 e4 fd ff
	ff 20 00 00 00	 mov	 DWORD PTR _endBlock$[ebp], 32 ; 00000020H
$LN23@DecryptBuf:

; 370  : 
; 371  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
; 372  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 373  : 
; 374  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 375  : 		// whitening value for this data unit)
; 376  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  000c5	8b 85 c8 fd ff
	ff		 mov	 eax, DWORD PTR _dataUnitNo$[ebp]

; 377  : 		*(whiteningValuePtr64 + 1) = 0;
; 378  : 		EncipherBlock (cipher, whiteningValue, ks2);

  000cb	ff b5 c4 fd ff
	ff		 push	 DWORD PTR _ks2$GSCopy$[ebp]
  000d1	83 65 f4 00	 and	 DWORD PTR _whiteningValue$[ebp+8], 0
  000d5	83 65 f8 00	 and	 DWORD PTR _whiteningValue$[ebp+12], 0
  000d9	89 45 ec	 mov	 DWORD PTR _whiteningValue$[ebp], eax
  000dc	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _dataUnitNo$[ebp+4]
  000e2	8d 75 ec	 lea	 esi, DWORD PTR _whiteningValue$[ebp]
  000e5	89 45 f0	 mov	 DWORD PTR _whiteningValue$[ebp+4], eax
  000e8	8b c6		 mov	 eax, esi
  000ea	50		 push	 eax
  000eb	ff 75 1c	 push	 DWORD PTR _cipher$[ebp]
  000ee	8d 5d e4	 lea	 ebx, DWORD PTR _whiteningValues$[ebp+504]
  000f1	89 9d e0 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], ebx
  000f7	e8 00 00 00 00	 call	 _EncipherBlock@12

; 379  : 
; 380  : 		// Generate subsequent whitening values for blocks in this data unit. Note that all generated 128-bit
; 381  : 		// whitening values are stored in memory as a sequence of 64-bit integers in reverse order.
; 382  : 		for (block = 0; block < endBlock; block++)

  000fc	83 a5 d4 fd ff
	ff 00		 and	 DWORD PTR _block$[ebp], 0
  00103	83 bd e4 fd ff
	ff 00		 cmp	 DWORD PTR _endBlock$[ebp], 0
  0010a	0f 86 b6 00 00
	00		 jbe	 $LN20@DecryptBuf
  00110	eb 06		 jmp	 SHORT $LN22@DecryptBuf
$LL57@DecryptBuf:
  00112	8b 9d e0 fd ff
	ff		 mov	 ebx, DWORD PTR _whiteningValuesPtr64$[ebp]
$LN22@DecryptBuf:

; 383  : 		{
; 384  : 			if (block >= startBlock)

  00118	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _block$[ebp]
  0011e	3b 85 d0 fd ff
	ff		 cmp	 eax, DWORD PTR _startBlock$[ebp]
  00124	72 25		 jb	 SHORT $LN19@DecryptBuf

; 385  : 			{
; 386  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64++;

  00126	8b 06		 mov	 eax, DWORD PTR [esi]
  00128	89 03		 mov	 DWORD PTR [ebx], eax
  0012a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0012d	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00130	83 c6 08	 add	 esi, 8

; 387  : 				*whiteningValuesPtr64-- = *whiteningValuePtr64;

  00133	8b 06		 mov	 eax, DWORD PTR [esi]
  00135	83 eb 08	 sub	 ebx, 8
  00138	89 03		 mov	 DWORD PTR [ebx], eax
  0013a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0013d	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00140	83 eb 08	 sub	 ebx, 8
  00143	89 9d e0 fd ff
	ff		 mov	 DWORD PTR _whiteningValuesPtr64$[ebp], ebx

; 388  : 			}
; 389  : 			else

  00149	eb 03		 jmp	 SHORT $LN18@DecryptBuf
$LN19@DecryptBuf:

; 390  : 				whiteningValuePtr64++;

  0014b	83 c6 08	 add	 esi, 8
$LN18@DecryptBuf:

; 391  : 
; 392  : 			// Derive the next whitening value
; 393  : 
; 394  : #if BYTE_ORDER == LITTLE_ENDIAN
; 395  : 
; 396  : 			// Little-endian platforms
; 397  : 
; 398  : 			finalCarry = 
; 399  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 400  : 				135 : 0;

  0014e	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00151	8b 06		 mov	 eax, DWORD PTR [esi]
  00153	8b da		 mov	 ebx, edx
  00155	81 e3 00 00 00
	80		 and	 ebx, -2147483648	; 80000000H
  0015b	33 c9		 xor	 ecx, ecx
  0015d	0b cb		 or	 ecx, ebx
  0015f	c6 85 eb fd ff
	ff 87		 mov	 BYTE PTR _finalCarry$[ebp], 135 ; 00000087H
  00166	75 07		 jne	 SHORT $LN31@DecryptBuf
  00168	c6 85 eb fd ff
	ff 00		 mov	 BYTE PTR _finalCarry$[ebp], 0
$LN31@DecryptBuf:

; 401  : 
; 402  : 			*whiteningValuePtr64-- <<= 1;

  0016f	0f a4 c2 01	 shld	 edx, eax, 1
  00173	03 c0		 add	 eax, eax
  00175	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00178	89 06		 mov	 DWORD PTR [esi], eax

; 403  : 
; 404  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  0017a	8b 5e fc	 mov	 ebx, DWORD PTR [esi-4]
  0017d	83 ee 08	 sub	 esi, 8
  00180	8b 06		 mov	 eax, DWORD PTR [esi]
  00182	8b d3		 mov	 edx, ebx
  00184	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H
  0018a	33 c9		 xor	 ecx, ecx
  0018c	0b ca		 or	 ecx, edx
  0018e	74 0a		 je	 SHORT $LN17@DecryptBuf

; 405  : 				*(whiteningValuePtr64 + 1) |= 1;	

  00190	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00193	83 4e 08 01	 or	 DWORD PTR [esi+8], 1
  00197	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
$LN17@DecryptBuf:

; 406  : 
; 407  : 			*whiteningValuePtr64 <<= 1;

  0019a	0f a4 c3 01	 shld	 ebx, eax, 1
  0019e	03 c0		 add	 eax, eax
  001a0	89 06		 mov	 DWORD PTR [esi], eax

; 408  : 
; 409  : #else
; 410  : 			// Big-endian platforms
; 411  : 
; 412  : 			finalCarry = 
; 413  : 				(*whiteningValuePtr64 & 0x80) ?
; 414  : 				135 : 0;
; 415  : 
; 416  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 417  : 
; 418  : 			whiteningValuePtr64--;
; 419  : 
; 420  : 			if (*whiteningValuePtr64 & 0x80)
; 421  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 422  : 
; 423  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 424  : #endif
; 425  : 
; 426  : 			whiteningValue[0] ^= finalCarry;

  001a2	8a 85 eb fd ff
	ff		 mov	 al, BYTE PTR _finalCarry$[ebp]
  001a8	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  001ab	30 45 ec	 xor	 BYTE PTR _whiteningValue$[ebp], al
  001ae	ff 85 d4 fd ff
	ff		 inc	 DWORD PTR _block$[ebp]
  001b4	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _block$[ebp]
  001ba	3b 85 e4 fd ff
	ff		 cmp	 eax, DWORD PTR _endBlock$[ebp]
  001c0	0f 82 4c ff ff
	ff		 jb	 $LL57@DecryptBuf
$LN20@DecryptBuf:

; 430  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
; 431  : 
; 432  : 		// Decrypt blocks in this data unit
; 433  : 
; 434  : 		for (block = startBlock; block < endBlock; block++)

  001c6	8b 9d d0 fd ff
	ff		 mov	 ebx, DWORD PTR _startBlock$[ebp]
  001cc	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR _endBlock$[ebp]
  001d2	89 bd e0 fd ff
	ff		 mov	 DWORD PTR _dataUnitBufPtr$[ebp], edi
  001d8	8d 45 e4	 lea	 eax, DWORD PTR _whiteningValues$[ebp+504]
  001db	3b d9		 cmp	 ebx, ecx
  001dd	73 24		 jae	 SHORT $LN14@DecryptBuf

; 427  : 		}
; 428  : 
; 429  : 		dataUnitBufPtr = bufPtr;

  001df	2b cb		 sub	 ecx, ebx
$LL16@DecryptBuf:

; 435  : 		{
; 436  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  001e1	8b 10		 mov	 edx, DWORD PTR [eax]
  001e3	31 17		 xor	 DWORD PTR [edi], edx
  001e5	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001e8	31 57 04	 xor	 DWORD PTR [edi+4], edx
  001eb	6a 08		 push	 8
  001ed	5a		 pop	 edx
  001ee	2b c2		 sub	 eax, edx

; 437  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  001f0	8b 30		 mov	 esi, DWORD PTR [eax]
  001f2	03 fa		 add	 edi, edx
  001f4	31 37		 xor	 DWORD PTR [edi], esi
  001f6	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  001f9	31 77 04	 xor	 DWORD PTR [edi+4], esi
  001fc	2b c2		 sub	 eax, edx
  001fe	03 fa		 add	 edi, edx
  00200	49		 dec	 ecx
  00201	75 de		 jne	 SHORT $LL16@DecryptBuf
$LN14@DecryptBuf:

; 438  : 		}
; 439  : 
; 440  : 		DecipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);

  00203	8b b5 e4 fd ff
	ff		 mov	 esi, DWORD PTR _endBlock$[ebp]
  00209	2b f3		 sub	 esi, ebx
  0020b	56		 push	 esi
  0020c	ff b5 c0 fd ff
	ff		 push	 DWORD PTR _ks$GSCopy$[ebp]
  00212	ff b5 e0 fd ff
	ff		 push	 DWORD PTR _dataUnitBufPtr$[ebp]
  00218	ff 75 1c	 push	 DWORD PTR _cipher$[ebp]
  0021b	e8 00 00 00 00	 call	 _DecipherBlocks@16

; 441  : 
; 442  : 		bufPtr = dataUnitBufPtr;

  00220	8b bd e0 fd ff
	ff		 mov	 edi, DWORD PTR _dataUnitBufPtr$[ebp]

; 443  : 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;

  00226	8d 45 e4	 lea	 eax, DWORD PTR _whiteningValues$[ebp+504]

; 444  : 
; 445  : 		for (block = startBlock; block < endBlock; block++)

  00229	3b 9d e4 fd ff
	ff		 cmp	 ebx, DWORD PTR _endBlock$[ebp]
  0022f	73 24		 jae	 SHORT $LN11@DecryptBuf

; 438  : 		}
; 439  : 
; 440  : 		DecipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);

  00231	8b d6		 mov	 edx, esi
$LL13@DecryptBuf:

; 446  : 		{
; 447  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00233	8b 08		 mov	 ecx, DWORD PTR [eax]
  00235	31 0f		 xor	 DWORD PTR [edi], ecx
  00237	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0023a	31 4f 04	 xor	 DWORD PTR [edi+4], ecx
  0023d	6a 08		 push	 8
  0023f	59		 pop	 ecx
  00240	2b c1		 sub	 eax, ecx

; 448  : 			*bufPtr++ ^= *whiteningValuesPtr64--;

  00242	8b 18		 mov	 ebx, DWORD PTR [eax]
  00244	03 f9		 add	 edi, ecx
  00246	31 1f		 xor	 DWORD PTR [edi], ebx
  00248	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  0024b	31 5f 04	 xor	 DWORD PTR [edi+4], ebx
  0024e	2b c1		 sub	 eax, ecx
  00250	03 f9		 add	 edi, ecx
  00252	4a		 dec	 edx
  00253	75 de		 jne	 SHORT $LL13@DecryptBuf
$LN11@DecryptBuf:

; 449  : 		}
; 450  : 
; 451  : 		blockCount -= endBlock - startBlock;

  00255	29 b5 d8 fd ff
	ff		 sub	 DWORD PTR _blockCount$[ebp], esi
  0025b	6a 00		 push	 0
  0025d	58		 pop	 eax
  0025e	19 85 dc fd ff
	ff		 sbb	 DWORD PTR _blockCount$[ebp+4], eax

; 452  : 		startBlock = 0;
; 453  : 		dataUnitNo++;

  00264	83 85 c8 fd ff
	ff 01		 add	 DWORD PTR _dataUnitNo$[ebp], 1
  0026b	89 85 d0 fd ff
	ff		 mov	 DWORD PTR _startBlock$[ebp], eax
  00271	11 85 cc fd ff
	ff		 adc	 DWORD PTR _dataUnitNo$[ebp+4], eax
  00277	39 85 dc fd ff
	ff		 cmp	 DWORD PTR _blockCount$[ebp+4], eax
  0027d	0f 87 0b fe ff
	ff		 ja	 $LL55@DecryptBuf

; 362  : 
; 363  : 	// Process all blocks in the buffer
; 364  : 	while (blockCount > 0)

  00283	72 0c		 jb	 SHORT $LN58@DecryptBuf
  00285	39 85 d8 fd ff
	ff		 cmp	 DWORD PTR _blockCount$[ebp], eax
  0028b	0f 87 fd fd ff
	ff		 ja	 $LL55@DecryptBuf
$LN58@DecryptBuf:
  00291	33 f6		 xor	 esi, esi
  00293	5b		 pop	 ebx
$LN10@DecryptBuf:

; 454  : 
; 455  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 456  : 	}
; 457  : 
; 458  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  00294	6a 02		 push	 2
  00296	8d 45 ec	 lea	 eax, DWORD PTR _whiteningValue$[ebp]
  00299	59		 pop	 ecx
$LL7@DecryptBuf:
  0029a	89 30		 mov	 DWORD PTR [eax], esi
  0029c	49		 dec	 ecx
  0029d	89 70 04	 mov	 DWORD PTR [eax+4], esi
  002a0	83 c0 08	 add	 eax, 8
  002a3	3b ce		 cmp	 ecx, esi
  002a5	75 f3		 jne	 SHORT $LL7@DecryptBuf

; 459  : 	FAST_ERASE64 (whiteningValues, sizeof (whiteningValues));

  002a7	6a 40		 push	 64			; 00000040H
  002a9	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _whiteningValues$[ebp]
  002af	59		 pop	 ecx
$LL2@DecryptBuf:
  002b0	89 30		 mov	 DWORD PTR [eax], esi
  002b2	49		 dec	 ecx
  002b3	89 70 04	 mov	 DWORD PTR [eax+4], esi
  002b6	83 c0 08	 add	 eax, 8
  002b9	3b ce		 cmp	 ecx, esi
  002bb	75 f3		 jne	 SHORT $LL2@DecryptBuf

; 460  : }

  002bd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002c0	5f		 pop	 edi
  002c1	33 cd		 xor	 ecx, ebp
  002c3	5e		 pop	 esi
  002c4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002c9	c9		 leave
  002ca	c2 18 00	 ret	 24			; 00000018H
$LN60@DecryptBuf:
_DecryptBufferXTSParallel@32 ENDP
_TEXT	ENDS
PUBLIC	_ks2$GSCopy$
PUBLIC	_ks$GSCopy$
PUBLIC	__$ArrayPad$
EXTRN	_DecipherBlock@12:PROC
; Function compile flags: /Ogsp
;	COMDAT _DecryptBufferXTSNonParallel@32
_TEXT	SEGMENT
_ks$GSCopy$ = -60					; size = 4
_ks2$GSCopy$ = -56					; size = 4
_dataUnitNo$ = -52					; size = 8
_endBlock$ = -44					; size = 4
_block$ = -40						; size = 4
_startBlock$ = -36					; size = 4
_blockCount$ = -32					; size = 8
_finalCarry$ = -21					; size = 1
_whiteningValue$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_length$ = 8						; size = 8
_startDataUnitNo$ = 16					; size = 4
_startCipherBlockNo$ = 20				; size = 4
_ks2$ = 24						; size = 4
_cipher$ = 28						; size = 4
_DecryptBufferXTSNonParallel@32 PROC			; COMDAT
; _buffer$ = edx
; _ks$ = ecx

; 471  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00012	8b 45 10	 mov	 eax, DWORD PTR _startDataUnitNo$[ebp]
  00015	89 4d c4	 mov	 DWORD PTR _ks$GSCopy$[ebp], ecx

; 472  : 	unsigned __int8 finalCarry;
; 473  : 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
; 474  : 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
; 475  : 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 476  : 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
; 477  : 	unsigned int startBlock = startCipherBlockNo, endBlock, block;

  00018	8b 4d 18	 mov	 ecx, DWORD PTR _ks2$[ebp]
  0001b	89 4d c8	 mov	 DWORD PTR _ks2$GSCopy$[ebp], ecx
  0001e	8b 4d 14	 mov	 ecx, DWORD PTR _startCipherBlockNo$[ebp]
  00021	89 4d dc	 mov	 DWORD PTR _startBlock$[ebp], ecx

; 478  : 	TC_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
; 479  : 
; 480  : 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
; 481  : 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
; 482  : 	dataUnitNo = startDataUnitNo->Value;

  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00029	57		 push	 edi
  0002a	8b fa		 mov	 edi, edx

; 483  : 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 484  : 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
; 485  : 
; 486  : 	if (length % BYTES_PER_XTS_BLOCK)

  0002c	8b 55 08	 mov	 edx, DWORD PTR _length$[ebp]
  0002f	89 45 d0	 mov	 DWORD PTR _dataUnitNo$[ebp+4], eax
  00032	8b c2		 mov	 eax, edx
  00034	89 4d cc	 mov	 DWORD PTR _dataUnitNo$[ebp], ecx
  00037	83 e0 0f	 and	 eax, 15			; 0000000fH
  0003a	33 c9		 xor	 ecx, ecx
  0003c	0b c1		 or	 eax, ecx
  0003e	74 14		 je	 SHORT $LN16@DecryptBuf@2

; 487  : 		TC_THROW_FATAL_EXCEPTION;

  00040	68 43 54 00 00	 push	 21571			; 00005443H
  00045	51		 push	 ecx
  00046	51		 push	 ecx
  00047	68 e7 01 00 00	 push	 487			; 000001e7H
  0004c	6a 29		 push	 41			; 00000029H
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN42@DecryptBuf@2:
$LN16@DecryptBuf@2:

; 488  : 
; 489  : 	blockCount = length / BYTES_PER_XTS_BLOCK;

  00054	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp+4]
  00057	0f ac c2 04	 shrd	 edx, eax, 4
  0005b	c1 e8 04	 shr	 eax, 4
  0005e	89 45 e4	 mov	 DWORD PTR _blockCount$[ebp+4], eax
  00061	89 55 e0	 mov	 DWORD PTR _blockCount$[ebp], edx

; 490  : 
; 491  : 	// Process all blocks in the buffer
; 492  : 	while (blockCount > 0)

  00064	3b c1		 cmp	 eax, ecx
  00066	77 08		 ja	 SHORT $LN31@DecryptBuf@2
  00068	3b d1		 cmp	 edx, ecx
  0006a	0f 86 44 01 00
	00		 jbe	 $LN5@DecryptBuf@2
$LN31@DecryptBuf@2:
  00070	53		 push	 ebx
  00071	56		 push	 esi
  00072	eb 03		 jmp	 SHORT $LN15@DecryptBuf@2
$LL34@DecryptBuf@2:
  00074	8b 45 e4	 mov	 eax, DWORD PTR _blockCount$[ebp+4]
$LN15@DecryptBuf@2:

; 493  : 	{
; 494  : 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)

  00077	85 c0		 test	 eax, eax
  00079	77 16		 ja	 SHORT $LN35@DecryptBuf@2
  0007b	72 06		 jb	 SHORT $LN38@DecryptBuf@2
  0007d	83 7d e0 20	 cmp	 DWORD PTR _blockCount$[ebp], 32 ; 00000020H
  00081	73 0e		 jae	 SHORT $LN35@DecryptBuf@2
$LN38@DecryptBuf@2:

; 495  : 			endBlock = startBlock + (unsigned int) blockCount;

  00083	8b 45 dc	 mov	 eax, DWORD PTR _startBlock$[ebp]
  00086	8b 4d e0	 mov	 ecx, DWORD PTR _blockCount$[ebp]
  00089	8d 1c 01	 lea	 ebx, DWORD PTR [ecx+eax]
  0008c	89 5d d4	 mov	 DWORD PTR _endBlock$[ebp], ebx

; 496  : 		else

  0008f	eb 0a		 jmp	 SHORT $LN12@DecryptBuf@2
$LN35@DecryptBuf@2:

; 497  : 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;

  00091	c7 45 d4 20 00
	00 00		 mov	 DWORD PTR _endBlock$[ebp], 32 ; 00000020H
  00098	8b 5d d4	 mov	 ebx, DWORD PTR _endBlock$[ebp]
$LN12@DecryptBuf@2:

; 498  : 
; 499  : 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
; 500  : 
; 501  : 		// Encrypt the data unit number using the secondary key (in order to generate the first 
; 502  : 		// whitening value for this data unit)
; 503  : 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);

  0009b	8b 45 cc	 mov	 eax, DWORD PTR _dataUnitNo$[ebp]

; 504  : 		*(whiteningValuePtr64 + 1) = 0;
; 505  : 		EncipherBlock (cipher, whiteningValue, ks2);

  0009e	ff 75 c8	 push	 DWORD PTR _ks2$GSCopy$[ebp]
  000a1	83 65 f4 00	 and	 DWORD PTR _whiteningValue$[ebp+8], 0
  000a5	83 65 f8 00	 and	 DWORD PTR _whiteningValue$[ebp+12], 0
  000a9	89 45 ec	 mov	 DWORD PTR _whiteningValue$[ebp], eax
  000ac	8b 45 d0	 mov	 eax, DWORD PTR _dataUnitNo$[ebp+4]
  000af	8d 75 ec	 lea	 esi, DWORD PTR _whiteningValue$[ebp]
  000b2	89 45 f0	 mov	 DWORD PTR _whiteningValue$[ebp+4], eax
  000b5	8b c6		 mov	 eax, esi
  000b7	50		 push	 eax
  000b8	ff 75 1c	 push	 DWORD PTR _cipher$[ebp]
  000bb	e8 00 00 00 00	 call	 _EncipherBlock@12

; 506  : 
; 507  : 		// Generate (and apply) subsequent whitening values for blocks in this data unit and
; 508  : 		// decrypt all relevant blocks in this data unit
; 509  : 		for (block = 0; block < endBlock; block++)

  000c0	33 c0		 xor	 eax, eax
  000c2	89 45 d8	 mov	 DWORD PTR _block$[ebp], eax
  000c5	3b d8		 cmp	 ebx, eax
  000c7	0f 86 bd 00 00
	00		 jbe	 $LN9@DecryptBuf@2
$LL36@DecryptBuf@2:

; 510  : 		{
; 511  : 			if (block >= startBlock)

  000cd	8b 45 d8	 mov	 eax, DWORD PTR _block$[ebp]
  000d0	3b 45 dc	 cmp	 eax, DWORD PTR _startBlock$[ebp]
  000d3	72 47		 jb	 SHORT $LN8@DecryptBuf@2

; 512  : 			{
; 513  : 				// Post-whitening
; 514  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  000d5	8b 06		 mov	 eax, DWORD PTR [esi]
  000d7	31 07		 xor	 DWORD PTR [edi], eax
  000d9	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000dc	31 47 04	 xor	 DWORD PTR [edi+4], eax
  000df	6a 08		 push	 8
  000e1	5b		 pop	 ebx

; 515  : 				*bufPtr-- ^= *whiteningValuePtr64--;
; 516  : 
; 517  : 				// Actual decryption
; 518  : 				DecipherBlock (cipher, bufPtr, ks);

  000e2	ff 75 c4	 push	 DWORD PTR _ks$GSCopy$[ebp]
  000e5	03 f3		 add	 esi, ebx
  000e7	8b 06		 mov	 eax, DWORD PTR [esi]
  000e9	03 fb		 add	 edi, ebx
  000eb	31 07		 xor	 DWORD PTR [edi], eax
  000ed	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000f0	31 47 04	 xor	 DWORD PTR [edi+4], eax
  000f3	2b fb		 sub	 edi, ebx
  000f5	57		 push	 edi
  000f6	ff 75 1c	 push	 DWORD PTR _cipher$[ebp]
  000f9	2b f3		 sub	 esi, ebx
  000fb	e8 00 00 00 00	 call	 _DecipherBlock@12

; 519  : 
; 520  : 				// Pre-whitening
; 521  : 				*bufPtr++ ^= *whiteningValuePtr64++;

  00100	8b 06		 mov	 eax, DWORD PTR [esi]
  00102	31 07		 xor	 DWORD PTR [edi], eax
  00104	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00107	31 47 04	 xor	 DWORD PTR [edi+4], eax
  0010a	03 f3		 add	 esi, ebx

; 522  : 				*bufPtr++ ^= *whiteningValuePtr64;

  0010c	8b 06		 mov	 eax, DWORD PTR [esi]
  0010e	03 fb		 add	 edi, ebx
  00110	31 07		 xor	 DWORD PTR [edi], eax
  00112	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00115	31 47 04	 xor	 DWORD PTR [edi+4], eax
  00118	03 fb		 add	 edi, ebx

; 523  : 			}
; 524  : 			else

  0011a	eb 03		 jmp	 SHORT $LN7@DecryptBuf@2
$LN8@DecryptBuf@2:

; 525  : 				whiteningValuePtr64++;

  0011c	83 c6 08	 add	 esi, 8
$LN7@DecryptBuf@2:

; 526  : 
; 527  : 			// Derive the next whitening value
; 528  : 
; 529  : #if BYTE_ORDER == LITTLE_ENDIAN
; 530  : 
; 531  : 			// Little-endian platforms
; 532  : 
; 533  : 			finalCarry = 
; 534  : 				(*whiteningValuePtr64 & 0x8000000000000000) ?
; 535  : 				135 : 0;

  0011f	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00122	8b 06		 mov	 eax, DWORD PTR [esi]
  00124	8b da		 mov	 ebx, edx
  00126	81 e3 00 00 00
	80		 and	 ebx, -2147483648	; 80000000H
  0012c	33 c9		 xor	 ecx, ecx
  0012e	0b cb		 or	 ecx, ebx
  00130	c6 45 eb 87	 mov	 BYTE PTR _finalCarry$[ebp], 135 ; 00000087H
  00134	75 04		 jne	 SHORT $LN20@DecryptBuf@2
  00136	c6 45 eb 00	 mov	 BYTE PTR _finalCarry$[ebp], 0
$LN20@DecryptBuf@2:

; 536  : 
; 537  : 			*whiteningValuePtr64-- <<= 1;

  0013a	0f a4 c2 01	 shld	 edx, eax, 1
  0013e	03 c0		 add	 eax, eax
  00140	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00143	89 06		 mov	 DWORD PTR [esi], eax

; 538  : 
; 539  : 			if (*whiteningValuePtr64 & 0x8000000000000000)

  00145	8b 5e fc	 mov	 ebx, DWORD PTR [esi-4]
  00148	83 ee 08	 sub	 esi, 8
  0014b	8b 06		 mov	 eax, DWORD PTR [esi]
  0014d	8b d3		 mov	 edx, ebx
  0014f	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H
  00155	33 c9		 xor	 ecx, ecx
  00157	0b ca		 or	 ecx, edx
  00159	74 0a		 je	 SHORT $LN6@DecryptBuf@2

; 540  : 				*(whiteningValuePtr64 + 1) |= 1;	

  0015b	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0015e	83 4e 08 01	 or	 DWORD PTR [esi+8], 1
  00162	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
$LN6@DecryptBuf@2:

; 541  : 
; 542  : 			*whiteningValuePtr64 <<= 1;

  00165	0f a4 c3 01	 shld	 ebx, eax, 1
  00169	03 c0		 add	 eax, eax
  0016b	89 06		 mov	 DWORD PTR [esi], eax

; 543  : 
; 544  : #else
; 545  : 			// Big-endian platforms
; 546  : 
; 547  : 			finalCarry = 
; 548  : 				(*whiteningValuePtr64 & 0x80) ?
; 549  : 				135 : 0;
; 550  : 
; 551  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 552  : 
; 553  : 			whiteningValuePtr64--;
; 554  : 
; 555  : 			if (*whiteningValuePtr64 & 0x80)
; 556  : 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
; 557  : 
; 558  : 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
; 559  : #endif
; 560  : 
; 561  : 			whiteningValue[0] ^= finalCarry;

  0016d	8a 45 eb	 mov	 al, BYTE PTR _finalCarry$[ebp]
  00170	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  00173	30 45 ec	 xor	 BYTE PTR _whiteningValue$[ebp], al
  00176	ff 45 d8	 inc	 DWORD PTR _block$[ebp]
  00179	8b 45 d8	 mov	 eax, DWORD PTR _block$[ebp]
  0017c	3b 45 d4	 cmp	 eax, DWORD PTR _endBlock$[ebp]
  0017f	0f 82 48 ff ff
	ff		 jb	 $LL36@DecryptBuf@2
  00185	8b 5d d4	 mov	 ebx, DWORD PTR _endBlock$[ebp]
  00188	33 c0		 xor	 eax, eax
$LN9@DecryptBuf@2:

; 562  : 		}
; 563  : 
; 564  : 		blockCount -= endBlock - startBlock;

  0018a	2b 5d dc	 sub	 ebx, DWORD PTR _startBlock$[ebp]

; 565  : 		startBlock = 0;

  0018d	89 45 dc	 mov	 DWORD PTR _startBlock$[ebp], eax
  00190	29 5d e0	 sub	 DWORD PTR _blockCount$[ebp], ebx
  00193	19 45 e4	 sbb	 DWORD PTR _blockCount$[ebp+4], eax

; 566  : 		dataUnitNo++;

  00196	83 45 cc 01	 add	 DWORD PTR _dataUnitNo$[ebp], 1
  0019a	11 45 d0	 adc	 DWORD PTR _dataUnitNo$[ebp+4], eax
  0019d	39 45 e4	 cmp	 DWORD PTR _blockCount$[ebp+4], eax
  001a0	0f 87 ce fe ff
	ff		 ja	 $LL34@DecryptBuf@2

; 490  : 
; 491  : 	// Process all blocks in the buffer
; 492  : 	while (blockCount > 0)

  001a6	72 0a		 jb	 SHORT $LN39@DecryptBuf@2
  001a8	83 7d e0 00	 cmp	 DWORD PTR _blockCount$[ebp], 0
  001ac	0f 87 c2 fe ff
	ff		 ja	 $LL34@DecryptBuf@2
$LN39@DecryptBuf@2:
  001b2	5e		 pop	 esi
  001b3	5b		 pop	 ebx
$LN5@DecryptBuf@2:

; 567  : 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
; 568  : 	}
; 569  : 
; 570  : 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));

  001b4	6a 02		 push	 2
  001b6	59		 pop	 ecx
  001b7	8d 45 ec	 lea	 eax, DWORD PTR _whiteningValue$[ebp]
  001ba	5f		 pop	 edi
$LL2@DecryptBuf@2:
  001bb	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  001c1	49		 dec	 ecx
  001c2	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  001c9	83 c0 08	 add	 eax, 8
  001cc	85 c9		 test	 ecx, ecx
  001ce	75 eb		 jne	 SHORT $LL2@DecryptBuf@2

; 571  : }

  001d0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d3	33 cd		 xor	 ecx, ebp
  001d5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001da	c9		 leave
  001db	c2 18 00	 ret	 24			; 00000018H
$LN41@DecryptBuf@2:
_DecryptBufferXTSNonParallel@32 ENDP
_TEXT	ENDS
PUBLIC	_EncryptBufferXTS@32
EXTRN	_CipherSupportsIntraDataUnitParallelization@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _EncryptBufferXTS@32
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_ks$ = 28						; size = 4
_ks2$ = 32						; size = 4
_cipher$ = 36						; size = 4
_EncryptBufferXTS@32 PROC				; COMDAT

; 48   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 49   : 	if (CipherSupportsIntraDataUnitParallelization (cipher))

  00005	ff 75 24	 push	 DWORD PTR _cipher$[ebp]
  00008	e8 00 00 00 00	 call	 _CipherSupportsIntraDataUnitParallelization@4

; 50   : 		EncryptBufferXTSParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  0000d	ff 75 24	 push	 DWORD PTR _cipher$[ebp]
  00010	8b 4d 1c	 mov	 ecx, DWORD PTR _ks$[ebp]
  00013	ff 75 20	 push	 DWORD PTR _ks2$[ebp]
  00016	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00019	ff 75 18	 push	 DWORD PTR _startCipherBlockNo$[ebp]
  0001c	ff 75 14	 push	 DWORD PTR _startDataUnitNo$[ebp]
  0001f	ff 75 10	 push	 DWORD PTR _length$[ebp+4]
  00022	ff 75 0c	 push	 DWORD PTR _length$[ebp]
  00025	85 c0		 test	 eax, eax
  00027	74 07		 je	 SHORT $LN2@EncryptBuf@3
  00029	e8 00 00 00 00	 call	 _EncryptBufferXTSParallel@32

; 51   : 	else

  0002e	eb 05		 jmp	 SHORT $LN1@EncryptBuf@3
$LN2@EncryptBuf@3:

; 52   : 		EncryptBufferXTSNonParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  00030	e8 00 00 00 00	 call	 _EncryptBufferXTSNonParallel@32
$LN1@EncryptBuf@3:

; 53   : }

  00035	5d		 pop	 ebp
  00036	c2 20 00	 ret	 32			; 00000020H
_EncryptBufferXTS@32 ENDP
_TEXT	ENDS
PUBLIC	_DecryptBufferXTS@32
; Function compile flags: /Ogsp
;	COMDAT _DecryptBufferXTS@32
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_startDataUnitNo$ = 20					; size = 4
_startCipherBlockNo$ = 24				; size = 4
_ks$ = 28						; size = 4
_ks2$ = 32						; size = 4
_cipher$ = 36						; size = 4
_DecryptBufferXTS@32 PROC				; COMDAT

; 323  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 324  : 	if (CipherSupportsIntraDataUnitParallelization (cipher))

  00005	ff 75 24	 push	 DWORD PTR _cipher$[ebp]
  00008	e8 00 00 00 00	 call	 _CipherSupportsIntraDataUnitParallelization@4

; 325  : 		DecryptBufferXTSParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  0000d	ff 75 24	 push	 DWORD PTR _cipher$[ebp]
  00010	8b 4d 1c	 mov	 ecx, DWORD PTR _ks$[ebp]
  00013	ff 75 20	 push	 DWORD PTR _ks2$[ebp]
  00016	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00019	ff 75 18	 push	 DWORD PTR _startCipherBlockNo$[ebp]
  0001c	ff 75 14	 push	 DWORD PTR _startDataUnitNo$[ebp]
  0001f	ff 75 10	 push	 DWORD PTR _length$[ebp+4]
  00022	ff 75 0c	 push	 DWORD PTR _length$[ebp]
  00025	85 c0		 test	 eax, eax
  00027	74 07		 je	 SHORT $LN2@DecryptBuf@3
  00029	e8 00 00 00 00	 call	 _DecryptBufferXTSParallel@32

; 326  : 	else

  0002e	eb 05		 jmp	 SHORT $LN1@DecryptBuf@3
$LN2@DecryptBuf@3:

; 327  : 		DecryptBufferXTSNonParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);

  00030	e8 00 00 00 00	 call	 _DecryptBufferXTSNonParallel@32
$LN1@DecryptBuf@3:

; 328  : }

  00035	5d		 pop	 ebp
  00036	c2 20 00	 ret	 32			; 00000020H
_DecryptBufferXTS@32 ENDP
_TEXT	ENDS
END
