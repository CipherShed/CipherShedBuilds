; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	InitializeListHead
PUBLIC	??_C@_0EP@FEOCDHHD@c?3?2home?2public?2desktop?2projects?2@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0O@FECNDOKE@buffer?9?$DOInUse?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CG@COCFEEEN@?$CBbuffer?9?$DOInUse?5?$HM?$HM?5queue?9?$DOStartPe@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0GC@JKEACOCL@request?9?$DOEncryptedOffset?5?$CL?5reque@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EP@IGAPPBIF@Hidden?5volume?5protection?5trigger@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DJ@KOLNOKOK@Preventing?5write?5to?5the?5system?5e@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DI@GBCOIBFH@Preventing?5write?5to?5boot?5loader?5@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CB@JMNJFHBF@STATUS_DEVICE_NOT_READY?5?5out?$DN?$CFd?6@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BC@DPKEMNCN@?$CBqueue?9?$DOSuspended?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BB@CDEEPNAM@queue?9?$DOSuspended?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0P@IPONPJEA@Queue?5started?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BE@PAKNKFEC@?$CBqueue?9?$DOStopPending?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BI@FIKKAEEK@Queue?5stopping?5?5out?$DN?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BH@LHJJPAN@Queue?5stopped?5?5out?$DN?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp_KeClearEvent:PROC
EXTRN	__imp_ZwWriteFile:PROC
EXTRN	__imp_SeImpersonateClientEx:PROC
EXTRN	__imp_ZwReadFile:PROC
EXTRN	__imp_KeSetPriorityThread:PROC
EXTRN	__imp_ExInterlockedInsertTailList:PROC
EXTRN	__imp_ExInterlockedRemoveHeadList:PROC
;	COMDAT ??_C@_0BH@LHJJPAN@Queue?5stopped?5?5out?$DN?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BH@LHJJPAN@Queue?5stopped?5?5out?$DN?$CFd?6?$AA@FNODOBFM@ DB 'Queu'
	DB	'e stopped  out=%d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BI@FIKKAEEK@Queue?5stopping?5?5out?$DN?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BI@FIKKAEEK@Queue?5stopping?5?5out?$DN?$CFd?6?$AA@FNODOBFM@ DB 'Qu'
	DB	'eue stopping  out=%d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BE@PAKNKFEC@?$CBqueue?9?$DOStopPending?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BE@PAKNKFEC@?$CBqueue?9?$DOStopPending?$AA@FNODOBFM@ DB '!queue->S'
	DB	'topPending', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0P@IPONPJEA@Queue?5started?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0P@IPONPJEA@Queue?5started?6?$AA@FNODOBFM@ DB 'Queue started', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BB@CDEEPNAM@queue?9?$DOSuspended?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BB@CDEEPNAM@queue?9?$DOSuspended?$AA@FNODOBFM@ DB 'queue->Suspende'
	DB	'd', 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BC@DPKEMNCN@?$CBqueue?9?$DOSuspended?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BC@DPKEMNCN@?$CBqueue?9?$DOSuspended?$AA@FNODOBFM@ DB '!queue->Sus'
	DB	'pended', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CB@JMNJFHBF@STATUS_DEVICE_NOT_READY?5?5out?$DN?$CFd?6@FNODOBFM@
text$s	SEGMENT
??_C@_0CB@JMNJFHBF@STATUS_DEVICE_NOT_READY?5?5out?$DN?$CFd?6@FNODOBFM@ DB 'S'
	DB	'TATUS_DEVICE_NOT_READY  out=%d', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DI@GBCOIBFH@Preventing?5write?5to?5boot?5loader?5@FNODOBFM@
text$s	SEGMENT
??_C@_0DI@GBCOIBFH@Preventing?5write?5to?5boot?5loader?5@FNODOBFM@ DB 'Pr'
	DB	'eventing write to boot loader or host protected area', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DJ@KOLNOKOK@Preventing?5write?5to?5the?5system?5e@FNODOBFM@
text$s	SEGMENT
??_C@_0DJ@KOLNOKOK@Preventing?5write?5to?5the?5system?5e@FNODOBFM@ DB 'Pr'
	DB	'eventing write to the system encryption key data area', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EP@IGAPPBIF@Hidden?5volume?5protection?5trigger@FNODOBFM@
text$s	SEGMENT
??_C@_0EP@IGAPPBIF@Hidden?5volume?5protection?5trigger@FNODOBFM@ DB 'Hidd'
	DB	'en volume protection triggered: write %I64d-%I64d (protected '
	DB	'%I64d-%I64d)', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0GC@JKEACOCL@request?9?$DOEncryptedOffset?5?$CL?5reque@FNODOBFM@
text$s	SEGMENT
??_C@_0GC@JKEACOCL@request?9?$DOEncryptedOffset?5?$CL?5reque@FNODOBFM@ DB 'r'
	DB	'equest->EncryptedOffset + request->EncryptedLength <= request'
	DB	'->Offset.QuadPart + request->Length', 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CG@COCFEEEN@?$CBbuffer?9?$DOInUse?5?$HM?$HM?5queue?9?$DOStartPe@FNODOBFM@
text$s	SEGMENT
??_C@_0CG@COCFEEEN@?$CBbuffer?9?$DOInUse?5?$HM?$HM?5queue?9?$DOStartPe@FNODOBFM@ DB '!'
	DB	'buffer->InUse || queue->StartPending', 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0O@FECNDOKE@buffer?9?$DOInUse?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0O@FECNDOKE@buffer?9?$DOInUse?$AA@FNODOBFM@ DB 'buffer->InUse', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EP@FEOCDHHD@c?3?2home?2public?2desktop?2projects?2@FNODOBFM@
text$s	SEGMENT
??_C@_0EP@FEOCDHHD@c?3?2home?2public?2desktop?2projects?2@FNODOBFM@ DB 'c'
	DB	':\home\public\desktop\projects\ciphershed.build\src\driver\en'
	DB	'cryptedioqueue.c', 00H			;  ?? ::FNODOBFM::`string'
PUBLIC	EncryptedIoQueueResumeFromHold
;	COMDAT pdata
; File c:\home\public\desktop\projects\ciphershed.build\src\driver\encryptedioqueue.c
pdata	SEGMENT
$pdata$EncryptedIoQueueResumeFromHold DD imagerel $LN5
	DD	imagerel $LN5+119
	DD	imagerel $unwind$EncryptedIoQueueResumeFromHold
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptedIoQueueResumeFromHold DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EncryptedIoQueueResumeFromHold
_TEXT	SEGMENT
tv71 = 32
queue$ = 64
EncryptedIoQueueResumeFromHold PROC			; COMDAT

; 858  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 859  : 	ASSERT (queue->Suspended);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR queue$[rsp]
  0000e	8b 80 90 02 00
	00		 mov	 eax, DWORD PTR [rax+656]
  00014	85 c0		 test	 eax, eax
  00016	75 27		 jne	 SHORT $LN3@EncryptedI
  00018	45 33 c9	 xor	 r9d, r9d
  0001b	41 b8 5b 03 00
	00		 mov	 r8d, 859		; 0000035bH
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EP@FEOCDHHD@c?3?2home?2public?2desktop?2projects?2@FNODOBFM@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@CDEEPNAM@queue?9?$DOSuspended?$AA@FNODOBFM@
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  00035	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
  0003d	eb 08		 jmp	 SHORT $LN4@EncryptedI
$LN3@EncryptedI:
  0003f	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv71[rsp], 1
$LN4@EncryptedI:

; 860  : 	
; 861  : 	queue->Suspended = FALSE;

  00047	48 8b 44 24 40	 mov	 rax, QWORD PTR queue$[rsp]
  0004c	c7 80 90 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+656], 0

; 862  : 	KeSetEvent (&queue->QueueResumedEvent, IO_DISK_INCREMENT, FALSE);

  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  0005b	48 81 c1 a0 02
	00 00		 add	 rcx, 672		; 000002a0H
  00062	45 33 c0	 xor	 r8d, r8d
  00065	ba 01 00 00 00	 mov	 edx, 1
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 863  : 
; 864  : 	return STATUS_SUCCESS;

  00070	33 c0		 xor	 eax, eax

; 865  : }

  00072	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00076	c3		 ret	 0
EncryptedIoQueueResumeFromHold ENDP
_TEXT	ENDS
PUBLIC	EncryptedIoQueueIsRunning
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptedIoQueueIsRunning DD imagerel $LN5
	DD	imagerel $LN5+48
	DD	imagerel $unwind$EncryptedIoQueueIsRunning
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptedIoQueueIsRunning DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EncryptedIoQueueIsRunning
_TEXT	SEGMENT
tv67 = 0
queue$ = 32
EncryptedIoQueueIsRunning PROC				; COMDAT

; 852  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 853  : 	return !queue->StopPending;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR queue$[rsp]
  0000e	8b 80 98 02 00
	00		 mov	 eax, DWORD PTR [rax+664]
  00014	85 c0		 test	 eax, eax
  00016	75 09		 jne	 SHORT $LN3@EncryptedI@2
  00018	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv67[rsp], 1
  0001f	eb 07		 jmp	 SHORT $LN4@EncryptedI@2
$LN3@EncryptedI@2:
  00021	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv67[rsp], 0
$LN4@EncryptedI@2:
  00028	8b 04 24	 mov	 eax, DWORD PTR tv67[rsp]

; 854  : }

  0002b	48 83 c4 18	 add	 rsp, 24
  0002f	c3		 ret	 0
EncryptedIoQueueIsRunning ENDP
_TEXT	ENDS
PUBLIC	EncryptedIoQueueIsSuspended
; Function compile flags: /Odtp
;	COMDAT EncryptedIoQueueIsSuspended
_TEXT	SEGMENT
queue$ = 8
EncryptedIoQueueIsSuspended PROC			; COMDAT

; 846  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 847  : 	return queue->Suspended;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR queue$[rsp]
  0000a	8b 80 90 02 00
	00		 mov	 eax, DWORD PTR [rax+656]

; 848  : }

  00010	c3		 ret	 0
EncryptedIoQueueIsSuspended ENDP
_TEXT	ENDS
PUBLIC	EncryptedIoQueueHoldWhenIdle
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptedIoQueueHoldWhenIdle DD imagerel $LN15
	DD	imagerel $LN15+469
	DD	imagerel $unwind$EncryptedIoQueueHoldWhenIdle
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptedIoQueueHoldWhenIdle DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EncryptedIoQueueHoldWhenIdle
_TEXT	SEGMENT
status$ = 48
waitTimeout$29789 = 56
tv71 = 64
tv82 = 72
queue$ = 96
timeout$ = 104
EncryptedIoQueueHoldWhenIdle PROC			; COMDAT

; 796  : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 797  : 	NTSTATUS status;
; 798  : 	ASSERT (!queue->Suspended);

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  00013	8b 80 90 02 00
	00		 mov	 eax, DWORD PTR [rax+656]
  00019	85 c0		 test	 eax, eax
  0001b	74 27		 je	 SHORT $LN11@EncryptedI@3
  0001d	45 33 c9	 xor	 r9d, r9d
  00020	41 b8 1e 03 00
	00		 mov	 r8d, 798		; 0000031eH
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EP@FEOCDHHD@c?3?2home?2public?2desktop?2projects?2@FNODOBFM@
  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@DPKEMNCN@?$CBqueue?9?$DOSuspended?$AA@FNODOBFM@
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  0003a	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
  00042	eb 08		 jmp	 SHORT $LN12@EncryptedI@3
$LN11@EncryptedI@3:
  00044	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv71[rsp], 1
$LN12@EncryptedI@3:

; 799  : 
; 800  : 	queue->SuspendPending = TRUE;

  0004c	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  00051	c7 80 94 02 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+660], 1
$LN8@EncryptedI@3:

; 801  : 	
; 802  : 	while (TRUE)

  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 01	 cmp	 eax, 1
  00060	0f 84 4a 01 00
	00		 je	 $LN7@EncryptedI@3
$LN6@EncryptedI@3:

; 803  : 	{
; 804  : 		while (InterlockedExchangeAdd (&queue->OutstandingIoCount, 0) > 0)

  00066	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  0006b	48 05 38 02 00
	00		 add	 rax, 568		; 00000238H
  00071	33 c9		 xor	 ecx, ecx
  00073	f0 0f c1 08	 lock xadd DWORD PTR [rax], ecx
  00077	8b c1		 mov	 eax, ecx
  00079	85 c0		 test	 eax, eax
  0007b	0f 8e c6 00 00
	00		 jle	 $LN5@EncryptedI@3

; 805  : 		{
; 806  : 			LARGE_INTEGER waitTimeout;
; 807  : 
; 808  : 			waitTimeout.QuadPart = timeout * -10000;

  00081	48 8b 44 24 68	 mov	 rax, QWORD PTR timeout$[rsp]
  00086	48 69 c0 f0 d8
	ff ff		 imul	 rax, -10000		; ffffffffffffd8f0H
  0008d	48 89 44 24 38	 mov	 QWORD PTR waitTimeout$29789[rsp], rax

; 809  : 			status = KeWaitForSingleObject (&queue->NoOutstandingIoEvent, Executive, KernelMode, FALSE, timeout != 0 ? &waitTimeout : NULL);

  00092	48 83 7c 24 68
	00		 cmp	 QWORD PTR timeout$[rsp], 0
  00098	74 0c		 je	 SHORT $LN13@EncryptedI@3
  0009a	48 8d 44 24 38	 lea	 rax, QWORD PTR waitTimeout$29789[rsp]
  0009f	48 89 44 24 48	 mov	 QWORD PTR tv82[rsp], rax
  000a4	eb 09		 jmp	 SHORT $LN14@EncryptedI@3
$LN13@EncryptedI@3:
  000a6	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv82[rsp], 0
$LN14@EncryptedI@3:
  000af	48 8b 4c 24 60	 mov	 rcx, QWORD PTR queue$[rsp]
  000b4	48 81 c1 40 02
	00 00		 add	 rcx, 576		; 00000240H
  000bb	48 8b 44 24 48	 mov	 rax, QWORD PTR tv82[rsp]
  000c0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c5	45 33 c9	 xor	 r9d, r9d
  000c8	45 33 c0	 xor	 r8d, r8d
  000cb	33 d2		 xor	 edx, edx
  000cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  000d3	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax

; 810  : 
; 811  : 			if (status == STATUS_TIMEOUT)

  000d7	81 7c 24 30 02
	01 00 00	 cmp	 DWORD PTR status$[rsp], 258 ; 00000102H
  000df	75 08		 jne	 SHORT $LN4@EncryptedI@3

; 812  : 				status = STATUS_UNSUCCESSFUL;

  000e1	c7 44 24 30 01
	00 00 c0	 mov	 DWORD PTR status$[rsp], -1073741823 ; ffffffffc0000001H
$LN4@EncryptedI@3:

; 813  : 
; 814  : 			if (!NT_SUCCESS (status))

  000e9	83 7c 24 30 00	 cmp	 DWORD PTR status$[rsp], 0
  000ee	7d 18		 jge	 SHORT $LN3@EncryptedI@3

; 815  : 			{
; 816  : 				queue->SuspendPending = FALSE;

  000f0	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  000f5	c7 80 94 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+660], 0

; 817  : 				return status;

  000ff	8b 44 24 30	 mov	 eax, DWORD PTR status$[rsp]
  00103	e9 c8 00 00 00	 jmp	 $LN9@EncryptedI@3
$LN3@EncryptedI@3:

; 818  : 			}
; 819  : 
; 820  : 			TCSleep (1);

  00108	b9 01 00 00 00	 mov	 ecx, 1
  0010d	e8 00 00 00 00	 call	 TCSleep

; 821  : 			if (InterlockedExchangeAdd (&queue->OutstandingIoCount, 0) > 0)

  00112	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  00117	48 05 38 02 00
	00		 add	 rax, 568		; 00000238H
  0011d	33 c9		 xor	 ecx, ecx
  0011f	f0 0f c1 08	 lock xadd DWORD PTR [rax], ecx
  00123	8b c1		 mov	 eax, ecx
  00125	85 c0		 test	 eax, eax
  00127	7e 19		 jle	 SHORT $LN2@EncryptedI@3

; 822  : 			{
; 823  : 				queue->SuspendPending = FALSE;

  00129	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  0012e	c7 80 94 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+660], 0

; 824  : 				return STATUS_UNSUCCESSFUL;

  00138	b8 01 00 00 c0	 mov	 eax, -1073741823	; ffffffffc0000001H
  0013d	e9 8e 00 00 00	 jmp	 $LN9@EncryptedI@3
$LN2@EncryptedI@3:

; 825  : 			}
; 826  : 		}

  00142	e9 1f ff ff ff	 jmp	 $LN6@EncryptedI@3
$LN5@EncryptedI@3:

; 827  : 
; 828  : 		KeClearEvent (&queue->QueueResumedEvent);

  00147	48 8b 4c 24 60	 mov	 rcx, QWORD PTR queue$[rsp]
  0014c	48 81 c1 a0 02
	00 00		 add	 rcx, 672		; 000002a0H
  00153	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeClearEvent

; 829  : 		queue->Suspended = TRUE;

  00159	4c 8b 5c 24 60	 mov	 r11, QWORD PTR queue$[rsp]
  0015e	41 c7 83 90 02
	00 00 01 00 00
	00		 mov	 DWORD PTR [r11+656], 1

; 830  : 
; 831  : 		if (InterlockedExchangeAdd (&queue->OutstandingIoCount, 0) == 0)

  00169	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  0016e	48 05 38 02 00
	00		 add	 rax, 568		; 00000238H
  00174	33 c9		 xor	 ecx, ecx
  00176	f0 0f c1 08	 lock xadd DWORD PTR [rax], ecx
  0017a	8b c1		 mov	 eax, ecx
  0017c	85 c0		 test	 eax, eax
  0017e	75 02		 jne	 SHORT $LN1@EncryptedI@3

; 832  : 			break;

  00180	eb 2e		 jmp	 SHORT $LN7@EncryptedI@3
$LN1@EncryptedI@3:

; 833  : 
; 834  : 		queue->Suspended = FALSE;

  00182	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  00187	c7 80 90 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+656], 0

; 835  : 		KeSetEvent (&queue->QueueResumedEvent, IO_DISK_INCREMENT, FALSE);

  00191	48 8b 4c 24 60	 mov	 rcx, QWORD PTR queue$[rsp]
  00196	48 81 c1 a0 02
	00 00		 add	 rcx, 672		; 000002a0H
  0019d	45 33 c0	 xor	 r8d, r8d
  001a0	ba 01 00 00 00	 mov	 edx, 1
  001a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 836  : 	}

  001ab	e9 ab fe ff ff	 jmp	 $LN8@EncryptedI@3
$LN7@EncryptedI@3:

; 837  : 
; 838  : 	queue->ReadAheadBufferValid = FALSE;

  001b0	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  001b5	c7 80 00 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+512], 0

; 839  : 
; 840  : 	queue->SuspendPending = FALSE;

  001bf	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  001c4	c7 80 94 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+660], 0

; 841  : 	return STATUS_SUCCESS;

  001ce	33 c0		 xor	 eax, eax
$LN9@EncryptedI@3:

; 842  : }

  001d0	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d4	c3		 ret	 0
EncryptedIoQueueHoldWhenIdle ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ReleaseFragmentBuffer DD imagerel ReleaseFragmentBuffer
	DD	imagerel ReleaseFragmentBuffer+148
	DD	imagerel $unwind$ReleaseFragmentBuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ReleaseFragmentBuffer DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ReleaseFragmentBuffer
_TEXT	SEGMENT
queue$ = 64
buffer$ = 72
ReleaseFragmentBuffer PROC				; COMDAT

; 208  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 209  : 	if (buffer == queue->FragmentBufferA)

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR queue$[rsp]
  00013	48 8b 80 c0 01
	00 00		 mov	 rax, QWORD PTR [rax+448]
  0001a	48 39 44 24 48	 cmp	 QWORD PTR buffer$[rsp], rax
  0001f	75 1c		 jne	 SHORT $LN4@ReleaseFra

; 210  : 	{
; 211  : 		KeSetEvent (&queue->FragmentBufferAFreeEvent, IO_DISK_INCREMENT, FALSE);

  00021	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  00026	48 81 c1 d0 01
	00 00		 add	 rcx, 464		; 000001d0H
  0002d	45 33 c0	 xor	 r8d, r8d
  00030	ba 01 00 00 00	 mov	 edx, 1
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent
  0003b	eb 52		 jmp	 SHORT $LN3@ReleaseFra
$LN4@ReleaseFra:

; 212  : 	}
; 213  : 	else if (buffer == queue->FragmentBufferB)

  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR queue$[rsp]
  00042	48 8b 80 c8 01
	00 00		 mov	 rax, QWORD PTR [rax+456]
  00049	48 39 44 24 48	 cmp	 QWORD PTR buffer$[rsp], rax
  0004e	75 1c		 jne	 SHORT $LN2@ReleaseFra

; 214  : 	{
; 215  : 		KeSetEvent (&queue->FragmentBufferBFreeEvent, IO_DISK_INCREMENT, FALSE);

  00050	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  00055	48 81 c1 e8 01
	00 00		 add	 rcx, 488		; 000001e8H
  0005c	45 33 c0	 xor	 r8d, r8d
  0005f	ba 01 00 00 00	 mov	 edx, 1
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 216  : 	}
; 217  : 	else

  0006a	eb 23		 jmp	 SHORT $LN1@ReleaseFra
$LN2@ReleaseFra:

; 218  : 	{
; 219  : 		TC_BUG_CHECK (STATUS_INVALID_PARAMETER);

  0006c	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00075	45 33 c9	 xor	 r9d, r9d
  00078	49 c7 c0 0d 00
	00 c0		 mov	 r8, -1073741811		; ffffffffc000000dH
  0007f	ba db 00 00 00	 mov	 edx, 219		; 000000dbH
  00084	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN1@ReleaseFra:
$LN3@ReleaseFra:
$LN6@ReleaseFra:

; 220  : 	}
; 221  : }

  0008f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00093	c3		 ret	 0
ReleaseFragmentBuffer ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcquireFragmentBuffer DD imagerel AcquireFragmentBuffer
	DD	imagerel AcquireFragmentBuffer+185
	DD	imagerel $unwind$AcquireFragmentBuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcquireFragmentBuffer DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT AcquireFragmentBuffer
_TEXT	SEGMENT
status$ = 48
queue$ = 80
buffer$ = 88
AcquireFragmentBuffer PROC				; COMDAT

; 190  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 191  : 	NTSTATUS status = STATUS_INVALID_PARAMETER;

  0000e	c7 44 24 30 0d
	00 00 c0	 mov	 DWORD PTR status$[rsp], -1073741811 ; ffffffffc000000dH

; 192  : 
; 193  : 	if (buffer == queue->FragmentBufferA)

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR queue$[rsp]
  0001b	48 8b 80 c0 01
	00 00		 mov	 rax, QWORD PTR [rax+448]
  00022	48 39 44 24 58	 cmp	 QWORD PTR buffer$[rsp], rax
  00027	75 29		 jne	 SHORT $LN4@AcquireFra

; 194  : 	{
; 195  : 		status = KeWaitForSingleObject (&queue->FragmentBufferAFreeEvent, Executive, KernelMode, FALSE, NULL);

  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR queue$[rsp]
  0002e	48 81 c1 d0 01
	00 00		 add	 rcx, 464		; 000001d0H
  00035	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0003e	45 33 c9	 xor	 r9d, r9d
  00041	45 33 c0	 xor	 r8d, r8d
  00044	33 d2		 xor	 edx, edx
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  0004c	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax
  00050	eb 3a		 jmp	 SHORT $LN3@AcquireFra
$LN4@AcquireFra:

; 196  : 	}
; 197  : 	else if (buffer == queue->FragmentBufferB)

  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR queue$[rsp]
  00057	48 8b 80 c8 01
	00 00		 mov	 rax, QWORD PTR [rax+456]
  0005e	48 39 44 24 58	 cmp	 QWORD PTR buffer$[rsp], rax
  00063	75 27		 jne	 SHORT $LN2@AcquireFra

; 198  : 	{
; 199  : 		status = KeWaitForSingleObject (&queue->FragmentBufferBFreeEvent, Executive, KernelMode, FALSE, NULL);

  00065	48 8b 4c 24 50	 mov	 rcx, QWORD PTR queue$[rsp]
  0006a	48 81 c1 e8 01
	00 00		 add	 rcx, 488		; 000001e8H
  00071	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0007a	45 33 c9	 xor	 r9d, r9d
  0007d	45 33 c0	 xor	 r8d, r8d
  00080	33 d2		 xor	 edx, edx
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  00088	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax
$LN2@AcquireFra:
$LN3@AcquireFra:

; 200  : 	}
; 201  : 
; 202  : 	if (!NT_SUCCESS (status))

  0008c	83 7c 24 30 00	 cmp	 DWORD PTR status$[rsp], 0
  00091	7d 21		 jge	 SHORT $LN1@AcquireFra

; 203  : 		TC_BUG_CHECK (status);

  00093	4c 63 44 24 30	 movsxd	 r8, DWORD PTR status$[rsp]
  00098	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  000a1	45 33 c9	 xor	 r9d, r9d
  000a4	ba cb 00 00 00	 mov	 edx, 203		; 000000cbH
  000a9	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN1@AcquireFra:
$LN6@AcquireFra:

; 204  : }

  000b4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b8	c3		 ret	 0
AcquireFragmentBuffer ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DecrementOutstandingIoCount DD imagerel DecrementOutstandingIoCount
	DD	imagerel DecrementOutstandingIoCount+98
	DD	imagerel $unwind$DecrementOutstandingIoCount
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecrementOutstandingIoCount DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DecrementOutstandingIoCount
_TEXT	SEGMENT
queue$ = 48
DecrementOutstandingIoCount PROC			; COMDAT

; 150  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 151  : 	if (InterlockedDecrement (&queue->OutstandingIoCount) == 0 && (queue->SuspendPending || queue->StopPending))

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR queue$[rsp]
  0000e	48 81 c1 38 02
	00 00		 add	 rcx, 568		; 00000238H
  00015	b8 ff ff ff ff	 mov	 eax, -1
  0001a	f0 0f c1 01	 lock xadd DWORD PTR [rcx], eax
  0001e	83 c0 ff	 add	 eax, -1
  00021	85 c0		 test	 eax, eax
  00023	75 38		 jne	 SHORT $LN2@DecrementO
  00025	48 8b 44 24 30	 mov	 rax, QWORD PTR queue$[rsp]
  0002a	8b 80 94 02 00
	00		 mov	 eax, DWORD PTR [rax+660]
  00030	85 c0		 test	 eax, eax
  00032	75 0f		 jne	 SHORT $LN1@DecrementO
  00034	48 8b 44 24 30	 mov	 rax, QWORD PTR queue$[rsp]
  00039	8b 80 98 02 00
	00		 mov	 eax, DWORD PTR [rax+664]
  0003f	85 c0		 test	 eax, eax
  00041	74 1a		 je	 SHORT $LN2@DecrementO
$LN1@DecrementO:

; 152  : 		KeSetEvent (&queue->NoOutstandingIoEvent, IO_DISK_INCREMENT, FALSE);

  00043	48 8b 4c 24 30	 mov	 rcx, QWORD PTR queue$[rsp]
  00048	48 81 c1 40 02
	00 00		 add	 rcx, 576		; 00000240H
  0004f	45 33 c0	 xor	 r8d, r8d
  00052	ba 01 00 00 00	 mov	 edx, 1
  00057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent
$LN2@DecrementO:

; 153  : }

  0005d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00061	c3		 ret	 0
DecrementOutstandingIoCount ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ReleaseBufferPoolMutex DD imagerel ReleaseBufferPoolMutex
	DD	imagerel ReleaseBufferPoolMutex+31
	DD	imagerel $unwind$ReleaseBufferPoolMutex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ReleaseBufferPoolMutex DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ReleaseBufferPoolMutex
_TEXT	SEGMENT
queue$ = 48
ReleaseBufferPoolMutex PROC				; COMDAT

; 29   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 30   : 	KeReleaseMutex (&queue->BufferPoolMutex, FALSE);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR queue$[rsp]
  0000e	48 83 c1 08	 add	 rcx, 8
  00012	33 d2		 xor	 edx, edx
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseMutex

; 31   : }

  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
ReleaseBufferPoolMutex ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcquireBufferPoolMutex DD imagerel AcquireBufferPoolMutex
	DD	imagerel AcquireBufferPoolMutex+90
	DD	imagerel $unwind$AcquireBufferPoolMutex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcquireBufferPoolMutex DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT AcquireBufferPoolMutex
_TEXT	SEGMENT
status$ = 48
queue$ = 80
AcquireBufferPoolMutex PROC				; COMDAT

; 19   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 20   : 	NTSTATUS status;
; 21   : 
; 22   : 	status = KeWaitForMutexObject (&queue->BufferPoolMutex, Executive, KernelMode, FALSE, NULL);

  00009	48 8b 4c 24 50	 mov	 rcx, QWORD PTR queue$[rsp]
  0000e	48 83 c1 08	 add	 rcx, 8
  00012	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0001b	45 33 c9	 xor	 r9d, r9d
  0001e	45 33 c0	 xor	 r8d, r8d
  00021	33 d2		 xor	 edx, edx
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  00029	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax

; 23   : 	if (!NT_SUCCESS (status))

  0002d	83 7c 24 30 00	 cmp	 DWORD PTR status$[rsp], 0
  00032	7d 21		 jge	 SHORT $LN1@AcquireBuf

; 24   : 		TC_BUG_CHECK (status);

  00034	4c 63 44 24 30	 movsxd	 r8, DWORD PTR status$[rsp]
  00039	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00042	45 33 c9	 xor	 r9d, r9d
  00045	ba 18 00 00 00	 mov	 edx, 24
  0004a	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN1@AcquireBuf:
$LN3@AcquireBuf:

; 25   : }

  00055	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00059	c3		 ret	 0
AcquireBufferPoolMutex ENDP
; Function compile flags: /Odtp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT InitializeListHead
_TEXT	SEGMENT
ListHead$ = 8
InitializeListHead PROC					; COMDAT

; 7550 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 7551 :     ListHead->Flink = ListHead->Blink = ListHead;

  00005	48 8b 4c 24 08	 mov	 rcx, QWORD PTR ListHead$[rsp]
  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ListHead$[rsp]
  0000f	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00013	48 8b 4c 24 08	 mov	 rcx, QWORD PTR ListHead$[rsp]
  00018	48 8b 44 24 08	 mov	 rax, QWORD PTR ListHead$[rsp]
  0001d	48 89 01	 mov	 QWORD PTR [rcx], rax

; 7552 : }

  00020	c3		 ret	 0
InitializeListHead ENDP
;	COMDAT pdata
; File c:\home\public\desktop\projects\ciphershed.build\src\driver\encryptedioqueue.c
pdata	SEGMENT
$pdata$FreePoolBuffers DD imagerel FreePoolBuffers
	DD	imagerel FreePoolBuffers+210
	DD	imagerel $unwind$FreePoolBuffers
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$FreePoolBuffers DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT FreePoolBuffers
_TEXT	SEGMENT
buffer$ = 32
nextBuffer$29433 = 40
tv76 = 48
queue$ = 80
FreePoolBuffers PROC					; COMDAT

; 128  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 129  : 	EncryptedIoQueueBuffer *buffer;
; 130  : 	AcquireBufferPoolMutex (queue);

  00009	48 8b 4c 24 50	 mov	 rcx, QWORD PTR queue$[rsp]
  0000e	e8 00 00 00 00	 call	 AcquireBufferPoolMutex

; 131  : 
; 132  : 	for (buffer = queue->FirstPoolBuffer; buffer != NULL; )

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR queue$[rsp]
  00018	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0001c	48 89 44 24 20	 mov	 QWORD PTR buffer$[rsp], rax
$LN2@FreePoolBu@2:
  00021	48 83 7c 24 20
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00027	0f 84 89 00 00
	00		 je	 $LN1@FreePoolBu@2

; 133  : 	{
; 134  : 		EncryptedIoQueueBuffer *nextBuffer = buffer->NextBuffer;

  0002d	48 8b 44 24 20	 mov	 rax, QWORD PTR buffer$[rsp]
  00032	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00035	48 89 44 24 28	 mov	 QWORD PTR nextBuffer$29433[rsp], rax

; 135  : 
; 136  : 		ASSERT (!buffer->InUse || queue->StartPending);

  0003a	48 8b 44 24 20	 mov	 rax, QWORD PTR buffer$[rsp]
  0003f	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  00043	74 36		 je	 SHORT $LN5@FreePoolBu@2
  00045	48 8b 44 24 50	 mov	 rax, QWORD PTR queue$[rsp]
  0004a	8b 80 88 02 00
	00		 mov	 eax, DWORD PTR [rax+648]
  00050	85 c0		 test	 eax, eax
  00052	75 27		 jne	 SHORT $LN5@FreePoolBu@2
  00054	45 33 c9	 xor	 r9d, r9d
  00057	41 b8 88 00 00
	00		 mov	 r8d, 136		; 00000088H
  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EP@FEOCDHHD@c?3?2home?2public?2desktop?2projects?2@FNODOBFM@
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CG@COCFEEEN@?$CBbuffer?9?$DOInUse?5?$HM?$HM?5queue?9?$DOStartPe@FNODOBFM@
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  00071	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
  00079	eb 08		 jmp	 SHORT $LN6@FreePoolBu@2
$LN5@FreePoolBu@2:
  0007b	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
$LN6@FreePoolBu@2:

; 137  : 
; 138  : 		TCfree (buffer->Address);

  00083	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00088	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buffer$[rsp]
  0008d	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 139  : 		TCfree (buffer);

  00097	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  0009c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buffer$[rsp]
  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 140  : 
; 141  : 		buffer = nextBuffer;

  000a7	4c 8b 5c 24 28	 mov	 r11, QWORD PTR nextBuffer$29433[rsp]
  000ac	4c 89 5c 24 20	 mov	 QWORD PTR buffer$[rsp], r11

; 142  : 	}

  000b1	e9 6b ff ff ff	 jmp	 $LN2@FreePoolBu@2
$LN1@FreePoolBu@2:

; 143  : 
; 144  : 	queue->FirstPoolBuffer = NULL;

  000b6	48 8b 44 24 50	 mov	 rax, QWORD PTR queue$[rsp]
  000bb	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0

; 145  : 	ReleaseBufferPoolMutex (queue);

  000c3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR queue$[rsp]
  000c8	e8 00 00 00 00	 call	 ReleaseBufferPoolMutex

; 146  : }

  000cd	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000d1	c3		 ret	 0
FreePoolBuffers ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ReleasePoolBuffer DD imagerel ReleasePoolBuffer
	DD	imagerel ReleasePoolBuffer+192
	DD	imagerel $unwind$ReleasePoolBuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ReleasePoolBuffer DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ReleasePoolBuffer
_TEXT	SEGMENT
buffer$ = 32
tv75 = 40
queue$ = 64
address$ = 72
ReleasePoolBuffer PROC					; COMDAT

; 107  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 108  : 	EncryptedIoQueueBuffer *buffer;
; 109  : 	AcquireBufferPoolMutex (queue);

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  00013	e8 00 00 00 00	 call	 AcquireBufferPoolMutex

; 110  : 	
; 111  : 	for (buffer = queue->FirstPoolBuffer; buffer != NULL; buffer = buffer->NextBuffer)

  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR queue$[rsp]
  0001d	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00021	48 89 44 24 20	 mov	 QWORD PTR buffer$[rsp], rax
  00026	eb 0d		 jmp	 SHORT $LN4@ReleasePoo
$LN3@ReleasePoo:
  00028	48 8b 44 24 20	 mov	 rax, QWORD PTR buffer$[rsp]
  0002d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00030	48 89 44 24 20	 mov	 QWORD PTR buffer$[rsp], rax
$LN4@ReleasePoo:
  00035	48 83 7c 24 20
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  0003b	74 5a		 je	 SHORT $LN2@ReleasePoo

; 112  : 	{
; 113  : 		if (buffer->Address == address)

  0003d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buffer$[rsp]
  00042	48 8b 44 24 48	 mov	 rax, QWORD PTR address$[rsp]
  00047	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  0004b	75 48		 jne	 SHORT $LN1@ReleasePoo

; 114  : 		{
; 115  : 			ASSERT (buffer->InUse);

  0004d	48 8b 44 24 20	 mov	 rax, QWORD PTR buffer$[rsp]
  00052	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  00056	75 27		 jne	 SHORT $LN7@ReleasePoo
  00058	45 33 c9	 xor	 r9d, r9d
  0005b	41 b8 73 00 00
	00		 mov	 r8d, 115		; 00000073H
  00061	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EP@FEOCDHHD@c?3?2home?2public?2desktop?2projects?2@FNODOBFM@
  00068	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@FECNDOKE@buffer?9?$DOInUse?$AA@FNODOBFM@
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  00075	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
  0007d	eb 08		 jmp	 SHORT $LN8@ReleasePoo
$LN7@ReleasePoo:
  0007f	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
$LN8@ReleasePoo:

; 116  : 
; 117  : 			buffer->InUse = FALSE;

  00087	48 8b 44 24 20	 mov	 rax, QWORD PTR buffer$[rsp]
  0008c	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0

; 118  : 			break;

  00093	eb 02		 jmp	 SHORT $LN2@ReleasePoo
$LN1@ReleasePoo:

; 119  : 		}
; 120  : 	}

  00095	eb 91		 jmp	 SHORT $LN3@ReleasePoo
$LN2@ReleasePoo:

; 121  : 
; 122  : 	ReleaseBufferPoolMutex (queue);

  00097	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  0009c	e8 00 00 00 00	 call	 ReleaseBufferPoolMutex

; 123  : 	KeSetEvent (&queue->PoolBufferFreeEvent, IO_DISK_INCREMENT, FALSE);

  000a1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  000a6	48 81 c1 60 02
	00 00		 add	 rcx, 608		; 00000260H
  000ad	45 33 c0	 xor	 r8d, r8d
  000b0	ba 01 00 00 00	 mov	 edx, 1
  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 124  : }

  000bb	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bf	c3		 ret	 0
ReleasePoolBuffer ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetPoolBuffer DD imagerel GetPoolBuffer
	DD	imagerel GetPoolBuffer+483
	DD	imagerel $unwind$GetPoolBuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetPoolBuffer DD 010d01H
	DD	0a20dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GetPoolBuffer
_TEXT	SEGMENT
bufferAddress$ = 48
requestedSizePresentInPool$ = 56
buffer$ = 64
newBuffer$29394 = 72
queue$ = 96
requestedSize$ = 104
GetPoolBuffer PROC					; COMDAT

; 35   : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 36   : 	EncryptedIoQueueBuffer *buffer;
; 37   : 	void *bufferAddress = NULL;

  0000d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR bufferAddress$[rsp], 0

; 38   : 	BOOL requestedSizePresentInPool = FALSE;

  00016	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR requestedSizePresentInPool$[rsp], 0
$LN17@GetPoolBuf:

; 39   : 
; 40   : 	while (TRUE)

  0001e	33 c0		 xor	 eax, eax
  00020	83 f8 01	 cmp	 eax, 1
  00023	0f 84 b0 01 00
	00		 je	 $LN16@GetPoolBuf

; 41   : 	{
; 42   : 		AcquireBufferPoolMutex (queue);

  00029	48 8b 4c 24 60	 mov	 rcx, QWORD PTR queue$[rsp]
  0002e	e8 00 00 00 00	 call	 AcquireBufferPoolMutex

; 43   : 
; 44   : 		for (buffer = queue->FirstPoolBuffer; ; buffer = buffer->NextBuffer)

  00033	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  00038	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0003c	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax
  00041	eb 0d		 jmp	 SHORT $LN15@GetPoolBuf
$LN14@GetPoolBuf:
  00043	48 8b 44 24 40	 mov	 rax, QWORD PTR buffer$[rsp]
  00048	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004b	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax
$LN15@GetPoolBuf:

; 45   : 		{
; 46   : 			if (buffer && buffer->Size == requestedSize)

  00050	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00056	74 40		 je	 SHORT $LN12@GetPoolBuf
  00058	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  0005d	8b 44 24 68	 mov	 eax, DWORD PTR requestedSize$[rsp]
  00061	39 41 10	 cmp	 DWORD PTR [rcx+16], eax
  00064	75 32		 jne	 SHORT $LN12@GetPoolBuf

; 47   : 			{
; 48   : 				requestedSizePresentInPool = TRUE;

  00066	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR requestedSizePresentInPool$[rsp], 1

; 49   : 
; 50   : 				if (!buffer->InUse)

  0006e	48 8b 44 24 40	 mov	 rax, QWORD PTR buffer$[rsp]
  00073	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  00077	75 1f		 jne	 SHORT $LN11@GetPoolBuf

; 51   : 				{
; 52   : 					// Reuse a free buffer
; 53   : 					buffer->InUse = TRUE;

  00079	48 8b 44 24 40	 mov	 rax, QWORD PTR buffer$[rsp]
  0007e	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [rax+20], 1

; 54   : 					bufferAddress = buffer->Address;

  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR buffer$[rsp]
  0008a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0008e	48 89 44 24 30	 mov	 QWORD PTR bufferAddress$[rsp], rax

; 55   : 					break;

  00093	e9 ef 00 00 00	 jmp	 $LN13@GetPoolBuf
$LN11@GetPoolBuf:
$LN12@GetPoolBuf:

; 56   : 				}
; 57   : 			}
; 58   : 
; 59   : 			if (!buffer || !buffer->NextBuffer)

  00098	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  0009e	74 0f		 je	 SHORT $LN9@GetPoolBuf
  000a0	48 8b 44 24 40	 mov	 rax, QWORD PTR buffer$[rsp]
  000a5	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000a9	0f 85 d3 00 00
	00		 jne	 $LN10@GetPoolBuf
$LN9@GetPoolBuf:

; 60   : 			{
; 61   : 				EncryptedIoQueueBuffer *newBuffer;
; 62   : 
; 63   : 				if (requestedSizePresentInPool && !queue->StartPending)

  000af	83 7c 24 38 00	 cmp	 DWORD PTR requestedSizePresentInPool$[rsp], 0
  000b4	74 14		 je	 SHORT $LN8@GetPoolBuf
  000b6	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  000bb	8b 80 88 02 00
	00		 mov	 eax, DWORD PTR [rax+648]
  000c1	85 c0		 test	 eax, eax
  000c3	75 05		 jne	 SHORT $LN8@GetPoolBuf

; 64   : 					break;

  000c5	e9 bd 00 00 00	 jmp	 $LN13@GetPoolBuf
$LN8@GetPoolBuf:

; 65   : 
; 66   : 				// Allocate a new buffer
; 67   : 				newBuffer = TCalloc (sizeof (EncryptedIoQueueBuffer));

  000ca	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  000d0	ba 18 00 00 00	 mov	 edx, 24
  000d5	33 c9		 xor	 ecx, ecx
  000d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  000dd	48 89 44 24 48	 mov	 QWORD PTR newBuffer$29394[rsp], rax

; 68   : 				if (!newBuffer)

  000e2	48 83 7c 24 48
	00		 cmp	 QWORD PTR newBuffer$29394[rsp], 0
  000e8	75 0e		 jne	 SHORT $LN7@GetPoolBuf

; 69   : 				{
; 70   : 					bufferAddress = NULL;

  000ea	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR bufferAddress$[rsp], 0

; 71   : 					break;

  000f3	e9 8f 00 00 00	 jmp	 $LN13@GetPoolBuf
$LN7@GetPoolBuf:

; 72   : 				}
; 73   : 
; 74   : 				bufferAddress = TCalloc (requestedSize);

  000f8	8b 54 24 68	 mov	 edx, DWORD PTR requestedSize$[rsp]
  000fc	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  00102	33 c9		 xor	 ecx, ecx
  00104	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  0010a	48 89 44 24 30	 mov	 QWORD PTR bufferAddress$[rsp], rax

; 75   : 				if (bufferAddress)

  0010f	48 83 7c 24 30
	00		 cmp	 QWORD PTR bufferAddress$[rsp], 0
  00115	74 59		 je	 SHORT $LN6@GetPoolBuf

; 76   : 				{
; 77   : 					newBuffer->NextBuffer = NULL;

  00117	48 8b 44 24 48	 mov	 rax, QWORD PTR newBuffer$29394[rsp]
  0011c	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 78   : 					newBuffer->Address = bufferAddress;

  00123	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newBuffer$29394[rsp]
  00128	48 8b 44 24 30	 mov	 rax, QWORD PTR bufferAddress$[rsp]
  0012d	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 79   : 					newBuffer->Size = requestedSize;

  00131	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newBuffer$29394[rsp]
  00136	8b 44 24 68	 mov	 eax, DWORD PTR requestedSize$[rsp]
  0013a	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 80   : 					newBuffer->InUse = TRUE;

  0013d	48 8b 44 24 48	 mov	 rax, QWORD PTR newBuffer$29394[rsp]
  00142	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [rax+20], 1

; 81   : 
; 82   : 					if (!buffer)

  00149	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  0014f	75 10		 jne	 SHORT $LN5@GetPoolBuf

; 83   : 						queue->FirstPoolBuffer = newBuffer;

  00151	48 8b 4c 24 60	 mov	 rcx, QWORD PTR queue$[rsp]
  00156	48 8b 44 24 48	 mov	 rax, QWORD PTR newBuffer$29394[rsp]
  0015b	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax

; 84   : 					else

  0015f	eb 0d		 jmp	 SHORT $LN4@GetPoolBuf
$LN5@GetPoolBuf:

; 85   : 						buffer->NextBuffer = newBuffer;

  00161	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00166	48 8b 44 24 48	 mov	 rax, QWORD PTR newBuffer$29394[rsp]
  0016b	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN4@GetPoolBuf:

; 86   : 				}
; 87   : 				else

  0016e	eb 10		 jmp	 SHORT $LN3@GetPoolBuf
$LN6@GetPoolBuf:

; 88   : 					TCfree (newBuffer);

  00170	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00175	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newBuffer$29394[rsp]
  0017a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN3@GetPoolBuf:

; 89   : 
; 90   : 				break;

  00180	eb 05		 jmp	 SHORT $LN13@GetPoolBuf
$LN10@GetPoolBuf:

; 91   : 			}
; 92   : 		}

  00182	e9 bc fe ff ff	 jmp	 $LN14@GetPoolBuf
$LN13@GetPoolBuf:

; 93   : 
; 94   : 		ReleaseBufferPoolMutex (queue);

  00187	48 8b 4c 24 60	 mov	 rcx, QWORD PTR queue$[rsp]
  0018c	e8 00 00 00 00	 call	 ReleaseBufferPoolMutex

; 95   : 
; 96   : 		if (bufferAddress || !requestedSizePresentInPool || queue->StartPending)

  00191	48 83 7c 24 30
	00		 cmp	 QWORD PTR bufferAddress$[rsp], 0
  00197	75 16		 jne	 SHORT $LN1@GetPoolBuf
  00199	83 7c 24 38 00	 cmp	 DWORD PTR requestedSizePresentInPool$[rsp], 0
  0019e	74 0f		 je	 SHORT $LN1@GetPoolBuf
  001a0	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  001a5	8b 80 88 02 00
	00		 mov	 eax, DWORD PTR [rax+648]
  001ab	85 c0		 test	 eax, eax
  001ad	74 02		 je	 SHORT $LN2@GetPoolBuf
$LN1@GetPoolBuf:

; 97   : 			break;

  001af	eb 28		 jmp	 SHORT $LN16@GetPoolBuf
$LN2@GetPoolBuf:

; 98   : 
; 99   : 		KeWaitForSingleObject (&queue->PoolBufferFreeEvent, Executive, KernelMode, FALSE, NULL);

  001b1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR queue$[rsp]
  001b6	48 81 c1 60 02
	00 00		 add	 rcx, 608		; 00000260H
  001bd	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  001c6	45 33 c9	 xor	 r9d, r9d
  001c9	45 33 c0	 xor	 r8d, r8d
  001cc	33 d2		 xor	 edx, edx
  001ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 100  : 	}

  001d4	e9 45 fe ff ff	 jmp	 $LN17@GetPoolBuf
$LN16@GetPoolBuf:

; 101  : 
; 102  : 	return bufferAddress;

  001d9	48 8b 44 24 30	 mov	 rax, QWORD PTR bufferAddress$[rsp]

; 103  : }

  001de	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001e2	c3		 ret	 0
GetPoolBuffer ENDP
PUBLIC	EncryptedIoQueueStop
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptedIoQueueStop DD imagerel $LN7
	DD	imagerel $LN7+382
	DD	imagerel $unwind$EncryptedIoQueueStop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptedIoQueueStop DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EncryptedIoQueueStop
_TEXT	SEGMENT
tv71 = 48
queue$ = 80
EncryptedIoQueueStop PROC				; COMDAT

; 983  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 984  : 	ASSERT (!queue->StopPending);

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR queue$[rsp]
  0000e	8b 80 98 02 00
	00		 mov	 eax, DWORD PTR [rax+664]
  00014	85 c0		 test	 eax, eax
  00016	74 27		 je	 SHORT $LN5@EncryptedI@4
  00018	45 33 c9	 xor	 r9d, r9d
  0001b	41 b8 d8 03 00
	00		 mov	 r8d, 984		; 000003d8H
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EP@FEOCDHHD@c?3?2home?2public?2desktop?2projects?2@FNODOBFM@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@PAKNKFEC@?$CBqueue?9?$DOStopPending?$AA@FNODOBFM@
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  00035	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
  0003d	eb 08		 jmp	 SHORT $LN6@EncryptedI@4
$LN5@EncryptedI@4:
  0003f	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv71[rsp], 1
$LN6@EncryptedI@4:

; 985  : 	queue->StopPending = TRUE;

  00047	48 8b 44 24 50	 mov	 rax, QWORD PTR queue$[rsp]
  0004c	c7 80 98 02 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+664], 1
$LN2@EncryptedI@4:

; 986  : 	
; 987  : 	while (InterlockedExchangeAdd (&queue->OutstandingIoCount, 0) > 0)

  00056	48 8b 44 24 50	 mov	 rax, QWORD PTR queue$[rsp]
  0005b	48 05 38 02 00
	00		 add	 rax, 568		; 00000238H
  00061	33 c9		 xor	 ecx, ecx
  00063	f0 0f c1 08	 lock xadd DWORD PTR [rax], ecx
  00067	8b c1		 mov	 eax, ecx
  00069	85 c0		 test	 eax, eax
  0006b	7e 25		 jle	 SHORT $LN1@EncryptedI@4

; 988  : 	{
; 989  : 		KeWaitForSingleObject (&queue->NoOutstandingIoEvent, Executive, KernelMode, FALSE, NULL);

  0006d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR queue$[rsp]
  00072	48 81 c1 40 02
	00 00		 add	 rcx, 576		; 00000240H
  00079	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00082	45 33 c9	 xor	 r9d, r9d
  00085	45 33 c0	 xor	 r8d, r8d
  00088	33 d2		 xor	 edx, edx
  0008a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 990  : 	}

  00090	eb c4		 jmp	 SHORT $LN2@EncryptedI@4
$LN1@EncryptedI@4:

; 991  : 
; 992  : 	Dump ("Queue stopping  out=%d\n", queue->OutstandingIoCount);

  00092	48 8b 44 24 50	 mov	 rax, QWORD PTR queue$[rsp]
  00097	8b 90 38 02 00
	00		 mov	 edx, DWORD PTR [rax+568]
  0009d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@FIKKAEEK@Queue?5stopping?5?5out?$DN?$CFd?6?$AA@FNODOBFM@
  000a4	e8 00 00 00 00	 call	 DbgPrint

; 993  : 
; 994  : 	queue->ThreadExitRequested = TRUE;

  000a9	4c 8b 5c 24 50	 mov	 r11, QWORD PTR queue$[rsp]
  000ae	41 c7 83 8c 02
	00 00 01 00 00
	00		 mov	 DWORD PTR [r11+652], 1

; 995  : 
; 996  : 	TCStopThread (queue->MainThread, &queue->MainThreadQueueNotEmptyEvent);

  000b9	48 8b 54 24 50	 mov	 rdx, QWORD PTR queue$[rsp]
  000be	48 81 c2 38 01
	00 00		 add	 rdx, 312		; 00000138H
  000c5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR queue$[rsp]
  000ca	48 8b 89 18 01
	00 00		 mov	 rcx, QWORD PTR [rcx+280]
  000d1	e8 00 00 00 00	 call	 TCStopThread

; 997  : 	TCStopThread (queue->IoThread, &queue->IoThreadQueueNotEmptyEvent);

  000d6	48 8b 54 24 50	 mov	 rdx, QWORD PTR queue$[rsp]
  000db	48 81 c2 70 01
	00 00		 add	 rdx, 368		; 00000170H
  000e2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR queue$[rsp]
  000e7	48 8b 89 50 01
	00 00		 mov	 rcx, QWORD PTR [rcx+336]
  000ee	e8 00 00 00 00	 call	 TCStopThread

; 998  : 	TCStopThread (queue->CompletionThread, &queue->CompletionThreadQueueNotEmptyEvent);

  000f3	48 8b 54 24 50	 mov	 rdx, QWORD PTR queue$[rsp]
  000f8	48 81 c2 a8 01
	00 00		 add	 rdx, 424		; 000001a8H
  000ff	48 8b 4c 24 50	 mov	 rcx, QWORD PTR queue$[rsp]
  00104	48 8b 89 88 01
	00 00		 mov	 rcx, QWORD PTR [rcx+392]
  0010b	e8 00 00 00 00	 call	 TCStopThread

; 999  : 
; 1000 : 	TCfree (queue->FragmentBufferA);

  00110	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00115	48 8b 4c 24 50	 mov	 rcx, QWORD PTR queue$[rsp]
  0011a	48 8b 89 c0 01
	00 00		 mov	 rcx, QWORD PTR [rcx+448]
  00121	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 1001 : 	TCfree (queue->FragmentBufferB);

  00127	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  0012c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR queue$[rsp]
  00131	48 8b 89 c8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+456]
  00138	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 1002 : 	TCfree (queue->ReadAheadBuffer);

  0013e	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00143	48 8b 4c 24 50	 mov	 rcx, QWORD PTR queue$[rsp]
  00148	48 8b 89 28 02
	00 00		 mov	 rcx, QWORD PTR [rcx+552]
  0014f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 1003 : 
; 1004 : 	FreePoolBuffers (queue);

  00155	48 8b 4c 24 50	 mov	 rcx, QWORD PTR queue$[rsp]
  0015a	e8 00 00 00 00	 call	 FreePoolBuffers

; 1005 : 
; 1006 : 	Dump ("Queue stopped  out=%d\n", queue->OutstandingIoCount);

  0015f	4c 8b 5c 24 50	 mov	 r11, QWORD PTR queue$[rsp]
  00164	41 8b 93 38 02
	00 00		 mov	 edx, DWORD PTR [r11+568]
  0016b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@LHJJPAN@Queue?5stopped?5?5out?$DN?$CFd?6?$AA@FNODOBFM@
  00172	e8 00 00 00 00	 call	 DbgPrint

; 1007 : 	return STATUS_SUCCESS;

  00177	33 c0		 xor	 eax, eax

; 1008 : }

  00179	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0017d	c3		 ret	 0
EncryptedIoQueueStop ENDP
_TEXT	ENDS
PUBLIC	EncryptedIoQueueAddIrp
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptedIoQueueAddIrp DD imagerel $LN5
	DD	imagerel $LN5+241
	DD	imagerel $unwind$EncryptedIoQueueAddIrp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptedIoQueueAddIrp DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EncryptedIoQueueAddIrp
_TEXT	SEGMENT
status$ = 48
queue$ = 80
irp$ = 88
EncryptedIoQueueAddIrp PROC				; COMDAT

; 760  : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 761  : 	NTSTATUS status;
; 762  : 
; 763  : 	InterlockedIncrement (&queue->OutstandingIoCount);

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR queue$[rsp]
  00013	48 05 38 02 00
	00		 add	 rax, 568		; 00000238H
  00019	f0 83 00 01	 lock add DWORD PTR [rax], 1

; 764  : 	if (queue->StopPending)

  0001d	48 8b 44 24 50	 mov	 rax, QWORD PTR queue$[rsp]
  00022	8b 80 98 02 00
	00		 mov	 eax, DWORD PTR [rax+664]
  00028	85 c0		 test	 eax, eax
  0002a	74 24		 je	 SHORT $LN2@EncryptedI@5

; 765  : 	{
; 766  : 		Dump ("STATUS_DEVICE_NOT_READY  out=%d\n", queue->OutstandingIoCount);

  0002c	48 8b 44 24 50	 mov	 rax, QWORD PTR queue$[rsp]
  00031	8b 90 38 02 00
	00		 mov	 edx, DWORD PTR [rax+568]
  00037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CB@JMNJFHBF@STATUS_DEVICE_NOT_READY?5?5out?$DN?$CFd?6@FNODOBFM@
  0003e	e8 00 00 00 00	 call	 DbgPrint

; 767  : 		status = STATUS_DEVICE_NOT_READY;

  00043	c7 44 24 30 a3
	00 00 c0	 mov	 DWORD PTR status$[rsp], -1073741661 ; ffffffffc00000a3H

; 768  : 		goto err;

  0004b	e9 8e 00 00 00	 jmp	 $err$29770
$LN2@EncryptedI@5:

; 769  : 	}
; 770  : 
; 771  : 	status = IoAcquireRemoveLock (&queue->RemoveLock, irp);

  00050	48 8b 4c 24 50	 mov	 rcx, QWORD PTR queue$[rsp]
  00055	48 81 c1 a0 00
	00 00		 add	 rcx, 160		; 000000a0H
  0005c	c7 44 24 20 78
	00 00 00	 mov	 DWORD PTR [rsp+32], 120	; 00000078H
  00064	41 b9 03 03 00
	00		 mov	 r9d, 771		; 00000303H
  0006a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0EP@FEOCDHHD@c?3?2home?2public?2desktop?2projects?2@FNODOBFM@
  00071	48 8b 54 24 58	 mov	 rdx, QWORD PTR irp$[rsp]
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAcquireRemoveLockEx
  0007c	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax

; 772  : 	if (!NT_SUCCESS (status))

  00080	83 7c 24 30 00	 cmp	 DWORD PTR status$[rsp], 0
  00085	7d 02		 jge	 SHORT $LN1@EncryptedI@5

; 773  : 		goto err;

  00087	eb 55		 jmp	 SHORT $err$29770
$LN1@EncryptedI@5:

; 774  : 
; 775  : #ifdef TC_TRACE_IO_QUEUE
; 776  : 	{
; 777  : 		PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (irp);
; 778  : 		Dump ("* %I64d [%I64d] %c len=%d out=%d\n", irpSp->MajorFunction == IRP_MJ_WRITE ? irpSp->Parameters.Write.ByteOffset : irpSp->Parameters.Read.ByteOffset, GetElapsedTime (&queue->LastPerformanceCounter), irpSp->MajorFunction == IRP_MJ_WRITE ? 'W' : 'R', irpSp->MajorFunction == IRP_MJ_WRITE ? irpSp->Parameters.Write.Length : irpSp->Parameters.Read.Length, queue->OutstandingIoCount);
; 779  : 	}
; 780  : #endif
; 781  : 
; 782  : 	IoMarkIrpPending (irp);

  00089	48 8b 4c 24 58	 mov	 rcx, QWORD PTR irp$[rsp]
  0008e	e8 00 00 00 00	 call	 IoMarkIrpPending

; 783  : 
; 784  : 	ExInterlockedInsertTailList (&queue->MainThreadQueue, &irp->Tail.Overlay.ListEntry, &queue->MainThreadQueueLock);

  00093	4c 8b 44 24 50	 mov	 r8, QWORD PTR queue$[rsp]
  00098	49 81 c0 30 01
	00 00		 add	 r8, 304			; 00000130H
  0009f	48 8b 54 24 58	 mov	 rdx, QWORD PTR irp$[rsp]
  000a4	48 81 c2 a8 00
	00 00		 add	 rdx, 168		; 000000a8H
  000ab	48 8b 4c 24 50	 mov	 rcx, QWORD PTR queue$[rsp]
  000b0	48 81 c1 20 01
	00 00		 add	 rcx, 288		; 00000120H
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExInterlockedInsertTailList

; 785  : 	KeSetEvent (&queue->MainThreadQueueNotEmptyEvent, IO_DISK_INCREMENT, FALSE);

  000bd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR queue$[rsp]
  000c2	48 81 c1 38 01
	00 00		 add	 rcx, 312		; 00000138H
  000c9	45 33 c0	 xor	 r8d, r8d
  000cc	ba 01 00 00 00	 mov	 edx, 1
  000d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 786  : 	
; 787  : 	return STATUS_PENDING;

  000d7	b8 03 01 00 00	 mov	 eax, 259		; 00000103H
  000dc	eb 0e		 jmp	 SHORT $LN3@EncryptedI@5
$err$29770:

; 788  : 
; 789  : err:
; 790  : 	DecrementOutstandingIoCount (queue);

  000de	48 8b 4c 24 50	 mov	 rcx, QWORD PTR queue$[rsp]
  000e3	e8 00 00 00 00	 call	 DecrementOutstandingIoCount

; 791  : 	return status;

  000e8	8b 44 24 30	 mov	 eax, DWORD PTR status$[rsp]
$LN3@EncryptedI@5:

; 792  : }

  000ec	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000f0	c3		 ret	 0
EncryptedIoQueueAddIrp ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCCachedRead DD imagerel TCCachedRead
	DD	imagerel TCCachedRead+331
	DD	imagerel $unwind$TCCachedRead
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCCachedRead DD 031a01H
	DD	07016a21aH
	DD	06015H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT TCCachedRead
_TEXT	SEGMENT
queue$ = 112
ioStatus$ = 120
buffer$ = 128
offset$ = 136
length$ = 144
TCCachedRead PROC					; COMDAT

; 274  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 275  : 	queue->LastReadOffset = offset;

  0001a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR queue$[rsp]
  0001f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR offset$[rsp]
  00027	48 89 81 08 02
	00 00		 mov	 QWORD PTR [rcx+520], rax

; 276  : 	queue->LastReadLength = length;

  0002e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR queue$[rsp]
  00033	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR length$[rsp]
  0003a	89 81 10 02 00
	00		 mov	 DWORD PTR [rcx+528], eax

; 277  : 
; 278  : 	if (queue->ReadAheadBufferValid && queue->ReadAheadOffset.QuadPart == offset.QuadPart && queue->ReadAheadLength >= length)

  00040	48 8b 44 24 70	 mov	 rax, QWORD PTR queue$[rsp]
  00045	83 b8 00 02 00
	00 00		 cmp	 DWORD PTR [rax+512], 0
  0004c	74 74		 je	 SHORT $LN3@TCCachedRe
  0004e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR queue$[rsp]
  00053	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR offset$[rsp]
  0005b	48 39 81 18 02
	00 00		 cmp	 QWORD PTR [rcx+536], rax
  00062	75 5e		 jne	 SHORT $LN3@TCCachedRe
  00064	48 8b 4c 24 70	 mov	 rcx, QWORD PTR queue$[rsp]
  00069	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR length$[rsp]
  00070	39 81 20 02 00
	00		 cmp	 DWORD PTR [rcx+544], eax
  00076	72 4a		 jb	 SHORT $LN3@TCCachedRe

; 279  : 	{
; 280  : 		memcpy (buffer, queue->ReadAheadBuffer, length);

  00078	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR length$[rsp]
  0007f	48 8b 74 24 70	 mov	 rsi, QWORD PTR queue$[rsp]
  00084	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR buffer$[rsp]
  0008c	48 8b b6 28 02
	00 00		 mov	 rsi, QWORD PTR [rsi+552]
  00093	f3 a4		 rep movsb

; 281  : 
; 282  : 		if (!queue->IsFilterDevice)

  00095	48 8b 44 24 70	 mov	 rax, QWORD PTR queue$[rsp]
  0009a	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  0009e	75 1b		 jne	 SHORT $LN2@TCCachedRe

; 283  : 		{
; 284  : 			ioStatus->Information = length;

  000a0	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR length$[rsp]
  000a7	48 8b 44 24 78	 mov	 rax, QWORD PTR ioStatus$[rsp]
  000ac	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 285  : 			ioStatus->Status = STATUS_SUCCESS;

  000b0	48 8b 44 24 78	 mov	 rax, QWORD PTR ioStatus$[rsp]
  000b5	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN2@TCCachedRe:

; 286  : 		}
; 287  : 
; 288  : 		return STATUS_SUCCESS;

  000bb	33 c0		 xor	 eax, eax
  000bd	e9 82 00 00 00	 jmp	 $LN4@TCCachedRe
$LN3@TCCachedRe:

; 289  : 	}
; 290  : 
; 291  : 	if (queue->IsFilterDevice)

  000c2	48 8b 44 24 70	 mov	 rax, QWORD PTR queue$[rsp]
  000c7	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  000cb	74 28		 je	 SHORT $LN1@TCCachedRe

; 292  : 		return TCReadDevice (queue->LowerDeviceObject, buffer, offset, length);

  000cd	44 8b 8c 24 90
	00 00 00	 mov	 r9d, DWORD PTR length$[rsp]
  000d5	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR offset$[rsp]
  000dd	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR buffer$[rsp]
  000e5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR queue$[rsp]
  000ea	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  000ee	e8 00 00 00 00	 call	 TCReadDevice
  000f3	eb 4f		 jmp	 SHORT $LN4@TCCachedRe
$LN1@TCCachedRe:

; 293  : 
; 294  : 	return ZwReadFile (queue->HostFileHandle, NULL, NULL, NULL, ioStatus, buffer, length, &offset, NULL);

  000f5	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  000fe	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR offset$[rsp]
  00106	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0010b	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR length$[rsp]
  00112	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00116	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR buffer$[rsp]
  0011e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00123	48 8b 44 24 78	 mov	 rax, QWORD PTR ioStatus$[rsp]
  00128	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0012d	45 33 c9	 xor	 r9d, r9d
  00130	45 33 c0	 xor	 r8d, r8d
  00133	33 d2		 xor	 edx, edx
  00135	48 8b 4c 24 70	 mov	 rcx, QWORD PTR queue$[rsp]
  0013a	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0013e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwReadFile
$LN4@TCCachedRe:

; 295  : }

  00144	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00148	5f		 pop	 rdi
  00149	5e		 pop	 rsi
  0014a	c3		 ret	 0
TCCachedRead ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$OnItemCompleted DD imagerel OnItemCompleted
	DD	imagerel OnItemCompleted+193
	DD	imagerel $unwind$OnItemCompleted
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$OnItemCompleted DD 010d01H
	DD	0420dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT OnItemCompleted
_TEXT	SEGMENT
item$ = 48
freeItem$ = 56
OnItemCompleted PROC					; COMDAT

; 157  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 158  : 	DecrementOutstandingIoCount (item->Queue);

  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR item$[rsp]
  00012	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00015	e8 00 00 00 00	 call	 DecrementOutstandingIoCount

; 159  : 	IoReleaseRemoveLock (&item->Queue->RemoveLock, item->OriginalIrp);

  0001a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR item$[rsp]
  0001f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00022	48 81 c1 a0 00
	00 00		 add	 rcx, 160		; 000000a0H
  00029	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  0002f	48 8b 54 24 30	 mov	 rdx, QWORD PTR item$[rsp]
  00034	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 160  : 
; 161  : 	if (NT_SUCCESS (item->Status))

  0003e	4c 8b 5c 24 30	 mov	 r11, QWORD PTR item$[rsp]
  00043	41 83 7b 20 00	 cmp	 DWORD PTR [r11+32], 0
  00048	7c 59		 jl	 SHORT $LN4@OnItemComp

; 162  : 	{
; 163  : 		if (item->Write)

  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR item$[rsp]
  0004f	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  00053	74 28		 je	 SHORT $LN3@OnItemComp

; 164  : 			item->Queue->TotalBytesWritten += item->OriginalLength;

  00055	48 8b 54 24 30	 mov	 rdx, QWORD PTR item$[rsp]
  0005a	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  0005d	48 8b 44 24 30	 mov	 rax, QWORD PTR item$[rsp]
  00062	8b 48 14	 mov	 ecx, DWORD PTR [rax+20]
  00065	48 03 8a 80 02
	00 00		 add	 rcx, QWORD PTR [rdx+640]
  0006c	48 8b 44 24 30	 mov	 rax, QWORD PTR item$[rsp]
  00071	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00074	48 89 88 80 02
	00 00		 mov	 QWORD PTR [rax+640], rcx

; 165  : 		else

  0007b	eb 26		 jmp	 SHORT $LN2@OnItemComp
$LN3@OnItemComp:

; 166  : 			item->Queue->TotalBytesRead += item->OriginalLength;

  0007d	48 8b 54 24 30	 mov	 rdx, QWORD PTR item$[rsp]
  00082	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00085	48 8b 44 24 30	 mov	 rax, QWORD PTR item$[rsp]
  0008a	8b 48 14	 mov	 ecx, DWORD PTR [rax+20]
  0008d	48 03 8a 78 02
	00 00		 add	 rcx, QWORD PTR [rdx+632]
  00094	48 8b 44 24 30	 mov	 rax, QWORD PTR item$[rsp]
  00099	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0009c	48 89 88 78 02
	00 00		 mov	 QWORD PTR [rax+632], rcx
$LN2@OnItemComp:
$LN4@OnItemComp:

; 167  : 	}
; 168  : 
; 169  : 	if (freeItem)

  000a3	83 7c 24 38 00	 cmp	 DWORD PTR freeItem$[rsp], 0
  000a8	74 12		 je	 SHORT $LN1@OnItemComp

; 170  : 		ReleasePoolBuffer (item->Queue, item);

  000aa	48 8b 54 24 30	 mov	 rdx, QWORD PTR item$[rsp]
  000af	48 8b 4c 24 30	 mov	 rcx, QWORD PTR item$[rsp]
  000b4	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000b7	e8 00 00 00 00	 call	 ReleasePoolBuffer
$LN1@OnItemComp:

; 171  : }

  000bc	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000c0	c3		 ret	 0
OnItemCompleted ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$CompleteOriginalIrp DD imagerel CompleteOriginalIrp
	DD	imagerel CompleteOriginalIrp+78
	DD	imagerel $unwind$CompleteOriginalIrp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CompleteOriginalIrp DD 011201H
	DD	04212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT CompleteOriginalIrp
_TEXT	SEGMENT
item$ = 48
status$ = 56
information$ = 64
CompleteOriginalIrp PROC				; COMDAT

; 175  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 176  : #ifdef TC_TRACE_IO_QUEUE
; 177  : 	Dump ("< %I64d [%I64d] %c status=%x info=%I64d\n", item->OriginalIrpOffset, GetElapsedTime (&item->Queue->LastPerformanceCounter), item->Write ? 'W' : 'R', status, (int64) information);
; 178  : #endif
; 179  : 
; 180  : 	TCCompleteDiskIrp (item->OriginalIrp, status, information);

  00012	4c 8b 44 24 40	 mov	 r8, QWORD PTR information$[rsp]
  00017	8b 54 24 38	 mov	 edx, DWORD PTR status$[rsp]
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR item$[rsp]
  00020	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00024	e8 00 00 00 00	 call	 TCCompleteDiskIrp

; 181  : 
; 182  : 	item->Status = status;

  00029	4c 8b 5c 24 30	 mov	 r11, QWORD PTR item$[rsp]
  0002e	8b 44 24 38	 mov	 eax, DWORD PTR status$[rsp]
  00032	41 89 43 20	 mov	 DWORD PTR [r11+32], eax

; 183  : 	OnItemCompleted (item, TRUE);

  00036	ba 01 00 00 00	 mov	 edx, 1
  0003b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR item$[rsp]
  00040	e8 00 00 00 00	 call	 OnItemCompleted

; 184  : 
; 185  : 	return status;

  00045	8b 44 24 38	 mov	 eax, DWORD PTR status$[rsp]

; 186  : }

  00049	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004d	c3		 ret	 0
CompleteOriginalIrp ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$IoThreadProc DD imagerel IoThreadProc
	DD	imagerel IoThreadProc+2135
	DD	imagerel $unwind$IoThreadProc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IoThreadProc DD 040e01H
	DD	01b010eH
	DD	060067007H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT IoThreadProc
_TEXT	SEGMENT
listEntry$ = 80
queue$ = 88
request$ = 96
status$29557 = 104
subFragment$29581 = 108
subFragmentData$29582 = 112
subFragmentLength$29587 = 120
subFragmentOffset$29586 = 128
remappedOffset$29602 = 136
ioStatus$29611 = 144
readAhead$29625 = 160
ioStatus$29635 = 168
tv80 = 184
tv151 = 188
tv283 = 192
tv357 = 196
tv374 = 200
threadArg$ = 240
IoThreadProc PROC					; COMDAT

; 299  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 300  : 	EncryptedIoQueue *queue = (EncryptedIoQueue *) threadArg;

  0000e	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR threadArg$[rsp]
  00016	48 89 44 24 58	 mov	 QWORD PTR queue$[rsp], rax

; 301  : 	PLIST_ENTRY listEntry;
; 302  : 	EncryptedIoRequest *request;
; 303  : 
; 304  : 	KeSetPriorityThread (KeGetCurrentThread(), LOW_REALTIME_PRIORITY);

  0001b	e8 00 00 00 00	 call	 KeGetCurrentThread
  00020	ba 10 00 00 00	 mov	 edx, 16
  00025	48 8b c8	 mov	 rcx, rax
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetPriorityThread

; 305  : 
; 306  : 	if (!queue->IsFilterDevice && queue->SecurityClientContext)

  0002e	48 8b 54 24 58	 mov	 rdx, QWORD PTR queue$[rsp]
  00033	83 7a 68 00	 cmp	 DWORD PTR [rdx+104], 0
  00037	75 5d		 jne	 SHORT $LN41@IoThreadPr
  00039	48 8b 44 24 58	 mov	 rax, QWORD PTR queue$[rsp]
  0003e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00043	74 51		 je	 SHORT $LN41@IoThreadPr

; 307  : 	{
; 308  : #ifdef DEBUG
; 309  : 		NTSTATUS status =
; 310  : #endif
; 311  : 		SeImpersonateClientEx (queue->SecurityClientContext, NULL);

  00045	33 d2		 xor	 edx, edx
  00047	48 8b 4c 24 58	 mov	 rcx, QWORD PTR queue$[rsp]
  0004c	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeImpersonateClientEx
  00056	89 44 24 68	 mov	 DWORD PTR status$29557[rsp], eax

; 312  : 		ASSERT (NT_SUCCESS (status));

  0005a	83 7c 24 68 00	 cmp	 DWORD PTR status$29557[rsp], 0
  0005f	7d 2a		 jge	 SHORT $LN44@IoThreadPr
  00061	45 33 c9	 xor	 r9d, r9d
  00064	41 b8 38 01 00
	00		 mov	 r8d, 312		; 00000138H
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EP@FEOCDHHD@c?3?2home?2public?2desktop?2projects?2@FNODOBFM@
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@IDPHHPHP@NT_SUCCESS?5?$CIstatus?$CJ?$AA@FNODOBFM@
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  0007e	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv80[rsp], 0
  00089	eb 0b		 jmp	 SHORT $LN45@IoThreadPr
$LN44@IoThreadPr:
  0008b	c7 84 24 b8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv80[rsp], 1
$LN45@IoThreadPr:
$LN41@IoThreadPr:
$LN52@IoThreadPr:
$LN40@IoThreadPr:

; 313  : 	}
; 314  : 
; 315  : 	while (!queue->ThreadExitRequested)

  00096	48 8b 44 24 58	 mov	 rax, QWORD PTR queue$[rsp]
  0009b	8b 80 8c 02 00
	00		 mov	 eax, DWORD PTR [rax+652]
  000a1	85 c0		 test	 eax, eax
  000a3	0f 85 9c 07 00
	00		 jne	 $LN39@IoThreadPr

; 316  : 	{
; 317  : 		if (!NT_SUCCESS (KeWaitForSingleObject (&queue->IoThreadQueueNotEmptyEvent, Executive, KernelMode, FALSE, NULL)))

  000a9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR queue$[rsp]
  000ae	48 81 c1 70 01
	00 00		 add	 rcx, 368		; 00000170H
  000b5	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000be	45 33 c9	 xor	 r9d, r9d
  000c1	45 33 c0	 xor	 r8d, r8d
  000c4	33 d2		 xor	 edx, edx
  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  000cc	85 c0		 test	 eax, eax
  000ce	7d 02		 jge	 SHORT $LN38@IoThreadPr

; 318  : 			continue;

  000d0	eb c4		 jmp	 SHORT $LN40@IoThreadPr
$LN38@IoThreadPr:

; 319  : 
; 320  : 		if (queue->ThreadExitRequested)

  000d2	48 8b 44 24 58	 mov	 rax, QWORD PTR queue$[rsp]
  000d7	8b 80 8c 02 00
	00		 mov	 eax, DWORD PTR [rax+652]
  000dd	85 c0		 test	 eax, eax
  000df	74 05		 je	 SHORT $LN37@IoThreadPr

; 321  : 			break;

  000e1	e9 5f 07 00 00	 jmp	 $LN39@IoThreadPr
$LN37@IoThreadPr:
$LN36@IoThreadPr:

; 322  : 
; 323  : 		while ((listEntry = ExInterlockedRemoveHeadList (&queue->IoThreadQueue, &queue->IoThreadQueueLock)))

  000e6	48 8b 54 24 58	 mov	 rdx, QWORD PTR queue$[rsp]
  000eb	48 81 c2 68 01
	00 00		 add	 rdx, 360		; 00000168H
  000f2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR queue$[rsp]
  000f7	48 81 c1 58 01
	00 00		 add	 rcx, 344		; 00000158H
  000fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExInterlockedRemoveHeadList
  00104	48 89 44 24 50	 mov	 QWORD PTR listEntry$[rsp], rax
  00109	48 83 7c 24 50
	00		 cmp	 QWORD PTR listEntry$[rsp], 0
  0010f	0f 84 2b 07 00
	00		 je	 $LN35@IoThreadPr

; 324  : 		{
; 325  : 			InterlockedDecrement (&queue->IoThreadPendingRequestCount);

  00115	48 8b 44 24 58	 mov	 rax, QWORD PTR queue$[rsp]
  0011a	48 05 58 02 00
	00		 add	 rax, 600		; 00000258H
  00120	f0 83 00 ff	 lock add DWORD PTR [rax], -1

; 326  : 			request = CONTAINING_RECORD (listEntry, EncryptedIoRequest, ListEntry);

  00124	48 8b 44 24 50	 mov	 rax, QWORD PTR listEntry$[rsp]
  00129	48 83 e8 40	 sub	 rax, 64			; 00000040H
  0012d	48 89 44 24 60	 mov	 QWORD PTR request$[rsp], rax

; 327  : 			
; 328  : #ifdef TC_TRACE_IO_QUEUE
; 329  : 			Dump ("%c   %I64d [%I64d] roff=%I64d rlen=%d\n", request->Item->Write ? 'W' : 'R', request->Item->OriginalIrpOffset.QuadPart, GetElapsedTime (&queue->LastPerformanceCounter), request->Offset.QuadPart, request->Length);
; 330  : #endif
; 331  : 
; 332  : 			// Perform IO request if no preceding request of the item failed
; 333  : 			if (NT_SUCCESS (request->Item->Status))

  00132	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  00137	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0013a	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  0013e	0f 8c ce 03 00
	00		 jl	 $LN34@IoThreadPr

; 334  : 			{
; 335  : 				if (queue->IsFilterDevice)

  00144	48 8b 44 24 58	 mov	 rax, QWORD PTR queue$[rsp]
  00149	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  0014d	0f 84 e1 02 00
	00		 je	 $LN33@IoThreadPr

; 336  : 				{
; 337  : 					if (queue->RemapEncryptedArea && request->EncryptedLength > 0)

  00153	48 8b 44 24 58	 mov	 rax, QWORD PTR queue$[rsp]
  00158	83 b8 8c 00 00
	00 00		 cmp	 DWORD PTR [rax+140], 0
  0015f	0f 84 4d 02 00
	00		 je	 $LN32@IoThreadPr
  00165	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  0016a	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  0016e	0f 86 3e 02 00
	00		 jbe	 $LN32@IoThreadPr

; 338  : 					{
; 339  : 						if (request->EncryptedLength != request->Length)

  00174	48 8b 4c 24 60	 mov	 rcx, QWORD PTR request$[rsp]
  00179	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  0017e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00181	39 41 28	 cmp	 DWORD PTR [rcx+40], eax
  00184	0f 84 8e 01 00
	00		 je	 $LN31@IoThreadPr

; 340  : 						{
; 341  : 							// Up to three subfragments may be required to handle a partially remapped fragment
; 342  : 							int subFragment;
; 343  : 							byte *subFragmentData = request->Data;

  0018a	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  0018f	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00193	48 89 44 24 70	 mov	 QWORD PTR subFragmentData$29582[rsp], rax

; 344  : 
; 345  : 							for (subFragment = 0 ; subFragment < 3; ++subFragment)

  00198	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR subFragment$29581[rsp], 0
  001a0	eb 0b		 jmp	 SHORT $LN30@IoThreadPr
$LN29@IoThreadPr:
  001a2	8b 44 24 6c	 mov	 eax, DWORD PTR subFragment$29581[rsp]
  001a6	83 c0 01	 add	 eax, 1
  001a9	89 44 24 6c	 mov	 DWORD PTR subFragment$29581[rsp], eax
$LN30@IoThreadPr:
  001ad	83 7c 24 6c 03	 cmp	 DWORD PTR subFragment$29581[rsp], 3
  001b2	0f 8d 5b 01 00
	00		 jge	 $LN28@IoThreadPr

; 346  : 							{
; 347  : 								LARGE_INTEGER subFragmentOffset;
; 348  : 								ULONG subFragmentLength;
; 349  : 								subFragmentOffset.QuadPart = request->Offset.QuadPart;

  001b8	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  001bd	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001c1	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR subFragmentOffset$29586[rsp], rax

; 350  : 
; 351  : 								switch (subFragment)

  001c9	8b 44 24 6c	 mov	 eax, DWORD PTR subFragment$29581[rsp]
  001cd	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv151[rsp], eax
  001d4	83 bc 24 bc 00
	00 00 00	 cmp	 DWORD PTR tv151[rsp], 0
  001dc	74 19		 je	 SHORT $LN25@IoThreadPr
  001de	83 bc 24 bc 00
	00 00 01	 cmp	 DWORD PTR tv151[rsp], 1
  001e6	74 20		 je	 SHORT $LN24@IoThreadPr
  001e8	83 bc 24 bc 00
	00 00 02	 cmp	 DWORD PTR tv151[rsp], 2
  001f0	74 4c		 je	 SHORT $LN23@IoThreadPr
  001f2	e9 94 00 00 00	 jmp	 $LN26@IoThreadPr
$LN25@IoThreadPr:

; 352  : 								{
; 353  : 								case 0:
; 354  : 									subFragmentLength = (ULONG) request->EncryptedOffset;

  001f7	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  001fc	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  001ff	89 44 24 78	 mov	 DWORD PTR subFragmentLength$29587[rsp], eax

; 355  : 									break;

  00203	e9 83 00 00 00	 jmp	 $LN26@IoThreadPr
$LN24@IoThreadPr:

; 356  : 
; 357  : 								case 1:
; 358  : 									subFragmentOffset.QuadPart += request->EncryptedOffset + queue->RemappedAreaOffset;

  00208	48 8b 4c 24 60	 mov	 rcx, QWORD PTR request$[rsp]
  0020d	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00211	48 8b 44 24 58	 mov	 rax, QWORD PTR queue$[rsp]
  00216	48 03 88 90 00
	00 00		 add	 rcx, QWORD PTR [rax+144]
  0021d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR subFragmentOffset$29586[rsp]
  00225	48 03 c1	 add	 rax, rcx
  00228	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR subFragmentOffset$29586[rsp], rax

; 359  : 									subFragmentLength = request->EncryptedLength;

  00230	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  00235	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00238	89 44 24 78	 mov	 DWORD PTR subFragmentLength$29587[rsp], eax

; 360  : 									break;

  0023c	eb 4d		 jmp	 SHORT $LN26@IoThreadPr
$LN23@IoThreadPr:

; 361  : 
; 362  : 								case 2:
; 363  : 									subFragmentOffset.QuadPart += request->EncryptedOffset + request->EncryptedLength;

  0023e	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  00243	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00246	48 8b 4c 24 60	 mov	 rcx, QWORD PTR request$[rsp]
  0024b	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0024f	48 03 c8	 add	 rcx, rax
  00252	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR subFragmentOffset$29586[rsp]
  0025a	48 03 c1	 add	 rax, rcx
  0025d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR subFragmentOffset$29586[rsp], rax

; 364  : 									subFragmentLength = (ULONG) (request->Length - (request->EncryptedOffset + request->EncryptedLength));

  00265	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  0026a	8b 50 18	 mov	 edx, DWORD PTR [rax+24]
  0026d	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  00272	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00275	48 8b 4c 24 60	 mov	 rcx, QWORD PTR request$[rsp]
  0027a	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0027e	48 03 c8	 add	 rcx, rax
  00281	48 8b c2	 mov	 rax, rdx
  00284	48 2b c1	 sub	 rax, rcx
  00287	89 44 24 78	 mov	 DWORD PTR subFragmentLength$29587[rsp], eax
$LN26@IoThreadPr:

; 365  : 									break;
; 366  : 								}
; 367  : 
; 368  : 								if (subFragmentLength > 0)

  0028b	83 7c 24 78 00	 cmp	 DWORD PTR subFragmentLength$29587[rsp], 0
  00290	76 7c		 jbe	 SHORT $LN22@IoThreadPr

; 369  : 								{
; 370  : 									if (request->Item->Write)

  00292	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  00297	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0029a	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  0029e	74 2f		 je	 SHORT $LN21@IoThreadPr

; 371  : 										request->Item->Status = TCWriteDevice (queue->LowerDeviceObject, subFragmentData, subFragmentOffset, subFragmentLength);

  002a0	44 8b 4c 24 78	 mov	 r9d, DWORD PTR subFragmentLength$29587[rsp]
  002a5	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR subFragmentOffset$29586[rsp]
  002ad	48 8b 54 24 70	 mov	 rdx, QWORD PTR subFragmentData$29582[rsp]
  002b2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR queue$[rsp]
  002b7	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  002bb	e8 00 00 00 00	 call	 TCWriteDevice
  002c0	8b d0		 mov	 edx, eax
  002c2	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  002c7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002ca	89 50 20	 mov	 DWORD PTR [rax+32], edx

; 372  : 									else

  002cd	eb 2e		 jmp	 SHORT $LN20@IoThreadPr
$LN21@IoThreadPr:

; 373  : 										request->Item->Status = TCCachedRead (queue, NULL, subFragmentData, subFragmentOffset, subFragmentLength);

  002cf	8b 44 24 78	 mov	 eax, DWORD PTR subFragmentLength$29587[rsp]
  002d3	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  002d7	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR subFragmentOffset$29586[rsp]
  002df	4c 8b 44 24 70	 mov	 r8, QWORD PTR subFragmentData$29582[rsp]
  002e4	33 d2		 xor	 edx, edx
  002e6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR queue$[rsp]
  002eb	e8 00 00 00 00	 call	 TCCachedRead
  002f0	8b d0		 mov	 edx, eax
  002f2	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  002f7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002fa	89 50 20	 mov	 DWORD PTR [rax+32], edx
$LN20@IoThreadPr:

; 374  : 
; 375  : 									subFragmentData += subFragmentLength;

  002fd	8b 4c 24 78	 mov	 ecx, DWORD PTR subFragmentLength$29587[rsp]
  00301	48 8b 44 24 70	 mov	 rax, QWORD PTR subFragmentData$29582[rsp]
  00306	48 03 c1	 add	 rax, rcx
  00309	48 89 44 24 70	 mov	 QWORD PTR subFragmentData$29582[rsp], rax
$LN22@IoThreadPr:

; 376  : 								}
; 377  : 							}

  0030e	e9 8f fe ff ff	 jmp	 $LN29@IoThreadPr
$LN28@IoThreadPr:

; 378  : 						}
; 379  : 						else

  00313	e9 98 00 00 00	 jmp	 $LN19@IoThreadPr
$LN31@IoThreadPr:

; 380  : 						{
; 381  : 							// Remap the fragment
; 382  : 							LARGE_INTEGER remappedOffset;
; 383  : 							remappedOffset.QuadPart = request->Offset.QuadPart + queue->RemappedAreaOffset;

  00318	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  0031d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00321	48 8b 4c 24 58	 mov	 rcx, QWORD PTR queue$[rsp]
  00326	48 03 81 90 00
	00 00		 add	 rax, QWORD PTR [rcx+144]
  0032d	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR remappedOffset$29602[rsp], rax

; 384  : 
; 385  : 							if (request->Item->Write)

  00335	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  0033a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0033d	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  00341	74 37		 je	 SHORT $LN18@IoThreadPr

; 386  : 								request->Item->Status = TCWriteDevice (queue->LowerDeviceObject, request->Data, remappedOffset, request->Length);

  00343	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  00348	44 8b 48 18	 mov	 r9d, DWORD PTR [rax+24]
  0034c	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR remappedOffset$29602[rsp]
  00354	48 8b 54 24 60	 mov	 rdx, QWORD PTR request$[rsp]
  00359	48 8b 52 30	 mov	 rdx, QWORD PTR [rdx+48]
  0035d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR queue$[rsp]
  00362	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00366	e8 00 00 00 00	 call	 TCWriteDevice
  0036b	8b d0		 mov	 edx, eax
  0036d	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  00372	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00375	89 50 20	 mov	 DWORD PTR [rax+32], edx

; 387  : 							else

  00378	eb 36		 jmp	 SHORT $LN17@IoThreadPr
$LN18@IoThreadPr:

; 388  : 								request->Item->Status = TCCachedRead (queue, NULL, request->Data, remappedOffset, request->Length);

  0037a	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  0037f	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00382	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00386	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR remappedOffset$29602[rsp]
  0038e	4c 8b 44 24 60	 mov	 r8, QWORD PTR request$[rsp]
  00393	4d 8b 40 30	 mov	 r8, QWORD PTR [r8+48]
  00397	33 d2		 xor	 edx, edx
  00399	48 8b 4c 24 58	 mov	 rcx, QWORD PTR queue$[rsp]
  0039e	e8 00 00 00 00	 call	 TCCachedRead
  003a3	8b d0		 mov	 edx, eax
  003a5	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  003aa	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003ad	89 50 20	 mov	 DWORD PTR [rax+32], edx
$LN17@IoThreadPr:
$LN19@IoThreadPr:

; 389  : 						}
; 390  : 					}
; 391  : 					else

  003b0	eb 7d		 jmp	 SHORT $LN16@IoThreadPr
$LN32@IoThreadPr:

; 392  : 					{
; 393  : 						if (request->Item->Write)

  003b2	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  003b7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003ba	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  003be	74 38		 je	 SHORT $LN15@IoThreadPr

; 394  : 							request->Item->Status = TCWriteDevice (queue->LowerDeviceObject, request->Data, request->Offset, request->Length);

  003c0	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  003c5	44 8b 48 18	 mov	 r9d, DWORD PTR [rax+24]
  003c9	4c 8b 44 24 60	 mov	 r8, QWORD PTR request$[rsp]
  003ce	4d 8b 40 10	 mov	 r8, QWORD PTR [r8+16]
  003d2	48 8b 54 24 60	 mov	 rdx, QWORD PTR request$[rsp]
  003d7	48 8b 52 30	 mov	 rdx, QWORD PTR [rdx+48]
  003db	48 8b 4c 24 58	 mov	 rcx, QWORD PTR queue$[rsp]
  003e0	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  003e4	e8 00 00 00 00	 call	 TCWriteDevice
  003e9	8b d0		 mov	 edx, eax
  003eb	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  003f0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003f3	89 50 20	 mov	 DWORD PTR [rax+32], edx

; 395  : 						else

  003f6	eb 37		 jmp	 SHORT $LN14@IoThreadPr
$LN15@IoThreadPr:

; 396  : 							request->Item->Status = TCCachedRead (queue, NULL, request->Data, request->Offset, request->Length);

  003f8	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  003fd	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00400	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00404	4c 8b 4c 24 60	 mov	 r9, QWORD PTR request$[rsp]
  00409	4d 8b 49 10	 mov	 r9, QWORD PTR [r9+16]
  0040d	4c 8b 44 24 60	 mov	 r8, QWORD PTR request$[rsp]
  00412	4d 8b 40 30	 mov	 r8, QWORD PTR [r8+48]
  00416	33 d2		 xor	 edx, edx
  00418	48 8b 4c 24 58	 mov	 rcx, QWORD PTR queue$[rsp]
  0041d	e8 00 00 00 00	 call	 TCCachedRead
  00422	8b d0		 mov	 edx, eax
  00424	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  00429	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0042c	89 50 20	 mov	 DWORD PTR [rax+32], edx
$LN14@IoThreadPr:
$LN16@IoThreadPr:

; 397  : 					}
; 398  : 				}
; 399  : 				else

  0042f	e9 de 00 00 00	 jmp	 $LN13@IoThreadPr
$LN33@IoThreadPr:

; 400  : 				{
; 401  : 					IO_STATUS_BLOCK ioStatus;
; 402  : 
; 403  : 					if (request->Item->Write)

  00434	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  00439	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0043c	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  00440	74 64		 je	 SHORT $LN12@IoThreadPr

; 404  : 						request->Item->Status = ZwWriteFile (queue->HostFileHandle, NULL, NULL, NULL, &ioStatus, request->Data, request->Length, &request->Offset, NULL);

  00442	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  00447	48 83 c0 10	 add	 rax, 16
  0044b	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00454	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00459	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  0045e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00461	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00465	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  0046a	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0046e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00473	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR ioStatus$29611[rsp]
  0047b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00480	45 33 c9	 xor	 r9d, r9d
  00483	45 33 c0	 xor	 r8d, r8d
  00486	33 d2		 xor	 edx, edx
  00488	48 8b 4c 24 58	 mov	 rcx, QWORD PTR queue$[rsp]
  0048d	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00491	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwWriteFile
  00497	8b d0		 mov	 edx, eax
  00499	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  0049e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004a1	89 50 20	 mov	 DWORD PTR [rax+32], edx

; 405  : 					else

  004a4	eb 3d		 jmp	 SHORT $LN11@IoThreadPr
$LN12@IoThreadPr:

; 406  : 						request->Item->Status = TCCachedRead (queue, &ioStatus, request->Data, request->Offset, request->Length);

  004a6	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  004ab	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  004ae	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  004b2	4c 8b 4c 24 60	 mov	 r9, QWORD PTR request$[rsp]
  004b7	4d 8b 49 10	 mov	 r9, QWORD PTR [r9+16]
  004bb	4c 8b 44 24 60	 mov	 r8, QWORD PTR request$[rsp]
  004c0	4d 8b 40 30	 mov	 r8, QWORD PTR [r8+48]
  004c4	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR ioStatus$29611[rsp]
  004cc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR queue$[rsp]
  004d1	e8 00 00 00 00	 call	 TCCachedRead
  004d6	8b d0		 mov	 edx, eax
  004d8	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  004dd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004e0	89 50 20	 mov	 DWORD PTR [rax+32], edx
$LN11@IoThreadPr:

; 407  : 
; 408  : 					if (NT_SUCCESS (request->Item->Status) && ioStatus.Information != request->Length)

  004e3	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  004e8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004eb	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  004ef	7c 21		 jl	 SHORT $LN10@IoThreadPr
  004f1	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  004f6	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  004f9	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR ioStatus$29611[rsp+8], rax
  00501	74 0f		 je	 SHORT $LN10@IoThreadPr

; 409  : 						request->Item->Status = STATUS_END_OF_FILE;

  00503	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  00508	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0050b	c7 40 20 11 00
	00 c0		 mov	 DWORD PTR [rax+32], -1073741807 ; ffffffffc0000011H
$LN10@IoThreadPr:
$LN13@IoThreadPr:
$LN34@IoThreadPr:

; 410  : 				}
; 411  : 			}
; 412  : 
; 413  : 			if (request->Item->Write)

  00512	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  00517	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0051a	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  0051e	0f 84 8e 00 00
	00		 je	 $LN9@IoThreadPr

; 414  : 			{
; 415  : 				queue->ReadAheadBufferValid = FALSE;

  00524	48 8b 44 24 58	 mov	 rax, QWORD PTR queue$[rsp]
  00529	c7 80 00 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+512], 0

; 416  : 
; 417  : 				ReleaseFragmentBuffer (queue, request->Data);

  00533	48 8b 54 24 60	 mov	 rdx, QWORD PTR request$[rsp]
  00538	48 8b 52 30	 mov	 rdx, QWORD PTR [rdx+48]
  0053c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR queue$[rsp]
  00541	e8 00 00 00 00	 call	 ReleaseFragmentBuffer

; 418  : 
; 419  : 				if (request->CompleteOriginalIrp)

  00546	48 8b 54 24 60	 mov	 rdx, QWORD PTR request$[rsp]
  0054b	83 7a 08 00	 cmp	 DWORD PTR [rdx+8], 0
  0054f	74 4d		 je	 SHORT $LN8@IoThreadPr

; 420  : 				{
; 421  : 					CompleteOriginalIrp (request->Item, request->Item->Status,
; 422  : 						NT_SUCCESS (request->Item->Status) ? request->Item->OriginalLength : 0);

  00551	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  00556	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00559	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  0055d	7c 14		 jl	 SHORT $LN46@IoThreadPr
  0055f	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  00564	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00567	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0056a	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv283[rsp], eax
  00571	eb 0b		 jmp	 SHORT $LN47@IoThreadPr
$LN46@IoThreadPr:
  00573	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv283[rsp], 0
$LN47@IoThreadPr:
  0057e	44 8b 84 24 c0
	00 00 00	 mov	 r8d, DWORD PTR tv283[rsp]
  00586	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  0058b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0058e	8b 50 20	 mov	 edx, DWORD PTR [rax+32]
  00591	48 8b 4c 24 60	 mov	 rcx, QWORD PTR request$[rsp]
  00596	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00599	e8 00 00 00 00	 call	 CompleteOriginalIrp
$LN8@IoThreadPr:

; 423  : 				}
; 424  : 
; 425  : 				ReleasePoolBuffer (queue, request);

  0059e	48 8b 54 24 60	 mov	 rdx, QWORD PTR request$[rsp]
  005a3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR queue$[rsp]
  005a8	e8 00 00 00 00	 call	 ReleasePoolBuffer

; 426  : 			}
; 427  : 			else

  005ad	e9 89 02 00 00	 jmp	 $LN7@IoThreadPr
$LN9@IoThreadPr:

; 428  : 			{
; 429  : 				BOOL readAhead = FALSE;

  005b2	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR readAhead$29625[rsp], 0

; 430  : 
; 431  : 				if (NT_SUCCESS (request->Item->Status))

  005bd	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  005c2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005c5	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  005c9	7c 1c		 jl	 SHORT $LN6@IoThreadPr

; 432  : 					memcpy (request->OrigDataBufferFragment, request->Data, request->Length);

  005cb	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  005d0	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  005d3	48 8b 7c 24 60	 mov	 rdi, QWORD PTR request$[rsp]
  005d8	48 8b 74 24 60	 mov	 rsi, QWORD PTR request$[rsp]
  005dd	48 8b 7f 38	 mov	 rdi, QWORD PTR [rdi+56]
  005e1	48 8b 76 30	 mov	 rsi, QWORD PTR [rsi+48]
  005e5	f3 a4		 rep movsb
$LN6@IoThreadPr:

; 433  : 
; 434  : 				ReleaseFragmentBuffer (queue, request->Data);

  005e7	48 8b 54 24 60	 mov	 rdx, QWORD PTR request$[rsp]
  005ec	48 8b 52 30	 mov	 rdx, QWORD PTR [rdx+48]
  005f0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR queue$[rsp]
  005f5	e8 00 00 00 00	 call	 ReleaseFragmentBuffer

; 435  : 				request->Data = request->OrigDataBufferFragment;

  005fa	48 8b 54 24 60	 mov	 rdx, QWORD PTR request$[rsp]
  005ff	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  00604	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00608	48 89 42 30	 mov	 QWORD PTR [rdx+48], rax

; 436  : 
; 437  : 				if (request->CompleteOriginalIrp
; 438  : 					&& queue->LastReadLength > 0
; 439  : 					&& NT_SUCCESS (request->Item->Status)
; 440  : 					&& InterlockedExchangeAdd (&queue->IoThreadPendingRequestCount, 0) == 0)

  0060c	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  00611	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00615	74 4d		 je	 SHORT $LN5@IoThreadPr
  00617	48 8b 44 24 58	 mov	 rax, QWORD PTR queue$[rsp]
  0061c	83 b8 10 02 00
	00 00		 cmp	 DWORD PTR [rax+528], 0
  00623	76 3f		 jbe	 SHORT $LN5@IoThreadPr
  00625	48 8b 44 24 60	 mov	 rax, QWORD PTR request$[rsp]
  0062a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0062d	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  00631	7c 31		 jl	 SHORT $LN5@IoThreadPr
  00633	48 8b 44 24 58	 mov	 rax, QWORD PTR queue$[rsp]
  00638	48 05 58 02 00
	00		 add	 rax, 600		; 00000258H
  0063e	33 c9		 xor	 ecx, ecx
  00640	f0 0f c1 08	 lock xadd DWORD PTR [rax], ecx
  00644	8b c1		 mov	 eax, ecx
  00646	85 c0		 test	 eax, eax
  00648	75 1a		 jne	 SHORT $LN5@IoThreadPr

; 441  : 				{
; 442  : 					readAhead = TRUE;

  0064a	c7 84 24 a0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR readAhead$29625[rsp], 1

; 443  : 					InterlockedIncrement (&queue->OutstandingIoCount);

  00655	48 8b 44 24 58	 mov	 rax, QWORD PTR queue$[rsp]
  0065a	48 05 38 02 00
	00		 add	 rax, 568		; 00000238H
  00660	f0 83 00 01	 lock add DWORD PTR [rax], 1
$LN5@IoThreadPr:

; 444  : 				}
; 445  : 
; 446  : 				ExInterlockedInsertTailList (&queue->CompletionThreadQueue, &request->CompletionListEntry, &queue->CompletionThreadQueueLock);

  00664	4c 8b 44 24 58	 mov	 r8, QWORD PTR queue$[rsp]
  00669	49 81 c0 a0 01
	00 00		 add	 r8, 416			; 000001a0H
  00670	48 8b 54 24 60	 mov	 rdx, QWORD PTR request$[rsp]
  00675	48 83 c2 50	 add	 rdx, 80			; 00000050H
  00679	48 8b 4c 24 58	 mov	 rcx, QWORD PTR queue$[rsp]
  0067e	48 81 c1 90 01
	00 00		 add	 rcx, 400		; 00000190H
  00685	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExInterlockedInsertTailList

; 447  : 				KeSetEvent (&queue->CompletionThreadQueueNotEmptyEvent, IO_DISK_INCREMENT, FALSE);

  0068b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR queue$[rsp]
  00690	48 81 c1 a8 01
	00 00		 add	 rcx, 424		; 000001a8H
  00697	45 33 c0	 xor	 r8d, r8d
  0069a	ba 01 00 00 00	 mov	 edx, 1
  0069f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 448  : 
; 449  : 				if (readAhead)

  006a5	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR readAhead$29625[rsp], 0
  006ad	0f 84 88 01 00
	00		 je	 $LN4@IoThreadPr

; 450  : 				{
; 451  : 					queue->ReadAheadBufferValid = FALSE;

  006b3	48 8b 44 24 58	 mov	 rax, QWORD PTR queue$[rsp]
  006b8	c7 80 00 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+512], 0

; 452  : 					queue->ReadAheadOffset.QuadPart = queue->LastReadOffset.QuadPart + queue->LastReadLength;

  006c2	48 8b 44 24 58	 mov	 rax, QWORD PTR queue$[rsp]
  006c7	8b 88 10 02 00
	00		 mov	 ecx, DWORD PTR [rax+528]
  006cd	48 8b 44 24 58	 mov	 rax, QWORD PTR queue$[rsp]
  006d2	48 03 88 08 02
	00 00		 add	 rcx, QWORD PTR [rax+520]
  006d9	48 8b 44 24 58	 mov	 rax, QWORD PTR queue$[rsp]
  006de	48 89 88 18 02
	00 00		 mov	 QWORD PTR [rax+536], rcx

; 453  : 					queue->ReadAheadLength = queue->LastReadLength;

  006e5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR queue$[rsp]
  006ea	48 8b 44 24 58	 mov	 rax, QWORD PTR queue$[rsp]
  006ef	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  006f5	89 81 20 02 00
	00		 mov	 DWORD PTR [rcx+544], eax

; 454  : 
; 455  : 					if (queue->ReadAheadOffset.QuadPart + queue->ReadAheadLength <= queue->MaxReadAheadOffset.QuadPart)

  006fb	48 8b 44 24 58	 mov	 rax, QWORD PTR queue$[rsp]
  00700	8b 88 20 02 00
	00		 mov	 ecx, DWORD PTR [rax+544]
  00706	48 8b 44 24 58	 mov	 rax, QWORD PTR queue$[rsp]
  0070b	48 03 88 18 02
	00 00		 add	 rcx, QWORD PTR [rax+536]
  00712	48 8b 44 24 58	 mov	 rax, QWORD PTR queue$[rsp]
  00717	48 3b 88 30 02
	00 00		 cmp	 rcx, QWORD PTR [rax+560]
  0071e	0f 8f 0d 01 00
	00		 jg	 $LN3@IoThreadPr

; 456  : 					{
; 457  : #ifdef TC_TRACE_IO_QUEUE
; 458  : 						Dump ("A   %I64d [%I64d] roff=%I64d rlen=%d\n", request->Item->OriginalIrpOffset.QuadPart, GetElapsedTime (&queue->LastPerformanceCounter), queue->ReadAheadOffset, queue->ReadAheadLength);
; 459  : #endif
; 460  : 						if (queue->IsFilterDevice)

  00724	48 8b 44 24 58	 mov	 rax, QWORD PTR queue$[rsp]
  00729	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  0072d	74 65		 je	 SHORT $LN2@IoThreadPr

; 461  : 						{
; 462  : 							queue->ReadAheadBufferValid = NT_SUCCESS (TCReadDevice (queue->LowerDeviceObject, queue->ReadAheadBuffer, queue->ReadAheadOffset, queue->ReadAheadLength));

  0072f	48 8b 44 24 58	 mov	 rax, QWORD PTR queue$[rsp]
  00734	44 8b 88 20 02
	00 00		 mov	 r9d, DWORD PTR [rax+544]
  0073b	4c 8b 44 24 58	 mov	 r8, QWORD PTR queue$[rsp]
  00740	4d 8b 80 18 02
	00 00		 mov	 r8, QWORD PTR [r8+536]
  00747	48 8b 54 24 58	 mov	 rdx, QWORD PTR queue$[rsp]
  0074c	48 8b 92 28 02
	00 00		 mov	 rdx, QWORD PTR [rdx+552]
  00753	48 8b 4c 24 58	 mov	 rcx, QWORD PTR queue$[rsp]
  00758	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0075c	e8 00 00 00 00	 call	 TCReadDevice
  00761	85 c0		 test	 eax, eax
  00763	7c 0d		 jl	 SHORT $LN48@IoThreadPr
  00765	c7 84 24 c4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv357[rsp], 1
  00770	eb 0b		 jmp	 SHORT $LN49@IoThreadPr
$LN48@IoThreadPr:
  00772	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv357[rsp], 0
$LN49@IoThreadPr:
  0077d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR queue$[rsp]
  00782	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR tv357[rsp]
  00789	89 81 00 02 00
	00		 mov	 DWORD PTR [rcx+512], eax

; 463  : 						}
; 464  : 						else

  0078f	e9 9d 00 00 00	 jmp	 $LN1@IoThreadPr
$LN2@IoThreadPr:

; 465  : 						{
; 466  : 							IO_STATUS_BLOCK ioStatus;
; 467  : 							queue->ReadAheadBufferValid = NT_SUCCESS (ZwReadFile (queue->HostFileHandle, NULL, NULL, NULL, &ioStatus, queue->ReadAheadBuffer, queue->ReadAheadLength, &queue->ReadAheadOffset, NULL));

  00794	48 8b 44 24 58	 mov	 rax, QWORD PTR queue$[rsp]
  00799	48 05 18 02 00
	00		 add	 rax, 536		; 00000218H
  0079f	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  007a8	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  007ad	48 8b 44 24 58	 mov	 rax, QWORD PTR queue$[rsp]
  007b2	8b 80 20 02 00
	00		 mov	 eax, DWORD PTR [rax+544]
  007b8	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  007bc	48 8b 44 24 58	 mov	 rax, QWORD PTR queue$[rsp]
  007c1	48 8b 80 28 02
	00 00		 mov	 rax, QWORD PTR [rax+552]
  007c8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  007cd	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR ioStatus$29635[rsp]
  007d5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007da	45 33 c9	 xor	 r9d, r9d
  007dd	45 33 c0	 xor	 r8d, r8d
  007e0	33 d2		 xor	 edx, edx
  007e2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR queue$[rsp]
  007e7	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  007eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwReadFile
  007f1	85 c0		 test	 eax, eax
  007f3	7c 0d		 jl	 SHORT $LN50@IoThreadPr
  007f5	c7 84 24 c8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv374[rsp], 1
  00800	eb 0b		 jmp	 SHORT $LN51@IoThreadPr
$LN50@IoThreadPr:
  00802	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv374[rsp], 0
$LN51@IoThreadPr:
  0080d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR queue$[rsp]
  00812	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR tv374[rsp]
  00819	89 81 00 02 00
	00		 mov	 DWORD PTR [rcx+512], eax

; 468  : 							queue->ReadAheadLength = (ULONG) ioStatus.Information;

  0081f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR queue$[rsp]
  00824	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR ioStatus$29635[rsp+8]
  0082b	89 81 20 02 00
	00		 mov	 DWORD PTR [rcx+544], eax
$LN1@IoThreadPr:
$LN3@IoThreadPr:

; 469  : 						}
; 470  : 					}
; 471  : 
; 472  : 					DecrementOutstandingIoCount (queue);

  00831	48 8b 4c 24 58	 mov	 rcx, QWORD PTR queue$[rsp]
  00836	e8 00 00 00 00	 call	 DecrementOutstandingIoCount
$LN4@IoThreadPr:
$LN7@IoThreadPr:

; 473  : 				}
; 474  : 			}
; 475  : 		}

  0083b	e9 a6 f8 ff ff	 jmp	 $LN36@IoThreadPr
$LN35@IoThreadPr:

; 476  : 	}

  00840	e9 51 f8 ff ff	 jmp	 $LN52@IoThreadPr
$LN39@IoThreadPr:

; 477  : 
; 478  : 	PsTerminateSystemThread (STATUS_SUCCESS);

  00845	33 c9		 xor	 ecx, ecx
  00847	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsTerminateSystemThread

; 479  : }

  0084d	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  00854	5f		 pop	 rdi
  00855	5e		 pop	 rsi
  00856	c3		 ret	 0
IoThreadProc ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$MainThreadProc DD imagerel MainThreadProc
	DD	imagerel MainThreadProc+3283
	DD	imagerel $unwind$MainThreadProc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MainThreadProc DD 040e01H
	DD	021010eH
	DD	060067007H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT MainThreadProc
_TEXT	SEGMENT
intersectLength$ = 48
intersectStart$ = 56
fragmentOffset$ = 64
dataRemaining$ = 72
listEntry$ = 80
activeFragmentBuffer$ = 88
queue$ = 96
request$ = 104
dataBuffer$ = 112
item$ = 120
irp$29668 = 128
irpSp$29673 = 136
alignedLength$29696 = 144
buffer$29695 = 152
alignedOffset$29697 = 160
dataUnit$29704 = 168
dataFragmentLength$29745 = 176
isLastFragment$29744 = 180
dataUnit$29754 = 184
tv146 = 192
tv215 = 200
tv263 = 208
tv423 = 216
tv433 = 224
tv435 = 228
tv440 = 232
tv498 = 240
threadArg$ = 288
MainThreadProc PROC					; COMDAT

; 483  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H

; 484  : 	EncryptedIoQueue *queue = (EncryptedIoQueue *) threadArg;

  0000e	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR threadArg$[rsp]
  00016	48 89 44 24 60	 mov	 QWORD PTR queue$[rsp], rax

; 485  : 	PLIST_ENTRY listEntry;
; 486  : 	EncryptedIoQueueItem *item;
; 487  : 
; 488  : 	LARGE_INTEGER fragmentOffset;
; 489  : 	ULONG dataRemaining;
; 490  : 	PUCHAR activeFragmentBuffer = queue->FragmentBufferA;

  0001b	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  00020	48 8b 80 c0 01
	00 00		 mov	 rax, QWORD PTR [rax+448]
  00027	48 89 44 24 58	 mov	 QWORD PTR activeFragmentBuffer$[rsp], rax

; 491  : 	PUCHAR dataBuffer;
; 492  : 	EncryptedIoRequest *request;
; 493  : 	uint64 intersectStart;
; 494  : 	uint32 intersectLength;
; 495  : 
; 496  : 	if (IsEncryptionThreadPoolRunning())

  0002c	e8 00 00 00 00	 call	 IsEncryptionThreadPoolRunning
  00031	85 c0		 test	 eax, eax
  00033	74 13		 je	 SHORT $LN46@MainThread

; 497  : 		KeSetPriorityThread (KeGetCurrentThread(), LOW_REALTIME_PRIORITY);

  00035	e8 00 00 00 00	 call	 KeGetCurrentThread
  0003a	ba 10 00 00 00	 mov	 edx, 16
  0003f	48 8b c8	 mov	 rcx, rax
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetPriorityThread
$LN46@MainThread:
$LN63@MainThread:
$LN45@MainThread:

; 498  : 
; 499  : 	while (!queue->ThreadExitRequested)

  00048	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  0004d	8b 80 8c 02 00
	00		 mov	 eax, DWORD PTR [rax+652]
  00053	85 c0		 test	 eax, eax
  00055	0f 85 66 0c 00
	00		 jne	 $LN44@MainThread

; 500  : 	{
; 501  : 		if (!NT_SUCCESS (KeWaitForSingleObject (&queue->MainThreadQueueNotEmptyEvent, Executive, KernelMode, FALSE, NULL)))

  0005b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR queue$[rsp]
  00060	48 81 c1 38 01
	00 00		 add	 rcx, 312		; 00000138H
  00067	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00070	45 33 c9	 xor	 r9d, r9d
  00073	45 33 c0	 xor	 r8d, r8d
  00076	33 d2		 xor	 edx, edx
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  0007e	85 c0		 test	 eax, eax
  00080	7d 02		 jge	 SHORT $LN43@MainThread

; 502  : 			continue;

  00082	eb c4		 jmp	 SHORT $LN45@MainThread
$LN43@MainThread:
$LN74@MainThread:
$LN73@MainThread:
$LN72@MainThread:
$LN71@MainThread:
$LN70@MainThread:
$LN69@MainThread:
$LN68@MainThread:
$LN67@MainThread:
$LN66@MainThread:
$LN65@MainThread:
$LN64@MainThread:
$LN42@MainThread:

; 503  : 
; 504  : 		while ((listEntry = ExInterlockedRemoveHeadList (&queue->MainThreadQueue, &queue->MainThreadQueueLock)))

  00084	48 8b 54 24 60	 mov	 rdx, QWORD PTR queue$[rsp]
  00089	48 81 c2 30 01
	00 00		 add	 rdx, 304		; 00000130H
  00090	48 8b 4c 24 60	 mov	 rcx, QWORD PTR queue$[rsp]
  00095	48 81 c1 20 01
	00 00		 add	 rcx, 288		; 00000120H
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExInterlockedRemoveHeadList
  000a2	48 89 44 24 50	 mov	 QWORD PTR listEntry$[rsp], rax
  000a7	48 83 7c 24 50
	00		 cmp	 QWORD PTR listEntry$[rsp], 0
  000ad	0f 84 09 0c 00
	00		 je	 $LN41@MainThread

; 505  : 		{
; 506  : 			PIRP irp = CONTAINING_RECORD (listEntry, IRP, Tail.Overlay.ListEntry);

  000b3	48 8b 44 24 50	 mov	 rax, QWORD PTR listEntry$[rsp]
  000b8	48 2d a8 00 00
	00		 sub	 rax, 168		; 000000a8H
  000be	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR irp$29668[rsp], rax

; 507  : 			PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (irp);

  000c6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR irp$29668[rsp]
  000ce	e8 00 00 00 00	 call	 IoGetCurrentIrpStackLocation
  000d3	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR irpSp$29673[rsp], rax

; 508  : 			
; 509  : 			if (queue->Suspended)

  000db	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  000e0	8b 80 90 02 00
	00		 mov	 eax, DWORD PTR [rax+656]
  000e6	85 c0		 test	 eax, eax
  000e8	74 23		 je	 SHORT $LN40@MainThread

; 510  : 				KeWaitForSingleObject (&queue->QueueResumedEvent, Executive, KernelMode, FALSE, NULL);

  000ea	48 8b 4c 24 60	 mov	 rcx, QWORD PTR queue$[rsp]
  000ef	48 81 c1 a0 02
	00 00		 add	 rcx, 672		; 000002a0H
  000f6	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000ff	45 33 c9	 xor	 r9d, r9d
  00102	45 33 c0	 xor	 r8d, r8d
  00105	33 d2		 xor	 edx, edx
  00107	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
$LN40@MainThread:

; 511  : 
; 512  : 			item = GetPoolBuffer (queue, sizeof (EncryptedIoQueueItem));

  0010d	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00112	48 8b 4c 24 60	 mov	 rcx, QWORD PTR queue$[rsp]
  00117	e8 00 00 00 00	 call	 GetPoolBuffer
  0011c	48 89 44 24 78	 mov	 QWORD PTR item$[rsp], rax

; 513  : 			item->Queue = queue;

  00121	48 8b 4c 24 78	 mov	 rcx, QWORD PTR item$[rsp]
  00126	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  0012b	48 89 01	 mov	 QWORD PTR [rcx], rax

; 514  : 			item->OriginalIrp = irp;

  0012e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR item$[rsp]
  00133	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR irp$29668[rsp]
  0013b	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 515  : 			item->Status = STATUS_SUCCESS;

  0013f	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  00144	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 516  : 
; 517  : 			IoSetCancelRoutine (irp, NULL);

  0014b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR irp$29668[rsp]
  00153	48 83 c0 68	 add	 rax, 104		; 00000068H
  00157	33 c9		 xor	 ecx, ecx
  00159	48 87 08	 xchg	 QWORD PTR [rax], rcx

; 518  : 			if (irp->Cancel)

  0015c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR irp$29668[rsp]
  00164	0f b6 40 44	 movzx	 eax, BYTE PTR [rax+68]
  00168	85 c0		 test	 eax, eax
  0016a	74 17		 je	 SHORT $LN39@MainThread

; 519  : 			{
; 520  : 				CompleteOriginalIrp (item, STATUS_CANCELLED, 0);

  0016c	45 33 c0	 xor	 r8d, r8d
  0016f	ba 20 01 00 c0	 mov	 edx, -1073741536	; ffffffffc0000120H
  00174	48 8b 4c 24 78	 mov	 rcx, QWORD PTR item$[rsp]
  00179	e8 00 00 00 00	 call	 CompleteOriginalIrp

; 521  : 				continue;

  0017e	e9 01 ff ff ff	 jmp	 $LN42@MainThread
$LN39@MainThread:

; 522  : 			}
; 523  : 
; 524  : 			switch (irpSp->MajorFunction)

  00183	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR irpSp$29673[rsp]
  0018b	8a 00		 mov	 al, BYTE PTR [rax]
  0018d	88 84 24 c0 00
	00 00		 mov	 BYTE PTR tv146[rsp], al
  00194	80 bc 24 c0 00
	00 00 03	 cmp	 BYTE PTR tv146[rsp], 3
  0019c	74 0c		 je	 SHORT $LN36@MainThread
  0019e	80 bc 24 c0 00
	00 00 04	 cmp	 BYTE PTR tv146[rsp], 4
  001a6	74 38		 je	 SHORT $LN35@MainThread
  001a8	eb 6c		 jmp	 SHORT $LN34@MainThread
$LN36@MainThread:

; 525  : 			{
; 526  : 			case IRP_MJ_READ:
; 527  : 				item->Write = FALSE;

  001aa	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  001af	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 528  : 				item->OriginalOffset = irpSp->Parameters.Read.ByteOffset;

  001b6	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR irpSp$29673[rsp]
  001be	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  001c2	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  001c7	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 529  : 				item->OriginalLength = irpSp->Parameters.Read.Length;

  001cb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR item$[rsp]
  001d0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR irpSp$29673[rsp]
  001d8	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  001db	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 530  : 				break;

  001de	eb 4d		 jmp	 SHORT $LN37@MainThread
$LN35@MainThread:

; 531  : 
; 532  : 			case IRP_MJ_WRITE:
; 533  : 				item->Write = TRUE;

  001e0	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  001e5	c7 40 10 01 00
	00 00		 mov	 DWORD PTR [rax+16], 1

; 534  : 				item->OriginalOffset = irpSp->Parameters.Write.ByteOffset;

  001ec	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR irpSp$29673[rsp]
  001f4	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  001f8	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  001fd	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 535  : 				item->OriginalLength = irpSp->Parameters.Write.Length;

  00201	48 8b 4c 24 78	 mov	 rcx, QWORD PTR item$[rsp]
  00206	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR irpSp$29673[rsp]
  0020e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00211	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 536  : 				break;

  00214	eb 17		 jmp	 SHORT $LN37@MainThread
$LN34@MainThread:

; 537  : 
; 538  : 			default:
; 539  : 				CompleteOriginalIrp (item, STATUS_INVALID_PARAMETER, 0);

  00216	45 33 c0	 xor	 r8d, r8d
  00219	ba 0d 00 00 c0	 mov	 edx, -1073741811	; ffffffffc000000dH
  0021e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR item$[rsp]
  00223	e8 00 00 00 00	 call	 CompleteOriginalIrp

; 540  : 				continue;

  00228	e9 57 fe ff ff	 jmp	 $LN64@MainThread
$LN37@MainThread:

; 541  : 			}
; 542  : 
; 543  : #ifdef TC_TRACE_IO_QUEUE
; 544  : 			item->OriginalIrpOffset = item->OriginalOffset;
; 545  : #endif
; 546  : 
; 547  : 			// Handle misaligned read operations to work around a bug in Windows System Assessment Tool which does not follow FILE_FLAG_NO_BUFFERING requirements when benchmarking disk devices
; 548  : 			if (queue->IsFilterDevice
; 549  : 				&& !item->Write
; 550  : 				&& item->OriginalLength > 0
; 551  : 				&& (item->OriginalLength & (ENCRYPTION_DATA_UNIT_SIZE - 1)) == 0
; 552  : 				&& (item->OriginalOffset.QuadPart & (ENCRYPTION_DATA_UNIT_SIZE - 1)) != 0)

  0022d	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  00232	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  00236	0f 84 dd 02 00
	00		 je	 $LN33@MainThread
  0023c	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  00241	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  00245	0f 85 ce 02 00
	00		 jne	 $LN33@MainThread
  0024b	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  00250	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  00254	0f 86 bf 02 00
	00		 jbe	 $LN33@MainThread
  0025a	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  0025f	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00262	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  00267	85 c0		 test	 eax, eax
  00269	0f 85 aa 02 00
	00		 jne	 $LN33@MainThread
  0026f	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  00274	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00278	48 25 ff 01 00
	00		 and	 rax, 511		; 000001ffH
  0027e	48 85 c0	 test	 rax, rax
  00281	0f 84 92 02 00
	00		 je	 $LN33@MainThread

; 553  : 			{
; 554  : 				byte *buffer;
; 555  : 				ULONG alignedLength = item->OriginalLength + ENCRYPTION_DATA_UNIT_SIZE;

  00287	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  0028c	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0028f	05 00 02 00 00	 add	 eax, 512		; 00000200H
  00294	89 84 24 90 00
	00 00		 mov	 DWORD PTR alignedLength$29696[rsp], eax

; 556  : 				LARGE_INTEGER alignedOffset;
; 557  : 				alignedOffset.QuadPart = item->OriginalOffset.QuadPart & ~((LONGLONG) ENCRYPTION_DATA_UNIT_SIZE - 1);

  0029b	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  002a0	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  002a4	48 25 00 fe ff
	ff		 and	 rax, -512		; fffffffffffffe00H
  002aa	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR alignedOffset$29697[rsp], rax

; 558  : 
; 559  : 				buffer = TCalloc (alignedLength);

  002b2	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR alignedLength$29696[rsp]
  002b9	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  002bf	33 c9		 xor	 ecx, ecx
  002c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  002c7	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR buffer$29695[rsp], rax

; 560  : 				if (!buffer)

  002cf	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR buffer$29695[rsp], 0
  002d8	75 17		 jne	 SHORT $LN32@MainThread

; 561  : 				{
; 562  : 					CompleteOriginalIrp (item, STATUS_INSUFFICIENT_RESOURCES, 0);

  002da	45 33 c0	 xor	 r8d, r8d
  002dd	ba 9a 00 00 c0	 mov	 edx, -1073741670	; ffffffffc000009aH
  002e2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR item$[rsp]
  002e7	e8 00 00 00 00	 call	 CompleteOriginalIrp

; 563  : 					continue;

  002ec	e9 93 fd ff ff	 jmp	 $LN65@MainThread
$LN32@MainThread:

; 564  : 				}
; 565  : 
; 566  : 				item->Status = TCReadDevice (queue->LowerDeviceObject, buffer, alignedOffset, alignedLength);

  002f1	44 8b 8c 24 90
	00 00 00	 mov	 r9d, DWORD PTR alignedLength$29696[rsp]
  002f9	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR alignedOffset$29697[rsp]
  00301	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR buffer$29695[rsp]
  00309	48 8b 4c 24 60	 mov	 rcx, QWORD PTR queue$[rsp]
  0030e	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00312	e8 00 00 00 00	 call	 TCReadDevice
  00317	8b d0		 mov	 edx, eax
  00319	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  0031e	89 50 20	 mov	 DWORD PTR [rax+32], edx

; 567  : 
; 568  : 				if (NT_SUCCESS (item->Status))

  00321	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  00326	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  0032a	0f 8c 90 01 00
	00		 jl	 $LN31@MainThread

; 569  : 				{
; 570  : 					UINT64_STRUCT dataUnit;
; 571  : 
; 572  : 					dataBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe (irp->MdlAddress, HighPagePriority);

  00330	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR irp$29668[rsp]
  00338	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0033c	0f bf 40 0a	 movsx	 eax, WORD PTR [rax+10]
  00340	83 e0 05	 and	 eax, 5
  00343	85 c0		 test	 eax, eax
  00345	74 1a		 je	 SHORT $LN49@MainThread
  00347	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR irp$29668[rsp]
  0034f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00353	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00357	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv215[rsp], rax
  0035f	eb 35		 jmp	 SHORT $LN50@MainThread
$LN49@MainThread:
  00361	c7 44 24 28 20
	00 00 00	 mov	 DWORD PTR [rsp+40], 32	; 00000020H
  00369	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00371	45 33 c9	 xor	 r9d, r9d
  00374	41 b8 01 00 00
	00		 mov	 r8d, 1
  0037a	33 d2		 xor	 edx, edx
  0037c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR irp$29668[rsp]
  00384	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00388	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmMapLockedPagesSpecifyCache
  0038e	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv215[rsp], rax
$LN50@MainThread:
  00396	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv215[rsp]
  0039e	48 89 44 24 70	 mov	 QWORD PTR dataBuffer$[rsp], rax

; 573  : 					if (!dataBuffer)

  003a3	48 83 7c 24 70
	00		 cmp	 QWORD PTR dataBuffer$[rsp], 0
  003a9	75 2a		 jne	 SHORT $LN30@MainThread

; 574  : 					{
; 575  : 						TCfree (buffer);

  003ab	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  003b0	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR buffer$29695[rsp]
  003b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 576  : 						CompleteOriginalIrp (item, STATUS_INSUFFICIENT_RESOURCES, 0);

  003be	45 33 c0	 xor	 r8d, r8d
  003c1	ba 9a 00 00 c0	 mov	 edx, -1073741670	; ffffffffc000009aH
  003c6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR item$[rsp]
  003cb	e8 00 00 00 00	 call	 CompleteOriginalIrp

; 577  : 						continue;

  003d0	e9 af fc ff ff	 jmp	 $LN66@MainThread
$LN30@MainThread:

; 578  : 					}
; 579  : 
; 580  : 					if (queue->EncryptedAreaStart != -1 && queue->EncryptedAreaEnd != -1)

  003d5	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  003da	48 83 78 78 ff	 cmp	 QWORD PTR [rax+120], -1
  003df	0f 84 b2 00 00
	00		 je	 $LN29@MainThread
  003e5	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  003ea	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  003f1	48 83 f8 ff	 cmp	 rax, -1
  003f5	0f 84 9c 00 00
	00		 je	 $LN29@MainThread

; 581  : 					{
; 582  : 						GetIntersection (alignedOffset.QuadPart, alignedLength, queue->EncryptedAreaStart, queue->EncryptedAreaEnd, &intersectStart, &intersectLength);

  003fb	48 8d 44 24 30	 lea	 rax, QWORD PTR intersectLength$[rsp]
  00400	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00405	48 8d 44 24 38	 lea	 rax, QWORD PTR intersectStart$[rsp]
  0040a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0040f	4c 8b 4c 24 60	 mov	 r9, QWORD PTR queue$[rsp]
  00414	4d 8b 89 80 00
	00 00		 mov	 r9, QWORD PTR [r9+128]
  0041b	4c 8b 44 24 60	 mov	 r8, QWORD PTR queue$[rsp]
  00420	4d 8b 40 78	 mov	 r8, QWORD PTR [r8+120]
  00424	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR alignedLength$29696[rsp]
  0042b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR alignedOffset$29697[rsp]
  00433	e8 00 00 00 00	 call	 GetIntersection

; 583  : 						if (intersectLength > 0)

  00438	83 7c 24 30 00	 cmp	 DWORD PTR intersectLength$[rsp], 0
  0043d	76 58		 jbe	 SHORT $LN28@MainThread

; 584  : 						{
; 585  : 							dataUnit.Value = intersectStart / ENCRYPTION_DATA_UNIT_SIZE;

  0043f	33 d2		 xor	 edx, edx
  00441	48 8b 44 24 38	 mov	 rax, QWORD PTR intersectStart$[rsp]
  00446	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0044b	48 f7 f1	 div	 rcx
  0044e	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR dataUnit$29704[rsp], rax

; 586  : 							DecryptDataUnits (buffer + (intersectStart - alignedOffset.QuadPart), &dataUnit, intersectLength / ENCRYPTION_DATA_UNIT_SIZE, queue->CryptoInfo);

  00456	33 d2		 xor	 edx, edx
  00458	8b 44 24 30	 mov	 eax, DWORD PTR intersectLength$[rsp]
  0045c	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00461	f7 f1		 div	 ecx
  00463	44 8b c0	 mov	 r8d, eax
  00466	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR alignedOffset$29697[rsp]
  0046e	48 8b 44 24 38	 mov	 rax, QWORD PTR intersectStart$[rsp]
  00473	48 2b c1	 sub	 rax, rcx
  00476	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR buffer$29695[rsp]
  0047e	48 03 c8	 add	 rcx, rax
  00481	4c 8b 4c 24 60	 mov	 r9, QWORD PTR queue$[rsp]
  00486	4d 8b 49 48	 mov	 r9, QWORD PTR [r9+72]
  0048a	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR dataUnit$29704[rsp]
  00492	e8 00 00 00 00	 call	 DecryptDataUnits
$LN28@MainThread:
$LN29@MainThread:

; 587  : 						}
; 588  : 					}
; 589  : 
; 590  : 					memcpy (dataBuffer, buffer + (item->OriginalOffset.LowPart & (ENCRYPTION_DATA_UNIT_SIZE - 1)), item->OriginalLength);

  00497	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  0049c	8b 48 14	 mov	 ecx, DWORD PTR [rax+20]
  0049f	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  004a4	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  004a7	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  004ac	8b c0		 mov	 eax, eax
  004ae	48 8b b4 24 98
	00 00 00	 mov	 rsi, QWORD PTR buffer$29695[rsp]
  004b6	48 03 f0	 add	 rsi, rax
  004b9	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dataBuffer$[rsp]
  004be	f3 a4		 rep movsb
$LN31@MainThread:

; 591  : 				}
; 592  : 
; 593  : 				TCfree (buffer);

  004c0	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  004c5	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR buffer$29695[rsp]
  004cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 594  : 				CompleteOriginalIrp (item, item->Status, NT_SUCCESS (item->Status) ? item->OriginalLength : 0);

  004d3	48 8b 54 24 78	 mov	 rdx, QWORD PTR item$[rsp]
  004d8	83 7a 20 00	 cmp	 DWORD PTR [rdx+32], 0
  004dc	7c 11		 jl	 SHORT $LN51@MainThread
  004de	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  004e3	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  004e6	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv263[rsp], eax
  004ed	eb 0b		 jmp	 SHORT $LN52@MainThread
$LN51@MainThread:
  004ef	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv263[rsp], 0
$LN52@MainThread:
  004fa	44 8b 84 24 d0
	00 00 00	 mov	 r8d, DWORD PTR tv263[rsp]
  00502	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  00507	8b 50 20	 mov	 edx, DWORD PTR [rax+32]
  0050a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR item$[rsp]
  0050f	e8 00 00 00 00	 call	 CompleteOriginalIrp

; 595  : 				continue;

  00514	e9 6b fb ff ff	 jmp	 $LN67@MainThread
$LN33@MainThread:

; 596  : 			}
; 597  : 
; 598  : 			// Validate offset and length
; 599  : 			if (item->OriginalLength == 0
; 600  : 				|| (item->OriginalLength & (ENCRYPTION_DATA_UNIT_SIZE - 1)) != 0
; 601  : 				|| (item->OriginalOffset.QuadPart & (ENCRYPTION_DATA_UNIT_SIZE - 1)) != 0
; 602  : 				|| (!queue->IsFilterDevice && item->OriginalOffset.QuadPart + item->OriginalLength > queue->VirtualDeviceLength))

  00519	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  0051e	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  00522	74 4c		 je	 SHORT $LN26@MainThread
  00524	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  00529	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0052c	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  00531	85 c0		 test	 eax, eax
  00533	75 3b		 jne	 SHORT $LN26@MainThread
  00535	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  0053a	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0053e	48 25 ff 01 00
	00		 and	 rax, 511		; 000001ffH
  00544	48 85 c0	 test	 rax, rax
  00547	75 27		 jne	 SHORT $LN26@MainThread
  00549	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  0054e	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  00552	75 33		 jne	 SHORT $LN27@MainThread
  00554	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  00559	8b 48 14	 mov	 ecx, DWORD PTR [rax+20]
  0055c	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  00561	48 03 48 18	 add	 rcx, QWORD PTR [rax+24]
  00565	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  0056a	48 3b 48 58	 cmp	 rcx, QWORD PTR [rax+88]
  0056e	7e 17		 jle	 SHORT $LN27@MainThread
$LN26@MainThread:

; 603  : 			{
; 604  : 				CompleteOriginalIrp (item, STATUS_INVALID_PARAMETER, 0);

  00570	45 33 c0	 xor	 r8d, r8d
  00573	ba 0d 00 00 c0	 mov	 edx, -1073741811	; ffffffffc000000dH
  00578	48 8b 4c 24 78	 mov	 rcx, QWORD PTR item$[rsp]
  0057d	e8 00 00 00 00	 call	 CompleteOriginalIrp

; 605  : 				continue;

  00582	e9 fd fa ff ff	 jmp	 $LN68@MainThread
$LN27@MainThread:

; 606  : 			}
; 607  : 
; 608  : #ifdef TC_TRACE_IO_QUEUE
; 609  : 			Dump ("Q  %I64d [%I64d] %c len=%d\n", item->OriginalOffset.QuadPart, GetElapsedTime (&queue->LastPerformanceCounter), item->Write ? 'W' : 'R', item->OriginalLength);
; 610  : #endif
; 611  : 
; 612  : 			if (!queue->IsFilterDevice)

  00587	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  0058c	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  00590	0f 85 9b 01 00
	00		 jne	 $LN25@MainThread

; 613  : 			{
; 614  : 				// Adjust the offset for host file or device
; 615  : 				if (queue->CryptoInfo->hiddenVolume)

  00596	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  0059b	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  0059f	83 b8 a0 29 00
	00 00		 cmp	 DWORD PTR [rax+10656], 0
  005a6	74 24		 je	 SHORT $LN24@MainThread

; 616  : 					item->OriginalOffset.QuadPart += queue->CryptoInfo->hiddenVolumeOffset;

  005a8	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  005ad	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  005b1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR item$[rsp]
  005b6	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  005ba	48 03 88 18 44
	00 00		 add	 rcx, QWORD PTR [rax+17432]
  005c1	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  005c6	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 617  : 				else

  005ca	eb 22		 jmp	 SHORT $LN23@MainThread
$LN24@MainThread:

; 618  : 					item->OriginalOffset.QuadPart += queue->CryptoInfo->volDataAreaOffset; 

  005cc	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  005d1	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  005d5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR item$[rsp]
  005da	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  005de	48 03 88 08 44
	00 00		 add	 rcx, QWORD PTR [rax+17416]
  005e5	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  005ea	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx
$LN23@MainThread:

; 619  : 
; 620  : 				// Hidden volume protection
; 621  : 				if (item->Write && queue->CryptoInfo->bProtectHiddenVolume)

  005ee	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  005f3	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  005f7	0f 84 2f 01 00
	00		 je	 $LN22@MainThread
  005fd	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  00602	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  00606	83 b8 00 44 00
	00 00		 cmp	 DWORD PTR [rax+17408], 0
  0060d	0f 84 19 01 00
	00		 je	 $LN22@MainThread

; 622  : 				{
; 623  : 					// If there has already been a write operation denied in order to protect the
; 624  : 					// hidden volume (since the volume mount time)
; 625  : 					if (queue->CryptoInfo->bHiddenVolProtectionAction)	

  00613	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  00618	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  0061c	83 b8 04 44 00
	00 00		 cmp	 DWORD PTR [rax+17412], 0
  00623	74 17		 je	 SHORT $LN21@MainThread

; 626  : 					{
; 627  : 						// Do not allow writing to this volume anymore. This is to fake a complete volume
; 628  : 						// or system failure (otherwise certain kinds of inconsistency within the file
; 629  : 						// system could indicate that this volume has used hidden volume protection).
; 630  : 						CompleteOriginalIrp (item, STATUS_INVALID_PARAMETER, 0);

  00625	45 33 c0	 xor	 r8d, r8d
  00628	ba 0d 00 00 c0	 mov	 edx, -1073741811	; ffffffffc000000dH
  0062d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR item$[rsp]
  00632	e8 00 00 00 00	 call	 CompleteOriginalIrp

; 631  : 						continue;

  00637	e9 48 fa ff ff	 jmp	 $LN69@MainThread
$LN21@MainThread:

; 632  : 					}
; 633  : 
; 634  : 					// Verify that no byte is going to be written to the hidden volume area
; 635  : 					if (RegionsOverlap ((unsigned __int64) item->OriginalOffset.QuadPart,
; 636  : 						(unsigned __int64) item->OriginalOffset.QuadPart + item->OriginalLength - 1,
; 637  : 						queue->CryptoInfo->hiddenVolumeOffset,
; 638  : 						(unsigned __int64) queue->CryptoInfo->hiddenVolumeOffset + queue->CryptoInfo->hiddenVolumeProtectedSize - 1))

  0063c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR queue$[rsp]
  00641	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  00645	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  0064a	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  0064e	48 8b 89 18 44
	00 00		 mov	 rcx, QWORD PTR [rcx+17432]
  00655	48 8b 80 20 44
	00 00		 mov	 rax, QWORD PTR [rax+17440]
  0065c	4c 8d 4c 01 ff	 lea	 r9, QWORD PTR [rcx+rax-1]
  00661	4c 8b 44 24 60	 mov	 r8, QWORD PTR queue$[rsp]
  00666	4d 8b 40 48	 mov	 r8, QWORD PTR [r8+72]
  0066a	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  0066f	8b 48 14	 mov	 ecx, DWORD PTR [rax+20]
  00672	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  00677	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0067b	48 8d 54 08 ff	 lea	 rdx, QWORD PTR [rax+rcx-1]
  00680	4d 8b 80 18 44
	00 00		 mov	 r8, QWORD PTR [r8+17432]
  00687	48 8b 4c 24 78	 mov	 rcx, QWORD PTR item$[rsp]
  0068c	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00690	e8 00 00 00 00	 call	 RegionsOverlap
  00695	85 c0		 test	 eax, eax
  00697	0f 84 8f 00 00
	00		 je	 $LN20@MainThread

; 639  : 					{
; 640  : 						Dump ("Hidden volume protection triggered: write %I64d-%I64d (protected %I64d-%I64d)\n", item->OriginalOffset.QuadPart, item->OriginalOffset.QuadPart + item->OriginalLength - 1, queue->CryptoInfo->hiddenVolumeOffset, queue->CryptoInfo->hiddenVolumeOffset + queue->CryptoInfo->hiddenVolumeProtectedSize - 1);

  0069d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR queue$[rsp]
  006a2	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  006a6	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  006ab	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  006af	48 8b 89 18 44
	00 00		 mov	 rcx, QWORD PTR [rcx+17432]
  006b6	48 8b 80 20 44
	00 00		 mov	 rax, QWORD PTR [rax+17440]
  006bd	48 8d 54 01 ff	 lea	 rdx, QWORD PTR [rcx+rax-1]
  006c2	4c 8b 4c 24 60	 mov	 r9, QWORD PTR queue$[rsp]
  006c7	4d 8b 49 48	 mov	 r9, QWORD PTR [r9+72]
  006cb	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  006d0	8b 48 14	 mov	 ecx, DWORD PTR [rax+20]
  006d3	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  006d8	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  006dc	4c 8d 44 08 ff	 lea	 r8, QWORD PTR [rax+rcx-1]
  006e1	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  006e6	4d 8b 89 18 44
	00 00		 mov	 r9, QWORD PTR [r9+17432]
  006ed	48 8b 54 24 78	 mov	 rdx, QWORD PTR item$[rsp]
  006f2	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  006f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EP@IGAPPBIF@Hidden?5volume?5protection?5trigger@FNODOBFM@
  006fd	e8 00 00 00 00	 call	 DbgPrint

; 641  : 						queue->CryptoInfo->bHiddenVolProtectionAction = TRUE;

  00702	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  00707	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  0070b	c7 80 04 44 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+17412], 1

; 642  : 
; 643  : 						// Deny this write operation to prevent the hidden volume from being overwritten
; 644  : 						CompleteOriginalIrp (item, STATUS_INVALID_PARAMETER, 0);

  00715	45 33 c0	 xor	 r8d, r8d
  00718	ba 0d 00 00 c0	 mov	 edx, -1073741811	; ffffffffc000000dH
  0071d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR item$[rsp]
  00722	e8 00 00 00 00	 call	 CompleteOriginalIrp

; 645  : 						continue;

  00727	e9 58 f9 ff ff	 jmp	 $LN70@MainThread
$LN20@MainThread:
$LN22@MainThread:

; 646  : 					}
; 647  : 				}
; 648  : 			}
; 649  : 			else if (item->Write

  0072c	e9 14 01 00 00	 jmp	 $LN19@MainThread
$LN25@MainThread:

; 650  : 				&& RegionsOverlap (item->OriginalOffset.QuadPart, item->OriginalOffset.QuadPart + item->OriginalLength - 1, TC_BOOT_VOLUME_HEADER_SECTOR_OFFSET, TC_BOOT_VOLUME_HEADER_SECTOR_OFFSET + TC_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE - 1))

  00731	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  00736	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  0073a	74 5c		 je	 SHORT $LN18@MainThread
  0073c	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  00741	8b 48 14	 mov	 ecx, DWORD PTR [rax+20]
  00744	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  00749	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0074d	48 8d 54 08 ff	 lea	 rdx, QWORD PTR [rax+rcx-1]
  00752	41 b9 ff 7d 00
	00		 mov	 r9d, 32255		; 00007dffH
  00758	41 b8 00 7c 00
	00		 mov	 r8d, 31744		; 00007c00H
  0075e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR item$[rsp]
  00763	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00767	e8 00 00 00 00	 call	 RegionsOverlap
  0076c	85 c0		 test	 eax, eax
  0076e	74 28		 je	 SHORT $LN18@MainThread

; 651  : 			{
; 652  : 				// Prevent inappropriately designed software from damaging important data that may be out of sync with the backup on the Rescue Disk (such as the end of the encrypted area).
; 653  : 				Dump ("Preventing write to the system encryption key data area\n");

  00770	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DJ@KOLNOKOK@Preventing?5write?5to?5the?5system?5e@FNODOBFM@
  00777	e8 00 00 00 00	 call	 DbgPrint

; 654  : 				CompleteOriginalIrp (item, STATUS_MEDIA_WRITE_PROTECTED, 0);

  0077c	45 33 c0	 xor	 r8d, r8d
  0077f	ba a2 00 00 c0	 mov	 edx, -1073741662	; ffffffffc00000a2H
  00784	48 8b 4c 24 78	 mov	 rcx, QWORD PTR item$[rsp]
  00789	e8 00 00 00 00	 call	 CompleteOriginalIrp

; 655  : 				continue;

  0078e	e9 f1 f8 ff ff	 jmp	 $LN71@MainThread

; 656  : 			}
; 657  : 			else if (item->Write && IsHiddenSystemRunning()

  00793	e9 ad 00 00 00	 jmp	 $LN17@MainThread
$LN18@MainThread:

; 658  : 				&& (RegionsOverlap (item->OriginalOffset.QuadPart, item->OriginalOffset.QuadPart + item->OriginalLength - 1, TC_SECTOR_SIZE_BIOS, TC_BOOT_LOADER_AREA_SECTOR_COUNT * TC_SECTOR_SIZE_BIOS - 1)
; 659  : 				 || RegionsOverlap (item->OriginalOffset.QuadPart, item->OriginalOffset.QuadPart + item->OriginalLength - 1, GetBootDriveLength(), _I64_MAX)))

  00798	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  0079d	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  007a1	0f 84 9e 00 00
	00		 je	 $LN16@MainThread
  007a7	e8 00 00 00 00	 call	 IsHiddenSystemRunning
  007ac	85 c0		 test	 eax, eax
  007ae	0f 84 91 00 00
	00		 je	 $LN16@MainThread
  007b4	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  007b9	8b 48 14	 mov	 ecx, DWORD PTR [rax+20]
  007bc	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  007c1	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  007c5	48 8d 54 08 ff	 lea	 rdx, QWORD PTR [rax+rcx-1]
  007ca	41 b9 ff 7d 00
	00		 mov	 r9d, 32255		; 00007dffH
  007d0	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  007d6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR item$[rsp]
  007db	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  007df	e8 00 00 00 00	 call	 RegionsOverlap
  007e4	85 c0		 test	 eax, eax
  007e6	75 3a		 jne	 SHORT $LN15@MainThread
  007e8	e8 00 00 00 00	 call	 GetBootDriveLength
  007ed	4c 8b c0	 mov	 r8, rax
  007f0	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  007f5	8b 48 14	 mov	 ecx, DWORD PTR [rax+20]
  007f8	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  007fd	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00801	48 8d 54 08 ff	 lea	 rdx, QWORD PTR [rax+rcx-1]
  00806	49 b9 ff ff ff
	ff ff ff ff 7f	 mov	 r9, 9223372036854775807	; 7fffffffffffffffH
  00810	48 8b 4c 24 78	 mov	 rcx, QWORD PTR item$[rsp]
  00815	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00819	e8 00 00 00 00	 call	 RegionsOverlap
  0081e	85 c0		 test	 eax, eax
  00820	74 23		 je	 SHORT $LN16@MainThread
$LN15@MainThread:

; 660  : 			{
; 661  : 				Dump ("Preventing write to boot loader or host protected area\n");

  00822	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DI@GBCOIBFH@Preventing?5write?5to?5boot?5loader?5@FNODOBFM@
  00829	e8 00 00 00 00	 call	 DbgPrint

; 662  : 				CompleteOriginalIrp (item, STATUS_MEDIA_WRITE_PROTECTED, 0);

  0082e	45 33 c0	 xor	 r8d, r8d
  00831	ba a2 00 00 c0	 mov	 edx, -1073741662	; ffffffffc00000a2H
  00836	48 8b 4c 24 78	 mov	 rcx, QWORD PTR item$[rsp]
  0083b	e8 00 00 00 00	 call	 CompleteOriginalIrp

; 663  : 				continue;

  00840	e9 3f f8 ff ff	 jmp	 $LN72@MainThread
$LN16@MainThread:
$LN17@MainThread:
$LN19@MainThread:

; 664  : 			}
; 665  : 
; 666  : 			dataBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe (irp->MdlAddress, HighPagePriority);

  00845	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR irp$29668[rsp]
  0084d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00851	0f bf 40 0a	 movsx	 eax, WORD PTR [rax+10]
  00855	83 e0 05	 and	 eax, 5
  00858	85 c0		 test	 eax, eax
  0085a	74 1a		 je	 SHORT $LN53@MainThread
  0085c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR irp$29668[rsp]
  00864	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00868	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0086c	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv423[rsp], rax
  00874	eb 35		 jmp	 SHORT $LN54@MainThread
$LN53@MainThread:
  00876	c7 44 24 28 20
	00 00 00	 mov	 DWORD PTR [rsp+40], 32	; 00000020H
  0087e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00886	45 33 c9	 xor	 r9d, r9d
  00889	41 b8 01 00 00
	00		 mov	 r8d, 1
  0088f	33 d2		 xor	 edx, edx
  00891	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR irp$29668[rsp]
  00899	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0089d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmMapLockedPagesSpecifyCache
  008a3	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv423[rsp], rax
$LN54@MainThread:
  008ab	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR tv423[rsp]
  008b3	48 89 44 24 70	 mov	 QWORD PTR dataBuffer$[rsp], rax

; 667  : 
; 668  : 			if (dataBuffer == NULL)

  008b8	48 83 7c 24 70
	00		 cmp	 QWORD PTR dataBuffer$[rsp], 0
  008be	75 17		 jne	 SHORT $LN14@MainThread

; 669  : 			{
; 670  : 				CompleteOriginalIrp (item, STATUS_INSUFFICIENT_RESOURCES, 0);

  008c0	45 33 c0	 xor	 r8d, r8d
  008c3	ba 9a 00 00 c0	 mov	 edx, -1073741670	; ffffffffc000009aH
  008c8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR item$[rsp]
  008cd	e8 00 00 00 00	 call	 CompleteOriginalIrp

; 671  : 				continue;

  008d2	e9 ad f7 ff ff	 jmp	 $LN73@MainThread
$LN14@MainThread:

; 672  : 			}
; 673  : 
; 674  : 			// Divide data block to fragments to enable efficient overlapping of encryption and IO operations
; 675  : 
; 676  : 			dataRemaining = item->OriginalLength;

  008d7	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  008dc	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  008df	89 44 24 48	 mov	 DWORD PTR dataRemaining$[rsp], eax

; 677  : 			fragmentOffset = item->OriginalOffset;

  008e3	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  008e8	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  008ec	48 89 44 24 40	 mov	 QWORD PTR fragmentOffset$[rsp], rax
$LN13@MainThread:

; 678  : 
; 679  : 			while (dataRemaining > 0)

  008f1	83 7c 24 48 00	 cmp	 DWORD PTR dataRemaining$[rsp], 0
  008f6	0f 86 bb 03 00
	00		 jbe	 $LN12@MainThread

; 680  : 			{
; 681  : 				BOOL isLastFragment = dataRemaining <= TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE;

  008fc	81 7c 24 48 00
	00 04 00	 cmp	 DWORD PTR dataRemaining$[rsp], 262144 ; 00040000H
  00904	77 0d		 ja	 SHORT $LN55@MainThread
  00906	c7 84 24 e0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv433[rsp], 1
  00911	eb 0b		 jmp	 SHORT $LN56@MainThread
$LN55@MainThread:
  00913	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv433[rsp], 0
$LN56@MainThread:
  0091e	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR tv433[rsp]
  00925	89 84 24 b4 00
	00 00		 mov	 DWORD PTR isLastFragment$29744[rsp], eax

; 682  : 				
; 683  : 				ULONG dataFragmentLength = isLastFragment ? dataRemaining : TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE;

  0092c	83 bc 24 b4 00
	00 00 00	 cmp	 DWORD PTR isLastFragment$29744[rsp], 0
  00934	74 0d		 je	 SHORT $LN57@MainThread
  00936	8b 44 24 48	 mov	 eax, DWORD PTR dataRemaining$[rsp]
  0093a	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv435[rsp], eax
  00941	eb 0b		 jmp	 SHORT $LN58@MainThread
$LN57@MainThread:
  00943	c7 84 24 e4 00
	00 00 00 00 04
	00		 mov	 DWORD PTR tv435[rsp], 262144 ; 00040000H
$LN58@MainThread:
  0094e	8b 84 24 e4 00
	00 00		 mov	 eax, DWORD PTR tv435[rsp]
  00955	89 84 24 b0 00
	00 00		 mov	 DWORD PTR dataFragmentLength$29745[rsp], eax

; 684  : 				activeFragmentBuffer = (activeFragmentBuffer == queue->FragmentBufferA ? queue->FragmentBufferB : queue->FragmentBufferA);

  0095c	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  00961	48 8b 80 c0 01
	00 00		 mov	 rax, QWORD PTR [rax+448]
  00968	48 39 44 24 58	 cmp	 QWORD PTR activeFragmentBuffer$[rsp], rax
  0096d	75 16		 jne	 SHORT $LN59@MainThread
  0096f	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  00974	48 8b 80 c8 01
	00 00		 mov	 rax, QWORD PTR [rax+456]
  0097b	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv440[rsp], rax
  00983	eb 14		 jmp	 SHORT $LN60@MainThread
$LN59@MainThread:
  00985	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  0098a	48 8b 80 c0 01
	00 00		 mov	 rax, QWORD PTR [rax+448]
  00991	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv440[rsp], rax
$LN60@MainThread:
  00999	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR tv440[rsp]
  009a1	48 89 44 24 58	 mov	 QWORD PTR activeFragmentBuffer$[rsp], rax

; 685  : 
; 686  : 				InterlockedIncrement (&queue->IoThreadPendingRequestCount);

  009a6	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  009ab	48 05 58 02 00
	00		 add	 rax, 600		; 00000258H
  009b1	f0 83 00 01	 lock add DWORD PTR [rax], 1

; 687  : 
; 688  : 				// Create IO request
; 689  : 				request = GetPoolBuffer (queue, sizeof (EncryptedIoRequest));

  009b5	ba 60 00 00 00	 mov	 edx, 96			; 00000060H
  009ba	48 8b 4c 24 60	 mov	 rcx, QWORD PTR queue$[rsp]
  009bf	e8 00 00 00 00	 call	 GetPoolBuffer
  009c4	48 89 44 24 68	 mov	 QWORD PTR request$[rsp], rax

; 690  : 				request->Item = item;

  009c9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR request$[rsp]
  009ce	48 8b 44 24 78	 mov	 rax, QWORD PTR item$[rsp]
  009d3	48 89 01	 mov	 QWORD PTR [rcx], rax

; 691  : 				request->CompleteOriginalIrp = isLastFragment;

  009d6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR request$[rsp]
  009db	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR isLastFragment$29744[rsp]
  009e2	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 692  : 				request->Offset = fragmentOffset;

  009e5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR request$[rsp]
  009ea	48 8b 44 24 40	 mov	 rax, QWORD PTR fragmentOffset$[rsp]
  009ef	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 693  : 				request->Data = activeFragmentBuffer;

  009f3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR request$[rsp]
  009f8	48 8b 44 24 58	 mov	 rax, QWORD PTR activeFragmentBuffer$[rsp]
  009fd	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 694  : 				request->OrigDataBufferFragment = dataBuffer;

  00a01	48 8b 4c 24 68	 mov	 rcx, QWORD PTR request$[rsp]
  00a06	48 8b 44 24 70	 mov	 rax, QWORD PTR dataBuffer$[rsp]
  00a0b	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 695  : 				request->Length = dataFragmentLength;

  00a0f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR request$[rsp]
  00a14	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR dataFragmentLength$29745[rsp]
  00a1b	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 696  : 
; 697  : 				if (queue->IsFilterDevice)

  00a1e	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  00a23	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  00a27	0f 84 8a 00 00
	00		 je	 $LN11@MainThread

; 698  : 				{
; 699  : 					if (queue->EncryptedAreaStart == -1 || queue->EncryptedAreaEnd == -1)

  00a2d	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  00a32	48 83 78 78 ff	 cmp	 QWORD PTR [rax+120], -1
  00a37	74 12		 je	 SHORT $LN9@MainThread
  00a39	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  00a3e	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00a45	48 83 f8 ff	 cmp	 rax, -1
  00a49	75 0e		 jne	 SHORT $LN10@MainThread
$LN9@MainThread:

; 700  : 					{
; 701  : 						request->EncryptedLength = 0;

  00a4b	48 8b 44 24 68	 mov	 rax, QWORD PTR request$[rsp]
  00a50	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [rax+40], 0

; 702  : 					}
; 703  : 					else

  00a57	eb 5c		 jmp	 SHORT $LN8@MainThread
$LN10@MainThread:

; 704  : 					{
; 705  : 						// Get intersection of data fragment with encrypted area
; 706  : 						GetIntersection (fragmentOffset.QuadPart, dataFragmentLength, queue->EncryptedAreaStart, queue->EncryptedAreaEnd, &intersectStart, &intersectLength);

  00a59	48 8d 44 24 30	 lea	 rax, QWORD PTR intersectLength$[rsp]
  00a5e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00a63	48 8d 44 24 38	 lea	 rax, QWORD PTR intersectStart$[rsp]
  00a68	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a6d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR queue$[rsp]
  00a72	4d 8b 89 80 00
	00 00		 mov	 r9, QWORD PTR [r9+128]
  00a79	4c 8b 44 24 60	 mov	 r8, QWORD PTR queue$[rsp]
  00a7e	4d 8b 40 78	 mov	 r8, QWORD PTR [r8+120]
  00a82	8b 94 24 b0 00
	00 00		 mov	 edx, DWORD PTR dataFragmentLength$29745[rsp]
  00a89	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fragmentOffset$[rsp]
  00a8e	e8 00 00 00 00	 call	 GetIntersection

; 707  : 
; 708  : 						request->EncryptedOffset = intersectStart - fragmentOffset.QuadPart;

  00a93	48 8b 54 24 40	 mov	 rdx, QWORD PTR fragmentOffset$[rsp]
  00a98	48 8b 4c 24 38	 mov	 rcx, QWORD PTR intersectStart$[rsp]
  00a9d	48 2b ca	 sub	 rcx, rdx
  00aa0	48 8b 44 24 68	 mov	 rax, QWORD PTR request$[rsp]
  00aa5	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 709  : 						request->EncryptedLength = intersectLength;

  00aa9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR request$[rsp]
  00aae	8b 44 24 30	 mov	 eax, DWORD PTR intersectLength$[rsp]
  00ab2	89 41 28	 mov	 DWORD PTR [rcx+40], eax
$LN8@MainThread:

; 710  : 					}
; 711  : 				}
; 712  : 				else

  00ab5	eb 1c		 jmp	 SHORT $LN7@MainThread
$LN11@MainThread:

; 713  : 				{
; 714  : 					request->EncryptedOffset = 0;

  00ab7	48 8b 44 24 68	 mov	 rax, QWORD PTR request$[rsp]
  00abc	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 715  : 					request->EncryptedLength = dataFragmentLength;

  00ac4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR request$[rsp]
  00ac9	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR dataFragmentLength$29745[rsp]
  00ad0	89 41 28	 mov	 DWORD PTR [rcx+40], eax
$LN7@MainThread:

; 716  : 				}
; 717  : 
; 718  : 				AcquireFragmentBuffer (queue, activeFragmentBuffer);

  00ad3	48 8b 54 24 58	 mov	 rdx, QWORD PTR activeFragmentBuffer$[rsp]
  00ad8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR queue$[rsp]
  00add	e8 00 00 00 00	 call	 AcquireFragmentBuffer

; 719  : 
; 720  : 				if (item->Write)

  00ae2	48 8b 54 24 78	 mov	 rdx, QWORD PTR item$[rsp]
  00ae7	83 7a 10 00	 cmp	 DWORD PTR [rdx+16], 0
  00aeb	0f 84 47 01 00
	00		 je	 $LN6@MainThread

; 721  : 				{
; 722  : 					// Encrypt data
; 723  : 					memcpy (activeFragmentBuffer, dataBuffer, dataFragmentLength);

  00af1	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR dataFragmentLength$29745[rsp]
  00af8	48 8b 7c 24 58	 mov	 rdi, QWORD PTR activeFragmentBuffer$[rsp]
  00afd	48 8b 74 24 70	 mov	 rsi, QWORD PTR dataBuffer$[rsp]
  00b02	f3 a4		 rep movsb

; 724  : 
; 725  : 					if (request->EncryptedLength > 0)

  00b04	48 8b 44 24 68	 mov	 rax, QWORD PTR request$[rsp]
  00b09	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  00b0d	0f 86 25 01 00
	00		 jbe	 $LN5@MainThread

; 726  : 					{
; 727  : 						UINT64_STRUCT dataUnit;
; 728  : 						ASSERT (request->EncryptedOffset + request->EncryptedLength <= request->Offset.QuadPart + request->Length);

  00b13	48 8b 44 24 68	 mov	 rax, QWORD PTR request$[rsp]
  00b18	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  00b1b	48 8b 44 24 68	 mov	 rax, QWORD PTR request$[rsp]
  00b20	48 03 50 20	 add	 rdx, QWORD PTR [rax+32]
  00b24	48 8b 44 24 68	 mov	 rax, QWORD PTR request$[rsp]
  00b29	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00b2c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR request$[rsp]
  00b31	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  00b35	48 3b d0	 cmp	 rdx, rax
  00b38	7e 2a		 jle	 SHORT $LN61@MainThread
  00b3a	45 33 c9	 xor	 r9d, r9d
  00b3d	41 b8 d8 02 00
	00		 mov	 r8d, 728		; 000002d8H
  00b43	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EP@FEOCDHHD@c?3?2home?2public?2desktop?2projects?2@FNODOBFM@
  00b4a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0GC@JKEACOCL@request?9?$DOEncryptedOffset?5?$CL?5reque@FNODOBFM@
  00b51	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  00b57	c7 84 24 f0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv498[rsp], 0
  00b62	eb 0b		 jmp	 SHORT $LN62@MainThread
$LN61@MainThread:
  00b64	c7 84 24 f0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv498[rsp], 1
$LN62@MainThread:

; 729  : 
; 730  : 						dataUnit.Value = (request->Offset.QuadPart + request->EncryptedOffset) / ENCRYPTION_DATA_UNIT_SIZE;

  00b6f	48 8b 44 24 68	 mov	 rax, QWORD PTR request$[rsp]
  00b74	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00b78	48 8b 4c 24 68	 mov	 rcx, QWORD PTR request$[rsp]
  00b7d	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00b81	48 99		 cdq
  00b83	48 81 e2 ff 01
	00 00		 and	 rdx, 511		; 000001ffH
  00b8a	48 03 c2	 add	 rax, rdx
  00b8d	48 c1 f8 09	 sar	 rax, 9
  00b91	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR dataUnit$29754[rsp], rax

; 731  : 
; 732  : 						if (queue->CryptoInfo->bPartitionInInactiveSysEncScope)

  00b99	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  00b9e	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  00ba2	83 b8 28 44 00
	00 00		 cmp	 DWORD PTR [rax+17448], 0
  00ba9	74 25		 je	 SHORT $LN4@MainThread

; 733  : 							dataUnit.Value += queue->CryptoInfo->FirstDataUnitNo.Value;

  00bab	48 8b 4c 24 60	 mov	 rcx, QWORD PTR queue$[rsp]
  00bb0	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  00bb4	48 8b 89 30 44
	00 00		 mov	 rcx, QWORD PTR [rcx+17456]
  00bbb	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR dataUnit$29754[rsp]
  00bc3	48 03 c1	 add	 rax, rcx
  00bc6	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR dataUnit$29754[rsp], rax
  00bce	eb 2d		 jmp	 SHORT $LN3@MainThread
$LN4@MainThread:

; 734  : 						else if (queue->RemapEncryptedArea)

  00bd0	48 8b 44 24 60	 mov	 rax, QWORD PTR queue$[rsp]
  00bd5	83 b8 8c 00 00
	00 00		 cmp	 DWORD PTR [rax+140], 0
  00bdc	74 1f		 je	 SHORT $LN2@MainThread

; 735  : 							dataUnit.Value += queue->RemappedAreaDataUnitOffset;

  00bde	48 8b 4c 24 60	 mov	 rcx, QWORD PTR queue$[rsp]
  00be3	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  00bea	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR dataUnit$29754[rsp]
  00bf2	48 03 c1	 add	 rax, rcx
  00bf5	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR dataUnit$29754[rsp], rax
$LN2@MainThread:
$LN3@MainThread:

; 736  : 								
; 737  : 						EncryptDataUnits (activeFragmentBuffer + request->EncryptedOffset, &dataUnit, request->EncryptedLength / ENCRYPTION_DATA_UNIT_SIZE, queue->CryptoInfo);

  00bfd	33 d2		 xor	 edx, edx
  00bff	48 8b 44 24 68	 mov	 rax, QWORD PTR request$[rsp]
  00c04	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00c07	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00c0c	f7 f1		 div	 ecx
  00c0e	44 8b c0	 mov	 r8d, eax
  00c11	48 8b 44 24 68	 mov	 rax, QWORD PTR request$[rsp]
  00c16	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00c1a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR activeFragmentBuffer$[rsp]
  00c1f	48 03 c8	 add	 rcx, rax
  00c22	4c 8b 4c 24 60	 mov	 r9, QWORD PTR queue$[rsp]
  00c27	4d 8b 49 48	 mov	 r9, QWORD PTR [r9+72]
  00c2b	48 8d 94 24 b8
	00 00 00	 lea	 rdx, QWORD PTR dataUnit$29754[rsp]
  00c33	e8 00 00 00 00	 call	 EncryptDataUnits
$LN5@MainThread:
$LN6@MainThread:

; 738  : 					}
; 739  : 				}
; 740  : 
; 741  : 				// Queue IO request
; 742  : 				ExInterlockedInsertTailList (&queue->IoThreadQueue, &request->ListEntry, &queue->IoThreadQueueLock);

  00c38	4c 8b 44 24 60	 mov	 r8, QWORD PTR queue$[rsp]
  00c3d	49 81 c0 68 01
	00 00		 add	 r8, 360			; 00000168H
  00c44	48 8b 54 24 68	 mov	 rdx, QWORD PTR request$[rsp]
  00c49	48 83 c2 40	 add	 rdx, 64			; 00000040H
  00c4d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR queue$[rsp]
  00c52	48 81 c1 58 01
	00 00		 add	 rcx, 344		; 00000158H
  00c59	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExInterlockedInsertTailList

; 743  : 				KeSetEvent (&queue->IoThreadQueueNotEmptyEvent, IO_DISK_INCREMENT, FALSE);

  00c5f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR queue$[rsp]
  00c64	48 81 c1 70 01
	00 00		 add	 rcx, 368		; 00000170H
  00c6b	45 33 c0	 xor	 r8d, r8d
  00c6e	ba 01 00 00 00	 mov	 edx, 1
  00c73	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 744  : 
; 745  : 				if (isLastFragment)

  00c79	83 bc 24 b4 00
	00 00 00	 cmp	 DWORD PTR isLastFragment$29744[rsp], 0
  00c81	74 02		 je	 SHORT $LN1@MainThread

; 746  : 					break;

  00c83	eb 32		 jmp	 SHORT $LN12@MainThread
$LN1@MainThread:

; 747  : 
; 748  : 				dataRemaining -= TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE;

  00c85	8b 44 24 48	 mov	 eax, DWORD PTR dataRemaining$[rsp]
  00c89	2d 00 00 04 00	 sub	 eax, 262144		; 00040000H
  00c8e	89 44 24 48	 mov	 DWORD PTR dataRemaining$[rsp], eax

; 749  : 				dataBuffer += TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE;

  00c92	48 8b 44 24 70	 mov	 rax, QWORD PTR dataBuffer$[rsp]
  00c97	48 05 00 00 04
	00		 add	 rax, 262144		; 00040000H
  00c9d	48 89 44 24 70	 mov	 QWORD PTR dataBuffer$[rsp], rax

; 750  : 				fragmentOffset.QuadPart += TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE;

  00ca2	48 8b 44 24 40	 mov	 rax, QWORD PTR fragmentOffset$[rsp]
  00ca7	48 05 00 00 04
	00		 add	 rax, 262144		; 00040000H
  00cad	48 89 44 24 40	 mov	 QWORD PTR fragmentOffset$[rsp], rax

; 751  : 			}

  00cb2	e9 3a fc ff ff	 jmp	 $LN13@MainThread
$LN12@MainThread:

; 752  : 		}

  00cb7	e9 c8 f3 ff ff	 jmp	 $LN74@MainThread
$LN41@MainThread:

; 753  : 	}

  00cbc	e9 87 f3 ff ff	 jmp	 $LN63@MainThread
$LN44@MainThread:

; 754  : 
; 755  : 	PsTerminateSystemThread (STATUS_SUCCESS);

  00cc1	33 c9		 xor	 ecx, ecx
  00cc3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsTerminateSystemThread

; 756  : }

  00cc9	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  00cd0	5f		 pop	 rdi
  00cd1	5e		 pop	 rsi
  00cd2	c3		 ret	 0
MainThreadProc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CompletionThreadProc DD imagerel CompletionThreadProc
	DD	imagerel CompletionThreadProc+608
	DD	imagerel $unwind$CompletionThreadProc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CompletionThreadProc DD 010901H
	DD	0c209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT CompletionThreadProc
_TEXT	SEGMENT
dataUnit$ = 48
listEntry$ = 56
queue$ = 64
request$ = 72
tv139 = 80
tv170 = 84
threadArg$ = 112
CompletionThreadProc PROC				; COMDAT

; 225  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 226  : 	EncryptedIoQueue *queue = (EncryptedIoQueue *) threadArg;

  00009	48 8b 44 24 70	 mov	 rax, QWORD PTR threadArg$[rsp]
  0000e	48 89 44 24 40	 mov	 QWORD PTR queue$[rsp], rax

; 227  : 	PLIST_ENTRY listEntry;
; 228  : 	EncryptedIoRequest *request;
; 229  : 	UINT64_STRUCT dataUnit;
; 230  : 
; 231  : 	if (IsEncryptionThreadPoolRunning())

  00013	e8 00 00 00 00	 call	 IsEncryptionThreadPoolRunning
  00018	85 c0		 test	 eax, eax
  0001a	74 13		 je	 SHORT $LN12@Completion

; 232  : 		KeSetPriorityThread (KeGetCurrentThread(), LOW_REALTIME_PRIORITY);

  0001c	e8 00 00 00 00	 call	 KeGetCurrentThread
  00021	ba 10 00 00 00	 mov	 edx, 16
  00026	48 8b c8	 mov	 rcx, rax
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetPriorityThread
$LN12@Completion:
$LN19@Completion:
$LN11@Completion:

; 233  : 
; 234  : 	while (!queue->ThreadExitRequested)

  0002f	48 8b 44 24 40	 mov	 rax, QWORD PTR queue$[rsp]
  00034	8b 80 8c 02 00
	00		 mov	 eax, DWORD PTR [rax+652]
  0003a	85 c0		 test	 eax, eax
  0003c	0f 85 11 02 00
	00		 jne	 $LN10@Completion

; 235  : 	{
; 236  : 		if (!NT_SUCCESS (KeWaitForSingleObject (&queue->CompletionThreadQueueNotEmptyEvent, Executive, KernelMode, FALSE, NULL)))

  00042	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  00047	48 81 c1 a8 01
	00 00		 add	 rcx, 424		; 000001a8H
  0004e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00057	45 33 c9	 xor	 r9d, r9d
  0005a	45 33 c0	 xor	 r8d, r8d
  0005d	33 d2		 xor	 edx, edx
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  00065	85 c0		 test	 eax, eax
  00067	7d 02		 jge	 SHORT $LN9@Completion

; 237  : 			continue;

  00069	eb c4		 jmp	 SHORT $LN11@Completion
$LN9@Completion:

; 238  : 
; 239  : 		if (queue->ThreadExitRequested)

  0006b	48 8b 44 24 40	 mov	 rax, QWORD PTR queue$[rsp]
  00070	8b 80 8c 02 00
	00		 mov	 eax, DWORD PTR [rax+652]
  00076	85 c0		 test	 eax, eax
  00078	74 05		 je	 SHORT $LN8@Completion

; 240  : 			break;

  0007a	e9 d4 01 00 00	 jmp	 $LN10@Completion
$LN8@Completion:
$LN7@Completion:

; 241  : 
; 242  : 		while ((listEntry = ExInterlockedRemoveHeadList (&queue->CompletionThreadQueue, &queue->CompletionThreadQueueLock)))

  0007f	48 8b 54 24 40	 mov	 rdx, QWORD PTR queue$[rsp]
  00084	48 81 c2 a0 01
	00 00		 add	 rdx, 416		; 000001a0H
  0008b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  00090	48 81 c1 90 01
	00 00		 add	 rcx, 400		; 00000190H
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExInterlockedRemoveHeadList
  0009d	48 89 44 24 38	 mov	 QWORD PTR listEntry$[rsp], rax
  000a2	48 83 7c 24 38
	00		 cmp	 QWORD PTR listEntry$[rsp], 0
  000a8	0f 84 a0 01 00
	00		 je	 $LN6@Completion

; 243  : 		{
; 244  : 			request = CONTAINING_RECORD (listEntry, EncryptedIoRequest, CompletionListEntry);

  000ae	48 8b 44 24 38	 mov	 rax, QWORD PTR listEntry$[rsp]
  000b3	48 83 e8 50	 sub	 rax, 80			; 00000050H
  000b7	48 89 44 24 48	 mov	 QWORD PTR request$[rsp], rax

; 245  : 
; 246  : 			if (request->EncryptedLength > 0 && NT_SUCCESS (request->Item->Status))

  000bc	48 8b 44 24 48	 mov	 rax, QWORD PTR request$[rsp]
  000c1	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  000c5	0f 86 20 01 00
	00		 jbe	 $LN5@Completion
  000cb	48 8b 44 24 48	 mov	 rax, QWORD PTR request$[rsp]
  000d0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d3	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  000d7	0f 8c 0e 01 00
	00		 jl	 $LN5@Completion

; 247  : 			{
; 248  : 				ASSERT (request->EncryptedOffset + request->EncryptedLength <= request->Offset.QuadPart + request->Length);

  000dd	48 8b 44 24 48	 mov	 rax, QWORD PTR request$[rsp]
  000e2	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  000e5	48 8b 44 24 48	 mov	 rax, QWORD PTR request$[rsp]
  000ea	48 03 50 20	 add	 rdx, QWORD PTR [rax+32]
  000ee	48 8b 44 24 48	 mov	 rax, QWORD PTR request$[rsp]
  000f3	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000f6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR request$[rsp]
  000fb	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  000ff	48 3b d0	 cmp	 rdx, rax
  00102	7e 27		 jle	 SHORT $LN15@Completion
  00104	45 33 c9	 xor	 r9d, r9d
  00107	41 b8 f8 00 00
	00		 mov	 r8d, 248		; 000000f8H
  0010d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EP@FEOCDHHD@c?3?2home?2public?2desktop?2projects?2@FNODOBFM@
  00114	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0GC@JKEACOCL@request?9?$DOEncryptedOffset?5?$CL?5reque@FNODOBFM@
  0011b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  00121	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv139[rsp], 0
  00129	eb 08		 jmp	 SHORT $LN16@Completion
$LN15@Completion:
  0012b	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv139[rsp], 1
$LN16@Completion:

; 249  : 				dataUnit.Value = (request->Offset.QuadPart + request->EncryptedOffset) / ENCRYPTION_DATA_UNIT_SIZE;

  00133	48 8b 44 24 48	 mov	 rax, QWORD PTR request$[rsp]
  00138	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0013c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR request$[rsp]
  00141	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00145	48 99		 cdq
  00147	48 81 e2 ff 01
	00 00		 and	 rdx, 511		; 000001ffH
  0014e	48 03 c2	 add	 rax, rdx
  00151	48 c1 f8 09	 sar	 rax, 9
  00155	48 89 44 24 30	 mov	 QWORD PTR dataUnit$[rsp], rax

; 250  : 
; 251  : 				if (queue->CryptoInfo->bPartitionInInactiveSysEncScope)

  0015a	48 8b 44 24 40	 mov	 rax, QWORD PTR queue$[rsp]
  0015f	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  00163	83 b8 28 44 00
	00 00		 cmp	 DWORD PTR [rax+17448], 0
  0016a	74 1f		 je	 SHORT $LN4@Completion

; 252  : 					dataUnit.Value += queue->CryptoInfo->FirstDataUnitNo.Value;

  0016c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  00171	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  00175	48 8b 89 30 44
	00 00		 mov	 rcx, QWORD PTR [rcx+17456]
  0017c	48 8b 44 24 30	 mov	 rax, QWORD PTR dataUnit$[rsp]
  00181	48 03 c1	 add	 rax, rcx
  00184	48 89 44 24 30	 mov	 QWORD PTR dataUnit$[rsp], rax
  00189	eb 27		 jmp	 SHORT $LN3@Completion
$LN4@Completion:

; 253  : 				else if (queue->RemapEncryptedArea)

  0018b	48 8b 44 24 40	 mov	 rax, QWORD PTR queue$[rsp]
  00190	83 b8 8c 00 00
	00 00		 cmp	 DWORD PTR [rax+140], 0
  00197	74 19		 je	 SHORT $LN2@Completion

; 254  : 					dataUnit.Value += queue->RemappedAreaDataUnitOffset;

  00199	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  0019e	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  001a5	48 8b 44 24 30	 mov	 rax, QWORD PTR dataUnit$[rsp]
  001aa	48 03 c1	 add	 rax, rcx
  001ad	48 89 44 24 30	 mov	 QWORD PTR dataUnit$[rsp], rax
$LN2@Completion:
$LN3@Completion:

; 255  : 
; 256  : 				DecryptDataUnits (request->Data + request->EncryptedOffset, &dataUnit, request->EncryptedLength / ENCRYPTION_DATA_UNIT_SIZE, queue->CryptoInfo);

  001b2	33 d2		 xor	 edx, edx
  001b4	48 8b 44 24 48	 mov	 rax, QWORD PTR request$[rsp]
  001b9	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  001bc	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001c1	f7 f1		 div	 ecx
  001c3	44 8b c0	 mov	 r8d, eax
  001c6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR request$[rsp]
  001cb	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  001cf	48 8b 44 24 48	 mov	 rax, QWORD PTR request$[rsp]
  001d4	48 03 48 20	 add	 rcx, QWORD PTR [rax+32]
  001d8	4c 8b 4c 24 40	 mov	 r9, QWORD PTR queue$[rsp]
  001dd	4d 8b 49 48	 mov	 r9, QWORD PTR [r9+72]
  001e1	48 8d 54 24 30	 lea	 rdx, QWORD PTR dataUnit$[rsp]
  001e6	e8 00 00 00 00	 call	 DecryptDataUnits
$LN5@Completion:

; 257  : 			}
; 258  : 
; 259  : 			if (request->CompleteOriginalIrp)

  001eb	48 8b 44 24 48	 mov	 rax, QWORD PTR request$[rsp]
  001f0	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  001f4	74 44		 je	 SHORT $LN1@Completion

; 260  : 			{
; 261  : 				CompleteOriginalIrp (request->Item, request->Item->Status,
; 262  : 					NT_SUCCESS (request->Item->Status) ? request->Item->OriginalLength : 0);

  001f6	48 8b 44 24 48	 mov	 rax, QWORD PTR request$[rsp]
  001fb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001fe	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  00202	7c 11		 jl	 SHORT $LN17@Completion
  00204	48 8b 44 24 48	 mov	 rax, QWORD PTR request$[rsp]
  00209	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0020c	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0020f	89 44 24 54	 mov	 DWORD PTR tv170[rsp], eax
  00213	eb 08		 jmp	 SHORT $LN18@Completion
$LN17@Completion:
  00215	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv170[rsp], 0
$LN18@Completion:
  0021d	44 8b 44 24 54	 mov	 r8d, DWORD PTR tv170[rsp]
  00222	48 8b 44 24 48	 mov	 rax, QWORD PTR request$[rsp]
  00227	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0022a	8b 50 20	 mov	 edx, DWORD PTR [rax+32]
  0022d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR request$[rsp]
  00232	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00235	e8 00 00 00 00	 call	 CompleteOriginalIrp
$LN1@Completion:

; 263  : 			}
; 264  : 
; 265  : 			ReleasePoolBuffer (queue, request);

  0023a	48 8b 54 24 48	 mov	 rdx, QWORD PTR request$[rsp]
  0023f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  00244	e8 00 00 00 00	 call	 ReleasePoolBuffer

; 266  : 		}

  00249	e9 31 fe ff ff	 jmp	 $LN7@Completion
$LN6@Completion:

; 267  : 	}

  0024e	e9 dc fd ff ff	 jmp	 $LN19@Completion
$LN10@Completion:

; 268  : 
; 269  : 	PsTerminateSystemThread (STATUS_SUCCESS);

  00253	33 c9		 xor	 ecx, ecx
  00255	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsTerminateSystemThread

; 270  : }

  0025b	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0025f	c3		 ret	 0
CompletionThreadProc ENDP
PUBLIC	EncryptedIoQueueStart
;	COMDAT pdata
pdata	SEGMENT
$pdata$EncryptedIoQueueStart DD imagerel $LN20
	DD	imagerel $LN20+1180
	DD	imagerel $unwind$EncryptedIoQueueStart
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EncryptedIoQueueStart DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EncryptedIoQueueStart
_TEXT	SEGMENT
i$ = 32
status$ = 36
buffer$ = 40
queue$ = 64
EncryptedIoQueueStart PROC				; COMDAT

; 869  : {

$LN20:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 870  : 	NTSTATUS status;
; 871  : 	EncryptedIoQueueBuffer *buffer;
; 872  : 	int i;
; 873  : 
; 874  : 	queue->StartPending = TRUE;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR queue$[rsp]
  0000e	c7 80 88 02 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+648], 1

; 875  : 	queue->ThreadExitRequested = FALSE;

  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR queue$[rsp]
  0001d	c7 80 8c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+652], 0

; 876  : 
; 877  : 	queue->OutstandingIoCount = 0;

  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR queue$[rsp]
  0002c	c7 80 38 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+568], 0

; 878  : 	queue->IoThreadPendingRequestCount = 0;

  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR queue$[rsp]
  0003b	c7 80 58 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+600], 0

; 879  : 
; 880  : 	queue->FirstPoolBuffer = NULL;

  00045	48 8b 44 24 40	 mov	 rax, QWORD PTR queue$[rsp]
  0004a	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0

; 881  : 	KeInitializeMutex (&queue->BufferPoolMutex, 0);

  00052	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  00057	48 83 c1 08	 add	 rcx, 8
  0005b	33 d2		 xor	 edx, edx
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeMutex

; 882  : 
; 883  : 	KeInitializeEvent (&queue->NoOutstandingIoEvent, SynchronizationEvent, FALSE);

  00063	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  00068	48 81 c1 40 02
	00 00		 add	 rcx, 576		; 00000240H
  0006f	45 33 c0	 xor	 r8d, r8d
  00072	ba 01 00 00 00	 mov	 edx, 1
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 884  : 	KeInitializeEvent (&queue->PoolBufferFreeEvent, SynchronizationEvent, FALSE);

  0007d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  00082	48 81 c1 60 02
	00 00		 add	 rcx, 608		; 00000260H
  00089	45 33 c0	 xor	 r8d, r8d
  0008c	ba 01 00 00 00	 mov	 edx, 1
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 885  : 	KeInitializeEvent (&queue->QueueResumedEvent, SynchronizationEvent, FALSE);

  00097	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  0009c	48 81 c1 a0 02
	00 00		 add	 rcx, 672		; 000002a0H
  000a3	45 33 c0	 xor	 r8d, r8d
  000a6	ba 01 00 00 00	 mov	 edx, 1
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 886  : 
; 887  : 	queue->FragmentBufferA = TCalloc (TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE);

  000b1	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  000b7	ba 00 00 04 00	 mov	 edx, 262144		; 00040000H
  000bc	33 c9		 xor	 ecx, ecx
  000be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  000c4	4c 8b d8	 mov	 r11, rax
  000c7	48 8b 44 24 40	 mov	 rax, QWORD PTR queue$[rsp]
  000cc	4c 89 98 c0 01
	00 00		 mov	 QWORD PTR [rax+448], r11

; 888  : 	if (!queue->FragmentBufferA)

  000d3	48 8b 44 24 40	 mov	 rax, QWORD PTR queue$[rsp]
  000d8	48 83 b8 c0 01
	00 00 00	 cmp	 QWORD PTR [rax+448], 0
  000e0	75 05		 jne	 SHORT $LN17@EncryptedI@6

; 889  : 		goto noMemory;

  000e2	e9 18 03 00 00	 jmp	 $noMemory$29821
$LN17@EncryptedI@6:

; 890  : 
; 891  : 	queue->FragmentBufferB = TCalloc (TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE);

  000e7	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  000ed	ba 00 00 04 00	 mov	 edx, 262144		; 00040000H
  000f2	33 c9		 xor	 ecx, ecx
  000f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  000fa	4c 8b d8	 mov	 r11, rax
  000fd	48 8b 44 24 40	 mov	 rax, QWORD PTR queue$[rsp]
  00102	4c 89 98 c8 01
	00 00		 mov	 QWORD PTR [rax+456], r11

; 892  : 	if (!queue->FragmentBufferB)

  00109	48 8b 44 24 40	 mov	 rax, QWORD PTR queue$[rsp]
  0010e	48 83 b8 c8 01
	00 00 00	 cmp	 QWORD PTR [rax+456], 0
  00116	75 05		 jne	 SHORT $LN16@EncryptedI@6

; 893  : 		goto noMemory;

  00118	e9 e2 02 00 00	 jmp	 $noMemory$29821
$LN16@EncryptedI@6:

; 894  : 
; 895  : 	KeInitializeEvent (&queue->FragmentBufferAFreeEvent, SynchronizationEvent, TRUE);

  0011d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  00122	48 81 c1 d0 01
	00 00		 add	 rcx, 464		; 000001d0H
  00129	41 b0 01	 mov	 r8b, 1
  0012c	ba 01 00 00 00	 mov	 edx, 1
  00131	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 896  : 	KeInitializeEvent (&queue->FragmentBufferBFreeEvent, SynchronizationEvent, TRUE);

  00137	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  0013c	48 81 c1 e8 01
	00 00		 add	 rcx, 488		; 000001e8H
  00143	41 b0 01	 mov	 r8b, 1
  00146	ba 01 00 00 00	 mov	 edx, 1
  0014b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 897  : 
; 898  : 	queue->ReadAheadBufferValid = FALSE;

  00151	4c 8b 5c 24 40	 mov	 r11, QWORD PTR queue$[rsp]
  00156	41 c7 83 00 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [r11+512], 0

; 899  : 	queue->ReadAheadBuffer = TCalloc (TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE);

  00161	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  00167	ba 00 00 04 00	 mov	 edx, 262144		; 00040000H
  0016c	33 c9		 xor	 ecx, ecx
  0016e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00174	4c 8b d8	 mov	 r11, rax
  00177	48 8b 44 24 40	 mov	 rax, QWORD PTR queue$[rsp]
  0017c	4c 89 98 28 02
	00 00		 mov	 QWORD PTR [rax+552], r11

; 900  : 	if (!queue->ReadAheadBuffer)

  00183	48 8b 44 24 40	 mov	 rax, QWORD PTR queue$[rsp]
  00188	48 83 b8 28 02
	00 00 00	 cmp	 QWORD PTR [rax+552], 0
  00190	75 05		 jne	 SHORT $LN15@EncryptedI@6

; 901  : 		goto noMemory;

  00192	e9 68 02 00 00	 jmp	 $noMemory$29821
$LN15@EncryptedI@6:

; 902  : 
; 903  : 	// Preallocate buffers
; 904  : 	for (i = 0; i < TC_ENC_IO_QUEUE_PREALLOCATED_IO_REQUEST_COUNT; ++i)

  00197	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0019f	eb 0b		 jmp	 SHORT $LN14@EncryptedI@6
$LN13@EncryptedI@6:
  001a1	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001a5	83 c0 01	 add	 eax, 1
  001a8	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN14@EncryptedI@6:
  001ac	83 7c 24 20 10	 cmp	 DWORD PTR i$[rsp], 16
  001b1	7d 3b		 jge	 SHORT $LN12@EncryptedI@6

; 905  : 	{
; 906  : 		if (i < TC_ENC_IO_QUEUE_PREALLOCATED_ITEM_COUNT && !GetPoolBuffer (queue, sizeof (EncryptedIoQueueItem)))

  001b3	83 7c 24 20 08	 cmp	 DWORD PTR i$[rsp], 8
  001b8	7d 19		 jge	 SHORT $LN11@EncryptedI@6
  001ba	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  001bf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  001c4	e8 00 00 00 00	 call	 GetPoolBuffer
  001c9	48 85 c0	 test	 rax, rax
  001cc	75 05		 jne	 SHORT $LN11@EncryptedI@6

; 907  : 			goto noMemory;

  001ce	e9 2c 02 00 00	 jmp	 $noMemory$29821
$LN11@EncryptedI@6:

; 908  : 
; 909  : 		if (!GetPoolBuffer (queue, sizeof (EncryptedIoRequest)))

  001d3	ba 60 00 00 00	 mov	 edx, 96			; 00000060H
  001d8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  001dd	e8 00 00 00 00	 call	 GetPoolBuffer
  001e2	48 85 c0	 test	 rax, rax
  001e5	75 05		 jne	 SHORT $LN10@EncryptedI@6

; 910  : 			goto noMemory;

  001e7	e9 13 02 00 00	 jmp	 $noMemory$29821
$LN10@EncryptedI@6:

; 911  : 	}

  001ec	eb b3		 jmp	 SHORT $LN13@EncryptedI@6
$LN12@EncryptedI@6:

; 912  : 
; 913  : 	for (buffer = queue->FirstPoolBuffer; buffer != NULL; buffer = buffer->NextBuffer)

  001ee	48 8b 44 24 40	 mov	 rax, QWORD PTR queue$[rsp]
  001f3	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  001f7	48 89 44 24 28	 mov	 QWORD PTR buffer$[rsp], rax
  001fc	eb 0d		 jmp	 SHORT $LN9@EncryptedI@6
$LN8@EncryptedI@6:
  001fe	48 8b 44 24 28	 mov	 rax, QWORD PTR buffer$[rsp]
  00203	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00206	48 89 44 24 28	 mov	 QWORD PTR buffer$[rsp], rax
$LN9@EncryptedI@6:
  0020b	48 83 7c 24 28
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00211	74 0e		 je	 SHORT $LN7@EncryptedI@6

; 914  : 	{
; 915  : 		buffer->InUse = FALSE;

  00213	48 8b 44 24 28	 mov	 rax, QWORD PTR buffer$[rsp]
  00218	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0

; 916  : 	}

  0021f	eb dd		 jmp	 SHORT $LN8@EncryptedI@6
$LN7@EncryptedI@6:

; 917  : 
; 918  : 	// Main thread
; 919  : 	InitializeListHead (&queue->MainThreadQueue);

  00221	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  00226	48 81 c1 20 01
	00 00		 add	 rcx, 288		; 00000120H
  0022d	e8 00 00 00 00	 call	 InitializeListHead

; 920  : 	KeInitializeSpinLock (&queue->MainThreadQueueLock);

  00232	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  00237	48 81 c1 30 01
	00 00		 add	 rcx, 304		; 00000130H
  0023e	e8 00 00 00 00	 call	 KeInitializeSpinLock

; 921  : 	KeInitializeEvent (&queue->MainThreadQueueNotEmptyEvent, SynchronizationEvent, FALSE);

  00243	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  00248	48 81 c1 38 01
	00 00		 add	 rcx, 312		; 00000138H
  0024f	45 33 c0	 xor	 r8d, r8d
  00252	ba 01 00 00 00	 mov	 edx, 1
  00257	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 922  : 
; 923  : 	status = TCStartThread (MainThreadProc, queue, &queue->MainThread);

  0025d	4c 8b 44 24 40	 mov	 r8, QWORD PTR queue$[rsp]
  00262	49 81 c0 18 01
	00 00		 add	 r8, 280			; 00000118H
  00269	48 8b 54 24 40	 mov	 rdx, QWORD PTR queue$[rsp]
  0026e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:MainThreadProc
  00275	e8 00 00 00 00	 call	 TCStartThread
  0027a	89 44 24 24	 mov	 DWORD PTR status$[rsp], eax

; 924  : 	if (!NT_SUCCESS (status))

  0027e	83 7c 24 24 00	 cmp	 DWORD PTR status$[rsp], 0
  00283	7d 05		 jge	 SHORT $LN6@EncryptedI@6

; 925  : 		goto err;

  00285	e9 7d 01 00 00	 jmp	 $err$29839
$LN6@EncryptedI@6:

; 926  : 
; 927  : 	// IO thread
; 928  : 	InitializeListHead (&queue->IoThreadQueue);

  0028a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  0028f	48 81 c1 58 01
	00 00		 add	 rcx, 344		; 00000158H
  00296	e8 00 00 00 00	 call	 InitializeListHead

; 929  : 	KeInitializeSpinLock (&queue->IoThreadQueueLock);

  0029b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  002a0	48 81 c1 68 01
	00 00		 add	 rcx, 360		; 00000168H
  002a7	e8 00 00 00 00	 call	 KeInitializeSpinLock

; 930  : 	KeInitializeEvent (&queue->IoThreadQueueNotEmptyEvent, SynchronizationEvent, FALSE);

  002ac	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  002b1	48 81 c1 70 01
	00 00		 add	 rcx, 368		; 00000170H
  002b8	45 33 c0	 xor	 r8d, r8d
  002bb	ba 01 00 00 00	 mov	 edx, 1
  002c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 931  : 
; 932  : 	status = TCStartThread (IoThreadProc, queue, &queue->IoThread);

  002c6	4c 8b 44 24 40	 mov	 r8, QWORD PTR queue$[rsp]
  002cb	49 81 c0 50 01
	00 00		 add	 r8, 336			; 00000150H
  002d2	48 8b 54 24 40	 mov	 rdx, QWORD PTR queue$[rsp]
  002d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:IoThreadProc
  002de	e8 00 00 00 00	 call	 TCStartThread
  002e3	89 44 24 24	 mov	 DWORD PTR status$[rsp], eax

; 933  : 	if (!NT_SUCCESS (status))

  002e7	83 7c 24 24 00	 cmp	 DWORD PTR status$[rsp], 0
  002ec	7d 31		 jge	 SHORT $LN5@EncryptedI@6

; 934  : 	{
; 935  : 		queue->ThreadExitRequested = TRUE;

  002ee	48 8b 44 24 40	 mov	 rax, QWORD PTR queue$[rsp]
  002f3	c7 80 8c 02 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+652], 1

; 936  : 		TCStopThread (queue->MainThread, &queue->MainThreadQueueNotEmptyEvent);

  002fd	48 8b 54 24 40	 mov	 rdx, QWORD PTR queue$[rsp]
  00302	48 81 c2 38 01
	00 00		 add	 rdx, 312		; 00000138H
  00309	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  0030e	48 8b 89 18 01
	00 00		 mov	 rcx, QWORD PTR [rcx+280]
  00315	e8 00 00 00 00	 call	 TCStopThread

; 937  : 		goto err;

  0031a	e9 e8 00 00 00	 jmp	 $err$29839
$LN5@EncryptedI@6:

; 938  : 	}
; 939  : 
; 940  : 	// Completion thread
; 941  : 	InitializeListHead (&queue->CompletionThreadQueue);

  0031f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  00324	48 81 c1 90 01
	00 00		 add	 rcx, 400		; 00000190H
  0032b	e8 00 00 00 00	 call	 InitializeListHead

; 942  : 	KeInitializeSpinLock (&queue->CompletionThreadQueueLock);

  00330	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  00335	48 81 c1 a0 01
	00 00		 add	 rcx, 416		; 000001a0H
  0033c	e8 00 00 00 00	 call	 KeInitializeSpinLock

; 943  : 	KeInitializeEvent (&queue->CompletionThreadQueueNotEmptyEvent, SynchronizationEvent, FALSE);

  00341	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  00346	48 81 c1 a8 01
	00 00		 add	 rcx, 424		; 000001a8H
  0034d	45 33 c0	 xor	 r8d, r8d
  00350	ba 01 00 00 00	 mov	 edx, 1
  00355	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 944  : 
; 945  : 	status = TCStartThread (CompletionThreadProc, queue, &queue->CompletionThread);

  0035b	4c 8b 44 24 40	 mov	 r8, QWORD PTR queue$[rsp]
  00360	49 81 c0 88 01
	00 00		 add	 r8, 392			; 00000188H
  00367	48 8b 54 24 40	 mov	 rdx, QWORD PTR queue$[rsp]
  0036c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CompletionThreadProc
  00373	e8 00 00 00 00	 call	 TCStartThread
  00378	89 44 24 24	 mov	 DWORD PTR status$[rsp], eax

; 946  : 	if (!NT_SUCCESS (status))

  0037c	83 7c 24 24 00	 cmp	 DWORD PTR status$[rsp], 0
  00381	7d 4b		 jge	 SHORT $LN4@EncryptedI@6

; 947  : 	{
; 948  : 		queue->ThreadExitRequested = TRUE;

  00383	48 8b 44 24 40	 mov	 rax, QWORD PTR queue$[rsp]
  00388	c7 80 8c 02 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+652], 1

; 949  : 		TCStopThread (queue->MainThread, &queue->MainThreadQueueNotEmptyEvent);

  00392	48 8b 54 24 40	 mov	 rdx, QWORD PTR queue$[rsp]
  00397	48 81 c2 38 01
	00 00		 add	 rdx, 312		; 00000138H
  0039e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  003a3	48 8b 89 18 01
	00 00		 mov	 rcx, QWORD PTR [rcx+280]
  003aa	e8 00 00 00 00	 call	 TCStopThread

; 950  : 		TCStopThread (queue->IoThread, &queue->IoThreadQueueNotEmptyEvent);

  003af	48 8b 54 24 40	 mov	 rdx, QWORD PTR queue$[rsp]
  003b4	48 81 c2 70 01
	00 00		 add	 rdx, 368		; 00000170H
  003bb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  003c0	48 8b 89 50 01
	00 00		 mov	 rcx, QWORD PTR [rcx+336]
  003c7	e8 00 00 00 00	 call	 TCStopThread

; 951  : 		goto err;

  003cc	eb 39		 jmp	 SHORT $err$29839
$LN4@EncryptedI@6:

; 952  : 	}
; 953  : 
; 954  : #ifdef TC_TRACE_IO_QUEUE
; 955  : 	GetElapsedTimeInit (&queue->LastPerformanceCounter);
; 956  : #endif
; 957  : 
; 958  : 	queue->StopPending = FALSE;

  003ce	48 8b 44 24 40	 mov	 rax, QWORD PTR queue$[rsp]
  003d3	c7 80 98 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+664], 0

; 959  : 	queue->StartPending = FALSE;

  003dd	48 8b 44 24 40	 mov	 rax, QWORD PTR queue$[rsp]
  003e2	c7 80 88 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+648], 0

; 960  : 
; 961  : 	Dump ("Queue started\n");

  003ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@IPONPJEA@Queue?5started?6?$AA@FNODOBFM@
  003f3	e8 00 00 00 00	 call	 DbgPrint

; 962  : 	return STATUS_SUCCESS;

  003f8	33 c0		 xor	 eax, eax
  003fa	e9 98 00 00 00	 jmp	 $LN18@EncryptedI@6
$noMemory$29821:

; 963  : 
; 964  : noMemory:
; 965  : 	status = STATUS_INSUFFICIENT_RESOURCES;

  003ff	c7 44 24 24 9a
	00 00 c0	 mov	 DWORD PTR status$[rsp], -1073741670 ; ffffffffc000009aH
$err$29839:

; 966  : 
; 967  : err:
; 968  : 	if (queue->FragmentBufferA)

  00407	48 8b 44 24 40	 mov	 rax, QWORD PTR queue$[rsp]
  0040c	48 83 b8 c0 01
	00 00 00	 cmp	 QWORD PTR [rax+448], 0
  00414	74 17		 je	 SHORT $LN3@EncryptedI@6

; 969  : 		TCfree (queue->FragmentBufferA);

  00416	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  0041b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  00420	48 8b 89 c0 01
	00 00		 mov	 rcx, QWORD PTR [rcx+448]
  00427	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN3@EncryptedI@6:

; 970  : 	if (queue->FragmentBufferB)

  0042d	48 8b 44 24 40	 mov	 rax, QWORD PTR queue$[rsp]
  00432	48 83 b8 c8 01
	00 00 00	 cmp	 QWORD PTR [rax+456], 0
  0043a	74 17		 je	 SHORT $LN2@EncryptedI@6

; 971  : 		TCfree (queue->FragmentBufferB);

  0043c	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00441	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  00446	48 8b 89 c8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+456]
  0044d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN2@EncryptedI@6:

; 972  : 	if (queue->ReadAheadBuffer)

  00453	48 8b 44 24 40	 mov	 rax, QWORD PTR queue$[rsp]
  00458	48 83 b8 28 02
	00 00 00	 cmp	 QWORD PTR [rax+552], 0
  00460	74 17		 je	 SHORT $LN1@EncryptedI@6

; 973  : 		TCfree (queue->ReadAheadBuffer);

  00462	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00467	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  0046c	48 8b 89 28 02
	00 00		 mov	 rcx, QWORD PTR [rcx+552]
  00473	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN1@EncryptedI@6:

; 974  : 
; 975  : 	FreePoolBuffers (queue);

  00479	48 8b 4c 24 40	 mov	 rcx, QWORD PTR queue$[rsp]
  0047e	e8 00 00 00 00	 call	 FreePoolBuffers

; 976  : 
; 977  : 	queue->StartPending = FALSE;

  00483	4c 8b 5c 24 40	 mov	 r11, QWORD PTR queue$[rsp]
  00488	41 c7 83 88 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [r11+648], 0

; 978  : 	return status;

  00493	8b 44 24 24	 mov	 eax, DWORD PTR status$[rsp]
$LN18@EncryptedI@6:

; 979  : }

  00497	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0049b	c3		 ret	 0
EncryptedIoQueueStart ENDP
END
