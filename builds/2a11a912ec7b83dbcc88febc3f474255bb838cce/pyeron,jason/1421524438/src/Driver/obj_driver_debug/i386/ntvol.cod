; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\home\public\desktop\projects\ciphershed.build\src\driver\ntvol.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_ProbingHostDeviceForWrite
_BSS	SEGMENT
_ProbingHostDeviceForWrite DD 01H DUP (?)
_BSS	ENDS
PUBLIC	??_C@_1BA@GIIKONIJ@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BC@MAMPPFNN@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AAU?$AAN?$AAC?$AA?2?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BH@JONGPBLO@Incorrect?5volume?5size?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BJ@MEKDGODO@Volume?5data?5end?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BK@BIKGCOPF@Volume?5data?5size?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BM@CDNAEGGM@Volume?5data?5offset?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DG@NLAOEFNO@Hidden?5volume?5protection?5active?3@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BL@DBKGLLJI@Hidden?5volume?5end?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BM@CHOGCNPN@Hidden?5volume?5size?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BO@HCAAKCJO@Hidden?5volume?5offset?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BE@LHJMDIKA@Legacy?5volume?5?$DN?5?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BP@GNIOJEAD@Required?5program?5version?5?$DN?5?$CFx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BJ@JCBFCEPL@Volume?5header?5decrypted?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BO@DBKGEMGK@Read?5didn?8t?5read?5enough?5data?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BO@FHFPMFGI@Read?5failed?3?5NTSTATUS?50x?$CF08x?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BB@IPFFEHBJ@Cannot?5open?5?$CFls?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0FD@BKFNIFNN@Mounting?5partition?5within?5scope?5@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DM@FMJIKGBL@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAH?$AAa?$AAr?$AAd?$AAd?$AAi?$AAs?$AAk?$AA?$CF?$AAd?$AA?2?$AAP?$AAa?$AAr?$AAt?$AAi?$AAt?$AAi?$AAo?$AAn?$AA0?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CA@IGALEGOK@Reading?5volume?5header?5at?5?$CFI64d?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BP@BKDGGJEA@Trying?5to?5open?5volume?5type?5?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DF@LEPAODFF@File?5?$CC?$CFls?$CC?5is?5marked?5as?5compress@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0ED@EAABHCEJ@ZwQueryInformationFile?5failed?5wh@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	__$ArrayPad$
PUBLIC	_TCOpenVolume@20
EXTRN	_crypto_close@4:PROC
EXTRN	__imp__ExFreePoolWithTag@8:PROC
EXTRN	__imp__wcsncpy:PROC
EXTRN	__imp__wcsstr:PROC
EXTRN	_GetSystemDriveCryptoInfo@0:PROC
EXTRN	_EAGetKeySize@4:PROC
EXTRN	_HiddenSysLeakProtectionCount:DWORD
EXTRN	_ReadVolumeHeaderWCache@20:PROC
EXTRN	_ReadVolumeHeaderRecoveryMode:DWORD
EXTRN	__imp__ZwClose@4:PROC
EXTRN	__imp___snwprintf:PROC
EXTRN	__imp__ZwReadFile@36:PROC
EXTRN	__imp__ExAllocatePoolWithTag@12:PROC
EXTRN	__imp_@ObfDereferenceObject@4:PROC
EXTRN	_TCFsctlCall@24:PROC
EXTRN	__imp__IoGetRelatedDeviceObject@4:PROC
EXTRN	__imp__ObReferenceObjectByHandle@24:PROC
EXTRN	_IoFileObjectType:DWORD
EXTRN	_DbgPrint:PROC
EXTRN	__imp__ZwQueryInformationFile@20:PROC
EXTRN	__imp__ZwCreateFile@44:PROC
EXTRN	_IsHiddenSystemRunning@0:PROC
EXTRN	__imp__IoGetDeviceObjectPointer@16:PROC
EXTRN	__imp__SeImpersonateClientEx@8:PROC
EXTRN	__imp__KeInitializeEvent@12:PROC
EXTRN	__imp__RtlInitUnicodeString@8:PROC
EXTRN	_OsMinorVersion:DWORD
EXTRN	_OsMajorVersion:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__aullrem:PROC
EXTRN	__alldiv:PROC
EXTRN	_memset:PROC
EXTRN	__allmul:PROC
;	COMDAT ??_C@_1BA@GIIKONIJ@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@
; File c:\home\public\desktop\projects\ciphershed.build\src\driver\ntvol.c
text$s	SEGMENT
??_C@_1BA@GIIKONIJ@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, '?', 00H, '?', 00H, '\', 00H, '\', 00H, '%', 00H, 's', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BC@MAMPPFNN@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AAU?$AAN?$AAC?$AA?2?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BC@MAMPPFNN@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AAU?$AAN?$AAC?$AA?2?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, '?', 00H, '?', 00H, '\', 00H, 'U', 00H, 'N', 00H, 'C', 00H
	DB	'\', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BH@JONGPBLO@Incorrect?5volume?5size?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BH@JONGPBLO@Incorrect?5volume?5size?6?$AA@FNODOBFM@ DB 'Incorrect '
	DB	'volume size', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BJ@MEKDGODO@Volume?5data?5end?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BJ@MEKDGODO@Volume?5data?5end?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@ DB 'V'
	DB	'olume data end = %I64d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BK@BIKGCOPF@Volume?5data?5size?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BK@BIKGCOPF@Volume?5data?5size?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@ DB 'V'
	DB	'olume data size = %I64d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BM@CDNAEGGM@Volume?5data?5offset?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BM@CDNAEGGM@Volume?5data?5offset?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@ DB 'V'
	DB	'olume data offset = %I64d', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DG@NLAOEFNO@Hidden?5volume?5protection?5active?3@FNODOBFM@
text$s	SEGMENT
??_C@_0DG@NLAOEFNO@Hidden?5volume?5protection?5active?3@FNODOBFM@ DB 'Hid'
	DB	'den volume protection active: %I64d-%I64d (%I64d)', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BL@DBKGLLJI@Hidden?5volume?5end?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BL@DBKGLLJI@Hidden?5volume?5end?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@ DB 'H'
	DB	'idden volume end = %I64d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BM@CHOGCNPN@Hidden?5volume?5size?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BM@CHOGCNPN@Hidden?5volume?5size?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@ DB 'H'
	DB	'idden volume size = %I64d', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BO@HCAAKCJO@Hidden?5volume?5offset?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BO@HCAAKCJO@Hidden?5volume?5offset?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@ DB 'H'
	DB	'idden volume offset = %I64d', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BE@LHJMDIKA@Legacy?5volume?5?$DN?5?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BE@LHJMDIKA@Legacy?5volume?5?$DN?5?$CFd?6?$AA@FNODOBFM@ DB 'Legacy'
	DB	' volume = %d', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BP@GNIOJEAD@Required?5program?5version?5?$DN?5?$CFx?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BP@GNIOJEAD@Required?5program?5version?5?$DN?5?$CFx?6?$AA@FNODOBFM@ DB 'R'
	DB	'equired program version = %x', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BJ@JCBFCEPL@Volume?5header?5decrypted?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BJ@JCBFCEPL@Volume?5header?5decrypted?6?$AA@FNODOBFM@ DB 'Volume h'
	DB	'eader decrypted', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BO@DBKGEMGK@Read?5didn?8t?5read?5enough?5data?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BO@DBKGEMGK@Read?5didn?8t?5read?5enough?5data?6?$AA@FNODOBFM@ DB 'R'
	DB	'ead didn''t read enough data', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BO@FHFPMFGI@Read?5failed?3?5NTSTATUS?50x?$CF08x?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BO@FHFPMFGI@Read?5failed?3?5NTSTATUS?50x?$CF08x?6?$AA@FNODOBFM@ DB 'R'
	DB	'ead failed: NTSTATUS 0x%08x', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BB@IPFFEHBJ@Cannot?5open?5?$CFls?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BB@IPFFEHBJ@Cannot?5open?5?$CFls?6?$AA@FNODOBFM@ DB 'Cannot open %'
	DB	'ls', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0FD@BKFNIFNN@Mounting?5partition?5within?5scope?5@FNODOBFM@
text$s	SEGMENT
??_C@_0FD@BKFNIFNN@Mounting?5partition?5within?5scope?5@FNODOBFM@ DB 'Mou'
	DB	'nting partition within scope of system encryption (reading ke'
	DB	'y data from: %ls)', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DM@FMJIKGBL@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAH?$AAa?$AAr?$AAd?$AAd?$AAi?$AAs?$AAk?$AA?$CF?$AAd?$AA?2?$AAP?$AAa?$AAr?$AAt?$AAi?$AAt?$AAi?$AAo?$AAn?$AA0?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DM@FMJIKGBL@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAH?$AAa?$AAr?$AAd?$AAd?$AAi?$AAs?$AAk?$AA?$CF?$AAd?$AA?2?$AAP?$AAa?$AAr?$AAt?$AAi?$AAt?$AAi?$AAo?$AAn?$AA0?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'H', 00H, 'a', 00H, 'r', 00H, 'd', 00H, 'd', 00H, 'i'
	DB	00H, 's', 00H, 'k', 00H, '%', 00H, 'd', 00H, '\', 00H, 'P', 00H
	DB	'a', 00H, 'r', 00H, 't', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'o'
	DB	00H, 'n', 00H, '0', 00H, 00H, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CA@IGALEGOK@Reading?5volume?5header?5at?5?$CFI64d?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0CA@IGALEGOK@Reading?5volume?5header?5at?5?$CFI64d?6?$AA@FNODOBFM@ DB 'R'
	DB	'eading volume header at %I64d', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BP@BKDGGJEA@Trying?5to?5open?5volume?5type?5?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BP@BKDGGJEA@Trying?5to?5open?5volume?5type?5?$CFd?6?$AA@FNODOBFM@ DB 'T'
	DB	'rying to open volume type %d', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DF@LEPAODFF@File?5?$CC?$CFls?$CC?5is?5marked?5as?5compress@FNODOBFM@
text$s	SEGMENT
??_C@_0DF@LEPAODFF@File?5?$CC?$CFls?$CC?5is?5marked?5as?5compress@FNODOBFM@ DB 'F'
	DB	'ile "%ls" is marked as compressed - not supported!', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0ED@EAABHCEJ@ZwQueryInformationFile?5failed?5wh@FNODOBFM@
text$s	SEGMENT
??_C@_0ED@EAABHCEJ@ZwQueryInformationFile?5failed?5wh@FNODOBFM@ DB 'ZwQue'
	DB	'ryInformationFile failed while opening file: NTSTATUS 0x%08x', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _TCOpenVolume@20
_TEXT	SEGMENT
tv1452 = -632						; size = 4
tv1361 = -628						; size = 8
tv620 = -620						; size = 4
tv592 = -616						; size = 4
tv1228 = -612						; size = 4
tv1227 = -608						; size = 4
tv1214 = -604						; size = 4
tv1213 = -600						; size = 4
tv1203 = -596						; size = 8
tv1187 = -588						; size = 4
tv516 = -584						; size = 4
tv472 = -580						; size = 4
tv396 = -576						; size = 4
tv394 = -572						; size = 4
tv376 = -568						; size = 8
tv371 = -560						; size = 8
tv367 = -552						; size = 4
tv348 = -548						; size = 4
tv961 = -544						; size = 8
tv67 = -536						; size = 4
_FullParentPath$29337 = -532				; size = 8
_hParentDeviceFile$29335 = -524				; size = 4
_oaParentFileAttributes$29338 = -520			; size = 24
_parentKeyDataOffset$29339 = -496			; size = 8
_parentDrivePath$29334 = -488				; size = 96
__$ArrayPad$ = -388					; size = 4
_headerOffset$29316 = -384				; size = 8
_pfoTmpDeviceFile$29294 = -372				; size = 4
_dg$29241 = -368					; size = 24
_pi$29238 = -344					; size = 32
_diskLengthInfo$29240 = -312				; size = 8
_pix$29239 = -304					; size = 144
_tmpCryptoInfo$ = -156					; size = 4
_partitionStartingOffset$ = -152			; size = 8
_ntStatus$ = -144					; size = 4
_volumeType$ = -140					; size = 4
_FileStandardInfo$ = -136				; size = 24
_lDiskLength$ = -112					; size = 8
_forceAccessCheck$ = -100				; size = 4
_readBuffer$ = -96					; size = 4
_disableBuffering$ = -92				; size = 4
_FileBasicInfo$ = -88					; size = 40
_oaFileAttributes$ = -48				; size = 24
_IoStatusBlock$ = -24					; size = 8
_cryptoInfoPtr$ = -16					; size = 4
_FullFileName$ = -12					; size = 8
_exclusiveAccess$ = -4					; size = 4
_DeviceObject$ = 8					; size = 4
_Extension$ = 12					; size = 4
_mount$ = 16						; size = 4
_pwszMountVolume$ = 20					; size = 4
_bRawDevice$ = 24					; size = 4
_TCOpenVolume@20 PROC					; COMDAT

; 41   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 78 02 00
	00		 sub	 esp, 632		; 00000278H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 85 7c fe ff
	ff		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi

; 42   : 	FILE_STANDARD_INFORMATION FileStandardInfo;
; 43   : 	FILE_BASIC_INFORMATION FileBasicInfo;
; 44   : 	OBJECT_ATTRIBUTES oaFileAttributes;
; 45   : 	UNICODE_STRING FullFileName;
; 46   : 	IO_STATUS_BLOCK IoStatusBlock;
; 47   : 	PCRYPTO_INFO cryptoInfoPtr = NULL;

  0001b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _cryptoInfoPtr$[ebp], 0

; 48   : 	PCRYPTO_INFO tmpCryptoInfo = NULL;

  00022	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _tmpCryptoInfo$[ebp], 0

; 49   : 	LARGE_INTEGER lDiskLength;
; 50   : 	__int64 partitionStartingOffset = 0;

  0002c	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _partitionStartingOffset$[ebp], 0
  00036	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _partitionStartingOffset$[ebp+4], 0

; 51   : 	int volumeType;
; 52   : 	char *readBuffer = 0;

  00040	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _readBuffer$[ebp], 0

; 53   : 	NTSTATUS ntStatus = 0;

  00047	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ntStatus$[ebp], 0

; 54   : 	BOOL forceAccessCheck = (!bRawDevice && !(OsMajorVersion == 5 &&OsMinorVersion == 0)); // Windows 2000 does not support OBJ_FORCE_ACCESS_CHECK attribute

  00051	83 7d 18 00	 cmp	 DWORD PTR _bRawDevice$[ebp], 0
  00055	75 1e		 jne	 SHORT $LN111@TCOpenVolu
  00057	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR _OsMajorVersion, 5
  0005e	75 09		 jne	 SHORT $LN110@TCOpenVolu
  00060	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _OsMinorVersion, 0
  00067	74 0c		 je	 SHORT $LN111@TCOpenVolu
$LN110@TCOpenVolu:
  00069	c7 85 e8 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv67[ebp], 1
  00073	eb 0a		 jmp	 SHORT $LN112@TCOpenVolu
$LN111@TCOpenVolu:
  00075	c7 85 e8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
$LN112@TCOpenVolu:
  0007f	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR tv67[ebp]
  00085	89 45 9c	 mov	 DWORD PTR _forceAccessCheck$[ebp], eax

; 55   : 	BOOL disableBuffering = TRUE;

  00088	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _disableBuffering$[ebp], 1

; 56   : 	BOOL exclusiveAccess = mount->bExclusiveAccess;

  0008f	8b 4d 10	 mov	 ecx, DWORD PTR _mount$[ebp]
  00092	8b 91 74 02 00
	00		 mov	 edx, DWORD PTR [ecx+628]
  00098	89 55 fc	 mov	 DWORD PTR _exclusiveAccess$[ebp], edx

; 57   : 
; 58   : 	Extension->pfoDeviceFile = NULL;

  0009b	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  0009e	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0

; 59   : 	Extension->hDeviceFile = NULL;

  000a5	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  000a8	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], 0

; 60   : 	Extension->bTimeStampValid = FALSE;

  000af	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  000b2	c7 82 c8 04 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+1224], 0

; 61   : 
; 62   : 	RtlInitUnicodeString (&FullFileName, pwszMountVolume);

  000bc	8b 45 14	 mov	 eax, DWORD PTR _pwszMountVolume$[ebp]
  000bf	50		 push	 eax
  000c0	8d 4d f4	 lea	 ecx, DWORD PTR _FullFileName$[ebp]
  000c3	51		 push	 ecx
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 63   : 	InitializeObjectAttributes (&oaFileAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | (forceAccessCheck ? OBJ_FORCE_ACCESS_CHECK : 0) | OBJ_KERNEL_HANDLE, NULL, NULL);

  000ca	c7 45 d0 18 00
	00 00		 mov	 DWORD PTR _oaFileAttributes$[ebp], 24 ; 00000018H
  000d1	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _oaFileAttributes$[ebp+4], 0
  000d8	8b 55 9c	 mov	 edx, DWORD PTR _forceAccessCheck$[ebp]
  000db	f7 da		 neg	 edx
  000dd	1b d2		 sbb	 edx, edx
  000df	81 e2 00 04 00
	00		 and	 edx, 1024		; 00000400H
  000e5	83 ca 40	 or	 edx, 64			; 00000040H
  000e8	81 ca 00 02 00
	00		 or	 edx, 512		; 00000200H
  000ee	89 55 dc	 mov	 DWORD PTR _oaFileAttributes$[ebp+12], edx
  000f1	8d 45 f4	 lea	 eax, DWORD PTR _FullFileName$[ebp]
  000f4	89 45 d8	 mov	 DWORD PTR _oaFileAttributes$[ebp+8], eax
  000f7	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _oaFileAttributes$[ebp+16], 0
  000fe	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _oaFileAttributes$[ebp+20], 0

; 64   : 	KeInitializeEvent (&Extension->keVolumeEvent, NotificationEvent, FALSE);

  00105	6a 00		 push	 0
  00107	6a 00		 push	 0
  00109	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0010c	81 c1 94 00 00
	00		 add	 ecx, 148		; 00000094H
  00112	51		 push	 ecx
  00113	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 65   : 
; 66   : 	if (Extension->SecurityClientContextValid)

  00119	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  0011c	83 ba d0 04 00
	00 00		 cmp	 DWORD PTR [edx+1232], 0
  00123	74 25		 je	 SHORT $LN107@TCOpenVolu

; 67   : 	{
; 68   : 		ntStatus = SeImpersonateClientEx (&Extension->SecurityClientContext, NULL);

  00125	6a 00		 push	 0
  00127	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  0012a	05 d4 04 00 00	 add	 eax, 1236		; 000004d4H
  0012f	50		 push	 eax
  00130	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeImpersonateClientEx@8
  00136	89 85 70 ff ff
	ff		 mov	 DWORD PTR _ntStatus$[ebp], eax

; 69   : 		if (!NT_SUCCESS (ntStatus))

  0013c	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR _ntStatus$[ebp], 0
  00143	7d 05		 jge	 SHORT $LN107@TCOpenVolu

; 70   : 			goto error;

  00145	e9 62 14 00 00	 jmp	 $error$29236
$LN107@TCOpenVolu:

; 71   : 	}
; 72   : 
; 73   : 	mount->VolumeMountedReadOnlyAfterDeviceWriteProtected = FALSE;

  0014a	8b 4d 10	 mov	 ecx, DWORD PTR _mount$[ebp]
  0014d	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 74   : 
; 75   : 	// If we are opening a device, query its size first
; 76   : 	if (bRawDevice)

  00154	83 7d 18 00	 cmp	 DWORD PTR _bRawDevice$[ebp], 0
  00158	0f 84 f9 01 00
	00		 je	 $LN105@TCOpenVolu

; 77   : 	{
; 78   : 		PARTITION_INFORMATION pi;
; 79   : 		PARTITION_INFORMATION_EX pix;
; 80   : 		LARGE_INTEGER diskLengthInfo;
; 81   : 		DISK_GEOMETRY dg;
; 82   : 
; 83   : 		ntStatus = IoGetDeviceObjectPointer (&FullFileName,
; 84   : 			FILE_READ_DATA | FILE_READ_ATTRIBUTES,
; 85   : 			&Extension->pfoDeviceFile,
; 86   : 			&Extension->pFsdDevice);

  0015e	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  00161	83 c2 5c	 add	 edx, 92			; 0000005cH
  00164	52		 push	 edx
  00165	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  00168	83 c0 58	 add	 eax, 88			; 00000058H
  0016b	50		 push	 eax
  0016c	68 81 00 00 00	 push	 129			; 00000081H
  00171	8d 4d f4	 lea	 ecx, DWORD PTR _FullFileName$[ebp]
  00174	51		 push	 ecx
  00175	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoGetDeviceObjectPointer@16
  0017b	89 85 70 ff ff
	ff		 mov	 DWORD PTR _ntStatus$[ebp], eax

; 87   : 
; 88   : 		if (!NT_SUCCESS (ntStatus))

  00181	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR _ntStatus$[ebp], 0
  00188	7d 05		 jge	 SHORT $LN104@TCOpenVolu

; 89   : 			goto error;

  0018a	e9 1d 14 00 00	 jmp	 $error$29236
$LN104@TCOpenVolu:

; 90   : 
; 91   : 		ntStatus = TCSendHostDeviceIoControlRequest (DeviceObject, Extension, IOCTL_DISK_GET_DRIVE_GEOMETRY, (char *) &dg, sizeof (dg));

  0018f	6a 18		 push	 24			; 00000018H
  00191	8d 95 90 fe ff
	ff		 lea	 edx, DWORD PTR _dg$29241[ebp]
  00197	52		 push	 edx
  00198	68 00 00 07 00	 push	 458752			; 00070000H
  0019d	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  001a0	50		 push	 eax
  001a1	8b 4d 08	 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  001a4	51		 push	 ecx
  001a5	e8 00 00 00 00	 call	 _TCSendHostDeviceIoControlRequest@20
  001aa	89 85 70 ff ff
	ff		 mov	 DWORD PTR _ntStatus$[ebp], eax

; 92   : 		if (!NT_SUCCESS (ntStatus))

  001b0	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR _ntStatus$[ebp], 0
  001b7	7d 05		 jge	 SHORT $LN103@TCOpenVolu

; 93   : 			goto error;

  001b9	e9 ee 13 00 00	 jmp	 $error$29236
$LN103@TCOpenVolu:

; 94   : 
; 95   : 		lDiskLength.QuadPart = dg.Cylinders.QuadPart * dg.SectorsPerTrack * dg.TracksPerCylinder * dg.BytesPerSector;

  001be	8b 95 a0 fe ff
	ff		 mov	 edx, DWORD PTR _dg$29241[ebp+16]
  001c4	33 c0		 xor	 eax, eax
  001c6	50		 push	 eax
  001c7	52		 push	 edx
  001c8	8b 8d 94 fe ff
	ff		 mov	 ecx, DWORD PTR _dg$29241[ebp+4]
  001ce	51		 push	 ecx
  001cf	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR _dg$29241[ebp]
  001d5	52		 push	 edx
  001d6	e8 00 00 00 00	 call	 __allmul
  001db	8b 8d 9c fe ff
	ff		 mov	 ecx, DWORD PTR _dg$29241[ebp+12]
  001e1	33 f6		 xor	 esi, esi
  001e3	56		 push	 esi
  001e4	51		 push	 ecx
  001e5	52		 push	 edx
  001e6	50		 push	 eax
  001e7	e8 00 00 00 00	 call	 __allmul
  001ec	8b 8d a4 fe ff
	ff		 mov	 ecx, DWORD PTR _dg$29241[ebp+20]
  001f2	33 f6		 xor	 esi, esi
  001f4	56		 push	 esi
  001f5	51		 push	 ecx
  001f6	52		 push	 edx
  001f7	50		 push	 eax
  001f8	e8 00 00 00 00	 call	 __allmul
  001fd	89 45 90	 mov	 DWORD PTR _lDiskLength$[ebp], eax
  00200	89 55 94	 mov	 DWORD PTR _lDiskLength$[ebp+4], edx

; 96   : 		Extension->HostBytesPerSector = dg.BytesPerSector;

  00203	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  00206	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR _dg$29241[ebp+20]
  0020c	89 82 90 00 00
	00		 mov	 DWORD PTR [edx+144], eax

; 97   : 
; 98   : 		// Drive geometry is used only when IOCTL_DISK_GET_PARTITION_INFO fails
; 99   : 		if (NT_SUCCESS (TCSendHostDeviceIoControlRequest (DeviceObject, Extension, IOCTL_DISK_GET_PARTITION_INFO_EX, (char *) &pix, sizeof (pix))))

  00212	68 90 00 00 00	 push	 144			; 00000090H
  00217	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR _pix$29239[ebp]
  0021d	51		 push	 ecx
  0021e	68 48 00 07 00	 push	 458824			; 00070048H
  00223	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  00226	52		 push	 edx
  00227	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  0022a	50		 push	 eax
  0022b	e8 00 00 00 00	 call	 _TCSendHostDeviceIoControlRequest@20
  00230	85 c0		 test	 eax, eax
  00232	7c 2c		 jl	 SHORT $LN102@TCOpenVolu

; 100  : 		{
; 101  : 			lDiskLength.QuadPart = pix.PartitionLength.QuadPart;

  00234	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _pix$29239[ebp+16]
  0023a	89 4d 90	 mov	 DWORD PTR _lDiskLength$[ebp], ecx
  0023d	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _pix$29239[ebp+20]
  00243	89 55 94	 mov	 DWORD PTR _lDiskLength$[ebp+4], edx

; 102  : 			partitionStartingOffset = pix.StartingOffset.QuadPart;

  00246	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _pix$29239[ebp+8]
  0024c	89 85 68 ff ff
	ff		 mov	 DWORD PTR _partitionStartingOffset$[ebp], eax
  00252	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _pix$29239[ebp+12]
  00258	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _partitionStartingOffset$[ebp+4], ecx
  0025e	eb 7c		 jmp	 SHORT $LN101@TCOpenVolu
$LN102@TCOpenVolu:

; 103  : 		}
; 104  : 		// Windows 2000 does not support IOCTL_DISK_GET_PARTITION_INFO_EX
; 105  : 		else if (NT_SUCCESS (TCSendHostDeviceIoControlRequest (DeviceObject, Extension, IOCTL_DISK_GET_PARTITION_INFO, (char *) &pi, sizeof (pi))))

  00260	6a 20		 push	 32			; 00000020H
  00262	8d 95 a8 fe ff
	ff		 lea	 edx, DWORD PTR _pi$29238[ebp]
  00268	52		 push	 edx
  00269	68 04 40 07 00	 push	 475140			; 00074004H
  0026e	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  00271	50		 push	 eax
  00272	8b 4d 08	 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  00275	51		 push	 ecx
  00276	e8 00 00 00 00	 call	 _TCSendHostDeviceIoControlRequest@20
  0027b	85 c0		 test	 eax, eax
  0027d	7c 2c		 jl	 SHORT $LN100@TCOpenVolu

; 106  : 		{
; 107  : 			lDiskLength.QuadPart = pi.PartitionLength.QuadPart;

  0027f	8b 95 b0 fe ff
	ff		 mov	 edx, DWORD PTR _pi$29238[ebp+8]
  00285	89 55 90	 mov	 DWORD PTR _lDiskLength$[ebp], edx
  00288	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _pi$29238[ebp+12]
  0028e	89 45 94	 mov	 DWORD PTR _lDiskLength$[ebp+4], eax

; 108  : 			partitionStartingOffset = pi.StartingOffset.QuadPart;

  00291	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR _pi$29238[ebp]
  00297	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _partitionStartingOffset$[ebp], ecx
  0029d	8b 95 ac fe ff
	ff		 mov	 edx, DWORD PTR _pi$29238[ebp+4]
  002a3	89 95 6c ff ff
	ff		 mov	 DWORD PTR _partitionStartingOffset$[ebp+4], edx
  002a9	eb 31		 jmp	 SHORT $LN101@TCOpenVolu
$LN100@TCOpenVolu:

; 109  : 		}
; 110  : 		else if (NT_SUCCESS (TCSendHostDeviceIoControlRequest (DeviceObject, Extension, IOCTL_DISK_GET_LENGTH_INFO, &diskLengthInfo, sizeof (diskLengthInfo))))

  002ab	6a 08		 push	 8
  002ad	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR _diskLengthInfo$29240[ebp]
  002b3	50		 push	 eax
  002b4	68 5c 40 07 00	 push	 475228			; 0007405cH
  002b9	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  002bc	51		 push	 ecx
  002bd	8b 55 08	 mov	 edx, DWORD PTR _DeviceObject$[ebp]
  002c0	52		 push	 edx
  002c1	e8 00 00 00 00	 call	 _TCSendHostDeviceIoControlRequest@20
  002c6	85 c0		 test	 eax, eax
  002c8	7c 12		 jl	 SHORT $LN101@TCOpenVolu

; 111  : 		{
; 112  : 			lDiskLength = diskLengthInfo;

  002ca	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _diskLengthInfo$29240[ebp]
  002d0	89 45 90	 mov	 DWORD PTR _lDiskLength$[ebp], eax
  002d3	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR _diskLengthInfo$29240[ebp+4]
  002d9	89 4d 94	 mov	 DWORD PTR _lDiskLength$[ebp+4], ecx
$LN101@TCOpenVolu:

; 113  : 		}
; 114  : 
; 115  : 		ProbingHostDeviceForWrite = TRUE;

  002dc	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _ProbingHostDeviceForWrite, 1

; 116  : 
; 117  : 		if (!mount->bMountReadOnly
; 118  : 			&& TCSendHostDeviceIoControlRequest (DeviceObject, Extension,
; 119  : 				IsHiddenSystemRunning() ? TC_IOCTL_DISK_IS_WRITABLE : IOCTL_DISK_IS_WRITABLE, NULL, 0) == STATUS_MEDIA_WRITE_PROTECTED)

  002e6	8b 55 10	 mov	 edx, DWORD PTR _mount$[ebp]
  002e9	83 ba 6c 02 00
	00 00		 cmp	 DWORD PTR [edx+620], 0
  002f0	75 52		 jne	 SHORT $LN97@TCOpenVolu
  002f2	6a 00		 push	 0
  002f4	6a 00		 push	 0
  002f6	e8 00 00 00 00	 call	 _IsHiddenSystemRunning@0
  002fb	f7 d8		 neg	 eax
  002fd	1b c0		 sbb	 eax, eax
  002ff	25 50 20 1b 00	 and	 eax, 1777744		; 001b2050H
  00304	05 24 00 07 00	 add	 eax, 458788		; 00070024H
  00309	50		 push	 eax
  0030a	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  0030d	50		 push	 eax
  0030e	8b 4d 08	 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  00311	51		 push	 ecx
  00312	e8 00 00 00 00	 call	 _TCSendHostDeviceIoControlRequest@20
  00317	3d a2 00 00 c0	 cmp	 eax, -1073741662	; c00000a2H
  0031c	75 26		 jne	 SHORT $LN97@TCOpenVolu

; 120  : 		{
; 121  : 			mount->bMountReadOnly = TRUE;

  0031e	8b 55 10	 mov	 edx, DWORD PTR _mount$[ebp]
  00321	c7 82 6c 02 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+620], 1

; 122  : 			DeviceObject->Characteristics |= FILE_READ_ONLY_DEVICE;

  0032b	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  0032e	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00331	83 c9 02	 or	 ecx, 2
  00334	8b 55 08	 mov	 edx, DWORD PTR _DeviceObject$[ebp]
  00337	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 123  : 			mount->VolumeMountedReadOnlyAfterDeviceWriteProtected = TRUE;

  0033a	8b 45 10	 mov	 eax, DWORD PTR _mount$[ebp]
  0033d	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [eax+12], 1
$LN97@TCOpenVolu:

; 124  : 		}
; 125  : 
; 126  : 		ProbingHostDeviceForWrite = FALSE;

  00344	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ProbingHostDeviceForWrite, 0

; 127  : 
; 128  : 		// Some Windows tools (e.g. diskmgmt, diskpart, vssadmin) fail or experience timeouts when there is a raw device
; 129  : 		// open for exclusive access. Therefore, exclusive access is used only for file-hosted volumes.
; 130  : 		// Applications requiring a consistent device image need to acquire exclusive write access first. This is prevented
; 131  : 		// when a device-hosted volume is mounted.
; 132  : 
; 133  : 		exclusiveAccess = FALSE;

  0034e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _exclusiveAccess$[ebp], 0

; 134  : 	}
; 135  : 	else

  00355	eb 65		 jmp	 SHORT $LN96@TCOpenVolu
$LN105@TCOpenVolu:

; 136  : 	{
; 137  : 		// Limit the maximum required buffer size
; 138  : 		if (mount->BytesPerSector > 128 * BYTES_PER_KB)

  00357	8b 4d 10	 mov	 ecx, DWORD PTR _mount$[ebp]
  0035a	8b 91 68 02 00
	00		 mov	 edx, DWORD PTR [ecx+616]
  00360	33 c0		 xor	 eax, eax
  00362	89 95 e0 fd ff
	ff		 mov	 DWORD PTR tv961[ebp], edx
  00368	89 85 e4 fd ff
	ff		 mov	 DWORD PTR tv961[ebp+4], eax
  0036e	83 bd e4 fd ff
	ff 00		 cmp	 DWORD PTR tv961[ebp+4], 0
  00375	7c 1d		 jl	 SHORT $LN95@TCOpenVolu
  00377	7f 0c		 jg	 SHORT $LN129@TCOpenVolu
  00379	81 bd e0 fd ff
	ff 00 00 02 00	 cmp	 DWORD PTR tv961[ebp], 131072 ; 00020000H
  00383	76 0f		 jbe	 SHORT $LN95@TCOpenVolu
$LN129@TCOpenVolu:

; 139  : 		{
; 140  : 			ntStatus = STATUS_INVALID_PARAMETER;

  00385	c7 85 70 ff ff
	ff 0d 00 00 c0	 mov	 DWORD PTR _ntStatus$[ebp], -1073741811 ; c000000dH

; 141  : 			goto error;

  0038f	e9 18 12 00 00	 jmp	 $error$29236
$LN95@TCOpenVolu:

; 142  : 		}
; 143  : 
; 144  : 		Extension->HostBytesPerSector = mount->BytesPerSector;

  00394	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00397	8b 55 10	 mov	 edx, DWORD PTR _mount$[ebp]
  0039a	8b 82 68 02 00
	00		 mov	 eax, DWORD PTR [edx+616]
  003a0	89 81 90 00 00
	00		 mov	 DWORD PTR [ecx+144], eax

; 145  : 
; 146  : 		if (Extension->HostBytesPerSector != TC_SECTOR_SIZE_FILE_HOSTED_VOLUME)

  003a6	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  003a9	81 b9 90 00 00
	00 00 02 00 00	 cmp	 DWORD PTR [ecx+144], 512 ; 00000200H
  003b3	74 07		 je	 SHORT $LN96@TCOpenVolu

; 147  : 			disableBuffering = FALSE;

  003b5	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _disableBuffering$[ebp], 0
$LN96@TCOpenVolu:

; 148  : 	}
; 149  : 
; 150  : 	// Open the volume hosting file/device
; 151  : 	if (!mount->bMountReadOnly)

  003bc	8b 55 10	 mov	 edx, DWORD PTR _mount$[ebp]
  003bf	83 ba 6c 02 00
	00 00		 cmp	 DWORD PTR [edx+620], 0
  003c6	75 4e		 jne	 SHORT $LN93@TCOpenVolu

; 152  : 	{
; 153  : 		ntStatus = ZwCreateFile (&Extension->hDeviceFile,
; 154  : 			GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
; 155  : 			&oaFileAttributes,
; 156  : 			&IoStatusBlock,
; 157  : 			NULL,
; 158  : 			FILE_ATTRIBUTE_NORMAL |
; 159  : 			FILE_ATTRIBUTE_SYSTEM,
; 160  : 			exclusiveAccess ? 0 : FILE_SHARE_READ | FILE_SHARE_WRITE,
; 161  : 			FILE_OPEN,
; 162  : 			FILE_RANDOM_ACCESS |
; 163  : 			FILE_WRITE_THROUGH |
; 164  : 			(disableBuffering ? FILE_NO_INTERMEDIATE_BUFFERING : 0) |
; 165  : 			FILE_SYNCHRONOUS_IO_NONALERT,
; 166  : 			NULL,
; 167  : 			0);

  003c8	6a 00		 push	 0
  003ca	6a 00		 push	 0
  003cc	8b 45 a4	 mov	 eax, DWORD PTR _disableBuffering$[ebp]
  003cf	f7 d8		 neg	 eax
  003d1	1b c0		 sbb	 eax, eax
  003d3	83 e0 08	 and	 eax, 8
  003d6	0d 02 08 00 00	 or	 eax, 2050		; 00000802H
  003db	83 c8 20	 or	 eax, 32			; 00000020H
  003de	50		 push	 eax
  003df	6a 01		 push	 1
  003e1	8b 4d fc	 mov	 ecx, DWORD PTR _exclusiveAccess$[ebp]
  003e4	f7 d9		 neg	 ecx
  003e6	1b c9		 sbb	 ecx, ecx
  003e8	83 e1 fd	 and	 ecx, -3			; fffffffdH
  003eb	83 c1 03	 add	 ecx, 3
  003ee	51		 push	 ecx
  003ef	68 84 00 00 00	 push	 132			; 00000084H
  003f4	6a 00		 push	 0
  003f6	8d 55 e8	 lea	 edx, DWORD PTR _IoStatusBlock$[ebp]
  003f9	52		 push	 edx
  003fa	8d 45 d0	 lea	 eax, DWORD PTR _oaFileAttributes$[ebp]
  003fd	50		 push	 eax
  003fe	68 00 00 10 c0	 push	 -1072693248		; c0100000H
  00403	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00406	83 c1 54	 add	 ecx, 84			; 00000054H
  00409	51		 push	 ecx
  0040a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwCreateFile@44
  00410	89 85 70 ff ff
	ff		 mov	 DWORD PTR _ntStatus$[ebp], eax
$LN93@TCOpenVolu:

; 168  : 	}
; 169  : 
; 170  : 	/* 26-4-99 NT for some partitions returns this code, it is really a	access denied */
; 171  : 	if (ntStatus == 0xc000001b)

  00416	81 bd 70 ff ff
	ff 1b 00 00 c0	 cmp	 DWORD PTR _ntStatus$[ebp], -1073741797 ; c000001bH
  00420	75 0a		 jne	 SHORT $LN92@TCOpenVolu

; 172  : 		ntStatus = STATUS_ACCESS_DENIED;

  00422	c7 85 70 ff ff
	ff 22 00 00 c0	 mov	 DWORD PTR _ntStatus$[ebp], -1073741790 ; c0000022H
$LN92@TCOpenVolu:

; 173  : 
; 174  : 	mount->VolumeMountedReadOnlyAfterAccessDenied = FALSE;

  0042c	8b 55 10	 mov	 edx, DWORD PTR _mount$[ebp]
  0042f	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 175  : 
; 176  : 	if (mount->bMountReadOnly || ntStatus == STATUS_ACCESS_DENIED)

  00436	8b 45 10	 mov	 eax, DWORD PTR _mount$[ebp]
  00439	83 b8 6c 02 00
	00 00		 cmp	 DWORD PTR [eax+620], 0
  00440	75 10		 jne	 SHORT $LN90@TCOpenVolu
  00442	81 bd 70 ff ff
	ff 22 00 00 c0	 cmp	 DWORD PTR _ntStatus$[ebp], -1073741790 ; c0000022H
  0044c	0f 85 8c 00 00
	00		 jne	 $LN91@TCOpenVolu
$LN90@TCOpenVolu:

; 177  : 	{
; 178  : 		ntStatus = ZwCreateFile (&Extension->hDeviceFile,
; 179  : 			GENERIC_READ | SYNCHRONIZE,
; 180  : 			&oaFileAttributes,
; 181  : 			&IoStatusBlock,
; 182  : 			NULL,
; 183  : 			FILE_ATTRIBUTE_NORMAL |
; 184  : 			FILE_ATTRIBUTE_SYSTEM,
; 185  : 			exclusiveAccess ? FILE_SHARE_READ : FILE_SHARE_READ | FILE_SHARE_WRITE,
; 186  : 			FILE_OPEN,
; 187  : 			FILE_RANDOM_ACCESS |
; 188  : 			FILE_WRITE_THROUGH |
; 189  : 			(disableBuffering ? FILE_NO_INTERMEDIATE_BUFFERING : 0) |
; 190  : 			FILE_SYNCHRONOUS_IO_NONALERT,
; 191  : 			NULL,
; 192  : 			0);

  00452	6a 00		 push	 0
  00454	6a 00		 push	 0
  00456	8b 4d a4	 mov	 ecx, DWORD PTR _disableBuffering$[ebp]
  00459	f7 d9		 neg	 ecx
  0045b	1b c9		 sbb	 ecx, ecx
  0045d	83 e1 08	 and	 ecx, 8
  00460	81 c9 02 08 00
	00		 or	 ecx, 2050		; 00000802H
  00466	83 c9 20	 or	 ecx, 32			; 00000020H
  00469	51		 push	 ecx
  0046a	6a 01		 push	 1
  0046c	33 d2		 xor	 edx, edx
  0046e	83 7d fc 00	 cmp	 DWORD PTR _exclusiveAccess$[ebp], 0
  00472	0f 94 c2	 sete	 dl
  00475	8d 54 12 01	 lea	 edx, DWORD PTR [edx+edx+1]
  00479	52		 push	 edx
  0047a	68 84 00 00 00	 push	 132			; 00000084H
  0047f	6a 00		 push	 0
  00481	8d 45 e8	 lea	 eax, DWORD PTR _IoStatusBlock$[ebp]
  00484	50		 push	 eax
  00485	8d 4d d0	 lea	 ecx, DWORD PTR _oaFileAttributes$[ebp]
  00488	51		 push	 ecx
  00489	68 00 00 10 80	 push	 -2146435072		; 80100000H
  0048e	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  00491	83 c2 54	 add	 edx, 84			; 00000054H
  00494	52		 push	 edx
  00495	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwCreateFile@44
  0049b	89 85 70 ff ff
	ff		 mov	 DWORD PTR _ntStatus$[ebp], eax

; 193  : 
; 194  : 		if (NT_SUCCESS (ntStatus) && !mount->bMountReadOnly)

  004a1	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR _ntStatus$[ebp], 0
  004a8	7c 16		 jl	 SHORT $LN89@TCOpenVolu
  004aa	8b 45 10	 mov	 eax, DWORD PTR _mount$[ebp]
  004ad	83 b8 6c 02 00
	00 00		 cmp	 DWORD PTR [eax+620], 0
  004b4	75 0a		 jne	 SHORT $LN89@TCOpenVolu

; 195  : 			mount->VolumeMountedReadOnlyAfterAccessDenied = TRUE;

  004b6	8b 4d 10	 mov	 ecx, DWORD PTR _mount$[ebp]
  004b9	c7 41 08 01 00
	00 00		 mov	 DWORD PTR [ecx+8], 1
$LN89@TCOpenVolu:

; 196  : 
; 197  : 		Extension->bReadOnly = TRUE;

  004c0	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  004c3	c7 82 88 02 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+648], 1

; 198  : 		DeviceObject->Characteristics |= FILE_READ_ONLY_DEVICE;

  004cd	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  004d0	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  004d3	83 c9 02	 or	 ecx, 2
  004d6	8b 55 08	 mov	 edx, DWORD PTR _DeviceObject$[ebp]
  004d9	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 199  : 	}
; 200  : 	else

  004dc	eb 0d		 jmp	 SHORT $LN88@TCOpenVolu
$LN91@TCOpenVolu:

; 201  : 		Extension->bReadOnly = FALSE;

  004de	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  004e1	c7 80 88 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+648], 0
$LN88@TCOpenVolu:

; 202  : 
; 203  : 	/* 26-4-99 NT for some partitions returns this code, it is really a
; 204  : 	access denied */
; 205  : 	if (ntStatus == 0xc000001b)

  004eb	81 bd 70 ff ff
	ff 1b 00 00 c0	 cmp	 DWORD PTR _ntStatus$[ebp], -1073741797 ; c000001bH
  004f5	75 0a		 jne	 SHORT $LN87@TCOpenVolu

; 206  : 	{
; 207  : 		/* Partitions which return this code can still be opened with
; 208  : 		FILE_SHARE_READ but this causes NT problems elsewhere in
; 209  : 		particular if you do FILE_SHARE_READ NT will die later if
; 210  : 		anyone even tries to open the partition (or file for that
; 211  : 		matter...)  */
; 212  : 		ntStatus = STATUS_SHARING_VIOLATION;

  004f7	c7 85 70 ff ff
	ff 43 00 00 c0	 mov	 DWORD PTR _ntStatus$[ebp], -1073741757 ; c0000043H
$LN87@TCOpenVolu:

; 213  : 	}
; 214  : 
; 215  : 	if (!NT_SUCCESS (ntStatus))

  00501	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR _ntStatus$[ebp], 0
  00508	7d 05		 jge	 SHORT $LN86@TCOpenVolu

; 216  : 	{
; 217  : 		goto error;

  0050a	e9 9d 10 00 00	 jmp	 $error$29236
$LN86@TCOpenVolu:

; 218  : 	}
; 219  : 
; 220  : 	// If we have opened a file, query its size now
; 221  : 	if (bRawDevice == FALSE)

  0050f	83 7d 18 00	 cmp	 DWORD PTR _bRawDevice$[ebp], 0
  00513	0f 85 6b 01 00
	00		 jne	 $LN85@TCOpenVolu

; 222  : 	{
; 223  : 		ntStatus = ZwQueryInformationFile (Extension->hDeviceFile,
; 224  : 			&IoStatusBlock,
; 225  : 			&FileBasicInfo,
; 226  : 			sizeof (FileBasicInfo),
; 227  : 			FileBasicInformation);

  00519	6a 04		 push	 4
  0051b	6a 28		 push	 40			; 00000028H
  0051d	8d 4d a8	 lea	 ecx, DWORD PTR _FileBasicInfo$[ebp]
  00520	51		 push	 ecx
  00521	8d 55 e8	 lea	 edx, DWORD PTR _IoStatusBlock$[ebp]
  00524	52		 push	 edx
  00525	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  00528	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  0052b	51		 push	 ecx
  0052c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwQueryInformationFile@20
  00532	89 85 70 ff ff
	ff		 mov	 DWORD PTR _ntStatus$[ebp], eax

; 228  : 
; 229  : 		if (NT_SUCCESS (ntStatus))

  00538	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR _ntStatus$[ebp], 0
  0053f	0f 8c 8f 00 00
	00		 jl	 $LN84@TCOpenVolu

; 230  : 		{
; 231  : 			if (mount->bPreserveTimestamp)

  00545	8b 55 10	 mov	 edx, DWORD PTR _mount$[ebp]
  00548	83 ba 7c 02 00
	00 00		 cmp	 DWORD PTR [edx+636], 0
  0054f	74 61		 je	 SHORT $LN83@TCOpenVolu

; 232  : 			{
; 233  : 				Extension->fileCreationTime = FileBasicInfo.CreationTime;

  00551	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  00554	8b 4d a8	 mov	 ecx, DWORD PTR _FileBasicInfo$[ebp]
  00557	89 88 a8 04 00
	00		 mov	 DWORD PTR [eax+1192], ecx
  0055d	8b 55 ac	 mov	 edx, DWORD PTR _FileBasicInfo$[ebp+4]
  00560	89 90 ac 04 00
	00		 mov	 DWORD PTR [eax+1196], edx

; 234  : 				Extension->fileLastAccessTime = FileBasicInfo.LastAccessTime;

  00566	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  00569	8b 4d b0	 mov	 ecx, DWORD PTR _FileBasicInfo$[ebp+8]
  0056c	89 88 b0 04 00
	00		 mov	 DWORD PTR [eax+1200], ecx
  00572	8b 55 b4	 mov	 edx, DWORD PTR _FileBasicInfo$[ebp+12]
  00575	89 90 b4 04 00
	00		 mov	 DWORD PTR [eax+1204], edx

; 235  : 				Extension->fileLastWriteTime = FileBasicInfo.LastWriteTime;

  0057b	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  0057e	8b 4d b8	 mov	 ecx, DWORD PTR _FileBasicInfo$[ebp+16]
  00581	89 88 b8 04 00
	00		 mov	 DWORD PTR [eax+1208], ecx
  00587	8b 55 bc	 mov	 edx, DWORD PTR _FileBasicInfo$[ebp+20]
  0058a	89 90 bc 04 00
	00		 mov	 DWORD PTR [eax+1212], edx

; 236  : 				Extension->fileLastChangeTime = FileBasicInfo.ChangeTime;

  00590	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  00593	8b 4d c0	 mov	 ecx, DWORD PTR _FileBasicInfo$[ebp+24]
  00596	89 88 c0 04 00
	00		 mov	 DWORD PTR [eax+1216], ecx
  0059c	8b 55 c4	 mov	 edx, DWORD PTR _FileBasicInfo$[ebp+28]
  0059f	89 90 c4 04 00
	00		 mov	 DWORD PTR [eax+1220], edx

; 237  : 				Extension->bTimeStampValid = TRUE;

  005a5	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  005a8	c7 80 c8 04 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+1224], 1
$LN83@TCOpenVolu:

; 238  : 			}
; 239  : 
; 240  : 			ntStatus = ZwQueryInformationFile (Extension->hDeviceFile,
; 241  : 				&IoStatusBlock,
; 242  : 				&FileStandardInfo,
; 243  : 				sizeof (FileStandardInfo),
; 244  : 				FileStandardInformation);

  005b2	6a 05		 push	 5
  005b4	6a 18		 push	 24			; 00000018H
  005b6	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _FileStandardInfo$[ebp]
  005bc	51		 push	 ecx
  005bd	8d 55 e8	 lea	 edx, DWORD PTR _IoStatusBlock$[ebp]
  005c0	52		 push	 edx
  005c1	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  005c4	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  005c7	51		 push	 ecx
  005c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwQueryInformationFile@20
  005ce	89 85 70 ff ff
	ff		 mov	 DWORD PTR _ntStatus$[ebp], eax
$LN84@TCOpenVolu:

; 245  : 		}
; 246  : 
; 247  : 		if (!NT_SUCCESS (ntStatus))

  005d4	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR _ntStatus$[ebp], 0
  005db	7d 19		 jge	 SHORT $LN82@TCOpenVolu

; 248  : 		{
; 249  : 			Dump ("ZwQueryInformationFile failed while opening file: NTSTATUS 0x%08x\n",
; 250  : 				ntStatus);

  005dd	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _ntStatus$[ebp]
  005e3	52		 push	 edx
  005e4	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@EAABHCEJ@ZwQueryInformationFile?5failed?5wh@FNODOBFM@
  005e9	e8 00 00 00 00	 call	 _DbgPrint
  005ee	83 c4 08	 add	 esp, 8

; 251  : 			goto error;

  005f1	e9 b6 0f 00 00	 jmp	 $error$29236
$LN82@TCOpenVolu:

; 252  : 		}
; 253  : 
; 254  : 		lDiskLength.QuadPart = FileStandardInfo.EndOfFile.QuadPart;

  005f6	8b 45 80	 mov	 eax, DWORD PTR _FileStandardInfo$[ebp+8]
  005f9	89 45 90	 mov	 DWORD PTR _lDiskLength$[ebp], eax
  005fc	8b 4d 84	 mov	 ecx, DWORD PTR _FileStandardInfo$[ebp+12]
  005ff	89 4d 94	 mov	 DWORD PTR _lDiskLength$[ebp+4], ecx

; 255  : 
; 256  : 		if (FileBasicInfo.FileAttributes & FILE_ATTRIBUTE_COMPRESSED)

  00602	8b 55 c8	 mov	 edx, DWORD PTR _FileBasicInfo$[ebp+32]
  00605	81 e2 00 08 00
	00		 and	 edx, 2048		; 00000800H
  0060b	74 29		 je	 SHORT $LN81@TCOpenVolu

; 257  : 		{
; 258  : 			Dump ("File \"%ls\" is marked as compressed - not supported!\n", pwszMountVolume);

  0060d	8b 45 14	 mov	 eax, DWORD PTR _pwszMountVolume$[ebp]
  00610	50		 push	 eax
  00611	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LEPAODFF@File?5?$CC?$CFls?$CC?5is?5marked?5as?5compress@FNODOBFM@
  00616	e8 00 00 00 00	 call	 _DbgPrint
  0061b	83 c4 08	 add	 esp, 8

; 259  : 			mount->nReturnCode = ERR_COMPRESSION_NOT_SUPPORTED;

  0061e	8b 4d 10	 mov	 ecx, DWORD PTR _mount$[ebp]
  00621	c7 01 08 00 00
	00		 mov	 DWORD PTR [ecx], 8

; 260  : 			ntStatus = STATUS_SUCCESS;

  00627	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ntStatus$[ebp], 0

; 261  : 			goto error;

  00631	e9 76 0f 00 00	 jmp	 $error$29236
$LN81@TCOpenVolu:

; 262  : 		}
; 263  : 
; 264  : 		ntStatus = ObReferenceObjectByHandle (Extension->hDeviceFile,
; 265  : 			FILE_ALL_ACCESS,
; 266  : 			*IoFileObjectType,
; 267  : 			KernelMode,
; 268  : 			&Extension->pfoDeviceFile,
; 269  : 			0);

  00636	6a 00		 push	 0
  00638	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  0063b	83 c2 58	 add	 edx, 88			; 00000058H
  0063e	52		 push	 edx
  0063f	6a 00		 push	 0
  00641	a1 00 00 00 00	 mov	 eax, DWORD PTR _IoFileObjectType
  00646	8b 08		 mov	 ecx, DWORD PTR [eax]
  00648	51		 push	 ecx
  00649	68 ff 01 1f 00	 push	 2032127			; 001f01ffH
  0064e	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  00651	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  00654	50		 push	 eax
  00655	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ObReferenceObjectByHandle@24
  0065b	89 85 70 ff ff
	ff		 mov	 DWORD PTR _ntStatus$[ebp], eax

; 270  : 
; 271  : 		if (!NT_SUCCESS (ntStatus))

  00661	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR _ntStatus$[ebp], 0
  00668	7d 05		 jge	 SHORT $LN80@TCOpenVolu

; 272  : 		{
; 273  : 			goto error;

  0066a	e9 3d 0f 00 00	 jmp	 $error$29236
$LN80@TCOpenVolu:

; 274  : 		}
; 275  : 
; 276  : 		/* Get the FSD device for the file (probably either NTFS or	FAT) */
; 277  : 		Extension->pFsdDevice = IoGetRelatedDeviceObject (Extension->pfoDeviceFile);

  0066f	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00672	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  00675	52		 push	 edx
  00676	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoGetRelatedDeviceObject@4
  0067c	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0067f	89 41 5c	 mov	 DWORD PTR [ecx+92], eax

; 278  : 	}
; 279  : 	else

  00682	eb 61		 jmp	 SHORT $LN79@TCOpenVolu
$LN85@TCOpenVolu:

; 280  : 	{
; 281  : 		// Try to gain "raw" access to the partition in case there is a live filesystem on it (otherwise, 
; 282  : 		// the NTFS driver guards hidden sectors and prevents mounting using a backup header e.g. after the user 
; 283  : 		// accidentally quick-formats a dismounted partition-hosted CipherShed volume as NTFS).
; 284  : 
; 285  : 		PFILE_OBJECT pfoTmpDeviceFile = NULL;

  00684	c7 85 8c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _pfoTmpDeviceFile$29294[ebp], 0

; 286  : 
; 287  : 		if (NT_SUCCESS (ObReferenceObjectByHandle (Extension->hDeviceFile, FILE_ALL_ACCESS, *IoFileObjectType, KernelMode, &pfoTmpDeviceFile, NULL))
; 288  : 			&& pfoTmpDeviceFile != NULL)

  0068e	6a 00		 push	 0
  00690	8d 95 8c fe ff
	ff		 lea	 edx, DWORD PTR _pfoTmpDeviceFile$29294[ebp]
  00696	52		 push	 edx
  00697	6a 00		 push	 0
  00699	a1 00 00 00 00	 mov	 eax, DWORD PTR _IoFileObjectType
  0069e	8b 08		 mov	 ecx, DWORD PTR [eax]
  006a0	51		 push	 ecx
  006a1	68 ff 01 1f 00	 push	 2032127			; 001f01ffH
  006a6	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  006a9	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  006ac	50		 push	 eax
  006ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ObReferenceObjectByHandle@24
  006b3	85 c0		 test	 eax, eax
  006b5	7c 2e		 jl	 SHORT $LN79@TCOpenVolu
  006b7	83 bd 8c fe ff
	ff 00		 cmp	 DWORD PTR _pfoTmpDeviceFile$29294[ebp], 0
  006be	74 25		 je	 SHORT $LN79@TCOpenVolu

; 289  : 		{
; 290  : 			TCFsctlCall (pfoTmpDeviceFile, FSCTL_ALLOW_EXTENDED_DASD_IO, NULL, 0, NULL, 0);

  006c0	6a 00		 push	 0
  006c2	6a 00		 push	 0
  006c4	6a 00		 push	 0
  006c6	6a 00		 push	 0
  006c8	68 83 00 09 00	 push	 589955			; 00090083H
  006cd	8b 8d 8c fe ff
	ff		 mov	 ecx, DWORD PTR _pfoTmpDeviceFile$29294[ebp]
  006d3	51		 push	 ecx
  006d4	e8 00 00 00 00	 call	 _TCFsctlCall@24

; 291  : 			ObDereferenceObject (pfoTmpDeviceFile);

  006d9	8b 8d 8c fe ff
	ff		 mov	 ecx, DWORD PTR _pfoTmpDeviceFile$29294[ebp]
  006df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4
$LN79@TCOpenVolu:

; 292  : 		}
; 293  : 	}
; 294  : 
; 295  : 	// Check volume size
; 296  : 	if (lDiskLength.QuadPart < TC_MIN_VOLUME_SIZE_LEGACY || lDiskLength.QuadPart > TC_MAX_VOLUME_SIZE)

  006e5	83 7d 94 00	 cmp	 DWORD PTR _lDiskLength$[ebp+4], 0
  006e9	7c 1c		 jl	 SHORT $LN76@TCOpenVolu
  006eb	7f 09		 jg	 SHORT $LN130@TCOpenVolu
  006ed	81 7d 90 00 4a
	00 00		 cmp	 DWORD PTR _lDiskLength$[ebp], 18944 ; 00004a00H
  006f4	72 11		 jb	 SHORT $LN76@TCOpenVolu
$LN130@TCOpenVolu:
  006f6	81 7d 94 00 00
	04 00		 cmp	 DWORD PTR _lDiskLength$[ebp+4], 262144 ; 00040000H
  006fd	7c 20		 jl	 SHORT $LN77@TCOpenVolu
  006ff	7f 06		 jg	 SHORT $LN76@TCOpenVolu
  00701	83 7d 90 00	 cmp	 DWORD PTR _lDiskLength$[ebp], 0
  00705	76 18		 jbe	 SHORT $LN77@TCOpenVolu
$LN76@TCOpenVolu:

; 297  : 	{
; 298  : 		mount->nReturnCode = ERR_VOL_SIZE_WRONG;

  00707	8b 55 10	 mov	 edx, DWORD PTR _mount$[ebp]
  0070a	c7 02 07 00 00
	00		 mov	 DWORD PTR [edx], 7

; 299  : 		ntStatus = STATUS_SUCCESS;

  00710	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ntStatus$[ebp], 0

; 300  : 		goto error;

  0071a	e9 8d 0e 00 00	 jmp	 $error$29236
$LN77@TCOpenVolu:

; 301  : 	}
; 302  : 
; 303  : 	Extension->DiskLength = lDiskLength.QuadPart;

  0071f	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  00722	8b 4d 90	 mov	 ecx, DWORD PTR _lDiskLength$[ebp]
  00725	89 48 70	 mov	 DWORD PTR [eax+112], ecx
  00728	8b 55 94	 mov	 edx, DWORD PTR _lDiskLength$[ebp+4]
  0072b	89 50 74	 mov	 DWORD PTR [eax+116], edx

; 304  : 	Extension->HostLength = lDiskLength.QuadPart;

  0072e	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  00731	8b 4d 90	 mov	 ecx, DWORD PTR _lDiskLength$[ebp]
  00734	89 48 68	 mov	 DWORD PTR [eax+104], ecx
  00737	8b 55 94	 mov	 edx, DWORD PTR _lDiskLength$[ebp+4]
  0073a	89 50 6c	 mov	 DWORD PTR [eax+108], edx

; 305  : 
; 306  : 	readBuffer = TCalloc (max (max (TC_VOLUME_HEADER_EFFECTIVE_SIZE, PAGE_SIZE), Extension->HostBytesPerSector));

  0073d	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  00740	81 b8 90 00 00
	00 00 10 00 00	 cmp	 DWORD PTR [eax+144], 4096 ; 00001000H
  0074a	73 0c		 jae	 SHORT $LN113@TCOpenVolu
  0074c	c7 85 dc fd ff
	ff 00 10 00 00	 mov	 DWORD PTR tv348[ebp], 4096 ; 00001000H
  00756	eb 0f		 jmp	 SHORT $LN114@TCOpenVolu
$LN113@TCOpenVolu:
  00758	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0075b	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  00761	89 95 dc fd ff
	ff		 mov	 DWORD PTR tv348[ebp], edx
$LN114@TCOpenVolu:
  00767	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0076c	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR tv348[ebp]
  00772	50		 push	 eax
  00773	6a 00		 push	 0
  00775	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0077b	89 45 a0	 mov	 DWORD PTR _readBuffer$[ebp], eax

; 307  : 	if (readBuffer == NULL)

  0077e	83 7d a0 00	 cmp	 DWORD PTR _readBuffer$[ebp], 0
  00782	75 0f		 jne	 SHORT $LN75@TCOpenVolu

; 308  : 	{
; 309  : 		ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00784	c7 85 70 ff ff
	ff 9a 00 00 c0	 mov	 DWORD PTR _ntStatus$[ebp], -1073741670 ; c000009aH

; 310  : 		goto error;

  0078e	e9 19 0e 00 00	 jmp	 $error$29236
$LN75@TCOpenVolu:

; 311  : 	}
; 312  : 
; 313  : 	// Go through all volume types (e.g., normal, hidden)
; 314  : 	for (volumeType = TC_VOLUME_TYPE_NORMAL;
; 315  : 		volumeType < TC_VOLUME_TYPE_COUNT;
; 316  : 		volumeType++)	

  00793	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _volumeType$[ebp], 0
  0079d	eb 0f		 jmp	 SHORT $LN74@TCOpenVolu
$LN73@TCOpenVolu:
  0079f	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _volumeType$[ebp]
  007a5	83 c1 01	 add	 ecx, 1
  007a8	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _volumeType$[ebp], ecx
$LN74@TCOpenVolu:
  007ae	83 bd 74 ff ff
	ff 03		 cmp	 DWORD PTR _volumeType$[ebp], 3
  007b5	0f 8d d3 0d 00
	00		 jge	 $LN72@TCOpenVolu

; 317  : 	{
; 318  : 		Dump ("Trying to open volume type %d\n", volumeType);

  007bb	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _volumeType$[ebp]
  007c1	52		 push	 edx
  007c2	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@BKDGGJEA@Trying?5to?5open?5volume?5type?5?$CFd?6?$AA@FNODOBFM@
  007c7	e8 00 00 00 00	 call	 _DbgPrint
  007cc	83 c4 08	 add	 esp, 8

; 319  : 
; 320  : 		if (mount->bPartitionInInactiveSysEncScope
; 321  : 			&& volumeType == TC_VOLUME_TYPE_HIDDEN_LEGACY)

  007cf	8b 45 10	 mov	 eax, DWORD PTR _mount$[ebp]
  007d2	83 b8 80 02 00
	00 00		 cmp	 DWORD PTR [eax+640], 0
  007d9	74 0b		 je	 SHORT $LN71@TCOpenVolu
  007db	83 bd 74 ff ff
	ff 02		 cmp	 DWORD PTR _volumeType$[ebp], 2
  007e2	75 02		 jne	 SHORT $LN71@TCOpenVolu

; 322  : 			continue;		

  007e4	eb b9		 jmp	 SHORT $LN73@TCOpenVolu
$LN71@TCOpenVolu:

; 323  : 
; 324  : 		/* Read the volume header */
; 325  : 
; 326  : 		if (!mount->bPartitionInInactiveSysEncScope
; 327  : 			|| (mount->bPartitionInInactiveSysEncScope && volumeType == TC_VOLUME_TYPE_HIDDEN))

  007e6	8b 4d 10	 mov	 ecx, DWORD PTR _mount$[ebp]
  007e9	83 b9 80 02 00
	00 00		 cmp	 DWORD PTR [ecx+640], 0
  007f0	74 1d		 je	 SHORT $LN69@TCOpenVolu
  007f2	8b 55 10	 mov	 edx, DWORD PTR _mount$[ebp]
  007f5	83 ba 80 02 00
	00 00		 cmp	 DWORD PTR [edx+640], 0
  007fc	0f 84 04 02 00
	00		 je	 $LN70@TCOpenVolu
  00802	83 bd 74 ff ff
	ff 01		 cmp	 DWORD PTR _volumeType$[ebp], 1
  00809	0f 85 f7 01 00
	00		 jne	 $LN70@TCOpenVolu
$LN69@TCOpenVolu:

; 328  : 		{
; 329  : 			// Header of a volume that is not within the scope of system encryption, or
; 330  : 			// header of a system hidden volume (containing a hidden OS)
; 331  : 
; 332  : 			LARGE_INTEGER headerOffset;
; 333  : 
; 334  : 			if (mount->UseBackupHeader && lDiskLength.QuadPart <= TC_TOTAL_VOLUME_HEADERS_SIZE)

  0080f	8b 45 10	 mov	 eax, DWORD PTR _mount$[ebp]
  00812	83 b8 d8 02 00
	00 00		 cmp	 DWORD PTR [eax+728], 0
  00819	74 16		 je	 SHORT $LN68@TCOpenVolu
  0081b	83 7d 94 00	 cmp	 DWORD PTR _lDiskLength$[ebp+4], 0
  0081f	7f 10		 jg	 SHORT $LN68@TCOpenVolu
  00821	7c 09		 jl	 SHORT $LN132@TCOpenVolu
  00823	81 7d 90 00 00
	04 00		 cmp	 DWORD PTR _lDiskLength$[ebp], 262144 ; 00040000H
  0082a	77 05		 ja	 SHORT $LN68@TCOpenVolu
$LN132@TCOpenVolu:

; 335  : 				continue;

  0082c	e9 6e ff ff ff	 jmp	 $LN73@TCOpenVolu
$LN68@TCOpenVolu:

; 336  : 
; 337  : 			switch (volumeType)

  00831	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _volumeType$[ebp]
  00837	89 8d d8 fd ff
	ff		 mov	 DWORD PTR tv367[ebp], ecx
  0083d	83 bd d8 fd ff
	ff 00		 cmp	 DWORD PTR tv367[ebp], 0
  00844	74 1b		 je	 SHORT $LN65@TCOpenVolu
  00846	83 bd d8 fd ff
	ff 01		 cmp	 DWORD PTR tv367[ebp], 1
  0084d	74 6b		 je	 SHORT $LN64@TCOpenVolu
  0084f	83 bd d8 fd ff
	ff 02		 cmp	 DWORD PTR tv367[ebp], 2
  00856	0f 84 cb 00 00
	00		 je	 $LN62@TCOpenVolu
  0085c	e9 0c 01 00 00	 jmp	 $LN66@TCOpenVolu
$LN65@TCOpenVolu:

; 338  : 			{
; 339  : 			case TC_VOLUME_TYPE_NORMAL:
; 340  : 				headerOffset.QuadPart = mount->UseBackupHeader ? lDiskLength.QuadPart - TC_VOLUME_HEADER_GROUP_SIZE : TC_VOLUME_HEADER_OFFSET;

  00861	8b 55 10	 mov	 edx, DWORD PTR _mount$[ebp]
  00864	83 ba d8 02 00
	00 00		 cmp	 DWORD PTR [edx+728], 0
  0086b	74 1c		 je	 SHORT $LN115@TCOpenVolu
  0086d	8b 45 90	 mov	 eax, DWORD PTR _lDiskLength$[ebp]
  00870	2d 00 00 02 00	 sub	 eax, 131072		; 00020000H
  00875	8b 4d 94	 mov	 ecx, DWORD PTR _lDiskLength$[ebp+4]
  00878	83 d9 00	 sbb	 ecx, 0
  0087b	89 85 d0 fd ff
	ff		 mov	 DWORD PTR tv371[ebp], eax
  00881	89 8d d4 fd ff
	ff		 mov	 DWORD PTR tv371[ebp+4], ecx
  00887	eb 14		 jmp	 SHORT $LN116@TCOpenVolu
$LN115@TCOpenVolu:
  00889	c7 85 d0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv371[ebp], 0
  00893	c7 85 d4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv371[ebp+4], 0
$LN116@TCOpenVolu:
  0089d	8b 95 d0 fd ff
	ff		 mov	 edx, DWORD PTR tv371[ebp]
  008a3	89 95 80 fe ff
	ff		 mov	 DWORD PTR _headerOffset$29316[ebp], edx
  008a9	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR tv371[ebp+4]
  008af	89 85 84 fe ff
	ff		 mov	 DWORD PTR _headerOffset$29316[ebp+4], eax

; 341  : 				break;

  008b5	e9 b3 00 00 00	 jmp	 $LN66@TCOpenVolu
$LN64@TCOpenVolu:

; 342  : 
; 343  : 			case TC_VOLUME_TYPE_HIDDEN:
; 344  : 				if (lDiskLength.QuadPart <= TC_VOLUME_HEADER_GROUP_SIZE)

  008ba	83 7d 94 00	 cmp	 DWORD PTR _lDiskLength$[ebp+4], 0
  008be	7f 10		 jg	 SHORT $LN63@TCOpenVolu
  008c0	7c 09		 jl	 SHORT $LN133@TCOpenVolu
  008c2	81 7d 90 00 00
	02 00		 cmp	 DWORD PTR _lDiskLength$[ebp], 131072 ; 00020000H
  008c9	77 05		 ja	 SHORT $LN63@TCOpenVolu
$LN133@TCOpenVolu:

; 345  : 					continue;

  008cb	e9 cf fe ff ff	 jmp	 $LN73@TCOpenVolu
$LN63@TCOpenVolu:

; 346  : 
; 347  : 				headerOffset.QuadPart = mount->UseBackupHeader ? lDiskLength.QuadPart - TC_HIDDEN_VOLUME_HEADER_OFFSET : TC_HIDDEN_VOLUME_HEADER_OFFSET;

  008d0	8b 4d 10	 mov	 ecx, DWORD PTR _mount$[ebp]
  008d3	83 b9 d8 02 00
	00 00		 cmp	 DWORD PTR [ecx+728], 0
  008da	74 1d		 je	 SHORT $LN117@TCOpenVolu
  008dc	8b 55 90	 mov	 edx, DWORD PTR _lDiskLength$[ebp]
  008df	81 ea 00 00 01
	00		 sub	 edx, 65536		; 00010000H
  008e5	8b 45 94	 mov	 eax, DWORD PTR _lDiskLength$[ebp+4]
  008e8	83 d8 00	 sbb	 eax, 0
  008eb	89 95 c8 fd ff
	ff		 mov	 DWORD PTR tv376[ebp], edx
  008f1	89 85 cc fd ff
	ff		 mov	 DWORD PTR tv376[ebp+4], eax
  008f7	eb 14		 jmp	 SHORT $LN118@TCOpenVolu
$LN117@TCOpenVolu:
  008f9	c7 85 c8 fd ff
	ff 00 00 01 00	 mov	 DWORD PTR tv376[ebp], 65536 ; 00010000H
  00903	c7 85 cc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv376[ebp+4], 0
$LN118@TCOpenVolu:
  0090d	8b 8d c8 fd ff
	ff		 mov	 ecx, DWORD PTR tv376[ebp]
  00913	89 8d 80 fe ff
	ff		 mov	 DWORD PTR _headerOffset$29316[ebp], ecx
  00919	8b 95 cc fd ff
	ff		 mov	 edx, DWORD PTR tv376[ebp+4]
  0091f	89 95 84 fe ff
	ff		 mov	 DWORD PTR _headerOffset$29316[ebp+4], edx

; 348  : 				break;

  00925	eb 46		 jmp	 SHORT $LN66@TCOpenVolu
$LN62@TCOpenVolu:

; 349  : 
; 350  : 			case TC_VOLUME_TYPE_HIDDEN_LEGACY:
; 351  : 				if (mount->UseBackupHeader)

  00927	8b 45 10	 mov	 eax, DWORD PTR _mount$[ebp]
  0092a	83 b8 d8 02 00
	00 00		 cmp	 DWORD PTR [eax+728], 0
  00931	74 05		 je	 SHORT $LN61@TCOpenVolu

; 352  : 					continue;

  00933	e9 67 fe ff ff	 jmp	 $LN73@TCOpenVolu
$LN61@TCOpenVolu:

; 353  : 
; 354  : 				if (bRawDevice && Extension->HostBytesPerSector != TC_SECTOR_SIZE_LEGACY)

  00938	83 7d 18 00	 cmp	 DWORD PTR _bRawDevice$[ebp], 0
  0093c	74 14		 je	 SHORT $LN60@TCOpenVolu
  0093e	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00941	81 b9 90 00 00
	00 00 02 00 00	 cmp	 DWORD PTR [ecx+144], 512 ; 00000200H
  0094b	74 05		 je	 SHORT $LN60@TCOpenVolu

; 355  : 					continue;

  0094d	e9 4d fe ff ff	 jmp	 $LN73@TCOpenVolu
$LN60@TCOpenVolu:

; 356  : 
; 357  : 				headerOffset.QuadPart = lDiskLength.QuadPart - TC_HIDDEN_VOLUME_HEADER_OFFSET_LEGACY;

  00952	8b 55 90	 mov	 edx, DWORD PTR _lDiskLength$[ebp]
  00955	81 ea 00 06 00
	00		 sub	 edx, 1536		; 00000600H
  0095b	8b 45 94	 mov	 eax, DWORD PTR _lDiskLength$[ebp+4]
  0095e	83 d8 00	 sbb	 eax, 0
  00961	89 95 80 fe ff
	ff		 mov	 DWORD PTR _headerOffset$29316[ebp], edx
  00967	89 85 84 fe ff
	ff		 mov	 DWORD PTR _headerOffset$29316[ebp+4], eax
$LN66@TCOpenVolu:

; 358  : 				break;
; 359  : 			}
; 360  : 
; 361  : 			Dump ("Reading volume header at %I64d\n", headerOffset.QuadPart);

  0096d	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR _headerOffset$29316[ebp+4]
  00973	51		 push	 ecx
  00974	8b 95 80 fe ff
	ff		 mov	 edx, DWORD PTR _headerOffset$29316[ebp]
  0097a	52		 push	 edx
  0097b	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@IGALEGOK@Reading?5volume?5header?5at?5?$CFI64d?6?$AA@FNODOBFM@
  00980	e8 00 00 00 00	 call	 _DbgPrint
  00985	83 c4 0c	 add	 esp, 12			; 0000000cH

; 362  : 
; 363  : 			ntStatus = ZwReadFile (Extension->hDeviceFile,
; 364  : 			NULL,
; 365  : 			NULL,
; 366  : 			NULL,
; 367  : 			&IoStatusBlock,
; 368  : 			readBuffer,
; 369  : 			bRawDevice ? max (TC_VOLUME_HEADER_EFFECTIVE_SIZE, Extension->HostBytesPerSector) : TC_VOLUME_HEADER_EFFECTIVE_SIZE,
; 370  : 			&headerOffset,
; 371  : 			NULL);

  00988	83 7d 18 00	 cmp	 DWORD PTR _bRawDevice$[ebp], 0
  0098c	74 38		 je	 SHORT $LN121@TCOpenVolu
  0098e	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  00991	81 b8 90 00 00
	00 00 02 00 00	 cmp	 DWORD PTR [eax+144], 512 ; 00000200H
  0099b	73 0c		 jae	 SHORT $LN119@TCOpenVolu
  0099d	c7 85 c4 fd ff
	ff 00 02 00 00	 mov	 DWORD PTR tv394[ebp], 512 ; 00000200H
  009a7	eb 0f		 jmp	 SHORT $LN120@TCOpenVolu
$LN119@TCOpenVolu:
  009a9	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  009ac	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  009b2	89 95 c4 fd ff
	ff		 mov	 DWORD PTR tv394[ebp], edx
$LN120@TCOpenVolu:
  009b8	8b 85 c4 fd ff
	ff		 mov	 eax, DWORD PTR tv394[ebp]
  009be	89 85 c0 fd ff
	ff		 mov	 DWORD PTR tv396[ebp], eax
  009c4	eb 0a		 jmp	 SHORT $LN122@TCOpenVolu
$LN121@TCOpenVolu:
  009c6	c7 85 c0 fd ff
	ff 00 02 00 00	 mov	 DWORD PTR tv396[ebp], 512 ; 00000200H
$LN122@TCOpenVolu:
  009d0	6a 00		 push	 0
  009d2	8d 8d 80 fe ff
	ff		 lea	 ecx, DWORD PTR _headerOffset$29316[ebp]
  009d8	51		 push	 ecx
  009d9	8b 95 c0 fd ff
	ff		 mov	 edx, DWORD PTR tv396[ebp]
  009df	52		 push	 edx
  009e0	8b 45 a0	 mov	 eax, DWORD PTR _readBuffer$[ebp]
  009e3	50		 push	 eax
  009e4	8d 4d e8	 lea	 ecx, DWORD PTR _IoStatusBlock$[ebp]
  009e7	51		 push	 ecx
  009e8	6a 00		 push	 0
  009ea	6a 00		 push	 0
  009ec	6a 00		 push	 0
  009ee	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  009f1	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  009f4	50		 push	 eax
  009f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwReadFile@36
  009fb	89 85 70 ff ff
	ff		 mov	 DWORD PTR _ntStatus$[ebp], eax

; 372  : 		}
; 373  : 		else

  00a01	e9 a1 01 00 00	 jmp	 $LN59@TCOpenVolu
$LN70@TCOpenVolu:

; 374  : 		{
; 375  : 			// Header of a partition that is within the scope of system encryption
; 376  : 
; 377  : 			WCHAR parentDrivePath [47+1] = {0};

  00a06	33 c9		 xor	 ecx, ecx
  00a08	66 89 8d 18 fe
	ff ff		 mov	 WORD PTR _parentDrivePath$29334[ebp], cx
  00a0f	6a 5e		 push	 94			; 0000005eH
  00a11	6a 00		 push	 0
  00a13	8d 95 1a fe ff
	ff		 lea	 edx, DWORD PTR _parentDrivePath$29334[ebp+2]
  00a19	52		 push	 edx
  00a1a	e8 00 00 00 00	 call	 _memset
  00a1f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 378  : 			HANDLE hParentDeviceFile = NULL;

  00a22	c7 85 f4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _hParentDeviceFile$29335[ebp], 0

; 379  : 			UNICODE_STRING FullParentPath;
; 380  : 			OBJECT_ATTRIBUTES oaParentFileAttributes;
; 381  : 			LARGE_INTEGER parentKeyDataOffset;
; 382  : 
; 383  : 			_snwprintf (parentDrivePath,
; 384  : 				sizeof (parentDrivePath) / sizeof (WCHAR) - 1,
; 385  : 				WIDE ("\\Device\\Harddisk%d\\Partition0"),
; 386  : 				mount->nPartitionInInactiveSysEncScopeDriveNo);

  00a2c	8b 45 10	 mov	 eax, DWORD PTR _mount$[ebp]
  00a2f	8b 88 84 02 00
	00		 mov	 ecx, DWORD PTR [eax+644]
  00a35	51		 push	 ecx
  00a36	68 00 00 00 00	 push	 OFFSET ??_C@_1DM@FMJIKGBL@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAH?$AAa?$AAr?$AAd?$AAd?$AAi?$AAs?$AAk?$AA?$CF?$AAd?$AA?2?$AAP?$AAa?$AAr?$AAt?$AAi?$AAt?$AAi?$AAo?$AAn?$AA0?$AA?$AA@FNODOBFM@
  00a3b	6a 2f		 push	 47			; 0000002fH
  00a3d	8d 95 18 fe ff
	ff		 lea	 edx, DWORD PTR _parentDrivePath$29334[ebp]
  00a43	52		 push	 edx
  00a44	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___snwprintf
  00a4a	83 c4 10	 add	 esp, 16			; 00000010H

; 387  : 
; 388  : 			Dump ("Mounting partition within scope of system encryption (reading key data from: %ls)\n", parentDrivePath);

  00a4d	8d 85 18 fe ff
	ff		 lea	 eax, DWORD PTR _parentDrivePath$29334[ebp]
  00a53	50		 push	 eax
  00a54	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@BKFNIFNN@Mounting?5partition?5within?5scope?5@FNODOBFM@
  00a59	e8 00 00 00 00	 call	 _DbgPrint
  00a5e	83 c4 08	 add	 esp, 8

; 389  : 
; 390  : 			RtlInitUnicodeString (&FullParentPath, parentDrivePath);

  00a61	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR _parentDrivePath$29334[ebp]
  00a67	51		 push	 ecx
  00a68	8d 95 ec fd ff
	ff		 lea	 edx, DWORD PTR _FullParentPath$29337[ebp]
  00a6e	52		 push	 edx
  00a6f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 391  : 			InitializeObjectAttributes (&oaParentFileAttributes, &FullParentPath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,	NULL, NULL);

  00a75	c7 85 f8 fd ff
	ff 18 00 00 00	 mov	 DWORD PTR _oaParentFileAttributes$29338[ebp], 24 ; 00000018H
  00a7f	c7 85 fc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _oaParentFileAttributes$29338[ebp+4], 0
  00a89	c7 85 04 fe ff
	ff 40 02 00 00	 mov	 DWORD PTR _oaParentFileAttributes$29338[ebp+12], 576 ; 00000240H
  00a93	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _FullParentPath$29337[ebp]
  00a99	89 85 00 fe ff
	ff		 mov	 DWORD PTR _oaParentFileAttributes$29338[ebp+8], eax
  00a9f	c7 85 08 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _oaParentFileAttributes$29338[ebp+16], 0
  00aa9	c7 85 0c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _oaParentFileAttributes$29338[ebp+20], 0

; 392  : 
; 393  : 			ntStatus = ZwCreateFile (&hParentDeviceFile,
; 394  : 				GENERIC_READ | SYNCHRONIZE,
; 395  : 				&oaParentFileAttributes,
; 396  : 				&IoStatusBlock,
; 397  : 				NULL,
; 398  : 				FILE_ATTRIBUTE_NORMAL |
; 399  : 				FILE_ATTRIBUTE_SYSTEM,
; 400  : 				FILE_SHARE_READ | FILE_SHARE_WRITE,
; 401  : 				FILE_OPEN,
; 402  : 				FILE_RANDOM_ACCESS |
; 403  : 				FILE_WRITE_THROUGH |
; 404  : 				FILE_NO_INTERMEDIATE_BUFFERING |
; 405  : 				FILE_SYNCHRONOUS_IO_NONALERT,
; 406  : 				NULL,
; 407  : 				0);

  00ab3	6a 00		 push	 0
  00ab5	6a 00		 push	 0
  00ab7	68 2a 08 00 00	 push	 2090			; 0000082aH
  00abc	6a 01		 push	 1
  00abe	6a 03		 push	 3
  00ac0	68 84 00 00 00	 push	 132			; 00000084H
  00ac5	6a 00		 push	 0
  00ac7	8d 4d e8	 lea	 ecx, DWORD PTR _IoStatusBlock$[ebp]
  00aca	51		 push	 ecx
  00acb	8d 95 f8 fd ff
	ff		 lea	 edx, DWORD PTR _oaParentFileAttributes$29338[ebp]
  00ad1	52		 push	 edx
  00ad2	68 00 00 10 80	 push	 -2146435072		; 80100000H
  00ad7	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _hParentDeviceFile$29335[ebp]
  00add	50		 push	 eax
  00ade	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwCreateFile@44
  00ae4	89 85 70 ff ff
	ff		 mov	 DWORD PTR _ntStatus$[ebp], eax

; 408  : 
; 409  : 			if (!NT_SUCCESS (ntStatus))

  00aea	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR _ntStatus$[ebp], 0
  00af1	7d 2f		 jge	 SHORT $LN58@TCOpenVolu

; 410  : 			{
; 411  : 				if (hParentDeviceFile != NULL)

  00af3	83 bd f4 fd ff
	ff 00		 cmp	 DWORD PTR _hParentDeviceFile$29335[ebp], 0
  00afa	74 0d		 je	 SHORT $LN57@TCOpenVolu

; 412  : 					ZwClose (hParentDeviceFile);

  00afc	8b 8d f4 fd ff
	ff		 mov	 ecx, DWORD PTR _hParentDeviceFile$29335[ebp]
  00b02	51		 push	 ecx
  00b03	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4
$LN57@TCOpenVolu:

; 413  : 
; 414  : 				Dump ("Cannot open %ls\n", parentDrivePath);

  00b09	8d 95 18 fe ff
	ff		 lea	 edx, DWORD PTR _parentDrivePath$29334[ebp]
  00b0f	52		 push	 edx
  00b10	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IPFFEHBJ@Cannot?5open?5?$CFls?6?$AA@FNODOBFM@
  00b15	e8 00 00 00 00	 call	 _DbgPrint
  00b1a	83 c4 08	 add	 esp, 8

; 415  : 
; 416  : 				goto error;

  00b1d	e9 8a 0a 00 00	 jmp	 $error$29236
$LN58@TCOpenVolu:

; 417  : 			}
; 418  : 
; 419  : 			parentKeyDataOffset.QuadPart = TC_BOOT_VOLUME_HEADER_SECTOR_OFFSET;

  00b22	c7 85 10 fe ff
	ff 00 7c 00 00	 mov	 DWORD PTR _parentKeyDataOffset$29339[ebp], 31744 ; 00007c00H
  00b2c	c7 85 14 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _parentKeyDataOffset$29339[ebp+4], 0

; 420  : 
; 421  : 			ntStatus = ZwReadFile (hParentDeviceFile,
; 422  : 				NULL,
; 423  : 				NULL,
; 424  : 				NULL,
; 425  : 				&IoStatusBlock,
; 426  : 				readBuffer,
; 427  : 				max (TC_VOLUME_HEADER_EFFECTIVE_SIZE, Extension->HostBytesPerSector),
; 428  : 				&parentKeyDataOffset,
; 429  : 				NULL);

  00b36	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  00b39	81 b8 90 00 00
	00 00 02 00 00	 cmp	 DWORD PTR [eax+144], 512 ; 00000200H
  00b43	73 0c		 jae	 SHORT $LN123@TCOpenVolu
  00b45	c7 85 bc fd ff
	ff 00 02 00 00	 mov	 DWORD PTR tv472[ebp], 512 ; 00000200H
  00b4f	eb 0f		 jmp	 SHORT $LN124@TCOpenVolu
$LN123@TCOpenVolu:
  00b51	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00b54	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  00b5a	89 95 bc fd ff
	ff		 mov	 DWORD PTR tv472[ebp], edx
$LN124@TCOpenVolu:
  00b60	6a 00		 push	 0
  00b62	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR _parentKeyDataOffset$29339[ebp]
  00b68	50		 push	 eax
  00b69	8b 8d bc fd ff
	ff		 mov	 ecx, DWORD PTR tv472[ebp]
  00b6f	51		 push	 ecx
  00b70	8b 55 a0	 mov	 edx, DWORD PTR _readBuffer$[ebp]
  00b73	52		 push	 edx
  00b74	8d 45 e8	 lea	 eax, DWORD PTR _IoStatusBlock$[ebp]
  00b77	50		 push	 eax
  00b78	6a 00		 push	 0
  00b7a	6a 00		 push	 0
  00b7c	6a 00		 push	 0
  00b7e	8b 8d f4 fd ff
	ff		 mov	 ecx, DWORD PTR _hParentDeviceFile$29335[ebp]
  00b84	51		 push	 ecx
  00b85	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwReadFile@36
  00b8b	89 85 70 ff ff
	ff		 mov	 DWORD PTR _ntStatus$[ebp], eax

; 430  : 
; 431  : 			if (hParentDeviceFile != NULL)

  00b91	83 bd f4 fd ff
	ff 00		 cmp	 DWORD PTR _hParentDeviceFile$29335[ebp], 0
  00b98	74 0d		 je	 SHORT $LN59@TCOpenVolu

; 432  : 				ZwClose (hParentDeviceFile);

  00b9a	8b 95 f4 fd ff
	ff		 mov	 edx, DWORD PTR _hParentDeviceFile$29335[ebp]
  00ba0	52		 push	 edx
  00ba1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4
$LN59@TCOpenVolu:

; 433  : 		}
; 434  : 
; 435  : 		if (!NT_SUCCESS (ntStatus) && ntStatus != STATUS_END_OF_FILE)

  00ba7	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR _ntStatus$[ebp], 0
  00bae	7d 25		 jge	 SHORT $LN55@TCOpenVolu
  00bb0	81 bd 70 ff ff
	ff 11 00 00 c0	 cmp	 DWORD PTR _ntStatus$[ebp], -1073741807 ; c0000011H
  00bba	74 19		 je	 SHORT $LN55@TCOpenVolu

; 436  : 		{
; 437  : 			Dump ("Read failed: NTSTATUS 0x%08x\n", ntStatus);

  00bbc	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _ntStatus$[ebp]
  00bc2	50		 push	 eax
  00bc3	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FHFPMFGI@Read?5failed?3?5NTSTATUS?50x?$CF08x?6?$AA@FNODOBFM@
  00bc8	e8 00 00 00 00	 call	 _DbgPrint
  00bcd	83 c4 08	 add	 esp, 8

; 438  : 			goto error;

  00bd0	e9 d7 09 00 00	 jmp	 $error$29236
$LN55@TCOpenVolu:

; 439  : 		}
; 440  : 
; 441  : 		if (ntStatus == STATUS_END_OF_FILE || IoStatusBlock.Information < TC_VOLUME_HEADER_EFFECTIVE_SIZE)

  00bd5	81 bd 70 ff ff
	ff 11 00 00 c0	 cmp	 DWORD PTR _ntStatus$[ebp], -1073741807 ; c0000011H
  00bdf	74 09		 je	 SHORT $LN53@TCOpenVolu
  00be1	81 7d ec 00 02
	00 00		 cmp	 DWORD PTR _IoStatusBlock$[ebp+4], 512 ; 00000200H
  00be8	73 20		 jae	 SHORT $LN54@TCOpenVolu
$LN53@TCOpenVolu:

; 442  : 		{
; 443  : 			Dump ("Read didn't read enough data\n");

  00bea	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@DBKGEMGK@Read?5didn?8t?5read?5enough?5data?6?$AA@FNODOBFM@
  00bef	e8 00 00 00 00	 call	 _DbgPrint
  00bf4	83 c4 04	 add	 esp, 4

; 444  : 
; 445  : 			// If FSCTL_ALLOW_EXTENDED_DASD_IO failed and there is a live filesystem on the partition, then the
; 446  : 			// filesystem driver may report EOF when we are reading hidden sectors (when the filesystem is 
; 447  : 			// shorter than the partition). This can happen for example after the user quick-formats a dismounted
; 448  : 			// partition-hosted CipherShed volume and then tries to mount the volume using the embedded backup header.
; 449  : 			memset (readBuffer, 0, TC_VOLUME_HEADER_EFFECTIVE_SIZE);

  00bf7	68 00 02 00 00	 push	 512			; 00000200H
  00bfc	6a 00		 push	 0
  00bfe	8b 4d a0	 mov	 ecx, DWORD PTR _readBuffer$[ebp]
  00c01	51		 push	 ecx
  00c02	e8 00 00 00 00	 call	 _memset
  00c07	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN54@TCOpenVolu:

; 450  : 		}
; 451  : 
; 452  : 		/* Attempt to recognize the volume (decrypt the header) */
; 453  : 
; 454  : 		ReadVolumeHeaderRecoveryMode = mount->RecoveryMode;

  00c0a	8b 55 10	 mov	 edx, DWORD PTR _mount$[ebp]
  00c0d	8b 82 dc 02 00
	00		 mov	 eax, DWORD PTR [edx+732]
  00c13	a3 00 00 00 00	 mov	 DWORD PTR _ReadVolumeHeaderRecoveryMode, eax

; 455  : 
; 456  : 		if ((volumeType == TC_VOLUME_TYPE_HIDDEN || volumeType == TC_VOLUME_TYPE_HIDDEN_LEGACY) && mount->bProtectHiddenVolume)

  00c18	83 bd 74 ff ff
	ff 01		 cmp	 DWORD PTR _volumeType$[ebp], 1
  00c1f	74 09		 je	 SHORT $LN51@TCOpenVolu
  00c21	83 bd 74 ff ff
	ff 02		 cmp	 DWORD PTR _volumeType$[ebp], 2
  00c28	75 38		 jne	 SHORT $LN52@TCOpenVolu
$LN51@TCOpenVolu:
  00c2a	8b 4d 10	 mov	 ecx, DWORD PTR _mount$[ebp]
  00c2d	83 b9 8c 02 00
	00 00		 cmp	 DWORD PTR [ecx+652], 0
  00c34	74 2c		 je	 SHORT $LN52@TCOpenVolu

; 457  : 		{
; 458  : 			mount->nReturnCode = ReadVolumeHeaderWCache (
; 459  : 				FALSE,
; 460  : 				mount->bCache,
; 461  : 				readBuffer,
; 462  : 				&mount->ProtectedHidVolPassword,
; 463  : 				&tmpCryptoInfo);

  00c36	8d 95 64 ff ff
	ff		 lea	 edx, DWORD PTR _tmpCryptoInfo$[ebp]
  00c3c	52		 push	 edx
  00c3d	8b 45 10	 mov	 eax, DWORD PTR _mount$[ebp]
  00c40	05 90 02 00 00	 add	 eax, 656		; 00000290H
  00c45	50		 push	 eax
  00c46	8b 4d a0	 mov	 ecx, DWORD PTR _readBuffer$[ebp]
  00c49	51		 push	 ecx
  00c4a	8b 55 10	 mov	 edx, DWORD PTR _mount$[ebp]
  00c4d	8b 82 60 02 00
	00		 mov	 eax, DWORD PTR [edx+608]
  00c53	50		 push	 eax
  00c54	6a 00		 push	 0
  00c56	e8 00 00 00 00	 call	 _ReadVolumeHeaderWCache@20
  00c5b	8b 4d 10	 mov	 ecx, DWORD PTR _mount$[ebp]
  00c5e	89 01		 mov	 DWORD PTR [ecx], eax

; 464  : 		}
; 465  : 		else

  00c60	eb 5b		 jmp	 SHORT $LN50@TCOpenVolu
$LN52@TCOpenVolu:

; 466  : 		{
; 467  : 			mount->nReturnCode = ReadVolumeHeaderWCache (
; 468  : 				mount->bPartitionInInactiveSysEncScope && volumeType == TC_VOLUME_TYPE_NORMAL,
; 469  : 				mount->bCache,
; 470  : 				readBuffer,
; 471  : 				&mount->VolumePassword,
; 472  : 				&Extension->cryptoInfo);

  00c62	8b 55 10	 mov	 edx, DWORD PTR _mount$[ebp]
  00c65	83 ba 80 02 00
	00 00		 cmp	 DWORD PTR [edx+640], 0
  00c6c	74 15		 je	 SHORT $LN125@TCOpenVolu
  00c6e	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _volumeType$[ebp], 0
  00c75	75 0c		 jne	 SHORT $LN125@TCOpenVolu
  00c77	c7 85 b8 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv516[ebp], 1
  00c81	eb 0a		 jmp	 SHORT $LN126@TCOpenVolu
$LN125@TCOpenVolu:
  00c83	c7 85 b8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv516[ebp], 0
$LN126@TCOpenVolu:
  00c8d	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  00c90	83 c0 60	 add	 eax, 96			; 00000060H
  00c93	50		 push	 eax
  00c94	8b 4d 10	 mov	 ecx, DWORD PTR _mount$[ebp]
  00c97	81 c1 18 02 00
	00		 add	 ecx, 536		; 00000218H
  00c9d	51		 push	 ecx
  00c9e	8b 55 a0	 mov	 edx, DWORD PTR _readBuffer$[ebp]
  00ca1	52		 push	 edx
  00ca2	8b 45 10	 mov	 eax, DWORD PTR _mount$[ebp]
  00ca5	8b 88 60 02 00
	00		 mov	 ecx, DWORD PTR [eax+608]
  00cab	51		 push	 ecx
  00cac	8b 95 b8 fd ff
	ff		 mov	 edx, DWORD PTR tv516[ebp]
  00cb2	52		 push	 edx
  00cb3	e8 00 00 00 00	 call	 _ReadVolumeHeaderWCache@20
  00cb8	8b 4d 10	 mov	 ecx, DWORD PTR _mount$[ebp]
  00cbb	89 01		 mov	 DWORD PTR [ecx], eax
$LN50@TCOpenVolu:

; 473  : 		}
; 474  : 
; 475  : 		ReadVolumeHeaderRecoveryMode = FALSE;

  00cbd	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ReadVolumeHeaderRecoveryMode, 0

; 476  : 
; 477  : 		if (mount->nReturnCode == 0 || mount->nReturnCode == ERR_CIPHER_INIT_WEAK_KEY)

  00cc7	8b 55 10	 mov	 edx, DWORD PTR _mount$[ebp]
  00cca	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00ccd	74 0c		 je	 SHORT $LN48@TCOpenVolu
  00ccf	8b 45 10	 mov	 eax, DWORD PTR _mount$[ebp]
  00cd2	83 38 12	 cmp	 DWORD PTR [eax], 18	; 00000012H
  00cd5	0f 85 8f 08 00
	00		 jne	 $LN49@TCOpenVolu
$LN48@TCOpenVolu:

; 478  : 		{
; 479  : 			/* Volume header successfully decrypted */
; 480  : 
; 481  : 			Dump ("Volume header decrypted\n");

  00cdb	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@JCBFCEPL@Volume?5header?5decrypted?6?$AA@FNODOBFM@
  00ce0	e8 00 00 00 00	 call	 _DbgPrint
  00ce5	83 c4 04	 add	 esp, 4

; 482  : 			Dump ("Required program version = %x\n", (int) Extension->cryptoInfo->RequiredProgramVersion);

  00ce8	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00ceb	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00cee	0f b7 82 38 44
	00 00		 movzx	 eax, WORD PTR [edx+17464]
  00cf5	50		 push	 eax
  00cf6	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@GNIOJEAD@Required?5program?5version?5?$DN?5?$CFx?6?$AA@FNODOBFM@
  00cfb	e8 00 00 00 00	 call	 _DbgPrint
  00d00	83 c4 08	 add	 esp, 8

; 483  : 			Dump ("Legacy volume = %d\n", (int) Extension->cryptoInfo->LegacyVolume);

  00d03	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00d06	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00d09	8b 82 3c 44 00
	00		 mov	 eax, DWORD PTR [edx+17468]
  00d0f	50		 push	 eax
  00d10	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@LHJMDIKA@Legacy?5volume?5?$DN?5?$CFd?6?$AA@FNODOBFM@
  00d15	e8 00 00 00 00	 call	 _DbgPrint
  00d1a	83 c4 08	 add	 esp, 8

; 484  : 
; 485  : 			if (IsHiddenSystemRunning() && !Extension->cryptoInfo->hiddenVolume)

  00d1d	e8 00 00 00 00	 call	 _IsHiddenSystemRunning@0
  00d22	85 c0		 test	 eax, eax
  00d24	74 38		 je	 SHORT $LN47@TCOpenVolu
  00d26	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00d29	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00d2c	83 ba a0 29 00
	00 00		 cmp	 DWORD PTR [edx+10656], 0
  00d33	75 29		 jne	 SHORT $LN47@TCOpenVolu

; 486  : 			{
; 487  : 				Extension->bReadOnly = mount->bMountReadOnly = TRUE;

  00d35	8b 45 10	 mov	 eax, DWORD PTR _mount$[ebp]
  00d38	c7 80 6c 02 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+620], 1
  00d42	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00d45	c7 81 88 02 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+648], 1

; 488  : 				HiddenSysLeakProtectionCount++;

  00d4f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _HiddenSysLeakProtectionCount
  00d55	83 c2 01	 add	 edx, 1
  00d58	89 15 00 00 00
	00		 mov	 DWORD PTR _HiddenSysLeakProtectionCount, edx
$LN47@TCOpenVolu:

; 489  : 			}
; 490  : 
; 491  : 			Extension->cryptoInfo->bProtectHiddenVolume = FALSE;

  00d5e	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  00d61	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00d64	c7 81 00 44 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+17408], 0

; 492  : 			Extension->cryptoInfo->bHiddenVolProtectionAction = FALSE;

  00d6e	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  00d71	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00d74	c7 80 04 44 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+17412], 0

; 493  : 
; 494  : 			Extension->cryptoInfo->bPartitionInInactiveSysEncScope = mount->bPartitionInInactiveSysEncScope;

  00d7e	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00d81	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00d84	8b 45 10	 mov	 eax, DWORD PTR _mount$[ebp]
  00d87	8b 88 80 02 00
	00		 mov	 ecx, DWORD PTR [eax+640]
  00d8d	89 8a 28 44 00
	00		 mov	 DWORD PTR [edx+17448], ecx

; 495  : 
; 496  : 			if (volumeType == TC_VOLUME_TYPE_NORMAL)

  00d93	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _volumeType$[ebp], 0
  00d9a	0f 85 87 01 00
	00		 jne	 $LN46@TCOpenVolu

; 497  : 			{
; 498  : 				if (mount->bPartitionInInactiveSysEncScope)

  00da0	8b 55 10	 mov	 edx, DWORD PTR _mount$[ebp]
  00da3	83 ba 80 02 00
	00 00		 cmp	 DWORD PTR [edx+640], 0
  00daa	0f 84 02 01 00
	00		 je	 $LN45@TCOpenVolu

; 499  : 				{
; 500  : 					if (Extension->cryptoInfo->EncryptedAreaStart.Value > (unsigned __int64) partitionStartingOffset
; 501  : 						|| Extension->cryptoInfo->EncryptedAreaStart.Value + Extension->cryptoInfo->VolumeSize.Value <= (unsigned __int64) partitionStartingOffset)

  00db0	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  00db3	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00db6	89 8d b4 fd ff
	ff		 mov	 DWORD PTR tv1187[ebp], ecx
  00dbc	8b 95 b4 fd ff
	ff		 mov	 edx, DWORD PTR tv1187[ebp]
  00dc2	8b 82 54 44 00
	00		 mov	 eax, DWORD PTR [edx+17492]
  00dc8	3b 85 6c ff ff
	ff		 cmp	 eax, DWORD PTR _partitionStartingOffset$[ebp+4]
  00dce	77 64		 ja	 SHORT $LN43@TCOpenVolu
  00dd0	72 14		 jb	 SHORT $LN134@TCOpenVolu
  00dd2	8b 8d b4 fd ff
	ff		 mov	 ecx, DWORD PTR tv1187[ebp]
  00dd8	8b 91 50 44 00
	00		 mov	 edx, DWORD PTR [ecx+17488]
  00dde	3b 95 68 ff ff
	ff		 cmp	 edx, DWORD PTR _partitionStartingOffset$[ebp]
  00de4	77 4e		 ja	 SHORT $LN43@TCOpenVolu
$LN134@TCOpenVolu:
  00de6	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  00de9	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00dec	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  00def	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00df2	8b 91 50 44 00
	00		 mov	 edx, DWORD PTR [ecx+17488]
  00df8	03 90 48 44 00
	00		 add	 edx, DWORD PTR [eax+17480]
  00dfe	8b 89 54 44 00
	00		 mov	 ecx, DWORD PTR [ecx+17492]
  00e04	13 88 4c 44 00
	00		 adc	 ecx, DWORD PTR [eax+17484]
  00e0a	89 95 ac fd ff
	ff		 mov	 DWORD PTR tv1203[ebp], edx
  00e10	89 8d b0 fd ff
	ff		 mov	 DWORD PTR tv1203[ebp+4], ecx
  00e16	8b 95 b0 fd ff
	ff		 mov	 edx, DWORD PTR tv1203[ebp+4]
  00e1c	3b 95 6c ff ff
	ff		 cmp	 edx, DWORD PTR _partitionStartingOffset$[ebp+4]
  00e22	77 28		 ja	 SHORT $LN44@TCOpenVolu
  00e24	72 0e		 jb	 SHORT $LN43@TCOpenVolu
  00e26	8b 85 ac fd ff
	ff		 mov	 eax, DWORD PTR tv1203[ebp]
  00e2c	3b 85 68 ff ff
	ff		 cmp	 eax, DWORD PTR _partitionStartingOffset$[ebp]
  00e32	77 18		 ja	 SHORT $LN44@TCOpenVolu
$LN43@TCOpenVolu:

; 502  : 					{
; 503  : 						// The partition is not within the key scope of system encryption
; 504  : 						mount->nReturnCode = ERR_PASSWORD_WRONG;

  00e34	8b 4d 10	 mov	 ecx, DWORD PTR _mount$[ebp]
  00e37	c7 01 03 00 00
	00		 mov	 DWORD PTR [ecx], 3

; 505  : 						ntStatus = STATUS_SUCCESS;

  00e3d	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ntStatus$[ebp], 0

; 506  : 						goto error;

  00e47	e9 60 07 00 00	 jmp	 $error$29236
$LN44@TCOpenVolu:

; 507  : 					}
; 508  : 
; 509  : 					if (Extension->cryptoInfo->EncryptedAreaLength.Value != Extension->cryptoInfo->VolumeSize.Value)

  00e4c	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  00e4f	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00e52	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00e55	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00e58	89 85 a8 fd ff
	ff		 mov	 DWORD PTR tv1213[ebp], eax
  00e5e	89 95 a4 fd ff
	ff		 mov	 DWORD PTR tv1214[ebp], edx
  00e64	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR tv1213[ebp]
  00e6a	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR tv1214[ebp]
  00e70	8b 90 58 44 00
	00		 mov	 edx, DWORD PTR [eax+17496]
  00e76	3b 91 48 44 00
	00		 cmp	 edx, DWORD PTR [ecx+17480]
  00e7c	75 1a		 jne	 SHORT $LN136@TCOpenVolu
  00e7e	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR tv1213[ebp]
  00e84	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR tv1214[ebp]
  00e8a	8b 90 5c 44 00
	00		 mov	 edx, DWORD PTR [eax+17500]
  00e90	3b 91 4c 44 00
	00		 cmp	 edx, DWORD PTR [ecx+17484]
  00e96	74 18		 je	 SHORT $LN42@TCOpenVolu
$LN136@TCOpenVolu:

; 510  : 					{
; 511  : 						// Partial encryption is not supported for volumes mounted as regular
; 512  : 						mount->nReturnCode = ERR_ENCRYPTION_NOT_COMPLETED;

  00e98	8b 45 10	 mov	 eax, DWORD PTR _mount$[ebp]
  00e9b	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH

; 513  : 						ntStatus = STATUS_SUCCESS;

  00ea1	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ntStatus$[ebp], 0

; 514  : 						goto error;

  00eab	e9 fc 06 00 00	 jmp	 $error$29236
$LN42@TCOpenVolu:

; 515  : 					}

  00eb0	eb 75		 jmp	 SHORT $LN46@TCOpenVolu
$LN45@TCOpenVolu:

; 516  : 				}
; 517  : 				else if (Extension->cryptoInfo->HeaderFlags & TC_HEADER_FLAG_NONSYS_INPLACE_ENC)

  00eb2	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00eb5	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00eb8	8b 82 60 44 00
	00		 mov	 eax, DWORD PTR [edx+17504]
  00ebe	83 e0 02	 and	 eax, 2
  00ec1	74 64		 je	 SHORT $LN46@TCOpenVolu

; 518  : 				{
; 519  : 					if (Extension->cryptoInfo->EncryptedAreaLength.Value != Extension->cryptoInfo->VolumeSize.Value)

  00ec3	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00ec6	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00ec9	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  00ecc	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00ecf	89 95 a0 fd ff
	ff		 mov	 DWORD PTR tv1227[ebp], edx
  00ed5	89 8d 9c fd ff
	ff		 mov	 DWORD PTR tv1228[ebp], ecx
  00edb	8b 95 a0 fd ff
	ff		 mov	 edx, DWORD PTR tv1227[ebp]
  00ee1	8b 85 9c fd ff
	ff		 mov	 eax, DWORD PTR tv1228[ebp]
  00ee7	8b 8a 58 44 00
	00		 mov	 ecx, DWORD PTR [edx+17496]
  00eed	3b 88 48 44 00
	00		 cmp	 ecx, DWORD PTR [eax+17480]
  00ef3	75 1a		 jne	 SHORT $LN137@TCOpenVolu
  00ef5	8b 95 a0 fd ff
	ff		 mov	 edx, DWORD PTR tv1227[ebp]
  00efb	8b 85 9c fd ff
	ff		 mov	 eax, DWORD PTR tv1228[ebp]
  00f01	8b 8a 5c 44 00
	00		 mov	 ecx, DWORD PTR [edx+17500]
  00f07	3b 88 4c 44 00
	00		 cmp	 ecx, DWORD PTR [eax+17484]
  00f0d	74 18		 je	 SHORT $LN46@TCOpenVolu
$LN137@TCOpenVolu:

; 520  : 					{
; 521  : 						// Non-system in-place encryption process has not been completed on this volume
; 522  : 						mount->nReturnCode = ERR_NONSYS_INPLACE_ENC_INCOMPLETE;

  00f0f	8b 55 10	 mov	 edx, DWORD PTR _mount$[ebp]
  00f12	c7 02 20 00 00
	00		 mov	 DWORD PTR [edx], 32	; 00000020H

; 523  : 						ntStatus = STATUS_SUCCESS;

  00f18	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ntStatus$[ebp], 0

; 524  : 						goto error;

  00f22	e9 85 06 00 00	 jmp	 $error$29236
$LN46@TCOpenVolu:

; 525  : 					}
; 526  : 				}
; 527  : 			}
; 528  : 
; 529  : 			Extension->cryptoInfo->FirstDataUnitNo.Value = 0;

  00f27	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  00f2a	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00f2d	c7 81 30 44 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+17456], 0
  00f37	c7 81 34 44 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+17460], 0

; 530  : 
; 531  : 			if (Extension->cryptoInfo->hiddenVolume && IsHiddenSystemRunning())

  00f41	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  00f44	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00f47	83 b8 a0 29 00
	00 00		 cmp	 DWORD PTR [eax+10656], 0
  00f4e	74 51		 je	 SHORT $LN38@TCOpenVolu
  00f50	e8 00 00 00 00	 call	 _IsHiddenSystemRunning@0
  00f55	85 c0		 test	 eax, eax
  00f57	74 48		 je	 SHORT $LN38@TCOpenVolu

; 532  : 			{
; 533  : 				// Prevent mount of a hidden system partition if the system hosted on it is currently running
; 534  : 				if (memcmp (Extension->cryptoInfo->master_keydata, GetSystemDriveCryptoInfo()->master_keydata, EAGetKeySize (Extension->cryptoInfo->ea)) == 0)

  00f59	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00f5c	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00f5f	8b 02		 mov	 eax, DWORD PTR [edx]
  00f61	50		 push	 eax
  00f62	e8 00 00 00 00	 call	 _EAGetKeySize@4
  00f67	8b d8		 mov	 ebx, eax
  00f69	e8 00 00 00 00	 call	 _GetSystemDriveCryptoInfo@0
  00f6e	05 a8 41 00 00	 add	 eax, 16808		; 000041a8H
  00f73	8b f8		 mov	 edi, eax
  00f75	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00f78	8b 71 60	 mov	 esi, DWORD PTR [ecx+96]
  00f7b	81 c6 a8 41 00
	00		 add	 esi, 16808		; 000041a8H
  00f81	8b cb		 mov	 ecx, ebx
  00f83	33 d2		 xor	 edx, edx
  00f85	f3 a6		 repe cmpsb
  00f87	75 18		 jne	 SHORT $LN38@TCOpenVolu

; 535  : 				{
; 536  : 					mount->nReturnCode = ERR_VOL_ALREADY_MOUNTED;

  00f89	8b 45 10	 mov	 eax, DWORD PTR _mount$[ebp]
  00f8c	c7 00 15 00 00
	00		 mov	 DWORD PTR [eax], 21	; 00000015H

; 537  : 					ntStatus = STATUS_SUCCESS;

  00f92	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ntStatus$[ebp], 0

; 538  : 					goto error;

  00f9c	e9 0b 06 00 00	 jmp	 $error$29236
$LN38@TCOpenVolu:

; 539  : 				}
; 540  : 			}
; 541  : 
; 542  : 			switch (volumeType)

  00fa1	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _volumeType$[ebp]
  00fa7	89 8d 98 fd ff
	ff		 mov	 DWORD PTR tv592[ebp], ecx
  00fad	83 bd 98 fd ff
	ff 00		 cmp	 DWORD PTR tv592[ebp], 0
  00fb4	74 1f		 je	 SHORT $LN34@TCOpenVolu
  00fb6	83 bd 98 fd ff
	ff 00		 cmp	 DWORD PTR tv592[ebp], 0
  00fbd	0f 8e 98 03 00
	00		 jle	 $LN35@TCOpenVolu
  00fc3	83 bd 98 fd ff
	ff 02		 cmp	 DWORD PTR tv592[ebp], 2
  00fca	0f 8e 01 01 00
	00		 jle	 $LN29@TCOpenVolu
  00fd0	e9 86 03 00 00	 jmp	 $LN35@TCOpenVolu
$LN34@TCOpenVolu:

; 543  : 			{
; 544  : 			case TC_VOLUME_TYPE_NORMAL:
; 545  : 
; 546  : 				Extension->cryptoInfo->hiddenVolume = FALSE;

  00fd5	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  00fd8	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00fdb	c7 80 a0 29 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+10656], 0

; 547  : 
; 548  : 				if (mount->bPartitionInInactiveSysEncScope)

  00fe5	8b 4d 10	 mov	 ecx, DWORD PTR _mount$[ebp]
  00fe8	83 b9 80 02 00
	00 00		 cmp	 DWORD PTR [ecx+640], 0
  00fef	74 5a		 je	 SHORT $LN33@TCOpenVolu

; 549  : 				{
; 550  : 					Extension->cryptoInfo->volDataAreaOffset = 0;

  00ff1	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  00ff4	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00ff7	c7 80 08 44 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+17416], 0
  01001	c7 80 0c 44 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+17420], 0

; 551  : 					Extension->DiskLength = lDiskLength.QuadPart;

  0100b	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0100e	8b 55 90	 mov	 edx, DWORD PTR _lDiskLength$[ebp]
  01011	89 51 70	 mov	 DWORD PTR [ecx+112], edx
  01014	8b 45 94	 mov	 eax, DWORD PTR _lDiskLength$[ebp+4]
  01017	89 41 74	 mov	 DWORD PTR [ecx+116], eax

; 552  : 					Extension->cryptoInfo->FirstDataUnitNo.Value = partitionStartingOffset / ENCRYPTION_DATA_UNIT_SIZE;

  0101a	6a 00		 push	 0
  0101c	68 00 02 00 00	 push	 512			; 00000200H
  01021	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _partitionStartingOffset$[ebp+4]
  01027	51		 push	 ecx
  01028	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _partitionStartingOffset$[ebp]
  0102e	52		 push	 edx
  0102f	e8 00 00 00 00	 call	 __alldiv
  01034	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  01037	8b 49 60	 mov	 ecx, DWORD PTR [ecx+96]
  0103a	89 81 30 44 00
	00		 mov	 DWORD PTR [ecx+17456], eax
  01040	89 91 34 44 00
	00		 mov	 DWORD PTR [ecx+17460], edx
  01046	e9 81 00 00 00	 jmp	 $LN32@TCOpenVolu
$LN33@TCOpenVolu:

; 553  : 				}
; 554  : 				else if (Extension->cryptoInfo->LegacyVolume)

  0104b	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  0104e	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  01051	83 b8 3c 44 00
	00 00		 cmp	 DWORD PTR [eax+17468], 0
  01058	74 33		 je	 SHORT $LN31@TCOpenVolu

; 555  : 				{
; 556  : 					Extension->cryptoInfo->volDataAreaOffset = TC_VOLUME_HEADER_SIZE_LEGACY;

  0105a	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0105d	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  01060	c7 82 08 44 00
	00 00 02 00 00	 mov	 DWORD PTR [edx+17416], 512 ; 00000200H
  0106a	c7 82 0c 44 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+17420], 0

; 557  : 					Extension->DiskLength = lDiskLength.QuadPart - TC_VOLUME_HEADER_SIZE_LEGACY;

  01074	8b 45 90	 mov	 eax, DWORD PTR _lDiskLength$[ebp]
  01077	2d 00 02 00 00	 sub	 eax, 512		; 00000200H
  0107c	8b 4d 94	 mov	 ecx, DWORD PTR _lDiskLength$[ebp+4]
  0107f	83 d9 00	 sbb	 ecx, 0
  01082	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  01085	89 42 70	 mov	 DWORD PTR [edx+112], eax
  01088	89 4a 74	 mov	 DWORD PTR [edx+116], ecx

; 558  : 				}
; 559  : 				else

  0108b	eb 3f		 jmp	 SHORT $LN32@TCOpenVolu
$LN31@TCOpenVolu:

; 560  : 				{
; 561  : 					Extension->cryptoInfo->volDataAreaOffset = Extension->cryptoInfo->EncryptedAreaStart.Value;

  0108d	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  01090	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  01093	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  01096	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  01099	8b 91 50 44 00
	00		 mov	 edx, DWORD PTR [ecx+17488]
  0109f	89 90 08 44 00
	00		 mov	 DWORD PTR [eax+17416], edx
  010a5	8b 89 54 44 00
	00		 mov	 ecx, DWORD PTR [ecx+17492]
  010ab	89 88 0c 44 00
	00		 mov	 DWORD PTR [eax+17420], ecx

; 562  : 					Extension->DiskLength = Extension->cryptoInfo->VolumeSize.Value;

  010b1	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  010b4	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  010b7	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  010ba	8b 90 48 44 00
	00		 mov	 edx, DWORD PTR [eax+17480]
  010c0	89 51 70	 mov	 DWORD PTR [ecx+112], edx
  010c3	8b 80 4c 44 00
	00		 mov	 eax, DWORD PTR [eax+17484]
  010c9	89 41 74	 mov	 DWORD PTR [ecx+116], eax
$LN32@TCOpenVolu:

; 563  : 				}
; 564  : 
; 565  : 				break;

  010cc	e9 8a 02 00 00	 jmp	 $LN35@TCOpenVolu
$LN29@TCOpenVolu:

; 566  : 
; 567  : 			case TC_VOLUME_TYPE_HIDDEN:
; 568  : 			case TC_VOLUME_TYPE_HIDDEN_LEGACY:
; 569  : 
; 570  : 				cryptoInfoPtr = mount->bProtectHiddenVolume ? tmpCryptoInfo : Extension->cryptoInfo;

  010d1	8b 4d 10	 mov	 ecx, DWORD PTR _mount$[ebp]
  010d4	83 b9 8c 02 00
	00 00		 cmp	 DWORD PTR [ecx+652], 0
  010db	74 0e		 je	 SHORT $LN127@TCOpenVolu
  010dd	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _tmpCryptoInfo$[ebp]
  010e3	89 95 94 fd ff
	ff		 mov	 DWORD PTR tv620[ebp], edx
  010e9	eb 0c		 jmp	 SHORT $LN128@TCOpenVolu
$LN127@TCOpenVolu:
  010eb	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  010ee	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  010f1	89 8d 94 fd ff
	ff		 mov	 DWORD PTR tv620[ebp], ecx
$LN128@TCOpenVolu:
  010f7	8b 95 94 fd ff
	ff		 mov	 edx, DWORD PTR tv620[ebp]
  010fd	89 55 f0	 mov	 DWORD PTR _cryptoInfoPtr$[ebp], edx

; 571  : 
; 572  : 				if (volumeType == TC_VOLUME_TYPE_HIDDEN_LEGACY)

  01100	83 bd 74 ff ff
	ff 02		 cmp	 DWORD PTR _volumeType$[ebp], 2
  01107	75 32		 jne	 SHORT $LN28@TCOpenVolu

; 573  : 					Extension->cryptoInfo->hiddenVolumeOffset = lDiskLength.QuadPart - cryptoInfoPtr->hiddenVolumeSize - TC_HIDDEN_VOLUME_HEADER_OFFSET_LEGACY;

  01109	8b 45 f0	 mov	 eax, DWORD PTR _cryptoInfoPtr$[ebp]
  0110c	8b 4d 90	 mov	 ecx, DWORD PTR _lDiskLength$[ebp]
  0110f	2b 88 10 44 00
	00		 sub	 ecx, DWORD PTR [eax+17424]
  01115	8b 55 94	 mov	 edx, DWORD PTR _lDiskLength$[ebp+4]
  01118	1b 90 14 44 00
	00		 sbb	 edx, DWORD PTR [eax+17428]
  0111e	81 e9 00 06 00
	00		 sub	 ecx, 1536		; 00000600H
  01124	83 da 00	 sbb	 edx, 0
  01127	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  0112a	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  0112d	89 88 18 44 00
	00		 mov	 DWORD PTR [eax+17432], ecx
  01133	89 90 1c 44 00
	00		 mov	 DWORD PTR [eax+17436], edx

; 574  : 				else

  01139	eb 21		 jmp	 SHORT $LN27@TCOpenVolu
$LN28@TCOpenVolu:

; 575  : 					Extension->cryptoInfo->hiddenVolumeOffset = cryptoInfoPtr->EncryptedAreaStart.Value;

  0113b	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0113e	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  01141	8b 45 f0	 mov	 eax, DWORD PTR _cryptoInfoPtr$[ebp]
  01144	8b 88 50 44 00
	00		 mov	 ecx, DWORD PTR [eax+17488]
  0114a	89 8a 18 44 00
	00		 mov	 DWORD PTR [edx+17432], ecx
  01150	8b 80 54 44 00
	00		 mov	 eax, DWORD PTR [eax+17492]
  01156	89 82 1c 44 00
	00		 mov	 DWORD PTR [edx+17436], eax
$LN27@TCOpenVolu:

; 576  : 
; 577  : 				Dump ("Hidden volume offset = %I64d\n", Extension->cryptoInfo->hiddenVolumeOffset);

  0115c	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0115f	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  01162	8b 82 1c 44 00
	00		 mov	 eax, DWORD PTR [edx+17436]
  01168	50		 push	 eax
  01169	8b 8a 18 44 00
	00		 mov	 ecx, DWORD PTR [edx+17432]
  0116f	51		 push	 ecx
  01170	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@HCAAKCJO@Hidden?5volume?5offset?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@
  01175	e8 00 00 00 00	 call	 _DbgPrint
  0117a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 578  : 				Dump ("Hidden volume size = %I64d\n", cryptoInfoPtr->hiddenVolumeSize);

  0117d	8b 55 f0	 mov	 edx, DWORD PTR _cryptoInfoPtr$[ebp]
  01180	8b 82 14 44 00
	00		 mov	 eax, DWORD PTR [edx+17428]
  01186	50		 push	 eax
  01187	8b 8a 10 44 00
	00		 mov	 ecx, DWORD PTR [edx+17424]
  0118d	51		 push	 ecx
  0118e	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@CHOGCNPN@Hidden?5volume?5size?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@
  01193	e8 00 00 00 00	 call	 _DbgPrint
  01198	83 c4 0c	 add	 esp, 12			; 0000000cH

; 579  : 				Dump ("Hidden volume end = %I64d\n", Extension->cryptoInfo->hiddenVolumeOffset + cryptoInfoPtr->hiddenVolumeSize - 1);

  0119b	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  0119e	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  011a1	8b 4d f0	 mov	 ecx, DWORD PTR _cryptoInfoPtr$[ebp]
  011a4	8b 90 18 44 00
	00		 mov	 edx, DWORD PTR [eax+17432]
  011aa	03 91 10 44 00
	00		 add	 edx, DWORD PTR [ecx+17424]
  011b0	8b 80 1c 44 00
	00		 mov	 eax, DWORD PTR [eax+17436]
  011b6	13 81 14 44 00
	00		 adc	 eax, DWORD PTR [ecx+17428]
  011bc	83 ea 01	 sub	 edx, 1
  011bf	83 d8 00	 sbb	 eax, 0
  011c2	50		 push	 eax
  011c3	52		 push	 edx
  011c4	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@DBKGLLJI@Hidden?5volume?5end?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@
  011c9	e8 00 00 00 00	 call	 _DbgPrint
  011ce	83 c4 0c	 add	 esp, 12			; 0000000cH

; 580  : 
; 581  : 				// Validate the offset
; 582  : 				if (Extension->cryptoInfo->hiddenVolumeOffset % ENCRYPTION_DATA_UNIT_SIZE != 0)

  011d1	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  011d4	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  011d7	6a 00		 push	 0
  011d9	68 00 02 00 00	 push	 512			; 00000200H
  011de	8b 82 1c 44 00
	00		 mov	 eax, DWORD PTR [edx+17436]
  011e4	50		 push	 eax
  011e5	8b 8a 18 44 00
	00		 mov	 ecx, DWORD PTR [edx+17432]
  011eb	51		 push	 ecx
  011ec	e8 00 00 00 00	 call	 __aullrem
  011f1	89 85 8c fd ff
	ff		 mov	 DWORD PTR tv1361[ebp], eax
  011f7	89 95 90 fd ff
	ff		 mov	 DWORD PTR tv1361[ebp+4], edx
  011fd	8b 95 8c fd ff
	ff		 mov	 edx, DWORD PTR tv1361[ebp]
  01203	0b 95 90 fd ff
	ff		 or	 edx, DWORD PTR tv1361[ebp+4]
  01209	74 18		 je	 SHORT $LN26@TCOpenVolu

; 583  : 				{
; 584  : 					mount->nReturnCode = ERR_VOL_SIZE_WRONG;

  0120b	8b 45 10	 mov	 eax, DWORD PTR _mount$[ebp]
  0120e	c7 00 07 00 00
	00		 mov	 DWORD PTR [eax], 7

; 585  : 					ntStatus = STATUS_SUCCESS;

  01214	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ntStatus$[ebp], 0

; 586  : 					goto error;

  0121e	e9 89 03 00 00	 jmp	 $error$29236
$LN26@TCOpenVolu:

; 587  : 				}
; 588  : 
; 589  : 				// If we are supposed to actually mount the hidden volume (not just to protect it)
; 590  : 				if (!mount->bProtectHiddenVolume)	

  01223	8b 4d 10	 mov	 ecx, DWORD PTR _mount$[ebp]
  01226	83 b9 8c 02 00
	00 00		 cmp	 DWORD PTR [ecx+652], 0
  0122d	75 51		 jne	 SHORT $LN25@TCOpenVolu

; 591  : 				{
; 592  : 					Extension->DiskLength = cryptoInfoPtr->hiddenVolumeSize;

  0122f	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  01232	8b 45 f0	 mov	 eax, DWORD PTR _cryptoInfoPtr$[ebp]
  01235	8b 88 10 44 00
	00		 mov	 ecx, DWORD PTR [eax+17424]
  0123b	89 4a 70	 mov	 DWORD PTR [edx+112], ecx
  0123e	8b 80 14 44 00
	00		 mov	 eax, DWORD PTR [eax+17428]
  01244	89 42 74	 mov	 DWORD PTR [edx+116], eax

; 593  : 					Extension->cryptoInfo->hiddenVolume = TRUE;

  01247	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0124a	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  0124d	c7 82 a0 29 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+10656], 1

; 594  : 					Extension->cryptoInfo->volDataAreaOffset = Extension->cryptoInfo->hiddenVolumeOffset;

  01257	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  0125a	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0125d	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  01260	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  01263	8b 91 18 44 00
	00		 mov	 edx, DWORD PTR [ecx+17432]
  01269	89 90 08 44 00
	00		 mov	 DWORD PTR [eax+17416], edx
  0126f	8b 89 1c 44 00
	00		 mov	 ecx, DWORD PTR [ecx+17436]
  01275	89 88 0c 44 00
	00		 mov	 DWORD PTR [eax+17420], ecx

; 595  : 				}
; 596  : 				else

  0127b	e9 db 00 00 00	 jmp	 $LN35@TCOpenVolu
$LN25@TCOpenVolu:

; 597  : 				{
; 598  : 					// Hidden volume protection
; 599  : 					Extension->cryptoInfo->hiddenVolume = FALSE;

  01280	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  01283	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  01286	c7 80 a0 29 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+10656], 0

; 600  : 					Extension->cryptoInfo->bProtectHiddenVolume = TRUE;

  01290	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  01293	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  01296	c7 82 00 44 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+17408], 1

; 601  : 					
; 602  : 					Extension->cryptoInfo->hiddenVolumeProtectedSize = tmpCryptoInfo->hiddenVolumeSize;

  012a0	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  012a3	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  012a6	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _tmpCryptoInfo$[ebp]
  012ac	8b 82 10 44 00
	00		 mov	 eax, DWORD PTR [edx+17424]
  012b2	89 81 20 44 00
	00		 mov	 DWORD PTR [ecx+17440], eax
  012b8	8b 92 14 44 00
	00		 mov	 edx, DWORD PTR [edx+17428]
  012be	89 91 24 44 00
	00		 mov	 DWORD PTR [ecx+17444], edx

; 603  : 
; 604  : 					if (volumeType == TC_VOLUME_TYPE_HIDDEN_LEGACY)

  012c4	83 bd 74 ff ff
	ff 02		 cmp	 DWORD PTR _volumeType$[ebp], 2
  012cb	75 2d		 jne	 SHORT $LN23@TCOpenVolu

; 605  : 						Extension->cryptoInfo->hiddenVolumeProtectedSize += TC_VOLUME_HEADER_SIZE_LEGACY;

  012cd	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  012d0	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  012d3	8b 91 20 44 00
	00		 mov	 edx, DWORD PTR [ecx+17440]
  012d9	81 c2 00 02 00
	00		 add	 edx, 512		; 00000200H
  012df	8b 81 24 44 00
	00		 mov	 eax, DWORD PTR [ecx+17444]
  012e5	83 d0 00	 adc	 eax, 0
  012e8	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  012eb	8b 49 60	 mov	 ecx, DWORD PTR [ecx+96]
  012ee	89 91 20 44 00
	00		 mov	 DWORD PTR [ecx+17440], edx
  012f4	89 81 24 44 00
	00		 mov	 DWORD PTR [ecx+17444], eax
$LN23@TCOpenVolu:

; 606  : 
; 607  : 					Dump ("Hidden volume protection active: %I64d-%I64d (%I64d)\n", Extension->cryptoInfo->hiddenVolumeOffset, Extension->cryptoInfo->hiddenVolumeProtectedSize + Extension->cryptoInfo->hiddenVolumeOffset - 1, Extension->cryptoInfo->hiddenVolumeProtectedSize);

  012fa	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  012fd	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  01300	8b 88 24 44 00
	00		 mov	 ecx, DWORD PTR [eax+17444]
  01306	51		 push	 ecx
  01307	8b 90 20 44 00
	00		 mov	 edx, DWORD PTR [eax+17440]
  0130d	52		 push	 edx
  0130e	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  01311	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  01314	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  01317	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  0131a	8b 91 20 44 00
	00		 mov	 edx, DWORD PTR [ecx+17440]
  01320	03 90 18 44 00
	00		 add	 edx, DWORD PTR [eax+17432]
  01326	8b 89 24 44 00
	00		 mov	 ecx, DWORD PTR [ecx+17444]
  0132c	13 88 1c 44 00
	00		 adc	 ecx, DWORD PTR [eax+17436]
  01332	83 ea 01	 sub	 edx, 1
  01335	83 d9 00	 sbb	 ecx, 0
  01338	51		 push	 ecx
  01339	52		 push	 edx
  0133a	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  0133d	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  01340	8b 88 1c 44 00
	00		 mov	 ecx, DWORD PTR [eax+17436]
  01346	51		 push	 ecx
  01347	8b 90 18 44 00
	00		 mov	 edx, DWORD PTR [eax+17432]
  0134d	52		 push	 edx
  0134e	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@NLAOEFNO@Hidden?5volume?5protection?5active?3@FNODOBFM@
  01353	e8 00 00 00 00	 call	 _DbgPrint
  01358	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN35@TCOpenVolu:

; 608  : 				}
; 609  : 
; 610  : 				break;
; 611  : 			}
; 612  : 
; 613  : 			Dump ("Volume data offset = %I64d\n", Extension->cryptoInfo->volDataAreaOffset);

  0135b	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  0135e	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  01361	8b 91 0c 44 00
	00		 mov	 edx, DWORD PTR [ecx+17420]
  01367	52		 push	 edx
  01368	8b 81 08 44 00
	00		 mov	 eax, DWORD PTR [ecx+17416]
  0136e	50		 push	 eax
  0136f	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@CDNAEGGM@Volume?5data?5offset?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@
  01374	e8 00 00 00 00	 call	 _DbgPrint
  01379	83 c4 0c	 add	 esp, 12			; 0000000cH

; 614  : 			Dump ("Volume data size = %I64d\n", Extension->DiskLength);

  0137c	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0137f	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  01382	52		 push	 edx
  01383	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  01386	50		 push	 eax
  01387	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@BIKGCOPF@Volume?5data?5size?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@
  0138c	e8 00 00 00 00	 call	 _DbgPrint
  01391	83 c4 0c	 add	 esp, 12			; 0000000cH

; 615  : 			Dump ("Volume data end = %I64d\n", Extension->cryptoInfo->volDataAreaOffset + Extension->DiskLength - 1);

  01394	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  01397	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  0139a	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  0139d	8b 8a 08 44 00
	00		 mov	 ecx, DWORD PTR [edx+17416]
  013a3	03 48 70	 add	 ecx, DWORD PTR [eax+112]
  013a6	8b 92 0c 44 00
	00		 mov	 edx, DWORD PTR [edx+17420]
  013ac	13 50 74	 adc	 edx, DWORD PTR [eax+116]
  013af	83 e9 01	 sub	 ecx, 1
  013b2	83 da 00	 sbb	 edx, 0
  013b5	52		 push	 edx
  013b6	51		 push	 ecx
  013b7	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@MEKDGODO@Volume?5data?5end?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@
  013bc	e8 00 00 00 00	 call	 _DbgPrint
  013c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 616  : 
; 617  : 			if (Extension->DiskLength == 0)

  013c4	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  013c7	89 85 88 fd ff
	ff		 mov	 DWORD PTR tv1452[ebp], eax
  013cd	8b 8d 88 fd ff
	ff		 mov	 ecx, DWORD PTR tv1452[ebp]
  013d3	8b 95 88 fd ff
	ff		 mov	 edx, DWORD PTR tv1452[ebp]
  013d9	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  013dc	0b 42 74	 or	 eax, DWORD PTR [edx+116]
  013df	75 12		 jne	 SHORT $LN22@TCOpenVolu

; 618  : 			{
; 619  : 				Dump ("Incorrect volume size\n");

  013e1	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@JONGPBLO@Incorrect?5volume?5size?6?$AA@FNODOBFM@
  013e6	e8 00 00 00 00	 call	 _DbgPrint
  013eb	83 c4 04	 add	 esp, 4

; 620  : 				continue;

  013ee	e9 ac f3 ff ff	 jmp	 $LN73@TCOpenVolu
$LN22@TCOpenVolu:

; 621  : 			}
; 622  : 
; 623  : 			// If this is a hidden volume, make sure we are supposed to actually
; 624  : 			// mount it (i.e. not just to protect it)
; 625  : 			if (volumeType == TC_VOLUME_TYPE_NORMAL || !mount->bProtectHiddenVolume)	

  013f3	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _volumeType$[ebp], 0
  013fa	74 10		 je	 SHORT $LN20@TCOpenVolu
  013fc	8b 4d 10	 mov	 ecx, DWORD PTR _mount$[ebp]
  013ff	83 b9 8c 02 00
	00 00		 cmp	 DWORD PTR [ecx+652], 0
  01406	0f 85 12 01 00
	00		 jne	 $LN21@TCOpenVolu
$LN20@TCOpenVolu:

; 626  : 			{
; 627  : 				// Validate sector size
; 628  : 				if (bRawDevice && Extension->cryptoInfo->SectorSize != Extension->HostBytesPerSector)

  0140c	83 7d 18 00	 cmp	 DWORD PTR _bRawDevice$[ebp], 0
  01410	74 2f		 je	 SHORT $LN19@TCOpenVolu
  01412	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  01415	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  01418	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0141b	8b 90 40 44 00
	00		 mov	 edx, DWORD PTR [eax+17472]
  01421	3b 91 90 00 00
	00		 cmp	 edx, DWORD PTR [ecx+144]
  01427	74 18		 je	 SHORT $LN19@TCOpenVolu

; 629  : 				{
; 630  : 					mount->nReturnCode = ERR_PARAMETER_INCORRECT;

  01429	8b 45 10	 mov	 eax, DWORD PTR _mount$[ebp]
  0142c	c7 00 1e 00 00
	00		 mov	 DWORD PTR [eax], 30	; 0000001eH

; 631  : 					ntStatus = STATUS_SUCCESS;

  01432	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ntStatus$[ebp], 0

; 632  : 					goto error;

  0143c	e9 6b 01 00 00	 jmp	 $error$29236
$LN19@TCOpenVolu:

; 633  : 				}
; 634  : 
; 635  : 				// Calculate virtual volume geometry
; 636  : 				Extension->TracksPerCylinder = 1;

  01441	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  01444	c7 81 80 00 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+128], 1

; 637  : 				Extension->SectorsPerTrack = 1;

  0144e	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  01451	c7 82 84 00 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+132], 1

; 638  : 				Extension->BytesPerSector = Extension->cryptoInfo->SectorSize;

  0145b	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  0145e	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  01461	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  01464	8b 81 40 44 00
	00		 mov	 eax, DWORD PTR [ecx+17472]
  0146a	89 82 88 00 00
	00		 mov	 DWORD PTR [edx+136], eax

; 639  : 				Extension->NumberOfCylinders = Extension->DiskLength / Extension->BytesPerSector;

  01470	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  01473	8b 91 88 00 00
	00		 mov	 edx, DWORD PTR [ecx+136]
  01479	33 c0		 xor	 eax, eax
  0147b	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0147e	50		 push	 eax
  0147f	52		 push	 edx
  01480	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  01483	52		 push	 edx
  01484	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  01487	50		 push	 eax
  01488	e8 00 00 00 00	 call	 __alldiv
  0148d	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  01490	89 41 78	 mov	 DWORD PTR [ecx+120], eax
  01493	89 51 7c	 mov	 DWORD PTR [ecx+124], edx

; 640  : 				Extension->PartitionType = 0;

  01496	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  01499	c6 82 8c 00 00
	00 00		 mov	 BYTE PTR [edx+140], 0

; 641  : 
; 642  : 				Extension->bRawDevice = bRawDevice;

  014a0	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  014a3	8b 4d 18	 mov	 ecx, DWORD PTR _bRawDevice$[ebp]
  014a6	89 88 94 02 00
	00		 mov	 DWORD PTR [eax+660], ecx

; 643  : 				
; 644  : 				memset (Extension->wszVolume, 0, sizeof (Extension->wszVolume));

  014ac	68 08 02 00 00	 push	 520			; 00000208H
  014b1	6a 00		 push	 0
  014b3	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  014b6	81 c2 a0 02 00
	00		 add	 edx, 672		; 000002a0H
  014bc	52		 push	 edx
  014bd	e8 00 00 00 00	 call	 _memset
  014c2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 645  : 				if (wcsstr (pwszMountVolume, WIDE ("\\??\\UNC\\")) == pwszMountVolume)

  014c5	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@MAMPPFNN@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AAU?$AAN?$AAC?$AA?2?$AA?$AA@FNODOBFM@
  014ca	8b 45 14	 mov	 eax, DWORD PTR _pwszMountVolume$[ebp]
  014cd	50		 push	 eax
  014ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcsstr
  014d4	83 c4 08	 add	 esp, 8
  014d7	3b 45 14	 cmp	 eax, DWORD PTR _pwszMountVolume$[ebp]
  014da	75 26		 jne	 SHORT $LN18@TCOpenVolu

; 646  : 				{
; 647  : 					/* UNC path */
; 648  : 					_snwprintf (Extension->wszVolume,
; 649  : 						sizeof (Extension->wszVolume) / sizeof (WCHAR) - 1,
; 650  : 						WIDE ("\\??\\\\%s"),
; 651  : 						pwszMountVolume + 7);

  014dc	8b 4d 14	 mov	 ecx, DWORD PTR _pwszMountVolume$[ebp]
  014df	83 c1 0e	 add	 ecx, 14			; 0000000eH
  014e2	51		 push	 ecx
  014e3	68 00 00 00 00	 push	 OFFSET ??_C@_1BA@GIIKONIJ@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@
  014e8	68 03 01 00 00	 push	 259			; 00000103H
  014ed	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  014f0	81 c2 a0 02 00
	00		 add	 edx, 672		; 000002a0H
  014f6	52		 push	 edx
  014f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___snwprintf
  014fd	83 c4 10	 add	 esp, 16			; 00000010H

; 652  : 				}
; 653  : 				else

  01500	eb 1c		 jmp	 SHORT $LN21@TCOpenVolu
$LN18@TCOpenVolu:

; 654  : 				{
; 655  : 					wcsncpy (Extension->wszVolume, pwszMountVolume, sizeof (Extension->wszVolume) / sizeof (WCHAR) - 1);

  01502	68 03 01 00 00	 push	 259			; 00000103H
  01507	8b 45 14	 mov	 eax, DWORD PTR _pwszMountVolume$[ebp]
  0150a	50		 push	 eax
  0150b	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0150e	81 c1 a0 02 00
	00		 add	 ecx, 672		; 000002a0H
  01514	51		 push	 ecx
  01515	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcsncpy
  0151b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN21@TCOpenVolu:

; 656  : 				}
; 657  : 			}
; 658  : 
; 659  : 			// If we are to protect a hidden volume we cannot exit yet, for we must also
; 660  : 			// decrypt the hidden volume header.
; 661  : 			if (!(volumeType == TC_VOLUME_TYPE_NORMAL && mount->bProtectHiddenVolume))

  0151e	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _volumeType$[ebp], 0
  01525	75 0c		 jne	 SHORT $LN15@TCOpenVolu
  01527	8b 55 10	 mov	 edx, DWORD PTR _mount$[ebp]
  0152a	83 ba 8c 02 00
	00 00		 cmp	 DWORD PTR [edx+652], 0
  01531	75 35		 jne	 SHORT $LN16@TCOpenVolu
$LN15@TCOpenVolu:

; 662  : 			{
; 663  : 				TCfree (readBuffer);

  01533	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  01538	8b 45 a0	 mov	 eax, DWORD PTR _readBuffer$[ebp]
  0153b	50		 push	 eax
  0153c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 664  : 
; 665  : 				if (tmpCryptoInfo != NULL)

  01542	83 bd 64 ff ff
	ff 00		 cmp	 DWORD PTR _tmpCryptoInfo$[ebp], 0
  01549	74 16		 je	 SHORT $LN14@TCOpenVolu

; 666  : 				{
; 667  : 					crypto_close (tmpCryptoInfo);

  0154b	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _tmpCryptoInfo$[ebp]
  01551	51		 push	 ecx
  01552	e8 00 00 00 00	 call	 _crypto_close@4

; 668  : 					tmpCryptoInfo = NULL;

  01557	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _tmpCryptoInfo$[ebp], 0
$LN14@TCOpenVolu:

; 669  : 				}
; 670  : 				
; 671  : 				return STATUS_SUCCESS;

  01561	33 c0		 xor	 eax, eax
  01563	e9 ee 00 00 00	 jmp	 $LN108@TCOpenVolu
$LN16@TCOpenVolu:

; 672  : 			}
; 673  : 		}
; 674  : 		else if ((mount->bProtectHiddenVolume && volumeType == TC_VOLUME_TYPE_NORMAL)

  01568	eb 1f		 jmp	 SHORT $LN13@TCOpenVolu
$LN49@TCOpenVolu:

; 675  : 			  || mount->nReturnCode != ERR_PASSWORD_WRONG)

  0156a	8b 55 10	 mov	 edx, DWORD PTR _mount$[ebp]
  0156d	83 ba 8c 02 00
	00 00		 cmp	 DWORD PTR [edx+652], 0
  01574	74 09		 je	 SHORT $LN10@TCOpenVolu
  01576	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _volumeType$[ebp], 0
  0157d	74 08		 je	 SHORT $LN11@TCOpenVolu
$LN10@TCOpenVolu:
  0157f	8b 45 10	 mov	 eax, DWORD PTR _mount$[ebp]
  01582	83 38 03	 cmp	 DWORD PTR [eax], 3
  01585	74 02		 je	 SHORT $LN13@TCOpenVolu
$LN11@TCOpenVolu:

; 676  : 		{
; 677  : 			 /* If we are not supposed to protect a hidden volume, the only error that is
; 678  : 				tolerated is ERR_PASSWORD_WRONG (to allow mounting a possible hidden volume). 
; 679  : 
; 680  : 				If we _are_ supposed to protect a hidden volume, we do not tolerate any error
; 681  : 				(both volume headers must be successfully decrypted). */
; 682  : 
; 683  : 			break;

  01587	eb 05		 jmp	 SHORT $LN72@TCOpenVolu
$LN13@TCOpenVolu:

; 684  : 		}
; 685  : 	}

  01589	e9 11 f2 ff ff	 jmp	 $LN73@TCOpenVolu
$LN72@TCOpenVolu:

; 686  : 
; 687  : 	/* Failed due to some non-OS reason so we drop through and return NT
; 688  : 	   SUCCESS then nReturnCode is checked later in user-mode */
; 689  : 
; 690  : 	if (mount->nReturnCode == ERR_OUTOFMEMORY)

  0158e	8b 4d 10	 mov	 ecx, DWORD PTR _mount$[ebp]
  01591	83 39 02	 cmp	 DWORD PTR [ecx], 2
  01594	75 0c		 jne	 SHORT $LN9@TCOpenVolu

; 691  : 		ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  01596	c7 85 70 ff ff
	ff 9a 00 00 c0	 mov	 DWORD PTR _ntStatus$[ebp], -1073741670 ; c000009aH

; 692  : 	else

  015a0	eb 0a		 jmp	 SHORT $error$29236
$LN9@TCOpenVolu:

; 693  : 		ntStatus = STATUS_SUCCESS;

  015a2	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ntStatus$[ebp], 0
$error$29236:

; 694  : 
; 695  : error:
; 696  : 	if (mount->nReturnCode == ERR_SUCCESS)

  015ac	8b 55 10	 mov	 edx, DWORD PTR _mount$[ebp]
  015af	83 3a 00	 cmp	 DWORD PTR [edx], 0
  015b2	75 09		 jne	 SHORT $LN7@TCOpenVolu

; 697  : 		mount->nReturnCode = ERR_PASSWORD_WRONG;

  015b4	8b 45 10	 mov	 eax, DWORD PTR _mount$[ebp]
  015b7	c7 00 03 00 00
	00		 mov	 DWORD PTR [eax], 3
$LN7@TCOpenVolu:

; 698  : 
; 699  : 	if (tmpCryptoInfo != NULL)

  015bd	83 bd 64 ff ff
	ff 00		 cmp	 DWORD PTR _tmpCryptoInfo$[ebp], 0
  015c4	74 16		 je	 SHORT $LN6@TCOpenVolu

; 700  : 	{
; 701  : 		crypto_close (tmpCryptoInfo);

  015c6	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _tmpCryptoInfo$[ebp]
  015cc	51		 push	 ecx
  015cd	e8 00 00 00 00	 call	 _crypto_close@4

; 702  : 		tmpCryptoInfo = NULL;

  015d2	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _tmpCryptoInfo$[ebp], 0
$LN6@TCOpenVolu:

; 703  : 	}
; 704  : 
; 705  : 	if (Extension->cryptoInfo)

  015dc	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  015df	83 7a 60 00	 cmp	 DWORD PTR [edx+96], 0
  015e3	74 16		 je	 SHORT $LN5@TCOpenVolu

; 706  : 	{
; 707  : 		crypto_close (Extension->cryptoInfo);

  015e5	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  015e8	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  015eb	51		 push	 ecx
  015ec	e8 00 00 00 00	 call	 _crypto_close@4

; 708  : 		Extension->cryptoInfo = NULL;

  015f1	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  015f4	c7 42 60 00 00
	00 00		 mov	 DWORD PTR [edx+96], 0
$LN5@TCOpenVolu:

; 709  : 	}
; 710  : 
; 711  : 	if (Extension->bTimeStampValid)

  015fb	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  015fe	83 b8 c8 04 00
	00 00		 cmp	 DWORD PTR [eax+1224], 0
  01605	74 09		 je	 SHORT $LN4@TCOpenVolu

; 712  : 	{
; 713  : 		RestoreTimeStamp (Extension);

  01607	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0160a	51		 push	 ecx
  0160b	e8 00 00 00 00	 call	 _RestoreTimeStamp@4
$LN4@TCOpenVolu:

; 714  : 	}
; 715  : 
; 716  : 	/* Close the hDeviceFile */
; 717  : 	if (Extension->hDeviceFile != NULL)

  01610	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  01613	83 7a 54 00	 cmp	 DWORD PTR [edx+84], 0
  01617	74 0d		 je	 SHORT $LN3@TCOpenVolu

; 718  : 		ZwClose (Extension->hDeviceFile);

  01619	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  0161c	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  0161f	51		 push	 ecx
  01620	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4
$LN3@TCOpenVolu:

; 719  : 
; 720  : 	/* The cryptoInfo pointer is deallocated if the readheader routines
; 721  : 	   fail so there is no need to deallocate here  */
; 722  : 
; 723  : 	/* Dereference the user-mode file object */
; 724  : 	if (Extension->pfoDeviceFile != NULL)

  01626	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  01629	83 7a 58 00	 cmp	 DWORD PTR [edx+88], 0
  0162d	74 0c		 je	 SHORT $LN2@TCOpenVolu

; 725  : 		ObDereferenceObject (Extension->pfoDeviceFile);

  0162f	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  01632	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  01635	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4
$LN2@TCOpenVolu:

; 726  : 
; 727  : 	/* Free the tmp IO buffers */
; 728  : 	if (readBuffer != NULL)

  0163b	83 7d a0 00	 cmp	 DWORD PTR _readBuffer$[ebp], 0
  0163f	74 0f		 je	 SHORT $LN1@TCOpenVolu

; 729  : 		TCfree (readBuffer);

  01641	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  01646	8b 4d a0	 mov	 ecx, DWORD PTR _readBuffer$[ebp]
  01649	51		 push	 ecx
  0164a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN1@TCOpenVolu:

; 730  : 
; 731  : 	return ntStatus;

  01650	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _ntStatus$[ebp]
$LN108@TCOpenVolu:

; 732  : }

  01656	5f		 pop	 edi
  01657	5e		 pop	 esi
  01658	5b		 pop	 ebx
  01659	8b 8d 7c fe ff
	ff		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0165f	33 cd		 xor	 ecx, ebp
  01661	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01666	8b e5		 mov	 esp, ebp
  01668	5d		 pop	 ebp
  01669	c2 14 00	 ret	 20			; 00000014H
_TCOpenVolume@20 ENDP
_TEXT	ENDS
PUBLIC	_TCCloseVolume@8
; Function compile flags: /Odtp
;	COMDAT _TCCloseVolume@8
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_Extension$ = 12					; size = 4
_TCCloseVolume@8 PROC					; COMDAT

; 735  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 736  : 	if (DeviceObject);	/* Remove compiler warning */
; 737  : 
; 738  : 	if (Extension->hDeviceFile != NULL)

  00005	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  00008	83 78 54 00	 cmp	 DWORD PTR [eax+84], 0
  0000c	74 2e		 je	 SHORT $LN2@TCCloseVol

; 739  : 	{
; 740  : 		if (Extension->bRawDevice == FALSE
; 741  : 			&& Extension->bTimeStampValid)

  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00011	83 b9 94 02 00
	00 00		 cmp	 DWORD PTR [ecx+660], 0
  00018	75 15		 jne	 SHORT $LN1@TCCloseVol
  0001a	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  0001d	83 ba c8 04 00
	00 00		 cmp	 DWORD PTR [edx+1224], 0
  00024	74 09		 je	 SHORT $LN1@TCCloseVol

; 742  : 		{
; 743  : 			RestoreTimeStamp (Extension);

  00026	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _RestoreTimeStamp@4
$LN1@TCCloseVol:

; 744  : 		}
; 745  : 		ZwClose (Extension->hDeviceFile);

  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00032	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  00035	52		 push	 edx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4
$LN2@TCCloseVol:

; 746  : 	}
; 747  : 	ObDereferenceObject (Extension->pfoDeviceFile);

  0003c	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  0003f	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 748  : 	crypto_close (Extension->cryptoInfo);

  00048	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0004b	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  0004e	52		 push	 edx
  0004f	e8 00 00 00 00	 call	 _crypto_close@4

; 749  : }

  00054	5d		 pop	 ebp
  00055	c2 08 00	 ret	 8
_TCCloseVolume@8 ENDP
_TEXT	ENDS
PUBLIC	_IoGetNextIrpStackLocation@4
PUBLIC	??_C@_0BH@BPCEMJJB@IRP?5allocation?5failed?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp__KeWaitForSingleObject@20:PROC
EXTRN	__imp_@IofCallDriver@8:PROC
EXTRN	__imp__IoBuildDeviceIoControlRequest@36:PROC
EXTRN	__imp__KeClearEvent@4:PROC
;	COMDAT ??_C@_0BH@BPCEMJJB@IRP?5allocation?5failed?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BH@BPCEMJJB@IRP?5allocation?5failed?6?$AA@FNODOBFM@ DB 'IRP alloca'
	DB	'tion failed', 0aH, 00H			;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _TCSendHostDeviceIoControlRequest@20
_TEXT	SEGMENT
_ntStatus$ = -16					; size = 4
_IoStatusBlock$ = -12					; size = 8
_Irp$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_Extension$ = 12					; size = 4
_IoControlCode$ = 16					; size = 4
_OutputBuffer$ = 20					; size = 4
_OutputBufferSize$ = 24					; size = 4
_TCSendHostDeviceIoControlRequest@20 PROC		; COMDAT

; 757  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 10	 sub	 esp, 16			; 00000010H

; 758  : 	IO_STATUS_BLOCK IoStatusBlock;
; 759  : 	NTSTATUS ntStatus;
; 760  : 	PIRP Irp;
; 761  : 
; 762  : 	if (DeviceObject);	/* Remove compiler warning */
; 763  : 
; 764  : 	KeClearEvent (&Extension->keVolumeEvent);

  00008	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  0000b	05 94 00 00 00	 add	 eax, 148		; 00000094H
  00010	50		 push	 eax
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeClearEvent@4

; 765  : 
; 766  : 	Irp = IoBuildDeviceIoControlRequest (IoControlCode,
; 767  : 					     Extension->pFsdDevice,
; 768  : 					     NULL, 0,
; 769  : 					     OutputBuffer, OutputBufferSize,
; 770  : 					     FALSE,
; 771  : 					     &Extension->keVolumeEvent,
; 772  : 					     &IoStatusBlock);

  00017	8d 4d f4	 lea	 ecx, DWORD PTR _IoStatusBlock$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  0001e	81 c2 94 00 00
	00		 add	 edx, 148		; 00000094H
  00024	52		 push	 edx
  00025	6a 00		 push	 0
  00027	8b 45 18	 mov	 eax, DWORD PTR _OutputBufferSize$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 14	 mov	 ecx, DWORD PTR _OutputBuffer$[ebp]
  0002e	51		 push	 ecx
  0002f	6a 00		 push	 0
  00031	6a 00		 push	 0
  00033	8b 55 0c	 mov	 edx, DWORD PTR _Extension$[ebp]
  00036	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  00039	50		 push	 eax
  0003a	8b 4d 10	 mov	 ecx, DWORD PTR _IoControlCode$[ebp]
  0003d	51		 push	 ecx
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36
  00044	89 45 fc	 mov	 DWORD PTR _Irp$[ebp], eax

; 773  : 
; 774  : 	if (Irp == NULL)

  00047	83 7d fc 00	 cmp	 DWORD PTR _Irp$[ebp], 0
  0004b	75 14		 jne	 SHORT $LN2@TCSendHost

; 775  : 	{
; 776  : 		Dump ("IRP allocation failed\n");

  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@BPCEMJJB@IRP?5allocation?5failed?6?$AA@FNODOBFM@
  00052	e8 00 00 00 00	 call	 _DbgPrint
  00057	83 c4 04	 add	 esp, 4

; 777  : 		return STATUS_INSUFFICIENT_RESOURCES;

  0005a	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  0005f	eb 4e		 jmp	 SHORT $LN4@TCSendHost
$LN2@TCSendHost:

; 778  : 	}
; 779  : 
; 780  : 	// Disk device may be used by filesystem driver which needs file object
; 781  : 	IoGetNextIrpStackLocation (Irp) -> FileObject = Extension->pfoDeviceFile;

  00061	8b 55 fc	 mov	 edx, DWORD PTR _Irp$[ebp]
  00064	52		 push	 edx
  00065	e8 00 00 00 00	 call	 _IoGetNextIrpStackLocation@4
  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0006d	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  00070	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 782  : 
; 783  : 	ntStatus = IoCallDriver (Extension->pFsdDevice, Irp);

  00073	8b 55 fc	 mov	 edx, DWORD PTR _Irp$[ebp]
  00076	8b 45 0c	 mov	 eax, DWORD PTR _Extension$[ebp]
  00079	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8
  00082	89 45 f0	 mov	 DWORD PTR _ntStatus$[ebp], eax

; 784  : 	if (ntStatus == STATUS_PENDING)

  00085	81 7d f0 03 01
	00 00		 cmp	 DWORD PTR _ntStatus$[ebp], 259 ; 00000103H
  0008c	75 1e		 jne	 SHORT $LN1@TCSendHost

; 785  : 	{
; 786  : 		KeWaitForSingleObject (&Extension->keVolumeEvent, Executive, KernelMode, FALSE, NULL);

  0008e	6a 00		 push	 0
  00090	6a 00		 push	 0
  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	8b 4d 0c	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00099	81 c1 94 00 00
	00		 add	 ecx, 148		; 00000094H
  0009f	51		 push	 ecx
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 787  : 		ntStatus = IoStatusBlock.Status;

  000a6	8b 55 f4	 mov	 edx, DWORD PTR _IoStatusBlock$[ebp]
  000a9	89 55 f0	 mov	 DWORD PTR _ntStatus$[ebp], edx
$LN1@TCSendHost:

; 788  : 	}
; 789  : 
; 790  : 	return ntStatus;

  000ac	8b 45 f0	 mov	 eax, DWORD PTR _ntStatus$[ebp]
$LN4@TCSendHost:

; 791  : }

  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c2 14 00	 ret	 20			; 00000014H
_TCSendHostDeviceIoControlRequest@20 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp__RtlAssert@16:PROC
;	COMDAT ??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
text$s	SEGMENT
??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@ DB 'Irp'
	DB	'->CurrentLocation > 0', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@
text$s	SEGMENT
??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@ DB 'c'
	DB	':\winddk\7600.16385.1\inc\ddk\wdm.h', 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _IoGetNextIrpStackLocation@4
_TEXT	SEGMENT
tv71 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoGetNextIrpStackLocation@4 PROC			; COMDAT

; 23479: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 23480:     ASSERT(Irp->CurrentLocation > 0);

  00006	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00009	0f be 48 23	 movsx	 ecx, BYTE PTR [eax+35]
  0000d	85 c9		 test	 ecx, ecx
  0000f	7f 20		 jg	 SHORT $LN3@IoGetNextI
  00011	6a 00		 push	 0
  00013	68 b8 5b 00 00	 push	 23480			; 00005bb8H
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
  0002f	eb 07		 jmp	 SHORT $LN4@IoGetNextI
$LN3@IoGetNextI:
  00031	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
$LN4@IoGetNextI:

; 23481: 
; 23482:     return ((Irp)->Tail.Overlay.CurrentStackLocation - 1 );

  00038	8b 55 08	 mov	 edx, DWORD PTR _Irp$[ebp]
  0003b	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  0003e	83 e8 24	 sub	 eax, 36			; 00000024H

; 23483: }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
_IoGetNextIrpStackLocation@4 ENDP
_TEXT	ENDS
PUBLIC	_COMPLETE_IRP@16
EXTRN	__imp_@IofCompleteRequest@8:PROC
; Function compile flags: /Odtp
; File c:\home\public\desktop\projects\ciphershed.build\src\driver\ntvol.c
;	COMDAT _COMPLETE_IRP@16
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_IrpStatus$ = 16					; size = 4
_IrpInformation$ = 20					; size = 4
_COMPLETE_IRP@16 PROC					; COMDAT

; 797  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 798  : 	Irp->IoStatus.Status = IrpStatus;

  00005	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00008	8b 4d 10	 mov	 ecx, DWORD PTR _IrpStatus$[ebp]
  0000b	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 799  : 	Irp->IoStatus.Information = IrpInformation;

  0000e	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  00011	8b 45 14	 mov	 eax, DWORD PTR _IrpInformation$[ebp]
  00014	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 800  : 
; 801  : 	if (DeviceObject);	/* Remove compiler warning */
; 802  : 
; 803  : #if EXTRA_INFO
; 804  : 	if (!NT_SUCCESS (IrpStatus))
; 805  : 	{
; 806  : 		PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);
; 807  : 		Dump ("COMPLETE_IRP FAILING IRP %ls Flags 0x%08x vpb 0x%08x NTSTATUS 0x%08x\n", TCTranslateCode (irpSp->MajorFunction),
; 808  : 		      (ULONG) DeviceObject->Flags, (ULONG) DeviceObject->Vpb->Flags, IrpStatus);
; 809  : 	}
; 810  : 	else
; 811  : 	{
; 812  : 		PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);
; 813  : 		Dump ("COMPLETE_IRP SUCCESS IRP %ls Flags 0x%08x vpb 0x%08x NTSTATUS 0x%08x\n", TCTranslateCode (irpSp->MajorFunction),
; 814  : 		      (ULONG) DeviceObject->Flags, (ULONG) DeviceObject->Vpb->Flags, IrpStatus);
; 815  : 	}
; 816  : #endif
; 817  : 	IoCompleteRequest (Irp, IO_NO_INCREMENT);

  00017	32 d2		 xor	 dl, dl
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 818  : 	return IrpStatus;

  00022	8b 45 10	 mov	 eax, DWORD PTR _IrpStatus$[ebp]

; 819  : }

  00025	5d		 pop	 ebp
  00026	c2 10 00	 ret	 16			; 00000010H
_COMPLETE_IRP@16 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EC@JFODFBAB@ZwSetInformationFile?5failed?5in?5R@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EE@JIJFFNGM@ZwQueryInformationFile?5failed?5in@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp__ZwSetInformationFile@20:PROC
;	COMDAT ??_C@_0EC@JFODFBAB@ZwSetInformationFile?5failed?5in?5R@FNODOBFM@
text$s	SEGMENT
??_C@_0EC@JFODFBAB@ZwSetInformationFile?5failed?5in?5R@FNODOBFM@ DB 'ZwSe'
	DB	'tInformationFile failed in RestoreTimeStamp: NTSTATUS 0x%08x', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EE@JIJFFNGM@ZwQueryInformationFile?5failed?5in@FNODOBFM@
text$s	SEGMENT
??_C@_0EE@JIJFFNGM@ZwQueryInformationFile?5failed?5in@FNODOBFM@ DB 'ZwQue'
	DB	'ryInformationFile failed in RestoreTimeStamp: NTSTATUS 0x%08x'
	DB	0aH, 00H					;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _RestoreTimeStamp@4
_TEXT	SEGMENT
_ntStatus$ = -52					; size = 4
_FileBasicInfo$ = -48					; size = 40
_IoStatusBlock$ = -8					; size = 8
_Extension$ = 8						; size = 4
_RestoreTimeStamp@4 PROC				; COMDAT

; 823  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 34	 sub	 esp, 52			; 00000034H

; 824  : 	NTSTATUS ntStatus;
; 825  : 	FILE_BASIC_INFORMATION FileBasicInfo;
; 826  : 	IO_STATUS_BLOCK IoStatusBlock;
; 827  : 
; 828  : 	if (Extension->hDeviceFile != NULL 
; 829  : 		&& Extension->bRawDevice == FALSE 
; 830  : 		&& Extension->bReadOnly == FALSE
; 831  : 		&& Extension->bTimeStampValid)

  00008	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  0000b	83 78 54 00	 cmp	 DWORD PTR [eax+84], 0
  0000f	0f 84 ef 00 00
	00		 je	 $LN5@RestoreTim
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00018	83 b9 94 02 00
	00 00		 cmp	 DWORD PTR [ecx+660], 0
  0001f	0f 85 df 00 00
	00		 jne	 $LN5@RestoreTim
  00025	8b 55 08	 mov	 edx, DWORD PTR _Extension$[ebp]
  00028	83 ba 88 02 00
	00 00		 cmp	 DWORD PTR [edx+648], 0
  0002f	0f 85 cf 00 00
	00		 jne	 $LN5@RestoreTim
  00035	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  00038	83 b8 c8 04 00
	00 00		 cmp	 DWORD PTR [eax+1224], 0
  0003f	0f 84 bf 00 00
	00		 je	 $LN5@RestoreTim

; 832  : 	{
; 833  : 		ntStatus = ZwQueryInformationFile (Extension->hDeviceFile,
; 834  : 			&IoStatusBlock,
; 835  : 			&FileBasicInfo,
; 836  : 			sizeof (FileBasicInfo),
; 837  : 			FileBasicInformation); 

  00045	6a 04		 push	 4
  00047	6a 28		 push	 40			; 00000028H
  00049	8d 4d d0	 lea	 ecx, DWORD PTR _FileBasicInfo$[ebp]
  0004c	51		 push	 ecx
  0004d	8d 55 f8	 lea	 edx, DWORD PTR _IoStatusBlock$[ebp]
  00050	52		 push	 edx
  00051	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  00054	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00057	51		 push	 ecx
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwQueryInformationFile@20
  0005e	89 45 cc	 mov	 DWORD PTR _ntStatus$[ebp], eax

; 838  : 
; 839  : 		if (!NT_SUCCESS (ntStatus))

  00061	83 7d cc 00	 cmp	 DWORD PTR _ntStatus$[ebp], 0
  00065	7d 16		 jge	 SHORT $LN3@RestoreTim

; 840  : 		{
; 841  : 			Dump ("ZwQueryInformationFile failed in RestoreTimeStamp: NTSTATUS 0x%08x\n",
; 842  : 				ntStatus);

  00067	8b 55 cc	 mov	 edx, DWORD PTR _ntStatus$[ebp]
  0006a	52		 push	 edx
  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@JIJFFNGM@ZwQueryInformationFile?5failed?5in@FNODOBFM@
  00070	e8 00 00 00 00	 call	 _DbgPrint
  00075	83 c4 08	 add	 esp, 8

; 843  : 		}
; 844  : 		else

  00078	e9 87 00 00 00	 jmp	 $LN5@RestoreTim
$LN3@RestoreTim:

; 845  : 		{
; 846  : 			FileBasicInfo.CreationTime = Extension->fileCreationTime;

  0007d	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  00080	8b 88 a8 04 00
	00		 mov	 ecx, DWORD PTR [eax+1192]
  00086	8b 90 ac 04 00
	00		 mov	 edx, DWORD PTR [eax+1196]
  0008c	89 4d d0	 mov	 DWORD PTR _FileBasicInfo$[ebp], ecx
  0008f	89 55 d4	 mov	 DWORD PTR _FileBasicInfo$[ebp+4], edx

; 847  : 			FileBasicInfo.LastAccessTime = Extension->fileLastAccessTime;

  00092	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  00095	8b 88 b0 04 00
	00		 mov	 ecx, DWORD PTR [eax+1200]
  0009b	8b 90 b4 04 00
	00		 mov	 edx, DWORD PTR [eax+1204]
  000a1	89 4d d8	 mov	 DWORD PTR _FileBasicInfo$[ebp+8], ecx
  000a4	89 55 dc	 mov	 DWORD PTR _FileBasicInfo$[ebp+12], edx

; 848  : 			FileBasicInfo.LastWriteTime = Extension->fileLastWriteTime;

  000a7	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  000aa	8b 88 b8 04 00
	00		 mov	 ecx, DWORD PTR [eax+1208]
  000b0	8b 90 bc 04 00
	00		 mov	 edx, DWORD PTR [eax+1212]
  000b6	89 4d e0	 mov	 DWORD PTR _FileBasicInfo$[ebp+16], ecx
  000b9	89 55 e4	 mov	 DWORD PTR _FileBasicInfo$[ebp+20], edx

; 849  : 			FileBasicInfo.ChangeTime = Extension->fileLastChangeTime;

  000bc	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  000bf	8b 88 c0 04 00
	00		 mov	 ecx, DWORD PTR [eax+1216]
  000c5	8b 90 c4 04 00
	00		 mov	 edx, DWORD PTR [eax+1220]
  000cb	89 4d e8	 mov	 DWORD PTR _FileBasicInfo$[ebp+24], ecx
  000ce	89 55 ec	 mov	 DWORD PTR _FileBasicInfo$[ebp+28], edx

; 850  : 
; 851  : 			ntStatus = ZwSetInformationFile(
; 852  : 				Extension->hDeviceFile,
; 853  : 				&IoStatusBlock,
; 854  : 				&FileBasicInfo,
; 855  : 				sizeof (FileBasicInfo),
; 856  : 				FileBasicInformation); 

  000d1	6a 04		 push	 4
  000d3	6a 28		 push	 40			; 00000028H
  000d5	8d 45 d0	 lea	 eax, DWORD PTR _FileBasicInfo$[ebp]
  000d8	50		 push	 eax
  000d9	8d 4d f8	 lea	 ecx, DWORD PTR _IoStatusBlock$[ebp]
  000dc	51		 push	 ecx
  000dd	8b 55 08	 mov	 edx, DWORD PTR _Extension$[ebp]
  000e0	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  000e3	50		 push	 eax
  000e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwSetInformationFile@20
  000ea	89 45 cc	 mov	 DWORD PTR _ntStatus$[ebp], eax

; 857  : 
; 858  : 			if (!NT_SUCCESS (ntStatus))

  000ed	83 7d cc 00	 cmp	 DWORD PTR _ntStatus$[ebp], 0
  000f1	7d 11		 jge	 SHORT $LN5@RestoreTim

; 859  : 				Dump ("ZwSetInformationFile failed in RestoreTimeStamp: NTSTATUS 0x%08x\n",ntStatus);

  000f3	8b 4d cc	 mov	 ecx, DWORD PTR _ntStatus$[ebp]
  000f6	51		 push	 ecx
  000f7	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@JFODFBAB@ZwSetInformationFile?5failed?5in?5R@FNODOBFM@
  000fc	e8 00 00 00 00	 call	 _DbgPrint
  00101	83 c4 08	 add	 esp, 8
$LN5@RestoreTim:

; 860  : 		}
; 861  : 	}
; 862  : }

  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c2 04 00	 ret	 4
_RestoreTimeStamp@4 ENDP
_TEXT	ENDS
END
