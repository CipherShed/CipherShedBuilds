; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\home\public\Desktop\projects\ciphershed.build\src\Setup\ComSetup.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0P@GHFPNOJB@bad?5allocation?$AA@		; `string'
PUBLIC	??_C@_07KJLOKDKB@TypeLib?$AA@			; `string'
PUBLIC	??_C@_08KEKAJNJI@Software?$AA@			; `string'
PUBLIC	??_C@_06FDHFNJBJ@SYSTEM?$AA@			; `string'
PUBLIC	??_C@_08LOPHEHKG@SECURITY?$AA@			; `string'
PUBLIC	??_C@_03DDIMFGBA@SAM?$AA@			; `string'
PUBLIC	??_C@_04IHBFOLAC@Mime?$AA@			; `string'
PUBLIC	??_C@_08PPIOJEA@Hardware?$AA@			; `string'
PUBLIC	??_C@_09JKPGEJCH@Interface?$AA@			; `string'
PUBLIC	??_C@_08PICKODJL@FileType?$AA@			; `string'
PUBLIC	??_C@_0BF@HDDNNDFH@Component?5Categories?$AA@	; `string'
PUBLIC	??_C@_05GIBEAPNE@CLSID?$AA@			; `string'
PUBLIC	??_C@_05PDIKPLII@AppID?$AA@			; `string'
PUBLIC	??_C@_06JBKGCNBB@Delete?$AA@			; `string'
PUBLIC	??_C@_08KAAPDIAN@NoRemove?$AA@			; `string'
PUBLIC	??_C@_0M@DBGDLGLL@ForceRemove?$AA@		; `string'
PUBLIC	??_C@_03LAIAPFCB@Val?$AA@			; `string'
PUBLIC	??_C@_01HMGJMAIH@B?$AA@				; `string'
PUBLIC	??_C@_01CKDDGHAB@D?$AA@				; `string'
PUBLIC	??_C@_01PLPBNMEI@M?$AA@				; `string'
PUBLIC	??_C@_01CPLAODJH@S?$AA@				; `string'
PUBLIC	?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A ; ATL::_pAtlAutoThreadModule
PUBLIC	?_Min@?$AtlLimits@H@ATL@@2HB			; ATL::AtlLimits<int>::_Min
PUBLIC	?_Max@?$AtlLimits@H@ATL@@2HB			; ATL::AtlLimits<int>::_Max
PUBLIC	?_Min@?$AtlLimits@I@ATL@@2IB			; ATL::AtlLimits<unsigned int>::_Min
PUBLIC	?_Max@?$AtlLimits@I@ATL@@2IB			; ATL::AtlLimits<unsigned int>::_Max
PUBLIC	?_Min@?$AtlLimits@J@ATL@@2JB			; ATL::AtlLimits<long>::_Min
PUBLIC	?_Max@?$AtlLimits@J@ATL@@2JB			; ATL::AtlLimits<long>::_Max
PUBLIC	?_Min@?$AtlLimits@K@ATL@@2KB			; ATL::AtlLimits<unsigned long>::_Min
PUBLIC	?_Max@?$AtlLimits@K@ATL@@2KB			; ATL::AtlLimits<unsigned long>::_Max
PUBLIC	?_Min@?$AtlLimits@_J@ATL@@2_JB			; ATL::AtlLimits<__int64>::_Min
PUBLIC	?_Max@?$AtlLimits@_J@ATL@@2_JB			; ATL::AtlLimits<__int64>::_Max
PUBLIC	?_Min@?$AtlLimits@_K@ATL@@2_KB			; ATL::AtlLimits<unsigned __int64>::_Min
PUBLIC	?_Max@?$AtlLimits@_K@ATL@@2_KB			; ATL::AtlLimits<unsigned __int64>::_Max
PUBLIC	?m_bInitFailed@CAtlBaseModule@ATL@@2_NA		; ATL::CAtlBaseModule::m_bInitFailed
PUBLIC	?VT@?$CVarTypeInfo@D@ATL@@2GB			; ATL::CVarTypeInfo<char>::VT
PUBLIC	?pmField@?$CVarTypeInfo@D@ATL@@2QQtagVARIANT@@DQ3@ ; ATL::CVarTypeInfo<char>::pmField
PUBLIC	?VT@?$CVarTypeInfo@E@ATL@@2GB			; ATL::CVarTypeInfo<unsigned char>::VT
PUBLIC	?pmField@?$CVarTypeInfo@E@ATL@@2QQtagVARIANT@@EQ3@ ; ATL::CVarTypeInfo<unsigned char>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAD@ATL@@2GB			; ATL::CVarTypeInfo<char *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAD@ATL@@2QQtagVARIANT@@PADQ3@ ; ATL::CVarTypeInfo<char *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAE@ATL@@2GB			; ATL::CVarTypeInfo<unsigned char *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAE@ATL@@2QQtagVARIANT@@PAEQ3@ ; ATL::CVarTypeInfo<unsigned char *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@F@ATL@@2GB			; ATL::CVarTypeInfo<short>::VT
PUBLIC	?pmField@?$CVarTypeInfo@F@ATL@@2QQtagVARIANT@@FQ3@ ; ATL::CVarTypeInfo<short>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAF@ATL@@2GB			; ATL::CVarTypeInfo<short *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAF@ATL@@2QQtagVARIANT@@PAFQ3@ ; ATL::CVarTypeInfo<short *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@G@ATL@@2GB			; ATL::CVarTypeInfo<unsigned short>::VT
PUBLIC	?pmField@?$CVarTypeInfo@G@ATL@@2QQtagVARIANT@@GQ3@ ; ATL::CVarTypeInfo<unsigned short>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAG@ATL@@2GB			; ATL::CVarTypeInfo<unsigned short *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAG@ATL@@2QQtagVARIANT@@PAGQ3@ ; ATL::CVarTypeInfo<unsigned short *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@H@ATL@@2GB			; ATL::CVarTypeInfo<int>::VT
PUBLIC	?pmField@?$CVarTypeInfo@H@ATL@@2QQtagVARIANT@@HQ3@ ; ATL::CVarTypeInfo<int>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAH@ATL@@2GB			; ATL::CVarTypeInfo<int *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAH@ATL@@2QQtagVARIANT@@PAHQ3@ ; ATL::CVarTypeInfo<int *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@I@ATL@@2GB			; ATL::CVarTypeInfo<unsigned int>::VT
PUBLIC	?pmField@?$CVarTypeInfo@I@ATL@@2QQtagVARIANT@@IQ3@ ; ATL::CVarTypeInfo<unsigned int>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAI@ATL@@2GB			; ATL::CVarTypeInfo<unsigned int *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAI@ATL@@2QQtagVARIANT@@PAIQ3@ ; ATL::CVarTypeInfo<unsigned int *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@J@ATL@@2GB			; ATL::CVarTypeInfo<long>::VT
PUBLIC	?pmField@?$CVarTypeInfo@J@ATL@@2QQtagVARIANT@@JQ3@ ; ATL::CVarTypeInfo<long>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAJ@ATL@@2GB			; ATL::CVarTypeInfo<long *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAJ@ATL@@2QQtagVARIANT@@PAJQ3@ ; ATL::CVarTypeInfo<long *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@K@ATL@@2GB			; ATL::CVarTypeInfo<unsigned long>::VT
PUBLIC	?pmField@?$CVarTypeInfo@K@ATL@@2QQtagVARIANT@@KQ3@ ; ATL::CVarTypeInfo<unsigned long>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAK@ATL@@2GB			; ATL::CVarTypeInfo<unsigned long *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAK@ATL@@2QQtagVARIANT@@PAKQ3@ ; ATL::CVarTypeInfo<unsigned long *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@_J@ATL@@2GB			; ATL::CVarTypeInfo<__int64>::VT
PUBLIC	?pmField@?$CVarTypeInfo@_J@ATL@@2QQtagVARIANT@@_JQ3@ ; ATL::CVarTypeInfo<__int64>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PA_J@ATL@@2GB		; ATL::CVarTypeInfo<__int64 *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PA_J@ATL@@2QQtagVARIANT@@PA_JQ3@ ; ATL::CVarTypeInfo<__int64 *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@_K@ATL@@2GB			; ATL::CVarTypeInfo<unsigned __int64>::VT
PUBLIC	?pmField@?$CVarTypeInfo@_K@ATL@@2QQtagVARIANT@@_KQ3@ ; ATL::CVarTypeInfo<unsigned __int64>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PA_K@ATL@@2GB		; ATL::CVarTypeInfo<unsigned __int64 *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PA_K@ATL@@2QQtagVARIANT@@PA_KQ3@ ; ATL::CVarTypeInfo<unsigned __int64 *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@M@ATL@@2GB			; ATL::CVarTypeInfo<float>::VT
PUBLIC	?pmField@?$CVarTypeInfo@M@ATL@@2QQtagVARIANT@@MQ3@ ; ATL::CVarTypeInfo<float>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAM@ATL@@2GB			; ATL::CVarTypeInfo<float *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAM@ATL@@2QQtagVARIANT@@PAMQ3@ ; ATL::CVarTypeInfo<float *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@N@ATL@@2GB			; ATL::CVarTypeInfo<double>::VT
PUBLIC	?pmField@?$CVarTypeInfo@N@ATL@@2QQtagVARIANT@@NQ3@ ; ATL::CVarTypeInfo<double>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAN@ATL@@2GB			; ATL::CVarTypeInfo<double *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAN@ATL@@2QQtagVARIANT@@PANQ3@ ; ATL::CVarTypeInfo<double *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@UtagVARIANT@@@ATL@@2GB	; ATL::CVarTypeInfo<tagVARIANT>::VT
PUBLIC	?VT@?$CVarTypeInfo@PA_W@ATL@@2GB		; ATL::CVarTypeInfo<wchar_t *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PA_W@ATL@@2QQtagVARIANT@@PA_WQ3@ ; ATL::CVarTypeInfo<wchar_t *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAPA_W@ATL@@2GB		; ATL::CVarTypeInfo<wchar_t * *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAPA_W@ATL@@2QQtagVARIANT@@PAPA_WQ3@ ; ATL::CVarTypeInfo<wchar_t * *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2GB	; ATL::CVarTypeInfo<IUnknown *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2QQtagVARIANT@@PAUIUnknown@@Q3@ ; ATL::CVarTypeInfo<IUnknown *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2GB	; ATL::CVarTypeInfo<IUnknown * *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2QQtagVARIANT@@PAPAUIUnknown@@Q3@ ; ATL::CVarTypeInfo<IUnknown * *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2GB	; ATL::CVarTypeInfo<IDispatch *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2QQtagVARIANT@@PAUIDispatch@@Q3@ ; ATL::CVarTypeInfo<IDispatch *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2GB	; ATL::CVarTypeInfo<IDispatch * *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2QQtagVARIANT@@PAPAUIDispatch@@Q3@ ; ATL::CVarTypeInfo<IDispatch * *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@TtagCY@@@ATL@@2GB		; ATL::CVarTypeInfo<tagCY>::VT
PUBLIC	?pmField@?$CVarTypeInfo@TtagCY@@@ATL@@2QQtagVARIANT@@TtagCY@@Q3@ ; ATL::CVarTypeInfo<tagCY>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PATtagCY@@@ATL@@2GB		; ATL::CVarTypeInfo<tagCY *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PATtagCY@@@ATL@@2QQtagVARIANT@@PATtagCY@@Q3@ ; ATL::CVarTypeInfo<tagCY *>::pmField
PUBLIC	_LIBID_ATLLib
PUBLIC	_CLSID_Registrar
PUBLIC	_IID_IRegistrar
PUBLIC	_IID_IAxWinHostWindow
PUBLIC	_IID_IAxWinAmbientDispatch
PUBLIC	_IID_IInternalConnection
PUBLIC	_IID_IDocHostUIHandlerDispatch
PUBLIC	_IID_IAxWinHostWindowLic
PUBLIC	_IID_IAxWinAmbientDispatchEx
PUBLIC	___pobjMapEntryFirst
PUBLIC	___pobjMapEntryLast
PUBLIC	?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA	; ATL::_pPerfRegFunc
PUBLIC	?_pPerfUnRegFunc@ATL@@3P6AJXZA			; ATL::_pPerfUnRegFunc
PUBLIC	?_AtlRegisterPerUser@ATL@@3_NA			; ATL::_AtlRegisterPerUser
PUBLIC	?_pAtlModule@ATL@@3PAVCAtlModule@1@A		; ATL::_pAtlModule
PUBLIC	?m_libid@CAtlModule@ATL@@2U_GUID@@A		; ATL::CAtlModule::m_libid
PUBLIC	?_pModule@ATL@@3PAVCComModule@1@A		; ATL::_pModule
PUBLIC	?ATL_CREATE_OBJECT@CComApartment@ATL@@2IA	; ATL::CComApartment::ATL_CREATE_OBJECT
PUBLIC	?MAX_VALUE@CRegParser@ATL@@1HB			; ATL::CRegParser::MAX_VALUE
PUBLIC	?MAX_TYPE@CRegParser@ATL@@1HB			; ATL::CRegParser::MAX_TYPE
PUBLIC	?rgszNeverDelete@CRegParser@ATL@@1QBQBDB	; ATL::CRegParser::rgszNeverDelete
PUBLIC	?cbNeverDelete@CRegParser@ATL@@1HB		; ATL::CRegParser::cbNeverDelete
PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
;	COMDAT ?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A
_BSS	SEGMENT
?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A DD 01H DUP (?) ; ATL::_pAtlAutoThreadModule
_BSS	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_BSS	SEGMENT
?m_bInitFailed@CAtlBaseModule@ATL@@2_NA DB 01H DUP (?)	; ATL::CAtlBaseModule::m_bInitFailed
_BSS	ENDS
;	COMDAT ?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA
_BSS	SEGMENT
?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA DD 01H DUP (?) ; ATL::_pPerfRegFunc
_BSS	ENDS
;	COMDAT ?_pPerfUnRegFunc@ATL@@3P6AJXZA
_BSS	SEGMENT
?_pPerfUnRegFunc@ATL@@3P6AJXZA DD 01H DUP (?)		; ATL::_pPerfUnRegFunc
_BSS	ENDS
;	COMDAT ?_AtlRegisterPerUser@ATL@@3_NA
_BSS	SEGMENT
?_AtlRegisterPerUser@ATL@@3_NA DB 01H DUP (?)		; ATL::_AtlRegisterPerUser
_BSS	ENDS
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_BSS	SEGMENT
?_pAtlModule@ATL@@3PAVCAtlModule@1@A DD 01H DUP (?)	; ATL::_pAtlModule
_BSS	ENDS
;	COMDAT ?m_libid@CAtlModule@ATL@@2U_GUID@@A
_BSS	SEGMENT
?m_libid@CAtlModule@ATL@@2U_GUID@@A DB 010H DUP (?)	; ATL::CAtlModule::m_libid
_BSS	ENDS
;	COMDAT ?_pModule@ATL@@3PAVCComModule@1@A
_BSS	SEGMENT
?_pModule@ATL@@3PAVCComModule@1@A DD 01H DUP (?)	; ATL::_pModule
_BSS	ENDS
;	COMDAT ?ATL_CREATE_OBJECT@CComApartment@ATL@@2IA
_BSS	SEGMENT
?ATL_CREATE_OBJECT@CComApartment@ATL@@2IA DD 01H DUP (?) ; ATL::CComApartment::ATL_CREATE_OBJECT
_BSS	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
_DATA	ENDS
;	COMDAT ??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
CONST	SEGMENT
??_C@_0P@GHFPNOJB@bad?5allocation?$AA@ DB 'bad allocation', 00H ; `string'
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
;	COMDAT ?cbNeverDelete@CRegParser@ATL@@1HB
CONST	SEGMENT
?cbNeverDelete@CRegParser@ATL@@1HB DD 0cH		; ATL::CRegParser::cbNeverDelete
CONST	ENDS
;	COMDAT ?rgszNeverDelete@CRegParser@ATL@@1QBQBDB
CONST	SEGMENT
?rgszNeverDelete@CRegParser@ATL@@1QBQBDB DD FLAT:??_C@_05PDIKPLII@AppID?$AA@ ; ATL::CRegParser::rgszNeverDelete
	DD	FLAT:??_C@_05GIBEAPNE@CLSID?$AA@
	DD	FLAT:??_C@_0BF@HDDNNDFH@Component?5Categories?$AA@
	DD	FLAT:??_C@_08PICKODJL@FileType?$AA@
	DD	FLAT:??_C@_09JKPGEJCH@Interface?$AA@
	DD	FLAT:??_C@_08PPIOJEA@Hardware?$AA@
	DD	FLAT:??_C@_04IHBFOLAC@Mime?$AA@
	DD	FLAT:??_C@_03DDIMFGBA@SAM?$AA@
	DD	FLAT:??_C@_08LOPHEHKG@SECURITY?$AA@
	DD	FLAT:??_C@_06FDHFNJBJ@SYSTEM?$AA@
	DD	FLAT:??_C@_08KEKAJNJI@Software?$AA@
	DD	FLAT:??_C@_07KJLOKDKB@TypeLib?$AA@
CONST	ENDS
;	COMDAT ??_C@_07KJLOKDKB@TypeLib?$AA@
CONST	SEGMENT
??_C@_07KJLOKDKB@TypeLib?$AA@ DB 'TypeLib', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KEKAJNJI@Software?$AA@
CONST	SEGMENT
??_C@_08KEKAJNJI@Software?$AA@ DB 'Software', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FDHFNJBJ@SYSTEM?$AA@
CONST	SEGMENT
??_C@_06FDHFNJBJ@SYSTEM?$AA@ DB 'SYSTEM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LOPHEHKG@SECURITY?$AA@
CONST	SEGMENT
??_C@_08LOPHEHKG@SECURITY?$AA@ DB 'SECURITY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03DDIMFGBA@SAM?$AA@
CONST	SEGMENT
??_C@_03DDIMFGBA@SAM?$AA@ DB 'SAM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IHBFOLAC@Mime?$AA@
CONST	SEGMENT
??_C@_04IHBFOLAC@Mime?$AA@ DB 'Mime', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PPIOJEA@Hardware?$AA@
CONST	SEGMENT
??_C@_08PPIOJEA@Hardware?$AA@ DB 'Hardware', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JKPGEJCH@Interface?$AA@
CONST	SEGMENT
??_C@_09JKPGEJCH@Interface?$AA@ DB 'Interface', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08PICKODJL@FileType?$AA@
CONST	SEGMENT
??_C@_08PICKODJL@FileType?$AA@ DB 'FileType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HDDNNDFH@Component?5Categories?$AA@
CONST	SEGMENT
??_C@_0BF@HDDNNDFH@Component?5Categories?$AA@ DB 'Component Categories', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05GIBEAPNE@CLSID?$AA@
CONST	SEGMENT
??_C@_05GIBEAPNE@CLSID?$AA@ DB 'CLSID', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PDIKPLII@AppID?$AA@
CONST	SEGMENT
??_C@_05PDIKPLII@AppID?$AA@ DB 'AppID', 00H		; `string'
CONST	ENDS
;	COMDAT ?MAX_TYPE@CRegParser@ATL@@1HB
CONST	SEGMENT
?MAX_TYPE@CRegParser@ATL@@1HB DD 01000H			; ATL::CRegParser::MAX_TYPE
CONST	ENDS
;	COMDAT ?MAX_VALUE@CRegParser@ATL@@1HB
CONST	SEGMENT
?MAX_VALUE@CRegParser@ATL@@1HB DD 01000H		; ATL::CRegParser::MAX_VALUE
CONST	ENDS
;	COMDAT ??_C@_06JBKGCNBB@Delete?$AA@
CONST	SEGMENT
??_C@_06JBKGCNBB@Delete?$AA@ DB 'Delete', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KAAPDIAN@NoRemove?$AA@
CONST	SEGMENT
??_C@_08KAAPDIAN@NoRemove?$AA@ DB 'NoRemove', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DBGDLGLL@ForceRemove?$AA@
CONST	SEGMENT
??_C@_0M@DBGDLGLL@ForceRemove?$AA@ DB 'ForceRemove', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03LAIAPFCB@Val?$AA@
CONST	SEGMENT
??_C@_03LAIAPFCB@Val?$AA@ DB 'Val', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HMGJMAIH@B?$AA@
CONST	SEGMENT
??_C@_01HMGJMAIH@B?$AA@ DB 'B', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01CKDDGHAB@D?$AA@
CONST	SEGMENT
??_C@_01CKDDGHAB@D?$AA@ DB 'D', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01PLPBNMEI@M?$AA@
CONST	SEGMENT
??_C@_01PLPBNMEI@M?$AA@ DB 'M', 00H			; `string'
CONST	ENDS
CONST	SEGMENT
_szStringVal DD	FLAT:??_C@_01CPLAODJH@S?$AA@
_multiszStringVal DD FLAT:??_C@_01PLPBNMEI@M?$AA@
_szDwordVal DD	FLAT:??_C@_01CKDDGHAB@D?$AA@
_szBinaryVal DD	FLAT:??_C@_01HMGJMAIH@B?$AA@
_szValToken DD	FLAT:??_C@_03LAIAPFCB@Val?$AA@
_szForceRemove DD FLAT:??_C@_0M@DBGDLGLL@ForceRemove?$AA@
_szNoRemove DD	FLAT:??_C@_08KAAPDIAN@NoRemove?$AA@
_szDelete DD	FLAT:??_C@_06JBKGCNBB@Delete?$AA@
_LIBID_CipherShedMainCom DD 01770f56cH
	DW	07881H
	DW	04591H
	DB	0a1H
	DB	079H
	DB	079H
	DB	0b8H
	DB	00H
	DB	01cH
	DB	07dH
	DB	042H
_LIBID_CipherShedFormatCom DD 0a7df958cH
	DW	0716H
	DW	049e9H
	DB	08cH
	DB	03eH
	DB	053H
	DB	0a7H
	DB	075H
	DB	079H
	DB	075H
	DB	076H
CONST	ENDS
;	COMDAT ??_C@_01CPLAODJH@S?$AA@
CONST	SEGMENT
??_C@_01CPLAODJH@S?$AA@ DB 'S', 00H			; `string'
CONST	ENDS
;	COMDAT ___pobjMapEntryLast
ATL$__z	SEGMENT
___pobjMapEntryLast DD 00H
ATL$__z	ENDS
;	COMDAT ___pobjMapEntryFirst
ATL$__a	SEGMENT
___pobjMapEntryFirst DD 00H
ATL$__a	ENDS
;	COMDAT _IID_IAxWinAmbientDispatchEx
CONST	SEGMENT
_IID_IAxWinAmbientDispatchEx DD 0b2d0778bH
	DW	0ac99H
	DW	04c58H
	DB	0a5H
	DB	0c8H
	DB	0e7H
	DB	072H
	DB	04eH
	DB	053H
	DB	016H
	DB	0b5H
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindowLic
CONST	SEGMENT
_IID_IAxWinHostWindowLic DD 03935bda8H
	DW	04ed9H
	DW	0495cH
	DB	086H
	DB	050H
	DB	0e0H
	DB	01fH
	DB	0c1H
	DB	0e3H
	DB	08aH
	DB	04bH
CONST	ENDS
;	COMDAT _IID_IDocHostUIHandlerDispatch
CONST	SEGMENT
_IID_IDocHostUIHandlerDispatch DD 0425b5af0H
	DW	065f1H
	DW	011d1H
	DB	096H
	DB	011H
	DB	00H
	DB	00H
	DB	0f8H
	DB	01eH
	DB	0dH
	DB	0dH
CONST	ENDS
;	COMDAT _IID_IInternalConnection
CONST	SEGMENT
_IID_IInternalConnection DD 072ad0770H
	DW	06a9fH
	DW	011d1H
	DB	0bcH
	DB	0ecH
	DB	00H
	DB	060H
	DB	08H
	DB	08fH
	DB	044H
	DB	04eH
CONST	ENDS
;	COMDAT _IID_IAxWinAmbientDispatch
CONST	SEGMENT
_IID_IAxWinAmbientDispatch DD 0b6ea2051H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindow
CONST	SEGMENT
_IID_IAxWinHostWindow DD 0b6ea2050H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT _IID_IRegistrar
CONST	SEGMENT
_IID_IRegistrar DD 044ec053bH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT _CLSID_Registrar
CONST	SEGMENT
_CLSID_Registrar DD 044ec053aH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT _LIBID_ATLLib
CONST	SEGMENT
_LIBID_ATLLib DD 044ec0535H
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PATtagCY@@@ATL@@2QQtagVARIANT@@PATtagCY@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PATtagCY@@@ATL@@2QQtagVARIANT@@PATtagCY@@Q3@ DD 08H ; ATL::CVarTypeInfo<tagCY *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PATtagCY@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PATtagCY@@@ATL@@2GB DW 04006H	; ATL::CVarTypeInfo<tagCY *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@TtagCY@@@ATL@@2QQtagVARIANT@@TtagCY@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@TtagCY@@@ATL@@2QQtagVARIANT@@TtagCY@@Q3@ DD 08H ; ATL::CVarTypeInfo<tagCY>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@TtagCY@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@TtagCY@@@ATL@@2GB DW 06H		; ATL::CVarTypeInfo<tagCY>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2QQtagVARIANT@@PAPAUIDispatch@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2QQtagVARIANT@@PAPAUIDispatch@@Q3@ DD 08H ; ATL::CVarTypeInfo<IDispatch * *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2GB DW 04009H	; ATL::CVarTypeInfo<IDispatch * *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2QQtagVARIANT@@PAUIDispatch@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2QQtagVARIANT@@PAUIDispatch@@Q3@ DD 08H ; ATL::CVarTypeInfo<IDispatch *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2GB DW 09H	; ATL::CVarTypeInfo<IDispatch *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2QQtagVARIANT@@PAPAUIUnknown@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2QQtagVARIANT@@PAPAUIUnknown@@Q3@ DD 08H ; ATL::CVarTypeInfo<IUnknown * *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2GB DW 0400dH	; ATL::CVarTypeInfo<IUnknown * *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2QQtagVARIANT@@PAUIUnknown@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2QQtagVARIANT@@PAUIUnknown@@Q3@ DD 08H ; ATL::CVarTypeInfo<IUnknown *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2GB DW 0dH	; ATL::CVarTypeInfo<IUnknown *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAPA_W@ATL@@2QQtagVARIANT@@PAPA_WQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAPA_W@ATL@@2QQtagVARIANT@@PAPA_WQ3@ DD 08H ; ATL::CVarTypeInfo<wchar_t * *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAPA_W@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAPA_W@ATL@@2GB DW 04008H		; ATL::CVarTypeInfo<wchar_t * *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PA_W@ATL@@2QQtagVARIANT@@PA_WQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PA_W@ATL@@2QQtagVARIANT@@PA_WQ3@ DD 08H ; ATL::CVarTypeInfo<wchar_t *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PA_W@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PA_W@ATL@@2GB DW 08H			; ATL::CVarTypeInfo<wchar_t *>::VT
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@UtagVARIANT@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@UtagVARIANT@@@ATL@@2GB DW 0cH	; ATL::CVarTypeInfo<tagVARIANT>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAN@ATL@@2QQtagVARIANT@@PANQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAN@ATL@@2QQtagVARIANT@@PANQ3@ DD 08H ; ATL::CVarTypeInfo<double *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAN@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAN@ATL@@2GB DW 04005H		; ATL::CVarTypeInfo<double *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@N@ATL@@2QQtagVARIANT@@NQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@N@ATL@@2QQtagVARIANT@@NQ3@ DD 08H ; ATL::CVarTypeInfo<double>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@N@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@N@ATL@@2GB DW 05H			; ATL::CVarTypeInfo<double>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAM@ATL@@2QQtagVARIANT@@PAMQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAM@ATL@@2QQtagVARIANT@@PAMQ3@ DD 08H ; ATL::CVarTypeInfo<float *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAM@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAM@ATL@@2GB DW 04004H		; ATL::CVarTypeInfo<float *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@M@ATL@@2QQtagVARIANT@@MQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@M@ATL@@2QQtagVARIANT@@MQ3@ DD 08H ; ATL::CVarTypeInfo<float>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@M@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@M@ATL@@2GB DW 04H			; ATL::CVarTypeInfo<float>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PA_K@ATL@@2QQtagVARIANT@@PA_KQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PA_K@ATL@@2QQtagVARIANT@@PA_KQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned __int64 *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PA_K@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PA_K@ATL@@2GB DW 04015H		; ATL::CVarTypeInfo<unsigned __int64 *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@_K@ATL@@2QQtagVARIANT@@_KQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@_K@ATL@@2QQtagVARIANT@@_KQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned __int64>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@_K@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@_K@ATL@@2GB DW 015H			; ATL::CVarTypeInfo<unsigned __int64>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PA_J@ATL@@2QQtagVARIANT@@PA_JQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PA_J@ATL@@2QQtagVARIANT@@PA_JQ3@ DD 08H ; ATL::CVarTypeInfo<__int64 *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PA_J@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PA_J@ATL@@2GB DW 04014H		; ATL::CVarTypeInfo<__int64 *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@_J@ATL@@2QQtagVARIANT@@_JQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@_J@ATL@@2QQtagVARIANT@@_JQ3@ DD 08H ; ATL::CVarTypeInfo<__int64>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@_J@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@_J@ATL@@2GB DW 014H			; ATL::CVarTypeInfo<__int64>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAK@ATL@@2QQtagVARIANT@@PAKQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAK@ATL@@2QQtagVARIANT@@PAKQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned long *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAK@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAK@ATL@@2GB DW 04013H		; ATL::CVarTypeInfo<unsigned long *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@K@ATL@@2QQtagVARIANT@@KQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@K@ATL@@2QQtagVARIANT@@KQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned long>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@K@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@K@ATL@@2GB DW 013H			; ATL::CVarTypeInfo<unsigned long>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAJ@ATL@@2QQtagVARIANT@@PAJQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAJ@ATL@@2QQtagVARIANT@@PAJQ3@ DD 08H ; ATL::CVarTypeInfo<long *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAJ@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAJ@ATL@@2GB DW 04003H		; ATL::CVarTypeInfo<long *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@J@ATL@@2QQtagVARIANT@@JQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@J@ATL@@2QQtagVARIANT@@JQ3@ DD 08H ; ATL::CVarTypeInfo<long>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@J@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@J@ATL@@2GB DW 03H			; ATL::CVarTypeInfo<long>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAI@ATL@@2QQtagVARIANT@@PAIQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAI@ATL@@2QQtagVARIANT@@PAIQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned int *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAI@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAI@ATL@@2GB DW 04013H		; ATL::CVarTypeInfo<unsigned int *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@I@ATL@@2QQtagVARIANT@@IQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@I@ATL@@2QQtagVARIANT@@IQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned int>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@I@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@I@ATL@@2GB DW 013H			; ATL::CVarTypeInfo<unsigned int>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAH@ATL@@2QQtagVARIANT@@PAHQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAH@ATL@@2QQtagVARIANT@@PAHQ3@ DD 08H ; ATL::CVarTypeInfo<int *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAH@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAH@ATL@@2GB DW 04003H		; ATL::CVarTypeInfo<int *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@H@ATL@@2QQtagVARIANT@@HQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@H@ATL@@2QQtagVARIANT@@HQ3@ DD 08H ; ATL::CVarTypeInfo<int>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@H@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@H@ATL@@2GB DW 03H			; ATL::CVarTypeInfo<int>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAG@ATL@@2QQtagVARIANT@@PAGQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAG@ATL@@2QQtagVARIANT@@PAGQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned short *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAG@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAG@ATL@@2GB DW 04012H		; ATL::CVarTypeInfo<unsigned short *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@G@ATL@@2QQtagVARIANT@@GQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@G@ATL@@2QQtagVARIANT@@GQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned short>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@G@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@G@ATL@@2GB DW 012H			; ATL::CVarTypeInfo<unsigned short>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAF@ATL@@2QQtagVARIANT@@PAFQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAF@ATL@@2QQtagVARIANT@@PAFQ3@ DD 08H ; ATL::CVarTypeInfo<short *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAF@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAF@ATL@@2GB DW 04002H		; ATL::CVarTypeInfo<short *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@F@ATL@@2QQtagVARIANT@@FQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@F@ATL@@2QQtagVARIANT@@FQ3@ DD 08H ; ATL::CVarTypeInfo<short>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@F@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@F@ATL@@2GB DW 02H			; ATL::CVarTypeInfo<short>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAE@ATL@@2QQtagVARIANT@@PAEQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAE@ATL@@2QQtagVARIANT@@PAEQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned char *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAE@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAE@ATL@@2GB DW 04011H		; ATL::CVarTypeInfo<unsigned char *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAD@ATL@@2QQtagVARIANT@@PADQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAD@ATL@@2QQtagVARIANT@@PADQ3@ DD 08H ; ATL::CVarTypeInfo<char *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAD@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAD@ATL@@2GB DW 04010H		; ATL::CVarTypeInfo<char *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@E@ATL@@2QQtagVARIANT@@EQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@E@ATL@@2QQtagVARIANT@@EQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned char>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@E@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@E@ATL@@2GB DW 011H			; ATL::CVarTypeInfo<unsigned char>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@D@ATL@@2QQtagVARIANT@@DQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@D@ATL@@2QQtagVARIANT@@DQ3@ DD 08H ; ATL::CVarTypeInfo<char>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@D@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@D@ATL@@2GB DW 010H			; ATL::CVarTypeInfo<char>::VT
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@_K@ATL@@2_KB
CONST	SEGMENT
?_Max@?$AtlLimits@_K@ATL@@2_KB DQ ffffffffffffffffH	; ATL::AtlLimits<unsigned __int64>::_Max
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@_K@ATL@@2_KB
CONST	SEGMENT
?_Min@?$AtlLimits@_K@ATL@@2_KB DQ 0000000000000000H	; ATL::AtlLimits<unsigned __int64>::_Min
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@_J@ATL@@2_JB
CONST	SEGMENT
?_Max@?$AtlLimits@_J@ATL@@2_JB DQ 7fffffffffffffffH	; ATL::AtlLimits<__int64>::_Max
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@_J@ATL@@2_JB
CONST	SEGMENT
?_Min@?$AtlLimits@_J@ATL@@2_JB DQ 8000000000000000H	; ATL::AtlLimits<__int64>::_Min
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@K@ATL@@2KB
CONST	SEGMENT
?_Max@?$AtlLimits@K@ATL@@2KB DD 0ffffffffH		; ATL::AtlLimits<unsigned long>::_Max
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@K@ATL@@2KB
CONST	SEGMENT
?_Min@?$AtlLimits@K@ATL@@2KB DD 00H			; ATL::AtlLimits<unsigned long>::_Min
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@J@ATL@@2JB
CONST	SEGMENT
?_Max@?$AtlLimits@J@ATL@@2JB DD 07fffffffH		; ATL::AtlLimits<long>::_Max
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@J@ATL@@2JB
CONST	SEGMENT
?_Min@?$AtlLimits@J@ATL@@2JB DD 080000000H		; ATL::AtlLimits<long>::_Min
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@I@ATL@@2IB
CONST	SEGMENT
?_Max@?$AtlLimits@I@ATL@@2IB DD 0ffffffffH		; ATL::AtlLimits<unsigned int>::_Max
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@I@ATL@@2IB
CONST	SEGMENT
?_Min@?$AtlLimits@I@ATL@@2IB DD 00H			; ATL::AtlLimits<unsigned int>::_Min
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@H@ATL@@2HB
CONST	SEGMENT
?_Max@?$AtlLimits@H@ATL@@2HB DD 07fffffffH		; ATL::AtlLimits<int>::_Max
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@H@ATL@@2HB
CONST	SEGMENT
?_Min@?$AtlLimits@H@ATL@@2HB DD 080000000H		; ATL::AtlLimits<int>::_Min
CONST	ENDS
PUBLIC	??_7Thank_you@Define_the_symbol__ATL_MIXED@@6B@	; Define_the_symbol__ATL_MIXED::Thank_you::`vftable'
PUBLIC	??0Thank_you@Define_the_symbol__ATL_MIXED@@QAE@XZ ; Define_the_symbol__ATL_MIXED::Thank_you::Thank_you
PUBLIC	??_R4Thank_you@Define_the_symbol__ATL_MIXED@@6B@ ; Define_the_symbol__ATL_MIXED::Thank_you::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUThank_you@Define_the_symbol__ATL_MIXED@@@8 ; Define_the_symbol__ATL_MIXED::Thank_you `RTTI Type Descriptor'
PUBLIC	??_R3Thank_you@Define_the_symbol__ATL_MIXED@@8	; Define_the_symbol__ATL_MIXED::Thank_you::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Thank_you@Define_the_symbol__ATL_MIXED@@8	; Define_the_symbol__ATL_MIXED::Thank_you::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Thank_you@Define_the_symbol__ATL_MIXED@@8 ; Define_the_symbol__ATL_MIXED::Thank_you::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?one@Thank_you@Define_the_symbol__ATL_MIXED@@UAEXXZ ; Define_the_symbol__ATL_MIXED::Thank_you::one
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT ??_R1A@?0A@EA@Thank_you@Define_the_symbol__ATL_MIXED@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Thank_you@Define_the_symbol__ATL_MIXED@@8 DD FLAT:??_R0?AUThank_you@Define_the_symbol__ATL_MIXED@@@8 ; Define_the_symbol__ATL_MIXED::Thank_you::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Thank_you@Define_the_symbol__ATL_MIXED@@8
rdata$r	ENDS
;	COMDAT ??_R2Thank_you@Define_the_symbol__ATL_MIXED@@8
rdata$r	SEGMENT
??_R2Thank_you@Define_the_symbol__ATL_MIXED@@8 DD FLAT:??_R1A@?0A@EA@Thank_you@Define_the_symbol__ATL_MIXED@@8 ; Define_the_symbol__ATL_MIXED::Thank_you::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Thank_you@Define_the_symbol__ATL_MIXED@@8
rdata$r	SEGMENT
??_R3Thank_you@Define_the_symbol__ATL_MIXED@@8 DD 00H	; Define_the_symbol__ATL_MIXED::Thank_you::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Thank_you@Define_the_symbol__ATL_MIXED@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUThank_you@Define_the_symbol__ATL_MIXED@@@8
_DATA	SEGMENT
??_R0?AUThank_you@Define_the_symbol__ATL_MIXED@@@8 DD FLAT:??_7type_info@@6B@ ; Define_the_symbol__ATL_MIXED::Thank_you `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUThank_you@Define_the_symbol__ATL_MIXED@@', 00H
_DATA	ENDS
;	COMDAT ??_R4Thank_you@Define_the_symbol__ATL_MIXED@@6B@
rdata$r	SEGMENT
??_R4Thank_you@Define_the_symbol__ATL_MIXED@@6B@ DD 00H	; Define_the_symbol__ATL_MIXED::Thank_you::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUThank_you@Define_the_symbol__ATL_MIXED@@@8
	DD	FLAT:??_R3Thank_you@Define_the_symbol__ATL_MIXED@@8
rdata$r	ENDS
;	COMDAT ??_7Thank_you@Define_the_symbol__ATL_MIXED@@6B@
CONST	SEGMENT
??_7Thank_you@Define_the_symbol__ATL_MIXED@@6B@ DD FLAT:??_R4Thank_you@Define_the_symbol__ATL_MIXED@@6B@ ; Define_the_symbol__ATL_MIXED::Thank_you::`vftable'
	DD	FLAT:?one@Thank_you@Define_the_symbol__ATL_MIXED@@UAEXXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0Thank_you@Define_the_symbol__ATL_MIXED@@QAE@XZ
_TEXT	SEGMENT
??0Thank_you@Define_the_symbol__ATL_MIXED@@QAE@XZ PROC	; Define_the_symbol__ATL_MIXED::Thank_you::Thank_you, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7Thank_you@Define_the_symbol__ATL_MIXED@@6B@
  00008	c3		 ret	 0
??0Thank_you@Define_the_symbol__ATL_MIXED@@QAE@XZ ENDP	; Define_the_symbol__ATL_MIXED::Thank_you::Thank_you
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atldef.h
_TEXT	ENDS
;	COMDAT ?one@Thank_you@Define_the_symbol__ATL_MIXED@@UAEXXZ
_TEXT	SEGMENT
?one@Thank_you@Define_the_symbol__ATL_MIXED@@UAEXXZ PROC ; Define_the_symbol__ATL_MIXED::Thank_you::one, COMDAT
; _this$ = ecx

; 80   : 	struct Thank_you { virtual void one(){} };

  00000	c3		 ret	 0
?one@Thank_you@Define_the_symbol__ATL_MIXED@@UAEXXZ ENDP ; Define_the_symbol__ATL_MIXED::Thank_you::one
_TEXT	ENDS
PUBLIC	_HRESULT_FROM_WIN32
; Function compile flags: /Ogtpy
; File c:\program files\microsoft sdks\windows\v7.1\include\winerror.h
;	COMDAT _HRESULT_FROM_WIN32
_TEXT	SEGMENT
_x$ = 8							; size = 4
_HRESULT_FROM_WIN32 PROC				; COMDAT

; 23841: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _x$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7e 0a		 jle	 SHORT $LN4@HRESULT_FR
  00008	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0000d	0d 00 00 07 80	 or	 eax, -2147024896	; 80070000H
$LN4@HRESULT_FR:
  00012	c3		 ret	 0
_HRESULT_FROM_WIN32 ENDP
_TEXT	ENDS
PUBLIC	__tcsncpy_s
EXTRN	__mbsnbcpy_s:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\tchar.h
;	COMDAT __tcsncpy_s
_TEXT	SEGMENT
__Destination$ = 8					; size = 4
__Destination_size_chars$ = 12				; size = 4
__Source$ = 16						; size = 4
__Count$ = 20						; size = 4
__tcsncpy_s PROC					; COMDAT

; 1513 :     return _mbsnbcpy_s((unsigned char *)_Destination, _Destination_size_chars, (const unsigned char *)_Source,_Count);

  00000	e9 00 00 00 00	 jmp	 __mbsnbcpy_s
__tcsncpy_s ENDP
_TEXT	ENDS
PUBLIC	__tcsstr
EXTRN	__mbsstr:PROC
; Function compile flags: /Ogtpy
;	COMDAT __tcsstr
_TEXT	SEGMENT
__s1$ = 8						; size = 4
__s2$ = 12						; size = 4
__tcsstr PROC						; COMDAT

; 1548 : _Check_return_ __inline _CRPC _tcsstr(_In_ _CPC _s1,_In_ _CPC _s2) {return (_CRPC)_mbsstr((_CPUC)_s1,(_CPUC)_s2);}

  00000	e9 00 00 00 00	 jmp	 __mbsstr
__tcsstr ENDP
_TEXT	ENDS
PUBLIC	?_tcsstr@@YAPADPADPBD@Z				; _tcsstr
; Function compile flags: /Ogtpy
;	COMDAT ?_tcsstr@@YAPADPADPBD@Z
_TEXT	SEGMENT
__S$ = 8						; size = 4
__P$ = 12						; size = 4
?_tcsstr@@YAPADPADPBD@Z PROC				; _tcsstr, COMDAT

; 2006 :         {return ((char *)_tcsstr((const char *)_S, _P)); }

  00000	e9 00 00 00 00	 jmp	 __mbsstr
?_tcsstr@@YAPADPADPBD@Z ENDP				; _tcsstr
_TEXT	ENDS
PUBLIC	??$AtlMultiply@H@ATL@@YAJPAHHH@Z		; ATL::AtlMultiply<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlMultiply@H@ATL@@YAJPAHHH@Z
_TEXT	SEGMENT
_piResult$ = 8						; size = 4
_iLeft$ = 12						; size = 4
_iRight$ = 16						; size = 4
??$AtlMultiply@H@ATL@@YAJPAHHH@Z PROC			; ATL::AtlMultiply<int>, COMDAT

; 126  : 	__int64 i64Result=static_cast<__int64>(iLeft) * static_cast<__int64>(iRight);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _iLeft$[esp-4]
  00004	f7 6c 24 0c	 imul	 DWORD PTR _iRight$[esp-4]

; 127  : 	if(i64Result>INT_MAX || i64Result < INT_MIN)

  00008	8b c8		 mov	 ecx, eax
  0000a	81 c1 00 00 00
	80		 add	 ecx, -2147483648	; 80000000H
  00010	83 d2 00	 adc	 edx, 0
  00013	85 d2		 test	 edx, edx
  00015	77 10		 ja	 SHORT $LN1@AtlMultipl
  00017	72 05		 jb	 SHORT $LN5@AtlMultipl
  00019	83 f9 ff	 cmp	 ecx, -1
  0001c	77 09		 ja	 SHORT $LN1@AtlMultipl
$LN5@AtlMultipl:

; 130  : 	}
; 131  : 	*piResult=static_cast<int _ATL_W64>(i64Result);

  0001e	8b 4c 24 04	 mov	 ecx, DWORD PTR _piResult$[esp-4]
  00022	89 01		 mov	 DWORD PTR [ecx], eax

; 132  : 	return S_OK;

  00024	33 c0		 xor	 eax, eax

; 133  : }

  00026	c3		 ret	 0
$LN1@AtlMultipl:

; 128  : 	{
; 129  : 		return E_INVALIDARG;

  00027	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H

; 133  : }

  0002c	c3		 ret	 0
??$AtlMultiply@H@ATL@@YAJPAHHH@Z ENDP			; ATL::AtlMultiply<int>
_TEXT	ENDS
PUBLIC	??$AtlMultiply@I@ATL@@YAJPAIII@Z		; ATL::AtlMultiply<unsigned int>
; Function compile flags: /Ogtpy
;	COMDAT ??$AtlMultiply@I@ATL@@YAJPAIII@Z
_TEXT	SEGMENT
_piResult$ = 8						; size = 4
_iLeft$ = 12						; size = 4
_iRight$ = 16						; size = 4
??$AtlMultiply@I@ATL@@YAJPAIII@Z PROC			; ATL::AtlMultiply<unsigned int>, COMDAT

; 138  : 	unsigned __int64 i64Result=static_cast<unsigned __int64>(iLeft) * static_cast<unsigned __int64>(iRight);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _iLeft$[esp-4]
  00004	f7 64 24 0c	 mul	 DWORD PTR _iRight$[esp-4]

; 139  : 	if(i64Result>UINT_MAX)

  00008	85 d2		 test	 edx, edx
  0000a	77 05		 ja	 SHORT $LN4@AtlMultipl@2
  0000c	83 f8 ff	 cmp	 eax, -1
  0000f	76 06		 jbe	 SHORT $LN1@AtlMultipl@2
$LN4@AtlMultipl@2:

; 140  : 	{
; 141  : 		return E_INVALIDARG;

  00011	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H

; 145  : }

  00016	c3		 ret	 0
$LN1@AtlMultipl@2:

; 142  : 	}
; 143  : 	*piResult=static_cast<unsigned int _ATL_W64>(i64Result);

  00017	8b 4c 24 04	 mov	 ecx, DWORD PTR _piResult$[esp-4]
  0001b	89 01		 mov	 DWORD PTR [ecx], eax

; 144  : 	return S_OK;

  0001d	33 c0		 xor	 eax, eax

; 145  : }

  0001f	c3		 ret	 0
??$AtlMultiply@I@ATL@@YAJPAIII@Z ENDP			; ATL::AtlMultiply<unsigned int>
_TEXT	ENDS
PUBLIC	??$AtlMultiply@K@ATL@@YAJPAKKK@Z		; ATL::AtlMultiply<unsigned long>
; Function compile flags: /Ogtpy
;	COMDAT ??$AtlMultiply@K@ATL@@YAJPAKKK@Z
_TEXT	SEGMENT
_piResult$ = 8						; size = 4
_iLeft$ = 12						; size = 4
_iRight$ = 16						; size = 4
??$AtlMultiply@K@ATL@@YAJPAKKK@Z PROC			; ATL::AtlMultiply<unsigned long>, COMDAT

; 162  : 	unsigned __int64 i64Result=static_cast<unsigned __int64>(iLeft) * static_cast<unsigned __int64>(iRight);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _iLeft$[esp-4]
  00004	f7 64 24 0c	 mul	 DWORD PTR _iRight$[esp-4]

; 163  : 	if(i64Result>ULONG_MAX)

  00008	85 d2		 test	 edx, edx
  0000a	77 05		 ja	 SHORT $LN4@AtlMultipl@3
  0000c	83 f8 ff	 cmp	 eax, -1
  0000f	76 06		 jbe	 SHORT $LN1@AtlMultipl@3
$LN4@AtlMultipl@3:

; 164  : 	{
; 165  : 		return E_INVALIDARG;

  00011	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H

; 169  : }

  00016	c3		 ret	 0
$LN1@AtlMultipl@3:

; 166  : 	}
; 167  : 	*piResult=static_cast<unsigned long _ATL_W64>(i64Result);

  00017	8b 4c 24 04	 mov	 ecx, DWORD PTR _piResult$[esp-4]
  0001b	89 01		 mov	 DWORD PTR [ecx], eax

; 168  : 	return S_OK;

  0001d	33 c0		 xor	 eax, eax

; 169  : }

  0001f	c3		 ret	 0
??$AtlMultiply@K@ATL@@YAJPAKKK@Z ENDP			; ATL::AtlMultiply<unsigned long>
_TEXT	ENDS
PUBLIC	?AtlCoTaskMemCAlloc@ATL@@YAPAXKK@Z		; ATL::AtlCoTaskMemCAlloc
EXTRN	__imp__CoTaskMemAlloc@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?AtlCoTaskMemCAlloc@ATL@@YAPAXKK@Z
_TEXT	SEGMENT
_nCount$ = 8						; size = 4
_nSize$ = 12						; size = 4
?AtlCoTaskMemCAlloc@ATL@@YAPAXKK@Z PROC			; ATL::AtlCoTaskMemCAlloc, COMDAT

; 197  : 	HRESULT hr;
; 198  : 	ULONG nBytes=0;
; 199  : 	if( FAILED(hr=::ATL::AtlMultiply(&nBytes, nCount, nSize)))

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nCount$[esp-4]
  00004	f7 64 24 08	 mul	 DWORD PTR _nSize$[esp-4]
  00008	85 d2		 test	 edx, edx
  0000a	77 05		 ja	 SHORT $LN8@AtlCoTaskM
  0000c	83 f8 ff	 cmp	 eax, -1
  0000f	76 03		 jbe	 SHORT $LN1@AtlCoTaskM
$LN8@AtlCoTaskM:

; 200  : 	{
; 201  : 		return NULL;

  00011	33 c0		 xor	 eax, eax

; 204  : }

  00013	c3		 ret	 0
$LN1@AtlCoTaskM:

; 202  : 	}
; 203  : 	return ::CoTaskMemAlloc(nBytes);

  00014	50		 push	 eax
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoTaskMemAlloc@4

; 204  : }

  0001b	c3		 ret	 0
?AtlCoTaskMemCAlloc@ATL@@YAPAXKK@Z ENDP			; ATL::AtlCoTaskMemCAlloc
_TEXT	ENDS
PUBLIC	?AtlCoTaskMemRecalloc@ATL@@YAPAXPAXKK@Z		; ATL::AtlCoTaskMemRecalloc
EXTRN	__imp__CoTaskMemRealloc@8:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?AtlCoTaskMemRecalloc@ATL@@YAPAXPAXKK@Z
_TEXT	SEGMENT
_pvMemory$ = 8						; size = 4
_nCount$ = 12						; size = 4
_nSize$ = 16						; size = 4
?AtlCoTaskMemRecalloc@ATL@@YAPAXPAXKK@Z PROC		; ATL::AtlCoTaskMemRecalloc, COMDAT

; 208  : 	HRESULT hr;
; 209  : 	ULONG nBytes=0;
; 210  : 	if( FAILED(hr=::ATL::AtlMultiply(&nBytes, nCount, nSize)))

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _nCount$[esp-4]
  00004	f7 64 24 0c	 mul	 DWORD PTR _nSize$[esp-4]
  00008	85 d2		 test	 edx, edx
  0000a	77 05		 ja	 SHORT $LN8@AtlCoTaskM@2
  0000c	83 f8 ff	 cmp	 eax, -1
  0000f	76 03		 jbe	 SHORT $LN1@AtlCoTaskM@2
$LN8@AtlCoTaskM@2:

; 211  : 	{
; 212  : 		return NULL;

  00011	33 c0		 xor	 eax, eax

; 215  : }

  00013	c3		 ret	 0
$LN1@AtlCoTaskM@2:

; 213  : 	}
; 214  : 	return ::CoTaskMemRealloc(pvMemory, nBytes);

  00014	50		 push	 eax
  00015	8b 44 24 08	 mov	 eax, DWORD PTR _pvMemory$[esp]
  00019	50		 push	 eax
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoTaskMemRealloc@8

; 215  : }

  00020	c3		 ret	 0
?AtlCoTaskMemRecalloc@ATL@@YAPAXPAXKK@Z ENDP		; ATL::AtlCoTaskMemRecalloc
_TEXT	ENDS
PUBLIC	?Allocate@CCRTAllocator@ATL@@SAPAXI@Z		; ATL::CCRTAllocator::Allocate
EXTRN	_malloc:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z PROC		; ATL::CCRTAllocator::Allocate, COMDAT

; 243  : 		return malloc(nBytes);

  00000	e9 00 00 00 00	 jmp	 _malloc
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ENDP		; ATL::CCRTAllocator::Allocate
_TEXT	ENDS
PUBLIC	?Free@CCRTAllocator@ATL@@SAXPAX@Z		; ATL::CCRTAllocator::Free
EXTRN	_free:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?Free@CCRTAllocator@ATL@@SAXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?Free@CCRTAllocator@ATL@@SAXPAX@Z PROC			; ATL::CCRTAllocator::Free, COMDAT

; 248  : 		free(p);

  00000	e9 00 00 00 00	 jmp	 _free
?Free@CCRTAllocator@ATL@@SAXPAX@Z ENDP			; ATL::CCRTAllocator::Free
_TEXT	ENDS
PUBLIC	?_AtlGetConversionACP@ATL@@YGIXZ		; ATL::_AtlGetConversionACP
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlconv.h
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetConversionACP@ATL@@YGIXZ PROC			; ATL::_AtlGetConversionACP, COMDAT

; 104  : #ifdef _CONVERSION_DONT_USE_THREAD_LOCALE
; 105  : 	return CP_ACP;
; 106  : #else
; 107  : 	return CP_THREAD_ACP;

  00000	b8 03 00 00 00	 mov	 eax, 3

; 108  : #endif
; 109  : }

  00005	c3		 ret	 0
?_AtlGetConversionACP@ATL@@YGIXZ ENDP			; ATL::_AtlGetConversionACP
_TEXT	ENDS
PUBLIC	?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z		; AtlA2WHelper
EXTRN	__imp__MultiByteToWideChar@24:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z
_TEXT	SEGMENT
_lpw$ = 8						; size = 4
_lpa$ = 12						; size = 4
_nChars$ = 16						; size = 4
_acp$ = 20						; size = 4
?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z PROC			; AtlA2WHelper, COMDAT

; 536  : {

  00000	56		 push	 esi

; 537  : 	ATLASSERT(lpa != NULL);
; 538  : 	ATLASSERT(lpw != NULL);
; 539  : 	if (lpw == NULL || lpa == NULL)

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _lpw$[esp]
  00005	85 f6		 test	 esi, esi
  00007	74 2c		 je	 SHORT $LN2@AtlA2WHelp
  00009	8b 44 24 0c	 mov	 eax, DWORD PTR _lpa$[esp]
  0000d	85 c0		 test	 eax, eax
  0000f	74 24		 je	 SHORT $LN2@AtlA2WHelp

; 541  : 	// verify that no illegal character present
; 542  : 	// since lpw was allocated based on the size of lpa
; 543  : 	// don't worry about the number of chars
; 544  : 	*lpw = '\0';
; 545  : 	int ret = MultiByteToWideChar(acp, 0, lpa, -1, lpw, nChars);

  00011	8b 54 24 10	 mov	 edx, DWORD PTR _nChars$[esp]
  00015	52		 push	 edx
  00016	56		 push	 esi
  00017	6a ff		 push	 -1
  00019	50		 push	 eax
  0001a	8b 44 24 24	 mov	 eax, DWORD PTR _acp$[esp+16]
  0001e	33 c9		 xor	 ecx, ecx
  00020	51		 push	 ecx
  00021	50		 push	 eax
  00022	66 89 0e	 mov	 WORD PTR [esi], cx
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 546  : 	if(ret == 0)

  0002b	f7 d8		 neg	 eax
  0002d	1b c0		 sbb	 eax, eax
  0002f	23 c6		 and	 eax, esi
  00031	5e		 pop	 esi

; 547  : 	{
; 548  : 		ATLASSERT(FALSE);
; 549  : 		return NULL;
; 550  : 	}		
; 551  : 	return lpw;
; 552  : }

  00032	c2 10 00	 ret	 16			; 00000010H
$LN2@AtlA2WHelp:

; 540  : 		return NULL;

  00035	33 c0		 xor	 eax, eax
  00037	5e		 pop	 esi

; 547  : 	{
; 548  : 		ATLASSERT(FALSE);
; 549  : 		return NULL;
; 550  : 	}		
; 551  : 	return lpw;
; 552  : }

  00038	c2 10 00	 ret	 16			; 00000010H
?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z ENDP			; AtlA2WHelper
_TEXT	ENDS
PUBLIC	?AtlW2AHelper@@YGPADPADPB_WHI@Z			; AtlW2AHelper
EXTRN	__imp__WideCharToMultiByte@32:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?AtlW2AHelper@@YGPADPADPB_WHI@Z
_TEXT	SEGMENT
_lpa$ = 8						; size = 4
_lpw$ = 12						; size = 4
_nChars$ = 16						; size = 4
_acp$ = 20						; size = 4
?AtlW2AHelper@@YGPADPADPB_WHI@Z PROC			; AtlW2AHelper, COMDAT

; 555  : {

  00000	56		 push	 esi

; 556  : 	ATLASSERT(lpw != NULL);
; 557  : 	ATLASSERT(lpa != NULL);
; 558  : 	if (lpa == NULL || lpw == NULL)

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _lpa$[esp]
  00005	85 f6		 test	 esi, esi
  00007	74 2f		 je	 SHORT $LN2@AtlW2AHelp
  00009	8b 44 24 0c	 mov	 eax, DWORD PTR _lpw$[esp]
  0000d	85 c0		 test	 eax, eax
  0000f	74 27		 je	 SHORT $LN2@AtlW2AHelp

; 560  : 	// verify that no illegal character present
; 561  : 	// since lpa was allocated based on the size of lpw
; 562  : 	// don't worry about the number of chars
; 563  : 	*lpa = '\0';
; 564  : 	int ret = WideCharToMultiByte(acp, 0, lpw, -1, lpa, nChars, NULL, NULL);

  00011	8b 4c 24 10	 mov	 ecx, DWORD PTR _nChars$[esp]
  00015	8b 54 24 14	 mov	 edx, DWORD PTR _acp$[esp]
  00019	6a 00		 push	 0
  0001b	6a 00		 push	 0
  0001d	51		 push	 ecx
  0001e	56		 push	 esi
  0001f	6a ff		 push	 -1
  00021	50		 push	 eax
  00022	6a 00		 push	 0
  00024	52		 push	 edx
  00025	c6 06 00	 mov	 BYTE PTR [esi], 0
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 565  : 	if(ret == 0)

  0002e	f7 d8		 neg	 eax
  00030	1b c0		 sbb	 eax, eax
  00032	23 c6		 and	 eax, esi
  00034	5e		 pop	 esi

; 566  : 	{
; 567  : 		ATLASSERT(FALSE);
; 568  : 		return NULL;
; 569  : 	}
; 570  : 	return lpa;
; 571  : }

  00035	c2 10 00	 ret	 16			; 00000010H
$LN2@AtlW2AHelp:

; 559  : 		return NULL;

  00038	33 c0		 xor	 eax, eax
  0003a	5e		 pop	 esi

; 566  : 	{
; 567  : 		ATLASSERT(FALSE);
; 568  : 		return NULL;
; 569  : 	}
; 570  : 	return lpa;
; 571  : }

  0003b	c2 10 00	 ret	 16			; 00000010H
?AtlW2AHelper@@YGPADPADPB_WHI@Z ENDP			; AtlW2AHelper
_TEXT	ENDS
PUBLIC	?ocslen@@YAHPB_W@Z				; ocslen
EXTRN	__imp__lstrlenW@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?ocslen@@YAHPB_W@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?ocslen@@YAHPB_W@Z PROC					; ocslen, COMDAT

; 689  : 	inline int ocslen(_In_z_ LPCOLESTR x) throw() { return lstrlenW(x); }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _x$[esp-4]
  00004	50		 push	 eax
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0000b	c3		 ret	 0
?ocslen@@YAHPB_W@Z ENDP					; ocslen
_TEXT	ENDS
PUBLIC	?_AtlRaiseException@ATL@@YAXKK@Z		; ATL::_AtlRaiseException
EXTRN	__imp__RaiseException@16:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ?_AtlRaiseException@ATL@@YAXKK@Z
_TEXT	SEGMENT
_dwExceptionCode$ = 8					; size = 4
_dwExceptionFlags$ = 12					; size = 4
?_AtlRaiseException@ATL@@YAXKK@Z PROC			; ATL::_AtlRaiseException, COMDAT

; 29   : 	RaiseException( dwExceptionCode, dwExceptionFlags, 0, NULL );

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _dwExceptionFlags$[esp-4]
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR _dwExceptionCode$[esp-4]
  00008	6a 00		 push	 0
  0000a	6a 00		 push	 0
  0000c	50		 push	 eax
  0000d	51		 push	 ecx
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RaiseException@16

; 30   : }

  00014	c3		 ret	 0
?_AtlRaiseException@ATL@@YAXKK@Z ENDP			; ATL::_AtlRaiseException
_TEXT	ENDS
PUBLIC	??0CAtlException@ATL@@QAE@J@Z			; ATL::CAtlException::CAtlException
; Function compile flags: /Ogtpy
;	COMDAT ??0CAtlException@ATL@@QAE@J@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
??0CAtlException@ATL@@QAE@J@Z PROC			; ATL::CAtlException::CAtlException, COMDAT
; _this$ = ecx

; 42   : 	{

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR _hr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 43   : 	}

  00008	c2 04 00	 ret	 4
??0CAtlException@ATL@@QAE@J@Z ENDP			; ATL::CAtlException::CAtlException
_TEXT	ENDS
PUBLIC	__TI1?AVCAtlException@ATL@@
PUBLIC	?AtlThrowImpl@ATL@@YGXJ@Z			; ATL::AtlThrowImpl
PUBLIC	__CTA1?AVCAtlException@ATL@@
PUBLIC	__CT??_R0?AVCAtlException@ATL@@@84
PUBLIC	??_R0?AVCAtlException@ATL@@@8			; ATL::CAtlException `RTTI Type Descriptor'
EXTRN	__CxxThrowException@8:PROC
;	COMDAT ??_R0?AVCAtlException@ATL@@@8
_DATA	SEGMENT
??_R0?AVCAtlException@ATL@@@8 DD FLAT:??_7type_info@@6B@ ; ATL::CAtlException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCAtlException@ATL@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVCAtlException@ATL@@@84
xdata$x	SEGMENT
__CT??_R0?AVCAtlException@ATL@@@84 DD 00H
	DD	FLAT:??_R0?AVCAtlException@ATL@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT __CTA1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__CTA1?AVCAtlException@ATL@@ DD 01H
	DD	FLAT:__CT??_R0?AVCAtlException@ATL@@@84
xdata$x	ENDS
;	COMDAT __TI1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__TI1?AVCAtlException@ATL@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1?AVCAtlException@ATL@@
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?AtlThrowImpl@ATL@@YGXJ@Z
_TEXT	SEGMENT
$T110455 = 8						; size = 4
_hr$ = 8						; size = 4
?AtlThrowImpl@ATL@@YGXJ@Z PROC				; ATL::AtlThrowImpl, COMDAT

; 64   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
; 65   : #ifdef _AFX
; 66   : 	if( hr == E_OUTOFMEMORY )
; 67   : 	{
; 68   : 		AfxThrowMemoryException();
; 69   : 	}
; 70   : 	else
; 71   : 	{
; 72   : 		AfxThrowOleException( hr );
; 73   : 	}
; 74   : #else
; 75   : 	throw CAtlException( hr );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _hr$[esp-4]
  00004	68 00 00 00 00	 push	 OFFSET __TI1?AVCAtlException@ATL@@
  00009	8d 4c 24 08	 lea	 ecx, DWORD PTR $T110455[esp]
  0000d	51		 push	 ecx
  0000e	89 44 24 0c	 mov	 DWORD PTR $T110455[esp+4], eax
  00012	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN5@AtlThrowIm:
  00017	cc		 int	 3
?AtlThrowImpl@ATL@@YGXJ@Z ENDP				; ATL::AtlThrowImpl
_TEXT	ENDS
PUBLIC	?AtlCrtErrorCheck@ATL@@YAHH@Z			; ATL::AtlCrtErrorCheck
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlchecked.h
;	COMDAT ?AtlCrtErrorCheck@ATL@@YAHH@Z
_TEXT	SEGMENT
_nError$ = 8						; size = 4
?AtlCrtErrorCheck@ATL@@YAHH@Z PROC			; ATL::AtlCrtErrorCheck, COMDAT

; 32   : 	switch(nError)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nError$[esp-4]
  00004	83 f8 50	 cmp	 eax, 80			; 00000050H
  00007	77 22		 ja	 SHORT $LN1@AtlCrtErro
  00009	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN9@AtlCrtErro[eax]
  00010	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN11@AtlCrtErro[ecx*4]
$LN4@AtlCrtErro:

; 33   : 	{
; 34   : 	case ENOMEM:
; 35   : 		AtlThrow(E_OUTOFMEMORY);

  00017	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  0001c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN3@AtlCrtErro:

; 36   : 		break;
; 37   : 	case EINVAL:
; 38   : 	case ERANGE:
; 39   : 		AtlThrow(E_INVALIDARG);

  00021	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00026	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN1@AtlCrtErro:

; 40   : 		break;
; 41   : 	case 0:
; 42   : 	case STRUNCATE:
; 43   : 		break;
; 44   : 	default:
; 45   : 		AtlThrow(E_FAIL);

  0002b	68 05 40 00 80	 push	 -2147467259		; 80004005H
  00030	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN7@AtlCrtErro:

; 46   : 		break;
; 47   : 	}
; 48   : 	return nError;
; 49   : }

  00035	c3		 ret	 0
$LN10@AtlCrtErro:
  00036	8b ff		 npad	 2
$LN11@AtlCrtErro:
  00038	00 00 00 00	 DD	 $LN7@AtlCrtErro
  0003c	00 00 00 00	 DD	 $LN4@AtlCrtErro
  00040	00 00 00 00	 DD	 $LN3@AtlCrtErro
  00044	00 00 00 00	 DD	 $LN1@AtlCrtErro
$LN9@AtlCrtErro:
  00048	00		 DB	 0
  00049	03		 DB	 3
  0004a	03		 DB	 3
  0004b	03		 DB	 3
  0004c	03		 DB	 3
  0004d	03		 DB	 3
  0004e	03		 DB	 3
  0004f	03		 DB	 3
  00050	03		 DB	 3
  00051	03		 DB	 3
  00052	03		 DB	 3
  00053	03		 DB	 3
  00054	01		 DB	 1
  00055	03		 DB	 3
  00056	03		 DB	 3
  00057	03		 DB	 3
  00058	03		 DB	 3
  00059	03		 DB	 3
  0005a	03		 DB	 3
  0005b	03		 DB	 3
  0005c	03		 DB	 3
  0005d	03		 DB	 3
  0005e	02		 DB	 2
  0005f	03		 DB	 3
  00060	03		 DB	 3
  00061	03		 DB	 3
  00062	03		 DB	 3
  00063	03		 DB	 3
  00064	03		 DB	 3
  00065	03		 DB	 3
  00066	03		 DB	 3
  00067	03		 DB	 3
  00068	03		 DB	 3
  00069	03		 DB	 3
  0006a	02		 DB	 2
  0006b	03		 DB	 3
  0006c	03		 DB	 3
  0006d	03		 DB	 3
  0006e	03		 DB	 3
  0006f	03		 DB	 3
  00070	03		 DB	 3
  00071	03		 DB	 3
  00072	03		 DB	 3
  00073	03		 DB	 3
  00074	03		 DB	 3
  00075	03		 DB	 3
  00076	03		 DB	 3
  00077	03		 DB	 3
  00078	03		 DB	 3
  00079	03		 DB	 3
  0007a	03		 DB	 3
  0007b	03		 DB	 3
  0007c	03		 DB	 3
  0007d	03		 DB	 3
  0007e	03		 DB	 3
  0007f	03		 DB	 3
  00080	03		 DB	 3
  00081	03		 DB	 3
  00082	03		 DB	 3
  00083	03		 DB	 3
  00084	03		 DB	 3
  00085	03		 DB	 3
  00086	03		 DB	 3
  00087	03		 DB	 3
  00088	03		 DB	 3
  00089	03		 DB	 3
  0008a	03		 DB	 3
  0008b	03		 DB	 3
  0008c	03		 DB	 3
  0008d	03		 DB	 3
  0008e	03		 DB	 3
  0008f	03		 DB	 3
  00090	03		 DB	 3
  00091	03		 DB	 3
  00092	03		 DB	 3
  00093	03		 DB	 3
  00094	03		 DB	 3
  00095	03		 DB	 3
  00096	03		 DB	 3
  00097	03		 DB	 3
  00098	00		 DB	 0
?AtlCrtErrorCheck@ATL@@YAHH@Z ENDP			; ATL::AtlCrtErrorCheck
_TEXT	ENDS
PUBLIC	?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z		; ATL::Checked::memcpy_s
EXTRN	_memcpy_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S1max$ = 12						; size = 4
__S2$ = 16						; size = 4
__N$ = 20						; size = 4
?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z PROC		; ATL::Checked::memcpy_s, COMDAT

; 65   : 	ATLMFC_CRT_ERRORCHECK(::memcpy_s(_S1, _S1max, _S2, _N));

  00000	8b 44 24 10	 mov	 eax, DWORD PTR __N$[esp-4]
  00004	8b 4c 24 0c	 mov	 ecx, DWORD PTR __S2$[esp-4]
  00008	8b 54 24 08	 mov	 edx, DWORD PTR __S1max$[esp-4]
  0000c	50		 push	 eax
  0000d	8b 44 24 08	 mov	 eax, DWORD PTR __S1$[esp]
  00011	51		 push	 ecx
  00012	52		 push	 edx
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _memcpy_s
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ?AtlCrtErrorCheck@ATL@@YAHH@Z ; ATL::AtlCrtErrorCheck
  0001f	83 c4 14	 add	 esp, 20			; 00000014H

; 66   : }

  00022	c3		 ret	 0
?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z ENDP		; ATL::Checked::memcpy_s
_TEXT	ENDS
PUBLIC	?tcsncpy_s@Checked@ATL@@YAHPADIPBDI@Z		; ATL::Checked::tcsncpy_s
; Function compile flags: /Ogtpy
;	COMDAT ?tcsncpy_s@Checked@ATL@@YAHPADIPBDI@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__SizeInChars$ = 12					; size = 4
__Source$ = 16						; size = 4
__Count$ = 20						; size = 4
?tcsncpy_s@Checked@ATL@@YAHPADIPBDI@Z PROC		; ATL::Checked::tcsncpy_s, COMDAT

; 105  : 	return ATLMFC_CRT_ERRORCHECK(::_tcsncpy_s(_Dest, _SizeInChars, _Source,_Count));	

  00000	8b 44 24 10	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Source$[esp-4]
  00008	8b 54 24 08	 mov	 edx, DWORD PTR __SizeInChars$[esp-4]
  0000c	50		 push	 eax
  0000d	8b 44 24 08	 mov	 eax, DWORD PTR __Dest$[esp]
  00011	51		 push	 ecx
  00012	52		 push	 edx
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 __mbsnbcpy_s
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ?AtlCrtErrorCheck@ATL@@YAHH@Z ; ATL::AtlCrtErrorCheck
  0001f	83 c4 14	 add	 esp, 20			; 00000014H

; 106  : }

  00022	c3		 ret	 0
?tcsncpy_s@Checked@ATL@@YAHPADIPBDI@Z ENDP		; ATL::Checked::tcsncpy_s
_TEXT	ENDS
PUBLIC	??0CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::CComCriticalSection
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlcore.h
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CComCriticalSection@ATL@@QAE@XZ PROC			; ATL::CComCriticalSection::CComCriticalSection, COMDAT
; _this$ = ecx

; 79   : 	CComCriticalSection() throw()

  00000	8b c1		 mov	 eax, ecx

; 80   : 	{
; 81   : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000c	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0000f	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00012	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 82   : 	}

  00015	c3		 ret	 0
??0CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::CComCriticalSection
_TEXT	ENDS
PUBLIC	??1CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::~CComCriticalSection
; Function compile flags: /Ogtpy
;	COMDAT ??1CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CComCriticalSection@ATL@@QAE@XZ PROC			; ATL::CComCriticalSection::~CComCriticalSection, COMDAT
; _this$ = ecx

; 85   : 	}

  00000	c3		 ret	 0
??1CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::~CComCriticalSection
_TEXT	ENDS
PUBLIC	?Lock@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Lock
EXTRN	__imp__EnterCriticalSection@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?Lock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
?Lock@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Lock, COMDAT
; _this$ = ecx

; 88   : 		EnterCriticalSection(&m_sec);

  00000	51		 push	 ecx
  00001	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 89   : 		return S_OK;

  00007	33 c0		 xor	 eax, eax

; 90   : 	}

  00009	c3		 ret	 0
?Lock@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Lock
_TEXT	ENDS
PUBLIC	?Unlock@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Unlock
EXTRN	__imp__LeaveCriticalSection@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
?Unlock@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Unlock, COMDAT
; _this$ = ecx

; 93   : 		LeaveCriticalSection(&m_sec);

  00000	51		 push	 ecx
  00001	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 94   : 		return S_OK;

  00007	33 c0		 xor	 eax, eax

; 95   : 	}

  00009	c3		 ret	 0
?Unlock@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Unlock
_TEXT	ENDS
PUBLIC	?Init@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Init
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__except_handler4:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?Init@CComCriticalSection@ATL@@QAEJXZ DD 0fffffffeH
	DD	00H
	DD	0ffffffd4H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN5@Init
	DD	FLAT:$LN6@Init
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?Init@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
_hRes$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
?Init@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Init, COMDAT
; _this$ = ecx

; 97   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?Init@CComCriticalSection@ATL@@QAEJXZ
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	50		 push	 eax
  00027	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00030	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp

; 98   : 		HRESULT hRes = E_FAIL;
; 99   : 		__try

  00033	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 100  : 		{
; 101  : 			InitializeCriticalSection(&m_sec);

  0003a	51		 push	 ecx
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 102  : 			hRes = S_OK;

  00041	33 c0		 xor	 eax, eax

; 103  : 		}

  00043	eb 1c		 jmp	 SHORT $LN9@Init
$LN5@Init:

; 104  : 		// structured exception may be raised in low memory situations
; 105  : 		__except(STATUS_NO_MEMORY == GetExceptionCode())

  00045	8b 45 ec	 mov	 eax, DWORD PTR __$SEHRec$[ebp+4]
  00048	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004c	33 d2		 xor	 edx, edx
  0004e	3d 17 00 00 c0	 cmp	 eax, -1073741801	; c0000017H
  00053	0f 94 c2	 sete	 dl
  00056	8b c2		 mov	 eax, edx
$LN7@Init:
  00058	c3		 ret	 0
$LN6@Init:
  00059	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 106  : 		{			
; 107  : 			hRes = E_OUTOFMEMORY;		

  0005c	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
$LN9@Init:
  00061	89 45 e4	 mov	 DWORD PTR _hRes$[ebp], eax

; 108  : 		}

  00064	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH

; 109  : 		return hRes;
; 110  : 	}

  0006b	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
?Init@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Init
_TEXT	ENDS
PUBLIC	?Term@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Term
EXTRN	__imp__DeleteCriticalSection@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?Term@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
?Term@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Term, COMDAT
; _this$ = ecx

; 114  : 		DeleteCriticalSection(&m_sec);

  00000	51		 push	 ecx
  00001	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 115  : 		return S_OK;

  00007	33 c0		 xor	 eax, eax

; 116  : 	}	

  00009	c3		 ret	 0
?Term@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Term
_TEXT	ENDS
PUBLIC	??0CComSafeDeleteCriticalSection@ATL@@QAE@XZ	; ATL::CComSafeDeleteCriticalSection::CComSafeDeleteCriticalSection
; Function compile flags: /Ogtpy
;	COMDAT ??0CComSafeDeleteCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CComSafeDeleteCriticalSection@ATL@@QAE@XZ PROC	; ATL::CComSafeDeleteCriticalSection::CComSafeDeleteCriticalSection, COMDAT
; _this$ = ecx

; 142  : 	{

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000c	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0000f	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00012	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00015	88 48 18	 mov	 BYTE PTR [eax+24], cl

; 143  : 	}

  00018	c3		 ret	 0
??0CComSafeDeleteCriticalSection@ATL@@QAE@XZ ENDP	; ATL::CComSafeDeleteCriticalSection::CComSafeDeleteCriticalSection
_TEXT	ENDS
PUBLIC	??1CComSafeDeleteCriticalSection@ATL@@QAE@XZ	; ATL::CComSafeDeleteCriticalSection::~CComSafeDeleteCriticalSection
; Function compile flags: /Ogtpy
;	COMDAT ??1CComSafeDeleteCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CComSafeDeleteCriticalSection@ATL@@QAE@XZ PROC	; ATL::CComSafeDeleteCriticalSection::~CComSafeDeleteCriticalSection, COMDAT
; _this$ = ecx

; 147  : 		if (!m_bInitialized)

  00000	80 79 18 00	 cmp	 BYTE PTR [ecx+24], 0
  00004	74 0b		 je	 SHORT $LN4@CComSafeDe

; 148  : 		{
; 149  : 			return;
; 150  : 		}
; 151  : 		m_bInitialized = false;
; 152  : 		CComCriticalSection::Term();

  00006	51		 push	 ecx
  00007	c6 41 18 00	 mov	 BYTE PTR [ecx+24], 0
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
$LN4@CComSafeDe:

; 153  : 	}

  00011	c3		 ret	 0
??1CComSafeDeleteCriticalSection@ATL@@QAE@XZ ENDP	; ATL::CComSafeDeleteCriticalSection::~CComSafeDeleteCriticalSection
_TEXT	ENDS
PUBLIC	?Init@CComSafeDeleteCriticalSection@ATL@@QAEJXZ	; ATL::CComSafeDeleteCriticalSection::Init
; Function compile flags: /Ogtpy
;	COMDAT ?Init@CComSafeDeleteCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
?Init@CComSafeDeleteCriticalSection@ATL@@QAEJXZ PROC	; ATL::CComSafeDeleteCriticalSection::Init, COMDAT
; _this$ = ecx

; 156  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 157  : 		ATLASSERT( !m_bInitialized );
; 158  : 		HRESULT hr = CComCriticalSection::Init();

  00003	e8 00 00 00 00	 call	 ?Init@CComCriticalSection@ATL@@QAEJXZ ; ATL::CComCriticalSection::Init

; 159  : 		if (SUCCEEDED(hr))

  00008	85 c0		 test	 eax, eax
  0000a	7c 04		 jl	 SHORT $LN1@Init@2

; 160  : 		{
; 161  : 			m_bInitialized = true;

  0000c	c6 46 18 01	 mov	 BYTE PTR [esi+24], 1
$LN1@Init@2:
  00010	5e		 pop	 esi

; 162  : 		}
; 163  : 		return hr;
; 164  : 	}

  00011	c3		 ret	 0
?Init@CComSafeDeleteCriticalSection@ATL@@QAEJXZ ENDP	; ATL::CComSafeDeleteCriticalSection::Init
_TEXT	ENDS
PUBLIC	?Lock@CComSafeDeleteCriticalSection@ATL@@QAEJXZ	; ATL::CComSafeDeleteCriticalSection::Lock
; Function compile flags: /Ogtpy
;	COMDAT ?Lock@CComSafeDeleteCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
?Lock@CComSafeDeleteCriticalSection@ATL@@QAEJXZ PROC	; ATL::CComSafeDeleteCriticalSection::Lock, COMDAT
; _this$ = ecx

; 178  : 		// CComSafeDeleteCriticalSection::Init or CComAutoDeleteCriticalSection::Init
; 179  : 		// not called or failed.
; 180  : 		// m_critsec member of CComObjectRootEx is now of type 
; 181  : 		// CComAutoDeleteCriticalSection. It has to be initialized
; 182  : 		// by calling CComObjectRootEx::_AtlInitialConstruct
; 183  : 		ATLASSUME(m_bInitialized);
; 184  : 		return CComCriticalSection::Lock();

  00000	51		 push	 ecx
  00001	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  00007	33 c0		 xor	 eax, eax

; 185  : 	}

  00009	c3		 ret	 0
?Lock@CComSafeDeleteCriticalSection@ATL@@QAEJXZ ENDP	; ATL::CComSafeDeleteCriticalSection::Lock
_TEXT	ENDS
PUBLIC	?AtlHresultFromLastError@ATL@@YAJXZ		; ATL::AtlHresultFromLastError
EXTRN	__imp__GetLastError@0:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ?AtlHresultFromLastError@ATL@@YAJXZ
_TEXT	SEGMENT
?AtlHresultFromLastError@ATL@@YAJXZ PROC		; ATL::AtlHresultFromLastError, COMDAT

; 33   : 	DWORD dwErr = ::GetLastError();

  00000	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 34   : 	return HRESULT_FROM_WIN32(dwErr);

  00006	85 c0		 test	 eax, eax
  00008	7e 0a		 jle	 SHORT $LN6@AtlHresult
  0000a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0000f	0d 00 00 07 80	 or	 eax, -2147024896	; 80070000H
$LN6@AtlHresult:

; 35   : }

  00014	c3		 ret	 0
?AtlHresultFromLastError@ATL@@YAJXZ ENDP		; ATL::AtlHresultFromLastError
_TEXT	ENDS
PUBLIC	?AtlHresultFromWin32@ATL@@YAJK@Z		; ATL::AtlHresultFromWin32
; Function compile flags: /Ogtpy
;	COMDAT ?AtlHresultFromWin32@ATL@@YAJK@Z
_TEXT	SEGMENT
_nError$ = 8						; size = 4
?AtlHresultFromWin32@ATL@@YAJK@Z PROC			; ATL::AtlHresultFromWin32, COMDAT

; 39   : 	return( HRESULT_FROM_WIN32( nError ) );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nError$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7e 0a		 jle	 SHORT $LN6@AtlHresult@2
  00008	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0000d	0d 00 00 07 80	 or	 eax, -2147024896	; 80070000H
$LN6@AtlHresult@2:

; 40   : }

  00012	c3		 ret	 0
?AtlHresultFromWin32@ATL@@YAJK@Z ENDP			; ATL::AtlHresultFromWin32
_TEXT	ENDS
PUBLIC	??0CRegKey@ATL@@QAE@XZ				; ATL::CRegKey::CRegKey
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??0CRegKey@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CRegKey@ATL@@QAE@XZ PROC				; ATL::CRegKey::CRegKey, COMDAT
; _this$ = ecx

; 5190 : {

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00008	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 5191 : }

  0000f	c3		 ret	 0
??0CRegKey@ATL@@QAE@XZ ENDP				; ATL::CRegKey::CRegKey
_TEXT	ENDS
PUBLIC	??BCRegKey@ATL@@QBEPAUHKEY__@@XZ		; ATL::CRegKey::operator HKEY__ *
; Function compile flags: /Ogtpy
;	COMDAT ??BCRegKey@ATL@@QBEPAUHKEY__@@XZ
_TEXT	SEGMENT
??BCRegKey@ATL@@QBEPAUHKEY__@@XZ PROC			; ATL::CRegKey::operator HKEY__ *, COMDAT
; _this$ = ecx

; 5219 : {return m_hKey;}

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	c3		 ret	 0
??BCRegKey@ATL@@QBEPAUHKEY__@@XZ ENDP			; ATL::CRegKey::operator HKEY__ *
_TEXT	ENDS
PUBLIC	?Detach@CRegKey@ATL@@QAEPAUHKEY__@@XZ		; ATL::CRegKey::Detach
; Function compile flags: /Ogtpy
;	COMDAT ?Detach@CRegKey@ATL@@QAEPAUHKEY__@@XZ
_TEXT	SEGMENT
?Detach@CRegKey@ATL@@QAEPAUHKEY__@@XZ PROC		; ATL::CRegKey::Detach, COMDAT
; _this$ = ecx

; 5223 : 	HKEY hKey = m_hKey;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 5224 : 	m_hKey = NULL;

  00002	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 5225 : 	m_samWOW64 = 0;

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 5226 : 	return hKey;
; 5227 : }

  0000f	c3		 ret	 0
?Detach@CRegKey@ATL@@QAEPAUHKEY__@@XZ ENDP		; ATL::CRegKey::Detach
_TEXT	ENDS
PUBLIC	?Attach@CRegKey@ATL@@QAEXPAUHKEY__@@@Z		; ATL::CRegKey::Attach
; Function compile flags: /Ogtpy
;	COMDAT ?Attach@CRegKey@ATL@@QAEXPAUHKEY__@@@Z
_TEXT	SEGMENT
_hKey$ = 8						; size = 4
?Attach@CRegKey@ATL@@QAEXPAUHKEY__@@@Z PROC		; ATL::CRegKey::Attach, COMDAT
; _this$ = ecx

; 5231 : 	ATLASSUME(m_hKey == NULL);
; 5232 : 	m_hKey = hKey;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _hKey$[esp-4]
  00004	89 01		 mov	 DWORD PTR [ecx], eax

; 5233 : 	m_samWOW64 = 0;

  00006	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 5234 : }

  0000d	c2 04 00	 ret	 4
?Attach@CRegKey@ATL@@QAEXPAUHKEY__@@@Z ENDP		; ATL::CRegKey::Attach
_TEXT	ENDS
PUBLIC	?pfnRegDeleteKeyEx@?5??DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z@4P6GJPAUHKEY__@@0KK@ZA ; `ATL::CRegKey::DeleteSubKey'::`6'::pfnRegDeleteKeyEx
PUBLIC	??_C@_0BA@KECIECLD@RegDeleteKeyExA?$AA@		; `string'
PUBLIC	??_C@_0N@DOHINHCI@Advapi32?4dll?$AA@		; `string'
PUBLIC	?bInitialized@?5??DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z@4_NA ; `ATL::CRegKey::DeleteSubKey'::`6'::bInitialized
PUBLIC	?DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z		; ATL::CRegKey::DeleteSubKey
EXTRN	__imp__RegDeleteKeyA@8:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__GetModuleHandleA@4:PROC
;	COMDAT ?pfnRegDeleteKeyEx@?5??DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z@4P6GJPAUHKEY__@@0KK@ZA
_BSS	SEGMENT
?pfnRegDeleteKeyEx@?5??DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z@4P6GJPAUHKEY__@@0KK@ZA DD 01H DUP (?) ; `ATL::CRegKey::DeleteSubKey'::`6'::pfnRegDeleteKeyEx
_BSS	ENDS
;	COMDAT ?bInitialized@?5??DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z@4_NA
_BSS	SEGMENT
?bInitialized@?5??DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z@4_NA DB 01H DUP (?) ; `ATL::CRegKey::DeleteSubKey'::`6'::bInitialized
_BSS	ENDS
;	COMDAT ??_C@_0BA@KECIECLD@RegDeleteKeyExA?$AA@
CONST	SEGMENT
??_C@_0BA@KECIECLD@RegDeleteKeyExA?$AA@ DB 'RegDeleteKeyExA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DOHINHCI@Advapi32?4dll?$AA@
CONST	SEGMENT
??_C@_0N@DOHINHCI@Advapi32?4dll?$AA@ DB 'Advapi32.dll', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z
_TEXT	SEGMENT
_lpszSubKey$ = 8					; size = 4
?DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z PROC		; ATL::CRegKey::DeleteSubKey, COMDAT
; _this$ = ecx

; 5238 : 	ATLASSUME(m_hKey != NULL);
; 5239 : 
; 5240 : #if WINVER >= 0x0501
; 5241 : 	typedef LSTATUS (WINAPI * PFNRegDeleteKeyEx)(HKEY, LPCTSTR, REGSAM, DWORD);
; 5242 : 	static bool bInitialized = false;
; 5243 : 	static PFNRegDeleteKeyEx pfnRegDeleteKeyEx = NULL;
; 5244 : 
; 5245 : 	if (!bInitialized)

  00000	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?bInitialized@?5??DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z@4_NA, 0 ; `ATL::CRegKey::DeleteSubKey'::`6'::bInitialized
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	75 27		 jne	 SHORT $LN13@DeleteSubK

; 5246 : 	{
; 5247 : 		HMODULE hAdvapi32 = GetModuleHandle(_T("Advapi32.dll"));

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DOHINHCI@Advapi32?4dll?$AA@
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4

; 5248 : 		if (hAdvapi32 != NULL)

  00017	85 c0		 test	 eax, eax
  00019	74 11		 je	 SHORT $LN12@DeleteSubK

; 5249 : 		{
; 5250 : #ifdef _UNICODE
; 5251 : 			pfnRegDeleteKeyEx = (PFNRegDeleteKeyEx)GetProcAddress(hAdvapi32, "RegDeleteKeyExW");
; 5252 : #else
; 5253 : 			pfnRegDeleteKeyEx = (PFNRegDeleteKeyEx)GetProcAddress(hAdvapi32, "RegDeleteKeyExA");

  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@KECIECLD@RegDeleteKeyExA?$AA@
  00020	50		 push	 eax
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00027	a3 00 00 00 00	 mov	 DWORD PTR ?pfnRegDeleteKeyEx@?5??DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z@4P6GJPAUHKEY__@@0KK@ZA, eax ; `ATL::CRegKey::DeleteSubKey'::`6'::pfnRegDeleteKeyEx
$LN12@DeleteSubK:

; 5254 : #endif	// _UNICODE
; 5255 : 		}
; 5256 : 		bInitialized = true;

  0002c	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?bInitialized@?5??DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z@4_NA, 1 ; `ATL::CRegKey::DeleteSubKey'::`6'::bInitialized
$LN13@DeleteSubK:

; 5257 : 	}
; 5258 : 
; 5259 : 	if (pfnRegDeleteKeyEx != NULL)

  00033	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pfnRegDeleteKeyEx@?5??DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z@4P6GJPAUHKEY__@@0KK@ZA ; `ATL::CRegKey::DeleteSubKey'::`6'::pfnRegDeleteKeyEx

; 5260 : 	{
; 5261 : 		return pfnRegDeleteKeyEx(m_hKey, lpszSubKey, m_samWOW64, 0);

  00038	8b 54 24 08	 mov	 edx, DWORD PTR _lpszSubKey$[esp]
  0003c	85 c0		 test	 eax, eax
  0003e	74 10		 je	 SHORT $LN1@DeleteSubK
  00040	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00043	6a 00		 push	 0
  00045	51		 push	 ecx
  00046	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00048	52		 push	 edx
  00049	51		 push	 ecx
  0004a	ff d0		 call	 eax
  0004c	5e		 pop	 esi

; 5267 : }

  0004d	c2 04 00	 ret	 4
$LN1@DeleteSubK:

; 5262 : 	}
; 5263 : 
; 5264 : #endif	// WINVER
; 5265 : 
; 5266 : 	return RegDeleteKey(m_hKey, lpszSubKey);

  00050	8b 06		 mov	 eax, DWORD PTR [esi]
  00052	52		 push	 edx
  00053	50		 push	 eax
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegDeleteKeyA@8
  0005a	5e		 pop	 esi

; 5267 : }

  0005b	c2 04 00	 ret	 4
?DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z ENDP		; ATL::CRegKey::DeleteSubKey
_TEXT	ENDS
PUBLIC	?DeleteValue@CRegKey@ATL@@QAEJPBD@Z		; ATL::CRegKey::DeleteValue
EXTRN	__imp__RegDeleteValueA@8:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?DeleteValue@CRegKey@ATL@@QAEJPBD@Z
_TEXT	SEGMENT
_lpszValue$ = 8						; size = 4
?DeleteValue@CRegKey@ATL@@QAEJPBD@Z PROC		; ATL::CRegKey::DeleteValue, COMDAT
; _this$ = ecx

; 5271 : 	ATLASSUME(m_hKey != NULL);
; 5272 : 	return RegDeleteValue(m_hKey, (LPTSTR)lpszValue);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _lpszValue$[esp-4]
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	50		 push	 eax
  00007	51		 push	 ecx
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegDeleteValueA@8

; 5273 : }

  0000e	c2 04 00	 ret	 4
?DeleteValue@CRegKey@ATL@@QAEJPBD@Z ENDP		; ATL::CRegKey::DeleteValue
_TEXT	ENDS
PUBLIC	?Close@CRegKey@ATL@@QAEJXZ			; ATL::CRegKey::Close
EXTRN	__imp__RegCloseKey@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?Close@CRegKey@ATL@@QAEJXZ
_TEXT	SEGMENT
?Close@CRegKey@ATL@@QAEJXZ PROC				; ATL::CRegKey::Close, COMDAT
; _this$ = ecx

; 5276 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 5277 : 	LONG lRes = ERROR_SUCCESS;
; 5278 : 	if (m_hKey != NULL)

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	33 c0		 xor	 eax, eax
  00007	85 c9		 test	 ecx, ecx
  00009	74 16		 je	 SHORT $LN4@Close

; 5279 : 	{
; 5280 : 		lRes = RegCloseKey(m_hKey);

  0000b	51		 push	 ecx
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 5281 : 		m_hKey = NULL;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 5282 : 	}
; 5283 : 	m_samWOW64 = 0;

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001f	5e		 pop	 esi

; 5284 : 	return lRes;
; 5285 : }

  00020	c3		 ret	 0
$LN4@Close:

; 5282 : 	}
; 5283 : 	m_samWOW64 = 0;

  00021	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00024	5e		 pop	 esi

; 5284 : 	return lRes;
; 5285 : }

  00025	c3		 ret	 0
?Close@CRegKey@ATL@@QAEJXZ ENDP				; ATL::CRegKey::Close
_TEXT	ENDS
PUBLIC	?Create@CRegKey@ATL@@QAEJPAUHKEY__@@PBDPADKKPAU_SECURITY_ATTRIBUTES@@PAK@Z ; ATL::CRegKey::Create
EXTRN	__imp__RegCreateKeyExA@36:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?Create@CRegKey@ATL@@QAEJPAUHKEY__@@PBDPADKKPAU_SECURITY_ATTRIBUTES@@PAK@Z
_TEXT	SEGMENT
_hKey$ = -4						; size = 4
_hKeyParent$ = 8					; size = 4
_lpszKeyName$ = 12					; size = 4
_lpszClass$ = 16					; size = 4
_dwOptions$ = 20					; size = 4
_samDesired$ = 24					; size = 4
_dw$ = 28						; size = 4
_lpSecAttr$ = 28					; size = 4
_lpdwDisposition$ = 32					; size = 4
?Create@CRegKey@ATL@@QAEJPAUHKEY__@@PBDPADKKPAU_SECURITY_ATTRIBUTES@@PAK@Z PROC ; ATL::CRegKey::Create, COMDAT
; _this$ = ecx

; 5318 : {

  00000	51		 push	 ecx

; 5319 : 	ATLASSERT(hKeyParent != NULL);
; 5320 : 	DWORD dw;
; 5321 : 	HKEY hKey = NULL;
; 5322 : 	LONG lRes = RegCreateKeyEx(hKeyParent, lpszKeyName, 0,
; 5323 : 		lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw);

  00001	8b 54 24 1c	 mov	 edx, DWORD PTR _lpSecAttr$[esp]
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b 7c 24 20	 mov	 edi, DWORD PTR _samDesired$[esp+8]
  0000b	8b f1		 mov	 esi, ecx
  0000d	8d 44 24 24	 lea	 eax, DWORD PTR _dw$[esp+8]
  00011	50		 push	 eax
  00012	8b 44 24 20	 mov	 eax, DWORD PTR _dwOptions$[esp+12]
  00016	8d 4c 24 0c	 lea	 ecx, DWORD PTR _hKey$[esp+16]
  0001a	51		 push	 ecx
  0001b	8b 4c 24 20	 mov	 ecx, DWORD PTR _lpszClass$[esp+16]
  0001f	52		 push	 edx
  00020	8b 54 24 20	 mov	 edx, DWORD PTR _lpszKeyName$[esp+20]
  00024	57		 push	 edi
  00025	50		 push	 eax
  00026	8b 44 24 24	 mov	 eax, DWORD PTR _hKeyParent$[esp+28]
  0002a	51		 push	 ecx
  0002b	6a 00		 push	 0
  0002d	52		 push	 edx
  0002e	50		 push	 eax
  0002f	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR _hKey$[esp+48], 0
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCreateKeyExA@36

; 5324 : 	if (lpdwDisposition != NULL)

  0003d	8b 4c 24 28	 mov	 ecx, DWORD PTR _lpdwDisposition$[esp+8]
  00041	85 c9		 test	 ecx, ecx
  00043	74 06		 je	 SHORT $LN2@Create

; 5325 : 		*lpdwDisposition = dw;

  00045	8b 54 24 24	 mov	 edx, DWORD PTR _dw$[esp+8]
  00049	89 11		 mov	 DWORD PTR [ecx], edx
$LN2@Create:

; 5326 : 	if (lRes == ERROR_SUCCESS)

  0004b	85 c0		 test	 eax, eax
  0004d	75 22		 jne	 SHORT $LN1@Create

; 5327 : 	{
; 5328 : 		lRes = Close();

  0004f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00051	85 c9		 test	 ecx, ecx
  00053	74 0d		 je	 SHORT $LN5@Create
  00055	51		 push	 ecx
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  0005c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN5@Create:

; 5329 : 		m_hKey = hKey;

  00062	8b 4c 24 08	 mov	 ecx, DWORD PTR _hKey$[esp+12]

; 5330 : #if WINVER >= 0x0501
; 5331 : 		m_samWOW64 = samDesired & (KEY_WOW64_32KEY | KEY_WOW64_64KEY);

  00066	81 e7 00 03 00
	00		 and	 edi, 768		; 00000300H
  0006c	89 0e		 mov	 DWORD PTR [esi], ecx
  0006e	89 7e 04	 mov	 DWORD PTR [esi+4], edi
$LN1@Create:
  00071	5f		 pop	 edi
  00072	5e		 pop	 esi

; 5332 : #endif
; 5333 : 	}
; 5334 : 	return lRes;
; 5335 : }

  00073	59		 pop	 ecx
  00074	c2 1c 00	 ret	 28			; 0000001cH
?Create@CRegKey@ATL@@QAEJPAUHKEY__@@PBDPADKKPAU_SECURITY_ATTRIBUTES@@PAK@Z ENDP ; ATL::CRegKey::Create
_TEXT	ENDS
PUBLIC	?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PBDK@Z	; ATL::CRegKey::Open
EXTRN	__imp__RegOpenKeyExA@20:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PBDK@Z
_TEXT	SEGMENT
_hKey$ = -4						; size = 4
_hKeyParent$ = 8					; size = 4
_lpszKeyName$ = 12					; size = 4
_samDesired$ = 16					; size = 4
?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PBDK@Z PROC		; ATL::CRegKey::Open, COMDAT
; _this$ = ecx

; 5338 : {

  00000	51		 push	 ecx

; 5339 : 	ATLASSUME(hKeyParent != NULL);
; 5340 : 	HKEY hKey = NULL;
; 5341 : 	LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);

  00001	8b 54 24 08	 mov	 edx, DWORD PTR _hKeyParent$[esp]
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b 7c 24 18	 mov	 edi, DWORD PTR _samDesired$[esp+8]
  0000b	8d 44 24 08	 lea	 eax, DWORD PTR _hKey$[esp+12]
  0000f	50		 push	 eax
  00010	57		 push	 edi
  00011	8b f1		 mov	 esi, ecx
  00013	8b 4c 24 1c	 mov	 ecx, DWORD PTR _lpszKeyName$[esp+16]
  00017	6a 00		 push	 0
  00019	51		 push	 ecx
  0001a	52		 push	 edx
  0001b	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _hKey$[esp+32], 0
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20

; 5342 : 	if (lRes == ERROR_SUCCESS)

  00029	85 c0		 test	 eax, eax
  0002b	75 22		 jne	 SHORT $LN1@Open

; 5343 : 	{
; 5344 : 		lRes = Close();

  0002d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0002f	85 c9		 test	 ecx, ecx
  00031	74 0d		 je	 SHORT $LN10@Open
  00033	51		 push	 ecx
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  0003a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN10@Open:

; 5345 : 		ATLASSERT(lRes == ERROR_SUCCESS);
; 5346 : 		m_hKey = hKey;

  00040	8b 4c 24 08	 mov	 ecx, DWORD PTR _hKey$[esp+12]

; 5347 : #if WINVER >= 0x0501
; 5348 : 		m_samWOW64 = samDesired & (KEY_WOW64_32KEY | KEY_WOW64_64KEY);

  00044	81 e7 00 03 00
	00		 and	 edi, 768		; 00000300H
  0004a	89 0e		 mov	 DWORD PTR [esi], ecx
  0004c	89 7e 04	 mov	 DWORD PTR [esi+4], edi
$LN1@Open:
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi

; 5349 : #endif
; 5350 : 	}
; 5351 : 	return lRes;
; 5352 : }

  00051	59		 pop	 ecx
  00052	c2 0c 00	 ret	 12			; 0000000cH
?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PBDK@Z ENDP		; ATL::CRegKey::Open
_TEXT	ENDS
PUBLIC	?SetDWORDValue@CRegKey@ATL@@QAEJPBDK@Z		; ATL::CRegKey::SetDWORDValue
EXTRN	__imp__RegSetValueExA@24:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?SetDWORDValue@CRegKey@ATL@@QAEJPBDK@Z
_TEXT	SEGMENT
_pszValueName$ = 8					; size = 4
_dwValue$ = 12						; size = 4
?SetDWORDValue@CRegKey@ATL@@QAEJPBDK@Z PROC		; ATL::CRegKey::SetDWORDValue, COMDAT
; _this$ = ecx

; 5653 : 	ATLASSUME(m_hKey != NULL);
; 5654 : 	return ::RegSetValueEx(m_hKey, pszValueName, NULL, REG_DWORD, reinterpret_cast<const BYTE*>(&dwValue), sizeof(DWORD));

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _pszValueName$[esp-4]
  00004	6a 04		 push	 4
  00006	8d 44 24 0c	 lea	 eax, DWORD PTR _dwValue$[esp]
  0000a	50		 push	 eax
  0000b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000d	6a 04		 push	 4
  0000f	6a 00		 push	 0
  00011	52		 push	 edx
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24

; 5655 : }

  00019	c2 08 00	 ret	 8
?SetDWORDValue@CRegKey@ATL@@QAEJPBDK@Z ENDP		; ATL::CRegKey::SetDWORDValue
_TEXT	ENDS
PUBLIC	?SetStringValue@CRegKey@ATL@@QAEJPBD0K@Z	; ATL::CRegKey::SetStringValue
EXTRN	__imp__lstrlenA@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?SetStringValue@CRegKey@ATL@@QAEJPBD0K@Z
_TEXT	SEGMENT
_pszValueName$ = 8					; size = 4
_pszValue$ = 12						; size = 4
_dwType$ = 16						; size = 4
?SetStringValue@CRegKey@ATL@@QAEJPBD0K@Z PROC		; ATL::CRegKey::SetStringValue, COMDAT
; _this$ = ecx

; 5664 : {

  00000	56		 push	 esi

; 5665 : 	ATLASSUME(m_hKey != NULL);
; 5666 : 	ATLENSURE_RETURN_VAL(pszValue != NULL, ERROR_INVALID_DATA);

  00001	8b 74 24 0c	 mov	 esi, DWORD PTR _pszValue$[esp]
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx
  00008	85 f6		 test	 esi, esi
  0000a	75 08		 jne	 SHORT $LN3@SetStringV
  0000c	5f		 pop	 edi
  0000d	8d 46 0d	 lea	 eax, DWORD PTR [esi+13]
  00010	5e		 pop	 esi

; 5670 : }

  00011	c2 0c 00	 ret	 12			; 0000000cH
$LN3@SetStringV:

; 5667 : 	ATLASSERT((dwType == REG_SZ) || (dwType == REG_EXPAND_SZ));
; 5668 : 
; 5669 : 	return ::RegSetValueEx(m_hKey, pszValueName, NULL, dwType, reinterpret_cast<const BYTE*>(pszValue), (lstrlen(pszValue)+1)*sizeof(TCHAR));

  00014	56		 push	 esi
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  0001b	8b 4c 24 0c	 mov	 ecx, DWORD PTR _pszValueName$[esp+4]
  0001f	8b 17		 mov	 edx, DWORD PTR [edi]
  00021	40		 inc	 eax
  00022	50		 push	 eax
  00023	8b 44 24 18	 mov	 eax, DWORD PTR _dwType$[esp+8]
  00027	56		 push	 esi
  00028	50		 push	 eax
  00029	6a 00		 push	 0
  0002b	51		 push	 ecx
  0002c	52		 push	 edx
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi

; 5670 : }

  00035	c2 0c 00	 ret	 12			; 0000000cH
?SetStringValue@CRegKey@ATL@@QAEJPBD0K@Z ENDP		; ATL::CRegKey::SetStringValue
_TEXT	ENDS
PUBLIC	?SetMultiStringValue@CRegKey@ATL@@QAEJPBD0@Z	; ATL::CRegKey::SetMultiStringValue
; Function compile flags: /Ogtpy
;	COMDAT ?SetMultiStringValue@CRegKey@ATL@@QAEJPBD0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszValueName$ = 8					; size = 4
_pszValue$ = 12						; size = 4
?SetMultiStringValue@CRegKey@ATL@@QAEJPBD0@Z PROC	; ATL::CRegKey::SetMultiStringValue, COMDAT
; _this$ = ecx

; 5673 : {

  00000	51		 push	 ecx
  00001	55		 push	 ebp

; 5674 : 	LPCTSTR pszTemp;
; 5675 : 	ULONG nBytes;
; 5676 : 	ULONG nLength;
; 5677 : 
; 5678 : 	ATLASSUME(m_hKey != NULL);
; 5679 : 	ATLENSURE_RETURN_VAL(pszValue != NULL, ERROR_INVALID_DATA);

  00002	8b 6c 24 10	 mov	 ebp, DWORD PTR _pszValue$[esp+4]
  00006	89 4c 24 04	 mov	 DWORD PTR _this$[esp+8], ecx
  0000a	85 ed		 test	 ebp, ebp
  0000c	75 08		 jne	 SHORT $LN6@SetMultiSt
  0000e	8d 45 0d	 lea	 eax, DWORD PTR [ebp+13]
  00011	5d		 pop	 ebp

; 5695 : }

  00012	59		 pop	 ecx
  00013	c2 08 00	 ret	 8
$LN6@SetMultiSt:
  00016	53		 push	 ebx

; 5680 : 
; 5681 : 	// Find the total length (in bytes) of all of the strings, including the
; 5682 : 	// terminating '\0' of each string, and the second '\0' that terminates
; 5683 : 	// the list.
; 5684 : 	nBytes = 0;
; 5685 : 	pszTemp = pszValue;

  00017	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__lstrlenA@4
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	33 ff		 xor	 edi, edi
  00021	8b f5		 mov	 esi, ebp
$LL3@SetMultiSt:

; 5686 : 	do
; 5687 : 	{
; 5688 : 		nLength = lstrlen(pszTemp)+1;

  00023	56		 push	 esi
  00024	ff d3		 call	 ebx
  00026	40		 inc	 eax

; 5689 : 		pszTemp += nLength;

  00027	03 f0		 add	 esi, eax

; 5690 : 		nBytes += nLength*sizeof(TCHAR);

  00029	03 f8		 add	 edi, eax

; 5691 : 	} while (nLength != 1);

  0002b	83 f8 01	 cmp	 eax, 1
  0002e	75 f3		 jne	 SHORT $LL3@SetMultiSt

; 5692 : 
; 5693 : 	return ::RegSetValueEx(m_hKey, pszValueName, NULL, REG_MULTI_SZ, reinterpret_cast<const BYTE*>(pszValue),
; 5694 : 		nBytes);

  00030	8b 44 24 18	 mov	 eax, DWORD PTR _pszValueName$[esp+16]
  00034	8b 4c 24 10	 mov	 ecx, DWORD PTR _this$[esp+20]
  00038	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003a	57		 push	 edi
  0003b	55		 push	 ebp
  0003c	6a 07		 push	 7
  0003e	6a 00		 push	 0
  00040	50		 push	 eax
  00041	52		 push	 edx
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24
  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	5d		 pop	 ebp

; 5695 : }

  0004c	59		 pop	 ecx
  0004d	c2 08 00	 ret	 8
?SetMultiStringValue@CRegKey@ATL@@QAEJPBD0@Z ENDP	; ATL::CRegKey::SetMultiStringValue
_TEXT	ENDS
PUBLIC	?IsEqualKey@CExpansionVectorEqualHelper@ATL@@SA_NQAD0@Z ; ATL::CExpansionVectorEqualHelper::IsEqualKey
EXTRN	__imp__lstrcmpiA@8:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\statreg.h
;	COMDAT ?IsEqualKey@CExpansionVectorEqualHelper@ATL@@SA_NQAD0@Z
_TEXT	SEGMENT
_k1$ = 8						; size = 4
_k2$ = 12						; size = 4
?IsEqualKey@CExpansionVectorEqualHelper@ATL@@SA_NQAD0@Z PROC ; ATL::CExpansionVectorEqualHelper::IsEqualKey, COMDAT

; 75   : 		if (lstrcmpi(k1, k2) == 0)

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _k2$[esp-4]
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR _k1$[esp-4]
  00008	50		 push	 eax
  00009	51		 push	 ecx
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpiA@8
  00010	85 c0		 test	 eax, eax
  00012	0f 94 c0	 sete	 al

; 76   : 			return true;
; 77   : 		return false;
; 78   : 	}

  00015	c3		 ret	 0
?IsEqualKey@CExpansionVectorEqualHelper@ATL@@SA_NQAD0@Z ENDP ; ATL::CExpansionVectorEqualHelper::IsEqualKey
_TEXT	ENDS
PUBLIC	?GenerateError@CRegParser@ATL@@IAEJI@Z		; ATL::CRegParser::GenerateError
; Function compile flags: /Ogtpy
;	COMDAT ?GenerateError@CRegParser@ATL@@IAEJI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?GenerateError@CRegParser@ATL@@IAEJI@Z PROC		; ATL::CRegParser::GenerateError, COMDAT
; _this$ = ecx

; 170  : 	HRESULT GenerateError(UINT) {return DISP_E_EXCEPTION;}

  00000	b8 09 00 02 80	 mov	 eax, -2147352567	; 80020009H
  00005	c2 04 00	 ret	 4
?GenerateError@CRegParser@ATL@@IAEJI@Z ENDP		; ATL::CRegParser::GenerateError
_TEXT	ENDS
PUBLIC	?EndOfVar@CRegParser@ATL@@IAEHXZ		; ATL::CRegParser::EndOfVar
EXTRN	__imp__CharNextA@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?EndOfVar@CRegParser@ATL@@IAEHXZ
_TEXT	SEGMENT
?EndOfVar@CRegParser@ATL@@IAEHXZ PROC			; ATL::CRegParser::EndOfVar, COMDAT
; _this$ = ecx

; 174  : 	BOOL    EndOfVar() { return chQuote == *m_pchCur && chQuote != *CharNext(m_pchCur); }

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	80 38 27	 cmp	 BYTE PTR [eax], 39	; 00000027H
  00005	75 12		 jne	 SHORT $LN3@EndOfVar
  00007	50		 push	 eax
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextA@4
  0000e	80 38 27	 cmp	 BYTE PTR [eax], 39	; 00000027H
  00011	74 06		 je	 SHORT $LN3@EndOfVar
  00013	b8 01 00 00 00	 mov	 eax, 1
  00018	c3		 ret	 0
$LN3@EndOfVar:
  00019	33 c0		 xor	 eax, eax
  0001b	c3		 ret	 0
?EndOfVar@CRegParser@ATL@@IAEHXZ ENDP			; ATL::CRegParser::EndOfVar
_TEXT	ENDS
PUBLIC	??0CParseBuffer@CRegParser@ATL@@QAE@H@Z		; ATL::CRegParser::CParseBuffer::CParseBuffer
; Function compile flags: /Ogtpy
;	COMDAT ??0CParseBuffer@CRegParser@ATL@@QAE@H@Z
_TEXT	SEGMENT
_nInitial$ = 8						; size = 4
??0CParseBuffer@CRegParser@ATL@@QAE@H@Z PROC		; ATL::CRegParser::CParseBuffer::CParseBuffer, COMDAT
; _this$ = ecx

; 191  : 		{
; 192  : 			if (nInitial < 100)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nInitial$[esp-4]
  00004	83 f8 64	 cmp	 eax, 100		; 00000064H
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	7d 05		 jge	 SHORT $LN2@CParseBuff

; 193  : 				nInitial = 1000;

  0000c	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
$LN2@CParseBuff:

; 194  : 			nPos = 0;
; 195  : 			nSize = nInitial;
; 196  : 			p = (LPTSTR) ::ATL::AtlCoTaskMemCAlloc(nSize,static_cast<ULONG>(sizeof(TCHAR)));

  00011	33 c9		 xor	 ecx, ecx
  00013	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00019	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0001c	77 05		 ja	 SHORT $LN12@CParseBuff
  0001e	83 f8 ff	 cmp	 eax, -1
  00021	76 04		 jbe	 SHORT $LN5@CParseBuff
$LN12@CParseBuff:
  00023	33 c0		 xor	 eax, eax
  00025	eb 07		 jmp	 SHORT $LN6@CParseBuff
$LN5@CParseBuff:
  00027	50		 push	 eax
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoTaskMemAlloc@4
$LN6@CParseBuff:
  0002e	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 197  : 			if (p != NULL)

  00031	85 c0		 test	 eax, eax
  00033	74 03		 je	 SHORT $LN13@CParseBuff

; 198  : 				*p = NULL;

  00035	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN13@CParseBuff:

; 199  : 		}

  00038	8b c6		 mov	 eax, esi
  0003a	5e		 pop	 esi
  0003b	c2 04 00	 ret	 4
??0CParseBuffer@CRegParser@ATL@@QAE@H@Z ENDP		; ATL::CRegParser::CParseBuffer::CParseBuffer
_TEXT	ENDS
PUBLIC	??1CParseBuffer@CRegParser@ATL@@QAE@XZ		; ATL::CRegParser::CParseBuffer::~CParseBuffer
EXTRN	__imp__CoTaskMemFree@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1CParseBuffer@CRegParser@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CParseBuffer@CRegParser@ATL@@QAE@XZ PROC		; ATL::CRegParser::CParseBuffer::~CParseBuffer, COMDAT
; _this$ = ecx

; 202  : 			CoTaskMemFree(p);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	50		 push	 eax
  00004	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoTaskMemFree@4

; 203  : 		}

  0000a	c3		 ret	 0
??1CParseBuffer@CRegParser@ATL@@QAE@XZ ENDP		; ATL::CRegParser::CParseBuffer::~CParseBuffer
_TEXT	ENDS
PUBLIC	?Append@CParseBuffer@CRegParser@ATL@@QAEHPBDH@Z	; ATL::CRegParser::CParseBuffer::Append
; Function compile flags: /Ogtpy
;	COMDAT ?Append@CParseBuffer@CRegParser@ATL@@QAEHPBDH@Z
_TEXT	SEGMENT
_pch$ = 8						; size = 4
_nChars$ = 12						; size = 4
?Append@CParseBuffer@CRegParser@ATL@@QAEHPBDH@Z PROC	; ATL::CRegParser::CParseBuffer::Append, COMDAT
; _this$ = ecx

; 205  : 		{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 206  : 			ATLASSERT(p != NULL);
; 207  : 			int newSize = nPos + nChars + 1;

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	57		 push	 edi
  00006	8b 7c 24 10	 mov	 edi, DWORD PTR _nChars$[esp+4]
  0000a	8d 4c 38 01	 lea	 ecx, DWORD PTR [eax+edi+1]

; 208  : 			if ((newSize <= nPos) || (newSize <= nChars))

  0000e	3b c8		 cmp	 ecx, eax
  00010	7e 7d		 jle	 SHORT $LN8@Append
  00012	3b cf		 cmp	 ecx, edi
  00014	7e 79		 jle	 SHORT $LN8@Append

; 210  : 
; 211  : 			if (newSize >= nSize)

  00016	3b 4e 04	 cmp	 ecx, DWORD PTR [esi+4]
  00019	7c 35		 jl	 SHORT $LN7@Append
  0001b	eb 03 8d 49 00	 npad	 5
$LL6@Append:

; 212  : 			{
; 213  : 				while (newSize >= nSize) {
; 214  : 					if (nSize > INT_MAX / 2)

  00020	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00023	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00028	7f 65		 jg	 SHORT $LN8@Append

; 215  : 					return FALSE;
; 216  : 					nSize *= 2;

  0002a	03 c0		 add	 eax, eax
  0002c	3b c8		 cmp	 ecx, eax
  0002e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00031	7d ed		 jge	 SHORT $LL6@Append

; 217  : 				}
; 218  : 				LPTSTR pTemp = (LPTSTR)::ATL::AtlCoTaskMemRecalloc(p, nSize, sizeof(TCHAR));

  00033	33 c9		 xor	 ecx, ecx
  00035	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00038	77 55		 ja	 SHORT $LN8@Append
  0003a	72 05		 jb	 SHORT $LN23@Append
  0003c	83 f8 ff	 cmp	 eax, -1
  0003f	77 4e		 ja	 SHORT $LN8@Append
$LN23@Append:
  00041	50		 push	 eax
  00042	52		 push	 edx
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoTaskMemRealloc@8

; 219  : 				if (pTemp == NULL)

  00049	85 c0		 test	 eax, eax

; 220  : 					return FALSE;

  0004b	74 42		 je	 SHORT $LN8@Append

; 221  : 				p = pTemp;

  0004d	89 46 08	 mov	 DWORD PTR [esi+8], eax
$LN7@Append:

; 222  : 			}
; 223  : 			if ((nPos < 0) || (nPos >= nSize) || nSize - nPos > nSize)

  00050	8b 06		 mov	 eax, DWORD PTR [esi]
  00052	85 c0		 test	 eax, eax
  00054	7c 39		 jl	 SHORT $LN8@Append
  00056	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00059	3b c2		 cmp	 eax, edx
  0005b	7d 32		 jge	 SHORT $LN8@Append
  0005d	8b ca		 mov	 ecx, edx
  0005f	2b c8		 sub	 ecx, eax
  00061	3b ca		 cmp	 ecx, edx
  00063	7f 2a		 jg	 SHORT $LN8@Append

; 224  : 				return FALSE;
; 225  : 
; 226  : #pragma warning(push)
; 227  : #pragma warning(disable: 22008)
; 228  : 			/* Prefast false warning is fired here despite the all above checks */
; 229  : 			Checked::memcpy_s(p + nPos, (nSize-nPos) * sizeof(TCHAR), pch, int(nChars * sizeof(TCHAR)));

  00065	8b 54 24 0c	 mov	 edx, DWORD PTR _pch$[esp+4]
  00069	57		 push	 edi
  0006a	52		 push	 edx
  0006b	51		 push	 ecx
  0006c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0006f	03 c8		 add	 ecx, eax
  00071	51		 push	 ecx
  00072	e8 00 00 00 00	 call	 ?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z ; ATL::Checked::memcpy_s

; 230  : 			nPos += nChars;
; 231  : 			*(p + nPos) = NULL;

  00077	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0007a	83 c4 10	 add	 esp, 16			; 00000010H
  0007d	01 3e		 add	 DWORD PTR [esi], edi
  0007f	8b 06		 mov	 eax, DWORD PTR [esi]
  00081	5f		 pop	 edi
  00082	c6 04 10 00	 mov	 BYTE PTR [eax+edx], 0

; 232  : #pragma warning(pop)
; 233  : 			return TRUE;			

  00086	b8 01 00 00 00	 mov	 eax, 1
  0008b	5e		 pop	 esi

; 234  : 		}

  0008c	c2 08 00	 ret	 8
$LN8@Append:
  0008f	5f		 pop	 edi

; 209  : 				return FALSE;

  00090	33 c0		 xor	 eax, eax
  00092	5e		 pop	 esi

; 234  : 		}

  00093	c2 08 00	 ret	 8
?Append@CParseBuffer@CRegParser@ATL@@QAEHPBDH@Z ENDP	; ATL::CRegParser::CParseBuffer::Append
_TEXT	ENDS
PUBLIC	?AddChar@CParseBuffer@CRegParser@ATL@@QAEHPBD@Z	; ATL::CRegParser::CParseBuffer::AddChar
; Function compile flags: /Ogtpy
;	COMDAT ?AddChar@CParseBuffer@CRegParser@ATL@@QAEHPBD@Z
_TEXT	SEGMENT
_pch$ = 8						; size = 4
?AddChar@CParseBuffer@CRegParser@ATL@@QAEHPBD@Z PROC	; ATL::CRegParser::CParseBuffer::AddChar, COMDAT
; _this$ = ecx

; 237  : 		{

  00000	56		 push	 esi

; 238  : #ifndef _UNICODE		
; 239  : 			int nChars = int(CharNext(pch) - pch);

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _pch$[esp]
  00005	57		 push	 edi
  00006	56		 push	 esi
  00007	8b f9		 mov	 edi, ecx
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextA@4
  0000f	2b c6		 sub	 eax, esi

; 240  : #else
; 241  : 			int nChars = 1;
; 242  : #endif
; 243  : 			return Append(pch, nChars);

  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	8b cf		 mov	 ecx, edi
  00015	e8 00 00 00 00	 call	 ?Append@CParseBuffer@CRegParser@ATL@@QAEHPBDH@Z ; ATL::CRegParser::CParseBuffer::Append
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 244  : 
; 245  : 		}

  0001c	c2 04 00	 ret	 4
?AddChar@CParseBuffer@CRegParser@ATL@@QAEHPBD@Z ENDP	; ATL::CRegParser::CParseBuffer::AddChar
_TEXT	ENDS
PUBLIC	?Detach@CParseBuffer@CRegParser@ATL@@QAEPADXZ	; ATL::CRegParser::CParseBuffer::Detach
; Function compile flags: /Ogtpy
;	COMDAT ?Detach@CParseBuffer@CRegParser@ATL@@QAEPADXZ
_TEXT	SEGMENT
?Detach@CParseBuffer@CRegParser@ATL@@QAEPADXZ PROC	; ATL::CRegParser::CParseBuffer::Detach, COMDAT
; _this$ = ecx

; 262  : 			LPTSTR lp = p;

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 263  : 			p = NULL;

  00003	33 d2		 xor	 edx, edx
  00005	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 264  : 			nSize = nPos = 0;

  00008	89 11		 mov	 DWORD PTR [ecx], edx
  0000a	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 265  : 			return lp;
; 266  : 		}

  0000d	c3		 ret	 0
?Detach@CParseBuffer@CRegParser@ATL@@QAEPADXZ ENDP	; ATL::CRegParser::CParseBuffer::Detach
_TEXT	ENDS
PUBLIC	?FinalConstruct@CRegObject@ATL@@QAEJXZ		; ATL::CRegObject::FinalConstruct
; Function compile flags: /Ogtpy
;	COMDAT ?FinalConstruct@CRegObject@ATL@@QAEJXZ
_TEXT	SEGMENT
?FinalConstruct@CRegObject@ATL@@QAEJXZ PROC		; ATL::CRegObject::FinalConstruct, COMDAT
; _this$ = ecx

; 301  : 	HRESULT FinalConstruct() { return m_csMap.Init(); }

  00000	56		 push	 esi
  00001	8d 71 10	 lea	 esi, DWORD PTR [ecx+16]
  00004	8b ce		 mov	 ecx, esi
  00006	e8 00 00 00 00	 call	 ?Init@CComCriticalSection@ATL@@QAEJXZ ; ATL::CComCriticalSection::Init
  0000b	85 c0		 test	 eax, eax
  0000d	7c 04		 jl	 SHORT $LN3@FinalConst
  0000f	c6 46 18 01	 mov	 BYTE PTR [esi+24], 1
$LN3@FinalConst:
  00013	5e		 pop	 esi
  00014	c3		 ret	 0
?FinalConstruct@CRegObject@ATL@@QAEJXZ ENDP		; ATL::CRegObject::FinalConstruct
_TEXT	ENDS
PUBLIC	?FinalRelease@CRegObject@ATL@@QAEXXZ		; ATL::CRegObject::FinalRelease
; Function compile flags: /Ogtpy
;	COMDAT ?FinalRelease@CRegObject@ATL@@QAEXXZ
_TEXT	SEGMENT
?FinalRelease@CRegObject@ATL@@QAEXXZ PROC		; ATL::CRegObject::FinalRelease, COMDAT
; _this$ = ecx

; 302  : 	void FinalRelease() {}

  00000	c3		 ret	 0
?FinalRelease@CRegObject@ATL@@QAEXXZ ENDP		; ATL::CRegObject::FinalRelease
_TEXT	ENDS
PUBLIC	??1CComAutoDeleteCriticalSection@ATL@@QAE@XZ	; ATL::CComAutoDeleteCriticalSection::~CComAutoDeleteCriticalSection
; Function compile flags: /Ogtpy
;	COMDAT ??1CComAutoDeleteCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CComAutoDeleteCriticalSection@ATL@@QAE@XZ PROC	; ATL::CComAutoDeleteCriticalSection::~CComAutoDeleteCriticalSection, COMDAT
; _this$ = ecx
  00000	80 79 18 00	 cmp	 BYTE PTR [ecx+24], 0
  00004	74 0b		 je	 SHORT $LN6@CComAutoDe
  00006	51		 push	 ecx
  00007	c6 41 18 00	 mov	 BYTE PTR [ecx+24], 0
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
$LN6@CComAutoDe:
  00011	c3		 ret	 0
??1CComAutoDeleteCriticalSection@ATL@@QAE@XZ ENDP	; ATL::CComAutoDeleteCriticalSection::~CComAutoDeleteCriticalSection
_TEXT	ENDS
PUBLIC	?map@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@?1??123@KAH01@Z@B ; `ATL::CRegParser::VTFromRegType'::`2'::map
PUBLIC	??_B?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@51 ; `ATL::CRegParser::VTFromRegType'::`2'::`local static guard'
PUBLIC	?VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z	; ATL::CRegParser::VTFromRegType
;	COMDAT ?map@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@?1??123@KAH01@Z@B
_BSS	SEGMENT
?map@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@?1??123@KAH01@Z@B DQ 04H DUP (?) ; `ATL::CRegParser::VTFromRegType'::`2'::map
_BSS	ENDS
;	COMDAT ??_B?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@51
_BSS	SEGMENT
??_B?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@51 DD 01H DUP (?) ; `ATL::CRegParser::VTFromRegType'::`2'::`local static guard'
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT ?VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z
_TEXT	SEGMENT
_szValueType$ = 8					; size = 4
_vt$ = 12						; size = 4
?VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z PROC		; ATL::CRegParser::VTFromRegType, COMDAT

; 652  : 	struct typemap
; 653  : 	{
; 654  : 		LPCTSTR lpsz;
; 655  : 		VARTYPE vt;
; 656  : 	};
; 657  : #pragma warning (push)
; 658  : #pragma warning (disable : 4640)	// construction of local static object is not thread-safe
; 659  : 
; 660  : 	static const typemap map[] = {
; 661  : 		{szStringVal, VT_BSTR},

  00000	f6 05 00 00 00
	00 01		 test	 BYTE PTR ??_B?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@51, 1
  00007	75 5d		 jne	 SHORT $LN12@VTFromRegT
  00009	83 0d 00 00 00
	00 01		 or	 DWORD PTR ??_B?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@51, 1
  00010	b8 08 00 00 00	 mov	 eax, 8
  00015	66 a3 04 00 00
	00		 mov	 WORD PTR ?map@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@?1??123@KAH01@Z@B+4, ax

; 662  : 		{multiszStringVal, VT_BSTR | VT_BYREF},

  0001b	b9 08 40 00 00	 mov	 ecx, 16392		; 00004008H

; 663  : 		{szDwordVal,  VT_UI4},

  00020	ba 13 00 00 00	 mov	 edx, 19			; 00000013H

; 664  : 		{szBinaryVal, VT_UI1}

  00025	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  0002a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?map@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@?1??123@KAH01@Z@B, OFFSET ??_C@_01CPLAODJH@S?$AA@
  00034	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?map@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@?1??123@KAH01@Z@B+8, OFFSET ??_C@_01PLPBNMEI@M?$AA@
  0003e	66 89 0d 0c 00
	00 00		 mov	 WORD PTR ?map@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@?1??123@KAH01@Z@B+12, cx
  00045	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?map@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@?1??123@KAH01@Z@B+16, OFFSET ??_C@_01CKDDGHAB@D?$AA@
  0004f	66 89 15 14 00
	00 00		 mov	 WORD PTR ?map@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@?1??123@KAH01@Z@B+20, dx
  00056	c7 05 18 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?map@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@?1??123@KAH01@Z@B+24, OFFSET ??_C@_01HMGJMAIH@B?$AA@
  00060	66 a3 1c 00 00
	00		 mov	 WORD PTR ?map@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@?1??123@KAH01@Z@B+28, ax
$LN12@VTFromRegT:
  00066	53		 push	 ebx

; 665  : 	};
; 666  : 
; 667  : #pragma warning (pop)
; 668  : 
; 669  : 	for (int i=0;i<sizeof(map)/sizeof(typemap);i++)

  00067	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__lstrcmpiA@8
  0006d	56		 push	 esi
  0006e	57		 push	 edi
  0006f	8b 7c 24 10	 mov	 edi, DWORD PTR _szValueType$[esp+8]
  00073	33 f6		 xor	 esi, esi
$LL4@VTFromRegT:

; 670  : 	{
; 671  : 		if (!lstrcmpi(szValueType, map[i].lpsz))

  00075	8b 0c f5 00 00
	00 00		 mov	 ecx, DWORD PTR ?map@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@?1??123@KAH01@Z@B[esi*8]
  0007c	51		 push	 ecx
  0007d	57		 push	 edi
  0007e	ff d3		 call	 ebx
  00080	85 c0		 test	 eax, eax
  00082	74 0c		 je	 SHORT $LN10@VTFromRegT
  00084	46		 inc	 esi
  00085	83 fe 04	 cmp	 esi, 4
  00088	72 eb		 jb	 SHORT $LL4@VTFromRegT
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi

; 675  : 		}
; 676  : 	}
; 677  : 
; 678  : 	return FALSE;

  0008c	33 c0		 xor	 eax, eax
  0008e	5b		 pop	 ebx

; 679  : 
; 680  : }

  0008f	c3		 ret	 0
$LN10@VTFromRegT:

; 672  : 		{
; 673  : 			vt = map[i].vt;

  00090	66 8b 14 f5 04
	00 00 00	 mov	 dx, WORD PTR ?map@?1??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@?1??123@KAH01@Z@B[esi*8+4]
  00098	8b 44 24 14	 mov	 eax, DWORD PTR _vt$[esp+8]
  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi
  0009e	66 89 10	 mov	 WORD PTR [eax], dx

; 674  : 			return TRUE;

  000a1	b8 01 00 00 00	 mov	 eax, 1
  000a6	5b		 pop	 ebx

; 679  : 
; 680  : }

  000a7	c3		 ret	 0
?VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z ENDP		; ATL::CRegParser::VTFromRegType
_TEXT	ENDS
PUBLIC	?ChToByte@CRegParser@ATL@@KAED@Z		; ATL::CRegParser::ChToByte
; Function compile flags: /Ogtpy
;	COMDAT ?ChToByte@CRegParser@ATL@@KAED@Z
_TEXT	SEGMENT
_ch$ = 8						; size = 1
?ChToByte@CRegParser@ATL@@KAED@Z PROC			; ATL::CRegParser::ChToByte, COMDAT

; 684  : 	switch (ch)

  00000	0f be 4c 24 04	 movsx	 ecx, BYTE PTR _ch$[esp-4]
  00005	8d 41 d0	 lea	 eax, DWORD PTR [ecx-48]
  00008	83 f8 36	 cmp	 eax, 54			; 00000036H
  0000b	77 16		 ja	 SHORT $LN1@ChToByte
  0000d	0f b6 90 00 00
	00 00		 movzx	 edx, BYTE PTR $LN9@ChToByte[eax]
  00014	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN10@ChToByte[edx*4]
$LN3@ChToByte:

; 685  : 	{
; 686  : 		case '0':
; 687  : 		case '1':
; 688  : 		case '2':
; 689  : 		case '3':
; 690  : 		case '4':
; 691  : 		case '5':
; 692  : 		case '6':
; 693  : 		case '7':
; 694  : 		case '8':
; 695  : 		case '9':
; 696  : 				return (BYTE) (ch - '0');
; 697  : 		case 'A':
; 698  : 		case 'B':
; 699  : 		case 'C':
; 700  : 		case 'D':
; 701  : 		case 'E':
; 702  : 		case 'F':
; 703  : 				return (BYTE) (10 + (ch - 'A'));

  0001b	8d 41 c9	 lea	 eax, DWORD PTR [ecx-55]

; 715  : 	}
; 716  : }

  0001e	c3		 ret	 0
$LN2@ChToByte:

; 704  : 		case 'a':
; 705  : 		case 'b':
; 706  : 		case 'c':
; 707  : 		case 'd':
; 708  : 		case 'e':
; 709  : 		case 'f':
; 710  : 				return (BYTE) (10 + (ch - 'a'));

  0001f	8d 41 a9	 lea	 eax, DWORD PTR [ecx-87]

; 715  : 	}
; 716  : }

  00022	c3		 ret	 0
$LN1@ChToByte:

; 711  : 		default:
; 712  : 				ATLASSERT(FALSE);
; 713  : 				ATLTRACE(atlTraceRegistrar, 0, _T("Bogus value %c passed as binary Hex value\n"), ch);
; 714  : 				return 0;

  00023	32 c0		 xor	 al, al
$LN5@ChToByte:

; 715  : 	}
; 716  : }

  00025	c3		 ret	 0
  00026	8b ff		 npad	 2
$LN10@ChToByte:
  00028	00 00 00 00	 DD	 $LN5@ChToByte
  0002c	00 00 00 00	 DD	 $LN3@ChToByte
  00030	00 00 00 00	 DD	 $LN2@ChToByte
  00034	00 00 00 00	 DD	 $LN1@ChToByte
$LN9@ChToByte:
  00038	00		 DB	 0
  00039	00		 DB	 0
  0003a	00		 DB	 0
  0003b	00		 DB	 0
  0003c	00		 DB	 0
  0003d	00		 DB	 0
  0003e	00		 DB	 0
  0003f	00		 DB	 0
  00040	00		 DB	 0
  00041	00		 DB	 0
  00042	03		 DB	 3
  00043	03		 DB	 3
  00044	03		 DB	 3
  00045	03		 DB	 3
  00046	03		 DB	 3
  00047	03		 DB	 3
  00048	03		 DB	 3
  00049	01		 DB	 1
  0004a	01		 DB	 1
  0004b	01		 DB	 1
  0004c	01		 DB	 1
  0004d	01		 DB	 1
  0004e	01		 DB	 1
  0004f	03		 DB	 3
  00050	03		 DB	 3
  00051	03		 DB	 3
  00052	03		 DB	 3
  00053	03		 DB	 3
  00054	03		 DB	 3
  00055	03		 DB	 3
  00056	03		 DB	 3
  00057	03		 DB	 3
  00058	03		 DB	 3
  00059	03		 DB	 3
  0005a	03		 DB	 3
  0005b	03		 DB	 3
  0005c	03		 DB	 3
  0005d	03		 DB	 3
  0005e	03		 DB	 3
  0005f	03		 DB	 3
  00060	03		 DB	 3
  00061	03		 DB	 3
  00062	03		 DB	 3
  00063	03		 DB	 3
  00064	03		 DB	 3
  00065	03		 DB	 3
  00066	03		 DB	 3
  00067	03		 DB	 3
  00068	03		 DB	 3
  00069	02		 DB	 2
  0006a	02		 DB	 2
  0006b	02		 DB	 2
  0006c	02		 DB	 2
  0006d	02		 DB	 2
  0006e	02		 DB	 2
?ChToByte@CRegParser@ATL@@KAED@Z ENDP			; ATL::CRegParser::ChToByte
_TEXT	ENDS
PUBLIC	?map@?1??HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z@4QBUkeymap@?1??123@KAPAU4@0@Z@B ; `ATL::CRegParser::HKeyFromString'::`2'::map
PUBLIC	?HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z ; ATL::CRegParser::HKeyFromString
PUBLIC	??_C@_04OHBKMIBJ@HKCR?$AA@			; `string'
PUBLIC	??_C@_04KIFLFONO@HKCU?$AA@			; `string'
PUBLIC	??_C@_04CBBMIBLK@HKLM?$AA@			; `string'
PUBLIC	??_C@_03DLBIJLAB@HKU?$AA@			; `string'
PUBLIC	??_C@_04OFOCGAOH@HKPD?$AA@			; `string'
PUBLIC	??_C@_04POMNGLEL@HKDD?$AA@			; `string'
PUBLIC	??_C@_04LEMDOLAJ@HKCC?$AA@			; `string'
PUBLIC	??_C@_0BC@JBJOLKMF@HKEY_CLASSES_ROOT?$AA@	; `string'
PUBLIC	??_C@_0BC@GMMMKLBI@HKEY_CURRENT_USER?$AA@	; `string'
PUBLIC	??_C@_0BD@GIIFIKDM@HKEY_LOCAL_MACHINE?$AA@	; `string'
PUBLIC	??_C@_0L@OEMMANAM@HKEY_USERS?$AA@		; `string'
PUBLIC	??_C@_0BG@IDBEHNDO@HKEY_PERFORMANCE_DATA?$AA@	; `string'
PUBLIC	??_C@_0O@MJDLIIGK@HKEY_DYN_DATA?$AA@		; `string'
PUBLIC	??_C@_0BE@NLNNHLLF@HKEY_CURRENT_CONFIG?$AA@	; `string'
;	COMDAT ??_C@_0BE@NLNNHLLF@HKEY_CURRENT_CONFIG?$AA@
CONST	SEGMENT
??_C@_0BE@NLNNHLLF@HKEY_CURRENT_CONFIG?$AA@ DB 'HKEY_CURRENT_CONFIG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MJDLIIGK@HKEY_DYN_DATA?$AA@
CONST	SEGMENT
??_C@_0O@MJDLIIGK@HKEY_DYN_DATA?$AA@ DB 'HKEY_DYN_DATA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IDBEHNDO@HKEY_PERFORMANCE_DATA?$AA@
CONST	SEGMENT
??_C@_0BG@IDBEHNDO@HKEY_PERFORMANCE_DATA?$AA@ DB 'HKEY_PERFORMANCE_DATA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OEMMANAM@HKEY_USERS?$AA@
CONST	SEGMENT
??_C@_0L@OEMMANAM@HKEY_USERS?$AA@ DB 'HKEY_USERS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GIIFIKDM@HKEY_LOCAL_MACHINE?$AA@
CONST	SEGMENT
??_C@_0BD@GIIFIKDM@HKEY_LOCAL_MACHINE?$AA@ DB 'HKEY_LOCAL_MACHINE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GMMMKLBI@HKEY_CURRENT_USER?$AA@
CONST	SEGMENT
??_C@_0BC@GMMMKLBI@HKEY_CURRENT_USER?$AA@ DB 'HKEY_CURRENT_USER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JBJOLKMF@HKEY_CLASSES_ROOT?$AA@
CONST	SEGMENT
??_C@_0BC@JBJOLKMF@HKEY_CLASSES_ROOT?$AA@ DB 'HKEY_CLASSES_ROOT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04LEMDOLAJ@HKCC?$AA@
CONST	SEGMENT
??_C@_04LEMDOLAJ@HKCC?$AA@ DB 'HKCC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04POMNGLEL@HKDD?$AA@
CONST	SEGMENT
??_C@_04POMNGLEL@HKDD?$AA@ DB 'HKDD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OFOCGAOH@HKPD?$AA@
CONST	SEGMENT
??_C@_04OFOCGAOH@HKPD?$AA@ DB 'HKPD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DLBIJLAB@HKU?$AA@
CONST	SEGMENT
??_C@_03DLBIJLAB@HKU?$AA@ DB 'HKU', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CBBMIBLK@HKLM?$AA@
CONST	SEGMENT
??_C@_04CBBMIBLK@HKLM?$AA@ DB 'HKLM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KIFLFONO@HKCU?$AA@
CONST	SEGMENT
??_C@_04KIFLFONO@HKCU?$AA@ DB 'HKCU', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OHBKMIBJ@HKCR?$AA@
CONST	SEGMENT
??_C@_04OHBKMIBJ@HKCR?$AA@ DB 'HKCR', 00H		; `string'
CONST	ENDS
;	COMDAT ?map@?1??HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z@4QBUkeymap@?1??123@KAPAU4@0@Z@B
CONST	SEGMENT
?map@?1??HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z@4QBUkeymap@?1??123@KAPAU4@0@Z@B DD FLAT:??_C@_04OHBKMIBJ@HKCR?$AA@ ; `ATL::CRegParser::HKeyFromString'::`2'::map
	DD	080000000H
	DD	FLAT:??_C@_04KIFLFONO@HKCU?$AA@
	DD	080000001H
	DD	FLAT:??_C@_04CBBMIBLK@HKLM?$AA@
	DD	080000002H
	DD	FLAT:??_C@_03DLBIJLAB@HKU?$AA@
	DD	080000003H
	DD	FLAT:??_C@_04OFOCGAOH@HKPD?$AA@
	DD	080000004H
	DD	FLAT:??_C@_04POMNGLEL@HKDD?$AA@
	DD	080000006H
	DD	FLAT:??_C@_04LEMDOLAJ@HKCC?$AA@
	DD	080000005H
	DD	FLAT:??_C@_0BC@JBJOLKMF@HKEY_CLASSES_ROOT?$AA@
	DD	080000000H
	DD	FLAT:??_C@_0BC@GMMMKLBI@HKEY_CURRENT_USER?$AA@
	DD	080000001H
	DD	FLAT:??_C@_0BD@GIIFIKDM@HKEY_LOCAL_MACHINE?$AA@
	DD	080000002H
	DD	FLAT:??_C@_0L@OEMMANAM@HKEY_USERS?$AA@
	DD	080000003H
	DD	FLAT:??_C@_0BG@IDBEHNDO@HKEY_PERFORMANCE_DATA?$AA@
	DD	080000004H
	DD	FLAT:??_C@_0O@MJDLIIGK@HKEY_DYN_DATA?$AA@
	DD	080000006H
	DD	FLAT:??_C@_0BE@NLNNHLLF@HKEY_CURRENT_CONFIG?$AA@
	DD	080000005H
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z
_TEXT	SEGMENT
_szToken$ = 8						; size = 4
?HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z PROC	; ATL::CRegParser::HKeyFromString, COMDAT

; 719  : {

  00000	53		 push	 ebx

; 720  : 	struct keymap
; 721  : 	{
; 722  : 		LPCTSTR lpsz;
; 723  : 		HKEY hkey;
; 724  : 	};
; 725  : 	static const keymap map[] = {
; 726  : 		{_T("HKCR"), HKEY_CLASSES_ROOT},
; 727  : 		{_T("HKCU"), HKEY_CURRENT_USER},
; 728  : 		{_T("HKLM"), HKEY_LOCAL_MACHINE},
; 729  : 		{_T("HKU"),  HKEY_USERS},
; 730  : 		{_T("HKPD"), HKEY_PERFORMANCE_DATA},
; 731  : 		{_T("HKDD"), HKEY_DYN_DATA},
; 732  : 		{_T("HKCC"), HKEY_CURRENT_CONFIG},
; 733  : 		{_T("HKEY_CLASSES_ROOT"), HKEY_CLASSES_ROOT},
; 734  : 		{_T("HKEY_CURRENT_USER"), HKEY_CURRENT_USER},
; 735  : 		{_T("HKEY_LOCAL_MACHINE"), HKEY_LOCAL_MACHINE},
; 736  : 		{_T("HKEY_USERS"), HKEY_USERS},
; 737  : 		{_T("HKEY_PERFORMANCE_DATA"), HKEY_PERFORMANCE_DATA},
; 738  : 		{_T("HKEY_DYN_DATA"), HKEY_DYN_DATA},
; 739  : 		{_T("HKEY_CURRENT_CONFIG"), HKEY_CURRENT_CONFIG}
; 740  : 	};
; 741  : 
; 742  : 	for (int i=0;i<sizeof(map)/sizeof(keymap);i++)

  00001	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__lstrcmpiA@8
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7c 24 10	 mov	 edi, DWORD PTR _szToken$[esp+8]
  0000d	33 f6		 xor	 esi, esi
  0000f	90		 npad	 1
$LL4@HKeyFromSt:

; 743  : 	{
; 744  : 		if (!lstrcmpi(szToken, map[i].lpsz))

  00010	8b 04 f5 00 00
	00 00		 mov	 eax, DWORD PTR ?map@?1??HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z@4QBUkeymap@?1??123@KAPAU4@0@Z@B[esi*8]
  00017	50		 push	 eax
  00018	57		 push	 edi
  00019	ff d3		 call	 ebx
  0001b	85 c0		 test	 eax, eax
  0001d	74 0c		 je	 SHORT $LN8@HKeyFromSt
  0001f	46		 inc	 esi
  00020	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  00023	72 eb		 jb	 SHORT $LL4@HKeyFromSt
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 746  : 	}
; 747  : 	return NULL;

  00027	33 c0		 xor	 eax, eax
  00029	5b		 pop	 ebx

; 748  : }

  0002a	c3		 ret	 0
$LN8@HKeyFromSt:

; 745  : 			return map[i].hkey;

  0002b	8b 04 f5 04 00
	00 00		 mov	 eax, DWORD PTR ?map@?1??HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z@4QBUkeymap@?1??123@KAPAU4@0@Z@B[esi*8+4]
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx

; 748  : }

  00035	c3		 ret	 0
?HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z ENDP	; ATL::CRegParser::HKeyFromString
_TEXT	ENDS
PUBLIC	?StrChrA@CRegParser@ATL@@KAPADPADD@Z		; ATL::CRegParser::StrChrA
; Function compile flags: /Ogtpy
;	COMDAT ?StrChrA@CRegParser@ATL@@KAPADPADD@Z
_TEXT	SEGMENT
_lpsz$ = 8						; size = 4
_ch$ = 12						; size = 1
?StrChrA@CRegParser@ATL@@KAPADPADD@Z PROC		; ATL::CRegParser::StrChrA, COMDAT

; 752  : 	LPTSTR p = NULL;
; 753  : 
; 754  : 	if (lpsz == NULL)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _lpsz$[esp-4]
  00004	57		 push	 edi
  00005	33 ff		 xor	 edi, edi
  00007	85 c0		 test	 eax, eax
  00009	75 02		 jne	 SHORT $LN7@StrChrA
  0000b	5f		 pop	 edi

; 767  : }

  0000c	c3		 ret	 0
$LN7@StrChrA:

; 755  : 		return NULL;
; 756  : 	
; 757  : 	while (*lpsz)

  0000d	8a 08		 mov	 cl, BYTE PTR [eax]
  0000f	84 c9		 test	 cl, cl
  00011	74 24		 je	 SHORT $LN2@StrChrA
  00013	53		 push	 ebx
  00014	8a 5c 24 10	 mov	 bl, BYTE PTR _ch$[esp+4]
  00018	56		 push	 esi
  00019	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CharNextA@4
  0001f	90		 npad	 1
$LL3@StrChrA:

; 758  : 	{
; 759  : 		if (*lpsz == ch)

  00020	3a cb		 cmp	 cl, bl
  00022	74 0f		 je	 SHORT $LN8@StrChrA

; 762  : 			break;
; 763  : 		}
; 764  : 		lpsz = CharNext(lpsz);

  00024	50		 push	 eax
  00025	ff d6		 call	 esi
  00027	8a 08		 mov	 cl, BYTE PTR [eax]
  00029	84 c9		 test	 cl, cl
  0002b	75 f3		 jne	 SHORT $LL3@StrChrA
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx

; 765  : 	}
; 766  : 	return p;

  0002f	8b c7		 mov	 eax, edi
  00031	5f		 pop	 edi

; 767  : }

  00032	c3		 ret	 0
$LN8@StrChrA:
  00033	5e		 pop	 esi

; 760  : 		{
; 761  : 			p = lpsz;

  00034	8b f8		 mov	 edi, eax
  00036	5b		 pop	 ebx
$LN2@StrChrA:

; 765  : 	}
; 766  : 	return p;

  00037	8b c7		 mov	 eax, edi
  00039	5f		 pop	 edi

; 767  : }

  0003a	c3		 ret	 0
?StrChrA@CRegParser@ATL@@KAPADPADD@Z ENDP		; ATL::CRegParser::StrChrA
_TEXT	ENDS
PUBLIC	??0CRegParser@ATL@@QAE@PAVCRegObject@1@@Z	; ATL::CRegParser::CRegParser
; Function compile flags: /Ogtpy
;	COMDAT ??0CRegParser@ATL@@QAE@PAVCRegObject@1@@Z
_TEXT	SEGMENT
_pRegObj$ = 8						; size = 4
??0CRegParser@ATL@@QAE@PAVCRegObject@1@@Z PROC		; ATL::CRegParser::CRegParser, COMDAT
; _this$ = ecx

; 770  : {

  00000	8b c1		 mov	 eax, ecx

; 771  : 	m_pRegObj           = pRegObj;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR _pRegObj$[esp-4]
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 772  : 	m_pchCur            = NULL;

  00009	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 773  : }

  0000f	c2 04 00	 ret	 4
??0CRegParser@ATL@@QAE@PAVCRegObject@1@@Z ENDP		; ATL::CRegParser::CRegParser
_TEXT	ENDS
PUBLIC	?IsSpace@CRegParser@ATL@@IAEHD@Z		; ATL::CRegParser::IsSpace
; Function compile flags: /Ogtpy
;	COMDAT ?IsSpace@CRegParser@ATL@@IAEHD@Z
_TEXT	SEGMENT
_ch$ = 8						; size = 1
?IsSpace@CRegParser@ATL@@IAEHD@Z PROC			; ATL::CRegParser::IsSpace, COMDAT
; _this$ = ecx

; 777  : 	switch (ch)

  00000	0f be 44 24 04	 movsx	 eax, BYTE PTR _ch$[esp-4]
  00005	83 c0 f7	 add	 eax, -9			; fffffff7H
  00008	83 f8 17	 cmp	 eax, 23			; 00000017H
  0000b	77 16		 ja	 SHORT $LN2@IsSpace
  0000d	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN6@IsSpace[eax]
  00014	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN7@IsSpace[eax*4]
$LN1@IsSpace:

; 778  : 	{
; 779  : 		case _T(' '):
; 780  : 		case _T('\t'):
; 781  : 		case _T('\r'):
; 782  : 		case _T('\n'):
; 783  : 				return TRUE;

  0001b	b8 01 00 00 00	 mov	 eax, 1

; 787  : }

  00020	c2 04 00	 ret	 4
$LN2@IsSpace:

; 784  : 	}
; 785  : 
; 786  : 	return FALSE;

  00023	33 c0		 xor	 eax, eax

; 787  : }

  00025	c2 04 00	 ret	 4
$LN7@IsSpace:
  00028	00 00 00 00	 DD	 $LN1@IsSpace
  0002c	00 00 00 00	 DD	 $LN2@IsSpace
$LN6@IsSpace:
  00030	00		 DB	 0
  00031	00		 DB	 0
  00032	01		 DB	 1
  00033	01		 DB	 1
  00034	00		 DB	 0
  00035	01		 DB	 1
  00036	01		 DB	 1
  00037	01		 DB	 1
  00038	01		 DB	 1
  00039	01		 DB	 1
  0003a	01		 DB	 1
  0003b	01		 DB	 1
  0003c	01		 DB	 1
  0003d	01		 DB	 1
  0003e	01		 DB	 1
  0003f	01		 DB	 1
  00040	01		 DB	 1
  00041	01		 DB	 1
  00042	01		 DB	 1
  00043	01		 DB	 1
  00044	01		 DB	 1
  00045	01		 DB	 1
  00046	01		 DB	 1
  00047	00		 DB	 0
?IsSpace@CRegParser@ATL@@IAEHD@Z ENDP			; ATL::CRegParser::IsSpace
_TEXT	ENDS
PUBLIC	?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ		; ATL::CRegParser::SkipWhiteSpace
; Function compile flags: /Ogtpy
;	COMDAT ?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ
_TEXT	SEGMENT
?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ PROC		; ATL::CRegParser::SkipWhiteSpace, COMDAT
; _this$ = ecx

; 790  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__CharNextA@4
  00008	8b f1		 mov	 esi, ecx
  0000a	8d 9b 00 00 00
	00		 npad	 6
$LL2@SkipWhiteS:

; 791  : 	while(IsSpace(*m_pchCur))

  00010	8b 06		 mov	 eax, DWORD PTR [esi]
  00012	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00015	83 c1 f7	 add	 ecx, -9			; fffffff7H
  00018	83 f9 17	 cmp	 ecx, 23			; 00000017H
  0001b	77 15		 ja	 SHORT $LN6@SkipWhiteS
  0001d	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN12@SkipWhiteS[ecx]
  00024	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN13@SkipWhiteS[ecx*4]
$LN5@SkipWhiteS:

; 792  : 		m_pchCur = CharNext(m_pchCur);

  0002b	50		 push	 eax
  0002c	ff d7		 call	 edi
  0002e	89 06		 mov	 DWORD PTR [esi], eax
  00030	eb de		 jmp	 SHORT $LL2@SkipWhiteS

; 791  : 	while(IsSpace(*m_pchCur))

$LN6@SkipWhiteS:
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi

; 793  : }

  00034	c3		 ret	 0
  00035	8d 49 00	 npad	 3
$LN13@SkipWhiteS:
  00038	00 00 00 00	 DD	 $LN5@SkipWhiteS
  0003c	00 00 00 00	 DD	 $LN6@SkipWhiteS
$LN12@SkipWhiteS:
  00040	00		 DB	 0
  00041	00		 DB	 0
  00042	01		 DB	 1
  00043	01		 DB	 1
  00044	00		 DB	 0
  00045	01		 DB	 1
  00046	01		 DB	 1
  00047	01		 DB	 1
  00048	01		 DB	 1
  00049	01		 DB	 1
  0004a	01		 DB	 1
  0004b	01		 DB	 1
  0004c	01		 DB	 1
  0004d	01		 DB	 1
  0004e	01		 DB	 1
  0004f	01		 DB	 1
  00050	01		 DB	 1
  00051	01		 DB	 1
  00052	01		 DB	 1
  00053	01		 DB	 1
  00054	01		 DB	 1
  00055	01		 DB	 1
  00056	01		 DB	 1
  00057	00		 DB	 0
?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ ENDP		; ATL::CRegParser::SkipWhiteSpace
_TEXT	ENDS
PUBLIC	?NextToken@CRegParser@ATL@@IAEJPAD@Z		; ATL::CRegParser::NextToken
; Function compile flags: /Ogtpy
;	COMDAT ?NextToken@CRegParser@ATL@@IAEJPAD@Z
_TEXT	SEGMENT
_szOrig$ = 8						; size = 4
_szToken$ = 8						; size = 4
?NextToken@CRegParser@ATL@@IAEJPAD@Z PROC		; ATL::CRegParser::NextToken, COMDAT
; _this$ = ecx

; 798  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 799  : 	SkipWhiteSpace();

  00003	e8 00 00 00 00	 call	 ?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ ; ATL::CRegParser::SkipWhiteSpace

; 800  : 
; 801  : 	// NextToken cannot be called at EOS
; 802  : 	if (NULL == *m_pchCur)

  00008	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0000a	8a 01		 mov	 al, BYTE PTR [ecx]
  0000c	84 c0		 test	 al, al
  0000e	75 09		 jne	 SHORT $LN17@NextToken

; 803  : 		return GenerateError(E_ATL_UNEXPECTED_EOS);

  00010	b8 09 00 02 80	 mov	 eax, -2147352567	; 80020009H
  00015	5e		 pop	 esi

; 861  : }

  00016	c2 04 00	 ret	 4
$LN17@NextToken:
  00019	53		 push	 ebx

; 804  : #pragma warning(pop)
; 805  : 
; 806  : 	LPCTSTR szOrig = szToken;

  0001a	8b 5c 24 0c	 mov	 ebx, DWORD PTR _szToken$[esp+4]
  0001e	55		 push	 ebp

; 807  : 	// handle quoted value / key
; 808  : 	if (chQuote == *m_pchCur)
; 809  : 	{
; 810  : 		m_pchCur = CharNext(m_pchCur);

  0001f	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__CharNextA@4
  00025	57		 push	 edi
  00026	89 5c 24 14	 mov	 DWORD PTR _szOrig$[esp+12], ebx
  0002a	3c 27		 cmp	 al, 39			; 00000027H
  0002c	75 74		 jne	 SHORT $LL6@NextToken
  0002e	51		 push	 ecx
  0002f	ff d5		 call	 ebp
  00031	89 06		 mov	 DWORD PTR [esi], eax

; 811  : 
; 812  : 		while (NULL != *m_pchCur && !EndOfVar())

  00033	80 38 00	 cmp	 BYTE PTR [eax], 0
  00036	74 50		 je	 SHORT $LN14@NextToken
$LL15@NextToken:
  00038	8b 06		 mov	 eax, DWORD PTR [esi]
  0003a	80 38 27	 cmp	 BYTE PTR [eax], 39	; 00000027H
  0003d	75 08		 jne	 SHORT $LN24@NextToken
  0003f	50		 push	 eax
  00040	ff d5		 call	 ebp
  00042	80 38 27	 cmp	 BYTE PTR [eax], 39	; 00000027H
  00045	75 41		 jne	 SHORT $LN14@NextToken
$LN24@NextToken:

; 813  : 		{
; 814  : 			if (chQuote == *m_pchCur) // If it is a quote that means we must skip it

  00047	8b 06		 mov	 eax, DWORD PTR [esi]
  00049	80 38 27	 cmp	 BYTE PTR [eax], 39	; 00000027H
  0004c	75 05		 jne	 SHORT $LN13@NextToken

; 815  : 				m_pchCur = CharNext(m_pchCur);

  0004e	50		 push	 eax
  0004f	ff d5		 call	 ebp
  00051	89 06		 mov	 DWORD PTR [esi], eax
$LN13@NextToken:

; 816  : 
; 817  : 			LPTSTR pchPrev = m_pchCur;

  00053	8b 3e		 mov	 edi, DWORD PTR [esi]

; 818  : 			m_pchCur = CharNext(m_pchCur);

  00055	57		 push	 edi
  00056	ff d5		 call	 ebp

; 819  : 
; 820  : 			INT_PTR nChars = m_pchCur - pchPrev;
; 821  : 
; 822  : 			// Make sure we have room for nChars plus terminating NULL
; 823  : 			if ((szToken + nChars + 1) >= szOrig + MAX_VALUE)

  00058	8b 54 24 14	 mov	 edx, DWORD PTR _szOrig$[esp+12]
  0005c	89 06		 mov	 DWORD PTR [esi], eax
  0005e	2b c7		 sub	 eax, edi
  00060	8d 4c 18 01	 lea	 ecx, DWORD PTR [eax+ebx+1]
  00064	81 c2 00 10 00
	00		 add	 edx, 4096		; 00001000H
  0006a	3b ca		 cmp	 ecx, edx
  0006c	0f 83 8c 00 00
	00		 jae	 $LN42@NextToken

; 824  : 				return GenerateError(E_ATL_VALUE_TOO_LARGE);
; 825  : 
; 826  : 			for (int i = 0; i < (int)nChars; i++, szToken++, pchPrev++)

  00072	85 c0		 test	 eax, eax
  00074	7e 0b		 jle	 SHORT $LN9@NextToken
$LL11@NextToken:

; 827  : 				*szToken = *pchPrev;

  00076	8a 0f		 mov	 cl, BYTE PTR [edi]
  00078	88 0b		 mov	 BYTE PTR [ebx], cl
  0007a	43		 inc	 ebx
  0007b	47		 inc	 edi
  0007c	83 e8 01	 sub	 eax, 1
  0007f	75 f5		 jne	 SHORT $LL11@NextToken
$LN9@NextToken:

; 811  : 
; 812  : 		while (NULL != *m_pchCur && !EndOfVar())

  00081	8b 16		 mov	 edx, DWORD PTR [esi]
  00083	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00086	75 b0		 jne	 SHORT $LL15@NextToken
$LN14@NextToken:

; 828  : 		}
; 829  : 
; 830  : 		if (NULL == *m_pchCur)

  00088	8b 06		 mov	 eax, DWORD PTR [esi]
  0008a	80 38 00	 cmp	 BYTE PTR [eax], 0

; 831  : 		{
; 832  : 			ATLTRACE(atlTraceRegistrar, 0, _T("NextToken : Unexpected End of File\n"));
; 833  : 			return GenerateError(E_ATL_UNEXPECTED_EOS);

  0008d	74 6f		 je	 SHORT $LN42@NextToken

; 834  : 		}
; 835  : 
; 836  : 		*szToken = NULL;

  0008f	c6 03 00	 mov	 BYTE PTR [ebx], 0

; 837  : 		m_pchCur = CharNext(m_pchCur);

  00092	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00094	51		 push	 ecx
  00095	ff d5		 call	 ebp
  00097	5f		 pop	 edi
  00098	5d		 pop	 ebp
  00099	89 06		 mov	 DWORD PTR [esi], eax
  0009b	5b		 pop	 ebx

; 859  : 	}
; 860  : 	return S_OK;

  0009c	33 c0		 xor	 eax, eax
  0009e	5e		 pop	 esi

; 861  : }

  0009f	c2 04 00	 ret	 4
$LL6@NextToken:

; 838  : 	}
; 839  : 
; 840  : 	else
; 841  : 	{   
; 842  : 		// Handle non-quoted ie parse up till first "White Space"
; 843  : 		while (NULL != *m_pchCur && !IsSpace(*m_pchCur))

  000a2	8b 3e		 mov	 edi, DWORD PTR [esi]
  000a4	0f be 07	 movsx	 eax, BYTE PTR [edi]
  000a7	83 c0 f7	 add	 eax, -9			; fffffff7H
  000aa	83 f8 17	 cmp	 eax, 23			; 00000017H
  000ad	77 0e		 ja	 SHORT $LN31@NextToken
  000af	0f b6 90 00 00
	00 00		 movzx	 edx, BYTE PTR $LN50@NextToken[eax]
  000b6	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN56@NextToken[edx*4]
$LN31@NextToken:

; 844  : 		{
; 845  : 			LPTSTR pchPrev = m_pchCur;
; 846  : 			m_pchCur = CharNext(m_pchCur);

  000bd	57		 push	 edi
  000be	ff d5		 call	 ebp

; 847  : 
; 848  : 			INT_PTR nChars = m_pchCur - pchPrev;
; 849  : 
; 850  : 			// Make sure we have room for nChars plus terminating NULL
; 851  : 			if ((szToken + nChars + 1) >= szOrig + MAX_VALUE)

  000c0	8b 54 24 14	 mov	 edx, DWORD PTR _szOrig$[esp+12]
  000c4	89 06		 mov	 DWORD PTR [esi], eax
  000c6	2b c7		 sub	 eax, edi
  000c8	8d 4c 18 01	 lea	 ecx, DWORD PTR [eax+ebx+1]
  000cc	81 c2 00 10 00
	00		 add	 edx, 4096		; 00001000H
  000d2	3b ca		 cmp	 ecx, edx
  000d4	73 28		 jae	 SHORT $LN42@NextToken

; 853  : 
; 854  : 			for (int i = 0; i < (int)nChars; i++, szToken++, pchPrev++)

  000d6	85 c0		 test	 eax, eax
  000d8	7e 11		 jle	 SHORT $LN1@NextToken
  000da	8d 9b 00 00 00
	00		 npad	 6
$LL3@NextToken:

; 855  : 				*szToken = *pchPrev;

  000e0	8a 0f		 mov	 cl, BYTE PTR [edi]
  000e2	88 0b		 mov	 BYTE PTR [ebx], cl
  000e4	43		 inc	 ebx
  000e5	47		 inc	 edi
  000e6	83 e8 01	 sub	 eax, 1
  000e9	75 f5		 jne	 SHORT $LL3@NextToken
$LN1@NextToken:

; 838  : 	}
; 839  : 
; 840  : 	else
; 841  : 	{   
; 842  : 		// Handle non-quoted ie parse up till first "White Space"
; 843  : 		while (NULL != *m_pchCur && !IsSpace(*m_pchCur))

  000eb	8b 16		 mov	 edx, DWORD PTR [esi]
  000ed	80 3a 00	 cmp	 BYTE PTR [edx], 0
  000f0	75 b0		 jne	 SHORT $LL6@NextToken
$LN5@NextToken:
  000f2	5f		 pop	 edi
  000f3	5d		 pop	 ebp

; 856  : 		}
; 857  : 
; 858  : 		*szToken = NULL;

  000f4	c6 03 00	 mov	 BYTE PTR [ebx], 0
  000f7	5b		 pop	 ebx

; 859  : 	}
; 860  : 	return S_OK;

  000f8	33 c0		 xor	 eax, eax
  000fa	5e		 pop	 esi

; 861  : }

  000fb	c2 04 00	 ret	 4
$LN42@NextToken:
  000fe	5f		 pop	 edi
  000ff	5d		 pop	 ebp
  00100	5b		 pop	 ebx

; 852  : 				return GenerateError(E_ATL_VALUE_TOO_LARGE);

  00101	b8 09 00 02 80	 mov	 eax, -2147352567	; 80020009H
  00106	5e		 pop	 esi

; 861  : }

  00107	c2 04 00	 ret	 4
  0010a	8b ff		 npad	 2
$LN56@NextToken:
  0010c	00 00 00 00	 DD	 $LN5@NextToken
  00110	00 00 00 00	 DD	 $LN31@NextToken
$LN50@NextToken:
  00114	00		 DB	 0
  00115	00		 DB	 0
  00116	01		 DB	 1
  00117	01		 DB	 1
  00118	00		 DB	 0
  00119	01		 DB	 1
  0011a	01		 DB	 1
  0011b	01		 DB	 1
  0011c	01		 DB	 1
  0011d	01		 DB	 1
  0011e	01		 DB	 1
  0011f	01		 DB	 1
  00120	01		 DB	 1
  00121	01		 DB	 1
  00122	01		 DB	 1
  00123	01		 DB	 1
  00124	01		 DB	 1
  00125	01		 DB	 1
  00126	01		 DB	 1
  00127	01		 DB	 1
  00128	01		 DB	 1
  00129	01		 DB	 1
  0012a	01		 DB	 1
  0012b	00		 DB	 0
?NextToken@CRegParser@ATL@@IAEJPAD@Z ENDP		; ATL::CRegParser::NextToken
_TEXT	ENDS
PUBLIC	?CanForceRemoveKey@CRegParser@ATL@@IAEHPBD@Z	; ATL::CRegParser::CanForceRemoveKey
; Function compile flags: /Ogtpy
;	COMDAT ?CanForceRemoveKey@CRegParser@ATL@@IAEHPBD@Z
_TEXT	SEGMENT
_szKey$ = 8						; size = 4
?CanForceRemoveKey@CRegParser@ATL@@IAEHPBD@Z PROC	; ATL::CRegParser::CanForceRemoveKey, COMDAT
; _this$ = ecx

; 995  : {

  00000	53		 push	 ebx

; 996  : 	for (int iNoDel = 0; iNoDel < cbNeverDelete; iNoDel++)

  00001	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__lstrcmpiA@8
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7c 24 10	 mov	 edi, DWORD PTR _szKey$[esp+8]
  0000d	be 00 00 00 00	 mov	 esi, OFFSET ?rgszNeverDelete@CRegParser@ATL@@1QBQBDB ; ATL::CRegParser::rgszNeverDelete
$LL4@CanForceRe:

; 997  : 		if (!lstrcmpi(szKey, rgszNeverDelete[iNoDel]))

  00012	8b 06		 mov	 eax, DWORD PTR [esi]
  00014	50		 push	 eax
  00015	57		 push	 edi
  00016	ff d3		 call	 ebx
  00018	85 c0		 test	 eax, eax
  0001a	74 16		 je	 SHORT $LN8@CanForceRe
  0001c	83 c6 04	 add	 esi, 4
  0001f	81 fe 30 00 00
	00		 cmp	 esi, OFFSET ?rgszNeverDelete@CRegParser@ATL@@1QBQBDB+48
  00025	7c eb		 jl	 SHORT $LL4@CanForceRe
  00027	5f		 pop	 edi
  00028	5e		 pop	 esi

; 999  : 
; 1000 : 	return TRUE;

  00029	b8 01 00 00 00	 mov	 eax, 1
  0002e	5b		 pop	 ebx

; 1001 : }

  0002f	c2 04 00	 ret	 4
$LN8@CanForceRe:
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi

; 998  : 			 return FALSE;                       // We cannot delete it

  00034	33 c0		 xor	 eax, eax
  00036	5b		 pop	 ebx

; 1001 : }

  00037	c2 04 00	 ret	 4
?CanForceRemoveKey@CRegParser@ATL@@IAEHPBD@Z ENDP	; ATL::CRegParser::CanForceRemoveKey
_TEXT	ENDS
PUBLIC	?HasSubKeys@CRegParser@ATL@@IAEHPAUHKEY__@@@Z	; ATL::CRegParser::HasSubKeys
EXTRN	__imp__RegQueryInfoKeyA@48:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?HasSubKeys@CRegParser@ATL@@IAEHPAUHKEY__@@@Z
_TEXT	SEGMENT
_cbSubKeys$ = -4					; size = 4
_hkey$ = 8						; size = 4
?HasSubKeys@CRegParser@ATL@@IAEHPAUHKEY__@@@Z PROC	; ATL::CRegParser::HasSubKeys, COMDAT
; _this$ = ecx

; 1004 : {

  00000	51		 push	 ecx

; 1005 : 	DWORD       cbSubKeys = 0;
; 1006 : 
; 1007 : 	if (RegQueryInfoKey(hkey, NULL, NULL, NULL,
; 1008 : 							   &cbSubKeys, NULL, NULL,
; 1009 : 							   NULL, NULL, NULL, NULL, NULL) != ERROR_SUCCESS)

  00001	8b 4c 24 08	 mov	 ecx, DWORD PTR _hkey$[esp]
  00005	6a 00		 push	 0
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	6a 00		 push	 0
  0000f	6a 00		 push	 0
  00011	6a 00		 push	 0
  00013	8d 44 24 1c	 lea	 eax, DWORD PTR _cbSubKeys$[esp+32]
  00017	50		 push	 eax
  00018	6a 00		 push	 0
  0001a	6a 00		 push	 0
  0001c	6a 00		 push	 0
  0001e	51		 push	 ecx
  0001f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR _cbSubKeys$[esp+52], 0
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryInfoKeyA@48
  0002d	85 c0		 test	 eax, eax
  0002f	74 06		 je	 SHORT $LN1@HasSubKeys

; 1010 : 	{
; 1011 : 		ATLTRACE(atlTraceRegistrar, 0, _T("Should not be here!!\n"));
; 1012 : 		ATLASSERT(FALSE);
; 1013 : 		return FALSE;

  00031	33 c0		 xor	 eax, eax

; 1017 : }

  00033	59		 pop	 ecx
  00034	c2 04 00	 ret	 4
$LN1@HasSubKeys:

; 1014 : 	}
; 1015 : 
; 1016 : 	return cbSubKeys > 0;

  00037	33 d2		 xor	 edx, edx
  00039	3b 14 24	 cmp	 edx, DWORD PTR _cbSubKeys$[esp+4]
  0003c	1b c0		 sbb	 eax, eax
  0003e	f7 d8		 neg	 eax

; 1017 : }

  00040	59		 pop	 ecx
  00041	c2 04 00	 ret	 4
?HasSubKeys@CRegParser@ATL@@IAEHPAUHKEY__@@@Z ENDP	; ATL::CRegParser::HasSubKeys
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SkipAssignment@CRegParser@ATL@@IAEJPAD@Z	; ATL::CRegParser::SkipAssignment
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?SkipAssignment@CRegParser@ATL@@IAEJPAD@Z
_TEXT	SEGMENT
_szValue$ = -4100					; size = 4096
__$ArrayPad$ = -4					; size = 4
_szToken$ = 8						; size = 4
?SkipAssignment@CRegParser@ATL@@IAEJPAD@Z PROC		; ATL::CRegParser::SkipAssignment, COMDAT
; _this$ = ecx

; 1048 : {

  00000	b8 04 10 00 00	 mov	 eax, 4100		; 00001004H
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000f	33 c4		 xor	 eax, esp
  00011	89 84 24 00 10
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+4100], eax
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8b bc 24 10 10
	00 00		 mov	 edi, DWORD PTR _szToken$[esp+4104]

; 1049 : 	HRESULT hr;
; 1050 : 	TCHAR szValue[MAX_VALUE];
; 1051 : 
; 1052 : 	if (*szToken == chEquals)

  00021	80 3f 3d	 cmp	 BYTE PTR [edi], 61	; 0000003dH
  00024	8b f1		 mov	 esi, ecx
  00026	75 2d		 jne	 SHORT $LN1@SkipAssign

; 1053 : 	{
; 1054 : 		if (FAILED(hr = NextToken(szToken)))

  00028	57		 push	 edi
  00029	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  0002e	85 c0		 test	 eax, eax

; 1055 : 			return hr;

  00030	7c 25		 jl	 SHORT $LN5@SkipAssign

; 1056 : 		// Skip assignment
; 1057 : 		SkipWhiteSpace();

  00032	8b ce		 mov	 ecx, esi
  00034	e8 00 00 00 00	 call	 ?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ ; ATL::CRegParser::SkipWhiteSpace

; 1058 : 		if (FAILED(hr = NextToken(szValue)))

  00039	8d 44 24 08	 lea	 eax, DWORD PTR _szValue$[esp+4108]
  0003d	50		 push	 eax
  0003e	8b ce		 mov	 ecx, esi
  00040	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  00045	85 c0		 test	 eax, eax

; 1059 : 			return hr;

  00047	7c 0e		 jl	 SHORT $LN5@SkipAssign

; 1060 : 		if (FAILED(hr = NextToken(szToken)))

  00049	57		 push	 edi
  0004a	8b ce		 mov	 ecx, esi
  0004c	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  00051	85 c0		 test	 eax, eax

; 1061 : 			return hr;

  00053	7c 02		 jl	 SHORT $LN5@SkipAssign
$LN1@SkipAssign:

; 1062 : 	}
; 1063 : 
; 1064 : 	return S_OK;

  00055	33 c0		 xor	 eax, eax
$LN5@SkipAssign:

; 1065 : }

  00057	8b 8c 24 08 10
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+4108]
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	33 cc		 xor	 ecx, esp
  00062	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00067	81 c4 04 10 00
	00		 add	 esp, 4100		; 00001004H
  0006d	c2 04 00	 ret	 4
?SkipAssignment@CRegParser@ATL@@IAEJPAD@Z ENDP		; ATL::CRegParser::SkipAssignment
_TEXT	ENDS
PUBLIC	??0CComAutoDeleteCriticalSection@ATL@@QAE@XZ	; ATL::CComAutoDeleteCriticalSection::CComAutoDeleteCriticalSection
; Function compile flags: /Ogtpy
;	COMDAT ??0CComAutoDeleteCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CComAutoDeleteCriticalSection@ATL@@QAE@XZ PROC	; ATL::CComAutoDeleteCriticalSection::CComAutoDeleteCriticalSection, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000c	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0000f	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00012	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00015	88 48 18	 mov	 BYTE PTR [eax+24], cl
  00018	c3		 ret	 0
??0CComAutoDeleteCriticalSection@ATL@@QAE@XZ ENDP	; ATL::CComAutoDeleteCriticalSection::CComAutoDeleteCriticalSection
_TEXT	ENDS
PUBLIC	??0IUnknown@@QAE@XZ				; IUnknown::IUnknown
; Function compile flags: /Ogtpy
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT
??0IUnknown@@QAE@XZ PROC				; IUnknown::IUnknown, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0IUnknown@@QAE@XZ ENDP				; IUnknown::IUnknown
_TEXT	ENDS
PUBLIC	?AtlGetPerUserRegistration@ATL@@YGJPA_N@Z	; ATL::AtlGetPerUserRegistration
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?AtlGetPerUserRegistration@ATL@@YGJPA_N@Z
_TEXT	SEGMENT
_pbEnabled$ = 8						; size = 4
?AtlGetPerUserRegistration@ATL@@YGJPA_N@Z PROC		; ATL::AtlGetPerUserRegistration, COMDAT

; 6459 : 	if (pbEnabled == NULL)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _pbEnabled$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	75 08		 jne	 SHORT $LN1@AtlGetPerU

; 6460 : 		return E_POINTER;

  00008	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H

; 6464 : }

  0000d	c2 04 00	 ret	 4
$LN1@AtlGetPerU:

; 6461 : 
; 6462 : 	*pbEnabled = _AtlRegisterPerUser;

  00010	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?_AtlRegisterPerUser@ATL@@3_NA ; ATL::_AtlRegisterPerUser
  00016	88 08		 mov	 BYTE PTR [eax], cl

; 6463 : 	return S_OK;

  00018	33 c0		 xor	 eax, eax

; 6464 : }

  0001a	c2 04 00	 ret	 4
?AtlGetPerUserRegistration@ATL@@YGJPA_N@Z ENDP		; ATL::AtlGetPerUserRegistration
_TEXT	ENDS
PUBLIC	??_7_com_error@@6B@				; _com_error::`vftable'
PUBLIC	??0_com_error@@QAE@JPAUIErrorInfo@@_N@Z		; _com_error::_com_error
PUBLIC	??_R4_com_error@@6B@				; _com_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_com_error@@@8				; _com_error `RTTI Type Descriptor'
PUBLIC	??_R3_com_error@@8				; _com_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_com_error@@8				; _com_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_com_error@@8			; _com_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_E_com_error@@UAEPAXI@Z:PROC			; _com_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@_com_error@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\comdef.h
rdata$r	SEGMENT
??_R1A@?0A@EA@_com_error@@8 DD FLAT:??_R0?AV_com_error@@@8 ; _com_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_com_error@@8
rdata$r	ENDS
;	COMDAT ??_R2_com_error@@8
rdata$r	SEGMENT
??_R2_com_error@@8 DD FLAT:??_R1A@?0A@EA@_com_error@@8	; _com_error::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_com_error@@8
rdata$r	SEGMENT
??_R3_com_error@@8 DD 00H				; _com_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_com_error@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_com_error@@@8
_DATA	SEGMENT
??_R0?AV_com_error@@@8 DD FLAT:??_7type_info@@6B@	; _com_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_com_error@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_com_error@@6B@
rdata$r	SEGMENT
??_R4_com_error@@6B@ DD 00H				; _com_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_com_error@@@8
	DD	FLAT:??_R3_com_error@@8
rdata$r	ENDS
;	COMDAT ??_7_com_error@@6B@
CONST	SEGMENT
??_7_com_error@@6B@ DD FLAT:??_R4_com_error@@6B@	; _com_error::`vftable'
	DD	FLAT:??_E_com_error@@UAEPAXI@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0_com_error@@QAE@JPAUIErrorInfo@@_N@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
_perrinfo$ = 12						; size = 4
_fAddRef$ = 16						; size = 1
??0_com_error@@QAE@JPAUIErrorInfo@@_N@Z PROC		; _com_error::_com_error, COMDAT
; _this$ = ecx

; 134  : {

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _hr$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0000a	8b 44 24 0c	 mov	 eax, DWORD PTR _perrinfo$[esp]
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_com_error@@6B@
  00014	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00017	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 135  :     if (m_perrinfo != NULL && fAddRef) {

  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN5@com_error
  00022	80 7c 24 10 00	 cmp	 BYTE PTR _fAddRef$[esp], 0
  00027	74 08		 je	 SHORT $LN5@com_error

; 136  :         m_perrinfo->AddRef();

  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002e	50		 push	 eax
  0002f	ff d2		 call	 edx
$LN5@com_error:

; 137  :     }
; 138  : }

  00031	8b c6		 mov	 eax, esi
  00033	5e		 pop	 esi
  00034	c2 0c 00	 ret	 12			; 0000000cH
??0_com_error@@QAE@JPAUIErrorInfo@@_N@Z ENDP		; _com_error::_com_error
_TEXT	ENDS
PUBLIC	??1_com_error@@UAE@XZ				; _com_error::~_com_error
EXTRN	__imp__LocalFree@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1_com_error@@UAE@XZ
_TEXT	SEGMENT
??1_com_error@@UAE@XZ PROC				; _com_error::~_com_error, COMDAT
; _this$ = ecx

; 149  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 150  :     if (m_perrinfo != NULL) {

  00003	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_com_error@@6B@
  0000c	85 c0		 test	 eax, eax
  0000e	74 08		 je	 SHORT $LN2@com_error@2

; 151  :         m_perrinfo->Release();

  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00015	50		 push	 eax
  00016	ff d2		 call	 edx
$LN2@com_error@2:

; 152  :     }
; 153  :     if (m_pszMsg != NULL) {

  00018	8b 76 0c	 mov	 esi, DWORD PTR [esi+12]
  0001b	85 f6		 test	 esi, esi
  0001d	74 07		 je	 SHORT $LN1@com_error@2

; 154  :         LocalFree((HLOCAL)m_pszMsg);

  0001f	56		 push	 esi
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalFree@4
$LN1@com_error@2:
  00026	5e		 pop	 esi

; 155  :     }
; 156  : }

  00027	c3		 ret	 0
??1_com_error@@UAE@XZ ENDP				; _com_error::~_com_error
_TEXT	ENDS
PUBLIC	?HRESULTToWCode@_com_error@@SAGJ@Z		; _com_error::HRESULTToWCode
; Function compile flags: /Ogtpy
;	COMDAT ?HRESULTToWCode@_com_error@@SAGJ@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
?HRESULTToWCode@_com_error@@SAGJ@Z PROC			; _com_error::HRESULTToWCode, COMDAT

; 275  :     return (hr >= WCODE_HRESULT_FIRST && hr <= WCODE_HRESULT_LAST)
; 276  :         ? WORD(hr - WCODE_HRESULT_FIRST)
; 277  :         : 0;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _hr$[esp-4]
  00004	8d 88 00 fe fb
	7f		 lea	 ecx, DWORD PTR [eax+2147220992]
  0000a	81 f9 ff fd 00
	00		 cmp	 ecx, 65023		; 0000fdffH
  00010	77 09		 ja	 SHORT $LN3@HRESULTToW
  00012	05 00 fe ff ff	 add	 eax, -512		; fffffe00H
  00017	0f b7 c0	 movzx	 eax, ax

; 278  : }

  0001a	c3		 ret	 0
$LN3@HRESULTToW:

; 275  :     return (hr >= WCODE_HRESULT_FIRST && hr <= WCODE_HRESULT_LAST)
; 276  :         ? WORD(hr - WCODE_HRESULT_FIRST)
; 277  :         : 0;

  0001b	33 c0		 xor	 eax, eax

; 278  : }

  0001d	c3		 ret	 0
?HRESULTToWCode@_com_error@@SAGJ@Z ENDP			; _com_error::HRESULTToWCode
_TEXT	ENDS
PUBLIC	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ PROC ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 640  : 	CAtlSafeAllocBufferManager() : m_pHead(NULL) {};

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00008	c3		 ret	 0
??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ PROC ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 654  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 655  : 		// Walk the list and free the buffers
; 656  : 		while (m_pHead != NULL)

  00003	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00006	74 14		 je	 SHORT $LN1@CAtlSafeAl
$LL2@CAtlSafeAl:

; 657  : 		{
; 658  : 			CAtlSafeAllocBufferNode* p = m_pHead;

  00008	8b 06		 mov	 eax, DWORD PTR [esi]

; 659  : 			m_pHead = m_pHead->m_pNext;

  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]

; 660  : 			Allocator::Free(p);

  0000c	50		 push	 eax
  0000d	89 0e		 mov	 DWORD PTR [esi], ecx
  0000f	e8 00 00 00 00	 call	 _free
  00014	83 c4 04	 add	 esp, 4
  00017	83 3e 00	 cmp	 DWORD PTR [esi], 0
  0001a	75 ec		 jne	 SHORT $LL2@CAtlSafeAl
$LN1@CAtlSafeAl:
  0001c	5e		 pop	 esi

; 661  : 		}
; 662  : 	}

  0001d	c3		 ret	 0
??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	??0?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??0?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>, COMDAT
; _this$ = ecx

; 297  : 	{ }

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000c	c3		 ret	 0
??0?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>
_TEXT	ENDS
PUBLIC	?GetSize@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHXZ ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::GetSize
; Function compile flags: /Ogtpy
;	COMDAT ?GetSize@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetSize@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHXZ PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::GetSize, COMDAT
; _this$ = ecx

; 307  : 		return m_nSize;

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 308  : 	}

  00003	c3		 ret	 0
?GetSize@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHXZ ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::GetSize
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::RemoveAll
; Function compile flags: /Ogtpy
;	COMDAT ?RemoveAll@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
?RemoveAll@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXXZ PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::RemoveAll, COMDAT
; _this$ = ecx

; 356  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 357  : 		if(m_aKey != NULL)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 0f		 je	 SHORT $LN5@RemoveAll

; 358  : 		{
; 359  : 			for(int i = 0; i < m_nSize; i++)
; 360  : 			{
; 361  : 				m_aKey[i].~TKey();
; 362  : 				m_aVal[i].~TVal();
; 363  : 			}
; 364  : 			free(m_aKey);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _free
  0000f	83 c4 04	 add	 esp, 4

; 365  : 			m_aKey = NULL;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN5@RemoveAll:

; 366  : 		}
; 367  : 		if(m_aVal != NULL)

  00018	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001b	85 c0		 test	 eax, eax
  0001d	74 10		 je	 SHORT $LN10@RemoveAll

; 368  : 		{
; 369  : 			free(m_aVal);

  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _free
  00025	83 c4 04	 add	 esp, 4

; 370  : 			m_aVal = NULL;

  00028	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
$LN10@RemoveAll:

; 371  : 		}
; 372  : 
; 373  : 		m_nSize = 0;

  0002f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00036	5e		 pop	 esi

; 374  : 	}

  00037	c3		 ret	 0
?RemoveAll@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::RemoveAll
_TEXT	ENDS
PUBLIC	?GetKeyAt@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPADH@Z ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::GetKeyAt
; Function compile flags: /Ogtpy
;	COMDAT ?GetKeyAt@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPADH@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
?GetKeyAt@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPADH@Z PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::GetKeyAt, COMDAT
; _this$ = ecx

; 402  : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
; 403  : 		if(nIndex < 0 || nIndex >= m_nSize)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nIndex$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 0d		 jl	 SHORT $LN1@GetKeyAt
  00008	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0000b	7d 08		 jge	 SHORT $LN1@GetKeyAt

; 404  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);
; 405  : 			
; 406  : 		return m_aKey[nIndex];

  0000d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 407  : 	}

  00012	c2 04 00	 ret	 4
$LN1@GetKeyAt:
  00015	6a 00		 push	 0
  00017	6a 00		 push	 0
  00019	6a 01		 push	 1
  0001b	68 8c 00 00 c0	 push	 -1073741684		; c000008cH
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RaiseException@16
$LN7@GetKeyAt:
  00026	cc		 int	 3
?GetKeyAt@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPADH@Z ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::GetKeyAt
_TEXT	ENDS
PUBLIC	?GetValueAt@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPA_WH@Z ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::GetValueAt
; Function compile flags: /Ogtpy
;	COMDAT ?GetValueAt@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPA_WH@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
?GetValueAt@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPA_WH@Z PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::GetValueAt, COMDAT
; _this$ = ecx

; 410  : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
; 411  : 		if(nIndex < 0 || nIndex >= m_nSize)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nIndex$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 0e		 jl	 SHORT $LN1@GetValueAt
  00008	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0000b	7d 09		 jge	 SHORT $LN1@GetValueAt

; 412  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);	
; 413  : 			
; 414  : 		return m_aVal[nIndex];

  0000d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00010	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 415  : 	}

  00013	c2 04 00	 ret	 4
$LN1@GetValueAt:
  00016	6a 00		 push	 0
  00018	6a 00		 push	 0
  0001a	6a 01		 push	 1
  0001c	68 8c 00 00 c0	 push	 -1073741684		; c000008cH
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RaiseException@16
$LN7@GetValueAt:
  00027	cc		 int	 3
?GetValueAt@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPA_WH@Z ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::GetValueAt
_TEXT	ENDS
PUBLIC	??0?$CAutoVectorPtr@D@ATL@@QAE@XZ		; ATL::CAutoVectorPtr<char>::CAutoVectorPtr<char>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??0?$CAutoVectorPtr@D@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CAutoVectorPtr@D@ATL@@QAE@XZ PROC			; ATL::CAutoVectorPtr<char>::CAutoVectorPtr<char>, COMDAT
; _this$ = ecx

; 605  : 	{

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 606  : 	}

  00008	c3		 ret	 0
??0?$CAutoVectorPtr@D@ATL@@QAE@XZ ENDP			; ATL::CAutoVectorPtr<char>::CAutoVectorPtr<char>
_TEXT	ENDS
PUBLIC	?Attach@?$CAutoVectorPtr@D@ATL@@QAEXPAD@Z	; ATL::CAutoVectorPtr<char>::Attach
; Function compile flags: /Ogtpy
;	COMDAT ?Attach@?$CAutoVectorPtr@D@ATL@@QAEXPAD@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?Attach@?$CAutoVectorPtr@D@ATL@@QAEXPAD@Z PROC		; ATL::CAutoVectorPtr<char>::Attach, COMDAT
; _this$ = ecx

; 686  : 		ATLASSUME( m_p == NULL );
; 687  : 		m_p = p;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _p$[esp-4]
  00004	89 01		 mov	 DWORD PTR [ecx], eax

; 688  : 	}

  00006	c2 04 00	 ret	 4
?Attach@?$CAutoVectorPtr@D@ATL@@QAEXPAD@Z ENDP		; ATL::CAutoVectorPtr<char>::Attach
_TEXT	ENDS
PUBLIC	?Detach@?$CAutoVectorPtr@D@ATL@@QAEPADXZ	; ATL::CAutoVectorPtr<char>::Detach
; Function compile flags: /Ogtpy
;	COMDAT ?Detach@?$CAutoVectorPtr@D@ATL@@QAEPADXZ
_TEXT	SEGMENT
?Detach@?$CAutoVectorPtr@D@ATL@@QAEPADXZ PROC		; ATL::CAutoVectorPtr<char>::Detach, COMDAT
; _this$ = ecx

; 692  : 		T* p;
; 693  : 
; 694  : 		p = m_p;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 695  : 		m_p = NULL;

  00002	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 696  : 
; 697  : 		return( p );
; 698  : 	}

  00008	c3		 ret	 0
?Detach@?$CAutoVectorPtr@D@ATL@@QAEPADXZ ENDP		; ATL::CAutoVectorPtr<char>::Detach
_TEXT	ENDS
PUBLIC	??0?$CAutoVectorPtr@_W@ATL@@QAE@XZ		; ATL::CAutoVectorPtr<wchar_t>::CAutoVectorPtr<wchar_t>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$CAutoVectorPtr@_W@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CAutoVectorPtr@_W@ATL@@QAE@XZ PROC			; ATL::CAutoVectorPtr<wchar_t>::CAutoVectorPtr<wchar_t>, COMDAT
; _this$ = ecx

; 605  : 	{

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 606  : 	}

  00008	c3		 ret	 0
??0?$CAutoVectorPtr@_W@ATL@@QAE@XZ ENDP			; ATL::CAutoVectorPtr<wchar_t>::CAutoVectorPtr<wchar_t>
_TEXT	ENDS
PUBLIC	?Attach@?$CAutoVectorPtr@_W@ATL@@QAEXPA_W@Z	; ATL::CAutoVectorPtr<wchar_t>::Attach
; Function compile flags: /Ogtpy
;	COMDAT ?Attach@?$CAutoVectorPtr@_W@ATL@@QAEXPA_W@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?Attach@?$CAutoVectorPtr@_W@ATL@@QAEXPA_W@Z PROC	; ATL::CAutoVectorPtr<wchar_t>::Attach, COMDAT
; _this$ = ecx

; 686  : 		ATLASSUME( m_p == NULL );
; 687  : 		m_p = p;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _p$[esp-4]
  00004	89 01		 mov	 DWORD PTR [ecx], eax

; 688  : 	}

  00006	c2 04 00	 ret	 4
?Attach@?$CAutoVectorPtr@_W@ATL@@QAEXPA_W@Z ENDP	; ATL::CAutoVectorPtr<wchar_t>::Attach
_TEXT	ENDS
PUBLIC	?Detach@?$CAutoVectorPtr@_W@ATL@@QAEPA_WXZ	; ATL::CAutoVectorPtr<wchar_t>::Detach
; Function compile flags: /Ogtpy
;	COMDAT ?Detach@?$CAutoVectorPtr@_W@ATL@@QAEPA_WXZ
_TEXT	SEGMENT
?Detach@?$CAutoVectorPtr@_W@ATL@@QAEPA_WXZ PROC		; ATL::CAutoVectorPtr<wchar_t>::Detach, COMDAT
; _this$ = ecx

; 692  : 		T* p;
; 693  : 
; 694  : 		p = m_p;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 695  : 		m_p = NULL;

  00002	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 696  : 
; 697  : 		return( p );
; 698  : 	}

  00008	c3		 ret	 0
?Detach@?$CAutoVectorPtr@_W@ATL@@QAEPA_WXZ ENDP		; ATL::CAutoVectorPtr<wchar_t>::Detach
_TEXT	ENDS
PUBLIC	??0?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::CTempBuffer<char,1024,ATL::CCRTAllocator>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??0?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::CTempBuffer<char,1024,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 455  : 	{

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 456  : 	}

  00008	c3		 ret	 0
??0?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::CTempBuffer<char,1024,ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	??B?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::operator char *
; Function compile flags: /Ogtpy
;	COMDAT ??B?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT
??B?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ PROC ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::operator char *, COMDAT
; _this$ = ecx

; 473  : 		return( m_p );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 474  : 	}

  00002	c3		 ret	 0
??B?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ENDP ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::operator char *
_TEXT	ENDS
PUBLIC	??0?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::CTempBuffer<char,256,ATL::CCRTAllocator>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::CTempBuffer<char,256,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 455  : 	{

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 456  : 	}

  00008	c3		 ret	 0
??0?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::CTempBuffer<char,256,ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	??B?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::operator char *
; Function compile flags: /Ogtpy
;	COMDAT ??B?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT
??B?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ PROC ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::operator char *, COMDAT
; _this$ = ecx

; 473  : 		return( m_p );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 474  : 	}

  00002	c3		 ret	 0
??B?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ENDP ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::operator char *
_TEXT	ENDS
PUBLIC	??0?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 455  : 	{

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 456  : 	}

  00008	c3		 ret	 0
??0?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	??B?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPAEXZ ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::operator unsigned char *
; Function compile flags: /Ogtpy
;	COMDAT ??B?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPAEXZ
_TEXT	SEGMENT
??B?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPAEXZ PROC ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::operator unsigned char *, COMDAT
; _this$ = ecx

; 473  : 		return( m_p );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 474  : 	}

  00002	c3		 ret	 0
??B?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPAEXZ ENDP ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::operator unsigned char *
_TEXT	ENDS
PUBLIC	??1?$CComPtrBase@UITypeLib@@@ATL@@QAE@XZ	; ATL::CComPtrBase<ITypeLib>::~CComPtrBase<ITypeLib>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UITypeLib@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UITypeLib@@@ATL@@QAE@XZ PROC		; ATL::CComPtrBase<ITypeLib>::~CComPtrBase<ITypeLib>, COMDAT
; _this$ = ecx

; 151  : 		if (p)

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	85 c0		 test	 eax, eax
  00004	74 08		 je	 SHORT $LN1@CComPtrBas

; 152  : 			p->Release();

  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0000b	50		 push	 eax
  0000c	ff d2		 call	 edx
$LN1@CComPtrBas:

; 153  : 	}

  0000e	c3		 ret	 0
??1?$CComPtrBase@UITypeLib@@@ATL@@QAE@XZ ENDP		; ATL::CComPtrBase<ITypeLib>::~CComPtrBase<ITypeLib>
_TEXT	ENDS
PUBLIC	??B?$CComPtrBase@UITypeLib@@@ATL@@QBEPAUITypeLib@@XZ ; ATL::CComPtrBase<ITypeLib>::operator ITypeLib *
; Function compile flags: /Ogtpy
;	COMDAT ??B?$CComPtrBase@UITypeLib@@@ATL@@QBEPAUITypeLib@@XZ
_TEXT	SEGMENT
??B?$CComPtrBase@UITypeLib@@@ATL@@QBEPAUITypeLib@@XZ PROC ; ATL::CComPtrBase<ITypeLib>::operator ITypeLib *, COMDAT
; _this$ = ecx

; 156  : 		return p;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 157  : 	}

  00002	c3		 ret	 0
??B?$CComPtrBase@UITypeLib@@@ATL@@QBEPAUITypeLib@@XZ ENDP ; ATL::CComPtrBase<ITypeLib>::operator ITypeLib *
_TEXT	ENDS
PUBLIC	??I?$CComPtrBase@UITypeLib@@@ATL@@QAEPAPAUITypeLib@@XZ ; ATL::CComPtrBase<ITypeLib>::operator&
; Function compile flags: /Ogtpy
;	COMDAT ??I?$CComPtrBase@UITypeLib@@@ATL@@QAEPAPAUITypeLib@@XZ
_TEXT	SEGMENT
??I?$CComPtrBase@UITypeLib@@@ATL@@QAEPAPAUITypeLib@@XZ PROC ; ATL::CComPtrBase<ITypeLib>::operator&, COMDAT
; _this$ = ecx

; 166  : 	{

  00000	8b c1		 mov	 eax, ecx

; 167  : 		ATLASSERT(p==NULL);
; 168  : 		return &p;
; 169  : 	}

  00002	c3		 ret	 0
??I?$CComPtrBase@UITypeLib@@@ATL@@QAEPAPAUITypeLib@@XZ ENDP ; ATL::CComPtrBase<ITypeLib>::operator&
_TEXT	ENDS
PUBLIC	?FindKey@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHABQAD@Z ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::FindKey
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?FindKey@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHABQAD@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
?FindKey@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHABQAD@Z PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::FindKey, COMDAT
; _this$ = ecx

; 418  : 	{

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi
  00003	57		 push	 edi
  00004	8b f9		 mov	 edi, ecx

; 419  : 		for(int i = 0; i < m_nSize; i++)

  00006	33 f6		 xor	 esi, esi
  00008	39 77 08	 cmp	 DWORD PTR [edi+8], esi
  0000b	7e 1f		 jle	 SHORT $LN2@FindKey
  0000d	8b 5c 24 14	 mov	 ebx, DWORD PTR _key$[esp+12]
  00011	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__lstrcmpiA@8
$LL4@FindKey:

; 420  : 		{
; 421  : 			if(TEqual::IsEqualKey(m_aKey[i], key))

  00017	8b 03		 mov	 eax, DWORD PTR [ebx]
  00019	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0001b	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  0001e	50		 push	 eax
  0001f	51		 push	 ecx
  00020	ff d5		 call	 ebp
  00022	85 c0		 test	 eax, eax
  00024	74 10		 je	 SHORT $LN11@FindKey
  00026	46		 inc	 esi
  00027	3b 77 08	 cmp	 esi, DWORD PTR [edi+8]
  0002a	7c eb		 jl	 SHORT $LL4@FindKey
$LN2@FindKey:
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5d		 pop	 ebp

; 423  : 		}
; 424  : 		return -1;  // not found

  0002f	83 c8 ff	 or	 eax, -1
  00032	5b		 pop	 ebx

; 425  : 	}

  00033	c2 04 00	 ret	 4
$LN11@FindKey:
  00036	5f		 pop	 edi

; 422  : 				return i;

  00037	8b c6		 mov	 eax, esi
  00039	5e		 pop	 esi
  0003a	5d		 pop	 ebp
  0003b	5b		 pop	 ebx

; 425  : 	}

  0003c	c2 04 00	 ret	 4
?FindKey@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHABQAD@Z ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::FindKey
_TEXT	ENDS
PUBLIC	?Free@?$CAutoVectorPtr@D@ATL@@QAEXXZ		; ATL::CAutoVectorPtr<char>::Free
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?Free@?$CAutoVectorPtr@D@ATL@@QAEXXZ
_TEXT	SEGMENT
?Free@?$CAutoVectorPtr@D@ATL@@QAEXXZ PROC		; ATL::CAutoVectorPtr<char>::Free, COMDAT
; _this$ = ecx

; 701  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 702  : 		delete[] m_p;

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0000b	83 c4 04	 add	 esp, 4

; 703  : 		m_p = NULL;

  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	5e		 pop	 esi

; 704  : 	}

  00015	c3		 ret	 0
?Free@?$CAutoVectorPtr@D@ATL@@QAEXXZ ENDP		; ATL::CAutoVectorPtr<char>::Free
_TEXT	ENDS
PUBLIC	?Free@?$CAutoVectorPtr@_W@ATL@@QAEXXZ		; ATL::CAutoVectorPtr<wchar_t>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$CAutoVectorPtr@_W@ATL@@QAEXXZ
_TEXT	SEGMENT
?Free@?$CAutoVectorPtr@_W@ATL@@QAEXXZ PROC		; ATL::CAutoVectorPtr<wchar_t>::Free, COMDAT
; _this$ = ecx

; 701  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 702  : 		delete[] m_p;

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0000b	83 c4 04	 add	 esp, 4

; 703  : 		m_p = NULL;

  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	5e		 pop	 esi

; 704  : 	}

  00015	c3		 ret	 0
?Free@?$CAutoVectorPtr@_W@ATL@@QAEXXZ ENDP		; ATL::CAutoVectorPtr<wchar_t>::Free
_TEXT	ENDS
PUBLIC	?FreeHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::FreeHeap
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT
?FreeHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ PROC ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::FreeHeap, COMDAT
; _this$ = ecx

; 558  : 		Allocator::Free( m_p );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	50		 push	 eax
  00003	e8 00 00 00 00	 call	 _free
  00008	59		 pop	 ecx

; 559  : 	}

  00009	c3		 ret	 0
?FreeHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ENDP ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::FreeHeap
_TEXT	ENDS
PUBLIC	?FreeHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::FreeHeap
; Function compile flags: /Ogtpy
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT
?FreeHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ PROC ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::FreeHeap, COMDAT
; _this$ = ecx

; 558  : 		Allocator::Free( m_p );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	50		 push	 eax
  00003	e8 00 00 00 00	 call	 _free
  00008	59		 pop	 ecx

; 559  : 	}

  00009	c3		 ret	 0
?FreeHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ENDP ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::FreeHeap
_TEXT	ENDS
PUBLIC	?FreeHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::FreeHeap
; Function compile flags: /Ogtpy
;	COMDAT ?FreeHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT
?FreeHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ PROC ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::FreeHeap, COMDAT
; _this$ = ecx

; 558  : 		Allocator::Free( m_p );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	50		 push	 eax
  00003	e8 00 00 00 00	 call	 _free
  00008	59		 pop	 ecx

; 559  : 	}

  00009	c3		 ret	 0
?FreeHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ENDP ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::FreeHeap
_TEXT	ENDS
PUBLIC	??0?$CComPtrBase@UITypeLib@@@ATL@@IAE@XZ	; ATL::CComPtrBase<ITypeLib>::CComPtrBase<ITypeLib>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UITypeLib@@@ATL@@IAE@XZ
_TEXT	SEGMENT
??0?$CComPtrBase@UITypeLib@@@ATL@@IAE@XZ PROC		; ATL::CComPtrBase<ITypeLib>::CComPtrBase<ITypeLib>, COMDAT
; _this$ = ecx

; 131  : 	CComPtrBase() throw()

  00000	8b c1		 mov	 eax, ecx

; 132  : 	{
; 133  : 		p = NULL;

  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 134  : 	}

  00008	c3		 ret	 0
??0?$CComPtrBase@UITypeLib@@@ATL@@IAE@XZ ENDP		; ATL::CComPtrBase<ITypeLib>::CComPtrBase<ITypeLib>
_TEXT	ENDS
PUBLIC	?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ
_TEXT	SEGMENT
?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ PROC ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData, COMDAT
; _this$ = ecx

; 633  : 			return (this + 1);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 634  : 		}

  00003	c3		 ret	 0
?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
_TEXT	ENDS
PUBLIC	?AllocateHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::AllocateHeap
; Function compile flags: /Ogtpy
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?AllocateHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z PROC ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::AllocateHeap, COMDAT
; _this$ = ecx

; 538  : 		T* p = static_cast< T* >( Allocator::Allocate( nBytes ) );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nBytes$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 _malloc
  0000d	83 c4 04	 add	 esp, 4

; 539  : 		if( p == NULL )

  00010	85 c0		 test	 eax, eax
  00012	75 0a		 jne	 SHORT $LN1@AllocateHe

; 540  : 		{
; 541  : 			AtlThrow( E_OUTOFMEMORY );

  00014	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  00019	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN1@AllocateHe:

; 542  : 		}
; 543  : 		m_p = p;

  0001e	89 06		 mov	 DWORD PTR [esi], eax
  00020	5e		 pop	 esi

; 544  : 	}

  00021	c2 04 00	 ret	 4
$LN6@AllocateHe:
?AllocateHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ENDP ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::AllocateHeap
_TEXT	ENDS
PUBLIC	?AllocateHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::AllocateHeap
; Function compile flags: /Ogtpy
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?AllocateHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z PROC ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::AllocateHeap, COMDAT
; _this$ = ecx

; 538  : 		T* p = static_cast< T* >( Allocator::Allocate( nBytes ) );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nBytes$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 _malloc
  0000d	83 c4 04	 add	 esp, 4

; 539  : 		if( p == NULL )

  00010	85 c0		 test	 eax, eax
  00012	75 0a		 jne	 SHORT $LN1@AllocateHe@2

; 540  : 		{
; 541  : 			AtlThrow( E_OUTOFMEMORY );

  00014	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  00019	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN1@AllocateHe@2:

; 542  : 		}
; 543  : 		m_p = p;

  0001e	89 06		 mov	 DWORD PTR [esi], eax
  00020	5e		 pop	 esi

; 544  : 	}

  00021	c2 04 00	 ret	 4
$LN6@AllocateHe@2:
?AllocateHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ENDP ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::AllocateHeap
_TEXT	ENDS
PUBLIC	?AllocateHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::AllocateHeap
; Function compile flags: /Ogtpy
;	COMDAT ?AllocateHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?AllocateHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z PROC ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::AllocateHeap, COMDAT
; _this$ = ecx

; 538  : 		T* p = static_cast< T* >( Allocator::Allocate( nBytes ) );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nBytes$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 _malloc
  0000d	83 c4 04	 add	 esp, 4

; 539  : 		if( p == NULL )

  00010	85 c0		 test	 eax, eax
  00012	75 0a		 jne	 SHORT $LN1@AllocateHe@3

; 540  : 		{
; 541  : 			AtlThrow( E_OUTOFMEMORY );

  00014	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  00019	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN1@AllocateHe@3:

; 542  : 		}
; 543  : 		m_p = p;

  0001e	89 06		 mov	 DWORD PTR [esi], eax
  00020	5e		 pop	 esi

; 544  : 	}

  00021	c2 04 00	 ret	 4
$LN6@AllocateHe@3:
?AllocateHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ENDP ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::AllocateHeap
_TEXT	ENDS
PUBLIC	??0?$Wrapper@PAD@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@ABQAD@Z ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Wrapper<char *>::Wrapper<char *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??0?$Wrapper@PAD@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@ABQAD@Z
_TEXT	SEGMENT
__t$ = 8						; size = 4
??0?$Wrapper@PAD@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@ABQAD@Z PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Wrapper<char *>::Wrapper<char *>, COMDAT
; _this$ = ecx

; 452  : 		{

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __t$[esp-4]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	89 10		 mov	 DWORD PTR [eax], edx

; 453  : 		}

  0000a	c2 04 00	 ret	 4
??0?$Wrapper@PAD@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@ABQAD@Z ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Wrapper<char *>::Wrapper<char *>
_TEXT	ENDS
PUBLIC	??0?$Wrapper@PA_W@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@ABQA_W@Z ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Wrapper<wchar_t *>::Wrapper<wchar_t *>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$Wrapper@PA_W@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@ABQA_W@Z
_TEXT	SEGMENT
__t$ = 8						; size = 4
??0?$Wrapper@PA_W@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@ABQA_W@Z PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Wrapper<wchar_t *>::Wrapper<wchar_t *>, COMDAT
; _this$ = ecx

; 452  : 		{

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __t$[esp-4]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	89 10		 mov	 DWORD PTR [eax], edx

; 453  : 		}

  0000a	c2 04 00	 ret	 4
??0?$Wrapper@PA_W@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@ABQA_W@Z ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Wrapper<wchar_t *>::Wrapper<wchar_t *>
_TEXT	ENDS
PUBLIC	??$AtlAdd@K@ATL@@YAJPAKKK@Z			; ATL::AtlAdd<unsigned long>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlAdd@K@ATL@@YAJPAKKK@Z
_TEXT	SEGMENT
_ptResult$ = 8						; size = 4
_tLeft$ = 12						; size = 4
_tRight$ = 16						; size = 4
??$AtlAdd@K@ATL@@YAJPAKKK@Z PROC			; ATL::AtlAdd<unsigned long>, COMDAT

; 96   : 	if(::ATL::AtlLimits<T>::_Max-tLeft < tRight)

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _tLeft$[esp-4]
  00004	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tRight$[esp-4]
  00008	83 ca ff	 or	 edx, -1
  0000b	2b d0		 sub	 edx, eax
  0000d	3b d1		 cmp	 edx, ecx
  0000f	73 06		 jae	 SHORT $LN1@AtlAdd

; 97   : 	{
; 98   : 		return E_INVALIDARG;

  00011	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H

; 102  : }

  00016	c3		 ret	 0
$LN1@AtlAdd:

; 99   : 	}
; 100  : 	*ptResult= tLeft + tRight;

  00017	03 c1		 add	 eax, ecx
  00019	8b 4c 24 04	 mov	 ecx, DWORD PTR _ptResult$[esp-4]
  0001d	89 01		 mov	 DWORD PTR [ecx], eax

; 101  : 	return S_OK;

  0001f	33 c0		 xor	 eax, eax

; 102  : }

  00021	c3		 ret	 0
??$AtlAdd@K@ATL@@YAJPAKKK@Z ENDP			; ATL::AtlAdd<unsigned long>
_TEXT	ENDS
PUBLIC	??$AtlAddThrow@K@ATL@@YAKKK@Z			; ATL::AtlAddThrow<unsigned long>
; Function compile flags: /Ogtpy
;	COMDAT ??$AtlAddThrow@K@ATL@@YAKKK@Z
_TEXT	SEGMENT
_tLeft$ = 8						; size = 4
_tRight$ = 12						; size = 4
??$AtlAddThrow@K@ATL@@YAKKK@Z PROC			; ATL::AtlAddThrow<unsigned long>, COMDAT

; 186  : 	T tResult;
; 187  : 	HRESULT hr=AtlAdd(&tResult, tLeft, tRight);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _tLeft$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR _tRight$[esp-4]
  00008	83 ca ff	 or	 edx, -1
  0000b	2b d0		 sub	 edx, eax
  0000d	3b d1		 cmp	 edx, ecx
  0000f	72 03		 jb	 SHORT $LN7@AtlAddThro
  00011	03 c1		 add	 eax, ecx

; 188  : 	if(FAILED(hr))
; 189  : 	{
; 190  : 		AtlThrow(hr);
; 191  : 	}
; 192  : 	return tResult;
; 193  : }

  00013	c3		 ret	 0
$LN7@AtlAddThro:
  00014	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00019	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN8@AtlAddThro:
  0001e	cc		 int	 3
??$AtlAddThrow@K@ATL@@YAKKK@Z ENDP			; ATL::AtlAddThrow<unsigned long>
_TEXT	ENDS
PUBLIC	??$AtlMultiplyThrow@I@ATL@@YAIII@Z		; ATL::AtlMultiplyThrow<unsigned int>
; Function compile flags: /Ogtpy
;	COMDAT ??$AtlMultiplyThrow@I@ATL@@YAIII@Z
_TEXT	SEGMENT
_tLeft$ = 8						; size = 4
_tRight$ = 12						; size = 4
??$AtlMultiplyThrow@I@ATL@@YAIII@Z PROC			; ATL::AtlMultiplyThrow<unsigned int>, COMDAT

; 174  : 	T tResult;
; 175  : 	HRESULT hr=AtlMultiply(&tResult, tLeft, tRight);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _tLeft$[esp-4]
  00004	f7 64 24 08	 mul	 DWORD PTR _tRight$[esp-4]
  00008	85 d2		 test	 edx, edx
  0000a	77 05		 ja	 SHORT $LN8@AtlMultipl@4
  0000c	83 f8 ff	 cmp	 eax, -1

; 176  : 	if(FAILED(hr))

  0000f	76 0a		 jbe	 SHORT $LN2@AtlMultipl@4
$LN8@AtlMultipl@4:

; 177  : 	{
; 178  : 		AtlThrow(hr);

  00011	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00016	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN2@AtlMultipl@4:

; 179  : 	}
; 180  : 	return tResult;
; 181  : }

  0001b	c3		 ret	 0
$LN9@AtlMultipl@4:
??$AtlMultiplyThrow@I@ATL@@YAIII@Z ENDP			; ATL::AtlMultiplyThrow<unsigned int>
_TEXT	ENDS
PUBLIC	??$?2PAD@?$Wrapper@PAD@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAPAXIPAPAD@Z ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Wrapper<char *>::operator new<char *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??$?2PAD@?$Wrapper@PAD@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAPAXIPAPAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_p$ = 12						; size = 4
??$?2PAD@?$Wrapper@PAD@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAPAXIPAPAD@Z PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Wrapper<char *>::operator new<char *>, COMDAT

; 456  : 		{
; 457  : 			return p;

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _p$[esp-4]

; 458  : 		}

  00004	c3		 ret	 0
??$?2PAD@?$Wrapper@PAD@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAPAXIPAPAD@Z ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Wrapper<char *>::operator new<char *>
_TEXT	ENDS
PUBLIC	??$?3PAD@?$Wrapper@PAD@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAXPAXPAPAD@Z ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Wrapper<char *>::operator delete<char *>
; Function compile flags: /Ogtpy
;	COMDAT ??$?3PAD@?$Wrapper@PAD@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAXPAXPAPAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?3PAD@?$Wrapper@PAD@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAXPAXPAPAD@Z PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Wrapper<char *>::operator delete<char *>, COMDAT

; 461  : 		{
; 462  : 		}

  00000	c3		 ret	 0
??$?3PAD@?$Wrapper@PAD@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAXPAXPAPAD@Z ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Wrapper<char *>::operator delete<char *>
_TEXT	ENDS
PUBLIC	??$?2PA_W@?$Wrapper@PA_W@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAPAXIPAPA_W@Z ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Wrapper<wchar_t *>::operator new<wchar_t *>
; Function compile flags: /Ogtpy
;	COMDAT ??$?2PA_W@?$Wrapper@PA_W@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAPAXIPAPA_W@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_p$ = 12						; size = 4
??$?2PA_W@?$Wrapper@PA_W@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAPAXIPAPA_W@Z PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Wrapper<wchar_t *>::operator new<wchar_t *>, COMDAT

; 456  : 		{
; 457  : 			return p;

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _p$[esp-4]

; 458  : 		}

  00004	c3		 ret	 0
??$?2PA_W@?$Wrapper@PA_W@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAPAXIPAPA_W@Z ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Wrapper<wchar_t *>::operator new<wchar_t *>
_TEXT	ENDS
PUBLIC	??$?3PA_W@?$Wrapper@PA_W@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAXPAXPAPA_W@Z ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Wrapper<wchar_t *>::operator delete<wchar_t *>
; Function compile flags: /Ogtpy
;	COMDAT ??$?3PA_W@?$Wrapper@PA_W@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAXPAXPAPA_W@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?3PA_W@?$Wrapper@PA_W@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAXPAXPAPA_W@Z PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Wrapper<wchar_t *>::operator delete<wchar_t *>, COMDAT

; 461  : 		{
; 462  : 		}

  00000	c3		 ret	 0
??$?3PA_W@?$Wrapper@PA_W@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@SAXPAXPAPA_W@Z ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Wrapper<wchar_t *>::operator delete<wchar_t *>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
EXTRN	__resetstkoflw:PROC
EXTRN	__alloca_probe_16:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlalloc.h
xdata$x	SEGMENT
__sehtable$?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z DD 0ffffffe4H
	DD	00H
	DD	0ffffffccH
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN7@AtlVerifyS
	DD	FLAT:$LN8@AtlVerifyS
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z
_TEXT	SEGMENT
_size$68575 = -36					; size = 4
_bStackAvailable$ = -29					; size = 1
__$ArrayPad$ = -28					; size = 4
__$SEHRec$ = -24					; size = 24
_Size$ = 8						; size = 4
?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z PROC ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable, COMDAT

; 585  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 14	 sub	 esp, 20			; 00000014H
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 e4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	50		 push	 eax
  0002a	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp

; 586  :     bool bStackAvailable = true;

  00036	b3 01		 mov	 bl, 1

; 587  : 
; 588  :     __try

  00038	33 f6		 xor	 esi, esi
  0003a	89 75 fc	 mov	 DWORD PTR __$SEHRec$[ebp+20], esi

; 589  :     {
; 590  : 		SIZE_T size=0;

  0003d	89 75 dc	 mov	 DWORD PTR _size$68575[ebp], esi

; 591  : 		HRESULT hrAdd=::ATL::AtlAdd(&size, Size, static_cast<SIZE_T>(_ATL_STACK_MARGIN));

  00040	68 00 20 00 00	 push	 8192			; 00002000H
  00045	8b 45 08	 mov	 eax, DWORD PTR _Size$[ebp]
  00048	50		 push	 eax
  00049	8d 4d dc	 lea	 ecx, DWORD PTR _size$68575[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$AtlAdd@K@ATL@@YAJPAKKK@Z ; ATL::AtlAdd<unsigned long>
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH

; 592  : 		if(FAILED(hrAdd))

  00055	3b c6		 cmp	 eax, esi
  00057	7d 07		 jge	 SHORT $LN2@AtlVerifyS

; 593  : 		{
; 594  : 			ATLASSERT(FALSE);
; 595  : 			bStackAvailable = false;

  00059	32 db		 xor	 bl, bl
  0005b	88 5d e3	 mov	 BYTE PTR _bStackAvailable$[ebp], bl

; 596  : 		}
; 597  : 		else

  0005e	eb 2e		 jmp	 SHORT $LN1@AtlVerifyS
$LN2@AtlVerifyS:

; 598  : 		{
; 599  : 			PVOID p = _alloca(size);

  00060	8b 45 dc	 mov	 eax, DWORD PTR _size$68575[ebp]
  00063	e8 00 00 00 00	 call	 __alloca_probe_16
  00068	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp

; 600  : 			(p);
; 601  : 		}
; 602  :     }

  0006b	eb 21		 jmp	 SHORT $LN1@AtlVerifyS
$LN7@AtlVerifyS:

; 603  :     __except ((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
; 604  :                    EXCEPTION_EXECUTE_HANDLER :
; 605  :                    EXCEPTION_CONTINUE_SEARCH)

  0006d	8b 55 ec	 mov	 edx, DWORD PTR __$SEHRec$[ebp+4]
  00070	8b 02		 mov	 eax, DWORD PTR [edx]
  00072	8b 00		 mov	 eax, DWORD PTR [eax]
  00074	33 c9		 xor	 ecx, ecx
  00076	3d fd 00 00 c0	 cmp	 eax, -1073741571	; c00000fdH
  0007b	0f 94 c1	 sete	 cl
  0007e	8b c1		 mov	 eax, ecx
$LN9@AtlVerifyS:
  00080	c3		 ret	 0
$LN8@AtlVerifyS:
  00081	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 606  :     {
; 607  :         bStackAvailable = false;

  00084	32 db		 xor	 bl, bl
  00086	88 5d e3	 mov	 BYTE PTR _bStackAvailable$[ebp], bl

; 608  :         _resetstkoflw();

  00089	e8 00 00 00 00	 call	 __resetstkoflw
$LN1@AtlVerifyS:

; 609  :     }

  0008e	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH

; 610  :     return bStackAvailable;

  00095	8a c3		 mov	 al, bl

; 611  : }

  00097	8d 65 cc	 lea	 esp, DWORD PTR [ebp-52]
  0009a	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  0009d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a4	59		 pop	 ecx
  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	5b		 pop	 ebx
  000a8	8b 4d e4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ab	33 cd		 xor	 ecx, ebp
  000ad	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c3		 ret	 0
?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
_TEXT	ENDS
PUBLIC	??1CRegKey@ATL@@QAE@XZ				; ATL::CRegKey::~CRegKey
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??1CRegKey@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CRegKey@ATL@@QAE@XZ PROC				; ATL::CRegKey::~CRegKey, COMDAT
; _this$ = ecx

; 5205 : {Close();}

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 0d		 je	 SHORT $LN6@CRegKey
  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  00010	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN6@CRegKey:
  00016	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001d	5e		 pop	 esi
  0001e	c3		 ret	 0
??1CRegKey@ATL@@QAE@XZ ENDP				; ATL::CRegKey::~CRegKey
_TEXT	ENDS
PUBLIC	_lpszKey$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?RecurseDeleteKey@CRegKey@ATL@@QAEJPBD@Z	; ATL::CRegKey::RecurseDeleteKey
EXTRN	__imp__RegEnumKeyExA@32:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?RecurseDeleteKey@CRegKey@ATL@@QAEJPBD@Z
_TEXT	SEGMENT
_key$ = -296						; size = 8
_dwSize$ = -288						; size = 4
_hKey$111000 = -284					; size = 4
_this$GSCopy$ = -280					; size = 4
_lpszKey$GSCopy$ = -276					; size = 4
_time$ = -272						; size = 8
_szBuffer$ = -264					; size = 256
__$ArrayPad$ = -4					; size = 4
_lpszKey$ = 8						; size = 4
?RecurseDeleteKey@CRegKey@ATL@@QAEJPBD@Z PROC		; ATL::CRegKey::RecurseDeleteKey, COMDAT
; _this$ = ecx

; 5731 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00011	33 c4		 xor	 eax, esp
  00013	89 84 24 28 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+300], eax

; 5732 : 	CRegKey key;
; 5733 : 	LONG lRes = key.Open(m_hKey, lpszKey, KEY_READ | KEY_WRITE | m_samWOW64);

  0001a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001c	8b 55 08	 mov	 edx, DWORD PTR _lpszKey$[ebp]
  0001f	53		 push	 ebx
  00020	56		 push	 esi
  00021	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00024	57		 push	 edi

; 5752 : 	}
; 5753 : 	key.Close();

  00025	89 4c 24 20	 mov	 DWORD PTR _this$GSCopy$[esp+312], ecx
  00029	8d 4c 24 1c	 lea	 ecx, DWORD PTR _hKey$111000[esp+312]
  0002d	51		 push	 ecx
  0002e	33 db		 xor	 ebx, ebx
  00030	81 ce 1f 00 02
	00		 or	 esi, 131103		; 0002001fH
  00036	56		 push	 esi
  00037	53		 push	 ebx
  00038	52		 push	 edx
  00039	50		 push	 eax
  0003a	89 54 24 38	 mov	 DWORD PTR _lpszKey$GSCopy$[esp+332], edx
  0003e	89 5c 24 24	 mov	 DWORD PTR _key$[esp+332], ebx
  00042	89 5c 24 28	 mov	 DWORD PTR _key$[esp+336], ebx
  00046	89 5c 24 30	 mov	 DWORD PTR _hKey$111000[esp+332], ebx
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  00050	8b 4c 24 10	 mov	 ecx, DWORD PTR _key$[esp+312]
  00054	8b f8		 mov	 edi, eax
  00056	3b fb		 cmp	 edi, ebx
  00058	75 25		 jne	 SHORT $LN43@RecurseDel
  0005a	33 c0		 xor	 eax, eax
  0005c	3b cb		 cmp	 ecx, ebx
  0005e	74 07		 je	 SHORT $LN19@RecurseDel
  00060	51		 push	 ecx
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$LN19@RecurseDel:
  00067	8b 4c 24 1c	 mov	 ecx, DWORD PTR _hKey$111000[esp+312]
  0006b	81 e6 00 03 00
	00		 and	 esi, 768		; 00000300H
  00071	8b f8		 mov	 edi, eax
  00073	89 4c 24 10	 mov	 DWORD PTR _key$[esp+312], ecx
  00077	89 74 24 14	 mov	 DWORD PTR _key$[esp+316], esi
  0007b	3b c3		 cmp	 eax, ebx
  0007d	74 24		 je	 SHORT $LN5@RecurseDel
$LN43@RecurseDel:

; 5734 : 	if (lRes != ERROR_SUCCESS)
; 5735 : 	{
; 5736 : 		if (lRes != ERROR_FILE_NOT_FOUND && lRes != ERROR_PATH_NOT_FOUND)
; 5737 : 		{
; 5738 : 			ATLTRACE(atlTraceCOM, 0, _T("CRegKey::RecurseDeleteKey : Failed to Open Key %s(Error = %d)\n"), lpszKey, lRes);
; 5739 : 		}
; 5740 : 		return lRes;

  0007f	3b cb		 cmp	 ecx, ebx
  00081	74 07		 je	 SHORT $LN24@RecurseDel
  00083	51		 push	 ecx
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$LN24@RecurseDel:
  0008a	8b c7		 mov	 eax, edi

; 5755 : }

  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	8b 8c 24 28 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+300]
  00096	33 cc		 xor	 ecx, esp
  00098	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c2 04 00	 ret	 4
$LN5@RecurseDel:

; 5741 : 	}
; 5742 : 	FILETIME time;
; 5743 : 	DWORD dwSize = 256;
; 5744 : 	TCHAR szBuffer[256];
; 5745 : 	while (RegEnumKeyEx(key.m_hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL,
; 5746 : 		&time)==ERROR_SUCCESS)

  000a3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__RegEnumKeyExA@32
  000a9	8d 54 24 28	 lea	 edx, DWORD PTR _time$[esp+312]
  000ad	52		 push	 edx
  000ae	53		 push	 ebx
  000af	53		 push	 ebx
  000b0	53		 push	 ebx
  000b1	8d 44 24 28	 lea	 eax, DWORD PTR _dwSize$[esp+328]
  000b5	50		 push	 eax
  000b6	8d 54 24 44	 lea	 edx, DWORD PTR _szBuffer$[esp+332]
  000ba	52		 push	 edx
  000bb	53		 push	 ebx
  000bc	51		 push	 ecx
  000bd	c7 44 24 38 00
	01 00 00	 mov	 DWORD PTR _dwSize$[esp+344], 256 ; 00000100H
  000c5	ff d6		 call	 esi
  000c7	85 c0		 test	 eax, eax
  000c9	75 3f		 jne	 SHORT $LN2@RecurseDel
  000cb	eb 03 8d 49 00	 npad	 5
$LL3@RecurseDel:

; 5747 : 	{
; 5748 : 		lRes = key.RecurseDeleteKey(szBuffer);

  000d0	8d 44 24 30	 lea	 eax, DWORD PTR _szBuffer$[esp+312]
  000d4	50		 push	 eax
  000d5	8d 4c 24 14	 lea	 ecx, DWORD PTR _key$[esp+316]
  000d9	e8 00 00 00 00	 call	 ?RecurseDeleteKey@CRegKey@ATL@@QAEJPBD@Z ; ATL::CRegKey::RecurseDeleteKey
  000de	8b f8		 mov	 edi, eax

; 5749 : 		if (lRes != ERROR_SUCCESS)

  000e0	3b fb		 cmp	 edi, ebx
  000e2	75 75		 jne	 SHORT $LN41@RecurseDel
  000e4	8d 4c 24 28	 lea	 ecx, DWORD PTR _time$[esp+312]
  000e8	51		 push	 ecx
  000e9	8b 4c 24 14	 mov	 ecx, DWORD PTR _key$[esp+316]
  000ed	53		 push	 ebx
  000ee	53		 push	 ebx
  000ef	53		 push	 ebx
  000f0	8d 54 24 28	 lea	 edx, DWORD PTR _dwSize$[esp+328]
  000f4	52		 push	 edx
  000f5	8d 44 24 44	 lea	 eax, DWORD PTR _szBuffer$[esp+332]
  000f9	50		 push	 eax
  000fa	53		 push	 ebx
  000fb	51		 push	 ecx

; 5751 : 		dwSize = 256;

  000fc	c7 44 24 38 00
	01 00 00	 mov	 DWORD PTR _dwSize$[esp+344], 256 ; 00000100H
  00104	ff d6		 call	 esi
  00106	85 c0		 test	 eax, eax
  00108	74 c6		 je	 SHORT $LL3@RecurseDel
$LN2@RecurseDel:

; 5752 : 	}
; 5753 : 	key.Close();

  0010a	8b 44 24 10	 mov	 eax, DWORD PTR _key$[esp+312]
  0010e	3b c3		 cmp	 eax, ebx
  00110	74 0b		 je	 SHORT $LN32@RecurseDel
  00112	50		 push	 eax
  00113	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  00119	89 5c 24 10	 mov	 DWORD PTR _key$[esp+312], ebx
$LN32@RecurseDel:

; 5754 : 	return DeleteSubKey(lpszKey);

  0011d	8b 54 24 24	 mov	 edx, DWORD PTR _lpszKey$GSCopy$[esp+312]
  00121	8b 4c 24 20	 mov	 ecx, DWORD PTR _this$GSCopy$[esp+312]
  00125	52		 push	 edx
  00126	89 5c 24 18	 mov	 DWORD PTR _key$[esp+320], ebx
  0012a	e8 00 00 00 00	 call	 ?DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z ; ATL::CRegKey::DeleteSubKey
  0012f	8b f0		 mov	 esi, eax
  00131	8b 44 24 10	 mov	 eax, DWORD PTR _key$[esp+312]
  00135	3b c3		 cmp	 eax, ebx
  00137	74 07		 je	 SHORT $LN37@RecurseDel
  00139	50		 push	 eax
  0013a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$LN37@RecurseDel:
  00140	8b c6		 mov	 eax, esi

; 5755 : }

  00142	5f		 pop	 edi
  00143	5e		 pop	 esi
  00144	5b		 pop	 ebx
  00145	8b 8c 24 28 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+300]
  0014c	33 cc		 xor	 ecx, esp
  0014e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00153	8b e5		 mov	 esp, ebp
  00155	5d		 pop	 ebp
  00156	c2 04 00	 ret	 4
$LN41@RecurseDel:

; 5750 : 			return lRes;

  00159	8b 44 24 10	 mov	 eax, DWORD PTR _key$[esp+312]
  0015d	3b c3		 cmp	 eax, ebx
  0015f	74 07		 je	 SHORT $LN29@RecurseDel
  00161	50		 push	 eax
  00162	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$LN29@RecurseDel:

; 5755 : }

  00168	8b 8c 24 34 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+312]
  0016f	8b c7		 mov	 eax, edi
  00171	5f		 pop	 edi
  00172	5e		 pop	 esi
  00173	5b		 pop	 ebx
  00174	33 cc		 xor	 ecx, esp
  00176	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017b	8b e5		 mov	 esp, ebp
  0017d	5d		 pop	 ebp
  0017e	c2 04 00	 ret	 4
?RecurseDeleteKey@CRegKey@ATL@@QAEJPBD@Z ENDP		; ATL::CRegKey::RecurseDeleteKey
_TEXT	ENDS
PUBLIC	?ClearReplacements@CExpansionVector@ATL@@QAEJXZ	; ATL::CExpansionVector::ClearReplacements
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\statreg.h
;	COMDAT ?ClearReplacements@CExpansionVector@ATL@@QAEJXZ
_TEXT	SEGMENT
?ClearReplacements@CExpansionVector@ATL@@QAEJXZ PROC	; ATL::CExpansionVector::ClearReplacements, COMDAT
; _this$ = ecx

; 134  : 	{

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f1		 mov	 esi, ecx

; 135  : 		for (int i = 0; i < GetSize(); i++)

  00004	33 ff		 xor	 edi, edi
  00006	39 7e 08	 cmp	 DWORD PTR [esi+8], edi
  00009	7e 36		 jle	 SHORT $LN1@ClearRepla
  0000b	eb 03 8d 49 00	 npad	 5
$LL3@ClearRepla:

; 136  : 		{
; 137  : 			delete []GetKeyAt(i);

  00010	85 ff		 test	 edi, edi
  00012	7c 65		 jl	 SHORT $LN31@ClearRepla
  00014	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  00017	7d 60		 jge	 SHORT $LN31@ClearRepla
  00019	8b 06		 mov	 eax, DWORD PTR [esi]
  0001b	8b 0c b8	 mov	 ecx, DWORD PTR [eax+edi*4]
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00024	83 c4 04	 add	 esp, 4

; 138  : 			delete []GetValueAt(i);

  00027	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  0002a	7d 4d		 jge	 SHORT $LN31@ClearRepla
  0002c	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0002f	8b 04 ba	 mov	 eax, DWORD PTR [edx+edi*4]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00038	47		 inc	 edi
  00039	83 c4 04	 add	 esp, 4
  0003c	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  0003f	7c cf		 jl	 SHORT $LL3@ClearRepla
$LN1@ClearRepla:

; 139  : 		}
; 140  : 		RemoveAll();

  00041	8b 06		 mov	 eax, DWORD PTR [esi]
  00043	85 c0		 test	 eax, eax
  00045	74 0f		 je	 SHORT $LN25@ClearRepla
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _free
  0004d	83 c4 04	 add	 esp, 4
  00050	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN25@ClearRepla:
  00056	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00059	85 c0		 test	 eax, eax
  0005b	74 10		 je	 SHORT $LN21@ClearRepla
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 _free
  00063	83 c4 04	 add	 esp, 4
  00066	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
$LN21@ClearRepla:
  0006d	5f		 pop	 edi
  0006e	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 141  : 		return S_OK;

  00075	33 c0		 xor	 eax, eax
  00077	5e		 pop	 esi

; 142  : 	}

  00078	c3		 ret	 0
$LN31@ClearRepla:
  00079	6a 00		 push	 0
  0007b	6a 00		 push	 0
  0007d	6a 01		 push	 1
  0007f	68 8c 00 00 c0	 push	 -1073741684		; c000008cH
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RaiseException@16
$LN34@ClearRepla:
  0008a	cc		 int	 3
?ClearReplacements@CExpansionVector@ATL@@QAEJXZ ENDP	; ATL::CExpansionVector::ClearReplacements
_TEXT	ENDS
PUBLIC	?ClearReplacements@CRegObject@ATL@@UAGJXZ	; ATL::CRegObject::ClearReplacements
; Function compile flags: /Ogtpy
;	COMDAT ?ClearReplacements@CRegObject@ATL@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?ClearReplacements@CRegObject@ATL@@UAGJXZ PROC		; ATL::CRegObject::ClearReplacements, COMDAT

; 539  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 540  : 	m_csMap.Lock();

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _this$[esp+4]
  00006	8d 77 10	 lea	 esi, DWORD PTR [edi+16]
  00009	56		 push	 esi
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 541  : 	HRESULT hr = m_RepMap.ClearReplacements();

  00010	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00013	e8 00 00 00 00	 call	 ?ClearReplacements@CExpansionVector@ATL@@QAEJXZ ; ATL::CExpansionVector::ClearReplacements

; 542  : 	m_csMap.Unlock();

  00018	56		 push	 esi
  00019	8b f8		 mov	 edi, eax
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 543  : 	return hr;

  00021	8b c7		 mov	 eax, edi
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi

; 544  : }

  00025	c2 04 00	 ret	 4
?ClearReplacements@CRegObject@ATL@@UAGJXZ ENDP		; ATL::CRegObject::ClearReplacements
_TEXT	ENDS
PUBLIC	??0IRegistrarBase@@QAE@XZ			; IRegistrarBase::IRegistrarBase
; Function compile flags: /Ogtpy
;	COMDAT ??0IRegistrarBase@@QAE@XZ
_TEXT	SEGMENT
??0IRegistrarBase@@QAE@XZ PROC				; IRegistrarBase::IRegistrarBase, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0IRegistrarBase@@QAE@XZ ENDP				; IRegistrarBase::IRegistrarBase
_TEXT	ENDS
PUBLIC	??1?$CComPtr@UITypeLib@@@ATL@@QAE@XZ		; ATL::CComPtr<ITypeLib>::~CComPtr<ITypeLib>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$CComPtr@UITypeLib@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtr@UITypeLib@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<ITypeLib>::~CComPtr<ITypeLib>, COMDAT
; _this$ = ecx
  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	85 c0		 test	 eax, eax
  00004	74 08		 je	 SHORT $LN3@CComPtr
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0000b	50		 push	 eax
  0000c	ff d2		 call	 edx
$LN3@CComPtr:
  0000e	c3		 ret	 0
??1?$CComPtr@UITypeLib@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<ITypeLib>::~CComPtr<ITypeLib>
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_G_com_error@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_com_error@@UAEPAXI@Z PROC				; _com_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_com_error@@6B@
  0000c	85 c0		 test	 eax, eax
  0000e	74 08		 je	 SHORT $LN5@scalar
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00015	50		 push	 eax
  00016	ff d2		 call	 edx
$LN5@scalar:
  00018	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0001b	85 c0		 test	 eax, eax
  0001d	74 07		 je	 SHORT $LN4@scalar
  0001f	50		 push	 eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalFree@4
$LN4@scalar:
  00026	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0002b	74 09		 je	 SHORT $LN8@scalar
  0002d	56		 push	 esi
  0002e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00033	83 c4 04	 add	 esp, 4
$LN8@scalar:
  00036	8b c6		 mov	 eax, esi
  00038	5e		 pop	 esi
  00039	c2 04 00	 ret	 4
??_G_com_error@@UAEPAXI@Z ENDP				; _com_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?WCode@_com_error@@QBEGXZ			; _com_error::WCode
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\comdef.h
;	COMDAT ?WCode@_com_error@@QBEGXZ
_TEXT	SEGMENT
?WCode@_com_error@@QBEGXZ PROC				; _com_error::WCode, COMDAT
; _this$ = ecx

; 174  :     return HRESULTToWCode(m_hresult);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8d 88 00 fe fb
	7f		 lea	 ecx, DWORD PTR [eax+2147220992]
  00009	81 f9 ff fd 00
	00		 cmp	 ecx, 65023		; 0000fdffH
  0000f	77 09		 ja	 SHORT $LN5@WCode
  00011	05 00 fe ff ff	 add	 eax, -512		; fffffe00H
  00016	0f b7 c0	 movzx	 eax, ax

; 175  : }

  00019	c3		 ret	 0

; 174  :     return HRESULTToWCode(m_hresult);

$LN5@WCode:
  0001a	33 c0		 xor	 eax, eax

; 175  : }

  0001c	c3		 ret	 0
?WCode@_com_error@@QBEGXZ ENDP				; _com_error::WCode
_TEXT	ENDS
PUBLIC	??_C@_0BF@IPPGFENJ@Unknown?5error?50x?$CF0lX?$AA@ ; `string'
PUBLIC	??_C@_0BE@NNIJINN@IDispatch?5error?5?$CD?$CFd?$AA@ ; `string'
PUBLIC	?ErrorMessage@_com_error@@QBEPBDXZ		; _com_error::ErrorMessage
EXTRN	_sprintf_s:PROC
EXTRN	__imp__LocalAlloc@8:PROC
EXTRN	__imp__FormatMessageA@28:PROC
;	COMDAT ??_C@_0BF@IPPGFENJ@Unknown?5error?50x?$CF0lX?$AA@
CONST	SEGMENT
??_C@_0BF@IPPGFENJ@Unknown?5error?50x?$CF0lX?$AA@ DB 'Unknown error 0x%0l'
	DB	'X', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NNIJINN@IDispatch?5error?5?$CD?$CFd?$AA@
CONST	SEGMENT
??_C@_0BE@NNIJINN@IDispatch?5error?5?$CD?$CFd?$AA@ DB 'IDispatch error #%'
	DB	'd', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?ErrorMessage@_com_error@@QBEPBDXZ
_TEXT	SEGMENT
?ErrorMessage@_com_error@@QBEPBDXZ PROC			; _com_error::ErrorMessage, COMDAT
; _this$ = ecx

; 232  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 233  :     if (m_pszMsg == NULL) {

  00004	83 7f 0c 00	 cmp	 DWORD PTR [edi+12], 0
  00008	8d 77 0c	 lea	 esi, DWORD PTR [edi+12]
  0000b	0f 85 95 00 00
	00		 jne	 $LN21@ErrorMessa

; 234  :         FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|
; 235  :                           FORMAT_MESSAGE_FROM_SYSTEM|
; 236  :                           FORMAT_MESSAGE_IGNORE_INSERTS,
; 237  :                       NULL,
; 238  :                       m_hresult,
; 239  :                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
; 240  :                       (LPTSTR)&m_pszMsg,
; 241  :                       0,
; 242  :                       NULL);

  00011	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00014	6a 00		 push	 0
  00016	6a 00		 push	 0
  00018	56		 push	 esi
  00019	68 00 04 00 00	 push	 1024			; 00000400H
  0001e	50		 push	 eax
  0001f	6a 00		 push	 0
  00021	68 00 13 00 00	 push	 4864			; 00001300H
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FormatMessageA@28

; 243  :         if (m_pszMsg != NULL) {

  0002c	8b 06		 mov	 eax, DWORD PTR [esi]
  0002e	85 c0		 test	 eax, eax
  00030	74 31		 je	 SHORT $LN7@ErrorMessa

; 244  :             int nLen = lstrlen(m_pszMsg);

  00032	50		 push	 eax
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4

; 245  :             if (nLen > 1 && m_pszMsg[nLen - 1] == '\n') {

  00039	83 f8 01	 cmp	 eax, 1
  0003c	7e 68		 jle	 SHORT $LN21@ErrorMessa
  0003e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00040	80 7c 08 ff 0a	 cmp	 BYTE PTR [eax+ecx-1], 10 ; 0000000aH
  00045	8d 4c 08 ff	 lea	 ecx, DWORD PTR [eax+ecx-1]
  00049	75 5b		 jne	 SHORT $LN21@ErrorMessa

; 246  :                 m_pszMsg[nLen - 1] = 0;

  0004b	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 247  :                 if (m_pszMsg[nLen - 2] == '\r') {

  0004e	8b 16		 mov	 edx, DWORD PTR [esi]
  00050	80 7c 10 fe 0d	 cmp	 BYTE PTR [eax+edx-2], 13 ; 0000000dH
  00055	8d 44 10 fe	 lea	 eax, DWORD PTR [eax+edx-2]
  00059	75 66		 jne	 SHORT $LN19@ErrorMessa

; 248  :                         m_pszMsg[nLen - 2] = 0;

  0005b	c6 00 00	 mov	 BYTE PTR [eax], 0

; 261  :                 }
; 262  :             }
; 263  :         }
; 264  :     }
; 265  :     return m_pszMsg;

  0005e	8b 06		 mov	 eax, DWORD PTR [esi]
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi

; 266  : }

  00062	c3		 ret	 0
$LN7@ErrorMessa:

; 249  :                 }
; 250  :             }
; 251  :         } 
; 252  :         else {
; 253  :             m_pszMsg = (LPTSTR)LocalAlloc(0, 32 * sizeof(TCHAR));

  00063	6a 20		 push	 32			; 00000020H
  00065	6a 00		 push	 0
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalAlloc@8
  0006d	89 06		 mov	 DWORD PTR [esi], eax

; 254  :             if (m_pszMsg != NULL) {

  0006f	85 c0		 test	 eax, eax
  00071	74 35		 je	 SHORT $LN1@ErrorMessa

; 255  :                 WORD wCode = WCode();

  00073	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00076	8d 91 00 fe fb
	7f		 lea	 edx, DWORD PTR [ecx+2147220992]
  0007c	81 fa ff fd 00
	00		 cmp	 edx, 65023		; 0000fdffH
  00082	77 27		 ja	 SHORT $LN2@ErrorMessa
  00084	8d 91 00 fe ff
	ff		 lea	 edx, DWORD PTR [ecx-512]
  0008a	0f b7 d2	 movzx	 edx, dx

; 256  :                 if (wCode != 0) {

  0008d	66 85 d2	 test	 dx, dx
  00090	74 19		 je	 SHORT $LN2@ErrorMessa

; 257  :                     _COM_PRINTF_S_1(m_pszMsg, 32, TEXT("IDispatch error #%d"), wCode);

  00092	0f b7 ca	 movzx	 ecx, dx
  00095	51		 push	 ecx
  00096	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@NNIJINN@IDispatch?5error?5?$CD?$CFd?$AA@

; 258  :                 } 
; 259  :                 else {
; 260  :                     _COM_PRINTF_S_1(m_pszMsg, 32, TEXT("Unknown error 0x%0lX"), m_hresult);

  0009b	6a 20		 push	 32			; 00000020H
  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 _sprintf_s
  000a3	83 c4 10	 add	 esp, 16			; 00000010H
$LN21@ErrorMessa:

; 261  :                 }
; 262  :             }
; 263  :         }
; 264  :     }
; 265  :     return m_pszMsg;

  000a6	8b 06		 mov	 eax, DWORD PTR [esi]
$LN1@ErrorMessa:
  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi

; 266  : }

  000aa	c3		 ret	 0
$LN2@ErrorMessa:

; 258  :                 } 
; 259  :                 else {
; 260  :                     _COM_PRINTF_S_1(m_pszMsg, 32, TEXT("Unknown error 0x%0lX"), m_hresult);

  000ab	51		 push	 ecx
  000ac	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@IPPGFENJ@Unknown?5error?50x?$CF0lX?$AA@
  000b1	6a 20		 push	 32			; 00000020H
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 _sprintf_s

; 261  :                 }
; 262  :             }
; 263  :         }
; 264  :     }
; 265  :     return m_pszMsg;

  000b9	8b 06		 mov	 eax, DWORD PTR [esi]
  000bb	83 c4 10	 add	 esp, 16			; 00000010H
  000be	5f		 pop	 edi
  000bf	5e		 pop	 esi

; 266  : }

  000c0	c3		 ret	 0
$LN19@ErrorMessa:
  000c1	5f		 pop	 edi

; 261  :                 }
; 262  :             }
; 263  :         }
; 264  :     }
; 265  :     return m_pszMsg;

  000c2	8b c2		 mov	 eax, edx
  000c4	5e		 pop	 esi

; 266  : }

  000c5	c3		 ret	 0
?ErrorMessage@_com_error@@QBEPBDXZ ENDP			; _com_error::ErrorMessage
_TEXT	ENDS
PUBLIC	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z
_TEXT	SEGMENT
_nRequestedSize$ = 8					; size = 4
?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z PROC ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 643  : 		CAtlSafeAllocBufferNode *p = (CAtlSafeAllocBufferNode*)Allocator::Allocate(::ATL::AtlAddThrow(nRequestedSize, static_cast<SIZE_T>(sizeof(CAtlSafeAllocBufferNode))));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nRequestedSize$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	83 c9 ff	 or	 ecx, -1
  0000a	2b c8		 sub	 ecx, eax
  0000c	83 f9 08	 cmp	 ecx, 8
  0000f	72 14		 jb	 SHORT $LN15@Allocate
  00011	83 c0 08	 add	 eax, 8
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 _malloc
  0001a	83 c4 04	 add	 esp, 4

; 644  : 		if (p == NULL)

  0001d	85 c0		 test	 eax, eax
  0001f	75 0e		 jne	 SHORT $LN1@Allocate
  00021	5e		 pop	 esi

; 652  : 	}

  00022	c2 04 00	 ret	 4
$LN15@Allocate:

; 643  : 		CAtlSafeAllocBufferNode *p = (CAtlSafeAllocBufferNode*)Allocator::Allocate(::ATL::AtlAddThrow(nRequestedSize, static_cast<SIZE_T>(sizeof(CAtlSafeAllocBufferNode))));

  00025	68 57 00 07 80	 push	 -2147024809		; 80070057H
  0002a	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN1@Allocate:

; 645  : 			return NULL;
; 646  : 		
; 647  : 		// Add buffer to the list
; 648  : 		p->m_pNext = m_pHead;

  0002f	8b 16		 mov	 edx, DWORD PTR [esi]
  00031	89 10		 mov	 DWORD PTR [eax], edx

; 649  : 		m_pHead = p;

  00033	89 06		 mov	 DWORD PTR [esi], eax

; 650  : 		
; 651  : 		return p->GetData();

  00035	83 c0 08	 add	 eax, 8
  00038	5e		 pop	 esi

; 652  : 	}

  00039	c2 04 00	 ret	 4
$LN16@Allocate:
?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
PUBLIC	??1?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::~CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??1?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::~CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>, COMDAT
; _this$ = ecx

; 300  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 301  : 		RemoveAll();	

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 0f		 je	 SHORT $LN7@CSimpleMap
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _free
  0000f	83 c4 04	 add	 esp, 4
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN7@CSimpleMap:
  00018	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001b	85 c0		 test	 eax, eax
  0001d	74 10		 je	 SHORT $LN12@CSimpleMap
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _free
  00025	83 c4 04	 add	 esp, 4
  00028	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
$LN12@CSimpleMap:
  0002f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00036	5e		 pop	 esi

; 302  : 	}

  00037	c3		 ret	 0
??1?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::~CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>
_TEXT	ENDS
PUBLIC	?Lookup@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEPA_WABQAD@Z ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Lookup
; Function compile flags: /Ogtpy
;	COMDAT ?Lookup@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEPA_WABQAD@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
?Lookup@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEPA_WABQAD@Z PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Lookup, COMDAT
; _this$ = ecx

; 388  : 		int nIndex = FindKey(key);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _key$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?FindKey@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHABQAD@Z ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::FindKey

; 389  : 		if(nIndex == -1)

  0000d	83 f8 ff	 cmp	 eax, -1
  00010	75 06		 jne	 SHORT $LN1@Lookup

; 390  : 			return NULL;    // must be able to convert

  00012	33 c0		 xor	 eax, eax
  00014	5e		 pop	 esi

; 392  : 	}

  00015	c2 04 00	 ret	 4
$LN1@Lookup:

; 391  : 		return GetValueAt(nIndex);

  00018	85 c0		 test	 eax, eax
  0001a	7c 0f		 jl	 SHORT $LN4@Lookup
  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	7d 0a		 jge	 SHORT $LN4@Lookup
  00021	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00024	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00027	5e		 pop	 esi

; 392  : 	}

  00028	c2 04 00	 ret	 4
$LN4@Lookup:
  0002b	6a 00		 push	 0
  0002d	6a 00		 push	 0
  0002f	6a 01		 push	 1
  00031	68 8c 00 00 c0	 push	 -1073741684		; c000008cH
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RaiseException@16
$LN11@Lookup:
  0003c	cc		 int	 3
?Lookup@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEPA_WABQAD@Z ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Lookup
_TEXT	ENDS
PUBLIC	??1?$CAutoVectorPtr@D@ATL@@QAE@XZ		; ATL::CAutoVectorPtr<char>::~CAutoVectorPtr<char>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??1?$CAutoVectorPtr@D@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CAutoVectorPtr@D@ATL@@QAE@XZ PROC			; ATL::CAutoVectorPtr<char>::~CAutoVectorPtr<char>, COMDAT
; _this$ = ecx

; 616  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 617  : 		Free();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0000b	83 c4 04	 add	 esp, 4
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	5e		 pop	 esi

; 618  : 	}

  00015	c3		 ret	 0
??1?$CAutoVectorPtr@D@ATL@@QAE@XZ ENDP			; ATL::CAutoVectorPtr<char>::~CAutoVectorPtr<char>
_TEXT	ENDS
PUBLIC	??1?$CAutoVectorPtr@_W@ATL@@QAE@XZ		; ATL::CAutoVectorPtr<wchar_t>::~CAutoVectorPtr<wchar_t>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$CAutoVectorPtr@_W@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CAutoVectorPtr@_W@ATL@@QAE@XZ PROC			; ATL::CAutoVectorPtr<wchar_t>::~CAutoVectorPtr<wchar_t>, COMDAT
; _this$ = ecx

; 616  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 617  : 		Free();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0000b	83 c4 04	 add	 esp, 4
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	5e		 pop	 esi

; 618  : 	}

  00015	c3		 ret	 0
??1?$CAutoVectorPtr@_W@ATL@@QAE@XZ ENDP			; ATL::CAutoVectorPtr<wchar_t>::~CAutoVectorPtr<wchar_t>
_TEXT	ENDS
PUBLIC	??1?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::~CTempBuffer<char,1024,ATL::CCRTAllocator>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??1?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::~CTempBuffer<char,1024,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 465  : 		if( m_p != reinterpret_cast< T* >( m_abFixedBuffer ) )

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	39 01		 cmp	 DWORD PTR [ecx], eax
  00005	74 05		 je	 SHORT $LN1@CTempBuffe

; 466  : 		{
; 467  : 			FreeHeap();

  00007	e9 00 00 00 00	 jmp	 ?FreeHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::FreeHeap
$LN1@CTempBuffe:

; 468  : 		}
; 469  : 	}

  0000c	c3		 ret	 0
??1?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::~CTempBuffer<char,1024,ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	??1?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::~CTempBuffer<char,256,ATL::CCRTAllocator>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::~CTempBuffer<char,256,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 465  : 		if( m_p != reinterpret_cast< T* >( m_abFixedBuffer ) )

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	39 01		 cmp	 DWORD PTR [ecx], eax
  00005	74 05		 je	 SHORT $LN1@CTempBuffe@2

; 466  : 		{
; 467  : 			FreeHeap();

  00007	e9 00 00 00 00	 jmp	 ?FreeHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::FreeHeap
$LN1@CTempBuffe@2:

; 468  : 		}
; 469  : 	}

  0000c	c3		 ret	 0
??1?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::~CTempBuffer<char,256,ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	??1?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::~CTempBuffer<unsigned char,256,ATL::CCRTAllocator>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::~CTempBuffer<unsigned char,256,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 465  : 		if( m_p != reinterpret_cast< T* >( m_abFixedBuffer ) )

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	39 01		 cmp	 DWORD PTR [ecx], eax
  00005	74 05		 je	 SHORT $LN1@CTempBuffe@3

; 466  : 		{
; 467  : 			FreeHeap();

  00007	e9 00 00 00 00	 jmp	 ?FreeHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::FreeHeap
$LN1@CTempBuffe@3:

; 468  : 		}
; 469  : 	}

  0000c	c3		 ret	 0
??1?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::~CTempBuffer<unsigned char,256,ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	??0?$CComPtr@UITypeLib@@@ATL@@QAE@XZ		; ATL::CComPtr<ITypeLib>::CComPtr<ITypeLib>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UITypeLib@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CComPtr@UITypeLib@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<ITypeLib>::CComPtr<ITypeLib>, COMDAT
; _this$ = ecx

; 276  : 	CComPtr() throw()

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 277  : 	{
; 278  : 	}

  00008	c3		 ret	 0
??0?$CComPtr@UITypeLib@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<ITypeLib>::CComPtr<ITypeLib>
_TEXT	ENDS
PUBLIC	?InternalSetAtIndex@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXHABQADABQA_W@Z ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::InternalSetAtIndex
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?InternalSetAtIndex@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXHABQADABQA_W@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
_key$ = 12						; size = 4
_val$ = 16						; size = 4
?InternalSetAtIndex@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXHABQADABQA_W@Z PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::InternalSetAtIndex, COMDAT
; _this$ = ecx

; 467  : 		new(m_aKey + nIndex) Wrapper<TKey>(key);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _nIndex$[esp-4]
  00004	8b 01		 mov	 eax, DWORD PTR [ecx]
  00006	03 d2		 add	 edx, edx
  00008	03 d2		 add	 edx, edx
  0000a	03 c2		 add	 eax, edx
  0000c	74 0a		 je	 SHORT $LN3@InternalSe
  0000e	56		 push	 esi
  0000f	8b 74 24 0c	 mov	 esi, DWORD PTR _key$[esp]
  00013	8b 36		 mov	 esi, DWORD PTR [esi]
  00015	89 30		 mov	 DWORD PTR [eax], esi
  00017	5e		 pop	 esi
$LN3@InternalSe:

; 468  : 		new(m_aVal + nIndex) Wrapper<TVal>(val);

  00018	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0001b	03 ca		 add	 ecx, edx
  0001d	74 08		 je	 SHORT $LN5@InternalSe
  0001f	8b 44 24 0c	 mov	 eax, DWORD PTR _val$[esp-4]
  00023	8b 10		 mov	 edx, DWORD PTR [eax]
  00025	89 11		 mov	 DWORD PTR [ecx], edx
$LN5@InternalSe:

; 469  : 	}

  00027	c2 0c 00	 ret	 12			; 0000000cH
?InternalSetAtIndex@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXHABQADABQA_W@Z ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::InternalSetAtIndex
_TEXT	ENDS
PUBLIC	?AllocateBytes@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::AllocateBytes
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?AllocateBytes@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::AllocateBytes, COMDAT
; _this$ = ecx

; 522  : 		ATLASSERT( m_p == NULL );
; 523  : 		if( nBytes > t_nFixedBytes )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nBytes$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  0000c	76 0c		 jbe	 SHORT $LN2@AllocateBy

; 524  : 		{
; 525  : 			AllocateHeap( nBytes );

  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?AllocateHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::AllocateHeap

; 530  : 		}
; 531  : 
; 532  : 		return( m_p );

  00014	8b 06		 mov	 eax, DWORD PTR [esi]
  00016	5e		 pop	 esi

; 533  : 	}

  00017	c2 04 00	 ret	 4
$LN2@AllocateBy:

; 526  : 		}
; 527  : 		else
; 528  : 		{
; 529  : 			m_p = reinterpret_cast< T* >( m_abFixedBuffer );

  0001a	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0001d	89 06		 mov	 DWORD PTR [esi], eax
  0001f	5e		 pop	 esi

; 533  : 	}

  00020	c2 04 00	 ret	 4
?AllocateBytes@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::AllocateBytes
_TEXT	ENDS
PUBLIC	?AllocateBytes@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::AllocateBytes
; Function compile flags: /Ogtpy
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?AllocateBytes@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::AllocateBytes, COMDAT
; _this$ = ecx

; 522  : 		ATLASSERT( m_p == NULL );
; 523  : 		if( nBytes > t_nFixedBytes )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nBytes$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0000c	76 0c		 jbe	 SHORT $LN2@AllocateBy@2

; 524  : 		{
; 525  : 			AllocateHeap( nBytes );

  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?AllocateHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::AllocateHeap

; 530  : 		}
; 531  : 
; 532  : 		return( m_p );

  00014	8b 06		 mov	 eax, DWORD PTR [esi]
  00016	5e		 pop	 esi

; 533  : 	}

  00017	c2 04 00	 ret	 4
$LN2@AllocateBy@2:

; 526  : 		}
; 527  : 		else
; 528  : 		{
; 529  : 			m_p = reinterpret_cast< T* >( m_abFixedBuffer );

  0001a	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0001d	89 06		 mov	 DWORD PTR [esi], eax
  0001f	5e		 pop	 esi

; 533  : 	}

  00020	c2 04 00	 ret	 4
?AllocateBytes@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::AllocateBytes
_TEXT	ENDS
PUBLIC	?AllocateBytes@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::AllocateBytes
; Function compile flags: /Ogtpy
;	COMDAT ?AllocateBytes@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?AllocateBytes@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z PROC ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::AllocateBytes, COMDAT
; _this$ = ecx

; 522  : 		ATLASSERT( m_p == NULL );
; 523  : 		if( nBytes > t_nFixedBytes )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nBytes$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0000c	76 0c		 jbe	 SHORT $LN2@AllocateBy@3

; 524  : 		{
; 525  : 			AllocateHeap( nBytes );

  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?AllocateHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::AllocateHeap

; 530  : 		}
; 531  : 
; 532  : 		return( m_p );

  00014	8b 06		 mov	 eax, DWORD PTR [esi]
  00016	5e		 pop	 esi

; 533  : 	}

  00017	c2 04 00	 ret	 4
$LN2@AllocateBy@3:

; 526  : 		}
; 527  : 		else
; 528  : 		{
; 529  : 			m_p = reinterpret_cast< T* >( m_abFixedBuffer );

  0001a	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0001d	89 06		 mov	 DWORD PTR [esi], eax
  0001f	5e		 pop	 esi

; 533  : 	}

  00020	c2 04 00	 ret	 4
?AllocateBytes@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z ENDP ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::AllocateBytes
_TEXT	ENDS
PUBLIC	??1CExpansionVector@ATL@@QAE@XZ			; ATL::CExpansionVector::~CExpansionVector
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\statreg.h
;	COMDAT ??1CExpansionVector@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CExpansionVector@ATL@@QAE@XZ PROC			; ATL::CExpansionVector::~CExpansionVector, COMDAT
; _this$ = ecx

; 92   : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 93   : 		 ClearReplacements();

  00003	e8 00 00 00 00	 call	 ?ClearReplacements@CExpansionVector@ATL@@QAEJXZ ; ATL::CExpansionVector::ClearReplacements

; 94   : 	}

  00008	8b 06		 mov	 eax, DWORD PTR [esi]
  0000a	85 c0		 test	 eax, eax
  0000c	74 0f		 je	 SHORT $LN10@CExpansion
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _free
  00014	83 c4 04	 add	 esp, 4
  00017	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN10@CExpansion:
  0001d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00020	85 c0		 test	 eax, eax
  00022	74 10		 je	 SHORT $LN15@CExpansion
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _free
  0002a	83 c4 04	 add	 esp, 4
  0002d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
$LN15@CExpansion:
  00034	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0003b	5e		 pop	 esi
  0003c	c3		 ret	 0
??1CExpansionVector@ATL@@QAE@XZ ENDP			; ATL::CExpansionVector::~CExpansionVector
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z ; ATL::CRegParser::CParseBuffer::AddString
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__allmul:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlalloc.h
xdata$x	SEGMENT
__unwindtable$?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z$0
__ehfuncinfo$?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\statreg.h
xdata$x	ENDS
;	COMDAT ?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__AtlSafeAllocaManager$ = -20				; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lpsz$ = 8						; size = 4
?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z PROC	; ATL::CRegParser::CParseBuffer::AddString, COMDAT
; _this$ = ecx

; 247  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 248  : 			if (lpsz == NULL)

  0002e	8b 5d 08	 mov	 ebx, DWORD PTR _lpsz$[ebp]
  00031	33 f6		 xor	 esi, esi
  00033	3b de		 cmp	 ebx, esi

; 249  : 			{
; 250  : 				return FALSE;

  00035	74 7e		 je	 SHORT $LN20@AddString

; 251  : 			}
; 252  : 			USES_CONVERSION_EX;

  00037	89 75 ec	 mov	 DWORD PTR __AtlSafeAllocaManager$[ebp], esi

; 253  : 			LPCTSTR lpszT = OLE2CT_EX(lpsz, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

  0003a	53		 push	 ebx
  0003b	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  00044	56		 push	 esi
  00045	40		 inc	 eax
  00046	99		 cdq
  00047	6a 02		 push	 2
  00049	52		 push	 edx
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 __allmul
  00050	8b f8		 mov	 edi, eax
  00052	05 00 00 00 80	 add	 eax, -2147483648	; 80000000H
  00057	13 d6		 adc	 edx, esi
  00059	85 d2		 test	 edx, edx
  0005b	77 58		 ja	 SHORT $LN20@AddString
  0005d	72 05		 jb	 SHORT $LN38@AddString
  0005f	83 f8 ff	 cmp	 eax, -1
  00062	77 51		 ja	 SHORT $LN20@AddString
$LN38@AddString:
  00064	81 ff 00 04 00
	00		 cmp	 edi, 1024		; 00000400H
  0006a	7f 18		 jg	 SHORT $LN5@AddString
  0006c	57		 push	 edi
  0006d	e8 00 00 00 00	 call	 ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
  00072	83 c4 04	 add	 esp, 4
  00075	84 c0		 test	 al, al
  00077	74 0b		 je	 SHORT $LN5@AddString
  00079	8b c7		 mov	 eax, edi
  0007b	e8 00 00 00 00	 call	 __alloca_probe_16
  00080	8b c4		 mov	 eax, esp
  00082	eb 0c		 jmp	 SHORT $LN6@AddString
$LN5@AddString:
  00084	57		 push	 edi
  00085	8d 4d ec	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  00088	e8 00 00 00 00	 call	 ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
  0008d	8b 75 ec	 mov	 esi, DWORD PTR __AtlSafeAllocaManager$[ebp]
$LN6@AddString:
  00090	6a 03		 push	 3
  00092	57		 push	 edi
  00093	53		 push	 ebx
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  0009a	8b f8		 mov	 edi, eax

; 254  : 			if (lpszT == NULL)

  0009c	85 ff		 test	 edi, edi
  0009e	75 19		 jne	 SHORT $LN1@AddString

; 255  : 			{
; 256  : 				return FALSE;

  000a0	85 f6		 test	 esi, esi
  000a2	74 11		 je	 SHORT $LN20@AddString
$LL21@AddString:
  000a4	8b c6		 mov	 eax, esi
  000a6	8b 36		 mov	 esi, DWORD PTR [esi]
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 _free
  000ae	83 c4 04	 add	 esp, 4
  000b1	85 f6		 test	 esi, esi
  000b3	75 ef		 jne	 SHORT $LL21@AddString
$LN20@AddString:
  000b5	33 c0		 xor	 eax, eax
  000b7	eb 2a		 jmp	 SHORT $LN3@AddString
$LN1@AddString:

; 257  : 			}
; 258  : 			return Append(lpszT, (int)lstrlen(lpszT));

  000b9	57		 push	 edi
  000ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  000c0	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c3	50		 push	 eax
  000c4	57		 push	 edi
  000c5	e8 00 00 00 00	 call	 ?Append@CParseBuffer@CRegParser@ATL@@QAEHPBDH@Z ; ATL::CRegParser::CParseBuffer::Append
  000ca	8b f8		 mov	 edi, eax
  000cc	85 f6		 test	 esi, esi
  000ce	74 11		 je	 SHORT $LN26@AddString
$LL27@AddString:
  000d0	8b c6		 mov	 eax, esi
  000d2	8b 36		 mov	 esi, DWORD PTR [esi]
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 _free
  000da	83 c4 04	 add	 esp, 4
  000dd	85 f6		 test	 esi, esi
  000df	75 ef		 jne	 SHORT $LL27@AddString
$LN26@AddString:
  000e1	8b c7		 mov	 eax, edi
$LN3@AddString:

; 259  : 		}

  000e3	8d 65 d8	 lea	 esp, DWORD PTR [ebp-40]
  000e6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f0	59		 pop	 ecx
  000f1	5f		 pop	 edi
  000f2	5e		 pop	 esi
  000f3	5b		 pop	 ebx
  000f4	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f7	33 cd		 xor	 ecx, ebp
  000f9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fe	8b e5		 mov	 esp, ebp
  00100	5d		 pop	 ebp
  00101	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z ENDP	; ATL::CRegParser::CParseBuffer::AddString
PUBLIC	??_7CRegObject@ATL@@6B@				; ATL::CRegObject::`vftable'
PUBLIC	??1CRegObject@ATL@@UAE@XZ			; ATL::CRegObject::~CRegObject
PUBLIC	??_R4CRegObject@ATL@@6B@			; ATL::CRegObject::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCRegObject@ATL@@@8			; ATL::CRegObject `RTTI Type Descriptor'
PUBLIC	??_R3CRegObject@ATL@@8				; ATL::CRegObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CRegObject@ATL@@8				; ATL::CRegObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CRegObject@ATL@@8			; ATL::CRegObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@IRegistrarBase@@8			; IRegistrarBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AUIRegistrarBase@@@8			; IRegistrarBase `RTTI Type Descriptor'
PUBLIC	??_R3IRegistrarBase@@8				; IRegistrarBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IRegistrarBase@@8				; IRegistrarBase::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IUnknown@@8			; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AUIUnknown@@@8				; IUnknown `RTTI Type Descriptor'
PUBLIC	??_R3IUnknown@@8				; IUnknown::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IUnknown@@8				; IUnknown::`RTTI Base Class Array'
PUBLIC	?QueryInterface@CRegObject@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CRegObject::QueryInterface
PUBLIC	?AddRef@CRegObject@ATL@@UAGKXZ			; ATL::CRegObject::AddRef
PUBLIC	?Release@CRegObject@ATL@@UAGKXZ			; ATL::CRegObject::Release
PUBLIC	?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z	; ATL::CRegObject::AddReplacement
EXTRN	??_ECRegObject@ATL@@UAEPAXI@Z:PROC		; ATL::CRegObject::`vector deleting destructor'
;	COMDAT ??_R2IUnknown@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlsimpcoll.h
rdata$r	SEGMENT
??_R2IUnknown@@8 DD FLAT:??_R1A@?0A@EA@IUnknown@@8	; IUnknown::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3IUnknown@@8
rdata$r	SEGMENT
??_R3IUnknown@@8 DD 00H					; IUnknown::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUIUnknown@@@8
_DATA	SEGMENT
??_R0?AUIUnknown@@@8 DD FLAT:??_7type_info@@6B@		; IUnknown `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUIUnknown@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@IUnknown@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IUnknown@@8 DD FLAT:??_R0?AUIUnknown@@@8	; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R2IRegistrarBase@@8
rdata$r	SEGMENT
??_R2IRegistrarBase@@8 DD FLAT:??_R1A@?0A@EA@IRegistrarBase@@8 ; IRegistrarBase::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R3IRegistrarBase@@8
rdata$r	SEGMENT
??_R3IRegistrarBase@@8 DD 00H				; IRegistrarBase::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2IRegistrarBase@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUIRegistrarBase@@@8
_DATA	SEGMENT
??_R0?AUIRegistrarBase@@@8 DD FLAT:??_7type_info@@6B@	; IRegistrarBase `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUIRegistrarBase@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@IRegistrarBase@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IRegistrarBase@@8 DD FLAT:??_R0?AUIRegistrarBase@@@8 ; IRegistrarBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IRegistrarBase@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CRegObject@ATL@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CRegObject@ATL@@8 DD FLAT:??_R0?AVCRegObject@ATL@@@8 ; ATL::CRegObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CRegObject@ATL@@8
rdata$r	ENDS
;	COMDAT ??_R2CRegObject@ATL@@8
rdata$r	SEGMENT
??_R2CRegObject@ATL@@8 DD FLAT:??_R1A@?0A@EA@CRegObject@ATL@@8 ; ATL::CRegObject::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IRegistrarBase@@8
	DD	FLAT:??_R1A@?0A@EA@IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R3CRegObject@ATL@@8
rdata$r	SEGMENT
??_R3CRegObject@ATL@@8 DD 00H				; ATL::CRegObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CRegObject@ATL@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCRegObject@ATL@@@8
_DATA	SEGMENT
??_R0?AVCRegObject@ATL@@@8 DD FLAT:??_7type_info@@6B@	; ATL::CRegObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCRegObject@ATL@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CRegObject@ATL@@6B@
rdata$r	SEGMENT
??_R4CRegObject@ATL@@6B@ DD 00H				; ATL::CRegObject::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCRegObject@ATL@@@8
	DD	FLAT:??_R3CRegObject@ATL@@8
rdata$r	ENDS
;	COMDAT ??_7CRegObject@ATL@@6B@
CONST	SEGMENT
??_7CRegObject@ATL@@6B@ DD FLAT:??_R4CRegObject@ATL@@6B@ ; ATL::CRegObject::`vftable'
	DD	FLAT:?QueryInterface@CRegObject@ATL@@UAGJABU_GUID@@PAPAX@Z
	DD	FLAT:?AddRef@CRegObject@ATL@@UAGKXZ
	DD	FLAT:?Release@CRegObject@ATL@@UAGKXZ
	DD	FLAT:?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z
	DD	FLAT:?ClearReplacements@CRegObject@ATL@@UAGJXZ
	DD	FLAT:??_ECRegObject@ATL@@UAEPAXI@Z
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\statreg.h
CONST	ENDS
;	COMDAT ??1CRegObject@ATL@@UAE@XZ
_TEXT	SEGMENT
??1CRegObject@ATL@@UAE@XZ PROC				; ATL::CRegObject::~CRegObject, COMDAT
; _this$ = ecx

; 300  : 	virtual ~CRegObject(){ClearReplacements();}

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx
  00004	57		 push	 edi
  00005	8d 7e 10	 lea	 edi, DWORD PTR [esi+16]
  00008	57		 push	 edi
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CRegObject@ATL@@6B@
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  00015	83 c6 04	 add	 esi, 4
  00018	8b ce		 mov	 ecx, esi
  0001a	e8 00 00 00 00	 call	 ?ClearReplacements@CExpansionVector@ATL@@QAEJXZ ; ATL::CExpansionVector::ClearReplacements
  0001f	57		 push	 edi
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00026	33 db		 xor	 ebx, ebx
  00028	38 5f 18	 cmp	 BYTE PTR [edi+24], bl
  0002b	74 0a		 je	 SHORT $LN24@CRegObject
  0002d	57		 push	 edi
  0002e	88 5f 18	 mov	 BYTE PTR [edi+24], bl
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
$LN24@CRegObject:
  00037	8b ce		 mov	 ecx, esi
  00039	e8 00 00 00 00	 call	 ?ClearReplacements@CExpansionVector@ATL@@QAEJXZ ; ATL::CExpansionVector::ClearReplacements
  0003e	8b 06		 mov	 eax, DWORD PTR [esi]
  00040	3b c3		 cmp	 eax, ebx
  00042	74 0b		 je	 SHORT $LN36@CRegObject
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _free
  0004a	83 c4 04	 add	 esp, 4
  0004d	89 1e		 mov	 DWORD PTR [esi], ebx
$LN36@CRegObject:
  0004f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00052	3b c3		 cmp	 eax, ebx
  00054	74 0c		 je	 SHORT $LN41@CRegObject
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 _free
  0005c	83 c4 04	 add	 esp, 4
  0005f	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
$LN41@CRegObject:
  00062	5f		 pop	 edi
  00063	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	c3		 ret	 0
??1CRegObject@ATL@@UAE@XZ ENDP				; ATL::CRegObject::~CRegObject
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?QueryInterface@CRegObject@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?QueryInterface@CRegObject@ATL@@UAGJABU_GUID@@PAPAX@Z PROC ; ATL::CRegObject::QueryInterface, COMDAT

; 285  : 		ATLASSERT(_T("statically linked in CRegObject is not a com object. Do not callthis function"));
; 286  : 		return E_NOTIMPL;

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 287  : 	}

  00005	c2 0c 00	 ret	 12			; 0000000cH
?QueryInterface@CRegObject@ATL@@UAGJABU_GUID@@PAPAX@Z ENDP ; ATL::CRegObject::QueryInterface
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?AddRef@CRegObject@ATL@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?AddRef@CRegObject@ATL@@UAGKXZ PROC			; ATL::CRegObject::AddRef, COMDAT

; 291  : 		ATLASSERT(_T("statically linked in CRegObject is not a com object. Do not callthis function"));
; 292  : 		return 1;

  00000	b8 01 00 00 00	 mov	 eax, 1

; 293  : 	}

  00005	c2 04 00	 ret	 4
?AddRef@CRegObject@ATL@@UAGKXZ ENDP			; ATL::CRegObject::AddRef
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Release@CRegObject@ATL@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Release@CRegObject@ATL@@UAGKXZ PROC			; ATL::CRegObject::Release, COMDAT

; 296  : 		ATLASSERT(_T("statically linked in CRegObject is not a com object. Do not callthis function"));
; 297  : 		return 0;

  00000	33 c0		 xor	 eax, eax

; 298  : 	}

  00002	c2 04 00	 ret	 4
?Release@CRegObject@ATL@@UAGKXZ ENDP			; ATL::CRegObject::Release
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCRegObject@ATL@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCRegObject@ATL@@UAEPAXI@Z PROC			; ATL::CRegObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1CRegObject@ATL@@UAE@XZ ; ATL::CRegObject::~CRegObject
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 09		 je	 SHORT $LN4@scalar@2
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$LN4@scalar@2:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	c2 04 00	 ret	 4
??_GCRegObject@ATL@@UAEPAXI@Z ENDP			; ATL::CRegObject::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?StrFromMap@CRegObject@ATL@@QAEPB_WPAD@Z	; ATL::CRegObject::StrFromMap
; Function compile flags: /Ogtpy
;	COMDAT ?StrFromMap@CRegObject@ATL@@QAEPB_WPAD@Z
_TEXT	SEGMENT
_lpszKey$ = 8						; size = 4
?StrFromMap@CRegObject@ATL@@QAEPB_WPAD@Z PROC		; ATL::CRegObject::StrFromMap, COMDAT
; _this$ = ecx

; 548  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f1		 mov	 esi, ecx

; 549  : 	m_csMap.Lock();

  00004	8d 7e 10	 lea	 edi, DWORD PTR [esi+16]
  00007	57		 push	 edi
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 550  : 	LPCOLESTR lpsz = m_RepMap.Lookup(lpszKey);

  0000e	8d 44 24 0c	 lea	 eax, DWORD PTR _lpszKey$[esp+4]
  00012	83 c6 04	 add	 esi, 4
  00015	50		 push	 eax
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?FindKey@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHABQAD@Z ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::FindKey
  0001d	83 f8 ff	 cmp	 eax, -1
  00020	75 10		 jne	 SHORT $LN14@StrFromMap

; 551  : 	if (lpsz == NULL) // not found!!
; 552  : 		ATLTRACE(atlTraceRegistrar, 0, _T("Map Entry not found\n"));
; 553  : 	m_csMap.Unlock();

  00022	57		 push	 edi
  00023	33 f6		 xor	 esi, esi
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0002b	5f		 pop	 edi

; 554  : 	return lpsz;

  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi

; 555  : }

  0002f	c2 04 00	 ret	 4

; 550  : 	LPCOLESTR lpsz = m_RepMap.Lookup(lpszKey);

$LN14@StrFromMap:
  00032	85 c0		 test	 eax, eax
  00034	7c 19		 jl	 SHORT $LN17@StrFromMap
  00036	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00039	7d 14		 jge	 SHORT $LN17@StrFromMap
  0003b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0003e	8b 34 81	 mov	 esi, DWORD PTR [ecx+eax*4]

; 551  : 	if (lpsz == NULL) // not found!!
; 552  : 		ATLTRACE(atlTraceRegistrar, 0, _T("Map Entry not found\n"));
; 553  : 	m_csMap.Unlock();

  00041	57		 push	 edi
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00048	5f		 pop	 edi

; 554  : 	return lpsz;

  00049	8b c6		 mov	 eax, esi
  0004b	5e		 pop	 esi

; 555  : }

  0004c	c2 04 00	 ret	 4
$LN17@StrFromMap:
  0004f	6a 00		 push	 0
  00051	6a 00		 push	 0
  00053	6a 01		 push	 1
  00055	68 8c 00 00 c0	 push	 -1073741684		; c000008cH
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RaiseException@16
$LN27@StrFromMap:
  00060	cc		 int	 3
?StrFromMap@CRegObject@ATL@@QAEPB_WPAD@Z ENDP		; ATL::CRegObject::StrFromMap
_TEXT	ENDS
PUBLIC	??_C@_1BE@LJOLIMEM@?$AA?$AN?$AA?6?$AA?7?$AA?$HN?$AA?$AN?$AA?6?$AA?$HN?$AA?$AN?$AA?6?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EA@NHKLICFA@?$AAH?$AAK?$AAC?$AAU?$AA?$AN?$AA?6?$AA?$HL?$AA?7?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe?$AA?$AN?$AA?6?$AA?7?$AA?$HL?$AA?$AN?$AA?6?$AA?7?$AA?7?$AAC?$AAl?$AAa?$AAs?$AAs?$AAe?$AAs?$AA?$AA@ ; `string'
PUBLIC	_ppszReg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z ; ATL::CRegParser::PreProcessBuffer
;	COMDAT ??_C@_1BE@LJOLIMEM@?$AA?$AN?$AA?6?$AA?7?$AA?$HN?$AA?$AN?$AA?6?$AA?$HN?$AA?$AN?$AA?6?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@LJOLIMEM@?$AA?$AN?$AA?6?$AA?7?$AA?$HN?$AA?$AN?$AA?6?$AA?$HN?$AA?$AN?$AA?6?$AA?$AA@ DB 0dH
	DB	00H, 0aH, 00H, 09H, 00H, '}', 00H, 0dH, 00H, 0aH, 00H, '}', 00H
	DB	0dH, 00H, 0aH, 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@NHKLICFA@?$AAH?$AAK?$AAC?$AAU?$AA?$AN?$AA?6?$AA?$HL?$AA?7?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe?$AA?$AN?$AA?6?$AA?7?$AA?$HL?$AA?$AN?$AA?6?$AA?7?$AA?7?$AAC?$AAl?$AAa?$AAs?$AAs?$AAe?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1EA@NHKLICFA@?$AAH?$AAK?$AAC?$AAU?$AA?$AN?$AA?6?$AA?$HL?$AA?7?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe?$AA?$AN?$AA?6?$AA?7?$AA?$HL?$AA?$AN?$AA?6?$AA?7?$AA?7?$AAC?$AAl?$AAa?$AAs?$AAs?$AAe?$AAs?$AA?$AA@ DB 'H'
	DB	00H, 'K', 00H, 'C', 00H, 'U', 00H, 0dH, 00H, 0aH, 00H, '{', 00H
	DB	09H, 00H, 'S', 00H, 'o', 00H, 'f', 00H, 't', 00H, 'w', 00H, 'a'
	DB	00H, 'r', 00H, 'e', 00H, 0dH, 00H, 0aH, 00H, 09H, 00H, '{', 00H
	DB	0dH, 00H, 0aH, 00H, 09H, 00H, 09H, 00H, 'C', 00H, 'l', 00H, 'a'
	DB	00H, 's', 00H, 's', 00H, 'e', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z$0
__ehfuncinfo$?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z
_TEXT	SEGMENT
_bInsideQuotes$ = -77					; size = 1
_hr$ = -76						; size = 4
_bRedirectionEnabled$ = -69				; size = 1
_nNestingLevel$ = -68					; size = 4
_pb$ = -64						; size = 12
_ppszReg$GSCopy$ = -52					; size = 4
_buf$83327 = -48					; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lpszReg$ = 8						; size = 4
_ppszReg$ = 12						; size = 4
?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z PROC	; ATL::CRegParser::PreProcessBuffer, COMDAT
; _this$ = ecx

; 1068 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	83 ec 44	 sub	 esp, 68			; 00000044H
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c4		 xor	 eax, esp
  00018	89 44 24 40	 mov	 DWORD PTR __$ArrayPad$[esp+80], eax
  0001c	53		 push	 ebx
  0001d	55		 push	 ebp
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c4		 xor	 eax, esp
  00027	50		 push	 eax
  00028	8d 44 24 58	 lea	 eax, DWORD PTR __$EHRec$[esp+100]
  0002c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00032	8b 7c 24 68	 mov	 edi, DWORD PTR _lpszReg$[esp+96]
  00036	8b 6c 24 6c	 mov	 ebp, DWORD PTR _ppszReg$[esp+96]

; 1069 : 	ATLASSERT(lpszReg != NULL);
; 1070 : 	ATLASSERT(ppszReg != NULL);
; 1071 : 
; 1072 : 	if (lpszReg == NULL || ppszReg == NULL)

  0003a	33 db		 xor	 ebx, ebx
  0003c	8b f1		 mov	 esi, ecx

; 1221 : 			{
; 1222 : 				hr = E_OUTOFMEMORY;
; 1223 : 				break;
; 1224 : 			}
; 1225 : 		}
; 1226 : 
; 1227 : 		m_pchCur = CharNext(m_pchCur);

  0003e	89 6c 24 30	 mov	 DWORD PTR _ppszReg$GSCopy$[esp+100], ebp
  00042	3b fb		 cmp	 edi, ebx
  00044	0f 84 51 02 00
	00		 je	 $LN32@PreProcess

; 1069 : 	ATLASSERT(lpszReg != NULL);
; 1070 : 	ATLASSERT(ppszReg != NULL);
; 1071 : 
; 1072 : 	if (lpszReg == NULL || ppszReg == NULL)

  0004a	3b eb		 cmp	 ebp, ebx
  0004c	0f 84 49 02 00
	00		 je	 $LN32@PreProcess

; 1074 : 	
; 1075 : 	*ppszReg = NULL;
; 1076 : 	int nSize = lstrlen(lpszReg)*2;

  00052	57		 push	 edi
  00053	89 5d 00	 mov	 DWORD PTR [ebp], ebx
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  0005c	03 c0		 add	 eax, eax

; 1077 : 	CParseBuffer pb(nSize);

  0005e	50		 push	 eax
  0005f	8d 4c 24 28	 lea	 ecx, DWORD PTR _pb$[esp+104]
  00063	e8 00 00 00 00	 call	 ??0CParseBuffer@CRegParser@ATL@@QAE@H@Z ; ATL::CRegParser::CParseBuffer::CParseBuffer
  00068	89 5c 24 60	 mov	 DWORD PTR __$EHRec$[esp+108], ebx

; 1078 : 	if (pb.p == NULL)

  0006c	39 5c 24 2c	 cmp	 DWORD PTR _pb$[esp+108], ebx
  00070	75 11		 jne	 SHORT $LN31@PreProcess

; 1079 : 		return E_OUTOFMEMORY;

  00072	53		 push	 ebx
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoTaskMemFree@4
  00079	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  0007e	e9 1d 02 00 00	 jmp	 $LN34@PreProcess
$LN31@PreProcess:

; 1080 : 	m_pchCur = lpszReg;

  00083	89 3e		 mov	 DWORD PTR [esi], edi

; 1081 : 	HRESULT hr = S_OK;
; 1082 : 
; 1083 : 	bool bRedirectionEnabled = false;
; 1084 : 	hr = AtlGetPerUserRegistration(&bRedirectionEnabled);

  00085	a0 00 00 00 00	 mov	 al, BYTE PTR ?_AtlRegisterPerUser@ATL@@3_NA ; ATL::_AtlRegisterPerUser
  0008a	89 5c 24 18	 mov	 DWORD PTR _hr$[esp+100], ebx

; 1085 : 	if( FAILED(hr) )
; 1086 : 	{
; 1087 : 		return hr;
; 1088 : 	}
; 1089 : 
; 1090 : 	// nNestingLevel is used to avoid checking for unnecessary root key replacements
; 1091 : 	// since all of them are expected to be at the top level.
; 1092 : 	int nNestingLevel = 0;

  0008e	89 5c 24 20	 mov	 DWORD PTR _nNestingLevel$[esp+100], ebx

; 1093 : 	bool bRedirectionPresent = false;

  00092	32 db		 xor	 bl, bl
  00094	88 44 24 1f	 mov	 BYTE PTR _bRedirectionEnabled$[esp+100], al

; 1094 : 	bool bInsideQuotes = false;

  00098	88 5c 24 17	 mov	 BYTE PTR _bInsideQuotes$[esp+100], bl

; 1095 : 
; 1096 : 	while (*m_pchCur != NULL) // look for end

  0009c	38 1f		 cmp	 BYTE PTR [edi], bl
  0009e	0f 84 17 01 00
	00		 je	 $LN81@PreProcess
  000a4	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__CharNextA@4
$LN29@PreProcess:

; 1097 : 	{
; 1098 : 		if ( true == bRedirectionEnabled )

  000aa	80 7c 24 1f 01	 cmp	 BYTE PTR _bRedirectionEnabled$[esp+100], 1
  000af	0f 85 c5 00 00
	00		 jne	 $LN15@PreProcess

; 1099 : 		{
; 1100 : 			LPCOLESTR szStartHKCU = L"HKCU\r\n{\tSoftware\r\n\t{\r\n\t\tClasses";
; 1101 : 			LPCOLESTR szEndHKCU = L"\r\n\t}\r\n}\r\n";
; 1102 : 
; 1103 : 			if ( 0 == nNestingLevel )

  000b5	83 7c 24 20 00	 cmp	 DWORD PTR _nNestingLevel$[esp+100], 0
  000ba	75 46		 jne	 SHORT $LN25@PreProcess

; 1104 : 			{
; 1105 : 				// Then we should be reading a root key. HKCR, HKCU, etc
; 1106 : 				TCHAR* szRootKey = NULL;
; 1107 : 				if( NULL != ( szRootKey = _tcsstr(m_pchCur, _T("HKCR")) ) &&	// if HKCR is found.
; 1108 : 					(szRootKey == m_pchCur) )	// if HKCR is the first token.

  000bc	8b 06		 mov	 eax, DWORD PTR [esi]
  000be	68 00 00 00 00	 push	 OFFSET ??_C@_04OHBKMIBJ@HKCR?$AA@
  000c3	50		 push	 eax
  000c4	e8 00 00 00 00	 call	 __mbsstr
  000c9	83 c4 08	 add	 esp, 8
  000cc	85 c0		 test	 eax, eax
  000ce	74 32		 je	 SHORT $LN25@PreProcess
  000d0	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000d2	3b c1		 cmp	 eax, ecx
  000d4	75 2c		 jne	 SHORT $LN25@PreProcess

; 1109 : 				{
; 1110 : 					// Skip HKCR
; 1111 : 					m_pchCur = CharNext(m_pchCur);

  000d6	51		 push	 ecx
  000d7	ff d5		 call	 ebp

; 1112 : 					m_pchCur = CharNext(m_pchCur);

  000d9	50		 push	 eax
  000da	89 06		 mov	 DWORD PTR [esi], eax
  000dc	ff d5		 call	 ebp

; 1113 : 					m_pchCur = CharNext(m_pchCur);

  000de	50		 push	 eax
  000df	89 06		 mov	 DWORD PTR [esi], eax
  000e1	ff d5		 call	 ebp

; 1114 : 					m_pchCur = CharNext(m_pchCur);

  000e3	50		 push	 eax
  000e4	89 06		 mov	 DWORD PTR [esi], eax
  000e6	ff d5		 call	 ebp

; 1115 : 
; 1116 : 					// Add HKCU
; 1117 : 					if (!pb.AddString(szStartHKCU))

  000e8	68 00 00 00 00	 push	 OFFSET ??_C@_1EA@NHKLICFA@?$AAH?$AAK?$AAC?$AAU?$AA?$AN?$AA?6?$AA?$HL?$AA?7?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe?$AA?$AN?$AA?6?$AA?7?$AA?$HL?$AA?$AN?$AA?6?$AA?7?$AA?7?$AAC?$AAl?$AAa?$AAs?$AAs?$AAe?$AAs?$AA?$AA@
  000ed	8d 4c 24 28	 lea	 ecx, DWORD PTR _pb$[esp+104]
  000f1	89 06		 mov	 DWORD PTR [esi], eax
  000f3	e8 00 00 00 00	 call	 ?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z ; ATL::CRegParser::CParseBuffer::AddString
  000f8	85 c0		 test	 eax, eax
  000fa	0f 84 50 01 00
	00		 je	 $LN70@PreProcess

; 1118 : 					{
; 1119 : 						hr = E_OUTOFMEMORY;
; 1120 : 						break;
; 1121 : 					}
; 1122 : 
; 1123 : 					bRedirectionPresent = true;

  00100	b3 01		 mov	 bl, 1
$LN25@PreProcess:

; 1124 : 				}
; 1125 : 			}
; 1126 : 
; 1127 : 			if ( chQuote == *m_pchCur )

  00102	8b 06		 mov	 eax, DWORD PTR [esi]
  00104	80 38 27	 cmp	 BYTE PTR [eax], 39	; 00000027H
  00107	75 36		 jne	 SHORT $LN18@PreProcess

; 1128 : 			{
; 1129 : 				if( false == bInsideQuotes )

  00109	80 7c 24 17 00	 cmp	 BYTE PTR _bInsideQuotes$[esp+100], 0
  0010e	75 07		 jne	 SHORT $LN22@PreProcess

; 1130 : 				{
; 1131 : 					bInsideQuotes = true;

  00110	c6 44 24 17 01	 mov	 BYTE PTR _bInsideQuotes$[esp+100], 1

; 1132 : 				}
; 1133 : 				else

  00115	eb 63		 jmp	 SHORT $LN15@PreProcess
$LN22@PreProcess:

; 1134 : 				{
; 1135 : 					// Make sure it is not an escaped sequence.
; 1136 : 					if( EndOfVar() )

  00117	50		 push	 eax
  00118	ff d5		 call	 ebp
  0011a	80 38 27	 cmp	 BYTE PTR [eax], 39	; 00000027H
  0011d	74 07		 je	 SHORT $LN20@PreProcess

; 1137 : 					{
; 1138 : 						bInsideQuotes = false;

  0011f	c6 44 24 17 00	 mov	 BYTE PTR _bInsideQuotes$[esp+100], 0

; 1139 : 					}
; 1140 : 					else

  00124	eb 20		 jmp	 SHORT $LN83@PreProcess
$LN20@PreProcess:

; 1141 : 					{
; 1142 : 						// An escaped single quote...
; 1143 : 						m_pchCur = CharNext(m_pchCur);

  00126	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00128	51		 push	 ecx
  00129	ff d5		 call	 ebp

; 1144 : 						if (!pb.AddChar(m_pchCur))

  0012b	50		 push	 eax
  0012c	8d 4c 24 28	 lea	 ecx, DWORD PTR _pb$[esp+104]
  00130	89 06		 mov	 DWORD PTR [esi], eax
  00132	e8 00 00 00 00	 call	 ?AddChar@CParseBuffer@CRegParser@ATL@@QAEHPBD@Z ; ATL::CRegParser::CParseBuffer::AddChar
  00137	85 c0		 test	 eax, eax
  00139	0f 84 11 01 00
	00		 je	 $LN70@PreProcess
$LN18@PreProcess:

; 1145 : 						{
; 1146 : 							hr = E_OUTOFMEMORY;
; 1147 : 							break;
; 1148 : 						}
; 1149 : 					}
; 1150 : 				}
; 1151 : 			}
; 1152 : 
; 1153 : 			if ( (false == bInsideQuotes) && (*m_pchCur == _T('{')) )

  0013f	80 7c 24 17 00	 cmp	 BYTE PTR _bInsideQuotes$[esp+100], 0
  00144	75 34		 jne	 SHORT $LN15@PreProcess
$LN83@PreProcess:
  00146	8b 16		 mov	 edx, DWORD PTR [esi]
  00148	8a 02		 mov	 al, BYTE PTR [edx]
  0014a	3c 7b		 cmp	 al, 123			; 0000007bH
  0014c	75 04		 jne	 SHORT $LN84@PreProcess

; 1154 : 			{
; 1155 : 				++nNestingLevel;

  0014e	ff 44 24 20	 inc	 DWORD PTR _nNestingLevel$[esp+100]
$LN84@PreProcess:

; 1156 : 			}
; 1157 : 
; 1158 : 			if ( (false == bInsideQuotes) && (*m_pchCur == _T('}')) )

  00152	3c 7d		 cmp	 al, 125			; 0000007dH
  00154	75 24		 jne	 SHORT $LN15@PreProcess

; 1159 : 			{
; 1160 : 				--nNestingLevel;

  00156	83 6c 24 20 01	 sub	 DWORD PTR _nNestingLevel$[esp+100], 1

; 1161 : 				if ( (0 == nNestingLevel) && (true == bRedirectionPresent) )

  0015b	75 1d		 jne	 SHORT $LN15@PreProcess
  0015d	80 fb 01	 cmp	 bl, 1
  00160	75 18		 jne	 SHORT $LN15@PreProcess

; 1162 : 				{
; 1163 : 					if (!pb.AddString(szEndHKCU))

  00162	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@LJOLIMEM@?$AA?$AN?$AA?6?$AA?7?$AA?$HN?$AA?$AN?$AA?6?$AA?$HN?$AA?$AN?$AA?6?$AA?$AA@
  00167	8d 4c 24 28	 lea	 ecx, DWORD PTR _pb$[esp+104]
  0016b	e8 00 00 00 00	 call	 ?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z ; ATL::CRegParser::CParseBuffer::AddString
  00170	85 c0		 test	 eax, eax
  00172	0f 84 d8 00 00
	00		 je	 $LN70@PreProcess

; 1164 : 					{
; 1165 : 						hr = E_OUTOFMEMORY;
; 1166 : 						break;
; 1167 : 					}
; 1168 : 
; 1169 : 					bRedirectionPresent = false;

  00178	32 db		 xor	 bl, bl
$LN15@PreProcess:

; 1170 : 				}
; 1171 : 			}
; 1172 : 		}
; 1173 : 
; 1174 : 		if (*m_pchCur == _T('%'))

  0017a	8b 3e		 mov	 edi, DWORD PTR [esi]
  0017c	80 3f 25	 cmp	 BYTE PTR [edi], 37	; 00000025H

; 1175 : 		{
; 1176 : 			m_pchCur = CharNext(m_pchCur);

  0017f	57		 push	 edi
  00180	75 0c		 jne	 SHORT $LN13@PreProcess
  00182	ff d5		 call	 ebp
  00184	8b f8		 mov	 edi, eax
  00186	89 3e		 mov	 DWORD PTR [esi], edi

; 1177 : 			if (*m_pchCur == _T('%'))

  00188	80 3f 25	 cmp	 BYTE PTR [edi], 37	; 00000025H
  0018b	75 51		 jne	 SHORT $LN12@PreProcess

; 1178 : 			{
; 1179 : 				if (!pb.AddChar(m_pchCur))

  0018d	57		 push	 edi
$LN13@PreProcess:

; 1219 : 		{
; 1220 : 			if (!pb.AddChar(m_pchCur))

  0018e	ff d5		 call	 ebp
  00190	2b c7		 sub	 eax, edi
  00192	50		 push	 eax
  00193	57		 push	 edi
  00194	8d 4c 24 2c	 lea	 ecx, DWORD PTR _pb$[esp+108]
  00198	e8 00 00 00 00	 call	 ?Append@CParseBuffer@CRegParser@ATL@@QAEHPBDH@Z ; ATL::CRegParser::CParseBuffer::Append
  0019d	85 c0		 test	 eax, eax
  0019f	0f 84 ab 00 00
	00		 je	 $LN70@PreProcess
$LN2@PreProcess:

; 1221 : 			{
; 1222 : 				hr = E_OUTOFMEMORY;
; 1223 : 				break;
; 1224 : 			}
; 1225 : 		}
; 1226 : 
; 1227 : 		m_pchCur = CharNext(m_pchCur);

  001a5	8b 06		 mov	 eax, DWORD PTR [esi]
  001a7	50		 push	 eax
  001a8	ff d5		 call	 ebp
  001aa	8b c8		 mov	 ecx, eax
  001ac	89 06		 mov	 DWORD PTR [esi], eax
  001ae	80 39 00	 cmp	 BYTE PTR [ecx], 0
  001b1	0f 85 f3 fe ff
	ff		 jne	 $LN29@PreProcess

; 1219 : 		{
; 1220 : 			if (!pb.AddChar(m_pchCur))

  001b7	8b 6c 24 30	 mov	 ebp, DWORD PTR _ppszReg$GSCopy$[esp+100]
$LN81@PreProcess:

; 1228 : 	}
; 1229 : 	if (SUCCEEDED(hr))
; 1230 : 		*ppszReg = pb.Detach();

  001bb	8b 44 24 2c	 mov	 eax, DWORD PTR _pb$[esp+108]
  001bf	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR _pb$[esp+108], 0

; 1231 : 	return hr;

  001c7	8b 54 24 2c	 mov	 edx, DWORD PTR _pb$[esp+108]
  001cb	52		 push	 edx
  001cc	89 45 00	 mov	 DWORD PTR [ebp], eax
  001cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoTaskMemFree@4
  001d5	8b 44 24 18	 mov	 eax, DWORD PTR _hr$[esp+100]
  001d9	e9 c2 00 00 00	 jmp	 $LN34@PreProcess
$LN12@PreProcess:

; 1180 : 				{
; 1181 : 					hr = E_OUTOFMEMORY;
; 1182 : 					break;
; 1183 : 				}
; 1184 : 			}
; 1185 : 			else
; 1186 : 			{
; 1187 : 				LPTSTR lpszNext = StrChr(m_pchCur, _T('%'));

  001de	6a 25		 push	 37			; 00000025H
  001e0	57		 push	 edi
  001e1	e8 00 00 00 00	 call	 ?StrChrA@CRegParser@ATL@@KAPADPADD@Z ; ATL::CRegParser::StrChrA
  001e6	8b f8		 mov	 edi, eax
  001e8	83 c4 08	 add	 esp, 8

; 1188 : 				if (lpszNext == NULL)

  001eb	85 ff		 test	 edi, edi
  001ed	74 7a		 je	 SHORT $LN74@PreProcess

; 1189 : 				{
; 1190 : 					ATLTRACE(atlTraceRegistrar, 0, _T("Error no closing %% found\n"));
; 1191 : 					hr = GenerateError(E_ATL_UNEXPECTED_EOS);
; 1192 : 					break;
; 1193 : 				}
; 1194 : 				if ((lpszNext-m_pchCur) > 31)

  001ef	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001f1	2b c1		 sub	 eax, ecx
  001f3	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001f6	0f 8f 86 00 00
	00		 jg	 $LN75@PreProcess

; 1195 : 				{
; 1196 : 					hr = E_FAIL;
; 1197 : 					break;
; 1198 : 				}
; 1199 : 				int nLength = int(lpszNext - m_pchCur);
; 1200 : 				TCHAR buf[32];
; 1201 : 				Checked::tcsncpy_s(buf, _countof(buf), m_pchCur, nLength);

  001fc	50		 push	 eax
  001fd	51		 push	 ecx
  001fe	8d 44 24 3c	 lea	 eax, DWORD PTR _buf$83327[esp+108]
  00202	6a 20		 push	 32			; 00000020H
  00204	50		 push	 eax
  00205	e8 00 00 00 00	 call	 __mbsnbcpy_s
  0020a	50		 push	 eax
  0020b	e8 00 00 00 00	 call	 ?AtlCrtErrorCheck@ATL@@YAHH@Z ; ATL::AtlCrtErrorCheck
  00210	83 c4 14	 add	 esp, 20			; 00000014H

; 1202 : 				LPCOLESTR lpszVar = m_pRegObj->StrFromMap(buf);

  00213	8d 4c 24 34	 lea	 ecx, DWORD PTR _buf$83327[esp+100]
  00217	51		 push	 ecx
  00218	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0021b	e8 00 00 00 00	 call	 ?StrFromMap@CRegObject@ATL@@QAEPB_WPAD@Z ; ATL::CRegObject::StrFromMap

; 1203 : 				if (lpszVar == NULL)

  00220	85 c0		 test	 eax, eax
  00222	74 45		 je	 SHORT $LN74@PreProcess

; 1204 : 				{
; 1205 : 					hr = GenerateError(E_ATL_NOT_IN_MAP);
; 1206 : 					break;
; 1207 : 				}
; 1208 : 				if (!pb.AddString(lpszVar))

  00224	50		 push	 eax
  00225	8d 4c 24 28	 lea	 ecx, DWORD PTR _pb$[esp+104]
  00229	e8 00 00 00 00	 call	 ?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z ; ATL::CRegParser::CParseBuffer::AddString
  0022e	85 c0		 test	 eax, eax
  00230	74 1e		 je	 SHORT $LN70@PreProcess

; 1209 : 				{
; 1210 : 					hr = E_OUTOFMEMORY;
; 1211 : 					break;
; 1212 : 				}
; 1213 : 
; 1214 : 				while (m_pchCur != lpszNext)

  00232	39 3e		 cmp	 DWORD PTR [esi], edi
  00234	0f 84 6b ff ff
	ff		 je	 $LN2@PreProcess
  0023a	8d 9b 00 00 00
	00		 npad	 6
$LL5@PreProcess:

; 1215 : 					m_pchCur = CharNext(m_pchCur);

  00240	8b 16		 mov	 edx, DWORD PTR [esi]
  00242	52		 push	 edx
  00243	ff d5		 call	 ebp
  00245	89 06		 mov	 DWORD PTR [esi], eax
  00247	3b c7		 cmp	 eax, edi
  00249	75 f5		 jne	 SHORT $LL5@PreProcess

; 1216 : 			}
; 1217 : 		}
; 1218 : 		else

  0024b	e9 55 ff ff ff	 jmp	 $LN2@PreProcess
$LN70@PreProcess:

; 1231 : 	return hr;

  00250	8b 54 24 2c	 mov	 edx, DWORD PTR _pb$[esp+108]
  00254	52		 push	 edx
  00255	c7 44 24 1c 0e
	00 07 80	 mov	 DWORD PTR _hr$[esp+104], -2147024882 ; 8007000eH
  0025d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoTaskMemFree@4
  00263	8b 44 24 18	 mov	 eax, DWORD PTR _hr$[esp+100]
  00267	eb 37		 jmp	 SHORT $LN34@PreProcess
$LN74@PreProcess:
  00269	8b 54 24 2c	 mov	 edx, DWORD PTR _pb$[esp+108]
  0026d	52		 push	 edx
  0026e	c7 44 24 1c 09
	00 02 80	 mov	 DWORD PTR _hr$[esp+104], -2147352567 ; 80020009H
  00276	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoTaskMemFree@4
  0027c	8b 44 24 18	 mov	 eax, DWORD PTR _hr$[esp+100]
  00280	eb 1e		 jmp	 SHORT $LN34@PreProcess
$LN75@PreProcess:
  00282	8b 54 24 2c	 mov	 edx, DWORD PTR _pb$[esp+108]
  00286	52		 push	 edx
  00287	c7 44 24 1c 05
	40 00 80	 mov	 DWORD PTR _hr$[esp+104], -2147467259 ; 80004005H
  0028f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoTaskMemFree@4
  00295	8b 44 24 18	 mov	 eax, DWORD PTR _hr$[esp+100]
  00299	eb 05		 jmp	 SHORT $LN34@PreProcess
$LN32@PreProcess:

; 1073 : 		return E_POINTER;

  0029b	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
$LN34@PreProcess:

; 1232 : }

  002a0	8b 4c 24 58	 mov	 ecx, DWORD PTR __$EHRec$[esp+100]
  002a4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002ab	59		 pop	 ecx
  002ac	5f		 pop	 edi
  002ad	5e		 pop	 esi
  002ae	5d		 pop	 ebp
  002af	5b		 pop	 ebx
  002b0	8b 4c 24 40	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+80]
  002b4	33 cc		 xor	 ecx, esp
  002b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002bb	83 c4 50	 add	 esp, 80			; 00000050H
  002be	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z$0:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR _pb$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CParseBuffer@CRegParser@ATL@@QAE@XZ ; ATL::CRegParser::CParseBuffer::~CParseBuffer
__ehhandler$?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 ac	 lea	 eax, DWORD PTR [edx-84]
  0000f	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	83 c0 10	 add	 eax, 16			; 00000010H
  0001c	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z ENDP	; ATL::CRegParser::PreProcessBuffer
PUBLIC	??0CExpansionVector@ATL@@QAE@XZ			; ATL::CExpansionVector::CExpansionVector
; Function compile flags: /Ogtpy
;	COMDAT ??0CExpansionVector@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CExpansionVector@ATL@@QAE@XZ PROC			; ATL::CExpansionVector::CExpansionVector, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000c	c3		 ret	 0
??0CExpansionVector@ATL@@QAE@XZ ENDP			; ATL::CExpansionVector::CExpansionVector
_TEXT	ENDS
PUBLIC	?Add@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEHABQADABQA_W@Z ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Add
EXTRN	__recalloc:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?Add@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEHABQADABQA_W@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
_val$ = 12						; size = 4
?Add@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEHABQADABQA_W@Z PROC ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Add, COMDAT
; _this$ = ecx

; 310  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 311  : 		TKey* pKey;
; 312  : 		pKey = (TKey*)_recalloc(m_aKey, (m_nSize + 1), sizeof(TKey));

  00003	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00006	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00008	6a 04		 push	 4
  0000a	40		 inc	 eax
  0000b	50		 push	 eax
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 __recalloc
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 313  : 		if(pKey == NULL)

  00015	85 c0		 test	 eax, eax
  00017	75 06		 jne	 SHORT $LN2@Add
$LN19@Add:

; 314  : 			return FALSE;

  00019	33 c0		 xor	 eax, eax
  0001b	5e		 pop	 esi

; 324  : 	}

  0001c	c2 08 00	 ret	 8
$LN2@Add:

; 315  : 		m_aKey = pKey;
; 316  : 		TVal* pVal;
; 317  : 		pVal = (TVal*)_recalloc(m_aVal, (m_nSize + 1), sizeof(TVal));

  0001f	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00022	6a 04		 push	 4
  00024	42		 inc	 edx
  00025	89 06		 mov	 DWORD PTR [esi], eax
  00027	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002a	52		 push	 edx
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 __recalloc
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 318  : 		if(pVal == NULL)

  00034	85 c0		 test	 eax, eax

; 319  : 			return FALSE;

  00036	74 e1		 je	 SHORT $LN19@Add

; 320  : 		m_aVal = pVal;

  00038	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 321  : 		InternalSetAtIndex(m_nSize, key, val);

  0003b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0003e	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  00045	8b 06		 mov	 eax, DWORD PTR [esi]
  00047	03 c1		 add	 eax, ecx
  00049	74 08		 je	 SHORT $LN7@Add
  0004b	8b 54 24 08	 mov	 edx, DWORD PTR _key$[esp]
  0004f	8b 12		 mov	 edx, DWORD PTR [edx]
  00051	89 10		 mov	 DWORD PTR [eax], edx
$LN7@Add:
  00053	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00056	03 c1		 add	 eax, ecx
  00058	74 08		 je	 SHORT $LN9@Add
  0005a	8b 4c 24 0c	 mov	 ecx, DWORD PTR _val$[esp]
  0005e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00060	89 10		 mov	 DWORD PTR [eax], edx
$LN9@Add:

; 322  : 		m_nSize++;

  00062	ff 46 08	 inc	 DWORD PTR [esi+8]

; 323  : 		return TRUE;

  00065	b8 01 00 00 00	 mov	 eax, 1
  0006a	5e		 pop	 esi

; 324  : 	}

  0006b	c2 08 00	 ret	 8
?Add@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEHABQADABQA_W@Z ENDP ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Add
_TEXT	ENDS
PUBLIC	?Allocate@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::Allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Allocate@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_nElements$ = 8						; size = 4
?Allocate@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 483  : 		return( AllocateBytes( ::ATL::AtlMultiplyThrow(nElements,sizeof( T )) ) );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nElements$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	33 c9		 xor	 ecx, ecx
  00009	77 05		 ja	 SHORT $LN15@Allocate@2
  0000b	83 f8 ff	 cmp	 eax, -1
  0000e	76 0a		 jbe	 SHORT $LN3@Allocate@2
$LN15@Allocate@2:
  00010	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00015	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN3@Allocate@2:
  0001a	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  0001f	76 0e		 jbe	 SHORT $LN11@Allocate@2
  00021	50		 push	 eax
  00022	8b ce		 mov	 ecx, esi
  00024	e8 00 00 00 00	 call	 ?AllocateHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::AllocateHeap
  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	5e		 pop	 esi

; 484  : 	}

  0002c	c2 04 00	 ret	 4

; 483  : 		return( AllocateBytes( ::ATL::AtlMultiplyThrow(nElements,sizeof( T )) ) );

$LN11@Allocate@2:
  0002f	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00032	89 06		 mov	 DWORD PTR [esi], eax
  00034	5e		 pop	 esi

; 484  : 	}

  00035	c2 04 00	 ret	 4
$LN16@Allocate@2:
?Allocate@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
PUBLIC	?Allocate@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::Allocate
; Function compile flags: /Ogtpy
;	COMDAT ?Allocate@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_nElements$ = 8						; size = 4
?Allocate@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 483  : 		return( AllocateBytes( ::ATL::AtlMultiplyThrow(nElements,sizeof( T )) ) );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nElements$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	33 c9		 xor	 ecx, ecx
  00009	77 05		 ja	 SHORT $LN15@Allocate@3
  0000b	83 f8 ff	 cmp	 eax, -1
  0000e	76 0a		 jbe	 SHORT $LN3@Allocate@3
$LN15@Allocate@3:
  00010	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00015	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN3@Allocate@3:
  0001a	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0001f	76 0e		 jbe	 SHORT $LN11@Allocate@3
  00021	50		 push	 eax
  00022	8b ce		 mov	 ecx, esi
  00024	e8 00 00 00 00	 call	 ?AllocateHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::AllocateHeap
  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	5e		 pop	 esi

; 484  : 	}

  0002c	c2 04 00	 ret	 4

; 483  : 		return( AllocateBytes( ::ATL::AtlMultiplyThrow(nElements,sizeof( T )) ) );

$LN11@Allocate@3:
  0002f	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00032	89 06		 mov	 DWORD PTR [esi], eax
  00034	5e		 pop	 esi

; 484  : 	}

  00035	c2 04 00	 ret	 4
$LN16@Allocate@3:
?Allocate@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
PUBLIC	?Allocate@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::Allocate
; Function compile flags: /Ogtpy
;	COMDAT ?Allocate@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z
_TEXT	SEGMENT
_nElements$ = 8						; size = 4
?Allocate@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z PROC ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 483  : 		return( AllocateBytes( ::ATL::AtlMultiplyThrow(nElements,sizeof( T )) ) );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nElements$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	33 c9		 xor	 ecx, ecx
  00009	77 05		 ja	 SHORT $LN15@Allocate@4
  0000b	83 f8 ff	 cmp	 eax, -1
  0000e	76 0a		 jbe	 SHORT $LN3@Allocate@4
$LN15@Allocate@4:
  00010	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00015	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN3@Allocate@4:
  0001a	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0001f	76 0e		 jbe	 SHORT $LN11@Allocate@4
  00021	50		 push	 eax
  00022	8b ce		 mov	 ecx, esi
  00024	e8 00 00 00 00	 call	 ?AllocateHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::AllocateHeap
  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	5e		 pop	 esi

; 484  : 	}

  0002c	c2 04 00	 ret	 4

; 483  : 		return( AllocateBytes( ::ATL::AtlMultiplyThrow(nElements,sizeof( T )) ) );

$LN11@Allocate@4:
  0002f	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00032	89 06		 mov	 DWORD PTR [esi], eax
  00034	5e		 pop	 esi

; 484  : 	}

  00035	c2 04 00	 ret	 4
$LN16@Allocate@4:
?Allocate@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z ENDP ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
PUBLIC	?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z	; ATL::CExpansionVector::Add
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlbase.h
xdata$x	SEGMENT
__catchsym$?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z$7 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z$2
__catchsym$?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z$0
__ehfuncinfo$?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z
	DD	02H
	DD	FLAT:__tryblocktable$?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z$6
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z$7
__unwindtable$?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z$4
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	FLAT:__unwindfunclet$?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\statreg.h
xdata$x	ENDS
;	COMDAT ?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
_spValue$ = -40						; size = 4
_cbValue$ = -40						; size = 4
_spKey$ = -36						; size = 4
_cbKey$ = -32						; size = 4
_hRes$ = -28						; size = 4
_szValue$ = -24						; size = 4
_szKey$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_lpszKey$ = 8						; size = 4
_lpszValue$ = 12					; size = 4
?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z PROC		; ATL::CExpansionVector::Add, COMDAT
; _this$ = ecx

; 97   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx

; 98   : 		ATLASSERT(lpszKey != NULL && lpszValue != NULL);
; 99   : 		if (lpszKey == NULL || lpszValue == NULL)

  0002e	8b 45 08	 mov	 eax, DWORD PTR _lpszKey$[ebp]
  00031	33 db		 xor	 ebx, ebx
  00033	3b c3		 cmp	 eax, ebx
  00035	0f 84 19 01 00
	00		 je	 $LN8@Add@2
  0003b	39 5d 0c	 cmp	 DWORD PTR _lpszValue$[ebp], ebx
  0003e	0f 84 10 01 00
	00		 je	 $LN8@Add@2

; 101  : 
; 102  : 		HRESULT hRes = S_OK;
; 103  : 
; 104  : 		size_t cbKey = (lstrlen(lpszKey)+1)*sizeof(TCHAR);

  00044	50		 push	 eax
  00045	89 5d e4	 mov	 DWORD PTR _hRes$[ebp], ebx
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  0004e	8b f0		 mov	 esi, eax
  00050	46		 inc	 esi

; 105  : 		TCHAR* szKey = NULL;
; 106  : 
; 107  : 		ATLTRY(szKey = new TCHAR[cbKey];)

  00051	56		 push	 esi
  00052	89 75 e0	 mov	 DWORD PTR _cbKey$[ebp], esi
  00055	89 5d ec	 mov	 DWORD PTR _szKey$[ebp], ebx
  00058	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx
  0005b	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00060	83 c4 04	 add	 esp, 4
  00063	89 45 ec	 mov	 DWORD PTR _szKey$[ebp], eax
  00066	eb 0b		 jmp	 SHORT $LN19@Add@2
__catch$?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z$0:
  00068	b8 00 00 00 00	 mov	 eax, $LN59@Add@2
  0006d	c3		 ret	 0
$LN59@Add@2:
  0006e	8b 75 e0	 mov	 esi, DWORD PTR _cbKey$[ebp]
  00071	33 db		 xor	 ebx, ebx
$LN19@Add@2:

; 108  : 		CAutoVectorPtr<TCHAR> spKey;
; 109  : 		spKey.Attach(szKey);
; 110  : 
; 111  : 		size_t cbValue = (ocslen(lpszValue)+1)*sizeof(OLECHAR);

  00073	8b 4d 0c	 mov	 ecx, DWORD PTR _lpszValue$[ebp]
  00076	8b 45 ec	 mov	 eax, DWORD PTR _szKey$[ebp]
  00079	51		 push	 ecx
  0007a	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2
  00081	89 45 dc	 mov	 DWORD PTR _spKey$[ebp], eax
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0008a	8d 7c 00 02	 lea	 edi, DWORD PTR [eax+eax+2]

; 112  : 		LPOLESTR szValue = NULL;
; 113  : 		ATLTRY(szValue = new OLECHAR[cbValue];)

  0008e	33 c9		 xor	 ecx, ecx
  00090	8b c7		 mov	 eax, edi
  00092	ba 02 00 00 00	 mov	 edx, 2
  00097	f7 e2		 mul	 edx
  00099	0f 90 c1	 seto	 cl
  0009c	89 7d d8	 mov	 DWORD PTR _cbValue$[ebp], edi
  0009f	89 5d e8	 mov	 DWORD PTR _szValue$[ebp], ebx
  000a2	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
  000a6	f7 d9		 neg	 ecx
  000a8	0b c8		 or	 ecx, eax
  000aa	51		 push	 ecx
  000ab	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  000b0	8b d8		 mov	 ebx, eax
  000b2	83 c4 04	 add	 esp, 4
  000b5	89 5d e8	 mov	 DWORD PTR _szValue$[ebp], ebx
  000b8	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2
  000bf	eb 16		 jmp	 SHORT $LN21@Add@2
__catch$?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z$2:
  000c1	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2
  000c8	b8 00 00 00 00	 mov	 eax, $LN60@Add@2
  000cd	c3		 ret	 0
$LN60@Add@2:
  000ce	8b 75 e0	 mov	 esi, DWORD PTR _cbKey$[ebp]
  000d1	8b 7d d8	 mov	 edi, DWORD PTR _cbValue$[ebp]
  000d4	8b 5d e8	 mov	 ebx, DWORD PTR _szValue$[ebp]
$LN21@Add@2:

; 114  : 		CAutoVectorPtr<OLECHAR> spValue;
; 115  : 		spValue.Attach(szValue);
; 116  : 
; 117  : 		if (szKey == NULL || szValue == NULL)

  000d7	8b 45 ec	 mov	 eax, DWORD PTR _szKey$[ebp]
  000da	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5
  000de	89 5d d8	 mov	 DWORD PTR _spValue$[ebp], ebx
  000e1	85 c0		 test	 eax, eax
  000e3	74 33		 je	 SHORT $LN4@Add@2
  000e5	85 db		 test	 ebx, ebx
  000e7	74 2f		 je	 SHORT $LN4@Add@2

; 118  : 			hRes = E_OUTOFMEMORY;
; 119  : 		else
; 120  : 		{
; 121  : 			Checked::memcpy_s(szKey, cbKey, lpszKey, cbKey);

  000e9	8b 4d 08	 mov	 ecx, DWORD PTR _lpszKey$[ebp]
  000ec	56		 push	 esi
  000ed	51		 push	 ecx
  000ee	56		 push	 esi
  000ef	50		 push	 eax
  000f0	e8 00 00 00 00	 call	 ?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z ; ATL::Checked::memcpy_s

; 122  : 			Checked::memcpy_s(szValue, cbValue, lpszValue, cbValue);

  000f5	8b 55 0c	 mov	 edx, DWORD PTR _lpszValue$[ebp]
  000f8	57		 push	 edi
  000f9	52		 push	 edx
  000fa	57		 push	 edi
  000fb	53		 push	 ebx
  000fc	e8 00 00 00 00	 call	 ?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z ; ATL::Checked::memcpy_s
  00101	83 c4 20	 add	 esp, 32			; 00000020H

; 123  : 			if (!CSimpleMap<LPTSTR, LPOLESTR, CExpansionVectorEqualHelper>::Add(szKey, szValue))

  00104	8d 45 e8	 lea	 eax, DWORD PTR _szValue$[ebp]
  00107	50		 push	 eax
  00108	8d 4d ec	 lea	 ecx, DWORD PTR _szKey$[ebp]
  0010b	51		 push	 ecx
  0010c	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  0010f	e8 00 00 00 00	 call	 ?Add@?$CSimpleMap@PADPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEHABQADABQA_W@Z ; ATL::CSimpleMap<char *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Add
  00114	85 c0		 test	 eax, eax
  00116	75 09		 jne	 SHORT $LN58@Add@2
$LN4@Add@2:

; 124  : 				hRes = E_OUTOFMEMORY;

  00118	c7 45 e4 0e 00
	07 80		 mov	 DWORD PTR _hRes$[ebp], -2147024882 ; 8007000eH
  0011f	eb 05		 jmp	 SHORT $LN46@Add@2
$LN58@Add@2:

; 125  : 		}
; 126  : 		if (SUCCEEDED(hRes))
; 127  : 		{
; 128  : 			spKey.Detach();

  00121	33 db		 xor	 ebx, ebx
  00123	89 5d dc	 mov	 DWORD PTR _spKey$[ebp], ebx

; 129  : 			spValue.Detach();

$LN46@Add@2:

; 130  : 		}
; 131  : 		return SUCCEEDED(hRes);

  00126	53		 push	 ebx
  00127	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0012c	8b 55 dc	 mov	 edx, DWORD PTR _spKey$[ebp]
  0012f	52		 push	 edx
  00130	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00135	33 c0		 xor	 eax, eax
  00137	83 c4 08	 add	 esp, 8
  0013a	39 45 e4	 cmp	 DWORD PTR _hRes$[ebp], eax
  0013d	0f 9d c0	 setge	 al

; 132  : 	}

  00140	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00143	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0014a	59		 pop	 ecx
  0014b	5f		 pop	 edi
  0014c	5e		 pop	 esi
  0014d	5b		 pop	 ebx
  0014e	8b e5		 mov	 esp, ebp
  00150	5d		 pop	 ebp
  00151	c2 08 00	 ret	 8
$LN8@Add@2:

; 100  : 			return FALSE;

  00154	33 c0		 xor	 eax, eax

; 132  : 	}

  00156	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00159	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00160	59		 pop	 ecx
  00161	5f		 pop	 edi
  00162	5e		 pop	 esi
  00163	5b		 pop	 ebx
  00164	8b e5		 mov	 esp, ebp
  00166	5d		 pop	 ebp
  00167	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z$4:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR _spKey$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CAutoVectorPtr@D@ATL@@QAE@XZ ; ATL::CAutoVectorPtr<char>::~CAutoVectorPtr<char>
__unwindfunclet$?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z$5:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR _spValue$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$CAutoVectorPtr@_W@ATL@@QAE@XZ ; ATL::CAutoVectorPtr<wchar_t>::~CAutoVectorPtr<wchar_t>
__ehhandler$?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z ENDP		; ATL::CExpansionVector::Add
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlcore.h
xdata$x	SEGMENT
__unwindtable$?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z$0
__ehfuncinfo$?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\statreg.h
xdata$x	ENDS
;	COMDAT ?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z
_TEXT	SEGMENT
__AtlSafeAllocaManager$ = -20				; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszKey$ = 12						; size = 4
_lpszItem$ = 16						; size = 4
?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z PROC	; ATL::CRegObject::AddReplacement, COMDAT

; 348  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 349  : 	if (lpszKey == NULL || lpszItem == NULL)

  0002b	8b 5d 0c	 mov	 ebx, DWORD PTR _lpszKey$[ebp]
  0002e	33 f6		 xor	 esi, esi
  00030	3b de		 cmp	 ebx, esi
  00032	0f 84 bd 00 00
	00		 je	 $LN2@AddReplace
  00038	39 75 10	 cmp	 DWORD PTR _lpszItem$[ebp], esi
  0003b	0f 84 b4 00 00
	00		 je	 $LN2@AddReplace

; 351  : 	m_csMap.Lock();

  00041	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]
  00044	83 c7 10	 add	 edi, 16			; 00000010H
  00047	57		 push	 edi
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 352  : 	USES_CONVERSION_EX;

  0004e	89 75 ec	 mov	 DWORD PTR __AtlSafeAllocaManager$[ebp], esi

; 353  : 	
; 354  : 	LPCTSTR lpszT = OLE2CT_EX(lpszKey, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

  00051	53		 push	 ebx
  00052	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0005b	56		 push	 esi
  0005c	40		 inc	 eax
  0005d	99		 cdq
  0005e	6a 02		 push	 2
  00060	52		 push	 edx
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 __allmul
  00067	8b f0		 mov	 esi, eax
  00069	05 00 00 00 80	 add	 eax, -2147483648	; 80000000H
  0006e	83 d2 00	 adc	 edx, 0
  00071	85 d2		 test	 edx, edx
  00073	77 3e		 ja	 SHORT $LN34@AddReplace
  00075	72 05		 jb	 SHORT $LN35@AddReplace
  00077	83 f8 ff	 cmp	 eax, -1
  0007a	77 37		 ja	 SHORT $LN34@AddReplace
$LN35@AddReplace:
  0007c	81 fe 00 04 00
	00		 cmp	 esi, 1024		; 00000400H
  00082	7f 18		 jg	 SHORT $LN6@AddReplace
  00084	56		 push	 esi
  00085	e8 00 00 00 00	 call	 ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
  0008a	83 c4 04	 add	 esp, 4
  0008d	84 c0		 test	 al, al
  0008f	74 0b		 je	 SHORT $LN6@AddReplace
  00091	8b c6		 mov	 eax, esi
  00093	e8 00 00 00 00	 call	 __alloca_probe_16
  00098	8b c4		 mov	 eax, esp
  0009a	eb 09		 jmp	 SHORT $LN7@AddReplace
$LN6@AddReplace:
  0009c	56		 push	 esi
  0009d	8d 4d ec	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  000a0	e8 00 00 00 00	 call	 ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
$LN7@AddReplace:
  000a5	6a 03		 push	 3
  000a7	56		 push	 esi
  000a8	53		 push	 ebx
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper

; 355  : 
; 356  : #ifndef _UNICODE
; 357  : 	if(lpszT == NULL)

  000af	85 c0		 test	 eax, eax
  000b1	75 0f		 jne	 SHORT $LN1@AddReplace
$LN34@AddReplace:

; 358  : 		return E_OUTOFMEMORY;

  000b3	8d 4d ec	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  000b6	e8 00 00 00 00	 call	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
  000bb	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  000c0	eb 38		 jmp	 SHORT $LN4@AddReplace
$LN1@AddReplace:

; 359  : #endif
; 360  : 	
; 361  : 	BOOL bRet = m_RepMap.Add(lpszT, lpszItem);

  000c2	8b 4d 10	 mov	 ecx, DWORD PTR _lpszItem$[ebp]
  000c5	51		 push	 ecx
  000c6	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	50		 push	 eax
  000ca	83 c1 04	 add	 ecx, 4
  000cd	e8 00 00 00 00	 call	 ?Add@CExpansionVector@ATL@@QAEHPBDPB_W@Z ; ATL::CExpansionVector::Add

; 362  : 	m_csMap.Unlock();

  000d2	57		 push	 edi
  000d3	8b f0		 mov	 esi, eax
  000d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 363  : 	return bRet ? S_OK : E_OUTOFMEMORY;

  000db	8d 4d ec	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  000de	e8 00 00 00 00	 call	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
  000e3	8b c6		 mov	 eax, esi
  000e5	f7 d8		 neg	 eax
  000e7	1b c0		 sbb	 eax, eax
  000e9	25 f2 ff f8 7f	 and	 eax, 2147024882		; 7ff8fff2H
  000ee	05 0e 00 07 80	 add	 eax, -2147024882	; 8007000eH
  000f3	eb 05		 jmp	 SHORT $LN4@AddReplace
$LN2@AddReplace:

; 350  : 		return E_INVALIDARG;

  000f5	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
$LN4@AddReplace:

; 364  : }

  000fa	8d 65 dc	 lea	 esp, DWORD PTR [ebp-36]
  000fd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00100	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00107	59		 pop	 ecx
  00108	5f		 pop	 edi
  00109	5e		 pop	 esi
  0010a	5b		 pop	 ebx
  0010b	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010e	33 cd		 xor	 ecx, ebp
  00110	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00115	8b e5		 mov	 esp, ebp
  00117	5d		 pop	 ebp
  00118	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z ENDP	; ATL::CRegObject::AddReplacement
PUBLIC	_szToken$GSCopy$
PUBLIC	_szValueName$GSCopy$
PUBLIC	_rkParent$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z ; ATL::CRegParser::AddValue
EXTRN	__imp__IsDBCSLeadByte@4:PROC
EXTRN	__imp__VarUI4FromStr@16:PROC
EXTRN	_memset:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlalloc.h
xdata$x	SEGMENT
__catchsym$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z$8 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z$2
__catchsym$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z$7 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z$0
__ehfuncinfo$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z
	DD	02H
	DD	FLAT:__tryblocktable$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z$7
	DD	05H
	DD	05H
	DD	06H
	DD	01H
	DD	FLAT:__catchsym$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z$8
__unwindtable$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z$4
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z$6
	DD	04H
	DD	00H
	DD	04H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\statreg.h
xdata$x	ENDS
;	COMDAT ?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z
_TEXT	SEGMENT
_this$GSCopy$ = -40					; size = 4
_szToken$GSCopy$ = -36					; size = 4
_rkParent$GSCopy$ = -32					; size = 4
_cbValue$83174 = -28					; size = 4
_ulVal$83157 = -28					; size = 4
_szValueName$GSCopy$ = -24				; size = 4
__convert_ex$83158 = -24				; size = 4
_vt$ = -20						; size = 2
_cbValDiv2$83177 = -20					; size = 4
__AtlSafeAllocaManager$83163 = -20			; size = 4
__$EHRec$ = -16						; size = 16
_rgBinary$83213 = 0					; size = 260
_pszDestValue$83142 = 0					; size = 260
_szValue$ = 260						; size = 4096
__$ArrayPad$ = 4356					; size = 4
_rkParent$ = 4368					; size = 4
_szValueName$ = 4372					; size = 4
_szToken$ = 4376					; size = 4
?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z PROC ; ATL::CRegParser::AddValue, COMDAT
; _this$ = ecx

; 866  : {

  00000	55		 push	 ebp
  00001	8d ac 24 f8 ee
	ff ff		 lea	 ebp, DWORD PTR [esp-4360]
  00008	b8 08 11 00 00	 mov	 eax, 4360		; 00001108H
  0000d	e8 00 00 00 00	 call	 __chkstk
  00012	6a ff		 push	 -1
  00014	68 00 00 00 00	 push	 __ehhandler$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z
  00019	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001f	50		 push	 eax
  00020	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00028	33 c5		 xor	 eax, ebp
  0002a	89 85 04 11 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00030	53		 push	 ebx
  00031	56		 push	 esi
  00032	57		 push	 edi
  00033	50		 push	 eax
  00034	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00037	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003d	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 986  : 	}
; 987  : 
; 988  : 	if (FAILED(hr = NextToken(szToken)))

  00040	8b 85 18 11 00
	00		 mov	 eax, DWORD PTR _szToken$[ebp]
  00046	8b bd 10 11 00
	00		 mov	 edi, DWORD PTR _rkParent$[ebp]
  0004c	8b 9d 14 11 00
	00		 mov	 ebx, DWORD PTR _szValueName$[ebp]
  00052	8b f1		 mov	 esi, ecx
  00054	8d 8d 04 01 00
	00		 lea	 ecx, DWORD PTR _szValue$[ebp]
  0005a	51		 push	 ecx
  0005b	8b ce		 mov	 ecx, esi
  0005d	89 75 d8	 mov	 DWORD PTR _this$GSCopy$[ebp], esi
  00060	89 7d e0	 mov	 DWORD PTR _rkParent$GSCopy$[ebp], edi
  00063	89 5d e8	 mov	 DWORD PTR _szValueName$GSCopy$[ebp], ebx
  00066	89 45 dc	 mov	 DWORD PTR _szToken$GSCopy$[ebp], eax
  00069	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _vt$[ebp], 0
  00070	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  00075	85 c0		 test	 eax, eax
  00077	0f 8c 02 03 00
	00		 jl	 $LN1@AddValue
  0007d	8d 55 ec	 lea	 edx, DWORD PTR _vt$[ebp]
  00080	52		 push	 edx
  00081	8d 85 04 01 00
	00		 lea	 eax, DWORD PTR _szValue$[ebp]
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 ?VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z ; ATL::CRegParser::VTFromRegType
  0008d	83 c4 08	 add	 esp, 8
  00090	85 c0		 test	 eax, eax
  00092	75 0a		 jne	 SHORT $LN26@AddValue

; 867  : 	HRESULT hr;
; 868  : 
; 869  : 	TCHAR		szValue[MAX_VALUE];
; 870  : 	VARTYPE     vt = VT_EMPTY;
; 871  : 	LONG        lRes = ERROR_SUCCESS;
; 872  : 	UINT        nIDRes = 0;
; 873  : 
; 874  : 	if (FAILED(hr = NextToken(szValue)))
; 875  : 		return hr;
; 876  : 	if (!VTFromRegType(szValue, vt))
; 877  : 	{
; 878  : 		ATLTRACE(atlTraceRegistrar, 0, _T("%s Type not supported\n"), szValue);
; 879  : 		return GenerateError(E_ATL_TYPE_NOT_SUPPORTED);

  00094	b8 09 00 02 80	 mov	 eax, -2147352567	; 80020009H
  00099	e9 e1 02 00 00	 jmp	 $LN1@AddValue
$LN26@AddValue:

; 880  : 	}
; 881  : #pragma warning(pop)
; 882  : 
; 883  : 	SkipWhiteSpace();

  0009e	8b ce		 mov	 ecx, esi
  000a0	e8 00 00 00 00	 call	 ?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ ; ATL::CRegParser::SkipWhiteSpace

; 884  : 	if (FAILED(hr = NextToken(szValue)))

  000a5	8d 8d 04 01 00
	00		 lea	 ecx, DWORD PTR _szValue$[ebp]
  000ab	51		 push	 ecx
  000ac	8b ce		 mov	 ecx, esi
  000ae	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  000b3	85 c0		 test	 eax, eax

; 885  : 		return hr;

  000b5	0f 8c c4 02 00
	00		 jl	 $LN1@AddValue

; 886  : 
; 887  : 	switch (vt)

  000bb	0f b7 45 ec	 movzx	 eax, WORD PTR _vt$[ebp]
  000bf	83 f8 13	 cmp	 eax, 19			; 00000013H
  000c2	0f 8f d0 01 00
	00		 jg	 $LN36@AddValue
  000c8	0f 84 17 01 00
	00		 je	 $LN11@AddValue
  000ce	83 f8 08	 cmp	 eax, 8
  000d1	0f 84 f6 00 00
	00		 je	 $LN22@AddValue
  000d7	83 f8 11	 cmp	 eax, 17			; 00000011H
  000da	0f 85 8a 02 00
	00		 jne	 $LN2@AddValue

; 960  : 		}
; 961  : 	case VT_UI1:
; 962  : 		{
; 963  : 			int cbValue = lstrlen(szValue);

  000e0	8d 95 04 01 00
	00		 lea	 edx, DWORD PTR _szValue$[ebp]
  000e6	52		 push	 edx
  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  000ed	8b d8		 mov	 ebx, eax
  000ef	89 5d e4	 mov	 DWORD PTR _cbValue$83174[ebp], ebx

; 964  : 			if (cbValue & 0x00000001)

  000f2	f6 c3 01	 test	 bl, 1

; 965  : 			{
; 966  : 				ATLTRACE(atlTraceRegistrar, 0, _T("Binary Data does not fall on BYTE boundries\n"));
; 967  : 				return E_FAIL;

  000f5	75 49		 jne	 SHORT $LN69@AddValue

; 968  : 			}
; 969  : 			int cbValDiv2 = cbValue/2;

  000f7	99		 cdq
  000f8	2b c2		 sub	 eax, edx
  000fa	8b f8		 mov	 edi, eax
  000fc	d1 ff		 sar	 edi, 1
  000fe	89 7d ec	 mov	 DWORD PTR _cbValDiv2$83177[ebp], edi

; 970  : 			CTempBuffer<BYTE, 256> rgBinary;

  00101	c7 45 00 00 00
	00 00		 mov	 DWORD PTR _rgBinary$83213[ebp], 0
  00108	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4

; 971  : 			ATLTRY(rgBinary.Allocate(cbValDiv2));			

  0010f	57		 push	 edi
  00110	8d 4d 00	 lea	 ecx, DWORD PTR _rgBinary$83213[ebp]
  00113	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5
  00117	e8 00 00 00 00	 call	 ?Allocate@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::Allocate
  0011c	eb 0c		 jmp	 SHORT $LN47@AddValue
__catch$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z$2:
  0011e	b8 00 00 00 00	 mov	 eax, $LN91@AddValue
  00123	c3		 ret	 0
$LN91@AddValue:
  00124	8b 5d e4	 mov	 ebx, DWORD PTR _cbValue$83174[ebp]
  00127	8b 7d ec	 mov	 edi, DWORD PTR _cbValDiv2$83177[ebp]
$LN47@AddValue:

; 972  : 			if (rgBinary == NULL)

  0012a	8b 45 00	 mov	 eax, DWORD PTR _rgBinary$83213[ebp]
  0012d	85 c0		 test	 eax, eax
  0012f	75 19		 jne	 SHORT $LN6@AddValue

; 973  : 				return E_FAIL;

  00131	8d 45 04	 lea	 eax, DWORD PTR _rgBinary$83213[ebp+4]
  00134	85 c0		 test	 eax, eax
  00136	74 08		 je	 SHORT $LN69@AddValue
  00138	8d 4d 00	 lea	 ecx, DWORD PTR _rgBinary$83213[ebp]
  0013b	e8 00 00 00 00	 call	 ?FreeHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::FreeHeap
$LN69@AddValue:
  00140	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00145	e9 35 02 00 00	 jmp	 $LN1@AddValue
$LN6@AddValue:

; 974  : 			memset(rgBinary, 0, cbValDiv2);				

  0014a	57		 push	 edi
  0014b	6a 00		 push	 0
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 _memset
  00153	83 c4 0c	 add	 esp, 12			; 0000000cH

; 975  : 			for (int irg = 0; irg < cbValue; irg++)

  00156	33 f6		 xor	 esi, esi
  00158	85 db		 test	 ebx, ebx
  0015a	7e 3d		 jle	 SHORT $LN3@AddValue
  0015c	8d 64 24 00	 npad	 4
$LL5@AddValue:

; 976  : 				rgBinary[(irg/2)] |= (ChToByte(szValue[irg])) << (4*(1 - (irg & 0x00000001)));

  00160	0f b6 84 35 04
	01 00 00	 movzx	 eax, BYTE PTR _szValue$[ebp+esi]
  00168	8b 55 00	 mov	 edx, DWORD PTR _rgBinary$83213[ebp]
  0016b	8b ce		 mov	 ecx, esi
  0016d	d1 e9		 shr	 ecx, 1
  0016f	50		 push	 eax
  00170	8d 3c 11	 lea	 edi, DWORD PTR [ecx+edx]
  00173	e8 00 00 00 00	 call	 ?ChToByte@CRegParser@ATL@@KAED@Z ; ATL::CRegParser::ChToByte
  00178	8b ce		 mov	 ecx, esi
  0017a	83 e1 01	 and	 ecx, 1
  0017d	03 c9		 add	 ecx, ecx
  0017f	03 c9		 add	 ecx, ecx
  00181	8b d1		 mov	 edx, ecx
  00183	b9 04 00 00 00	 mov	 ecx, 4
  00188	2b ca		 sub	 ecx, edx
  0018a	d2 e0		 shl	 al, cl
  0018c	46		 inc	 esi
  0018d	83 c4 04	 add	 esp, 4
  00190	08 07		 or	 BYTE PTR [edi], al
  00192	3b f3		 cmp	 esi, ebx
  00194	7c ca		 jl	 SHORT $LL5@AddValue

; 975  : 			for (int irg = 0; irg < cbValue; irg++)

  00196	8b 7d ec	 mov	 edi, DWORD PTR _cbValDiv2$83177[ebp]
$LN3@AddValue:

; 977  : 			lRes = RegSetValueEx(rkParent, szValueName, 0, REG_BINARY, rgBinary, cbValDiv2);

  00199	8b 4d 00	 mov	 ecx, DWORD PTR _rgBinary$83213[ebp]
  0019c	8b 55 e8	 mov	 edx, DWORD PTR _szValueName$GSCopy$[ebp]
  0019f	8b 45 e0	 mov	 eax, DWORD PTR _rkParent$GSCopy$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	57		 push	 edi
  001a5	51		 push	 ecx
  001a6	6a 03		 push	 3
  001a8	6a 00		 push	 0
  001aa	52		 push	 edx
  001ab	50		 push	 eax
  001ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24
  001b2	8b f0		 mov	 esi, eax

; 978  : 			break;

  001b4	8d 45 04	 lea	 eax, DWORD PTR _rgBinary$83213[ebp+4]
  001b7	39 45 00	 cmp	 DWORD PTR _rgBinary$83213[ebp], eax
  001ba	0f 84 98 01 00
	00		 je	 $LN58@AddValue
  001c0	8d 4d 00	 lea	 ecx, DWORD PTR _rgBinary$83213[ebp]
  001c3	e8 00 00 00 00	 call	 ?FreeHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::FreeHeap
  001c8	e9 8b 01 00 00	 jmp	 $LN58@AddValue
$LN22@AddValue:

; 888  : 	{
; 889  : 	case VT_BSTR:
; 890  : 		{
; 891  : 			lRes = rkParent.SetStringValue(szValueName, szValue);

  001cd	6a 01		 push	 1
  001cf	8d 8d 04 01 00
	00		 lea	 ecx, DWORD PTR _szValue$[ebp]
  001d5	51		 push	 ecx
  001d6	53		 push	 ebx
  001d7	8b cf		 mov	 ecx, edi
  001d9	e8 00 00 00 00	 call	 ?SetStringValue@CRegKey@ATL@@QAEJPBD0K@Z ; ATL::CRegKey::SetStringValue
  001de	8b f0		 mov	 esi, eax

; 892  : 			ATLTRACE(atlTraceRegistrar, 2, _T("Setting Value %s at %s\n"), szValue, !szValueName ? _T("default") : szValueName);
; 893  : 			break;

  001e0	e9 73 01 00 00	 jmp	 $LN58@AddValue
$LN11@AddValue:

; 944  : 		break;
; 945  : 	case VT_UI4:
; 946  : 		{
; 947  : 			ULONG ulVal;
; 948  : 			USES_CONVERSION_EX;

  001e5	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __AtlSafeAllocaManager$83163[ebp], 0

; 949  : 
; 950  : 			LPOLESTR lpszV = T2OLE_EX(szValue, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

  001ec	8d 95 04 01 00
	00		 lea	 edx, DWORD PTR _szValue$[ebp]
  001f2	52		 push	 edx
  001f3	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 3
  001fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  00200	40		 inc	 eax
  00201	6a 02		 push	 2
  00203	50		 push	 eax
  00204	89 45 e8	 mov	 DWORD PTR __convert_ex$83158[ebp], eax
  00207	8d 45 e8	 lea	 eax, DWORD PTR __convert_ex$83158[ebp]
  0020a	50		 push	 eax
  0020b	e8 00 00 00 00	 call	 ??$AtlMultiply@H@ATL@@YAJPAHHH@Z ; ATL::AtlMultiply<int>
  00210	83 c4 0c	 add	 esp, 12			; 0000000cH
  00213	85 c0		 test	 eax, eax
  00215	7c 45		 jl	 SHORT $LN90@AddValue
  00217	8b 75 e8	 mov	 esi, DWORD PTR __convert_ex$83158[ebp]
  0021a	81 fe 00 04 00
	00		 cmp	 esi, 1024		; 00000400H
  00220	7f 1b		 jg	 SHORT $LN30@AddValue
  00222	56		 push	 esi
  00223	e8 00 00 00 00	 call	 ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
  00228	83 c4 04	 add	 esp, 4
  0022b	84 c0		 test	 al, al
  0022d	74 0e		 je	 SHORT $LN30@AddValue
  0022f	8b c6		 mov	 eax, esi
  00231	e8 00 00 00 00	 call	 __alloca_probe_16
  00236	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00239	8b c4		 mov	 eax, esp
  0023b	eb 09		 jmp	 SHORT $LN31@AddValue
$LN30@AddValue:
  0023d	56		 push	 esi
  0023e	8d 4d ec	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$83163[ebp]
  00241	e8 00 00 00 00	 call	 ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
$LN31@AddValue:
  00246	6a 03		 push	 3
  00248	d1 ee		 shr	 esi, 1
  0024a	56		 push	 esi
  0024b	8d 8d 04 01 00
	00		 lea	 ecx, DWORD PTR _szValue$[ebp]
  00251	51		 push	 ecx
  00252	50		 push	 eax
  00253	e8 00 00 00 00	 call	 ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z ; AtlA2WHelper

; 951  : 	#ifndef _UNICODE
; 952  : 			if(lpszV == NULL) 

  00258	85 c0		 test	 eax, eax
  0025a	75 12		 jne	 SHORT $LN10@AddValue
$LN90@AddValue:

; 953  : 				return E_OUTOFMEMORY;

  0025c	8d 4d ec	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$83163[ebp]
  0025f	e8 00 00 00 00	 call	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
  00264	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  00269	e9 11 01 00 00	 jmp	 $LN1@AddValue
$LN10@AddValue:

; 954  : 	#endif	
; 955  : 			VarUI4FromStr(lpszV, 0, 0, &ulVal);

  0026e	8d 55 e4	 lea	 edx, DWORD PTR _ulVal$83157[ebp]
  00271	52		 push	 edx
  00272	6a 00		 push	 0
  00274	6a 00		 push	 0
  00276	50		 push	 eax
  00277	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VarUI4FromStr@16

; 956  : 			
; 957  : 			lRes = rkParent.SetDWORDValue(szValueName, ulVal);

  0027d	8b 45 e4	 mov	 eax, DWORD PTR _ulVal$83157[ebp]
  00280	50		 push	 eax
  00281	53		 push	 ebx
  00282	8b cf		 mov	 ecx, edi
  00284	e8 00 00 00 00	 call	 ?SetDWORDValue@CRegKey@ATL@@QAEJPBDK@Z ; ATL::CRegKey::SetDWORDValue

; 958  : 			ATLTRACE(atlTraceRegistrar, 2, _T("Setting Value %d at %s\n"), ulVal, !szValueName ? _T("default") : szValueName);
; 959  : 			break;

  00289	8d 4d ec	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$83163[ebp]
  0028c	8b f0		 mov	 esi, eax
  0028e	e8 00 00 00 00	 call	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
  00293	e9 c0 00 00 00	 jmp	 $LN58@AddValue
$LN36@AddValue:

; 886  : 
; 887  : 	switch (vt)

  00298	3d 08 40 00 00	 cmp	 eax, 16392		; 00004008H
  0029d	0f 85 c7 00 00
	00		 jne	 $LN2@AddValue

; 894  : 		}
; 895  : 	case VT_BSTR | VT_BYREF:
; 896  : 		{
; 897  : 			ATLTRACE(atlTraceRegistrar, 2, _T("Setting Value %s at %s\n"), szValue, !szValueName ? _T("default") : szValueName);
; 898  : 			int nLen = lstrlen(szValue) + 2; //Allocate space for double null termination.

  002a3	8d 8d 04 01 00
	00		 lea	 ecx, DWORD PTR _szValue$[ebp]
  002a9	51		 push	 ecx
  002aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4

; 899  : 			CTempBuffer<TCHAR, 256> pszDestValue;

  002b0	33 c9		 xor	 ecx, ecx
  002b2	83 c0 02	 add	 eax, 2
  002b5	89 4d 00	 mov	 DWORD PTR _pszDestValue$83142[ebp], ecx
  002b8	89 4d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ecx

; 900  : 			//nLen should be >= the max size of the target buffer.
; 901  : 			ATLTRY(pszDestValue.Allocate(nLen));

  002bb	50		 push	 eax
  002bc	8d 4d 00	 lea	 ecx, DWORD PTR _pszDestValue$83142[ebp]
  002bf	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  002c3	e8 00 00 00 00	 call	 ?Allocate@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::Allocate
$LN45@AddValue:

; 902  : 			if (pszDestValue != NULL)

  002c8	8b 7d 00	 mov	 edi, DWORD PTR _pszDestValue$83142[ebp]
  002cb	85 ff		 test	 edi, edi
  002cd	74 75		 je	 SHORT $LN19@AddValue

; 903  : 			{
; 904  : 				TCHAR* p = pszDestValue;
; 905  : 				TCHAR* q = szValue;
; 906  : 				nLen = 0;
; 907  : 				while (*q != _T('\0'))

  002cf	80 bd 04 01 00
	00 00		 cmp	 BYTE PTR _szValue$[ebp], 0
  002d6	8d b5 04 01 00
	00		 lea	 esi, DWORD PTR _szValue$[ebp]
  002dc	74 48		 je	 SHORT $LN87@AddValue
  002de	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__CharNextA@4
$LL18@AddValue:

; 908  : 				{
; 909  : 					TCHAR* r = CharNext(q);

  002e4	56		 push	 esi
  002e5	ff d3		 call	 ebx

; 910  : 					if (*q == _T('\\') && *r == _T('0'))

  002e7	8a 0e		 mov	 cl, BYTE PTR [esi]
  002e9	80 f9 5c	 cmp	 cl, 92			; 0000005cH
  002ec	75 16		 jne	 SHORT $LN16@AddValue
  002ee	80 38 30	 cmp	 BYTE PTR [eax], 48	; 00000030H
  002f1	75 11		 jne	 SHORT $LN16@AddValue

; 911  : 					{
; 912  : 						*p++ = NULL;

  002f3	c6 07 00	 mov	 BYTE PTR [edi], 0

; 913  : 						q = CharNext(r);

  002f6	50		 push	 eax
  002f7	47		 inc	 edi
  002f8	ff d3		 call	 ebx
  002fa	8b f0		 mov	 esi, eax

; 914  : 					}
; 915  : 					else

  002fc	eb 23		 jmp	 SHORT $LN15@AddValue
__catch$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z$0:

; 900  : 			//nLen should be >= the max size of the target buffer.
; 901  : 			ATLTRY(pszDestValue.Allocate(nLen));

  002fe	b8 00 00 00 00	 mov	 eax, $LN45@AddValue
  00303	c3		 ret	 0
$LN16@AddValue:

; 916  : 					{
; 917  : 						*p = *q;

  00304	88 0f		 mov	 BYTE PTR [edi], cl

; 918  : #ifndef _UNICODE
; 919  : 						if (IsDBCSLeadByte(*q))

  00306	0f b6 16	 movzx	 edx, BYTE PTR [esi]
  00309	52		 push	 edx
  0030a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsDBCSLeadByte@4
  00310	85 c0		 test	 eax, eax
  00312	74 0b		 je	 SHORT $LN14@AddValue

; 920  : 						{
; 921  : 							p++;
; 922  : 							q++;
; 923  : 							//Protect from Lead byte followed by the zero terminator.May skip beyond the end of the string.
; 924  : 							if (*q == _T('\0')) { break; }

  00314	8a 46 01	 mov	 al, BYTE PTR [esi+1]
  00317	46		 inc	 esi
  00318	47		 inc	 edi
  00319	84 c0		 test	 al, al
  0031b	74 09		 je	 SHORT $LN87@AddValue

; 925  : 							*p = *q;

  0031d	88 07		 mov	 BYTE PTR [edi], al
$LN14@AddValue:

; 926  : 						}
; 927  : #endif
; 928  : 						p++;

  0031f	47		 inc	 edi

; 929  : 						q++;

  00320	46		 inc	 esi
$LN15@AddValue:

; 903  : 			{
; 904  : 				TCHAR* p = pszDestValue;
; 905  : 				TCHAR* q = szValue;
; 906  : 				nLen = 0;
; 907  : 				while (*q != _T('\0'))

  00321	80 3e 00	 cmp	 BYTE PTR [esi], 0
  00324	75 be		 jne	 SHORT $LL18@AddValue
$LN87@AddValue:

; 930  : 					}
; 931  : 					nLen ++;
; 932  : 				}
; 933  : 			   //Always terminate with 2 NULLs.
; 934  : 				*p = NULL;
; 935  : 				p++;
; 936  : 			    *p = NULL;
; 937  : 				lRes = rkParent.SetMultiStringValue(szValueName, pszDestValue);

  00326	8b 4d e8	 mov	 ecx, DWORD PTR _szValueName$GSCopy$[ebp]
  00329	c6 07 00	 mov	 BYTE PTR [edi], 0
  0032c	c6 47 01 00	 mov	 BYTE PTR [edi+1], 0
  00330	8b 45 00	 mov	 eax, DWORD PTR _pszDestValue$83142[ebp]
  00333	50		 push	 eax
  00334	51		 push	 ecx
  00335	8b 4d e0	 mov	 ecx, DWORD PTR _rkParent$GSCopy$[ebp]
  00338	e8 00 00 00 00	 call	 ?SetMultiStringValue@CRegKey@ATL@@QAEJPBD0@Z ; ATL::CRegKey::SetMultiStringValue

; 938  : 			}
; 939  : 			else

  0033d	8b 7d 00	 mov	 edi, DWORD PTR _pszDestValue$83142[ebp]
  00340	8b f0		 mov	 esi, eax
  00342	eb 05		 jmp	 SHORT $LN12@AddValue
$LN19@AddValue:

; 940  : 			{
; 941  : 				lRes = ERROR_OUTOFMEMORY;

  00344	be 0e 00 00 00	 mov	 esi, 14			; 0000000eH
$LN12@AddValue:

; 942  : 			}
; 943  : 		}

  00349	8d 55 04	 lea	 edx, DWORD PTR _pszDestValue$83142[ebp+4]
  0034c	3b fa		 cmp	 edi, edx
  0034e	74 08		 je	 SHORT $LN58@AddValue
  00350	8d 4d 00	 lea	 ecx, DWORD PTR _pszDestValue$83142[ebp]
  00353	e8 00 00 00 00	 call	 ?FreeHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::FreeHeap
$LN58@AddValue:

; 979  : 		}
; 980  : 	}
; 981  : 
; 982  : 	if (ERROR_SUCCESS != lRes)

  00358	85 f6		 test	 esi, esi
  0035a	74 0b		 je	 SHORT $LN95@AddValue

; 983  : 	{
; 984  : 		nIDRes = E_ATL_VALUE_SET_FAILED;
; 985  : 		return AtlHresultFromWin32(lRes);

  0035c	56		 push	 esi
  0035d	e8 00 00 00 00	 call	 ?AtlHresultFromWin32@ATL@@YAJK@Z ; ATL::AtlHresultFromWin32
  00362	83 c4 04	 add	 esp, 4
  00365	eb 18		 jmp	 SHORT $LN1@AddValue
$LN95@AddValue:

; 979  : 		}
; 980  : 	}
; 981  : 
; 982  : 	if (ERROR_SUCCESS != lRes)

  00367	8b 75 d8	 mov	 esi, DWORD PTR _this$GSCopy$[ebp]
$LN2@AddValue:

; 986  : 	}
; 987  : 
; 988  : 	if (FAILED(hr = NextToken(szToken)))

  0036a	8b 45 dc	 mov	 eax, DWORD PTR _szToken$GSCopy$[ebp]
  0036d	50		 push	 eax
  0036e	8b ce		 mov	 ecx, esi
  00370	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  00375	33 c9		 xor	 ecx, ecx
  00377	85 c0		 test	 eax, eax
  00379	0f 9d c1	 setge	 cl
  0037c	49		 dec	 ecx
  0037d	23 c1		 and	 eax, ecx
$LN1@AddValue:

; 989  : 		return hr;
; 990  : 
; 991  : 	return S_OK;
; 992  : }

  0037f	8d 65 c8	 lea	 esp, DWORD PTR [ebp-56]
  00382	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00385	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0038c	59		 pop	 ecx
  0038d	5f		 pop	 edi
  0038e	5e		 pop	 esi
  0038f	5b		 pop	 ebx
  00390	8b 8d 04 11 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00396	33 cd		 xor	 ecx, ebp
  00398	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0039d	81 c5 08 11 00
	00		 add	 ebp, 4360		; 00001108H
  003a3	8b e5		 mov	 esp, ebp
  003a5	5d		 pop	 ebp
  003a6	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z$6:
  00000	8d 4d 00	 lea	 ecx, DWORD PTR _rgBinary$83213[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::~CTempBuffer<unsigned char,256,ATL::CCRTAllocator>
__unwindfunclet$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z$5:
  00008	8d 4d ec	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$83163[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__unwindfunclet$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z$4:
  00010	8d 4d 00	 lea	 ecx, DWORD PTR _pszDestValue$83142[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::~CTempBuffer<char,256,ATL::CCRTAllocator>
__ehhandler$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z:
  00018	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001f	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	8b 8a 10 11 00
	00		 mov	 ecx, DWORD PTR [edx+4368]
  0002f	33 c8		 xor	 ecx, eax
  00031	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00036	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z
  0003b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z ENDP ; ATL::CRegParser::AddValue
PUBLIC	_hkParent$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z ; ATL::CRegParser::RegisterSubkeys
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlbase.h
xdata$x	SEGMENT
__unwindtable$?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z$4
__ehfuncinfo$?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\statreg.h
xdata$x	ENDS
;	COMDAT ?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z
_TEXT	SEGMENT
_keyCur$ = -4436					; size = 8
_hKey$112183 = -4428					; size = 4
_hKey$112167 = -4428					; size = 4
_lRes$ = -4428						; size = 4
_hkParent$GSCopy$ = -4424				; size = 4
_rkForceRemove$83400 = -4420				; size = 8
_bDelete$ = -4412					; size = 4
_rkParent$83430 = -4408					; size = 8
_rk$83423 = -4400					; size = 8
_rkParent$83477 = -4392					; size = 8
_this$GSCopy$ = -4384					; size = 4
_bInRecovery$ = -4380					; size = 4
_dw$112182 = -4376					; size = 4
_szKey$ = -4372						; size = 260
_szValueName$83415 = -4112				; size = 4096
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_szToken$ = 8						; size = 4
_hkParent$ = 12						; size = 4
_bRegister$ = 16					; size = 4
_bRecover$ = 20						; size = 4
?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z PROC ; ATL::CRegParser::RegisterSubkeys, COMDAT
; _this$ = ecx

; 1296 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	b8 48 11 00 00	 mov	 eax, 4424		; 00001148H
  00013	e8 00 00 00 00	 call	 __chkstk
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c4		 xor	 eax, esp
  0001f	89 84 24 44 11
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+4436], eax
  00026	53		 push	 ebx
  00027	55		 push	 ebp
  00028	56		 push	 esi
  00029	57		 push	 edi
  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002f	33 c4		 xor	 eax, esp
  00031	50		 push	 eax
  00032	8d 84 24 5c 11
	00 00		 lea	 eax, DWORD PTR __$EHRec$[esp+4456]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1297 : 	CRegKey keyCur;

  0003f	8b 84 24 70 11
	00 00		 mov	 eax, DWORD PTR _hkParent$[esp+4452]
  00046	8b bc 24 6c 11
	00 00		 mov	 edi, DWORD PTR _szToken$[esp+4452]
  0004d	33 ed		 xor	 ebp, ebp
  0004f	8b d9		 mov	 ebx, ecx

; 1298 : 	LONG    lRes;
; 1299 : 	TCHAR  szKey[_MAX_PATH];
; 1300 : 	BOOL    bDelete = TRUE;
; 1301 : 	BOOL    bInRecovery = bRecover;

  00051	89 5c 24 48	 mov	 DWORD PTR _this$GSCopy$[esp+4456], ebx
  00055	89 44 24 20	 mov	 DWORD PTR _hkParent$GSCopy$[esp+4456], eax
  00059	89 6c 24 14	 mov	 DWORD PTR _keyCur$[esp+4456], ebp
  0005d	89 6c 24 18	 mov	 DWORD PTR _keyCur$[esp+4460], ebp
  00061	8b 8c 24 78 11
	00 00		 mov	 ecx, DWORD PTR _bRecover$[esp+4452]
  00068	89 4c 24 4c	 mov	 DWORD PTR _bInRecovery$[esp+4456], ecx

; 1302 : 	HRESULT hr = S_OK;
; 1303 : 
; 1304 : 	ATLTRACE(atlTraceRegistrar, 2, _T("Num Els = %d\n"), cbNeverDelete);
; 1305 : 	if (FAILED(hr = NextToken(szToken)))

  0006c	57		 push	 edi
  0006d	8b cb		 mov	 ecx, ebx
  0006f	89 ac 24 68 11
	00 00		 mov	 DWORD PTR __$EHRec$[esp+4468], ebp
  00076	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  0007b	8b f0		 mov	 esi, eax
  0007d	3b f5		 cmp	 esi, ebp

; 1306 : 		return hr;

  0007f	0f 8c f2 05 00
	00		 jl	 $LN59@RegisterSu

; 1307 : 
; 1308 : 
; 1309 : 	while (*szToken != chRightBracket) // Continue till we see a }

  00085	80 3f 7d	 cmp	 BYTE PTR [edi], 125	; 0000007dH
  00088	0f 84 e7 05 00
	00		 je	 $LN189@RegisterSu
  0008e	eb 04		 jmp	 SHORT $LN241@RegisterSu
$LL233@RegisterSu:
  00090	8b 5c 24 48	 mov	 ebx, DWORD PTR _this$GSCopy$[esp+4456]
$LN241@RegisterSu:
  00094	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__lstrcmpiA@8

; 1310 : 	{
; 1311 : 
; 1312 : 		
; 1313 : 		bDelete = TRUE;
; 1314 : 		BOOL bTokenDelete = !lstrcmpi(szToken, szDelete);

  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_06JBKGCNBB@Delete?$AA@
  0009f	57		 push	 edi
  000a0	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR _bDelete$[esp+4464], 1
  000a8	ff d6		 call	 esi
  000aa	8b e8		 mov	 ebp, eax
  000ac	f7 dd		 neg	 ebp

; 1315 : 
; 1316 : 		if (!lstrcmpi(szToken, szForceRemove) || bTokenDelete)

  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_0M@DBGDLGLL@ForceRemove?$AA@
  000b3	1b ed		 sbb	 ebp, ebp
  000b5	57		 push	 edi
  000b6	45		 inc	 ebp
  000b7	ff d6		 call	 esi
  000b9	85 c0		 test	 eax, eax
  000bb	74 08		 je	 SHORT $LN54@RegisterSu
  000bd	85 ed		 test	 ebp, ebp
  000bf	0f 84 ff 00 00
	00		 je	 $LN237@RegisterSu
$LN54@RegisterSu:

; 1317 : 		{
; 1318 : 			if (FAILED(hr = NextToken(szToken)))

  000c5	57		 push	 edi
  000c6	8b cb		 mov	 ecx, ebx
  000c8	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  000cd	8b f0		 mov	 esi, eax
  000cf	85 f6		 test	 esi, esi
  000d1	0f 8c 8f 05 00
	00		 jl	 $LN222@RegisterSu

; 1319 : 				break;
; 1320 : 
; 1321 : 			if (bRegister)

  000d7	33 f6		 xor	 esi, esi
  000d9	39 b4 24 74 11
	00 00		 cmp	 DWORD PTR _bRegister$[esp+4452], esi
  000e0	0f 84 e0 00 00
	00		 je	 $LN101@RegisterSu

; 1322 : 			{
; 1323 : 				CRegKey rkForceRemove;
; 1324 : 
; 1325 : 				if (StrChr(szToken, chDirSep) != NULL)

  000e6	8a 0f		 mov	 cl, BYTE PTR [edi]
  000e8	89 74 24 24	 mov	 DWORD PTR _rkForceRemove$83400[esp+4456], esi
  000ec	89 74 24 28	 mov	 DWORD PTR _rkForceRemove$83400[esp+4460], esi
  000f0	8b c7		 mov	 eax, edi
  000f2	84 c9		 test	 cl, cl
  000f4	74 1c		 je	 SHORT $LN228@RegisterSu
$LL77@RegisterSu:
  000f6	80 f9 5c	 cmp	 cl, 92			; 0000005cH
  000f9	74 0f		 je	 SHORT $LN199@RegisterSu
  000fb	50		 push	 eax
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextA@4
  00102	8a 08		 mov	 cl, BYTE PTR [eax]
  00104	84 c9		 test	 cl, cl
  00106	75 ee		 jne	 SHORT $LL77@RegisterSu

; 1550 : 					break;
; 1551 : 				if (FAILED(hr = NextToken(szToken)))

  00108	eb 08		 jmp	 SHORT $LN228@RegisterSu
$LN199@RegisterSu:

; 1322 : 			{
; 1323 : 				CRegKey rkForceRemove;
; 1324 : 
; 1325 : 				if (StrChr(szToken, chDirSep) != NULL)

  0010a	3b c6		 cmp	 eax, esi
  0010c	0f 85 d9 04 00
	00		 jne	 $LN202@RegisterSu
$LN228@RegisterSu:

; 1327 : 
; 1328 : 				if (CanForceRemoveKey(szToken))

  00112	57		 push	 edi
  00113	8b cb		 mov	 ecx, ebx
  00115	e8 00 00 00 00	 call	 ?CanForceRemoveKey@CRegParser@ATL@@IAEHPBD@Z ; ATL::CRegParser::CanForceRemoveKey
  0011a	85 c0		 test	 eax, eax
  0011c	74 1e		 je	 SHORT $LN91@RegisterSu

; 1329 : 				{
; 1330 : 					rkForceRemove.Attach(hkParent);

  0011e	8b 54 24 20	 mov	 edx, DWORD PTR _hkParent$GSCopy$[esp+4456]

; 1331 : 					// Error not returned. We will overwrite the values any way.
; 1332 : 					rkForceRemove.RecurseDeleteKey(szToken);

  00122	57		 push	 edi
  00123	8d 4c 24 28	 lea	 ecx, DWORD PTR _rkForceRemove$83400[esp+4460]
  00127	89 54 24 28	 mov	 DWORD PTR _rkForceRemove$83400[esp+4460], edx
  0012b	89 74 24 2c	 mov	 DWORD PTR _rkForceRemove$83400[esp+4464], esi
  0012f	e8 00 00 00 00	 call	 ?RecurseDeleteKey@CRegKey@ATL@@QAEJPBD@Z ; ATL::CRegKey::RecurseDeleteKey

; 1333 : 					rkForceRemove.Detach();

  00134	89 74 24 24	 mov	 DWORD PTR _rkForceRemove$83400[esp+4456], esi
  00138	89 74 24 28	 mov	 DWORD PTR _rkForceRemove$83400[esp+4460], esi
$LN91@RegisterSu:

; 1334 : 				}
; 1335 : 				if (bTokenDelete)

  0013c	3b ee		 cmp	 ebp, esi
  0013e	74 7e		 je	 SHORT $LN100@RegisterSu

; 1336 : 				{
; 1337 : 					if (FAILED(hr = NextToken(szToken)))

  00140	57		 push	 edi
  00141	8b cb		 mov	 ecx, ebx
  00143	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  00148	8b f0		 mov	 esi, eax
  0014a	85 f6		 test	 esi, esi
  0014c	0f 8c b2 04 00
	00		 jl	 $LN203@RegisterSu

; 1339 : 					if (FAILED(hr = SkipAssignment(szToken)))

  00152	57		 push	 edi
  00153	8b cb		 mov	 ecx, ebx
  00155	e8 00 00 00 00	 call	 ?SkipAssignment@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::SkipAssignment
  0015a	8b f0		 mov	 esi, eax
  0015c	85 f6		 test	 esi, esi
  0015e	0f 8c a0 04 00
	00		 jl	 $LN203@RegisterSu

; 1537 : 		
; 1538 : 		
; 1539 : 		
; 1540 : 		
; 1541 : 		}
; 1542 : 
; 1543 : EndCheck:

  00164	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR _rkForceRemove$83400[esp+4460], 0
$EndCheck$83409:

; 1546 : 		{
; 1547 : 			if (*szToken == chLeftBracket && lstrlen(szToken) == 1)

  0016c	80 3f 7b	 cmp	 BYTE PTR [edi], 123	; 0000007bH
  0016f	75 3f		 jne	 SHORT $LN1@RegisterSu
  00171	57		 push	 edi
  00172	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  00178	83 f8 01	 cmp	 eax, 1
  0017b	75 33		 jne	 SHORT $LN1@RegisterSu

; 1548 : 			{
; 1549 : 				if (FAILED(hr = RegisterSubkeys(szToken, keyCur.m_hKey, bRegister, FALSE)))

  0017d	8b 8c 24 74 11
	00 00		 mov	 ecx, DWORD PTR _bRegister$[esp+4452]
  00184	8b 54 24 14	 mov	 edx, DWORD PTR _keyCur$[esp+4456]
  00188	6a 00		 push	 0
  0018a	51		 push	 ecx
  0018b	52		 push	 edx
  0018c	57		 push	 edi
  0018d	8b cb		 mov	 ecx, ebx
  0018f	e8 00 00 00 00	 call	 ?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z ; ATL::CRegParser::RegisterSubkeys
  00194	8b f0		 mov	 esi, eax
  00196	85 f6		 test	 esi, esi
  00198	0f 8c c8 04 00
	00		 jl	 $LN222@RegisterSu

; 1550 : 					break;
; 1551 : 				if (FAILED(hr = NextToken(szToken)))

  0019e	57		 push	 edi
  0019f	8b cb		 mov	 ecx, ebx
  001a1	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  001a6	8b f0		 mov	 esi, eax
  001a8	85 f6		 test	 esi, esi
$LN242@RegisterSu:
  001aa	0f 8c b6 04 00
	00		 jl	 $LN222@RegisterSu
$LN1@RegisterSu:

; 1307 : 
; 1308 : 
; 1309 : 	while (*szToken != chRightBracket) // Continue till we see a }

  001b0	80 3f 7d	 cmp	 BYTE PTR [edi], 125	; 0000007dH
  001b3	0f 85 d7 fe ff
	ff		 jne	 $LL233@RegisterSu

; 1550 : 					break;
; 1551 : 				if (FAILED(hr = NextToken(szToken)))

  001b9	e9 a8 04 00 00	 jmp	 $LN222@RegisterSu

; 1340 : 						break;
; 1341 : 					goto EndCheck;
; 1342 : 				}
; 1343 : 			}

$LN100@RegisterSu:
  001be	89 74 24 28	 mov	 DWORD PTR _rkForceRemove$83400[esp+4460], esi
  001c2	eb 02		 jmp	 SHORT $LN101@RegisterSu
$LN237@RegisterSu:
  001c4	33 f6		 xor	 esi, esi
$LN101@RegisterSu:

; 1344 : 
; 1345 : 		}
; 1346 : 
; 1347 : 		if (!lstrcmpi(szToken, szNoRemove))

  001c6	68 00 00 00 00	 push	 OFFSET ??_C@_08KAAPDIAN@NoRemove?$AA@
  001cb	57		 push	 edi
  001cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpiA@8
  001d2	85 c0		 test	 eax, eax
  001d4	75 18		 jne	 SHORT $LN44@RegisterSu

; 1348 : 		{
; 1349 : 			bDelete = FALSE;    // set even for register
; 1350 : 			if (FAILED(hr = NextToken(szToken)))

  001d6	57		 push	 edi
  001d7	8b cb		 mov	 ecx, ebx
  001d9	89 44 24 30	 mov	 DWORD PTR _bDelete$[esp+4460], eax
  001dd	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  001e2	8b f0		 mov	 esi, eax
  001e4	85 f6		 test	 esi, esi
  001e6	0f 8c 7a 04 00
	00		 jl	 $LN222@RegisterSu
  001ec	33 f6		 xor	 esi, esi
$LN44@RegisterSu:

; 1351 : 				break;
; 1352 : 		}
; 1353 : 
; 1354 : 		if (!lstrcmpi(szToken, szValToken)) // need to add a value to hkParent

  001ee	68 00 00 00 00	 push	 OFFSET ??_C@_03LAIAPFCB@Val?$AA@
  001f3	57		 push	 edi
  001f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpiA@8
  001fa	85 c0		 test	 eax, eax
  001fc	0f 85 02 01 00
	00		 jne	 $LN36@RegisterSu

; 1355 : 		{
; 1356 : 			TCHAR  szValueName[MAX_VALUE];
; 1357 : 
; 1358 : 
; 1359 : 		 
; 1360 : 			if (FAILED(hr = NextToken(szValueName)))

  00202	8d 84 24 58 01
	00 00		 lea	 eax, DWORD PTR _szValueName$83415[esp+4456]
  00209	50		 push	 eax
  0020a	8b cb		 mov	 ecx, ebx
  0020c	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  00211	8b f0		 mov	 esi, eax
  00213	85 f6		 test	 esi, esi
  00215	0f 8c 4b 04 00
	00		 jl	 $LN222@RegisterSu

; 1361 : 				break;
; 1362 : 			if (FAILED(hr = NextToken(szToken)))

  0021b	57		 push	 edi
  0021c	8b cb		 mov	 ecx, ebx
  0021e	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  00223	8b f0		 mov	 esi, eax
  00225	85 f6		 test	 esi, esi
  00227	0f 8c 39 04 00
	00		 jl	 $LN222@RegisterSu

; 1363 : 				break;
; 1364 :  
; 1365 : 			if (*szToken != chEquals)

  0022d	80 3f 3d	 cmp	 BYTE PTR [edi], 61	; 0000003dH
  00230	0f 85 be 03 00
	00		 jne	 $LN208@RegisterSu

; 1366 : 				return GenerateError(E_ATL_EXPECTING_EQUAL);
; 1367 : 
; 1368 : 			if (bRegister)

  00236	33 ed		 xor	 ebp, ebp
  00238	39 ac 24 74 11
	00 00		 cmp	 DWORD PTR _bRegister$[esp+4452], ebp
  0023f	74 4c		 je	 SHORT $LN39@RegisterSu

; 1369 : 			{
; 1370 : 				CRegKey rk;
; 1371 : 
; 1372 : 				rk.Attach(hkParent);

  00241	8b 4c 24 20	 mov	 ecx, DWORD PTR _hkParent$GSCopy$[esp+4456]

; 1373 : 				hr = AddValue(rk, szValueName, szToken);

  00245	57		 push	 edi
  00246	8d 94 24 5c 01
	00 00		 lea	 edx, DWORD PTR _szValueName$83415[esp+4460]
  0024d	52		 push	 edx
  0024e	8d 44 24 40	 lea	 eax, DWORD PTR _rk$83423[esp+4464]
  00252	89 4c 24 40	 mov	 DWORD PTR _rk$83423[esp+4464], ecx
  00256	50		 push	 eax
  00257	8b cb		 mov	 ecx, ebx
  00259	c6 84 24 70 11
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+4476], 1
  00261	89 6c 24 48	 mov	 DWORD PTR _rk$83423[esp+4472], ebp
  00265	e8 00 00 00 00	 call	 ?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z ; ATL::CRegParser::AddValue
  0026a	8b f0		 mov	 esi, eax

; 1374 : 				rk.Detach();
; 1375 : 
; 1376 : 				if (FAILED(hr))

  0026c	3b f5		 cmp	 esi, ebp
  0026e	89 6c 24 38	 mov	 DWORD PTR _rk$83423[esp+4456], ebp
  00272	89 6c 24 3c	 mov	 DWORD PTR _rk$83423[esp+4460], ebp
  00276	0f 8c 8e 03 00
	00		 jl	 $LN209@RegisterSu

; 1537 : 		
; 1538 : 		
; 1539 : 		
; 1540 : 		
; 1541 : 		}
; 1542 : 
; 1543 : EndCheck:

  0027c	c6 84 24 64 11
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+4464], 0
  00284	89 6c 24 3c	 mov	 DWORD PTR _rk$83423[esp+4460], ebp
  00288	e9 df fe ff ff	 jmp	 $EndCheck$83409
$LN39@RegisterSu:

; 1378 : 
; 1379 : 				goto EndCheck;
; 1380 : 			}
; 1381 : 			else
; 1382 : 			{
; 1383 : 				if (!bRecover && bDelete)

  0028d	39 ac 24 78 11
	00 00		 cmp	 DWORD PTR _bRecover$[esp+4452], ebp
  00294	75 5d		 jne	 SHORT $LN135@RegisterSu
  00296	39 6c 24 2c	 cmp	 DWORD PTR _bDelete$[esp+4456], ebp
  0029a	74 57		 je	 SHORT $LN135@RegisterSu

; 1384 : 				{
; 1385 : 					ATLTRACE(atlTraceRegistrar, 1, _T("Deleting %s\n"), szValueName);
; 1386 : 					// We have to open the key for write to be able to delete.
; 1387 : 					CRegKey rkParent;
; 1388 : 					lRes = rkParent.Open(hkParent, NULL, KEY_WRITE);

  0029c	8b 4c 24 20	 mov	 ecx, DWORD PTR _hkParent$GSCopy$[esp+4456]
  002a0	68 06 00 02 00	 push	 131078			; 00020006H
  002a5	55		 push	 ebp
  002a6	51		 push	 ecx
  002a7	8d 4c 24 3c	 lea	 ecx, DWORD PTR _rkParent$83430[esp+4468]
  002ab	89 6c 24 3c	 mov	 DWORD PTR _rkParent$83430[esp+4468], ebp
  002af	89 6c 24 40	 mov	 DWORD PTR _rkParent$83430[esp+4472], ebp
  002b3	e8 00 00 00 00	 call	 ?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PBDK@Z ; ATL::CRegKey::Open

; 1389 : 					if (lRes == ERROR_SUCCESS)

  002b8	3b c5		 cmp	 eax, ebp
  002ba	0f 85 5e 03 00
	00		 jne	 $LN210@RegisterSu

; 1390 : 					{
; 1391 : 						lRes = rkParent.DeleteValue(szValueName);

  002c0	8b 74 24 30	 mov	 esi, DWORD PTR _rkParent$83430[esp+4456]
  002c4	8d 94 24 58 01
	00 00		 lea	 edx, DWORD PTR _szValueName$83415[esp+4456]
  002cb	52		 push	 edx
  002cc	56		 push	 esi
  002cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegDeleteValueA@8

; 1392 : 						if (lRes != ERROR_SUCCESS && lRes != ERROR_FILE_NOT_FOUND)

  002d3	3b c5		 cmp	 eax, ebp
  002d5	74 09		 je	 SHORT $LN33@RegisterSu
  002d7	83 f8 02	 cmp	 eax, 2
  002da	0f 85 3e 03 00
	00		 jne	 $LN210@RegisterSu
$LN33@RegisterSu:

; 1397 : 						}
; 1398 : 					}
; 1399 : 					else
; 1400 : 					{
; 1401 : 						hr = AtlHresultFromWin32(lRes);
; 1402 : 						break;
; 1403 : 					}
; 1404 : 				}

  002e0	3b f5		 cmp	 esi, ebp
  002e2	74 0b		 je	 SHORT $LN134@RegisterSu
  002e4	56		 push	 esi
  002e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  002eb	89 6c 24 30	 mov	 DWORD PTR _rkParent$83430[esp+4456], ebp
$LN134@RegisterSu:
  002ef	89 6c 24 34	 mov	 DWORD PTR _rkParent$83430[esp+4460], ebp
$LN135@RegisterSu:

; 1405 : 				if (FAILED(hr = SkipAssignment(szToken)))

  002f3	57		 push	 edi
  002f4	8b cb		 mov	 ecx, ebx
  002f6	e8 00 00 00 00	 call	 ?SkipAssignment@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::SkipAssignment
  002fb	8b f0		 mov	 esi, eax
  002fd	3b f5		 cmp	 esi, ebp

; 1406 : 					break;
; 1407 : 				continue;  // can never have a subkey

  002ff	e9 a6 fe ff ff	 jmp	 $LN242@RegisterSu
$LN36@RegisterSu:

; 1408 : 			}
; 1409 : 		}
; 1410 : 
; 1411 : 		if (StrChr(szToken, chDirSep) != NULL)

  00304	8a 0f		 mov	 cl, BYTE PTR [edi]
  00306	8b c7		 mov	 eax, edi
  00308	84 c9		 test	 cl, cl
  0030a	74 20		 je	 SHORT $LN229@RegisterSu
  0030c	8d 64 24 00	 npad	 4
$LL139@RegisterSu:
  00310	80 f9 5c	 cmp	 cl, 92			; 0000005cH
  00313	74 0f		 je	 SHORT $LN200@RegisterSu
  00315	50		 push	 eax
  00316	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextA@4
  0031c	8a 08		 mov	 cl, BYTE PTR [eax]
  0031e	84 c9		 test	 cl, cl
  00320	75 ee		 jne	 SHORT $LL139@RegisterSu

; 1550 : 					break;
; 1551 : 				if (FAILED(hr = NextToken(szToken)))

  00322	eb 08		 jmp	 SHORT $LN229@RegisterSu
$LN200@RegisterSu:

; 1408 : 			}
; 1409 : 		}
; 1410 : 
; 1411 : 		if (StrChr(szToken, chDirSep) != NULL)

  00324	3b c6		 cmp	 eax, esi
  00326	0f 85 c8 02 00
	00		 jne	 $LN208@RegisterSu
$LN229@RegisterSu:

; 1412 : 			return GenerateError(E_ATL_COMPOUND_KEY);
; 1413 : 
; 1414 : 		if (bRegister)

  0032c	39 b4 24 74 11
	00 00		 cmp	 DWORD PTR _bRegister$[esp+4452], esi
  00333	0f 84 e7 00 00
	00		 je	 $LN29@RegisterSu

; 1415 : 		{
; 1416 : 			lRes = keyCur.Open(hkParent, szToken, KEY_READ | KEY_WRITE);

  00339	8b 4c 24 20	 mov	 ecx, DWORD PTR _hkParent$GSCopy$[esp+4456]
  0033d	8d 44 24 1c	 lea	 eax, DWORD PTR _hKey$112167[esp+4456]
  00341	50		 push	 eax
  00342	68 1f 00 02 00	 push	 131103			; 0002001fH
  00347	56		 push	 esi
  00348	57		 push	 edi
  00349	51		 push	 ecx
  0034a	89 74 24 30	 mov	 DWORD PTR _hKey$112167[esp+4476], esi
  0034e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  00354	3b c6		 cmp	 eax, esi
  00356	75 21		 jne	 SHORT $LN226@RegisterSu
  00358	8b 4c 24 14	 mov	 ecx, DWORD PTR _keyCur$[esp+4456]
  0035c	33 c0		 xor	 eax, eax
  0035e	3b ce		 cmp	 ecx, esi
  00360	74 07		 je	 SHORT $LN154@RegisterSu
  00362	51		 push	 ecx
  00363	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$LN154@RegisterSu:
  00369	8b 54 24 1c	 mov	 edx, DWORD PTR _hKey$112167[esp+4456]
  0036d	89 54 24 14	 mov	 DWORD PTR _keyCur$[esp+4456], edx
  00371	89 74 24 18	 mov	 DWORD PTR _keyCur$[esp+4460], esi

; 1417 : 			if (ERROR_SUCCESS != lRes)

  00375	3b c6		 cmp	 eax, esi
  00377	74 6e		 je	 SHORT $LN26@RegisterSu
$LN226@RegisterSu:

; 1418 : 			{
; 1419 : 				// Failed all access try read only
; 1420 : 				lRes = keyCur.Open(hkParent, szToken, KEY_READ);

  00379	8b 44 24 20	 mov	 eax, DWORD PTR _hkParent$GSCopy$[esp+4456]
  0037d	68 19 00 02 00	 push	 131097			; 00020019H
  00382	57		 push	 edi
  00383	50		 push	 eax
  00384	8d 4c 24 20	 lea	 ecx, DWORD PTR _keyCur$[esp+4468]
  00388	e8 00 00 00 00	 call	 ?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PBDK@Z ; ATL::CRegKey::Open

; 1421 : 				if (ERROR_SUCCESS != lRes)

  0038d	85 c0		 test	 eax, eax
  0038f	74 56		 je	 SHORT $LN26@RegisterSu

; 1422 : 				{
; 1423 : 					// Finally try creating it
; 1424 : 					ATLTRACE(atlTraceRegistrar, 2, _T("Creating key %s\n"), szToken);
; 1425 : 					lRes = keyCur.Create(hkParent, szToken, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE);

  00391	8b 44 24 20	 mov	 eax, DWORD PTR _hkParent$GSCopy$[esp+4456]
  00395	8d 4c 24 50	 lea	 ecx, DWORD PTR _dw$112182[esp+4456]
  00399	51		 push	 ecx
  0039a	33 ed		 xor	 ebp, ebp
  0039c	8d 54 24 20	 lea	 edx, DWORD PTR _hKey$112183[esp+4460]
  003a0	52		 push	 edx
  003a1	55		 push	 ebp
  003a2	68 1f 00 02 00	 push	 131103			; 0002001fH
  003a7	55		 push	 ebp
  003a8	55		 push	 ebp
  003a9	55		 push	 ebp
  003aa	57		 push	 edi
  003ab	50		 push	 eax
  003ac	89 6c 24 40	 mov	 DWORD PTR _hKey$112183[esp+4492], ebp
  003b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCreateKeyExA@36
  003b6	8b f0		 mov	 esi, eax
  003b8	3b f5		 cmp	 esi, ebp
  003ba	0f 85 6a 02 00
	00		 jne	 $LN213@RegisterSu
  003c0	8b 4c 24 14	 mov	 ecx, DWORD PTR _keyCur$[esp+4456]
  003c4	33 c0		 xor	 eax, eax
  003c6	3b cd		 cmp	 ecx, ebp
  003c8	74 07		 je	 SHORT $LN161@RegisterSu
  003ca	51		 push	 ecx
  003cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$LN161@RegisterSu:
  003d1	8b 4c 24 1c	 mov	 ecx, DWORD PTR _hKey$112183[esp+4456]
  003d5	8b f0		 mov	 esi, eax
  003d7	89 4c 24 14	 mov	 DWORD PTR _keyCur$[esp+4456], ecx
  003db	89 6c 24 18	 mov	 DWORD PTR _keyCur$[esp+4460], ebp

; 1426 : 					if (lRes != ERROR_SUCCESS)

  003df	3b c5		 cmp	 eax, ebp
  003e1	0f 85 43 02 00
	00		 jne	 $LN213@RegisterSu
$LN26@RegisterSu:

; 1428 : 				}
; 1429 : 			}
; 1430 : 
; 1431 : 			if (FAILED(hr = NextToken(szToken)))

  003e7	57		 push	 edi
  003e8	8b cb		 mov	 ecx, ebx
  003ea	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  003ef	8b f0		 mov	 esi, eax
  003f1	85 f6		 test	 esi, esi
  003f3	0f 8c 6d 02 00
	00		 jl	 $LN222@RegisterSu

; 1432 : 				break;
; 1433 : 
; 1434 : 
; 1435 : 			if (*szToken == chEquals)

  003f9	80 3f 3d	 cmp	 BYTE PTR [edi], 61	; 0000003dH
  003fc	0f 85 6a fd ff
	ff		 jne	 $EndCheck$83409

; 1436 : 			{
; 1437 : 				if (FAILED(hr = AddValue(keyCur, NULL, szToken))) // NULL == default

  00402	57		 push	 edi
  00403	6a 00		 push	 0
  00405	8d 54 24 1c	 lea	 edx, DWORD PTR _keyCur$[esp+4464]
  00409	52		 push	 edx
  0040a	8b cb		 mov	 ecx, ebx
  0040c	e8 00 00 00 00	 call	 ?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z ; ATL::CRegParser::AddValue
  00411	8b f0		 mov	 esi, eax
  00413	85 f6		 test	 esi, esi
  00415	0f 8c 4b 02 00
	00		 jl	 $LN222@RegisterSu

; 1438 : 					break;
; 1439 : 			}
; 1440 : 		}
; 1441 : 		else //Unregister

  0041b	e9 4c fd ff ff	 jmp	 $EndCheck$83409
$LN29@RegisterSu:

; 1442 : 		{
; 1443 : 			if (!bRecover)

  00420	39 b4 24 78 11
	00 00		 cmp	 DWORD PTR _bRecover$[esp+4452], esi
  00427	0f 85 e4 00 00
	00		 jne	 $LN21@RegisterSu

; 1444 : 			{
; 1445 :  				lRes = keyCur.Open(hkParent, szToken, KEY_READ);

  0042d	8b 44 24 20	 mov	 eax, DWORD PTR _hkParent$GSCopy$[esp+4456]
  00431	68 19 00 02 00	 push	 131097			; 00020019H
  00436	57		 push	 edi
  00437	50		 push	 eax
  00438	8d 4c 24 20	 lea	 ecx, DWORD PTR _keyCur$[esp+4468]
  0043c	e8 00 00 00 00	 call	 ?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PBDK@Z ; ATL::CRegKey::Open
  00441	8b e8		 mov	 ebp, eax
  00443	89 6c 24 1c	 mov	 DWORD PTR _lRes$[esp+4456], ebp

; 1450 : 
; 1451 : 
; 1452 : 			// Open failed set recovery mode
; 1453 : 			if (lRes != ERROR_SUCCESS)

  00447	3b ee		 cmp	 ebp, esi
  00449	74 0b		 je	 SHORT $LN19@RegisterSu
$LN227@RegisterSu:

; 1454 : 				bRecover = true;

  0044b	c7 84 24 78 11
	00 00 01 00 00
	00		 mov	 DWORD PTR _bRecover$[esp+4452], 1
$LN19@RegisterSu:

; 1455 : 
; 1456 : 			// TRACE out Key open status and if in recovery mode
; 1457 : #ifdef _DEBUG
; 1458 : 			if (!bRecover)
; 1459 : 				ATLTRACE(atlTraceRegistrar, 1, _T("Opened Key %s\n"), szToken);
; 1460 : 			else
; 1461 : 				ATLTRACE(atlTraceRegistrar, 0, _T("Ignoring Open key on %s : In Recovery mode\n"), szToken);
; 1462 : #endif //_DEBUG
; 1463 : 
; 1464 : 			// Remember Subkey
; 1465 : 			Checked::tcsncpy_s(szKey, _countof(szKey), szToken, _TRUNCATE);

  00456	6a ff		 push	 -1
  00458	57		 push	 edi
  00459	8d 4c 24 5c	 lea	 ecx, DWORD PTR _szKey$[esp+4464]
  0045d	68 04 01 00 00	 push	 260			; 00000104H
  00462	51		 push	 ecx
  00463	e8 00 00 00 00	 call	 __mbsnbcpy_s
  00468	50		 push	 eax
  00469	e8 00 00 00 00	 call	 ?AtlCrtErrorCheck@ATL@@YAHH@Z ; ATL::AtlCrtErrorCheck
  0046e	83 c4 14	 add	 esp, 20			; 00000014H

; 1466 : 
; 1467 : 			if (FAILED(hr = NextToken(szToken)))

  00471	57		 push	 edi
  00472	8b cb		 mov	 ecx, ebx
  00474	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  00479	8b f0		 mov	 esi, eax
  0047b	85 f6		 test	 esi, esi
  0047d	0f 8c e3 01 00
	00		 jl	 $LN222@RegisterSu

; 1468 : 				break;
; 1469 : 			if (FAILED(hr = SkipAssignment(szToken)))

  00483	57		 push	 edi
  00484	8b cb		 mov	 ecx, ebx
  00486	e8 00 00 00 00	 call	 ?SkipAssignment@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::SkipAssignment
  0048b	8b f0		 mov	 esi, eax
  0048d	85 f6		 test	 esi, esi
  0048f	0f 8c d1 01 00
	00		 jl	 $LN222@RegisterSu

; 1470 : 				break;
; 1471 : 
; 1472 : 			if (*szToken == chLeftBracket && lstrlen(szToken) == 1)

  00495	80 3f 7b	 cmp	 BYTE PTR [edi], 123	; 0000007bH
  00498	75 47		 jne	 SHORT $LN14@RegisterSu
  0049a	57		 push	 edi
  0049b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  004a1	83 f8 01	 cmp	 eax, 1
  004a4	75 3b		 jne	 SHORT $LN14@RegisterSu

; 1473 : 			{
; 1474 : 				hr = RegisterSubkeys(szToken, keyCur.m_hKey, bRegister, bRecover);

  004a6	8b ac 24 78 11
	00 00		 mov	 ebp, DWORD PTR _bRecover$[esp+4452]
  004ad	8b 54 24 14	 mov	 edx, DWORD PTR _keyCur$[esp+4456]
  004b1	55		 push	 ebp
  004b2	6a 00		 push	 0
  004b4	52		 push	 edx
  004b5	57		 push	 edi
  004b6	8b cb		 mov	 ecx, ebx
  004b8	e8 00 00 00 00	 call	 ?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z ; ATL::CRegParser::RegisterSubkeys
  004bd	8b f0		 mov	 esi, eax

; 1475 : 				// In recover mode ignore error
; 1476 : 				if (FAILED(hr) && !bRecover)

  004bf	85 f6		 test	 esi, esi
  004c1	7d 08		 jge	 SHORT $LN15@RegisterSu
  004c3	85 ed		 test	 ebp, ebp
  004c5	0f 84 9b 01 00
	00		 je	 $LN222@RegisterSu
$LN15@RegisterSu:

; 1477 : 					break;
; 1478 : 				// Skip the }
; 1479 : 				if (FAILED(hr = NextToken(szToken)))

  004cb	57		 push	 edi
  004cc	8b cb		 mov	 ecx, ebx
  004ce	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  004d3	8b f0		 mov	 esi, eax
  004d5	85 f6		 test	 esi, esi
  004d7	0f 8c 89 01 00
	00		 jl	 $LN222@RegisterSu
  004dd	8b 6c 24 1c	 mov	 ebp, DWORD PTR _lRes$[esp+4456]
$LN14@RegisterSu:

; 1480 : 					break;
; 1481 : 			}
; 1482 : 
; 1483 : #ifdef _DEBUG
; 1484 : 			if (bRecover != bInRecovery)
; 1485 : 				ATLTRACE(atlTraceRegistrar, 0, _T("Ending Recovery Mode\n"));
; 1486 : #endif
; 1487 : 			bRecover = bInRecovery;

  004e1	8b 44 24 4c	 mov	 eax, DWORD PTR _bInRecovery$[esp+4456]
  004e5	89 84 24 78 11
	00 00		 mov	 DWORD PTR _bRecover$[esp+4452], eax

; 1488 : 
; 1489 : 			if (lRes == ERROR_FILE_NOT_FOUND)

  004ec	83 fd 02	 cmp	 ebp, 2
  004ef	0f 84 bb fc ff
	ff		 je	 $LN1@RegisterSu

; 1490 : 				// Key already not present so not an error.
; 1491 : 				continue;
; 1492 : 
; 1493 : 			if (lRes != ERROR_SUCCESS)

  004f5	85 ed		 test	 ebp, ebp
  004f7	74 29		 je	 SHORT $LN10@RegisterSu

; 1494 : 			{
; 1495 : 				// We are recovery mode continue on errors else break
; 1496 : 				if (bRecover)

  004f9	85 c0		 test	 eax, eax
  004fb	0f 85 af fc ff
	ff		 jne	 $LN1@RegisterSu

; 1497 : 					continue;
; 1498 : 				else
; 1499 : 				{
; 1500 : 					hr = AtlHresultFromWin32(lRes);

  00501	55		 push	 ebp
  00502	e8 00 00 00 00	 call	 ?AtlHresultFromWin32@ATL@@YAJK@Z ; ATL::AtlHresultFromWin32
  00507	83 c4 04	 add	 esp, 4
  0050a	8b f0		 mov	 esi, eax

; 1501 : 					break;

  0050c	e9 55 01 00 00	 jmp	 $LN222@RegisterSu
$LN21@RegisterSu:

; 1446 : 
; 1447 : 			}
; 1448 : 			else
; 1449 : 				lRes = ERROR_FILE_NOT_FOUND;

  00511	c7 44 24 1c 02
	00 00 00	 mov	 DWORD PTR _lRes$[esp+4456], 2

; 1450 : 
; 1451 : 
; 1452 : 			// Open failed set recovery mode
; 1453 : 			if (lRes != ERROR_SUCCESS)

  00519	8b 6c 24 1c	 mov	 ebp, DWORD PTR _lRes$[esp+4456]
  0051d	e9 29 ff ff ff	 jmp	 $LN227@RegisterSu
$LN10@RegisterSu:

; 1502 : 				}
; 1503 : 			}
; 1504 : 
; 1505 : 			// If in recovery mode
; 1506 : 			if (bRecover && HasSubKeys(keyCur))

  00522	85 c0		 test	 eax, eax
  00524	74 42		 je	 SHORT $LN9@RegisterSu
  00526	8b 44 24 14	 mov	 eax, DWORD PTR _keyCur$[esp+4456]
  0052a	50		 push	 eax
  0052b	8b cb		 mov	 ecx, ebx
  0052d	e8 00 00 00 00	 call	 ?HasSubKeys@CRegParser@ATL@@IAEHPAUHKEY__@@@Z ; ATL::CRegParser::HasSubKeys
  00532	85 c0		 test	 eax, eax
  00534	74 32		 je	 SHORT $LN9@RegisterSu

; 1507 : 			{
; 1508 : 				// See if the KEY is in the NeverDelete list and if so, don't
; 1509 : 				if (CanForceRemoveKey(szKey) && bDelete)

  00536	8d 4c 24 54	 lea	 ecx, DWORD PTR _szKey$[esp+4456]
  0053a	51		 push	 ecx
  0053b	8b cb		 mov	 ecx, ebx
  0053d	e8 00 00 00 00	 call	 ?CanForceRemoveKey@CRegParser@ATL@@IAEHPBD@Z ; ATL::CRegParser::CanForceRemoveKey
  00542	85 c0		 test	 eax, eax
  00544	0f 84 66 fc ff
	ff		 je	 $LN1@RegisterSu
  0054a	83 7c 24 2c 00	 cmp	 DWORD PTR _bDelete$[esp+4456], 0
  0054f	0f 84 5b fc ff
	ff		 je	 $LN1@RegisterSu

; 1510 : 				{
; 1511 : 					ATLTRACE(atlTraceRegistrar, 0, _T("Deleting non-empty subkey %s by force\n"), szKey);
; 1512 : 					// Error not returned since we are in recovery mode. The error that caused recovery mode is returned
; 1513 : 					keyCur.RecurseDeleteKey(szKey);

  00555	8d 54 24 54	 lea	 edx, DWORD PTR _szKey$[esp+4456]
  00559	52		 push	 edx
  0055a	8d 4c 24 18	 lea	 ecx, DWORD PTR _keyCur$[esp+4460]
  0055e	e8 00 00 00 00	 call	 ?RecurseDeleteKey@CRegKey@ATL@@QAEJPBD@Z ; ATL::CRegKey::RecurseDeleteKey

; 1514 : 				}
; 1515 : 				continue;

  00563	e9 48 fc ff ff	 jmp	 $LN1@RegisterSu
$LN9@RegisterSu:

; 1516 : 			}
; 1517 :  			
; 1518 : 			BOOL bHasSubKeys=HasSubKeys(keyCur);

  00568	8b 44 24 14	 mov	 eax, DWORD PTR _keyCur$[esp+4456]
  0056c	8b 4c 24 48	 mov	 ecx, DWORD PTR _this$GSCopy$[esp+4456]
  00570	50		 push	 eax
  00571	e8 00 00 00 00	 call	 ?HasSubKeys@CRegParser@ATL@@IAEHPAUHKEY__@@@Z ; ATL::CRegParser::HasSubKeys

; 1519 : 			lRes = keyCur.Close();

  00576	33 ed		 xor	 ebp, ebp
  00578	8b d8		 mov	 ebx, eax
  0057a	39 6c 24 14	 cmp	 DWORD PTR _keyCur$[esp+4456], ebp
  0057e	74 15		 je	 SHORT $LN172@RegisterSu
  00580	8b 4c 24 14	 mov	 ecx, DWORD PTR _keyCur$[esp+4456]
  00584	51		 push	 ecx
  00585	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  0058b	8b e8		 mov	 ebp, eax
  0058d	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _keyCur$[esp+4456], 0
$LN172@RegisterSu:
  00595	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _keyCur$[esp+4460], 0

; 1520 : 			if (lRes != ERROR_SUCCESS)

  0059d	85 ed		 test	 ebp, ebp
  0059f	0f 85 99 00 00
	00		 jne	 $LN220@RegisterSu

; 1522 : 
; 1523 : 			if (bDelete&& !bHasSubKeys)

  005a5	39 6c 24 2c	 cmp	 DWORD PTR _bDelete$[esp+4456], ebp
  005a9	0f 84 01 fc ff
	ff		 je	 $LN1@RegisterSu
  005af	85 db		 test	 ebx, ebx
  005b1	0f 85 f9 fb ff
	ff		 jne	 $LN1@RegisterSu

; 1524 : 			{
; 1525 : 				ATLTRACE(atlTraceRegistrar, 0, _T("Deleting Key %s\n"), szKey);
; 1526 : 				CRegKey rkParent;
; 1527 : 				rkParent.Attach(hkParent);

  005b7	8b 54 24 20	 mov	 edx, DWORD PTR _hkParent$GSCopy$[esp+4456]

; 1528 : 				lRes = rkParent.DeleteSubKey(szKey);

  005bb	8d 44 24 54	 lea	 eax, DWORD PTR _szKey$[esp+4456]
  005bf	50		 push	 eax
  005c0	8d 4c 24 44	 lea	 ecx, DWORD PTR _rkParent$83477[esp+4460]
  005c4	89 54 24 44	 mov	 DWORD PTR _rkParent$83477[esp+4460], edx
  005c8	89 5c 24 48	 mov	 DWORD PTR _rkParent$83477[esp+4464], ebx
  005cc	e8 00 00 00 00	 call	 ?DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z ; ATL::CRegKey::DeleteSubKey

; 1529 : 				rkParent.Detach();

  005d1	89 5c 24 40	 mov	 DWORD PTR _rkParent$83477[esp+4456], ebx
  005d5	89 5c 24 44	 mov	 DWORD PTR _rkParent$83477[esp+4460], ebx

; 1530 : 				if (lRes != ERROR_SUCCESS)

  005d9	3b c3		 cmp	 eax, ebx
  005db	75 75		 jne	 SHORT $LN221@RegisterSu

; 1535 : 				}
; 1536 : 			}

  005dd	8d 4c 24 40	 lea	 ecx, DWORD PTR _rkParent$83477[esp+4456]
  005e1	e8 00 00 00 00	 call	 ??1CRegKey@ATL@@QAE@XZ	; ATL::CRegKey::~CRegKey

; 1544 : 
; 1545 : 		if (bRegister)

  005e6	e9 c5 fb ff ff	 jmp	 $LN1@RegisterSu
$LN202@RegisterSu:

; 1326 : 					return GenerateError(E_ATL_COMPOUND_KEY);

  005eb	8d 4c 24 24	 lea	 ecx, DWORD PTR _rkForceRemove$83400[esp+4456]
  005ef	e8 00 00 00 00	 call	 ??1CRegKey@ATL@@QAE@XZ	; ATL::CRegKey::~CRegKey
$LN208@RegisterSu:
  005f4	8d 4c 24 14	 lea	 ecx, DWORD PTR _keyCur$[esp+4456]
  005f8	e8 00 00 00 00	 call	 ??1CRegKey@ATL@@QAE@XZ	; ATL::CRegKey::~CRegKey
  005fd	b8 09 00 02 80	 mov	 eax, -2147352567	; 80020009H
  00602	eb 73		 jmp	 SHORT $LN59@RegisterSu
$LN203@RegisterSu:

; 1338 : 						break;

  00604	8d 4c 24 24	 lea	 ecx, DWORD PTR _rkForceRemove$83400[esp+4456]
  00608	eb 57		 jmp	 SHORT $LN243@RegisterSu
$LN209@RegisterSu:

; 1377 : 					return hr;

  0060a	8d 4c 24 38	 lea	 ecx, DWORD PTR _rk$83423[esp+4456]
  0060e	e8 00 00 00 00	 call	 ??1CRegKey@ATL@@QAE@XZ	; ATL::CRegKey::~CRegKey
  00613	8d 4c 24 14	 lea	 ecx, DWORD PTR _keyCur$[esp+4456]
  00617	e8 00 00 00 00	 call	 ??1CRegKey@ATL@@QAE@XZ	; ATL::CRegKey::~CRegKey
  0061c	eb 57		 jmp	 SHORT $LN189@RegisterSu
$LN210@RegisterSu:

; 1393 : 						{
; 1394 : 							// Key not present is not an error
; 1395 : 							hr = AtlHresultFromWin32(lRes);

  0061e	50		 push	 eax
  0061f	e8 00 00 00 00	 call	 ?AtlHresultFromWin32@ATL@@YAJK@Z ; ATL::AtlHresultFromWin32

; 1396 : 							break;

  00624	8d 4c 24 34	 lea	 ecx, DWORD PTR _rkParent$83430[esp+4460]
  00628	eb 32		 jmp	 SHORT $LN244@RegisterSu
$LN213@RegisterSu:

; 1427 : 						return AtlHresultFromWin32(lRes);

  0062a	8d 4c 24 14	 lea	 ecx, DWORD PTR _keyCur$[esp+4456]
  0062e	e8 00 00 00 00	 call	 ??1CRegKey@ATL@@QAE@XZ	; ATL::CRegKey::~CRegKey
  00633	56		 push	 esi
  00634	e8 00 00 00 00	 call	 ?AtlHresultFromWin32@ATL@@YAJK@Z ; ATL::AtlHresultFromWin32
  00639	83 c4 04	 add	 esp, 4
  0063c	eb 39		 jmp	 SHORT $LN59@RegisterSu
$LN220@RegisterSu:

; 1521 : 			return AtlHresultFromWin32(lRes);

  0063e	8d 4c 24 14	 lea	 ecx, DWORD PTR _keyCur$[esp+4456]
  00642	e8 00 00 00 00	 call	 ??1CRegKey@ATL@@QAE@XZ	; ATL::CRegKey::~CRegKey
  00647	55		 push	 ebp
  00648	e8 00 00 00 00	 call	 ?AtlHresultFromWin32@ATL@@YAJK@Z ; ATL::AtlHresultFromWin32
  0064d	83 c4 04	 add	 esp, 4
  00650	eb 25		 jmp	 SHORT $LN59@RegisterSu
$LN221@RegisterSu:

; 1531 : 				{
; 1532 : 					 
; 1533 : 					hr = AtlHresultFromWin32(lRes);

  00652	50		 push	 eax
  00653	e8 00 00 00 00	 call	 ?AtlHresultFromWin32@ATL@@YAJK@Z ; ATL::AtlHresultFromWin32

; 1534 : 					break;

  00658	8d 4c 24 44	 lea	 ecx, DWORD PTR _rkParent$83477[esp+4460]
$LN244@RegisterSu:
  0065c	83 c4 04	 add	 esp, 4
  0065f	8b f0		 mov	 esi, eax
$LN243@RegisterSu:
  00661	e8 00 00 00 00	 call	 ??1CRegKey@ATL@@QAE@XZ	; ATL::CRegKey::~CRegKey
$LN222@RegisterSu:

; 1552 : 					break;
; 1553 : 			}
; 1554 : 		}
; 1555 : 	}
; 1556 : 
; 1557 : 	return hr;

  00666	8b 44 24 14	 mov	 eax, DWORD PTR _keyCur$[esp+4456]
  0066a	85 c0		 test	 eax, eax
  0066c	74 07		 je	 SHORT $LN189@RegisterSu
  0066e	50		 push	 eax
  0066f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$LN189@RegisterSu:
  00675	8b c6		 mov	 eax, esi
$LN59@RegisterSu:

; 1558 : }

  00677	8b 8c 24 5c 11
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+4456]
  0067e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00685	59		 pop	 ecx
  00686	5f		 pop	 edi
  00687	5e		 pop	 esi
  00688	5d		 pop	 ebp
  00689	5b		 pop	 ebx
  0068a	8b 8c 24 44 11
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+4436]
  00691	33 cc		 xor	 ecx, esp
  00693	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00698	81 c4 54 11 00
	00		 add	 esp, 4436		; 00001154H
  0069e	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z$2:
  00000	8d 8d ac ee ff
	ff		 lea	 ecx, DWORD PTR _keyCur$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CRegKey@ATL@@QAE@XZ	; ATL::CRegKey::~CRegKey
__unwindfunclet$?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z$4:
  0000b	8d 8d d0 ee ff
	ff		 lea	 ecx, DWORD PTR _rk$83423[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1CRegKey@ATL@@QAE@XZ	; ATL::CRegKey::~CRegKey
__ehhandler$?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 82 a8 ee ff
	ff		 lea	 eax, DWORD PTR [edx-4440]
  00020	8b 8a a4 ee ff
	ff		 mov	 ecx, DWORD PTR [edx-4444]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	83 c0 10	 add	 eax, 16			; 00000010H
  00030	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00033	33 c8		 xor	 ecx, eax
  00035	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z
  0003f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z ENDP ; ATL::CRegParser::RegisterSubkeys
PUBLIC	??0CRegObject@ATL@@QAE@XZ			; ATL::CRegObject::CRegObject
; Function compile flags: /Ogtpy
;	COMDAT ??0CRegObject@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CRegObject@ATL@@QAE@XZ PROC				; ATL::CRegObject::CRegObject, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CRegObject@ATL@@6B@
  0000a	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0000d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00010	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00013	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00016	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00019	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  0001c	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
  0001f	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  00022	89 48 24	 mov	 DWORD PTR [eax+36], ecx
  00025	88 48 28	 mov	 BYTE PTR [eax+40], cl
  00028	c3		 ret	 0
??0CRegObject@ATL@@QAE@XZ ENDP				; ATL::CRegObject::CRegObject
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?RegisterBuffer@CRegParser@ATL@@QAEJPADH@Z	; ATL::CRegParser::RegisterBuffer
; Function compile flags: /Ogtpy
;	COMDAT ?RegisterBuffer@CRegParser@ATL@@QAEJPADH@Z
_TEXT	SEGMENT
_szReg$ = -4104						; size = 4
_szToken$ = -4100					; size = 4096
__$ArrayPad$ = -4					; size = 4
_szBuffer$ = 8						; size = 4
_bRegister$ = 12					; size = 4
?RegisterBuffer@CRegParser@ATL@@QAEJPADH@Z PROC		; ATL::CRegParser::RegisterBuffer, COMDAT
; _this$ = ecx

; 1235 : {

  00000	b8 08 10 00 00	 mov	 eax, 4104		; 00001008H
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000f	33 c4		 xor	 eax, esp
  00011	89 84 24 04 10
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+4104], eax
  00018	8b 84 24 0c 10
	00 00		 mov	 eax, DWORD PTR _szBuffer$[esp+4100]
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	8b f9		 mov	 edi, ecx

; 1236 : 	TCHAR   szToken[MAX_VALUE];
; 1237 : 	HRESULT hr = S_OK;
; 1238 : 
; 1239 : 	LPTSTR szReg = NULL;
; 1240 : 	hr = PreProcessBuffer(szBuffer, &szReg);

  00023	8d 4c 24 08	 lea	 ecx, DWORD PTR _szReg$[esp+4112]
  00027	51		 push	 ecx
  00028	50		 push	 eax
  00029	8b cf		 mov	 ecx, edi
  0002b	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _szReg$[esp+4120], 0
  00033	e8 00 00 00 00	 call	 ?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z ; ATL::CRegParser::PreProcessBuffer
  00038	8b f0		 mov	 esi, eax

; 1241 : 	if (FAILED(hr))

  0003a	85 f6		 test	 esi, esi

; 1242 : 		return hr;

  0003c	0f 8c bb 00 00
	00		 jl	 $LN12@RegisterBu

; 1243 : 
; 1244 : 	ATLTRACE(atlTraceRegistrar, 0, _T("%s\n"), szReg);
; 1245 : 
; 1246 : 	m_pchCur = szReg;

  00042	8b 44 24 08	 mov	 eax, DWORD PTR _szReg$[esp+4112]
  00046	89 07		 mov	 DWORD PTR [edi], eax

; 1247 : 
; 1248 : 	// Preprocess szReg
; 1249 : 
; 1250 : 	while (NULL != *m_pchCur)

  00048	80 38 00	 cmp	 BYTE PTR [eax], 0
  0004b	0f 84 9f 00 00
	00		 je	 $LN32@RegisterBu
  00051	53		 push	 ebx
  00052	55		 push	 ebp
$LL10@RegisterBu:

; 1251 : 	{
; 1252 : 		if (FAILED(hr = NextToken(szToken)))

  00053	8d 54 24 14	 lea	 edx, DWORD PTR _szToken$[esp+4120]
  00057	52		 push	 edx
  00058	8b cf		 mov	 ecx, edi
  0005a	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  0005f	8b f0		 mov	 esi, eax
  00061	85 f6		 test	 esi, esi
  00063	0f 8c 85 00 00
	00		 jl	 $LN37@RegisterBu

; 1253 : 			break;
; 1254 : 		HKEY hkBase;
; 1255 : 		if ((hkBase = HKeyFromString(szToken)) == NULL)

  00069	33 f6		 xor	 esi, esi
  0006b	eb 03 8d 49 00	 npad	 5
$LL17@RegisterBu:
  00070	8b 04 f5 00 00
	00 00		 mov	 eax, DWORD PTR ?map@?1??HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z@4QBUkeymap@?1??123@KAPAU4@0@Z@B[esi*8]
  00077	50		 push	 eax
  00078	8d 4c 24 18	 lea	 ecx, DWORD PTR _szToken$[esp+4124]
  0007c	51		 push	 ecx
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpiA@8
  00083	85 c0		 test	 eax, eax
  00085	74 0d		 je	 SHORT $LN26@RegisterBu
  00087	46		 inc	 esi
  00088	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  0008b	72 e3		 jb	 SHORT $LL17@RegisterBu
$LN30@RegisterBu:

; 1266 : 		{
; 1267 : 			ATLTRACE(atlTraceRegistrar, 0, _T("Syntax error, expecting a {, found a %s\n"), szToken);
; 1268 : 			hr = GenerateError(E_ATL_MISSING_OPENKEY_TOKEN);

  0008d	be 09 00 02 80	 mov	 esi, -2147352567	; 80020009H

; 1269 : 			break;

  00092	eb 5a		 jmp	 SHORT $LN37@RegisterBu
$LN26@RegisterBu:

; 1253 : 			break;
; 1254 : 		HKEY hkBase;
; 1255 : 		if ((hkBase = HKeyFromString(szToken)) == NULL)

  00094	8b 2c f5 04 00
	00 00		 mov	 ebp, DWORD PTR ?map@?1??HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z@4QBUkeymap@?1??123@KAPAU4@0@Z@B[esi*8+4]
  0009b	85 ed		 test	 ebp, ebp
  0009d	74 ee		 je	 SHORT $LN30@RegisterBu

; 1256 : 		{
; 1257 : 			ATLTRACE(atlTraceRegistrar, 0, _T("HKeyFromString failed on %s\n"), szToken);
; 1258 : 			hr = GenerateError(E_ATL_BAD_HKEY);
; 1259 : 			break;
; 1260 : 		}
; 1261 : 
; 1262 : 		if (FAILED(hr = NextToken(szToken)))

  0009f	8d 54 24 14	 lea	 edx, DWORD PTR _szToken$[esp+4120]
  000a3	52		 push	 edx
  000a4	8b cf		 mov	 ecx, edi
  000a6	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::NextToken
  000ab	8b f0		 mov	 esi, eax
  000ad	85 f6		 test	 esi, esi
  000af	7c 3d		 jl	 SHORT $LN37@RegisterBu

; 1263 : 			break;
; 1264 : 
; 1265 : 		if (chLeftBracket != *szToken)

  000b1	80 7c 24 14 7b	 cmp	 BYTE PTR _szToken$[esp+4120], 123 ; 0000007bH
  000b6	75 d5		 jne	 SHORT $LN30@RegisterBu

; 1270 : 		}
; 1271 : 		if (bRegister)

  000b8	8b 84 24 20 10
	00 00		 mov	 eax, DWORD PTR _bRegister$[esp+4116]

; 1272 : 		{
; 1273 : 			LPTSTR szRegAtRegister = m_pchCur;
; 1274 : 			hr = RegisterSubkeys(szToken, hkBase, bRegister);

  000bf	6a 00		 push	 0
  000c1	85 c0		 test	 eax, eax
  000c3	74 51		 je	 SHORT $LN4@RegisterBu
  000c5	8b 1f		 mov	 ebx, DWORD PTR [edi]
  000c7	50		 push	 eax
  000c8	55		 push	 ebp
  000c9	8d 44 24 20	 lea	 eax, DWORD PTR _szToken$[esp+4132]
  000cd	50		 push	 eax
  000ce	8b cf		 mov	 ecx, edi
  000d0	e8 00 00 00 00	 call	 ?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z ; ATL::CRegParser::RegisterSubkeys
  000d5	8b f0		 mov	 esi, eax

; 1275 : 			if (FAILED(hr))

  000d7	85 f6		 test	 esi, esi
  000d9	7d 50		 jge	 SHORT $LN1@RegisterBu

; 1276 : 			{
; 1277 : 				ATLTRACE(atlTraceRegistrar, 0, _T("Failed to register, cleaning up!\n"));
; 1278 : 				m_pchCur = szRegAtRegister;
; 1279 : 				RegisterSubkeys(szToken, hkBase, FALSE);

  000db	6a 00		 push	 0
  000dd	6a 00		 push	 0
  000df	55		 push	 ebp
  000e0	8d 44 24 20	 lea	 eax, DWORD PTR _szToken$[esp+4132]
  000e4	50		 push	 eax
  000e5	8b cf		 mov	 ecx, edi
  000e7	89 1f		 mov	 DWORD PTR [edi], ebx
  000e9	e8 00 00 00 00	 call	 ?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z ; ATL::CRegParser::RegisterSubkeys
$LN37@RegisterBu:
  000ee	5d		 pop	 ebp
  000ef	5b		 pop	 ebx
$LN32@RegisterBu:

; 1290 : 	}
; 1291 : 	CoTaskMemFree(szReg);

  000f0	8b 4c 24 08	 mov	 ecx, DWORD PTR _szReg$[esp+4112]
  000f4	51		 push	 ecx
  000f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoTaskMemFree@4

; 1292 : 	return hr;

  000fb	8b c6		 mov	 eax, esi
$LN12@RegisterBu:

; 1293 : }

  000fd	8b 8c 24 0c 10
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+4112]
  00104	5f		 pop	 edi
  00105	5e		 pop	 esi
  00106	33 cc		 xor	 ecx, esp
  00108	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010d	81 c4 08 10 00
	00		 add	 esp, 4104		; 00001008H
  00113	c2 08 00	 ret	 8
$LN4@RegisterBu:

; 1280 : 				break;
; 1281 : 			}
; 1282 : 		}
; 1283 : 		else
; 1284 : 		{
; 1285 : 			if (FAILED(hr = RegisterSubkeys(szToken, hkBase, bRegister)))

  00116	6a 00		 push	 0
  00118	55		 push	 ebp
  00119	8d 4c 24 20	 lea	 ecx, DWORD PTR _szToken$[esp+4132]
  0011d	51		 push	 ecx
  0011e	8b cf		 mov	 ecx, edi
  00120	e8 00 00 00 00	 call	 ?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z ; ATL::CRegParser::RegisterSubkeys
  00125	8b f0		 mov	 esi, eax
  00127	85 f6		 test	 esi, esi
  00129	7c c3		 jl	 SHORT $LN37@RegisterBu
$LN1@RegisterBu:

; 1286 : 				break;
; 1287 : 		}
; 1288 : 
; 1289 : 		SkipWhiteSpace();

  0012b	8b cf		 mov	 ecx, edi
  0012d	e8 00 00 00 00	 call	 ?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ ; ATL::CRegParser::SkipWhiteSpace
  00132	8b 17		 mov	 edx, DWORD PTR [edi]
  00134	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00137	0f 85 16 ff ff
	ff		 jne	 $LL10@RegisterBu

; 1247 : 
; 1248 : 	// Preprocess szReg
; 1249 : 
; 1250 : 	while (NULL != *m_pchCur)

  0013d	eb af		 jmp	 SHORT $LN37@RegisterBu
?RegisterBuffer@CRegParser@ATL@@QAEJPADH@Z ENDP		; ATL::CRegParser::RegisterBuffer
_TEXT	ENDS
PUBLIC	_szType$GSCopy$
PUBLIC	_szID$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z ; ATL::CRegObject::RegisterFromResource
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__SizeofResource@8:PROC
EXTRN	__imp__LoadResource@8:PROC
EXTRN	__imp__FindResourceA@12:PROC
EXTRN	__imp__LoadLibraryExA@12:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlalloc.h
xdata$x	SEGMENT
__catchsym$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z$8 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z$3
__tryblocktable$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z$8
__unwindtable$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z$6
	DD	00H
	DD	FLAT:__unwindfunclet$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z$7
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z
	DD	01H
	DD	FLAT:__tryblocktable$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\statreg.h
xdata$x	ENDS
;	COMDAT ?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z
_TEXT	SEGMENT
_parser$ = -40						; size = 8
_hInstResDll$ = -32					; size = 4
_szType$GSCopy$ = -28					; size = 4
_hReg$ = -28						; size = 4
_szID$GSCopy$ = -24					; size = 4
_dwSize$ = -24						; size = 4
__AtlSafeAllocaManager$ = -20				; size = 4
__$EHRec$ = -16						; size = 16
_szReg$ = 0						; size = 1028
__$ArrayPad$ = 1028					; size = 4
_bstrFileName$ = 1040					; size = 4
_szID$ = 1044						; size = 4
_szType$ = 1048						; size = 4
_bRegister$ = 1052					; size = 4
?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z PROC ; ATL::CRegObject::RegisterFromResource, COMDAT
; _this$ = ecx

; 368  : {

  00000	55		 push	 ebp
  00001	8d ac 24 f8 fb
	ff ff		 lea	 ebp, DWORD PTR [esp-1032]
  00008	81 ec 08 04 00
	00		 sub	 esp, 1032		; 00000408H
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c5		 xor	 eax, ebp
  00026	89 85 04 04 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002c	53		 push	 ebx
  0002d	56		 push	 esi
  0002e	57		 push	 edi
  0002f	50		 push	 eax
  00030	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00033	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00039	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0003c	8b 85 14 04 00
	00		 mov	 eax, DWORD PTR _szID$[ebp]
  00042	8b 95 18 04 00
	00		 mov	 edx, DWORD PTR _szType$[ebp]
  00048	8b 9d 10 04 00
	00		 mov	 ebx, DWORD PTR _bstrFileName$[ebp]

; 369  : 	USES_CONVERSION_EX;

  0004e	33 f6		 xor	 esi, esi

; 370  : 
; 371  : 	HRESULT     hr;
; 372  : 	CRegParser  parser(this);
; 373  : 	HINSTANCE   hInstResDll;
; 374  : 	HRSRC       hrscReg;
; 375  : 	HGLOBAL     hReg;
; 376  : 	DWORD       dwSize;
; 377  : 	LPSTR       szRegA;
; 378  : 	CTempBuffer<TCHAR, 1024> szReg;	
; 379  : 
; 380  : 	LPCTSTR lpszBSTRFileName = OLE2CT_EX(bstrFileName, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

  00050	89 45 e8	 mov	 DWORD PTR _szID$GSCopy$[ebp], eax
  00053	89 55 e4	 mov	 DWORD PTR _szType$GSCopy$[ebp], edx
  00056	33 ff		 xor	 edi, edi
  00058	89 75 ec	 mov	 DWORD PTR __AtlSafeAllocaManager$[ebp], esi
  0005b	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], edi
  0005e	89 4d dc	 mov	 DWORD PTR _parser$[ebp+4], ecx
  00061	89 7d d8	 mov	 DWORD PTR _parser$[ebp], edi
  00064	89 7d 00	 mov	 DWORD PTR _szReg$[ebp], edi
  00067	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  0006b	3b df		 cmp	 ebx, edi
  0006d	74 66		 je	 SHORT $LN73@RegisterFr
  0006f	53		 push	 ebx
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  00076	57		 push	 edi
  00077	40		 inc	 eax
  00078	99		 cdq
  00079	6a 02		 push	 2
  0007b	52		 push	 edx
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 __allmul
  00082	8b f8		 mov	 edi, eax
  00084	05 00 00 00 80	 add	 eax, -2147483648	; 80000000H
  00089	13 d6		 adc	 edx, esi
  0008b	85 d2		 test	 edx, edx
  0008d	77 44		 ja	 SHORT $LN76@RegisterFr
  0008f	72 05		 jb	 SHORT $LN75@RegisterFr
  00091	83 f8 ff	 cmp	 eax, -1
  00094	77 3d		 ja	 SHORT $LN76@RegisterFr
$LN75@RegisterFr:
  00096	81 ff 00 04 00
	00		 cmp	 edi, 1024		; 00000400H
  0009c	7f 1b		 jg	 SHORT $LN15@RegisterFr
  0009e	57		 push	 edi
  0009f	e8 00 00 00 00	 call	 ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
  000a4	83 c4 04	 add	 esp, 4
  000a7	84 c0		 test	 al, al
  000a9	74 0e		 je	 SHORT $LN15@RegisterFr
  000ab	8b c7		 mov	 eax, edi
  000ad	e8 00 00 00 00	 call	 __alloca_probe_16
  000b2	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  000b5	8b c4		 mov	 eax, esp
  000b7	eb 0c		 jmp	 SHORT $LN16@RegisterFr
$LN15@RegisterFr:
  000b9	57		 push	 edi
  000ba	8d 4d ec	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  000bd	e8 00 00 00 00	 call	 ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
  000c2	8b 75 ec	 mov	 esi, DWORD PTR __AtlSafeAllocaManager$[ebp]
$LN16@RegisterFr:
  000c5	6a 03		 push	 3
  000c7	57		 push	 edi
  000c8	53		 push	 ebx
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper

; 381  : #ifndef _UNICODE
; 382  : 	if (lpszBSTRFileName == NULL)

  000cf	85 c0		 test	 eax, eax
  000d1	75 38		 jne	 SHORT $LN12@RegisterFr
$LN76@RegisterFr:
  000d3	33 ff		 xor	 edi, edi
$LN73@RegisterFr:

; 383  : 	{
; 384  : 		return E_OUTOFMEMORY;

  000d5	8d 45 04	 lea	 eax, DWORD PTR _szReg$[ebp+4]
  000d8	39 45 00	 cmp	 DWORD PTR _szReg$[ebp], eax
  000db	74 08		 je	 SHORT $LN39@RegisterFr
  000dd	8d 4d 00	 lea	 ecx, DWORD PTR _szReg$[ebp]
  000e0	e8 00 00 00 00	 call	 ?FreeHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::FreeHeap
$LN39@RegisterFr:
  000e5	3b f7		 cmp	 esi, edi
  000e7	74 18		 je	 SHORT $LN42@RegisterFr
  000e9	8d a4 24 00 00
	00 00		 npad	 7
$LL43@RegisterFr:
  000f0	8b c6		 mov	 eax, esi
  000f2	8b 36		 mov	 esi, DWORD PTR [esi]
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 _free
  000fa	83 c4 04	 add	 esp, 4
  000fd	3b f7		 cmp	 esi, edi
  000ff	75 ef		 jne	 SHORT $LL43@RegisterFr
$LN42@RegisterFr:
  00101	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  00106	e9 28 01 00 00	 jmp	 $LN13@RegisterFr
$LN12@RegisterFr:

; 385  : 	}
; 386  : #endif // _UNICODE
; 387  : 
; 388  : 	hInstResDll = LoadLibraryEx(lpszBSTRFileName, NULL, LOAD_LIBRARY_AS_DATAFILE);

  0010b	6a 02		 push	 2
  0010d	6a 00		 push	 0
  0010f	50		 push	 eax
  00110	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryExA@12
  00116	8b d8		 mov	 ebx, eax
  00118	89 5d e0	 mov	 DWORD PTR _hInstResDll$[ebp], ebx

; 389  : 
; 390  : 	if (NULL == hInstResDll)

  0011b	85 db		 test	 ebx, ebx
  0011d	75 0c		 jne	 SHORT $LN11@RegisterFr

; 391  : 	{
; 392  : 		ATLTRACE(atlTraceRegistrar, 0, _T("Failed to LoadLibrary on %s\n"), bstrFileName);
; 393  : 		hr = AtlHresultFromLastError();

  0011f	e8 00 00 00 00	 call	 ?AtlHresultFromLastError@ATL@@YAJXZ ; ATL::AtlHresultFromLastError
  00124	8b f8		 mov	 edi, eax

; 394  : 		goto ReturnHR;

  00126	e9 da 00 00 00	 jmp	 $LN1@RegisterFr
$LN11@RegisterFr:

; 395  : 	}
; 396  : 
; 397  : 	hrscReg =FindResource((HMODULE)hInstResDll, szID, szType);

  0012b	8b 4d e4	 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  0012e	8b 55 e8	 mov	 edx, DWORD PTR _szID$GSCopy$[ebp]
  00131	51		 push	 ecx
  00132	52		 push	 edx
  00133	53		 push	 ebx
  00134	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindResourceA@12
  0013a	8b f8		 mov	 edi, eax

; 398  : 
; 399  : 	if (NULL == hrscReg)

  0013c	85 ff		 test	 edi, edi
  0013e	75 0a		 jne	 SHORT $LN9@RegisterFr

; 400  : 	{
; 401  : 		ATLTRACE(atlTraceRegistrar, 0, (HIWORD(szID) == NULL) ? 
; 402  : 			_T("Failed to FindResource on ID:%d TYPE:%s\n") : 
; 403  : 			_T("Failed to FindResource on ID:%s TYPE:%s\n"), 
; 404  : 			szID, szType);
; 405  : 		hr = AtlHresultFromLastError();

  00140	e8 00 00 00 00	 call	 ?AtlHresultFromLastError@ATL@@YAJXZ ; ATL::AtlHresultFromLastError

; 406  : 		goto ReturnHR;

  00145	e9 b2 00 00 00	 jmp	 $LN79@RegisterFr
$LN9@RegisterFr:

; 407  : 	}
; 408  : 	hReg = LoadResource((HMODULE)hInstResDll, hrscReg);

  0014a	57		 push	 edi
  0014b	53		 push	 ebx
  0014c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadResource@8
  00152	89 45 e4	 mov	 DWORD PTR _hReg$[ebp], eax

; 409  : 
; 410  : 	if (NULL == hReg)

  00155	85 c0		 test	 eax, eax
  00157	75 0a		 jne	 SHORT $LN7@RegisterFr

; 411  : 	{
; 412  : 		ATLTRACE(atlTraceRegistrar, 0, _T("Failed to LoadResource\n"));
; 413  : 		hr = AtlHresultFromLastError();

  00159	e8 00 00 00 00	 call	 ?AtlHresultFromLastError@ATL@@YAJXZ ; ATL::AtlHresultFromLastError

; 414  : 		goto ReturnHR;

  0015e	e9 99 00 00 00	 jmp	 $LN79@RegisterFr
$LN7@RegisterFr:

; 415  : 	}
; 416  : 
; 417  : 	dwSize = SizeofResource((HMODULE)hInstResDll, hrscReg);

  00163	57		 push	 edi
  00164	53		 push	 ebx
  00165	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SizeofResource@8
  0016b	8b f8		 mov	 edi, eax

; 418  : 	szRegA = (LPSTR)hReg;
; 419  : 
; 420  : 	// Allocate extra space for NULL.
; 421  : 	if (dwSize + 1 < dwSize) 

  0016d	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00170	89 7d e8	 mov	 DWORD PTR _dwSize$[ebp], edi
  00173	3b c7		 cmp	 eax, edi
  00175	73 22		 jae	 SHORT $LN5@RegisterFr

; 422  : 		return E_OUTOFMEMORY;

  00177	8d 45 04	 lea	 eax, DWORD PTR _szReg$[ebp+4]
  0017a	39 45 00	 cmp	 DWORD PTR _szReg$[ebp], eax
  0017d	74 08		 je	 SHORT $LN48@RegisterFr
  0017f	8d 4d 00	 lea	 ecx, DWORD PTR _szReg$[ebp]
  00182	e8 00 00 00 00	 call	 ?FreeHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::FreeHeap
$LN48@RegisterFr:
  00187	8d 4d ec	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  0018a	e8 00 00 00 00	 call	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
  0018f	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  00194	e9 9a 00 00 00	 jmp	 $LN13@RegisterFr
$LN5@RegisterFr:

; 423  : 	ATLTRY(szReg.Allocate(dwSize + 1));

  00199	50		 push	 eax
  0019a	8d 4d 00	 lea	 ecx, DWORD PTR _szReg$[ebp]
  0019d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  001a1	e8 00 00 00 00	 call	 ?Allocate@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::Allocate
  001a6	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  001ad	eb 16		 jmp	 SHORT $LN26@RegisterFr
__catch$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z$3:
  001af	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  001b6	b8 00 00 00 00	 mov	 eax, $LN77@RegisterFr
  001bb	c3		 ret	 0
$LN77@RegisterFr:
  001bc	8b 75 ec	 mov	 esi, DWORD PTR __AtlSafeAllocaManager$[ebp]
  001bf	8b 5d e0	 mov	 ebx, DWORD PTR _hInstResDll$[ebp]
  001c2	8b 7d e8	 mov	 edi, DWORD PTR _dwSize$[ebp]
$LN26@RegisterFr:

; 424  : 	if (szReg == NULL)

  001c5	8b 45 00	 mov	 eax, DWORD PTR _szReg$[ebp]
  001c8	85 c0		 test	 eax, eax
  001ca	75 07		 jne	 SHORT $LN3@RegisterFr

; 425  : 	{
; 426  : 		hr = E_OUTOFMEMORY;

  001cc	bf 0e 00 07 80	 mov	 edi, -2147024882	; 8007000eH

; 427  : 		goto ReturnHR;

  001d1	eb 2b		 jmp	 SHORT $ReturnHR$82679
$LN3@RegisterFr:

; 428  : 	}	
; 429  : 
; 430  : #ifdef _UNICODE
; 431  : 	DWORD uniSize = ::MultiByteToWideChar(_AtlGetConversionACP(), 0, szRegA, dwSize, szReg, dwSize);
; 432  : 	if (uniSize == 0)
; 433  : 	{
; 434  : 		hr = AtlHresultFromLastError();
; 435  : 		goto ReturnHR;
; 436  : 	}
; 437  : 	// Append a NULL at the end.
; 438  : 	szReg[uniSize] = NULL;
; 439  : #else
; 440  : 	Checked::memcpy_s(szReg, dwSize, szRegA, dwSize);

  001d3	8b 4d e4	 mov	 ecx, DWORD PTR _hReg$[ebp]
  001d6	57		 push	 edi
  001d7	51		 push	 ecx
  001d8	57		 push	 edi
  001d9	50		 push	 eax
  001da	e8 00 00 00 00	 call	 ?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z ; ATL::Checked::memcpy_s

; 441  : 	// Append a NULL at the end.
; 442  :    	szReg[dwSize] = NULL;

  001df	8b 55 00	 mov	 edx, DWORD PTR _szReg$[ebp]

; 443  : #endif
; 444  : 
; 445  :  
; 446  : 
; 447  : 	hr = parser.RegisterBuffer(szReg, bRegister);

  001e2	8b 85 1c 04 00
	00		 mov	 eax, DWORD PTR _bRegister$[ebp]
  001e8	83 c4 10	 add	 esp, 16			; 00000010H
  001eb	c6 04 3a 00	 mov	 BYTE PTR [edx+edi], 0
  001ef	8b 4d 00	 mov	 ecx, DWORD PTR _szReg$[ebp]
  001f2	50		 push	 eax
  001f3	51		 push	 ecx
  001f4	8d 4d d8	 lea	 ecx, DWORD PTR _parser$[ebp]
  001f7	e8 00 00 00 00	 call	 ?RegisterBuffer@CRegParser@ATL@@QAEJPADH@Z ; ATL::CRegParser::RegisterBuffer
$LN79@RegisterFr:
  001fc	8b f8		 mov	 edi, eax
$ReturnHR$82679:

; 448  : 
; 449  : ReturnHR:
; 450  : 
; 451  : 	if (NULL != hInstResDll)
; 452  : 		FreeLibrary((HMODULE)hInstResDll);

  001fe	53		 push	 ebx
  001ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4
$LN1@RegisterFr:

; 453  : 	return hr;

  00205	8d 55 04	 lea	 edx, DWORD PTR _szReg$[ebp+4]
  00208	39 55 00	 cmp	 DWORD PTR _szReg$[ebp], edx
  0020b	74 08		 je	 SHORT $LN59@RegisterFr
  0020d	8d 4d 00	 lea	 ecx, DWORD PTR _szReg$[ebp]
  00210	e8 00 00 00 00	 call	 ?FreeHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::FreeHeap
$LN59@RegisterFr:
  00215	85 f6		 test	 esi, esi
  00217	74 18		 je	 SHORT $LN62@RegisterFr
  00219	8d a4 24 00 00
	00 00		 npad	 7
$LL63@RegisterFr:
  00220	8b c6		 mov	 eax, esi
  00222	8b 36		 mov	 esi, DWORD PTR [esi]
  00224	50		 push	 eax
  00225	e8 00 00 00 00	 call	 _free
  0022a	83 c4 04	 add	 esp, 4
  0022d	85 f6		 test	 esi, esi
  0022f	75 ef		 jne	 SHORT $LL63@RegisterFr
$LN62@RegisterFr:
  00231	8b c7		 mov	 eax, edi
$LN13@RegisterFr:

; 454  : }

  00233	8d 65 c8	 lea	 esp, DWORD PTR [ebp-56]
  00236	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00239	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00240	59		 pop	 ecx
  00241	5f		 pop	 edi
  00242	5e		 pop	 esi
  00243	5b		 pop	 ebx
  00244	8b 8d 04 04 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0024a	33 cd		 xor	 ecx, ebp
  0024c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00251	81 c5 08 04 00
	00		 add	 ebp, 1032		; 00000408H
  00257	8b e5		 mov	 esp, ebp
  00259	5d		 pop	 ebp
  0025a	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z$6:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__unwindfunclet$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z$7:
  00008	8d 4d 00	 lea	 ecx, DWORD PTR _szReg$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::~CTempBuffer<char,1024,ATL::CCRTAllocator>
__ehhandler$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 8a 10 04 00
	00		 mov	 ecx, DWORD PTR [edx+1040]
  00027	33 c8		 xor	 ecx, eax
  00029	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z
  00033	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z ENDP ; ATL::CRegObject::RegisterFromResource
PUBLIC	__$ArrayPad$
PUBLIC	?ResourceRegister@CRegObject@ATL@@QAGJPB_WI0@Z	; ATL::CRegObject::ResourceRegister
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlalloc.h
xdata$x	SEGMENT
__unwindtable$?ResourceRegister@CRegObject@ATL@@QAGJPB_WI0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ResourceRegister@CRegObject@ATL@@QAGJPB_WI0@Z$0
__ehfuncinfo$?ResourceRegister@CRegObject@ATL@@QAGJPB_WI0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ResourceRegister@CRegObject@ATL@@QAGJPB_WI0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\statreg.h
xdata$x	ENDS
;	COMDAT ?ResourceRegister@CRegObject@ATL@@QAGJPB_WI0@Z
_TEXT	SEGMENT
__AtlSafeAllocaManager$ = -20				; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_szFileName$ = 12					; size = 4
_nID$ = 16						; size = 4
_szType$ = 20						; size = 4
?ResourceRegister@CRegObject@ATL@@QAGJPB_WI0@Z PROC	; ATL::CRegObject::ResourceRegister, COMDAT

; 457  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ResourceRegister@CRegObject@ATL@@QAGJPB_WI0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 458  : 	USES_CONVERSION_EX;

  0002b	33 f6		 xor	 esi, esi
  0002d	89 75 ec	 mov	 DWORD PTR __AtlSafeAllocaManager$[ebp], esi

; 459  : 
; 460  : 	LPCTSTR lpszT = OLE2CT_EX(szType, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

  00030	8b 5d 14	 mov	 ebx, DWORD PTR _szType$[ebp]
  00033	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  00036	3b de		 cmp	 ebx, esi
  00038	74 77		 je	 SHORT $LN19@ResourceRe
  0003a	53		 push	 ebx
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  00041	56		 push	 esi
  00042	40		 inc	 eax
  00043	99		 cdq
  00044	6a 02		 push	 2
  00046	52		 push	 edx
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 __allmul
  0004d	8b f8		 mov	 edi, eax
  0004f	05 00 00 00 80	 add	 eax, -2147483648	; 80000000H
  00054	13 d6		 adc	 edx, esi
  00056	85 d2		 test	 edx, edx
  00058	77 57		 ja	 SHORT $LN19@ResourceRe
  0005a	72 05		 jb	 SHORT $LN37@ResourceRe
  0005c	83 f8 ff	 cmp	 eax, -1
  0005f	77 50		 ja	 SHORT $LN19@ResourceRe
$LN37@ResourceRe:
  00061	81 ff 00 04 00
	00		 cmp	 edi, 1024		; 00000400H
  00067	7f 18		 jg	 SHORT $LN4@ResourceRe
  00069	57		 push	 edi
  0006a	e8 00 00 00 00	 call	 ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
  0006f	83 c4 04	 add	 esp, 4
  00072	84 c0		 test	 al, al
  00074	74 0b		 je	 SHORT $LN4@ResourceRe
  00076	8b c7		 mov	 eax, edi
  00078	e8 00 00 00 00	 call	 __alloca_probe_16
  0007d	8b c4		 mov	 eax, esp
  0007f	eb 0c		 jmp	 SHORT $LN5@ResourceRe
$LN4@ResourceRe:
  00081	57		 push	 edi
  00082	8d 4d ec	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  00085	e8 00 00 00 00	 call	 ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
  0008a	8b 75 ec	 mov	 esi, DWORD PTR __AtlSafeAllocaManager$[ebp]
$LN5@ResourceRe:
  0008d	6a 03		 push	 3
  0008f	57		 push	 edi
  00090	53		 push	 ebx
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper

; 461  : #ifndef _UNICODE
; 462  : 	if (lpszT == NULL)

  00097	85 c0		 test	 eax, eax
  00099	75 1d		 jne	 SHORT $LN1@ResourceRe

; 463  : 	{
; 464  : 		return E_OUTOFMEMORY;

  0009b	85 f6		 test	 esi, esi
  0009d	74 12		 je	 SHORT $LN19@ResourceRe
  0009f	90		 npad	 1
$LL20@ResourceRe:
  000a0	8b c6		 mov	 eax, esi
  000a2	8b 36		 mov	 esi, DWORD PTR [esi]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _free
  000aa	83 c4 04	 add	 esp, 4
  000ad	85 f6		 test	 esi, esi
  000af	75 ef		 jne	 SHORT $LL20@ResourceRe
$LN19@ResourceRe:
  000b1	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  000b6	eb 2d		 jmp	 SHORT $LN2@ResourceRe
$LN1@ResourceRe:

; 465  : 	}
; 466  : #endif // _UNICODE
; 467  : 
; 468  : 	return RegisterFromResource(szFileName, MAKEINTRESOURCE(nID), lpszT, TRUE);

  000b8	8b 4d 0c	 mov	 ecx, DWORD PTR _szFileName$[ebp]
  000bb	6a 01		 push	 1
  000bd	50		 push	 eax
  000be	0f b7 45 10	 movzx	 eax, WORD PTR _nID$[ebp]
  000c2	50		 push	 eax
  000c3	51		 push	 ecx
  000c4	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000c7	e8 00 00 00 00	 call	 ?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z ; ATL::CRegObject::RegisterFromResource
  000cc	8b f8		 mov	 edi, eax
  000ce	85 f6		 test	 esi, esi
  000d0	74 11		 je	 SHORT $LN25@ResourceRe
$LL26@ResourceRe:
  000d2	8b c6		 mov	 eax, esi
  000d4	8b 36		 mov	 esi, DWORD PTR [esi]
  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 _free
  000dc	83 c4 04	 add	 esp, 4
  000df	85 f6		 test	 esi, esi
  000e1	75 ef		 jne	 SHORT $LL26@ResourceRe
$LN25@ResourceRe:
  000e3	8b c7		 mov	 eax, edi
$LN2@ResourceRe:

; 469  : }

  000e5	8d 65 dc	 lea	 esp, DWORD PTR [ebp-36]
  000e8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000eb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f2	59		 pop	 ecx
  000f3	5f		 pop	 edi
  000f4	5e		 pop	 esi
  000f5	5b		 pop	 ebx
  000f6	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f9	33 cd		 xor	 ecx, ebp
  000fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ResourceRegister@CRegObject@ATL@@QAGJPB_WI0@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?ResourceRegister@CRegObject@ATL@@QAGJPB_WI0@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ResourceRegister@CRegObject@ATL@@QAGJPB_WI0@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ResourceRegister@CRegObject@ATL@@QAGJPB_WI0@Z ENDP	; ATL::CRegObject::ResourceRegister
PUBLIC	__$ArrayPad$
PUBLIC	?ResourceUnregister@CRegObject@ATL@@QAGJPB_WI0@Z ; ATL::CRegObject::ResourceUnregister
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlalloc.h
xdata$x	SEGMENT
__unwindtable$?ResourceUnregister@CRegObject@ATL@@QAGJPB_WI0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ResourceUnregister@CRegObject@ATL@@QAGJPB_WI0@Z$0
__ehfuncinfo$?ResourceUnregister@CRegObject@ATL@@QAGJPB_WI0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ResourceUnregister@CRegObject@ATL@@QAGJPB_WI0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\statreg.h
xdata$x	ENDS
;	COMDAT ?ResourceUnregister@CRegObject@ATL@@QAGJPB_WI0@Z
_TEXT	SEGMENT
__AtlSafeAllocaManager$ = -20				; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_szFileName$ = 12					; size = 4
_nID$ = 16						; size = 4
_szType$ = 20						; size = 4
?ResourceUnregister@CRegObject@ATL@@QAGJPB_WI0@Z PROC	; ATL::CRegObject::ResourceUnregister, COMDAT

; 489  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ResourceUnregister@CRegObject@ATL@@QAGJPB_WI0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 490  : 	USES_CONVERSION_EX;

  0002b	33 f6		 xor	 esi, esi
  0002d	89 75 ec	 mov	 DWORD PTR __AtlSafeAllocaManager$[ebp], esi

; 491  : 
; 492  : 	LPCTSTR lpszT = OLE2CT_EX(szType, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

  00030	8b 5d 14	 mov	 ebx, DWORD PTR _szType$[ebp]
  00033	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  00036	3b de		 cmp	 ebx, esi
  00038	74 77		 je	 SHORT $LN19@ResourceUn
  0003a	53		 push	 ebx
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  00041	56		 push	 esi
  00042	40		 inc	 eax
  00043	99		 cdq
  00044	6a 02		 push	 2
  00046	52		 push	 edx
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 __allmul
  0004d	8b f8		 mov	 edi, eax
  0004f	05 00 00 00 80	 add	 eax, -2147483648	; 80000000H
  00054	13 d6		 adc	 edx, esi
  00056	85 d2		 test	 edx, edx
  00058	77 57		 ja	 SHORT $LN19@ResourceUn
  0005a	72 05		 jb	 SHORT $LN37@ResourceUn
  0005c	83 f8 ff	 cmp	 eax, -1
  0005f	77 50		 ja	 SHORT $LN19@ResourceUn
$LN37@ResourceUn:
  00061	81 ff 00 04 00
	00		 cmp	 edi, 1024		; 00000400H
  00067	7f 18		 jg	 SHORT $LN4@ResourceUn
  00069	57		 push	 edi
  0006a	e8 00 00 00 00	 call	 ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
  0006f	83 c4 04	 add	 esp, 4
  00072	84 c0		 test	 al, al
  00074	74 0b		 je	 SHORT $LN4@ResourceUn
  00076	8b c7		 mov	 eax, edi
  00078	e8 00 00 00 00	 call	 __alloca_probe_16
  0007d	8b c4		 mov	 eax, esp
  0007f	eb 0c		 jmp	 SHORT $LN5@ResourceUn
$LN4@ResourceUn:
  00081	57		 push	 edi
  00082	8d 4d ec	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  00085	e8 00 00 00 00	 call	 ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
  0008a	8b 75 ec	 mov	 esi, DWORD PTR __AtlSafeAllocaManager$[ebp]
$LN5@ResourceUn:
  0008d	6a 03		 push	 3
  0008f	57		 push	 edi
  00090	53		 push	 ebx
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper

; 493  : #ifndef _UNICODE
; 494  : 	if (lpszT == NULL)

  00097	85 c0		 test	 eax, eax
  00099	75 1d		 jne	 SHORT $LN1@ResourceUn

; 495  : 	{
; 496  : 		return E_OUTOFMEMORY;

  0009b	85 f6		 test	 esi, esi
  0009d	74 12		 je	 SHORT $LN19@ResourceUn
  0009f	90		 npad	 1
$LL20@ResourceUn:
  000a0	8b c6		 mov	 eax, esi
  000a2	8b 36		 mov	 esi, DWORD PTR [esi]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _free
  000aa	83 c4 04	 add	 esp, 4
  000ad	85 f6		 test	 esi, esi
  000af	75 ef		 jne	 SHORT $LL20@ResourceUn
$LN19@ResourceUn:
  000b1	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  000b6	eb 2d		 jmp	 SHORT $LN2@ResourceUn
$LN1@ResourceUn:

; 497  : 	}
; 498  : #endif // _UNICODE
; 499  : 	return RegisterFromResource(szFileName, MAKEINTRESOURCE(nID), lpszT, FALSE);

  000b8	8b 4d 0c	 mov	 ecx, DWORD PTR _szFileName$[ebp]
  000bb	6a 00		 push	 0
  000bd	50		 push	 eax
  000be	0f b7 45 10	 movzx	 eax, WORD PTR _nID$[ebp]
  000c2	50		 push	 eax
  000c3	51		 push	 ecx
  000c4	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000c7	e8 00 00 00 00	 call	 ?RegisterFromResource@CRegObject@ATL@@IAEJPB_WPBD1H@Z ; ATL::CRegObject::RegisterFromResource
  000cc	8b f8		 mov	 edi, eax
  000ce	85 f6		 test	 esi, esi
  000d0	74 11		 je	 SHORT $LN25@ResourceUn
$LL26@ResourceUn:
  000d2	8b c6		 mov	 eax, esi
  000d4	8b 36		 mov	 esi, DWORD PTR [esi]
  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 _free
  000dc	83 c4 04	 add	 esp, 4
  000df	85 f6		 test	 esi, esi
  000e1	75 ef		 jne	 SHORT $LL26@ResourceUn
$LN25@ResourceUn:
  000e3	8b c7		 mov	 eax, edi
$LN2@ResourceUn:

; 500  : }

  000e5	8d 65 dc	 lea	 esp, DWORD PTR [ebp-36]
  000e8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000eb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f2	59		 pop	 ecx
  000f3	5f		 pop	 edi
  000f4	5e		 pop	 esi
  000f5	5b		 pop	 ebx
  000f6	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f9	33 cd		 xor	 ecx, ebp
  000fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ResourceUnregister@CRegObject@ATL@@QAGJPB_WI0@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?ResourceUnregister@CRegObject@ATL@@QAGJPB_WI0@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ResourceUnregister@CRegObject@ATL@@QAGJPB_WI0@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ResourceUnregister@CRegObject@ATL@@QAGJPB_WI0@Z ENDP	; ATL::CRegObject::ResourceUnregister
PUBLIC	??_C@_0L@FEEFGEIL@CipherShed?$AA@		; `string'
PUBLIC	??_C@_1BC@KAILKFFG@?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BM@IFKNBDBK@?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAM?$AAO?$AAD?$AAU?$AAL?$AAE?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BI@FPIOFILF@?$AAM?$AAA?$AAI?$AAN?$AA_?$AAM?$AAO?$AAD?$AAU?$AAL?$AAE?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DC@LLKEOMDK@?$AA?$CF?$AAh?$AAs?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AA?5?$AAF?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?4?$AAe?$AAx?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CE@EBKOGEKF@?$AA?$CF?$AAh?$AAs?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AA?4?$AAe?$AAx?$AAe?$AA?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_RegisterComServers
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	_MainDlg:DWORD
EXTRN	__imp__RegisterTypeLib@12:PROC
EXTRN	__imp__LoadTypeLib@8:PROC
EXTRN	__imp__GetModuleFileNameW@12:PROC
EXTRN	__imp__UnRegisterTypeLib@20:PROC
EXTRN	__imp__wsprintfW:PROC
;	COMDAT ??_C@_0L@FEEFGEIL@CipherShed?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlcomcli.h
CONST	SEGMENT
??_C@_0L@FEEFGEIL@CipherShed?$AA@ DB 'CipherShed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@KAILKFFG@?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@KAILKFFG@?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?$AA@ DB 'R'
	DB	00H, 'E', 00H, 'G', 00H, 'I', 00H, 'S', 00H, 'T', 00H, 'R', 00H
	DB	'Y', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@IFKNBDBK@?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAM?$AAO?$AAD?$AAU?$AAL?$AAE?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@IFKNBDBK@?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAM?$AAO?$AAD?$AAU?$AAL?$AAE?$AA?$AA@ DB 'F'
	DB	00H, 'O', 00H, 'R', 00H, 'M', 00H, 'A', 00H, 'T', 00H, '_', 00H
	DB	'M', 00H, 'O', 00H, 'D', 00H, 'U', 00H, 'L', 00H, 'E', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@FPIOFILF@?$AAM?$AAA?$AAI?$AAN?$AA_?$AAM?$AAO?$AAD?$AAU?$AAL?$AAE?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@FPIOFILF@?$AAM?$AAA?$AAI?$AAN?$AA_?$AAM?$AAO?$AAD?$AAU?$AAL?$AAE?$AA?$AA@ DB 'M'
	DB	00H, 'A', 00H, 'I', 00H, 'N', 00H, '_', 00H, 'M', 00H, 'O', 00H
	DB	'D', 00H, 'U', 00H, 'L', 00H, 'E', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@LLKEOMDK@?$AA?$CF?$AAh?$AAs?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AA?5?$AAF?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?4?$AAe?$AAx?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@LLKEOMDK@?$AA?$CF?$AAh?$AAs?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AA?5?$AAF?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?4?$AAe?$AAx?$AAe?$AA?$AA@ DB '%'
	DB	00H, 'h', 00H, 's', 00H, 'C', 00H, 'i', 00H, 'p', 00H, 'h', 00H
	DB	'e', 00H, 'r', 00H, 'S', 00H, 'h', 00H, 'e', 00H, 'd', 00H, ' '
	DB	00H, 'F', 00H, 'o', 00H, 'r', 00H, 'm', 00H, 'a', 00H, 't', 00H
	DB	'.', 00H, 'e', 00H, 'x', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@EBKOGEKF@?$AA?$CF?$AAh?$AAs?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AA?4?$AAe?$AAx?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@EBKOGEKF@?$AA?$CF?$AAh?$AAs?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AA?4?$AAe?$AAx?$AAe?$AA?$AA@ DB '%'
	DB	00H, 'h', 00H, 's', 00H, 'C', 00H, 'i', 00H, 'p', 00H, 'h', 00H
	DB	'e', 00H, 'r', 00H, 'S', 00H, 'h', 00H, 'e', 00H, 'd', 00H, '.'
	DB	00H, 'e', 00H, 'x', 00H, 'e', 00H, 00H, 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\home\public\desktop\projects\ciphershed.build\src\setup\comsetup.cpp
CONST	ENDS
;	COMDAT _RegisterComServers
_TEXT	SEGMENT
_tl$ = -4688						; size = 4
_tl2$ = -4684						; size = 4
$T112593 = -4680					; size = 16
_ro$ = -4664						; size = 44
_setupModule$ = -4620					; size = 520
_mainModule$ = -4100					; size = 2048
_formatModule$ = -2052					; size = 2048
__$ArrayPad$ = -4					; size = 4
_modulePath$ = 8					; size = 4
_RegisterComServers PROC				; COMDAT

; 29   : {

  00000	b8 50 12 00 00	 mov	 eax, 4688		; 00001250H
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000f	33 c4		 xor	 eax, esp
  00011	89 84 24 4c 12
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+4688], eax
  00018	53		 push	 ebx
  00019	55		 push	 ebp
  0001a	56		 push	 esi
  0001b	8b b4 24 60 12
	00 00		 mov	 esi, DWORD PTR _modulePath$[esp+4696]
  00022	57		 push	 edi

; 30   : 	BOOL ret = TRUE;
; 31   : 	wchar_t mainModule[1024], formatModule[1024];
; 32   : 	CComPtr<ITypeLib> tl, tl2;
; 33   : 
; 34   : 	wsprintfW (mainModule, L"%hsCipherShed.exe", modulePath);

  00023	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__wsprintfW
  00029	56		 push	 esi
  0002a	8d 84 24 60 02
	00 00		 lea	 eax, DWORD PTR _mainModule$[esp+4708]
  00031	33 db		 xor	 ebx, ebx
  00033	68 00 00 00 00	 push	 OFFSET ??_C@_1CE@EBKOGEKF@?$AA?$CF?$AAh?$AAs?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AA?4?$AAe?$AAx?$AAe?$AA?$AA@
  00038	50		 push	 eax
  00039	bd 01 00 00 00	 mov	 ebp, 1
  0003e	89 5c 24 1c	 mov	 DWORD PTR _tl$[esp+4716], ebx
  00042	89 5c 24 20	 mov	 DWORD PTR _tl2$[esp+4716], ebx
  00046	ff d7		 call	 edi

; 35   : 	wsprintfW (formatModule, L"%hsCipherShed Format.exe", modulePath);

  00048	56		 push	 esi
  00049	8d 8c 24 6c 0a
	00 00		 lea	 ecx, DWORD PTR _formatModule$[esp+4720]
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_1DC@LLKEOMDK@?$AA?$CF?$AAh?$AAs?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AA?5?$AAF?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?4?$AAe?$AAx?$AAe?$AA?$AA@
  00055	51		 push	 ecx
  00056	ff d7		 call	 edi

; 36   : 
; 37   : 	UnRegisterTypeLib (LIBID_CipherShedMainCom, TC_MAIN_COM_VERSION_MAJOR, TC_MAIN_COM_VERSION_MINOR, 0, SYS_WIN32);

  00058	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__UnRegisterTypeLib@20
  0005e	83 c4 18	 add	 esp, 24			; 00000018H
  00061	55		 push	 ebp
  00062	53		 push	 ebx
  00063	6a 04		 push	 4
  00065	6a 02		 push	 2
  00067	68 00 00 00 00	 push	 OFFSET _LIBID_CipherShedMainCom
  0006c	ff d6		 call	 esi

; 38   : 	UnRegisterTypeLib (LIBID_CipherShedFormatCom, TC_FORMAT_COM_VERSION_MAJOR, TC_FORMAT_COM_VERSION_MINOR, 0, SYS_WIN32);

  0006e	55		 push	 ebp
  0006f	53		 push	 ebx
  00070	6a 04		 push	 4
  00072	6a 02		 push	 2
  00074	68 00 00 00 00	 push	 OFFSET _LIBID_CipherShedFormatCom
  00079	ff d6		 call	 esi

; 39   : 
; 40   : 	wchar_t setupModule[MAX_PATH];
; 41   : 	GetModuleFileNameW (NULL, setupModule, sizeof (setupModule) / sizeof (setupModule[0]));

  0007b	68 04 01 00 00	 push	 260			; 00000104H
  00080	8d 54 24 58	 lea	 edx, DWORD PTR _setupModule$[esp+4708]
  00084	52		 push	 edx
  00085	53		 push	 ebx
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameW@12

; 42   : 
; 43   : 	CRegObject ro;

  0008c	33 c0		 xor	 eax, eax

; 44   : 	HRESULT r;
; 45   : 
; 46   : 	if (!SUCCEEDED (r = ro.FinalConstruct ())	/* Init. */
; 47   : 		|| !SUCCEEDED (r = ro.AddReplacement (L"MAIN_MODULE", mainModule))	/* Replaceable parameters. */
; 48   : 		|| !SUCCEEDED (r = ro.AddReplacement (L"FORMAT_MODULE", formatModule))
; 49   : 		|| !SUCCEEDED (r = ro.ResourceRegister (setupModule, IDR_COMREG, L"REGISTRY"))	/* Register ComSetup.rgs */
; 50   : 		|| !SUCCEEDED (r = LoadTypeLib (mainModule, &tl))	/* CipherShed type class. */
; 51   : 		|| !SUCCEEDED (r = RegisterTypeLib (tl, mainModule, 0))
; 52   : 		|| !SUCCEEDED (r = LoadTypeLib (formatModule, &tl2))	/* CipherShedFormat type class. */
; 53   : 		|| !SUCCEEDED (r = RegisterTypeLib (tl2, formatModule, 0)))

  0008e	8d 4c 24 38	 lea	 ecx, DWORD PTR _ro$[esp+4720]
  00092	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR _ro$[esp+4704], OFFSET ??_7CRegObject@ATL@@6B@
  0009a	89 5c 24 2c	 mov	 DWORD PTR _ro$[esp+4708], ebx
  0009e	89 5c 24 30	 mov	 DWORD PTR _ro$[esp+4712], ebx
  000a2	89 5c 24 34	 mov	 DWORD PTR _ro$[esp+4716], ebx
  000a6	89 44 24 38	 mov	 DWORD PTR _ro$[esp+4720], eax
  000aa	89 44 24 3c	 mov	 DWORD PTR _ro$[esp+4724], eax
  000ae	89 44 24 40	 mov	 DWORD PTR _ro$[esp+4728], eax
  000b2	89 44 24 44	 mov	 DWORD PTR _ro$[esp+4732], eax
  000b6	89 44 24 48	 mov	 DWORD PTR _ro$[esp+4736], eax
  000ba	89 44 24 4c	 mov	 DWORD PTR _ro$[esp+4740], eax
  000be	88 5c 24 50	 mov	 BYTE PTR _ro$[esp+4744], bl
  000c2	e8 00 00 00 00	 call	 ?Init@CComCriticalSection@ATL@@QAEJXZ ; ATL::CComCriticalSection::Init
  000c7	3b c3		 cmp	 eax, ebx
  000c9	0f 8c b3 00 00
	00		 jl	 $LN1@RegisterCo
  000cf	8d 84 24 5c 02
	00 00		 lea	 eax, DWORD PTR _mainModule$[esp+4704]
  000d6	50		 push	 eax
  000d7	68 00 00 00 00	 push	 OFFSET ??_C@_1BI@FPIOFILF@?$AAM?$AAA?$AAI?$AAN?$AA_?$AAM?$AAO?$AAD?$AAU?$AAL?$AAE?$AA?$AA@
  000dc	8d 4c 24 30	 lea	 ecx, DWORD PTR _ro$[esp+4712]
  000e0	51		 push	 ecx
  000e1	c6 44 24 5c 01	 mov	 BYTE PTR _ro$[esp+4756], 1
  000e6	e8 00 00 00 00	 call	 ?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z ; ATL::CRegObject::AddReplacement
  000eb	3b c3		 cmp	 eax, ebx
  000ed	0f 8c 8f 00 00
	00		 jl	 $LN1@RegisterCo
  000f3	8d 94 24 5c 0a
	00 00		 lea	 edx, DWORD PTR _formatModule$[esp+4704]
  000fa	52		 push	 edx
  000fb	68 00 00 00 00	 push	 OFFSET ??_C@_1BM@IFKNBDBK@?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAM?$AAO?$AAD?$AAU?$AAL?$AAE?$AA?$AA@
  00100	8d 44 24 30	 lea	 eax, DWORD PTR _ro$[esp+4712]
  00104	50		 push	 eax
  00105	e8 00 00 00 00	 call	 ?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z ; ATL::CRegObject::AddReplacement
  0010a	3b c3		 cmp	 eax, ebx
  0010c	7c 74		 jl	 SHORT $LN1@RegisterCo
  0010e	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@KAILKFFG@?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?$AA@
  00113	6a 0a		 push	 10			; 0000000aH
  00115	8d 4c 24 5c	 lea	 ecx, DWORD PTR _setupModule$[esp+4712]
  00119	51		 push	 ecx
  0011a	8d 54 24 34	 lea	 edx, DWORD PTR _ro$[esp+4716]
  0011e	52		 push	 edx
  0011f	e8 00 00 00 00	 call	 ?ResourceRegister@CRegObject@ATL@@QAGJPB_WI0@Z ; ATL::CRegObject::ResourceRegister
  00124	3b c3		 cmp	 eax, ebx
  00126	7c 5a		 jl	 SHORT $LN1@RegisterCo
  00128	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__LoadTypeLib@8
  0012e	8d 44 24 10	 lea	 eax, DWORD PTR _tl$[esp+4704]
  00132	50		 push	 eax
  00133	8d 8c 24 60 02
	00 00		 lea	 ecx, DWORD PTR _mainModule$[esp+4708]
  0013a	51		 push	 ecx
  0013b	ff d7		 call	 edi
  0013d	3b c3		 cmp	 eax, ebx
  0013f	7c 41		 jl	 SHORT $LN1@RegisterCo
  00141	8b 44 24 10	 mov	 eax, DWORD PTR _tl$[esp+4704]
  00145	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__RegisterTypeLib@12
  0014b	53		 push	 ebx
  0014c	8d 94 24 60 02
	00 00		 lea	 edx, DWORD PTR _mainModule$[esp+4708]
  00153	52		 push	 edx
  00154	50		 push	 eax
  00155	ff d6		 call	 esi
  00157	3b c3		 cmp	 eax, ebx
  00159	7c 27		 jl	 SHORT $LN1@RegisterCo
  0015b	8d 4c 24 14	 lea	 ecx, DWORD PTR _tl2$[esp+4704]
  0015f	51		 push	 ecx
  00160	8d 94 24 60 0a
	00 00		 lea	 edx, DWORD PTR _formatModule$[esp+4708]
  00167	52		 push	 edx
  00168	ff d7		 call	 edi
  0016a	3b c3		 cmp	 eax, ebx
  0016c	7c 14		 jl	 SHORT $LN1@RegisterCo
  0016e	8b 4c 24 14	 mov	 ecx, DWORD PTR _tl2$[esp+4704]
  00172	53		 push	 ebx
  00173	8d 84 24 60 0a
	00 00		 lea	 eax, DWORD PTR _formatModule$[esp+4708]
  0017a	50		 push	 eax
  0017b	51		 push	 ecx
  0017c	ff d6		 call	 esi
  0017e	3b c3		 cmp	 eax, ebx
  00180	7d 58		 jge	 SHORT $LN2@RegisterCo
$LN1@RegisterCo:

; 54   : 	{
; 55   : 		MessageBox (MainDlg, _com_error (r).ErrorMessage(), TC_APP_NAME, MB_ICONERROR);

  00182	6a 10		 push	 16			; 00000010H
  00184	be 00 00 00 00	 mov	 esi, OFFSET ??_7_com_error@@6B@
  00189	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FEEFGEIL@CipherShed?$AA@
  0018e	8d 4c 24 20	 lea	 ecx, DWORD PTR $T112593[esp+4712]
  00192	89 74 24 20	 mov	 DWORD PTR $T112593[esp+4712], esi
  00196	89 44 24 24	 mov	 DWORD PTR $T112593[esp+4716], eax
  0019a	89 5c 24 28	 mov	 DWORD PTR $T112593[esp+4720], ebx
  0019e	89 5c 24 2c	 mov	 DWORD PTR $T112593[esp+4724], ebx
  001a2	e8 00 00 00 00	 call	 ?ErrorMessage@_com_error@@QBEPBDXZ ; _com_error::ErrorMessage
  001a7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  001ad	50		 push	 eax
  001ae	52		 push	 edx
  001af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  001b5	8b 44 24 20	 mov	 eax, DWORD PTR $T112593[esp+4712]
  001b9	89 74 24 18	 mov	 DWORD PTR $T112593[esp+4704], esi
  001bd	3b c3		 cmp	 eax, ebx
  001bf	74 08		 je	 SHORT $LN42@RegisterCo
  001c1	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c3	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  001c6	50		 push	 eax
  001c7	ff d2		 call	 edx
$LN42@RegisterCo:
  001c9	8b 44 24 24	 mov	 eax, DWORD PTR $T112593[esp+4716]
  001cd	3b c3		 cmp	 eax, ebx
  001cf	74 07		 je	 SHORT $LN41@RegisterCo
  001d1	50		 push	 eax
  001d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalFree@4
$LN41@RegisterCo:

; 56   : 		ret = FALSE;

  001d8	33 ed		 xor	 ebp, ebp
$LN2@RegisterCo:

; 57   : 	}
; 58   : 
; 59   : 	ro.FinalRelease ();
; 60   : 	return ret;

  001da	8d 4c 24 28	 lea	 ecx, DWORD PTR _ro$[esp+4704]
  001de	e8 00 00 00 00	 call	 ??1CRegObject@ATL@@UAE@XZ ; ATL::CRegObject::~CRegObject
  001e3	8b 44 24 14	 mov	 eax, DWORD PTR _tl2$[esp+4704]
  001e7	3b c3		 cmp	 eax, ebx
  001e9	74 08		 je	 SHORT $LN49@RegisterCo
  001eb	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ed	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  001f0	50		 push	 eax
  001f1	ff d2		 call	 edx
$LN49@RegisterCo:
  001f3	8b 44 24 10	 mov	 eax, DWORD PTR _tl$[esp+4704]
  001f7	3b c3		 cmp	 eax, ebx
  001f9	74 08		 je	 SHORT $LN57@RegisterCo
  001fb	8b 08		 mov	 ecx, DWORD PTR [eax]
  001fd	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00200	50		 push	 eax
  00201	ff d2		 call	 edx
$LN57@RegisterCo:

; 61   : }

  00203	8b 8c 24 5c 12
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+4704]
  0020a	5f		 pop	 edi
  0020b	5e		 pop	 esi
  0020c	8b c5		 mov	 eax, ebp
  0020e	5d		 pop	 ebp
  0020f	5b		 pop	 ebx
  00210	33 cc		 xor	 ecx, esp
  00212	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00217	81 c4 50 12 00
	00		 add	 esp, 4688		; 00001250H
  0021d	c3		 ret	 0
_RegisterComServers ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_UnregisterComServers
; Function compile flags: /Ogtpy
;	COMDAT _UnregisterComServers
_TEXT	SEGMENT
_ro$ = -2616						; size = 44
_setupModule$ = -2572					; size = 520
_module$ = -2052					; size = 2048
__$ArrayPad$ = -4					; size = 4
_modulePath$ = 8					; size = 4
_UnregisterComServers PROC				; COMDAT

; 65   : {

  00000	81 ec 38 0a 00
	00		 sub	 esp, 2616		; 00000a38H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 34 0a
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+2616], eax
  00014	53		 push	 ebx
  00015	56		 push	 esi

; 66   : 	BOOL ret;
; 67   : 
; 68   : 	if (UnRegisterTypeLib (LIBID_CipherShedMainCom, TC_MAIN_COM_VERSION_MAJOR, TC_MAIN_COM_VERSION_MINOR, 0, SYS_WIN32) != S_OK)

  00016	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__UnRegisterTypeLib@20
  0001c	57		 push	 edi
  0001d	8b bc 24 48 0a
	00 00		 mov	 edi, DWORD PTR _modulePath$[esp+2624]
  00024	6a 01		 push	 1
  00026	33 db		 xor	 ebx, ebx
  00028	53		 push	 ebx
  00029	6a 04		 push	 4
  0002b	6a 02		 push	 2
  0002d	68 00 00 00 00	 push	 OFFSET _LIBID_CipherShedMainCom
  00032	ff d6		 call	 esi
  00034	85 c0		 test	 eax, eax
  00036	74 1a		 je	 SHORT $LN2@Unregister
$LN24@Unregister:
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi

; 69   : 		return FALSE;

  0003a	33 c0		 xor	 eax, eax
  0003c	5b		 pop	 ebx

; 94   : }

  0003d	8b 8c 24 34 0a
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+2616]
  00044	33 cc		 xor	 ecx, esp
  00046	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004b	81 c4 38 0a 00
	00		 add	 esp, 2616		; 00000a38H
  00051	c3		 ret	 0
$LN2@Unregister:

; 70   : 	if (UnRegisterTypeLib (LIBID_CipherShedFormatCom, TC_FORMAT_COM_VERSION_MAJOR, TC_FORMAT_COM_VERSION_MINOR, 0, SYS_WIN32) != S_OK)

  00052	6a 01		 push	 1
  00054	53		 push	 ebx
  00055	6a 04		 push	 4
  00057	6a 02		 push	 2
  00059	68 00 00 00 00	 push	 OFFSET _LIBID_CipherShedFormatCom
  0005e	ff d6		 call	 esi
  00060	85 c0		 test	 eax, eax

; 71   : 		return FALSE;

  00062	75 d4		 jne	 SHORT $LN24@Unregister

; 72   : 
; 73   : 	wchar_t module[1024];
; 74   : 	CRegObject ro;
; 75   : 
; 76   : 	/* Init. */
; 77   : 	ro.FinalConstruct ();

  00064	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ro$[esp+2644]
  00068	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _ro$[esp+2628], OFFSET ??_7CRegObject@ATL@@6B@
  00070	89 5c 24 10	 mov	 DWORD PTR _ro$[esp+2632], ebx
  00074	89 5c 24 14	 mov	 DWORD PTR _ro$[esp+2636], ebx
  00078	89 5c 24 18	 mov	 DWORD PTR _ro$[esp+2640], ebx
  0007c	89 44 24 1c	 mov	 DWORD PTR _ro$[esp+2644], eax
  00080	89 44 24 20	 mov	 DWORD PTR _ro$[esp+2648], eax
  00084	89 44 24 24	 mov	 DWORD PTR _ro$[esp+2652], eax
  00088	89 44 24 28	 mov	 DWORD PTR _ro$[esp+2656], eax
  0008c	89 44 24 2c	 mov	 DWORD PTR _ro$[esp+2660], eax
  00090	89 44 24 30	 mov	 DWORD PTR _ro$[esp+2664], eax
  00094	88 5c 24 34	 mov	 BYTE PTR _ro$[esp+2668], bl
  00098	e8 00 00 00 00	 call	 ?Init@CComCriticalSection@ATL@@QAEJXZ ; ATL::CComCriticalSection::Init
  0009d	85 c0		 test	 eax, eax
  0009f	7c 05		 jl	 SHORT $LN19@Unregister
  000a1	c6 44 24 34 01	 mov	 BYTE PTR _ro$[esp+2668], 1
$LN19@Unregister:

; 78   : 
; 79   : 	/* Replaceable parameters. */
; 80   : 	wsprintfW (module, L"%hsCipherShed.exe", modulePath);

  000a6	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__wsprintfW
  000ac	57		 push	 edi
  000ad	8d 84 24 44 02
	00 00		 lea	 eax, DWORD PTR _module$[esp+2632]
  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_1CE@EBKOGEKF@?$AA?$CF?$AAh?$AAs?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AA?4?$AAe?$AAx?$AAe?$AA?$AA@
  000b9	50		 push	 eax
  000ba	ff d6		 call	 esi
  000bc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 81   : 	ro.AddReplacement (L"MAIN_MODULE", module);

  000bf	8d 8c 24 40 02
	00 00		 lea	 ecx, DWORD PTR _module$[esp+2628]
  000c6	51		 push	 ecx
  000c7	68 00 00 00 00	 push	 OFFSET ??_C@_1BI@FPIOFILF@?$AAM?$AAA?$AAI?$AAN?$AA_?$AAM?$AAO?$AAD?$AAU?$AAL?$AAE?$AA?$AA@
  000cc	8d 54 24 14	 lea	 edx, DWORD PTR _ro$[esp+2636]
  000d0	52		 push	 edx
  000d1	e8 00 00 00 00	 call	 ?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z ; ATL::CRegObject::AddReplacement

; 82   : 
; 83   : 	wsprintfW (module, L"%hsCipherShed Format.exe", modulePath);

  000d6	57		 push	 edi
  000d7	8d 84 24 44 02
	00 00		 lea	 eax, DWORD PTR _module$[esp+2632]
  000de	68 00 00 00 00	 push	 OFFSET ??_C@_1DC@LLKEOMDK@?$AA?$CF?$AAh?$AAs?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AA?5?$AAF?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?4?$AAe?$AAx?$AAe?$AA?$AA@
  000e3	50		 push	 eax
  000e4	ff d6		 call	 esi
  000e6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 84   : 	ro.AddReplacement (L"FORMAT_MODULE", module);

  000e9	8d 8c 24 40 02
	00 00		 lea	 ecx, DWORD PTR _module$[esp+2628]
  000f0	51		 push	 ecx
  000f1	68 00 00 00 00	 push	 OFFSET ??_C@_1BM@IFKNBDBK@?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAM?$AAO?$AAD?$AAU?$AAL?$AAE?$AA?$AA@
  000f6	8d 54 24 14	 lea	 edx, DWORD PTR _ro$[esp+2636]
  000fa	52		 push	 edx
  000fb	e8 00 00 00 00	 call	 ?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z ; ATL::CRegObject::AddReplacement

; 85   : 
; 86   : 	wchar_t setupModule[MAX_PATH];
; 87   : 	GetModuleFileNameW (NULL, setupModule, sizeof (setupModule) / sizeof (setupModule[0]));

  00100	68 04 01 00 00	 push	 260			; 00000104H
  00105	8d 44 24 3c	 lea	 eax, DWORD PTR _setupModule$[esp+2632]
  00109	50		 push	 eax
  0010a	53		 push	 ebx
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameW@12

; 88   : 
; 89   : 	/* Unregister ComSetup.rgs */
; 90   : 	ret = ro.ResourceUnregister (setupModule, IDR_COMREG, L"REGISTRY") == S_OK;

  00111	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@KAILKFFG@?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?$AA@
  00116	6a 0a		 push	 10			; 0000000aH
  00118	8d 4c 24 40	 lea	 ecx, DWORD PTR _setupModule$[esp+2636]
  0011c	51		 push	 ecx
  0011d	8d 54 24 18	 lea	 edx, DWORD PTR _ro$[esp+2640]
  00121	52		 push	 edx
  00122	e8 00 00 00 00	 call	 ?ResourceUnregister@CRegObject@ATL@@QAGJPB_WI0@Z ; ATL::CRegObject::ResourceUnregister
  00127	8b f0		 mov	 esi, eax
  00129	f7 de		 neg	 esi
  0012b	1b f6		 sbb	 esi, esi

; 91   : 
; 92   : 	ro.FinalRelease ();
; 93   : 	return ret;

  0012d	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ro$[esp+2628]
  00131	46		 inc	 esi
  00132	e8 00 00 00 00	 call	 ??1CRegObject@ATL@@UAE@XZ ; ATL::CRegObject::~CRegObject

; 94   : }

  00137	8b 8c 24 40 0a
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+2628]
  0013e	5f		 pop	 edi
  0013f	8b c6		 mov	 eax, esi
  00141	5e		 pop	 esi
  00142	5b		 pop	 ebx
  00143	33 cc		 xor	 ecx, esp
  00145	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014a	81 c4 38 0a 00
	00		 add	 esp, 2616		; 00000a38H
  00150	c3		 ret	 0
_UnregisterComServers ENDP
_TEXT	ENDS
PUBLIC	?clash@Define_the_symbol__ATL_MIXED@@3UThank_you@1@A ; Define_the_symbol__ATL_MIXED::clash
;	COMDAT ?clash@Define_the_symbol__ATL_MIXED@@3UThank_you@1@A
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atldef.h
_DATA	SEGMENT
?clash@Define_the_symbol__ATL_MIXED@@3UThank_you@1@A DD FLAT:??_7Thank_you@Define_the_symbol__ATL_MIXED@@6B@ ; Define_the_symbol__ATL_MIXED::clash
_DATA	ENDS
PUBLIC	?clash@Inconsistent_definition_of_symbol__ATL_MIXED@@3U_Please_define_it_the_same_throughout_your_project@1@A ; Inconsistent_definition_of_symbol__ATL_MIXED::clash
;	COMDAT ?clash@Inconsistent_definition_of_symbol__ATL_MIXED@@3U_Please_define_it_the_same_throughout_your_project@1@A
_BSS	SEGMENT
?clash@Inconsistent_definition_of_symbol__ATL_MIXED@@3U_Please_define_it_the_same_throughout_your_project@1@A DB 01H DUP (?) ; Inconsistent_definition_of_symbol__ATL_MIXED::clash
_BSS	ENDS
END
