; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\home\public\Desktop\projects\ciphershed.build\src\Setup\SelfExtract.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@KMEHMKJJ@truecrypt?9x64?4sys?$AA@	; `string'
PUBLIC	??_C@_0O@OJENBJKN@truecrypt?4sys?$AA@		; `string'
PUBLIC	??_C@_0BG@NHCNJMON@CipherShed?5Format?4exe?$AA@	; `string'
PUBLIC	??_C@_0P@KEOPEMDF@CipherShed?4exe?$AA@		; `string'
PUBLIC	??_C@_0M@HNDLNFKG@License?4txt?$AA@		; `string'
PUBLIC	??_C@_0BK@LMECBCPP@CipherShed?5User?5Guide?4pdf?$AA@ ; `string'
PUBLIC	??_C@_0BG@PCIEDLBB@ACipherShed?5Setup?4exe?$AA@	; `string'
PUBLIC	??_C@_0P@KPKCHNJD@Dtruecrypt?4sys?$AA@		; `string'
PUBLIC	??_C@_0BD@ILLOKAML@Atruecrypt?9x64?4sys?$AA@	; `string'
PUBLIC	??_C@_0P@JMCFMDBI@Atruecrypt?4sys?$AA@		; `string'
PUBLIC	??_C@_0BH@JDBNPKKN@ACipherShed?5Format?4exe?$AA@ ; `string'
PUBLIC	??_C@_0BA@BPJBGDOM@ACipherShed?4exe?$AA@	; `string'
PUBLIC	??_C@_0N@GJIBBNGF@ALicense?4txt?$AA@		; `string'
PUBLIC	??_C@_0BL@MFPLEOCK@ACipherShed?5User?5Guide?4pdf?$AA@ ; `string'
PUBLIC	_PipeWriteBuf
PUBLIC	_hChildStdinWrite
PUBLIC	_DecompressedData
_DATA	SEGMENT
COMM	_DestExtractPath:BYTE:0104H
COMM	_MagEndMarker:BYTE:010H
COMM	_Decompressed_Files:BYTE:078H
_DATA	ENDS
_BSS	SEGMENT
_PipeWriteBuf DD 01H DUP (?)
_DecompressedData DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BC@KMEHMKJJ@truecrypt?9x64?4sys?$AA@
CONST	SEGMENT
??_C@_0BC@KMEHMKJJ@truecrypt?9x64?4sys?$AA@ DB 'truecrypt-x64.sys', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OJENBJKN@truecrypt?4sys?$AA@
CONST	SEGMENT
??_C@_0O@OJENBJKN@truecrypt?4sys?$AA@ DB 'truecrypt.sys', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NHCNJMON@CipherShed?5Format?4exe?$AA@
CONST	SEGMENT
??_C@_0BG@NHCNJMON@CipherShed?5Format?4exe?$AA@ DB 'CipherShed Format.exe'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KEOPEMDF@CipherShed?4exe?$AA@
CONST	SEGMENT
??_C@_0P@KEOPEMDF@CipherShed?4exe?$AA@ DB 'CipherShed.exe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HNDLNFKG@License?4txt?$AA@
CONST	SEGMENT
??_C@_0M@HNDLNFKG@License?4txt?$AA@ DB 'License.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LMECBCPP@CipherShed?5User?5Guide?4pdf?$AA@
CONST	SEGMENT
??_C@_0BK@LMECBCPP@CipherShed?5User?5Guide?4pdf?$AA@ DB 'CipherShed User '
	DB	'Guide.pdf', 00H				; `string'
CONST	ENDS
_DATA	SEGMENT
_szFiles DD	FLAT:??_C@_0BL@MFPLEOCK@ACipherShed?5User?5Guide?4pdf?$AA@
	DD	FLAT:??_C@_0N@GJIBBNGF@ALicense?4txt?$AA@
	DD	FLAT:??_C@_0BA@BPJBGDOM@ACipherShed?4exe?$AA@
	DD	FLAT:??_C@_0BH@JDBNPKKN@ACipherShed?5Format?4exe?$AA@
	DD	FLAT:??_C@_0P@JMCFMDBI@Atruecrypt?4sys?$AA@
	DD	FLAT:??_C@_0BD@ILLOKAML@Atruecrypt?9x64?4sys?$AA@
	DD	FLAT:??_C@_0P@KPKCHNJD@Dtruecrypt?4sys?$AA@
	DD	FLAT:??_C@_0BG@PCIEDLBB@ACipherShed?5Setup?4exe?$AA@
_szCompressedFiles DD FLAT:??_C@_0BK@LMECBCPP@CipherShed?5User?5Guide?4pdf?$AA@
	DD	FLAT:??_C@_0M@HNDLNFKG@License?4txt?$AA@
	DD	FLAT:??_C@_0P@KEOPEMDF@CipherShed?4exe?$AA@
	DD	FLAT:??_C@_0BG@NHCNJMON@CipherShed?5Format?4exe?$AA@
	DD	FLAT:??_C@_0O@OJENBJKN@truecrypt?4sys?$AA@
	DD	FLAT:??_C@_0BC@KMEHMKJJ@truecrypt?9x64?4sys?$AA@
_hChildStdinWrite DD 0ffffffffH
_DATA	ENDS
;	COMDAT ??_C@_0BG@PCIEDLBB@ACipherShed?5Setup?4exe?$AA@
CONST	SEGMENT
??_C@_0BG@PCIEDLBB@ACipherShed?5Setup?4exe?$AA@ DB 'ACipherShed Setup.exe'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KPKCHNJD@Dtruecrypt?4sys?$AA@
CONST	SEGMENT
??_C@_0P@KPKCHNJD@Dtruecrypt?4sys?$AA@ DB 'Dtruecrypt.sys', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@ILLOKAML@Atruecrypt?9x64?4sys?$AA@
CONST	SEGMENT
??_C@_0BD@ILLOKAML@Atruecrypt?9x64?4sys?$AA@ DB 'Atruecrypt-x64.sys', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JMCFMDBI@Atruecrypt?4sys?$AA@
CONST	SEGMENT
??_C@_0P@JMCFMDBI@Atruecrypt?4sys?$AA@ DB 'Atruecrypt.sys', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JDBNPKKN@ACipherShed?5Format?4exe?$AA@
CONST	SEGMENT
??_C@_0BH@JDBNPKKN@ACipherShed?5Format?4exe?$AA@ DB 'ACipherShed Format.e'
	DB	'xe', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BPJBGDOM@ACipherShed?4exe?$AA@
CONST	SEGMENT
??_C@_0BA@BPJBGDOM@ACipherShed?4exe?$AA@ DB 'ACipherShed.exe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GJIBBNGF@ALicense?4txt?$AA@
CONST	SEGMENT
??_C@_0N@GJIBBNGF@ALicense?4txt?$AA@ DB 'ALicense.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MFPLEOCK@ACipherShed?5User?5Guide?4pdf?$AA@
CONST	SEGMENT
??_C@_0BL@MFPLEOCK@ACipherShed?5User?5Guide?4pdf?$AA@ DB 'ACipherShed Use'
	DB	'r Guide.pdf', 00H				; `string'
CONST	ENDS
PUBLIC	??_C@_0BA@LOGCKKME@T?1C?1I?1N?1S?1C?1R?1C?$AA@	; `string'
;	COMDAT ??_C@_0BA@LOGCKKME@T?1C?1I?1N?1S?1C?1R?1C?$AA@
; File c:\home\public\desktop\projects\ciphershed.build\src\setup\selfextract.c
CONST	SEGMENT
??_C@_0BA@LOGCKKME@T?1C?1I?1N?1S?1C?1R?1C?$AA@ DB 'T/C/I/N/S/C/R/C', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _DeobfuscateMagEndMarker
_TEXT	SEGMENT
_DeobfuscateMagEndMarker PROC				; COMDAT

; 49   : 	int i;
; 50   : 
; 51   : 	for (i = 0; i < sizeof (MAG_END_MARKER_OBFUSCATED); i += 2)

  00000	33 c0		 xor	 eax, eax
$LL3@Deobfuscat:

; 52   : 		MagEndMarker [i/2] = MAG_END_MARKER_OBFUSCATED [i];

  00002	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR ??_C@_0BA@LOGCKKME@T?1C?1I?1N?1S?1C?1R?1C?$AA@[eax]
  00008	8b c8		 mov	 ecx, eax
  0000a	d1 e9		 shr	 ecx, 1
  0000c	83 c0 02	 add	 eax, 2
  0000f	88 91 00 00 00
	00		 mov	 BYTE PTR _MagEndMarker[ecx], dl
  00015	83 f8 10	 cmp	 eax, 16			; 00000010H
  00018	72 e8		 jb	 SHORT $LL3@Deobfuscat

; 53   : 
; 54   : 	MagEndMarker [i/2] = 0;

  0001a	99		 cdq
  0001b	2b c2		 sub	 eax, edx
  0001d	d1 f8		 sar	 eax, 1
  0001f	c6 80 00 00 00
	00 00		 mov	 BYTE PTR _MagEndMarker[eax], 0

; 55   : }

  00026	c3		 ret	 0
_DeobfuscateMagEndMarker ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@FEEFGEIL@CipherShed?$AA@		; `string'
EXTRN	__imp__MessageBoxA@16:PROC
;	COMDAT ??_C@_0L@FEEFGEIL@CipherShed?$AA@
CONST	SEGMENT
??_C@_0L@FEEFGEIL@CipherShed?$AA@ DB 'CipherShed', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PkgError
_TEXT	SEGMENT
_PkgError PROC						; COMDAT
; _msg$ = eax

; 60   : 	MessageBox (NULL, msg, "CipherShed", MB_ICONERROR | MB_SETFOREGROUND | MB_TOPMOST);

  00000	68 10 00 05 00	 push	 327696			; 00050010H
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FEEFGEIL@CipherShed?$AA@
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 61   : }

  00013	c3		 ret	 0
_PkgError ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _PkgInfo
_TEXT	SEGMENT
_PkgInfo PROC						; COMDAT
; _msg$ = eax

; 72   : 	MessageBox (NULL, msg, "CipherShed", MB_ICONINFORMATION | MB_SETFOREGROUND | MB_TOPMOST);

  00000	68 40 00 05 00	 push	 327744			; 00050040H
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FEEFGEIL@CipherShed?$AA@
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 73   : }

  00013	c3		 ret	 0
_PkgInfo ENDP
_TEXT	ENDS
EXTRN	_DecompressDeflatedData:PROC
; Function compile flags: /Ogtpy
;	COMDAT _DecompressBuffer
_TEXT	SEGMENT
_DecompressBuffer PROC					; COMDAT
; _out$ = edx
; _in$ = ecx
; _len$ = eax

; 79   : 	return (DecompressDeflatedData (out, in, len));		// Inflate

  00000	50		 push	 eax
  00001	51		 push	 ecx
  00002	52		 push	 edx
  00003	e8 00 00 00 00	 call	 _DecompressDeflatedData
  00008	83 c4 0c	 add	 esp, 12			; 0000000cH

; 80   : }

  0000b	c3		 ret	 0
_DecompressBuffer ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@GGPNKNGJ@Failed?5sending?5data?5to?5the?5STDIN@ ; `string'
PUBLIC	??_C@_0BC@LMFKNEDD@Cannot?5close?5pipe?$AA@	; `string'
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__WriteFile@20:PROC
;	COMDAT ??_C@_0CG@GGPNKNGJ@Failed?5sending?5data?5to?5the?5STDIN@
CONST	SEGMENT
??_C@_0CG@GGPNKNGJ@Failed?5sending?5data?5to?5the?5STDIN@ DB 'Failed send'
	DB	'ing data to the STDIN pipe', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LMFKNEDD@Cannot?5close?5pipe?$AA@
CONST	SEGMENT
??_C@_0BC@LMFKNEDD@Cannot?5close?5pipe?$AA@ DB 'Cannot close pipe', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PipeWriteThread
_TEXT	SEGMENT
_bytesSent$ = -4					; size = 4
_len$ = 8						; size = 4
_PipeWriteThread PROC					; COMDAT

; 84   : {

  00000	51		 push	 ecx

; 85   : 	int sendBufSize = PIPE_BUFFER_LEN, bytesSent = 0;
; 86   : 	int bytesToSend = *((int *) len), bytesSentTotal = 0;

  00001	8b 44 24 08	 mov	 eax, DWORD PTR _len$[esp]
  00005	53		 push	 ebx
  00006	56		 push	 esi
  00007	8b 30		 mov	 esi, DWORD PTR [eax]
  00009	57		 push	 edi
  0000a	33 ff		 xor	 edi, edi
  0000c	bb 00 10 00 00	 mov	 ebx, 4096		; 00001000H
  00011	89 7c 24 0c	 mov	 DWORD PTR _bytesSent$[esp+16], edi

; 87   : 
; 88   : 	if (PipeWriteBuf == NULL || (HANDLE) hChildStdinWrite == INVALID_HANDLE_VALUE)

  00015	39 3d 00 00 00
	00		 cmp	 DWORD PTR _PipeWriteBuf, edi
  0001b	0f 84 98 00 00
	00		 je	 $LN7@PipeWriteT
  00021	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hChildStdinWrite
  00027	83 f9 ff	 cmp	 ecx, -1
  0002a	0f 84 89 00 00
	00		 je	 $LN7@PipeWriteT

; 91   : 		return;
; 92   : 	}
; 93   : 
; 94   : 	while (bytesToSend > 0) 

  00030	3b f7		 cmp	 esi, edi
  00032	55		 push	 ebp
  00033	7e 46		 jle	 SHORT $LN5@PipeWriteT
  00035	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__WriteFile@20
  0003b	eb 03 8d 49 00	 npad	 5
$LL6@PipeWriteT:

; 95   : 	{ 
; 96   : 		if (bytesToSend < PIPE_BUFFER_LEN)

  00040	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  00046	7d 02		 jge	 SHORT $LN4@PipeWriteT

; 97   : 			sendBufSize = bytesToSend;

  00048	8b de		 mov	 ebx, esi
$LN4@PipeWriteT:

; 98   : 
; 99   : 		if (!WriteFile ((HANDLE) hChildStdinWrite, (char *) PipeWriteBuf + bytesSentTotal, sendBufSize, &bytesSent, NULL) 
; 100  : 			|| bytesSent == 0
; 101  : 			|| bytesSent != sendBufSize) 

  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR _PipeWriteBuf
  0004f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hChildStdinWrite
  00055	6a 00		 push	 0
  00057	8d 54 24 14	 lea	 edx, DWORD PTR _bytesSent$[esp+24]
  0005b	52		 push	 edx
  0005c	53		 push	 ebx
  0005d	03 c7		 add	 eax, edi
  0005f	50		 push	 eax
  00060	51		 push	 ecx
  00061	ff d5		 call	 ebp
  00063	85 c0		 test	 eax, eax
  00065	74 35		 je	 SHORT $LN19@PipeWriteT
  00067	8b 44 24 10	 mov	 eax, DWORD PTR _bytesSent$[esp+20]
  0006b	85 c0		 test	 eax, eax
  0006d	74 2d		 je	 SHORT $LN19@PipeWriteT
  0006f	3b c3		 cmp	 eax, ebx
  00071	75 29		 jne	 SHORT $LN19@PipeWriteT

; 104  : 			return;
; 105  : 		}
; 106  : 
; 107  : 		bytesToSend -= bytesSent;

  00073	2b f0		 sub	 esi, eax

; 108  : 		bytesSentTotal += bytesSent;

  00075	03 f8		 add	 edi, eax
  00077	85 f6		 test	 esi, esi
  00079	7f c5		 jg	 SHORT $LL6@PipeWriteT
$LN5@PipeWriteT:

; 109  : 	}
; 110  : 
; 111  : 	// Closing the pipe causes the child process to stop reading from it
; 112  : 
; 113  : 	if (!CloseHandle (hChildStdinWrite))

  0007b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hChildStdinWrite
  00081	52		 push	 edx
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  00088	85 c0		 test	 eax, eax
  0008a	75 0a		 jne	 SHORT $LN20@PipeWriteT

; 114  : 	{
; 115  : 		PkgError ("Cannot close pipe"); 

  0008c	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@LMFKNEDD@Cannot?5close?5pipe?$AA@
  00091	e8 00 00 00 00	 call	 _PkgError
$LN20@PipeWriteT:
  00096	5d		 pop	 ebp
  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
  00099	5b		 pop	 ebx

; 116  : 		return;
; 117  : 	}
; 118  : }

  0009a	59		 pop	 ecx
  0009b	c3		 ret	 0
$LN19@PipeWriteT:

; 102  : 		{
; 103  : 			PkgError ("Failed sending data to the STDIN pipe"); 

  0009c	68 10 00 05 00	 push	 327696			; 00050010H
  000a1	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FEEFGEIL@CipherShed?$AA@
  000a6	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@GGPNKNGJ@Failed?5sending?5data?5to?5the?5STDIN@
  000ab	6a 00		 push	 0
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  000b3	5d		 pop	 ebp
  000b4	5f		 pop	 edi
  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx

; 116  : 		return;
; 117  : 	}
; 118  : }

  000b7	59		 pop	 ecx
  000b8	c3		 ret	 0
$LN7@PipeWriteT:

; 89   : 	{
; 90   : 		PkgError ("Failed sending data to the STDIN pipe"); 

  000b9	68 10 00 05 00	 push	 327696			; 00050010H
  000be	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FEEFGEIL@CipherShed?$AA@
  000c3	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@GGPNKNGJ@Failed?5sending?5data?5to?5the?5STDIN@
  000c8	57		 push	 edi
  000c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  000cf	5f		 pop	 edi
  000d0	5e		 pop	 esi
  000d1	5b		 pop	 ebx

; 116  : 		return;
; 117  : 	}
; 118  : }

  000d2	59		 pop	 ecx
  000d3	c3		 ret	 0
_PipeWriteThread ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@NGGPKPLC@Cannot?5close?5STDOUT?5write?$AA@ ; `string'
PUBLIC	??_C@_0BCL@DAKFJLFE@Error?3?5Cannot?5run?5gzip?4?6?6Before?5@ ; `string'
PUBLIC	??_C@_0M@HPMDPAK@gzip?5?9?9best?$AA@		; `string'
PUBLIC	??_C@_0BK@CBLLHDHE@Cannot?5create?5STDIN?5pipe?4?$AA@ ; `string'
PUBLIC	??_C@_0BL@CGCLLOGA@Cannot?5create?5STDOUT?5pipe?4?$AA@ ; `string'
PUBLIC	_out$GSCopy$
PUBLIC	__$ArrayPad$
EXTRN	__imp__ReadFile@20:PROC
EXTRN	__beginthread:PROC
EXTRN	__imp__CreateProcessA@40:PROC
EXTRN	__imp__SetHandleInformation@12:PROC
EXTRN	__imp__CreatePipe@16:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_0BK@NGGPKPLC@Cannot?5close?5STDOUT?5write?$AA@
CONST	SEGMENT
??_C@_0BK@NGGPKPLC@Cannot?5close?5STDOUT?5write?$AA@ DB 'Cannot close STD'
	DB	'OUT write', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BCL@DAKFJLFE@Error?3?5Cannot?5run?5gzip?4?6?6Before?5@
CONST	SEGMENT
??_C@_0BCL@DAKFJLFE@Error?3?5Cannot?5run?5gzip?4?6?6Before?5@ DB 'Error: '
	DB	'Cannot run gzip.', 0aH, 0aH, 'Before you can create a self-ex'
	DB	'tracting CipherShed package, you need to have the open-source'
	DB	' ''gzip'' compression tool placed in any directory in the sea'
	DB	'rch path for executable files (for example, in ''C:\Windows\'''
	DB	').', 0aH, 0aH, 'Note: gzip can be freely downloaded e.g. from'
	DB	' www.gzip.org', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HPMDPAK@gzip?5?9?9best?$AA@
CONST	SEGMENT
??_C@_0M@HPMDPAK@gzip?5?9?9best?$AA@ DB 'gzip --best', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CBLLHDHE@Cannot?5create?5STDIN?5pipe?4?$AA@
CONST	SEGMENT
??_C@_0BK@CBLLHDHE@Cannot?5create?5STDIN?5pipe?4?$AA@ DB 'Cannot create S'
	DB	'TDIN pipe.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CGCLLOGA@Cannot?5create?5STDOUT?5pipe?4?$AA@
CONST	SEGMENT
??_C@_0BL@CGCLLOGA@Cannot?5create?5STDOUT?5pipe?4?$AA@ DB 'Cannot create '
	DB	'STDOUT pipe.', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _CompressBuffer
_TEXT	SEGMENT
_hChildStdoutRead$ = -4224				; size = 4
_hChildStdoutWrite$ = -4220				; size = 4
_hChildStdinRead$ = -4216				; size = 4
_bytesReceived$ = -4212					; size = 4
_out$GSCopy$ = -4208					; size = 4
_procInfo$ = -4204					; size = 16
_securityAttrib$ = -4188				; size = 12
tv151 = -4176						; size = 8
_startupInfo$ = -4168					; size = 68
_pipeBuffer$ = -4100					; size = 4096
__$ArrayPad$ = -4					; size = 4
_out$ = 8						; size = 4
_in$ = 12						; size = 4
_len$ = 16						; size = 4
_CompressBuffer PROC					; COMDAT

; 123  : {

  00000	b8 80 10 00 00	 mov	 eax, 4224		; 00001080H
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000f	33 c4		 xor	 eax, esp
  00011	89 84 24 7c 10
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+4224], eax
  00018	8b 84 24 84 10
	00 00		 mov	 eax, DWORD PTR _out$[esp+4220]
  0001f	53		 push	 ebx
  00020	55		 push	 ebp
  00021	56		 push	 esi

; 124  : 	SECURITY_ATTRIBUTES securityAttrib; 
; 125  : 	DWORD bytesReceived = 0;

  00022	33 db		 xor	 ebx, ebx

; 126  : 	HANDLE hChildStdoutWrite = INVALID_HANDLE_VALUE;
; 127  : 	HANDLE hChildStdoutRead = INVALID_HANDLE_VALUE;
; 128  : 	HANDLE hChildStdinRead = INVALID_HANDLE_VALUE;
; 129  : 	STARTUPINFO startupInfo;
; 130  : 	PROCESS_INFORMATION procInfo; 
; 131  : 	char pipeBuffer [PIPE_BUFFER_LEN]; 
; 132  : 	int res_len = 0;
; 133  : 	BOOL bGzipHeaderRead = FALSE;
; 134  : 
; 135  : 	ZeroMemory (&startupInfo, sizeof (startupInfo));

  00024	6a 44		 push	 68			; 00000044H

; 201  : 	return res_len - 8;	// A gzip stream ends with a CRC-32 hash and a 32-bit size (those 8 bytes need to be chopped off)

  00026	89 44 24 20	 mov	 DWORD PTR _out$GSCopy$[esp+4240], eax
  0002a	83 c8 ff	 or	 eax, -1
  0002d	8d 4c 24 48	 lea	 ecx, DWORD PTR _startupInfo$[esp+4240]
  00031	53		 push	 ebx
  00032	51		 push	 ecx
  00033	89 5c 24 24	 mov	 DWORD PTR _bytesReceived$[esp+4248], ebx
  00037	89 44 24 1c	 mov	 DWORD PTR _hChildStdoutWrite$[esp+4248], eax
  0003b	89 44 24 18	 mov	 DWORD PTR _hChildStdoutRead$[esp+4248], eax
  0003f	89 44 24 20	 mov	 DWORD PTR _hChildStdinRead$[esp+4248], eax
  00043	33 ed		 xor	 ebp, ebp
  00045	e8 00 00 00 00	 call	 _memset
  0004a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CreatePipe@16
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	33 c0		 xor	 eax, eax
  00055	53		 push	 ebx
  00056	8d 54 24 34	 lea	 edx, DWORD PTR _securityAttrib$[esp+4240]
  0005a	89 44 24 24	 mov	 DWORD PTR _procInfo$[esp+4240], eax
  0005e	89 44 24 28	 mov	 DWORD PTR _procInfo$[esp+4244], eax
  00062	89 44 24 2c	 mov	 DWORD PTR _procInfo$[esp+4248], eax
  00066	89 44 24 30	 mov	 DWORD PTR _procInfo$[esp+4252], eax
  0006a	52		 push	 edx
  0006b	8d 44 24 18	 lea	 eax, DWORD PTR _hChildStdoutWrite$[esp+4244]
  0006f	50		 push	 eax
  00070	8d 4c 24 18	 lea	 ecx, DWORD PTR _hChildStdoutRead$[esp+4248]
  00074	51		 push	 ecx
  00075	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR _securityAttrib$[esp+4260], 1
  0007d	c7 44 24 40 0c
	00 00 00	 mov	 DWORD PTR _securityAttrib$[esp+4252], 12 ; 0000000cH
  00085	89 5c 24 44	 mov	 DWORD PTR _securityAttrib$[esp+4256], ebx
  00089	ff d6		 call	 esi
  0008b	85 c0		 test	 eax, eax
  0008d	75 30		 jne	 SHORT $LN9@CompressBu
  0008f	68 10 00 05 00	 push	 327696			; 00050010H
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FEEFGEIL@CipherShed?$AA@
  00099	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@CGCLLOGA@Cannot?5create?5STDOUT?5pipe?4?$AA@
  0009e	53		 push	 ebx
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  000a5	5e		 pop	 esi
  000a6	5d		 pop	 ebp
  000a7	33 c0		 xor	 eax, eax
  000a9	5b		 pop	 ebx

; 202  : }

  000aa	8b 8c 24 7c 10
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+4224]
  000b1	33 cc		 xor	 ecx, esp
  000b3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b8	81 c4 80 10 00
	00		 add	 esp, 4224		; 00001080H
  000be	c3		 ret	 0
$LN9@CompressBu:

; 136  : 	ZeroMemory (&procInfo, sizeof (procInfo));
; 137  : 
; 138  : 	// Pipe handle inheritance
; 139  : 	securityAttrib.bInheritHandle = TRUE; 
; 140  : 	securityAttrib.nLength = sizeof (securityAttrib); 
; 141  : 	securityAttrib.lpSecurityDescriptor = NULL; 
; 142  : 
; 143  : 	if (!CreatePipe (&hChildStdoutRead, &hChildStdoutWrite, &securityAttrib, 0))
; 144  : 	{
; 145  : 		PkgError ("Cannot create STDOUT pipe."); 
; 146  : 		return 0;
; 147  : 	}
; 148  : 	SetHandleInformation (hChildStdoutRead, HANDLE_FLAG_INHERIT, 0);

  000bf	8b 54 24 0c	 mov	 edx, DWORD PTR _hChildStdoutRead$[esp+4236]
  000c3	57		 push	 edi
  000c4	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__SetHandleInformation@12
  000ca	53		 push	 ebx
  000cb	6a 01		 push	 1
  000cd	52		 push	 edx
  000ce	ff d7		 call	 edi

; 149  : 
; 150  : 	if (!CreatePipe (&hChildStdinRead, &((HANDLE) hChildStdinWrite), &securityAttrib, 0))

  000d0	53		 push	 ebx
  000d1	8d 44 24 38	 lea	 eax, DWORD PTR _securityAttrib$[esp+4244]
  000d5	50		 push	 eax
  000d6	68 00 00 00 00	 push	 OFFSET _hChildStdinWrite
  000db	8d 4c 24 24	 lea	 ecx, DWORD PTR _hChildStdinRead$[esp+4252]
  000df	51		 push	 ecx
  000e0	ff d6		 call	 esi
  000e2	85 c0		 test	 eax, eax
  000e4	75 1d		 jne	 SHORT $LN8@CompressBu

; 151  : 	{
; 152  : 		PkgError ("Cannot create STDIN pipe.");

  000e6	68 10 00 05 00	 push	 327696			; 00050010H
  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FEEFGEIL@CipherShed?$AA@
  000f0	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@CBLLHDHE@Cannot?5create?5STDIN?5pipe?4?$AA@
  000f5	53		 push	 ebx
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 153  : 		return 0;

  000fc	33 c0		 xor	 eax, eax
  000fe	e9 3d 01 00 00	 jmp	 $LN25@CompressBu
$LN8@CompressBu:

; 154  : 	}
; 155  : 	SetHandleInformation (hChildStdinWrite, HANDLE_FLAG_INHERIT, 0);

  00103	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hChildStdinWrite
  00109	53		 push	 ebx
  0010a	6a 01		 push	 1
  0010c	52		 push	 edx
  0010d	ff d7		 call	 edi

; 156  : 
; 157  : 	// Create a child process that will compress the data
; 158  : 
; 159  : 	startupInfo.wShowWindow = SW_HIDE;
; 160  : 	startupInfo.hStdInput = hChildStdinRead;

  0010f	8b 4c 24 18	 mov	 ecx, DWORD PTR _hChildStdinRead$[esp+4240]

; 161  : 	startupInfo.hStdOutput = hChildStdoutWrite;
; 162  : 	startupInfo.cb = sizeof (startupInfo); 
; 163  : 	startupInfo.hStdError = hChildStdoutWrite;
; 164  : 	startupInfo.dwFlags |= STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;

  00113	81 4c 24 74 01
	01 00 00	 or	 DWORD PTR _startupInfo$[esp+4284], 257 ; 00000101H
  0011b	33 c0		 xor	 eax, eax
  0011d	66 89 44 24 78	 mov	 WORD PTR _startupInfo$[esp+4288], ax
  00122	8b 44 24 14	 mov	 eax, DWORD PTR _hChildStdoutWrite$[esp+4240]

; 165  : 
; 166  : 	if (!CreateProcess (NULL, "gzip --best", NULL, NULL, TRUE, 0, NULL, NULL, &startupInfo, &procInfo))

  00126	8d 54 24 24	 lea	 edx, DWORD PTR _procInfo$[esp+4240]
  0012a	52		 push	 edx
  0012b	89 84 24 88 00
	00 00		 mov	 DWORD PTR _startupInfo$[esp+4304], eax
  00132	89 84 24 8c 00
	00 00		 mov	 DWORD PTR _startupInfo$[esp+4308], eax
  00139	8d 44 24 4c	 lea	 eax, DWORD PTR _startupInfo$[esp+4244]
  0013d	50		 push	 eax
  0013e	53		 push	 ebx
  0013f	53		 push	 ebx
  00140	53		 push	 ebx
  00141	6a 01		 push	 1
  00143	53		 push	 ebx
  00144	53		 push	 ebx
  00145	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HPMDPAK@gzip?5?9?9best?$AA@
  0014a	53		 push	 ebx
  0014b	89 8c 24 a8 00
	00 00		 mov	 DWORD PTR _startupInfo$[esp+4336], ecx
  00152	c7 44 24 70 44
	00 00 00	 mov	 DWORD PTR _startupInfo$[esp+4280], 68 ; 00000044H
  0015a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateProcessA@40
  00160	85 c0		 test	 eax, eax
  00162	75 1d		 jne	 SHORT $LN7@CompressBu

; 167  : 	{
; 168  : 		PkgError ("Error: Cannot run gzip.\n\nBefore you can create a self-extracting CipherShed package, you need to have the open-source 'gzip' compression tool placed in any directory in the search path for executable files (for example, in 'C:\\Windows\\').\n\nNote: gzip can be freely downloaded e.g. from www.gzip.org");

  00164	68 10 00 05 00	 push	 327696			; 00050010H
  00169	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FEEFGEIL@CipherShed?$AA@
  0016e	68 00 00 00 00	 push	 OFFSET ??_C@_0BCL@DAKFJLFE@Error?3?5Cannot?5run?5gzip?4?6?6Before?5@
  00173	53		 push	 ebx
  00174	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 169  : 		return 0;

  0017a	33 c0		 xor	 eax, eax
  0017c	e9 bf 00 00 00	 jmp	 $LN25@CompressBu
$LN7@CompressBu:

; 170  : 	}
; 171  : 
; 172  : 	CloseHandle (procInfo.hProcess);

  00181	8b 4c 24 24	 mov	 ecx, DWORD PTR _procInfo$[esp+4240]
  00185	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CloseHandle@4
  0018b	51		 push	 ecx
  0018c	ff d6		 call	 esi

; 173  : 	CloseHandle (procInfo.hThread);

  0018e	8b 54 24 28	 mov	 edx, DWORD PTR _procInfo$[esp+4244]
  00192	52		 push	 edx
  00193	ff d6		 call	 esi

; 174  : 
; 175  : 	// Start sending the uncompressed data to the pipe (STDIN)
; 176  : 	PipeWriteBuf = in;

  00195	8b 84 24 98 10
	00 00		 mov	 eax, DWORD PTR _in$[esp+4236]

; 177  : 	_beginthread (PipeWriteThread, PIPE_BUFFER_LEN * 2, (void *) &len);

  0019c	8d 8c 24 9c 10
	00 00		 lea	 ecx, DWORD PTR _len$[esp+4236]
  001a3	51		 push	 ecx
  001a4	68 00 20 00 00	 push	 8192			; 00002000H
  001a9	68 00 00 00 00	 push	 OFFSET _PipeWriteThread
  001ae	a3 00 00 00 00	 mov	 DWORD PTR _PipeWriteBuf, eax
  001b3	e8 00 00 00 00	 call	 __beginthread

; 178  : 
; 179  : 	if (!CloseHandle (hChildStdoutWrite))

  001b8	8b 54 24 20	 mov	 edx, DWORD PTR _hChildStdoutWrite$[esp+4252]
  001bc	83 c4 0c	 add	 esp, 12			; 0000000cH
  001bf	52		 push	 edx
  001c0	ff d6		 call	 esi
  001c2	85 c0		 test	 eax, eax
  001c4	75 1a		 jne	 SHORT $LN6@CompressBu

; 180  : 	{
; 181  : 		PkgError ("Cannot close STDOUT write"); 

  001c6	68 10 00 05 00	 push	 327696			; 00050010H
  001cb	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FEEFGEIL@CipherShed?$AA@
  001d0	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@NGGPKPLC@Cannot?5close?5STDOUT?5write?$AA@
  001d5	53		 push	 ebx
  001d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 182  : 		return 0;

  001dc	33 c0		 xor	 eax, eax
  001de	eb 60		 jmp	 SHORT $LN25@CompressBu
$LN6@CompressBu:

; 183  : 	}
; 184  : 
; 185  : 	bGzipHeaderRead = FALSE;

  001e0	33 ff		 xor	 edi, edi
$LL5@CompressBu:

; 186  : 
; 187  : 	// Read the compressed data from the pipe (sent by the child process to STDOUT)
; 188  : 	while (TRUE) 
; 189  : 	{ 
; 190  : 		if (!ReadFile (hChildStdoutRead, pipeBuffer, bGzipHeaderRead ? PIPE_BUFFER_LEN : 10, &bytesReceived, NULL)) 

  001e2	89 5c 24 44	 mov	 DWORD PTR tv151[esp+4244], ebx
  001e6	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  001eb	3b fb		 cmp	 edi, ebx
  001ed	75 05		 jne	 SHORT $LN13@CompressBu
  001ef	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
$LN13@CompressBu:
  001f4	53		 push	 ebx
  001f5	8d 4c 24 20	 lea	 ecx, DWORD PTR _bytesReceived$[esp+4244]
  001f9	51		 push	 ecx
  001fa	50		 push	 eax
  001fb	8b 44 24 1c	 mov	 eax, DWORD PTR _hChildStdoutRead$[esp+4252]
  001ff	8d 94 24 98 00
	00 00		 lea	 edx, DWORD PTR _pipeBuffer$[esp+4252]
  00206	52		 push	 edx
  00207	50		 push	 eax
  00208	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20
  0020e	85 c0		 test	 eax, eax
  00210	74 2b		 je	 SHORT $LN24@CompressBu

; 191  : 			break; 
; 192  : 
; 193  : 		if (bGzipHeaderRead)

  00212	3b fb		 cmp	 edi, ebx
  00214	74 20		 je	 SHORT $LN2@CompressBu

; 194  : 		{
; 195  : 			memcpy (out + res_len, pipeBuffer, bytesReceived);

  00216	8b 74 24 1c	 mov	 esi, DWORD PTR _bytesReceived$[esp+4240]
  0021a	8b 54 24 20	 mov	 edx, DWORD PTR _out$GSCopy$[esp+4240]
  0021e	56		 push	 esi
  0021f	8d 8c 24 90 00
	00 00		 lea	 ecx, DWORD PTR _pipeBuffer$[esp+4244]
  00226	51		 push	 ecx
  00227	03 d5		 add	 edx, ebp
  00229	52		 push	 edx
  0022a	e8 00 00 00 00	 call	 _memcpy
  0022f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 196  : 			res_len += bytesReceived;

  00232	03 ee		 add	 ebp, esi

; 197  : 		}
; 198  : 		else

  00234	eb ac		 jmp	 SHORT $LL5@CompressBu
$LN2@CompressBu:

; 199  : 			bGzipHeaderRead = TRUE;	// Skip the 10-byte gzip header

  00236	bf 01 00 00 00	 mov	 edi, 1

; 200  : 	} 

  0023b	eb a5		 jmp	 SHORT $LL5@CompressBu
$LN24@CompressBu:

; 201  : 	return res_len - 8;	// A gzip stream ends with a CRC-32 hash and a 32-bit size (those 8 bytes need to be chopped off)

  0023d	8d 45 f8	 lea	 eax, DWORD PTR [ebp-8]
$LN25@CompressBu:

; 202  : }

  00240	8b 8c 24 8c 10
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+4240]
  00247	5f		 pop	 edi
  00248	5e		 pop	 esi
  00249	5d		 pop	 ebp
  0024a	5b		 pop	 ebx
  0024b	33 cc		 xor	 ecx, esp
  0024d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00252	81 c4 80 10 00
	00		 add	 esp, 4224		; 00001080H
  00258	c3		 ret	 0
_CompressBuffer ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _WipeSignatureAreas
_TEXT	SEGMENT
_WipeSignatureAreas PROC				; COMDAT
; _buffer$ = eax

; 209  : 	// Clear bytes 0x130-0x1ff
; 210  : 	memset (buffer + 0x130, 0, 0x200 - 0x130);

  00000	68 d0 00 00 00	 push	 208			; 000000d0H
  00005	05 30 01 00 00	 add	 eax, 304		; 00000130H
  0000a	6a 00		 push	 0
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _memset
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 211  : }

  00015	c3		 ret	 0
_WipeSignatureAreas ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DC@MFPOOIGB@Self?9extracting?5package?5successf@ ; `string'
PUBLIC	??_C@_0CH@KLAPHHKA@Cannot?5load?5the?5package?5to?5compu@ ; `string'
PUBLIC	??_C@_0BM@CAOLNJAF@Cannot?5write?5the?5end?5marker?$AA@ ; `string'
PUBLIC	??_C@_0CM@OKBFEFMD@Cannot?5write?5compressed?5data?5to?5@ ; `string'
PUBLIC	??_C@_0DD@BPNJOCGM@Cannot?5write?5the?5total?5size?5of?5t@ ; `string'
PUBLIC	??_C@_0BM@OPFGKMBF@Failed?5to?5compress?5the?5data?$AA@ ; `string'
PUBLIC	??_C@_0CL@MCBJOHEJ@Cannot?5allocate?5memory?5for?5compr@ ; `string'
PUBLIC	??_C@_0BH@BHAJCMKJ@Cannot?5load?5file?5?6?8?$CFs?8?$AA@ ; `string'
PUBLIC	??_C@_0DF@FMCDCAIK@Cannot?5write?5the?5total?5size?5of?5t@ ; `string'
PUBLIC	??_C@_0BO@MFJOIAFD@Cannot?5write?5the?5start?5marker?$AA@ ; `string'
PUBLIC	??_C@_08PPKICKPD@TCINSTRT?$AA@			; `string'
PUBLIC	??_C@_0BG@MKKJCCCC@File?5not?5found?3?6?6?8?$CFs?8?$AA@ ; `string'
PUBLIC	??_C@_0CN@MELKNJCC@Cannot?5allocate?5memory?5for?5uncom@ ; `string'
PUBLIC	??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@		; `string'
PUBLIC	??_C@_0DC@EJFFIFBK@Cannot?5copy?5?8CipherShed?5Setup?4ex@ ; `string'
PUBLIC	??_C@_0BL@KMNOMKN@CipherShed?5Setup?50?47?43?4exe?$AA@ ; `string'
PUBLIC	??_C@_01KICIPPFI@?2?$AA@			; `string'
PUBLIC	_szDestDir$GSCopy$
PUBLIC	_hwndDlg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_MakeSelfExtractingPackage
EXTRN	_sprintf:PROC
EXTRN	_GetCrc32:PROC
EXTRN	_LoadFile:PROC
EXTRN	_SaveBufferToFile:PROC
EXTRN	_free:PROC
EXTRN	_remove:PROC
EXTRN	_malloc:PROC
EXTRN	_GetFileSize64:PROC
EXTRN	_FileExists:PROC
EXTRN	__snprintf:PROC
EXTRN	_handleWin32Error:PROC
EXTRN	_TCCopyFile:PROC
EXTRN	_strncat:PROC
EXTRN	__imp__GetModuleFileNameA@12:PROC
;	COMDAT ??_C@_0DC@MFPOOIGB@Self?9extracting?5package?5successf@
CONST	SEGMENT
??_C@_0DC@MFPOOIGB@Self?9extracting?5package?5successf@ DB 'Self-extracti'
	DB	'ng package successfully created (%s)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@KLAPHHKA@Cannot?5load?5the?5package?5to?5compu@
CONST	SEGMENT
??_C@_0CH@KLAPHHKA@Cannot?5load?5the?5package?5to?5compu@ DB 'Cannot load'
	DB	' the package to compute CRC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CAOLNJAF@Cannot?5write?5the?5end?5marker?$AA@
CONST	SEGMENT
??_C@_0BM@CAOLNJAF@Cannot?5write?5the?5end?5marker?$AA@ DB 'Cannot write '
	DB	'the end marker', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@OKBFEFMD@Cannot?5write?5compressed?5data?5to?5@
CONST	SEGMENT
??_C@_0CM@OKBFEFMD@Cannot?5write?5compressed?5data?5to?5@ DB 'Cannot writ'
	DB	'e compressed data to the package', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@BPNJOCGM@Cannot?5write?5the?5total?5size?5of?5t@
CONST	SEGMENT
??_C@_0DD@BPNJOCGM@Cannot?5write?5the?5total?5size?5of?5t@ DB 'Cannot wri'
	DB	'te the total size of the compressed data', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OPFGKMBF@Failed?5to?5compress?5the?5data?$AA@
CONST	SEGMENT
??_C@_0BM@OPFGKMBF@Failed?5to?5compress?5the?5data?$AA@ DB 'Failed to com'
	DB	'press the data', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@MCBJOHEJ@Cannot?5allocate?5memory?5for?5compr@
CONST	SEGMENT
??_C@_0CL@MCBJOHEJ@Cannot?5allocate?5memory?5for?5compr@ DB 'Cannot alloc'
	DB	'ate memory for compressed data', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BHAJCMKJ@Cannot?5load?5file?5?6?8?$CFs?8?$AA@
CONST	SEGMENT
??_C@_0BH@BHAJCMKJ@Cannot?5load?5file?5?6?8?$CFs?8?$AA@ DB 'Cannot load f'
	DB	'ile ', 0aH, '''%s''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@FMCDCAIK@Cannot?5write?5the?5total?5size?5of?5t@
CONST	SEGMENT
??_C@_0DF@FMCDCAIK@Cannot?5write?5the?5total?5size?5of?5t@ DB 'Cannot wri'
	DB	'te the total size of the uncompressed data', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MFJOIAFD@Cannot?5write?5the?5start?5marker?$AA@
CONST	SEGMENT
??_C@_0BO@MFJOIAFD@Cannot?5write?5the?5start?5marker?$AA@ DB 'Cannot writ'
	DB	'e the start marker', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08PPKICKPD@TCINSTRT?$AA@
CONST	SEGMENT
??_C@_08PPKICKPD@TCINSTRT?$AA@ DB 'TCINSTRT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MKKJCCCC@File?5not?5found?3?6?6?8?$CFs?8?$AA@
CONST	SEGMENT
??_C@_0BG@MKKJCCCC@File?5not?5found?3?6?6?8?$CFs?8?$AA@ DB 'File not foun'
	DB	'd:', 0aH, 0aH, '''%s''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@MELKNJCC@Cannot?5allocate?5memory?5for?5uncom@
CONST	SEGMENT
??_C@_0CN@MELKNJCC@Cannot?5allocate?5memory?5for?5uncom@ DB 'Cannot alloc'
	DB	'ate memory for uncompressed data', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
CONST	SEGMENT
??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@ DB '%s%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@EJFFIFBK@Cannot?5copy?5?8CipherShed?5Setup?4ex@
CONST	SEGMENT
??_C@_0DC@EJFFIFBK@Cannot?5copy?5?8CipherShed?5Setup?4ex@ DB 'Cannot copy'
	DB	' ''CipherShed Setup.exe'' to the package', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KMNOMKN@CipherShed?5Setup?50?47?43?4exe?$AA@
CONST	SEGMENT
??_C@_0BL@KMNOMKN@CipherShed?5Setup?50?47?43?4exe?$AA@ DB 'CipherShed Set'
	DB	'up 0.7.3.exe', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01KICIPPFI@?2?$AA@
CONST	SEGMENT
??_C@_01KICIPPFI@?2?$AA@ DB '\', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _MakeSelfExtractingPackage
_TEXT	SEGMENT
_szTmp32bit$ = -3856					; size = 4
_tmpFileSize$80515 = -3852				; size = 4
_tmpFileSize$80461 = -3852				; size = 4
_buffer$ = -3848					; size = 4
_compressedBuffer$ = -3844				; size = 4
_hwndDlg$GSCopy$ = -3840				; size = 4
_szDestDir$GSCopy$ = -3836				; size = 4
_outputFile$ = -3832					; size = 260
_szTmpFilePath$ = -3572					; size = 260
_inputFile$ = -3312					; size = 260
_tmpstr$80465 = -3052					; size = 1000
_tmpstr$80449 = -3052					; size = 1000
_tmpStr$ = -2052					; size = 2048
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_szDestDir$ = 12					; size = 4
_MakeSelfExtractingPackage PROC				; COMDAT

; 215  : {

  00000	81 ec 10 0f 00
	00		 sub	 esp, 3856		; 00000f10H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 0c 0f
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+3856], eax
  00014	53		 push	 ebx
  00015	8b 9c 24 1c 0f
	00 00		 mov	 ebx, DWORD PTR _szDestDir$[esp+3856]

; 216  : 	int i, x;
; 217  : 	unsigned char inputFile [TC_MAX_PATH];
; 218  : 	unsigned char outputFile [TC_MAX_PATH];
; 219  : 	unsigned char szTmpFilePath [TC_MAX_PATH];
; 220  : 	unsigned char szTmp32bit [4] = {0};

  0001c	33 c0		 xor	 eax, eax
  0001e	55		 push	 ebp
  0001f	56		 push	 esi
  00020	8b b4 24 20 0f
	00 00		 mov	 esi, DWORD PTR _hwndDlg$[esp+3864]
  00027	66 89 44 24 0d	 mov	 WORD PTR _szTmp32bit$[esp+3869], ax
  0002c	88 44 24 0f	 mov	 BYTE PTR _szTmp32bit$[esp+3871], al

; 221  : 	unsigned char *szTmp32bitPtr = szTmp32bit;
; 222  : 	unsigned char *buffer = NULL, *compressedBuffer = NULL;

  00030	89 44 24 18	 mov	 DWORD PTR _compressedBuffer$[esp+3868], eax

; 223  : 	unsigned char *bufIndex = NULL;
; 224  : 	char tmpStr [2048];
; 225  : 	int bufLen = 0, compressedDataLen = 0, uncompressedDataLen = 0;
; 226  : 
; 227  : 	x = strlen (szDestDir);

  00034	8b c3		 mov	 eax, ebx
  00036	57		 push	 edi
  00037	89 74 24 20	 mov	 DWORD PTR _hwndDlg$GSCopy$[esp+3872], esi
  0003b	89 5c 24 24	 mov	 DWORD PTR _szDestDir$GSCopy$[esp+3872], ebx
  0003f	c6 44 24 10 00	 mov	 BYTE PTR _szTmp32bit$[esp+3872], 0
  00044	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL58@MakeSelfEx:
  00047	8a 08		 mov	 cl, BYTE PTR [eax]
  00049	40		 inc	 eax
  0004a	84 c9		 test	 cl, cl
  0004c	75 f9		 jne	 SHORT $LL58@MakeSelfEx
  0004e	2b c2		 sub	 eax, edx

; 228  : 	if (x < 2)

  00050	83 f8 02	 cmp	 eax, 2
  00053	0f 8c 7e 01 00
	00		 jl	 $LN1@MakeSelfEx

; 229  : 		goto err;
; 230  : 
; 231  : 	if (szDestDir[x - 1] != '\\')

  00059	80 7c 03 ff 5c	 cmp	 BYTE PTR [ebx+eax-1], 92 ; 0000005cH
  0005e	74 14		 je	 SHORT $LN22@MakeSelfEx

; 232  : 		strcat (szDestDir, "\\");

  00060	8b fb		 mov	 edi, ebx
  00062	4f		 dec	 edi
$LL59@MakeSelfEx:
  00063	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00066	47		 inc	 edi
  00067	84 c0		 test	 al, al
  00069	75 f8		 jne	 SHORT $LL59@MakeSelfEx
  0006b	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01KICIPPFI@?2?$AA@
  00071	66 89 07	 mov	 WORD PTR [edi], ax
$LN22@MakeSelfEx:

; 233  : 
; 234  : 	GetModuleFileName (NULL, inputFile, sizeof (inputFile));

  00074	68 04 01 00 00	 push	 260			; 00000104H
  00079	8d 8c 24 34 02
	00 00		 lea	 ecx, DWORD PTR _inputFile$[esp+3876]
  00080	51		 push	 ecx
  00081	6a 00		 push	 0
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12

; 235  : 
; 236  : 	strcpy (outputFile, szDestDir);

  00089	8d 54 24 28	 lea	 edx, DWORD PTR _outputFile$[esp+3872]
  0008d	8b c3		 mov	 eax, ebx
  0008f	2b d3		 sub	 edx, ebx
$LL26@MakeSelfEx:
  00091	8a 08		 mov	 cl, BYTE PTR [eax]
  00093	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00096	40		 inc	 eax
  00097	84 c9		 test	 cl, cl
  00099	75 f6		 jne	 SHORT $LL26@MakeSelfEx

; 237  : 	strncat (outputFile, OutputPackageFile, sizeof (outputFile) - strlen (outputFile) - 1);

  0009b	8d 44 24 28	 lea	 eax, DWORD PTR _outputFile$[esp+3872]
  0009f	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL60@MakeSelfEx:
  000a2	8a 08		 mov	 cl, BYTE PTR [eax]
  000a4	40		 inc	 eax
  000a5	84 c9		 test	 cl, cl
  000a7	75 f9		 jne	 SHORT $LL60@MakeSelfEx
  000a9	2b c2		 sub	 eax, edx
  000ab	ba 03 01 00 00	 mov	 edx, 259		; 00000103H
  000b0	2b d0		 sub	 edx, eax
  000b2	52		 push	 edx
  000b3	8d 44 24 2c	 lea	 eax, DWORD PTR _outputFile$[esp+3876]
  000b7	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@KMNOMKN@CipherShed?5Setup?50?47?43?4exe?$AA@
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 _strncat

; 238  : 
; 239  : 	// Clone 'CipherShed Setup.exe' to create the base of the new self-extracting archive
; 240  : 
; 241  : 	if (!TCCopyFile (inputFile, outputFile))

  000c2	8d 4c 24 34	 lea	 ecx, DWORD PTR _outputFile$[esp+3884]
  000c6	51		 push	 ecx
  000c7	8d 94 24 40 02
	00 00		 lea	 edx, DWORD PTR _inputFile$[esp+3888]
  000ce	52		 push	 edx
  000cf	e8 00 00 00 00	 call	 _TCCopyFile
  000d4	83 c4 14	 add	 esp, 20			; 00000014H
  000d7	85 c0		 test	 eax, eax
  000d9	75 27		 jne	 SHORT $LN21@MakeSelfEx

; 242  : 	{
; 243  : 		handleWin32Error (hwndDlg);

  000db	56		 push	 esi
  000dc	e8 00 00 00 00	 call	 _handleWin32Error
  000e1	83 c4 04	 add	 esp, 4

; 244  : 		PkgError ("Cannot copy 'CipherShed Setup.exe' to the package");

  000e4	68 10 00 05 00	 push	 327696			; 00050010H
  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FEEFGEIL@CipherShed?$AA@
  000ee	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@EJFFIFBK@Cannot?5copy?5?8CipherShed?5Setup?4ex@
  000f3	6a 00		 push	 0
  000f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 437  : 
; 438  : 	return FALSE;

  000fb	33 c0		 xor	 eax, eax
  000fd	e9 de 05 00 00	 jmp	 $LN24@MakeSelfEx
$LN21@MakeSelfEx:

; 245  : 		goto err;
; 246  : 	}
; 247  : 
; 248  : 	// Determine the buffer size needed for all the files and meta data and check if all required files exist
; 249  : 
; 250  : 	bufLen = 0;

  00102	33 ff		 xor	 edi, edi

; 251  : 
; 252  : 	for (i = 0; i < sizeof (szCompressedFiles) / sizeof (szCompressedFiles[0]); i++)

  00104	33 f6		 xor	 esi, esi
$LL20@MakeSelfEx:

; 253  : 	{
; 254  : 		_snprintf (szTmpFilePath, sizeof(szTmpFilePath), "%s%s", szDestDir, szCompressedFiles[i]);

  00106	8b 86 00 00 00
	00		 mov	 eax, DWORD PTR _szCompressedFiles[esi]
  0010c	50		 push	 eax
  0010d	53		 push	 ebx
  0010e	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  00113	8d 8c 24 38 01
	00 00		 lea	 ecx, DWORD PTR _szTmpFilePath$[esp+3884]
  0011a	68 04 01 00 00	 push	 260			; 00000104H
  0011f	51		 push	 ecx
  00120	e8 00 00 00 00	 call	 __snprintf

; 255  : 
; 256  : 		if (!FileExists (szTmpFilePath))

  00125	8d 94 24 40 01
	00 00		 lea	 edx, DWORD PTR _szTmpFilePath$[esp+3892]
  0012c	52		 push	 edx
  0012d	e8 00 00 00 00	 call	 _FileExists
  00132	83 c4 18	 add	 esp, 24			; 00000018H
  00135	85 c0		 test	 eax, eax
  00137	0f 84 a1 00 00
	00		 je	 $LN54@MakeSelfEx

; 263  : 			goto err;
; 264  : 		}
; 265  : 
; 266  : 		bufLen += (int) GetFileSize64 (szTmpFilePath);

  0013d	8d 84 24 2c 01
	00 00		 lea	 eax, DWORD PTR _szTmpFilePath$[esp+3872]
  00144	50		 push	 eax
  00145	e8 00 00 00 00	 call	 _GetFileSize64

; 267  : 
; 268  : 		bufLen += 2;					// 16-bit filename length

  0014a	8d 54 07 02	 lea	 edx, DWORD PTR [edi+eax+2]

; 269  : 		bufLen += strlen(szCompressedFiles[i]);	// Filename

  0014e	8b 86 00 00 00
	00		 mov	 eax, DWORD PTR _szCompressedFiles[esi]
  00154	83 c4 04	 add	 esp, 4
  00157	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0015a	8d 9b 00 00 00
	00		 npad	 6
$LL61@MakeSelfEx:
  00160	8a 08		 mov	 cl, BYTE PTR [eax]
  00162	40		 inc	 eax
  00163	84 c9		 test	 cl, cl
  00165	75 f9		 jne	 SHORT $LL61@MakeSelfEx
  00167	2b c7		 sub	 eax, edi
  00169	83 c6 04	 add	 esi, 4

; 270  : 		bufLen += 4;					// CRC-32
; 271  : 		bufLen += 4;					// 32-bit file length

  0016c	8d 7c 02 08	 lea	 edi, DWORD PTR [edx+eax+8]
  00170	83 fe 18	 cmp	 esi, 24			; 00000018H
  00173	72 91		 jb	 SHORT $LL20@MakeSelfEx

; 272  : 	}
; 273  : 
; 274  : 	buffer = malloc (bufLen + 524288);	// + 512K reserve 

  00175	81 c7 00 00 08
	00		 add	 edi, 524288		; 00080000H
  0017b	57		 push	 edi
  0017c	e8 00 00 00 00	 call	 _malloc
  00181	8b f0		 mov	 esi, eax
  00183	83 c4 04	 add	 esp, 4
  00186	89 74 24 18	 mov	 DWORD PTR _buffer$[esp+3872], esi

; 275  : 	if (buffer == NULL)

  0018a	85 f6		 test	 esi, esi
  0018c	0f 85 99 00 00
	00		 jne	 $LN16@MakeSelfEx

; 276  : 	{
; 277  : 		PkgError ("Cannot allocate memory for uncompressed data");

  00192	68 10 00 05 00	 push	 327696			; 00050010H
  00197	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FEEFGEIL@CipherShed?$AA@
  0019c	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@MELKNJCC@Cannot?5allocate?5memory?5for?5uncom@
  001a1	50		 push	 eax
  001a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 278  : 		remove (outputFile);

  001a8	8d 54 24 28	 lea	 edx, DWORD PTR _outputFile$[esp+3872]
  001ac	52		 push	 edx
$LN68@MakeSelfEx:

; 287  : 		remove (outputFile);

  001ad	e8 00 00 00 00	 call	 _remove
  001b2	83 c4 04	 add	 esp, 4
$err$80437:

; 431  : 
; 432  : err:
; 433  : 	if (buffer)

  001b5	8b 44 24 18	 mov	 eax, DWORD PTR _buffer$[esp+3872]
  001b9	85 c0		 test	 eax, eax
  001bb	74 09		 je	 SHORT $LN2@MakeSelfEx

; 434  : 		free (buffer);

  001bd	50		 push	 eax
  001be	e8 00 00 00 00	 call	 _free
  001c3	83 c4 04	 add	 esp, 4
$LN2@MakeSelfEx:

; 435  : 	if (compressedBuffer)

  001c6	8b 44 24 1c	 mov	 eax, DWORD PTR _compressedBuffer$[esp+3872]
  001ca	85 c0		 test	 eax, eax
  001cc	74 09		 je	 SHORT $LN1@MakeSelfEx

; 436  : 		free (compressedBuffer);

  001ce	50		 push	 eax
  001cf	e8 00 00 00 00	 call	 _free
  001d4	83 c4 04	 add	 esp, 4
$LN1@MakeSelfEx:

; 437  : 
; 438  : 	return FALSE;

  001d7	33 c0		 xor	 eax, eax
  001d9	e9 02 05 00 00	 jmp	 $LN24@MakeSelfEx
$LN54@MakeSelfEx:

; 257  : 		{
; 258  : 			char tmpstr [1000];
; 259  : 
; 260  : 			_snprintf (tmpstr, sizeof(tmpstr), "File not found:\n\n'%s'", szTmpFilePath);

  001de	8d 8c 24 2c 01
	00 00		 lea	 ecx, DWORD PTR _szTmpFilePath$[esp+3872]
  001e5	51		 push	 ecx
  001e6	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@MKKJCCCC@File?5not?5found?3?6?6?8?$CFs?8?$AA@
  001eb	8d 94 24 3c 03
	00 00		 lea	 edx, DWORD PTR _tmpstr$80449[esp+3880]
  001f2	68 e8 03 00 00	 push	 1000			; 000003e8H
  001f7	52		 push	 edx
  001f8	e8 00 00 00 00	 call	 __snprintf

; 261  : 			remove (outputFile);

  001fd	8d 44 24 38	 lea	 eax, DWORD PTR _outputFile$[esp+3888]
  00201	50		 push	 eax
  00202	e8 00 00 00 00	 call	 _remove
  00207	83 c4 14	 add	 esp, 20			; 00000014H

; 262  : 			PkgError (tmpstr);

  0020a	68 10 00 05 00	 push	 327696			; 00050010H
  0020f	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FEEFGEIL@CipherShed?$AA@
  00214	8d 8c 24 3c 03
	00 00		 lea	 ecx, DWORD PTR _tmpstr$80449[esp+3880]
  0021b	51		 push	 ecx
  0021c	6a 00		 push	 0
  0021e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 437  : 
; 438  : 	return FALSE;

  00224	33 c0		 xor	 eax, eax
  00226	e9 b5 04 00 00	 jmp	 $LN24@MakeSelfEx
$LN16@MakeSelfEx:

; 279  : 		goto err;
; 280  : 	}
; 281  : 
; 282  : 
; 283  : 	// Write the start marker
; 284  : 	if (!SaveBufferToFile (MAG_START_MARKER, outputFile, strlen (MAG_START_MARKER), TRUE))

  0022b	6a 01		 push	 1
  0022d	6a 08		 push	 8
  0022f	8d 44 24 30	 lea	 eax, DWORD PTR _outputFile$[esp+3880]
  00233	50		 push	 eax
  00234	68 00 00 00 00	 push	 OFFSET ??_C@_08PPKICKPD@TCINSTRT?$AA@
  00239	e8 00 00 00 00	 call	 _SaveBufferToFile
  0023e	83 c4 10	 add	 esp, 16			; 00000010H
  00241	85 c0		 test	 eax, eax
  00243	75 20		 jne	 SHORT $LN15@MakeSelfEx

; 285  : 	{
; 286  : 		PkgError ("Cannot write the start marker");

  00245	68 10 00 05 00	 push	 327696			; 00050010H
  0024a	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FEEFGEIL@CipherShed?$AA@
  0024f	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@MFJOIAFD@Cannot?5write?5the?5start?5marker?$AA@
  00254	50		 push	 eax
  00255	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 287  : 		remove (outputFile);

  0025b	8d 4c 24 28	 lea	 ecx, DWORD PTR _outputFile$[esp+3872]
  0025f	51		 push	 ecx

; 288  : 		goto err;

  00260	e9 48 ff ff ff	 jmp	 $LN68@MakeSelfEx
$LN15@MakeSelfEx:

; 289  : 	}
; 290  : 
; 291  : 
; 292  : 	bufIndex = buffer;
; 293  : 
; 294  : 	// Copy all required files and their meta data to the buffer
; 295  : 	for (i = 0; i < sizeof (szCompressedFiles) / sizeof (szCompressedFiles[0]); i++)

  00265	33 ff		 xor	 edi, edi
  00267	eb 0b		 jmp	 SHORT $LN14@MakeSelfEx
  00269	8d a4 24 00 00
	00 00		 npad	 7
$LL67@MakeSelfEx:
  00270	8b 5c 24 24	 mov	 ebx, DWORD PTR _szDestDir$GSCopy$[esp+3872]
$LN14@MakeSelfEx:

; 296  : 	{
; 297  : 		DWORD tmpFileSize;
; 298  : 		unsigned char *tmpBuffer;
; 299  : 
; 300  : 		_snprintf (szTmpFilePath, sizeof(szTmpFilePath), "%s%s", szDestDir, szCompressedFiles[i]);

  00274	8b 97 00 00 00
	00		 mov	 edx, DWORD PTR _szCompressedFiles[edi]
  0027a	52		 push	 edx
  0027b	53		 push	 ebx
  0027c	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  00281	8d 84 24 38 01
	00 00		 lea	 eax, DWORD PTR _szTmpFilePath$[esp+3884]
  00288	68 04 01 00 00	 push	 260			; 00000104H
  0028d	50		 push	 eax
  0028e	e8 00 00 00 00	 call	 __snprintf

; 301  : 
; 302  : 		tmpBuffer = LoadFile (szTmpFilePath, &tmpFileSize);

  00293	8d 4c 24 28	 lea	 ecx, DWORD PTR _tmpFileSize$80461[esp+3892]
  00297	51		 push	 ecx
  00298	8d 94 24 44 01
	00 00		 lea	 edx, DWORD PTR _szTmpFilePath$[esp+3896]
  0029f	52		 push	 edx
  002a0	e8 00 00 00 00	 call	 _LoadFile
  002a5	8b d8		 mov	 ebx, eax
  002a7	83 c4 1c	 add	 esp, 28			; 0000001cH

; 303  : 
; 304  : 		if (tmpBuffer == NULL)

  002aa	85 db		 test	 ebx, ebx
  002ac	0f 84 5e 01 00
	00		 je	 $LN55@MakeSelfEx

; 313  : 		}
; 314  : 
; 315  : 		// Copy the filename length to the main buffer
; 316  : 		mputWord (bufIndex, (WORD) strlen(szCompressedFiles[i]));

  002b2	8b 87 00 00 00
	00		 mov	 eax, DWORD PTR _szCompressedFiles[edi]
  002b8	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  002bb	eb 03 8d 49 00	 npad	 5
$LL62@MakeSelfEx:
  002c0	8a 08		 mov	 cl, BYTE PTR [eax]
  002c2	40		 inc	 eax
  002c3	84 c9		 test	 cl, cl
  002c5	75 f9		 jne	 SHORT $LL62@MakeSelfEx
  002c7	2b c2		 sub	 eax, edx
  002c9	c1 e8 08	 shr	 eax, 8
  002cc	88 06		 mov	 BYTE PTR [esi], al
  002ce	8b 87 00 00 00
	00		 mov	 eax, DWORD PTR _szCompressedFiles[edi]
  002d4	46		 inc	 esi
  002d5	8d 68 01	 lea	 ebp, DWORD PTR [eax+1]
$LL63@MakeSelfEx:
  002d8	8a 08		 mov	 cl, BYTE PTR [eax]
  002da	40		 inc	 eax
  002db	84 c9		 test	 cl, cl
  002dd	75 f9		 jne	 SHORT $LL63@MakeSelfEx
  002df	2b c5		 sub	 eax, ebp
  002e1	88 06		 mov	 BYTE PTR [esi], al

; 317  : 
; 318  : 		// Copy the filename to the main buffer
; 319  : 		memcpy (bufIndex, szCompressedFiles[i], strlen(szCompressedFiles[i]));

  002e3	8b af 00 00 00
	00		 mov	 ebp, DWORD PTR _szCompressedFiles[edi]
  002e9	8b c5		 mov	 eax, ebp
  002eb	46		 inc	 esi
  002ec	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  002ef	90		 npad	 1
$LL64@MakeSelfEx:
  002f0	8a 10		 mov	 dl, BYTE PTR [eax]
  002f2	40		 inc	 eax
  002f3	84 d2		 test	 dl, dl
  002f5	75 f9		 jne	 SHORT $LL64@MakeSelfEx
  002f7	2b c1		 sub	 eax, ecx
  002f9	50		 push	 eax
  002fa	55		 push	 ebp
  002fb	56		 push	 esi
  002fc	e8 00 00 00 00	 call	 _memcpy

; 320  : 		bufIndex += strlen(szCompressedFiles[i]);

  00301	8b 87 00 00 00
	00		 mov	 eax, DWORD PTR _szCompressedFiles[edi]
  00307	83 c4 0c	 add	 esp, 12			; 0000000cH
  0030a	8d 68 01	 lea	 ebp, DWORD PTR [eax+1]
  0030d	8d 49 00	 npad	 3
$LL65@MakeSelfEx:
  00310	8a 08		 mov	 cl, BYTE PTR [eax]
  00312	40		 inc	 eax
  00313	84 c9		 test	 cl, cl
  00315	75 f9		 jne	 SHORT $LL65@MakeSelfEx
  00317	2b c5		 sub	 eax, ebp
  00319	03 f0		 add	 esi, eax

; 321  : 
; 322  : 		// Compute CRC-32 hash of the uncompressed file and copy it to the main buffer
; 323  : 		mputLong (bufIndex, GetCrc32 (tmpBuffer, tmpFileSize));

  0031b	8b 44 24 14	 mov	 eax, DWORD PTR _tmpFileSize$80461[esp+3872]
  0031f	50		 push	 eax
  00320	53		 push	 ebx
  00321	e8 00 00 00 00	 call	 _GetCrc32
  00326	c1 e8 18	 shr	 eax, 24			; 00000018H
  00329	88 06		 mov	 BYTE PTR [esi], al
  0032b	8b 4c 24 1c	 mov	 ecx, DWORD PTR _tmpFileSize$80461[esp+3880]
  0032f	51		 push	 ecx
  00330	53		 push	 ebx
  00331	46		 inc	 esi
  00332	e8 00 00 00 00	 call	 _GetCrc32
  00337	c1 e8 10	 shr	 eax, 16			; 00000010H
  0033a	88 06		 mov	 BYTE PTR [esi], al
  0033c	8b 54 24 24	 mov	 edx, DWORD PTR _tmpFileSize$80461[esp+3888]
  00340	52		 push	 edx
  00341	53		 push	 ebx
  00342	46		 inc	 esi
  00343	e8 00 00 00 00	 call	 _GetCrc32
  00348	c1 e8 08	 shr	 eax, 8
  0034b	88 06		 mov	 BYTE PTR [esi], al
  0034d	8b 44 24 2c	 mov	 eax, DWORD PTR _tmpFileSize$80461[esp+3896]
  00351	50		 push	 eax
  00352	53		 push	 ebx
  00353	46		 inc	 esi
  00354	e8 00 00 00 00	 call	 _GetCrc32
  00359	88 06		 mov	 BYTE PTR [esi], al

; 324  : 
; 325  : 		// Copy the file length to the main buffer
; 326  : 		mputLong (bufIndex, (unsigned __int32) tmpFileSize);

  0035b	8b 4c 24 34	 mov	 ecx, DWORD PTR _tmpFileSize$80461[esp+3904]
  0035f	46		 inc	 esi
  00360	c1 e9 18	 shr	 ecx, 24			; 00000018H
  00363	88 0e		 mov	 BYTE PTR [esi], cl
  00365	8b 54 24 34	 mov	 edx, DWORD PTR _tmpFileSize$80461[esp+3904]
  00369	46		 inc	 esi
  0036a	c1 ea 10	 shr	 edx, 16			; 00000010H
  0036d	88 16		 mov	 BYTE PTR [esi], dl
  0036f	8b 44 24 34	 mov	 eax, DWORD PTR _tmpFileSize$80461[esp+3904]
  00373	46		 inc	 esi
  00374	c1 e8 08	 shr	 eax, 8
  00377	88 06		 mov	 BYTE PTR [esi], al
  00379	8a 4c 24 34	 mov	 cl, BYTE PTR _tmpFileSize$80461[esp+3904]
  0037d	46		 inc	 esi
  0037e	88 0e		 mov	 BYTE PTR [esi], cl

; 327  : 
; 328  : 		// Copy the file contents to the main buffer
; 329  : 		memcpy (bufIndex, tmpBuffer, tmpFileSize);

  00380	8b 54 24 34	 mov	 edx, DWORD PTR _tmpFileSize$80461[esp+3904]
  00384	52		 push	 edx
  00385	46		 inc	 esi
  00386	53		 push	 ebx
  00387	56		 push	 esi
  00388	e8 00 00 00 00	 call	 _memcpy

; 330  : 		bufIndex += tmpFileSize;

  0038d	03 74 24 40	 add	 esi, DWORD PTR _tmpFileSize$80461[esp+3916]

; 331  : 
; 332  : 		free (tmpBuffer);

  00391	53		 push	 ebx
  00392	e8 00 00 00 00	 call	 _free
  00397	83 c7 04	 add	 edi, 4
  0039a	83 c4 30	 add	 esp, 48			; 00000030H
  0039d	83 ff 18	 cmp	 edi, 24			; 00000018H
  003a0	0f 82 ca fe ff
	ff		 jb	 $LL67@MakeSelfEx

; 333  : 	}
; 334  : 
; 335  : 	// Calculate the total size of the uncompressed data
; 336  : 	uncompressedDataLen = (int) (bufIndex - buffer);

  003a6	8b 7c 24 18	 mov	 edi, DWORD PTR _buffer$[esp+3872]
  003aa	2b f7		 sub	 esi, edi
  003ac	8b de		 mov	 ebx, esi

; 337  : 
; 338  : 	// Write total size of the uncompressed data
; 339  : 	szTmp32bitPtr = szTmp32bit;
; 340  : 	mputLong (szTmp32bitPtr, (unsigned __int32) uncompressedDataLen);

  003ae	8b cb		 mov	 ecx, ebx
  003b0	c1 e9 18	 shr	 ecx, 24			; 00000018H

; 341  : 	if (!SaveBufferToFile (szTmp32bit, outputFile, sizeof (szTmp32bit), TRUE))

  003b3	6a 01		 push	 1
  003b5	8b d3		 mov	 edx, ebx
  003b7	c1 ea 10	 shr	 edx, 16			; 00000010H
  003ba	88 4c 24 14	 mov	 BYTE PTR _szTmp32bit$[esp+3876], cl
  003be	6a 04		 push	 4
  003c0	8d 4c 24 30	 lea	 ecx, DWORD PTR _outputFile$[esp+3880]
  003c4	88 54 24 19	 mov	 BYTE PTR _szTmp32bit$[esp+3881], dl
  003c8	8b c3		 mov	 eax, ebx
  003ca	51		 push	 ecx
  003cb	8d 54 24 1c	 lea	 edx, DWORD PTR _szTmp32bit$[esp+3884]
  003cf	c1 e8 08	 shr	 eax, 8
  003d2	52		 push	 edx
  003d3	88 44 24 22	 mov	 BYTE PTR _szTmp32bit$[esp+3890], al
  003d7	88 5c 24 23	 mov	 BYTE PTR _szTmp32bit$[esp+3891], bl
  003db	e8 00 00 00 00	 call	 _SaveBufferToFile
  003e0	83 c4 10	 add	 esp, 16			; 00000010H
  003e3	85 c0		 test	 eax, eax
  003e5	75 7b		 jne	 SHORT $LN10@MakeSelfEx

; 342  : 	{
; 343  : 		remove (outputFile);

  003e7	8d 44 24 28	 lea	 eax, DWORD PTR _outputFile$[esp+3872]
  003eb	50		 push	 eax
  003ec	e8 00 00 00 00	 call	 _remove
  003f1	83 c4 04	 add	 esp, 4

; 344  : 		PkgError ("Cannot write the total size of the uncompressed data");

  003f4	68 10 00 05 00	 push	 327696			; 00050010H
  003f9	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FEEFGEIL@CipherShed?$AA@
  003fe	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@FMCDCAIK@Cannot?5write?5the?5total?5size?5of?5t@
  00403	6a 00		 push	 0
  00405	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 345  : 		goto err;

  0040b	e9 a5 fd ff ff	 jmp	 $err$80437
$LN55@MakeSelfEx:

; 305  : 		{
; 306  : 			char tmpstr [1000];
; 307  : 
; 308  : 			free (tmpBuffer);

  00410	6a 00		 push	 0
  00412	e8 00 00 00 00	 call	 _free

; 309  : 			_snprintf (tmpstr, sizeof(tmpstr), "Cannot load file \n'%s'", szTmpFilePath);

  00417	8d 84 24 30 01
	00 00		 lea	 eax, DWORD PTR _szTmpFilePath$[esp+3876]
  0041e	50		 push	 eax
  0041f	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@BHAJCMKJ@Cannot?5load?5file?5?6?8?$CFs?8?$AA@
  00424	8d 8c 24 40 03
	00 00		 lea	 ecx, DWORD PTR _tmpstr$80465[esp+3884]
  0042b	68 e8 03 00 00	 push	 1000			; 000003e8H
  00430	51		 push	 ecx
  00431	e8 00 00 00 00	 call	 __snprintf

; 310  : 			remove (outputFile);

  00436	8d 54 24 3c	 lea	 edx, DWORD PTR _outputFile$[esp+3892]
  0043a	52		 push	 edx
  0043b	e8 00 00 00 00	 call	 _remove
  00440	83 c4 18	 add	 esp, 24			; 00000018H

; 311  : 			PkgError (tmpstr);

  00443	68 10 00 05 00	 push	 327696			; 00050010H
  00448	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FEEFGEIL@CipherShed?$AA@
  0044d	8d 84 24 3c 03
	00 00		 lea	 eax, DWORD PTR _tmpstr$80465[esp+3880]
  00454	50		 push	 eax
  00455	6a 00		 push	 0
  00457	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 312  : 			goto err;

  0045d	e9 53 fd ff ff	 jmp	 $err$80437
$LN10@MakeSelfEx:

; 346  : 	}
; 347  : 
; 348  : 	// Compress all the files and meta data in the buffer to create a solid archive
; 349  : 
; 350  : 	compressedBuffer = malloc (uncompressedDataLen + 524288);	// + 512K reserve

  00462	8d 8b 00 00 08
	00		 lea	 ecx, DWORD PTR [ebx+524288]
  00468	51		 push	 ecx
  00469	e8 00 00 00 00	 call	 _malloc
  0046e	8b f0		 mov	 esi, eax
  00470	83 c4 04	 add	 esp, 4
  00473	89 74 24 1c	 mov	 DWORD PTR _compressedBuffer$[esp+3872], esi

; 351  : 	if (compressedBuffer == NULL)

  00477	85 f6		 test	 esi, esi
  00479	75 28		 jne	 SHORT $LN9@MakeSelfEx

; 352  : 	{
; 353  : 		remove (outputFile);

  0047b	8d 54 24 28	 lea	 edx, DWORD PTR _outputFile$[esp+3872]
  0047f	52		 push	 edx
  00480	e8 00 00 00 00	 call	 _remove
  00485	83 c4 04	 add	 esp, 4

; 354  : 		PkgError ("Cannot allocate memory for compressed data");

  00488	68 10 00 05 00	 push	 327696			; 00050010H
  0048d	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FEEFGEIL@CipherShed?$AA@
  00492	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@MCBJOHEJ@Cannot?5allocate?5memory?5for?5compr@
  00497	56		 push	 esi
  00498	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 355  : 		goto err;

  0049e	e9 12 fd ff ff	 jmp	 $err$80437
$LN9@MakeSelfEx:

; 356  : 	}
; 357  : 
; 358  : 	compressedDataLen = CompressBuffer (compressedBuffer, buffer, uncompressedDataLen);

  004a3	53		 push	 ebx
  004a4	57		 push	 edi
  004a5	56		 push	 esi
  004a6	e8 00 00 00 00	 call	 _CompressBuffer
  004ab	8b d8		 mov	 ebx, eax
  004ad	83 c4 0c	 add	 esp, 12			; 0000000cH

; 359  : 	if (compressedDataLen <= 0)

  004b0	85 db		 test	 ebx, ebx
  004b2	7f 29		 jg	 SHORT $LN8@MakeSelfEx

; 360  : 	{
; 361  : 		remove (outputFile);

  004b4	8d 44 24 28	 lea	 eax, DWORD PTR _outputFile$[esp+3872]
  004b8	50		 push	 eax
  004b9	e8 00 00 00 00	 call	 _remove
  004be	83 c4 04	 add	 esp, 4

; 362  : 		PkgError ("Failed to compress the data");

  004c1	68 10 00 05 00	 push	 327696			; 00050010H
  004c6	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FEEFGEIL@CipherShed?$AA@
  004cb	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@OPFGKMBF@Failed?5to?5compress?5the?5data?$AA@
  004d0	6a 00		 push	 0
  004d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 363  : 		goto err;

  004d8	e9 d8 fc ff ff	 jmp	 $err$80437
$LN8@MakeSelfEx:

; 364  : 	}
; 365  : 
; 366  : 	free (buffer);

  004dd	57		 push	 edi
  004de	e8 00 00 00 00	 call	 _free

; 367  : 	buffer = NULL;
; 368  : 
; 369  : 	// Write the total size of the compressed data
; 370  : 	szTmp32bitPtr = szTmp32bit;
; 371  : 	mputLong (szTmp32bitPtr, (unsigned __int32) compressedDataLen);

  004e3	8b cb		 mov	 ecx, ebx
  004e5	c1 e9 18	 shr	 ecx, 24			; 00000018H

; 372  : 	if (!SaveBufferToFile (szTmp32bit, outputFile, sizeof (szTmp32bit), TRUE))

  004e8	6a 01		 push	 1
  004ea	8b d3		 mov	 edx, ebx
  004ec	c1 ea 10	 shr	 edx, 16			; 00000010H
  004ef	88 4c 24 18	 mov	 BYTE PTR _szTmp32bit$[esp+3880], cl
  004f3	6a 04		 push	 4
  004f5	8d 4c 24 34	 lea	 ecx, DWORD PTR _outputFile$[esp+3884]
  004f9	88 54 24 1d	 mov	 BYTE PTR _szTmp32bit$[esp+3885], dl
  004fd	8b c3		 mov	 eax, ebx
  004ff	51		 push	 ecx
  00500	8d 54 24 20	 lea	 edx, DWORD PTR _szTmp32bit$[esp+3888]
  00504	c1 e8 08	 shr	 eax, 8
  00507	52		 push	 edx
  00508	88 44 24 26	 mov	 BYTE PTR _szTmp32bit$[esp+3894], al
  0050c	88 5c 24 27	 mov	 BYTE PTR _szTmp32bit$[esp+3895], bl
  00510	e8 00 00 00 00	 call	 _SaveBufferToFile
  00515	83 c4 14	 add	 esp, 20			; 00000014H
  00518	85 c0		 test	 eax, eax
  0051a	75 29		 jne	 SHORT $LN7@MakeSelfEx

; 373  : 	{
; 374  : 		remove (outputFile);

  0051c	8d 44 24 28	 lea	 eax, DWORD PTR _outputFile$[esp+3872]
  00520	50		 push	 eax
  00521	e8 00 00 00 00	 call	 _remove
  00526	83 c4 04	 add	 esp, 4

; 375  : 		PkgError ("Cannot write the total size of the compressed data");

  00529	68 10 00 05 00	 push	 327696			; 00050010H
  0052e	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FEEFGEIL@CipherShed?$AA@
  00533	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@BPNJOCGM@Cannot?5write?5the?5total?5size?5of?5t@
  00538	6a 00		 push	 0
  0053a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 376  : 		goto err;

  00540	e9 81 fc ff ff	 jmp	 $LN2@MakeSelfEx
$LN7@MakeSelfEx:

; 377  : 	}
; 378  : 
; 379  : 	// Write the compressed data
; 380  : 	if (!SaveBufferToFile (compressedBuffer, outputFile, compressedDataLen, TRUE))

  00545	6a 01		 push	 1
  00547	53		 push	 ebx
  00548	8d 4c 24 30	 lea	 ecx, DWORD PTR _outputFile$[esp+3880]
  0054c	51		 push	 ecx
  0054d	56		 push	 esi
  0054e	e8 00 00 00 00	 call	 _SaveBufferToFile
  00553	83 c4 10	 add	 esp, 16			; 00000010H
  00556	85 c0		 test	 eax, eax
  00558	75 29		 jne	 SHORT $LN6@MakeSelfEx

; 381  : 	{
; 382  : 		remove (outputFile);

  0055a	8d 54 24 28	 lea	 edx, DWORD PTR _outputFile$[esp+3872]
  0055e	52		 push	 edx
  0055f	e8 00 00 00 00	 call	 _remove
  00564	83 c4 04	 add	 esp, 4

; 383  : 		PkgError ("Cannot write compressed data to the package");

  00567	68 10 00 05 00	 push	 327696			; 00050010H
  0056c	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FEEFGEIL@CipherShed?$AA@
  00571	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@OKBFEFMD@Cannot?5write?5compressed?5data?5to?5@
  00576	6a 00		 push	 0
  00578	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 384  : 		goto err;

  0057e	e9 43 fc ff ff	 jmp	 $LN2@MakeSelfEx
$LN6@MakeSelfEx:

; 385  : 	}
; 386  : 
; 387  : 	// Write the end marker
; 388  : 	if (!SaveBufferToFile (MagEndMarker, outputFile, strlen (MagEndMarker), TRUE))

  00583	b8 00 00 00 00	 mov	 eax, OFFSET _MagEndMarker
  00588	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0058b	eb 03 8d 49 00	 npad	 5
$LL66@MakeSelfEx:
  00590	8a 08		 mov	 cl, BYTE PTR [eax]
  00592	40		 inc	 eax
  00593	84 c9		 test	 cl, cl
  00595	75 f9		 jne	 SHORT $LL66@MakeSelfEx
  00597	2b c2		 sub	 eax, edx
  00599	6a 01		 push	 1
  0059b	50		 push	 eax
  0059c	8d 44 24 30	 lea	 eax, DWORD PTR _outputFile$[esp+3880]
  005a0	50		 push	 eax
  005a1	68 00 00 00 00	 push	 OFFSET _MagEndMarker
  005a6	e8 00 00 00 00	 call	 _SaveBufferToFile
  005ab	83 c4 10	 add	 esp, 16			; 00000010H
  005ae	85 c0		 test	 eax, eax
  005b0	75 1c		 jne	 SHORT $LN5@MakeSelfEx

; 389  : 	{
; 390  : 		remove (outputFile);

  005b2	8d 4c 24 28	 lea	 ecx, DWORD PTR _outputFile$[esp+3872]
  005b6	51		 push	 ecx
  005b7	e8 00 00 00 00	 call	 _remove
  005bc	83 c4 04	 add	 esp, 4

; 391  : 		PkgError ("Cannot write the end marker");

  005bf	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BM@CAOLNJAF@Cannot?5write?5the?5end?5marker?$AA@
  005c4	e8 00 00 00 00	 call	 _PkgError

; 392  : 		goto err;

  005c9	e9 f8 fb ff ff	 jmp	 $LN2@MakeSelfEx
$LN5@MakeSelfEx:

; 393  : 	}
; 394  : 
; 395  : 	free (compressedBuffer);

  005ce	56		 push	 esi
  005cf	e8 00 00 00 00	 call	 _free

; 396  : 	compressedBuffer = NULL;
; 397  : 
; 398  : 	// Compute and write CRC-32 hash of the entire package
; 399  : 	{
; 400  : 		DWORD tmpFileSize;
; 401  : 		char *tmpBuffer;
; 402  : 
; 403  : 		tmpBuffer = LoadFile (outputFile, &tmpFileSize);

  005d4	8d 54 24 18	 lea	 edx, DWORD PTR _tmpFileSize$80515[esp+3876]
  005d8	52		 push	 edx
  005d9	8d 44 24 30	 lea	 eax, DWORD PTR _outputFile$[esp+3880]
  005dd	50		 push	 eax
  005de	e8 00 00 00 00	 call	 _LoadFile
  005e3	8b f0		 mov	 esi, eax
  005e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 404  : 
; 405  : 		if (tmpBuffer == NULL)

  005e8	85 f6		 test	 esi, esi
  005ea	75 28		 jne	 SHORT $LN4@MakeSelfEx

; 406  : 		{
; 407  : 			handleWin32Error (hwndDlg);

  005ec	8b 4c 24 20	 mov	 ecx, DWORD PTR _hwndDlg$GSCopy$[esp+3872]
  005f0	51		 push	 ecx
  005f1	e8 00 00 00 00	 call	 _handleWin32Error

; 408  : 			remove (outputFile);

  005f6	8d 54 24 2c	 lea	 edx, DWORD PTR _outputFile$[esp+3876]
  005fa	52		 push	 edx
  005fb	e8 00 00 00 00	 call	 _remove
  00600	83 c4 08	 add	 esp, 8

; 409  : 			PkgError ("Cannot load the package to compute CRC");

  00603	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CH@KLAPHHKA@Cannot?5load?5the?5package?5to?5compu@
  00608	e8 00 00 00 00	 call	 _PkgError

; 437  : 
; 438  : 	return FALSE;

  0060d	33 c0		 xor	 eax, eax
  0060f	e9 cc 00 00 00	 jmp	 $LN24@MakeSelfEx
$LN4@MakeSelfEx:

; 410  : 			goto err;
; 411  : 		}
; 412  : 
; 413  : 		// Zero all bytes that change when the exe is digitally signed (except appended blocks).
; 414  : 		WipeSignatureAreas (tmpBuffer);

  00614	68 d0 00 00 00	 push	 208			; 000000d0H
  00619	8d 86 30 01 00
	00		 lea	 eax, DWORD PTR [esi+304]
  0061f	6a 00		 push	 0
  00621	50		 push	 eax
  00622	e8 00 00 00 00	 call	 _memset

; 415  : 
; 416  : 		szTmp32bitPtr = szTmp32bit;
; 417  : 		mputLong (szTmp32bitPtr, GetCrc32 (tmpBuffer, tmpFileSize));

  00627	8b 4c 24 20	 mov	 ecx, DWORD PTR _tmpFileSize$80515[esp+3884]
  0062b	51		 push	 ecx
  0062c	56		 push	 esi
  0062d	e8 00 00 00 00	 call	 _GetCrc32
  00632	8b 54 24 28	 mov	 edx, DWORD PTR _tmpFileSize$80515[esp+3892]
  00636	52		 push	 edx
  00637	c1 e8 18	 shr	 eax, 24			; 00000018H
  0063a	56		 push	 esi
  0063b	88 44 24 2c	 mov	 BYTE PTR _szTmp32bit$[esp+3900], al
  0063f	e8 00 00 00 00	 call	 _GetCrc32
  00644	c1 e8 10	 shr	 eax, 16			; 00000010H
  00647	88 44 24 2d	 mov	 BYTE PTR _szTmp32bit$[esp+3901], al
  0064b	8b 44 24 30	 mov	 eax, DWORD PTR _tmpFileSize$80515[esp+3900]
  0064f	50		 push	 eax
  00650	56		 push	 esi
  00651	e8 00 00 00 00	 call	 _GetCrc32
  00656	8b 4c 24 38	 mov	 ecx, DWORD PTR _tmpFileSize$80515[esp+3908]
  0065a	51		 push	 ecx
  0065b	c1 e8 08	 shr	 eax, 8
  0065e	56		 push	 esi
  0065f	88 44 24 3e	 mov	 BYTE PTR _szTmp32bit$[esp+3918], al
  00663	e8 00 00 00 00	 call	 _GetCrc32

; 418  : 		free (tmpBuffer);

  00668	56		 push	 esi
  00669	88 44 24 43	 mov	 BYTE PTR _szTmp32bit$[esp+3923], al
  0066d	e8 00 00 00 00	 call	 _free

; 419  : 
; 420  : 		if (!SaveBufferToFile (szTmp32bit, outputFile, sizeof (szTmp32bit), TRUE))

  00672	6a 01		 push	 1
  00674	6a 04		 push	 4
  00676	8d 54 24 60	 lea	 edx, DWORD PTR _outputFile$[esp+3928]
  0067a	52		 push	 edx
  0067b	8d 44 24 4c	 lea	 eax, DWORD PTR _szTmp32bit$[esp+3932]
  0067f	50		 push	 eax
  00680	e8 00 00 00 00	 call	 _SaveBufferToFile
  00685	83 c4 40	 add	 esp, 64			; 00000040H
  00688	85 c0		 test	 eax, eax
  0068a	75 1b		 jne	 SHORT $LN3@MakeSelfEx

; 421  : 		{
; 422  : 			remove (outputFile);

  0068c	8d 4c 24 28	 lea	 ecx, DWORD PTR _outputFile$[esp+3872]
  00690	51		 push	 ecx
  00691	e8 00 00 00 00	 call	 _remove
  00696	83 c4 04	 add	 esp, 4

; 423  : 			PkgError ("Cannot write the total size of the compressed data");

  00699	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0DD@BPNJOCGM@Cannot?5write?5the?5total?5size?5of?5t@
  0069e	e8 00 00 00 00	 call	 _PkgError

; 437  : 
; 438  : 	return FALSE;

  006a3	33 c0		 xor	 eax, eax
  006a5	eb 39		 jmp	 SHORT $LN24@MakeSelfEx
$LN3@MakeSelfEx:

; 424  : 			goto err;
; 425  : 		}
; 426  : 	}
; 427  : 
; 428  : 	sprintf (tmpStr, "Self-extracting package successfully created (%s)", outputFile);

  006a7	8d 54 24 28	 lea	 edx, DWORD PTR _outputFile$[esp+3872]
  006ab	52		 push	 edx
  006ac	8d 84 24 20 07
	00 00		 lea	 eax, DWORD PTR _tmpStr$[esp+3876]
  006b3	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@MFPOOIGB@Self?9extracting?5package?5successf@
  006b8	50		 push	 eax
  006b9	e8 00 00 00 00	 call	 _sprintf
  006be	83 c4 0c	 add	 esp, 12			; 0000000cH

; 429  : 	PkgInfo (tmpStr);

  006c1	68 40 00 05 00	 push	 327744			; 00050040H
  006c6	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FEEFGEIL@CipherShed?$AA@
  006cb	8d 8c 24 24 07
	00 00		 lea	 ecx, DWORD PTR _tmpStr$[esp+3880]
  006d2	51		 push	 ecx
  006d3	6a 00		 push	 0
  006d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 430  : 	return TRUE;

  006db	b8 01 00 00 00	 mov	 eax, 1
$LN24@MakeSelfEx:

; 439  : }

  006e0	8b 8c 24 1c 0f
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+3872]
  006e7	5f		 pop	 edi
  006e8	5e		 pop	 esi
  006e9	5d		 pop	 ebp
  006ea	5b		 pop	 ebx
  006eb	33 cc		 xor	 ecx, esp
  006ed	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006f2	81 c4 10 0f 00
	00		 add	 esp, 3856		; 00000f10H
  006f8	c3		 ret	 0
_MakeSelfExtractingPackage ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@FDGMLBCO@CANT_VERIFY_PACKAGE_INTEGRITY?$AA@ ; `string'
PUBLIC	??_C@_0BH@LJNMHMFF@DIST_PACKAGE_CORRUPTED?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_VerifyPackageIntegrity
EXTRN	_LoadInt32:PROC
EXTRN	_Error:PROC
EXTRN	_FindStringInFile:PROC
;	COMDAT ??_C@_0BO@FDGMLBCO@CANT_VERIFY_PACKAGE_INTEGRITY?$AA@
CONST	SEGMENT
??_C@_0BO@FDGMLBCO@CANT_VERIFY_PACKAGE_INTEGRITY?$AA@ DB 'CANT_VERIFY_PAC'
	DB	'KAGE_INTEGRITY', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LJNMHMFF@DIST_PACKAGE_CORRUPTED?$AA@
CONST	SEGMENT
??_C@_0BH@LJNMHMFF@DIST_PACKAGE_CORRUPTED?$AA@ DB 'DIST_PACKAGE_CORRUPTED'
	DB	00H						; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _VerifyPackageIntegrity
_TEXT	SEGMENT
_crc$ = -272						; size = 4
_tmpFileSize$ = -268					; size = 4
_path$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_VerifyPackageIntegrity PROC				; COMDAT

; 444  : {

  00000	81 ec 10 01 00
	00		 sub	 esp, 272		; 00000110H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 0c 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+272], eax

; 445  : 	int fileDataEndPos = 0;
; 446  : 	int fileDataStartPos = 0;
; 447  : 	unsigned __int32 crc = 0;
; 448  : 	unsigned char *tmpBuffer;
; 449  : 	int tmpFileSize;
; 450  : 	char path [TC_MAX_PATH];
; 451  : 
; 452  : 	GetModuleFileName (NULL, path, sizeof (path));

  00014	68 04 01 00 00	 push	 260			; 00000104H
  00019	8d 44 24 0c	 lea	 eax, DWORD PTR _path$[esp+276]
  0001d	50		 push	 eax
  0001e	6a 00		 push	 0
  00020	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _crc$[esp+284], 0
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12

; 453  : 
; 454  : 	fileDataEndPos = (int) FindStringInFile (path, MagEndMarker, strlen (MagEndMarker));

  0002e	b8 00 00 00 00	 mov	 eax, OFFSET _MagEndMarker
  00033	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL10@VerifyPack:
  00036	8a 08		 mov	 cl, BYTE PTR [eax]
  00038	40		 inc	 eax
  00039	84 c9		 test	 cl, cl
  0003b	75 f9		 jne	 SHORT $LL10@VerifyPack
  0003d	57		 push	 edi
  0003e	2b c2		 sub	 eax, edx
  00040	50		 push	 eax
  00041	8d 4c 24 10	 lea	 ecx, DWORD PTR _path$[esp+280]
  00045	68 00 00 00 00	 push	 OFFSET _MagEndMarker
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 _FindStringInFile
  00050	8b f8		 mov	 edi, eax
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH

; 455  : 	if (fileDataEndPos < 0)

  00055	85 ff		 test	 edi, edi
  00057	7d 25		 jge	 SHORT $LN5@VerifyPack
$LN14@VerifyPack:

; 456  : 	{
; 457  : 		Error ("DIST_PACKAGE_CORRUPTED");

  00059	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LJNMHMFF@DIST_PACKAGE_CORRUPTED?$AA@
  0005e	e8 00 00 00 00	 call	 _Error
  00063	83 c4 04	 add	 esp, 4

; 458  : 		return FALSE;

  00066	33 c0		 xor	 eax, eax
  00068	5f		 pop	 edi

; 497  : 
; 498  : 	return TRUE;
; 499  : }

  00069	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+272]
  00070	33 cc		 xor	 ecx, esp
  00072	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00077	81 c4 10 01 00
	00		 add	 esp, 272		; 00000110H
  0007d	c3		 ret	 0
$LN5@VerifyPack:

; 459  : 	}
; 460  : 	fileDataEndPos--;
; 461  : 
; 462  : 	fileDataStartPos = (int) FindStringInFile (path, MAG_START_MARKER, strlen (MAG_START_MARKER));

  0007e	6a 08		 push	 8
  00080	8d 54 24 10	 lea	 edx, DWORD PTR _path$[esp+280]
  00084	68 00 00 00 00	 push	 OFFSET ??_C@_08PPKICKPD@TCINSTRT?$AA@
  00089	52		 push	 edx
  0008a	4f		 dec	 edi
  0008b	e8 00 00 00 00	 call	 _FindStringInFile
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH

; 463  : 	if (fileDataStartPos < 0)

  00093	85 c0		 test	 eax, eax

; 464  : 	{
; 465  : 		Error ("DIST_PACKAGE_CORRUPTED");
; 466  : 		return FALSE;

  00095	7c c2		 jl	 SHORT $LN14@VerifyPack

; 467  : 	}
; 468  : 	fileDataStartPos += strlen (MAG_START_MARKER);
; 469  : 
; 470  : 
; 471  : 	if (!LoadInt32 (path, &crc, fileDataEndPos + strlen (MagEndMarker) + 1))

  00097	b8 00 00 00 00	 mov	 eax, OFFSET _MagEndMarker
  0009c	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0009f	90		 npad	 1
$LL11@VerifyPack:
  000a0	8a 08		 mov	 cl, BYTE PTR [eax]
  000a2	40		 inc	 eax
  000a3	84 c9		 test	 cl, cl
  000a5	75 f9		 jne	 SHORT $LL11@VerifyPack
  000a7	2b c2		 sub	 eax, edx
  000a9	6a 00		 push	 0
  000ab	8d 44 38 01	 lea	 eax, DWORD PTR [eax+edi+1]
  000af	50		 push	 eax
  000b0	8d 4c 24 0c	 lea	 ecx, DWORD PTR _crc$[esp+284]
  000b4	51		 push	 ecx
  000b5	8d 54 24 18	 lea	 edx, DWORD PTR _path$[esp+288]
  000b9	52		 push	 edx
  000ba	e8 00 00 00 00	 call	 _LoadInt32
  000bf	83 c4 10	 add	 esp, 16			; 00000010H
  000c2	85 c0		 test	 eax, eax
  000c4	75 25		 jne	 SHORT $LN3@VerifyPack

; 472  : 	{
; 473  : 		Error ("CANT_VERIFY_PACKAGE_INTEGRITY");

  000c6	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FDGMLBCO@CANT_VERIFY_PACKAGE_INTEGRITY?$AA@
  000cb	e8 00 00 00 00	 call	 _Error
  000d0	83 c4 04	 add	 esp, 4

; 474  : 		return FALSE;

  000d3	33 c0		 xor	 eax, eax
  000d5	5f		 pop	 edi

; 497  : 
; 498  : 	return TRUE;
; 499  : }

  000d6	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+272]
  000dd	33 cc		 xor	 ecx, esp
  000df	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e4	81 c4 10 01 00
	00		 add	 esp, 272		; 00000110H
  000ea	c3		 ret	 0
$LN3@VerifyPack:
  000eb	56		 push	 esi

; 475  : 	}
; 476  : 
; 477  : 	// Compute the CRC-32 hash of the whole file (except the digital signature area, if present)
; 478  : 	tmpBuffer = LoadFile (path, &tmpFileSize);

  000ec	8d 44 24 0c	 lea	 eax, DWORD PTR _tmpFileSize$[esp+280]
  000f0	50		 push	 eax
  000f1	8d 4c 24 14	 lea	 ecx, DWORD PTR _path$[esp+284]
  000f5	51		 push	 ecx
  000f6	e8 00 00 00 00	 call	 _LoadFile
  000fb	8b f0		 mov	 esi, eax
  000fd	83 c4 08	 add	 esp, 8

; 479  : 
; 480  : 	if (tmpBuffer == NULL)

  00100	85 f6		 test	 esi, esi
  00102	75 26		 jne	 SHORT $LN2@VerifyPack

; 481  : 	{
; 482  : 		Error ("CANT_VERIFY_PACKAGE_INTEGRITY");

  00104	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FDGMLBCO@CANT_VERIFY_PACKAGE_INTEGRITY?$AA@
  00109	e8 00 00 00 00	 call	 _Error
  0010e	83 c4 04	 add	 esp, 4
  00111	5e		 pop	 esi

; 483  : 		return FALSE;

  00112	33 c0		 xor	 eax, eax
  00114	5f		 pop	 edi

; 497  : 
; 498  : 	return TRUE;
; 499  : }

  00115	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+272]
  0011c	33 cc		 xor	 ecx, esp
  0011e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00123	81 c4 10 01 00
	00		 add	 esp, 272		; 00000110H
  00129	c3		 ret	 0
$LN2@VerifyPack:

; 484  : 	}
; 485  : 
; 486  : 	// Zero all bytes that change when an exe is digitally signed (except appended blocks).
; 487  : 	WipeSignatureAreas (tmpBuffer);

  0012a	68 d0 00 00 00	 push	 208			; 000000d0H
  0012f	8d 96 30 01 00
	00		 lea	 edx, DWORD PTR [esi+304]
  00135	6a 00		 push	 0
  00137	52		 push	 edx
  00138	e8 00 00 00 00	 call	 _memset

; 488  : 
; 489  : 	if (crc != GetCrc32 (tmpBuffer, fileDataEndPos + 1 + strlen (MagEndMarker)))

  0013d	b8 00 00 00 00	 mov	 eax, OFFSET _MagEndMarker
  00142	83 c4 0c	 add	 esp, 12			; 0000000cH
  00145	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL12@VerifyPack:
  00148	8a 08		 mov	 cl, BYTE PTR [eax]
  0014a	40		 inc	 eax
  0014b	84 c9		 test	 cl, cl
  0014d	75 f9		 jne	 SHORT $LL12@VerifyPack
  0014f	2b c2		 sub	 eax, edx
  00151	8d 44 38 01	 lea	 eax, DWORD PTR [eax+edi+1]
  00155	50		 push	 eax
  00156	56		 push	 esi
  00157	e8 00 00 00 00	 call	 _GetCrc32
  0015c	83 c4 08	 add	 esp, 8

; 490  : 	{
; 491  : 		free (tmpBuffer);

  0015f	56		 push	 esi
  00160	39 44 24 0c	 cmp	 DWORD PTR _crc$[esp+284], eax
  00164	74 2b		 je	 SHORT $LN1@VerifyPack
  00166	e8 00 00 00 00	 call	 _free

; 492  : 		Error ("DIST_PACKAGE_CORRUPTED");

  0016b	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LJNMHMFF@DIST_PACKAGE_CORRUPTED?$AA@
  00170	e8 00 00 00 00	 call	 _Error
  00175	83 c4 08	 add	 esp, 8
  00178	5e		 pop	 esi

; 493  : 		return FALSE;

  00179	33 c0		 xor	 eax, eax
  0017b	5f		 pop	 edi

; 497  : 
; 498  : 	return TRUE;
; 499  : }

  0017c	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+272]
  00183	33 cc		 xor	 ecx, esp
  00185	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0018a	81 c4 10 01 00
	00		 add	 esp, 272		; 00000110H
  00190	c3		 ret	 0
$LN1@VerifyPack:

; 494  : 	}
; 495  : 
; 496  : 	free (tmpBuffer);

  00191	e8 00 00 00 00	 call	 _free

; 497  : 
; 498  : 	return TRUE;
; 499  : }

  00196	8b 8c 24 18 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+284]
  0019d	83 c4 04	 add	 esp, 4
  001a0	5e		 pop	 esi
  001a1	5f		 pop	 edi
  001a2	33 cc		 xor	 ecx, esp
  001a4	b8 01 00 00 00	 mov	 eax, 1
  001a9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ae	81 c4 10 01 00
	00		 add	 esp, 272		; 00000110H
  001b4	c3		 ret	 0
_VerifyPackageIntegrity ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_IsSelfExtractingPackage
; Function compile flags: /Ogtpy
;	COMDAT _IsSelfExtractingPackage
_TEXT	SEGMENT
_path$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_IsSelfExtractingPackage PROC				; COMDAT

; 504  : {

  00000	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 04 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+264], eax

; 505  : 	char path [TC_MAX_PATH];
; 506  : 
; 507  : 	GetModuleFileName (NULL, path, sizeof (path));

  00014	68 04 01 00 00	 push	 260			; 00000104H
  00019	8d 44 24 04	 lea	 eax, DWORD PTR _path$[esp+268]
  0001d	50		 push	 eax
  0001e	6a 00		 push	 0
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12

; 508  : 
; 509  : 	return (FindStringInFile (path, MagEndMarker, strlen (MagEndMarker)) != -1);

  00026	b8 00 00 00 00	 mov	 eax, OFFSET _MagEndMarker
  0002b	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0002e	8b ff		 npad	 2
$LL5@IsSelfExtr:
  00030	8a 08		 mov	 cl, BYTE PTR [eax]
  00032	40		 inc	 eax
  00033	84 c9		 test	 cl, cl
  00035	75 f9		 jne	 SHORT $LL5@IsSelfExtr
  00037	2b c2		 sub	 eax, edx
  00039	50		 push	 eax
  0003a	8d 4c 24 04	 lea	 ecx, DWORD PTR _path$[esp+268]
  0003e	68 00 00 00 00	 push	 OFFSET _MagEndMarker
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 _FindStringInFile
  00049	23 c2		 and	 eax, edx
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004e	83 f8 ff	 cmp	 eax, -1
  00051	74 1a		 je	 SHORT $LN3@IsSelfExtr
  00053	b8 01 00 00 00	 mov	 eax, 1

; 510  : }

  00058	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+264]
  0005f	33 cc		 xor	 ecx, esp
  00061	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00066	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  0006c	c3		 ret	 0
$LN3@IsSelfExtr:
  0006d	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+264]
  00074	33 cc		 xor	 ecx, esp
  00076	33 c0		 xor	 eax, eax
  00078	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007d	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  00083	c3		 ret	 0
_IsSelfExtractingPackage ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _FreeAllFileBuffers
_TEXT	SEGMENT
_FreeAllFileBuffers PROC				; COMDAT

; 515  : 	int fileNo;
; 516  : 
; 517  : 	if (DecompressedData != NULL)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _DecompressedData
  00005	56		 push	 esi
  00006	33 f6		 xor	 esi, esi
  00008	3b c6		 cmp	 eax, esi
  0000a	74 0f		 je	 SHORT $LN4@FreeAllFil

; 518  : 	{
; 519  : 		free (DecompressedData);

  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _free
  00012	83 c4 04	 add	 esp, 4

; 520  : 		DecompressedData = NULL;

  00015	89 35 00 00 00
	00		 mov	 DWORD PTR _DecompressedData, esi
$LN4@FreeAllFil:

; 521  : 	}
; 522  : 
; 523  : 	for (fileNo = 0; fileNo < NBR_COMPRESSED_FILES; fileNo++)
; 524  : 	{
; 525  : 		Decompressed_Files[fileNo].fileName = NULL;

  0001b	89 35 00 00 00
	00		 mov	 DWORD PTR _Decompressed_Files, esi

; 526  : 		Decompressed_Files[fileNo].fileContent = NULL;

  00021	89 35 10 00 00
	00		 mov	 DWORD PTR _Decompressed_Files+16, esi

; 527  : 		Decompressed_Files[fileNo].fileNameLength = 0;

  00027	89 35 04 00 00
	00		 mov	 DWORD PTR _Decompressed_Files+4, esi

; 528  : 		Decompressed_Files[fileNo].fileLength = 0;

  0002d	89 35 0c 00 00
	00		 mov	 DWORD PTR _Decompressed_Files+12, esi

; 529  : 		Decompressed_Files[fileNo].crc = 0;

  00033	89 35 08 00 00
	00		 mov	 DWORD PTR _Decompressed_Files+8, esi
  00039	89 35 14 00 00
	00		 mov	 DWORD PTR _Decompressed_Files+20, esi
  0003f	89 35 24 00 00
	00		 mov	 DWORD PTR _Decompressed_Files+36, esi
  00045	89 35 18 00 00
	00		 mov	 DWORD PTR _Decompressed_Files+24, esi
  0004b	89 35 20 00 00
	00		 mov	 DWORD PTR _Decompressed_Files+32, esi
  00051	89 35 1c 00 00
	00		 mov	 DWORD PTR _Decompressed_Files+28, esi
  00057	89 35 28 00 00
	00		 mov	 DWORD PTR _Decompressed_Files+40, esi
  0005d	89 35 38 00 00
	00		 mov	 DWORD PTR _Decompressed_Files+56, esi
  00063	89 35 2c 00 00
	00		 mov	 DWORD PTR _Decompressed_Files+44, esi
  00069	89 35 34 00 00
	00		 mov	 DWORD PTR _Decompressed_Files+52, esi
  0006f	89 35 30 00 00
	00		 mov	 DWORD PTR _Decompressed_Files+48, esi
  00075	89 35 3c 00 00
	00		 mov	 DWORD PTR _Decompressed_Files+60, esi
  0007b	89 35 4c 00 00
	00		 mov	 DWORD PTR _Decompressed_Files+76, esi
  00081	89 35 40 00 00
	00		 mov	 DWORD PTR _Decompressed_Files+64, esi
  00087	89 35 48 00 00
	00		 mov	 DWORD PTR _Decompressed_Files+72, esi
  0008d	89 35 44 00 00
	00		 mov	 DWORD PTR _Decompressed_Files+68, esi
  00093	89 35 50 00 00
	00		 mov	 DWORD PTR _Decompressed_Files+80, esi
  00099	89 35 60 00 00
	00		 mov	 DWORD PTR _Decompressed_Files+96, esi
  0009f	89 35 54 00 00
	00		 mov	 DWORD PTR _Decompressed_Files+84, esi
  000a5	89 35 5c 00 00
	00		 mov	 DWORD PTR _Decompressed_Files+92, esi
  000ab	89 35 58 00 00
	00		 mov	 DWORD PTR _Decompressed_Files+88, esi
  000b1	89 35 64 00 00
	00		 mov	 DWORD PTR _Decompressed_Files+100, esi
  000b7	89 35 74 00 00
	00		 mov	 DWORD PTR _Decompressed_Files+116, esi
  000bd	89 35 68 00 00
	00		 mov	 DWORD PTR _Decompressed_Files+104, esi
  000c3	89 35 70 00 00
	00		 mov	 DWORD PTR _Decompressed_Files+112, esi
  000c9	89 35 6c 00 00
	00		 mov	 DWORD PTR _Decompressed_Files+108, esi
  000cf	5e		 pop	 esi

; 530  : 	}
; 531  : }

  000d0	c3		 ret	 0
_FreeAllFileBuffers ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@JJNKJOK@ERR_MEM_ALLOC?$AA@		; `string'
PUBLIC	??_C@_0BJ@OFFDHJBA@CANNOT_READ_FROM_PACKAGE?$AA@ ; `string'
PUBLIC	_SelfExtractInMemory
EXTRN	_LoadFileBlock:PROC
;	COMDAT ??_C@_0O@JJNKJOK@ERR_MEM_ALLOC?$AA@
CONST	SEGMENT
??_C@_0O@JJNKJOK@ERR_MEM_ALLOC?$AA@ DB 'ERR_MEM_ALLOC', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OFFDHJBA@CANNOT_READ_FROM_PACKAGE?$AA@
CONST	SEGMENT
??_C@_0BJ@OFFDHJBA@CANNOT_READ_FROM_PACKAGE?$AA@ DB 'CANNOT_READ_FROM_PAC'
	DB	'KAGE', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _SelfExtractInMemory
_TEXT	SEGMENT
_compressedLen$ = -16					; size = 4
_uncompressedLen$ = -12					; size = 4
_fileNo$ = -8						; size = 4
_bufEndPos$ = -4					; size = 4
_path$ = 8						; size = 4
_SelfExtractInMemory PROC				; COMDAT

; 539  : {

  00000	83 ec 10	 sub	 esp, 16			; 00000010H
  00003	53		 push	 ebx

; 540  : 	int filePos = 0, fileNo = 0;

  00004	33 db		 xor	 ebx, ebx
  00006	55		 push	 ebp
  00007	56		 push	 esi
  00008	89 5c 24 14	 mov	 DWORD PTR _fileNo$[esp+28], ebx

; 541  : 	int fileDataEndPos = 0;
; 542  : 	int fileDataStartPos = 0;
; 543  : 	int uncompressedLen = 0;

  0000c	89 5c 24 10	 mov	 DWORD PTR _uncompressedLen$[esp+28], ebx

; 544  : 	int compressedLen = 0;

  00010	89 5c 24 0c	 mov	 DWORD PTR _compressedLen$[esp+28], ebx

; 545  : 	unsigned char *compressedData = NULL;
; 546  : 	unsigned char *bufPos = NULL, *bufEndPos = NULL;
; 547  : 
; 548  : 	FreeAllFileBuffers();

  00014	e8 00 00 00 00	 call	 _FreeAllFileBuffers

; 549  : 
; 550  : 	fileDataEndPos = (int) FindStringInFile (path, MagEndMarker, strlen (MagEndMarker));

  00019	b8 00 00 00 00	 mov	 eax, OFFSET _MagEndMarker
  0001e	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL21@SelfExtrac:
  00021	8a 08		 mov	 cl, BYTE PTR [eax]
  00023	40		 inc	 eax
  00024	84 c9		 test	 cl, cl
  00026	75 f9		 jne	 SHORT $LL21@SelfExtrac
  00028	8b 6c 24 20	 mov	 ebp, DWORD PTR _path$[esp+24]
  0002c	2b c2		 sub	 eax, edx
  0002e	50		 push	 eax
  0002f	68 00 00 00 00	 push	 OFFSET _MagEndMarker
  00034	55		 push	 ebp
  00035	e8 00 00 00 00	 call	 _FindStringInFile
  0003a	8b f0		 mov	 esi, eax
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 551  : 	if (fileDataEndPos < 0)

  0003f	3b f3		 cmp	 esi, ebx
  00041	7d 16		 jge	 SHORT $LN12@SelfExtrac

; 552  : 	{
; 553  : 		Error ("CANNOT_READ_FROM_PACKAGE");

  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@OFFDHJBA@CANNOT_READ_FROM_PACKAGE?$AA@
  00048	e8 00 00 00 00	 call	 _Error
  0004d	83 c4 04	 add	 esp, 4
  00050	5e		 pop	 esi
  00051	5d		 pop	 ebp

; 554  : 		return FALSE;

  00052	33 c0		 xor	 eax, eax
  00054	5b		 pop	 ebx

; 664  : }

  00055	83 c4 10	 add	 esp, 16			; 00000010H
  00058	c3		 ret	 0
$LN12@SelfExtrac:
  00059	57		 push	 edi

; 555  : 	}
; 556  : 
; 557  : 	fileDataEndPos--;
; 558  : 
; 559  : 	fileDataStartPos = (int) FindStringInFile (path, MAG_START_MARKER, strlen (MAG_START_MARKER));

  0005a	6a 08		 push	 8
  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_08PPKICKPD@TCINSTRT?$AA@
  00061	55		 push	 ebp
  00062	e8 00 00 00 00	 call	 _FindStringInFile
  00067	8b f8		 mov	 edi, eax
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 560  : 	if (fileDataStartPos < 0)

  0006c	3b fb		 cmp	 edi, ebx

; 561  : 	{
; 562  : 		Error ("CANNOT_READ_FROM_PACKAGE");
; 563  : 		return FALSE;

  0006e	7c 34		 jl	 SHORT $LN24@SelfExtrac

; 564  : 	}
; 565  : 
; 566  : 	fileDataStartPos += strlen (MAG_START_MARKER);

  00070	83 c7 08	 add	 edi, 8

; 567  : 
; 568  : 	filePos = fileDataStartPos;
; 569  : 
; 570  : 	// Read the stored total size of the uncompressed data
; 571  : 	if (!LoadInt32 (path, &uncompressedLen, filePos))

  00073	8b c7		 mov	 eax, edi
  00075	99		 cdq
  00076	52		 push	 edx
  00077	50		 push	 eax
  00078	8d 44 24 1c	 lea	 eax, DWORD PTR _uncompressedLen$[esp+40]
  0007c	50		 push	 eax
  0007d	55		 push	 ebp
  0007e	e8 00 00 00 00	 call	 _LoadInt32
  00083	83 c4 10	 add	 esp, 16			; 00000010H
  00086	85 c0		 test	 eax, eax

; 572  : 	{
; 573  : 		Error ("CANNOT_READ_FROM_PACKAGE");
; 574  : 		return FALSE;

  00088	74 1a		 je	 SHORT $LN24@SelfExtrac

; 575  : 	}
; 576  : 
; 577  : 	filePos += 4;

  0008a	8d 5f 04	 lea	 ebx, DWORD PTR [edi+4]

; 578  : 
; 579  : 	// Read the stored total size of the compressed data
; 580  : 	if (!LoadInt32 (path, &compressedLen, filePos))

  0008d	8b c3		 mov	 eax, ebx
  0008f	99		 cdq
  00090	52		 push	 edx
  00091	50		 push	 eax
  00092	8d 4c 24 18	 lea	 ecx, DWORD PTR _compressedLen$[esp+40]
  00096	51		 push	 ecx
  00097	55		 push	 ebp
  00098	e8 00 00 00 00	 call	 _LoadInt32
  0009d	83 c4 10	 add	 esp, 16			; 00000010H
  000a0	85 c0		 test	 eax, eax
  000a2	75 17		 jne	 SHORT $LN9@SelfExtrac
$LN24@SelfExtrac:

; 581  : 	{
; 582  : 		Error ("CANNOT_READ_FROM_PACKAGE");

  000a4	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@OFFDHJBA@CANNOT_READ_FROM_PACKAGE?$AA@
  000a9	e8 00 00 00 00	 call	 _Error
  000ae	83 c4 04	 add	 esp, 4
  000b1	5f		 pop	 edi
  000b2	5e		 pop	 esi
  000b3	5d		 pop	 ebp

; 583  : 		return FALSE;

  000b4	33 c0		 xor	 eax, eax
  000b6	5b		 pop	 ebx

; 664  : }

  000b7	83 c4 10	 add	 esp, 16			; 00000010H
  000ba	c3		 ret	 0
$LN9@SelfExtrac:

; 584  : 	}
; 585  : 
; 586  : 	filePos += 4;
; 587  : 
; 588  : 	if (compressedLen != fileDataEndPos - fileDataStartPos - 8 + 1)

  000bb	2b f7		 sub	 esi, edi
  000bd	83 ee 08	 sub	 esi, 8
  000c0	83 c3 04	 add	 ebx, 4
  000c3	39 74 24 10	 cmp	 DWORD PTR _compressedLen$[esp+32], esi
  000c7	74 0d		 je	 SHORT $LN22@SelfExtrac

; 589  : 	{
; 590  : 		Error ("DIST_PACKAGE_CORRUPTED");

  000c9	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LJNMHMFF@DIST_PACKAGE_CORRUPTED?$AA@
  000ce	e8 00 00 00 00	 call	 _Error
  000d3	83 c4 04	 add	 esp, 4
$LN22@SelfExtrac:

; 591  : 	}
; 592  : 
; 593  : 	DecompressedData = malloc (uncompressedLen + 524288);	// + 512K reserve 

  000d6	8b 54 24 14	 mov	 edx, DWORD PTR _uncompressedLen$[esp+32]
  000da	81 c2 00 00 08
	00		 add	 edx, 524288		; 00080000H
  000e0	52		 push	 edx
  000e1	e8 00 00 00 00	 call	 _malloc
  000e6	83 c4 04	 add	 esp, 4
  000e9	a3 00 00 00 00	 mov	 DWORD PTR _DecompressedData, eax

; 594  : 	if (DecompressedData == NULL)

  000ee	85 c0		 test	 eax, eax
  000f0	75 17		 jne	 SHORT $LN7@SelfExtrac

; 595  : 	{
; 596  : 		Error ("ERR_MEM_ALLOC");

  000f2	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JJNKJOK@ERR_MEM_ALLOC?$AA@
  000f7	e8 00 00 00 00	 call	 _Error
  000fc	83 c4 04	 add	 esp, 4
  000ff	5f		 pop	 edi
  00100	5e		 pop	 esi
  00101	5d		 pop	 ebp

; 597  : 		return FALSE;

  00102	33 c0		 xor	 eax, eax
  00104	5b		 pop	 ebx

; 664  : }

  00105	83 c4 10	 add	 esp, 16			; 00000010H
  00108	c3		 ret	 0
$LN7@SelfExtrac:

; 598  : 	}
; 599  : 
; 600  : 	bufPos = DecompressedData;
; 601  : 	bufEndPos = bufPos + uncompressedLen - 1;
; 602  : 
; 603  : 	compressedData = LoadFileBlock (path, filePos, compressedLen);

  00109	8b 4c 24 10	 mov	 ecx, DWORD PTR _compressedLen$[esp+32]
  0010d	8b f0		 mov	 esi, eax
  0010f	8b 44 24 14	 mov	 eax, DWORD PTR _uncompressedLen$[esp+32]
  00113	8d 7c 06 ff	 lea	 edi, DWORD PTR [esi+eax-1]
  00117	51		 push	 ecx
  00118	8b c3		 mov	 eax, ebx
  0011a	99		 cdq
  0011b	52		 push	 edx
  0011c	50		 push	 eax
  0011d	55		 push	 ebp
  0011e	89 7c 24 2c	 mov	 DWORD PTR _bufEndPos$[esp+48], edi
  00122	e8 00 00 00 00	 call	 _LoadFileBlock
  00127	8b d8		 mov	 ebx, eax
  00129	83 c4 10	 add	 esp, 16			; 00000010H

; 604  : 
; 605  : 	if (compressedData == NULL)

  0012c	85 db		 test	 ebx, ebx
  0012e	75 29		 jne	 SHORT $LN6@SelfExtrac

; 606  : 	{
; 607  : 		free (DecompressedData);

  00130	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _DecompressedData
  00136	52		 push	 edx
  00137	e8 00 00 00 00	 call	 _free

; 608  : 		DecompressedData = NULL;
; 609  : 
; 610  : 		Error ("CANNOT_READ_FROM_PACKAGE");

  0013c	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@OFFDHJBA@CANNOT_READ_FROM_PACKAGE?$AA@
  00141	89 1d 00 00 00
	00		 mov	 DWORD PTR _DecompressedData, ebx
  00147	e8 00 00 00 00	 call	 _Error
  0014c	83 c4 08	 add	 esp, 8
  0014f	5f		 pop	 edi
  00150	5e		 pop	 esi
  00151	5d		 pop	 ebp

; 611  : 		return FALSE;

  00152	33 c0		 xor	 eax, eax
  00154	5b		 pop	 ebx

; 664  : }

  00155	83 c4 10	 add	 esp, 16			; 00000010H
  00158	c3		 ret	 0
$LN6@SelfExtrac:

; 612  : 	}
; 613  : 
; 614  : 	// Decompress the data
; 615  : 	if (DecompressBuffer (DecompressedData, compressedData, compressedLen) != uncompressedLen)

  00159	8b 44 24 10	 mov	 eax, DWORD PTR _compressedLen$[esp+32]
  0015d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _DecompressedData
  00163	50		 push	 eax
  00164	53		 push	 ebx
  00165	51		 push	 ecx
  00166	e8 00 00 00 00	 call	 _DecompressDeflatedData
  0016b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0016e	3b 44 24 14	 cmp	 eax, DWORD PTR _uncompressedLen$[esp+32]

; 616  : 	{
; 617  : 		Error ("DIST_PACKAGE_CORRUPTED");
; 618  : 		goto sem_end;

  00172	0f 85 bf 00 00
	00		 jne	 $LN20@SelfExtrac

; 619  : 	}
; 620  : 
; 621  : 	while (bufPos <= bufEndPos && fileNo < NBR_COMPRESSED_FILES)

  00178	3b f7		 cmp	 esi, edi
  0017a	0f 87 b7 00 00
	00		 ja	 $LN20@SelfExtrac
  00180	33 ff		 xor	 edi, edi
  00182	8d 6f 01	 lea	 ebp, DWORD PTR [edi+1]
$LL4@SelfExtrac:
  00185	83 ff 78	 cmp	 edi, 120		; 00000078H
  00188	0f 83 ce 00 00
	00		 jae	 $LN1@SelfExtrac

; 622  : 	{
; 623  : 		// Filename length
; 624  : 		Decompressed_Files[fileNo].fileNameLength = mgetWord (bufPos);

  0018e	0f b6 16	 movzx	 edx, BYTE PTR [esi]
  00191	0f b6 46 01	 movzx	 eax, BYTE PTR [esi+1]
  00195	83 c6 02	 add	 esi, 2
  00198	c1 e2 08	 shl	 edx, 8
  0019b	0b d0		 or	 edx, eax
  0019d	89 97 04 00 00
	00		 mov	 DWORD PTR _Decompressed_Files[edi+4], edx

; 625  : 
; 626  : 		// Filename
; 627  : 		Decompressed_Files[fileNo].fileName = bufPos;
; 628  : 		bufPos += Decompressed_Files[fileNo].fileNameLength;
; 629  : 
; 630  : 		// CRC-32 of the file
; 631  : 		Decompressed_Files[fileNo].crc = mgetLong (bufPos);

  001a3	8b ca		 mov	 ecx, edx
  001a5	89 b7 00 00 00
	00		 mov	 DWORD PTR _Decompressed_Files[edi], esi
  001ab	0f b6 14 0e	 movzx	 edx, BYTE PTR [esi+ecx]
  001af	0f b6 44 0e 01	 movzx	 eax, BYTE PTR [esi+ecx+1]
  001b4	8d 74 0e 04	 lea	 esi, DWORD PTR [esi+ecx+4]
  001b8	0f b6 4e fe	 movzx	 ecx, BYTE PTR [esi-2]
  001bc	c1 e2 08	 shl	 edx, 8
  001bf	0b d0		 or	 edx, eax
  001c1	0f b6 46 ff	 movzx	 eax, BYTE PTR [esi-1]
  001c5	c1 e2 08	 shl	 edx, 8
  001c8	0b d1		 or	 edx, ecx
  001ca	c1 e2 08	 shl	 edx, 8
  001cd	0b d0		 or	 edx, eax

; 632  : 
; 633  : 		// File length
; 634  : 		Decompressed_Files[fileNo].fileLength = mgetLong (bufPos);

  001cf	83 c6 04	 add	 esi, 4
  001d2	89 97 08 00 00
	00		 mov	 DWORD PTR _Decompressed_Files[edi+8], edx
  001d8	0f b6 4e fc	 movzx	 ecx, BYTE PTR [esi-4]
  001dc	0f b6 56 fd	 movzx	 edx, BYTE PTR [esi-3]
  001e0	0f b6 46 fe	 movzx	 eax, BYTE PTR [esi-2]
  001e4	c1 e1 08	 shl	 ecx, 8
  001e7	0b ca		 or	 ecx, edx
  001e9	0f b6 56 ff	 movzx	 edx, BYTE PTR [esi-1]
  001ed	c1 e1 08	 shl	 ecx, 8
  001f0	0b c8		 or	 ecx, eax
  001f2	c1 e1 08	 shl	 ecx, 8
  001f5	0b ca		 or	 ecx, edx

; 635  : 
; 636  : 		// File content
; 637  : 		Decompressed_Files[fileNo].fileContent = bufPos;
; 638  : 		bufPos += Decompressed_Files[fileNo].fileLength;

  001f7	8b c1		 mov	 eax, ecx
  001f9	89 b7 10 00 00
	00		 mov	 DWORD PTR _Decompressed_Files[edi+16], esi

; 639  : 
; 640  : 		// Verify CRC-32 of the file (to verify that it didn't get corrupted while creating the solid archive).
; 641  : 		if (Decompressed_Files[fileNo].crc 
; 642  : 			!= GetCrc32 (Decompressed_Files[fileNo].fileContent, Decompressed_Files[fileNo].fileLength))

  001ff	50		 push	 eax
  00200	03 f0		 add	 esi, eax
  00202	8b 87 10 00 00
	00		 mov	 eax, DWORD PTR _Decompressed_Files[edi+16]
  00208	50		 push	 eax
  00209	89 8f 0c 00 00
	00		 mov	 DWORD PTR _Decompressed_Files[edi+12], ecx
  0020f	e8 00 00 00 00	 call	 _GetCrc32
  00214	83 c4 08	 add	 esp, 8
  00217	39 87 08 00 00
	00		 cmp	 DWORD PTR _Decompressed_Files[edi+8], eax
  0021d	75 18		 jne	 SHORT $LN20@SelfExtrac

; 643  : 		{
; 644  : 			Error ("DIST_PACKAGE_CORRUPTED");
; 645  : 			goto sem_end;
; 646  : 		}
; 647  : 
; 648  : 		fileNo++;

  0021f	01 6c 24 18	 add	 DWORD PTR _fileNo$[esp+32], ebp
  00223	83 c7 14	 add	 edi, 20			; 00000014H
  00226	3b 74 24 1c	 cmp	 esi, DWORD PTR _bufEndPos$[esp+32]
  0022a	0f 86 55 ff ff
	ff		 jbe	 $LL4@SelfExtrac

; 649  : 	}
; 650  : 
; 651  : 	if (fileNo < NBR_COMPRESSED_FILES)

  00230	83 7c 24 18 06	 cmp	 DWORD PTR _fileNo$[esp+32], 6
  00235	73 25		 jae	 SHORT $LN1@SelfExtrac
$LN20@SelfExtrac:

; 652  : 	{
; 653  : 		Error ("DIST_PACKAGE_CORRUPTED");

  00237	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LJNMHMFF@DIST_PACKAGE_CORRUPTED?$AA@
  0023c	e8 00 00 00 00	 call	 _Error
  00241	83 c4 04	 add	 esp, 4
$sem_end$80593:

; 659  : 
; 660  : sem_end:
; 661  : 	FreeAllFileBuffers();

  00244	e8 00 00 00 00	 call	 _FreeAllFileBuffers

; 662  : 	free (compressedData);

  00249	53		 push	 ebx
  0024a	e8 00 00 00 00	 call	 _free
  0024f	83 c4 04	 add	 esp, 4
  00252	5f		 pop	 edi
  00253	5e		 pop	 esi
  00254	5d		 pop	 ebp

; 663  : 	return FALSE;

  00255	33 c0		 xor	 eax, eax
  00257	5b		 pop	 ebx

; 664  : }

  00258	83 c4 10	 add	 esp, 16			; 00000010H
  0025b	c3		 ret	 0
$LN1@SelfExtrac:

; 654  : 		goto sem_end;
; 655  : 	}
; 656  : 
; 657  : 	free (compressedData);

  0025c	53		 push	 ebx
  0025d	e8 00 00 00 00	 call	 _free
  00262	83 c4 04	 add	 esp, 4
  00265	5f		 pop	 edi
  00266	5e		 pop	 esi

; 658  : 	return TRUE;

  00267	8b c5		 mov	 eax, ebp
  00269	5d		 pop	 ebp
  0026a	5b		 pop	 ebx

; 664  : }

  0026b	83 c4 10	 add	 esp, 16			; 00000010H
  0026e	c3		 ret	 0
_SelfExtractInMemory ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@BADKJOBO@CANNOT_WRITE_FILE_X?$AA@	; `string'
PUBLIC	__real@4059000000000000
PUBLIC	__real@4018000000000000
PUBLIC	??_C@_0BA@IBCNACGH@EXTRACTING_VERB?$AA@		; `string'
PUBLIC	??_C@_0BD@KJOFIBFE@CANT_CREATE_FOLDER?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_ExtractAllFilesThread
EXTRN	__imp__PostMessageA@16:PROC
EXTRN	_MainDlg:DWORD
EXTRN	__snwprintf:PROC
EXTRN	_UpdateProgressBarProc:PROC
EXTRN	_StatusMessageParam:PROC
EXTRN	_strncpy:PROC
EXTRN	__imp__MessageBoxW@16:PROC
EXTRN	_lpszTitle:DWORD
EXTRN	__imp__wsprintfW:PROC
EXTRN	_GetString:PROC
EXTRN	_mkfulldir:PROC
EXTRN	_ClearLogWindow:PROC
EXTRN	__imp__InvalidateRect@12:PROC
EXTRN	__imp__GetDlgItem@8:PROC
EXTRN	__imp__GetParent@4:PROC
EXTRN	__fltused:DWORD
EXTRN	__ftol2_sse:PROC
;	COMDAT ??_C@_0BE@BADKJOBO@CANNOT_WRITE_FILE_X?$AA@
CONST	SEGMENT
??_C@_0BE@BADKJOBO@CANNOT_WRITE_FILE_X?$AA@ DB 'CANNOT_WRITE_FILE_X', 00H ; `string'
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@4018000000000000
CONST	SEGMENT
__real@4018000000000000 DQ 04018000000000000r	; 6
CONST	ENDS
;	COMDAT ??_C@_0BA@IBCNACGH@EXTRACTING_VERB?$AA@
CONST	SEGMENT
??_C@_0BA@IBCNACGH@EXTRACTING_VERB?$AA@ DB 'EXTRACTING_VERB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KJOFIBFE@CANT_CREATE_FOLDER?$AA@
CONST	SEGMENT
??_C@_0BD@KJOFIBFE@CANT_CREATE_FOLDER?$AA@ DB 'CANT_CREATE_FOLDER', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _ExtractAllFilesThread
_TEXT	SEGMENT
_fileNo$ = -2076					; size = 4
_bSuccess$ = -2072					; size = 4
_filePath$80627 = -2068					; size = 260
_fileName$80626 = -1808					; size = 260
_szTmp$80621 = -1808					; size = 520
_packageFile$ = -1288					; size = 260
_szTmp$80630 = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_ExtractAllFilesThread PROC				; COMDAT

; 668  : {

  00000	81 ec 1c 08 00
	00		 sub	 esp, 2076		; 0000081cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 18 08
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+2076], eax
  00014	53		 push	 ebx
  00015	8b 9c 24 24 08
	00 00		 mov	 ebx, DWORD PTR _hwndDlg$[esp+2076]
  0001c	55		 push	 ebp

; 669  : 	int fileNo;
; 670  : 	BOOL bSuccess = FALSE;
; 671  : 	char packageFile [TC_MAX_PATH];
; 672  : 
; 673  : 	InvalidateRect (GetDlgItem (GetParent (hwndDlg), IDD_INSTL_DLG), NULL, TRUE);

  0001d	6a 01		 push	 1
  0001f	33 ed		 xor	 ebp, ebp
  00021	55		 push	 ebp
  00022	6a 6f		 push	 111			; 0000006fH
  00024	53		 push	 ebx
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  0002b	50		 push	 eax
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00032	50		 push	 eax
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InvalidateRect@12

; 674  : 
; 675  : 	ClearLogWindow (hwndDlg);

  00039	53		 push	 ebx
  0003a	e8 00 00 00 00	 call	 _ClearLogWindow
  0003f	83 c4 04	 add	 esp, 4

; 676  : 
; 677  : 	GetModuleFileName (NULL, packageFile, sizeof (packageFile));

  00042	68 04 01 00 00	 push	 260			; 00000104H
  00047	8d 84 24 20 03
	00 00		 lea	 eax, DWORD PTR _packageFile$[esp+2088]
  0004e	50		 push	 eax
  0004f	55		 push	 ebp
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12

; 678  : 
; 679  : 	if (!(bSuccess = SelfExtractInMemory (packageFile)))

  00056	8d 8c 24 1c 03
	00 00		 lea	 ecx, DWORD PTR _packageFile$[esp+2084]
  0005d	51		 push	 ecx
  0005e	e8 00 00 00 00	 call	 _SelfExtractInMemory
  00063	83 c4 04	 add	 esp, 4
  00066	89 44 24 0c	 mov	 DWORD PTR _bSuccess$[esp+2084], eax
  0006a	3b c5		 cmp	 eax, ebp
  0006c	0f 84 c8 01 00
	00		 je	 $eaf_end$80618

; 680  : 		goto eaf_end;
; 681  : 
; 682  : 	if (mkfulldir (DestExtractPath, TRUE) != 0)

  00072	6a 01		 push	 1
  00074	68 00 00 00 00	 push	 OFFSET _DestExtractPath
  00079	e8 00 00 00 00	 call	 _mkfulldir
  0007e	83 c4 08	 add	 esp, 8
  00081	85 c0		 test	 eax, eax
  00083	74 5f		 je	 SHORT $LN7@ExtractAll

; 683  : 	{
; 684  : 		if (mkfulldir (DestExtractPath, FALSE) != 0)

  00085	55		 push	 ebp
  00086	68 00 00 00 00	 push	 OFFSET _DestExtractPath
  0008b	e8 00 00 00 00	 call	 _mkfulldir
  00090	83 c4 08	 add	 esp, 8
  00093	85 c0		 test	 eax, eax
  00095	74 4d		 je	 SHORT $LN7@ExtractAll

; 685  : 		{
; 686  : 			wchar_t szTmp[TC_MAX_PATH];
; 687  : 
; 688  : 			handleWin32Error (hwndDlg);

  00097	53		 push	 ebx
  00098	e8 00 00 00 00	 call	 _handleWin32Error
  0009d	83 c4 04	 add	 esp, 4

; 689  : 			wsprintfW (szTmp, GetString ("CANT_CREATE_FOLDER"), DestExtractPath);

  000a0	68 00 00 00 00	 push	 OFFSET _DestExtractPath
  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KJOFIBFE@CANT_CREATE_FOLDER?$AA@
  000aa	e8 00 00 00 00	 call	 _GetString
  000af	83 c4 04	 add	 esp, 4
  000b2	50		 push	 eax
  000b3	8d 94 24 1c 01
	00 00		 lea	 edx, DWORD PTR _szTmp$80621[esp+2092]
  000ba	52		 push	 edx
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfW

; 690  : 			MessageBoxW (hwndDlg, szTmp, lpszTitle, MB_ICONHAND);

  000c1	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c9	6a 10		 push	 16			; 00000010H
  000cb	50		 push	 eax
  000cc	8d 8c 24 1c 01
	00 00		 lea	 ecx, DWORD PTR _szTmp$80621[esp+2092]
  000d3	51		 push	 ecx
  000d4	53		 push	 ebx
  000d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 691  : 			bSuccess = FALSE;

  000db	89 6c 24 0c	 mov	 DWORD PTR _bSuccess$[esp+2084], ebp

; 692  : 			goto eaf_end;

  000df	e9 56 01 00 00	 jmp	 $eaf_end$80618
$LN7@ExtractAll:
  000e4	56		 push	 esi

; 693  : 		}
; 694  : 	}
; 695  : 
; 696  : 	for (fileNo = 0; fileNo < NBR_COMPRESSED_FILES; fileNo++)

  000e5	89 6c 24 0c	 mov	 DWORD PTR _fileNo$[esp+2088], ebp
  000e9	57		 push	 edi
  000ea	8d 9b 00 00 00
	00		 npad	 6
$LL19@ExtractAll:

; 697  : 	{
; 698  : 		char fileName [TC_MAX_PATH] = {0};

  000f0	68 03 01 00 00	 push	 259			; 00000103H
  000f5	8d 94 24 21 01
	00 00		 lea	 edx, DWORD PTR _fileName$80626[esp+2097]
  000fc	6a 00		 push	 0
  000fe	52		 push	 edx
  000ff	c6 84 24 28 01
	00 00 00	 mov	 BYTE PTR _fileName$80626[esp+2104], 0
  00107	e8 00 00 00 00	 call	 _memset

; 699  : 		char filePath [TC_MAX_PATH] = {0};

  0010c	68 03 01 00 00	 push	 259			; 00000103H
  00111	8d 44 24 29	 lea	 eax, DWORD PTR _filePath$80627[esp+2109]
  00115	6a 00		 push	 0
  00117	50		 push	 eax
  00118	c6 44 24 30 00	 mov	 BYTE PTR _filePath$80627[esp+2116], 0
  0011d	e8 00 00 00 00	 call	 _memset

; 700  : 
; 701  : 		// Filename
; 702  : 		strncpy (fileName, Decompressed_Files[fileNo].fileName, Decompressed_Files[fileNo].fileNameLength);

  00122	8b 8d 04 00 00
	00		 mov	 ecx, DWORD PTR _Decompressed_Files[ebp+4]
  00128	8b 95 00 00 00
	00		 mov	 edx, DWORD PTR _Decompressed_Files[ebp]
  0012e	51		 push	 ecx
  0012f	52		 push	 edx
  00130	8d 84 24 3c 01
	00 00		 lea	 eax, DWORD PTR _fileName$80626[esp+2124]
  00137	50		 push	 eax
  00138	e8 00 00 00 00	 call	 _strncpy

; 703  : 		fileName [Decompressed_Files[fileNo].fileNameLength] = 0;

  0013d	8b 8d 04 00 00
	00		 mov	 ecx, DWORD PTR _Decompressed_Files[ebp+4]
  00143	83 c4 24	 add	 esp, 36			; 00000024H
  00146	c6 84 0c 1c 01
	00 00 00	 mov	 BYTE PTR _fileName$80626[esp+ecx+2092], 0

; 704  : 		strcpy (filePath, DestExtractPath);

  0014e	33 c0		 xor	 eax, eax
$LL12@ExtractAll:
  00150	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR _DestExtractPath[eax]
  00156	88 4c 04 18	 mov	 BYTE PTR _filePath$80627[esp+eax+2092], cl
  0015a	40		 inc	 eax
  0015b	84 c9		 test	 cl, cl
  0015d	75 f1		 jne	 SHORT $LL12@ExtractAll

; 705  : 		strcat (filePath, fileName);

  0015f	8d 84 24 1c 01
	00 00		 lea	 eax, DWORD PTR _fileName$80626[esp+2092]
  00166	8b f0		 mov	 esi, eax
$LL17@ExtractAll:
  00168	8a 08		 mov	 cl, BYTE PTR [eax]
  0016a	40		 inc	 eax
  0016b	84 c9		 test	 cl, cl
  0016d	75 f9		 jne	 SHORT $LL17@ExtractAll
  0016f	8d 7c 24 18	 lea	 edi, DWORD PTR _filePath$80627[esp+2092]
  00173	2b c6		 sub	 eax, esi
  00175	4f		 dec	 edi
$LL18@ExtractAll:
  00176	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00179	47		 inc	 edi
  0017a	84 c9		 test	 cl, cl
  0017c	75 f8		 jne	 SHORT $LL18@ExtractAll
  0017e	8b c8		 mov	 ecx, eax
  00180	c1 e9 02	 shr	 ecx, 2
  00183	f3 a5		 rep movsd

; 706  : 
; 707  : 		StatusMessageParam (hwndDlg, "EXTRACTING_VERB", filePath);

  00185	8d 54 24 18	 lea	 edx, DWORD PTR _filePath$80627[esp+2092]
  00189	52		 push	 edx
  0018a	8b c8		 mov	 ecx, eax
  0018c	83 e1 03	 and	 ecx, 3
  0018f	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@IBCNACGH@EXTRACTING_VERB?$AA@
  00194	53		 push	 ebx
  00195	f3 a4		 rep movsb
  00197	e8 00 00 00 00	 call	 _StatusMessageParam

; 708  : 
; 709  : 		// Write the file
; 710  : 		if (!SaveBufferToFile (
; 711  : 			Decompressed_Files[fileNo].fileContent,
; 712  : 			filePath,
; 713  : 			Decompressed_Files[fileNo].fileLength,
; 714  : 			FALSE))

  0019c	8b 85 0c 00 00
	00		 mov	 eax, DWORD PTR _Decompressed_Files[ebp+12]
  001a2	8b 95 10 00 00
	00		 mov	 edx, DWORD PTR _Decompressed_Files[ebp+16]
  001a8	6a 00		 push	 0
  001aa	50		 push	 eax
  001ab	8d 4c 24 2c	 lea	 ecx, DWORD PTR _filePath$80627[esp+2112]
  001af	51		 push	 ecx
  001b0	52		 push	 edx
  001b1	e8 00 00 00 00	 call	 _SaveBufferToFile
  001b6	83 c4 1c	 add	 esp, 28			; 0000001cH
  001b9	85 c0		 test	 eax, eax
  001bb	74 30		 je	 SHORT $LN15@ExtractAll

; 721  : 			goto eaf_end;
; 722  : 		}
; 723  : 		UpdateProgressBarProc ((int) (100 * ((float) fileNo / NBR_COMPRESSED_FILES)));

  001bd	db 44 24 10	 fild	 DWORD PTR _fileNo$[esp+2092]
  001c1	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4018000000000000
  001c7	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4059000000000000
  001cd	e8 00 00 00 00	 call	 __ftol2_sse
  001d2	50		 push	 eax
  001d3	e8 00 00 00 00	 call	 _UpdateProgressBarProc
  001d8	ff 44 24 14	 inc	 DWORD PTR _fileNo$[esp+2096]
  001dc	83 c5 14	 add	 ebp, 20			; 00000014H
  001df	83 c4 04	 add	 esp, 4
  001e2	83 fd 78	 cmp	 ebp, 120		; 00000078H
  001e5	0f 82 05 ff ff
	ff		 jb	 $LL19@ExtractAll

; 708  : 
; 709  : 		// Write the file
; 710  : 		if (!SaveBufferToFile (
; 711  : 			Decompressed_Files[fileNo].fileContent,
; 712  : 			filePath,
; 713  : 			Decompressed_Files[fileNo].fileLength,
; 714  : 			FALSE))

  001eb	eb 4b		 jmp	 SHORT $LN20@ExtractAll
$LN15@ExtractAll:

; 715  : 		{
; 716  : 			wchar_t szTmp[512];
; 717  : 
; 718  : 			_snwprintf (szTmp, sizeof (szTmp) / 2, GetString ("CANNOT_WRITE_FILE_X"), filePath);

  001ed	8d 44 24 18	 lea	 eax, DWORD PTR _filePath$80627[esp+2092]
  001f1	50		 push	 eax
  001f2	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@BADKJOBO@CANNOT_WRITE_FILE_X?$AA@
  001f7	e8 00 00 00 00	 call	 _GetString
  001fc	83 c4 04	 add	 esp, 4
  001ff	50		 push	 eax
  00200	8d 8c 24 30 04
	00 00		 lea	 ecx, DWORD PTR _szTmp$80630[esp+2100]
  00207	68 00 02 00 00	 push	 512			; 00000200H
  0020c	51		 push	 ecx
  0020d	e8 00 00 00 00	 call	 __snwprintf

; 719  : 			MessageBoxW (hwndDlg, szTmp, lpszTitle, MB_ICONERROR | MB_SETFOREGROUND | MB_TOPMOST);

  00212	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lpszTitle
  00218	83 c4 10	 add	 esp, 16			; 00000010H
  0021b	68 10 00 05 00	 push	 327696			; 00050010H
  00220	52		 push	 edx
  00221	8d 84 24 30 04
	00 00		 lea	 eax, DWORD PTR _szTmp$80630[esp+2100]
  00228	50		 push	 eax
  00229	53		 push	 ebx
  0022a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 720  : 			bSuccess = FALSE;

  00230	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _bSuccess$[esp+2092], 0
$LN20@ExtractAll:
  00238	5f		 pop	 edi
  00239	5e		 pop	 esi
$eaf_end$80618:

; 724  : 	}
; 725  : 
; 726  : eaf_end:
; 727  : 	FreeAllFileBuffers();

  0023a	e8 00 00 00 00	 call	 _FreeAllFileBuffers

; 728  : 
; 729  : 	if (bSuccess)

  0023f	83 7c 24 0c 00	 cmp	 DWORD PTR _bSuccess$[esp+2084], 0
  00244	5d		 pop	 ebp
  00245	5b		 pop	 ebx

; 730  : 		PostMessage (MainDlg, TC_APPMSG_EXTRACTION_SUCCESS, 0, 0);

  00246	6a 00		 push	 0
  00248	6a 00		 push	 0
  0024a	74 0e		 je	 SHORT $LN2@ExtractAll
  0024c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _MainDlg
  00252	68 93 81 00 00	 push	 33171			; 00008193H
  00257	51		 push	 ecx

; 731  : 	else

  00258	eb 0c		 jmp	 SHORT $LN22@ExtractAll
$LN2@ExtractAll:

; 732  : 		PostMessage (MainDlg, TC_APPMSG_EXTRACTION_FAILURE, 0, 0);

  0025a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _MainDlg
  00260	68 96 81 00 00	 push	 33174			; 00008196H
  00265	52		 push	 edx
$LN22@ExtractAll:
  00266	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16

; 733  : }

  0026c	8b 8c 24 18 08
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+2076]
  00273	33 cc		 xor	 ecx, esp
  00275	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0027a	81 c4 1c 08 00
	00		 add	 esp, 2076		; 0000081cH
  00280	c3		 ret	 0
_ExtractAllFilesThread ENDP
_TEXT	ENDS
PUBLIC	_SelfExtractStartupInit
; Function compile flags: /Ogtpy
;	COMDAT _SelfExtractStartupInit
_TEXT	SEGMENT
_SelfExtractStartupInit PROC				; COMDAT

; 40   : 	DeobfuscateMagEndMarker ();

  00000	33 c0		 xor	 eax, eax
$LL5@SelfExtrac@2:
  00002	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR ??_C@_0BA@LOGCKKME@T?1C?1I?1N?1S?1C?1R?1C?$AA@[eax]
  00008	8b c8		 mov	 ecx, eax
  0000a	d1 e9		 shr	 ecx, 1
  0000c	83 c0 02	 add	 eax, 2
  0000f	88 91 00 00 00
	00		 mov	 BYTE PTR _MagEndMarker[ecx], dl
  00015	83 f8 10	 cmp	 eax, 16			; 00000010H
  00018	72 e8		 jb	 SHORT $LL5@SelfExtrac@2
  0001a	99		 cdq
  0001b	2b c2		 sub	 eax, edx
  0001d	d1 f8		 sar	 eax, 1
  0001f	c6 80 00 00 00
	00 00		 mov	 BYTE PTR _MagEndMarker[eax], 0

; 41   : }

  00026	c3		 ret	 0
_SelfExtractStartupInit ENDP
_TEXT	ENDS
END
