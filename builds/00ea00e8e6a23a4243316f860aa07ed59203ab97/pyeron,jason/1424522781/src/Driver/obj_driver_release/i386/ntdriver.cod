; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\home\public\desktop\projects\ciphershed.build\src\driver\ntdriver.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_RootDeviceObject
PUBLIC	_DriverShuttingDown
PUBLIC	_OsMajorVersion
PUBLIC	_DriverUnloadDisabled
PUBLIC	_PortableMode
PUBLIC	_VolumeClassFilterRegistered
PUBLIC	_CacheBootPassword
PUBLIC	_NonAdminSystemFavoritesAccessDisabled
_DATA	SEGMENT
COMM	_VirtualVolumeDeviceObjects:DWORD:01aH
COMM	_TCDriverObject:DWORD
COMM	_LastUniqueVolumeId:DWORD
COMM	_OsMinorVersion:DWORD
COMM	_SelfTestsPassed:DWORD
_DATA	ENDS
_BSS	SEGMENT
_RootDeviceObject DD 01H DUP (?)
_DriverShuttingDown DD 01H DUP (?)
_OsMajorVersion DD 01H DUP (?)
_DriverUnloadDisabled DD 01H DUP (?)
_PortableMode DD 01H DUP (?)
_VolumeClassFilterRegistered DD 01H DUP (?)
_CacheBootPassword DD 01H DUP (?)
_NonAdminSystemFavoritesAccessDisabled DD 01H DUP (?)
_EncryptionThreadPoolFreeCpuCountLimit DD 01H DUP (?)
_SystemFavoriteVolumeDirty DD 01H DUP (?)
_PagingFileCreationPrevented DD 01H DUP (?)
_BSS	ENDS
PUBLIC	_InitializeListHead@4
; Function compile flags: /Ogsp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
;	COMDAT _InitializeListHead@4
_TEXT	SEGMENT
_ListHead$ = 8						; size = 4
_InitializeListHead@4 PROC				; COMDAT

; 7550 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 7551 :     ListHead->Flink = ListHead->Blink = ListHead;

  00005	8b 45 08	 mov	 eax, DWORD PTR _ListHead$[ebp]
  00008	89 40 04	 mov	 DWORD PTR [eax+4], eax
  0000b	89 00		 mov	 DWORD PTR [eax], eax

; 7552 : }

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
_InitializeListHead@4 ENDP
_TEXT	ENDS
PUBLIC	_RtlSecureZeroMemory@8
; Function compile flags: /Ogsp
;	COMDAT _RtlSecureZeroMemory@8
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory@8 PROC				; COMDAT

; 8322 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 8323 :     volatile char *vptr = (volatile char *)ptr;
; 8324 : 
; 8325 : #if defined(_M_AMD64)
; 8326 : 
; 8327 :         __stosb((PUCHAR)((ULONG64)vptr), 0, cnt);
; 8328 : 
; 8329 : #else
; 8330 : 
; 8331 :     while (cnt) {

  00005	83 7d 0c 00	 cmp	 DWORD PTR _cnt$[ebp], 0
  00009	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  0000c	74 09		 je	 SHORT $LN1@RtlSecureZ
$LL2@RtlSecureZ:

; 8332 :         *vptr = 0;

  0000e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 8333 :         vptr++;

  00011	40		 inc	 eax

; 8334 :         cnt--;

  00012	ff 4d 0c	 dec	 DWORD PTR _cnt$[ebp]
  00015	75 f7		 jne	 SHORT $LL2@RtlSecureZ
$LN1@RtlSecureZ:

; 8335 :     }
; 8336 : 
; 8337 : #endif
; 8338 : 
; 8339 :     return ptr;

  00017	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]

; 8340 : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
_RtlSecureZeroMemory@8 ENDP
_TEXT	ENDS
PUBLIC	_KeInitializeSpinLock@4
; Function compile flags: /Ogsp
;	COMDAT _KeInitializeSpinLock@4
_TEXT	SEGMENT
_SpinLock$ = 8						; size = 4
_KeInitializeSpinLock@4 PROC				; COMDAT

; 15095: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 15096: 
; 15097:     *SpinLock = 0;

  00005	8b 45 08	 mov	 eax, DWORD PTR _SpinLock$[ebp]
  00008	83 20 00	 and	 DWORD PTR [eax], 0

; 15098:     return;
; 15099: }

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
_KeInitializeSpinLock@4 ENDP
_TEXT	ENDS
PUBLIC	_PsGetCurrentThread@0
EXTRN	__imp__KeGetCurrentThread@0:PROC
; Function compile flags: /Ogsp
;	COMDAT _PsGetCurrentThread@0
_TEXT	SEGMENT
_PsGetCurrentThread@0 PROC				; COMDAT

; 19989: 
; 19990:     return (PETHREAD)KeGetCurrentThread();

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp__KeGetCurrentThread@0
_PsGetCurrentThread@0 ENDP
_TEXT	ENDS
PUBLIC	_IoGetCurrentIrpStackLocation@4
; Function compile flags: /Ogsp
;	COMDAT _IoGetCurrentIrpStackLocation@4
_TEXT	SEGMENT
_Irp$ = 8						; size = 4
_IoGetCurrentIrpStackLocation@4 PROC			; COMDAT

; 23316: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 23317:     ASSERT(Irp->CurrentLocation <= Irp->StackCount + 1);
; 23318:     return Irp->Tail.Overlay.CurrentStackLocation;

  00005	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00008	8b 40 60	 mov	 eax, DWORD PTR [eax+96]

; 23319: }

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
_IoGetCurrentIrpStackLocation@4 ENDP
_TEXT	ENDS
PUBLIC	_IoGetNextIrpStackLocation@4
; Function compile flags: /Ogsp
;	COMDAT _IoGetNextIrpStackLocation@4
_TEXT	SEGMENT
_Irp$ = 8						; size = 4
_IoGetNextIrpStackLocation@4 PROC			; COMDAT

; 23479: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 23480:     ASSERT(Irp->CurrentLocation > 0);
; 23481: 
; 23482:     return ((Irp)->Tail.Overlay.CurrentStackLocation - 1 );

  00005	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00008	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  0000b	83 e8 24	 sub	 eax, 36			; 00000024H

; 23483: }

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
_IoGetNextIrpStackLocation@4 ENDP
_TEXT	ENDS
PUBLIC	_IoMarkIrpPending@4
; Function compile flags: /Ogsp
;	COMDAT _IoMarkIrpPending@4
_TEXT	SEGMENT
_Irp$ = 8						; size = 4
_IoMarkIrpPending@4 PROC				; COMDAT

; 23667: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 23668:     IoGetCurrentIrpStackLocation( (Irp) )->Control |= SL_PENDING_RETURNED;

  00005	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00008	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  0000b	80 48 03 01	 or	 BYTE PTR [eax+3], 1

; 23669: }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
_IoMarkIrpPending@4 ENDP
_TEXT	ENDS
PUBLIC	_DriverAddDevice@8
EXTRN	_DriveFilterAddDevice@8:PROC
EXTRN	_VolumeFilterAddDevice@8:PROC
EXTRN	__imp__ExFreePoolWithTag@8:PROC
EXTRN	__imp__IoGetDeviceInterfaces@16:PROC
EXTRN	_GUID_DEVINTERFACE_VOLUME:BYTE
EXTRN	_BootArgs:BYTE
EXTRN	_BootArgsValid:DWORD
; Function compile flags: /Ogsp
; File c:\home\public\desktop\projects\ciphershed.build\src\driver\ntdriver.c
;	COMDAT _DriverAddDevice@8
_TEXT	SEGMENT
_interfaceLinks$29763 = -4				; size = 4
_driverObject$ = 8					; size = 4
_pdo$ = 12						; size = 4
_DriverAddDevice@8 PROC					; COMDAT

; 112  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	56		 push	 esi

; 113  : #ifdef DEBUG
; 114  : 	char nameInfoBuffer[128];
; 115  : 	POBJECT_NAME_INFORMATION nameInfo = (POBJECT_NAME_INFORMATION) nameInfoBuffer;
; 116  : 	ULONG nameInfoSize;
; 117  : 	Dump ("AddDevice pdo=%p type=%x name=%ws\n", pdo, pdo->DeviceType, NT_SUCCESS (ObQueryNameString (pdo, nameInfo, sizeof (nameInfoBuffer), &nameInfoSize)) ? nameInfo->Name.Buffer : L"?");
; 118  : #endif
; 119  : 
; 120  : 	if (VolumeClassFilterRegistered && BootArgsValid && BootArgs.HiddenSystemPartitionStart != 0)

  00007	33 f6		 xor	 esi, esi
  00009	39 35 00 00 00
	00		 cmp	 DWORD PTR _VolumeClassFilterRegistered, esi
  0000f	74 50		 je	 SHORT $LN2@DriverAddD
  00011	39 35 00 00 00
	00		 cmp	 DWORD PTR _BootArgsValid, esi
  00017	74 48		 je	 SHORT $LN2@DriverAddD
  00019	a1 5a 00 00 00	 mov	 eax, DWORD PTR _BootArgs+90
  0001e	0b 05 5e 00 00
	00		 or	 eax, DWORD PTR _BootArgs+94
  00024	74 3b		 je	 SHORT $LN2@DriverAddD

; 121  : 	{
; 122  : 		PWSTR interfaceLinks;
; 123  : 		if (NT_SUCCESS (IoGetDeviceInterfaces (&GUID_DEVINTERFACE_VOLUME, pdo, DEVICE_INTERFACE_INCLUDE_NONACTIVE, &interfaceLinks)))

  00026	8d 45 fc	 lea	 eax, DWORD PTR _interfaceLinks$29763[ebp]
  00029	50		 push	 eax
  0002a	6a 01		 push	 1
  0002c	ff 75 0c	 push	 DWORD PTR _pdo$[ebp]
  0002f	68 00 00 00 00	 push	 OFFSET _GUID_DEVINTERFACE_VOLUME
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoGetDeviceInterfaces@16
  0003a	85 c0		 test	 eax, eax
  0003c	7c 23		 jl	 SHORT $LN2@DriverAddD

; 124  : 		{
; 125  : 			if (interfaceLinks[0] != UNICODE_NULL)

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _interfaceLinks$29763[ebp]

; 126  : 			{
; 127  : 				Dump ("Volume pdo=%p interface=%ws\n", pdo, interfaceLinks);
; 128  : 				ExFreePool (interfaceLinks);

  00041	56		 push	 esi
  00042	50		 push	 eax
  00043	66 39 30	 cmp	 WORD PTR [eax], si
  00046	74 13		 je	 SHORT $LN1@DriverAddD
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 129  : 
; 130  : 				return VolumeFilterAddDevice (driverObject, pdo);

  0004e	ff 75 0c	 push	 DWORD PTR _pdo$[ebp]
  00051	ff 75 08	 push	 DWORD PTR _driverObject$[ebp]
  00054	e8 00 00 00 00	 call	 _VolumeFilterAddDevice@8
  00059	eb 11		 jmp	 SHORT $LN4@DriverAddD
$LN1@DriverAddD:

; 131  : 			}
; 132  : 
; 133  : 			ExFreePool (interfaceLinks);

  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN2@DriverAddD:

; 134  : 		}
; 135  : 	}
; 136  : 
; 137  : 	return DriveFilterAddDevice (driverObject, pdo);

  00061	ff 75 0c	 push	 DWORD PTR _pdo$[ebp]
  00064	ff 75 08	 push	 DWORD PTR _driverObject$[ebp]
  00067	e8 00 00 00 00	 call	 _DriveFilterAddDevice@8
$LN4@DriverAddD:
  0006c	5e		 pop	 esi

; 138  : }

  0006d	c9		 leave
  0006e	c2 08 00	 ret	 8
_DriverAddDevice@8 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_DumpMemory@8
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _DumpMemory@8
_TEXT	SEGMENT
_str$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_mem$ = 8						; size = 4
_size$ = 12						; size = 4
_DumpMemory@8 PROC					; COMDAT

; 143  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 18	 sub	 esp, 24			; 00000018H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 144  : 	unsigned char str[20];
; 145  : 	unsigned char *m = mem;
; 146  : 	int i,j;
; 147  : 
; 148  : 	for (j = 0; j < size / 8; j++)

  00012	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  00015	99		 cdq
  00016	83 e2 07	 and	 edx, 7
  00019	03 c2		 add	 eax, edx
  0001b	c1 f8 03	 sar	 eax, 3
  0001e	56		 push	 esi
  0001f	8b 75 08	 mov	 esi, DWORD PTR _mem$[ebp]
  00022	85 c0		 test	 eax, eax
  00024	7e 2a		 jle	 SHORT $LN6@DumpMemory
  00026	8d 4d e8	 lea	 ecx, DWORD PTR _str$[ebp]
  00029	57		 push	 edi
  0002a	2b ce		 sub	 ecx, esi
  0002c	8b f8		 mov	 edi, eax
$LL8@DumpMemory:

; 149  : 	{
; 150  : 		memset (str,0,sizeof str);
; 151  : 		for (i = 0; i < 8; i++) 

  0002e	6a 08		 push	 8
  00030	8b c6		 mov	 eax, esi
  00032	5e		 pop	 esi
$LL5@DumpMemory:

; 152  : 		{
; 153  : 			if (m[i] > ' ' && m[i] <= '~')

  00033	8a 10		 mov	 dl, BYTE PTR [eax]
  00035	80 fa 20	 cmp	 dl, 32			; 00000020H
  00038	76 05		 jbe	 SHORT $LN2@DumpMemory
  0003a	80 fa 7e	 cmp	 dl, 126			; 0000007eH

; 154  : 				str[i]=m[i];
; 155  : 			else

  0003d	76 04		 jbe	 SHORT $LN4@DumpMemory
$LN2@DumpMemory:

; 156  : 				str[i]='.';

  0003f	c6 04 01 2e	 mov	 BYTE PTR [ecx+eax], 46	; 0000002eH
$LN4@DumpMemory:

; 149  : 	{
; 150  : 		memset (str,0,sizeof str);
; 151  : 		for (i = 0; i < 8; i++) 

  00043	40		 inc	 eax
  00044	4e		 dec	 esi
  00045	75 ec		 jne	 SHORT $LL5@DumpMemory

; 157  : 		}
; 158  : 
; 159  : 		Dump ("0x%08p  %02x %02x %02x %02x %02x %02x %02x %02x  %s\n",
; 160  : 			m, m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], str);
; 161  : 
; 162  : 		m+=8;

  00047	83 e9 08	 sub	 ecx, 8
  0004a	4f		 dec	 edi
  0004b	8b f0		 mov	 esi, eax
  0004d	75 df		 jne	 SHORT $LL8@DumpMemory
  0004f	5f		 pop	 edi
$LN6@DumpMemory:

; 163  : 	}
; 164  : }

  00050	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00053	33 cd		 xor	 ecx, ebp
  00055	5e		 pop	 esi
  00056	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005b	c9		 leave
  0005c	c2 08 00	 ret	 8
_DumpMemory@8 ENDP
_TEXT	ENDS
PUBLIC	_ValidateIOBufferSize@12
EXTRN	_memset:PROC
; Function compile flags: /Ogsp
;	COMDAT _ValidateIOBufferSize@12
_TEXT	SEGMENT
_irp$ = 8						; size = 4
_requiredBufferSize$ = 12				; size = 4
_type$ = 16						; size = 4
_ValidateIOBufferSize@12 PROC				; COMDAT

; 168  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 169  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (irp);
; 170  : 	BOOL input = (type == ValidateInput || type == ValidateInputOutput);

  00005	8b 55 10	 mov	 edx, DWORD PTR _type$[ebp]
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _irp$[ebp]
  0000b	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	85 d2		 test	 edx, edx
  00012	74 09		 je	 SHORT $LN7@ValidateIO
  00014	83 fa 02	 cmp	 edx, 2
  00017	74 04		 je	 SHORT $LN7@ValidateIO
  00019	33 ff		 xor	 edi, edi
  0001b	eb 03		 jmp	 SHORT $LN8@ValidateIO
$LN7@ValidateIO:
  0001d	33 ff		 xor	 edi, edi
  0001f	47		 inc	 edi
$LN8@ValidateIO:

; 171  : 	BOOL output = (type == ValidateOutput || type == ValidateInputOutput);

  00020	83 fa 01	 cmp	 edx, 1
  00023	74 09		 je	 SHORT $LN9@ValidateIO
  00025	83 fa 02	 cmp	 edx, 2
  00028	74 04		 je	 SHORT $LN9@ValidateIO
  0002a	33 f6		 xor	 esi, esi
  0002c	eb 03		 jmp	 SHORT $LN10@ValidateIO
$LN9@ValidateIO:
  0002e	33 f6		 xor	 esi, esi
  00030	46		 inc	 esi
$LN10@ValidateIO:

; 172  : 
; 173  : 	if ((input && irpSp->Parameters.DeviceIoControl.InputBufferLength < requiredBufferSize)
; 174  : 		|| (output && irpSp->Parameters.DeviceIoControl.OutputBufferLength < requiredBufferSize))

  00031	8b 55 0c	 mov	 edx, DWORD PTR _requiredBufferSize$[ebp]
  00034	85 ff		 test	 edi, edi
  00036	74 05		 je	 SHORT $LN2@ValidateIO
  00038	39 50 08	 cmp	 DWORD PTR [eax+8], edx
  0003b	72 09		 jb	 SHORT $LN3@ValidateIO
$LN2@ValidateIO:
  0003d	85 f6		 test	 esi, esi
  0003f	74 14		 je	 SHORT $LN4@ValidateIO
  00041	39 50 04	 cmp	 DWORD PTR [eax+4], edx
  00044	73 0f		 jae	 SHORT $LN4@ValidateIO
$LN3@ValidateIO:

; 175  : 	{
; 176  : 		Dump ("STATUS_BUFFER_TOO_SMALL ioctl=0x%x,%d in=%d out=%d reqsize=%d insize=%d outsize=%d\n", (int) (irpSp->Parameters.DeviceIoControl.IoControlCode >> 16), (int) ((irpSp->Parameters.DeviceIoControl.IoControlCode & 0x1FFF) >> 2), input, output, requiredBufferSize, irpSp->Parameters.DeviceIoControl.InputBufferLength, irpSp->Parameters.DeviceIoControl.OutputBufferLength);
; 177  : 
; 178  : 		irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
; 179  : 		irp->IoStatus.Information = 0;

  00046	83 61 1c 00	 and	 DWORD PTR [ecx+28], 0
  0004a	c7 41 18 23 00
	00 c0		 mov	 DWORD PTR [ecx+24], -1073741789 ; c0000023H

; 180  : 		return FALSE;

  00051	33 c0		 xor	 eax, eax
  00053	eb 1a		 jmp	 SHORT $LN5@ValidateIO
$LN4@ValidateIO:

; 181  : 	}
; 182  : 
; 183  : 	if (!input && output)

  00055	85 ff		 test	 edi, edi
  00057	75 13		 jne	 SHORT $LN1@ValidateIO
  00059	85 f6		 test	 esi, esi
  0005b	74 0f		 je	 SHORT $LN1@ValidateIO

; 184  : 		memset (irp->AssociatedIrp.SystemBuffer, 0, irpSp->Parameters.DeviceIoControl.OutputBufferLength);

  0005d	ff 70 04	 push	 DWORD PTR [eax+4]
  00060	57		 push	 edi
  00061	ff 71 0c	 push	 DWORD PTR [ecx+12]
  00064	e8 00 00 00 00	 call	 _memset
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@ValidateIO:

; 185  : 
; 186  : 	return TRUE;

  0006c	33 c0		 xor	 eax, eax
  0006e	40		 inc	 eax
$LN5@ValidateIO:
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi

; 187  : }

  00071	5d		 pop	 ebp
  00072	c2 0c 00	 ret	 12			; 0000000cH
_ValidateIOBufferSize@12 ENDP
_TEXT	ENDS
PUBLIC	_GetVirtualVolumeDeviceObject@4
; Function compile flags: /Ogsp
;	COMDAT _GetVirtualVolumeDeviceObject@4
_TEXT	SEGMENT
_driveNumber$ = 8					; size = 4
_GetVirtualVolumeDeviceObject@4 PROC			; COMDAT

; 191  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 192  : 	if (driveNumber < MIN_MOUNTED_VOLUME_DRIVE_NUMBER || driveNumber > MAX_MOUNTED_VOLUME_DRIVE_NUMBER)

  00005	8b 45 08	 mov	 eax, DWORD PTR _driveNumber$[ebp]
  00008	83 f8 19	 cmp	 eax, 25			; 00000019H
  0000b	77 09		 ja	 SHORT $LN1@GetVirtual

; 194  : 
; 195  : 	return VirtualVolumeDeviceObjects[driveNumber];

  0000d	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _VirtualVolumeDeviceObjects[eax*4]
  00014	eb 02		 jmp	 SHORT $LN3@GetVirtual
$LN1@GetVirtual:

; 193  : 		return NULL;

  00016	33 c0		 xor	 eax, eax
$LN3@GetVirtual:

; 196  : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
_GetVirtualVolumeDeviceObject@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	__$ArrayPad$
PUBLIC	_TCCreateRootDeviceObject@4
EXTRN	__imp__IoRegisterShutdownNotification@4:PROC
EXTRN	__imp__IoDeleteDevice@4:PROC
EXTRN	__imp__IoCreateSymbolicLink@8:PROC
EXTRN	__imp__KeInitializeMutex@8:PROC
EXTRN	__imp__IoCreateDevice@28:PROC
EXTRN	__imp__RtlInitUnicodeString@8:PROC
_BSS	SEGMENT
_RootDeviceControlMutex DB 020H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'T', 00H, 'r', 00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r'
	DB	00H, 'y', 00H, 'p', 00H, 't', 00H, 00H, 00H	;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'T', 00H, 'r'
	DB	00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r', 00H, 'y', 00H, 'p', 00H
	DB	't', 00H, 00H, 00H				;  ?? ::PBOPGDP::`string'
; Function compile flags: /Ogsp
INIT$s	ENDS
;	COMDAT _TCCreateRootDeviceObject@4
INIT	SEGMENT
_Win32NameString$ = -152				; size = 8
_ntUnicodeString$ = -144				; size = 8
_DeviceObject$ = -136					; size = 4
_ntname$ = -132						; size = 64
_dosname$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_DriverObject$ = 8					; size = 4
_TCCreateRootDeviceObject@4 PROC			; COMDAT

; 354  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	8b 7d 08	 mov	 edi, DWORD PTR _DriverObject$[ebp]

; 355  : 	UNICODE_STRING Win32NameString, ntUnicodeString;
; 356  : 	WCHAR dosname[32], ntname[32];
; 357  : 	PDEVICE_OBJECT DeviceObject;
; 358  : 	NTSTATUS ntStatus;
; 359  : 	BOOL *bRootExtension;
; 360  : 
; 361  : 	Dump ("TCCreateRootDeviceObject BEGIN\n");
; 362  : 	ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);
; 363  : 
; 364  : 	wcscpy (dosname, (LPWSTR) DOS_ROOT_PREFIX);

  0001a	33 c0		 xor	 eax, eax
$LL5@TCCreateRo:
  0001c	0f b7 88 00 00
	00 00		 movzx	 ecx, WORD PTR ??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@[eax]
  00023	66 89 4c 05 bc	 mov	 WORD PTR _dosname$[ebp+eax], cx
  00028	40		 inc	 eax
  00029	40		 inc	 eax
  0002a	66 85 c9	 test	 cx, cx
  0002d	75 ed		 jne	 SHORT $LL5@TCCreateRo

; 365  : 	wcscpy (ntname, (LPWSTR) NT_ROOT_PREFIX);

  0002f	33 c0		 xor	 eax, eax
$LL6@TCCreateRo:
  00031	0f b7 88 00 00
	00 00		 movzx	 ecx, WORD PTR ??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@[eax]
  00038	66 89 8c 05 7c
	ff ff ff	 mov	 WORD PTR _ntname$[ebp+eax], cx
  00040	40		 inc	 eax
  00041	40		 inc	 eax
  00042	66 85 c9	 test	 cx, cx
  00045	75 ea		 jne	 SHORT $LL6@TCCreateRo

; 366  : 	RtlInitUnicodeString (&ntUnicodeString, ntname);

  00047	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__RtlInitUnicodeString@8
  0004d	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _ntname$[ebp]
  00053	50		 push	 eax
  00054	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _ntUnicodeString$[ebp]
  0005a	50		 push	 eax
  0005b	ff d6		 call	 esi

; 367  : 	RtlInitUnicodeString (&Win32NameString, dosname);

  0005d	8d 45 bc	 lea	 eax, DWORD PTR _dosname$[ebp]
  00060	50		 push	 eax
  00061	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _Win32NameString$[ebp]
  00067	50		 push	 eax
  00068	ff d6		 call	 esi

; 368  : 
; 369  : 	Dump ("Creating root device nt=%ls dos=%ls\n", ntname, dosname);
; 370  : 	
; 371  : 	ntStatus = IoCreateDevice (
; 372  : 					  DriverObject,
; 373  : 					  sizeof (BOOL),
; 374  : 					  &ntUnicodeString,
; 375  : 					  FILE_DEVICE_UNKNOWN,
; 376  : 					  FILE_DEVICE_SECURE_OPEN,
; 377  : 					  FALSE,
; 378  : 					  &DeviceObject);

  0006a	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _DeviceObject$[ebp]
  00070	50		 push	 eax
  00071	6a 00		 push	 0
  00073	68 00 01 00 00	 push	 256			; 00000100H
  00078	6a 22		 push	 34			; 00000022H
  0007a	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _ntUnicodeString$[ebp]
  00080	50		 push	 eax
  00081	6a 04		 push	 4
  00083	57		 push	 edi
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoCreateDevice@28

; 379  : 
; 380  : 	if (!NT_SUCCESS (ntStatus))

  0008a	85 c0		 test	 eax, eax

; 381  : 	{
; 382  : 		Dump ("TCCreateRootDeviceObject NTSTATUS = 0x%08x END\n", ntStatus);
; 383  : 		return ntStatus;/* Failed to create DeviceObject */

  0008c	7c 6b		 jl	 SHORT $LN3@TCCreateRo

; 384  : 	}
; 385  : 
; 386  : 	DeviceObject->Flags |= DO_DIRECT_IO;

  0008e	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00094	83 48 1c 10	 or	 DWORD PTR [eax+28], 16	; 00000010H

; 387  : 	DeviceObject->AlignmentRequirement = FILE_WORD_ALIGNMENT;

  00098	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  0009e	33 c0		 xor	 eax, eax
  000a0	40		 inc	 eax
  000a1	89 41 5c	 mov	 DWORD PTR [ecx+92], eax

; 388  : 
; 389  : 	/* Setup the device extension */
; 390  : 	bRootExtension = (BOOL *) DeviceObject->DeviceExtension;

  000a4	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  000aa	8b 49 28	 mov	 ecx, DWORD PTR [ecx+40]

; 391  : 	*bRootExtension = TRUE;
; 392  : 
; 393  : 	KeInitializeMutex (&RootDeviceControlMutex, 0);

  000ad	6a 00		 push	 0
  000af	68 00 00 00 00	 push	 OFFSET _RootDeviceControlMutex
  000b4	89 01		 mov	 DWORD PTR [ecx], eax
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeMutex@8

; 394  : 
; 395  : 	ntStatus = IoCreateSymbolicLink (&Win32NameString, &ntUnicodeString);

  000bc	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _ntUnicodeString$[ebp]
  000c2	50		 push	 eax
  000c3	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _Win32NameString$[ebp]
  000c9	50		 push	 eax
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoCreateSymbolicLink@8

; 396  : 
; 397  : 	if (!NT_SUCCESS (ntStatus))
; 398  : 	{
; 399  : 		Dump ("TCCreateRootDeviceObject NTSTATUS = 0x%08x END\n", ntStatus);
; 400  : 		IoDeleteDevice (DeviceObject);

  000d0	ff b5 78 ff ff
	ff		 push	 DWORD PTR _DeviceObject$[ebp]
  000d6	8b f0		 mov	 esi, eax
  000d8	85 f6		 test	 esi, esi
  000da	7d 0a		 jge	 SHORT $LN1@TCCreateRo
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteDevice@4

; 401  : 		return ntStatus;

  000e2	8b c6		 mov	 eax, esi
  000e4	eb 13		 jmp	 SHORT $LN3@TCCreateRo
$LN1@TCCreateRo:

; 402  : 	}
; 403  : 
; 404  : 	IoRegisterShutdownNotification (DeviceObject);

  000e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoRegisterShutdownNotification@4

; 405  : 	RootDeviceObject = DeviceObject;

  000ec	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  000f2	a3 00 00 00 00	 mov	 DWORD PTR _RootDeviceObject, eax

; 406  : 
; 407  : 	Dump ("TCCreateRootDeviceObject STATUS_SUCCESS END\n");
; 408  : 	return STATUS_SUCCESS;

  000f7	33 c0		 xor	 eax, eax
$LN3@TCCreateRo:

; 409  : }

  000f9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fc	5f		 pop	 edi
  000fd	33 cd		 xor	 ecx, ebp
  000ff	5e		 pop	 esi
  00100	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00105	c9		 leave
  00106	c2 04 00	 ret	 4
_TCCreateRootDeviceObject@4 ENDP
INIT	ENDS
PUBLIC	_RootDeviceControlMutexAcquireNoWait@0
EXTRN	__imp__KeWaitForSingleObject@20:PROC
; Function compile flags: /Ogsp
;	COMDAT _RootDeviceControlMutexAcquireNoWait@0
_TEXT	SEGMENT
_timeout$ = -8						; size = 8
_RootDeviceControlMutexAcquireNoWait@0 PROC		; COMDAT

; 479  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	51		 push	 ecx
  00007	56		 push	 esi

; 480  : 	NTSTATUS status;
; 481  : 	LARGE_INTEGER timeout;
; 482  : 	timeout.QuadPart = 0;

  00008	33 f6		 xor	 esi, esi

; 483  : 
; 484  : 	status = KeWaitForMutexObject (&RootDeviceControlMutex, Executive, KernelMode, FALSE, &timeout);

  0000a	8d 45 f8	 lea	 eax, DWORD PTR _timeout$[ebp]
  0000d	50		 push	 eax
  0000e	56		 push	 esi
  0000f	56		 push	 esi
  00010	56		 push	 esi
  00011	68 00 00 00 00	 push	 OFFSET _RootDeviceControlMutex
  00016	89 75 f8	 mov	 DWORD PTR _timeout$[ebp], esi
  00019	89 75 fc	 mov	 DWORD PTR _timeout$[ebp+4], esi
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 485  : 	return NT_SUCCESS (status) && status != STATUS_TIMEOUT;

  00022	3b c6		 cmp	 eax, esi
  00024	7c 0c		 jl	 SHORT $LN3@RootDevice
  00026	3d 02 01 00 00	 cmp	 eax, 258		; 00000102H
  0002b	74 05		 je	 SHORT $LN3@RootDevice
  0002d	33 c0		 xor	 eax, eax
  0002f	40		 inc	 eax
  00030	eb 02		 jmp	 SHORT $LN4@RootDevice
$LN3@RootDevice:
  00032	33 c0		 xor	 eax, eax
$LN4@RootDevice:
  00034	5e		 pop	 esi

; 486  : }

  00035	c9		 leave
  00036	c3		 ret	 0
_RootDeviceControlMutexAcquireNoWait@0 ENDP
_TEXT	ENDS
PUBLIC	_RootDeviceControlMutexRelease@0
EXTRN	__imp__KeReleaseMutex@8:PROC
; Function compile flags: /Ogsp
;	COMDAT _RootDeviceControlMutexRelease@0
_TEXT	SEGMENT
_RootDeviceControlMutexRelease@0 PROC			; COMDAT

; 491  : 	KeReleaseMutex (&RootDeviceControlMutex, FALSE);

  00000	6a 00		 push	 0
  00002	68 00 00 00 00	 push	 OFFSET _RootDeviceControlMutex
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeReleaseMutex@8

; 492  : }

  0000d	c3		 ret	 0
_RootDeviceControlMutexRelease@0 ENDP
_TEXT	ENDS
PUBLIC	_TCStartThreadInProcess@16
EXTRN	__imp__ZwClose@4:PROC
EXTRN	__imp__ObReferenceObjectByHandle@24:PROC
EXTRN	__imp__PsCreateSystemThread@28:PROC
EXTRN	__imp__ObOpenObjectByPointer@28:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCStartThreadInProcess@16
_TEXT	SEGMENT
_threadObjAttributes$ = -28				; size = 24
_processHandle$ = -4					; size = 4
_threadProc$ = 8					; size = 4
_threadArg$ = 12					; size = 4
_kThread$ = 16						; size = 4
_threadHandle$ = 20					; size = 4
_process$ = 20						; size = 4
_TCStartThreadInProcess@16 PROC				; COMDAT

; 1565 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00008	56		 push	 esi

; 1566 : 	NTSTATUS status;
; 1567 : 	HANDLE threadHandle;
; 1568 : 	HANDLE processHandle = NULL;

  00009	33 f6		 xor	 esi, esi
  0000b	57		 push	 edi
  0000c	89 75 fc	 mov	 DWORD PTR _processHandle$[ebp], esi

; 1569 : 	OBJECT_ATTRIBUTES threadObjAttributes;
; 1570 : 
; 1571 : 	if (process)

  0000f	bf 00 02 00 00	 mov	 edi, 512		; 00000200H
  00014	39 75 14	 cmp	 DWORD PTR _process$[ebp], esi
  00017	74 16		 je	 SHORT $LN8@TCStartThr

; 1572 : 	{
; 1573 : 		status = ObOpenObjectByPointer (process, OBJ_KERNEL_HANDLE, NULL, 0, NULL, KernelMode, &processHandle);

  00019	8d 45 fc	 lea	 eax, DWORD PTR _processHandle$[ebp]
  0001c	50		 push	 eax
  0001d	56		 push	 esi
  0001e	56		 push	 esi
  0001f	56		 push	 esi
  00020	56		 push	 esi
  00021	57		 push	 edi
  00022	ff 75 14	 push	 DWORD PTR _process$[ebp]
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ObOpenObjectByPointer@28

; 1574 : 		if (!NT_SUCCESS (status))

  0002b	3b c6		 cmp	 eax, esi

; 1575 : 			return status;

  0002d	7c 77		 jl	 SHORT $LN6@TCStartThr
$LN8@TCStartThr:

; 1576 : 	}
; 1577 : 
; 1578 : 	InitializeObjectAttributes (&threadObjAttributes, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);
; 1579 : 	
; 1580 : 	status = PsCreateSystemThread (&threadHandle, THREAD_ALL_ACCESS, &threadObjAttributes, processHandle, NULL, threadProc, threadArg);

  0002f	ff 75 0c	 push	 DWORD PTR _threadArg$[ebp]
  00032	8d 45 e4	 lea	 eax, DWORD PTR _threadObjAttributes$[ebp]
  00035	ff 75 08	 push	 DWORD PTR _threadProc$[ebp]
  00038	89 7d f0	 mov	 DWORD PTR _threadObjAttributes$[ebp+12], edi
  0003b	56		 push	 esi
  0003c	ff 75 fc	 push	 DWORD PTR _processHandle$[ebp]
  0003f	bf ff 03 1f 00	 mov	 edi, 2032639		; 001f03ffH
  00044	50		 push	 eax
  00045	57		 push	 edi
  00046	8d 45 14	 lea	 eax, DWORD PTR _threadHandle$[ebp]
  00049	50		 push	 eax
  0004a	c7 45 e4 18 00
	00 00		 mov	 DWORD PTR _threadObjAttributes$[ebp], 24 ; 00000018H
  00051	89 75 e8	 mov	 DWORD PTR _threadObjAttributes$[ebp+4], esi
  00054	89 75 ec	 mov	 DWORD PTR _threadObjAttributes$[ebp+8], esi
  00057	89 75 f4	 mov	 DWORD PTR _threadObjAttributes$[ebp+16], esi
  0005a	89 75 f8	 mov	 DWORD PTR _threadObjAttributes$[ebp+20], esi
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsCreateSystemThread@28

; 1581 : 	if (!NT_SUCCESS (status))

  00063	3b c6		 cmp	 eax, esi

; 1582 : 		return status;

  00065	7c 3f		 jl	 SHORT $LN6@TCStartThr
  00067	53		 push	 ebx

; 1583 : 
; 1584 : 	status = ObReferenceObjectByHandle (threadHandle, THREAD_ALL_ACCESS, NULL, KernelMode, (PVOID *) kThread, NULL);

  00068	8b 5d 10	 mov	 ebx, DWORD PTR _kThread$[ebp]
  0006b	56		 push	 esi
  0006c	53		 push	 ebx
  0006d	56		 push	 esi
  0006e	56		 push	 esi
  0006f	57		 push	 edi
  00070	ff 75 14	 push	 DWORD PTR _threadHandle$[ebp]
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ObReferenceObjectByHandle@24
  00079	8b f8		 mov	 edi, eax

; 1585 : 	if (!NT_SUCCESS (status))

  0007b	3b fe		 cmp	 edi, esi
  0007d	7d 0f		 jge	 SHORT $LN2@TCStartThr

; 1586 : 	{
; 1587 : 		ZwClose (threadHandle);

  0007f	ff 75 14	 push	 DWORD PTR _threadHandle$[ebp]
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 1588 : 		*kThread = NULL;

  00088	89 33		 mov	 DWORD PTR [ebx], esi

; 1589 : 		return status;

  0008a	8b c7		 mov	 eax, edi
  0008c	eb 17		 jmp	 SHORT $LN9@TCStartThr
$LN2@TCStartThr:

; 1590 : 	}
; 1591 : 
; 1592 : 	if (processHandle)

  0008e	39 75 fc	 cmp	 DWORD PTR _processHandle$[ebp], esi
  00091	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__ZwClose@4
  00097	74 05		 je	 SHORT $LN1@TCStartThr

; 1593 : 		ZwClose (processHandle);

  00099	ff 75 fc	 push	 DWORD PTR _processHandle$[ebp]
  0009c	ff d6		 call	 esi
$LN1@TCStartThr:

; 1594 : 
; 1595 : 	ZwClose (threadHandle);

  0009e	ff 75 14	 push	 DWORD PTR _threadHandle$[ebp]
  000a1	ff d6		 call	 esi

; 1596 : 	return STATUS_SUCCESS;

  000a3	33 c0		 xor	 eax, eax
$LN9@TCStartThr:
  000a5	5b		 pop	 ebx
$LN6@TCStartThr:
  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi

; 1597 : }

  000a8	c9		 leave
  000a9	c2 10 00	 ret	 16			; 00000010H
_TCStartThreadInProcess@16 ENDP
_TEXT	ENDS
PUBLIC	_TCStopThread@8
EXTRN	__imp_@ObfDereferenceObject@4:PROC
EXTRN	__imp__KeSetEvent@12:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCStopThread@8
_TEXT	SEGMENT
_kThread$ = 8						; size = 4
_wakeUpEvent$ = 12					; size = 4
_TCStopThread@8 PROC					; COMDAT

; 1601 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 1602 : 	if (wakeUpEvent)

  00006	33 f6		 xor	 esi, esi
  00008	39 75 0c	 cmp	 DWORD PTR _wakeUpEvent$[ebp], esi
  0000b	74 0b		 je	 SHORT $LN1@TCStopThre

; 1603 : 		KeSetEvent (wakeUpEvent, 0, FALSE);

  0000d	56		 push	 esi
  0000e	56		 push	 esi
  0000f	ff 75 0c	 push	 DWORD PTR _wakeUpEvent$[ebp]
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
$LN1@TCStopThre:

; 1604 : 
; 1605 : 	KeWaitForSingleObject (kThread, Executive, KernelMode, FALSE, NULL);

  00018	56		 push	 esi
  00019	56		 push	 esi
  0001a	56		 push	 esi
  0001b	56		 push	 esi
  0001c	ff 75 08	 push	 DWORD PTR _kThread$[ebp]
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 1606 : 	ObDereferenceObject (kThread);

  00025	8b 4d 08	 mov	 ecx, DWORD PTR _kThread$[ebp]
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4
  0002e	5e		 pop	 esi

; 1607 : }

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
_TCStopThread@8 ENDP
_TEXT	ENDS
PUBLIC	_TCStopVolumeThread@8
EXTRN	__imp__KeReleaseSemaphore@16:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCStopVolumeThread@8
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_Extension$ = 12					; size = 4
_TCStopVolumeThread@8 PROC				; COMDAT

; 1688 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 1689 : 	NTSTATUS ntStatus;
; 1690 : 
; 1691 : 	if (DeviceObject);	/* Remove compiler warning */
; 1692 : 
; 1693 : 	Dump ("Signalling thread to quit...\n");
; 1694 : 
; 1695 : 	Extension->bThreadShouldQuit = TRUE;

  00006	8b 75 0c	 mov	 esi, DWORD PTR _Extension$[ebp]
  00009	57		 push	 edi
  0000a	33 c0		 xor	 eax, eax
  0000c	40		 inc	 eax

; 1696 : 
; 1697 : 	KeReleaseSemaphore (&Extension->RequestSemaphore,
; 1698 : 			    0,
; 1699 : 			    1,
; 1700 : 			    TRUE);

  0000d	50		 push	 eax
  0000e	50		 push	 eax
  0000f	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  00012	33 ff		 xor	 edi, edi
  00014	57		 push	 edi
  00015	8d 46 40	 lea	 eax, DWORD PTR [esi+64]
  00018	50		 push	 eax
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeReleaseSemaphore@16

; 1701 : 
; 1702 : 	ntStatus = KeWaitForSingleObject (Extension->peThread,
; 1703 : 					  Executive,
; 1704 : 					  KernelMode,
; 1705 : 					  FALSE,
; 1706 : 					  NULL);

  0001f	57		 push	 edi
  00020	57		 push	 edi
  00021	57		 push	 edi
  00022	57		 push	 edi
  00023	ff 76 20	 push	 DWORD PTR [esi+32]
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 1707 : 
; 1708 : 	ASSERT (NT_SUCCESS (ntStatus));
; 1709 : 
; 1710 : 	ObDereferenceObject (Extension->peThread);

  0002c	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 1711 : 	Extension->peThread = NULL;

  00035	89 7e 20	 mov	 DWORD PTR [esi+32], edi
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi

; 1712 : 
; 1713 : 	Dump ("Thread exited\n");
; 1714 : }

  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
_TCStopVolumeThread@8 ENDP
_TEXT	ENDS
PUBLIC	_TCSleep@4
EXTRN	__imp__KeSetTimerEx@20:PROC
EXTRN	__imp__KeInitializeTimerEx@8:PROC
EXTRN	__imp__ExAllocatePoolWithTag@12:PROC
EXTRN	__allmul:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCSleep@4
_TEXT	SEGMENT
_duetime$ = -8						; size = 8
_milliSeconds$ = 8					; size = 4
_TCSleep@4 PROC						; COMDAT

; 1719 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	51		 push	 ecx
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi

; 1720 : 	PKTIMER timer = (PKTIMER) TCalloc (sizeof (KTIMER));

  0000a	bf 54 43 4d 4d	 mov	 edi, 1296909140		; 4d4d4354H
  0000f	57		 push	 edi
  00010	6a 28		 push	 40			; 00000028H
  00012	33 f6		 xor	 esi, esi
  00014	56		 push	 esi
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0001b	8b d8		 mov	 ebx, eax

; 1721 : 	LARGE_INTEGER duetime;
; 1722 : 
; 1723 : 	if (!timer)

  0001d	3b de		 cmp	 ebx, esi
  0001f	74 42		 je	 SHORT $LN2@TCSleep

; 1724 : 		return;
; 1725 : 
; 1726 : 	duetime.QuadPart = (__int64) milliSeconds * -10000;

  00021	8b 45 08	 mov	 eax, DWORD PTR _milliSeconds$[ebp]
  00024	6a ff		 push	 -1
  00026	99		 cdq
  00027	68 f0 d8 ff ff	 push	 -10000			; ffffd8f0H
  0002c	52		 push	 edx
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 __allmul

; 1727 : 	KeInitializeTimerEx(timer, NotificationTimer);

  00033	56		 push	 esi
  00034	53		 push	 ebx
  00035	89 45 f8	 mov	 DWORD PTR _duetime$[ebp], eax
  00038	89 55 fc	 mov	 DWORD PTR _duetime$[ebp+4], edx
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeTimerEx@8

; 1728 : 	KeSetTimerEx(timer, duetime, 0, NULL);

  00041	56		 push	 esi
  00042	56		 push	 esi
  00043	ff 75 fc	 push	 DWORD PTR _duetime$[ebp+4]
  00046	ff 75 f8	 push	 DWORD PTR _duetime$[ebp]
  00049	53		 push	 ebx
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetTimerEx@20

; 1729 : 
; 1730 : 	KeWaitForSingleObject (timer, Executive, KernelMode, FALSE, NULL);

  00050	56		 push	 esi
  00051	56		 push	 esi
  00052	56		 push	 esi
  00053	56		 push	 esi
  00054	53		 push	 ebx
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 1731 : 
; 1732 : 	TCfree (timer);

  0005b	57		 push	 edi
  0005c	53		 push	 ebx
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN2@TCSleep:
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx

; 1733 : }

  00066	c9		 leave
  00067	c2 04 00	 ret	 4
_TCSleep@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DA@GMJGMIMP@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	__$ArrayPad$
PUBLIC	_TCGetNTNameFromNumber@8
EXTRN	__imp__wcsncat:PROC
;	COMDAT ??_C@_1DA@GMJGMIMP@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DA@GMJGMIMP@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'T', 00H, 'r', 00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r'
	DB	00H, 'y', 00H, 'p', 00H, 't', 00H, 'V', 00H, 'o', 00H, 'l', 00H
	DB	'u', 00H, 'm', 00H, 'e', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
text$s	ENDS
;	COMDAT _TCGetNTNameFromNumber@8
_TEXT	SEGMENT
_tmp$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
_ntname$ = 8						; size = 4
_nDriveNo$ = 12						; size = 4
_TCGetNTNameFromNumber@8 PROC				; COMDAT

; 1844 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00012	56		 push	 esi
  00013	8b 75 08	 mov	 esi, DWORD PTR _ntname$[ebp]

; 1845 : 	WCHAR tmp[3] =
; 1846 : 	{0, ':', 0};

  00016	6a 3a		 push	 58			; 0000003aH
  00018	58		 pop	 eax
  00019	66 89 45 f6	 mov	 WORD PTR _tmp$[ebp+2], ax
  0001d	33 c0		 xor	 eax, eax
  0001f	66 89 45 f8	 mov	 WORD PTR _tmp$[ebp+4], ax

; 1847 : 	int j = nDriveNo + (WCHAR) 'A';

  00023	8b 45 0c	 mov	 eax, DWORD PTR _nDriveNo$[ebp]
  00026	83 c0 41	 add	 eax, 65			; 00000041H

; 1848 : 
; 1849 : 	tmp[0] = (short) j;

  00029	66 89 45 f4	 mov	 WORD PTR _tmp$[ebp], ax

; 1850 : 	wcscpy (ntname, (LPWSTR) NT_MOUNT_PREFIX);

  0002d	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DA@GMJGMIMP@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@FNODOBFM@
  00032	8b d6		 mov	 edx, esi
  00034	2b d0		 sub	 edx, eax
$LL3@TCGetNTNam:
  00036	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00039	66 89 0c 02	 mov	 WORD PTR [edx+eax], cx
  0003d	40		 inc	 eax
  0003e	40		 inc	 eax
  0003f	66 85 c9	 test	 cx, cx
  00042	75 f2		 jne	 SHORT $LL3@TCGetNTNam

; 1851 : 	wcsncat (ntname, tmp, 1);

  00044	6a 01		 push	 1
  00046	8d 45 f4	 lea	 eax, DWORD PTR _tmp$[ebp]
  00049	50		 push	 eax
  0004a	56		 push	 esi
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcsncat

; 1852 : }

  00051	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
  00057	33 cd		 xor	 ecx, ebp
  00059	5e		 pop	 esi
  0005a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005f	c9		 leave
  00060	c2 08 00	 ret	 8
_TCGetNTNameFromNumber@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	__$ArrayPad$
PUBLIC	_TCGetDosNameFromNumber@8
;	COMDAT ??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
text$s	ENDS
;	COMDAT _TCGetDosNameFromNumber@8
_TEXT	SEGMENT
_tmp$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
_dosname$ = 8						; size = 4
_nDriveNo$ = 12						; size = 4
_TCGetDosNameFromNumber@8 PROC				; COMDAT

; 1855 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _dosname$[ebp]
  00015	56		 push	 esi
  00016	57		 push	 edi

; 1856 : 	WCHAR tmp[3] =
; 1857 : 	{0, ':', 0};

  00017	6a 3a		 push	 58			; 0000003aH
  00019	58		 pop	 eax
  0001a	66 89 45 f6	 mov	 WORD PTR _tmp$[ebp+2], ax
  0001e	33 c0		 xor	 eax, eax
  00020	66 89 45 f8	 mov	 WORD PTR _tmp$[ebp+4], ax

; 1858 : 	int j = nDriveNo + (WCHAR) 'A';

  00024	8b 45 0c	 mov	 eax, DWORD PTR _nDriveNo$[ebp]
  00027	83 c0 41	 add	 eax, 65			; 00000041H

; 1859 : 
; 1860 : 	tmp[0] = (short) j;

  0002a	66 89 45 f4	 mov	 WORD PTR _tmp$[ebp], ax

; 1861 : 	wcscpy (dosname, (LPWSTR) DOS_MOUNT_PREFIX);

  0002e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@FNODOBFM@
  00033	8b f1		 mov	 esi, ecx
  00035	2b f0		 sub	 esi, eax
$LL3@TCGetDosNa:
  00037	0f b7 10	 movzx	 edx, WORD PTR [eax]
  0003a	66 89 14 06	 mov	 WORD PTR [esi+eax], dx
  0003e	40		 inc	 eax
  0003f	40		 inc	 eax
  00040	66 85 d2	 test	 dx, dx
  00043	75 f2		 jne	 SHORT $LL3@TCGetDosNa

; 1862 : 	wcscat (dosname, tmp);

  00045	8d 45 f4	 lea	 eax, DWORD PTR _tmp$[ebp]
  00048	8b f0		 mov	 esi, eax
$LL5@TCGetDosNa:
  0004a	66 8b 10	 mov	 dx, WORD PTR [eax]
  0004d	40		 inc	 eax
  0004e	40		 inc	 eax
  0004f	66 85 d2	 test	 dx, dx
  00052	75 f6		 jne	 SHORT $LL5@TCGetDosNa
  00054	2b c6		 sub	 eax, esi
  00056	49		 dec	 ecx
  00057	49		 dec	 ecx
$LL6@TCGetDosNa:
  00058	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  0005c	41		 inc	 ecx
  0005d	41		 inc	 ecx
  0005e	66 85 d2	 test	 dx, dx
  00061	75 f5		 jne	 SHORT $LL6@TCGetDosNa
  00063	8b f9		 mov	 edi, ecx
  00065	8b c8		 mov	 ecx, eax
  00067	c1 e9 02	 shr	 ecx, 2
  0006a	f3 a5		 rep movsd
  0006c	8b c8		 mov	 ecx, eax
  0006e	83 e1 03	 and	 ecx, 3
  00071	f3 a4		 rep movsb

; 1863 : }

  00073	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00076	5f		 pop	 edi
  00077	33 cd		 xor	 ecx, ebp
  00079	5e		 pop	 esi
  0007a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007f	c9		 leave
  00080	c2 08 00	 ret	 8
_TCGetDosNameFromNumber@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EA@FPAPEGHJ@?$AAP?$AAs?$AAD?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAI?$AAm?$AAp?$AAe?$AAr?$AAs?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAk?$AAe?$AAn?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_TCDeleteDeviceObject@8
EXTRN	__imp__SeTokenType@4:PROC
EXTRN	__imp__KeBugCheckEx@20:PROC
EXTRN	__imp__MmGetSystemRoutineAddress@4:PROC
EXTRN	__imp__IoDeleteSymbolicLink@4:PROC
;	COMDAT ??_C@_1EA@FPAPEGHJ@?$AAP?$AAs?$AAD?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAI?$AAm?$AAp?$AAe?$AAr?$AAs?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAk?$AAe?$AAn?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1EA@FPAPEGHJ@?$AAP?$AAs?$AAD?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAI?$AAm?$AAp?$AAe?$AAr?$AAs?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAk?$AAe?$AAn?$AA?$AA@FNODOBFM@ DB 'P'
	DB	00H, 's', 00H, 'D', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H
	DB	'e', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, 'I'
	DB	00H, 'm', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 's', 00H, 'o', 00H
	DB	'n', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'T'
	DB	00H, 'o', 00H, 'k', 00H, 'e', 00H, 'n', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'T', 00H, 'r'
	DB	00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r', 00H, 'y', 00H, 'p', 00H
	DB	't', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
text$s	ENDS
;	COMDAT _TCDeleteDeviceObject@8
_TEXT	SEGMENT
_name$30624 = -16					; size = 8
_Win32NameString$ = -8					; size = 8
_DeviceObject$ = 8					; size = 4
_Extension$ = 12					; size = 4
_TCDeleteDeviceObject@8 PROC				; COMDAT

; 2031 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 10	 sub	 esp, 16			; 00000010H
  00008	56		 push	 esi

; 2032 : 	UNICODE_STRING Win32NameString;
; 2033 : 	NTSTATUS ntStatus;
; 2034 : 
; 2035 : 	Dump ("TCDeleteDeviceObject BEGIN\n");
; 2036 : 
; 2037 : 	if (Extension->bRootDevice)

  00009	8b 75 0c	 mov	 esi, DWORD PTR _Extension$[ebp]
  0000c	57		 push	 edi
  0000d	33 ff		 xor	 edi, edi
  0000f	39 3e		 cmp	 DWORD PTR [esi], edi
  00011	74 24		 je	 SHORT $LN11@TCDeleteDe

; 2038 : 	{
; 2039 : 		RtlInitUnicodeString (&Win32NameString, (LPWSTR) DOS_ROOT_PREFIX);

  00013	68 00 00 00 00	 push	 OFFSET ??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
  00018	8d 45 f8	 lea	 eax, DWORD PTR _Win32NameString$[ebp]
  0001b	50		 push	 eax
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 2040 : 		ntStatus = IoDeleteSymbolicLink (&Win32NameString);

  00022	8d 45 f8	 lea	 eax, DWORD PTR _Win32NameString$[ebp]
  00025	50		 push	 eax
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteSymbolicLink@4

; 2041 : 		if (!NT_SUCCESS (ntStatus))
; 2042 : 			Dump ("IoDeleteSymbolicLink failed ntStatus = 0x%08x\n", ntStatus);
; 2043 : 
; 2044 : 		RootDeviceObject = NULL;

  0002c	89 3d 00 00 00
	00		 mov	 DWORD PTR _RootDeviceObject, edi

; 2045 : 	}
; 2046 : 	else

  00032	e9 a7 00 00 00	 jmp	 $LN9@TCDeleteDe
$LN11@TCDeleteDe:

; 2047 : 	{
; 2048 : 		if (Extension->peThread != NULL)

  00037	39 7e 20	 cmp	 DWORD PTR [esi+32], edi
  0003a	74 09		 je	 SHORT $LN14@TCDeleteDe

; 2049 : 			TCStopVolumeThread (DeviceObject, Extension);

  0003c	56		 push	 esi
  0003d	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  00040	e8 00 00 00 00	 call	 _TCStopVolumeThread@8
$LN14@TCDeleteDe:

; 2050 : 
; 2051 : 		if (Extension->UserSid)

  00045	8b 86 8c 04 00
	00		 mov	 eax, DWORD PTR [esi+1164]
  0004b	3b c7		 cmp	 eax, edi
  0004d	74 0c		 je	 SHORT $LN7@TCDeleteDe

; 2052 : 			TCfree (Extension->UserSid);

  0004f	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00054	50		 push	 eax
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN7@TCDeleteDe:

; 2053 : 
; 2054 : 		if (Extension->SecurityClientContextValid)

  0005b	39 be 90 04 00
	00		 cmp	 DWORD PTR [esi+1168], edi
  00061	74 71		 je	 SHORT $LN1@TCDeleteDe

; 2055 : 		{
; 2056 : 			if (OsMajorVersion == 5 && OsMinorVersion == 0)

  00063	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR _OsMajorVersion, 5
  0006a	75 16		 jne	 SHORT $LN5@TCDeleteDe
  0006c	39 3d 00 00 00
	00		 cmp	 DWORD PTR _OsMinorVersion, edi
  00072	75 0e		 jne	 SHORT $LN5@TCDeleteDe

; 2057 : 			{
; 2058 : 				ObDereferenceObject (Extension->SecurityClientContext.ClientToken);

  00074	8b 8e a0 04 00
	00		 mov	 ecx, DWORD PTR [esi+1184]
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 2059 : 			}
; 2060 : 			else

  00080	eb 52		 jmp	 SHORT $LN1@TCDeleteDe
$LN5@TCDeleteDe:
  00082	53		 push	 ebx

; 2061 : 			{
; 2062 : 				// Windows 2000 does not support PsDereferenceImpersonationToken() used by SeDeleteClientSecurity().
; 2063 : 				// TODO: Use only SeDeleteClientSecurity() once support for Windows 2000 is dropped.
; 2064 : 
; 2065 : 				VOID (*PsDereferenceImpersonationTokenD) (PACCESS_TOKEN ImpersonationToken);
; 2066 : 				UNICODE_STRING name;
; 2067 : 				RtlInitUnicodeString (&name, L"PsDereferenceImpersonationToken");

  00083	68 00 00 00 00	 push	 OFFSET ??_C@_1EA@FPAPEGHJ@?$AAP?$AAs?$AAD?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAI?$AAm?$AAp?$AAe?$AAr?$AAs?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAk?$AAe?$AAn?$AA?$AA@FNODOBFM@
  00088	8d 45 f0	 lea	 eax, DWORD PTR _name$30624[ebp]
  0008b	50		 push	 eax
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 2068 : 
; 2069 : 				PsDereferenceImpersonationTokenD = MmGetSystemRoutineAddress (&name);

  00092	8d 45 f0	 lea	 eax, DWORD PTR _name$30624[ebp]
  00095	50		 push	 eax
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmGetSystemRoutineAddress@4
  0009c	8b d8		 mov	 ebx, eax

; 2070 : 				if (!PsDereferenceImpersonationTokenD)

  0009e	3b df		 cmp	 ebx, edi
  000a0	75 18		 jne	 SHORT $LN3@TCDeleteDe

; 2071 : 					TC_BUG_CHECK (STATUS_NOT_IMPLEMENTED);

  000a2	68 43 54 00 00	 push	 21571			; 00005443H
  000a7	57		 push	 edi
  000a8	68 02 00 00 c0	 push	 -1073741822		; c0000002H
  000ad	68 17 08 00 00	 push	 2071			; 00000817H
  000b2	6a 29		 push	 41			; 00000029H
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN18@TCDeleteDe:
$LN3@TCDeleteDe:

; 2072 : 				
; 2073 : #				define PsDereferencePrimaryToken
; 2074 : #				define PsDereferenceImpersonationToken PsDereferenceImpersonationTokenD
; 2075 : 
; 2076 : 				SeDeleteClientSecurity (&Extension->SecurityClientContext);

  000ba	8d be a0 04 00
	00		 lea	 edi, DWORD PTR [esi+1184]
  000c0	ff 37		 push	 DWORD PTR [edi]
  000c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeTokenType@4
  000c8	83 f8 01	 cmp	 eax, 1
  000cb	74 04		 je	 SHORT $LN15@TCDeleteDe
  000cd	ff 37		 push	 DWORD PTR [edi]
  000cf	ff d3		 call	 ebx
$LN15@TCDeleteDe:
  000d1	33 ff		 xor	 edi, edi
  000d3	5b		 pop	 ebx
$LN1@TCDeleteDe:

; 2077 : 
; 2078 : #				undef PsDereferencePrimaryToken
; 2079 : #				undef PsDereferenceImpersonationToken
; 2080 : 			}
; 2081 : 		}
; 2082 : 
; 2083 : 		VirtualVolumeDeviceObjects[Extension->nDosDriveNo] = NULL;

  000d4	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000d7	89 3c 85 00 00
	00 00		 mov	 DWORD PTR _VirtualVolumeDeviceObjects[eax*4], edi
$LN9@TCDeleteDe:

; 2084 : 	}
; 2085 : 
; 2086 : 	IoDeleteDevice (DeviceObject);

  000de	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  000e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteDevice@4
  000e7	5f		 pop	 edi
  000e8	5e		 pop	 esi

; 2087 : 
; 2088 : 	Dump ("TCDeleteDeviceObject END\n");
; 2089 : }

  000e9	c9		 leave
  000ea	c2 08 00	 ret	 8
$LN17@TCDeleteDe:
_TCDeleteDeviceObject@8 ENDP
_TEXT	ENDS
PUBLIC	_TCDeviceIoControl@24
EXTRN	__imp_@IofCallDriver@8:PROC
EXTRN	__imp__IoBuildDeviceIoControlRequest@36:PROC
EXTRN	__imp__KeInitializeEvent@12:PROC
EXTRN	__imp__IoGetDeviceObjectPointer@16:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCDeviceIoControl@24
_TEXT	SEGMENT
_event$ = -36						; size = 16
_ioStatusBlock$ = -20					; size = 8
_name$ = -12						; size = 8
_fileObject$ = -4					; size = 4
_deviceObject$ = 8					; size = 4
_deviceName$ = 8					; size = 4
_IoControlCode$ = 12					; size = 4
_InputBuffer$ = 16					; size = 4
_InputBufferSize$ = 20					; size = 4
_OutputBuffer$ = 24					; size = 4
_OutputBufferSize$ = 28					; size = 4
_TCDeviceIoControl@24 PROC				; COMDAT

; 2122 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 24	 sub	 esp, 36			; 00000024H
  00008	57		 push	 edi

; 2123 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2124 : 	NTSTATUS ntStatus;
; 2125 : 	PIRP irp;
; 2126 : 	PFILE_OBJECT fileObject;
; 2127 : 	PDEVICE_OBJECT deviceObject;
; 2128 : 	KEVENT event;
; 2129 : 	UNICODE_STRING name;
; 2130 : 
; 2131 : 	RtlInitUnicodeString(&name, deviceName);

  00009	ff 75 08	 push	 DWORD PTR _deviceName$[ebp]
  0000c	8d 45 f4	 lea	 eax, DWORD PTR _name$[ebp]
  0000f	50		 push	 eax
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 2132 : 	ntStatus = IoGetDeviceObjectPointer (&name, FILE_READ_ATTRIBUTES, &fileObject, &deviceObject);

  00016	8d 45 08	 lea	 eax, DWORD PTR _deviceObject$[ebp]
  00019	50		 push	 eax
  0001a	8d 45 fc	 lea	 eax, DWORD PTR _fileObject$[ebp]
  0001d	50		 push	 eax
  0001e	68 80 00 00 00	 push	 128			; 00000080H
  00023	8d 45 f4	 lea	 eax, DWORD PTR _name$[ebp]
  00026	50		 push	 eax
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoGetDeviceObjectPointer@16

; 2133 : 
; 2134 : 	if (!NT_SUCCESS (ntStatus))

  0002d	33 ff		 xor	 edi, edi
  0002f	3b c7		 cmp	 eax, edi

; 2135 : 		return ntStatus;

  00031	7c 74		 jl	 SHORT $LN4@TCDeviceIo
  00033	56		 push	 esi

; 2136 : 
; 2137 : 	KeInitializeEvent(&event, NotificationEvent, FALSE);

  00034	57		 push	 edi
  00035	57		 push	 edi
  00036	8d 45 dc	 lea	 eax, DWORD PTR _event$[ebp]
  00039	50		 push	 eax
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 2138 : 
; 2139 : 	irp = IoBuildDeviceIoControlRequest (IoControlCode,
; 2140 : 					     deviceObject,
; 2141 : 					     InputBuffer, InputBufferSize,
; 2142 : 					     OutputBuffer, OutputBufferSize,
; 2143 : 					     FALSE,
; 2144 : 					     &event,
; 2145 : 					     &ioStatusBlock);

  00040	8d 45 ec	 lea	 eax, DWORD PTR _ioStatusBlock$[ebp]
  00043	50		 push	 eax
  00044	8d 45 dc	 lea	 eax, DWORD PTR _event$[ebp]
  00047	50		 push	 eax
  00048	57		 push	 edi
  00049	ff 75 1c	 push	 DWORD PTR _OutputBufferSize$[ebp]
  0004c	ff 75 18	 push	 DWORD PTR _OutputBuffer$[ebp]
  0004f	ff 75 14	 push	 DWORD PTR _InputBufferSize$[ebp]
  00052	ff 75 10	 push	 DWORD PTR _InputBuffer$[ebp]
  00055	ff 75 08	 push	 DWORD PTR _deviceObject$[ebp]
  00058	ff 75 0c	 push	 DWORD PTR _IoControlCode$[ebp]
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 2146 : 
; 2147 : 	if (irp == NULL)

  00061	3b c7		 cmp	 eax, edi
  00063	75 07		 jne	 SHORT $LN2@TCDeviceIo

; 2148 : 	{
; 2149 : 		Dump ("IRP allocation failed\n");
; 2150 : 		ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00065	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH

; 2151 : 		goto ret;

  0006a	eb 2f		 jmp	 SHORT $ret$30679
$LN2@TCDeviceIo:

; 2152 : 	}
; 2153 : 
; 2154 : 	IoGetNextIrpStackLocation (irp)->FileObject = fileObject;

  0006c	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0006f	8b 55 fc	 mov	 edx, DWORD PTR _fileObject$[ebp]
  00072	89 51 f4	 mov	 DWORD PTR [ecx-12], edx

; 2155 : 
; 2156 : 	ntStatus = IoCallDriver (deviceObject, irp);

  00075	8b 4d 08	 mov	 ecx, DWORD PTR _deviceObject$[ebp]
  00078	8b d0		 mov	 edx, eax
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8
  00080	8b f0		 mov	 esi, eax

; 2157 : 	if (ntStatus == STATUS_PENDING)

  00082	81 fe 03 01 00
	00		 cmp	 esi, 259		; 00000103H
  00088	75 11		 jne	 SHORT $ret$30679

; 2158 : 	{
; 2159 : 		KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);

  0008a	57		 push	 edi
  0008b	57		 push	 edi
  0008c	57		 push	 edi
  0008d	57		 push	 edi
  0008e	8d 45 dc	 lea	 eax, DWORD PTR _event$[ebp]
  00091	50		 push	 eax
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 2160 : 		ntStatus = ioStatusBlock.Status;

  00098	8b 75 ec	 mov	 esi, DWORD PTR _ioStatusBlock$[ebp]
$ret$30679:

; 2161 : 	}
; 2162 : 
; 2163 : ret:
; 2164 : 	ObDereferenceObject (fileObject);

  0009b	8b 4d fc	 mov	 ecx, DWORD PTR _fileObject$[ebp]
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 2165 : 	return ntStatus;

  000a4	8b c6		 mov	 eax, esi
  000a6	5e		 pop	 esi
$LN4@TCDeviceIo:
  000a7	5f		 pop	 edi

; 2166 : }

  000a8	c9		 leave
  000a9	c2 18 00	 ret	 24			; 00000018H
_TCDeviceIoControl@24 ENDP
_TEXT	ENDS
PUBLIC	_SendDeviceIoControlRequest@24
; Function compile flags: /Ogsp
;	COMDAT _SendDeviceIoControlRequestWorkItemRoutine@8
_TEXT	SEGMENT
_rootDeviceObject$ = 8					; size = 4
_arg$ = 12						; size = 4
_SendDeviceIoControlRequestWorkItemRoutine@8 PROC	; COMDAT

; 2178 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 2179 : 	arg->Status = SendDeviceIoControlRequest (arg->deviceObject, arg->ioControlCode, arg->inputBuffer, arg->inputBufferSize, arg->outputBuffer, arg->outputBufferSize);

  00006	8b 75 0c	 mov	 esi, DWORD PTR _arg$[ebp]
  00009	ff 76 14	 push	 DWORD PTR [esi+20]
  0000c	ff 76 10	 push	 DWORD PTR [esi+16]
  0000f	ff 76 0c	 push	 DWORD PTR [esi+12]
  00012	ff 76 08	 push	 DWORD PTR [esi+8]
  00015	ff 76 04	 push	 DWORD PTR [esi+4]
  00018	ff 36		 push	 DWORD PTR [esi]
  0001a	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24

; 2180 : 	KeSetEvent (&arg->WorkItemCompletedEvent, IO_NO_INCREMENT, FALSE);

  0001f	6a 00		 push	 0
  00021	89 46 18	 mov	 DWORD PTR [esi+24], eax
  00024	6a 00		 push	 0
  00026	83 c6 1c	 add	 esi, 28			; 0000001cH
  00029	56		 push	 esi
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
  00030	5e		 pop	 esi

; 2181 : }

  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
_SendDeviceIoControlRequestWorkItemRoutine@8 ENDP
_TEXT	ENDS
EXTRN	__imp_@ObfReferenceObject@4:PROC
EXTRN	__imp__IoFreeWorkItem@4:PROC
EXTRN	__imp__IoQueueWorkItem@16:PROC
EXTRN	__imp__IoAllocateWorkItem@4:PROC
EXTRN	__imp__KeGetCurrentIrql@0:PROC
; Function compile flags: /Ogsp
;	COMDAT _SendDeviceIoControlRequest@24
_TEXT	SEGMENT
_args$30717 = -68					; size = 44
_event$ = -24						; size = 16
_ioStatusBlock$ = -8					; size = 8
_deviceObject$ = 8					; size = 4
_ioControlCode$ = 12					; size = 4
_inputBuffer$ = 16					; size = 4
_inputBufferSize$ = 20					; size = 4
_outputBuffer$ = 24					; size = 4
_outputBufferSize$ = 28					; size = 4
_SendDeviceIoControlRequest@24 PROC			; COMDAT

; 2185 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 44	 sub	 esp, 68			; 00000044H
  00008	56		 push	 esi
  00009	57		 push	 edi

; 2186 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2187 : 	NTSTATUS status;
; 2188 : 	PIRP irp;
; 2189 : 	KEVENT event;
; 2190 : 
; 2191 : 	if (KeGetCurrentIrql() > APC_LEVEL)

  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeGetCurrentIrql@0
  00010	3c 01		 cmp	 al, 1
  00012	76 7b		 jbe	 SHORT $LN4@SendDevice

; 2192 : 	{
; 2193 : 		SendDeviceIoControlRequestWorkItemArgs args;
; 2194 : 
; 2195 : 		PIO_WORKITEM workItem = IoAllocateWorkItem (RootDeviceObject);

  00014	ff 35 00 00 00
	00		 push	 DWORD PTR _RootDeviceObject
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAllocateWorkItem@4
  00020	8b f8		 mov	 edi, eax

; 2196 : 		if (!workItem)

  00022	33 f6		 xor	 esi, esi
  00024	3b fe		 cmp	 edi, esi
  00026	75 0a		 jne	 SHORT $LN3@SendDevice

; 2197 : 			return STATUS_INSUFFICIENT_RESOURCES;

  00028	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  0002d	e9 d3 00 00 00	 jmp	 $LN5@SendDevice
$LN3@SendDevice:

; 2198 : 
; 2199 : 		args.deviceObject = deviceObject;

  00032	8b 45 08	 mov	 eax, DWORD PTR _deviceObject$[ebp]
  00035	89 45 bc	 mov	 DWORD PTR _args$30717[ebp], eax

; 2200 : 		args.ioControlCode = ioControlCode;

  00038	8b 45 0c	 mov	 eax, DWORD PTR _ioControlCode$[ebp]
  0003b	89 45 c0	 mov	 DWORD PTR _args$30717[ebp+4], eax

; 2201 : 		args.inputBuffer = inputBuffer;

  0003e	8b 45 10	 mov	 eax, DWORD PTR _inputBuffer$[ebp]
  00041	89 45 c4	 mov	 DWORD PTR _args$30717[ebp+8], eax

; 2202 : 		args.inputBufferSize = inputBufferSize;

  00044	8b 45 14	 mov	 eax, DWORD PTR _inputBufferSize$[ebp]
  00047	89 45 c8	 mov	 DWORD PTR _args$30717[ebp+12], eax

; 2203 : 		args.outputBuffer = outputBuffer;

  0004a	8b 45 18	 mov	 eax, DWORD PTR _outputBuffer$[ebp]
  0004d	89 45 cc	 mov	 DWORD PTR _args$30717[ebp+16], eax

; 2204 : 		args.outputBufferSize = outputBufferSize;

  00050	8b 45 1c	 mov	 eax, DWORD PTR _outputBufferSize$[ebp]

; 2205 : 
; 2206 : 		KeInitializeEvent (&args.WorkItemCompletedEvent, SynchronizationEvent, FALSE);

  00053	56		 push	 esi
  00054	89 45 d0	 mov	 DWORD PTR _args$30717[ebp+20], eax
  00057	6a 01		 push	 1
  00059	8d 45 d8	 lea	 eax, DWORD PTR _args$30717[ebp+28]
  0005c	50		 push	 eax
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 2207 : 		IoQueueWorkItem (workItem, SendDeviceIoControlRequestWorkItemRoutine, DelayedWorkQueue, &args); 

  00063	8d 45 bc	 lea	 eax, DWORD PTR _args$30717[ebp]
  00066	50		 push	 eax
  00067	6a 01		 push	 1
  00069	68 00 00 00 00	 push	 OFFSET _SendDeviceIoControlRequestWorkItemRoutine@8
  0006e	57		 push	 edi
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoQueueWorkItem@16

; 2208 : 
; 2209 : 		KeWaitForSingleObject (&args.WorkItemCompletedEvent, Executive, KernelMode, FALSE, NULL);

  00075	56		 push	 esi
  00076	56		 push	 esi
  00077	56		 push	 esi
  00078	56		 push	 esi
  00079	8d 45 d8	 lea	 eax, DWORD PTR _args$30717[ebp+28]
  0007c	50		 push	 eax
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 2210 : 		IoFreeWorkItem (workItem);

  00083	57		 push	 edi
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoFreeWorkItem@4

; 2211 :  
; 2212 : 		return args.Status;

  0008a	8b 45 d4	 mov	 eax, DWORD PTR _args$30717[ebp+24]
  0008d	eb 76		 jmp	 SHORT $LN5@SendDevice
$LN4@SendDevice:
  0008f	53		 push	 ebx

; 2213 : 	}
; 2214 : 
; 2215 : 	KeInitializeEvent (&event, NotificationEvent, FALSE);

  00090	33 f6		 xor	 esi, esi
  00092	56		 push	 esi
  00093	56		 push	 esi
  00094	8d 45 e8	 lea	 eax, DWORD PTR _event$[ebp]
  00097	50		 push	 eax
  00098	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 2216 : 
; 2217 : 	irp = IoBuildDeviceIoControlRequest (ioControlCode, deviceObject, inputBuffer, inputBufferSize,
; 2218 : 		outputBuffer, outputBufferSize, FALSE, &event, &ioStatusBlock);

  0009e	8b 5d 08	 mov	 ebx, DWORD PTR _deviceObject$[ebp]
  000a1	8d 45 f8	 lea	 eax, DWORD PTR _ioStatusBlock$[ebp]
  000a4	50		 push	 eax
  000a5	8d 45 e8	 lea	 eax, DWORD PTR _event$[ebp]
  000a8	50		 push	 eax
  000a9	56		 push	 esi
  000aa	ff 75 1c	 push	 DWORD PTR _outputBufferSize$[ebp]
  000ad	ff 75 18	 push	 DWORD PTR _outputBuffer$[ebp]
  000b0	ff 75 14	 push	 DWORD PTR _inputBufferSize$[ebp]
  000b3	ff 75 10	 push	 DWORD PTR _inputBuffer$[ebp]
  000b6	53		 push	 ebx
  000b7	ff 75 0c	 push	 DWORD PTR _ioControlCode$[ebp]
  000ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36
  000c0	8b f8		 mov	 edi, eax

; 2219 : 
; 2220 : 	if (!irp)

  000c2	3b fe		 cmp	 edi, esi
  000c4	75 07		 jne	 SHORT $LN2@SendDevice

; 2221 : 		return STATUS_INSUFFICIENT_RESOURCES;

  000c6	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  000cb	eb 37		 jmp	 SHORT $LN7@SendDevice
$LN2@SendDevice:

; 2222 : 
; 2223 : 	ObReferenceObject (deviceObject);

  000cd	8b cb		 mov	 ecx, ebx
  000cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfReferenceObject@4

; 2224 : 
; 2225 : 	status = IoCallDriver (deviceObject, irp);

  000d5	8b d7		 mov	 edx, edi
  000d7	8b cb		 mov	 ecx, ebx
  000d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8
  000df	8b f8		 mov	 edi, eax

; 2226 : 	if (status == STATUS_PENDING)

  000e1	81 ff 03 01 00
	00		 cmp	 edi, 259		; 00000103H
  000e7	75 11		 jne	 SHORT $LN1@SendDevice

; 2227 : 	{
; 2228 : 		KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);

  000e9	56		 push	 esi
  000ea	56		 push	 esi
  000eb	56		 push	 esi
  000ec	56		 push	 esi
  000ed	8d 45 e8	 lea	 eax, DWORD PTR _event$[ebp]
  000f0	50		 push	 eax
  000f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 2229 : 		status = ioStatusBlock.Status;

  000f7	8b 7d f8	 mov	 edi, DWORD PTR _ioStatusBlock$[ebp]
$LN1@SendDevice:

; 2230 : 	}
; 2231 : 
; 2232 : 	ObDereferenceObject (deviceObject);

  000fa	8b cb		 mov	 ecx, ebx
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 2233 : 	return status;

  00102	8b c7		 mov	 eax, edi
$LN7@SendDevice:
  00104	5b		 pop	 ebx
$LN5@SendDevice:
  00105	5f		 pop	 edi
  00106	5e		 pop	 esi

; 2234 : }

  00107	c9		 leave
  00108	c2 18 00	 ret	 24			; 00000018H
_SendDeviceIoControlRequest@24 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_TCOpenFsVolume@12
EXTRN	__imp__ZwCreateFile@44:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCOpenFsVolume@12
_TEXT	SEGMENT
_ioStatus$ = -564					; size = 8
_fullFileName$ = -556					; size = 8
_objectAttributes$ = -548				; size = 24
_volumeName$ = -524					; size = 520
__$ArrayPad$ = -4					; size = 4
_Extension$ = 8						; size = 4
_volumeHandle$ = 12					; size = 4
_fileObject$ = 16					; size = 4
_TCOpenFsVolume@12 PROC					; COMDAT

; 2290 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 34 02 00
	00		 sub	 esp, 564		; 00000234H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2291 : 	NTSTATUS ntStatus;
; 2292 : 	OBJECT_ATTRIBUTES objectAttributes;
; 2293 : 	UNICODE_STRING fullFileName;
; 2294 : 	IO_STATUS_BLOCK ioStatus;
; 2295 : 	WCHAR volumeName[TC_MAX_PATH];
; 2296 : 
; 2297 : 	TCGetNTNameFromNumber (volumeName, Extension->nDosDriveNo);

  00015	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  00018	53		 push	 ebx
  00019	8b 5d 10	 mov	 ebx, DWORD PTR _fileObject$[ebp]
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	ff 70 14	 push	 DWORD PTR [eax+20]
  00021	8b 7d 0c	 mov	 edi, DWORD PTR _volumeHandle$[ebp]
  00024	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _volumeName$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 _TCGetNTNameFromNumber@8

; 2298 : 	RtlInitUnicodeString (&fullFileName, volumeName);

  00030	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _volumeName$[ebp]
  00036	50		 push	 eax
  00037	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _fullFileName$[ebp]
  0003d	50		 push	 eax
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 2299 : 	InitializeObjectAttributes (&objectAttributes, &fullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

  00044	33 f6		 xor	 esi, esi

; 2300 : 
; 2301 : 	ntStatus = ZwCreateFile (volumeHandle,
; 2302 : 		SYNCHRONIZE | GENERIC_READ,
; 2303 : 		&objectAttributes,
; 2304 : 		&ioStatus,
; 2305 : 		NULL,
; 2306 : 		FILE_ATTRIBUTE_NORMAL,
; 2307 : 		FILE_SHARE_READ | FILE_SHARE_WRITE,
; 2308 : 		FILE_OPEN,
; 2309 : 		FILE_SYNCHRONOUS_IO_NONALERT,
; 2310 : 		NULL,
; 2311 : 		0);

  00046	56		 push	 esi
  00047	56		 push	 esi
  00048	6a 20		 push	 32			; 00000020H
  0004a	6a 01		 push	 1
  0004c	6a 03		 push	 3
  0004e	68 80 00 00 00	 push	 128			; 00000080H
  00053	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _fullFileName$[ebp]
  00059	56		 push	 esi
  0005a	89 85 e4 fd ff
	ff		 mov	 DWORD PTR _objectAttributes$[ebp+8], eax
  00060	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _ioStatus$[ebp]
  00066	50		 push	 eax
  00067	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _objectAttributes$[ebp]
  0006d	50		 push	 eax
  0006e	68 00 00 10 80	 push	 -2146435072		; 80100000H
  00073	57		 push	 edi
  00074	c7 85 dc fd ff
	ff 18 00 00 00	 mov	 DWORD PTR _objectAttributes$[ebp], 24 ; 00000018H
  0007e	89 b5 e0 fd ff
	ff		 mov	 DWORD PTR _objectAttributes$[ebp+4], esi
  00084	c7 85 e8 fd ff
	ff 40 02 00 00	 mov	 DWORD PTR _objectAttributes$[ebp+12], 576 ; 00000240H
  0008e	89 b5 ec fd ff
	ff		 mov	 DWORD PTR _objectAttributes$[ebp+16], esi
  00094	89 b5 f0 fd ff
	ff		 mov	 DWORD PTR _objectAttributes$[ebp+20], esi
  0009a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwCreateFile@44

; 2312 : 
; 2313 : 	Dump ("Volume %ls open NTSTATUS 0x%08x\n", volumeName, ntStatus);
; 2314 : 
; 2315 : 	if (!NT_SUCCESS (ntStatus))

  000a0	3b c6		 cmp	 eax, esi

; 2316 : 		return ntStatus;

  000a2	7c 1e		 jl	 SHORT $LN3@TCOpenFsVo

; 2317 : 
; 2318 : 	ntStatus = ObReferenceObjectByHandle (*volumeHandle,
; 2319 : 		FILE_READ_DATA,
; 2320 : 		NULL,
; 2321 : 		KernelMode,
; 2322 : 		fileObject,
; 2323 : 		NULL);

  000a4	56		 push	 esi
  000a5	53		 push	 ebx
  000a6	56		 push	 esi
  000a7	56		 push	 esi
  000a8	6a 01		 push	 1
  000aa	ff 37		 push	 DWORD PTR [edi]
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ObReferenceObjectByHandle@24
  000b2	8b d8		 mov	 ebx, eax

; 2324 : 
; 2325 : 	if (!NT_SUCCESS (ntStatus))

  000b4	3b de		 cmp	 ebx, esi
  000b6	7d 08		 jge	 SHORT $LN1@TCOpenFsVo

; 2326 : 		ZwClose (*volumeHandle);

  000b8	ff 37		 push	 DWORD PTR [edi]
  000ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4
$LN1@TCOpenFsVo:

; 2327 : 
; 2328 : 	return ntStatus;

  000c0	8b c3		 mov	 eax, ebx
$LN3@TCOpenFsVo:

; 2329 : }

  000c2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c5	5f		 pop	 edi
  000c6	5e		 pop	 esi
  000c7	33 cd		 xor	 ecx, ebp
  000c9	5b		 pop	 ebx
  000ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cf	c9		 leave
  000d0	c2 0c 00	 ret	 12			; 0000000cH
_TCOpenFsVolume@12 ENDP
_TEXT	ENDS
PUBLIC	_TCCloseFsVolume@8
; Function compile flags: /Ogsp
;	COMDAT _TCCloseFsVolume@8
_TEXT	SEGMENT
_volumeHandle$ = 8					; size = 4
_fileObject$ = 12					; size = 4
_TCCloseFsVolume@8 PROC					; COMDAT

; 2333 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 2334 : 	ObDereferenceObject (fileObject);

  00005	8b 4d 0c	 mov	 ecx, DWORD PTR _fileObject$[ebp]
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 2335 : 	ZwClose (volumeHandle);

  0000e	ff 75 08	 push	 DWORD PTR _volumeHandle$[ebp]
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 2336 : }

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
_TCCloseFsVolume@8 ENDP
_TEXT	ENDS
EXTRN	__imp__IoBuildSynchronousFsdRequest@28:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCReadWriteDevice@24
_TEXT	SEGMENT
_completionEvent$ = -24					; size = 16
_ioStatusBlock$ = -8					; size = 8
_write$ = 8						; size = 4
_buffer$ = 12						; size = 4
_offset$ = 16						; size = 8
_length$ = 24						; size = 4
_TCReadWriteDevice@24 PROC				; COMDAT
; _deviceObject$ = ebx

; 2340 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 18	 sub	 esp, 24			; 00000018H
  00008	56		 push	 esi
  00009	57		 push	 edi

; 2341 : 	NTSTATUS status;
; 2342 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2343 : 	PIRP irp;
; 2344 : 	KEVENT completionEvent;
; 2345 : 
; 2346 : 	ASSERT (KeGetCurrentIrql() <= APC_LEVEL);
; 2347 : 
; 2348 : 	KeInitializeEvent (&completionEvent, NotificationEvent, FALSE);

  0000a	33 f6		 xor	 esi, esi
  0000c	56		 push	 esi
  0000d	56		 push	 esi
  0000e	8d 45 e8	 lea	 eax, DWORD PTR _completionEvent$[ebp]
  00011	50		 push	 eax
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 2349 : 	irp = IoBuildSynchronousFsdRequest (write ? IRP_MJ_WRITE : IRP_MJ_READ, deviceObject, buffer, length, &offset, &completionEvent, &ioStatusBlock);

  00018	8d 45 f8	 lea	 eax, DWORD PTR _ioStatusBlock$[ebp]
  0001b	50		 push	 eax
  0001c	8d 45 e8	 lea	 eax, DWORD PTR _completionEvent$[ebp]
  0001f	50		 push	 eax
  00020	8d 45 10	 lea	 eax, DWORD PTR _offset$[ebp]
  00023	50		 push	 eax
  00024	ff 75 18	 push	 DWORD PTR _length$[ebp]
  00027	33 c0		 xor	 eax, eax
  00029	39 75 08	 cmp	 DWORD PTR _write$[ebp], esi
  0002c	ff 75 0c	 push	 DWORD PTR _buffer$[ebp]
  0002f	0f 95 c0	 setne	 al
  00032	53		 push	 ebx
  00033	83 c0 03	 add	 eax, 3
  00036	50		 push	 eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildSynchronousFsdRequest@28
  0003d	8b f8		 mov	 edi, eax

; 2350 : 	if (!irp)

  0003f	3b fe		 cmp	 edi, esi
  00041	75 07		 jne	 SHORT $LN3@TCReadWrit

; 2351 : 		return STATUS_INSUFFICIENT_RESOURCES;

  00043	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  00048	eb 3d		 jmp	 SHORT $LN4@TCReadWrit
$LN3@TCReadWrit:

; 2352 : 
; 2353 : 	ObReferenceObject (deviceObject);

  0004a	8b cb		 mov	 ecx, ebx
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfReferenceObject@4

; 2354 : 	status = IoCallDriver (deviceObject, irp);

  00052	8b d7		 mov	 edx, edi
  00054	8b cb		 mov	 ecx, ebx
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8
  0005c	8b f8		 mov	 edi, eax

; 2355 : 
; 2356 : 	if (status == STATUS_PENDING)

  0005e	81 ff 03 01 00
	00		 cmp	 edi, 259		; 00000103H
  00064	75 17		 jne	 SHORT $LN1@TCReadWrit

; 2357 : 	{
; 2358 : 		status = KeWaitForSingleObject (&completionEvent, Executive, KernelMode, FALSE, NULL);

  00066	56		 push	 esi
  00067	56		 push	 esi
  00068	56		 push	 esi
  00069	56		 push	 esi
  0006a	8d 45 e8	 lea	 eax, DWORD PTR _completionEvent$[ebp]
  0006d	50		 push	 eax
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
  00074	8b f8		 mov	 edi, eax

; 2359 : 		if (NT_SUCCESS (status))

  00076	3b fe		 cmp	 edi, esi
  00078	7c 03		 jl	 SHORT $LN1@TCReadWrit

; 2360 : 			status = ioStatusBlock.Status;

  0007a	8b 7d f8	 mov	 edi, DWORD PTR _ioStatusBlock$[ebp]
$LN1@TCReadWrit:

; 2361 : 	}
; 2362 : 
; 2363 : 	ObDereferenceObject (deviceObject);

  0007d	8b cb		 mov	 ecx, ebx
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 2364 : 	return status;

  00085	8b c7		 mov	 eax, edi
$LN4@TCReadWrit:
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi

; 2365 : }

  00089	c9		 leave
  0008a	c2 14 00	 ret	 20			; 00000014H
_TCReadWriteDevice@24 ENDP
_TEXT	ENDS
PUBLIC	_TCReadDevice@20
; Function compile flags: /Ogsp
;	COMDAT _TCReadDevice@20
_TEXT	SEGMENT
_deviceObject$ = 8					; size = 4
_buffer$ = 12						; size = 4
_offset$ = 16						; size = 8
_length$ = 24						; size = 4
_TCReadDevice@20 PROC					; COMDAT

; 2369 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	53		 push	 ebx

; 2370 : 	return TCReadWriteDevice (FALSE, deviceObject, buffer, offset, length);

  00006	ff 75 18	 push	 DWORD PTR _length$[ebp]
  00009	8b 5d 08	 mov	 ebx, DWORD PTR _deviceObject$[ebp]
  0000c	ff 75 14	 push	 DWORD PTR _offset$[ebp+4]
  0000f	ff 75 10	 push	 DWORD PTR _offset$[ebp]
  00012	ff 75 0c	 push	 DWORD PTR _buffer$[ebp]
  00015	6a 00		 push	 0
  00017	e8 00 00 00 00	 call	 _TCReadWriteDevice@24
  0001c	5b		 pop	 ebx

; 2371 : }

  0001d	5d		 pop	 ebp
  0001e	c2 14 00	 ret	 20			; 00000014H
_TCReadDevice@20 ENDP
_TEXT	ENDS
PUBLIC	_TCWriteDevice@20
; Function compile flags: /Ogsp
;	COMDAT _TCWriteDevice@20
_TEXT	SEGMENT
_deviceObject$ = 8					; size = 4
_buffer$ = 12						; size = 4
_offset$ = 16						; size = 8
_length$ = 24						; size = 4
_TCWriteDevice@20 PROC					; COMDAT

; 2375 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	53		 push	 ebx

; 2376 : 	return TCReadWriteDevice (TRUE, deviceObject, buffer, offset, length);

  00006	ff 75 18	 push	 DWORD PTR _length$[ebp]
  00009	8b 5d 08	 mov	 ebx, DWORD PTR _deviceObject$[ebp]
  0000c	ff 75 14	 push	 DWORD PTR _offset$[ebp+4]
  0000f	ff 75 10	 push	 DWORD PTR _offset$[ebp]
  00012	ff 75 0c	 push	 DWORD PTR _buffer$[ebp]
  00015	6a 01		 push	 1
  00017	e8 00 00 00 00	 call	 _TCReadWriteDevice@24
  0001c	5b		 pop	 ebx

; 2377 : }

  0001d	5d		 pop	 ebp
  0001e	c2 14 00	 ret	 20			; 00000014H
_TCWriteDevice@20 ENDP
_TEXT	ENDS
PUBLIC	_TCFsctlCall@24
EXTRN	__imp__IoGetRelatedDeviceObject@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCFsctlCall@24
_TEXT	SEGMENT
_event$ = -24						; size = 16
_ioStatusBlock$ = -8					; size = 8
_fileObject$ = 8					; size = 4
_IoControlCode$ = 12					; size = 4
_InputBuffer$ = 16					; size = 4
_InputBufferSize$ = 20					; size = 4
_OutputBuffer$ = 24					; size = 4
_OutputBufferSize$ = 28					; size = 4
_TCFsctlCall@24 PROC					; COMDAT

; 2382 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 18	 sub	 esp, 24			; 00000018H
  00008	53		 push	 ebx
  00009	56		 push	 esi

; 2383 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2384 : 	NTSTATUS ntStatus;
; 2385 : 	PIRP irp;
; 2386 : 	KEVENT event;
; 2387 : 	PIO_STACK_LOCATION stack;
; 2388 : 	PDEVICE_OBJECT deviceObject = IoGetRelatedDeviceObject (fileObject);

  0000a	8b 75 08	 mov	 esi, DWORD PTR _fileObject$[ebp]
  0000d	57		 push	 edi
  0000e	56		 push	 esi
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoGetRelatedDeviceObject@4

; 2389 : 
; 2390 : 	KeInitializeEvent(&event, NotificationEvent, FALSE);

  00015	33 db		 xor	 ebx, ebx
  00017	53		 push	 ebx
  00018	8b f8		 mov	 edi, eax
  0001a	53		 push	 ebx
  0001b	8d 45 e8	 lea	 eax, DWORD PTR _event$[ebp]
  0001e	50		 push	 eax
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 2391 : 
; 2392 : 	irp = IoBuildDeviceIoControlRequest (IoControlCode,
; 2393 : 					     deviceObject,
; 2394 : 					     InputBuffer, InputBufferSize,
; 2395 : 					     OutputBuffer, OutputBufferSize,
; 2396 : 					     FALSE,
; 2397 : 					     &event,
; 2398 : 					     &ioStatusBlock);

  00025	8d 45 f8	 lea	 eax, DWORD PTR _ioStatusBlock$[ebp]
  00028	50		 push	 eax
  00029	8d 45 e8	 lea	 eax, DWORD PTR _event$[ebp]
  0002c	50		 push	 eax
  0002d	53		 push	 ebx
  0002e	ff 75 1c	 push	 DWORD PTR _OutputBufferSize$[ebp]
  00031	ff 75 18	 push	 DWORD PTR _OutputBuffer$[ebp]
  00034	ff 75 14	 push	 DWORD PTR _InputBufferSize$[ebp]
  00037	ff 75 10	 push	 DWORD PTR _InputBuffer$[ebp]
  0003a	57		 push	 edi
  0003b	ff 75 0c	 push	 DWORD PTR _IoControlCode$[ebp]
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 2399 : 
; 2400 : 	if (irp == NULL)

  00044	3b c3		 cmp	 eax, ebx
  00046	75 07		 jne	 SHORT $LN2@TCFsctlCal

; 2401 : 		return STATUS_INSUFFICIENT_RESOURCES;

  00048	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  0004d	eb 31		 jmp	 SHORT $LN3@TCFsctlCal
$LN2@TCFsctlCal:

; 2402 : 
; 2403 : 	stack = IoGetNextIrpStackLocation(irp);

  0004f	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00052	83 e9 24	 sub	 ecx, 36			; 00000024H

; 2404 : 	
; 2405 : 	stack->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;

  00055	c6 01 0d	 mov	 BYTE PTR [ecx], 13	; 0000000dH

; 2406 : 	stack->MinorFunction = IRP_MN_USER_FS_REQUEST;

  00058	88 59 01	 mov	 BYTE PTR [ecx+1], bl

; 2407 : 	stack->FileObject = fileObject;

  0005b	89 71 18	 mov	 DWORD PTR [ecx+24], esi

; 2408 : 
; 2409 : 	ntStatus = IoCallDriver (deviceObject, irp);

  0005e	8b d0		 mov	 edx, eax
  00060	8b cf		 mov	 ecx, edi
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8

; 2410 : 	if (ntStatus == STATUS_PENDING)

  00068	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  0006d	75 11		 jne	 SHORT $LN3@TCFsctlCal

; 2411 : 	{
; 2412 : 		KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);

  0006f	53		 push	 ebx
  00070	53		 push	 ebx
  00071	53		 push	 ebx
  00072	53		 push	 ebx
  00073	8d 45 e8	 lea	 eax, DWORD PTR _event$[ebp]
  00076	50		 push	 eax
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 2413 : 		ntStatus = ioStatusBlock.Status;

  0007d	8b 45 f8	 mov	 eax, DWORD PTR _ioStatusBlock$[ebp]
$LN3@TCFsctlCal:
  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx

; 2414 : 	}
; 2415 : 
; 2416 : 	return ntStatus;
; 2417 : }

  00083	c9		 leave
  00084	c2 18 00	 ret	 24			; 00000018H
_TCFsctlCall@24 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_CreateDriveLink@4
; Function compile flags: /Ogsp
;	COMDAT _CreateDriveLink@4
_TEXT	SEGMENT
_deviceName$ = -532					; size = 8
_symLink$ = -524					; size = 8
_dev$ = -516						; size = 256
_link$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_nDosDriveNo$ = 8					; size = 4
_CreateDriveLink@4 PROC					; COMDAT

; 2421 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 14 02 00
	00		 sub	 esp, 532		; 00000214H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi

; 2422 : 	WCHAR dev[128], link[128];
; 2423 : 	UNICODE_STRING deviceName, symLink;
; 2424 : 	NTSTATUS ntStatus;
; 2425 : 
; 2426 : 	TCGetNTNameFromNumber (dev, nDosDriveNo);

  00016	ff 75 08	 push	 DWORD PTR _nDosDriveNo$[ebp]
  00019	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _dev$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _TCGetNTNameFromNumber@8

; 2427 : 	TCGetDosNameFromNumber (link, nDosDriveNo);

  00025	ff 75 08	 push	 DWORD PTR _nDosDriveNo$[ebp]
  00028	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _link$[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _TCGetDosNameFromNumber@8

; 2428 : 
; 2429 : 	RtlInitUnicodeString (&deviceName, dev);

  00034	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__RtlInitUnicodeString@8
  0003a	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _dev$[ebp]
  00040	50		 push	 eax
  00041	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _deviceName$[ebp]
  00047	50		 push	 eax
  00048	ff d6		 call	 esi

; 2430 : 	RtlInitUnicodeString (&symLink, link);

  0004a	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _link$[ebp]
  00050	50		 push	 eax
  00051	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _symLink$[ebp]
  00057	50		 push	 eax
  00058	ff d6		 call	 esi

; 2431 : 
; 2432 : 	ntStatus = IoCreateSymbolicLink (&symLink, &deviceName);

  0005a	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _deviceName$[ebp]
  00060	50		 push	 eax
  00061	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _symLink$[ebp]
  00067	50		 push	 eax
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoCreateSymbolicLink@8

; 2433 : 	Dump ("IoCreateSymbolicLink returned %X\n", ntStatus);
; 2434 : 	return ntStatus;
; 2435 : }

  0006e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00071	33 cd		 xor	 ecx, ebp
  00073	5e		 pop	 esi
  00074	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00079	c9		 leave
  0007a	c2 04 00	 ret	 4
_CreateDriveLink@4 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_RemoveDriveLink@4
; Function compile flags: /Ogsp
;	COMDAT _RemoveDriveLink@4
_TEXT	SEGMENT
_symLink$ = -524					; size = 8
_link$ = -516						; size = 512
__$ArrayPad$ = -4					; size = 4
_nDosDriveNo$ = 8					; size = 4
_RemoveDriveLink@4 PROC					; COMDAT

; 2439 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 0c 02 00
	00		 sub	 esp, 524		; 0000020cH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2440 : 	WCHAR link[256];
; 2441 : 	UNICODE_STRING symLink;
; 2442 : 	NTSTATUS ntStatus;
; 2443 : 
; 2444 : 	TCGetDosNameFromNumber (link, nDosDriveNo);

  00015	ff 75 08	 push	 DWORD PTR _nDosDriveNo$[ebp]
  00018	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _link$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 _TCGetDosNameFromNumber@8

; 2445 : 	RtlInitUnicodeString (&symLink, link);

  00024	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _link$[ebp]
  0002a	50		 push	 eax
  0002b	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _symLink$[ebp]
  00031	50		 push	 eax
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 2446 : 
; 2447 : 	ntStatus = IoDeleteSymbolicLink (&symLink);

  00038	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _symLink$[ebp]
  0003e	50		 push	 eax
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteSymbolicLink@4

; 2448 : 	Dump ("IoDeleteSymbolicLink returned %X\n", ntStatus);
; 2449 : 	return ntStatus;
; 2450 : }

  00045	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00048	33 cd		 xor	 ecx, ebp
  0004a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004f	c9		 leave
  00050	c2 04 00	 ret	 4
_RemoveDriveLink@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	__$ArrayPad$
PUBLIC	_MountManagerMount@4
;	COMDAT ??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'M', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, 'P'
	DB	00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'M', 00H, 'a', 00H
	DB	'n', 00H, 'a', 00H, 'g', 00H, 'e', 00H, 'r', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
text$s	ENDS
;	COMDAT _MountManagerMount@4
_TEXT	SEGMENT
_symName$ = -732					; size = 8
_devName$ = -724					; size = 8
_arrVolume$ = -716					; size = 512
_buf$ = -204						; size = 200
__$ArrayPad$ = -4					; size = 4
_mount$ = 8						; size = 4
_MountManagerMount@4 PROC				; COMDAT

; 2454 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec dc 02 00
	00		 sub	 esp, 732		; 000002dcH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi

; 2455 : 	NTSTATUS ntStatus; 
; 2456 : 	WCHAR arrVolume[256];
; 2457 : 	char buf[200];
; 2458 : 	PMOUNTMGR_TARGET_NAME in = (PMOUNTMGR_TARGET_NAME) buf;
; 2459 : 	PMOUNTMGR_CREATE_POINT_INPUT point = (PMOUNTMGR_CREATE_POINT_INPUT) buf;
; 2460 : 	UNICODE_STRING symName, devName;
; 2461 : 
; 2462 : 	TCGetNTNameFromNumber (arrVolume, mount->nDosDriveNo);

  00018	8b 7d 08	 mov	 edi, DWORD PTR _mount$[ebp]
  0001b	ff b7 64 02 00
	00		 push	 DWORD PTR [edi+612]
  00021	8d 85 34 fd ff
	ff		 lea	 eax, DWORD PTR _arrVolume$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _TCGetNTNameFromNumber@8

; 2463 : 	in->DeviceNameLength = (USHORT) wcslen (arrVolume) * 2;

  0002d	8d 85 34 fd ff
	ff		 lea	 eax, DWORD PTR _arrVolume$[ebp]
  00033	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
$LL5@MountManag:
  00036	66 8b 08	 mov	 cx, WORD PTR [eax]
  00039	40		 inc	 eax
  0003a	40		 inc	 eax
  0003b	66 85 c9	 test	 cx, cx
  0003e	75 f6		 jne	 SHORT $LL5@MountManag
  00040	2b c2		 sub	 eax, edx
  00042	d1 f8		 sar	 eax, 1
  00044	03 c0		 add	 eax, eax
  00046	66 89 85 34 ff
	ff ff		 mov	 WORD PTR _buf$[ebp], ax

; 2464 : 	wcscpy(in->DeviceName, arrVolume);

  0004d	33 f6		 xor	 esi, esi
  0004f	33 c0		 xor	 eax, eax
$LL3@MountManag:
  00051	0f b7 8c 05 34
	fd ff ff	 movzx	 ecx, WORD PTR _arrVolume$[ebp+eax]
  00059	66 89 8c 05 36
	ff ff ff	 mov	 WORD PTR _buf$[ebp+eax+2], cx
  00061	40		 inc	 eax
  00062	40		 inc	 eax
  00063	66 3b ce	 cmp	 cx, si
  00066	75 e9		 jne	 SHORT $LL3@MountManag

; 2465 : 
; 2466 : 	ntStatus = TCDeviceIoControl (MOUNTMGR_DEVICE_NAME, IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION,
; 2467 : 		in, (ULONG) (sizeof (in->DeviceNameLength) + wcslen (arrVolume) * 2), 0, 0);

  00068	8d 85 34 fd ff
	ff		 lea	 eax, DWORD PTR _arrVolume$[ebp]
  0006e	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
$LL6@MountManag:
  00071	66 8b 08	 mov	 cx, WORD PTR [eax]
  00074	40		 inc	 eax
  00075	40		 inc	 eax
  00076	66 3b ce	 cmp	 cx, si
  00079	75 f6		 jne	 SHORT $LL6@MountManag
  0007b	2b c2		 sub	 eax, edx
  0007d	56		 push	 esi
  0007e	d1 f8		 sar	 eax, 1
  00080	56		 push	 esi
  00081	8d 44 00 02	 lea	 eax, DWORD PTR [eax+eax+2]
  00085	50		 push	 eax
  00086	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  0008c	50		 push	 eax
  0008d	68 2c 40 6d 00	 push	 7159852			; 006d402cH
  00092	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
  00097	53		 push	 ebx
  00098	e8 00 00 00 00	 call	 _TCDeviceIoControl@24

; 2468 : 
; 2469 : 	memset (buf, 0, sizeof buf);

  0009d	68 c8 00 00 00	 push	 200			; 000000c8H
  000a2	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  000a8	56		 push	 esi
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 _memset
  000af	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2470 : 	TCGetDosNameFromNumber ((PWSTR) &point[1], mount->nDosDriveNo);

  000b2	ff b7 64 02 00
	00		 push	 DWORD PTR [edi+612]
  000b8	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp+8]
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 _TCGetDosNameFromNumber@8

; 2471 : 
; 2472 : 	point->SymbolicLinkNameOffset = sizeof (MOUNTMGR_CREATE_POINT_INPUT);

  000c4	6a 08		 push	 8
  000c6	58		 pop	 eax
  000c7	66 89 85 34 ff
	ff ff		 mov	 WORD PTR _buf$[ebp], ax

; 2473 : 	point->SymbolicLinkNameLength = (USHORT) wcslen ((PWSTR) &point[1]) * 2;

  000ce	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp+8]
  000d4	8d 48 02	 lea	 ecx, DWORD PTR [eax+2]
$LL7@MountManag:
  000d7	66 8b 10	 mov	 dx, WORD PTR [eax]
  000da	40		 inc	 eax
  000db	40		 inc	 eax
  000dc	66 3b d6	 cmp	 dx, si
  000df	75 f6		 jne	 SHORT $LL7@MountManag

; 2474 : 
; 2475 : 	RtlInitUnicodeString(&symName, (PWSTR) (buf + point->SymbolicLinkNameOffset));

  000e1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__RtlInitUnicodeString@8
  000e7	2b c1		 sub	 eax, ecx
  000e9	d1 f8		 sar	 eax, 1
  000eb	03 c0		 add	 eax, eax
  000ed	66 89 85 36 ff
	ff ff		 mov	 WORD PTR _buf$[ebp+2], ax
  000f4	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp+8]
  000fa	50		 push	 eax
  000fb	8d 85 24 fd ff
	ff		 lea	 eax, DWORD PTR _symName$[ebp]
  00101	50		 push	 eax
  00102	ff d6		 call	 esi

; 2476 : 
; 2477 : 	point->DeviceNameOffset = point->SymbolicLinkNameOffset + point->SymbolicLinkNameLength;

  00104	8b 85 36 ff ff
	ff		 mov	 eax, DWORD PTR _buf$[ebp+2]
  0010a	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _buf$[ebp]

; 2478 : 	TCGetNTNameFromNumber ((PWSTR) (buf + point->DeviceNameOffset), mount->nDosDriveNo);

  00110	ff b7 64 02 00
	00		 push	 DWORD PTR [edi+612]
  00116	03 c1		 add	 eax, ecx
  00118	66 89 85 38 ff
	ff ff		 mov	 WORD PTR _buf$[ebp+4], ax
  0011f	0f b7 c0	 movzx	 eax, ax
  00122	8d 84 05 34 ff
	ff ff		 lea	 eax, DWORD PTR _buf$[ebp+eax]
  00129	50		 push	 eax
  0012a	e8 00 00 00 00	 call	 _TCGetNTNameFromNumber@8

; 2479 : 	point->DeviceNameLength = (USHORT) wcslen ((PWSTR) (buf + point->DeviceNameOffset)) * 2;

  0012f	0f b7 8d 38 ff
	ff ff		 movzx	 ecx, WORD PTR _buf$[ebp+4]
  00136	8d 8c 0d 34 ff
	ff ff		 lea	 ecx, DWORD PTR _buf$[ebp+ecx]
  0013d	8b c1		 mov	 eax, ecx
  0013f	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
$LL8@MountManag:
  00142	66 8b 38	 mov	 di, WORD PTR [eax]
  00145	40		 inc	 eax
  00146	40		 inc	 eax
  00147	66 85 ff	 test	 di, di
  0014a	75 f6		 jne	 SHORT $LL8@MountManag
  0014c	2b c2		 sub	 eax, edx
  0014e	d1 f8		 sar	 eax, 1
  00150	03 c0		 add	 eax, eax
  00152	66 89 85 3a ff
	ff ff		 mov	 WORD PTR _buf$[ebp+6], ax

; 2480 : 
; 2481 : 	RtlInitUnicodeString(&devName, (PWSTR) (buf + point->DeviceNameOffset));

  00159	51		 push	 ecx
  0015a	8d 85 2c fd ff
	ff		 lea	 eax, DWORD PTR _devName$[ebp]
  00160	50		 push	 eax
  00161	ff d6		 call	 esi

; 2482 : 
; 2483 : 	ntStatus = TCDeviceIoControl (MOUNTMGR_DEVICE_NAME, IOCTL_MOUNTMGR_CREATE_POINT, point,
; 2484 : 		point->DeviceNameOffset + point->DeviceNameLength, 0, 0);
; 2485 : 
; 2486 : 	return ntStatus;

  00163	0f b7 85 3a ff
	ff ff		 movzx	 eax, WORD PTR _buf$[ebp+6]
  0016a	0f b7 8d 38 ff
	ff ff		 movzx	 ecx, WORD PTR _buf$[ebp+4]
  00171	6a 00		 push	 0
  00173	6a 00		 push	 0
  00175	03 c1		 add	 eax, ecx
  00177	50		 push	 eax
  00178	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  0017e	50		 push	 eax
  0017f	68 00 c0 6d 00	 push	 7192576			; 006dc000H
  00184	53		 push	 ebx
  00185	e8 00 00 00 00	 call	 _TCDeviceIoControl@24

; 2487 : }

  0018a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018d	5f		 pop	 edi
  0018e	5e		 pop	 esi
  0018f	33 cd		 xor	 ecx, ebp
  00191	5b		 pop	 ebx
  00192	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00197	c9		 leave
  00198	c2 04 00	 ret	 4
_MountManagerMount@4 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_MountManagerUnmount@4
; Function compile flags: /Ogsp
;	COMDAT _MountManagerUnmount@4
_TEXT	SEGMENT
_out$ = -560						; size = 300
_buf$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_nDosDriveNo$ = 8					; size = 4
_MountManagerUnmount@4 PROC				; COMDAT

; 2491 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 30 02 00
	00		 sub	 esp, 560		; 00000230H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2492 : 	NTSTATUS ntStatus; 
; 2493 : 	char buf[256], out[300];
; 2494 : 	PMOUNTMGR_MOUNT_POINT in = (PMOUNTMGR_MOUNT_POINT) buf;
; 2495 : 
; 2496 : 	memset (buf, 0, sizeof buf);

  00015	68 00 01 00 00	 push	 256			; 00000100H
  0001a	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  00020	6a 00		 push	 0
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 _memset
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2497 : 
; 2498 : 	TCGetDosNameFromNumber ((PWSTR) &in[1], nDosDriveNo);

  0002b	ff 75 08	 push	 DWORD PTR _nDosDriveNo$[ebp]
  0002e	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp+24]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _TCGetDosNameFromNumber@8

; 2499 : 
; 2500 : 	// Only symbolic link can be deleted with IOCTL_MOUNTMGR_DELETE_POINTS. If any other entry is specified, the mount manager will ignore subsequent IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION for the same volume ID.
; 2501 : 	in->SymbolicLinkNameOffset = sizeof (MOUNTMGR_MOUNT_POINT);

  0003a	6a 18		 push	 24			; 00000018H
  0003c	5a		 pop	 edx

; 2502 : 	in->SymbolicLinkNameLength = (USHORT) wcslen ((PWCHAR) &in[1]) * 2;

  0003d	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp+24]
  00043	89 95 fc fe ff
	ff		 mov	 DWORD PTR _buf$[ebp], edx
  00049	8d 48 02	 lea	 ecx, DWORD PTR [eax+2]
  0004c	56		 push	 esi
$LL3@MountManag@2:
  0004d	66 8b 30	 mov	 si, WORD PTR [eax]
  00050	40		 inc	 eax
  00051	40		 inc	 eax
  00052	66 85 f6	 test	 si, si
  00055	75 f6		 jne	 SHORT $LL3@MountManag@2
  00057	2b c1		 sub	 eax, ecx
  00059	d1 f8		 sar	 eax, 1
  0005b	03 c0		 add	 eax, eax
  0005d	66 89 85 00 ff
	ff ff		 mov	 WORD PTR _buf$[ebp+4], ax

; 2503 : 
; 2504 : 	ntStatus = TCDeviceIoControl (MOUNTMGR_DEVICE_NAME, IOCTL_MOUNTMGR_DELETE_POINTS,
; 2505 : 		in, sizeof(MOUNTMGR_MOUNT_POINT) + in->SymbolicLinkNameLength, out, sizeof out);

  00064	68 2c 01 00 00	 push	 300			; 0000012cH

; 2506 : 
; 2507 : 	Dump ("IOCTL_MOUNTMGR_DELETE_POINTS returned 0x%08x\n", ntStatus);
; 2508 : 
; 2509 : 	return ntStatus;

  00069	0f b7 c0	 movzx	 eax, ax
  0006c	8d 8d d0 fd ff
	ff		 lea	 ecx, DWORD PTR _out$[ebp]
  00072	51		 push	 ecx
  00073	03 c2		 add	 eax, edx
  00075	50		 push	 eax
  00076	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  0007c	50		 push	 eax
  0007d	68 04 c0 6d 00	 push	 7192580			; 006dc004H
  00082	68 00 00 00 00	 push	 OFFSET ??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
  00087	e8 00 00 00 00	 call	 _TCDeviceIoControl@24

; 2510 : }

  0008c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008f	33 cd		 xor	 ecx, ebp
  00091	5e		 pop	 esi
  00092	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00097	c9		 leave
  00098	c2 04 00	 ret	 4
_MountManagerUnmount@4 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _FindVolumeWithHighestUniqueId@4
_TEXT	SEGMENT
_maxUniqueId$ = 8					; size = 4
_FindVolumeWithHighestUniqueId@4 PROC			; COMDAT

; 2733 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi
  00006	57		 push	 edi

; 2734 : 	PDEVICE_OBJECT highestIdDevice = NULL;

  00007	33 ff		 xor	 edi, edi

; 2735 : 	int highestId = -1;

  00009	83 ca ff	 or	 edx, -1

; 2736 : 	int drive;
; 2737 : 
; 2738 : 	for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)

  0000c	33 f6		 xor	 esi, esi
$LL5@FindVolume:

; 2739 : 	{
; 2740 : 		PDEVICE_OBJECT device = GetVirtualVolumeDeviceObject (drive);

  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _GetVirtualVolumeDeviceObject@4

; 2741 : 		if (device)

  00014	85 c0		 test	 eax, eax
  00016	74 13		 je	 SHORT $LN4@FindVolume

; 2742 : 		{
; 2743 : 			PEXTENSION extension = (PEXTENSION) device->DeviceExtension;

  00018	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]

; 2744 : 			if (extension->UniqueVolumeId > highestId && extension->UniqueVolumeId <= maxUniqueId)

  0001b	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0001e	3b ca		 cmp	 ecx, edx
  00020	7e 09		 jle	 SHORT $LN4@FindVolume
  00022	3b 4d 08	 cmp	 ecx, DWORD PTR _maxUniqueId$[ebp]
  00025	7f 04		 jg	 SHORT $LN4@FindVolume

; 2745 : 			{
; 2746 : 				highestId = extension->UniqueVolumeId;

  00027	8b d1		 mov	 edx, ecx

; 2747 : 				highestIdDevice = device;

  00029	8b f8		 mov	 edi, eax
$LN4@FindVolume:
  0002b	46		 inc	 esi
  0002c	83 fe 19	 cmp	 esi, 25			; 00000019H
  0002f	7e dd		 jle	 SHORT $LL5@FindVolume

; 2748 : 			}
; 2749 : 		}
; 2750 : 	}
; 2751 : 
; 2752 : 	return highestIdDevice;

  00031	8b c7		 mov	 eax, edi
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi

; 2753 : }

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
_FindVolumeWithHighestUniqueId@4 ENDP
_TEXT	ENDS
PUBLIC	_SymbolicLinkToTarget@12
EXTRN	__imp__ZwQuerySymbolicLinkObject@12:PROC
EXTRN	__imp__ZwOpenSymbolicLinkObject@12:PROC
; Function compile flags: /Ogsp
;	COMDAT _SymbolicLinkToTarget@12
_TEXT	SEGMENT
_objectAttributes$ = -40				; size = 24
_fullFileName$ = -16					; size = 8
_target$31057 = -8					; size = 8
_handle$ = 8						; size = 4
_symlinkName$ = 8					; size = 4
_targetName$ = 12					; size = 4
_maxTargetNameLength$ = 16				; size = 2
_SymbolicLinkToTarget@12 PROC				; COMDAT

; 2793 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 28	 sub	 esp, 40			; 00000028H
  00008	56		 push	 esi
  00009	57		 push	 edi

; 2794 : 	NTSTATUS ntStatus;
; 2795 : 	OBJECT_ATTRIBUTES objectAttributes;
; 2796 : 	UNICODE_STRING fullFileName;
; 2797 : 	HANDLE handle;
; 2798 : 
; 2799 : 	RtlInitUnicodeString (&fullFileName, symlinkName);

  0000a	ff 75 08	 push	 DWORD PTR _symlinkName$[ebp]
  0000d	8d 45 f0	 lea	 eax, DWORD PTR _fullFileName$[ebp]
  00010	50		 push	 eax
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 2800 : 	InitializeObjectAttributes (&objectAttributes, &fullFileName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

  00017	8d 45 f0	 lea	 eax, DWORD PTR _fullFileName$[ebp]
  0001a	89 45 e0	 mov	 DWORD PTR _objectAttributes$[ebp+8], eax

; 2801 : 
; 2802 : 	ntStatus = ZwOpenSymbolicLinkObject (&handle, GENERIC_READ, &objectAttributes);

  0001d	8d 45 d8	 lea	 eax, DWORD PTR _objectAttributes$[ebp]
  00020	50		 push	 eax
  00021	33 f6		 xor	 esi, esi
  00023	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00028	8d 45 08	 lea	 eax, DWORD PTR _handle$[ebp]
  0002b	50		 push	 eax
  0002c	c7 45 d8 18 00
	00 00		 mov	 DWORD PTR _objectAttributes$[ebp], 24 ; 00000018H
  00033	89 75 dc	 mov	 DWORD PTR _objectAttributes$[ebp+4], esi
  00036	c7 45 e4 40 02
	00 00		 mov	 DWORD PTR _objectAttributes$[ebp+12], 576 ; 00000240H
  0003d	89 75 e8	 mov	 DWORD PTR _objectAttributes$[ebp+16], esi
  00040	89 75 ec	 mov	 DWORD PTR _objectAttributes$[ebp+20], esi
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwOpenSymbolicLinkObject@12
  00049	8b f8		 mov	 edi, eax

; 2803 : 
; 2804 : 	if (NT_SUCCESS (ntStatus))

  0004b	3b fe		 cmp	 edi, esi
  0004d	7c 3b		 jl	 SHORT $LN1@SymbolicLi

; 2805 : 	{
; 2806 : 		UNICODE_STRING target;
; 2807 : 		target.Buffer = targetName;

  0004f	8b 45 0c	 mov	 eax, DWORD PTR _targetName$[ebp]

; 2808 : 		target.Length = 0;

  00052	33 c9		 xor	 ecx, ecx
  00054	66 89 4d f8	 mov	 WORD PTR _target$31057[ebp], cx

; 2809 : 		target.MaximumLength = maxTargetNameLength;

  00058	66 8b 4d 10	 mov	 cx, WORD PTR _maxTargetNameLength$[ebp]
  0005c	66 89 4d fa	 mov	 WORD PTR _target$31057[ebp+2], cx

; 2810 : 		memset (targetName, 0, maxTargetNameLength);

  00060	0f b7 c9	 movzx	 ecx, cx
  00063	51		 push	 ecx
  00064	56		 push	 esi
  00065	50		 push	 eax
  00066	89 45 fc	 mov	 DWORD PTR _target$31057[ebp+4], eax
  00069	e8 00 00 00 00	 call	 _memset
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2811 : 
; 2812 : 		ntStatus = ZwQuerySymbolicLinkObject (handle, &target, NULL);

  00071	56		 push	 esi
  00072	8d 45 f8	 lea	 eax, DWORD PTR _target$31057[ebp]
  00075	50		 push	 eax
  00076	ff 75 08	 push	 DWORD PTR _handle$[ebp]
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwQuerySymbolicLinkObject@12

; 2813 : 
; 2814 : 		ZwClose (handle);

  0007f	ff 75 08	 push	 DWORD PTR _handle$[ebp]
  00082	8b f8		 mov	 edi, eax
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4
$LN1@SymbolicLi:

; 2815 : 	}
; 2816 : 
; 2817 : 	return ntStatus;

  0008a	8b c7		 mov	 eax, edi
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi

; 2818 : }

  0008e	c9		 leave
  0008f	c2 0c 00	 ret	 12			; 0000000cH
_SymbolicLinkToTarget@12 ENDP
_TEXT	ENDS
PUBLIC	_RegionsOverlap@32
; Function compile flags: /Ogsp
;	COMDAT _RegionsOverlap@32
_TEXT	SEGMENT
_start1$ = 8						; size = 8
_end1$ = 16						; size = 8
_start2$ = 24						; size = 8
_end2$ = 32						; size = 8
_RegionsOverlap@32 PROC					; COMDAT

; 2823 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 2824 : 	return (start1 < start2) ? (end1 >= start2) : (start1 <= end2);

  00005	8b 45 0c	 mov	 eax, DWORD PTR _start1$[ebp+4]
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _start1$[ebp]
  0000b	3b 45 1c	 cmp	 eax, DWORD PTR _start2$[ebp+4]
  0000e	77 1f		 ja	 SHORT $LN7@RegionsOve
  00010	72 05		 jb	 SHORT $LN9@RegionsOve
  00012	3b 4d 18	 cmp	 ecx, DWORD PTR _start2$[ebp]
  00015	73 18		 jae	 SHORT $LN7@RegionsOve
$LN9@RegionsOve:
  00017	8b 45 14	 mov	 eax, DWORD PTR _end1$[ebp+4]
  0001a	3b 45 1c	 cmp	 eax, DWORD PTR _start2$[ebp+4]
  0001d	72 0a		 jb	 SHORT $LN3@RegionsOve
  0001f	77 1a		 ja	 SHORT $LN11@RegionsOve
  00021	8b 45 10	 mov	 eax, DWORD PTR _end1$[ebp]
  00024	3b 45 18	 cmp	 eax, DWORD PTR _start2$[ebp]
  00027	73 12		 jae	 SHORT $LN11@RegionsOve
$LN3@RegionsOve:
  00029	33 c0		 xor	 eax, eax
$LN4@RegionsOve:

; 2825 : }

  0002b	5d		 pop	 ebp
  0002c	c2 20 00	 ret	 32			; 00000020H
$LN7@RegionsOve:

; 2824 : 	return (start1 < start2) ? (end1 >= start2) : (start1 <= end2);

  0002f	3b 45 24	 cmp	 eax, DWORD PTR _end2$[ebp+4]
  00032	77 f5		 ja	 SHORT $LN3@RegionsOve
  00034	72 05		 jb	 SHORT $LN11@RegionsOve
  00036	3b 4d 20	 cmp	 ecx, DWORD PTR _end2$[ebp]
  00039	77 ee		 ja	 SHORT $LN3@RegionsOve
$LN11@RegionsOve:
  0003b	33 c0		 xor	 eax, eax
  0003d	40		 inc	 eax
  0003e	eb eb		 jmp	 SHORT $LN4@RegionsOve
_RegionsOverlap@32 ENDP
_TEXT	ENDS
PUBLIC	_GetIntersection@36
; Function compile flags: /Ogsp
;	COMDAT _GetIntersection@36
_TEXT	SEGMENT
_start1$ = 8						; size = 8
_length1$ = 16						; size = 4
_start2$ = 20						; size = 8
tv74 = 28						; size = 8
_end2$ = 28						; size = 8
_intersectStart$ = 36					; size = 4
_intersectLength$ = 40					; size = 4
_GetIntersection@36 PROC				; COMDAT

; 2829 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 2830 : 	uint64 end1 = start1 + length1 - 1;

  00005	8b 45 10	 mov	 eax, DWORD PTR _length1$[ebp]

; 2831 : 	uint64 intersectEnd = (end1 <= end2) ? end1 : end2;

  00008	8b 55 1c	 mov	 edx, DWORD PTR _end2$[ebp]
  0000b	33 c9		 xor	 ecx, ecx
  0000d	03 45 08	 add	 eax, DWORD PTR _start1$[ebp]
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _start1$[ebp+4]
  00014	13 cb		 adc	 ecx, ebx
  00016	83 c0 ff	 add	 eax, -1
  00019	83 d1 ff	 adc	 ecx, -1
  0001c	3b 4d 20	 cmp	 ecx, DWORD PTR _end2$[ebp+4]
  0001f	77 0a		 ja	 SHORT $LN4@GetInterse
  00021	72 04		 jb	 SHORT $LN10@GetInterse
  00023	3b c2		 cmp	 eax, edx
  00025	77 04		 ja	 SHORT $LN4@GetInterse
$LN10@GetInterse:
  00027	8b d0		 mov	 edx, eax
  00029	eb 03		 jmp	 SHORT $LN5@GetInterse
$LN4@GetInterse:
  0002b	8b 4d 20	 mov	 ecx, DWORD PTR _end2$[ebp+4]
$LN5@GetInterse:
  0002e	56		 push	 esi

; 2832 : 	
; 2833 : 	*intersectStart = (start1 >= start2) ? start1 : start2;

  0002f	8b 75 14	 mov	 esi, DWORD PTR _start2$[ebp]
  00032	57		 push	 edi
  00033	8b 7d 18	 mov	 edi, DWORD PTR _start2$[ebp+4]
  00036	3b df		 cmp	 ebx, edi
  00038	72 0c		 jb	 SHORT $LN6@GetInterse
  0003a	77 05		 ja	 SHORT $LN13@GetInterse
  0003c	39 75 08	 cmp	 DWORD PTR _start1$[ebp], esi
  0003f	72 05		 jb	 SHORT $LN6@GetInterse
$LN13@GetInterse:
  00041	8b 75 08	 mov	 esi, DWORD PTR _start1$[ebp]
  00044	8b fb		 mov	 edi, ebx
$LN6@GetInterse:
  00046	8b 45 24	 mov	 eax, DWORD PTR _intersectStart$[ebp]
  00049	89 78 04	 mov	 DWORD PTR [eax+4], edi
  0004c	89 30		 mov	 DWORD PTR [eax], esi

; 2834 : 	*intersectLength = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);

  0004e	8b fe		 mov	 edi, esi
  00050	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00053	3b f1		 cmp	 esi, ecx
  00055	72 0d		 jb	 SHORT $LN8@GetInterse
  00057	77 04		 ja	 SHORT $LN12@GetInterse
  00059	3b fa		 cmp	 edi, edx
  0005b	76 07		 jbe	 SHORT $LN8@GetInterse
$LN12@GetInterse:
  0005d	33 d2		 xor	 edx, edx
  0005f	21 55 20	 and	 DWORD PTR tv74[ebp+4], edx
  00062	eb 0d		 jmp	 SHORT $LN9@GetInterse
$LN8@GetInterse:
  00064	2b d7		 sub	 edx, edi
  00066	1b ce		 sbb	 ecx, esi
  00068	83 c2 01	 add	 edx, 1
  0006b	83 d1 00	 adc	 ecx, 0
  0006e	89 4d 20	 mov	 DWORD PTR tv74[ebp+4], ecx
$LN9@GetInterse:
  00071	8b 4d 28	 mov	 ecx, DWORD PTR _intersectLength$[ebp]
  00074	5f		 pop	 edi
  00075	89 11		 mov	 DWORD PTR [ecx], edx
  00077	5e		 pop	 esi

; 2835 : 	
; 2836 : 	if (*intersectLength == 0)

  00078	85 d2		 test	 edx, edx
  0007a	75 08		 jne	 SHORT $LN1@GetInterse

; 2837 : 		*intersectStart = start1;

  0007c	8b 4d 08	 mov	 ecx, DWORD PTR _start1$[ebp]
  0007f	89 08		 mov	 DWORD PTR [eax], ecx
  00081	89 58 04	 mov	 DWORD PTR [eax+4], ebx
$LN1@GetInterse:
  00084	5b		 pop	 ebx

; 2838 : }

  00085	5d		 pop	 ebp
  00086	c2 24 00	 ret	 36			; 00000024H
_GetIntersection@36 ENDP
_TEXT	ENDS
PUBLIC	_IsAccessibleByUser@8
; Function compile flags: /Ogsp
;	COMDAT _IsAccessibleByUser@8
_TEXT	SEGMENT
_fileObjAttributes$ = -32				; size = 24
_ioStatusBlock$ = -8					; size = 8
_fileHandle$ = 8					; size = 4
_objectFileName$ = 8					; size = 4
_readOnly$ = 12						; size = 4
_IsAccessibleByUser@8 PROC				; COMDAT

; 2842 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 20	 sub	 esp, 32			; 00000020H

; 2843 : 	OBJECT_ATTRIBUTES fileObjAttributes;
; 2844 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2845 : 	HANDLE fileHandle;
; 2846 : 	NTSTATUS status;
; 2847 : 
; 2848 : 	ASSERT (!IoIsSystemThread (PsGetCurrentThread()));
; 2849 : 
; 2850 : 	InitializeObjectAttributes (&fileObjAttributes, objectFileName, OBJ_CASE_INSENSITIVE | OBJ_FORCE_ACCESS_CHECK | OBJ_KERNEL_HANDLE, NULL, NULL);

  00008	8b 4d 08	 mov	 ecx, DWORD PTR _objectFileName$[ebp]
  0000b	33 c0		 xor	 eax, eax

; 2851 : 	
; 2852 : 	status = ZwCreateFile (&fileHandle,
; 2853 : 		readOnly ? GENERIC_READ : GENERIC_READ | GENERIC_WRITE,
; 2854 : 		&fileObjAttributes,
; 2855 : 		&ioStatusBlock,
; 2856 : 		NULL,
; 2857 : 		FILE_ATTRIBUTE_NORMAL,
; 2858 : 		FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
; 2859 : 		FILE_OPEN,
; 2860 : 		FILE_SYNCHRONOUS_IO_NONALERT,
; 2861 : 		NULL,
; 2862 : 		0);

  0000d	50		 push	 eax
  0000e	50		 push	 eax
  0000f	6a 20		 push	 32			; 00000020H
  00011	6a 01		 push	 1
  00013	6a 07		 push	 7
  00015	68 80 00 00 00	 push	 128			; 00000080H
  0001a	50		 push	 eax
  0001b	89 45 e4	 mov	 DWORD PTR _fileObjAttributes$[ebp+4], eax
  0001e	89 45 f0	 mov	 DWORD PTR _fileObjAttributes$[ebp+16], eax
  00021	89 45 f4	 mov	 DWORD PTR _fileObjAttributes$[ebp+20], eax
  00024	89 4d e8	 mov	 DWORD PTR _fileObjAttributes$[ebp+8], ecx
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _readOnly$[ebp]
  0002a	8d 45 f8	 lea	 eax, DWORD PTR _ioStatusBlock$[ebp]
  0002d	50		 push	 eax
  0002e	f7 d9		 neg	 ecx
  00030	8d 45 e0	 lea	 eax, DWORD PTR _fileObjAttributes$[ebp]
  00033	50		 push	 eax
  00034	1b c9		 sbb	 ecx, ecx
  00036	b8 00 00 00 c0	 mov	 eax, -1073741824	; c0000000H
  0003b	23 c8		 and	 ecx, eax
  0003d	03 c8		 add	 ecx, eax
  0003f	51		 push	 ecx
  00040	8d 45 08	 lea	 eax, DWORD PTR _fileHandle$[ebp]
  00043	50		 push	 eax
  00044	c7 45 e0 18 00
	00 00		 mov	 DWORD PTR _fileObjAttributes$[ebp], 24 ; 00000018H
  0004b	c7 45 ec 40 06
	00 00		 mov	 DWORD PTR _fileObjAttributes$[ebp+12], 1600 ; 00000640H
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwCreateFile@44

; 2863 : 
; 2864 : 	if (NT_SUCCESS (status))

  00058	85 c0		 test	 eax, eax
  0005a	7c 0e		 jl	 SHORT $LN1@IsAccessib

; 2865 : 	{
; 2866 : 		ZwClose (fileHandle);

  0005c	ff 75 08	 push	 DWORD PTR _fileHandle$[ebp]
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 2867 : 		return TRUE;

  00065	33 c0		 xor	 eax, eax
  00067	40		 inc	 eax
  00068	eb 02		 jmp	 SHORT $LN2@IsAccessib
$LN1@IsAccessib:

; 2868 : 	}
; 2869 : 
; 2870 : 	return FALSE;

  0006a	33 c0		 xor	 eax, eax
$LN2@IsAccessib:

; 2871 : }

  0006c	c9		 leave
  0006d	c2 08 00	 ret	 8
_IsAccessibleByUser@8 ENDP
_TEXT	ENDS
PUBLIC	_UserCanAccessDriveDevice@0
; Function compile flags: /Ogsp
;	COMDAT _UserCanAccessDriveDevice@0
_TEXT	SEGMENT
_name$ = -8						; size = 8
_UserCanAccessDriveDevice@0 PROC			; COMDAT

; 2875 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	51		 push	 ecx

; 2876 : 	UNICODE_STRING name;
; 2877 : 	RtlInitUnicodeString (&name, L"\\Device\\MountPointManager");

  00007	68 00 00 00 00	 push	 OFFSET ??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
  0000c	8d 45 f8	 lea	 eax, DWORD PTR _name$[ebp]
  0000f	50		 push	 eax
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 2878 : 
; 2879 : 	return IsAccessibleByUser (&name, FALSE);

  00016	6a 00		 push	 0
  00018	8d 45 f8	 lea	 eax, DWORD PTR _name$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _IsAccessibleByUser@8

; 2880 : }

  00021	c9		 leave
  00022	c3		 ret	 0
_UserCanAccessDriveDevice@0 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_IsDriveLetterAvailable@4
; Function compile flags: /Ogsp
;	COMDAT _IsDriveLetterAvailable@4
_TEXT	SEGMENT
_objectName$ = -296					; size = 8
_objectAttributes$ = -288				; size = 24
_handle$ = -264						; size = 4
_link$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_nDosDriveNo$ = 8					; size = 4
_IsDriveLetterAvailable@4 PROC				; COMDAT

; 2884 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 28 01 00
	00		 sub	 esp, 296		; 00000128H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2885 : 	OBJECT_ATTRIBUTES objectAttributes;
; 2886 : 	UNICODE_STRING objectName;
; 2887 : 	WCHAR link[128];
; 2888 : 	HANDLE handle;
; 2889 : 
; 2890 : 	TCGetDosNameFromNumber (link, nDosDriveNo);

  00015	ff 75 08	 push	 DWORD PTR _nDosDriveNo$[ebp]
  00018	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _link$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 _TCGetDosNameFromNumber@8

; 2891 : 	RtlInitUnicodeString (&objectName, link);

  00024	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _link$[ebp]
  0002a	50		 push	 eax
  0002b	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _objectName$[ebp]
  00031	50		 push	 eax
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 2892 : 	InitializeObjectAttributes (&objectAttributes, &objectName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

  00038	33 c0		 xor	 eax, eax
  0003a	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _objectAttributes$[ebp+4], eax
  00040	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _objectAttributes$[ebp+16], eax
  00046	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _objectAttributes$[ebp+20], eax

; 2893 : 
; 2894 : 	if (NT_SUCCESS (ZwOpenSymbolicLinkObject (&handle, GENERIC_READ, &objectAttributes)))

  0004c	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _objectAttributes$[ebp]
  00052	50		 push	 eax
  00053	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00058	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _handle$[ebp]
  0005e	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _objectName$[ebp]
  00064	50		 push	 eax
  00065	c7 85 e0 fe ff
	ff 18 00 00 00	 mov	 DWORD PTR _objectAttributes$[ebp], 24 ; 00000018H
  0006f	c7 85 ec fe ff
	ff 40 02 00 00	 mov	 DWORD PTR _objectAttributes$[ebp+12], 576 ; 00000240H
  00079	89 8d e8 fe ff
	ff		 mov	 DWORD PTR _objectAttributes$[ebp+8], ecx
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwOpenSymbolicLinkObject@12
  00085	85 c0		 test	 eax, eax
  00087	7c 10		 jl	 SHORT $LN1@IsDriveLet

; 2895 : 	{
; 2896 : 		ZwClose (handle);

  00089	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _handle$[ebp]
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 2897 : 		return FALSE;

  00095	33 c0		 xor	 eax, eax
  00097	eb 03		 jmp	 SHORT $LN2@IsDriveLet
$LN1@IsDriveLet:

; 2898 : 	}
; 2899 : 
; 2900 : 	return TRUE;

  00099	33 c0		 xor	 eax, eax
  0009b	40		 inc	 eax
$LN2@IsDriveLet:

; 2901 : }

  0009c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009f	33 cd		 xor	 ecx, ebp
  000a1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a6	c9		 leave
  000a7	c2 04 00	 ret	 4
_IsDriveLetterAvailable@4 ENDP
_TEXT	ENDS
PUBLIC	_TCCompleteIrp@12
EXTRN	__imp_@IofCompleteRequest@8:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCCompleteIrp@12
_TEXT	SEGMENT
_irp$ = 8						; size = 4
_status$ = 12						; size = 4
_information$ = 16					; size = 4
_TCCompleteIrp@12 PROC					; COMDAT

; 2905 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 2906 : 	irp->IoStatus.Status = status;

  00005	8b 4d 08	 mov	 ecx, DWORD PTR _irp$[ebp]

; 2907 : 	irp->IoStatus.Information = information;

  00008	8b 45 10	 mov	 eax, DWORD PTR _information$[ebp]
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR _status$[ebp]

; 2908 : 	IoCompleteRequest (irp, IO_NO_INCREMENT);

  0000f	32 d2		 xor	 dl, dl
  00011	89 71 18	 mov	 DWORD PTR [ecx+24], esi
  00014	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 2909 : 	return status;

  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi

; 2910 : }

  00020	5d		 pop	 ebp
  00021	c2 0c 00	 ret	 12			; 0000000cH
_TCCompleteIrp@12 ENDP
_TEXT	ENDS
PUBLIC	_TCCompleteDiskIrp@12
; Function compile flags: /Ogsp
;	COMDAT _TCCompleteDiskIrp@12
_TEXT	SEGMENT
_irp$ = 8						; size = 4
_status$ = 12						; size = 4
_information$ = 16					; size = 4
_TCCompleteDiskIrp@12 PROC				; COMDAT

; 2914 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 2915 : 	irp->IoStatus.Status = status;

  00005	8b 4d 08	 mov	 ecx, DWORD PTR _irp$[ebp]

; 2916 : 	irp->IoStatus.Information = information;

  00008	8b 45 10	 mov	 eax, DWORD PTR _information$[ebp]
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR _status$[ebp]

; 2917 : 	IoCompleteRequest (irp, NT_SUCCESS (status) ? IO_DISK_INCREMENT : IO_NO_INCREMENT);

  0000f	85 f6		 test	 esi, esi
  00011	0f 9d c2	 setge	 dl
  00014	89 71 18	 mov	 DWORD PTR [ecx+24], esi
  00017	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 2918 : 	return status;

  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi

; 2919 : }

  00023	5d		 pop	 ebp
  00024	c2 0c 00	 ret	 12			; 0000000cH
_TCCompleteDiskIrp@12 ENDP
_TEXT	ENDS
PUBLIC	_GetCpuCount@0
EXTRN	__imp__KeQueryActiveProcessors@0:PROC
; Function compile flags: /Ogsp
;	COMDAT _GetCpuCount@0
_TEXT	SEGMENT
_GetCpuCount@0 PROC					; COMDAT

; 2924 : 	KAFFINITY activeCpuMap = KeQueryActiveProcessors();

  00000	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeQueryActiveProcessors@0

; 2925 : 	size_t mapSize = sizeof (activeCpuMap) * 8;

  00006	6a 20		 push	 32			; 00000020H
  00008	59		 pop	 ecx

; 2926 : 	size_t cpuCount = 0;

  00009	33 d2		 xor	 edx, edx
$LL4@GetCpuCoun@2:

; 2927 : 
; 2928 : 	while (mapSize--)

  0000b	49		 dec	 ecx

; 2929 : 	{
; 2930 : 		if (activeCpuMap & 1)

  0000c	a8 01		 test	 al, 1
  0000e	74 01		 je	 SHORT $LN2@GetCpuCoun@2

; 2931 : 			++cpuCount;

  00010	42		 inc	 edx
$LN2@GetCpuCoun@2:

; 2932 : 
; 2933 : 		activeCpuMap >>= 1;

  00011	d1 e8		 shr	 eax, 1
  00013	85 c9		 test	 ecx, ecx
  00015	75 f4		 jne	 SHORT $LL4@GetCpuCoun@2

; 2934 : 	}
; 2935 : 
; 2936 : 	if (cpuCount == 0)

  00017	85 d2		 test	 edx, edx
  00019	75 04		 jne	 SHORT $LN1@GetCpuCoun@2

; 2937 : 		return 1;

  0001b	33 c0		 xor	 eax, eax
  0001d	40		 inc	 eax

; 2940 : }

  0001e	c3		 ret	 0
$LN1@GetCpuCoun@2:

; 2938 : 
; 2939 : 	return cpuCount;

  0001f	8b c2		 mov	 eax, edx

; 2940 : }

  00021	c3		 ret	 0
_GetCpuCount@0 ENDP
_TEXT	ENDS
PUBLIC	_EnsureNullTerminatedString@8
; Function compile flags: /Ogsp
;	COMDAT _EnsureNullTerminatedString@8
_TEXT	SEGMENT
_str$ = 8						; size = 4
_maxSizeInBytes$ = 12					; size = 4
_EnsureNullTerminatedString@8 PROC			; COMDAT

; 2944 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 2945 : 	ASSERT ((maxSizeInBytes & 1) == 0);
; 2946 : 	str[maxSizeInBytes / sizeof (wchar_t) - 1] = 0;

  00005	8b 45 0c	 mov	 eax, DWORD PTR _maxSizeInBytes$[ebp]
  00008	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  0000b	d1 e8		 shr	 eax, 1
  0000d	33 c9		 xor	 ecx, ecx
  0000f	66 89 4c 42 fe	 mov	 WORD PTR [edx+eax*2-2], cx

; 2947 : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
_EnsureNullTerminatedString@8 ENDP
_TEXT	ENDS
PUBLIC	_AllocateMemoryWithTimeout@12
EXTRN	__imp__KeDelayExecutionThread@12:PROC
; Function compile flags: /Ogsp
;	COMDAT _AllocateMemoryWithTimeout@12
_TEXT	SEGMENT
_waitInterval$ = -8					; size = 8
_size$ = 8						; size = 4
_retryDelay$ = 12					; size = 4
_timeout$ = 16						; size = 4
_AllocateMemoryWithTimeout@12 PROC			; COMDAT

; 2951 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	51		 push	 ecx

; 2952 : 	LARGE_INTEGER waitInterval;
; 2953 : 	waitInterval.QuadPart = retryDelay * -10000;

  00007	8b 45 0c	 mov	 eax, DWORD PTR _retryDelay$[ebp]
  0000a	69 c0 f0 d8 ff
	ff		 imul	 eax, -10000		; ffffd8f0H
  00010	56		 push	 esi

; 2954 : 
; 2955 : 	ASSERT (KeGetCurrentIrql() <= APC_LEVEL);
; 2956 : 	ASSERT (retryDelay > 0 && retryDelay <= timeout);
; 2957 : 
; 2958 : 	while (TRUE)
; 2959 : 	{
; 2960 : 		void *memory = TCalloc (size);

  00011	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__ExAllocatePoolWithTag@12
  00017	99		 cdq
  00018	57		 push	 edi
  00019	89 45 f8	 mov	 DWORD PTR _waitInterval$[ebp], eax
  0001c	89 55 fc	 mov	 DWORD PTR _waitInterval$[ebp+4], edx
  0001f	bf 54 43 4d 4d	 mov	 edi, 1296909140		; 4d4d4354H
  00024	eb 1b		 jmp	 SHORT $LN13@AllocateMe
$LL4@AllocateMe:

; 2963 : 
; 2964 : 		timeout -= retryDelay;

  00026	8b 45 10	 mov	 eax, DWORD PTR _timeout$[ebp]
  00029	2b 45 0c	 sub	 eax, DWORD PTR _retryDelay$[ebp]
  0002c	89 45 10	 mov	 DWORD PTR _timeout$[ebp], eax

; 2965 : 		if (timeout <= 0)

  0002f	85 c0		 test	 eax, eax
  00031	7e 1c		 jle	 SHORT $LN10@AllocateMe

; 2966 : 			break;
; 2967 : 
; 2968 : 		KeDelayExecutionThread (KernelMode, FALSE, &waitInterval);

  00033	8d 45 f8	 lea	 eax, DWORD PTR _waitInterval$[ebp]
  00036	50		 push	 eax
  00037	6a 00		 push	 0
  00039	6a 00		 push	 0
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeDelayExecutionThread@12
$LN13@AllocateMe:
  00041	57		 push	 edi
  00042	ff 75 08	 push	 DWORD PTR _size$[ebp]
  00045	6a 00		 push	 0
  00047	ff d6		 call	 esi
  00049	85 c0		 test	 eax, eax
  0004b	74 d9		 je	 SHORT $LL4@AllocateMe

; 2961 : 		if (memory)
; 2962 : 			return memory;

  0004d	eb 02		 jmp	 SHORT $LN5@AllocateMe
$LN10@AllocateMe:

; 2969 : 	}
; 2970 : 
; 2971 : 	return NULL;

  0004f	33 c0		 xor	 eax, eax
$LN5@AllocateMe:
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi

; 2972 : }

  00053	c9		 leave
  00054	c2 0c 00	 ret	 12			; 0000000cH
_AllocateMemoryWithTimeout@12 ENDP
_TEXT	ENDS
PUBLIC	_TCReadRegistryKey@12
EXTRN	__imp__ZwQueryValueKey@24:PROC
EXTRN	__imp__ZwOpenKey@12:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCReadRegistryKey@12
_TEXT	SEGMENT
_regObjAttribs$ = -40					; size = 24
_valName$ = -16						; size = 8
_resultSize$ = -8					; size = 4
_size$ = -4						; size = 4
_regKeyHandle$ = 8					; size = 4
_keyPath$ = 8						; size = 4
_keyValueName$ = 12					; size = 4
_keyData$ = 16						; size = 4
_TCReadRegistryKey@12 PROC				; COMDAT

; 2976 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 28	 sub	 esp, 40			; 00000028H

; 2977 : 	OBJECT_ATTRIBUTES regObjAttribs;
; 2978 : 	HANDLE regKeyHandle;
; 2979 : 	NTSTATUS status;
; 2980 : 	UNICODE_STRING valName;
; 2981 : 	ULONG size = 0;
; 2982 : 	ULONG resultSize;
; 2983 : 
; 2984 : 	InitializeObjectAttributes (&regObjAttribs, keyPath, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

  00008	8b 45 08	 mov	 eax, DWORD PTR _keyPath$[ebp]
  0000b	57		 push	 edi
  0000c	89 45 e0	 mov	 DWORD PTR _regObjAttribs$[ebp+8], eax

; 2985 : 	status = ZwOpenKey (&regKeyHandle, KEY_READ, &regObjAttribs);

  0000f	8d 45 d8	 lea	 eax, DWORD PTR _regObjAttribs$[ebp]
  00012	50		 push	 eax
  00013	33 ff		 xor	 edi, edi
  00015	68 19 00 02 00	 push	 131097			; 00020019H
  0001a	8d 45 08	 lea	 eax, DWORD PTR _regKeyHandle$[ebp]
  0001d	50		 push	 eax
  0001e	89 7d fc	 mov	 DWORD PTR _size$[ebp], edi
  00021	c7 45 d8 18 00
	00 00		 mov	 DWORD PTR _regObjAttribs$[ebp], 24 ; 00000018H
  00028	89 7d dc	 mov	 DWORD PTR _regObjAttribs$[ebp+4], edi
  0002b	c7 45 e4 40 02
	00 00		 mov	 DWORD PTR _regObjAttribs$[ebp+12], 576 ; 00000240H
  00032	89 7d e8	 mov	 DWORD PTR _regObjAttribs$[ebp+16], edi
  00035	89 7d ec	 mov	 DWORD PTR _regObjAttribs$[ebp+20], edi
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwOpenKey@12

; 2986 : 	if (!NT_SUCCESS (status))

  0003e	3b c7		 cmp	 eax, edi

; 2987 : 		return status;

  00040	7c 45		 jl	 SHORT $LN5@TCReadRegi
  00042	56		 push	 esi

; 2988 : 
; 2989 : 	RtlInitUnicodeString (&valName, keyValueName);

  00043	ff 75 0c	 push	 DWORD PTR _keyValueName$[ebp]
  00046	8d 45 f0	 lea	 eax, DWORD PTR _valName$[ebp]
  00049	50		 push	 eax
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 2990 : 	status = ZwQueryValueKey (regKeyHandle, &valName, KeyValuePartialInformation, NULL, 0, &size);

  00050	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__ZwQueryValueKey@24
  00056	8d 45 fc	 lea	 eax, DWORD PTR _size$[ebp]
  00059	50		 push	 eax
  0005a	57		 push	 edi
  0005b	57		 push	 edi
  0005c	6a 02		 push	 2
  0005e	8d 45 f0	 lea	 eax, DWORD PTR _valName$[ebp]
  00061	50		 push	 eax
  00062	ff 75 08	 push	 DWORD PTR _regKeyHandle$[ebp]
  00065	ff d6		 call	 esi

; 2991 : 		
; 2992 : 	if (!NT_SUCCESS (status) && status != STATUS_BUFFER_OVERFLOW && status != STATUS_BUFFER_TOO_SMALL)

  00067	3b c7		 cmp	 eax, edi
  00069	7d 21		 jge	 SHORT $LN3@TCReadRegi
  0006b	3d 05 00 00 80	 cmp	 eax, -2147483643	; 80000005H
  00070	74 1a		 je	 SHORT $LN3@TCReadRegi
  00072	3d 23 00 00 c0	 cmp	 eax, -1073741789	; c0000023H
  00077	74 13		 je	 SHORT $LN3@TCReadRegi
$LN9@TCReadRegi:
  00079	8b f0		 mov	 esi, eax
$LN7@TCReadRegi:

; 2993 : 	{
; 2994 : 		ZwClose (regKeyHandle);

  0007b	ff 75 08	 push	 DWORD PTR _regKeyHandle$[ebp]
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 2995 : 		return status;

  00084	8b c6		 mov	 eax, esi
  00086	5e		 pop	 esi
$LN5@TCReadRegi:
  00087	5f		 pop	 edi

; 3012 : 
; 3013 : 	ZwClose (regKeyHandle);
; 3014 : 	return status;
; 3015 : }

  00088	c9		 leave
  00089	c2 0c 00	 ret	 12			; 0000000cH
$LN3@TCReadRegi:

; 2996 : 	}
; 2997 : 
; 2998 : 	if (size == 0)

  0008c	39 7d fc	 cmp	 DWORD PTR _size$[ebp], edi
  0008f	75 07		 jne	 SHORT $LN2@TCReadRegi
  00091	be 22 00 00 80	 mov	 esi, -2147483614	; 80000022H
  00096	eb e3		 jmp	 SHORT $LN7@TCReadRegi
$LN2@TCReadRegi:

; 2999 : 	{
; 3000 : 		ZwClose (regKeyHandle);
; 3001 : 		return STATUS_NO_DATA_DETECTED;
; 3002 : 	}
; 3003 : 
; 3004 : 	*keyData = (PKEY_VALUE_PARTIAL_INFORMATION) TCalloc (size);

  00098	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0009d	ff 75 fc	 push	 DWORD PTR _size$[ebp]
  000a0	57		 push	 edi
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  000a7	8b 4d 10	 mov	 ecx, DWORD PTR _keyData$[ebp]
  000aa	89 01		 mov	 DWORD PTR [ecx], eax

; 3005 : 	if (!*keyData)

  000ac	3b c7		 cmp	 eax, edi
  000ae	75 07		 jne	 SHORT $LN1@TCReadRegi
  000b0	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH
  000b5	eb c4		 jmp	 SHORT $LN7@TCReadRegi
$LN1@TCReadRegi:

; 3006 : 	{
; 3007 : 		ZwClose (regKeyHandle);
; 3008 : 		return STATUS_INSUFFICIENT_RESOURCES;
; 3009 : 	}
; 3010 : 
; 3011 : 	status = ZwQueryValueKey (regKeyHandle, &valName, KeyValuePartialInformation, *keyData, size, &resultSize);

  000b7	8d 4d f8	 lea	 ecx, DWORD PTR _resultSize$[ebp]
  000ba	51		 push	 ecx
  000bb	ff 75 fc	 push	 DWORD PTR _size$[ebp]
  000be	50		 push	 eax
  000bf	6a 02		 push	 2
  000c1	8d 45 f0	 lea	 eax, DWORD PTR _valName$[ebp]
  000c4	50		 push	 eax
  000c5	ff 75 08	 push	 DWORD PTR _regKeyHandle$[ebp]
  000c8	ff d6		 call	 esi
  000ca	eb ad		 jmp	 SHORT $LN9@TCReadRegi
_TCReadRegistryKey@12 ENDP
_TEXT	ENDS
PUBLIC	_TCWriteRegistryKey@20
EXTRN	__imp__ZwSetValueKey@24:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCWriteRegistryKey@20
_TEXT	SEGMENT
_regObjAttribs$ = -32					; size = 24
_valName$ = -8						; size = 8
_regKeyHandle$ = 8					; size = 4
_keyPath$ = 8						; size = 4
_keyValueName$ = 12					; size = 4
_keyValueType$ = 16					; size = 4
_valueData$ = 20					; size = 4
_valueSize$ = 24					; size = 4
_TCWriteRegistryKey@20 PROC				; COMDAT

; 3019 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 20	 sub	 esp, 32			; 00000020H

; 3020 : 	OBJECT_ATTRIBUTES regObjAttribs;
; 3021 : 	HANDLE regKeyHandle;
; 3022 : 	NTSTATUS status;
; 3023 : 	UNICODE_STRING valName;
; 3024 : 
; 3025 : 	InitializeObjectAttributes (&regObjAttribs, keyPath, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

  00008	8b 45 08	 mov	 eax, DWORD PTR _keyPath$[ebp]
  0000b	56		 push	 esi
  0000c	89 45 e8	 mov	 DWORD PTR _regObjAttribs$[ebp+8], eax

; 3026 : 	status = ZwOpenKey (&regKeyHandle, KEY_READ | KEY_WRITE, &regObjAttribs);

  0000f	8d 45 e0	 lea	 eax, DWORD PTR _regObjAttribs$[ebp]
  00012	50		 push	 eax
  00013	33 f6		 xor	 esi, esi
  00015	68 1f 00 02 00	 push	 131103			; 0002001fH
  0001a	8d 45 08	 lea	 eax, DWORD PTR _regKeyHandle$[ebp]
  0001d	50		 push	 eax
  0001e	c7 45 e0 18 00
	00 00		 mov	 DWORD PTR _regObjAttribs$[ebp], 24 ; 00000018H
  00025	89 75 e4	 mov	 DWORD PTR _regObjAttribs$[ebp+4], esi
  00028	c7 45 ec 40 02
	00 00		 mov	 DWORD PTR _regObjAttribs$[ebp+12], 576 ; 00000240H
  0002f	89 75 f0	 mov	 DWORD PTR _regObjAttribs$[ebp+16], esi
  00032	89 75 f4	 mov	 DWORD PTR _regObjAttribs$[ebp+20], esi
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwOpenKey@12

; 3027 : 	if (!NT_SUCCESS (status))

  0003b	3b c6		 cmp	 eax, esi

; 3028 : 		return status;

  0003d	7c 31		 jl	 SHORT $LN2@TCWriteReg

; 3029 : 
; 3030 : 	RtlInitUnicodeString (&valName, keyValueName);

  0003f	ff 75 0c	 push	 DWORD PTR _keyValueName$[ebp]
  00042	8d 45 f8	 lea	 eax, DWORD PTR _valName$[ebp]
  00045	50		 push	 eax
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 3031 : 
; 3032 : 	status = ZwSetValueKey (regKeyHandle, &valName, 0, keyValueType, valueData, valueSize);

  0004c	ff 75 18	 push	 DWORD PTR _valueSize$[ebp]
  0004f	8d 45 f8	 lea	 eax, DWORD PTR _valName$[ebp]
  00052	ff 75 14	 push	 DWORD PTR _valueData$[ebp]
  00055	ff 75 10	 push	 DWORD PTR _keyValueType$[ebp]
  00058	56		 push	 esi
  00059	50		 push	 eax
  0005a	ff 75 08	 push	 DWORD PTR _regKeyHandle$[ebp]
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwSetValueKey@24

; 3033 : 
; 3034 : 	ZwClose (regKeyHandle);

  00063	ff 75 08	 push	 DWORD PTR _regKeyHandle$[ebp]
  00066	8b f0		 mov	 esi, eax
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 3035 : 	return status;

  0006e	8b c6		 mov	 eax, esi
$LN2@TCWriteReg:
  00070	5e		 pop	 esi

; 3036 : }

  00071	c9		 leave
  00072	c2 14 00	 ret	 20			; 00000014H
_TCWriteRegistryKey@20 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BE@OBOIPPHP@?$AAt?$AAr?$AAu?$AAe?$AAc?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BK@FNJCPENK@?$AAU?$AAp?$AAp?$AAe?$AAr?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAs?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1MA@BNNNAGDA@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_IsVolumeClassFilterRegistered@0
;	COMDAT ??_C@_1BE@OBOIPPHP@?$AAt?$AAr?$AAu?$AAe?$AAc?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BE@OBOIPPHP@?$AAt?$AAr?$AAu?$AAe?$AAc?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ DB 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 'c', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BK@FNJCPENK@?$AAU?$AAp?$AAp?$AAe?$AAr?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAs?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BK@FNJCPENK@?$AAU?$AAp?$AAp?$AAe?$AAr?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAs?$AA?$AA@FNODOBFM@ DB 'U'
	DB	00H, 'p', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'F', 00H, 'i', 00H
	DB	'l', 00H, 't', 00H, 'e', 00H, 'r', 00H, 's', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1MA@BNNNAGDA@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
text$s	SEGMENT
??_C@_1MA@BNNNAGDA@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@ DB '\'
	DB	00H, 'R', 00H, 'E', 00H, 'G', 00H, 'I', 00H, 'S', 00H, 'T', 00H
	DB	'R', 00H, 'Y', 00H, '\', 00H, 'M', 00H, 'A', 00H, 'C', 00H, 'H'
	DB	00H, 'I', 00H, 'N', 00H, 'E', 00H, '\', 00H, 'S', 00H, 'Y', 00H
	DB	'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '\', 00H, 'C', 00H, 'u'
	DB	00H, 'r', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'C', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, 'r', 00H, 'o', 00H, 'l', 00H, 'S'
	DB	00H, 'e', 00H, 't', 00H, '\', 00H, 'C', 00H, 'o', 00H, 'n', 00H
	DB	't', 00H, 'r', 00H, 'o', 00H, 'l', 00H, '\', 00H, 'C', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, '\', 00H, '{', 00H, '7', 00H
	DB	'1', 00H, 'A', 00H, '2', 00H, '7', 00H, 'C', 00H, 'D', 00H, 'D'
	DB	00H, '-', 00H, '8', 00H, '1', 00H, '2', 00H, 'A', 00H, '-', 00H
	DB	'1', 00H, '1', 00H, 'D', 00H, '0', 00H, '-', 00H, 'B', 00H, 'E'
	DB	00H, 'C', 00H, '7', 00H, '-', 00H, '0', 00H, '8', 00H, '0', 00H
	DB	'0', 00H, '2', 00H, 'B', 00H, 'E', 00H, '2', 00H, '0', 00H, '9'
	DB	00H, '2', 00H, 'F', 00H, '}', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
text$s	ENDS
;	COMDAT _IsVolumeClassFilterRegistered@0
_TEXT	SEGMENT
_name$ = -16						; size = 8
_data$ = -8						; size = 4
_registered$ = -4					; size = 4
_IsVolumeClassFilterRegistered@0 PROC			; COMDAT

; 3040 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 10	 sub	 esp, 16			; 00000010H

; 3041 : 	UNICODE_STRING name;
; 3042 : 	NTSTATUS status;
; 3043 : 	BOOL registered = FALSE;

  00008	83 65 fc 00	 and	 DWORD PTR _registered$[ebp], 0

; 3044 : 
; 3045 : 	PKEY_VALUE_PARTIAL_INFORMATION data;
; 3046 : 
; 3047 : 	/*
; 3048 : 	 * Note: Do not change the "Storage Volumes" guid (System-Defined Device Setup Classes).
; 3049 : 	 * This class includes storage volumes as defined by the system-supplied
; 3050 : 	 * logical volume manager and class drivers that create device objects to
; 3051 : 	 * represent storage volumes, such as the system disk class driver.
; 3052 : 	 * @see	http://msdn.microsoft.com/en-us/library/windows/hardware/ff553426%28v=vs.85%29.aspx
; 3053 : 	 */
; 3054 : 	RtlInitUnicodeString (&name, L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class\\{71A27CDD-812A-11D0-BEC7-08002BE2092F}");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_1MA@BNNNAGDA@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
  00011	8d 45 f0	 lea	 eax, DWORD PTR _name$[ebp]
  00014	50		 push	 eax
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 3055 : 	status = TCReadRegistryKey (&name, L"UpperFilters", &data);

  0001b	8d 45 f8	 lea	 eax, DWORD PTR _data$[ebp]
  0001e	50		 push	 eax
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@FNJCPENK@?$AAU?$AAp?$AAp?$AAe?$AAr?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAs?$AA?$AA@FNODOBFM@
  00024	8d 45 f0	 lea	 eax, DWORD PTR _name$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _TCReadRegistryKey@12

; 3056 : 
; 3057 : 	if (NT_SUCCESS (status))

  0002d	85 c0		 test	 eax, eax
  0002f	7c 4a		 jl	 SHORT $LN6@IsVolumeCl

; 3058 : 	{
; 3059 : 		if (data->Type == REG_MULTI_SZ && data->DataLength >= 9 * sizeof (wchar_t))

  00031	8b 55 f8	 mov	 edx, DWORD PTR _data$[ebp]
  00034	83 7a 04 07	 cmp	 DWORD PTR [edx+4], 7
  00038	75 35		 jne	 SHORT $LN2@IsVolumeCl
  0003a	83 7a 08 12	 cmp	 DWORD PTR [edx+8], 18	; 00000012H
  0003e	72 2f		 jb	 SHORT $LN2@IsVolumeCl
  00040	53		 push	 ebx
  00041	56		 push	 esi

; 3060 : 		{
; 3061 : 			// Search for the string "truecrypt"
; 3062 : 			ULONG i;
; 3063 : 			for (i = 0; i <= data->DataLength - 9 * sizeof (wchar_t); ++i)

  00042	33 c0		 xor	 eax, eax
  00044	57		 push	 edi
$LL4@IsVolumeCl:

; 3064 : 			{
; 3065 : 				if (memcmp (data->Data + i, L"truecrypt", 9 * sizeof (wchar_t)) == 0)

  00045	6a 09		 push	 9
  00047	59		 pop	 ecx
  00048	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_1BE@OBOIPPHP@?$AAt?$AAr?$AAu?$AAe?$AAc?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
  0004d	8d 74 02 0c	 lea	 esi, DWORD PTR [edx+eax+12]
  00051	33 db		 xor	 ebx, ebx
  00053	66 f3 a7	 repe cmpsw
  00056	74 0d		 je	 SHORT $LN10@IsVolumeCl
  00058	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0005b	40		 inc	 eax
  0005c	83 c1 ee	 add	 ecx, -18		; ffffffeeH
  0005f	3b c1		 cmp	 eax, ecx
  00061	76 e2		 jbe	 SHORT $LL4@IsVolumeCl
  00063	eb 07		 jmp	 SHORT $LN13@IsVolumeCl
$LN10@IsVolumeCl:

; 3066 : 				{
; 3067 : 					Dump ("Volume class filter active\n");
; 3068 : 					registered = TRUE;

  00065	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _registered$[ebp], 1
$LN13@IsVolumeCl:
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
$LN2@IsVolumeCl:

; 3069 : 					break;
; 3070 : 				}
; 3071 : 			}
; 3072 : 		}
; 3073 : 
; 3074 : 		TCfree (data);

  0006f	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00074	52		 push	 edx
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN6@IsVolumeCl:

; 3075 : 	}
; 3076 : 
; 3077 : 	return registered;

  0007b	8b 45 fc	 mov	 eax, DWORD PTR _registered$[ebp]

; 3078 : }

  0007e	c9		 leave
  0007f	c3		 ret	 0
_IsVolumeClassFilterRegistered@0 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EA@CEOJFLPD@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAE?$AAn?$AAc?$AAr?$AAy?$AAp?$AAt?$AAi?$AAo?$AAn?$AAF?$AAr?$AAe?$AAe?$AAC?$AAp?$AAu?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CA@LGEHFLCO@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1HM@GLBNDPGI@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_ReadRegistryConfigFlags@4
EXTRN	_EnableHwEncryption@4:PROC
;	COMDAT ??_C@_1EA@CEOJFLPD@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAE?$AAn?$AAc?$AAr?$AAy?$AAp?$AAt?$AAi?$AAo?$AAn?$AAF?$AAr?$AAe?$AAe?$AAC?$AAp?$AAu?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1EA@CEOJFLPD@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAE?$AAn?$AAc?$AAr?$AAy?$AAp?$AAt?$AAi?$AAo?$AAn?$AAF?$AAr?$AAe?$AAe?$AAC?$AAp?$AAu?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, 'E', 00H, 'n', 00H, 'c', 00H, 'r', 00H, 'y'
	DB	00H, 'p', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'F', 00H
	DB	'r', 00H, 'e', 00H, 'e', 00H, 'C', 00H, 'p', 00H, 'u', 00H, 'C'
	DB	00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CA@LGEHFLCO@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CA@LGEHFLCO@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 'f', 00H, 'i'
	DB	00H, 'g', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1HM@GLBNDPGI@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
text$s	SEGMENT
??_C@_1HM@GLBNDPGI@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@ DB '\'
	DB	00H, 'R', 00H, 'E', 00H, 'G', 00H, 'I', 00H, 'S', 00H, 'T', 00H
	DB	'R', 00H, 'Y', 00H, '\', 00H, 'M', 00H, 'A', 00H, 'C', 00H, 'H'
	DB	00H, 'I', 00H, 'N', 00H, 'E', 00H, '\', 00H, 'S', 00H, 'Y', 00H
	DB	'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '\', 00H, 'C', 00H, 'u'
	DB	00H, 'r', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'C', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, 'r', 00H, 'o', 00H, 'l', 00H, 'S'
	DB	00H, 'e', 00H, 't', 00H, '\', 00H, 'S', 00H, 'e', 00H, 'r', 00H
	DB	'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 'c', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
text$s	ENDS
;	COMDAT _ReadRegistryConfigFlags@4
_TEXT	SEGMENT
_name$ = -16						; size = 8
_status$ = -8						; size = 4
_data$ = -4						; size = 4
_driverEntry$ = 8					; size = 4
_ReadRegistryConfigFlags@4 PROC				; COMDAT

; 3082 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 10	 sub	 esp, 16			; 00000010H
  00008	53		 push	 ebx
  00009	57		 push	 edi

; 3083 : 	PKEY_VALUE_PARTIAL_INFORMATION data;
; 3084 : 	UNICODE_STRING name;
; 3085 : 	NTSTATUS status;
; 3086 : 	uint32 flags = 0;
; 3087 : 
; 3088 : 	RtlInitUnicodeString (&name, L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\truecrypt");

  0000a	68 00 00 00 00	 push	 OFFSET ??_C@_1HM@GLBNDPGI@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
  0000f	8d 45 f0	 lea	 eax, DWORD PTR _name$[ebp]
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 3089 : 	status = TCReadRegistryKey (&name, TC_DRIVER_CONFIG_REG_VALUE_NAME, &data);

  00019	8d 45 fc	 lea	 eax, DWORD PTR _data$[ebp]
  0001c	50		 push	 eax
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_1CA@LGEHFLCO@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@
  00022	8d 45 f0	 lea	 eax, DWORD PTR _name$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _TCReadRegistryKey@12

; 3090 : 
; 3091 : 	if (NT_SUCCESS (status))

  0002b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__ExFreePoolWithTag@8
  00031	89 45 f8	 mov	 DWORD PTR _status$[ebp], eax
  00034	bb 54 43 4d 4d	 mov	 ebx, 1296909140		; 4d4d4354H
  00039	85 c0		 test	 eax, eax
  0003b	7c 45		 jl	 SHORT $LN8@ReadRegist
  0003d	56		 push	 esi

; 3092 : 	{
; 3093 : 		if (data->Type == REG_DWORD)

  0003e	8b 75 fc	 mov	 esi, DWORD PTR _data$[ebp]
  00041	83 7e 04 04	 cmp	 DWORD PTR [esi+4], 4
  00045	75 2f		 jne	 SHORT $LN7@ReadRegist

; 3094 : 		{
; 3095 : 			flags = *(uint32 *) data->Data;

  00047	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]

; 3096 : 			Dump ("Configuration flags = 0x%x\n", flags);
; 3097 : 
; 3098 : 			if (driverEntry)

  0004a	33 c9		 xor	 ecx, ecx
  0004c	41		 inc	 ecx
  0004d	83 7d 08 00	 cmp	 DWORD PTR _driverEntry$[ebp], 0
  00051	74 14		 je	 SHORT $LN4@ReadRegist

; 3099 : 			{
; 3100 : 				if (flags & (TC_DRIVER_CONFIG_CACHE_BOOT_PASSWORD | TC_DRIVER_CONFIG_CACHE_BOOT_PASSWORD_FOR_SYS_FAVORITES))

  00053	a8 03		 test	 al, 3
  00055	74 06		 je	 SHORT $LN5@ReadRegist

; 3101 : 					CacheBootPassword = TRUE;

  00057	89 0d 00 00 00
	00		 mov	 DWORD PTR _CacheBootPassword, ecx
$LN5@ReadRegist:

; 3102 : 
; 3103 : 				if (flags & TC_DRIVER_CONFIG_DISABLE_NONADMIN_SYS_FAVORITES_ACCESS)

  0005d	a8 04		 test	 al, 4
  0005f	74 06		 je	 SHORT $LN4@ReadRegist

; 3104 : 					NonAdminSystemFavoritesAccessDisabled = TRUE;

  00061	89 0d 00 00 00
	00		 mov	 DWORD PTR _NonAdminSystemFavoritesAccessDisabled, ecx
$LN4@ReadRegist:

; 3105 : 			}
; 3106 : 
; 3107 : 			EnableHwEncryption ((flags & TC_DRIVER_CONFIG_DISABLE_HARDWARE_ENCRYPTION) ? FALSE : TRUE);

  00067	c1 e8 03	 shr	 eax, 3
  0006a	f7 d0		 not	 eax
  0006c	23 c1		 and	 eax, ecx
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _EnableHwEncryption@4

; 3108 : 		}
; 3109 : 		else

  00074	eb 07		 jmp	 SHORT $LN3@ReadRegist
$LN7@ReadRegist:

; 3110 : 			status = STATUS_INVALID_PARAMETER;

  00076	c7 45 f8 0d 00
	00 c0		 mov	 DWORD PTR _status$[ebp], -1073741811 ; c000000dH
$LN3@ReadRegist:

; 3111 : 
; 3112 : 		TCfree (data);

  0007d	53		 push	 ebx
  0007e	56		 push	 esi
  0007f	ff d7		 call	 edi
  00081	5e		 pop	 esi
$LN8@ReadRegist:

; 3113 : 	}
; 3114 : 
; 3115 : 	if (driverEntry && NT_SUCCESS (TCReadRegistryKey (&name, TC_ENCRYPTION_FREE_CPU_COUNT_REG_VALUE_NAME, &data)))

  00082	83 7d 08 00	 cmp	 DWORD PTR _driverEntry$[ebp], 0
  00086	74 2c		 je	 SHORT $LN11@ReadRegist
  00088	8d 45 fc	 lea	 eax, DWORD PTR _data$[ebp]
  0008b	50		 push	 eax
  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_1EA@CEOJFLPD@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAE?$AAn?$AAc?$AAr?$AAy?$AAp?$AAt?$AAi?$AAo?$AAn?$AAF?$AAr?$AAe?$AAe?$AAC?$AAp?$AAu?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@FNODOBFM@
  00091	8d 45 f0	 lea	 eax, DWORD PTR _name$[ebp]
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 _TCReadRegistryKey@12
  0009a	85 c0		 test	 eax, eax
  0009c	7c 16		 jl	 SHORT $LN11@ReadRegist

; 3116 : 	{
; 3117 : 		if (data->Type == REG_DWORD)

  0009e	8b 45 fc	 mov	 eax, DWORD PTR _data$[ebp]
  000a1	83 78 04 04	 cmp	 DWORD PTR [eax+4], 4
  000a5	75 09		 jne	 SHORT $LN1@ReadRegist

; 3118 : 			EncryptionThreadPoolFreeCpuCountLimit = *(uint32 *) data->Data;

  000a7	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000aa	89 0d 00 00 00
	00		 mov	 DWORD PTR _EncryptionThreadPoolFreeCpuCountLimit, ecx
$LN1@ReadRegist:

; 3119 : 
; 3120 : 		TCfree (data);

  000b0	53		 push	 ebx
  000b1	50		 push	 eax
  000b2	ff d7		 call	 edi
$LN11@ReadRegist:

; 3121 : 	}
; 3122 : 
; 3123 : 	return status;

  000b4	8b 45 f8	 mov	 eax, DWORD PTR _status$[ebp]
  000b7	5f		 pop	 edi
  000b8	5b		 pop	 ebx

; 3124 : }

  000b9	c9		 leave
  000ba	c2 04 00	 ret	 4
_ReadRegistryConfigFlags@4 ENDP
_TEXT	ENDS
PUBLIC	_WriteRegistryConfigFlags@4
; Function compile flags: /Ogsp
;	COMDAT _WriteRegistryConfigFlags@4
_TEXT	SEGMENT
_name$ = -8						; size = 8
_flags$ = 8						; size = 4
_WriteRegistryConfigFlags@4 PROC			; COMDAT

; 3128 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	51		 push	 ecx

; 3129 : 	UNICODE_STRING name;
; 3130 : 	RtlInitUnicodeString (&name, L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\truecrypt");

  00007	68 00 00 00 00	 push	 OFFSET ??_C@_1HM@GLBNDPGI@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
  0000c	8d 45 f8	 lea	 eax, DWORD PTR _name$[ebp]
  0000f	50		 push	 eax
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 3131 : 
; 3132 : 	return TCWriteRegistryKey (&name, TC_DRIVER_CONFIG_REG_VALUE_NAME, REG_DWORD, &flags, sizeof (flags));

  00016	6a 04		 push	 4
  00018	8d 45 08	 lea	 eax, DWORD PTR _flags$[ebp]
  0001b	50		 push	 eax
  0001c	6a 04		 push	 4
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_1CA@LGEHFLCO@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@
  00023	8d 45 f8	 lea	 eax, DWORD PTR _name$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 _TCWriteRegistryKey@20

; 3133 : }

  0002c	c9		 leave
  0002d	c2 04 00	 ret	 4
_WriteRegistryConfigFlags@4 ENDP
_TEXT	ENDS
PUBLIC	_GetDeviceSectorSize@8
; Function compile flags: /Ogsp
;	COMDAT _GetDeviceSectorSize@8
_TEXT	SEGMENT
_geometry$ = -24					; size = 24
_deviceObject$ = 8					; size = 4
_bytesPerSector$ = 12					; size = 4
_GetDeviceSectorSize@8 PROC				; COMDAT

; 3137 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 18	 sub	 esp, 24			; 00000018H

; 3138 : 	NTSTATUS status;
; 3139 : 	DISK_GEOMETRY geometry;
; 3140 : 
; 3141 : 	status = SendDeviceIoControlRequest (deviceObject, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &geometry, sizeof (geometry));

  00008	6a 18		 push	 24			; 00000018H
  0000a	8d 45 e8	 lea	 eax, DWORD PTR _geometry$[ebp]
  0000d	50		 push	 eax
  0000e	6a 00		 push	 0
  00010	6a 00		 push	 0
  00012	68 00 00 07 00	 push	 458752			; 00070000H
  00017	ff 75 08	 push	 DWORD PTR _deviceObject$[ebp]
  0001a	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24

; 3142 : 
; 3143 : 	if (!NT_SUCCESS (status))

  0001f	85 c0		 test	 eax, eax

; 3144 : 		return status;

  00021	7c 0a		 jl	 SHORT $LN2@GetDeviceS

; 3145 : 
; 3146 : 	*bytesPerSector = geometry.BytesPerSector;

  00023	8b 45 0c	 mov	 eax, DWORD PTR _bytesPerSector$[ebp]
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _geometry$[ebp+20]
  00029	89 08		 mov	 DWORD PTR [eax], ecx

; 3147 : 	return STATUS_SUCCESS;

  0002b	33 c0		 xor	 eax, eax
$LN2@GetDeviceS:

; 3148 : }

  0002d	c9		 leave
  0002e	c2 08 00	 ret	 8
_GetDeviceSectorSize@8 ENDP
_TEXT	ENDS
PUBLIC	_ZeroUnreadableSectors@20
; Function compile flags: /Ogsp
;	COMDAT _ZeroUnreadableSectors@20
_TEXT	SEGMENT
_status$ = -4						; size = 4
_deviceObject$ = 8					; size = 4
_startOffset$ = 12					; size = 8
_sectorCount$ = 20					; size = 4
_size$ = 20						; size = 4
_sectorSize$ = 24					; size = 4
_sectorBuffer$ = 24					; size = 4
_zeroedSectorCount$ = 24				; size = 4
_ZeroUnreadableSectors@20 PROC				; COMDAT

; 3152 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 3153 : 	NTSTATUS status;
; 3154 : 	ULONG sectorSize;
; 3155 : 	ULONG sectorCount;
; 3156 : 	byte *sectorBuffer = NULL;
; 3157 : 
; 3158 : 	*zeroedSectorCount = 0;

  00008	8b 75 18	 mov	 esi, DWORD PTR _zeroedSectorCount$[ebp]

; 3159 : 
; 3160 : 	status = GetDeviceSectorSize (deviceObject, &sectorSize);

  0000b	8d 45 18	 lea	 eax, DWORD PTR _sectorSize$[ebp]
  0000e	50		 push	 eax
  0000f	ff 75 08	 push	 DWORD PTR _deviceObject$[ebp]
  00012	33 db		 xor	 ebx, ebx
  00014	89 1e		 mov	 DWORD PTR [esi], ebx
  00016	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  00019	e8 00 00 00 00	 call	 _GetDeviceSectorSize@8

; 3161 : 	if (!NT_SUCCESS (status))

  0001e	3b c3		 cmp	 eax, ebx

; 3162 : 		return status;

  00020	0f 8c 92 00 00
	00		 jl	 $LN9@ZeroUnread
  00026	57		 push	 edi

; 3163 : 
; 3164 : 	sectorBuffer = TCalloc (sectorSize);

  00027	8b 7d 18	 mov	 edi, DWORD PTR _sectorSize$[ebp]
  0002a	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0002f	57		 push	 edi
  00030	53		 push	 ebx
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00037	89 45 18	 mov	 DWORD PTR _sectorBuffer$[ebp], eax

; 3165 : 	if (!sectorBuffer)

  0003a	3b c3		 cmp	 eax, ebx
  0003c	75 07		 jne	 SHORT $LN7@ZeroUnread

; 3166 : 		return STATUS_INSUFFICIENT_RESOURCES;

  0003e	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  00043	eb 72		 jmp	 SHORT $LN16@ZeroUnread
$LN7@ZeroUnread:

; 3167 : 
; 3168 : 	for (sectorCount = size / sectorSize; sectorCount > 0; --sectorCount, startOffset.QuadPart += sectorSize)

  00045	8b 45 14	 mov	 eax, DWORD PTR _size$[ebp]
  00048	33 d2		 xor	 edx, edx
  0004a	f7 f7		 div	 edi
  0004c	89 45 14	 mov	 DWORD PTR _sectorCount$[ebp], eax
  0004f	3b c3		 cmp	 eax, ebx
  00051	76 50		 jbe	 SHORT $LN4@ZeroUnread
$LL14@ZeroUnread:

; 3169 : 	{
; 3170 : 		status = TCReadDevice (deviceObject, sectorBuffer, startOffset, sectorSize);

  00053	57		 push	 edi
  00054	ff 75 10	 push	 DWORD PTR _startOffset$[ebp+4]
  00057	ff 75 0c	 push	 DWORD PTR _startOffset$[ebp]
  0005a	ff 75 18	 push	 DWORD PTR _sectorBuffer$[ebp]
  0005d	ff 75 08	 push	 DWORD PTR _deviceObject$[ebp]
  00060	e8 00 00 00 00	 call	 _TCReadDevice@20

; 3171 : 		if (!NT_SUCCESS (status))

  00065	85 c0		 test	 eax, eax
  00067	7d 2c		 jge	 SHORT $LN5@ZeroUnread

; 3172 : 		{
; 3173 : 			Dump ("Zeroing sector at %I64d\n", startOffset.QuadPart);
; 3174 : 			memset (sectorBuffer, 0, sectorSize);

  00069	57		 push	 edi
  0006a	53		 push	 ebx
  0006b	ff 75 18	 push	 DWORD PTR _sectorBuffer$[ebp]
  0006e	e8 00 00 00 00	 call	 _memset
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3175 : 
; 3176 : 			status = TCWriteDevice (deviceObject, sectorBuffer, startOffset, sectorSize);

  00076	57		 push	 edi
  00077	ff 75 10	 push	 DWORD PTR _startOffset$[ebp+4]
  0007a	ff 75 0c	 push	 DWORD PTR _startOffset$[ebp]
  0007d	ff 75 18	 push	 DWORD PTR _sectorBuffer$[ebp]
  00080	ff 75 08	 push	 DWORD PTR _deviceObject$[ebp]
  00083	e8 00 00 00 00	 call	 _TCWriteDevice@20

; 3177 : 			if (!NT_SUCCESS (status))

  00088	3b c3		 cmp	 eax, ebx
  0008a	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax
  0008d	7c 17		 jl	 SHORT $err$31304

; 3178 : 				goto err;
; 3179 : 
; 3180 : 			++(*zeroedSectorCount);

  0008f	83 06 01	 add	 DWORD PTR [esi], 1
  00092	11 5e 04	 adc	 DWORD PTR [esi+4], ebx
$LN5@ZeroUnread:
  00095	ff 4d 14	 dec	 DWORD PTR _sectorCount$[ebp]
  00098	01 7d 0c	 add	 DWORD PTR _startOffset$[ebp], edi
  0009b	11 5d 10	 adc	 DWORD PTR _startOffset$[ebp+4], ebx
  0009e	39 5d 14	 cmp	 DWORD PTR _sectorCount$[ebp], ebx
  000a1	77 b0		 ja	 SHORT $LL14@ZeroUnread
$LN4@ZeroUnread:

; 3181 : 		}
; 3182 : 	}
; 3183 : 
; 3184 : 	status = STATUS_SUCCESS;

  000a3	89 5d fc	 mov	 DWORD PTR _status$[ebp], ebx
$err$31304:

; 3185 : 
; 3186 : err:
; 3187 : 	if (sectorBuffer)
; 3188 : 		TCfree (sectorBuffer);

  000a6	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  000ab	ff 75 18	 push	 DWORD PTR _sectorBuffer$[ebp]
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 3189 : 
; 3190 : 	return status;

  000b4	8b 45 fc	 mov	 eax, DWORD PTR _status$[ebp]
$LN16@ZeroUnread:
  000b7	5f		 pop	 edi
$LN9@ZeroUnread:
  000b8	5e		 pop	 esi
  000b9	5b		 pop	 ebx

; 3191 : }

  000ba	c9		 leave
  000bb	c2 14 00	 ret	 20			; 00000014H
_ZeroUnreadableSectors@20 ENDP
_TEXT	ENDS
PUBLIC	_ReadDeviceSkipUnreadableSectors@24
; Function compile flags: /Ogsp
;	COMDAT _ReadDeviceSkipUnreadableSectors@24
_TEXT	SEGMENT
_deviceObject$ = 8					; size = 4
_buffer$ = 12						; size = 4
_startOffset$ = 16					; size = 8
_size$ = 24						; size = 4
_sectorCount$ = 28					; size = 4
_sectorSize$ = 28					; size = 4
_badSectorCount$ = 28					; size = 4
_ReadDeviceSkipUnreadableSectors@24 PROC		; COMDAT

; 3195 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	53		 push	 ebx
  00006	56		 push	 esi

; 3196 : 	NTSTATUS status;
; 3197 : 	ULONG sectorSize;
; 3198 : 	ULONG sectorCount;
; 3199 : 
; 3200 : 	*badSectorCount = 0;

  00007	8b 75 1c	 mov	 esi, DWORD PTR _badSectorCount$[ebp]

; 3201 : 
; 3202 : 	status = GetDeviceSectorSize (deviceObject, &sectorSize);

  0000a	8d 45 1c	 lea	 eax, DWORD PTR _sectorSize$[ebp]
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR _deviceObject$[ebp]
  00011	33 db		 xor	 ebx, ebx
  00013	89 1e		 mov	 DWORD PTR [esi], ebx
  00015	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  00018	e8 00 00 00 00	 call	 _GetDeviceSectorSize@8

; 3203 : 	if (!NT_SUCCESS (status))

  0001d	3b c3		 cmp	 eax, ebx

; 3204 : 		return status;

  0001f	7c 52		 jl	 SHORT $LN6@ReadDevice

; 3205 : 
; 3206 : 	for (sectorCount = size / sectorSize; sectorCount > 0; --sectorCount, startOffset.QuadPart += sectorSize, buffer += sectorSize)

  00021	8b 45 18	 mov	 eax, DWORD PTR _size$[ebp]
  00024	57		 push	 edi
  00025	8b 7d 1c	 mov	 edi, DWORD PTR _sectorSize$[ebp]
  00028	33 d2		 xor	 edx, edx
  0002a	f7 f7		 div	 edi
  0002c	89 45 1c	 mov	 DWORD PTR _sectorCount$[ebp], eax
  0002f	3b c3		 cmp	 eax, ebx
  00031	76 3d		 jbe	 SHORT $LN2@ReadDevice
$LL4@ReadDevice:

; 3207 : 	{
; 3208 : 		status = TCReadDevice (deviceObject, buffer, startOffset, sectorSize);

  00033	57		 push	 edi
  00034	ff 75 14	 push	 DWORD PTR _startOffset$[ebp+4]
  00037	ff 75 10	 push	 DWORD PTR _startOffset$[ebp]
  0003a	ff 75 0c	 push	 DWORD PTR _buffer$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR _deviceObject$[ebp]
  00040	e8 00 00 00 00	 call	 _TCReadDevice@20

; 3209 : 		if (!NT_SUCCESS (status))

  00045	85 c0		 test	 eax, eax
  00047	7d 13		 jge	 SHORT $LN3@ReadDevice

; 3210 : 		{
; 3211 : 			Dump ("Skipping bad sector at %I64d\n", startOffset.QuadPart);
; 3212 : 			memset (buffer, 0, sectorSize);

  00049	57		 push	 edi
  0004a	53		 push	 ebx
  0004b	ff 75 0c	 push	 DWORD PTR _buffer$[ebp]
  0004e	e8 00 00 00 00	 call	 _memset
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3213 : 			++(*badSectorCount);

  00056	83 06 01	 add	 DWORD PTR [esi], 1
  00059	11 5e 04	 adc	 DWORD PTR [esi+4], ebx
$LN3@ReadDevice:
  0005c	ff 4d 1c	 dec	 DWORD PTR _sectorCount$[ebp]
  0005f	01 7d 10	 add	 DWORD PTR _startOffset$[ebp], edi
  00062	6a 00		 push	 0
  00064	58		 pop	 eax
  00065	11 45 14	 adc	 DWORD PTR _startOffset$[ebp+4], eax
  00068	01 7d 0c	 add	 DWORD PTR _buffer$[ebp], edi
  0006b	39 5d 1c	 cmp	 DWORD PTR _sectorCount$[ebp], ebx
  0006e	77 c3		 ja	 SHORT $LL4@ReadDevice
$LN2@ReadDevice:

; 3214 : 		}
; 3215 : 	}
; 3216 : 
; 3217 : 	return STATUS_SUCCESS;

  00070	33 c0		 xor	 eax, eax
  00072	5f		 pop	 edi
$LN6@ReadDevice:
  00073	5e		 pop	 esi
  00074	5b		 pop	 ebx

; 3218 : }

  00075	5d		 pop	 ebp
  00076	c2 18 00	 ret	 24			; 00000018H
_ReadDeviceSkipUnreadableSectors@24 ENDP
_TEXT	ENDS
PUBLIC	_IsVolumeAccessibleByCurrentUser@4
EXTRN	__imp__SeReleaseSubjectContext@4:PROC
EXTRN	__imp__RtlEqualSid@8:PROC
EXTRN	__imp__SeQueryInformationToken@12:PROC
EXTRN	__imp__SeTokenIsAdmin@4:PROC
EXTRN	__imp__SeCaptureSubjectContext@4:PROC
EXTRN	__imp__IoIsSystemThread@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _IsVolumeAccessibleByCurrentUser@4
_TEXT	SEGMENT
_subContext$ = -24					; size = 16
_tokenUser$ = -8					; size = 4
_result$ = -4						; size = 4
_volumeDeviceExtension$ = 8				; size = 4
_IsVolumeAccessibleByCurrentUser@4 PROC			; COMDAT

; 3222 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 18	 sub	 esp, 24			; 00000018H
  00008	53		 push	 ebx

; 3223 : 	SECURITY_SUBJECT_CONTEXT subContext;
; 3224 : 	PACCESS_TOKEN accessToken;
; 3225 : 	PTOKEN_USER tokenUser;
; 3226 : 	BOOL result = FALSE;

  00009	33 db		 xor	 ebx, ebx
  0000b	56		 push	 esi
  0000c	89 5d fc	 mov	 DWORD PTR _result$[ebp], ebx

; 3227 : 
; 3228 : 	if (IoIsSystemThread (PsGetCurrentThread())
; 3229 : 		|| UserCanAccessDriveDevice()
; 3230 : 		|| !volumeDeviceExtension->UserSid
; 3231 : 		|| (volumeDeviceExtension->SystemFavorite && !NonAdminSystemFavoritesAccessDisabled))

  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeGetCurrentThread@0
  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoIsSystemThread@4
  0001c	84 c0		 test	 al, al
  0001e	0f 85 97 00 00
	00		 jne	 $LN4@IsVolumeAc
  00024	e8 00 00 00 00	 call	 _UserCanAccessDriveDevice@0
  00029	85 c0		 test	 eax, eax
  0002b	0f 85 8a 00 00
	00		 jne	 $LN4@IsVolumeAc
  00031	8b 75 08	 mov	 esi, DWORD PTR _volumeDeviceExtension$[ebp]
  00034	39 9e 8c 04 00
	00		 cmp	 DWORD PTR [esi+1164], ebx
  0003a	74 7f		 je	 SHORT $LN4@IsVolumeAc
  0003c	39 9e 5c 02 00
	00		 cmp	 DWORD PTR [esi+604], ebx
  00042	74 08		 je	 SHORT $LN5@IsVolumeAc
  00044	39 1d 00 00 00
	00		 cmp	 DWORD PTR _NonAdminSystemFavoritesAccessDisabled, ebx
  0004a	74 6f		 je	 SHORT $LN4@IsVolumeAc
$LN5@IsVolumeAc:
  0004c	57		 push	 edi

; 3234 : 	}
; 3235 : 
; 3236 : 	SeCaptureSubjectContext (&subContext);

  0004d	8d 45 e8	 lea	 eax, DWORD PTR _subContext$[ebp]
  00050	50		 push	 eax
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeCaptureSubjectContext@4

; 3237 : 	accessToken = SeQuerySubjectContextToken (&subContext);

  00057	8b 7d e8	 mov	 edi, DWORD PTR _subContext$[ebp]
  0005a	3b fb		 cmp	 edi, ebx
  0005c	75 07		 jne	 SHORT $LN14@IsVolumeAc
  0005e	8b 7d f0	 mov	 edi, DWORD PTR _subContext$[ebp+8]

; 3238 : 
; 3239 : 	if (!accessToken)

  00061	3b fb		 cmp	 edi, ebx
  00063	74 46		 je	 SHORT $ret$31346
$LN14@IsVolumeAc:

; 3240 : 		goto ret;
; 3241 : 	
; 3242 : 	if (SeTokenIsAdmin (accessToken))

  00065	57		 push	 edi
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeTokenIsAdmin@4
  0006c	84 c0		 test	 al, al
  0006e	74 09		 je	 SHORT $LN2@IsVolumeAc

; 3243 : 	{
; 3244 : 		result = TRUE;

  00070	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _result$[ebp], 1

; 3245 : 		goto ret;

  00077	eb 32		 jmp	 SHORT $ret$31346
$LN2@IsVolumeAc:

; 3246 : 	}
; 3247 : 
; 3248 : 	if (!NT_SUCCESS (SeQueryInformationToken (accessToken, TokenUser, &tokenUser)))

  00079	8d 45 f8	 lea	 eax, DWORD PTR _tokenUser$[ebp]
  0007c	50		 push	 eax
  0007d	6a 01		 push	 1
  0007f	57		 push	 edi
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeQueryInformationToken@12
  00086	85 c0		 test	 eax, eax
  00088	7c 21		 jl	 SHORT $ret$31346

; 3249 : 		goto ret;
; 3250 : 
; 3251 : 	result = RtlEqualSid (volumeDeviceExtension->UserSid, tokenUser->User.Sid);

  0008a	8b 45 f8	 mov	 eax, DWORD PTR _tokenUser$[ebp]
  0008d	ff 30		 push	 DWORD PTR [eax]
  0008f	ff b6 8c 04 00
	00		 push	 DWORD PTR [esi+1164]
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEqualSid@8
  0009b	0f b6 c0	 movzx	 eax, al

; 3252 : 	ExFreePool (tokenUser);		// Documented in newer versions of WDK

  0009e	53		 push	 ebx
  0009f	ff 75 f8	 push	 DWORD PTR _tokenUser$[ebp]
  000a2	89 45 fc	 mov	 DWORD PTR _result$[ebp], eax
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$ret$31346:

; 3253 : 
; 3254 : ret:
; 3255 : 	SeReleaseSubjectContext (&subContext);

  000ab	8d 45 e8	 lea	 eax, DWORD PTR _subContext$[ebp]
  000ae	50		 push	 eax
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeReleaseSubjectContext@4

; 3256 : 	return result;

  000b5	8b 45 fc	 mov	 eax, DWORD PTR _result$[ebp]
  000b8	5f		 pop	 edi
  000b9	eb 03		 jmp	 SHORT $LN6@IsVolumeAc
$LN4@IsVolumeAc:

; 3232 : 	{
; 3233 : 		return TRUE;

  000bb	33 c0		 xor	 eax, eax
  000bd	40		 inc	 eax
$LN6@IsVolumeAc:
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx

; 3257 : }

  000c0	c9		 leave
  000c1	c2 04 00	 ret	 4
_IsVolumeAccessibleByCurrentUser@4 ENDP
_TEXT	ENDS
PUBLIC	_GetElapsedTimeInit@4
EXTRN	__imp__KeQueryPerformanceCounter@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _GetElapsedTimeInit@4
_TEXT	SEGMENT
_lastPerfCounter$ = 8					; size = 4
_GetElapsedTimeInit@4 PROC				; COMDAT

; 3261 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 3262 : 	*lastPerfCounter = KeQueryPerformanceCounter (NULL);

  00005	6a 00		 push	 0
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeQueryPerformanceCounter@4
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _lastPerfCounter$[ebp]
  00010	89 01		 mov	 DWORD PTR [ecx], eax
  00012	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 3263 : }

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
_GetElapsedTimeInit@4 ENDP
_TEXT	ENDS
PUBLIC	_GetElapsedTime@4
EXTRN	__alldiv:PROC
; Function compile flags: /Ogsp
;	COMDAT _GetElapsedTime@4
_TEXT	SEGMENT
_freq$ = -8						; size = 8
_lastPerfCounter$ = 8					; size = 4
_GetElapsedTime@4 PROC					; COMDAT

; 3268 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	51		 push	 ecx
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi

; 3269 : 	LARGE_INTEGER freq;
; 3270 : 	LARGE_INTEGER counter = KeQueryPerformanceCounter (&freq);

  0000a	8d 45 f8	 lea	 eax, DWORD PTR _freq$[ebp]
  0000d	50		 push	 eax
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeQueryPerformanceCounter@4

; 3271 : 
; 3272 : 	int64 elapsed = (counter.QuadPart - lastPerfCounter->QuadPart) * 1000000LL / freq.QuadPart;

  00014	8b 75 08	 mov	 esi, DWORD PTR _lastPerfCounter$[ebp]
  00017	8b f8		 mov	 edi, eax
  00019	2b 06		 sub	 eax, DWORD PTR [esi]
  0001b	8b da		 mov	 ebx, edx
  0001d	6a 00		 push	 0
  0001f	8b cb		 mov	 ecx, ebx
  00021	1b 4e 04	 sbb	 ecx, DWORD PTR [esi+4]
  00024	68 40 42 0f 00	 push	 1000000			; 000f4240H
  00029	51		 push	 ecx
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 __allmul
  00030	ff 75 fc	 push	 DWORD PTR _freq$[ebp+4]
  00033	ff 75 f8	 push	 DWORD PTR _freq$[ebp]
  00036	52		 push	 edx
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 __alldiv

; 3273 : 	*lastPerfCounter = counter;

  0003d	89 3e		 mov	 DWORD PTR [esi], edi
  0003f	5f		 pop	 edi
  00040	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx

; 3274 : 
; 3275 : 	return elapsed;
; 3276 : }

  00045	c9		 leave
  00046	c2 04 00	 ret	 4
_GetElapsedTime@4 ENDP
_TEXT	ENDS
PUBLIC	_IsOSAtLeast@4
; Function compile flags: /Ogsp
;	COMDAT _IsOSAtLeast@4
_TEXT	SEGMENT
_reqMinOS$ = 8						; size = 4
_IsOSAtLeast@4 PROC					; COMDAT

; 3280 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 3281 : 	/* When updating this function, update IsOSVersionAtLeast() in Dlgcode.c too. */
; 3282 : 
; 3283 : 	ULONG major = 0, minor = 0;
; 3284 : 
; 3285 : 	ASSERT (OsMajorVersion != 0);
; 3286 : 
; 3287 : 	switch (reqMinOS)

  00005	8b 45 08	 mov	 eax, DWORD PTR _reqMinOS$[ebp]
  00008	83 e8 07	 sub	 eax, 7
  0000b	74 49		 je	 SHORT $LN8@IsOSAtLeas
  0000d	48		 dec	 eax
  0000e	74 42		 je	 SHORT $LN7@IsOSAtLeas
  00010	6a 02		 push	 2
  00012	59		 pop	 ecx
  00013	2b c1		 sub	 eax, ecx
  00015	74 37		 je	 SHORT $LN6@IsOSAtLeas
  00017	48		 dec	 eax
  00018	74 30		 je	 SHORT $LN5@IsOSAtLeas
  0001a	2b c1		 sub	 eax, ecx
  0001c	74 25		 je	 SHORT $LN4@IsOSAtLeas
  0001e	2b c1		 sub	 eax, ecx
  00020	74 1d		 je	 SHORT $LN2@IsOSAtLeas
  00022	6a 04		 push	 4
  00024	59		 pop	 ecx
  00025	2b c1		 sub	 eax, ecx
  00027	74 16		 je	 SHORT $LN2@IsOSAtLeas

; 3296 : 
; 3297 : 	default:
; 3298 : 		TC_THROW_FATAL_EXCEPTION;

  00029	68 43 54 00 00	 push	 21571			; 00005443H
  0002e	6a 00		 push	 0
  00030	6a 00		 push	 0
  00032	68 e2 0c 00 00	 push	 3298			; 00000ce2H
  00037	6a 29		 push	 41			; 00000029H
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN17@IsOSAtLeas:
$LN2@IsOSAtLeas:

; 3294 : 	case WIN_8:				major = 6; minor = 2; break;
; 3295 : 	case WIN_10:			major = 6; minor = 4; break;

  0003f	6a 06		 push	 6
  00041	eb 17		 jmp	 SHORT $LN14@IsOSAtLeas
$LN4@IsOSAtLeas:

; 3293 : 	case WIN_7:				major = 6; minor = 1; break;

  00043	6a 06		 push	 6
$LN16@IsOSAtLeas:
  00045	33 c9		 xor	 ecx, ecx
  00047	41		 inc	 ecx
  00048	eb 10		 jmp	 SHORT $LN14@IsOSAtLeas
$LN5@IsOSAtLeas:

; 3292 : 	case WIN_VISTA:			major = 6; minor = 0; break;

  0004a	6a 06		 push	 6
  0004c	eb 0a		 jmp	 SHORT $LN15@IsOSAtLeas
$LN6@IsOSAtLeas:

; 3291 : 	case WIN_SERVER_2003:	major = 5; minor = 2; break;

  0004e	6a 05		 push	 5
  00050	eb 08		 jmp	 SHORT $LN14@IsOSAtLeas
$LN7@IsOSAtLeas:

; 3290 : 	case WIN_XP:			major = 5; minor = 1; break;

  00052	6a 05		 push	 5
  00054	eb ef		 jmp	 SHORT $LN16@IsOSAtLeas
$LN8@IsOSAtLeas:

; 3288 : 	{
; 3289 : 	case WIN_2000:			major = 5; minor = 0; break;

  00056	6a 05		 push	 5
$LN15@IsOSAtLeas:
  00058	33 c9		 xor	 ecx, ecx
$LN14@IsOSAtLeas:

; 3299 : 		break;
; 3300 : 	}
; 3301 : 
; 3302 : 	return ((OsMajorVersion << 16 | OsMinorVersion << 8)
; 3303 : 		>= (major << 16 | minor << 8));

  0005a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _OsMajorVersion
  00060	c1 e2 08	 shl	 edx, 8
  00063	0b 15 00 00 00
	00		 or	 edx, DWORD PTR _OsMinorVersion
  00069	58		 pop	 eax
  0006a	c1 e0 08	 shl	 eax, 8
  0006d	0b c1		 or	 eax, ecx
  0006f	b9 ff ff ff 00	 mov	 ecx, 16777215		; 00ffffffH
  00074	23 c1		 and	 eax, ecx
  00076	23 d1		 and	 edx, ecx
  00078	3b d0		 cmp	 edx, eax
  0007a	1b c0		 sbb	 eax, eax
  0007c	40		 inc	 eax

; 3304 : }

  0007d	5d		 pop	 ebp
  0007e	c2 04 00	 ret	 4
$LN13@IsOSAtLeas:
_IsOSAtLeast@4 ENDP
_TEXT	ENDS
PUBLIC	_DriverObject$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_TCCreateDeviceObject@12
EXTRN	__imp__IoInitializeRemoveLockEx@20:PROC
EXTRN	__imp__KeInitializeSemaphore@12:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCCreateDeviceObject@12
_TEXT	SEGMENT
_Win32NameString$ = -152				; size = 8
_ntUnicodeString$ = -144				; size = 8
_DriverObject$GSCopy$ = -136				; size = 4
_ntname$ = -132						; size = 64
_dosname$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_DriverObject$ = 8					; size = 4
_ppDeviceObject$ = 12					; size = 4
_mount$ = 16						; size = 4
_TCCreateDeviceObject@12 PROC				; COMDAT

; 414  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	8b 45 08	 mov	 eax, DWORD PTR _DriverObject$[ebp]
  00018	53		 push	 ebx
  00019	8b 5d 0c	 mov	 ebx, DWORD PTR _ppDeviceObject$[ebp]
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8b 7d 10	 mov	 edi, DWORD PTR _mount$[ebp]

; 415  : 	UNICODE_STRING Win32NameString, ntUnicodeString;
; 416  : 	WCHAR dosname[32], ntname[32];
; 417  : 	PEXTENSION Extension;
; 418  : 	NTSTATUS ntStatus;
; 419  : 	ULONG devChars = 0;
; 420  : 
; 421  : 	Dump ("TCCreateDeviceObject BEGIN\n");
; 422  : 	ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);
; 423  : 
; 424  : 	TCGetDosNameFromNumber (dosname, mount->nDosDriveNo);

  00021	ff b7 64 02 00
	00		 push	 DWORD PTR [edi+612]
  00027	89 85 78 ff ff
	ff		 mov	 DWORD PTR _DriverObject$GSCopy$[ebp], eax
  0002d	8d 45 bc	 lea	 eax, DWORD PTR _dosname$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 _TCGetDosNameFromNumber@8

; 425  : 	TCGetNTNameFromNumber (ntname, mount->nDosDriveNo);

  00036	ff b7 64 02 00
	00		 push	 DWORD PTR [edi+612]
  0003c	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _ntname$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 _TCGetNTNameFromNumber@8

; 426  : 	RtlInitUnicodeString (&ntUnicodeString, ntname);

  00048	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__RtlInitUnicodeString@8
  0004e	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _ntname$[ebp]
  00054	50		 push	 eax
  00055	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _ntUnicodeString$[ebp]
  0005b	50		 push	 eax
  0005c	ff d6		 call	 esi

; 427  : 	RtlInitUnicodeString (&Win32NameString, dosname);

  0005e	8d 45 bc	 lea	 eax, DWORD PTR _dosname$[ebp]
  00061	50		 push	 eax
  00062	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _Win32NameString$[ebp]
  00068	50		 push	 eax
  00069	ff d6		 call	 esi

; 428  : 
; 429  : 	devChars = FILE_DEVICE_SECURE_OPEN;
; 430  : 	devChars |= mount->bMountReadOnly ? FILE_READ_ONLY_DEVICE : 0;

  0006b	8b 87 6c 02 00
	00		 mov	 eax, DWORD PTR [edi+620]
  00071	f7 d8		 neg	 eax
  00073	1b c0		 sbb	 eax, eax
  00075	83 e0 02	 and	 eax, 2

; 431  : 	devChars |= mount->bMountRemovable ? FILE_REMOVABLE_MEDIA : 0;

  00078	33 c9		 xor	 ecx, ecx
  0007a	39 8f 70 02 00
	00		 cmp	 DWORD PTR [edi+624], ecx

; 432  : 
; 433  : 	Dump ("Creating device nt=%ls dos=%ls\n", ntname, dosname);
; 434  : 
; 435  : 	ntStatus = IoCreateDevice (
; 436  : 					  DriverObject,			/* Our Driver Object */
; 437  : 					  sizeof (EXTENSION),	/* Size of state information */
; 438  : 					  &ntUnicodeString,		/* Device name "\Device\Name" */
; 439  : 					  FILE_DEVICE_DISK,		/* Device type */
; 440  : 					  devChars,				/* Device characteristics */
; 441  : 					  FALSE,				/* Exclusive device */
; 442  : 					  ppDeviceObject);		/* Returned ptr to Device Object */

  00080	53		 push	 ebx
  00081	0f 95 c1	 setne	 cl
  00084	6a 00		 push	 0
  00086	0b c1		 or	 eax, ecx
  00088	0d 00 01 00 00	 or	 eax, 256		; 00000100H
  0008d	50		 push	 eax
  0008e	6a 07		 push	 7
  00090	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _ntUnicodeString$[ebp]
  00096	50		 push	 eax
  00097	68 d0 04 00 00	 push	 1232			; 000004d0H
  0009c	ff b5 78 ff ff
	ff		 push	 DWORD PTR _DriverObject$GSCopy$[ebp]
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoCreateDevice@28

; 443  : 
; 444  : 	if (!NT_SUCCESS (ntStatus))

  000a8	85 c0		 test	 eax, eax

; 445  : 	{
; 446  : 		Dump ("TCCreateDeviceObject NTSTATUS = 0x%08x END\n", ntStatus);
; 447  : 		return ntStatus;/* Failed to create DeviceObject */

  000aa	0f 8c a6 00 00
	00		 jl	 $LN2@TCCreateDe

; 448  : 	}
; 449  : 	/* Initialize device object and extension. */
; 450  : 
; 451  : 	(*ppDeviceObject)->Flags |= DO_DIRECT_IO;

  000b0	8b 03		 mov	 eax, DWORD PTR [ebx]
  000b2	83 48 1c 10	 or	 DWORD PTR [eax+28], 16	; 00000010H

; 452  : 	(*ppDeviceObject)->StackSize += 6;		// Reduce occurrence of NO_MORE_IRP_STACK_LOCATIONS bug check caused by buggy drivers

  000b6	8b 03		 mov	 eax, DWORD PTR [ebx]
  000b8	80 40 30 06	 add	 BYTE PTR [eax+48], 6

; 453  : 
; 454  : 	/* Setup the device extension */
; 455  : 	Extension = (PEXTENSION) (*ppDeviceObject)->DeviceExtension;

  000bc	8b 03		 mov	 eax, DWORD PTR [ebx]
  000be	8b 70 28	 mov	 esi, DWORD PTR [eax+40]

; 456  : 	memset (Extension, 0, sizeof (EXTENSION));

  000c1	68 d0 04 00 00	 push	 1232			; 000004d0H
  000c6	6a 00		 push	 0
  000c8	56		 push	 esi
  000c9	e8 00 00 00 00	 call	 _memset

; 457  : 
; 458  : 	Extension->IsVolumeDevice = TRUE;

  000ce	33 c0		 xor	 eax, eax
  000d0	40		 inc	 eax
  000d1	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 459  : 	Extension->nDosDriveNo = mount->nDosDriveNo;

  000d4	8b 8f 64 02 00
	00		 mov	 ecx, DWORD PTR [edi+612]
  000da	89 4e 14	 mov	 DWORD PTR [esi+20], ecx

; 460  : 	Extension->bRemovable = mount->bMountRemovable;

  000dd	8b 8f 70 02 00
	00		 mov	 ecx, DWORD PTR [edi+624]
  000e3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e6	89 8e 4c 02 00
	00		 mov	 DWORD PTR [esi+588], ecx

; 461  : 	Extension->PartitionInInactiveSysEncScope = mount->bPartitionInInactiveSysEncScope;

  000ec	8b 8f 80 02 00
	00		 mov	 ecx, DWORD PTR [edi+640]

; 462  : 	Extension->SystemFavorite = mount->SystemFavorite;
; 463  : 
; 464  : 	KeInitializeEvent (&Extension->keCreateEvent, SynchronizationEvent, FALSE);

  000f2	6a 00		 push	 0
  000f4	50		 push	 eax
  000f5	89 8e 50 02 00
	00		 mov	 DWORD PTR [esi+592], ecx
  000fb	8b 8f 88 02 00
	00		 mov	 ecx, DWORD PTR [edi+648]
  00101	8d 46 24	 lea	 eax, DWORD PTR [esi+36]
  00104	50		 push	 eax
  00105	89 8e 5c 02 00
	00		 mov	 DWORD PTR [esi+604], ecx
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 465  : 	KeInitializeSemaphore (&Extension->RequestSemaphore, 0L, MAXLONG);

  00111	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  00116	6a 00		 push	 0
  00118	8d 46 40	 lea	 eax, DWORD PTR [esi+64]
  0011b	50		 push	 eax
  0011c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeSemaphore@12

; 466  : 	KeInitializeSpinLock (&Extension->ListSpinLock);
; 467  : 	InitializeListHead (&Extension->ListEntry);
; 468  : 	IoInitializeRemoveLock (&Extension->Queue.RemoveLock, 'LRCT', 0, 0);

  00122	6a 18		 push	 24			; 00000018H
  00124	33 c9		 xor	 ecx, ecx
  00126	51		 push	 ecx
  00127	89 4e 34	 mov	 DWORD PTR [esi+52], ecx
  0012a	8d 46 38	 lea	 eax, DWORD PTR [esi+56]
  0012d	51		 push	 ecx
  0012e	68 54 43 52 4c	 push	 1280459604		; 4c524354H
  00133	81 c6 18 01 00
	00		 add	 esi, 280		; 00000118H
  00139	56		 push	 esi
  0013a	89 40 04	 mov	 DWORD PTR [eax+4], eax
  0013d	89 00		 mov	 DWORD PTR [eax], eax
  0013f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoInitializeRemoveLockEx@20

; 469  : 
; 470  : 	VirtualVolumeDeviceObjects[mount->nDosDriveNo] = *ppDeviceObject;

  00145	8b 87 64 02 00
	00		 mov	 eax, DWORD PTR [edi+612]
  0014b	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0014d	89 0c 85 00 00
	00 00		 mov	 DWORD PTR _VirtualVolumeDeviceObjects[eax*4], ecx

; 471  : 
; 472  : 	Dump ("TCCreateDeviceObject STATUS_SUCCESS END\n");
; 473  : 
; 474  : 	return STATUS_SUCCESS;

  00154	33 c0		 xor	 eax, eax
$LN2@TCCreateDe:

; 475  : }

  00156	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00159	5f		 pop	 edi
  0015a	5e		 pop	 esi
  0015b	33 cd		 xor	 ecx, ebp
  0015d	5b		 pop	 ebx
  0015e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00163	c9		 leave
  00164	c2 0c 00	 ret	 12			; 0000000cH
_TCCreateDeviceObject@12 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	_Extension$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_ProcessVolumeDeviceControlIrp@12
EXTRN	__imp__ZwReadFile@36:PROC
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@FNODOBFM@
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
text$s	SEGMENT
??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@FNODOBFM@ DB 'TrueCryptVolume', 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
; File c:\home\public\desktop\projects\ciphershed.build\src\driver\ntdriver.c
text$s	ENDS
;	COMDAT _ProcessVolumeDeviceControlIrp@12
_TEXT	SEGMENT
_ioStatus$30037 = -664					; size = 8
_Extension$GSCopy$ = -660				; size = 4
_offset$30043 = -656					; size = 8
_ntUnicodeString$29976 = -656				; size = 8
_ntUnicodeString$29943 = -656				; size = 8
_irpSp$ = -652						; size = 4
_buffer$30038 = -648					; size = 4
_outputBuffer$29978 = -648				; size = 4
_tmp$29961 = -648					; size = 2
_outputBuffer$29945 = -648				; size = 4
_ntName$29977 = -644					; size = 512
_ntName$29944 = -644					; size = 512
_volId$29960 = -132					; size = 128
__$ArrayPad$ = -4					; size = 4
_DeviceObject$ = 8					; size = 4
_Extension$ = 12					; size = 4
_Irp$ = 16						; size = 4
_ProcessVolumeDeviceControlIrp@12 PROC			; COMDAT

; 496  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 98 02 00
	00		 sub	 esp, 664		; 00000298H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	53		 push	 ebx
  00016	8b 5d 10	 mov	 ebx, DWORD PTR _Irp$[ebp]
  00019	56		 push	 esi

; 497  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);

  0001a	8b 73 60	 mov	 esi, DWORD PTR [ebx+96]

; 498  : 
; 499  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  0001d	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00020	57		 push	 edi
  00021	8b 7d 0c	 mov	 edi, DWORD PTR _Extension$[ebp]
  00024	b8 5c 40 07 00	 mov	 eax, 475228		; 0007405cH
  00029	89 bd 6c fd ff
	ff		 mov	 DWORD PTR _Extension$GSCopy$[ebp], edi
  0002f	89 b5 74 fd ff
	ff		 mov	 DWORD PTR _irpSp$[ebp], esi
  00035	3b c8		 cmp	 ecx, eax
  00037	0f 87 db 02 00
	00		 ja	 $LN50@ProcessVol
  0003d	0f 84 a6 02 00
	00		 je	 $LN22@ProcessVol
  00043	81 e9 00 00 07
	00		 sub	 ecx, 458752		; 00070000H
  00049	0f 84 48 02 00
	00		 je	 $LN30@ProcessVol
  0004f	83 e9 14	 sub	 ecx, 20			; 00000014H
  00052	0f 84 40 01 00
	00		 je	 $LN19@ProcessVol
  00058	83 e9 10	 sub	 ecx, 16			; 00000010H
  0005b	0f 84 20 01 00
	00		 je	 $LN10@ProcessVol
  00061	83 e9 24	 sub	 ecx, 36			; 00000024H
  00064	0f 84 ca 00 00
	00		 je	 $LN26@ProcessVol
  0006a	81 e9 b8 0b 00
	00		 sub	 ecx, 3000		; 00000bb8H
  00070	0f 84 21 02 00
	00		 je	 $LN30@ProcessVol
  00076	81 e9 04 34 00
	00		 sub	 ecx, 13316		; 00003404H
  0007c	74 66		 je	 SHORT $LN28@ProcessVol
  0007e	83 e9 08	 sub	 ecx, 8
  00081	0f 85 d3 02 00
	00		 jne	 $LN1@ProcessVol

; 665  : 
; 666  : 	case IOCTL_DISK_GET_DRIVE_LAYOUT:
; 667  : 		if (ValidateIOBufferSize (Irp, sizeof (DRIVE_LAYOUT_INFORMATION), ValidateOutput))

  00087	33 f6		 xor	 esi, esi
  00089	46		 inc	 esi
  0008a	56		 push	 esi
  0008b	6a 28		 push	 40			; 00000028H
  0008d	53		 push	 ebx
  0008e	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00093	85 c0		 test	 eax, eax
  00095	0f 84 1e 05 00
	00		 je	 $LN11@ProcessVol

; 668  : 		{
; 669  : 			PDRIVE_LAYOUT_INFORMATION outputBuffer = (PDRIVE_LAYOUT_INFORMATION)
; 670  : 			Irp->AssociatedIrp.SystemBuffer;

  0009b	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]

; 671  : 
; 672  : 			outputBuffer->PartitionCount = 1;

  0009e	89 30		 mov	 DWORD PTR [eax], esi

; 673  : 			outputBuffer->Signature = 0;

  000a0	33 f6		 xor	 esi, esi
  000a2	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 674  : 
; 675  : 			outputBuffer->PartitionEntry->PartitionType = Extension->PartitionType;

  000a5	8a 8f 8c 00 00
	00		 mov	 cl, BYTE PTR [edi+140]
  000ab	88 48 20	 mov	 BYTE PTR [eax+32], cl

; 676  : 			outputBuffer->PartitionEntry->BootIndicator = FALSE;

  000ae	c6 40 21 00	 mov	 BYTE PTR [eax+33], 0

; 677  : 			outputBuffer->PartitionEntry->RecognizedPartition = TRUE;

  000b2	c6 40 22 01	 mov	 BYTE PTR [eax+34], 1

; 678  : 			outputBuffer->PartitionEntry->RewritePartition = FALSE;

  000b6	c6 40 23 00	 mov	 BYTE PTR [eax+35], 0

; 679  : 			outputBuffer->PartitionEntry->StartingOffset.QuadPart = Extension->BytesPerSector;

  000ba	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  000c0	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000c3	89 70 0c	 mov	 DWORD PTR [eax+12], esi

; 680  : 			outputBuffer->PartitionEntry->PartitionLength.QuadPart = Extension->DiskLength;

  000c6	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  000c9	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  000cc	8b 4f 74	 mov	 ecx, DWORD PTR [edi+116]
  000cf	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 681  : 			outputBuffer->PartitionEntry->HiddenSectors = 0;

  000d2	89 70 18	 mov	 DWORD PTR [eax+24], esi

; 682  : 
; 683  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  000d5	89 73 18	 mov	 DWORD PTR [ebx+24], esi

; 684  : 			Irp->IoStatus.Information = sizeof (PARTITION_INFORMATION);

  000d8	c7 43 1c 20 00
	00 00		 mov	 DWORD PTR [ebx+28], 32	; 00000020H

; 685  : 		}
; 686  : 		break;

  000df	e9 d5 04 00 00	 jmp	 $LN11@ProcessVol
$LN28@ProcessVol:

; 629  : 
; 630  : 	case IOCTL_DISK_GET_PARTITION_INFO:
; 631  : 		if (ValidateIOBufferSize (Irp, sizeof (PARTITION_INFORMATION), ValidateOutput))

  000e4	6a 01		 push	 1
  000e6	6a 20		 push	 32			; 00000020H
  000e8	5e		 pop	 esi
  000e9	56		 push	 esi
  000ea	53		 push	 ebx
  000eb	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  000f0	85 c0		 test	 eax, eax
  000f2	0f 84 c1 04 00
	00		 je	 $LN11@ProcessVol

; 632  : 		{
; 633  : 			PPARTITION_INFORMATION outputBuffer = (PPARTITION_INFORMATION)
; 634  : 			Irp->AssociatedIrp.SystemBuffer;
; 635  : 
; 636  : 			outputBuffer->PartitionType = Extension->PartitionType;

  000f8	8a 8f 8c 00 00
	00		 mov	 cl, BYTE PTR [edi+140]
  000fe	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00101	88 48 18	 mov	 BYTE PTR [eax+24], cl

; 637  : 			outputBuffer->BootIndicator = FALSE;

  00104	c6 40 19 00	 mov	 BYTE PTR [eax+25], 0

; 638  : 			outputBuffer->RecognizedPartition = TRUE;

  00108	c6 40 1a 01	 mov	 BYTE PTR [eax+26], 1

; 639  : 			outputBuffer->RewritePartition = FALSE;

  0010c	c6 40 1b 00	 mov	 BYTE PTR [eax+27], 0

; 640  : 			outputBuffer->StartingOffset.QuadPart = Extension->BytesPerSector;

  00110	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  00116	89 08		 mov	 DWORD PTR [eax], ecx
  00118	33 c9		 xor	 ecx, ecx
  0011a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 641  : 			outputBuffer->PartitionLength.QuadPart= Extension->DiskLength;

  0011d	8b 57 70	 mov	 edx, DWORD PTR [edi+112]
  00120	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00123	8b 57 74	 mov	 edx, DWORD PTR [edi+116]
  00126	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 642  : 			outputBuffer->HiddenSectors = 0;

  00129	89 48 10	 mov	 DWORD PTR [eax+16], ecx
$LN66@ProcessVol:

; 643  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  0012c	89 4b 18	 mov	 DWORD PTR [ebx+24], ecx

; 644  : 			Irp->IoStatus.Information = sizeof (PARTITION_INFORMATION);
; 645  : 		}
; 646  : 		break;

  0012f	e9 68 04 00 00	 jmp	 $LN65@ProcessVol
$LN26@ProcessVol:

; 647  : 
; 648  : 	case IOCTL_DISK_GET_PARTITION_INFO_EX:
; 649  : 		if (ValidateIOBufferSize (Irp, sizeof (PARTITION_INFORMATION_EX), ValidateOutput))

  00134	6a 01		 push	 1
  00136	be 90 00 00 00	 mov	 esi, 144		; 00000090H
  0013b	56		 push	 esi
  0013c	53		 push	 ebx
  0013d	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00142	85 c0		 test	 eax, eax
  00144	0f 84 6f 04 00
	00		 je	 $LN11@ProcessVol

; 650  : 		{
; 651  : 			PPARTITION_INFORMATION_EX outputBuffer = (PPARTITION_INFORMATION_EX) Irp->AssociatedIrp.SystemBuffer;

  0014a	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]

; 652  : 
; 653  : 			outputBuffer->PartitionStyle = PARTITION_STYLE_MBR;

  0014d	33 c9		 xor	 ecx, ecx
  0014f	89 08		 mov	 DWORD PTR [eax], ecx

; 654  : 			outputBuffer->RewritePartition = FALSE;

  00151	88 48 1c	 mov	 BYTE PTR [eax+28], cl

; 655  : 			outputBuffer->StartingOffset.QuadPart = Extension->BytesPerSector;

  00154	8b 97 88 00 00
	00		 mov	 edx, DWORD PTR [edi+136]
  0015a	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0015d	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 656  : 			outputBuffer->PartitionLength.QuadPart= Extension->DiskLength;

  00160	8b 57 70	 mov	 edx, DWORD PTR [edi+112]
  00163	89 50 10	 mov	 DWORD PTR [eax+16], edx
  00166	8b 57 74	 mov	 edx, DWORD PTR [edi+116]
  00169	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 657  : 			outputBuffer->Mbr.PartitionType = Extension->PartitionType;

  0016c	8a 97 8c 00 00
	00		 mov	 dl, BYTE PTR [edi+140]
  00172	88 50 20	 mov	 BYTE PTR [eax+32], dl

; 658  : 			outputBuffer->Mbr.BootIndicator = FALSE;

  00175	88 48 21	 mov	 BYTE PTR [eax+33], cl

; 659  : 			outputBuffer->Mbr.RecognizedPartition = TRUE;

  00178	c6 40 22 01	 mov	 BYTE PTR [eax+34], 1

; 660  : 			outputBuffer->Mbr.HiddenSectors = 0;

  0017c	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 661  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 662  : 			Irp->IoStatus.Information = sizeof (PARTITION_INFORMATION_EX);
; 663  : 		}
; 664  : 		break;

  0017f	eb ab		 jmp	 SHORT $LN66@ProcessVol
$LN10@ProcessVol:

; 748  : 			}
; 749  : 		}
; 750  : 		break;
; 751  : 
; 752  : 	case IOCTL_DISK_IS_WRITABLE:
; 753  : 		{
; 754  : 			if (Extension->bReadOnly)

  00181	8b 87 48 02 00
	00		 mov	 eax, DWORD PTR [edi+584]
  00187	f7 d8		 neg	 eax
  00189	1b c0		 sbb	 eax, eax
  0018b	25 a2 00 00 c0	 and	 eax, -1073741662	; c00000a2H
  00190	89 43 18	 mov	 DWORD PTR [ebx+24], eax

; 755  : 				Irp->IoStatus.Status = STATUS_MEDIA_WRITE_PROTECTED;
; 756  : 			else
; 757  : 				Irp->IoStatus.Status = STATUS_SUCCESS;
; 758  : 			Irp->IoStatus.Information = 0;
; 759  : 
; 760  : 		}
; 761  : 		break;

  00193	e9 3d 02 00 00	 jmp	 $LN60@ProcessVol
$LN19@ProcessVol:

; 703  : 
; 704  : 	case IOCTL_DISK_VERIFY:
; 705  : 		if (ValidateIOBufferSize (Irp, sizeof (VERIFY_INFORMATION), ValidateInput))

  00198	6a 00		 push	 0
  0019a	6a 10		 push	 16			; 00000010H
  0019c	53		 push	 ebx
  0019d	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  001a2	85 c0		 test	 eax, eax
  001a4	0f 84 0f 04 00
	00		 je	 $LN11@ProcessVol

; 706  : 		{
; 707  : 			PVERIFY_INFORMATION pVerifyInformation;
; 708  : 			pVerifyInformation = (PVERIFY_INFORMATION) Irp->AssociatedIrp.SystemBuffer;

  001aa	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]

; 709  : 
; 710  : 			if (pVerifyInformation->StartingOffset.QuadPart + pVerifyInformation->Length > Extension->DiskLength)

  001ad	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  001b0	33 c0		 xor	 eax, eax
  001b2	8b ca		 mov	 ecx, edx
  001b4	03 0e		 add	 ecx, DWORD PTR [esi]
  001b6	13 46 04	 adc	 eax, DWORD PTR [esi+4]
  001b9	3b 47 74	 cmp	 eax, DWORD PTR [edi+116]
  001bc	7c 0f		 jl	 SHORT $LN17@ProcessVol
  001be	0f 8f 0a 02 00
	00		 jg	 $LN53@ProcessVol
  001c4	3b 4f 70	 cmp	 ecx, DWORD PTR [edi+112]

; 711  : 				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
; 712  : 			else

  001c7	0f 87 01 02 00
	00		 ja	 $LN53@ProcessVol
$LN17@ProcessVol:

; 713  : 			{
; 714  : 				IO_STATUS_BLOCK ioStatus;
; 715  : 				PVOID buffer = TCalloc (max (pVerifyInformation->Length, PAGE_SIZE));

  001cd	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  001d2	3b d0		 cmp	 edx, eax
  001d4	76 02		 jbe	 SHORT $LN46@ProcessVol
  001d6	8b c2		 mov	 eax, edx
$LN46@ProcessVol:
  001d8	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  001dd	50		 push	 eax
  001de	6a 00		 push	 0
  001e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  001e6	89 85 78 fd ff
	ff		 mov	 DWORD PTR _buffer$30038[ebp], eax

; 716  : 				
; 717  : 				if (!buffer)

  001ec	85 c0		 test	 eax, eax
  001ee	75 0c		 jne	 SHORT $LN15@ProcessVol

; 718  : 				{
; 719  : 					Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

  001f0	c7 43 18 9a 00
	00 c0		 mov	 DWORD PTR [ebx+24], -1073741670 ; c000009aH

; 720  : 				}
; 721  : 				else

  001f7	e9 d9 01 00 00	 jmp	 $LN60@ProcessVol
$LN15@ProcessVol:

; 722  : 				{
; 723  : 					LARGE_INTEGER offset = pVerifyInformation->StartingOffset;

  001fc	8b 06		 mov	 eax, DWORD PTR [esi]
  001fe	89 85 70 fd ff
	ff		 mov	 DWORD PTR _offset$30043[ebp], eax
  00204	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00207	89 85 74 fd ff
	ff		 mov	 DWORD PTR _offset$30043[ebp+4], eax

; 724  : 					offset.QuadPart += Extension->cryptoInfo->hiddenVolume ? Extension->cryptoInfo->hiddenVolumeOffset : Extension->cryptoInfo->volDataAreaOffset;

  0020d	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  00210	83 b8 a0 29 00
	00 00		 cmp	 DWORD PTR [eax+10656], 0
  00217	74 0e		 je	 SHORT $LN48@ProcessVol
  00219	8b 88 18 44 00
	00		 mov	 ecx, DWORD PTR [eax+17432]
  0021f	8b 80 1c 44 00
	00		 mov	 eax, DWORD PTR [eax+17436]
  00225	eb 0c		 jmp	 SHORT $LN49@ProcessVol
$LN48@ProcessVol:
  00227	8b 88 08 44 00
	00		 mov	 ecx, DWORD PTR [eax+17416]
  0022d	8b 80 0c 44 00
	00		 mov	 eax, DWORD PTR [eax+17420]
$LN49@ProcessVol:
  00233	01 8d 70 fd ff
	ff		 add	 DWORD PTR _offset$30043[ebp], ecx

; 725  : 
; 726  : 					Irp->IoStatus.Status = ZwReadFile (Extension->hDeviceFile, NULL, NULL, NULL, &ioStatus, buffer, pVerifyInformation->Length, &offset, NULL);

  00239	8d 8d 70 fd ff
	ff		 lea	 ecx, DWORD PTR _offset$30043[ebp]
  0023f	11 85 74 fd ff
	ff		 adc	 DWORD PTR _offset$30043[ebp+4], eax
  00245	33 c0		 xor	 eax, eax
  00247	50		 push	 eax
  00248	51		 push	 ecx
  00249	ff 76 08	 push	 DWORD PTR [esi+8]
  0024c	8d 8d 68 fd ff
	ff		 lea	 ecx, DWORD PTR _ioStatus$30037[ebp]
  00252	ff b5 78 fd ff
	ff		 push	 DWORD PTR _buffer$30038[ebp]
  00258	51		 push	 ecx
  00259	50		 push	 eax
  0025a	50		 push	 eax
  0025b	50		 push	 eax
  0025c	ff 77 54	 push	 DWORD PTR [edi+84]
  0025f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwReadFile@36

; 727  : 					TCfree (buffer);

  00265	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0026a	ff b5 78 fd ff
	ff		 push	 DWORD PTR _buffer$30038[ebp]
  00270	89 43 18	 mov	 DWORD PTR [ebx+24], eax
  00273	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 728  : 
; 729  : 					if (NT_SUCCESS (Irp->IoStatus.Status) && ioStatus.Information != pVerifyInformation->Length)

  00279	83 7b 18 00	 cmp	 DWORD PTR [ebx+24], 0
  0027d	0f 8c 52 01 00
	00		 jl	 $LN60@ProcessVol
  00283	8b 85 6c fd ff
	ff		 mov	 eax, DWORD PTR _ioStatus$30037[ebp+4]
  00289	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0028c	0f 84 43 01 00
	00		 je	 $LN60@ProcessVol

; 730  : 						Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
; 731  : 				}
; 732  : 			}
; 733  : 
; 734  : 			Irp->IoStatus.Information = 0;
; 735  : 		}
; 736  : 		break;

  00292	e9 37 01 00 00	 jmp	 $LN53@ProcessVol
$LN30@ProcessVol:

; 610  : 
; 611  : 	case IOCTL_DISK_GET_MEDIA_TYPES:
; 612  : 	case IOCTL_DISK_GET_DRIVE_GEOMETRY:
; 613  : 		/* Return the drive geometry for the disk.  Note that we
; 614  : 		   return values which were made up to suit the disk size.  */
; 615  : 		if (ValidateIOBufferSize (Irp, sizeof (DISK_GEOMETRY), ValidateOutput))

  00297	6a 01		 push	 1
  00299	6a 18		 push	 24			; 00000018H
  0029b	5e		 pop	 esi
  0029c	56		 push	 esi
  0029d	53		 push	 ebx
  0029e	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  002a3	85 c0		 test	 eax, eax
  002a5	0f 84 0e 03 00
	00		 je	 $LN11@ProcessVol

; 616  : 		{
; 617  : 			PDISK_GEOMETRY outputBuffer = (PDISK_GEOMETRY)
; 618  : 			Irp->AssociatedIrp.SystemBuffer;
; 619  : 
; 620  : 			outputBuffer->MediaType = Extension->bRemovable ? RemovableMedia : FixedMedia;

  002ab	8b 8f 4c 02 00
	00		 mov	 ecx, DWORD PTR [edi+588]
  002b1	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  002b4	f7 d9		 neg	 ecx
  002b6	1b c9		 sbb	 ecx, ecx
  002b8	83 c1 0c	 add	 ecx, 12			; 0000000cH
  002bb	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 621  : 			outputBuffer->Cylinders.QuadPart = Extension->NumberOfCylinders;

  002be	8b 4f 78	 mov	 ecx, DWORD PTR [edi+120]
  002c1	89 08		 mov	 DWORD PTR [eax], ecx
  002c3	8b 4f 7c	 mov	 ecx, DWORD PTR [edi+124]
  002c6	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 622  : 			outputBuffer->TracksPerCylinder = Extension->TracksPerCylinder;

  002c9	8b 8f 80 00 00
	00		 mov	 ecx, DWORD PTR [edi+128]
  002cf	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 623  : 			outputBuffer->SectorsPerTrack = Extension->SectorsPerTrack;

  002d2	8b 8f 84 00 00
	00		 mov	 ecx, DWORD PTR [edi+132]
  002d8	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 624  : 			outputBuffer->BytesPerSector = Extension->BytesPerSector;

  002db	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  002e1	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 625  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 626  : 			Irp->IoStatus.Information = sizeof (DISK_GEOMETRY);
; 627  : 		}
; 628  : 		break;

  002e4	e9 af 02 00 00	 jmp	 $LN64@ProcessVol
$LN22@ProcessVol:

; 687  : 
; 688  : 	case IOCTL_DISK_GET_LENGTH_INFO:
; 689  : 		if (!ValidateIOBufferSize (Irp, sizeof (GET_LENGTH_INFORMATION), ValidateOutput))

  002e9	6a 01		 push	 1
  002eb	6a 08		 push	 8
  002ed	5e		 pop	 esi
  002ee	56		 push	 esi
  002ef	53		 push	 ebx
  002f0	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  002f5	85 c0		 test	 eax, eax
  002f7	75 0c		 jne	 SHORT $LN21@ProcessVol

; 690  : 		{
; 691  : 			Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

  002f9	c7 43 18 05 00
	00 80		 mov	 DWORD PTR [ebx+24], -2147483643 ; 80000005H

; 692  : 			Irp->IoStatus.Information = sizeof (GET_LENGTH_INFORMATION);
; 693  : 		}
; 694  : 		else

  00300	e9 97 02 00 00	 jmp	 $LN65@ProcessVol
$LN21@ProcessVol:

; 695  : 		{
; 696  : 			PGET_LENGTH_INFORMATION outputBuffer = (PGET_LENGTH_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
; 697  : 
; 698  : 			outputBuffer->Length.QuadPart = Extension->DiskLength;

  00305	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  00308	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0030b	89 08		 mov	 DWORD PTR [eax], ecx
  0030d	8b 4f 74	 mov	 ecx, DWORD PTR [edi+116]
  00310	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 699  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 700  : 			Irp->IoStatus.Information = sizeof (GET_LENGTH_INFORMATION);
; 701  : 		}
; 702  : 		break;

  00313	e9 80 02 00 00	 jmp	 $LN64@ProcessVol
$LN50@ProcessVol:

; 498  : 
; 499  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  00318	81 e9 00 48 07
	00		 sub	 ecx, 477184		; 00074800H
  0031e	0f 84 7d 02 00
	00		 je	 $LN12@ProcessVol
  00324	81 e9 00 00 26
	00		 sub	 ecx, 2490368		; 00260000H
  0032a	0f 84 71 02 00
	00		 je	 $LN12@ProcessVol
  00330	81 e9 00 b8 1f
	00		 sub	 ecx, 2078720		; 001fb800H
  00336	0f 84 90 01 00
	00		 je	 $LN37@ProcessVol
  0033c	83 e9 08	 sub	 ecx, 8
  0033f	0f 84 fc 00 00
	00		 je	 $LN41@ProcessVol
  00345	83 e9 04	 sub	 ecx, 4
  00348	74 6d		 je	 SHORT $LN33@ProcessVol
  0034a	81 e9 f4 ff 08
	00		 sub	 ecx, 589812		; 0008fff4H
  00350	74 20		 je	 SHORT $LN6@ProcessVol
  00352	81 e9 08 c0 00
	00		 sub	 ecx, 49160		; 0000c008H
  00358	74 12		 je	 SHORT $LN7@ProcessVol
$LN1@ProcessVol:

; 788  : 
; 789  : 	default:
; 790  : 		return TCCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);

  0035a	6a 00		 push	 0
  0035c	68 10 00 00 c0	 push	 -1073741808		; c0000010H
  00361	53		 push	 ebx
  00362	e8 00 00 00 00	 call	 _TCCompleteIrp@12
  00367	e9 59 02 00 00	 jmp	 $LN44@ProcessVol
$LN7@ProcessVol:

; 762  : 		
; 763  : 	case IOCTL_VOLUME_ONLINE:
; 764  : 		Irp->IoStatus.Status = STATUS_SUCCESS;

  0036c	83 63 18 00	 and	 DWORD PTR [ebx+24], 0

; 765  : 		Irp->IoStatus.Information = 0;
; 766  : 		break;

  00370	eb 63		 jmp	 SHORT $LN60@ProcessVol
$LN6@ProcessVol:

; 767  : 
; 768  : 	case IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS:
; 769  : 
; 770  : 		// Vista's filesystem defragmenter fails if IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS does not succeed.
; 771  : 		if (!(OsMajorVersion == 6 && OsMinorVersion == 0))

  00372	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _OsMajorVersion, 6
  00379	75 33		 jne	 SHORT $LN59@ProcessVol
  0037b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _OsMinorVersion, 0
  00382	75 2a		 jne	 SHORT $LN59@ProcessVol

; 774  : 			Irp->IoStatus.Information = 0;
; 775  : 		}
; 776  : 		else if (ValidateIOBufferSize (Irp, sizeof (VOLUME_DISK_EXTENTS), ValidateOutput))

  00384	6a 01		 push	 1
  00386	6a 20		 push	 32			; 00000020H
  00388	5e		 pop	 esi
  00389	56		 push	 esi
  0038a	53		 push	 ebx
  0038b	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00390	85 c0		 test	 eax, eax
  00392	0f 84 21 02 00
	00		 je	 $LN11@ProcessVol

; 777  : 		{
; 778  : 			VOLUME_DISK_EXTENTS *extents = (VOLUME_DISK_EXTENTS *) Irp->AssociatedIrp.SystemBuffer;

  00398	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]

; 779  : 
; 780  : 			// No extent data can be returned as this is not a physical drive.
; 781  : 			memset (extents, 0, sizeof (*extents));

  0039b	6a 08		 push	 8
  0039d	33 c0		 xor	 eax, eax
  0039f	59		 pop	 ecx
  003a0	8b fa		 mov	 edi, edx
  003a2	f3 ab		 rep stosd

; 782  : 			extents->NumberOfDiskExtents = 0;

  003a4	21 02		 and	 DWORD PTR [edx], eax

; 783  : 
; 784  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  003a6	21 43 18	 and	 DWORD PTR [ebx+24], eax

; 785  : 			Irp->IoStatus.Information = sizeof (*extents);

  003a9	e9 ee 01 00 00	 jmp	 $LN65@ProcessVol
$LN59@ProcessVol:

; 772  : 		{
; 773  : 			Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;

  003ae	c7 43 18 10 00
	00 c0		 mov	 DWORD PTR [ebx+24], -1073741808 ; c0000010H

; 786  : 		}
; 787  : 		break;

  003b5	eb 1e		 jmp	 SHORT $LN60@ProcessVol
$LN33@ProcessVol:

; 572  : 
; 573  : 	case IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME:
; 574  : 		{
; 575  : 			ULONG outLength;
; 576  : 			UNICODE_STRING ntUnicodeString;
; 577  : 			WCHAR ntName[256];
; 578  : 			PMOUNTDEV_SUGGESTED_LINK_NAME outputBuffer = (PMOUNTDEV_SUGGESTED_LINK_NAME) Irp->AssociatedIrp.SystemBuffer;

  003b7	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]

; 579  : 
; 580  : 			if (!ValidateIOBufferSize (Irp, sizeof (MOUNTDEV_SUGGESTED_LINK_NAME), ValidateOutput))

  003ba	6a 01		 push	 1
  003bc	6a 06		 push	 6
  003be	53		 push	 ebx
  003bf	89 85 78 fd ff
	ff		 mov	 DWORD PTR _outputBuffer$29978[ebp], eax
  003c5	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  003ca	85 c0		 test	 eax, eax
  003cc	75 10		 jne	 SHORT $LN32@ProcessVol
$LN53@ProcessVol:

; 581  : 			{
; 582  : 				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  003ce	c7 43 18 0d 00
	00 c0		 mov	 DWORD PTR [ebx+24], -1073741811 ; c000000dH
$LN60@ProcessVol:

; 583  : 				Irp->IoStatus.Information = 0;

  003d5	83 63 1c 00	 and	 DWORD PTR [ebx+28], 0

; 584  : 				break; 

  003d9	e9 db 01 00 00	 jmp	 $LN11@ProcessVol
$LN32@ProcessVol:

; 585  : 			}
; 586  : 
; 587  : 			TCGetDosNameFromNumber (ntName, Extension->nDosDriveNo);

  003de	ff 77 14	 push	 DWORD PTR [edi+20]
  003e1	8d 85 7c fd ff
	ff		 lea	 eax, DWORD PTR _ntName$29977[ebp]
  003e7	50		 push	 eax
  003e8	e8 00 00 00 00	 call	 _TCGetDosNameFromNumber@8

; 588  : 			RtlInitUnicodeString (&ntUnicodeString, ntName);

  003ed	8d 85 7c fd ff
	ff		 lea	 eax, DWORD PTR _ntName$29977[ebp]
  003f3	50		 push	 eax
  003f4	8d 85 70 fd ff
	ff		 lea	 eax, DWORD PTR _ntUnicodeString$29976[ebp]
  003fa	50		 push	 eax
  003fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 589  : 
; 590  : 			outLength = FIELD_OFFSET(MOUNTDEV_SUGGESTED_LINK_NAME,Name) + ntUnicodeString.Length;

  00401	0f b7 bd 70 fd
	ff ff		 movzx	 edi, WORD PTR _ntUnicodeString$29976[ebp]

; 591  : 
; 592  : 			outputBuffer->UseOnlyIfThereAreNoOtherLinks = FALSE;

  00408	8b 85 78 fd ff
	ff		 mov	 eax, DWORD PTR _outputBuffer$29978[ebp]
  0040e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 593  : 			outputBuffer->NameLength = ntUnicodeString.Length;

  00411	66 8b 8d 70 fd
	ff ff		 mov	 cx, WORD PTR _ntUnicodeString$29976[ebp]
  00418	83 c7 04	 add	 edi, 4
  0041b	66 89 48 02	 mov	 WORD PTR [eax+2], cx

; 594  : 
; 595  : 			if(irpSp->Parameters.DeviceIoControl.OutputBufferLength < outLength)

  0041f	39 7e 04	 cmp	 DWORD PTR [esi+4], edi
  00422	73 09		 jae	 SHORT $LN31@ProcessVol

; 596  : 			{
; 597  : 				Irp->IoStatus.Information = sizeof (MOUNTDEV_SUGGESTED_LINK_NAME);

  00424	c7 43 1c 06 00
	00 00		 mov	 DWORD PTR [ebx+28], 6

; 598  : 				Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
; 599  : 				break;

  0042b	eb 74		 jmp	 SHORT $LN62@ProcessVol
$LN31@ProcessVol:

; 600  : 			}
; 601  : 
; 602  : 			RtlCopyMemory ((PCHAR)outputBuffer->Name,ntUnicodeString.Buffer, ntUnicodeString.Length);

  0042d	0f b7 8d 70 fd
	ff ff		 movzx	 ecx, WORD PTR _ntUnicodeString$29976[ebp]
  00434	51		 push	 ecx
  00435	ff b5 74 fd ff
	ff		 push	 DWORD PTR _ntUnicodeString$29976[ebp+4]
  0043b	83 c0 04	 add	 eax, 4
  0043e	50		 push	 eax

; 603  : 		
; 604  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 605  : 			Irp->IoStatus.Information = outLength;
; 606  : 
; 607  : 			Dump ("link = %ls\n",ntName);
; 608  : 		}
; 609  : 		break;

  0043f	eb 77		 jmp	 SHORT $LN63@ProcessVol
$LN41@ProcessVol:

; 500  : 	{
; 501  : 
; 502  : 	case IOCTL_MOUNTDEV_QUERY_DEVICE_NAME:
; 503  : 		if (!ValidateIOBufferSize (Irp, sizeof (MOUNTDEV_NAME), ValidateOutput))

  00441	6a 01		 push	 1
  00443	6a 04		 push	 4
  00445	53		 push	 ebx
  00446	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  0044b	85 c0		 test	 eax, eax

; 504  : 		{
; 505  : 			Irp->IoStatus.Information = sizeof (MOUNTDEV_NAME);
; 506  : 			Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
; 507  : 		}
; 508  : 		else

  0044d	74 4b		 je	 SHORT $LN61@ProcessVol

; 509  : 		{
; 510  : 			ULONG outLength;
; 511  : 			UNICODE_STRING ntUnicodeString;
; 512  : 			WCHAR ntName[256];
; 513  : 			PMOUNTDEV_NAME outputBuffer = (PMOUNTDEV_NAME) Irp->AssociatedIrp.SystemBuffer;

  0044f	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]

; 514  : 
; 515  : 			TCGetNTNameFromNumber (ntName, Extension->nDosDriveNo);

  00452	ff 77 14	 push	 DWORD PTR [edi+20]
  00455	89 85 78 fd ff
	ff		 mov	 DWORD PTR _outputBuffer$29945[ebp], eax
  0045b	8d 85 7c fd ff
	ff		 lea	 eax, DWORD PTR _ntName$29944[ebp]
  00461	50		 push	 eax
  00462	e8 00 00 00 00	 call	 _TCGetNTNameFromNumber@8

; 516  : 			RtlInitUnicodeString (&ntUnicodeString, ntName);

  00467	8d 85 7c fd ff
	ff		 lea	 eax, DWORD PTR _ntName$29944[ebp]
  0046d	50		 push	 eax
  0046e	8d 85 70 fd ff
	ff		 lea	 eax, DWORD PTR _ntUnicodeString$29943[ebp]
  00474	50		 push	 eax
  00475	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 517  : 
; 518  : 			outputBuffer->NameLength = ntUnicodeString.Length;

  0047b	66 8b 85 70 fd
	ff ff		 mov	 ax, WORD PTR _ntUnicodeString$29943[ebp]
  00482	8b 8d 78 fd ff
	ff		 mov	 ecx, DWORD PTR _outputBuffer$29945[ebp]
  00488	66 89 01	 mov	 WORD PTR [ecx], ax

; 519  : 			outLength = ntUnicodeString.Length + sizeof(USHORT);

  0048b	0f b7 85 70 fd
	ff ff		 movzx	 eax, WORD PTR _ntUnicodeString$29943[ebp]
  00492	8d 78 02	 lea	 edi, DWORD PTR [eax+2]

; 520  : 
; 521  : 			if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < outLength)

  00495	39 7e 04	 cmp	 DWORD PTR [esi+4], edi
  00498	73 13		 jae	 SHORT $LN38@ProcessVol
$LN61@ProcessVol:

; 522  : 			{
; 523  : 				Irp->IoStatus.Information = sizeof (MOUNTDEV_NAME);

  0049a	c7 43 1c 04 00
	00 00		 mov	 DWORD PTR [ebx+28], 4
$LN62@ProcessVol:

; 524  : 				Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

  004a1	c7 43 18 05 00
	00 80		 mov	 DWORD PTR [ebx+24], -2147483643 ; 80000005H

; 525  : 
; 526  : 				break;

  004a8	e9 0c 01 00 00	 jmp	 $LN11@ProcessVol
$LN38@ProcessVol:

; 527  : 			}
; 528  : 
; 529  : 			RtlCopyMemory ((PCHAR)outputBuffer->Name,ntUnicodeString.Buffer, ntUnicodeString.Length);

  004ad	50		 push	 eax
  004ae	ff b5 74 fd ff
	ff		 push	 DWORD PTR _ntUnicodeString$29943[ebp+4]
  004b4	83 c1 02	 add	 ecx, 2
  004b7	51		 push	 ecx
$LN63@ProcessVol:
  004b8	e8 00 00 00 00	 call	 _memcpy
  004bd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 530  : 
; 531  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  004c0	83 63 18 00	 and	 DWORD PTR [ebx+24], 0

; 532  : 			Irp->IoStatus.Information = outLength;

  004c4	89 7b 1c	 mov	 DWORD PTR [ebx+28], edi

; 533  : 
; 534  : 			Dump ("name = %ls\n",ntName);
; 535  : 		}
; 536  : 		break;

  004c7	e9 ed 00 00 00	 jmp	 $LN11@ProcessVol
$LN37@ProcessVol:

; 537  : 
; 538  : 	case IOCTL_MOUNTDEV_QUERY_UNIQUE_ID:
; 539  : 		if (!ValidateIOBufferSize (Irp, sizeof (MOUNTDEV_UNIQUE_ID), ValidateOutput))

  004cc	6a 01		 push	 1
  004ce	6a 04		 push	 4
  004d0	5e		 pop	 esi
  004d1	56		 push	 esi
  004d2	53		 push	 ebx
  004d3	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  004d8	85 c0		 test	 eax, eax
  004da	75 05		 jne	 SHORT $LN36@ProcessVol

; 540  : 		{
; 541  : 			Irp->IoStatus.Information = sizeof (MOUNTDEV_UNIQUE_ID);

  004dc	89 73 1c	 mov	 DWORD PTR [ebx+28], esi

; 542  : 			Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
; 543  : 		}
; 544  : 		else

  004df	eb c0		 jmp	 SHORT $LN62@ProcessVol
$LN36@ProcessVol:

; 545  : 		{
; 546  : 			ULONG outLength;
; 547  : 			UCHAR volId[128], tmp[] = { 0,0 };
; 548  : 			PMOUNTDEV_UNIQUE_ID outputBuffer = (PMOUNTDEV_UNIQUE_ID) Irp->AssociatedIrp.SystemBuffer;
; 549  : 
; 550  : 			strcpy (volId, TC_UNIQUE_ID_PREFIX); 
; 551  : 			tmp[0] = 'A' + (UCHAR) Extension->nDosDriveNo;

  004e1	8b 85 6c fd ff
	ff		 mov	 eax, DWORD PTR _Extension$GSCopy$[ebp]
  004e7	8a 40 14	 mov	 al, BYTE PTR [eax+20]
  004ea	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]
  004ed	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@FNODOBFM@
  004f2	8d bd 7c ff ff
	ff		 lea	 edi, DWORD PTR _volId$29960[ebp]
  004f8	a5		 movsd
  004f9	a5		 movsd
  004fa	a5		 movsd
  004fb	04 41		 add	 al, 65			; 00000041H
  004fd	88 85 78 fd ff
	ff		 mov	 BYTE PTR _tmp$29961[ebp], al

; 552  : 			strcat (volId, tmp);

  00503	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR _tmp$29961[ebp]
  00509	a5		 movsd
  0050a	c6 85 79 fd ff
	ff 00		 mov	 BYTE PTR _tmp$29961[ebp+1], 0
  00511	8b f0		 mov	 esi, eax
$LL54@ProcessVol:
  00513	8a 08		 mov	 cl, BYTE PTR [eax]
  00515	40		 inc	 eax
  00516	84 c9		 test	 cl, cl
  00518	75 f9		 jne	 SHORT $LL54@ProcessVol
  0051a	8d bd 7c ff ff
	ff		 lea	 edi, DWORD PTR _volId$29960[ebp]
  00520	2b c6		 sub	 eax, esi
  00522	4f		 dec	 edi
$LL55@ProcessVol:
  00523	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00526	47		 inc	 edi
  00527	84 c9		 test	 cl, cl
  00529	75 f8		 jne	 SHORT $LL55@ProcessVol
  0052b	8b c8		 mov	 ecx, eax
  0052d	c1 e9 02	 shr	 ecx, 2
  00530	f3 a5		 rep movsd
  00532	8b c8		 mov	 ecx, eax
  00534	83 e1 03	 and	 ecx, 3

; 553  : 			
; 554  : 			outputBuffer->UniqueIdLength = (USHORT) strlen (volId);

  00537	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _volId$29960[ebp]
  0053d	f3 a4		 rep movsb
  0053f	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$LL56@ProcessVol:
  00542	8a 08		 mov	 cl, BYTE PTR [eax]
  00544	40		 inc	 eax
  00545	84 c9		 test	 cl, cl
  00547	75 f9		 jne	 SHORT $LL56@ProcessVol
  00549	2b c6		 sub	 eax, esi
  0054b	66 89 02	 mov	 WORD PTR [edx], ax

; 555  : 			outLength = (ULONG) (strlen (volId) + sizeof (USHORT));

  0054e	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _volId$29960[ebp]
  00554	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$LL57@ProcessVol:
  00557	8a 08		 mov	 cl, BYTE PTR [eax]
  00559	40		 inc	 eax
  0055a	84 c9		 test	 cl, cl
  0055c	75 f9		 jne	 SHORT $LL57@ProcessVol
  0055e	2b c6		 sub	 eax, esi
  00560	8d 70 02	 lea	 esi, DWORD PTR [eax+2]

; 556  : 
; 557  : 			if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < outLength)

  00563	8b 85 74 fd ff
	ff		 mov	 eax, DWORD PTR _irpSp$[ebp]
  00569	39 70 04	 cmp	 DWORD PTR [eax+4], esi

; 558  : 			{
; 559  : 				Irp->IoStatus.Information = sizeof (MOUNTDEV_UNIQUE_ID);
; 560  : 				Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
; 561  : 				break;

  0056c	0f 82 28 ff ff
	ff		 jb	 $LN61@ProcessVol

; 562  : 			}
; 563  : 
; 564  : 			RtlCopyMemory ((PCHAR)outputBuffer->UniqueId, volId, strlen (volId));

  00572	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _volId$29960[ebp]
  00578	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
$LL58@ProcessVol:
  0057b	8a 08		 mov	 cl, BYTE PTR [eax]
  0057d	40		 inc	 eax
  0057e	84 c9		 test	 cl, cl
  00580	75 f9		 jne	 SHORT $LL58@ProcessVol
  00582	2b c7		 sub	 eax, edi
  00584	50		 push	 eax
  00585	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _volId$29960[ebp]
  0058b	50		 push	 eax
  0058c	83 c2 02	 add	 edx, 2
  0058f	52		 push	 edx
  00590	e8 00 00 00 00	 call	 _memcpy
  00595	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN64@ProcessVol:

; 565  : 
; 566  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00598	83 63 18 00	 and	 DWORD PTR [ebx+24], 0
$LN65@ProcessVol:

; 567  : 			Irp->IoStatus.Information = outLength;

  0059c	89 73 1c	 mov	 DWORD PTR [ebx+28], esi

; 568  : 
; 569  : 			Dump ("id = %s\n",volId);
; 570  : 		}
; 571  : 		break;

  0059f	eb 18		 jmp	 SHORT $LN11@ProcessVol
$LN12@ProcessVol:

; 737  : 
; 738  : 	case IOCTL_DISK_CHECK_VERIFY:
; 739  : 	case IOCTL_STORAGE_CHECK_VERIFY:
; 740  : 		{
; 741  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  005a1	33 c9		 xor	 ecx, ecx

; 742  : 			Irp->IoStatus.Information = 0;
; 743  : 
; 744  : 			if (irpSp->Parameters.DeviceIoControl.OutputBufferLength >= sizeof (ULONG))

  005a3	6a 04		 push	 4
  005a5	58		 pop	 eax
  005a6	89 4b 18	 mov	 DWORD PTR [ebx+24], ecx
  005a9	89 4b 1c	 mov	 DWORD PTR [ebx+28], ecx
  005ac	39 46 04	 cmp	 DWORD PTR [esi+4], eax
  005af	72 08		 jb	 SHORT $LN11@ProcessVol

; 745  : 			{
; 746  : 				*((ULONG *) Irp->AssociatedIrp.SystemBuffer) = 0;

  005b1	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]
  005b4	89 0a		 mov	 DWORD PTR [edx], ecx

; 747  : 				Irp->IoStatus.Information = sizeof (ULONG);

  005b6	89 43 1c	 mov	 DWORD PTR [ebx+28], eax
$LN11@ProcessVol:

; 791  : 	}
; 792  : 
; 793  : #ifdef DEBUG
; 794  : 	if (!NT_SUCCESS (Irp->IoStatus.Status))
; 795  : 	{
; 796  : 		Dump ("IOCTL error 0x%08x (0x%x %d)\n",
; 797  : 			Irp->IoStatus.Status,
; 798  : 			(int) (irpSp->Parameters.DeviceIoControl.IoControlCode >> 16),
; 799  : 			(int) ((irpSp->Parameters.DeviceIoControl.IoControlCode & 0x1FFF) >> 2));
; 800  : 	}
; 801  : #endif
; 802  : 
; 803  : 	return TCCompleteDiskIrp (Irp, Irp->IoStatus.Status, Irp->IoStatus.Information);

  005b9	ff 73 1c	 push	 DWORD PTR [ebx+28]
  005bc	ff 73 18	 push	 DWORD PTR [ebx+24]
  005bf	53		 push	 ebx
  005c0	e8 00 00 00 00	 call	 _TCCompleteDiskIrp@12
$LN44@ProcessVol:

; 804  : }

  005c5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005c8	5f		 pop	 edi
  005c9	5e		 pop	 esi
  005ca	33 cd		 xor	 ecx, ebp
  005cc	5b		 pop	 ebx
  005cd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005d2	c9		 leave
  005d3	c2 0c 00	 ret	 12			; 0000000cH
_ProcessVolumeDeviceControlIrp@12 ENDP
_TEXT	ENDS
PUBLIC	_TCStartThread@12
; Function compile flags: /Ogsp
;	COMDAT _TCStartThread@12
_TEXT	SEGMENT
_threadProc$ = 8					; size = 4
_threadArg$ = 12					; size = 4
_kThread$ = 16						; size = 4
_TCStartThread@12 PROC					; COMDAT

; 1559 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1560 : 	return TCStartThreadInProcess (threadProc, threadArg, kThread, NULL);

  00005	6a 00		 push	 0
  00007	ff 75 10	 push	 DWORD PTR _kThread$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR _threadArg$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR _threadProc$[ebp]
  00010	e8 00 00 00 00	 call	 _TCStartThreadInProcess@16

; 1561 : }

  00015	5d		 pop	 ebp
  00016	c2 0c 00	 ret	 12			; 0000000cH
_TCStartThread@12 ENDP
_TEXT	ENDS
PUBLIC	??_C@_19JHEHLFPM@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BA@CCLAPIHO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_VolumeThreadProc@4
EXTRN	_EncryptedIoQueueStop@4:PROC
EXTRN	__imp__IoReleaseRemoveLockEx@12:PROC
EXTRN	__imp_@ExfInterlockedRemoveHeadList@8:PROC
EXTRN	_TCCloseVolume@8:PROC
EXTRN	_EncryptedIoQueueStart@4:PROC
EXTRN	__imp__PsTerminateSystemThread@4:PROC
EXTRN	_TCOpenVolume@20:PROC
EXTRN	__imp__KeSetPriorityThread@8:PROC
;	COMDAT ??_C@_19JHEHLFPM@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$AA@FNODOBFM@
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
text$s	SEGMENT
??_C@_19JHEHLFPM@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$AA@FNODOBFM@ DB '\', 00H
	DB	'?', 00H, '?', 00H, '\', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BA@CCLAPIHO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BA@CCLAPIHO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
; File c:\home\public\desktop\projects\ciphershed.build\src\driver\ntdriver.c
text$s	ENDS
;	COMDAT _VolumeThreadProc@4
_TEXT	SEGMENT
tv375 = -8						; size = 4
_DeviceObject$ = -4					; size = 4
_irp$30565 = 8						; size = 4
_Context$ = 8						; size = 4
_VolumeThreadProc@4 PROC				; COMDAT

; 1739 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	51		 push	 ecx
  00007	53		 push	 ebx
  00008	56		 push	 esi

; 1740 : 	PTHREAD_BLOCK pThreadBlock = (PTHREAD_BLOCK) Context;
; 1741 : 	PDEVICE_OBJECT DeviceObject = pThreadBlock->DeviceObject;

  00009	8b 75 08	 mov	 esi, DWORD PTR _Context$[ebp]
  0000c	8b 06		 mov	 eax, DWORD PTR [esi]

; 1742 : 	PEXTENSION Extension = (PEXTENSION) DeviceObject->DeviceExtension;

  0000e	8b 58 28	 mov	 ebx, DWORD PTR [eax+40]
  00011	57		 push	 edi

; 1743 : 	BOOL bDevice;
; 1744 : 
; 1745 : 	/* Set thread priority to lowest realtime level. */
; 1746 : 	KeSetPriorityThread (KeGetCurrentThread (), LOW_REALTIME_PRIORITY);

  00012	6a 10		 push	 16			; 00000010H
  00014	89 45 fc	 mov	 DWORD PTR _DeviceObject$[ebp], eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeGetCurrentThread@0
  0001d	50		 push	 eax
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetPriorityThread@8

; 1747 : 
; 1748 : 	Dump ("Mount THREAD OPENING VOLUME BEGIN\n");
; 1749 : 
; 1750 : 	if (memcmp (pThreadBlock->mount->wszVolume, WIDE ("\\Device"), 14) != 0)

  00024	8b 86 20 02 00
	00		 mov	 eax, DWORD PTR [esi+544]
  0002a	6a 07		 push	 7
  0002c	83 c0 10	 add	 eax, 16			; 00000010H
  0002f	59		 pop	 ecx
  00030	33 d2		 xor	 edx, edx
  00032	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_1BA@CCLAPIHO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@
  00037	8b f0		 mov	 esi, eax
  00039	52		 push	 edx
  0003a	66 f3 a7	 repe cmpsw
  0003d	5f		 pop	 edi
  0003e	74 3d		 je	 SHORT $LN13@VolumeThre

; 1751 : 	{
; 1752 : 		wcscpy (pThreadBlock->wszMountVolume, WIDE ("\\??\\"));

  00040	8b 75 08	 mov	 esi, DWORD PTR _Context$[ebp]
  00043	8d 56 08	 lea	 edx, DWORD PTR [esi+8]
  00046	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_19JHEHLFPM@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$AA@FNODOBFM@
  0004b	89 55 f8	 mov	 DWORD PTR tv375[ebp], edx
  0004e	2b d0		 sub	 edx, eax
$LL16@VolumeThre:
  00050	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00053	66 89 0c 02	 mov	 WORD PTR [edx+eax], cx
  00057	40		 inc	 eax
  00058	40		 inc	 eax
  00059	66 3b cf	 cmp	 cx, di
  0005c	75 f2		 jne	 SHORT $LL16@VolumeThre

; 1753 : 		wcsncat (pThreadBlock->wszMountVolume, pThreadBlock->mount->wszVolume,
; 1754 : 			sizeof (pThreadBlock->wszMountVolume) / 2 - 5);

  0005e	8b 86 20 02 00
	00		 mov	 eax, DWORD PTR [esi+544]
  00064	68 07 01 00 00	 push	 263			; 00000107H
  00069	83 c0 10	 add	 eax, 16			; 00000010H
  0006c	50		 push	 eax
  0006d	ff 75 f8	 push	 DWORD PTR tv375[ebp]
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcsncat
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1755 : 		bDevice = FALSE;

  00079	33 c0		 xor	 eax, eax

; 1756 : 	}
; 1757 : 	else

  0007b	eb 24		 jmp	 SHORT $LN12@VolumeThre
$LN13@VolumeThre:

; 1758 : 	{
; 1759 : 		pThreadBlock->wszMountVolume[0] = 0;

  0007d	8b 4d 08	 mov	 ecx, DWORD PTR _Context$[ebp]
  00080	83 c1 08	 add	 ecx, 8

; 1760 : 		wcsncat (pThreadBlock->wszMountVolume, pThreadBlock->mount->wszVolume,
; 1761 : 			sizeof (pThreadBlock->wszMountVolume) / 2 - 1);

  00083	68 0b 01 00 00	 push	 267			; 0000010bH
  00088	50		 push	 eax
  00089	33 d2		 xor	 edx, edx
  0008b	51		 push	 ecx
  0008c	89 4d f8	 mov	 DWORD PTR tv375[ebp], ecx
  0008f	66 89 11	 mov	 WORD PTR [ecx], dx
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcsncat

; 1762 : 		bDevice = TRUE;

  00098	8b 75 08	 mov	 esi, DWORD PTR _Context$[ebp]
  0009b	33 c0		 xor	 eax, eax
  0009d	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a0	40		 inc	 eax
$LN12@VolumeThre:

; 1763 : 	}
; 1764 : 
; 1765 : 	Dump ("Mount THREAD request for File %ls DriveNumber %d Device = %d\n",
; 1766 : 	      pThreadBlock->wszMountVolume, pThreadBlock->mount->nDosDriveNo, bDevice);
; 1767 : 
; 1768 : 	pThreadBlock->ntCreateStatus = TCOpenVolume (DeviceObject,
; 1769 : 		Extension,
; 1770 : 		pThreadBlock->mount,
; 1771 : 		pThreadBlock->wszMountVolume,
; 1772 : 		bDevice);

  000a1	50		 push	 eax
  000a2	ff 75 f8	 push	 DWORD PTR tv375[ebp]
  000a5	ff b6 20 02 00
	00		 push	 DWORD PTR [esi+544]
  000ab	53		 push	 ebx
  000ac	ff 75 fc	 push	 DWORD PTR _DeviceObject$[ebp]
  000af	e8 00 00 00 00	 call	 _TCOpenVolume@20

; 1773 : 
; 1774 : 	if (!NT_SUCCESS (pThreadBlock->ntCreateStatus) || pThreadBlock->mount->nReturnCode != 0)

  000b4	3b c7		 cmp	 eax, edi
  000b6	89 46 04	 mov	 DWORD PTR [esi+4], eax
  000b9	7c 0a		 jl	 SHORT $LN10@VolumeThre
  000bb	8b 86 20 02 00
	00		 mov	 eax, DWORD PTR [esi+544]
  000c1	39 38		 cmp	 DWORD PTR [eax], edi
  000c3	74 13		 je	 SHORT $LN11@VolumeThre
$LN10@VolumeThre:

; 1775 : 	{
; 1776 : 		KeSetEvent (&Extension->keCreateEvent, 0, FALSE);

  000c5	57		 push	 edi
  000c6	57		 push	 edi
  000c7	8d 43 24	 lea	 eax, DWORD PTR [ebx+36]
  000ca	50		 push	 eax
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 1777 : 		PsTerminateSystemThread (STATUS_SUCCESS);

  000d1	57		 push	 edi
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsTerminateSystemThread@4
$LN11@VolumeThre:

; 1778 : 	}
; 1779 : 
; 1780 : 	// Start IO queue
; 1781 : 	Extension->Queue.IsFilterDevice = FALSE;
; 1782 : 	Extension->Queue.DeviceObject = DeviceObject;

  000d8	8b 4d fc	 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  000db	8d 83 a8 00 00
	00		 lea	 eax, DWORD PTR [ebx+168]
  000e1	89 08		 mov	 DWORD PTR [eax], ecx

; 1783 : 	Extension->Queue.CryptoInfo = Extension->cryptoInfo;

  000e3	8b 4b 60	 mov	 ecx, DWORD PTR [ebx+96]
  000e6	89 8b d0 00 00
	00		 mov	 DWORD PTR [ebx+208], ecx

; 1784 : 	Extension->Queue.HostFileHandle = Extension->hDeviceFile;

  000ec	8b 4b 54	 mov	 ecx, DWORD PTR [ebx+84]
  000ef	89 8b d4 00 00
	00		 mov	 DWORD PTR [ebx+212], ecx

; 1785 : 	Extension->Queue.VirtualDeviceLength = Extension->DiskLength;

  000f5	8b 4b 70	 mov	 ecx, DWORD PTR [ebx+112]
  000f8	89 8b d8 00 00
	00		 mov	 DWORD PTR [ebx+216], ecx
  000fe	8b 4b 74	 mov	 ecx, DWORD PTR [ebx+116]
  00101	89 8b dc 00 00
	00		 mov	 DWORD PTR [ebx+220], ecx

; 1786 : 	Extension->Queue.MaxReadAheadOffset.QuadPart = Extension->HostLength;

  00107	8b 4b 68	 mov	 ecx, DWORD PTR [ebx+104]
  0010a	89 8b e0 01 00
	00		 mov	 DWORD PTR [ebx+480], ecx
  00110	8b 4b 6c	 mov	 ecx, DWORD PTR [ebx+108]
  00113	89 bb e4 00 00
	00		 mov	 DWORD PTR [ebx+228], edi
  00119	89 8b e4 01 00
	00		 mov	 DWORD PTR [ebx+484], ecx

; 1787 : 
; 1788 : 	if (Extension->SecurityClientContextValid)

  0011f	39 bb 90 04 00
	00		 cmp	 DWORD PTR [ebx+1168], edi
  00125	74 0e		 je	 SHORT $LN9@VolumeThre

; 1789 : 		Extension->Queue.SecurityClientContext = &Extension->SecurityClientContext;

  00127	8d 8b 94 04 00
	00		 lea	 ecx, DWORD PTR [ebx+1172]
  0012d	89 8b e0 00 00
	00		 mov	 DWORD PTR [ebx+224], ecx

; 1790 : 	else

  00133	eb 06		 jmp	 SHORT $LN8@VolumeThre
$LN9@VolumeThre:

; 1791 : 		Extension->Queue.SecurityClientContext = NULL;

  00135	89 bb e0 00 00
	00		 mov	 DWORD PTR [ebx+224], edi
$LN8@VolumeThre:

; 1792 : 
; 1793 : 	pThreadBlock->ntCreateStatus = EncryptedIoQueueStart (&Extension->Queue);

  0013b	50		 push	 eax
  0013c	e8 00 00 00 00	 call	 _EncryptedIoQueueStart@4

; 1794 : 
; 1795 : 	if (!NT_SUCCESS (pThreadBlock->ntCreateStatus))

  00141	3b c7		 cmp	 eax, edi
  00143	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00146	7d 28		 jge	 SHORT $LN7@VolumeThre

; 1796 : 	{
; 1797 : 		TCCloseVolume (DeviceObject, Extension);

  00148	53		 push	 ebx
  00149	ff 75 fc	 push	 DWORD PTR _DeviceObject$[ebp]
  0014c	e8 00 00 00 00	 call	 _TCCloseVolume@8

; 1798 : 
; 1799 : 		pThreadBlock->mount->nReturnCode = ERR_OS_ERROR;

  00151	8b 86 20 02 00
	00		 mov	 eax, DWORD PTR [esi+544]

; 1800 : 		KeSetEvent (&Extension->keCreateEvent, 0, FALSE);

  00157	57		 push	 edi
  00158	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
  0015e	57		 push	 edi
  0015f	8d 43 24	 lea	 eax, DWORD PTR [ebx+36]
  00162	50		 push	 eax
  00163	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 1801 : 		PsTerminateSystemThread (STATUS_SUCCESS);

  00169	57		 push	 edi
  0016a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsTerminateSystemThread@4
$LN7@VolumeThre:

; 1802 : 	}
; 1803 : 
; 1804 : 	KeSetEvent (&Extension->keCreateEvent, 0, FALSE);

  00170	57		 push	 edi
  00171	57		 push	 edi
  00172	8d 43 24	 lea	 eax, DWORD PTR [ebx+36]
  00175	50		 push	 eax
  00176	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
  0017c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_@ExfInterlockedRemoveHeadList@8
$LL6@VolumeThre:

; 1805 : 	/* From this point on pThreadBlock cannot be used as it will have been released! */
; 1806 : 	pThreadBlock = NULL;
; 1807 : 
; 1808 : 	for (;;)
; 1809 : 	{
; 1810 : 		/* Wait for a request from the dispatch routines. */
; 1811 : 		KeWaitForSingleObject ((PVOID) & Extension->RequestSemaphore, Executive, KernelMode, FALSE, NULL);

  00182	57		 push	 edi
  00183	57		 push	 edi
  00184	57		 push	 edi
  00185	57		 push	 edi
  00186	8d 43 40	 lea	 eax, DWORD PTR [ebx+64]
  00189	50		 push	 eax
  0018a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 1812 : 
; 1813 : 		for (;;)
; 1814 : 		{
; 1815 : 			PIO_STACK_LOCATION irpSp;
; 1816 : 			PLIST_ENTRY request;
; 1817 : 			PIRP irp;
; 1818 : 
; 1819 : 			request = ExInterlockedRemoveHeadList (&Extension->ListEntry, &Extension->ListSpinLock);

  00190	eb 22		 jmp	 SHORT $LN28@VolumeThre
$LL4@VolumeThre:

; 1820 : 			if (request == NULL)
; 1821 : 				break;
; 1822 : 
; 1823 : 			irp = CONTAINING_RECORD (request, IRP, Tail.Overlay.ListEntry);

  00192	83 c0 a8	 add	 eax, -88		; ffffffa8H

; 1824 : 			irpSp = IoGetCurrentIrpStackLocation (irp);
; 1825 : 
; 1826 : 			ASSERT (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL);
; 1827 : 
; 1828 : 			ProcessVolumeDeviceControlIrp (DeviceObject, Extension, irp);

  00195	50		 push	 eax
  00196	53		 push	 ebx
  00197	ff 75 fc	 push	 DWORD PTR _DeviceObject$[ebp]
  0019a	89 45 08	 mov	 DWORD PTR _irp$30565[ebp], eax
  0019d	e8 00 00 00 00	 call	 _ProcessVolumeDeviceControlIrp@12

; 1829 : 			IoReleaseRemoveLock (&Extension->Queue.RemoveLock, irp);

  001a2	6a 18		 push	 24			; 00000018H
  001a4	ff 75 08	 push	 DWORD PTR _irp$30565[ebp]
  001a7	8d 83 18 01 00
	00		 lea	 eax, DWORD PTR [ebx+280]
  001ad	50		 push	 eax
  001ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12
$LN28@VolumeThre:
  001b4	8d 53 34	 lea	 edx, DWORD PTR [ebx+52]
  001b7	8d 4b 38	 lea	 ecx, DWORD PTR [ebx+56]
  001ba	ff d6		 call	 esi
  001bc	3b c7		 cmp	 eax, edi
  001be	75 d2		 jne	 SHORT $LL4@VolumeThre

; 1830 : 		}
; 1831 : 
; 1832 : 		if (Extension->bThreadShouldQuit)

  001c0	39 7b 1c	 cmp	 DWORD PTR [ebx+28], edi
  001c3	74 bd		 je	 SHORT $LL6@VolumeThre

; 1833 : 		{
; 1834 : 			Dump ("Closing volume\n");
; 1835 : 			EncryptedIoQueueStop (&Extension->Queue);

  001c5	8d 83 a8 00 00
	00		 lea	 eax, DWORD PTR [ebx+168]
  001cb	50		 push	 eax
  001cc	e8 00 00 00 00	 call	 _EncryptedIoQueueStop@4

; 1836 : 
; 1837 : 			TCCloseVolume (DeviceObject, Extension);

  001d1	53		 push	 ebx
  001d2	ff 75 fc	 push	 DWORD PTR _DeviceObject$[ebp]
  001d5	e8 00 00 00 00	 call	 _TCCloseVolume@8

; 1838 : 			PsTerminateSystemThread (STATUS_SUCCESS);

  001da	57		 push	 edi
  001db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsTerminateSystemThread@4
  001e1	eb 9f		 jmp	 SHORT $LL6@VolumeThre
_VolumeThreadProc@4 ENDP
_TEXT	ENDS
PUBLIC	_OnShutdownPending@0
; Function compile flags: /Ogsp
;	COMDAT _OnShutdownPending@0
_TEXT	SEGMENT
_unmount$ = -16						; size = 16
_OnShutdownPending@0 PROC				; COMDAT

; 2109 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 10	 sub	 esp, 16			; 00000010H
  00008	56		 push	 esi
  00009	57		 push	 edi

; 2110 : 	UNMOUNT_STRUCT unmount;
; 2111 : 	memset (&unmount, 0, sizeof (unmount));

  0000a	33 c0		 xor	 eax, eax
  0000c	8d 7d f0	 lea	 edi, DWORD PTR _unmount$[ebp]
  0000f	ab		 stosd
  00010	ab		 stosd
  00011	ab		 stosd
  00012	ab		 stosd

; 2112 : 	unmount.ignoreOpenFiles = TRUE;

  00013	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _unmount$[ebp+4], 1
  0001a	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH
  0001f	33 ff		 xor	 edi, edi
$LL5@OnShutdown:

; 2113 : 
; 2114 : 	while (SendDeviceIoControlRequest (RootDeviceObject, TC_IOCTL_DISMOUNT_ALL_VOLUMES, &unmount, sizeof (unmount), &unmount, sizeof (unmount)) == STATUS_INSUFFICIENT_RESOURCES || unmount.HiddenVolumeProtectionTriggered)

  00021	6a 10		 push	 16			; 00000010H
  00023	8d 45 f0	 lea	 eax, DWORD PTR _unmount$[ebp]
  00026	50		 push	 eax
  00027	6a 10		 push	 16			; 00000010H
  00029	50		 push	 eax
  0002a	68 14 20 22 00	 push	 2236436			; 00222014H
  0002f	ff 35 00 00 00
	00		 push	 DWORD PTR _RootDeviceObject
  00035	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  0003a	3b c6		 cmp	 eax, esi
  0003c	74 05		 je	 SHORT $LN3@OnShutdown
  0003e	39 7d f8	 cmp	 DWORD PTR _unmount$[ebp+8], edi
  00041	74 05		 je	 SHORT $LL2@OnShutdown
$LN3@OnShutdown:

; 2115 : 		unmount.HiddenVolumeProtectionTriggered = FALSE;

  00043	89 7d f8	 mov	 DWORD PTR _unmount$[ebp+8], edi
  00046	eb d9		 jmp	 SHORT $LL5@OnShutdown
$LL2@OnShutdown:

; 2116 : 
; 2117 : 	while (SendDeviceIoControlRequest (RootDeviceObject, TC_IOCTL_WIPE_PASSWORD_CACHE, NULL, 0, NULL, 0) == STATUS_INSUFFICIENT_RESOURCES);

  00048	57		 push	 edi
  00049	57		 push	 edi
  0004a	57		 push	 edi
  0004b	57		 push	 edi
  0004c	68 30 20 22 00	 push	 2236464			; 00222030H
  00051	ff 35 00 00 00
	00		 push	 DWORD PTR _RootDeviceObject
  00057	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  0005c	3b c6		 cmp	 eax, esi
  0005e	74 e8		 je	 SHORT $LL2@OnShutdown
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi

; 2118 : }

  00062	c9		 leave
  00063	c3		 ret	 0
_OnShutdownPending@0 ENDP
_TEXT	ENDS
PUBLIC	_ProbeRealDriveSize@8
EXTRN	__imp__KeQueryInterruptTime@0:PROC
; Function compile flags: /Ogsp
;	COMDAT _ProbeRealDriveSize@8
_TEXT	SEGMENT
_startTime$ = -20					; size = 8
_sysLength$ = -12					; size = 8
_sectorBuffer$ = -4					; size = 4
_driveDeviceObject$ = 8					; size = 4
_driveSize$ = 12					; size = 4
_ProbeRealDriveSize@8 PROC				; COMDAT

; 2238 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 14	 sub	 esp, 20			; 00000014H

; 2239 : 	NTSTATUS status;
; 2240 : 	LARGE_INTEGER sysLength;
; 2241 : 	LARGE_INTEGER offset;
; 2242 : 	byte *sectorBuffer;
; 2243 : 	ULONGLONG startTime;
; 2244 : 
; 2245 : 	if (!UserCanAccessDriveDevice())

  00008	e8 00 00 00 00	 call	 _UserCanAccessDriveDevice@0
  0000d	85 c0		 test	 eax, eax
  0000f	75 07		 jne	 SHORT $LN9@ProbeRealD

; 2246 : 		return STATUS_ACCESS_DENIED;

  00011	b8 22 00 00 c0	 mov	 eax, -1073741790	; c0000022H
  00016	eb 24		 jmp	 SHORT $LN4@ProbeRealD
$LN9@ProbeRealD:
  00018	56		 push	 esi
  00019	57		 push	 edi

; 2247 : 
; 2248 : 	sectorBuffer = TCalloc (TC_SECTOR_SIZE_BIOS);

  0001a	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0001f	be 00 02 00 00	 mov	 esi, 512		; 00000200H
  00024	56		 push	 esi
  00025	33 ff		 xor	 edi, edi
  00027	57		 push	 edi
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0002e	89 45 fc	 mov	 DWORD PTR _sectorBuffer$[ebp], eax

; 2249 : 	if (!sectorBuffer)

  00031	3b c7		 cmp	 eax, edi
  00033	75 0b		 jne	 SHORT $LN8@ProbeRealD

; 2250 : 		return STATUS_INSUFFICIENT_RESOURCES;

  00035	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
$LN19@ProbeRealD:
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
$LN4@ProbeRealD:

; 2282 : 			TCfree (sectorBuffer);
; 2283 : 			return STATUS_TIMEOUT;
; 2284 : 		}
; 2285 : 	}
; 2286 : }

  0003c	c9		 leave
  0003d	c2 08 00	 ret	 8
$LN8@ProbeRealD:
  00040	53		 push	 ebx

; 2251 : 
; 2252 : 	status = SendDeviceIoControlRequest (driveDeviceObject, IOCTL_DISK_GET_LENGTH_INFO,
; 2253 : 		NULL, 0, &sysLength, sizeof (sysLength));

  00041	6a 08		 push	 8
  00043	8d 45 f4	 lea	 eax, DWORD PTR _sysLength$[ebp]
  00046	50		 push	 eax
  00047	57		 push	 edi
  00048	57		 push	 edi
  00049	68 5c 40 07 00	 push	 475228			; 0007405cH
  0004e	ff 75 08	 push	 DWORD PTR _driveDeviceObject$[ebp]
  00051	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24

; 2254 : 
; 2255 : 	if (!NT_SUCCESS (status))

  00056	3b c7		 cmp	 eax, edi
  00058	7d 15		 jge	 SHORT $LN7@ProbeRealD
  0005a	8b f0		 mov	 esi, eax
$LN16@ProbeRealD:

; 2256 : 	{
; 2257 : 		Dump ("Failed to get drive size - error %x\n", status);
; 2258 : 		TCfree (sectorBuffer);

  0005c	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00061	ff 75 fc	 push	 DWORD PTR _sectorBuffer$[ebp]
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 2259 : 		return status;

  0006a	8b c6		 mov	 eax, esi
  0006c	5b		 pop	 ebx
  0006d	eb cb		 jmp	 SHORT $LN19@ProbeRealD
$LN7@ProbeRealD:

; 2260 : 	}
; 2261 : 
; 2262 : 	startTime = KeQueryInterruptTime ();

  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeQueryInterruptTime@0

; 2263 : 	for (offset.QuadPart = sysLength.QuadPart; ; offset.QuadPart += TC_SECTOR_SIZE_BIOS)

  00075	8b 7d f4	 mov	 edi, DWORD PTR _sysLength$[ebp]
  00078	8b 5d f8	 mov	 ebx, DWORD PTR _sysLength$[ebp+4]
  0007b	89 45 ec	 mov	 DWORD PTR _startTime$[ebp], eax
  0007e	89 55 f0	 mov	 DWORD PTR _startTime$[ebp+4], edx
$LL6@ProbeRealD:

; 2264 : 	{
; 2265 : 		status = TCReadDevice (driveDeviceObject, sectorBuffer, offset, TC_SECTOR_SIZE_BIOS);

  00081	56		 push	 esi
  00082	53		 push	 ebx
  00083	57		 push	 edi
  00084	ff 75 fc	 push	 DWORD PTR _sectorBuffer$[ebp]
  00087	ff 75 08	 push	 DWORD PTR _driveDeviceObject$[ebp]
  0008a	e8 00 00 00 00	 call	 _TCReadDevice@20

; 2266 : 		
; 2267 : 		if (NT_SUCCESS (status))

  0008f	85 c0		 test	 eax, eax
  00091	7c 32		 jl	 SHORT $LN18@ProbeRealD

; 2268 : 			status = TCWriteDevice (driveDeviceObject, sectorBuffer, offset, TC_SECTOR_SIZE_BIOS);

  00093	56		 push	 esi
  00094	53		 push	 ebx
  00095	57		 push	 edi
  00096	ff 75 fc	 push	 DWORD PTR _sectorBuffer$[ebp]
  00099	ff 75 08	 push	 DWORD PTR _driveDeviceObject$[ebp]
  0009c	e8 00 00 00 00	 call	 _TCWriteDevice@20

; 2269 : 
; 2270 : 		if (!NT_SUCCESS (status))

  000a1	85 c0		 test	 eax, eax
  000a3	7c 20		 jl	 SHORT $LN18@ProbeRealD

; 2273 : 			Dump ("Real drive size = %I64d bytes (%I64d hidden)\n", driveSize->QuadPart, driveSize->QuadPart - sysLength.QuadPart);
; 2274 : 			TCfree (sectorBuffer);
; 2275 : 			return STATUS_SUCCESS;
; 2276 : 		}
; 2277 : 
; 2278 : 		if (KeQueryInterruptTime() - startTime > 3ULL * 60 * 1000 * 1000 * 10)

  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeQueryInterruptTime@0
  000ab	2b 45 ec	 sub	 eax, DWORD PTR _startTime$[ebp]
  000ae	1b 55 f0	 sbb	 edx, DWORD PTR _startTime$[ebp+4]
  000b1	85 d2		 test	 edx, edx
  000b3	77 1c		 ja	 SHORT $LN15@ProbeRealD
  000b5	72 07		 jb	 SHORT $LN17@ProbeRealD
  000b7	3d 00 d2 49 6b	 cmp	 eax, 1800000000		; 6b49d200H
  000bc	77 13		 ja	 SHORT $LN15@ProbeRealD
$LN17@ProbeRealD:

; 2263 : 	for (offset.QuadPart = sysLength.QuadPart; ; offset.QuadPart += TC_SECTOR_SIZE_BIOS)

  000be	03 fe		 add	 edi, esi
  000c0	83 d3 00	 adc	 ebx, 0
  000c3	eb bc		 jmp	 SHORT $LL6@ProbeRealD
$LN18@ProbeRealD:

; 2271 : 		{
; 2272 : 			driveSize->QuadPart = offset.QuadPart;

  000c5	8b 45 0c	 mov	 eax, DWORD PTR _driveSize$[ebp]
  000c8	89 38		 mov	 DWORD PTR [eax], edi
  000ca	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  000cd	33 f6		 xor	 esi, esi
  000cf	eb 8b		 jmp	 SHORT $LN16@ProbeRealD
$LN15@ProbeRealD:

; 2279 : 		{
; 2280 : 			// Abort if probing for more than 3 minutes
; 2281 : 			driveSize->QuadPart = sysLength.QuadPart;

  000d1	8b 4d f4	 mov	 ecx, DWORD PTR _sysLength$[ebp]
  000d4	8b 45 0c	 mov	 eax, DWORD PTR _driveSize$[ebp]
  000d7	89 08		 mov	 DWORD PTR [eax], ecx
  000d9	8b 4d f8	 mov	 ecx, DWORD PTR _sysLength$[ebp+4]
  000dc	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  000df	be 02 01 00 00	 mov	 esi, 258		; 00000102H
  000e4	e9 73 ff ff ff	 jmp	 $LN16@ProbeRealD
_ProbeRealDriveSize@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@FNODOBFM@			;  ?? ::FNODOBFM::`string'
PUBLIC	_UnmountDevice@12
EXTRN	__imp__IoReleaseRemoveLockAndWaitEx@12:PROC
EXTRN	__imp__IoAcquireRemoveLockEx@20:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_00CNPNBAHC@?$AA@FNODOBFM@ DB 00H			;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
text$s	ENDS
;	COMDAT _UnmountDevice@12
_TEXT	SEGMENT
_ntfsData$30971 = -108					; size = 96
_dismountRetry$30969 = -12				; size = 4
_volumeHandle$ = -8					; size = 4
_volumeFileObject$ = -4					; size = 4
_unmountRequest$ = 8					; size = 4
_deviceObject$ = 12					; size = 4
_ignoreOpenFiles$ = 16					; size = 4
_UnmountDevice@12 PROC					; COMDAT

; 2646 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 2647 : 	PEXTENSION extension = deviceObject->DeviceExtension;

  00005	8b 45 0c	 mov	 eax, DWORD PTR _deviceObject$[ebp]
  00008	83 ec 6c	 sub	 esp, 108		; 0000006cH
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	8b 70 28	 mov	 esi, DWORD PTR [eax+40]
  00010	57		 push	 edi

; 2648 : 	NTSTATUS ntStatus;
; 2649 : 	HANDLE volumeHandle;
; 2650 : 	PFILE_OBJECT volumeFileObject;
; 2651 : 
; 2652 : 	Dump ("UnmountDevice %d\n", extension->nDosDriveNo);
; 2653 : 
; 2654 : 	ntStatus = TCOpenFsVolume (extension, &volumeHandle, &volumeFileObject);

  00011	8d 45 fc	 lea	 eax, DWORD PTR _volumeFileObject$[ebp]
  00014	50		 push	 eax
  00015	8d 45 f8	 lea	 eax, DWORD PTR _volumeHandle$[ebp]
  00018	50		 push	 eax
  00019	56		 push	 esi
  0001a	e8 00 00 00 00	 call	 _TCOpenFsVolume@12

; 2655 : 
; 2656 : 	if (NT_SUCCESS (ntStatus))

  0001f	33 db		 xor	 ebx, ebx
  00021	43		 inc	 ebx
  00022	85 c0		 test	 eax, eax
  00024	0f 8c 9a 00 00
	00		 jl	 $LN16@UnmountDev

; 2657 : 	{
; 2658 : 		int dismountRetry;
; 2659 : 
; 2660 : 		// Dismounting a writable NTFS filesystem prevents the driver from being unloaded on Windows 7
; 2661 : 		if (IsOSAtLeast (WIN_7) && !extension->bReadOnly)

  0002a	6a 0d		 push	 13			; 0000000dH
  0002c	e8 00 00 00 00	 call	 _IsOSAtLeast@4
  00031	33 ff		 xor	 edi, edi
  00033	85 c0		 test	 eax, eax
  00035	74 27		 je	 SHORT $LN14@UnmountDev
  00037	39 be 48 02 00
	00		 cmp	 DWORD PTR [esi+584], edi
  0003d	75 1f		 jne	 SHORT $LN14@UnmountDev

; 2662 : 		{
; 2663 : 			NTFS_VOLUME_DATA_BUFFER ntfsData;
; 2664 : 
; 2665 : 			if (NT_SUCCESS (TCFsctlCall (volumeFileObject, FSCTL_GET_NTFS_VOLUME_DATA, NULL, 0, &ntfsData, sizeof (ntfsData))))

  0003f	6a 60		 push	 96			; 00000060H
  00041	8d 45 94	 lea	 eax, DWORD PTR _ntfsData$30971[ebp]
  00044	50		 push	 eax
  00045	57		 push	 edi
  00046	57		 push	 edi
  00047	68 64 00 09 00	 push	 589924			; 00090064H
  0004c	ff 75 fc	 push	 DWORD PTR _volumeFileObject$[ebp]
  0004f	e8 00 00 00 00	 call	 _TCFsctlCall@24
  00054	85 c0		 test	 eax, eax
  00056	7c 06		 jl	 SHORT $LN14@UnmountDev

; 2666 : 				DriverUnloadDisabled = TRUE;

  00058	89 1d 00 00 00
	00		 mov	 DWORD PTR _DriverUnloadDisabled, ebx
$LN14@UnmountDev:

; 2667 : 		}
; 2668 : 
; 2669 : 		// Lock volume
; 2670 : 		ntStatus = TCFsctlCall (volumeFileObject, FSCTL_LOCK_VOLUME, NULL, 0, NULL, 0);

  0005e	57		 push	 edi
  0005f	57		 push	 edi
  00060	57		 push	 edi
  00061	57		 push	 edi
  00062	68 18 00 09 00	 push	 589848			; 00090018H
  00067	ff 75 fc	 push	 DWORD PTR _volumeFileObject$[ebp]
  0006a	e8 00 00 00 00	 call	 _TCFsctlCall@24

; 2671 : 		Dump ("FSCTL_LOCK_VOLUME returned %X\n", ntStatus);
; 2672 : 
; 2673 : 		if (!NT_SUCCESS (ntStatus) && !ignoreOpenFiles)

  0006f	85 c0		 test	 eax, eax
  00071	7d 18		 jge	 SHORT $LN13@UnmountDev
  00073	39 7d 10	 cmp	 DWORD PTR _ignoreOpenFiles$[ebp], edi
  00076	75 13		 jne	 SHORT $LN13@UnmountDev
$LN23@UnmountDev:

; 2674 : 		{
; 2675 : 			TCCloseFsVolume (volumeHandle, volumeFileObject);

  00078	ff 75 fc	 push	 DWORD PTR _volumeFileObject$[ebp]
  0007b	ff 75 f8	 push	 DWORD PTR _volumeHandle$[ebp]
  0007e	e8 00 00 00 00	 call	 _TCCloseFsVolume@8
$LN26@UnmountDev:

; 2676 : 			return ERR_FILES_OPEN;

  00083	6a 06		 push	 6
  00085	58		 pop	 eax
  00086	e9 be 00 00 00	 jmp	 $LN17@UnmountDev
$LN13@UnmountDev:

; 2677 : 		}
; 2678 : 
; 2679 : 		// Dismount volume
; 2680 : 		for (dismountRetry = 0; dismountRetry < 200; ++dismountRetry)

  0008b	89 7d f4	 mov	 DWORD PTR _dismountRetry$30969[ebp], edi
$LL12@UnmountDev:

; 2681 : 		{
; 2682 : 			ntStatus = TCFsctlCall (volumeFileObject, FSCTL_DISMOUNT_VOLUME, NULL, 0, NULL, 0);

  0008e	57		 push	 edi
  0008f	57		 push	 edi
  00090	57		 push	 edi
  00091	57		 push	 edi
  00092	68 20 00 09 00	 push	 589856			; 00090020H
  00097	ff 75 fc	 push	 DWORD PTR _volumeFileObject$[ebp]
  0009a	e8 00 00 00 00	 call	 _TCFsctlCall@24

; 2683 : 			Dump ("FSCTL_DISMOUNT_VOLUME returned %X\n", ntStatus);
; 2684 : 
; 2685 : 			if (NT_SUCCESS (ntStatus) || ntStatus == STATUS_VOLUME_DISMOUNTED)

  0009f	3b c7		 cmp	 eax, edi
  000a1	7d 2b		 jge	 SHORT $LN4@UnmountDev
  000a3	3d 6e 02 00 c0	 cmp	 eax, -1073741202	; c000026eH
  000a8	74 24		 je	 SHORT $LN4@UnmountDev

; 2686 : 				break;
; 2687 : 
; 2688 : 			if (!ignoreOpenFiles)

  000aa	39 7d 10	 cmp	 DWORD PTR _ignoreOpenFiles$[ebp], edi
  000ad	74 c9		 je	 SHORT $LN23@UnmountDev

; 2689 : 			{
; 2690 : 				TCCloseFsVolume (volumeHandle, volumeFileObject);
; 2691 : 				return ERR_FILES_OPEN;
; 2692 : 			}
; 2693 : 
; 2694 : 			TCSleep (100);

  000af	6a 64		 push	 100			; 00000064H
  000b1	e8 00 00 00 00	 call	 _TCSleep@4
  000b6	ff 45 f4	 inc	 DWORD PTR _dismountRetry$30969[ebp]
  000b9	81 7d f4 c8 00
	00 00		 cmp	 DWORD PTR _dismountRetry$30969[ebp], 200 ; 000000c8H
  000c0	7c cc		 jl	 SHORT $LL12@UnmountDev

; 2686 : 				break;
; 2687 : 
; 2688 : 			if (!ignoreOpenFiles)

  000c2	eb 0a		 jmp	 SHORT $LN4@UnmountDev
$LN16@UnmountDev:

; 2695 : 		}
; 2696 : 	}
; 2697 : 	else 
; 2698 : 	{
; 2699 : 		// Volume cannot be opened => force dismount if allowed
; 2700 : 		if (!ignoreOpenFiles)

  000c4	33 ff		 xor	 edi, edi
  000c6	39 7d 10	 cmp	 DWORD PTR _ignoreOpenFiles$[ebp], edi

; 2701 : 			return ERR_FILES_OPEN;

  000c9	74 b8		 je	 SHORT $LN26@UnmountDev

; 2702 : 		else
; 2703 : 			volumeHandle = NULL;

  000cb	89 7d f8	 mov	 DWORD PTR _volumeHandle$[ebp], edi
$LN4@UnmountDev:

; 2704 : 	}
; 2705 : 
; 2706 : 	if (extension->bMountManager)

  000ce	39 be 58 02 00
	00		 cmp	 DWORD PTR [esi+600], edi
  000d4	74 08		 je	 SHORT $LN3@UnmountDev

; 2707 : 		MountManagerUnmount (extension->nDosDriveNo);

  000d6	ff 76 14	 push	 DWORD PTR [esi+20]
  000d9	e8 00 00 00 00	 call	 _MountManagerUnmount@4
$LN3@UnmountDev:

; 2708 : 
; 2709 : 	// We always remove symbolic link as mount manager might fail to do so
; 2710 : 	RemoveDriveLink (extension->nDosDriveNo);

  000de	ff 76 14	 push	 DWORD PTR [esi+20]
  000e1	e8 00 00 00 00	 call	 _RemoveDriveLink@4

; 2711 : 
; 2712 : 	extension->bShuttingDown = TRUE;
; 2713 : 
; 2714 : 	ntStatus = IoAcquireRemoveLock (&extension->Queue.RemoveLock, NULL);

  000e6	6a 18		 push	 24			; 00000018H
  000e8	53		 push	 ebx
  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@FNODOBFM@
  000ee	89 5e 18	 mov	 DWORD PTR [esi+24], ebx
  000f1	57		 push	 edi
  000f2	81 c6 18 01 00
	00		 add	 esi, 280		; 00000118H
  000f8	56		 push	 esi
  000f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAcquireRemoveLockEx@20

; 2715 : 	ASSERT (NT_SUCCESS (ntStatus));
; 2716 : 	IoReleaseRemoveLockAndWait (&extension->Queue.RemoveLock, NULL);

  000ff	6a 18		 push	 24			; 00000018H
  00101	57		 push	 edi
  00102	56		 push	 esi
  00103	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockAndWaitEx@12

; 2717 : 
; 2718 : 	if (volumeHandle != NULL)

  00109	39 7d f8	 cmp	 DWORD PTR _volumeHandle$[ebp], edi
  0010c	74 0b		 je	 SHORT $LN2@UnmountDev

; 2719 : 		TCCloseFsVolume (volumeHandle, volumeFileObject);

  0010e	ff 75 fc	 push	 DWORD PTR _volumeFileObject$[ebp]
  00111	ff 75 f8	 push	 DWORD PTR _volumeHandle$[ebp]
  00114	e8 00 00 00 00	 call	 _TCCloseFsVolume@8
$LN2@UnmountDev:

; 2720 : 
; 2721 : 	if (unmountRequest)

  00119	8b 55 08	 mov	 edx, DWORD PTR _unmountRequest$[ebp]

; 2722 : 	{
; 2723 : 		PCRYPTO_INFO cryptoInfo = ((PEXTENSION) deviceObject->DeviceExtension)->cryptoInfo;

  0011c	8b 4d 0c	 mov	 ecx, DWORD PTR _deviceObject$[ebp]
  0011f	3b d7		 cmp	 edx, edi
  00121	74 1b		 je	 SHORT $LN1@UnmountDev
  00123	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00126	8b 40 60	 mov	 eax, DWORD PTR [eax+96]

; 2724 : 		unmountRequest->HiddenVolumeProtectionTriggered = (cryptoInfo->bProtectHiddenVolume && cryptoInfo->bHiddenVolProtectionAction);

  00129	39 b8 00 44 00
	00		 cmp	 DWORD PTR [eax+17408], edi
  0012f	74 0a		 je	 SHORT $LN19@UnmountDev
  00131	39 b8 04 44 00
	00		 cmp	 DWORD PTR [eax+17412], edi
  00137	74 02		 je	 SHORT $LN19@UnmountDev
  00139	8b fb		 mov	 edi, ebx
$LN19@UnmountDev:
  0013b	89 7a 08	 mov	 DWORD PTR [edx+8], edi
$LN1@UnmountDev:

; 2725 : 	}
; 2726 : 
; 2727 : 	TCDeleteDeviceObject (deviceObject, (PEXTENSION) deviceObject->DeviceExtension);

  0013e	ff 71 28	 push	 DWORD PTR [ecx+40]
  00141	51		 push	 ecx
  00142	e8 00 00 00 00	 call	 _TCDeleteDeviceObject@8

; 2728 : 	return 0;

  00147	33 c0		 xor	 eax, eax
$LN17@UnmountDev:
  00149	5f		 pop	 edi
  0014a	5e		 pop	 esi
  0014b	5b		 pop	 ebx

; 2729 : }

  0014c	c9		 leave
  0014d	c2 0c 00	 ret	 12			; 0000000cH
_UnmountDevice@12 ENDP
_TEXT	ENDS
PUBLIC	_UnmountAllDevices@8
; Function compile flags: /Ogsp
;	COMDAT _UnmountAllDevices@8
_TEXT	SEGMENT
_status$ = -4						; size = 4
_unmountRequest$ = 8					; size = 4
_ignoreOpenFiles$ = 12					; size = 4
_UnmountAllDevices@8 PROC				; COMDAT

; 2757 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 2758 : 	NTSTATUS status = 0;
; 2759 : 	PDEVICE_OBJECT ListDevice;
; 2760 : 	int maxUniqueId = LastUniqueVolumeId;
; 2761 : 
; 2762 : 	Dump ("Unmounting all volumes\n");
; 2763 : 
; 2764 : 	if (unmountRequest)

  00006	8b 45 08	 mov	 eax, DWORD PTR _unmountRequest$[ebp]
  00009	83 65 fc 00	 and	 DWORD PTR _status$[ebp], 0
  0000d	53		 push	 ebx
  0000e	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _LastUniqueVolumeId
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	85 c0		 test	 eax, eax
  00018	74 04		 je	 SHORT $LL5@UnmountAll

; 2765 : 		unmountRequest->HiddenVolumeProtectionTriggered = FALSE;

  0001a	83 60 08 00	 and	 DWORD PTR [eax+8], 0
$LL5@UnmountAll:

; 2766 : 
; 2767 : 	// Dismount volumes in the reverse order they were mounted to properly dismount nested volumes
; 2768 : 	while ((ListDevice = FindVolumeWithHighestUniqueId (maxUniqueId)) != NULL)

  0001e	33 ff		 xor	 edi, edi
  00020	83 ca ff	 or	 edx, -1
  00023	33 f6		 xor	 esi, esi
$LL28@UnmountAll:
  00025	56		 push	 esi
  00026	e8 00 00 00 00	 call	 _GetVirtualVolumeDeviceObject@4
  0002b	85 c0		 test	 eax, eax
  0002d	74 12		 je	 SHORT $LN14@UnmountAll
  0002f	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00032	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00035	3b ca		 cmp	 ecx, edx
  00037	7e 08		 jle	 SHORT $LN14@UnmountAll
  00039	3b cb		 cmp	 ecx, ebx
  0003b	7f 04		 jg	 SHORT $LN14@UnmountAll
  0003d	8b d1		 mov	 edx, ecx
  0003f	8b f8		 mov	 edi, eax
$LN14@UnmountAll:
  00041	46		 inc	 esi
  00042	83 fe 19	 cmp	 esi, 25			; 00000019H
  00045	7e de		 jle	 SHORT $LL28@UnmountAll
  00047	85 ff		 test	 edi, edi
  00049	74 3d		 je	 SHORT $LN20@UnmountAll

; 2769 : 	{
; 2770 : 		PEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;

  0004b	8b 77 28	 mov	 esi, DWORD PTR [edi+40]

; 2771 : 		maxUniqueId = ListExtension->UniqueVolumeId - 1;

  0004e	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]

; 2772 : 
; 2773 : 		if (IsVolumeAccessibleByCurrentUser (ListExtension))

  00051	56		 push	 esi
  00052	4b		 dec	 ebx
  00053	e8 00 00 00 00	 call	 _IsVolumeAccessibleByCurrentUser@4
  00058	85 c0		 test	 eax, eax
  0005a	74 c2		 je	 SHORT $LL5@UnmountAll

; 2774 : 		{
; 2775 : 			NTSTATUS ntStatus;
; 2776 : 
; 2777 : 			if (unmountRequest)

  0005c	8b 45 08	 mov	 eax, DWORD PTR _unmountRequest$[ebp]
  0005f	85 c0		 test	 eax, eax
  00061	74 05		 je	 SHORT $LN2@UnmountAll

; 2778 : 				unmountRequest->nDosDriveNo = ListExtension->nDosDriveNo;

  00063	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00066	89 08		 mov	 DWORD PTR [eax], ecx
$LN2@UnmountAll:

; 2779 : 
; 2780 : 			ntStatus = UnmountDevice (unmountRequest, ListDevice, ignoreOpenFiles);

  00068	ff 75 0c	 push	 DWORD PTR _ignoreOpenFiles$[ebp]
  0006b	57		 push	 edi
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 _UnmountDevice@12

; 2781 : 			status = ntStatus == 0 ? status : ntStatus;

  00072	85 c0		 test	 eax, eax
  00074	74 03		 je	 SHORT $LN10@UnmountAll
  00076	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax
$LN10@UnmountAll:

; 2782 : 
; 2783 : 			if (unmountRequest && unmountRequest->HiddenVolumeProtectionTriggered)

  00079	83 7d 08 00	 cmp	 DWORD PTR _unmountRequest$[ebp], 0
  0007d	74 9f		 je	 SHORT $LL5@UnmountAll
  0007f	8b 45 08	 mov	 eax, DWORD PTR _unmountRequest$[ebp]
  00082	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0

; 2784 : 				break;
; 2785 : 		}
; 2786 : 	}

  00086	74 96		 je	 SHORT $LL5@UnmountAll
$LN20@UnmountAll:

; 2787 : 
; 2788 : 	return status;

  00088	8b 45 fc	 mov	 eax, DWORD PTR _status$[ebp]
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx

; 2789 : }

  0008e	c9		 leave
  0008f	c2 08 00	 ret	 8
_UnmountAllDevices@8 ENDP
_TEXT	ENDS
PUBLIC	_TCStartVolumeThread@12
EXTRN	__imp__SeCreateClientSecurity@16:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCStartVolumeThread@12
_TEXT	SEGMENT
_threadObjAttributes$ = -40				; size = 24
_qos$ = -16						; size = 12
_hThread$ = -4						; size = 4
_ntStatus$ = 8						; size = 4
_DeviceObject$ = 8					; size = 4
_Extension$ = 12					; size = 4
_mount$ = 16						; size = 4
_TCStartVolumeThread@12 PROC				; COMDAT

; 1611 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 28	 sub	 esp, 40			; 00000028H
  00008	53		 push	 ebx
  00009	57		 push	 edi

; 1612 : 	PTHREAD_BLOCK pThreadBlock = TCalloc (sizeof (THREAD_BLOCK));

  0000a	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0000f	68 24 02 00 00	 push	 548			; 00000224H
  00014	33 db		 xor	 ebx, ebx
  00016	53		 push	 ebx
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0001d	8b f8		 mov	 edi, eax

; 1613 : 	HANDLE hThread;
; 1614 : 	NTSTATUS ntStatus;
; 1615 : 	OBJECT_ATTRIBUTES threadObjAttributes;
; 1616 : 	SECURITY_QUALITY_OF_SERVICE qos;
; 1617 : 
; 1618 : 	Dump ("Starting thread...\n");
; 1619 : 
; 1620 : 	if (pThreadBlock == NULL)

  0001f	3b fb		 cmp	 edi, ebx
  00021	75 0a		 jne	 SHORT $LN5@TCStartVol

; 1621 : 	{
; 1622 : 		return STATUS_INSUFFICIENT_RESOURCES;

  00023	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  00028	e9 de 00 00 00	 jmp	 $LN6@TCStartVol
$LN5@TCStartVol:

; 1623 : 	}
; 1624 : 	else
; 1625 : 	{
; 1626 : 		pThreadBlock->DeviceObject = DeviceObject;

  0002d	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00030	89 07		 mov	 DWORD PTR [edi], eax

; 1627 : 		pThreadBlock->mount = mount;

  00032	8b 45 10	 mov	 eax, DWORD PTR _mount$[ebp]
  00035	89 87 20 02 00
	00		 mov	 DWORD PTR [edi+544], eax
  0003b	56		 push	 esi

; 1628 : 	}
; 1629 : 
; 1630 : 	qos.Length = sizeof (qos);

  0003c	c7 45 f0 0c 00
	00 00		 mov	 DWORD PTR _qos$[ebp], 12 ; 0000000cH

; 1631 : 	qos.ContextTrackingMode = SECURITY_STATIC_TRACKING;

  00043	88 5d f8	 mov	 BYTE PTR _qos$[ebp+8], bl

; 1632 : 	qos.EffectiveOnly = TRUE;

  00046	c6 45 f9 01	 mov	 BYTE PTR _qos$[ebp+9], 1

; 1633 : 	qos.ImpersonationLevel = SecurityImpersonation;

  0004a	c7 45 f4 02 00
	00 00		 mov	 DWORD PTR _qos$[ebp+4], 2

; 1634 : 
; 1635 : 	ntStatus = SeCreateClientSecurity (PsGetCurrentThread(), &qos, FALSE, &Extension->SecurityClientContext);

  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeGetCurrentThread@0
  00057	8b 75 0c	 mov	 esi, DWORD PTR _Extension$[ebp]
  0005a	8d 8e 94 04 00
	00		 lea	 ecx, DWORD PTR [esi+1172]
  00060	51		 push	 ecx
  00061	53		 push	 ebx
  00062	8d 4d f0	 lea	 ecx, DWORD PTR _qos$[ebp]
  00065	51		 push	 ecx
  00066	50		 push	 eax
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeCreateClientSecurity@16

; 1636 : 	if (!NT_SUCCESS (ntStatus))

  0006d	3b c3		 cmp	 eax, ebx
  0006f	89 45 08	 mov	 DWORD PTR _ntStatus$[ebp], eax
  00072	0f 8c 83 00 00
	00		 jl	 $ret$30492

; 1637 : 		goto ret;
; 1638 : 
; 1639 : 	Extension->SecurityClientContextValid = TRUE;
; 1640 : 
; 1641 : 	Extension->bThreadShouldQuit = FALSE;
; 1642 : 
; 1643 : 	InitializeObjectAttributes (&threadObjAttributes, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);
; 1644 : 
; 1645 : 	ntStatus = PsCreateSystemThread (&hThread,
; 1646 : 					 THREAD_ALL_ACCESS,
; 1647 : 					 &threadObjAttributes,
; 1648 : 					 NULL,
; 1649 : 					 NULL,
; 1650 : 					 VolumeThreadProc,
; 1651 : 					 pThreadBlock);

  00078	57		 push	 edi
  00079	68 00 00 00 00	 push	 OFFSET _VolumeThreadProc@4
  0007e	53		 push	 ebx
  0007f	53		 push	 ebx
  00080	8d 45 d8	 lea	 eax, DWORD PTR _threadObjAttributes$[ebp]
  00083	50		 push	 eax
  00084	68 ff 03 1f 00	 push	 2032639			; 001f03ffH
  00089	8d 45 fc	 lea	 eax, DWORD PTR _hThread$[ebp]
  0008c	50		 push	 eax
  0008d	c7 86 90 04 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+1168], 1
  00097	89 5e 1c	 mov	 DWORD PTR [esi+28], ebx
  0009a	c7 45 d8 18 00
	00 00		 mov	 DWORD PTR _threadObjAttributes$[ebp], 24 ; 00000018H
  000a1	89 5d dc	 mov	 DWORD PTR _threadObjAttributes$[ebp+4], ebx
  000a4	c7 45 e4 00 02
	00 00		 mov	 DWORD PTR _threadObjAttributes$[ebp+12], 512 ; 00000200H
  000ab	89 5d e0	 mov	 DWORD PTR _threadObjAttributes$[ebp+8], ebx
  000ae	89 5d e8	 mov	 DWORD PTR _threadObjAttributes$[ebp+16], ebx
  000b1	89 5d ec	 mov	 DWORD PTR _threadObjAttributes$[ebp+20], ebx
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsCreateSystemThread@28

; 1652 : 
; 1653 : 	if (!NT_SUCCESS (ntStatus))

  000ba	3b c3		 cmp	 eax, ebx
  000bc	89 45 08	 mov	 DWORD PTR _ntStatus$[ebp], eax
  000bf	7c 3a		 jl	 SHORT $ret$30492

; 1654 : 	{
; 1655 : 		Dump ("PsCreateSystemThread Failed END\n");
; 1656 : 		goto ret;
; 1657 : 	}
; 1658 : 
; 1659 : 	ntStatus = ObReferenceObjectByHandle (hThread,
; 1660 : 				   THREAD_ALL_ACCESS,
; 1661 : 				   NULL,
; 1662 : 				   KernelMode,
; 1663 : 				   &Extension->peThread,
; 1664 : 				   NULL);

  000c1	53		 push	 ebx
  000c2	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  000c5	50		 push	 eax
  000c6	53		 push	 ebx
  000c7	53		 push	 ebx
  000c8	68 ff 03 1f 00	 push	 2032639			; 001f03ffH
  000cd	ff 75 fc	 push	 DWORD PTR _hThread$[ebp]
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ObReferenceObjectByHandle@24

; 1665 : 
; 1666 : 	ZwClose (hThread);

  000d6	ff 75 fc	 push	 DWORD PTR _hThread$[ebp]
  000d9	89 45 08	 mov	 DWORD PTR _ntStatus$[ebp], eax
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 1667 : 
; 1668 : 	if (!NT_SUCCESS (ntStatus))

  000e2	39 5d 08	 cmp	 DWORD PTR _ntStatus$[ebp], ebx
  000e5	7c 14		 jl	 SHORT $ret$30492

; 1669 : 		goto ret;
; 1670 : 
; 1671 : 	Dump ("Waiting for thread to initialize...\n");
; 1672 : 
; 1673 : 	KeWaitForSingleObject (&Extension->keCreateEvent,
; 1674 : 			       Executive,
; 1675 : 			       KernelMode,
; 1676 : 			       FALSE,
; 1677 : 			       NULL);

  000e7	53		 push	 ebx
  000e8	53		 push	 ebx
  000e9	53		 push	 ebx
  000ea	53		 push	 ebx
  000eb	83 c6 24	 add	 esi, 36			; 00000024H
  000ee	56		 push	 esi
  000ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 1678 : 
; 1679 : 	Dump ("Waiting completed! Thread returns 0x%08x\n", pThreadBlock->ntCreateStatus);
; 1680 : 	ntStatus = pThreadBlock->ntCreateStatus;

  000f5	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000f8	89 45 08	 mov	 DWORD PTR _ntStatus$[ebp], eax
$ret$30492:

; 1681 : 
; 1682 : ret:
; 1683 : 	TCfree (pThreadBlock);

  000fb	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00100	57		 push	 edi
  00101	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 1684 : 	return ntStatus;

  00107	8b 45 08	 mov	 eax, DWORD PTR _ntStatus$[ebp]
  0010a	5e		 pop	 esi
$LN6@TCStartVol:
  0010b	5f		 pop	 edi
  0010c	5b		 pop	 ebx

; 1685 : }

  0010d	c9		 leave
  0010e	c2 0c 00	 ret	 12			; 0000000cH
_TCStartVolumeThread@12 ENDP
_TEXT	ENDS
PUBLIC	_TCUnloadDriver@4
EXTRN	_EncryptionThreadPoolStop@0:PROC
EXTRN	_IsBootDriveMounted@0:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCUnloadDriver@4
_TEXT	SEGMENT
_DriverObject$ = 8					; size = 4
_TCUnloadDriver@4 PROC					; COMDAT

; 2094 : 	Dump ("TCUnloadDriver BEGIN\n");
; 2095 : 
; 2096 : 	OnShutdownPending();

  00000	e8 00 00 00 00	 call	 _OnShutdownPending@0

; 2097 : 
; 2098 : 	if (IsBootDriveMounted())

  00005	e8 00 00 00 00	 call	 _IsBootDriveMounted@0
  0000a	85 c0		 test	 eax, eax
  0000c	74 19		 je	 SHORT $LN1@TCUnloadDr

; 2099 : 		TC_BUG_CHECK (STATUS_INVALID_DEVICE_STATE);

  0000e	68 43 54 00 00	 push	 21571			; 00005443H
  00013	6a 00		 push	 0
  00015	68 84 01 00 c0	 push	 -1073741436		; c0000184H
  0001a	68 33 08 00 00	 push	 2099			; 00000833H
  0001f	6a 29		 push	 41			; 00000029H
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN5@TCUnloadDr:
$LN1@TCUnloadDr:

; 2100 : 
; 2101 : 	EncryptionThreadPoolStop();

  00027	e8 00 00 00 00	 call	 _EncryptionThreadPoolStop@0

; 2102 : 	TCDeleteDeviceObject (RootDeviceObject, (PEXTENSION) RootDeviceObject->DeviceExtension);

  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR _RootDeviceObject
  00031	ff 70 28	 push	 DWORD PTR [eax+40]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _TCDeleteDeviceObject@8

; 2103 : 
; 2104 : 	Dump ("TCUnloadDriver END\n");
; 2105 : }

  0003a	c2 04 00	 ret	 4
$LN4@TCUnloadDr:
_TCUnloadDriver@4 ENDP
_TEXT	ENDS
PUBLIC	_MountDevice@8
EXTRN	__imp__RtlCopySid@12:PROC
EXTRN	__imp__RtlLengthSid@4:PROC
EXTRN	__SEH_epilog4:PROC
EXTRN	__except_handler4:PROC
EXTRN	__SEH_prolog4:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$_MountDevice@8 DD 0fffffffeH
	DD	00H
	DD	0ffffffbcH
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN26@MountDevic
	DD	FLAT:$LN27@MountDevic
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT _MountDevice@8
_TEXT	SEGMENT
_subContext$30917 = -52					; size = 16
_volumeHandle$30943 = -36				; size = 4
_fsStatus$30950 = -32					; size = 4
_NewDeviceObject$ = -28					; size = 4
__$SEHRec$ = -24					; size = 24
_volumeFileObject$30944 = 8				; size = 4
_tokenUser$30929 = 8					; size = 4
_DeviceObject$ = 8					; size = 4
_mount$ = 12						; size = 4
_MountDevice@8 PROC					; COMDAT

; 2514 : {

  00000	6a 24		 push	 36			; 00000024H
  00002	68 00 00 00 00	 push	 OFFSET __sehtable$_MountDevice@8
  00007	e8 00 00 00 00	 call	 __SEH_prolog4

; 2515 : 	PDEVICE_OBJECT NewDeviceObject;
; 2516 : 	NTSTATUS ntStatus;
; 2517 : 
; 2518 : 	// Make sure the user is asking for a reasonable nDosDriveNo
; 2519 : 	if (mount->nDosDriveNo >= 0 && mount->nDosDriveNo <= 25 && IsDriveLetterAvailable (mount->nDosDriveNo))

  0000c	8b 7d 0c	 mov	 edi, DWORD PTR _mount$[ebp]
  0000f	8b 87 64 02 00
	00		 mov	 eax, DWORD PTR [edi+612]
  00015	85 c0		 test	 eax, eax
  00017	0f 8c b4 01 00
	00		 jl	 $LN20@MountDevic
  0001d	83 f8 19	 cmp	 eax, 25			; 00000019H
  00020	0f 8f ab 01 00
	00		 jg	 $LN20@MountDevic
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 _IsDriveLetterAvailable@4
  0002c	85 c0		 test	 eax, eax
  0002e	0f 84 9d 01 00
	00		 je	 $LN20@MountDevic

; 2527 : 		return ERR_DRIVE_NOT_FOUND;
; 2528 : 	}
; 2529 : 
; 2530 : 	if (!SelfTestsPassed)

  00034	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SelfTestsPassed, 0
  0003b	75 07		 jne	 SHORT $LN18@MountDevic

; 2531 : 	{
; 2532 : 		mount->nReturnCode = ERR_SELF_TESTS_FAILED;

  0003d	6a 13		 push	 19			; 00000013H

; 2533 : 		return ERR_SELF_TESTS_FAILED;

  0003f	e9 8f 01 00 00	 jmp	 $LN31@MountDevic
$LN18@MountDevic:

; 2534 : 	}
; 2535 : 
; 2536 : 	ntStatus = TCCreateDeviceObject (DeviceObject->DriverObject, &NewDeviceObject, mount);

  00044	57		 push	 edi
  00045	8d 45 e4	 lea	 eax, DWORD PTR _NewDeviceObject$[ebp]
  00048	50		 push	 eax
  00049	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  0004c	ff 70 08	 push	 DWORD PTR [eax+8]
  0004f	e8 00 00 00 00	 call	 _TCCreateDeviceObject@12

; 2537 : 
; 2538 : 	if (!NT_SUCCESS (ntStatus))

  00054	85 c0		 test	 eax, eax

; 2539 : 	{
; 2540 : 		Dump ("Mount CREATE DEVICE ERROR, ntStatus = 0x%08x\n", ntStatus);
; 2541 : 		return ntStatus;

  00056	0f 8c 7a 01 00
	00		 jl	 $LN8@MountDevic

; 2542 : 	}
; 2543 : 	else
; 2544 : 	{
; 2545 : 		PEXTENSION NewExtension = (PEXTENSION) NewDeviceObject->DeviceExtension;

  0005c	8b 45 e4	 mov	 eax, DWORD PTR _NewDeviceObject$[ebp]
  0005f	8b 58 28	 mov	 ebx, DWORD PTR [eax+40]

; 2546 : 		SECURITY_SUBJECT_CONTEXT subContext;
; 2547 : 		PACCESS_TOKEN accessToken;
; 2548 : 
; 2549 : 		SeCaptureSubjectContext (&subContext);

  00062	8d 45 cc	 lea	 eax, DWORD PTR _subContext$30917[ebp]
  00065	50		 push	 eax
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeCaptureSubjectContext@4

; 2550 : 		accessToken = SeQuerySubjectContextToken (&subContext);

  0006c	8b 45 cc	 mov	 eax, DWORD PTR _subContext$30917[ebp]
  0006f	85 c0		 test	 eax, eax
  00071	75 0e		 jne	 SHORT $LN15@MountDevic
  00073	8b 45 d4	 mov	 eax, DWORD PTR _subContext$30917[ebp+8]

; 2551 : 
; 2552 : 		if (!accessToken)

  00076	85 c0		 test	 eax, eax
  00078	75 07		 jne	 SHORT $LN15@MountDevic

; 2553 : 		{
; 2554 : 			ntStatus = STATUS_INVALID_PARAMETER;

  0007a	be 0d 00 00 c0	 mov	 esi, -1073741811	; c000000dH

; 2555 : 		}
; 2556 : 		else

  0007f	eb 59		 jmp	 SHORT $LN13@MountDevic
$LN15@MountDevic:

; 2557 : 		{
; 2558 : 			PTOKEN_USER tokenUser;
; 2559 : 
; 2560 : 			ntStatus = SeQueryInformationToken (accessToken, TokenUser, &tokenUser);

  00081	8d 4d 08	 lea	 ecx, DWORD PTR _tokenUser$30929[ebp]
  00084	51		 push	 ecx
  00085	6a 01		 push	 1
  00087	50		 push	 eax
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeQueryInformationToken@12
  0008e	8b f0		 mov	 esi, eax

; 2561 : 			if (NT_SUCCESS (ntStatus))

  00090	85 f6		 test	 esi, esi
  00092	7c 46		 jl	 SHORT $LN13@MountDevic

; 2562 : 			{
; 2563 : 				ULONG sidLength = RtlLengthSid (tokenUser->User.Sid);

  00094	8b 45 08	 mov	 eax, DWORD PTR _tokenUser$30929[ebp]
  00097	ff 30		 push	 DWORD PTR [eax]
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLengthSid@4
  0009f	8b f0		 mov	 esi, eax

; 2564 : 
; 2565 : 				NewExtension->UserSid = TCalloc (sidLength);

  000a1	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  000a6	56		 push	 esi
  000a7	6a 00		 push	 0
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  000af	89 83 8c 04 00
	00		 mov	 DWORD PTR [ebx+1164], eax

; 2566 : 				if (!NewExtension->UserSid)

  000b5	85 c0		 test	 eax, eax
  000b7	75 07		 jne	 SHORT $LN12@MountDevic

; 2567 : 					ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  000b9	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH

; 2568 : 				else

  000be	eb 0f		 jmp	 SHORT $LN11@MountDevic
$LN12@MountDevic:

; 2569 : 					ntStatus = RtlCopySid (sidLength, NewExtension->UserSid, tokenUser->User.Sid);

  000c0	8b 4d 08	 mov	 ecx, DWORD PTR _tokenUser$30929[ebp]
  000c3	ff 31		 push	 DWORD PTR [ecx]
  000c5	50		 push	 eax
  000c6	56		 push	 esi
  000c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlCopySid@12
  000cd	8b f0		 mov	 esi, eax
$LN11@MountDevic:

; 2570 : 
; 2571 : 				ExFreePool (tokenUser);		// Documented in newer versions of WDK

  000cf	6a 00		 push	 0
  000d1	ff 75 08	 push	 DWORD PTR _tokenUser$30929[ebp]
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN13@MountDevic:

; 2572 : 			}
; 2573 : 		}
; 2574 : 
; 2575 : 		SeReleaseSubjectContext (&subContext);

  000da	8d 45 cc	 lea	 eax, DWORD PTR _subContext$30917[ebp]
  000dd	50		 push	 eax
  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeReleaseSubjectContext@4

; 2576 : 
; 2577 : 		if (NT_SUCCESS (ntStatus))

  000e4	85 f6		 test	 esi, esi
  000e6	7c 10		 jl	 SHORT $LN34@MountDevic

; 2578 : 			ntStatus = TCStartVolumeThread (NewDeviceObject, NewExtension, mount);

  000e8	57		 push	 edi
  000e9	53		 push	 ebx
  000ea	ff 75 e4	 push	 DWORD PTR _NewDeviceObject$[ebp]
  000ed	e8 00 00 00 00	 call	 _TCStartVolumeThread@12
  000f2	8b f0		 mov	 esi, eax

; 2579 : 
; 2580 : 		if (!NT_SUCCESS (ntStatus))

  000f4	85 f6		 test	 esi, esi
  000f6	7d 10		 jge	 SHORT $LN9@MountDevic
$LN34@MountDevic:

; 2581 : 		{
; 2582 : 			Dump ("Mount FAILURE NT ERROR, ntStatus = 0x%08x\n", ntStatus);
; 2583 : 			TCDeleteDeviceObject (NewDeviceObject, NewExtension);

  000f8	53		 push	 ebx
  000f9	ff 75 e4	 push	 DWORD PTR _NewDeviceObject$[ebp]
  000fc	e8 00 00 00 00	 call	 _TCDeleteDeviceObject@8

; 2584 : 			return ntStatus;

  00101	8b c6		 mov	 eax, esi
  00103	e9 ce 00 00 00	 jmp	 $LN8@MountDevic
$LN9@MountDevic:

; 2585 : 		}
; 2586 : 		else
; 2587 : 		{
; 2588 : 			if (mount->nReturnCode == 0)

  00108	83 3f 00	 cmp	 DWORD PTR [edi], 0
  0010b	0f 85 b3 00 00
	00		 jne	 $LN7@MountDevic

; 2589 : 			{
; 2590 : 				HANDLE volumeHandle;
; 2591 : 				PFILE_OBJECT volumeFileObject;
; 2592 : 
; 2593 : 				Dump ("Mount SUCCESS TC code = 0x%08x READ-ONLY = %d\n", mount->nReturnCode, NewExtension->bReadOnly);
; 2594 : 
; 2595 : 				if (NewExtension->bReadOnly)

  00111	83 bb 48 02 00
	00 00		 cmp	 DWORD PTR [ebx+584], 0
  00118	74 07		 je	 SHORT $LN6@MountDevic

; 2596 : 					NewDeviceObject->Characteristics |= FILE_READ_ONLY_DEVICE;

  0011a	8b 45 e4	 mov	 eax, DWORD PTR _NewDeviceObject$[ebp]
  0011d	83 48 20 02	 or	 DWORD PTR [eax+32], 2
$LN6@MountDevic:

; 2597 : 
; 2598 : 				NewDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

  00121	8b 45 e4	 mov	 eax, DWORD PTR _NewDeviceObject$[ebp]
  00124	81 60 1c 7f ff
	ff ff		 and	 DWORD PTR [eax+28], -129 ; ffffff7fH

; 2599 : 
; 2600 : 				NewExtension->UniqueVolumeId = LastUniqueVolumeId++;

  0012b	a1 00 00 00 00	 mov	 eax, DWORD PTR _LastUniqueVolumeId
  00130	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  00133	ff 05 00 00 00
	00		 inc	 DWORD PTR _LastUniqueVolumeId

; 2601 : 
; 2602 : 				if (mount->bMountManager)

  00139	8d b7 78 02 00
	00		 lea	 esi, DWORD PTR [edi+632]
  0013f	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00142	74 06		 je	 SHORT $LN5@MountDevic

; 2603 : 					MountManagerMount (mount);

  00144	57		 push	 edi
  00145	e8 00 00 00 00	 call	 _MountManagerMount@4
$LN5@MountDevic:

; 2604 : 
; 2605 : 				NewExtension->bMountManager = mount->bMountManager;

  0014a	8b 06		 mov	 eax, DWORD PTR [esi]
  0014c	89 83 58 02 00
	00		 mov	 DWORD PTR [ebx+600], eax

; 2606 : 
; 2607 : 				// We create symbolic link even if mount manager is notified of
; 2608 : 				// arriving volume as it apparently sometimes fails to create the link
; 2609 : 				CreateDriveLink (mount->nDosDriveNo);

  00152	ff b7 64 02 00
	00		 push	 DWORD PTR [edi+612]
  00158	e8 00 00 00 00	 call	 _CreateDriveLink@4

; 2610 : 
; 2611 : 				mount->FilesystemDirty = FALSE;

  0015d	33 f6		 xor	 esi, esi
  0015f	89 77 04	 mov	 DWORD PTR [edi+4], esi

; 2612 : 
; 2613 : 				if (NT_SUCCESS (TCOpenFsVolume (NewExtension, &volumeHandle, &volumeFileObject)))

  00162	8d 45 08	 lea	 eax, DWORD PTR _volumeFileObject$30944[ebp]
  00165	50		 push	 eax
  00166	8d 45 dc	 lea	 eax, DWORD PTR _volumeHandle$30943[ebp]
  00169	50		 push	 eax
  0016a	53		 push	 ebx
  0016b	e8 00 00 00 00	 call	 _TCOpenFsVolume@12
  00170	85 c0		 test	 eax, eax
  00172	7c 59		 jl	 SHORT $LN1@MountDevic

; 2614 : 				{
; 2615 : 					__try

  00174	89 75 fc	 mov	 DWORD PTR __$SEHRec$[ebp+20], esi

; 2616 : 					{
; 2617 : 						ULONG fsStatus;
; 2618 : 
; 2619 : 						if (NT_SUCCESS (TCFsctlCall (volumeFileObject, FSCTL_IS_VOLUME_DIRTY, NULL, 0, &fsStatus, sizeof (fsStatus)))
; 2620 : 							&& (fsStatus & VOLUME_IS_DIRTY))

  00177	6a 04		 push	 4
  00179	8d 45 e0	 lea	 eax, DWORD PTR _fsStatus$30950[ebp]
  0017c	50		 push	 eax
  0017d	56		 push	 esi
  0017e	56		 push	 esi
  0017f	68 78 00 09 00	 push	 589944			; 00090078H
  00184	ff 75 08	 push	 DWORD PTR _volumeFileObject$30944[ebp]
  00187	e8 00 00 00 00	 call	 _TCFsctlCall@24
  0018c	85 c0		 test	 eax, eax
  0018e	7c 20		 jl	 SHORT $LN2@MountDevic
  00190	f6 45 e0 01	 test	 BYTE PTR _fsStatus$30950[ebp], 1
  00194	74 1a		 je	 SHORT $LN2@MountDevic

; 2621 : 						{
; 2622 : 							mount->FilesystemDirty = TRUE;

  00196	c7 47 04 01 00
	00 00		 mov	 DWORD PTR [edi+4], 1

; 2623 : 						}
; 2624 : 					}

  0019d	eb 11		 jmp	 SHORT $LN2@MountDevic
$LN26@MountDevic:
$LN35@MountDevic:

; 2625 : 					__except (EXCEPTION_EXECUTE_HANDLER)

  0019f	33 c0		 xor	 eax, eax
  001a1	40		 inc	 eax
$LN30@MountDevic:
$LN28@MountDevic:
  001a2	c3		 ret	 0
$LN27@MountDevic:
  001a3	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 2626 : 					{
; 2627 : 						mount->FilesystemDirty = TRUE;

  001a6	8b 45 0c	 mov	 eax, DWORD PTR _mount$[ebp]
  001a9	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [eax+4], 1
$LN2@MountDevic:

; 2628 : 					}

  001b0	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH

; 2629 : 
; 2630 : 
; 2631 : 					TCCloseFsVolume (volumeHandle, volumeFileObject);

  001b7	ff 75 08	 push	 DWORD PTR _volumeFileObject$30944[ebp]
  001ba	ff 75 dc	 push	 DWORD PTR _volumeHandle$30943[ebp]
  001bd	e8 00 00 00 00	 call	 _TCCloseFsVolume@8

; 2632 : 				}
; 2633 : 			}
; 2634 : 			else

  001c2	eb 09		 jmp	 SHORT $LN1@MountDevic
$LN7@MountDevic:

; 2635 : 			{
; 2636 : 				Dump ("Mount FAILURE TC code = 0x%08x\n", mount->nReturnCode);
; 2637 : 				TCDeleteDeviceObject (NewDeviceObject, NewExtension);

  001c4	53		 push	 ebx
  001c5	ff 75 e4	 push	 DWORD PTR _NewDeviceObject$[ebp]
  001c8	e8 00 00 00 00	 call	 _TCDeleteDeviceObject@8
$LN1@MountDevic:

; 2638 : 			}
; 2639 : 			
; 2640 : 			return STATUS_SUCCESS;

  001cd	33 c0		 xor	 eax, eax
  001cf	eb 05		 jmp	 SHORT $LN8@MountDevic
$LN20@MountDevic:

; 2520 : 	{
; 2521 : 		Dump ("Mount request looks valid\n");
; 2522 : 	}
; 2523 : 	else
; 2524 : 	{
; 2525 : 		Dump ("WARNING: MOUNT DRIVE LETTER INVALID\n");
; 2526 : 		mount->nReturnCode = ERR_DRIVE_NOT_FOUND;

  001d1	6a 05		 push	 5
$LN31@MountDevic:
  001d3	58		 pop	 eax
  001d4	89 07		 mov	 DWORD PTR [edi], eax
$LN8@MountDevic:

; 2641 : 		}
; 2642 : 	}
; 2643 : }

  001d6	e8 00 00 00 00	 call	 __SEH_epilog4
  001db	c2 08 00	 ret	 8
_MountDevice@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_09EMKKFGIH@TrueCrypt?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	_DeviceObject$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_ProcessMainDeviceControlIrp@12
EXTRN	_IsHwEncryptionEnabled@0:PROC
EXTRN	_GetBootDriveFilterExtension@0:PROC
EXTRN	_WriteBootDriveSector@8:PROC
EXTRN	_StartDecoySystemWipe@12:PROC
EXTRN	_AbortDecoySystemWipe@0:PROC
EXTRN	_GetDecoySystemWipeStatus@8:PROC
EXTRN	_GetDecoySystemWipeResult@0:PROC
EXTRN	_MirrorBytes16@4:PROC
EXTRN	_GetBootEncryptionAlgorithmName@8:PROC
EXTRN	_IsHiddenSystemRunning@0:PROC
EXTRN	_ReopenBootVolumeHeader@8:PROC
EXTRN	_StartBootEncryptionSetup@12:PROC
EXTRN	_AbortBootEncryptionSetup@0:PROC
EXTRN	_GetSetupResult@0:PROC
EXTRN	_GetBootDriveVolumeProperties@8:PROC
EXTRN	_GetBootEncryptionStatus@8:PROC
EXTRN	_MirrorBytes64@8:PROC
EXTRN	__imp__IoEnumerateDeviceObjectList@16:PROC
EXTRN	_cacheEmpty:DWORD
EXTRN	_WipeCache@0:PROC
EXTRN	_GetBootLoaderVersion@8:PROC
;	COMDAT ??_C@_09EMKKFGIH@TrueCrypt?$AA@FNODOBFM@
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
text$s	SEGMENT
??_C@_09EMKKFGIH@TrueCrypt?$AA@FNODOBFM@ DB 'TrueCrypt', 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
; File c:\home\public\desktop\projects\ciphershed.build\src\driver\ntdriver.c
text$s	ENDS
;	COMDAT _ProcessMainDeviceControlIrp@12
_TEXT	SEGMENT
_pi$30285 = -796					; size = 144
_name$30319 = -652					; size = 8
_FullFileName$30131 = -644				; size = 8
_FullFileName$30183 = -636				; size = 8
_IoStatus$30184 = -628					; size = 8
_ObjectAttributes$30181 = -620				; size = 24
_ObjectAttributes$30129 = -596				; size = 24
_offset$30133 = -572					; size = 8
_offset$30185 = -564					; size = 8
_lengthInfo$30295 = -556				; size = 8
_deviceObject$30321 = -548				; size = 4
_IoStatus$30132 = -544					; size = 8
tv1386 = -536						; size = 4
_fileObject$30320 = -536				; size = 4
_request$30179 = -532					; size = 4
_NtFileHandle$30130 = -532				; size = 4
_DeviceObject$GSCopy$ = -528				; size = 4
_opentest$30127 = -528					; size = 4
_deviceObjectCount$30104 = -528				; size = 4
_NtFileHandle$30182 = -524				; size = 4
_ntStatus$ = -524					; size = 4
_access$30134 = -524					; size = 4
tv1054 = -520						; size = 4
_ntStatus$30286 = -520					; size = 4
_drive$30237 = -520					; size = 4
_readBuffer$30149 = -520				; size = 4
_readBuffer$30186 = -516				; size = 512
__$ArrayPad$ = -4					; size = 4
_DeviceObject$ = 8					; size = 4
_Extension$ = 12					; size = 4
_Irp$ = 16						; size = 4
_ProcessMainDeviceControlIrp@12 PROC			; COMDAT

; 808  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 1c 03 00
	00		 sub	 esp, 796		; 0000031cH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	8b 55 08	 mov	 edx, DWORD PTR _DeviceObject$[ebp]
  00018	53		 push	 ebx
  00019	8b 5d 10	 mov	 ebx, DWORD PTR _Irp$[ebp]
  0001c	56		 push	 esi
  0001d	57		 push	 edi

; 809  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);

  0001e	8b 7b 60	 mov	 edi, DWORD PTR [ebx+96]

; 810  : 	NTSTATUS ntStatus;
; 811  : 
; 812  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  00021	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00024	b9 48 20 22 00	 mov	 ecx, 2236488		; 00222048H

; 1361 : 			}
; 1362 : 
; 1363 : 			EnsureNullTerminatedString (mount->wszVolume, sizeof (mount->wszVolume));

  00029	89 95 f0 fd ff
	ff		 mov	 DWORD PTR _DeviceObject$GSCopy$[ebp], edx
  0002f	3b c1		 cmp	 eax, ecx
  00031	0f 87 97 0a 00
	00		 ja	 $LN152@ProcessMai

; 810  : 	NTSTATUS ntStatus;
; 811  : 
; 812  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  00037	0f 84 85 0a 00
	00		 je	 $LN24@ProcessMai
  0003d	83 c1 d8	 add	 ecx, -40		; ffffffd8H
  00040	3b c1		 cmp	 eax, ecx
  00042	0f 87 6e 04 00
	00		 ja	 $LN153@ProcessMai
  00048	0f 84 41 04 00
	00		 je	 $LN141@ProcessMai
  0004e	b9 0c 20 22 00	 mov	 ecx, 2236428		; 0022200cH
  00053	3b c1		 cmp	 eax, ecx
  00055	0f 87 1f 01 00
	00		 ja	 $LN154@ProcessMai
  0005b	0f 84 85 00 00
	00		 je	 $LN46@ProcessMai
  00061	2d 04 20 07 00	 sub	 eax, 466948		; 00072004H
  00066	74 47		 je	 SHORT $LN74@ProcessMai
  00068	83 e8 14	 sub	 eax, 20			; 00000014H
  0006b	74 1c		 je	 SHORT $LN143@ProcessMai
  0006d	2d ec ff 1a 00	 sub	 eax, 1769452		; 001affecH
  00072	74 15		 je	 SHORT $LN143@ProcessMai
  00074	83 e8 04	 sub	 eax, 4
  00077	0f 85 7b 0d 00
	00		 jne	 $LN1@ProcessMai

; 1428 : 
; 1429 : 	case TC_IOCTL_GET_BOOT_LOADER_VERSION:
; 1430 : 		GetBootLoaderVersion (Irp, irpSp);

  0007d	57		 push	 edi
  0007e	53		 push	 ebx
  0007f	e8 00 00 00 00	 call	 _GetBootLoaderVersion@8

; 1431 : 		break;

  00084	e9 28 0e 00 00	 jmp	 $LN10@ProcessMai
$LN143@ProcessMai:

; 813  : 	{
; 814  : 	case TC_IOCTL_GET_DRIVER_VERSION:
; 815  : 	case TC_IOCTL_LEGACY_GET_DRIVER_VERSION:
; 816  : 		if (ValidateIOBufferSize (Irp, sizeof (LONG), ValidateOutput))

  00089	6a 01		 push	 1
  0008b	6a 04		 push	 4
  0008d	5e		 pop	 esi
  0008e	56		 push	 esi
  0008f	53		 push	 ebx
  00090	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00095	85 c0		 test	 eax, eax
  00097	0f 84 14 0e 00
	00		 je	 $LN10@ProcessMai

; 817  : 		{
; 818  : 			LONG tmp = VERSION_NUM;
; 819  : 			memcpy (Irp->AssociatedIrp.SystemBuffer, &tmp, 4);

  0009d	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  000a0	c7 00 30 07 00
	00		 mov	 DWORD PTR [eax], 1840	; 00000730H
$LN257@ProcessMai:

; 820  : 			Irp->IoStatus.Information = sizeof (LONG);
; 821  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  000a6	83 63 18 00	 and	 DWORD PTR [ebx+24], 0

; 822  : 		}
; 823  : 		break;

  000aa	e9 ff 0d 00 00	 jmp	 $LN254@ProcessMai
$LN74@ProcessMai:

; 1145 : 
; 1146 : 	case TC_IOCTL_LEGACY_GET_MOUNTED_VOLUMES:
; 1147 : 		if (ValidateIOBufferSize (Irp, sizeof (uint32), ValidateOutput))

  000af	6a 01		 push	 1
  000b1	6a 04		 push	 4
  000b3	53		 push	 ebx
  000b4	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  000b9	85 c0		 test	 eax, eax
  000bb	0f 84 f0 0d 00
	00		 je	 $LN10@ProcessMai

; 1148 : 		{
; 1149 : 			// Prevent the user from downgrading to versions lower than 5.0 by faking mounted volumes.
; 1150 : 			// The user could render the system unbootable by downgrading when boot encryption
; 1151 : 			// is active or being set up.
; 1152 : 
; 1153 : 			memset (Irp->AssociatedIrp.SystemBuffer, 0, irpSp->Parameters.DeviceIoControl.OutputBufferLength);

  000c1	ff 77 04	 push	 DWORD PTR [edi+4]
  000c4	6a 00		 push	 0
  000c6	ff 73 0c	 push	 DWORD PTR [ebx+12]
  000c9	e8 00 00 00 00	 call	 _memset

; 1154 : 			*(uint32 *) Irp->AssociatedIrp.SystemBuffer = 0xffffFFFF;

  000ce	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  000d1	83 08 ff	 or	 DWORD PTR [eax], -1
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1155 : 
; 1156 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  000d7	83 63 18 00	 and	 DWORD PTR [ebx+24], 0

; 1157 : 			Irp->IoStatus.Information = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

  000db	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000de	89 43 1c	 mov	 DWORD PTR [ebx+28], eax

; 1158 : 		}
; 1159 : 		break;

  000e1	e9 cb 0d 00 00	 jmp	 $LN10@ProcessMai
$LN46@ProcessMai:

; 1350 : 
; 1351 : 	case TC_IOCTL_MOUNT_VOLUME:
; 1352 : 		if (ValidateIOBufferSize (Irp, sizeof (MOUNT_STRUCT), ValidateInputOutput))

  000e6	6a 02		 push	 2
  000e8	bf e0 02 00 00	 mov	 edi, 736		; 000002e0H
  000ed	57		 push	 edi
  000ee	53		 push	 ebx
  000ef	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  000f4	85 c0		 test	 eax, eax
  000f6	0f 84 b5 0d 00
	00		 je	 $LN10@ProcessMai

; 1353 : 		{
; 1354 : 			MOUNT_STRUCT *mount = (MOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  000fc	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]

; 1355 : 
; 1356 : 			if (mount->VolumePassword.Length > MAX_PASSWORD || mount->ProtectedHidVolPassword.Length > MAX_PASSWORD)

  000ff	8d b0 18 02 00
	00		 lea	 esi, DWORD PTR [eax+536]
  00105	83 3e 40	 cmp	 DWORD PTR [esi], 64	; 00000040H
  00108	77 64		 ja	 SHORT $LN43@ProcessMai
  0010a	8d 88 90 02 00
	00		 lea	 ecx, DWORD PTR [eax+656]
  00110	83 39 40	 cmp	 DWORD PTR [ecx], 64	; 00000040H
  00113	89 8d f8 fd ff
	ff		 mov	 DWORD PTR tv1054[ebp], ecx
  00119	77 53		 ja	 SHORT $LN43@ProcessMai

; 1364 : 
; 1365 : 			Irp->IoStatus.Information = sizeof (MOUNT_STRUCT);
; 1366 : 			Irp->IoStatus.Status = MountDevice (DeviceObject, mount);

  0011b	50		 push	 eax
  0011c	ff b5 f0 fd ff
	ff		 push	 DWORD PTR _DeviceObject$GSCopy$[ebp]
  00122	33 c9		 xor	 ecx, ecx
  00124	66 89 88 16 02
	00 00		 mov	 WORD PTR [eax+534], cx
  0012b	89 7b 1c	 mov	 DWORD PTR [ebx+28], edi
  0012e	e8 00 00 00 00	 call	 _MountDevice@8

; 1367 : 
; 1368 : 			burn (&mount->VolumePassword, sizeof (mount->VolumePassword));

  00133	6a 48		 push	 72			; 00000048H
  00135	89 43 18	 mov	 DWORD PTR [ebx+24], eax
  00138	58		 pop	 eax
  00139	8b ce		 mov	 ecx, esi
  0013b	8b d0		 mov	 edx, eax
  0013d	8b f8		 mov	 edi, eax
$LL176@ProcessMai:
  0013f	c6 06 00	 mov	 BYTE PTR [esi], 0
  00142	46		 inc	 esi
  00143	4f		 dec	 edi
  00144	75 f9		 jne	 SHORT $LL176@ProcessMai
$LL39@ProcessMai:
  00146	4a		 dec	 edx
  00147	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0014a	41		 inc	 ecx
  0014b	85 d2		 test	 edx, edx
  0014d	75 f7		 jne	 SHORT $LL39@ProcessMai

; 1369 : 			burn (&mount->ProtectedHidVolPassword, sizeof (mount->ProtectedHidVolPassword));

  0014f	8b 95 f8 fd ff
	ff		 mov	 edx, DWORD PTR tv1054[ebp]
  00155	8b f0		 mov	 esi, eax
  00157	8b ca		 mov	 ecx, edx
$LL180@ProcessMai:
  00159	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0015c	41		 inc	 ecx
  0015d	48		 dec	 eax
  0015e	75 f9		 jne	 SHORT $LL180@ProcessMai
$LL34@ProcessMai:
  00160	4e		 dec	 esi
  00161	c6 02 00	 mov	 BYTE PTR [edx], 0
  00164	42		 inc	 edx
  00165	85 f6		 test	 esi, esi
  00167	75 f7		 jne	 SHORT $LL34@ProcessMai

; 1114 : 
; 1115 : 			for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)

  00169	e9 43 0d 00 00	 jmp	 $LN10@ProcessMai
$LN43@ProcessMai:

; 1357 : 			{
; 1358 : 				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  0016e	c7 43 18 0d 00
	00 c0		 mov	 DWORD PTR [ebx+24], -1073741811 ; c000000dH

; 1359 : 				Irp->IoStatus.Information = 0;
; 1360 : 				break;

  00175	e9 76 03 00 00	 jmp	 $LN260@ProcessMai
$LN154@ProcessMai:

; 810  : 	NTSTATUS ntStatus;
; 811  : 
; 812  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  0017a	2d 10 20 22 00	 sub	 eax, 2236432		; 00222010H
  0017f	0f 84 b8 02 00
	00		 je	 $LN32@ProcessMai
  00185	6a 04		 push	 4
  00187	5e		 pop	 esi
  00188	2b c6		 sub	 eax, esi
  0018a	0f 84 85 02 00
	00		 je	 $LN28@ProcessMai
  00190	2b c6		 sub	 eax, esi
  00192	0f 84 6e 01 00
	00		 je	 $LN87@ProcessMai
  00198	2b c6		 sub	 eax, esi
  0019a	0f 85 58 0c 00
	00		 jne	 $LN1@ProcessMai

; 1160 : 
; 1161 : 	case TC_IOCTL_GET_VOLUME_PROPERTIES:
; 1162 : 		if (ValidateIOBufferSize (Irp, sizeof (VOLUME_PROPERTIES_STRUCT), ValidateInputOutput))

  001a0	6a 02		 push	 2
  001a2	68 54 02 00 00	 push	 596			; 00000254H
  001a7	53		 push	 ebx
  001a8	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  001ad	85 c0		 test	 eax, eax
  001af	0f 84 fc 0c 00
	00		 je	 $LN10@ProcessMai

; 1163 : 		{
; 1164 : 			VOLUME_PROPERTIES_STRUCT *prop = (VOLUME_PROPERTIES_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  001b5	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]

; 1165 : 			PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject (prop->driveNo);

  001b8	ff 36		 push	 DWORD PTR [esi]
  001ba	e8 00 00 00 00	 call	 _GetVirtualVolumeDeviceObject@4

; 1166 : 
; 1167 : 			Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
; 1168 : 			Irp->IoStatus.Information = 0;

  001bf	83 63 1c 00	 and	 DWORD PTR [ebx+28], 0
  001c3	c7 43 18 0d 00
	00 c0		 mov	 DWORD PTR [ebx+24], -1073741811 ; c000000dH

; 1169 : 
; 1170 : 			if (ListDevice)

  001ca	85 c0		 test	 eax, eax
  001cc	0f 84 df 0c 00
	00		 je	 $LN10@ProcessMai

; 1171 : 			{
; 1172 : 				PEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;

  001d2	8b 78 28	 mov	 edi, DWORD PTR [eax+40]

; 1173 : 				if (IsVolumeAccessibleByCurrentUser (ListExtension))

  001d5	57		 push	 edi
  001d6	e8 00 00 00 00	 call	 _IsVolumeAccessibleByCurrentUser@4
  001db	85 c0		 test	 eax, eax
  001dd	0f 84 ce 0c 00
	00		 je	 $LN10@ProcessMai

; 1174 : 				{
; 1175 : 					prop->uniqueId = ListExtension->UniqueVolumeId;

  001e3	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  001e6	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1176 : 					wcscpy (prop->wszVolume, ListExtension->wszVolume);

  001e9	8d 87 60 02 00
	00		 lea	 eax, DWORD PTR [edi+608]
  001ef	8d 56 08	 lea	 edx, DWORD PTR [esi+8]
  001f2	2b d0		 sub	 edx, eax
$LL151@ProcessMai:
  001f4	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  001f7	66 89 0c 02	 mov	 WORD PTR [edx+eax], cx
  001fb	40		 inc	 eax
  001fc	40		 inc	 eax
  001fd	66 85 c9	 test	 cx, cx
  00200	75 f2		 jne	 SHORT $LL151@ProcessMai

; 1177 : 					prop->diskLength = ListExtension->DiskLength;

  00202	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  00205	89 86 10 02 00
	00		 mov	 DWORD PTR [esi+528], eax
  0020b	8b 47 74	 mov	 eax, DWORD PTR [edi+116]
  0020e	89 86 14 02 00
	00		 mov	 DWORD PTR [esi+532], eax

; 1178 : 					prop->ea = ListExtension->cryptoInfo->ea;

  00214	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  00217	8b 00		 mov	 eax, DWORD PTR [eax]
  00219	89 86 18 02 00
	00		 mov	 DWORD PTR [esi+536], eax

; 1179 : 					prop->mode = ListExtension->cryptoInfo->mode;

  0021f	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  00222	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00225	89 86 1c 02 00
	00		 mov	 DWORD PTR [esi+540], eax

; 1180 : 					prop->pkcs5 = ListExtension->cryptoInfo->pkcs5;

  0022b	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  0022e	8b 80 ec 43 00
	00		 mov	 eax, DWORD PTR [eax+17388]
  00234	89 86 20 02 00
	00		 mov	 DWORD PTR [esi+544], eax

; 1181 : 					prop->pkcs5Iterations = ListExtension->cryptoInfo->noIterations;

  0023a	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  0023d	8b 80 e8 43 00
	00		 mov	 eax, DWORD PTR [eax+17384]
  00243	89 86 24 02 00
	00		 mov	 DWORD PTR [esi+548], eax

; 1182 : #if 0
; 1183 : 					prop->volumeCreationTime = ListExtension->cryptoInfo->volume_creation_time;
; 1184 : 					prop->headerCreationTime = ListExtension->cryptoInfo->header_creation_time;
; 1185 : #endif
; 1186 : 					prop->volumeHeaderFlags = ListExtension->cryptoInfo->HeaderFlags;

  00249	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  0024c	8b 80 60 44 00
	00		 mov	 eax, DWORD PTR [eax+17504]
  00252	89 86 38 02 00
	00		 mov	 DWORD PTR [esi+568], eax

; 1187 : 					prop->readOnly = ListExtension->bReadOnly;

  00258	8b 87 48 02 00
	00		 mov	 eax, DWORD PTR [edi+584]
  0025e	89 86 2c 02 00
	00		 mov	 DWORD PTR [esi+556], eax

; 1188 : 					prop->removable = ListExtension->bRemovable;

  00264	8b 87 4c 02 00
	00		 mov	 eax, DWORD PTR [edi+588]
  0026a	89 86 30 02 00
	00		 mov	 DWORD PTR [esi+560], eax

; 1189 : 					prop->partitionInInactiveSysEncScope = ListExtension->PartitionInInactiveSysEncScope;

  00270	8b 87 50 02 00
	00		 mov	 eax, DWORD PTR [edi+592]
  00276	89 86 34 02 00
	00		 mov	 DWORD PTR [esi+564], eax

; 1190 : 					prop->hiddenVolume = ListExtension->cryptoInfo->hiddenVolume;

  0027c	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  0027f	8b 80 a0 29 00
	00		 mov	 eax, DWORD PTR [eax+10656]
  00285	89 86 28 02 00
	00		 mov	 DWORD PTR [esi+552], eax

; 1191 : 
; 1192 : 					if (ListExtension->cryptoInfo->bProtectHiddenVolume)

  0028b	8b 4f 60	 mov	 ecx, DWORD PTR [edi+96]
  0028e	33 c0		 xor	 eax, eax
  00290	39 81 00 44 00
	00		 cmp	 DWORD PTR [ecx+17408], eax
  00296	74 14		 je	 SHORT $LN68@ProcessMai

; 1193 : 						prop->hiddenVolProtection = ListExtension->cryptoInfo->bHiddenVolProtectionAction ? HIDVOL_PROT_STATUS_ACTION_TAKEN : HIDVOL_PROT_STATUS_ACTIVE;

  00298	33 d2		 xor	 edx, edx
  0029a	39 81 04 44 00
	00		 cmp	 DWORD PTR [ecx+17412], eax
  002a0	0f 95 c2	 setne	 dl
  002a3	42		 inc	 edx
  002a4	89 96 4c 02 00
	00		 mov	 DWORD PTR [esi+588], edx

; 1194 : 					else

  002aa	eb 06		 jmp	 SHORT $LN67@ProcessMai
$LN68@ProcessMai:

; 1195 : 						prop->hiddenVolProtection = HIDVOL_PROT_STATUS_NONE;

  002ac	89 86 4c 02 00
	00		 mov	 DWORD PTR [esi+588], eax
$LN67@ProcessMai:

; 1196 : 
; 1197 : 					prop->totalBytesRead = ListExtension->Queue.TotalBytesRead;

  002b2	8b 8f 10 02 00
	00		 mov	 ecx, DWORD PTR [edi+528]
  002b8	89 8e 3c 02 00
	00		 mov	 DWORD PTR [esi+572], ecx
  002be	8b 8f 14 02 00
	00		 mov	 ecx, DWORD PTR [edi+532]
  002c4	89 8e 40 02 00
	00		 mov	 DWORD PTR [esi+576], ecx

; 1198 : 					prop->totalBytesWritten = ListExtension->Queue.TotalBytesWritten;

  002ca	8b 8f 18 02 00
	00		 mov	 ecx, DWORD PTR [edi+536]
  002d0	89 8e 44 02 00
	00		 mov	 DWORD PTR [esi+580], ecx
  002d6	8b 8f 1c 02 00
	00		 mov	 ecx, DWORD PTR [edi+540]
  002dc	89 8e 48 02 00
	00		 mov	 DWORD PTR [esi+584], ecx

; 1199 : 
; 1200 : 					prop->volFormatVersion = ListExtension->cryptoInfo->LegacyVolume ? TC_VOLUME_FORMAT_VERSION_PRE_6_0 : TC_VOLUME_FORMAT_VERSION;

  002e2	8b 4f 60	 mov	 ecx, DWORD PTR [edi+96]
  002e5	33 d2		 xor	 edx, edx
  002e7	39 81 3c 44 00
	00		 cmp	 DWORD PTR [ecx+17468], eax
  002ed	0f 94 c2	 sete	 dl
  002f0	42		 inc	 edx
  002f1	89 96 50 02 00
	00		 mov	 DWORD PTR [esi+592], edx

; 1201 : 
; 1202 : 					Irp->IoStatus.Status = STATUS_SUCCESS;

  002f7	89 43 18	 mov	 DWORD PTR [ebx+24], eax

; 1203 : 					Irp->IoStatus.Information = sizeof (VOLUME_PROPERTIES_STRUCT);

  002fa	c7 43 1c 54 02
	00 00		 mov	 DWORD PTR [ebx+28], 596	; 00000254H

; 1204 : 				}
; 1205 : 			}
; 1206 : 		}
; 1207 : 		break;

  00301	e9 ab 0b 00 00	 jmp	 $LN10@ProcessMai
$LN87@ProcessMai:

; 1104 : 
; 1105 : 	case TC_IOCTL_GET_MOUNTED_VOLUMES:
; 1106 : 
; 1107 : 		if (ValidateIOBufferSize (Irp, sizeof (MOUNT_LIST_STRUCT), ValidateOutput))

  00306	6a 01		 push	 1
  00308	68 74 36 00 00	 push	 13940			; 00003674H
  0030d	53		 push	 ebx
  0030e	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00313	85 c0		 test	 eax, eax
  00315	0f 84 96 0b 00
	00		 je	 $LN10@ProcessMai

; 1108 : 		{
; 1109 : 			MOUNT_LIST_STRUCT *list = (MOUNT_LIST_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  0031b	8b 7b 0c	 mov	 edi, DWORD PTR [ebx+12]

; 1110 : 			PDEVICE_OBJECT ListDevice;
; 1111 : 			int drive;
; 1112 : 
; 1113 : 			list->ulMountedDrives = 0;

  0031e	83 27 00	 and	 DWORD PTR [edi], 0

; 1114 : 
; 1115 : 			for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)

  00321	83 a5 f8 fd ff
	ff 00		 and	 DWORD PTR _drive$30237[ebp], 0
$LL243@ProcessMai:

; 1116 : 			{
; 1117 : 				PEXTENSION ListExtension;
; 1118 : 				
; 1119 : 				ListDevice = GetVirtualVolumeDeviceObject (drive);

  00328	ff b5 f8 fd ff
	ff		 push	 DWORD PTR _drive$30237[ebp]
  0032e	e8 00 00 00 00	 call	 _GetVirtualVolumeDeviceObject@4

; 1120 : 				if (!ListDevice)

  00333	85 c0		 test	 eax, eax
  00335	0f 84 b7 00 00
	00		 je	 $LN84@ProcessMai

; 1121 : 					continue;
; 1122 : 
; 1123 : 				ListExtension = (PEXTENSION) ListDevice->DeviceExtension;

  0033b	8b 70 28	 mov	 esi, DWORD PTR [eax+40]

; 1124 : 				if (IsVolumeAccessibleByCurrentUser (ListExtension))

  0033e	56		 push	 esi
  0033f	e8 00 00 00 00	 call	 _IsVolumeAccessibleByCurrentUser@4
  00344	85 c0		 test	 eax, eax
  00346	0f 84 a6 00 00
	00		 je	 $LN84@ProcessMai

; 1125 : 				{
; 1126 : 					list->ulMountedDrives |= (1 << ListExtension->nDosDriveNo);

  0034c	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0034f	33 c0		 xor	 eax, eax
  00351	40		 inc	 eax
  00352	d3 e0		 shl	 eax, cl

; 1127 : 					wcscpy (list->wszVolume[ListExtension->nDosDriveNo], ListExtension->wszVolume);

  00354	8d 8e 60 02 00
	00		 lea	 ecx, DWORD PTR [esi+608]
  0035a	09 07		 or	 DWORD PTR [edi], eax
  0035c	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0035f	69 c0 08 02 00
	00		 imul	 eax, 520		; 00000208H
  00365	8d 54 38 04	 lea	 edx, DWORD PTR [eax+edi+4]
$LL150@ProcessMai:
  00369	0f b7 01	 movzx	 eax, WORD PTR [ecx]
  0036c	41		 inc	 ecx
  0036d	66 89 02	 mov	 WORD PTR [edx], ax
  00370	41		 inc	 ecx
  00371	42		 inc	 edx
  00372	42		 inc	 edx
  00373	66 85 c0	 test	 ax, ax
  00376	75 f1		 jne	 SHORT $LL150@ProcessMai

; 1128 : 					list->diskLength[ListExtension->nDosDriveNo] = ListExtension->DiskLength;

  00378	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0037b	8b 4e 70	 mov	 ecx, DWORD PTR [esi+112]
  0037e	89 8c c7 d4 34
	00 00		 mov	 DWORD PTR [edi+eax*8+13524], ecx
  00385	8b 4e 74	 mov	 ecx, DWORD PTR [esi+116]
  00388	89 8c c7 d8 34
	00 00		 mov	 DWORD PTR [edi+eax*8+13528], ecx

; 1129 : 					list->ea[ListExtension->nDosDriveNo] = ListExtension->cryptoInfo->ea;

  0038f	8b 46 60	 mov	 eax, DWORD PTR [esi+96]
  00392	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00395	8b 00		 mov	 eax, DWORD PTR [eax]
  00397	89 84 8f a4 35
	00 00		 mov	 DWORD PTR [edi+ecx*4+13732], eax

; 1130 : 					if (ListExtension->cryptoInfo->hiddenVolume)

  0039e	8b 46 60	 mov	 eax, DWORD PTR [esi+96]
  003a1	33 c9		 xor	 ecx, ecx
  003a3	39 88 a0 29 00
	00		 cmp	 DWORD PTR [eax+10656], ecx
  003a9	74 10		 je	 SHORT $LN80@ProcessMai

; 1131 : 						list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_HIDDEN;	// Hidden volume

  003ab	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  003ae	c7 84 87 0c 36
	00 00 01 00 00
	00		 mov	 DWORD PTR [edi+eax*4+13836], 1
  003b9	eb 37		 jmp	 SHORT $LN84@ProcessMai
$LN80@ProcessMai:

; 1132 : 					else if (ListExtension->cryptoInfo->bHiddenVolProtectionAction)

  003bb	39 88 04 44 00
	00		 cmp	 DWORD PTR [eax+17412], ecx
  003c1	74 10		 je	 SHORT $LN78@ProcessMai

; 1133 : 						list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_OUTER_VOL_WRITE_PREVENTED;	// Normal/outer volume (hidden volume protected AND write already prevented)

  003c3	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  003c6	c7 84 87 0c 36
	00 00 03 00 00
	00		 mov	 DWORD PTR [edi+eax*4+13836], 3
  003d1	eb 1f		 jmp	 SHORT $LN84@ProcessMai
$LN78@ProcessMai:

; 1134 : 					else if (ListExtension->cryptoInfo->bProtectHiddenVolume)

  003d3	39 88 00 44 00
	00		 cmp	 DWORD PTR [eax+17408], ecx

; 1135 : 						list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_OUTER;	// Normal/outer volume (hidden volume protected)

  003d9	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  003dc	74 0d		 je	 SHORT $LN76@ProcessMai
  003de	c7 84 87 0c 36
	00 00 02 00 00
	00		 mov	 DWORD PTR [edi+eax*4+13836], 2

; 1136 : 					else

  003e9	eb 07		 jmp	 SHORT $LN84@ProcessMai
$LN76@ProcessMai:

; 1137 : 						list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_NORMAL;	// Normal volume

  003eb	89 8c 87 0c 36
	00 00		 mov	 DWORD PTR [edi+eax*4+13836], ecx
$LN84@ProcessMai:

; 1114 : 
; 1115 : 			for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)

  003f2	ff 85 f8 fd ff
	ff		 inc	 DWORD PTR _drive$30237[ebp]
  003f8	83 bd f8 fd ff
	ff 19		 cmp	 DWORD PTR _drive$30237[ebp], 25 ; 00000019H
  003ff	0f 8e 23 ff ff
	ff		 jle	 $LL243@ProcessMai

; 1138 : 				}
; 1139 : 			}
; 1140 : 
; 1141 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00405	83 63 18 00	 and	 DWORD PTR [ebx+24], 0

; 1142 : 			Irp->IoStatus.Information = sizeof (MOUNT_LIST_STRUCT);

  00409	c7 43 1c 74 36
	00 00		 mov	 DWORD PTR [ebx+28], 13940 ; 00003674H

; 1143 : 		}
; 1144 : 		break;

  00410	e9 9c 0a 00 00	 jmp	 $LN10@ProcessMai
$LN28@ProcessMai:

; 1393 : 
; 1394 : 	case TC_IOCTL_DISMOUNT_ALL_VOLUMES:
; 1395 : 		if (ValidateIOBufferSize (Irp, sizeof (UNMOUNT_STRUCT), ValidateInputOutput))

  00415	6a 02		 push	 2
  00417	6a 10		 push	 16			; 00000010H
  00419	5f		 pop	 edi
  0041a	57		 push	 edi
  0041b	53		 push	 ebx
  0041c	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00421	85 c0		 test	 eax, eax
  00423	0f 84 88 0a 00
	00		 je	 $LN10@ProcessMai

; 1396 : 		{
; 1397 : 			UNMOUNT_STRUCT *unmount = (UNMOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  00429	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]

; 1398 : 
; 1399 : 			unmount->nReturnCode = UnmountAllDevices (unmount, unmount->ignoreOpenFiles);

  0042c	ff 76 04	 push	 DWORD PTR [esi+4]
  0042f	56		 push	 esi
  00430	e8 00 00 00 00	 call	 _UnmountAllDevices@8
  00435	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 1400 : 
; 1401 : 			Irp->IoStatus.Information = sizeof (UNMOUNT_STRUCT);

  00438	89 7b 1c	 mov	 DWORD PTR [ebx+28], edi

; 1402 : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 1403 : 		}
; 1404 : 		break;

  0043b	eb 49		 jmp	 SHORT $LN262@ProcessMai
$LN32@ProcessMai:

; 1370 : 		}
; 1371 : 		break;
; 1372 : 
; 1373 : 	case TC_IOCTL_DISMOUNT_VOLUME:
; 1374 : 		if (ValidateIOBufferSize (Irp, sizeof (UNMOUNT_STRUCT), ValidateInputOutput))

  0043d	6a 02		 push	 2
  0043f	6a 10		 push	 16			; 00000010H
  00441	53		 push	 ebx
  00442	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00447	85 c0		 test	 eax, eax
  00449	0f 84 62 0a 00
	00		 je	 $LN10@ProcessMai

; 1375 : 		{
; 1376 : 			UNMOUNT_STRUCT *unmount = (UNMOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  0044f	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]

; 1377 : 			PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject (unmount->nDosDriveNo);

  00452	ff 36		 push	 DWORD PTR [esi]
  00454	e8 00 00 00 00	 call	 _GetVirtualVolumeDeviceObject@4
  00459	8b f8		 mov	 edi, eax

; 1378 : 
; 1379 : 			unmount->nReturnCode = ERR_DRIVE_NOT_FOUND;

  0045b	c7 46 0c 05 00
	00 00		 mov	 DWORD PTR [esi+12], 5

; 1380 : 
; 1381 : 			if (ListDevice)

  00462	85 ff		 test	 edi, edi
  00464	74 19		 je	 SHORT $LN240@ProcessMai

; 1382 : 			{
; 1383 : 				PEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;
; 1384 : 
; 1385 : 				if (IsVolumeAccessibleByCurrentUser (ListExtension))

  00466	ff 77 28	 push	 DWORD PTR [edi+40]
  00469	e8 00 00 00 00	 call	 _IsVolumeAccessibleByCurrentUser@4
  0046e	85 c0		 test	 eax, eax
  00470	74 0d		 je	 SHORT $LN240@ProcessMai

; 1386 : 					unmount->nReturnCode = UnmountDevice (unmount, ListDevice, unmount->ignoreOpenFiles);

  00472	ff 76 04	 push	 DWORD PTR [esi+4]
  00475	57		 push	 edi
  00476	56		 push	 esi
  00477	e8 00 00 00 00	 call	 _UnmountDevice@12
  0047c	89 46 0c	 mov	 DWORD PTR [esi+12], eax
$LN240@ProcessMai:

; 1387 : 			}
; 1388 : 
; 1389 : 			Irp->IoStatus.Information = sizeof (UNMOUNT_STRUCT);

  0047f	c7 43 1c 10 00
	00 00		 mov	 DWORD PTR [ebx+28], 16	; 00000010H
$LN262@ProcessMai:

; 1390 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00486	83 63 18 00	 and	 DWORD PTR [ebx+24], 0

; 1391 : 		}
; 1392 : 		break;

  0048a	e9 22 0a 00 00	 jmp	 $LN10@ProcessMai
$LN141@ProcessMai:

; 824  : 
; 825  : 	case TC_IOCTL_GET_DEVICE_REFCOUNT:
; 826  : 		if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))

  0048f	6a 01		 push	 1
  00491	6a 04		 push	 4
  00493	5e		 pop	 esi
  00494	56		 push	 esi
  00495	53		 push	 ebx
  00496	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  0049b	85 c0		 test	 eax, eax
  0049d	0f 84 0e 0a 00
	00		 je	 $LN10@ProcessMai

; 827  : 		{
; 828  : 			*(int *) Irp->AssociatedIrp.SystemBuffer = DeviceObject->ReferenceCount;

  004a3	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR _DeviceObject$GSCopy$[ebp]
  004a9	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  004ac	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  004af	89 08		 mov	 DWORD PTR [eax], ecx

; 829  : 			Irp->IoStatus.Information = sizeof (int);
; 830  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 831  : 		}
; 832  : 		break;

  004b1	e9 f0 fb ff ff	 jmp	 $LN257@ProcessMai
$LN153@ProcessMai:

; 810  : 	NTSTATUS ntStatus;
; 811  : 
; 812  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  004b6	b9 34 20 22 00	 mov	 ecx, 2236468		; 00222034H
  004bb	3b c1		 cmp	 eax, ecx
  004bd	0f 87 33 03 00
	00		 ja	 $LN155@ProcessMai
  004c3	0f 84 e2 00 00
	00		 je	 $LN129@ProcessMai
  004c9	2d 24 20 22 00	 sub	 eax, 2236452		; 00222024H
  004ce	0f 84 80 00 00
	00		 je	 $LN139@ProcessMai
  004d4	6a 04		 push	 4
  004d6	5e		 pop	 esi
  004d7	2b c6		 sub	 eax, esi
  004d9	74 31		 je	 SHORT $LN136@ProcessMai
  004db	2b c6		 sub	 eax, esi
  004dd	74 1a		 je	 SHORT $LN92@ProcessMai
  004df	2b c6		 sub	 eax, esi
  004e1	0f 85 11 09 00
	00		 jne	 $LN1@ProcessMai

; 1068 : 			{
; 1069 : 				Irp->IoStatus.Status = ntStatus;
; 1070 : 				Irp->IoStatus.Information = 0;
; 1071 : 			}
; 1072 : 		}
; 1073 : 		break;
; 1074 : 
; 1075 : 	case TC_IOCTL_WIPE_PASSWORD_CACHE:
; 1076 : 		WipeCache ();

  004e7	e8 00 00 00 00	 call	 _WipeCache@0
$LN265@ProcessMai:

; 1077 : 
; 1078 : 		Irp->IoStatus.Status = STATUS_SUCCESS;

  004ec	83 63 18 00	 and	 DWORD PTR [ebx+24], 0
$LN260@ProcessMai:

; 1079 : 		Irp->IoStatus.Information = 0;

  004f0	83 63 1c 00	 and	 DWORD PTR [ebx+28], 0

; 1080 : 		break;

  004f4	e9 b8 09 00 00	 jmp	 $LN10@ProcessMai
$LN92@ProcessMai:

; 1081 : 
; 1082 : 	case TC_IOCTL_GET_PASSWORD_CACHE_STATUS:
; 1083 : 		Irp->IoStatus.Status = cacheEmpty ? STATUS_PIPE_EMPTY : STATUS_SUCCESS;

  004f9	a1 00 00 00 00	 mov	 eax, DWORD PTR _cacheEmpty
  004fe	f7 d8		 neg	 eax
  00500	1b c0		 sbb	 eax, eax
  00502	25 d9 00 00 c0	 and	 eax, -1073741607	; c00000d9H
$LN264@ProcessMai:
  00507	89 43 18	 mov	 DWORD PTR [ebx+24], eax

; 1084 : 		Irp->IoStatus.Information = 0;
; 1085 : 		break;

  0050a	eb e4		 jmp	 SHORT $LN260@ProcessMai
$LN136@ProcessMai:

; 848  : 
; 849  : 	case TC_IOCTL_IS_ANY_VOLUME_MOUNTED:
; 850  : 		if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))

  0050c	33 ff		 xor	 edi, edi
  0050e	47		 inc	 edi
  0050f	57		 push	 edi
  00510	56		 push	 esi
  00511	53		 push	 ebx
  00512	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00517	85 c0		 test	 eax, eax
  00519	0f 84 92 09 00
	00		 je	 $LN10@ProcessMai

; 851  : 		{
; 852  : 			int drive;
; 853  : 			*(int *) Irp->AssociatedIrp.SystemBuffer = 0;

  0051f	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00522	33 c9		 xor	 ecx, ecx
  00524	89 08		 mov	 DWORD PTR [eax], ecx
$LL134@ProcessMai:

; 854  : 
; 855  : 			for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)
; 856  : 			{
; 857  : 				if (GetVirtualVolumeDeviceObject (drive))

  00526	51		 push	 ecx
  00527	e8 00 00 00 00	 call	 _GetVirtualVolumeDeviceObject@4
  0052c	85 c0		 test	 eax, eax
  0052e	75 08		 jne	 SHORT $LN194@ProcessMai
  00530	41		 inc	 ecx
  00531	83 f9 19	 cmp	 ecx, 25			; 00000019H
  00534	7e f0		 jle	 SHORT $LL134@ProcessMai

; 1040 : 					{
; 1041 : 						if (memcmp (readBuffer + i, TC_APP_NAME_LEGACY, strlen (TC_APP_NAME_LEGACY)) == 0)

  00536	eb 05		 jmp	 SHORT $LN132@ProcessMai
$LN194@ProcessMai:

; 858  : 				{
; 859  : 					*(int *) Irp->AssociatedIrp.SystemBuffer = 1;

  00538	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0053b	89 38		 mov	 DWORD PTR [eax], edi
$LN132@ProcessMai:

; 860  : 					break;
; 861  : 				}
; 862  : 			}
; 863  : 
; 864  : 			if (IsBootDriveMounted())

  0053d	e8 00 00 00 00	 call	 _IsBootDriveMounted@0
  00542	85 c0		 test	 eax, eax
  00544	0f 84 5c fb ff
	ff		 je	 $LN257@ProcessMai
$LN263@ProcessMai:

; 865  : 				*(int *) Irp->AssociatedIrp.SystemBuffer = 1;

  0054a	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0054d	89 38		 mov	 DWORD PTR [eax], edi

; 866  : 
; 867  : 			Irp->IoStatus.Information = sizeof (int);
; 868  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 869  : 		}
; 870  : 		break;

  0054f	e9 52 fb ff ff	 jmp	 $LN257@ProcessMai
$LN139@ProcessMai:

; 833  : 
; 834  : 	case TC_IOCTL_IS_DRIVER_UNLOAD_DISABLED:
; 835  : 		if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))

  00554	33 ff		 xor	 edi, edi
  00556	47		 inc	 edi
  00557	57		 push	 edi
  00558	6a 04		 push	 4
  0055a	5e		 pop	 esi
  0055b	56		 push	 esi
  0055c	53		 push	 ebx
  0055d	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00562	85 c0		 test	 eax, eax
  00564	0f 84 47 09 00
	00		 je	 $LN10@ProcessMai

; 836  : 		{
; 837  : 			LONG deviceObjectCount = 0;
; 838  : 
; 839  : 			*(int *) Irp->AssociatedIrp.SystemBuffer = DriverUnloadDisabled;

  0056a	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  0056d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _DriverUnloadDisabled
  00573	33 c0		 xor	 eax, eax
  00575	89 85 f0 fd ff
	ff		 mov	 DWORD PTR _deviceObjectCount$30104[ebp], eax
  0057b	89 11		 mov	 DWORD PTR [ecx], edx

; 840  : 
; 841  : 			if (IoEnumerateDeviceObjectList (TCDriverObject, NULL, 0, &deviceObjectCount) == STATUS_BUFFER_TOO_SMALL && deviceObjectCount > 1)

  0057d	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _deviceObjectCount$30104[ebp]
  00583	51		 push	 ecx
  00584	50		 push	 eax
  00585	50		 push	 eax
  00586	ff 35 00 00 00
	00		 push	 DWORD PTR _TCDriverObject
  0058c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoEnumerateDeviceObjectList@16
  00592	3d 23 00 00 c0	 cmp	 eax, -1073741789	; c0000023H
  00597	0f 85 09 fb ff
	ff		 jne	 $LN257@ProcessMai
  0059d	39 bd f0 fd ff
	ff		 cmp	 DWORD PTR _deviceObjectCount$30104[ebp], edi
  005a3	0f 8e fd fa ff
	ff		 jle	 $LN257@ProcessMai

; 842  : 				*(int *) Irp->AssociatedIrp.SystemBuffer = TRUE;
; 843  : 
; 844  : 			Irp->IoStatus.Information = sizeof (int);
; 845  : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 846  : 		}
; 847  : 		break;

  005a9	eb 9f		 jmp	 SHORT $LN263@ProcessMai
$LN129@ProcessMai:

; 871  : 
; 872  : 	case TC_IOCTL_OPEN_TEST:
; 873  : 		{
; 874  : 			OPEN_TEST_STRUCT *opentest = (OPEN_TEST_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  005ab	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]

; 875  : 			OBJECT_ATTRIBUTES ObjectAttributes;
; 876  : 			HANDLE NtFileHandle;
; 877  : 			UNICODE_STRING FullFileName;
; 878  : 			IO_STATUS_BLOCK IoStatus;
; 879  : 			LARGE_INTEGER offset;
; 880  : 			ACCESS_MASK access = FILE_READ_ATTRIBUTES;
; 881  : 
; 882  : 			if (!ValidateIOBufferSize (Irp, sizeof (OPEN_TEST_STRUCT), ValidateInputOutput))

  005ae	6a 02		 push	 2
  005b0	68 18 02 00 00	 push	 536			; 00000218H
  005b5	53		 push	 ebx
  005b6	89 b5 f0 fd ff
	ff		 mov	 DWORD PTR _opentest$30127[ebp], esi
  005bc	c7 85 f4 fd ff
	ff 80 00 00 00	 mov	 DWORD PTR _access$30134[ebp], 128 ; 00000080H
  005c6	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  005cb	85 c0		 test	 eax, eax
  005cd	0f 84 de 08 00
	00		 je	 $LN10@ProcessMai

; 883  : 				break;
; 884  : 
; 885  : 			EnsureNullTerminatedString (opentest->wszFileName, sizeof (opentest->wszFileName));

  005d3	33 c0		 xor	 eax, eax
  005d5	66 89 86 06 02
	00 00		 mov	 WORD PTR [esi+518], ax

; 886  : 			RtlInitUnicodeString (&FullFileName, opentest->wszFileName);

  005dc	56		 push	 esi
  005dd	8d 85 7c fd ff
	ff		 lea	 eax, DWORD PTR _FullFileName$30131[ebp]
  005e3	50		 push	 eax
  005e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 887  : 
; 888  : 			InitializeObjectAttributes (&ObjectAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

  005ea	33 ff		 xor	 edi, edi
  005ec	8d 85 7c fd ff
	ff		 lea	 eax, DWORD PTR _FullFileName$30131[ebp]
  005f2	c7 85 ac fd ff
	ff 18 00 00 00	 mov	 DWORD PTR _ObjectAttributes$30129[ebp], 24 ; 00000018H
  005fc	89 bd b0 fd ff
	ff		 mov	 DWORD PTR _ObjectAttributes$30129[ebp+4], edi
  00602	c7 85 b8 fd ff
	ff 40 02 00 00	 mov	 DWORD PTR _ObjectAttributes$30129[ebp+12], 576 ; 00000240H
  0060c	89 85 b4 fd ff
	ff		 mov	 DWORD PTR _ObjectAttributes$30129[ebp+8], eax
  00612	89 bd bc fd ff
	ff		 mov	 DWORD PTR _ObjectAttributes$30129[ebp+16], edi
  00618	89 bd c0 fd ff
	ff		 mov	 DWORD PTR _ObjectAttributes$30129[ebp+20], edi

; 889  : 
; 890  : 			if (opentest->bDetectTCBootLoader || opentest->DetectFilesystem)

  0061e	39 be 08 02 00
	00		 cmp	 DWORD PTR [esi+520], edi
  00624	75 08		 jne	 SHORT $LN126@ProcessMai
  00626	39 be 10 02 00
	00		 cmp	 DWORD PTR [esi+528], edi
  0062c	74 0a		 je	 SHORT $LN127@ProcessMai
$LN126@ProcessMai:

; 891  : 				access |= FILE_READ_DATA;

  0062e	c7 85 f4 fd ff
	ff 81 00 00 00	 mov	 DWORD PTR _access$30134[ebp], 129 ; 00000081H
$LN127@ProcessMai:

; 892  : 
; 893  : 			ntStatus = ZwCreateFile (&NtFileHandle,
; 894  : 						 SYNCHRONIZE | access, &ObjectAttributes, &IoStatus, NULL,
; 895  : 						 0, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);

  00638	57		 push	 edi
  00639	57		 push	 edi
  0063a	6a 20		 push	 32			; 00000020H
  0063c	6a 01		 push	 1
  0063e	6a 03		 push	 3
  00640	57		 push	 edi
  00641	57		 push	 edi
  00642	8d 85 e0 fd ff
	ff		 lea	 eax, DWORD PTR _IoStatus$30132[ebp]
  00648	50		 push	 eax
  00649	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR _ObjectAttributes$30129[ebp]
  0064f	50		 push	 eax
  00650	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _access$30134[ebp]
  00656	0d 00 00 10 00	 or	 eax, 1048576		; 00100000H
  0065b	50		 push	 eax
  0065c	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _NtFileHandle$30130[ebp]
  00662	50		 push	 eax
  00663	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwCreateFile@44

; 896  : 
; 897  : 			if (NT_SUCCESS (ntStatus))

  00669	3b c7		 cmp	 eax, edi
  0066b	89 85 f4 fd ff
	ff		 mov	 DWORD PTR _ntStatus$[ebp], eax
  00671	0f 8c 6e 01 00
	00		 jl	 $LN238@ProcessMai

; 898  : 			{
; 899  : 				opentest->TCBootLoaderDetected = FALSE;

  00677	89 be 0c 02 00
	00		 mov	 DWORD PTR [esi+524], edi

; 900  : 				opentest->FilesystemDetected = FALSE;

  0067d	89 be 14 02 00
	00		 mov	 DWORD PTR [esi+532], edi

; 901  : 
; 902  : 				if (opentest->bDetectTCBootLoader || opentest->DetectFilesystem)

  00683	39 be 08 02 00
	00		 cmp	 DWORD PTR [esi+520], edi
  00689	75 0c		 jne	 SHORT $LN123@ProcessMai
  0068b	39 be 10 02 00
	00		 cmp	 DWORD PTR [esi+528], edi
  00691	0f 84 35 01 00
	00		 je	 $LN237@ProcessMai
$LN123@ProcessMai:

; 903  : 				{
; 904  : 					byte *readBuffer = TCalloc (TC_MAX_VOLUME_SECTOR_SIZE);

  00697	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0069c	68 00 10 00 00	 push	 4096			; 00001000H
  006a1	57		 push	 edi
  006a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  006a8	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _readBuffer$30149[ebp], eax

; 905  : 					if (!readBuffer)

  006ae	3b c7		 cmp	 eax, edi
  006b0	75 0f		 jne	 SHORT $LN122@ProcessMai

; 906  : 					{
; 907  : 						ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  006b2	c7 85 f4 fd ff
	ff 9a 00 00 c0	 mov	 DWORD PTR _ntStatus$[ebp], -1073741670 ; c000009aH

; 908  : 					}
; 909  : 					else

  006bc	e9 0b 01 00 00	 jmp	 $LN237@ProcessMai
$LN122@ProcessMai:

; 910  : 					{
; 911  : 						// Determine if the first sector contains a portion of the TrueCrypt Boot Loader
; 912  : 
; 913  : 						offset.QuadPart = 0;
; 914  : 
; 915  : 						ntStatus = ZwReadFile (NtFileHandle,
; 916  : 							NULL,
; 917  : 							NULL,
; 918  : 							NULL,
; 919  : 							&IoStatus,
; 920  : 							readBuffer,
; 921  : 							TC_MAX_VOLUME_SECTOR_SIZE,
; 922  : 							&offset,
; 923  : 							NULL);

  006c1	57		 push	 edi
  006c2	8d 85 c4 fd ff
	ff		 lea	 eax, DWORD PTR _offset$30133[ebp]
  006c8	50		 push	 eax
  006c9	68 00 10 00 00	 push	 4096			; 00001000H
  006ce	ff b5 f8 fd ff
	ff		 push	 DWORD PTR _readBuffer$30149[ebp]
  006d4	8d 85 e0 fd ff
	ff		 lea	 eax, DWORD PTR _IoStatus$30132[ebp]
  006da	50		 push	 eax
  006db	57		 push	 edi
  006dc	57		 push	 edi
  006dd	57		 push	 edi
  006de	ff b5 ec fd ff
	ff		 push	 DWORD PTR _NtFileHandle$30130[ebp]
  006e4	89 bd c4 fd ff
	ff		 mov	 DWORD PTR _offset$30133[ebp], edi
  006ea	89 bd c8 fd ff
	ff		 mov	 DWORD PTR _offset$30133[ebp+4], edi
  006f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwReadFile@36

; 924  : 
; 925  : 						if (NT_SUCCESS (ntStatus))

  006f6	3b c7		 cmp	 eax, edi
  006f8	89 85 f4 fd ff
	ff		 mov	 DWORD PTR _ntStatus$[ebp], eax
  006fe	0f 8c b7 00 00
	00		 jl	 $LN112@ProcessMai

; 926  : 						{
; 927  : 							size_t i;
; 928  : 
; 929  : 							if (opentest->bDetectTCBootLoader && IoStatus.Information >= TC_SECTOR_SIZE_BIOS)

  00704	39 be 08 02 00
	00		 cmp	 DWORD PTR [esi+520], edi
  0070a	74 49		 je	 SHORT $LN234@ProcessMai
  0070c	81 bd e4 fd ff
	ff 00 02 00 00	 cmp	 DWORD PTR _IoStatus$30132[ebp+4], 512 ; 00000200H
  00716	72 3d		 jb	 SHORT $LN234@ProcessMai

; 930  : 							{
; 931  : 								// Search for the string "TrueCrypt"
; 932  : 								for (i = 0; i < TC_SECTOR_SIZE_BIOS - strlen (TC_APP_NAME_LEGACY); ++i)

  00718	33 c0		 xor	 eax, eax
$LL241@ProcessMai:

; 933  : 								{
; 934  : 									if (memcmp (readBuffer + i, TC_APP_NAME_LEGACY, strlen (TC_APP_NAME_LEGACY)) == 0)

  0071a	8b 95 f8 fd ff
	ff		 mov	 edx, DWORD PTR _readBuffer$30149[ebp]
  00720	6a 09		 push	 9
  00722	8d 34 10	 lea	 esi, DWORD PTR [eax+edx]
  00725	59		 pop	 ecx
  00726	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_09EMKKFGIH@TrueCrypt?$AA@FNODOBFM@
  0072b	33 d2		 xor	 edx, edx
  0072d	f3 a6		 repe cmpsb
  0072f	74 10		 je	 SHORT $LN195@ProcessMai
  00731	40		 inc	 eax
  00732	3d f7 01 00 00	 cmp	 eax, 503		; 000001f7H
  00737	72 e1		 jb	 SHORT $LL241@ProcessMai

; 1040 : 					{
; 1041 : 						if (memcmp (readBuffer + i, TC_APP_NAME_LEGACY, strlen (TC_APP_NAME_LEGACY)) == 0)

  00739	8b b5 f0 fd ff
	ff		 mov	 esi, DWORD PTR _opentest$30127[ebp]
  0073f	eb 12		 jmp	 SHORT $LN255@ProcessMai
$LN195@ProcessMai:

; 935  : 									{
; 936  : 										opentest->TCBootLoaderDetected = TRUE;

  00741	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _opentest$30127[ebp]
  00747	c7 80 0c 02 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+524], 1
  00751	8b f0		 mov	 esi, eax
$LN255@ProcessMai:
  00753	33 ff		 xor	 edi, edi
$LN234@ProcessMai:

; 937  : 										break;
; 938  : 									}
; 939  : 								}
; 940  : 							}
; 941  : 
; 942  : 							if (opentest->DetectFilesystem && IoStatus.Information >= sizeof (int64))

  00755	39 be 10 02 00
	00		 cmp	 DWORD PTR [esi+528], edi
  0075b	74 5e		 je	 SHORT $LN112@ProcessMai
  0075d	83 bd e4 fd ff
	ff 08		 cmp	 DWORD PTR _IoStatus$30132[ebp+4], 8
  00764	72 55		 jb	 SHORT $LN112@ProcessMai

; 943  : 							{
; 944  : 								switch (BE64 (*(uint64 *) readBuffer))

  00766	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR _readBuffer$30149[ebp]
  0076c	ff 70 04	 push	 DWORD PTR [eax+4]
  0076f	ff 30		 push	 DWORD PTR [eax]
  00771	e8 00 00 00 00	 call	 _MirrorBytes64@8
  00776	b9 53 4f 44 53	 mov	 ecx, 1396985683		; 53444f53H
  0077b	3b c1		 cmp	 eax, ecx
  0077d	75 08		 jne	 SHORT $LN220@ProcessMai
  0077f	81 fa 4d 90 3c
	eb		 cmp	 edx, -348352435		; eb3c904dH
  00785	74 2a		 je	 SHORT $LN111@ProcessMai
$LN220@ProcessMai:
  00787	3d 20 53 46 54	 cmp	 eax, 1413894944		; 54465320H
  0078c	75 08		 jne	 SHORT $LN221@ProcessMai
  0078e	81 fa 4e 90 52
	eb		 cmp	 edx, -346910642		; eb52904eH
  00794	74 1b		 je	 SHORT $LN111@ProcessMai
$LN221@ProcessMai:
  00796	3b c1		 cmp	 eax, ecx
  00798	75 08		 jne	 SHORT $LN222@ProcessMai
  0079a	81 fa 4d 90 58
	eb		 cmp	 edx, -346517427		; eb58904dH
  007a0	74 0f		 je	 SHORT $LN111@ProcessMai
$LN222@ProcessMai:
  007a2	3d 54 41 46 58	 cmp	 eax, 1480999252		; 58464154H
  007a7	75 12		 jne	 SHORT $LN112@ProcessMai
  007a9	81 fa 45 90 76
	eb		 cmp	 edx, -344551355		; eb769045H
  007af	75 0a		 jne	 SHORT $LN112@ProcessMai
$LN111@ProcessMai:

; 945  : 								{
; 946  : 								case 0xEB52904E54465320: // NTFS
; 947  : 								case 0xEB3C904D53444F53: // FAT16
; 948  : 								case 0xEB58904D53444F53: // FAT32
; 949  : 								case 0xEB76904558464154: // exFAT
; 950  : 
; 951  : 									opentest->FilesystemDetected = TRUE;

  007b1	c7 86 14 02 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+532], 1
$LN112@ProcessMai:

; 952  : 									break;
; 953  : 								}
; 954  : 							}
; 955  : 						}
; 956  : 
; 957  : 						TCfree (readBuffer);

  007bb	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  007c0	ff b5 f8 fd ff
	ff		 push	 DWORD PTR _readBuffer$30149[ebp]
  007c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN237@ProcessMai:

; 958  : 					}
; 959  : 				}
; 960  : 
; 961  : 				ZwClose (NtFileHandle);

  007cc	ff b5 ec fd ff
	ff		 push	 DWORD PTR _NtFileHandle$30130[ebp]
  007d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 962  : 				Dump ("Open test on file %ls success.\n", opentest->wszFileName);
; 963  : 			}
; 964  : 			else
; 965  : 			{
; 966  : #if 0
; 967  : 				Dump ("Open test on file %ls failed NTSTATUS 0x%08x\n", opentest->wszFileName, ntStatus);
; 968  : #endif
; 969  : 			}
; 970  : 
; 971  : 			Irp->IoStatus.Information = NT_SUCCESS (ntStatus) ? sizeof (OPEN_TEST_STRUCT) : 0;

  007d8	39 bd f4 fd ff
	ff		 cmp	 DWORD PTR _ntStatus$[ebp], edi
  007de	7c 05		 jl	 SHORT $LN238@ProcessMai
  007e0	bf 18 02 00 00	 mov	 edi, 536		; 00000218H
$LN238@ProcessMai:

; 972  : 			Irp->IoStatus.Status = ntStatus;

  007e5	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _ntStatus$[ebp]
  007eb	89 7b 1c	 mov	 DWORD PTR [ebx+28], edi
$LN259@ProcessMai:
  007ee	89 43 18	 mov	 DWORD PTR [ebx+24], eax

; 973  : 		}
; 974  : 		break;

  007f1	e9 bb 06 00 00	 jmp	 $LN10@ProcessMai
$LN155@ProcessMai:

; 810  : 	NTSTATUS ntStatus;
; 811  : 
; 812  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  007f6	2d 38 20 22 00	 sub	 eax, 2236472		; 00222038H
  007fb	0f 84 4c 01 00
	00		 je	 $LN64@ProcessMai
  00801	6a 04		 push	 4
  00803	5e		 pop	 esi
  00804	2b c6		 sub	 eax, esi
  00806	0f 84 02 01 00
	00		 je	 $LN55@ProcessMai
  0080c	2b c6		 sub	 eax, esi
  0080e	74 44		 je	 SHORT $LN53@ProcessMai
  00810	2b c6		 sub	 eax, esi
  00812	0f 85 e0 05 00
	00		 jne	 $LN1@ProcessMai

; 1208 : 
; 1209 : 	case TC_IOCTL_GET_RESOLVED_SYMLINK:
; 1210 : 		if (ValidateIOBufferSize (Irp, sizeof (RESOLVE_SYMLINK_STRUCT), ValidateInputOutput))

  00818	6a 02		 push	 2
  0081a	be 10 04 00 00	 mov	 esi, 1040		; 00000410H
  0081f	56		 push	 esi
  00820	53		 push	 ebx
  00821	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00826	85 c0		 test	 eax, eax
  00828	0f 84 83 06 00
	00		 je	 $LN10@ProcessMai

; 1211 : 		{
; 1212 : 			RESOLVE_SYMLINK_STRUCT *resolve = (RESOLVE_SYMLINK_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  0082e	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]

; 1213 : 			{
; 1214 : 				NTSTATUS ntStatus;
; 1215 : 
; 1216 : 				EnsureNullTerminatedString (resolve->symLinkName, sizeof (resolve->symLinkName));

  00831	33 c9		 xor	 ecx, ecx
  00833	66 89 88 06 02
	00 00		 mov	 WORD PTR [eax+518], cx

; 1217 : 
; 1218 : 				ntStatus = SymbolicLinkToTarget (resolve->symLinkName,
; 1219 : 					resolve->targetName,
; 1220 : 					sizeof (resolve->targetName));

  0083a	68 08 02 00 00	 push	 520			; 00000208H
  0083f	8d 88 08 02 00
	00		 lea	 ecx, DWORD PTR [eax+520]
  00845	51		 push	 ecx
  00846	50		 push	 eax
  00847	e8 00 00 00 00	 call	 _SymbolicLinkToTarget@12
$LN258@ProcessMai:

; 1221 : 
; 1222 : 				Irp->IoStatus.Information = sizeof (RESOLVE_SYMLINK_STRUCT);
; 1223 : 				Irp->IoStatus.Status = ntStatus;

  0084c	89 43 18	 mov	 DWORD PTR [ebx+24], eax

; 1224 : 			}
; 1225 : 		}
; 1226 : 		break;

  0084f	e9 5a 06 00 00	 jmp	 $LN254@ProcessMai
$LN53@ProcessMai:

; 1307 : 
; 1308 : 	case TC_IOCTL_PROBE_REAL_DRIVE_SIZE:
; 1309 : 		if (ValidateIOBufferSize (Irp, sizeof (ProbeRealDriveSizeRequest), ValidateInputOutput))

  00854	6a 02		 push	 2
  00856	68 14 02 00 00	 push	 532			; 00000214H
  0085b	53		 push	 ebx
  0085c	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00861	85 c0		 test	 eax, eax
  00863	0f 84 48 06 00
	00		 je	 $LN10@ProcessMai

; 1310 : 		{
; 1311 : 			ProbeRealDriveSizeRequest *request = (ProbeRealDriveSizeRequest *) Irp->AssociatedIrp.SystemBuffer;

  00869	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]

; 1312 : 			NTSTATUS status;
; 1313 : 			UNICODE_STRING name;
; 1314 : 			PFILE_OBJECT fileObject;
; 1315 : 			PDEVICE_OBJECT deviceObject;
; 1316 : 
; 1317 : 			EnsureNullTerminatedString (request->DeviceName, sizeof (request->DeviceName));

  0086c	33 c0		 xor	 eax, eax
  0086e	66 89 86 06 02
	00 00		 mov	 WORD PTR [esi+518], ax

; 1318 : 
; 1319 : 			RtlInitUnicodeString (&name, request->DeviceName);

  00875	56		 push	 esi
  00876	8d 85 74 fd ff
	ff		 lea	 eax, DWORD PTR _name$30319[ebp]
  0087c	50		 push	 eax
  0087d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 1320 : 			status = IoGetDeviceObjectPointer (&name, FILE_READ_ATTRIBUTES, &fileObject, &deviceObject);

  00883	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _deviceObject$30321[ebp]
  00889	50		 push	 eax
  0088a	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _fileObject$30320[ebp]
  00890	50		 push	 eax
  00891	68 80 00 00 00	 push	 128			; 00000080H
  00896	8d 85 74 fd ff
	ff		 lea	 eax, DWORD PTR _name$30319[ebp]
  0089c	50		 push	 eax
  0089d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoGetDeviceObjectPointer@16

; 1321 : 			if (!NT_SUCCESS (status))

  008a3	85 c0		 test	 eax, eax
  008a5	7d 09		 jge	 SHORT $LN51@ProcessMai

; 1322 : 			{
; 1323 : 				Irp->IoStatus.Information = 0;

  008a7	83 63 1c 00	 and	 DWORD PTR [ebx+28], 0

; 1324 : 				Irp->IoStatus.Status = status;
; 1325 : 				break;

  008ab	e9 3e ff ff ff	 jmp	 $LN259@ProcessMai
$LN51@ProcessMai:

; 1326 : 			}
; 1327 : 
; 1328 : 			status = ProbeRealDriveSize (deviceObject, &request->RealDriveSize);

  008b0	8d 86 08 02 00
	00		 lea	 eax, DWORD PTR [esi+520]
  008b6	50		 push	 eax
  008b7	ff b5 dc fd ff
	ff		 push	 DWORD PTR _deviceObject$30321[ebp]
  008bd	e8 00 00 00 00	 call	 _ProbeRealDriveSize@8

; 1329 : 			ObDereferenceObject (fileObject);

  008c2	8b 8d e8 fd ff
	ff		 mov	 ecx, DWORD PTR _fileObject$30320[ebp]
  008c8	8b f8		 mov	 edi, eax
  008ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 1330 : 
; 1331 : 			if (status == STATUS_TIMEOUT)

  008d0	81 ff 02 01 00
	00		 cmp	 edi, 258		; 00000102H
  008d6	75 16		 jne	 SHORT $LN50@ProcessMai

; 1332 : 			{
; 1333 : 				request->TimeOut = TRUE;

  008d8	c7 86 10 02 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+528], 1

; 1334 : 				Irp->IoStatus.Information = sizeof (ProbeRealDriveSizeRequest);

  008e2	c7 43 1c 14 02
	00 00		 mov	 DWORD PTR [ebx+28], 532	; 00000214H

; 1335 : 				Irp->IoStatus.Status = STATUS_SUCCESS;

  008e9	e9 98 fb ff ff	 jmp	 $LN262@ProcessMai
$LN50@ProcessMai:

; 1336 : 			}
; 1337 : 			else if (!NT_SUCCESS (status))

  008ee	85 ff		 test	 edi, edi
  008f0	7d 06		 jge	 SHORT $LN48@ProcessMai

; 1338 : 			{
; 1339 : 				Irp->IoStatus.Information = 0;

  008f2	83 63 1c 00	 and	 DWORD PTR [ebx+28], 0

; 1340 : 				Irp->IoStatus.Status = status;
; 1341 : 			}
; 1342 : 			else

  008f6	eb 0e		 jmp	 SHORT $LN261@ProcessMai
$LN48@ProcessMai:

; 1343 : 			{
; 1344 : 				request->TimeOut = FALSE;

  008f8	83 a6 10 02 00
	00 00		 and	 DWORD PTR [esi+528], 0

; 1345 : 				Irp->IoStatus.Information = sizeof (ProbeRealDriveSizeRequest);

  008ff	c7 43 1c 14 02
	00 00		 mov	 DWORD PTR [ebx+28], 532	; 00000214H
$LN261@ProcessMai:

; 1346 : 				Irp->IoStatus.Status = status;

  00906	89 7b 18	 mov	 DWORD PTR [ebx+24], edi

; 1347 : 			}
; 1348 : 		}
; 1349 : 		break;

  00909	e9 a3 05 00 00	 jmp	 $LN10@ProcessMai
$LN55@ProcessMai:

; 1288 : 
; 1289 : 	case TC_IOCTL_GET_DRIVE_GEOMETRY:
; 1290 : 		if (ValidateIOBufferSize (Irp, sizeof (DISK_GEOMETRY_STRUCT), ValidateInputOutput))

  0090e	6a 02		 push	 2
  00910	be 20 02 00 00	 mov	 esi, 544		; 00000220H
  00915	56		 push	 esi
  00916	53		 push	 ebx
  00917	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  0091c	85 c0		 test	 eax, eax
  0091e	0f 84 8d 05 00
	00		 je	 $LN10@ProcessMai

; 1291 : 		{
; 1292 : 			DISK_GEOMETRY_STRUCT *g = (DISK_GEOMETRY_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  00924	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]

; 1293 : 			{
; 1294 : 				NTSTATUS ntStatus;
; 1295 : 
; 1296 : 				EnsureNullTerminatedString (g->deviceName, sizeof (g->deviceName));

  00927	33 c9		 xor	 ecx, ecx

; 1297 : 
; 1298 : 				ntStatus = TCDeviceIoControl (g->deviceName,
; 1299 : 					IOCTL_DISK_GET_DRIVE_GEOMETRY,
; 1300 : 					NULL, 0, &g->diskGeometry, sizeof (g->diskGeometry));

  00929	6a 18		 push	 24			; 00000018H
  0092b	66 89 88 06 02
	00 00		 mov	 WORD PTR [eax+518], cx
  00932	8d 88 08 02 00
	00		 lea	 ecx, DWORD PTR [eax+520]
  00938	51		 push	 ecx
  00939	6a 00		 push	 0
  0093b	6a 00		 push	 0
  0093d	68 00 00 07 00	 push	 458752			; 00070000H
  00942	50		 push	 eax
  00943	e8 00 00 00 00	 call	 _TCDeviceIoControl@24

; 1301 : 
; 1302 : 				Irp->IoStatus.Information = sizeof (DISK_GEOMETRY_STRUCT);
; 1303 : 				Irp->IoStatus.Status = ntStatus;
; 1304 : 			}
; 1305 : 		}
; 1306 : 		break;

  00948	e9 ff fe ff ff	 jmp	 $LN258@ProcessMai
$LN64@ProcessMai:

; 1227 : 
; 1228 : 	case TC_IOCTL_GET_DRIVE_PARTITION_INFO:
; 1229 : 		if (ValidateIOBufferSize (Irp, sizeof (DISK_PARTITION_INFO_STRUCT), ValidateInputOutput))

  0094d	6a 02		 push	 2
  0094f	68 30 02 00 00	 push	 560			; 00000230H
  00954	53		 push	 ebx
  00955	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  0095a	85 c0		 test	 eax, eax
  0095c	0f 84 4f 05 00
	00		 je	 $LN10@ProcessMai

; 1230 : 		{
; 1231 : 			DISK_PARTITION_INFO_STRUCT *info = (DISK_PARTITION_INFO_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  00962	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]

; 1232 : 			{
; 1233 : 				PARTITION_INFORMATION_EX pi;
; 1234 : 				NTSTATUS ntStatus;
; 1235 : 
; 1236 : 				EnsureNullTerminatedString (info->deviceName, sizeof (info->deviceName));

  00965	33 c0		 xor	 eax, eax

; 1237 : 
; 1238 : 				ntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0, &pi, sizeof (pi));

  00967	68 90 00 00 00	 push	 144			; 00000090H
  0096c	66 89 86 06 02
	00 00		 mov	 WORD PTR [esi+518], ax
  00973	8d 85 e4 fc ff
	ff		 lea	 eax, DWORD PTR _pi$30285[ebp]
  00979	50		 push	 eax
  0097a	33 ff		 xor	 edi, edi
  0097c	57		 push	 edi
  0097d	57		 push	 edi
  0097e	68 48 00 07 00	 push	 458824			; 00070048H
  00983	56		 push	 esi
  00984	e8 00 00 00 00	 call	 _TCDeviceIoControl@24

; 1239 : 				if (NT_SUCCESS(ntStatus))

  00989	3b c7		 cmp	 eax, edi
  0098b	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _ntStatus$30286[ebp], eax
  00991	7c 79		 jl	 SHORT $LN62@ProcessMai

; 1240 : 				{
; 1241 : 					memset (&info->partInfo, 0, sizeof (info->partInfo));

  00993	33 c0		 xor	 eax, eax

; 1242 : 
; 1243 : 					info->partInfo.PartitionLength = pi.PartitionLength;
; 1244 : 					info->partInfo.PartitionNumber = pi.PartitionNumber;
; 1245 : 					info->partInfo.StartingOffset = pi.StartingOffset;
; 1246 : 
; 1247 : 					if (pi.PartitionStyle == PARTITION_STYLE_MBR)

  00995	83 bd e4 fc ff
	ff 00		 cmp	 DWORD PTR _pi$30285[ebp], 0
  0099c	8d 96 08 02 00
	00		 lea	 edx, DWORD PTR [esi+520]
  009a2	6a 08		 push	 8
  009a4	59		 pop	 ecx
  009a5	8b fa		 mov	 edi, edx
  009a7	f3 ab		 rep stosd
  009a9	8b 85 f4 fc ff
	ff		 mov	 eax, DWORD PTR _pi$30285[ebp+16]
  009af	89 86 10 02 00
	00		 mov	 DWORD PTR [esi+528], eax
  009b5	8b 85 f8 fc ff
	ff		 mov	 eax, DWORD PTR _pi$30285[ebp+20]
  009bb	89 86 14 02 00
	00		 mov	 DWORD PTR [esi+532], eax
  009c1	8b 85 fc fc ff
	ff		 mov	 eax, DWORD PTR _pi$30285[ebp+24]
  009c7	89 86 1c 02 00
	00		 mov	 DWORD PTR [esi+540], eax
  009cd	8b 85 ec fc ff
	ff		 mov	 eax, DWORD PTR _pi$30285[ebp+8]
  009d3	89 02		 mov	 DWORD PTR [edx], eax
  009d5	8b 85 f0 fc ff
	ff		 mov	 eax, DWORD PTR _pi$30285[ebp+12]
  009db	89 42 04	 mov	 DWORD PTR [edx+4], eax
  009de	75 18		 jne	 SHORT $LN61@ProcessMai

; 1248 : 					{
; 1249 : 						info->partInfo.PartitionType = pi.Mbr.PartitionType;

  009e0	8a 85 04 fd ff
	ff		 mov	 al, BYTE PTR _pi$30285[ebp+32]
  009e6	88 86 20 02 00
	00		 mov	 BYTE PTR [esi+544], al

; 1250 : 						info->partInfo.BootIndicator = pi.Mbr.BootIndicator;

  009ec	8a 85 05 fd ff
	ff		 mov	 al, BYTE PTR _pi$30285[ebp+33]
  009f2	88 86 21 02 00
	00		 mov	 BYTE PTR [esi+545], al
$LN61@ProcessMai:

; 1251 : 					}
; 1252 : 
; 1253 : 					info->IsGPT = pi.PartitionStyle == PARTITION_STYLE_GPT;

  009f8	33 c0		 xor	 eax, eax
  009fa	83 bd e4 fc ff
	ff 01		 cmp	 DWORD PTR _pi$30285[ebp], 1
  00a01	0f 94 c0	 sete	 al
  00a04	89 86 28 02 00
	00		 mov	 DWORD PTR [esi+552], eax

; 1254 : 				}
; 1255 : 				else

  00a0a	eb 22		 jmp	 SHORT $LN60@ProcessMai
$LN62@ProcessMai:

; 1256 : 				{
; 1257 : 					// Windows 2000 does not support IOCTL_DISK_GET_PARTITION_INFO_EX
; 1258 : 					ntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0, &info->partInfo, sizeof (info->partInfo));

  00a0c	6a 20		 push	 32			; 00000020H
  00a0e	8d 86 08 02 00
	00		 lea	 eax, DWORD PTR [esi+520]
  00a14	50		 push	 eax
  00a15	57		 push	 edi
  00a16	57		 push	 edi
  00a17	68 04 40 07 00	 push	 475140			; 00074004H
  00a1c	56		 push	 esi
  00a1d	e8 00 00 00 00	 call	 _TCDeviceIoControl@24
  00a22	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _ntStatus$30286[ebp], eax

; 1259 : 					info->IsGPT = FALSE;

  00a28	89 be 28 02 00
	00		 mov	 DWORD PTR [esi+552], edi
$LN60@ProcessMai:

; 1260 : 				}
; 1261 : 
; 1262 : 				if (!NT_SUCCESS (ntStatus))

  00a2e	83 bd f8 fd ff
	ff 00		 cmp	 DWORD PTR _ntStatus$30286[ebp], 0
  00a35	7d 47		 jge	 SHORT $LN235@ProcessMai

; 1263 : 				{
; 1264 : 					GET_LENGTH_INFORMATION lengthInfo;
; 1265 : 					ntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_LENGTH_INFO, NULL, 0, &lengthInfo, sizeof (lengthInfo));

  00a37	6a 08		 push	 8
  00a39	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _lengthInfo$30295[ebp]
  00a3f	50		 push	 eax
  00a40	6a 00		 push	 0
  00a42	6a 00		 push	 0
  00a44	68 5c 40 07 00	 push	 475228			; 0007405cH
  00a49	56		 push	 esi
  00a4a	e8 00 00 00 00	 call	 _TCDeviceIoControl@24
  00a4f	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _ntStatus$30286[ebp], eax

; 1266 : 
; 1267 : 					if (NT_SUCCESS (ntStatus))

  00a55	85 c0		 test	 eax, eax
  00a57	7c 25		 jl	 SHORT $LN235@ProcessMai

; 1268 : 					{
; 1269 : 						memset (&info->partInfo, 0, sizeof (info->partInfo));

  00a59	6a 08		 push	 8
  00a5b	33 c0		 xor	 eax, eax
  00a5d	59		 pop	 ecx
  00a5e	8d be 08 02 00
	00		 lea	 edi, DWORD PTR [esi+520]
  00a64	f3 ab		 rep stosd

; 1270 : 						info->partInfo.PartitionLength = lengthInfo.Length;

  00a66	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _lengthInfo$30295[ebp]
  00a6c	89 86 10 02 00
	00		 mov	 DWORD PTR [esi+528], eax
  00a72	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _lengthInfo$30295[ebp+4]
  00a78	89 86 14 02 00
	00		 mov	 DWORD PTR [esi+532], eax
$LN235@ProcessMai:

; 1271 : 					}
; 1272 : 				}
; 1273 : 
; 1274 : 				info->IsDynamic = FALSE;

  00a7e	33 c0		 xor	 eax, eax

; 1275 : 
; 1276 : 				if (NT_SUCCESS (ntStatus) && OsMajorVersion >= 6)

  00a80	39 85 f8 fd ff
	ff		 cmp	 DWORD PTR _ntStatus$30286[ebp], eax
  00a86	8d be 2c 02 00
	00		 lea	 edi, DWORD PTR [esi+556]
  00a8c	89 07		 mov	 DWORD PTR [edi], eax
  00a8e	7c 20		 jl	 SHORT $LN239@ProcessMai
  00a90	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _OsMajorVersion, 6
  00a97	72 17		 jb	 SHORT $LN239@ProcessMai

; 1277 : 				{
; 1278 : #					define IOCTL_VOLUME_IS_DYNAMIC CTL_CODE(IOCTL_VOLUME_BASE, 18, METHOD_BUFFERED, FILE_ANY_ACCESS)
; 1279 : 					if (!NT_SUCCESS (TCDeviceIoControl (info->deviceName, IOCTL_VOLUME_IS_DYNAMIC, NULL, 0, &info->IsDynamic, sizeof (info->IsDynamic))))

  00a99	6a 04		 push	 4
  00a9b	57		 push	 edi
  00a9c	50		 push	 eax
  00a9d	50		 push	 eax
  00a9e	68 48 00 56 00	 push	 5636168			; 00560048H
  00aa3	56		 push	 esi
  00aa4	e8 00 00 00 00	 call	 _TCDeviceIoControl@24
  00aa9	85 c0		 test	 eax, eax
  00aab	7d 03		 jge	 SHORT $LN239@ProcessMai

; 1280 : 						info->IsDynamic = FALSE;

  00aad	83 27 00	 and	 DWORD PTR [edi], 0
$LN239@ProcessMai:

; 1281 : 				}
; 1282 : 
; 1283 : 				Irp->IoStatus.Information = sizeof (DISK_PARTITION_INFO_STRUCT);
; 1284 : 				Irp->IoStatus.Status = ntStatus;

  00ab0	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR _ntStatus$30286[ebp]
  00ab6	c7 43 1c 30 02
	00 00		 mov	 DWORD PTR [ebx+28], 560	; 00000230H

; 1285 : 			}
; 1286 : 		}
; 1287 : 		break;

  00abd	e9 2c fd ff ff	 jmp	 $LN259@ProcessMai
$LN24@ProcessMai:

; 1415 : 
; 1416 : 	case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS:
; 1417 : 		GetBootEncryptionStatus (Irp, irpSp);

  00ac2	57		 push	 edi
  00ac3	53		 push	 ebx
  00ac4	e8 00 00 00 00	 call	 _GetBootEncryptionStatus@8

; 1418 : 		break;

  00ac9	e9 e3 03 00 00	 jmp	 $LN10@ProcessMai
$LN152@ProcessMai:

; 810  : 	NTSTATUS ntStatus;
; 811  : 
; 812  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  00ace	b9 70 20 22 00	 mov	 ecx, 2236528		; 00222070H
  00ad3	3b c1		 cmp	 eax, ecx
  00ad5	0f 87 a9 02 00
	00		 ja	 $LN156@ProcessMai
  00adb	0f 84 e0 00 00
	00		 je	 $LN109@ProcessMai
  00ae1	83 c1 ec	 add	 ecx, -20		; ffffffecH
  00ae4	3b c1		 cmp	 eax, ecx
  00ae6	77 59		 ja	 SHORT $LN157@ProcessMai
  00ae8	74 4b		 je	 SHORT $LN20@ProcessMai
  00aea	2d 4c 20 22 00	 sub	 eax, 2236492		; 0022204cH
  00aef	74 37		 je	 SHORT $LN26@ProcessMai
  00af1	6a 04		 push	 4
  00af3	5e		 pop	 esi
  00af4	2b c6		 sub	 eax, esi
  00af6	74 26		 je	 SHORT $LN25@ProcessMai
  00af8	2b c6		 sub	 eax, esi
  00afa	74 14		 je	 SHORT $LN23@ProcessMai
  00afc	2b c6		 sub	 eax, esi
  00afe	0f 85 f4 02 00
	00		 jne	 $LN1@ProcessMai

; 1424 : 
; 1425 : 	case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:
; 1426 : 		GetBootDriveVolumeProperties (Irp, irpSp);

  00b04	57		 push	 edi
  00b05	53		 push	 ebx
  00b06	e8 00 00 00 00	 call	 _GetBootDriveVolumeProperties@8

; 1427 : 		break;

  00b0b	e9 a1 03 00 00	 jmp	 $LN10@ProcessMai
$LN23@ProcessMai:

; 1419 : 
; 1420 : 	case TC_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT:
; 1421 : 		Irp->IoStatus.Information = 0;

  00b10	83 63 1c 00	 and	 DWORD PTR [ebx+28], 0

; 1422 : 		Irp->IoStatus.Status = GetSetupResult();

  00b14	e8 00 00 00 00	 call	 _GetSetupResult@0

; 1423 : 		break;

  00b19	e9 d0 fc ff ff	 jmp	 $LN259@ProcessMai
$LN25@ProcessMai:

; 1410 : 
; 1411 : 	case TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP:
; 1412 : 		Irp->IoStatus.Status = AbortBootEncryptionSetup();

  00b1e	e8 00 00 00 00	 call	 _AbortBootEncryptionSetup@0

; 1413 : 		Irp->IoStatus.Information = 0;
; 1414 : 		break;

  00b23	e9 df f9 ff ff	 jmp	 $LN264@ProcessMai
$LN26@ProcessMai:

; 1405 : 
; 1406 : 	case TC_IOCTL_BOOT_ENCRYPTION_SETUP:
; 1407 : 		Irp->IoStatus.Status = StartBootEncryptionSetup (DeviceObject, Irp, irpSp);

  00b28	57		 push	 edi
  00b29	53		 push	 ebx
  00b2a	52		 push	 edx
  00b2b	e8 00 00 00 00	 call	 _StartBootEncryptionSetup@12

; 1408 : 		Irp->IoStatus.Information = 0;
; 1409 : 		break;

  00b30	e9 d2 f9 ff ff	 jmp	 $LN264@ProcessMai
$LN20@ProcessMai:

; 1432 : 
; 1433 : 	case TC_IOCTL_REOPEN_BOOT_VOLUME_HEADER:
; 1434 : 		ReopenBootVolumeHeader (Irp, irpSp);

  00b35	57		 push	 edi
  00b36	53		 push	 ebx
  00b37	e8 00 00 00 00	 call	 _ReopenBootVolumeHeader@8

; 1435 : 		break;

  00b3c	e9 70 03 00 00	 jmp	 $LN10@ProcessMai
$LN157@ProcessMai:

; 810  : 	NTSTATUS ntStatus;
; 811  : 
; 812  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  00b41	2d 60 20 22 00	 sub	 eax, 2236512		; 00222060H
  00b46	74 6d		 je	 SHORT $LN19@ProcessMai
  00b48	6a 04		 push	 4
  00b4a	5e		 pop	 esi
  00b4b	2b c6		 sub	 eax, esi
  00b4d	74 4e		 je	 SHORT $LN88@ProcessMai
  00b4f	2b c6		 sub	 eax, esi
  00b51	74 2e		 je	 SHORT $LN91@ProcessMai
  00b53	2b c6		 sub	 eax, esi
  00b55	0f 85 9d 02 00
	00		 jne	 $LN1@ProcessMai

; 1440 : 
; 1441 : 	case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:
; 1442 : 		if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))

  00b5b	6a 01		 push	 1
  00b5d	56		 push	 esi
  00b5e	53		 push	 ebx
  00b5f	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00b64	85 c0		 test	 eax, eax
  00b66	0f 84 45 03 00
	00		 je	 $LN10@ProcessMai

; 1443 : 		{
; 1444 : 			*(int *) Irp->AssociatedIrp.SystemBuffer = IsHiddenSystemRunning() ? 1 : 0;

  00b6c	e8 00 00 00 00	 call	 _IsHiddenSystemRunning@0
  00b71	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00b74	f7 d8		 neg	 eax
  00b76	1b c0		 sbb	 eax, eax
  00b78	f7 d8		 neg	 eax
  00b7a	89 01		 mov	 DWORD PTR [ecx], eax

; 1445 : 			Irp->IoStatus.Information = sizeof (int);
; 1446 : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 1447 : 		}
; 1448 : 		break;

  00b7c	e9 25 f5 ff ff	 jmp	 $LN257@ProcessMai
$LN91@ProcessMai:

; 1086 : 
; 1087 : 	case TC_IOCTL_SET_PORTABLE_MODE_STATUS:
; 1088 : 		if (!UserCanAccessDriveDevice())

  00b81	e8 00 00 00 00	 call	 _UserCanAccessDriveDevice@0
  00b86	85 c0		 test	 eax, eax

; 1089 : 		{
; 1090 : 			Irp->IoStatus.Status = STATUS_ACCESS_DENIED;
; 1091 : 			Irp->IoStatus.Information = 0;
; 1092 : 		}
; 1093 : 		else

  00b88	0f 84 df 02 00
	00		 je	 $LN8@ProcessMai

; 1094 : 		{
; 1095 : 			PortableMode = TRUE;

  00b8e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _PortableMode, 1

; 1096 : 			Dump ("Setting portable mode\n");
; 1097 : 		}
; 1098 : 		break;

  00b98	e9 14 03 00 00	 jmp	 $LN10@ProcessMai
$LN88@ProcessMai:

; 1099 : 
; 1100 : 	case TC_IOCTL_GET_PORTABLE_MODE_STATUS:
; 1101 : 		Irp->IoStatus.Status = PortableMode ? STATUS_SUCCESS : STATUS_PIPE_EMPTY;

  00b9d	a1 00 00 00 00	 mov	 eax, DWORD PTR _PortableMode
  00ba2	f7 d8		 neg	 eax
  00ba4	1b c0		 sbb	 eax, eax
  00ba6	25 27 ff ff 3f	 and	 eax, 1073741607		; 3fffff27H
  00bab	05 d9 00 00 c0	 add	 eax, -1073741607	; c00000d9H

; 1102 : 		Irp->IoStatus.Information = 0;
; 1103 : 		break;

  00bb0	e9 52 f9 ff ff	 jmp	 $LN264@ProcessMai
$LN19@ProcessMai:

; 1436 : 
; 1437 : 	case TC_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME:
; 1438 : 		GetBootEncryptionAlgorithmName (Irp, irpSp);

  00bb5	57		 push	 edi
  00bb6	53		 push	 ebx
  00bb7	e8 00 00 00 00	 call	 _GetBootEncryptionAlgorithmName@8

; 1439 : 		break;

  00bbc	e9 f0 02 00 00	 jmp	 $LN10@ProcessMai
$LN109@ProcessMai:

; 975  : 
; 976  : 	case TC_IOCTL_GET_SYSTEM_DRIVE_CONFIG:
; 977  : 		{
; 978  : 			GetSystemDriveConfigurationRequest *request = (GetSystemDriveConfigurationRequest *) Irp->AssociatedIrp.SystemBuffer;

  00bc1	8b 7b 0c	 mov	 edi, DWORD PTR [ebx+12]

; 979  : 			OBJECT_ATTRIBUTES ObjectAttributes;
; 980  : 			HANDLE NtFileHandle;
; 981  : 			UNICODE_STRING FullFileName;
; 982  : 			IO_STATUS_BLOCK IoStatus;
; 983  : 			LARGE_INTEGER offset;
; 984  : 			byte readBuffer [TC_SECTOR_SIZE_BIOS];
; 985  : 
; 986  : 			if (!ValidateIOBufferSize (Irp, sizeof (GetSystemDriveConfigurationRequest), ValidateInputOutput))

  00bc4	6a 02		 push	 2
  00bc6	68 29 02 00 00	 push	 553			; 00000229H
  00bcb	53		 push	 ebx
  00bcc	89 bd ec fd ff
	ff		 mov	 DWORD PTR _request$30179[ebp], edi
  00bd2	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00bd7	85 c0		 test	 eax, eax
  00bd9	0f 84 d2 02 00
	00		 je	 $LN10@ProcessMai

; 987  : 				break;
; 988  : 
; 989  : 			EnsureNullTerminatedString (request->DevicePath, sizeof (request->DevicePath));

  00bdf	33 c0		 xor	 eax, eax
  00be1	66 89 87 06 02
	00 00		 mov	 WORD PTR [edi+518], ax

; 990  : 			RtlInitUnicodeString (&FullFileName, request->DevicePath);

  00be8	57		 push	 edi
  00be9	8d 85 84 fd ff
	ff		 lea	 eax, DWORD PTR _FullFileName$30183[ebp]
  00bef	50		 push	 eax
  00bf0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 991  : 
; 992  : 			InitializeObjectAttributes (&ObjectAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

  00bf6	33 f6		 xor	 esi, esi

; 993  : 
; 994  : 			ntStatus = ZwCreateFile (&NtFileHandle,
; 995  : 				SYNCHRONIZE | GENERIC_READ, &ObjectAttributes, &IoStatus, NULL,
; 996  : 				FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS, NULL, 0);

  00bf8	56		 push	 esi
  00bf9	56		 push	 esi
  00bfa	68 20 08 00 00	 push	 2080			; 00000820H
  00bff	6a 01		 push	 1
  00c01	6a 03		 push	 3
  00c03	68 80 00 00 00	 push	 128			; 00000080H
  00c08	8d 85 84 fd ff
	ff		 lea	 eax, DWORD PTR _FullFileName$30183[ebp]
  00c0e	89 85 9c fd ff
	ff		 mov	 DWORD PTR _ObjectAttributes$30181[ebp+8], eax
  00c14	56		 push	 esi
  00c15	8d 85 8c fd ff
	ff		 lea	 eax, DWORD PTR _IoStatus$30184[ebp]
  00c1b	50		 push	 eax
  00c1c	8d 85 94 fd ff
	ff		 lea	 eax, DWORD PTR _ObjectAttributes$30181[ebp]
  00c22	50		 push	 eax
  00c23	68 00 00 10 80	 push	 -2146435072		; 80100000H
  00c28	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _NtFileHandle$30182[ebp]
  00c2e	50		 push	 eax
  00c2f	c7 85 94 fd ff
	ff 18 00 00 00	 mov	 DWORD PTR _ObjectAttributes$30181[ebp], 24 ; 00000018H
  00c39	89 b5 98 fd ff
	ff		 mov	 DWORD PTR _ObjectAttributes$30181[ebp+4], esi
  00c3f	c7 85 a0 fd ff
	ff 40 02 00 00	 mov	 DWORD PTR _ObjectAttributes$30181[ebp+12], 576 ; 00000240H
  00c49	89 b5 a4 fd ff
	ff		 mov	 DWORD PTR _ObjectAttributes$30181[ebp+16], esi
  00c4f	89 b5 a8 fd ff
	ff		 mov	 DWORD PTR _ObjectAttributes$30181[ebp+20], esi
  00c55	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwCreateFile@44

; 997  : 
; 998  : 			if (NT_SUCCESS (ntStatus))

  00c5b	3b c6		 cmp	 eax, esi
  00c5d	0f 8c e9 fb ff
	ff		 jl	 $LN258@ProcessMai

; 999  : 			{
; 1000 : 				// Determine if the first sector contains a portion of the TrueCrypt Boot Loader
; 1001 : 				offset.QuadPart = 0;	// MBR
; 1002 : 
; 1003 : 				ntStatus = ZwReadFile (NtFileHandle,
; 1004 : 					NULL,
; 1005 : 					NULL,
; 1006 : 					NULL,
; 1007 : 					&IoStatus,
; 1008 : 					readBuffer,
; 1009 : 					sizeof(readBuffer),
; 1010 : 					&offset,
; 1011 : 					NULL);

  00c63	56		 push	 esi
  00c64	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _offset$30185[ebp]
  00c6a	50		 push	 eax
  00c6b	68 00 02 00 00	 push	 512			; 00000200H
  00c70	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _readBuffer$30186[ebp]
  00c76	50		 push	 eax
  00c77	8d 85 8c fd ff
	ff		 lea	 eax, DWORD PTR _IoStatus$30184[ebp]
  00c7d	50		 push	 eax
  00c7e	56		 push	 esi
  00c7f	56		 push	 esi
  00c80	56		 push	 esi
  00c81	ff b5 f4 fd ff
	ff		 push	 DWORD PTR _NtFileHandle$30182[ebp]
  00c87	89 b5 cc fd ff
	ff		 mov	 DWORD PTR _offset$30185[ebp], esi
  00c8d	89 b5 d0 fd ff
	ff		 mov	 DWORD PTR _offset$30185[ebp+4], esi
  00c93	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwReadFile@36

; 1012 : 
; 1013 : 				if (NT_SUCCESS (ntStatus))

  00c99	3b c6		 cmp	 eax, esi
  00c9b	0f 8c cc 00 00
	00		 jl	 $LN106@ProcessMai

; 1014 : 				{
; 1015 : 					size_t i;
; 1016 : 
; 1017 : 					// Check for dynamic drive
; 1018 : 					request->DriveIsDynamic = FALSE;

  00ca1	89 b7 09 02 00
	00		 mov	 DWORD PTR [edi+521], esi

; 1019 : 
; 1020 : 					if (readBuffer[510] == 0x55 && readBuffer[511] == 0xaa)

  00ca7	80 7d fa 55	 cmp	 BYTE PTR _readBuffer$30186[ebp+510], 85 ; 00000055H
  00cab	75 27		 jne	 SHORT $LN102@ProcessMai
  00cad	80 7d fb aa	 cmp	 BYTE PTR _readBuffer$30186[ebp+511], 170 ; 000000aaH
  00cb1	75 21		 jne	 SHORT $LN102@ProcessMai

; 1021 : 					{
; 1022 : 						int i;
; 1023 : 						for (i = 0; i < 4; ++i)

  00cb3	6a 04		 push	 4
  00cb5	33 c9		 xor	 ecx, ecx
  00cb7	8d 45 be	 lea	 eax, DWORD PTR _readBuffer$30186[ebp+450]
  00cba	5e		 pop	 esi
$LL104@ProcessMai:

; 1024 : 						{
; 1025 : 							if (readBuffer[446 + i * 16 + 4] == PARTITION_LDM)

  00cbb	80 38 42	 cmp	 BYTE PTR [eax], 66	; 00000042H
  00cbe	74 0a		 je	 SHORT $LN196@ProcessMai
  00cc0	41		 inc	 ecx
  00cc1	83 c0 10	 add	 eax, 16			; 00000010H
  00cc4	3b ce		 cmp	 ecx, esi
  00cc6	7c f3		 jl	 SHORT $LL104@ProcessMai

; 1040 : 					{
; 1041 : 						if (memcmp (readBuffer + i, TC_APP_NAME_LEGACY, strlen (TC_APP_NAME_LEGACY)) == 0)

  00cc8	eb 0a		 jmp	 SHORT $LN102@ProcessMai
$LN196@ProcessMai:

; 1026 : 							{
; 1027 : 								request->DriveIsDynamic = TRUE;

  00cca	c7 87 09 02 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+521], 1
$LN102@ProcessMai:

; 1028 : 								break;
; 1029 : 							}
; 1030 : 						}
; 1031 : 					}
; 1032 : 
; 1033 : 					request->BootLoaderVersion = 0;

  00cd4	33 c0		 xor	 eax, eax
  00cd6	66 89 87 0d 02
	00 00		 mov	 WORD PTR [edi+525], ax

; 1034 : 					request->Configuration = 0;

  00cdd	88 87 08 02 00
	00		 mov	 BYTE PTR [edi+520], al

; 1035 : 					request->UserConfiguration = 0;

  00ce3	88 87 0f 02 00
	00		 mov	 BYTE PTR [edi+527], al

; 1036 : 					request->CustomUserMessage[0] = 0;

  00ce9	8d 87 10 02 00
	00		 lea	 eax, DWORD PTR [edi+528]
  00cef	89 85 e8 fd ff
	ff		 mov	 DWORD PTR tv1386[ebp], eax
  00cf5	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1037 : 
; 1038 : 					// Search for the string "TrueCrypt"
; 1039 : 					for (i = 0; i < sizeof (readBuffer) - strlen (TC_APP_NAME_LEGACY); ++i)

  00cf8	33 c0		 xor	 eax, eax
$LL100@ProcessMai:

; 1040 : 					{
; 1041 : 						if (memcmp (readBuffer + i, TC_APP_NAME_LEGACY, strlen (TC_APP_NAME_LEGACY)) == 0)

  00cfa	6a 09		 push	 9
  00cfc	59		 pop	 ecx
  00cfd	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_09EMKKFGIH@TrueCrypt?$AA@FNODOBFM@
  00d02	8d b4 05 fc fd
	ff ff		 lea	 esi, DWORD PTR _readBuffer$30186[ebp+eax]
  00d09	33 d2		 xor	 edx, edx
  00d0b	f3 a6		 repe cmpsb
  00d0d	74 0a		 je	 SHORT $LN197@ProcessMai
  00d0f	40		 inc	 eax
  00d10	3d f7 01 00 00	 cmp	 eax, 503		; 000001f7H
  00d15	72 e3		 jb	 SHORT $LL100@ProcessMai
  00d17	eb 47		 jmp	 SHORT $LN96@ProcessMai
$LN197@ProcessMai:

; 1042 : 						{
; 1043 : 							request->BootLoaderVersion = BE16 (*(uint16 *) (readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET));

  00d19	ff 75 aa	 push	 DWORD PTR _readBuffer$30186[ebp+430]
  00d1c	e8 00 00 00 00	 call	 _MirrorBytes16@4
  00d21	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _request$30179[ebp]
  00d27	66 8b f0	 mov	 si, ax
  00d2a	66 89 b1 0d 02
	00 00		 mov	 WORD PTR [ecx+525], si

; 1044 : 							request->Configuration = readBuffer[TC_BOOT_SECTOR_CONFIG_OFFSET];

  00d31	8a 45 b3	 mov	 al, BYTE PTR _readBuffer$30186[ebp+439]
  00d34	88 81 08 02 00
	00		 mov	 BYTE PTR [ecx+520], al

; 1045 : 
; 1046 : 							if (request->BootLoaderVersion != 0 && request->BootLoaderVersion <= VERSION_NUM)

  00d3a	66 85 f6	 test	 si, si
  00d3d	74 21		 je	 SHORT $LN96@ProcessMai
  00d3f	b8 30 07 00 00	 mov	 eax, 1840		; 00000730H
  00d44	66 3b f0	 cmp	 si, ax
  00d47	77 17		 ja	 SHORT $LN96@ProcessMai

; 1047 : 							{
; 1048 : 								request->UserConfiguration = readBuffer[TC_BOOT_SECTOR_USER_CONFIG_OFFSET];

  00d49	8a 45 b2	 mov	 al, BYTE PTR _readBuffer$30186[ebp+438]

; 1049 : 								memcpy (request->CustomUserMessage, readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET, TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH);

  00d4c	8b bd e8 fd ff
	ff		 mov	 edi, DWORD PTR tv1386[ebp]
  00d52	88 81 0f 02 00
	00		 mov	 BYTE PTR [ecx+527], al
  00d58	6a 06		 push	 6
  00d5a	59		 pop	 ecx
  00d5b	8d 75 92	 lea	 esi, DWORD PTR _readBuffer$30186[ebp+406]
  00d5e	f3 a5		 rep movsd
$LN96@ProcessMai:

; 1050 : 							}
; 1051 : 							break;
; 1052 : 						}
; 1053 : 					}
; 1054 : 
; 1055 : 					Irp->IoStatus.Status = STATUS_SUCCESS;

  00d60	83 63 18 00	 and	 DWORD PTR [ebx+24], 0

; 1056 : 					Irp->IoStatus.Information = sizeof (*request);

  00d64	c7 43 1c 29 02
	00 00		 mov	 DWORD PTR [ebx+28], 553	; 00000229H

; 1057 : 				}
; 1058 : 				else

  00d6b	eb 06		 jmp	 SHORT $LN95@ProcessMai
$LN106@ProcessMai:

; 1059 : 				{
; 1060 : 					Irp->IoStatus.Status = ntStatus;

  00d6d	89 43 18	 mov	 DWORD PTR [ebx+24], eax

; 1061 : 					Irp->IoStatus.Information = 0;

  00d70	89 73 1c	 mov	 DWORD PTR [ebx+28], esi
$LN95@ProcessMai:

; 1062 : 				}
; 1063 : 
; 1064 : 				ZwClose (NtFileHandle);

  00d73	ff b5 f4 fd ff
	ff		 push	 DWORD PTR _NtFileHandle$30182[ebp]
  00d79	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 1065 : 
; 1066 : 			}
; 1067 : 			else

  00d7f	e9 2d 01 00 00	 jmp	 $LN10@ProcessMai
$LN156@ProcessMai:

; 810  : 	NTSTATUS ntStatus;
; 811  : 
; 812  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  00d84	b9 88 20 22 00	 mov	 ecx, 2236552		; 00222088H
  00d89	3b c1		 cmp	 eax, ecx
  00d8b	77 51		 ja	 SHORT $LN158@ProcessMai
  00d8d	74 43		 je	 SHORT $LN12@ProcessMai
  00d8f	2d 78 20 22 00	 sub	 eax, 2236536		; 00222078H
  00d94	74 2f		 je	 SHORT $LN16@ProcessMai
  00d96	6a 04		 push	 4
  00d98	5e		 pop	 esi
  00d99	2b c6		 sub	 eax, esi
  00d9b	74 1e		 je	 SHORT $LN15@ProcessMai
  00d9d	2b c6		 sub	 eax, esi
  00d9f	74 0e		 je	 SHORT $LN13@ProcessMai
  00da1	2b c6		 sub	 eax, esi
  00da3	75 53		 jne	 SHORT $LN1@ProcessMai

; 1459 : 
; 1460 : 	case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT:
; 1461 : 		Irp->IoStatus.Status = GetDecoySystemWipeResult();

  00da5	e8 00 00 00 00	 call	 _GetDecoySystemWipeResult@0

; 1462 : 		Irp->IoStatus.Information = 0;
; 1463 : 		break;

  00daa	e9 58 f7 ff ff	 jmp	 $LN264@ProcessMai
$LN13@ProcessMai:

; 1464 : 
; 1465 : 	case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS:
; 1466 : 		GetDecoySystemWipeStatus (Irp, irpSp);

  00daf	57		 push	 edi
  00db0	53		 push	 ebx
  00db1	e8 00 00 00 00	 call	 _GetDecoySystemWipeStatus@8

; 1467 : 		break;

  00db6	e9 f6 00 00 00	 jmp	 $LN10@ProcessMai
$LN15@ProcessMai:

; 1454 : 
; 1455 : 	case TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE:
; 1456 : 		Irp->IoStatus.Status = AbortDecoySystemWipe();

  00dbb	e8 00 00 00 00	 call	 _AbortDecoySystemWipe@0

; 1457 : 		Irp->IoStatus.Information = 0;
; 1458 : 		break;

  00dc0	e9 42 f7 ff ff	 jmp	 $LN264@ProcessMai
$LN16@ProcessMai:

; 1449 : 
; 1450 : 	case TC_IOCTL_START_DECOY_SYSTEM_WIPE:
; 1451 : 		Irp->IoStatus.Status = StartDecoySystemWipe (DeviceObject, Irp, irpSp);

  00dc5	57		 push	 edi
  00dc6	53		 push	 ebx
  00dc7	52		 push	 edx
  00dc8	e8 00 00 00 00	 call	 _StartDecoySystemWipe@12

; 1452 : 		Irp->IoStatus.Information = 0;
; 1453 : 		break;

  00dcd	e9 35 f7 ff ff	 jmp	 $LN264@ProcessMai
$LN12@ProcessMai:

; 1468 : 
; 1469 : 	case TC_IOCTL_WRITE_BOOT_DRIVE_SECTOR:
; 1470 : 		Irp->IoStatus.Status = WriteBootDriveSector (Irp, irpSp);

  00dd2	57		 push	 edi
  00dd3	53		 push	 ebx
  00dd4	e8 00 00 00 00	 call	 _WriteBootDriveSector@8

; 1471 : 		Irp->IoStatus.Information = 0;
; 1472 : 		break;

  00dd9	e9 29 f7 ff ff	 jmp	 $LN264@ProcessMai
$LN158@ProcessMai:

; 810  : 	NTSTATUS ntStatus;
; 811  : 
; 812  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  00dde	2d 8c 20 22 00	 sub	 eax, 2236556		; 0022208cH
  00de3	0f 84 90 00 00
	00		 je	 $LN11@ProcessMai
  00de9	6a 04		 push	 4
  00deb	5e		 pop	 esi
  00dec	2b c6		 sub	 eax, esi
  00dee	74 65		 je	 SHORT $LN9@ProcessMai
  00df0	2b c6		 sub	 eax, esi
  00df2	74 55		 je	 SHORT $LN6@ProcessMai
  00df4	2b c6		 sub	 eax, esi
  00df6	74 0c		 je	 SHORT $LN5@ProcessMai
$LN1@ProcessMai:

; 1519 : 			{
; 1520 : 				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
; 1521 : 				Irp->IoStatus.Information = 0;
; 1522 : 			}
; 1523 : 		}
; 1524 : 		break;
; 1525 : 
; 1526 : 	default:
; 1527 : 		return TCCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);

  00df8	6a 00		 push	 0
  00dfa	68 10 00 00 c0	 push	 -1073741808		; c0000010H
  00dff	e9 b3 00 00 00	 jmp	 $LN256@ProcessMai
$LN5@ProcessMai:

; 1505 : 
; 1506 : 	case TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG:
; 1507 : 		if (ValidateIOBufferSize (Irp, sizeof (GetSystemDriveDumpConfigRequest), ValidateOutput))

  00e04	6a 01		 push	 1
  00e06	6a 08		 push	 8
  00e08	5f		 pop	 edi
  00e09	57		 push	 edi
  00e0a	53		 push	 ebx
  00e0b	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00e10	85 c0		 test	 eax, eax
  00e12	0f 84 99 00 00
	00		 je	 $LN10@ProcessMai

; 1508 : 		{
; 1509 : 			GetSystemDriveDumpConfigRequest *request = (GetSystemDriveDumpConfigRequest *) Irp->AssociatedIrp.SystemBuffer;

  00e18	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]

; 1510 : 
; 1511 : 			request->BootDriveFilterExtension = GetBootDriveFilterExtension();

  00e1b	e8 00 00 00 00	 call	 _GetBootDriveFilterExtension@0
  00e20	89 06		 mov	 DWORD PTR [esi], eax

; 1512 : 			if (IsBootDriveMounted() && request->BootDriveFilterExtension)

  00e22	e8 00 00 00 00	 call	 _IsBootDriveMounted@0
  00e27	85 c0		 test	 eax, eax
  00e29	0f 84 3f f3 ff
	ff		 je	 $LN43@ProcessMai
  00e2f	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00e32	0f 84 36 f3 ff
	ff		 je	 $LN43@ProcessMai

; 1513 : 			{
; 1514 : 				request->HwEncryptionEnabled = IsHwEncryptionEnabled();

  00e38	e8 00 00 00 00	 call	 _IsHwEncryptionEnabled@0
  00e3d	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1515 : 				Irp->IoStatus.Status = STATUS_SUCCESS;

  00e40	83 63 18 00	 and	 DWORD PTR [ebx+24], 0

; 1516 : 				Irp->IoStatus.Information = sizeof (*request);

  00e44	89 7b 1c	 mov	 DWORD PTR [ebx+28], edi

; 1517 : 			}
; 1518 : 			else

  00e47	eb 68		 jmp	 SHORT $LN10@ProcessMai
$LN6@ProcessMai:

; 1500 : 
; 1501 : 	case TC_IOCTL_REREAD_DRIVER_CONFIG:
; 1502 : 		Irp->IoStatus.Status = ReadRegistryConfigFlags (FALSE);

  00e49	6a 00		 push	 0
  00e4b	e8 00 00 00 00	 call	 _ReadRegistryConfigFlags@4

; 1503 : 		Irp->IoStatus.Information = 0;
; 1504 : 		break;

  00e50	e9 b2 f6 ff ff	 jmp	 $LN264@ProcessMai
$LN9@ProcessMai:

; 1486 : 		}
; 1487 : 		break;
; 1488 : 
; 1489 : 	case TC_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY:
; 1490 : 		if (UserCanAccessDriveDevice())

  00e55	e8 00 00 00 00	 call	 _UserCanAccessDriveDevice@0
  00e5a	85 c0		 test	 eax, eax
  00e5c	74 0f		 je	 SHORT $LN8@ProcessMai

; 1491 : 		{
; 1492 : 			SystemFavoriteVolumeDirty = TRUE;

  00e5e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _SystemFavoriteVolumeDirty, 1

; 1493 : 			Irp->IoStatus.Status = STATUS_SUCCESS;
; 1494 : 		}
; 1495 : 		else

  00e68	e9 7f f6 ff ff	 jmp	 $LN265@ProcessMai
$LN8@ProcessMai:

; 1496 : 			Irp->IoStatus.Status = STATUS_ACCESS_DENIED;

  00e6d	c7 43 18 22 00
	00 c0		 mov	 DWORD PTR [ebx+24], -1073741790 ; c0000022H

; 1497 : 
; 1498 : 		Irp->IoStatus.Information = 0;
; 1499 : 		break;

  00e74	e9 77 f6 ff ff	 jmp	 $LN260@ProcessMai
$LN11@ProcessMai:

; 1473 : 
; 1474 : 	case TC_IOCTL_GET_WARNING_FLAGS:
; 1475 : 		if (ValidateIOBufferSize (Irp, sizeof (GetWarningFlagsRequest), ValidateOutput))

  00e79	6a 01		 push	 1
  00e7b	6a 08		 push	 8
  00e7d	5e		 pop	 esi
  00e7e	56		 push	 esi
  00e7f	53		 push	 ebx
  00e80	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00e85	85 c0		 test	 eax, eax
  00e87	74 28		 je	 SHORT $LN10@ProcessMai

; 1476 : 		{
; 1477 : 			GetWarningFlagsRequest *flags = (GetWarningFlagsRequest *) Irp->AssociatedIrp.SystemBuffer;
; 1478 : 
; 1479 : 			flags->PagingFileCreationPrevented = PagingFileCreationPrevented;

  00e89	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _PagingFileCreationPrevented
  00e8f	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]

; 1480 : 			PagingFileCreationPrevented = FALSE;
; 1481 : 			flags->SystemFavoriteVolumeDirty = SystemFavoriteVolumeDirty;

  00e92	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SystemFavoriteVolumeDirty
  00e98	89 08		 mov	 DWORD PTR [eax], ecx
  00e9a	33 c9		 xor	 ecx, ecx
  00e9c	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00e9f	89 0d 00 00 00
	00		 mov	 DWORD PTR _PagingFileCreationPrevented, ecx

; 1482 : 			SystemFavoriteVolumeDirty = FALSE;

  00ea5	89 0d 00 00 00
	00		 mov	 DWORD PTR _SystemFavoriteVolumeDirty, ecx

; 1485 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00eab	89 4b 18	 mov	 DWORD PTR [ebx+24], ecx
$LN254@ProcessMai:

; 1483 : 
; 1484 : 			Irp->IoStatus.Information = sizeof (GetWarningFlagsRequest);

  00eae	89 73 1c	 mov	 DWORD PTR [ebx+28], esi
$LN10@ProcessMai:

; 1528 : 	}
; 1529 : 
; 1530 : 	
; 1531 : #ifdef DEBUG
; 1532 : 	if (!NT_SUCCESS (Irp->IoStatus.Status))
; 1533 : 	{
; 1534 : 		switch (irpSp->Parameters.DeviceIoControl.IoControlCode)
; 1535 : 		{
; 1536 : 		case TC_IOCTL_GET_MOUNTED_VOLUMES:
; 1537 : 		case TC_IOCTL_GET_PASSWORD_CACHE_STATUS:
; 1538 : 		case TC_IOCTL_GET_PORTABLE_MODE_STATUS:
; 1539 : 		case TC_IOCTL_SET_PORTABLE_MODE_STATUS:
; 1540 : 		case TC_IOCTL_OPEN_TEST:
; 1541 : 		case TC_IOCTL_GET_RESOLVED_SYMLINK:
; 1542 : 		case TC_IOCTL_GET_DRIVE_PARTITION_INFO:
; 1543 : 		case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:
; 1544 : 		case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS:
; 1545 : 		case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:
; 1546 : 			break;
; 1547 : 
; 1548 : 		default:
; 1549 : 			Dump ("IOCTL error 0x%08x\n", Irp->IoStatus.Status);
; 1550 : 		}
; 1551 : 	}
; 1552 : #endif
; 1553 : 
; 1554 : 	return TCCompleteIrp (Irp, Irp->IoStatus.Status, Irp->IoStatus.Information);

  00eb1	ff 73 1c	 push	 DWORD PTR [ebx+28]
  00eb4	ff 73 18	 push	 DWORD PTR [ebx+24]
$LN256@ProcessMai:
  00eb7	53		 push	 ebx
  00eb8	e8 00 00 00 00	 call	 _TCCompleteIrp@12

; 1555 : }

  00ebd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00ec0	5f		 pop	 edi
  00ec1	5e		 pop	 esi
  00ec2	33 cd		 xor	 ecx, ebp
  00ec4	5b		 pop	 ebx
  00ec5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00eca	c9		 leave
  00ecb	c2 0c 00	 ret	 12			; 0000000cH
_ProcessMainDeviceControlIrp@12 ENDP
_TEXT	ENDS
PUBLIC	_TCDispatchQueueIRP@8
EXTRN	_COMPLETE_IRP@16:PROC
EXTRN	_DecoySystemWipeThread:DWORD
EXTRN	_EncryptionSetupThread:DWORD
EXTRN	_EncryptedIoQueueAddIrp@8:PROC
EXTRN	__imp_@ExfInterlockedInsertTailList@12:PROC
EXTRN	_VolumeFilterDispatchIrp@8:PROC
EXTRN	_DriveFilterDispatchIrp@8:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCDispatchQueueIRP@8
_TEXT	SEGMENT
tv306 = -1						; size = 1
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_TCDispatchQueueIRP@8 PROC				; COMDAT

; 202  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 203  : 	PEXTENSION Extension = (PEXTENSION) DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b 70 28	 mov	 esi, DWORD PTR [eax+40]

; 204  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);
; 205  : 	NTSTATUS ntStatus;
; 206  : 
; 207  : #ifdef _DEBUG
; 208  : 	if (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL && (Extension->bRootDevice || Extension->IsVolumeDevice))
; 209  : 	{
; 210  : 		switch (irpSp->Parameters.DeviceIoControl.IoControlCode)
; 211  : 		{
; 212  : 		case TC_IOCTL_GET_MOUNTED_VOLUMES:
; 213  : 		case TC_IOCTL_GET_PASSWORD_CACHE_STATUS:
; 214  : 		case TC_IOCTL_GET_PORTABLE_MODE_STATUS:
; 215  : 		case TC_IOCTL_SET_PORTABLE_MODE_STATUS:
; 216  : 		case TC_IOCTL_OPEN_TEST:
; 217  : 		case TC_IOCTL_GET_RESOLVED_SYMLINK:
; 218  : 		case TC_IOCTL_GET_DEVICE_REFCOUNT:
; 219  : 		case TC_IOCTL_GET_DRIVE_PARTITION_INFO:
; 220  : 		case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:
; 221  : 		case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS:
; 222  : 		case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS:
; 223  : 		case TC_IOCTL_GET_WARNING_FLAGS:
; 224  : 		case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:
; 225  : 		case IOCTL_DISK_CHECK_VERIFY:
; 226  : 			break;
; 227  : 
; 228  : 		default:
; 229  : 			Dump ("%ls (0x%x %d)\n",
; 230  : 				TCTranslateCode (irpSp->Parameters.DeviceIoControl.IoControlCode),
; 231  : 				(int) (irpSp->Parameters.DeviceIoControl.IoControlCode >> 16),
; 232  : 				(int) ((irpSp->Parameters.DeviceIoControl.IoControlCode & 0x1FFF) >> 2));
; 233  : 		}
; 234  : 	}
; 235  : #endif
; 236  : 
; 237  : 	if (!Extension->bRootDevice)

  0000e	8b 16		 mov	 edx, DWORD PTR [esi]
  00010	57		 push	 edi
  00011	8b 7d 0c	 mov	 edi, DWORD PTR _Irp$[ebp]
  00014	8b 4f 60	 mov	 ecx, DWORD PTR [edi+96]
  00017	33 db		 xor	 ebx, ebx
  00019	3b d3		 cmp	 edx, ebx
  0001b	75 22		 jne	 SHORT $LN27@TCDispatch

; 238  : 	{
; 239  : 		// Drive filter IRP
; 240  : 		if (Extension->IsDriveFilterDevice)

  0001d	39 5e 08	 cmp	 DWORD PTR [esi+8], ebx
  00020	74 0c		 je	 SHORT $LN28@TCDispatch

; 241  : 			return DriveFilterDispatchIrp (DeviceObject, Irp);

  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 _DriveFilterDispatchIrp@8
  00029	e9 13 02 00 00	 jmp	 $LN30@TCDispatch
$LN28@TCDispatch:

; 242  : 
; 243  : 		// Volume filter IRP
; 244  : 		if (Extension->IsVolumeFilterDevice)

  0002e	39 5e 0c	 cmp	 DWORD PTR [esi+12], ebx
  00031	74 0c		 je	 SHORT $LN27@TCDispatch

; 245  : 			return VolumeFilterDispatchIrp (DeviceObject, Irp);

  00033	57		 push	 edi
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _VolumeFilterDispatchIrp@8
  0003a	e9 02 02 00 00	 jmp	 $LN30@TCDispatch
$LN27@TCDispatch:

; 246  : 	}
; 247  : 
; 248  : 	switch (irpSp->MajorFunction)

  0003f	8a 01		 mov	 al, BYTE PTR [ecx]
  00041	88 45 ff	 mov	 BYTE PTR tv306[ebp], al
  00044	0f b6 c0	 movzx	 eax, al
  00047	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  0004a	0f 8f 47 01 00
	00		 jg	 $LN32@TCDispatch
  00050	74 25		 je	 SHORT $LN15@TCDispatch
  00052	3b c3		 cmp	 eax, ebx
  00054	0f 84 dc 01 00
	00		 je	 $LN22@TCDispatch
  0005a	83 f8 02	 cmp	 eax, 2
  0005d	0f 84 d3 01 00
	00		 je	 $LN22@TCDispatch
  00063	0f 8e 6a 01 00
	00		 jle	 $LN1@TCDispatch
  00069	83 f8 04	 cmp	 eax, 4
  0006c	7e 09		 jle	 SHORT $LN15@TCDispatch
  0006e	83 f8 09	 cmp	 eax, 9
  00071	0f 85 5c 01 00
	00		 jne	 $LN1@TCDispatch
$LN15@TCDispatch:

; 271  : 
; 272  : 	case IRP_MJ_FLUSH_BUFFERS:
; 273  : 	case IRP_MJ_READ:
; 274  : 	case IRP_MJ_WRITE:
; 275  : 	case IRP_MJ_DEVICE_CONTROL:
; 276  : 
; 277  : 		if (Extension->bRootDevice)

  00077	3b d3		 cmp	 edx, ebx
  00079	74 3f		 je	 SHORT $LN14@TCDispatch

; 278  : 		{
; 279  : 			if (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL)

  0007b	80 7d ff 0e	 cmp	 BYTE PTR tv306[ebp], 14	; 0000000eH
  0007f	0f 85 4e 01 00
	00		 jne	 $LN1@TCDispatch

; 280  : 			{
; 281  : 				NTSTATUS status = KeWaitForMutexObject (&RootDeviceControlMutex, Executive, KernelMode, FALSE, NULL);

  00085	53		 push	 ebx
  00086	53		 push	 ebx
  00087	53		 push	 ebx
  00088	53		 push	 ebx
  00089	bf 00 00 00 00	 mov	 edi, OFFSET _RootDeviceControlMutex
  0008e	57		 push	 edi
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 282  : 				if (!NT_SUCCESS (status))

  00095	3b c3		 cmp	 eax, ebx

; 283  : 					return status;

  00097	0f 8c a4 01 00
	00		 jl	 $LN30@TCDispatch

; 284  : 
; 285  : 				status = ProcessMainDeviceControlIrp (DeviceObject, Extension, Irp);

  0009d	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  000a0	56		 push	 esi
  000a1	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  000a4	e8 00 00 00 00	 call	 _ProcessMainDeviceControlIrp@12

; 286  : 
; 287  : 				KeReleaseMutex (&RootDeviceControlMutex, FALSE);

  000a9	53		 push	 ebx
  000aa	57		 push	 edi
  000ab	8b f0		 mov	 esi, eax
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeReleaseMutex@8
$LN6@TCDispatch:

; 288  : 				return status;

  000b3	8b c6		 mov	 eax, esi
  000b5	e9 87 01 00 00	 jmp	 $LN30@TCDispatch
$LN14@TCDispatch:

; 289  : 			}
; 290  : 			break;
; 291  : 		}
; 292  : 
; 293  : 		if (Extension->bShuttingDown)

  000ba	39 5e 18	 cmp	 DWORD PTR [esi+24], ebx
  000bd	74 11		 je	 SHORT $LN11@TCDispatch

; 294  : 		{
; 295  : 			Dump ("Device %d shutting down: STATUS_DELETE_PENDING\n", Extension->nDosDriveNo);
; 296  : 			return TCCompleteDiskIrp (Irp, STATUS_DELETE_PENDING, 0);

  000bf	53		 push	 ebx
  000c0	68 56 00 00 c0	 push	 -1073741738		; c0000056H
$LN42@TCDispatch:
  000c5	57		 push	 edi
  000c6	e8 00 00 00 00	 call	 _TCCompleteDiskIrp@12
  000cb	e9 71 01 00 00	 jmp	 $LN30@TCDispatch
$LN11@TCDispatch:

; 297  : 		}
; 298  : 
; 299  : 		if (Extension->bRemovable
; 300  : 			&& (DeviceObject->Flags & DO_VERIFY_VOLUME)
; 301  : 			&& !(irpSp->Flags & SL_OVERRIDE_VERIFY_VOLUME)
; 302  : 			&& irpSp->MajorFunction != IRP_MJ_FLUSH_BUFFERS)

  000d0	39 9e 4c 02 00
	00		 cmp	 DWORD PTR [esi+588], ebx
  000d6	74 1d		 je	 SHORT $LN41@TCDispatch
  000d8	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  000db	f6 40 1c 02	 test	 BYTE PTR [eax+28], 2
  000df	74 14		 je	 SHORT $LN41@TCDispatch
  000e1	f6 41 02 02	 test	 BYTE PTR [ecx+2], 2
  000e5	75 0e		 jne	 SHORT $LN41@TCDispatch
  000e7	80 7d ff 09	 cmp	 BYTE PTR tv306[ebp], 9
  000eb	74 08		 je	 SHORT $LN41@TCDispatch

; 303  : 		{
; 304  : 			Dump ("Removable device %d has DO_VERIFY_VOLUME flag: STATUS_DEVICE_NOT_READY\n", Extension->nDosDriveNo);
; 305  : 			return TCCompleteDiskIrp (Irp, STATUS_DEVICE_NOT_READY, 0);

  000ed	53		 push	 ebx
  000ee	68 a3 00 00 c0	 push	 -1073741661		; c00000a3H
  000f3	eb d0		 jmp	 SHORT $LN42@TCDispatch
$LN41@TCDispatch:

; 306  : 		}
; 307  : 
; 308  : 		switch (irpSp->MajorFunction)

  000f5	8a 45 ff	 mov	 al, BYTE PTR tv306[ebp]
  000f8	3c 03		 cmp	 al, 3
  000fa	0f 82 d3 00 00
	00		 jb	 $LN1@TCDispatch
  00100	3c 04		 cmp	 al, 4
  00102	76 6b		 jbe	 SHORT $LN7@TCDispatch
  00104	3c 09		 cmp	 al, 9
  00106	74 60		 je	 SHORT $LN3@TCDispatch
  00108	3c 0e		 cmp	 al, 14			; 0000000eH
  0010a	0f 85 c3 00 00
	00		 jne	 $LN1@TCDispatch

; 318  : 
; 319  : 		case IRP_MJ_DEVICE_CONTROL:
; 320  : 			ntStatus = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00110	6a 18		 push	 24			; 00000018H
  00112	6a 01		 push	 1
  00114	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@FNODOBFM@
  00119	57		 push	 edi
  0011a	8d 86 18 01 00
	00		 lea	 eax, DWORD PTR [esi+280]
  00120	50		 push	 eax
  00121	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAcquireRemoveLockEx@20

; 321  : 			if (!NT_SUCCESS (ntStatus))

  00127	3b c3		 cmp	 eax, ebx
  00129	7d 0d		 jge	 SHORT $LN4@TCDispatch

; 322  : 				return TCCompleteIrp (Irp, ntStatus, 0);

  0012b	53		 push	 ebx
  0012c	50		 push	 eax
$LN43@TCDispatch:
  0012d	57		 push	 edi
  0012e	e8 00 00 00 00	 call	 _TCCompleteIrp@12
  00133	e9 09 01 00 00	 jmp	 $LN30@TCDispatch
$LN4@TCDispatch:

; 323  : 
; 324  : 			IoMarkIrpPending (Irp);

  00138	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  0013b	80 48 03 01	 or	 BYTE PTR [eax+3], 1

; 325  : 			
; 326  : 			ExInterlockedInsertTailList (&Extension->ListEntry, &Irp->Tail.Overlay.ListEntry, &Extension->ListSpinLock);

  0013f	8d 46 34	 lea	 eax, DWORD PTR [esi+52]
  00142	50		 push	 eax
  00143	8d 57 58	 lea	 edx, DWORD PTR [edi+88]
  00146	8d 4e 38	 lea	 ecx, DWORD PTR [esi+56]
  00149	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExfInterlockedInsertTailList@12

; 327  : 			KeReleaseSemaphore (&Extension->RequestSemaphore, IO_DISK_INCREMENT, 1, FALSE);

  0014f	53		 push	 ebx
  00150	6a 01		 push	 1
  00152	6a 01		 push	 1
  00154	83 c6 40	 add	 esi, 64			; 00000040H
  00157	56		 push	 esi
  00158	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeReleaseSemaphore@16

; 328  : 			
; 329  : 			return STATUS_PENDING;

  0015e	b8 03 01 00 00	 mov	 eax, 259		; 00000103H
  00163	e9 d9 00 00 00	 jmp	 $LN30@TCDispatch
$LN3@TCDispatch:

; 330  : 
; 331  : 		case IRP_MJ_FLUSH_BUFFERS:
; 332  : 			return TCCompleteDiskIrp (Irp, STATUS_SUCCESS, 0);

  00168	53		 push	 ebx
  00169	53		 push	 ebx
  0016a	e9 56 ff ff ff	 jmp	 $LN42@TCDispatch
$LN7@TCDispatch:

; 309  : 		{
; 310  : 		case IRP_MJ_READ:
; 311  : 		case IRP_MJ_WRITE:
; 312  : 			ntStatus = EncryptedIoQueueAddIrp (&Extension->Queue, Irp);

  0016f	57		 push	 edi
  00170	81 c6 a8 00 00
	00		 add	 esi, 168		; 000000a8H
  00176	56		 push	 esi
  00177	e8 00 00 00 00	 call	 _EncryptedIoQueueAddIrp@8
  0017c	8b f0		 mov	 esi, eax

; 313  : 
; 314  : 			if (ntStatus != STATUS_PENDING)

  0017e	81 fe 03 01 00
	00		 cmp	 esi, 259		; 00000103H
  00184	0f 84 29 ff ff
	ff		 je	 $LN6@TCDispatch

; 315  : 				TCCompleteDiskIrp (Irp, ntStatus, 0);

  0018a	53		 push	 ebx
  0018b	56		 push	 esi
  0018c	57		 push	 edi
  0018d	e8 00 00 00 00	 call	 _TCCompleteDiskIrp@12

; 316  : 
; 317  : 			return ntStatus;

  00192	e9 1c ff ff ff	 jmp	 $LN6@TCDispatch
$LN32@TCDispatch:

; 246  : 	}
; 247  : 
; 248  : 	switch (irpSp->MajorFunction)

  00197	83 e8 10	 sub	 eax, 16			; 00000010H
  0019a	74 42		 je	 SHORT $LN23@TCDispatch
  0019c	48		 dec	 eax
  0019d	48		 dec	 eax
  0019e	0f 84 92 00 00
	00		 je	 $LN22@TCDispatch
  001a4	83 e8 09	 sub	 eax, 9
  001a7	75 2a		 jne	 SHORT $LN1@TCDispatch

; 333  : 		}
; 334  : 
; 335  : 		break;
; 336  : 
; 337  : 	case IRP_MJ_PNP:
; 338  : 		if (!Extension->bRootDevice
; 339  : 			&& Extension->IsVolumeDevice
; 340  : 			&& irpSp->MinorFunction == IRP_MN_DEVICE_USAGE_NOTIFICATION
; 341  : 			&& irpSp->Parameters.UsageNotification.Type == DeviceUsageTypePaging
; 342  : 			&& irpSp->Parameters.UsageNotification.InPath)

  001a9	3b d3		 cmp	 edx, ebx
  001ab	75 26		 jne	 SHORT $LN1@TCDispatch
  001ad	39 5e 04	 cmp	 DWORD PTR [esi+4], ebx
  001b0	74 21		 je	 SHORT $LN1@TCDispatch
  001b2	80 79 01 16	 cmp	 BYTE PTR [ecx+1], 22	; 00000016H
  001b6	75 1b		 jne	 SHORT $LN1@TCDispatch
  001b8	40		 inc	 eax
  001b9	39 41 08	 cmp	 DWORD PTR [ecx+8], eax
  001bc	75 15		 jne	 SHORT $LN1@TCDispatch
  001be	38 59 04	 cmp	 BYTE PTR [ecx+4], bl
  001c1	74 10		 je	 SHORT $LN1@TCDispatch

; 343  : 		{
; 344  : 			PagingFileCreationPrevented = TRUE;
; 345  : 			return TCCompleteIrp (Irp, STATUS_UNSUCCESSFUL, 0);

  001c3	53		 push	 ebx
  001c4	a3 00 00 00 00	 mov	 DWORD PTR _PagingFileCreationPrevented, eax
  001c9	68 01 00 00 c0	 push	 -1073741823		; c0000001H
  001ce	e9 5a ff ff ff	 jmp	 $LN43@TCDispatch
$LN1@TCDispatch:

; 346  : 		}
; 347  : 		break;
; 348  : 	}
; 349  : 
; 350  : 	return TCCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);

  001d3	53		 push	 ebx
  001d4	68 10 00 00 c0	 push	 -1073741808		; c0000010H
  001d9	e9 4f ff ff ff	 jmp	 $LN43@TCDispatch
$LN23@TCDispatch:

; 249  : 	{
; 250  : 	case IRP_MJ_CLOSE:
; 251  : 	case IRP_MJ_CREATE:
; 252  : 	case IRP_MJ_CLEANUP:
; 253  : 		return COMPLETE_IRP (DeviceObject, Irp, STATUS_SUCCESS, 0);
; 254  : 
; 255  : 	case IRP_MJ_SHUTDOWN:
; 256  : 		if (Extension->bRootDevice)

  001de	3b d3		 cmp	 edx, ebx
  001e0	74 54		 je	 SHORT $LN22@TCDispatch

; 257  : 		{
; 258  : 			Dump ("Driver shutting down\n");
; 259  : 			DriverShuttingDown = TRUE;

  001e2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _DriverShuttingDown, 1

; 260  : 
; 261  : 			if (EncryptionSetupThread)

  001ec	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH
  001f1	39 1d 00 00 00
	00		 cmp	 DWORD PTR _EncryptionSetupThread, ebx
  001f7	74 18		 je	 SHORT $LN19@TCDispatch
$LL20@TCDispatch:

; 262  : 				while (SendDeviceIoControlRequest (RootDeviceObject, TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP, NULL, 0, NULL, 0) == STATUS_INSUFFICIENT_RESOURCES);

  001f9	53		 push	 ebx
  001fa	53		 push	 ebx
  001fb	53		 push	 ebx
  001fc	53		 push	 ebx
  001fd	68 50 20 22 00	 push	 2236496			; 00222050H
  00202	ff 35 00 00 00
	00		 push	 DWORD PTR _RootDeviceObject
  00208	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  0020d	3b c6		 cmp	 eax, esi
  0020f	74 e8		 je	 SHORT $LL20@TCDispatch
$LN19@TCDispatch:

; 263  : 
; 264  : 			if (DecoySystemWipeThread)

  00211	39 1d 00 00 00
	00		 cmp	 DWORD PTR _DecoySystemWipeThread, ebx
  00217	74 18		 je	 SHORT $LN16@TCDispatch
$LL17@TCDispatch:

; 265  : 				while (SendDeviceIoControlRequest (RootDeviceObject, TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE, NULL, 0, NULL, 0) == STATUS_INSUFFICIENT_RESOURCES);

  00219	53		 push	 ebx
  0021a	53		 push	 ebx
  0021b	53		 push	 ebx
  0021c	53		 push	 ebx
  0021d	68 7c 20 22 00	 push	 2236540			; 0022207cH
  00222	ff 35 00 00 00
	00		 push	 DWORD PTR _RootDeviceObject
  00228	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  0022d	3b c6		 cmp	 eax, esi
  0022f	74 e8		 je	 SHORT $LL17@TCDispatch
$LN16@TCDispatch:

; 266  : 
; 267  : 			OnShutdownPending();

  00231	e8 00 00 00 00	 call	 _OnShutdownPending@0
$LN22@TCDispatch:

; 268  : 		}
; 269  : 
; 270  : 		return COMPLETE_IRP (DeviceObject, Irp, STATUS_SUCCESS, 0);

  00236	53		 push	 ebx
  00237	53		 push	 ebx
  00238	57		 push	 edi
  00239	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  0023c	e8 00 00 00 00	 call	 _COMPLETE_IRP@16
$LN30@TCDispatch:
  00241	5f		 pop	 edi
  00242	5e		 pop	 esi
  00243	5b		 pop	 ebx

; 351  : }

  00244	c9		 leave
  00245	c2 08 00	 ret	 8
_TCDispatchQueueIRP@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1M@IOJLKPKK@?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	_DriverEntry@8
EXTRN	_LoadBootArguments@0:PROC
EXTRN	_AutoTestAlgorithms@0:PROC
EXTRN	_EncryptionThreadPoolStart@4:PROC
EXTRN	_DumpFilterEntry@8:PROC
EXTRN	__imp__PsGetVersion@16:PROC
;	COMDAT ??_C@_1M@IOJLKPKK@?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_1M@IOJLKPKK@?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@PBOPGDP@ DB 'S', 00H, 't'
	DB	00H, 'a', 00H, 'r', 00H, 't', 00H, 00H, 00H	;  ?? ::PBOPGDP::`string'
; Function compile flags: /Ogsp
INIT$s	ENDS
;	COMDAT _DriverEntry@8
INIT	SEGMENT
_version$ = -4						; size = 4
_startKeyValue$ = 8					; size = 4
_DriverObject$ = 8					; size = 4
_RegistryPath$ = 12					; size = 4
_DriverEntry@8 PROC					; COMDAT

; 63   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	57		 push	 edi

; 64   : 	PKEY_VALUE_PARTIAL_INFORMATION startKeyValue;
; 65   : 	LONG version;
; 66   : 	int i;
; 67   : 
; 68   : 	Dump ("DriverEntry " TC_APP_NAME " " VERSION_STRING "\n");
; 69   : 
; 70   : 	PsGetVersion (&OsMajorVersion, &OsMinorVersion, NULL, NULL);

  00007	33 ff		 xor	 edi, edi
  00009	57		 push	 edi
  0000a	57		 push	 edi
  0000b	68 00 00 00 00	 push	 OFFSET _OsMinorVersion
  00010	68 00 00 00 00	 push	 OFFSET _OsMajorVersion
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsGetVersion@16

; 71   : 
; 72   : 	// Load dump filter if the main driver is already loaded
; 73   : 	if (NT_SUCCESS (TCDeviceIoControl (NT_ROOT_PREFIX, TC_IOCTL_GET_DRIVER_VERSION, NULL, 0, &version, sizeof (version))))

  0001b	6a 04		 push	 4
  0001d	8d 45 fc	 lea	 eax, DWORD PTR _version$[ebp]
  00020	50		 push	 eax
  00021	57		 push	 edi
  00022	57		 push	 edi
  00023	68 04 20 22 00	 push	 2236420			; 00222004H
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@
  0002d	e8 00 00 00 00	 call	 _TCDeviceIoControl@24
  00032	85 c0		 test	 eax, eax
  00034	7c 10		 jl	 SHORT $LN7@DriverEntr

; 74   : 		return DumpFilterEntry ((PFILTER_EXTENSION) DriverObject, (PFILTER_INITIALIZATION_DATA) RegistryPath);

  00036	ff 75 0c	 push	 DWORD PTR _RegistryPath$[ebp]
  00039	ff 75 08	 push	 DWORD PTR _DriverObject$[ebp]
  0003c	e8 00 00 00 00	 call	 _DumpFilterEntry@8
  00041	e9 b8 00 00 00	 jmp	 $LN8@DriverEntr
$LN7@DriverEntr:
  00046	56		 push	 esi

; 75   : 
; 76   : 	TCDriverObject = DriverObject;

  00047	8b 75 08	 mov	 esi, DWORD PTR _DriverObject$[ebp]

; 77   : 	memset (VirtualVolumeDeviceObjects, 0, sizeof (VirtualVolumeDeviceObjects));

  0004a	6a 68		 push	 104			; 00000068H
  0004c	57		 push	 edi
  0004d	68 00 00 00 00	 push	 OFFSET _VirtualVolumeDeviceObjects
  00052	89 35 00 00 00
	00		 mov	 DWORD PTR _TCDriverObject, esi
  00058	e8 00 00 00 00	 call	 _memset
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 78   : 
; 79   : 	ReadRegistryConfigFlags (TRUE);

  00060	6a 01		 push	 1
  00062	e8 00 00 00 00	 call	 _ReadRegistryConfigFlags@4

; 80   : 	EncryptionThreadPoolStart (EncryptionThreadPoolFreeCpuCountLimit);

  00067	ff 35 00 00 00
	00		 push	 DWORD PTR _EncryptionThreadPoolFreeCpuCountLimit
  0006d	e8 00 00 00 00	 call	 _EncryptionThreadPoolStart@4

; 81   : 	SelfTestsPassed = AutoTestAlgorithms();

  00072	e8 00 00 00 00	 call	 _AutoTestAlgorithms@0
  00077	a3 00 00 00 00	 mov	 DWORD PTR _SelfTestsPassed, eax

; 82   : 
; 83   : 	// Enable device class filters and load boot arguments if the driver is set to start at system boot
; 84   : 		
; 85   : 	if (NT_SUCCESS (TCReadRegistryKey (RegistryPath, L"Start", &startKeyValue)))

  0007c	8d 45 08	 lea	 eax, DWORD PTR _startKeyValue$[ebp]
  0007f	50		 push	 eax
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_1M@IOJLKPKK@?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@PBOPGDP@
  00085	ff 75 0c	 push	 DWORD PTR _RegistryPath$[ebp]
  00088	e8 00 00 00 00	 call	 _TCReadRegistryKey@12
  0008d	85 c0		 test	 eax, eax
  0008f	7c 52		 jl	 SHORT $LN6@DriverEntr
  00091	53		 push	 ebx

; 86   : 	{
; 87   : 		if (startKeyValue->Type == REG_DWORD && *((uint32 *) startKeyValue->Data) == SERVICE_BOOT_START)

  00092	8b 5d 08	 mov	 ebx, DWORD PTR _startKeyValue$[ebp]
  00095	83 7b 04 04	 cmp	 DWORD PTR [ebx+4], 4
  00099	75 3b		 jne	 SHORT $LN5@DriverEntr
  0009b	39 7b 0c	 cmp	 DWORD PTR [ebx+12], edi
  0009e	75 36		 jne	 SHORT $LN5@DriverEntr

; 88   : 		{
; 89   : 			if (!SelfTestsPassed)

  000a0	39 3d 00 00 00
	00		 cmp	 DWORD PTR _SelfTestsPassed, edi
  000a6	75 15		 jne	 SHORT $LN4@DriverEntr

; 90   : 				TC_BUG_CHECK (STATUS_INVALID_PARAMETER);

  000a8	68 43 54 00 00	 push	 21571			; 00005443H
  000ad	57		 push	 edi
  000ae	68 0d 00 00 c0	 push	 -1073741811		; c000000dH
  000b3	6a 5a		 push	 90			; 0000005aH
  000b5	6a 29		 push	 41			; 00000029H
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN13@DriverEntr:
$LN4@DriverEntr:

; 91   : 
; 92   : 			LoadBootArguments();

  000bd	e8 00 00 00 00	 call	 _LoadBootArguments@0

; 93   : 			VolumeClassFilterRegistered = IsVolumeClassFilterRegistered();

  000c2	e8 00 00 00 00	 call	 _IsVolumeClassFilterRegistered@0
  000c7	a3 00 00 00 00	 mov	 DWORD PTR _VolumeClassFilterRegistered, eax

; 94   : 
; 95   : 			DriverObject->DriverExtension->AddDevice = DriverAddDevice;

  000cc	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  000cf	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET _DriverAddDevice@8
$LN5@DriverEntr:

; 96   : 		}
; 97   : 
; 98   : 		TCfree (startKeyValue);

  000d6	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  000db	53		 push	 ebx
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
  000e2	5b		 pop	 ebx
$LN6@DriverEntr:

; 99   : 	}
; 100  : 
; 101  : 	for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; ++i)
; 102  : 	{
; 103  : 		DriverObject->MajorFunction[i] = TCDispatchQueueIRP;

  000e3	6a 1c		 push	 28			; 0000001cH
  000e5	59		 pop	 ecx
  000e6	b8 00 00 00 00	 mov	 eax, OFFSET _TCDispatchQueueIRP@8
  000eb	8d 7e 38	 lea	 edi, DWORD PTR [esi+56]
  000ee	f3 ab		 rep stosd

; 104  : 	}
; 105  : 
; 106  : 	DriverObject->DriverUnload = TCUnloadDriver;
; 107  : 	return TCCreateRootDeviceObject (DriverObject);

  000f0	56		 push	 esi
  000f1	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], OFFSET _TCUnloadDriver@4
  000f8	e8 00 00 00 00	 call	 _TCCreateRootDeviceObject@4
  000fd	5e		 pop	 esi
$LN8@DriverEntr:
  000fe	5f		 pop	 edi

; 108  : }

  000ff	c9		 leave
  00100	c2 08 00	 ret	 8
$LN12@DriverEntr:
_DriverEntry@8 ENDP
INIT	ENDS
END
