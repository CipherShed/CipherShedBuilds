; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\home\public\Desktop\projects\ciphershed.build\src\Common\util\unicode\ConvertUTF.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
_halfShift DD	0aH
_halfBase DD	010000H
_halfMask DD	03ffH
	ORG $+4
_trailingBytesForUTF8 DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
_offsetsFromUTF8 DD 00H
	DD	03080H
	DD	0e2080H
	DD	03c82080H
	DD	0fa082080H
	DD	082082080H
_firstByteMark DB 00H
	DB	00H
	DB	0c0H
	DB	0e0H
	DB	0f0H
	DB	0f8H
	DB	0fcH
CONST	ENDS
PUBLIC	_ConvertUTF16toUTF8
; Function compile flags: /Ogtpy
; File c:\home\public\desktop\projects\ciphershed.build\src\common\util\unicode\convertutf.c
;	COMDAT _ConvertUTF16toUTF8
_TEXT	SEGMENT
_sourceStart$ = 8					; size = 4
_sourceEnd$ = 12					; size = 4
_targetStart$ = 16					; size = 4
_targetEnd$ = 20					; size = 4
_flags$ = 24						; size = 4
_ConvertUTF16toUTF8 PROC				; COMDAT

; 218  :     ConversionResult result = conversionOK;
; 219  :     const UTF16* source = *sourceStart;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _sourceStart$[esp-4]

; 220  :     UTF8* target = *targetStart;

  00004	8b 54 24 0c	 mov	 edx, DWORD PTR _targetStart$[esp-4]
  00008	8b 12		 mov	 edx, DWORD PTR [edx]
  0000a	57		 push	 edi
  0000b	8b 39		 mov	 edi, DWORD PTR [ecx]
  0000d	33 c0		 xor	 eax, eax

; 221  :     while (source < sourceEnd) {

  0000f	3b 7c 24 0c	 cmp	 edi, DWORD PTR _sourceEnd$[esp]
  00013	0f 83 50 01 00
	00		 jae	 $LN25@ConvertUTF
  00019	53		 push	 ebx
  0001a	55		 push	 ebp
  0001b	56		 push	 esi
  0001c	8d 64 24 00	 npad	 4
$LL26@ConvertUTF:

; 222  :         UTF32 ch;
; 223  :         unsigned short bytesToWrite = 0;
; 224  :         const UTF32 byteMask = 0xBF;
; 225  :         const UTF32 byteMark = 0x80; 
; 226  :         const UTF16* oldSource = source; /* In case we have to back up because of target overflow. */
; 227  :         ch = *source++;

  00020	0f b7 0f	 movzx	 ecx, WORD PTR [edi]
  00023	8b df		 mov	 ebx, edi

; 228  :         /* If we have a surrogate pair, convert to UTF32 first. */
; 229  :         if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {

  00025	8d b1 00 28 ff
	ff		 lea	 esi, DWORD PTR [ecx-55296]
  0002b	83 c7 02	 add	 edi, 2
  0002e	81 fe ff 03 00
	00		 cmp	 esi, 1023		; 000003ffH
  00034	77 4a		 ja	 SHORT $LN24@ConvertUTF

; 230  :             /* If the 16 bits following the high surrogate are in the source buffer... */
; 231  :             if (source < sourceEnd) {

  00036	3b 7c 24 18	 cmp	 edi, DWORD PTR _sourceEnd$[esp+12]
  0003a	0f 83 01 01 00
	00		 jae	 $LN23@ConvertUTF

; 232  :                 UTF32 ch2 = *source;

  00040	0f b7 37	 movzx	 esi, WORD PTR [edi]

; 233  :                 /* If it's a low surrogate, convert to UTF32. */
; 234  :                 if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) {

  00043	8d ae 00 24 ff
	ff		 lea	 ebp, DWORD PTR [esi-56320]
  00049	81 fd ff 03 00
	00		 cmp	 ebp, 1023		; 000003ffH
  0004f	77 10		 ja	 SHORT $LN22@ConvertUTF

; 235  :                     ch = ((ch - UNI_SUR_HIGH_START) << halfShift)
; 236  :                         + (ch2 - UNI_SUR_LOW_START) + halfBase;

  00051	81 c1 09 28 ff
	ff		 add	 ecx, -55287		; ffff2809H
  00057	c1 e1 0a	 shl	 ecx, 10			; 0000000aH
  0005a	03 ce		 add	 ecx, esi

; 237  :                     ++source;

  0005c	83 c7 02	 add	 edi, 2
  0005f	eb 35		 jmp	 SHORT $LN16@ConvertUTF
$LN22@ConvertUTF:

; 238  :                 } else if (flags == strictConversion) { /* it's an unpaired high surrogate */

  00061	39 44 24 24	 cmp	 DWORD PTR _flags$[esp+12], eax
  00065	75 2f		 jne	 SHORT $LN16@ConvertUTF
$LN31@ConvertUTF:

; 277  :     }
; 278  :     *sourceStart = source;

  00067	8b 4c 24 14	 mov	 ecx, DWORD PTR _sourceStart$[esp+12]
  0006b	5e		 pop	 esi
  0006c	83 ef 02	 sub	 edi, 2
  0006f	5d		 pop	 ebp
  00070	89 39		 mov	 DWORD PTR [ecx], edi

; 279  :     *targetStart = target;

  00072	8b 4c 24 14	 mov	 ecx, DWORD PTR _targetStart$[esp+4]
  00076	5b		 pop	 ebx
  00077	b8 03 00 00 00	 mov	 eax, 3
  0007c	89 11		 mov	 DWORD PTR [ecx], edx
  0007e	5f		 pop	 edi

; 280  :     return result;
; 281  : }

  0007f	c3		 ret	 0
$LN24@ConvertUTF:

; 239  :                     --source; /* return to the illegal value itself */
; 240  :                     result = sourceIllegal;
; 241  :                     break;
; 242  :                 }
; 243  :             } else { /* We don't have the 16 bits following the high surrogate. */
; 244  :                 --source; /* return to the high surrogate */
; 245  :                 result = sourceExhausted;
; 246  :                 break;
; 247  :             }
; 248  :         } else if (flags == strictConversion) {

  00080	39 44 24 24	 cmp	 DWORD PTR _flags$[esp+12], eax
  00084	75 10		 jne	 SHORT $LN16@ConvertUTF

; 249  :             /* UTF-16 surrogate values are illegal in UTF-32 */
; 250  :             if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) {

  00086	81 f9 00 dc 00
	00		 cmp	 ecx, 56320		; 0000dc00H
  0008c	72 08		 jb	 SHORT $LN16@ConvertUTF
  0008e	81 f9 ff df 00
	00		 cmp	 ecx, 57343		; 0000dfffH
  00094	76 d1		 jbe	 SHORT $LN31@ConvertUTF
$LN16@ConvertUTF:

; 251  :                 --source; /* return to the illegal value itself */
; 252  :                 result = sourceIllegal;
; 253  :                 break;
; 254  :             }
; 255  :         }
; 256  :         /* Figure out how many bytes the result will require */
; 257  :         if (ch < (UTF32)0x80) {      bytesToWrite = 1;

  00096	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  0009c	73 07		 jae	 SHORT $LN15@ConvertUTF
  0009e	be 01 00 00 00	 mov	 esi, 1
  000a3	eb 30		 jmp	 SHORT $LN8@ConvertUTF
$LN15@ConvertUTF:

; 258  :         } else if (ch < (UTF32)0x800) {     bytesToWrite = 2;

  000a5	81 f9 00 08 00
	00		 cmp	 ecx, 2048		; 00000800H
  000ab	73 07		 jae	 SHORT $LN13@ConvertUTF
  000ad	be 02 00 00 00	 mov	 esi, 2
  000b2	eb 21		 jmp	 SHORT $LN8@ConvertUTF
$LN13@ConvertUTF:

; 259  :         } else if (ch < (UTF32)0x10000) {   bytesToWrite = 3;

  000b4	81 f9 00 00 01
	00		 cmp	 ecx, 65536		; 00010000H
  000ba	72 14		 jb	 SHORT $LN42@ConvertUTF

; 260  :         } else if (ch < (UTF32)0x110000) {  bytesToWrite = 4;

  000bc	81 f9 00 00 11
	00		 cmp	 ecx, 1114112		; 00110000H
  000c2	73 07		 jae	 SHORT $LN9@ConvertUTF
  000c4	be 04 00 00 00	 mov	 esi, 4
  000c9	eb 0a		 jmp	 SHORT $LN8@ConvertUTF
$LN9@ConvertUTF:

; 262  :                                             ch = UNI_REPLACEMENT_CHAR;

  000cb	b9 fd ff 00 00	 mov	 ecx, 65533		; 0000fffdH
$LN42@ConvertUTF:

; 261  :         } else {                            bytesToWrite = 3;

  000d0	be 03 00 00 00	 mov	 esi, 3
$LN8@ConvertUTF:

; 263  :         }
; 264  : 
; 265  :         target += bytesToWrite;

  000d5	0f b7 ee	 movzx	 ebp, si
  000d8	03 d5		 add	 edx, ebp

; 266  :         if (target > targetEnd) {

  000da	3b 54 24 20	 cmp	 edx, DWORD PTR _targetEnd$[esp+12]
  000de	77 7a		 ja	 SHORT $LN32@ConvertUTF

; 269  :         }
; 270  :         switch (bytesToWrite) { /* note: everything falls through. */

  000e0	8d 75 ff	 lea	 esi, DWORD PTR [ebp-1]
  000e3	83 fe 03	 cmp	 esi, 3
  000e6	77 3c		 ja	 SHORT $LN38@ConvertUTF
  000e8	ff 24 b5 00 00
	00 00		 jmp	 DWORD PTR $LN43@ConvertUTF[esi*4]
$LN4@ConvertUTF:

; 271  :             case 4: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

  000ef	8a d9		 mov	 bl, cl
  000f1	80 e3 3f	 and	 bl, 63			; 0000003fH
  000f4	4a		 dec	 edx
  000f5	80 cb 80	 or	 bl, 128			; 00000080H
  000f8	88 1a		 mov	 BYTE PTR [edx], bl
  000fa	c1 e9 06	 shr	 ecx, 6
$LN35@ConvertUTF:

; 272  :             case 3: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

  000fd	8a d9		 mov	 bl, cl
  000ff	80 e3 3f	 and	 bl, 63			; 0000003fH
  00102	4a		 dec	 edx
  00103	80 cb 80	 or	 bl, 128			; 00000080H
  00106	88 1a		 mov	 BYTE PTR [edx], bl
  00108	c1 e9 06	 shr	 ecx, 6
$LN36@ConvertUTF:

; 273  :             case 2: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

  0010b	8a d9		 mov	 bl, cl
  0010d	80 e3 3f	 and	 bl, 63			; 0000003fH
  00110	4a		 dec	 edx
  00111	80 cb 80	 or	 bl, 128			; 00000080H
  00114	88 1a		 mov	 BYTE PTR [edx], bl
  00116	c1 e9 06	 shr	 ecx, 6
$LN37@ConvertUTF:

; 274  :             case 1: *--target =  (UTF8)(ch | firstByteMark[bytesToWrite]);

  00119	8a 9d 00 00 00
	00		 mov	 bl, BYTE PTR _firstByteMark[ebp]
  0011f	4a		 dec	 edx
  00120	0a d9		 or	 bl, cl
  00122	88 1a		 mov	 BYTE PTR [edx], bl
$LN38@ConvertUTF:

; 275  :         }
; 276  :         target += bytesToWrite;

  00124	03 d5		 add	 edx, ebp
  00126	3b 7c 24 18	 cmp	 edi, DWORD PTR _sourceEnd$[esp+12]
  0012a	0f 82 f0 fe ff
	ff		 jb	 $LL26@ConvertUTF

; 277  :     }
; 278  :     *sourceStart = source;

  00130	8b 4c 24 14	 mov	 ecx, DWORD PTR _sourceStart$[esp+12]
  00134	5e		 pop	 esi
  00135	5d		 pop	 ebp
  00136	89 39		 mov	 DWORD PTR [ecx], edi

; 279  :     *targetStart = target;

  00138	8b 4c 24 14	 mov	 ecx, DWORD PTR _targetStart$[esp+4]
  0013c	5b		 pop	 ebx
  0013d	89 11		 mov	 DWORD PTR [ecx], edx
  0013f	5f		 pop	 edi

; 280  :     return result;
; 281  : }

  00140	c3		 ret	 0
$LN23@ConvertUTF:

; 277  :     }
; 278  :     *sourceStart = source;

  00141	8b 4c 24 14	 mov	 ecx, DWORD PTR _sourceStart$[esp+12]
  00145	5e		 pop	 esi
  00146	83 ef 02	 sub	 edi, 2
  00149	5d		 pop	 ebp
  0014a	89 39		 mov	 DWORD PTR [ecx], edi

; 279  :     *targetStart = target;

  0014c	8b 4c 24 14	 mov	 ecx, DWORD PTR _targetStart$[esp+4]
  00150	5b		 pop	 ebx
  00151	b8 01 00 00 00	 mov	 eax, 1
  00156	89 11		 mov	 DWORD PTR [ecx], edx
  00158	5f		 pop	 edi

; 280  :     return result;
; 281  : }

  00159	c3		 ret	 0
$LN32@ConvertUTF:

; 267  :             source = oldSource; /* Back up source pointer! */
; 268  :             target -= bytesToWrite; result = targetExhausted; break;

  0015a	0f b7 c6	 movzx	 eax, si
  0015d	5e		 pop	 esi
  0015e	5d		 pop	 ebp
  0015f	8b fb		 mov	 edi, ebx
  00161	2b d0		 sub	 edx, eax
  00163	b8 02 00 00 00	 mov	 eax, 2
  00168	5b		 pop	 ebx
$LN25@ConvertUTF:

; 277  :     }
; 278  :     *sourceStart = source;

  00169	8b 4c 24 08	 mov	 ecx, DWORD PTR _sourceStart$[esp]
  0016d	89 39		 mov	 DWORD PTR [ecx], edi

; 279  :     *targetStart = target;

  0016f	8b 4c 24 10	 mov	 ecx, DWORD PTR _targetStart$[esp]
  00173	89 11		 mov	 DWORD PTR [ecx], edx
  00175	5f		 pop	 edi

; 280  :     return result;
; 281  : }

  00176	c3		 ret	 0
  00177	90		 npad	 1
$LN43@ConvertUTF:
  00178	00 00 00 00	 DD	 $LN37@ConvertUTF
  0017c	00 00 00 00	 DD	 $LN36@ConvertUTF
  00180	00 00 00 00	 DD	 $LN35@ConvertUTF
  00184	00 00 00 00	 DD	 $LN4@ConvertUTF
_ConvertUTF16toUTF8 ENDP
_TEXT	ENDS
END
