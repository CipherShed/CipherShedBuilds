; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\home\public\Desktop\projects\ciphershed.build\src\Common\Cmdline.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_06EEAEEKCL@?$CFs?7?$CFs?6?$AA@		; `string'
PUBLIC	??_C@_0BI@HHPEFDNB@Command?5line?5options?3?6?6?$AA@ ; `string'
PUBLIC	??_C@_0BE@GKKPACCB@IDD_COMMANDHELP_DLG?$AA@	; `string'
PUBLIC	_hwndDlg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_CommandHelpDlgProc@16
EXTRN	__imp__EndDialog@8:PROC
EXTRN	__imp__SetWindowTextA@8:PROC
EXTRN	__imp__GetDlgItem@8:PROC
EXTRN	_sprintf_s:PROC
EXTRN	_LocalizeDialog:PROC
EXTRN	_err_malloc:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_06EEAEEKCL@?$CFs?7?$CFs?6?$AA@
; File c:\home\public\desktop\projects\ciphershed.build\src\common\cmdline.c
CONST	SEGMENT
??_C@_06EEAEEKCL@?$CFs?7?$CFs?6?$AA@ DB '%s', 09H, '%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HHPEFDNB@Command?5line?5options?3?6?6?$AA@
CONST	SEGMENT
??_C@_0BI@HHPEFDNB@Command?5line?5options?3?6?6?$AA@ DB 'Command line opt'
	DB	'ions:', 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GKKPACCB@IDD_COMMANDHELP_DLG?$AA@
CONST	SEGMENT
??_C@_0BE@GKKPACCB@IDD_COMMANDHELP_DLG?$AA@ DB 'IDD_COMMANDHELP_DLG', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _CommandHelpDlgProc@16
_TEXT	SEGMENT
tv225 = -536						; size = 4
_i$80126 = -532						; size = 4
_hwndDlg$GSCopy$ = -528					; size = 4
_tmp2$80124 = -524					; size = 520
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_msg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_CommandHelpDlgProc@16 PROC				; COMDAT

; 29   : {

  00000	81 ec 18 02 00
	00		 sub	 esp, 536		; 00000218H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 14 02
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+536], eax

; 30   : 	if (lParam);		/* remove warning */
; 31   : 	if (wParam);		/* remove warning */
; 32   : 
; 33   : 	switch (msg)

  00014	8b 84 24 20 02
	00 00		 mov	 eax, DWORD PTR _msg$[esp+532]
  0001b	83 e8 10	 sub	 eax, 16			; 00000010H
  0001e	53		 push	 ebx
  0001f	8b 9c 24 2c 02
	00 00		 mov	 ebx, DWORD PTR _lParam$[esp+536]
  00026	56		 push	 esi
  00027	8b b4 24 24 02
	00 00		 mov	 esi, DWORD PTR _hwndDlg$[esp+540]

; 49   : 		for (i = 0; i < as->arg_cnt; i ++)

  0002e	89 74 24 10	 mov	 DWORD PTR _hwndDlg$GSCopy$[esp+544], esi
  00032	0f 84 03 01 00
	00		 je	 $LN1@CommandHel

; 30   : 	if (lParam);		/* remove warning */
; 31   : 	if (wParam);		/* remove warning */
; 32   : 
; 33   : 	switch (msg)

  00038	2d 00 01 00 00	 sub	 eax, 256		; 00000100H
  0003d	74 13		 je	 SHORT $LN7@CommandHel
  0003f	83 e8 01	 sub	 eax, 1
  00042	74 07		 je	 SHORT $LN2@CommandHel

; 68   : 	}
; 69   : 
; 70   : 	return 0;

  00044	33 c0		 xor	 eax, eax
  00046	e9 fe 00 00 00	 jmp	 $LN12@CommandHel
$LN2@CommandHel:

; 60   : 		}
; 61   : 
; 62   : 	case WM_COMMAND:
; 63   : 		EndDialog (hwndDlg, IDOK);

  0004b	6a 01		 push	 1

; 64   : 		return 1;

  0004d	e9 eb 00 00 00	 jmp	 $LN19@CommandHel
$LN7@CommandHel:
  00052	55		 push	 ebp

; 34   : 	{
; 35   : 	case WM_INITDIALOG:
; 36   : 		{
; 37   : 		char * tmp = err_malloc(8192);

  00053	68 00 20 00 00	 push	 8192			; 00002000H
  00058	e8 00 00 00 00	 call	 _err_malloc

; 38   : 		char tmp2[MAX_PATH * 2];
; 39   : 		argumentspec *as;
; 40   : 		int i;
; 41   : 
; 42   : 		LocalizeDialog (hwndDlg, "IDD_COMMANDHELP_DLG");

  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@GKKPACCB@IDD_COMMANDHELP_DLG?$AA@
  00062	56		 push	 esi
  00063	8b e8		 mov	 ebp, eax
  00065	e8 00 00 00 00	 call	 _LocalizeDialog

; 43   : 
; 44   : 		as = (argumentspec*) lParam;
; 45   : 
; 46   : 		*tmp = 0;

  0006a	c6 45 00 00	 mov	 BYTE PTR [ebp], 0

; 47   : 
; 48   : 		strcpy (tmp, "Command line options:\n\n");

  0006e	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_0BI@HHPEFDNB@Command?5line?5options?3?6?6?$AA@
  00073	89 45 00	 mov	 DWORD PTR [ebp], eax
  00076	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_0BI@HHPEFDNB@Command?5line?5options?3?6?6?$AA@+4
  0007c	89 4d 04	 mov	 DWORD PTR [ebp+4], ecx
  0007f	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR ??_C@_0BI@HHPEFDNB@Command?5line?5options?3?6?6?$AA@+8
  00085	89 55 08	 mov	 DWORD PTR [ebp+8], edx
  00088	a1 0c 00 00 00	 mov	 eax, DWORD PTR ??_C@_0BI@HHPEFDNB@Command?5line?5options?3?6?6?$AA@+12
  0008d	89 45 0c	 mov	 DWORD PTR [ebp+12], eax
  00090	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_0BI@HHPEFDNB@Command?5line?5options?3?6?6?$AA@+16
  00096	89 4d 10	 mov	 DWORD PTR [ebp+16], ecx
  00099	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ??_C@_0BI@HHPEFDNB@Command?5line?5options?3?6?6?$AA@+20

; 49   : 		for (i = 0; i < as->arg_cnt; i ++)

  0009f	33 c0		 xor	 eax, eax
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a4	89 55 14	 mov	 DWORD PTR [ebp+20], edx
  000a7	39 43 04	 cmp	 DWORD PTR [ebx+4], eax
  000aa	89 44 24 10	 mov	 DWORD PTR _i$80126[esp+548], eax
  000ae	7e 74		 jle	 SHORT $LN4@CommandHel
  000b0	89 44 24 0c	 mov	 DWORD PTR tv225[esp+548], eax
  000b4	57		 push	 edi
$LL18@CommandHel:

; 50   : 		{
; 51   : 			if (!as->args[i].Internal)

  000b5	8b 03		 mov	 eax, DWORD PTR [ebx]
  000b7	8b 4c 24 10	 mov	 ecx, DWORD PTR tv225[esp+552]
  000bb	03 c1		 add	 eax, ecx
  000bd	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  000c1	75 4d		 jne	 SHORT $LN5@CommandHel

; 52   : 			{
; 53   : 				snprintf(tmp2, ARRAY_LENGTH(tmp2), "%s\t%s\n", as->args[i].short_name, as->args[i].long_name);

  000c3	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  000c6	52		 push	 edx
  000c7	83 c0 24	 add	 eax, 36			; 00000024H
  000ca	50		 push	 eax
  000cb	68 00 00 00 00	 push	 OFFSET ??_C@_06EEAEEKCL@?$CFs?7?$CFs?6?$AA@
  000d0	8d 44 24 28	 lea	 eax, DWORD PTR _tmp2$80124[esp+564]
  000d4	68 08 02 00 00	 push	 520			; 00000208H
  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 _sprintf_s

; 54   : 				strcat(tmp,tmp2);

  000df	8d 44 24 30	 lea	 eax, DWORD PTR _tmp2$80124[esp+572]
  000e3	83 c4 14	 add	 esp, 20			; 00000014H
  000e6	8b c8		 mov	 ecx, eax
$LL16@CommandHel:
  000e8	8a 10		 mov	 dl, BYTE PTR [eax]
  000ea	40		 inc	 eax
  000eb	84 d2		 test	 dl, dl
  000ed	75 f9		 jne	 SHORT $LL16@CommandHel
  000ef	8b fd		 mov	 edi, ebp
  000f1	2b c1		 sub	 eax, ecx
  000f3	8b f1		 mov	 esi, ecx
  000f5	4f		 dec	 edi
$LL17@CommandHel:
  000f6	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  000f9	47		 inc	 edi
  000fa	84 c9		 test	 cl, cl
  000fc	75 f8		 jne	 SHORT $LL17@CommandHel
  000fe	8b c8		 mov	 ecx, eax
  00100	c1 e9 02	 shr	 ecx, 2
  00103	f3 a5		 rep movsd
  00105	8b c8		 mov	 ecx, eax
  00107	83 e1 03	 and	 ecx, 3
  0010a	f3 a4		 rep movsb
  0010c	8b 74 24 18	 mov	 esi, DWORD PTR _hwndDlg$GSCopy$[esp+552]
$LN5@CommandHel:
  00110	8b 44 24 14	 mov	 eax, DWORD PTR _i$80126[esp+552]
  00114	83 44 24 10 30	 add	 DWORD PTR tv225[esp+552], 48 ; 00000030H
  00119	40		 inc	 eax
  0011a	3b 43 04	 cmp	 eax, DWORD PTR [ebx+4]
  0011d	89 44 24 14	 mov	 DWORD PTR _i$80126[esp+552], eax
  00121	7c 92		 jl	 SHORT $LL18@CommandHel
  00123	5f		 pop	 edi
$LN4@CommandHel:

; 55   : 			}
; 56   : 		}
; 57   : 
; 58   : 		SetWindowTextA(GetDlgItem (hwndDlg, IDC_COMMANDHELP_TEXT), (char*) tmp);

  00124	55		 push	 ebp
  00125	68 bd 13 00 00	 push	 5053			; 000013bdH
  0012a	56		 push	 esi
  0012b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00131	50		 push	 eax
  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8
  00138	5d		 pop	 ebp

; 59   : 		return 1;

  00139	eb 09		 jmp	 SHORT $LN20@CommandHel
$LN1@CommandHel:

; 65   : 	case WM_CLOSE:
; 66   : 		EndDialog (hwndDlg, 0);

  0013b	6a 00		 push	 0
$LN19@CommandHel:
  0013d	56		 push	 esi
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndDialog@8
$LN20@CommandHel:

; 67   : 		return 1;

  00144	b8 01 00 00 00	 mov	 eax, 1
$LN12@CommandHel:

; 71   : }

  00149	8b 8c 24 1c 02
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+544]
  00150	5e		 pop	 esi
  00151	5b		 pop	 ebx
  00152	33 cc		 xor	 ecx, esp
  00154	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00159	81 c4 18 02 00
	00		 add	 esp, 536		; 00000218H
  0015f	c2 10 00	 ret	 16			; 00000010H
_CommandHelpDlgProc@16 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@IMAOAGMP@OUTOFMEMORY?$AA@		; `string'
PUBLIC	_Win32CommandLine
EXTRN	_AbortProcessSilent:PROC
EXTRN	__imp__WideCharToMultiByte@32:PROC
EXTRN	_AbortProcess:PROC
EXTRN	_malloc:PROC
EXTRN	__imp__LocalFree@4:PROC
EXTRN	_handleWin32Error:PROC
EXTRN	__imp__CommandLineToArgvW@8:PROC
EXTRN	__imp__GetCommandLineW@0:PROC
;	COMDAT ??_C@_0M@IMAOAGMP@OUTOFMEMORY?$AA@
CONST	SEGMENT
??_C@_0M@IMAOAGMP@OUTOFMEMORY?$AA@ DB 'OUTOFMEMORY', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Win32CommandLine
_TEXT	SEGMENT
_argumentCount$ = -16					; size = 4
_i$ = -12						; size = 4
tv233 = -8						; size = 4
_arguments$ = -4					; size = 4
_lpszCommandLine$ = 8					; size = 4
_lpszArgs$ = 12						; size = 4
_Win32CommandLine PROC					; COMDAT

; 74   : {

  00000	83 ec 10	 sub	 esp, 16			; 00000010H
  00003	56		 push	 esi

; 75   : 	int argumentCount;
; 76   : 	int i;
; 77   : 
; 78   : 	LPWSTR *arguments = CommandLineToArgvW (GetCommandLineW(), &argumentCount);

  00004	8d 44 24 04	 lea	 eax, DWORD PTR _argumentCount$[esp+20]
  00008	50		 push	 eax
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCommandLineW@0
  0000f	50		 push	 eax
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CommandLineToArgvW@8
  00016	8b f0		 mov	 esi, eax
  00018	89 74 24 10	 mov	 DWORD PTR _arguments$[esp+20], esi

; 79   : 	if (!arguments)

  0001c	85 f6		 test	 esi, esi
  0001e	75 10		 jne	 SHORT $LN10@Win32Comma

; 80   : 	{
; 81   : 		handleWin32Error (NULL);

  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 _handleWin32Error
  00026	83 c4 04	 add	 esp, 4

; 82   : 		return 0;

  00029	33 c0		 xor	 eax, eax
  0002b	5e		 pop	 esi

; 121  : }

  0002c	83 c4 10	 add	 esp, 16			; 00000010H
  0002f	c3		 ret	 0
$LN10@Win32Comma:

; 83   : 	}
; 84   : 
; 85   : 	--argumentCount;

  00030	8b 44 24 04	 mov	 eax, DWORD PTR _argumentCount$[esp+20]
  00034	48		 dec	 eax

; 86   : 	if (argumentCount < 1)

  00035	83 f8 01	 cmp	 eax, 1
  00038	89 44 24 04	 mov	 DWORD PTR _argumentCount$[esp+20], eax
  0003c	7d 0e		 jge	 SHORT $LN9@Win32Comma

; 87   : 	{
; 88   : 		LocalFree (arguments);

  0003e	56		 push	 esi
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalFree@4

; 89   : 		return 0;

  00045	33 c0		 xor	 eax, eax
  00047	5e		 pop	 esi

; 121  : }

  00048	83 c4 10	 add	 esp, 16			; 00000010H
  0004b	c3		 ret	 0
$LN9@Win32Comma:

; 90   : 	}
; 91   : 
; 92   : 	*lpszArgs = malloc (sizeof (char *) * argumentCount);

  0004c	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 _malloc
  00059	8b 54 24 20	 mov	 edx, DWORD PTR _lpszArgs$[esp+20]
  0005d	83 c4 04	 add	 esp, 4
  00060	89 02		 mov	 DWORD PTR [edx], eax

; 93   : 	if (!*lpszArgs)

  00062	85 c0		 test	 eax, eax
  00064	75 0d		 jne	 SHORT $LN8@Win32Comma

; 94   : 		AbortProcess ("OUTOFMEMORY");

  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0M@IMAOAGMP@OUTOFMEMORY?$AA@
  0006b	e8 00 00 00 00	 call	 _AbortProcess
  00070	83 c4 04	 add	 esp, 4
$LN8@Win32Comma:

; 95   : 
; 96   : 	for (i = 0; i < argumentCount; ++i)

  00073	83 7c 24 04 00	 cmp	 DWORD PTR _argumentCount$[esp+20], 0
  00078	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR _i$[esp+20], 0
  00080	0f 8e a6 00 00
	00		 jle	 $LN5@Win32Comma
  00086	53		 push	 ebx
  00087	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0008c	55		 push	 ebp
  0008d	2b c6		 sub	 eax, esi
  0008f	57		 push	 edi
  00090	8d 5e 04	 lea	 ebx, DWORD PTR [esi+4]
  00093	89 44 24 18	 mov	 DWORD PTR tv233[esp+32], eax
$LL16@Win32Comma:

; 97   : 	{
; 98   : 		size_t argLen = wcslen (arguments[i + 1]);

  00097	8b 03		 mov	 eax, DWORD PTR [ebx]
  00099	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
  0009c	8d 64 24 00	 npad	 4
$LL15@Win32Comma:
  000a0	66 8b 08	 mov	 cx, WORD PTR [eax]
  000a3	83 c0 02	 add	 eax, 2
  000a6	66 85 c9	 test	 cx, cx
  000a9	75 f5		 jne	 SHORT $LL15@Win32Comma
  000ab	2b c2		 sub	 eax, edx
  000ad	d1 f8		 sar	 eax, 1
  000af	8b e8		 mov	 ebp, eax

; 99   : 
; 100  : 		char *arg = malloc (argLen + 1);

  000b1	8d 7d 01	 lea	 edi, DWORD PTR [ebp+1]
  000b4	57		 push	 edi
  000b5	e8 00 00 00 00	 call	 _malloc
  000ba	8b f0		 mov	 esi, eax
  000bc	83 c4 04	 add	 esp, 4

; 101  : 		if (!arg)

  000bf	85 f6		 test	 esi, esi
  000c1	75 0d		 jne	 SHORT $LN4@Win32Comma

; 102  : 			AbortProcess ("OUTOFMEMORY");

  000c3	68 00 00 00 00	 push	 OFFSET ??_C@_0M@IMAOAGMP@OUTOFMEMORY?$AA@
  000c8	e8 00 00 00 00	 call	 _AbortProcess
  000cd	83 c4 04	 add	 esp, 4
$LN4@Win32Comma:

; 103  : 
; 104  : 		if (argLen > 0)

  000d0	85 ed		 test	 ebp, ebp
  000d2	76 29		 jbe	 SHORT $LN3@Win32Comma

; 105  : 		{
; 106  : 			int len = WideCharToMultiByte (CP_ACP, 0, arguments[i + 1], -1, arg, argLen + 1, NULL, NULL);

  000d4	8b 03		 mov	 eax, DWORD PTR [ebx]
  000d6	6a 00		 push	 0
  000d8	6a 00		 push	 0
  000da	57		 push	 edi
  000db	56		 push	 esi
  000dc	6a ff		 push	 -1
  000de	50		 push	 eax
  000df	6a 00		 push	 0
  000e1	6a 00		 push	 0
  000e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 107  : 			if (len == 0)

  000e9	85 c0		 test	 eax, eax
  000eb	75 13		 jne	 SHORT $LN1@Win32Comma

; 108  : 			{
; 109  : 				handleWin32Error (NULL);

  000ed	50		 push	 eax
  000ee	e8 00 00 00 00	 call	 _handleWin32Error
  000f3	83 c4 04	 add	 esp, 4

; 110  : 				AbortProcessSilent();

  000f6	e8 00 00 00 00	 call	 _AbortProcessSilent

; 111  : 			}
; 112  : 		}
; 113  : 		else

  000fb	eb 03		 jmp	 SHORT $LN1@Win32Comma
$LN3@Win32Comma:

; 114  : 			arg[0] = 0;

  000fd	c6 06 00	 mov	 BYTE PTR [esi], 0
$LN1@Win32Comma:

; 115  : 
; 116  : 		(*lpszArgs)[i] = arg;

  00100	8b 4c 24 18	 mov	 ecx, DWORD PTR tv233[esp+32]
  00104	8b 54 24 28	 mov	 edx, DWORD PTR _lpszArgs$[esp+28]
  00108	8b 02		 mov	 eax, DWORD PTR [edx]
  0010a	03 cb		 add	 ecx, ebx
  0010c	89 34 01	 mov	 DWORD PTR [ecx+eax], esi
  0010f	8b 44 24 14	 mov	 eax, DWORD PTR _i$[esp+32]
  00113	40		 inc	 eax
  00114	83 c3 04	 add	 ebx, 4
  00117	3b 44 24 10	 cmp	 eax, DWORD PTR _argumentCount$[esp+32]
  0011b	89 44 24 14	 mov	 DWORD PTR _i$[esp+32], eax
  0011f	0f 8c 72 ff ff
	ff		 jl	 $LL16@Win32Comma
  00125	8b 74 24 1c	 mov	 esi, DWORD PTR _arguments$[esp+32]
  00129	5f		 pop	 edi
  0012a	5d		 pop	 ebp
  0012b	5b		 pop	 ebx
$LN5@Win32Comma:

; 117  : 	}
; 118  : 
; 119  : 	LocalFree (arguments);

  0012c	56		 push	 esi
  0012d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalFree@4

; 120  : 	return argumentCount;

  00133	8b 44 24 04	 mov	 eax, DWORD PTR _argumentCount$[esp+20]
  00137	5e		 pop	 esi

; 121  : }

  00138	83 c4 10	 add	 esp, 16			; 00000010H
  0013b	c3		 ret	 0
_Win32CommandLine ENDP
_TEXT	ENDS
PUBLIC	_GetArgSepPosOffset
; Function compile flags: /Ogtpy
;	COMDAT _GetArgSepPosOffset
_TEXT	SEGMENT
_lpszArgument$ = 8					; size = 4
_GetArgSepPosOffset PROC				; COMDAT

; 125  : 	if (lpszArgument[0] == '/')

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _lpszArgument$[esp-4]
  00004	33 c0		 xor	 eax, eax
  00006	80 39 2f	 cmp	 BYTE PTR [ecx], 47	; 0000002fH
  00009	0f 94 c0	 sete	 al

; 126  : 		return 1;
; 127  : 
; 128  : 	return 0;
; 129  : }

  0000c	c3		 ret	 0
_GetArgSepPosOffset ENDP
_TEXT	ENDS
PUBLIC	_lpszArgument$GSCopy$
PUBLIC	_nArgPos$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_GetArgumentID
EXTRN	_tolower:PROC
; Function compile flags: /Ogtpy
;	COMDAT _GetArgumentID
_TEXT	SEGMENT
tv827 = -556						; size = 4
tv737 = -556						; size = 4
_i$ = -552						; size = 4
tv870 = -548						; size = 4
tv778 = -548						; size = 4
tv880 = -544						; size = 4
tv772 = -544						; size = 4
tv428 = -540						; size = 4
_nArgPos$GSCopy$ = -536					; size = 4
_lpszArgument$GSCopy$ = -532				; size = 4
_k$80201 = -528						; size = 4
_szTmp$ = -524						; size = 520
__$ArrayPad$ = -4					; size = 4
_as$ = 8						; size = 4
_lpszArgument$ = 12					; size = 4
_nArgPos$ = 16						; size = 4
_GetArgumentID PROC					; COMDAT

; 132  : {

  00000	81 ec 2c 02 00
	00		 sub	 esp, 556		; 0000022cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 28 02
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+556], eax
  00014	8b 84 24 38 02
	00 00		 mov	 eax, DWORD PTR _nArgPos$[esp+552]
  0001b	53		 push	 ebx
  0001c	55		 push	 ebp
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	8b bc 24 44 02
	00 00		 mov	 edi, DWORD PTR _lpszArgument$[esp+568]

; 163  : 			{
; 164  : 				if (strlen (lpszArgument) != k)

  00026	89 44 24 24	 mov	 DWORD PTR _nArgPos$GSCopy$[esp+572], eax
  0002a	8b c7		 mov	 eax, edi
  0002c	89 7c 24 28	 mov	 DWORD PTR _lpszArgument$GSCopy$[esp+572], edi
  00030	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL75@GetArgumen:
  00033	8a 08		 mov	 cl, BYTE PTR [eax]
  00035	40		 inc	 eax
  00036	84 c9		 test	 cl, cl
  00038	75 f9		 jne	 SHORT $LL75@GetArgumen
  0003a	2b c2		 sub	 eax, edx
  0003c	8b f0		 mov	 esi, eax
  0003e	83 ee 01	 sub	 esi, 1
  00041	88 4c 34 31	 mov	 BYTE PTR _szTmp$[esp+esi+573], cl
  00045	78 23		 js	 SHORT $LN25@GetArgumen
  00047	8d 4c 24 30	 lea	 ecx, DWORD PTR _szTmp$[esp+572]
  0004b	2b f9		 sub	 edi, ecx
  0004d	8d 49 00	 npad	 3
$LL26@GetArgumen:
  00050	8d 14 37	 lea	 edx, DWORD PTR [edi+esi]
  00053	0f be 44 14 30	 movsx	 eax, BYTE PTR _szTmp$[esp+edx+572]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 _tolower
  0005e	83 c4 04	 add	 esp, 4
  00061	83 ee 01	 sub	 esi, 1
  00064	88 44 34 31	 mov	 BYTE PTR _szTmp$[esp+esi+573], al
  00068	79 e6		 jns	 SHORT $LL26@GetArgumen
$LN25@GetArgumen:

; 133  : 	char szTmp[MAX_PATH * 2];
; 134  : 	int i;
; 135  : 
; 136  : 	i = strlen (lpszArgument);
; 137  : 	szTmp[i] = 0;
; 138  : 	while (--i >= 0)
; 139  : 	{
; 140  : 		szTmp[i] = (char) tolower (lpszArgument[i]);
; 141  : 	}
; 142  : 
; 143  : 	for (i = 0; i < as->arg_cnt; i++)

  0006a	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR _as$[esp+568]
  00071	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00074	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _i$[esp+572], 0
  0007c	89 4c 24 20	 mov	 DWORD PTR tv428[esp+572], ecx
  00080	85 c9		 test	 ecx, ecx
  00082	0f 8e 24 01 00
	00		 jle	 $LN22@GetArgumen
  00088	8b 00		 mov	 eax, DWORD PTR [eax]
  0008a	8d 70 04	 lea	 esi, DWORD PTR [eax+4]
  0008d	83 c0 34	 add	 eax, 52			; 00000034H
  00090	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR tv737[esp+572], 1
  00098	89 74 24 1c	 mov	 DWORD PTR tv772[esp+572], esi
  0009c	89 44 24 18	 mov	 DWORD PTR tv778[esp+572], eax
$LL24@GetArgumen:

; 144  : 	{
; 145  : 		size_t k;
; 146  : 
; 147  : 		k = strlen (as->args[i].long_name);

  000a0	8b c6		 mov	 eax, esi
  000a2	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL76@GetArgumen:
  000a5	8a 08		 mov	 cl, BYTE PTR [eax]
  000a7	40		 inc	 eax
  000a8	84 c9		 test	 cl, cl
  000aa	75 f9		 jne	 SHORT $LL76@GetArgumen
  000ac	2b c2		 sub	 eax, edx
  000ae	8b d8		 mov	 ebx, eax

; 148  : 		if (memcmp (as->args[i].long_name, szTmp, k * sizeof (char)) == 0)

  000b0	8d 4c 24 30	 lea	 ecx, DWORD PTR _szTmp$[esp+572]
  000b4	83 fb 04	 cmp	 ebx, 4
  000b7	72 1f		 jb	 SHORT $LN58@GetArgumen
  000b9	8d a4 24 00 00
	00 00		 npad	 7
$LL30@GetArgumen:
  000c0	8b 16		 mov	 edx, DWORD PTR [esi]
  000c2	3b 11		 cmp	 edx, DWORD PTR [ecx]
  000c4	0f 85 b2 00 00
	00		 jne	 $LN23@GetArgumen
  000ca	83 e8 04	 sub	 eax, 4
  000cd	83 c1 04	 add	 ecx, 4
  000d0	83 c6 04	 add	 esi, 4
  000d3	83 f8 04	 cmp	 eax, 4
  000d6	73 e8		 jae	 SHORT $LL30@GetArgumen
$LN58@GetArgumen:
  000d8	85 c0		 test	 eax, eax
  000da	74 28		 je	 SHORT $LN32@GetArgumen
  000dc	8a 11		 mov	 dl, BYTE PTR [ecx]
  000de	3a 16		 cmp	 dl, BYTE PTR [esi]
  000e0	0f 85 96 00 00
	00		 jne	 $LN23@GetArgumen
  000e6	83 f8 01	 cmp	 eax, 1
  000e9	76 19		 jbe	 SHORT $LN32@GetArgumen
  000eb	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  000ee	3a 56 01	 cmp	 dl, BYTE PTR [esi+1]
  000f1	0f 85 85 00 00
	00		 jne	 $LN23@GetArgumen
  000f7	83 f8 02	 cmp	 eax, 2
  000fa	76 08		 jbe	 SHORT $LN32@GetArgumen
  000fc	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  000ff	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  00102	75 78		 jne	 SHORT $LN23@GetArgumen
$LN32@GetArgumen:

; 149  : 		{
; 150  : 			int x;
; 151  : 			for (x = i + 1; x < as->arg_cnt; x++)

  00104	8b 6c 24 10	 mov	 ebp, DWORD PTR tv737[esp+572]
  00108	3b 6c 24 20	 cmp	 ebp, DWORD PTR tv428[esp+572]
  0010c	7d 68		 jge	 SHORT $LN86@GetArgumen
  0010e	8b 7c 24 18	 mov	 edi, DWORD PTR tv778[esp+572]
$LL20@GetArgumen:

; 152  : 			{
; 153  : 				size_t m;
; 154  : 
; 155  : 				m = strlen (as->args[x].long_name);

  00112	8b c7		 mov	 eax, edi
  00114	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL77@GetArgumen:
  00117	8a 08		 mov	 cl, BYTE PTR [eax]
  00119	40		 inc	 eax
  0011a	84 c9		 test	 cl, cl
  0011c	75 f9		 jne	 SHORT $LL77@GetArgumen
  0011e	2b c2		 sub	 eax, edx

; 156  : 				if (memcmp (as->args[x].long_name, szTmp, m * sizeof (char)) == 0)

  00120	8d 4c 24 30	 lea	 ecx, DWORD PTR _szTmp$[esp+572]
  00124	8b f7		 mov	 esi, edi
  00126	83 f8 04	 cmp	 eax, 4
  00129	72 19		 jb	 SHORT $LN59@GetArgumen
  0012b	eb 03 8d 49 00	 npad	 5
$LL34@GetArgumen:
  00130	8b 16		 mov	 edx, DWORD PTR [esi]
  00132	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00134	75 32		 jne	 SHORT $LN19@GetArgumen
  00136	83 e8 04	 sub	 eax, 4
  00139	83 c1 04	 add	 ecx, 4
  0013c	83 c6 04	 add	 esi, 4
  0013f	83 f8 04	 cmp	 eax, 4
  00142	73 ec		 jae	 SHORT $LL34@GetArgumen
$LN59@GetArgumen:
  00144	85 c0		 test	 eax, eax
  00146	74 2a		 je	 SHORT $LN60@GetArgumen
  00148	8a 11		 mov	 dl, BYTE PTR [ecx]
  0014a	3a 16		 cmp	 dl, BYTE PTR [esi]
  0014c	75 1a		 jne	 SHORT $LN19@GetArgumen
  0014e	83 f8 01	 cmp	 eax, 1
  00151	76 1f		 jbe	 SHORT $LN60@GetArgumen
  00153	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  00156	3a 56 01	 cmp	 dl, BYTE PTR [esi+1]
  00159	75 0d		 jne	 SHORT $LN19@GetArgumen
  0015b	83 f8 02	 cmp	 eax, 2
  0015e	76 12		 jbe	 SHORT $LN60@GetArgumen
  00160	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  00163	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  00166	74 0a		 je	 SHORT $LN60@GetArgumen
$LN19@GetArgumen:

; 149  : 		{
; 150  : 			int x;
; 151  : 			for (x = i + 1; x < as->arg_cnt; x++)

  00168	45		 inc	 ebp
  00169	83 c7 30	 add	 edi, 48			; 00000030H
  0016c	3b 6c 24 20	 cmp	 ebp, DWORD PTR tv428[esp+572]
  00170	7c a0		 jl	 SHORT $LL20@GetArgumen
$LN60@GetArgumen:

; 157  : 				{
; 158  : 					break;
; 159  : 				}
; 160  : 			}
; 161  : 
; 162  : 			if (x == as->arg_cnt)

  00172	3b 6c 24 20	 cmp	 ebp, DWORD PTR tv428[esp+572]
$LN86@GetArgumen:
  00176	0f 84 94 01 00
	00		 je	 $LN61@GetArgumen
$LN23@GetArgumen:

; 133  : 	char szTmp[MAX_PATH * 2];
; 134  : 	int i;
; 135  : 
; 136  : 	i = strlen (lpszArgument);
; 137  : 	szTmp[i] = 0;
; 138  : 	while (--i >= 0)
; 139  : 	{
; 140  : 		szTmp[i] = (char) tolower (lpszArgument[i]);
; 141  : 	}
; 142  : 
; 143  : 	for (i = 0; i < as->arg_cnt; i++)

  0017c	8b 44 24 14	 mov	 eax, DWORD PTR _i$[esp+572]
  00180	8b 74 24 1c	 mov	 esi, DWORD PTR tv772[esp+572]
  00184	8b 4c 24 20	 mov	 ecx, DWORD PTR tv428[esp+572]
  00188	ff 44 24 10	 inc	 DWORD PTR tv737[esp+572]
  0018c	83 44 24 18 30	 add	 DWORD PTR tv778[esp+572], 48 ; 00000030H
  00191	40		 inc	 eax
  00192	83 c6 30	 add	 esi, 48			; 00000030H
  00195	3b c1		 cmp	 eax, ecx
  00197	89 44 24 14	 mov	 DWORD PTR _i$[esp+572], eax
  0019b	89 74 24 1c	 mov	 DWORD PTR tv772[esp+572], esi
  0019f	0f 8c fb fe ff
	ff		 jl	 $LL24@GetArgumen

; 193  : 				{
; 194  : 					break;
; 195  : 				}
; 196  : 			}
; 197  : 
; 198  : 			if (x == as->arg_cnt)

  001a5	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR _as$[esp+568]
$LN22@GetArgumen:

; 169  : 			}
; 170  : 		}
; 171  : 	}
; 172  : 
; 173  : 	for (i = 0; i < as->arg_cnt; i++)

  001ac	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _i$[esp+572], 0
  001b4	85 c9		 test	 ecx, ecx
  001b6	0f 8e 38 01 00
	00		 jle	 $LN11@GetArgumen
  001bc	8b 00		 mov	 eax, DWORD PTR [eax]
  001be	8d 50 24	 lea	 edx, DWORD PTR [eax+36]
  001c1	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR tv827[esp+572], 1
  001c9	8b 6c 24 10	 mov	 ebp, DWORD PTR tv827[esp+572]
  001cd	83 c0 54	 add	 eax, 84			; 00000054H
  001d0	89 54 24 18	 mov	 DWORD PTR tv870[esp+572], edx
  001d4	89 44 24 1c	 mov	 DWORD PTR tv880[esp+572], eax
  001d8	8b fa		 mov	 edi, edx
  001da	8d 9b 00 00 00
	00		 npad	 6
$LL85@GetArgumen:

; 174  : 	{
; 175  : 		size_t k;
; 176  : 
; 177  : 		if (as->args[i].short_name[0] == 0)

  001e0	80 3f 00	 cmp	 BYTE PTR [edi], 0
  001e3	0f 84 e7 00 00
	00		 je	 $LN12@GetArgumen

; 178  : 			continue;
; 179  : 
; 180  : 		k = strlen (as->args[i].short_name);

  001e9	8b c7		 mov	 eax, edi
  001eb	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  001ee	8b ff		 npad	 2
$LL79@GetArgumen:
  001f0	8a 08		 mov	 cl, BYTE PTR [eax]
  001f2	40		 inc	 eax
  001f3	84 c9		 test	 cl, cl
  001f5	75 f9		 jne	 SHORT $LL79@GetArgumen
  001f7	2b c2		 sub	 eax, edx
  001f9	89 44 24 2c	 mov	 DWORD PTR _k$80201[esp+572], eax

; 181  : 		if (memcmp (as->args[i].short_name, szTmp, k * sizeof (char)) == 0)

  001fd	8d 4c 24 30	 lea	 ecx, DWORD PTR _szTmp$[esp+572]
  00201	8b f7		 mov	 esi, edi
  00203	83 f8 04	 cmp	 eax, 4
  00206	72 20		 jb	 SHORT $LN62@GetArgumen
  00208	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL38@GetArgumen:
  00210	8b 16		 mov	 edx, DWORD PTR [esi]
  00212	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00214	0f 85 b6 00 00
	00		 jne	 $LN12@GetArgumen
  0021a	83 e8 04	 sub	 eax, 4
  0021d	83 c1 04	 add	 ecx, 4
  00220	83 c6 04	 add	 esi, 4
  00223	83 f8 04	 cmp	 eax, 4
  00226	73 e8		 jae	 SHORT $LL38@GetArgumen
$LN62@GetArgumen:
  00228	85 c0		 test	 eax, eax
  0022a	74 2c		 je	 SHORT $LN40@GetArgumen
  0022c	8a 11		 mov	 dl, BYTE PTR [ecx]
  0022e	3a 16		 cmp	 dl, BYTE PTR [esi]
  00230	0f 85 9a 00 00
	00		 jne	 $LN12@GetArgumen
  00236	83 f8 01	 cmp	 eax, 1
  00239	76 1d		 jbe	 SHORT $LN40@GetArgumen
  0023b	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  0023e	3a 56 01	 cmp	 dl, BYTE PTR [esi+1]
  00241	0f 85 89 00 00
	00		 jne	 $LN12@GetArgumen
  00247	83 f8 02	 cmp	 eax, 2
  0024a	76 0c		 jbe	 SHORT $LN40@GetArgumen
  0024c	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  0024f	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  00252	0f 85 78 00 00
	00		 jne	 $LN12@GetArgumen
$LN40@GetArgumen:

; 182  : 		{
; 183  : 			int x;
; 184  : 			for (x = i + 1; x < as->arg_cnt; x++)

  00258	8b 5c 24 20	 mov	 ebx, DWORD PTR tv428[esp+572]
  0025c	3b eb		 cmp	 ebp, ebx
  0025e	7d 66		 jge	 SHORT $LN87@GetArgumen
  00260	8b 7c 24 1c	 mov	 edi, DWORD PTR tv880[esp+572]
$LL8@GetArgumen:

; 185  : 			{
; 186  : 				size_t m;
; 187  : 
; 188  : 				if (as->args[x].short_name[0] == 0)

  00264	80 3f 00	 cmp	 BYTE PTR [edi], 0
  00267	74 53		 je	 SHORT $LN7@GetArgumen

; 189  : 					continue;
; 190  : 
; 191  : 				m = strlen (as->args[x].short_name);

  00269	8b c7		 mov	 eax, edi
  0026b	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0026e	8b ff		 npad	 2
$LL80@GetArgumen:
  00270	8a 08		 mov	 cl, BYTE PTR [eax]
  00272	40		 inc	 eax
  00273	84 c9		 test	 cl, cl
  00275	75 f9		 jne	 SHORT $LL80@GetArgumen
  00277	2b c2		 sub	 eax, edx

; 192  : 				if (memcmp (as->args[x].short_name, szTmp, m * sizeof (char)) == 0)

  00279	8d 4c 24 30	 lea	 ecx, DWORD PTR _szTmp$[esp+572]
  0027d	8b f7		 mov	 esi, edi
  0027f	83 f8 04	 cmp	 eax, 4
  00282	72 14		 jb	 SHORT $LN63@GetArgumen
$LL42@GetArgumen:
  00284	8b 16		 mov	 edx, DWORD PTR [esi]
  00286	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00288	75 32		 jne	 SHORT $LN7@GetArgumen
  0028a	83 e8 04	 sub	 eax, 4
  0028d	83 c1 04	 add	 ecx, 4
  00290	83 c6 04	 add	 esi, 4
  00293	83 f8 04	 cmp	 eax, 4
  00296	73 ec		 jae	 SHORT $LL42@GetArgumen
$LN63@GetArgumen:
  00298	85 c0		 test	 eax, eax
  0029a	74 28		 je	 SHORT $LN64@GetArgumen
  0029c	8a 11		 mov	 dl, BYTE PTR [ecx]
  0029e	3a 16		 cmp	 dl, BYTE PTR [esi]
  002a0	75 1a		 jne	 SHORT $LN7@GetArgumen
  002a2	83 f8 01	 cmp	 eax, 1
  002a5	76 1d		 jbe	 SHORT $LN64@GetArgumen
  002a7	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  002aa	3a 56 01	 cmp	 dl, BYTE PTR [esi+1]
  002ad	75 0d		 jne	 SHORT $LN7@GetArgumen
  002af	83 f8 02	 cmp	 eax, 2
  002b2	76 10		 jbe	 SHORT $LN64@GetArgumen
  002b4	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  002b7	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  002ba	74 08		 je	 SHORT $LN64@GetArgumen
$LN7@GetArgumen:

; 182  : 		{
; 183  : 			int x;
; 184  : 			for (x = i + 1; x < as->arg_cnt; x++)

  002bc	45		 inc	 ebp
  002bd	83 c7 30	 add	 edi, 48			; 00000030H
  002c0	3b eb		 cmp	 ebp, ebx
  002c2	7c a0		 jl	 SHORT $LL8@GetArgumen
$LN64@GetArgumen:

; 193  : 				{
; 194  : 					break;
; 195  : 				}
; 196  : 			}
; 197  : 
; 198  : 			if (x == as->arg_cnt)

  002c4	3b eb		 cmp	 ebp, ebx
$LN87@GetArgumen:
  002c6	74 7e		 je	 SHORT $LN65@GetArgumen
  002c8	8b 7c 24 18	 mov	 edi, DWORD PTR tv870[esp+572]
  002cc	8b 6c 24 10	 mov	 ebp, DWORD PTR tv827[esp+572]
$LN12@GetArgumen:
  002d0	8b 44 24 14	 mov	 eax, DWORD PTR _i$[esp+572]
  002d4	83 44 24 1c 30	 add	 DWORD PTR tv880[esp+572], 48 ; 00000030H
  002d9	40		 inc	 eax
  002da	83 c7 30	 add	 edi, 48			; 00000030H
  002dd	45		 inc	 ebp
  002de	3b 44 24 20	 cmp	 eax, DWORD PTR tv428[esp+572]
  002e2	89 44 24 14	 mov	 DWORD PTR _i$[esp+572], eax
  002e6	89 7c 24 18	 mov	 DWORD PTR tv870[esp+572], edi
  002ea	89 6c 24 10	 mov	 DWORD PTR tv827[esp+572], ebp
  002ee	0f 8c ec fe ff
	ff		 jl	 $LL85@GetArgumen
$LN11@GetArgumen:

; 205  : 			}
; 206  : 		}
; 207  : 	}
; 208  : 
; 209  : 
; 210  : 	return -1;

  002f4	83 c8 ff	 or	 eax, -1
$LN27@GetArgumen:

; 211  : }

  002f7	8b 8c 24 38 02
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+572]
  002fe	5f		 pop	 edi
  002ff	5e		 pop	 esi
  00300	5d		 pop	 ebp
  00301	5b		 pop	 ebx
  00302	33 cc		 xor	 ecx, esp
  00304	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00309	81 c4 2c 02 00
	00		 add	 esp, 556		; 0000022cH
  0030f	c3		 ret	 0
$LN61@GetArgumen:

; 163  : 			{
; 164  : 				if (strlen (lpszArgument) != k)

  00310	8b 44 24 28	 mov	 eax, DWORD PTR _lpszArgument$GSCopy$[esp+572]
  00314	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL78@GetArgumen:
  00317	8a 08		 mov	 cl, BYTE PTR [eax]
  00319	40		 inc	 eax
  0031a	84 c9		 test	 cl, cl
  0031c	75 f9		 jne	 SHORT $LL78@GetArgumen
  0031e	2b c2		 sub	 eax, edx
  00320	2b c3		 sub	 eax, ebx
  00322	f7 d8		 neg	 eax
  00324	1b c0		 sbb	 eax, eax
  00326	23 c3		 and	 eax, ebx
$LN88@GetArgumen:
  00328	8b 4c 24 24	 mov	 ecx, DWORD PTR _nArgPos$GSCopy$[esp+572]
  0032c	89 01		 mov	 DWORD PTR [ecx], eax

; 165  : 					*nArgPos = k;
; 166  : 				else
; 167  : 					*nArgPos = 0;
; 168  : 				return as->args[i].Id;

  0032e	8b 44 24 14	 mov	 eax, DWORD PTR _i$[esp+572]
  00332	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00335	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR _as$[esp+568]
  0033c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0033e	c1 e2 04	 shl	 edx, 4
  00341	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00344	eb b1		 jmp	 SHORT $LN27@GetArgumen
$LN65@GetArgumen:

; 199  : 			{
; 200  : 				if (strlen (lpszArgument) != k)

  00346	8b 44 24 28	 mov	 eax, DWORD PTR _lpszArgument$GSCopy$[esp+572]
  0034a	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0034d	8d 49 00	 npad	 3
$LL81@GetArgumen:
  00350	8a 08		 mov	 cl, BYTE PTR [eax]
  00352	40		 inc	 eax
  00353	84 c9		 test	 cl, cl
  00355	75 f9		 jne	 SHORT $LL81@GetArgumen
  00357	8b 4c 24 2c	 mov	 ecx, DWORD PTR _k$80201[esp+572]
  0035b	2b c2		 sub	 eax, edx
  0035d	2b c1		 sub	 eax, ecx
  0035f	f7 d8		 neg	 eax
  00361	1b c0		 sbb	 eax, eax
  00363	23 c1		 and	 eax, ecx

; 201  : 					*nArgPos = k;
; 202  : 				else
; 203  : 					*nArgPos = 0;
; 204  : 				return as->args[i].Id;

  00365	eb c1		 jmp	 SHORT $LN88@GetArgumen
_GetArgumentID ENDP
_TEXT	ENDS
PUBLIC	_GetArgumentValue
EXTRN	_strncpy:PROC
; Function compile flags: /Ogtpy
;	COMDAT _GetArgumentValue
_TEXT	SEGMENT
_lpszCommandLineArgs$ = 8				; size = 4
_nArgPos$ = 12						; size = 4
_nArgIdx$ = 16						; size = 4
_nNoCommandLineArgs$ = 20				; size = 4
_lpszValue$ = 24					; size = 4
_nValueSize$ = 28					; size = 4
_GetArgumentValue PROC					; COMDAT

; 216  : 	*lpszValue = 0;
; 217  : 
; 218  : 	if (nArgPos)

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _nArgPos$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 18	 mov	 esi, DWORD PTR _lpszValue$[esp]
  00009	57		 push	 edi
  0000a	c6 06 00	 mov	 BYTE PTR [esi], 0
  0000d	85 c0		 test	 eax, eax
  0000f	74 2b		 je	 SHORT $LN4@GetArgumen@2

; 219  : 	{
; 220  : 		/* Handles the case of no space between parameter code and
; 221  : 		   value */
; 222  : 		strncpy (lpszValue, &lpszCommandLineArgs[*nArgIdx][nArgPos], nValueSize);

  00011	8b 4c 24 14	 mov	 ecx, DWORD PTR _nArgIdx$[esp+4]
  00015	8b 11		 mov	 edx, DWORD PTR [ecx]
  00017	8b 4c 24 0c	 mov	 ecx, DWORD PTR _lpszCommandLineArgs$[esp+4]
  0001b	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  0001e	8b 7c 24 20	 mov	 edi, DWORD PTR _nValueSize$[esp+4]
  00022	57		 push	 edi
  00023	03 d0		 add	 edx, eax
  00025	52		 push	 edx
  00026	56		 push	 esi
  00027	e8 00 00 00 00	 call	 _strncpy
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 223  : 		lpszValue[nValueSize - 1] = 0;

  0002f	c6 44 3e ff 00	 mov	 BYTE PTR [esi+edi-1], 0
  00034	5f		 pop	 edi

; 224  : 		return HAS_ARGUMENT;

  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	5e		 pop	 esi

; 241  : }

  0003b	c3		 ret	 0
$LN4@GetArgumen@2:

; 225  : 	}
; 226  : 	else if (*nArgIdx + 1 < nNoCommandLineArgs)

  0003c	8b 7c 24 14	 mov	 edi, DWORD PTR _nArgIdx$[esp+4]
  00040	8b 07		 mov	 eax, DWORD PTR [edi]
  00042	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  00045	3b 4c 24 18	 cmp	 ecx, DWORD PTR _nNoCommandLineArgs$[esp+4]
  00049	7d 2d		 jge	 SHORT $LN1@GetArgumen@2

; 227  : 	{
; 228  : 		int x = GetArgSepPosOffset (lpszCommandLineArgs[*nArgIdx + 1]);

  0004b	8b 54 24 0c	 mov	 edx, DWORD PTR _lpszCommandLineArgs$[esp+4]
  0004f	8b 44 82 04	 mov	 eax, DWORD PTR [edx+eax*4+4]
  00053	80 38 2f	 cmp	 BYTE PTR [eax], 47	; 0000002fH
  00056	74 20		 je	 SHORT $LN1@GetArgumen@2
  00058	55		 push	 ebp

; 229  : 		if (x == 0)
; 230  : 		{
; 231  : 			/* Handles the case of space between parameter code
; 232  : 			   and value */
; 233  : 			strncpy (lpszValue, &lpszCommandLineArgs[*nArgIdx + 1][x], nValueSize);

  00059	8b 6c 24 24	 mov	 ebp, DWORD PTR _nValueSize$[esp+8]
  0005d	55		 push	 ebp
  0005e	50		 push	 eax
  0005f	56		 push	 esi
  00060	e8 00 00 00 00	 call	 _strncpy
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH

; 234  : 			lpszValue[nValueSize - 1] = 0;

  00068	c6 44 2e ff 00	 mov	 BYTE PTR [esi+ebp-1], 0

; 235  : 			(*nArgIdx)++;

  0006d	ff 07		 inc	 DWORD PTR [edi]
  0006f	5d		 pop	 ebp
  00070	5f		 pop	 edi

; 236  : 			return HAS_ARGUMENT;

  00071	b8 01 00 00 00	 mov	 eax, 1
  00076	5e		 pop	 esi

; 241  : }

  00077	c3		 ret	 0
$LN1@GetArgumen@2:
  00078	5f		 pop	 edi

; 237  : 		}
; 238  : 	}
; 239  : 
; 240  : 	return HAS_NO_ARGUMENT;

  00079	33 c0		 xor	 eax, eax
  0007b	5e		 pop	 esi

; 241  : }

  0007c	c3		 ret	 0
_GetArgumentValue ENDP
_TEXT	ENDS
END
