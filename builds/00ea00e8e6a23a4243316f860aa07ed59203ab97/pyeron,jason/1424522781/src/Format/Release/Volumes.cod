; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\home\public\Desktop\projects\ciphershed.build\src\Common\Volumes.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_ReadVolumeHeaderRecoveryMode
_BSS	SEGMENT
_ReadVolumeHeaderRecoveryMode DD 01H DUP (?)
_BSS	ENDS
PUBLIC	_RtlSecureZeroMemory
; Function compile flags: /Ogtpy
; File c:\program files\microsoft sdks\windows\v7.1\include\winnt.h
;	COMDAT _RtlSecureZeroMemory
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory PROC				; COMDAT

; 13070:     volatile char *vptr = (volatile char *)ptr;
; 13071: 
; 13072: #if defined(_M_AMD64)
; 13073: 
; 13074:         __stosb((PBYTE )((DWORD64)vptr), 0, cnt);
; 13075: 
; 13076: #else
; 13077: 
; 13078:     while (cnt) {

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _cnt$[esp-4]
  00004	8b 44 24 04	 mov	 eax, DWORD PTR _ptr$[esp-4]
  00008	8b c8		 mov	 ecx, eax
  0000a	85 d2		 test	 edx, edx
  0000c	74 0b		 je	 SHORT $LN1@RtlSecureZ
  0000e	8b ff		 npad	 2
$LL2@RtlSecureZ:

; 13079:         *vptr = 0;

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 13080:         vptr++;

  00013	41		 inc	 ecx

; 13081:         cnt--;

  00014	83 ea 01	 sub	 edx, 1
  00017	75 f7		 jne	 SHORT $LL2@RtlSecureZ
$LN1@RtlSecureZ:

; 13082:     }
; 13083: 
; 13084: #endif
; 13085: 
; 13086:     return ptr;
; 13087: }

  00019	c3		 ret	 0
_RtlSecureZeroMemory ENDP
_TEXT	ENDS
PUBLIC	_GetHeaderField16
EXTRN	_MirrorBytes16:PROC
; Function compile flags: /Ogtpy
; File c:\home\public\desktop\projects\ciphershed.build\src\common\volumes.c
;	COMDAT _GetHeaderField16
_TEXT	SEGMENT
_header$ = 8						; size = 4
_offset$ = 12						; size = 4
_GetHeaderField16 PROC					; COMDAT

; 126  : 	return BE16 (*(uint16 *) (header + offset));

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _offset$[esp-4]
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR _header$[esp-4]
  00008	0f b7 14 01	 movzx	 edx, WORD PTR [ecx+eax]
  0000c	52		 push	 edx
  0000d	e8 00 00 00 00	 call	 _MirrorBytes16
  00012	83 c4 04	 add	 esp, 4

; 127  : }

  00015	c3		 ret	 0
_GetHeaderField16 ENDP
_TEXT	ENDS
PUBLIC	_GetHeaderField32
EXTRN	_MirrorBytes32:PROC
; Function compile flags: /Ogtpy
;	COMDAT _GetHeaderField32
_TEXT	SEGMENT
_header$ = 8						; size = 4
_offset$ = 12						; size = 4
_GetHeaderField32 PROC					; COMDAT

; 132  : 	return BE32 (*(uint32 *) (header + offset));

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _offset$[esp-4]
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR _header$[esp-4]
  00008	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  0000b	52		 push	 edx
  0000c	e8 00 00 00 00	 call	 _MirrorBytes32
  00011	83 c4 04	 add	 esp, 4

; 133  : }

  00014	c3		 ret	 0
_GetHeaderField32 ENDP
_TEXT	ENDS
PUBLIC	_GetHeaderField64
EXTRN	_MirrorBytes64:PROC
; Function compile flags: /Ogtpy
;	COMDAT _GetHeaderField64
_TEXT	SEGMENT
_header$ = 8						; size = 4
_offset$ = 12						; size = 4
_GetHeaderField64 PROC					; COMDAT

; 138  : 	UINT64_STRUCT uint64Struct;
; 139  : 
; 140  : #ifndef TC_NO_COMPILER_INT64
; 141  : 	uint64Struct.Value = BE64 (*(uint64 *) (header + offset));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _header$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR _offset$[esp-4]
  00008	8b 54 08 04	 mov	 edx, DWORD PTR [eax+ecx+4]
  0000c	89 54 24 08	 mov	 DWORD PTR _offset$[esp-4], edx
  00010	8b 04 08	 mov	 eax, DWORD PTR [eax+ecx]
  00013	89 44 24 04	 mov	 DWORD PTR _header$[esp-4], eax
  00017	e9 00 00 00 00	 jmp	 _MirrorBytes64
_GetHeaderField64 ENDP
_TEXT	ENDS
PUBLIC	_retHeaderCryptoInfo$GSCopy$
PUBLIC	_retInfo$GSCopy$
PUBLIC	_encryptedHeader$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_ReadVolumeHeader
EXTRN	__imp__VirtualUnlock@8:PROC
EXTRN	_crypto_close:PROC
EXTRN	_EAGetNext:PROC
EXTRN	_GetCrc32:PROC
EXTRN	_DecryptBuffer:PROC
EXTRN	_EAInitMode:PROC
EXTRN	_EAGetKeySize:PROC
EXTRN	_EAInit:PROC
EXTRN	_CipherGetBlockSize:PROC
EXTRN	_EAGetFirstCipher:PROC
EXTRN	_EAIsModeSupported:PROC
EXTRN	_EAGetFirst:PROC
EXTRN	_derive_key_whirlpool:PROC
EXTRN	_derive_key_sha1:PROC
EXTRN	_derive_key_sha512:PROC
EXTRN	_derive_key_ripemd160:PROC
EXTRN	_GetMaxPkcs5OutSize:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__InterlockedExchangeAdd@8:PROC
EXTRN	_EncryptionThreadPoolBeginKeyDerivation:PROC
EXTRN	_get_pkcs5_iteration_count:PROC
EXTRN	_crypto_loadkey:PROC
EXTRN	__imp__VirtualLock@8:PROC
EXTRN	_free:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__CreateEventA@16:PROC
EXTRN	_malloc:PROC
EXTRN	_crypto_open:PROC
EXTRN	_GetEncryptionThreadCount:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
;	COMDAT _ReadVolumeHeader
_TEXT	SEGMENT
_status$ = -1228					; size = 4
_queuedWorkItems$ = -1224				; size = 4
_enqPkcs5Prf$ = -1220					; size = 4
_primaryKeyOffset$ = -1216				; size = 4
_item$ = -1216						; size = 4
tv1157 = -1212						; size = 4
_pkcs5_prf$ = -1212					; size = 4
_encryptionThreadCount$ = -1208				; size = 4
_keyDerivationCompletedEvent$ = -1204			; size = 4
_noOutstandingWorkItemEvent$ = -1200			; size = 4
_keyDerivationWorkItems$ = -1196			; size = 4
_retHeaderCryptoInfo$GSCopy$ = -1192			; size = 4
_retInfo$GSCopy$ = -1188				; size = 4
_lrw64InitDone$79798 = -1184				; size = 4
_encryptedHeader$GSCopy$ = -1180			; size = 4
_lrw128InitDone$79799 = -1176				; size = 4
_outstandingWorkItemCount$ = -1172			; size = 4
_keyInfo$ = -1168					; size = 392
_dk$ = -776						; size = 256
_header$ = -520						; size = 512
__$ArrayPad$ = -4					; size = 4
_bBoot$ = 8						; size = 4
_encryptedHeader$ = 12					; size = 4
_password$ = 16						; size = 4
_retInfo$ = 20						; size = 4
_retHeaderCryptoInfo$ = 24				; size = 4
_ReadVolumeHeader PROC					; COMDAT

; 164  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec cc 04 00
	00		 sub	 esp, 1228		; 000004ccH
  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00011	33 c4		 xor	 eax, esp
  00013	89 84 24 c8 04
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1228], eax
  0001a	8b 45 0c	 mov	 eax, DWORD PTR _encryptedHeader$[ebp]
  0001d	53		 push	 ebx
  0001e	8b 5d 18	 mov	 ebx, DWORD PTR _retHeaderCryptoInfo$[ebp]
  00021	56		 push	 esi
  00022	8b 75 14	 mov	 esi, DWORD PTR _retInfo$[ebp]
  00025	57		 push	 edi
  00026	8b 7d 10	 mov	 edi, DWORD PTR _password$[ebp]

; 165  : 	char header[TC_VOLUME_HEADER_EFFECTIVE_SIZE];
; 166  : 	KEY_INFO keyInfo;
; 167  : 	PCRYPTO_INFO cryptoInfo;
; 168  : 	char dk[MASTER_KEYDATA_SIZE];
; 169  : 	int enqPkcs5Prf, pkcs5_prf;
; 170  : 	uint16 headerVersion;
; 171  : 	int status = ERR_PARAMETER_INCORRECT;
; 172  : 	int primaryKeyOffset;
; 173  : 
; 174  : 	TC_EVENT keyDerivationCompletedEvent;
; 175  : 	TC_EVENT noOutstandingWorkItemEvent;
; 176  : 	KeyDerivationWorkItem *keyDerivationWorkItems;
; 177  : 	KeyDerivationWorkItem *item;
; 178  : 	int pkcs5PrfCount = LAST_PRF_ID - FIRST_PRF_ID + 1;
; 179  : 	size_t encryptionThreadCount = GetEncryptionThreadCount();

  00029	89 44 24 3c	 mov	 DWORD PTR _encryptedHeader$GSCopy$[esp+1240], eax
  0002d	89 74 24 34	 mov	 DWORD PTR _retInfo$GSCopy$[esp+1240], esi
  00031	89 5c 24 30	 mov	 DWORD PTR _retHeaderCryptoInfo$GSCopy$[esp+1240], ebx
  00035	e8 00 00 00 00	 call	 _GetEncryptionThreadCount
  0003a	89 44 24 20	 mov	 DWORD PTR _encryptionThreadCount$[esp+1240], eax

; 180  : 	size_t queuedWorkItems = 0;

  0003e	33 c0		 xor	 eax, eax
  00040	89 44 24 10	 mov	 DWORD PTR _queuedWorkItems$[esp+1240], eax

; 181  : 	LONG outstandingWorkItemCount = 0;

  00044	89 44 24 44	 mov	 DWORD PTR _outstandingWorkItemCount$[esp+1240], eax

; 182  : 	int i;
; 183  : 
; 184  : 	if (retHeaderCryptoInfo != NULL)

  00048	3b d8		 cmp	 ebx, eax

; 185  : 	{
; 186  : 		cryptoInfo = retHeaderCryptoInfo;
; 187  : 	}
; 188  : 	else

  0004a	75 0d		 jne	 SHORT $LN92@ReadVolume

; 189  : 	{
; 190  : 		cryptoInfo = *retInfo = crypto_open ();

  0004c	e8 00 00 00 00	 call	 _crypto_open
  00051	8b d8		 mov	 ebx, eax
  00053	89 06		 mov	 DWORD PTR [esi], eax

; 191  : 		if (cryptoInfo == NULL)

  00055	85 db		 test	 ebx, ebx

; 192  : 			return ERR_OUTOFMEMORY;

  00057	74 7f		 je	 SHORT $LN198@ReadVolume
$LN92@ReadVolume:

; 193  : 	}
; 194  : 
; 195  : 	if (encryptionThreadCount > 1)

  00059	83 7c 24 20 01	 cmp	 DWORD PTR _encryptionThreadCount$[esp+1240], 1
  0005e	0f 86 8e 00 00
	00		 jbe	 $LN85@ReadVolume

; 196  : 	{
; 197  : 		keyDerivationWorkItems = TCalloc (sizeof (KeyDerivationWorkItem) * pkcs5PrfCount);

  00064	68 30 04 00 00	 push	 1072			; 00000430H
  00069	e8 00 00 00 00	 call	 _malloc
  0006e	8b f0		 mov	 esi, eax
  00070	83 c4 04	 add	 esp, 4
  00073	89 74 24 2c	 mov	 DWORD PTR _keyDerivationWorkItems$[esp+1240], esi

; 198  : 		if (!keyDerivationWorkItems)

  00077	85 f6		 test	 esi, esi

; 199  : 			return ERR_OUTOFMEMORY;

  00079	74 5d		 je	 SHORT $LN198@ReadVolume

; 200  : 
; 201  : 		for (i = 0; i < pkcs5PrfCount; ++i)
; 202  : 			keyDerivationWorkItems[i].Free = TRUE;
; 203  : 
; 204  : #ifdef DEVICE_DRIVER
; 205  : 		KeInitializeEvent (&keyDerivationCompletedEvent, SynchronizationEvent, FALSE);
; 206  : 		KeInitializeEvent (&noOutstandingWorkItemEvent, SynchronizationEvent, TRUE);
; 207  : #else
; 208  : 		keyDerivationCompletedEvent = CreateEvent (NULL, FALSE, FALSE, NULL);

  0007b	6a 00		 push	 0
  0007d	6a 00		 push	 0
  0007f	b8 01 00 00 00	 mov	 eax, 1
  00084	6a 00		 push	 0
  00086	6a 00		 push	 0
  00088	89 86 00 01 00
	00		 mov	 DWORD PTR [esi+256], eax
  0008e	89 86 0c 02 00
	00		 mov	 DWORD PTR [esi+524], eax
  00094	89 86 18 03 00
	00		 mov	 DWORD PTR [esi+792], eax
  0009a	89 86 24 04 00
	00		 mov	 DWORD PTR [esi+1060], eax
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateEventA@16
  000a6	89 44 24 24	 mov	 DWORD PTR _keyDerivationCompletedEvent$[esp+1240], eax

; 209  : 		if (!keyDerivationCompletedEvent)

  000aa	85 c0		 test	 eax, eax

; 210  : 		{
; 211  : 			TCfree (keyDerivationWorkItems);
; 212  : 			return ERR_OUTOFMEMORY;

  000ac	74 21		 je	 SHORT $LN199@ReadVolume

; 213  : 		}
; 214  : 
; 215  : 		noOutstandingWorkItemEvent = CreateEvent (NULL, FALSE, TRUE, NULL);

  000ae	6a 00		 push	 0
  000b0	6a 01		 push	 1
  000b2	6a 00		 push	 0
  000b4	6a 00		 push	 0
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateEventA@16
  000bc	89 44 24 28	 mov	 DWORD PTR _noOutstandingWorkItemEvent$[esp+1240], eax

; 216  : 		if (!noOutstandingWorkItemEvent)

  000c0	85 c0		 test	 eax, eax
  000c2	75 2e		 jne	 SHORT $LN85@ReadVolume

; 217  : 		{
; 218  : 			CloseHandle (keyDerivationCompletedEvent);

  000c4	8b 4c 24 24	 mov	 ecx, DWORD PTR _keyDerivationCompletedEvent$[esp+1240]
  000c8	51		 push	 ecx
  000c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN199@ReadVolume:

; 219  : 			TCfree (keyDerivationWorkItems);

  000cf	56		 push	 esi
  000d0	e8 00 00 00 00	 call	 _free
  000d5	83 c4 04	 add	 esp, 4
$LN198@ReadVolume:

; 220  : 			return ERR_OUTOFMEMORY;

  000d8	b8 02 00 00 00	 mov	 eax, 2

; 572  : #endif
; 573  : 	}
; 574  : 
; 575  : 	return status;
; 576  : }

  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	5b		 pop	 ebx
  000e0	8b 8c 24 c8 04
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1228]
  000e7	33 cc		 xor	 ecx, esp
  000e9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ee	8b e5		 mov	 esp, ebp
  000f0	5d		 pop	 ebp
  000f1	c3		 ret	 0
$LN85@ReadVolume:

; 221  : 		}
; 222  : #endif
; 223  : 	}
; 224  : 		
; 225  : #ifndef DEVICE_DRIVER
; 226  : 	VirtualLock (&keyInfo, sizeof (keyInfo));

  000f2	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__VirtualLock@8
  000f8	68 88 01 00 00	 push	 392			; 00000188H
  000fd	8d 54 24 4c	 lea	 edx, DWORD PTR _keyInfo$[esp+1244]
  00101	52		 push	 edx
  00102	ff d6		 call	 esi

; 227  : 	VirtualLock (&dk, sizeof (dk));

  00104	68 00 01 00 00	 push	 256			; 00000100H
  00109	8d 84 24 d4 01
	00 00		 lea	 eax, DWORD PTR _dk$[esp+1244]
  00110	50		 push	 eax
  00111	ff d6		 call	 esi

; 228  : #endif
; 229  : 
; 230  : 	crypto_loadkey (&keyInfo, password->Text, (int) password->Length);

  00113	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00115	51		 push	 ecx
  00116	83 c7 04	 add	 edi, 4
  00119	8d 54 24 4c	 lea	 edx, DWORD PTR _keyInfo$[esp+1244]
  0011d	57		 push	 edi
  0011e	52		 push	 edx
  0011f	e8 00 00 00 00	 call	 _crypto_loadkey

; 231  : 
; 232  : 	// PKCS5 is used to derive the primary header key(s) and secondary header key(s) (XTS mode) from the password
; 233  : 	memcpy (keyInfo.salt, encryptedHeader + HEADER_SALT_OFFSET, PKCS5_SALT_SIZE);

  00124	8b 74 24 48	 mov	 esi, DWORD PTR _encryptedHeader$GSCopy$[esp+1252]
  00128	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0012d	8d bc 24 9c 00
	00 00		 lea	 edi, DWORD PTR _keyInfo$[esp+1324]

; 234  : 
; 235  : 	// Test all available PKCS5 PRFs
; 236  : 	for (enqPkcs5Prf = FIRST_PRF_ID; enqPkcs5Prf <= LAST_PRF_ID || queuedWorkItems > 0; ++enqPkcs5Prf)

  00134	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR _enqPkcs5Prf$[esp+1252], 1
  0013c	f3 a5		 rep movsd
  0013e	8b 7c 24 20	 mov	 edi, DWORD PTR _enqPkcs5Prf$[esp+1252]
  00142	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN197@ReadVolume:
  00145	83 ff 04	 cmp	 edi, 4
  00148	8b 4c 24 10	 mov	 ecx, DWORD PTR _queuedWorkItems$[esp+1240]
  0014c	8b 44 24 20	 mov	 eax, DWORD PTR _encryptionThreadCount$[esp+1240]
  00150	7e 08		 jle	 SHORT $LN81@ReadVolume
  00152	85 c9		 test	 ecx, ecx
  00154	0f 86 93 04 00
	00		 jbe	 $LN82@ReadVolume
$LN81@ReadVolume:

; 237  : 	{
; 238  : 		BOOL lrw64InitDone = FALSE;		// Deprecated/legacy

  0015a	33 d2		 xor	 edx, edx
  0015c	89 54 24 38	 mov	 DWORD PTR _lrw64InitDone$79798[esp+1240], edx

; 239  : 		BOOL lrw128InitDone = FALSE;	// Deprecated/legacy

  00160	89 54 24 40	 mov	 DWORD PTR _lrw128InitDone$79799[esp+1240], edx

; 240  : 
; 241  : 		if (encryptionThreadCount > 1)

  00164	83 f8 01	 cmp	 eax, 1
  00167	0f 86 3b 01 00
	00		 jbe	 $LN80@ReadVolume

; 242  : 		{
; 243  : 			// Enqueue key derivation on thread pool
; 244  : 			if (queuedWorkItems < encryptionThreadCount && enqPkcs5Prf <= LAST_PRF_ID)

  0016d	3b c8		 cmp	 ecx, eax
  0016f	0f 83 8d 00 00
	00		 jae	 $LN79@ReadVolume
  00175	83 ff 04	 cmp	 edi, 4
  00178	0f 8f 84 00 00
	00		 jg	 $LN79@ReadVolume

; 245  : 			{
; 246  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  0017e	8b 44 24 2c	 mov	 eax, DWORD PTR _keyDerivationWorkItems$[esp+1240]
  00182	33 c9		 xor	 ecx, ecx
$LL78@ReadVolume:

; 247  : 				{
; 248  : 					item = &keyDerivationWorkItems[i];
; 249  : 					if (item->Free)

  00184	39 90 00 01 00
	00		 cmp	 DWORD PTR [eax+256], edx
  0018a	75 0d		 jne	 SHORT $LN151@ReadVolume
  0018c	41		 inc	 ecx
  0018d	05 0c 01 00 00	 add	 eax, 268		; 0000010cH
  00192	83 f9 04	 cmp	 ecx, 4
  00195	7c ed		 jl	 SHORT $LL78@ReadVolume

; 411  : 				
; 412  : 				if (headerVersion > VOLUME_HEADER_VERSION)

  00197	eb 5a		 jmp	 SHORT $LN76@ReadVolume
$LN151@ReadVolume:

; 250  : 					{
; 251  : 						item->Free = FALSE;
; 252  : 						item->KeyReady = FALSE;
; 253  : 						item->Pkcs5Prf = enqPkcs5Prf;
; 254  : 
; 255  : 						EncryptionThreadPoolBeginKeyDerivation (&keyDerivationCompletedEvent, &noOutstandingWorkItemEvent,
; 256  : 							&item->KeyReady, &outstandingWorkItemCount, enqPkcs5Prf, keyInfo.userKey,
; 257  : 							keyInfo.keyLength, keyInfo.salt, get_pkcs5_iteration_count (enqPkcs5Prf, bBoot), item->DerivedKey);

  00199	50		 push	 eax
  0019a	8d b0 04 01 00
	00		 lea	 esi, DWORD PTR [eax+260]
  001a0	c7 80 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+256], 0
  001aa	89 b8 08 01 00
	00		 mov	 DWORD PTR [eax+264], edi
  001b0	8b 45 08	 mov	 eax, DWORD PTR _bBoot$[ebp]
  001b3	50		 push	 eax
  001b4	57		 push	 edi
  001b5	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  001bb	e8 00 00 00 00	 call	 _get_pkcs5_iteration_count
  001c0	8b 54 24 58	 mov	 edx, DWORD PTR _keyInfo$[esp+1256]
  001c4	83 c4 08	 add	 esp, 8
  001c7	50		 push	 eax
  001c8	8d 8c 24 98 00
	00 00		 lea	 ecx, DWORD PTR _keyInfo$[esp+1320]
  001cf	51		 push	 ecx
  001d0	52		 push	 edx
  001d1	8d 44 24 60	 lea	 eax, DWORD PTR _keyInfo$[esp+1264]
  001d5	50		 push	 eax
  001d6	57		 push	 edi
  001d7	8d 4c 24 5c	 lea	 ecx, DWORD PTR _outstandingWorkItemCount$[esp+1264]
  001db	51		 push	 ecx
  001dc	56		 push	 esi
  001dd	8d 54 24 48	 lea	 edx, DWORD PTR _noOutstandingWorkItemEvent$[esp+1272]
  001e1	52		 push	 edx
  001e2	8d 44 24 48	 lea	 eax, DWORD PTR _keyDerivationCompletedEvent$[esp+1276]
  001e6	50		 push	 eax
  001e7	e8 00 00 00 00	 call	 _EncryptionThreadPoolBeginKeyDerivation
  001ec	83 c4 28	 add	 esp, 40			; 00000028H

; 258  : 						
; 259  : 						++queuedWorkItems;

  001ef	ff 44 24 10	 inc	 DWORD PTR _queuedWorkItems$[esp+1240]
$LN76@ReadVolume:

; 260  : 						break;
; 261  : 					}
; 262  : 				}
; 263  : 
; 264  : 				if (enqPkcs5Prf < LAST_PRF_ID)

  001f3	83 ff 04	 cmp	 edi, 4
  001f6	0f 8c e7 03 00
	00		 jl	 $LN83@ReadVolume

; 265  : 					continue;
; 266  : 			}
; 267  : 			else

  001fc	8b 4c 24 10	 mov	 ecx, DWORD PTR _queuedWorkItems$[esp+1240]
  00200	eb 05		 jmp	 SHORT $LN141@ReadVolume
$LN79@ReadVolume:

; 268  : 				--enqPkcs5Prf;

  00202	4f		 dec	 edi
  00203	89 7c 24 14	 mov	 DWORD PTR _enqPkcs5Prf$[esp+1240], edi
$LN141@ReadVolume:

; 269  : 
; 270  : 			// Wait for completion of a key derivation
; 271  : 			while (queuedWorkItems > 0)

  00207	85 c9		 test	 ecx, ecx
  00209	0f 86 d4 03 00
	00		 jbe	 $LN83@ReadVolume
  0020f	8b 4c 24 2c	 mov	 ecx, DWORD PTR _keyDerivationWorkItems$[esp+1240]
  00213	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H

; 272  : 			{
; 273  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  00219	89 4c 24 1c	 mov	 DWORD PTR tv1157[esp+1240], ecx
  0021d	8d 49 00	 npad	 3
$LL72@ReadVolume:
  00220	8b 74 24 1c	 mov	 esi, DWORD PTR tv1157[esp+1240]
  00224	33 ff		 xor	 edi, edi
$LN70@ReadVolume:

; 274  : 				{
; 275  : 					item = &keyDerivationWorkItems[i];
; 276  : 					if (!item->Free && InterlockedExchangeAdd (&item->KeyReady, 0) == TRUE)

  00226	83 7e fc 00	 cmp	 DWORD PTR [esi-4], 0
  0022a	8d 96 fc fe ff
	ff		 lea	 edx, DWORD PTR [esi-260]
  00230	89 54 24 18	 mov	 DWORD PTR _item$[esp+1240], edx
  00234	75 0e		 jne	 SHORT $LN69@ReadVolume
  00236	6a 00		 push	 0
  00238	56		 push	 esi
  00239	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchangeAdd@8
  0023f	83 f8 01	 cmp	 eax, 1
  00242	74 1b		 je	 SHORT $LN152@ReadVolume
$LN69@ReadVolume:

; 272  : 			{
; 273  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  00244	47		 inc	 edi
  00245	81 c6 0c 01 00
	00		 add	 esi, 268		; 0000010cH
  0024b	83 ff 04	 cmp	 edi, 4
  0024e	7c d6		 jl	 SHORT $LN70@ReadVolume

; 283  : 						--queuedWorkItems;
; 284  : 						goto KeyReady;
; 285  : 					}
; 286  : 				}
; 287  : 
; 288  : 				if (queuedWorkItems > 0)
; 289  : 					TC_WAIT_EVENT (keyDerivationCompletedEvent);

  00250	8b 44 24 24	 mov	 eax, DWORD PTR _keyDerivationCompletedEvent$[esp+1240]
  00254	6a ff		 push	 -1
  00256	50		 push	 eax
  00257	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  0025d	eb c1		 jmp	 SHORT $LL72@ReadVolume
$LN152@ReadVolume:

; 277  : 					{
; 278  : 						pkcs5_prf = item->Pkcs5Prf;
; 279  : 						keyInfo.noIterations = get_pkcs5_iteration_count (pkcs5_prf, bBoot);

  0025f	8b 4d 08	 mov	 ecx, DWORD PTR _bBoot$[ebp]
  00262	8b 74 24 18	 mov	 esi, DWORD PTR _item$[esp+1240]
  00266	8b 86 08 01 00
	00		 mov	 eax, DWORD PTR [esi+264]
  0026c	51		 push	 ecx
  0026d	50		 push	 eax
  0026e	89 44 24 24	 mov	 DWORD PTR _pkcs5_prf$[esp+1248], eax
  00272	e8 00 00 00 00	 call	 _get_pkcs5_iteration_count

; 280  : 						memcpy (dk, item->DerivedKey, sizeof (dk));
; 281  : 
; 282  : 						item->Free = TRUE;

  00277	8b 54 24 20	 mov	 edx, DWORD PTR _item$[esp+1248]
  0027b	89 44 24 50	 mov	 DWORD PTR _keyInfo$[esp+1248], eax
  0027f	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00284	8d bc 24 d8 01
	00 00		 lea	 edi, DWORD PTR _dk$[esp+1248]
  0028b	b8 01 00 00 00	 mov	 eax, 1
  00290	f3 a5		 rep movsd

; 290  : 			}
; 291  : 			continue;
; 292  : KeyReady:	;
; 293  : 		}
; 294  : 		else

  00292	8b 7c 24 1c	 mov	 edi, DWORD PTR _enqPkcs5Prf$[esp+1248]
  00296	83 c4 08	 add	 esp, 8
  00299	29 44 24 10	 sub	 DWORD PTR _queuedWorkItems$[esp+1240], eax
  0029d	89 82 00 01 00
	00		 mov	 DWORD PTR [edx+256], eax
$KeyReady$79815:
  002a3	e9 f6 00 00 00	 jmp	 $LN63@ReadVolume
$LN80@ReadVolume:

; 295  : 		{
; 296  : 			pkcs5_prf = enqPkcs5Prf;
; 297  : 			keyInfo.noIterations = get_pkcs5_iteration_count (enqPkcs5Prf, bBoot);

  002a8	8b 45 08	 mov	 eax, DWORD PTR _bBoot$[ebp]
  002ab	50		 push	 eax
  002ac	57		 push	 edi
  002ad	89 7c 24 24	 mov	 DWORD PTR _pkcs5_prf$[esp+1248], edi
  002b1	e8 00 00 00 00	 call	 _get_pkcs5_iteration_count
  002b6	89 44 24 50	 mov	 DWORD PTR _keyInfo$[esp+1248], eax

; 298  : 
; 299  : 			switch (pkcs5_prf)

  002ba	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  002bd	83 c4 08	 add	 esp, 8
  002c0	83 f8 03	 cmp	 eax, 3
  002c3	0f 87 ce 00 00
	00		 ja	 $LN58@ReadVolume
  002c9	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN200@ReadVolume[eax*4]
$LN62@ReadVolume:

; 300  : 			{
; 301  : 			case RIPEMD160:
; 302  : 				derive_key_ripemd160 (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 303  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  002d0	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize
  002d5	8b 54 24 48	 mov	 edx, DWORD PTR _keyInfo$[esp+1240]
  002d9	50		 push	 eax
  002da	8d 8c 24 d4 01
	00 00		 lea	 ecx, DWORD PTR _dk$[esp+1244]
  002e1	51		 push	 ecx
  002e2	8b 4c 24 54	 mov	 ecx, DWORD PTR _keyInfo$[esp+1252]
  002e6	52		 push	 edx
  002e7	6a 40		 push	 64			; 00000040H
  002e9	8d 84 24 a0 00
	00 00		 lea	 eax, DWORD PTR _keyInfo$[esp+1328]
  002f0	50		 push	 eax
  002f1	51		 push	 ecx
  002f2	8d 54 24 68	 lea	 edx, DWORD PTR _keyInfo$[esp+1272]
  002f6	52		 push	 edx
  002f7	e8 00 00 00 00	 call	 _derive_key_ripemd160
  002fc	83 c4 1c	 add	 esp, 28			; 0000001cH

; 304  : 				break;

  002ff	e9 9a 00 00 00	 jmp	 $LN63@ReadVolume
$LN61@ReadVolume:

; 305  : 
; 306  : 			case SHA512:
; 307  : 				derive_key_sha512 (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 308  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  00304	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize
  00309	8b 4c 24 48	 mov	 ecx, DWORD PTR _keyInfo$[esp+1240]
  0030d	50		 push	 eax
  0030e	8d 84 24 d4 01
	00 00		 lea	 eax, DWORD PTR _dk$[esp+1244]
  00315	50		 push	 eax
  00316	8b 44 24 54	 mov	 eax, DWORD PTR _keyInfo$[esp+1252]
  0031a	51		 push	 ecx
  0031b	6a 40		 push	 64			; 00000040H
  0031d	8d 94 24 a0 00
	00 00		 lea	 edx, DWORD PTR _keyInfo$[esp+1328]
  00324	52		 push	 edx
  00325	50		 push	 eax
  00326	8d 4c 24 68	 lea	 ecx, DWORD PTR _keyInfo$[esp+1272]
  0032a	51		 push	 ecx
  0032b	e8 00 00 00 00	 call	 _derive_key_sha512
  00330	83 c4 1c	 add	 esp, 28			; 0000001cH

; 309  : 				break;

  00333	eb 69		 jmp	 SHORT $LN63@ReadVolume
$LN60@ReadVolume:

; 310  : 
; 311  : 			case SHA1:
; 312  : 				// Deprecated/legacy
; 313  : 				derive_key_sha1 (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 314  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  00335	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize
  0033a	50		 push	 eax
  0033b	8b 44 24 4c	 mov	 eax, DWORD PTR _keyInfo$[esp+1244]
  0033f	8d 94 24 d4 01
	00 00		 lea	 edx, DWORD PTR _dk$[esp+1244]
  00346	52		 push	 edx
  00347	8b 54 24 54	 mov	 edx, DWORD PTR _keyInfo$[esp+1252]
  0034b	50		 push	 eax
  0034c	6a 40		 push	 64			; 00000040H
  0034e	8d 8c 24 a0 00
	00 00		 lea	 ecx, DWORD PTR _keyInfo$[esp+1328]
  00355	51		 push	 ecx
  00356	52		 push	 edx
  00357	8d 44 24 68	 lea	 eax, DWORD PTR _keyInfo$[esp+1272]
  0035b	50		 push	 eax
  0035c	e8 00 00 00 00	 call	 _derive_key_sha1
  00361	83 c4 1c	 add	 esp, 28			; 0000001cH

; 315  : 				break;

  00364	eb 38		 jmp	 SHORT $LN63@ReadVolume
$LN59@ReadVolume:

; 316  : 
; 317  : 			case WHIRLPOOL:
; 318  : 				derive_key_whirlpool (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 319  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  00366	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize
  0036b	8b 54 24 48	 mov	 edx, DWORD PTR _keyInfo$[esp+1240]
  0036f	50		 push	 eax
  00370	8d 8c 24 d4 01
	00 00		 lea	 ecx, DWORD PTR _dk$[esp+1244]
  00377	51		 push	 ecx
  00378	8b 4c 24 54	 mov	 ecx, DWORD PTR _keyInfo$[esp+1252]
  0037c	52		 push	 edx
  0037d	6a 40		 push	 64			; 00000040H
  0037f	8d 84 24 a0 00
	00 00		 lea	 eax, DWORD PTR _keyInfo$[esp+1328]
  00386	50		 push	 eax
  00387	51		 push	 ecx
  00388	8d 54 24 68	 lea	 edx, DWORD PTR _keyInfo$[esp+1272]
  0038c	52		 push	 edx
  0038d	e8 00 00 00 00	 call	 _derive_key_whirlpool
  00392	83 c4 1c	 add	 esp, 28			; 0000001cH

; 320  : 				break;

  00395	eb 07		 jmp	 SHORT $LN63@ReadVolume
$LN58@ReadVolume:

; 321  : 
; 322  : 			default:		
; 323  : 				// Unknown/wrong ID
; 324  : 				TC_THROW_FATAL_EXCEPTION;

  00397	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
$LN63@ReadVolume:

; 325  : 			} 
; 326  : 		}
; 327  : 
; 328  : 		// Test all available modes of operation
; 329  : 		for (cryptoInfo->mode = FIRST_MODE_OF_OPERATION_ID;
; 330  : 			cryptoInfo->mode <= LAST_MODE_OF_OPERATION;
; 331  : 			cryptoInfo->mode++)

  0039e	c7 43 04 01 00
	00 00		 mov	 DWORD PTR [ebx+4], 1
$LN57@ReadVolume:

; 332  : 		{
; 333  : 			switch (cryptoInfo->mode)

  003a5	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  003a8	83 c0 fe	 add	 eax, -2			; fffffffeH
  003ab	83 f8 03	 cmp	 eax, 3
  003ae	77 22		 ja	 SHORT $LN51@ReadVolume

; 334  : 			{
; 335  : 			case LRW:
; 336  : 			case CBC:
; 337  : 			case INNER_CBC:
; 338  : 			case OUTER_CBC:
; 339  : 
; 340  : 				// For LRW (deprecated/legacy), copy the tweak key 
; 341  : 				// For CBC (deprecated/legacy), copy the IV/whitening seed 
; 342  : 				memcpy (cryptoInfo->k2, dk, LEGACY_VOL_IV_SIZE);

  003b0	8d bb a8 42 00
	00		 lea	 edi, DWORD PTR [ebx+17064]
  003b6	b9 08 00 00 00	 mov	 ecx, 8
  003bb	8d b4 24 d0 01
	00 00		 lea	 esi, DWORD PTR _dk$[esp+1240]
  003c2	f3 a5		 rep movsd

; 343  : 				primaryKeyOffset = LEGACY_VOL_IV_SIZE;
; 344  : 				break;

  003c4	8b 7c 24 14	 mov	 edi, DWORD PTR _enqPkcs5Prf$[esp+1240]
  003c8	c7 44 24 18 20
	00 00 00	 mov	 DWORD PTR _primaryKeyOffset$[esp+1240], 32 ; 00000020H
  003d0	eb 08		 jmp	 SHORT $LN53@ReadVolume
$LN51@ReadVolume:

; 345  : 
; 346  : 			default:
; 347  : 				primaryKeyOffset = 0;

  003d2	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _primaryKeyOffset$[esp+1240], 0
$LN53@ReadVolume:

; 348  : 			}
; 349  : 
; 350  : 			// Test all available encryption algorithms
; 351  : 			for (cryptoInfo->ea = EAGetFirst ();
; 352  : 				cryptoInfo->ea != 0;
; 353  : 				cryptoInfo->ea = EAGetNext (cryptoInfo->ea))

  003da	e8 00 00 00 00	 call	 _EAGetFirst
  003df	89 03		 mov	 DWORD PTR [ebx], eax
  003e1	85 c0		 test	 eax, eax
  003e3	0f 84 ed 01 00
	00		 je	 $LN56@ReadVolume
  003e9	8d a4 24 00 00
	00 00		 npad	 7
$LL190@ReadVolume:

; 354  : 			{
; 355  : 				int blockSize;
; 356  : 
; 357  : 				if (!EAIsModeSupported (cryptoInfo->ea, cryptoInfo->mode))

  003f0	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  003f3	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  003f5	50		 push	 eax
  003f6	51		 push	 ecx
  003f7	bf 01 00 00 00	 mov	 edi, 1
  003fc	e8 00 00 00 00	 call	 _EAIsModeSupported
  00401	83 c4 08	 add	 esp, 8
  00404	85 c0		 test	 eax, eax
  00406	0f 84 b1 01 00
	00		 je	 $LN49@ReadVolume

; 358  : 					continue;	// This encryption algorithm has never been available with this mode of operation
; 359  : 
; 360  : 				blockSize = CipherGetBlockSize (EAGetFirstCipher (cryptoInfo->ea));

  0040c	8b 13		 mov	 edx, DWORD PTR [ebx]
  0040e	52		 push	 edx
  0040f	e8 00 00 00 00	 call	 _EAGetFirstCipher
  00414	50		 push	 eax
  00415	e8 00 00 00 00	 call	 _CipherGetBlockSize

; 361  : 
; 362  : 				status = EAInit (cryptoInfo->ea, dk + primaryKeyOffset, cryptoInfo->ks);

  0041a	8b 4c 24 20	 mov	 ecx, DWORD PTR _primaryKeyOffset$[esp+1248]
  0041e	8b f0		 mov	 esi, eax
  00420	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  00423	50		 push	 eax
  00424	8b 03		 mov	 eax, DWORD PTR [ebx]
  00426	8d 94 0c dc 01
	00 00		 lea	 edx, DWORD PTR _dk$[esp+ecx+1252]
  0042d	52		 push	 edx
  0042e	50		 push	 eax
  0042f	e8 00 00 00 00	 call	 _EAInit
  00434	83 c4 14	 add	 esp, 20			; 00000014H
  00437	89 44 24 0c	 mov	 DWORD PTR _status$[esp+1240], eax

; 363  : 				if (status == ERR_CIPHER_INIT_FAILURE)

  0043b	83 f8 11	 cmp	 eax, 17			; 00000011H
  0043e	0f 84 5e 04 00
	00		 je	 $err$79843

; 364  : 					goto err;
; 365  : 
; 366  : 				// Init objects related to the mode of operation
; 367  : 
; 368  : 				if (cryptoInfo->mode == XTS)

  00444	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00447	3b c7		 cmp	 eax, edi
  00449	75 3e		 jne	 SHORT $LN45@ReadVolume

; 369  : 				{
; 370  : 					// Copy the secondary key (if cascade, multiple concatenated)
; 371  : 					memcpy (cryptoInfo->k2, dk + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));

  0044b	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0044d	51		 push	 ecx
  0044e	e8 00 00 00 00	 call	 _EAGetKeySize
  00453	8b 13		 mov	 edx, DWORD PTR [ebx]
  00455	83 c4 04	 add	 esp, 4
  00458	50		 push	 eax
  00459	52		 push	 edx
  0045a	e8 00 00 00 00	 call	 _EAGetKeySize
  0045f	83 c4 04	 add	 esp, 4
  00462	8d 84 04 d4 01
	00 00		 lea	 eax, DWORD PTR _dk$[esp+eax+1244]
  00469	50		 push	 eax
  0046a	8d 8b a8 42 00
	00		 lea	 ecx, DWORD PTR [ebx+17064]
  00470	51		 push	 ecx
  00471	e8 00 00 00 00	 call	 _memcpy

; 372  : 
; 373  : 					// Secondary key schedule
; 374  : 					if (!EAInitMode (cryptoInfo))

  00476	53		 push	 ebx
  00477	e8 00 00 00 00	 call	 _EAInitMode
  0047c	83 c4 10	 add	 esp, 16			; 00000010H
  0047f	85 c0		 test	 eax, eax
  00481	0f 84 ff 03 00
	00		 je	 $LN154@ReadVolume

; 375  : 					{
; 376  : 						status = ERR_MODE_INIT_FAILED;
; 377  : 						goto err;
; 378  : 					}
; 379  : 				}
; 380  : 				else if (cryptoInfo->mode == LRW

  00487	eb 44		 jmp	 SHORT $LN36@ReadVolume
$LN45@ReadVolume:

; 381  : 					&& (blockSize == 8 && !lrw64InitDone || blockSize == 16 && !lrw128InitDone))

  00489	83 f8 02	 cmp	 eax, 2
  0048c	75 3f		 jne	 SHORT $LN36@ReadVolume
  0048e	83 fe 08	 cmp	 esi, 8
  00491	75 09		 jne	 SHORT $LN40@ReadVolume
  00493	83 7c 24 38 00	 cmp	 DWORD PTR _lrw64InitDone$79798[esp+1240], 0
  00498	74 0e		 je	 SHORT $LN41@ReadVolume
  0049a	eb 31		 jmp	 SHORT $LN36@ReadVolume
$LN40@ReadVolume:
  0049c	83 fe 10	 cmp	 esi, 16			; 00000010H
  0049f	75 2c		 jne	 SHORT $LN36@ReadVolume
  004a1	83 7c 24 40 00	 cmp	 DWORD PTR _lrw128InitDone$79799[esp+1240], 0
  004a6	75 25		 jne	 SHORT $LN36@ReadVolume
$LN41@ReadVolume:

; 382  : 				{
; 383  : 					// Deprecated/legacy
; 384  : 
; 385  : 					if (!EAInitMode (cryptoInfo))

  004a8	53		 push	 ebx
  004a9	e8 00 00 00 00	 call	 _EAInitMode
  004ae	83 c4 04	 add	 esp, 4
  004b1	85 c0		 test	 eax, eax
  004b3	0f 84 cd 03 00
	00		 je	 $LN154@ReadVolume

; 386  : 					{
; 387  : 						status = ERR_MODE_INIT_FAILED;
; 388  : 						goto err;
; 389  : 					}
; 390  : 
; 391  : 					if (blockSize == 8)

  004b9	83 fe 08	 cmp	 esi, 8
  004bc	75 06		 jne	 SHORT $LN38@ReadVolume

; 392  : 						lrw64InitDone = TRUE;

  004be	89 7c 24 38	 mov	 DWORD PTR _lrw64InitDone$79798[esp+1240], edi
  004c2	eb 09		 jmp	 SHORT $LN36@ReadVolume
$LN38@ReadVolume:

; 393  : 					else if (blockSize == 16)

  004c4	83 fe 10	 cmp	 esi, 16			; 00000010H
  004c7	75 04		 jne	 SHORT $LN36@ReadVolume

; 394  : 						lrw128InitDone = TRUE;

  004c9	89 7c 24 40	 mov	 DWORD PTR _lrw128InitDone$79799[esp+1240], edi
$LN36@ReadVolume:

; 395  : 				}
; 396  : 
; 397  : 				// Copy the header for decryption
; 398  : 				memcpy (header, encryptedHeader, sizeof (header));

  004cd	8b 74 24 3c	 mov	 esi, DWORD PTR _encryptedHeader$GSCopy$[esp+1240]

; 399  : 
; 400  : 				// Try to decrypt header 
; 401  : 
; 402  : 				DecryptBuffer (header + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, cryptoInfo);

  004d1	53		 push	 ebx
  004d2	6a 00		 push	 0
  004d4	8d 94 24 18 03
	00 00		 lea	 edx, DWORD PTR _header$[esp+1312]
  004db	68 c0 01 00 00	 push	 448			; 000001c0H
  004e0	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  004e5	8d bc 24 dc 02
	00 00		 lea	 edi, DWORD PTR _header$[esp+1252]
  004ec	52		 push	 edx
  004ed	f3 a5		 rep movsd
  004ef	e8 00 00 00 00	 call	 _DecryptBuffer

; 403  : 
; 404  : 				// Magic 'TRUE'
; 405  : 				/* Modifying 'TRUE' can introduce incompatibility with previous versions. */
; 406  : 				if (GetHeaderField32 (header, TC_HEADER_OFFSET_MAGIC) != 0x54525545)

  004f4	8b 84 24 20 03
	00 00		 mov	 eax, DWORD PTR _header$[esp+1320]
  004fb	50		 push	 eax
  004fc	e8 00 00 00 00	 call	 _MirrorBytes32
  00501	83 c4 14	 add	 esp, 20			; 00000014H
  00504	3d 45 55 52 54	 cmp	 eax, 1414681925		; 54525545H
  00509	0f 85 ae 00 00
	00		 jne	 $LN49@ReadVolume

; 407  : 					continue;
; 408  : 
; 409  : 				// Header version
; 410  : 				headerVersion = GetHeaderField16 (header, TC_HEADER_OFFSET_VERSION);

  0050f	8b 8c 24 14 03
	00 00		 mov	 ecx, DWORD PTR _header$[esp+1308]
  00516	51		 push	 ecx
  00517	e8 00 00 00 00	 call	 _MirrorBytes16
  0051c	0f b7 f8	 movzx	 edi, ax
  0051f	83 c4 04	 add	 esp, 4

; 411  : 				
; 412  : 				if (headerVersion > VOLUME_HEADER_VERSION)

  00522	66 83 ff 05	 cmp	 di, 5
  00526	0f 87 dc 00 00
	00		 ja	 $LN156@ReadVolume

; 413  : 				{
; 414  : 					status = ERR_NEW_VERSION_REQUIRED;
; 415  : 					goto err;
; 416  : 				}
; 417  : 
; 418  : 				// Check CRC of the header fields
; 419  : 				if (!ReadVolumeHeaderRecoveryMode
; 420  : 					&& headerVersion >= 4
; 421  : 					&& GetHeaderField32 (header, TC_HEADER_OFFSET_HEADER_CRC) != GetCrc32 (header + TC_HEADER_OFFSET_MAGIC, TC_HEADER_OFFSET_HEADER_CRC - TC_HEADER_OFFSET_MAGIC))

  0052c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ReadVolumeHeaderRecoveryMode, 0
  00533	75 2e		 jne	 SHORT $LN33@ReadVolume
  00535	66 83 ff 04	 cmp	 di, 4
  00539	72 28		 jb	 SHORT $LN33@ReadVolume
  0053b	8b 94 24 cc 03
	00 00		 mov	 edx, DWORD PTR _header$[esp+1492]
  00542	52		 push	 edx
  00543	e8 00 00 00 00	 call	 _MirrorBytes32
  00548	8b f0		 mov	 esi, eax
  0054a	8d 84 24 14 03
	00 00		 lea	 eax, DWORD PTR _header$[esp+1308]
  00551	68 bc 00 00 00	 push	 188			; 000000bcH
  00556	50		 push	 eax
  00557	e8 00 00 00 00	 call	 _GetCrc32
  0055c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0055f	3b f0		 cmp	 esi, eax
  00561	75 5a		 jne	 SHORT $LN49@ReadVolume
$LN33@ReadVolume:

; 422  : 					continue;
; 423  : 
; 424  : 				// Required program version
; 425  : 				cryptoInfo->RequiredProgramVersion = GetHeaderField16 (header, TC_HEADER_OFFSET_REQUIRED_VERSION);

  00563	8b 8c 24 16 03
	00 00		 mov	 ecx, DWORD PTR _header$[esp+1310]
  0056a	51		 push	 ecx
  0056b	e8 00 00 00 00	 call	 _MirrorBytes16
  00570	83 c4 04	 add	 esp, 4

; 426  : 				cryptoInfo->LegacyVolume = cryptoInfo->RequiredProgramVersion < 0x600;

  00573	ba 00 06 00 00	 mov	 edx, 1536		; 00000600H
  00578	66 3b c2	 cmp	 ax, dx
  0057b	66 89 83 38 44
	00 00		 mov	 WORD PTR [ebx+17464], ax
  00582	1b c0		 sbb	 eax, eax
  00584	f7 d8		 neg	 eax
  00586	89 83 3c 44 00
	00		 mov	 DWORD PTR [ebx+17468], eax

; 427  : 
; 428  : 				// Check CRC of the key set
; 429  : 				if (!ReadVolumeHeaderRecoveryMode
; 430  : 					&& GetHeaderField32 (header, TC_HEADER_OFFSET_KEY_AREA_CRC) != GetCrc32 (header + HEADER_MASTER_KEYDATA_OFFSET, MASTER_KEYDATA_SIZE))

  0058c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ReadVolumeHeaderRecoveryMode, 0
  00593	75 65		 jne	 SHORT $LN32@ReadVolume
  00595	8b 8c 24 18 03
	00 00		 mov	 ecx, DWORD PTR _header$[esp+1312]
  0059c	51		 push	 ecx
  0059d	e8 00 00 00 00	 call	 _MirrorBytes32
  005a2	8d 94 24 d4 03
	00 00		 lea	 edx, DWORD PTR _header$[esp+1500]
  005a9	68 00 01 00 00	 push	 256			; 00000100H
  005ae	52		 push	 edx
  005af	8b f0		 mov	 esi, eax
  005b1	e8 00 00 00 00	 call	 _GetCrc32
  005b6	83 c4 0c	 add	 esp, 12			; 0000000cH
  005b9	3b f0		 cmp	 esi, eax
  005bb	74 3d		 je	 SHORT $LN32@ReadVolume
$LN49@ReadVolume:

; 348  : 			}
; 349  : 
; 350  : 			// Test all available encryption algorithms
; 351  : 			for (cryptoInfo->ea = EAGetFirst ();
; 352  : 				cryptoInfo->ea != 0;
; 353  : 				cryptoInfo->ea = EAGetNext (cryptoInfo->ea))

  005bd	8b 03		 mov	 eax, DWORD PTR [ebx]
  005bf	50		 push	 eax
  005c0	e8 00 00 00 00	 call	 _EAGetNext
  005c5	83 c4 04	 add	 esp, 4
  005c8	89 03		 mov	 DWORD PTR [ebx], eax
  005ca	85 c0		 test	 eax, eax
  005cc	0f 85 1e fe ff
	ff		 jne	 $LL190@ReadVolume
  005d2	8b 7c 24 14	 mov	 edi, DWORD PTR _enqPkcs5Prf$[esp+1240]
$LN56@ReadVolume:

; 325  : 			} 
; 326  : 		}
; 327  : 
; 328  : 		// Test all available modes of operation
; 329  : 		for (cryptoInfo->mode = FIRST_MODE_OF_OPERATION_ID;
; 330  : 			cryptoInfo->mode <= LAST_MODE_OF_OPERATION;
; 331  : 			cryptoInfo->mode++)

  005d6	ff 43 04	 inc	 DWORD PTR [ebx+4]
  005d9	83 7b 04 05	 cmp	 DWORD PTR [ebx+4], 5
  005dd	0f 8e c2 fd ff
	ff		 jle	 $LN57@ReadVolume
$LN83@ReadVolume:

; 234  : 
; 235  : 	// Test all available PKCS5 PRFs
; 236  : 	for (enqPkcs5Prf = FIRST_PRF_ID; enqPkcs5Prf <= LAST_PRF_ID || queuedWorkItems > 0; ++enqPkcs5Prf)

  005e3	47		 inc	 edi
  005e4	89 7c 24 14	 mov	 DWORD PTR _enqPkcs5Prf$[esp+1240], edi
  005e8	e9 58 fb ff ff	 jmp	 $LN197@ReadVolume
$LN82@ReadVolume:

; 541  : 			}
; 542  : 		}
; 543  : 	}
; 544  : 	status = ERR_PASSWORD_WRONG;

  005ed	c7 44 24 0c 03
	00 00 00	 mov	 DWORD PTR _status$[esp+1240], 3
  005f5	e9 a8 02 00 00	 jmp	 $err$79843
$LN32@ReadVolume:

; 431  : 					continue;
; 432  : 
; 433  : 				// Now we have the correct password, cipher, hash algorithm, and volume type
; 434  : 
; 435  : 				// Check the version required to handle this volume
; 436  : 				if (cryptoInfo->RequiredProgramVersion > VERSION_NUM)

  005fa	b9 30 07 00 00	 mov	 ecx, 1840		; 00000730H
  005ff	66 39 8b 38 44
	00 00		 cmp	 WORD PTR [ebx+17464], cx
  00606	76 0d		 jbe	 SHORT $LN31@ReadVolume
$LN156@ReadVolume:

; 437  : 				{
; 438  : 					status = ERR_NEW_VERSION_REQUIRED;

  00608	c7 44 24 0c 10
	00 00 00	 mov	 DWORD PTR _status$[esp+1240], 16 ; 00000010H

; 439  : 					goto err;

  00610	e9 8d 02 00 00	 jmp	 $err$79843
$LN31@ReadVolume:

; 440  : 				}
; 441  : 
; 442  : 				// Header version
; 443  : 				cryptoInfo->HeaderVersion = headerVersion;

  00615	66 89 bb a4 29
	00 00		 mov	 WORD PTR [ebx+10660], di

; 444  : 
; 445  : 				// Volume creation time (legacy)
; 446  : 				cryptoInfo->volume_creation_time = GetHeaderField64 (header, TC_HEADER_OFFSET_VOLUME_CREATION_TIME).Value;

  0061c	8b 94 24 20 03
	00 00		 mov	 edx, DWORD PTR _header$[esp+1320]
  00623	8b 84 24 1c 03
	00 00		 mov	 eax, DWORD PTR _header$[esp+1316]
  0062a	52		 push	 edx
  0062b	50		 push	 eax
  0062c	e8 00 00 00 00	 call	 _MirrorBytes64
  00631	89 83 f0 43 00
	00		 mov	 DWORD PTR [ebx+17392], eax
  00637	89 93 f4 43 00
	00		 mov	 DWORD PTR [ebx+17396], edx

; 447  : 
; 448  : 				// Header creation time (legacy)
; 449  : 				cryptoInfo->header_creation_time = GetHeaderField64 (header, TC_HEADER_OFFSET_MODIFICATION_TIME).Value;

  0063d	8b 8c 24 30 03
	00 00		 mov	 ecx, DWORD PTR _header$[esp+1336]
  00644	8b 94 24 2c 03
	00 00		 mov	 edx, DWORD PTR _header$[esp+1332]
  0064b	51		 push	 ecx
  0064c	52		 push	 edx
  0064d	e8 00 00 00 00	 call	 _MirrorBytes64
  00652	89 83 f8 43 00
	00		 mov	 DWORD PTR [ebx+17400], eax
  00658	89 93 fc 43 00
	00		 mov	 DWORD PTR [ebx+17404], edx

; 450  : 
; 451  : 				// Hidden volume size (if any)
; 452  : 				cryptoInfo->hiddenVolumeSize = GetHeaderField64 (header, TC_HEADER_OFFSET_HIDDEN_VOLUME_SIZE).Value;

  0065e	8b 84 24 40 03
	00 00		 mov	 eax, DWORD PTR _header$[esp+1352]
  00665	8b 8c 24 3c 03
	00 00		 mov	 ecx, DWORD PTR _header$[esp+1348]
  0066c	50		 push	 eax
  0066d	51		 push	 ecx
  0066e	e8 00 00 00 00	 call	 _MirrorBytes64
  00673	89 93 14 44 00
	00		 mov	 DWORD PTR [ebx+17428], edx

; 453  : 
; 454  : 				// Hidden volume status
; 455  : 				cryptoInfo->hiddenVolume = (cryptoInfo->hiddenVolumeSize != 0);

  00679	8b d0		 mov	 edx, eax
  0067b	83 c4 18	 add	 esp, 24			; 00000018H
  0067e	0b 93 14 44 00
	00		 or	 edx, DWORD PTR [ebx+17428]
  00684	89 83 10 44 00
	00		 mov	 DWORD PTR [ebx+17424], eax
  0068a	74 07		 je	 SHORT $LN97@ReadVolume
  0068c	b8 01 00 00 00	 mov	 eax, 1
  00691	eb 02		 jmp	 SHORT $LN98@ReadVolume
$LN97@ReadVolume:
  00693	33 c0		 xor	 eax, eax
$LN98@ReadVolume:
  00695	89 83 a0 29 00
	00		 mov	 DWORD PTR [ebx+10656], eax

; 456  : 
; 457  : 				// Volume size
; 458  : 				cryptoInfo->VolumeSize = GetHeaderField64 (header, TC_HEADER_OFFSET_VOLUME_SIZE);

  0069b	8b 84 24 38 03
	00 00		 mov	 eax, DWORD PTR _header$[esp+1344]
  006a2	8b 8c 24 34 03
	00 00		 mov	 ecx, DWORD PTR _header$[esp+1340]
  006a9	50		 push	 eax
  006aa	51		 push	 ecx
  006ab	e8 00 00 00 00	 call	 _MirrorBytes64
  006b0	89 83 48 44 00
	00		 mov	 DWORD PTR [ebx+17480], eax
  006b6	89 93 4c 44 00
	00		 mov	 DWORD PTR [ebx+17484], edx

; 459  : 				
; 460  : 				// Encrypted area size and length
; 461  : 				cryptoInfo->EncryptedAreaStart = GetHeaderField64 (header, TC_HEADER_OFFSET_ENCRYPTED_AREA_START);

  006bc	8b 94 24 48 03
	00 00		 mov	 edx, DWORD PTR _header$[esp+1360]
  006c3	8b 84 24 44 03
	00 00		 mov	 eax, DWORD PTR _header$[esp+1356]
  006ca	52		 push	 edx
  006cb	50		 push	 eax
  006cc	e8 00 00 00 00	 call	 _MirrorBytes64
  006d1	89 83 50 44 00
	00		 mov	 DWORD PTR [ebx+17488], eax
  006d7	89 93 54 44 00
	00		 mov	 DWORD PTR [ebx+17492], edx

; 462  : 				cryptoInfo->EncryptedAreaLength = GetHeaderField64 (header, TC_HEADER_OFFSET_ENCRYPTED_AREA_LENGTH);

  006dd	8b 8c 24 58 03
	00 00		 mov	 ecx, DWORD PTR _header$[esp+1376]
  006e4	8b 94 24 54 03
	00 00		 mov	 edx, DWORD PTR _header$[esp+1372]
  006eb	51		 push	 ecx
  006ec	52		 push	 edx
  006ed	e8 00 00 00 00	 call	 _MirrorBytes64
  006f2	89 83 58 44 00
	00		 mov	 DWORD PTR [ebx+17496], eax
  006f8	89 93 5c 44 00
	00		 mov	 DWORD PTR [ebx+17500], edx

; 463  : 
; 464  : 				// Flags
; 465  : 				cryptoInfo->HeaderFlags = GetHeaderField32 (header, TC_HEADER_OFFSET_FLAGS);

  006fe	8b 84 24 64 03
	00 00		 mov	 eax, DWORD PTR _header$[esp+1388]
  00705	50		 push	 eax
  00706	e8 00 00 00 00	 call	 _MirrorBytes32
  0070b	83 c4 1c	 add	 esp, 28			; 0000001cH
  0070e	89 83 60 44 00
	00		 mov	 DWORD PTR [ebx+17504], eax

; 466  : 
; 467  : 				// Sector size
; 468  : 				if (headerVersion >= 5)

  00714	66 83 ff 05	 cmp	 di, 5
  00718	72 18		 jb	 SHORT $LN30@ReadVolume

; 469  : 					cryptoInfo->SectorSize = GetHeaderField32 (header, TC_HEADER_OFFSET_SECTOR_SIZE);

  0071a	8b 8c 24 50 03
	00 00		 mov	 ecx, DWORD PTR _header$[esp+1368]
  00721	51		 push	 ecx
  00722	e8 00 00 00 00	 call	 _MirrorBytes32
  00727	83 c4 04	 add	 esp, 4
  0072a	89 83 40 44 00
	00		 mov	 DWORD PTR [ebx+17472], eax

; 470  : 				else

  00730	eb 0a		 jmp	 SHORT $LN29@ReadVolume
$LN30@ReadVolume:

; 471  : 					cryptoInfo->SectorSize = TC_SECTOR_SIZE_LEGACY;

  00732	c7 83 40 44 00
	00 00 02 00 00	 mov	 DWORD PTR [ebx+17472], 512 ; 00000200H
$LN29@ReadVolume:

; 472  : 
; 473  : 				if (cryptoInfo->SectorSize < TC_MIN_VOLUME_SECTOR_SIZE
; 474  : 					|| cryptoInfo->SectorSize > TC_MAX_VOLUME_SECTOR_SIZE
; 475  : 					|| cryptoInfo->SectorSize % ENCRYPTION_DATA_UNIT_SIZE != 0)

  0073c	8b 83 40 44 00
	00		 mov	 eax, DWORD PTR [ebx+17472]
  00742	3d 00 02 00 00	 cmp	 eax, 512		; 00000200H
  00747	0f 82 4d 01 00
	00		 jb	 $LN27@ReadVolume
  0074d	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00752	0f 87 42 01 00
	00		 ja	 $LN27@ReadVolume
  00758	a9 ff 01 00 00	 test	 eax, 511		; 000001ffH
  0075d	0f 85 37 01 00
	00		 jne	 $LN27@ReadVolume

; 478  : 					goto err;
; 479  : 				}
; 480  : 
; 481  : 				// Preserve scheduled header keys if requested			
; 482  : 				if (retHeaderCryptoInfo)

  00763	8b 7c 24 30	 mov	 edi, DWORD PTR _retHeaderCryptoInfo$GSCopy$[esp+1240]
  00767	85 ff		 test	 edi, edi
  00769	74 4a		 je	 SHORT $LN26@ReadVolume

; 483  : 				{
; 484  : 					if (retInfo == NULL)

  0076b	8b 74 24 34	 mov	 esi, DWORD PTR _retInfo$GSCopy$[esp+1240]
  0076f	85 f6		 test	 esi, esi
  00771	75 19		 jne	 SHORT $LN25@ReadVolume

; 485  : 					{
; 486  : 						cryptoInfo->pkcs5 = pkcs5_prf;

  00773	8b 54 24 1c	 mov	 edx, DWORD PTR _pkcs5_prf$[esp+1240]
  00777	89 93 ec 43 00
	00		 mov	 DWORD PTR [ebx+17388], edx

; 487  : 						cryptoInfo->noIterations = keyInfo.noIterations;

  0077d	8b 44 24 48	 mov	 eax, DWORD PTR _keyInfo$[esp+1240]
  00781	89 83 e8 43 00
	00		 mov	 DWORD PTR [ebx+17384], eax

; 488  : 						goto ret;

  00787	e9 2f 01 00 00	 jmp	 $ret$79866
$LN25@ReadVolume:

; 489  : 					}
; 490  : 
; 491  : 					cryptoInfo = *retInfo = crypto_open ();

  0078c	e8 00 00 00 00	 call	 _crypto_open
  00791	8b d8		 mov	 ebx, eax
  00793	89 06		 mov	 DWORD PTR [esi], eax

; 492  : 					if (cryptoInfo == NULL)

  00795	85 db		 test	 ebx, ebx
  00797	75 0d		 jne	 SHORT $LN24@ReadVolume

; 493  : 					{
; 494  : 						status = ERR_OUTOFMEMORY;

  00799	c7 44 24 0c 02
	00 00 00	 mov	 DWORD PTR _status$[esp+1240], 2

; 495  : 						goto err;

  007a1	e9 fc 00 00 00	 jmp	 $err$79843
$LN24@ReadVolume:

; 496  : 					}
; 497  : 
; 498  : 					memcpy (cryptoInfo, retHeaderCryptoInfo, sizeof (*cryptoInfo));

  007a6	68 68 44 00 00	 push	 17512			; 00004468H
  007ab	57		 push	 edi
  007ac	53		 push	 ebx
  007ad	e8 00 00 00 00	 call	 _memcpy
  007b2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN26@ReadVolume:

; 499  : 				}
; 500  : 
; 501  : 				// Master key data
; 502  : 				memcpy (keyInfo.master_keydata, header + HEADER_MASTER_KEYDATA_OFFSET, MASTER_KEYDATA_SIZE);

  007b5	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  007ba	8d b4 24 d0 03
	00 00		 lea	 esi, DWORD PTR _header$[esp+1496]
  007c1	8d bc 24 d0 00
	00 00		 lea	 edi, DWORD PTR _keyInfo$[esp+1376]
  007c8	f3 a5		 rep movsd

; 503  : 				memcpy (cryptoInfo->master_keydata, keyInfo.master_keydata, MASTER_KEYDATA_SIZE);

  007ca	8d bb a8 41 00
	00		 lea	 edi, DWORD PTR [ebx+16808]
  007d0	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  007d5	8d b4 24 d0 00
	00 00		 lea	 esi, DWORD PTR _keyInfo$[esp+1376]
  007dc	f3 a5		 rep movsd

; 504  : 
; 505  : 				// PKCS #5
; 506  : 				memcpy (cryptoInfo->salt, keyInfo.salt, PKCS5_SALT_SIZE);

  007de	8d bb a8 43 00
	00		 lea	 edi, DWORD PTR [ebx+17320]
  007e4	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  007e9	8d b4 24 90 00
	00 00		 lea	 esi, DWORD PTR _keyInfo$[esp+1312]
  007f0	f3 a5		 rep movsd

; 507  : 				cryptoInfo->pkcs5 = pkcs5_prf;

  007f2	8b 4c 24 1c	 mov	 ecx, DWORD PTR _pkcs5_prf$[esp+1240]
  007f6	89 8b ec 43 00
	00		 mov	 DWORD PTR [ebx+17388], ecx

; 508  : 				cryptoInfo->noIterations = keyInfo.noIterations;

  007fc	8b 54 24 48	 mov	 edx, DWORD PTR _keyInfo$[esp+1240]

; 509  : 
; 510  : 				// Init the cipher with the decrypted master key
; 511  : 				status = EAInit (cryptoInfo->ea, keyInfo.master_keydata + primaryKeyOffset, cryptoInfo->ks);

  00800	8b 4c 24 18	 mov	 ecx, DWORD PTR _primaryKeyOffset$[esp+1240]
  00804	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  00807	50		 push	 eax
  00808	8b 03		 mov	 eax, DWORD PTR [ebx]
  0080a	89 93 e8 43 00
	00		 mov	 DWORD PTR [ebx+17384], edx
  00810	8d 94 0c d4 00
	00 00		 lea	 edx, DWORD PTR _keyInfo$[esp+ecx+1380]
  00817	52		 push	 edx
  00818	50		 push	 eax
  00819	e8 00 00 00 00	 call	 _EAInit
  0081e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00821	89 44 24 0c	 mov	 DWORD PTR _status$[esp+1240], eax

; 512  : 				if (status == ERR_CIPHER_INIT_FAILURE)

  00825	83 f8 11	 cmp	 eax, 17			; 00000011H
  00828	74 78		 je	 SHORT $err$79843

; 513  : 					goto err;
; 514  : 
; 515  : 				switch (cryptoInfo->mode)

  0082a	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0082d	83 c0 fe	 add	 eax, -2			; fffffffeH
  00830	83 f8 03	 cmp	 eax, 3
  00833	77 16		 ja	 SHORT $LN19@ReadVolume

; 516  : 				{
; 517  : 				case LRW:
; 518  : 				case CBC:
; 519  : 				case INNER_CBC:
; 520  : 				case OUTER_CBC:
; 521  : 
; 522  : 					// For LRW (deprecated/legacy), the tweak key
; 523  : 					// For CBC (deprecated/legacy), the IV/whitening seed
; 524  : 					memcpy (cryptoInfo->k2, keyInfo.master_keydata, LEGACY_VOL_IV_SIZE);

  00835	8d bb a8 42 00
	00		 lea	 edi, DWORD PTR [ebx+17064]
  0083b	b9 08 00 00 00	 mov	 ecx, 8
  00840	8d b4 24 d0 00
	00 00		 lea	 esi, DWORD PTR _keyInfo$[esp+1376]
  00847	f3 a5		 rep movsd

; 525  : 					break;

  00849	eb 2e		 jmp	 SHORT $LN21@ReadVolume
$LN19@ReadVolume:

; 526  : 
; 527  : 				default:
; 528  : 					// The secondary master key (if cascade, multiple concatenated)
; 529  : 					memcpy (cryptoInfo->k2, keyInfo.master_keydata + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));

  0084b	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0084d	51		 push	 ecx
  0084e	e8 00 00 00 00	 call	 _EAGetKeySize
  00853	8b 13		 mov	 edx, DWORD PTR [ebx]
  00855	83 c4 04	 add	 esp, 4
  00858	50		 push	 eax
  00859	52		 push	 edx
  0085a	e8 00 00 00 00	 call	 _EAGetKeySize
  0085f	83 c4 04	 add	 esp, 4
  00862	8d 84 04 d4 00
	00 00		 lea	 eax, DWORD PTR _keyInfo$[esp+eax+1380]
  00869	50		 push	 eax
  0086a	8d 8b a8 42 00
	00		 lea	 ecx, DWORD PTR [ebx+17064]
  00870	51		 push	 ecx
  00871	e8 00 00 00 00	 call	 _memcpy
  00876	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN21@ReadVolume:

; 530  : 
; 531  : 				}
; 532  : 
; 533  : 				if (!EAInitMode (cryptoInfo))

  00879	53		 push	 ebx
  0087a	e8 00 00 00 00	 call	 _EAInitMode
  0087f	83 c4 04	 add	 esp, 4
  00882	85 c0		 test	 eax, eax
  00884	75 0a		 jne	 SHORT $LN18@ReadVolume
$LN154@ReadVolume:

; 534  : 				{
; 535  : 					status = ERR_MODE_INIT_FAILED;

  00886	c7 44 24 0c 1b
	00 00 00	 mov	 DWORD PTR _status$[esp+1240], 27 ; 0000001bH

; 536  : 					goto err;

  0088e	eb 12		 jmp	 SHORT $err$79843
$LN18@ReadVolume:

; 537  : 				}
; 538  : 
; 539  : 				status = ERR_SUCCESS;

  00890	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _status$[esp+1240], 0

; 540  : 				goto ret;

  00898	eb 21		 jmp	 SHORT $ret$79866
$LN27@ReadVolume:

; 476  : 				{
; 477  : 					status = ERR_PARAMETER_INCORRECT;

  0089a	c7 44 24 0c 1e
	00 00 00	 mov	 DWORD PTR _status$[esp+1240], 30 ; 0000001eH
$err$79843:

; 545  : 
; 546  : err:
; 547  : 	if (cryptoInfo != retHeaderCryptoInfo)

  008a2	3b 5c 24 30	 cmp	 ebx, DWORD PTR _retHeaderCryptoInfo$GSCopy$[esp+1240]
  008a6	74 13		 je	 SHORT $ret$79866

; 548  : 	{
; 549  : 		crypto_close(cryptoInfo);

  008a8	53		 push	 ebx
  008a9	e8 00 00 00 00	 call	 _crypto_close

; 550  : 		*retInfo = NULL; 

  008ae	8b 54 24 38	 mov	 edx, DWORD PTR _retInfo$GSCopy$[esp+1244]
  008b2	83 c4 04	 add	 esp, 4
  008b5	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$ret$79866:

; 551  : 	}
; 552  : 
; 553  : ret:
; 554  : 	burn (&keyInfo, sizeof (keyInfo));

  008bb	8d 54 24 48	 lea	 edx, DWORD PTR _keyInfo$[esp+1240]
  008bf	b9 88 01 00 00	 mov	 ecx, 392		; 00000188H
  008c4	8b f1		 mov	 esi, ecx
  008c6	8b c2		 mov	 eax, edx
$LL126@ReadVolume:
  008c8	c6 00 00	 mov	 BYTE PTR [eax], 0
  008cb	40		 inc	 eax
  008cc	83 ee 01	 sub	 esi, 1
  008cf	75 f7		 jne	 SHORT $LL126@ReadVolume
$LL13@ReadVolume:
  008d1	49		 dec	 ecx
  008d2	c6 02 00	 mov	 BYTE PTR [edx], 0
  008d5	42		 inc	 edx
  008d6	85 c9		 test	 ecx, ecx
  008d8	75 f7		 jne	 SHORT $LL13@ReadVolume

; 555  : 	burn (dk, sizeof(dk));

  008da	8d 94 24 d0 01
	00 00		 lea	 edx, DWORD PTR _dk$[esp+1240]
  008e1	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  008e6	8b f1		 mov	 esi, ecx
  008e8	8b c2		 mov	 eax, edx
  008ea	8d 9b 00 00 00
	00		 npad	 6
$LL130@ReadVolume:
  008f0	c6 00 00	 mov	 BYTE PTR [eax], 0
  008f3	40		 inc	 eax
  008f4	83 ee 01	 sub	 esi, 1
  008f7	75 f7		 jne	 SHORT $LL130@ReadVolume
  008f9	8d a4 24 00 00
	00 00		 npad	 7
$LL8@ReadVolume:
  00900	49		 dec	 ecx
  00901	c6 02 00	 mov	 BYTE PTR [edx], 0
  00904	42		 inc	 edx
  00905	85 c9		 test	 ecx, ecx
  00907	75 f7		 jne	 SHORT $LL8@ReadVolume

; 556  : 
; 557  : #ifndef DEVICE_DRIVER
; 558  : 	VirtualUnlock (&keyInfo, sizeof (keyInfo));

  00909	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__VirtualUnlock@8
  0090f	68 88 01 00 00	 push	 392			; 00000188H
  00914	8d 44 24 4c	 lea	 eax, DWORD PTR _keyInfo$[esp+1244]
  00918	50		 push	 eax
  00919	ff d6		 call	 esi

; 559  : 	VirtualUnlock (&dk, sizeof (dk));

  0091b	68 00 01 00 00	 push	 256			; 00000100H
  00920	8d 8c 24 d4 01
	00 00		 lea	 ecx, DWORD PTR _dk$[esp+1244]
  00927	51		 push	 ecx
  00928	ff d6		 call	 esi

; 560  : #endif
; 561  : 
; 562  : 	if (encryptionThreadCount > 1)

  0092a	83 7c 24 20 01	 cmp	 DWORD PTR _encryptionThreadCount$[esp+1240], 1
  0092f	76 55		 jbe	 SHORT $LN6@ReadVolume

; 563  : 	{
; 564  : 		TC_WAIT_EVENT (noOutstandingWorkItemEvent);

  00931	8b 54 24 28	 mov	 edx, DWORD PTR _noOutstandingWorkItemEvent$[esp+1240]
  00935	6a ff		 push	 -1
  00937	52		 push	 edx
  00938	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 565  : 
; 566  : 		burn (keyDerivationWorkItems, sizeof (KeyDerivationWorkItem) * pkcs5PrfCount);

  0093e	8b 7c 24 2c	 mov	 edi, DWORD PTR _keyDerivationWorkItems$[esp+1240]
  00942	b9 30 04 00 00	 mov	 ecx, 1072		; 00000430H
  00947	8b d7		 mov	 edx, edi
  00949	8b f1		 mov	 esi, ecx
  0094b	8b c7		 mov	 eax, edi
  0094d	8d 49 00	 npad	 3
$LL134@ReadVolume:
  00950	c6 00 00	 mov	 BYTE PTR [eax], 0
  00953	40		 inc	 eax
  00954	83 ee 01	 sub	 esi, 1
  00957	75 f7		 jne	 SHORT $LL134@ReadVolume
  00959	8d a4 24 00 00
	00 00		 npad	 7
$LL2@ReadVolume:
  00960	49		 dec	 ecx
  00961	c6 02 00	 mov	 BYTE PTR [edx], 0
  00964	42		 inc	 edx
  00965	85 c9		 test	 ecx, ecx
  00967	75 f7		 jne	 SHORT $LL2@ReadVolume

; 567  : 		TCfree (keyDerivationWorkItems);

  00969	57		 push	 edi
  0096a	e8 00 00 00 00	 call	 _free

; 568  : 
; 569  : #ifndef DEVICE_DRIVER
; 570  : 		CloseHandle (keyDerivationCompletedEvent);

  0096f	8b 44 24 28	 mov	 eax, DWORD PTR _keyDerivationCompletedEvent$[esp+1244]
  00973	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CloseHandle@4
  00979	83 c4 04	 add	 esp, 4
  0097c	50		 push	 eax
  0097d	ff d6		 call	 esi

; 571  : 		CloseHandle (noOutstandingWorkItemEvent);

  0097f	8b 4c 24 28	 mov	 ecx, DWORD PTR _noOutstandingWorkItemEvent$[esp+1240]
  00983	51		 push	 ecx
  00984	ff d6		 call	 esi
$LN6@ReadVolume:

; 572  : #endif
; 573  : 	}
; 574  : 
; 575  : 	return status;
; 576  : }

  00986	8b 8c 24 d4 04
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1240]
  0098d	8b 44 24 0c	 mov	 eax, DWORD PTR _status$[esp+1240]
  00991	5f		 pop	 edi
  00992	5e		 pop	 esi
  00993	5b		 pop	 ebx
  00994	33 cc		 xor	 ecx, esp
  00996	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0099b	8b e5		 mov	 esp, ebp
  0099d	5d		 pop	 ebp
  0099e	c3		 ret	 0
  0099f	90		 npad	 1
$LN200@ReadVolume:
  009a0	00 00 00 00	 DD	 $LN62@ReadVolume
  009a4	00 00 00 00	 DD	 $LN61@ReadVolume
  009a8	00 00 00 00	 DD	 $LN59@ReadVolume
  009ac	00 00 00 00	 DD	 $LN60@ReadVolume
_ReadVolumeHeader ENDP
_TEXT	ENDS
PUBLIC	??_C@_04JFFKLGJF@?$CF02X?$AA@			; `string'
PUBLIC	_retInfo$GSCopy$
PUBLIC	_password$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_CreateVolumeHeaderInMemory
EXTRN	__imp__SendMessageA@16:PROC
EXTRN	_DisplayPortionsOfKeys:PROC
EXTRN	_hHeaderKey:DWORD
EXTRN	_hMasterKey:DWORD
EXTRN	_HeaderKeyGUIView:BYTE
EXTRN	_sprintf:PROC
EXTRN	_MasterKeyGUIView:BYTE
EXTRN	_bInPlaceEncNonSys:DWORD
EXTRN	_showKeys:DWORD
EXTRN	_EncryptBuffer:PROC
EXTRN	_RandgetBytes:PROC
EXTRN	_memset:PROC
_BSS	SEGMENT
?dk@?1??CreateVolumeHeaderInMemory@@9@9 DB 0100H DUP (?) ; `CreateVolumeHeaderInMemory'::`2'::dk
?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9 DB 0188H DUP (?) ; `CreateVolumeHeaderInMemory'::`2'::keyInfo
_BSS	ENDS
;	COMDAT ??_C@_04JFFKLGJF@?$CF02X?$AA@
; File c:\program files\microsoft sdks\windows\v7.1\include\winnt.h
CONST	SEGMENT
??_C@_04JFFKLGJF@?$CF02X?$AA@ DB '%02X', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\home\public\desktop\projects\ciphershed.build\src\common\volumes.c
CONST	ENDS
;	COMDAT _CreateVolumeHeaderInMemory
_TEXT	SEGMENT
tv918 = -40						; size = 4
_password$GSCopy$ = -40					; size = 4
_j$81735 = -40						; size = 4
_dots3$81733 = -36					; size = 4
_nUserKeyLen$ = -36					; size = 4
tv933 = -32						; size = 4
_retInfo$GSCopy$ = -28					; size = 4
tv936 = -24						; size = 4
_tmp2$81740 = -20					; size = 8
_tmp2$81747 = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_bBoot$ = 8						; size = 4
_header$ = 12						; size = 4
_ea$ = 16						; size = 4
_mode$ = 20						; size = 4
_password$ = 24						; size = 4
_pkcs5_prf$ = 28					; size = 4
_masterKeydata$ = 32					; size = 4
_retInfo$ = 36						; size = 4
_volumeSize$ = 40					; size = 8
_hiddenVolumeSize$ = 48					; size = 8
_encryptedAreaStart$ = 56				; size = 8
_encryptedAreaLength$ = 64				; size = 8
_requiredProgramVersion$ = 72				; size = 2
_headerFlags$ = 76					; size = 4
_sectorSize$ = 80					; size = 4
_bWipeMode$ = 84					; size = 4
_CreateVolumeHeaderInMemory PROC			; COMDAT

; 691  : {

  00000	83 ec 28	 sub	 esp, 40			; 00000028H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 24	 mov	 DWORD PTR __$ArrayPad$[esp+40], eax
  0000e	8b 44 24 3c	 mov	 eax, DWORD PTR _password$[esp+36]
  00012	8b 4c 24 48	 mov	 ecx, DWORD PTR _retInfo$[esp+36]

; 692  : 	unsigned char *p = (unsigned char *) header;
; 693  : 	static KEY_INFO keyInfo;
; 694  : 
; 695  : 	int nUserKeyLen = password->Length;

  00016	8b 10		 mov	 edx, DWORD PTR [eax]
  00018	53		 push	 ebx
  00019	8b 5c 24 34	 mov	 ebx, DWORD PTR _header$[esp+40]
  0001d	55		 push	 ebp
  0001e	56		 push	 esi
  0001f	8b 74 24 50	 mov	 esi, DWORD PTR _masterKeydata$[esp+48]
  00023	89 44 24 0c	 mov	 DWORD PTR _password$GSCopy$[esp+52], eax

; 958  : 			strcat (MasterKeyGUIView, tmp2);

  00027	89 4c 24 18	 mov	 DWORD PTR _retInfo$GSCopy$[esp+52], ecx
  0002b	89 54 24 10	 mov	 DWORD PTR _nUserKeyLen$[esp+52], edx
  0002f	e8 00 00 00 00	 call	 _crypto_open
  00034	8b e8		 mov	 ebp, eax
  00036	85 ed		 test	 ebp, ebp
  00038	75 15		 jne	 SHORT $LN56@CreateVolu
  0003a	5e		 pop	 esi
  0003b	8d 45 02	 lea	 eax, DWORD PTR [ebp+2]
  0003e	5d		 pop	 ebp
  0003f	5b		 pop	 ebx

; 986  : }

  00040	8b 4c 24 24	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+40]
  00044	33 cc		 xor	 ecx, esp
  00046	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004b	83 c4 28	 add	 esp, 40			; 00000028H
  0004e	c3		 ret	 0
$LN56@CreateVolu:
  0004f	57		 push	 edi

; 696  : 	PCRYPTO_INFO cryptoInfo = crypto_open ();
; 697  : 	static char dk[MASTER_KEYDATA_SIZE];
; 698  : 	int x;
; 699  : 	int retVal = 0;
; 700  : 	int primaryKeyOffset;
; 701  : 
; 702  : 	if (cryptoInfo == NULL)
; 703  : 		return ERR_OUTOFMEMORY;
; 704  : 
; 705  : 	memset (header, 0, TC_VOLUME_HEADER_EFFECTIVE_SIZE);

  00050	68 00 02 00 00	 push	 512			; 00000200H
  00055	6a 00		 push	 0
  00057	53		 push	 ebx
  00058	e8 00 00 00 00	 call	 _memset

; 706  : 
; 707  : 	VirtualLock (&keyInfo, sizeof (keyInfo));

  0005d	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__VirtualLock@8
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH
  00066	68 88 01 00 00	 push	 392			; 00000188H
  0006b	68 00 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9
  00070	ff d7		 call	 edi

; 708  : 	VirtualLock (&dk, sizeof (dk));

  00072	68 00 01 00 00	 push	 256			; 00000100H
  00077	68 00 00 00 00	 push	 OFFSET ?dk@?1??CreateVolumeHeaderInMemory@@9@9
  0007c	ff d7		 call	 edi

; 709  : 
; 710  : 	/* Encryption setup */
; 711  : 
; 712  : 	if (masterKeydata == NULL)

  0007e	85 f6		 test	 esi, esi
  00080	75 62		 jne	 SHORT $LN55@CreateVolu

; 713  : 	{
; 714  : 		// We have no master key data (creating a new volume) so we'll use the CipherShed RNG to generate them
; 715  : 
; 716  : 		int bytesNeeded;
; 717  : 
; 718  : 		switch (mode)

  00082	8b 7c 24 48	 mov	 edi, DWORD PTR _mode$[esp+52]
  00086	83 ff 02	 cmp	 edi, 2
  00089	7c 1e		 jl	 SHORT $LN51@CreateVolu
  0008b	83 ff 05	 cmp	 edi, 5
  0008e	7f 19		 jg	 SHORT $LN51@CreateVolu

; 719  : 		{
; 720  : 		case LRW:
; 721  : 		case CBC:
; 722  : 		case INNER_CBC:
; 723  : 		case OUTER_CBC:
; 724  : 
; 725  : 			// Deprecated/legacy modes of operation
; 726  : 			bytesNeeded = LEGACY_VOL_IV_SIZE + EAGetKeySize (ea);

  00090	8b 44 24 44	 mov	 eax, DWORD PTR _ea$[esp+52]
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 _EAGetKeySize
  0009a	83 c4 04	 add	 esp, 4
  0009d	83 c0 20	 add	 eax, 32			; 00000020H

; 727  : 
; 728  : 			// In fact, this should never be the case since volumes being newly created are not
; 729  : 			// supposed to use any deprecated mode of operation.
; 730  : 			TC_THROW_FATAL_EXCEPTION;

  000a0	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0

; 731  : 			break;

  000a7	eb 0f		 jmp	 SHORT $LN53@CreateVolu
$LN51@CreateVolu:

; 732  : 
; 733  : 		default:
; 734  : 			bytesNeeded = EAGetKeySize (ea) * 2;	// Size of primary + secondary key(s)

  000a9	8b 4c 24 44	 mov	 ecx, DWORD PTR _ea$[esp+52]
  000ad	51		 push	 ecx
  000ae	e8 00 00 00 00	 call	 _EAGetKeySize
  000b3	83 c4 04	 add	 esp, 4
  000b6	03 c0		 add	 eax, eax
$LN53@CreateVolu:

; 735  : 		}
; 736  : 
; 737  : 		if (!RandgetBytes (keyInfo.master_keydata, bytesNeeded, TRUE))

  000b8	6a 01		 push	 1
  000ba	50		 push	 eax
  000bb	68 88 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+136
  000c0	e8 00 00 00 00	 call	 _RandgetBytes
  000c5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c8	85 c0		 test	 eax, eax
  000ca	75 28		 jne	 SHORT $LN49@CreateVolu
$LN115@CreateVolu:
  000cc	5f		 pop	 edi
  000cd	5e		 pop	 esi
  000ce	5d		 pop	 ebp

; 738  : 			return ERR_CIPHER_INIT_WEAK_KEY;

  000cf	b8 12 00 00 00	 mov	 eax, 18			; 00000012H
  000d4	5b		 pop	 ebx

; 986  : }

  000d5	8b 4c 24 24	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+40]
  000d9	33 cc		 xor	 ecx, esp
  000db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e0	83 c4 28	 add	 esp, 40			; 00000028H
  000e3	c3		 ret	 0
$LN55@CreateVolu:

; 739  : 	}
; 740  : 	else
; 741  : 	{
; 742  : 		// We already have existing master key data (the header is being re-encrypted)
; 743  : 		memcpy (keyInfo.master_keydata, masterKeydata, MASTER_KEYDATA_SIZE);

  000e4	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000e9	bf 88 00 00 00	 mov	 edi, OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+136
  000ee	f3 a5		 rep movsd
  000f0	8b 7c 24 48	 mov	 edi, DWORD PTR _mode$[esp+52]
$LN49@CreateVolu:

; 744  : 	}
; 745  : 
; 746  : 	// User key 
; 747  : 	memcpy (keyInfo.userKey, password->Text, nUserKeyLen);

  000f4	8b 74 24 14	 mov	 esi, DWORD PTR _nUserKeyLen$[esp+56]
  000f8	8b 54 24 10	 mov	 edx, DWORD PTR _password$GSCopy$[esp+56]
  000fc	56		 push	 esi
  000fd	83 c2 04	 add	 edx, 4
  00100	52		 push	 edx
  00101	68 08 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+8
  00106	e8 00 00 00 00	 call	 _memcpy

; 748  : 	keyInfo.keyLength = nUserKeyLen;
; 749  : 	keyInfo.noIterations = get_pkcs5_iteration_count (pkcs5_prf, bBoot);

  0010b	8b 44 24 48	 mov	 eax, DWORD PTR _bBoot$[esp+64]
  0010f	89 35 04 00 00
	00		 mov	 DWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+4, esi
  00115	8b 74 24 5c	 mov	 esi, DWORD PTR _pkcs5_prf$[esp+64]
  00119	50		 push	 eax
  0011a	56		 push	 esi
  0011b	e8 00 00 00 00	 call	 _get_pkcs5_iteration_count

; 750  : 
; 751  : 	// User selected encryption algorithm
; 752  : 	cryptoInfo->ea = ea;

  00120	8b 4c 24 58	 mov	 ecx, DWORD PTR _ea$[esp+72]

; 753  : 
; 754  : 	// Mode of operation
; 755  : 	cryptoInfo->mode = mode;
; 756  : 
; 757  : 	// Salt for header key derivation
; 758  : 	if (!RandgetBytes (keyInfo.salt, PKCS5_SALT_SIZE, !bWipeMode))

  00124	33 d2		 xor	 edx, edx
  00126	39 94 24 9c 00
	00 00		 cmp	 DWORD PTR _bWipeMode$[esp+72], edx
  0012d	a3 00 00 00 00	 mov	 DWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9, eax
  00132	0f 94 c2	 sete	 dl
  00135	89 4d 00	 mov	 DWORD PTR [ebp], ecx
  00138	89 7d 04	 mov	 DWORD PTR [ebp+4], edi
  0013b	52		 push	 edx
  0013c	6a 40		 push	 64			; 00000040H
  0013e	68 48 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+72
  00143	e8 00 00 00 00	 call	 _RandgetBytes
  00148	83 c4 20	 add	 esp, 32			; 00000020H
  0014b	85 c0		 test	 eax, eax

; 759  : 		return ERR_CIPHER_INIT_WEAK_KEY; 

  0014d	0f 84 79 ff ff
	ff		 je	 $LN115@CreateVolu

; 760  : 
; 761  : 	// PBKDF2 (PKCS5) is used to derive primary header key(s) and secondary header key(s) (XTS) from the password/keyfiles
; 762  : 	switch (pkcs5_prf)

  00153	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  00156	83 f8 03	 cmp	 eax, 3
  00159	0f 87 c3 00 00
	00		 ja	 $LN41@CreateVolu
  0015f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN116@CreateVolu[eax*4]
$LN45@CreateVolu:

; 763  : 	{
; 764  : 	case SHA512:
; 765  : 		derive_key_sha512 (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 766  : 			PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  00166	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize
  0016b	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+4
  00171	50		 push	 eax
  00172	a1 00 00 00 00	 mov	 eax, DWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9
  00177	68 00 00 00 00	 push	 OFFSET ?dk@?1??CreateVolumeHeaderInMemory@@9@9
  0017c	50		 push	 eax
  0017d	6a 40		 push	 64			; 00000040H
  0017f	68 48 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+72
  00184	51		 push	 ecx
  00185	68 08 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+8
  0018a	e8 00 00 00 00	 call	 _derive_key_sha512
  0018f	83 c4 1c	 add	 esp, 28			; 0000001cH

; 767  : 		break;

  00192	e9 92 00 00 00	 jmp	 $LN46@CreateVolu
$LN44@CreateVolu:

; 768  : 
; 769  : 	case SHA1:
; 770  : 		// Deprecated/legacy
; 771  : 		derive_key_sha1 (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 772  : 			PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  00197	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize
  0019c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9
  001a2	50		 push	 eax
  001a3	a1 04 00 00 00	 mov	 eax, DWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+4
  001a8	68 00 00 00 00	 push	 OFFSET ?dk@?1??CreateVolumeHeaderInMemory@@9@9
  001ad	52		 push	 edx
  001ae	6a 40		 push	 64			; 00000040H
  001b0	68 48 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+72
  001b5	50		 push	 eax
  001b6	68 08 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+8
  001bb	e8 00 00 00 00	 call	 _derive_key_sha1
  001c0	83 c4 1c	 add	 esp, 28			; 0000001cH

; 773  : 		break;

  001c3	eb 64		 jmp	 SHORT $LN46@CreateVolu
$LN43@CreateVolu:

; 774  : 
; 775  : 	case RIPEMD160:
; 776  : 		derive_key_ripemd160 (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 777  : 			PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  001c5	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize
  001ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9
  001d0	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+4
  001d6	50		 push	 eax
  001d7	68 00 00 00 00	 push	 OFFSET ?dk@?1??CreateVolumeHeaderInMemory@@9@9
  001dc	51		 push	 ecx
  001dd	6a 40		 push	 64			; 00000040H
  001df	68 48 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+72
  001e4	52		 push	 edx
  001e5	68 08 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+8
  001ea	e8 00 00 00 00	 call	 _derive_key_ripemd160
  001ef	83 c4 1c	 add	 esp, 28			; 0000001cH

; 778  : 		break;

  001f2	eb 35		 jmp	 SHORT $LN46@CreateVolu
$LN42@CreateVolu:

; 779  : 
; 780  : 	case WHIRLPOOL:
; 781  : 		derive_key_whirlpool (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 782  : 			PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  001f4	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize
  001f9	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+4
  001ff	50		 push	 eax
  00200	a1 00 00 00 00	 mov	 eax, DWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9
  00205	68 00 00 00 00	 push	 OFFSET ?dk@?1??CreateVolumeHeaderInMemory@@9@9
  0020a	50		 push	 eax
  0020b	6a 40		 push	 64			; 00000040H
  0020d	68 48 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+72
  00212	51		 push	 ecx
  00213	68 08 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+8
  00218	e8 00 00 00 00	 call	 _derive_key_whirlpool
  0021d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 783  : 		break;

  00220	eb 07		 jmp	 SHORT $LN46@CreateVolu
$LN41@CreateVolu:

; 784  : 
; 785  : 	default:		
; 786  : 		// Unknown/wrong ID
; 787  : 		TC_THROW_FATAL_EXCEPTION;

  00222	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
$LN46@CreateVolu:

; 788  : 	} 
; 789  : 
; 790  : 	/* Header setup */
; 791  : 
; 792  : 	// Salt
; 793  : 	mputBytes (p, keyInfo.salt, PKCS5_SALT_SIZE);	
; 794  : 
; 795  : 	// Magic 'TRUE'
; 796  : 	/* Modifying 'TRUE' can introduce incompatibility with previous versions. */
; 797  : 	mputLong (p, 0x54525545);
; 798  : 
; 799  : 	// Header version
; 800  : 	mputWord (p, VOLUME_HEADER_VERSION);
; 801  : 	cryptoInfo->HeaderVersion = VOLUME_HEADER_VERSION;
; 802  : 
; 803  : 	// Required program version to handle this volume
; 804  : 	switch (mode)

  00229	8b 44 24 48	 mov	 eax, DWORD PTR _mode$[esp+52]
  0022d	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00232	be 48 00 00 00	 mov	 esi, OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+72
  00237	8b fb		 mov	 edi, ebx
  00239	f3 a5		 rep movsd
  0023b	c6 43 40 54	 mov	 BYTE PTR [ebx+64], 84	; 00000054H
  0023f	8d 73 40	 lea	 esi, DWORD PTR [ebx+64]
  00242	c6 46 01 52	 mov	 BYTE PTR [esi+1], 82	; 00000052H
  00246	89 74 24 10	 mov	 DWORD PTR tv918[esp+56], esi
  0024a	46		 inc	 esi
  0024b	46		 inc	 esi
  0024c	c6 06 55	 mov	 BYTE PTR [esi], 85	; 00000055H
  0024f	46		 inc	 esi
  00250	c6 06 45	 mov	 BYTE PTR [esi], 69	; 00000045H
  00253	46		 inc	 esi
  00254	c6 06 00	 mov	 BYTE PTR [esi], 0
  00257	46		 inc	 esi
  00258	c6 06 05	 mov	 BYTE PTR [esi], 5
  0025b	83 c0 fe	 add	 eax, -2			; fffffffeH
  0025e	46		 inc	 esi
  0025f	ba 05 00 00 00	 mov	 edx, 5
  00264	66 89 95 a4 29
	00 00		 mov	 WORD PTR [ebp+10660], dx
  0026b	83 f8 03	 cmp	 eax, 3
  0026e	77 53		 ja	 SHORT $LN35@CreateVolu
  00270	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN117@CreateVolu[eax*4]
$LN38@CreateVolu:

; 805  : 	{
; 806  : 	case LRW:
; 807  : 		// Deprecated/legacy
; 808  : 		mputWord (p, 0x0410);

  00277	c6 06 04	 mov	 BYTE PTR [esi], 4
  0027a	46		 inc	 esi
  0027b	c6 06 10	 mov	 BYTE PTR [esi], 16	; 00000010H

; 809  : 		break;

  0027e	eb 6c		 jmp	 SHORT $LN113@CreateVolu
$LN37@CreateVolu:

; 810  : 	case OUTER_CBC:
; 811  : 	case INNER_CBC:
; 812  : 		// Deprecated/legacy
; 813  : 		mputWord (p, 0x0300);

  00280	c6 06 03	 mov	 BYTE PTR [esi], 3
  00283	46		 inc	 esi
  00284	c6 06 00	 mov	 BYTE PTR [esi], 0

; 814  : 		break;

  00287	eb 63		 jmp	 SHORT $LN113@CreateVolu
$LN36@CreateVolu:

; 815  : 	case CBC:
; 816  : 		// Deprecated/legacy
; 817  : 		mputWord (p, hiddenVolumeSize > 0 ? 0x0300 : 0x0100);

  00289	8b 4c 24 68	 mov	 ecx, DWORD PTR _hiddenVolumeSize$[esp+56]
  0028d	85 c9		 test	 ecx, ecx
  0028f	77 07		 ja	 SHORT $LN108@CreateVolu
  00291	83 7c 24 64 00	 cmp	 DWORD PTR _hiddenVolumeSize$[esp+52], 0
  00296	76 07		 jbe	 SHORT $LN59@CreateVolu
$LN108@CreateVolu:
  00298	b8 00 03 00 00	 mov	 eax, 768		; 00000300H
  0029d	eb 05		 jmp	 SHORT $LN60@CreateVolu
$LN59@CreateVolu:
  0029f	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
$LN60@CreateVolu:
  002a4	c1 f8 08	 sar	 eax, 8
  002a7	88 06		 mov	 BYTE PTR [esi], al
  002a9	46		 inc	 esi
  002aa	85 c9		 test	 ecx, ecx
  002ac	77 07		 ja	 SHORT $LN100@CreateVolu
  002ae	83 7c 24 64 00	 cmp	 DWORD PTR _hiddenVolumeSize$[esp+52], 0
  002b3	76 07		 jbe	 SHORT $LN61@CreateVolu
$LN100@CreateVolu:
  002b5	b8 00 03 00 00	 mov	 eax, 768		; 00000300H
  002ba	eb 2e		 jmp	 SHORT $LN66@CreateVolu
$LN61@CreateVolu:
  002bc	b8 00 01 00 00	 mov	 eax, 256		; 00000100H

; 818  : 		break;

  002c1	eb 27		 jmp	 SHORT $LN66@CreateVolu
$LN35@CreateVolu:

; 819  : 	default:
; 820  : 		mputWord (p, requiredProgramVersion != 0 ? requiredProgramVersion : TC_VOLUME_MIN_REQUIRED_PROGRAM_VERSION);

  002c3	66 8b 44 24 7c	 mov	 ax, WORD PTR _requiredProgramVersion$[esp+52]
  002c8	0f b7 f8	 movzx	 edi, ax
  002cb	66 85 c0	 test	 ax, ax
  002ce	75 05		 jne	 SHORT $LN64@CreateVolu
  002d0	bf 00 07 00 00	 mov	 edi, 1792		; 00000700H
$LN64@CreateVolu:
  002d5	8b cf		 mov	 ecx, edi
  002d7	c1 f9 08	 sar	 ecx, 8
  002da	88 0e		 mov	 BYTE PTR [esi], cl
  002dc	46		 inc	 esi
  002dd	66 85 c0	 test	 ax, ax
  002e0	0f b7 c0	 movzx	 eax, ax
  002e3	75 05		 jne	 SHORT $LN66@CreateVolu
  002e5	b8 00 07 00 00	 mov	 eax, 1792		; 00000700H
$LN66@CreateVolu:
  002ea	88 06		 mov	 BYTE PTR [esi], al
$LN113@CreateVolu:

; 821  : 	}
; 822  : 
; 823  : 	// CRC of the master key data
; 824  : 	x = GetCrc32(keyInfo.master_keydata, MASTER_KEYDATA_SIZE);

  002ec	68 00 01 00 00	 push	 256			; 00000100H
  002f1	68 88 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+136
  002f6	46		 inc	 esi
  002f7	e8 00 00 00 00	 call	 _GetCrc32

; 825  : 	mputLong (p, x);

  002fc	46		 inc	 esi
  002fd	8b d0		 mov	 edx, eax
  002ff	c1 fa 18	 sar	 edx, 24			; 00000018H
  00302	88 56 ff	 mov	 BYTE PTR [esi-1], dl
  00305	46		 inc	 esi
  00306	8b c8		 mov	 ecx, eax
  00308	c1 f9 10	 sar	 ecx, 16			; 00000010H
  0030b	88 4e ff	 mov	 BYTE PTR [esi-1], cl

; 826  : 
; 827  : 	// Reserved fields
; 828  : 	p += 2 * 8;
; 829  : 
; 830  : 	// Size of hidden volume (if any)
; 831  : 	cryptoInfo->hiddenVolumeSize = hiddenVolumeSize;

  0030e	8b 4c 24 70	 mov	 ecx, DWORD PTR _hiddenVolumeSize$[esp+64]
  00312	46		 inc	 esi
  00313	8b d0		 mov	 edx, eax
  00315	c1 fa 08	 sar	 edx, 8
  00318	88 56 ff	 mov	 BYTE PTR [esi-1], dl
  0031b	88 06		 mov	 BYTE PTR [esi], al
  0031d	8b 44 24 6c	 mov	 eax, DWORD PTR _hiddenVolumeSize$[esp+60]
  00321	89 8d 14 44 00
	00		 mov	 DWORD PTR [ebp+17428], ecx

; 832  : 	mputInt64 (p, cryptoInfo->hiddenVolumeSize);

  00327	0f b6 95 17 44
	00 00		 movzx	 edx, BYTE PTR [ebp+17431]
  0032e	89 85 10 44 00
	00		 mov	 DWORD PTR [ebp+17424], eax
  00334	88 56 11	 mov	 BYTE PTR [esi+17], dl
  00337	0f b6 85 16 44
	00 00		 movzx	 eax, BYTE PTR [ebp+17430]
  0033e	83 c6 11	 add	 esi, 17			; 00000011H
  00341	88 46 01	 mov	 BYTE PTR [esi+1], al
  00344	0f b6 8d 15 44
	00 00		 movzx	 ecx, BYTE PTR [ebp+17429]
  0034b	46		 inc	 esi
  0034c	88 4e 01	 mov	 BYTE PTR [esi+1], cl
  0034f	0f b6 95 14 44
	00 00		 movzx	 edx, BYTE PTR [ebp+17428]
  00356	46		 inc	 esi
  00357	88 56 01	 mov	 BYTE PTR [esi+1], dl
  0035a	0f b6 85 13 44
	00 00		 movzx	 eax, BYTE PTR [ebp+17427]
  00361	46		 inc	 esi
  00362	88 46 01	 mov	 BYTE PTR [esi+1], al
  00365	0f b6 8d 12 44
	00 00		 movzx	 ecx, BYTE PTR [ebp+17426]
  0036c	46		 inc	 esi
  0036d	88 4e 01	 mov	 BYTE PTR [esi+1], cl
  00370	0f b6 95 11 44
	00 00		 movzx	 edx, BYTE PTR [ebp+17425]
  00377	46		 inc	 esi
  00378	46		 inc	 esi
  00379	88 16		 mov	 BYTE PTR [esi], dl
  0037b	0f b6 85 10 44
	00 00		 movzx	 eax, BYTE PTR [ebp+17424]
  00382	46		 inc	 esi
  00383	88 06		 mov	 BYTE PTR [esi], al

; 833  : 
; 834  : 	cryptoInfo->hiddenVolume = cryptoInfo->hiddenVolumeSize != 0;

  00385	8b 8d 10 44 00
	00		 mov	 ecx, DWORD PTR [ebp+17424]
  0038b	83 c4 08	 add	 esp, 8
  0038e	46		 inc	 esi
  0038f	0b 8d 14 44 00
	00		 or	 ecx, DWORD PTR [ebp+17428]
  00395	74 07		 je	 SHORT $LN67@CreateVolu
  00397	b8 01 00 00 00	 mov	 eax, 1
  0039c	eb 02		 jmp	 SHORT $LN68@CreateVolu
$LN67@CreateVolu:
  0039e	33 c0		 xor	 eax, eax
$LN68@CreateVolu:

; 835  : 
; 836  : 	// Volume size
; 837  : 	cryptoInfo->VolumeSize.Value = volumeSize;

  003a0	8b 4c 24 5c	 mov	 ecx, DWORD PTR _volumeSize$[esp+52]
  003a4	89 85 a0 29 00
	00		 mov	 DWORD PTR [ebp+10656], eax
  003aa	8b 44 24 60	 mov	 eax, DWORD PTR _volumeSize$[esp+56]
  003ae	89 85 4c 44 00
	00		 mov	 DWORD PTR [ebp+17484], eax
  003b4	89 8d 48 44 00
	00		 mov	 DWORD PTR [ebp+17480], ecx

; 838  : 	mputInt64 (p, volumeSize);

  003ba	46		 inc	 esi
  003bb	8b d0		 mov	 edx, eax
  003bd	c1 ea 18	 shr	 edx, 24			; 00000018H
  003c0	88 56 ff	 mov	 BYTE PTR [esi-1], dl
  003c3	46		 inc	 esi
  003c4	8b d0		 mov	 edx, eax
  003c6	c1 ea 10	 shr	 edx, 16			; 00000010H
  003c9	88 56 ff	 mov	 BYTE PTR [esi-1], dl
  003cc	46		 inc	 esi
  003cd	8b d0		 mov	 edx, eax
  003cf	c1 ea 08	 shr	 edx, 8
  003d2	88 56 ff	 mov	 BYTE PTR [esi-1], dl
  003d5	8b d0		 mov	 edx, eax
  003d7	88 16		 mov	 BYTE PTR [esi], dl
  003d9	46		 inc	 esi
  003da	8b f8		 mov	 edi, eax
  003dc	8b d1		 mov	 edx, ecx
  003de	0f ac fa 18	 shrd	 edx, edi, 24
  003e2	88 16		 mov	 BYTE PTR [esi], dl
  003e4	c1 ef 18	 shr	 edi, 24			; 00000018H
  003e7	46		 inc	 esi
  003e8	8b f8		 mov	 edi, eax
  003ea	8b d1		 mov	 edx, ecx
  003ec	0f ac fa 10	 shrd	 edx, edi, 16
  003f0	88 16		 mov	 BYTE PTR [esi], dl
  003f2	46		 inc	 esi
  003f3	8b d1		 mov	 edx, ecx
  003f5	0f ac c2 08	 shrd	 edx, eax, 8
  003f9	88 16		 mov	 BYTE PTR [esi], dl
  003fb	88 4e 01	 mov	 BYTE PTR [esi+1], cl

; 839  : 
; 840  : 	// Encrypted area start
; 841  : 	cryptoInfo->EncryptedAreaStart.Value = encryptedAreaStart;

  003fe	8b 4c 24 6c	 mov	 ecx, DWORD PTR _encryptedAreaStart$[esp+52]
  00402	46		 inc	 esi
  00403	c1 e8 08	 shr	 eax, 8
  00406	8b 44 24 70	 mov	 eax, DWORD PTR _encryptedAreaStart$[esp+56]
  0040a	46		 inc	 esi
  0040b	89 85 54 44 00
	00		 mov	 DWORD PTR [ebp+17492], eax
  00411	89 8d 50 44 00
	00		 mov	 DWORD PTR [ebp+17488], ecx

; 842  : 	mputInt64 (p, encryptedAreaStart);

  00417	8b d0		 mov	 edx, eax
  00419	c1 ea 18	 shr	 edx, 24			; 00000018H
  0041c	88 16		 mov	 BYTE PTR [esi], dl
  0041e	46		 inc	 esi
  0041f	8b d0		 mov	 edx, eax
  00421	c1 ea 10	 shr	 edx, 16			; 00000010H
  00424	88 16		 mov	 BYTE PTR [esi], dl
  00426	46		 inc	 esi
  00427	8b d0		 mov	 edx, eax
  00429	c1 ea 08	 shr	 edx, 8
  0042c	88 16		 mov	 BYTE PTR [esi], dl
  0042e	46		 inc	 esi
  0042f	c1 ef 10	 shr	 edi, 16			; 00000010H
  00432	8b d0		 mov	 edx, eax
  00434	88 16		 mov	 BYTE PTR [esi], dl
  00436	8b f8		 mov	 edi, eax
  00438	8b d1		 mov	 edx, ecx
  0043a	0f ac fa 18	 shrd	 edx, edi, 24
  0043e	88 56 01	 mov	 BYTE PTR [esi+1], dl
  00441	46		 inc	 esi
  00442	c1 ef 18	 shr	 edi, 24			; 00000018H
  00445	8b f8		 mov	 edi, eax
  00447	8b d1		 mov	 edx, ecx
  00449	0f ac fa 10	 shrd	 edx, edi, 16
  0044d	88 56 01	 mov	 BYTE PTR [esi+1], dl
  00450	46		 inc	 esi
  00451	8b d1		 mov	 edx, ecx
  00453	0f ac c2 08	 shrd	 edx, eax, 8
  00457	46		 inc	 esi
  00458	88 16		 mov	 BYTE PTR [esi], dl
  0045a	46		 inc	 esi
  0045b	88 0e		 mov	 BYTE PTR [esi], cl

; 843  : 
; 844  : 	// Encrypted area size
; 845  : 	cryptoInfo->EncryptedAreaLength.Value = encryptedAreaLength;

  0045d	8b 4c 24 74	 mov	 ecx, DWORD PTR _encryptedAreaLength$[esp+52]
  00461	c1 e8 08	 shr	 eax, 8
  00464	8b 44 24 78	 mov	 eax, DWORD PTR _encryptedAreaLength$[esp+56]
  00468	c1 ef 10	 shr	 edi, 16			; 00000010H
  0046b	46		 inc	 esi
  0046c	89 8d 58 44 00
	00		 mov	 DWORD PTR [ebp+17496], ecx
  00472	89 85 5c 44 00
	00		 mov	 DWORD PTR [ebp+17500], eax

; 846  : 	mputInt64 (p, encryptedAreaLength);

  00478	46		 inc	 esi
  00479	8b d0		 mov	 edx, eax
  0047b	c1 ea 18	 shr	 edx, 24			; 00000018H
  0047e	88 56 ff	 mov	 BYTE PTR [esi-1], dl
  00481	46		 inc	 esi
  00482	8b d0		 mov	 edx, eax
  00484	c1 ea 10	 shr	 edx, 16			; 00000010H
  00487	88 56 ff	 mov	 BYTE PTR [esi-1], dl
  0048a	46		 inc	 esi
  0048b	8b d0		 mov	 edx, eax
  0048d	c1 ea 08	 shr	 edx, 8
  00490	88 56 ff	 mov	 BYTE PTR [esi-1], dl
  00493	8b d0		 mov	 edx, eax
  00495	88 16		 mov	 BYTE PTR [esi], dl
  00497	46		 inc	 esi
  00498	8b d1		 mov	 edx, ecx
  0049a	8b f8		 mov	 edi, eax
  0049c	0f ac fa 18	 shrd	 edx, edi, 24
  004a0	88 16		 mov	 BYTE PTR [esi], dl
  004a2	c1 ef 18	 shr	 edi, 24			; 00000018H
  004a5	8b d1		 mov	 edx, ecx
  004a7	46		 inc	 esi
  004a8	8b f8		 mov	 edi, eax
  004aa	0f ac fa 10	 shrd	 edx, edi, 16
  004ae	88 16		 mov	 BYTE PTR [esi], dl
  004b0	8b d1		 mov	 edx, ecx
  004b2	0f ac c2 08	 shrd	 edx, eax, 8
  004b6	88 56 01	 mov	 BYTE PTR [esi+1], dl
  004b9	46		 inc	 esi
  004ba	88 4e 01	 mov	 BYTE PTR [esi+1], cl
  004bd	46		 inc	 esi
  004be	c1 e8 08	 shr	 eax, 8

; 847  : 
; 848  : 	// Flags
; 849  : 	cryptoInfo->HeaderFlags = headerFlags;

  004c1	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR _headerFlags$[esp+52]
  004c8	46		 inc	 esi
  004c9	89 85 60 44 00
	00		 mov	 DWORD PTR [ebp+17504], eax

; 850  : 	mputLong (p, headerFlags);

  004cf	8b c8		 mov	 ecx, eax
  004d1	c1 e9 18	 shr	 ecx, 24			; 00000018H
  004d4	88 0e		 mov	 BYTE PTR [esi], cl
  004d6	46		 inc	 esi
  004d7	8b d0		 mov	 edx, eax
  004d9	c1 ea 10	 shr	 edx, 16			; 00000010H
  004dc	88 16		 mov	 BYTE PTR [esi], dl
  004de	46		 inc	 esi
  004df	8b c8		 mov	 ecx, eax
  004e1	c1 e9 08	 shr	 ecx, 8
  004e4	88 0e		 mov	 BYTE PTR [esi], cl
  004e6	46		 inc	 esi
  004e7	88 06		 mov	 BYTE PTR [esi], al

; 851  : 
; 852  : 	// Sector size
; 853  : 	if (sectorSize < TC_MIN_VOLUME_SECTOR_SIZE
; 854  : 		|| sectorSize > TC_MAX_VOLUME_SECTOR_SIZE
; 855  : 		|| sectorSize % ENCRYPTION_DATA_UNIT_SIZE != 0)

  004e9	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR _sectorSize$[esp+52]
  004f0	8d 90 00 fe ff
	ff		 lea	 edx, DWORD PTR [eax-512]
  004f6	c1 ef 10	 shr	 edi, 16			; 00000010H
  004f9	46		 inc	 esi
  004fa	81 fa 00 0e 00
	00		 cmp	 edx, 3584		; 00000e00H
  00500	77 07		 ja	 SHORT $LN33@CreateVolu
  00502	a9 ff 01 00 00	 test	 eax, 511		; 000001ffH
  00507	74 07		 je	 SHORT $LN34@CreateVolu
$LN33@CreateVolu:

; 856  : 	{
; 857  : 		TC_THROW_FATAL_EXCEPTION;

  00509	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
$LN34@CreateVolu:

; 858  : 	}
; 859  : 
; 860  : 	cryptoInfo->SectorSize = sectorSize;

  00510	89 85 40 44 00
	00		 mov	 DWORD PTR [ebp+17472], eax

; 861  : 	mputLong (p, sectorSize);

  00516	8b c8		 mov	 ecx, eax
  00518	c1 e9 18	 shr	 ecx, 24			; 00000018H
  0051b	88 0e		 mov	 BYTE PTR [esi], cl
  0051d	8b d0		 mov	 edx, eax
  0051f	c1 ea 10	 shr	 edx, 16			; 00000010H
  00522	88 56 01	 mov	 BYTE PTR [esi+1], dl

; 862  : 
; 863  : 	// CRC of the header fields
; 864  : 	x = GetCrc32 (header + TC_HEADER_OFFSET_MAGIC, TC_HEADER_OFFSET_HEADER_CRC - TC_HEADER_OFFSET_MAGIC);

  00525	8b 54 24 10	 mov	 edx, DWORD PTR tv918[esp+56]
  00529	46		 inc	 esi
  0052a	8b c8		 mov	 ecx, eax
  0052c	46		 inc	 esi
  0052d	c1 e9 08	 shr	 ecx, 8
  00530	68 bc 00 00 00	 push	 188			; 000000bcH
  00535	88 0e		 mov	 BYTE PTR [esi], cl
  00537	52		 push	 edx
  00538	88 46 01	 mov	 BYTE PTR [esi+1], al
  0053b	e8 00 00 00 00	 call	 _GetCrc32

; 865  : 	p = header + TC_HEADER_OFFSET_HEADER_CRC;
; 866  : 	mputLong (p, x);

  00540	8b d0		 mov	 edx, eax
  00542	c1 fa 18	 sar	 edx, 24			; 00000018H
  00545	88 93 fc 00 00
	00		 mov	 BYTE PTR [ebx+252], dl
  0054b	8d 8b fc 00 00
	00		 lea	 ecx, DWORD PTR [ebx+252]
  00551	41		 inc	 ecx
  00552	8b d0		 mov	 edx, eax
  00554	c1 fa 10	 sar	 edx, 16			; 00000010H
  00557	88 11		 mov	 BYTE PTR [ecx], dl
  00559	41		 inc	 ecx
  0055a	8b d0		 mov	 edx, eax
  0055c	c1 fa 08	 sar	 edx, 8
  0055f	88 11		 mov	 BYTE PTR [ecx], dl
  00561	88 41 01	 mov	 BYTE PTR [ecx+1], al
  00564	83 c4 08	 add	 esp, 8

; 867  : 
; 868  : 	// The master key data
; 869  : 	memcpy (header + HEADER_MASTER_KEYDATA_OFFSET, keyInfo.master_keydata, MASTER_KEYDATA_SIZE);
; 870  : 
; 871  : 
; 872  : 	/* Header encryption */
; 873  : 
; 874  : 	switch (mode)

  00567	83 7c 24 48 02	 cmp	 DWORD PTR _mode$[esp+52], 2
  0056c	8d bb 00 01 00
	00		 lea	 edi, DWORD PTR [ebx+256]
  00572	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00577	be 88 00 00 00	 mov	 esi, OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+136
  0057c	f3 a5		 rep movsd
  0057e	7c 22		 jl	 SHORT $LN29@CreateVolu
  00580	83 7c 24 48 05	 cmp	 DWORD PTR _mode$[esp+52], 5
  00585	7f 1b		 jg	 SHORT $LN29@CreateVolu

; 875  : 	{
; 876  : 	case LRW:
; 877  : 	case CBC:
; 878  : 	case INNER_CBC:
; 879  : 	case OUTER_CBC:
; 880  : 
; 881  : 		// For LRW (deprecated/legacy), the tweak key
; 882  : 		// For CBC (deprecated/legacy), the IV/whitening seed
; 883  : 		memcpy (cryptoInfo->k2, dk, LEGACY_VOL_IV_SIZE);

  00587	8d 9d a8 42 00
	00		 lea	 ebx, DWORD PTR [ebp+17064]
  0058d	b9 08 00 00 00	 mov	 ecx, 8
  00592	be 00 00 00 00	 mov	 esi, OFFSET ?dk@?1??CreateVolumeHeaderInMemory@@9@9
  00597	8b fb		 mov	 edi, ebx
  00599	f3 a5		 rep movsd

; 884  : 		primaryKeyOffset = LEGACY_VOL_IV_SIZE;

  0059b	be 20 00 00 00	 mov	 esi, 32			; 00000020H

; 885  : 		break;

  005a0	eb 30		 jmp	 SHORT $LN31@CreateVolu
$LN29@CreateVolu:

; 886  : 
; 887  : 	default:
; 888  : 		// The secondary key (if cascade, multiple concatenated)
; 889  : 		memcpy (cryptoInfo->k2, dk + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));

  005a2	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  005a5	50		 push	 eax
  005a6	8d 9d a8 42 00
	00		 lea	 ebx, DWORD PTR [ebp+17064]
  005ac	e8 00 00 00 00	 call	 _EAGetKeySize
  005b1	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  005b4	83 c4 04	 add	 esp, 4
  005b7	50		 push	 eax
  005b8	51		 push	 ecx
  005b9	e8 00 00 00 00	 call	 _EAGetKeySize
  005be	83 c4 04	 add	 esp, 4
  005c1	05 00 00 00 00	 add	 eax, OFFSET ?dk@?1??CreateVolumeHeaderInMemory@@9@9
  005c6	50		 push	 eax
  005c7	53		 push	 ebx
  005c8	e8 00 00 00 00	 call	 _memcpy
  005cd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 890  : 		primaryKeyOffset = 0;

  005d0	33 f6		 xor	 esi, esi
$LN31@CreateVolu:

; 891  : 	}
; 892  : 
; 893  : 	retVal = EAInit (cryptoInfo->ea, dk + primaryKeyOffset, cryptoInfo->ks);

  005d2	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  005d5	8d 7d 08	 lea	 edi, DWORD PTR [ebp+8]
  005d8	8d 86 00 00 00
	00		 lea	 eax, DWORD PTR ?dk@?1??CreateVolumeHeaderInMemory@@9@9[esi]
  005de	57		 push	 edi
  005df	50		 push	 eax
  005e0	52		 push	 edx
  005e1	89 44 24 24	 mov	 DWORD PTR tv933[esp+68], eax
  005e5	e8 00 00 00 00	 call	 _EAInit
  005ea	83 c4 0c	 add	 esp, 12			; 0000000cH

; 894  : 	if (retVal != ERR_SUCCESS)

  005ed	85 c0		 test	 eax, eax

; 895  : 		return retVal;

  005ef	0f 85 8c 02 00
	00		 jne	 $LN112@CreateVolu

; 896  : 
; 897  : 	// Mode of operation
; 898  : 	if (!EAInitMode (cryptoInfo))

  005f5	55		 push	 ebp
  005f6	e8 00 00 00 00	 call	 _EAInitMode
  005fb	83 c4 04	 add	 esp, 4
  005fe	85 c0		 test	 eax, eax

; 899  : 		return ERR_OUTOFMEMORY;

  00600	0f 84 94 00 00
	00		 je	 $LN114@CreateVolu

; 900  : 
; 901  : 
; 902  : 	// Encrypt the entire header (except the salt)
; 903  : 	EncryptBuffer (header + HEADER_ENCRYPTED_DATA_OFFSET,
; 904  : 		HEADER_ENCRYPTED_DATA_SIZE,
; 905  : 		cryptoInfo);

  00606	8b 44 24 10	 mov	 eax, DWORD PTR tv918[esp+56]
  0060a	55		 push	 ebp
  0060b	6a 00		 push	 0
  0060d	68 c0 01 00 00	 push	 448			; 000001c0H
  00612	50		 push	 eax
  00613	e8 00 00 00 00	 call	 _EncryptBuffer

; 906  : 
; 907  : 
; 908  : 	/* cryptoInfo setup for further use (disk format) */
; 909  : 
; 910  : 	// Init with the master key(s) 
; 911  : 	retVal = EAInit (cryptoInfo->ea, keyInfo.master_keydata + primaryKeyOffset, cryptoInfo->ks);

  00618	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  0061b	8d 86 88 00 00
	00		 lea	 eax, DWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9[esi+136]
  00621	57		 push	 edi
  00622	50		 push	 eax
  00623	51		 push	 ecx
  00624	89 44 24 3c	 mov	 DWORD PTR tv936[esp+84], eax
  00628	e8 00 00 00 00	 call	 _EAInit
  0062d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 912  : 	if (retVal != ERR_SUCCESS)

  00630	85 c0		 test	 eax, eax

; 913  : 		return retVal;

  00632	0f 85 49 02 00
	00		 jne	 $LN112@CreateVolu

; 914  : 
; 915  : 	memcpy (cryptoInfo->master_keydata, keyInfo.master_keydata, MASTER_KEYDATA_SIZE);
; 916  : 
; 917  : 	switch (cryptoInfo->mode)

  00638	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  0063b	83 c0 fe	 add	 eax, -2			; fffffffeH
  0063e	8d bd a8 41 00
	00		 lea	 edi, DWORD PTR [ebp+16808]
  00644	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00649	be 88 00 00 00	 mov	 esi, OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+136
  0064e	f3 a5		 rep movsd
  00650	83 f8 03	 cmp	 eax, 3
  00653	77 10		 ja	 SHORT $LN22@CreateVolu

; 918  : 	{
; 919  : 	case LRW:
; 920  : 	case CBC:
; 921  : 	case INNER_CBC:
; 922  : 	case OUTER_CBC:
; 923  : 
; 924  : 		// For LRW (deprecated/legacy), the tweak key
; 925  : 		// For CBC (deprecated/legacy), the IV/whitening seed
; 926  : 		memcpy (cryptoInfo->k2, keyInfo.master_keydata, LEGACY_VOL_IV_SIZE);

  00655	b9 08 00 00 00	 mov	 ecx, 8
  0065a	be 88 00 00 00	 mov	 esi, OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+136
  0065f	8b fb		 mov	 edi, ebx
  00661	f3 a5		 rep movsd

; 927  : 		break;

  00663	eb 28		 jmp	 SHORT $LN24@CreateVolu
$LN22@CreateVolu:

; 928  : 
; 929  : 	default:
; 930  : 		// The secondary master key (if cascade, multiple concatenated)
; 931  : 		memcpy (cryptoInfo->k2, keyInfo.master_keydata + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));

  00665	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  00668	52		 push	 edx
  00669	e8 00 00 00 00	 call	 _EAGetKeySize
  0066e	83 c4 04	 add	 esp, 4
  00671	50		 push	 eax
  00672	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  00675	50		 push	 eax
  00676	e8 00 00 00 00	 call	 _EAGetKeySize
  0067b	83 c4 04	 add	 esp, 4
  0067e	05 88 00 00 00	 add	 eax, OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+136
  00683	50		 push	 eax
  00684	53		 push	 ebx
  00685	e8 00 00 00 00	 call	 _memcpy
  0068a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN24@CreateVolu:

; 932  : 	}
; 933  : 
; 934  : 	// Mode of operation
; 935  : 	if (!EAInitMode (cryptoInfo))

  0068d	55		 push	 ebp
  0068e	e8 00 00 00 00	 call	 _EAInitMode
  00693	83 c4 04	 add	 esp, 4
  00696	85 c0		 test	 eax, eax
  00698	75 18		 jne	 SHORT $LN21@CreateVolu
$LN114@CreateVolu:
  0069a	5f		 pop	 edi
  0069b	5e		 pop	 esi
  0069c	5d		 pop	 ebp

; 936  : 		return ERR_OUTOFMEMORY;

  0069d	b8 02 00 00 00	 mov	 eax, 2
  006a2	5b		 pop	 ebx

; 986  : }

  006a3	8b 4c 24 24	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+40]
  006a7	33 cc		 xor	 ecx, esp
  006a9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006ae	83 c4 28	 add	 esp, 40			; 00000028H
  006b1	c3		 ret	 0
$LN21@CreateVolu:

; 937  : 
; 938  : 
; 939  : #ifdef VOLFORMAT
; 940  : 	if (showKeys && !bInPlaceEncNonSys)

  006b2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _showKeys, 0
  006b9	0f 84 6d 01 00
	00		 je	 $LN10@CreateVolu
  006bf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _bInPlaceEncNonSys
  006c5	85 c9		 test	 ecx, ecx
  006c7	0f 85 5f 01 00
	00		 jne	 $LN10@CreateVolu

; 941  : 	{
; 942  : 		BOOL dots3 = FALSE;
; 943  : 		int i, j;
; 944  : 
; 945  : 		j = EAGetKeySize (ea);

  006cd	8b 54 24 44	 mov	 edx, DWORD PTR _ea$[esp+52]
  006d1	52		 push	 edx
  006d2	89 4c 24 18	 mov	 DWORD PTR _dots3$81733[esp+60], ecx
  006d6	e8 00 00 00 00	 call	 _EAGetKeySize
  006db	83 c4 04	 add	 esp, 4

; 946  : 
; 947  : 		if (j > NBR_KEY_BYTES_TO_DISPLAY)

  006de	83 f8 10	 cmp	 eax, 16			; 00000010H
  006e1	89 44 24 10	 mov	 DWORD PTR _j$81735[esp+56], eax
  006e5	7e 10		 jle	 SHORT $LN19@CreateVolu

; 948  : 		{
; 949  : 			dots3 = TRUE;

  006e7	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR _dots3$81733[esp+56], 1

; 950  : 			j = NBR_KEY_BYTES_TO_DISPLAY;

  006ef	c7 44 24 10 10
	00 00 00	 mov	 DWORD PTR _j$81735[esp+56], 16 ; 00000010H
$LN19@CreateVolu:

; 951  : 		}
; 952  : 
; 953  : 		MasterKeyGUIView[0] = 0;
; 954  : 		for (i = 0; i < j; i++)

  006f7	33 db		 xor	 ebx, ebx
  006f9	39 5c 24 10	 cmp	 DWORD PTR _j$81735[esp+56], ebx
  006fd	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _MasterKeyGUIView, 0
  00704	7e 6d		 jle	 SHORT $LN16@CreateVolu
  00706	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL18@CreateVolu:

; 955  : 		{
; 956  : 			char tmp2[8] = {0};

  00710	33 c0		 xor	 eax, eax
  00712	89 44 24 25	 mov	 DWORD PTR _tmp2$81740[esp+57], eax
  00716	66 89 44 24 29	 mov	 WORD PTR _tmp2$81740[esp+61], ax
  0071b	88 44 24 2b	 mov	 BYTE PTR _tmp2$81740[esp+63], al

; 957  : 			sprintf (tmp2, "%02X", (int) (unsigned char) keyInfo.master_keydata[i + primaryKeyOffset]);

  0071f	8b 44 24 20	 mov	 eax, DWORD PTR tv936[esp+56]
  00723	0f b6 0c 18	 movzx	 ecx, BYTE PTR [eax+ebx]
  00727	51		 push	 ecx
  00728	8d 54 24 28	 lea	 edx, DWORD PTR _tmp2$81740[esp+60]
  0072c	68 00 00 00 00	 push	 OFFSET ??_C@_04JFFKLGJF@?$CF02X?$AA@
  00731	52		 push	 edx
  00732	c6 44 24 30 00	 mov	 BYTE PTR _tmp2$81740[esp+68], 0
  00737	e8 00 00 00 00	 call	 _sprintf

; 958  : 			strcat (MasterKeyGUIView, tmp2);

  0073c	8d 44 24 30	 lea	 eax, DWORD PTR _tmp2$81740[esp+68]
  00740	83 c4 0c	 add	 esp, 12			; 0000000cH
  00743	8b c8		 mov	 ecx, eax
$LL101@CreateVolu:
  00745	8a 10		 mov	 dl, BYTE PTR [eax]
  00747	40		 inc	 eax
  00748	84 d2		 test	 dl, dl
  0074a	75 f9		 jne	 SHORT $LL101@CreateVolu
  0074c	bf 00 00 00 00	 mov	 edi, OFFSET _MasterKeyGUIView
  00751	2b c1		 sub	 eax, ecx
  00753	8b f1		 mov	 esi, ecx
  00755	4f		 dec	 edi
$LL102@CreateVolu:
  00756	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00759	47		 inc	 edi
  0075a	84 c9		 test	 cl, cl
  0075c	75 f8		 jne	 SHORT $LL102@CreateVolu
  0075e	8b c8		 mov	 ecx, eax
  00760	c1 e9 02	 shr	 ecx, 2
  00763	f3 a5		 rep movsd
  00765	8b c8		 mov	 ecx, eax
  00767	83 e1 03	 and	 ecx, 3
  0076a	43		 inc	 ebx
  0076b	3b 5c 24 10	 cmp	 ebx, DWORD PTR _j$81735[esp+56]
  0076f	f3 a4		 rep movsb
  00771	7c 9d		 jl	 SHORT $LL18@CreateVolu
$LN16@CreateVolu:

; 959  : 		}
; 960  : 
; 961  : 		HeaderKeyGUIView[0] = 0;

  00773	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _HeaderKeyGUIView, 0

; 962  : 		for (i = 0; i < NBR_KEY_BYTES_TO_DISPLAY; i++)

  0077a	33 db		 xor	 ebx, ebx
  0077c	8d 64 24 00	 npad	 4
$LL15@CreateVolu:

; 963  : 		{
; 964  : 			char tmp2[8];
; 965  : 			sprintf (tmp2, "%02X", (int) (unsigned char) dk[primaryKeyOffset + i]);

  00780	8b 44 24 18	 mov	 eax, DWORD PTR tv933[esp+56]
  00784	0f b6 0c 18	 movzx	 ecx, BYTE PTR [eax+ebx]
  00788	51		 push	 ecx
  00789	8d 54 24 30	 lea	 edx, DWORD PTR _tmp2$81747[esp+60]
  0078d	68 00 00 00 00	 push	 OFFSET ??_C@_04JFFKLGJF@?$CF02X?$AA@
  00792	52		 push	 edx
  00793	e8 00 00 00 00	 call	 _sprintf

; 966  : 			strcat (HeaderKeyGUIView, tmp2);

  00798	8d 44 24 38	 lea	 eax, DWORD PTR _tmp2$81747[esp+68]
  0079c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0079f	8b c8		 mov	 ecx, eax
$LL103@CreateVolu:
  007a1	8a 10		 mov	 dl, BYTE PTR [eax]
  007a3	40		 inc	 eax
  007a4	84 d2		 test	 dl, dl
  007a6	75 f9		 jne	 SHORT $LL103@CreateVolu
  007a8	bf 00 00 00 00	 mov	 edi, OFFSET _HeaderKeyGUIView
  007ad	2b c1		 sub	 eax, ecx
  007af	8b f1		 mov	 esi, ecx
  007b1	4f		 dec	 edi
$LL104@CreateVolu:
  007b2	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  007b5	47		 inc	 edi
  007b6	84 c9		 test	 cl, cl
  007b8	75 f8		 jne	 SHORT $LL104@CreateVolu
  007ba	8b c8		 mov	 ecx, eax
  007bc	c1 e9 02	 shr	 ecx, 2
  007bf	f3 a5		 rep movsd
  007c1	8b c8		 mov	 ecx, eax
  007c3	83 e1 03	 and	 ecx, 3
  007c6	43		 inc	 ebx
  007c7	83 fb 10	 cmp	 ebx, 16			; 00000010H
  007ca	f3 a4		 rep movsb
  007cc	7c b2		 jl	 SHORT $LL15@CreateVolu

; 967  : 		}
; 968  : 
; 969  : 		if (dots3)

  007ce	83 7c 24 14 00	 cmp	 DWORD PTR _dots3$81733[esp+56], 0
  007d3	74 2e		 je	 SHORT $LN12@CreateVolu

; 970  : 		{
; 971  : 			DisplayPortionsOfKeys (hHeaderKey, hMasterKey, HeaderKeyGUIView, MasterKeyGUIView, !showKeys);

  007d5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hMasterKey
  007db	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hHeaderKey
  007e1	33 c0		 xor	 eax, eax
  007e3	39 05 00 00 00
	00		 cmp	 DWORD PTR _showKeys, eax
  007e9	0f 94 c0	 sete	 al
  007ec	50		 push	 eax
  007ed	68 00 00 00 00	 push	 OFFSET _MasterKeyGUIView
  007f2	68 00 00 00 00	 push	 OFFSET _HeaderKeyGUIView
  007f7	51		 push	 ecx
  007f8	52		 push	 edx
  007f9	e8 00 00 00 00	 call	 _DisplayPortionsOfKeys
  007fe	83 c4 14	 add	 esp, 20			; 00000014H

; 972  : 		}
; 973  : 		else

  00801	eb 29		 jmp	 SHORT $LN10@CreateVolu
$LN12@CreateVolu:

; 974  : 		{
; 975  : 			SendMessage (hMasterKey, WM_SETTEXT, 0, (LPARAM) MasterKeyGUIView);

  00803	a1 00 00 00 00	 mov	 eax, DWORD PTR _hMasterKey
  00808	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  0080e	68 00 00 00 00	 push	 OFFSET _MasterKeyGUIView
  00813	6a 00		 push	 0
  00815	6a 0c		 push	 12			; 0000000cH
  00817	50		 push	 eax
  00818	ff d6		 call	 esi

; 976  : 			SendMessage (hHeaderKey, WM_SETTEXT, 0, (LPARAM) HeaderKeyGUIView);

  0081a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hHeaderKey
  00820	68 00 00 00 00	 push	 OFFSET _HeaderKeyGUIView
  00825	6a 00		 push	 0
  00827	6a 0c		 push	 12			; 0000000cH
  00829	51		 push	 ecx
  0082a	ff d6		 call	 esi
$LN10@CreateVolu:

; 977  : 		}
; 978  : 	}
; 979  : #endif	// #ifdef VOLFORMAT
; 980  : 
; 981  : 	burn (dk, sizeof(dk));

  0082c	ba 00 00 00 00	 mov	 edx, OFFSET ?dk@?1??CreateVolumeHeaderInMemory@@9@9
  00831	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00836	8b f1		 mov	 esi, ecx
  00838	8b c2		 mov	 eax, edx
  0083a	8d 9b 00 00 00
	00		 npad	 6
$LL70@CreateVolu:
  00840	c6 00 00	 mov	 BYTE PTR [eax], 0
  00843	40		 inc	 eax
  00844	83 ee 01	 sub	 esi, 1
  00847	75 f7		 jne	 SHORT $LL70@CreateVolu
  00849	8d a4 24 00 00
	00 00		 npad	 7
$LL7@CreateVolu:
  00850	49		 dec	 ecx
  00851	c6 02 00	 mov	 BYTE PTR [edx], 0
  00854	42		 inc	 edx
  00855	85 c9		 test	 ecx, ecx
  00857	75 f7		 jne	 SHORT $LL7@CreateVolu

; 982  : 	burn (&keyInfo, sizeof (keyInfo));

  00859	ba 00 00 00 00	 mov	 edx, OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9
  0085e	b9 88 01 00 00	 mov	 ecx, 392		; 00000188H
  00863	8b f1		 mov	 esi, ecx
  00865	8b c2		 mov	 eax, edx
$LL74@CreateVolu:
  00867	c6 00 00	 mov	 BYTE PTR [eax], 0
  0086a	40		 inc	 eax
  0086b	83 ee 01	 sub	 esi, 1
  0086e	75 f7		 jne	 SHORT $LL74@CreateVolu
$LL2@CreateVolu:
  00870	49		 dec	 ecx
  00871	c6 02 00	 mov	 BYTE PTR [edx], 0
  00874	42		 inc	 edx
  00875	85 c9		 test	 ecx, ecx
  00877	75 f7		 jne	 SHORT $LL2@CreateVolu

; 983  : 
; 984  : 	*retInfo = cryptoInfo;

  00879	8b 54 24 1c	 mov	 edx, DWORD PTR _retInfo$GSCopy$[esp+56]
  0087d	89 2a		 mov	 DWORD PTR [edx], ebp

; 985  : 	return 0;

  0087f	33 c0		 xor	 eax, eax
$LN112@CreateVolu:

; 986  : }

  00881	8b 4c 24 34	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+56]
  00885	5f		 pop	 edi
  00886	5e		 pop	 esi
  00887	5d		 pop	 ebp
  00888	5b		 pop	 ebx
  00889	33 cc		 xor	 ecx, esp
  0088b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00890	83 c4 28	 add	 esp, 40			; 00000028H
  00893	c3		 ret	 0
$LN116@CreateVolu:
  00894	00 00 00 00	 DD	 $LN43@CreateVolu
  00898	00 00 00 00	 DD	 $LN45@CreateVolu
  0089c	00 00 00 00	 DD	 $LN42@CreateVolu
  008a0	00 00 00 00	 DD	 $LN44@CreateVolu
$LN117@CreateVolu:
  008a4	00 00 00 00	 DD	 $LN38@CreateVolu
  008a8	00 00 00 00	 DD	 $LN36@CreateVolu
  008ac	00 00 00 00	 DD	 $LN37@CreateVolu
  008b0	00 00 00 00	 DD	 $LN37@CreateVolu
_CreateVolumeHeaderInMemory ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_ReadEffectiveVolumeHeader
EXTRN	__imp__SetLastError@4:PROC
EXTRN	__imp__DeviceIoControl@32:PROC
EXTRN	__imp__ReadFile@20:PROC
EXTRN	__chkstk:PROC
; Function compile flags: /Ogtpy
;	COMDAT _ReadEffectiveVolumeHeader
_TEXT	SEGMENT
_geometry$ = -4124					; size = 24
_sectorBuffer$ = -4100					; size = 4096
__$ArrayPad$ = -4					; size = 4
_device$ = 8						; size = 4
_fileHandle$ = 12					; size = 4
_header$ = 16						; size = 4
_bytesRead$ = 20					; size = 4
_ReadEffectiveVolumeHeader PROC				; COMDAT

; 990  : {

  00000	b8 1c 10 00 00	 mov	 eax, 4124		; 0000101cH
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000f	33 c4		 xor	 eax, esp
  00011	89 84 24 18 10
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+4124], eax

; 991  : #if TC_VOLUME_HEADER_EFFECTIVE_SIZE > TC_MAX_VOLUME_SECTOR_SIZE
; 992  : #error TC_VOLUME_HEADER_EFFECTIVE_SIZE > TC_MAX_VOLUME_SECTOR_SIZE
; 993  : #endif
; 994  : 
; 995  : 	byte sectorBuffer[TC_MAX_VOLUME_SECTOR_SIZE];
; 996  : 	DISK_GEOMETRY geometry;
; 997  : 
; 998  : 	if (!device)

  00018	83 bc 24 20 10
	00 00 00	 cmp	 DWORD PTR _device$[esp+4120], 0
  00020	53		 push	 ebx
  00021	8b 9c 24 2c 10
	00 00		 mov	 ebx, DWORD PTR _header$[esp+4124]
  00028	56		 push	 esi
  00029	8b b4 24 34 10
	00 00		 mov	 esi, DWORD PTR _bytesRead$[esp+4128]
  00030	57		 push	 edi
  00031	8b bc 24 30 10
	00 00		 mov	 edi, DWORD PTR _fileHandle$[esp+4132]

; 999  : 		return ReadFile (fileHandle, header, TC_VOLUME_HEADER_EFFECTIVE_SIZE, bytesRead, NULL);

  00038	6a 00		 push	 0
  0003a	56		 push	 esi
  0003b	75 25		 jne	 SHORT $LN6@ReadEffect
  0003d	68 00 02 00 00	 push	 512			; 00000200H
  00042	53		 push	 ebx
  00043	57		 push	 edi
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx

; 1019 : }

  0004d	8b 8c 24 18 10
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+4124]
  00054	33 cc		 xor	 ecx, esp
  00056	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005b	81 c4 1c 10 00
	00		 add	 esp, 4124		; 0000101cH
  00061	c3		 ret	 0
$LN6@ReadEffect:

; 1000 : 
; 1001 : 	if (!DeviceIoControl (fileHandle, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &geometry, sizeof (geometry), bytesRead, NULL))

  00062	6a 18		 push	 24			; 00000018H
  00064	8d 44 24 18	 lea	 eax, DWORD PTR _geometry$[esp+4148]
  00068	50		 push	 eax
  00069	6a 00		 push	 0
  0006b	6a 00		 push	 0
  0006d	68 00 00 07 00	 push	 458752			; 00070000H
  00072	57		 push	 edi
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  00079	85 c0		 test	 eax, eax

; 1002 : 		return FALSE;

  0007b	74 76		 je	 SHORT $LN13@ReadEffect

; 1003 : 
; 1004 : 	if (geometry.BytesPerSector > sizeof (sectorBuffer) || geometry.BytesPerSector < TC_MIN_VOLUME_SECTOR_SIZE)

  0007d	8b 44 24 20	 mov	 eax, DWORD PTR _geometry$[esp+4156]
  00081	8d 88 00 fe ff
	ff		 lea	 ecx, DWORD PTR [eax-512]
  00087	81 f9 00 0e 00
	00		 cmp	 ecx, 3584		; 00000e00H
  0008d	77 5c		 ja	 SHORT $LN3@ReadEffect

; 1007 : 		return FALSE;
; 1008 : 	}
; 1009 : 
; 1010 : 	if (!ReadFile (fileHandle, sectorBuffer, max (TC_VOLUME_HEADER_EFFECTIVE_SIZE, geometry.BytesPerSector), bytesRead, NULL))

  0008f	6a 00		 push	 0
  00091	56		 push	 esi
  00092	50		 push	 eax
  00093	8d 54 24 30	 lea	 edx, DWORD PTR _sectorBuffer$[esp+4148]
  00097	52		 push	 edx
  00098	57		 push	 edi
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20
  0009f	85 c0		 test	 eax, eax

; 1011 : 		return FALSE;

  000a1	74 50		 je	 SHORT $LN13@ReadEffect

; 1012 : 
; 1013 : 	memcpy (header, sectorBuffer, min (*bytesRead, TC_VOLUME_HEADER_EFFECTIVE_SIZE));

  000a3	8b 06		 mov	 eax, DWORD PTR [esi]
  000a5	3d 00 02 00 00	 cmp	 eax, 512		; 00000200H
  000aa	72 05		 jb	 SHORT $LN12@ReadEffect
  000ac	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
$LN12@ReadEffect:
  000b1	50		 push	 eax
  000b2	8d 44 24 28	 lea	 eax, DWORD PTR _sectorBuffer$[esp+4140]
  000b6	50		 push	 eax
  000b7	53		 push	 ebx
  000b8	e8 00 00 00 00	 call	 _memcpy
  000bd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1014 : 	
; 1015 : 	if (*bytesRead > TC_VOLUME_HEADER_EFFECTIVE_SIZE)

  000c0	81 3e 00 02 00
	00		 cmp	 DWORD PTR [esi], 512	; 00000200H
  000c6	76 06		 jbe	 SHORT $LN1@ReadEffect

; 1016 : 		*bytesRead = TC_VOLUME_HEADER_EFFECTIVE_SIZE;

  000c8	c7 06 00 02 00
	00		 mov	 DWORD PTR [esi], 512	; 00000200H
$LN1@ReadEffect:
  000ce	5f		 pop	 edi
  000cf	5e		 pop	 esi

; 1017 : 
; 1018 : 	return TRUE;

  000d0	b8 01 00 00 00	 mov	 eax, 1
  000d5	5b		 pop	 ebx

; 1019 : }

  000d6	8b 8c 24 18 10
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+4124]
  000dd	33 cc		 xor	 ecx, esp
  000df	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e4	81 c4 1c 10 00
	00		 add	 esp, 4124		; 0000101cH
  000ea	c3		 ret	 0
$LN3@ReadEffect:

; 1005 : 	{
; 1006 : 		SetLastError (ERROR_INVALID_PARAMETER);

  000eb	6a 57		 push	 87			; 00000057H
  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
$LN13@ReadEffect:

; 1019 : }

  000f3	8b 8c 24 24 10
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+4136]
  000fa	5f		 pop	 edi
  000fb	5e		 pop	 esi
  000fc	5b		 pop	 ebx
  000fd	33 cc		 xor	 ecx, esp
  000ff	33 c0		 xor	 eax, eax
  00101	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00106	81 c4 1c 10 00
	00		 add	 esp, 4124		; 0000101cH
  0010c	c3		 ret	 0
_ReadEffectiveVolumeHeader ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_WriteEffectiveVolumeHeader
EXTRN	__imp__SetFilePointerEx@20:PROC
EXTRN	__imp__WriteFile@20:PROC
; Function compile flags: /Ogtpy
;	COMDAT _WriteEffectiveVolumeHeader
_TEXT	SEGMENT
_bytesDone$ = -4132					; size = 4
_geometry$ = -4128					; size = 24
_sectorBuffer$ = -4104					; size = 4096
__$ArrayPad$ = -4					; size = 4
_device$ = 8						; size = 4
_fileHandle$ = 12					; size = 4
_header$ = 16						; size = 4
_WriteEffectiveVolumeHeader PROC			; COMDAT

; 1023 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	b8 24 10 00 00	 mov	 eax, 4132		; 00001024H
  0000b	e8 00 00 00 00	 call	 __chkstk
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	89 84 24 20 10
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+4132], eax

; 1024 : #if TC_VOLUME_HEADER_EFFECTIVE_SIZE > TC_MAX_VOLUME_SECTOR_SIZE
; 1025 : #error TC_VOLUME_HEADER_EFFECTIVE_SIZE > TC_MAX_VOLUME_SECTOR_SIZE
; 1026 : #endif
; 1027 : 
; 1028 : 	byte sectorBuffer[TC_MAX_VOLUME_SECTOR_SIZE];
; 1029 : 	DWORD bytesDone;
; 1030 : 	DISK_GEOMETRY geometry;
; 1031 : 
; 1032 : 	if (!device)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _device$[ebp], 0
  00022	53		 push	 ebx
  00023	8b 5d 0c	 mov	 ebx, DWORD PTR _fileHandle$[ebp]
  00026	56		 push	 esi
  00027	8b 75 10	 mov	 esi, DWORD PTR _header$[ebp]
  0002a	57		 push	 edi

; 1033 : 	{
; 1034 : 		if (!WriteFile (fileHandle, header, TC_VOLUME_HEADER_EFFECTIVE_SIZE, &bytesDone, NULL))

  0002b	6a 00		 push	 0
  0002d	75 42		 jne	 SHORT $LN12@WriteEffec
  0002f	8d 44 24 10	 lea	 eax, DWORD PTR _bytesDone$[esp+4148]
  00033	50		 push	 eax
  00034	68 00 02 00 00	 push	 512			; 00000200H
  00039	56		 push	 esi
  0003a	53		 push	 ebx
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  00041	85 c0		 test	 eax, eax

; 1035 : 			return FALSE;

  00043	0f 84 f2 00 00
	00		 je	 $LN16@WriteEffec

; 1036 : 
; 1037 : 		if (bytesDone != TC_VOLUME_HEADER_EFFECTIVE_SIZE)

  00049	81 7c 24 0c 00
	02 00 00	 cmp	 DWORD PTR _bytesDone$[esp+4144], 512 ; 00000200H

; 1038 : 		{
; 1039 : 			SetLastError (ERROR_INVALID_PARAMETER);
; 1040 : 			return FALSE;

  00051	0f 85 dc 00 00
	00		 jne	 $LN7@WriteEffec

; 1041 : 		}
; 1042 : 
; 1043 : 		return TRUE;

  00057	b8 01 00 00 00	 mov	 eax, 1

; 1085 : }

  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	8b 8c 24 20 10
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+4132]
  00066	33 cc		 xor	 ecx, esp
  00068	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
$LN12@WriteEffec:

; 1044 : 	}
; 1045 : 
; 1046 : 	if (!DeviceIoControl (fileHandle, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &geometry, sizeof (geometry), &bytesDone, NULL))

  00071	8d 4c 24 10	 lea	 ecx, DWORD PTR _bytesDone$[esp+4148]
  00075	51		 push	 ecx
  00076	6a 18		 push	 24			; 00000018H
  00078	8d 54 24 1c	 lea	 edx, DWORD PTR _geometry$[esp+4156]
  0007c	52		 push	 edx
  0007d	6a 00		 push	 0
  0007f	6a 00		 push	 0
  00081	68 00 00 07 00	 push	 458752			; 00070000H
  00086	53		 push	 ebx
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  0008d	85 c0		 test	 eax, eax

; 1047 : 		return FALSE;

  0008f	0f 84 a6 00 00
	00		 je	 $LN16@WriteEffec

; 1048 : 
; 1049 : 	if (geometry.BytesPerSector > sizeof (sectorBuffer) || geometry.BytesPerSector < TC_MIN_VOLUME_SECTOR_SIZE)

  00095	8b 44 24 24	 mov	 eax, DWORD PTR _geometry$[esp+4164]
  00099	8d 88 00 fe ff
	ff		 lea	 ecx, DWORD PTR [eax-512]
  0009f	81 f9 00 0e 00
	00		 cmp	 ecx, 3584		; 00000e00H
  000a5	0f 87 88 00 00
	00		 ja	 $LN7@WriteEffec

; 1052 : 		return FALSE;
; 1053 : 	}
; 1054 : 
; 1055 : 	if (geometry.BytesPerSector != TC_VOLUME_HEADER_EFFECTIVE_SIZE)

  000ab	3d 00 02 00 00	 cmp	 eax, 512		; 00000200H
  000b0	74 3a		 je	 SHORT $LN3@WriteEffec

; 1056 : 	{
; 1057 : 		LARGE_INTEGER seekOffset;
; 1058 : 
; 1059 : 		if (!ReadFile (fileHandle, sectorBuffer, geometry.BytesPerSector, &bytesDone, NULL))

  000b2	6a 00		 push	 0
  000b4	8d 54 24 10	 lea	 edx, DWORD PTR _bytesDone$[esp+4148]
  000b8	52		 push	 edx
  000b9	50		 push	 eax
  000ba	8d 44 24 34	 lea	 eax, DWORD PTR _sectorBuffer$[esp+4156]
  000be	50		 push	 eax
  000bf	53		 push	 ebx
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20
  000c6	85 c0		 test	 eax, eax

; 1060 : 			return FALSE;

  000c8	74 71		 je	 SHORT $LN16@WriteEffec

; 1061 : 
; 1062 : 		if (bytesDone != geometry.BytesPerSector)

  000ca	8b 44 24 0c	 mov	 eax, DWORD PTR _bytesDone$[esp+4144]
  000ce	3b 44 24 24	 cmp	 eax, DWORD PTR _geometry$[esp+4164]

; 1063 : 		{
; 1064 : 			SetLastError (ERROR_INVALID_PARAMETER);
; 1065 : 			return FALSE;

  000d2	75 5f		 jne	 SHORT $LN7@WriteEffec

; 1066 : 		}
; 1067 : 
; 1068 : 		seekOffset.QuadPart = -(int) bytesDone;
; 1069 : 		if (!SetFilePointerEx (fileHandle, seekOffset, NULL, FILE_CURRENT))

  000d4	6a 01		 push	 1
  000d6	f7 d8		 neg	 eax
  000d8	99		 cdq
  000d9	6a 00		 push	 0
  000db	52		 push	 edx
  000dc	50		 push	 eax
  000dd	53		 push	 ebx
  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  000e4	85 c0		 test	 eax, eax

; 1070 : 			return FALSE;

  000e6	74 53		 je	 SHORT $LN16@WriteEffec
  000e8	8b 44 24 24	 mov	 eax, DWORD PTR _geometry$[esp+4164]
$LN3@WriteEffec:

; 1071 : 	}
; 1072 : 
; 1073 : 	memcpy (sectorBuffer, header, TC_VOLUME_HEADER_EFFECTIVE_SIZE);
; 1074 : 
; 1075 : 	if (!WriteFile (fileHandle, sectorBuffer, geometry.BytesPerSector, &bytesDone, NULL))

  000ec	6a 00		 push	 0
  000ee	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  000f3	8d 7c 24 2c	 lea	 edi, DWORD PTR _sectorBuffer$[esp+4148]
  000f7	f3 a5		 rep movsd
  000f9	8d 4c 24 10	 lea	 ecx, DWORD PTR _bytesDone$[esp+4148]
  000fd	51		 push	 ecx
  000fe	50		 push	 eax
  000ff	8d 54 24 34	 lea	 edx, DWORD PTR _sectorBuffer$[esp+4156]
  00103	52		 push	 edx
  00104	53		 push	 ebx
  00105	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  0010b	85 c0		 test	 eax, eax

; 1076 : 		return FALSE;

  0010d	74 2c		 je	 SHORT $LN16@WriteEffec

; 1077 : 
; 1078 : 	if (bytesDone != geometry.BytesPerSector)

  0010f	8b 44 24 0c	 mov	 eax, DWORD PTR _bytesDone$[esp+4144]
  00113	3b 44 24 24	 cmp	 eax, DWORD PTR _geometry$[esp+4164]

; 1079 : 	{
; 1080 : 		SetLastError (ERROR_INVALID_PARAMETER);
; 1081 : 		return FALSE;

  00117	75 1a		 jne	 SHORT $LN7@WriteEffec

; 1082 : 	}
; 1083 : 
; 1084 : 	return TRUE;

  00119	b8 01 00 00 00	 mov	 eax, 1

; 1085 : }

  0011e	5f		 pop	 edi
  0011f	5e		 pop	 esi
  00120	5b		 pop	 ebx
  00121	8b 8c 24 20 10
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+4132]
  00128	33 cc		 xor	 ecx, esp
  0012a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012f	8b e5		 mov	 esp, ebp
  00131	5d		 pop	 ebp
  00132	c3		 ret	 0
$LN7@WriteEffec:

; 1050 : 	{
; 1051 : 		SetLastError (ERROR_INVALID_PARAMETER);

  00133	6a 57		 push	 87			; 00000057H
  00135	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
$LN16@WriteEffec:

; 1085 : }

  0013b	8b 8c 24 2c 10
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+4144]
  00142	5f		 pop	 edi
  00143	5e		 pop	 esi
  00144	5b		 pop	 ebx
  00145	33 cc		 xor	 ecx, esp
  00147	33 c0		 xor	 eax, eax
  00149	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014e	8b e5		 mov	 esp, ebp
  00150	5d		 pop	 ebp
  00151	c3		 ret	 0
_WriteEffectiveVolumeHeader ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_WriteRandomDataToReservedHeaderAreas
EXTRN	__imp__GetLastError@0:PROC
; Function compile flags: /Ogtpy
;	COMDAT _WriteRandomDataToReservedHeaderAreas
_TEXT	SEGMENT
_bytesDone$ = -131596					; size = 4
_backupHeaders$ = -131592				; size = 4
_temporaryKey$ = -131588				; size = 256
_originalK2$ = -131332					; size = 256
_buf$ = -131076						; size = 131072
__$ArrayPad$ = -4					; size = 4
_dev$ = 8						; size = 4
_cryptoInfo$ = 12					; size = 4
_dataAreaSize$ = 16					; size = 8
_bPrimaryOnly$ = 24					; size = 4
_bBackupOnly$ = 28					; size = 4
_WriteRandomDataToReservedHeaderAreas PROC		; COMDAT

; 1092 : {

  00000	b8 0c 02 02 00	 mov	 eax, 131596		; 0002020cH
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000f	33 c4		 xor	 eax, esp
  00011	89 84 24 08 02
	02 00		 mov	 DWORD PTR __$ArrayPad$[esp+131596], eax

; 1093 : 	char temporaryKey[MASTER_KEYDATA_SIZE];
; 1094 : 	char originalK2[MASTER_KEYDATA_SIZE];
; 1095 : 
; 1096 : 	byte buf[TC_VOLUME_HEADER_GROUP_SIZE];
; 1097 : 
; 1098 : 	LARGE_INTEGER offset;
; 1099 : 	int nStatus = ERR_SUCCESS;
; 1100 : 	DWORD dwError;
; 1101 : 	DWORD bytesDone;
; 1102 : 	BOOL backupHeaders = bBackupOnly;
; 1103 : 
; 1104 : 	if (bPrimaryOnly && bBackupOnly)

  00018	83 bc 24 20 02
	02 00 00	 cmp	 DWORD PTR _bPrimaryOnly$[esp+131592], 0
  00020	8b 84 24 24 02
	02 00		 mov	 eax, DWORD PTR _bBackupOnly$[esp+131592]
  00027	53		 push	 ebx
  00028	8b 9c 24 18 02
	02 00		 mov	 ebx, DWORD PTR _cryptoInfo$[esp+131596]
  0002f	55		 push	 ebp
  00030	8b ac 24 18 02
	02 00		 mov	 ebp, DWORD PTR _dev$[esp+131600]
  00037	56		 push	 esi
  00038	57		 push	 edi
  00039	89 44 24 14	 mov	 DWORD PTR _backupHeaders$[esp+131612], eax
  0003d	74 0b		 je	 SHORT $LN28@WriteRando
  0003f	85 c0		 test	 eax, eax
  00041	74 07		 je	 SHORT $LN28@WriteRando

; 1105 : 		TC_THROW_FATAL_EXCEPTION;

  00043	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
$LN28@WriteRando:

; 1106 : 
; 1107 : 	memcpy (originalK2, cryptoInfo->k2, sizeof (cryptoInfo->k2));
; 1108 : 
; 1109 : 	while (TRUE)
; 1110 : 	{
; 1111 : 		// Temporary keys
; 1112 : 		if (!RandgetBytes (temporaryKey, EAGetKeySize (cryptoInfo->ea), FALSE)
; 1113 : 			|| !RandgetBytes (cryptoInfo->k2, sizeof (cryptoInfo->k2), FALSE))

  0004a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0004c	6a 00		 push	 0
  0004e	8d b3 a8 42 00
	00		 lea	 esi, DWORD PTR [ebx+17064]
  00054	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00059	8d bc 24 1c 01
	00 00		 lea	 edi, DWORD PTR _originalK2$[esp+131616]
  00060	50		 push	 eax
  00061	f3 a5		 rep movsd
  00063	e8 00 00 00 00	 call	 _EAGetKeySize
  00068	83 c4 04	 add	 esp, 4
  0006b	50		 push	 eax
  0006c	8d 4c 24 20	 lea	 ecx, DWORD PTR _temporaryKey$[esp+131620]
  00070	51		 push	 ecx
  00071	e8 00 00 00 00	 call	 _RandgetBytes
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
  00079	85 c0		 test	 eax, eax
  0007b	0f 84 54 01 00
	00		 je	 $LN24@WriteRando
$LL27@WriteRando:
  00081	6a 00		 push	 0
  00083	8d 83 a8 42 00
	00		 lea	 eax, DWORD PTR [ebx+17064]
  00089	68 00 01 00 00	 push	 256			; 00000100H
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 _RandgetBytes
  00094	83 c4 0c	 add	 esp, 12			; 0000000cH
  00097	85 c0		 test	 eax, eax
  00099	0f 84 36 01 00
	00		 je	 $LN24@WriteRando

; 1116 : 			goto final_seq;
; 1117 : 		}
; 1118 : 
; 1119 : 		nStatus = EAInit (cryptoInfo->ea, temporaryKey, cryptoInfo->ks);

  0009f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000a1	8d 53 08	 lea	 edx, DWORD PTR [ebx+8]
  000a4	52		 push	 edx
  000a5	8d 44 24 1c	 lea	 eax, DWORD PTR _temporaryKey$[esp+131616]
  000a9	50		 push	 eax
  000aa	51		 push	 ecx
  000ab	e8 00 00 00 00	 call	 _EAInit
  000b0	8b f0		 mov	 esi, eax
  000b2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1120 : 		if (nStatus != ERR_SUCCESS)

  000b5	85 f6		 test	 esi, esi
  000b7	0f 85 1d 01 00
	00		 jne	 $final_seq$81849

; 1121 : 			goto final_seq;
; 1122 : 
; 1123 : 		if (!EAInitMode (cryptoInfo))

  000bd	53		 push	 ebx
  000be	e8 00 00 00 00	 call	 _EAInitMode
  000c3	83 c4 04	 add	 esp, 4
  000c6	85 c0		 test	 eax, eax
  000c8	0f 84 e8 01 00
	00		 je	 $LN48@WriteRando

; 1124 : 		{
; 1125 : 			nStatus = ERR_MODE_INIT_FAILED;
; 1126 : 			goto final_seq;
; 1127 : 		}
; 1128 : 
; 1129 : 		offset.QuadPart = backupHeaders ? dataAreaSize + TC_VOLUME_HEADER_GROUP_SIZE : TC_VOLUME_HEADER_OFFSET;

  000ce	39 74 24 14	 cmp	 DWORD PTR _backupHeaders$[esp+131612], esi
  000d2	74 19		 je	 SHORT $LN31@WriteRando
  000d4	8b b4 24 28 02
	02 00		 mov	 esi, DWORD PTR _dataAreaSize$[esp+131608]
  000db	8b bc 24 2c 02
	02 00		 mov	 edi, DWORD PTR _dataAreaSize$[esp+131612]
  000e2	81 c6 00 00 02
	00		 add	 esi, 131072		; 00020000H
  000e8	83 d7 00	 adc	 edi, 0
  000eb	eb 04		 jmp	 SHORT $LN32@WriteRando
$LN31@WriteRando:
  000ed	33 f6		 xor	 esi, esi
  000ef	33 ff		 xor	 edi, edi
$LN32@WriteRando:

; 1130 : 
; 1131 : 		if (!SetFilePointerEx (dev, offset, NULL, FILE_BEGIN))

  000f1	6a 00		 push	 0
  000f3	6a 00		 push	 0
  000f5	57		 push	 edi
  000f6	56		 push	 esi
  000f7	55		 push	 ebp
  000f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  000fe	85 c0		 test	 eax, eax
  00100	0f 84 61 01 00
	00		 je	 $LN49@WriteRando

; 1132 : 		{
; 1133 : 			nStatus = ERR_OS_ERROR;
; 1134 : 			goto final_seq;
; 1135 : 		}
; 1136 : 
; 1137 : 		if (!ReadFile (dev, buf, sizeof (buf), &bytesDone, NULL))

  00106	6a 00		 push	 0
  00108	8d 54 24 14	 lea	 edx, DWORD PTR _bytesDone$[esp+131616]
  0010c	52		 push	 edx
  0010d	68 00 00 02 00	 push	 131072			; 00020000H
  00112	8d 84 24 24 02
	00 00		 lea	 eax, DWORD PTR _buf$[esp+131624]
  00119	50		 push	 eax
  0011a	55		 push	 ebp
  0011b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20
  00121	85 c0		 test	 eax, eax
  00123	0f 84 3e 01 00
	00		 je	 $LN49@WriteRando

; 1138 : 		{
; 1139 : 			nStatus = ERR_OS_ERROR;
; 1140 : 			goto final_seq;
; 1141 : 		}
; 1142 : 
; 1143 : 		if (bytesDone < TC_VOLUME_HEADER_EFFECTIVE_SIZE)

  00129	81 7c 24 10 00
	02 00 00	 cmp	 DWORD PTR _bytesDone$[esp+131612], 512 ; 00000200H
  00131	0f 82 28 01 00
	00		 jb	 $LN51@WriteRando

; 1148 : 		}
; 1149 : 
; 1150 : 		EncryptBuffer (buf + TC_VOLUME_HEADER_EFFECTIVE_SIZE, sizeof (buf) - TC_VOLUME_HEADER_EFFECTIVE_SIZE, cryptoInfo);

  00137	53		 push	 ebx
  00138	6a 00		 push	 0
  0013a	8d 8c 24 20 04
	00 00		 lea	 ecx, DWORD PTR _buf$[esp+132132]
  00141	68 00 fe 01 00	 push	 130560			; 0001fe00H
  00146	51		 push	 ecx
  00147	e8 00 00 00 00	 call	 _EncryptBuffer
  0014c	83 c4 10	 add	 esp, 16			; 00000010H

; 1151 : 
; 1152 : 		if (!SetFilePointerEx (dev, offset, NULL, FILE_BEGIN))

  0014f	6a 00		 push	 0
  00151	6a 00		 push	 0
  00153	57		 push	 edi
  00154	56		 push	 esi
  00155	55		 push	 ebp
  00156	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  0015c	85 c0		 test	 eax, eax
  0015e	0f 84 03 01 00
	00		 je	 $LN49@WriteRando

; 1153 : 		{
; 1154 : 			nStatus = ERR_OS_ERROR;
; 1155 : 			goto final_seq;
; 1156 : 		}
; 1157 : 
; 1158 : 		if (!WriteFile (dev, buf, sizeof (buf), &bytesDone, NULL))

  00164	6a 00		 push	 0
  00166	8d 54 24 14	 lea	 edx, DWORD PTR _bytesDone$[esp+131616]
  0016a	52		 push	 edx
  0016b	68 00 00 02 00	 push	 131072			; 00020000H
  00170	8d 84 24 24 02
	00 00		 lea	 eax, DWORD PTR _buf$[esp+131624]
  00177	50		 push	 eax
  00178	55		 push	 ebp
  00179	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  0017f	85 c0		 test	 eax, eax
  00181	0f 84 e0 00 00
	00		 je	 $LN49@WriteRando

; 1159 : 		{
; 1160 : 			nStatus = ERR_OS_ERROR;
; 1161 : 			goto final_seq;
; 1162 : 		}
; 1163 : 
; 1164 : 		if (bytesDone != sizeof (buf))

  00187	81 7c 24 10 00
	00 02 00	 cmp	 DWORD PTR _bytesDone$[esp+131612], 131072 ; 00020000H
  0018f	75 44		 jne	 SHORT $LN24@WriteRando

; 1165 : 		{
; 1166 : 			nStatus = ERR_PARAMETER_INCORRECT;
; 1167 : 			goto final_seq;
; 1168 : 		}
; 1169 : 
; 1170 : 		if (backupHeaders || bPrimaryOnly)

  00191	83 7c 24 14 00	 cmp	 DWORD PTR _backupHeaders$[esp+131612], 0
  00196	0f 85 d5 00 00
	00		 jne	 $LN55@WriteRando
  0019c	83 bc 24 30 02
	02 00 00	 cmp	 DWORD PTR _bPrimaryOnly$[esp+131608], 0
  001a4	0f 85 c7 00 00
	00		 jne	 $LN55@WriteRando
  001aa	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  001ac	6a 00		 push	 0
  001ae	51		 push	 ecx

; 1171 : 			break;
; 1172 : 
; 1173 : 		backupHeaders = TRUE;

  001af	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR _backupHeaders$[esp+131620], 1
  001b7	e8 00 00 00 00	 call	 _EAGetKeySize
  001bc	83 c4 04	 add	 esp, 4
  001bf	50		 push	 eax
  001c0	8d 54 24 20	 lea	 edx, DWORD PTR _temporaryKey$[esp+131620]
  001c4	52		 push	 edx
  001c5	e8 00 00 00 00	 call	 _RandgetBytes
  001ca	83 c4 0c	 add	 esp, 12			; 0000000cH
  001cd	85 c0		 test	 eax, eax
  001cf	0f 85 ac fe ff
	ff		 jne	 $LL27@WriteRando
$LN24@WriteRando:

; 1114 : 		{
; 1115 : 			nStatus = ERR_PARAMETER_INCORRECT; 

  001d5	be 1e 00 00 00	 mov	 esi, 30			; 0000001eH
$final_seq$81849:

; 1186 : 	}
; 1187 : 
; 1188 : final_seq:
; 1189 : 
; 1190 : 	dwError = GetLastError();

  001da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 1191 : 
; 1192 : 	burn (temporaryKey, sizeof (temporaryKey));

  001e0	8d 7c 24 18	 lea	 edi, DWORD PTR _temporaryKey$[esp+131612]
  001e4	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  001e9	8b da		 mov	 ebx, edx
  001eb	8b cf		 mov	 ecx, edi
  001ed	8d 49 00	 npad	 3
$LL34@WriteRando:
  001f0	c6 01 00	 mov	 BYTE PTR [ecx], 0
  001f3	41		 inc	 ecx
  001f4	83 eb 01	 sub	 ebx, 1
  001f7	75 f7		 jne	 SHORT $LL34@WriteRando
  001f9	8d a4 24 00 00
	00 00		 npad	 7
$LL8@WriteRando:
  00200	4a		 dec	 edx
  00201	c6 07 00	 mov	 BYTE PTR [edi], 0
  00204	47		 inc	 edi
  00205	85 d2		 test	 edx, edx
  00207	75 f7		 jne	 SHORT $LL8@WriteRando

; 1193 : 	burn (originalK2, sizeof (originalK2));

  00209	8d bc 24 18 01
	00 00		 lea	 edi, DWORD PTR _originalK2$[esp+131612]
  00210	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00215	8b da		 mov	 ebx, edx
  00217	8b cf		 mov	 ecx, edi
  00219	8d a4 24 00 00
	00 00		 npad	 7
$LL38@WriteRando:
  00220	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00223	41		 inc	 ecx
  00224	83 eb 01	 sub	 ebx, 1
  00227	75 f7		 jne	 SHORT $LL38@WriteRando
  00229	8d a4 24 00 00
	00 00		 npad	 7
$LL3@WriteRando:
  00230	4a		 dec	 edx
  00231	c6 07 00	 mov	 BYTE PTR [edi], 0
  00234	47		 inc	 edi
  00235	85 d2		 test	 edx, edx
  00237	75 f7		 jne	 SHORT $LL3@WriteRando

; 1194 : 
; 1195 : 	if (nStatus != ERR_SUCCESS)

  00239	85 f6		 test	 esi, esi
  0023b	74 07		 je	 SHORT $LN71@WriteRando

; 1196 : 		SetLastError (dwError);

  0023d	50		 push	 eax
  0023e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
$LN71@WriteRando:

; 1197 : 
; 1198 : 	return nStatus;
; 1199 : }

  00244	8b 8c 24 18 02
	02 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+131612]
  0024b	5f		 pop	 edi
  0024c	8b c6		 mov	 eax, esi
  0024e	5e		 pop	 esi
  0024f	5d		 pop	 ebp
  00250	5b		 pop	 ebx
  00251	33 cc		 xor	 ecx, esp
  00253	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00258	81 c4 0c 02 02
	00		 add	 esp, 131596		; 0002020cH
  0025e	c3		 ret	 0
$LN51@WriteRando:

; 1144 : 		{
; 1145 : 			SetLastError (ERROR_INVALID_PARAMETER);

  0025f	6a 57		 push	 87			; 00000057H
  00261	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
$LN49@WriteRando:

; 1146 : 			nStatus = ERR_OS_ERROR;

  00267	be 01 00 00 00	 mov	 esi, 1

; 1147 : 			goto final_seq;

  0026c	e9 69 ff ff ff	 jmp	 $final_seq$81849
$LN55@WriteRando:

; 1174 : 	}
; 1175 : 
; 1176 : 	memcpy (cryptoInfo->k2, originalK2, sizeof (cryptoInfo->k2));
; 1177 : 
; 1178 : 	nStatus = EAInit (cryptoInfo->ea, cryptoInfo->master_keydata, cryptoInfo->ks);

  00271	8b 13		 mov	 edx, DWORD PTR [ebx]
  00273	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00278	8d b4 24 18 01
	00 00		 lea	 esi, DWORD PTR _originalK2$[esp+131612]
  0027f	8d bb a8 42 00
	00		 lea	 edi, DWORD PTR [ebx+17064]
  00285	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  00288	f3 a5		 rep movsd
  0028a	50		 push	 eax
  0028b	8d 8b a8 41 00
	00		 lea	 ecx, DWORD PTR [ebx+16808]
  00291	51		 push	 ecx
  00292	52		 push	 edx
  00293	e8 00 00 00 00	 call	 _EAInit
  00298	8b f0		 mov	 esi, eax
  0029a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1179 : 	if (nStatus != ERR_SUCCESS)

  0029d	85 f6		 test	 esi, esi
  0029f	0f 85 35 ff ff
	ff		 jne	 $final_seq$81849

; 1180 : 		goto final_seq;
; 1181 : 
; 1182 : 	if (!EAInitMode (cryptoInfo))

  002a5	53		 push	 ebx
  002a6	e8 00 00 00 00	 call	 _EAInitMode
  002ab	83 c4 04	 add	 esp, 4
  002ae	85 c0		 test	 eax, eax
  002b0	0f 85 24 ff ff
	ff		 jne	 $final_seq$81849
$LN48@WriteRando:

; 1183 : 	{
; 1184 : 		nStatus = ERR_MODE_INIT_FAILED;

  002b6	be 1b 00 00 00	 mov	 esi, 27			; 0000001bH

; 1185 : 		goto final_seq;

  002bb	e9 1a ff ff ff	 jmp	 $final_seq$81849
_WriteRandomDataToReservedHeaderAreas ENDP
_TEXT	ENDS
END
