; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\home\public\desktop\projects\ciphershed.build\src\common\crypto.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_05HJMENKNE@SHA?91?$AA@			; `string'
PUBLIC	??_C@_09HLDHDDJL@Whirlpool?$AA@			; `string'
PUBLIC	??_C@_07MEOJAOJE@SHA?9512?$AA@			; `string'
PUBLIC	??_C@_0L@PKFJAMAA@RIPEMD?9160?$AA@		; `string'
PUBLIC	??_C@_0L@NEGMAKNF@Triple?5DES?$AA@		; `string'
PUBLIC	??_C@_05LCFOLDPB@CAST5?$AA@			; `string'
PUBLIC	??_C@_08KOMAHJJD@Blowfish?$AA@			; `string'
PUBLIC	??_C@_07DABDIDEC@Twofish?$AA@			; `string'
PUBLIC	??_C@_07CCCAKGBN@Serpent?$AA@			; `string'
PUBLIC	??_C@_03BKNEFOAH@AES?$AA@			; `string'
_BSS	SEGMENT
_HwEncryptionDisabled DD 01H DUP (?)
?state@?1??IsAesHwCpuSupported@@9@9 DD 01H DUP (?)	; `IsAesHwCpuSupported'::`2'::state
?stateValid@?1??IsAesHwCpuSupported@@9@9 DD 01H DUP (?)	; `IsAesHwCpuSupported'::`2'::stateValid
_BSS	ENDS
;	COMDAT ??_C@_05HJMENKNE@SHA?91?$AA@
CONST	SEGMENT
??_C@_05HJMENKNE@SHA?91?$AA@ DB 'SHA-1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HLDHDDJL@Whirlpool?$AA@
CONST	SEGMENT
??_C@_09HLDHDDJL@Whirlpool?$AA@ DB 'Whirlpool', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07MEOJAOJE@SHA?9512?$AA@
CONST	SEGMENT
??_C@_07MEOJAOJE@SHA?9512?$AA@ DB 'SHA-512', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PKFJAMAA@RIPEMD?9160?$AA@
CONST	SEGMENT
??_C@_0L@PKFJAMAA@RIPEMD?9160?$AA@ DB 'RIPEMD-160', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
_Ciphers DD	01H
	DD	FLAT:??_C@_03BKNEFOAH@AES?$AA@
	DD	010H
	DD	020H
	DD	01e8H
	DD	02H
	DD	FLAT:??_C@_07CCCAKGBN@Serpent?$AA@
	DD	010H
	DD	020H
	DD	0230H
	DD	03H
	DD	FLAT:??_C@_07DABDIDEC@Twofish?$AA@
	DD	010H
	DD	020H
	DD	010b4H
	DD	04H
	DD	FLAT:??_C@_08KOMAHJJD@Blowfish?$AA@
	DD	08H
	DD	038H
	DD	01090H
	DD	05H
	DD	FLAT:??_C@_05LCFOLDPB@CAST5?$AA@
	DD	08H
	DD	010H
	DD	080H
	DD	06H
	DD	FLAT:??_C@_0L@NEGMAKNF@Triple?5DES?$AA@
	DD	08H
	DD	018H
	DD	0300H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
_EncryptionAlgorithms DD 00H
	DD	00H
	ORG $+8
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+8
	DD	00H
	DD	01H
	DD	00H
	ORG $+8
	DD	01H
	DD	02H
	DD	03H
	DD	00H
	ORG $+8
	DD	01H
	DD	02H
	DD	00H
	ORG $+8
	DD	01H
	DD	02H
	DD	03H
	DD	00H
	ORG $+8
	DD	01H
	DD	03H
	DD	00H
	ORG $+8
	DD	01H
	DD	02H
	DD	03H
	DD	00H
	ORG $+8
	DD	01H
	DD	03H
	DD	01H
	DD	00H
	ORG $+4
	DD	01H
	DD	02H
	DD	04H
	DD	00H
	ORG $+8
	DD	01H
	DD	02H
	DD	03H
	DD	01H
	DD	00H
	DD	01H
	DD	02H
	DD	04H
	DD	00H
	ORG $+8
	DD	01H
	DD	01H
	DD	02H
	DD	00H
	ORG $+4
	DD	01H
	DD	02H
	DD	04H
	DD	00H
	ORG $+8
	DD	01H
	DD	01H
	DD	03H
	DD	02H
	DD	00H
	DD	01H
	DD	02H
	DD	04H
	DD	00H
	ORG $+8
	DD	01H
	DD	02H
	DD	03H
	DD	00H
	ORG $+4
	DD	01H
	DD	02H
	DD	04H
	DD	00H
	ORG $+8
	DD	01H
	DD	04H
	DD	00H
	ORG $+8
	DD	02H
	DD	03H
	DD	00H
	DD	00H
	ORG $+8
	DD	00H
	DD	05H
	DD	00H
	ORG $+8
	DD	02H
	DD	03H
	DD	00H
	DD	00H
	ORG $+8
	DD	00H
	DD	06H
	DD	00H
	ORG $+8
	DD	02H
	DD	03H
	DD	00H
	DD	00H
	ORG $+8
	DD	00H
	DD	04H
	DD	01H
	DD	00H
	ORG $+4
	DD	05H
	DD	00H
	DD	00H
	DD	00H
	ORG $+8
	DD	00H
	DD	02H
	DD	04H
	DD	01H
	DD	00H
	DD	05H
	DD	00H
	DD	00H
	DD	00H
	ORG $+8
	DD	00H
	DD	00H
	DD	00H
	ORG $+8
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+8
	DD	00H
	ORG $+4
_Hashes	DD	01H
	DD	FLAT:??_C@_0L@PKFJAMAA@RIPEMD?9160?$AA@
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:??_C@_07MEOJAOJE@SHA?9512?$AA@
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:??_C@_09HLDHDDJL@Whirlpool?$AA@
	DD	00H
	DD	00H
	DD	04H
	DD	FLAT:??_C@_05HJMENKNE@SHA?91?$AA@
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
_DATA	ENDS
;	COMDAT ??_C@_0L@NEGMAKNF@Triple?5DES?$AA@
CONST	SEGMENT
??_C@_0L@NEGMAKNF@Triple?5DES?$AA@ DB 'Triple DES', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05LCFOLDPB@CAST5?$AA@
CONST	SEGMENT
??_C@_05LCFOLDPB@CAST5?$AA@ DB 'CAST5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KOMAHJJD@Blowfish?$AA@
CONST	SEGMENT
??_C@_08KOMAHJJD@Blowfish?$AA@ DB 'Blowfish', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07DABDIDEC@Twofish?$AA@
CONST	SEGMENT
??_C@_07DABDIDEC@Twofish?$AA@ DB 'Twofish', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CCCAKGBN@Serpent?$AA@
CONST	SEGMENT
??_C@_07CCCAKGBN@Serpent?$AA@ DB 'Serpent', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BKNEFOAH@AES?$AA@
CONST	SEGMENT
??_C@_03BKNEFOAH@AES?$AA@ DB 'AES', 00H			; `string'
CONST	ENDS
PUBLIC	_RtlSecureZeroMemory@8
; Function compile flags: /Ogsp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
;	COMDAT _RtlSecureZeroMemory@8
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory@8 PROC				; COMDAT

; 8322 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 8323 :     volatile char *vptr = (volatile char *)ptr;
; 8324 : 
; 8325 : #if defined(_M_AMD64)
; 8326 : 
; 8327 :         __stosb((PUCHAR)((ULONG64)vptr), 0, cnt);
; 8328 : 
; 8329 : #else
; 8330 : 
; 8331 :     while (cnt) {

  00005	83 7d 0c 00	 cmp	 DWORD PTR _cnt$[ebp], 0
  00009	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  0000c	74 09		 je	 SHORT $LN1@RtlSecureZ
$LL2@RtlSecureZ:

; 8332 :         *vptr = 0;

  0000e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 8333 :         vptr++;

  00011	40		 inc	 eax

; 8334 :         cnt--;

  00012	ff 4d 0c	 dec	 DWORD PTR _cnt$[ebp]
  00015	75 f7		 jne	 SHORT $LL2@RtlSecureZ
$LN1@RtlSecureZ:

; 8335 :     }
; 8336 : 
; 8337 : #endif
; 8338 : 
; 8339 :     return ptr;

  00017	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]

; 8340 : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
_RtlSecureZeroMemory@8 ENDP
_TEXT	ENDS
PUBLIC	_EncipherBlock@12
EXTRN	_aes_encrypt@12:PROC
EXTRN	_serpent_encrypt@12:PROC
EXTRN	_twofish_encrypt@12:PROC
EXTRN	_BlowfishEncryptLE@16:PROC
EXTRN	_Cast5Encrypt@12:PROC
EXTRN	_TripleDesEncrypt@16:PROC
EXTRN	__imp__KeBugCheckEx@20:PROC
; Function compile flags: /Ogsp
; File c:\home\public\desktop\projects\ciphershed.build\src\common\crypto.c
;	COMDAT _EncipherBlock@12
_TEXT	SEGMENT
_cipher$ = 8						; size = 4
_data$ = 12						; size = 4
_ks$ = 16						; size = 4
_EncipherBlock@12 PROC					; COMDAT

; 176  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 177  : 	switch (cipher)

  00005	8b 45 08	 mov	 eax, DWORD PTR _cipher$[ebp]
  00008	48		 dec	 eax
  00009	74 79		 je	 SHORT $LN7@EncipherBl
  0000b	48		 dec	 eax
  0000c	74 66		 je	 SHORT $LN5@EncipherBl
  0000e	48		 dec	 eax
  0000f	74 53		 je	 SHORT $LN6@EncipherBl
  00011	48		 dec	 eax
  00012	74 3e		 je	 SHORT $LN4@EncipherBl
  00014	48		 dec	 eax
  00015	74 2b		 je	 SHORT $LN3@EncipherBl
  00017	48		 dec	 eax
  00018	74 16		 je	 SHORT $LN2@EncipherBl

; 195  : #endif
; 196  : 	default:			TC_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID

  0001a	68 43 54 00 00	 push	 21571			; 00005443H
  0001f	6a 00		 push	 0
  00021	6a 00		 push	 0
  00023	68 c4 00 00 00	 push	 196			; 000000c4H
  00028	6a 29		 push	 41			; 00000029H
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN13@EncipherBl:
$LN2@EncipherBl:

; 194  : 	case TRIPLEDES:		TripleDesEncrypt (data, data, ks, 1); break;	// Deprecated/legacy

  00030	6a 01		 push	 1
  00032	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  00035	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  00038	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  0003b	e8 00 00 00 00	 call	 _TripleDesEncrypt@16
  00040	eb 50		 jmp	 SHORT $LN8@EncipherBl
$LN3@EncipherBl:

; 193  : 	case CAST:			Cast5Encrypt (data, data, ks); break;			// Deprecated/legacy

  00042	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  00045	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  00048	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  0004b	e8 00 00 00 00	 call	 _Cast5Encrypt@12
  00050	eb 40		 jmp	 SHORT $LN8@EncipherBl
$LN4@EncipherBl:

; 191  : #ifndef TC_WINDOWS_BOOT
; 192  : 	case BLOWFISH:		BlowfishEncryptLE (data, data, ks, 1); break;	// Deprecated/legacy

  00052	6a 01		 push	 1
  00054	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  00057	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  0005a	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  0005d	e8 00 00 00 00	 call	 _BlowfishEncryptLE@16
  00062	eb 2e		 jmp	 SHORT $LN8@EncipherBl
$LN6@EncipherBl:

; 187  : 		break;
; 188  : 
; 189  : 	case TWOFISH:		twofish_encrypt (ks, data, data); break;

  00064	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  00067	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  0006a	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  0006d	e8 00 00 00 00	 call	 _twofish_encrypt@12
  00072	eb 1e		 jmp	 SHORT $LN8@EncipherBl
$LN5@EncipherBl:

; 190  : 	case SERPENT:		serpent_encrypt (data, data, ks); break;

  00074	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  00077	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  0007a	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  0007d	e8 00 00 00 00	 call	 _serpent_encrypt@12
  00082	eb 0e		 jmp	 SHORT $LN8@EncipherBl
$LN7@EncipherBl:

; 178  : 	{
; 179  : 	case AES:	
; 180  : 		// In 32-bit kernel mode, due to KeSaveFloatingPointState() overhead, AES instructions can be used only when processing the whole data unit.
; 181  : #if (defined (_WIN64) || !defined (TC_WINDOWS_DRIVER)) && !defined (TC_WINDOWS_BOOT)
; 182  : 		if (IsAesHwCpuSupported())
; 183  : 			aes_hw_cpu_encrypt (ks, data);
; 184  : 		else
; 185  : #endif
; 186  : 			aes_encrypt (data, data, ks);

  00084	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  00087	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  0008a	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  0008d	e8 00 00 00 00	 call	 _aes_encrypt@12
$LN8@EncipherBl:

; 197  : 	}
; 198  : }

  00092	5d		 pop	 ebp
  00093	c2 0c 00	 ret	 12			; 0000000cH
$LN12@EncipherBl:
_EncipherBlock@12 ENDP
_TEXT	ENDS
PUBLIC	_DecipherBlock@12
EXTRN	_aes_decrypt@12:PROC
EXTRN	_serpent_decrypt@12:PROC
EXTRN	_twofish_decrypt@12:PROC
EXTRN	_Cast5Decrypt@12:PROC
; Function compile flags: /Ogsp
;	COMDAT _DecipherBlock@12
_TEXT	SEGMENT
_cipher$ = 8						; size = 4
_data$ = 12						; size = 4
_ks$ = 16						; size = 4
_DecipherBlock@12 PROC					; COMDAT

; 243  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 244  : 	switch (cipher)

  00005	8b 45 08	 mov	 eax, DWORD PTR _cipher$[ebp]
  00008	48		 dec	 eax
  00009	74 79		 je	 SHORT $LN5@DecipherBl
  0000b	48		 dec	 eax
  0000c	74 66		 je	 SHORT $LN7@DecipherBl
  0000e	48		 dec	 eax
  0000f	74 53		 je	 SHORT $LN6@DecipherBl
  00011	48		 dec	 eax
  00012	74 3e		 je	 SHORT $LN4@DecipherBl
  00014	48		 dec	 eax
  00015	74 2b		 je	 SHORT $LN3@DecipherBl
  00017	48		 dec	 eax
  00018	74 16		 je	 SHORT $LN2@DecipherBl

; 262  : #else
; 263  : 	case AES:		aes_decrypt (data, data, ks); break;
; 264  : #endif
; 265  : 	default:		TC_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID

  0001a	68 43 54 00 00	 push	 21571			; 00005443H
  0001f	6a 00		 push	 0
  00021	6a 00		 push	 0
  00023	68 09 01 00 00	 push	 265			; 00000109H
  00028	6a 29		 push	 41			; 00000029H
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN13@DecipherBl:
$LN2@DecipherBl:

; 261  : 	case TRIPLEDES:	TripleDesEncrypt (data, data, ks, 0); break;	// Deprecated/legacy

  00030	6a 00		 push	 0
  00032	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  00035	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  00038	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  0003b	e8 00 00 00 00	 call	 _TripleDesEncrypt@16
  00040	eb 56		 jmp	 SHORT $LN8@DecipherBl
$LN3@DecipherBl:

; 260  : 	case CAST:		Cast5Decrypt (data, data, ks); break;			// Deprecated/legacy

  00042	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  00045	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  00048	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  0004b	e8 00 00 00 00	 call	 _Cast5Decrypt@12
  00050	eb 46		 jmp	 SHORT $LN8@DecipherBl
$LN4@DecipherBl:

; 257  : 		break;
; 258  : 
; 259  : 	case BLOWFISH:	BlowfishEncryptLE (data, data, ks, 0); break;	// Deprecated/legacy

  00052	6a 00		 push	 0
  00054	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  00057	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  0005a	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  0005d	e8 00 00 00 00	 call	 _BlowfishEncryptLE@16
  00062	eb 34		 jmp	 SHORT $LN8@DecipherBl
$LN6@DecipherBl:

; 247  : 	case TWOFISH:	twofish_decrypt (ks, data, data); break;

  00064	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  00067	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  0006a	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  0006d	e8 00 00 00 00	 call	 _twofish_decrypt@12
  00072	eb 24		 jmp	 SHORT $LN8@DecipherBl
$LN7@DecipherBl:

; 245  : 	{
; 246  : 	case SERPENT:	serpent_decrypt (data, data, ks); break;

  00074	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  00077	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  0007a	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  0007d	e8 00 00 00 00	 call	 _serpent_decrypt@12
  00082	eb 14		 jmp	 SHORT $LN8@DecipherBl
$LN5@DecipherBl:

; 248  : #ifndef TC_WINDOWS_BOOT
; 249  : 
; 250  : 	case AES:
; 251  : #if defined (_WIN64) || !defined (TC_WINDOWS_DRIVER)
; 252  : 		if (IsAesHwCpuSupported())
; 253  : 			aes_hw_cpu_decrypt ((byte *) ks + sizeof (aes_encrypt_ctx), data);
; 254  : 		else
; 255  : #endif
; 256  : 			aes_decrypt (data, data, (void *) ((char *) ks + sizeof(aes_encrypt_ctx)));

  00084	8b 45 10	 mov	 eax, DWORD PTR _ks$[ebp]
  00087	05 f4 00 00 00	 add	 eax, 244		; 000000f4H
  0008c	50		 push	 eax
  0008d	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  00090	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  00093	e8 00 00 00 00	 call	 _aes_decrypt@12
$LN8@DecipherBl:

; 266  : 	}
; 267  : }

  00098	5d		 pop	 ebp
  00099	c2 0c 00	 ret	 12			; 0000000cH
$LN12@DecipherBl:
_DecipherBlock@12 ENDP
_TEXT	ENDS
PUBLIC	_CipherGet@4
; Function compile flags: /Ogsp
;	COMDAT _CipherGet@4
_TEXT	SEGMENT
_id$ = 8						; size = 4
_CipherGet@4 PROC					; COMDAT

; 315  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 316  : 	int i;
; 317  : 	for (i = 0; Ciphers[i].Id != 0; i++)

  00005	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Ciphers
  0000b	33 c0		 xor	 eax, eax
  0000d	eb 11		 jmp	 SHORT $LN10@CipherGet
$LL4@CipherGet:

; 318  : 		if (Ciphers[i].Id == id)

  0000f	3b 4d 08	 cmp	 ecx, DWORD PTR _id$[ebp]
  00012	74 16		 je	 SHORT $LN8@CipherGet
  00014	40		 inc	 eax
  00015	8b c8		 mov	 ecx, eax
  00017	6b c9 14	 imul	 ecx, 20			; 00000014H
  0001a	8b 89 00 00 00
	00		 mov	 ecx, DWORD PTR _Ciphers[ecx]
$LN10@CipherGet:

; 316  : 	int i;
; 317  : 	for (i = 0; Ciphers[i].Id != 0; i++)

  00020	85 c9		 test	 ecx, ecx
  00022	75 eb		 jne	 SHORT $LL4@CipherGet

; 320  : 
; 321  : 	return NULL;

  00024	33 c0		 xor	 eax, eax
$LN5@CipherGet:

; 322  : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN8@CipherGet:

; 319  : 			return &Ciphers[i];

  0002a	6b c0 14	 imul	 eax, 20			; 00000014H
  0002d	05 00 00 00 00	 add	 eax, OFFSET _Ciphers
  00032	eb f2		 jmp	 SHORT $LN5@CipherGet
_CipherGet@4 ENDP
_TEXT	ENDS
PUBLIC	_CipherGetName@4
; Function compile flags: /Ogsp
;	COMDAT _CipherGetName@4
_TEXT	SEGMENT
_cipherId$ = 8						; size = 4
_CipherGetName@4 PROC					; COMDAT

; 325  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 326  : 	return CipherGet (cipherId) -> Name;

  00005	ff 75 08	 push	 DWORD PTR _cipherId$[ebp]
  00008	e8 00 00 00 00	 call	 _CipherGet@4
  0000d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 327  : }

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
_CipherGetName@4 ENDP
_TEXT	ENDS
PUBLIC	_CipherGetBlockSize@4
; Function compile flags: /Ogsp
;	COMDAT _CipherGetBlockSize@4
_TEXT	SEGMENT
_cipherId$ = 8						; size = 4
_CipherGetBlockSize@4 PROC				; COMDAT

; 330  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 331  : 	return CipherGet (cipherId) -> BlockSize;

  00005	ff 75 08	 push	 DWORD PTR _cipherId$[ebp]
  00008	e8 00 00 00 00	 call	 _CipherGet@4
  0000d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 332  : }

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
_CipherGetBlockSize@4 ENDP
_TEXT	ENDS
PUBLIC	_CipherGetKeySize@4
; Function compile flags: /Ogsp
;	COMDAT _CipherGetKeySize@4
_TEXT	SEGMENT
_cipherId$ = 8						; size = 4
_CipherGetKeySize@4 PROC				; COMDAT

; 335  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 336  : 	return CipherGet (cipherId) -> KeySize;

  00005	ff 75 08	 push	 DWORD PTR _cipherId$[ebp]
  00008	e8 00 00 00 00	 call	 _CipherGet@4
  0000d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 337  : }

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
_CipherGetKeySize@4 ENDP
_TEXT	ENDS
PUBLIC	_CipherGetKeyScheduleSize@4
; Function compile flags: /Ogsp
;	COMDAT _CipherGetKeyScheduleSize@4
_TEXT	SEGMENT
_cipherId$ = 8						; size = 4
_CipherGetKeyScheduleSize@4 PROC			; COMDAT

; 340  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 341  : 	return CipherGet (cipherId) -> KeyScheduleSize;

  00005	ff 75 08	 push	 DWORD PTR _cipherId$[ebp]
  00008	e8 00 00 00 00	 call	 _CipherGet@4
  0000d	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 342  : }

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
_CipherGetKeyScheduleSize@4 ENDP
_TEXT	ENDS
PUBLIC	_EAGetFirst@0
; Function compile flags: /Ogsp
;	COMDAT _EAGetFirst@0
_TEXT	SEGMENT
_EAGetFirst@0 PROC					; COMDAT

; 358  : 	return 1;

  00000	33 c0		 xor	 eax, eax
  00002	40		 inc	 eax

; 359  : }

  00003	c3		 ret	 0
_EAGetFirst@0 ENDP
_TEXT	ENDS
PUBLIC	_EAGetNext@4
; Function compile flags: /Ogsp
;	COMDAT _EAGetNext@4
_TEXT	SEGMENT
_previousEA$ = 8					; size = 4
_EAGetNext@4 PROC					; COMDAT

; 374  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 375  : 	int id = previousEA + 1;

  00005	8b 4d 08	 mov	 ecx, DWORD PTR _previousEA$[ebp]
  00008	41		 inc	 ecx

; 376  : 	if (EncryptionAlgorithms[id].Ciphers[0] != 0) return id;

  00009	8b c1		 mov	 eax, ecx
  0000b	6b c0 2c	 imul	 eax, 44			; 0000002cH
  0000e	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax]
  00014	f7 d8		 neg	 eax
  00016	1b c0		 sbb	 eax, eax
  00018	23 c1		 and	 eax, ecx

; 377  : 	return 0;
; 378  : }

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
_EAGetNext@4 ENDP
_TEXT	ENDS
PUBLIC	_EAGetFirstMode@4
; Function compile flags: /Ogsp
;	COMDAT _EAGetFirstMode@4
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_EAGetFirstMode@4 PROC					; COMDAT

; 507  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 508  : 	return (EncryptionAlgorithms[ea].Modes[0]);

  00005	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00008	6b c0 2c	 imul	 eax, 44			; 0000002cH
  0000b	8b 80 10 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax+16]

; 509  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
_EAGetFirstMode@4 ENDP
_TEXT	ENDS
PUBLIC	_EAGetNextMode@8
; Function compile flags: /Ogsp
;	COMDAT _EAGetNextMode@8
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_previousModeId$ = 12					; size = 4
_EAGetNextMode@8 PROC					; COMDAT

; 513  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 514  : 	int c, i = 0;
; 515  : 	while (c = EncryptionAlgorithms[ea].Modes[i++])

  00005	8b 55 08	 mov	 edx, DWORD PTR _ea$[ebp]
  00008	8b c2		 mov	 eax, edx
  0000a	6b c0 0b	 imul	 eax, 11			; 0000000bH
  0000d	8b 0c 85 10 00
	00 00		 mov	 ecx, DWORD PTR _EncryptionAlgorithms[eax*4+16]
  00014	56		 push	 esi
  00015	33 f6		 xor	 esi, esi
  00017	85 c9		 test	 ecx, ecx
  00019	74 18		 je	 SHORT $LN8@EAGetNextM
  0001b	6b d2 2c	 imul	 edx, 44			; 0000002cH
  0001e	81 c2 10 00 00
	00		 add	 edx, OFFSET _EncryptionAlgorithms+16
$LL3@EAGetNextM:
  00024	46		 inc	 esi
  00025	83 c2 04	 add	 edx, 4

; 516  : 	{
; 517  : 		if (c == previousModeId) 

  00028	3b 4d 0c	 cmp	 ecx, DWORD PTR _previousModeId$[ebp]
  0002b	74 0d		 je	 SHORT $LN7@EAGetNextM
  0002d	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0002f	85 c9		 test	 ecx, ecx
  00031	75 f1		 jne	 SHORT $LL3@EAGetNextM
$LN8@EAGetNextM:

; 519  : 	}
; 520  : 
; 521  : 	return 0;

  00033	33 c0		 xor	 eax, eax
$LN4@EAGetNextM:
  00035	5e		 pop	 esi

; 522  : }

  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
$LN7@EAGetNextM:

; 518  : 			return EncryptionAlgorithms[ea].Modes[i];

  0003a	03 c6		 add	 eax, esi
  0003c	8b 04 85 10 00
	00 00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax*4+16]
  00043	eb f0		 jmp	 SHORT $LN4@EAGetNextM
_EAGetNextMode@8 ENDP
_TEXT	ENDS
PUBLIC	_EAGetCipherCount@4
; Function compile flags: /Ogsp
;	COMDAT _EAGetCipherCount@4
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_EAGetCipherCount@4 PROC				; COMDAT

; 623  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 624  : 	int i = 0;

  00005	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00008	6b c0 2c	 imul	 eax, 44			; 0000002cH
  0000b	33 c9		 xor	 ecx, ecx
  0000d	05 00 00 00 00	 add	 eax, OFFSET _EncryptionAlgorithms
$LL2@EAGetCiphe:

; 625  : 	while (EncryptionAlgorithms[ea].Ciphers[i++]);

  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	41		 inc	 ecx
  00015	83 c0 04	 add	 eax, 4
  00018	85 d2		 test	 edx, edx
  0001a	75 f6		 jne	 SHORT $LL2@EAGetCiphe

; 626  : 
; 627  : 	return i - 1;

  0001c	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]

; 628  : }

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
_EAGetCipherCount@4 ENDP
_TEXT	ENDS
PUBLIC	_EAGetFirstCipher@4
; Function compile flags: /Ogsp
;	COMDAT _EAGetFirstCipher@4
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_EAGetFirstCipher@4 PROC				; COMDAT

; 632  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 633  : 	return EncryptionAlgorithms[ea].Ciphers[0];

  00005	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00008	6b c0 2c	 imul	 eax, 44			; 0000002cH
  0000b	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax]

; 634  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
_EAGetFirstCipher@4 ENDP
_TEXT	ENDS
PUBLIC	_EAGetLastCipher@4
; Function compile flags: /Ogsp
;	COMDAT _EAGetLastCipher@4
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_EAGetLastCipher@4 PROC					; COMDAT

; 638  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 639  : 	int c, i = 0;

  00005	8b 4d 08	 mov	 ecx, DWORD PTR _ea$[ebp]
  00008	8b c1		 mov	 eax, ecx
  0000a	6b c0 2c	 imul	 eax, 44			; 0000002cH
  0000d	33 d2		 xor	 edx, edx
  0000f	05 00 00 00 00	 add	 eax, OFFSET _EncryptionAlgorithms
  00014	56		 push	 esi
$LL2@EAGetLastC:

; 640  : 	while (c = EncryptionAlgorithms[ea].Ciphers[i++]);

  00015	8b 30		 mov	 esi, DWORD PTR [eax]
  00017	42		 inc	 edx
  00018	83 c0 04	 add	 eax, 4
  0001b	85 f6		 test	 esi, esi
  0001d	75 f6		 jne	 SHORT $LL2@EAGetLastC

; 641  : 
; 642  : 	return EncryptionAlgorithms[ea].Ciphers[i - 2];

  0001f	6b c9 0b	 imul	 ecx, 11			; 0000000bH
  00022	03 ca		 add	 ecx, edx
  00024	8b 04 8d f8 ff
	ff ff		 mov	 eax, DWORD PTR _EncryptionAlgorithms[ecx*4-8]
  0002b	5e		 pop	 esi

; 643  : }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
_EAGetLastCipher@4 ENDP
_TEXT	ENDS
PUBLIC	_EAGetNextCipher@8
; Function compile flags: /Ogsp
;	COMDAT _EAGetNextCipher@8
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_previousCipherId$ = 12					; size = 4
_EAGetNextCipher@8 PROC					; COMDAT

; 647  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 648  : 	int c, i = 0;
; 649  : 	while (c = EncryptionAlgorithms[ea].Ciphers[i++])

  00005	8b 55 08	 mov	 edx, DWORD PTR _ea$[ebp]
  00008	8b c2		 mov	 eax, edx
  0000a	6b c0 0b	 imul	 eax, 11			; 0000000bH
  0000d	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _EncryptionAlgorithms[eax*4]
  00014	56		 push	 esi
  00015	33 f6		 xor	 esi, esi
  00017	85 c9		 test	 ecx, ecx
  00019	74 18		 je	 SHORT $LN8@EAGetNextC
  0001b	6b d2 2c	 imul	 edx, 44			; 0000002cH
  0001e	81 c2 00 00 00
	00		 add	 edx, OFFSET _EncryptionAlgorithms
$LL3@EAGetNextC:
  00024	46		 inc	 esi
  00025	83 c2 04	 add	 edx, 4

; 650  : 	{
; 651  : 		if (c == previousCipherId) 

  00028	3b 4d 0c	 cmp	 ecx, DWORD PTR _previousCipherId$[ebp]
  0002b	74 0d		 je	 SHORT $LN7@EAGetNextC
  0002d	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0002f	85 c9		 test	 ecx, ecx
  00031	75 f1		 jne	 SHORT $LL3@EAGetNextC
$LN8@EAGetNextC:

; 653  : 	}
; 654  : 
; 655  : 	return 0;

  00033	33 c0		 xor	 eax, eax
$LN4@EAGetNextC:
  00035	5e		 pop	 esi

; 656  : }

  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
$LN7@EAGetNextC:

; 652  : 			return EncryptionAlgorithms[ea].Ciphers[i];

  0003a	03 c6		 add	 eax, esi
  0003c	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax*4]
  00043	eb f0		 jmp	 SHORT $LN4@EAGetNextC
_EAGetNextCipher@8 ENDP
_TEXT	ENDS
PUBLIC	_EAGetPreviousCipher@8
; Function compile flags: /Ogsp
;	COMDAT _EAGetPreviousCipher@8
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_previousCipherId$ = 12					; size = 4
_EAGetPreviousCipher@8 PROC				; COMDAT

; 660  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 661  : 	int c, i = 0;
; 662  : 
; 663  : 	if (EncryptionAlgorithms[ea].Ciphers[i++] == previousCipherId)

  00005	8b 55 08	 mov	 edx, DWORD PTR _ea$[ebp]
  00008	8b c2		 mov	 eax, edx
  0000a	6b c0 0b	 imul	 eax, 11			; 0000000bH
  0000d	56		 push	 esi
  0000e	8b 75 0c	 mov	 esi, DWORD PTR _previousCipherId$[ebp]
  00011	57		 push	 edi
  00012	33 ff		 xor	 edi, edi
  00014	47		 inc	 edi
  00015	39 34 85 00 00
	00 00		 cmp	 DWORD PTR _EncryptionAlgorithms[eax*4], esi

; 664  : 		return 0;

  0001c	74 22		 je	 SHORT $LN9@EAGetPrevi

; 665  : 
; 666  : 	while (c = EncryptionAlgorithms[ea].Ciphers[i++])

  0001e	8b 0c 85 04 00
	00 00		 mov	 ecx, DWORD PTR _EncryptionAlgorithms[eax*4+4]
  00025	85 c9		 test	 ecx, ecx
  00027	74 17		 je	 SHORT $LN9@EAGetPrevi
  00029	6b d2 2c	 imul	 edx, 44			; 0000002cH
  0002c	81 c2 04 00 00
	00		 add	 edx, OFFSET _EncryptionAlgorithms+4
$LL3@EAGetPrevi:
  00032	47		 inc	 edi
  00033	83 c2 04	 add	 edx, 4

; 667  : 	{
; 668  : 		if (c == previousCipherId) 

  00036	3b ce		 cmp	 ecx, esi
  00038	74 0e		 je	 SHORT $LN8@EAGetPrevi
  0003a	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0003c	85 c9		 test	 ecx, ecx
  0003e	75 f2		 jne	 SHORT $LL3@EAGetPrevi
$LN9@EAGetPrevi:

; 670  : 	}
; 671  : 
; 672  : 	return 0;

  00040	33 c0		 xor	 eax, eax
$LN5@EAGetPrevi:
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi

; 673  : }

  00044	5d		 pop	 ebp
  00045	c2 08 00	 ret	 8
$LN8@EAGetPrevi:

; 669  : 			return EncryptionAlgorithms[ea].Ciphers[i - 2];

  00048	03 c7		 add	 eax, edi
  0004a	8b 04 85 f8 ff
	ff ff		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax*4-8]
  00051	eb ef		 jmp	 SHORT $LN5@EAGetPrevi
_EAGetPreviousCipher@8 ENDP
_TEXT	ENDS
PUBLIC	_EAIsFormatEnabled@4
; Function compile flags: /Ogsp
;	COMDAT _EAIsFormatEnabled@4
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_EAIsFormatEnabled@4 PROC				; COMDAT

; 677  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 678  : 	return EncryptionAlgorithms[ea].FormatEnabled;

  00005	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00008	6b c0 2c	 imul	 eax, 44			; 0000002cH
  0000b	8b 80 28 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax+40]

; 679  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
_EAIsFormatEnabled@4 ENDP
_TEXT	ENDS
PUBLIC	_EAIsModeSupported@8
; Function compile flags: /Ogsp
;	COMDAT _EAIsModeSupported@8
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_testedMode$ = 12					; size = 4
_EAIsModeSupported@8 PROC				; COMDAT

; 684  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 685  : 	int mode;
; 686  : 
; 687  : 	for (mode = EAGetFirstMode (ea); mode != 0; mode = EAGetNextMode (ea, mode))

  00005	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00008	6b c0 2c	 imul	 eax, 44			; 0000002cH
  0000b	8b 80 10 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax+16]
  00011	eb 0e		 jmp	 SHORT $LN12@EAIsModeSu
$LL4@EAIsModeSu:

; 688  : 	{
; 689  : 		if (mode == testedMode)

  00013	3b 45 0c	 cmp	 eax, DWORD PTR _testedMode$[ebp]
  00016	74 11		 je	 SHORT $LN10@EAIsModeSu
  00018	50		 push	 eax
  00019	ff 75 08	 push	 DWORD PTR _ea$[ebp]
  0001c	e8 00 00 00 00	 call	 _EAGetNextMode@8
$LN12@EAIsModeSu:

; 685  : 	int mode;
; 686  : 
; 687  : 	for (mode = EAGetFirstMode (ea); mode != 0; mode = EAGetNextMode (ea, mode))

  00021	85 c0		 test	 eax, eax
  00023	75 ee		 jne	 SHORT $LL4@EAIsModeSu
$LN5@EAIsModeSu:

; 691  : 	}
; 692  : 	return FALSE;
; 693  : }

  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
$LN10@EAIsModeSu:

; 690  : 			return TRUE;

  00029	33 c0		 xor	 eax, eax
  0002b	40		 inc	 eax
  0002c	eb f7		 jmp	 SHORT $LN5@EAIsModeSu
_EAIsModeSupported@8 ENDP
_TEXT	ENDS
PUBLIC	_HashGet@4
; Function compile flags: /Ogsp
;	COMDAT _HashGet@4
_TEXT	SEGMENT
_id$ = 8						; size = 4
_HashGet@4 PROC						; COMDAT

; 697  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 698  : 	int i;
; 699  : 	for (i = 0; Hashes[i].Id != 0; i++)

  00005	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Hashes
  0000b	33 c0		 xor	 eax, eax
  0000d	eb 11		 jmp	 SHORT $LN10@HashGet
$LL4@HashGet:

; 700  : 		if (Hashes[i].Id == id)

  0000f	3b 4d 08	 cmp	 ecx, DWORD PTR _id$[ebp]
  00012	74 16		 je	 SHORT $LN8@HashGet
  00014	40		 inc	 eax
  00015	8b c8		 mov	 ecx, eax
  00017	c1 e1 04	 shl	 ecx, 4
  0001a	8b 89 00 00 00
	00		 mov	 ecx, DWORD PTR _Hashes[ecx]
$LN10@HashGet:

; 698  : 	int i;
; 699  : 	for (i = 0; Hashes[i].Id != 0; i++)

  00020	85 c9		 test	 ecx, ecx
  00022	75 eb		 jne	 SHORT $LL4@HashGet

; 702  : 
; 703  : 	return 0;

  00024	33 c0		 xor	 eax, eax
$LN5@HashGet:

; 704  : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN8@HashGet:

; 701  : 			return &Hashes[i];

  0002a	c1 e0 04	 shl	 eax, 4
  0002d	05 00 00 00 00	 add	 eax, OFFSET _Hashes
  00032	eb f2		 jmp	 SHORT $LN5@HashGet
_HashGet@4 ENDP
_TEXT	ENDS
PUBLIC	_HashGetIdByName@4
; Function compile flags: /Ogsp
;	COMDAT _HashGetIdByName@4
_TEXT	SEGMENT
_name$ = 8						; size = 4
_HashGetIdByName@4 PROC					; COMDAT

; 708  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 709  : 	int i;
; 710  : 	for (i = 0; Hashes[i].Id != 0; i++)

  00006	33 f6		 xor	 esi, esi
  00008	39 35 00 00 00
	00		 cmp	 DWORD PTR _Hashes, esi
  0000e	74 41		 je	 SHORT $LN2@HashGetIdB
  00010	33 c0		 xor	 eax, eax
$LL4@HashGetIdB:

; 711  : 		if (strcmp (Hashes[i].Name, name) == 0)

  00012	8b 4d 08	 mov	 ecx, DWORD PTR _name$[ebp]
  00015	8b 80 04 00 00
	00		 mov	 eax, DWORD PTR _Hashes[eax+4]
$LL10@HashGetIdB:
  0001b	8a 10		 mov	 dl, BYTE PTR [eax]
  0001d	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0001f	75 18		 jne	 SHORT $LN11@HashGetIdB
  00021	84 d2		 test	 dl, dl
  00023	74 10		 je	 SHORT $LN12@HashGetIdB
  00025	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00028	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  0002b	75 0c		 jne	 SHORT $LN11@HashGetIdB
  0002d	40		 inc	 eax
  0002e	40		 inc	 eax
  0002f	41		 inc	 ecx
  00030	41		 inc	 ecx
  00031	84 d2		 test	 dl, dl
  00033	75 e6		 jne	 SHORT $LL10@HashGetIdB
$LN12@HashGetIdB:
  00035	33 c0		 xor	 eax, eax
  00037	eb 05		 jmp	 SHORT $LN13@HashGetIdB
$LN11@HashGetIdB:
  00039	1b c0		 sbb	 eax, eax
  0003b	83 d8 ff	 sbb	 eax, -1
$LN13@HashGetIdB:
  0003e	85 c0		 test	 eax, eax
  00040	74 16		 je	 SHORT $LN8@HashGetIdB
  00042	46		 inc	 esi
  00043	8b c6		 mov	 eax, esi
  00045	c1 e0 04	 shl	 eax, 4
  00048	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _Hashes[eax], 0
  0004f	75 c1		 jne	 SHORT $LL4@HashGetIdB
$LN2@HashGetIdB:

; 713  : 
; 714  : 	return 0;

  00051	33 c0		 xor	 eax, eax
$LN5@HashGetIdB:
  00053	5e		 pop	 esi

; 715  : }

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
$LN8@HashGetIdB:

; 712  : 			return Hashes[i].Id;

  00058	c1 e6 04	 shl	 esi, 4
  0005b	8b 86 00 00 00
	00		 mov	 eax, DWORD PTR _Hashes[esi]
  00061	eb f0		 jmp	 SHORT $LN5@HashGetIdB
_HashGetIdByName@4 ENDP
_TEXT	ENDS
PUBLIC	_HashGetName@4
; Function compile flags: /Ogsp
;	COMDAT _HashGetName@4
_TEXT	SEGMENT
_hashId$ = 8						; size = 4
_HashGetName@4 PROC					; COMDAT

; 719  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 720  : 	return HashGet (hashId) -> Name;

  00005	ff 75 08	 push	 DWORD PTR _hashId$[ebp]
  00008	e8 00 00 00 00	 call	 _HashGet@4
  0000d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 721  : }

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
_HashGetName@4 ENDP
_TEXT	ENDS
PUBLIC	_HashIsDeprecated@4
; Function compile flags: /Ogsp
;	COMDAT _HashIsDeprecated@4
_TEXT	SEGMENT
_hashId$ = 8						; size = 4
_HashIsDeprecated@4 PROC				; COMDAT

; 725  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 726  : 	return HashGet (hashId) -> Deprecated;

  00005	ff 75 08	 push	 DWORD PTR _hashId$[ebp]
  00008	e8 00 00 00 00	 call	 _HashGet@4
  0000d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 727  : }

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
_HashIsDeprecated@4 ENDP
_TEXT	ENDS
PUBLIC	_crypto_open@0
EXTRN	__imp__ExAllocatePoolWithTag@12:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogsp
;	COMDAT _crypto_open@0
_TEXT	SEGMENT
_crypto_open@0 PROC					; COMDAT

; 741  : {

  00000	8b ff		 npad	 2
  00002	56		 push	 esi
  00003	57		 push	 edi

; 742  : #ifndef TC_WINDOWS_BOOT
; 743  : 
; 744  : 	/* Do the crt allocation */
; 745  : 	PCRYPTO_INFO cryptoInfo = (PCRYPTO_INFO) TCalloc (sizeof (CRYPTO_INFO));

  00004	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00009	be 68 44 00 00	 mov	 esi, 17512		; 00004468H
  0000e	56		 push	 esi
  0000f	6a 00		 push	 0
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00017	8b f8		 mov	 edi, eax

; 746  : 	if (cryptoInfo == NULL)

  00019	85 ff		 test	 edi, edi
  0001b	74 11		 je	 SHORT $LN2@crypto_ope
$LN1@crypto_ope:

; 747  : 		return NULL;
; 748  : 
; 749  : 	memset (cryptoInfo, 0, sizeof (CRYPTO_INFO));

  0001d	56		 push	 esi
  0001e	6a 00		 push	 0
  00020	57		 push	 edi
  00021	e8 00 00 00 00	 call	 _memset
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 750  : 
; 751  : #ifndef DEVICE_DRIVER
; 752  : 	VirtualLock (cryptoInfo, sizeof (CRYPTO_INFO));
; 753  : #endif
; 754  : 
; 755  : 	cryptoInfo->ea = -1;

  00029	83 0f ff	 or	 DWORD PTR [edi], -1

; 756  : 	return cryptoInfo;

  0002c	8b c7		 mov	 eax, edi
$LN2@crypto_ope:
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi

; 757  : 
; 758  : #else // TC_WINDOWS_BOOT
; 759  : 
; 760  : #if 0
; 761  : 	if (CryptoInfoBufferInUse)
; 762  : 		TC_THROW_FATAL_EXCEPTION;
; 763  : #endif
; 764  : 	CryptoInfoBufferInUse = 1;
; 765  : 	return &CryptoInfoBuffer;
; 766  : 
; 767  : #endif // TC_WINDOWS_BOOT
; 768  : }

  00030	c3		 ret	 0
_crypto_open@0 ENDP
_TEXT	ENDS
PUBLIC	_crypto_loadkey@12
EXTRN	_memcpy:PROC
; Function compile flags: /Ogsp
;	COMDAT _crypto_loadkey@12
_TEXT	SEGMENT
_keyInfo$ = 8						; size = 4
_lpszUserKey$ = 12					; size = 4
_nUserKeyLen$ = 16					; size = 4
_crypto_loadkey@12 PROC					; COMDAT

; 771  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 772  : 	keyInfo->keyLength = nUserKeyLen;

  00005	8b 45 08	 mov	 eax, DWORD PTR _keyInfo$[ebp]
  00008	8b 55 10	 mov	 edx, DWORD PTR _nUserKeyLen$[ebp]
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	57		 push	 edi

; 773  : 	burn (keyInfo->userKey, sizeof (keyInfo->userKey));

  0000e	6a 40		 push	 64			; 00000040H
  00010	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00013	83 c0 08	 add	 eax, 8
  00016	5b		 pop	 ebx
  00017	8b f0		 mov	 esi, eax
  00019	8b fb		 mov	 edi, ebx
  0001b	8b c8		 mov	 ecx, eax
$LL9@crypto_loa:
  0001d	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00020	41		 inc	 ecx
  00021	4b		 dec	 ebx
  00022	75 f9		 jne	 SHORT $LL9@crypto_loa
$LL2@crypto_loa:
  00024	4f		 dec	 edi
  00025	c6 06 00	 mov	 BYTE PTR [esi], 0
  00028	46		 inc	 esi
  00029	85 ff		 test	 edi, edi
  0002b	75 f7		 jne	 SHORT $LL2@crypto_loa

; 774  : 	memcpy (keyInfo->userKey, lpszUserKey, nUserKeyLen);

  0002d	52		 push	 edx
  0002e	ff 75 0c	 push	 DWORD PTR _lpszUserKey$[ebp]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 _memcpy
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx

; 775  : }

  0003d	5d		 pop	 ebp
  0003e	c2 0c 00	 ret	 12			; 0000000cH
_crypto_loadkey@12 ENDP
_TEXT	ENDS
PUBLIC	_crypto_close@4
EXTRN	__imp__ExFreePoolWithTag@8:PROC
; Function compile flags: /Ogsp
;	COMDAT _crypto_close@4
_TEXT	SEGMENT
_cryptoInfo$ = 8					; size = 4
_crypto_close@4 PROC					; COMDAT

; 778  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	57		 push	 edi

; 779  : #ifndef TC_WINDOWS_BOOT
; 780  : 
; 781  : 	if (cryptoInfo != NULL)

  00006	8b 7d 08	 mov	 edi, DWORD PTR _cryptoInfo$[ebp]
  00009	85 ff		 test	 edi, edi
  0000b	74 29		 je	 SHORT $LN6@crypto_clo

; 782  : 	{
; 783  : 		burn (cryptoInfo, sizeof (CRYPTO_INFO));

  0000d	b8 68 44 00 00	 mov	 eax, 17512		; 00004468H
  00012	56		 push	 esi
  00013	8b d7		 mov	 edx, edi
  00015	8b f0		 mov	 esi, eax
  00017	8b cf		 mov	 ecx, edi
$LL10@crypto_clo:
  00019	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0001c	41		 inc	 ecx
  0001d	48		 dec	 eax
  0001e	75 f9		 jne	 SHORT $LL10@crypto_clo
$LL2@crypto_clo:
  00020	4e		 dec	 esi
  00021	c6 02 00	 mov	 BYTE PTR [edx], 0
  00024	42		 inc	 edx
  00025	85 f6		 test	 esi, esi
  00027	75 f7		 jne	 SHORT $LL2@crypto_clo

; 784  : #ifndef DEVICE_DRIVER
; 785  : 		VirtualUnlock (cryptoInfo, sizeof (CRYPTO_INFO));
; 786  : #endif
; 787  : 		TCfree (cryptoInfo);

  00029	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0002e	57		 push	 edi
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
  00035	5e		 pop	 esi
$LN6@crypto_clo:
  00036	5f		 pop	 edi

; 788  : 	}
; 789  : 
; 790  : #else // TC_WINDOWS_BOOT
; 791  : 
; 792  : 	burn (&CryptoInfoBuffer, sizeof (CryptoInfoBuffer));
; 793  : 	CryptoInfoBufferInUse = FALSE;
; 794  : 
; 795  : #endif // TC_WINDOWS_BOOT
; 796  : }

  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
_crypto_close@4 ENDP
_TEXT	ENDS
PUBLIC	_Xor128@8
; Function compile flags: /Ogsp
;	COMDAT _Xor128@8
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_Xor128@8 PROC						; COMDAT

; 804  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 805  : 	*a++ ^= *b++;

  00005	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0000d	31 10		 xor	 DWORD PTR [eax], edx
  0000f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00012	31 50 04	 xor	 DWORD PTR [eax+4], edx

; 806  : 	*a ^= *b;

  00015	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00018	83 c0 08	 add	 eax, 8
  0001b	31 10		 xor	 DWORD PTR [eax], edx
  0001d	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00020	31 48 04	 xor	 DWORD PTR [eax+4], ecx

; 807  : }

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
_Xor128@8 ENDP
_TEXT	ENDS
PUBLIC	_Xor64@8
; Function compile flags: /Ogsp
;	COMDAT _Xor64@8
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_Xor64@8 PROC						; COMDAT

; 811  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 812  : 	*a ^= *b;

  00005	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0000d	31 10		 xor	 DWORD PTR [eax], edx
  0000f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00012	31 48 04	 xor	 DWORD PTR [eax+4], ecx

; 813  : }

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
_Xor64@8 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_EncryptBufferLRW128@24
EXTRN	_Gf128MulBy64Tab@12:PROC
EXTRN	_MirrorBytes64@8:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _EncryptBufferLRW128@24
_TEXT	SEGMENT
tv202 = -56						; size = 8
_cipherCount$ = -48					; size = 4
_b$ = -44						; size = 8
_ks$ = -36						; size = 4
_p$ = -32						; size = 4
_t$ = -28						; size = 16
_i$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_blockIndex$ = 20					; size = 8
_cryptoInfo$ = 28					; size = 4
_EncryptBufferLRW128@24 PROC				; COMDAT

; 817  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 38	 sub	 esp, 56			; 00000038H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	8b 75 1c	 mov	 esi, DWORD PTR _cryptoInfo$[ebp]

; 818  : 	/* Deprecated/legacy */
; 819  : 
; 820  : 	int cipher = EAGetFirstCipher (cryptoInfo->ea);

  00017	8b 06		 mov	 eax, DWORD PTR [esi]
  00019	8b c8		 mov	 ecx, eax
  0001b	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  0001e	8b 99 00 00 00
	00		 mov	 ebx, DWORD PTR _EncryptionAlgorithms[ecx]
  00024	57		 push	 edi
  00025	8b 7d 08	 mov	 edi, DWORD PTR _buffer$[ebp]

; 821  : 	int cipherCount = EAGetCipherCount (cryptoInfo->ea);

  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 _EAGetCipherCount@4

; 822  : 	unsigned __int8 *p = buffer;
; 823  : 	unsigned __int8 *ks = cryptoInfo->ks;
; 824  : 	unsigned __int8 i[8];
; 825  : 	unsigned __int8 t[16];
; 826  : 	unsigned __int64 b;
; 827  : 
; 828  : 	*(unsigned __int64 *)i = BE64(blockIndex);

  0002e	ff 75 18	 push	 DWORD PTR _blockIndex$[ebp+4]
  00031	89 45 d0	 mov	 DWORD PTR _cipherCount$[ebp], eax
  00034	ff 75 14	 push	 DWORD PTR _blockIndex$[ebp]
  00037	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  0003a	89 7d e0	 mov	 DWORD PTR _p$[ebp], edi
  0003d	89 45 dc	 mov	 DWORD PTR _ks$[ebp], eax
  00040	e8 00 00 00 00	 call	 _MirrorBytes64@8
  00045	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
  00048	89 55 f8	 mov	 DWORD PTR _i$[ebp+4], edx

; 829  : 
; 830  : 	if (length % 16)

  0004b	8b 55 0c	 mov	 edx, DWORD PTR _length$[ebp]
  0004e	8b c2		 mov	 eax, edx
  00050	83 e0 0f	 and	 eax, 15			; 0000000fH
  00053	33 c9		 xor	 ecx, ecx
  00055	0b c1		 or	 eax, ecx
  00057	74 14		 je	 SHORT $LN16@EncryptBuf

; 831  : 		TC_THROW_FATAL_EXCEPTION;

  00059	68 43 54 00 00	 push	 21571			; 00005443H
  0005e	51		 push	 ecx
  0005f	51		 push	 ecx
  00060	68 3f 03 00 00	 push	 831			; 0000033fH
  00065	6a 29		 push	 41			; 00000029H
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN40@EncryptBuf:
$LN16@EncryptBuf:

; 832  : 
; 833  : 	// Note that the maximum supported volume size is 8589934592 GB  (i.e., 2^63 bytes).
; 834  : 
; 835  : 	for (b = 0; b < length >> 4; b++)

  0006d	8b 7d 10	 mov	 edi, DWORD PTR _length$[ebp+4]
  00070	0f ac fa 04	 shrd	 edx, edi, 4
  00074	c1 ef 04	 shr	 edi, 4
  00077	89 4d d4	 mov	 DWORD PTR _b$[ebp], ecx
  0007a	89 4d d8	 mov	 DWORD PTR _b$[ebp+4], ecx
  0007d	89 55 c8	 mov	 DWORD PTR tv202[ebp], edx
  00080	85 ff		 test	 edi, edi
  00082	0f 82 cf 00 00
	00		 jb	 $LN5@EncryptBuf
  00088	77 08		 ja	 SHORT $LL32@EncryptBuf
  0008a	3b d1		 cmp	 edx, ecx
  0008c	0f 86 c5 00 00
	00		 jbe	 $LN5@EncryptBuf
$LL32@EncryptBuf:

; 836  : 	{
; 837  : 		Gf128MulBy64Tab (i, t, &cryptoInfo->gf_ctx);

  00092	8d 86 a8 29 00
	00		 lea	 eax, DWORD PTR [esi+10664]
  00098	50		 push	 eax
  00099	8d 45 e4	 lea	 eax, DWORD PTR _t$[ebp]
  0009c	50		 push	 eax
  0009d	8d 45 f4	 lea	 eax, DWORD PTR _i$[ebp]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 _Gf128MulBy64Tab@12

; 838  : 		Xor128 ((unsigned __int64 *)p, (unsigned __int64 *)t);

  000a6	8d 45 e4	 lea	 eax, DWORD PTR _t$[ebp]
  000a9	50		 push	 eax
  000aa	ff 75 e0	 push	 DWORD PTR _p$[ebp]
  000ad	e8 00 00 00 00	 call	 _Xor128@8

; 839  : 
; 840  : 		if (cipherCount > 1)

  000b2	83 7d d0 01	 cmp	 DWORD PTR _cipherCount$[ebp], 1
  000b6	7e 3b		 jle	 SHORT $LN12@EncryptBuf

; 841  : 		{
; 842  : 			// Cipher cascade
; 843  : 			for (cipher = EAGetFirstCipher (cryptoInfo->ea);
; 844  : 				cipher != 0;
; 845  : 				cipher = EAGetNextCipher (cryptoInfo->ea, cipher))

  000b8	8b 06		 mov	 eax, DWORD PTR [esi]
  000ba	6b c0 2c	 imul	 eax, 44			; 0000002cH
  000bd	8b 98 00 00 00
	00		 mov	 ebx, DWORD PTR _EncryptionAlgorithms[eax]
  000c3	eb 22		 jmp	 SHORT $LN39@EncryptBuf
$LL11@EncryptBuf:

; 846  : 			{
; 847  : 				EncipherBlock (cipher, p, ks);

  000c5	ff 75 dc	 push	 DWORD PTR _ks$[ebp]
  000c8	ff 75 e0	 push	 DWORD PTR _p$[ebp]
  000cb	53		 push	 ebx
  000cc	e8 00 00 00 00	 call	 _EncipherBlock@12

; 848  : 				ks += CipherGetKeyScheduleSize (cipher);

  000d1	53		 push	 ebx
  000d2	e8 00 00 00 00	 call	 _CipherGet@4
  000d7	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  000da	01 45 dc	 add	 DWORD PTR _ks$[ebp], eax
  000dd	53		 push	 ebx
  000de	ff 36		 push	 DWORD PTR [esi]
  000e0	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  000e5	8b d8		 mov	 ebx, eax
$LN39@EncryptBuf:

; 841  : 		{
; 842  : 			// Cipher cascade
; 843  : 			for (cipher = EAGetFirstCipher (cryptoInfo->ea);
; 844  : 				cipher != 0;
; 845  : 				cipher = EAGetNextCipher (cryptoInfo->ea, cipher))

  000e7	85 db		 test	 ebx, ebx
  000e9	75 da		 jne	 SHORT $LL11@EncryptBuf

; 849  : 			}
; 850  : 			ks = cryptoInfo->ks;

  000eb	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  000ee	89 45 dc	 mov	 DWORD PTR _ks$[ebp], eax

; 851  : 		}
; 852  : 		else

  000f1	eb 0c		 jmp	 SHORT $LN8@EncryptBuf
$LN12@EncryptBuf:

; 853  : 		{
; 854  : 			EncipherBlock (cipher, p, ks);

  000f3	ff 75 dc	 push	 DWORD PTR _ks$[ebp]
  000f6	ff 75 e0	 push	 DWORD PTR _p$[ebp]
  000f9	53		 push	 ebx
  000fa	e8 00 00 00 00	 call	 _EncipherBlock@12
$LN8@EncryptBuf:

; 855  : 		}
; 856  : 
; 857  : 		Xor128 ((unsigned __int64 *)p, (unsigned __int64 *)t);

  000ff	8d 45 e4	 lea	 eax, DWORD PTR _t$[ebp]
  00102	50		 push	 eax
  00103	ff 75 e0	 push	 DWORD PTR _p$[ebp]
  00106	e8 00 00 00 00	 call	 _Xor128@8

; 858  : 
; 859  : 		p += 16;

  0010b	83 45 e0 10	 add	 DWORD PTR _p$[ebp], 16	; 00000010H

; 860  : 
; 861  : 		if (i[7] != 0xff)

  0010f	80 7d fb ff	 cmp	 BYTE PTR _i$[ebp+7], 255 ; 000000ffH
  00113	74 05		 je	 SHORT $LN7@EncryptBuf

; 862  : 			i[7]++;

  00115	fe 45 fb	 inc	 BYTE PTR _i$[ebp+7]

; 863  : 		else

  00118	eb 1e		 jmp	 SHORT $LN14@EncryptBuf
$LN7@EncryptBuf:

; 864  : 			*(unsigned __int64 *)i = BE64 ( BE64(*(unsigned __int64 *)i) + 1 );

  0011a	ff 75 f8	 push	 DWORD PTR _i$[ebp+4]
  0011d	ff 75 f4	 push	 DWORD PTR _i$[ebp]
  00120	e8 00 00 00 00	 call	 _MirrorBytes64@8
  00125	83 c0 01	 add	 eax, 1
  00128	83 d2 00	 adc	 edx, 0
  0012b	52		 push	 edx
  0012c	50		 push	 eax
  0012d	e8 00 00 00 00	 call	 _MirrorBytes64@8
  00132	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
  00135	89 55 f8	 mov	 DWORD PTR _i$[ebp+4], edx
$LN14@EncryptBuf:
  00138	83 45 d4 01	 add	 DWORD PTR _b$[ebp], 1
  0013c	83 55 d8 00	 adc	 DWORD PTR _b$[ebp+4], 0
  00140	39 7d d8	 cmp	 DWORD PTR _b$[ebp+4], edi
  00143	0f 82 49 ff ff
	ff		 jb	 $LL32@EncryptBuf

; 832  : 
; 833  : 	// Note that the maximum supported volume size is 8589934592 GB  (i.e., 2^63 bytes).
; 834  : 
; 835  : 	for (b = 0; b < length >> 4; b++)

  00149	77 0c		 ja	 SHORT $LN5@EncryptBuf
  0014b	8b 45 c8	 mov	 eax, DWORD PTR tv202[ebp]
  0014e	39 45 d4	 cmp	 DWORD PTR _b$[ebp], eax
  00151	0f 82 3b ff ff
	ff		 jb	 $LL32@EncryptBuf
$LN5@EncryptBuf:

; 865  : 	}
; 866  : 
; 867  : 	FAST_ERASE64 (t, sizeof(t));

  00157	6a 02		 push	 2
  00159	59		 pop	 ecx
  0015a	5f		 pop	 edi
  0015b	5e		 pop	 esi
  0015c	8d 45 e4	 lea	 eax, DWORD PTR _t$[ebp]
  0015f	5b		 pop	 ebx
$LL2@EncryptBuf:
  00160	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00166	49		 dec	 ecx
  00167	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0016e	83 c0 08	 add	 eax, 8
  00171	85 c9		 test	 ecx, ecx
  00173	75 eb		 jne	 SHORT $LL2@EncryptBuf

; 868  : }

  00175	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00178	33 cd		 xor	 ecx, ebp
  0017a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017f	c9		 leave
  00180	c2 18 00	 ret	 24			; 00000018H
$LN38@EncryptBuf:
_EncryptBufferLRW128@24 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_EncryptBufferLRW64@24
EXTRN	_Gf64MulTab@12:PROC
; Function compile flags: /Ogsp
;	COMDAT _EncryptBufferLRW64@24
_TEXT	SEGMENT
tv169 = -44						; size = 8
_cipher$ = -36						; size = 4
_ks$ = -32						; size = 4
_b$ = -28						; size = 8
_t$ = -20						; size = 8
_i$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_blockIndex$ = 20					; size = 8
_cryptoInfo$ = 28					; size = 4
_EncryptBufferLRW64@24 PROC				; COMDAT

; 872  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _buffer$[ebp]
  00017	57		 push	 edi
  00018	8b 7d 1c	 mov	 edi, DWORD PTR _cryptoInfo$[ebp]

; 873  : 	/* Deprecated/legacy */
; 874  : 
; 875  : 	int cipher = EAGetFirstCipher (cryptoInfo->ea);

  0001b	8b 07		 mov	 eax, DWORD PTR [edi]

; 876  : 	unsigned __int8 *p = buffer;
; 877  : 	unsigned __int8 *ks = cryptoInfo->ks;
; 878  : 	unsigned __int8 i[8];
; 879  : 	unsigned __int8 t[8];
; 880  : 	unsigned __int64 b;
; 881  : 
; 882  : 	*(unsigned __int64 *)i = BE64(blockIndex);

  0001d	ff 75 18	 push	 DWORD PTR _blockIndex$[ebp+4]
  00020	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00023	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax]
  00029	ff 75 14	 push	 DWORD PTR _blockIndex$[ebp]
  0002c	89 45 dc	 mov	 DWORD PTR _cipher$[ebp], eax
  0002f	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  00032	89 45 e0	 mov	 DWORD PTR _ks$[ebp], eax
  00035	e8 00 00 00 00	 call	 _MirrorBytes64@8
  0003a	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
  0003d	89 55 f8	 mov	 DWORD PTR _i$[ebp+4], edx

; 883  : 
; 884  : 	if (length % 8)

  00040	8b 55 0c	 mov	 edx, DWORD PTR _length$[ebp]
  00043	8b c2		 mov	 eax, edx
  00045	83 e0 07	 and	 eax, 7
  00048	33 c9		 xor	 ecx, ecx
  0004a	0b c1		 or	 eax, ecx
  0004c	74 14		 je	 SHORT $LN11@EncryptBuf@2

; 885  : 		TC_THROW_FATAL_EXCEPTION;

  0004e	68 43 54 00 00	 push	 21571			; 00005443H
  00053	51		 push	 ecx
  00054	51		 push	 ecx
  00055	68 75 03 00 00	 push	 885			; 00000375H
  0005a	6a 29		 push	 41			; 00000029H
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN29@EncryptBuf@2:
$LN11@EncryptBuf@2:

; 886  : 
; 887  : 	for (b = 0; b < length >> 3; b++)

  00062	8b 5d 10	 mov	 ebx, DWORD PTR _length$[ebp+4]
  00065	0f ac da 03	 shrd	 edx, ebx, 3
  00069	c1 eb 03	 shr	 ebx, 3
  0006c	89 4d e4	 mov	 DWORD PTR _b$[ebp], ecx
  0006f	89 4d e8	 mov	 DWORD PTR _b$[ebp+4], ecx
  00072	89 55 d4	 mov	 DWORD PTR tv169[ebp], edx
  00075	85 db		 test	 ebx, ebx
  00077	72 7f		 jb	 SHORT $LN5@EncryptBuf@2
  00079	77 04		 ja	 SHORT $LN25@EncryptBuf@2
  0007b	3b d1		 cmp	 edx, ecx
  0007d	76 79		 jbe	 SHORT $LN5@EncryptBuf@2
$LN25@EncryptBuf@2:
  0007f	81 c7 a8 29 00
	00		 add	 edi, 10664		; 000029a8H
$LL10@EncryptBuf@2:

; 888  : 	{
; 889  : 		Gf64MulTab (i, t, &cryptoInfo->gf_ctx);

  00085	57		 push	 edi
  00086	8d 45 ec	 lea	 eax, DWORD PTR _t$[ebp]
  00089	50		 push	 eax
  0008a	8d 45 f4	 lea	 eax, DWORD PTR _i$[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 _Gf64MulTab@12

; 890  : 		Xor64 ((unsigned __int64 *)p, (unsigned __int64 *)t);
; 891  : 
; 892  : 		EncipherBlock (cipher, p, ks);

  00093	ff 75 e0	 push	 DWORD PTR _ks$[ebp]
  00096	8b 45 ec	 mov	 eax, DWORD PTR _t$[ebp]
  00099	31 06		 xor	 DWORD PTR [esi], eax
  0009b	8b 45 f0	 mov	 eax, DWORD PTR _t$[ebp+4]
  0009e	31 46 04	 xor	 DWORD PTR [esi+4], eax
  000a1	56		 push	 esi
  000a2	ff 75 dc	 push	 DWORD PTR _cipher$[ebp]
  000a5	e8 00 00 00 00	 call	 _EncipherBlock@12

; 893  : 
; 894  : 		Xor64 ((unsigned __int64 *)p, (unsigned __int64 *)t);

  000aa	8b 45 ec	 mov	 eax, DWORD PTR _t$[ebp]
  000ad	31 06		 xor	 DWORD PTR [esi], eax
  000af	8b 45 f0	 mov	 eax, DWORD PTR _t$[ebp+4]
  000b2	31 46 04	 xor	 DWORD PTR [esi+4], eax

; 895  : 
; 896  : 		p += 8;

  000b5	83 c6 08	 add	 esi, 8

; 897  : 
; 898  : 		if (i[7] != 0xff)

  000b8	80 7d fb ff	 cmp	 BYTE PTR _i$[ebp+7], 255 ; 000000ffH
  000bc	74 05		 je	 SHORT $LN7@EncryptBuf@2

; 899  : 			i[7]++;

  000be	fe 45 fb	 inc	 BYTE PTR _i$[ebp+7]

; 900  : 		else

  000c1	eb 1e		 jmp	 SHORT $LN9@EncryptBuf@2
$LN7@EncryptBuf@2:

; 901  : 			*(unsigned __int64 *)i = BE64 ( BE64(*(unsigned __int64 *)i) + 1 );

  000c3	ff 75 f8	 push	 DWORD PTR _i$[ebp+4]
  000c6	ff 75 f4	 push	 DWORD PTR _i$[ebp]
  000c9	e8 00 00 00 00	 call	 _MirrorBytes64@8
  000ce	83 c0 01	 add	 eax, 1
  000d1	83 d2 00	 adc	 edx, 0
  000d4	52		 push	 edx
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 _MirrorBytes64@8
  000db	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
  000de	89 55 f8	 mov	 DWORD PTR _i$[ebp+4], edx
$LN9@EncryptBuf@2:
  000e1	83 45 e4 01	 add	 DWORD PTR _b$[ebp], 1
  000e5	83 55 e8 00	 adc	 DWORD PTR _b$[ebp+4], 0
  000e9	39 5d e8	 cmp	 DWORD PTR _b$[ebp+4], ebx
  000ec	72 97		 jb	 SHORT $LL10@EncryptBuf@2

; 886  : 
; 887  : 	for (b = 0; b < length >> 3; b++)

  000ee	77 08		 ja	 SHORT $LN5@EncryptBuf@2
  000f0	8b 45 d4	 mov	 eax, DWORD PTR tv169[ebp]
  000f3	39 45 e4	 cmp	 DWORD PTR _b$[ebp], eax
  000f6	72 8d		 jb	 SHORT $LL10@EncryptBuf@2
$LN5@EncryptBuf@2:

; 902  : 	}
; 903  : 
; 904  : 	FAST_ERASE64 (t, sizeof(t));

  000f8	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _t$[ebp], 0
  000ff	5f		 pop	 edi
  00100	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _t$[ebp+4], 0

; 905  : }

  00107	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010a	5e		 pop	 esi
  0010b	33 cd		 xor	 ecx, ebp
  0010d	5b		 pop	 ebx
  0010e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00113	c9		 leave
  00114	c2 18 00	 ret	 24			; 00000018H
$LN28@EncryptBuf@2:
_EncryptBufferLRW64@24 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_DecryptBufferLRW64@24
; Function compile flags: /Ogsp
;	COMDAT _DecryptBufferLRW64@24
_TEXT	SEGMENT
tv169 = -44						; size = 8
_cipher$ = -36						; size = 4
_ks$ = -32						; size = 4
_b$ = -28						; size = 8
_t$ = -20						; size = 8
_i$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_blockIndex$ = 20					; size = 8
_cryptoInfo$ = 28					; size = 4
_DecryptBufferLRW64@24 PROC				; COMDAT

; 966  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _buffer$[ebp]
  00017	57		 push	 edi
  00018	8b 7d 1c	 mov	 edi, DWORD PTR _cryptoInfo$[ebp]

; 967  : 	/* Deprecated/legacy */
; 968  : 
; 969  : 	int cipher = EAGetFirstCipher (cryptoInfo->ea);

  0001b	8b 07		 mov	 eax, DWORD PTR [edi]

; 970  : 	unsigned __int8 *p = buffer;
; 971  : 	unsigned __int8 *ks = cryptoInfo->ks;
; 972  : 	unsigned __int8 i[8];
; 973  : 	unsigned __int8 t[8];
; 974  : 	unsigned __int64 b;
; 975  : 
; 976  : 	*(unsigned __int64 *)i = BE64(blockIndex);

  0001d	ff 75 18	 push	 DWORD PTR _blockIndex$[ebp+4]
  00020	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00023	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax]
  00029	ff 75 14	 push	 DWORD PTR _blockIndex$[ebp]
  0002c	89 45 dc	 mov	 DWORD PTR _cipher$[ebp], eax
  0002f	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  00032	89 45 e0	 mov	 DWORD PTR _ks$[ebp], eax
  00035	e8 00 00 00 00	 call	 _MirrorBytes64@8
  0003a	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
  0003d	89 55 f8	 mov	 DWORD PTR _i$[ebp+4], edx

; 977  : 
; 978  : 	if (length % 8)

  00040	8b 55 0c	 mov	 edx, DWORD PTR _length$[ebp]
  00043	8b c2		 mov	 eax, edx
  00045	83 e0 07	 and	 eax, 7
  00048	33 c9		 xor	 ecx, ecx
  0004a	0b c1		 or	 eax, ecx
  0004c	74 14		 je	 SHORT $LN11@DecryptBuf

; 979  : 		TC_THROW_FATAL_EXCEPTION;

  0004e	68 43 54 00 00	 push	 21571			; 00005443H
  00053	51		 push	 ecx
  00054	51		 push	 ecx
  00055	68 d3 03 00 00	 push	 979			; 000003d3H
  0005a	6a 29		 push	 41			; 00000029H
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN29@DecryptBuf:
$LN11@DecryptBuf:

; 980  : 
; 981  : 	for (b = 0; b < length >> 3; b++)

  00062	8b 5d 10	 mov	 ebx, DWORD PTR _length$[ebp+4]
  00065	0f ac da 03	 shrd	 edx, ebx, 3
  00069	c1 eb 03	 shr	 ebx, 3
  0006c	89 4d e4	 mov	 DWORD PTR _b$[ebp], ecx
  0006f	89 4d e8	 mov	 DWORD PTR _b$[ebp+4], ecx
  00072	89 55 d4	 mov	 DWORD PTR tv169[ebp], edx
  00075	85 db		 test	 ebx, ebx
  00077	72 7f		 jb	 SHORT $LN5@DecryptBuf
  00079	77 04		 ja	 SHORT $LN25@DecryptBuf
  0007b	3b d1		 cmp	 edx, ecx
  0007d	76 79		 jbe	 SHORT $LN5@DecryptBuf
$LN25@DecryptBuf:
  0007f	81 c7 a8 29 00
	00		 add	 edi, 10664		; 000029a8H
$LL10@DecryptBuf:

; 982  : 	{
; 983  : 		Gf64MulTab (i, t, &cryptoInfo->gf_ctx);

  00085	57		 push	 edi
  00086	8d 45 ec	 lea	 eax, DWORD PTR _t$[ebp]
  00089	50		 push	 eax
  0008a	8d 45 f4	 lea	 eax, DWORD PTR _i$[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 _Gf64MulTab@12

; 984  : 		Xor64 ((unsigned __int64 *)p, (unsigned __int64 *)t);
; 985  : 
; 986  : 		DecipherBlock (cipher, p, ks);

  00093	ff 75 e0	 push	 DWORD PTR _ks$[ebp]
  00096	8b 45 ec	 mov	 eax, DWORD PTR _t$[ebp]
  00099	31 06		 xor	 DWORD PTR [esi], eax
  0009b	8b 45 f0	 mov	 eax, DWORD PTR _t$[ebp+4]
  0009e	31 46 04	 xor	 DWORD PTR [esi+4], eax
  000a1	56		 push	 esi
  000a2	ff 75 dc	 push	 DWORD PTR _cipher$[ebp]
  000a5	e8 00 00 00 00	 call	 _DecipherBlock@12

; 987  : 
; 988  : 		Xor64 ((unsigned __int64 *)p, (unsigned __int64 *)t);

  000aa	8b 45 ec	 mov	 eax, DWORD PTR _t$[ebp]
  000ad	31 06		 xor	 DWORD PTR [esi], eax
  000af	8b 45 f0	 mov	 eax, DWORD PTR _t$[ebp+4]
  000b2	31 46 04	 xor	 DWORD PTR [esi+4], eax

; 989  : 
; 990  : 		p += 8;

  000b5	83 c6 08	 add	 esi, 8

; 991  : 
; 992  : 		if (i[7] != 0xff)

  000b8	80 7d fb ff	 cmp	 BYTE PTR _i$[ebp+7], 255 ; 000000ffH
  000bc	74 05		 je	 SHORT $LN7@DecryptBuf

; 993  : 			i[7]++;

  000be	fe 45 fb	 inc	 BYTE PTR _i$[ebp+7]

; 994  : 		else

  000c1	eb 1e		 jmp	 SHORT $LN9@DecryptBuf
$LN7@DecryptBuf:

; 995  : 			*(unsigned __int64 *)i = BE64 ( BE64(*(unsigned __int64 *)i) + 1 );

  000c3	ff 75 f8	 push	 DWORD PTR _i$[ebp+4]
  000c6	ff 75 f4	 push	 DWORD PTR _i$[ebp]
  000c9	e8 00 00 00 00	 call	 _MirrorBytes64@8
  000ce	83 c0 01	 add	 eax, 1
  000d1	83 d2 00	 adc	 edx, 0
  000d4	52		 push	 edx
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 _MirrorBytes64@8
  000db	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
  000de	89 55 f8	 mov	 DWORD PTR _i$[ebp+4], edx
$LN9@DecryptBuf:
  000e1	83 45 e4 01	 add	 DWORD PTR _b$[ebp], 1
  000e5	83 55 e8 00	 adc	 DWORD PTR _b$[ebp+4], 0
  000e9	39 5d e8	 cmp	 DWORD PTR _b$[ebp+4], ebx
  000ec	72 97		 jb	 SHORT $LL10@DecryptBuf

; 980  : 
; 981  : 	for (b = 0; b < length >> 3; b++)

  000ee	77 08		 ja	 SHORT $LN5@DecryptBuf
  000f0	8b 45 d4	 mov	 eax, DWORD PTR tv169[ebp]
  000f3	39 45 e4	 cmp	 DWORD PTR _b$[ebp], eax
  000f6	72 8d		 jb	 SHORT $LL10@DecryptBuf
$LN5@DecryptBuf:

; 996  : 	}
; 997  : 
; 998  : 	FAST_ERASE64 (t, sizeof(t));

  000f8	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _t$[ebp], 0
  000ff	5f		 pop	 edi
  00100	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _t$[ebp+4], 0

; 999  : }

  00107	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010a	5e		 pop	 esi
  0010b	33 cd		 xor	 ecx, ebp
  0010d	5b		 pop	 ebx
  0010e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00113	c9		 leave
  00114	c2 18 00	 ret	 24			; 00000018H
$LN28@DecryptBuf:
_DecryptBufferLRW64@24 ENDP
_TEXT	ENDS
EXTRN	_crc32int@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _InitSectorIVAndWhitening@24
_TEXT	SEGMENT
_iv64$ = -32						; size = 32
_unitNo$ = 8						; size = 8
_blockSize$ = 16					; size = 4
_iv$ = 20						; size = 4
_whitening$ = 24					; size = 4
_InitSectorIVAndWhitening@24 PROC			; COMDAT
; _ivSeed$ = eax

; 1010 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 20	 sub	 esp, 32			; 00000020H

; 1011 : 
; 1012 : 	/* IMPORTANT: This function has been deprecated (legacy) */
; 1013 : 
; 1014 : 	unsigned __int64 iv64[4];
; 1015 : 	unsigned __int32 *iv32 = (unsigned __int32 *) iv64;
; 1016 : 
; 1017 : 	iv64[0] = ivSeed[0] ^ LE64(unitNo);

  00008	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0000d	33 4d 08	 xor	 ecx, DWORD PTR _unitNo$[ebp]
  00010	33 55 0c	 xor	 edx, DWORD PTR _unitNo$[ebp+4]
  00013	53		 push	 ebx

; 1018 : 	iv64[1] = ivSeed[1] ^ LE64(unitNo);
; 1019 : 	iv64[2] = ivSeed[2] ^ LE64(unitNo);

  00014	8b 58 14	 mov	 ebx, DWORD PTR [eax+20]
  00017	33 5d 0c	 xor	 ebx, DWORD PTR _unitNo$[ebp+4]
  0001a	56		 push	 esi
  0001b	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0001e	33 75 08	 xor	 esi, DWORD PTR _unitNo$[ebp]
  00021	57		 push	 edi
  00022	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]
  00025	33 7d 0c	 xor	 edi, DWORD PTR _unitNo$[ebp+4]
  00028	89 4d e0	 mov	 DWORD PTR _iv64$[ebp], ecx
  0002b	89 7d ec	 mov	 DWORD PTR _iv64$[ebp+12], edi
  0002e	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
  00031	33 7d 08	 xor	 edi, DWORD PTR _unitNo$[ebp]

; 1020 : 	if (blockSize == 16)

  00034	83 7d 10 10	 cmp	 DWORD PTR _blockSize$[ebp], 16 ; 00000010H
  00038	89 55 e4	 mov	 DWORD PTR _iv64$[ebp+4], edx
  0003b	89 75 e8	 mov	 DWORD PTR _iv64$[ebp+8], esi
  0003e	89 7d f0	 mov	 DWORD PTR _iv64$[ebp+16], edi
  00041	89 5d f4	 mov	 DWORD PTR _iv64$[ebp+20], ebx
  00044	75 12		 jne	 SHORT $LN6@InitSector

; 1021 : 	{
; 1022 : 		iv64[3] = ivSeed[3] ^ LE64(unitNo);

  00046	8b 78 18	 mov	 edi, DWORD PTR [eax+24]
  00049	33 7d 08	 xor	 edi, DWORD PTR _unitNo$[ebp]
  0004c	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0004f	33 45 0c	 xor	 eax, DWORD PTR _unitNo$[ebp+4]
  00052	89 7d f8	 mov	 DWORD PTR _iv64$[ebp+24], edi
  00055	89 45 fc	 mov	 DWORD PTR _iv64$[ebp+28], eax
$LN6@InitSector:

; 1023 : 	}
; 1024 : 
; 1025 : 	iv[0] = iv32[0];
; 1026 : 	iv[1] = iv32[1];
; 1027 : 
; 1028 : 	switch (blockSize)

  00058	83 7d 10 08	 cmp	 DWORD PTR _blockSize$[ebp], 8
  0005c	8b 45 14	 mov	 eax, DWORD PTR _iv$[ebp]
  0005f	89 08		 mov	 DWORD PTR [eax], ecx
  00061	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00064	74 50		 je	 SHORT $LN2@InitSector
  00066	83 7d 10 10	 cmp	 DWORD PTR _blockSize$[ebp], 16 ; 00000010H
  0006a	74 16		 je	 SHORT $LN3@InitSector

; 1047 : 		break;
; 1048 : 
; 1049 : 	default:
; 1050 : 		TC_THROW_FATAL_EXCEPTION;

  0006c	68 43 54 00 00	 push	 21571			; 00005443H
  00071	6a 00		 push	 0
  00073	6a 00		 push	 0
  00075	68 1a 04 00 00	 push	 1050			; 0000041aH
  0007a	6a 29		 push	 41			; 00000029H
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN11@InitSector:
$LN3@InitSector:

; 1029 : 	{
; 1030 : 	case 16:
; 1031 : 
; 1032 : 		// 128-bit block
; 1033 : 
; 1034 : 		iv[2] = iv32[2];
; 1035 : 		iv[3] = iv32[3];

  00082	8b 4d ec	 mov	 ecx, DWORD PTR _iv64$[ebp+12]
  00085	89 70 08	 mov	 DWORD PTR [eax+8], esi
  00088	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 1036 : 
; 1037 : 		whitening[0] = LE32( crc32int ( &iv32[4] ) ^ crc32int ( &iv32[7] ) );

  0008b	8d 45 f0	 lea	 eax, DWORD PTR _iv64$[ebp+16]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 _crc32int@4
  00094	8b f8		 mov	 edi, eax
  00096	8d 45 fc	 lea	 eax, DWORD PTR _iv64$[ebp+28]
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 _crc32int@4
  0009f	8b 75 18	 mov	 esi, DWORD PTR _whitening$[ebp]
  000a2	33 f8		 xor	 edi, eax

; 1038 : 		whitening[1] = LE32( crc32int ( &iv32[5] ) ^ crc32int ( &iv32[6] ) );

  000a4	8d 45 f4	 lea	 eax, DWORD PTR _iv64$[ebp+20]
  000a7	50		 push	 eax
  000a8	89 3e		 mov	 DWORD PTR [esi], edi
  000aa	e8 00 00 00 00	 call	 _crc32int@4
  000af	8b f8		 mov	 edi, eax
  000b1	8d 45 f8	 lea	 eax, DWORD PTR _iv64$[ebp+24]

; 1039 : 		break;

  000b4	eb 29		 jmp	 SHORT $LN10@InitSector
$LN2@InitSector:

; 1040 : 
; 1041 : 	case 8:
; 1042 : 
; 1043 : 		// 64-bit block
; 1044 : 
; 1045 : 		whitening[0] = LE32( crc32int ( &iv32[2] ) ^ crc32int ( &iv32[5] ) );

  000b6	8d 45 f4	 lea	 eax, DWORD PTR _iv64$[ebp+20]
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 _crc32int@4
  000bf	8b f8		 mov	 edi, eax
  000c1	8d 45 e8	 lea	 eax, DWORD PTR _iv64$[ebp+8]
  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 _crc32int@4
  000ca	8b 75 18	 mov	 esi, DWORD PTR _whitening$[ebp]
  000cd	33 f8		 xor	 edi, eax

; 1046 : 		whitening[1] = LE32( crc32int ( &iv32[3] ) ^ crc32int ( &iv32[4] ) );

  000cf	8d 45 f0	 lea	 eax, DWORD PTR _iv64$[ebp+16]
  000d2	50		 push	 eax
  000d3	89 3e		 mov	 DWORD PTR [esi], edi
  000d5	e8 00 00 00 00	 call	 _crc32int@4
  000da	8b f8		 mov	 edi, eax
  000dc	8d 45 ec	 lea	 eax, DWORD PTR _iv64$[ebp+12]
$LN10@InitSector:
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 _crc32int@4
  000e5	33 f8		 xor	 edi, eax
  000e7	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  000ea	5f		 pop	 edi
  000eb	5e		 pop	 esi
  000ec	5b		 pop	 ebx

; 1051 : 	}
; 1052 : }

  000ed	c9		 leave
  000ee	c2 14 00	 ret	 20			; 00000014H
$LN9@InitSector:
_InitSectorIVAndWhitening@24 ENDP
_TEXT	ENDS
PUBLIC	_DataUnit2LRWIndex@16
; Function compile flags: /Ogsp
;	COMDAT _DataUnit2LRWIndex@16
_TEXT	SEGMENT
_dataUnit$ = 8						; size = 8
_blockSize$ = 16					; size = 4
_ci$ = 20						; size = 4
_DataUnit2LRWIndex@16 PROC				; COMDAT

; 1342 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1343 : 	/* Deprecated/legacy */
; 1344 : 
; 1345 : 	if (ci->hiddenVolume)

  00005	8b 45 14	 mov	 eax, DWORD PTR _ci$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	39 88 a0 29 00
	00		 cmp	 DWORD PTR [eax+10656], ecx
  00010	74 21		 je	 SHORT $LN7@DataUnit2L

; 1346 : 		dataUnit -= ci->hiddenVolumeOffset / ENCRYPTION_DATA_UNIT_SIZE;

  00012	8b 90 18 44 00
	00		 mov	 edx, DWORD PTR [eax+17432]
  00018	56		 push	 esi
  00019	8b b0 1c 44 00
	00		 mov	 esi, DWORD PTR [eax+17436]
  0001f	8b 45 08	 mov	 eax, DWORD PTR _dataUnit$[ebp]
  00022	0f ac f2 09	 shrd	 edx, esi, 9
  00026	c1 ee 09	 shr	 esi, 9
  00029	2b c2		 sub	 eax, edx
  0002b	8b 55 0c	 mov	 edx, DWORD PTR _dataUnit$[ebp+4]
  0002e	1b d6		 sbb	 edx, esi
  00030	5e		 pop	 esi

; 1347 : 	else

  00031	eb 0c		 jmp	 SHORT $LN6@DataUnit2L
$LN7@DataUnit2L:

; 1348 : 		dataUnit -= TC_VOLUME_HEADER_SIZE_LEGACY / ENCRYPTION_DATA_UNIT_SIZE;	// Compensate for the volume header size

  00033	8b 45 08	 mov	 eax, DWORD PTR _dataUnit$[ebp]
  00036	8b 55 0c	 mov	 edx, DWORD PTR _dataUnit$[ebp+4]
  00039	83 c0 ff	 add	 eax, -1
  0003c	83 d2 ff	 adc	 edx, -1
$LN6@DataUnit2L:

; 1349 : 
; 1350 : 	switch (blockSize)

  0003f	83 7d 10 08	 cmp	 DWORD PTR _blockSize$[ebp], 8
  00043	74 23		 je	 SHORT $LN3@DataUnit2L
  00045	83 7d 10 10	 cmp	 DWORD PTR _blockSize$[ebp], 16 ; 00000010H
  00049	74 14		 je	 SHORT $LN2@DataUnit2L

; 1357 : 
; 1358 : 	default:
; 1359 : 		TC_THROW_FATAL_EXCEPTION;

  0004b	68 43 54 00 00	 push	 21571			; 00005443H
  00050	51		 push	 ecx
  00051	51		 push	 ecx
  00052	68 4f 05 00 00	 push	 1359			; 0000054fH
  00057	6a 29		 push	 41			; 00000029H
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN12@DataUnit2L:
$LN2@DataUnit2L:

; 1354 : 
; 1355 : 	case 16:
; 1356 : 		return (dataUnit << 5) | 1;

  0005f	0f a4 c2 05	 shld	 edx, eax, 5
  00063	c1 e0 05	 shl	 eax, 5
  00066	eb 07		 jmp	 SHORT $LN11@DataUnit2L
$LN3@DataUnit2L:

; 1351 : 	{
; 1352 : 	case 8:
; 1353 : 		return (dataUnit << 6) | 1;

  00068	0f a4 c2 06	 shld	 edx, eax, 6
  0006c	c1 e0 06	 shl	 eax, 6
$LN11@DataUnit2L:
  0006f	83 c8 01	 or	 eax, 1

; 1360 : 	}
; 1361 : 
; 1362 : 	return 0;
; 1363 : }

  00072	5d		 pop	 ebp
  00073	c2 10 00	 ret	 16			; 00000010H
$LN10@DataUnit2L:
_DataUnit2LRWIndex@16 ENDP
_TEXT	ENDS
PUBLIC	_EncryptDataUnits@16
EXTRN	_EncryptionThreadPoolDoWork@20:PROC
; Function compile flags: /Ogsp
;	COMDAT _EncryptDataUnits@16
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_structUnitNo$ = 12					; size = 4
_nbrUnits$ = 16						; size = 4
_ci$ = 20						; size = 4
_EncryptDataUnits@16 PROC				; COMDAT

; 1372 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1373 : 	EncryptionThreadPoolDoWork (EncryptDataUnitsWork, buf, structUnitNo, nbrUnits, ci);

  00005	ff 75 14	 push	 DWORD PTR _ci$[ebp]
  00008	ff 75 10	 push	 DWORD PTR _nbrUnits$[ebp]
  0000b	ff 75 0c	 push	 DWORD PTR _structUnitNo$[ebp]
  0000e	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  00011	6a 00		 push	 0
  00013	e8 00 00 00 00	 call	 _EncryptionThreadPoolDoWork@20

; 1374 : }

  00018	5d		 pop	 ebp
  00019	c2 10 00	 ret	 16			; 00000010H
_EncryptDataUnits@16 ENDP
_TEXT	ENDS
PUBLIC	_DecryptDataUnits@16
; Function compile flags: /Ogsp
;	COMDAT _DecryptDataUnits@16
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_structUnitNo$ = 12					; size = 4
_nbrUnits$ = 16						; size = 4
_ci$ = 20						; size = 4
_DecryptDataUnits@16 PROC				; COMDAT

; 1595 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1596 : 	EncryptionThreadPoolDoWork (DecryptDataUnitsWork, buf, structUnitNo, nbrUnits, ci);

  00005	ff 75 14	 push	 DWORD PTR _ci$[ebp]
  00008	ff 75 10	 push	 DWORD PTR _nbrUnits$[ebp]
  0000b	ff 75 0c	 push	 DWORD PTR _structUnitNo$[ebp]
  0000e	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  00011	6a 01		 push	 1
  00013	e8 00 00 00 00	 call	 _EncryptionThreadPoolDoWork@20

; 1597 : }

  00018	5d		 pop	 ebp
  00019	c2 10 00	 ret	 16			; 00000010H
_DecryptDataUnits@16 ENDP
_TEXT	ENDS
PUBLIC	_IsAesHwCpuSupported@0
EXTRN	_is_aes_hw_cpu_supported@0:PROC
; Function compile flags: /Ogsp
;	COMDAT _IsAesHwCpuSupported@0
_TEXT	SEGMENT
_IsAesHwCpuSupported@0 PROC				; COMDAT

; 1844 : 	static BOOL state = FALSE;
; 1845 : 	static BOOL stateValid = FALSE;
; 1846 : 
; 1847 : 	if (!stateValid)

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?stateValid@?1??IsAesHwCpuSupported@@9@9, 0
  00007	75 1c		 jne	 SHORT $LN1@IsAesHwCpu

; 1848 : 	{
; 1849 : 		state = is_aes_hw_cpu_supported() ? TRUE : FALSE;

  00009	e8 00 00 00 00	 call	 _is_aes_hw_cpu_supported@0
  0000e	33 c9		 xor	 ecx, ecx
  00010	84 c0		 test	 al, al
  00012	0f 95 c1	 setne	 cl

; 1850 : 		stateValid = TRUE;

  00015	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?stateValid@?1??IsAesHwCpuSupported@@9@9, 1
  0001f	89 0d 00 00 00
	00		 mov	 DWORD PTR ?state@?1??IsAesHwCpuSupported@@9@9, ecx
$LN1@IsAesHwCpu:

; 1851 : 	}
; 1852 : 
; 1853 : 	return state && !HwEncryptionDisabled;

  00025	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?state@?1??IsAesHwCpuSupported@@9@9, 0
  0002c	74 0d		 je	 SHORT $LN4@IsAesHwCpu
  0002e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _HwEncryptionDisabled, 0
  00035	75 04		 jne	 SHORT $LN4@IsAesHwCpu
  00037	33 c0		 xor	 eax, eax
  00039	40		 inc	 eax

; 1854 : }

  0003a	c3		 ret	 0
$LN4@IsAesHwCpu:

; 1851 : 	}
; 1852 : 
; 1853 : 	return state && !HwEncryptionDisabled;

  0003b	33 c0		 xor	 eax, eax

; 1854 : }

  0003d	c3		 ret	 0
_IsAesHwCpuSupported@0 ENDP
_TEXT	ENDS
PUBLIC	_EnableHwEncryption@4
; Function compile flags: /Ogsp
;	COMDAT _EnableHwEncryption@4
_TEXT	SEGMENT
_enable$ = 8						; size = 4
_EnableHwEncryption@4 PROC				; COMDAT

; 1857 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1858 : #if defined (TC_WINDOWS_BOOT)
; 1859 : 	if (enable)
; 1860 : 		aes_hw_cpu_enable_sse();
; 1861 : #endif
; 1862 : 
; 1863 : 	HwEncryptionDisabled = !enable;

  00005	33 c0		 xor	 eax, eax
  00007	39 45 08	 cmp	 DWORD PTR _enable$[ebp], eax
  0000a	0f 94 c0	 sete	 al
  0000d	a3 00 00 00 00	 mov	 DWORD PTR _HwEncryptionDisabled, eax

; 1864 : }

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
_EnableHwEncryption@4 ENDP
_TEXT	ENDS
PUBLIC	_IsHwEncryptionEnabled@0
; Function compile flags: /Ogsp
;	COMDAT _IsHwEncryptionEnabled@0
_TEXT	SEGMENT
_IsHwEncryptionEnabled@0 PROC				; COMDAT

; 1868 : 	return !HwEncryptionDisabled;

  00000	33 c0		 xor	 eax, eax
  00002	39 05 00 00 00
	00		 cmp	 DWORD PTR _HwEncryptionDisabled, eax
  00008	0f 94 c0	 sete	 al

; 1869 : }

  0000b	c3		 ret	 0
_IsHwEncryptionEnabled@0 ENDP
_TEXT	ENDS
PUBLIC	_CipherInit@12
EXTRN	_aes_decrypt_key256@8:PROC
EXTRN	_aes_encrypt_key256@8:PROC
EXTRN	_serpent_set_key@12:PROC
EXTRN	_twofish_set_key@12:PROC
EXTRN	_BlowfishSetKey@12:PROC
EXTRN	_Cast5SetKey@12:PROC
EXTRN	_TripleDesSetKey@12:PROC
; Function compile flags: /Ogsp
;	COMDAT _CipherInit@12
_TEXT	SEGMENT
tv200 = -12						; size = 8
_retVal$ = -4						; size = 4
_cipher$ = 8						; size = 4
_key$ = 12						; size = 4
_ks$ = 16						; size = 4
_CipherInit@12 PROC					; COMDAT

; 115  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 116  : 	int retVal = ERR_SUCCESS;
; 117  : 
; 118  : 	switch (cipher)

  00008	8b 45 08	 mov	 eax, DWORD PTR _cipher$[ebp]
  0000b	83 65 fc 00	 and	 DWORD PTR _retVal$[ebp], 0
  0000f	48		 dec	 eax
  00010	56		 push	 esi
  00011	0f 84 f2 00 00
	00		 je	 $LN11@CipherInit
  00017	48		 dec	 eax
  00018	0f 84 d0 00 00
	00		 je	 $LN8@CipherInit
  0001e	48		 dec	 eax
  0001f	0f 84 ae 00 00
	00		 je	 $LN7@CipherInit
  00025	48		 dec	 eax
  00026	0f 84 90 00 00
	00		 je	 $LN6@CipherInit
  0002c	48		 dec	 eax
  0002d	74 76		 je	 SHORT $LN5@CipherInit
  0002f	48		 dec	 eax

; 162  : 
; 163  : 		break;
; 164  : 
; 165  : #endif	// TC_WINDOWS_BOOT
; 166  : 
; 167  : 	default:
; 168  : 		// Unknown/wrong cipher ID
; 169  : 		return ERR_CIPHER_INIT_FAILURE;

  00030	0f 85 e3 00 00
	00		 jne	 $LN29@CipherInit
  00036	53		 push	 ebx
  00037	57		 push	 edi
  00038	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  0003b	6a 06		 push	 6
  0003d	e8 00 00 00 00	 call	 _CipherGet@4
  00042	ff 70 0c	 push	 DWORD PTR [eax+12]
  00045	8b 75 0c	 mov	 esi, DWORD PTR _key$[ebp]
  00048	56		 push	 esi
  00049	e8 00 00 00 00	 call	 _TripleDesSetKey@12
  0004e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00050	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00053	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00056	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  00059	89 4d f4	 mov	 DWORD PTR tv200[ebp], ecx
  0005c	89 55 f8	 mov	 DWORD PTR tv200[ebp+4], edx
  0005f	33 cf		 xor	 ecx, edi
  00061	33 d3		 xor	 edx, ebx
  00063	b8 fe fe fe fe	 mov	 eax, -16843010		; fefefefeH
  00068	23 c8		 and	 ecx, eax
  0006a	23 d0		 and	 edx, eax
  0006c	0b ca		 or	 ecx, edx
  0006e	74 24		 je	 SHORT $LN2@CipherInit
  00070	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00073	8b 76 14	 mov	 esi, DWORD PTR [esi+20]
  00076	8b ca		 mov	 ecx, edx
  00078	33 cf		 xor	 ecx, edi
  0007a	8b fe		 mov	 edi, esi
  0007c	33 fb		 xor	 edi, ebx
  0007e	23 c8		 and	 ecx, eax
  00080	23 f8		 and	 edi, eax
  00082	0b cf		 or	 ecx, edi
  00084	74 0e		 je	 SHORT $LN2@CipherInit
  00086	33 55 f4	 xor	 edx, DWORD PTR tv200[ebp]
  00089	33 75 f8	 xor	 esi, DWORD PTR tv200[ebp+4]
  0008c	23 d0		 and	 edx, eax
  0008e	23 f0		 and	 esi, eax
  00090	0b d6		 or	 edx, esi
  00092	75 07		 jne	 SHORT $LN27@CipherInit
$LN2@CipherInit:

; 152  : 
; 153  : 	case TRIPLEDES:
; 154  : 		/* Deprecated/legacy */
; 155  : 		TripleDesSetKey (key, CipherGetKeySize (TRIPLEDES), (TDES_KEY *) ks);
; 156  : 
; 157  : 		// Verify whether all three DES keys are mutually different
; 158  : 		if (((*((__int64 *) key) ^ *((__int64 *) key+1)) & 0xFEFEFEFEFEFEFEFEULL) == 0
; 159  : 		|| ((*((__int64 *) key+1) ^ *((__int64 *) key+2)) & 0xFEFEFEFEFEFEFEFEULL) == 0
; 160  : 		|| ((*((__int64 *) key) ^ *((__int64 *) key+2)) & 0xFEFEFEFEFEFEFEFEULL) == 0)
; 161  : 			retVal = ERR_CIPHER_INIT_WEAK_KEY;		// Non-fatal error

  00094	c7 45 fc 12 00
	00 00		 mov	 DWORD PTR _retVal$[ebp], 18 ; 00000012H
$LN27@CipherInit:
  0009b	5f		 pop	 edi
  0009c	5b		 pop	 ebx
$LN26@CipherInit:

; 170  : 	}
; 171  : 
; 172  : 	return retVal;

  0009d	8b 45 fc	 mov	 eax, DWORD PTR _retVal$[ebp]
$LN14@CipherInit:
  000a0	5e		 pop	 esi

; 173  : }

  000a1	c9		 leave
  000a2	c2 0c 00	 ret	 12			; 0000000cH
$LN5@CipherInit:

; 147  : 
; 148  : 	case CAST:
; 149  : 		/* Deprecated/legacy */
; 150  : 		Cast5SetKey ((CAST_KEY *) ks, CipherGetKeySize(CAST), key);

  000a5	ff 75 0c	 push	 DWORD PTR _key$[ebp]
  000a8	6a 05		 push	 5
  000aa	e8 00 00 00 00	 call	 _CipherGet@4
  000af	ff 70 0c	 push	 DWORD PTR [eax+12]
  000b2	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  000b5	e8 00 00 00 00	 call	 _Cast5SetKey@12

; 151  : 		break;

  000ba	eb e1		 jmp	 SHORT $LN26@CipherInit
$LN6@CipherInit:

; 140  : 
; 141  : #ifndef TC_WINDOWS_BOOT
; 142  : 		
; 143  : 	case BLOWFISH:
; 144  : 		/* Deprecated/legacy */
; 145  : 		BlowfishSetKey ((BF_KEY *)ks, CipherGetKeySize(BLOWFISH), key);

  000bc	ff 75 0c	 push	 DWORD PTR _key$[ebp]
  000bf	6a 04		 push	 4
  000c1	e8 00 00 00 00	 call	 _CipherGet@4
  000c6	ff 70 0c	 push	 DWORD PTR [eax+12]
  000c9	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  000cc	e8 00 00 00 00	 call	 _BlowfishSetKey@12

; 146  : 		break;

  000d1	eb ca		 jmp	 SHORT $LN26@CipherInit
$LN7@CipherInit:

; 136  : 		
; 137  : 	case TWOFISH:
; 138  : 		twofish_set_key ((TwofishInstance *)ks, (const u4byte *)key, CipherGetKeySize(TWOFISH) * 8);

  000d3	6a 03		 push	 3
  000d5	e8 00 00 00 00	 call	 _CipherGet@4
  000da	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000dd	c1 e0 03	 shl	 eax, 3
  000e0	50		 push	 eax
  000e1	ff 75 0c	 push	 DWORD PTR _key$[ebp]
  000e4	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  000e7	e8 00 00 00 00	 call	 _twofish_set_key@12

; 139  : 		break;

  000ec	eb af		 jmp	 SHORT $LN26@CipherInit
$LN8@CipherInit:

; 127  : #else
; 128  : 		if (aes_set_key (key, (length_type) CipherGetKeySize(AES), (aes_context *) ks) != 0)
; 129  : 			return ERR_CIPHER_INIT_FAILURE;
; 130  : #endif
; 131  : 		break;
; 132  : 
; 133  : 	case SERPENT:
; 134  : 		serpent_set_key (key, CipherGetKeySize(SERPENT) * 8, ks);

  000ee	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  000f1	6a 02		 push	 2
  000f3	e8 00 00 00 00	 call	 _CipherGet@4
  000f8	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000fb	c1 e0 03	 shl	 eax, 3
  000fe	50		 push	 eax
  000ff	ff 75 0c	 push	 DWORD PTR _key$[ebp]
  00102	e8 00 00 00 00	 call	 _serpent_set_key@12

; 135  : 		break;

  00107	eb 94		 jmp	 SHORT $LN26@CipherInit
$LN11@CipherInit:

; 119  : 	{
; 120  : 	case AES:
; 121  : #ifndef TC_WINDOWS_BOOT
; 122  : 		if (aes_encrypt_key256 (key, (aes_encrypt_ctx *) ks) != EXIT_SUCCESS)

  00109	8b 75 10	 mov	 esi, DWORD PTR _ks$[ebp]
  0010c	56		 push	 esi
  0010d	ff 75 0c	 push	 DWORD PTR _key$[ebp]
  00110	e8 00 00 00 00	 call	 _aes_encrypt_key256@8
  00115	85 c0		 test	 eax, eax
  00117	74 05		 je	 SHORT $LN10@CipherInit
$LN29@CipherInit:

; 123  : 			return ERR_CIPHER_INIT_FAILURE;

  00119	6a 11		 push	 17			; 00000011H
  0011b	58		 pop	 eax
  0011c	eb 82		 jmp	 SHORT $LN14@CipherInit
$LN10@CipherInit:

; 124  : 
; 125  : 		if (aes_decrypt_key256 (key, (aes_decrypt_ctx *) (ks + sizeof(aes_encrypt_ctx))) != EXIT_SUCCESS)

  0011e	81 c6 f4 00 00
	00		 add	 esi, 244		; 000000f4H
  00124	56		 push	 esi
  00125	ff 75 0c	 push	 DWORD PTR _key$[ebp]
  00128	e8 00 00 00 00	 call	 _aes_decrypt_key256@8
  0012d	85 c0		 test	 eax, eax
  0012f	0f 84 68 ff ff
	ff		 je	 $LN26@CipherInit

; 126  : 			return ERR_CIPHER_INIT_FAILURE;

  00135	eb e2		 jmp	 SHORT $LN29@CipherInit
_CipherInit@12 ENDP
_TEXT	ENDS
PUBLIC	_EncipherBlocks@16
EXTRN	__imp__KeRestoreFloatingPointState@4:PROC
EXTRN	_aes_hw_cpu_encrypt_32_blocks@8:PROC
EXTRN	__imp__KeSaveFloatingPointState@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _EncipherBlocks@16
_TEXT	SEGMENT
_floatingPointState$ = -32				; size = 32
_cipher$ = 8						; size = 4
_dataPtr$ = 12						; size = 4
_ks$ = 16						; size = 4
_blockCount$ = 20					; size = 4
_EncipherBlocks@16 PROC					; COMDAT

; 203  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 20	 sub	 esp, 32			; 00000020H

; 204  : 	byte *data = dataPtr;
; 205  : #if defined (TC_WINDOWS_DRIVER) && !defined (_WIN64)
; 206  : 	KFLOATING_SAVE floatingPointState;
; 207  : #endif
; 208  : 
; 209  : 	if (cipher == AES
; 210  : 		&& (blockCount & (32 - 1)) == 0
; 211  : 		&& IsAesHwCpuSupported()
; 212  : #if defined (TC_WINDOWS_DRIVER) && !defined (_WIN64)
; 213  : 		&& NT_SUCCESS (KeSaveFloatingPointState (&floatingPointState))
; 214  : #endif
; 215  : 		)

  00008	83 7d 08 01	 cmp	 DWORD PTR _cipher$[ebp], 1
  0000c	53		 push	 ebx
  0000d	8b 5d 14	 mov	 ebx, DWORD PTR _blockCount$[ebp]
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	8b 7d 0c	 mov	 edi, DWORD PTR _dataPtr$[ebp]
  00015	75 45		 jne	 SHORT $LN16@EncipherBl@2
  00017	f6 c3 1f	 test	 bl, 31			; 0000001fH
  0001a	75 40		 jne	 SHORT $LN16@EncipherBl@2
  0001c	e8 00 00 00 00	 call	 _IsAesHwCpuSupported@0
  00021	85 c0		 test	 eax, eax
  00023	74 37		 je	 SHORT $LN16@EncipherBl@2
  00025	8d 45 e0	 lea	 eax, DWORD PTR _floatingPointState$[ebp]
  00028	50		 push	 eax
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSaveFloatingPointState@4
  0002f	85 c0		 test	 eax, eax
  00031	7c 29		 jl	 SHORT $LN16@EncipherBl@2

; 216  : 	{
; 217  : 		while (blockCount > 0)

  00033	85 db		 test	 ebx, ebx
  00035	76 19		 jbe	 SHORT $LN4@EncipherBl@2
  00037	8d 73 ff	 lea	 esi, DWORD PTR [ebx-1]
  0003a	c1 ee 05	 shr	 esi, 5
  0003d	46		 inc	 esi
$LL5@EncipherBl@2:

; 218  : 		{
; 219  : 			aes_hw_cpu_encrypt_32_blocks (ks, data);

  0003e	57		 push	 edi
  0003f	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  00042	e8 00 00 00 00	 call	 _aes_hw_cpu_encrypt_32_blocks@8

; 220  : 
; 221  : 			data += 32 * 16;

  00047	81 c7 00 02 00
	00		 add	 edi, 512		; 00000200H
  0004d	4e		 dec	 esi
  0004e	75 ee		 jne	 SHORT $LL5@EncipherBl@2
$LN4@EncipherBl@2:

; 222  : 			blockCount -= 32;
; 223  : 		}
; 224  : 
; 225  : #if defined (TC_WINDOWS_DRIVER) && !defined (_WIN64)
; 226  : 		KeRestoreFloatingPointState (&floatingPointState);

  00050	8d 45 e0	 lea	 eax, DWORD PTR _floatingPointState$[ebp]
  00053	50		 push	 eax
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeRestoreFloatingPointState@4

; 227  : #endif
; 228  : 	}
; 229  : 	else

  0005a	eb 20		 jmp	 SHORT $LN14@EncipherBl@2
$LN16@EncipherBl@2:

; 230  : 	{
; 231  : 		size_t blockSize = CipherGetBlockSize (cipher);

  0005c	ff 75 08	 push	 DWORD PTR _cipher$[ebp]
  0005f	e8 00 00 00 00	 call	 _CipherGet@4
  00064	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00067	eb 0f		 jmp	 SHORT $LN18@EncipherBl@2
$LL2@EncipherBl@2:

; 233  : 		{
; 234  : 			EncipherBlock (cipher, data, ks);

  00069	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  0006c	4b		 dec	 ebx
  0006d	57		 push	 edi
  0006e	ff 75 08	 push	 DWORD PTR _cipher$[ebp]
  00071	e8 00 00 00 00	 call	 _EncipherBlock@12

; 235  : 			data += blockSize;

  00076	03 fe		 add	 edi, esi
$LN18@EncipherBl@2:

; 232  : 		while (blockCount-- > 0)

  00078	85 db		 test	 ebx, ebx
  0007a	77 ed		 ja	 SHORT $LL2@EncipherBl@2
$LN14@EncipherBl@2:
  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx

; 236  : 		}
; 237  : 	}
; 238  : }

  0007f	c9		 leave
  00080	c2 10 00	 ret	 16			; 00000010H
_EncipherBlocks@16 ENDP
_TEXT	ENDS
PUBLIC	_DecipherBlocks@16
EXTRN	_aes_hw_cpu_decrypt_32_blocks@8:PROC
; Function compile flags: /Ogsp
;	COMDAT _DecipherBlocks@16
_TEXT	SEGMENT
_floatingPointState$ = -32				; size = 32
tv166 = 8						; size = 4
_cipher$ = 8						; size = 4
_dataPtr$ = 12						; size = 4
_ks$ = 16						; size = 4
_blockCount$ = 20					; size = 4
_DecipherBlocks@16 PROC					; COMDAT

; 272  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 20	 sub	 esp, 32			; 00000020H

; 273  : 	byte *data = dataPtr;
; 274  : #if defined (TC_WINDOWS_DRIVER) && !defined (_WIN64)
; 275  : 	KFLOATING_SAVE floatingPointState;
; 276  : #endif
; 277  : 
; 278  : 	if (cipher == AES
; 279  : 		&& (blockCount & (32 - 1)) == 0
; 280  : 		&& IsAesHwCpuSupported()
; 281  : #if defined (TC_WINDOWS_DRIVER) && !defined (_WIN64)
; 282  : 		&& NT_SUCCESS (KeSaveFloatingPointState (&floatingPointState))
; 283  : #endif
; 284  : 		)

  00008	83 7d 08 01	 cmp	 DWORD PTR _cipher$[ebp], 1
  0000c	53		 push	 ebx
  0000d	8b 5d 14	 mov	 ebx, DWORD PTR _blockCount$[ebp]
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	8b 7d 0c	 mov	 edi, DWORD PTR _dataPtr$[ebp]
  00015	75 50		 jne	 SHORT $LN17@DecipherBl@2
  00017	f6 c3 1f	 test	 bl, 31			; 0000001fH
  0001a	75 4b		 jne	 SHORT $LN17@DecipherBl@2
  0001c	e8 00 00 00 00	 call	 _IsAesHwCpuSupported@0
  00021	85 c0		 test	 eax, eax
  00023	74 42		 je	 SHORT $LN17@DecipherBl@2
  00025	8d 45 e0	 lea	 eax, DWORD PTR _floatingPointState$[ebp]
  00028	50		 push	 eax
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSaveFloatingPointState@4
  0002f	85 c0		 test	 eax, eax
  00031	7c 34		 jl	 SHORT $LN17@DecipherBl@2

; 285  : 	{
; 286  : 		while (blockCount > 0)

  00033	85 db		 test	 ebx, ebx
  00035	76 24		 jbe	 SHORT $LN4@DecipherBl@2
  00037	8b 45 10	 mov	 eax, DWORD PTR _ks$[ebp]
  0003a	8d 73 ff	 lea	 esi, DWORD PTR [ebx-1]

; 301  : 		while (blockCount-- > 0)

  0003d	05 f4 00 00 00	 add	 eax, 244		; 000000f4H
  00042	c1 ee 05	 shr	 esi, 5
  00045	89 45 08	 mov	 DWORD PTR tv166[ebp], eax
  00048	46		 inc	 esi
$LL5@DecipherBl@2:
  00049	57		 push	 edi
  0004a	ff 75 08	 push	 DWORD PTR tv166[ebp]
  0004d	e8 00 00 00 00	 call	 _aes_hw_cpu_decrypt_32_blocks@8
  00052	81 c7 00 02 00
	00		 add	 edi, 512		; 00000200H
  00058	4e		 dec	 esi
  00059	75 ee		 jne	 SHORT $LL5@DecipherBl@2
$LN4@DecipherBl@2:

; 287  : 		{
; 288  : 			aes_hw_cpu_decrypt_32_blocks ((byte *) ks + sizeof (aes_encrypt_ctx), data);
; 289  : 
; 290  : 			data += 32 * 16;
; 291  : 			blockCount -= 32;
; 292  : 		}
; 293  : 
; 294  : #if defined (TC_WINDOWS_DRIVER) && !defined (_WIN64)
; 295  : 		KeRestoreFloatingPointState (&floatingPointState);

  0005b	8d 45 e0	 lea	 eax, DWORD PTR _floatingPointState$[ebp]
  0005e	50		 push	 eax
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeRestoreFloatingPointState@4

; 296  : #endif
; 297  : 	}
; 298  : 	else

  00065	eb 20		 jmp	 SHORT $LN14@DecipherBl@2
$LN17@DecipherBl@2:

; 299  : 	{
; 300  : 		size_t blockSize = CipherGetBlockSize (cipher);

  00067	ff 75 08	 push	 DWORD PTR _cipher$[ebp]
  0006a	e8 00 00 00 00	 call	 _CipherGet@4
  0006f	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00072	eb 0f		 jmp	 SHORT $LN19@DecipherBl@2
$LL2@DecipherBl@2:

; 302  : 		{
; 303  : 			DecipherBlock (cipher, data, ks);

  00074	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  00077	4b		 dec	 ebx
  00078	57		 push	 edi
  00079	ff 75 08	 push	 DWORD PTR _cipher$[ebp]
  0007c	e8 00 00 00 00	 call	 _DecipherBlock@12

; 304  : 			data += blockSize;

  00081	03 fe		 add	 edi, esi
$LN19@DecipherBl@2:

; 301  : 		while (blockCount-- > 0)

  00083	85 db		 test	 ebx, ebx
  00085	77 ed		 ja	 SHORT $LL2@DecipherBl@2
$LN14@DecipherBl@2:
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx

; 305  : 		}
; 306  : 	}
; 307  : }

  0008a	c9		 leave
  0008b	c2 10 00	 ret	 16			; 00000010H
_DecipherBlocks@16 ENDP
_TEXT	ENDS
PUBLIC	_CipherSupportsIntraDataUnitParallelization@4
; Function compile flags: /Ogsp
;	COMDAT _CipherSupportsIntraDataUnitParallelization@4
_TEXT	SEGMENT
_cipher$ = 8						; size = 4
_CipherSupportsIntraDataUnitParallelization@4 PROC	; COMDAT

; 347  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 348  : 	return cipher == AES && IsAesHwCpuSupported();

  00005	83 7d 08 01	 cmp	 DWORD PTR _cipher$[ebp], 1
  00009	75 0e		 jne	 SHORT $LN3@CipherSupp
  0000b	e8 00 00 00 00	 call	 _IsAesHwCpuSupported@0
  00010	85 c0		 test	 eax, eax
  00012	74 05		 je	 SHORT $LN3@CipherSupp
  00014	33 c0		 xor	 eax, eax
  00016	40		 inc	 eax
  00017	eb 02		 jmp	 SHORT $LN4@CipherSupp
$LN3@CipherSupp:
  00019	33 c0		 xor	 eax, eax
$LN4@CipherSupp:

; 349  : }

  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
_CipherSupportsIntraDataUnitParallelization@4 ENDP
_TEXT	ENDS
PUBLIC	_EAGetCount@0
; Function compile flags: /Ogsp
;	COMDAT _EAGetCount@0
_TEXT	SEGMENT
_EAGetCount@0 PROC					; COMDAT

; 364  : 	int ea, count = 0;
; 365  : 
; 366  : 	for (ea = EAGetFirst (); ea != 0; ea = EAGetNext (ea))

  00000	33 c0		 xor	 eax, eax
  00002	33 d2		 xor	 edx, edx
  00004	40		 inc	 eax
$LL3@EAGetCount:
  00005	50		 push	 eax

; 367  : 	{
; 368  : 		count++;

  00006	42		 inc	 edx
  00007	e8 00 00 00 00	 call	 _EAGetNext@4
  0000c	85 c0		 test	 eax, eax
  0000e	75 f5		 jne	 SHORT $LL3@EAGetCount

; 369  : 	}
; 370  : 	return count;

  00010	8b c2		 mov	 eax, edx

; 371  : }

  00012	c3		 ret	 0
_EAGetCount@0 ENDP
_TEXT	ENDS
PUBLIC	_EAInit@12
; Function compile flags: /Ogsp
;	COMDAT _EAInit@12
_TEXT	SEGMENT
_retVal$ = -4						; size = 4
_ea$ = 8						; size = 4
_key$ = 12						; size = 4
_ks$ = 16						; size = 4
_EAInit@12 PROC						; COMDAT

; 383  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 384  : 	int c, retVal = ERR_SUCCESS;

  00006	83 65 fc 00	 and	 DWORD PTR _retVal$[ebp], 0

; 385  : 
; 386  : 	if (ea == 0)

  0000a	83 7d 08 00	 cmp	 DWORD PTR _ea$[ebp], 0
  0000e	75 05		 jne	 SHORT $LN8@EAInit

; 387  : 		return ERR_CIPHER_INIT_FAILURE;

  00010	6a 11		 push	 17			; 00000011H
  00012	58		 pop	 eax
  00013	eb 51		 jmp	 SHORT $LN9@EAInit
$LN8@EAInit:

; 388  : 
; 389  : 	for (c = EAGetFirstCipher (ea); c != 0; c = EAGetNextCipher (ea, c))

  00015	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00018	6b c0 2c	 imul	 eax, 44			; 0000002cH
  0001b	53		 push	 ebx
  0001c	8b 98 00 00 00
	00		 mov	 ebx, DWORD PTR _EncryptionAlgorithms[eax]
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	85 db		 test	 ebx, ebx
  00026	74 38		 je	 SHORT $LN5@EAInit
  00028	8b 7d 10	 mov	 edi, DWORD PTR _ks$[ebp]
  0002b	8b 75 0c	 mov	 esi, DWORD PTR _key$[ebp]
$LL7@EAInit:

; 390  : 	{
; 391  : 		switch (CipherInit (c, key, ks))

  0002e	57		 push	 edi
  0002f	56		 push	 esi
  00030	53		 push	 ebx
  00031	e8 00 00 00 00	 call	 _CipherInit@12
  00036	83 e8 11	 sub	 eax, 17			; 00000011H
  00039	74 2f		 je	 SHORT $LN2@EAInit
  0003b	48		 dec	 eax
  0003c	75 07		 jne	 SHORT $LN3@EAInit

; 395  : 
; 396  : 		case ERR_CIPHER_INIT_WEAK_KEY:
; 397  : 			retVal = ERR_CIPHER_INIT_WEAK_KEY;		// Non-fatal error

  0003e	c7 45 fc 12 00
	00 00		 mov	 DWORD PTR _retVal$[ebp], 18 ; 00000012H
$LN3@EAInit:

; 398  : 			break;
; 399  : 		}
; 400  : 
; 401  : 		key += CipherGetKeySize (c);

  00045	53		 push	 ebx
  00046	e8 00 00 00 00	 call	 _CipherGet@4
  0004b	03 70 0c	 add	 esi, DWORD PTR [eax+12]

; 402  : 		ks += CipherGetKeyScheduleSize (c);

  0004e	03 78 10	 add	 edi, DWORD PTR [eax+16]
  00051	53		 push	 ebx
  00052	ff 75 08	 push	 DWORD PTR _ea$[ebp]
  00055	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  0005a	8b d8		 mov	 ebx, eax
  0005c	85 db		 test	 ebx, ebx
  0005e	75 ce		 jne	 SHORT $LL7@EAInit
$LN5@EAInit:

; 403  : 	}
; 404  : 	return retVal;

  00060	8b 45 fc	 mov	 eax, DWORD PTR _retVal$[ebp]
$LN19@EAInit:
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
$LN9@EAInit:

; 405  : }

  00066	c9		 leave
  00067	c2 0c 00	 ret	 12			; 0000000cH
$LN2@EAInit:

; 392  : 		{
; 393  : 		case ERR_CIPHER_INIT_FAILURE:
; 394  : 			return ERR_CIPHER_INIT_FAILURE;

  0006a	6a 11		 push	 17			; 00000011H
  0006c	58		 pop	 eax
  0006d	eb f4		 jmp	 SHORT $LN19@EAInit
_EAInit@12 ENDP
_TEXT	ENDS
PUBLIC	_EAInitMode@4
EXTRN	_Gf64TabInit@8:PROC
EXTRN	_Gf128Tab64Init@8:PROC
; Function compile flags: /Ogsp
;	COMDAT _EAInitMode@4
_TEXT	SEGMENT
_ci$ = 8						; size = 4
_EAInitMode@4 PROC					; COMDAT

; 411  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 412  : 	switch (ci->mode)

  00005	8b 55 08	 mov	 edx, DWORD PTR _ci$[ebp]
  00008	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000b	83 f8 01	 cmp	 eax, 1
  0000e	0f 84 82 00 00
	00		 je	 $LN10@EAInitMode
  00014	83 f8 02	 cmp	 eax, 2
  00017	74 26		 je	 SHORT $LN8@EAInitMode
  00019	83 c0 fd	 add	 eax, -3			; fffffffdH
  0001c	83 f8 02	 cmp	 eax, 2
  0001f	77 08		 ja	 SHORT $LN1@EAInitMode

; 438  : 		}
; 439  : 
; 440  : 		break;
; 441  : 
; 442  : 	case CBC:
; 443  : 	case INNER_CBC:
; 444  : 	case OUTER_CBC:
; 445  : 		// The mode does not need to be initialized or is initialized elsewhere 
; 446  : 		return TRUE;

  00021	33 c0		 xor	 eax, eax
  00023	40		 inc	 eax
  00024	e9 87 00 00 00	 jmp	 $LN9@EAInitMode
$LN1@EAInitMode:

; 447  : 
; 448  : 	default:		
; 449  : 		// Unknown/wrong ID
; 450  : 		TC_THROW_FATAL_EXCEPTION;

  00029	68 43 54 00 00	 push	 21571			; 00005443H
  0002e	6a 00		 push	 0
  00030	6a 00		 push	 0
  00032	68 c2 01 00 00	 push	 450			; 000001c2H
$LN20@EAInitMode:
  00037	6a 29		 push	 41			; 00000029H
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN21@EAInitMode:
$LN8@EAInitMode:

; 417  : 			return FALSE;
; 418  : 
; 419  : 		/* Note: XTS mode could potentially be initialized with a weak key causing all blocks in one data unit
; 420  : 		on the volume to be tweaked with zero tweaks (i.e. 512 bytes of the volume would be encrypted in ECB
; 421  : 		mode). However, to create a CipherShed volume with such a weak key, each human being on Earth would have
; 422  : 		to create approximately 11,378,125,361,078,862 (about eleven quadrillion) CipherShed volumes (provided 
; 423  : 		that the size of each of the volumes is 1024 terabytes). */
; 424  : 		break;
; 425  : 
; 426  : 	case LRW:
; 427  : 		switch (CipherGetBlockSize (EAGetFirstCipher (ci->ea)))

  0003f	8b 02		 mov	 eax, DWORD PTR [edx]
  00041	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00044	ff b0 00 00 00
	00		 push	 DWORD PTR _EncryptionAlgorithms[eax]
  0004a	e8 00 00 00 00	 call	 _CipherGet@4
  0004f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00052	83 f8 08	 cmp	 eax, 8
  00055	74 2a		 je	 SHORT $LN5@EAInitMode
  00057	83 f8 10	 cmp	 eax, 16			; 00000010H
  0005a	74 10		 je	 SHORT $LN4@EAInitMode

; 435  : 
; 436  : 		default:
; 437  : 			TC_THROW_FATAL_EXCEPTION;

  0005c	68 43 54 00 00	 push	 21571			; 00005443H
  00061	6a 00		 push	 0
  00063	6a 00		 push	 0
  00065	68 b5 01 00 00	 push	 437			; 000001b5H
  0006a	eb cb		 jmp	 SHORT $LN20@EAInitMode
$LN4@EAInitMode:

; 432  : 
; 433  : 		case 16:
; 434  : 			return Gf128Tab64Init (ci->k2, &ci->gf_ctx);

  0006c	8d 82 a8 29 00
	00		 lea	 eax, DWORD PTR [edx+10664]
  00072	50		 push	 eax
  00073	81 c2 a8 42 00
	00		 add	 edx, 17064		; 000042a8H
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 _Gf128Tab64Init@8
  0007f	eb 2f		 jmp	 SHORT $LN9@EAInitMode
$LN5@EAInitMode:

; 428  : 		{
; 429  : 		case 8:
; 430  : 			/* Deprecated/legacy */
; 431  : 			return Gf64TabInit (ci->k2, &ci->gf_ctx);

  00081	8d 82 a8 29 00
	00		 lea	 eax, DWORD PTR [edx+10664]
  00087	50		 push	 eax
  00088	81 c2 a8 42 00
	00		 add	 edx, 17064		; 000042a8H
  0008e	52		 push	 edx
  0008f	e8 00 00 00 00	 call	 _Gf64TabInit@8
  00094	eb 1a		 jmp	 SHORT $LN9@EAInitMode
$LN10@EAInitMode:

; 413  : 	{
; 414  : 	case XTS:
; 415  : 		// Secondary key schedule
; 416  : 		if (EAInit (ci->ea, ci->k2, ci->ks2) != ERR_SUCCESS)

  00096	8d 82 d4 14 00
	00		 lea	 eax, DWORD PTR [edx+5332]
  0009c	50		 push	 eax
  0009d	8d 82 a8 42 00
	00		 lea	 eax, DWORD PTR [edx+17064]
  000a3	50		 push	 eax
  000a4	ff 32		 push	 DWORD PTR [edx]
  000a6	e8 00 00 00 00	 call	 _EAInit@12
  000ab	f7 d8		 neg	 eax
  000ad	1b c0		 sbb	 eax, eax
  000af	40		 inc	 eax
$LN9@EAInitMode:

; 451  : 	}
; 452  : 	return TRUE;
; 453  : }

  000b0	5d		 pop	 ebp
  000b1	c2 04 00	 ret	 4
$LN19@EAInitMode:
_EAInitMode@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_01JOAMLHOP@?9?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_01OGPIMHDM@?$DP?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	_EAGetName@8
;	COMDAT ??_C@_01JOAMLHOP@?9?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_01JOAMLHOP@?9?$AA@FNODOBFM@ DB '-', 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_01OGPIMHDM@?$DP?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_01OGPIMHDM@?$DP?$AA@FNODOBFM@ DB '?', 00H		;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
text$s	ENDS
;	COMDAT _EAGetName@8
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_ea$ = 12						; size = 4
_EAGetName@8 PROC					; COMDAT

; 458  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	53		 push	 ebx
  00006	56		 push	 esi

; 459  : 	int i = EAGetLastCipher(ea);

  00007	ff 75 0c	 push	 DWORD PTR _ea$[ebp]
  0000a	e8 00 00 00 00	 call	 _EAGetLastCipher@4
  0000f	8b f0		 mov	 esi, eax

; 460  : 	strcpy (buf, (i != 0) ? CipherGetName (i) : "?");

  00011	85 f6		 test	 esi, esi
  00013	74 0b		 je	 SHORT $LN5@EAGetName
  00015	56		 push	 esi
  00016	e8 00 00 00 00	 call	 _CipherGet@4
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	eb 05		 jmp	 SHORT $LN6@EAGetName
$LN5@EAGetName:
  00020	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_01OGPIMHDM@?$DP?$AA@FNODOBFM@
$LN6@EAGetName:
  00025	8b 5d 08	 mov	 ebx, DWORD PTR _buf$[ebp]
  00028	8b c8		 mov	 ecx, eax
  0002a	8b d3		 mov	 edx, ebx
$LL7@EAGetName:
  0002c	8a 01		 mov	 al, BYTE PTR [ecx]
  0002e	41		 inc	 ecx
  0002f	88 02		 mov	 BYTE PTR [edx], al
  00031	42		 inc	 edx
  00032	84 c0		 test	 al, al
  00034	75 f6		 jne	 SHORT $LL7@EAGetName

; 461  : 
; 462  : 	while (i = EAGetPreviousCipher(ea, i))

  00036	56		 push	 esi
  00037	ff 75 0c	 push	 DWORD PTR _ea$[ebp]
  0003a	e8 00 00 00 00	 call	 _EAGetPreviousCipher@8
  0003f	8b d0		 mov	 edx, eax
  00041	85 d2		 test	 edx, edx
  00043	74 50		 je	 SHORT $LN1@EAGetName
  00045	57		 push	 edi
$LL2@EAGetName:

; 463  : 	{
; 464  : 		strcat (buf, "-");

  00046	8b fb		 mov	 edi, ebx
  00048	4f		 dec	 edi
$LL16@EAGetName:
  00049	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  0004c	47		 inc	 edi
  0004d	84 c0		 test	 al, al
  0004f	75 f8		 jne	 SHORT $LL16@EAGetName
  00051	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_01JOAMLHOP@?9?$AA@FNODOBFM@

; 465  : 		strcat (buf, CipherGetName (i));

  00056	52		 push	 edx
  00057	66 a5		 movsw
  00059	e8 00 00 00 00	 call	 _CipherGet@4
  0005e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00061	8b f0		 mov	 esi, eax
$LL17@EAGetName:
  00063	8a 08		 mov	 cl, BYTE PTR [eax]
  00065	40		 inc	 eax
  00066	84 c9		 test	 cl, cl
  00068	75 f9		 jne	 SHORT $LL17@EAGetName
  0006a	8b fb		 mov	 edi, ebx
  0006c	2b c6		 sub	 eax, esi
  0006e	4f		 dec	 edi
$LL18@EAGetName:
  0006f	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00072	47		 inc	 edi
  00073	84 c9		 test	 cl, cl
  00075	75 f8		 jne	 SHORT $LL18@EAGetName
  00077	8b c8		 mov	 ecx, eax
  00079	c1 e9 02	 shr	 ecx, 2
  0007c	f3 a5		 rep movsd
  0007e	8b c8		 mov	 ecx, eax
  00080	52		 push	 edx
  00081	ff 75 0c	 push	 DWORD PTR _ea$[ebp]
  00084	83 e1 03	 and	 ecx, 3
  00087	f3 a4		 rep movsb
  00089	e8 00 00 00 00	 call	 _EAGetPreviousCipher@8
  0008e	8b d0		 mov	 edx, eax
  00090	85 d2		 test	 edx, edx
  00092	75 b2		 jne	 SHORT $LL2@EAGetName
  00094	5f		 pop	 edi
$LN1@EAGetName:
  00095	5e		 pop	 esi

; 466  : 	}
; 467  : 
; 468  : 	return buf;

  00096	8b c3		 mov	 eax, ebx
  00098	5b		 pop	 ebx

; 469  : }

  00099	5d		 pop	 ebp
  0009a	c2 08 00	 ret	 8
_EAGetName@8 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_EAGetByName@4
; Function compile flags: /Ogsp
;	COMDAT _EAGetByName@4
_TEXT	SEGMENT
_n$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_name$ = 8						; size = 4
_EAGetByName@4 PROC					; COMDAT

; 473  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi

; 474  : 	int ea = EAGetFirst ();

  00016	33 f6		 xor	 esi, esi
  00018	46		 inc	 esi
$LL4@EAGetByNam:

; 475  : 	char n[128];
; 476  : 
; 477  : 	do
; 478  : 	{
; 479  : 		EAGetName (n, ea);

  00019	56		 push	 esi
  0001a	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _n$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 _EAGetName@8

; 480  : 		if (strcmp (n, name) == 0)

  00026	8b 4d 08	 mov	 ecx, DWORD PTR _name$[ebp]
  00029	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _n$[ebp]
$LL12@EAGetByNam:
  0002f	8a 10		 mov	 dl, BYTE PTR [eax]
  00031	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00033	75 18		 jne	 SHORT $LN13@EAGetByNam
  00035	84 d2		 test	 dl, dl
  00037	74 10		 je	 SHORT $LN14@EAGetByNam
  00039	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0003c	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  0003f	75 0c		 jne	 SHORT $LN13@EAGetByNam
  00041	40		 inc	 eax
  00042	40		 inc	 eax
  00043	41		 inc	 ecx
  00044	41		 inc	 ecx
  00045	84 d2		 test	 dl, dl
  00047	75 e6		 jne	 SHORT $LL12@EAGetByNam
$LN14@EAGetByNam:
  00049	33 c0		 xor	 eax, eax
  0004b	eb 05		 jmp	 SHORT $LN15@EAGetByNam
$LN13@EAGetByNam:
  0004d	1b c0		 sbb	 eax, eax
  0004f	83 d8 ff	 sbb	 eax, -1
$LN15@EAGetByNam:
  00052	85 c0		 test	 eax, eax
  00054	74 1b		 je	 SHORT $LN10@EAGetByNam

; 482  : 	}
; 483  : 	while (ea = EAGetNext (ea));

  00056	56		 push	 esi
  00057	e8 00 00 00 00	 call	 _EAGetNext@4
  0005c	8b f0		 mov	 esi, eax
  0005e	85 f6		 test	 esi, esi
  00060	75 b7		 jne	 SHORT $LL4@EAGetByNam
$LN5@EAGetByNam:

; 484  : 
; 485  : 	return 0;
; 486  : }

  00062	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00065	33 cd		 xor	 ecx, ebp
  00067	5e		 pop	 esi
  00068	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006d	c9		 leave
  0006e	c2 04 00	 ret	 4
$LN10@EAGetByNam:

; 481  : 			return ea;

  00071	8b c6		 mov	 eax, esi
  00073	eb ed		 jmp	 SHORT $LN5@EAGetByNam
_EAGetByName@4 ENDP
_TEXT	ENDS
PUBLIC	_EAGetKeySize@4
; Function compile flags: /Ogsp
;	COMDAT _EAGetKeySize@4
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_EAGetKeySize@4 PROC					; COMDAT

; 492  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 493  : 	int i = EAGetFirstCipher (ea);

  00005	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00008	6b c0 2c	 imul	 eax, 44			; 0000002cH
  0000b	8b 90 00 00 00
	00		 mov	 edx, DWORD PTR _EncryptionAlgorithms[eax]
  00011	56		 push	 esi

; 494  : 	int size = CipherGetKeySize (i);

  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 _CipherGet@4
  00018	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]

; 495  : 
; 496  : 	while (i = EAGetNextCipher (ea, i))

  0001b	eb 09		 jmp	 SHORT $LN14@EAGetKeySi
$LL2@EAGetKeySi:

; 497  : 	{
; 498  : 		size += CipherGetKeySize (i);

  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 _CipherGet@4
  00023	03 70 0c	 add	 esi, DWORD PTR [eax+12]
$LN14@EAGetKeySi:
  00026	52		 push	 edx
  00027	ff 75 08	 push	 DWORD PTR _ea$[ebp]
  0002a	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  0002f	8b d0		 mov	 edx, eax
  00031	85 d2		 test	 edx, edx
  00033	75 e8		 jne	 SHORT $LL2@EAGetKeySi

; 499  : 	}
; 500  : 
; 501  : 	return size;

  00035	8b c6		 mov	 eax, esi
  00037	5e		 pop	 esi

; 502  : }

  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
_EAGetKeySize@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_03CKCBIPFF@XTS?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_03JFLLPGCL@LRW?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_03PPFAJCFI@CBC?$AA@FNODOBFM@		;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_09CJGJEHAC@outer?9CBC?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_09GGDEEENC@Outer?9CBC?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0L@NEGMAKNF@Triple?5DES?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_09OHJJMGAK@inner?9CBC?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_09KIMEMFNK@Inner?9CBC?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_09DJENBFJK@?$FLunknown?$FN?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	__$ArrayPad$
PUBLIC	_EAGetModeName@12
;	COMDAT ??_C@_03CKCBIPFF@XTS?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_03CKCBIPFF@XTS?$AA@FNODOBFM@ DB 'XTS', 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_03JFLLPGCL@LRW?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_03JFLLPGCL@LRW?$AA@FNODOBFM@ DB 'LRW', 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_03PPFAJCFI@CBC?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_03PPFAJCFI@CBC?$AA@FNODOBFM@ DB 'CBC', 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_09CJGJEHAC@outer?9CBC?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09CJGJEHAC@outer?9CBC?$AA@FNODOBFM@ DB 'outer-CBC', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_09GGDEEENC@Outer?9CBC?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09GGDEEENC@Outer?9CBC?$AA@FNODOBFM@ DB 'Outer-CBC', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0L@NEGMAKNF@Triple?5DES?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0L@NEGMAKNF@Triple?5DES?$AA@FNODOBFM@ DB 'Triple DES', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_09OHJJMGAK@inner?9CBC?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09OHJJMGAK@inner?9CBC?$AA@FNODOBFM@ DB 'inner-CBC', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_09KIMEMFNK@Inner?9CBC?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09KIMEMFNK@Inner?9CBC?$AA@FNODOBFM@ DB 'Inner-CBC', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_09DJENBFJK@?$FLunknown?$FN?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09DJENBFJK@?$FLunknown?$FN?$AA@FNODOBFM@ DB '[unknown]', 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
text$s	ENDS
;	COMDAT _EAGetModeName@12
_TEXT	SEGMENT
_eaName$27228 = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
_ea$ = 8						; size = 4
_mode$ = 12						; size = 4
_capitalLetters$ = 16					; size = 4
_EAGetModeName@12 PROC					; COMDAT

; 529  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 68	 sub	 esp, 104		; 00000068H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 530  : 	switch (mode)

  00012	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  00015	48		 dec	 eax
  00016	74 6b		 je	 SHORT $LN6@EAGetModeN
  00018	48		 dec	 eax
  00019	74 61		 je	 SHORT $LN5@EAGetModeN
  0001b	48		 dec	 eax
  0001c	74 25		 je	 SHORT $LN4@EAGetModeN
  0001e	48		 dec	 eax
  0001f	74 1c		 je	 SHORT $LN2@EAGetModeN
  00021	48		 dec	 eax
  00022	74 07		 je	 SHORT $LN1@EAGetModeN

; 566  : 
; 567  : 	}
; 568  : 	return "[unknown]";

  00024	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09DJENBFJK@?$FLunknown?$FN?$AA@FNODOBFM@
  00029	eb 5d		 jmp	 SHORT $LN9@EAGetModeN
$LN1@EAGetModeN:

; 560  : 
; 561  : 	case INNER_CBC:
; 562  : 
; 563  : 		/* Deprecated/legacy */
; 564  : 
; 565  : 		return capitalLetters ? "Inner-CBC" : "inner-CBC";

  0002b	83 7d 10 00	 cmp	 DWORD PTR _capitalLetters$[ebp], 0
  0002f	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09KIMEMFNK@Inner?9CBC?$AA@FNODOBFM@
  00034	75 52		 jne	 SHORT $LN9@EAGetModeN
  00036	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09OHJJMGAK@inner?9CBC?$AA@FNODOBFM@
  0003b	eb 4b		 jmp	 SHORT $LN9@EAGetModeN
$LN2@EAGetModeN:

; 553  : 		}
; 554  : 
; 555  : 	case OUTER_CBC:
; 556  : 
; 557  : 		/* Deprecated/legacy */
; 558  : 
; 559  : 		return  capitalLetters ? "Outer-CBC" : "outer-CBC";

  0003d	83 7d 10 00	 cmp	 DWORD PTR _capitalLetters$[ebp], 0
  00041	eb 24		 jmp	 SHORT $LN18@EAGetModeN
$LN4@EAGetModeN:
  00043	56		 push	 esi
  00044	57		 push	 edi

; 541  : 
; 542  : 	case CBC:
; 543  : 		{
; 544  : 			/* Deprecated/legacy */
; 545  : 
; 546  : 			char eaName[100];
; 547  : 			EAGetName (eaName, ea);

  00045	ff 75 08	 push	 DWORD PTR _ea$[ebp]
  00048	8d 45 98	 lea	 eax, DWORD PTR _eaName$27228[ebp]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 _EAGetName@8

; 548  : 
; 549  : 			if (strcmp (eaName, "Triple DES") == 0)

  00051	6a 0b		 push	 11			; 0000000bH
  00053	59		 pop	 ecx
  00054	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_0L@NEGMAKNF@Triple?5DES?$AA@FNODOBFM@
  00059	8d 75 98	 lea	 esi, DWORD PTR _eaName$27228[ebp]
  0005c	33 c0		 xor	 eax, eax
  0005e	f3 a6		 repe cmpsb
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	75 11		 jne	 SHORT $LN3@EAGetModeN

; 550  : 				return capitalLetters ? "Outer-CBC" : "outer-CBC";

  00064	39 45 10	 cmp	 DWORD PTR _capitalLetters$[ebp], eax
$LN18@EAGetModeN:
  00067	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09GGDEEENC@Outer?9CBC?$AA@FNODOBFM@
  0006c	75 1a		 jne	 SHORT $LN9@EAGetModeN
  0006e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09CJGJEHAC@outer?9CBC?$AA@FNODOBFM@
  00073	eb 13		 jmp	 SHORT $LN9@EAGetModeN
$LN3@EAGetModeN:

; 551  : 
; 552  : 			return "CBC";

  00075	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03PPFAJCFI@CBC?$AA@FNODOBFM@
  0007a	eb 0c		 jmp	 SHORT $LN9@EAGetModeN
$LN5@EAGetModeN:

; 535  : 
; 536  : 	case LRW:
; 537  : 
; 538  : 		/* Deprecated/legacy */
; 539  : 
; 540  : 		return "LRW";

  0007c	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JFLLPGCL@LRW?$AA@FNODOBFM@
  00081	eb 05		 jmp	 SHORT $LN9@EAGetModeN
$LN6@EAGetModeN:

; 531  : 	{
; 532  : 	case XTS:
; 533  : 
; 534  : 		return "XTS";

  00083	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03CKCBIPFF@XTS?$AA@FNODOBFM@
$LN9@EAGetModeN:

; 569  : }

  00088	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008b	33 cd		 xor	 ecx, ebp
  0008d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00092	c9		 leave
  00093	c2 0c 00	 ret	 12			; 0000000cH
_EAGetModeName@12 ENDP
_TEXT	ENDS
PUBLIC	_EAGetKeyScheduleSize@4
; Function compile flags: /Ogsp
;	COMDAT _EAGetKeyScheduleSize@4
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_EAGetKeyScheduleSize@4 PROC				; COMDAT

; 576  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 577  : 	int i = EAGetFirstCipher(ea);

  00005	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00008	6b c0 2c	 imul	 eax, 44			; 0000002cH
  0000b	8b 90 00 00 00
	00		 mov	 edx, DWORD PTR _EncryptionAlgorithms[eax]
  00011	56		 push	 esi

; 578  : 	int size = CipherGetKeyScheduleSize (i);

  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 _CipherGet@4
  00018	8b 70 10	 mov	 esi, DWORD PTR [eax+16]

; 579  : 
; 580  : 	while (i = EAGetNextCipher(ea, i))

  0001b	eb 09		 jmp	 SHORT $LN14@EAGetKeySc
$LL2@EAGetKeySc:

; 581  : 	{
; 582  : 		size += CipherGetKeyScheduleSize (i);

  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 _CipherGet@4
  00023	03 70 10	 add	 esi, DWORD PTR [eax+16]
$LN14@EAGetKeySc:
  00026	52		 push	 edx
  00027	ff 75 08	 push	 DWORD PTR _ea$[ebp]
  0002a	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  0002f	8b d0		 mov	 edx, eax
  00031	85 d2		 test	 edx, edx
  00033	75 e8		 jne	 SHORT $LL2@EAGetKeySc

; 583  : 	}
; 584  : 
; 585  : 	return size;

  00035	8b c6		 mov	 eax, esi
  00037	5e		 pop	 esi

; 586  : }

  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
_EAGetKeyScheduleSize@4 ENDP
_TEXT	ENDS
PUBLIC	_EAGetLargestKeyForMode@4
; Function compile flags: /Ogsp
;	COMDAT _EAGetLargestKeyForMode@4
_TEXT	SEGMENT
_mode$ = 8						; size = 4
_EAGetLargestKeyForMode@4 PROC				; COMDAT

; 591  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi
  00006	57		 push	 edi

; 592  : 	int ea, key = 0;
; 593  : 
; 594  : 	for (ea = EAGetFirst (); ea != 0; ea = EAGetNext (ea))

  00007	33 f6		 xor	 esi, esi
  00009	33 ff		 xor	 edi, edi
  0000b	46		 inc	 esi
$LL5@EAGetLarge:

; 595  : 	{
; 596  : 		if (!EAIsModeSupported (ea, mode))

  0000c	ff 75 08	 push	 DWORD PTR _mode$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _EAIsModeSupported@8
  00015	85 c0		 test	 eax, eax
  00017	74 12		 je	 SHORT $LN4@EAGetLarge

; 597  : 			continue;
; 598  : 
; 599  : 		if (EAGetKeySize (ea) >= key)

  00019	56		 push	 esi
  0001a	e8 00 00 00 00	 call	 _EAGetKeySize@4
  0001f	3b c7		 cmp	 eax, edi
  00021	7c 08		 jl	 SHORT $LN4@EAGetLarge

; 600  : 			key = EAGetKeySize (ea);

  00023	56		 push	 esi
  00024	e8 00 00 00 00	 call	 _EAGetKeySize@4
  00029	8b f8		 mov	 edi, eax
$LN4@EAGetLarge:
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 _EAGetNext@4
  00031	8b f0		 mov	 esi, eax
  00033	85 f6		 test	 esi, esi
  00035	75 d5		 jne	 SHORT $LL5@EAGetLarge

; 601  : 	}
; 602  : 	return key;

  00037	8b c7		 mov	 eax, edi
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi

; 603  : }

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
_EAGetLargestKeyForMode@4 ENDP
_TEXT	ENDS
PUBLIC	_EAGetLargestKey@0
; Function compile flags: /Ogsp
;	COMDAT _EAGetLargestKey@0
_TEXT	SEGMENT
_EAGetLargestKey@0 PROC					; COMDAT

; 608  : {

  00000	8b ff		 npad	 2
  00002	56		 push	 esi
  00003	57		 push	 edi

; 609  : 	int ea, key = 0;
; 610  : 
; 611  : 	for (ea = EAGetFirst (); ea != 0; ea = EAGetNext (ea))

  00004	33 f6		 xor	 esi, esi
  00006	33 ff		 xor	 edi, edi
  00008	46		 inc	 esi
$LL4@EAGetLarge@2:

; 612  : 	{
; 613  : 		if (EAGetKeySize (ea) >= key)

  00009	56		 push	 esi
  0000a	e8 00 00 00 00	 call	 _EAGetKeySize@4
  0000f	3b c7		 cmp	 eax, edi
  00011	7c 08		 jl	 SHORT $LN3@EAGetLarge@2

; 614  : 			key = EAGetKeySize (ea);

  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 _EAGetKeySize@4
  00019	8b f8		 mov	 edi, eax
$LN3@EAGetLarge@2:
  0001b	56		 push	 esi
  0001c	e8 00 00 00 00	 call	 _EAGetNext@4
  00021	8b f0		 mov	 esi, eax
  00023	85 f6		 test	 esi, esi
  00025	75 e2		 jne	 SHORT $LL4@EAGetLarge@2

; 615  : 	}
; 616  : 
; 617  : 	return key;

  00027	8b c7		 mov	 eax, edi
  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi

; 618  : }

  0002b	c3		 ret	 0
_EAGetLargestKey@0 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_DecryptBufferLRW128@24
; Function compile flags: /Ogsp
;	COMDAT _DecryptBufferLRW128@24
_TEXT	SEGMENT
tv202 = -56						; size = 8
_cipherCount$ = -48					; size = 4
_b$ = -44						; size = 8
_p$ = -36						; size = 4
_cipher$ = -32						; size = 4
_t$ = -28						; size = 16
_i$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 8
_blockIndex$ = 20					; size = 8
_cryptoInfo$ = 28					; size = 4
_DecryptBufferLRW128@24 PROC				; COMDAT

; 909  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 38	 sub	 esp, 56			; 00000038H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	8b 75 1c	 mov	 esi, DWORD PTR _cryptoInfo$[ebp]

; 910  : 	/* Deprecated/legacy */
; 911  : 
; 912  : 	int cipher = EAGetFirstCipher (cryptoInfo->ea);

  00017	8b 06		 mov	 eax, DWORD PTR [esi]
  00019	8b c8		 mov	 ecx, eax
  0001b	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  0001e	8b 89 00 00 00
	00		 mov	 ecx, DWORD PTR _EncryptionAlgorithms[ecx]
  00024	57		 push	 edi
  00025	8b 7d 08	 mov	 edi, DWORD PTR _buffer$[ebp]

; 913  : 	int cipherCount = EAGetCipherCount (cryptoInfo->ea);

  00028	50		 push	 eax
  00029	89 4d e0	 mov	 DWORD PTR _cipher$[ebp], ecx
  0002c	e8 00 00 00 00	 call	 _EAGetCipherCount@4

; 914  : 	unsigned __int8 *p = buffer;
; 915  : 	unsigned __int8 *ks = cryptoInfo->ks;
; 916  : 	unsigned __int8 i[8];
; 917  : 	unsigned __int8 t[16];
; 918  : 	unsigned __int64 b;
; 919  : 
; 920  : 	*(unsigned __int64 *)i = BE64(blockIndex);

  00031	ff 75 18	 push	 DWORD PTR _blockIndex$[ebp+4]
  00034	89 7d dc	 mov	 DWORD PTR _p$[ebp], edi
  00037	ff 75 14	 push	 DWORD PTR _blockIndex$[ebp]
  0003a	89 45 d0	 mov	 DWORD PTR _cipherCount$[ebp], eax
  0003d	8d 7e 08	 lea	 edi, DWORD PTR [esi+8]
  00040	e8 00 00 00 00	 call	 _MirrorBytes64@8
  00045	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
  00048	89 55 f8	 mov	 DWORD PTR _i$[ebp+4], edx

; 921  : 
; 922  : 	if (length % 16)

  0004b	8b 55 0c	 mov	 edx, DWORD PTR _length$[ebp]
  0004e	8b c2		 mov	 eax, edx
  00050	83 e0 0f	 and	 eax, 15			; 0000000fH
  00053	33 c9		 xor	 ecx, ecx
  00055	0b c1		 or	 eax, ecx
  00057	74 14		 je	 SHORT $LN16@DecryptBuf@2

; 923  : 		TC_THROW_FATAL_EXCEPTION;

  00059	68 43 54 00 00	 push	 21571			; 00005443H
  0005e	51		 push	 ecx
  0005f	51		 push	 ecx
  00060	68 9b 03 00 00	 push	 923			; 0000039bH
  00065	6a 29		 push	 41			; 00000029H
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN39@DecryptBuf@2:
$LN16@DecryptBuf@2:

; 924  : 
; 925  : 	// Note that the maximum supported volume size is 8589934592 GB  (i.e., 2^63 bytes).
; 926  : 
; 927  : 	for (b = 0; b < length >> 4; b++)

  0006d	8b 5d 10	 mov	 ebx, DWORD PTR _length$[ebp+4]
  00070	0f ac da 04	 shrd	 edx, ebx, 4
  00074	c1 eb 04	 shr	 ebx, 4
  00077	89 4d d4	 mov	 DWORD PTR _b$[ebp], ecx
  0007a	89 4d d8	 mov	 DWORD PTR _b$[ebp+4], ecx
  0007d	89 55 c8	 mov	 DWORD PTR tv202[ebp], edx
  00080	85 db		 test	 ebx, ebx
  00082	0f 82 d2 00 00
	00		 jb	 $LN5@DecryptBuf@2
  00088	77 08		 ja	 SHORT $LL30@DecryptBuf@2
  0008a	3b d1		 cmp	 edx, ecx
  0008c	0f 86 c8 00 00
	00		 jbe	 $LN5@DecryptBuf@2
$LL30@DecryptBuf@2:

; 928  : 	{
; 929  : 		Gf128MulBy64Tab (i, t, &cryptoInfo->gf_ctx);

  00092	8d 86 a8 29 00
	00		 lea	 eax, DWORD PTR [esi+10664]
  00098	50		 push	 eax
  00099	8d 45 e4	 lea	 eax, DWORD PTR _t$[ebp]
  0009c	50		 push	 eax
  0009d	8d 45 f4	 lea	 eax, DWORD PTR _i$[ebp]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 _Gf128MulBy64Tab@12

; 930  : 		Xor128 ((unsigned __int64 *)p, (unsigned __int64 *)t);

  000a6	8d 45 e4	 lea	 eax, DWORD PTR _t$[ebp]
  000a9	50		 push	 eax
  000aa	ff 75 dc	 push	 DWORD PTR _p$[ebp]
  000ad	e8 00 00 00 00	 call	 _Xor128@8

; 931  : 
; 932  : 		if (cipherCount > 1)

  000b2	83 7d d0 01	 cmp	 DWORD PTR _cipherCount$[ebp], 1
  000b6	7e 3e		 jle	 SHORT $LN12@DecryptBuf@2

; 933  : 		{
; 934  : 			// Cipher cascade
; 935  : 			ks = cryptoInfo->ks + EAGetKeyScheduleSize (cryptoInfo->ea);

  000b8	ff 36		 push	 DWORD PTR [esi]
  000ba	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4

; 936  : 
; 937  : 			for (cipher = EAGetLastCipher (cryptoInfo->ea);
; 938  : 				cipher != 0;
; 939  : 				cipher = EAGetPreviousCipher (cryptoInfo->ea, cipher))

  000bf	ff 36		 push	 DWORD PTR [esi]
  000c1	8d 7c 30 08	 lea	 edi, DWORD PTR [eax+esi+8]
  000c5	e8 00 00 00 00	 call	 _EAGetLastCipher@4
  000ca	eb 21		 jmp	 SHORT $LN38@DecryptBuf@2
$LL32@DecryptBuf@2:

; 940  : 			{
; 941  : 				ks -= CipherGetKeyScheduleSize (cipher);

  000cc	ff 75 e0	 push	 DWORD PTR _cipher$[ebp]
  000cf	e8 00 00 00 00	 call	 _CipherGet@4
  000d4	2b 78 10	 sub	 edi, DWORD PTR [eax+16]

; 942  : 				DecipherBlock (cipher, p, ks);

  000d7	57		 push	 edi
  000d8	ff 75 dc	 push	 DWORD PTR _p$[ebp]
  000db	ff 75 e0	 push	 DWORD PTR _cipher$[ebp]
  000de	e8 00 00 00 00	 call	 _DecipherBlock@12
  000e3	ff 75 e0	 push	 DWORD PTR _cipher$[ebp]
  000e6	ff 36		 push	 DWORD PTR [esi]
  000e8	e8 00 00 00 00	 call	 _EAGetPreviousCipher@8
$LN38@DecryptBuf@2:
  000ed	89 45 e0	 mov	 DWORD PTR _cipher$[ebp], eax
  000f0	85 c0		 test	 eax, eax
  000f2	75 d8		 jne	 SHORT $LL32@DecryptBuf@2

; 943  : 			}
; 944  : 		}
; 945  : 		else

  000f4	eb 0c		 jmp	 SHORT $LN8@DecryptBuf@2
$LN12@DecryptBuf@2:

; 946  : 		{
; 947  : 			DecipherBlock (cipher, p, ks);

  000f6	57		 push	 edi
  000f7	ff 75 dc	 push	 DWORD PTR _p$[ebp]
  000fa	ff 75 e0	 push	 DWORD PTR _cipher$[ebp]
  000fd	e8 00 00 00 00	 call	 _DecipherBlock@12
$LN8@DecryptBuf@2:

; 948  : 		}
; 949  : 
; 950  : 		Xor128 ((unsigned __int64 *)p, (unsigned __int64 *)t);

  00102	8d 45 e4	 lea	 eax, DWORD PTR _t$[ebp]
  00105	50		 push	 eax
  00106	ff 75 dc	 push	 DWORD PTR _p$[ebp]
  00109	e8 00 00 00 00	 call	 _Xor128@8

; 951  : 
; 952  : 		p += 16;

  0010e	83 45 dc 10	 add	 DWORD PTR _p$[ebp], 16	; 00000010H

; 953  : 
; 954  : 		if (i[7] != 0xff)

  00112	80 7d fb ff	 cmp	 BYTE PTR _i$[ebp+7], 255 ; 000000ffH
  00116	74 05		 je	 SHORT $LN7@DecryptBuf@2

; 955  : 			i[7]++;

  00118	fe 45 fb	 inc	 BYTE PTR _i$[ebp+7]

; 956  : 		else

  0011b	eb 1e		 jmp	 SHORT $LN14@DecryptBuf@2
$LN7@DecryptBuf@2:

; 957  : 			*(unsigned __int64 *)i = BE64 ( BE64(*(unsigned __int64 *)i) + 1 );

  0011d	ff 75 f8	 push	 DWORD PTR _i$[ebp+4]
  00120	ff 75 f4	 push	 DWORD PTR _i$[ebp]
  00123	e8 00 00 00 00	 call	 _MirrorBytes64@8
  00128	83 c0 01	 add	 eax, 1
  0012b	83 d2 00	 adc	 edx, 0
  0012e	52		 push	 edx
  0012f	50		 push	 eax
  00130	e8 00 00 00 00	 call	 _MirrorBytes64@8
  00135	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
  00138	89 55 f8	 mov	 DWORD PTR _i$[ebp+4], edx
$LN14@DecryptBuf@2:
  0013b	83 45 d4 01	 add	 DWORD PTR _b$[ebp], 1
  0013f	83 55 d8 00	 adc	 DWORD PTR _b$[ebp+4], 0
  00143	39 5d d8	 cmp	 DWORD PTR _b$[ebp+4], ebx
  00146	0f 82 46 ff ff
	ff		 jb	 $LL30@DecryptBuf@2

; 924  : 
; 925  : 	// Note that the maximum supported volume size is 8589934592 GB  (i.e., 2^63 bytes).
; 926  : 
; 927  : 	for (b = 0; b < length >> 4; b++)

  0014c	77 0c		 ja	 SHORT $LN5@DecryptBuf@2
  0014e	8b 45 c8	 mov	 eax, DWORD PTR tv202[ebp]
  00151	39 45 d4	 cmp	 DWORD PTR _b$[ebp], eax
  00154	0f 82 38 ff ff
	ff		 jb	 $LL30@DecryptBuf@2
$LN5@DecryptBuf@2:

; 958  : 	}
; 959  : 
; 960  : 	FAST_ERASE64 (t, sizeof(t));

  0015a	6a 02		 push	 2
  0015c	59		 pop	 ecx
  0015d	5f		 pop	 edi
  0015e	5e		 pop	 esi
  0015f	8d 45 e4	 lea	 eax, DWORD PTR _t$[ebp]
  00162	5b		 pop	 ebx
$LL2@DecryptBuf@2:
  00163	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00169	49		 dec	 ecx
  0016a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00171	83 c0 08	 add	 eax, 8
  00174	85 c9		 test	 ecx, ecx
  00176	75 eb		 jne	 SHORT $LL2@DecryptBuf@2

; 961  : }

  00178	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0017b	33 cd		 xor	 ecx, ebp
  0017d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00182	c9		 leave
  00183	c2 18 00	 ret	 24			; 00000018H
$LN37@DecryptBuf@2:
_DecryptBufferLRW128@24 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _EncryptBufferCBC@28
_TEXT	SEGMENT
_bufIV$ = -28						; size = 16
_i$ = -12						; size = 8
tv284 = -4						; size = 4
tv247 = 8						; size = 4
_len$ = 8						; size = 4
_ks$ = 12						; size = 4
_whitening$ = 16					; size = 4
_ea$ = 20						; size = 4
_cipher$ = 24						; size = 4
_EncryptBufferCBC@28 PROC				; COMDAT
; _data$ = ecx
; _iv$ = eax

; 1073 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 1074 : 	/* IMPORTANT: This function has been deprecated (legacy) */
; 1075 : 
; 1076 : 	unsigned __int32 bufIV[4];
; 1077 : 	unsigned __int64 i;
; 1078 : 	int blockSize = CipherGetBlockSize (ea != 0 ? EAGetFirstCipher (ea) : cipher);

  00008	83 7d 14 00	 cmp	 DWORD PTR _ea$[ebp], 0
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b f8		 mov	 edi, eax
  00011	8b f1		 mov	 esi, ecx
  00013	74 0e		 je	 SHORT $LN16@EncryptBuf@3
  00015	8b 45 14	 mov	 eax, DWORD PTR _ea$[ebp]
  00018	6b c0 2c	 imul	 eax, 44			; 0000002cH
  0001b	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax]
  00021	eb 03		 jmp	 SHORT $LN17@EncryptBuf@3
$LN16@EncryptBuf@3:
  00023	8b 45 18	 mov	 eax, DWORD PTR _cipher$[ebp]
$LN17@EncryptBuf@3:
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 _CipherGet@4
  0002c	8b 58 08	 mov	 ebx, DWORD PTR [eax+8]

; 1079 : 
; 1080 : 	if (len % blockSize)

  0002f	8b 45 08	 mov	 eax, DWORD PTR _len$[ebp]
  00032	33 d2		 xor	 edx, edx
  00034	f7 f3		 div	 ebx
  00036	89 45 08	 mov	 DWORD PTR tv247[ebp], eax
  00039	85 d2		 test	 edx, edx
  0003b	74 16		 je	 SHORT $LN13@EncryptBuf@3

; 1081 : 		TC_THROW_FATAL_EXCEPTION;

  0003d	68 43 54 00 00	 push	 21571			; 00005443H
  00042	6a 00		 push	 0
  00044	6a 00		 push	 0
  00046	68 39 04 00 00	 push	 1081			; 00000439H
  0004b	6a 29		 push	 41			; 00000029H
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN38@EncryptBuf@3:
$LN13@EncryptBuf@3:

; 1082 : 
; 1083 : 	//  IV
; 1084 : 	bufIV[0] = iv[0];

  00053	8b 07		 mov	 eax, DWORD PTR [edi]

; 1085 : 	bufIV[1] = iv[1];

  00055	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 1086 : 	if (blockSize == 16)

  00058	83 fb 10	 cmp	 ebx, 16			; 00000010H
  0005b	75 0c		 jne	 SHORT $LN32@EncryptBuf@3

; 1087 : 	{
; 1088 : 		bufIV[2] = iv[2];

  0005d	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  00060	89 55 ec	 mov	 DWORD PTR _bufIV$[ebp+8], edx

; 1089 : 		bufIV[3] = iv[3];

  00063	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  00066	89 55 f0	 mov	 DWORD PTR _bufIV$[ebp+12], edx
$LN32@EncryptBuf@3:

; 1090 : 	}
; 1091 : 
; 1092 : 	// Encrypt each block
; 1093 : 	for (i = 0; i < len/blockSize; i++)

  00069	33 d2		 xor	 edx, edx
  0006b	89 55 f4	 mov	 DWORD PTR _i$[ebp], edx
  0006e	89 55 f8	 mov	 DWORD PTR _i$[ebp+4], edx
  00071	3b d2		 cmp	 edx, edx
  00073	0f 82 e1 00 00
	00		 jb	 $LN31@EncryptBuf@3
  00079	77 09		 ja	 SHORT $LN30@EncryptBuf@3
  0007b	39 55 08	 cmp	 DWORD PTR tv247[ebp], edx
  0007e	0f 86 d6 00 00
	00		 jbe	 $LN31@EncryptBuf@3
$LN30@EncryptBuf@3:
  00084	8b d3		 mov	 edx, ebx
  00086	c1 ea 02	 shr	 edx, 2
  00089	c1 e2 02	 shl	 edx, 2
  0008c	89 55 fc	 mov	 DWORD PTR tv284[ebp], edx
$LL33@EncryptBuf@3:

; 1094 : 	{
; 1095 : 		// CBC
; 1096 : 		data[0] ^= bufIV[0];

  0008f	31 06		 xor	 DWORD PTR [esi], eax

; 1097 : 		data[1] ^= bufIV[1];

  00091	31 4e 04	 xor	 DWORD PTR [esi+4], ecx

; 1098 : 		if (blockSize == 16)

  00094	83 fb 10	 cmp	 ebx, 16			; 00000010H
  00097	75 0c		 jne	 SHORT $LN8@EncryptBuf@3

; 1099 : 		{
; 1100 : 			data[2] ^= bufIV[2];

  00099	8b 45 ec	 mov	 eax, DWORD PTR _bufIV$[ebp+8]
  0009c	31 46 08	 xor	 DWORD PTR [esi+8], eax

; 1101 : 			data[3] ^= bufIV[3];

  0009f	8b 45 f0	 mov	 eax, DWORD PTR _bufIV$[ebp+12]
  000a2	31 46 0c	 xor	 DWORD PTR [esi+12], eax
$LN8@EncryptBuf@3:

; 1102 : 		}
; 1103 : 
; 1104 : 		if (ea != 0)

  000a5	83 7d 14 00	 cmp	 DWORD PTR _ea$[ebp], 0
  000a9	74 48		 je	 SHORT $LN7@EncryptBuf@3

; 1105 : 		{
; 1106 : 			// Outer-CBC
; 1107 : 			for (cipher = EAGetFirstCipher (ea); cipher != 0; cipher = EAGetNextCipher (ea, cipher))

  000ab	8b 45 14	 mov	 eax, DWORD PTR _ea$[ebp]
  000ae	6b c0 2c	 imul	 eax, 44			; 0000002cH
  000b1	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax]
  000b7	eb 26		 jmp	 SHORT $LN37@EncryptBuf@3
$LL35@EncryptBuf@3:

; 1108 : 			{
; 1109 : 				EncipherBlock (cipher, data, ks);

  000b9	8b 7d 0c	 mov	 edi, DWORD PTR _ks$[ebp]
  000bc	57		 push	 edi
  000bd	56		 push	 esi
  000be	ff 75 18	 push	 DWORD PTR _cipher$[ebp]
  000c1	e8 00 00 00 00	 call	 _EncipherBlock@12

; 1110 : 				ks += CipherGetKeyScheduleSize (cipher);

  000c6	ff 75 18	 push	 DWORD PTR _cipher$[ebp]
  000c9	e8 00 00 00 00	 call	 _CipherGet@4
  000ce	ff 75 18	 push	 DWORD PTR _cipher$[ebp]
  000d1	03 78 10	 add	 edi, DWORD PTR [eax+16]
  000d4	ff 75 14	 push	 DWORD PTR _ea$[ebp]
  000d7	89 7d 0c	 mov	 DWORD PTR _ks$[ebp], edi
  000da	e8 00 00 00 00	 call	 _EAGetNextCipher@8
$LN37@EncryptBuf@3:
  000df	89 45 18	 mov	 DWORD PTR _cipher$[ebp], eax
  000e2	85 c0		 test	 eax, eax
  000e4	75 d3		 jne	 SHORT $LL35@EncryptBuf@3

; 1111 : 			}
; 1112 : 			ks -= EAGetKeyScheduleSize (ea);

  000e6	ff 75 14	 push	 DWORD PTR _ea$[ebp]
  000e9	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4
  000ee	29 45 0c	 sub	 DWORD PTR _ks$[ebp], eax

; 1113 : 		}
; 1114 : 		else

  000f1	eb 0c		 jmp	 SHORT $LN3@EncryptBuf@3
$LN7@EncryptBuf@3:

; 1115 : 		{
; 1116 : 			// CBC/inner-CBC
; 1117 : 			EncipherBlock (cipher, data, ks);

  000f3	ff 75 0c	 push	 DWORD PTR _ks$[ebp]
  000f6	56		 push	 esi
  000f7	ff 75 18	 push	 DWORD PTR _cipher$[ebp]
  000fa	e8 00 00 00 00	 call	 _EncipherBlock@12
$LN3@EncryptBuf@3:

; 1118 : 		}
; 1119 : 
; 1120 : 		// CBC
; 1121 : 		bufIV[0] = data[0];

  000ff	8b 06		 mov	 eax, DWORD PTR [esi]

; 1122 : 		bufIV[1] = data[1];

  00101	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 1123 : 		if (blockSize == 16)

  00104	83 fb 10	 cmp	 ebx, 16			; 00000010H
  00107	75 0c		 jne	 SHORT $LN2@EncryptBuf@3

; 1124 : 		{
; 1125 : 			bufIV[2] = data[2];

  00109	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0010c	89 55 ec	 mov	 DWORD PTR _bufIV$[ebp+8], edx

; 1126 : 			bufIV[3] = data[3];

  0010f	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00112	89 55 f0	 mov	 DWORD PTR _bufIV$[ebp+12], edx
$LN2@EncryptBuf@3:

; 1127 : 		}
; 1128 : 
; 1129 : 		// Whitening
; 1130 : 		data[0] ^= whitening[0];

  00115	8b 55 10	 mov	 edx, DWORD PTR _whitening$[ebp]
  00118	8b 3a		 mov	 edi, DWORD PTR [edx]
  0011a	33 f8		 xor	 edi, eax
  0011c	89 3e		 mov	 DWORD PTR [esi], edi

; 1131 : 		data[1] ^= whitening[1];

  0011e	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  00121	33 f9		 xor	 edi, ecx
  00123	89 7e 04	 mov	 DWORD PTR [esi+4], edi

; 1132 : 		if (blockSize == 16)

  00126	83 fb 10	 cmp	 ebx, 16			; 00000010H
  00129	75 0b		 jne	 SHORT $LN1@EncryptBuf@3

; 1133 : 		{
; 1134 : 			data[2] ^= whitening[0];

  0012b	8b 3a		 mov	 edi, DWORD PTR [edx]
  0012d	31 7e 08	 xor	 DWORD PTR [esi+8], edi

; 1135 : 			data[3] ^= whitening[1];

  00130	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00133	31 56 0c	 xor	 DWORD PTR [esi+12], edx
$LN1@EncryptBuf@3:

; 1136 : 		}
; 1137 : 
; 1138 : 		data += blockSize / sizeof(*data);

  00136	03 75 fc	 add	 esi, DWORD PTR tv284[ebp]
  00139	83 45 f4 01	 add	 DWORD PTR _i$[ebp], 1
  0013d	83 55 f8 00	 adc	 DWORD PTR _i$[ebp+4], 0
  00141	33 d2		 xor	 edx, edx
  00143	39 55 f8	 cmp	 DWORD PTR _i$[ebp+4], edx
  00146	0f 82 43 ff ff
	ff		 jb	 $LL33@EncryptBuf@3

; 1090 : 	}
; 1091 : 
; 1092 : 	// Encrypt each block
; 1093 : 	for (i = 0; i < len/blockSize; i++)

  0014c	77 0c		 ja	 SHORT $LN31@EncryptBuf@3
  0014e	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00151	3b 55 08	 cmp	 edx, DWORD PTR tv247[ebp]
  00154	0f 82 35 ff ff
	ff		 jb	 $LL33@EncryptBuf@3
$LN31@EncryptBuf@3:
  0015a	5f		 pop	 edi
  0015b	5e		 pop	 esi
  0015c	5b		 pop	 ebx

; 1139 : 	}
; 1140 : }

  0015d	c9		 leave
  0015e	c2 14 00	 ret	 20			; 00000014H
$LN36@EncryptBuf@3:
_EncryptBufferCBC@28 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _DecryptBufferCBC@28
_TEXT	SEGMENT
_ct$ = -48						; size = 16
_bufIV$ = -32						; size = 16
_i$ = -16						; size = 8
tv285 = -8						; size = 4
_blockSize$ = -4					; size = 4
tv247 = 8						; size = 4
_len$ = 8						; size = 4
_ks$ = 12						; size = 4
_whitening$ = 16					; size = 4
_ea$ = 20						; size = 4
_cipher$ = 24						; size = 4
_DecryptBufferCBC@28 PROC				; COMDAT
; _data$ = ecx
; _iv$ = eax

; 1161 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 30	 sub	 esp, 48			; 00000030H
  00008	53		 push	 ebx
  00009	56		 push	 esi

; 1162 : 
; 1163 : 	/* IMPORTANT: This function has been deprecated (legacy) */
; 1164 : 
; 1165 : 	unsigned __int32 bufIV[4];
; 1166 : 	unsigned __int64 i;
; 1167 : 	unsigned __int32 ct[4];
; 1168 : 	int blockSize = CipherGetBlockSize (ea != 0 ? EAGetFirstCipher (ea) : cipher);

  0000a	33 db		 xor	 ebx, ebx
  0000c	57		 push	 edi
  0000d	8b f8		 mov	 edi, eax
  0000f	8b f1		 mov	 esi, ecx
  00011	39 5d 14	 cmp	 DWORD PTR _ea$[ebp], ebx
  00014	74 0e		 je	 SHORT $LN16@DecryptBuf@3
  00016	8b 45 14	 mov	 eax, DWORD PTR _ea$[ebp]
  00019	6b c0 2c	 imul	 eax, 44			; 0000002cH
  0001c	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax]
  00022	eb 03		 jmp	 SHORT $LN17@DecryptBuf@3
$LN16@DecryptBuf@3:
  00024	8b 45 18	 mov	 eax, DWORD PTR _cipher$[ebp]
$LN17@DecryptBuf@3:
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _CipherGet@4
  0002d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 1169 : 
; 1170 : 	if (len % blockSize)

  00030	8b 45 08	 mov	 eax, DWORD PTR _len$[ebp]
  00033	33 d2		 xor	 edx, edx
  00035	f7 f1		 div	 ecx
  00037	89 4d fc	 mov	 DWORD PTR _blockSize$[ebp], ecx
  0003a	89 45 08	 mov	 DWORD PTR tv247[ebp], eax
  0003d	3b d3		 cmp	 edx, ebx
  0003f	74 14		 je	 SHORT $LN13@DecryptBuf@3

; 1171 : 		TC_THROW_FATAL_EXCEPTION;

  00041	68 43 54 00 00	 push	 21571			; 00005443H
  00046	53		 push	 ebx
  00047	53		 push	 ebx
  00048	68 93 04 00 00	 push	 1171			; 00000493H
  0004d	6a 29		 push	 41			; 00000029H
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN35@DecryptBuf@3:
$LN13@DecryptBuf@3:

; 1172 : 
; 1173 : 	//  IV
; 1174 : 	bufIV[0] = iv[0];

  00055	8b 07		 mov	 eax, DWORD PTR [edi]
  00057	89 45 e0	 mov	 DWORD PTR _bufIV$[ebp], eax

; 1175 : 	bufIV[1] = iv[1];

  0005a	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0005d	89 45 e4	 mov	 DWORD PTR _bufIV$[ebp+4], eax

; 1176 : 	if (blockSize == 16)

  00060	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00063	75 0c		 jne	 SHORT $LN30@DecryptBuf@3

; 1177 : 	{
; 1178 : 		bufIV[2] = iv[2];

  00065	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00068	89 45 e8	 mov	 DWORD PTR _bufIV$[ebp+8], eax

; 1179 : 		bufIV[3] = iv[3];

  0006b	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0006e	89 45 ec	 mov	 DWORD PTR _bufIV$[ebp+12], eax
$LN30@DecryptBuf@3:

; 1180 : 	}
; 1181 : 
; 1182 : 	// Decrypt each block
; 1183 : 	for (i = 0; i < len/blockSize; i++)

  00071	33 c0		 xor	 eax, eax
  00073	89 5d f0	 mov	 DWORD PTR _i$[ebp], ebx
  00076	89 5d f4	 mov	 DWORD PTR _i$[ebp+4], ebx
  00079	3b c3		 cmp	 eax, ebx
  0007b	0f 82 f7 00 00
	00		 jb	 $LN29@DecryptBuf@3
  00081	77 09		 ja	 SHORT $LN28@DecryptBuf@3
  00083	39 5d 08	 cmp	 DWORD PTR tv247[ebp], ebx
  00086	0f 86 ec 00 00
	00		 jbe	 $LN29@DecryptBuf@3
$LN28@DecryptBuf@3:
  0008c	8b c1		 mov	 eax, ecx
  0008e	c1 e8 02	 shr	 eax, 2
  00091	c1 e0 02	 shl	 eax, 2
  00094	89 45 f8	 mov	 DWORD PTR tv285[ebp], eax
  00097	eb 03		 jmp	 SHORT $LN11@DecryptBuf@3
$LL31@DecryptBuf@3:
  00099	8b 4d fc	 mov	 ecx, DWORD PTR _blockSize$[ebp]
$LN11@DecryptBuf@3:

; 1184 : 	{
; 1185 : 		// Dewhitening
; 1186 : 		data[0] ^= whitening[0];

  0009c	8b 45 10	 mov	 eax, DWORD PTR _whitening$[ebp]
  0009f	8b 10		 mov	 edx, DWORD PTR [eax]
  000a1	31 16		 xor	 DWORD PTR [esi], edx

; 1187 : 		data[1] ^= whitening[1];

  000a3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a6	31 56 04	 xor	 DWORD PTR [esi+4], edx

; 1188 : 		if (blockSize == 16)

  000a9	83 f9 10	 cmp	 ecx, 16			; 00000010H
  000ac	75 0b		 jne	 SHORT $LN8@DecryptBuf@3

; 1189 : 		{
; 1190 : 			data[2] ^= whitening[0];

  000ae	8b 10		 mov	 edx, DWORD PTR [eax]
  000b0	31 56 08	 xor	 DWORD PTR [esi+8], edx

; 1191 : 			data[3] ^= whitening[1];

  000b3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b6	31 46 0c	 xor	 DWORD PTR [esi+12], eax
$LN8@DecryptBuf@3:

; 1192 : 		}
; 1193 : 
; 1194 : 		// CBC
; 1195 : 		ct[0] = data[0];

  000b9	8b 3e		 mov	 edi, DWORD PTR [esi]

; 1196 : 		ct[1] = data[1];

  000bb	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]

; 1197 : 		if (blockSize == 16)

  000be	83 f9 10	 cmp	 ecx, 16			; 00000010H
  000c1	75 0c		 jne	 SHORT $LN7@DecryptBuf@3

; 1198 : 		{
; 1199 : 			ct[2] = data[2];

  000c3	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000c6	89 45 d8	 mov	 DWORD PTR _ct$[ebp+8], eax

; 1200 : 			ct[3] = data[3];

  000c9	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  000cc	89 45 dc	 mov	 DWORD PTR _ct$[ebp+12], eax
$LN7@DecryptBuf@3:

; 1201 : 		}
; 1202 : 
; 1203 : 		if (ea != 0)

  000cf	83 7d 14 00	 cmp	 DWORD PTR _ea$[ebp], 0
  000d3	74 44		 je	 SHORT $LN6@DecryptBuf@3

; 1204 : 		{
; 1205 : 			// Outer-CBC
; 1206 : 			ks += EAGetKeyScheduleSize (ea);

  000d5	ff 75 14	 push	 DWORD PTR _ea$[ebp]
  000d8	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4

; 1207 : 			for (cipher = EAGetLastCipher (ea); cipher != 0; cipher = EAGetPreviousCipher (ea, cipher))

  000dd	ff 75 14	 push	 DWORD PTR _ea$[ebp]
  000e0	01 45 0c	 add	 DWORD PTR _ks$[ebp], eax
  000e3	e8 00 00 00 00	 call	 _EAGetLastCipher@4
  000e8	eb 26		 jmp	 SHORT $LN34@DecryptBuf@3
$LL32@DecryptBuf@3:

; 1208 : 			{
; 1209 : 				ks -= CipherGetKeyScheduleSize (cipher);

  000ea	ff 75 18	 push	 DWORD PTR _cipher$[ebp]
  000ed	e8 00 00 00 00	 call	 _CipherGet@4
  000f2	8b 4d 0c	 mov	 ecx, DWORD PTR _ks$[ebp]
  000f5	2b 48 10	 sub	 ecx, DWORD PTR [eax+16]

; 1210 : 				DecipherBlock (cipher, data, ks);

  000f8	51		 push	 ecx
  000f9	56		 push	 esi
  000fa	ff 75 18	 push	 DWORD PTR _cipher$[ebp]
  000fd	89 4d 0c	 mov	 DWORD PTR _ks$[ebp], ecx
  00100	e8 00 00 00 00	 call	 _DecipherBlock@12
  00105	ff 75 18	 push	 DWORD PTR _cipher$[ebp]
  00108	ff 75 14	 push	 DWORD PTR _ea$[ebp]
  0010b	e8 00 00 00 00	 call	 _EAGetPreviousCipher@8
$LN34@DecryptBuf@3:
  00110	89 45 18	 mov	 DWORD PTR _cipher$[ebp], eax
  00113	85 c0		 test	 eax, eax
  00115	75 d3		 jne	 SHORT $LL32@DecryptBuf@3

; 1211 : 			}
; 1212 : 		}
; 1213 : 		else

  00117	eb 0c		 jmp	 SHORT $LN2@DecryptBuf@3
$LN6@DecryptBuf@3:

; 1214 : 		{
; 1215 : 			// CBC/inner-CBC
; 1216 : 			DecipherBlock (cipher, data, ks);

  00119	ff 75 0c	 push	 DWORD PTR _ks$[ebp]
  0011c	56		 push	 esi
  0011d	ff 75 18	 push	 DWORD PTR _cipher$[ebp]
  00120	e8 00 00 00 00	 call	 _DecipherBlock@12
$LN2@DecryptBuf@3:

; 1217 : 		}
; 1218 : 
; 1219 : 		// CBC
; 1220 : 		data[0] ^= bufIV[0];

  00125	8b 45 e0	 mov	 eax, DWORD PTR _bufIV$[ebp]
  00128	31 06		 xor	 DWORD PTR [esi], eax

; 1221 : 		data[1] ^= bufIV[1];

  0012a	8b 45 e4	 mov	 eax, DWORD PTR _bufIV$[ebp+4]
  0012d	31 46 04	 xor	 DWORD PTR [esi+4], eax

; 1222 : 		bufIV[0] = ct[0];
; 1223 : 		bufIV[1] = ct[1];
; 1224 : 		if (blockSize == 16)

  00130	83 7d fc 10	 cmp	 DWORD PTR _blockSize$[ebp], 16 ; 00000010H
  00134	89 7d e0	 mov	 DWORD PTR _bufIV$[ebp], edi
  00137	89 5d e4	 mov	 DWORD PTR _bufIV$[ebp+4], ebx
  0013a	75 18		 jne	 SHORT $LN1@DecryptBuf@3

; 1225 : 		{
; 1226 : 			data[2] ^= bufIV[2];

  0013c	8b 45 e8	 mov	 eax, DWORD PTR _bufIV$[ebp+8]
  0013f	31 46 08	 xor	 DWORD PTR [esi+8], eax

; 1227 : 			data[3] ^= bufIV[3];

  00142	8b 45 ec	 mov	 eax, DWORD PTR _bufIV$[ebp+12]
  00145	31 46 0c	 xor	 DWORD PTR [esi+12], eax

; 1228 : 			bufIV[2] = ct[2];

  00148	8b 45 d8	 mov	 eax, DWORD PTR _ct$[ebp+8]
  0014b	89 45 e8	 mov	 DWORD PTR _bufIV$[ebp+8], eax

; 1229 : 			bufIV[3] = ct[3];

  0014e	8b 45 dc	 mov	 eax, DWORD PTR _ct$[ebp+12]
  00151	89 45 ec	 mov	 DWORD PTR _bufIV$[ebp+12], eax
$LN1@DecryptBuf@3:

; 1230 : 		}
; 1231 : 
; 1232 : 		data += blockSize / sizeof(*data);

  00154	03 75 f8	 add	 esi, DWORD PTR tv285[ebp]
  00157	83 45 f0 01	 add	 DWORD PTR _i$[ebp], 1
  0015b	83 55 f4 00	 adc	 DWORD PTR _i$[ebp+4], 0
  0015f	33 c0		 xor	 eax, eax
  00161	39 45 f4	 cmp	 DWORD PTR _i$[ebp+4], eax
  00164	0f 82 2f ff ff
	ff		 jb	 $LL31@DecryptBuf@3

; 1180 : 	}
; 1181 : 
; 1182 : 	// Decrypt each block
; 1183 : 	for (i = 0; i < len/blockSize; i++)

  0016a	77 0c		 ja	 SHORT $LN29@DecryptBuf@3
  0016c	8b 45 08	 mov	 eax, DWORD PTR tv247[ebp]
  0016f	39 45 f0	 cmp	 DWORD PTR _i$[ebp], eax
  00172	0f 82 21 ff ff
	ff		 jb	 $LL31@DecryptBuf@3
$LN29@DecryptBuf@3:
  00178	5f		 pop	 edi
  00179	5e		 pop	 esi
  0017a	5b		 pop	 ebx

; 1233 : 	}
; 1234 : }

  0017b	c9		 leave
  0017c	c2 14 00	 ret	 20			; 00000014H
$LN33@DecryptBuf@3:
_DecryptBufferCBC@28 ENDP
_TEXT	ENDS
PUBLIC	_EncryptBuffer@16
EXTRN	_EncryptBufferXTS@32:PROC
; Function compile flags: /Ogsp
;	COMDAT _EncryptBuffer@16
_TEXT	SEGMENT
_dataUnitNo$27664 = -8					; size = 8
_buf$ = 8						; size = 4
_len$ = 12						; size = 8
_ks2$27663 = 20						; size = 4
_cryptoInfo$ = 20					; size = 4
_EncryptBuffer@16 PROC					; COMDAT

; 1244 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	51		 push	 ecx
  00007	53		 push	 ebx
  00008	56		 push	 esi

; 1245 : 	switch (cryptoInfo->mode)

  00009	8b 75 14	 mov	 esi, DWORD PTR _cryptoInfo$[ebp]
  0000c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000f	48		 dec	 eax
  00010	57		 push	 edi
  00011	0f 84 ed 00 00
	00		 je	 $LN16@EncryptBuf@4
  00017	48		 dec	 eax
  00018	0f 84 8c 00 00
	00		 je	 $LN12@EncryptBuf@4
  0001e	48		 dec	 eax
  0001f	74 41		 je	 SHORT $LN6@EncryptBuf@4
  00021	48		 dec	 eax
  00022	74 19		 je	 SHORT $LN2@EncryptBuf@4
  00024	48		 dec	 eax
  00025	74 3b		 je	 SHORT $LN6@EncryptBuf@4

; 1330 : #endif	// #ifndef TC_NO_COMPILER_INT64
; 1331 : 
; 1332 : 	default:		
; 1333 : 		// Unknown/wrong ID
; 1334 : 		TC_THROW_FATAL_EXCEPTION;

  00027	68 43 54 00 00	 push	 21571			; 00005443H
  0002c	6a 00		 push	 0
  0002e	6a 00		 push	 0
  00030	68 36 05 00 00	 push	 1334			; 00000536H
$LN44@EncryptBuf@4:
  00035	6a 29		 push	 41			; 00000029H
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN45@EncryptBuf@4:
$LN2@EncryptBuf@4:

; 1316 : 
; 1317 : 	case OUTER_CBC:
; 1318 : 
; 1319 : 		/* Deprecated/legacy */
; 1320 : 
; 1321 : 		EncryptBufferCBC ((unsigned __int32 *) buf,
; 1322 : 			(unsigned int) len,
; 1323 : 			cryptoInfo->ks,
; 1324 : 			(unsigned __int32 *) cryptoInfo->k2,
; 1325 : 			(unsigned __int32 *) &cryptoInfo->k2[8],
; 1326 : 			cryptoInfo->ea,
; 1327 : 			0);

  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00040	6a 00		 push	 0
  00042	ff 36		 push	 DWORD PTR [esi]
  00044	8d 86 b0 42 00
	00		 lea	 eax, DWORD PTR [esi+17072]
  0004a	50		 push	 eax
  0004b	8d 86 a8 42 00
	00		 lea	 eax, DWORD PTR [esi+17064]
  00051	83 c6 08	 add	 esi, 8
  00054	56		 push	 esi
  00055	ff 75 0c	 push	 DWORD PTR _len$[ebp]
  00058	e8 00 00 00 00	 call	 _EncryptBufferCBC@28

; 1328 : 
; 1329 : 		break;

  0005d	e9 f8 00 00 00	 jmp	 $LN13@EncryptBuf@4
$LN6@EncryptBuf@4:

; 1291 : 
; 1292 : 	case CBC:
; 1293 : 	case INNER_CBC:
; 1294 : 		{
; 1295 : 			/* Deprecated/legacy */
; 1296 : 
; 1297 : 			unsigned __int8 *ks = cryptoInfo->ks;
; 1298 : 			int cipher;
; 1299 : 
; 1300 : 			for (cipher = EAGetFirstCipher (cryptoInfo->ea);
; 1301 : 				cipher != 0;
; 1302 : 				cipher = EAGetNextCipher (cryptoInfo->ea, cipher))

  00062	8b 06		 mov	 eax, DWORD PTR [esi]
  00064	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00067	8b 98 00 00 00
	00		 mov	 ebx, DWORD PTR _EncryptionAlgorithms[eax]
  0006d	8d 7e 08	 lea	 edi, DWORD PTR [esi+8]
  00070	eb 2f		 jmp	 SHORT $LN42@EncryptBuf@4
$LL39@EncryptBuf@4:

; 1303 : 			{
; 1304 : 				EncryptBufferCBC ((unsigned __int32 *) buf,
; 1305 : 					(unsigned int) len,
; 1306 : 					ks,
; 1307 : 					(unsigned __int32 *) cryptoInfo->k2,
; 1308 : 					(unsigned __int32 *) &cryptoInfo->k2[8],
; 1309 : 					0,
; 1310 : 					cipher);

  00072	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00075	53		 push	 ebx
  00076	6a 00		 push	 0
  00078	8d 86 b0 42 00
	00		 lea	 eax, DWORD PTR [esi+17072]
  0007e	50		 push	 eax
  0007f	57		 push	 edi
  00080	ff 75 0c	 push	 DWORD PTR _len$[ebp]
  00083	8d 86 a8 42 00
	00		 lea	 eax, DWORD PTR [esi+17064]
  00089	e8 00 00 00 00	 call	 _EncryptBufferCBC@28

; 1311 : 
; 1312 : 				ks += CipherGetKeyScheduleSize (cipher);

  0008e	53		 push	 ebx
  0008f	e8 00 00 00 00	 call	 _CipherGet@4
  00094	03 78 10	 add	 edi, DWORD PTR [eax+16]
  00097	53		 push	 ebx
  00098	ff 36		 push	 DWORD PTR [esi]
  0009a	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  0009f	8b d8		 mov	 ebx, eax
$LN42@EncryptBuf@4:

; 1291 : 
; 1292 : 	case CBC:
; 1293 : 	case INNER_CBC:
; 1294 : 		{
; 1295 : 			/* Deprecated/legacy */
; 1296 : 
; 1297 : 			unsigned __int8 *ks = cryptoInfo->ks;
; 1298 : 			int cipher;
; 1299 : 
; 1300 : 			for (cipher = EAGetFirstCipher (cryptoInfo->ea);
; 1301 : 				cipher != 0;
; 1302 : 				cipher = EAGetNextCipher (cryptoInfo->ea, cipher))

  000a1	85 db		 test	 ebx, ebx
  000a3	75 cd		 jne	 SHORT $LL39@EncryptBuf@4

; 1313 : 			}
; 1314 : 		}
; 1315 : 		break;

  000a5	e9 b0 00 00 00	 jmp	 $LN13@EncryptBuf@4
$LN12@EncryptBuf@4:

; 1268 : 			}
; 1269 : 		}
; 1270 : 		break;
; 1271 : 
; 1272 : #ifndef TC_NO_COMPILER_INT64
; 1273 : 	case LRW:
; 1274 : 
; 1275 : 		/* Deprecated/legacy */
; 1276 : 
; 1277 : 		switch (CipherGetBlockSize (EAGetFirstCipher (cryptoInfo->ea)))

  000aa	8b 06		 mov	 eax, DWORD PTR [esi]
  000ac	6b c0 2c	 imul	 eax, 44			; 0000002cH
  000af	ff b0 00 00 00
	00		 push	 DWORD PTR _EncryptionAlgorithms[eax]
  000b5	e8 00 00 00 00	 call	 _CipherGet@4
  000ba	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000bd	83 f8 08	 cmp	 eax, 8
  000c0	74 2d		 je	 SHORT $LN9@EncryptBuf@4
  000c2	83 f8 10	 cmp	 eax, 16			; 00000010H
  000c5	74 13		 je	 SHORT $LN8@EncryptBuf@4

; 1286 : 
; 1287 : 		default:
; 1288 : 			TC_THROW_FATAL_EXCEPTION;

  000c7	68 43 54 00 00	 push	 21571			; 00005443H
  000cc	6a 00		 push	 0
  000ce	6a 00		 push	 0
  000d0	68 08 05 00 00	 push	 1288			; 00000508H
  000d5	e9 5b ff ff ff	 jmp	 $LN44@EncryptBuf@4
$LN8@EncryptBuf@4:

; 1281 : 			break;
; 1282 : 
; 1283 : 		case 16:
; 1284 : 			EncryptBufferLRW128 ((unsigned __int8 *)buf, (unsigned __int64) len, 1, cryptoInfo);

  000da	56		 push	 esi
  000db	6a 00		 push	 0
  000dd	6a 01		 push	 1
  000df	ff 75 10	 push	 DWORD PTR _len$[ebp+4]
  000e2	ff 75 0c	 push	 DWORD PTR _len$[ebp]
  000e5	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  000e8	e8 00 00 00 00	 call	 _EncryptBufferLRW128@24

; 1285 : 			break;

  000ed	eb 6b		 jmp	 SHORT $LN13@EncryptBuf@4
$LN9@EncryptBuf@4:

; 1278 : 		{
; 1279 : 		case 8:
; 1280 : 			EncryptBufferLRW64 ((unsigned __int8 *)buf, (unsigned __int64) len, 1, cryptoInfo);

  000ef	56		 push	 esi
  000f0	6a 00		 push	 0
  000f2	6a 01		 push	 1
  000f4	ff 75 10	 push	 DWORD PTR _len$[ebp+4]
  000f7	ff 75 0c	 push	 DWORD PTR _len$[ebp]
  000fa	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  000fd	e8 00 00 00 00	 call	 _EncryptBufferLRW64@24

; 1289 : 		}
; 1290 : 		break;

  00102	eb 56		 jmp	 SHORT $LN13@EncryptBuf@4
$LN16@EncryptBuf@4:

; 1246 : 	{
; 1247 : 	case XTS:
; 1248 : 		{
; 1249 : 			unsigned __int8 *ks = cryptoInfo->ks;
; 1250 : 			unsigned __int8 *ks2 = cryptoInfo->ks2;
; 1251 : 			UINT64_STRUCT dataUnitNo;
; 1252 : 			int cipher;
; 1253 : 
; 1254 : 			// When encrypting/decrypting a buffer (typically a volume header) the sequential number
; 1255 : 			// of the first XTS data unit in the buffer is always 0 and the start of the buffer is
; 1256 : 			// always assumed to be aligned with the start of a data unit.
; 1257 : 			dataUnitNo.LowPart = 0;

  00104	83 65 f8 00	 and	 DWORD PTR _dataUnitNo$27664[ebp], 0

; 1258 : 			dataUnitNo.HighPart = 0;

  00108	83 65 fc 00	 and	 DWORD PTR _dataUnitNo$27664[ebp+4], 0
  0010c	8d 86 d4 14 00
	00		 lea	 eax, DWORD PTR [esi+5332]
  00112	89 45 14	 mov	 DWORD PTR _ks2$27663[ebp], eax

; 1259 : 
; 1260 : 			for (cipher = EAGetFirstCipher (cryptoInfo->ea);
; 1261 : 				cipher != 0;
; 1262 : 				cipher = EAGetNextCipher (cryptoInfo->ea, cipher))

  00115	8b 06		 mov	 eax, DWORD PTR [esi]
  00117	6b c0 2c	 imul	 eax, 44			; 0000002cH
  0011a	8b b8 00 00 00
	00		 mov	 edi, DWORD PTR _EncryptionAlgorithms[eax]
  00120	8d 5e 08	 lea	 ebx, DWORD PTR [esi+8]
  00123	eb 31		 jmp	 SHORT $LN43@EncryptBuf@4
$LL40@EncryptBuf@4:

; 1263 : 			{
; 1264 : 				EncryptBufferXTS (buf, len, &dataUnitNo, 0, ks, ks2, cipher);

  00125	57		 push	 edi
  00126	ff 75 14	 push	 DWORD PTR _ks2$27663[ebp]
  00129	8d 45 f8	 lea	 eax, DWORD PTR _dataUnitNo$27664[ebp]
  0012c	53		 push	 ebx
  0012d	6a 00		 push	 0
  0012f	50		 push	 eax
  00130	ff 75 10	 push	 DWORD PTR _len$[ebp+4]
  00133	ff 75 0c	 push	 DWORD PTR _len$[ebp]
  00136	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  00139	e8 00 00 00 00	 call	 _EncryptBufferXTS@32

; 1265 : 
; 1266 : 				ks += CipherGetKeyScheduleSize (cipher);

  0013e	57		 push	 edi
  0013f	e8 00 00 00 00	 call	 _CipherGet@4
  00144	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 1267 : 				ks2 += CipherGetKeyScheduleSize (cipher);

  00147	01 45 14	 add	 DWORD PTR _ks2$27663[ebp], eax
  0014a	57		 push	 edi
  0014b	ff 36		 push	 DWORD PTR [esi]
  0014d	03 d8		 add	 ebx, eax
  0014f	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  00154	8b f8		 mov	 edi, eax
$LN43@EncryptBuf@4:

; 1259 : 
; 1260 : 			for (cipher = EAGetFirstCipher (cryptoInfo->ea);
; 1261 : 				cipher != 0;
; 1262 : 				cipher = EAGetNextCipher (cryptoInfo->ea, cipher))

  00156	85 ff		 test	 edi, edi
  00158	75 cb		 jne	 SHORT $LL40@EncryptBuf@4
$LN13@EncryptBuf@4:
  0015a	5f		 pop	 edi
  0015b	5e		 pop	 esi
  0015c	5b		 pop	 ebx

; 1335 : 	}
; 1336 : }

  0015d	c9		 leave
  0015e	c2 10 00	 ret	 16			; 00000010H
$LN41@EncryptBuf@4:
_EncryptBuffer@16 ENDP
_TEXT	ENDS
PUBLIC	_EncryptDataUnitsCurrentThread@20
EXTRN	__allmul:PROC
; Function compile flags: /Ogsp
;	COMDAT _EncryptDataUnitsCurrentThread@20
_TEXT	SEGMENT
_sectorIV$ = -40					; size = 16
_secWhitening$ = -24					; size = 8
_unitNo$ = -16						; size = 8
_ea$ = -8						; size = 4
_iv64$ = -4						; size = 4
_buf$ = 8						; size = 4
tv269 = 12						; size = 4
_structUnitNo$ = 12					; size = 4
tv293 = 16						; size = 8
_nbrUnits$ = 16						; size = 8
_ks2$ = 24						; size = 4
_ci$ = 24						; size = 4
_EncryptDataUnitsCurrentThread@20 PROC			; COMDAT

; 1378 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 28	 sub	 esp, 40			; 00000028H

; 1379 : 	int ea = ci->ea;

  00008	8b 55 18	 mov	 edx, DWORD PTR _ci$[ebp]

; 1380 : 	unsigned __int8 *ks = ci->ks;
; 1381 : 	unsigned __int8 *ks2 = ci->ks2;

  0000b	8d 82 d4 14 00
	00		 lea	 eax, DWORD PTR [edx+5332]
  00011	89 45 18	 mov	 DWORD PTR _ks2$[ebp], eax

; 1382 : 	int cipher;
; 1383 : 
; 1384 : #ifndef TC_NO_COMPILER_INT64
; 1385 : 	void *iv = ci->k2;									// Deprecated/legacy
; 1386 : 	unsigned __int64 unitNo = structUnitNo->Value;

  00014	8b 45 0c	 mov	 eax, DWORD PTR _structUnitNo$[ebp]
  00017	53		 push	 ebx
  00018	8b 1a		 mov	 ebx, DWORD PTR [edx]
  0001a	56		 push	 esi
  0001b	8b 30		 mov	 esi, DWORD PTR [eax]
  0001d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00020	89 45 f4	 mov	 DWORD PTR _unitNo$[ebp+4], eax
  00023	8d 82 a8 42 00
	00		 lea	 eax, DWORD PTR [edx+17064]
  00029	89 45 fc	 mov	 DWORD PTR _iv64$[ebp], eax

; 1387 : 	unsigned __int64 *iv64 = (unsigned __int64 *) iv;	// Deprecated/legacy
; 1388 : 	unsigned __int32 sectorIV[4];						// Deprecated/legacy
; 1389 : 	unsigned __int32 secWhitening[2];					// Deprecated/legacy
; 1390 : #endif
; 1391 : 
; 1392 : 	switch (ci->mode)

  0002c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0002f	48		 dec	 eax
  00030	57		 push	 edi
  00031	89 5d f8	 mov	 DWORD PTR _ea$[ebp], ebx
  00034	8d 7a 08	 lea	 edi, DWORD PTR [edx+8]
  00037	89 75 f0	 mov	 DWORD PTR _unitNo$[ebp], esi
  0003a	0f 84 c7 01 00
	00		 je	 $LN20@EncryptDat
  00040	48		 dec	 eax
  00041	0f 84 35 01 00
	00		 je	 $LN16@EncryptDat
  00047	48		 dec	 eax
  00048	0f 84 96 00 00
	00		 je	 $LN46@EncryptDat
  0004e	48		 dec	 eax
  0004f	74 1d		 je	 SHORT $LN45@EncryptDat
  00051	48		 dec	 eax
  00052	0f 84 8c 00 00
	00		 je	 $LN46@EncryptDat

; 1483 : #endif	// #ifndef TC_NO_COMPILER_INT64
; 1484 : 
; 1485 : 	default:		
; 1486 : 		// Unknown/wrong ID
; 1487 : 		TC_THROW_FATAL_EXCEPTION;

  00058	68 43 54 00 00	 push	 21571			; 00005443H
  0005d	6a 00		 push	 0
  0005f	6a 00		 push	 0
  00061	68 cf 05 00 00	 push	 1487			; 000005cfH
$LN60@EncryptDat:
  00066	6a 29		 push	 41			; 00000029H
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN61@EncryptDat:
$LN45@EncryptDat:

; 1462 : 
; 1463 : 	case OUTER_CBC:
; 1464 : 
; 1465 : 		/* Deprecated/legacy */
; 1466 : 
; 1467 : 		while (nbrUnits--)

  0006e	8b 45 10	 mov	 eax, DWORD PTR _nbrUnits$[ebp]
  00071	0b 45 14	 or	 eax, DWORD PTR _nbrUnits$[ebp+4]
  00074	0f 84 e7 01 00
	00		 je	 $LN17@EncryptDat
  0007a	8b c3		 mov	 eax, ebx
  0007c	6b c0 2c	 imul	 eax, 44			; 0000002cH
  0007f	8d 80 00 00 00
	00		 lea	 eax, DWORD PTR _EncryptionAlgorithms[eax]
  00085	89 45 0c	 mov	 DWORD PTR tv269[ebp], eax
  00088	be 00 02 00 00	 mov	 esi, 512		; 00000200H
$LL3@EncryptDat:
  0008d	83 45 10 ff	 add	 DWORD PTR _nbrUnits$[ebp], -1

; 1468 : 		{
; 1469 : 			InitSectorIVAndWhitening (unitNo, CipherGetBlockSize (EAGetFirstCipher (ea)), sectorIV, iv64, secWhitening);

  00091	8d 45 e8	 lea	 eax, DWORD PTR _secWhitening$[ebp]
  00094	50		 push	 eax
  00095	83 55 14 ff	 adc	 DWORD PTR _nbrUnits$[ebp+4], -1
  00099	8d 45 d8	 lea	 eax, DWORD PTR _sectorIV$[ebp]
  0009c	50		 push	 eax
  0009d	8b 45 0c	 mov	 eax, DWORD PTR tv269[ebp]
  000a0	ff 30		 push	 DWORD PTR [eax]
  000a2	e8 00 00 00 00	 call	 _CipherGet@4
  000a7	ff 70 08	 push	 DWORD PTR [eax+8]
  000aa	8b 45 fc	 mov	 eax, DWORD PTR _iv64$[ebp]
  000ad	ff 75 f4	 push	 DWORD PTR _unitNo$[ebp+4]
  000b0	ff 75 f0	 push	 DWORD PTR _unitNo$[ebp]
  000b3	e8 00 00 00 00	 call	 _InitSectorIVAndWhitening@24

; 1470 : 
; 1471 : 			EncryptBufferCBC ((unsigned __int32 *) buf,
; 1472 : 				ENCRYPTION_DATA_UNIT_SIZE,
; 1473 : 				ks,
; 1474 : 				sectorIV,
; 1475 : 				secWhitening,
; 1476 : 				ea,
; 1477 : 				0);

  000b8	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  000bb	6a 00		 push	 0
  000bd	53		 push	 ebx
  000be	8d 45 e8	 lea	 eax, DWORD PTR _secWhitening$[ebp]
  000c1	50		 push	 eax
  000c2	57		 push	 edi
  000c3	56		 push	 esi
  000c4	8d 45 d8	 lea	 eax, DWORD PTR _sectorIV$[ebp]
  000c7	e8 00 00 00 00	 call	 _EncryptBufferCBC@28

; 1478 : 
; 1479 : 			buf += ENCRYPTION_DATA_UNIT_SIZE;

  000cc	01 75 08	 add	 DWORD PTR _buf$[ebp], esi

; 1480 : 			unitNo++;

  000cf	83 45 f0 01	 add	 DWORD PTR _unitNo$[ebp], 1
  000d3	8b 45 10	 mov	 eax, DWORD PTR _nbrUnits$[ebp]
  000d6	83 55 f4 00	 adc	 DWORD PTR _unitNo$[ebp+4], 0
  000da	0b 45 14	 or	 eax, DWORD PTR _nbrUnits$[ebp+4]
  000dd	75 ae		 jne	 SHORT $LL3@EncryptDat

; 1481 : 		}
; 1482 : 		break;

  000df	e9 7d 01 00 00	 jmp	 $LN17@EncryptDat
$LN46@EncryptDat:

; 1435 : 
; 1436 : 	case CBC:
; 1437 : 	case INNER_CBC:
; 1438 : 
; 1439 : 		/* Deprecated/legacy */
; 1440 : 
; 1441 : 		while (nbrUnits--)

  000e4	8b 45 10	 mov	 eax, DWORD PTR _nbrUnits$[ebp]
  000e7	0b 45 14	 or	 eax, DWORD PTR _nbrUnits$[ebp+4]
  000ea	0f 84 71 01 00
	00		 je	 $LN17@EncryptDat
  000f0	6b db 2c	 imul	 ebx, 44			; 0000002cH
  000f3	8d 83 00 00 00
	00		 lea	 eax, DWORD PTR _EncryptionAlgorithms[ebx]
  000f9	89 45 0c	 mov	 DWORD PTR tv269[ebp], eax
  000fc	be 00 02 00 00	 mov	 esi, 512		; 00000200H
$LL9@EncryptDat:
  00101	83 45 10 ff	 add	 DWORD PTR _nbrUnits$[ebp], -1

; 1442 : 		{
; 1443 : 			for (cipher = EAGetFirstCipher (ea); cipher != 0; cipher = EAGetNextCipher (ea, cipher))

  00105	8b 45 0c	 mov	 eax, DWORD PTR tv269[ebp]
  00108	8b 18		 mov	 ebx, DWORD PTR [eax]
  0010a	83 55 14 ff	 adc	 DWORD PTR _nbrUnits$[ebp+4], -1
  0010e	eb 47		 jmp	 SHORT $LN59@EncryptDat
$LL7@EncryptDat:

; 1444 : 			{
; 1445 : 				InitSectorIVAndWhitening (unitNo, CipherGetBlockSize (cipher), sectorIV, iv64, secWhitening);

  00110	8d 45 e8	 lea	 eax, DWORD PTR _secWhitening$[ebp]
  00113	50		 push	 eax
  00114	8d 45 d8	 lea	 eax, DWORD PTR _sectorIV$[ebp]
  00117	50		 push	 eax
  00118	53		 push	 ebx
  00119	e8 00 00 00 00	 call	 _CipherGet@4
  0011e	ff 70 08	 push	 DWORD PTR [eax+8]
  00121	8b 45 fc	 mov	 eax, DWORD PTR _iv64$[ebp]
  00124	ff 75 f4	 push	 DWORD PTR _unitNo$[ebp+4]
  00127	ff 75 f0	 push	 DWORD PTR _unitNo$[ebp]
  0012a	e8 00 00 00 00	 call	 _InitSectorIVAndWhitening@24

; 1446 : 
; 1447 : 				EncryptBufferCBC ((unsigned __int32 *) buf,
; 1448 : 					ENCRYPTION_DATA_UNIT_SIZE,
; 1449 : 					ks,
; 1450 : 					sectorIV,
; 1451 : 					secWhitening,
; 1452 : 					0,
; 1453 : 					cipher);

  0012f	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00132	53		 push	 ebx
  00133	6a 00		 push	 0
  00135	8d 45 e8	 lea	 eax, DWORD PTR _secWhitening$[ebp]
  00138	50		 push	 eax
  00139	57		 push	 edi
  0013a	56		 push	 esi
  0013b	8d 45 d8	 lea	 eax, DWORD PTR _sectorIV$[ebp]
  0013e	e8 00 00 00 00	 call	 _EncryptBufferCBC@28

; 1454 : 
; 1455 : 				ks += CipherGetKeyScheduleSize (cipher);

  00143	53		 push	 ebx
  00144	e8 00 00 00 00	 call	 _CipherGet@4
  00149	03 78 10	 add	 edi, DWORD PTR [eax+16]
  0014c	53		 push	 ebx
  0014d	ff 75 f8	 push	 DWORD PTR _ea$[ebp]
  00150	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  00155	8b d8		 mov	 ebx, eax
$LN59@EncryptDat:

; 1442 : 		{
; 1443 : 			for (cipher = EAGetFirstCipher (ea); cipher != 0; cipher = EAGetNextCipher (ea, cipher))

  00157	85 db		 test	 ebx, ebx
  00159	75 b5		 jne	 SHORT $LL7@EncryptDat

; 1456 : 			}
; 1457 : 			ks -= EAGetKeyScheduleSize (ea);

  0015b	ff 75 f8	 push	 DWORD PTR _ea$[ebp]
  0015e	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4

; 1458 : 			buf += ENCRYPTION_DATA_UNIT_SIZE;

  00163	01 75 08	 add	 DWORD PTR _buf$[ebp], esi
  00166	2b f8		 sub	 edi, eax

; 1459 : 			unitNo++;

  00168	83 45 f0 01	 add	 DWORD PTR _unitNo$[ebp], 1
  0016c	8b 45 10	 mov	 eax, DWORD PTR _nbrUnits$[ebp]
  0016f	11 5d f4	 adc	 DWORD PTR _unitNo$[ebp+4], ebx
  00172	0b 45 14	 or	 eax, DWORD PTR _nbrUnits$[ebp+4]
  00175	75 8a		 jne	 SHORT $LL9@EncryptDat

; 1460 : 		}
; 1461 : 		break;

  00177	e9 e5 00 00 00	 jmp	 $LN17@EncryptDat
$LN16@EncryptDat:

; 1407 : 		}
; 1408 : 		break;
; 1409 : 
; 1410 : #ifndef TC_NO_COMPILER_INT64
; 1411 : 	case LRW:
; 1412 : 
; 1413 : 		/* Deprecated/legacy */
; 1414 : 
; 1415 : 		switch (CipherGetBlockSize (EAGetFirstCipher (ea)))

  0017c	6b db 2c	 imul	 ebx, 44			; 0000002cH
  0017f	ff b3 00 00 00
	00		 push	 DWORD PTR _EncryptionAlgorithms[ebx]
  00185	e8 00 00 00 00	 call	 _CipherGet@4
  0018a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0018d	83 f8 08	 cmp	 eax, 8
  00190	74 48		 je	 SHORT $LN13@EncryptDat
  00192	83 f8 10	 cmp	 eax, 16			; 00000010H
  00195	74 13		 je	 SHORT $LN12@EncryptDat

; 1430 : 
; 1431 : 		default:
; 1432 : 			TC_THROW_FATAL_EXCEPTION;

  00197	68 43 54 00 00	 push	 21571			; 00005443H
  0019c	6a 00		 push	 0
  0019e	6a 00		 push	 0
  001a0	68 98 05 00 00	 push	 1432			; 00000598H
  001a5	e9 bc fe ff ff	 jmp	 $LN60@EncryptDat
$LN12@EncryptDat:

; 1422 : 			break;
; 1423 : 
; 1424 : 		case 16:
; 1425 : 			EncryptBufferLRW128 (buf,
; 1426 : 				(unsigned __int64) nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1427 : 				DataUnit2LRWIndex (unitNo, 16, ci),
; 1428 : 				ci);

  001aa	52		 push	 edx
  001ab	52		 push	 edx
  001ac	6a 10		 push	 16			; 00000010H
  001ae	ff 75 f4	 push	 DWORD PTR _unitNo$[ebp+4]
  001b1	56		 push	 esi
  001b2	e8 00 00 00 00	 call	 _DataUnit2LRWIndex@16
  001b7	52		 push	 edx
  001b8	50		 push	 eax
  001b9	6a 00		 push	 0
  001bb	68 00 02 00 00	 push	 512			; 00000200H
  001c0	ff 75 14	 push	 DWORD PTR _nbrUnits$[ebp+4]
  001c3	ff 75 10	 push	 DWORD PTR _nbrUnits$[ebp]
  001c6	e8 00 00 00 00	 call	 __allmul
  001cb	52		 push	 edx
  001cc	50		 push	 eax
  001cd	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  001d0	e8 00 00 00 00	 call	 _EncryptBufferLRW128@24

; 1429 : 			break;

  001d5	e9 87 00 00 00	 jmp	 $LN17@EncryptDat
$LN13@EncryptDat:

; 1416 : 		{
; 1417 : 		case 8:
; 1418 : 			EncryptBufferLRW64 (buf,
; 1419 : 				(unsigned __int64) nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1420 : 				DataUnit2LRWIndex (unitNo, 8, ci),
; 1421 : 				ci);

  001da	52		 push	 edx
  001db	52		 push	 edx
  001dc	6a 08		 push	 8
  001de	ff 75 f4	 push	 DWORD PTR _unitNo$[ebp+4]
  001e1	56		 push	 esi
  001e2	e8 00 00 00 00	 call	 _DataUnit2LRWIndex@16
  001e7	52		 push	 edx
  001e8	50		 push	 eax
  001e9	6a 00		 push	 0
  001eb	68 00 02 00 00	 push	 512			; 00000200H
  001f0	ff 75 14	 push	 DWORD PTR _nbrUnits$[ebp+4]
  001f3	ff 75 10	 push	 DWORD PTR _nbrUnits$[ebp]
  001f6	e8 00 00 00 00	 call	 __allmul
  001fb	52		 push	 edx
  001fc	50		 push	 eax
  001fd	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  00200	e8 00 00 00 00	 call	 _EncryptBufferLRW64@24

; 1433 : 		}
; 1434 : 		break;

  00205	eb 5a		 jmp	 SHORT $LN17@EncryptDat
$LN20@EncryptDat:

; 1393 : 	{
; 1394 : 	case XTS:
; 1395 : 		for (cipher = EAGetFirstCipher (ea); cipher != 0; cipher = EAGetNextCipher (ea, cipher))

  00207	8b c3		 mov	 eax, ebx
  00209	6b c0 2c	 imul	 eax, 44			; 0000002cH
  0020c	8b b0 00 00 00
	00		 mov	 esi, DWORD PTR _EncryptionAlgorithms[eax]
  00212	85 f6		 test	 esi, esi
  00214	74 4b		 je	 SHORT $LN17@EncryptDat
  00216	6a 00		 push	 0
  00218	68 00 02 00 00	 push	 512			; 00000200H
  0021d	ff 75 14	 push	 DWORD PTR _nbrUnits$[ebp+4]
  00220	ff 75 10	 push	 DWORD PTR _nbrUnits$[ebp]
  00223	e8 00 00 00 00	 call	 __allmul
  00228	89 45 10	 mov	 DWORD PTR tv293[ebp], eax
  0022b	89 55 14	 mov	 DWORD PTR tv293[ebp+4], edx
$LL57@EncryptDat:

; 1396 : 		{
; 1397 : 			EncryptBufferXTS (buf,
; 1398 : 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1399 : 				structUnitNo,
; 1400 : 				0,
; 1401 : 				ks,
; 1402 : 				ks2,
; 1403 : 				cipher);

  0022e	56		 push	 esi
  0022f	ff 75 18	 push	 DWORD PTR _ks2$[ebp]
  00232	57		 push	 edi
  00233	6a 00		 push	 0
  00235	ff 75 0c	 push	 DWORD PTR _structUnitNo$[ebp]
  00238	ff 75 14	 push	 DWORD PTR tv293[ebp+4]
  0023b	ff 75 10	 push	 DWORD PTR tv293[ebp]
  0023e	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  00241	e8 00 00 00 00	 call	 _EncryptBufferXTS@32

; 1404 : 
; 1405 : 			ks += CipherGetKeyScheduleSize (cipher);

  00246	56		 push	 esi
  00247	e8 00 00 00 00	 call	 _CipherGet@4
  0024c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 1406 : 			ks2 += CipherGetKeyScheduleSize (cipher);

  0024f	01 45 18	 add	 DWORD PTR _ks2$[ebp], eax
  00252	56		 push	 esi
  00253	53		 push	 ebx
  00254	03 f8		 add	 edi, eax
  00256	e8 00 00 00 00	 call	 _EAGetNextCipher@8
  0025b	8b f0		 mov	 esi, eax
  0025d	85 f6		 test	 esi, esi
  0025f	75 cd		 jne	 SHORT $LL57@EncryptDat
$LN17@EncryptDat:
  00261	5f		 pop	 edi
  00262	5e		 pop	 esi
  00263	5b		 pop	 ebx

; 1488 : 	}
; 1489 : }

  00264	c9		 leave
  00265	c2 14 00	 ret	 20			; 00000014H
$LN58@EncryptDat:
_EncryptDataUnitsCurrentThread@20 ENDP
_TEXT	ENDS
PUBLIC	_DecryptBuffer@16
EXTRN	_DecryptBufferXTS@32:PROC
; Function compile flags: /Ogsp
;	COMDAT _DecryptBuffer@16
_TEXT	SEGMENT
_dataUnitNo$27792 = -8					; size = 8
_buf$ = 8						; size = 4
_len$ = 12						; size = 8
_ks2$27791 = 20						; size = 4
_cryptoInfo$ = 20					; size = 4
_DecryptBuffer@16 PROC					; COMDAT

; 1497 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	51		 push	 ecx
  00007	53		 push	 ebx
  00008	56		 push	 esi

; 1498 : 	switch (cryptoInfo->mode)

  00009	8b 75 14	 mov	 esi, DWORD PTR _cryptoInfo$[ebp]
  0000c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000f	48		 dec	 eax
  00010	57		 push	 edi
  00011	0f 84 f1 00 00
	00		 je	 $LN16@DecryptBuf@4
  00017	48		 dec	 eax
  00018	0f 84 90 00 00
	00		 je	 $LN12@DecryptBuf@4
  0001e	48		 dec	 eax
  0001f	74 41		 je	 SHORT $LN6@DecryptBuf@4
  00021	48		 dec	 eax
  00022	74 19		 je	 SHORT $LN2@DecryptBuf@4
  00024	48		 dec	 eax
  00025	74 3b		 je	 SHORT $LN6@DecryptBuf@4

; 1582 : #endif	// #ifndef TC_NO_COMPILER_INT64
; 1583 : 
; 1584 : 	default:		
; 1585 : 		// Unknown/wrong ID
; 1586 : 		TC_THROW_FATAL_EXCEPTION;

  00027	68 43 54 00 00	 push	 21571			; 00005443H
  0002c	6a 00		 push	 0
  0002e	6a 00		 push	 0
  00030	68 32 06 00 00	 push	 1586			; 00000632H
$LN42@DecryptBuf@4:
  00035	6a 29		 push	 41			; 00000029H
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN43@DecryptBuf@4:
$LN2@DecryptBuf@4:

; 1568 : 
; 1569 : 	case OUTER_CBC:
; 1570 : 
; 1571 : 		/* Deprecated/legacy */
; 1572 : 
; 1573 : 		DecryptBufferCBC ((unsigned __int32 *) buf,
; 1574 : 			(unsigned int) len,
; 1575 : 			cryptoInfo->ks,
; 1576 : 			(unsigned __int32 *) cryptoInfo->k2,
; 1577 : 			(unsigned __int32 *) &cryptoInfo->k2[8],
; 1578 : 			cryptoInfo->ea,
; 1579 : 			0);

  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00040	6a 00		 push	 0
  00042	ff 36		 push	 DWORD PTR [esi]
  00044	8d 86 b0 42 00
	00		 lea	 eax, DWORD PTR [esi+17072]
  0004a	50		 push	 eax
  0004b	8d 86 a8 42 00
	00		 lea	 eax, DWORD PTR [esi+17064]
  00051	83 c6 08	 add	 esi, 8
  00054	56		 push	 esi
  00055	ff 75 0c	 push	 DWORD PTR _len$[ebp]
  00058	e8 00 00 00 00	 call	 _DecryptBufferCBC@28

; 1580 : 
; 1581 : 		break;

  0005d	e9 07 01 00 00	 jmp	 $LN13@DecryptBuf@4
$LN6@DecryptBuf@4:

; 1544 : 
; 1545 : 	case CBC:
; 1546 : 	case INNER_CBC:
; 1547 : 		{
; 1548 : 			/* Deprecated/legacy */
; 1549 : 
; 1550 : 			unsigned __int8 *ks = cryptoInfo->ks + EAGetKeyScheduleSize (cryptoInfo->ea);

  00062	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00064	53		 push	 ebx
  00065	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4

; 1551 : 			int cipher;
; 1552 : 			for (cipher = EAGetLastCipher (cryptoInfo->ea);
; 1553 : 				cipher != 0;
; 1554 : 				cipher = EAGetPreviousCipher (cryptoInfo->ea, cipher))

  0006a	53		 push	 ebx
  0006b	8d 7c 30 08	 lea	 edi, DWORD PTR [eax+esi+8]
  0006f	e8 00 00 00 00	 call	 _EAGetLastCipher@4
  00074	eb 2d		 jmp	 SHORT $LN39@DecryptBuf@4
$LL35@DecryptBuf@4:

; 1555 : 			{
; 1556 : 				ks -= CipherGetKeyScheduleSize (cipher);

  00076	53		 push	 ebx
  00077	e8 00 00 00 00	 call	 _CipherGet@4
  0007c	2b 78 10	 sub	 edi, DWORD PTR [eax+16]

; 1557 : 
; 1558 : 				DecryptBufferCBC ((unsigned __int32 *) buf,
; 1559 : 					(unsigned int) len,
; 1560 : 					ks,
; 1561 : 					(unsigned __int32 *) cryptoInfo->k2,
; 1562 : 					(unsigned __int32 *) &cryptoInfo->k2[8],
; 1563 : 					0,
; 1564 : 					cipher);

  0007f	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00082	53		 push	 ebx
  00083	6a 00		 push	 0
  00085	8d 86 b0 42 00
	00		 lea	 eax, DWORD PTR [esi+17072]
  0008b	50		 push	 eax
  0008c	57		 push	 edi
  0008d	ff 75 0c	 push	 DWORD PTR _len$[ebp]
  00090	8d 86 a8 42 00
	00		 lea	 eax, DWORD PTR [esi+17064]
  00096	e8 00 00 00 00	 call	 _DecryptBufferCBC@28
  0009b	53		 push	 ebx
  0009c	ff 36		 push	 DWORD PTR [esi]
  0009e	e8 00 00 00 00	 call	 _EAGetPreviousCipher@8
$LN39@DecryptBuf@4:
  000a3	8b d8		 mov	 ebx, eax
  000a5	85 db		 test	 ebx, ebx
  000a7	75 cd		 jne	 SHORT $LL35@DecryptBuf@4

; 1565 : 			}
; 1566 : 		}
; 1567 : 		break;

  000a9	e9 bb 00 00 00	 jmp	 $LN13@DecryptBuf@4
$LN12@DecryptBuf@4:

; 1521 : 			}
; 1522 : 		}
; 1523 : 		break;
; 1524 : 
; 1525 : #ifndef TC_NO_COMPILER_INT64
; 1526 : 	case LRW:
; 1527 : 
; 1528 : 		/* Deprecated/legacy */
; 1529 : 
; 1530 : 		switch (CipherGetBlockSize (EAGetFirstCipher (cryptoInfo->ea)))

  000ae	8b 06		 mov	 eax, DWORD PTR [esi]
  000b0	6b c0 2c	 imul	 eax, 44			; 0000002cH
  000b3	ff b0 00 00 00
	00		 push	 DWORD PTR _EncryptionAlgorithms[eax]
  000b9	e8 00 00 00 00	 call	 _CipherGet@4
  000be	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c1	83 f8 08	 cmp	 eax, 8
  000c4	74 2d		 je	 SHORT $LN9@DecryptBuf@4
  000c6	83 f8 10	 cmp	 eax, 16			; 00000010H
  000c9	74 13		 je	 SHORT $LN8@DecryptBuf@4

; 1539 : 
; 1540 : 		default:
; 1541 : 			TC_THROW_FATAL_EXCEPTION;

  000cb	68 43 54 00 00	 push	 21571			; 00005443H
  000d0	6a 00		 push	 0
  000d2	6a 00		 push	 0
  000d4	68 05 06 00 00	 push	 1541			; 00000605H
  000d9	e9 57 ff ff ff	 jmp	 $LN42@DecryptBuf@4
$LN8@DecryptBuf@4:

; 1534 : 			break;
; 1535 : 
; 1536 : 		case 16:
; 1537 : 			DecryptBufferLRW128 (buf, (unsigned __int64) len, 1, cryptoInfo);

  000de	56		 push	 esi
  000df	6a 00		 push	 0
  000e1	6a 01		 push	 1
  000e3	ff 75 10	 push	 DWORD PTR _len$[ebp+4]
  000e6	ff 75 0c	 push	 DWORD PTR _len$[ebp]
  000e9	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  000ec	e8 00 00 00 00	 call	 _DecryptBufferLRW128@24

; 1538 : 			break;

  000f1	eb 76		 jmp	 SHORT $LN13@DecryptBuf@4
$LN9@DecryptBuf@4:

; 1531 : 		{
; 1532 : 		case 8:
; 1533 : 			DecryptBufferLRW64 (buf, (unsigned __int64) len, 1, cryptoInfo);

  000f3	56		 push	 esi
  000f4	6a 00		 push	 0
  000f6	6a 01		 push	 1
  000f8	ff 75 10	 push	 DWORD PTR _len$[ebp+4]
  000fb	ff 75 0c	 push	 DWORD PTR _len$[ebp]
  000fe	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  00101	e8 00 00 00 00	 call	 _DecryptBufferLRW64@24

; 1542 : 		}
; 1543 : 		break;

  00106	eb 61		 jmp	 SHORT $LN13@DecryptBuf@4
$LN16@DecryptBuf@4:

; 1499 : 	{
; 1500 : 	case XTS:
; 1501 : 		{
; 1502 : 			unsigned __int8 *ks = cryptoInfo->ks + EAGetKeyScheduleSize (cryptoInfo->ea);

  00108	8b 3e		 mov	 edi, DWORD PTR [esi]
  0010a	57		 push	 edi
  0010b	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4

; 1503 : 			unsigned __int8 *ks2 = cryptoInfo->ks2 + EAGetKeyScheduleSize (cryptoInfo->ea);

  00110	57		 push	 edi
  00111	8d 5c 30 08	 lea	 ebx, DWORD PTR [eax+esi+8]
  00115	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4

; 1504 : 			UINT64_STRUCT dataUnitNo;
; 1505 : 			int cipher;
; 1506 : 
; 1507 : 			// When encrypting/decrypting a buffer (typically a volume header) the sequential number
; 1508 : 			// of the first XTS data unit in the buffer is always 0 and the start of the buffer is
; 1509 : 			// always assumed to be aligned with the start of the data unit 0.
; 1510 : 			dataUnitNo.LowPart = 0;

  0011a	83 65 f8 00	 and	 DWORD PTR _dataUnitNo$27792[ebp], 0

; 1511 : 			dataUnitNo.HighPart = 0;

  0011e	83 65 fc 00	 and	 DWORD PTR _dataUnitNo$27792[ebp+4], 0
  00122	8d 84 30 d4 14
	00 00		 lea	 eax, DWORD PTR [eax+esi+5332]

; 1512 : 
; 1513 : 			for (cipher = EAGetLastCipher (cryptoInfo->ea);
; 1514 : 				cipher != 0;
; 1515 : 				cipher = EAGetPreviousCipher (cryptoInfo->ea, cipher))

  00129	57		 push	 edi
  0012a	89 45 14	 mov	 DWORD PTR _ks2$27791[ebp], eax
  0012d	e8 00 00 00 00	 call	 _EAGetLastCipher@4
  00132	eb 2f		 jmp	 SHORT $LN41@DecryptBuf@4
$LL36@DecryptBuf@4:

; 1516 : 			{
; 1517 : 				ks -= CipherGetKeyScheduleSize (cipher);

  00134	57		 push	 edi
  00135	e8 00 00 00 00	 call	 _CipherGet@4
  0013a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 1518 : 				ks2 -= CipherGetKeyScheduleSize (cipher);

  0013d	29 45 14	 sub	 DWORD PTR _ks2$27791[ebp], eax

; 1519 : 
; 1520 : 				DecryptBufferXTS (buf, len, &dataUnitNo, 0, ks, ks2, cipher);

  00140	57		 push	 edi
  00141	ff 75 14	 push	 DWORD PTR _ks2$27791[ebp]
  00144	2b d8		 sub	 ebx, eax
  00146	53		 push	 ebx
  00147	6a 00		 push	 0
  00149	8d 45 f8	 lea	 eax, DWORD PTR _dataUnitNo$27792[ebp]
  0014c	50		 push	 eax
  0014d	ff 75 10	 push	 DWORD PTR _len$[ebp+4]
  00150	ff 75 0c	 push	 DWORD PTR _len$[ebp]
  00153	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  00156	e8 00 00 00 00	 call	 _DecryptBufferXTS@32
  0015b	57		 push	 edi
  0015c	ff 36		 push	 DWORD PTR [esi]
  0015e	e8 00 00 00 00	 call	 _EAGetPreviousCipher@8
$LN41@DecryptBuf@4:
  00163	8b f8		 mov	 edi, eax
  00165	85 ff		 test	 edi, edi
  00167	75 cb		 jne	 SHORT $LL36@DecryptBuf@4
$LN13@DecryptBuf@4:
  00169	5f		 pop	 edi
  0016a	5e		 pop	 esi
  0016b	5b		 pop	 ebx

; 1587 : 	}
; 1588 : }

  0016c	c9		 leave
  0016d	c2 10 00	 ret	 16			; 00000010H
$LN37@DecryptBuf@4:
_DecryptBuffer@16 ENDP
_TEXT	ENDS
PUBLIC	_DecryptDataUnitsCurrentThread@20
; Function compile flags: /Ogsp
;	COMDAT _DecryptDataUnitsCurrentThread@20
_TEXT	SEGMENT
_sectorIV$ = -32					; size = 16
_secWhitening$ = -16					; size = 8
_unitNo$ = -8						; size = 8
_buf$ = 8						; size = 4
tv269 = 12						; size = 4
_cipher$ = 12						; size = 4
_structUnitNo$ = 12					; size = 4
tv294 = 16						; size = 8
_nbrUnits$ = 16						; size = 8
_iv64$ = 24						; size = 4
_ks2$ = 24						; size = 4
_ci$ = 24						; size = 4
_DecryptDataUnitsCurrentThread@20 PROC			; COMDAT

; 1601 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 20	 sub	 esp, 32			; 00000020H

; 1602 : 	int ea = ci->ea;

  00008	8b 55 18	 mov	 edx, DWORD PTR _ci$[ebp]

; 1603 : 	unsigned __int8 *ks = ci->ks;
; 1604 : 	unsigned __int8 *ks2 = ci->ks2;
; 1605 : 	int cipher;
; 1606 : 
; 1607 : #ifndef TC_NO_COMPILER_INT64
; 1608 : 	void *iv = ci->k2;									// Deprecated/legacy
; 1609 : 	unsigned __int64 unitNo = structUnitNo->Value;

  0000b	8b 45 0c	 mov	 eax, DWORD PTR _structUnitNo$[ebp]
  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00010	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00013	89 45 fc	 mov	 DWORD PTR _unitNo$[ebp+4], eax
  00016	53		 push	 ebx
  00017	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00019	8d 82 a8 42 00
	00		 lea	 eax, DWORD PTR [edx+17064]
  0001f	89 45 18	 mov	 DWORD PTR _iv64$[ebp], eax

; 1610 : 	unsigned __int64 *iv64 = (unsigned __int64 *) iv;	// Deprecated/legacy
; 1611 : 	unsigned __int32 sectorIV[4];						// Deprecated/legacy
; 1612 : 	unsigned __int32 secWhitening[2];					// Deprecated/legacy
; 1613 : #endif	// #ifndef TC_NO_COMPILER_INT64
; 1614 : 
; 1615 : 
; 1616 : 	switch (ci->mode)

  00022	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00025	48		 dec	 eax
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	8d 7a 08	 lea	 edi, DWORD PTR [edx+8]
  0002b	8d b2 d4 14 00
	00		 lea	 esi, DWORD PTR [edx+5332]
  00031	89 4d f8	 mov	 DWORD PTR _unitNo$[ebp], ecx
  00034	0f 84 c6 01 00
	00		 je	 $LN20@DecryptDat
  0003a	48		 dec	 eax
  0003b	0f 84 30 01 00
	00		 je	 $LN16@DecryptDat
  00041	48		 dec	 eax
  00042	0f 84 96 00 00
	00		 je	 $LN42@DecryptDat
  00048	48		 dec	 eax
  00049	74 1d		 je	 SHORT $LN41@DecryptDat
  0004b	48		 dec	 eax
  0004c	0f 84 8c 00 00
	00		 je	 $LN42@DecryptDat

; 1710 : #endif // #ifndef TC_NO_COMPILER_INT64
; 1711 : 
; 1712 : 	default:		
; 1713 : 		// Unknown/wrong ID
; 1714 : 		TC_THROW_FATAL_EXCEPTION;

  00052	68 43 54 00 00	 push	 21571			; 00005443H
  00057	6a 00		 push	 0
  00059	6a 00		 push	 0
  0005b	68 b2 06 00 00	 push	 1714			; 000006b2H
$LN57@DecryptDat:
  00060	6a 29		 push	 41			; 00000029H
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN58@DecryptDat:
$LN41@DecryptDat:

; 1689 : 
; 1690 : 	case OUTER_CBC:
; 1691 : 
; 1692 : 		/* Deprecated/legacy */
; 1693 : 
; 1694 : 		while (nbrUnits--)

  00068	8b 45 10	 mov	 eax, DWORD PTR _nbrUnits$[ebp]
  0006b	0b 45 14	 or	 eax, DWORD PTR _nbrUnits$[ebp+4]
  0006e	0f 84 f6 01 00
	00		 je	 $LN17@DecryptDat
  00074	8b c3		 mov	 eax, ebx
  00076	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00079	8d 80 00 00 00
	00		 lea	 eax, DWORD PTR _EncryptionAlgorithms[eax]
  0007f	89 45 0c	 mov	 DWORD PTR tv269[ebp], eax
  00082	be 00 02 00 00	 mov	 esi, 512		; 00000200H
$LL3@DecryptDat:
  00087	83 45 10 ff	 add	 DWORD PTR _nbrUnits$[ebp], -1

; 1695 : 		{
; 1696 : 			InitSectorIVAndWhitening (unitNo, CipherGetBlockSize (EAGetFirstCipher (ea)), sectorIV, iv64, secWhitening);

  0008b	8d 45 f0	 lea	 eax, DWORD PTR _secWhitening$[ebp]
  0008e	50		 push	 eax
  0008f	83 55 14 ff	 adc	 DWORD PTR _nbrUnits$[ebp+4], -1
  00093	8d 45 e0	 lea	 eax, DWORD PTR _sectorIV$[ebp]
  00096	50		 push	 eax
  00097	8b 45 0c	 mov	 eax, DWORD PTR tv269[ebp]
  0009a	ff 30		 push	 DWORD PTR [eax]
  0009c	e8 00 00 00 00	 call	 _CipherGet@4
  000a1	ff 70 08	 push	 DWORD PTR [eax+8]
  000a4	8b 45 18	 mov	 eax, DWORD PTR _iv64$[ebp]
  000a7	ff 75 fc	 push	 DWORD PTR _unitNo$[ebp+4]
  000aa	ff 75 f8	 push	 DWORD PTR _unitNo$[ebp]
  000ad	e8 00 00 00 00	 call	 _InitSectorIVAndWhitening@24

; 1697 : 
; 1698 : 			DecryptBufferCBC ((unsigned __int32 *) buf,
; 1699 : 				ENCRYPTION_DATA_UNIT_SIZE,
; 1700 : 				ks,
; 1701 : 				sectorIV,
; 1702 : 				secWhitening,
; 1703 : 				ea,
; 1704 : 				0);

  000b2	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  000b5	6a 00		 push	 0
  000b7	53		 push	 ebx
  000b8	8d 45 f0	 lea	 eax, DWORD PTR _secWhitening$[ebp]
  000bb	50		 push	 eax
  000bc	57		 push	 edi
  000bd	56		 push	 esi
  000be	8d 45 e0	 lea	 eax, DWORD PTR _sectorIV$[ebp]
  000c1	e8 00 00 00 00	 call	 _DecryptBufferCBC@28

; 1705 : 
; 1706 : 			buf += ENCRYPTION_DATA_UNIT_SIZE;

  000c6	01 75 08	 add	 DWORD PTR _buf$[ebp], esi

; 1707 : 			unitNo++;

  000c9	83 45 f8 01	 add	 DWORD PTR _unitNo$[ebp], 1
  000cd	8b 45 10	 mov	 eax, DWORD PTR _nbrUnits$[ebp]
  000d0	83 55 fc 00	 adc	 DWORD PTR _unitNo$[ebp+4], 0
  000d4	0b 45 14	 or	 eax, DWORD PTR _nbrUnits$[ebp+4]
  000d7	75 ae		 jne	 SHORT $LL3@DecryptDat

; 1708 : 		}
; 1709 : 		break;

  000d9	e9 8c 01 00 00	 jmp	 $LN17@DecryptDat
$LN42@DecryptDat:

; 1662 : 
; 1663 : 	case CBC:
; 1664 : 	case INNER_CBC:
; 1665 : 
; 1666 : 		/* Deprecated/legacy */
; 1667 : 
; 1668 : 		while (nbrUnits--)

  000de	8b 45 10	 mov	 eax, DWORD PTR _nbrUnits$[ebp]
  000e1	0b 45 14	 or	 eax, DWORD PTR _nbrUnits$[ebp+4]
  000e4	0f 84 80 01 00
	00		 je	 $LN17@DecryptDat
  000ea	be 00 02 00 00	 mov	 esi, 512		; 00000200H
$LL9@DecryptDat:
  000ef	83 45 10 ff	 add	 DWORD PTR _nbrUnits$[ebp], -1

; 1669 : 		{
; 1670 : 			ks += EAGetKeyScheduleSize (ea);

  000f3	53		 push	 ebx
  000f4	83 55 14 ff	 adc	 DWORD PTR _nbrUnits$[ebp+4], -1
  000f8	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4

; 1671 : 			for (cipher = EAGetLastCipher (ea); cipher != 0; cipher = EAGetPreviousCipher (ea, cipher))

  000fd	53		 push	 ebx
  000fe	03 f8		 add	 edi, eax
  00100	e8 00 00 00 00	 call	 _EAGetLastCipher@4
  00105	eb 4b		 jmp	 SHORT $LN56@DecryptDat
$LL53@DecryptDat:

; 1672 : 			{
; 1673 : 				InitSectorIVAndWhitening (unitNo, CipherGetBlockSize (cipher), sectorIV, iv64, secWhitening);

  00107	8d 45 f0	 lea	 eax, DWORD PTR _secWhitening$[ebp]
  0010a	50		 push	 eax
  0010b	8d 45 e0	 lea	 eax, DWORD PTR _sectorIV$[ebp]
  0010e	50		 push	 eax
  0010f	ff 75 0c	 push	 DWORD PTR _cipher$[ebp]
  00112	e8 00 00 00 00	 call	 _CipherGet@4
  00117	ff 70 08	 push	 DWORD PTR [eax+8]
  0011a	8b 45 18	 mov	 eax, DWORD PTR _iv64$[ebp]
  0011d	ff 75 fc	 push	 DWORD PTR _unitNo$[ebp+4]
  00120	ff 75 f8	 push	 DWORD PTR _unitNo$[ebp]
  00123	e8 00 00 00 00	 call	 _InitSectorIVAndWhitening@24

; 1674 : 
; 1675 : 				ks -= CipherGetKeyScheduleSize (cipher);

  00128	ff 75 0c	 push	 DWORD PTR _cipher$[ebp]
  0012b	e8 00 00 00 00	 call	 _CipherGet@4

; 1676 : 
; 1677 : 				DecryptBufferCBC ((unsigned __int32 *) buf,
; 1678 : 					ENCRYPTION_DATA_UNIT_SIZE,
; 1679 : 					ks,
; 1680 : 					sectorIV,
; 1681 : 					secWhitening,
; 1682 : 					0,
; 1683 : 					cipher);

  00130	ff 75 0c	 push	 DWORD PTR _cipher$[ebp]
  00133	2b 78 10	 sub	 edi, DWORD PTR [eax+16]
  00136	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00139	6a 00		 push	 0
  0013b	8d 45 f0	 lea	 eax, DWORD PTR _secWhitening$[ebp]
  0013e	50		 push	 eax
  0013f	57		 push	 edi
  00140	56		 push	 esi
  00141	8d 45 e0	 lea	 eax, DWORD PTR _sectorIV$[ebp]
  00144	e8 00 00 00 00	 call	 _DecryptBufferCBC@28
  00149	ff 75 0c	 push	 DWORD PTR _cipher$[ebp]
  0014c	53		 push	 ebx
  0014d	e8 00 00 00 00	 call	 _EAGetPreviousCipher@8
$LN56@DecryptDat:
  00152	89 45 0c	 mov	 DWORD PTR _cipher$[ebp], eax
  00155	85 c0		 test	 eax, eax
  00157	75 ae		 jne	 SHORT $LL53@DecryptDat

; 1684 : 			}
; 1685 : 			buf += ENCRYPTION_DATA_UNIT_SIZE;

  00159	01 75 08	 add	 DWORD PTR _buf$[ebp], esi

; 1686 : 			unitNo++;

  0015c	83 45 f8 01	 add	 DWORD PTR _unitNo$[ebp], 1
  00160	8b 45 10	 mov	 eax, DWORD PTR _nbrUnits$[ebp]
  00163	83 55 fc 00	 adc	 DWORD PTR _unitNo$[ebp+4], 0
  00167	0b 45 14	 or	 eax, DWORD PTR _nbrUnits$[ebp+4]
  0016a	75 83		 jne	 SHORT $LL9@DecryptDat

; 1687 : 		}
; 1688 : 		break;

  0016c	e9 f9 00 00 00	 jmp	 $LN17@DecryptDat
$LN16@DecryptDat:

; 1634 : 		}
; 1635 : 		break;
; 1636 : 
; 1637 : #ifndef TC_NO_COMPILER_INT64
; 1638 : 	case LRW:
; 1639 : 
; 1640 : 		/* Deprecated/legacy */
; 1641 : 
; 1642 : 		switch (CipherGetBlockSize (EAGetFirstCipher (ea)))

  00171	6b db 2c	 imul	 ebx, 44			; 0000002cH
  00174	ff b3 00 00 00
	00		 push	 DWORD PTR _EncryptionAlgorithms[ebx]
  0017a	e8 00 00 00 00	 call	 _CipherGet@4
  0017f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00182	83 f8 08	 cmp	 eax, 8
  00185	74 4a		 je	 SHORT $LN13@DecryptDat
  00187	83 f8 10	 cmp	 eax, 16			; 00000010H
  0018a	74 13		 je	 SHORT $LN12@DecryptDat

; 1657 : 
; 1658 : 		default:
; 1659 : 			TC_THROW_FATAL_EXCEPTION;

  0018c	68 43 54 00 00	 push	 21571			; 00005443H
  00191	6a 00		 push	 0
  00193	6a 00		 push	 0
  00195	68 7b 06 00 00	 push	 1659			; 0000067bH
  0019a	e9 c1 fe ff ff	 jmp	 $LN57@DecryptDat
$LN12@DecryptDat:

; 1649 : 			break;
; 1650 : 
; 1651 : 		case 16:
; 1652 : 			DecryptBufferLRW128 (buf,
; 1653 : 				(unsigned __int64) nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1654 : 				DataUnit2LRWIndex (unitNo, 16, ci),
; 1655 : 				ci);

  0019f	52		 push	 edx
  001a0	52		 push	 edx
  001a1	6a 10		 push	 16			; 00000010H
  001a3	ff 75 fc	 push	 DWORD PTR _unitNo$[ebp+4]
  001a6	ff 75 f8	 push	 DWORD PTR _unitNo$[ebp]
  001a9	e8 00 00 00 00	 call	 _DataUnit2LRWIndex@16
  001ae	52		 push	 edx
  001af	50		 push	 eax
  001b0	6a 00		 push	 0
  001b2	68 00 02 00 00	 push	 512			; 00000200H
  001b7	ff 75 14	 push	 DWORD PTR _nbrUnits$[ebp+4]
  001ba	ff 75 10	 push	 DWORD PTR _nbrUnits$[ebp]
  001bd	e8 00 00 00 00	 call	 __allmul
  001c2	52		 push	 edx
  001c3	50		 push	 eax
  001c4	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  001c7	e8 00 00 00 00	 call	 _DecryptBufferLRW128@24

; 1656 : 			break;

  001cc	e9 99 00 00 00	 jmp	 $LN17@DecryptDat
$LN13@DecryptDat:

; 1643 : 		{
; 1644 : 		case 8:
; 1645 : 			DecryptBufferLRW64 (buf,
; 1646 : 				(unsigned __int64) nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1647 : 				DataUnit2LRWIndex (unitNo, 8, ci),
; 1648 : 				ci);

  001d1	52		 push	 edx
  001d2	52		 push	 edx
  001d3	6a 08		 push	 8
  001d5	ff 75 fc	 push	 DWORD PTR _unitNo$[ebp+4]
  001d8	ff 75 f8	 push	 DWORD PTR _unitNo$[ebp]
  001db	e8 00 00 00 00	 call	 _DataUnit2LRWIndex@16
  001e0	52		 push	 edx
  001e1	50		 push	 eax
  001e2	6a 00		 push	 0
  001e4	68 00 02 00 00	 push	 512			; 00000200H
  001e9	ff 75 14	 push	 DWORD PTR _nbrUnits$[ebp+4]
  001ec	ff 75 10	 push	 DWORD PTR _nbrUnits$[ebp]
  001ef	e8 00 00 00 00	 call	 __allmul
  001f4	52		 push	 edx
  001f5	50		 push	 eax
  001f6	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  001f9	e8 00 00 00 00	 call	 _DecryptBufferLRW64@24

; 1660 : 		}
; 1661 : 		break;

  001fe	eb 6a		 jmp	 SHORT $LN17@DecryptDat
$LN20@DecryptDat:

; 1617 : 	{
; 1618 : 	case XTS:
; 1619 : 		ks += EAGetKeyScheduleSize (ea);

  00200	53		 push	 ebx
  00201	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4

; 1620 : 		ks2 += EAGetKeyScheduleSize (ea);

  00206	53		 push	 ebx
  00207	03 f8		 add	 edi, eax
  00209	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize@4
  0020e	03 f0		 add	 esi, eax

; 1621 : 
; 1622 : 		for (cipher = EAGetLastCipher (ea); cipher != 0; cipher = EAGetPreviousCipher (ea, cipher))

  00210	53		 push	 ebx
  00211	89 75 18	 mov	 DWORD PTR _ks2$[ebp], esi
  00214	e8 00 00 00 00	 call	 _EAGetLastCipher@4
  00219	8b f0		 mov	 esi, eax
  0021b	85 f6		 test	 esi, esi
  0021d	74 4b		 je	 SHORT $LN17@DecryptDat
  0021f	6a 00		 push	 0
  00221	68 00 02 00 00	 push	 512			; 00000200H
  00226	ff 75 14	 push	 DWORD PTR _nbrUnits$[ebp+4]
  00229	ff 75 10	 push	 DWORD PTR _nbrUnits$[ebp]
  0022c	e8 00 00 00 00	 call	 __allmul
  00231	89 45 10	 mov	 DWORD PTR tv294[ebp], eax
  00234	89 55 14	 mov	 DWORD PTR tv294[ebp+4], edx
$LL54@DecryptDat:

; 1623 : 		{
; 1624 : 			ks -= CipherGetKeyScheduleSize (cipher);

  00237	56		 push	 esi
  00238	e8 00 00 00 00	 call	 _CipherGet@4
  0023d	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 1625 : 			ks2 -= CipherGetKeyScheduleSize (cipher);

  00240	29 45 18	 sub	 DWORD PTR _ks2$[ebp], eax

; 1626 : 
; 1627 : 			DecryptBufferXTS (buf,
; 1628 : 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1629 : 				structUnitNo,
; 1630 : 				0,
; 1631 : 				ks,
; 1632 : 				ks2,
; 1633 : 				cipher);

  00243	56		 push	 esi
  00244	ff 75 18	 push	 DWORD PTR _ks2$[ebp]
  00247	2b f8		 sub	 edi, eax
  00249	57		 push	 edi
  0024a	6a 00		 push	 0
  0024c	ff 75 0c	 push	 DWORD PTR _structUnitNo$[ebp]
  0024f	ff 75 14	 push	 DWORD PTR tv294[ebp+4]
  00252	ff 75 10	 push	 DWORD PTR tv294[ebp]
  00255	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  00258	e8 00 00 00 00	 call	 _DecryptBufferXTS@32
  0025d	56		 push	 esi
  0025e	53		 push	 ebx
  0025f	e8 00 00 00 00	 call	 _EAGetPreviousCipher@8
  00264	8b f0		 mov	 esi, eax
  00266	85 f6		 test	 esi, esi
  00268	75 cd		 jne	 SHORT $LL54@DecryptDat
$LN17@DecryptDat:
  0026a	5f		 pop	 edi
  0026b	5e		 pop	 esi
  0026c	5b		 pop	 ebx

; 1715 : 	}
; 1716 : }

  0026d	c9		 leave
  0026e	c2 14 00	 ret	 20			; 00000014H
$LN55@DecryptDat:
_DecryptDataUnitsCurrentThread@20 ENDP
_TEXT	ENDS
PUBLIC	_GetMaxPkcs5OutSize@0
; Function compile flags: /Ogsp
;	COMDAT _GetMaxPkcs5OutSize@0
_TEXT	SEGMENT
_GetMaxPkcs5OutSize@0 PROC				; COMDAT

; 1721 : {

  00000	8b ff		 npad	 2
  00002	56		 push	 esi
  00003	57		 push	 edi

; 1722 : 	int size = 32;

  00004	6a 20		 push	 32			; 00000020H
  00006	5f		 pop	 edi

; 1723 : 
; 1724 : 	size = max (size, EAGetLargestKeyForMode (XTS) * 2);	// Sizes of primary + secondary keys

  00007	6a 01		 push	 1
  00009	8b f7		 mov	 esi, edi
  0000b	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode@4
  00010	03 c0		 add	 eax, eax
  00012	3b c7		 cmp	 eax, edi
  00014	7c 0b		 jl	 SHORT $LN4@GetMaxPkcs
  00016	6a 01		 push	 1
  00018	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode@4
  0001d	8b f0		 mov	 esi, eax
  0001f	03 f6		 add	 esi, esi
$LN4@GetMaxPkcs:

; 1725 : 
; 1726 : #ifndef TC_WINDOWS_BOOT
; 1727 : 	size = max (size, LEGACY_VOL_IV_SIZE + EAGetLargestKeyForMode (LRW));		// Deprecated/legacy

  00021	6a 02		 push	 2
  00023	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode@4
  00028	03 c7		 add	 eax, edi
  0002a	3b f0		 cmp	 esi, eax
  0002c	7f 0b		 jg	 SHORT $LN6@GetMaxPkcs
  0002e	6a 02		 push	 2
  00030	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode@4
  00035	8b f0		 mov	 esi, eax
  00037	03 f7		 add	 esi, edi
$LN6@GetMaxPkcs:

; 1728 : 	size = max (size, LEGACY_VOL_IV_SIZE + EAGetLargestKeyForMode (CBC));		// Deprecated/legacy

  00039	6a 03		 push	 3
  0003b	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode@4
  00040	03 c7		 add	 eax, edi
  00042	3b f0		 cmp	 esi, eax
  00044	7f 0b		 jg	 SHORT $LN8@GetMaxPkcs
  00046	6a 03		 push	 3
  00048	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode@4
  0004d	8b f0		 mov	 esi, eax
  0004f	03 f7		 add	 esi, edi
$LN8@GetMaxPkcs:

; 1729 : 	size = max (size, LEGACY_VOL_IV_SIZE + EAGetLargestKeyForMode (OUTER_CBC));	// Deprecated/legacy

  00051	6a 04		 push	 4
  00053	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode@4
  00058	03 c7		 add	 eax, edi
  0005a	3b f0		 cmp	 esi, eax
  0005c	7f 0b		 jg	 SHORT $LN10@GetMaxPkcs
  0005e	6a 04		 push	 4
  00060	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode@4
  00065	8b f0		 mov	 esi, eax
  00067	03 f7		 add	 esi, edi
$LN10@GetMaxPkcs:

; 1730 : 	size = max (size, LEGACY_VOL_IV_SIZE + EAGetLargestKeyForMode (INNER_CBC));	// Deprecated/legacy

  00069	6a 05		 push	 5
  0006b	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode@4
  00070	03 c7		 add	 eax, edi
  00072	3b f0		 cmp	 esi, eax
  00074	7f 0b		 jg	 SHORT $LN12@GetMaxPkcs
  00076	6a 05		 push	 5
  00078	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode@4
  0007d	8b f0		 mov	 esi, eax
  0007f	03 f7		 add	 esi, edi
$LN12@GetMaxPkcs:
  00081	5f		 pop	 edi

; 1731 : #endif
; 1732 : 
; 1733 : 	return size;

  00082	8b c6		 mov	 eax, esi
  00084	5e		 pop	 esi

; 1734 : }

  00085	c3		 ret	 0
_GetMaxPkcs5OutSize@0 ENDP
_TEXT	ENDS
END
