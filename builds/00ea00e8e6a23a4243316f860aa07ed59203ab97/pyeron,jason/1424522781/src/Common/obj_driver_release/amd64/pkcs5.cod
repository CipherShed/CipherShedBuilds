; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0N@PGAIHMNP@HMAC?9SHA?9512?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0L@GENPDEDH@HMAC?9SHA?91?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BA@EMJCKHIJ@HMAC?9RIPEMD?9160?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09ONJBBFFA@?$CIUnknown?$CJ?$AA@FNODOBFM@ DB '(Unknown)', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0P@NGLBIHKE@HMAC?9Whirlpool?$AA@FNODOBFM@ DB 'HMAC-Whirlpool', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BA@EMJCKHIJ@HMAC?9RIPEMD?9160?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BA@EMJCKHIJ@HMAC?9RIPEMD?9160?$AA@FNODOBFM@ DB 'HMAC-RIPEMD-160', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0L@GENPDEDH@HMAC?9SHA?91?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0L@GENPDEDH@HMAC?9SHA?91?$AA@FNODOBFM@ DB 'HMAC-SHA-1', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0N@PGAIHMNP@HMAC?9SHA?9512?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0N@PGAIHMNP@HMAC?9SHA?9512?$AA@FNODOBFM@ DB 'HMAC-SHA-512', 00H ;  ?? ::FNODOBFM::`string'
PUBLIC	get_pkcs5_iteration_count
;	COMDAT pdata
; File c:\home\public\desktop\projects\ciphershed.build\src\common\pkcs5.c
pdata	SEGMENT
$pdata$get_pkcs5_iteration_count DD imagerel $LN11
	DD	imagerel $LN11+88
	DD	imagerel $unwind$get_pkcs5_iteration_count
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_pkcs5_iteration_count DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT get_pkcs5_iteration_count
_TEXT	SEGMENT
pkcs5_prf_id$ = 64
bBoot$ = 72
get_pkcs5_iteration_count PROC				; COMDAT

; 620  : {

$LN11:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 621  : 	switch (pkcs5_prf_id)

  00004	83 e9 01	 sub	 ecx, 1
  00007	74 3c		 je	 SHORT $LN5@get_pkcs5_
  00009	83 e9 01	 sub	 ecx, 1
  0000c	74 30		 je	 SHORT $LN4@get_pkcs5_
  0000e	83 e9 01	 sub	 ecx, 1
  00011	74 2b		 je	 SHORT $LN4@get_pkcs5_
  00013	83 f9 01	 cmp	 ecx, 1
  00016	74 1f		 je	 SHORT $LN3@get_pkcs5_

; 633  : 
; 634  : 	case WHIRLPOOL:	
; 635  : 		return 1000;
; 636  : #endif
; 637  : 
; 638  : 	default:		
; 639  : 		TC_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID

  00018	45 33 c9	 xor	 r9d, r9d
  0001b	45 33 c0	 xor	 r8d, r8d
  0001e	ba 7f 02 00 00	 mov	 edx, 639		; 0000027fH
  00023	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00027	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00036	cc		 int	 3
$LN3@get_pkcs5_:

; 630  : 
; 631  : 	case SHA1:		// Deprecated/legacy		
; 632  : 		return 2000;			

  00037	b8 d0 07 00 00	 mov	 eax, 2000		; 000007d0H
  0003c	eb 15		 jmp	 SHORT $LN8@get_pkcs5_
$LN4@get_pkcs5_:

; 625  : 
; 626  : #ifndef TC_WINDOWS_BOOT
; 627  : 
; 628  : 	case SHA512:	
; 629  : 		return 1000;			

  0003e	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  00043	eb 0e		 jmp	 SHORT $LN8@get_pkcs5_
$LN5@get_pkcs5_:

; 622  : 	{
; 623  : 	case RIPEMD160:	
; 624  : 		return (bBoot ? 1000 : 2000);

  00045	f7 da		 neg	 edx
  00047	1b c0		 sbb	 eax, eax
  00049	25 18 fc ff ff	 and	 eax, -1000		; fffffffffffffc18H
  0004e	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
$LN8@get_pkcs5_:

; 640  : 	}
; 641  : 	return 0;
; 642  : }

  00053	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00057	c3		 ret	 0
$LN10@get_pkcs5_:
get_pkcs5_iteration_count ENDP
_TEXT	ENDS
PUBLIC	hmac_truncate
; Function compile flags: /Ogspy
;	COMDAT hmac_truncate
_TEXT	SEGMENT
d1$ = 8
d2$ = 16
len$ = 24
hmac_truncate PROC					; COMDAT

; 31   : 	int i;
; 32   : 	for (i = 0; i < len; i++)

  00000	4d 63 c8	 movsxd	 r9, r8d
  00003	45 85 c0	 test	 r8d, r8d
  00006	7e 11		 jle	 SHORT $LN1@hmac_trunc
  00008	48 2b ca	 sub	 rcx, rdx
$LL3@hmac_trunc:

; 33   : 		d2[i] = d1[i];

  0000b	8a 04 11	 mov	 al, BYTE PTR [rcx+rdx]
  0000e	88 02		 mov	 BYTE PTR [rdx], al
  00010	48 ff c2	 inc	 rdx
  00013	49 83 e9 01	 sub	 r9, 1
  00017	75 f2		 jne	 SHORT $LL3@hmac_trunc
$LN1@hmac_trunc:

; 34   : }

  00019	f3 c3		 fatret	 0
hmac_truncate ENDP
PUBLIC	__$ArrayPad$
PUBLIC	hmac_whirlpool
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$hmac_whirlpool DD imagerel $LN122
	DD	imagerel $LN122+892
	DD	imagerel $unwind$hmac_whirlpool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$hmac_whirlpool DD 0a2619H
	DD	0690114H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	0330H
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed.build\src\common\pkcs5.c
xdata	ENDS
;	COMDAT hmac_whirlpool
_TEXT	SEGMENT
ictx$ = 32
octx$ = 208
tctx$29144 = 384
buf$ = 560
key$ = 624
owhi$ = 688
iwhi$ = 752
__$ArrayPad$ = 816
k$ = 912
lk$ = 920
d$ = 928
ld$ = 936
out$ = 944
t$ = 952
hmac_whirlpool PROC					; COMDAT

; 465  : {

$LN122:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 81 ec 48 03
	00 00		 sub	 rsp, 840		; 00000348H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 30
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00026	4c 8b bc 24 b0
	03 00 00	 mov	 r15, QWORD PTR out$[rsp]

; 466  : 	WHIRLPOOL_CTX ictx, octx;
; 467  : 	char iwhi[WHIRLPOOL_DIGESTSIZE], owhi[WHIRLPOOL_DIGESTSIZE];
; 468  : 	char key[WHIRLPOOL_DIGESTSIZE];
; 469  : 	char buf[WHIRLPOOL_BLOCKSIZE];
; 470  : 	int i;
; 471  : 
; 472  :     /* If the key is longer than the hash algorithm block size,
; 473  : 	   let key = whirlpool(key), as per HMAC specifications. */
; 474  : 	if (lk > WHIRLPOOL_BLOCKSIZE)

  0002e	33 ff		 xor	 edi, edi
  00030	45 8b f1	 mov	 r14d, r9d
  00033	8d 5f 40	 lea	 ebx, QWORD PTR [rdi+64]
  00036	4d 8b e8	 mov	 r13, r8
  00039	44 8b e2	 mov	 r12d, edx
  0003c	3b d3		 cmp	 edx, ebx
  0003e	48 8b e9	 mov	 rbp, rcx
  00041	be a8 00 00 00	 mov	 esi, 168		; 000000a8H
  00046	0f 8e 9b 00 00
	00		 jle	 $LN45@hmac_whirl

; 475  : 	{
; 476  : 		WHIRLPOOL_CTX tctx;
; 477  : 
; 478  : 		WHIRLPOOL_init (&tctx);

  0004c	44 8d 47 20	 lea	 r8d, QWORD PTR [rdi+32]
  00050	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR tctx$29144[rsp]
  00058	33 d2		 xor	 edx, edx
  0005a	e8 00 00 00 00	 call	 memset
  0005f	48 8d 8c 24 e8
	01 00 00	 lea	 rcx, QWORD PTR tctx$29144[rsp+104]
  00067	4c 8b c3	 mov	 r8, rbx
  0006a	33 d2		 xor	 edx, edx
  0006c	89 bc 24 e4 01
	00 00		 mov	 DWORD PTR tctx$29144[rsp+100], edi
  00073	89 bc 24 e0 01
	00 00		 mov	 DWORD PTR tctx$29144[rsp+96], edi
  0007a	40 88 bc 24 a0
	01 00 00	 mov	 BYTE PTR tctx$29144[rsp+32], dil
  00082	e8 00 00 00 00	 call	 memset

; 479  : 		WHIRLPOOL_add ((unsigned char *) k, lk * 8, &tctx);

  00087	41 8b d4	 mov	 edx, r12d
  0008a	4c 8d 84 24 80
	01 00 00	 lea	 r8, QWORD PTR tctx$29144[rsp]
  00092	c1 e2 03	 shl	 edx, 3
  00095	48 8b cd	 mov	 rcx, rbp
  00098	e8 00 00 00 00	 call	 WHIRLPOOL_add

; 480  : 		WHIRLPOOL_finalize (&tctx, (unsigned char *) key);

  0009d	48 8d 94 24 70
	02 00 00	 lea	 rdx, QWORD PTR key$[rsp]
  000a5	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR tctx$29144[rsp]
  000ad	e8 00 00 00 00	 call	 WHIRLPOOL_finalize

; 481  : 
; 482  : 		k = key;
; 483  : 		lk = WHIRLPOOL_DIGESTSIZE;
; 484  : 
; 485  : 		burn (&tctx, sizeof(tctx));		// Prevent leaks

  000b2	33 c0		 xor	 eax, eax
  000b4	48 8d bc 24 80
	01 00 00	 lea	 rdi, QWORD PTR tctx$29144[rsp]
  000bc	48 8b ce	 mov	 rcx, rsi
  000bf	48 8d ac 24 70
	02 00 00	 lea	 rbp, QWORD PTR key$[rsp]
  000c7	44 8b e3	 mov	 r12d, ebx
  000ca	f3 aa		 rep stosb
  000cc	48 8d 94 24 80
	01 00 00	 lea	 rdx, QWORD PTR tctx$29144[rsp]
  000d4	44 8b c6	 mov	 r8d, esi
  000d7	33 ff		 xor	 edi, edi
$LL44@hmac_whirl:
  000d9	41 ff c8	 dec	 r8d
  000dc	40 88 3a	 mov	 BYTE PTR [rdx], dil
  000df	48 ff c2	 inc	 rdx
  000e2	44 3b c7	 cmp	 r8d, edi
  000e5	75 f2		 jne	 SHORT $LL44@hmac_whirl
$LN45@hmac_whirl:

; 486  : 	}
; 487  : 
; 488  : 	/**** Inner Digest ****/
; 489  : 
; 490  : 	WHIRLPOOL_init (&ictx);

  000e7	33 d2		 xor	 edx, edx
  000e9	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ictx$[rsp]
  000ee	44 8d 42 20	 lea	 r8d, QWORD PTR [rdx+32]
  000f2	e8 00 00 00 00	 call	 memset
  000f7	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR ictx$[rsp+104]
  000ff	4c 8b c3	 mov	 r8, rbx
  00102	33 d2		 xor	 edx, edx
  00104	89 bc 24 84 00
	00 00		 mov	 DWORD PTR ictx$[rsp+100], edi
  0010b	89 bc 24 80 00
	00 00		 mov	 DWORD PTR ictx$[rsp+96], edi
  00112	40 88 7c 24 40	 mov	 BYTE PTR ictx$[rsp+32], dil
  00117	e8 00 00 00 00	 call	 memset

; 491  : 
; 492  : 	/* Pad the key for inner digest */
; 493  : 	for (i = 0; i < lk; ++i)

  0011c	4c 8b df	 mov	 r11, rdi
  0011f	49 63 fc	 movsxd	 rdi, r12d
  00122	45 33 e4	 xor	 r12d, r12d
  00125	b2 36		 mov	 dl, 54			; 00000036H
  00127	49 3b fc	 cmp	 rdi, r12
  0012a	7e 26		 jle	 SHORT $LN40@hmac_whirl
  0012c	48 8d 84 24 30
	02 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  00134	4c 8b c5	 mov	 r8, rbp
  00137	4c 2b c0	 sub	 r8, rax
$LL42@hmac_whirl:

; 494  : 		buf[i] = (char) (k[i] ^ 0x36);

  0013a	4a 8d 8c 1c 30
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp+r11]
  00142	49 ff c3	 inc	 r11
  00145	41 8a 04 08	 mov	 al, BYTE PTR [r8+rcx]
  00149	32 c2		 xor	 al, dl
  0014b	4c 3b df	 cmp	 r11, rdi
  0014e	88 01		 mov	 BYTE PTR [rcx], al
  00150	7c e8		 jl	 SHORT $LL42@hmac_whirl
$LN40@hmac_whirl:

; 495  : 	for (i = lk; i < WHIRLPOOL_BLOCKSIZE; ++i)

  00152	48 3b fb	 cmp	 rdi, rbx
  00155	7d 13		 jge	 SHORT $LN39@hmac_whirl
  00157	4c 8b c3	 mov	 r8, rbx
  0015a	48 8d 8c 3c 30
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp+rdi]
  00162	4c 2b c7	 sub	 r8, rdi
  00165	e8 00 00 00 00	 call	 memset
$LN39@hmac_whirl:

; 496  : 		buf[i] = 0x36;
; 497  : 
; 498  : 	WHIRLPOOL_add ((unsigned char *) buf, WHIRLPOOL_BLOCKSIZE * 8, &ictx);

  0016a	4c 8d 44 24 20	 lea	 r8, QWORD PTR ictx$[rsp]
  0016f	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00177	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  0017c	e8 00 00 00 00	 call	 WHIRLPOOL_add

; 499  : 	WHIRLPOOL_add ((unsigned char *) d, ld * 8, &ictx);

  00181	41 8b d6	 mov	 edx, r14d
  00184	4c 8d 44 24 20	 lea	 r8, QWORD PTR ictx$[rsp]
  00189	c1 e2 03	 shl	 edx, 3
  0018c	49 8b cd	 mov	 rcx, r13
  0018f	e8 00 00 00 00	 call	 WHIRLPOOL_add

; 500  : 
; 501  : 	WHIRLPOOL_finalize (&ictx, (unsigned char *) iwhi);

  00194	48 8d 94 24 f0
	02 00 00	 lea	 rdx, QWORD PTR iwhi$[rsp]
  0019c	48 8d 4c 24 20	 lea	 rcx, QWORD PTR ictx$[rsp]
  001a1	e8 00 00 00 00	 call	 WHIRLPOOL_finalize

; 502  : 
; 503  : 	/**** Outer Digest ****/
; 504  : 
; 505  : 	WHIRLPOOL_init (&octx);

  001a6	33 d2		 xor	 edx, edx
  001a8	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR octx$[rsp]
  001b0	44 8d 42 20	 lea	 r8d, QWORD PTR [rdx+32]
  001b4	e8 00 00 00 00	 call	 memset
  001b9	48 8d 8c 24 38
	01 00 00	 lea	 rcx, QWORD PTR octx$[rsp+104]
  001c1	4c 8b c3	 mov	 r8, rbx
  001c4	33 d2		 xor	 edx, edx
  001c6	44 89 a4 24 34
	01 00 00	 mov	 DWORD PTR octx$[rsp+100], r12d
  001ce	44 89 a4 24 30
	01 00 00	 mov	 DWORD PTR octx$[rsp+96], r12d
  001d6	44 88 a4 24 f0
	00 00 00	 mov	 BYTE PTR octx$[rsp+32], r12b
  001de	e8 00 00 00 00	 call	 memset

; 506  : 
; 507  : 	for (i = 0; i < lk; ++i)

  001e3	49 3b fc	 cmp	 rdi, r12
  001e6	4d 8b dc	 mov	 r11, r12
  001e9	b2 5c		 mov	 dl, 92			; 0000005cH
  001eb	7e 22		 jle	 SHORT $LN34@hmac_whirl
  001ed	48 8d 84 24 30
	02 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  001f5	48 2b e8	 sub	 rbp, rax
$LL36@hmac_whirl:

; 508  : 		buf[i] = (char) (k[i] ^ 0x5C);

  001f8	4a 8d 8c 1c 30
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp+r11]
  00200	49 ff c3	 inc	 r11
  00203	8a 04 29	 mov	 al, BYTE PTR [rcx+rbp]
  00206	32 c2		 xor	 al, dl
  00208	4c 3b df	 cmp	 r11, rdi
  0020b	88 01		 mov	 BYTE PTR [rcx], al
  0020d	7c e9		 jl	 SHORT $LL36@hmac_whirl
$LN34@hmac_whirl:

; 509  : 	for (i = lk; i < WHIRLPOOL_BLOCKSIZE; ++i)

  0020f	48 3b fb	 cmp	 rdi, rbx
  00212	7d 13		 jge	 SHORT $LN33@hmac_whirl
  00214	4c 8b c3	 mov	 r8, rbx
  00217	48 8d 8c 3c 30
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp+rdi]
  0021f	4c 2b c7	 sub	 r8, rdi
  00222	e8 00 00 00 00	 call	 memset
$LN33@hmac_whirl:

; 510  : 		buf[i] = 0x5C;
; 511  : 
; 512  : 	WHIRLPOOL_add ((unsigned char *) buf, WHIRLPOOL_BLOCKSIZE * 8, &octx);

  00227	bf 00 02 00 00	 mov	 edi, 512		; 00000200H
  0022c	4c 8d 84 24 d0
	00 00 00	 lea	 r8, QWORD PTR octx$[rsp]
  00234	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0023c	8b d7		 mov	 edx, edi
  0023e	e8 00 00 00 00	 call	 WHIRLPOOL_add

; 513  : 	WHIRLPOOL_add ((unsigned char *) iwhi, WHIRLPOOL_DIGESTSIZE * 8, &octx);

  00243	4c 8d 84 24 d0
	00 00 00	 lea	 r8, QWORD PTR octx$[rsp]
  0024b	48 8d 8c 24 f0
	02 00 00	 lea	 rcx, QWORD PTR iwhi$[rsp]
  00253	8b d7		 mov	 edx, edi
  00255	e8 00 00 00 00	 call	 WHIRLPOOL_add

; 514  : 
; 515  : 	WHIRLPOOL_finalize (&octx, (unsigned char *) owhi);

  0025a	48 8d 94 24 b0
	02 00 00	 lea	 rdx, QWORD PTR owhi$[rsp]
  00262	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR octx$[rsp]
  0026a	e8 00 00 00 00	 call	 WHIRLPOOL_finalize

; 516  : 
; 517  : 	/* truncate and print the results */
; 518  : 	t = t > WHIRLPOOL_DIGESTSIZE ? WHIRLPOOL_DIGESTSIZE : t;
; 519  : 	hmac_truncate (owhi, out, t);

  0026f	48 8d 94 24 b0
	02 00 00	 lea	 rdx, QWORD PTR owhi$[rsp]
  00277	4c 8b c3	 mov	 r8, rbx
  0027a	49 8b cf	 mov	 rcx, r15
  0027d	e8 00 00 00 00	 call	 memcpy

; 520  : 
; 521  : 	/* Prevent possible leaks. */
; 522  : 	burn (&ictx, sizeof(ictx));

  00282	48 8d 7c 24 20	 lea	 rdi, QWORD PTR ictx$[rsp]
  00287	33 c0		 xor	 eax, eax
  00289	48 8b ce	 mov	 rcx, rsi
  0028c	4c 8d 5c 24 20	 lea	 r11, QWORD PTR ictx$[rsp]
  00291	8b d6		 mov	 edx, esi
  00293	f3 aa		 rep stosb
$LL27@hmac_whirl:
  00295	ff ca		 dec	 edx
  00297	45 88 23	 mov	 BYTE PTR [r11], r12b
  0029a	49 ff c3	 inc	 r11
  0029d	41 3b d4	 cmp	 edx, r12d
  002a0	75 f3		 jne	 SHORT $LL27@hmac_whirl

; 523  : 	burn (&octx, sizeof(octx));

  002a2	48 8d bc 24 d0
	00 00 00	 lea	 rdi, QWORD PTR octx$[rsp]
  002aa	48 8b ce	 mov	 rcx, rsi
  002ad	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR octx$[rsp]
  002b5	f3 aa		 rep stosb
$LL22@hmac_whirl:
  002b7	ff ce		 dec	 esi
  002b9	44 88 22	 mov	 BYTE PTR [rdx], r12b
  002bc	48 ff c2	 inc	 rdx
  002bf	41 3b f4	 cmp	 esi, r12d
  002c2	75 f3		 jne	 SHORT $LL22@hmac_whirl

; 524  : 	burn (owhi, sizeof(owhi));

  002c4	48 8d bc 24 b0
	02 00 00	 lea	 rdi, QWORD PTR owhi$[rsp]
  002cc	48 8b cb	 mov	 rcx, rbx
  002cf	48 8d 94 24 b0
	02 00 00	 lea	 rdx, QWORD PTR owhi$[rsp]
  002d7	f3 aa		 rep stosb
  002d9	44 8b c3	 mov	 r8d, ebx
$LL17@hmac_whirl:
  002dc	41 ff c8	 dec	 r8d
  002df	44 88 22	 mov	 BYTE PTR [rdx], r12b
  002e2	48 ff c2	 inc	 rdx
  002e5	45 3b c4	 cmp	 r8d, r12d
  002e8	75 f2		 jne	 SHORT $LL17@hmac_whirl

; 525  : 	burn (iwhi, sizeof(iwhi));

  002ea	48 8d bc 24 f0
	02 00 00	 lea	 rdi, QWORD PTR iwhi$[rsp]
  002f2	48 8b cb	 mov	 rcx, rbx
  002f5	48 8d 94 24 f0
	02 00 00	 lea	 rdx, QWORD PTR iwhi$[rsp]
  002fd	f3 aa		 rep stosb
  002ff	44 8b c3	 mov	 r8d, ebx
$LL12@hmac_whirl:
  00302	41 ff c8	 dec	 r8d
  00305	44 88 22	 mov	 BYTE PTR [rdx], r12b
  00308	48 ff c2	 inc	 rdx
  0030b	45 3b c4	 cmp	 r8d, r12d
  0030e	75 f2		 jne	 SHORT $LL12@hmac_whirl

; 526  : 	burn (buf, sizeof(buf));

  00310	48 8d bc 24 30
	02 00 00	 lea	 rdi, QWORD PTR buf$[rsp]
  00318	48 8b cb	 mov	 rcx, rbx
  0031b	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00323	f3 aa		 rep stosb
  00325	44 8b c3	 mov	 r8d, ebx
$LL7@hmac_whirl:
  00328	41 ff c8	 dec	 r8d
  0032b	44 88 22	 mov	 BYTE PTR [rdx], r12b
  0032e	48 ff c2	 inc	 rdx
  00331	45 3b c4	 cmp	 r8d, r12d
  00334	75 f2		 jne	 SHORT $LL7@hmac_whirl

; 527  : 	burn (key, sizeof(key));

  00336	48 8d bc 24 70
	02 00 00	 lea	 rdi, QWORD PTR key$[rsp]
  0033e	48 8b cb	 mov	 rcx, rbx
  00341	48 8d 94 24 70
	02 00 00	 lea	 rdx, QWORD PTR key$[rsp]
  00349	f3 aa		 rep stosb
$LL2@hmac_whirl:
  0034b	ff cb		 dec	 ebx
  0034d	44 88 22	 mov	 BYTE PTR [rdx], r12b
  00350	48 ff c2	 inc	 rdx
  00353	41 3b dc	 cmp	 ebx, r12d
  00356	75 f3		 jne	 SHORT $LL2@hmac_whirl

; 528  : }

  00358	48 8b 8c 24 30
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00360	48 33 cc	 xor	 rcx, rsp
  00363	e8 00 00 00 00	 call	 __security_check_cookie
  00368	48 81 c4 48 03
	00 00		 add	 rsp, 840		; 00000348H
  0036f	41 5f		 pop	 r15
  00371	41 5e		 pop	 r14
  00373	41 5d		 pop	 r13
  00375	41 5c		 pop	 r12
  00377	5f		 pop	 rdi
  00378	5e		 pop	 rsi
  00379	5d		 pop	 rbp
  0037a	5b		 pop	 rbx
  0037b	c3		 ret	 0
hmac_whirlpool ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	hmac_sha1
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$hmac_sha1 DD imagerel $LN107
	DD	imagerel $LN107+896
	DD	imagerel $unwind$hmac_sha1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$hmac_sha1 DD 0a2619H
	DD	03d0114H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	01d0H
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed.build\src\common\pkcs5.c
xdata	ENDS
;	COMDAT hmac_sha1
_TEXT	SEGMENT
ictx$ = 32
octx$ = 128
tctx$28807 = 224
key$ = 320
osha$ = 344
isha$ = 368
buf$ = 400
__$ArrayPad$ = 464
k$ = 560
lk$ = 568
d$ = 576
ld$ = 584
out$ = 592
t$ = 600
hmac_sha1 PROC						; COMDAT

; 189  : {

$LN107:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 81 ec e8 01
	00 00		 sub	 rsp, 488		; 000001e8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 d0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00026	4c 8b bc 24 50
	02 00 00	 mov	 r15, QWORD PTR out$[rsp]

; 190  : 	sha1_ctx ictx, octx;
; 191  : 	char isha[SHA1_DIGESTSIZE], osha[SHA1_DIGESTSIZE];
; 192  : 	char key[SHA1_DIGESTSIZE];
; 193  : 	char buf[SHA1_BLOCKSIZE];
; 194  : 	int i;
; 195  : 
; 196  :     /* If the key is longer than the hash algorithm block size,
; 197  : 	   let key = sha1(key), as per HMAC specifications. */
; 198  : 	if (lk > SHA1_BLOCKSIZE)

  0002e	33 c0		 xor	 eax, eax
  00030	45 8b f1	 mov	 r14d, r9d
  00033	8d 70 40	 lea	 esi, QWORD PTR [rax+64]
  00036	4d 8b e8	 mov	 r13, r8
  00039	44 8b ca	 mov	 r9d, edx
  0003c	3b d6		 cmp	 edx, esi
  0003e	4c 8b e1	 mov	 r12, rcx
  00041	8d 58 14	 lea	 ebx, QWORD PTR [rax+20]
  00044	8d 68 5c	 lea	 ebp, QWORD PTR [rax+92]
  00047	0f 8e 99 00 00
	00		 jle	 $LN45@hmac_sha1

; 199  : 	{
; 200  : 		sha1_ctx tctx;
; 201  : 
; 202  : 		sha1_begin (&tctx);
; 203  : 		sha1_hash ((unsigned char *) k, lk, &tctx);

  0004d	4c 8d 84 24 e0
	00 00 00	 lea	 r8, QWORD PTR tctx$28807[rsp]
  00055	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tctx$28807[rsp+4], eax
  0005c	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tctx$28807[rsp], eax
  00063	c7 84 24 e8 00
	00 00 01 23 45
	67		 mov	 DWORD PTR tctx$28807[rsp+8], 1732584193 ; 67452301H
  0006e	c7 84 24 ec 00
	00 00 89 ab cd
	ef		 mov	 DWORD PTR tctx$28807[rsp+12], -271733879 ; efcdab89H
  00079	c7 84 24 f0 00
	00 00 fe dc ba
	98		 mov	 DWORD PTR tctx$28807[rsp+16], -1732584194 ; 98badcfeH
  00084	c7 84 24 f4 00
	00 00 76 54 32
	10		 mov	 DWORD PTR tctx$28807[rsp+20], 271733878 ; 10325476H
  0008f	c7 84 24 f8 00
	00 00 f0 e1 d2
	c3		 mov	 DWORD PTR tctx$28807[rsp+24], -1009589776 ; c3d2e1f0H
  0009a	e8 00 00 00 00	 call	 sha1_hash

; 204  : 		sha1_end ((unsigned char *) key, &tctx);

  0009f	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR tctx$28807[rsp]
  000a7	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR key$[rsp]
  000af	e8 00 00 00 00	 call	 sha1_end

; 205  : 
; 206  : 		k = key;
; 207  : 		lk = SHA1_DIGESTSIZE;
; 208  : 
; 209  : 		burn (&tctx, sizeof(tctx));		// Prevent leaks

  000b4	48 8d bc 24 e0
	00 00 00	 lea	 rdi, QWORD PTR tctx$28807[rsp]
  000bc	33 c0		 xor	 eax, eax
  000be	48 8b cd	 mov	 rcx, rbp
  000c1	4c 8d a4 24 40
	01 00 00	 lea	 r12, QWORD PTR key$[rsp]
  000c9	44 8b cb	 mov	 r9d, ebx
  000cc	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR tctx$28807[rsp]
  000d4	44 8b c5	 mov	 r8d, ebp
  000d7	f3 aa		 rep stosb
$LL44@hmac_sha1:
  000d9	41 ff c8	 dec	 r8d
  000dc	88 02		 mov	 BYTE PTR [rdx], al
  000de	48 ff c2	 inc	 rdx
  000e1	44 3b c0	 cmp	 r8d, eax
  000e4	75 f3		 jne	 SHORT $LL44@hmac_sha1
$LN45@hmac_sha1:

; 210  : 	}
; 211  : 
; 212  : 	/**** Inner Digest ****/
; 213  : 
; 214  : 	sha1_begin (&ictx);
; 215  : 
; 216  : 	/* Pad the key for inner digest */
; 217  : 	for (i = 0; i < lk; ++i)

  000e6	49 63 f9	 movsxd	 rdi, r9d
  000e9	89 44 24 24	 mov	 DWORD PTR ictx$[rsp+4], eax
  000ed	89 44 24 20	 mov	 DWORD PTR ictx$[rsp], eax
  000f1	48 3b f8	 cmp	 rdi, rax
  000f4	c7 44 24 28 01
	23 45 67	 mov	 DWORD PTR ictx$[rsp+8], 1732584193 ; 67452301H
  000fc	c7 44 24 2c 89
	ab cd ef	 mov	 DWORD PTR ictx$[rsp+12], -271733879 ; efcdab89H
  00104	c7 44 24 30 fe
	dc ba 98	 mov	 DWORD PTR ictx$[rsp+16], -1732584194 ; 98badcfeH
  0010c	c7 44 24 34 76
	54 32 10	 mov	 DWORD PTR ictx$[rsp+20], 271733878 ; 10325476H
  00114	c7 44 24 38 f0
	e1 d2 c3	 mov	 DWORD PTR ictx$[rsp+24], -1009589776 ; c3d2e1f0H
  0011c	4c 8b c0	 mov	 r8, rax
  0011f	b2 36		 mov	 dl, 54			; 00000036H
  00121	7e 26		 jle	 SHORT $LN40@hmac_sha1
  00123	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  0012b	4d 8b cc	 mov	 r9, r12
  0012e	4c 2b c8	 sub	 r9, rax
$LL42@hmac_sha1:

; 218  : 		buf[i] = (char) (k[i] ^ 0x36);

  00131	4a 8d 8c 04 90
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp+r8]
  00139	49 ff c0	 inc	 r8
  0013c	41 8a 04 09	 mov	 al, BYTE PTR [r9+rcx]
  00140	32 c2		 xor	 al, dl
  00142	4c 3b c7	 cmp	 r8, rdi
  00145	88 01		 mov	 BYTE PTR [rcx], al
  00147	7c e8		 jl	 SHORT $LL42@hmac_sha1
$LN40@hmac_sha1:

; 219  : 	for (i = lk; i < SHA1_BLOCKSIZE; ++i)

  00149	48 3b fe	 cmp	 rdi, rsi
  0014c	7d 13		 jge	 SHORT $LN39@hmac_sha1
  0014e	4c 8b c6	 mov	 r8, rsi
  00151	48 8d 8c 3c 90
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp+rdi]
  00159	4c 2b c7	 sub	 r8, rdi
  0015c	e8 00 00 00 00	 call	 memset
$LN39@hmac_sha1:

; 220  : 		buf[i] = 0x36;
; 221  : 
; 222  : 	sha1_hash ((unsigned char *) buf, SHA1_BLOCKSIZE, &ictx);

  00161	4c 8d 44 24 20	 lea	 r8, QWORD PTR ictx$[rsp]
  00166	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0016e	8b d6		 mov	 edx, esi
  00170	e8 00 00 00 00	 call	 sha1_hash

; 223  : 	sha1_hash ((unsigned char *) d, ld, &ictx);

  00175	4c 8d 44 24 20	 lea	 r8, QWORD PTR ictx$[rsp]
  0017a	41 8b d6	 mov	 edx, r14d
  0017d	49 8b cd	 mov	 rcx, r13
  00180	e8 00 00 00 00	 call	 sha1_hash

; 224  : 
; 225  : 	sha1_end ((unsigned char *) isha, &ictx);

  00185	48 8d 54 24 20	 lea	 rdx, QWORD PTR ictx$[rsp]
  0018a	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR isha$[rsp]
  00192	e8 00 00 00 00	 call	 sha1_end

; 226  : 
; 227  : 	/**** Outer Digest ****/
; 228  : 
; 229  : 	sha1_begin (&octx);

  00197	45 33 ed	 xor	 r13d, r13d
  0019a	c7 84 24 88 00
	00 00 01 23 45
	67		 mov	 DWORD PTR octx$[rsp+8], 1732584193 ; 67452301H

; 230  : 
; 231  : 	for (i = 0; i < lk; ++i)

  001a5	49 3b fd	 cmp	 rdi, r13
  001a8	44 89 ac 24 84
	00 00 00	 mov	 DWORD PTR octx$[rsp+4], r13d
  001b0	44 89 ac 24 80
	00 00 00	 mov	 DWORD PTR octx$[rsp], r13d
  001b8	c7 84 24 8c 00
	00 00 89 ab cd
	ef		 mov	 DWORD PTR octx$[rsp+12], -271733879 ; efcdab89H
  001c3	c7 84 24 90 00
	00 00 fe dc ba
	98		 mov	 DWORD PTR octx$[rsp+16], -1732584194 ; 98badcfeH
  001ce	c7 84 24 94 00
	00 00 76 54 32
	10		 mov	 DWORD PTR octx$[rsp+20], 271733878 ; 10325476H
  001d9	c7 84 24 98 00
	00 00 f0 e1 d2
	c3		 mov	 DWORD PTR octx$[rsp+24], -1009589776 ; c3d2e1f0H
  001e4	49 8b d5	 mov	 rdx, r13
  001e7	7e 24		 jle	 SHORT $LN34@hmac_sha1
  001e9	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  001f1	4c 2b e0	 sub	 r12, rax
$LL36@hmac_sha1:

; 232  : 		buf[i] = (char) (k[i] ^ 0x5C);

  001f4	48 8d 8c 14 90
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp+rdx]
  001fc	48 ff c2	 inc	 rdx
  001ff	41 8a 04 0c	 mov	 al, BYTE PTR [r12+rcx]
  00203	40 32 c5	 xor	 al, bpl
  00206	48 3b d7	 cmp	 rdx, rdi
  00209	88 01		 mov	 BYTE PTR [rcx], al
  0020b	7c e7		 jl	 SHORT $LL36@hmac_sha1
$LN34@hmac_sha1:

; 233  : 	for (i = lk; i < SHA1_BLOCKSIZE; ++i)

  0020d	48 3b fe	 cmp	 rdi, rsi
  00210	7d 16		 jge	 SHORT $LN33@hmac_sha1
  00212	4c 8b c6	 mov	 r8, rsi
  00215	48 8d 8c 3c 90
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp+rdi]
  0021d	40 8a d5	 mov	 dl, bpl
  00220	4c 2b c7	 sub	 r8, rdi
  00223	e8 00 00 00 00	 call	 memset
$LN33@hmac_sha1:

; 234  : 		buf[i] = 0x5C;
; 235  : 
; 236  : 	sha1_hash ((unsigned char *) buf, SHA1_BLOCKSIZE, &octx);

  00228	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR octx$[rsp]
  00230	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00238	8b d6		 mov	 edx, esi
  0023a	e8 00 00 00 00	 call	 sha1_hash

; 237  : 	sha1_hash ((unsigned char *) isha, SHA1_DIGESTSIZE, &octx);

  0023f	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR octx$[rsp]
  00247	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR isha$[rsp]
  0024f	8b d3		 mov	 edx, ebx
  00251	e8 00 00 00 00	 call	 sha1_hash

; 238  : 
; 239  : 	sha1_end ((unsigned char *) osha, &octx);

  00256	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR octx$[rsp]
  0025e	48 8d 8c 24 58
	01 00 00	 lea	 rcx, QWORD PTR osha$[rsp]
  00266	e8 00 00 00 00	 call	 sha1_end

; 240  : 
; 241  : 	/* truncate and print the results */
; 242  : 	t = t > SHA1_DIGESTSIZE ? SHA1_DIGESTSIZE : t;
; 243  : 	hmac_truncate (osha, out, t);

  0026b	48 8d 94 24 58
	01 00 00	 lea	 rdx, QWORD PTR osha$[rsp]

; 244  : 
; 245  : 	/* Prevent leaks */
; 246  : 	burn (&ictx, sizeof(ictx));

  00273	48 8d 7c 24 20	 lea	 rdi, QWORD PTR ictx$[rsp]
  00278	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0027b	48 8b cd	 mov	 rcx, rbp
  0027e	44 8b c5	 mov	 r8d, ebp
  00281	49 89 07	 mov	 QWORD PTR [r15], rax
  00284	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00288	49 89 47 08	 mov	 QWORD PTR [r15+8], rax
  0028c	8b 42 10	 mov	 eax, DWORD PTR [rdx+16]
  0028f	48 8d 54 24 20	 lea	 rdx, QWORD PTR ictx$[rsp]
  00294	41 89 47 10	 mov	 DWORD PTR [r15+16], eax
  00298	33 c0		 xor	 eax, eax
  0029a	f3 aa		 rep stosb
$LL27@hmac_sha1:
  0029c	41 ff c8	 dec	 r8d
  0029f	44 88 2a	 mov	 BYTE PTR [rdx], r13b
  002a2	48 ff c2	 inc	 rdx
  002a5	45 3b c5	 cmp	 r8d, r13d
  002a8	75 f2		 jne	 SHORT $LL27@hmac_sha1

; 247  : 	burn (&octx, sizeof(octx));

  002aa	48 8d bc 24 80
	00 00 00	 lea	 rdi, QWORD PTR octx$[rsp]
  002b2	48 8b cd	 mov	 rcx, rbp
  002b5	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR octx$[rsp]
  002bd	f3 aa		 rep stosb
$LL22@hmac_sha1:
  002bf	ff cd		 dec	 ebp
  002c1	44 88 2a	 mov	 BYTE PTR [rdx], r13b
  002c4	48 ff c2	 inc	 rdx
  002c7	41 3b ed	 cmp	 ebp, r13d
  002ca	75 f3		 jne	 SHORT $LL22@hmac_sha1

; 248  : 	burn (isha, sizeof(isha));

  002cc	48 8d bc 24 70
	01 00 00	 lea	 rdi, QWORD PTR isha$[rsp]
  002d4	48 8b cb	 mov	 rcx, rbx
  002d7	48 8d 94 24 70
	01 00 00	 lea	 rdx, QWORD PTR isha$[rsp]
  002df	f3 aa		 rep stosb
  002e1	44 8b c3	 mov	 r8d, ebx
$LL17@hmac_sha1:
  002e4	41 ff c8	 dec	 r8d
  002e7	44 88 2a	 mov	 BYTE PTR [rdx], r13b
  002ea	48 ff c2	 inc	 rdx
  002ed	45 3b c5	 cmp	 r8d, r13d
  002f0	75 f2		 jne	 SHORT $LL17@hmac_sha1

; 249  : 	burn (osha, sizeof(osha));

  002f2	48 8d bc 24 58
	01 00 00	 lea	 rdi, QWORD PTR osha$[rsp]
  002fa	48 8b cb	 mov	 rcx, rbx
  002fd	48 8d 94 24 58
	01 00 00	 lea	 rdx, QWORD PTR osha$[rsp]
  00305	f3 aa		 rep stosb
  00307	44 8b c3	 mov	 r8d, ebx
$LL12@hmac_sha1:
  0030a	41 ff c8	 dec	 r8d
  0030d	44 88 2a	 mov	 BYTE PTR [rdx], r13b
  00310	48 ff c2	 inc	 rdx
  00313	45 3b c5	 cmp	 r8d, r13d
  00316	75 f2		 jne	 SHORT $LL12@hmac_sha1

; 250  : 	burn (buf, sizeof(buf));

  00318	48 8d bc 24 90
	01 00 00	 lea	 rdi, QWORD PTR buf$[rsp]
  00320	48 8b ce	 mov	 rcx, rsi
  00323	48 8d 94 24 90
	01 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  0032b	f3 aa		 rep stosb
$LL7@hmac_sha1:
  0032d	ff ce		 dec	 esi
  0032f	44 88 2a	 mov	 BYTE PTR [rdx], r13b
  00332	48 ff c2	 inc	 rdx
  00335	41 3b f5	 cmp	 esi, r13d
  00338	75 f3		 jne	 SHORT $LL7@hmac_sha1

; 251  : 	burn (key, sizeof(key));

  0033a	48 8d bc 24 40
	01 00 00	 lea	 rdi, QWORD PTR key$[rsp]
  00342	48 8b cb	 mov	 rcx, rbx
  00345	48 8d 94 24 40
	01 00 00	 lea	 rdx, QWORD PTR key$[rsp]
  0034d	f3 aa		 rep stosb
$LL2@hmac_sha1:
  0034f	ff cb		 dec	 ebx
  00351	44 88 2a	 mov	 BYTE PTR [rdx], r13b
  00354	48 ff c2	 inc	 rdx
  00357	41 3b dd	 cmp	 ebx, r13d
  0035a	75 f3		 jne	 SHORT $LL2@hmac_sha1

; 252  : }

  0035c	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00364	48 33 cc	 xor	 rcx, rsp
  00367	e8 00 00 00 00	 call	 __security_check_cookie
  0036c	48 81 c4 e8 01
	00 00		 add	 rsp, 488		; 000001e8H
  00373	41 5f		 pop	 r15
  00375	41 5e		 pop	 r14
  00377	41 5d		 pop	 r13
  00379	41 5c		 pop	 r12
  0037b	5f		 pop	 rdi
  0037c	5e		 pop	 rsi
  0037d	5d		 pop	 rbp
  0037e	5b		 pop	 rbx
  0037f	c3		 ret	 0
hmac_sha1 ENDP
PUBLIC	__$ArrayPad$
PUBLIC	derive_u_whirlpool
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$derive_u_whirlpool DD imagerel $LN33
	DD	imagerel $LN33+344
	DD	imagerel $unwind$derive_u_whirlpool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$derive_u_whirlpool DD 072019H
	DD	02a010eH
	DD	07005c007H
	DD	050036004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	0140H
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed.build\src\common\pkcs5.c
xdata	ENDS
;	COMDAT derive_u_whirlpool
_TEXT	SEGMENT
counter$ = 48
j$ = 64
k$ = 128
init$ = 192
__$ArrayPad$ = 320
pwd$ = 384
pwd_len$ = 392
salt$ = 400
salt_len$ = 408
iterations$ = 416
u$ = 424
b$ = 432
derive_u_whirlpool PROC					; COMDAT

; 531  : {

$LN33:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	48 81 ec 50 01
	00 00		 sub	 rsp, 336		; 00000150H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00020	48 8b b4 24 a8
	01 00 00	 mov	 rsi, QWORD PTR u$[rsp]

; 532  : 	char j[WHIRLPOOL_DIGESTSIZE], k[WHIRLPOOL_DIGESTSIZE];
; 533  : 	char init[128];
; 534  : 	char counter[4];
; 535  : 	int c, i;
; 536  : 
; 537  : 	/* iteration 1 */
; 538  : 	memset (counter, 0, 4);

  00028	33 c0		 xor	 eax, eax
  0002a	4d 8b d0	 mov	 r10, r8
  0002d	89 44 24 30	 mov	 DWORD PTR counter$[rsp], eax

; 539  : 	counter[3] = (char) b;

  00031	8a 84 24 b0 01
	00 00		 mov	 al, BYTE PTR b$[rsp]
  00038	49 63 d9	 movsxd	 rbx, r9d
  0003b	48 8b e9	 mov	 rbp, rcx
  0003e	44 8b e2	 mov	 r12d, edx

; 540  : 	memcpy (init, salt, salt_len);	/* salt */

  00041	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR init$[rsp]
  00049	4c 8b c3	 mov	 r8, rbx
  0004c	49 8b d2	 mov	 rdx, r10
  0004f	88 44 24 33	 mov	 BYTE PTR counter$[rsp+3], al
  00053	e8 00 00 00 00	 call	 memcpy

; 541  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */

  00058	8b 54 24 30	 mov	 edx, DWORD PTR counter$[rsp]

; 542  : 	hmac_whirlpool (pwd, pwd_len, init, salt_len + 4, j, WHIRLPOOL_DIGESTSIZE);

  0005c	44 8d 4b 04	 lea	 r9d, DWORD PTR [rbx+4]
  00060	89 94 1c c0 00
	00 00		 mov	 DWORD PTR init$[rsp+rbx], edx
  00067	48 8d 44 24 40	 lea	 rax, QWORD PTR j$[rsp]
  0006c	4c 8d 84 24 c0
	00 00 00	 lea	 r8, QWORD PTR init$[rsp]
  00074	bb 40 00 00 00	 mov	 ebx, 64			; 00000040H
  00079	41 8b d4	 mov	 edx, r12d
  0007c	48 8b cd	 mov	 rcx, rbp
  0007f	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  00083	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00088	e8 00 00 00 00	 call	 hmac_whirlpool

; 543  : 	memcpy (u, j, WHIRLPOOL_DIGESTSIZE);

  0008d	48 8d 54 24 40	 lea	 rdx, QWORD PTR j$[rsp]
  00092	48 8b ce	 mov	 rcx, rsi
  00095	4c 8b c3	 mov	 r8, rbx
  00098	e8 00 00 00 00	 call	 memcpy

; 544  : 
; 545  : 	/* remaining iterations */
; 546  : 	for (c = 1; c < iterations; c++)

  0009d	8b 84 24 a0 01
	00 00		 mov	 eax, DWORD PTR iterations$[rsp]
  000a4	83 f8 01	 cmp	 eax, 1
  000a7	7e 53		 jle	 SHORT $LN10@derive_u_w
  000a9	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR k$[rsp]
  000b1	8d 78 ff	 lea	 edi, DWORD PTR [rax-1]
  000b4	48 2b f1	 sub	 rsi, rcx
$LL16@derive_u_w:

; 547  : 	{
; 548  : 		hmac_whirlpool (pwd, pwd_len, j, WHIRLPOOL_DIGESTSIZE, k, WHIRLPOOL_DIGESTSIZE);

  000b7	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR k$[rsp]
  000bf	4c 8d 44 24 40	 lea	 r8, QWORD PTR j$[rsp]
  000c4	44 8b cb	 mov	 r9d, ebx
  000c7	41 8b d4	 mov	 edx, r12d
  000ca	48 8b cd	 mov	 rcx, rbp
  000cd	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  000d1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d6	e8 00 00 00 00	 call	 hmac_whirlpool

; 549  : 		for (i = 0; i < WHIRLPOOL_DIGESTSIZE; i++)

  000db	33 d2		 xor	 edx, edx
$LL13@derive_u_w:

; 550  : 		{
; 551  : 			u[i] ^= k[i];

  000dd	48 8d 8c 14 80
	00 00 00	 lea	 rcx, QWORD PTR k$[rsp+rdx]
  000e5	48 ff c2	 inc	 rdx
  000e8	8a 01		 mov	 al, BYTE PTR [rcx]
  000ea	30 04 0e	 xor	 BYTE PTR [rsi+rcx], al
  000ed	48 3b d3	 cmp	 rdx, rbx

; 552  : 			j[i] = k[i];

  000f0	88 44 14 3f	 mov	 BYTE PTR j$[rsp+rdx-1], al
  000f4	7c e7		 jl	 SHORT $LL13@derive_u_w

; 544  : 
; 545  : 	/* remaining iterations */
; 546  : 	for (c = 1; c < iterations; c++)

  000f6	48 83 ef 01	 sub	 rdi, 1
  000fa	75 bb		 jne	 SHORT $LL16@derive_u_w
$LN10@derive_u_w:

; 553  : 		}
; 554  : 	}
; 555  : 
; 556  : 	/* Prevent possible leaks. */
; 557  : 	burn (j, sizeof(j));

  000fc	48 8d 7c 24 40	 lea	 rdi, QWORD PTR j$[rsp]
  00101	33 c0		 xor	 eax, eax
  00103	48 8b cb	 mov	 rcx, rbx
  00106	48 8d 54 24 40	 lea	 rdx, QWORD PTR j$[rsp]
  0010b	44 8b c3	 mov	 r8d, ebx
  0010e	f3 aa		 rep stosb
$LL7@derive_u_w:
  00110	88 02		 mov	 BYTE PTR [rdx], al
  00112	48 ff c2	 inc	 rdx
  00115	41 83 e8 01	 sub	 r8d, 1
  00119	75 f5		 jne	 SHORT $LL7@derive_u_w

; 558  : 	burn (k, sizeof(k));

  0011b	48 8d bc 24 80
	00 00 00	 lea	 rdi, QWORD PTR k$[rsp]
  00123	48 8b cb	 mov	 rcx, rbx
  00126	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  0012e	f3 aa		 rep stosb
$LL2@derive_u_w:
  00130	88 02		 mov	 BYTE PTR [rdx], al
  00132	48 ff c2	 inc	 rdx
  00135	83 eb 01	 sub	 ebx, 1
  00138	75 f6		 jne	 SHORT $LL2@derive_u_w

; 559  : }

  0013a	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00142	48 33 cc	 xor	 rcx, rsp
  00145	e8 00 00 00 00	 call	 __security_check_cookie
  0014a	48 81 c4 50 01
	00 00		 add	 rsp, 336		; 00000150H
  00151	41 5c		 pop	 r12
  00153	5f		 pop	 rdi
  00154	5e		 pop	 rsi
  00155	5d		 pop	 rbp
  00156	5b		 pop	 rbx
  00157	c3		 ret	 0
derive_u_whirlpool ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	derive_u_sha1
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$derive_u_sha1 DD imagerel $LN33
	DD	imagerel $LN33+320
	DD	imagerel $unwind$derive_u_sha1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$derive_u_sha1 DD 072019H
	DD	020010eH
	DD	07005c007H
	DD	050036004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	0f0H
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed.build\src\common\pkcs5.c
xdata	ENDS
;	COMDAT derive_u_sha1
_TEXT	SEGMENT
counter$ = 48
j$ = 56
k$ = 80
init$ = 112
__$ArrayPad$ = 240
pwd$ = 304
pwd_len$ = 312
salt$ = 320
salt_len$ = 328
iterations$ = 336
u$ = 344
b$ = 352
derive_u_sha1 PROC					; COMDAT

; 257  : {

$LN33:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	48 81 ec 00 01
	00 00		 sub	 rsp, 256		; 00000100H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00020	48 8b b4 24 58
	01 00 00	 mov	 rsi, QWORD PTR u$[rsp]

; 258  : 	char j[SHA1_DIGESTSIZE], k[SHA1_DIGESTSIZE];
; 259  : 	char init[128];
; 260  : 	char counter[4];
; 261  : 	int c, i;
; 262  : 
; 263  : 	/* iteration 1 */
; 264  : 	memset (counter, 0, 4);

  00028	33 c0		 xor	 eax, eax
  0002a	4d 8b d0	 mov	 r10, r8
  0002d	89 44 24 30	 mov	 DWORD PTR counter$[rsp], eax

; 265  : 	counter[3] = (char) b;

  00031	8a 84 24 60 01
	00 00		 mov	 al, BYTE PTR b$[rsp]
  00038	49 63 d9	 movsxd	 rbx, r9d
  0003b	48 8b e9	 mov	 rbp, rcx
  0003e	44 8b e2	 mov	 r12d, edx

; 266  : 	memcpy (init, salt, salt_len);	/* salt */

  00041	48 8d 4c 24 70	 lea	 rcx, QWORD PTR init$[rsp]
  00046	4c 8b c3	 mov	 r8, rbx
  00049	49 8b d2	 mov	 rdx, r10
  0004c	88 44 24 33	 mov	 BYTE PTR counter$[rsp+3], al
  00050	e8 00 00 00 00	 call	 memcpy

; 267  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */

  00055	8b 54 24 30	 mov	 edx, DWORD PTR counter$[rsp]

; 268  : 	hmac_sha1 (pwd, pwd_len, init, salt_len + 4, j, SHA1_DIGESTSIZE);

  00059	44 8d 4b 04	 lea	 r9d, DWORD PTR [rbx+4]
  0005d	89 54 1c 70	 mov	 DWORD PTR init$[rsp+rbx], edx
  00061	48 8d 44 24 38	 lea	 rax, QWORD PTR j$[rsp]
  00066	4c 8d 44 24 70	 lea	 r8, QWORD PTR init$[rsp]
  0006b	bb 14 00 00 00	 mov	 ebx, 20
  00070	41 8b d4	 mov	 edx, r12d
  00073	48 8b cd	 mov	 rcx, rbp
  00076	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  0007a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007f	e8 00 00 00 00	 call	 hmac_sha1

; 269  : 	memcpy (u, j, SHA1_DIGESTSIZE);

  00084	48 8d 54 24 38	 lea	 rdx, QWORD PTR j$[rsp]
  00089	48 8b ce	 mov	 rcx, rsi
  0008c	4c 8b c3	 mov	 r8, rbx
  0008f	e8 00 00 00 00	 call	 memcpy

; 270  : 
; 271  : 	/* remaining iterations */
; 272  : 	for (c = 1; c < iterations; c++)

  00094	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR iterations$[rsp]
  0009b	83 f8 01	 cmp	 eax, 1
  0009e	7e 4a		 jle	 SHORT $LN10@derive_u_s
  000a0	48 8d 4c 24 50	 lea	 rcx, QWORD PTR k$[rsp]
  000a5	8d 78 ff	 lea	 edi, DWORD PTR [rax-1]
  000a8	48 2b f1	 sub	 rsi, rcx
$LL16@derive_u_s:

; 273  : 	{
; 274  : 		hmac_sha1 (pwd, pwd_len, j, SHA1_DIGESTSIZE, k, SHA1_DIGESTSIZE);

  000ab	48 8d 44 24 50	 lea	 rax, QWORD PTR k$[rsp]
  000b0	4c 8d 44 24 38	 lea	 r8, QWORD PTR j$[rsp]
  000b5	44 8b cb	 mov	 r9d, ebx
  000b8	41 8b d4	 mov	 edx, r12d
  000bb	48 8b cd	 mov	 rcx, rbp
  000be	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  000c2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c7	e8 00 00 00 00	 call	 hmac_sha1

; 275  : 		for (i = 0; i < SHA1_DIGESTSIZE; i++)

  000cc	33 d2		 xor	 edx, edx
$LL13@derive_u_s:

; 276  : 		{
; 277  : 			u[i] ^= k[i];

  000ce	48 8d 4c 14 50	 lea	 rcx, QWORD PTR k$[rsp+rdx]
  000d3	48 ff c2	 inc	 rdx
  000d6	8a 01		 mov	 al, BYTE PTR [rcx]
  000d8	30 04 0e	 xor	 BYTE PTR [rsi+rcx], al
  000db	48 3b d3	 cmp	 rdx, rbx

; 278  : 			j[i] = k[i];

  000de	88 44 14 37	 mov	 BYTE PTR j$[rsp+rdx-1], al
  000e2	7c ea		 jl	 SHORT $LL13@derive_u_s

; 270  : 
; 271  : 	/* remaining iterations */
; 272  : 	for (c = 1; c < iterations; c++)

  000e4	48 83 ef 01	 sub	 rdi, 1
  000e8	75 c1		 jne	 SHORT $LL16@derive_u_s
$LN10@derive_u_s:

; 279  : 		}
; 280  : 	}
; 281  : 
; 282  : 	/* Prevent possible leaks. */
; 283  : 	burn (j, sizeof(j));

  000ea	48 8d 7c 24 38	 lea	 rdi, QWORD PTR j$[rsp]
  000ef	33 c0		 xor	 eax, eax
  000f1	48 8b cb	 mov	 rcx, rbx
  000f4	48 8d 54 24 38	 lea	 rdx, QWORD PTR j$[rsp]
  000f9	44 8b c3	 mov	 r8d, ebx
  000fc	f3 aa		 rep stosb
$LL7@derive_u_s:
  000fe	88 02		 mov	 BYTE PTR [rdx], al
  00100	48 ff c2	 inc	 rdx
  00103	41 83 e8 01	 sub	 r8d, 1
  00107	75 f5		 jne	 SHORT $LL7@derive_u_s

; 284  : 	burn (k, sizeof(k));

  00109	48 8d 7c 24 50	 lea	 rdi, QWORD PTR k$[rsp]
  0010e	48 8b cb	 mov	 rcx, rbx
  00111	48 8d 54 24 50	 lea	 rdx, QWORD PTR k$[rsp]
  00116	f3 aa		 rep stosb
$LL2@derive_u_s:
  00118	88 02		 mov	 BYTE PTR [rdx], al
  0011a	48 ff c2	 inc	 rdx
  0011d	83 eb 01	 sub	 ebx, 1
  00120	75 f6		 jne	 SHORT $LL2@derive_u_s

; 285  : }

  00122	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0012a	48 33 cc	 xor	 rcx, rsp
  0012d	e8 00 00 00 00	 call	 __security_check_cookie
  00132	48 81 c4 00 01
	00 00		 add	 rsp, 256		; 00000100H
  00139	41 5c		 pop	 r12
  0013b	5f		 pop	 rdi
  0013c	5e		 pop	 rsi
  0013d	5d		 pop	 rbp
  0013e	5b		 pop	 rbx
  0013f	c3		 ret	 0
derive_u_sha1 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	hmac_sha512
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$hmac_sha512 DD imagerel $LN113
	DD	imagerel $LN113+829
	DD	imagerel $unwind$hmac_sha512
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$hmac_sha512 DD 0a2619H
	DD	07f0114H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	03e0H
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed.build\src\common\pkcs5.c
xdata	ENDS
;	COMDAT hmac_sha512
_TEXT	SEGMENT
out$GSCopy$1$ = 32
ictx$ = 48
octx$ = 256
tctx$28621 = 464
buf$ = 672
key$ = 800
osha$ = 864
isha$ = 928
__$ArrayPad$ = 992
k$ = 1088
lk$ = 1096
d$ = 1104
ld$ = 1112
out$ = 1120
t$ = 1128
hmac_sha512 PROC					; COMDAT

; 47   : {

$LN113:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 81 ec f8 03
	00 00		 sub	 rsp, 1016		; 000003f8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 e0
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00026	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR out$[rsp]

; 48   : 	sha512_ctx ictx, octx;
; 49   : 	char isha[SHA512_DIGESTSIZE], osha[SHA512_DIGESTSIZE];
; 50   : 	char key[SHA512_DIGESTSIZE];
; 51   : 	char buf[SHA512_BLOCKSIZE];
; 52   : 	int i;
; 53   : 
; 54   :     /* If the key is longer than the hash algorithm block size,
; 55   : 	   let key = sha512(key), as per HMAC specifications. */
; 56   : 	if (lk > SHA512_BLOCKSIZE)

  0002e	33 ff		 xor	 edi, edi
  00030	45 8b f9	 mov	 r15d, r9d
  00033	8d 5f 40	 lea	 ebx, QWORD PTR [rdi+64]
  00036	4d 8b f0	 mov	 r14, r8
  00039	44 8b ea	 mov	 r13d, edx
  0003c	8d 73 40	 lea	 esi, QWORD PTR [rbx+64]
  0003f	4c 8b e1	 mov	 r12, rcx
  00042	48 89 44 24 20	 mov	 QWORD PTR out$GSCopy$1$[rsp], rax
  00047	3b d6		 cmp	 edx, esi
  00049	bd d0 00 00 00	 mov	 ebp, 208		; 000000d0H
  0004e	0f 8e 87 00 00
	00		 jle	 $LN45@hmac_sha51

; 57   : 	{
; 58   : 		sha512_ctx tctx;
; 59   : 
; 60   : 		sha512_begin (&tctx);

  00054	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR tctx$28621[rsp+16]
  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:i512
  00063	4c 8b c3	 mov	 r8, rbx
  00066	48 89 bc 24 d8
	01 00 00	 mov	 QWORD PTR tctx$28621[rsp+8], rdi
  0006e	48 89 bc 24 d0
	01 00 00	 mov	 QWORD PTR tctx$28621[rsp], rdi
  00076	e8 00 00 00 00	 call	 memcpy

; 61   : 		sha512_hash ((unsigned char *) k, lk, &tctx);

  0007b	4c 8d 84 24 d0
	01 00 00	 lea	 r8, QWORD PTR tctx$28621[rsp]
  00083	41 8b d5	 mov	 edx, r13d
  00086	49 8b cc	 mov	 rcx, r12
  00089	e8 00 00 00 00	 call	 sha512_hash

; 62   : 		sha512_end ((unsigned char *) key, &tctx);

  0008e	48 8d 94 24 d0
	01 00 00	 lea	 rdx, QWORD PTR tctx$28621[rsp]
  00096	48 8d 8c 24 20
	03 00 00	 lea	 rcx, QWORD PTR key$[rsp]
  0009e	44 8b c3	 mov	 r8d, ebx
  000a1	e8 00 00 00 00	 call	 sha_end2

; 63   : 
; 64   : 		k = key;
; 65   : 		lk = SHA512_DIGESTSIZE;
; 66   : 
; 67   : 		burn (&tctx, sizeof(tctx));		// Prevent leaks

  000a6	33 c0		 xor	 eax, eax
  000a8	48 8d bc 24 d0
	01 00 00	 lea	 rdi, QWORD PTR tctx$28621[rsp]
  000b0	48 8b cd	 mov	 rcx, rbp
  000b3	4c 8d a4 24 20
	03 00 00	 lea	 r12, QWORD PTR key$[rsp]
  000bb	44 8b eb	 mov	 r13d, ebx
  000be	f3 aa		 rep stosb
  000c0	48 8d 94 24 d0
	01 00 00	 lea	 rdx, QWORD PTR tctx$28621[rsp]
  000c8	44 8b c5	 mov	 r8d, ebp
  000cb	33 ff		 xor	 edi, edi
$LL44@hmac_sha51:
  000cd	41 ff c8	 dec	 r8d
  000d0	40 88 3a	 mov	 BYTE PTR [rdx], dil
  000d3	48 ff c2	 inc	 rdx
  000d6	44 3b c7	 cmp	 r8d, edi
  000d9	75 f2		 jne	 SHORT $LL44@hmac_sha51
$LN45@hmac_sha51:

; 68   : 	}
; 69   : 
; 70   : 	/**** Inner Digest ****/
; 71   : 
; 72   : 	sha512_begin (&ictx);

  000db	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ictx$[rsp+16]
  000e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:i512
  000e7	4c 8b c3	 mov	 r8, rbx
  000ea	48 89 7c 24 38	 mov	 QWORD PTR ictx$[rsp+8], rdi
  000ef	48 89 7c 24 30	 mov	 QWORD PTR ictx$[rsp], rdi
  000f4	e8 00 00 00 00	 call	 memcpy

; 73   : 
; 74   : 	/* Pad the key for inner digest */
; 75   : 	for (i = 0; i < lk; ++i)

  000f9	4c 8b df	 mov	 r11, rdi
  000fc	49 63 fd	 movsxd	 rdi, r13d
  000ff	45 33 ed	 xor	 r13d, r13d
  00102	49 3b fd	 cmp	 rdi, r13
  00105	b2 36		 mov	 dl, 54			; 00000036H
  00107	7e 26		 jle	 SHORT $LN40@hmac_sha51
  00109	48 8d 84 24 a0
	02 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  00111	4d 8b c4	 mov	 r8, r12
  00114	4c 2b c0	 sub	 r8, rax
$LL42@hmac_sha51:

; 76   : 		buf[i] = (char) (k[i] ^ 0x36);

  00117	4a 8d 8c 1c a0
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp+r11]
  0011f	49 ff c3	 inc	 r11
  00122	41 8a 04 08	 mov	 al, BYTE PTR [r8+rcx]
  00126	32 c2		 xor	 al, dl
  00128	4c 3b df	 cmp	 r11, rdi
  0012b	88 01		 mov	 BYTE PTR [rcx], al
  0012d	7c e8		 jl	 SHORT $LL42@hmac_sha51
$LN40@hmac_sha51:

; 77   : 	for (i = lk; i < SHA512_BLOCKSIZE; ++i)

  0012f	48 3b fe	 cmp	 rdi, rsi
  00132	7d 13		 jge	 SHORT $LN39@hmac_sha51
  00134	4c 8b c6	 mov	 r8, rsi
  00137	48 8d 8c 3c a0
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp+rdi]
  0013f	4c 2b c7	 sub	 r8, rdi
  00142	e8 00 00 00 00	 call	 memset
$LN39@hmac_sha51:

; 78   : 		buf[i] = 0x36;
; 79   : 
; 80   : 	sha512_hash ((unsigned char *) buf, SHA512_BLOCKSIZE, &ictx);

  00147	4c 8d 44 24 30	 lea	 r8, QWORD PTR ictx$[rsp]
  0014c	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00154	8b d6		 mov	 edx, esi
  00156	e8 00 00 00 00	 call	 sha512_hash

; 81   : 	sha512_hash ((unsigned char *) d, ld, &ictx);

  0015b	4c 8d 44 24 30	 lea	 r8, QWORD PTR ictx$[rsp]
  00160	41 8b d7	 mov	 edx, r15d
  00163	49 8b ce	 mov	 rcx, r14
  00166	e8 00 00 00 00	 call	 sha512_hash

; 82   : 
; 83   : 	sha512_end ((unsigned char *) isha, &ictx);

  0016b	48 8d 54 24 30	 lea	 rdx, QWORD PTR ictx$[rsp]
  00170	48 8d 8c 24 a0
	03 00 00	 lea	 rcx, QWORD PTR isha$[rsp]
  00178	44 8b c3	 mov	 r8d, ebx
  0017b	e8 00 00 00 00	 call	 sha_end2

; 84   : 
; 85   : 	/**** Outer Digest ****/
; 86   : 
; 87   : 	sha512_begin (&octx);

  00180	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR octx$[rsp+16]
  00188	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:i512
  0018f	4c 8b c3	 mov	 r8, rbx
  00192	4c 89 ac 24 08
	01 00 00	 mov	 QWORD PTR octx$[rsp+8], r13
  0019a	4c 89 ac 24 00
	01 00 00	 mov	 QWORD PTR octx$[rsp], r13
  001a2	e8 00 00 00 00	 call	 memcpy

; 88   : 
; 89   : 	for (i = 0; i < lk; ++i)

  001a7	49 3b fd	 cmp	 rdi, r13
  001aa	4d 8b dd	 mov	 r11, r13
  001ad	b2 5c		 mov	 dl, 92			; 0000005cH
  001af	7e 23		 jle	 SHORT $LN34@hmac_sha51
  001b1	48 8d 84 24 a0
	02 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  001b9	4c 2b e0	 sub	 r12, rax
$LL36@hmac_sha51:

; 90   : 		buf[i] = (char) (k[i] ^ 0x5C);

  001bc	4a 8d 8c 1c a0
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp+r11]
  001c4	49 ff c3	 inc	 r11
  001c7	41 8a 04 0c	 mov	 al, BYTE PTR [r12+rcx]
  001cb	32 c2		 xor	 al, dl
  001cd	4c 3b df	 cmp	 r11, rdi
  001d0	88 01		 mov	 BYTE PTR [rcx], al
  001d2	7c e8		 jl	 SHORT $LL36@hmac_sha51
$LN34@hmac_sha51:

; 91   : 	for (i = lk; i < SHA512_BLOCKSIZE; ++i)

  001d4	48 3b fe	 cmp	 rdi, rsi
  001d7	7d 13		 jge	 SHORT $LN33@hmac_sha51
  001d9	4c 8b c6	 mov	 r8, rsi
  001dc	48 8d 8c 3c a0
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp+rdi]
  001e4	4c 2b c7	 sub	 r8, rdi
  001e7	e8 00 00 00 00	 call	 memset
$LN33@hmac_sha51:

; 92   : 		buf[i] = 0x5C;
; 93   : 
; 94   : 	sha512_hash ((unsigned char *) buf, SHA512_BLOCKSIZE, &octx);

  001ec	4c 8d 84 24 00
	01 00 00	 lea	 r8, QWORD PTR octx$[rsp]
  001f4	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  001fc	8b d6		 mov	 edx, esi
  001fe	e8 00 00 00 00	 call	 sha512_hash

; 95   : 	sha512_hash ((unsigned char *) isha, SHA512_DIGESTSIZE, &octx);

  00203	4c 8d 84 24 00
	01 00 00	 lea	 r8, QWORD PTR octx$[rsp]
  0020b	48 8d 8c 24 a0
	03 00 00	 lea	 rcx, QWORD PTR isha$[rsp]
  00213	8b d3		 mov	 edx, ebx
  00215	e8 00 00 00 00	 call	 sha512_hash

; 96   : 
; 97   : 	sha512_end ((unsigned char *) osha, &octx);

  0021a	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR octx$[rsp]
  00222	48 8d 8c 24 60
	03 00 00	 lea	 rcx, QWORD PTR osha$[rsp]
  0022a	44 8b c3	 mov	 r8d, ebx
  0022d	e8 00 00 00 00	 call	 sha_end2

; 98   : 
; 99   : 	/* truncate and print the results */
; 100  : 	t = t > SHA512_DIGESTSIZE ? SHA512_DIGESTSIZE : t;
; 101  : 	hmac_truncate (osha, out, t);

  00232	48 8b 4c 24 20	 mov	 rcx, QWORD PTR out$GSCopy$1$[rsp]
  00237	48 8d 94 24 60
	03 00 00	 lea	 rdx, QWORD PTR osha$[rsp]
  0023f	4c 8b c3	 mov	 r8, rbx
  00242	e8 00 00 00 00	 call	 memcpy

; 102  : 
; 103  : 	/* Prevent leaks */
; 104  : 	burn (&ictx, sizeof(ictx));

  00247	48 8d 7c 24 30	 lea	 rdi, QWORD PTR ictx$[rsp]
  0024c	33 c0		 xor	 eax, eax
  0024e	48 8b cd	 mov	 rcx, rbp
  00251	4c 8d 5c 24 30	 lea	 r11, QWORD PTR ictx$[rsp]
  00256	8b d5		 mov	 edx, ebp
  00258	f3 aa		 rep stosb
$LL27@hmac_sha51:
  0025a	ff ca		 dec	 edx
  0025c	45 88 2b	 mov	 BYTE PTR [r11], r13b
  0025f	49 ff c3	 inc	 r11
  00262	41 3b d5	 cmp	 edx, r13d
  00265	75 f3		 jne	 SHORT $LL27@hmac_sha51

; 105  : 	burn (&octx, sizeof(octx));

  00267	48 8d bc 24 00
	01 00 00	 lea	 rdi, QWORD PTR octx$[rsp]
  0026f	48 8b cd	 mov	 rcx, rbp
  00272	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR octx$[rsp]
  0027a	f3 aa		 rep stosb
$LL22@hmac_sha51:
  0027c	ff cd		 dec	 ebp
  0027e	44 88 2a	 mov	 BYTE PTR [rdx], r13b
  00281	48 ff c2	 inc	 rdx
  00284	41 3b ed	 cmp	 ebp, r13d
  00287	75 f3		 jne	 SHORT $LL22@hmac_sha51

; 106  : 	burn (isha, sizeof(isha));

  00289	48 8d bc 24 a0
	03 00 00	 lea	 rdi, QWORD PTR isha$[rsp]
  00291	48 8b cb	 mov	 rcx, rbx
  00294	48 8d 94 24 a0
	03 00 00	 lea	 rdx, QWORD PTR isha$[rsp]
  0029c	f3 aa		 rep stosb
  0029e	44 8b c3	 mov	 r8d, ebx
$LL17@hmac_sha51:
  002a1	41 ff c8	 dec	 r8d
  002a4	44 88 2a	 mov	 BYTE PTR [rdx], r13b
  002a7	48 ff c2	 inc	 rdx
  002aa	45 3b c5	 cmp	 r8d, r13d
  002ad	75 f2		 jne	 SHORT $LL17@hmac_sha51

; 107  : 	burn (osha, sizeof(osha));

  002af	48 8d bc 24 60
	03 00 00	 lea	 rdi, QWORD PTR osha$[rsp]
  002b7	48 8b cb	 mov	 rcx, rbx
  002ba	48 8d 94 24 60
	03 00 00	 lea	 rdx, QWORD PTR osha$[rsp]
  002c2	f3 aa		 rep stosb
  002c4	44 8b c3	 mov	 r8d, ebx
$LL12@hmac_sha51:
  002c7	41 ff c8	 dec	 r8d
  002ca	44 88 2a	 mov	 BYTE PTR [rdx], r13b
  002cd	48 ff c2	 inc	 rdx
  002d0	45 3b c5	 cmp	 r8d, r13d
  002d3	75 f2		 jne	 SHORT $LL12@hmac_sha51

; 108  : 	burn (buf, sizeof(buf));

  002d5	48 8d bc 24 a0
	02 00 00	 lea	 rdi, QWORD PTR buf$[rsp]
  002dd	48 8b ce	 mov	 rcx, rsi
  002e0	48 8d 94 24 a0
	02 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  002e8	f3 aa		 rep stosb
$LL7@hmac_sha51:
  002ea	ff ce		 dec	 esi
  002ec	44 88 2a	 mov	 BYTE PTR [rdx], r13b
  002ef	48 ff c2	 inc	 rdx
  002f2	41 3b f5	 cmp	 esi, r13d
  002f5	75 f3		 jne	 SHORT $LL7@hmac_sha51

; 109  : 	burn (key, sizeof(key));

  002f7	48 8d bc 24 20
	03 00 00	 lea	 rdi, QWORD PTR key$[rsp]
  002ff	48 8b cb	 mov	 rcx, rbx
  00302	48 8d 94 24 20
	03 00 00	 lea	 rdx, QWORD PTR key$[rsp]
  0030a	f3 aa		 rep stosb
$LL2@hmac_sha51:
  0030c	ff cb		 dec	 ebx
  0030e	44 88 2a	 mov	 BYTE PTR [rdx], r13b
  00311	48 ff c2	 inc	 rdx
  00314	41 3b dd	 cmp	 ebx, r13d
  00317	75 f3		 jne	 SHORT $LL2@hmac_sha51

; 110  : }

  00319	48 8b 8c 24 e0
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00321	48 33 cc	 xor	 rcx, rsp
  00324	e8 00 00 00 00	 call	 __security_check_cookie
  00329	48 81 c4 f8 03
	00 00		 add	 rsp, 1016		; 000003f8H
  00330	41 5f		 pop	 r15
  00332	41 5e		 pop	 r14
  00334	41 5d		 pop	 r13
  00336	41 5c		 pop	 r12
  00338	5f		 pop	 rdi
  00339	5e		 pop	 rsi
  0033a	5d		 pop	 rbp
  0033b	5b		 pop	 rbx
  0033c	c3		 ret	 0
hmac_sha512 ENDP
PUBLIC	__$ArrayPad$
PUBLIC	derive_key_whirlpool
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$derive_key_whirlpool DD imagerel $LN20
	DD	imagerel $LN20+315
	DD	imagerel $unwind$derive_key_whirlpool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$derive_key_whirlpool DD 0a2619H
	DD	0150114H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	090H
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed.build\src\common\pkcs5.c
xdata	ENDS
;	COMDAT derive_key_whirlpool
_TEXT	SEGMENT
salt_len$GSCopy$1$ = 64
salt$GSCopy$1$ = 72
u$ = 80
__$ArrayPad$ = 144
pwd$ = 240
pwd_len$ = 248
salt$ = 256
salt_len$ = 264
iterations$ = 272
dk$ = 280
dklen$ = 288
derive_key_whirlpool PROC				; COMDAT

; 562  : {

$LN20:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 563  : 	char u[WHIRLPOOL_DIGESTSIZE];
; 564  : 	int b, l, r;
; 565  : 
; 566  : 	if (dklen % WHIRLPOOL_DIGESTSIZE)

  00026	8b b4 24 20 01
	00 00		 mov	 esi, DWORD PTR dklen$[rsp]
  0002d	4c 8b ac 24 18
	01 00 00	 mov	 r13, QWORD PTR dk$[rsp]
  00035	44 8b fa	 mov	 r15d, edx
  00038	8b c6		 mov	 eax, esi
  0003a	44 89 4c 24 40	 mov	 DWORD PTR salt_len$GSCopy$1$[rsp], r9d
  0003f	4c 89 44 24 48	 mov	 QWORD PTR salt$GSCopy$1$[rsp], r8
  00044	99		 cdq
  00045	4c 8b f1	 mov	 r14, rcx
  00048	83 e2 3f	 and	 edx, 63			; 0000003fH
  0004b	03 c2		 add	 eax, edx
  0004d	8b f8		 mov	 edi, eax
  0004f	83 e0 3f	 and	 eax, 63			; 0000003fH
  00052	c1 ff 06	 sar	 edi, 6
  00055	3b c2		 cmp	 eax, edx
  00057	74 02		 je	 SHORT $LN9@derive_key

; 567  : 	{
; 568  : 		l = 1 + dklen / WHIRLPOOL_DIGESTSIZE;

  00059	ff c7		 inc	 edi
$LN9@derive_key:

; 569  : 	}
; 570  : 	else
; 571  : 	{
; 572  : 		l = dklen / WHIRLPOOL_DIGESTSIZE;
; 573  : 	}
; 574  : 
; 575  : 	r = dklen - (l - 1) * WHIRLPOOL_DIGESTSIZE;
; 576  : 
; 577  : 	/* first l - 1 blocks */
; 578  : 	for (b = 1; b < l; b++)

  0005b	44 8b a4 24 10
	01 00 00	 mov	 r12d, DWORD PTR iterations$[rsp]
  00063	bb 40 00 00 00	 mov	 ebx, 64			; 00000040H
  00068	8b c7		 mov	 eax, edi
  0006a	c1 e0 06	 shl	 eax, 6
  0006d	8d 6b c1	 lea	 ebp, QWORD PTR [rbx-63]
  00070	2b f0		 sub	 esi, eax
  00072	03 f3		 add	 esi, ebx
  00074	3b fd		 cmp	 edi, ebp
  00076	89 b4 24 20 01
	00 00		 mov	 DWORD PTR dklen$[rsp], esi
  0007d	7e 4e		 jle	 SHORT $LN6@derive_key
  0007f	49 8b f0	 mov	 rsi, r8
$LL8@derive_key:

; 579  : 	{
; 580  : 		derive_u_whirlpool (pwd, pwd_len, salt, salt_len, iterations, u, b);

  00082	48 8d 44 24 50	 lea	 rax, QWORD PTR u$[rsp]
  00087	89 6c 24 30	 mov	 DWORD PTR [rsp+48], ebp
  0008b	4c 8b c6	 mov	 r8, rsi
  0008e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00093	41 8b d7	 mov	 edx, r15d
  00096	49 8b ce	 mov	 rcx, r14
  00099	44 89 64 24 20	 mov	 DWORD PTR [rsp+32], r12d
  0009e	e8 00 00 00 00	 call	 derive_u_whirlpool

; 581  : 		memcpy (dk, u, WHIRLPOOL_DIGESTSIZE);

  000a3	48 8d 54 24 50	 lea	 rdx, QWORD PTR u$[rsp]
  000a8	49 8b cd	 mov	 rcx, r13
  000ab	4c 8b c3	 mov	 r8, rbx
  000ae	e8 00 00 00 00	 call	 memcpy
  000b3	44 8b 4c 24 40	 mov	 r9d, DWORD PTR salt_len$GSCopy$1$[rsp]
  000b8	ff c5		 inc	 ebp

; 582  : 		dk += WHIRLPOOL_DIGESTSIZE;

  000ba	4c 03 eb	 add	 r13, rbx
  000bd	3b ef		 cmp	 ebp, edi
  000bf	7c c1		 jl	 SHORT $LL8@derive_key
  000c1	8b b4 24 20 01
	00 00		 mov	 esi, DWORD PTR dklen$[rsp]
  000c8	4c 8b 44 24 48	 mov	 r8, QWORD PTR salt$GSCopy$1$[rsp]
$LN6@derive_key:

; 583  : 	}
; 584  : 
; 585  : 	/* last block */
; 586  : 	derive_u_whirlpool (pwd, pwd_len, salt, salt_len, iterations, u, b);

  000cd	48 8d 44 24 50	 lea	 rax, QWORD PTR u$[rsp]
  000d2	89 6c 24 30	 mov	 DWORD PTR [rsp+48], ebp
  000d6	41 8b d7	 mov	 edx, r15d
  000d9	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000de	49 8b ce	 mov	 rcx, r14
  000e1	44 89 64 24 20	 mov	 DWORD PTR [rsp+32], r12d
  000e6	e8 00 00 00 00	 call	 derive_u_whirlpool

; 587  : 	memcpy (dk, u, r);

  000eb	48 8d 54 24 50	 lea	 rdx, QWORD PTR u$[rsp]
  000f0	4c 63 c6	 movsxd	 r8, esi
  000f3	49 8b cd	 mov	 rcx, r13
  000f6	e8 00 00 00 00	 call	 memcpy

; 588  : 
; 589  : 
; 590  : 	/* Prevent possible leaks. */
; 591  : 	burn (u, sizeof(u));

  000fb	48 8d 7c 24 50	 lea	 rdi, QWORD PTR u$[rsp]
  00100	33 c0		 xor	 eax, eax
  00102	48 8b cb	 mov	 rcx, rbx
  00105	4c 8d 5c 24 50	 lea	 r11, QWORD PTR u$[rsp]
  0010a	f3 aa		 rep stosb
$LL2@derive_key:
  0010c	41 88 03	 mov	 BYTE PTR [r11], al
  0010f	49 ff c3	 inc	 r11
  00112	83 eb 01	 sub	 ebx, 1
  00115	75 f5		 jne	 SHORT $LL2@derive_key

; 592  : }

  00117	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0011f	48 33 cc	 xor	 rcx, rsp
  00122	e8 00 00 00 00	 call	 __security_check_cookie
  00127	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0012e	41 5f		 pop	 r15
  00130	41 5e		 pop	 r14
  00132	41 5d		 pop	 r13
  00134	41 5c		 pop	 r12
  00136	5f		 pop	 rdi
  00137	5e		 pop	 rsi
  00138	5d		 pop	 rbp
  00139	5b		 pop	 rbx
  0013a	c3		 ret	 0
derive_key_whirlpool ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	hmac_ripemd160
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$hmac_ripemd160 DD imagerel $LN116
	DD	imagerel $LN116+1271
	DD	imagerel $unwind$hmac_ripemd160
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$hmac_ripemd160 DD 0a2619H
	DD	03b0114H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	01c0H
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed.build\src\common\pkcs5.c
xdata	ENDS
;	COMDAT hmac_ripemd160
_TEXT	SEGMENT
len$GSCopy$1$ = 32
context$ = 48
tctx$28989 = 144
count$51085 = 240
count$51035 = 248
count$51121 = 256
tk$ = 264
k_ipad$ = 288
k_opad$ = 368
__$ArrayPad$ = 448
key$ = 544
keylen$ = 552
input$ = 560
len$ = 568
digest$ = 576
hmac_ripemd160 PROC					; COMDAT

; 325  : {

$LN116:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 81 ec d8 01
	00 00		 sub	 rsp, 472		; 000001d8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 c0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 326  :     RMD160_CTX context;
; 327  :     unsigned char k_ipad[65];  /* inner padding - key XORd with ipad */
; 328  :     unsigned char k_opad[65];  /* outer padding - key XORd with opad */
; 329  :     unsigned char tk[RIPEMD160_DIGESTSIZE];
; 330  :     int i;
; 331  : 
; 332  :     /* If the key is longer than the hash algorithm block size,
; 333  : 	   let key = ripemd160(key), as per HMAC specifications. */
; 334  :     if (keylen > RIPEMD160_BLOCKSIZE) 

  00026	83 fa 40	 cmp	 edx, 64			; 00000040H
  00029	4c 8b ac 24 40
	02 00 00	 mov	 r13, QWORD PTR digest$[rsp]
  00031	bd 14 00 00 00	 mov	 ebp, 20
  00036	44 89 4c 24 20	 mov	 DWORD PTR len$GSCopy$1$[rsp], r9d
  0003b	4d 8b f8	 mov	 r15, r8
  0003e	44 8b f2	 mov	 r14d, edx
  00041	44 8d 65 4c	 lea	 r12d, QWORD PTR [rbp+76]
  00045	48 8b f1	 mov	 rsi, rcx
  00048	0f 8e 5d 01 00
	00		 jle	 $LN26@hmac_ripem

; 335  : 	{
; 336  :         RMD160_CTX      tctx;
; 337  : 
; 338  :         RMD160Init(&tctx);

  0004e	48 83 a4 24 a8
	00 00 00 00	 and	 QWORD PTR tctx$28989[rsp+24], 0

; 339  :         RMD160Update(&tctx, (const unsigned char *) key, keylen);

  00057	44 8b c2	 mov	 r8d, edx
  0005a	48 8b d1	 mov	 rdx, rcx
  0005d	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR tctx$28989[rsp]
  00065	c7 84 24 90 00
	00 00 01 23 45
	67		 mov	 DWORD PTR tctx$28989[rsp], 1732584193 ; 67452301H
  00070	c7 84 24 94 00
	00 00 89 ab cd
	ef		 mov	 DWORD PTR tctx$28989[rsp+4], -271733879 ; efcdab89H
  0007b	c7 84 24 98 00
	00 00 fe dc ba
	98		 mov	 DWORD PTR tctx$28989[rsp+8], -1732584194 ; 98badcfeH
  00086	c7 84 24 9c 00
	00 00 76 54 32
	10		 mov	 DWORD PTR tctx$28989[rsp+12], 271733878 ; 10325476H
  00091	c7 84 24 a0 00
	00 00 f0 e1 d2
	c3		 mov	 DWORD PTR tctx$28989[rsp+16], -1009589776 ; c3d2e1f0H
  0009c	c6 05 00 00 00
	00 80		 mov	 BYTE PTR PADDING, 128	; 00000080H
  000a3	e8 00 00 00 00	 call	 RMD160Update

; 340  :         RMD160Final(tk, &tctx);

  000a8	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR tctx$28989[rsp+24]
  000b0	48 8b c2	 mov	 rax, rdx
  000b3	88 94 24 f8 00
	00 00		 mov	 BYTE PTR count$51035[rsp], dl
  000ba	44 8d 45 2c	 lea	 r8d, QWORD PTR [rbp+44]
  000be	48 c1 e8 38	 shr	 rax, 56			; 00000038H
  000c2	88 84 24 ff 00
	00 00		 mov	 BYTE PTR count$51035[rsp+7], al
  000c9	48 8b c2	 mov	 rax, rdx
  000cc	48 c1 e8 30	 shr	 rax, 48			; 00000030H
  000d0	88 84 24 fe 00
	00 00		 mov	 BYTE PTR count$51035[rsp+6], al
  000d7	48 8b c2	 mov	 rax, rdx
  000da	48 c1 e8 28	 shr	 rax, 40			; 00000028H
  000de	88 84 24 fd 00
	00 00		 mov	 BYTE PTR count$51035[rsp+5], al
  000e5	48 8b c2	 mov	 rax, rdx
  000e8	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  000ec	88 84 24 fc 00
	00 00		 mov	 BYTE PTR count$51035[rsp+4], al
  000f3	48 8b c2	 mov	 rax, rdx
  000f6	48 c1 e8 18	 shr	 rax, 24
  000fa	88 84 24 fb 00
	00 00		 mov	 BYTE PTR count$51035[rsp+3], al
  00101	48 8b c2	 mov	 rax, rdx
  00104	48 c1 e8 10	 shr	 rax, 16
  00108	88 84 24 fa 00
	00 00		 mov	 BYTE PTR count$51035[rsp+2], al
  0010f	48 8b c2	 mov	 rax, rdx
  00112	48 c1 e8 08	 shr	 rax, 8
  00116	88 84 24 f9 00
	00 00		 mov	 BYTE PTR count$51035[rsp+1], al
  0011d	8a c2		 mov	 al, dl
  0011f	48 c1 ea 03	 shr	 rdx, 3
  00123	83 e2 3f	 and	 edx, 63			; 0000003fH
  00126	44 2b c2	 sub	 r8d, edx
  00129	41 83 f8 09	 cmp	 r8d, 9
  0012d	73 04		 jae	 SHORT $LN45@hmac_ripem
  0012f	41 83 c0 40	 add	 r8d, 64			; 00000040H
$LN45@hmac_ripem:
  00133	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PADDING
  0013a	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR tctx$28989[rsp]
  00142	41 83 c0 f8	 add	 r8d, -8			; fffffff8H
  00146	e8 00 00 00 00	 call	 RMD160Update
  0014b	48 8d 94 24 f8
	00 00 00	 lea	 rdx, QWORD PTR count$51035[rsp]
  00153	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR tctx$28989[rsp]
  0015b	41 b8 08 00 00
	00		 mov	 r8d, 8
  00161	e8 00 00 00 00	 call	 RMD160Update
  00166	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR tctx$28989[rsp]
  0016e	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR tk$[rsp]
  00176	e8 00 00 00 00	 call	 RMD160Final

; 341  : 
; 342  :         key = (char *) tk;
; 343  :         keylen = RIPEMD160_DIGESTSIZE;
; 344  : 
; 345  : 		burn (&tctx, sizeof(tctx));	// Prevent leaks

  0017b	48 8d bc 24 90
	00 00 00	 lea	 rdi, QWORD PTR tctx$28989[rsp]
  00183	33 c0		 xor	 eax, eax
  00185	49 8b cc	 mov	 rcx, r12
  00188	48 8d b4 24 08
	01 00 00	 lea	 rsi, QWORD PTR tk$[rsp]
  00190	44 8b f5	 mov	 r14d, ebp
  00193	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR tctx$28989[rsp]
  0019b	45 8b c4	 mov	 r8d, r12d
  0019e	f3 aa		 rep stosb
$LL25@hmac_ripem:
  001a0	88 02		 mov	 BYTE PTR [rdx], al
  001a2	48 ff c2	 inc	 rdx
  001a5	41 83 e8 01	 sub	 r8d, 1
  001a9	75 f5		 jne	 SHORT $LL25@hmac_ripem
$LN26@hmac_ripem:

; 346  :     }
; 347  : 
; 348  : 	/*
; 349  : 
; 350  : 	RMD160(K XOR opad, RMD160(K XOR ipad, text))
; 351  : 
; 352  : 	where K is an n byte key
; 353  : 	ipad is the byte 0x36 repeated RIPEMD160_BLOCKSIZE times
; 354  : 	opad is the byte 0x5c repeated RIPEMD160_BLOCKSIZE times
; 355  : 	and text is the data being protected */
; 356  : 
; 357  : 
; 358  : 	/* start out by storing key in pads */
; 359  : 	memset(k_ipad, 0x36, sizeof(k_ipad));

  001ab	bb 41 00 00 00	 mov	 ebx, 65			; 00000041H
  001b0	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR k_ipad$[rsp]
  001b8	8d 53 f5	 lea	 edx, QWORD PTR [rbx-11]
  001bb	4c 8b c3	 mov	 r8, rbx
  001be	e8 00 00 00 00	 call	 memset

; 360  :     memset(k_opad, 0x5c, sizeof(k_opad));

  001c3	8d 53 1b	 lea	 edx, QWORD PTR [rbx+27]
  001c6	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR k_opad$[rsp]
  001ce	4c 8b c3	 mov	 r8, rbx
  001d1	e8 00 00 00 00	 call	 memset

; 361  : 
; 362  :     /* XOR key with ipad and opad values */
; 363  :     for (i=0; i<keylen; i++) 

  001d6	49 63 fe	 movsxd	 rdi, r14d
  001d9	45 33 f6	 xor	 r14d, r14d
  001dc	49 3b fe	 cmp	 rdi, r14
  001df	7e 27		 jle	 SHORT $LN21@hmac_ripem
  001e1	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR k_ipad$[rsp]
  001e9	48 8d 94 24 70
	01 00 00	 lea	 rdx, QWORD PTR k_opad$[rsp]
  001f1	48 2b ce	 sub	 rcx, rsi
  001f4	48 2b d6	 sub	 rdx, rsi
$LL23@hmac_ripem:

; 364  : 	{
; 365  :         k_ipad[i] ^= key[i];

  001f7	8a 06		 mov	 al, BYTE PTR [rsi]
  001f9	30 04 31	 xor	 BYTE PTR [rcx+rsi], al

; 366  :         k_opad[i] ^= key[i];

  001fc	30 04 32	 xor	 BYTE PTR [rdx+rsi], al
  001ff	48 ff c6	 inc	 rsi
  00202	48 83 ef 01	 sub	 rdi, 1
  00206	75 ef		 jne	 SHORT $LL23@hmac_ripem
$LN21@hmac_ripem:

; 367  :     }
; 368  : 
; 369  :     /* perform inner RIPEMD-160 */
; 370  : 
; 371  :     RMD160Init(&context);           /* init context for 1st pass */
; 372  :     RMD160Update(&context, k_ipad, RIPEMD160_BLOCKSIZE);  /* start with inner pad */

  00208	bf 40 00 00 00	 mov	 edi, 64			; 00000040H
  0020d	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR k_ipad$[rsp]
  00215	48 8d 4c 24 30	 lea	 rcx, QWORD PTR context$[rsp]
  0021a	44 8b c7	 mov	 r8d, edi
  0021d	4c 89 74 24 48	 mov	 QWORD PTR context$[rsp+24], r14
  00222	c7 44 24 30 01
	23 45 67	 mov	 DWORD PTR context$[rsp], 1732584193 ; 67452301H
  0022a	c7 44 24 34 89
	ab cd ef	 mov	 DWORD PTR context$[rsp+4], -271733879 ; efcdab89H
  00232	c7 44 24 38 fe
	dc ba 98	 mov	 DWORD PTR context$[rsp+8], -1732584194 ; 98badcfeH
  0023a	c7 44 24 3c 76
	54 32 10	 mov	 DWORD PTR context$[rsp+12], 271733878 ; 10325476H
  00242	c7 44 24 40 f0
	e1 d2 c3	 mov	 DWORD PTR context$[rsp+16], -1009589776 ; c3d2e1f0H
  0024a	c6 05 00 00 00
	00 80		 mov	 BYTE PTR PADDING, 128	; 00000080H
  00251	e8 00 00 00 00	 call	 RMD160Update

; 373  :     RMD160Update(&context, (const unsigned char *) input, len); /* then text of datagram */

  00256	44 8b 44 24 20	 mov	 r8d, DWORD PTR len$GSCopy$1$[rsp]
  0025b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR context$[rsp]
  00260	49 8b d7	 mov	 rdx, r15
  00263	e8 00 00 00 00	 call	 RMD160Update

; 374  :     RMD160Final((unsigned char *) digest, &context);         /* finish up 1st pass */

  00268	48 8b 54 24 48	 mov	 rdx, QWORD PTR context$[rsp+24]
  0026d	44 8b c7	 mov	 r8d, edi
  00270	48 8b c2	 mov	 rax, rdx
  00273	88 94 24 f0 00
	00 00		 mov	 BYTE PTR count$51085[rsp], dl
  0027a	48 c1 e8 38	 shr	 rax, 56			; 00000038H
  0027e	88 84 24 f7 00
	00 00		 mov	 BYTE PTR count$51085[rsp+7], al
  00285	48 8b c2	 mov	 rax, rdx
  00288	48 c1 e8 30	 shr	 rax, 48			; 00000030H
  0028c	88 84 24 f6 00
	00 00		 mov	 BYTE PTR count$51085[rsp+6], al
  00293	48 8b c2	 mov	 rax, rdx
  00296	48 c1 e8 28	 shr	 rax, 40			; 00000028H
  0029a	88 84 24 f5 00
	00 00		 mov	 BYTE PTR count$51085[rsp+5], al
  002a1	48 8b c2	 mov	 rax, rdx
  002a4	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  002a8	88 84 24 f4 00
	00 00		 mov	 BYTE PTR count$51085[rsp+4], al
  002af	48 8b c2	 mov	 rax, rdx
  002b2	48 c1 e8 18	 shr	 rax, 24
  002b6	88 84 24 f3 00
	00 00		 mov	 BYTE PTR count$51085[rsp+3], al
  002bd	48 8b c2	 mov	 rax, rdx
  002c0	48 c1 e8 10	 shr	 rax, 16
  002c4	88 84 24 f2 00
	00 00		 mov	 BYTE PTR count$51085[rsp+2], al
  002cb	48 8b c2	 mov	 rax, rdx
  002ce	48 c1 e8 08	 shr	 rax, 8
  002d2	88 84 24 f1 00
	00 00		 mov	 BYTE PTR count$51085[rsp+1], al
  002d9	8a c2		 mov	 al, dl
  002db	48 c1 ea 03	 shr	 rdx, 3
  002df	83 e2 3f	 and	 edx, 63			; 0000003fH
  002e2	44 2b c2	 sub	 r8d, edx
  002e5	41 83 f8 09	 cmp	 r8d, 9
  002e9	73 03		 jae	 SHORT $LN66@hmac_ripem
  002eb	44 03 c7	 add	 r8d, edi
$LN66@hmac_ripem:
  002ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PADDING
  002f5	48 8d 4c 24 30	 lea	 rcx, QWORD PTR context$[rsp]
  002fa	41 83 c0 f8	 add	 r8d, -8			; fffffff8H
  002fe	e8 00 00 00 00	 call	 RMD160Update
  00303	be 08 00 00 00	 mov	 esi, 8
  00308	48 8d 94 24 f0
	00 00 00	 lea	 rdx, QWORD PTR count$51085[rsp]
  00310	48 8d 4c 24 30	 lea	 rcx, QWORD PTR context$[rsp]
  00315	44 8b c6	 mov	 r8d, esi
  00318	e8 00 00 00 00	 call	 RMD160Update
  0031d	4d 3b ee	 cmp	 r13, r14
  00320	74 0d		 je	 SHORT $LN61@hmac_ripem
  00322	48 8d 54 24 30	 lea	 rdx, QWORD PTR context$[rsp]
  00327	49 8b cd	 mov	 rcx, r13
  0032a	e8 00 00 00 00	 call	 RMD160Final
$LN61@hmac_ripem:

; 375  : 
; 376  :     /* perform outer RIPEMD-160 */
; 377  :     RMD160Init(&context);           /* init context for 2nd pass */
; 378  :     RMD160Update(&context, k_opad, RIPEMD160_BLOCKSIZE);  /* start with outer pad */

  0032f	48 8d 94 24 70
	01 00 00	 lea	 rdx, QWORD PTR k_opad$[rsp]
  00337	48 8d 4c 24 30	 lea	 rcx, QWORD PTR context$[rsp]
  0033c	44 8b c7	 mov	 r8d, edi
  0033f	4c 89 74 24 48	 mov	 QWORD PTR context$[rsp+24], r14
  00344	c7 44 24 30 01
	23 45 67	 mov	 DWORD PTR context$[rsp], 1732584193 ; 67452301H
  0034c	c7 44 24 34 89
	ab cd ef	 mov	 DWORD PTR context$[rsp+4], -271733879 ; efcdab89H
  00354	c7 44 24 38 fe
	dc ba 98	 mov	 DWORD PTR context$[rsp+8], -1732584194 ; 98badcfeH
  0035c	c7 44 24 3c 76
	54 32 10	 mov	 DWORD PTR context$[rsp+12], 271733878 ; 10325476H
  00364	c7 44 24 40 f0
	e1 d2 c3	 mov	 DWORD PTR context$[rsp+16], -1009589776 ; c3d2e1f0H
  0036c	c6 05 00 00 00
	00 80		 mov	 BYTE PTR PADDING, 128	; 00000080H
  00373	e8 00 00 00 00	 call	 RMD160Update

; 379  :     /* results of 1st hash */
; 380  :     RMD160Update(&context, (const unsigned char *) digest, RIPEMD160_DIGESTSIZE);

  00378	48 8d 4c 24 30	 lea	 rcx, QWORD PTR context$[rsp]
  0037d	44 8b c5	 mov	 r8d, ebp
  00380	49 8b d5	 mov	 rdx, r13
  00383	e8 00 00 00 00	 call	 RMD160Update

; 381  :     RMD160Final((unsigned char *) digest, &context);         /* finish up 2nd pass */

  00388	48 8b 4c 24 48	 mov	 rcx, QWORD PTR context$[rsp+24]
  0038d	44 8b c7	 mov	 r8d, edi
  00390	48 8b c1	 mov	 rax, rcx
  00393	88 8c 24 00 01
	00 00		 mov	 BYTE PTR count$51121[rsp], cl
  0039a	48 c1 e8 38	 shr	 rax, 56			; 00000038H
  0039e	88 84 24 07 01
	00 00		 mov	 BYTE PTR count$51121[rsp+7], al
  003a5	48 8b c1	 mov	 rax, rcx
  003a8	48 c1 e8 30	 shr	 rax, 48			; 00000030H
  003ac	88 84 24 06 01
	00 00		 mov	 BYTE PTR count$51121[rsp+6], al
  003b3	48 8b c1	 mov	 rax, rcx
  003b6	48 c1 e8 28	 shr	 rax, 40			; 00000028H
  003ba	88 84 24 05 01
	00 00		 mov	 BYTE PTR count$51121[rsp+5], al
  003c1	48 8b c1	 mov	 rax, rcx
  003c4	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  003c8	88 84 24 04 01
	00 00		 mov	 BYTE PTR count$51121[rsp+4], al
  003cf	48 8b c1	 mov	 rax, rcx
  003d2	48 c1 e8 18	 shr	 rax, 24
  003d6	88 84 24 03 01
	00 00		 mov	 BYTE PTR count$51121[rsp+3], al
  003dd	48 8b c1	 mov	 rax, rcx
  003e0	48 c1 e8 10	 shr	 rax, 16
  003e4	88 84 24 02 01
	00 00		 mov	 BYTE PTR count$51121[rsp+2], al
  003eb	48 8b c1	 mov	 rax, rcx
  003ee	48 c1 e8 08	 shr	 rax, 8
  003f2	88 84 24 01 01
	00 00		 mov	 BYTE PTR count$51121[rsp+1], al
  003f9	8a c1		 mov	 al, cl
  003fb	48 c1 e9 03	 shr	 rcx, 3
  003ff	83 e1 3f	 and	 ecx, 63			; 0000003fH
  00402	44 2b c1	 sub	 r8d, ecx
  00405	41 83 f8 09	 cmp	 r8d, 9
  00409	73 03		 jae	 SHORT $LN85@hmac_ripem
  0040b	44 03 c7	 add	 r8d, edi
$LN85@hmac_ripem:
  0040e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PADDING
  00415	48 8d 4c 24 30	 lea	 rcx, QWORD PTR context$[rsp]
  0041a	41 83 c0 f8	 add	 r8d, -8			; fffffff8H
  0041e	e8 00 00 00 00	 call	 RMD160Update
  00423	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR count$51121[rsp]
  0042b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR context$[rsp]
  00430	44 8b c6	 mov	 r8d, esi
  00433	e8 00 00 00 00	 call	 RMD160Update
  00438	4d 3b ee	 cmp	 r13, r14
  0043b	74 0d		 je	 SHORT $LN20@hmac_ripem
  0043d	48 8d 54 24 30	 lea	 rdx, QWORD PTR context$[rsp]
  00442	49 8b cd	 mov	 rcx, r13
  00445	e8 00 00 00 00	 call	 RMD160Final
$LN20@hmac_ripem:

; 382  : 
; 383  : 	/* Prevent possible leaks. */
; 384  :     burn (k_ipad, sizeof(k_ipad));

  0044a	48 8d bc 24 20
	01 00 00	 lea	 rdi, QWORD PTR k_ipad$[rsp]
  00452	33 c0		 xor	 eax, eax
  00454	48 8b cb	 mov	 rcx, rbx
  00457	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR k_ipad$[rsp]
  0045f	44 8b c3	 mov	 r8d, ebx
  00462	f3 aa		 rep stosb
$LL17@hmac_ripem:
  00464	41 ff c8	 dec	 r8d
  00467	44 88 32	 mov	 BYTE PTR [rdx], r14b
  0046a	48 ff c2	 inc	 rdx
  0046d	45 3b c6	 cmp	 r8d, r14d
  00470	75 f2		 jne	 SHORT $LL17@hmac_ripem

; 385  :     burn (k_opad, sizeof(k_opad));

  00472	48 8d bc 24 70
	01 00 00	 lea	 rdi, QWORD PTR k_opad$[rsp]
  0047a	48 8b cb	 mov	 rcx, rbx
  0047d	48 8d 94 24 70
	01 00 00	 lea	 rdx, QWORD PTR k_opad$[rsp]
  00485	f3 aa		 rep stosb
$LL12@hmac_ripem:
  00487	ff cb		 dec	 ebx
  00489	44 88 32	 mov	 BYTE PTR [rdx], r14b
  0048c	48 ff c2	 inc	 rdx
  0048f	41 3b de	 cmp	 ebx, r14d
  00492	75 f3		 jne	 SHORT $LL12@hmac_ripem

; 386  : 	burn (tk, sizeof(tk));

  00494	48 8d bc 24 08
	01 00 00	 lea	 rdi, QWORD PTR tk$[rsp]
  0049c	48 8b cd	 mov	 rcx, rbp
  0049f	48 8d 94 24 08
	01 00 00	 lea	 rdx, QWORD PTR tk$[rsp]
  004a7	f3 aa		 rep stosb
$LL7@hmac_ripem:
  004a9	ff cd		 dec	 ebp
  004ab	44 88 32	 mov	 BYTE PTR [rdx], r14b
  004ae	48 ff c2	 inc	 rdx
  004b1	41 3b ee	 cmp	 ebp, r14d
  004b4	75 f3		 jne	 SHORT $LL7@hmac_ripem

; 387  : 	burn (&context, sizeof(context));

  004b6	48 8d 7c 24 30	 lea	 rdi, QWORD PTR context$[rsp]
  004bb	49 8b cc	 mov	 rcx, r12
  004be	48 8d 54 24 30	 lea	 rdx, QWORD PTR context$[rsp]
  004c3	f3 aa		 rep stosb
$LL2@hmac_ripem:
  004c5	41 ff cc	 dec	 r12d
  004c8	44 88 32	 mov	 BYTE PTR [rdx], r14b
  004cb	48 ff c2	 inc	 rdx
  004ce	45 3b e6	 cmp	 r12d, r14d
  004d1	75 f2		 jne	 SHORT $LL2@hmac_ripem

; 388  : }

  004d3	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004db	48 33 cc	 xor	 rcx, rsp
  004de	e8 00 00 00 00	 call	 __security_check_cookie
  004e3	48 81 c4 d8 01
	00 00		 add	 rsp, 472		; 000001d8H
  004ea	41 5f		 pop	 r15
  004ec	41 5e		 pop	 r14
  004ee	41 5d		 pop	 r13
  004f0	41 5c		 pop	 r12
  004f2	5f		 pop	 rdi
  004f3	5e		 pop	 rsi
  004f4	5d		 pop	 rbp
  004f5	5b		 pop	 rbx
  004f6	c3		 ret	 0
hmac_ripemd160 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	derive_key_sha1
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$derive_key_sha1 DD imagerel $LN20
	DD	imagerel $LN20+326
	DD	imagerel $unwind$derive_key_sha1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$derive_key_sha1 DD 092019H
	DD	0f00de211H
	DD	0d009e00bH
	DD	07005c007H
	DD	050036004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	068H
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed.build\src\common\pkcs5.c
xdata	ENDS
;	COMDAT derive_key_sha1
_TEXT	SEGMENT
salt_len$GSCopy$1$ = 64
salt$GSCopy$1$ = 72
u$ = 80
__$ArrayPad$ = 104
pwd$ = 192
pwd_len$ = 200
salt$ = 208
salt_len$ = 216
iterations$ = 224
dk$ = 232
dklen$ = 240
derive_key_sha1 PROC					; COMDAT

; 290  : {

$LN20:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 44 24 68	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 291  : 	char u[SHA1_DIGESTSIZE];
; 292  : 	int b, l, r;
; 293  : 
; 294  : 	if (dklen % SHA1_DIGESTSIZE)

  00020	8b b4 24 f0 00
	00 00		 mov	 esi, DWORD PTR dklen$[rsp]
  00027	4c 8b a4 24 e8
	00 00 00	 mov	 r12, QWORD PTR dk$[rsp]
  0002f	4c 8b f1	 mov	 r14, rcx
  00032	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00037	44 8b fa	 mov	 r15d, edx
  0003a	44 89 4c 24 40	 mov	 DWORD PTR salt_len$GSCopy$1$[rsp], r9d
  0003f	4c 89 44 24 48	 mov	 QWORD PTR salt$GSCopy$1$[rsp], r8
  00044	f7 ee		 imul	 esi
  00046	8b fa		 mov	 edi, edx
  00048	c1 ff 03	 sar	 edi, 3
  0004b	8b c7		 mov	 eax, edi
  0004d	c1 e8 1f	 shr	 eax, 31
  00050	03 f8		 add	 edi, eax
  00052	8d 0c bf	 lea	 ecx, DWORD PTR [rdi+rdi*4]
  00055	c1 e1 02	 shl	 ecx, 2
  00058	3b f1		 cmp	 esi, ecx
  0005a	74 02		 je	 SHORT $LN9@derive_key@2

; 295  : 	{
; 296  : 		l = 1 + dklen / SHA1_DIGESTSIZE;

  0005c	ff c7		 inc	 edi
$LN9@derive_key@2:

; 297  : 	}
; 298  : 	else
; 299  : 	{
; 300  : 		l = dklen / SHA1_DIGESTSIZE;
; 301  : 	}
; 302  : 
; 303  : 	r = dklen - (l - 1) * SHA1_DIGESTSIZE;
; 304  : 
; 305  : 	/* first l - 1 blocks */
; 306  : 	for (b = 1; b < l; b++)

  0005e	44 8b ac 24 e0
	00 00 00	 mov	 r13d, DWORD PTR iterations$[rsp]
  00066	bb 14 00 00 00	 mov	 ebx, 20
  0006b	8d 04 bf	 lea	 eax, DWORD PTR [rdi+rdi*4]
  0006e	c1 e0 02	 shl	 eax, 2
  00071	8d 6b ed	 lea	 ebp, QWORD PTR [rbx-19]
  00074	2b f0		 sub	 esi, eax
  00076	03 f3		 add	 esi, ebx
  00078	3b fd		 cmp	 edi, ebp
  0007a	89 b4 24 f0 00
	00 00		 mov	 DWORD PTR dklen$[rsp], esi
  00081	7e 5b		 jle	 SHORT $LN6@derive_key@2
  00083	49 8b f0	 mov	 rsi, r8
$LL8@derive_key@2:

; 307  : 	{
; 308  : 		derive_u_sha1 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  00086	48 8d 44 24 50	 lea	 rax, QWORD PTR u$[rsp]
  0008b	89 6c 24 30	 mov	 DWORD PTR [rsp+48], ebp
  0008f	4c 8b c6	 mov	 r8, rsi
  00092	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00097	41 8b d7	 mov	 edx, r15d
  0009a	49 8b ce	 mov	 rcx, r14
  0009d	44 89 6c 24 20	 mov	 DWORD PTR [rsp+32], r13d
  000a2	e8 00 00 00 00	 call	 derive_u_sha1
  000a7	44 8b 4c 24 40	 mov	 r9d, DWORD PTR salt_len$GSCopy$1$[rsp]

; 309  : 		memcpy (dk, u, SHA1_DIGESTSIZE);

  000ac	48 8d 4c 24 50	 lea	 rcx, QWORD PTR u$[rsp]
  000b1	ff c5		 inc	 ebp
  000b3	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  000b6	49 89 04 24	 mov	 QWORD PTR [r12], rax
  000ba	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  000be	49 89 44 24 08	 mov	 QWORD PTR [r12+8], rax
  000c3	8b 41 10	 mov	 eax, DWORD PTR [rcx+16]
  000c6	41 89 44 24 10	 mov	 DWORD PTR [r12+16], eax

; 310  : 		dk += SHA1_DIGESTSIZE;

  000cb	4c 03 e3	 add	 r12, rbx
  000ce	3b ef		 cmp	 ebp, edi
  000d0	7c b4		 jl	 SHORT $LL8@derive_key@2
  000d2	8b b4 24 f0 00
	00 00		 mov	 esi, DWORD PTR dklen$[rsp]
  000d9	4c 8b 44 24 48	 mov	 r8, QWORD PTR salt$GSCopy$1$[rsp]
$LN6@derive_key@2:

; 311  : 	}
; 312  : 
; 313  : 	/* last block */
; 314  : 	derive_u_sha1 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  000de	48 8d 44 24 50	 lea	 rax, QWORD PTR u$[rsp]
  000e3	89 6c 24 30	 mov	 DWORD PTR [rsp+48], ebp
  000e7	41 8b d7	 mov	 edx, r15d
  000ea	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000ef	49 8b ce	 mov	 rcx, r14
  000f2	44 89 6c 24 20	 mov	 DWORD PTR [rsp+32], r13d
  000f7	e8 00 00 00 00	 call	 derive_u_sha1

; 315  : 	memcpy (dk, u, r);

  000fc	48 8d 54 24 50	 lea	 rdx, QWORD PTR u$[rsp]
  00101	4c 63 c6	 movsxd	 r8, esi
  00104	49 8b cc	 mov	 rcx, r12
  00107	e8 00 00 00 00	 call	 memcpy

; 316  : 
; 317  : 
; 318  : 	/* Prevent possible leaks. */
; 319  : 	burn (u, sizeof(u));

  0010c	48 8d 7c 24 50	 lea	 rdi, QWORD PTR u$[rsp]
  00111	33 c0		 xor	 eax, eax
  00113	48 8b cb	 mov	 rcx, rbx
  00116	4c 8d 5c 24 50	 lea	 r11, QWORD PTR u$[rsp]
  0011b	f3 aa		 rep stosb
$LL2@derive_key@2:
  0011d	41 88 03	 mov	 BYTE PTR [r11], al
  00120	49 ff c3	 inc	 r11
  00123	83 eb 01	 sub	 ebx, 1
  00126	75 f5		 jne	 SHORT $LL2@derive_key@2

; 320  : }

  00128	48 8b 4c 24 68	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0012d	48 33 cc	 xor	 rcx, rsp
  00130	e8 00 00 00 00	 call	 __security_check_cookie
  00135	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00139	41 5f		 pop	 r15
  0013b	41 5e		 pop	 r14
  0013d	41 5d		 pop	 r13
  0013f	41 5c		 pop	 r12
  00141	5f		 pop	 rdi
  00142	5e		 pop	 rsi
  00143	5d		 pop	 rbp
  00144	5b		 pop	 rbx
  00145	c3		 ret	 0
derive_key_sha1 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	derive_u_sha512
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$derive_u_sha512 DD imagerel $LN33
	DD	imagerel $LN33+344
	DD	imagerel $unwind$derive_u_sha512
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$derive_u_sha512 DD 072019H
	DD	02a010eH
	DD	07005c007H
	DD	050036004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	0140H
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed.build\src\common\pkcs5.c
xdata	ENDS
;	COMDAT derive_u_sha512
_TEXT	SEGMENT
counter$ = 48
j$ = 64
k$ = 128
init$ = 192
__$ArrayPad$ = 320
pwd$ = 384
pwd_len$ = 392
salt$ = 400
salt_len$ = 408
iterations$ = 416
u$ = 424
b$ = 432
derive_u_sha512 PROC					; COMDAT

; 114  : {

$LN33:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	48 81 ec 50 01
	00 00		 sub	 rsp, 336		; 00000150H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00020	48 8b b4 24 a8
	01 00 00	 mov	 rsi, QWORD PTR u$[rsp]

; 115  : 	char j[SHA512_DIGESTSIZE], k[SHA512_DIGESTSIZE];
; 116  : 	char init[128];
; 117  : 	char counter[4];
; 118  : 	int c, i;
; 119  : 
; 120  : 	/* iteration 1 */
; 121  : 	memset (counter, 0, 4);

  00028	33 c0		 xor	 eax, eax
  0002a	4d 8b d0	 mov	 r10, r8
  0002d	89 44 24 30	 mov	 DWORD PTR counter$[rsp], eax

; 122  : 	counter[3] = (char) b;

  00031	8a 84 24 b0 01
	00 00		 mov	 al, BYTE PTR b$[rsp]
  00038	49 63 d9	 movsxd	 rbx, r9d
  0003b	48 8b e9	 mov	 rbp, rcx
  0003e	44 8b e2	 mov	 r12d, edx

; 123  : 	memcpy (init, salt, salt_len);	/* salt */

  00041	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR init$[rsp]
  00049	4c 8b c3	 mov	 r8, rbx
  0004c	49 8b d2	 mov	 rdx, r10
  0004f	88 44 24 33	 mov	 BYTE PTR counter$[rsp+3], al
  00053	e8 00 00 00 00	 call	 memcpy

; 124  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */

  00058	8b 54 24 30	 mov	 edx, DWORD PTR counter$[rsp]

; 125  : 	hmac_sha512 (pwd, pwd_len, init, salt_len + 4, j, SHA512_DIGESTSIZE);

  0005c	44 8d 4b 04	 lea	 r9d, DWORD PTR [rbx+4]
  00060	89 94 1c c0 00
	00 00		 mov	 DWORD PTR init$[rsp+rbx], edx
  00067	48 8d 44 24 40	 lea	 rax, QWORD PTR j$[rsp]
  0006c	4c 8d 84 24 c0
	00 00 00	 lea	 r8, QWORD PTR init$[rsp]
  00074	bb 40 00 00 00	 mov	 ebx, 64			; 00000040H
  00079	41 8b d4	 mov	 edx, r12d
  0007c	48 8b cd	 mov	 rcx, rbp
  0007f	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  00083	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00088	e8 00 00 00 00	 call	 hmac_sha512

; 126  : 	memcpy (u, j, SHA512_DIGESTSIZE);

  0008d	48 8d 54 24 40	 lea	 rdx, QWORD PTR j$[rsp]
  00092	48 8b ce	 mov	 rcx, rsi
  00095	4c 8b c3	 mov	 r8, rbx
  00098	e8 00 00 00 00	 call	 memcpy

; 127  : 
; 128  : 	/* remaining iterations */
; 129  : 	for (c = 1; c < iterations; c++)

  0009d	8b 84 24 a0 01
	00 00		 mov	 eax, DWORD PTR iterations$[rsp]
  000a4	83 f8 01	 cmp	 eax, 1
  000a7	7e 53		 jle	 SHORT $LN10@derive_u_s@2
  000a9	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR k$[rsp]
  000b1	8d 78 ff	 lea	 edi, DWORD PTR [rax-1]
  000b4	48 2b f1	 sub	 rsi, rcx
$LL16@derive_u_s@2:

; 130  : 	{
; 131  : 		hmac_sha512 (pwd, pwd_len, j, SHA512_DIGESTSIZE, k, SHA512_DIGESTSIZE);

  000b7	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR k$[rsp]
  000bf	4c 8d 44 24 40	 lea	 r8, QWORD PTR j$[rsp]
  000c4	44 8b cb	 mov	 r9d, ebx
  000c7	41 8b d4	 mov	 edx, r12d
  000ca	48 8b cd	 mov	 rcx, rbp
  000cd	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  000d1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d6	e8 00 00 00 00	 call	 hmac_sha512

; 132  : 		for (i = 0; i < SHA512_DIGESTSIZE; i++)

  000db	33 d2		 xor	 edx, edx
$LL13@derive_u_s@2:

; 133  : 		{
; 134  : 			u[i] ^= k[i];

  000dd	48 8d 8c 14 80
	00 00 00	 lea	 rcx, QWORD PTR k$[rsp+rdx]
  000e5	48 ff c2	 inc	 rdx
  000e8	8a 01		 mov	 al, BYTE PTR [rcx]
  000ea	30 04 0e	 xor	 BYTE PTR [rsi+rcx], al
  000ed	48 3b d3	 cmp	 rdx, rbx

; 135  : 			j[i] = k[i];

  000f0	88 44 14 3f	 mov	 BYTE PTR j$[rsp+rdx-1], al
  000f4	7c e7		 jl	 SHORT $LL13@derive_u_s@2

; 127  : 
; 128  : 	/* remaining iterations */
; 129  : 	for (c = 1; c < iterations; c++)

  000f6	48 83 ef 01	 sub	 rdi, 1
  000fa	75 bb		 jne	 SHORT $LL16@derive_u_s@2
$LN10@derive_u_s@2:

; 136  : 		}
; 137  : 	}
; 138  : 
; 139  : 	/* Prevent possible leaks. */
; 140  : 	burn (j, sizeof(j));

  000fc	48 8d 7c 24 40	 lea	 rdi, QWORD PTR j$[rsp]
  00101	33 c0		 xor	 eax, eax
  00103	48 8b cb	 mov	 rcx, rbx
  00106	48 8d 54 24 40	 lea	 rdx, QWORD PTR j$[rsp]
  0010b	44 8b c3	 mov	 r8d, ebx
  0010e	f3 aa		 rep stosb
$LL7@derive_u_s@2:
  00110	88 02		 mov	 BYTE PTR [rdx], al
  00112	48 ff c2	 inc	 rdx
  00115	41 83 e8 01	 sub	 r8d, 1
  00119	75 f5		 jne	 SHORT $LL7@derive_u_s@2

; 141  : 	burn (k, sizeof(k));

  0011b	48 8d bc 24 80
	00 00 00	 lea	 rdi, QWORD PTR k$[rsp]
  00123	48 8b cb	 mov	 rcx, rbx
  00126	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  0012e	f3 aa		 rep stosb
$LL2@derive_u_s@2:
  00130	88 02		 mov	 BYTE PTR [rdx], al
  00132	48 ff c2	 inc	 rdx
  00135	83 eb 01	 sub	 ebx, 1
  00138	75 f6		 jne	 SHORT $LL2@derive_u_s@2

; 142  : }

  0013a	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00142	48 33 cc	 xor	 rcx, rsp
  00145	e8 00 00 00 00	 call	 __security_check_cookie
  0014a	48 81 c4 50 01
	00 00		 add	 rsp, 336		; 00000150H
  00151	41 5c		 pop	 r12
  00153	5f		 pop	 rdi
  00154	5e		 pop	 rsi
  00155	5d		 pop	 rbp
  00156	5b		 pop	 rbx
  00157	c3		 ret	 0
derive_u_sha512 ENDP
PUBLIC	__$ArrayPad$
PUBLIC	derive_u_ripemd160
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$derive_u_ripemd160 DD imagerel $LN33
	DD	imagerel $LN33+312
	DD	imagerel $unwind$derive_u_ripemd160
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$derive_u_ripemd160 DD 072019H
	DD	020010eH
	DD	07005c007H
	DD	050036004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	0f0H
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed.build\src\common\pkcs5.c
xdata	ENDS
;	COMDAT derive_u_ripemd160
_TEXT	SEGMENT
counter$ = 48
j$ = 56
k$ = 80
init$ = 112
__$ArrayPad$ = 240
pwd$ = 304
pwd_len$ = 312
salt$ = 320
salt_len$ = 328
iterations$ = 336
u$ = 344
b$ = 352
derive_u_ripemd160 PROC					; COMDAT

; 391  : {

$LN33:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	48 81 ec 00 01
	00 00		 sub	 rsp, 256		; 00000100H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00020	48 8b b4 24 58
	01 00 00	 mov	 rsi, QWORD PTR u$[rsp]

; 392  : 	char j[RIPEMD160_DIGESTSIZE], k[RIPEMD160_DIGESTSIZE];
; 393  : 	char init[128];
; 394  : 	char counter[4];
; 395  : 	int c, i;
; 396  : 
; 397  : 	/* iteration 1 */
; 398  : 	memset (counter, 0, 4);

  00028	33 c0		 xor	 eax, eax
  0002a	4d 8b d0	 mov	 r10, r8
  0002d	89 44 24 30	 mov	 DWORD PTR counter$[rsp], eax

; 399  : 	counter[3] = (char) b;

  00031	8a 84 24 60 01
	00 00		 mov	 al, BYTE PTR b$[rsp]
  00038	49 63 d9	 movsxd	 rbx, r9d
  0003b	48 8b e9	 mov	 rbp, rcx
  0003e	44 8b e2	 mov	 r12d, edx

; 400  : 	memcpy (init, salt, salt_len);	/* salt */

  00041	48 8d 4c 24 70	 lea	 rcx, QWORD PTR init$[rsp]
  00046	4c 8b c3	 mov	 r8, rbx
  00049	49 8b d2	 mov	 rdx, r10
  0004c	88 44 24 33	 mov	 BYTE PTR counter$[rsp+3], al
  00050	e8 00 00 00 00	 call	 memcpy

; 401  : 	memcpy (&init[salt_len], counter, 4);	/* big-endian block number */

  00055	8b 54 24 30	 mov	 edx, DWORD PTR counter$[rsp]

; 402  : 	hmac_ripemd160 (pwd, pwd_len, init, salt_len + 4, j);

  00059	48 8d 44 24 38	 lea	 rax, QWORD PTR j$[rsp]
  0005e	89 54 1c 70	 mov	 DWORD PTR init$[rsp+rbx], edx
  00062	44 8d 4b 04	 lea	 r9d, DWORD PTR [rbx+4]
  00066	4c 8d 44 24 70	 lea	 r8, QWORD PTR init$[rsp]
  0006b	41 8b d4	 mov	 edx, r12d
  0006e	48 8b cd	 mov	 rcx, rbp
  00071	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00076	e8 00 00 00 00	 call	 hmac_ripemd160

; 403  : 	memcpy (u, j, RIPEMD160_DIGESTSIZE);

  0007b	bb 14 00 00 00	 mov	 ebx, 20
  00080	48 8d 54 24 38	 lea	 rdx, QWORD PTR j$[rsp]
  00085	4c 8b c3	 mov	 r8, rbx
  00088	48 8b ce	 mov	 rcx, rsi
  0008b	e8 00 00 00 00	 call	 memcpy

; 404  : 
; 405  : 	/* remaining iterations */
; 406  : 	for (c = 1; c < iterations; c++)

  00090	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR iterations$[rsp]
  00097	83 f8 01	 cmp	 eax, 1
  0009a	7e 46		 jle	 SHORT $LN10@derive_u_r
  0009c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR k$[rsp]
  000a1	8d 78 ff	 lea	 edi, DWORD PTR [rax-1]
  000a4	48 2b f1	 sub	 rsi, rcx
$LL16@derive_u_r:

; 407  : 	{
; 408  : 		hmac_ripemd160 (pwd, pwd_len, j, RIPEMD160_DIGESTSIZE, k);

  000a7	48 8d 44 24 50	 lea	 rax, QWORD PTR k$[rsp]
  000ac	4c 8d 44 24 38	 lea	 r8, QWORD PTR j$[rsp]
  000b1	44 8b cb	 mov	 r9d, ebx
  000b4	41 8b d4	 mov	 edx, r12d
  000b7	48 8b cd	 mov	 rcx, rbp
  000ba	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000bf	e8 00 00 00 00	 call	 hmac_ripemd160

; 409  : 		for (i = 0; i < RIPEMD160_DIGESTSIZE; i++)

  000c4	33 d2		 xor	 edx, edx
$LL13@derive_u_r:

; 410  : 		{
; 411  : 			u[i] ^= k[i];

  000c6	48 8d 4c 14 50	 lea	 rcx, QWORD PTR k$[rsp+rdx]
  000cb	48 ff c2	 inc	 rdx
  000ce	8a 01		 mov	 al, BYTE PTR [rcx]
  000d0	30 04 0e	 xor	 BYTE PTR [rsi+rcx], al
  000d3	48 3b d3	 cmp	 rdx, rbx

; 412  : 			j[i] = k[i];

  000d6	88 44 14 37	 mov	 BYTE PTR j$[rsp+rdx-1], al
  000da	7c ea		 jl	 SHORT $LL13@derive_u_r

; 404  : 
; 405  : 	/* remaining iterations */
; 406  : 	for (c = 1; c < iterations; c++)

  000dc	48 83 ef 01	 sub	 rdi, 1
  000e0	75 c5		 jne	 SHORT $LL16@derive_u_r
$LN10@derive_u_r:

; 413  : 		}
; 414  : 	}
; 415  : 
; 416  : 	/* Prevent possible leaks. */
; 417  : 	burn (j, sizeof(j));

  000e2	48 8d 7c 24 38	 lea	 rdi, QWORD PTR j$[rsp]
  000e7	33 c0		 xor	 eax, eax
  000e9	48 8b cb	 mov	 rcx, rbx
  000ec	48 8d 54 24 38	 lea	 rdx, QWORD PTR j$[rsp]
  000f1	44 8b c3	 mov	 r8d, ebx
  000f4	f3 aa		 rep stosb
$LL7@derive_u_r:
  000f6	88 02		 mov	 BYTE PTR [rdx], al
  000f8	48 ff c2	 inc	 rdx
  000fb	41 83 e8 01	 sub	 r8d, 1
  000ff	75 f5		 jne	 SHORT $LL7@derive_u_r

; 418  : 	burn (k, sizeof(k));

  00101	48 8d 7c 24 50	 lea	 rdi, QWORD PTR k$[rsp]
  00106	48 8b cb	 mov	 rcx, rbx
  00109	48 8d 54 24 50	 lea	 rdx, QWORD PTR k$[rsp]
  0010e	f3 aa		 rep stosb
$LL2@derive_u_r:
  00110	88 02		 mov	 BYTE PTR [rdx], al
  00112	48 ff c2	 inc	 rdx
  00115	83 eb 01	 sub	 ebx, 1
  00118	75 f6		 jne	 SHORT $LL2@derive_u_r

; 419  : }

  0011a	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00122	48 33 cc	 xor	 rcx, rsp
  00125	e8 00 00 00 00	 call	 __security_check_cookie
  0012a	48 81 c4 00 01
	00 00		 add	 rsp, 256		; 00000100H
  00131	41 5c		 pop	 r12
  00133	5f		 pop	 rdi
  00134	5e		 pop	 rsi
  00135	5d		 pop	 rbp
  00136	5b		 pop	 rbx
  00137	c3		 ret	 0
derive_u_ripemd160 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	derive_key_sha512
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$derive_key_sha512 DD imagerel $LN20
	DD	imagerel $LN20+315
	DD	imagerel $unwind$derive_key_sha512
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$derive_key_sha512 DD 0a2619H
	DD	0150114H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	090H
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed.build\src\common\pkcs5.c
xdata	ENDS
;	COMDAT derive_key_sha512
_TEXT	SEGMENT
salt_len$GSCopy$1$ = 64
salt$GSCopy$1$ = 72
u$ = 80
__$ArrayPad$ = 144
pwd$ = 240
pwd_len$ = 248
salt$ = 256
salt_len$ = 264
iterations$ = 272
dk$ = 280
dklen$ = 288
derive_key_sha512 PROC					; COMDAT

; 146  : {

$LN20:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 147  : 	char u[SHA512_DIGESTSIZE];
; 148  : 	int b, l, r;
; 149  : 
; 150  : 	if (dklen % SHA512_DIGESTSIZE)

  00026	8b b4 24 20 01
	00 00		 mov	 esi, DWORD PTR dklen$[rsp]
  0002d	4c 8b ac 24 18
	01 00 00	 mov	 r13, QWORD PTR dk$[rsp]
  00035	44 8b fa	 mov	 r15d, edx
  00038	8b c6		 mov	 eax, esi
  0003a	44 89 4c 24 40	 mov	 DWORD PTR salt_len$GSCopy$1$[rsp], r9d
  0003f	4c 89 44 24 48	 mov	 QWORD PTR salt$GSCopy$1$[rsp], r8
  00044	99		 cdq
  00045	4c 8b f1	 mov	 r14, rcx
  00048	83 e2 3f	 and	 edx, 63			; 0000003fH
  0004b	03 c2		 add	 eax, edx
  0004d	8b f8		 mov	 edi, eax
  0004f	83 e0 3f	 and	 eax, 63			; 0000003fH
  00052	c1 ff 06	 sar	 edi, 6
  00055	3b c2		 cmp	 eax, edx
  00057	74 02		 je	 SHORT $LN9@derive_key@3

; 151  : 	{
; 152  : 		l = 1 + dklen / SHA512_DIGESTSIZE;

  00059	ff c7		 inc	 edi
$LN9@derive_key@3:

; 153  : 	}
; 154  : 	else
; 155  : 	{
; 156  : 		l = dklen / SHA512_DIGESTSIZE;
; 157  : 	}
; 158  : 
; 159  : 	r = dklen - (l - 1) * SHA512_DIGESTSIZE;
; 160  : 
; 161  : 	/* first l - 1 blocks */
; 162  : 	for (b = 1; b < l; b++)

  0005b	44 8b a4 24 10
	01 00 00	 mov	 r12d, DWORD PTR iterations$[rsp]
  00063	bb 40 00 00 00	 mov	 ebx, 64			; 00000040H
  00068	8b c7		 mov	 eax, edi
  0006a	c1 e0 06	 shl	 eax, 6
  0006d	8d 6b c1	 lea	 ebp, QWORD PTR [rbx-63]
  00070	2b f0		 sub	 esi, eax
  00072	03 f3		 add	 esi, ebx
  00074	3b fd		 cmp	 edi, ebp
  00076	89 b4 24 20 01
	00 00		 mov	 DWORD PTR dklen$[rsp], esi
  0007d	7e 4e		 jle	 SHORT $LN6@derive_key@3
  0007f	49 8b f0	 mov	 rsi, r8
$LL8@derive_key@3:

; 163  : 	{
; 164  : 		derive_u_sha512 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  00082	48 8d 44 24 50	 lea	 rax, QWORD PTR u$[rsp]
  00087	89 6c 24 30	 mov	 DWORD PTR [rsp+48], ebp
  0008b	4c 8b c6	 mov	 r8, rsi
  0008e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00093	41 8b d7	 mov	 edx, r15d
  00096	49 8b ce	 mov	 rcx, r14
  00099	44 89 64 24 20	 mov	 DWORD PTR [rsp+32], r12d
  0009e	e8 00 00 00 00	 call	 derive_u_sha512

; 165  : 		memcpy (dk, u, SHA512_DIGESTSIZE);

  000a3	48 8d 54 24 50	 lea	 rdx, QWORD PTR u$[rsp]
  000a8	49 8b cd	 mov	 rcx, r13
  000ab	4c 8b c3	 mov	 r8, rbx
  000ae	e8 00 00 00 00	 call	 memcpy
  000b3	44 8b 4c 24 40	 mov	 r9d, DWORD PTR salt_len$GSCopy$1$[rsp]
  000b8	ff c5		 inc	 ebp

; 166  : 		dk += SHA512_DIGESTSIZE;

  000ba	4c 03 eb	 add	 r13, rbx
  000bd	3b ef		 cmp	 ebp, edi
  000bf	7c c1		 jl	 SHORT $LL8@derive_key@3
  000c1	8b b4 24 20 01
	00 00		 mov	 esi, DWORD PTR dklen$[rsp]
  000c8	4c 8b 44 24 48	 mov	 r8, QWORD PTR salt$GSCopy$1$[rsp]
$LN6@derive_key@3:

; 167  : 	}
; 168  : 
; 169  : 	/* last block */
; 170  : 	derive_u_sha512 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  000cd	48 8d 44 24 50	 lea	 rax, QWORD PTR u$[rsp]
  000d2	89 6c 24 30	 mov	 DWORD PTR [rsp+48], ebp
  000d6	41 8b d7	 mov	 edx, r15d
  000d9	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000de	49 8b ce	 mov	 rcx, r14
  000e1	44 89 64 24 20	 mov	 DWORD PTR [rsp+32], r12d
  000e6	e8 00 00 00 00	 call	 derive_u_sha512

; 171  : 	memcpy (dk, u, r);

  000eb	48 8d 54 24 50	 lea	 rdx, QWORD PTR u$[rsp]
  000f0	4c 63 c6	 movsxd	 r8, esi
  000f3	49 8b cd	 mov	 rcx, r13
  000f6	e8 00 00 00 00	 call	 memcpy

; 172  : 
; 173  : 
; 174  : 	/* Prevent possible leaks. */
; 175  : 	burn (u, sizeof(u));

  000fb	48 8d 7c 24 50	 lea	 rdi, QWORD PTR u$[rsp]
  00100	33 c0		 xor	 eax, eax
  00102	48 8b cb	 mov	 rcx, rbx
  00105	4c 8d 5c 24 50	 lea	 r11, QWORD PTR u$[rsp]
  0010a	f3 aa		 rep stosb
$LL2@derive_key@3:
  0010c	41 88 03	 mov	 BYTE PTR [r11], al
  0010f	49 ff c3	 inc	 r11
  00112	83 eb 01	 sub	 ebx, 1
  00115	75 f5		 jne	 SHORT $LL2@derive_key@3

; 176  : }

  00117	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0011f	48 33 cc	 xor	 rcx, rsp
  00122	e8 00 00 00 00	 call	 __security_check_cookie
  00127	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0012e	41 5f		 pop	 r15
  00130	41 5e		 pop	 r14
  00132	41 5d		 pop	 r13
  00134	41 5c		 pop	 r12
  00136	5f		 pop	 rdi
  00137	5e		 pop	 rsi
  00138	5d		 pop	 rbp
  00139	5b		 pop	 rbx
  0013a	c3		 ret	 0
derive_key_sha512 ENDP
PUBLIC	__$ArrayPad$
PUBLIC	derive_key_ripemd160
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$derive_key_ripemd160 DD imagerel $LN20
	DD	imagerel $LN20+326
	DD	imagerel $unwind$derive_key_ripemd160
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$derive_key_ripemd160 DD 092019H
	DD	0f00de211H
	DD	0d009e00bH
	DD	07005c007H
	DD	050036004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	068H
; Function compile flags: /Ogspy
; File c:\home\public\desktop\projects\ciphershed.build\src\common\pkcs5.c
xdata	ENDS
;	COMDAT derive_key_ripemd160
_TEXT	SEGMENT
salt_len$GSCopy$1$ = 64
salt$GSCopy$1$ = 72
u$ = 80
__$ArrayPad$ = 104
pwd$ = 192
pwd_len$ = 200
salt$ = 208
salt_len$ = 216
iterations$ = 224
dk$ = 232
dklen$ = 240
derive_key_ripemd160 PROC				; COMDAT

; 422  : {

$LN20:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 44 24 68	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 423  : 	char u[RIPEMD160_DIGESTSIZE];
; 424  : 	int b, l, r;
; 425  : 
; 426  : 	if (dklen % RIPEMD160_DIGESTSIZE)

  00020	8b b4 24 f0 00
	00 00		 mov	 esi, DWORD PTR dklen$[rsp]
  00027	4c 8b a4 24 e8
	00 00 00	 mov	 r12, QWORD PTR dk$[rsp]
  0002f	4c 8b f1	 mov	 r14, rcx
  00032	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00037	44 8b fa	 mov	 r15d, edx
  0003a	44 89 4c 24 40	 mov	 DWORD PTR salt_len$GSCopy$1$[rsp], r9d
  0003f	4c 89 44 24 48	 mov	 QWORD PTR salt$GSCopy$1$[rsp], r8
  00044	f7 ee		 imul	 esi
  00046	8b fa		 mov	 edi, edx
  00048	c1 ff 03	 sar	 edi, 3
  0004b	8b c7		 mov	 eax, edi
  0004d	c1 e8 1f	 shr	 eax, 31
  00050	03 f8		 add	 edi, eax
  00052	8d 0c bf	 lea	 ecx, DWORD PTR [rdi+rdi*4]
  00055	c1 e1 02	 shl	 ecx, 2
  00058	3b f1		 cmp	 esi, ecx
  0005a	74 02		 je	 SHORT $LN9@derive_key@4

; 427  : 	{
; 428  : 		l = 1 + dklen / RIPEMD160_DIGESTSIZE;

  0005c	ff c7		 inc	 edi
$LN9@derive_key@4:

; 429  : 	}
; 430  : 	else
; 431  : 	{
; 432  : 		l = dklen / RIPEMD160_DIGESTSIZE;
; 433  : 	}
; 434  : 
; 435  : 	r = dklen - (l - 1) * RIPEMD160_DIGESTSIZE;
; 436  : 
; 437  : 	/* first l - 1 blocks */
; 438  : 	for (b = 1; b < l; b++)

  0005e	44 8b ac 24 e0
	00 00 00	 mov	 r13d, DWORD PTR iterations$[rsp]
  00066	bb 14 00 00 00	 mov	 ebx, 20
  0006b	8d 04 bf	 lea	 eax, DWORD PTR [rdi+rdi*4]
  0006e	c1 e0 02	 shl	 eax, 2
  00071	8d 6b ed	 lea	 ebp, QWORD PTR [rbx-19]
  00074	2b f0		 sub	 esi, eax
  00076	03 f3		 add	 esi, ebx
  00078	3b fd		 cmp	 edi, ebp
  0007a	89 b4 24 f0 00
	00 00		 mov	 DWORD PTR dklen$[rsp], esi
  00081	7e 5b		 jle	 SHORT $LN6@derive_key@4
  00083	49 8b f0	 mov	 rsi, r8
$LL8@derive_key@4:

; 439  : 	{
; 440  : 		derive_u_ripemd160 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  00086	48 8d 44 24 50	 lea	 rax, QWORD PTR u$[rsp]
  0008b	89 6c 24 30	 mov	 DWORD PTR [rsp+48], ebp
  0008f	4c 8b c6	 mov	 r8, rsi
  00092	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00097	41 8b d7	 mov	 edx, r15d
  0009a	49 8b ce	 mov	 rcx, r14
  0009d	44 89 6c 24 20	 mov	 DWORD PTR [rsp+32], r13d
  000a2	e8 00 00 00 00	 call	 derive_u_ripemd160
  000a7	44 8b 4c 24 40	 mov	 r9d, DWORD PTR salt_len$GSCopy$1$[rsp]

; 441  : 		memcpy (dk, u, RIPEMD160_DIGESTSIZE);

  000ac	48 8d 4c 24 50	 lea	 rcx, QWORD PTR u$[rsp]
  000b1	ff c5		 inc	 ebp
  000b3	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  000b6	49 89 04 24	 mov	 QWORD PTR [r12], rax
  000ba	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  000be	49 89 44 24 08	 mov	 QWORD PTR [r12+8], rax
  000c3	8b 41 10	 mov	 eax, DWORD PTR [rcx+16]
  000c6	41 89 44 24 10	 mov	 DWORD PTR [r12+16], eax

; 442  : 		dk += RIPEMD160_DIGESTSIZE;

  000cb	4c 03 e3	 add	 r12, rbx
  000ce	3b ef		 cmp	 ebp, edi
  000d0	7c b4		 jl	 SHORT $LL8@derive_key@4
  000d2	8b b4 24 f0 00
	00 00		 mov	 esi, DWORD PTR dklen$[rsp]
  000d9	4c 8b 44 24 48	 mov	 r8, QWORD PTR salt$GSCopy$1$[rsp]
$LN6@derive_key@4:

; 443  : 	}
; 444  : 
; 445  : 	/* last block */
; 446  : 	derive_u_ripemd160 (pwd, pwd_len, salt, salt_len, iterations, u, b);

  000de	48 8d 44 24 50	 lea	 rax, QWORD PTR u$[rsp]
  000e3	89 6c 24 30	 mov	 DWORD PTR [rsp+48], ebp
  000e7	41 8b d7	 mov	 edx, r15d
  000ea	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000ef	49 8b ce	 mov	 rcx, r14
  000f2	44 89 6c 24 20	 mov	 DWORD PTR [rsp+32], r13d
  000f7	e8 00 00 00 00	 call	 derive_u_ripemd160

; 447  : 	memcpy (dk, u, r);

  000fc	48 8d 54 24 50	 lea	 rdx, QWORD PTR u$[rsp]
  00101	4c 63 c6	 movsxd	 r8, esi
  00104	49 8b cc	 mov	 rcx, r12
  00107	e8 00 00 00 00	 call	 memcpy

; 448  : 
; 449  : 
; 450  : 	/* Prevent possible leaks. */
; 451  : 	burn (u, sizeof(u));

  0010c	48 8d 7c 24 50	 lea	 rdi, QWORD PTR u$[rsp]
  00111	33 c0		 xor	 eax, eax
  00113	48 8b cb	 mov	 rcx, rbx
  00116	4c 8d 5c 24 50	 lea	 r11, QWORD PTR u$[rsp]
  0011b	f3 aa		 rep stosb
$LL2@derive_key@4:
  0011d	41 88 03	 mov	 BYTE PTR [r11], al
  00120	49 ff c3	 inc	 r11
  00123	83 eb 01	 sub	 ebx, 1
  00126	75 f5		 jne	 SHORT $LL2@derive_key@4

; 452  : }

  00128	48 8b 4c 24 68	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0012d	48 33 cc	 xor	 rcx, rsp
  00130	e8 00 00 00 00	 call	 __security_check_cookie
  00135	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00139	41 5f		 pop	 r15
  0013b	41 5e		 pop	 r14
  0013d	41 5d		 pop	 r13
  0013f	41 5c		 pop	 r12
  00141	5f		 pop	 rdi
  00142	5e		 pop	 rsi
  00143	5d		 pop	 rbp
  00144	5b		 pop	 rbx
  00145	c3		 ret	 0
derive_key_ripemd160 ENDP
END
