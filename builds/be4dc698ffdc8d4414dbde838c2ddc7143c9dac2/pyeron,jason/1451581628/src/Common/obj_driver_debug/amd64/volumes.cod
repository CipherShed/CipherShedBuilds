; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	ReadVolumeHeaderRecoveryMode
ReadVolumeHeaderRecoveryMode DD 01H DUP (?)
PUBLIC	GetHeaderField64
;	COMDAT pdata
; File c:\users\public\desktop\projects\ciphershed\src\common\volumes.c
pdata	SEGMENT
$pdata$GetHeaderField64 DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$GetHeaderField64
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetHeaderField64 DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GetHeaderField64
_TEXT	SEGMENT
uint64Struct$ = 32
header$ = 64
offset$ = 72
GetHeaderField64 PROC					; COMDAT

; 137  : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 138  : 	UINT64_STRUCT uint64Struct;
; 139  : 
; 140  : #ifndef TC_NO_COMPILER_INT64
; 141  : 	uint64Struct.Value = BE64 (*(uint64 *) (header + offset));

  0000d	48 63 44 24 48	 movsxd	 rax, DWORD PTR offset$[rsp]
  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR header$[rsp]
  00017	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0001b	e8 00 00 00 00	 call	 MirrorBytes64
  00020	48 89 44 24 20	 mov	 QWORD PTR uint64Struct$[rsp], rax

; 142  : #else
; 143  : 	uint64Struct.HighPart = BE32 (*(uint32 *) (header + offset));
; 144  : 	uint64Struct.LowPart = BE32 (*(uint32 *) (header + offset + 4));
; 145  : #endif
; 146  : 	return uint64Struct;

  00025	48 8b 44 24 20	 mov	 rax, QWORD PTR uint64Struct$[rsp]

; 147  : }

  0002a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002e	c3		 ret	 0
GetHeaderField64 ENDP
_TEXT	ENDS
PUBLIC	GetHeaderField32
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetHeaderField32 DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$GetHeaderField32
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetHeaderField32 DD 010d01H
	DD	0420dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GetHeaderField32
_TEXT	SEGMENT
header$ = 48
offset$ = 56
GetHeaderField32 PROC					; COMDAT

; 131  : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 132  : 	return BE32 (*(uint32 *) (header + offset));

  0000d	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR offset$[rsp]
  00012	48 8b 44 24 30	 mov	 rax, QWORD PTR header$[rsp]
  00017	8b 0c 08	 mov	 ecx, DWORD PTR [rax+rcx]
  0001a	e8 00 00 00 00	 call	 MirrorBytes32

; 133  : }

  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	c3		 ret	 0
GetHeaderField32 ENDP
_TEXT	ENDS
PUBLIC	GetHeaderField16
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetHeaderField16 DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$GetHeaderField16
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetHeaderField16 DD 010d01H
	DD	0420dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GetHeaderField16
_TEXT	SEGMENT
header$ = 48
offset$ = 56
GetHeaderField16 PROC					; COMDAT

; 125  : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 126  : 	return BE16 (*(uint16 *) (header + offset));

  0000d	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR offset$[rsp]
  00012	48 8b 44 24 30	 mov	 rax, QWORD PTR header$[rsp]
  00017	0f b7 0c 08	 movzx	 ecx, WORD PTR [rax+rcx]
  0001b	e8 00 00 00 00	 call	 MirrorBytes16

; 127  : }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
GetHeaderField16 ENDP
PUBLIC	__$ArrayPad$
PUBLIC	ReadVolumeHeader
;	COMDAT pdata
pdata	SEGMENT
$pdata$ReadVolumeHeader DD imagerel $LN99
	DD	imagerel $LN99+4021
	DD	imagerel $unwind$ReadVolumeHeader
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ReadVolumeHeader DD 052f19H
	DD	0bc011dH
	DD	060157016H
	DD	03014H
	DD	imagerel __GSHandlerCheck
	DD	05d8H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ReadVolumeHeader
_TEXT	SEGMENT
cryptoInfo$ = 80
dk$ = 96
i$ = 352
noOutstandingWorkItemEvent$ = 360
headerVersion$ = 384
encryptionThreadCount$ = 392
primaryKeyOffset$ = 400
keyDerivationCompletedEvent$ = 408
keyInfo$ = 432
keyDerivationWorkItems$ = 832
outstandingWorkItemCount$ = 840
queuedWorkItems$ = 848
enqPkcs5Prf$ = 856
status$ = 860
pkcs5PrfCount$ = 864
pkcs5_prf$ = 868
item$ = 872
header$ = 880
lrw128InitDone$29742 = 1392
lrw64InitDone$29741 = 1396
blockSize$29784 = 1400
burnc$29828 = 1404
burnm$29826 = 1408
burnc$29837 = 1416
burnm$29835 = 1424
burnc$29848 = 1432
burnm$29846 = 1440
$T45831 = 1448
$T45832 = 1456
$T45833 = 1464
tv199 = 1472
tv249 = 1476
tv381 = 1480
tv410 = 1484
tv487 = 1488
__$ArrayPad$ = 1496
bBoot$ = 1536
encryptedHeader$ = 1544
password$ = 1552
retInfo$ = 1560
retHeaderCryptoInfo$ = 1568
ReadVolumeHeader PROC					; COMDAT

; 164  : {

$LN99:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	53		 push	 rbx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec e0 05
	00 00		 sub	 rsp, 1504		; 000005e0H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 d8
	05 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 165  : 	char header[TC_VOLUME_HEADER_EFFECTIVE_SIZE];
; 166  : 	KEY_INFO keyInfo;
; 167  : 	PCRYPTO_INFO cryptoInfo;
; 168  : 	char dk[MASTER_KEYDATA_SIZE];
; 169  : 	int enqPkcs5Prf, pkcs5_prf;
; 170  : 	uint16 headerVersion;
; 171  : 	int status = ERR_PARAMETER_INCORRECT;

  0002f	c7 84 24 5c 03
	00 00 1e 00 00
	00		 mov	 DWORD PTR status$[rsp], 30

; 172  : 	int primaryKeyOffset;
; 173  : 
; 174  : 	TC_EVENT keyDerivationCompletedEvent;
; 175  : 	TC_EVENT noOutstandingWorkItemEvent;
; 176  : 	KeyDerivationWorkItem *keyDerivationWorkItems;
; 177  : 	KeyDerivationWorkItem *item;
; 178  : 	int pkcs5PrfCount = LAST_PRF_ID - FIRST_PRF_ID + 1;

  0003a	c7 84 24 60 03
	00 00 04 00 00
	00		 mov	 DWORD PTR pkcs5PrfCount$[rsp], 4

; 179  : 	size_t encryptionThreadCount = GetEncryptionThreadCount();

  00045	e8 00 00 00 00	 call	 GetEncryptionThreadCount
  0004a	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR encryptionThreadCount$[rsp], rax

; 180  : 	size_t queuedWorkItems = 0;

  00052	48 c7 84 24 50
	03 00 00 00 00
	00 00		 mov	 QWORD PTR queuedWorkItems$[rsp], 0

; 181  : 	LONG outstandingWorkItemCount = 0;

  0005e	c7 84 24 48 03
	00 00 00 00 00
	00		 mov	 DWORD PTR outstandingWorkItemCount$[rsp], 0

; 182  : 	int i;
; 183  : 
; 184  : 	if (retHeaderCryptoInfo != NULL)

  00069	48 83 bc 24 20
	06 00 00 00	 cmp	 QWORD PTR retHeaderCryptoInfo$[rsp], 0
  00072	74 0f		 je	 SHORT $LN92@ReadVolume

; 185  : 	{
; 186  : 		cryptoInfo = retHeaderCryptoInfo;

  00074	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR retHeaderCryptoInfo$[rsp]
  0007c	48 89 44 24 50	 mov	 QWORD PTR cryptoInfo$[rsp], rax

; 187  : 	}
; 188  : 	else

  00081	eb 35		 jmp	 SHORT $LN91@ReadVolume
$LN92@ReadVolume:

; 189  : 	{
; 190  : 		cryptoInfo = *retInfo = crypto_open ();

  00083	e8 00 00 00 00	 call	 crypto_open
  00088	48 8b d0	 mov	 rdx, rax
  0008b	48 8b 84 24 18
	06 00 00	 mov	 rax, QWORD PTR retInfo$[rsp]
  00093	48 89 10	 mov	 QWORD PTR [rax], rdx
  00096	48 8b 84 24 18
	06 00 00	 mov	 rax, QWORD PTR retInfo$[rsp]
  0009e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a1	48 89 44 24 50	 mov	 QWORD PTR cryptoInfo$[rsp], rax

; 191  : 		if (cryptoInfo == NULL)

  000a6	48 83 7c 24 50
	00		 cmp	 QWORD PTR cryptoInfo$[rsp], 0
  000ac	75 0a		 jne	 SHORT $LN90@ReadVolume

; 192  : 			return ERR_OUTOFMEMORY;

  000ae	b8 02 00 00 00	 mov	 eax, 2
  000b3	e9 e2 0e 00 00	 jmp	 $LN93@ReadVolume
$LN90@ReadVolume:
$LN91@ReadVolume:

; 193  : 	}
; 194  : 
; 195  : 	if (encryptionThreadCount > 1)

  000b8	48 83 bc 24 88
	01 00 00 01	 cmp	 QWORD PTR encryptionThreadCount$[rsp], 1
  000c1	0f 86 b8 00 00
	00		 jbe	 $LN89@ReadVolume

; 196  : 	{
; 197  : 		keyDerivationWorkItems = TCalloc (sizeof (KeyDerivationWorkItem) * pkcs5PrfCount);

  000c7	48 63 94 24 60
	03 00 00	 movsxd	 rdx, DWORD PTR pkcs5PrfCount$[rsp]
  000cf	48 69 d2 0c 01
	00 00		 imul	 rdx, 268		; 0000010cH
  000d6	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  000dc	33 c9		 xor	 ecx, ecx
  000de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  000e4	48 89 84 24 40
	03 00 00	 mov	 QWORD PTR keyDerivationWorkItems$[rsp], rax

; 198  : 		if (!keyDerivationWorkItems)

  000ec	48 83 bc 24 40
	03 00 00 00	 cmp	 QWORD PTR keyDerivationWorkItems$[rsp], 0
  000f5	75 0a		 jne	 SHORT $LN88@ReadVolume

; 199  : 			return ERR_OUTOFMEMORY;

  000f7	b8 02 00 00 00	 mov	 eax, 2
  000fc	e9 99 0e 00 00	 jmp	 $LN93@ReadVolume
$LN88@ReadVolume:

; 200  : 
; 201  : 		for (i = 0; i < pkcs5PrfCount; ++i)

  00101	c7 84 24 60 01
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  0010c	eb 11		 jmp	 SHORT $LN87@ReadVolume
$LN86@ReadVolume:
  0010e	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00115	83 c0 01	 add	 eax, 1
  00118	89 84 24 60 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN87@ReadVolume:
  0011f	8b 84 24 60 03
	00 00		 mov	 eax, DWORD PTR pkcs5PrfCount$[rsp]
  00126	39 84 24 60 01
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  0012d	7d 24		 jge	 SHORT $LN85@ReadVolume

; 202  : 			keyDerivationWorkItems[i].Free = TRUE;

  0012f	48 63 8c 24 60
	01 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  00137	48 69 c9 0c 01
	00 00		 imul	 rcx, 268		; 0000010cH
  0013e	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR keyDerivationWorkItems$[rsp]
  00146	c7 84 08 00 01
	00 00 01 00 00
	00		 mov	 DWORD PTR [rax+rcx+256], 1
  00151	eb bb		 jmp	 SHORT $LN86@ReadVolume
$LN85@ReadVolume:

; 203  : 
; 204  : #ifdef DEVICE_DRIVER
; 205  : 		KeInitializeEvent (&keyDerivationCompletedEvent, SynchronizationEvent, FALSE);

  00153	45 33 c0	 xor	 r8d, r8d
  00156	ba 01 00 00 00	 mov	 edx, 1
  0015b	48 8d 8c 24 98
	01 00 00	 lea	 rcx, QWORD PTR keyDerivationCompletedEvent$[rsp]
  00163	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 206  : 		KeInitializeEvent (&noOutstandingWorkItemEvent, SynchronizationEvent, TRUE);

  00169	41 b0 01	 mov	 r8b, 1
  0016c	ba 01 00 00 00	 mov	 edx, 1
  00171	48 8d 8c 24 68
	01 00 00	 lea	 rcx, QWORD PTR noOutstandingWorkItemEvent$[rsp]
  00179	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent
$LN89@ReadVolume:

; 207  : #else
; 208  : 		keyDerivationCompletedEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
; 209  : 		if (!keyDerivationCompletedEvent)
; 210  : 		{
; 211  : 			TCfree (keyDerivationWorkItems);
; 212  : 			return ERR_OUTOFMEMORY;
; 213  : 		}
; 214  : 
; 215  : 		noOutstandingWorkItemEvent = CreateEvent (NULL, FALSE, TRUE, NULL);
; 216  : 		if (!noOutstandingWorkItemEvent)
; 217  : 		{
; 218  : 			CloseHandle (keyDerivationCompletedEvent);
; 219  : 			TCfree (keyDerivationWorkItems);
; 220  : 			return ERR_OUTOFMEMORY;
; 221  : 		}
; 222  : #endif
; 223  : 	}
; 224  : 		
; 225  : #ifndef DEVICE_DRIVER
; 226  : 	VirtualLock (&keyInfo, sizeof (keyInfo));
; 227  : 	VirtualLock (&dk, sizeof (dk));
; 228  : #endif
; 229  : 
; 230  : 	crypto_loadkey (&keyInfo, password->Text, (int) password->Length);

  0017f	48 8b 94 24 10
	06 00 00	 mov	 rdx, QWORD PTR password$[rsp]
  00187	48 83 c2 04	 add	 rdx, 4
  0018b	48 8b 84 24 10
	06 00 00	 mov	 rax, QWORD PTR password$[rsp]
  00193	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  00196	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR keyInfo$[rsp]
  0019e	e8 00 00 00 00	 call	 crypto_loadkey

; 231  : 
; 232  : 	// PKCS5 is used to derive the primary header key(s) and secondary header key(s) (XTS mode) from the password
; 233  : 	memcpy (keyInfo.salt, encryptedHeader + HEADER_SALT_OFFSET, PKCS5_SALT_SIZE);

  001a3	48 8d bc 24 f8
	01 00 00	 lea	 rdi, QWORD PTR keyInfo$[rsp+72]
  001ab	48 8b b4 24 08
	06 00 00	 mov	 rsi, QWORD PTR encryptedHeader$[rsp]
  001b3	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  001b8	f3 a4		 rep movsb

; 234  : 
; 235  : 	// Test all available PKCS5 PRFs
; 236  : 	for (enqPkcs5Prf = FIRST_PRF_ID; enqPkcs5Prf <= LAST_PRF_ID || queuedWorkItems > 0; ++enqPkcs5Prf)

  001ba	c7 84 24 58 03
	00 00 01 00 00
	00		 mov	 DWORD PTR enqPkcs5Prf$[rsp], 1
  001c5	eb 11		 jmp	 SHORT $LN84@ReadVolume
$LN83@ReadVolume:
  001c7	8b 84 24 58 03
	00 00		 mov	 eax, DWORD PTR enqPkcs5Prf$[rsp]
  001ce	83 c0 01	 add	 eax, 1
  001d1	89 84 24 58 03
	00 00		 mov	 DWORD PTR enqPkcs5Prf$[rsp], eax
$LN84@ReadVolume:
  001d8	83 bc 24 58 03
	00 00 04	 cmp	 DWORD PTR enqPkcs5Prf$[rsp], 4
  001e0	7e 0f		 jle	 SHORT $LN81@ReadVolume
  001e2	48 83 bc 24 50
	03 00 00 00	 cmp	 QWORD PTR queuedWorkItems$[rsp], 0
  001eb	0f 86 cb 0b 00
	00		 jbe	 $LN82@ReadVolume
$LN81@ReadVolume:

; 237  : 	{
; 238  : 		BOOL lrw64InitDone = FALSE;		// Deprecated/legacy

  001f1	c7 84 24 74 05
	00 00 00 00 00
	00		 mov	 DWORD PTR lrw64InitDone$29741[rsp], 0

; 239  : 		BOOL lrw128InitDone = FALSE;	// Deprecated/legacy

  001fc	c7 84 24 70 05
	00 00 00 00 00
	00		 mov	 DWORD PTR lrw128InitDone$29742[rsp], 0

; 240  : 
; 241  : 		if (encryptionThreadCount > 1)

  00207	48 83 bc 24 88
	01 00 00 01	 cmp	 QWORD PTR encryptionThreadCount$[rsp], 1
  00210	0f 86 c1 02 00
	00		 jbe	 $LN80@ReadVolume

; 242  : 		{
; 243  : 			// Enqueue key derivation on thread pool
; 244  : 			if (queuedWorkItems < encryptionThreadCount && enqPkcs5Prf <= LAST_PRF_ID)

  00216	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR encryptionThreadCount$[rsp]
  0021e	48 39 84 24 50
	03 00 00	 cmp	 QWORD PTR queuedWorkItems$[rsp], rax
  00226	0f 83 5e 01 00
	00		 jae	 $LN79@ReadVolume
  0022c	83 bc 24 58 03
	00 00 04	 cmp	 DWORD PTR enqPkcs5Prf$[rsp], 4
  00234	0f 8f 50 01 00
	00		 jg	 $LN79@ReadVolume

; 245  : 			{
; 246  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  0023a	c7 84 24 60 01
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  00245	eb 11		 jmp	 SHORT $LN78@ReadVolume
$LN77@ReadVolume:
  00247	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0024e	83 c0 01	 add	 eax, 1
  00251	89 84 24 60 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN78@ReadVolume:
  00258	8b 84 24 60 03
	00 00		 mov	 eax, DWORD PTR pkcs5PrfCount$[rsp]
  0025f	39 84 24 60 01
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  00266	0f 8d 0d 01 00
	00		 jge	 $LN76@ReadVolume

; 247  : 				{
; 248  : 					item = &keyDerivationWorkItems[i];

  0026c	48 63 8c 24 60
	01 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  00274	48 69 c9 0c 01
	00 00		 imul	 rcx, 268		; 0000010cH
  0027b	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR keyDerivationWorkItems$[rsp]
  00283	48 03 c1	 add	 rax, rcx
  00286	48 89 84 24 68
	03 00 00	 mov	 QWORD PTR item$[rsp], rax

; 249  : 					if (item->Free)

  0028e	48 8b 84 24 68
	03 00 00	 mov	 rax, QWORD PTR item$[rsp]
  00296	83 b8 00 01 00
	00 00		 cmp	 DWORD PTR [rax+256], 0
  0029d	0f 84 d1 00 00
	00		 je	 $LN75@ReadVolume

; 250  : 					{
; 251  : 						item->Free = FALSE;

  002a3	48 8b 84 24 68
	03 00 00	 mov	 rax, QWORD PTR item$[rsp]
  002ab	c7 80 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+256], 0

; 252  : 						item->KeyReady = FALSE;

  002b5	48 8b 84 24 68
	03 00 00	 mov	 rax, QWORD PTR item$[rsp]
  002bd	c7 80 04 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+260], 0

; 253  : 						item->Pkcs5Prf = enqPkcs5Prf;

  002c7	48 8b 8c 24 68
	03 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  002cf	8b 84 24 58 03
	00 00		 mov	 eax, DWORD PTR enqPkcs5Prf$[rsp]
  002d6	89 81 08 01 00
	00		 mov	 DWORD PTR [rcx+264], eax

; 254  : 
; 255  : 						EncryptionThreadPoolBeginKeyDerivation (&keyDerivationCompletedEvent, &noOutstandingWorkItemEvent,
; 256  : 							&item->KeyReady, &outstandingWorkItemCount, enqPkcs5Prf, keyInfo.userKey,
; 257  : 							keyInfo.keyLength, keyInfo.salt, get_pkcs5_iteration_count (enqPkcs5Prf, bBoot), item->DerivedKey);

  002dc	8b 94 24 00 06
	00 00		 mov	 edx, DWORD PTR bBoot$[rsp]
  002e3	8b 8c 24 58 03
	00 00		 mov	 ecx, DWORD PTR enqPkcs5Prf$[rsp]
  002ea	e8 00 00 00 00	 call	 get_pkcs5_iteration_count
  002ef	8b d0		 mov	 edx, eax
  002f1	4c 8b 84 24 68
	03 00 00	 mov	 r8, QWORD PTR item$[rsp]
  002f9	49 81 c0 04 01
	00 00		 add	 r8, 260			; 00000104H
  00300	48 8b 84 24 68
	03 00 00	 mov	 rax, QWORD PTR item$[rsp]
  00308	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0030d	89 54 24 40	 mov	 DWORD PTR [rsp+64], edx
  00311	48 8d 84 24 f8
	01 00 00	 lea	 rax, QWORD PTR keyInfo$[rsp+72]
  00319	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0031e	8b 84 24 b4 01
	00 00		 mov	 eax, DWORD PTR keyInfo$[rsp+4]
  00325	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00329	48 8d 84 24 b8
	01 00 00	 lea	 rax, QWORD PTR keyInfo$[rsp+8]
  00331	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00336	8b 84 24 58 03
	00 00		 mov	 eax, DWORD PTR enqPkcs5Prf$[rsp]
  0033d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00341	4c 8d 8c 24 48
	03 00 00	 lea	 r9, QWORD PTR outstandingWorkItemCount$[rsp]
  00349	48 8d 94 24 68
	01 00 00	 lea	 rdx, QWORD PTR noOutstandingWorkItemEvent$[rsp]
  00351	48 8d 8c 24 98
	01 00 00	 lea	 rcx, QWORD PTR keyDerivationCompletedEvent$[rsp]
  00359	e8 00 00 00 00	 call	 EncryptionThreadPoolBeginKeyDerivation

; 258  : 						
; 259  : 						++queuedWorkItems;

  0035e	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR queuedWorkItems$[rsp]
  00366	48 83 c0 01	 add	 rax, 1
  0036a	48 89 84 24 50
	03 00 00	 mov	 QWORD PTR queuedWorkItems$[rsp], rax

; 260  : 						break;

  00372	eb 05		 jmp	 SHORT $LN76@ReadVolume
$LN75@ReadVolume:

; 261  : 					}
; 262  : 				}

  00374	e9 ce fe ff ff	 jmp	 $LN77@ReadVolume
$LN76@ReadVolume:

; 263  : 
; 264  : 				if (enqPkcs5Prf < LAST_PRF_ID)

  00379	83 bc 24 58 03
	00 00 04	 cmp	 DWORD PTR enqPkcs5Prf$[rsp], 4
  00381	7d 05		 jge	 SHORT $LN74@ReadVolume

; 265  : 					continue;

  00383	e9 3f fe ff ff	 jmp	 $LN83@ReadVolume
$LN74@ReadVolume:

; 266  : 			}
; 267  : 			else

  00388	eb 11		 jmp	 SHORT $LN73@ReadVolume
$LN79@ReadVolume:

; 268  : 				--enqPkcs5Prf;

  0038a	8b 84 24 58 03
	00 00		 mov	 eax, DWORD PTR enqPkcs5Prf$[rsp]
  00391	83 e8 01	 sub	 eax, 1
  00394	89 84 24 58 03
	00 00		 mov	 DWORD PTR enqPkcs5Prf$[rsp], eax
$LN73@ReadVolume:
$LN72@ReadVolume:

; 269  : 
; 270  : 			// Wait for completion of a key derivation
; 271  : 			while (queuedWorkItems > 0)

  0039b	48 83 bc 24 50
	03 00 00 00	 cmp	 QWORD PTR queuedWorkItems$[rsp], 0
  003a4	0f 86 23 01 00
	00		 jbe	 $LN71@ReadVolume

; 272  : 			{
; 273  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  003aa	c7 84 24 60 01
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  003b5	eb 11		 jmp	 SHORT $LN70@ReadVolume
$LN69@ReadVolume:
  003b7	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  003be	83 c0 01	 add	 eax, 1
  003c1	89 84 24 60 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN70@ReadVolume:
  003c8	8b 84 24 60 03
	00 00		 mov	 eax, DWORD PTR pkcs5PrfCount$[rsp]
  003cf	39 84 24 60 01
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  003d6	0f 8d c2 00 00
	00		 jge	 $LN68@ReadVolume

; 274  : 				{
; 275  : 					item = &keyDerivationWorkItems[i];

  003dc	48 63 8c 24 60
	01 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  003e4	48 69 c9 0c 01
	00 00		 imul	 rcx, 268		; 0000010cH
  003eb	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR keyDerivationWorkItems$[rsp]
  003f3	48 03 c1	 add	 rax, rcx
  003f6	48 89 84 24 68
	03 00 00	 mov	 QWORD PTR item$[rsp], rax

; 276  : 					if (!item->Free && InterlockedExchangeAdd (&item->KeyReady, 0) == TRUE)

  003fe	48 8b 84 24 68
	03 00 00	 mov	 rax, QWORD PTR item$[rsp]
  00406	83 b8 00 01 00
	00 00		 cmp	 DWORD PTR [rax+256], 0
  0040d	0f 85 86 00 00
	00		 jne	 $LN67@ReadVolume
  00413	48 8b 84 24 68
	03 00 00	 mov	 rax, QWORD PTR item$[rsp]
  0041b	48 05 04 01 00
	00		 add	 rax, 260		; 00000104H
  00421	33 c9		 xor	 ecx, ecx
  00423	f0 0f c1 08	 lock xadd DWORD PTR [rax], ecx
  00427	8b c1		 mov	 eax, ecx
  00429	83 f8 01	 cmp	 eax, 1
  0042c	75 6b		 jne	 SHORT $LN67@ReadVolume

; 277  : 					{
; 278  : 						pkcs5_prf = item->Pkcs5Prf;

  0042e	48 8b 84 24 68
	03 00 00	 mov	 rax, QWORD PTR item$[rsp]
  00436	8b 80 08 01 00
	00		 mov	 eax, DWORD PTR [rax+264]
  0043c	89 84 24 64 03
	00 00		 mov	 DWORD PTR pkcs5_prf$[rsp], eax

; 279  : 						keyInfo.noIterations = get_pkcs5_iteration_count (pkcs5_prf, bBoot);

  00443	8b 94 24 00 06
	00 00		 mov	 edx, DWORD PTR bBoot$[rsp]
  0044a	8b 8c 24 64 03
	00 00		 mov	 ecx, DWORD PTR pkcs5_prf$[rsp]
  00451	e8 00 00 00 00	 call	 get_pkcs5_iteration_count
  00456	89 84 24 b0 01
	00 00		 mov	 DWORD PTR keyInfo$[rsp], eax

; 280  : 						memcpy (dk, item->DerivedKey, sizeof (dk));

  0045d	48 8d 7c 24 60	 lea	 rdi, QWORD PTR dk$[rsp]
  00462	48 8b b4 24 68
	03 00 00	 mov	 rsi, QWORD PTR item$[rsp]
  0046a	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0046f	f3 a4		 rep movsb

; 281  : 
; 282  : 						item->Free = TRUE;

  00471	48 8b 84 24 68
	03 00 00	 mov	 rax, QWORD PTR item$[rsp]
  00479	c7 80 00 01 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+256], 1

; 283  : 						--queuedWorkItems;

  00483	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR queuedWorkItems$[rsp]
  0048b	48 83 e8 01	 sub	 rax, 1
  0048f	48 89 84 24 50
	03 00 00	 mov	 QWORD PTR queuedWorkItems$[rsp], rax

; 284  : 						goto KeyReady;

  00497	eb 39		 jmp	 SHORT $KeyReady$29758
$LN67@ReadVolume:

; 285  : 					}
; 286  : 				}

  00499	e9 19 ff ff ff	 jmp	 $LN69@ReadVolume
$LN68@ReadVolume:

; 287  : 
; 288  : 				if (queuedWorkItems > 0)

  0049e	48 83 bc 24 50
	03 00 00 00	 cmp	 QWORD PTR queuedWorkItems$[rsp], 0
  004a7	76 1f		 jbe	 SHORT $LN66@ReadVolume

; 289  : 					TC_WAIT_EVENT (keyDerivationCompletedEvent);

  004a9	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  004b2	45 33 c9	 xor	 r9d, r9d
  004b5	45 33 c0	 xor	 r8d, r8d
  004b8	33 d2		 xor	 edx, edx
  004ba	48 8d 8c 24 98
	01 00 00	 lea	 rcx, QWORD PTR keyDerivationCompletedEvent$[rsp]
  004c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
$LN66@ReadVolume:

; 290  : 			}

  004c8	e9 ce fe ff ff	 jmp	 $LN72@ReadVolume
$LN71@ReadVolume:

; 291  : 			continue;

  004cd	e9 f5 fc ff ff	 jmp	 $LN83@ReadVolume
$KeyReady$29758:

; 292  : KeyReady:	;
; 293  : 		}
; 294  : 		else

  004d2	e9 98 01 00 00	 jmp	 $LN65@ReadVolume
$LN80@ReadVolume:

; 295  : 		{
; 296  : 			pkcs5_prf = enqPkcs5Prf;

  004d7	8b 84 24 58 03
	00 00		 mov	 eax, DWORD PTR enqPkcs5Prf$[rsp]
  004de	89 84 24 64 03
	00 00		 mov	 DWORD PTR pkcs5_prf$[rsp], eax

; 297  : 			keyInfo.noIterations = get_pkcs5_iteration_count (enqPkcs5Prf, bBoot);

  004e5	8b 94 24 00 06
	00 00		 mov	 edx, DWORD PTR bBoot$[rsp]
  004ec	8b 8c 24 58 03
	00 00		 mov	 ecx, DWORD PTR enqPkcs5Prf$[rsp]
  004f3	e8 00 00 00 00	 call	 get_pkcs5_iteration_count
  004f8	89 84 24 b0 01
	00 00		 mov	 DWORD PTR keyInfo$[rsp], eax

; 298  : 
; 299  : 			switch (pkcs5_prf)

  004ff	8b 84 24 64 03
	00 00		 mov	 eax, DWORD PTR pkcs5_prf$[rsp]
  00506	89 84 24 c0 05
	00 00		 mov	 DWORD PTR tv199[rsp], eax
  0050d	83 bc 24 c0 05
	00 00 01	 cmp	 DWORD PTR tv199[rsp], 1
  00515	74 2b		 je	 SHORT $LN62@ReadVolume
  00517	83 bc 24 c0 05
	00 00 02	 cmp	 DWORD PTR tv199[rsp], 2
  0051f	74 66		 je	 SHORT $LN61@ReadVolume
  00521	83 bc 24 c0 05
	00 00 03	 cmp	 DWORD PTR tv199[rsp], 3
  00529	0f 84 df 00 00
	00		 je	 $LN59@ReadVolume
  0052f	83 bc 24 c0 05
	00 00 04	 cmp	 DWORD PTR tv199[rsp], 4
  00537	0f 84 8f 00 00
	00		 je	 $LN60@ReadVolume
  0053d	e9 0e 01 00 00	 jmp	 $LN58@ReadVolume
$LN62@ReadVolume:

; 300  : 			{
; 301  : 			case RIPEMD160:
; 302  : 				derive_key_ripemd160 (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 303  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  00542	e8 00 00 00 00	 call	 GetMaxPkcs5OutSize
  00547	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0054b	48 8d 44 24 60	 lea	 rax, QWORD PTR dk$[rsp]
  00550	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00555	8b 84 24 b0 01
	00 00		 mov	 eax, DWORD PTR keyInfo$[rsp]
  0055c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00560	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  00566	4c 8d 84 24 f8
	01 00 00	 lea	 r8, QWORD PTR keyInfo$[rsp+72]
  0056e	8b 94 24 b4 01
	00 00		 mov	 edx, DWORD PTR keyInfo$[rsp+4]
  00575	48 8d 8c 24 b8
	01 00 00	 lea	 rcx, QWORD PTR keyInfo$[rsp+8]
  0057d	e8 00 00 00 00	 call	 derive_key_ripemd160

; 304  : 				break;

  00582	e9 e8 00 00 00	 jmp	 $LN63@ReadVolume
$LN61@ReadVolume:

; 305  : 
; 306  : 			case SHA512:
; 307  : 				derive_key_sha512 (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 308  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  00587	e8 00 00 00 00	 call	 GetMaxPkcs5OutSize
  0058c	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00590	48 8d 44 24 60	 lea	 rax, QWORD PTR dk$[rsp]
  00595	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0059a	8b 84 24 b0 01
	00 00		 mov	 eax, DWORD PTR keyInfo$[rsp]
  005a1	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  005a5	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  005ab	4c 8d 84 24 f8
	01 00 00	 lea	 r8, QWORD PTR keyInfo$[rsp+72]
  005b3	8b 94 24 b4 01
	00 00		 mov	 edx, DWORD PTR keyInfo$[rsp+4]
  005ba	48 8d 8c 24 b8
	01 00 00	 lea	 rcx, QWORD PTR keyInfo$[rsp+8]
  005c2	e8 00 00 00 00	 call	 derive_key_sha512

; 309  : 				break;

  005c7	e9 a3 00 00 00	 jmp	 $LN63@ReadVolume
$LN60@ReadVolume:

; 310  : 
; 311  : 			case SHA1:
; 312  : 				// Deprecated/legacy
; 313  : 				derive_key_sha1 (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 314  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  005cc	e8 00 00 00 00	 call	 GetMaxPkcs5OutSize
  005d1	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  005d5	48 8d 44 24 60	 lea	 rax, QWORD PTR dk$[rsp]
  005da	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  005df	8b 84 24 b0 01
	00 00		 mov	 eax, DWORD PTR keyInfo$[rsp]
  005e6	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  005ea	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  005f0	4c 8d 84 24 f8
	01 00 00	 lea	 r8, QWORD PTR keyInfo$[rsp+72]
  005f8	8b 94 24 b4 01
	00 00		 mov	 edx, DWORD PTR keyInfo$[rsp+4]
  005ff	48 8d 8c 24 b8
	01 00 00	 lea	 rcx, QWORD PTR keyInfo$[rsp+8]
  00607	e8 00 00 00 00	 call	 derive_key_sha1

; 315  : 				break;

  0060c	eb 61		 jmp	 SHORT $LN63@ReadVolume
$LN59@ReadVolume:

; 316  : 
; 317  : 			case WHIRLPOOL:
; 318  : 				derive_key_whirlpool (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 319  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  0060e	e8 00 00 00 00	 call	 GetMaxPkcs5OutSize
  00613	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00617	48 8d 44 24 60	 lea	 rax, QWORD PTR dk$[rsp]
  0061c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00621	8b 84 24 b0 01
	00 00		 mov	 eax, DWORD PTR keyInfo$[rsp]
  00628	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0062c	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  00632	4c 8d 84 24 f8
	01 00 00	 lea	 r8, QWORD PTR keyInfo$[rsp+72]
  0063a	8b 94 24 b4 01
	00 00		 mov	 edx, DWORD PTR keyInfo$[rsp+4]
  00641	48 8d 8c 24 b8
	01 00 00	 lea	 rcx, QWORD PTR keyInfo$[rsp+8]
  00649	e8 00 00 00 00	 call	 derive_key_whirlpool

; 320  : 				break;

  0064e	eb 1f		 jmp	 SHORT $LN63@ReadVolume
$LN58@ReadVolume:

; 321  : 
; 322  : 			default:		
; 323  : 				// Unknown/wrong ID
; 324  : 				TC_THROW_FATAL_EXCEPTION;

  00650	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00659	45 33 c9	 xor	 r9d, r9d
  0065c	45 33 c0	 xor	 r8d, r8d
  0065f	ba 44 01 00 00	 mov	 edx, 324		; 00000144H
  00664	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  00669	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN63@ReadVolume:
$LN65@ReadVolume:

; 325  : 			} 
; 326  : 		}
; 327  : 
; 328  : 		// Test all available modes of operation
; 329  : 		for (cryptoInfo->mode = FIRST_MODE_OF_OPERATION_ID;
; 330  : 			cryptoInfo->mode <= LAST_MODE_OF_OPERATION;
; 331  : 			cryptoInfo->mode++)

  0066f	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00674	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [rax+4], 1
  0067b	eb 13		 jmp	 SHORT $LN57@ReadVolume
$LN56@ReadVolume:
  0067d	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00682	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  00685	83 c1 01	 add	 ecx, 1
  00688	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  0068d	89 48 04	 mov	 DWORD PTR [rax+4], ecx
$LN57@ReadVolume:
  00690	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00695	83 78 04 05	 cmp	 DWORD PTR [rax+4], 5
  00699	0f 8f 18 07 00
	00		 jg	 $LN55@ReadVolume

; 332  : 		{
; 333  : 			switch (cryptoInfo->mode)

  0069f	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  006a4	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  006a7	89 84 24 c4 05
	00 00		 mov	 DWORD PTR tv249[rsp], eax
  006ae	83 bc 24 c4 05
	00 00 02	 cmp	 DWORD PTR tv249[rsp], 2
  006b6	7c 31		 jl	 SHORT $LN51@ReadVolume
  006b8	83 bc 24 c4 05
	00 00 05	 cmp	 DWORD PTR tv249[rsp], 5
  006c0	7e 02		 jle	 SHORT $LN52@ReadVolume
  006c2	eb 25		 jmp	 SHORT $LN51@ReadVolume
$LN52@ReadVolume:

; 334  : 			{
; 335  : 			case LRW:
; 336  : 			case CBC:
; 337  : 			case INNER_CBC:
; 338  : 			case OUTER_CBC:
; 339  : 
; 340  : 				// For LRW (deprecated/legacy), copy the tweak key 
; 341  : 				// For CBC (deprecated/legacy), copy the IV/whitening seed 
; 342  : 				memcpy (cryptoInfo->k2, dk, LEGACY_VOL_IV_SIZE);

  006c4	48 8b 7c 24 50	 mov	 rdi, QWORD PTR cryptoInfo$[rsp]
  006c9	48 8d 74 24 60	 lea	 rsi, QWORD PTR dk$[rsp]
  006ce	48 81 c7 a8 42
	00 00		 add	 rdi, 17064		; 000042a8H
  006d5	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  006da	f3 a4		 rep movsb

; 343  : 				primaryKeyOffset = LEGACY_VOL_IV_SIZE;

  006dc	c7 84 24 90 01
	00 00 20 00 00
	00		 mov	 DWORD PTR primaryKeyOffset$[rsp], 32 ; 00000020H

; 344  : 				break;

  006e7	eb 0b		 jmp	 SHORT $LN53@ReadVolume
$LN51@ReadVolume:

; 345  : 
; 346  : 			default:
; 347  : 				primaryKeyOffset = 0;

  006e9	c7 84 24 90 01
	00 00 00 00 00
	00		 mov	 DWORD PTR primaryKeyOffset$[rsp], 0
$LN53@ReadVolume:

; 348  : 			}
; 349  : 
; 350  : 			// Test all available encryption algorithms
; 351  : 			for (cryptoInfo->ea = EAGetFirst ();
; 352  : 				cryptoInfo->ea != 0;
; 353  : 				cryptoInfo->ea = EAGetNext (cryptoInfo->ea))

  006f4	e8 00 00 00 00	 call	 EAGetFirst
  006f9	8b d0		 mov	 edx, eax
  006fb	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00700	89 10		 mov	 DWORD PTR [rax], edx
  00702	eb 15		 jmp	 SHORT $LN50@ReadVolume
$LN49@ReadVolume:
  00704	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00709	8b 08		 mov	 ecx, DWORD PTR [rax]
  0070b	e8 00 00 00 00	 call	 EAGetNext
  00710	8b d0		 mov	 edx, eax
  00712	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00717	89 10		 mov	 DWORD PTR [rax], edx
$LN50@ReadVolume:
  00719	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  0071e	83 38 00	 cmp	 DWORD PTR [rax], 0
  00721	0f 84 8b 06 00
	00		 je	 $LN48@ReadVolume

; 354  : 			{
; 355  : 				int blockSize;
; 356  : 
; 357  : 				if (!EAIsModeSupported (cryptoInfo->ea, cryptoInfo->mode))

  00727	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  0072c	8b 50 04	 mov	 edx, DWORD PTR [rax+4]
  0072f	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00734	8b 08		 mov	 ecx, DWORD PTR [rax]
  00736	e8 00 00 00 00	 call	 EAIsModeSupported
  0073b	85 c0		 test	 eax, eax
  0073d	75 02		 jne	 SHORT $LN47@ReadVolume

; 358  : 					continue;	// This encryption algorithm has never been available with this mode of operation

  0073f	eb c3		 jmp	 SHORT $LN49@ReadVolume
$LN47@ReadVolume:

; 359  : 
; 360  : 				blockSize = CipherGetBlockSize (EAGetFirstCipher (cryptoInfo->ea));

  00741	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00746	8b 08		 mov	 ecx, DWORD PTR [rax]
  00748	e8 00 00 00 00	 call	 EAGetFirstCipher
  0074d	8b c8		 mov	 ecx, eax
  0074f	e8 00 00 00 00	 call	 CipherGetBlockSize
  00754	89 84 24 78 05
	00 00		 mov	 DWORD PTR blockSize$29784[rsp], eax

; 361  : 
; 362  : 				status = EAInit (cryptoInfo->ea, dk + primaryKeyOffset, cryptoInfo->ks);

  0075b	4c 8b 44 24 50	 mov	 r8, QWORD PTR cryptoInfo$[rsp]
  00760	49 83 c0 08	 add	 r8, 8
  00764	48 63 84 24 90
	01 00 00	 movsxd	 rax, DWORD PTR primaryKeyOffset$[rsp]
  0076c	48 8d 54 04 60	 lea	 rdx, QWORD PTR dk$[rsp+rax]
  00771	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00776	8b 08		 mov	 ecx, DWORD PTR [rax]
  00778	e8 00 00 00 00	 call	 EAInit
  0077d	89 84 24 5c 03
	00 00		 mov	 DWORD PTR status$[rsp], eax

; 363  : 				if (status == ERR_CIPHER_INIT_FAILURE)

  00784	83 bc 24 5c 03
	00 00 11	 cmp	 DWORD PTR status$[rsp], 17
  0078c	75 05		 jne	 SHORT $LN46@ReadVolume

; 364  : 					goto err;

  0078e	e9 34 06 00 00	 jmp	 $err$29787
$LN46@ReadVolume:

; 365  : 
; 366  : 				// Init objects related to the mode of operation
; 367  : 
; 368  : 				if (cryptoInfo->mode == XTS)

  00793	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00798	83 78 04 01	 cmp	 DWORD PTR [rax+4], 1
  0079c	75 53		 jne	 SHORT $LN45@ReadVolume

; 369  : 				{
; 370  : 					// Copy the secondary key (if cascade, multiple concatenated)
; 371  : 					memcpy (cryptoInfo->k2, dk + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));

  0079e	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  007a3	8b 08		 mov	 ecx, DWORD PTR [rax]
  007a5	e8 00 00 00 00	 call	 EAGetKeySize
  007aa	48 63 d8	 movsxd	 rbx, eax
  007ad	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  007b2	8b 08		 mov	 ecx, DWORD PTR [rax]
  007b4	e8 00 00 00 00	 call	 EAGetKeySize
  007b9	48 98		 cdqe
  007bb	48 8d 74 04 60	 lea	 rsi, QWORD PTR dk$[rsp+rax]
  007c0	48 8b 7c 24 50	 mov	 rdi, QWORD PTR cryptoInfo$[rsp]
  007c5	48 81 c7 a8 42
	00 00		 add	 rdi, 17064		; 000042a8H
  007cc	48 8b cb	 mov	 rcx, rbx
  007cf	f3 a4		 rep movsb

; 372  : 
; 373  : 					// Secondary key schedule
; 374  : 					if (!EAInitMode (cryptoInfo))

  007d1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cryptoInfo$[rsp]
  007d6	e8 00 00 00 00	 call	 EAInitMode
  007db	85 c0		 test	 eax, eax
  007dd	75 10		 jne	 SHORT $LN44@ReadVolume

; 375  : 					{
; 376  : 						status = ERR_MODE_INIT_FAILED;

  007df	c7 84 24 5c 03
	00 00 1b 00 00
	00		 mov	 DWORD PTR status$[rsp], 27

; 377  : 						goto err;

  007ea	e9 d8 05 00 00	 jmp	 $err$29787
$LN44@ReadVolume:

; 378  : 					}
; 379  : 				}
; 380  : 				else if (cryptoInfo->mode == LRW

  007ef	eb 7d		 jmp	 SHORT $LN43@ReadVolume
$LN45@ReadVolume:

; 381  : 					&& (blockSize == 8 && !lrw64InitDone || blockSize == 16 && !lrw128InitDone))

  007f1	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  007f6	83 78 04 02	 cmp	 DWORD PTR [rax+4], 2
  007fa	75 72		 jne	 SHORT $LN42@ReadVolume
  007fc	83 bc 24 78 05
	00 00 08	 cmp	 DWORD PTR blockSize$29784[rsp], 8
  00804	75 0a		 jne	 SHORT $LN40@ReadVolume
  00806	83 bc 24 74 05
	00 00 00	 cmp	 DWORD PTR lrw64InitDone$29741[rsp], 0
  0080e	74 14		 je	 SHORT $LN41@ReadVolume
$LN40@ReadVolume:
  00810	83 bc 24 78 05
	00 00 10	 cmp	 DWORD PTR blockSize$29784[rsp], 16
  00818	75 54		 jne	 SHORT $LN42@ReadVolume
  0081a	83 bc 24 70 05
	00 00 00	 cmp	 DWORD PTR lrw128InitDone$29742[rsp], 0
  00822	75 4a		 jne	 SHORT $LN42@ReadVolume
$LN41@ReadVolume:

; 382  : 				{
; 383  : 					// Deprecated/legacy
; 384  : 
; 385  : 					if (!EAInitMode (cryptoInfo))

  00824	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cryptoInfo$[rsp]
  00829	e8 00 00 00 00	 call	 EAInitMode
  0082e	85 c0		 test	 eax, eax
  00830	75 10		 jne	 SHORT $LN39@ReadVolume

; 386  : 					{
; 387  : 						status = ERR_MODE_INIT_FAILED;

  00832	c7 84 24 5c 03
	00 00 1b 00 00
	00		 mov	 DWORD PTR status$[rsp], 27

; 388  : 						goto err;

  0083d	e9 85 05 00 00	 jmp	 $err$29787
$LN39@ReadVolume:

; 389  : 					}
; 390  : 
; 391  : 					if (blockSize == 8)

  00842	83 bc 24 78 05
	00 00 08	 cmp	 DWORD PTR blockSize$29784[rsp], 8
  0084a	75 0d		 jne	 SHORT $LN38@ReadVolume

; 392  : 						lrw64InitDone = TRUE;

  0084c	c7 84 24 74 05
	00 00 01 00 00
	00		 mov	 DWORD PTR lrw64InitDone$29741[rsp], 1
  00857	eb 15		 jmp	 SHORT $LN37@ReadVolume
$LN38@ReadVolume:

; 393  : 					else if (blockSize == 16)

  00859	83 bc 24 78 05
	00 00 10	 cmp	 DWORD PTR blockSize$29784[rsp], 16
  00861	75 0b		 jne	 SHORT $LN36@ReadVolume

; 394  : 						lrw128InitDone = TRUE;

  00863	c7 84 24 70 05
	00 00 01 00 00
	00		 mov	 DWORD PTR lrw128InitDone$29742[rsp], 1
$LN36@ReadVolume:
$LN37@ReadVolume:
$LN42@ReadVolume:
$LN43@ReadVolume:

; 395  : 				}
; 396  : 
; 397  : 				// Copy the header for decryption
; 398  : 				memcpy (header, encryptedHeader, sizeof (header));

  0086e	48 8d bc 24 70
	03 00 00	 lea	 rdi, QWORD PTR header$[rsp]
  00876	48 8b b4 24 08
	06 00 00	 mov	 rsi, QWORD PTR encryptedHeader$[rsp]
  0087e	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00883	f3 a4		 rep movsb

; 399  : 
; 400  : 				// Try to decrypt header 
; 401  : 
; 402  : 				DecryptBuffer (header + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, cryptoInfo);

  00885	48 8d 8c 24 b0
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp+64]
  0088d	4c 8b 44 24 50	 mov	 r8, QWORD PTR cryptoInfo$[rsp]
  00892	ba c0 01 00 00	 mov	 edx, 448		; 000001c0H
  00897	e8 00 00 00 00	 call	 DecryptBuffer

; 403  : 
; 404  : 				// Magic 'TRUE'
; 405  : 				/* Modifying 'TRUE' can introduce incompatibility with previous versions. */
; 406  : 				if (GetHeaderField32 (header, TC_HEADER_OFFSET_MAGIC) != 0x54525545)

  0089c	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  008a1	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  008a9	e8 00 00 00 00	 call	 GetHeaderField32
  008ae	3d 45 55 52 54	 cmp	 eax, 1414681925		; 54525545H
  008b3	74 05		 je	 SHORT $LN35@ReadVolume

; 407  : 					continue;

  008b5	e9 4a fe ff ff	 jmp	 $LN49@ReadVolume
$LN35@ReadVolume:

; 408  : 
; 409  : 				// Header version
; 410  : 				headerVersion = GetHeaderField16 (header, TC_HEADER_OFFSET_VERSION);

  008ba	ba 44 00 00 00	 mov	 edx, 68			; 00000044H
  008bf	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  008c7	e8 00 00 00 00	 call	 GetHeaderField16
  008cc	66 89 84 24 80
	01 00 00	 mov	 WORD PTR headerVersion$[rsp], ax

; 411  : 				
; 412  : 				if (headerVersion > VOLUME_HEADER_VERSION)

  008d4	0f b7 84 24 80
	01 00 00	 movzx	 eax, WORD PTR headerVersion$[rsp]
  008dc	83 f8 05	 cmp	 eax, 5
  008df	7e 10		 jle	 SHORT $LN34@ReadVolume

; 413  : 				{
; 414  : 					status = ERR_NEW_VERSION_REQUIRED;

  008e1	c7 84 24 5c 03
	00 00 10 00 00
	00		 mov	 DWORD PTR status$[rsp], 16

; 415  : 					goto err;

  008ec	e9 d6 04 00 00	 jmp	 $err$29787
$LN34@ReadVolume:

; 416  : 				}
; 417  : 
; 418  : 				// Check CRC of the header fields
; 419  : 				if (!ReadVolumeHeaderRecoveryMode
; 420  : 					&& headerVersion >= 4
; 421  : 					&& GetHeaderField32 (header, TC_HEADER_OFFSET_HEADER_CRC) != GetCrc32 (header + TC_HEADER_OFFSET_MAGIC, TC_HEADER_OFFSET_HEADER_CRC - TC_HEADER_OFFSET_MAGIC))

  008f1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ReadVolumeHeaderRecoveryMode, 0
  008f8	75 3c		 jne	 SHORT $LN33@ReadVolume
  008fa	0f b7 84 24 80
	01 00 00	 movzx	 eax, WORD PTR headerVersion$[rsp]
  00902	83 f8 04	 cmp	 eax, 4
  00905	7c 2f		 jl	 SHORT $LN33@ReadVolume
  00907	ba fc 00 00 00	 mov	 edx, 252		; 000000fcH
  0090c	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  00914	e8 00 00 00 00	 call	 GetHeaderField32
  00919	8b f8		 mov	 edi, eax
  0091b	48 8d 8c 24 b0
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp+64]
  00923	ba bc 00 00 00	 mov	 edx, 188		; 000000bcH
  00928	e8 00 00 00 00	 call	 GetCrc32
  0092d	3b f8		 cmp	 edi, eax
  0092f	74 05		 je	 SHORT $LN33@ReadVolume

; 422  : 					continue;

  00931	e9 ce fd ff ff	 jmp	 $LN49@ReadVolume
$LN33@ReadVolume:

; 423  : 
; 424  : 				// Required program version
; 425  : 				cryptoInfo->RequiredProgramVersion = GetHeaderField16 (header, TC_HEADER_OFFSET_REQUIRED_VERSION);

  00936	ba 46 00 00 00	 mov	 edx, 70			; 00000046H
  0093b	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  00943	e8 00 00 00 00	 call	 GetHeaderField16
  00948	0f b7 d0	 movzx	 edx, ax
  0094b	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00950	66 89 90 38 44
	00 00		 mov	 WORD PTR [rax+17464], dx

; 426  : 				cryptoInfo->LegacyVolume = cryptoInfo->RequiredProgramVersion < 0x600;

  00957	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  0095c	0f b7 80 38 44
	00 00		 movzx	 eax, WORD PTR [rax+17464]
  00963	3d 00 06 00 00	 cmp	 eax, 1536		; 00000600H
  00968	7d 0d		 jge	 SHORT $LN95@ReadVolume
  0096a	c7 84 24 c8 05
	00 00 01 00 00
	00		 mov	 DWORD PTR tv381[rsp], 1
  00975	eb 0b		 jmp	 SHORT $LN96@ReadVolume
$LN95@ReadVolume:
  00977	c7 84 24 c8 05
	00 00 00 00 00
	00		 mov	 DWORD PTR tv381[rsp], 0
$LN96@ReadVolume:
  00982	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cryptoInfo$[rsp]
  00987	8b 84 24 c8 05
	00 00		 mov	 eax, DWORD PTR tv381[rsp]
  0098e	89 81 3c 44 00
	00		 mov	 DWORD PTR [rcx+17468], eax

; 427  : 
; 428  : 				// Check CRC of the key set
; 429  : 				if (!ReadVolumeHeaderRecoveryMode
; 430  : 					&& GetHeaderField32 (header, TC_HEADER_OFFSET_KEY_AREA_CRC) != GetCrc32 (header + HEADER_MASTER_KEYDATA_OFFSET, MASTER_KEYDATA_SIZE))

  00994	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ReadVolumeHeaderRecoveryMode, 0
  0099b	75 2f		 jne	 SHORT $LN32@ReadVolume
  0099d	ba 48 00 00 00	 mov	 edx, 72			; 00000048H
  009a2	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  009aa	e8 00 00 00 00	 call	 GetHeaderField32
  009af	8b f8		 mov	 edi, eax
  009b1	48 8d 8c 24 70
	04 00 00	 lea	 rcx, QWORD PTR header$[rsp+256]
  009b9	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  009be	e8 00 00 00 00	 call	 GetCrc32
  009c3	3b f8		 cmp	 edi, eax
  009c5	74 05		 je	 SHORT $LN32@ReadVolume

; 431  : 					continue;

  009c7	e9 38 fd ff ff	 jmp	 $LN49@ReadVolume
$LN32@ReadVolume:

; 432  : 
; 433  : 				// Now we have the correct password, cipher, hash algorithm, and volume type
; 434  : 
; 435  : 				// Check the version required to handle this volume
; 436  : 				if (cryptoInfo->RequiredProgramVersion > VERSION_NUM)

  009cc	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  009d1	0f b7 80 38 44
	00 00		 movzx	 eax, WORD PTR [rax+17464]
  009d8	3d 40 07 00 00	 cmp	 eax, 1856		; 00000740H
  009dd	7e 10		 jle	 SHORT $LN31@ReadVolume

; 437  : 				{
; 438  : 					status = ERR_NEW_VERSION_REQUIRED;

  009df	c7 84 24 5c 03
	00 00 10 00 00
	00		 mov	 DWORD PTR status$[rsp], 16

; 439  : 					goto err;

  009ea	e9 d8 03 00 00	 jmp	 $err$29787
$LN31@ReadVolume:

; 440  : 				}
; 441  : 
; 442  : 				// Header version
; 443  : 				cryptoInfo->HeaderVersion = headerVersion;

  009ef	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cryptoInfo$[rsp]
  009f4	0f b7 84 24 80
	01 00 00	 movzx	 eax, WORD PTR headerVersion$[rsp]
  009fc	66 89 81 a4 29
	00 00		 mov	 WORD PTR [rcx+10660], ax

; 444  : 
; 445  : 				// Volume creation time (legacy)
; 446  : 				cryptoInfo->volume_creation_time = GetHeaderField64 (header, TC_HEADER_OFFSET_VOLUME_CREATION_TIME).Value;

  00a03	ba 4c 00 00 00	 mov	 edx, 76			; 0000004cH
  00a08	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  00a10	e8 00 00 00 00	 call	 GetHeaderField64
  00a15	48 89 84 24 a8
	05 00 00	 mov	 QWORD PTR $T45831[rsp], rax
  00a1d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cryptoInfo$[rsp]
  00a22	48 8b 84 24 a8
	05 00 00	 mov	 rax, QWORD PTR $T45831[rsp]
  00a2a	48 89 81 f0 43
	00 00		 mov	 QWORD PTR [rcx+17392], rax

; 447  : 
; 448  : 				// Header creation time (legacy)
; 449  : 				cryptoInfo->header_creation_time = GetHeaderField64 (header, TC_HEADER_OFFSET_MODIFICATION_TIME).Value;

  00a31	ba 54 00 00 00	 mov	 edx, 84			; 00000054H
  00a36	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  00a3e	e8 00 00 00 00	 call	 GetHeaderField64
  00a43	48 89 84 24 b0
	05 00 00	 mov	 QWORD PTR $T45832[rsp], rax
  00a4b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cryptoInfo$[rsp]
  00a50	48 8b 84 24 b0
	05 00 00	 mov	 rax, QWORD PTR $T45832[rsp]
  00a58	48 89 81 f8 43
	00 00		 mov	 QWORD PTR [rcx+17400], rax

; 450  : 
; 451  : 				// Hidden volume size (if any)
; 452  : 				cryptoInfo->hiddenVolumeSize = GetHeaderField64 (header, TC_HEADER_OFFSET_HIDDEN_VOLUME_SIZE).Value;

  00a5f	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  00a64	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  00a6c	e8 00 00 00 00	 call	 GetHeaderField64
  00a71	48 89 84 24 b8
	05 00 00	 mov	 QWORD PTR $T45833[rsp], rax
  00a79	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cryptoInfo$[rsp]
  00a7e	48 8b 84 24 b8
	05 00 00	 mov	 rax, QWORD PTR $T45833[rsp]
  00a86	48 89 81 10 44
	00 00		 mov	 QWORD PTR [rcx+17424], rax

; 453  : 
; 454  : 				// Hidden volume status
; 455  : 				cryptoInfo->hiddenVolume = (cryptoInfo->hiddenVolumeSize != 0);

  00a8d	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00a92	48 83 b8 10 44
	00 00 00	 cmp	 QWORD PTR [rax+17424], 0
  00a9a	74 0d		 je	 SHORT $LN97@ReadVolume
  00a9c	c7 84 24 cc 05
	00 00 01 00 00
	00		 mov	 DWORD PTR tv410[rsp], 1
  00aa7	eb 0b		 jmp	 SHORT $LN98@ReadVolume
$LN97@ReadVolume:
  00aa9	c7 84 24 cc 05
	00 00 00 00 00
	00		 mov	 DWORD PTR tv410[rsp], 0
$LN98@ReadVolume:
  00ab4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cryptoInfo$[rsp]
  00ab9	8b 84 24 cc 05
	00 00		 mov	 eax, DWORD PTR tv410[rsp]
  00ac0	89 81 a0 29 00
	00		 mov	 DWORD PTR [rcx+10656], eax

; 456  : 
; 457  : 				// Volume size
; 458  : 				cryptoInfo->VolumeSize = GetHeaderField64 (header, TC_HEADER_OFFSET_VOLUME_SIZE);

  00ac6	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00acb	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  00ad3	e8 00 00 00 00	 call	 GetHeaderField64
  00ad8	48 8b d0	 mov	 rdx, rax
  00adb	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00ae0	48 89 90 48 44
	00 00		 mov	 QWORD PTR [rax+17480], rdx

; 459  : 				
; 460  : 				// Encrypted area size and length
; 461  : 				cryptoInfo->EncryptedAreaStart = GetHeaderField64 (header, TC_HEADER_OFFSET_ENCRYPTED_AREA_START);

  00ae7	ba 6c 00 00 00	 mov	 edx, 108		; 0000006cH
  00aec	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  00af4	e8 00 00 00 00	 call	 GetHeaderField64
  00af9	48 8b d0	 mov	 rdx, rax
  00afc	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00b01	48 89 90 50 44
	00 00		 mov	 QWORD PTR [rax+17488], rdx

; 462  : 				cryptoInfo->EncryptedAreaLength = GetHeaderField64 (header, TC_HEADER_OFFSET_ENCRYPTED_AREA_LENGTH);

  00b08	ba 74 00 00 00	 mov	 edx, 116		; 00000074H
  00b0d	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  00b15	e8 00 00 00 00	 call	 GetHeaderField64
  00b1a	48 8b d0	 mov	 rdx, rax
  00b1d	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00b22	48 89 90 58 44
	00 00		 mov	 QWORD PTR [rax+17496], rdx

; 463  : 
; 464  : 				// Flags
; 465  : 				cryptoInfo->HeaderFlags = GetHeaderField32 (header, TC_HEADER_OFFSET_FLAGS);

  00b29	ba 7c 00 00 00	 mov	 edx, 124		; 0000007cH
  00b2e	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  00b36	e8 00 00 00 00	 call	 GetHeaderField32
  00b3b	8b d0		 mov	 edx, eax
  00b3d	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00b42	89 90 60 44 00
	00		 mov	 DWORD PTR [rax+17504], edx

; 466  : 
; 467  : 				// Sector size
; 468  : 				if (headerVersion >= 5)

  00b48	0f b7 84 24 80
	01 00 00	 movzx	 eax, WORD PTR headerVersion$[rsp]
  00b50	83 f8 05	 cmp	 eax, 5
  00b53	7c 21		 jl	 SHORT $LN30@ReadVolume

; 469  : 					cryptoInfo->SectorSize = GetHeaderField32 (header, TC_HEADER_OFFSET_SECTOR_SIZE);

  00b55	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00b5a	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  00b62	e8 00 00 00 00	 call	 GetHeaderField32
  00b67	8b d0		 mov	 edx, eax
  00b69	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00b6e	89 90 40 44 00
	00		 mov	 DWORD PTR [rax+17472], edx

; 470  : 				else

  00b74	eb 0f		 jmp	 SHORT $LN29@ReadVolume
$LN30@ReadVolume:

; 471  : 					cryptoInfo->SectorSize = TC_SECTOR_SIZE_LEGACY;

  00b76	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00b7b	c7 80 40 44 00
	00 00 02 00 00	 mov	 DWORD PTR [rax+17472], 512 ; 00000200H
$LN29@ReadVolume:

; 472  : 
; 473  : 				if (cryptoInfo->SectorSize < TC_MIN_VOLUME_SECTOR_SIZE
; 474  : 					|| cryptoInfo->SectorSize > TC_MAX_VOLUME_SECTOR_SIZE
; 475  : 					|| cryptoInfo->SectorSize % ENCRYPTION_DATA_UNIT_SIZE != 0)

  00b85	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00b8a	81 b8 40 44 00
	00 00 02 00 00	 cmp	 DWORD PTR [rax+17472], 512 ; 00000200H
  00b94	72 29		 jb	 SHORT $LN27@ReadVolume
  00b96	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00b9b	81 b8 40 44 00
	00 00 10 00 00	 cmp	 DWORD PTR [rax+17472], 4096 ; 00001000H
  00ba5	77 18		 ja	 SHORT $LN27@ReadVolume
  00ba7	33 d2		 xor	 edx, edx
  00ba9	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00bae	8b 80 40 44 00
	00		 mov	 eax, DWORD PTR [rax+17472]
  00bb4	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00bb9	f7 f1		 div	 ecx
  00bbb	85 d2		 test	 edx, edx
  00bbd	74 10		 je	 SHORT $LN28@ReadVolume
$LN27@ReadVolume:

; 476  : 				{
; 477  : 					status = ERR_PARAMETER_INCORRECT;

  00bbf	c7 84 24 5c 03
	00 00 1e 00 00
	00		 mov	 DWORD PTR status$[rsp], 30

; 478  : 					goto err;

  00bca	e9 f8 01 00 00	 jmp	 $err$29787
$LN28@ReadVolume:

; 479  : 				}
; 480  : 
; 481  : 				// Preserve scheduled header keys if requested			
; 482  : 				if (retHeaderCryptoInfo)

  00bcf	48 83 bc 24 20
	06 00 00 00	 cmp	 QWORD PTR retHeaderCryptoInfo$[rsp], 0
  00bd8	0f 84 83 00 00
	00		 je	 $LN26@ReadVolume

; 483  : 				{
; 484  : 					if (retInfo == NULL)

  00bde	48 83 bc 24 18
	06 00 00 00	 cmp	 QWORD PTR retInfo$[rsp], 0
  00be7	75 29		 jne	 SHORT $LN25@ReadVolume

; 485  : 					{
; 486  : 						cryptoInfo->pkcs5 = pkcs5_prf;

  00be9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cryptoInfo$[rsp]
  00bee	8b 84 24 64 03
	00 00		 mov	 eax, DWORD PTR pkcs5_prf$[rsp]
  00bf5	89 81 ec 43 00
	00		 mov	 DWORD PTR [rcx+17388], eax

; 487  : 						cryptoInfo->noIterations = keyInfo.noIterations;

  00bfb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cryptoInfo$[rsp]
  00c00	8b 84 24 b0 01
	00 00		 mov	 eax, DWORD PTR keyInfo$[rsp]
  00c07	89 81 e8 43 00
	00		 mov	 DWORD PTR [rcx+17384], eax

; 488  : 						goto ret;

  00c0d	e9 dd 01 00 00	 jmp	 $ret$29810
$LN25@ReadVolume:

; 489  : 					}
; 490  : 
; 491  : 					cryptoInfo = *retInfo = crypto_open ();

  00c12	e8 00 00 00 00	 call	 crypto_open
  00c17	48 8b d0	 mov	 rdx, rax
  00c1a	48 8b 84 24 18
	06 00 00	 mov	 rax, QWORD PTR retInfo$[rsp]
  00c22	48 89 10	 mov	 QWORD PTR [rax], rdx
  00c25	48 8b 84 24 18
	06 00 00	 mov	 rax, QWORD PTR retInfo$[rsp]
  00c2d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00c30	48 89 44 24 50	 mov	 QWORD PTR cryptoInfo$[rsp], rax

; 492  : 					if (cryptoInfo == NULL)

  00c35	48 83 7c 24 50
	00		 cmp	 QWORD PTR cryptoInfo$[rsp], 0
  00c3b	75 10		 jne	 SHORT $LN24@ReadVolume

; 493  : 					{
; 494  : 						status = ERR_OUTOFMEMORY;

  00c3d	c7 84 24 5c 03
	00 00 02 00 00
	00		 mov	 DWORD PTR status$[rsp], 2

; 495  : 						goto err;

  00c48	e9 7a 01 00 00	 jmp	 $err$29787
$LN24@ReadVolume:

; 496  : 					}
; 497  : 
; 498  : 					memcpy (cryptoInfo, retHeaderCryptoInfo, sizeof (*cryptoInfo));

  00c4d	48 8b 7c 24 50	 mov	 rdi, QWORD PTR cryptoInfo$[rsp]
  00c52	48 8b b4 24 20
	06 00 00	 mov	 rsi, QWORD PTR retHeaderCryptoInfo$[rsp]
  00c5a	b9 68 44 00 00	 mov	 ecx, 17512		; 00004468H
  00c5f	f3 a4		 rep movsb
$LN26@ReadVolume:

; 499  : 				}
; 500  : 
; 501  : 				// Master key data
; 502  : 				memcpy (keyInfo.master_keydata, header + HEADER_MASTER_KEYDATA_OFFSET, MASTER_KEYDATA_SIZE);

  00c61	48 8d bc 24 38
	02 00 00	 lea	 rdi, QWORD PTR keyInfo$[rsp+136]
  00c69	48 8d b4 24 70
	04 00 00	 lea	 rsi, QWORD PTR header$[rsp+256]
  00c71	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00c76	f3 a4		 rep movsb

; 503  : 				memcpy (cryptoInfo->master_keydata, keyInfo.master_keydata, MASTER_KEYDATA_SIZE);

  00c78	48 8b 7c 24 50	 mov	 rdi, QWORD PTR cryptoInfo$[rsp]
  00c7d	48 8d b4 24 38
	02 00 00	 lea	 rsi, QWORD PTR keyInfo$[rsp+136]
  00c85	48 81 c7 a8 41
	00 00		 add	 rdi, 16808		; 000041a8H
  00c8c	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00c91	f3 a4		 rep movsb

; 504  : 
; 505  : 				// PKCS #5
; 506  : 				memcpy (cryptoInfo->salt, keyInfo.salt, PKCS5_SALT_SIZE);

  00c93	48 8b 7c 24 50	 mov	 rdi, QWORD PTR cryptoInfo$[rsp]
  00c98	48 8d b4 24 f8
	01 00 00	 lea	 rsi, QWORD PTR keyInfo$[rsp+72]
  00ca0	48 81 c7 a8 43
	00 00		 add	 rdi, 17320		; 000043a8H
  00ca7	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00cac	f3 a4		 rep movsb

; 507  : 				cryptoInfo->pkcs5 = pkcs5_prf;

  00cae	48 8b 54 24 50	 mov	 rdx, QWORD PTR cryptoInfo$[rsp]
  00cb3	8b 84 24 64 03
	00 00		 mov	 eax, DWORD PTR pkcs5_prf$[rsp]
  00cba	89 82 ec 43 00
	00		 mov	 DWORD PTR [rdx+17388], eax

; 508  : 				cryptoInfo->noIterations = keyInfo.noIterations;

  00cc0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cryptoInfo$[rsp]
  00cc5	8b 84 24 b0 01
	00 00		 mov	 eax, DWORD PTR keyInfo$[rsp]
  00ccc	89 81 e8 43 00
	00		 mov	 DWORD PTR [rcx+17384], eax

; 509  : 
; 510  : 				// Init the cipher with the decrypted master key
; 511  : 				status = EAInit (cryptoInfo->ea, keyInfo.master_keydata + primaryKeyOffset, cryptoInfo->ks);

  00cd2	4c 8b 44 24 50	 mov	 r8, QWORD PTR cryptoInfo$[rsp]
  00cd7	49 83 c0 08	 add	 r8, 8
  00cdb	48 63 84 24 90
	01 00 00	 movsxd	 rax, DWORD PTR primaryKeyOffset$[rsp]
  00ce3	48 8d 94 04 38
	02 00 00	 lea	 rdx, QWORD PTR keyInfo$[rsp+rax+136]
  00ceb	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00cf0	8b 08		 mov	 ecx, DWORD PTR [rax]
  00cf2	e8 00 00 00 00	 call	 EAInit
  00cf7	89 84 24 5c 03
	00 00		 mov	 DWORD PTR status$[rsp], eax

; 512  : 				if (status == ERR_CIPHER_INIT_FAILURE)

  00cfe	83 bc 24 5c 03
	00 00 11	 cmp	 DWORD PTR status$[rsp], 17
  00d06	75 05		 jne	 SHORT $LN23@ReadVolume

; 513  : 					goto err;

  00d08	e9 ba 00 00 00	 jmp	 $err$29787
$LN23@ReadVolume:

; 514  : 
; 515  : 				switch (cryptoInfo->mode)

  00d0d	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00d12	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00d15	89 84 24 d0 05
	00 00		 mov	 DWORD PTR tv487[rsp], eax
  00d1c	83 bc 24 d0 05
	00 00 02	 cmp	 DWORD PTR tv487[rsp], 2
  00d24	7c 29		 jl	 SHORT $LN19@ReadVolume
  00d26	83 bc 24 d0 05
	00 00 05	 cmp	 DWORD PTR tv487[rsp], 5
  00d2e	7e 02		 jle	 SHORT $LN20@ReadVolume
  00d30	eb 1d		 jmp	 SHORT $LN19@ReadVolume
$LN20@ReadVolume:

; 516  : 				{
; 517  : 				case LRW:
; 518  : 				case CBC:
; 519  : 				case INNER_CBC:
; 520  : 				case OUTER_CBC:
; 521  : 
; 522  : 					// For LRW (deprecated/legacy), the tweak key
; 523  : 					// For CBC (deprecated/legacy), the IV/whitening seed
; 524  : 					memcpy (cryptoInfo->k2, keyInfo.master_keydata, LEGACY_VOL_IV_SIZE);

  00d32	48 8b 7c 24 50	 mov	 rdi, QWORD PTR cryptoInfo$[rsp]
  00d37	48 8d b4 24 38
	02 00 00	 lea	 rsi, QWORD PTR keyInfo$[rsp+136]
  00d3f	48 81 c7 a8 42
	00 00		 add	 rdi, 17064		; 000042a8H
  00d46	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00d4b	f3 a4		 rep movsb

; 525  : 					break;

  00d4d	eb 36		 jmp	 SHORT $LN21@ReadVolume
$LN19@ReadVolume:

; 526  : 
; 527  : 				default:
; 528  : 					// The secondary master key (if cascade, multiple concatenated)
; 529  : 					memcpy (cryptoInfo->k2, keyInfo.master_keydata + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));

  00d4f	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00d54	8b 08		 mov	 ecx, DWORD PTR [rax]
  00d56	e8 00 00 00 00	 call	 EAGetKeySize
  00d5b	48 63 d8	 movsxd	 rbx, eax
  00d5e	48 8b 44 24 50	 mov	 rax, QWORD PTR cryptoInfo$[rsp]
  00d63	8b 08		 mov	 ecx, DWORD PTR [rax]
  00d65	e8 00 00 00 00	 call	 EAGetKeySize
  00d6a	48 98		 cdqe
  00d6c	48 8d b4 04 38
	02 00 00	 lea	 rsi, QWORD PTR keyInfo$[rsp+rax+136]
  00d74	48 8b 7c 24 50	 mov	 rdi, QWORD PTR cryptoInfo$[rsp]
  00d79	48 81 c7 a8 42
	00 00		 add	 rdi, 17064		; 000042a8H
  00d80	48 8b cb	 mov	 rcx, rbx
  00d83	f3 a4		 rep movsb
$LN21@ReadVolume:

; 530  : 
; 531  : 				}
; 532  : 
; 533  : 				if (!EAInitMode (cryptoInfo))

  00d85	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cryptoInfo$[rsp]
  00d8a	e8 00 00 00 00	 call	 EAInitMode
  00d8f	85 c0		 test	 eax, eax
  00d91	75 0d		 jne	 SHORT $LN18@ReadVolume

; 534  : 				{
; 535  : 					status = ERR_MODE_INIT_FAILED;

  00d93	c7 84 24 5c 03
	00 00 1b 00 00
	00		 mov	 DWORD PTR status$[rsp], 27

; 536  : 					goto err;

  00d9e	eb 27		 jmp	 SHORT $err$29787
$LN18@ReadVolume:

; 537  : 				}
; 538  : 
; 539  : 				status = ERR_SUCCESS;

  00da0	c7 84 24 5c 03
	00 00 00 00 00
	00		 mov	 DWORD PTR status$[rsp], 0

; 540  : 				goto ret;

  00dab	eb 42		 jmp	 SHORT $ret$29810

; 541  : 			}

  00dad	e9 52 f9 ff ff	 jmp	 $LN49@ReadVolume
$LN48@ReadVolume:

; 542  : 		}

  00db2	e9 c6 f8 ff ff	 jmp	 $LN56@ReadVolume
$LN55@ReadVolume:

; 543  : 	}

  00db7	e9 0b f4 ff ff	 jmp	 $LN83@ReadVolume
$LN82@ReadVolume:

; 544  : 	status = ERR_PASSWORD_WRONG;

  00dbc	c7 84 24 5c 03
	00 00 03 00 00
	00		 mov	 DWORD PTR status$[rsp], 3
$err$29787:

; 545  : 
; 546  : err:
; 547  : 	if (cryptoInfo != retHeaderCryptoInfo)

  00dc7	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR retHeaderCryptoInfo$[rsp]
  00dcf	48 39 44 24 50	 cmp	 QWORD PTR cryptoInfo$[rsp], rax
  00dd4	74 19		 je	 SHORT $LN17@ReadVolume

; 548  : 	{
; 549  : 		crypto_close(cryptoInfo);

  00dd6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cryptoInfo$[rsp]
  00ddb	e8 00 00 00 00	 call	 crypto_close

; 550  : 		*retInfo = NULL; 

  00de0	48 8b 94 24 18
	06 00 00	 mov	 rdx, QWORD PTR retInfo$[rsp]
  00de8	48 c7 02 00 00
	00 00		 mov	 QWORD PTR [rdx], 0
$LN17@ReadVolume:
$ret$29810:
$LN16@ReadVolume:

; 551  : 	}
; 552  : 
; 553  : ret:
; 554  : 	burn (&keyInfo, sizeof (keyInfo));

  00def	48 8d 84 24 b0
	01 00 00	 lea	 rax, QWORD PTR keyInfo$[rsp]
  00df7	48 89 84 24 80
	05 00 00	 mov	 QWORD PTR burnm$29826[rsp], rax
  00dff	c7 84 24 7c 05
	00 00 88 01 00
	00		 mov	 DWORD PTR burnc$29828[rsp], 392 ; 00000188H
  00e0a	ba 88 01 00 00	 mov	 edx, 392		; 00000188H
  00e0f	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR keyInfo$[rsp]
  00e17	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN13@ReadVolume:
  00e1c	8b 8c 24 7c 05
	00 00		 mov	 ecx, DWORD PTR burnc$29828[rsp]
  00e23	8b 84 24 7c 05
	00 00		 mov	 eax, DWORD PTR burnc$29828[rsp]
  00e2a	83 e8 01	 sub	 eax, 1
  00e2d	89 84 24 7c 05
	00 00		 mov	 DWORD PTR burnc$29828[rsp], eax
  00e34	85 c9		 test	 ecx, ecx
  00e36	74 21		 je	 SHORT $LN12@ReadVolume
  00e38	48 8b 84 24 80
	05 00 00	 mov	 rax, QWORD PTR burnm$29826[rsp]
  00e40	c6 00 00	 mov	 BYTE PTR [rax], 0
  00e43	48 8b 84 24 80
	05 00 00	 mov	 rax, QWORD PTR burnm$29826[rsp]
  00e4b	48 83 c0 01	 add	 rax, 1
  00e4f	48 89 84 24 80
	05 00 00	 mov	 QWORD PTR burnm$29826[rsp], rax
  00e57	eb c3		 jmp	 SHORT $LN13@ReadVolume
$LN12@ReadVolume:
  00e59	33 c0		 xor	 eax, eax
  00e5b	85 c0		 test	 eax, eax
  00e5d	75 90		 jne	 SHORT $LN16@ReadVolume
$LN11@ReadVolume:

; 555  : 	burn (dk, sizeof(dk));

  00e5f	48 8d 44 24 60	 lea	 rax, QWORD PTR dk$[rsp]
  00e64	48 89 84 24 90
	05 00 00	 mov	 QWORD PTR burnm$29835[rsp], rax
  00e6c	c7 84 24 88 05
	00 00 00 01 00
	00		 mov	 DWORD PTR burnc$29837[rsp], 256 ; 00000100H
  00e77	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00e7c	48 8d 4c 24 60	 lea	 rcx, QWORD PTR dk$[rsp]
  00e81	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN8@ReadVolume:
  00e86	8b 8c 24 88 05
	00 00		 mov	 ecx, DWORD PTR burnc$29837[rsp]
  00e8d	8b 84 24 88 05
	00 00		 mov	 eax, DWORD PTR burnc$29837[rsp]
  00e94	83 e8 01	 sub	 eax, 1
  00e97	89 84 24 88 05
	00 00		 mov	 DWORD PTR burnc$29837[rsp], eax
  00e9e	85 c9		 test	 ecx, ecx
  00ea0	74 21		 je	 SHORT $LN7@ReadVolume
  00ea2	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR burnm$29835[rsp]
  00eaa	c6 00 00	 mov	 BYTE PTR [rax], 0
  00ead	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR burnm$29835[rsp]
  00eb5	48 83 c0 01	 add	 rax, 1
  00eb9	48 89 84 24 90
	05 00 00	 mov	 QWORD PTR burnm$29835[rsp], rax
  00ec1	eb c3		 jmp	 SHORT $LN8@ReadVolume
$LN7@ReadVolume:
  00ec3	33 c0		 xor	 eax, eax
  00ec5	85 c0		 test	 eax, eax
  00ec7	75 96		 jne	 SHORT $LN11@ReadVolume

; 556  : 
; 557  : #ifndef DEVICE_DRIVER
; 558  : 	VirtualUnlock (&keyInfo, sizeof (keyInfo));
; 559  : 	VirtualUnlock (&dk, sizeof (dk));
; 560  : #endif
; 561  : 
; 562  : 	if (encryptionThreadCount > 1)

  00ec9	48 83 bc 24 88
	01 00 00 01	 cmp	 QWORD PTR encryptionThreadCount$[rsp], 1
  00ed2	0f 86 bb 00 00
	00		 jbe	 $LN6@ReadVolume

; 563  : 	{
; 564  : 		TC_WAIT_EVENT (noOutstandingWorkItemEvent);

  00ed8	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00ee1	45 33 c9	 xor	 r9d, r9d
  00ee4	45 33 c0	 xor	 r8d, r8d
  00ee7	33 d2		 xor	 edx, edx
  00ee9	48 8d 8c 24 68
	01 00 00	 lea	 rcx, QWORD PTR noOutstandingWorkItemEvent$[rsp]
  00ef1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
$LN5@ReadVolume:

; 565  : 
; 566  : 		burn (keyDerivationWorkItems, sizeof (KeyDerivationWorkItem) * pkcs5PrfCount);

  00ef7	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR keyDerivationWorkItems$[rsp]
  00eff	48 89 84 24 a0
	05 00 00	 mov	 QWORD PTR burnm$29846[rsp], rax
  00f07	48 63 84 24 60
	03 00 00	 movsxd	 rax, DWORD PTR pkcs5PrfCount$[rsp]
  00f0f	48 69 c0 0c 01
	00 00		 imul	 rax, 268		; 0000010cH
  00f16	89 84 24 98 05
	00 00		 mov	 DWORD PTR burnc$29848[rsp], eax
  00f1d	48 63 94 24 60
	03 00 00	 movsxd	 rdx, DWORD PTR pkcs5PrfCount$[rsp]
  00f25	48 69 d2 0c 01
	00 00		 imul	 rdx, 268		; 0000010cH
  00f2c	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR keyDerivationWorkItems$[rsp]
  00f34	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN2@ReadVolume:
  00f39	8b 8c 24 98 05
	00 00		 mov	 ecx, DWORD PTR burnc$29848[rsp]
  00f40	8b 84 24 98 05
	00 00		 mov	 eax, DWORD PTR burnc$29848[rsp]
  00f47	83 e8 01	 sub	 eax, 1
  00f4a	89 84 24 98 05
	00 00		 mov	 DWORD PTR burnc$29848[rsp], eax
  00f51	85 c9		 test	 ecx, ecx
  00f53	74 21		 je	 SHORT $LN1@ReadVolume
  00f55	48 8b 84 24 a0
	05 00 00	 mov	 rax, QWORD PTR burnm$29846[rsp]
  00f5d	c6 00 00	 mov	 BYTE PTR [rax], 0
  00f60	48 8b 84 24 a0
	05 00 00	 mov	 rax, QWORD PTR burnm$29846[rsp]
  00f68	48 83 c0 01	 add	 rax, 1
  00f6c	48 89 84 24 a0
	05 00 00	 mov	 QWORD PTR burnm$29846[rsp], rax
  00f74	eb c3		 jmp	 SHORT $LN2@ReadVolume
$LN1@ReadVolume:
  00f76	33 c0		 xor	 eax, eax
  00f78	85 c0		 test	 eax, eax
  00f7a	0f 85 77 ff ff
	ff		 jne	 $LN5@ReadVolume

; 567  : 		TCfree (keyDerivationWorkItems);

  00f80	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00f85	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR keyDerivationWorkItems$[rsp]
  00f8d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN6@ReadVolume:

; 568  : 
; 569  : #ifndef DEVICE_DRIVER
; 570  : 		CloseHandle (keyDerivationCompletedEvent);
; 571  : 		CloseHandle (noOutstandingWorkItemEvent);
; 572  : #endif
; 573  : 	}
; 574  : 
; 575  : 	return status;

  00f93	8b 84 24 5c 03
	00 00		 mov	 eax, DWORD PTR status$[rsp]
$LN93@ReadVolume:
$LN94@ReadVolume:

; 576  : }

  00f9a	48 8b 8c 24 d8
	05 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00fa2	48 33 cc	 xor	 rcx, rsp
  00fa5	e8 00 00 00 00	 call	 __security_check_cookie
  00faa	48 81 c4 e0 05
	00 00		 add	 rsp, 1504		; 000005e0H
  00fb1	5f		 pop	 rdi
  00fb2	5e		 pop	 rsi
  00fb3	5b		 pop	 rbx
  00fb4	c3		 ret	 0
ReadVolumeHeader ENDP
END
