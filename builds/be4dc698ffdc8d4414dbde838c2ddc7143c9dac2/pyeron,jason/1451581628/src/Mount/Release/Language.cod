; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\Public\Desktop\projects\ciphershed\src\Common\Language.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_UnknownString:WORD:0400H
COMM	_LocalizationSerialNo:DWORD
COMM	_LocalizationActive:DWORD
_LanguageFileFindHandle DD 0ffffffffH
_DATA	ENDS
PUBLIC	??_C@_03FJEFHLHG@Xml?$AA@			; `string'
EXTRN	_MapResource:PROC
EXTRN	__imp__FindClose@4:PROC
_BSS	SEGMENT
_LanguageResource DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_03FJEFHLHG@Xml?$AA@
; File c:\users\public\desktop\projects\ciphershed\src\common\language.c
CONST	SEGMENT
??_C@_03FJEFHLHG@Xml?$AA@ DB 'Xml', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _MapFirstLanguageFile
_TEXT	SEGMENT
_size$86129 = -4					; size = 4
_MapFirstLanguageFile PROC				; COMDAT

; 42   : {

  00000	51		 push	 ecx

; 43   : 	if (LanguageFileFindHandle != INVALID_HANDLE_VALUE)

  00001	a1 00 00 00 00	 mov	 eax, DWORD PTR _LanguageFileFindHandle
  00006	83 f8 ff	 cmp	 eax, -1
  00009	74 11		 je	 SHORT $LN2@MapFirstLa

; 44   : 	{
; 45   : 		FindClose (LanguageFileFindHandle);

  0000b	50		 push	 eax
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindClose@4

; 46   : 		LanguageFileFindHandle = INVALID_HANDLE_VALUE;

  00012	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _LanguageFileFindHandle, -1
$LN2@MapFirstLa:

; 47   : 	}
; 48   : 
; 49   : 	if (LanguageResource == NULL)

  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR _LanguageResource
  00021	85 c0		 test	 eax, eax
  00023	75 24		 jne	 SHORT $LN1@MapFirstLa

; 50   : 	{
; 51   : 		DWORD size;
; 52   : 		LanguageResource = MapResource ("Xml", IDR_LANGUAGE, &size);

  00025	8d 04 24	 lea	 eax, DWORD PTR _size$86129[esp+4]
  00028	50		 push	 eax
  00029	68 fa 01 00 00	 push	 506			; 000001faH
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_03FJEFHLHG@Xml?$AA@
  00033	e8 00 00 00 00	 call	 _MapResource

; 53   : 		LanguageResource[size - 1] = 0;

  00038	8b 4c 24 0c	 mov	 ecx, DWORD PTR _size$86129[esp+16]
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003f	a3 00 00 00 00	 mov	 DWORD PTR _LanguageResource, eax
  00044	c6 44 08 ff 00	 mov	 BYTE PTR [eax+ecx-1], 0
$LN1@MapFirstLa:

; 54   : 	}
; 55   : 
; 56   : 	return LanguageResource;
; 57   : }

  00049	59		 pop	 ecx
  0004a	c3		 ret	 0
_MapFirstLanguageFile ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BO@DAKOOJFM@?$AA?2?$AAL?$AAa?$AAn?$AAg?$AAu?$AAa?$AAg?$AAe?$AA?$CK?$AA?4?$AAx?$AAm?$AAl?$AA?$AA@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	__imp__FindNextFileW@8:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__ReadFile@20:PROC
EXTRN	__imp__CreateFileW@28:PROC
EXTRN	_malloc:PROC
EXTRN	_free:PROC
EXTRN	__imp__FindFirstFileW@8:PROC
EXTRN	_wcsrchr:PROC
EXTRN	__imp__GetModuleFileNameW@12:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
_LanguageFileBuffer DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_1BO@DAKOOJFM@?$AA?2?$AAL?$AAa?$AAn?$AAg?$AAu?$AAa?$AAg?$AAe?$AA?$CK?$AA?4?$AAx?$AAm?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@DAKOOJFM@?$AA?2?$AAL?$AAa?$AAn?$AAg?$AAu?$AAa?$AAg?$AAe?$AA?$CK?$AA?4?$AAx?$AAm?$AAl?$AA?$AA@ DB '\'
	DB	00H, 'L', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'u', 00H, 'a', 00H
	DB	'g', 00H, 'e', 00H, '*', 00H, '.', 00H, 'x', 00H, 'm', 00H, 'l'
	DB	00H, 00H, 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _MapNextLanguageFile
_TEXT	SEGMENT
_read$ = -1640						; size = 4
_find$ = -1636						; size = 592
_f$ = -1044						; size = 1040
__$ArrayPad$ = -4					; size = 4
_MapNextLanguageFile PROC				; COMDAT

; 61   : {

  00000	81 ec 68 06 00
	00		 sub	 esp, 1640		; 00000668H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 64 06
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1640], eax

; 62   : 	wchar_t f[TC_MAX_PATH*2], *t;
; 63   : 	WIN32_FIND_DATAW find;
; 64   : 	HANDLE file;
; 65   : 	DWORD read;
; 66   : 
; 67   : 	if (LanguageFileFindHandle == INVALID_HANDLE_VALUE)

  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR _LanguageFileFindHandle
  00019	56		 push	 esi
  0001a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetModuleFileNameW@12
  00020	83 f8 ff	 cmp	 eax, -1
  00023	0f 85 45 01 00
	00		 jne	 $LN9@MapNextLan

; 68   : 	{
; 69   : 		GetModuleFileNameW (NULL, f, sizeof (f) / sizeof (f[0]));

  00029	68 08 02 00 00	 push	 520			; 00000208H
  0002e	8d 84 24 5c 02
	00 00		 lea	 eax, DWORD PTR _f$[esp+1648]
  00035	50		 push	 eax
  00036	6a 00		 push	 0
  00038	ff d6		 call	 esi

; 70   : 		t = wcsrchr (f, L'\\');

  0003a	8d 8c 24 58 02
	00 00		 lea	 ecx, DWORD PTR _f$[esp+1644]
  00041	6a 5c		 push	 92			; 0000005cH
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 _wcsrchr
  00049	83 c4 08	 add	 esp, 8

; 71   : 		if (t == NULL) return NULL;

  0004c	85 c0		 test	 eax, eax
  0004e	0f 84 45 01 00
	00		 je	 $LN16@MapNextLan

; 72   : 
; 73   : 		wcscpy (t, L"\\Language*.xml");

  00054	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_1BO@DAKOOJFM@?$AA?2?$AAL?$AAa?$AAn?$AAg?$AAu?$AAa?$AAg?$AAe?$AA?$CK?$AA?4?$AAx?$AAm?$AAl?$AA?$AA@
  00059	8b d0		 mov	 edx, eax
  0005b	2b d1		 sub	 edx, ecx
  0005d	8d 49 00	 npad	 3
$LL12@MapNextLan:
  00060	0f b7 01	 movzx	 eax, WORD PTR [ecx]
  00063	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
  00067	83 c1 02	 add	 ecx, 2
  0006a	66 85 c0	 test	 ax, ax
  0006d	75 f1		 jne	 SHORT $LL12@MapNextLan

; 74   : 
; 75   : 		LanguageFileFindHandle = FindFirstFileW (f, &find);

  0006f	8d 54 24 08	 lea	 edx, DWORD PTR _find$[esp+1644]
  00073	52		 push	 edx
  00074	8d 84 24 5c 02
	00 00		 lea	 eax, DWORD PTR _f$[esp+1648]
  0007b	50		 push	 eax
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindFirstFileW@8
  00082	a3 00 00 00 00	 mov	 DWORD PTR _LanguageFileFindHandle, eax
$LN6@MapNextLan:

; 81   : 		return NULL;
; 82   : 	}
; 83   : 
; 84   : 	if (find.nFileSizeHigh != 0) return NULL;

  00087	83 7c 24 24 00	 cmp	 DWORD PTR _find$[esp+1672], 0
  0008c	0f 85 07 01 00
	00		 jne	 $LN16@MapNextLan

; 85   : 
; 86   : 	if (LanguageFileBuffer != NULL) free (LanguageFileBuffer);

  00092	a1 00 00 00 00	 mov	 eax, DWORD PTR _LanguageFileBuffer
  00097	85 c0		 test	 eax, eax
  00099	74 09		 je	 SHORT $LN4@MapNextLan
  0009b	50		 push	 eax
  0009c	e8 00 00 00 00	 call	 _free
  000a1	83 c4 04	 add	 esp, 4
$LN4@MapNextLan:

; 87   : 	LanguageFileBuffer = malloc(find.nFileSizeLow);

  000a4	8b 44 24 28	 mov	 eax, DWORD PTR _find$[esp+1676]
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 _malloc
  000ae	83 c4 04	 add	 esp, 4
  000b1	a3 00 00 00 00	 mov	 DWORD PTR _LanguageFileBuffer, eax

; 88   : 	if (LanguageFileBuffer == NULL) return NULL;

  000b6	85 c0		 test	 eax, eax
  000b8	0f 84 db 00 00
	00		 je	 $LN16@MapNextLan

; 89   : 
; 90   : 	GetModuleFileNameW (NULL, f, sizeof (f) / sizeof(f[0]));

  000be	68 08 02 00 00	 push	 520			; 00000208H
  000c3	8d 8c 24 5c 02
	00 00		 lea	 ecx, DWORD PTR _f$[esp+1648]
  000ca	51		 push	 ecx
  000cb	6a 00		 push	 0
  000cd	ff d6		 call	 esi

; 91   : 	t = wcsrchr (f, L'\\');

  000cf	8d 94 24 58 02
	00 00		 lea	 edx, DWORD PTR _f$[esp+1644]
  000d6	6a 5c		 push	 92			; 0000005cH
  000d8	52		 push	 edx

; 92   : 	wcscpy (t + 1, find.cFileName);

  000d9	8d 74 24 3c	 lea	 esi, DWORD PTR _find$[esp+1696]
  000dd	e8 00 00 00 00	 call	 _wcsrchr
  000e2	8d 48 02	 lea	 ecx, DWORD PTR [eax+2]
  000e5	8b c6		 mov	 eax, esi
  000e7	83 c4 08	 add	 esp, 8
  000ea	2b c8		 sub	 ecx, eax
  000ec	8d 64 24 00	 npad	 4
$LL13@MapNextLan:
  000f0	0f b7 06	 movzx	 eax, WORD PTR [esi]
  000f3	66 89 04 31	 mov	 WORD PTR [ecx+esi], ax
  000f7	83 c6 02	 add	 esi, 2
  000fa	66 85 c0	 test	 ax, ax
  000fd	75 f1		 jne	 SHORT $LL13@MapNextLan

; 93   : 
; 94   : 	file = CreateFileW (f, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);

  000ff	6a 00		 push	 0
  00101	6a 00		 push	 0
  00103	6a 03		 push	 3
  00105	6a 00		 push	 0
  00107	6a 00		 push	 0
  00109	68 00 00 00 80	 push	 -2147483648		; 80000000H
  0010e	8d 8c 24 70 02
	00 00		 lea	 ecx, DWORD PTR _f$[esp+1668]
  00115	51		 push	 ecx
  00116	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileW@28
  0011c	8b f0		 mov	 esi, eax

; 95   : 	if (file == INVALID_HANDLE_VALUE) return NULL;

  0011e	83 fe ff	 cmp	 esi, -1
  00121	74 76		 je	 SHORT $LN16@MapNextLan

; 96   : 
; 97   : 	ReadFile (file, LanguageFileBuffer, find.nFileSizeLow, &read, NULL);

  00123	8b 44 24 28	 mov	 eax, DWORD PTR _find$[esp+1676]
  00127	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _LanguageFileBuffer
  0012d	6a 00		 push	 0
  0012f	8d 54 24 08	 lea	 edx, DWORD PTR _read$[esp+1648]
  00133	52		 push	 edx
  00134	50		 push	 eax
  00135	51		 push	 ecx
  00136	56		 push	 esi
  00137	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20

; 98   : 	CloseHandle (file);

  0013d	56		 push	 esi
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 99   : 	if (read != find.nFileSizeLow) return NULL;

  00144	8b 54 24 04	 mov	 edx, DWORD PTR _read$[esp+1644]
  00148	33 c0		 xor	 eax, eax
  0014a	3b 54 24 28	 cmp	 edx, DWORD PTR _find$[esp+1676]
  0014e	5e		 pop	 esi
  0014f	0f 95 c0	 setne	 al
  00152	48		 dec	 eax
  00153	23 05 00 00 00
	00		 and	 eax, DWORD PTR _LanguageFileBuffer

; 100  : 
; 101  : 	return LanguageFileBuffer;
; 102  : }

  00159	8b 8c 24 64 06
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1640]
  00160	33 cc		 xor	 ecx, esp
  00162	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00167	81 c4 68 06 00
	00		 add	 esp, 1640		; 00000668H
  0016d	c3		 ret	 0
$LN9@MapNextLan:

; 76   : 	}
; 77   : 	else if (!FindNextFileW (LanguageFileFindHandle, &find))

  0016e	8d 4c 24 08	 lea	 ecx, DWORD PTR _find$[esp+1644]
  00172	51		 push	 ecx
  00173	50		 push	 eax
  00174	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindNextFileW@8
  0017a	85 c0		 test	 eax, eax
  0017c	0f 85 05 ff ff
	ff		 jne	 $LN6@MapNextLan

; 78   : 	{
; 79   : 		FindClose (LanguageFileFindHandle);

  00182	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _LanguageFileFindHandle
  00188	52		 push	 edx
  00189	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindClose@4

; 80   : 		LanguageFileFindHandle = INVALID_HANDLE_VALUE;

  0018f	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _LanguageFileFindHandle, -1
$LN16@MapNextLan:

; 100  : 
; 101  : 	return LanguageFileBuffer;
; 102  : }

  00199	8b 8c 24 68 06
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1644]
  001a0	5e		 pop	 esi
  001a1	33 cc		 xor	 ecx, esp
  001a3	33 c0		 xor	 eax, eax
  001a5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001aa	81 c4 68 06 00
	00		 add	 esp, 1640		; 00000668H
  001b0	c3		 ret	 0
_MapNextLanguageFile ENDP
_TEXT	ENDS
PUBLIC	_GetPreferredLangId
_BSS	SEGMENT
_PreferredLangId DB 06H DUP (?)
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _GetPreferredLangId
_TEXT	SEGMENT
_GetPreferredLangId PROC				; COMDAT

; 486  : 	return PreferredLangId;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET _PreferredLangId

; 487  : }

  00005	c3		 ret	 0
_GetPreferredLangId ENDP
_TEXT	ENDS
PUBLIC	_SetPreferredLangId
EXTRN	_strncpy:PROC
; Function compile flags: /Ogtpy
;	COMDAT _SetPreferredLangId
_TEXT	SEGMENT
_langId$ = 8						; size = 4
_SetPreferredLangId PROC				; COMDAT

; 492  : 	strncpy (PreferredLangId, langId, 5);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _langId$[esp-4]
  00004	6a 05		 push	 5
  00006	50		 push	 eax
  00007	68 00 00 00 00	 push	 OFFSET _PreferredLangId
  0000c	e8 00 00 00 00	 call	 _strncpy
  00011	83 c4 0c	 add	 esp, 12			; 0000000cH

; 493  : }

  00014	c3		 ret	 0
_SetPreferredLangId ENDP
_TEXT	ENDS
PUBLIC	_GetActiveLangPackVersion
_BSS	SEGMENT
	ALIGN	4

_ActiveLangPackVersion DB 06H DUP (?)
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _GetActiveLangPackVersion
_TEXT	SEGMENT
_GetActiveLangPackVersion PROC				; COMDAT

; 498  : 	return ActiveLangPackVersion;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET _ActiveLangPackVersion

; 499  : }

  00005	c3		 ret	 0
_GetActiveLangPackVersion ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BE@ONAPIBAL@?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$CF?$AAh?$AAs?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$AA@ ; `string'
PUBLIC	_GetString
EXTRN	__snwprintf:PROC
EXTRN	_GetDictionaryValue:PROC
;	COMDAT ??_C@_1BE@ONAPIBAL@?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$CF?$AAh?$AAs?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@ONAPIBAL@?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$CF?$AAh?$AAs?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$AA@ DB '['
	DB	00H, '?', 00H, ']', 00H, '%', 00H, 'h', 00H, 's', 00H, '[', 00H
	DB	'?', 00H, ']', 00H, 00H, 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _GetString
_TEXT	SEGMENT
_stringId$ = 8						; size = 4
_GetString PROC						; COMDAT

; 503  : {

  00000	56		 push	 esi

; 504  : 	WCHAR *str = (WCHAR *) GetDictionaryValue (stringId);

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _stringId$[esp]
  00005	56		 push	 esi
  00006	e8 00 00 00 00	 call	 _GetDictionaryValue
  0000b	83 c4 04	 add	 esp, 4

; 505  : 	if (str != NULL) return str;

  0000e	85 c0		 test	 eax, eax
  00010	75 1d		 jne	 SHORT $LN2@GetString

; 506  : 
; 507  : 	_snwprintf (UnknownString, ARRAY_LENGTH(UnknownString), UNKNOWN_STRING_ID L"%hs" UNKNOWN_STRING_ID, stringId);

  00012	56		 push	 esi
  00013	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@ONAPIBAL@?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$CF?$AAh?$AAs?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$AA@
  00018	68 00 04 00 00	 push	 1024			; 00000400H
  0001d	68 00 00 00 00	 push	 OFFSET _UnknownString
  00022	e8 00 00 00 00	 call	 __snwprintf
  00027	83 c4 10	 add	 esp, 16			; 00000010H

; 508  : 	return UnknownString;

  0002a	b8 00 00 00 00	 mov	 eax, OFFSET _UnknownString
$LN2@GetString:
  0002f	5e		 pop	 esi

; 509  : }

  00030	c3		 ret	 0
_GetString ENDP
_TEXT	ENDS
PUBLIC	_GetFont
; Function compile flags: /Ogtpy
;	COMDAT _GetFont
_TEXT	SEGMENT
_fontType$ = 8						; size = 4
_GetFont PROC						; COMDAT

; 514  : 	return (Font *) GetDictionaryValue (fontType);

  00000	e9 00 00 00 00	 jmp	 _GetDictionaryValue
_GetFont ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@MBEIEFFD@?$CDdefine?5?$CFs?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_06OENKJGA@Header?$AA@			; `string'
PUBLIC	??_C@_06CALLMKCG@IDHELP?$AA@			; `string'
PUBLIC	??_C@_07CIAHAGHC@IDCLOSE?$AA@			; `string'
PUBLIC	??_C@_08DDAIHKOO@IDCANCEL?$AA@			; `string'
PUBLIC	??_C@_04BAADKBID@IDOK?$AA@			; `string'
PUBLIC	??_C@_0CO@OPBINFGK@CipherShed?3?5Error?5while?5decoding@ ; `string'
PUBLIC	??_C@_0DC@NDOJKNIA@CipherShed?3?5Unknown?5?8?2?8?5escape?5s@ ; `string'
PUBLIC	??_C@_03ICHNJLJF@key?$AA@			; `string'
PUBLIC	??_C@_05ENKANFLO@class?$AA@			; `string'
PUBLIC	??_C@_05DONAFDKA@font_?$AA@			; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_C@_04IAGNFIBA@size?$AA@			; `string'
PUBLIC	??_C@_04POCOPAPC@face?$AA@			; `string'
PUBLIC	??_C@_04IOHABJIC@lang?$AA@			; `string'
PUBLIC	??_C@_04EFPADHIC@font?$AA@			; `string'
PUBLIC	??_C@_07CPCPJPKL@version?$AA@			; `string'
PUBLIC	??_C@_06CLEJICHF@langid?$AA@			; `string'
PUBLIC	??_C@_08JGCCIMAA@language?$AA@			; `string'
PUBLIC	??_C@_1BG@INDNNNCG@?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EAI@KOJNONI@?$AAT?$AAh?$AAe?$AA?5?$AAi?$AAn?$AAs?$AAt?$AAa?$AAl?$AAl?$AAe?$AAd?$AA?5?$AAl?$AAa?$AAn?$AAg?$AAu?$AAa?$AAg?$AAe?$AA?5?$AAp?$AAa?$AAc?$AAk?$AA?5?$AAi?$AAs?$AA?5?$AAi@ ; `string'
PUBLIC	??_C@_05KOLFGEDA@DEBUG?$AA@			; `string'
PUBLIC	??_C@_07HFMAKFLF@0?47?44?40?$AA@		; `string'
PUBLIC	??_C@_0N@LEFFHNKM@prog?9version?$AA@		; `string'
PUBLIC	??_C@_0N@MFNNBINO@localization?$AA@		; `string'
PUBLIC	??_C@_06ICGJLFIM@string?$AA@			; `string'
PUBLIC	??_C@_07MMBOFDEG@control?$AA@			; `string'
PUBLIC	??_C@_02LFNMGJAP@en?$AA@			; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_LoadLanguageFile
EXTRN	_strchr:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	_XmlGetNodeText:PROC
EXTRN	_AddDictionaryEntry:PROC
EXTRN	_sscanf:PROC
EXTRN	_AddPoolData:PROC
EXTRN	__imp__MessageBoxW@16:PROC
EXTRN	__swprintf:PROC
EXTRN	_XmlGetAttributeText:PROC
EXTRN	_XmlFindElement:PROC
EXTRN	__imp__MultiByteToWideChar@24:PROC
EXTRN	_ClearDictionaryPool:PROC
EXTRN	__chkstk:PROC
_BSS	SEGMENT
	ALIGN	4

_HeaderResource DD 02H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0O@MBEIEFFD@?$CDdefine?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0O@MBEIEFFD@?$CDdefine?5?$CFs?5?$CFd?$AA@ DB '#define %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06OENKJGA@Header?$AA@
CONST	SEGMENT
??_C@_06OENKJGA@Header?$AA@ DB 'Header', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CALLMKCG@IDHELP?$AA@
CONST	SEGMENT
??_C@_06CALLMKCG@IDHELP?$AA@ DB 'IDHELP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CIAHAGHC@IDCLOSE?$AA@
CONST	SEGMENT
??_C@_07CIAHAGHC@IDCLOSE?$AA@ DB 'IDCLOSE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DDAIHKOO@IDCANCEL?$AA@
CONST	SEGMENT
??_C@_08DDAIHKOO@IDCANCEL?$AA@ DB 'IDCANCEL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04BAADKBID@IDOK?$AA@
CONST	SEGMENT
??_C@_04BAADKBID@IDOK?$AA@ DB 'IDOK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@OPBINFGK@CipherShed?3?5Error?5while?5decoding@
CONST	SEGMENT
??_C@_0CO@OPBINFGK@CipherShed?3?5Error?5while?5decoding@ DB 'CipherShed: '
	DB	'Error while decoding UTF-8 string', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@NDOJKNIA@CipherShed?3?5Unknown?5?8?2?8?5escape?5s@
CONST	SEGMENT
??_C@_0DC@NDOJKNIA@CipherShed?3?5Unknown?5?8?2?8?5escape?5s@ DB 'CipherSh'
	DB	'ed: Unknown ''\'' escape sequence in string', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03ICHNJLJF@key?$AA@
CONST	SEGMENT
??_C@_03ICHNJLJF@key?$AA@ DB 'key', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05ENKANFLO@class?$AA@
CONST	SEGMENT
??_C@_05ENKANFLO@class?$AA@ DB 'class', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DONAFDKA@font_?$AA@
CONST	SEGMENT
??_C@_05DONAFDKA@font_?$AA@ DB 'font_', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IAGNFIBA@size?$AA@
CONST	SEGMENT
??_C@_04IAGNFIBA@size?$AA@ DB 'size', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04POCOPAPC@face?$AA@
CONST	SEGMENT
??_C@_04POCOPAPC@face?$AA@ DB 'face', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IOHABJIC@lang?$AA@
CONST	SEGMENT
??_C@_04IOHABJIC@lang?$AA@ DB 'lang', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EFPADHIC@font?$AA@
CONST	SEGMENT
??_C@_04EFPADHIC@font?$AA@ DB 'font', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CPCPJPKL@version?$AA@
CONST	SEGMENT
??_C@_07CPCPJPKL@version?$AA@ DB 'version', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CLEJICHF@langid?$AA@
CONST	SEGMENT
??_C@_06CLEJICHF@langid?$AA@ DB 'langid', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08JGCCIMAA@language?$AA@
CONST	SEGMENT
??_C@_08JGCCIMAA@language?$AA@ DB 'language', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@INDNNNCG@?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@INDNNNCG@?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AA?$AA@ DB 'C'
	DB	00H, 'i', 00H, 'p', 00H, 'h', 00H, 'e', 00H, 'r', 00H, 'S', 00H
	DB	'h', 00H, 'e', 00H, 'd', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EAI@KOJNONI@?$AAT?$AAh?$AAe?$AA?5?$AAi?$AAn?$AAs?$AAt?$AAa?$AAl?$AAl?$AAe?$AAd?$AA?5?$AAl?$AAa?$AAn?$AAg?$AAu?$AAa?$AAg?$AAe?$AA?5?$AAp?$AAa?$AAc?$AAk?$AA?5?$AAi?$AAs?$AA?5?$AAi@
CONST	SEGMENT
??_C@_1EAI@KOJNONI@?$AAT?$AAh?$AAe?$AA?5?$AAi?$AAn?$AAs?$AAt?$AAa?$AAl?$AAl?$AAe?$AAd?$AA?5?$AAl?$AAa?$AAn?$AAg?$AAu?$AAa?$AAg?$AAe?$AA?5?$AAp?$AAa?$AAc?$AAk?$AA?5?$AAi?$AAs?$AA?5?$AAi@ DB 'T'
	DB	00H, 'h', 00H, 'e', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 's', 00H
	DB	't', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'e', 00H, 'd', 00H, ' '
	DB	00H, 'l', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'u', 00H, 'a', 00H
	DB	'g', 00H, 'e', 00H, ' ', 00H, 'p', 00H, 'a', 00H, 'c', 00H, 'k'
	DB	00H, ' ', 00H, 'i', 00H, 's', 00H, ' ', 00H, 'i', 00H, 'n', 00H
	DB	'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 't', 00H, 'i'
	DB	00H, 'b', 00H, 'l', 00H, 'e', 00H, ' ', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'i', 00H, 's'
	DB	00H, ' ', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 's', 00H, 'i', 00H
	DB	'o', 00H, 'n', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'C'
	DB	00H, 'i', 00H, 'p', 00H, 'h', 00H, 'e', 00H, 'r', 00H, 'S', 00H
	DB	'h', 00H, 'e', 00H, 'd', 00H, ' ', 00H, '(', 00H, 't', 00H, 'h'
	DB	00H, 'e', 00H, ' ', 00H, 'l', 00H, 'a', 00H, 'n', 00H, 'g', 00H
	DB	'u', 00H, 'a', 00H, 'g', 00H, 'e', 00H, ' ', 00H, 'p', 00H, 'a'
	DB	00H, 'c', 00H, 'k', 00H, ' ', 00H, 'i', 00H, 's', 00H, ' ', 00H
	DB	'f', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'C', 00H, 'i', 00H, 'p'
	DB	00H, 'h', 00H, 'e', 00H, 'r', 00H, 'S', 00H, 'h', 00H, 'e', 00H
	DB	'd', 00H, ' ', 00H, '%', 00H, 'h', 00H, 's', 00H, ')', 00H, '.'
	DB	00H, ' ', 00H, 'A', 00H, ' ', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'e', 00H, 'r', 00H, ' ', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 's'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H, 'm', 00H, 'a', 00H
	DB	'y', 00H, ' ', 00H, 'b', 00H, 'e', 00H, ' ', 00H, 'a', 00H, 'v'
	DB	00H, 'a', 00H, 'i', 00H, 'l', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, ' ', 00H, 'a', 00H, 't', 00H, ' ', 00H, 'c', 00H, 'i'
	DB	00H, 'p', 00H, 'h', 00H, 'e', 00H, 'r', 00H, 's', 00H, 'h', 00H
	DB	'e', 00H, 'd', 00H, '.', 00H, 'o', 00H, 'r', 00H, 'g', 00H, '.'
	DB	00H, 0aH, 00H, 0aH, 00H, 'T', 00H, 'o', 00H, ' ', 00H, 'p', 00H
	DB	'r', 00H, 'e', 00H, 'v', 00H, 'e', 00H, 'n', 00H, 't', 00H, ' '
	DB	00H, 't', 00H, 'h', 00H, 'i', 00H, 's', 00H, ' ', 00H, 'm', 00H
	DB	'e', 00H, 's', 00H, 's', 00H, 'a', 00H, 'g', 00H, 'e', 00H, ' '
	DB	00H, 'f', 00H, 'r', 00H, 'o', 00H, 'm', 00H, ' ', 00H, 'b', 00H
	DB	'e', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'd', 00H, 'i'
	DB	00H, 's', 00H, 'p', 00H, 'l', 00H, 'a', 00H, 'y', 00H, 'e', 00H
	DB	'd', 00H, ',', 00H, ' ', 00H, 'd', 00H, 'o', 00H, ' ', 00H, 'a'
	DB	00H, 'n', 00H, 'y', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H
	DB	't', 00H, 'h', 00H, 'e', 00H, ' ', 00H, 'f', 00H, 'o', 00H, 'l'
	DB	00H, 'l', 00H, 'o', 00H, 'w', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	':', 00H, 0aH, 00H, 0aH, 00H, '-', 00H, ' ', 00H, 'S', 00H, 'e'
	DB	00H, 'l', 00H, 'e', 00H, 'c', 00H, 't', 00H, ' ', 00H, '''', 00H
	DB	'S', 00H, 'e', 00H, 't', 00H, 't', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, 's', 00H, '''', 00H, ' ', 00H, '>', 00H, ' ', 00H, '''', 00H
	DB	'L', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'u', 00H, 'a', 00H, 'g'
	DB	00H, 'e', 00H, '''', 00H, ';', 00H, ' ', 00H, 't', 00H, 'h', 00H
	DB	'e', 00H, 'n', 00H, ' ', 00H, 's', 00H, 'e', 00H, 'l', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, ' ', 00H, '''', 00H, 'E', 00H, 'n', 00H
	DB	'g', 00H, 'l', 00H, 'i', 00H, 's', 00H, 'h', 00H, '''', 00H, ' '
	DB	00H, 'a', 00H, 'n', 00H, 'd', 00H, ' ', 00H, 'c', 00H, 'l', 00H
	DB	'i', 00H, 'c', 00H, 'k', 00H, ' ', 00H, '''', 00H, 'O', 00H, 'K'
	DB	00H, '''', 00H, '.', 00H, 0aH, 00H, 0aH, 00H, '-', 00H, ' ', 00H
	DB	'R', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'v', 00H, 'e', 00H, ' '
	DB	00H, 'o', 00H, 'r', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'p', 00H
	DB	'l', 00H, 'a', 00H, 'c', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'h'
	DB	00H, 'e', 00H, ' ', 00H, 'l', 00H, 'a', 00H, 'n', 00H, 'g', 00H
	DB	'u', 00H, 'a', 00H, 'g', 00H, 'e', 00H, ' ', 00H, 'p', 00H, 'a'
	DB	00H, 'c', 00H, 'k', 00H, ' ', 00H, 'w', 00H, 'i', 00H, 't', 00H
	DB	'h', 00H, ' ', 00H, 'a', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'm'
	DB	00H, 'p', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, ' ', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 's', 00H, 'i'
	DB	00H, 'o', 00H, 'n', 00H, ' ', 00H, '(', 00H, 't', 00H, 'h', 00H
	DB	'e', 00H, ' ', 00H, 'l', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'u'
	DB	00H, 'a', 00H, 'g', 00H, 'e', 00H, ' ', 00H, 'p', 00H, 'a', 00H
	DB	'c', 00H, 'k', 00H, ' ', 00H, 'm', 00H, 'a', 00H, 'y', 00H, ' '
	DB	00H, 'r', 00H, 'e', 00H, 's', 00H, 'i', 00H, 'd', 00H, 'e', 00H
	DB	' ', 00H, 'e', 00H, '.', 00H, 'g', 00H, '.', 00H, ' ', 00H, 'i'
	DB	00H, 'n', 00H, ' ', 00H, '''', 00H, 'C', 00H, ':', 00H, '\', 00H
	DB	'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H, 'r', 00H, 'a', 00H, 'm'
	DB	00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 's', 00H
	DB	'\', 00H, 'C', 00H, 'i', 00H, 'p', 00H, 'h', 00H, 'e', 00H, 'r'
	DB	00H, 'S', 00H, 'h', 00H, 'e', 00H, 'd', 00H, '''', 00H, ' ', 00H
	DB	'o', 00H, 'r', 00H, ' ', 00H, '''', 00H, '%', 00H, '%', 00H, 'L'
	DB	00H, 'O', 00H, 'C', 00H, 'A', 00H, 'L', 00H, 'A', 00H, 'P', 00H
	DB	'P', 00H, 'D', 00H, 'A', 00H, 'T', 00H, 'A', 00H, '%', 00H, '%'
	DB	00H, '\', 00H, 'V', 00H, 'i', 00H, 'r', 00H, 't', 00H, 'u', 00H
	DB	'a', 00H, 'l', 00H, 'S', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'e'
	DB	00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H, 'r', 00H
	DB	'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l', 00H, 'e'
	DB	00H, 's', 00H, '\', 00H, 'C', 00H, 'i', 00H, 'p', 00H, 'h', 00H
	DB	'e', 00H, 'r', 00H, 'S', 00H, 'h', 00H, 'e', 00H, 'd', 00H, ''''
	DB	00H, ',', 00H, ' ', 00H, 'e', 00H, 't', 00H, 'c', 00H, '.', 00H
	DB	')', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05KOLFGEDA@DEBUG?$AA@
CONST	SEGMENT
??_C@_05KOLFGEDA@DEBUG?$AA@ DB 'DEBUG', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HFMAKFLF@0?47?44?40?$AA@
CONST	SEGMENT
??_C@_07HFMAKFLF@0?47?44?40?$AA@ DB '0.7.4.0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LEFFHNKM@prog?9version?$AA@
CONST	SEGMENT
??_C@_0N@LEFFHNKM@prog?9version?$AA@ DB 'prog-version', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MFNNBINO@localization?$AA@
CONST	SEGMENT
??_C@_0N@MFNNBINO@localization?$AA@ DB 'localization', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06ICGJLFIM@string?$AA@
CONST	SEGMENT
??_C@_06ICGJLFIM@string?$AA@ DB 'string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MMBOFDEG@control?$AA@
CONST	SEGMENT
??_C@_07MMBOFDEG@control?$AA@ DB 'control', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02LFNMGJAP@en?$AA@
CONST	SEGMENT
??_C@_02LFNMGJAP@en?$AA@ DB 'en', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _LoadLanguageFile
_TEXT	SEGMENT
_defaultLangParsed$ = -102600				; size = 4
_res$ = -102596						; size = 4
_i$ = -102592						; size = 4
_langFound$ = -102588					; size = 4
_font$86220 = -102584					; size = 8
_size$ = -102576					; size = 4
_intKey$ = -102572					; size = 4
_headers$ = -102568					; size = 12
_xmlElements$ = -102556					; size = 12
_langId$ = -102544					; size = 6
_key$ = -102536						; size = 128
_m$86199 = -102408					; size = 4096
_attr$ = -98312						; size = 32768
_wattr$ = -65544					; size = 65536
__$ArrayPad$ = -4					; size = 4
_LoadLanguageFile PROC					; COMDAT

; 106  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	b8 cc 90 01 00	 mov	 eax, 102604		; 000190ccH
  0000b	e8 00 00 00 00	 call	 __chkstk
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	89 84 24 c8 90
	01 00		 mov	 DWORD PTR __$ArrayPad$[esp+102604], eax

; 107  : 	DWORD size;
; 108  : 	BYTE *res;
; 109  : 	char *xml, *header;
; 110  : 	char langId[6] = "en", attr[32768], key[128];

  0001e	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_02LFNMGJAP@en?$AA@
  00024	8a 0d 02 00 00
	00		 mov	 cl, BYTE PTR ??_C@_02LFNMGJAP@en?$AA@+2
  0002a	53		 push	 ebx
  0002b	56		 push	 esi
  0002c	33 f6		 xor	 esi, esi
  0002e	66 89 44 24 44	 mov	 WORD PTR _langId$[esp+102612], ax
  00033	33 c0		 xor	 eax, eax
  00035	57		 push	 edi
  00036	88 4c 24 4a	 mov	 BYTE PTR _langId$[esp+102618], cl
  0003a	66 89 44 24 4b	 mov	 WORD PTR _langId$[esp+102619], ax
  0003f	88 44 24 4d	 mov	 BYTE PTR _langId$[esp+102621], al

; 111  : 	BOOL defaultLangParsed = FALSE, langFound = FALSE;

  00043	89 74 24 10	 mov	 DWORD PTR _defaultLangParsed$[esp+102616], esi
  00047	89 74 24 1c	 mov	 DWORD PTR _langFound$[esp+102616], esi

; 112  : 	WCHAR wattr[32768];
; 113  : 	int i, intKey, len;
; 114  : 
; 115  : 	char *xmlElements[] = {"control", "string", 0};

  0004b	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR _xmlElements$[esp+102616], OFFSET ??_C@_07MMBOFDEG@control?$AA@
  00053	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR _xmlElements$[esp+102620], OFFSET ??_C@_06ICGJLFIM@string?$AA@
  0005b	89 74 24 44	 mov	 DWORD PTR _xmlElements$[esp+102624], esi

; 116  : 
; 117  : #ifdef TCMOUNT
; 118  : 	int headers[] = { IDR_COMMON_RSRC_HEADER, IDR_MOUNT_RSRC_HEADER, 0 };

  0005f	c7 44 24 30 00
	02 00 00	 mov	 DWORD PTR _headers$[esp+102616], 512 ; 00000200H
  00067	c7 44 24 34 6d
	00 00 00	 mov	 DWORD PTR _headers$[esp+102620], 109 ; 0000006dH
  0006f	89 74 24 38	 mov	 DWORD PTR _headers$[esp+102624], esi

; 119  : #endif
; 120  : 
; 121  : #ifdef VOLFORMAT
; 122  : 	int headers[] = { IDR_COMMON_RSRC_HEADER, IDR_FORMAT_RSRC_HEADER, 0 };
; 123  : #endif
; 124  : 
; 125  : #ifdef SETUP
; 126  : 	int headers[] = { IDR_COMMON_RSRC_HEADER, IDR_SETUP_RSRC_HEADER, 0 };
; 127  : #endif
; 128  : 
; 129  : 	LocalizationActive = FALSE;

  00073	89 35 00 00 00
	00		 mov	 DWORD PTR _LocalizationActive, esi

; 130  : 	ActiveLangPackVersion[0] = 0;

  00079	a2 00 00 00 00	 mov	 BYTE PTR _ActiveLangPackVersion, al

; 131  : 	ClearDictionaryPool ();

  0007e	e8 00 00 00 00	 call	 _ClearDictionaryPool

; 132  : 
; 133  : 	if (PreferredLangId[0] != 0)

  00083	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _PreferredLangId, 0
  0008a	74 13		 je	 SHORT $LN51@LoadLangua

; 134  : 		strcpy (langId, PreferredLangId);

  0008c	33 c0		 xor	 eax, eax
  0008e	8b ff		 npad	 2
$LL54@LoadLangua:
  00090	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR _PreferredLangId[eax]
  00096	88 4c 04 48	 mov	 BYTE PTR _langId$[esp+eax+102616], cl
  0009a	40		 inc	 eax
  0009b	84 c9		 test	 cl, cl
  0009d	75 f1		 jne	 SHORT $LL54@LoadLangua
$LN51@LoadLangua:

; 135  : 
; 136  : 	// Parse all available language files until preferred language is found
; 137  : 	for (res = MapFirstLanguageFile (); res != NULL; res = MapNextLanguageFile ())

  0009f	e8 00 00 00 00	 call	 _MapFirstLanguageFile
  000a4	89 44 24 14	 mov	 DWORD PTR _res$[esp+102616], eax
  000a8	3b c6		 cmp	 eax, esi
  000aa	0f 84 e5 05 00
	00		 je	 $LN55@LoadLangua
  000b0	8b f8		 mov	 edi, eax
$LL125@LoadLangua:
  000b2	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__MultiByteToWideChar@24

; 138  : 	{
; 139  : 		xml = (char *) res;
; 140  : 		xml = XmlFindElement (xml, "localization");

  000b8	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MFNNBINO@localization?$AA@
  000bd	57		 push	 edi
  000be	e8 00 00 00 00	 call	 _XmlFindElement
  000c3	8b f0		 mov	 esi, eax
  000c5	83 c4 08	 add	 esp, 8

; 141  : 		if (!xml)

  000c8	85 f6		 test	 esi, esi
  000ca	0f 84 23 05 00
	00		 je	 $LN49@LoadLangua

; 142  : 			continue;
; 143  : 
; 144  : 		// Required CipherShed version
; 145  : 		XmlGetAttributeText (xml, "prog-version", attr, sizeof (attr));

  000d0	68 00 80 00 00	 push	 32768			; 00008000H
  000d5	8d 94 24 d4 10
	00 00		 lea	 edx, DWORD PTR _attr$[esp+102620]
  000dc	52		 push	 edx
  000dd	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LEFFHNKM@prog?9version?$AA@
  000e2	56		 push	 esi
  000e3	e8 00 00 00 00	 call	 _XmlGetAttributeText
  000e8	83 c4 10	 add	 esp, 16			; 00000010H

; 146  : 
; 147  : 		// Check version of external language file
; 148  : 		if (defaultLangParsed && strcmp (attr, VERSION_STRING) && strcmp (attr, "DEBUG"))

  000eb	83 7c 24 10 00	 cmp	 DWORD PTR _defaultLangParsed$[esp+102616], 0
  000f0	0f 84 41 01 00
	00		 je	 $LN41@LoadLangua
  000f6	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_07HFMAKFLF@0?47?44?40?$AA@
  000fb	8d 84 24 d0 10
	00 00		 lea	 eax, DWORD PTR _attr$[esp+102616]
$LL95@LoadLangua:
  00102	8a 10		 mov	 dl, BYTE PTR [eax]
  00104	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00106	75 1a		 jne	 SHORT $LN96@LoadLangua
  00108	84 d2		 test	 dl, dl
  0010a	74 12		 je	 SHORT $LN97@LoadLangua
  0010c	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0010f	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00112	75 0e		 jne	 SHORT $LN96@LoadLangua
  00114	83 c0 02	 add	 eax, 2
  00117	83 c1 02	 add	 ecx, 2
  0011a	84 d2		 test	 dl, dl
  0011c	75 e4		 jne	 SHORT $LL95@LoadLangua
$LN97@LoadLangua:
  0011e	33 c0		 xor	 eax, eax
  00120	eb 05		 jmp	 SHORT $LN98@LoadLangua
$LN96@LoadLangua:
  00122	1b c0		 sbb	 eax, eax
  00124	83 d8 ff	 sbb	 eax, -1
$LN98@LoadLangua:
  00127	85 c0		 test	 eax, eax
  00129	74 6e		 je	 SHORT $LN46@LoadLangua
  0012b	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_05KOLFGEDA@DEBUG?$AA@
  00130	8d 84 24 d0 10
	00 00		 lea	 eax, DWORD PTR _attr$[esp+102616]
$LL99@LoadLangua:
  00137	8a 10		 mov	 dl, BYTE PTR [eax]
  00139	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0013b	75 1a		 jne	 SHORT $LN100@LoadLangua
  0013d	84 d2		 test	 dl, dl
  0013f	74 12		 je	 SHORT $LN101@LoadLangua
  00141	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00144	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00147	75 0e		 jne	 SHORT $LN100@LoadLangua
  00149	83 c0 02	 add	 eax, 2
  0014c	83 c1 02	 add	 ecx, 2
  0014f	84 d2		 test	 dl, dl
  00151	75 e4		 jne	 SHORT $LL99@LoadLangua
$LN101@LoadLangua:
  00153	33 c0		 xor	 eax, eax
  00155	eb 05		 jmp	 SHORT $LN102@LoadLangua
$LN100@LoadLangua:
  00157	1b c0		 sbb	 eax, eax
  00159	83 d8 ff	 sbb	 eax, -1
$LN102@LoadLangua:
  0015c	85 c0		 test	 eax, eax
  0015e	74 39		 je	 SHORT $LN46@LoadLangua

; 149  : 		{
; 150  : 			wchar_t m[2048];
; 151  : 			swprintf (m, L"The installed language pack is incompatible with this version of CipherShed (the language pack is for CipherShed %hs). A newer version may be available at ciphershed.org.\n\nTo prevent this message from being displayed, do any of the following:\n\n- Select 'Settings' > 'Language'; then select 'English' and click 'OK'.\n\n- Remove or replace the language pack with a compatible version (the language pack may reside e.g. in 'C:\\Program Files\\CipherShed' or '%%LOCALAPPDATA%%\\VirtualStore\\Program Files\\CipherShed', etc.)", attr);

  00160	8d 84 24 d0 10
	00 00		 lea	 eax, DWORD PTR _attr$[esp+102616]
  00167	50		 push	 eax
  00168	8d 8c 24 d4 00
	00 00		 lea	 ecx, DWORD PTR _m$86199[esp+102620]
  0016f	68 00 00 00 00	 push	 OFFSET ??_C@_1EAI@KOJNONI@?$AAT?$AAh?$AAe?$AA?5?$AAi?$AAn?$AAs?$AAt?$AAa?$AAl?$AAl?$AAe?$AAd?$AA?5?$AAl?$AAa?$AAn?$AAg?$AAu?$AAa?$AAg?$AAe?$AA?5?$AAp?$AAa?$AAc?$AAk?$AA?5?$AAi?$AAs?$AA?5?$AAi@
  00174	51		 push	 ecx
  00175	e8 00 00 00 00	 call	 __swprintf
  0017a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 152  : 			MessageBoxW (NULL, m, L"CipherShed", MB_ICONERROR);

  0017d	6a 10		 push	 16			; 00000010H
  0017f	68 00 00 00 00	 push	 OFFSET ??_C@_1BG@INDNNNCG@?$AAC?$AAi?$AAp?$AAh?$AAe?$AAr?$AAS?$AAh?$AAe?$AAd?$AA?$AA@
  00184	8d 94 24 d8 00
	00 00		 lea	 edx, DWORD PTR _m$86199[esp+102624]
  0018b	52		 push	 edx
  0018c	6a 00		 push	 0
  0018e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 153  : 			continue;

  00194	e9 5a 04 00 00	 jmp	 $LN49@LoadLangua
$LN46@LoadLangua:

; 154  : 		}
; 155  : 
; 156  : 		// Search language id in language file
; 157  : 		if (defaultLangParsed)
; 158  : 		{
; 159  : 			while (xml = XmlFindElement (xml, "language"))

  00199	68 00 00 00 00	 push	 OFFSET ??_C@_08JGCCIMAA@language?$AA@
  0019e	56		 push	 esi
  0019f	e8 00 00 00 00	 call	 _XmlFindElement
  001a4	8b f0		 mov	 esi, eax
  001a6	83 c4 08	 add	 esp, 8
  001a9	85 f6		 test	 esi, esi
  001ab	0f 84 42 04 00
	00		 je	 $LN49@LoadLangua
$LL44@LoadLangua:

; 160  : 			{
; 161  : 				XmlGetAttributeText (xml, "langid", attr, sizeof (attr));

  001b1	68 00 80 00 00	 push	 32768			; 00008000H
  001b6	8d 84 24 d4 10
	00 00		 lea	 eax, DWORD PTR _attr$[esp+102620]
  001bd	50		 push	 eax
  001be	68 00 00 00 00	 push	 OFFSET ??_C@_06CLEJICHF@langid?$AA@
  001c3	56		 push	 esi
  001c4	e8 00 00 00 00	 call	 _XmlGetAttributeText
  001c9	83 c4 10	 add	 esp, 16			; 00000010H

; 162  : 				if (strcmp (attr, langId) == 0)

  001cc	8d 4c 24 48	 lea	 ecx, DWORD PTR _langId$[esp+102616]
  001d0	8d 84 24 d0 10
	00 00		 lea	 eax, DWORD PTR _attr$[esp+102616]
$LL103@LoadLangua:
  001d7	8a 10		 mov	 dl, BYTE PTR [eax]
  001d9	3a 11		 cmp	 dl, BYTE PTR [ecx]
  001db	75 1a		 jne	 SHORT $LN104@LoadLangua
  001dd	84 d2		 test	 dl, dl
  001df	74 12		 je	 SHORT $LN105@LoadLangua
  001e1	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  001e4	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  001e7	75 0e		 jne	 SHORT $LN104@LoadLangua
  001e9	83 c0 02	 add	 eax, 2
  001ec	83 c1 02	 add	 ecx, 2
  001ef	84 d2		 test	 dl, dl
  001f1	75 e4		 jne	 SHORT $LL103@LoadLangua
$LN105@LoadLangua:
  001f3	33 c0		 xor	 eax, eax
  001f5	eb 05		 jmp	 SHORT $LN106@LoadLangua
$LN104@LoadLangua:
  001f7	1b c0		 sbb	 eax, eax
  001f9	83 d8 ff	 sbb	 eax, -1
$LN106@LoadLangua:
  001fc	85 c0		 test	 eax, eax
  001fe	74 1a		 je	 SHORT $LN81@LoadLangua
  00200	68 00 00 00 00	 push	 OFFSET ??_C@_08JGCCIMAA@language?$AA@

; 166  : 					break;
; 167  : 				}
; 168  : 				xml++;

  00205	46		 inc	 esi
  00206	56		 push	 esi
  00207	e8 00 00 00 00	 call	 _XmlFindElement
  0020c	8b f0		 mov	 esi, eax
  0020e	83 c4 08	 add	 esp, 8
  00211	85 f6		 test	 esi, esi
  00213	75 9c		 jne	 SHORT $LL44@LoadLangua

; 298  : 		if (header == NULL) return FALSE;

  00215	e9 d9 03 00 00	 jmp	 $LN49@LoadLangua
$LN81@LoadLangua:

; 163  : 				{
; 164  : 					XmlGetAttributeText (xml++, "version", ActiveLangPackVersion, sizeof (ActiveLangPackVersion));

  0021a	6a 06		 push	 6
  0021c	68 00 00 00 00	 push	 OFFSET _ActiveLangPackVersion
  00221	68 00 00 00 00	 push	 OFFSET ??_C@_07CPCPJPKL@version?$AA@
  00226	56		 push	 esi
  00227	e8 00 00 00 00	 call	 _XmlGetAttributeText
  0022c	83 c4 10	 add	 esp, 16			; 00000010H

; 165  : 					langFound = TRUE;

  0022f	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR _langFound$[esp+102616], 1
$LN41@LoadLangua:

; 169  : 			}
; 170  : 
; 171  : 			if (!langFound) continue;
; 172  : 		}
; 173  : 
; 174  : 		// Create font dictionary
; 175  : 		xml = (char *) res;
; 176  : 		while (xml = XmlFindElement (xml, "font"))

  00237	68 00 00 00 00	 push	 OFFSET ??_C@_04EFPADHIC@font?$AA@
  0023c	57		 push	 edi
  0023d	e8 00 00 00 00	 call	 _XmlFindElement
  00242	8b f0		 mov	 esi, eax
  00244	83 c4 08	 add	 esp, 8
  00247	85 f6		 test	 esi, esi
  00249	0f 84 79 01 00
	00		 je	 $LN39@LoadLangua
  0024f	90		 npad	 1
$LL40@LoadLangua:

; 177  : 		{
; 178  : 			XmlGetAttributeText (xml, "lang", attr, sizeof (attr));

  00250	68 00 80 00 00	 push	 32768			; 00008000H
  00255	8d 8c 24 d4 10
	00 00		 lea	 ecx, DWORD PTR _attr$[esp+102620]
  0025c	51		 push	 ecx
  0025d	68 00 00 00 00	 push	 OFFSET ??_C@_04IOHABJIC@lang?$AA@
  00262	56		 push	 esi
  00263	e8 00 00 00 00	 call	 _XmlGetAttributeText
  00268	83 c4 10	 add	 esp, 16			; 00000010H

; 179  : 			if (!defaultLangParsed
; 180  : 				|| strcmp (attr, langId) == 0)

  0026b	83 7c 24 10 00	 cmp	 DWORD PTR _defaultLangParsed$[esp+102616], 0
  00270	74 3b		 je	 SHORT $LN37@LoadLangua
  00272	8d 4c 24 48	 lea	 ecx, DWORD PTR _langId$[esp+102616]
  00276	8d 84 24 d0 10
	00 00		 lea	 eax, DWORD PTR _attr$[esp+102616]
  0027d	8d 49 00	 npad	 3
$LL107@LoadLangua:
  00280	8a 10		 mov	 dl, BYTE PTR [eax]
  00282	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00284	75 1a		 jne	 SHORT $LN108@LoadLangua
  00286	84 d2		 test	 dl, dl
  00288	74 12		 je	 SHORT $LN109@LoadLangua
  0028a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0028d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00290	75 0e		 jne	 SHORT $LN108@LoadLangua
  00292	83 c0 02	 add	 eax, 2
  00295	83 c1 02	 add	 ecx, 2
  00298	84 d2		 test	 dl, dl
  0029a	75 e4		 jne	 SHORT $LL107@LoadLangua
$LN109@LoadLangua:
  0029c	33 c0		 xor	 eax, eax
  0029e	eb 05		 jmp	 SHORT $LN110@LoadLangua
$LN108@LoadLangua:
  002a0	1b c0		 sbb	 eax, eax
  002a2	83 d8 ff	 sbb	 eax, -1
$LN110@LoadLangua:
  002a5	85 c0		 test	 eax, eax
  002a7	0f 85 02 01 00
	00		 jne	 $LN38@LoadLangua
$LN37@LoadLangua:

; 181  : 			{
; 182  : 				Font font;
; 183  : 				memset (&font, 0, sizeof (font));
; 184  : 
; 185  : 				XmlGetAttributeText (xml, "face", attr, sizeof (attr));

  002ad	68 00 80 00 00	 push	 32768			; 00008000H
  002b2	8d 94 24 d4 10
	00 00		 lea	 edx, DWORD PTR _attr$[esp+102620]
  002b9	52		 push	 edx
  002ba	33 c0		 xor	 eax, eax
  002bc	68 00 00 00 00	 push	 OFFSET ??_C@_04POCOPAPC@face?$AA@
  002c1	56		 push	 esi
  002c2	89 44 24 30	 mov	 DWORD PTR _font$86220[esp+102632], eax
  002c6	89 44 24 34	 mov	 DWORD PTR _font$86220[esp+102636], eax
  002ca	e8 00 00 00 00	 call	 _XmlGetAttributeText
  002cf	83 c4 10	 add	 esp, 16			; 00000010H

; 186  : 			
; 187  : 				len = MultiByteToWideChar (CP_UTF8, 0, attr, -1, wattr, sizeof (wattr) / sizeof(wattr[0]));

  002d2	68 00 80 00 00	 push	 32768			; 00008000H
  002d7	8d 84 24 d4 90
	00 00		 lea	 eax, DWORD PTR _wattr$[esp+102620]
  002de	50		 push	 eax
  002df	6a ff		 push	 -1
  002e1	8d 8c 24 dc 10
	00 00		 lea	 ecx, DWORD PTR _attr$[esp+102628]
  002e8	51		 push	 ecx
  002e9	6a 00		 push	 0
  002eb	68 e9 fd 00 00	 push	 65001			; 0000fde9H
  002f0	ff d3		 call	 ebx

; 188  : 				font.FaceName = AddPoolData ((void *) wattr, len * 2);

  002f2	8d 14 00	 lea	 edx, DWORD PTR [eax+eax]
  002f5	52		 push	 edx
  002f6	8d 84 24 d4 90
	00 00		 lea	 eax, DWORD PTR _wattr$[esp+102620]
  002fd	50		 push	 eax
  002fe	e8 00 00 00 00	 call	 _AddPoolData

; 189  : 				
; 190  : 				XmlGetAttributeText (xml, "size", attr, sizeof (attr));

  00303	68 00 80 00 00	 push	 32768			; 00008000H
  00308	8d 8c 24 dc 10
	00 00		 lea	 ecx, DWORD PTR _attr$[esp+102628]
  0030f	51		 push	 ecx
  00310	68 00 00 00 00	 push	 OFFSET ??_C@_04IAGNFIBA@size?$AA@
  00315	56		 push	 esi
  00316	89 44 24 38	 mov	 DWORD PTR _font$86220[esp+102640], eax
  0031a	e8 00 00 00 00	 call	 _XmlGetAttributeText

; 191  : 				sscanf (attr, "%d", &font.Size);

  0031f	8d 54 24 3c	 lea	 edx, DWORD PTR _font$86220[esp+102644]
  00323	52		 push	 edx
  00324	8d 84 24 ec 10
	00 00		 lea	 eax, DWORD PTR _attr$[esp+102644]
  0032b	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00330	50		 push	 eax
  00331	e8 00 00 00 00	 call	 _sscanf

; 192  : 
; 193  : 				strcpy (attr, "font_");

  00336	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_05DONAFDKA@font_?$AA@
  0033c	66 8b 15 04 00
	00 00		 mov	 dx, WORD PTR ??_C@_05DONAFDKA@font_?$AA@+4

; 194  : 				XmlGetAttributeText (xml, "class", attr + 5, sizeof (attr) - 5);

  00343	68 fb 7f 00 00	 push	 32763			; 00007ffbH
  00348	8d 84 24 fd 10
	00 00		 lea	 eax, DWORD PTR _attr$[esp+102661]
  0034f	50		 push	 eax
  00350	68 00 00 00 00	 push	 OFFSET ??_C@_05ENKANFLO@class?$AA@
  00355	56		 push	 esi
  00356	89 8c 24 04 11
	00 00		 mov	 DWORD PTR _attr$[esp+102668], ecx
  0035d	66 89 94 24 08
	11 00 00	 mov	 WORD PTR _attr$[esp+102672], dx
  00365	e8 00 00 00 00	 call	 _XmlGetAttributeText

; 195  : 				AddDictionaryEntry (
; 196  : 					AddPoolData ((void *) attr, strlen (attr) + 1), 0,
; 197  : 					AddPoolData ((void *) &font, sizeof(font)));

  0036a	8d 84 24 04 11
	00 00		 lea	 eax, DWORD PTR _attr$[esp+102668]
  00371	83 c4 34	 add	 esp, 52			; 00000034H
  00374	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
$LL111@LoadLangua:
  00377	8a 10		 mov	 dl, BYTE PTR [eax]
  00379	40		 inc	 eax
  0037a	84 d2		 test	 dl, dl
  0037c	75 f9		 jne	 SHORT $LL111@LoadLangua
  0037e	2b c1		 sub	 eax, ecx
  00380	8d 4c 24 20	 lea	 ecx, DWORD PTR _font$86220[esp+102616]
  00384	6a 08		 push	 8
  00386	51		 push	 ecx
  00387	8b f8		 mov	 edi, eax
  00389	e8 00 00 00 00	 call	 _AddPoolData
  0038e	83 c4 08	 add	 esp, 8
  00391	50		 push	 eax
  00392	6a 00		 push	 0
  00394	47		 inc	 edi
  00395	8d 94 24 d8 10
	00 00		 lea	 edx, DWORD PTR _attr$[esp+102624]
  0039c	57		 push	 edi
  0039d	52		 push	 edx
  0039e	e8 00 00 00 00	 call	 _AddPoolData
  003a3	83 c4 08	 add	 esp, 8
  003a6	50		 push	 eax
  003a7	e8 00 00 00 00	 call	 _AddDictionaryEntry
  003ac	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN38@LoadLangua:
  003af	68 00 00 00 00	 push	 OFFSET ??_C@_04EFPADHIC@font?$AA@

; 198  : 			}
; 199  : 
; 200  : 			xml++;

  003b4	46		 inc	 esi
  003b5	56		 push	 esi
  003b6	e8 00 00 00 00	 call	 _XmlFindElement
  003bb	8b f0		 mov	 esi, eax
  003bd	83 c4 08	 add	 esp, 8
  003c0	85 f6		 test	 esi, esi
  003c2	0f 85 88 fe ff
	ff		 jne	 $LL40@LoadLangua
$LN39@LoadLangua:

; 201  : 		}
; 202  : 
; 203  : 		// Create string and control dictionaries
; 204  : 		for (i = 0; xmlElements[i] != 0; i++)

  003c8	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _i$[esp+102616], 0
  003d0	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_07MMBOFDEG@control?$AA@
$LL36@LoadLangua:

; 205  : 		{
; 206  : 			xml = (char *) res;
; 207  : 			while (xml = XmlFindElement (xml, xmlElements[i]))

  003d5	8b 44 24 14	 mov	 eax, DWORD PTR _res$[esp+102616]
  003d9	53		 push	 ebx
  003da	50		 push	 eax
  003db	e8 00 00 00 00	 call	 _XmlFindElement
  003e0	8b f8		 mov	 edi, eax
  003e2	83 c4 08	 add	 esp, 8
  003e5	85 ff		 test	 edi, edi
  003e7	0f 84 99 01 00
	00		 je	 $LN35@LoadLangua
  003ed	8d 49 00	 npad	 3
$LL33@LoadLangua:

; 208  : 			{
; 209  : 				void *key;
; 210  : 				void *text;
; 211  : 
; 212  : 				XmlGetAttributeText (xml, "lang", attr, sizeof (attr));

  003f0	68 00 80 00 00	 push	 32768			; 00008000H
  003f5	8d 8c 24 d4 10
	00 00		 lea	 ecx, DWORD PTR _attr$[esp+102620]
  003fc	51		 push	 ecx
  003fd	68 00 00 00 00	 push	 OFFSET ??_C@_04IOHABJIC@lang?$AA@
  00402	57		 push	 edi
  00403	e8 00 00 00 00	 call	 _XmlGetAttributeText
  00408	83 c4 10	 add	 esp, 16			; 00000010H

; 213  : 				if (!defaultLangParsed
; 214  : 					|| strcmp (attr, langId) == 0)

  0040b	83 7c 24 10 00	 cmp	 DWORD PTR _defaultLangParsed$[esp+102616], 0
  00410	74 3b		 je	 SHORT $LN30@LoadLangua
  00412	8d 4c 24 48	 lea	 ecx, DWORD PTR _langId$[esp+102616]
  00416	8d 84 24 d0 10
	00 00		 lea	 eax, DWORD PTR _attr$[esp+102616]
  0041d	8d 49 00	 npad	 3
$LL112@LoadLangua:
  00420	8a 10		 mov	 dl, BYTE PTR [eax]
  00422	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00424	75 1a		 jne	 SHORT $LN113@LoadLangua
  00426	84 d2		 test	 dl, dl
  00428	74 12		 je	 SHORT $LN114@LoadLangua
  0042a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0042d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00430	75 0e		 jne	 SHORT $LN113@LoadLangua
  00432	83 c0 02	 add	 eax, 2
  00435	83 c1 02	 add	 ecx, 2
  00438	84 d2		 test	 dl, dl
  0043a	75 e4		 jne	 SHORT $LL112@LoadLangua
$LN114@LoadLangua:
  0043c	33 c0		 xor	 eax, eax
  0043e	eb 05		 jmp	 SHORT $LN115@LoadLangua
$LN113@LoadLangua:
  00440	1b c0		 sbb	 eax, eax
  00442	83 d8 ff	 sbb	 eax, -1
$LN115@LoadLangua:
  00445	85 c0		 test	 eax, eax
  00447	0f 85 24 01 00
	00		 jne	 $LN29@LoadLangua
$LN30@LoadLangua:

; 215  : 				{
; 216  : 					if (XmlGetAttributeText (xml, "key", attr, sizeof (attr)))

  0044d	68 00 80 00 00	 push	 32768			; 00008000H
  00452	8d 94 24 d4 10
	00 00		 lea	 edx, DWORD PTR _attr$[esp+102620]
  00459	52		 push	 edx
  0045a	68 00 00 00 00	 push	 OFFSET ??_C@_03ICHNJLJF@key?$AA@
  0045f	57		 push	 edi
  00460	e8 00 00 00 00	 call	 _XmlGetAttributeText
  00465	83 c4 10	 add	 esp, 16			; 00000010H
  00468	85 c0		 test	 eax, eax
  0046a	0f 84 01 01 00
	00		 je	 $LN29@LoadLangua

; 217  : 					{
; 218  : 						key = AddPoolData (attr, strlen (attr) + 1);

  00470	8d 84 24 d0 10
	00 00		 lea	 eax, DWORD PTR _attr$[esp+102616]
  00477	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0047a	8d 9b 00 00 00
	00		 npad	 6
$LL116@LoadLangua:
  00480	8a 08		 mov	 cl, BYTE PTR [eax]
  00482	40		 inc	 eax
  00483	84 c9		 test	 cl, cl
  00485	75 f9		 jne	 SHORT $LL116@LoadLangua
  00487	2b c2		 sub	 eax, edx
  00489	40		 inc	 eax
  0048a	50		 push	 eax
  0048b	8d 84 24 d4 10
	00 00		 lea	 eax, DWORD PTR _attr$[esp+102620]
  00492	50		 push	 eax
  00493	e8 00 00 00 00	 call	 _AddPoolData
  00498	8b f0		 mov	 esi, eax
  0049a	83 c4 08	 add	 esp, 8

; 219  : 						if (key == NULL) return FALSE;

  0049d	85 f6		 test	 esi, esi
  0049f	0f 84 76 01 00
	00		 je	 $LN83@LoadLangua

; 220  : 
; 221  : 						XmlGetNodeText (xml, attr, sizeof (attr));

  004a5	68 00 80 00 00	 push	 32768			; 00008000H
  004aa	8d 8c 24 d4 10
	00 00		 lea	 ecx, DWORD PTR _attr$[esp+102620]
  004b1	51		 push	 ecx
  004b2	57		 push	 edi
  004b3	e8 00 00 00 00	 call	 _XmlGetNodeText
  004b8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 222  : 
; 223  : 						// Parse \ escape sequences
; 224  : 						{
; 225  : 							char *in = attr, *out = attr;
; 226  : 							while (*in)

  004bb	80 bc 24 d0 10
	00 00 00	 cmp	 BYTE PTR _attr$[esp+102616], 0
  004c3	8d 8c 24 d0 10
	00 00		 lea	 ecx, DWORD PTR _attr$[esp+102616]
  004ca	8b c1		 mov	 eax, ecx
  004cc	74 41		 je	 SHORT $LN26@LoadLangua
  004ce	8b ff		 npad	 2
$LL27@LoadLangua:

; 227  : 							{
; 228  : 								if (*in == '\\')

  004d0	8a 11		 mov	 dl, BYTE PTR [ecx]
  004d2	80 fa 5c	 cmp	 dl, 92			; 0000005cH
  004d5	75 2f		 jne	 SHORT $LN25@LoadLangua

; 229  : 								{
; 230  : 									in++;
; 231  : 									switch (*in++)

  004d7	0f be 51 01	 movsx	 edx, BYTE PTR [ecx+1]
  004db	41		 inc	 ecx
  004dc	41		 inc	 ecx
  004dd	83 fa 5c	 cmp	 edx, 92			; 0000005cH
  004e0	74 1e		 je	 SHORT $LN22@LoadLangua
  004e2	83 fa 6e	 cmp	 edx, 110		; 0000006eH
  004e5	74 0f		 je	 SHORT $LN20@LoadLangua
  004e7	83 fa 74	 cmp	 edx, 116		; 00000074H
  004ea	0f 85 1b 01 00
	00		 jne	 $LN82@LoadLangua

; 234  : 									case 't': *out++ = '\t'; break;

  004f0	c6 00 09	 mov	 BYTE PTR [eax], 9
  004f3	40		 inc	 eax
  004f4	eb 14		 jmp	 SHORT $LN18@LoadLangua
$LN20@LoadLangua:

; 235  : 									case 'n': *out++ = 13; *out++ = 10; break;

  004f6	c6 00 0d	 mov	 BYTE PTR [eax], 13	; 0000000dH
  004f9	40		 inc	 eax
  004fa	c6 00 0a	 mov	 BYTE PTR [eax], 10	; 0000000aH
  004fd	40		 inc	 eax
  004fe	eb 0a		 jmp	 SHORT $LN18@LoadLangua
$LN22@LoadLangua:

; 232  : 									{
; 233  : 									case '\\': *out++ = '\\'; break;

  00500	c6 00 5c	 mov	 BYTE PTR [eax], 92	; 0000005cH
  00503	40		 inc	 eax

; 239  : 									}
; 240  : 								}
; 241  : 								else

  00504	eb 04		 jmp	 SHORT $LN18@LoadLangua
$LN25@LoadLangua:

; 242  : 									*out++ = *in++;

  00506	88 10		 mov	 BYTE PTR [eax], dl
  00508	40		 inc	 eax
  00509	41		 inc	 ecx
$LN18@LoadLangua:

; 222  : 
; 223  : 						// Parse \ escape sequences
; 224  : 						{
; 225  : 							char *in = attr, *out = attr;
; 226  : 							while (*in)

  0050a	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0050d	75 c1		 jne	 SHORT $LL27@LoadLangua
$LN26@LoadLangua:

; 243  : 							}
; 244  : 							*out = 0;
; 245  : 						}
; 246  : 
; 247  : 						// UTF8 => wide char
; 248  : 						len = MultiByteToWideChar (CP_UTF8, 0, attr, -1, wattr, sizeof (wattr) / sizeof(wattr[0]));

  0050f	68 00 80 00 00	 push	 32768			; 00008000H
  00514	8d 94 24 d4 90
	00 00		 lea	 edx, DWORD PTR _wattr$[esp+102620]
  0051b	52		 push	 edx
  0051c	6a ff		 push	 -1
  0051e	c6 00 00	 mov	 BYTE PTR [eax], 0
  00521	8d 84 24 dc 10
	00 00		 lea	 eax, DWORD PTR _attr$[esp+102628]
  00528	50		 push	 eax
  00529	6a 00		 push	 0
  0052b	68 e9 fd 00 00	 push	 65001			; 0000fde9H
  00530	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 249  : 						if (len == 0 || len == ERROR_NO_UNICODE_TRANSLATION)

  00536	85 c0		 test	 eax, eax
  00538	0f 84 f4 00 00
	00		 je	 $LN16@LoadLangua
  0053e	3d 59 04 00 00	 cmp	 eax, 1113		; 00000459H
  00543	0f 84 e9 00 00
	00		 je	 $LN16@LoadLangua

; 253  : 						}
; 254  : 
; 255  : 						// Add to dictionary
; 256  : 						text = AddPoolData ((void *) wattr, len * 2);

  00549	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  0054c	51		 push	 ecx
  0054d	8d 94 24 d4 90
	00 00		 lea	 edx, DWORD PTR _wattr$[esp+102620]
  00554	52		 push	 edx
  00555	e8 00 00 00 00	 call	 _AddPoolData
  0055a	83 c4 08	 add	 esp, 8

; 257  : 						if (text == NULL) return FALSE;

  0055d	85 c0		 test	 eax, eax
  0055f	0f 84 b6 00 00
	00		 je	 $LN83@LoadLangua

; 258  : 
; 259  : 						AddDictionaryEntry ((char *) key, 0, text);

  00565	50		 push	 eax
  00566	6a 00		 push	 0
  00568	56		 push	 esi
  00569	e8 00 00 00 00	 call	 _AddDictionaryEntry
  0056e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN29@LoadLangua:
  00571	53		 push	 ebx

; 260  : 					}
; 261  : 				}
; 262  : 
; 263  : 				xml++;

  00572	47		 inc	 edi
  00573	57		 push	 edi
  00574	e8 00 00 00 00	 call	 _XmlFindElement
  00579	8b f8		 mov	 edi, eax
  0057b	83 c4 08	 add	 esp, 8
  0057e	85 ff		 test	 edi, edi
  00580	0f 85 6a fe ff
	ff		 jne	 $LL33@LoadLangua
$LN35@LoadLangua:

; 201  : 		}
; 202  : 
; 203  : 		// Create string and control dictionaries
; 204  : 		for (i = 0; xmlElements[i] != 0; i++)

  00586	8b 44 24 18	 mov	 eax, DWORD PTR _i$[esp+102616]
  0058a	8b 5c 84 40	 mov	 ebx, DWORD PTR _xmlElements$[esp+eax*4+102620]
  0058e	40		 inc	 eax
  0058f	89 44 24 18	 mov	 DWORD PTR _i$[esp+102616], eax
  00593	85 db		 test	 ebx, ebx
  00595	0f 85 3a fe ff
	ff		 jne	 $LL36@LoadLangua

; 264  : 			}
; 265  : 		}
; 266  : 
; 267  : 		if (langFound)

  0059b	39 5c 24 1c	 cmp	 DWORD PTR _langFound$[esp+102616], ebx
  0059f	0f 85 b4 00 00
	00		 jne	 $LN94@LoadLangua

; 268  : 			break;
; 269  : 
; 270  : 		if (!defaultLangParsed)

  005a5	39 5c 24 10	 cmp	 DWORD PTR _defaultLangParsed$[esp+102616], ebx
  005a9	75 48		 jne	 SHORT $LN49@LoadLangua

; 271  : 		{
; 272  : 			defaultLangParsed = TRUE;

  005ab	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR _defaultLangParsed$[esp+102616], 1

; 273  : 			if (langId[0] == 0 || strcmp (langId, "en") == 0)

  005b3	38 5c 24 48	 cmp	 BYTE PTR _langId$[esp+102616], bl
  005b7	0f 84 d8 00 00
	00		 je	 $LN55@LoadLangua
  005bd	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_02LFNMGJAP@en?$AA@
  005c2	8d 44 24 48	 lea	 eax, DWORD PTR _langId$[esp+102616]
$LL117@LoadLangua:
  005c6	8a 10		 mov	 dl, BYTE PTR [eax]
  005c8	3a 11		 cmp	 dl, BYTE PTR [ecx]
  005ca	75 1a		 jne	 SHORT $LN118@LoadLangua
  005cc	84 d2		 test	 dl, dl
  005ce	74 12		 je	 SHORT $LN119@LoadLangua
  005d0	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  005d3	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  005d6	75 0e		 jne	 SHORT $LN118@LoadLangua
  005d8	83 c0 02	 add	 eax, 2
  005db	83 c1 02	 add	 ecx, 2
  005de	84 d2		 test	 dl, dl
  005e0	75 e4		 jne	 SHORT $LL117@LoadLangua
$LN119@LoadLangua:
  005e2	33 c0		 xor	 eax, eax
  005e4	eb 05		 jmp	 SHORT $LN120@LoadLangua
$LN118@LoadLangua:
  005e6	1b c0		 sbb	 eax, eax
  005e8	83 d8 ff	 sbb	 eax, -1
$LN120@LoadLangua:
  005eb	85 c0		 test	 eax, eax
  005ed	0f 84 a2 00 00
	00		 je	 $LN55@LoadLangua
$LN49@LoadLangua:

; 135  : 
; 136  : 	// Parse all available language files until preferred language is found
; 137  : 	for (res = MapFirstLanguageFile (); res != NULL; res = MapNextLanguageFile ())

  005f3	e8 00 00 00 00	 call	 _MapNextLanguageFile
  005f8	8b f8		 mov	 edi, eax
  005fa	89 7c 24 14	 mov	 DWORD PTR _res$[esp+102616], edi
  005fe	85 ff		 test	 edi, edi
  00600	0f 85 ac fa ff
	ff		 jne	 $LL125@LoadLangua

; 298  : 		if (header == NULL) return FALSE;

  00606	e9 8a 00 00 00	 jmp	 $LN55@LoadLangua
$LN82@LoadLangua:

; 236  : 									default:
; 237  : 										MessageBox (0, key, "CipherShed: Unknown '\\' escape sequence in string", MB_ICONERROR);

  0060b	6a 10		 push	 16			; 00000010H
  0060d	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@NDOJKNIA@CipherShed?3?5Unknown?5?8?2?8?5escape?5s@
  00612	56		 push	 esi
  00613	6a 00		 push	 0
  00615	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
$LN83@LoadLangua:

; 238  : 										return FALSE;

  0061b	33 c0		 xor	 eax, eax

; 311  : 	}
; 312  : 
; 313  : 	return TRUE;
; 314  : }

  0061d	5f		 pop	 edi
  0061e	5e		 pop	 esi
  0061f	5b		 pop	 ebx
  00620	8b 8c 24 c8 90
	01 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+102604]
  00627	33 cc		 xor	 ecx, esp
  00629	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0062e	8b e5		 mov	 esp, ebp
  00630	5d		 pop	 ebp
  00631	c3		 ret	 0
$LN16@LoadLangua:

; 250  : 						{
; 251  : 							MessageBox (0, key, "CipherShed: Error while decoding UTF-8 string", MB_ICONERROR);

  00632	6a 10		 push	 16			; 00000010H
  00634	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@OPBINFGK@CipherShed?3?5Error?5while?5decoding@
  00639	56		 push	 esi
  0063a	6a 00		 push	 0
  0063c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 252  : 							return FALSE;

  00642	33 c0		 xor	 eax, eax

; 311  : 	}
; 312  : 
; 313  : 	return TRUE;
; 314  : }

  00644	5f		 pop	 edi
  00645	5e		 pop	 esi
  00646	5b		 pop	 ebx
  00647	8b 8c 24 c8 90
	01 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+102604]
  0064e	33 cc		 xor	 ecx, esp
  00650	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00655	8b e5		 mov	 esp, ebp
  00657	5d		 pop	 ebp
  00658	c3		 ret	 0
$LN94@LoadLangua:

; 274  : 				break;
; 275  : 		}
; 276  : 	}
; 277  : 
; 278  : 	LocalizationActive = langFound && strcmp (langId, "en") != 0;

  00659	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_02LFNMGJAP@en?$AA@
  0065e	8d 44 24 48	 lea	 eax, DWORD PTR _langId$[esp+102616]
$LL121@LoadLangua:
  00662	8a 10		 mov	 dl, BYTE PTR [eax]
  00664	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00666	75 1a		 jne	 SHORT $LN122@LoadLangua
  00668	84 d2		 test	 dl, dl
  0066a	74 12		 je	 SHORT $LN123@LoadLangua
  0066c	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0066f	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00672	75 0e		 jne	 SHORT $LN122@LoadLangua
  00674	83 c0 02	 add	 eax, 2
  00677	83 c1 02	 add	 ecx, 2
  0067a	84 d2		 test	 dl, dl
  0067c	75 e4		 jne	 SHORT $LL121@LoadLangua
$LN123@LoadLangua:
  0067e	33 c0		 xor	 eax, eax
  00680	eb 05		 jmp	 SHORT $LN124@LoadLangua
$LN122@LoadLangua:
  00682	1b c0		 sbb	 eax, eax
  00684	83 d8 ff	 sbb	 eax, -1
$LN124@LoadLangua:
  00687	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _LocalizationActive, 1
  00691	85 c0		 test	 eax, eax
  00693	75 0a		 jne	 SHORT $LN56@LoadLangua
$LN55@LoadLangua:
  00695	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _LocalizationActive, 0
$LN56@LoadLangua:

; 279  : 	LocalizationSerialNo++;

  0069f	ff 05 00 00 00
	00		 inc	 DWORD PTR _LocalizationSerialNo

; 280  : 
; 281  : 	// Create control ID dictionary
; 282  : 	
; 283  : 	// Default controls
; 284  : 	AddDictionaryEntry (NULL, 1, GetString ("IDOK"));

  006a5	68 00 00 00 00	 push	 OFFSET ??_C@_04BAADKBID@IDOK?$AA@
  006aa	e8 00 00 00 00	 call	 _GetDictionaryValue
  006af	83 c4 04	 add	 esp, 4
  006b2	85 c0		 test	 eax, eax
  006b4	75 21		 jne	 SHORT $LN58@LoadLangua
  006b6	68 00 00 00 00	 push	 OFFSET ??_C@_04BAADKBID@IDOK?$AA@
  006bb	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@ONAPIBAL@?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$CF?$AAh?$AAs?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$AA@
  006c0	68 00 04 00 00	 push	 1024			; 00000400H
  006c5	68 00 00 00 00	 push	 OFFSET _UnknownString
  006ca	e8 00 00 00 00	 call	 __snwprintf
  006cf	83 c4 10	 add	 esp, 16			; 00000010H
  006d2	b8 00 00 00 00	 mov	 eax, OFFSET _UnknownString
$LN58@LoadLangua:
  006d7	50		 push	 eax
  006d8	6a 01		 push	 1
  006da	6a 00		 push	 0
  006dc	e8 00 00 00 00	 call	 _AddDictionaryEntry

; 285  : 	AddDictionaryEntry (NULL, 2, GetString ("IDCANCEL"));

  006e1	68 00 00 00 00	 push	 OFFSET ??_C@_08DDAIHKOO@IDCANCEL?$AA@
  006e6	e8 00 00 00 00	 call	 _GetDictionaryValue
  006eb	83 c4 10	 add	 esp, 16			; 00000010H
  006ee	85 c0		 test	 eax, eax
  006f0	75 21		 jne	 SHORT $LN61@LoadLangua
  006f2	68 00 00 00 00	 push	 OFFSET ??_C@_08DDAIHKOO@IDCANCEL?$AA@
  006f7	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@ONAPIBAL@?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$CF?$AAh?$AAs?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$AA@
  006fc	68 00 04 00 00	 push	 1024			; 00000400H
  00701	68 00 00 00 00	 push	 OFFSET _UnknownString
  00706	e8 00 00 00 00	 call	 __snwprintf
  0070b	83 c4 10	 add	 esp, 16			; 00000010H
  0070e	b8 00 00 00 00	 mov	 eax, OFFSET _UnknownString
$LN61@LoadLangua:
  00713	50		 push	 eax
  00714	6a 02		 push	 2
  00716	6a 00		 push	 0
  00718	e8 00 00 00 00	 call	 _AddDictionaryEntry

; 286  : 	AddDictionaryEntry (NULL, 8, GetString ("IDCLOSE"));

  0071d	68 00 00 00 00	 push	 OFFSET ??_C@_07CIAHAGHC@IDCLOSE?$AA@
  00722	e8 00 00 00 00	 call	 _GetDictionaryValue
  00727	83 c4 10	 add	 esp, 16			; 00000010H
  0072a	85 c0		 test	 eax, eax
  0072c	75 21		 jne	 SHORT $LN64@LoadLangua
  0072e	68 00 00 00 00	 push	 OFFSET ??_C@_07CIAHAGHC@IDCLOSE?$AA@
  00733	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@ONAPIBAL@?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$CF?$AAh?$AAs?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$AA@
  00738	68 00 04 00 00	 push	 1024			; 00000400H
  0073d	68 00 00 00 00	 push	 OFFSET _UnknownString
  00742	e8 00 00 00 00	 call	 __snwprintf
  00747	83 c4 10	 add	 esp, 16			; 00000010H
  0074a	b8 00 00 00 00	 mov	 eax, OFFSET _UnknownString
$LN64@LoadLangua:
  0074f	50		 push	 eax
  00750	6a 08		 push	 8
  00752	6a 00		 push	 0
  00754	e8 00 00 00 00	 call	 _AddDictionaryEntry

; 287  : 	AddDictionaryEntry (NULL, 9, GetString ("IDHELP"));

  00759	68 00 00 00 00	 push	 OFFSET ??_C@_06CALLMKCG@IDHELP?$AA@
  0075e	e8 00 00 00 00	 call	 _GetDictionaryValue
  00763	83 c4 10	 add	 esp, 16			; 00000010H
  00766	85 c0		 test	 eax, eax
  00768	75 21		 jne	 SHORT $LN67@LoadLangua
  0076a	68 00 00 00 00	 push	 OFFSET ??_C@_06CALLMKCG@IDHELP?$AA@
  0076f	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@ONAPIBAL@?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$CF?$AAh?$AAs?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$AA@
  00774	68 00 04 00 00	 push	 1024			; 00000400H
  00779	68 00 00 00 00	 push	 OFFSET _UnknownString
  0077e	e8 00 00 00 00	 call	 __snwprintf
  00783	83 c4 10	 add	 esp, 16			; 00000010H
  00786	b8 00 00 00 00	 mov	 eax, OFFSET _UnknownString
$LN67@LoadLangua:
  0078b	50		 push	 eax
  0078c	6a 09		 push	 9
  0078e	6a 00		 push	 0
  00790	e8 00 00 00 00	 call	 _AddDictionaryEntry
  00795	83 c4 0c	 add	 esp, 12			; 0000000cH

; 288  : 
; 289  : 	for (i = 0; headers[i] != 0; i++)

  00798	33 ff		 xor	 edi, edi
  0079a	33 f6		 xor	 esi, esi
  0079c	8d 64 24 00	 npad	 4
$LL10@LoadLangua:

; 290  : 	{
; 291  : 		if (HeaderResource[i] == NULL)

  007a0	83 be 00 00 00
	00 00		 cmp	 DWORD PTR _HeaderResource[esi], 0
  007a7	75 26		 jne	 SHORT $LN7@LoadLangua

; 292  : 		{
; 293  : 			HeaderResource[i] = MapResource ("Header", headers[i], &size);

  007a9	8b 4c 34 30	 mov	 ecx, DWORD PTR _headers$[esp+esi+102616]
  007ad	8d 44 24 28	 lea	 eax, DWORD PTR _size$[esp+102616]
  007b1	50		 push	 eax
  007b2	51		 push	 ecx
  007b3	68 00 00 00 00	 push	 OFFSET ??_C@_06OENKJGA@Header?$AA@
  007b8	e8 00 00 00 00	 call	 _MapResource

; 294  : 			*(HeaderResource[i] + size - 1) = 0;

  007bd	8b 54 24 34	 mov	 edx, DWORD PTR _size$[esp+102628]
  007c1	89 86 00 00 00
	00		 mov	 DWORD PTR _HeaderResource[esi], eax
  007c7	83 c4 0c	 add	 esp, 12			; 0000000cH
  007ca	c6 44 10 ff 00	 mov	 BYTE PTR [eax+edx-1], 0
$LN7@LoadLangua:

; 295  : 		}
; 296  : 
; 297  : 		header = HeaderResource[i];

  007cf	8b b6 00 00 00
	00		 mov	 esi, DWORD PTR _HeaderResource[esi]

; 298  : 		if (header == NULL) return FALSE;

  007d5	85 f6		 test	 esi, esi
  007d7	0f 84 3e fe ff
	ff		 je	 $LN83@LoadLangua
  007dd	8d 49 00	 npad	 3
$LL5@LoadLangua:

; 299  : 
; 300  : 		do
; 301  : 		{
; 302  : 			if (sscanf (header, "#define %s %d", key, &intKey) == 2)

  007e0	8d 44 24 2c	 lea	 eax, DWORD PTR _intKey$[esp+102616]
  007e4	50		 push	 eax
  007e5	8d 4c 24 54	 lea	 ecx, DWORD PTR _key$[esp+102620]
  007e9	51		 push	 ecx
  007ea	68 00 00 00 00	 push	 OFFSET ??_C@_0O@MBEIEFFD@?$CDdefine?5?$CFs?5?$CFd?$AA@
  007ef	56		 push	 esi
  007f0	e8 00 00 00 00	 call	 _sscanf
  007f5	83 c4 10	 add	 esp, 16			; 00000010H
  007f8	83 f8 02	 cmp	 eax, 2
  007fb	75 46		 jne	 SHORT $LN4@LoadLangua

; 303  : 			{
; 304  : 				WCHAR *str = GetString (key);

  007fd	8d 54 24 50	 lea	 edx, DWORD PTR _key$[esp+102616]
  00801	52		 push	 edx
  00802	e8 00 00 00 00	 call	 _GetDictionaryValue
  00807	83 c4 04	 add	 esp, 4
  0080a	85 c0		 test	 eax, eax
  0080c	75 1e		 jne	 SHORT $LN70@LoadLangua
  0080e	8d 44 24 50	 lea	 eax, DWORD PTR _key$[esp+102616]
  00812	50		 push	 eax
  00813	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@ONAPIBAL@?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$CF?$AAh?$AAs?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$AA@
  00818	68 00 04 00 00	 push	 1024			; 00000400H
  0081d	68 00 00 00 00	 push	 OFFSET _UnknownString
  00822	e8 00 00 00 00	 call	 __snwprintf
  00827	83 c4 10	 add	 esp, 16			; 00000010H

; 305  : 
; 306  : 				if (str != UnknownString)

  0082a	eb 17		 jmp	 SHORT $LN4@LoadLangua

; 303  : 			{
; 304  : 				WCHAR *str = GetString (key);

$LN70@LoadLangua:

; 305  : 
; 306  : 				if (str != UnknownString)

  0082c	3d 00 00 00 00	 cmp	 eax, OFFSET _UnknownString
  00831	74 10		 je	 SHORT $LN4@LoadLangua

; 307  : 					AddDictionaryEntry (NULL, intKey, str);

  00833	8b 4c 24 2c	 mov	 ecx, DWORD PTR _intKey$[esp+102616]
  00837	50		 push	 eax
  00838	51		 push	 ecx
  00839	6a 00		 push	 0
  0083b	e8 00 00 00 00	 call	 _AddDictionaryEntry
  00840	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@LoadLangua:

; 308  : 			}
; 309  : 
; 310  : 		} while ((header = strchr (header, '\n') + 1) != (char *) 1);

  00843	6a 0a		 push	 10			; 0000000aH
  00845	56		 push	 esi
  00846	e8 00 00 00 00	 call	 _strchr
  0084b	40		 inc	 eax
  0084c	8b f0		 mov	 esi, eax
  0084e	83 c4 08	 add	 esp, 8
  00851	83 fe 01	 cmp	 esi, 1
  00854	75 8a		 jne	 SHORT $LL5@LoadLangua
  00856	47		 inc	 edi
  00857	8d 34 bd 00 00
	00 00		 lea	 esi, DWORD PTR [edi*4]
  0085e	83 7c 34 30 00	 cmp	 DWORD PTR _headers$[esp+esi+102616], 0
  00863	0f 85 37 ff ff
	ff		 jne	 $LL10@LoadLangua

; 311  : 	}
; 312  : 
; 313  : 	return TRUE;
; 314  : }

  00869	8b 8c 24 d4 90
	01 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+102616]
  00870	5f		 pop	 edi
  00871	5e		 pop	 esi
  00872	5b		 pop	 ebx
  00873	33 cc		 xor	 ecx, esp
  00875	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0087a	8b e5		 mov	 esp, ebp
  0087c	5d		 pop	 ebp
  0087d	c3		 ret	 0
_LoadLanguageFile ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@DOLNAGBN@translators?$AA@		; `string'
PUBLIC	??_C@_15KHFHDPFH@?$AA?9?$AA?9?$AA?$AA@		; `string'
PUBLIC	??_C@_0BC@KEBBFOHL@LANG_PACK_VERSION?$AA@	; `string'
PUBLIC	??_C@_1BA@CLLEDPIF@?$AAE?$AAn?$AAg?$AAl?$AAi?$AAs?$AAh?$AA?$AA@ ; `string'
PUBLIC	??_C@_04MEMAJGDJ@name?$AA@			; `string'
PUBLIC	??_C@_0N@CHAAEAGP@IDD_LANGUAGE?$AA@		; `string'
PUBLIC	??_C@_0O@GFLMAIPO@localizations?$AA@		; `string'
PUBLIC	??_C@_0BM@OECEHKD@?$CGlangpackversion?$DN?$CFs?$CGlang?$DN?$CFs?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_LanguageDlgProc@16
EXTRN	__imp__SetWindowTextW@8:PROC
EXTRN	__imp__GetDlgItem@8:PROC
EXTRN	__imp__SendDlgItemMessageW@20:PROC
EXTRN	_ToHyperlink:PROC
EXTRN	_LocalizeDialog:PROC
EXTRN	__imp__SendDlgItemMessageA@20:PROC
EXTRN	_Applink:PROC
EXTRN	_sprintf_s:PROC
EXTRN	__imp__EndDialog@8:PROC
;	COMDAT ??_C@_0M@DOLNAGBN@translators?$AA@
CONST	SEGMENT
??_C@_0M@DOLNAGBN@translators?$AA@ DB 'translators', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15KHFHDPFH@?$AA?9?$AA?9?$AA?$AA@
CONST	SEGMENT
??_C@_15KHFHDPFH@?$AA?9?$AA?9?$AA?$AA@ DB '-', 00H, '-', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KEBBFOHL@LANG_PACK_VERSION?$AA@
CONST	SEGMENT
??_C@_0BC@KEBBFOHL@LANG_PACK_VERSION?$AA@ DB 'LANG_PACK_VERSION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@CLLEDPIF@?$AAE?$AAn?$AAg?$AAl?$AAi?$AAs?$AAh?$AA?$AA@
CONST	SEGMENT
??_C@_1BA@CLLEDPIF@?$AAE?$AAn?$AAg?$AAl?$AAi?$AAs?$AAh?$AA?$AA@ DB 'E', 00H
	DB	'n', 00H, 'g', 00H, 'l', 00H, 'i', 00H, 's', 00H, 'h', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name?$AA@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name?$AA@ DB 'name', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CHAAEAGP@IDD_LANGUAGE?$AA@
CONST	SEGMENT
??_C@_0N@CHAAEAGP@IDD_LANGUAGE?$AA@ DB 'IDD_LANGUAGE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GFLMAIPO@localizations?$AA@
CONST	SEGMENT
??_C@_0O@GFLMAIPO@localizations?$AA@ DB 'localizations', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OECEHKD@?$CGlangpackversion?$DN?$CFs?$CGlang?$DN?$CFs?$AA@
CONST	SEGMENT
??_C@_0BM@OECEHKD@?$CGlangpackversion?$DN?$CFs?$CGlang?$DN?$CFs?$AA@ DB '&'
	DB	'langpackversion=%s&lang=%s', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _LanguageDlgProc@16
_TEXT	SEGMENT
_defaultLangFound$86322 = -36612			; size = 4
tv351 = -36608						; size = 4
tv346 = -36608						; size = 4
_l$86373 = -36608					; size = 6
_langCount$86321 = -36608				; size = 4
_lastLangId$86318 = -36600				; size = 10
_wversion$86351 = -36588				; size = 40
_tmpstr$86381 = -36548					; size = 256
_szVers$86352 = -36548					; size = 400
_attr$86317 = -36148					; size = 2048
_wattr$86319 = -34100					; size = 4096
_credits$86349 = -30004					; size = 10000
_wcredits$86350 = -20004				; size = 20000
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_msg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_LanguageDlgProc@16 PROC				; COMDAT

; 319  : {

  00000	b8 04 8f 00 00	 mov	 eax, 36612		; 00008f04H
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000f	33 c4		 xor	 eax, esp
  00011	89 84 24 00 8f
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+36612], eax

; 320  : 	WORD lw = LOWORD (wParam);
; 321  : 	WORD hw = HIWORD (wParam);
; 322  : 
; 323  : 	switch (msg)

  00018	8b 84 24 0c 8f
	00 00		 mov	 eax, DWORD PTR _msg$[esp+36608]
  0001f	2d 10 01 00 00	 sub	 eax, 272		; 00000110H
  00024	56		 push	 esi
  00025	57		 push	 edi
  00026	8b bc 24 10 8f
	00 00		 mov	 edi, DWORD PTR _hwndDlg$[esp+36616]
  0002d	0f 84 4c 01 00
	00		 je	 $LN35@LanguageDl
  00033	83 e8 01	 sub	 eax, 1

; 478  : 	}
; 479  : 
; 480  : 	return 0;

  00036	0f 85 a4 00 00
	00		 jne	 $LN3@LanguageDl
  0003c	8b 84 24 18 8f
	00 00		 mov	 eax, DWORD PTR _wParam$[esp+36616]
  00043	66 83 f8 01	 cmp	 ax, 1
  00047	0f 84 9a 00 00
	00		 je	 $LN9@LanguageDl
  0004d	8b c8		 mov	 ecx, eax
  0004f	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00052	83 f9 02	 cmp	 ecx, 2
  00055	0f 84 8c 00 00
	00		 je	 $LN9@LanguageDl

; 456  : 		}
; 457  : 
; 458  : 		if (lw == IDCANCEL)

  0005b	66 83 f8 02	 cmp	 ax, 2
  0005f	75 0e		 jne	 SHORT $LN4@LanguageDl

; 459  : 		{
; 460  : 			EndDialog (hwndDlg, lw);

  00061	6a 02		 push	 2
  00063	57		 push	 edi
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndDialog@8

; 461  : 			return 1;

  0006a	e9 a9 04 00 00	 jmp	 $LN79@LanguageDl
$LN4@LanguageDl:

; 462  : 		}
; 463  : 
; 464  : 		if (lw == IDC_GET_LANG_PACKS)

  0006f	ba d5 13 00 00	 mov	 edx, 5077		; 000013d5H
  00074	66 3b c2	 cmp	 ax, dx
  00077	75 67		 jne	 SHORT $LN3@LanguageDl

; 465  : 		{
; 466  : 			char tmpstr [256];
; 467  : 
; 468  : 			if (strlen (ActiveLangPackVersion) > 0 && strlen (GetPreferredLangId()) > 0)

  00079	b8 00 00 00 00	 mov	 eax, OFFSET _ActiveLangPackVersion
  0007e	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL62@LanguageDl:
  00081	8a 08		 mov	 cl, BYTE PTR [eax]
  00083	40		 inc	 eax
  00084	84 c9		 test	 cl, cl
  00086	75 f9		 jne	 SHORT $LL62@LanguageDl
  00088	2b c2		 sub	 eax, edx
  0008a	74 36		 je	 SHORT $LN2@LanguageDl
  0008c	b8 00 00 00 00	 mov	 eax, OFFSET _PreferredLangId
  00091	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL63@LanguageDl:
  00094	8a 08		 mov	 cl, BYTE PTR [eax]
  00096	40		 inc	 eax
  00097	84 c9		 test	 cl, cl
  00099	75 f9		 jne	 SHORT $LL63@LanguageDl
  0009b	2b c2		 sub	 eax, edx
  0009d	74 23		 je	 SHORT $LN2@LanguageDl

; 469  : 				snprintf (tmpstr, ARRAY_LENGTH(tmpstr), "&langpackversion=%s&lang=%s", ActiveLangPackVersion, GetPreferredLangId());

  0009f	68 00 00 00 00	 push	 OFFSET _PreferredLangId
  000a4	68 00 00 00 00	 push	 OFFSET _ActiveLangPackVersion
  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@OECEHKD@?$CGlangpackversion?$DN?$CFs?$CGlang?$DN?$CFs?$AA@
  000ae	8d 44 24 54	 lea	 eax, DWORD PTR _tmpstr$86381[esp+36632]
  000b2	68 00 01 00 00	 push	 256			; 00000100H
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _sprintf_s
  000bd	83 c4 14	 add	 esp, 20			; 00000014H

; 470  : 			else

  000c0	eb 05		 jmp	 SHORT $LN1@LanguageDl
$LN2@LanguageDl:

; 471  : 				tmpstr[0] = 0;

  000c2	c6 44 24 48 00	 mov	 BYTE PTR _tmpstr$86381[esp+36620], 0
$LN1@LanguageDl:

; 472  : 
; 473  : 			Applink ("localizations", TRUE, tmpstr);

  000c7	8d 4c 24 48	 lea	 ecx, DWORD PTR _tmpstr$86381[esp+36620]
  000cb	51		 push	 ecx
  000cc	6a 01		 push	 1
  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GFLMAIPO@localizations?$AA@
  000d3	e8 00 00 00 00	 call	 _Applink
  000d8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 474  : 
; 475  : 			return 1;

  000db	e9 38 04 00 00	 jmp	 $LN79@LanguageDl
$LN3@LanguageDl:

; 476  : 		}
; 477  : 		return 0;

  000e0	33 c0		 xor	 eax, eax
  000e2	e9 36 04 00 00	 jmp	 $LN38@LanguageDl
$LN9@LanguageDl:

; 420  : 		}
; 421  : 
; 422  : 	case WM_COMMAND:
; 423  : 
; 424  : 		if (lw == IDOK || hw == LBN_DBLCLK)
; 425  : 		{
; 426  : 			int i = SendDlgItemMessage (hwndDlg, IDC_LANGLIST, LB_GETCURSEL, 0, 0);

  000e7	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendDlgItemMessageA@20
  000ed	6a 00		 push	 0
  000ef	6a 00		 push	 0
  000f1	68 88 01 00 00	 push	 392			; 00000188H
  000f6	68 ce 13 00 00	 push	 5070			; 000013ceH
  000fb	57		 push	 edi
  000fc	ff d6		 call	 esi

; 427  : 
; 428  : 			if (i >= 0)

  000fe	85 c0		 test	 eax, eax
  00100	7c 6f		 jl	 SHORT $LN5@LanguageDl

; 429  : 			{
; 430  : 				int id = SendDlgItemMessage (hwndDlg, IDC_LANGLIST, LB_GETITEMDATA, i, 0);

  00102	6a 00		 push	 0
  00104	50		 push	 eax
  00105	68 99 01 00 00	 push	 409			; 00000199H
  0010a	68 ce 13 00 00	 push	 5070			; 000013ceH
  0010f	57		 push	 edi
  00110	ff d6		 call	 esi

; 431  : 
; 432  : 				if (id != LB_ERR)

  00112	83 f8 ff	 cmp	 eax, -1
  00115	74 5a		 je	 SHORT $LN5@LanguageDl

; 433  : 				{
; 434  : 					char l[6];
; 435  : 
; 436  : 					// Decode language id from LPARAM
; 437  : 					l[0] = (char) id;
; 438  : 					l[1] = (char) (id >> 8);

  00117	8b d0		 mov	 edx, eax
  00119	c1 fa 08	 sar	 edx, 8
  0011c	88 44 24 0c	 mov	 BYTE PTR _l$86373[esp+36620], al
  00120	88 54 24 0d	 mov	 BYTE PTR _l$86373[esp+36621], dl

; 439  : 					l[2] = 0;

  00124	c6 44 24 0e 00	 mov	 BYTE PTR _l$86373[esp+36622], 0

; 440  : 
; 441  : 					if ((id & 0xffff0000) != 0)

  00129	a9 00 00 ff ff	 test	 eax, -65536		; ffff0000H
  0012e	74 1a		 je	 SHORT $LN6@LanguageDl

; 442  : 					{
; 443  : 						l[2] = '-';
; 444  : 						l[3] = (char) (id >> 16);

  00130	8b c8		 mov	 ecx, eax
  00132	c1 f9 10	 sar	 ecx, 16			; 00000010H

; 445  : 						l[4] = id >> 24;

  00135	c1 f8 18	 sar	 eax, 24			; 00000018H
  00138	c6 44 24 0e 2d	 mov	 BYTE PTR _l$86373[esp+36622], 45 ; 0000002dH
  0013d	88 4c 24 0f	 mov	 BYTE PTR _l$86373[esp+36623], cl
  00141	88 44 24 10	 mov	 BYTE PTR _l$86373[esp+36624], al

; 446  : 						l[5] = 0;

  00145	c6 44 24 11 00	 mov	 BYTE PTR _l$86373[esp+36625], 0
$LN6@LanguageDl:

; 447  : 					}	
; 448  : 		
; 449  : 					if (SendDlgItemMessage (hwndDlg, IDC_LANGLIST, LB_GETCOUNT, 0, 0) > 1)

  0014a	6a 00		 push	 0
  0014c	6a 00		 push	 0
  0014e	68 8b 01 00 00	 push	 395			; 0000018bH
  00153	68 ce 13 00 00	 push	 5070			; 000013ceH
  00158	57		 push	 edi
  00159	ff d6		 call	 esi
  0015b	83 f8 01	 cmp	 eax, 1
  0015e	7e 11		 jle	 SHORT $LN5@LanguageDl

; 450  : 						strcpy (PreferredLangId, l);

  00160	33 c0		 xor	 eax, eax
$LL42@LanguageDl:
  00162	8a 4c 04 0c	 mov	 cl, BYTE PTR _l$86373[esp+eax+36620]
  00166	88 88 00 00 00
	00		 mov	 BYTE PTR _PreferredLangId[eax], cl
  0016c	40		 inc	 eax
  0016d	84 c9		 test	 cl, cl
  0016f	75 f1		 jne	 SHORT $LL42@LanguageDl
$LN5@LanguageDl:

; 451  : 				}
; 452  : 			}
; 453  : 
; 454  : 			EndDialog (hwndDlg, IDOK);

  00171	6a 01		 push	 1
  00173	57		 push	 edi
  00174	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndDialog@8

; 455  : 			return 1;

  0017a	e9 99 03 00 00	 jmp	 $LN79@LanguageDl
$LN35@LanguageDl:
  0017f	53		 push	 ebx

; 324  : 	{
; 325  : 	case WM_INITDIALOG:
; 326  : 		{
; 327  : 			char *xml;
; 328  : 			char attr[2048], lastLangId[10];
; 329  : 			WCHAR wattr[2048];
; 330  : 			int len;
; 331  : 			int langCount = 0;
; 332  : 			BOOL defaultLangFound = FALSE;
; 333  : 
; 334  : 			LocalizeDialog (hwndDlg, "IDD_LANGUAGE");

  00180	68 00 00 00 00	 push	 OFFSET ??_C@_0N@CHAAEAGP@IDD_LANGUAGE?$AA@
  00185	57		 push	 edi
  00186	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _langCount$86321[esp+36632], 0
  0018e	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _defaultLangFound$86322[esp+36632], 0
  00196	e8 00 00 00 00	 call	 _LocalizeDialog

; 335  : 			ToHyperlink (hwndDlg, IDC_GET_LANG_PACKS);

  0019b	68 d5 13 00 00	 push	 5077			; 000013d5H
  001a0	57		 push	 edi
  001a1	e8 00 00 00 00	 call	 _ToHyperlink
  001a6	83 c4 10	 add	 esp, 16			; 00000010H

; 336  : 
; 337  : 			for (xml = MapFirstLanguageFile (); xml != NULL; xml = MapNextLanguageFile ())

  001a9	e8 00 00 00 00	 call	 _MapFirstLanguageFile
  001ae	85 c0		 test	 eax, eax
  001b0	0f 84 28 03 00
	00		 je	 $LN32@LanguageDl
  001b6	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__MultiByteToWideChar@24
  001bc	55		 push	 ebp
  001bd	8d 49 00	 npad	 3
$LL34@LanguageDl:

; 338  : 			{
; 339  : 				while (xml = XmlFindElement (xml, "language"))

  001c0	68 00 00 00 00	 push	 OFFSET ??_C@_08JGCCIMAA@language?$AA@
  001c5	50		 push	 eax
  001c6	e8 00 00 00 00	 call	 _XmlFindElement
  001cb	8b e8		 mov	 ebp, eax
  001cd	83 c4 08	 add	 esp, 8
  001d0	85 ed		 test	 ebp, ebp
  001d2	0f 84 f8 02 00
	00		 je	 $LN33@LanguageDl
  001d8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL31@LanguageDl:

; 340  : 				{
; 341  : 					XmlGetAttributeText (xml, "name", attr, sizeof (attr));

  001e0	68 00 08 00 00	 push	 2048			; 00000800H
  001e5	8d 94 24 e4 01
	00 00		 lea	 edx, DWORD PTR _attr$86317[esp+36632]
  001ec	52		 push	 edx
  001ed	68 00 00 00 00	 push	 OFFSET ??_C@_04MEMAJGDJ@name?$AA@
  001f2	55		 push	 ebp
  001f3	e8 00 00 00 00	 call	 _XmlGetAttributeText
  001f8	83 c4 10	 add	 esp, 16			; 00000010H

; 342  : 					len = MultiByteToWideChar (CP_UTF8, 0, attr, -1, wattr, sizeof (wattr) / sizeof(wattr[0]));

  001fb	68 00 08 00 00	 push	 2048			; 00000800H
  00200	8d 84 24 e4 09
	00 00		 lea	 eax, DWORD PTR _wattr$86319[esp+36632]
  00207	50		 push	 eax
  00208	6a ff		 push	 -1
  0020a	8d 8c 24 ec 01
	00 00		 lea	 ecx, DWORD PTR _attr$86317[esp+36640]
  00211	51		 push	 ecx
  00212	6a 00		 push	 0
  00214	68 e9 fd 00 00	 push	 65001			; 0000fde9H
  00219	ff d3		 call	 ebx

; 343  : 
; 344  : 					if (len != 0 && len != ERROR_NO_UNICODE_TRANSLATION
; 345  : 						&& (!defaultLangFound || wcscmp (wattr, L"English") != 0))

  0021b	85 c0		 test	 eax, eax
  0021d	0f 84 94 02 00
	00		 je	 $LN76@LanguageDl
  00223	3d 59 04 00 00	 cmp	 eax, 1113		; 00000459H
  00228	0f 84 89 02 00
	00		 je	 $LN76@LanguageDl
  0022e	83 7c 24 10 00	 cmp	 DWORD PTR _defaultLangFound$86322[esp+36628], 0
  00233	74 3f		 je	 SHORT $LN28@LanguageDl
  00235	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_1BA@CLLEDPIF@?$AAE?$AAn?$AAg?$AAl?$AAi?$AAs?$AAh?$AA?$AA@
  0023a	8d 84 24 e0 09
	00 00		 lea	 eax, DWORD PTR _wattr$86319[esp+36628]
$LL64@LanguageDl:
  00241	66 8b 10	 mov	 dx, WORD PTR [eax]
  00244	66 3b 11	 cmp	 dx, WORD PTR [ecx]
  00247	75 1e		 jne	 SHORT $LN65@LanguageDl
  00249	66 85 d2	 test	 dx, dx
  0024c	74 15		 je	 SHORT $LN66@LanguageDl
  0024e	66 8b 50 02	 mov	 dx, WORD PTR [eax+2]
  00252	66 3b 51 02	 cmp	 dx, WORD PTR [ecx+2]
  00256	75 0f		 jne	 SHORT $LN65@LanguageDl
  00258	83 c0 04	 add	 eax, 4
  0025b	83 c1 04	 add	 ecx, 4
  0025e	66 85 d2	 test	 dx, dx
  00261	75 de		 jne	 SHORT $LL64@LanguageDl
$LN66@LanguageDl:
  00263	33 c0		 xor	 eax, eax
  00265	eb 05		 jmp	 SHORT $LN67@LanguageDl
$LN65@LanguageDl:
  00267	1b c0		 sbb	 eax, eax
  00269	83 d8 ff	 sbb	 eax, -1
$LN67@LanguageDl:
  0026c	85 c0		 test	 eax, eax
  0026e	0f 84 43 02 00
	00		 je	 $LN76@LanguageDl
$LN28@LanguageDl:

; 346  : 					{
; 347  : 						int i = SendDlgItemMessageW (hwndDlg, IDC_LANGLIST, LB_ADDSTRING, 0, (LPARAM)wattr);

  00274	8d 94 24 e0 09
	00 00		 lea	 edx, DWORD PTR _wattr$86319[esp+36628]
  0027b	52		 push	 edx
  0027c	6a 00		 push	 0
  0027e	68 80 01 00 00	 push	 384			; 00000180H
  00283	68 ce 13 00 00	 push	 5070			; 000013ceH
  00288	57		 push	 edi
  00289	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageW@20
  0028f	8b f0		 mov	 esi, eax

; 348  : 						if (i >= 0)

  00291	85 f6		 test	 esi, esi
  00293	0f 8c 1e 02 00
	00		 jl	 $LN76@LanguageDl

; 349  : 						{
; 350  : 							int id;
; 351  : 
; 352  : 							// Encode language id in LPARAM
; 353  : 							XmlGetAttributeText (xml, "langid", attr, sizeof (attr));

  00299	68 00 08 00 00	 push	 2048			; 00000800H
  0029e	8d 84 24 e4 01
	00 00		 lea	 eax, DWORD PTR _attr$86317[esp+36632]
  002a5	50		 push	 eax
  002a6	68 00 00 00 00	 push	 OFFSET ??_C@_06CLEJICHF@langid?$AA@
  002ab	55		 push	 ebp
  002ac	e8 00 00 00 00	 call	 _XmlGetAttributeText

; 354  : 							switch (strlen (attr))

  002b1	8d 84 24 f0 01
	00 00		 lea	 eax, DWORD PTR _attr$86317[esp+36644]
  002b8	83 c4 10	 add	 esp, 16			; 00000010H
  002bb	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  002be	8b ff		 npad	 2
$LL68@LanguageDl:
  002c0	8a 08		 mov	 cl, BYTE PTR [eax]
  002c2	40		 inc	 eax
  002c3	84 c9		 test	 cl, cl
  002c5	75 f9		 jne	 SHORT $LL68@LanguageDl
  002c7	2b c2		 sub	 eax, edx
  002c9	83 e8 02	 sub	 eax, 2
  002cc	74 3a		 je	 SHORT $LN24@LanguageDl
  002ce	83 e8 03	 sub	 eax, 3
  002d1	0f 85 e1 01 00
	00		 jne	 $LN60@LanguageDl

; 357  : 							case 5: id = attr[0] | attr[1] << 8 | attr[3] << 16 | attr[4] << 24; break;

  002d7	0f be 84 24 e4
	01 00 00	 movsx	 eax, BYTE PTR _attr$86317[esp+36632]
  002df	0f be 8c 24 e3
	01 00 00	 movsx	 ecx, BYTE PTR _attr$86317[esp+36631]
  002e7	0f be 94 24 e1
	01 00 00	 movsx	 edx, BYTE PTR _attr$86317[esp+36629]
  002ef	c1 e0 08	 shl	 eax, 8
  002f2	0b c1		 or	 eax, ecx
  002f4	0f be 8c 24 e0
	01 00 00	 movsx	 ecx, BYTE PTR _attr$86317[esp+36628]
  002fc	c1 e0 08	 shl	 eax, 8
  002ff	0b c2		 or	 eax, edx
  00301	c1 e0 08	 shl	 eax, 8
  00304	0b c1		 or	 eax, ecx
  00306	eb 15		 jmp	 SHORT $LN25@LanguageDl
$LN24@LanguageDl:

; 355  : 							{
; 356  : 							case 2: id = attr[0] | attr[1] << 8; break;

  00308	0f be 84 24 e1
	01 00 00	 movsx	 eax, BYTE PTR _attr$86317[esp+36629]
  00310	0f be 94 24 e0
	01 00 00	 movsx	 edx, BYTE PTR _attr$86317[esp+36628]
  00318	c1 e0 08	 shl	 eax, 8
  0031b	0b c2		 or	 eax, edx
$LN25@LanguageDl:

; 358  : 							default: continue;
; 359  : 							}
; 360  : 
; 361  : 							if (!defaultLangFound)

  0031d	83 7c 24 10 00	 cmp	 DWORD PTR _defaultLangFound$86322[esp+36628], 0
  00322	75 08		 jne	 SHORT $LN21@LanguageDl

; 362  : 								defaultLangFound = TRUE;

  00324	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR _defaultLangFound$86322[esp+36628], 1
$LN21@LanguageDl:

; 363  : 
; 364  : 							SendDlgItemMessage (hwndDlg, IDC_LANGLIST, LB_SETITEMDATA, i, (LPARAM) id);

  0032c	50		 push	 eax
  0032d	56		 push	 esi
  0032e	68 9a 01 00 00	 push	 410			; 0000019aH
  00333	68 ce 13 00 00	 push	 5070			; 000013ceH
  00338	57		 push	 edi
  00339	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20

; 365  : 
; 366  : 							if (strcmp (attr, PreferredLangId) == 0)

  0033f	b9 00 00 00 00	 mov	 ecx, OFFSET _PreferredLangId
  00344	8d 84 24 e0 01
	00 00		 lea	 eax, DWORD PTR _attr$86317[esp+36628]
  0034b	eb 03 8d 49 00	 npad	 5
$LL69@LanguageDl:
  00350	8a 10		 mov	 dl, BYTE PTR [eax]
  00352	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00354	75 1a		 jne	 SHORT $LN70@LanguageDl
  00356	84 d2		 test	 dl, dl
  00358	74 12		 je	 SHORT $LN71@LanguageDl
  0035a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0035d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00360	75 0e		 jne	 SHORT $LN70@LanguageDl
  00362	83 c0 02	 add	 eax, 2
  00365	83 c1 02	 add	 ecx, 2
  00368	84 d2		 test	 dl, dl
  0036a	75 e4		 jne	 SHORT $LL69@LanguageDl
$LN71@LanguageDl:
  0036c	33 c0		 xor	 eax, eax
  0036e	eb 05		 jmp	 SHORT $LN72@LanguageDl
$LN70@LanguageDl:
  00370	1b c0		 sbb	 eax, eax
  00372	83 d8 ff	 sbb	 eax, -1
$LN72@LanguageDl:
  00375	85 c0		 test	 eax, eax
  00377	0f 85 24 01 00
	00		 jne	 $LN75@LanguageDl

; 367  : 							{
; 368  : 								char credits [10000];
; 369  : 								WCHAR wcredits [10000];
; 370  : 								WCHAR wversion [20];
; 371  : 								wchar_t szVers [200];
; 372  : 								int nLen;
; 373  : 
; 374  : 								SendDlgItemMessage (hwndDlg, IDC_LANGLIST, LB_SETCURSEL, i, 0);

  0037d	50		 push	 eax
  0037e	56		 push	 esi
  0037f	68 86 01 00 00	 push	 390			; 00000186H
  00384	68 ce 13 00 00	 push	 5070			; 000013ceH
  00389	57		 push	 edi
  0038a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageA@20

; 375  : 
; 376  : 								// Language pack version 
; 377  : 								if (!ActiveLangPackVersion[0] || memcmp (ActiveLangPackVersion, "0.0.0", 5) == 0)

  00390	a1 00 00 00 00	 mov	 eax, DWORD PTR _ActiveLangPackVersion
  00395	84 c0		 test	 al, al
  00397	74 4c		 je	 SHORT $LN46@LanguageDl
  00399	3d 30 2e 30 2e	 cmp	 eax, 774909488		; 2e302e30H
  0039e	75 09		 jne	 SHORT $LN19@LanguageDl
  003a0	80 3d 04 00 00
	00 30		 cmp	 BYTE PTR _ActiveLangPackVersion+4, 48 ; 00000030H
  003a7	74 3c		 je	 SHORT $LN46@LanguageDl
$LN19@LanguageDl:

; 380  : 								}
; 381  : 								else
; 382  : 								{
; 383  : 									nLen = MultiByteToWideChar (CP_UTF8, 0, ActiveLangPackVersion, -1, wversion, sizeof (wversion) / sizeof(wversion[0]));

  003a9	6a 14		 push	 20			; 00000014H
  003ab	8d 44 24 2c	 lea	 eax, DWORD PTR _wversion$86351[esp+36632]
  003af	50		 push	 eax
  003b0	6a ff		 push	 -1
  003b2	68 00 00 00 00	 push	 OFFSET _ActiveLangPackVersion
  003b7	6a 00		 push	 0
  003b9	68 e9 fd 00 00	 push	 65001			; 0000fde9H
  003be	ff d3		 call	 ebx

; 384  : 									if (nLen != 0 && nLen != ERROR_NO_UNICODE_TRANSLATION)

  003c0	85 c0		 test	 eax, eax
  003c2	74 66		 je	 SHORT $LN74@LanguageDl
  003c4	3d 59 04 00 00	 cmp	 eax, 1113		; 00000459H
  003c9	74 5f		 je	 SHORT $LN74@LanguageDl

; 385  : 										swprintf (szVers, GetString("LANG_PACK_VERSION"), wversion);

  003cb	8d 4c 24 28	 lea	 ecx, DWORD PTR _wversion$86351[esp+36628]
  003cf	51		 push	 ecx
  003d0	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KEBBFOHL@LANG_PACK_VERSION?$AA@
  003d5	e8 00 00 00 00	 call	 _GetString
  003da	83 c4 04	 add	 esp, 4
  003dd	50		 push	 eax
  003de	8d 54 24 58	 lea	 edx, DWORD PTR _szVers$86352[esp+36636]
  003e2	52		 push	 edx
  003e3	eb 3d		 jmp	 SHORT $LN80@LanguageDl
$LN46@LanguageDl:

; 378  : 								{
; 379  : 									swprintf (szVers, GetString("LANG_PACK_VERSION"), L"--");

  003e5	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KEBBFOHL@LANG_PACK_VERSION?$AA@
  003ea	e8 00 00 00 00	 call	 _GetDictionaryValue
  003ef	83 c4 04	 add	 esp, 4
  003f2	85 c0		 test	 eax, eax
  003f4	75 21		 jne	 SHORT $LN48@LanguageDl
  003f6	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KEBBFOHL@LANG_PACK_VERSION?$AA@
  003fb	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@ONAPIBAL@?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$CF?$AAh?$AAs?$AA?$FL?$AA?$DP?$AA?$FN?$AA?$AA@
  00400	68 00 04 00 00	 push	 1024			; 00000400H
  00405	68 00 00 00 00	 push	 OFFSET _UnknownString
  0040a	e8 00 00 00 00	 call	 __snwprintf
  0040f	83 c4 10	 add	 esp, 16			; 00000010H
  00412	b8 00 00 00 00	 mov	 eax, OFFSET _UnknownString
$LN48@LanguageDl:
  00417	68 00 00 00 00	 push	 OFFSET ??_C@_15KHFHDPFH@?$AA?9?$AA?9?$AA?$AA@
  0041c	50		 push	 eax
  0041d	8d 44 24 58	 lea	 eax, DWORD PTR _szVers$86352[esp+36636]
  00421	50		 push	 eax
$LN80@LanguageDl:
  00422	e8 00 00 00 00	 call	 __swprintf
  00427	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN74@LanguageDl:

; 386  : 								}
; 387  : 								SetWindowTextW (GetDlgItem (hwndDlg, IDC_LANGPACK_VERSION), szVers);

  0042a	8d 4c 24 50	 lea	 ecx, DWORD PTR _szVers$86352[esp+36628]
  0042e	51		 push	 ecx
  0042f	68 d8 13 00 00	 push	 5080			; 000013d8H
  00434	57		 push	 edi
  00435	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0043b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  00441	50		 push	 eax
  00442	ff d6		 call	 esi

; 388  : 
; 389  : 								// Translator credits
; 390  : 								XmlGetAttributeText (xml, "translators", credits, sizeof (credits));

  00444	68 10 27 00 00	 push	 10000			; 00002710H
  00449	8d 94 24 e4 19
	00 00		 lea	 edx, DWORD PTR _credits$86349[esp+36632]
  00450	52		 push	 edx
  00451	68 00 00 00 00	 push	 OFFSET ??_C@_0M@DOLNAGBN@translators?$AA@
  00456	55		 push	 ebp
  00457	e8 00 00 00 00	 call	 _XmlGetAttributeText
  0045c	83 c4 10	 add	 esp, 16			; 00000010H

; 391  : 								nLen = MultiByteToWideChar (CP_UTF8, 0, credits, -1, wcredits, sizeof (wcredits) / sizeof(wcredits[0]));

  0045f	68 10 27 00 00	 push	 10000			; 00002710H
  00464	8d 84 24 f4 40
	00 00		 lea	 eax, DWORD PTR _wcredits$86350[esp+36632]
  0046b	50		 push	 eax
  0046c	6a ff		 push	 -1
  0046e	8d 8c 24 ec 19
	00 00		 lea	 ecx, DWORD PTR _credits$86349[esp+36640]
  00475	51		 push	 ecx
  00476	6a 00		 push	 0
  00478	68 e9 fd 00 00	 push	 65001			; 0000fde9H
  0047d	ff d3		 call	 ebx

; 392  : 								if (nLen != 0 && nLen != ERROR_NO_UNICODE_TRANSLATION)

  0047f	85 c0		 test	 eax, eax
  00481	74 1e		 je	 SHORT $LN75@LanguageDl
  00483	3d 59 04 00 00	 cmp	 eax, 1113		; 00000459H
  00488	74 17		 je	 SHORT $LN75@LanguageDl

; 393  : 								{
; 394  : 									SetWindowTextW (GetDlgItem (hwndDlg, IDC_LANGPACK_CREDITS), wcredits);

  0048a	8d 94 24 f0 40
	00 00		 lea	 edx, DWORD PTR _wcredits$86350[esp+36628]
  00491	52		 push	 edx
  00492	68 d7 13 00 00	 push	 5079			; 000013d7H
  00497	57		 push	 edi
  00498	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0049e	50		 push	 eax
  0049f	ff d6		 call	 esi
$LN75@LanguageDl:

; 395  : 								}
; 396  : 							}
; 397  : 
; 398  : 							strcpy (lastLangId, attr);

  004a1	33 c0		 xor	 eax, eax
$LL40@LanguageDl:
  004a3	8a 8c 04 e0 01
	00 00		 mov	 cl, BYTE PTR _attr$86317[esp+eax+36628]
  004aa	88 4c 04 1c	 mov	 BYTE PTR _lastLangId$86318[esp+eax+36628], cl
  004ae	40		 inc	 eax
  004af	84 c9		 test	 cl, cl
  004b1	75 f0		 jne	 SHORT $LL40@LanguageDl

; 399  : 							langCount++;

  004b3	ff 44 24 14	 inc	 DWORD PTR _langCount$86321[esp+36628]
$LN76@LanguageDl:

; 400  : 						}
; 401  : 					}
; 402  : 
; 403  : 					xml++;

  004b7	45		 inc	 ebp
$LN60@LanguageDl:

; 338  : 			{
; 339  : 				while (xml = XmlFindElement (xml, "language"))

  004b8	68 00 00 00 00	 push	 OFFSET ??_C@_08JGCCIMAA@language?$AA@
  004bd	55		 push	 ebp
  004be	e8 00 00 00 00	 call	 _XmlFindElement
  004c3	8b e8		 mov	 ebp, eax
  004c5	83 c4 08	 add	 esp, 8
  004c8	85 ed		 test	 ebp, ebp
  004ca	0f 85 10 fd ff
	ff		 jne	 $LL31@LanguageDl
$LN33@LanguageDl:

; 336  : 
; 337  : 			for (xml = MapFirstLanguageFile (); xml != NULL; xml = MapNextLanguageFile ())

  004d0	e8 00 00 00 00	 call	 _MapNextLanguageFile
  004d5	85 c0		 test	 eax, eax
  004d7	0f 85 e3 fc ff
	ff		 jne	 $LL34@LanguageDl
  004dd	5d		 pop	 ebp
$LN32@LanguageDl:

; 404  : 				}
; 405  : 			}
; 406  : 
; 407  : 			if (lParam == 1)

  004de	83 bc 24 20 8f
	00 00 01	 cmp	 DWORD PTR _lParam$[esp+36620], 1
  004e6	75 2f		 jne	 SHORT $LN14@LanguageDl

; 408  : 			{
; 409  : 				// Auto mode
; 410  : 				if (langCount < 2) 

  004e8	8b 5c 24 10	 mov	 ebx, DWORD PTR _langCount$86321[esp+36624]
  004ec	83 fb 02	 cmp	 ebx, 2
  004ef	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__EndDialog@8
  004f5	7d 08		 jge	 SHORT $LN81@LanguageDl

; 411  : 					EndDialog (hwndDlg, IDCANCEL);

  004f7	6a 02		 push	 2
  004f9	57		 push	 edi
  004fa	ff d6		 call	 esi

; 412  : 
; 413  : 				if (langCount == 2)

  004fc	83 fb 02	 cmp	 ebx, 2
$LN81@LanguageDl:
  004ff	75 11		 jne	 SHORT $LN77@LanguageDl

; 414  : 					strcpy (PreferredLangId, lastLangId);

  00501	33 c0		 xor	 eax, eax
$LL41@LanguageDl:
  00503	8a 4c 04 18	 mov	 cl, BYTE PTR _lastLangId$86318[esp+eax+36624]
  00507	88 88 00 00 00
	00		 mov	 BYTE PTR _PreferredLangId[eax], cl
  0050d	40		 inc	 eax
  0050e	84 c9		 test	 cl, cl
  00510	75 f1		 jne	 SHORT $LL41@LanguageDl
$LN77@LanguageDl:

; 415  : 				
; 416  : 				EndDialog (hwndDlg, IDOK);

  00512	6a 01		 push	 1
  00514	57		 push	 edi
  00515	ff d6		 call	 esi
$LN14@LanguageDl:
  00517	5b		 pop	 ebx
$LN79@LanguageDl:

; 417  : 			}
; 418  : 
; 419  : 			return 1;

  00518	b8 01 00 00 00	 mov	 eax, 1
$LN38@LanguageDl:

; 481  : }

  0051d	8b 8c 24 08 8f
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+36620]
  00524	5f		 pop	 edi
  00525	5e		 pop	 esi
  00526	33 cc		 xor	 ecx, esp
  00528	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0052d	81 c4 04 8f 00
	00		 add	 esp, 36612		; 00008f04H
  00533	c2 10 00	 ret	 16			; 00000010H
_LanguageDlgProc@16 ENDP
_TEXT	ENDS
END
