; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp_MmMapLockedPagesSpecifyCache:PROC
	ALIGN	8

BootDriveFilterExtension DQ 01H DUP (?)
WriteFilterBuffer DQ 01H DUP (?)
;	COMDAT ??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'T', 00H, 'r', 00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r'
	DB	00H, 'y', 00H, 'p', 00H, 't', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
WriteFilterBufferSize DQ 01H DUP (?)
;	COMDAT pdata
; File c:\users\public\desktop\projects\ciphershed\src\driver\dumpfilter.c
pdata	SEGMENT
$pdata$DumpFilterUnload DD imagerel DumpFilterUnload
	DD	imagerel DumpFilterUnload+63
	DD	imagerel $unwind$DumpFilterUnload
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DumpFilterUnload DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT DumpFilterUnload
_TEXT	SEGMENT
filterExtension$ = 48
DumpFilterUnload PROC					; COMDAT

; 233  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 234  : 	Dump ("DumpFilterUnload type=%d\n", filterExtension->DumpType);
; 235  : 
; 236  : 	if (WriteFilterBuffer)

  00004	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR WriteFilterBuffer, 0
  0000c	74 2a		 je	 SHORT $LN1@DumpFilter

; 237  : 	{
; 238  : 		memset (WriteFilterBuffer, 0, WriteFilterBufferSize);

  0000e	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR WriteFilterBufferSize
  00015	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR WriteFilterBuffer
  0001c	33 d2		 xor	 edx, edx
  0001e	e8 00 00 00 00	 call	 memset

; 239  : 		MmFreeContiguousMemory (WriteFilterBuffer);

  00023	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR WriteFilterBuffer
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmFreeContiguousMemory

; 240  : 		WriteFilterBuffer = NULL;

  00030	48 83 25 00 00
	00 00 00	 and	 QWORD PTR WriteFilterBuffer, 0
$LN1@DumpFilter:

; 241  : 	}
; 242  : 
; 243  : 	return STATUS_SUCCESS;

  00038	33 c0		 xor	 eax, eax

; 244  : }

  0003a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003e	c3		 ret	 0
DumpFilterUnload ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT DumpFilterFinish
_TEXT	SEGMENT
filterExtension$ = 8
DumpFilterFinish PROC					; COMDAT

; 226  : 	Dump ("DumpFilterFinish type=%d\n", filterExtension->DumpType);
; 227  : 
; 228  : 	return STATUS_SUCCESS;

  00000	33 c0		 xor	 eax, eax

; 229  : }

  00002	c3		 ret	 0
DumpFilterFinish ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DumpFilterStart DD imagerel DumpFilterStart
	DD	imagerel DumpFilterStart+83
	DD	imagerel $unwind$DumpFilterStart
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DumpFilterStart DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT DumpFilterStart
_TEXT	SEGMENT
filterExtension$ = 64
DumpFilterStart PROC					; COMDAT

; 141  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 142  : 	Dump ("DumpFilterStart type=%d\n", filterExtension->DumpType);
; 143  : 
; 144  : 	if (BootDriveFilterExtension->MagicNumber != TC_BOOT_DRIVE_FILTER_EXTENSION_MAGIC_NUMBER)

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  0000b	48 b9 54 58 45
	42 45 55 52 54	 mov	 rcx, 6076012603229165652 ; 5452554542455854H
  00015	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  00019	74 22		 je	 SHORT $LN1@DumpFilter@2

; 145  : 		TC_BUG_CHECK (STATUS_CRC_ERROR);

  0001b	ba 91 00 00 00	 mov	 edx, 145		; 00000091H
  00020	45 33 c9	 xor	 r9d, r9d
  00023	49 c7 c0 3f 00
	00 c0		 mov	 r8, -1073741761		; ffffffffc000003fH
  0002a	8d 4a 98	 lea	 ecx, QWORD PTR [rdx-104]
  0002d	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  0003c	cc		 int	 3
$LN1@DumpFilter@2:

; 146  : 
; 147  : 	return BootDriveFilterExtension->DriveMounted ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;

  0003d	8b 80 b8 02 00
	00		 mov	 eax, DWORD PTR [rax+696]
  00043	f7 d8		 neg	 eax
  00045	1b c0		 sbb	 eax, eax
  00047	f7 d0		 not	 eax
  00049	25 01 00 00 c0	 and	 eax, -1073741823	; ffffffffc0000001H

; 148  : }

  0004e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00052	c3		 ret	 0
$LN4@DumpFilter@2:
DumpFilterStart ENDP
DumpPartitionOffset DQ 01H DUP (?)
;	COMDAT pdata
; File c:\users\public\desktop\projects\ciphershed\src\driver\ntdriver.c
pdata	SEGMENT
$pdata$DumpFilterWrite DD imagerel DumpFilterWrite
	DD	imagerel DumpFilterWrite+693
	DD	imagerel $unwind$DumpFilterWrite
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DumpFilterWrite DD 0a1801H
	DD	0d6418H
	DD	0c5418H
	DD	0a3418H
	DD	0d0145218H
	DD	07010c012H
; Function compile flags: /Ogspy
; File c:\users\public\desktop\projects\ciphershed\src\driver\dumpfilter.c
xdata	ENDS
;	COMDAT DumpFilterWrite
_TEXT	SEGMENT
filterExtension$ = 80
dataUnit$29496 = 88
diskWriteOffset$ = 88
writeMdl$ = 96
DumpFilterWrite PROC					; COMDAT

; 152  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 08	 mov	 QWORD PTR [r11+8], rbx
  00007	49 89 6b 18	 mov	 QWORD PTR [r11+24], rbp
  0000b	49 89 73 20	 mov	 QWORD PTR [r11+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 153  : 	ULONG dataLength = MmGetMdlByteCount (writeMdl);
; 154  : 	uint64 offset = DumpPartitionOffset.QuadPart + diskWriteOffset->QuadPart;

  00018	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR DumpPartitionOffset

; 155  : 	uint64 intersectStart;
; 156  : 	uint32 intersectLength;
; 157  : 	PVOID writeBuffer;
; 158  : 	CSHORT origMdlFlags;
; 159  : 
; 160  : 	if (BootDriveFilterExtension->MagicNumber != TC_BOOT_DRIVE_FILTER_EXTENSION_MAGIC_NUMBER)

  0001f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00026	41 8b 70 28	 mov	 esi, DWORD PTR [r8+40]
  0002a	48 03 1a	 add	 rbx, QWORD PTR [rdx]
  0002d	48 b9 54 58 45
	42 45 55 52 54	 mov	 rcx, 6076012603229165652 ; 5452554542455854H
  00037	49 8b f8	 mov	 rdi, r8
  0003a	48 8b ea	 mov	 rbp, rdx
  0003d	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  00041	74 21		 je	 SHORT $LN10@DumpFilter@3

; 161  : 		TC_BUG_CHECK (STATUS_CRC_ERROR);

  00043	ba a1 00 00 00	 mov	 edx, 161		; 000000a1H
  00048	45 33 c9	 xor	 r9d, r9d
  0004b	49 c7 c0 3f 00
	00 c0		 mov	 r8, -1073741761		; ffffffffc000003fH
  00052	8d 4a 88	 lea	 ecx, QWORD PTR [rdx-120]
  00055	49 c7 43 d8 43
	54 00 00	 mov	 QWORD PTR [r11-40], 21571 ; 00005443H
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00063	cc		 int	 3
$LN10@DumpFilter@3:

; 162  : 
; 163  : 	if (BootDriveFilterExtension->Queue.EncryptedAreaEndUpdatePending)	// Hibernation should always abort the setup thread

  00064	8b 80 d8 00 00
	00		 mov	 eax, DWORD PTR [rax+216]
  0006a	45 33 ed	 xor	 r13d, r13d
  0006d	41 3b c5	 cmp	 eax, r13d
  00070	74 22		 je	 SHORT $LN9@DumpFilter@3

; 164  : 		TC_BUG_CHECK (STATUS_INVALID_PARAMETER);

  00072	ba a4 00 00 00	 mov	 edx, 164		; 000000a4H
  00077	45 33 c9	 xor	 r9d, r9d
  0007a	49 c7 c0 0d 00
	00 c0		 mov	 r8, -1073741811		; ffffffffc000000dH
  00081	8d 4a 85	 lea	 ecx, QWORD PTR [rdx-123]
  00084	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00093	cc		 int	 3
$LN9@DumpFilter@3:

; 165  : 
; 166  : 	if (BootDriveFilterExtension->Queue.EncryptedAreaStart == -1 || BootDriveFilterExtension->Queue.EncryptedAreaEnd == -1)

  00094	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  0009b	48 83 b8 c8 00
	00 00 ff	 cmp	 QWORD PTR [rax+200], -1
  000a3	0f 84 f1 01 00
	00		 je	 $LN7@DumpFilter@3
  000a9	48 8b 80 d0 00
	00 00		 mov	 rax, QWORD PTR [rax+208]
  000b0	48 83 f8 ff	 cmp	 rax, -1
  000b4	0f 84 e0 01 00
	00		 je	 $LN7@DumpFilter@3

; 167  : 		return STATUS_SUCCESS;
; 168  : 
; 169  : 	if (dataLength > WriteFilterBufferSize)

  000ba	48 3b 35 00 00
	00 00		 cmp	 rsi, QWORD PTR WriteFilterBufferSize
  000c1	76 23		 jbe	 SHORT $LN6@DumpFilter@3

; 170  : 		TC_BUG_CHECK (STATUS_BUFFER_OVERFLOW);	// Bug check is required as returning an error does not prevent data from being written to disk

  000c3	45 33 c9	 xor	 r9d, r9d
  000c6	ba aa 00 00 00	 mov	 edx, 170		; 000000aaH
  000cb	49 c7 c0 05 00
	00 80		 mov	 r8, -2147483643		; ffffffff80000005H
  000d2	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  000d6	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  000e5	cc		 int	 3
$LN6@DumpFilter@3:

; 171  : 
; 172  : 	if ((dataLength & (ENCRYPTION_DATA_UNIT_SIZE - 1)) != 0)

  000e6	b8 ff 01 00 00	 mov	 eax, 511		; 000001ffH
  000eb	85 f0		 test	 esi, eax
  000ed	74 23		 je	 SHORT $LN5@DumpFilter@3

; 173  : 		TC_BUG_CHECK (STATUS_INVALID_PARAMETER);

  000ef	45 33 c9	 xor	 r9d, r9d
  000f2	ba ad 00 00 00	 mov	 edx, 173		; 000000adH
  000f7	49 c7 c0 0d 00
	00 c0		 mov	 r8, -1073741811		; ffffffffc000000dH
  000fe	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00102	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  0010b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00111	cc		 int	 3
$LN5@DumpFilter@3:

; 174  : 
; 175  : 	if ((offset & (ENCRYPTION_DATA_UNIT_SIZE - 1)) != 0)

  00112	48 85 d8	 test	 rbx, rax
  00115	74 23		 je	 SHORT $LN4@DumpFilter@3

; 176  : 		TC_BUG_CHECK (STATUS_INVALID_PARAMETER);

  00117	45 33 c9	 xor	 r9d, r9d
  0011a	ba b0 00 00 00	 mov	 edx, 176		; 000000b0H
  0011f	49 c7 c0 0d 00
	00 c0		 mov	 r8, -1073741811		; ffffffffc000000dH
  00126	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  0012a	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00133	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00139	cc		 int	 3
$LN4@DumpFilter@3:

; 177  : 
; 178  : 	writeBuffer = MmGetSystemAddressForMdlSafe (writeMdl, HighPagePriority);

  0013a	41 f6 40 0a 05	 test	 BYTE PTR [r8+10], 5
  0013f	74 06		 je	 SHORT $LN13@DumpFilter@3
  00141	49 8b 40 18	 mov	 rax, QWORD PTR [r8+24]
  00145	eb 1f		 jmp	 SHORT $LN14@DumpFilter@3
$LN13@DumpFilter@3:
  00147	45 33 c9	 xor	 r9d, r9d
  0014a	33 d2		 xor	 edx, edx
  0014c	48 8b cf	 mov	 rcx, rdi
  0014f	45 8d 41 01	 lea	 r8d, QWORD PTR [r9+1]
  00153	c7 44 24 28 20
	00 00 00	 mov	 DWORD PTR [rsp+40], 32	; 00000020H
  0015b	44 89 6c 24 20	 mov	 DWORD PTR [rsp+32], r13d
  00160	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmMapLockedPagesSpecifyCache
$LN14@DumpFilter@3:

; 179  : 	if (!writeBuffer)

  00166	49 3b c5	 cmp	 rax, r13
  00169	75 23		 jne	 SHORT $LN3@DumpFilter@3

; 180  : 		TC_BUG_CHECK (STATUS_INSUFFICIENT_RESOURCES);

  0016b	45 33 c9	 xor	 r9d, r9d
  0016e	ba b4 00 00 00	 mov	 edx, 180		; 000000b4H
  00173	49 c7 c0 9a 00
	00 c0		 mov	 r8, -1073741670		; ffffffffc000009aH
  0017a	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  0017e	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00187	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  0018d	cc		 int	 3
$LN3@DumpFilter@3:

; 181  : 
; 182  : 	memcpy (WriteFilterBuffer, writeBuffer, dataLength);

  0018e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR WriteFilterBuffer
  00195	4c 8b c6	 mov	 r8, rsi
  00198	48 8b d0	 mov	 rdx, rax
  0019b	e8 00 00 00 00	 call	 memcpy

; 183  : 
; 184  : 	GetIntersection (offset,
; 185  : 		dataLength,
; 186  : 		BootDriveFilterExtension->Queue.EncryptedAreaStart,
; 187  : 		BootDriveFilterExtension->Queue.EncryptedAreaEnd,
; 188  : 		&intersectStart,
; 189  : 		&intersectLength);

  001a0	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR BootDriveFilterExtension
  001a7	48 8d 44 1e ff	 lea	 rax, QWORD PTR [rsi+rbx-1]
  001ac	49 8b 93 d0 00
	00 00		 mov	 rdx, QWORD PTR [r11+208]
  001b3	4c 8b 15 00 00
	00 00		 mov	 r10, QWORD PTR BootDriveFilterExtension
  001ba	4d 8b 8a c8 00
	00 00		 mov	 r9, QWORD PTR [r10+200]
  001c1	48 3b c2	 cmp	 rax, rdx
  001c4	48 0f 46 d0	 cmovbe	 rdx, rax
  001c8	49 3b d9	 cmp	 rbx, r9
  001cb	4c 0f 43 cb	 cmovae	 r9, rbx
  001cf	4c 3b ca	 cmp	 r9, rdx
  001d2	76 05		 jbe	 SHORT $LN18@DumpFilter@3
  001d4	41 8b d5	 mov	 edx, r13d
  001d7	eb 08		 jmp	 SHORT $LN20@DumpFilter@3
$LN18@DumpFilter@3:
  001d9	41 2b d1	 sub	 edx, r9d
  001dc	83 c2 01	 add	 edx, 1
  001df	75 03		 jne	 SHORT $LN15@DumpFilter@3
$LN20@DumpFilter@3:
  001e1	4c 8b cb	 mov	 r9, rbx
$LN15@DumpFilter@3:

; 190  : 
; 191  : 	if (intersectLength > 0)

  001e4	41 3b d5	 cmp	 edx, r13d
  001e7	76 51		 jbe	 SHORT $LN2@DumpFilter@3

; 192  : 	{
; 193  : 		UINT64_STRUCT dataUnit;
; 194  : 		dataUnit.Value = intersectStart / ENCRYPTION_DATA_UNIT_SIZE;

  001e9	49 8b c1	 mov	 rax, r9
  001ec	48 c1 e8 09	 shr	 rax, 9
  001f0	48 89 44 24 58	 mov	 QWORD PTR dataUnit$29496[rsp], rax

; 195  : 
; 196  : 		if (BootDriveFilterExtension->Queue.RemapEncryptedArea)

  001f5	45 39 aa dc 00
	00 00		 cmp	 DWORD PTR [r10+220], r13d
  001fc	74 17		 je	 SHORT $LN1@DumpFilter@3

; 197  : 		{
; 198  : 			diskWriteOffset->QuadPart += BootDriveFilterExtension->Queue.RemappedAreaOffset;

  001fe	49 8b 8a e0 00
	00 00		 mov	 rcx, QWORD PTR [r10+224]
  00205	48 01 4d 00	 add	 QWORD PTR [rbp], rcx

; 199  : 			dataUnit.Value += BootDriveFilterExtension->Queue.RemappedAreaDataUnitOffset;

  00209	49 03 82 e8 00
	00 00		 add	 rax, QWORD PTR [r10+232]
  00210	48 89 44 24 58	 mov	 QWORD PTR dataUnit$29496[rsp], rax
$LN1@DumpFilter@3:

; 200  : 		}
; 201  : 
; 202  : 		EncryptDataUnitsCurrentThread (WriteFilterBuffer + (intersectStart - offset),
; 203  : 			&dataUnit,
; 204  : 			intersectLength / ENCRYPTION_DATA_UNIT_SIZE,
; 205  : 			BootDriveFilterExtension->Queue.CryptoInfo);

  00215	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR WriteFilterBuffer
  0021c	44 8b c2	 mov	 r8d, edx
  0021f	48 8d 54 24 58	 lea	 rdx, QWORD PTR dataUnit$29496[rsp]
  00224	48 2b cb	 sub	 rcx, rbx
  00227	49 c1 e8 09	 shr	 r8, 9
  0022b	49 03 c9	 add	 rcx, r9
  0022e	4d 8b 8a 98 00
	00 00		 mov	 r9, QWORD PTR [r10+152]
  00235	e8 00 00 00 00	 call	 EncryptDataUnitsCurrentThread
$LN2@DumpFilter@3:

; 206  : 	}
; 207  : 
; 208  : 	origMdlFlags = writeMdl->MdlFlags;
; 209  : 
; 210  : 	MmInitializeMdl (writeMdl, WriteFilterBuffer, dataLength);

  0023a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR WriteFilterBuffer
  00241	0f b7 5f 0a	 movzx	 ebx, WORD PTR [rdi+10]
  00245	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  0024a	44 8b c2	 mov	 r8d, edx
  0024d	8b c6		 mov	 eax, esi
  0024f	48 81 e2 00 f0
	ff ff		 and	 rdx, -4096		; fffffffffffff000H
  00256	23 c1		 and	 eax, ecx
  00258	44 23 c1	 and	 r8d, ecx
  0025b	4c 89 2f	 mov	 QWORD PTR [rdi], r13
  0025e	42 8d 8c 00 ff
	0f 00 00	 lea	 ecx, DWORD PTR [rax+r8+4095]
  00266	8b c6		 mov	 eax, esi
  00268	66 44 89 6f 0a	 mov	 WORD PTR [rdi+10], r13w
  0026d	c1 e9 0c	 shr	 ecx, 12
  00270	c1 e8 0c	 shr	 eax, 12
  00273	48 89 57 20	 mov	 QWORD PTR [rdi+32], rdx
  00277	66 03 c8	 add	 cx, ax
  0027a	44 89 47 2c	 mov	 DWORD PTR [rdi+44], r8d
  0027e	89 77 28	 mov	 DWORD PTR [rdi+40], esi
  00281	66 83 c1 06	 add	 cx, 6
  00285	66 c1 e1 03	 shl	 cx, 3
  00289	66 89 4f 08	 mov	 WORD PTR [rdi+8], cx

; 211  : 	MmBuildMdlForNonPagedPool (writeMdl);

  0028d	48 8b cf	 mov	 rcx, rdi
  00290	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmBuildMdlForNonPagedPool

; 212  : 
; 213  : 	// Instead of using MmGetSystemAddressForMdlSafe(), some buggy custom storage drivers may directly test MDL_MAPPED_TO_SYSTEM_VA flag,
; 214  : 	// disregarding the fact that other MDL flags may be set by the system or a dump filter (e.g. MDL_SOURCE_IS_NONPAGED_POOL flag only).
; 215  : 	// Therefore, to work around this issue, the original flags will be restored even if they do not match the new MDL.
; 216  : 	// MS BitLocker also uses this hack/workaround (it should be safe to use until the MDL structure is changed).
; 217  : 
; 218  : 	writeMdl->MdlFlags = origMdlFlags;

  00296	66 89 5f 0a	 mov	 WORD PTR [rdi+10], bx
$LN7@DumpFilter@3:

; 219  : 
; 220  : 	return STATUS_SUCCESS;
; 221  : }

  0029a	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0029f	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  002a4	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  002a9	33 c0		 xor	 eax, eax
  002ab	48 83 c4 30	 add	 rsp, 48			; 00000030H
  002af	41 5d		 pop	 r13
  002b1	41 5c		 pop	 r12
  002b3	5f		 pop	 rdi
  002b4	c3		 ret	 0
$LN21@DumpFilter@3:
DumpFilterWrite ENDP
PUBLIC	DumpFilterEntry
;	COMDAT pdata
; File c:\users\public\desktop\projects\ciphershed\src\common\crypto.c
pdata	SEGMENT
$pdata$DumpFilterEntry DD imagerel $LN19
	DD	imagerel $LN19+491
	DD	imagerel $unwind$DumpFilterEntry
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DumpFilterEntry DD 040c01H
	DD	010340cH
	DD	07008d20cH
; Function compile flags: /Ogspy
; File c:\users\public\desktop\projects\ciphershed\src\driver\dumpfilter.c
xdata	ENDS
;	COMDAT DumpFilterEntry
_TEXT	SEGMENT
dumpConfig$ = 48
storageDeviceNumber$ = 64
partitionInfo$ = 80
filterExtension$ = 128
version$ = 136
filterInitData$ = 136
DumpFilterEntry PROC					; COMDAT

; 21   : {

$LN19:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	57		 push	 rdi
  00008	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 22   : 	GetSystemDriveDumpConfigRequest dumpConfig;
; 23   : 	PHYSICAL_ADDRESS highestAcceptableWriteBufferAddr;
; 24   : 	STORAGE_DEVICE_NUMBER storageDeviceNumber;
; 25   : 	PARTITION_INFORMATION partitionInfo;
; 26   : 	LONG version;
; 27   : 	NTSTATUS status;
; 28   : 
; 29   : 	Dump ("DumpFilterEntry type=%d\n", filterExtension->DumpType);
; 30   : 
; 31   : 	filterInitData->MajorVersion = DUMP_FILTER_MAJOR_VERSION;
; 32   : 	filterInitData->MinorVersion = DUMP_FILTER_MINOR_VERSION;

  0000c	83 62 04 00	 and	 DWORD PTR [rdx+4], 0

; 33   : 	filterInitData->Flags |= DUMP_FILTER_CRITICAL;

  00010	83 4a 34 01	 or	 DWORD PTR [rdx+52], 1

; 34   : 
; 35   : 	// Check driver version of the main device
; 36   : 	status = TCDeviceIoControl (NT_ROOT_PREFIX, TC_IOCTL_GET_DRIVER_VERSION, NULL, 0, &version, sizeof (version));

  00014	c7 40 b0 04 00
	00 00		 mov	 DWORD PTR [rax-80], 4
  0001b	48 8d 40 10	 lea	 rax, QWORD PTR [rax+16]
  0001f	48 8b f9	 mov	 rdi, rcx
  00022	48 8b da	 mov	 rbx, rdx
  00025	c7 02 01 00 00
	00		 mov	 DWORD PTR [rdx], 1
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
  00032	45 33 c9	 xor	 r9d, r9d
  00035	45 33 c0	 xor	 r8d, r8d
  00038	ba 04 20 22 00	 mov	 edx, 2236420		; 00222004H
  0003d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00042	e8 00 00 00 00	 call	 TCDeviceIoControl

; 37   : 	if (!NT_SUCCESS (status))

  00047	85 c0		 test	 eax, eax
  00049	0f 88 8e 01 00
	00		 js	 $err$29416

; 38   : 		goto err;
; 39   : 
; 40   : 	if (version != VERSION_NUM)

  0004f	81 bc 24 88 00
	00 00 40 07 00
	00		 cmp	 DWORD PTR version$[rsp], 1856 ; 00000740H
  0005a	74 0a		 je	 SHORT $LN12@DumpFilter@4
$LN18@DumpFilter@4:

; 41   : 	{
; 42   : 		status = STATUS_INVALID_PARAMETER;

  0005c	b8 0d 00 00 c0	 mov	 eax, -1073741811	; ffffffffc000000dH

; 43   : 		goto err;

  00061	e9 77 01 00 00	 jmp	 $err$29416
$LN12@DumpFilter@4:

; 44   : 	}
; 45   : 
; 46   : 	// Get dump configuration from the main device
; 47   : 	status = TCDeviceIoControl (NT_ROOT_PREFIX, TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG, NULL, 0, &dumpConfig, sizeof (dumpConfig));

  00066	48 8d 44 24 30	 lea	 rax, QWORD PTR dumpConfig$[rsp]
  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
  00072	45 33 c9	 xor	 r9d, r9d
  00075	45 33 c0	 xor	 r8d, r8d
  00078	ba 98 20 22 00	 mov	 edx, 2236568		; 00222098H
  0007d	c7 44 24 28 0c
	00 00 00	 mov	 DWORD PTR [rsp+40], 12
  00085	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008a	e8 00 00 00 00	 call	 TCDeviceIoControl

; 48   : 	if (!NT_SUCCESS (status))

  0008f	85 c0		 test	 eax, eax
  00091	0f 88 46 01 00
	00		 js	 $err$29416

; 49   : 		goto err;
; 50   : 
; 51   : 	BootDriveFilterExtension = dumpConfig.BootDriveFilterExtension;

  00097	48 8b 44 24 30	 mov	 rax, QWORD PTR dumpConfig$[rsp]

; 52   : 
; 53   : 	if (BootDriveFilterExtension->MagicNumber != TC_BOOT_DRIVE_FILTER_EXTENSION_MAGIC_NUMBER)

  0009c	48 b9 54 58 45
	42 45 55 52 54	 mov	 rcx, 6076012603229165652 ; 5452554542455854H
  000a6	48 89 05 00 00
	00 00		 mov	 QWORD PTR BootDriveFilterExtension, rax
  000ad	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  000b1	74 0a		 je	 SHORT $LN10@DumpFilter@4

; 54   : 	{
; 55   : 		status = STATUS_CRC_ERROR;

  000b3	b8 3f 00 00 c0	 mov	 eax, -1073741761	; ffffffffc000003fH

; 56   : 		goto err;

  000b8	e9 20 01 00 00	 jmp	 $err$29416
$LN10@DumpFilter@4:

; 57   : 	}
; 58   : 
; 59   : 	// KeSaveFloatingPointState() may generate a bug check during crash dump
; 60   : #if !defined (_WIN64)
; 61   : 	if (filterExtension->DumpType == DumpTypeCrashdump)
; 62   : 		dumpConfig.HwEncryptionEnabled = FALSE;
; 63   : #endif
; 64   : 
; 65   : 	EnableHwEncryption (dumpConfig.HwEncryptionEnabled);

  000bd	33 c0		 xor	 eax, eax
  000bf	39 44 24 38	 cmp	 DWORD PTR dumpConfig$[rsp+8], eax
  000c3	0f 94 c0	 sete	 al
  000c6	89 05 00 00 00
	00		 mov	 DWORD PTR HwEncryptionDisabled, eax

; 66   : 
; 67   : 	if (!AutoTestAlgorithms())

  000cc	e8 00 00 00 00	 call	 AutoTestAlgorithms
  000d1	85 c0		 test	 eax, eax

; 68   : 	{
; 69   : 		status = STATUS_INVALID_PARAMETER;
; 70   : 		goto err;

  000d3	74 87		 je	 SHORT $LN18@DumpFilter@4

; 71   : 	}
; 72   : 
; 73   : 	// Check dump volume is located on the system drive
; 74   : 	status = SendDeviceIoControlRequest (filterExtension->DeviceObject, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0, &storageDeviceNumber, sizeof (storageDeviceNumber));

  000d5	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  000d9	48 8d 44 24 40	 lea	 rax, QWORD PTR storageDeviceNumber$[rsp]
  000de	45 33 c9	 xor	 r9d, r9d
  000e1	45 33 c0	 xor	 r8d, r8d
  000e4	ba 80 10 2d 00	 mov	 edx, 2953344		; 002d1080H
  000e9	c7 44 24 28 0c
	00 00 00	 mov	 DWORD PTR [rsp+40], 12
  000f1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f6	e8 00 00 00 00	 call	 SendDeviceIoControlRequest

; 75   : 	if (!NT_SUCCESS (status))

  000fb	85 c0		 test	 eax, eax
  000fd	0f 88 da 00 00
	00		 js	 $err$29416

; 76   : 		goto err;
; 77   : 
; 78   : 	if (!BootDriveFilterExtension->SystemStorageDeviceNumberValid)

  00103	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  0010a	83 78 34 00	 cmp	 DWORD PTR [rax+52], 0

; 79   : 	{
; 80   : 		status = STATUS_INVALID_PARAMETER;
; 81   : 		goto err;

  0010e	0f 84 48 ff ff
	ff		 je	 $LN18@DumpFilter@4

; 82   : 	}
; 83   : 
; 84   : 	if (storageDeviceNumber.DeviceNumber != BootDriveFilterExtension->SystemStorageDeviceNumber)

  00114	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00117	39 44 24 44	 cmp	 DWORD PTR storageDeviceNumber$[rsp+4], eax

; 85   : 	{
; 86   : 		status = STATUS_ACCESS_DENIED;
; 87   : 		goto err;

  0011b	0f 85 b7 00 00
	00		 jne	 $LN3@DumpFilter@4

; 88   : 	}
; 89   : 
; 90   : 	// Check dump volume is located within the scope of system encryption
; 91   : 	status = SendDeviceIoControlRequest (filterExtension->DeviceObject, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0, &partitionInfo, sizeof (partitionInfo));

  00121	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  00125	48 8d 44 24 50	 lea	 rax, QWORD PTR partitionInfo$[rsp]
  0012a	45 33 c9	 xor	 r9d, r9d
  0012d	45 33 c0	 xor	 r8d, r8d
  00130	ba 04 40 07 00	 mov	 edx, 475140		; 00074004H
  00135	c7 44 24 28 20
	00 00 00	 mov	 DWORD PTR [rsp+40], 32	; 00000020H
  0013d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00142	e8 00 00 00 00	 call	 SendDeviceIoControlRequest

; 92   : 	if (!NT_SUCCESS (status))

  00147	85 c0		 test	 eax, eax
  00149	0f 88 8e 00 00
	00		 js	 $err$29416

; 93   : 		goto err;
; 94   : 
; 95   : 	DumpPartitionOffset = partitionInfo.StartingOffset;

  0014f	48 8b 44 24 50	 mov	 rax, QWORD PTR partitionInfo$[rsp]

; 96   : 
; 97   : 	if (DumpPartitionOffset.QuadPart < BootDriveFilterExtension->ConfiguredEncryptedAreaStart
; 98   : 		|| DumpPartitionOffset.QuadPart > BootDriveFilterExtension->ConfiguredEncryptedAreaEnd)

  00154	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR BootDriveFilterExtension
  0015b	48 3b 41 38	 cmp	 rax, QWORD PTR [rcx+56]
  0015f	48 89 05 00 00
	00 00		 mov	 QWORD PTR DumpPartitionOffset, rax
  00166	7c 70		 jl	 SHORT $LN3@DumpFilter@4
  00168	48 3b 41 40	 cmp	 rax, QWORD PTR [rcx+64]
  0016c	7f 6a		 jg	 SHORT $LN3@DumpFilter@4

; 101  : 		goto err;
; 102  : 	}
; 103  : 
; 104  : 	// Allocate buffer for encryption
; 105  : 	if (filterInitData->MaxPagesPerWrite == 0)

  0016e	8b 43 30	 mov	 eax, DWORD PTR [rbx+48]
  00171	85 c0		 test	 eax, eax

; 106  : 	{
; 107  : 		status = STATUS_INVALID_PARAMETER;
; 108  : 		goto err;

  00173	0f 84 e3 fe ff
	ff		 je	 $LN18@DumpFilter@4

; 109  : 	}
; 110  : 
; 111  : 	WriteFilterBufferSize = filterInitData->MaxPagesPerWrite * PAGE_SIZE;

  00179	c1 e0 0c	 shl	 eax, 12

; 112  : 
; 113  : #ifdef _WIN64
; 114  : 	highestAcceptableWriteBufferAddr.QuadPart = 0x7FFffffFFFFLL;

  0017c	48 ba ff ff ff
	ff ff 07 00 00	 mov	 rdx, 8796093022207	; 000007ffffffffffH
  00186	8b c8		 mov	 ecx, eax
  00188	48 89 0d 00 00
	00 00		 mov	 QWORD PTR WriteFilterBufferSize, rcx

; 115  : #else
; 116  : 	highestAcceptableWriteBufferAddr.QuadPart = 0xffffFFFFLL;
; 117  : #endif
; 118  : 
; 119  : 	WriteFilterBuffer = MmAllocateContiguousMemory (WriteFilterBufferSize, highestAcceptableWriteBufferAddr);

  0018f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmAllocateContiguousMemory
  00195	48 89 05 00 00
	00 00		 mov	 QWORD PTR WriteFilterBuffer, rax

; 120  : 	if (!WriteFilterBuffer)

  0019c	48 85 c0	 test	 rax, rax
  0019f	75 07		 jne	 SHORT $LN1@DumpFilter@4

; 121  : 	{
; 122  : 		status = STATUS_INSUFFICIENT_RESOURCES;

  001a1	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH

; 123  : 		goto err;

  001a6	eb 35		 jmp	 SHORT $err$29416
$LN1@DumpFilter@4:

; 124  : 	}
; 125  : 
; 126  : 	filterInitData->DumpStart = DumpFilterStart;

  001a8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:DumpFilterStart
  001af	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax

; 127  : 	filterInitData->DumpWrite = DumpFilterWrite;

  001b3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:DumpFilterWrite
  001ba	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 128  : 	filterInitData->DumpFinish = DumpFilterFinish;

  001be	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:DumpFilterFinish
  001c5	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax

; 129  : 	filterInitData->DumpUnload = DumpFilterUnload;

  001c9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:DumpFilterUnload
  001d0	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 130  : 
; 131  : 	Dump ("Dump filter loaded type=%d\n", filterExtension->DumpType);
; 132  : 	return STATUS_SUCCESS;

  001d4	33 c0		 xor	 eax, eax
  001d6	eb 05		 jmp	 SHORT $err$29416
$LN3@DumpFilter@4:

; 99   : 	{
; 100  : 		status = STATUS_ACCESS_DENIED;

  001d8	b8 22 00 00 c0	 mov	 eax, -1073741790	; ffffffffc0000022H
$err$29416:

; 133  : 
; 134  : err:
; 135  : 	Dump ("DumpFilterEntry error %x\n", status);
; 136  : 	return status;
; 137  : }

  001dd	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  001e5	48 83 c4 70	 add	 rsp, 112		; 00000070H
  001e9	5f		 pop	 rdi
  001ea	c3		 ret	 0
DumpFilterEntry ENDP
END
