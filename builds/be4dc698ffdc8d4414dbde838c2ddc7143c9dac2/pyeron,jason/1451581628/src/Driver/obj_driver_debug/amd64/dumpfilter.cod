; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BJ@DKEIHACK@DumpFilterEntry?5type?$DN?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BM@NIHDEFIH@Dump?5filter?5loaded?5type?$DN?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BK@MPDBPBLL@DumpFilterEntry?5error?5?$CFx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BJ@IKOJIFKO@DumpFilterStart?5type?$DN?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BK@EIOFNLAN@DumpFilterFinish?5type?$DN?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BK@LHLJKEKP@DumpFilterUnload?5type?$DN?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp_MmMapLockedPagesSpecifyCache:PROC
	ALIGN	8

BootDriveFilterExtension DQ 01H DUP (?)
WriteFilterBuffer DQ 01H DUP (?)
;	COMDAT ??_C@_0BK@LHLJKEKP@DumpFilterUnload?5type?$DN?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BK@LHLJKEKP@DumpFilterUnload?5type?$DN?$CFd?6?$AA@FNODOBFM@ DB 'Du'
	DB	'mpFilterUnload type=%d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BK@EIOFNLAN@DumpFilterFinish?5type?$DN?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BK@EIOFNLAN@DumpFilterFinish?5type?$DN?$CFd?6?$AA@FNODOBFM@ DB 'Du'
	DB	'mpFilterFinish type=%d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BJ@IKOJIFKO@DumpFilterStart?5type?$DN?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BJ@IKOJIFKO@DumpFilterStart?5type?$DN?$CFd?6?$AA@FNODOBFM@ DB 'Dum'
	DB	'pFilterStart type=%d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BK@MPDBPBLL@DumpFilterEntry?5error?5?$CFx?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BK@MPDBPBLL@DumpFilterEntry?5error?5?$CFx?6?$AA@FNODOBFM@ DB 'Dump'
	DB	'FilterEntry error %x', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BM@NIHDEFIH@Dump?5filter?5loaded?5type?$DN?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BM@NIHDEFIH@Dump?5filter?5loaded?5type?$DN?$CFd?6?$AA@FNODOBFM@ DB 'D'
	DB	'ump filter loaded type=%d', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'T', 00H, 'r', 00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r'
	DB	00H, 'y', 00H, 'p', 00H, 't', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BJ@DKEIHACK@DumpFilterEntry?5type?$DN?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BJ@DKEIHACK@DumpFilterEntry?5type?$DN?$CFd?6?$AA@FNODOBFM@ DB 'Dum'
	DB	'pFilterEntry type=%d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
WriteFilterBufferSize DQ 01H DUP (?)
;	COMDAT pdata
; File c:\users\public\desktop\projects\ciphershed\src\driver\dumpfilter.c
pdata	SEGMENT
$pdata$DumpFilterUnload DD imagerel DumpFilterUnload
	DD	imagerel DumpFilterUnload+89
	DD	imagerel $unwind$DumpFilterUnload
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DumpFilterUnload DD 020a01H
	DD	07006320aH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DumpFilterUnload
_TEXT	SEGMENT
filterExtension$ = 48
DumpFilterUnload PROC					; COMDAT

; 233  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 234  : 	Dump ("DumpFilterUnload type=%d\n", filterExtension->DumpType);

  0000a	48 8b 44 24 30	 mov	 rax, QWORD PTR filterExtension$[rsp]
  0000f	8b 10		 mov	 edx, DWORD PTR [rax]
  00011	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@LHLJKEKP@DumpFilterUnload?5type?$DN?$CFd?6?$AA@FNODOBFM@
  00018	e8 00 00 00 00	 call	 DbgPrint

; 235  : 
; 236  : 	if (WriteFilterBuffer)

  0001d	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR WriteFilterBuffer, 0
  00025	74 2a		 je	 SHORT $LN1@DumpFilter

; 237  : 	{
; 238  : 		memset (WriteFilterBuffer, 0, WriteFilterBufferSize);

  00027	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR WriteFilterBuffer
  0002e	33 c0		 xor	 eax, eax
  00030	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR WriteFilterBufferSize
  00037	f3 aa		 rep stosb

; 239  : 		MmFreeContiguousMemory (WriteFilterBuffer);

  00039	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR WriteFilterBuffer
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmFreeContiguousMemory

; 240  : 		WriteFilterBuffer = NULL;

  00046	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR WriteFilterBuffer, 0
$LN1@DumpFilter:

; 241  : 	}
; 242  : 
; 243  : 	return STATUS_SUCCESS;

  00051	33 c0		 xor	 eax, eax

; 244  : }

  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5f		 pop	 rdi
  00058	c3		 ret	 0
DumpFilterUnload ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DumpFilterFinish DD imagerel DumpFilterFinish
	DD	imagerel DumpFilterFinish+35
	DD	imagerel $unwind$DumpFilterFinish
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DumpFilterFinish DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DumpFilterFinish
_TEXT	SEGMENT
filterExtension$ = 48
DumpFilterFinish PROC					; COMDAT

; 225  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 226  : 	Dump ("DumpFilterFinish type=%d\n", filterExtension->DumpType);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR filterExtension$[rsp]
  0000e	8b 10		 mov	 edx, DWORD PTR [rax]
  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@EIOFNLAN@DumpFilterFinish?5type?$DN?$CFd?6?$AA@FNODOBFM@
  00017	e8 00 00 00 00	 call	 DbgPrint

; 227  : 
; 228  : 	return STATUS_SUCCESS;

  0001c	33 c0		 xor	 eax, eax

; 229  : }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
DumpFilterFinish ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DumpFilterStart DD imagerel DumpFilterStart
	DD	imagerel DumpFilterStart+129
	DD	imagerel $unwind$DumpFilterStart
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DumpFilterStart DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DumpFilterStart
_TEXT	SEGMENT
tv75 = 48
filterExtension$ = 80
DumpFilterStart PROC					; COMDAT

; 141  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 142  : 	Dump ("DumpFilterStart type=%d\n", filterExtension->DumpType);

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR filterExtension$[rsp]
  0000e	8b 10		 mov	 edx, DWORD PTR [rax]
  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@IKOJIFKO@DumpFilterStart?5type?$DN?$CFd?6?$AA@FNODOBFM@
  00017	e8 00 00 00 00	 call	 DbgPrint

; 143  : 
; 144  : 	if (BootDriveFilterExtension->MagicNumber != TC_BOOT_DRIVE_FILTER_EXTENSION_MAGIC_NUMBER)

  0001c	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR BootDriveFilterExtension
  00023	48 b8 54 58 45
	42 45 55 52 54	 mov	 rax, 6076012603229165652 ; 5452554542455854H
  0002d	49 39 43 10	 cmp	 QWORD PTR [r11+16], rax
  00031	74 23		 je	 SHORT $LN1@DumpFilter@2

; 145  : 		TC_BUG_CHECK (STATUS_CRC_ERROR);

  00033	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  0003c	45 33 c9	 xor	 r9d, r9d
  0003f	49 c7 c0 3f 00
	00 c0		 mov	 r8, -1073741761		; ffffffffc000003fH
  00046	ba 91 00 00 00	 mov	 edx, 145		; 00000091H
  0004b	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN1@DumpFilter@2:

; 146  : 
; 147  : 	return BootDriveFilterExtension->DriveMounted ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;

  00056	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  0005d	83 b8 10 03 00
	00 00		 cmp	 DWORD PTR [rax+784], 0
  00064	74 0a		 je	 SHORT $LN4@DumpFilter@2
  00066	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
  0006e	eb 08		 jmp	 SHORT $LN5@DumpFilter@2
$LN4@DumpFilter@2:
  00070	c7 44 24 30 01
	00 00 c0	 mov	 DWORD PTR tv75[rsp], -1073741823 ; ffffffffc0000001H
$LN5@DumpFilter@2:
  00078	8b 44 24 30	 mov	 eax, DWORD PTR tv75[rsp]
$LN3@DumpFilter@2:

; 148  : }

  0007c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00080	c3		 ret	 0
DumpFilterStart ENDP
DumpPartitionOffset DQ 01H DUP (?)
;	COMDAT pdata
pdata	SEGMENT
$pdata$DumpFilterWrite DD imagerel DumpFilterWrite
	DD	imagerel DumpFilterWrite+977
	DD	imagerel $unwind$DumpFilterWrite
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DumpFilterWrite DD 031501H
	DD	07011e215H
	DD	06010H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DumpFilterWrite
_TEXT	SEGMENT
intersectLength$ = 48
origMdlFlags$ = 52
intersectStart$ = 56
dataLength$ = 64
offset$ = 72
writeBuffer$ = 80
dataUnit$29523 = 88
tv151 = 96
filterExtension$ = 144
diskWriteOffset$ = 152
writeMdl$ = 160
DumpFilterWrite PROC					; COMDAT

; 152  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 153  : 	ULONG dataLength = MmGetMdlByteCount (writeMdl);

  00015	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR writeMdl$[rsp]
  0001d	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00020	89 44 24 40	 mov	 DWORD PTR dataLength$[rsp], eax

; 154  : 	uint64 offset = DumpPartitionOffset.QuadPart + diskWriteOffset->QuadPart;

  00024	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR diskWriteOffset$[rsp]
  0002c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR DumpPartitionOffset
  00036	48 03 c1	 add	 rax, rcx
  00039	48 89 44 24 48	 mov	 QWORD PTR offset$[rsp], rax

; 155  : 	uint64 intersectStart;
; 156  : 	uint32 intersectLength;
; 157  : 	PVOID writeBuffer;
; 158  : 	CSHORT origMdlFlags;
; 159  : 
; 160  : 	if (BootDriveFilterExtension->MagicNumber != TC_BOOT_DRIVE_FILTER_EXTENSION_MAGIC_NUMBER)

  0003e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR BootDriveFilterExtension
  00045	48 b8 54 58 45
	42 45 55 52 54	 mov	 rax, 6076012603229165652 ; 5452554542455854H
  0004f	48 39 41 10	 cmp	 QWORD PTR [rcx+16], rax
  00053	74 23		 je	 SHORT $LN10@DumpFilter@3

; 161  : 		TC_BUG_CHECK (STATUS_CRC_ERROR);

  00055	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  0005e	45 33 c9	 xor	 r9d, r9d
  00061	49 c7 c0 3f 00
	00 c0		 mov	 r8, -1073741761		; ffffffffc000003fH
  00068	ba a1 00 00 00	 mov	 edx, 161		; 000000a1H
  0006d	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN10@DumpFilter@3:

; 162  : 
; 163  : 	if (BootDriveFilterExtension->Queue.EncryptedAreaEndUpdatePending)	// Hibernation should always abort the setup thread

  00078	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  0007f	8b 80 d8 00 00
	00		 mov	 eax, DWORD PTR [rax+216]
  00085	85 c0		 test	 eax, eax
  00087	74 23		 je	 SHORT $LN9@DumpFilter@3

; 164  : 		TC_BUG_CHECK (STATUS_INVALID_PARAMETER);

  00089	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00092	45 33 c9	 xor	 r9d, r9d
  00095	49 c7 c0 0d 00
	00 c0		 mov	 r8, -1073741811		; ffffffffc000000dH
  0009c	ba a4 00 00 00	 mov	 edx, 164		; 000000a4H
  000a1	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  000a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN9@DumpFilter@3:

; 165  : 
; 166  : 	if (BootDriveFilterExtension->Queue.EncryptedAreaStart == -1 || BootDriveFilterExtension->Queue.EncryptedAreaEnd == -1)

  000ac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  000b3	48 83 b8 c8 00
	00 00 ff	 cmp	 QWORD PTR [rax+200], -1
  000bb	74 14		 je	 SHORT $LN7@DumpFilter@3
  000bd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  000c4	48 8b 80 d0 00
	00 00		 mov	 rax, QWORD PTR [rax+208]
  000cb	48 83 f8 ff	 cmp	 rax, -1
  000cf	75 07		 jne	 SHORT $LN8@DumpFilter@3
$LN7@DumpFilter@3:

; 167  : 		return STATUS_SUCCESS;

  000d1	33 c0		 xor	 eax, eax
  000d3	e9 f2 02 00 00	 jmp	 $LN11@DumpFilter@3
$LN8@DumpFilter@3:

; 168  : 
; 169  : 	if (dataLength > WriteFilterBufferSize)

  000d8	8b 44 24 40	 mov	 eax, DWORD PTR dataLength$[rsp]
  000dc	48 3b 05 00 00
	00 00		 cmp	 rax, QWORD PTR WriteFilterBufferSize
  000e3	76 23		 jbe	 SHORT $LN6@DumpFilter@3

; 170  : 		TC_BUG_CHECK (STATUS_BUFFER_OVERFLOW);	// Bug check is required as returning an error does not prevent data from being written to disk

  000e5	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  000ee	45 33 c9	 xor	 r9d, r9d
  000f1	49 c7 c0 05 00
	00 80		 mov	 r8, -2147483643		; ffffffff80000005H
  000f8	ba aa 00 00 00	 mov	 edx, 170		; 000000aaH
  000fd	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  00102	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN6@DumpFilter@3:

; 171  : 
; 172  : 	if ((dataLength & (ENCRYPTION_DATA_UNIT_SIZE - 1)) != 0)

  00108	8b 44 24 40	 mov	 eax, DWORD PTR dataLength$[rsp]
  0010c	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  00111	85 c0		 test	 eax, eax
  00113	74 23		 je	 SHORT $LN5@DumpFilter@3

; 173  : 		TC_BUG_CHECK (STATUS_INVALID_PARAMETER);

  00115	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  0011e	45 33 c9	 xor	 r9d, r9d
  00121	49 c7 c0 0d 00
	00 c0		 mov	 r8, -1073741811		; ffffffffc000000dH
  00128	ba ad 00 00 00	 mov	 edx, 173		; 000000adH
  0012d	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  00132	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN5@DumpFilter@3:

; 174  : 
; 175  : 	if ((offset & (ENCRYPTION_DATA_UNIT_SIZE - 1)) != 0)

  00138	48 8b 44 24 48	 mov	 rax, QWORD PTR offset$[rsp]
  0013d	48 25 ff 01 00
	00		 and	 rax, 511		; 000001ffH
  00143	48 85 c0	 test	 rax, rax
  00146	74 23		 je	 SHORT $LN4@DumpFilter@3

; 176  : 		TC_BUG_CHECK (STATUS_INVALID_PARAMETER);

  00148	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00151	45 33 c9	 xor	 r9d, r9d
  00154	49 c7 c0 0d 00
	00 c0		 mov	 r8, -1073741811		; ffffffffc000000dH
  0015b	ba b0 00 00 00	 mov	 edx, 176		; 000000b0H
  00160	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  00165	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN4@DumpFilter@3:

; 177  : 
; 178  : 	writeBuffer = MmGetSystemAddressForMdlSafe (writeMdl, HighPagePriority);

  0016b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR writeMdl$[rsp]
  00173	0f bf 40 0a	 movsx	 eax, WORD PTR [rax+10]
  00177	83 e0 05	 and	 eax, 5
  0017a	85 c0		 test	 eax, eax
  0017c	74 13		 je	 SHORT $LN13@DumpFilter@3
  0017e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR writeMdl$[rsp]
  00186	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0018a	48 89 44 24 60	 mov	 QWORD PTR tv151[rsp], rax
  0018f	eb 2e		 jmp	 SHORT $LN14@DumpFilter@3
$LN13@DumpFilter@3:
  00191	c7 44 24 28 20
	00 00 00	 mov	 DWORD PTR [rsp+40], 32	; 00000020H
  00199	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  001a1	45 33 c9	 xor	 r9d, r9d
  001a4	41 b8 01 00 00
	00		 mov	 r8d, 1
  001aa	33 d2		 xor	 edx, edx
  001ac	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR writeMdl$[rsp]
  001b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmMapLockedPagesSpecifyCache
  001ba	48 89 44 24 60	 mov	 QWORD PTR tv151[rsp], rax
$LN14@DumpFilter@3:
  001bf	48 8b 44 24 60	 mov	 rax, QWORD PTR tv151[rsp]
  001c4	48 89 44 24 50	 mov	 QWORD PTR writeBuffer$[rsp], rax

; 179  : 	if (!writeBuffer)

  001c9	48 83 7c 24 50
	00		 cmp	 QWORD PTR writeBuffer$[rsp], 0
  001cf	75 23		 jne	 SHORT $LN3@DumpFilter@3

; 180  : 		TC_BUG_CHECK (STATUS_INSUFFICIENT_RESOURCES);

  001d1	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  001da	45 33 c9	 xor	 r9d, r9d
  001dd	49 c7 c0 9a 00
	00 c0		 mov	 r8, -1073741670		; ffffffffc000009aH
  001e4	ba b4 00 00 00	 mov	 edx, 180		; 000000b4H
  001e9	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  001ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN3@DumpFilter@3:

; 181  : 
; 182  : 	memcpy (WriteFilterBuffer, writeBuffer, dataLength);

  001f4	8b 4c 24 40	 mov	 ecx, DWORD PTR dataLength$[rsp]
  001f8	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR WriteFilterBuffer
  001ff	48 8b 74 24 50	 mov	 rsi, QWORD PTR writeBuffer$[rsp]
  00204	f3 a4		 rep movsb

; 183  : 
; 184  : 	GetIntersection (offset,
; 185  : 		dataLength,
; 186  : 		BootDriveFilterExtension->Queue.EncryptedAreaStart,
; 187  : 		BootDriveFilterExtension->Queue.EncryptedAreaEnd,
; 188  : 		&intersectStart,
; 189  : 		&intersectLength);

  00206	48 8d 44 24 30	 lea	 rax, QWORD PTR intersectLength$[rsp]
  0020b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00210	48 8d 44 24 38	 lea	 rax, QWORD PTR intersectStart$[rsp]
  00215	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0021a	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR BootDriveFilterExtension
  00221	4d 8b 89 d0 00
	00 00		 mov	 r9, QWORD PTR [r9+208]
  00228	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR BootDriveFilterExtension
  0022f	4d 8b 80 c8 00
	00 00		 mov	 r8, QWORD PTR [r8+200]
  00236	8b 54 24 40	 mov	 edx, DWORD PTR dataLength$[rsp]
  0023a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR offset$[rsp]
  0023f	e8 00 00 00 00	 call	 GetIntersection

; 190  : 
; 191  : 	if (intersectLength > 0)

  00244	83 7c 24 30 00	 cmp	 DWORD PTR intersectLength$[rsp], 0
  00249	0f 86 a2 00 00
	00		 jbe	 $LN2@DumpFilter@3

; 192  : 	{
; 193  : 		UINT64_STRUCT dataUnit;
; 194  : 		dataUnit.Value = intersectStart / ENCRYPTION_DATA_UNIT_SIZE;

  0024f	33 d2		 xor	 edx, edx
  00251	48 8b 44 24 38	 mov	 rax, QWORD PTR intersectStart$[rsp]
  00256	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0025b	48 f7 f1	 div	 rcx
  0025e	48 89 44 24 58	 mov	 QWORD PTR dataUnit$29523[rsp], rax

; 195  : 
; 196  : 		if (BootDriveFilterExtension->Queue.RemapEncryptedArea)

  00263	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  0026a	83 b8 dc 00 00
	00 00		 cmp	 DWORD PTR [rax+220], 0
  00271	74 3f		 je	 SHORT $LN1@DumpFilter@3

; 197  : 		{
; 198  : 			diskWriteOffset->QuadPart += BootDriveFilterExtension->Queue.RemappedAreaOffset;

  00273	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR diskWriteOffset$[rsp]
  0027b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0027e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00285	48 03 88 e0 00
	00 00		 add	 rcx, QWORD PTR [rax+224]
  0028c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR diskWriteOffset$[rsp]
  00294	48 89 08	 mov	 QWORD PTR [rax], rcx

; 199  : 			dataUnit.Value += BootDriveFilterExtension->Queue.RemappedAreaDataUnitOffset;

  00297	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR BootDriveFilterExtension
  0029e	48 8b 89 e8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+232]
  002a5	48 8b 44 24 58	 mov	 rax, QWORD PTR dataUnit$29523[rsp]
  002aa	48 03 c1	 add	 rax, rcx
  002ad	48 89 44 24 58	 mov	 QWORD PTR dataUnit$29523[rsp], rax
$LN1@DumpFilter@3:

; 200  : 		}
; 201  : 
; 202  : 		EncryptDataUnitsCurrentThread (WriteFilterBuffer + (intersectStart - offset),
; 203  : 			&dataUnit,
; 204  : 			intersectLength / ENCRYPTION_DATA_UNIT_SIZE,
; 205  : 			BootDriveFilterExtension->Queue.CryptoInfo);

  002b2	33 d2		 xor	 edx, edx
  002b4	8b 44 24 30	 mov	 eax, DWORD PTR intersectLength$[rsp]
  002b8	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  002bd	f7 f1		 div	 ecx
  002bf	44 8b c0	 mov	 r8d, eax
  002c2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR offset$[rsp]
  002c7	48 8b 44 24 38	 mov	 rax, QWORD PTR intersectStart$[rsp]
  002cc	48 2b c1	 sub	 rax, rcx
  002cf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR WriteFilterBuffer
  002d6	48 03 c8	 add	 rcx, rax
  002d9	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR BootDriveFilterExtension
  002e0	4d 8b 89 98 00
	00 00		 mov	 r9, QWORD PTR [r9+152]
  002e7	48 8d 54 24 58	 lea	 rdx, QWORD PTR dataUnit$29523[rsp]
  002ec	e8 00 00 00 00	 call	 EncryptDataUnitsCurrentThread
$LN2@DumpFilter@3:

; 206  : 	}
; 207  : 
; 208  : 	origMdlFlags = writeMdl->MdlFlags;

  002f1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR writeMdl$[rsp]
  002f9	0f b7 40 0a	 movzx	 eax, WORD PTR [rax+10]
  002fd	66 89 44 24 34	 mov	 WORD PTR origMdlFlags$[rsp], ax

; 209  : 
; 210  : 	MmInitializeMdl (writeMdl, WriteFilterBuffer, dataLength);

  00302	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR writeMdl$[rsp]
  0030a	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00311	8b 54 24 40	 mov	 edx, DWORD PTR dataLength$[rsp]
  00315	48 c1 ea 0c	 shr	 rdx, 12
  00319	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR WriteFilterBuffer
  00320	48 81 e1 ff 0f
	00 00		 and	 rcx, 4095		; 00000fffH
  00327	8b 44 24 40	 mov	 eax, DWORD PTR dataLength$[rsp]
  0032b	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00331	8d 84 01 ff 0f
	00 00		 lea	 eax, DWORD PTR [rcx+rax+4095]
  00338	c1 e8 0c	 shr	 eax, 12
  0033b	8b c8		 mov	 ecx, eax
  0033d	48 8b c2	 mov	 rax, rdx
  00340	48 03 c1	 add	 rax, rcx
  00343	8b c8		 mov	 ecx, eax
  00345	48 8d 0c cd 30
	00 00 00	 lea	 rcx, QWORD PTR [rcx*8+48]
  0034d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR writeMdl$[rsp]
  00355	66 89 48 08	 mov	 WORD PTR [rax+8], cx
  00359	33 c9		 xor	 ecx, ecx
  0035b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR writeMdl$[rsp]
  00363	66 89 48 0a	 mov	 WORD PTR [rax+10], cx
  00367	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR WriteFilterBuffer
  0036e	48 81 e1 00 f0
	ff ff		 and	 rcx, -4096		; fffffffffffff000H
  00375	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR writeMdl$[rsp]
  0037d	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx
  00381	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR WriteFilterBuffer
  00388	48 81 e1 ff 0f
	00 00		 and	 rcx, 4095		; 00000fffH
  0038f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR writeMdl$[rsp]
  00397	89 48 2c	 mov	 DWORD PTR [rax+44], ecx
  0039a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR writeMdl$[rsp]
  003a2	8b 44 24 40	 mov	 eax, DWORD PTR dataLength$[rsp]
  003a6	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 211  : 	MmBuildMdlForNonPagedPool (writeMdl);

  003a9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR writeMdl$[rsp]
  003b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmBuildMdlForNonPagedPool

; 212  : 
; 213  : 	// Instead of using MmGetSystemAddressForMdlSafe(), some buggy custom storage drivers may directly test MDL_MAPPED_TO_SYSTEM_VA flag,
; 214  : 	// disregarding the fact that other MDL flags may be set by the system or a dump filter (e.g. MDL_SOURCE_IS_NONPAGED_POOL flag only).
; 215  : 	// Therefore, to work around this issue, the original flags will be restored even if they do not match the new MDL.
; 216  : 	// MS BitLocker also uses this hack/workaround (it should be safe to use until the MDL structure is changed).
; 217  : 
; 218  : 	writeMdl->MdlFlags = origMdlFlags;

  003b7	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR writeMdl$[rsp]
  003bf	0f b7 44 24 34	 movzx	 eax, WORD PTR origMdlFlags$[rsp]
  003c4	66 89 42 0a	 mov	 WORD PTR [rdx+10], ax

; 219  : 
; 220  : 	return STATUS_SUCCESS;

  003c8	33 c0		 xor	 eax, eax
$LN11@DumpFilter@3:
$LN12@DumpFilter@3:

; 221  : }

  003ca	48 83 c4 78	 add	 rsp, 120		; 00000078H
  003ce	5f		 pop	 rdi
  003cf	5e		 pop	 rsi
  003d0	c3		 ret	 0
DumpFilterWrite ENDP
PUBLIC	DumpFilterEntry
;	COMDAT pdata
pdata	SEGMENT
$pdata$DumpFilterEntry DD imagerel $LN16
	DD	imagerel $LN16+797
	DD	imagerel $unwind$DumpFilterEntry
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DumpFilterEntry DD 021101H
	DD	0110111H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DumpFilterEntry
_TEXT	SEGMENT
dumpConfig$ = 48
storageDeviceNumber$ = 64
partitionInfo$ = 80
highestAcceptableWriteBufferAddr$ = 112
version$ = 120
status$ = 124
filterExtension$ = 144
filterInitData$ = 152
DumpFilterEntry PROC					; COMDAT

; 21   : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 22   : 	GetSystemDriveDumpConfigRequest dumpConfig;
; 23   : 	PHYSICAL_ADDRESS highestAcceptableWriteBufferAddr;
; 24   : 	STORAGE_DEVICE_NUMBER storageDeviceNumber;
; 25   : 	PARTITION_INFORMATION partitionInfo;
; 26   : 	LONG version;
; 27   : 	NTSTATUS status;
; 28   : 
; 29   : 	Dump ("DumpFilterEntry type=%d\n", filterExtension->DumpType);

  00011	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR filterExtension$[rsp]
  00019	8b 10		 mov	 edx, DWORD PTR [rax]
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@DKEIHACK@DumpFilterEntry?5type?$DN?$CFd?6?$AA@FNODOBFM@
  00022	e8 00 00 00 00	 call	 DbgPrint

; 30   : 
; 31   : 	filterInitData->MajorVersion = DUMP_FILTER_MAJOR_VERSION;

  00027	4c 8b 9c 24 98
	00 00 00	 mov	 r11, QWORD PTR filterInitData$[rsp]
  0002f	41 c7 03 01 00
	00 00		 mov	 DWORD PTR [r11], 1

; 32   : 	filterInitData->MinorVersion = DUMP_FILTER_MINOR_VERSION;

  00036	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR filterInitData$[rsp]
  0003e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 33   : 	filterInitData->Flags |= DUMP_FILTER_CRITICAL;

  00045	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR filterInitData$[rsp]
  0004d	8b 48 34	 mov	 ecx, DWORD PTR [rax+52]
  00050	83 c9 01	 or	 ecx, 1
  00053	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR filterInitData$[rsp]
  0005b	89 48 34	 mov	 DWORD PTR [rax+52], ecx

; 34   : 
; 35   : 	// Check driver version of the main device
; 36   : 	status = TCDeviceIoControl (NT_ROOT_PREFIX, TC_IOCTL_GET_DRIVER_VERSION, NULL, 0, &version, sizeof (version));

  0005e	c7 44 24 28 04
	00 00 00	 mov	 DWORD PTR [rsp+40], 4
  00066	48 8d 44 24 78	 lea	 rax, QWORD PTR version$[rsp]
  0006b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00070	45 33 c9	 xor	 r9d, r9d
  00073	45 33 c0	 xor	 r8d, r8d
  00076	ba 04 20 22 00	 mov	 edx, 2236420		; 00222004H
  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
  00082	e8 00 00 00 00	 call	 TCDeviceIoControl
  00087	89 44 24 7c	 mov	 DWORD PTR status$[rsp], eax

; 37   : 	if (!NT_SUCCESS (status))

  0008b	83 7c 24 7c 00	 cmp	 DWORD PTR status$[rsp], 0
  00090	7d 05		 jge	 SHORT $LN13@DumpFilter@4

; 38   : 		goto err;

  00092	e9 6a 02 00 00	 jmp	 $err$29440
$LN13@DumpFilter@4:

; 39   : 
; 40   : 	if (version != VERSION_NUM)

  00097	81 7c 24 78 40
	07 00 00	 cmp	 DWORD PTR version$[rsp], 1856 ; 00000740H
  0009f	74 0d		 je	 SHORT $LN12@DumpFilter@4

; 41   : 	{
; 42   : 		status = STATUS_INVALID_PARAMETER;

  000a1	c7 44 24 7c 0d
	00 00 c0	 mov	 DWORD PTR status$[rsp], -1073741811 ; ffffffffc000000dH

; 43   : 		goto err;

  000a9	e9 53 02 00 00	 jmp	 $err$29440
$LN12@DumpFilter@4:

; 44   : 	}
; 45   : 
; 46   : 	// Get dump configuration from the main device
; 47   : 	status = TCDeviceIoControl (NT_ROOT_PREFIX, TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG, NULL, 0, &dumpConfig, sizeof (dumpConfig));

  000ae	c7 44 24 28 0c
	00 00 00	 mov	 DWORD PTR [rsp+40], 12
  000b6	48 8d 44 24 30	 lea	 rax, QWORD PTR dumpConfig$[rsp]
  000bb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c0	45 33 c9	 xor	 r9d, r9d
  000c3	45 33 c0	 xor	 r8d, r8d
  000c6	ba 98 20 22 00	 mov	 edx, 2236568		; 00222098H
  000cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
  000d2	e8 00 00 00 00	 call	 TCDeviceIoControl
  000d7	89 44 24 7c	 mov	 DWORD PTR status$[rsp], eax

; 48   : 	if (!NT_SUCCESS (status))

  000db	83 7c 24 7c 00	 cmp	 DWORD PTR status$[rsp], 0
  000e0	7d 05		 jge	 SHORT $LN11@DumpFilter@4

; 49   : 		goto err;

  000e2	e9 1a 02 00 00	 jmp	 $err$29440
$LN11@DumpFilter@4:

; 50   : 
; 51   : 	BootDriveFilterExtension = dumpConfig.BootDriveFilterExtension;

  000e7	48 8b 44 24 30	 mov	 rax, QWORD PTR dumpConfig$[rsp]
  000ec	48 89 05 00 00
	00 00		 mov	 QWORD PTR BootDriveFilterExtension, rax

; 52   : 
; 53   : 	if (BootDriveFilterExtension->MagicNumber != TC_BOOT_DRIVE_FILTER_EXTENSION_MAGIC_NUMBER)

  000f3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR BootDriveFilterExtension
  000fa	48 b8 54 58 45
	42 45 55 52 54	 mov	 rax, 6076012603229165652 ; 5452554542455854H
  00104	48 39 41 10	 cmp	 QWORD PTR [rcx+16], rax
  00108	74 0d		 je	 SHORT $LN10@DumpFilter@4

; 54   : 	{
; 55   : 		status = STATUS_CRC_ERROR;

  0010a	c7 44 24 7c 3f
	00 00 c0	 mov	 DWORD PTR status$[rsp], -1073741761 ; ffffffffc000003fH

; 56   : 		goto err;

  00112	e9 ea 01 00 00	 jmp	 $err$29440
$LN10@DumpFilter@4:

; 57   : 	}
; 58   : 
; 59   : 	// KeSaveFloatingPointState() may generate a bug check during crash dump
; 60   : #if !defined (_WIN64)
; 61   : 	if (filterExtension->DumpType == DumpTypeCrashdump)
; 62   : 		dumpConfig.HwEncryptionEnabled = FALSE;
; 63   : #endif
; 64   : 
; 65   : 	EnableHwEncryption (dumpConfig.HwEncryptionEnabled);

  00117	8b 4c 24 38	 mov	 ecx, DWORD PTR dumpConfig$[rsp+8]
  0011b	e8 00 00 00 00	 call	 EnableHwEncryption

; 66   : 
; 67   : 	if (!AutoTestAlgorithms())

  00120	e8 00 00 00 00	 call	 AutoTestAlgorithms
  00125	85 c0		 test	 eax, eax
  00127	75 0d		 jne	 SHORT $LN9@DumpFilter@4

; 68   : 	{
; 69   : 		status = STATUS_INVALID_PARAMETER;

  00129	c7 44 24 7c 0d
	00 00 c0	 mov	 DWORD PTR status$[rsp], -1073741811 ; ffffffffc000000dH

; 70   : 		goto err;

  00131	e9 cb 01 00 00	 jmp	 $err$29440
$LN9@DumpFilter@4:

; 71   : 	}
; 72   : 
; 73   : 	// Check dump volume is located on the system drive
; 74   : 	status = SendDeviceIoControlRequest (filterExtension->DeviceObject, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0, &storageDeviceNumber, sizeof (storageDeviceNumber));

  00136	c7 44 24 28 0c
	00 00 00	 mov	 DWORD PTR [rsp+40], 12
  0013e	48 8d 44 24 40	 lea	 rax, QWORD PTR storageDeviceNumber$[rsp]
  00143	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00148	45 33 c9	 xor	 r9d, r9d
  0014b	45 33 c0	 xor	 r8d, r8d
  0014e	ba 80 10 2d 00	 mov	 edx, 2953344		; 002d1080H
  00153	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR filterExtension$[rsp]
  0015b	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0015f	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  00164	89 44 24 7c	 mov	 DWORD PTR status$[rsp], eax

; 75   : 	if (!NT_SUCCESS (status))

  00168	83 7c 24 7c 00	 cmp	 DWORD PTR status$[rsp], 0
  0016d	7d 05		 jge	 SHORT $LN8@DumpFilter@4

; 76   : 		goto err;

  0016f	e9 8d 01 00 00	 jmp	 $err$29440
$LN8@DumpFilter@4:

; 77   : 
; 78   : 	if (!BootDriveFilterExtension->SystemStorageDeviceNumberValid)

  00174	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  0017b	83 78 34 00	 cmp	 DWORD PTR [rax+52], 0
  0017f	75 0d		 jne	 SHORT $LN7@DumpFilter@4

; 79   : 	{
; 80   : 		status = STATUS_INVALID_PARAMETER;

  00181	c7 44 24 7c 0d
	00 00 c0	 mov	 DWORD PTR status$[rsp], -1073741811 ; ffffffffc000000dH

; 81   : 		goto err;

  00189	e9 73 01 00 00	 jmp	 $err$29440
$LN7@DumpFilter@4:

; 82   : 	}
; 83   : 
; 84   : 	if (storageDeviceNumber.DeviceNumber != BootDriveFilterExtension->SystemStorageDeviceNumber)

  0018e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00195	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00198	39 44 24 44	 cmp	 DWORD PTR storageDeviceNumber$[rsp+4], eax
  0019c	74 0d		 je	 SHORT $LN6@DumpFilter@4

; 85   : 	{
; 86   : 		status = STATUS_ACCESS_DENIED;

  0019e	c7 44 24 7c 22
	00 00 c0	 mov	 DWORD PTR status$[rsp], -1073741790 ; ffffffffc0000022H

; 87   : 		goto err;

  001a6	e9 56 01 00 00	 jmp	 $err$29440
$LN6@DumpFilter@4:

; 88   : 	}
; 89   : 
; 90   : 	// Check dump volume is located within the scope of system encryption
; 91   : 	status = SendDeviceIoControlRequest (filterExtension->DeviceObject, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0, &partitionInfo, sizeof (partitionInfo));

  001ab	c7 44 24 28 20
	00 00 00	 mov	 DWORD PTR [rsp+40], 32	; 00000020H
  001b3	48 8d 44 24 50	 lea	 rax, QWORD PTR partitionInfo$[rsp]
  001b8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001bd	45 33 c9	 xor	 r9d, r9d
  001c0	45 33 c0	 xor	 r8d, r8d
  001c3	ba 04 40 07 00	 mov	 edx, 475140		; 00074004H
  001c8	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR filterExtension$[rsp]
  001d0	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  001d4	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  001d9	89 44 24 7c	 mov	 DWORD PTR status$[rsp], eax

; 92   : 	if (!NT_SUCCESS (status))

  001dd	83 7c 24 7c 00	 cmp	 DWORD PTR status$[rsp], 0
  001e2	7d 05		 jge	 SHORT $LN5@DumpFilter@4

; 93   : 		goto err;

  001e4	e9 18 01 00 00	 jmp	 $err$29440
$LN5@DumpFilter@4:

; 94   : 
; 95   : 	DumpPartitionOffset = partitionInfo.StartingOffset;

  001e9	48 8b 44 24 50	 mov	 rax, QWORD PTR partitionInfo$[rsp]
  001ee	48 89 05 00 00
	00 00		 mov	 QWORD PTR DumpPartitionOffset, rax

; 96   : 
; 97   : 	if (DumpPartitionOffset.QuadPart < BootDriveFilterExtension->ConfiguredEncryptedAreaStart
; 98   : 		|| DumpPartitionOffset.QuadPart > BootDriveFilterExtension->ConfiguredEncryptedAreaEnd)

  001f5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  001fc	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00200	48 39 05 00 00
	00 00		 cmp	 QWORD PTR DumpPartitionOffset, rax
  00207	7c 14		 jl	 SHORT $LN3@DumpFilter@4
  00209	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00210	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00214	48 39 05 00 00
	00 00		 cmp	 QWORD PTR DumpPartitionOffset, rax
  0021b	7e 0d		 jle	 SHORT $LN4@DumpFilter@4
$LN3@DumpFilter@4:

; 99   : 	{
; 100  : 		status = STATUS_ACCESS_DENIED;

  0021d	c7 44 24 7c 22
	00 00 c0	 mov	 DWORD PTR status$[rsp], -1073741790 ; ffffffffc0000022H

; 101  : 		goto err;

  00225	e9 d7 00 00 00	 jmp	 $err$29440
$LN4@DumpFilter@4:

; 102  : 	}
; 103  : 
; 104  : 	// Allocate buffer for encryption
; 105  : 	if (filterInitData->MaxPagesPerWrite == 0)

  0022a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR filterInitData$[rsp]
  00232	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00236	75 0d		 jne	 SHORT $LN2@DumpFilter@4

; 106  : 	{
; 107  : 		status = STATUS_INVALID_PARAMETER;

  00238	c7 44 24 7c 0d
	00 00 c0	 mov	 DWORD PTR status$[rsp], -1073741811 ; ffffffffc000000dH

; 108  : 		goto err;

  00240	e9 bc 00 00 00	 jmp	 $err$29440
$LN2@DumpFilter@4:

; 109  : 	}
; 110  : 
; 111  : 	WriteFilterBufferSize = filterInitData->MaxPagesPerWrite * PAGE_SIZE;

  00245	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR filterInitData$[rsp]
  0024d	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00250	69 c0 00 10 00
	00		 imul	 eax, 4096		; 00001000H
  00256	8b c0		 mov	 eax, eax
  00258	48 89 05 00 00
	00 00		 mov	 QWORD PTR WriteFilterBufferSize, rax

; 112  : 
; 113  : #ifdef _WIN64
; 114  : 	highestAcceptableWriteBufferAddr.QuadPart = 0x7FFffffFFFFLL;

  0025f	48 b8 ff ff ff
	ff ff 07 00 00	 mov	 rax, 8796093022207	; 000007ffffffffffH
  00269	48 89 44 24 70	 mov	 QWORD PTR highestAcceptableWriteBufferAddr$[rsp], rax

; 115  : #else
; 116  : 	highestAcceptableWriteBufferAddr.QuadPart = 0xffffFFFFLL;
; 117  : #endif
; 118  : 
; 119  : 	WriteFilterBuffer = MmAllocateContiguousMemory (WriteFilterBufferSize, highestAcceptableWriteBufferAddr);

  0026e	48 8b 54 24 70	 mov	 rdx, QWORD PTR highestAcceptableWriteBufferAddr$[rsp]
  00273	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR WriteFilterBufferSize
  0027a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmAllocateContiguousMemory
  00280	48 89 05 00 00
	00 00		 mov	 QWORD PTR WriteFilterBuffer, rax

; 120  : 	if (!WriteFilterBuffer)

  00287	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR WriteFilterBuffer, 0
  0028f	75 0a		 jne	 SHORT $LN1@DumpFilter@4

; 121  : 	{
; 122  : 		status = STATUS_INSUFFICIENT_RESOURCES;

  00291	c7 44 24 7c 9a
	00 00 c0	 mov	 DWORD PTR status$[rsp], -1073741670 ; ffffffffc000009aH

; 123  : 		goto err;

  00299	eb 66		 jmp	 SHORT $err$29440
$LN1@DumpFilter@4:

; 124  : 	}
; 125  : 
; 126  : 	filterInitData->DumpStart = DumpFilterStart;

  0029b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR filterInitData$[rsp]
  002a3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:DumpFilterStart
  002aa	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 127  : 	filterInitData->DumpWrite = DumpFilterWrite;

  002ae	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR filterInitData$[rsp]
  002b6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:DumpFilterWrite
  002bd	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 128  : 	filterInitData->DumpFinish = DumpFilterFinish;

  002c1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR filterInitData$[rsp]
  002c9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:DumpFilterFinish
  002d0	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 129  : 	filterInitData->DumpUnload = DumpFilterUnload;

  002d4	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR filterInitData$[rsp]
  002dc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:DumpFilterUnload
  002e3	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 130  : 
; 131  : 	Dump ("Dump filter loaded type=%d\n", filterExtension->DumpType);

  002e7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR filterExtension$[rsp]
  002ef	8b 10		 mov	 edx, DWORD PTR [rax]
  002f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@NIHDEFIH@Dump?5filter?5loaded?5type?$DN?$CFd?6?$AA@FNODOBFM@
  002f8	e8 00 00 00 00	 call	 DbgPrint

; 132  : 	return STATUS_SUCCESS;

  002fd	33 c0		 xor	 eax, eax
  002ff	eb 14		 jmp	 SHORT $LN14@DumpFilter@4
$err$29440:

; 133  : 
; 134  : err:
; 135  : 	Dump ("DumpFilterEntry error %x\n", status);

  00301	8b 54 24 7c	 mov	 edx, DWORD PTR status$[rsp]
  00305	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@MPDBPBLL@DumpFilterEntry?5error?5?$CFx?6?$AA@FNODOBFM@
  0030c	e8 00 00 00 00	 call	 DbgPrint

; 136  : 	return status;

  00311	8b 44 24 7c	 mov	 eax, DWORD PTR status$[rsp]
$LN14@DumpFilter@4:

; 137  : }

  00315	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0031c	c3		 ret	 0
DumpFilterEntry ENDP
END
