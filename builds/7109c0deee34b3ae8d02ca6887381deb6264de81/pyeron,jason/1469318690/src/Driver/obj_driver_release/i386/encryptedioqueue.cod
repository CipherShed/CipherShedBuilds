; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\users\public\desktop\projects\ciphershed\src\driver\encryptedioqueue.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_InitializeListHead@4
; Function compile flags: /Ogsp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
;	COMDAT _InitializeListHead@4
_TEXT	SEGMENT
_ListHead$ = 8						; size = 4
_InitializeListHead@4 PROC				; COMDAT

; 7550 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 7551 :     ListHead->Flink = ListHead->Blink = ListHead;

  00005	8b 45 08	 mov	 eax, DWORD PTR _ListHead$[ebp]
  00008	89 40 04	 mov	 DWORD PTR [eax+4], eax
  0000b	89 00		 mov	 DWORD PTR [eax], eax

; 7552 : }

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
_InitializeListHead@4 ENDP
_TEXT	ENDS
PUBLIC	_KeInitializeSpinLock@4
; Function compile flags: /Ogsp
;	COMDAT _KeInitializeSpinLock@4
_TEXT	SEGMENT
_SpinLock$ = 8						; size = 4
_KeInitializeSpinLock@4 PROC				; COMDAT

; 15095: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 15096: 
; 15097:     *SpinLock = 0;

  00005	8b 45 08	 mov	 eax, DWORD PTR _SpinLock$[ebp]
  00008	83 20 00	 and	 DWORD PTR [eax], 0

; 15098:     return;
; 15099: }

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
_KeInitializeSpinLock@4 ENDP
_TEXT	ENDS
PUBLIC	_IoGetCurrentIrpStackLocation@4
; Function compile flags: /Ogsp
;	COMDAT _IoGetCurrentIrpStackLocation@4
_TEXT	SEGMENT
_Irp$ = 8						; size = 4
_IoGetCurrentIrpStackLocation@4 PROC			; COMDAT

; 23316: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 23317:     ASSERT(Irp->CurrentLocation <= Irp->StackCount + 1);
; 23318:     return Irp->Tail.Overlay.CurrentStackLocation;

  00005	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00008	8b 40 60	 mov	 eax, DWORD PTR [eax+96]

; 23319: }

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
_IoGetCurrentIrpStackLocation@4 ENDP
_TEXT	ENDS
PUBLIC	_IoMarkIrpPending@4
; Function compile flags: /Ogsp
;	COMDAT _IoMarkIrpPending@4
_TEXT	SEGMENT
_Irp$ = 8						; size = 4
_IoMarkIrpPending@4 PROC				; COMDAT

; 23667: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 23668:     IoGetCurrentIrpStackLocation( (Irp) )->Control |= SL_PENDING_RETURNED;

  00005	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00008	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  0000b	80 48 03 01	 or	 BYTE PTR [eax+3], 1

; 23669: }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
_IoMarkIrpPending@4 ENDP
_TEXT	ENDS
EXTRN	__imp__KeBugCheckEx@20:PROC
EXTRN	__imp__KeWaitForSingleObject@20:PROC
; Function compile flags: /Ogsp
; File c:\users\public\desktop\projects\ciphershed\src\driver\encryptedioqueue.c
;	COMDAT _AcquireBufferPoolMutex@4
_TEXT	SEGMENT
_AcquireBufferPoolMutex@4 PROC				; COMDAT
; _queue$ = eax

; 19   : {

  00000	8b ff		 npad	 2
  00002	56		 push	 esi

; 20   : 	NTSTATUS status;
; 21   : 
; 22   : 	status = KeWaitForMutexObject (&queue->BufferPoolMutex, Executive, KernelMode, FALSE, NULL);

  00003	33 f6		 xor	 esi, esi
  00005	56		 push	 esi
  00006	56		 push	 esi
  00007	56		 push	 esi
  00008	56		 push	 esi
  00009	83 c0 04	 add	 eax, 4
  0000c	50		 push	 eax
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 23   : 	if (!NT_SUCCESS (status))

  00013	3b c6		 cmp	 eax, esi
  00015	7d 11		 jge	 SHORT $LN1@AcquireBuf

; 24   : 		TC_BUG_CHECK (status);

  00017	68 43 54 00 00	 push	 21571			; 00005443H
  0001c	56		 push	 esi
  0001d	50		 push	 eax
  0001e	6a 18		 push	 24			; 00000018H
  00020	6a 29		 push	 41			; 00000029H
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN5@AcquireBuf:
$LN1@AcquireBuf:
  00028	5e		 pop	 esi

; 25   : }

  00029	c3		 ret	 0
$LN4@AcquireBuf:
_AcquireBufferPoolMutex@4 ENDP
_TEXT	ENDS
EXTRN	__imp__KeReleaseMutex@8:PROC
; Function compile flags: /Ogsp
;	COMDAT _ReleaseBufferPoolMutex@4
_TEXT	SEGMENT
_ReleaseBufferPoolMutex@4 PROC				; COMDAT
; _queue$ = eax

; 30   : 	KeReleaseMutex (&queue->BufferPoolMutex, FALSE);

  00000	6a 00		 push	 0
  00002	83 c0 04	 add	 eax, 4
  00005	50		 push	 eax
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeReleaseMutex@8

; 31   : }

  0000c	c3		 ret	 0
_ReleaseBufferPoolMutex@4 ENDP
_TEXT	ENDS
EXTRN	__imp__ExFreePoolWithTag@8:PROC
EXTRN	__imp__ExAllocatePoolWithTag@12:PROC
; Function compile flags: /Ogsp
;	COMDAT _GetPoolBuffer@8
_TEXT	SEGMENT
_requestedSizePresentInPool$ = -4			; size = 4
_queue$ = 8						; size = 4
_requestedSize$ = 12					; size = 4
_GetPoolBuffer@8 PROC					; COMDAT

; 35   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 36   : 	EncryptedIoQueueBuffer *buffer;
; 37   : 	void *bufferAddress = NULL;
; 38   : 	BOOL requestedSizePresentInPool = FALSE;

  00008	8b 75 08	 mov	 esi, DWORD PTR _queue$[ebp]
  0000b	33 db		 xor	 ebx, ebx
  0000d	57		 push	 edi
  0000e	89 5d fc	 mov	 DWORD PTR _requestedSizePresentInPool$[ebp], ebx
$LL17@GetPoolBuf:

; 39   : 
; 40   : 	while (TRUE)
; 41   : 	{
; 42   : 		AcquireBufferPoolMutex (queue);

  00011	8b c6		 mov	 eax, esi
  00013	e8 00 00 00 00	 call	 _AcquireBufferPoolMutex@4

; 43   : 
; 44   : 		for (buffer = queue->FirstPoolBuffer; ; buffer = buffer->NextBuffer)

  00018	8b 7e 24	 mov	 edi, DWORD PTR [esi+36]
$LL15@GetPoolBuf:

; 45   : 		{
; 46   : 			if (buffer && buffer->Size == requestedSize)

  0001b	33 c9		 xor	 ecx, ecx
  0001d	3b f9		 cmp	 edi, ecx
  0001f	74 25		 je	 SHORT $LN25@GetPoolBuf
  00021	8b 45 0c	 mov	 eax, DWORD PTR _requestedSize$[ebp]
  00024	39 47 08	 cmp	 DWORD PTR [edi+8], eax
  00027	75 0b		 jne	 SHORT $LN11@GetPoolBuf

; 47   : 			{
; 48   : 				requestedSizePresentInPool = TRUE;

  00029	33 c0		 xor	 eax, eax
  0002b	40		 inc	 eax
  0002c	89 45 fc	 mov	 DWORD PTR _requestedSizePresentInPool$[ebp], eax

; 49   : 
; 50   : 				if (!buffer->InUse)

  0002f	39 4f 0c	 cmp	 DWORD PTR [edi+12], ecx
  00032	74 0a		 je	 SHORT $LN24@GetPoolBuf
$LN11@GetPoolBuf:

; 56   : 				}
; 57   : 			}
; 58   : 
; 59   : 			if (!buffer || !buffer->NextBuffer)

  00034	8b 07		 mov	 eax, DWORD PTR [edi]
  00036	3b c1		 cmp	 eax, ecx
  00038	74 0c		 je	 SHORT $LN25@GetPoolBuf

; 43   : 
; 44   : 		for (buffer = queue->FirstPoolBuffer; ; buffer = buffer->NextBuffer)

  0003a	8b f8		 mov	 edi, eax
  0003c	eb dd		 jmp	 SHORT $LL15@GetPoolBuf
$LN24@GetPoolBuf:

; 51   : 				{
; 52   : 					// Reuse a free buffer
; 53   : 					buffer->InUse = TRUE;
; 54   : 					bufferAddress = buffer->Address;

  0003e	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  00041	89 47 0c	 mov	 DWORD PTR [edi+12], eax

; 55   : 					break;

  00044	eb 6f		 jmp	 SHORT $LN3@GetPoolBuf
$LN25@GetPoolBuf:

; 60   : 			{
; 61   : 				EncryptedIoQueueBuffer *newBuffer;
; 62   : 
; 63   : 				if (requestedSizePresentInPool && !queue->StartPending)

  00046	39 4d fc	 cmp	 DWORD PTR _requestedSizePresentInPool$[ebp], ecx
  00049	74 0a		 je	 SHORT $LN8@GetPoolBuf
  0004b	8b 86 78 01 00
	00		 mov	 eax, DWORD PTR [esi+376]
  00051	85 c0		 test	 eax, eax
  00053	74 60		 je	 SHORT $LN3@GetPoolBuf
$LN8@GetPoolBuf:

; 64   : 					break;
; 65   : 
; 66   : 				// Allocate a new buffer
; 67   : 				newBuffer = TCalloc (sizeof (EncryptedIoQueueBuffer));

  00055	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__ExAllocatePoolWithTag@12
  0005b	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00060	6a 10		 push	 16			; 00000010H
  00062	51		 push	 ecx
  00063	ff d3		 call	 ebx
  00065	8b f0		 mov	 esi, eax

; 68   : 				if (!newBuffer)

  00067	85 f6		 test	 esi, esi
  00069	75 04		 jne	 SHORT $LN7@GetPoolBuf

; 69   : 				{
; 70   : 					bufferAddress = NULL;

  0006b	33 db		 xor	 ebx, ebx

; 71   : 					break;

  0006d	eb 43		 jmp	 SHORT $LN27@GetPoolBuf
$LN7@GetPoolBuf:

; 72   : 				}
; 73   : 
; 74   : 				bufferAddress = TCalloc (requestedSize);

  0006f	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00074	ff 75 0c	 push	 DWORD PTR _requestedSize$[ebp]
  00077	6a 00		 push	 0
  00079	ff d3		 call	 ebx
  0007b	8b d8		 mov	 ebx, eax

; 75   : 				if (bufferAddress)

  0007d	85 db		 test	 ebx, ebx
  0007f	74 25		 je	 SHORT $LN6@GetPoolBuf

; 76   : 				{
; 77   : 					newBuffer->NextBuffer = NULL;

  00081	83 26 00	 and	 DWORD PTR [esi], 0

; 78   : 					newBuffer->Address = bufferAddress;
; 79   : 					newBuffer->Size = requestedSize;

  00084	8b 45 0c	 mov	 eax, DWORD PTR _requestedSize$[ebp]
  00087	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0008a	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 80   : 					newBuffer->InUse = TRUE;

  0008d	c7 46 0c 01 00
	00 00		 mov	 DWORD PTR [esi+12], 1

; 81   : 
; 82   : 					if (!buffer)

  00094	85 ff		 test	 edi, edi
  00096	75 0a		 jne	 SHORT $LN5@GetPoolBuf

; 83   : 						queue->FirstPoolBuffer = newBuffer;

  00098	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  0009b	89 70 24	 mov	 DWORD PTR [eax+36], esi

; 84   : 					else

  0009e	8b f0		 mov	 esi, eax
  000a0	eb 13		 jmp	 SHORT $LN3@GetPoolBuf
$LN5@GetPoolBuf:

; 85   : 						buffer->NextBuffer = newBuffer;

  000a2	89 37		 mov	 DWORD PTR [edi], esi

; 86   : 				}
; 87   : 				else

  000a4	eb 0c		 jmp	 SHORT $LN27@GetPoolBuf
$LN6@GetPoolBuf:

; 88   : 					TCfree (newBuffer);

  000a6	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  000ab	56		 push	 esi
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN27@GetPoolBuf:
  000b2	8b 75 08	 mov	 esi, DWORD PTR _queue$[ebp]
$LN3@GetPoolBuf:

; 89   : 
; 90   : 				break;
; 91   : 			}
; 92   : 		}
; 93   : 
; 94   : 		ReleaseBufferPoolMutex (queue);

  000b5	6a 00		 push	 0
  000b7	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  000ba	50		 push	 eax
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeReleaseMutex@8

; 95   : 
; 96   : 		if (bufferAddress || !requestedSizePresentInPool || queue->StartPending)

  000c1	33 c0		 xor	 eax, eax
  000c3	3b d8		 cmp	 ebx, eax
  000c5	75 25		 jne	 SHORT $LN26@GetPoolBuf
  000c7	39 45 fc	 cmp	 DWORD PTR _requestedSizePresentInPool$[ebp], eax
  000ca	74 20		 je	 SHORT $LN26@GetPoolBuf
  000cc	8b 8e 78 01 00
	00		 mov	 ecx, DWORD PTR [esi+376]
  000d2	85 c9		 test	 ecx, ecx
  000d4	75 16		 jne	 SHORT $LN26@GetPoolBuf

; 97   : 			break;
; 98   : 
; 99   : 		KeWaitForSingleObject (&queue->PoolBufferFreeEvent, Executive, KernelMode, FALSE, NULL);

  000d6	50		 push	 eax
  000d7	50		 push	 eax
  000d8	50		 push	 eax
  000d9	50		 push	 eax
  000da	8d 86 58 01 00
	00		 lea	 eax, DWORD PTR [esi+344]
  000e0	50		 push	 eax
  000e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 100  : 	}

  000e7	e9 25 ff ff ff	 jmp	 $LL17@GetPoolBuf
$LN26@GetPoolBuf:
  000ec	5f		 pop	 edi
  000ed	5e		 pop	 esi

; 101  : 
; 102  : 	return bufferAddress;

  000ee	8b c3		 mov	 eax, ebx
  000f0	5b		 pop	 ebx

; 103  : }

  000f1	c9		 leave
  000f2	c2 08 00	 ret	 8
_GetPoolBuffer@8 ENDP
_TEXT	ENDS
EXTRN	__imp__KeSetEvent@12:PROC
; Function compile flags: /Ogsp
;	COMDAT _ReleasePoolBuffer@8
_TEXT	SEGMENT
_address$ = 8						; size = 4
_ReleasePoolBuffer@8 PROC				; COMDAT
; _queue$ = eax

; 107  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi
  00006	8b f0		 mov	 esi, eax

; 108  : 	EncryptedIoQueueBuffer *buffer;
; 109  : 	AcquireBufferPoolMutex (queue);

  00008	e8 00 00 00 00	 call	 _AcquireBufferPoolMutex@4

; 110  : 	
; 111  : 	for (buffer = queue->FirstPoolBuffer; buffer != NULL; buffer = buffer->NextBuffer)

  0000d	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00010	eb 0a		 jmp	 SHORT $LN12@ReleasePoo
$LL4@ReleasePoo:

; 112  : 	{
; 113  : 		if (buffer->Address == address)

  00012	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00015	3b 4d 08	 cmp	 ecx, DWORD PTR _address$[ebp]
  00018	74 08		 je	 SHORT $LN10@ReleasePoo

; 110  : 	
; 111  : 	for (buffer = queue->FirstPoolBuffer; buffer != NULL; buffer = buffer->NextBuffer)

  0001a	8b 00		 mov	 eax, DWORD PTR [eax]
$LN12@ReleasePoo:
  0001c	85 c0		 test	 eax, eax
  0001e	75 f2		 jne	 SHORT $LL4@ReleasePoo

; 112  : 	{
; 113  : 		if (buffer->Address == address)

  00020	eb 04		 jmp	 SHORT $LN2@ReleasePoo
$LN10@ReleasePoo:

; 114  : 		{
; 115  : 			ASSERT (buffer->InUse);
; 116  : 
; 117  : 			buffer->InUse = FALSE;

  00022	83 60 0c 00	 and	 DWORD PTR [eax+12], 0
$LN2@ReleasePoo:

; 118  : 			break;
; 119  : 		}
; 120  : 	}
; 121  : 
; 122  : 	ReleaseBufferPoolMutex (queue);

  00026	6a 00		 push	 0
  00028	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0002b	50		 push	 eax
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeReleaseMutex@8

; 123  : 	KeSetEvent (&queue->PoolBufferFreeEvent, IO_DISK_INCREMENT, FALSE);

  00032	6a 00		 push	 0
  00034	6a 01		 push	 1
  00036	81 c6 58 01 00
	00		 add	 esi, 344		; 00000158H
  0003c	56		 push	 esi
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
  00043	5e		 pop	 esi

; 124  : }

  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
_ReleasePoolBuffer@8 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _FreePoolBuffers@4
_TEXT	SEGMENT
_nextBuffer$27787 = -4					; size = 4
_queue$ = 8						; size = 4
_FreePoolBuffers@4 PROC					; COMDAT

; 128  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	56		 push	 esi
  00007	57		 push	 edi

; 129  : 	EncryptedIoQueueBuffer *buffer;
; 130  : 	AcquireBufferPoolMutex (queue);

  00008	8b 7d 08	 mov	 edi, DWORD PTR _queue$[ebp]
  0000b	8b c7		 mov	 eax, edi
  0000d	e8 00 00 00 00	 call	 _AcquireBufferPoolMutex@4

; 131  : 
; 132  : 	for (buffer = queue->FirstPoolBuffer; buffer != NULL; )

  00012	8b 77 24	 mov	 esi, DWORD PTR [edi+36]
  00015	85 f6		 test	 esi, esi
  00017	74 26		 je	 SHORT $LN1@FreePoolBu
  00019	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__ExFreePoolWithTag@8
  0001f	53		 push	 ebx
  00020	bb 54 43 4d 4d	 mov	 ebx, 1296909140		; 4d4d4354H
$LL2@FreePoolBu:

; 133  : 	{
; 134  : 		EncryptedIoQueueBuffer *nextBuffer = buffer->NextBuffer;

  00025	8b 06		 mov	 eax, DWORD PTR [esi]

; 135  : 
; 136  : 		ASSERT (!buffer->InUse || queue->StartPending);
; 137  : 
; 138  : 		TCfree (buffer->Address);

  00027	53		 push	 ebx
  00028	ff 76 04	 push	 DWORD PTR [esi+4]
  0002b	89 45 fc	 mov	 DWORD PTR _nextBuffer$27787[ebp], eax
  0002e	ff d7		 call	 edi

; 139  : 		TCfree (buffer);

  00030	53		 push	 ebx
  00031	56		 push	 esi
  00032	ff d7		 call	 edi

; 140  : 
; 141  : 		buffer = nextBuffer;

  00034	8b 75 fc	 mov	 esi, DWORD PTR _nextBuffer$27787[ebp]
  00037	85 f6		 test	 esi, esi
  00039	75 ea		 jne	 SHORT $LL2@FreePoolBu
  0003b	8b 7d 08	 mov	 edi, DWORD PTR _queue$[ebp]
  0003e	5b		 pop	 ebx
$LN1@FreePoolBu:

; 142  : 	}
; 143  : 
; 144  : 	queue->FirstPoolBuffer = NULL;

  0003f	83 67 24 00	 and	 DWORD PTR [edi+36], 0

; 145  : 	ReleaseBufferPoolMutex (queue);

  00043	6a 00		 push	 0
  00045	83 c7 04	 add	 edi, 4
  00048	57		 push	 edi
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeReleaseMutex@8
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi

; 146  : }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
_FreePoolBuffers@4 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _DecrementOutstandingIoCount@4
_TEXT	SEGMENT
_DecrementOutstandingIoCount@4 PROC			; COMDAT
; _queue$ = eax

; 151  : 	if (InterlockedDecrement (&queue->OutstandingIoCount) == 0 && (queue->SuspendPending || queue->StopPending))

  00000	8d 88 40 01 00
	00		 lea	 ecx, DWORD PTR [eax+320]
  00006	83 ca ff	 or	 edx, -1
  00009	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  0000d	75 24		 jne	 SHORT $LN2@DecrementO
  0000f	8b 88 84 01 00
	00		 mov	 ecx, DWORD PTR [eax+388]
  00015	85 c9		 test	 ecx, ecx
  00017	75 0a		 jne	 SHORT $LN1@DecrementO
  00019	8b 88 88 01 00
	00		 mov	 ecx, DWORD PTR [eax+392]
  0001f	85 c9		 test	 ecx, ecx
  00021	74 10		 je	 SHORT $LN2@DecrementO
$LN1@DecrementO:

; 152  : 		KeSetEvent (&queue->NoOutstandingIoEvent, IO_DISK_INCREMENT, FALSE);

  00023	6a 00		 push	 0
  00025	6a 01		 push	 1
  00027	05 44 01 00 00	 add	 eax, 324		; 00000144H
  0002c	50		 push	 eax
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
$LN2@DecrementO:

; 153  : }

  00033	c3		 ret	 0
_DecrementOutstandingIoCount@4 ENDP
_TEXT	ENDS
EXTRN	__imp__IoReleaseRemoveLockEx@12:PROC
; Function compile flags: /Ogsp
;	COMDAT _OnItemCompleted@8
_TEXT	SEGMENT
_freeItem$ = 8						; size = 4
_OnItemCompleted@8 PROC					; COMDAT
; _item$ = esi

; 157  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 158  : 	DecrementOutstandingIoCount (item->Queue);

  00005	8b 06		 mov	 eax, DWORD PTR [esi]
  00007	e8 00 00 00 00	 call	 _DecrementOutstandingIoCount@4

; 159  : 	IoReleaseRemoveLock (&item->Queue->RemoveLock, item->OriginalIrp);

  0000c	8b 06		 mov	 eax, DWORD PTR [esi]
  0000e	6a 18		 push	 24			; 00000018H
  00010	ff 76 04	 push	 DWORD PTR [esi+4]
  00013	83 c0 70	 add	 eax, 112		; 00000070H
  00016	50		 push	 eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 160  : 
; 161  : 	if (NT_SUCCESS (item->Status))

  0001d	33 c9		 xor	 ecx, ecx
  0001f	39 4e 18	 cmp	 DWORD PTR [esi+24], ecx
  00022	7c 1b		 jl	 SHORT $LN2@OnItemComp

; 162  : 	{
; 163  : 		if (item->Write)
; 164  : 			item->Queue->TotalBytesWritten += item->OriginalLength;

  00024	8b 06		 mov	 eax, DWORD PTR [esi]
  00026	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00029	39 4e 08	 cmp	 DWORD PTR [esi+8], ecx
  0002c	74 07		 je	 SHORT $LN3@OnItemComp
  0002e	05 70 01 00 00	 add	 eax, 368		; 00000170H

; 165  : 		else

  00033	eb 05		 jmp	 SHORT $LN7@OnItemComp
$LN3@OnItemComp:

; 166  : 			item->Queue->TotalBytesRead += item->OriginalLength;

  00035	05 68 01 00 00	 add	 eax, 360		; 00000168H
$LN7@OnItemComp:
  0003a	01 10		 add	 DWORD PTR [eax], edx
  0003c	11 48 04	 adc	 DWORD PTR [eax+4], ecx
$LN2@OnItemComp:

; 167  : 	}
; 168  : 
; 169  : 	if (freeItem)

  0003f	39 4d 08	 cmp	 DWORD PTR _freeItem$[ebp], ecx
  00042	74 08		 je	 SHORT $LN1@OnItemComp

; 170  : 		ReleasePoolBuffer (item->Queue, item);

  00044	8b 06		 mov	 eax, DWORD PTR [esi]
  00046	56		 push	 esi
  00047	e8 00 00 00 00	 call	 _ReleasePoolBuffer@8
$LN1@OnItemComp:

; 171  : }

  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
_OnItemCompleted@8 ENDP
_TEXT	ENDS
EXTRN	_TCCompleteDiskIrp@12:PROC
; Function compile flags: /Ogsp
;	COMDAT _CompleteOriginalIrp@12
_TEXT	SEGMENT
_information$ = 8					; size = 4
_CompleteOriginalIrp@12 PROC				; COMDAT
; _item$ = esi
; _status$ = edi

; 175  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 176  : #ifdef TC_TRACE_IO_QUEUE
; 177  : 	Dump ("< %I64d [%I64d] %c status=%x info=%I64d\n", item->OriginalIrpOffset, GetElapsedTime (&item->Queue->LastPerformanceCounter), item->Write ? 'W' : 'R', status, (int64) information);
; 178  : #endif
; 179  : 
; 180  : 	TCCompleteDiskIrp (item->OriginalIrp, status, information);

  00005	ff 75 08	 push	 DWORD PTR _information$[ebp]
  00008	57		 push	 edi
  00009	ff 76 04	 push	 DWORD PTR [esi+4]
  0000c	e8 00 00 00 00	 call	 _TCCompleteDiskIrp@12

; 181  : 
; 182  : 	item->Status = status;
; 183  : 	OnItemCompleted (item, TRUE);

  00011	8b 06		 mov	 eax, DWORD PTR [esi]
  00013	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  00016	e8 00 00 00 00	 call	 _DecrementOutstandingIoCount@4
  0001b	8b 06		 mov	 eax, DWORD PTR [esi]
  0001d	6a 18		 push	 24			; 00000018H
  0001f	ff 76 04	 push	 DWORD PTR [esi+4]
  00022	83 c0 70	 add	 eax, 112		; 00000070H
  00025	50		 push	 eax
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12
  0002c	33 c9		 xor	 ecx, ecx
  0002e	39 4e 18	 cmp	 DWORD PTR [esi+24], ecx
  00031	7c 1b		 jl	 SHORT $LN4@CompleteOr
  00033	8b 06		 mov	 eax, DWORD PTR [esi]
  00035	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00038	39 4e 08	 cmp	 DWORD PTR [esi+8], ecx
  0003b	74 07		 je	 SHORT $LN5@CompleteOr
  0003d	05 70 01 00 00	 add	 eax, 368		; 00000170H
  00042	eb 05		 jmp	 SHORT $LN9@CompleteOr
$LN5@CompleteOr:
  00044	05 68 01 00 00	 add	 eax, 360		; 00000168H
$LN9@CompleteOr:
  00049	01 10		 add	 DWORD PTR [eax], edx
  0004b	11 48 04	 adc	 DWORD PTR [eax+4], ecx
$LN4@CompleteOr:
  0004e	8b 06		 mov	 eax, DWORD PTR [esi]
  00050	56		 push	 esi
  00051	e8 00 00 00 00	 call	 _ReleasePoolBuffer@8

; 184  : 
; 185  : 	return status;

  00056	8b c7		 mov	 eax, edi

; 186  : }

  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
_CompleteOriginalIrp@12 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _AcquireFragmentBuffer@8
_TEXT	SEGMENT
_AcquireFragmentBuffer@8 PROC				; COMDAT
; _queue$ = ecx
; _buffer$ = edx

; 190  : {

  00000	8b ff		 npad	 2
  00002	56		 push	 esi

; 191  : 	NTSTATUS status = STATUS_INVALID_PARAMETER;
; 192  : 
; 193  : 	if (buffer == queue->FragmentBufferA)

  00003	33 f6		 xor	 esi, esi
  00005	b8 0d 00 00 c0	 mov	 eax, -1073741811	; c000000dH
  0000a	3b 91 e8 00 00
	00		 cmp	 edx, DWORD PTR [ecx+232]
  00010	75 08		 jne	 SHORT $LN4@AcquireFra

; 194  : 	{
; 195  : 		status = KeWaitForSingleObject (&queue->FragmentBufferAFreeEvent, Executive, KernelMode, FALSE, NULL);

  00012	81 c1 f0 00 00
	00		 add	 ecx, 240		; 000000f0H
  00018	eb 0e		 jmp	 SHORT $LN9@AcquireFra
$LN4@AcquireFra:

; 196  : 	}
; 197  : 	else if (buffer == queue->FragmentBufferB)

  0001a	3b 91 ec 00 00
	00		 cmp	 edx, DWORD PTR [ecx+236]
  00020	75 15		 jne	 SHORT $LN7@AcquireFra

; 198  : 	{
; 199  : 		status = KeWaitForSingleObject (&queue->FragmentBufferBFreeEvent, Executive, KernelMode, FALSE, NULL);

  00022	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
$LN9@AcquireFra:
  00028	56		 push	 esi
  00029	56		 push	 esi
  0002a	56		 push	 esi
  0002b	56		 push	 esi
  0002c	51		 push	 ecx
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 200  : 	}
; 201  : 
; 202  : 	if (!NT_SUCCESS (status))

  00033	3b c6		 cmp	 eax, esi
  00035	7d 14		 jge	 SHORT $LN1@AcquireFra
$LN7@AcquireFra:

; 203  : 		TC_BUG_CHECK (status);

  00037	68 43 54 00 00	 push	 21571			; 00005443H
  0003c	56		 push	 esi
  0003d	50		 push	 eax
  0003e	68 cb 00 00 00	 push	 203			; 000000cbH
  00043	6a 29		 push	 41			; 00000029H
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN10@AcquireFra:
$LN1@AcquireFra:
  0004b	5e		 pop	 esi

; 204  : }

  0004c	c3		 ret	 0
$LN8@AcquireFra:
_AcquireFragmentBuffer@8 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _ReleaseFragmentBuffer@8
_TEXT	SEGMENT
_ReleaseFragmentBuffer@8 PROC				; COMDAT
; _queue$ = eax
; _buffer$ = ecx

; 209  : 	if (buffer == queue->FragmentBufferA)

  00000	3b 88 e8 00 00
	00		 cmp	 ecx, DWORD PTR [eax+232]
  00006	75 07		 jne	 SHORT $LN4@ReleaseFra

; 210  : 	{
; 211  : 		KeSetEvent (&queue->FragmentBufferAFreeEvent, IO_DISK_INCREMENT, FALSE);

  00008	05 f0 00 00 00	 add	 eax, 240		; 000000f0H
  0000d	eb 0d		 jmp	 SHORT $LN9@ReleaseFra
$LN4@ReleaseFra:

; 212  : 	}
; 213  : 	else if (buffer == queue->FragmentBufferB)

  0000f	3b 88 ec 00 00
	00		 cmp	 ecx, DWORD PTR [eax+236]
  00015	75 11		 jne	 SHORT $LN2@ReleaseFra

; 214  : 	{
; 215  : 		KeSetEvent (&queue->FragmentBufferBFreeEvent, IO_DISK_INCREMENT, FALSE);

  00017	05 00 01 00 00	 add	 eax, 256		; 00000100H
$LN9@ReleaseFra:
  0001c	6a 00		 push	 0
  0001e	6a 01		 push	 1
  00020	50		 push	 eax
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 216  : 	}
; 217  : 	else
; 218  : 	{
; 219  : 		TC_BUG_CHECK (STATUS_INVALID_PARAMETER);
; 220  : 	}
; 221  : }

  00027	c3		 ret	 0
$LN2@ReleaseFra:
  00028	68 43 54 00 00	 push	 21571			; 00005443H
  0002d	6a 00		 push	 0
  0002f	68 0d 00 00 c0	 push	 -1073741811		; c000000dH
  00034	68 db 00 00 00	 push	 219			; 000000dbH
  00039	6a 29		 push	 41			; 00000029H
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN10@ReleaseFra:
$LN7@ReleaseFra:
  00041	cc		 int	 3
_ReleaseFragmentBuffer@8 ENDP
_TEXT	ENDS
EXTRN	__imp__PsTerminateSystemThread@4:PROC
EXTRN	__imp_@ExfInterlockedRemoveHeadList@8:PROC
EXTRN	_DecryptDataUnits@16:PROC
EXTRN	__imp__KeSetPriorityThread@8:PROC
EXTRN	__imp__KeGetCurrentThread@0:PROC
EXTRN	_IsEncryptionThreadPoolRunning@0:PROC
EXTRN	__alldiv:PROC
; Function compile flags: /Ogsp
;	COMDAT _CompletionThreadProc@4
_TEXT	SEGMENT
_dataUnit$ = -8						; size = 8
_threadArg$ = 8						; size = 4
_CompletionThreadProc@4 PROC				; COMDAT

; 225  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	51		 push	 ecx

; 226  : 	EncryptedIoQueue *queue = (EncryptedIoQueue *) threadArg;
; 227  : 	PLIST_ENTRY listEntry;
; 228  : 	EncryptedIoRequest *request;
; 229  : 	UINT64_STRUCT dataUnit;
; 230  : 
; 231  : 	if (IsEncryptionThreadPoolRunning())

  00007	e8 00 00 00 00	 call	 _IsEncryptionThreadPoolRunning@0
  0000c	85 c0		 test	 eax, eax
  0000e	74 0f		 je	 SHORT $LN18@Completion

; 232  : 		KeSetPriorityThread (KeGetCurrentThread(), LOW_REALTIME_PRIORITY);

  00010	6a 10		 push	 16			; 00000010H
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeGetCurrentThread@0
  00018	50		 push	 eax
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetPriorityThread@8
$LN18@Completion:
  0001f	53		 push	 ebx
  00020	56		 push	 esi

; 233  : 
; 234  : 	while (!queue->ThreadExitRequested)

  00021	8b 75 08	 mov	 esi, DWORD PTR _threadArg$[ebp]
  00024	8b 86 7c 01 00
	00		 mov	 eax, DWORD PTR [esi+380]
  0002a	57		 push	 edi
  0002b	85 c0		 test	 eax, eax
  0002d	0f 85 f1 00 00
	00		 jne	 $LN22@Completion
$LL11@Completion:

; 235  : 	{
; 236  : 		if (!NT_SUCCESS (KeWaitForSingleObject (&queue->CompletionThreadQueueNotEmptyEvent, Executive, KernelMode, FALSE, NULL)))

  00033	33 ff		 xor	 edi, edi
  00035	57		 push	 edi
  00036	57		 push	 edi
  00037	57		 push	 edi
  00038	57		 push	 edi
  00039	8d 86 d8 00 00
	00		 lea	 eax, DWORD PTR [esi+216]
  0003f	50		 push	 eax
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
  00046	85 c0		 test	 eax, eax
  00048	0f 8c c6 00 00
	00		 jl	 $LN6@Completion

; 237  : 			continue;
; 238  : 
; 239  : 		if (queue->ThreadExitRequested)

  0004e	8b 86 7c 01 00
	00		 mov	 eax, DWORD PTR [esi+380]
  00054	85 c0		 test	 eax, eax
  00056	0f 85 ca 00 00
	00		 jne	 $LN20@Completion

; 240  : 			break;
; 241  : 
; 242  : 		while ((listEntry = ExInterlockedRemoveHeadList (&queue->CompletionThreadQueue, &queue->CompletionThreadQueueLock)))

  0005c	e9 99 00 00 00	 jmp	 $LN24@Completion
$LL7@Completion:

; 243  : 		{
; 244  : 			request = CONTAINING_RECORD (listEntry, EncryptedIoRequest, CompletionListEntry);

  00061	8d 58 cc	 lea	 ebx, DWORD PTR [eax-52]

; 245  : 
; 246  : 			if (request->EncryptedLength > 0 && NT_SUCCESS (request->Item->Status))

  00064	39 7b 20	 cmp	 DWORD PTR [ebx+32], edi
  00067	76 6b		 jbe	 SHORT $LN5@Completion
  00069	8b 03		 mov	 eax, DWORD PTR [ebx]
  0006b	39 78 18	 cmp	 DWORD PTR [eax+24], edi
  0006e	7c 64		 jl	 SHORT $LN5@Completion

; 247  : 			{
; 248  : 				ASSERT (request->EncryptedOffset + request->EncryptedLength <= request->Offset.QuadPart + request->Length);
; 249  : 				dataUnit.Value = (request->Offset.QuadPart + request->EncryptedOffset) / ENCRYPTION_DATA_UNIT_SIZE;

  00070	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00073	03 43 18	 add	 eax, DWORD PTR [ebx+24]
  00076	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00079	13 4b 1c	 adc	 ecx, DWORD PTR [ebx+28]
  0007c	57		 push	 edi
  0007d	68 00 02 00 00	 push	 512			; 00000200H
  00082	51		 push	 ecx
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 __alldiv
  00089	89 45 f8	 mov	 DWORD PTR _dataUnit$[ebp], eax

; 250  : 
; 251  : 				if (queue->CryptoInfo->bPartitionInInactiveSysEncScope)

  0008c	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  0008f	89 55 fc	 mov	 DWORD PTR _dataUnit$[ebp+4], edx
  00092	39 b8 28 44 00
	00		 cmp	 DWORD PTR [eax+17448], edi
  00098	74 11		 je	 SHORT $LN4@Completion

; 252  : 					dataUnit.Value += queue->CryptoInfo->FirstDataUnitNo.Value;

  0009a	8b 88 30 44 00
	00		 mov	 ecx, DWORD PTR [eax+17456]
  000a0	01 4d f8	 add	 DWORD PTR _dataUnit$[ebp], ecx
  000a3	8b 88 34 44 00
	00		 mov	 ecx, DWORD PTR [eax+17460]
  000a9	eb 0e		 jmp	 SHORT $LN25@Completion
$LN4@Completion:

; 253  : 				else if (queue->RemapEncryptedArea)

  000ab	39 7e 5c	 cmp	 DWORD PTR [esi+92], edi
  000ae	74 0c		 je	 SHORT $LN2@Completion

; 254  : 					dataUnit.Value += queue->RemappedAreaDataUnitOffset;

  000b0	8b 4e 68	 mov	 ecx, DWORD PTR [esi+104]
  000b3	01 4d f8	 add	 DWORD PTR _dataUnit$[ebp], ecx
  000b6	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
$LN25@Completion:
  000b9	11 4d fc	 adc	 DWORD PTR _dataUnit$[ebp+4], ecx
$LN2@Completion:

; 255  : 
; 256  : 				DecryptDataUnits (request->Data + request->EncryptedOffset, &dataUnit, request->EncryptedLength / ENCRYPTION_DATA_UNIT_SIZE, queue->CryptoInfo);

  000bc	50		 push	 eax
  000bd	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  000c0	c1 e8 09	 shr	 eax, 9
  000c3	50		 push	 eax
  000c4	8d 45 f8	 lea	 eax, DWORD PTR _dataUnit$[ebp]
  000c7	50		 push	 eax
  000c8	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  000cb	03 43 18	 add	 eax, DWORD PTR [ebx+24]
  000ce	50		 push	 eax
  000cf	e8 00 00 00 00	 call	 _DecryptDataUnits@16
$LN5@Completion:

; 257  : 			}
; 258  : 
; 259  : 			if (request->CompleteOriginalIrp)

  000d4	39 7b 04	 cmp	 DWORD PTR [ebx+4], edi
  000d7	74 19		 je	 SHORT $LN1@Completion

; 260  : 			{
; 261  : 				CompleteOriginalIrp (request->Item, request->Item->Status,
; 262  : 					NT_SUCCESS (request->Item->Status) ? request->Item->OriginalLength : 0);

  000d9	8b 33		 mov	 esi, DWORD PTR [ebx]
  000db	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  000de	3b c7		 cmp	 eax, edi
  000e0	7c 03		 jl	 SHORT $LN15@Completion
  000e2	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
$LN15@Completion:
  000e5	57		 push	 edi
  000e6	8b f8		 mov	 edi, eax
  000e8	e8 00 00 00 00	 call	 _CompleteOriginalIrp@12
  000ed	8b 75 08	 mov	 esi, DWORD PTR _threadArg$[ebp]
  000f0	33 ff		 xor	 edi, edi
$LN1@Completion:

; 263  : 			}
; 264  : 
; 265  : 			ReleasePoolBuffer (queue, request);

  000f2	53		 push	 ebx
  000f3	8b c6		 mov	 eax, esi
  000f5	e8 00 00 00 00	 call	 _ReleasePoolBuffer@8
$LN24@Completion:
  000fa	8d 96 d4 00 00
	00		 lea	 edx, DWORD PTR [esi+212]
  00100	8d 8e cc 00 00
	00		 lea	 ecx, DWORD PTR [esi+204]
  00106	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExfInterlockedRemoveHeadList@8
  0010c	3b c7		 cmp	 eax, edi
  0010e	0f 85 4d ff ff
	ff		 jne	 $LL7@Completion
$LN6@Completion:

; 233  : 
; 234  : 	while (!queue->ThreadExitRequested)

  00114	8b 86 7c 01 00
	00		 mov	 eax, DWORD PTR [esi+380]
  0011a	85 c0		 test	 eax, eax
  0011c	0f 84 11 ff ff
	ff		 je	 $LL11@Completion
  00122	eb 02		 jmp	 SHORT $LN20@Completion
$LN22@Completion:
  00124	33 ff		 xor	 edi, edi
$LN20@Completion:

; 266  : 		}
; 267  : 	}
; 268  : 
; 269  : 	PsTerminateSystemThread (STATUS_SUCCESS);

  00126	57		 push	 edi
  00127	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsTerminateSystemThread@4
  0012d	5f		 pop	 edi
  0012e	5e		 pop	 esi
  0012f	5b		 pop	 ebx

; 270  : }

  00130	c9		 leave
  00131	c2 04 00	 ret	 4
_CompletionThreadProc@4 ENDP
_TEXT	ENDS
EXTRN	__imp__ZwReadFile@36:PROC
EXTRN	_TCReadDevice@20:PROC
EXTRN	_memcpy:PROC
; Function compile flags: /Ogsp
;	COMDAT _TCCachedRead@24
_TEXT	SEGMENT
_ioStatus$ = 8						; size = 4
_buffer$ = 12						; size = 4
_offset$ = 16						; size = 8
_TCCachedRead@24 PROC					; COMDAT
; _queue$ = esi
; _length$ = edi

; 274  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 275  : 	queue->LastReadOffset = offset;

  00005	8b 45 10	 mov	 eax, DWORD PTR _offset$[ebp]
  00008	8b 4d 14	 mov	 ecx, DWORD PTR _offset$[ebp+4]
  0000b	53		 push	 ebx

; 276  : 	queue->LastReadLength = length;
; 277  : 
; 278  : 	if (queue->ReadAheadBufferValid && queue->ReadAheadOffset.QuadPart == offset.QuadPart && queue->ReadAheadLength >= length)

  0000c	33 db		 xor	 ebx, ebx
  0000e	89 86 18 01 00
	00		 mov	 DWORD PTR [esi+280], eax
  00014	89 8e 1c 01 00
	00		 mov	 DWORD PTR [esi+284], ecx
  0001a	89 be 20 01 00
	00		 mov	 DWORD PTR [esi+288], edi
  00020	39 9e 10 01 00
	00		 cmp	 DWORD PTR [esi+272], ebx
  00026	74 3f		 je	 SHORT $LN6@TCCachedRe
  00028	8b 96 28 01 00
	00		 mov	 edx, DWORD PTR [esi+296]
  0002e	3b d0		 cmp	 edx, eax
  00030	75 35		 jne	 SHORT $LN6@TCCachedRe
  00032	8b 96 2c 01 00
	00		 mov	 edx, DWORD PTR [esi+300]
  00038	3b d1		 cmp	 edx, ecx
  0003a	75 2b		 jne	 SHORT $LN6@TCCachedRe
  0003c	39 be 30 01 00
	00		 cmp	 DWORD PTR [esi+304], edi
  00042	72 23		 jb	 SHORT $LN6@TCCachedRe

; 279  : 	{
; 280  : 		memcpy (buffer, queue->ReadAheadBuffer, length);

  00044	57		 push	 edi
  00045	ff b6 34 01 00
	00		 push	 DWORD PTR [esi+308]
  0004b	ff 75 0c	 push	 DWORD PTR _buffer$[ebp]
  0004e	e8 00 00 00 00	 call	 _memcpy
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH

; 281  : 
; 282  : 		if (!queue->IsFilterDevice)

  00056	39 5e 3c	 cmp	 DWORD PTR [esi+60], ebx
  00059	75 08		 jne	 SHORT $LN2@TCCachedRe

; 283  : 		{
; 284  : 			ioStatus->Information = length;

  0005b	8b 45 08	 mov	 eax, DWORD PTR _ioStatus$[ebp]
  0005e	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 285  : 			ioStatus->Status = STATUS_SUCCESS;

  00061	89 18		 mov	 DWORD PTR [eax], ebx
$LN2@TCCachedRe:

; 286  : 		}
; 287  : 
; 288  : 		return STATUS_SUCCESS;

  00063	33 c0		 xor	 eax, eax
  00065	eb 2d		 jmp	 SHORT $LN4@TCCachedRe
$LN6@TCCachedRe:

; 289  : 	}
; 290  : 
; 291  : 	if (queue->IsFilterDevice)

  00067	39 5e 3c	 cmp	 DWORD PTR [esi+60], ebx
  0006a	74 10		 je	 SHORT $LN1@TCCachedRe

; 292  : 		return TCReadDevice (queue->LowerDeviceObject, buffer, offset, length);

  0006c	57		 push	 edi
  0006d	51		 push	 ecx
  0006e	50		 push	 eax
  0006f	ff 75 0c	 push	 DWORD PTR _buffer$[ebp]
  00072	ff 76 40	 push	 DWORD PTR [esi+64]
  00075	e8 00 00 00 00	 call	 _TCReadDevice@20
  0007a	eb 18		 jmp	 SHORT $LN4@TCCachedRe
$LN1@TCCachedRe:

; 293  : 
; 294  : 	return ZwReadFile (queue->HostFileHandle, NULL, NULL, NULL, ioStatus, buffer, length, &offset, NULL);

  0007c	53		 push	 ebx
  0007d	8d 45 10	 lea	 eax, DWORD PTR _offset$[ebp]
  00080	50		 push	 eax
  00081	57		 push	 edi
  00082	ff 75 0c	 push	 DWORD PTR _buffer$[ebp]
  00085	ff 75 08	 push	 DWORD PTR _ioStatus$[ebp]
  00088	53		 push	 ebx
  00089	53		 push	 ebx
  0008a	53		 push	 ebx
  0008b	ff 76 2c	 push	 DWORD PTR [esi+44]
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwReadFile@36
$LN4@TCCachedRe:
  00094	5b		 pop	 ebx

; 295  : }

  00095	5d		 pop	 ebp
  00096	c2 10 00	 ret	 16			; 00000010H
_TCCachedRead@24 ENDP
_TEXT	ENDS
EXTRN	__imp_@ExfInterlockedInsertTailList@12:PROC
EXTRN	__imp__ZwWriteFile@36:PROC
EXTRN	_TCWriteDevice@20:PROC
EXTRN	__imp__SeImpersonateClientEx@8:PROC
; Function compile flags: /Ogsp
;	COMDAT _IoThreadProc@4
_TEXT	SEGMENT
_ioStatus$27984 = -28					; size = 8
_ioStatus$27960 = -20					; size = 8
_readAhead$27974 = -12					; size = 4
_subFragment$27930 = -12				; size = 4
_subFragmentData$27931 = -8				; size = 4
_subFragmentLength$27936 = -4				; size = 4
_threadArg$ = 8						; size = 4
_IoThreadProc@4 PROC					; COMDAT

; 299  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00008	56		 push	 esi
  00009	57		 push	 edi

; 300  : 	EncryptedIoQueue *queue = (EncryptedIoQueue *) threadArg;
; 301  : 	PLIST_ENTRY listEntry;
; 302  : 	EncryptedIoRequest *request;
; 303  : 
; 304  : 	KeSetPriorityThread (KeGetCurrentThread(), LOW_REALTIME_PRIORITY);

  0000a	6a 10		 push	 16			; 00000010H
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeGetCurrentThread@0
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetPriorityThread@8

; 305  : 
; 306  : 	if (!queue->IsFilterDevice && queue->SecurityClientContext)

  00019	8b 75 08	 mov	 esi, DWORD PTR _threadArg$[ebp]
  0001c	33 ff		 xor	 edi, edi
  0001e	39 7e 3c	 cmp	 DWORD PTR [esi+60], edi
  00021	75 0f		 jne	 SHORT $LN47@IoThreadPr
  00023	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00026	3b c7		 cmp	 eax, edi
  00028	74 08		 je	 SHORT $LN47@IoThreadPr

; 307  : 	{
; 308  : #ifdef DEBUG
; 309  : 		NTSTATUS status =
; 310  : #endif
; 311  : 		SeImpersonateClientEx (queue->SecurityClientContext, NULL);

  0002a	57		 push	 edi
  0002b	50		 push	 eax
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeImpersonateClientEx@8
$LN47@IoThreadPr:

; 312  : 		ASSERT (NT_SUCCESS (status));
; 313  : 	}
; 314  : 
; 315  : 	while (!queue->ThreadExitRequested)

  00032	8b 86 7c 01 00
	00		 mov	 eax, DWORD PTR [esi+380]
  00038	85 c0		 test	 eax, eax
  0003a	0f 85 5a 03 00
	00		 jne	 $LN50@IoThreadPr
  00040	53		 push	 ebx
$LL40@IoThreadPr:

; 316  : 	{
; 317  : 		if (!NT_SUCCESS (KeWaitForSingleObject (&queue->IoThreadQueueNotEmptyEvent, Executive, KernelMode, FALSE, NULL)))

  00041	57		 push	 edi
  00042	57		 push	 edi
  00043	57		 push	 edi
  00044	57		 push	 edi
  00045	8d 86 b8 00 00
	00		 lea	 eax, DWORD PTR [esi+184]
  0004b	50		 push	 eax
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
  00052	85 c0		 test	 eax, eax
  00054	0f 8c 31 03 00
	00		 jl	 $LN35@IoThreadPr

; 318  : 			continue;
; 319  : 
; 320  : 		if (queue->ThreadExitRequested)

  0005a	8b 86 7c 01 00
	00		 mov	 eax, DWORD PTR [esi+380]
  00060	85 c0		 test	 eax, eax
  00062	0f 85 31 03 00
	00		 jne	 $LN57@IoThreadPr

; 321  : 			break;
; 322  : 
; 323  : 		while ((listEntry = ExInterlockedRemoveHeadList (&queue->IoThreadQueue, &queue->IoThreadQueueLock)))

  00068	e9 04 03 00 00	 jmp	 $LN4@IoThreadPr
$LL36@IoThreadPr:

; 324  : 		{
; 325  : 			InterlockedDecrement (&queue->IoThreadPendingRequestCount);

  0006d	8d 8e 54 01 00
	00		 lea	 ecx, DWORD PTR [esi+340]
  00073	83 ca ff	 or	 edx, -1
  00076	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx

; 326  : 			request = CONTAINING_RECORD (listEntry, EncryptedIoRequest, ListEntry);

  0007a	8d 58 d4	 lea	 ebx, DWORD PTR [eax-44]

; 327  : 			
; 328  : #ifdef TC_TRACE_IO_QUEUE
; 329  : 			Dump ("%c   %I64d [%I64d] roff=%I64d rlen=%d\n", request->Item->Write ? 'W' : 'R', request->Item->OriginalIrpOffset.QuadPart, GetElapsedTime (&queue->LastPerformanceCounter), request->Offset.QuadPart, request->Length);
; 330  : #endif
; 331  : 
; 332  : 			// Perform IO request if no preceding request of the item failed
; 333  : 			if (NT_SUCCESS (request->Item->Status))

  0007d	8b 13		 mov	 edx, DWORD PTR [ebx]
  0007f	39 7a 18	 cmp	 DWORD PTR [edx+24], edi
  00082	0f 8c 78 01 00
	00		 jl	 $LN10@IoThreadPr

; 334  : 			{
; 335  : 				if (queue->IsFilterDevice)

  00088	39 7e 3c	 cmp	 DWORD PTR [esi+60], edi
  0008b	0f 84 18 01 00
	00		 je	 $LN33@IoThreadPr

; 336  : 				{
; 337  : 					if (queue->RemapEncryptedArea && request->EncryptedLength > 0)

  00091	39 7e 5c	 cmp	 DWORD PTR [esi+92], edi
  00094	0f 84 d1 00 00
	00		 je	 $LN32@IoThreadPr
  0009a	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  0009d	3b c7		 cmp	 eax, edi
  0009f	0f 86 c6 00 00
	00		 jbe	 $LN32@IoThreadPr

; 338  : 					{
; 339  : 						if (request->EncryptedLength != request->Length)

  000a5	3b 43 10	 cmp	 eax, DWORD PTR [ebx+16]
  000a8	0f 84 a1 00 00
	00		 je	 $LN31@IoThreadPr

; 340  : 						{
; 341  : 							// Up to three subfragments may be required to handle a partially remapped fragment
; 342  : 							int subFragment;
; 343  : 							byte *subFragmentData = request->Data;

  000ae	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  000b1	89 45 f8	 mov	 DWORD PTR _subFragmentData$27931[ebp], eax

; 344  : 
; 345  : 							for (subFragment = 0 ; subFragment < 3; ++subFragment)

  000b4	89 7d f4	 mov	 DWORD PTR _subFragment$27930[ebp], edi
$LL30@IoThreadPr:

; 346  : 							{
; 347  : 								LARGE_INTEGER subFragmentOffset;
; 348  : 								ULONG subFragmentLength;
; 349  : 								subFragmentOffset.QuadPart = request->Offset.QuadPart;
; 350  : 
; 351  : 								switch (subFragment)

  000b7	8b 55 f4	 mov	 edx, DWORD PTR _subFragment$27930[ebp]
  000ba	2b d7		 sub	 edx, edi
  000bc	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  000bf	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  000c2	74 38		 je	 SHORT $LN25@IoThreadPr
  000c4	4a		 dec	 edx
  000c5	74 20		 je	 SHORT $LN24@IoThreadPr
  000c7	4a		 dec	 edx
  000c8	75 38		 jne	 SHORT $LN53@IoThreadPr

; 361  : 
; 362  : 								case 2:
; 363  : 									subFragmentOffset.QuadPart += request->EncryptedOffset + request->EncryptedLength;

  000ca	8b 53 20	 mov	 edx, DWORD PTR [ebx+32]
  000cd	33 ff		 xor	 edi, edi
  000cf	03 53 18	 add	 edx, DWORD PTR [ebx+24]
  000d2	13 7b 1c	 adc	 edi, DWORD PTR [ebx+28]
  000d5	03 c2		 add	 eax, edx
  000d7	13 cf		 adc	 ecx, edi

; 364  : 									subFragmentLength = (ULONG) (request->Length - (request->EncryptedOffset + request->EncryptedLength));

  000d9	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
  000dc	2b 7b 18	 sub	 edi, DWORD PTR [ebx+24]
  000df	2b 7b 20	 sub	 edi, DWORD PTR [ebx+32]
  000e2	89 7d fc	 mov	 DWORD PTR _subFragmentLength$27936[ebp], edi

; 365  : 									break;

  000e5	eb 1e		 jmp	 SHORT $LN26@IoThreadPr
$LN24@IoThreadPr:

; 355  : 									break;
; 356  : 
; 357  : 								case 1:
; 358  : 									subFragmentOffset.QuadPart += request->EncryptedOffset + queue->RemappedAreaOffset;

  000e7	8b 56 60	 mov	 edx, DWORD PTR [esi+96]
  000ea	03 53 18	 add	 edx, DWORD PTR [ebx+24]
  000ed	8b 7e 64	 mov	 edi, DWORD PTR [esi+100]
  000f0	13 7b 1c	 adc	 edi, DWORD PTR [ebx+28]
  000f3	03 c2		 add	 eax, edx

; 359  : 									subFragmentLength = request->EncryptedLength;

  000f5	8b 53 20	 mov	 edx, DWORD PTR [ebx+32]
  000f8	13 cf		 adc	 ecx, edi

; 360  : 									break;

  000fa	eb 03		 jmp	 SHORT $LN64@IoThreadPr
$LN25@IoThreadPr:

; 352  : 								{
; 353  : 								case 0:
; 354  : 									subFragmentLength = (ULONG) request->EncryptedOffset;

  000fc	8b 53 18	 mov	 edx, DWORD PTR [ebx+24]
$LN64@IoThreadPr:
  000ff	89 55 fc	 mov	 DWORD PTR _subFragmentLength$27936[ebp], edx
$LN53@IoThreadPr:
  00102	8b 7d fc	 mov	 edi, DWORD PTR _subFragmentLength$27936[ebp]
$LN26@IoThreadPr:

; 366  : 								}
; 367  : 
; 368  : 								if (subFragmentLength > 0)

  00105	85 ff		 test	 edi, edi
  00107	76 32		 jbe	 SHORT $LN29@IoThreadPr

; 369  : 								{
; 370  : 									if (request->Item->Write)

  00109	8b 13		 mov	 edx, DWORD PTR [ebx]
  0010b	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  0010f	74 10		 je	 SHORT $LN21@IoThreadPr

; 371  : 										request->Item->Status = TCWriteDevice (queue->LowerDeviceObject, subFragmentData, subFragmentOffset, subFragmentLength);

  00111	57		 push	 edi
  00112	51		 push	 ecx
  00113	50		 push	 eax
  00114	ff 75 f8	 push	 DWORD PTR _subFragmentData$27931[ebp]
  00117	ff 76 40	 push	 DWORD PTR [esi+64]
  0011a	e8 00 00 00 00	 call	 _TCWriteDevice@20

; 372  : 									else

  0011f	eb 12		 jmp	 SHORT $LN59@IoThreadPr
$LN21@IoThreadPr:

; 373  : 										request->Item->Status = TCCachedRead (queue, NULL, subFragmentData, subFragmentOffset, subFragmentLength);

  00121	51		 push	 ecx
  00122	50		 push	 eax
  00123	ff 75 f8	 push	 DWORD PTR _subFragmentData$27931[ebp]
  00126	6a 00		 push	 0
  00128	e8 00 00 00 00	 call	 _TCCachedRead@24
  0012d	8b 75 08	 mov	 esi, DWORD PTR _threadArg$[ebp]
  00130	8b 7d fc	 mov	 edi, DWORD PTR _subFragmentLength$27936[ebp]
$LN59@IoThreadPr:
  00133	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 374  : 
; 375  : 									subFragmentData += subFragmentLength;

  00135	01 7d f8	 add	 DWORD PTR _subFragmentData$27931[ebp], edi
  00138	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN29@IoThreadPr:
  0013b	ff 45 f4	 inc	 DWORD PTR _subFragment$27930[ebp]

; 376  : 								}
; 377  : 							}
; 378  : 						}
; 379  : 						else

  0013e	33 ff		 xor	 edi, edi
  00140	83 7d f4 03	 cmp	 DWORD PTR _subFragment$27930[ebp], 3
  00144	0f 8c 6d ff ff
	ff		 jl	 $LL30@IoThreadPr
  0014a	e9 b1 00 00 00	 jmp	 $LN10@IoThreadPr
$LN31@IoThreadPr:

; 380  : 						{
; 381  : 							// Remap the fragment
; 382  : 							LARGE_INTEGER remappedOffset;
; 383  : 							remappedOffset.QuadPart = request->Offset.QuadPart + queue->RemappedAreaOffset;

  0014f	8b 46 60	 mov	 eax, DWORD PTR [esi+96]
  00152	03 43 08	 add	 eax, DWORD PTR [ebx+8]
  00155	8b 4e 64	 mov	 ecx, DWORD PTR [esi+100]
  00158	13 4b 0c	 adc	 ecx, DWORD PTR [ebx+12]

; 384  : 
; 385  : 							if (request->Item->Write)

  0015b	39 7a 08	 cmp	 DWORD PTR [edx+8], edi
  0015e	74 07		 je	 SHORT $LN18@IoThreadPr

; 386  : 								request->Item->Status = TCWriteDevice (queue->LowerDeviceObject, request->Data, remappedOffset, request->Length);

  00160	ff 73 10	 push	 DWORD PTR [ebx+16]
  00163	51		 push	 ecx
  00164	50		 push	 eax

; 387  : 							else

  00165	eb 12		 jmp	 SHORT $LN62@IoThreadPr
$LN18@IoThreadPr:

; 388  : 								request->Item->Status = TCCachedRead (queue, NULL, request->Data, remappedOffset, request->Length);

  00167	51		 push	 ecx
  00168	50		 push	 eax

; 389  : 						}
; 390  : 					}
; 391  : 					else

  00169	eb 26		 jmp	 SHORT $LN61@IoThreadPr
$LN32@IoThreadPr:

; 392  : 					{
; 393  : 						if (request->Item->Write)

  0016b	39 7a 08	 cmp	 DWORD PTR [edx+8], edi
  0016e	74 1b		 je	 SHORT $LN15@IoThreadPr

; 394  : 							request->Item->Status = TCWriteDevice (queue->LowerDeviceObject, request->Data, request->Offset, request->Length);

  00170	ff 73 10	 push	 DWORD PTR [ebx+16]
  00173	ff 73 0c	 push	 DWORD PTR [ebx+12]
  00176	ff 73 08	 push	 DWORD PTR [ebx+8]
$LN62@IoThreadPr:
  00179	ff 73 24	 push	 DWORD PTR [ebx+36]
  0017c	ff 76 40	 push	 DWORD PTR [esi+64]
  0017f	e8 00 00 00 00	 call	 _TCWriteDevice@20
  00184	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00186	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 395  : 						else

  00189	eb 75		 jmp	 SHORT $LN10@IoThreadPr
$LN15@IoThreadPr:

; 396  : 							request->Item->Status = TCCachedRead (queue, NULL, request->Data, request->Offset, request->Length);

  0018b	ff 73 0c	 push	 DWORD PTR [ebx+12]
  0018e	ff 73 08	 push	 DWORD PTR [ebx+8]
$LN61@IoThreadPr:
  00191	ff 73 24	 push	 DWORD PTR [ebx+36]
  00194	57		 push	 edi
  00195	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
  00198	e8 00 00 00 00	 call	 _TCCachedRead@24
  0019d	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 397  : 					}
; 398  : 				}
; 399  : 				else

  0019f	8b 75 08	 mov	 esi, DWORD PTR _threadArg$[ebp]
  001a2	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  001a5	33 ff		 xor	 edi, edi
  001a7	eb 57		 jmp	 SHORT $LN10@IoThreadPr
$LN33@IoThreadPr:

; 400  : 				{
; 401  : 					IO_STATUS_BLOCK ioStatus;
; 402  : 
; 403  : 					if (request->Item->Write)

  001a9	39 7a 08	 cmp	 DWORD PTR [edx+8], edi
  001ac	74 1d		 je	 SHORT $LN12@IoThreadPr

; 404  : 						request->Item->Status = ZwWriteFile (queue->HostFileHandle, NULL, NULL, NULL, &ioStatus, request->Data, request->Length, &request->Offset, NULL);

  001ae	57		 push	 edi
  001af	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  001b2	50		 push	 eax
  001b3	ff 73 10	 push	 DWORD PTR [ebx+16]
  001b6	8d 45 ec	 lea	 eax, DWORD PTR _ioStatus$27960[ebp]
  001b9	ff 73 24	 push	 DWORD PTR [ebx+36]
  001bc	50		 push	 eax
  001bd	57		 push	 edi
  001be	57		 push	 edi
  001bf	57		 push	 edi
  001c0	ff 76 2c	 push	 DWORD PTR [esi+44]
  001c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwWriteFile@36

; 405  : 					else

  001c9	eb 1a		 jmp	 SHORT $LN60@IoThreadPr
$LN12@IoThreadPr:

; 406  : 						request->Item->Status = TCCachedRead (queue, &ioStatus, request->Data, request->Offset, request->Length);

  001cb	ff 73 0c	 push	 DWORD PTR [ebx+12]
  001ce	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
  001d1	ff 73 08	 push	 DWORD PTR [ebx+8]
  001d4	8d 45 ec	 lea	 eax, DWORD PTR _ioStatus$27960[ebp]
  001d7	ff 73 24	 push	 DWORD PTR [ebx+36]
  001da	50		 push	 eax
  001db	e8 00 00 00 00	 call	 _TCCachedRead@24
  001e0	8b 75 08	 mov	 esi, DWORD PTR _threadArg$[ebp]
  001e3	33 ff		 xor	 edi, edi
$LN60@IoThreadPr:
  001e5	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  001e7	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 407  : 
; 408  : 					if (NT_SUCCESS (request->Item->Status) && ioStatus.Information != request->Length)

  001ea	8b 03		 mov	 eax, DWORD PTR [ebx]
  001ec	39 78 18	 cmp	 DWORD PTR [eax+24], edi
  001ef	7c 0f		 jl	 SHORT $LN10@IoThreadPr
  001f1	8b 4d f0	 mov	 ecx, DWORD PTR _ioStatus$27960[ebp+4]
  001f4	3b 4b 10	 cmp	 ecx, DWORD PTR [ebx+16]
  001f7	74 07		 je	 SHORT $LN10@IoThreadPr

; 409  : 						request->Item->Status = STATUS_END_OF_FILE;

  001f9	c7 40 18 11 00
	00 c0		 mov	 DWORD PTR [eax+24], -1073741807 ; c0000011H
$LN10@IoThreadPr:

; 410  : 				}
; 411  : 			}
; 412  : 
; 413  : 			if (request->Item->Write)

  00200	8b 03		 mov	 eax, DWORD PTR [ebx]
  00202	39 78 08	 cmp	 DWORD PTR [eax+8], edi
  00205	74 3b		 je	 SHORT $LN9@IoThreadPr

; 414  : 			{
; 415  : 				queue->ReadAheadBufferValid = FALSE;

  00207	89 be 10 01 00
	00		 mov	 DWORD PTR [esi+272], edi

; 416  : 
; 417  : 				ReleaseFragmentBuffer (queue, request->Data);

  0020d	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  00210	8b c6		 mov	 eax, esi
  00212	e8 00 00 00 00	 call	 _ReleaseFragmentBuffer@8

; 418  : 
; 419  : 				if (request->CompleteOriginalIrp)

  00217	39 7b 04	 cmp	 DWORD PTR [ebx+4], edi
  0021a	74 19		 je	 SHORT $LN8@IoThreadPr

; 420  : 				{
; 421  : 					CompleteOriginalIrp (request->Item, request->Item->Status,
; 422  : 						NT_SUCCESS (request->Item->Status) ? request->Item->OriginalLength : 0);

  0021c	8b 33		 mov	 esi, DWORD PTR [ebx]
  0021e	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00221	3b c7		 cmp	 eax, edi
  00223	7c 03		 jl	 SHORT $LN44@IoThreadPr
  00225	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
$LN44@IoThreadPr:
  00228	57		 push	 edi
  00229	8b f8		 mov	 edi, eax
  0022b	e8 00 00 00 00	 call	 _CompleteOriginalIrp@12
  00230	8b 75 08	 mov	 esi, DWORD PTR _threadArg$[ebp]
  00233	33 ff		 xor	 edi, edi
$LN8@IoThreadPr:

; 423  : 				}
; 424  : 
; 425  : 				ReleasePoolBuffer (queue, request);

  00235	53		 push	 ebx
  00236	8b c6		 mov	 eax, esi
  00238	e8 00 00 00 00	 call	 _ReleasePoolBuffer@8

; 426  : 			}
; 427  : 			else

  0023d	e9 2f 01 00 00	 jmp	 $LN4@IoThreadPr
$LN9@IoThreadPr:

; 428  : 			{
; 429  : 				BOOL readAhead = FALSE;
; 430  : 
; 431  : 				if (NT_SUCCESS (request->Item->Status))

  00242	39 78 18	 cmp	 DWORD PTR [eax+24], edi
  00245	89 7d f4	 mov	 DWORD PTR _readAhead$27974[ebp], edi
  00248	7c 11		 jl	 SHORT $LN6@IoThreadPr

; 432  : 					memcpy (request->OrigDataBufferFragment, request->Data, request->Length);

  0024a	ff 73 10	 push	 DWORD PTR [ebx+16]
  0024d	ff 73 24	 push	 DWORD PTR [ebx+36]
  00250	ff 73 28	 push	 DWORD PTR [ebx+40]
  00253	e8 00 00 00 00	 call	 _memcpy
  00258	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@IoThreadPr:

; 433  : 
; 434  : 				ReleaseFragmentBuffer (queue, request->Data);

  0025b	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  0025e	8b c6		 mov	 eax, esi
  00260	e8 00 00 00 00	 call	 _ReleaseFragmentBuffer@8

; 435  : 				request->Data = request->OrigDataBufferFragment;

  00265	8b 43 28	 mov	 eax, DWORD PTR [ebx+40]
  00268	89 43 24	 mov	 DWORD PTR [ebx+36], eax

; 436  : 
; 437  : 				if (request->CompleteOriginalIrp
; 438  : 					&& queue->LastReadLength > 0
; 439  : 					&& NT_SUCCESS (request->Item->Status)
; 440  : 					&& InterlockedExchangeAdd (&queue->IoThreadPendingRequestCount, 0) == 0)

  0026b	39 7b 04	 cmp	 DWORD PTR [ebx+4], edi
  0026e	74 2f		 je	 SHORT $LN54@IoThreadPr
  00270	39 be 20 01 00
	00		 cmp	 DWORD PTR [esi+288], edi
  00276	76 27		 jbe	 SHORT $LN54@IoThreadPr
  00278	8b 03		 mov	 eax, DWORD PTR [ebx]
  0027a	39 78 18	 cmp	 DWORD PTR [eax+24], edi
  0027d	7c 20		 jl	 SHORT $LN54@IoThreadPr
  0027f	33 c9		 xor	 ecx, ecx
  00281	8d 86 54 01 00
	00		 lea	 eax, DWORD PTR [esi+340]
  00287	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  0028b	85 c9		 test	 ecx, ecx
  0028d	75 10		 jne	 SHORT $LN54@IoThreadPr

; 441  : 				{
; 442  : 					readAhead = TRUE;

  0028f	33 c0		 xor	 eax, eax
  00291	40		 inc	 eax
  00292	89 45 f4	 mov	 DWORD PTR _readAhead$27974[ebp], eax

; 443  : 					InterlockedIncrement (&queue->OutstandingIoCount);

  00295	8d 8e 40 01 00
	00		 lea	 ecx, DWORD PTR [esi+320]
  0029b	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
$LN54@IoThreadPr:

; 444  : 				}
; 445  : 
; 446  : 				ExInterlockedInsertTailList (&queue->CompletionThreadQueue, &request->CompletionListEntry, &queue->CompletionThreadQueueLock);

  0029f	8d 86 d4 00 00
	00		 lea	 eax, DWORD PTR [esi+212]
  002a5	50		 push	 eax
  002a6	8d 53 34	 lea	 edx, DWORD PTR [ebx+52]
  002a9	8d 8e cc 00 00
	00		 lea	 ecx, DWORD PTR [esi+204]
  002af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExfInterlockedInsertTailList@12

; 447  : 				KeSetEvent (&queue->CompletionThreadQueueNotEmptyEvent, IO_DISK_INCREMENT, FALSE);

  002b5	57		 push	 edi
  002b6	6a 01		 push	 1
  002b8	8d 86 d8 00 00
	00		 lea	 eax, DWORD PTR [esi+216]
  002be	50		 push	 eax
  002bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 448  : 
; 449  : 				if (readAhead)

  002c5	39 7d f4	 cmp	 DWORD PTR _readAhead$27974[ebp], edi
  002c8	0f 84 a3 00 00
	00		 je	 $LN4@IoThreadPr

; 450  : 				{
; 451  : 					queue->ReadAheadBufferValid = FALSE;
; 452  : 					queue->ReadAheadOffset.QuadPart = queue->LastReadOffset.QuadPart + queue->LastReadLength;

  002ce	8b 96 20 01 00
	00		 mov	 edx, DWORD PTR [esi+288]
  002d4	8b 9e 18 01 00
	00		 mov	 ebx, DWORD PTR [esi+280]
  002da	33 c9		 xor	 ecx, ecx
  002dc	03 da		 add	 ebx, edx
  002de	8b 96 1c 01 00
	00		 mov	 edx, DWORD PTR [esi+284]
  002e4	13 d1		 adc	 edx, ecx
  002e6	8d 86 28 01 00
	00		 lea	 eax, DWORD PTR [esi+296]
  002ec	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 453  : 					queue->ReadAheadLength = queue->LastReadLength;

  002ef	8b 96 20 01 00
	00		 mov	 edx, DWORD PTR [esi+288]
  002f5	89 18		 mov	 DWORD PTR [eax], ebx

; 454  : 
; 455  : 					if (queue->ReadAheadOffset.QuadPart + queue->ReadAheadLength <= queue->MaxReadAheadOffset.QuadPart)

  002f7	8b da		 mov	 ebx, edx
  002f9	03 18		 add	 ebx, DWORD PTR [eax]
  002fb	89 be 10 01 00
	00		 mov	 DWORD PTR [esi+272], edi
  00301	13 48 04	 adc	 ecx, DWORD PTR [eax+4]
  00304	89 96 30 01 00
	00		 mov	 DWORD PTR [esi+304], edx
  0030a	3b 8e 3c 01 00
	00		 cmp	 ecx, DWORD PTR [esi+316]
  00310	7f 58		 jg	 SHORT $LN1@IoThreadPr
  00312	7c 08		 jl	 SHORT $LN52@IoThreadPr
  00314	3b 9e 38 01 00
	00		 cmp	 ebx, DWORD PTR [esi+312]
  0031a	77 4e		 ja	 SHORT $LN1@IoThreadPr
$LN52@IoThreadPr:

; 456  : 					{
; 457  : #ifdef TC_TRACE_IO_QUEUE
; 458  : 						Dump ("A   %I64d [%I64d] roff=%I64d rlen=%d\n", request->Item->OriginalIrpOffset.QuadPart, GetElapsedTime (&queue->LastPerformanceCounter), queue->ReadAheadOffset, queue->ReadAheadLength);
; 459  : #endif
; 460  : 						if (queue->IsFilterDevice)

  0031c	39 7e 3c	 cmp	 DWORD PTR [esi+60], edi
  0031f	74 1a		 je	 SHORT $LN2@IoThreadPr

; 461  : 						{
; 462  : 							queue->ReadAheadBufferValid = NT_SUCCESS (TCReadDevice (queue->LowerDeviceObject, queue->ReadAheadBuffer, queue->ReadAheadOffset, queue->ReadAheadLength));

  00321	52		 push	 edx
  00322	ff 70 04	 push	 DWORD PTR [eax+4]
  00325	ff 30		 push	 DWORD PTR [eax]
  00327	ff b6 34 01 00
	00		 push	 DWORD PTR [esi+308]
  0032d	ff 76 40	 push	 DWORD PTR [esi+64]
  00330	e8 00 00 00 00	 call	 _TCReadDevice@20
  00335	33 c9		 xor	 ecx, ecx
  00337	85 c0		 test	 eax, eax

; 463  : 						}
; 464  : 						else

  00339	eb 26		 jmp	 SHORT $LN63@IoThreadPr
$LN2@IoThreadPr:

; 465  : 						{
; 466  : 							IO_STATUS_BLOCK ioStatus;
; 467  : 							queue->ReadAheadBufferValid = NT_SUCCESS (ZwReadFile (queue->HostFileHandle, NULL, NULL, NULL, &ioStatus, queue->ReadAheadBuffer, queue->ReadAheadLength, &queue->ReadAheadOffset, NULL));

  0033b	57		 push	 edi
  0033c	50		 push	 eax
  0033d	52		 push	 edx
  0033e	ff b6 34 01 00
	00		 push	 DWORD PTR [esi+308]
  00344	8d 45 e4	 lea	 eax, DWORD PTR _ioStatus$27984[ebp]
  00347	50		 push	 eax
  00348	57		 push	 edi
  00349	57		 push	 edi
  0034a	57		 push	 edi
  0034b	ff 76 2c	 push	 DWORD PTR [esi+44]
  0034e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwReadFile@36
  00354	33 c9		 xor	 ecx, ecx
  00356	85 c0		 test	 eax, eax

; 468  : 							queue->ReadAheadLength = (ULONG) ioStatus.Information;

  00358	8b 45 e8	 mov	 eax, DWORD PTR _ioStatus$27984[ebp+4]
  0035b	89 86 30 01 00
	00		 mov	 DWORD PTR [esi+304], eax
$LN63@IoThreadPr:
  00361	0f 9d c1	 setge	 cl
  00364	89 8e 10 01 00
	00		 mov	 DWORD PTR [esi+272], ecx
$LN1@IoThreadPr:

; 469  : 						}
; 470  : 					}
; 471  : 
; 472  : 					DecrementOutstandingIoCount (queue);

  0036a	8b c6		 mov	 eax, esi
  0036c	e8 00 00 00 00	 call	 _DecrementOutstandingIoCount@4
$LN4@IoThreadPr:
  00371	8d 96 b4 00 00
	00		 lea	 edx, DWORD PTR [esi+180]
  00377	8d 8e ac 00 00
	00		 lea	 ecx, DWORD PTR [esi+172]
  0037d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExfInterlockedRemoveHeadList@8
  00383	3b c7		 cmp	 eax, edi
  00385	0f 85 e2 fc ff
	ff		 jne	 $LL36@IoThreadPr
$LN35@IoThreadPr:

; 312  : 		ASSERT (NT_SUCCESS (status));
; 313  : 	}
; 314  : 
; 315  : 	while (!queue->ThreadExitRequested)

  0038b	8b 86 7c 01 00
	00		 mov	 eax, DWORD PTR [esi+380]
  00391	85 c0		 test	 eax, eax
  00393	0f 84 a8 fc ff
	ff		 je	 $LL40@IoThreadPr
$LN57@IoThreadPr:
  00399	5b		 pop	 ebx
$LN50@IoThreadPr:

; 473  : 				}
; 474  : 			}
; 475  : 		}
; 476  : 	}
; 477  : 
; 478  : 	PsTerminateSystemThread (STATUS_SUCCESS);

  0039a	57		 push	 edi
  0039b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsTerminateSystemThread@4
  003a1	5f		 pop	 edi
  003a2	5e		 pop	 esi

; 479  : }

  003a3	c9		 leave
  003a4	c2 04 00	 ret	 4
_IoThreadProc@4 ENDP
_TEXT	ENDS
EXTRN	_EncryptDataUnits@16:PROC
EXTRN	_GetBootDriveLength@0:PROC
EXTRN	_IsHiddenSystemRunning@0:PROC
EXTRN	_RegionsOverlap@32:PROC
EXTRN	_GetIntersection@36:PROC
EXTRN	__imp__MmMapLockedPagesSpecifyCache@24:PROC
; Function compile flags: /Ogsp
;	COMDAT _MainThreadProc@4
_TEXT	SEGMENT
_dataUnit$28056 = -68					; size = 8
_intersectStart$ = -60					; size = 8
tv695 = -52						; size = 8
_alignedOffset$28049 = -44				; size = 8
_dataUnit$28103 = -36					; size = 8
_fragmentOffset$ = -28					; size = 8
_dataRemaining$ = -20					; size = 4
_isLastFragment$28093 = -16				; size = 4
_intersectLength$ = -12					; size = 4
tv818 = -8						; size = 4
_dataFragmentLength$28094 = -8				; size = 4
_buffer$28047 = -8					; size = 4
_activeFragmentBuffer$ = -4				; size = 4
_dataBuffer$ = 8					; size = 4
_irp$28017 = 8						; size = 4
_threadArg$ = 8						; size = 4
_MainThreadProc@4 PROC					; COMDAT

; 483  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 44	 sub	 esp, 68			; 00000044H
  00008	53		 push	 ebx

; 484  : 	EncryptedIoQueue *queue = (EncryptedIoQueue *) threadArg;
; 485  : 	PLIST_ENTRY listEntry;
; 486  : 	EncryptedIoQueueItem *item;
; 487  : 
; 488  : 	LARGE_INTEGER fragmentOffset;
; 489  : 	ULONG dataRemaining;
; 490  : 	PUCHAR activeFragmentBuffer = queue->FragmentBufferA;

  00009	8b 5d 08	 mov	 ebx, DWORD PTR _threadArg$[ebp]
  0000c	8b 83 e8 00 00
	00		 mov	 eax, DWORD PTR [ebx+232]
  00012	56		 push	 esi
  00013	89 45 fc	 mov	 DWORD PTR _activeFragmentBuffer$[ebp], eax

; 491  : 	PUCHAR dataBuffer;
; 492  : 	EncryptedIoRequest *request;
; 493  : 	uint64 intersectStart;
; 494  : 	uint32 intersectLength;
; 495  : 
; 496  : 	if (IsEncryptionThreadPoolRunning())

  00016	e8 00 00 00 00	 call	 _IsEncryptionThreadPoolRunning@0
  0001b	85 c0		 test	 eax, eax
  0001d	74 0f		 je	 SHORT $LN80@MainThread

; 497  : 		KeSetPriorityThread (KeGetCurrentThread(), LOW_REALTIME_PRIORITY);

  0001f	6a 10		 push	 16			; 00000010H
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeGetCurrentThread@0
  00027	50		 push	 eax
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetPriorityThread@8
$LN80@MainThread:

; 498  : 
; 499  : 	while (!queue->ThreadExitRequested)

  0002e	8b 83 7c 01 00
	00		 mov	 eax, DWORD PTR [ebx+380]
  00034	33 f6		 xor	 esi, esi
  00036	85 c0		 test	 eax, eax
  00038	0f 85 55 03 00
	00		 jne	 $LN44@MainThread
  0003e	57		 push	 edi
$LL45@MainThread:

; 500  : 	{
; 501  : 		if (!NT_SUCCESS (KeWaitForSingleObject (&queue->MainThreadQueueNotEmptyEvent, Executive, KernelMode, FALSE, NULL)))

  0003f	56		 push	 esi
  00040	56		 push	 esi
  00041	56		 push	 esi
  00042	56		 push	 esi
  00043	8d 83 98 00 00
	00		 lea	 eax, DWORD PTR [ebx+152]
  00049	50		 push	 eax
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
  00050	85 c0		 test	 eax, eax
  00052	0f 8c 2c 03 00
	00		 jl	 $LN41@MainThread

; 502  : 			continue;
; 503  : 
; 504  : 		while ((listEntry = ExInterlockedRemoveHeadList (&queue->MainThreadQueue, &queue->MainThreadQueueLock)))

  00058	8d 93 94 00 00
	00		 lea	 edx, DWORD PTR [ebx+148]
  0005e	8d 8b 8c 00 00
	00		 lea	 ecx, DWORD PTR [ebx+140]
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExfInterlockedRemoveHeadList@8
  0006a	3b c6		 cmp	 eax, esi
  0006c	0f 84 12 03 00
	00		 je	 $LN41@MainThread
$LL42@MainThread:

; 505  : 		{
; 506  : 			PIRP irp = CONTAINING_RECORD (listEntry, IRP, Tail.Overlay.ListEntry);
; 507  : 			PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (irp);

  00072	8b 78 08	 mov	 edi, DWORD PTR [eax+8]
  00075	83 c0 a8	 add	 eax, -88		; ffffffa8H
  00078	89 45 08	 mov	 DWORD PTR _irp$28017[ebp], eax

; 508  : 			
; 509  : 			if (queue->Suspended)

  0007b	8b 83 80 01 00
	00		 mov	 eax, DWORD PTR [ebx+384]
  00081	85 c0		 test	 eax, eax
  00083	74 11		 je	 SHORT $LN40@MainThread

; 510  : 				KeWaitForSingleObject (&queue->QueueResumedEvent, Executive, KernelMode, FALSE, NULL);

  00085	56		 push	 esi
  00086	56		 push	 esi
  00087	56		 push	 esi
  00088	56		 push	 esi
  00089	8d 83 8c 01 00
	00		 lea	 eax, DWORD PTR [ebx+396]
  0008f	50		 push	 eax
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
$LN40@MainThread:

; 511  : 
; 512  : 			item = GetPoolBuffer (queue, sizeof (EncryptedIoQueueItem));

  00096	6a 20		 push	 32			; 00000020H
  00098	53		 push	 ebx
  00099	e8 00 00 00 00	 call	 _GetPoolBuffer@8
  0009e	8b f0		 mov	 esi, eax

; 513  : 			item->Queue = queue;
; 514  : 			item->OriginalIrp = irp;

  000a0	8b 45 08	 mov	 eax, DWORD PTR _irp$28017[ebp]

; 515  : 			item->Status = STATUS_SUCCESS;

  000a3	83 66 18 00	 and	 DWORD PTR [esi+24], 0
  000a7	89 1e		 mov	 DWORD PTR [esi], ebx
  000a9	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 516  : 
; 517  : 			IoSetCancelRoutine (irp, NULL);

  000ac	33 c9		 xor	 ecx, ecx
  000ae	8d 50 38	 lea	 edx, DWORD PTR [eax+56]
  000b1	87 0a		 xchg	 DWORD PTR [edx], ecx

; 518  : 			if (irp->Cancel)

  000b3	80 78 24 00	 cmp	 BYTE PTR [eax+36], 0
  000b7	74 0a		 je	 SHORT $LN39@MainThread

; 519  : 			{
; 520  : 				CompleteOriginalIrp (item, STATUS_CANCELLED, 0);

  000b9	bf 20 01 00 c0	 mov	 edi, -1073741536	; c0000120H

; 521  : 				continue;

  000be	e9 9e 02 00 00	 jmp	 $LN98@MainThread
$LN39@MainThread:

; 522  : 			}
; 523  : 
; 524  : 			switch (irpSp->MajorFunction)

  000c3	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  000c6	83 e8 03	 sub	 eax, 3
  000c9	74 10		 je	 SHORT $LN36@MainThread
  000cb	48		 dec	 eax

; 537  : 
; 538  : 			default:
; 539  : 				CompleteOriginalIrp (item, STATUS_INVALID_PARAMETER, 0);
; 540  : 				continue;

  000cc	0f 85 8a 02 00
	00		 jne	 $LN26@MainThread

; 530  : 				break;
; 531  : 
; 532  : 			case IRP_MJ_WRITE:
; 533  : 				item->Write = TRUE;

  000d2	c7 46 08 01 00
	00 00		 mov	 DWORD PTR [esi+8], 1

; 534  : 				item->OriginalOffset = irpSp->Parameters.Write.ByteOffset;
; 535  : 				item->OriginalLength = irpSp->Parameters.Write.Length;
; 536  : 				break;

  000d9	eb 04		 jmp	 SHORT $LN99@MainThread
$LN36@MainThread:

; 525  : 			{
; 526  : 			case IRP_MJ_READ:
; 527  : 				item->Write = FALSE;

  000db	83 66 08 00	 and	 DWORD PTR [esi+8], 0
$LN99@MainThread:

; 528  : 				item->OriginalOffset = irpSp->Parameters.Read.ByteOffset;

  000df	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000e2	89 46 10	 mov	 DWORD PTR [esi+16], eax
  000e5	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  000e8	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 529  : 				item->OriginalLength = irpSp->Parameters.Read.Length;

  000eb	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000ee	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 541  : 			}
; 542  : 
; 543  : #ifdef TC_TRACE_IO_QUEUE
; 544  : 			item->OriginalIrpOffset = item->OriginalOffset;
; 545  : #endif
; 546  : 
; 547  : 			// Handle misaligned read operations to work around a bug in Windows System Assessment Tool which does not follow FILE_FLAG_NO_BUFFERING requirements when benchmarking disk devices
; 548  : 			if (queue->IsFilterDevice
; 549  : 				&& !item->Write
; 550  : 				&& item->OriginalLength > 0
; 551  : 				&& (item->OriginalLength & (ENCRYPTION_DATA_UNIT_SIZE - 1)) == 0
; 552  : 				&& (item->OriginalOffset.QuadPart & (ENCRYPTION_DATA_UNIT_SIZE - 1)) != 0)

  000f1	83 7b 3c 00	 cmp	 DWORD PTR [ebx+60], 0
  000f5	0f 84 60 01 00
	00		 je	 $LN90@MainThread
  000fb	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  000ff	0f 85 56 01 00
	00		 jne	 $LN90@MainThread
  00105	85 c0		 test	 eax, eax
  00107	0f 86 50 01 00
	00		 jbe	 $LN100@MainThread
  0010d	a9 ff 01 00 00	 test	 eax, 511		; 000001ffH
  00112	0f 85 43 01 00
	00		 jne	 $LN90@MainThread
  00118	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0011b	8b ca		 mov	 ecx, edx
  0011d	81 e1 ff 01 00
	00		 and	 ecx, 511		; 000001ffH
  00123	33 ff		 xor	 edi, edi
  00125	0b cf		 or	 ecx, edi
  00127	0f 84 2e 01 00
	00		 je	 $LN90@MainThread

; 553  : 			{
; 554  : 				byte *buffer;
; 555  : 				ULONG alignedLength = item->OriginalLength + ENCRYPTION_DATA_UNIT_SIZE;

  0012d	8d b8 00 02 00
	00		 lea	 edi, DWORD PTR [eax+512]

; 556  : 				LARGE_INTEGER alignedOffset;
; 557  : 				alignedOffset.QuadPart = item->OriginalOffset.QuadPart & ~((LONGLONG) ENCRYPTION_DATA_UNIT_SIZE - 1);

  00133	8b 46 14	 mov	 eax, DWORD PTR [esi+20]

; 558  : 
; 559  : 				buffer = TCalloc (alignedLength);

  00136	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0013b	57		 push	 edi
  0013c	81 e2 00 fe ff
	ff		 and	 edx, -512		; fffffe00H
  00142	6a 00		 push	 0
  00144	89 55 d4	 mov	 DWORD PTR _alignedOffset$28049[ebp], edx
  00147	89 45 d8	 mov	 DWORD PTR _alignedOffset$28049[ebp+4], eax
  0014a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00150	89 45 f8	 mov	 DWORD PTR _buffer$28047[ebp], eax

; 560  : 				if (!buffer)

  00153	85 c0		 test	 eax, eax
  00155	75 0a		 jne	 SHORT $LN32@MainThread
$LN110@MainThread:

; 561  : 				{
; 562  : 					CompleteOriginalIrp (item, STATUS_INSUFFICIENT_RESOURCES, 0);

  00157	bf 9a 00 00 c0	 mov	 edi, -1073741670	; c000009aH

; 563  : 					continue;

  0015c	e9 00 02 00 00	 jmp	 $LN98@MainThread
$LN32@MainThread:

; 564  : 				}
; 565  : 
; 566  : 				item->Status = TCReadDevice (queue->LowerDeviceObject, buffer, alignedOffset, alignedLength);

  00161	57		 push	 edi
  00162	ff 75 d8	 push	 DWORD PTR _alignedOffset$28049[ebp+4]
  00165	ff 75 d4	 push	 DWORD PTR _alignedOffset$28049[ebp]
  00168	ff 75 f8	 push	 DWORD PTR _buffer$28047[ebp]
  0016b	ff 73 40	 push	 DWORD PTR [ebx+64]
  0016e	e8 00 00 00 00	 call	 _TCReadDevice@20
  00173	89 46 18	 mov	 DWORD PTR [esi+24], eax

; 567  : 
; 568  : 				if (NT_SUCCESS (item->Status))

  00176	85 c0		 test	 eax, eax
  00178	0f 8c bb 00 00
	00		 jl	 $LN96@MainThread

; 569  : 				{
; 570  : 					UINT64_STRUCT dataUnit;
; 571  : 
; 572  : 					dataBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe (irp->MdlAddress, HighPagePriority);

  0017e	8b 45 08	 mov	 eax, DWORD PTR _irp$28017[ebp]
  00181	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00184	f6 40 06 05	 test	 BYTE PTR [eax+6], 5
  00188	74 05		 je	 SHORT $LN49@MainThread
  0018a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0018d	eb 10		 jmp	 SHORT $LN101@MainThread
$LN49@MainThread:
  0018f	6a 20		 push	 32			; 00000020H
  00191	33 c9		 xor	 ecx, ecx
  00193	51		 push	 ecx
  00194	51		 push	 ecx
  00195	6a 01		 push	 1
  00197	51		 push	 ecx
  00198	50		 push	 eax
  00199	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmMapLockedPagesSpecifyCache@24
$LN101@MainThread:
  0019f	89 45 08	 mov	 DWORD PTR _dataBuffer$[ebp], eax

; 573  : 					if (!dataBuffer)

  001a2	85 c0		 test	 eax, eax
  001a4	75 10		 jne	 SHORT $LN30@MainThread

; 574  : 					{
; 575  : 						TCfree (buffer);

  001a6	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  001ab	ff 75 f8	 push	 DWORD PTR _buffer$28047[ebp]
  001ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 576  : 						CompleteOriginalIrp (item, STATUS_INSUFFICIENT_RESOURCES, 0);
; 577  : 						continue;

  001b4	eb a1		 jmp	 SHORT $LN110@MainThread
$LN30@MainThread:

; 578  : 					}
; 579  : 
; 580  : 					if (queue->EncryptedAreaStart != -1 && queue->EncryptedAreaEnd != -1)

  001b6	8b 43 48	 mov	 eax, DWORD PTR [ebx+72]
  001b9	23 43 4c	 and	 eax, DWORD PTR [ebx+76]
  001bc	83 f8 ff	 cmp	 eax, -1
  001bf	74 5e		 je	 SHORT $LN28@MainThread
  001c1	8b 43 50	 mov	 eax, DWORD PTR [ebx+80]
  001c4	23 43 54	 and	 eax, DWORD PTR [ebx+84]
  001c7	83 f8 ff	 cmp	 eax, -1
  001ca	74 53		 je	 SHORT $LN28@MainThread

; 581  : 					{
; 582  : 						GetIntersection (alignedOffset.QuadPart, alignedLength, queue->EncryptedAreaStart, queue->EncryptedAreaEnd, &intersectStart, &intersectLength);

  001cc	8d 45 f4	 lea	 eax, DWORD PTR _intersectLength$[ebp]
  001cf	50		 push	 eax
  001d0	8d 45 c4	 lea	 eax, DWORD PTR _intersectStart$[ebp]
  001d3	50		 push	 eax
  001d4	ff 73 54	 push	 DWORD PTR [ebx+84]
  001d7	ff 73 50	 push	 DWORD PTR [ebx+80]
  001da	ff 73 4c	 push	 DWORD PTR [ebx+76]
  001dd	ff 73 48	 push	 DWORD PTR [ebx+72]
  001e0	57		 push	 edi
  001e1	ff 75 d8	 push	 DWORD PTR _alignedOffset$28049[ebp+4]
  001e4	ff 75 d4	 push	 DWORD PTR _alignedOffset$28049[ebp]
  001e7	e8 00 00 00 00	 call	 _GetIntersection@36

; 583  : 						if (intersectLength > 0)

  001ec	8b 4d f4	 mov	 ecx, DWORD PTR _intersectLength$[ebp]
  001ef	85 c9		 test	 ecx, ecx
  001f1	76 2c		 jbe	 SHORT $LN28@MainThread

; 584  : 						{
; 585  : 							dataUnit.Value = intersectStart / ENCRYPTION_DATA_UNIT_SIZE;

  001f3	8b 45 c4	 mov	 eax, DWORD PTR _intersectStart$[ebp]

; 586  : 							DecryptDataUnits (buffer + (intersectStart - alignedOffset.QuadPart), &dataUnit, intersectLength / ENCRYPTION_DATA_UNIT_SIZE, queue->CryptoInfo);

  001f6	ff 73 28	 push	 DWORD PTR [ebx+40]
  001f9	8b 7d c8	 mov	 edi, DWORD PTR _intersectStart$[ebp+4]
  001fc	8b d0		 mov	 edx, eax
  001fe	2b 45 d4	 sub	 eax, DWORD PTR _alignedOffset$28049[ebp]
  00201	c1 e9 09	 shr	 ecx, 9
  00204	03 45 f8	 add	 eax, DWORD PTR _buffer$28047[ebp]
  00207	0f ac fa 09	 shrd	 edx, edi, 9
  0020b	51		 push	 ecx
  0020c	8d 4d bc	 lea	 ecx, DWORD PTR _dataUnit$28056[ebp]
  0020f	51		 push	 ecx
  00210	c1 ef 09	 shr	 edi, 9
  00213	50		 push	 eax
  00214	89 55 bc	 mov	 DWORD PTR _dataUnit$28056[ebp], edx
  00217	89 7d c0	 mov	 DWORD PTR _dataUnit$28056[ebp+4], edi
  0021a	e8 00 00 00 00	 call	 _DecryptDataUnits@16
$LN28@MainThread:

; 587  : 						}
; 588  : 					}
; 589  : 
; 590  : 					memcpy (dataBuffer, buffer + (item->OriginalOffset.LowPart & (ENCRYPTION_DATA_UNIT_SIZE - 1)), item->OriginalLength);

  0021f	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00222	ff 76 0c	 push	 DWORD PTR [esi+12]
  00225	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  0022a	03 45 f8	 add	 eax, DWORD PTR _buffer$28047[ebp]
  0022d	50		 push	 eax
  0022e	ff 75 08	 push	 DWORD PTR _dataBuffer$[ebp]
  00231	e8 00 00 00 00	 call	 _memcpy
  00236	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN96@MainThread:

; 591  : 				}
; 592  : 
; 593  : 				TCfree (buffer);

  00239	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0023e	ff 75 f8	 push	 DWORD PTR _buffer$28047[ebp]
  00241	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 594  : 				CompleteOriginalIrp (item, item->Status, NT_SUCCESS (item->Status) ? item->OriginalLength : 0);

  00247	8b 7e 18	 mov	 edi, DWORD PTR [esi+24]
  0024a	85 ff		 test	 edi, edi
  0024c	7c 05		 jl	 SHORT $LN51@MainThread
  0024e	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00251	eb 02		 jmp	 SHORT $LN52@MainThread
$LN51@MainThread:
  00253	33 c0		 xor	 eax, eax
$LN52@MainThread:
  00255	50		 push	 eax

; 595  : 				continue;

  00256	e9 08 01 00 00	 jmp	 $LN102@MainThread
$LN90@MainThread:

; 596  : 			}
; 597  : 
; 598  : 			// Validate offset and length
; 599  : 			if (item->OriginalLength == 0
; 600  : 				|| (item->OriginalLength & (ENCRYPTION_DATA_UNIT_SIZE - 1)) != 0
; 601  : 				|| (item->OriginalOffset.QuadPart & (ENCRYPTION_DATA_UNIT_SIZE - 1)) != 0
; 602  : 				|| (!queue->IsFilterDevice && item->OriginalOffset.QuadPart + item->OriginalLength > queue->VirtualDeviceLength))

  0025b	85 c0		 test	 eax, eax
$LN100@MainThread:
  0025d	0f 84 f9 00 00
	00		 je	 $LN26@MainThread
  00263	bf ff 01 00 00	 mov	 edi, 511		; 000001ffH
  00268	85 c7		 test	 eax, edi
  0026a	0f 85 ec 00 00
	00		 jne	 $LN26@MainThread
  00270	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00273	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00276	23 cf		 and	 ecx, edi
  00278	33 ff		 xor	 edi, edi
  0027a	0b cf		 or	 ecx, edi
  0027c	0f 85 da 00 00
	00		 jne	 $LN26@MainThread
  00282	39 7b 3c	 cmp	 DWORD PTR [ebx+60], edi
  00285	0f 85 15 01 00
	00		 jne	 $LN25@MainThread
  0028b	8b f8		 mov	 edi, eax
  0028d	03 7e 10	 add	 edi, DWORD PTR [esi+16]
  00290	13 ca		 adc	 ecx, edx
  00292	3b 4b 34	 cmp	 ecx, DWORD PTR [ebx+52]
  00295	0f 8f c1 00 00
	00		 jg	 $LN26@MainThread
  0029b	7c 09		 jl	 SHORT $LN93@MainThread
  0029d	3b 7b 30	 cmp	 edi, DWORD PTR [ebx+48]
  002a0	0f 87 b6 00 00
	00		 ja	 $LN26@MainThread
$LN93@MainThread:
  002a6	33 ff		 xor	 edi, edi

; 605  : 				continue;
; 606  : 			}
; 607  : 
; 608  : #ifdef TC_TRACE_IO_QUEUE
; 609  : 			Dump ("Q  %I64d [%I64d] %c len=%d\n", item->OriginalOffset.QuadPart, GetElapsedTime (&queue->LastPerformanceCounter), item->Write ? 'W' : 'R', item->OriginalLength);
; 610  : #endif
; 611  : 
; 612  : 			if (!queue->IsFilterDevice)

  002a8	39 7b 3c	 cmp	 DWORD PTR [ebx+60], edi
  002ab	0f 85 ef 00 00
	00		 jne	 $LN25@MainThread

; 613  : 			{
; 614  : 				// Adjust the offset for host file or device
; 615  : 				if (queue->CryptoInfo->hiddenVolume)

  002b1	8b 43 28	 mov	 eax, DWORD PTR [ebx+40]
  002b4	39 b8 a0 29 00
	00		 cmp	 DWORD PTR [eax+10656], edi
  002ba	74 0e		 je	 SHORT $LN24@MainThread

; 616  : 					item->OriginalOffset.QuadPart += queue->CryptoInfo->hiddenVolumeOffset;

  002bc	8b 88 18 44 00
	00		 mov	 ecx, DWORD PTR [eax+17432]
  002c2	8b 80 1c 44 00
	00		 mov	 eax, DWORD PTR [eax+17436]

; 617  : 				else

  002c8	eb 0c		 jmp	 SHORT $LN104@MainThread
$LN24@MainThread:

; 618  : 					item->OriginalOffset.QuadPart += queue->CryptoInfo->volDataAreaOffset; 

  002ca	8b 88 08 44 00
	00		 mov	 ecx, DWORD PTR [eax+17416]
  002d0	8b 80 0c 44 00
	00		 mov	 eax, DWORD PTR [eax+17420]
$LN104@MainThread:
  002d6	03 4e 10	 add	 ecx, DWORD PTR [esi+16]
  002d9	13 c2		 adc	 eax, edx

; 619  : 
; 620  : 				// Hidden volume protection
; 621  : 				if (item->Write && queue->CryptoInfo->bProtectHiddenVolume)

  002db	33 ff		 xor	 edi, edi
  002dd	89 46 14	 mov	 DWORD PTR [esi+20], eax
  002e0	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  002e3	39 7e 08	 cmp	 DWORD PTR [esi+8], edi
  002e6	0f 84 6f 01 00
	00		 je	 $LN16@MainThread
  002ec	8b 43 28	 mov	 eax, DWORD PTR [ebx+40]
  002ef	39 b8 00 44 00
	00		 cmp	 DWORD PTR [eax+17408], edi
  002f5	0f 84 60 01 00
	00		 je	 $LN16@MainThread

; 622  : 				{
; 623  : 					// If there has already been a write operation denied in order to protect the
; 624  : 					// hidden volume (since the volume mount time)
; 625  : 					if (queue->CryptoInfo->bHiddenVolProtectionAction)	

  002fb	39 b8 04 44 00
	00		 cmp	 DWORD PTR [eax+17412], edi

; 626  : 					{
; 627  : 						// Do not allow writing to this volume anymore. This is to fake a complete volume
; 628  : 						// or system failure (otherwise certain kinds of inconsistency within the file
; 629  : 						// system could indicate that this volume has used hidden volume protection).
; 630  : 						CompleteOriginalIrp (item, STATUS_INVALID_PARAMETER, 0);
; 631  : 						continue;

  00301	75 59		 jne	 SHORT $LN26@MainThread

; 632  : 					}
; 633  : 
; 634  : 					// Verify that no byte is going to be written to the hidden volume area
; 635  : 					if (RegionsOverlap ((unsigned __int64) item->OriginalOffset.QuadPart,
; 636  : 						(unsigned __int64) item->OriginalOffset.QuadPart + item->OriginalLength - 1,
; 637  : 						queue->CryptoInfo->hiddenVolumeOffset,
; 638  : 						(unsigned __int64) queue->CryptoInfo->hiddenVolumeOffset + queue->CryptoInfo->hiddenVolumeProtectedSize - 1))

  00303	8b 88 18 44 00
	00		 mov	 ecx, DWORD PTR [eax+17432]
  00309	8b 90 1c 44 00
	00		 mov	 edx, DWORD PTR [eax+17436]
  0030f	8b b8 20 44 00
	00		 mov	 edi, DWORD PTR [eax+17440]
  00315	8b 80 24 44 00
	00		 mov	 eax, DWORD PTR [eax+17444]
  0031b	03 f9		 add	 edi, ecx
  0031d	13 c2		 adc	 eax, edx
  0031f	83 c7 ff	 add	 edi, -1
  00322	83 d0 ff	 adc	 eax, -1
  00325	50		 push	 eax
  00326	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00329	57		 push	 edi
  0032a	52		 push	 edx
  0032b	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0032e	51		 push	 ecx
  0032f	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00332	33 ff		 xor	 edi, edi
  00334	03 d0		 add	 edx, eax
  00336	13 f9		 adc	 edi, ecx
  00338	83 c2 ff	 add	 edx, -1
  0033b	83 d7 ff	 adc	 edi, -1
  0033e	57		 push	 edi
  0033f	52		 push	 edx
  00340	51		 push	 ecx
  00341	50		 push	 eax
  00342	e8 00 00 00 00	 call	 _RegionsOverlap@32
  00347	85 c0		 test	 eax, eax
  00349	0f 84 0a 01 00
	00		 je	 $LN95@MainThread

; 639  : 					{
; 640  : 						Dump ("Hidden volume protection triggered: write %I64d-%I64d (protected %I64d-%I64d)\n", item->OriginalOffset.QuadPart, item->OriginalOffset.QuadPart + item->OriginalLength - 1, queue->CryptoInfo->hiddenVolumeOffset, queue->CryptoInfo->hiddenVolumeOffset + queue->CryptoInfo->hiddenVolumeProtectedSize - 1);
; 641  : 						queue->CryptoInfo->bHiddenVolProtectionAction = TRUE;

  0034f	8b 43 28	 mov	 eax, DWORD PTR [ebx+40]
  00352	c7 80 04 44 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+17412], 1
$LN26@MainThread:

; 603  : 			{
; 604  : 				CompleteOriginalIrp (item, STATUS_INVALID_PARAMETER, 0);

  0035c	bf 0d 00 00 c0	 mov	 edi, -1073741811	; c000000dH
$LN98@MainThread:
  00361	6a 00		 push	 0
$LN102@MainThread:
  00363	e8 00 00 00 00	 call	 _CompleteOriginalIrp@12
$LN89@MainThread:

; 502  : 			continue;
; 503  : 
; 504  : 		while ((listEntry = ExInterlockedRemoveHeadList (&queue->MainThreadQueue, &queue->MainThreadQueueLock)))

  00368	8d 93 94 00 00
	00		 lea	 edx, DWORD PTR [ebx+148]
  0036e	8d 8b 8c 00 00
	00		 lea	 ecx, DWORD PTR [ebx+140]
  00374	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExfInterlockedRemoveHeadList@8
  0037a	33 f6		 xor	 esi, esi
  0037c	85 c0		 test	 eax, eax
  0037e	0f 85 ee fc ff
	ff		 jne	 $LL42@MainThread
$LN41@MainThread:

; 498  : 
; 499  : 	while (!queue->ThreadExitRequested)

  00384	8b 83 7c 01 00
	00		 mov	 eax, DWORD PTR [ebx+380]
  0038a	85 c0		 test	 eax, eax
  0038c	0f 84 ad fc ff
	ff		 je	 $LL45@MainThread
  00392	5f		 pop	 edi
$LN44@MainThread:

; 753  : 	}
; 754  : 
; 755  : 	PsTerminateSystemThread (STATUS_SUCCESS);

  00393	56		 push	 esi
  00394	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsTerminateSystemThread@4
  0039a	5e		 pop	 esi
  0039b	5b		 pop	 ebx

; 756  : }

  0039c	c9		 leave
  0039d	c2 04 00	 ret	 4
$LN25@MainThread:

; 642  : 
; 643  : 						// Deny this write operation to prevent the hidden volume from being overwritten
; 644  : 						CompleteOriginalIrp (item, STATUS_INVALID_PARAMETER, 0);
; 645  : 						continue;
; 646  : 					}
; 647  : 				}
; 648  : 			}
; 649  : 			else if (item->Write
; 650  : 				&& RegionsOverlap (item->OriginalOffset.QuadPart, item->OriginalOffset.QuadPart + item->OriginalLength - 1, TC_BOOT_VOLUME_HEADER_SECTOR_OFFSET, TC_BOOT_VOLUME_HEADER_SECTOR_OFFSET + TC_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE - 1))

  003a0	39 7e 08	 cmp	 DWORD PTR [esi+8], edi
  003a3	0f 84 b2 00 00
	00		 je	 $LN16@MainThread
  003a9	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  003ac	57		 push	 edi
  003ad	68 ff 7d 00 00	 push	 32255			; 00007dffH
  003b2	57		 push	 edi
  003b3	33 ff		 xor	 edi, edi
  003b5	03 c1		 add	 eax, ecx
  003b7	13 fa		 adc	 edi, edx
  003b9	68 00 7c 00 00	 push	 31744			; 00007c00H
  003be	83 c0 ff	 add	 eax, -1
  003c1	83 d7 ff	 adc	 edi, -1
  003c4	57		 push	 edi
  003c5	50		 push	 eax
  003c6	52		 push	 edx
  003c7	51		 push	 ecx
  003c8	e8 00 00 00 00	 call	 _RegionsOverlap@32
  003cd	85 c0		 test	 eax, eax
  003cf	74 07		 je	 SHORT $LN94@MainThread
$LN15@MainThread:

; 651  : 			{
; 652  : 				// Prevent inappropriately designed software from damaging important data that may be out of sync with the backup on the Rescue Disk (such as the end of the encrypted area).
; 653  : 				Dump ("Preventing write to the system encryption key data area\n");
; 654  : 				CompleteOriginalIrp (item, STATUS_MEDIA_WRITE_PROTECTED, 0);

  003d1	bf a2 00 00 c0	 mov	 edi, -1073741662	; c00000a2H

; 655  : 				continue;

  003d6	eb 89		 jmp	 SHORT $LN98@MainThread
$LN94@MainThread:
  003d8	33 ff		 xor	 edi, edi

; 656  : 			}
; 657  : 			else if (item->Write && IsHiddenSystemRunning()
; 658  : 				&& (RegionsOverlap (item->OriginalOffset.QuadPart, item->OriginalOffset.QuadPart + item->OriginalLength - 1, TC_SECTOR_SIZE_BIOS, TC_BOOT_LOADER_AREA_SECTOR_COUNT * TC_SECTOR_SIZE_BIOS - 1)
; 659  : 				 || RegionsOverlap (item->OriginalOffset.QuadPart, item->OriginalOffset.QuadPart + item->OriginalLength - 1, GetBootDriveLength(), _I64_MAX)))

  003da	39 7e 08	 cmp	 DWORD PTR [esi+8], edi
  003dd	74 7c		 je	 SHORT $LN16@MainThread
  003df	e8 00 00 00 00	 call	 _IsHiddenSystemRunning@0
  003e4	85 c0		 test	 eax, eax
  003e6	74 73		 je	 SHORT $LN16@MainThread
  003e8	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  003eb	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  003ee	57		 push	 edi
  003ef	33 d2		 xor	 edx, edx
  003f1	68 ff 7d 00 00	 push	 32255			; 00007dffH
  003f6	03 c8		 add	 ecx, eax
  003f8	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  003fb	57		 push	 edi
  003fc	13 d0		 adc	 edx, eax
  003fe	68 00 02 00 00	 push	 512			; 00000200H
  00403	83 c1 ff	 add	 ecx, -1
  00406	83 d2 ff	 adc	 edx, -1
  00409	52		 push	 edx
  0040a	51		 push	 ecx
  0040b	50		 push	 eax
  0040c	ff 76 10	 push	 DWORD PTR [esi+16]
  0040f	e8 00 00 00 00	 call	 _RegionsOverlap@32
  00414	85 c0		 test	 eax, eax
  00416	75 b9		 jne	 SHORT $LN15@MainThread
  00418	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0041b	89 45 cc	 mov	 DWORD PTR tv695[ebp], eax
  0041e	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00421	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  00426	6a ff		 push	 -1
  00428	89 45 d0	 mov	 DWORD PTR tv695[ebp+4], eax
  0042b	e8 00 00 00 00	 call	 _GetBootDriveLength@0
  00430	52		 push	 edx
  00431	50		 push	 eax
  00432	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00435	33 c9		 xor	 ecx, ecx
  00437	03 45 cc	 add	 eax, DWORD PTR tv695[ebp]
  0043a	13 4d d0	 adc	 ecx, DWORD PTR tv695[ebp+4]
  0043d	83 c0 ff	 add	 eax, -1
  00440	83 d1 ff	 adc	 ecx, -1
  00443	51		 push	 ecx
  00444	50		 push	 eax
  00445	ff 75 d0	 push	 DWORD PTR tv695[ebp+4]
  00448	ff 75 cc	 push	 DWORD PTR tv695[ebp]
  0044b	e8 00 00 00 00	 call	 _RegionsOverlap@32
  00450	85 c0		 test	 eax, eax
  00452	74 07		 je	 SHORT $LN16@MainThread

; 660  : 			{
; 661  : 				Dump ("Preventing write to boot loader or host protected area\n");
; 662  : 				CompleteOriginalIrp (item, STATUS_MEDIA_WRITE_PROTECTED, 0);
; 663  : 				continue;

  00454	e9 78 ff ff ff	 jmp	 $LN15@MainThread
$LN95@MainThread:

; 656  : 			}
; 657  : 			else if (item->Write && IsHiddenSystemRunning()
; 658  : 				&& (RegionsOverlap (item->OriginalOffset.QuadPart, item->OriginalOffset.QuadPart + item->OriginalLength - 1, TC_SECTOR_SIZE_BIOS, TC_BOOT_LOADER_AREA_SECTOR_COUNT * TC_SECTOR_SIZE_BIOS - 1)
; 659  : 				 || RegionsOverlap (item->OriginalOffset.QuadPart, item->OriginalOffset.QuadPart + item->OriginalLength - 1, GetBootDriveLength(), _I64_MAX)))

  00459	33 ff		 xor	 edi, edi
$LN16@MainThread:

; 664  : 			}
; 665  : 
; 666  : 			dataBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe (irp->MdlAddress, HighPagePriority);

  0045b	8b 45 08	 mov	 eax, DWORD PTR _irp$28017[ebp]
  0045e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00461	f6 40 06 05	 test	 BYTE PTR [eax+6], 5
  00465	74 05		 je	 SHORT $LN53@MainThread
  00467	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0046a	eb 0e		 jmp	 SHORT $LN106@MainThread
$LN53@MainThread:
  0046c	6a 20		 push	 32			; 00000020H
  0046e	57		 push	 edi
  0046f	57		 push	 edi
  00470	6a 01		 push	 1
  00472	57		 push	 edi
  00473	50		 push	 eax
  00474	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmMapLockedPagesSpecifyCache@24
$LN106@MainThread:
  0047a	89 45 08	 mov	 DWORD PTR _dataBuffer$[ebp], eax

; 667  : 
; 668  : 			if (dataBuffer == NULL)

  0047d	3b c7		 cmp	 eax, edi

; 669  : 			{
; 670  : 				CompleteOriginalIrp (item, STATUS_INSUFFICIENT_RESOURCES, 0);
; 671  : 				continue;

  0047f	0f 84 d2 fc ff
	ff		 je	 $LN110@MainThread

; 672  : 			}
; 673  : 
; 674  : 			// Divide data block to fragments to enable efficient overlapping of encryption and IO operations
; 675  : 
; 676  : 			dataRemaining = item->OriginalLength;
; 677  : 			fragmentOffset = item->OriginalOffset;

  00485	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00488	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0048b	89 45 e4	 mov	 DWORD PTR _fragmentOffset$[ebp], eax
  0048e	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00491	89 4d ec	 mov	 DWORD PTR _dataRemaining$[ebp], ecx
  00494	89 45 e8	 mov	 DWORD PTR _fragmentOffset$[ebp+4], eax

; 678  : 
; 679  : 			while (dataRemaining > 0)

  00497	3b cf		 cmp	 ecx, edi
  00499	0f 86 c9 fe ff
	ff		 jbe	 $LN89@MainThread
  0049f	b8 00 00 04 00	 mov	 eax, 262144		; 00040000H
$LL13@MainThread:

; 680  : 			{
; 681  : 				BOOL isLastFragment = dataRemaining <= TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE;

  004a4	8b d0		 mov	 edx, eax
  004a6	3b d1		 cmp	 edx, ecx
  004a8	1b d2		 sbb	 edx, edx
  004aa	42		 inc	 edx
  004ab	89 55 f0	 mov	 DWORD PTR _isLastFragment$28093[ebp], edx

; 682  : 				
; 683  : 				ULONG dataFragmentLength = isLastFragment ? dataRemaining : TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE;

  004ae	89 4d f8	 mov	 DWORD PTR _dataFragmentLength$28094[ebp], ecx
  004b1	75 03		 jne	 SHORT $LN56@MainThread
  004b3	89 45 f8	 mov	 DWORD PTR _dataFragmentLength$28094[ebp], eax
$LN56@MainThread:

; 684  : 				activeFragmentBuffer = (activeFragmentBuffer == queue->FragmentBufferA ? queue->FragmentBufferB : queue->FragmentBufferA);

  004b6	8b 83 e8 00 00
	00		 mov	 eax, DWORD PTR [ebx+232]
  004bc	39 45 fc	 cmp	 DWORD PTR _activeFragmentBuffer$[ebp], eax
  004bf	75 06		 jne	 SHORT $LN57@MainThread
  004c1	8b 83 ec 00 00
	00		 mov	 eax, DWORD PTR [ebx+236]
$LN57@MainThread:

; 685  : 
; 686  : 				InterlockedIncrement (&queue->IoThreadPendingRequestCount);

  004c7	33 c9		 xor	 ecx, ecx
  004c9	89 45 fc	 mov	 DWORD PTR _activeFragmentBuffer$[ebp], eax
  004cc	8d 83 54 01 00
	00		 lea	 eax, DWORD PTR [ebx+340]
  004d2	41		 inc	 ecx
  004d3	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx

; 687  : 
; 688  : 				// Create IO request
; 689  : 				request = GetPoolBuffer (queue, sizeof (EncryptedIoRequest));

  004d7	6a 40		 push	 64			; 00000040H
  004d9	53		 push	 ebx
  004da	e8 00 00 00 00	 call	 _GetPoolBuffer@8
  004df	8b f8		 mov	 edi, eax

; 690  : 				request->Item = item;
; 691  : 				request->CompleteOriginalIrp = isLastFragment;

  004e1	8b 45 f0	 mov	 eax, DWORD PTR _isLastFragment$28093[ebp]
  004e4	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 692  : 				request->Offset = fragmentOffset;

  004e7	8b 45 e4	 mov	 eax, DWORD PTR _fragmentOffset$[ebp]
  004ea	89 47 08	 mov	 DWORD PTR [edi+8], eax
  004ed	8b 45 e8	 mov	 eax, DWORD PTR _fragmentOffset$[ebp+4]
  004f0	89 47 0c	 mov	 DWORD PTR [edi+12], eax

; 693  : 				request->Data = activeFragmentBuffer;

  004f3	8b 45 fc	 mov	 eax, DWORD PTR _activeFragmentBuffer$[ebp]
  004f6	89 47 24	 mov	 DWORD PTR [edi+36], eax

; 694  : 				request->OrigDataBufferFragment = dataBuffer;

  004f9	8b 45 08	 mov	 eax, DWORD PTR _dataBuffer$[ebp]
  004fc	89 47 28	 mov	 DWORD PTR [edi+40], eax

; 695  : 				request->Length = dataFragmentLength;

  004ff	8b 45 f8	 mov	 eax, DWORD PTR _dataFragmentLength$28094[ebp]
  00502	89 37		 mov	 DWORD PTR [edi], esi
  00504	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 696  : 
; 697  : 				if (queue->IsFilterDevice)

  00507	83 7b 3c 00	 cmp	 DWORD PTR [ebx+60], 0
  0050b	74 55		 je	 SHORT $LN11@MainThread

; 698  : 				{
; 699  : 					if (queue->EncryptedAreaStart == -1 || queue->EncryptedAreaEnd == -1)

  0050d	8b 43 48	 mov	 eax, DWORD PTR [ebx+72]
  00510	23 43 4c	 and	 eax, DWORD PTR [ebx+76]
  00513	83 f8 ff	 cmp	 eax, -1
  00516	74 44		 je	 SHORT $LN9@MainThread
  00518	8b 43 50	 mov	 eax, DWORD PTR [ebx+80]
  0051b	23 43 54	 and	 eax, DWORD PTR [ebx+84]
  0051e	83 f8 ff	 cmp	 eax, -1
  00521	74 39		 je	 SHORT $LN9@MainThread

; 702  : 					}
; 703  : 					else
; 704  : 					{
; 705  : 						// Get intersection of data fragment with encrypted area
; 706  : 						GetIntersection (fragmentOffset.QuadPart, dataFragmentLength, queue->EncryptedAreaStart, queue->EncryptedAreaEnd, &intersectStart, &intersectLength);

  00523	8d 45 f4	 lea	 eax, DWORD PTR _intersectLength$[ebp]
  00526	50		 push	 eax
  00527	8d 45 c4	 lea	 eax, DWORD PTR _intersectStart$[ebp]
  0052a	50		 push	 eax
  0052b	ff 73 54	 push	 DWORD PTR [ebx+84]
  0052e	ff 73 50	 push	 DWORD PTR [ebx+80]
  00531	ff 73 4c	 push	 DWORD PTR [ebx+76]
  00534	ff 73 48	 push	 DWORD PTR [ebx+72]
  00537	ff 75 f8	 push	 DWORD PTR _dataFragmentLength$28094[ebp]
  0053a	ff 75 e8	 push	 DWORD PTR _fragmentOffset$[ebp+4]
  0053d	ff 75 e4	 push	 DWORD PTR _fragmentOffset$[ebp]
  00540	e8 00 00 00 00	 call	 _GetIntersection@36

; 707  : 
; 708  : 						request->EncryptedOffset = intersectStart - fragmentOffset.QuadPart;

  00545	8b 45 c4	 mov	 eax, DWORD PTR _intersectStart$[ebp]
  00548	2b 45 e4	 sub	 eax, DWORD PTR _fragmentOffset$[ebp]
  0054b	8b 4d c8	 mov	 ecx, DWORD PTR _intersectStart$[ebp+4]
  0054e	1b 4d e8	 sbb	 ecx, DWORD PTR _fragmentOffset$[ebp+4]
  00551	89 47 18	 mov	 DWORD PTR [edi+24], eax
  00554	89 4f 1c	 mov	 DWORD PTR [edi+28], ecx

; 709  : 						request->EncryptedLength = intersectLength;

  00557	8b 45 f4	 mov	 eax, DWORD PTR _intersectLength$[ebp]
  0055a	eb 11		 jmp	 SHORT $LN107@MainThread
$LN9@MainThread:

; 700  : 					{
; 701  : 						request->EncryptedLength = 0;

  0055c	83 67 20 00	 and	 DWORD PTR [edi+32], 0

; 710  : 					}
; 711  : 				}
; 712  : 				else

  00560	eb 0e		 jmp	 SHORT $LN7@MainThread
$LN11@MainThread:

; 713  : 				{
; 714  : 					request->EncryptedOffset = 0;

  00562	83 67 18 00	 and	 DWORD PTR [edi+24], 0
  00566	83 67 1c 00	 and	 DWORD PTR [edi+28], 0

; 715  : 					request->EncryptedLength = dataFragmentLength;

  0056a	8b 45 f8	 mov	 eax, DWORD PTR _dataFragmentLength$28094[ebp]
$LN107@MainThread:
  0056d	89 47 20	 mov	 DWORD PTR [edi+32], eax
$LN7@MainThread:

; 716  : 				}
; 717  : 
; 718  : 				AcquireFragmentBuffer (queue, activeFragmentBuffer);

  00570	8b 4d fc	 mov	 ecx, DWORD PTR _activeFragmentBuffer$[ebp]
  00573	b8 0d 00 00 c0	 mov	 eax, -1073741811	; c000000dH
  00578	3b 8b e8 00 00
	00		 cmp	 ecx, DWORD PTR [ebx+232]
  0057e	75 0e		 jne	 SHORT $LN64@MainThread
  00580	33 c0		 xor	 eax, eax
  00582	50		 push	 eax
  00583	50		 push	 eax
  00584	50		 push	 eax
  00585	50		 push	 eax
  00586	8d 83 f0 00 00
	00		 lea	 eax, DWORD PTR [ebx+240]
  0058c	eb 18		 jmp	 SHORT $LN108@MainThread
$LN64@MainThread:
  0058e	3b 8b ec 00 00
	00		 cmp	 ecx, DWORD PTR [ebx+236]
  00594	0f 85 f5 00 00
	00		 jne	 $LN83@MainThread
  0059a	33 c0		 xor	 eax, eax
  0059c	50		 push	 eax
  0059d	50		 push	 eax
  0059e	50		 push	 eax
  0059f	50		 push	 eax
  005a0	8d 83 00 01 00
	00		 lea	 eax, DWORD PTR [ebx+256]
$LN108@MainThread:
  005a6	50		 push	 eax
  005a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
  005ad	85 c0		 test	 eax, eax
  005af	0f 8c da 00 00
	00		 jl	 $LN83@MainThread

; 719  : 
; 720  : 				if (item->Write)

  005b5	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  005b9	74 7f		 je	 SHORT $LN5@MainThread

; 721  : 				{
; 722  : 					// Encrypt data
; 723  : 					memcpy (activeFragmentBuffer, dataBuffer, dataFragmentLength);

  005bb	ff 75 f8	 push	 DWORD PTR _dataFragmentLength$28094[ebp]
  005be	ff 75 08	 push	 DWORD PTR _dataBuffer$[ebp]
  005c1	ff 75 fc	 push	 DWORD PTR _activeFragmentBuffer$[ebp]
  005c4	e8 00 00 00 00	 call	 _memcpy

; 724  : 
; 725  : 					if (request->EncryptedLength > 0)

  005c9	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  005cc	83 c4 0c	 add	 esp, 12			; 0000000cH
  005cf	85 c0		 test	 eax, eax
  005d1	76 67		 jbe	 SHORT $LN5@MainThread

; 726  : 					{
; 727  : 						UINT64_STRUCT dataUnit;
; 728  : 						ASSERT (request->EncryptedOffset + request->EncryptedLength <= request->Offset.QuadPart + request->Length);
; 729  : 
; 730  : 						dataUnit.Value = (request->Offset.QuadPart + request->EncryptedOffset) / ENCRYPTION_DATA_UNIT_SIZE;

  005d3	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  005d6	03 47 08	 add	 eax, DWORD PTR [edi+8]
  005d9	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  005dc	13 4f 0c	 adc	 ecx, DWORD PTR [edi+12]
  005df	6a 00		 push	 0
  005e1	68 00 02 00 00	 push	 512			; 00000200H
  005e6	51		 push	 ecx
  005e7	50		 push	 eax
  005e8	e8 00 00 00 00	 call	 __alldiv
  005ed	89 45 dc	 mov	 DWORD PTR _dataUnit$28103[ebp], eax

; 731  : 
; 732  : 						if (queue->CryptoInfo->bPartitionInInactiveSysEncScope)

  005f0	8b 43 28	 mov	 eax, DWORD PTR [ebx+40]
  005f3	89 55 e0	 mov	 DWORD PTR _dataUnit$28103[ebp+4], edx
  005f6	83 b8 28 44 00
	00 00		 cmp	 DWORD PTR [eax+17448], 0
  005fd	74 11		 je	 SHORT $LN4@MainThread

; 733  : 							dataUnit.Value += queue->CryptoInfo->FirstDataUnitNo.Value;

  005ff	8b 88 30 44 00
	00		 mov	 ecx, DWORD PTR [eax+17456]
  00605	01 4d dc	 add	 DWORD PTR _dataUnit$28103[ebp], ecx
  00608	8b 88 34 44 00
	00		 mov	 ecx, DWORD PTR [eax+17460]
  0060e	eb 0f		 jmp	 SHORT $LN109@MainThread
$LN4@MainThread:

; 734  : 						else if (queue->RemapEncryptedArea)

  00610	83 7b 5c 00	 cmp	 DWORD PTR [ebx+92], 0
  00614	74 0c		 je	 SHORT $LN2@MainThread

; 735  : 							dataUnit.Value += queue->RemappedAreaDataUnitOffset;

  00616	8b 4b 68	 mov	 ecx, DWORD PTR [ebx+104]
  00619	01 4d dc	 add	 DWORD PTR _dataUnit$28103[ebp], ecx
  0061c	8b 4b 6c	 mov	 ecx, DWORD PTR [ebx+108]
$LN109@MainThread:
  0061f	11 4d e0	 adc	 DWORD PTR _dataUnit$28103[ebp+4], ecx
$LN2@MainThread:

; 736  : 								
; 737  : 						EncryptDataUnits (activeFragmentBuffer + request->EncryptedOffset, &dataUnit, request->EncryptedLength / ENCRYPTION_DATA_UNIT_SIZE, queue->CryptoInfo);

  00622	50		 push	 eax
  00623	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00626	c1 e8 09	 shr	 eax, 9
  00629	50		 push	 eax
  0062a	8d 45 dc	 lea	 eax, DWORD PTR _dataUnit$28103[ebp]
  0062d	50		 push	 eax
  0062e	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00631	03 45 fc	 add	 eax, DWORD PTR _activeFragmentBuffer$[ebp]
  00634	50		 push	 eax
  00635	e8 00 00 00 00	 call	 _EncryptDataUnits@16
$LN5@MainThread:

; 738  : 					}
; 739  : 				}
; 740  : 
; 741  : 				// Queue IO request
; 742  : 				ExInterlockedInsertTailList (&queue->IoThreadQueue, &request->ListEntry, &queue->IoThreadQueueLock);

  0063a	8d 83 b4 00 00
	00		 lea	 eax, DWORD PTR [ebx+180]
  00640	50		 push	 eax
  00641	8d 57 2c	 lea	 edx, DWORD PTR [edi+44]
  00644	8d 8b ac 00 00
	00		 lea	 ecx, DWORD PTR [ebx+172]
  0064a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExfInterlockedInsertTailList@12

; 743  : 				KeSetEvent (&queue->IoThreadQueueNotEmptyEvent, IO_DISK_INCREMENT, FALSE);

  00650	6a 00		 push	 0
  00652	6a 01		 push	 1
  00654	8d 83 b8 00 00
	00		 lea	 eax, DWORD PTR [ebx+184]
  0065a	50		 push	 eax
  0065b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 744  : 
; 745  : 				if (isLastFragment)

  00661	83 7d f0 00	 cmp	 DWORD PTR _isLastFragment$28093[ebp], 0
  00665	0f 85 fd fc ff
	ff		 jne	 $LN89@MainThread

; 746  : 					break;
; 747  : 
; 748  : 				dataRemaining -= TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE;

  0066b	8b 4d ec	 mov	 ecx, DWORD PTR _dataRemaining$[ebp]
  0066e	b8 00 00 04 00	 mov	 eax, 262144		; 00040000H

; 749  : 				dataBuffer += TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE;

  00673	01 45 08	 add	 DWORD PTR _dataBuffer$[ebp], eax
  00676	2b c8		 sub	 ecx, eax

; 750  : 				fragmentOffset.QuadPart += TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE;

  00678	01 45 e4	 add	 DWORD PTR _fragmentOffset$[ebp], eax
  0067b	89 4d ec	 mov	 DWORD PTR _dataRemaining$[ebp], ecx
  0067e	83 55 e8 00	 adc	 DWORD PTR _fragmentOffset$[ebp+4], 0
  00682	85 c9		 test	 ecx, ecx
  00684	0f 87 1a fe ff
	ff		 ja	 $LL13@MainThread

; 751  : 			}
; 752  : 		}

  0068a	e9 d9 fc ff ff	 jmp	 $LN89@MainThread
$LN83@MainThread:

; 716  : 				}
; 717  : 
; 718  : 				AcquireFragmentBuffer (queue, activeFragmentBuffer);

  0068f	68 43 54 00 00	 push	 21571			; 00005443H
  00694	6a 00		 push	 0
  00696	50		 push	 eax
  00697	68 cb 00 00 00	 push	 203			; 000000cbH
  0069c	6a 29		 push	 41			; 00000029H
  0069e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN111@MainThread:
$LN97@MainThread:
  006a4	cc		 int	 3
_MainThreadProc@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@FNODOBFM@			;  ?? ::FNODOBFM::`string'
PUBLIC	_EncryptedIoQueueAddIrp@8
EXTRN	__imp__IoAcquireRemoveLockEx@20:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@FNODOBFM@
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
text$s	SEGMENT
??_C@_00CNPNBAHC@?$AA@FNODOBFM@ DB 00H			;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
; File c:\users\public\desktop\projects\ciphershed\src\driver\encryptedioqueue.c
text$s	ENDS
;	COMDAT _EncryptedIoQueueAddIrp@8
_TEXT	SEGMENT
_status$ = 8						; size = 4
_queue$ = 8						; size = 4
_irp$ = 12						; size = 4
_EncryptedIoQueueAddIrp@8 PROC				; COMDAT

; 760  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 761  : 	NTSTATUS status;
; 762  : 
; 763  : 	InterlockedIncrement (&queue->OutstandingIoCount);

  00006	8b 75 08	 mov	 esi, DWORD PTR _queue$[ebp]
  00009	33 c9		 xor	 ecx, ecx
  0000b	57		 push	 edi
  0000c	8d 86 40 01 00
	00		 lea	 eax, DWORD PTR [esi+320]
  00012	41		 inc	 ecx
  00013	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx

; 764  : 	if (queue->StopPending)

  00017	8b 86 88 01 00
	00		 mov	 eax, DWORD PTR [esi+392]
  0001d	85 c0		 test	 eax, eax
  0001f	74 09		 je	 SHORT $LN2@EncryptedI

; 765  : 	{
; 766  : 		Dump ("STATUS_DEVICE_NOT_READY  out=%d\n", queue->OutstandingIoCount);
; 767  : 		status = STATUS_DEVICE_NOT_READY;

  00021	c7 45 08 a3 00
	00 c0		 mov	 DWORD PTR _status$[ebp], -1073741661 ; c00000a3H

; 768  : 		goto err;

  00028	eb 1e		 jmp	 SHORT $err$28118
$LN2@EncryptedI:

; 769  : 	}
; 770  : 
; 771  : 	status = IoAcquireRemoveLock (&queue->RemoveLock, irp);

  0002a	8b 7d 0c	 mov	 edi, DWORD PTR _irp$[ebp]
  0002d	6a 18		 push	 24			; 00000018H
  0002f	6a 01		 push	 1
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@FNODOBFM@
  00036	57		 push	 edi
  00037	8d 46 70	 lea	 eax, DWORD PTR [esi+112]
  0003a	50		 push	 eax
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAcquireRemoveLockEx@20
  00041	89 45 08	 mov	 DWORD PTR _status$[ebp], eax

; 772  : 	if (!NT_SUCCESS (status))

  00044	85 c0		 test	 eax, eax
  00046	7d 0c		 jge	 SHORT $LN1@EncryptedI
$err$28118:

; 788  : 
; 789  : err:
; 790  : 	DecrementOutstandingIoCount (queue);

  00048	8b c6		 mov	 eax, esi
  0004a	e8 00 00 00 00	 call	 _DecrementOutstandingIoCount@4

; 791  : 	return status;

  0004f	8b 45 08	 mov	 eax, DWORD PTR _status$[ebp]
  00052	eb 33		 jmp	 SHORT $LN3@EncryptedI
$LN1@EncryptedI:

; 773  : 		goto err;
; 774  : 
; 775  : #ifdef TC_TRACE_IO_QUEUE
; 776  : 	{
; 777  : 		PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (irp);
; 778  : 		Dump ("* %I64d [%I64d] %c len=%d out=%d\n", irpSp->MajorFunction == IRP_MJ_WRITE ? irpSp->Parameters.Write.ByteOffset : irpSp->Parameters.Read.ByteOffset, GetElapsedTime (&queue->LastPerformanceCounter), irpSp->MajorFunction == IRP_MJ_WRITE ? 'W' : 'R', irpSp->MajorFunction == IRP_MJ_WRITE ? irpSp->Parameters.Write.Length : irpSp->Parameters.Read.Length, queue->OutstandingIoCount);
; 779  : 	}
; 780  : #endif
; 781  : 
; 782  : 	IoMarkIrpPending (irp);

  00054	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  00057	80 48 03 01	 or	 BYTE PTR [eax+3], 1

; 783  : 
; 784  : 	ExInterlockedInsertTailList (&queue->MainThreadQueue, &irp->Tail.Overlay.ListEntry, &queue->MainThreadQueueLock);

  0005b	8d 86 94 00 00
	00		 lea	 eax, DWORD PTR [esi+148]
  00061	50		 push	 eax
  00062	8d 57 58	 lea	 edx, DWORD PTR [edi+88]
  00065	8d 8e 8c 00 00
	00		 lea	 ecx, DWORD PTR [esi+140]
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExfInterlockedInsertTailList@12

; 785  : 	KeSetEvent (&queue->MainThreadQueueNotEmptyEvent, IO_DISK_INCREMENT, FALSE);

  00071	6a 00		 push	 0
  00073	6a 01		 push	 1
  00075	81 c6 98 00 00
	00		 add	 esi, 152		; 00000098H
  0007b	56		 push	 esi
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 786  : 	
; 787  : 	return STATUS_PENDING;

  00082	b8 03 01 00 00	 mov	 eax, 259		; 00000103H
$LN3@EncryptedI:
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi

; 792  : }

  00089	5d		 pop	 ebp
  0008a	c2 08 00	 ret	 8
_EncryptedIoQueueAddIrp@8 ENDP
_TEXT	ENDS
PUBLIC	_EncryptedIoQueueHoldWhenIdle@12
EXTRN	__imp__KeClearEvent@4:PROC
EXTRN	_TCSleep@4:PROC
EXTRN	__allmul:PROC
; Function compile flags: /Ogsp
;	COMDAT _EncryptedIoQueueHoldWhenIdle@12
_TEXT	SEGMENT
_waitTimeout$28138 = -16				; size = 8
tv164 = -8						; size = 8
_queue$ = 8						; size = 4
_timeout$ = 12						; size = 8
_EncryptedIoQueueHoldWhenIdle@12 PROC			; COMDAT

; 796  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 10	 sub	 esp, 16			; 00000010H
  00008	53		 push	 ebx
  00009	56		 push	 esi

; 797  : 	NTSTATUS status;
; 798  : 	ASSERT (!queue->Suspended);
; 799  : 
; 800  : 	queue->SuspendPending = TRUE;

  0000a	8b 75 08	 mov	 esi, DWORD PTR _queue$[ebp]
  0000d	57		 push	 edi
  0000e	c7 86 84 01 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+388], 1
  00018	33 db		 xor	 ebx, ebx
$LL8@EncryptedI@2:

; 801  : 	
; 802  : 	while (TRUE)
; 803  : 	{
; 804  : 		while (InterlockedExchangeAdd (&queue->OutstandingIoCount, 0) > 0)

  0001a	33 c9		 xor	 ecx, ecx
  0001c	8d 86 40 01 00
	00		 lea	 eax, DWORD PTR [esi+320]
  00022	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00026	85 c9		 test	 ecx, ecx
  00028	7e 77		 jle	 SHORT $LN5@EncryptedI@2
  0002a	6a ff		 push	 -1
  0002c	68 f0 d8 ff ff	 push	 -10000			; ffffd8f0H
  00031	ff 75 10	 push	 DWORD PTR _timeout$[ebp+4]
  00034	ff 75 0c	 push	 DWORD PTR _timeout$[ebp]
  00037	e8 00 00 00 00	 call	 __allmul
  0003c	89 45 f8	 mov	 DWORD PTR tv164[ebp], eax
  0003f	89 55 fc	 mov	 DWORD PTR tv164[ebp+4], edx
  00042	8d be 44 01 00
	00		 lea	 edi, DWORD PTR [esi+324]
$LL6@EncryptedI@2:

; 805  : 		{
; 806  : 			LARGE_INTEGER waitTimeout;
; 807  : 
; 808  : 			waitTimeout.QuadPart = timeout * -10000;

  00048	8b 45 f8	 mov	 eax, DWORD PTR tv164[ebp]
  0004b	89 45 f0	 mov	 DWORD PTR _waitTimeout$28138[ebp], eax
  0004e	8b 45 fc	 mov	 eax, DWORD PTR tv164[ebp+4]
  00051	89 45 f4	 mov	 DWORD PTR _waitTimeout$28138[ebp+4], eax

; 809  : 			status = KeWaitForSingleObject (&queue->NoOutstandingIoEvent, Executive, KernelMode, FALSE, timeout != 0 ? &waitTimeout : NULL);

  00054	8b 45 0c	 mov	 eax, DWORD PTR _timeout$[ebp]
  00057	0b 45 10	 or	 eax, DWORD PTR _timeout$[ebp+4]
  0005a	74 05		 je	 SHORT $LN11@EncryptedI@2
  0005c	8d 45 f0	 lea	 eax, DWORD PTR _waitTimeout$28138[ebp]
  0005f	eb 02		 jmp	 SHORT $LN12@EncryptedI@2
$LN11@EncryptedI@2:
  00061	33 c0		 xor	 eax, eax
$LN12@EncryptedI@2:
  00063	50		 push	 eax
  00064	53		 push	 ebx
  00065	53		 push	 ebx
  00066	53		 push	 ebx
  00067	57		 push	 edi
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 810  : 
; 811  : 			if (status == STATUS_TIMEOUT)

  0006e	3d 02 01 00 00	 cmp	 eax, 258		; 00000102H
  00073	75 05		 jne	 SHORT $LN4@EncryptedI@2

; 812  : 				status = STATUS_UNSUCCESSFUL;

  00075	b8 01 00 00 c0	 mov	 eax, -1073741823	; c0000001H
$LN4@EncryptedI@2:

; 813  : 
; 814  : 			if (!NT_SUCCESS (status))

  0007a	3b c3		 cmp	 eax, ebx
  0007c	7c 5d		 jl	 SHORT $LN16@EncryptedI@2

; 817  : 				return status;
; 818  : 			}
; 819  : 
; 820  : 			TCSleep (1);

  0007e	6a 01		 push	 1
  00080	e8 00 00 00 00	 call	 _TCSleep@4

; 821  : 			if (InterlockedExchangeAdd (&queue->OutstandingIoCount, 0) > 0)

  00085	8d 86 40 01 00
	00		 lea	 eax, DWORD PTR [esi+320]
  0008b	33 c9		 xor	 ecx, ecx
  0008d	8b d0		 mov	 edx, eax
  0008f	f0 0f c1 0a	 lock	  xadd	 DWORD PTR [edx], ecx
  00093	85 c9		 test	 ecx, ecx
  00095	7f 51		 jg	 SHORT $LN17@EncryptedI@2
  00097	33 c9		 xor	 ecx, ecx
  00099	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  0009d	85 c9		 test	 ecx, ecx
  0009f	7f a7		 jg	 SHORT $LL6@EncryptedI@2
$LN5@EncryptedI@2:

; 822  : 			{
; 823  : 				queue->SuspendPending = FALSE;
; 824  : 				return STATUS_UNSUCCESSFUL;
; 825  : 			}
; 826  : 		}
; 827  : 
; 828  : 		KeClearEvent (&queue->QueueResumedEvent);

  000a1	8d be 8c 01 00
	00		 lea	 edi, DWORD PTR [esi+396]
  000a7	57		 push	 edi
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeClearEvent@4

; 829  : 		queue->Suspended = TRUE;

  000ae	8d 86 80 01 00
	00		 lea	 eax, DWORD PTR [esi+384]
  000b4	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 830  : 
; 831  : 		if (InterlockedExchangeAdd (&queue->OutstandingIoCount, 0) == 0)

  000ba	33 d2		 xor	 edx, edx
  000bc	8d 8e 40 01 00
	00		 lea	 ecx, DWORD PTR [esi+320]
  000c2	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  000c6	85 d2		 test	 edx, edx
  000c8	74 25		 je	 SHORT $LN18@EncryptedI@2

; 832  : 			break;
; 833  : 
; 834  : 		queue->Suspended = FALSE;
; 835  : 		KeSetEvent (&queue->QueueResumedEvent, IO_DISK_INCREMENT, FALSE);

  000ca	53		 push	 ebx
  000cb	6a 01		 push	 1
  000cd	57		 push	 edi
  000ce	89 18		 mov	 DWORD PTR [eax], ebx
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 836  : 	}

  000d6	e9 3f ff ff ff	 jmp	 $LL8@EncryptedI@2
$LN16@EncryptedI@2:
  000db	5f		 pop	 edi

; 815  : 			{
; 816  : 				queue->SuspendPending = FALSE;

  000dc	89 9e 84 01 00
	00		 mov	 DWORD PTR [esi+388], ebx
  000e2	5e		 pop	 esi
  000e3	5b		 pop	 ebx

; 839  : 
; 840  : 	queue->SuspendPending = FALSE;
; 841  : 	return STATUS_SUCCESS;
; 842  : }

  000e4	c9		 leave
  000e5	c2 0c 00	 ret	 12			; 0000000cH
$LN17@EncryptedI@2:
  000e8	b8 01 00 00 c0	 mov	 eax, -1073741823	; c0000001H
  000ed	eb ec		 jmp	 SHORT $LN16@EncryptedI@2
$LN18@EncryptedI@2:

; 837  : 
; 838  : 	queue->ReadAheadBufferValid = FALSE;

  000ef	89 9e 10 01 00
	00		 mov	 DWORD PTR [esi+272], ebx
  000f5	33 c0		 xor	 eax, eax
  000f7	eb e2		 jmp	 SHORT $LN16@EncryptedI@2
_EncryptedIoQueueHoldWhenIdle@12 ENDP
_TEXT	ENDS
PUBLIC	_EncryptedIoQueueIsSuspended@4
; Function compile flags: /Ogsp
;	COMDAT _EncryptedIoQueueIsSuspended@4
_TEXT	SEGMENT
_queue$ = 8						; size = 4
_EncryptedIoQueueIsSuspended@4 PROC			; COMDAT

; 846  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 847  : 	return queue->Suspended;

  00005	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  00008	8b 80 80 01 00
	00		 mov	 eax, DWORD PTR [eax+384]

; 848  : }

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
_EncryptedIoQueueIsSuspended@4 ENDP
_TEXT	ENDS
PUBLIC	_EncryptedIoQueueIsRunning@4
; Function compile flags: /Ogsp
;	COMDAT _EncryptedIoQueueIsRunning@4
_TEXT	SEGMENT
_queue$ = 8						; size = 4
_EncryptedIoQueueIsRunning@4 PROC			; COMDAT

; 852  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 853  : 	return !queue->StopPending;

  00005	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  00008	8b 80 88 01 00
	00		 mov	 eax, DWORD PTR [eax+392]
  0000e	33 c9		 xor	 ecx, ecx
  00010	85 c0		 test	 eax, eax
  00012	0f 94 c1	 sete	 cl
  00015	8b c1		 mov	 eax, ecx

; 854  : }

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
_EncryptedIoQueueIsRunning@4 ENDP
_TEXT	ENDS
PUBLIC	_EncryptedIoQueueResumeFromHold@4
; Function compile flags: /Ogsp
;	COMDAT _EncryptedIoQueueResumeFromHold@4
_TEXT	SEGMENT
_queue$ = 8						; size = 4
_EncryptedIoQueueResumeFromHold@4 PROC			; COMDAT

; 858  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 859  : 	ASSERT (queue->Suspended);
; 860  : 	
; 861  : 	queue->Suspended = FALSE;

  00005	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]

; 862  : 	KeSetEvent (&queue->QueueResumedEvent, IO_DISK_INCREMENT, FALSE);

  00008	6a 00		 push	 0
  0000a	c7 80 80 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+384], 0
  00014	6a 01		 push	 1
  00016	05 8c 01 00 00	 add	 eax, 396		; 0000018cH
  0001b	50		 push	 eax
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 863  : 
; 864  : 	return STATUS_SUCCESS;

  00022	33 c0		 xor	 eax, eax

; 865  : }

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
_EncryptedIoQueueResumeFromHold@4 ENDP
_TEXT	ENDS
PUBLIC	_EncryptedIoQueueStart@4
EXTRN	_TCStopThread@8:PROC
EXTRN	_TCStartThread@12:PROC
EXTRN	__imp__KeInitializeEvent@12:PROC
EXTRN	__imp__KeInitializeMutex@8:PROC
; Function compile flags: /Ogsp
;	COMDAT _EncryptedIoQueueStart@4
_TEXT	SEGMENT
_status$ = 8						; size = 4
_i$ = 8							; size = 4
_queue$ = 8						; size = 4
_EncryptedIoQueueStart@4 PROC				; COMDAT

; 869  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	53		 push	 ebx
  00006	56		 push	 esi

; 870  : 	NTSTATUS status;
; 871  : 	EncryptedIoQueueBuffer *buffer;
; 872  : 	int i;
; 873  : 
; 874  : 	queue->StartPending = TRUE;

  00007	8b 75 08	 mov	 esi, DWORD PTR _queue$[ebp]
  0000a	57		 push	 edi

; 875  : 	queue->ThreadExitRequested = FALSE;

  0000b	33 db		 xor	 ebx, ebx
  0000d	33 ff		 xor	 edi, edi

; 876  : 
; 877  : 	queue->OutstandingIoCount = 0;
; 878  : 	queue->IoThreadPendingRequestCount = 0;
; 879  : 
; 880  : 	queue->FirstPoolBuffer = NULL;
; 881  : 	KeInitializeMutex (&queue->BufferPoolMutex, 0);

  0000f	53		 push	 ebx
  00010	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00013	47		 inc	 edi
  00014	89 be 78 01 00
	00		 mov	 DWORD PTR [esi+376], edi
  0001a	50		 push	 eax
  0001b	89 9e 7c 01 00
	00		 mov	 DWORD PTR [esi+380], ebx
  00021	89 9e 40 01 00
	00		 mov	 DWORD PTR [esi+320], ebx
  00027	89 9e 54 01 00
	00		 mov	 DWORD PTR [esi+340], ebx
  0002d	89 5e 24	 mov	 DWORD PTR [esi+36], ebx
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeMutex@8

; 882  : 
; 883  : 	KeInitializeEvent (&queue->NoOutstandingIoEvent, SynchronizationEvent, FALSE);

  00036	53		 push	 ebx
  00037	57		 push	 edi
  00038	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__KeInitializeEvent@12
  0003e	8d 86 44 01 00
	00		 lea	 eax, DWORD PTR [esi+324]
  00044	50		 push	 eax
  00045	ff d7		 call	 edi

; 884  : 	KeInitializeEvent (&queue->PoolBufferFreeEvent, SynchronizationEvent, FALSE);

  00047	53		 push	 ebx
  00048	6a 01		 push	 1
  0004a	8d 86 58 01 00
	00		 lea	 eax, DWORD PTR [esi+344]
  00050	50		 push	 eax
  00051	ff d7		 call	 edi

; 885  : 	KeInitializeEvent (&queue->QueueResumedEvent, SynchronizationEvent, FALSE);

  00053	53		 push	 ebx
  00054	6a 01		 push	 1
  00056	8d 86 8c 01 00
	00		 lea	 eax, DWORD PTR [esi+396]
  0005c	50		 push	 eax
  0005d	ff d7		 call	 edi

; 886  : 
; 887  : 	queue->FragmentBufferA = TCalloc (TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE);

  0005f	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00064	68 00 00 04 00	 push	 262144			; 00040000H
  00069	53		 push	 ebx
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00070	89 86 e8 00 00
	00		 mov	 DWORD PTR [esi+232], eax

; 888  : 	if (!queue->FragmentBufferA)

  00076	3b c3		 cmp	 eax, ebx
  00078	0f 84 85 00 00
	00		 je	 $noMemory$28169

; 889  : 		goto noMemory;
; 890  : 
; 891  : 	queue->FragmentBufferB = TCalloc (TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE);

  0007e	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00083	68 00 00 04 00	 push	 262144			; 00040000H
  00088	53		 push	 ebx
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0008f	89 86 ec 00 00
	00		 mov	 DWORD PTR [esi+236], eax

; 892  : 	if (!queue->FragmentBufferB)

  00095	3b c3		 cmp	 eax, ebx
  00097	74 6a		 je	 SHORT $noMemory$28169

; 893  : 		goto noMemory;
; 894  : 
; 895  : 	KeInitializeEvent (&queue->FragmentBufferAFreeEvent, SynchronizationEvent, TRUE);

  00099	6a 01		 push	 1
  0009b	6a 01		 push	 1
  0009d	8d 86 f0 00 00
	00		 lea	 eax, DWORD PTR [esi+240]
  000a3	50		 push	 eax
  000a4	ff d7		 call	 edi

; 896  : 	KeInitializeEvent (&queue->FragmentBufferBFreeEvent, SynchronizationEvent, TRUE);

  000a6	6a 01		 push	 1
  000a8	6a 01		 push	 1
  000aa	8d 86 00 01 00
	00		 lea	 eax, DWORD PTR [esi+256]
  000b0	50		 push	 eax
  000b1	ff d7		 call	 edi

; 897  : 
; 898  : 	queue->ReadAheadBufferValid = FALSE;
; 899  : 	queue->ReadAheadBuffer = TCalloc (TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE);

  000b3	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  000b8	68 00 00 04 00	 push	 262144			; 00040000H
  000bd	53		 push	 ebx
  000be	89 9e 10 01 00
	00		 mov	 DWORD PTR [esi+272], ebx
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  000ca	89 86 34 01 00
	00		 mov	 DWORD PTR [esi+308], eax

; 900  : 	if (!queue->ReadAheadBuffer)

  000d0	3b c3		 cmp	 eax, ebx
  000d2	74 2f		 je	 SHORT $noMemory$28169

; 901  : 		goto noMemory;
; 902  : 
; 903  : 	// Preallocate buffers
; 904  : 	for (i = 0; i < TC_ENC_IO_QUEUE_PREALLOCATED_IO_REQUEST_COUNT; ++i)

  000d4	89 5d 08	 mov	 DWORD PTR _i$[ebp], ebx
$LL38@EncryptedI@3:

; 905  : 	{
; 906  : 		if (i < TC_ENC_IO_QUEUE_PREALLOCATED_ITEM_COUNT && !GetPoolBuffer (queue, sizeof (EncryptedIoQueueItem)))

  000d7	83 7d 08 08	 cmp	 DWORD PTR _i$[ebp], 8
  000db	7d 0c		 jge	 SHORT $LN11@EncryptedI@3
  000dd	6a 20		 push	 32			; 00000020H
  000df	56		 push	 esi
  000e0	e8 00 00 00 00	 call	 _GetPoolBuffer@8
  000e5	85 c0		 test	 eax, eax
  000e7	74 1a		 je	 SHORT $noMemory$28169
$LN11@EncryptedI@3:

; 907  : 			goto noMemory;
; 908  : 
; 909  : 		if (!GetPoolBuffer (queue, sizeof (EncryptedIoRequest)))

  000e9	6a 40		 push	 64			; 00000040H
  000eb	56		 push	 esi
  000ec	e8 00 00 00 00	 call	 _GetPoolBuffer@8
  000f1	85 c0		 test	 eax, eax
  000f3	74 0e		 je	 SHORT $noMemory$28169
  000f5	ff 45 08	 inc	 DWORD PTR _i$[ebp]
  000f8	83 7d 08 10	 cmp	 DWORD PTR _i$[ebp], 16	; 00000010H
  000fc	7c d9		 jl	 SHORT $LL38@EncryptedI@3

; 910  : 			goto noMemory;
; 911  : 	}
; 912  : 
; 913  : 	for (buffer = queue->FirstPoolBuffer; buffer != NULL; buffer = buffer->NextBuffer)

  000fe	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00101	eb 11		 jmp	 SHORT $LN41@EncryptedI@3
$noMemory$28169:

; 963  : 
; 964  : noMemory:
; 965  : 	status = STATUS_INSUFFICIENT_RESOURCES;

  00103	c7 45 08 9a 00
	00 c0		 mov	 DWORD PTR _status$[ebp], -1073741670 ; c000009aH
  0010a	e9 f6 00 00 00	 jmp	 $err$28187
$LL9@EncryptedI@3:

; 914  : 	{
; 915  : 		buffer->InUse = FALSE;

  0010f	89 58 0c	 mov	 DWORD PTR [eax+12], ebx
  00112	8b 00		 mov	 eax, DWORD PTR [eax]
$LN41@EncryptedI@3:

; 910  : 			goto noMemory;
; 911  : 	}
; 912  : 
; 913  : 	for (buffer = queue->FirstPoolBuffer; buffer != NULL; buffer = buffer->NextBuffer)

  00114	3b c3		 cmp	 eax, ebx
  00116	75 f7		 jne	 SHORT $LL9@EncryptedI@3

; 916  : 	}
; 917  : 
; 918  : 	// Main thread
; 919  : 	InitializeListHead (&queue->MainThreadQueue);

  00118	8d 86 8c 00 00
	00		 lea	 eax, DWORD PTR [esi+140]

; 920  : 	KeInitializeSpinLock (&queue->MainThreadQueueLock);
; 921  : 	KeInitializeEvent (&queue->MainThreadQueueNotEmptyEvent, SynchronizationEvent, FALSE);

  0011e	53		 push	 ebx
  0011f	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00122	89 00		 mov	 DWORD PTR [eax], eax
  00124	8d 86 98 00 00
	00		 lea	 eax, DWORD PTR [esi+152]
  0012a	6a 01		 push	 1
  0012c	50		 push	 eax
  0012d	89 9e 94 00 00
	00		 mov	 DWORD PTR [esi+148], ebx
  00133	ff d7		 call	 edi

; 922  : 
; 923  : 	status = TCStartThread (MainThreadProc, queue, &queue->MainThread);

  00135	8d 86 88 00 00
	00		 lea	 eax, DWORD PTR [esi+136]
  0013b	50		 push	 eax
  0013c	56		 push	 esi
  0013d	68 00 00 00 00	 push	 OFFSET _MainThreadProc@4
  00142	e8 00 00 00 00	 call	 _TCStartThread@12

; 924  : 	if (!NT_SUCCESS (status))

  00147	3b c3		 cmp	 eax, ebx
  00149	89 45 08	 mov	 DWORD PTR _status$[ebp], eax
  0014c	0f 8c b3 00 00
	00		 jl	 $err$28187

; 925  : 		goto err;
; 926  : 
; 927  : 	// IO thread
; 928  : 	InitializeListHead (&queue->IoThreadQueue);

  00152	8d 86 ac 00 00
	00		 lea	 eax, DWORD PTR [esi+172]

; 929  : 	KeInitializeSpinLock (&queue->IoThreadQueueLock);
; 930  : 	KeInitializeEvent (&queue->IoThreadQueueNotEmptyEvent, SynchronizationEvent, FALSE);

  00158	53		 push	 ebx
  00159	89 40 04	 mov	 DWORD PTR [eax+4], eax
  0015c	89 00		 mov	 DWORD PTR [eax], eax
  0015e	8d 86 b8 00 00
	00		 lea	 eax, DWORD PTR [esi+184]
  00164	6a 01		 push	 1
  00166	50		 push	 eax
  00167	89 9e b4 00 00
	00		 mov	 DWORD PTR [esi+180], ebx
  0016d	ff d7		 call	 edi

; 931  : 
; 932  : 	status = TCStartThread (IoThreadProc, queue, &queue->IoThread);

  0016f	8d 86 a8 00 00
	00		 lea	 eax, DWORD PTR [esi+168]
  00175	50		 push	 eax
  00176	56		 push	 esi
  00177	68 00 00 00 00	 push	 OFFSET _IoThreadProc@4
  0017c	e8 00 00 00 00	 call	 _TCStartThread@12

; 933  : 	if (!NT_SUCCESS (status))

  00181	3b c3		 cmp	 eax, ebx
  00183	89 45 08	 mov	 DWORD PTR _status$[ebp], eax
  00186	7d 19		 jge	 SHORT $LN5@EncryptedI@3

; 934  : 	{
; 935  : 		queue->ThreadExitRequested = TRUE;
; 936  : 		TCStopThread (queue->MainThread, &queue->MainThreadQueueNotEmptyEvent);

  00188	8d 86 98 00 00
	00		 lea	 eax, DWORD PTR [esi+152]
  0018e	50		 push	 eax
  0018f	ff b6 88 00 00
	00		 push	 DWORD PTR [esi+136]
  00195	c7 86 7c 01 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+380], 1

; 937  : 		goto err;

  0019f	eb 5f		 jmp	 SHORT $LN42@EncryptedI@3
$LN5@EncryptedI@3:

; 938  : 	}
; 939  : 
; 940  : 	// Completion thread
; 941  : 	InitializeListHead (&queue->CompletionThreadQueue);

  001a1	8d 86 cc 00 00
	00		 lea	 eax, DWORD PTR [esi+204]

; 942  : 	KeInitializeSpinLock (&queue->CompletionThreadQueueLock);
; 943  : 	KeInitializeEvent (&queue->CompletionThreadQueueNotEmptyEvent, SynchronizationEvent, FALSE);

  001a7	53		 push	 ebx
  001a8	89 40 04	 mov	 DWORD PTR [eax+4], eax
  001ab	89 00		 mov	 DWORD PTR [eax], eax
  001ad	6a 01		 push	 1
  001af	8d 86 d8 00 00
	00		 lea	 eax, DWORD PTR [esi+216]
  001b5	50		 push	 eax
  001b6	89 9e d4 00 00
	00		 mov	 DWORD PTR [esi+212], ebx
  001bc	ff d7		 call	 edi

; 944  : 
; 945  : 	status = TCStartThread (CompletionThreadProc, queue, &queue->CompletionThread);

  001be	8d 86 c8 00 00
	00		 lea	 eax, DWORD PTR [esi+200]
  001c4	50		 push	 eax
  001c5	56		 push	 esi
  001c6	68 00 00 00 00	 push	 OFFSET _CompletionThreadProc@4
  001cb	e8 00 00 00 00	 call	 _TCStartThread@12

; 946  : 	if (!NT_SUCCESS (status))

  001d0	3b c3		 cmp	 eax, ebx
  001d2	89 45 08	 mov	 DWORD PTR _status$[ebp], eax
  001d5	7d 75		 jge	 SHORT $LN4@EncryptedI@3

; 947  : 	{
; 948  : 		queue->ThreadExitRequested = TRUE;
; 949  : 		TCStopThread (queue->MainThread, &queue->MainThreadQueueNotEmptyEvent);

  001d7	8d 86 98 00 00
	00		 lea	 eax, DWORD PTR [esi+152]
  001dd	50		 push	 eax
  001de	ff b6 88 00 00
	00		 push	 DWORD PTR [esi+136]
  001e4	c7 86 7c 01 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+380], 1
  001ee	e8 00 00 00 00	 call	 _TCStopThread@8

; 950  : 		TCStopThread (queue->IoThread, &queue->IoThreadQueueNotEmptyEvent);

  001f3	8d 86 b8 00 00
	00		 lea	 eax, DWORD PTR [esi+184]
  001f9	50		 push	 eax
  001fa	ff b6 a8 00 00
	00		 push	 DWORD PTR [esi+168]
$LN42@EncryptedI@3:
  00200	e8 00 00 00 00	 call	 _TCStopThread@8
$err$28187:

; 966  : 
; 967  : err:
; 968  : 	if (queue->FragmentBufferA)

  00205	8b 86 e8 00 00
	00		 mov	 eax, DWORD PTR [esi+232]
  0020b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__ExFreePoolWithTag@8
  00211	3b c3		 cmp	 eax, ebx
  00213	74 08		 je	 SHORT $LN40@EncryptedI@3

; 969  : 		TCfree (queue->FragmentBufferA);

  00215	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0021a	50		 push	 eax
  0021b	ff d7		 call	 edi
$LN40@EncryptedI@3:

; 970  : 	if (queue->FragmentBufferB)

  0021d	8b 86 ec 00 00
	00		 mov	 eax, DWORD PTR [esi+236]
  00223	3b c3		 cmp	 eax, ebx
  00225	74 08		 je	 SHORT $LN2@EncryptedI@3

; 971  : 		TCfree (queue->FragmentBufferB);

  00227	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0022c	50		 push	 eax
  0022d	ff d7		 call	 edi
$LN2@EncryptedI@3:

; 972  : 	if (queue->ReadAheadBuffer)

  0022f	8b 86 34 01 00
	00		 mov	 eax, DWORD PTR [esi+308]
  00235	3b c3		 cmp	 eax, ebx
  00237	74 08		 je	 SHORT $LN1@EncryptedI@3

; 973  : 		TCfree (queue->ReadAheadBuffer);

  00239	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0023e	50		 push	 eax
  0023f	ff d7		 call	 edi
$LN1@EncryptedI@3:

; 974  : 
; 975  : 	FreePoolBuffers (queue);

  00241	56		 push	 esi
  00242	e8 00 00 00 00	 call	 _FreePoolBuffers@4

; 976  : 
; 977  : 	queue->StartPending = FALSE;
; 978  : 	return status;

  00247	8b 45 08	 mov	 eax, DWORD PTR _status$[ebp]
  0024a	eb 08		 jmp	 SHORT $LN43@EncryptedI@3
$LN4@EncryptedI@3:

; 951  : 		goto err;
; 952  : 	}
; 953  : 
; 954  : #ifdef TC_TRACE_IO_QUEUE
; 955  : 	GetElapsedTimeInit (&queue->LastPerformanceCounter);
; 956  : #endif
; 957  : 
; 958  : 	queue->StopPending = FALSE;

  0024c	89 9e 88 01 00
	00		 mov	 DWORD PTR [esi+392], ebx

; 959  : 	queue->StartPending = FALSE;
; 960  : 
; 961  : 	Dump ("Queue started\n");
; 962  : 	return STATUS_SUCCESS;

  00252	33 c0		 xor	 eax, eax
$LN43@EncryptedI@3:
  00254	5f		 pop	 edi
  00255	89 9e 78 01 00
	00		 mov	 DWORD PTR [esi+376], ebx
  0025b	5e		 pop	 esi
  0025c	5b		 pop	 ebx

; 979  : }

  0025d	5d		 pop	 ebp
  0025e	c2 04 00	 ret	 4
_EncryptedIoQueueStart@4 ENDP
_TEXT	ENDS
PUBLIC	_EncryptedIoQueueStop@4
; Function compile flags: /Ogsp
;	COMDAT _EncryptedIoQueueStop@4
_TEXT	SEGMENT
_queue$ = 8						; size = 4
_EncryptedIoQueueStop@4 PROC				; COMDAT

; 983  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	53		 push	 ebx
  00006	56		 push	 esi

; 984  : 	ASSERT (!queue->StopPending);
; 985  : 	queue->StopPending = TRUE;

  00007	8b 75 08	 mov	 esi, DWORD PTR _queue$[ebp]
  0000a	33 db		 xor	 ebx, ebx
  0000c	43		 inc	 ebx
  0000d	57		 push	 edi
  0000e	89 9e 88 01 00
	00		 mov	 DWORD PTR [esi+392], ebx

; 986  : 	
; 987  : 	while (InterlockedExchangeAdd (&queue->OutstandingIoCount, 0) > 0)

  00014	8d 86 40 01 00
	00		 lea	 eax, DWORD PTR [esi+320]
  0001a	33 c9		 xor	 ecx, ecx
  0001c	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00020	85 c9		 test	 ecx, ecx
  00022	7e 23		 jle	 SHORT $LN1@EncryptedI@4
  00024	33 ff		 xor	 edi, edi
$LL2@EncryptedI@4:

; 988  : 	{
; 989  : 		KeWaitForSingleObject (&queue->NoOutstandingIoEvent, Executive, KernelMode, FALSE, NULL);

  00026	57		 push	 edi
  00027	57		 push	 edi
  00028	57		 push	 edi
  00029	57		 push	 edi
  0002a	8d 86 44 01 00
	00		 lea	 eax, DWORD PTR [esi+324]
  00030	50		 push	 eax
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
  00037	33 c9		 xor	 ecx, ecx
  00039	8d 86 40 01 00
	00		 lea	 eax, DWORD PTR [esi+320]
  0003f	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00043	85 c9		 test	 ecx, ecx
  00045	7f df		 jg	 SHORT $LL2@EncryptedI@4
$LN1@EncryptedI@4:

; 990  : 	}
; 991  : 
; 992  : 	Dump ("Queue stopping  out=%d\n", queue->OutstandingIoCount);
; 993  : 
; 994  : 	queue->ThreadExitRequested = TRUE;
; 995  : 
; 996  : 	TCStopThread (queue->MainThread, &queue->MainThreadQueueNotEmptyEvent);

  00047	8d 86 98 00 00
	00		 lea	 eax, DWORD PTR [esi+152]
  0004d	50		 push	 eax
  0004e	ff b6 88 00 00
	00		 push	 DWORD PTR [esi+136]
  00054	89 9e 7c 01 00
	00		 mov	 DWORD PTR [esi+380], ebx
  0005a	e8 00 00 00 00	 call	 _TCStopThread@8

; 997  : 	TCStopThread (queue->IoThread, &queue->IoThreadQueueNotEmptyEvent);

  0005f	8d 86 b8 00 00
	00		 lea	 eax, DWORD PTR [esi+184]
  00065	50		 push	 eax
  00066	ff b6 a8 00 00
	00		 push	 DWORD PTR [esi+168]
  0006c	e8 00 00 00 00	 call	 _TCStopThread@8

; 998  : 	TCStopThread (queue->CompletionThread, &queue->CompletionThreadQueueNotEmptyEvent);

  00071	8d 86 d8 00 00
	00		 lea	 eax, DWORD PTR [esi+216]
  00077	50		 push	 eax
  00078	ff b6 c8 00 00
	00		 push	 DWORD PTR [esi+200]
  0007e	e8 00 00 00 00	 call	 _TCStopThread@8

; 999  : 
; 1000 : 	TCfree (queue->FragmentBufferA);

  00083	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__ExFreePoolWithTag@8
  00089	bb 54 43 4d 4d	 mov	 ebx, 1296909140		; 4d4d4354H
  0008e	53		 push	 ebx
  0008f	ff b6 e8 00 00
	00		 push	 DWORD PTR [esi+232]
  00095	ff d7		 call	 edi

; 1001 : 	TCfree (queue->FragmentBufferB);

  00097	53		 push	 ebx
  00098	ff b6 ec 00 00
	00		 push	 DWORD PTR [esi+236]
  0009e	ff d7		 call	 edi

; 1002 : 	TCfree (queue->ReadAheadBuffer);

  000a0	53		 push	 ebx
  000a1	ff b6 34 01 00
	00		 push	 DWORD PTR [esi+308]
  000a7	ff d7		 call	 edi

; 1003 : 
; 1004 : 	FreePoolBuffers (queue);

  000a9	56		 push	 esi
  000aa	e8 00 00 00 00	 call	 _FreePoolBuffers@4
  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi

; 1005 : 
; 1006 : 	Dump ("Queue stopped  out=%d\n", queue->OutstandingIoCount);
; 1007 : 	return STATUS_SUCCESS;

  000b1	33 c0		 xor	 eax, eax
  000b3	5b		 pop	 ebx

; 1008 : }

  000b4	5d		 pop	 ebp
  000b5	c2 04 00	 ret	 4
_EncryptedIoQueueStop@4 ENDP
_TEXT	ENDS
END
