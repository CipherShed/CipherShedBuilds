; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	RootDeviceObject
PUBLIC	DriverShuttingDown
PUBLIC	OsMajorVersion
PUBLIC	DriverUnloadDisabled
PUBLIC	PortableMode
PUBLIC	VolumeClassFilterRegistered
PUBLIC	CacheBootPassword
PUBLIC	NonAdminSystemFavoritesAccessDisabled
PUBLIC	??_C@_0CA@PHLKBPMP@DriverEntry?5CipherShed?50?47?44?41?6?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_1M@IOJLKPKK@?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_13HGPDMIBE@?$AA?$DP?$AA?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CD@FCIMJPEM@AddDevice?5pdo?$DN?$CFp?5type?$DN?$CFx?5name?$DN?$CFw@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BN@PIELMKDH@Volume?5pdo?$DN?$CFp?5interface?$DN?$CFws?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DF@IHIBAGEA@0x?$CF08p?5?5?$CF02x?5?$CF02x?5?$CF02x?5?$CF02x?5?$CF02x@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0FE@HIDEPCAO@STATUS_BUFFER_TOO_SMALL?5ioctl?$DN0x@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0P@CMDFIGFB@?$CFls?5?$CI0x?$CFx?5?$CFd?$CJ?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BG@JHFMBFJC@Driver?5shutting?5down?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DA@HGPNLENJ@Device?5?$CFd?5shutting?5down?3?5STATUS_@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EI@NJLFEPKD@Removable?5device?5?$CFd?5has?5DO_VERIF@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CA@NGANHIBM@TCCreateRootDeviceObject?5BEGIN?6?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0CE@KKOENIAD@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5PASSIVE_LE@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0CF@KMOPKHLE@Creating?5root?5device?5nt?$DN?$CFls?5dos?$DN@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0DA@OJGNPLJ@TCCreateRootDeviceObject?5NTSTATU@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0CN@PMFMKKNC@TCCreateRootDeviceObject?5STATUS_@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0BM@HAIECJHN@TCCreateDeviceObject?5BEGIN?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CA@MBKOBJGH@Creating?5device?5nt?$DN?$CFls?5dos?$DN?$CFls?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CM@DAAJFNOI@TCCreateDeviceObject?5NTSTATUS?5?$DN?5@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CJ@CAANMOOG@TCCreateDeviceObject?5STATUS_SUCC@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0M@FBJPBOL@name?5?$DN?5?$CFls?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_08DALLBBIL@id?5?$DN?5?$CFs?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0M@HABEOOKA@link?5?$DN?5?$CFls?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BO@BEMMNDOD@IOCTL?5error?50x?$CF08x?5?$CI0x?$CFx?5?$CFd?$CJ?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0L@FEEFGEIL@CipherShed?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_09EMKKFGIH@TrueCrypt?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CA@FCHCHJKN@Open?5test?5on?5file?5?$CFls?5success?4?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BH@GFMHOPFN@Setting?5portable?5mode?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BE@MLCKFMJI@IOCTL?5error?50x?$CF08x?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BE@DCPHDOHD@Starting?5thread?4?4?4?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CB@DGOAIPAC@PsCreateSystemThread?5Failed?5END?6@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CF@DMBFEFC@Waiting?5for?5thread?5to?5initialize@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CK@KIOPBGEO@Waiting?5completed?$CB?5Thread?5return@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BO@IDJGLOL@Signalling?5thread?5to?5quit?4?4?4?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BG@MEOILBFO@NT_SUCCESS?5?$CIntStatus?$CJ?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0P@OPFPPFJJ@Thread?5exited?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CD@LOGBEHKH@Mount?5THREAD?5OPENING?5VOLUME?5BEGI@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BA@CCLAPIHO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_19JHEHLFPM@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DO@GJJNBBEG@Mount?5THREAD?5request?5for?5File?5?$CFl@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CO@PADHEFHE@irpSp?9?$DOMajorFunction?5?$DN?$DN?5IRP_MJ_D@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BA@OMKHINCH@Closing?5volume?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DA@GMJGMIMP@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EK@CMLLEBIK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAA?$AAB?$AAO?$AAR?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EC@HMNCILMA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAA?$AAB?$AAO?$AAR?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DO@JPMJPMCJ@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAE?$AAT?$AAU?$AAP?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DM@OLONGNGL@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAA?$AAL?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AAS?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DC@CLEBJPLG@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1FE@BEJBLKBA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAP@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1FI@CDJGLMPJ@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA?$AAL?$AAG@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1FE@OJNNCONL@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAE?$AAT@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EI@GAKLFLAF@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAT?$AAA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EC@OPCJHCIG@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAL?$AAO?$AAA?$AAD?$AAE?$AAR?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EM@OAEBJACE@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_?$AAR@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EM@LMAMOKGA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_?$AAS@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DK@DFEJGDBK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAR?$AAE?$AAF?$AAC?$AAO?$AAU?$AAN?$AAT?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DI@LAIAIOML@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EE@HEELFNND@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DI@ODPPPDDO@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DK@KJKOFIJA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAE?$AAD?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AAS?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EG@LLJHBPJF@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAS?$AAS?$AAW?$AAO?$AAR?$AAD?$AA_?$AAC?$AAA?$AAC?$AAH?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EC@FADHDJPK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EE@IPNJBDEG@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAO?$AAR?$AAT?$AAA?$AAB?$AAL?$AAE?$AA_?$AAM?$AAO?$AAD?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EE@NMKCMMBM@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAP?$AAO?$AAR?$AAT?$AAA?$AAB?$AAL?$AAE?$AA_?$AAM?$AAO?$AAD?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DM@GFCMCNDC@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAR?$AAE?$AAS?$AAO?$AAL?$AAV?$AAE?$AAD?$AA_?$AAS?$AAY?$AAM?$AAL?$AAI?$AAN?$AAK?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EM@GFDNBFC@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAD?$AAU?$AAM?$AAP?$AA_?$AAC@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DO@DMIHGGIB@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAP?$AAR?$AAO?$AAP?$AAE?$AAR?$AAT?$AAI?$AAE?$AAS?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DG@LBDEDPBA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAW?$AAA?$AAR?$AAN?$AAI?$AAN?$AAG?$AA_?$AAF?$AAL?$AAA?$AAG?$AAS?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DE@JNPINMHP@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAS?$AA_?$AAW?$AAR?$AAI?$AAT?$AAA?$AAB?$AAL?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DO@ICDMEENM@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAA?$AAN?$AAY?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EG@HPLFHOOO@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAU?$AAN?$AAL?$AAO?$AAA?$AAD?$AA_?$AAD?$AAI?$AAS?$AAA?$AAB?$AAL@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EE@HPDOLCKH@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAH?$AAI?$AAD?$AAD?$AAE?$AAN?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAR?$AAU?$AAN?$AAN?$AAI?$AAN@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CM@HJCGFKAD@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CG@HPPKKEKP@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAO?$AAP?$AAE?$AAN?$AA_?$AAT?$AAE?$AAS?$AAT?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DO@BKHLMLHN@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAP?$AAR?$AAO?$AAB?$AAE?$AA_?$AAR?$AAE?$AAA?$AAL?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EG@GGODONFK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAR?$AAE?$AAO?$AAP?$AAE?$AAN?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAH?$AAE?$AAA?$AAD@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DM@JFJLBNLP@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAR?$AAE?$AAR?$AAE?$AAA?$AAD?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1FE@EBAIHKDI@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAF?$AAA?$AAV?$AAO?$AAR?$AAI?$AAT?$AAE?$AA_?$AAV?$AAO?$AAL@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EC@FGBEDIDI@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAA?$AAR?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DK@BNKDMLAM@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_?$AAP?$AAA?$AAS?$AAS?$AAW?$AAO?$AAR?$AAD?$AA_?$AAC?$AAA?$AAC?$AAH?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EC@FOOPNHFI@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAW?$AAR?$AAI?$AAT?$AAE?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAS?$AAE?$AAC?$AAT?$AAO?$AAR@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EK@FDCJEFAP@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAE?$AAX?$AAT@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DM@KPKDNCHM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EC@NPAFBAMN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA_?$AAE?$AAX@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EC@HFOIOEOM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAN?$AAA?$AAM?$AAE@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1FC@MNMCPAAJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAS?$AAU?$AAG?$AAG?$AAE?$AAS?$AAT?$AAE?$AAD?$AA_?$AAL@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DO@OGNDJPNH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAU?$AAN?$AAI?$AAQ?$AAU?$AAE?$AA_?$AAI?$AAD?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CI@DJEMJCBH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAO?$AAN?$AAL?$AAI?$AAN?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DI@HGGIOGFM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAL?$AAI?$AAN?$AAK?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DI@BMKMBCGO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAL?$AAI?$AAN?$AAK?$AA_?$AAD?$AAE?$AAL?$AAE?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DI@LFNEEBHO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAP?$AAO?$AAI?$AAN?$AAT?$AAS?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1FE@CLAOKMGL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAP?$AAO?$AAI?$AAN@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1FE@EBMKFIFJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAP?$AAO?$AAI?$AAN@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DG@DLDFECDE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAL?$AAE?$AAN?$AAG?$AAT?$AAH?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EA@IKPNDHCL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAO?$AAR?$AAA?$AAG?$AAE?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAN?$AAU?$AAM?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DM@LOAKHCPB@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EC@CAILBHJF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA_?$AAE?$AAX@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DM@FAAIHMNH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAS?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DI@CCDFFIEC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAL?$AAA?$AAY?$AAO?$AAU?$AAT?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DO@EPIDKIKJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAS?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAL?$AAA?$AAY?$AAO?$AAU?$AAT?$AA_?$AAE?$AAX?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CE@LGEELOJE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DC@PCKIDBBB@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAT?$AAR?$AAA?$AAC?$AAK?$AAS?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DG@HPLPDECO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAA?$AAS?$AAS?$AAI?$AAG?$AAN?$AA_?$AAB?$AAL?$AAO?$AAC?$AAK?$AAS?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CO@LEDAJMII@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAP?$AAE?$AAR?$AAF?$AAO?$AAR?$AAM?$AAA?$AAN?$AAC?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CO@MFHKENAI@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAS?$AA_?$AAW?$AAR?$AAI?$AAT?$AAA?$AAB?$AAL?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CG@LCBFNDKM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAL?$AAO?$AAG?$AAG?$AAI?$AAN?$AAG?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DI@LHHOILKE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAT?$AAR?$AAA?$AAC?$AAK?$AAS?$AA_?$AAE?$AAX?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DO@JMICENAF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAS?$AAT?$AAR?$AAU?$AAC?$AAT?$AAU?$AAR?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DE@OGHADOL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DG@BLHGEOGG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAR?$AAE?$AAS?$AAE?$AAT?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DK@EFIEFEEG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAQ?$AAU?$AAE?$AAS?$AAT?$AA_?$AAS?$AAT?$AAR?$AAU?$AAC?$AAT?$AAU?$AAR?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DA@EGLLKJNO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAQ?$AAU?$AAE?$AAS?$AAT?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DK@NNJOEKIN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAC?$AAO?$AAN?$AAT?$AAR?$AAO?$AAL?$AAL?$AAE?$AAR?$AA_?$AAN?$AAU?$AAM?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CE@PLNOGJJD@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DC@MGFPICHJ@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAS?$AAE?$AAN?$AAD?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAC?$AAO?$AAM?$AAM?$AAA?$AAN?$AAD?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CK@JCHEBCIE@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAR?$AAC?$AAV?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DO@JKPDDEIN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAN?$AAT?$AAE?$AAR?$AAN?$AAA?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EC@JFOBAPGC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAN?$AAT?$AAE?$AAR?$AAN?$AAA?$AAL?$AA_?$AAC?$AAL?$AAE?$AAA?$AAR?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DA@DLMBEKMN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAC?$AAH?$AAE?$AAC?$AAK?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DC@NMJCPDJD@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA_?$AAR?$AAE?$AAM?$AAO?$AAV?$AAA?$AAL?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CO@KHEOABCH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAE?$AAJ?$AAE?$AAC?$AAT?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CM@GNBBIMEE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAL?$AAO?$AAA?$AAD?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CG@MJDBKCLM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAS?$AAE?$AAR?$AAV?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CG@BFEEHHEK@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAL?$AAE?$AAA?$AAS?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DI@EBJJOMKC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAI?$AAN?$AAD?$AA_?$AAN?$AAE?$AAW?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AAS?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DG@MIHPHMPG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA_?$AAT?$AAY?$AAP?$AAE?$AAS?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DO@MEELNMKF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAO?$AAR?$AAA?$AAG?$AAE?$AA_?$AAS?$AAE?$AAT?$AA_?$AAH?$AAO?$AAT?$AAP?$AAL?$AAU?$AAG?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BI@CFPHGFDN@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAR?$AAE?$AAA?$AAD?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BK@HGBIKEDO@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAW?$AAR?$AAI?$AAT?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BM@KFEHBPBD@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BK@JLALPKNJ@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAL?$AAO?$AAS?$AAE?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BO@GEGOKABG@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAL?$AAE?$AAA?$AAN?$AAU?$AAP?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CK@MCKHKFDD@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAF?$AAL?$AAU?$AAS?$AAH?$AA_?$AAB?$AAU?$AAF?$AAF?$AAE?$AAR?$AAS?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CA@FOECGGNC@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAS?$AAH?$AAU?$AAT?$AAD?$AAO?$AAW?$AAN?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CM@DKLAEDLO@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAT?$AAR?$AAO?$AAL?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1M@KHJOIALG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BM@GNHEHBJH@TCDeleteDeviceObject?5BEGIN?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CP@NIIDLADO@IoDeleteSymbolicLink?5failed?5ntSt@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EA@FPAPEGHJ@?$AAP?$AAs?$AAD?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAI?$AAm?$AAp?$AAe?$AAr?$AAs?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAk?$AAe?$AAn?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BK@EIFNDPP@TCDeleteDeviceObject?5END?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BG@MGFDNIAG@TCUnloadDriver?5BEGIN?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BE@CJGLKHCK@TCUnloadDriver?5END?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BH@BPCEMJJB@IRP?5allocation?5failed?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CF@BFNPLHIK@Failed?5to?5get?5drive?5size?5?9?5error@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CO@FHHNLLNJ@Real?5drive?5size?5?$DN?5?$CFI64d?5bytes?5?$CI?$CF@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CB@JIDCFMLM@Volume?5?$CFls?5open?5NTSTATUS?50x?$CF08x?6@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CA@MOHACMBH@KeGetCurrentIrql?$CI?$CJ?5?$DM?$DN?5APC_LEVEL?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CC@INHNDJGI@IoCreateSymbolicLink?5returned?5?$CFX@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CC@KAFJKDAC@IoDeleteSymbolicLink?5returned?5?$CFX@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CO@FHIENMIJ@IOCTL_MOUNTMGR_DELETE_POINTS?5ret@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BL@PIKDDHEP@Mount?5request?5looks?5valid?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CF@CGPMKDKJ@WARNING?3?5MOUNT?5DRIVE?5LETTER?5INVA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CO@NNHGPFIJ@Mount?5CREATE?5DEVICE?5ERROR?0?5ntSta@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CL@KIIHMHE@Mount?5FAILURE?5NT?5ERROR?0?5ntStatus@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CP@DBOFILAH@Mount?5SUCCESS?5TC?5code?5?$DN?50x?$CF08x?5R@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CA@IJMBHFOD@Mount?5FAILURE?5TC?5code?5?$DN?50x?$CF08x?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BC@FNOALNCB@UnmountDevice?5?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BP@EOHNIHMK@FSCTL_LOCK_VOLUME?5returned?5?$CFX?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CD@FFMFJFAI@FSCTL_DISMOUNT_VOLUME?5returned?5?$CF@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BI@OJEECLJN@Unmounting?5all?5volumes?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CJ@KBGIGBCB@?$CBIoIsSystemThread?5?$CIPsGetCurrentT@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BK@BGEEJMHD@?$CImaxSizeInBytes?5?$CG?51?$CJ?5?$DN?$DN?50?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CI@OFAMGLPO@retryDelay?5?$DO?50?5?$CG?$CG?5retryDelay?5?$DM?$DN?5@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1MA@BNNNAGDA@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BK@FNJCPENK@?$AAU?$AAp?$AAp?$AAe?$AAr?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAs?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BE@OBOIPPHP@?$AAt?$AAr?$AAu?$AAe?$AAc?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BM@GOBMMLHF@Volume?5class?5filter?5active?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1HM@GLBNDPGI@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CA@LGEHFLCO@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BM@LHOAOPML@Configuration?5flags?5?$DN?50x?$CFx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1EA@CEOJFLPD@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAE?$AAn?$AAc?$AAr?$AAy?$AAp?$AAt?$AAi?$AAo?$AAn?$AAF?$AAr?$AAe?$AAe?$AAC?$AAp?$AAu?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BJ@BHMICMIC@Zeroing?5sector?5at?5?$CFI64d?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BO@NFNIJFEK@Skipping?5bad?5sector?5at?5?$CFI64d?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BE@JBJOLBIB@OsMajorVersion?5?$CB?$DN?50?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp_PsGetVersion:PROC
EXTRN	__imp_IoGetDeviceInterfaces:PROC
EXTRN	__imp_ObQueryNameString:PROC
EXTRN	GUID_DEVINTERFACE_VOLUME:BYTE
EXTRN	__imp_IoRegisterShutdownNotification:PROC
EXTRN	__imp_KeInitializeSemaphore:PROC
EXTRN	__imp_IoEnumerateDeviceObjectList:PROC
EXTRN	__imp_ObOpenObjectByPointer:PROC
EXTRN	__imp_PsCreateSystemThread:PROC
EXTRN	__imp_SeCreateClientSecurity:PROC
EXTRN	__imp_KeReleaseSemaphore:PROC
EXTRN	__imp_KeInitializeTimerEx:PROC
EXTRN	__imp_KeSetTimerEx:PROC
EXTRN	__imp_wcsncat:PROC
EXTRN	__imp_MmGetSystemRoutineAddress:PROC
EXTRN	__imp_SeTokenType:PROC
EXTRN	__imp_IoGetDeviceObjectPointer:PROC
EXTRN	__imp_ObReferenceObjectByHandle:PROC
EXTRN	__imp_IoBuildSynchronousFsdRequest:PROC
EXTRN	__imp_ObfReferenceObject:PROC
EXTRN	__imp_IoBuildDeviceIoControlRequest:PROC
EXTRN	__imp_IoGetRelatedDeviceObject:PROC
EXTRN	__imp_IoCreateSymbolicLink:PROC
EXTRN	__imp_IoDeleteSymbolicLink:PROC
EXTRN	__imp_RtlLengthSid:PROC
EXTRN	__imp_RtlCopySid:PROC
EXTRN	__imp_ZwQuerySymbolicLinkObject:PROC
EXTRN	__imp_ZwCreateFile:PROC
EXTRN	__imp_ZwOpenSymbolicLinkObject:PROC
EXTRN	__imp_IofCompleteRequest:PROC
EXTRN	__imp_KeQueryActiveProcessors:PROC
EXTRN	__imp_KeDelayExecutionThread:PROC
EXTRN	__imp_ZwQueryValueKey:PROC
EXTRN	__imp_ZwClose:PROC
EXTRN	__imp_ZwOpenKey:PROC
EXTRN	__imp_ZwSetValueKey:PROC
EXTRN	__imp_RtlInitUnicodeString:PROC
EXTRN	__imp_SeCaptureSubjectContext:PROC
EXTRN	__imp_SeLockSubjectContext:PROC
EXTRN	__imp_SeUnlockSubjectContext:PROC
EXTRN	__imp_SeReleaseSubjectContext:PROC
EXTRN	__imp_RtlEqualSid:PROC
EXTRN	__imp_SeTokenIsAdmin:PROC
EXTRN	__imp_SeQueryInformationToken:PROC
EXTRN	__imp_KeQueryPerformanceCounter:PROC
COMM	VirtualVolumeDeviceObjects:QWORD:01aH
COMM	TCDriverObject:QWORD
COMM	LastUniqueVolumeId:DWORD
COMM	OsMinorVersion:DWORD
COMM	SelfTestsPassed:DWORD
RootDeviceObject DQ 01H DUP (?)
DriverShuttingDown DD 01H DUP (?)
OsMajorVersion DD 01H DUP (?)
DriverUnloadDisabled DD 01H DUP (?)
PortableMode DD	01H DUP (?)
VolumeClassFilterRegistered DD 01H DUP (?)
CacheBootPassword DD 01H DUP (?)
NonAdminSystemFavoritesAccessDisabled DD 01H DUP (?)
	ALIGN	8

EncryptionThreadPoolFreeCpuCountLimit DQ 01H DUP (?)
SystemFavoriteVolumeDirty DD 01H DUP (?)
PagingFileCreationPrevented DD 01H DUP (?)
;	COMDAT ??_C@_0BE@JBJOLBIB@OsMajorVersion?5?$CB?$DN?50?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BE@JBJOLBIB@OsMajorVersion?5?$CB?$DN?50?$AA@FNODOBFM@ DB 'OsMajorV'
	DB	'ersion != 0', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BO@NFNIJFEK@Skipping?5bad?5sector?5at?5?$CFI64d?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BO@NFNIJFEK@Skipping?5bad?5sector?5at?5?$CFI64d?6?$AA@FNODOBFM@ DB 'S'
	DB	'kipping bad sector at %I64d', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BJ@BHMICMIC@Zeroing?5sector?5at?5?$CFI64d?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BJ@BHMICMIC@Zeroing?5sector?5at?5?$CFI64d?6?$AA@FNODOBFM@ DB 'Zero'
	DB	'ing sector at %I64d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EA@CEOJFLPD@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAE?$AAn?$AAc?$AAr?$AAy?$AAp?$AAt?$AAi?$AAo?$AAn?$AAF?$AAr?$AAe?$AAe?$AAC?$AAp?$AAu?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1EA@CEOJFLPD@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAE?$AAn?$AAc?$AAr?$AAy?$AAp?$AAt?$AAi?$AAo?$AAn?$AAF?$AAr?$AAe?$AAe?$AAC?$AAp?$AAu?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, 'E', 00H, 'n', 00H, 'c', 00H, 'r', 00H, 'y'
	DB	00H, 'p', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'F', 00H
	DB	'r', 00H, 'e', 00H, 'e', 00H, 'C', 00H, 'p', 00H, 'u', 00H, 'C'
	DB	00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BM@LHOAOPML@Configuration?5flags?5?$DN?50x?$CFx?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BM@LHOAOPML@Configuration?5flags?5?$DN?50x?$CFx?6?$AA@FNODOBFM@ DB 'C'
	DB	'onfiguration flags = 0x%x', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CA@LGEHFLCO@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CA@LGEHFLCO@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 'f', 00H, 'i'
	DB	00H, 'g', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1HM@GLBNDPGI@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
text$s	SEGMENT
??_C@_1HM@GLBNDPGI@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@ DB '\'
	DB	00H, 'R', 00H, 'E', 00H, 'G', 00H, 'I', 00H, 'S', 00H, 'T', 00H
	DB	'R', 00H, 'Y', 00H, '\', 00H, 'M', 00H, 'A', 00H, 'C', 00H, 'H'
	DB	00H, 'I', 00H, 'N', 00H, 'E', 00H, '\', 00H, 'S', 00H, 'Y', 00H
	DB	'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '\', 00H, 'C', 00H, 'u'
	DB	00H, 'r', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'C', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, 'r', 00H, 'o', 00H, 'l', 00H, 'S'
	DB	00H, 'e', 00H, 't', 00H, '\', 00H, 'S', 00H, 'e', 00H, 'r', 00H
	DB	'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 'c', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BM@GOBMMLHF@Volume?5class?5filter?5active?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BM@GOBMMLHF@Volume?5class?5filter?5active?6?$AA@FNODOBFM@ DB 'Volu'
	DB	'me class filter active', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BE@OBOIPPHP@?$AAt?$AAr?$AAu?$AAe?$AAc?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BE@OBOIPPHP@?$AAt?$AAr?$AAu?$AAe?$AAc?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ DB 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 'c', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 't', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BK@FNJCPENK@?$AAU?$AAp?$AAp?$AAe?$AAr?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAs?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BK@FNJCPENK@?$AAU?$AAp?$AAp?$AAe?$AAr?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAs?$AA?$AA@FNODOBFM@ DB 'U'
	DB	00H, 'p', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'F', 00H, 'i', 00H
	DB	'l', 00H, 't', 00H, 'e', 00H, 'r', 00H, 's', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1MA@BNNNAGDA@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
text$s	SEGMENT
??_C@_1MA@BNNNAGDA@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@ DB '\'
	DB	00H, 'R', 00H, 'E', 00H, 'G', 00H, 'I', 00H, 'S', 00H, 'T', 00H
	DB	'R', 00H, 'Y', 00H, '\', 00H, 'M', 00H, 'A', 00H, 'C', 00H, 'H'
	DB	00H, 'I', 00H, 'N', 00H, 'E', 00H, '\', 00H, 'S', 00H, 'Y', 00H
	DB	'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '\', 00H, 'C', 00H, 'u'
	DB	00H, 'r', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'C', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, 'r', 00H, 'o', 00H, 'l', 00H, 'S'
	DB	00H, 'e', 00H, 't', 00H, '\', 00H, 'C', 00H, 'o', 00H, 'n', 00H
	DB	't', 00H, 'r', 00H, 'o', 00H, 'l', 00H, '\', 00H, 'C', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, '\', 00H, '{', 00H, '7', 00H
	DB	'1', 00H, 'A', 00H, '2', 00H, '7', 00H, 'C', 00H, 'D', 00H, 'D'
	DB	00H, '-', 00H, '8', 00H, '1', 00H, '2', 00H, 'A', 00H, '-', 00H
	DB	'1', 00H, '1', 00H, 'D', 00H, '0', 00H, '-', 00H, 'B', 00H, 'E'
	DB	00H, 'C', 00H, '7', 00H, '-', 00H, '0', 00H, '8', 00H, '0', 00H
	DB	'0', 00H, '2', 00H, 'B', 00H, 'E', 00H, '2', 00H, '0', 00H, '9'
	DB	00H, '2', 00H, 'F', 00H, '}', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CI@OFAMGLPO@retryDelay?5?$DO?50?5?$CG?$CG?5retryDelay?5?$DM?$DN?5@FNODOBFM@
text$s	SEGMENT
??_C@_0CI@OFAMGLPO@retryDelay?5?$DO?50?5?$CG?$CG?5retryDelay?5?$DM?$DN?5@FNODOBFM@ DB 'r'
	DB	'etryDelay > 0 && retryDelay <= timeout', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BK@BGEEJMHD@?$CImaxSizeInBytes?5?$CG?51?$CJ?5?$DN?$DN?50?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BK@BGEEJMHD@?$CImaxSizeInBytes?5?$CG?51?$CJ?5?$DN?$DN?50?$AA@FNODOBFM@ DB '('
	DB	'maxSizeInBytes & 1) == 0', 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CJ@KBGIGBCB@?$CBIoIsSystemThread?5?$CIPsGetCurrentT@FNODOBFM@
text$s	SEGMENT
??_C@_0CJ@KBGIGBCB@?$CBIoIsSystemThread?5?$CIPsGetCurrentT@FNODOBFM@ DB '!'
	DB	'IoIsSystemThread (PsGetCurrentThread())', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BI@OJEECLJN@Unmounting?5all?5volumes?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BI@OJEECLJN@Unmounting?5all?5volumes?6?$AA@FNODOBFM@ DB 'Unmountin'
	DB	'g all volumes', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CD@FFMFJFAI@FSCTL_DISMOUNT_VOLUME?5returned?5?$CF@FNODOBFM@
text$s	SEGMENT
??_C@_0CD@FFMFJFAI@FSCTL_DISMOUNT_VOLUME?5returned?5?$CF@FNODOBFM@ DB 'FS'
	DB	'CTL_DISMOUNT_VOLUME returned %X', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BP@EOHNIHMK@FSCTL_LOCK_VOLUME?5returned?5?$CFX?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BP@EOHNIHMK@FSCTL_LOCK_VOLUME?5returned?5?$CFX?6?$AA@FNODOBFM@ DB 'F'
	DB	'SCTL_LOCK_VOLUME returned %X', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BC@FNOALNCB@UnmountDevice?5?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BC@FNOALNCB@UnmountDevice?5?$CFd?6?$AA@FNODOBFM@ DB 'UnmountDevice'
	DB	' %d', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CA@IJMBHFOD@Mount?5FAILURE?5TC?5code?5?$DN?50x?$CF08x?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0CA@IJMBHFOD@Mount?5FAILURE?5TC?5code?5?$DN?50x?$CF08x?6?$AA@FNODOBFM@ DB 'M'
	DB	'ount FAILURE TC code = 0x%08x', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CP@DBOFILAH@Mount?5SUCCESS?5TC?5code?5?$DN?50x?$CF08x?5R@FNODOBFM@
text$s	SEGMENT
??_C@_0CP@DBOFILAH@Mount?5SUCCESS?5TC?5code?5?$DN?50x?$CF08x?5R@FNODOBFM@ DB 'M'
	DB	'ount SUCCESS TC code = 0x%08x READ-ONLY = %d', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CL@KIIHMHE@Mount?5FAILURE?5NT?5ERROR?0?5ntStatus@FNODOBFM@
text$s	SEGMENT
??_C@_0CL@KIIHMHE@Mount?5FAILURE?5NT?5ERROR?0?5ntStatus@FNODOBFM@ DB 'Mou'
	DB	'nt FAILURE NT ERROR, ntStatus = 0x%08x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CO@NNHGPFIJ@Mount?5CREATE?5DEVICE?5ERROR?0?5ntSta@FNODOBFM@
text$s	SEGMENT
??_C@_0CO@NNHGPFIJ@Mount?5CREATE?5DEVICE?5ERROR?0?5ntSta@FNODOBFM@ DB 'Mo'
	DB	'unt CREATE DEVICE ERROR, ntStatus = 0x%08x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CF@CGPMKDKJ@WARNING?3?5MOUNT?5DRIVE?5LETTER?5INVA@FNODOBFM@
text$s	SEGMENT
??_C@_0CF@CGPMKDKJ@WARNING?3?5MOUNT?5DRIVE?5LETTER?5INVA@FNODOBFM@ DB 'WA'
	DB	'RNING: MOUNT DRIVE LETTER INVALID', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BL@PIKDDHEP@Mount?5request?5looks?5valid?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BL@PIKDDHEP@Mount?5request?5looks?5valid?6?$AA@FNODOBFM@ DB 'Mount'
	DB	' request looks valid', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CO@FHIENMIJ@IOCTL_MOUNTMGR_DELETE_POINTS?5ret@FNODOBFM@
text$s	SEGMENT
??_C@_0CO@FHIENMIJ@IOCTL_MOUNTMGR_DELETE_POINTS?5ret@FNODOBFM@ DB 'IOCTL_'
	DB	'MOUNTMGR_DELETE_POINTS returned 0x%08x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'M', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, 'P'
	DB	00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'M', 00H, 'a', 00H
	DB	'n', 00H, 'a', 00H, 'g', 00H, 'e', 00H, 'r', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CC@KAFJKDAC@IoDeleteSymbolicLink?5returned?5?$CFX@FNODOBFM@
text$s	SEGMENT
??_C@_0CC@KAFJKDAC@IoDeleteSymbolicLink?5returned?5?$CFX@FNODOBFM@ DB 'Io'
	DB	'DeleteSymbolicLink returned %X', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CC@INHNDJGI@IoCreateSymbolicLink?5returned?5?$CFX@FNODOBFM@
text$s	SEGMENT
??_C@_0CC@INHNDJGI@IoCreateSymbolicLink?5returned?5?$CFX@FNODOBFM@ DB 'Io'
	DB	'CreateSymbolicLink returned %X', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CA@MOHACMBH@KeGetCurrentIrql?$CI?$CJ?5?$DM?$DN?5APC_LEVEL?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0CA@MOHACMBH@KeGetCurrentIrql?$CI?$CJ?5?$DM?$DN?5APC_LEVEL?$AA@FNODOBFM@ DB 'K'
	DB	'eGetCurrentIrql() <= APC_LEVEL', 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CB@JIDCFMLM@Volume?5?$CFls?5open?5NTSTATUS?50x?$CF08x?6@FNODOBFM@
text$s	SEGMENT
??_C@_0CB@JIDCFMLM@Volume?5?$CFls?5open?5NTSTATUS?50x?$CF08x?6@FNODOBFM@ DB 'V'
	DB	'olume %ls open NTSTATUS 0x%08x', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CO@FHHNLLNJ@Real?5drive?5size?5?$DN?5?$CFI64d?5bytes?5?$CI?$CF@FNODOBFM@
text$s	SEGMENT
??_C@_0CO@FHHNLLNJ@Real?5drive?5size?5?$DN?5?$CFI64d?5bytes?5?$CI?$CF@FNODOBFM@ DB 'R'
	DB	'eal drive size = %I64d bytes (%I64d hidden)', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CF@BFNPLHIK@Failed?5to?5get?5drive?5size?5?9?5error@FNODOBFM@
text$s	SEGMENT
??_C@_0CF@BFNPLHIK@Failed?5to?5get?5drive?5size?5?9?5error@FNODOBFM@ DB 'F'
	DB	'ailed to get drive size - error %x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BH@BPCEMJJB@IRP?5allocation?5failed?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BH@BPCEMJJB@IRP?5allocation?5failed?6?$AA@FNODOBFM@ DB 'IRP alloca'
	DB	'tion failed', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BE@CJGLKHCK@TCUnloadDriver?5END?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BE@CJGLKHCK@TCUnloadDriver?5END?6?$AA@FNODOBFM@ DB 'TCUnloadDriver'
	DB	' END', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BG@MGFDNIAG@TCUnloadDriver?5BEGIN?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BG@MGFDNIAG@TCUnloadDriver?5BEGIN?6?$AA@FNODOBFM@ DB 'TCUnloadDriv'
	DB	'er BEGIN', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BK@EIFNDPP@TCDeleteDeviceObject?5END?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BK@EIFNDPP@TCDeleteDeviceObject?5END?6?$AA@FNODOBFM@ DB 'TCDeleteD'
	DB	'eviceObject END', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EA@FPAPEGHJ@?$AAP?$AAs?$AAD?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAI?$AAm?$AAp?$AAe?$AAr?$AAs?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAk?$AAe?$AAn?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1EA@FPAPEGHJ@?$AAP?$AAs?$AAD?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAI?$AAm?$AAp?$AAe?$AAr?$AAs?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAk?$AAe?$AAn?$AA?$AA@FNODOBFM@ DB 'P'
	DB	00H, 's', 00H, 'D', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H
	DB	'e', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, 'I'
	DB	00H, 'm', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 's', 00H, 'o', 00H
	DB	'n', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'T'
	DB	00H, 'o', 00H, 'k', 00H, 'e', 00H, 'n', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CP@NIIDLADO@IoDeleteSymbolicLink?5failed?5ntSt@FNODOBFM@
text$s	SEGMENT
??_C@_0CP@NIIDLADO@IoDeleteSymbolicLink?5failed?5ntSt@FNODOBFM@ DB 'IoDel'
	DB	'eteSymbolicLink failed ntStatus = 0x%08x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'T', 00H, 'r'
	DB	00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r', 00H, 'y', 00H, 'p', 00H
	DB	't', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BM@GNHEHBJH@TCDeleteDeviceObject?5BEGIN?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BM@GNHEHBJH@TCDeleteDeviceObject?5BEGIN?6?$AA@FNODOBFM@ DB 'TCDele'
	DB	'teDeviceObject BEGIN', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1M@KHJOIALG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1M@KHJOIALG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA?$AA@FNODOBFM@ DB 'I', 00H
	DB	'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CM@DKLAEDLO@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAT?$AAR?$AAO?$AAL?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CM@DKLAEDLO@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAT?$AAR?$AAO?$AAL?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'R', 00H, 'P', 00H, '_', 00H, 'M', 00H, 'J', 00H, '_', 00H
	DB	'D', 00H, 'E', 00H, 'V', 00H, 'I', 00H, 'C', 00H, 'E', 00H, '_'
	DB	00H, 'C', 00H, 'O', 00H, 'N', 00H, 'T', 00H, 'R', 00H, 'O', 00H
	DB	'L', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CA@FOECGGNC@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAS?$AAH?$AAU?$AAT?$AAD?$AAO?$AAW?$AAN?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CA@FOECGGNC@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAS?$AAH?$AAU?$AAT?$AAD?$AAO?$AAW?$AAN?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'R', 00H, 'P', 00H, '_', 00H, 'M', 00H, 'J', 00H, '_', 00H
	DB	'S', 00H, 'H', 00H, 'U', 00H, 'T', 00H, 'D', 00H, 'O', 00H, 'W'
	DB	00H, 'N', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CK@MCKHKFDD@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAF?$AAL?$AAU?$AAS?$AAH?$AA_?$AAB?$AAU?$AAF?$AAF?$AAE?$AAR?$AAS?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CK@MCKHKFDD@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAF?$AAL?$AAU?$AAS?$AAH?$AA_?$AAB?$AAU?$AAF?$AAF?$AAE?$AAR?$AAS?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'R', 00H, 'P', 00H, '_', 00H, 'M', 00H, 'J', 00H, '_', 00H
	DB	'F', 00H, 'L', 00H, 'U', 00H, 'S', 00H, 'H', 00H, '_', 00H, 'B'
	DB	00H, 'U', 00H, 'F', 00H, 'F', 00H, 'E', 00H, 'R', 00H, 'S', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BO@GEGOKABG@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAL?$AAE?$AAA?$AAN?$AAU?$AAP?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BO@GEGOKABG@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAL?$AAE?$AAA?$AAN?$AAU?$AAP?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'R', 00H, 'P', 00H, '_', 00H, 'M', 00H, 'J', 00H, '_', 00H
	DB	'C', 00H, 'L', 00H, 'E', 00H, 'A', 00H, 'N', 00H, 'U', 00H, 'P'
	DB	00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BK@JLALPKNJ@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAL?$AAO?$AAS?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BK@JLALPKNJ@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAL?$AAO?$AAS?$AAE?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'R', 00H, 'P', 00H, '_', 00H, 'M', 00H, 'J', 00H, '_', 00H
	DB	'C', 00H, 'L', 00H, 'O', 00H, 'S', 00H, 'E', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BM@KFEHBPBD@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BM@KFEHBPBD@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'R', 00H, 'P', 00H, '_', 00H, 'M', 00H, 'J', 00H, '_', 00H
	DB	'C', 00H, 'R', 00H, 'E', 00H, 'A', 00H, 'T', 00H, 'E', 00H, 00H
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BK@HGBIKEDO@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAW?$AAR?$AAI?$AAT?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BK@HGBIKEDO@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAW?$AAR?$AAI?$AAT?$AAE?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'R', 00H, 'P', 00H, '_', 00H, 'M', 00H, 'J', 00H, '_', 00H
	DB	'W', 00H, 'R', 00H, 'I', 00H, 'T', 00H, 'E', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BI@CFPHGFDN@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAR?$AAE?$AAA?$AAD?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BI@CFPHGFDN@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAR?$AAE?$AAA?$AAD?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'R', 00H, 'P', 00H, '_', 00H, 'M', 00H, 'J', 00H, '_', 00H
	DB	'R', 00H, 'E', 00H, 'A', 00H, 'D', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DO@MEELNMKF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAO?$AAR?$AAA?$AAG?$AAE?$AA_?$AAS?$AAE?$AAT?$AA_?$AAH?$AAO?$AAT?$AAP?$AAL?$AAU?$AAG?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DO@MEELNMKF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAO?$AAR?$AAA?$AAG?$AAE?$AA_?$AAS?$AAE?$AAT?$AA_?$AAH?$AAO?$AAT?$AAP?$AAL?$AAU?$AAG?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'S', 00H
	DB	'T', 00H, 'O', 00H, 'R', 00H, 'A', 00H, 'G', 00H, 'E', 00H, '_'
	DB	00H, 'S', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'H', 00H, 'O', 00H
	DB	'T', 00H, 'P', 00H, 'L', 00H, 'U', 00H, 'G', 00H, '_', 00H, 'I'
	DB	00H, 'N', 00H, 'F', 00H, 'O', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DG@MIHPHMPG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA_?$AAT?$AAY?$AAP?$AAE?$AAS?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DG@MIHPHMPG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA_?$AAT?$AAY?$AAP?$AAE?$AAS?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T'
	DB	00H, '_', 00H, 'M', 00H, 'E', 00H, 'D', 00H, 'I', 00H, 'A', 00H
	DB	'_', 00H, 'T', 00H, 'Y', 00H, 'P', 00H, 'E', 00H, 'S', 00H, 00H
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DI@EBJJOMKC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAI?$AAN?$AAD?$AA_?$AAN?$AAE?$AAW?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AAS?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DI@EBJJOMKC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAI?$AAN?$AAD?$AA_?$AAN?$AAE?$AAW?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AAS?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'F', 00H, 'I', 00H, 'N'
	DB	00H, 'D', 00H, '_', 00H, 'N', 00H, 'E', 00H, 'W', 00H, '_', 00H
	DB	'D', 00H, 'E', 00H, 'V', 00H, 'I', 00H, 'C', 00H, 'E', 00H, 'S'
	DB	00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CG@BFEEHHEK@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAL?$AAE?$AAA?$AAS?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CG@BFEEHHEK@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAL?$AAE?$AAA?$AAS?$AAE?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'L'
	DB	00H, 'E', 00H, 'A', 00H, 'S', 00H, 'E', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CG@MJDBKCLM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAS?$AAE?$AAR?$AAV?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CG@MJDBKCLM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAS?$AAE?$AAR?$AAV?$AAE?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'S'
	DB	00H, 'E', 00H, 'R', 00H, 'V', 00H, 'E', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CM@GNBBIMEE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAL?$AAO?$AAA?$AAD?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CM@GNBBIMEE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAL?$AAO?$AAA?$AAD?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'L', 00H, 'O', 00H, 'A'
	DB	00H, 'D', 00H, '_', 00H, 'M', 00H, 'E', 00H, 'D', 00H, 'I', 00H
	DB	'A', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CO@KHEOABCH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAE?$AAJ?$AAE?$AAC?$AAT?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CO@KHEOABCH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAE?$AAJ?$AAE?$AAC?$AAT?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'E', 00H, 'J', 00H, 'E'
	DB	00H, 'C', 00H, 'T', 00H, '_', 00H, 'M', 00H, 'E', 00H, 'D', 00H
	DB	'I', 00H, 'A', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DC@NMJCPDJD@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA_?$AAR?$AAE?$AAM?$AAO?$AAV?$AAA?$AAL?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DC@NMJCPDJD@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA_?$AAR?$AAE?$AAM?$AAO?$AAV?$AAA?$AAL?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'M', 00H, 'E', 00H, 'D'
	DB	00H, 'I', 00H, 'A', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'M', 00H
	DB	'O', 00H, 'V', 00H, 'A', 00H, 'L', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DA@DLMBEKMN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAC?$AAH?$AAE?$AAC?$AAK?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DA@DLMBEKMN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAC?$AAH?$AAE?$AAC?$AAK?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'C', 00H, 'H', 00H, 'E'
	DB	00H, 'C', 00H, 'K', 00H, '_', 00H, 'V', 00H, 'E', 00H, 'R', 00H
	DB	'I', 00H, 'F', 00H, 'Y', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EC@JFOBAPGC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAN?$AAT?$AAE?$AAR?$AAN?$AAA?$AAL?$AA_?$AAC?$AAL?$AAE?$AAA?$AAR?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY@FNODOBFM@
text$s	SEGMENT
??_C@_1EC@JFOBAPGC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAN?$AAT?$AAE?$AAR?$AAN?$AAA?$AAL?$AA_?$AAC?$AAL?$AAE?$AAA?$AAR?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'I', 00H, 'N', 00H, 'T'
	DB	00H, 'E', 00H, 'R', 00H, 'N', 00H, 'A', 00H, 'L', 00H, '_', 00H
	DB	'C', 00H, 'L', 00H, 'E', 00H, 'A', 00H, 'R', 00H, '_', 00H, 'V'
	DB	00H, 'E', 00H, 'R', 00H, 'I', 00H, 'F', 00H, 'Y', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DO@JKPDDEIN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAN?$AAT?$AAE?$AAR?$AAN?$AAA?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DO@JKPDDEIN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAN?$AAT?$AAE?$AAR?$AAN?$AAA?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'I', 00H, 'N', 00H, 'T'
	DB	00H, 'E', 00H, 'R', 00H, 'N', 00H, 'A', 00H, 'L', 00H, '_', 00H
	DB	'S', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'V', 00H, 'E', 00H, 'R'
	DB	00H, 'I', 00H, 'F', 00H, 'Y', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CK@JCHEBCIE@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAR?$AAC?$AAV?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CK@JCHEBCIE@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAR?$AAC?$AAV?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@ DB 'S'
	DB	00H, 'M', 00H, 'A', 00H, 'R', 00H, 'T', 00H, '_', 00H, 'R', 00H
	DB	'C', 00H, 'V', 00H, '_', 00H, 'D', 00H, 'R', 00H, 'I', 00H, 'V'
	DB	00H, 'E', 00H, '_', 00H, 'D', 00H, 'A', 00H, 'T', 00H, 'A', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DC@MGFPICHJ@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAS?$AAE?$AAN?$AAD?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAC?$AAO?$AAM?$AAM?$AAA?$AAN?$AAD?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DC@MGFPICHJ@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAS?$AAE?$AAN?$AAD?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAC?$AAO?$AAM?$AAM?$AAA?$AAN?$AAD?$AA?$AA@FNODOBFM@ DB 'S'
	DB	00H, 'M', 00H, 'A', 00H, 'R', 00H, 'T', 00H, '_', 00H, 'S', 00H
	DB	'E', 00H, 'N', 00H, 'D', 00H, '_', 00H, 'D', 00H, 'R', 00H, 'I'
	DB	00H, 'V', 00H, 'E', 00H, '_', 00H, 'C', 00H, 'O', 00H, 'M', 00H
	DB	'M', 00H, 'A', 00H, 'N', 00H, 'D', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CE@PLNOGJJD@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CE@PLNOGJJD@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN?$AA?$AA@FNODOBFM@ DB 'S'
	DB	00H, 'M', 00H, 'A', 00H, 'R', 00H, 'T', 00H, '_', 00H, 'G', 00H
	DB	'E', 00H, 'T', 00H, '_', 00H, 'V', 00H, 'E', 00H, 'R', 00H, 'S'
	DB	00H, 'I', 00H, 'O', 00H, 'N', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DK@NNJOEKIN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAC?$AAO?$AAN?$AAT?$AAR?$AAO?$AAL?$AAL?$AAE?$AAR?$AA_?$AAN?$AAU?$AAM?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DK@NNJOEKIN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAC?$AAO?$AAN?$AAT?$AAR?$AAO?$AAL?$AAL?$AAE?$AAR?$AA_?$AAN?$AAU?$AAM?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'C', 00H, 'O', 00H, 'N'
	DB	00H, 'T', 00H, 'R', 00H, 'O', 00H, 'L', 00H, 'L', 00H, 'E', 00H
	DB	'R', 00H, '_', 00H, 'N', 00H, 'U', 00H, 'M', 00H, 'B', 00H, 'E'
	DB	00H, 'R', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DA@EGLLKJNO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAQ?$AAU?$AAE?$AAS?$AAT?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DA@EGLLKJNO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAQ?$AAU?$AAE?$AAS?$AAT?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'Q'
	DB	00H, 'U', 00H, 'E', 00H, 'S', 00H, 'T', 00H, '_', 00H, 'D', 00H
	DB	'A', 00H, 'T', 00H, 'A', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DK@EFIEFEEG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAQ?$AAU?$AAE?$AAS?$AAT?$AA_?$AAS?$AAT?$AAR?$AAU?$AAC?$AAT?$AAU?$AAR?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DK@EFIEFEEG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAQ?$AAU?$AAE?$AAS?$AAT?$AA_?$AAS?$AAT?$AAR?$AAU?$AAC?$AAT?$AAU?$AAR?$AAE?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'Q'
	DB	00H, 'U', 00H, 'E', 00H, 'S', 00H, 'T', 00H, '_', 00H, 'S', 00H
	DB	'T', 00H, 'R', 00H, 'U', 00H, 'C', 00H, 'T', 00H, 'U', 00H, 'R'
	DB	00H, 'E', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DG@BLHGEOGG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAR?$AAE?$AAS?$AAE?$AAT?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DG@BLHGEOGG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAR?$AAE?$AAS?$AAE?$AAT?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'H', 00H, 'I', 00H, 'S'
	DB	00H, 'T', 00H, 'O', 00H, 'G', 00H, 'R', 00H, 'A', 00H, 'M', 00H
	DB	'_', 00H, 'R', 00H, 'E', 00H, 'S', 00H, 'E', 00H, 'T', 00H, 00H
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DE@OGHADOL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DE@OGHADOL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'H', 00H, 'I', 00H, 'S'
	DB	00H, 'T', 00H, 'O', 00H, 'G', 00H, 'R', 00H, 'A', 00H, 'M', 00H
	DB	'_', 00H, 'D', 00H, 'A', 00H, 'T', 00H, 'A', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DO@JMICENAF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAS?$AAT?$AAR?$AAU?$AAC?$AAT?$AAU?$AAR?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DO@JMICENAF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAS?$AAT?$AAR?$AAU?$AAC?$AAT?$AAU?$AAR?$AAE?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'H', 00H, 'I', 00H, 'S'
	DB	00H, 'T', 00H, 'O', 00H, 'G', 00H, 'R', 00H, 'A', 00H, 'M', 00H
	DB	'_', 00H, 'S', 00H, 'T', 00H, 'R', 00H, 'U', 00H, 'C', 00H, 'T'
	DB	00H, 'U', 00H, 'R', 00H, 'E', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DI@LHHOILKE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAT?$AAR?$AAA?$AAC?$AAK?$AAS?$AA_?$AAE?$AAX?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DI@LHHOILKE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAT?$AAR?$AAA?$AAC?$AAK?$AAS?$AA_?$AAE?$AAX?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'F', 00H, 'O', 00H, 'R'
	DB	00H, 'M', 00H, 'A', 00H, 'T', 00H, '_', 00H, 'T', 00H, 'R', 00H
	DB	'A', 00H, 'C', 00H, 'K', 00H, 'S', 00H, '_', 00H, 'E', 00H, 'X'
	DB	00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CG@LCBFNDKM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAL?$AAO?$AAG?$AAG?$AAI?$AAN?$AAG?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CG@LCBFNDKM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAL?$AAO?$AAG?$AAG?$AAI?$AAN?$AAG?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'L', 00H, 'O', 00H, 'G'
	DB	00H, 'G', 00H, 'I', 00H, 'N', 00H, 'G', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CO@MFHKENAI@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAS?$AA_?$AAW?$AAR?$AAI?$AAT?$AAA?$AAB?$AAL?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CO@MFHKENAI@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAS?$AA_?$AAW?$AAR?$AAI?$AAT?$AAA?$AAB?$AAL?$AAE?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_'
	DB	00H, 'W', 00H, 'R', 00H, 'I', 00H, 'T', 00H, 'A', 00H, 'B', 00H
	DB	'L', 00H, 'E', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CO@LEDAJMII@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAP?$AAE?$AAR?$AAF?$AAO?$AAR?$AAM?$AAA?$AAN?$AAC?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CO@LEDAJMII@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAP?$AAE?$AAR?$AAF?$AAO?$AAR?$AAM?$AAA?$AAN?$AAC?$AAE?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'P', 00H, 'E', 00H, 'R'
	DB	00H, 'F', 00H, 'O', 00H, 'R', 00H, 'M', 00H, 'A', 00H, 'N', 00H
	DB	'C', 00H, 'E', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DG@HPLPDECO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAA?$AAS?$AAS?$AAI?$AAG?$AAN?$AA_?$AAB?$AAL?$AAO?$AAC?$AAK?$AAS?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DG@HPLPDECO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAA?$AAS?$AAS?$AAI?$AAG?$AAN?$AA_?$AAB?$AAL?$AAO?$AAC?$AAK?$AAS?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'A'
	DB	00H, 'S', 00H, 'S', 00H, 'I', 00H, 'G', 00H, 'N', 00H, '_', 00H
	DB	'B', 00H, 'L', 00H, 'O', 00H, 'C', 00H, 'K', 00H, 'S', 00H, 00H
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DC@PCKIDBBB@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAT?$AAR?$AAA?$AAC?$AAK?$AAS?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DC@PCKIDBBB@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAT?$AAR?$AAA?$AAC?$AAK?$AAS?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'F', 00H, 'O', 00H, 'R'
	DB	00H, 'M', 00H, 'A', 00H, 'T', 00H, '_', 00H, 'T', 00H, 'R', 00H
	DB	'A', 00H, 'C', 00H, 'K', 00H, 'S', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CE@LGEELOJE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CE@LGEELOJE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'V', 00H, 'E', 00H, 'R'
	DB	00H, 'I', 00H, 'F', 00H, 'Y', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DO@EPIDKIKJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAS?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAL?$AAA?$AAY?$AAO?$AAU?$AAT?$AA_?$AAE?$AAX?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DO@EPIDKIKJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAS?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAL?$AAA?$AAY?$AAO?$AAU?$AAT?$AA_?$AAE?$AAX?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'S', 00H, 'E', 00H, 'T'
	DB	00H, '_', 00H, 'D', 00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H
	DB	'_', 00H, 'L', 00H, 'A', 00H, 'Y', 00H, 'O', 00H, 'U', 00H, 'T'
	DB	00H, '_', 00H, 'E', 00H, 'X', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DI@CCDFFIEC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAL?$AAA?$AAY?$AAO?$AAU?$AAT?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DI@CCDFFIEC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAL?$AAA?$AAY?$AAO?$AAU?$AAT?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T'
	DB	00H, '_', 00H, 'D', 00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H
	DB	'_', 00H, 'L', 00H, 'A', 00H, 'Y', 00H, 'O', 00H, 'U', 00H, 'T'
	DB	00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DM@FAAIHMNH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAS?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DM@FAAIHMNH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAS?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'S', 00H, 'E', 00H, 'T'
	DB	00H, '_', 00H, 'P', 00H, 'A', 00H, 'R', 00H, 'T', 00H, 'I', 00H
	DB	'T', 00H, 'I', 00H, 'O', 00H, 'N', 00H, '_', 00H, 'I', 00H, 'N'
	DB	00H, 'F', 00H, 'O', 00H, 00H, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EC@CAILBHJF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA_?$AAE?$AAX@FNODOBFM@
text$s	SEGMENT
??_C@_1EC@CAILBHJF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA_?$AAE?$AAX@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T'
	DB	00H, '_', 00H, 'P', 00H, 'A', 00H, 'R', 00H, 'T', 00H, 'I', 00H
	DB	'T', 00H, 'I', 00H, 'O', 00H, 'N', 00H, '_', 00H, 'I', 00H, 'N'
	DB	00H, 'F', 00H, 'O', 00H, '_', 00H, 'E', 00H, 'X', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DM@LOAKHCPB@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DM@LOAKHCPB@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T'
	DB	00H, '_', 00H, 'P', 00H, 'A', 00H, 'R', 00H, 'T', 00H, 'I', 00H
	DB	'T', 00H, 'I', 00H, 'O', 00H, 'N', 00H, '_', 00H, 'I', 00H, 'N'
	DB	00H, 'F', 00H, 'O', 00H, 00H, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EA@IKPNDHCL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAO?$AAR?$AAA?$AAG?$AAE?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAN?$AAU?$AAM?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1EA@IKPNDHCL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAO?$AAR?$AAA?$AAG?$AAE?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAN?$AAU?$AAM?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'S', 00H
	DB	'T', 00H, 'O', 00H, 'R', 00H, 'A', 00H, 'G', 00H, 'E', 00H, '_'
	DB	00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'D', 00H, 'E', 00H
	DB	'V', 00H, 'I', 00H, 'C', 00H, 'E', 00H, '_', 00H, 'N', 00H, 'U'
	DB	00H, 'M', 00H, 'B', 00H, 'E', 00H, 'R', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DG@DLDFECDE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAL?$AAE?$AAN?$AAG?$AAT?$AAH?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DG@DLDFECDE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAL?$AAE?$AAN?$AAG?$AAT?$AAH?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T'
	DB	00H, '_', 00H, 'L', 00H, 'E', 00H, 'N', 00H, 'G', 00H, 'T', 00H
	DB	'H', 00H, '_', 00H, 'I', 00H, 'N', 00H, 'F', 00H, 'O', 00H, 00H
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1FE@EBMKFIFJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAP?$AAO?$AAI?$AAN@FNODOBFM@
text$s	SEGMENT
??_C@_1FE@EBMKFIFJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAP?$AAO?$AAI?$AAN@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'M', 00H, 'G', 00H, 'R'
	DB	00H, '_', 00H, 'V', 00H, 'O', 00H, 'L', 00H, 'U', 00H, 'M', 00H
	DB	'E', 00H, '_', 00H, 'M', 00H, 'O', 00H, 'U', 00H, 'N', 00H, 'T'
	DB	00H, '_', 00H, 'P', 00H, 'O', 00H, 'I', 00H, 'N', 00H, 'T', 00H
	DB	'_', 00H, 'D', 00H, 'E', 00H, 'L', 00H, 'E', 00H, 'T', 00H, 'E'
	DB	00H, 'D', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1FE@CLAOKMGL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAP?$AAO?$AAI?$AAN@FNODOBFM@
text$s	SEGMENT
??_C@_1FE@CLAOKMGL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAP?$AAO?$AAI?$AAN@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'M', 00H, 'G', 00H, 'R'
	DB	00H, '_', 00H, 'V', 00H, 'O', 00H, 'L', 00H, 'U', 00H, 'M', 00H
	DB	'E', 00H, '_', 00H, 'M', 00H, 'O', 00H, 'U', 00H, 'N', 00H, 'T'
	DB	00H, '_', 00H, 'P', 00H, 'O', 00H, 'I', 00H, 'N', 00H, 'T', 00H
	DB	'_', 00H, 'C', 00H, 'R', 00H, 'E', 00H, 'A', 00H, 'T', 00H, 'E'
	DB	00H, 'D', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DI@LFNEEBHO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAP?$AAO?$AAI?$AAN?$AAT?$AAS?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DI@LFNEEBHO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAP?$AAO?$AAI?$AAN?$AAT?$AAS?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'M', 00H, 'G', 00H, 'R'
	DB	00H, '_', 00H, 'Q', 00H, 'U', 00H, 'E', 00H, 'R', 00H, 'Y', 00H
	DB	'_', 00H, 'P', 00H, 'O', 00H, 'I', 00H, 'N', 00H, 'T', 00H, 'S'
	DB	00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DI@BMKMBCGO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAL?$AAI?$AAN?$AAK?$AA_?$AAD?$AAE?$AAL?$AAE?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DI@BMKMBCGO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAL?$AAI?$AAN?$AAK?$AA_?$AAD?$AAE?$AAL?$AAE?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'D', 00H, 'E', 00H, 'V'
	DB	00H, '_', 00H, 'L', 00H, 'I', 00H, 'N', 00H, 'K', 00H, '_', 00H
	DB	'D', 00H, 'E', 00H, 'L', 00H, 'E', 00H, 'T', 00H, 'E', 00H, 'D'
	DB	00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DI@HGGIOGFM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAL?$AAI?$AAN?$AAK?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DI@HGGIOGFM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAL?$AAI?$AAN?$AAK?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'D', 00H, 'E', 00H, 'V'
	DB	00H, '_', 00H, 'L', 00H, 'I', 00H, 'N', 00H, 'K', 00H, '_', 00H
	DB	'C', 00H, 'R', 00H, 'E', 00H, 'A', 00H, 'T', 00H, 'E', 00H, 'D'
	DB	00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CI@DJEMJCBH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAO?$AAN?$AAL?$AAI?$AAN?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CI@DJEMJCBH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAO?$AAN?$AAL?$AAI?$AAN?$AAE?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'V', 00H
	DB	'O', 00H, 'L', 00H, 'U', 00H, 'M', 00H, 'E', 00H, '_', 00H, 'O'
	DB	00H, 'N', 00H, 'L', 00H, 'I', 00H, 'N', 00H, 'E', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DO@OGNDJPNH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAU?$AAN?$AAI?$AAQ?$AAU?$AAE?$AA_?$AAI?$AAD?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DO@OGNDJPNH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAU?$AAN?$AAI?$AAQ?$AAU?$AAE?$AA_?$AAI?$AAD?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'D', 00H, 'E', 00H, 'V'
	DB	00H, '_', 00H, 'Q', 00H, 'U', 00H, 'E', 00H, 'R', 00H, 'Y', 00H
	DB	'_', 00H, 'U', 00H, 'N', 00H, 'I', 00H, 'Q', 00H, 'U', 00H, 'E'
	DB	00H, '_', 00H, 'I', 00H, 'D', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1FC@MNMCPAAJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAS?$AAU?$AAG?$AAG?$AAE?$AAS?$AAT?$AAE?$AAD?$AA_?$AAL@FNODOBFM@
text$s	SEGMENT
??_C@_1FC@MNMCPAAJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAS?$AAU?$AAG?$AAG?$AAE?$AAS?$AAT?$AAE?$AAD?$AA_?$AAL@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'D', 00H, 'E', 00H, 'V'
	DB	00H, '_', 00H, 'Q', 00H, 'U', 00H, 'E', 00H, 'R', 00H, 'Y', 00H
	DB	'_', 00H, 'S', 00H, 'U', 00H, 'G', 00H, 'G', 00H, 'E', 00H, 'S'
	DB	00H, 'T', 00H, 'E', 00H, 'D', 00H, '_', 00H, 'L', 00H, 'I', 00H
	DB	'N', 00H, 'K', 00H, '_', 00H, 'N', 00H, 'A', 00H, 'M', 00H, 'E'
	DB	00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EC@HFOIOEOM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAN?$AAA?$AAM?$AAE@FNODOBFM@
text$s	SEGMENT
??_C@_1EC@HFOIOEOM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAN?$AAA?$AAM?$AAE@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'D', 00H, 'E', 00H, 'V'
	DB	00H, '_', 00H, 'Q', 00H, 'U', 00H, 'E', 00H, 'R', 00H, 'Y', 00H
	DB	'_', 00H, 'D', 00H, 'E', 00H, 'V', 00H, 'I', 00H, 'C', 00H, 'E'
	DB	00H, '_', 00H, 'N', 00H, 'A', 00H, 'M', 00H, 'E', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EC@NPAFBAMN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA_?$AAE?$AAX@FNODOBFM@
text$s	SEGMENT
??_C@_1EC@NPAFBAMN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA_?$AAE?$AAX@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T'
	DB	00H, '_', 00H, 'D', 00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H
	DB	'_', 00H, 'G', 00H, 'E', 00H, 'O', 00H, 'M', 00H, 'E', 00H, 'T'
	DB	00H, 'R', 00H, 'Y', 00H, '_', 00H, 'E', 00H, 'X', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DM@KPKDNCHM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DM@KPKDNCHM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA?$AA@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'S', 00H, 'K', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T'
	DB	00H, '_', 00H, 'D', 00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H
	DB	'_', 00H, 'G', 00H, 'E', 00H, 'O', 00H, 'M', 00H, 'E', 00H, 'T'
	DB	00H, 'R', 00H, 'Y', 00H, 00H, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EK@FDCJEFAP@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAE?$AAX?$AAT@FNODOBFM@
text$s	SEGMENT
??_C@_1EK@FDCJEFAP@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAE?$AAX?$AAT@FNODOBFM@ DB 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, '_', 00H, 'V', 00H
	DB	'O', 00H, 'L', 00H, 'U', 00H, 'M', 00H, 'E', 00H, '_', 00H, 'G'
	DB	00H, 'E', 00H, 'T', 00H, '_', 00H, 'V', 00H, 'O', 00H, 'L', 00H
	DB	'U', 00H, 'M', 00H, 'E', 00H, '_', 00H, 'D', 00H, 'I', 00H, 'S'
	DB	00H, 'K', 00H, '_', 00H, 'E', 00H, 'X', 00H, 'T', 00H, 'E', 00H
	DB	'N', 00H, 'T', 00H, 'S', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EC@FOOPNHFI@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAW?$AAR?$AAI?$AAT?$AAE?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAS?$AAE?$AAC?$AAT?$AAO?$AAR@FNODOBFM@
text$s	SEGMENT
??_C@_1EC@FOOPNHFI@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAW?$AAR?$AAI?$AAT?$AAE?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAS?$AAE?$AAC?$AAT?$AAO?$AAR@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'W', 00H, 'R', 00H, 'I', 00H, 'T', 00H, 'E'
	DB	00H, '_', 00H, 'B', 00H, 'O', 00H, 'O', 00H, 'T', 00H, '_', 00H
	DB	'D', 00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H, '_', 00H, 'S'
	DB	00H, 'E', 00H, 'C', 00H, 'T', 00H, 'O', 00H, 'R', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DK@BNKDMLAM@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_?$AAP?$AAA?$AAS?$AAS?$AAW?$AAO?$AAR?$AAD?$AA_?$AAC?$AAA?$AAC?$AAH?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DK@BNKDMLAM@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_?$AAP?$AAA?$AAS?$AAS?$AAW?$AAO?$AAR?$AAD?$AA_?$AAC?$AAA?$AAC?$AAH?$AAE?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'W', 00H, 'I', 00H, 'P', 00H, 'E', 00H, '_'
	DB	00H, 'P', 00H, 'A', 00H, 'S', 00H, 'S', 00H, 'W', 00H, 'O', 00H
	DB	'R', 00H, 'D', 00H, '_', 00H, 'C', 00H, 'A', 00H, 'C', 00H, 'H'
	DB	00H, 'E', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EC@FGBEDIDI@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAA?$AAR?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE@FNODOBFM@
text$s	SEGMENT
??_C@_1EC@FGBEDIDI@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAA?$AAR?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'S', 00H, 'T', 00H, 'A', 00H, 'R', 00H, 'T'
	DB	00H, '_', 00H, 'D', 00H, 'E', 00H, 'C', 00H, 'O', 00H, 'Y', 00H
	DB	'_', 00H, 'S', 00H, 'Y', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M'
	DB	00H, '_', 00H, 'W', 00H, 'I', 00H, 'P', 00H, 'E', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1FE@EBAIHKDI@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAF?$AAA?$AAV?$AAO?$AAR?$AAI?$AAT?$AAE?$AA_?$AAV?$AAO?$AAL@FNODOBFM@
text$s	SEGMENT
??_C@_1FE@EBAIHKDI@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAF?$AAA?$AAV?$AAO?$AAR?$AAI?$AAT?$AAE?$AA_?$AAV?$AAO?$AAL@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'S', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'S'
	DB	00H, 'Y', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '_', 00H
	DB	'F', 00H, 'A', 00H, 'V', 00H, 'O', 00H, 'R', 00H, 'I', 00H, 'T'
	DB	00H, 'E', 00H, '_', 00H, 'V', 00H, 'O', 00H, 'L', 00H, 'U', 00H
	DB	'M', 00H, 'E', 00H, '_', 00H, 'D', 00H, 'I', 00H, 'R', 00H, 'T'
	DB	00H, 'Y', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DM@JFJLBNLP@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAR?$AAE?$AAR?$AAE?$AAA?$AAD?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DM@JFJLBNLP@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAR?$AAE?$AAR?$AAE?$AAA?$AAD?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'R', 00H, 'E', 00H, 'A'
	DB	00H, 'D', 00H, '_', 00H, 'D', 00H, 'R', 00H, 'I', 00H, 'V', 00H
	DB	'E', 00H, 'R', 00H, '_', 00H, 'C', 00H, 'O', 00H, 'N', 00H, 'F'
	DB	00H, 'I', 00H, 'G', 00H, 00H, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EG@GGODONFK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAR?$AAE?$AAO?$AAP?$AAE?$AAN?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAH?$AAE?$AAA?$AAD@FNODOBFM@
text$s	SEGMENT
??_C@_1EG@GGODONFK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAR?$AAE?$AAO?$AAP?$AAE?$AAN?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAH?$AAE?$AAA?$AAD@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'O', 00H, 'P', 00H, 'E'
	DB	00H, 'N', 00H, '_', 00H, 'B', 00H, 'O', 00H, 'O', 00H, 'T', 00H
	DB	'_', 00H, 'V', 00H, 'O', 00H, 'L', 00H, 'U', 00H, 'M', 00H, 'E'
	DB	00H, '_', 00H, 'H', 00H, 'E', 00H, 'A', 00H, 'D', 00H, 'E', 00H
	DB	'R', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DO@BKHLMLHN@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAP?$AAR?$AAO?$AAB?$AAE?$AA_?$AAR?$AAE?$AAA?$AAL?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DO@BKHLMLHN@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAP?$AAR?$AAO?$AAB?$AAE?$AA_?$AAR?$AAE?$AAA?$AAL?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'P', 00H, 'R', 00H, 'O', 00H, 'B', 00H, 'E'
	DB	00H, '_', 00H, 'R', 00H, 'E', 00H, 'A', 00H, 'L', 00H, '_', 00H
	DB	'D', 00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H, '_', 00H, 'S'
	DB	00H, 'I', 00H, 'Z', 00H, 'E', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CG@HPPKKEKP@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAO?$AAP?$AAE?$AAN?$AA_?$AAT?$AAE?$AAS?$AAT?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CG@HPPKKEKP@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAO?$AAP?$AAE?$AAN?$AA_?$AAT?$AAE?$AAS?$AAT?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'O', 00H, 'P', 00H, 'E', 00H, 'N', 00H, '_'
	DB	00H, 'T', 00H, 'E', 00H, 'S', 00H, 'T', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CM@HJCGFKAD@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CM@HJCGFKAD@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'M', 00H, 'O', 00H, 'U', 00H, 'N', 00H, 'T'
	DB	00H, '_', 00H, 'V', 00H, 'O', 00H, 'L', 00H, 'U', 00H, 'M', 00H
	DB	'E', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EE@HPDOLCKH@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAH?$AAI?$AAD?$AAD?$AAE?$AAN?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAR?$AAU?$AAN?$AAN?$AAI?$AAN@FNODOBFM@
text$s	SEGMENT
??_C@_1EE@HPDOLCKH@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAH?$AAI?$AAD?$AAD?$AAE?$AAN?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAR?$AAU?$AAN?$AAN?$AAI?$AAN@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'H', 00H, 'I'
	DB	00H, 'D', 00H, 'D', 00H, 'E', 00H, 'N', 00H, '_', 00H, 'S', 00H
	DB	'Y', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '_', 00H, 'R'
	DB	00H, 'U', 00H, 'N', 00H, 'N', 00H, 'I', 00H, 'N', 00H, 'G', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EG@HPLFHOOO@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAU?$AAN?$AAL?$AAO?$AAA?$AAD?$AA_?$AAD?$AAI?$AAS?$AAA?$AAB?$AAL@FNODOBFM@
text$s	SEGMENT
??_C@_1EG@HPLFHOOO@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAU?$AAN?$AAL?$AAO?$AAA?$AAD?$AA_?$AAD?$AAI?$AAS?$AAA?$AAB?$AAL@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'D', 00H, 'R'
	DB	00H, 'I', 00H, 'V', 00H, 'E', 00H, 'R', 00H, '_', 00H, 'U', 00H
	DB	'N', 00H, 'L', 00H, 'O', 00H, 'A', 00H, 'D', 00H, '_', 00H, 'D'
	DB	00H, 'I', 00H, 'S', 00H, 'A', 00H, 'B', 00H, 'L', 00H, 'E', 00H
	DB	'D', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DO@ICDMEENM@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAA?$AAN?$AAY?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DO@ICDMEENM@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAA?$AAN?$AAY?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'A', 00H, 'N'
	DB	00H, 'Y', 00H, '_', 00H, 'V', 00H, 'O', 00H, 'L', 00H, 'U', 00H
	DB	'M', 00H, 'E', 00H, '_', 00H, 'M', 00H, 'O', 00H, 'U', 00H, 'N'
	DB	00H, 'T', 00H, 'E', 00H, 'D', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DE@JNPINMHP@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAS?$AA_?$AAW?$AAR?$AAI?$AAT?$AAA?$AAB?$AAL?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DE@JNPINMHP@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAS?$AA_?$AAW?$AAR?$AAI?$AAT?$AAA?$AAB?$AAL?$AAE?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'D', 00H, 'I', 00H, 'S', 00H, 'K', 00H, '_'
	DB	00H, 'I', 00H, 'S', 00H, '_', 00H, 'W', 00H, 'R', 00H, 'I', 00H
	DB	'T', 00H, 'A', 00H, 'B', 00H, 'L', 00H, 'E', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DG@LBDEDPBA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAW?$AAA?$AAR?$AAN?$AAI?$AAN?$AAG?$AA_?$AAF?$AAL?$AAA?$AAG?$AAS?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DG@LBDEDPBA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAW?$AAA?$AAR?$AAN?$AAI?$AAN?$AAG?$AA_?$AAF?$AAL?$AAA?$AAG?$AAS?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'W'
	DB	00H, 'A', 00H, 'R', 00H, 'N', 00H, 'I', 00H, 'N', 00H, 'G', 00H
	DB	'_', 00H, 'F', 00H, 'L', 00H, 'A', 00H, 'G', 00H, 'S', 00H, 00H
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DO@DMIHGGIB@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAP?$AAR?$AAO?$AAP?$AAE?$AAR?$AAT?$AAI?$AAE?$AAS?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DO@DMIHGGIB@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAP?$AAR?$AAO?$AAP?$AAE?$AAR?$AAT?$AAI?$AAE?$AAS?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'V'
	DB	00H, 'O', 00H, 'L', 00H, 'U', 00H, 'M', 00H, 'E', 00H, '_', 00H
	DB	'P', 00H, 'R', 00H, 'O', 00H, 'P', 00H, 'E', 00H, 'R', 00H, 'T'
	DB	00H, 'I', 00H, 'E', 00H, 'S', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EM@GFDNBFC@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAD?$AAU?$AAM?$AAP?$AA_?$AAC@FNODOBFM@
text$s	SEGMENT
??_C@_1EM@GFDNBFC@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAD?$AAU?$AAM?$AAP?$AA_?$AAC@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'S'
	DB	00H, 'Y', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '_', 00H
	DB	'D', 00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H, '_', 00H, 'D'
	DB	00H, 'U', 00H, 'M', 00H, 'P', 00H, '_', 00H, 'C', 00H, 'O', 00H
	DB	'N', 00H, 'F', 00H, 'I', 00H, 'G', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DM@GFCMCNDC@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAR?$AAE?$AAS?$AAO?$AAL?$AAV?$AAE?$AAD?$AA_?$AAS?$AAY?$AAM?$AAL?$AAI?$AAN?$AAK?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DM@GFCMCNDC@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAR?$AAE?$AAS?$AAO?$AAL?$AAV?$AAE?$AAD?$AA_?$AAS?$AAY?$AAM?$AAL?$AAI?$AAN?$AAK?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'S', 00H, 'O', 00H, 'L', 00H, 'V', 00H, 'E', 00H
	DB	'D', 00H, '_', 00H, 'S', 00H, 'Y', 00H, 'M', 00H, 'L', 00H, 'I'
	DB	00H, 'N', 00H, 'K', 00H, 00H, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EE@NMKCMMBM@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAP?$AAO?$AAR?$AAT?$AAA?$AAB?$AAL?$AAE?$AA_?$AAM?$AAO?$AAD?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU@FNODOBFM@
text$s	SEGMENT
??_C@_1EE@NMKCMMBM@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAP?$AAO?$AAR?$AAT?$AAA?$AAB?$AAL?$AAE?$AA_?$AAM?$AAO?$AAD?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'S', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'P'
	DB	00H, 'O', 00H, 'R', 00H, 'T', 00H, 'A', 00H, 'B', 00H, 'L', 00H
	DB	'E', 00H, '_', 00H, 'M', 00H, 'O', 00H, 'D', 00H, 'E', 00H, '_'
	DB	00H, 'S', 00H, 'T', 00H, 'A', 00H, 'T', 00H, 'U', 00H, 'S', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EE@IPNJBDEG@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAO?$AAR?$AAT?$AAA?$AAB?$AAL?$AAE?$AA_?$AAM?$AAO?$AAD?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU@FNODOBFM@
text$s	SEGMENT
??_C@_1EE@IPNJBDEG@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAO?$AAR?$AAT?$AAA?$AAB?$AAL?$AAE?$AA_?$AAM?$AAO?$AAD?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'P'
	DB	00H, 'O', 00H, 'R', 00H, 'T', 00H, 'A', 00H, 'B', 00H, 'L', 00H
	DB	'E', 00H, '_', 00H, 'M', 00H, 'O', 00H, 'D', 00H, 'E', 00H, '_'
	DB	00H, 'S', 00H, 'T', 00H, 'A', 00H, 'T', 00H, 'U', 00H, 'S', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EC@FADHDJPK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG@FNODOBFM@
text$s	SEGMENT
??_C@_1EC@FADHDJPK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'S'
	DB	00H, 'Y', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '_', 00H
	DB	'D', 00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H, '_', 00H, 'C'
	DB	00H, 'O', 00H, 'N', 00H, 'F', 00H, 'I', 00H, 'G', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EG@LLJHBPJF@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAS?$AAS?$AAW?$AAO?$AAR?$AAD?$AA_?$AAC?$AAA?$AAC?$AAH?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT@FNODOBFM@
text$s	SEGMENT
??_C@_1EG@LLJHBPJF@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAS?$AAS?$AAW?$AAO?$AAR?$AAD?$AA_?$AAC?$AAA?$AAC?$AAH?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'P'
	DB	00H, 'A', 00H, 'S', 00H, 'S', 00H, 'W', 00H, 'O', 00H, 'R', 00H
	DB	'D', 00H, '_', 00H, 'C', 00H, 'A', 00H, 'C', 00H, 'H', 00H, 'E'
	DB	00H, '_', 00H, 'S', 00H, 'T', 00H, 'A', 00H, 'T', 00H, 'U', 00H
	DB	'S', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DK@KJKOFIJA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAE?$AAD?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AAS?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DK@KJKOFIJA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAE?$AAD?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AAS?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'M'
	DB	00H, 'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'E', 00H, 'D', 00H
	DB	'_', 00H, 'V', 00H, 'O', 00H, 'L', 00H, 'U', 00H, 'M', 00H, 'E'
	DB	00H, 'S', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DI@ODPPPDDO@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DI@ODPPPDDO@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'D'
	DB	00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H, 'R', 00H, '_', 00H
	DB	'V', 00H, 'E', 00H, 'R', 00H, 'S', 00H, 'I', 00H, 'O', 00H, 'N'
	DB	00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EE@HEELFNND@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF@FNODOBFM@
text$s	SEGMENT
??_C@_1EE@HEELFNND@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'D'
	DB	00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H, '_', 00H, 'P', 00H
	DB	'A', 00H, 'R', 00H, 'T', 00H, 'I', 00H, 'T', 00H, 'I', 00H, 'O'
	DB	00H, 'N', 00H, '_', 00H, 'I', 00H, 'N', 00H, 'F', 00H, 'O', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DI@LAIAIOML@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DI@LAIAIOML@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'D'
	DB	00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H, '_', 00H, 'G', 00H
	DB	'E', 00H, 'O', 00H, 'M', 00H, 'E', 00H, 'T', 00H, 'R', 00H, 'Y'
	DB	00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DK@DFEJGDBK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAR?$AAE?$AAF?$AAC?$AAO?$AAU?$AAN?$AAT?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DK@DFEJGDBK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAR?$AAE?$AAF?$AAC?$AAO?$AAU?$AAN?$AAT?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'D'
	DB	00H, 'E', 00H, 'V', 00H, 'I', 00H, 'C', 00H, 'E', 00H, '_', 00H
	DB	'R', 00H, 'E', 00H, 'F', 00H, 'C', 00H, 'O', 00H, 'U', 00H, 'N'
	DB	00H, 'T', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EM@LMAMOKGA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_?$AAS@FNODOBFM@
text$s	SEGMENT
??_C@_1EM@LMAMOKGA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_?$AAS@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'D'
	DB	00H, 'E', 00H, 'C', 00H, 'O', 00H, 'Y', 00H, '_', 00H, 'S', 00H
	DB	'Y', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '_', 00H, 'W'
	DB	00H, 'I', 00H, 'P', 00H, 'E', 00H, '_', 00H, 'S', 00H, 'T', 00H
	DB	'A', 00H, 'T', 00H, 'U', 00H, 'S', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EM@OAEBJACE@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_?$AAR@FNODOBFM@
text$s	SEGMENT
??_C@_1EM@OAEBJACE@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_?$AAR@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'D'
	DB	00H, 'E', 00H, 'C', 00H, 'O', 00H, 'Y', 00H, '_', 00H, 'S', 00H
	DB	'Y', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '_', 00H, 'W'
	DB	00H, 'I', 00H, 'P', 00H, 'E', 00H, '_', 00H, 'R', 00H, 'E', 00H
	DB	'S', 00H, 'U', 00H, 'L', 00H, 'T', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EC@OPCJHCIG@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAL?$AAO?$AAA?$AAD?$AAE?$AAR?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN@FNODOBFM@
text$s	SEGMENT
??_C@_1EC@OPCJHCIG@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAL?$AAO?$AAA?$AAD?$AAE?$AAR?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'B'
	DB	00H, 'O', 00H, 'O', 00H, 'T', 00H, '_', 00H, 'L', 00H, 'O', 00H
	DB	'A', 00H, 'D', 00H, 'E', 00H, 'R', 00H, '_', 00H, 'V', 00H, 'E'
	DB	00H, 'R', 00H, 'S', 00H, 'I', 00H, 'O', 00H, 'N', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EI@GAKLFLAF@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAT?$AAA@FNODOBFM@
text$s	SEGMENT
??_C@_1EI@GAKLFLAF@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAT?$AAA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'B'
	DB	00H, 'O', 00H, 'O', 00H, 'T', 00H, '_', 00H, 'E', 00H, 'N', 00H
	DB	'C', 00H, 'R', 00H, 'Y', 00H, 'P', 00H, 'T', 00H, 'I', 00H, 'O'
	DB	00H, 'N', 00H, '_', 00H, 'S', 00H, 'T', 00H, 'A', 00H, 'T', 00H
	DB	'U', 00H, 'S', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1FE@OJNNCONL@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAE?$AAT@FNODOBFM@
text$s	SEGMENT
??_C@_1FE@OJNNCONL@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAE?$AAT@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'B'
	DB	00H, 'O', 00H, 'O', 00H, 'T', 00H, '_', 00H, 'E', 00H, 'N', 00H
	DB	'C', 00H, 'R', 00H, 'Y', 00H, 'P', 00H, 'T', 00H, 'I', 00H, 'O'
	DB	00H, 'N', 00H, '_', 00H, 'S', 00H, 'E', 00H, 'T', 00H, 'U', 00H
	DB	'P', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'S', 00H, 'U', 00H, 'L'
	DB	00H, 'T', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1FI@CDJGLMPJ@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA?$AAL?$AAG@FNODOBFM@
text$s	SEGMENT
??_C@_1FI@CDJGLMPJ@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA?$AAL?$AAG@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'B'
	DB	00H, 'O', 00H, 'O', 00H, 'T', 00H, '_', 00H, 'E', 00H, 'N', 00H
	DB	'C', 00H, 'R', 00H, 'Y', 00H, 'P', 00H, 'T', 00H, 'I', 00H, 'O'
	DB	00H, 'N', 00H, '_', 00H, 'A', 00H, 'L', 00H, 'G', 00H, 'O', 00H
	DB	'R', 00H, 'I', 00H, 'T', 00H, 'H', 00H, 'M', 00H, '_', 00H, 'N'
	DB	00H, 'A', 00H, 'M', 00H, 'E', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1FE@BEJBLKBA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAP@FNODOBFM@
text$s	SEGMENT
??_C@_1FE@BEJBLKBA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAP@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_', 00H, 'B'
	DB	00H, 'O', 00H, 'O', 00H, 'T', 00H, '_', 00H, 'D', 00H, 'R', 00H
	DB	'I', 00H, 'V', 00H, 'E', 00H, '_', 00H, 'V', 00H, 'O', 00H, 'L'
	DB	00H, 'U', 00H, 'M', 00H, 'E', 00H, '_', 00H, 'P', 00H, 'R', 00H
	DB	'O', 00H, 'P', 00H, 'E', 00H, 'R', 00H, 'T', 00H, 'I', 00H, 'E'
	DB	00H, 'S', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DC@CLEBJPLG@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DC@CLEBJPLG@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'D', 00H, 'I', 00H, 'S', 00H, 'M', 00H, 'O'
	DB	00H, 'U', 00H, 'N', 00H, 'T', 00H, '_', 00H, 'V', 00H, 'O', 00H
	DB	'L', 00H, 'U', 00H, 'M', 00H, 'E', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DM@OLONGNGL@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAA?$AAL?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AAS?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DM@OLONGNGL@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAA?$AAL?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AAS?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'D', 00H, 'I', 00H, 'S', 00H, 'M', 00H, 'O'
	DB	00H, 'U', 00H, 'N', 00H, 'T', 00H, '_', 00H, 'A', 00H, 'L', 00H
	DB	'L', 00H, '_', 00H, 'V', 00H, 'O', 00H, 'L', 00H, 'U', 00H, 'M'
	DB	00H, 'E', 00H, 'S', 00H, 00H, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DO@JPMJPMCJ@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAE?$AAT?$AAU?$AAP?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DO@JPMJPMCJ@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAE?$AAT?$AAU?$AAP?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'B', 00H, 'O', 00H, 'O', 00H, 'T', 00H, '_'
	DB	00H, 'E', 00H, 'N', 00H, 'C', 00H, 'R', 00H, 'Y', 00H, 'P', 00H
	DB	'T', 00H, 'I', 00H, 'O', 00H, 'N', 00H, '_', 00H, 'S', 00H, 'E'
	DB	00H, 'T', 00H, 'U', 00H, 'P', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EC@HMNCILMA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAA?$AAB?$AAO?$AAR?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE@FNODOBFM@
text$s	SEGMENT
??_C@_1EC@HMNCILMA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAA?$AAB?$AAO?$AAR?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'A', 00H, 'B', 00H, 'O', 00H, 'R', 00H, 'T'
	DB	00H, '_', 00H, 'D', 00H, 'E', 00H, 'C', 00H, 'O', 00H, 'Y', 00H
	DB	'_', 00H, 'S', 00H, 'Y', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M'
	DB	00H, '_', 00H, 'W', 00H, 'I', 00H, 'P', 00H, 'E', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1EK@CMLLEBIK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAA?$AAB?$AAO?$AAR?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS@FNODOBFM@
text$s	SEGMENT
??_C@_1EK@CMLLEBIK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAA?$AAB?$AAO?$AAR?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS@FNODOBFM@ DB 'T'
	DB	00H, 'C', 00H, '_', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '_', 00H, 'A', 00H, 'B', 00H, 'O', 00H, 'R', 00H, 'T'
	DB	00H, '_', 00H, 'B', 00H, 'O', 00H, 'O', 00H, 'T', 00H, '_', 00H
	DB	'E', 00H, 'N', 00H, 'C', 00H, 'R', 00H, 'Y', 00H, 'P', 00H, 'T'
	DB	00H, 'I', 00H, 'O', 00H, 'N', 00H, '_', 00H, 'S', 00H, 'E', 00H
	DB	'T', 00H, 'U', 00H, 'P', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DA@GMJGMIMP@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DA@GMJGMIMP@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'T', 00H, 'r', 00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r'
	DB	00H, 'y', 00H, 'p', 00H, 't', 00H, 'V', 00H, 'o', 00H, 'l', 00H
	DB	'u', 00H, 'm', 00H, 'e', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BA@OMKHINCH@Closing?5volume?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BA@OMKHINCH@Closing?5volume?6?$AA@FNODOBFM@ DB 'Closing volume', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CO@PADHEFHE@irpSp?9?$DOMajorFunction?5?$DN?$DN?5IRP_MJ_D@FNODOBFM@
text$s	SEGMENT
??_C@_0CO@PADHEFHE@irpSp?9?$DOMajorFunction?5?$DN?$DN?5IRP_MJ_D@FNODOBFM@ DB 'i'
	DB	'rpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DO@GJJNBBEG@Mount?5THREAD?5request?5for?5File?5?$CFl@FNODOBFM@
text$s	SEGMENT
??_C@_0DO@GJJNBBEG@Mount?5THREAD?5request?5for?5File?5?$CFl@FNODOBFM@ DB 'M'
	DB	'ount THREAD request for File %ls DriveNumber %d Device = %d', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_19JHEHLFPM@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_19JHEHLFPM@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$AA@FNODOBFM@ DB '\', 00H
	DB	'?', 00H, '?', 00H, '\', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BA@CCLAPIHO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BA@CCLAPIHO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CD@LOGBEHKH@Mount?5THREAD?5OPENING?5VOLUME?5BEGI@FNODOBFM@
text$s	SEGMENT
??_C@_0CD@LOGBEHKH@Mount?5THREAD?5OPENING?5VOLUME?5BEGI@FNODOBFM@ DB 'Mou'
	DB	'nt THREAD OPENING VOLUME BEGIN', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0P@OPFPPFJJ@Thread?5exited?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0P@OPFPPFJJ@Thread?5exited?6?$AA@FNODOBFM@ DB 'Thread exited', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BG@MEOILBFO@NT_SUCCESS?5?$CIntStatus?$CJ?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BG@MEOILBFO@NT_SUCCESS?5?$CIntStatus?$CJ?$AA@FNODOBFM@ DB 'NT_SUCC'
	DB	'ESS (ntStatus)', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BO@IDJGLOL@Signalling?5thread?5to?5quit?4?4?4?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BO@IDJGLOL@Signalling?5thread?5to?5quit?4?4?4?6?$AA@FNODOBFM@ DB 'S'
	DB	'ignalling thread to quit...', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CK@KIOPBGEO@Waiting?5completed?$CB?5Thread?5return@FNODOBFM@
text$s	SEGMENT
??_C@_0CK@KIOPBGEO@Waiting?5completed?$CB?5Thread?5return@FNODOBFM@ DB 'W'
	DB	'aiting completed! Thread returns 0x%08x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CF@DMBFEFC@Waiting?5for?5thread?5to?5initialize@FNODOBFM@
text$s	SEGMENT
??_C@_0CF@DMBFEFC@Waiting?5for?5thread?5to?5initialize@FNODOBFM@ DB 'Wait'
	DB	'ing for thread to initialize...', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CB@DGOAIPAC@PsCreateSystemThread?5Failed?5END?6@FNODOBFM@
text$s	SEGMENT
??_C@_0CB@DGOAIPAC@PsCreateSystemThread?5Failed?5END?6@FNODOBFM@ DB 'PsCr'
	DB	'eateSystemThread Failed END', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BE@DCPHDOHD@Starting?5thread?4?4?4?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BE@DCPHDOHD@Starting?5thread?4?4?4?6?$AA@FNODOBFM@ DB 'Starting th'
	DB	'read...', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BE@MLCKFMJI@IOCTL?5error?50x?$CF08x?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BE@MLCKFMJI@IOCTL?5error?50x?$CF08x?6?$AA@FNODOBFM@ DB 'IOCTL erro'
	DB	'r 0x%08x', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BH@GFMHOPFN@Setting?5portable?5mode?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BH@GFMHOPFN@Setting?5portable?5mode?6?$AA@FNODOBFM@ DB 'Setting po'
	DB	'rtable mode', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CA@FCHCHJKN@Open?5test?5on?5file?5?$CFls?5success?4?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0CA@FCHCHJKN@Open?5test?5on?5file?5?$CFls?5success?4?6?$AA@FNODOBFM@ DB 'O'
	DB	'pen test on file %ls success.', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_09EMKKFGIH@TrueCrypt?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09EMKKFGIH@TrueCrypt?$AA@FNODOBFM@ DB 'TrueCrypt', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0L@FEEFGEIL@CipherShed?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0L@FEEFGEIL@CipherShed?$AA@FNODOBFM@ DB 'CipherShed', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BO@BEMMNDOD@IOCTL?5error?50x?$CF08x?5?$CI0x?$CFx?5?$CFd?$CJ?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BO@BEMMNDOD@IOCTL?5error?50x?$CF08x?5?$CI0x?$CFx?5?$CFd?$CJ?6?$AA@FNODOBFM@ DB 'I'
	DB	'OCTL error 0x%08x (0x%x %d)', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0M@HABEOOKA@link?5?$DN?5?$CFls?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0M@HABEOOKA@link?5?$DN?5?$CFls?6?$AA@FNODOBFM@ DB 'link = %ls', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_08DALLBBIL@id?5?$DN?5?$CFs?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_08DALLBBIL@id?5?$DN?5?$CFs?6?$AA@FNODOBFM@ DB 'id = %s', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@FNODOBFM@ DB 'TrueCryptVolume', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0M@FBJPBOL@name?5?$DN?5?$CFls?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0M@FBJPBOL@name?5?$DN?5?$CFls?6?$AA@FNODOBFM@ DB 'name = %ls', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CJ@CAANMOOG@TCCreateDeviceObject?5STATUS_SUCC@FNODOBFM@
text$s	SEGMENT
??_C@_0CJ@CAANMOOG@TCCreateDeviceObject?5STATUS_SUCC@FNODOBFM@ DB 'TCCrea'
	DB	'teDeviceObject STATUS_SUCCESS END', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CM@DAAJFNOI@TCCreateDeviceObject?5NTSTATUS?5?$DN?5@FNODOBFM@
text$s	SEGMENT
??_C@_0CM@DAAJFNOI@TCCreateDeviceObject?5NTSTATUS?5?$DN?5@FNODOBFM@ DB 'T'
	DB	'CCreateDeviceObject NTSTATUS = 0x%08x END', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CA@MBKOBJGH@Creating?5device?5nt?$DN?$CFls?5dos?$DN?$CFls?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0CA@MBKOBJGH@Creating?5device?5nt?$DN?$CFls?5dos?$DN?$CFls?6?$AA@FNODOBFM@ DB 'C'
	DB	'reating device nt=%ls dos=%ls', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BM@HAIECJHN@TCCreateDeviceObject?5BEGIN?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BM@HAIECJHN@TCCreateDeviceObject?5BEGIN?6?$AA@FNODOBFM@ DB 'TCCrea'
	DB	'teDeviceObject BEGIN', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CN@PMFMKKNC@TCCreateRootDeviceObject?5STATUS_@PBOPGDP@
INIT$s	SEGMENT
??_C@_0CN@PMFMKKNC@TCCreateRootDeviceObject?5STATUS_@PBOPGDP@ DB 'TCCreat'
	DB	'eRootDeviceObject STATUS_SUCCESS END', 0aH, 00H ;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0DA@OJGNPLJ@TCCreateRootDeviceObject?5NTSTATU@PBOPGDP@
INIT$s	SEGMENT
??_C@_0DA@OJGNPLJ@TCCreateRootDeviceObject?5NTSTATU@PBOPGDP@ DB 'TCCreate'
	DB	'RootDeviceObject NTSTATUS = 0x%08x END', 0aH, 00H ;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0CF@KMOPKHLE@Creating?5root?5device?5nt?$DN?$CFls?5dos?$DN@PBOPGDP@
INIT$s	SEGMENT
??_C@_0CF@KMOPKHLE@Creating?5root?5device?5nt?$DN?$CFls?5dos?$DN@PBOPGDP@ DB 'C'
	DB	'reating root device nt=%ls dos=%ls', 0aH, 00H ;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'T', 00H, 'r'
	DB	00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r', 00H, 'y', 00H, 'p', 00H
	DB	't', 00H, 00H, 00H				;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0CE@KKOENIAD@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5PASSIVE_LE@PBOPGDP@
INIT$s	SEGMENT
??_C@_0CE@KKOENIAD@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5PASSIVE_LE@PBOPGDP@ DB 'K'
	DB	'eGetCurrentIrql() == PASSIVE_LEVEL', 00H	;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@PBOPGDP@
INIT$s	SEGMENT
??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@PBOPGDP@ DB 'c:\'
	DB	'users\public\desktop\projects\ciphershed\src\driver\ntdriver.'
	DB	'c', 00H					;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0CA@NGANHIBM@TCCreateRootDeviceObject?5BEGIN?6?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_0CA@NGANHIBM@TCCreateRootDeviceObject?5BEGIN?6?$AA@PBOPGDP@ DB 'TCC'
	DB	'reateRootDeviceObject BEGIN', 0aH, 00H	;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@FNODOBFM@
text$s	SEGMENT
??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@FNODOBFM@ DB 'c:'
	DB	'\users\public\desktop\projects\ciphershed\src\driver\ntdriver'
	DB	'.c', 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EI@NJLFEPKD@Removable?5device?5?$CFd?5has?5DO_VERIF@FNODOBFM@
text$s	SEGMENT
??_C@_0EI@NJLFEPKD@Removable?5device?5?$CFd?5has?5DO_VERIF@FNODOBFM@ DB 'R'
	DB	'emovable device %d has DO_VERIFY_VOLUME flag: STATUS_DEVICE_N'
	DB	'OT_READY', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DA@HGPNLENJ@Device?5?$CFd?5shutting?5down?3?5STATUS_@FNODOBFM@
text$s	SEGMENT
??_C@_0DA@HGPNLENJ@Device?5?$CFd?5shutting?5down?3?5STATUS_@FNODOBFM@ DB 'D'
	DB	'evice %d shutting down: STATUS_DELETE_PENDING', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BG@JHFMBFJC@Driver?5shutting?5down?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BG@JHFMBFJC@Driver?5shutting?5down?6?$AA@FNODOBFM@ DB 'Driver shut'
	DB	'ting down', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0P@CMDFIGFB@?$CFls?5?$CI0x?$CFx?5?$CFd?$CJ?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0P@CMDFIGFB@?$CFls?5?$CI0x?$CFx?5?$CFd?$CJ?6?$AA@FNODOBFM@ DB '%ls '
	DB	'(0x%x %d)', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0FE@HIDEPCAO@STATUS_BUFFER_TOO_SMALL?5ioctl?$DN0x@FNODOBFM@
text$s	SEGMENT
??_C@_0FE@HIDEPCAO@STATUS_BUFFER_TOO_SMALL?5ioctl?$DN0x@FNODOBFM@ DB 'STA'
	DB	'TUS_BUFFER_TOO_SMALL ioctl=0x%x,%d in=%d out=%d reqsize=%d in'
	DB	'size=%d outsize=%d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DF@IHIBAGEA@0x?$CF08p?5?5?$CF02x?5?$CF02x?5?$CF02x?5?$CF02x?5?$CF02x@FNODOBFM@
text$s	SEGMENT
??_C@_0DF@IHIBAGEA@0x?$CF08p?5?5?$CF02x?5?$CF02x?5?$CF02x?5?$CF02x?5?$CF02x@FNODOBFM@ DB '0'
	DB	'x%08p  %02x %02x %02x %02x %02x %02x %02x %02x  %s', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BN@PIELMKDH@Volume?5pdo?$DN?$CFp?5interface?$DN?$CFws?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BN@PIELMKDH@Volume?5pdo?$DN?$CFp?5interface?$DN?$CFws?6?$AA@FNODOBFM@ DB 'V'
	DB	'olume pdo=%p interface=%ws', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CD@FCIMJPEM@AddDevice?5pdo?$DN?$CFp?5type?$DN?$CFx?5name?$DN?$CFw@FNODOBFM@
text$s	SEGMENT
??_C@_0CD@FCIMJPEM@AddDevice?5pdo?$DN?$CFp?5type?$DN?$CFx?5name?$DN?$CFw@FNODOBFM@ DB 'A'
	DB	'ddDevice pdo=%p type=%x name=%ws', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_13HGPDMIBE@?$AA?$DP?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_13HGPDMIBE@?$AA?$DP?$AA?$AA@FNODOBFM@ DB '?', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1M@IOJLKPKK@?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_1M@IOJLKPKK@?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@PBOPGDP@ DB 'S', 00H, 't'
	DB	00H, 'a', 00H, 'r', 00H, 't', 00H, 00H, 00H	;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'T', 00H, 'r', 00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r'
	DB	00H, 'y', 00H, 'p', 00H, 't', 00H, 00H, 00H	;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0CA@PHLKBPMP@DriverEntry?5CipherShed?50?47?44?41?6?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_0CA@PHLKBPMP@DriverEntry?5CipherShed?50?47?44?41?6?$AA@PBOPGDP@ DB 'D'
	DB	'riverEntry CipherShed 0.7.4.1', 0aH, 00H	;  ?? ::PBOPGDP::`string'
PUBLIC	IsOSAtLeast
;	COMDAT pdata
; File c:\users\public\desktop\projects\ciphershed\src\driver\ntdriver.c
pdata	SEGMENT
$pdata$IsOSAtLeast DD imagerel $LN18
	DD	imagerel $LN18+416
	DD	imagerel $unwind$IsOSAtLeast
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IsOSAtLeast DD 010801H
	DD	0a208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT IsOSAtLeast
_TEXT	SEGMENT
minor$ = 48
major$ = 52
tv69 = 56
tv70 = 60
tv85 = 64
reqMinOS$ = 96
IsOSAtLeast PROC					; COMDAT

; 3348 : {

$LN18:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3349 : 	/* When updating this function, update IsOSVersionAtLeast() in Dlgcode.c too. */
; 3350 : 
; 3351 : 	ULONG major = 0, minor = 0;

  00008	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR major$[rsp], 0
  00010	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR minor$[rsp], 0

; 3352 : 
; 3353 : 	ASSERT (OsMajorVersion != 0);

  00018	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR OsMajorVersion, 0
  0001f	75 27		 jne	 SHORT $LN13@IsOSAtLeas
  00021	45 33 c9	 xor	 r9d, r9d
  00024	41 b8 19 0d 00
	00		 mov	 r8d, 3353		; 00000d19H
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@JBJOLBIB@OsMajorVersion?5?$CB?$DN?50?$AA@FNODOBFM@
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  0003e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
  00046	eb 08		 jmp	 SHORT $LN14@IsOSAtLeas
$LN13@IsOSAtLeas:
  00048	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv69[rsp], 1
$LN14@IsOSAtLeas:

; 3354 : 
; 3355 : 	switch (reqMinOS)

  00050	8b 44 24 60	 mov	 eax, DWORD PTR reqMinOS$[rsp]
  00054	89 44 24 3c	 mov	 DWORD PTR tv70[rsp], eax
  00058	8b 44 24 3c	 mov	 eax, DWORD PTR tv70[rsp]
  0005c	83 e8 07	 sub	 eax, 7
  0005f	89 44 24 3c	 mov	 DWORD PTR tv70[rsp], eax
  00063	83 7c 24 3c 0c	 cmp	 DWORD PTR tv70[rsp], 12
  00068	0f 87 99 00 00
	00		 ja	 $LN1@IsOSAtLeas
  0006e	48 63 44 24 3c	 movsxd	 rax, DWORD PTR tv70[rsp]
  00073	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0007a	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN17@IsOSAtLeas[rcx+rax*4]
  00081	48 03 c1	 add	 rax, rcx
  00084	ff e0		 jmp	 rax
$LN8@IsOSAtLeas:

; 3356 : 	{
; 3357 : 	case WIN_2000:			major = 5; minor = 0; break;

  00086	c7 44 24 34 05
	00 00 00	 mov	 DWORD PTR major$[rsp], 5
  0008e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR minor$[rsp], 0
  00096	e9 8b 00 00 00	 jmp	 $LN9@IsOSAtLeas
$LN7@IsOSAtLeas:

; 3358 : 	case WIN_XP:			major = 5; minor = 1; break;

  0009b	c7 44 24 34 05
	00 00 00	 mov	 DWORD PTR major$[rsp], 5
  000a3	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR minor$[rsp], 1
  000ab	eb 79		 jmp	 SHORT $LN9@IsOSAtLeas
$LN6@IsOSAtLeas:

; 3359 : 	case WIN_SERVER_2003:	major = 5; minor = 2; break;

  000ad	c7 44 24 34 05
	00 00 00	 mov	 DWORD PTR major$[rsp], 5
  000b5	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR minor$[rsp], 2
  000bd	eb 67		 jmp	 SHORT $LN9@IsOSAtLeas
$LN5@IsOSAtLeas:

; 3360 : 	case WIN_VISTA:			major = 6; minor = 0; break;

  000bf	c7 44 24 34 06
	00 00 00	 mov	 DWORD PTR major$[rsp], 6
  000c7	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR minor$[rsp], 0
  000cf	eb 55		 jmp	 SHORT $LN9@IsOSAtLeas
$LN4@IsOSAtLeas:

; 3361 : 	case WIN_7:				major = 6; minor = 1; break;

  000d1	c7 44 24 34 06
	00 00 00	 mov	 DWORD PTR major$[rsp], 6
  000d9	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR minor$[rsp], 1
  000e1	eb 43		 jmp	 SHORT $LN9@IsOSAtLeas
$LN3@IsOSAtLeas:

; 3362 : 	case WIN_8:				major = 6; minor = 2; break;

  000e3	c7 44 24 34 06
	00 00 00	 mov	 DWORD PTR major$[rsp], 6
  000eb	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR minor$[rsp], 2
  000f3	eb 31		 jmp	 SHORT $LN9@IsOSAtLeas
$LN2@IsOSAtLeas:

; 3363 : 	case WIN_10:			major = 6; minor = 4; break;

  000f5	c7 44 24 34 06
	00 00 00	 mov	 DWORD PTR major$[rsp], 6
  000fd	c7 44 24 30 04
	00 00 00	 mov	 DWORD PTR minor$[rsp], 4
  00105	eb 1f		 jmp	 SHORT $LN9@IsOSAtLeas
$LN1@IsOSAtLeas:

; 3364 : 
; 3365 : 	default:
; 3366 : 		TC_THROW_FATAL_EXCEPTION;

  00107	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00110	45 33 c9	 xor	 r9d, r9d
  00113	45 33 c0	 xor	 r8d, r8d
  00116	ba 26 0d 00 00	 mov	 edx, 3366		; 00000d26H
  0011b	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  00120	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN9@IsOSAtLeas:

; 3367 : 		break;
; 3368 : 	}
; 3369 : 
; 3370 : 	return ((OsMajorVersion << 16 | OsMinorVersion << 8)
; 3371 : 		>= (major << 16 | minor << 8));

  00126	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR OsMajorVersion
  0012c	c1 e2 10	 shl	 edx, 16
  0012f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR OsMinorVersion
  00135	c1 e0 08	 shl	 eax, 8
  00138	0b d0		 or	 edx, eax
  0013a	8b 44 24 34	 mov	 eax, DWORD PTR major$[rsp]
  0013e	c1 e0 10	 shl	 eax, 16
  00141	8b 4c 24 30	 mov	 ecx, DWORD PTR minor$[rsp]
  00145	c1 e1 08	 shl	 ecx, 8
  00148	0b c1		 or	 eax, ecx
  0014a	3b d0		 cmp	 edx, eax
  0014c	72 0a		 jb	 SHORT $LN15@IsOSAtLeas
  0014e	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv85[rsp], 1
  00156	eb 08		 jmp	 SHORT $LN16@IsOSAtLeas
$LN15@IsOSAtLeas:
  00158	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv85[rsp], 0
$LN16@IsOSAtLeas:
  00160	8b 44 24 40	 mov	 eax, DWORD PTR tv85[rsp]
$LN12@IsOSAtLeas:

; 3372 : }

  00164	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00168	c3		 ret	 0
  00169	0f 1f 00	 npad	 3
$LN17@IsOSAtLeas:
  0016c	00 00 00 00	 DD	 $LN8@IsOSAtLeas
  00170	00 00 00 00	 DD	 $LN7@IsOSAtLeas
  00174	00 00 00 00	 DD	 $LN1@IsOSAtLeas
  00178	00 00 00 00	 DD	 $LN6@IsOSAtLeas
  0017c	00 00 00 00	 DD	 $LN5@IsOSAtLeas
  00180	00 00 00 00	 DD	 $LN1@IsOSAtLeas
  00184	00 00 00 00	 DD	 $LN4@IsOSAtLeas
  00188	00 00 00 00	 DD	 $LN1@IsOSAtLeas
  0018c	00 00 00 00	 DD	 $LN3@IsOSAtLeas
  00190	00 00 00 00	 DD	 $LN1@IsOSAtLeas
  00194	00 00 00 00	 DD	 $LN1@IsOSAtLeas
  00198	00 00 00 00	 DD	 $LN1@IsOSAtLeas
  0019c	00 00 00 00	 DD	 $LN2@IsOSAtLeas
IsOSAtLeast ENDP
_TEXT	ENDS
PUBLIC	TCReadRegistryKey
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCReadRegistryKey DD imagerel $LN7
	DD	imagerel $LN7+443
	DD	imagerel $unwind$TCReadRegistryKey
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCReadRegistryKey DD 021601H
	DD	0130116H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT TCReadRegistryKey
_TEXT	SEGMENT
regObjAttribs$ = 48
size$ = 96
valName$ = 104
regKeyHandle$ = 120
status$ = 128
resultSize$ = 132
keyPath$ = 160
keyValueName$ = 168
keyData$ = 176
TCReadRegistryKey PROC					; COMDAT

; 3042 : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 3043 : 	OBJECT_ATTRIBUTES regObjAttribs;
; 3044 : 	HANDLE regKeyHandle;
; 3045 : 	NTSTATUS status;
; 3046 : 	UNICODE_STRING valName;
; 3047 : 	ULONG size = 0;

  00016	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR size$[rsp], 0

; 3048 : 	ULONG resultSize;
; 3049 : 
; 3050 : 	InitializeObjectAttributes (&regObjAttribs, keyPath, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

  0001e	c7 44 24 30 30
	00 00 00	 mov	 DWORD PTR regObjAttribs$[rsp], 48 ; 00000030H
  00026	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR regObjAttribs$[rsp+8], 0
  0002f	c7 44 24 48 40
	02 00 00	 mov	 DWORD PTR regObjAttribs$[rsp+24], 576 ; 00000240H
  00037	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR keyPath$[rsp]
  0003f	48 89 44 24 40	 mov	 QWORD PTR regObjAttribs$[rsp+16], rax
  00044	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR regObjAttribs$[rsp+32], 0
  0004d	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR regObjAttribs$[rsp+40], 0

; 3051 : 	status = ZwOpenKey (&regKeyHandle, KEY_READ, &regObjAttribs);

  00056	4c 8d 44 24 30	 lea	 r8, QWORD PTR regObjAttribs$[rsp]
  0005b	ba 19 00 02 00	 mov	 edx, 131097		; 00020019H
  00060	48 8d 4c 24 78	 lea	 rcx, QWORD PTR regKeyHandle$[rsp]
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwOpenKey
  0006b	89 84 24 80 00
	00 00		 mov	 DWORD PTR status$[rsp], eax

; 3052 : 	if (!NT_SUCCESS (status))

  00072	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR status$[rsp], 0
  0007a	7d 0c		 jge	 SHORT $LN4@TCReadRegi

; 3053 : 		return status;

  0007c	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR status$[rsp]
  00083	e9 2b 01 00 00	 jmp	 $LN5@TCReadRegi
$LN4@TCReadRegi:

; 3054 : 
; 3055 : 	RtlInitUnicodeString (&valName, keyValueName);

  00088	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR keyValueName$[rsp]
  00090	48 8d 4c 24 68	 lea	 rcx, QWORD PTR valName$[rsp]
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 3056 : 	status = ZwQueryValueKey (regKeyHandle, &valName, KeyValuePartialInformation, NULL, 0, &size);

  0009b	4c 8d 5c 24 60	 lea	 r11, QWORD PTR size$[rsp]
  000a0	4c 89 5c 24 28	 mov	 QWORD PTR [rsp+40], r11
  000a5	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  000ad	45 33 c9	 xor	 r9d, r9d
  000b0	41 b8 02 00 00
	00		 mov	 r8d, 2
  000b6	48 8d 54 24 68	 lea	 rdx, QWORD PTR valName$[rsp]
  000bb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regKeyHandle$[rsp]
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwQueryValueKey
  000c6	89 84 24 80 00
	00 00		 mov	 DWORD PTR status$[rsp], eax

; 3057 : 		
; 3058 : 	if (!NT_SUCCESS (status) && status != STATUS_BUFFER_OVERFLOW && status != STATUS_BUFFER_TOO_SMALL)

  000cd	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR status$[rsp], 0
  000d5	7d 31		 jge	 SHORT $LN3@TCReadRegi
  000d7	81 bc 24 80 00
	00 00 05 00 00
	80		 cmp	 DWORD PTR status$[rsp], -2147483643 ; ffffffff80000005H
  000e2	74 24		 je	 SHORT $LN3@TCReadRegi
  000e4	81 bc 24 80 00
	00 00 23 00 00
	c0		 cmp	 DWORD PTR status$[rsp], -1073741789 ; ffffffffc0000023H
  000ef	74 17		 je	 SHORT $LN3@TCReadRegi

; 3059 : 	{
; 3060 : 		ZwClose (regKeyHandle);

  000f1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regKeyHandle$[rsp]
  000f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 3061 : 		return status;

  000fc	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR status$[rsp]
  00103	e9 ab 00 00 00	 jmp	 $LN5@TCReadRegi
$LN3@TCReadRegi:

; 3062 : 	}
; 3063 : 
; 3064 : 	if (size == 0)

  00108	83 7c 24 60 00	 cmp	 DWORD PTR size$[rsp], 0
  0010d	75 15		 jne	 SHORT $LN2@TCReadRegi

; 3065 : 	{
; 3066 : 		ZwClose (regKeyHandle);

  0010f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regKeyHandle$[rsp]
  00114	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 3067 : 		return STATUS_NO_DATA_DETECTED;

  0011a	b8 22 00 00 80	 mov	 eax, -2147483614	; ffffffff80000022H
  0011f	e9 8f 00 00 00	 jmp	 $LN5@TCReadRegi
$LN2@TCReadRegi:

; 3068 : 	}
; 3069 : 
; 3070 : 	*keyData = (PKEY_VALUE_PARTIAL_INFORMATION) TCalloc (size);

  00124	8b 54 24 60	 mov	 edx, DWORD PTR size$[rsp]
  00128	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  0012e	33 c9		 xor	 ecx, ecx
  00130	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00136	4c 8b d8	 mov	 r11, rax
  00139	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR keyData$[rsp]
  00141	4c 89 18	 mov	 QWORD PTR [rax], r11

; 3071 : 	if (!*keyData)

  00144	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR keyData$[rsp]
  0014c	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00150	75 12		 jne	 SHORT $LN1@TCReadRegi

; 3072 : 	{
; 3073 : 		ZwClose (regKeyHandle);

  00152	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regKeyHandle$[rsp]
  00157	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 3074 : 		return STATUS_INSUFFICIENT_RESOURCES;

  0015d	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  00162	eb 4f		 jmp	 SHORT $LN5@TCReadRegi
$LN1@TCReadRegi:

; 3075 : 	}
; 3076 : 
; 3077 : 	status = ZwQueryValueKey (regKeyHandle, &valName, KeyValuePartialInformation, *keyData, size, &resultSize);

  00164	48 8d 84 24 84
	00 00 00	 lea	 rax, QWORD PTR resultSize$[rsp]
  0016c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00171	8b 44 24 60	 mov	 eax, DWORD PTR size$[rsp]
  00175	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00179	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR keyData$[rsp]
  00181	4d 8b 09	 mov	 r9, QWORD PTR [r9]
  00184	41 b8 02 00 00
	00		 mov	 r8d, 2
  0018a	48 8d 54 24 68	 lea	 rdx, QWORD PTR valName$[rsp]
  0018f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regKeyHandle$[rsp]
  00194	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwQueryValueKey
  0019a	89 84 24 80 00
	00 00		 mov	 DWORD PTR status$[rsp], eax

; 3078 : 
; 3079 : 	ZwClose (regKeyHandle);

  001a1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regKeyHandle$[rsp]
  001a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 3080 : 	return status;

  001ac	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR status$[rsp]
$LN5@TCReadRegi:

; 3081 : }

  001b3	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  001ba	c3		 ret	 0
TCReadRegistryKey ENDP
_TEXT	ENDS
PUBLIC	EnsureNullTerminatedString
;	COMDAT pdata
pdata	SEGMENT
$pdata$EnsureNullTerminatedString DD imagerel $LN5
	DD	imagerel $LN5+111
	DD	imagerel $unwind$EnsureNullTerminatedString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EnsureNullTerminatedString DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EnsureNullTerminatedString
_TEXT	SEGMENT
tv70 = 32
str$ = 64
maxSizeInBytes$ = 72
EnsureNullTerminatedString PROC				; COMDAT

; 3010 : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3011 : 	ASSERT ((maxSizeInBytes & 1) == 0);

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR maxSizeInBytes$[rsp]
  00013	48 83 e0 01	 and	 rax, 1
  00017	48 85 c0	 test	 rax, rax
  0001a	74 27		 je	 SHORT $LN3@EnsureNull
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 c3 0b 00
	00		 mov	 r8d, 3011		; 00000bc3H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BGEEJMHD@?$CImaxSizeInBytes?5?$CG?51?$CJ?5?$DN?$DN?50?$AA@FNODOBFM@
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  00039	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00041	eb 08		 jmp	 SHORT $LN4@EnsureNull
$LN3@EnsureNull:
  00043	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
$LN4@EnsureNull:

; 3012 : 	str[maxSizeInBytes / sizeof (wchar_t) - 1] = 0;

  0004b	33 d2		 xor	 edx, edx
  0004d	48 8b 44 24 48	 mov	 rax, QWORD PTR maxSizeInBytes$[rsp]
  00052	b9 02 00 00 00	 mov	 ecx, 2
  00057	48 f7 f1	 div	 rcx
  0005a	4c 8b c0	 mov	 r8, rax
  0005d	33 c9		 xor	 ecx, ecx
  0005f	48 8b 44 24 40	 mov	 rax, QWORD PTR str$[rsp]
  00064	66 42 89 4c 40
	fe		 mov	 WORD PTR [rax+r8*2-2], cx

; 3013 : }

  0006a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006e	c3		 ret	 0
EnsureNullTerminatedString ENDP
_TEXT	ENDS
PUBLIC	GetCpuCount
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetCpuCount DD imagerel $LN7
	DD	imagerel $LN7+130
	DD	imagerel $unwind$GetCpuCount
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetCpuCount DD 010401H
	DD	08204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GetCpuCount
_TEXT	SEGMENT
mapSize$ = 32
activeCpuMap$ = 40
cpuCount$ = 48
GetCpuCount PROC					; COMDAT

; 2989 : {

$LN7:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2990 : 	KAFFINITY activeCpuMap = KeQueryActiveProcessors();

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeQueryActiveProcessors
  0000a	48 89 44 24 28	 mov	 QWORD PTR activeCpuMap$[rsp], rax

; 2991 : 	size_t mapSize = sizeof (activeCpuMap) * 8;

  0000f	48 c7 44 24 20
	40 00 00 00	 mov	 QWORD PTR mapSize$[rsp], 64 ; 00000040H

; 2992 : 	size_t cpuCount = 0;

  00018	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR cpuCount$[rsp], 0
$LN4@GetCpuCoun:

; 2993 : 
; 2994 : 	while (mapSize--)

  00021	48 8b 4c 24 20	 mov	 rcx, QWORD PTR mapSize$[rsp]
  00026	48 8b 44 24 20	 mov	 rax, QWORD PTR mapSize$[rsp]
  0002b	48 83 e8 01	 sub	 rax, 1
  0002f	48 89 44 24 20	 mov	 QWORD PTR mapSize$[rsp], rax
  00034	48 85 c9	 test	 rcx, rcx
  00037	74 2b		 je	 SHORT $LN3@GetCpuCoun

; 2995 : 	{
; 2996 : 		if (activeCpuMap & 1)

  00039	48 8b 44 24 28	 mov	 rax, QWORD PTR activeCpuMap$[rsp]
  0003e	48 83 e0 01	 and	 rax, 1
  00042	48 85 c0	 test	 rax, rax
  00045	74 0e		 je	 SHORT $LN2@GetCpuCoun

; 2997 : 			++cpuCount;

  00047	48 8b 44 24 30	 mov	 rax, QWORD PTR cpuCount$[rsp]
  0004c	48 83 c0 01	 add	 rax, 1
  00050	48 89 44 24 30	 mov	 QWORD PTR cpuCount$[rsp], rax
$LN2@GetCpuCoun:

; 2998 : 
; 2999 : 		activeCpuMap >>= 1;

  00055	48 8b 44 24 28	 mov	 rax, QWORD PTR activeCpuMap$[rsp]
  0005a	48 d1 e8	 shr	 rax, 1
  0005d	48 89 44 24 28	 mov	 QWORD PTR activeCpuMap$[rsp], rax

; 3000 : 	}

  00062	eb bd		 jmp	 SHORT $LN4@GetCpuCoun
$LN3@GetCpuCoun:

; 3001 : 
; 3002 : 	if (cpuCount == 0)

  00064	48 83 7c 24 30
	00		 cmp	 QWORD PTR cpuCount$[rsp], 0
  0006a	75 0c		 jne	 SHORT $LN1@GetCpuCoun

; 3003 : 		return 1;

  0006c	48 b8 01 00 00
	00 00 00 00 00	 mov	 rax, 1
  00076	eb 05		 jmp	 SHORT $LN5@GetCpuCoun
$LN1@GetCpuCoun:

; 3004 : 
; 3005 : 	return cpuCount;

  00078	48 8b 44 24 30	 mov	 rax, QWORD PTR cpuCount$[rsp]
$LN5@GetCpuCoun:

; 3006 : }

  0007d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00081	c3		 ret	 0
GetCpuCount ENDP
_TEXT	ENDS
PUBLIC	TCCompleteDiskIrp
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCCompleteDiskIrp DD imagerel $LN5
	DD	imagerel $LN5+94
	DD	imagerel $unwind$TCCompleteDiskIrp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCCompleteDiskIrp DD 011201H
	DD	06212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT TCCompleteDiskIrp
_TEXT	SEGMENT
tv67 = 32
irp$ = 64
status$ = 72
information$ = 80
TCCompleteDiskIrp PROC					; COMDAT

; 2980 : {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2981 : 	irp->IoStatus.Status = status;

  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR irp$[rsp]
  00017	8b 44 24 48	 mov	 eax, DWORD PTR status$[rsp]
  0001b	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 2982 : 	irp->IoStatus.Information = information;

  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR irp$[rsp]
  00023	48 8b 44 24 50	 mov	 rax, QWORD PTR information$[rsp]
  00028	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 2983 : 	IoCompleteRequest (irp, NT_SUCCESS (status) ? IO_DISK_INCREMENT : IO_NO_INCREMENT);

  0002c	83 7c 24 48 00	 cmp	 DWORD PTR status$[rsp], 0
  00031	7c 0a		 jl	 SHORT $LN3@TCComplete
  00033	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv67[rsp], 1
  0003b	eb 08		 jmp	 SHORT $LN4@TCComplete
$LN3@TCComplete:
  0003d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv67[rsp], 0
$LN4@TCComplete:
  00045	0f b6 54 24 20	 movzx	 edx, BYTE PTR tv67[rsp]
  0004a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR irp$[rsp]
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 2984 : 	return status;

  00055	8b 44 24 48	 mov	 eax, DWORD PTR status$[rsp]

; 2985 : }

  00059	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005d	c3		 ret	 0
TCCompleteDiskIrp ENDP
_TEXT	ENDS
PUBLIC	TCCompleteIrp
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCCompleteIrp DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$TCCompleteIrp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCCompleteIrp DD 011201H
	DD	04212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT TCCompleteIrp
_TEXT	SEGMENT
irp$ = 48
status$ = 56
information$ = 64
TCCompleteIrp PROC					; COMDAT

; 2971 : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2972 : 	irp->IoStatus.Status = status;

  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR irp$[rsp]
  00017	8b 44 24 38	 mov	 eax, DWORD PTR status$[rsp]
  0001b	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 2973 : 	irp->IoStatus.Information = information;

  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR irp$[rsp]
  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR information$[rsp]
  00028	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 2974 : 	IoCompleteRequest (irp, IO_NO_INCREMENT);

  0002c	33 d2		 xor	 edx, edx
  0002e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR irp$[rsp]
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 2975 : 	return status;

  00039	8b 44 24 38	 mov	 eax, DWORD PTR status$[rsp]

; 2976 : }

  0003d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00041	c3		 ret	 0
TCCompleteIrp ENDP
_TEXT	ENDS
PUBLIC	GetIntersection
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetIntersection DD imagerel $LN10
	DD	imagerel $LN10+217
	DD	imagerel $unwind$GetIntersection
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetIntersection DD 011701H
	DD	06217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GetIntersection
_TEXT	SEGMENT
intersectEnd$ = 0
end1$ = 8
tv68 = 16
tv70 = 24
tv74 = 32
start1$ = 64
length1$ = 72
start2$ = 80
end2$ = 88
intersectStart$ = 96
intersectLength$ = 104
GetIntersection PROC					; COMDAT

; 2881 : {

$LN10:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2882 : 	uint64 end1 = start1 + length1 - 1;

  00017	8b 4c 24 48	 mov	 ecx, DWORD PTR length1$[rsp]
  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR start1$[rsp]
  00020	48 8d 44 08 ff	 lea	 rax, QWORD PTR [rax+rcx-1]
  00025	48 89 44 24 08	 mov	 QWORD PTR end1$[rsp], rax

; 2883 : 	uint64 intersectEnd = (end1 <= end2) ? end1 : end2;

  0002a	48 8b 44 24 58	 mov	 rax, QWORD PTR end2$[rsp]
  0002f	48 39 44 24 08	 cmp	 QWORD PTR end1$[rsp], rax
  00034	77 0c		 ja	 SHORT $LN4@GetInterse
  00036	48 8b 44 24 08	 mov	 rax, QWORD PTR end1$[rsp]
  0003b	48 89 44 24 10	 mov	 QWORD PTR tv68[rsp], rax
  00040	eb 0a		 jmp	 SHORT $LN5@GetInterse
$LN4@GetInterse:
  00042	48 8b 44 24 58	 mov	 rax, QWORD PTR end2$[rsp]
  00047	48 89 44 24 10	 mov	 QWORD PTR tv68[rsp], rax
$LN5@GetInterse:
  0004c	48 8b 44 24 10	 mov	 rax, QWORD PTR tv68[rsp]
  00051	48 89 04 24	 mov	 QWORD PTR intersectEnd$[rsp], rax

; 2884 : 	
; 2885 : 	*intersectStart = (start1 >= start2) ? start1 : start2;

  00055	48 8b 44 24 50	 mov	 rax, QWORD PTR start2$[rsp]
  0005a	48 39 44 24 40	 cmp	 QWORD PTR start1$[rsp], rax
  0005f	72 0c		 jb	 SHORT $LN6@GetInterse
  00061	48 8b 44 24 40	 mov	 rax, QWORD PTR start1$[rsp]
  00066	48 89 44 24 18	 mov	 QWORD PTR tv70[rsp], rax
  0006b	eb 0a		 jmp	 SHORT $LN7@GetInterse
$LN6@GetInterse:
  0006d	48 8b 44 24 50	 mov	 rax, QWORD PTR start2$[rsp]
  00072	48 89 44 24 18	 mov	 QWORD PTR tv70[rsp], rax
$LN7@GetInterse:
  00077	48 8b 4c 24 60	 mov	 rcx, QWORD PTR intersectStart$[rsp]
  0007c	48 8b 44 24 18	 mov	 rax, QWORD PTR tv70[rsp]
  00081	48 89 01	 mov	 QWORD PTR [rcx], rax

; 2886 : 	*intersectLength = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);

  00084	48 8b 4c 24 60	 mov	 rcx, QWORD PTR intersectStart$[rsp]
  00089	48 8b 04 24	 mov	 rax, QWORD PTR intersectEnd$[rsp]
  0008d	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00090	76 0b		 jbe	 SHORT $LN8@GetInterse
  00092	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR tv74[rsp], 0
  0009b	eb 15		 jmp	 SHORT $LN9@GetInterse
$LN8@GetInterse:
  0009d	48 8b 04 24	 mov	 rax, QWORD PTR intersectEnd$[rsp]
  000a1	48 83 c0 01	 add	 rax, 1
  000a5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR intersectStart$[rsp]
  000aa	48 2b 01	 sub	 rax, QWORD PTR [rcx]
  000ad	48 89 44 24 20	 mov	 QWORD PTR tv74[rsp], rax
$LN9@GetInterse:
  000b2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR intersectLength$[rsp]
  000b7	8b 44 24 20	 mov	 eax, DWORD PTR tv74[rsp]
  000bb	89 01		 mov	 DWORD PTR [rcx], eax

; 2887 : 	
; 2888 : 	if (*intersectLength == 0)

  000bd	48 8b 44 24 68	 mov	 rax, QWORD PTR intersectLength$[rsp]
  000c2	83 38 00	 cmp	 DWORD PTR [rax], 0
  000c5	75 0d		 jne	 SHORT $LN1@GetInterse

; 2889 : 		*intersectStart = start1;

  000c7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR intersectStart$[rsp]
  000cc	48 8b 44 24 40	 mov	 rax, QWORD PTR start1$[rsp]
  000d1	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN1@GetInterse:

; 2890 : }

  000d4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d8	c3		 ret	 0
GetIntersection ENDP
_TEXT	ENDS
PUBLIC	RegionsOverlap
;	COMDAT pdata
pdata	SEGMENT
$pdata$RegionsOverlap DD imagerel $LN9
	DD	imagerel $LN9+120
	DD	imagerel $unwind$RegionsOverlap
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RegionsOverlap DD 011801H
	DD	02218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT RegionsOverlap
_TEXT	SEGMENT
tv68 = 0
tv69 = 4
tv67 = 8
start1$ = 32
end1$ = 40
start2$ = 48
end2$ = 56
RegionsOverlap PROC					; COMDAT

; 2875 : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24

; 2876 : 	return (start1 < start2) ? (end1 >= start2) : (start1 <= end2);

  00018	48 8b 44 24 30	 mov	 rax, QWORD PTR start2$[rsp]
  0001d	48 39 44 24 20	 cmp	 QWORD PTR start1$[rsp], rax
  00022	73 25		 jae	 SHORT $LN7@RegionsOve
  00024	48 8b 44 24 30	 mov	 rax, QWORD PTR start2$[rsp]
  00029	48 39 44 24 28	 cmp	 QWORD PTR end1$[rsp], rax
  0002e	72 09		 jb	 SHORT $LN5@RegionsOve
  00030	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv68[rsp], 1
  00037	eb 07		 jmp	 SHORT $LN6@RegionsOve
$LN5@RegionsOve:
  00039	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv68[rsp], 0
$LN6@RegionsOve:
  00040	8b 04 24	 mov	 eax, DWORD PTR tv68[rsp]
  00043	89 44 24 04	 mov	 DWORD PTR tv69[rsp], eax
  00047	eb 26		 jmp	 SHORT $LN8@RegionsOve
$LN7@RegionsOve:
  00049	48 8b 44 24 38	 mov	 rax, QWORD PTR end2$[rsp]
  0004e	48 39 44 24 20	 cmp	 QWORD PTR start1$[rsp], rax
  00053	77 0a		 ja	 SHORT $LN3@RegionsOve
  00055	c7 44 24 08 01
	00 00 00	 mov	 DWORD PTR tv67[rsp], 1
  0005d	eb 08		 jmp	 SHORT $LN4@RegionsOve
$LN3@RegionsOve:
  0005f	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR tv67[rsp], 0
$LN4@RegionsOve:
  00067	8b 44 24 08	 mov	 eax, DWORD PTR tv67[rsp]
  0006b	89 44 24 04	 mov	 DWORD PTR tv69[rsp], eax
$LN8@RegionsOve:
  0006f	8b 44 24 04	 mov	 eax, DWORD PTR tv69[rsp]

; 2877 : }

  00073	48 83 c4 18	 add	 rsp, 24
  00077	c3		 ret	 0
RegionsOverlap ENDP
_TEXT	ENDS
PUBLIC	SymbolicLinkToTarget
;	COMDAT pdata
pdata	SEGMENT
$pdata$SymbolicLinkToTarget DD imagerel $LN4
	DD	imagerel $LN4+228
	DD	imagerel $unwind$SymbolicLinkToTarget
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SymbolicLinkToTarget DD 021801H
	DD	07011f218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT SymbolicLinkToTarget
_TEXT	SEGMENT
objectAttributes$ = 32
ntStatus$ = 80
fullFileName$ = 88
handle$ = 104
target$33123 = 112
symlinkName$ = 144
targetName$ = 152
maxTargetNameLength$ = 160
SymbolicLinkToTarget PROC				; COMDAT

; 2845 : {

$LN4:
  00000	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  00006	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	57		 push	 rdi
  00011	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 2846 : 	NTSTATUS ntStatus;
; 2847 : 	OBJECT_ATTRIBUTES objectAttributes;
; 2848 : 	UNICODE_STRING fullFileName;
; 2849 : 	HANDLE handle;
; 2850 : 
; 2851 : 	RtlInitUnicodeString (&fullFileName, symlinkName);

  00018	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR symlinkName$[rsp]
  00020	48 8d 4c 24 58	 lea	 rcx, QWORD PTR fullFileName$[rsp]
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2852 : 	InitializeObjectAttributes (&objectAttributes, &fullFileName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

  0002b	c7 44 24 20 30
	00 00 00	 mov	 DWORD PTR objectAttributes$[rsp], 48 ; 00000030H
  00033	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR objectAttributes$[rsp+8], 0
  0003c	c7 44 24 38 40
	02 00 00	 mov	 DWORD PTR objectAttributes$[rsp+24], 576 ; 00000240H
  00044	48 8d 44 24 58	 lea	 rax, QWORD PTR fullFileName$[rsp]
  00049	48 89 44 24 30	 mov	 QWORD PTR objectAttributes$[rsp+16], rax
  0004e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR objectAttributes$[rsp+32], 0
  00057	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR objectAttributes$[rsp+40], 0

; 2853 : 
; 2854 : 	ntStatus = ZwOpenSymbolicLinkObject (&handle, GENERIC_READ, &objectAttributes);

  00060	4c 8d 44 24 20	 lea	 r8, QWORD PTR objectAttributes$[rsp]
  00065	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  0006a	48 8d 4c 24 68	 lea	 rcx, QWORD PTR handle$[rsp]
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwOpenSymbolicLinkObject
  00075	89 44 24 50	 mov	 DWORD PTR ntStatus$[rsp], eax

; 2855 : 
; 2856 : 	if (NT_SUCCESS (ntStatus))

  00079	83 7c 24 50 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  0007e	7c 57		 jl	 SHORT $LN1@SymbolicLi

; 2857 : 	{
; 2858 : 		UNICODE_STRING target;
; 2859 : 		target.Buffer = targetName;

  00080	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR targetName$[rsp]
  00088	48 89 44 24 78	 mov	 QWORD PTR target$33123[rsp+8], rax

; 2860 : 		target.Length = 0;

  0008d	33 c0		 xor	 eax, eax
  0008f	66 89 44 24 70	 mov	 WORD PTR target$33123[rsp], ax

; 2861 : 		target.MaximumLength = maxTargetNameLength;

  00094	0f b7 84 24 a0
	00 00 00	 movzx	 eax, WORD PTR maxTargetNameLength$[rsp]
  0009c	66 89 44 24 72	 mov	 WORD PTR target$33123[rsp+2], ax

; 2862 : 		memset (targetName, 0, maxTargetNameLength);

  000a1	0f b7 8c 24 a0
	00 00 00	 movzx	 ecx, WORD PTR maxTargetNameLength$[rsp]
  000a9	48 8b bc 24 98
	00 00 00	 mov	 rdi, QWORD PTR targetName$[rsp]
  000b1	33 c0		 xor	 eax, eax
  000b3	f3 aa		 rep stosb

; 2863 : 
; 2864 : 		ntStatus = ZwQuerySymbolicLinkObject (handle, &target, NULL);

  000b5	45 33 c0	 xor	 r8d, r8d
  000b8	48 8d 54 24 70	 lea	 rdx, QWORD PTR target$33123[rsp]
  000bd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR handle$[rsp]
  000c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwQuerySymbolicLinkObject
  000c8	89 44 24 50	 mov	 DWORD PTR ntStatus$[rsp], eax

; 2865 : 
; 2866 : 		ZwClose (handle);

  000cc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR handle$[rsp]
  000d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
$LN1@SymbolicLi:

; 2867 : 	}
; 2868 : 
; 2869 : 	return ntStatus;

  000d7	8b 44 24 50	 mov	 eax, DWORD PTR ntStatus$[rsp]

; 2870 : }

  000db	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  000e2	5f		 pop	 rdi
  000e3	c3		 ret	 0
SymbolicLinkToTarget ENDP
_TEXT	ENDS
PUBLIC	getToken
; Function compile flags: /Odtp
;	COMDAT getToken
_TEXT	SEGMENT
psubContext$ = 8
getToken PROC						; COMDAT

; 2548 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 2549 : 	if (!psubContext) 

  00005	48 83 7c 24 08
	00		 cmp	 QWORD PTR psubContext$[rsp], 0
  0000b	75 06		 jne	 SHORT $LN4@getToken

; 2550 : 	{
; 2551 : 		return NULL;

  0000d	33 c0		 xor	 eax, eax
  0000f	eb 2d		 jmp	 SHORT $LN5@getToken
  00011	eb 2b		 jmp	 SHORT $LN3@getToken
$LN4@getToken:

; 2552 : 	}
; 2553 : 	else if (psubContext->ClientToken && psubContext->ImpersonationLevel >= SecurityImpersonation)

  00013	48 8b 44 24 08	 mov	 rax, QWORD PTR psubContext$[rsp]
  00018	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0001c	74 17		 je	 SHORT $LN2@getToken
  0001e	48 8b 44 24 08	 mov	 rax, QWORD PTR psubContext$[rsp]
  00023	83 78 08 02	 cmp	 DWORD PTR [rax+8], 2
  00027	7c 0c		 jl	 SHORT $LN2@getToken

; 2554 : 	{
; 2555 : 		return psubContext->ClientToken;

  00029	48 8b 44 24 08	 mov	 rax, QWORD PTR psubContext$[rsp]
  0002e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00031	eb 0b		 jmp	 SHORT $LN5@getToken

; 2556 : 	}
; 2557 : 	else

  00033	eb 09		 jmp	 SHORT $LN1@getToken
$LN2@getToken:

; 2558 : 	{
; 2559 : 		return psubContext->PrimaryToken;

  00035	48 8b 44 24 08	 mov	 rax, QWORD PTR psubContext$[rsp]
  0003a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
$LN1@getToken:
$LN3@getToken:
$LN5@getToken:

; 2560 : 	}
; 2561 : }

  0003e	f3 c3		 fatret	 0
getToken ENDP
_TEXT	ENDS
PUBLIC	TCCloseFsVolume
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCCloseFsVolume DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$TCCloseFsVolume
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCCloseFsVolume DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT TCCloseFsVolume
_TEXT	SEGMENT
volumeHandle$ = 48
fileObject$ = 56
TCCloseFsVolume PROC					; COMDAT

; 2363 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2364 : 	ObDereferenceObject (fileObject);

  0000e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR fileObject$[rsp]
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 2365 : 	ZwClose (volumeHandle);

  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR volumeHandle$[rsp]
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 2366 : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	c3		 ret	 0
TCCloseFsVolume ENDP
_TEXT	ENDS
PUBLIC	SendDeviceIoControlRequest
;	COMDAT pdata
pdata	SEGMENT
$pdata$SendDeviceIoControlRequestWorkItemRoutine DD imagerel SendDeviceIoControlRequestWorkItemRoutine
	DD	imagerel SendDeviceIoControlRequestWorkItemRoutine+116
	DD	imagerel $unwind$SendDeviceIoControlRequestWorkItemRoutine
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SendDeviceIoControlRequestWorkItemRoutine DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT SendDeviceIoControlRequestWorkItemRoutine
_TEXT	SEGMENT
rootDeviceObject$ = 64
arg$ = 72
SendDeviceIoControlRequestWorkItemRoutine PROC		; COMDAT

; 2208 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2209 : 	arg->Status = SendDeviceIoControlRequest (arg->deviceObject, arg->ioControlCode, arg->inputBuffer, arg->inputBufferSize, arg->outputBuffer, arg->outputBufferSize);

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR arg$[rsp]
  00013	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00016	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0001a	48 8b 44 24 48	 mov	 rax, QWORD PTR arg$[rsp]
  0001f	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00023	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00028	48 8b 44 24 48	 mov	 rax, QWORD PTR arg$[rsp]
  0002d	44 8b 48 18	 mov	 r9d, DWORD PTR [rax+24]
  00031	4c 8b 44 24 48	 mov	 r8, QWORD PTR arg$[rsp]
  00036	4d 8b 40 10	 mov	 r8, QWORD PTR [r8+16]
  0003a	48 8b 44 24 48	 mov	 rax, QWORD PTR arg$[rsp]
  0003f	8b 50 08	 mov	 edx, DWORD PTR [rax+8]
  00042	48 8b 4c 24 48	 mov	 rcx, QWORD PTR arg$[rsp]
  00047	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0004a	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  0004f	44 8b d8	 mov	 r11d, eax
  00052	48 8b 44 24 48	 mov	 rax, QWORD PTR arg$[rsp]
  00057	44 89 58 2c	 mov	 DWORD PTR [rax+44], r11d

; 2210 : 	KeSetEvent (&arg->WorkItemCompletedEvent, IO_NO_INCREMENT, FALSE);

  0005b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR arg$[rsp]
  00060	48 83 c1 30	 add	 rcx, 48			; 00000030H
  00064	45 33 c0	 xor	 r8d, r8d
  00067	33 d2		 xor	 edx, edx
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 2211 : }

  0006f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00073	c3		 ret	 0
SendDeviceIoControlRequestWorkItemRoutine ENDP
_TEXT	ENDS
PUBLIC	TCTranslateCode
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCTranslateCode DD imagerel $LN153
	DD	imagerel $LN153+2249
	DD	imagerel $unwind$TCTranslateCode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCTranslateCode DD 010801H
	DD	02208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT TCTranslateCode
_TEXT	SEGMENT
tv64 = 0
ulCode$ = 32
TCTranslateCode PROC					; COMDAT

; 1897 : {

$LN153:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 1898 : 	switch (ulCode)

  00008	8b 44 24 20	 mov	 eax, DWORD PTR ulCode$[rsp]
  0000c	89 04 24	 mov	 DWORD PTR tv64[rsp], eax
  0000f	81 3c 24 00 00
	56 00		 cmp	 DWORD PTR tv64[rsp], 5636096 ; 00560000H
  00016	77 43		 ja	 SHORT $LN150@TCTranslat
  00018	81 3c 24 00 00
	56 00		 cmp	 DWORD PTR tv64[rsp], 5636096 ; 00560000H
  0001f	0f 84 03 02 00
	00		 je	 $LN107@TCTranslat
  00025	8b 04 24	 mov	 eax, DWORD PTR tv64[rsp]
  00028	2d 04 20 22 00	 sub	 eax, 2236420		; 00222004H
  0002d	89 04 24	 mov	 DWORD PTR tv64[rsp], eax
  00030	81 3c 24 94 00
	00 00		 cmp	 DWORD PTR tv64[rsp], 148 ; 00000094H
  00037	0f 87 f7 01 00
	00		 ja	 $LN146@TCTranslat
  0003d	8b 04 24	 mov	 eax, DWORD PTR tv64[rsp]
  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00047	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN151@TCTranslat[rcx+rax]
  0004f	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN152@TCTranslat[rcx+rax*4]
  00056	48 03 c1	 add	 rax, rcx
  00059	ff e0		 jmp	 rax
$LN150@TCTranslat:
  0005b	e9 d4 01 00 00	 jmp	 $LN146@TCTranslat
$LN145@TCTranslat:

; 1899 : 	{
; 1900 : #define TC_CASE_RET_NAME(CODE) case CODE : return L###CODE
; 1901 : 
; 1902 : 		TC_CASE_RET_NAME (TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP);

  00060	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EK@CMLLEBIK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAA?$AAB?$AAO?$AAR?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS@FNODOBFM@
  00067	e9 24 07 00 00	 jmp	 $LN148@TCTranslat
$LN144@TCTranslat:

; 1903 : 		TC_CASE_RET_NAME (TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE);

  0006c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EC@HMNCILMA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAA?$AAB?$AAO?$AAR?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE@FNODOBFM@
  00073	e9 18 07 00 00	 jmp	 $LN148@TCTranslat
$LN143@TCTranslat:

; 1904 : 		TC_CASE_RET_NAME (TC_IOCTL_BOOT_ENCRYPTION_SETUP);

  00078	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DO@JPMJPMCJ@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAE?$AAT?$AAU?$AAP?$AA?$AA@FNODOBFM@
  0007f	e9 0c 07 00 00	 jmp	 $LN148@TCTranslat
$LN142@TCTranslat:

; 1905 : 		TC_CASE_RET_NAME (TC_IOCTL_DISMOUNT_ALL_VOLUMES);

  00084	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DM@OLONGNGL@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAA?$AAL?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AAS?$AA?$AA@FNODOBFM@
  0008b	e9 00 07 00 00	 jmp	 $LN148@TCTranslat
$LN141@TCTranslat:

; 1906 : 		TC_CASE_RET_NAME (TC_IOCTL_DISMOUNT_VOLUME);

  00090	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DC@CLEBJPLG@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA?$AA@FNODOBFM@
  00097	e9 f4 06 00 00	 jmp	 $LN148@TCTranslat
$LN140@TCTranslat:

; 1907 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES);

  0009c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1FE@BEJBLKBA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAP@FNODOBFM@
  000a3	e9 e8 06 00 00	 jmp	 $LN148@TCTranslat
$LN139@TCTranslat:

; 1908 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME);

  000a8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1FI@CDJGLMPJ@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA?$AAL?$AAG@FNODOBFM@
  000af	e9 dc 06 00 00	 jmp	 $LN148@TCTranslat
$LN138@TCTranslat:

; 1909 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT);

  000b4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1FE@OJNNCONL@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAE?$AAT@FNODOBFM@
  000bb	e9 d0 06 00 00	 jmp	 $LN148@TCTranslat
$LN137@TCTranslat:

; 1910 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS);

  000c0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EI@GAKLFLAF@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAE?$AAN?$AAC?$AAR?$AAY?$AAP?$AAT?$AAI?$AAO?$AAN?$AA_?$AAS?$AAT?$AAA@FNODOBFM@
  000c7	e9 c4 06 00 00	 jmp	 $LN148@TCTranslat
$LN136@TCTranslat:

; 1911 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_BOOT_LOADER_VERSION);

  000cc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EC@OPCJHCIG@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAL?$AAO?$AAA?$AAD?$AAE?$AAR?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN@FNODOBFM@
  000d3	e9 b8 06 00 00	 jmp	 $LN148@TCTranslat
$LN135@TCTranslat:

; 1912 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT);

  000d8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EM@OAEBJACE@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_?$AAR@FNODOBFM@
  000df	e9 ac 06 00 00	 jmp	 $LN148@TCTranslat
$LN134@TCTranslat:

; 1913 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS);

  000e4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EM@LMAMOKGA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_?$AAS@FNODOBFM@
  000eb	e9 a0 06 00 00	 jmp	 $LN148@TCTranslat
$LN133@TCTranslat:

; 1914 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_DEVICE_REFCOUNT);

  000f0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DK@DFEJGDBK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAR?$AAE?$AAF?$AAC?$AAO?$AAU?$AAN?$AAT?$AA?$AA@FNODOBFM@
  000f7	e9 94 06 00 00	 jmp	 $LN148@TCTranslat
$LN132@TCTranslat:

; 1915 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_DRIVE_GEOMETRY);

  000fc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DI@LAIAIOML@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA?$AA@FNODOBFM@
  00103	e9 88 06 00 00	 jmp	 $LN148@TCTranslat
$LN131@TCTranslat:

; 1916 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_DRIVE_PARTITION_INFO);

  00108	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EE@HEELFNND@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF@FNODOBFM@
  0010f	e9 7c 06 00 00	 jmp	 $LN148@TCTranslat
$LN130@TCTranslat:

; 1917 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_DRIVER_VERSION);

  00114	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DI@ODPPPDDO@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN?$AA?$AA@FNODOBFM@
  0011b	e9 70 06 00 00	 jmp	 $LN148@TCTranslat
$LN129@TCTranslat:

; 1918 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_MOUNTED_VOLUMES);

  00120	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DK@KJKOFIJA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAE?$AAD?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AAS?$AA?$AA@FNODOBFM@
  00127	e9 64 06 00 00	 jmp	 $LN148@TCTranslat
$LN128@TCTranslat:

; 1919 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_PASSWORD_CACHE_STATUS);

  0012c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EG@LLJHBPJF@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAS?$AAS?$AAW?$AAO?$AAR?$AAD?$AA_?$AAC?$AAA?$AAC?$AAH?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT@FNODOBFM@
  00133	e9 58 06 00 00	 jmp	 $LN148@TCTranslat
$LN127@TCTranslat:

; 1920 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_SYSTEM_DRIVE_CONFIG);

  00138	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EC@FADHDJPK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG@FNODOBFM@
  0013f	e9 4c 06 00 00	 jmp	 $LN148@TCTranslat
$LN126@TCTranslat:

; 1921 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_PORTABLE_MODE_STATUS);

  00144	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EE@IPNJBDEG@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAO?$AAR?$AAT?$AAA?$AAB?$AAL?$AAE?$AA_?$AAM?$AAO?$AAD?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU@FNODOBFM@
  0014b	e9 40 06 00 00	 jmp	 $LN148@TCTranslat
$LN125@TCTranslat:

; 1922 : 		TC_CASE_RET_NAME (TC_IOCTL_SET_PORTABLE_MODE_STATUS);

  00150	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EE@NMKCMMBM@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAP?$AAO?$AAR?$AAT?$AAA?$AAB?$AAL?$AAE?$AA_?$AAM?$AAO?$AAD?$AAE?$AA_?$AAS?$AAT?$AAA?$AAT?$AAU@FNODOBFM@
  00157	e9 34 06 00 00	 jmp	 $LN148@TCTranslat
$LN124@TCTranslat:

; 1923 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_RESOLVED_SYMLINK);

  0015c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DM@GFCMCNDC@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAR?$AAE?$AAS?$AAO?$AAL?$AAV?$AAE?$AAD?$AA_?$AAS?$AAY?$AAM?$AAL?$AAI?$AAN?$AAK?$AA?$AA@FNODOBFM@
  00163	e9 28 06 00 00	 jmp	 $LN148@TCTranslat
$LN123@TCTranslat:

; 1924 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG);

  00168	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EM@GFDNBFC@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAD?$AAU?$AAM?$AAP?$AA_?$AAC@FNODOBFM@
  0016f	e9 1c 06 00 00	 jmp	 $LN148@TCTranslat
$LN122@TCTranslat:

; 1925 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_VOLUME_PROPERTIES);

  00174	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DO@DMIHGGIB@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAP?$AAR?$AAO?$AAP?$AAE?$AAR?$AAT?$AAI?$AAE?$AAS?$AA?$AA@FNODOBFM@
  0017b	e9 10 06 00 00	 jmp	 $LN148@TCTranslat
$LN121@TCTranslat:

; 1926 : 		TC_CASE_RET_NAME (TC_IOCTL_GET_WARNING_FLAGS);

  00180	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DG@LBDEDPBA@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAG?$AAE?$AAT?$AA_?$AAW?$AAA?$AAR?$AAN?$AAI?$AAN?$AAG?$AA_?$AAF?$AAL?$AAA?$AAG?$AAS?$AA?$AA@FNODOBFM@
  00187	e9 04 06 00 00	 jmp	 $LN148@TCTranslat
$LN120@TCTranslat:

; 1927 : 		TC_CASE_RET_NAME (TC_IOCTL_DISK_IS_WRITABLE);

  0018c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DE@JNPINMHP@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAS?$AA_?$AAW?$AAR?$AAI?$AAT?$AAA?$AAB?$AAL?$AAE?$AA?$AA@FNODOBFM@
  00193	e9 f8 05 00 00	 jmp	 $LN148@TCTranslat
$LN119@TCTranslat:

; 1928 : 		TC_CASE_RET_NAME (TC_IOCTL_IS_ANY_VOLUME_MOUNTED);

  00198	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DO@ICDMEENM@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAA?$AAN?$AAY?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@
  0019f	e9 ec 05 00 00	 jmp	 $LN148@TCTranslat
$LN118@TCTranslat:

; 1929 : 		TC_CASE_RET_NAME (TC_IOCTL_IS_DRIVER_UNLOAD_DISABLED);

  001a4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EG@HPLFHOOO@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAU?$AAN?$AAL?$AAO?$AAA?$AAD?$AA_?$AAD?$AAI?$AAS?$AAA?$AAB?$AAL@FNODOBFM@
  001ab	e9 e0 05 00 00	 jmp	 $LN148@TCTranslat
$LN117@TCTranslat:

; 1930 : 		TC_CASE_RET_NAME (TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING);

  001b0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EE@HPDOLCKH@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAI?$AAS?$AA_?$AAH?$AAI?$AAD?$AAD?$AAE?$AAN?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAR?$AAU?$AAN?$AAN?$AAI?$AAN@FNODOBFM@
  001b7	e9 d4 05 00 00	 jmp	 $LN148@TCTranslat
$LN116@TCTranslat:

; 1931 : 		TC_CASE_RET_NAME (TC_IOCTL_MOUNT_VOLUME);

  001bc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CM@HJCGFKAD@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA?$AA@FNODOBFM@
  001c3	e9 c8 05 00 00	 jmp	 $LN148@TCTranslat
$LN115@TCTranslat:

; 1932 : 		TC_CASE_RET_NAME (TC_IOCTL_OPEN_TEST);

  001c8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CG@HPPKKEKP@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAO?$AAP?$AAE?$AAN?$AA_?$AAT?$AAE?$AAS?$AAT?$AA?$AA@FNODOBFM@
  001cf	e9 bc 05 00 00	 jmp	 $LN148@TCTranslat
$LN114@TCTranslat:

; 1933 : 		TC_CASE_RET_NAME (TC_IOCTL_PROBE_REAL_DRIVE_SIZE);

  001d4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DO@BKHLMLHN@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAP?$AAR?$AAO?$AAB?$AAE?$AA_?$AAR?$AAE?$AAA?$AAL?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$AA@FNODOBFM@
  001db	e9 b0 05 00 00	 jmp	 $LN148@TCTranslat
$LN113@TCTranslat:

; 1934 : 		TC_CASE_RET_NAME (TC_IOCTL_REOPEN_BOOT_VOLUME_HEADER);

  001e0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EG@GGODONFK@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAR?$AAE?$AAO?$AAP?$AAE?$AAN?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAH?$AAE?$AAA?$AAD@FNODOBFM@
  001e7	e9 a4 05 00 00	 jmp	 $LN148@TCTranslat
$LN112@TCTranslat:

; 1935 : 		TC_CASE_RET_NAME (TC_IOCTL_REREAD_DRIVER_CONFIG);

  001ec	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DM@JFJLBNLP@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAR?$AAE?$AAR?$AAE?$AAA?$AAD?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AAR?$AA_?$AAC?$AAO?$AAN?$AAF?$AAI?$AAG?$AA?$AA@FNODOBFM@
  001f3	e9 98 05 00 00	 jmp	 $LN148@TCTranslat
$LN111@TCTranslat:

; 1936 : 		TC_CASE_RET_NAME (TC_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY);

  001f8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1FE@EBAIHKDI@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAF?$AAA?$AAV?$AAO?$AAR?$AAI?$AAT?$AAE?$AA_?$AAV?$AAO?$AAL@FNODOBFM@
  001ff	e9 8c 05 00 00	 jmp	 $LN148@TCTranslat
$LN110@TCTranslat:

; 1937 : 		TC_CASE_RET_NAME (TC_IOCTL_START_DECOY_SYSTEM_WIPE);

  00204	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EC@FGBEDIDI@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAA?$AAR?$AAT?$AA_?$AAD?$AAE?$AAC?$AAO?$AAY?$AA_?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA_?$AAW?$AAI?$AAP?$AAE@FNODOBFM@
  0020b	e9 80 05 00 00	 jmp	 $LN148@TCTranslat
$LN109@TCTranslat:

; 1938 : 		TC_CASE_RET_NAME (TC_IOCTL_WIPE_PASSWORD_CACHE);

  00210	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DK@BNKDMLAM@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAW?$AAI?$AAP?$AAE?$AA_?$AAP?$AAA?$AAS?$AAS?$AAW?$AAO?$AAR?$AAD?$AA_?$AAC?$AAA?$AAC?$AAH?$AAE?$AA?$AA@FNODOBFM@
  00217	e9 74 05 00 00	 jmp	 $LN148@TCTranslat
$LN108@TCTranslat:

; 1939 : 		TC_CASE_RET_NAME (TC_IOCTL_WRITE_BOOT_DRIVE_SECTOR);

  0021c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EC@FOOPNHFI@?$AAT?$AAC?$AA_?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAW?$AAR?$AAI?$AAT?$AAE?$AA_?$AAB?$AAO?$AAO?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAS?$AAE?$AAC?$AAT?$AAO?$AAR@FNODOBFM@
  00223	e9 68 05 00 00	 jmp	 $LN148@TCTranslat
$LN107@TCTranslat:

; 1940 : 
; 1941 : 		TC_CASE_RET_NAME (IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS);

  00228	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EK@FDCJEFAP@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAE?$AAX?$AAT@FNODOBFM@
  0022f	e9 5c 05 00 00	 jmp	 $LN148@TCTranslat
$LN146@TCTranslat:

; 1942 : 
; 1943 : #undef TC_CASE_RET_NAME
; 1944 : 	}
; 1945 : 
; 1946 : 	if (ulCode ==			 IOCTL_DISK_GET_DRIVE_GEOMETRY)

  00234	81 7c 24 20 00
	00 07 00	 cmp	 DWORD PTR ulCode$[rsp], 458752 ; 00070000H
  0023c	75 11		 jne	 SHORT $LN106@TCTranslat

; 1947 : 		return (LPWSTR) _T ("IOCTL_DISK_GET_DRIVE_GEOMETRY");

  0023e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DM@KPKDNCHM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA?$AA@FNODOBFM@
  00245	e9 46 05 00 00	 jmp	 $LN148@TCTranslat
  0024a	e9 41 05 00 00	 jmp	 $LN105@TCTranslat
$LN106@TCTranslat:

; 1948 : 	else if (ulCode ==		 IOCTL_DISK_GET_DRIVE_GEOMETRY_EX)

  0024f	81 7c 24 20 a0
	00 07 00	 cmp	 DWORD PTR ulCode$[rsp], 458912 ; 000700a0H
  00257	75 11		 jne	 SHORT $LN104@TCTranslat

; 1949 : 		return (LPWSTR) _T ("IOCTL_DISK_GET_DRIVE_GEOMETRY_EX");

  00259	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EC@NPAFBAMN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAG?$AAE?$AAO?$AAM?$AAE?$AAT?$AAR?$AAY?$AA_?$AAE?$AAX@FNODOBFM@
  00260	e9 2b 05 00 00	 jmp	 $LN148@TCTranslat
  00265	e9 26 05 00 00	 jmp	 $LN103@TCTranslat
$LN104@TCTranslat:

; 1950 : 	else if (ulCode ==		 IOCTL_MOUNTDEV_QUERY_DEVICE_NAME)

  0026a	81 7c 24 20 08
	00 4d 00	 cmp	 DWORD PTR ulCode$[rsp], 5046280 ; 004d0008H
  00272	75 11		 jne	 SHORT $LN102@TCTranslat

; 1951 : 		return (LPWSTR) _T ("IOCTL_MOUNTDEV_QUERY_DEVICE_NAME");

  00274	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EC@HFOIOEOM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAN?$AAA?$AAM?$AAE@FNODOBFM@
  0027b	e9 10 05 00 00	 jmp	 $LN148@TCTranslat
  00280	e9 0b 05 00 00	 jmp	 $LN101@TCTranslat
$LN102@TCTranslat:

; 1952 : 	else if (ulCode ==		 IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME)

  00285	81 7c 24 20 0c
	00 4d 00	 cmp	 DWORD PTR ulCode$[rsp], 5046284 ; 004d000cH
  0028d	75 11		 jne	 SHORT $LN100@TCTranslat

; 1953 : 		return (LPWSTR) _T ("IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME");

  0028f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1FC@MNMCPAAJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAS?$AAU?$AAG?$AAG?$AAE?$AAS?$AAT?$AAE?$AAD?$AA_?$AAL@FNODOBFM@
  00296	e9 f5 04 00 00	 jmp	 $LN148@TCTranslat
  0029b	e9 f0 04 00 00	 jmp	 $LN99@TCTranslat
$LN100@TCTranslat:

; 1954 : 	else if (ulCode ==		 IOCTL_MOUNTDEV_QUERY_UNIQUE_ID)

  002a0	81 7c 24 20 00
	00 4d 00	 cmp	 DWORD PTR ulCode$[rsp], 5046272 ; 004d0000H
  002a8	75 11		 jne	 SHORT $LN98@TCTranslat

; 1955 : 		return (LPWSTR) _T ("IOCTL_MOUNTDEV_QUERY_UNIQUE_ID");

  002aa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DO@OGNDJPNH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAU?$AAN?$AAI?$AAQ?$AAU?$AAE?$AA_?$AAI?$AAD?$AA?$AA@FNODOBFM@
  002b1	e9 da 04 00 00	 jmp	 $LN148@TCTranslat
  002b6	e9 d5 04 00 00	 jmp	 $LN97@TCTranslat
$LN98@TCTranslat:

; 1956 : 	else if (ulCode ==		 IOCTL_VOLUME_ONLINE)

  002bb	81 7c 24 20 08
	c0 56 00	 cmp	 DWORD PTR ulCode$[rsp], 5685256 ; 0056c008H
  002c3	75 11		 jne	 SHORT $LN96@TCTranslat

; 1957 : 		return (LPWSTR) _T ("IOCTL_VOLUME_ONLINE");

  002c5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CI@DJEMJCBH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAO?$AAN?$AAL?$AAI?$AAN?$AAE?$AA?$AA@FNODOBFM@
  002cc	e9 bf 04 00 00	 jmp	 $LN148@TCTranslat
  002d1	e9 ba 04 00 00	 jmp	 $LN95@TCTranslat
$LN96@TCTranslat:

; 1958 : 	else if (ulCode ==		 IOCTL_MOUNTDEV_LINK_CREATED)

  002d6	81 7c 24 20 10
	c0 4d 00	 cmp	 DWORD PTR ulCode$[rsp], 5095440 ; 004dc010H
  002de	75 11		 jne	 SHORT $LN94@TCTranslat

; 1959 : 		return (LPWSTR) _T ("IOCTL_MOUNTDEV_LINK_CREATED");

  002e0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DI@HGGIOGFM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAL?$AAI?$AAN?$AAK?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@
  002e7	e9 a4 04 00 00	 jmp	 $LN148@TCTranslat
  002ec	e9 9f 04 00 00	 jmp	 $LN93@TCTranslat
$LN94@TCTranslat:

; 1960 : 	else if (ulCode ==		 IOCTL_MOUNTDEV_LINK_DELETED)

  002f1	81 7c 24 20 14
	c0 4d 00	 cmp	 DWORD PTR ulCode$[rsp], 5095444 ; 004dc014H
  002f9	75 11		 jne	 SHORT $LN92@TCTranslat

; 1961 : 		return (LPWSTR) _T ("IOCTL_MOUNTDEV_LINK_DELETED");

  002fb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DI@BMKMBCGO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAD?$AAE?$AAV?$AA_?$AAL?$AAI?$AAN?$AAK?$AA_?$AAD?$AAE?$AAL?$AAE?$AAT?$AAE?$AAD?$AA?$AA@FNODOBFM@
  00302	e9 89 04 00 00	 jmp	 $LN148@TCTranslat
  00307	e9 84 04 00 00	 jmp	 $LN91@TCTranslat
$LN92@TCTranslat:

; 1962 : 	else if (ulCode ==		 IOCTL_MOUNTMGR_QUERY_POINTS)

  0030c	81 7c 24 20 08
	00 6d 00	 cmp	 DWORD PTR ulCode$[rsp], 7143432 ; 006d0008H
  00314	75 11		 jne	 SHORT $LN90@TCTranslat

; 1963 : 		return (LPWSTR) _T ("IOCTL_MOUNTMGR_QUERY_POINTS");

  00316	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DI@LFNEEBHO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAQ?$AAU?$AAE?$AAR?$AAY?$AA_?$AAP?$AAO?$AAI?$AAN?$AAT?$AAS?$AA?$AA@FNODOBFM@
  0031d	e9 6e 04 00 00	 jmp	 $LN148@TCTranslat
  00322	e9 69 04 00 00	 jmp	 $LN89@TCTranslat
$LN90@TCTranslat:

; 1964 : 	else if (ulCode ==		 IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED)

  00327	81 7c 24 20 18
	c0 6d 00	 cmp	 DWORD PTR ulCode$[rsp], 7192600 ; 006dc018H
  0032f	75 11		 jne	 SHORT $LN88@TCTranslat

; 1965 : 		return (LPWSTR) _T ("IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED");

  00331	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1FE@CLAOKMGL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAP?$AAO?$AAI?$AAN@FNODOBFM@
  00338	e9 53 04 00 00	 jmp	 $LN148@TCTranslat
  0033d	e9 4e 04 00 00	 jmp	 $LN87@TCTranslat
$LN88@TCTranslat:

; 1966 : 	else if (ulCode ==		 IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED)

  00342	81 7c 24 20 1c
	c0 6d 00	 cmp	 DWORD PTR ulCode$[rsp], 7192604 ; 006dc01cH
  0034a	75 11		 jne	 SHORT $LN86@TCTranslat

; 1967 : 		return (LPWSTR) _T ("IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED");

  0034c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1FE@EBMKFIFJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AAM?$AAG?$AAR?$AA_?$AAV?$AAO?$AAL?$AAU?$AAM?$AAE?$AA_?$AAM?$AAO?$AAU?$AAN?$AAT?$AA_?$AAP?$AAO?$AAI?$AAN@FNODOBFM@
  00353	e9 38 04 00 00	 jmp	 $LN148@TCTranslat
  00358	e9 33 04 00 00	 jmp	 $LN85@TCTranslat
$LN86@TCTranslat:

; 1968 : 	else if (ulCode ==		 IOCTL_DISK_GET_LENGTH_INFO)

  0035d	81 7c 24 20 5c
	40 07 00	 cmp	 DWORD PTR ulCode$[rsp], 475228 ; 0007405cH
  00365	75 11		 jne	 SHORT $LN84@TCTranslat

; 1969 : 		return (LPWSTR) _T ("IOCTL_DISK_GET_LENGTH_INFO");

  00367	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DG@DLDFECDE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAL?$AAE?$AAN?$AAG?$AAT?$AAH?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@
  0036e	e9 1d 04 00 00	 jmp	 $LN148@TCTranslat
  00373	e9 18 04 00 00	 jmp	 $LN83@TCTranslat
$LN84@TCTranslat:

; 1970 : 	else if (ulCode ==		 IOCTL_STORAGE_GET_DEVICE_NUMBER)

  00378	81 7c 24 20 80
	10 2d 00	 cmp	 DWORD PTR ulCode$[rsp], 2953344 ; 002d1080H
  00380	75 11		 jne	 SHORT $LN82@TCTranslat

; 1971 : 		return (LPWSTR) _T ("IOCTL_STORAGE_GET_DEVICE_NUMBER");

  00382	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EA@IKPNDHCL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAO?$AAR?$AAA?$AAG?$AAE?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAN?$AAU?$AAM?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@
  00389	e9 02 04 00 00	 jmp	 $LN148@TCTranslat
  0038e	e9 fd 03 00 00	 jmp	 $LN81@TCTranslat
$LN82@TCTranslat:

; 1972 : 	else if (ulCode ==		 IOCTL_DISK_GET_PARTITION_INFO)

  00393	81 7c 24 20 04
	40 07 00	 cmp	 DWORD PTR ulCode$[rsp], 475140 ; 00074004H
  0039b	75 11		 jne	 SHORT $LN80@TCTranslat

; 1973 : 		return (LPWSTR) _T ("IOCTL_DISK_GET_PARTITION_INFO");

  0039d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DM@LOAKHCPB@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@
  003a4	e9 e7 03 00 00	 jmp	 $LN148@TCTranslat
  003a9	e9 e2 03 00 00	 jmp	 $LN79@TCTranslat
$LN80@TCTranslat:

; 1974 : 	else if (ulCode ==		 IOCTL_DISK_GET_PARTITION_INFO_EX)

  003ae	81 7c 24 20 48
	00 07 00	 cmp	 DWORD PTR ulCode$[rsp], 458824 ; 00070048H
  003b6	75 11		 jne	 SHORT $LN78@TCTranslat

; 1975 : 		return (LPWSTR) _T ("IOCTL_DISK_GET_PARTITION_INFO_EX");

  003b8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EC@CAILBHJF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA_?$AAE?$AAX@FNODOBFM@
  003bf	e9 cc 03 00 00	 jmp	 $LN148@TCTranslat
  003c4	e9 c7 03 00 00	 jmp	 $LN77@TCTranslat
$LN78@TCTranslat:

; 1976 : 	else if (ulCode ==		 IOCTL_DISK_SET_PARTITION_INFO)

  003c9	81 7c 24 20 08
	c0 07 00	 cmp	 DWORD PTR ulCode$[rsp], 507912 ; 0007c008H
  003d1	75 11		 jne	 SHORT $LN76@TCTranslat

; 1977 : 		return (LPWSTR) _T ("IOCTL_DISK_SET_PARTITION_INFO");

  003d3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DM@FAAIHMNH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAS?$AAE?$AAT?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAT?$AAI?$AAO?$AAN?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@
  003da	e9 b1 03 00 00	 jmp	 $LN148@TCTranslat
  003df	e9 ac 03 00 00	 jmp	 $LN75@TCTranslat
$LN76@TCTranslat:

; 1978 : 	else if (ulCode ==		 IOCTL_DISK_GET_DRIVE_LAYOUT)

  003e4	81 7c 24 20 0c
	40 07 00	 cmp	 DWORD PTR ulCode$[rsp], 475148 ; 0007400cH
  003ec	75 11		 jne	 SHORT $LN74@TCTranslat

; 1979 : 		return (LPWSTR) _T ("IOCTL_DISK_GET_DRIVE_LAYOUT");

  003ee	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DI@CCDFFIEC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAL?$AAA?$AAY?$AAO?$AAU?$AAT?$AA?$AA@FNODOBFM@
  003f5	e9 96 03 00 00	 jmp	 $LN148@TCTranslat
  003fa	e9 91 03 00 00	 jmp	 $LN73@TCTranslat
$LN74@TCTranslat:

; 1980 : 	else if (ulCode ==		 IOCTL_DISK_SET_DRIVE_LAYOUT_EX)

  003ff	81 7c 24 20 54
	c0 07 00	 cmp	 DWORD PTR ulCode$[rsp], 507988 ; 0007c054H
  00407	75 11		 jne	 SHORT $LN72@TCTranslat

; 1981 : 		return (LPWSTR) _T ("IOCTL_DISK_SET_DRIVE_LAYOUT_EX");

  00409	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DO@EPIDKIKJ@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAS?$AAE?$AAT?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAL?$AAA?$AAY?$AAO?$AAU?$AAT?$AA_?$AAE?$AAX?$AA?$AA@FNODOBFM@
  00410	e9 7b 03 00 00	 jmp	 $LN148@TCTranslat
  00415	e9 76 03 00 00	 jmp	 $LN71@TCTranslat
$LN72@TCTranslat:

; 1982 : 	else if (ulCode ==		 IOCTL_DISK_VERIFY)

  0041a	81 7c 24 20 14
	00 07 00	 cmp	 DWORD PTR ulCode$[rsp], 458772 ; 00070014H
  00422	75 11		 jne	 SHORT $LN70@TCTranslat

; 1983 : 		return (LPWSTR) _T ("IOCTL_DISK_VERIFY");

  00424	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CE@LGEELOJE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@
  0042b	e9 60 03 00 00	 jmp	 $LN148@TCTranslat
  00430	e9 5b 03 00 00	 jmp	 $LN69@TCTranslat
$LN70@TCTranslat:

; 1984 : 	else if (ulCode == IOCTL_DISK_FORMAT_TRACKS)

  00435	81 7c 24 20 18
	c0 07 00	 cmp	 DWORD PTR ulCode$[rsp], 507928 ; 0007c018H
  0043d	75 11		 jne	 SHORT $LN68@TCTranslat

; 1985 : 		return (LPWSTR) _T ("IOCTL_DISK_FORMAT_TRACKS");

  0043f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DC@PCKIDBBB@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAT?$AAR?$AAA?$AAC?$AAK?$AAS?$AA?$AA@FNODOBFM@
  00446	e9 45 03 00 00	 jmp	 $LN148@TCTranslat
  0044b	e9 40 03 00 00	 jmp	 $LN67@TCTranslat
$LN68@TCTranslat:

; 1986 : 	else if (ulCode == IOCTL_DISK_REASSIGN_BLOCKS)

  00450	81 7c 24 20 1c
	c0 07 00	 cmp	 DWORD PTR ulCode$[rsp], 507932 ; 0007c01cH
  00458	75 11		 jne	 SHORT $LN66@TCTranslat

; 1987 : 		return (LPWSTR) _T ("IOCTL_DISK_REASSIGN_BLOCKS");

  0045a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DG@HPLPDECO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAA?$AAS?$AAS?$AAI?$AAG?$AAN?$AA_?$AAB?$AAL?$AAO?$AAC?$AAK?$AAS?$AA?$AA@FNODOBFM@
  00461	e9 2a 03 00 00	 jmp	 $LN148@TCTranslat
  00466	e9 25 03 00 00	 jmp	 $LN65@TCTranslat
$LN66@TCTranslat:

; 1988 : 	else if (ulCode == IOCTL_DISK_PERFORMANCE)

  0046b	81 7c 24 20 20
	00 07 00	 cmp	 DWORD PTR ulCode$[rsp], 458784 ; 00070020H
  00473	75 11		 jne	 SHORT $LN64@TCTranslat

; 1989 : 		return (LPWSTR) _T ("IOCTL_DISK_PERFORMANCE");

  00475	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CO@LEDAJMII@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAP?$AAE?$AAR?$AAF?$AAO?$AAR?$AAM?$AAA?$AAN?$AAC?$AAE?$AA?$AA@FNODOBFM@
  0047c	e9 0f 03 00 00	 jmp	 $LN148@TCTranslat
  00481	e9 0a 03 00 00	 jmp	 $LN63@TCTranslat
$LN64@TCTranslat:

; 1990 : 	else if (ulCode == IOCTL_DISK_IS_WRITABLE)

  00486	81 7c 24 20 24
	00 07 00	 cmp	 DWORD PTR ulCode$[rsp], 458788 ; 00070024H
  0048e	75 11		 jne	 SHORT $LN62@TCTranslat

; 1991 : 		return (LPWSTR) _T ("IOCTL_DISK_IS_WRITABLE");

  00490	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CO@MFHKENAI@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAS?$AA_?$AAW?$AAR?$AAI?$AAT?$AAA?$AAB?$AAL?$AAE?$AA?$AA@FNODOBFM@
  00497	e9 f4 02 00 00	 jmp	 $LN148@TCTranslat
  0049c	e9 ef 02 00 00	 jmp	 $LN61@TCTranslat
$LN62@TCTranslat:

; 1992 : 	else if (ulCode == IOCTL_DISK_LOGGING)

  004a1	81 7c 24 20 28
	00 07 00	 cmp	 DWORD PTR ulCode$[rsp], 458792 ; 00070028H
  004a9	75 11		 jne	 SHORT $LN60@TCTranslat

; 1993 : 		return (LPWSTR) _T ("IOCTL_DISK_LOGGING");

  004ab	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CG@LCBFNDKM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAL?$AAO?$AAG?$AAG?$AAI?$AAN?$AAG?$AA?$AA@FNODOBFM@
  004b2	e9 d9 02 00 00	 jmp	 $LN148@TCTranslat
  004b7	e9 d4 02 00 00	 jmp	 $LN59@TCTranslat
$LN60@TCTranslat:

; 1994 : 	else if (ulCode == IOCTL_DISK_FORMAT_TRACKS_EX)

  004bc	81 7c 24 20 2c
	c0 07 00	 cmp	 DWORD PTR ulCode$[rsp], 507948 ; 0007c02cH
  004c4	75 11		 jne	 SHORT $LN58@TCTranslat

; 1995 : 		return (LPWSTR) _T ("IOCTL_DISK_FORMAT_TRACKS_EX");

  004c6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DI@LHHOILKE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAO?$AAR?$AAM?$AAA?$AAT?$AA_?$AAT?$AAR?$AAA?$AAC?$AAK?$AAS?$AA_?$AAE?$AAX?$AA?$AA@FNODOBFM@
  004cd	e9 be 02 00 00	 jmp	 $LN148@TCTranslat
  004d2	e9 b9 02 00 00	 jmp	 $LN57@TCTranslat
$LN58@TCTranslat:

; 1996 : 	else if (ulCode == IOCTL_DISK_HISTOGRAM_STRUCTURE)

  004d7	81 7c 24 20 30
	00 07 00	 cmp	 DWORD PTR ulCode$[rsp], 458800 ; 00070030H
  004df	75 11		 jne	 SHORT $LN56@TCTranslat

; 1997 : 		return (LPWSTR) _T ("IOCTL_DISK_HISTOGRAM_STRUCTURE");

  004e1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DO@JMICENAF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAS?$AAT?$AAR?$AAU?$AAC?$AAT?$AAU?$AAR?$AAE?$AA?$AA@FNODOBFM@
  004e8	e9 a3 02 00 00	 jmp	 $LN148@TCTranslat
  004ed	e9 9e 02 00 00	 jmp	 $LN55@TCTranslat
$LN56@TCTranslat:

; 1998 : 	else if (ulCode == IOCTL_DISK_HISTOGRAM_DATA)

  004f2	81 7c 24 20 34
	00 07 00	 cmp	 DWORD PTR ulCode$[rsp], 458804 ; 00070034H
  004fa	75 11		 jne	 SHORT $LN54@TCTranslat

; 1999 : 		return (LPWSTR) _T ("IOCTL_DISK_HISTOGRAM_DATA");

  004fc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DE@OGHADOL@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@
  00503	e9 88 02 00 00	 jmp	 $LN148@TCTranslat
  00508	e9 83 02 00 00	 jmp	 $LN53@TCTranslat
$LN54@TCTranslat:

; 2000 : 	else if (ulCode == IOCTL_DISK_HISTOGRAM_RESET)

  0050d	81 7c 24 20 38
	00 07 00	 cmp	 DWORD PTR ulCode$[rsp], 458808 ; 00070038H
  00515	75 11		 jne	 SHORT $LN52@TCTranslat

; 2001 : 		return (LPWSTR) _T ("IOCTL_DISK_HISTOGRAM_RESET");

  00517	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DG@BLHGEOGG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAH?$AAI?$AAS?$AAT?$AAO?$AAG?$AAR?$AAA?$AAM?$AA_?$AAR?$AAE?$AAS?$AAE?$AAT?$AA?$AA@FNODOBFM@
  0051e	e9 6d 02 00 00	 jmp	 $LN148@TCTranslat
  00523	e9 68 02 00 00	 jmp	 $LN51@TCTranslat
$LN52@TCTranslat:

; 2002 : 	else if (ulCode == IOCTL_DISK_REQUEST_STRUCTURE)

  00528	81 7c 24 20 3c
	00 07 00	 cmp	 DWORD PTR ulCode$[rsp], 458812 ; 0007003cH
  00530	75 11		 jne	 SHORT $LN50@TCTranslat

; 2003 : 		return (LPWSTR) _T ("IOCTL_DISK_REQUEST_STRUCTURE");

  00532	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DK@EFIEFEEG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAQ?$AAU?$AAE?$AAS?$AAT?$AA_?$AAS?$AAT?$AAR?$AAU?$AAC?$AAT?$AAU?$AAR?$AAE?$AA?$AA@FNODOBFM@
  00539	e9 52 02 00 00	 jmp	 $LN148@TCTranslat
  0053e	e9 4d 02 00 00	 jmp	 $LN49@TCTranslat
$LN50@TCTranslat:

; 2004 : 	else if (ulCode == IOCTL_DISK_REQUEST_DATA)

  00543	81 7c 24 20 40
	00 07 00	 cmp	 DWORD PTR ulCode$[rsp], 458816 ; 00070040H
  0054b	75 11		 jne	 SHORT $LN48@TCTranslat

; 2005 : 		return (LPWSTR) _T ("IOCTL_DISK_REQUEST_DATA");

  0054d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DA@EGLLKJNO@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAQ?$AAU?$AAE?$AAS?$AAT?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@
  00554	e9 37 02 00 00	 jmp	 $LN148@TCTranslat
  00559	e9 32 02 00 00	 jmp	 $LN47@TCTranslat
$LN48@TCTranslat:

; 2006 : 	else if (ulCode == IOCTL_DISK_CONTROLLER_NUMBER)

  0055e	81 7c 24 20 44
	00 07 00	 cmp	 DWORD PTR ulCode$[rsp], 458820 ; 00070044H
  00566	75 11		 jne	 SHORT $LN46@TCTranslat

; 2007 : 		return (LPWSTR) _T ("IOCTL_DISK_CONTROLLER_NUMBER");

  00568	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DK@NNJOEKIN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAC?$AAO?$AAN?$AAT?$AAR?$AAO?$AAL?$AAL?$AAE?$AAR?$AA_?$AAN?$AAU?$AAM?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@
  0056f	e9 1c 02 00 00	 jmp	 $LN148@TCTranslat
  00574	e9 17 02 00 00	 jmp	 $LN45@TCTranslat
$LN46@TCTranslat:

; 2008 : 	else if (ulCode == SMART_GET_VERSION)

  00579	81 7c 24 20 80
	40 07 00	 cmp	 DWORD PTR ulCode$[rsp], 475264 ; 00074080H
  00581	75 11		 jne	 SHORT $LN44@TCTranslat

; 2009 : 		return (LPWSTR) _T ("SMART_GET_VERSION");

  00583	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CE@PLNOGJJD@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAG?$AAE?$AAT?$AA_?$AAV?$AAE?$AAR?$AAS?$AAI?$AAO?$AAN?$AA?$AA@FNODOBFM@
  0058a	e9 01 02 00 00	 jmp	 $LN148@TCTranslat
  0058f	e9 fc 01 00 00	 jmp	 $LN43@TCTranslat
$LN44@TCTranslat:

; 2010 : 	else if (ulCode == SMART_SEND_DRIVE_COMMAND)

  00594	81 7c 24 20 84
	c0 07 00	 cmp	 DWORD PTR ulCode$[rsp], 508036 ; 0007c084H
  0059c	75 11		 jne	 SHORT $LN42@TCTranslat

; 2011 : 		return (LPWSTR) _T ("SMART_SEND_DRIVE_COMMAND");

  0059e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DC@MGFPICHJ@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAS?$AAE?$AAN?$AAD?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAC?$AAO?$AAM?$AAM?$AAA?$AAN?$AAD?$AA?$AA@FNODOBFM@
  005a5	e9 e6 01 00 00	 jmp	 $LN148@TCTranslat
  005aa	e9 e1 01 00 00	 jmp	 $LN41@TCTranslat
$LN42@TCTranslat:

; 2012 : 	else if (ulCode == SMART_RCV_DRIVE_DATA)

  005af	81 7c 24 20 88
	c0 07 00	 cmp	 DWORD PTR ulCode$[rsp], 508040 ; 0007c088H
  005b7	75 11		 jne	 SHORT $LN40@TCTranslat

; 2013 : 		return (LPWSTR) _T ("SMART_RCV_DRIVE_DATA");

  005b9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CK@JCHEBCIE@?$AAS?$AAM?$AAA?$AAR?$AAT?$AA_?$AAR?$AAC?$AAV?$AA_?$AAD?$AAR?$AAI?$AAV?$AAE?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$AA@FNODOBFM@
  005c0	e9 cb 01 00 00	 jmp	 $LN148@TCTranslat
  005c5	e9 c6 01 00 00	 jmp	 $LN39@TCTranslat
$LN40@TCTranslat:

; 2014 : 	else if (ulCode == IOCTL_DISK_INTERNAL_SET_VERIFY)

  005ca	81 7c 24 20 03
	04 07 00	 cmp	 DWORD PTR ulCode$[rsp], 459779 ; 00070403H
  005d2	75 11		 jne	 SHORT $LN38@TCTranslat

; 2015 : 		return (LPWSTR) _T ("IOCTL_DISK_INTERNAL_SET_VERIFY");

  005d4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DO@JKPDDEIN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAN?$AAT?$AAE?$AAR?$AAN?$AAA?$AAL?$AA_?$AAS?$AAE?$AAT?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@
  005db	e9 b0 01 00 00	 jmp	 $LN148@TCTranslat
  005e0	e9 ab 01 00 00	 jmp	 $LN37@TCTranslat
$LN38@TCTranslat:

; 2016 : 	else if (ulCode == IOCTL_DISK_INTERNAL_CLEAR_VERIFY)

  005e5	81 7c 24 20 07
	04 07 00	 cmp	 DWORD PTR ulCode$[rsp], 459783 ; 00070407H
  005ed	75 11		 jne	 SHORT $LN36@TCTranslat

; 2017 : 		return (LPWSTR) _T ("IOCTL_DISK_INTERNAL_CLEAR_VERIFY");

  005ef	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EC@JFOBAPGC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAI?$AAN?$AAT?$AAE?$AAR?$AAN?$AAA?$AAL?$AA_?$AAC?$AAL?$AAE?$AAA?$AAR?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY@FNODOBFM@
  005f6	e9 95 01 00 00	 jmp	 $LN148@TCTranslat
  005fb	e9 90 01 00 00	 jmp	 $LN35@TCTranslat
$LN36@TCTranslat:

; 2018 : 	else if (ulCode == IOCTL_DISK_CHECK_VERIFY)

  00600	81 7c 24 20 00
	48 07 00	 cmp	 DWORD PTR ulCode$[rsp], 477184 ; 00074800H
  00608	75 11		 jne	 SHORT $LN34@TCTranslat

; 2019 : 		return (LPWSTR) _T ("IOCTL_DISK_CHECK_VERIFY");

  0060a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DA@DLMBEKMN@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAC?$AAH?$AAE?$AAC?$AAK?$AA_?$AAV?$AAE?$AAR?$AAI?$AAF?$AAY?$AA?$AA@FNODOBFM@
  00611	e9 7a 01 00 00	 jmp	 $LN148@TCTranslat
  00616	e9 75 01 00 00	 jmp	 $LN33@TCTranslat
$LN34@TCTranslat:

; 2020 : 	else if (ulCode == IOCTL_DISK_MEDIA_REMOVAL)

  0061b	81 7c 24 20 04
	48 07 00	 cmp	 DWORD PTR ulCode$[rsp], 477188 ; 00074804H
  00623	75 11		 jne	 SHORT $LN32@TCTranslat

; 2021 : 		return (LPWSTR) _T ("IOCTL_DISK_MEDIA_REMOVAL");

  00625	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DC@NMJCPDJD@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA_?$AAR?$AAE?$AAM?$AAO?$AAV?$AAA?$AAL?$AA?$AA@FNODOBFM@
  0062c	e9 5f 01 00 00	 jmp	 $LN148@TCTranslat
  00631	e9 5a 01 00 00	 jmp	 $LN31@TCTranslat
$LN32@TCTranslat:

; 2022 : 	else if (ulCode == IOCTL_DISK_EJECT_MEDIA)

  00636	81 7c 24 20 08
	48 07 00	 cmp	 DWORD PTR ulCode$[rsp], 477192 ; 00074808H
  0063e	75 11		 jne	 SHORT $LN30@TCTranslat

; 2023 : 		return (LPWSTR) _T ("IOCTL_DISK_EJECT_MEDIA");

  00640	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CO@KHEOABCH@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAE?$AAJ?$AAE?$AAC?$AAT?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA?$AA@FNODOBFM@
  00647	e9 44 01 00 00	 jmp	 $LN148@TCTranslat
  0064c	e9 3f 01 00 00	 jmp	 $LN29@TCTranslat
$LN30@TCTranslat:

; 2024 : 	else if (ulCode == IOCTL_DISK_LOAD_MEDIA)

  00651	81 7c 24 20 0c
	48 07 00	 cmp	 DWORD PTR ulCode$[rsp], 477196 ; 0007480cH
  00659	75 11		 jne	 SHORT $LN28@TCTranslat

; 2025 : 		return (LPWSTR) _T ("IOCTL_DISK_LOAD_MEDIA");

  0065b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CM@GNBBIMEE@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAL?$AAO?$AAA?$AAD?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA?$AA@FNODOBFM@
  00662	e9 29 01 00 00	 jmp	 $LN148@TCTranslat
  00667	e9 24 01 00 00	 jmp	 $LN27@TCTranslat
$LN28@TCTranslat:

; 2026 : 	else if (ulCode == IOCTL_DISK_RESERVE)

  0066c	81 7c 24 20 10
	48 07 00	 cmp	 DWORD PTR ulCode$[rsp], 477200 ; 00074810H
  00674	75 11		 jne	 SHORT $LN26@TCTranslat

; 2027 : 		return (LPWSTR) _T ("IOCTL_DISK_RESERVE");

  00676	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CG@MJDBKCLM@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAS?$AAE?$AAR?$AAV?$AAE?$AA?$AA@FNODOBFM@
  0067d	e9 0e 01 00 00	 jmp	 $LN148@TCTranslat
  00682	e9 09 01 00 00	 jmp	 $LN25@TCTranslat
$LN26@TCTranslat:

; 2028 : 	else if (ulCode == IOCTL_DISK_RELEASE)

  00687	81 7c 24 20 14
	48 07 00	 cmp	 DWORD PTR ulCode$[rsp], 477204 ; 00074814H
  0068f	75 11		 jne	 SHORT $LN24@TCTranslat

; 2029 : 		return (LPWSTR) _T ("IOCTL_DISK_RELEASE");

  00691	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CG@BFEEHHEK@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAR?$AAE?$AAL?$AAE?$AAA?$AAS?$AAE?$AA?$AA@FNODOBFM@
  00698	e9 f3 00 00 00	 jmp	 $LN148@TCTranslat
  0069d	e9 ee 00 00 00	 jmp	 $LN23@TCTranslat
$LN24@TCTranslat:

; 2030 : 	else if (ulCode == IOCTL_DISK_FIND_NEW_DEVICES)

  006a2	81 7c 24 20 18
	48 07 00	 cmp	 DWORD PTR ulCode$[rsp], 477208 ; 00074818H
  006aa	75 11		 jne	 SHORT $LN22@TCTranslat

; 2031 : 		return (LPWSTR) _T ("IOCTL_DISK_FIND_NEW_DEVICES");

  006ac	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DI@EBJJOMKC@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAF?$AAI?$AAN?$AAD?$AA_?$AAN?$AAE?$AAW?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AAS?$AA?$AA@FNODOBFM@
  006b3	e9 d8 00 00 00	 jmp	 $LN148@TCTranslat
  006b8	e9 d3 00 00 00	 jmp	 $LN21@TCTranslat
$LN22@TCTranslat:

; 2032 : 	else if (ulCode == IOCTL_DISK_GET_MEDIA_TYPES)

  006bd	81 7c 24 20 00
	0c 07 00	 cmp	 DWORD PTR ulCode$[rsp], 461824 ; 00070c00H
  006c5	75 11		 jne	 SHORT $LN20@TCTranslat

; 2033 : 		return (LPWSTR) _T ("IOCTL_DISK_GET_MEDIA_TYPES");

  006c7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DG@MIHPHMPG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAD?$AAI?$AAS?$AAK?$AA_?$AAG?$AAE?$AAT?$AA_?$AAM?$AAE?$AAD?$AAI?$AAA?$AA_?$AAT?$AAY?$AAP?$AAE?$AAS?$AA?$AA@FNODOBFM@
  006ce	e9 bd 00 00 00	 jmp	 $LN148@TCTranslat
  006d3	e9 b8 00 00 00	 jmp	 $LN19@TCTranslat
$LN20@TCTranslat:

; 2034 : 	else if (ulCode == IOCTL_STORAGE_SET_HOTPLUG_INFO)

  006d8	81 7c 24 20 18
	cc 2d 00	 cmp	 DWORD PTR ulCode$[rsp], 3001368 ; 002dcc18H
  006e0	75 11		 jne	 SHORT $LN18@TCTranslat

; 2035 : 		return (LPWSTR) _T ("IOCTL_STORAGE_SET_HOTPLUG_INFO");

  006e2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DO@MEELNMKF@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAS?$AAT?$AAO?$AAR?$AAA?$AAG?$AAE?$AA_?$AAS?$AAE?$AAT?$AA_?$AAH?$AAO?$AAT?$AAP?$AAL?$AAU?$AAG?$AA_?$AAI?$AAN?$AAF?$AAO?$AA?$AA@FNODOBFM@
  006e9	e9 a2 00 00 00	 jmp	 $LN148@TCTranslat
  006ee	e9 9d 00 00 00	 jmp	 $LN17@TCTranslat
$LN18@TCTranslat:

; 2036 : 	else if (ulCode == IRP_MJ_READ)

  006f3	83 7c 24 20 03	 cmp	 DWORD PTR ulCode$[rsp], 3
  006f8	75 11		 jne	 SHORT $LN16@TCTranslat

; 2037 : 		return (LPWSTR) _T ("IRP_MJ_READ");

  006fa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1BI@CFPHGFDN@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAR?$AAE?$AAA?$AAD?$AA?$AA@FNODOBFM@
  00701	e9 8a 00 00 00	 jmp	 $LN148@TCTranslat
  00706	e9 85 00 00 00	 jmp	 $LN15@TCTranslat
$LN16@TCTranslat:

; 2038 : 	else if (ulCode == IRP_MJ_WRITE)

  0070b	83 7c 24 20 04	 cmp	 DWORD PTR ulCode$[rsp], 4
  00710	75 0b		 jne	 SHORT $LN14@TCTranslat

; 2039 : 		return (LPWSTR) _T ("IRP_MJ_WRITE");

  00712	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1BK@HGBIKEDO@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAW?$AAR?$AAI?$AAT?$AAE?$AA?$AA@FNODOBFM@
  00719	eb 75		 jmp	 SHORT $LN148@TCTranslat
  0071b	eb 73		 jmp	 SHORT $LN13@TCTranslat
$LN14@TCTranslat:

; 2040 : 	else if (ulCode == IRP_MJ_CREATE)

  0071d	83 7c 24 20 00	 cmp	 DWORD PTR ulCode$[rsp], 0
  00722	75 0b		 jne	 SHORT $LN12@TCTranslat

; 2041 : 		return (LPWSTR) _T ("IRP_MJ_CREATE");

  00724	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1BM@KFEHBPBD@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAR?$AAE?$AAA?$AAT?$AAE?$AA?$AA@FNODOBFM@
  0072b	eb 63		 jmp	 SHORT $LN148@TCTranslat
  0072d	eb 61		 jmp	 SHORT $LN11@TCTranslat
$LN12@TCTranslat:

; 2042 : 	else if (ulCode == IRP_MJ_CLOSE)

  0072f	83 7c 24 20 02	 cmp	 DWORD PTR ulCode$[rsp], 2
  00734	75 0b		 jne	 SHORT $LN10@TCTranslat

; 2043 : 		return (LPWSTR) _T ("IRP_MJ_CLOSE");

  00736	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1BK@JLALPKNJ@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAL?$AAO?$AAS?$AAE?$AA?$AA@FNODOBFM@
  0073d	eb 51		 jmp	 SHORT $LN148@TCTranslat
  0073f	eb 4f		 jmp	 SHORT $LN9@TCTranslat
$LN10@TCTranslat:

; 2044 : 	else if (ulCode == IRP_MJ_CLEANUP)

  00741	83 7c 24 20 12	 cmp	 DWORD PTR ulCode$[rsp], 18
  00746	75 0b		 jne	 SHORT $LN8@TCTranslat

; 2045 : 		return (LPWSTR) _T ("IRP_MJ_CLEANUP");

  00748	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1BO@GEGOKABG@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAC?$AAL?$AAE?$AAA?$AAN?$AAU?$AAP?$AA?$AA@FNODOBFM@
  0074f	eb 3f		 jmp	 SHORT $LN148@TCTranslat
  00751	eb 3d		 jmp	 SHORT $LN7@TCTranslat
$LN8@TCTranslat:

; 2046 : 	else if (ulCode == IRP_MJ_FLUSH_BUFFERS)

  00753	83 7c 24 20 09	 cmp	 DWORD PTR ulCode$[rsp], 9
  00758	75 0b		 jne	 SHORT $LN6@TCTranslat

; 2047 : 		return (LPWSTR) _T ("IRP_MJ_FLUSH_BUFFERS");

  0075a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CK@MCKHKFDD@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAF?$AAL?$AAU?$AAS?$AAH?$AA_?$AAB?$AAU?$AAF?$AAF?$AAE?$AAR?$AAS?$AA?$AA@FNODOBFM@
  00761	eb 2d		 jmp	 SHORT $LN148@TCTranslat
  00763	eb 2b		 jmp	 SHORT $LN5@TCTranslat
$LN6@TCTranslat:

; 2048 : 	else if (ulCode == IRP_MJ_SHUTDOWN)

  00765	83 7c 24 20 10	 cmp	 DWORD PTR ulCode$[rsp], 16
  0076a	75 0b		 jne	 SHORT $LN4@TCTranslat

; 2049 : 		return (LPWSTR) _T ("IRP_MJ_SHUTDOWN");

  0076c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CA@FOECGGNC@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAS?$AAH?$AAU?$AAT?$AAD?$AAO?$AAW?$AAN?$AA?$AA@FNODOBFM@
  00773	eb 1b		 jmp	 SHORT $LN148@TCTranslat
  00775	eb 19		 jmp	 SHORT $LN3@TCTranslat
$LN4@TCTranslat:

; 2050 : 	else if (ulCode == IRP_MJ_DEVICE_CONTROL)

  00777	83 7c 24 20 0e	 cmp	 DWORD PTR ulCode$[rsp], 14
  0077c	75 0b		 jne	 SHORT $LN2@TCTranslat

; 2051 : 		return (LPWSTR) _T ("IRP_MJ_DEVICE_CONTROL");

  0077e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CM@DKLAEDLO@?$AAI?$AAR?$AAP?$AA_?$AAM?$AAJ?$AA_?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AA_?$AAC?$AAO?$AAN?$AAT?$AAR?$AAO?$AAL?$AA?$AA@FNODOBFM@
  00785	eb 09		 jmp	 SHORT $LN148@TCTranslat

; 2052 : 	else

  00787	eb 07		 jmp	 SHORT $LN1@TCTranslat
$LN2@TCTranslat:

; 2053 : 	{
; 2054 : 		return (LPWSTR) _T ("IOCTL");

  00789	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1M@KHJOIALG@?$AAI?$AAO?$AAC?$AAT?$AAL?$AA?$AA@FNODOBFM@
$LN1@TCTranslat:
$LN3@TCTranslat:
$LN5@TCTranslat:
$LN7@TCTranslat:
$LN9@TCTranslat:
$LN11@TCTranslat:
$LN13@TCTranslat:
$LN15@TCTranslat:
$LN17@TCTranslat:
$LN19@TCTranslat:
$LN21@TCTranslat:
$LN23@TCTranslat:
$LN25@TCTranslat:
$LN27@TCTranslat:
$LN29@TCTranslat:
$LN31@TCTranslat:
$LN33@TCTranslat:
$LN35@TCTranslat:
$LN37@TCTranslat:
$LN39@TCTranslat:
$LN41@TCTranslat:
$LN43@TCTranslat:
$LN45@TCTranslat:
$LN47@TCTranslat:
$LN49@TCTranslat:
$LN51@TCTranslat:
$LN53@TCTranslat:
$LN55@TCTranslat:
$LN57@TCTranslat:
$LN59@TCTranslat:
$LN61@TCTranslat:
$LN63@TCTranslat:
$LN65@TCTranslat:
$LN67@TCTranslat:
$LN69@TCTranslat:
$LN71@TCTranslat:
$LN73@TCTranslat:
$LN75@TCTranslat:
$LN77@TCTranslat:
$LN79@TCTranslat:
$LN81@TCTranslat:
$LN83@TCTranslat:
$LN85@TCTranslat:
$LN87@TCTranslat:
$LN89@TCTranslat:
$LN91@TCTranslat:
$LN93@TCTranslat:
$LN95@TCTranslat:
$LN97@TCTranslat:
$LN99@TCTranslat:
$LN101@TCTranslat:
$LN103@TCTranslat:
$LN105@TCTranslat:
$LN148@TCTranslat:

; 2055 : 	}
; 2056 : }

  00790	48 83 c4 18	 add	 rsp, 24
  00794	c3		 ret	 0
  00795	0f 1f 00	 npad	 3
$LN152@TCTranslat:
  00798	00 00 00 00	 DD	 $LN130@TCTranslat
  0079c	00 00 00 00	 DD	 $LN136@TCTranslat
  007a0	00 00 00 00	 DD	 $LN116@TCTranslat
  007a4	00 00 00 00	 DD	 $LN141@TCTranslat
  007a8	00 00 00 00	 DD	 $LN142@TCTranslat
  007ac	00 00 00 00	 DD	 $LN129@TCTranslat
  007b0	00 00 00 00	 DD	 $LN122@TCTranslat
  007b4	00 00 00 00	 DD	 $LN133@TCTranslat
  007b8	00 00 00 00	 DD	 $LN118@TCTranslat
  007bc	00 00 00 00	 DD	 $LN119@TCTranslat
  007c0	00 00 00 00	 DD	 $LN128@TCTranslat
  007c4	00 00 00 00	 DD	 $LN109@TCTranslat
  007c8	00 00 00 00	 DD	 $LN115@TCTranslat
  007cc	00 00 00 00	 DD	 $LN131@TCTranslat
  007d0	00 00 00 00	 DD	 $LN132@TCTranslat
  007d4	00 00 00 00	 DD	 $LN114@TCTranslat
  007d8	00 00 00 00	 DD	 $LN124@TCTranslat
  007dc	00 00 00 00	 DD	 $LN137@TCTranslat
  007e0	00 00 00 00	 DD	 $LN143@TCTranslat
  007e4	00 00 00 00	 DD	 $LN145@TCTranslat
  007e8	00 00 00 00	 DD	 $LN138@TCTranslat
  007ec	00 00 00 00	 DD	 $LN140@TCTranslat
  007f0	00 00 00 00	 DD	 $LN113@TCTranslat
  007f4	00 00 00 00	 DD	 $LN139@TCTranslat
  007f8	00 00 00 00	 DD	 $LN126@TCTranslat
  007fc	00 00 00 00	 DD	 $LN125@TCTranslat
  00800	00 00 00 00	 DD	 $LN117@TCTranslat
  00804	00 00 00 00	 DD	 $LN127@TCTranslat
  00808	00 00 00 00	 DD	 $LN120@TCTranslat
  0080c	00 00 00 00	 DD	 $LN110@TCTranslat
  00810	00 00 00 00	 DD	 $LN144@TCTranslat
  00814	00 00 00 00	 DD	 $LN134@TCTranslat
  00818	00 00 00 00	 DD	 $LN135@TCTranslat
  0081c	00 00 00 00	 DD	 $LN108@TCTranslat
  00820	00 00 00 00	 DD	 $LN121@TCTranslat
  00824	00 00 00 00	 DD	 $LN111@TCTranslat
  00828	00 00 00 00	 DD	 $LN112@TCTranslat
  0082c	00 00 00 00	 DD	 $LN123@TCTranslat
  00830	00 00 00 00	 DD	 $LN146@TCTranslat
$LN151@TCTranslat:
  00834	00		 DB	 0
  00835	26		 DB	 38			; 00000026H
  00836	26		 DB	 38			; 00000026H
  00837	26		 DB	 38			; 00000026H
  00838	01		 DB	 1
  00839	26		 DB	 38			; 00000026H
  0083a	26		 DB	 38			; 00000026H
  0083b	26		 DB	 38			; 00000026H
  0083c	02		 DB	 2
  0083d	26		 DB	 38			; 00000026H
  0083e	26		 DB	 38			; 00000026H
  0083f	26		 DB	 38			; 00000026H
  00840	03		 DB	 3
  00841	26		 DB	 38			; 00000026H
  00842	26		 DB	 38			; 00000026H
  00843	26		 DB	 38			; 00000026H
  00844	04		 DB	 4
  00845	26		 DB	 38			; 00000026H
  00846	26		 DB	 38			; 00000026H
  00847	26		 DB	 38			; 00000026H
  00848	05		 DB	 5
  00849	26		 DB	 38			; 00000026H
  0084a	26		 DB	 38			; 00000026H
  0084b	26		 DB	 38			; 00000026H
  0084c	06		 DB	 6
  0084d	26		 DB	 38			; 00000026H
  0084e	26		 DB	 38			; 00000026H
  0084f	26		 DB	 38			; 00000026H
  00850	07		 DB	 7
  00851	26		 DB	 38			; 00000026H
  00852	26		 DB	 38			; 00000026H
  00853	26		 DB	 38			; 00000026H
  00854	08		 DB	 8
  00855	26		 DB	 38			; 00000026H
  00856	26		 DB	 38			; 00000026H
  00857	26		 DB	 38			; 00000026H
  00858	09		 DB	 9
  00859	26		 DB	 38			; 00000026H
  0085a	26		 DB	 38			; 00000026H
  0085b	26		 DB	 38			; 00000026H
  0085c	0a		 DB	 10
  0085d	26		 DB	 38			; 00000026H
  0085e	26		 DB	 38			; 00000026H
  0085f	26		 DB	 38			; 00000026H
  00860	0b		 DB	 11
  00861	26		 DB	 38			; 00000026H
  00862	26		 DB	 38			; 00000026H
  00863	26		 DB	 38			; 00000026H
  00864	0c		 DB	 12
  00865	26		 DB	 38			; 00000026H
  00866	26		 DB	 38			; 00000026H
  00867	26		 DB	 38			; 00000026H
  00868	0d		 DB	 13
  00869	26		 DB	 38			; 00000026H
  0086a	26		 DB	 38			; 00000026H
  0086b	26		 DB	 38			; 00000026H
  0086c	0e		 DB	 14
  0086d	26		 DB	 38			; 00000026H
  0086e	26		 DB	 38			; 00000026H
  0086f	26		 DB	 38			; 00000026H
  00870	0f		 DB	 15
  00871	26		 DB	 38			; 00000026H
  00872	26		 DB	 38			; 00000026H
  00873	26		 DB	 38			; 00000026H
  00874	10		 DB	 16
  00875	26		 DB	 38			; 00000026H
  00876	26		 DB	 38			; 00000026H
  00877	26		 DB	 38			; 00000026H
  00878	11		 DB	 17
  00879	26		 DB	 38			; 00000026H
  0087a	26		 DB	 38			; 00000026H
  0087b	26		 DB	 38			; 00000026H
  0087c	12		 DB	 18
  0087d	26		 DB	 38			; 00000026H
  0087e	26		 DB	 38			; 00000026H
  0087f	26		 DB	 38			; 00000026H
  00880	13		 DB	 19
  00881	26		 DB	 38			; 00000026H
  00882	26		 DB	 38			; 00000026H
  00883	26		 DB	 38			; 00000026H
  00884	14		 DB	 20
  00885	26		 DB	 38			; 00000026H
  00886	26		 DB	 38			; 00000026H
  00887	26		 DB	 38			; 00000026H
  00888	15		 DB	 21
  00889	26		 DB	 38			; 00000026H
  0088a	26		 DB	 38			; 00000026H
  0088b	26		 DB	 38			; 00000026H
  0088c	16		 DB	 22
  0088d	26		 DB	 38			; 00000026H
  0088e	26		 DB	 38			; 00000026H
  0088f	26		 DB	 38			; 00000026H
  00890	17		 DB	 23
  00891	26		 DB	 38			; 00000026H
  00892	26		 DB	 38			; 00000026H
  00893	26		 DB	 38			; 00000026H
  00894	18		 DB	 24
  00895	26		 DB	 38			; 00000026H
  00896	26		 DB	 38			; 00000026H
  00897	26		 DB	 38			; 00000026H
  00898	19		 DB	 25
  00899	26		 DB	 38			; 00000026H
  0089a	26		 DB	 38			; 00000026H
  0089b	26		 DB	 38			; 00000026H
  0089c	1a		 DB	 26
  0089d	26		 DB	 38			; 00000026H
  0089e	26		 DB	 38			; 00000026H
  0089f	26		 DB	 38			; 00000026H
  008a0	1b		 DB	 27
  008a1	26		 DB	 38			; 00000026H
  008a2	26		 DB	 38			; 00000026H
  008a3	26		 DB	 38			; 00000026H
  008a4	1c		 DB	 28
  008a5	26		 DB	 38			; 00000026H
  008a6	26		 DB	 38			; 00000026H
  008a7	26		 DB	 38			; 00000026H
  008a8	1d		 DB	 29
  008a9	26		 DB	 38			; 00000026H
  008aa	26		 DB	 38			; 00000026H
  008ab	26		 DB	 38			; 00000026H
  008ac	1e		 DB	 30
  008ad	26		 DB	 38			; 00000026H
  008ae	26		 DB	 38			; 00000026H
  008af	26		 DB	 38			; 00000026H
  008b0	1f		 DB	 31
  008b1	26		 DB	 38			; 00000026H
  008b2	26		 DB	 38			; 00000026H
  008b3	26		 DB	 38			; 00000026H
  008b4	20		 DB	 32			; 00000020H
  008b5	26		 DB	 38			; 00000026H
  008b6	26		 DB	 38			; 00000026H
  008b7	26		 DB	 38			; 00000026H
  008b8	21		 DB	 33			; 00000021H
  008b9	26		 DB	 38			; 00000026H
  008ba	26		 DB	 38			; 00000026H
  008bb	26		 DB	 38			; 00000026H
  008bc	22		 DB	 34			; 00000022H
  008bd	26		 DB	 38			; 00000026H
  008be	26		 DB	 38			; 00000026H
  008bf	26		 DB	 38			; 00000026H
  008c0	23		 DB	 35			; 00000023H
  008c1	26		 DB	 38			; 00000026H
  008c2	26		 DB	 38			; 00000026H
  008c3	26		 DB	 38			; 00000026H
  008c4	24		 DB	 36			; 00000024H
  008c5	26		 DB	 38			; 00000026H
  008c6	26		 DB	 38			; 00000026H
  008c7	26		 DB	 38			; 00000026H
  008c8	25		 DB	 37			; 00000025H
TCTranslateCode ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	TCGetDosNameFromNumber
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCGetDosNameFromNumber DD imagerel $LN5
	DD	imagerel $LN5+232
	DD	imagerel $unwind$TCGetDosNameFromNumber
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCGetDosNameFromNumber DD 021d19H
	DD	0700a720eH
	DD	imagerel __GSHandlerCheck
	DD	038H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT TCGetDosNameFromNumber
_TEXT	SEGMENT
tmp$ = 8
j$ = 16
tv66 = 24
tv67 = 32
tv68 = 40
tv69 = 48
__$ArrayPad$ = 56
dosname$ = 80
nDriveNo$ = 88
TCGetDosNameFromNumber PROC				; COMDAT

; 1884 : {

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1885 : 	WCHAR tmp[3] =
; 1886 : 	{0, ':', 0};

  0001d	33 c0		 xor	 eax, eax
  0001f	66 89 44 24 08	 mov	 WORD PTR tmp$[rsp], ax
  00024	b8 3a 00 00 00	 mov	 eax, 58			; 0000003aH
  00029	66 89 44 24 0a	 mov	 WORD PTR tmp$[rsp+2], ax
  0002e	33 c0		 xor	 eax, eax
  00030	66 89 44 24 0c	 mov	 WORD PTR tmp$[rsp+4], ax

; 1887 : 	int j = nDriveNo + (WCHAR) 'A';

  00035	8b 44 24 58	 mov	 eax, DWORD PTR nDriveNo$[rsp]
  00039	83 c0 41	 add	 eax, 65			; 00000041H
  0003c	89 44 24 10	 mov	 DWORD PTR j$[rsp], eax

; 1888 : 
; 1889 : 	tmp[0] = (short) j;

  00040	0f b7 44 24 10	 movzx	 eax, WORD PTR j$[rsp]
  00045	66 89 44 24 08	 mov	 WORD PTR tmp$[rsp], ax

; 1890 : 	//This is a risk point from CVE-2015-7358, there are global and per user mounts, need more logic here.
; 1891 : 	wcscpy (dosname, (LPWSTR) DOS_MOUNT_PREFIX);

  0004a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1BK@LABJKOM@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$AA@FNODOBFM@
  00051	48 89 44 24 18	 mov	 QWORD PTR tv66[rsp], rax
  00056	48 8b 44 24 50	 mov	 rax, QWORD PTR dosname$[rsp]
  0005b	48 89 44 24 20	 mov	 QWORD PTR tv67[rsp], rax
  00060	48 8b 44 24 20	 mov	 rax, QWORD PTR tv67[rsp]
  00065	48 89 44 24 28	 mov	 QWORD PTR tv68[rsp], rax
$LN3@TCGetDosNa:
  0006a	48 8b 44 24 18	 mov	 rax, QWORD PTR tv66[rsp]
  0006f	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00072	66 89 44 24 30	 mov	 WORD PTR tv69[rsp], ax
  00077	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv67[rsp]
  0007c	0f b7 44 24 30	 movzx	 eax, WORD PTR tv69[rsp]
  00081	66 89 01	 mov	 WORD PTR [rcx], ax
  00084	48 8b 44 24 18	 mov	 rax, QWORD PTR tv66[rsp]
  00089	48 83 c0 02	 add	 rax, 2
  0008d	48 89 44 24 18	 mov	 QWORD PTR tv66[rsp], rax
  00092	48 8b 44 24 20	 mov	 rax, QWORD PTR tv67[rsp]
  00097	48 83 c0 02	 add	 rax, 2
  0009b	48 89 44 24 20	 mov	 QWORD PTR tv67[rsp], rax
  000a0	66 83 7c 24 30
	00		 cmp	 WORD PTR tv69[rsp], 0
  000a6	75 c2		 jne	 SHORT $LN3@TCGetDosNa

; 1892 : 	wcscat (dosname, tmp);

  000a8	48 8b 7c 24 50	 mov	 rdi, QWORD PTR dosname$[rsp]
  000ad	33 c0		 xor	 eax, eax
  000af	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  000b6	66 f2 af	 repne scasw
  000b9	48 83 ef 02	 sub	 rdi, 2
  000bd	48 8d 54 24 08	 lea	 rdx, QWORD PTR tmp$[rsp]
  000c2	33 c9		 xor	 ecx, ecx
$LL4@TCGetDosNa:
  000c4	0f b7 04 0a	 movzx	 eax, WORD PTR [rdx+rcx]
  000c8	66 89 04 0f	 mov	 WORD PTR [rdi+rcx], ax
  000cc	48 83 c1 02	 add	 rcx, 2
  000d0	66 85 c0	 test	 ax, ax
  000d3	75 ef		 jne	 SHORT $LL4@TCGetDosNa

; 1893 : }

  000d5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000da	48 33 cc	 xor	 rcx, rsp
  000dd	e8 00 00 00 00	 call	 __security_check_cookie
  000e2	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000e6	5f		 pop	 rdi
  000e7	c3		 ret	 0
TCGetDosNameFromNumber ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	TCGetNTNameFromNumber
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCGetNTNameFromNumber DD imagerel $LN4
	DD	imagerel $LN4+207
	DD	imagerel $unwind$TCGetNTNameFromNumber
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCGetNTNameFromNumber DD 011c19H
	DD	0c20dH
	DD	imagerel __GSHandlerCheck
	DD	058H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT TCGetNTNameFromNumber
_TEXT	SEGMENT
tmp$ = 40
j$ = 48
tv66 = 56
tv67 = 64
tv68 = 72
tv69 = 80
__$ArrayPad$ = 88
ntname$ = 112
nDriveNo$ = 120
TCGetNTNameFromNumber PROC				; COMDAT

; 1873 : {

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1874 : 	WCHAR tmp[3] =
; 1875 : 	{0, ':', 0};

  0001c	33 c0		 xor	 eax, eax
  0001e	66 89 44 24 28	 mov	 WORD PTR tmp$[rsp], ax
  00023	b8 3a 00 00 00	 mov	 eax, 58			; 0000003aH
  00028	66 89 44 24 2a	 mov	 WORD PTR tmp$[rsp+2], ax
  0002d	33 c0		 xor	 eax, eax
  0002f	66 89 44 24 2c	 mov	 WORD PTR tmp$[rsp+4], ax

; 1876 : 	int j = nDriveNo + (WCHAR) 'A';

  00034	8b 44 24 78	 mov	 eax, DWORD PTR nDriveNo$[rsp]
  00038	83 c0 41	 add	 eax, 65			; 00000041H
  0003b	89 44 24 30	 mov	 DWORD PTR j$[rsp], eax

; 1877 : 
; 1878 : 	tmp[0] = (short) j;

  0003f	0f b7 44 24 30	 movzx	 eax, WORD PTR j$[rsp]
  00044	66 89 44 24 28	 mov	 WORD PTR tmp$[rsp], ax

; 1879 : 	wcscpy (ntname, (LPWSTR) NT_MOUNT_PREFIX);

  00049	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DA@GMJGMIMP@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@FNODOBFM@
  00050	48 89 44 24 38	 mov	 QWORD PTR tv66[rsp], rax
  00055	48 8b 44 24 70	 mov	 rax, QWORD PTR ntname$[rsp]
  0005a	48 89 44 24 40	 mov	 QWORD PTR tv67[rsp], rax
  0005f	48 8b 44 24 40	 mov	 rax, QWORD PTR tv67[rsp]
  00064	48 89 44 24 48	 mov	 QWORD PTR tv68[rsp], rax
$LN3@TCGetNTNam:
  00069	48 8b 44 24 38	 mov	 rax, QWORD PTR tv66[rsp]
  0006e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00071	66 89 44 24 50	 mov	 WORD PTR tv69[rsp], ax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv67[rsp]
  0007b	0f b7 44 24 50	 movzx	 eax, WORD PTR tv69[rsp]
  00080	66 89 01	 mov	 WORD PTR [rcx], ax
  00083	48 8b 44 24 38	 mov	 rax, QWORD PTR tv66[rsp]
  00088	48 83 c0 02	 add	 rax, 2
  0008c	48 89 44 24 38	 mov	 QWORD PTR tv66[rsp], rax
  00091	48 8b 44 24 40	 mov	 rax, QWORD PTR tv67[rsp]
  00096	48 83 c0 02	 add	 rax, 2
  0009a	48 89 44 24 40	 mov	 QWORD PTR tv67[rsp], rax
  0009f	66 83 7c 24 50
	00		 cmp	 WORD PTR tv69[rsp], 0
  000a5	75 c2		 jne	 SHORT $LN3@TCGetNTNam

; 1880 : 	wcsncat (ntname, tmp, 1);

  000a7	41 b8 01 00 00
	00		 mov	 r8d, 1
  000ad	48 8d 54 24 28	 lea	 rdx, QWORD PTR tmp$[rsp]
  000b2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ntname$[rsp]
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncat

; 1881 : }

  000bd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000c2	48 33 cc	 xor	 rcx, rsp
  000c5	e8 00 00 00 00	 call	 __security_check_cookie
  000ca	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000ce	c3		 ret	 0
TCGetNTNameFromNumber ENDP
_TEXT	ENDS
PUBLIC	TCSleep
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCSleep DD imagerel $LN4
	DD	imagerel $LN4+143
	DD	imagerel $unwind$TCSleep
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCSleep DD 010801H
	DD	08208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT TCSleep
_TEXT	SEGMENT
timer$ = 48
duetime$ = 56
milliSeconds$ = 80
TCSleep	PROC						; COMDAT

; 1748 : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1749 : 	PKTIMER timer = (PKTIMER) TCalloc (sizeof (KTIMER));

  00008	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  0000e	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00013	33 c9		 xor	 ecx, ecx
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  0001b	48 89 44 24 30	 mov	 QWORD PTR timer$[rsp], rax

; 1750 : 	LARGE_INTEGER duetime;
; 1751 : 
; 1752 : 	if (!timer)

  00020	48 83 7c 24 30
	00		 cmp	 QWORD PTR timer$[rsp], 0
  00026	75 02		 jne	 SHORT $LN1@TCSleep

; 1753 : 		return;

  00028	eb 60		 jmp	 SHORT $LN2@TCSleep
$LN1@TCSleep:

; 1754 : 
; 1755 : 	duetime.QuadPart = (__int64) milliSeconds * -10000;

  0002a	48 63 44 24 50	 movsxd	 rax, DWORD PTR milliSeconds$[rsp]
  0002f	48 69 c0 f0 d8
	ff ff		 imul	 rax, -10000		; ffffffffffffd8f0H
  00036	48 89 44 24 38	 mov	 QWORD PTR duetime$[rsp], rax

; 1756 : 	KeInitializeTimerEx(timer, NotificationTimer);

  0003b	33 d2		 xor	 edx, edx
  0003d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR timer$[rsp]
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeTimerEx

; 1757 : 	KeSetTimerEx(timer, duetime, 0, NULL);

  00048	45 33 c9	 xor	 r9d, r9d
  0004b	45 33 c0	 xor	 r8d, r8d
  0004e	48 8b 54 24 38	 mov	 rdx, QWORD PTR duetime$[rsp]
  00053	48 8b 4c 24 30	 mov	 rcx, QWORD PTR timer$[rsp]
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetTimerEx

; 1758 : 
; 1759 : 	KeWaitForSingleObject (timer, Executive, KernelMode, FALSE, NULL);

  0005e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00067	45 33 c9	 xor	 r9d, r9d
  0006a	45 33 c0	 xor	 r8d, r8d
  0006d	33 d2		 xor	 edx, edx
  0006f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR timer$[rsp]
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 1760 : 
; 1761 : 	TCfree (timer);

  0007a	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  0007f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR timer$[rsp]
  00084	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN2@TCSleep:

; 1762 : }

  0008a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0008e	c3		 ret	 0
TCSleep	ENDP
_TEXT	ENDS
PUBLIC	TCStopVolumeThread
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCStopVolumeThread DD imagerel $LN6
	DD	imagerel $LN6+200
	DD	imagerel $unwind$TCStopVolumeThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCStopVolumeThread DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT TCStopVolumeThread
_TEXT	SEGMENT
ntStatus$ = 48
tv84 = 52
DeviceObject$ = 80
Extension$ = 88
TCStopVolumeThread PROC					; COMDAT

; 1717 : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1718 : 	NTSTATUS ntStatus;
; 1719 : 
; 1720 : 	if (DeviceObject);	/* Remove compiler warning */
; 1721 : 
; 1722 : 	Dump ("Signalling thread to quit...\n");

  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@IDJGLOL@Signalling?5thread?5to?5quit?4?4?4?6?$AA@FNODOBFM@
  00015	e8 00 00 00 00	 call	 DbgPrint

; 1723 : 
; 1724 : 	Extension->bThreadShouldQuit = TRUE;

  0001a	4c 8b 5c 24 58	 mov	 r11, QWORD PTR Extension$[rsp]
  0001f	41 c7 43 1c 01
	00 00 00	 mov	 DWORD PTR [r11+28], 1

; 1725 : 
; 1726 : 	KeReleaseSemaphore (&Extension->RequestSemaphore,
; 1727 : 			    0,
; 1728 : 			    1,
; 1729 : 			    TRUE);

  00027	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Extension$[rsp]
  0002c	48 83 c1 58	 add	 rcx, 88			; 00000058H
  00030	41 b1 01	 mov	 r9b, 1
  00033	41 b8 01 00 00
	00		 mov	 r8d, 1
  00039	33 d2		 xor	 edx, edx
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseSemaphore

; 1730 : 
; 1731 : 	ntStatus = KeWaitForSingleObject (Extension->peThread,
; 1732 : 					  Executive,
; 1733 : 					  KernelMode,
; 1734 : 					  FALSE,
; 1735 : 					  NULL);

  00041	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0004a	45 33 c9	 xor	 r9d, r9d
  0004d	45 33 c0	 xor	 r8d, r8d
  00050	33 d2		 xor	 edx, edx
  00052	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Extension$[rsp]
  00057	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  00061	89 44 24 30	 mov	 DWORD PTR ntStatus$[rsp], eax

; 1736 : 
; 1737 : 	ASSERT (NT_SUCCESS (ntStatus));

  00065	83 7c 24 30 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  0006a	7d 27		 jge	 SHORT $LN4@TCStopVolu
  0006c	45 33 c9	 xor	 r9d, r9d
  0006f	41 b8 c9 06 00
	00		 mov	 r8d, 1737		; 000006c9H
  00075	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@MEOILBFO@NT_SUCCESS?5?$CIntStatus?$CJ?$AA@FNODOBFM@
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  00089	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv84[rsp], 0
  00091	eb 08		 jmp	 SHORT $LN5@TCStopVolu
$LN4@TCStopVolu:
  00093	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv84[rsp], 1
$LN5@TCStopVolu:

; 1738 : 
; 1739 : 	ObDereferenceObject (Extension->peThread);

  0009b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Extension$[rsp]
  000a0	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  000a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 1740 : 	Extension->peThread = NULL;

  000aa	4c 8b 5c 24 58	 mov	 r11, QWORD PTR Extension$[rsp]
  000af	49 c7 43 20 00
	00 00 00	 mov	 QWORD PTR [r11+32], 0

; 1741 : 
; 1742 : 	Dump ("Thread exited\n");

  000b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@OPFPPFJJ@Thread?5exited?6?$AA@FNODOBFM@
  000be	e8 00 00 00 00	 call	 DbgPrint

; 1743 : }

  000c3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c7	c3		 ret	 0
TCStopVolumeThread ENDP
_TEXT	ENDS
PUBLIC	TCStopThread
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCStopThread DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$TCStopThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCStopThread DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT TCStopThread
_TEXT	SEGMENT
kThread$ = 64
wakeUpEvent$ = 72
TCStopThread PROC					; COMDAT

; 1630 : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1631 : 	if (wakeUpEvent)

  0000e	48 83 7c 24 48
	00		 cmp	 QWORD PTR wakeUpEvent$[rsp], 0
  00014	74 10		 je	 SHORT $LN1@TCStopThre

; 1632 : 		KeSetEvent (wakeUpEvent, 0, FALSE);

  00016	45 33 c0	 xor	 r8d, r8d
  00019	33 d2		 xor	 edx, edx
  0001b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR wakeUpEvent$[rsp]
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent
$LN1@TCStopThre:

; 1633 : 
; 1634 : 	KeWaitForSingleObject (kThread, Executive, KernelMode, FALSE, NULL);

  00026	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002f	45 33 c9	 xor	 r9d, r9d
  00032	45 33 c0	 xor	 r8d, r8d
  00035	33 d2		 xor	 edx, edx
  00037	48 8b 4c 24 40	 mov	 rcx, QWORD PTR kThread$[rsp]
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 1635 : 	ObDereferenceObject (kThread);

  00042	48 8b 4c 24 40	 mov	 rcx, QWORD PTR kThread$[rsp]
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 1636 : }

  0004d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00051	c3		 ret	 0
TCStopThread ENDP
_TEXT	ENDS
PUBLIC	TCStartThreadInProcess
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCStartThreadInProcess DD imagerel $LN8
	DD	imagerel $LN8+403
	DD	imagerel $unwind$TCStartThreadInProcess
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCStartThreadInProcess DD 021b01H
	DD	013011bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT TCStartThreadInProcess
_TEXT	SEGMENT
threadObjAttributes$ = 64
processHandle$ = 112
threadHandle$ = 120
status$ = 128
threadProc$ = 160
threadArg$ = 168
kThread$ = 176
process$ = 184
TCStartThreadInProcess PROC				; COMDAT

; 1594 : {

$LN8:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1595 : 	NTSTATUS status;
; 1596 : 	HANDLE threadHandle;
; 1597 : 	HANDLE processHandle = NULL;

  0001b	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR processHandle$[rsp], 0

; 1598 : 	OBJECT_ATTRIBUTES threadObjAttributes;
; 1599 : 
; 1600 : 	if (process)

  00024	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR process$[rsp], 0
  0002d	74 4e		 je	 SHORT $LN5@TCStartThr

; 1601 : 	{
; 1602 : 		status = ObOpenObjectByPointer (process, OBJ_KERNEL_HANDLE, NULL, 0, NULL, KernelMode, &processHandle);

  0002f	48 8d 44 24 70	 lea	 rax, QWORD PTR processHandle$[rsp]
  00034	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00039	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  0003e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00047	45 33 c9	 xor	 r9d, r9d
  0004a	45 33 c0	 xor	 r8d, r8d
  0004d	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  00052	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR process$[rsp]
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObOpenObjectByPointer
  00060	89 84 24 80 00
	00 00		 mov	 DWORD PTR status$[rsp], eax

; 1603 : 		if (!NT_SUCCESS (status))

  00067	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR status$[rsp], 0
  0006f	7d 0c		 jge	 SHORT $LN4@TCStartThr

; 1604 : 			return status;

  00071	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR status$[rsp]
  00078	e9 0e 01 00 00	 jmp	 $LN6@TCStartThr
$LN4@TCStartThr:
$LN5@TCStartThr:

; 1605 : 	}
; 1606 : 
; 1607 : 	InitializeObjectAttributes (&threadObjAttributes, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);

  0007d	c7 44 24 40 30
	00 00 00	 mov	 DWORD PTR threadObjAttributes$[rsp], 48 ; 00000030H
  00085	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR threadObjAttributes$[rsp+8], 0
  0008e	c7 44 24 58 00
	02 00 00	 mov	 DWORD PTR threadObjAttributes$[rsp+24], 512 ; 00000200H
  00096	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR threadObjAttributes$[rsp+16], 0
  0009f	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR threadObjAttributes$[rsp+32], 0
  000a8	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR threadObjAttributes$[rsp+40], 0

; 1608 : 	
; 1609 : 	status = PsCreateSystemThread (&threadHandle, THREAD_ALL_ACCESS, &threadObjAttributes, processHandle, NULL, threadProc, threadArg);

  000b1	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR threadArg$[rsp]
  000b9	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000be	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR threadProc$[rsp]
  000c6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000cb	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000d4	4c 8b 4c 24 70	 mov	 r9, QWORD PTR processHandle$[rsp]
  000d9	4c 8d 44 24 40	 lea	 r8, QWORD PTR threadObjAttributes$[rsp]
  000de	ba ff 03 1f 00	 mov	 edx, 2032639		; 001f03ffH
  000e3	48 8d 4c 24 78	 lea	 rcx, QWORD PTR threadHandle$[rsp]
  000e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsCreateSystemThread
  000ee	89 84 24 80 00
	00 00		 mov	 DWORD PTR status$[rsp], eax

; 1610 : 	if (!NT_SUCCESS (status))

  000f5	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR status$[rsp], 0
  000fd	7d 0c		 jge	 SHORT $LN3@TCStartThr

; 1611 : 		return status;

  000ff	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR status$[rsp]
  00106	e9 80 00 00 00	 jmp	 $LN6@TCStartThr
$LN3@TCStartThr:

; 1612 : 
; 1613 : 	status = ObReferenceObjectByHandle (threadHandle, THREAD_ALL_ACCESS, NULL, KernelMode, (PVOID *) kThread, NULL);

  0010b	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00114	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR kThread$[rsp]
  0011c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00121	45 33 c9	 xor	 r9d, r9d
  00124	45 33 c0	 xor	 r8d, r8d
  00127	ba ff 03 1f 00	 mov	 edx, 2032639		; 001f03ffH
  0012c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR threadHandle$[rsp]
  00131	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObReferenceObjectByHandle
  00137	89 84 24 80 00
	00 00		 mov	 DWORD PTR status$[rsp], eax

; 1614 : 	if (!NT_SUCCESS (status))

  0013e	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR status$[rsp], 0
  00146	7d 23		 jge	 SHORT $LN2@TCStartThr

; 1615 : 	{
; 1616 : 		ZwClose (threadHandle);

  00148	48 8b 4c 24 78	 mov	 rcx, QWORD PTR threadHandle$[rsp]
  0014d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 1617 : 		*kThread = NULL;

  00153	4c 8b 9c 24 b0
	00 00 00	 mov	 r11, QWORD PTR kThread$[rsp]
  0015b	49 c7 03 00 00
	00 00		 mov	 QWORD PTR [r11], 0

; 1618 : 		return status;

  00162	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR status$[rsp]
  00169	eb 20		 jmp	 SHORT $LN6@TCStartThr
$LN2@TCStartThr:

; 1619 : 	}
; 1620 : 
; 1621 : 	if (processHandle)

  0016b	48 83 7c 24 70
	00		 cmp	 QWORD PTR processHandle$[rsp], 0
  00171	74 0b		 je	 SHORT $LN1@TCStartThr

; 1622 : 		ZwClose (processHandle);

  00173	48 8b 4c 24 70	 mov	 rcx, QWORD PTR processHandle$[rsp]
  00178	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
$LN1@TCStartThr:

; 1623 : 
; 1624 : 	ZwClose (threadHandle);

  0017e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR threadHandle$[rsp]
  00183	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 1625 : 	return STATUS_SUCCESS;

  00189	33 c0		 xor	 eax, eax
$LN6@TCStartThr:

; 1626 : }

  0018b	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00192	c3		 ret	 0
TCStartThreadInProcess ENDP
_TEXT	ENDS
PUBLIC	TCStartThread
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCStartThread DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$TCStartThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCStartThread DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT TCStartThread
_TEXT	SEGMENT
threadProc$ = 48
threadArg$ = 56
kThread$ = 64
TCStartThread PROC					; COMDAT

; 1588 : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1589 : 	return TCStartThreadInProcess (threadProc, threadArg, kThread, NULL);

  00013	45 33 c9	 xor	 r9d, r9d
  00016	4c 8b 44 24 40	 mov	 r8, QWORD PTR kThread$[rsp]
  0001b	48 8b 54 24 38	 mov	 rdx, QWORD PTR threadArg$[rsp]
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR threadProc$[rsp]
  00025	e8 00 00 00 00	 call	 TCStartThreadInProcess

; 1590 : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
TCStartThread ENDP
_TEXT	ENDS
PUBLIC	RootDeviceControlMutexRelease
RootDeviceControlMutex DB 038H DUP (?)
;	COMDAT pdata
pdata	SEGMENT
$pdata$RootDeviceControlMutexRelease DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$RootDeviceControlMutexRelease
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RootDeviceControlMutexRelease DD 010401H
	DD	04204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT RootDeviceControlMutexRelease
_TEXT	SEGMENT
RootDeviceControlMutexRelease PROC			; COMDAT

; 490  : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 491  : 	KeReleaseMutex (&RootDeviceControlMutex, FALSE);

  00004	33 d2		 xor	 edx, edx
  00006	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:RootDeviceControlMutex
  0000d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseMutex

; 492  : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
RootDeviceControlMutexRelease ENDP
_TEXT	ENDS
PUBLIC	RootDeviceControlMutexAcquireNoWait
;	COMDAT pdata
pdata	SEGMENT
$pdata$RootDeviceControlMutexAcquireNoWait DD imagerel $LN5
	DD	imagerel $LN5+92
	DD	imagerel $unwind$RootDeviceControlMutexAcquireNoWait
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RootDeviceControlMutexAcquireNoWait DD 010401H
	DD	0a204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT RootDeviceControlMutexAcquireNoWait
_TEXT	SEGMENT
status$ = 48
timeout$ = 56
tv72 = 64
RootDeviceControlMutexAcquireNoWait PROC		; COMDAT

; 479  : {

$LN5:
  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 480  : 	NTSTATUS status;
; 481  : 	LARGE_INTEGER timeout;
; 482  : 	timeout.QuadPart = 0;

  00004	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR timeout$[rsp], 0

; 483  : 
; 484  : 	status = KeWaitForMutexObject (&RootDeviceControlMutex, Executive, KernelMode, FALSE, &timeout);

  0000d	48 8d 44 24 38	 lea	 rax, QWORD PTR timeout$[rsp]
  00012	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00017	45 33 c9	 xor	 r9d, r9d
  0001a	45 33 c0	 xor	 r8d, r8d
  0001d	33 d2		 xor	 edx, edx
  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:RootDeviceControlMutex
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  0002c	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax

; 485  : 	return NT_SUCCESS (status) && status != STATUS_TIMEOUT;

  00030	83 7c 24 30 00	 cmp	 DWORD PTR status$[rsp], 0
  00035	7c 14		 jl	 SHORT $LN3@RootDevice
  00037	81 7c 24 30 02
	01 00 00	 cmp	 DWORD PTR status$[rsp], 258 ; 00000102H
  0003f	74 0a		 je	 SHORT $LN3@RootDevice
  00041	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00049	eb 08		 jmp	 SHORT $LN4@RootDevice
$LN3@RootDevice:
  0004b	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN4@RootDevice:
  00053	8b 44 24 40	 mov	 eax, DWORD PTR tv72[rsp]

; 486  : }

  00057	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0005b	c3		 ret	 0
RootDeviceControlMutexAcquireNoWait ENDP
_TEXT	ENDS
PUBLIC	GetVirtualVolumeDeviceObject
; Function compile flags: /Odtp
;	COMDAT GetVirtualVolumeDeviceObject
_TEXT	SEGMENT
driveNumber$ = 8
GetVirtualVolumeDeviceObject PROC			; COMDAT

; 191  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 192  : 	if (driveNumber < MIN_MOUNTED_VOLUME_DRIVE_NUMBER || driveNumber > MAX_MOUNTED_VOLUME_DRIVE_NUMBER)

  00004	83 7c 24 08 00	 cmp	 DWORD PTR driveNumber$[rsp], 0
  00009	7c 07		 jl	 SHORT $LN1@GetVirtual
  0000b	83 7c 24 08 19	 cmp	 DWORD PTR driveNumber$[rsp], 25
  00010	7e 04		 jle	 SHORT $LN2@GetVirtual
$LN1@GetVirtual:

; 193  : 		return NULL;

  00012	33 c0		 xor	 eax, eax
  00014	eb 10		 jmp	 SHORT $LN3@GetVirtual
$LN2@GetVirtual:

; 194  : 
; 195  : 	return VirtualVolumeDeviceObjects[driveNumber];

  00016	48 63 4c 24 08	 movsxd	 rcx, DWORD PTR driveNumber$[rsp]
  0001b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:VirtualVolumeDeviceObjects
  00022	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
$LN3@GetVirtual:

; 196  : }

  00026	f3 c3		 fatret	 0
GetVirtualVolumeDeviceObject ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	DumpMemory
;	COMDAT pdata
pdata	SEGMENT
$pdata$DumpMemory DD imagerel $LN11
	DD	imagerel $LN11+386
	DD	imagerel $unwind$DumpMemory
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DumpMemory DD 042419H
	DD	0150112H
	DD	0300a700bH
	DD	imagerel __GSHandlerCheck
	DD	090H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DumpMemory
_TEXT	SEGMENT
i$ = 96
j$ = 100
m$ = 104
str$ = 120
__$ArrayPad$ = 144
mem$ = 192
size$ = 200
DumpMemory PROC						; COMDAT

; 143  : {

$LN11:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	53		 push	 rbx
  0000a	57		 push	 rdi
  0000b	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 144  : 	unsigned char str[20];
; 145  : 	unsigned char *m = mem;

  00024	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR mem$[rsp]
  0002c	48 89 44 24 68	 mov	 QWORD PTR m$[rsp], rax

; 146  : 	int i,j;
; 147  : 
; 148  : 	for (j = 0; j < size / 8; j++)

  00031	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00039	eb 0b		 jmp	 SHORT $LN8@DumpMemory
$LN7@DumpMemory:
  0003b	8b 44 24 64	 mov	 eax, DWORD PTR j$[rsp]
  0003f	83 c0 01	 add	 eax, 1
  00042	89 44 24 64	 mov	 DWORD PTR j$[rsp], eax
$LN8@DumpMemory:
  00046	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  0004d	99		 cdq
  0004e	83 e2 07	 and	 edx, 7
  00051	03 c2		 add	 eax, edx
  00053	c1 f8 03	 sar	 eax, 3
  00056	39 44 24 64	 cmp	 DWORD PTR j$[rsp], eax
  0005a	0f 8d 08 01 00
	00		 jge	 $LN6@DumpMemory

; 149  : 	{
; 150  : 		memset (str,0,sizeof str);

  00060	48 8d 7c 24 78	 lea	 rdi, QWORD PTR str$[rsp]
  00065	33 c0		 xor	 eax, eax
  00067	b9 14 00 00 00	 mov	 ecx, 20
  0006c	f3 aa		 rep stosb

; 151  : 		for (i = 0; i < 8; i++) 

  0006e	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00076	eb 0b		 jmp	 SHORT $LN5@DumpMemory
$LN4@DumpMemory:
  00078	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  0007c	83 c0 01	 add	 eax, 1
  0007f	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN5@DumpMemory:
  00083	83 7c 24 60 08	 cmp	 DWORD PTR i$[rsp], 8
  00088	7d 4b		 jge	 SHORT $LN3@DumpMemory

; 152  : 		{
; 153  : 			if (m[i] > ' ' && m[i] <= '~')

  0008a	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$[rsp]
  0008f	48 8b 44 24 68	 mov	 rax, QWORD PTR m$[rsp]
  00094	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00098	83 f8 20	 cmp	 eax, 32			; 00000020H
  0009b	7e 2c		 jle	 SHORT $LN2@DumpMemory
  0009d	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$[rsp]
  000a2	48 8b 44 24 68	 mov	 rax, QWORD PTR m$[rsp]
  000a7	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000ab	83 f8 7e	 cmp	 eax, 126		; 0000007eH
  000ae	7f 19		 jg	 SHORT $LN2@DumpMemory

; 154  : 				str[i]=m[i];

  000b0	48 63 54 24 60	 movsxd	 rdx, DWORD PTR i$[rsp]
  000b5	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$[rsp]
  000ba	48 8b 44 24 68	 mov	 rax, QWORD PTR m$[rsp]
  000bf	0f b6 04 10	 movzx	 eax, BYTE PTR [rax+rdx]
  000c3	88 44 0c 78	 mov	 BYTE PTR str$[rsp+rcx], al

; 155  : 			else

  000c7	eb 0a		 jmp	 SHORT $LN1@DumpMemory
$LN2@DumpMemory:

; 156  : 				str[i]='.';

  000c9	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  000ce	c6 44 04 78 2e	 mov	 BYTE PTR str$[rsp+rax], 46 ; 0000002eH
$LN1@DumpMemory:

; 157  : 		}

  000d3	eb a3		 jmp	 SHORT $LN4@DumpMemory
$LN3@DumpMemory:

; 158  : 
; 159  : 		Dump ("0x%08p  %02x %02x %02x %02x %02x %02x %02x %02x  %s\n",
; 160  : 			m, m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], str);

  000d5	48 8b 44 24 68	 mov	 rax, QWORD PTR m$[rsp]
  000da	0f b6 58 07	 movzx	 ebx, BYTE PTR [rax+7]
  000de	48 8b 44 24 68	 mov	 rax, QWORD PTR m$[rsp]
  000e3	44 0f b6 58 06	 movzx	 r11d, BYTE PTR [rax+6]
  000e8	48 8b 44 24 68	 mov	 rax, QWORD PTR m$[rsp]
  000ed	44 0f b6 50 05	 movzx	 r10d, BYTE PTR [rax+5]
  000f2	48 8b 44 24 68	 mov	 rax, QWORD PTR m$[rsp]
  000f7	0f b6 78 04	 movzx	 edi, BYTE PTR [rax+4]
  000fb	48 8b 44 24 68	 mov	 rax, QWORD PTR m$[rsp]
  00100	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00104	48 8b 44 24 68	 mov	 rax, QWORD PTR m$[rsp]
  00109	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  0010d	48 8b 44 24 68	 mov	 rax, QWORD PTR m$[rsp]
  00112	44 0f b6 48 01	 movzx	 r9d, BYTE PTR [rax+1]
  00117	48 8b 44 24 68	 mov	 rax, QWORD PTR m$[rsp]
  0011c	44 0f b6 00	 movzx	 r8d, BYTE PTR [rax]
  00120	48 8d 44 24 78	 lea	 rax, QWORD PTR str$[rsp]
  00125	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  0012a	89 5c 24 48	 mov	 DWORD PTR [rsp+72], ebx
  0012e	44 89 5c 24 40	 mov	 DWORD PTR [rsp+64], r11d
  00133	44 89 54 24 38	 mov	 DWORD PTR [rsp+56], r10d
  00138	89 7c 24 30	 mov	 DWORD PTR [rsp+48], edi
  0013c	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  00140	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00144	48 8b 54 24 68	 mov	 rdx, QWORD PTR m$[rsp]
  00149	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DF@IHIBAGEA@0x?$CF08p?5?5?$CF02x?5?$CF02x?5?$CF02x?5?$CF02x?5?$CF02x@FNODOBFM@
  00150	e8 00 00 00 00	 call	 DbgPrint

; 161  : 
; 162  : 		m+=8;

  00155	48 8b 44 24 68	 mov	 rax, QWORD PTR m$[rsp]
  0015a	48 83 c0 08	 add	 rax, 8
  0015e	48 89 44 24 68	 mov	 QWORD PTR m$[rsp], rax

; 163  : 	}

  00163	e9 d3 fe ff ff	 jmp	 $LN7@DumpMemory
$LN6@DumpMemory:

; 164  : }

  00168	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00170	48 33 cc	 xor	 rcx, rsp
  00173	e8 00 00 00 00	 call	 __security_check_cookie
  00178	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0017f	5f		 pop	 rdi
  00180	5b		 pop	 rbx
  00181	c3		 ret	 0
DumpMemory ENDP
PUBLIC	ReadRegistryConfigFlags
;	COMDAT pdata
pdata	SEGMENT
$pdata$ReadRegistryConfigFlags DD imagerel $LN13
	DD	imagerel $LN13+307
	DD	imagerel $unwind$ReadRegistryConfigFlags
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ReadRegistryConfigFlags DD 010801H
	DD	0a208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ReadRegistryConfigFlags
_TEXT	SEGMENT
flags$ = 32
name$ = 40
status$ = 56
data$ = 64
tv83 = 72
driverEntry$ = 96
ReadRegistryConfigFlags PROC				; COMDAT

; 3148 : {

$LN13:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3149 : 	PKEY_VALUE_PARTIAL_INFORMATION data;
; 3150 : 	UNICODE_STRING name;
; 3151 : 	NTSTATUS status;
; 3152 : 	uint32 flags = 0;

  00008	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR flags$[rsp], 0

; 3153 : 
; 3154 : 	RtlInitUnicodeString (&name, L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\truecrypt");

  00010	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1HM@GLBNDPGI@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
  00017	48 8d 4c 24 28	 lea	 rcx, QWORD PTR name$[rsp]
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 3155 : 	status = TCReadRegistryKey (&name, TC_DRIVER_CONFIG_REG_VALUE_NAME, &data);

  00022	4c 8d 44 24 40	 lea	 r8, QWORD PTR data$[rsp]
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@LGEHFLCO@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AA?$AA@FNODOBFM@
  0002e	48 8d 4c 24 28	 lea	 rcx, QWORD PTR name$[rsp]
  00033	e8 00 00 00 00	 call	 TCReadRegistryKey
  00038	89 44 24 38	 mov	 DWORD PTR status$[rsp], eax

; 3156 : 
; 3157 : 	if (NT_SUCCESS (status))

  0003c	83 7c 24 38 00	 cmp	 DWORD PTR status$[rsp], 0
  00041	0f 8c 98 00 00
	00		 jl	 $LN8@ReadRegist

; 3158 : 	{
; 3159 : 		if (data->Type == REG_DWORD)

  00047	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  0004c	83 78 04 04	 cmp	 DWORD PTR [rax+4], 4
  00050	75 75		 jne	 SHORT $LN7@ReadRegist

; 3160 : 		{
; 3161 : 			flags = *(uint32 *) data->Data;

  00052	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  00057	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0005a	89 44 24 20	 mov	 DWORD PTR flags$[rsp], eax

; 3162 : 			Dump ("Configuration flags = 0x%x\n", flags);

  0005e	8b 54 24 20	 mov	 edx, DWORD PTR flags$[rsp]
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@LHOAOPML@Configuration?5flags?5?$DN?50x?$CFx?6?$AA@FNODOBFM@
  00069	e8 00 00 00 00	 call	 DbgPrint

; 3163 : 
; 3164 : 			if (driverEntry)

  0006e	83 7c 24 60 00	 cmp	 DWORD PTR driverEntry$[rsp], 0
  00073	74 2a		 je	 SHORT $LN6@ReadRegist

; 3165 : 			{
; 3166 : 				if (flags & (TC_DRIVER_CONFIG_CACHE_BOOT_PASSWORD | TC_DRIVER_CONFIG_CACHE_BOOT_PASSWORD_FOR_SYS_FAVORITES))

  00075	8b 44 24 20	 mov	 eax, DWORD PTR flags$[rsp]
  00079	83 e0 03	 and	 eax, 3
  0007c	85 c0		 test	 eax, eax
  0007e	74 0a		 je	 SHORT $LN5@ReadRegist

; 3167 : 					CacheBootPassword = TRUE;

  00080	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR CacheBootPassword, 1
$LN5@ReadRegist:

; 3168 : 
; 3169 : 				if (flags & TC_DRIVER_CONFIG_DISABLE_NONADMIN_SYS_FAVORITES_ACCESS)

  0008a	8b 44 24 20	 mov	 eax, DWORD PTR flags$[rsp]
  0008e	83 e0 04	 and	 eax, 4
  00091	85 c0		 test	 eax, eax
  00093	74 0a		 je	 SHORT $LN4@ReadRegist

; 3170 : 					NonAdminSystemFavoritesAccessDisabled = TRUE;

  00095	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NonAdminSystemFavoritesAccessDisabled, 1
$LN4@ReadRegist:
$LN6@ReadRegist:

; 3171 : 			}
; 3172 : 
; 3173 : 			EnableHwEncryption ((flags & TC_DRIVER_CONFIG_DISABLE_HARDWARE_ENCRYPTION) ? FALSE : TRUE);

  0009f	8b 44 24 20	 mov	 eax, DWORD PTR flags$[rsp]
  000a3	83 e0 08	 and	 eax, 8
  000a6	85 c0		 test	 eax, eax
  000a8	74 0a		 je	 SHORT $LN11@ReadRegist
  000aa	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
  000b2	eb 08		 jmp	 SHORT $LN12@ReadRegist
$LN11@ReadRegist:
  000b4	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv83[rsp], 1
$LN12@ReadRegist:
  000bc	8b 4c 24 48	 mov	 ecx, DWORD PTR tv83[rsp]
  000c0	e8 00 00 00 00	 call	 EnableHwEncryption

; 3174 : 		}
; 3175 : 		else

  000c5	eb 08		 jmp	 SHORT $LN3@ReadRegist
$LN7@ReadRegist:

; 3176 : 			status = STATUS_INVALID_PARAMETER;

  000c7	c7 44 24 38 0d
	00 00 c0	 mov	 DWORD PTR status$[rsp], -1073741811 ; ffffffffc000000dH
$LN3@ReadRegist:

; 3177 : 
; 3178 : 		TCfree (data);

  000cf	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  000d4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN8@ReadRegist:

; 3179 : 	}
; 3180 : 
; 3181 : 	if (driverEntry && NT_SUCCESS (TCReadRegistryKey (&name, TC_ENCRYPTION_FREE_CPU_COUNT_REG_VALUE_NAME, &data)))

  000df	83 7c 24 60 00	 cmp	 DWORD PTR driverEntry$[rsp], 0
  000e4	74 44		 je	 SHORT $LN2@ReadRegist
  000e6	4c 8d 44 24 40	 lea	 r8, QWORD PTR data$[rsp]
  000eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EA@CEOJFLPD@?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AAE?$AAn?$AAc?$AAr?$AAy?$AAp?$AAt?$AAi?$AAo?$AAn?$AAF?$AAr?$AAe?$AAe?$AAC?$AAp?$AAu?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@FNODOBFM@
  000f2	48 8d 4c 24 28	 lea	 rcx, QWORD PTR name$[rsp]
  000f7	e8 00 00 00 00	 call	 TCReadRegistryKey
  000fc	85 c0		 test	 eax, eax
  000fe	7c 2a		 jl	 SHORT $LN2@ReadRegist

; 3182 : 	{
; 3183 : 		if (data->Type == REG_DWORD)

  00100	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  00105	83 78 04 04	 cmp	 DWORD PTR [rax+4], 4
  00109	75 0f		 jne	 SHORT $LN1@ReadRegist

; 3184 : 			EncryptionThreadPoolFreeCpuCountLimit = *(uint32 *) data->Data;

  0010b	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  00110	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00113	48 89 05 00 00
	00 00		 mov	 QWORD PTR EncryptionThreadPoolFreeCpuCountLimit, rax
$LN1@ReadRegist:

; 3185 : 
; 3186 : 		TCfree (data);

  0011a	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  0011f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  00124	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN2@ReadRegist:

; 3187 : 	}
; 3188 : 
; 3189 : 	return status;

  0012a	8b 44 24 38	 mov	 eax, DWORD PTR status$[rsp]

; 3190 : }

  0012e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00132	c3		 ret	 0
ReadRegistryConfigFlags ENDP
_TEXT	ENDS
PUBLIC	IsVolumeClassFilterRegistered
;	COMDAT pdata
pdata	SEGMENT
$pdata$IsVolumeClassFilterRegistered DD imagerel $LN9
	DD	imagerel $LN9+219
	DD	imagerel $unwind$IsVolumeClassFilterRegistered
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IsVolumeClassFilterRegistered DD 010401H
	DD	0a204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT IsVolumeClassFilterRegistered
_TEXT	SEGMENT
registered$ = 32
name$ = 40
data$ = 56
status$ = 64
i$33303 = 68
IsVolumeClassFilterRegistered PROC			; COMDAT

; 3106 : {

$LN9:
  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3107 : 	UNICODE_STRING name;
; 3108 : 	NTSTATUS status;
; 3109 : 	BOOL registered = FALSE;

  00004	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR registered$[rsp], 0

; 3110 : 
; 3111 : 	PKEY_VALUE_PARTIAL_INFORMATION data;
; 3112 : 
; 3113 : 	/*
; 3114 : 	 * Note: Do not change the "Storage Volumes" guid (System-Defined Device Setup Classes).
; 3115 : 	 * This class includes storage volumes as defined by the system-supplied
; 3116 : 	 * logical volume manager and class drivers that create device objects to
; 3117 : 	 * represent storage volumes, such as the system disk class driver.
; 3118 : 	 * @see	http://msdn.microsoft.com/en-us/library/windows/hardware/ff553426%28v=vs.85%29.aspx
; 3119 : 	 */
; 3120 : 	RtlInitUnicodeString (&name, L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class\\{71A27CDD-812A-11D0-BEC7-08002BE2092F}");

  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1MA@BNNNAGDA@?$AA?2?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?2?$AAM?$AAA?$AAC?$AAH?$AAI?$AAN?$AAE?$AA?2?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt@FNODOBFM@
  00013	48 8d 4c 24 28	 lea	 rcx, QWORD PTR name$[rsp]
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 3121 : 	status = TCReadRegistryKey (&name, L"UpperFilters", &data);

  0001e	4c 8d 44 24 38	 lea	 r8, QWORD PTR data$[rsp]
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1BK@FNJCPENK@?$AAU?$AAp?$AAp?$AAe?$AAr?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAs?$AA?$AA@FNODOBFM@
  0002a	48 8d 4c 24 28	 lea	 rcx, QWORD PTR name$[rsp]
  0002f	e8 00 00 00 00	 call	 TCReadRegistryKey
  00034	89 44 24 40	 mov	 DWORD PTR status$[rsp], eax

; 3122 : 
; 3123 : 	if (NT_SUCCESS (status))

  00038	83 7c 24 40 00	 cmp	 DWORD PTR status$[rsp], 0
  0003d	0f 8c 8f 00 00
	00		 jl	 $LN6@IsVolumeCl

; 3124 : 	{
; 3125 : 		if (data->Type == REG_MULTI_SZ && data->DataLength >= 9 * sizeof (wchar_t))

  00043	48 8b 44 24 38	 mov	 rax, QWORD PTR data$[rsp]
  00048	83 78 04 07	 cmp	 DWORD PTR [rax+4], 7
  0004c	75 74		 jne	 SHORT $LN5@IsVolumeCl
  0004e	48 8b 44 24 38	 mov	 rax, QWORD PTR data$[rsp]
  00053	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00056	48 83 f8 12	 cmp	 rax, 18
  0005a	72 66		 jb	 SHORT $LN5@IsVolumeCl

; 3126 : 		{
; 3127 : 			// Search for the string "truecrypt"
; 3128 : 			ULONG i;
; 3129 : 			for (i = 0; i <= data->DataLength - 9 * sizeof (wchar_t); ++i)

  0005c	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR i$33303[rsp], 0
  00064	eb 0b		 jmp	 SHORT $LN4@IsVolumeCl
$LN3@IsVolumeCl:
  00066	8b 44 24 44	 mov	 eax, DWORD PTR i$33303[rsp]
  0006a	83 c0 01	 add	 eax, 1
  0006d	89 44 24 44	 mov	 DWORD PTR i$33303[rsp], eax
$LN4@IsVolumeCl:
  00071	8b 4c 24 44	 mov	 ecx, DWORD PTR i$33303[rsp]
  00075	48 8b 44 24 38	 mov	 rax, QWORD PTR data$[rsp]
  0007a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0007d	48 83 e8 12	 sub	 rax, 18
  00081	48 3b c8	 cmp	 rcx, rax
  00084	77 3c		 ja	 SHORT $LN2@IsVolumeCl

; 3130 : 			{
; 3131 : 				if (memcmp (data->Data + i, L"truecrypt", 9 * sizeof (wchar_t)) == 0)

  00086	8b 4c 24 44	 mov	 ecx, DWORD PTR i$33303[rsp]
  0008a	48 8b 44 24 38	 mov	 rax, QWORD PTR data$[rsp]
  0008f	48 8d 4c 08 0c	 lea	 rcx, QWORD PTR [rax+rcx+12]
  00094	41 b8 12 00 00
	00		 mov	 r8d, 18
  0009a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1BE@OBOIPPHP@?$AAt?$AAr?$AAu?$AAe?$AAc?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
  000a1	e8 00 00 00 00	 call	 memcmp
  000a6	85 c0		 test	 eax, eax
  000a8	75 16		 jne	 SHORT $LN1@IsVolumeCl

; 3132 : 				{
; 3133 : 					Dump ("Volume class filter active\n");

  000aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@GOBMMLHF@Volume?5class?5filter?5active?6?$AA@FNODOBFM@
  000b1	e8 00 00 00 00	 call	 DbgPrint

; 3134 : 					registered = TRUE;

  000b6	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR registered$[rsp], 1

; 3135 : 					break;

  000be	eb 02		 jmp	 SHORT $LN2@IsVolumeCl
$LN1@IsVolumeCl:

; 3136 : 				}
; 3137 : 			}

  000c0	eb a4		 jmp	 SHORT $LN3@IsVolumeCl
$LN2@IsVolumeCl:
$LN5@IsVolumeCl:

; 3138 : 		}
; 3139 : 
; 3140 : 		TCfree (data);

  000c2	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  000c7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR data$[rsp]
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN6@IsVolumeCl:

; 3141 : 	}
; 3142 : 
; 3143 : 	return registered;

  000d2	8b 44 24 20	 mov	 eax, DWORD PTR registered$[rsp]

; 3144 : }

  000d6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000da	c3		 ret	 0
IsVolumeClassFilterRegistered ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	IsDriveLetterAvailable
;	COMDAT pdata
pdata	SEGMENT
$pdata$IsDriveLetterAvailable DD imagerel $LN7
	DD	imagerel $LN7+221
	DD	imagerel $unwind$IsDriveLetterAvailable
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IsDriveLetterAvailable DD 021d19H
	DD	031010bH
	DD	imagerel __GSHandlerCheck
	DD	0178H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT IsDriveLetterAvailable
_TEXT	SEGMENT
objectAttributes$ = 32
ntStatus$ = 80
link$ = 96
objectName$ = 352
handle$ = 368
__$ArrayPad$ = 376
nDosDriveNo$ = 400
IsDriveLetterAvailable PROC				; COMDAT

; 2942 : {

$LN7:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 81 ec 88 01
	00 00		 sub	 rsp, 392		; 00000188H
  0000b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00012	48 33 c4	 xor	 rax, rsp
  00015	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2943 : 	OBJECT_ATTRIBUTES objectAttributes;
; 2944 : 	UNICODE_STRING objectName;
; 2945 : 	WCHAR link[128];
; 2946 : 	HANDLE handle;
; 2947 : 	NTSTATUS ntStatus;
; 2948 : 
; 2949 : 	TCGetDosNameFromNumber (link, nDosDriveNo);

  0001d	8b 94 24 90 01
	00 00		 mov	 edx, DWORD PTR nDosDriveNo$[rsp]
  00024	48 8d 4c 24 60	 lea	 rcx, QWORD PTR link$[rsp]
  00029	e8 00 00 00 00	 call	 TCGetDosNameFromNumber

; 2950 : 	RtlInitUnicodeString (&objectName, link);

  0002e	48 8d 54 24 60	 lea	 rdx, QWORD PTR link$[rsp]
  00033	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR objectName$[rsp]
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2951 : 	InitializeObjectAttributes (&objectAttributes, &objectName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

  00041	c7 44 24 20 30
	00 00 00	 mov	 DWORD PTR objectAttributes$[rsp], 48 ; 00000030H
  00049	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR objectAttributes$[rsp+8], 0
  00052	c7 44 24 38 40
	02 00 00	 mov	 DWORD PTR objectAttributes$[rsp+24], 576 ; 00000240H
  0005a	48 8d 84 24 60
	01 00 00	 lea	 rax, QWORD PTR objectName$[rsp]
  00062	48 89 44 24 30	 mov	 QWORD PTR objectAttributes$[rsp+16], rax
  00067	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR objectAttributes$[rsp+32], 0
  00070	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR objectAttributes$[rsp+40], 0

; 2952 : 
; 2953 : 	ntStatus=ZwOpenSymbolicLinkObject (&handle, GENERIC_READ, &objectAttributes);

  00079	4c 8d 44 24 20	 lea	 r8, QWORD PTR objectAttributes$[rsp]
  0007e	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  00083	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR handle$[rsp]
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwOpenSymbolicLinkObject
  00091	89 44 24 50	 mov	 DWORD PTR ntStatus$[rsp], eax

; 2954 : 	if (NT_SUCCESS (ntStatus))

  00095	83 7c 24 50 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  0009a	7c 14		 jl	 SHORT $LN4@IsDriveLet

; 2955 : 	{
; 2956 : 		ZwClose (handle);

  0009c	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR handle$[rsp]
  000a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 2957 : 		return FALSE;

  000aa	33 c0		 xor	 eax, eax
  000ac	eb 17		 jmp	 SHORT $LN5@IsDriveLet
  000ae	eb 15		 jmp	 SHORT $LN3@IsDriveLet
$LN4@IsDriveLet:

; 2958 : 	}
; 2959 : 	else if (ntStatus == STATUS_OBJECT_NAME_NOT_FOUND)

  000b0	81 7c 24 50 34
	00 00 c0	 cmp	 DWORD PTR ntStatus$[rsp], -1073741772 ; ffffffffc0000034H
  000b8	75 09		 jne	 SHORT $LN2@IsDriveLet

; 2960 : 	{
; 2961 : 		return TRUE;

  000ba	b8 01 00 00 00	 mov	 eax, 1
  000bf	eb 04		 jmp	 SHORT $LN5@IsDriveLet

; 2962 : 	}
; 2963 : 	else

  000c1	eb 02		 jmp	 SHORT $LN1@IsDriveLet
$LN2@IsDriveLet:

; 2964 : 	{
; 2965 : 		return FALSE;

  000c3	33 c0		 xor	 eax, eax
$LN1@IsDriveLet:
$LN3@IsDriveLet:
$LN5@IsDriveLet:

; 2966 : 	}
; 2967 : }

  000c5	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000cd	48 33 cc	 xor	 rcx, rsp
  000d0	e8 00 00 00 00	 call	 __security_check_cookie
  000d5	48 81 c4 88 01
	00 00		 add	 rsp, 392		; 00000188H
  000dc	c3		 ret	 0
IsDriveLetterAvailable ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$FindVolumeWithHighestUniqueId DD imagerel FindVolumeWithHighestUniqueId
	DD	imagerel FindVolumeWithHighestUniqueId+151
	DD	imagerel $unwind$FindVolumeWithHighestUniqueId
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$FindVolumeWithHighestUniqueId DD 010801H
	DD	08208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT FindVolumeWithHighestUniqueId
_TEXT	SEGMENT
highestId$ = 32
drive$ = 36
highestIdDevice$ = 40
device$33081 = 48
extension$33083 = 56
maxUniqueId$ = 80
FindVolumeWithHighestUniqueId PROC			; COMDAT

; 2785 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2786 : 	PDEVICE_OBJECT highestIdDevice = NULL;

  00008	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR highestIdDevice$[rsp], 0

; 2787 : 	int highestId = -1;

  00011	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR highestId$[rsp], -1

; 2788 : 	int drive;
; 2789 : 
; 2790 : 	for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)

  00019	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR drive$[rsp], 0
  00021	eb 0b		 jmp	 SHORT $LN5@FindVolume
$LN4@FindVolume:
  00023	8b 44 24 24	 mov	 eax, DWORD PTR drive$[rsp]
  00027	83 c0 01	 add	 eax, 1
  0002a	89 44 24 24	 mov	 DWORD PTR drive$[rsp], eax
$LN5@FindVolume:
  0002e	83 7c 24 24 19	 cmp	 DWORD PTR drive$[rsp], 25
  00033	7f 58		 jg	 SHORT $LN3@FindVolume

; 2791 : 	{
; 2792 : 		PDEVICE_OBJECT device = GetVirtualVolumeDeviceObject (drive);

  00035	8b 4c 24 24	 mov	 ecx, DWORD PTR drive$[rsp]
  00039	e8 00 00 00 00	 call	 GetVirtualVolumeDeviceObject
  0003e	48 89 44 24 30	 mov	 QWORD PTR device$33081[rsp], rax

; 2793 : 		if (device)

  00043	48 83 7c 24 30
	00		 cmp	 QWORD PTR device$33081[rsp], 0
  00049	74 40		 je	 SHORT $LN2@FindVolume

; 2794 : 		{
; 2795 : 			PEXTENSION extension = (PEXTENSION) device->DeviceExtension;

  0004b	48 8b 44 24 30	 mov	 rax, QWORD PTR device$33081[rsp]
  00050	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00054	48 89 44 24 38	 mov	 QWORD PTR extension$33083[rsp], rax

; 2796 : 			if (extension->UniqueVolumeId > highestId && extension->UniqueVolumeId <= maxUniqueId)

  00059	48 8b 4c 24 38	 mov	 rcx, QWORD PTR extension$33083[rsp]
  0005e	8b 44 24 20	 mov	 eax, DWORD PTR highestId$[rsp]
  00062	39 41 10	 cmp	 DWORD PTR [rcx+16], eax
  00065	7e 24		 jle	 SHORT $LN1@FindVolume
  00067	48 8b 4c 24 38	 mov	 rcx, QWORD PTR extension$33083[rsp]
  0006c	8b 44 24 50	 mov	 eax, DWORD PTR maxUniqueId$[rsp]
  00070	39 41 10	 cmp	 DWORD PTR [rcx+16], eax
  00073	7f 16		 jg	 SHORT $LN1@FindVolume

; 2797 : 			{
; 2798 : 				highestId = extension->UniqueVolumeId;

  00075	48 8b 44 24 38	 mov	 rax, QWORD PTR extension$33083[rsp]
  0007a	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0007d	89 44 24 20	 mov	 DWORD PTR highestId$[rsp], eax

; 2799 : 				highestIdDevice = device;

  00081	48 8b 44 24 30	 mov	 rax, QWORD PTR device$33081[rsp]
  00086	48 89 44 24 28	 mov	 QWORD PTR highestIdDevice$[rsp], rax
$LN1@FindVolume:
$LN2@FindVolume:

; 2800 : 			}
; 2801 : 		}
; 2802 : 	}

  0008b	eb 96		 jmp	 SHORT $LN4@FindVolume
$LN3@FindVolume:

; 2803 : 
; 2804 : 	return highestIdDevice;

  0008d	48 8b 44 24 28	 mov	 rax, QWORD PTR highestIdDevice$[rsp]

; 2805 : }

  00092	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00096	c3		 ret	 0
FindVolumeWithHighestUniqueId ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	RemoveDriveLink
;	COMDAT pdata
pdata	SEGMENT
$pdata$RemoveDriveLink DD imagerel $LN3
	DD	imagerel $LN3+121
	DD	imagerel $unwind$RemoveDriveLink
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RemoveDriveLink DD 021d19H
	DD	04b010bH
	DD	imagerel __GSHandlerCheck
	DD	0240H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT RemoveDriveLink
_TEXT	SEGMENT
symLink$ = 32
ntStatus$ = 48
link$ = 64
__$ArrayPad$ = 576
nDosDriveNo$ = 608
RemoveDriveLink PROC					; COMDAT

; 2469 : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 81 ec 58 02
	00 00		 sub	 rsp, 600		; 00000258H
  0000b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00012	48 33 c4	 xor	 rax, rsp
  00015	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2470 : 	WCHAR link[256];
; 2471 : 	UNICODE_STRING symLink;
; 2472 : 	NTSTATUS ntStatus;
; 2473 : 
; 2474 : 	TCGetDosNameFromNumber (link, nDosDriveNo);

  0001d	8b 94 24 60 02
	00 00		 mov	 edx, DWORD PTR nDosDriveNo$[rsp]
  00024	48 8d 4c 24 40	 lea	 rcx, QWORD PTR link$[rsp]
  00029	e8 00 00 00 00	 call	 TCGetDosNameFromNumber

; 2475 : 	RtlInitUnicodeString (&symLink, link);

  0002e	48 8d 54 24 40	 lea	 rdx, QWORD PTR link$[rsp]
  00033	48 8d 4c 24 20	 lea	 rcx, QWORD PTR symLink$[rsp]
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2476 : 
; 2477 : 	ntStatus = IoDeleteSymbolicLink (&symLink);

  0003e	48 8d 4c 24 20	 lea	 rcx, QWORD PTR symLink$[rsp]
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteSymbolicLink
  00049	89 44 24 30	 mov	 DWORD PTR ntStatus$[rsp], eax

; 2478 : 	Dump ("IoDeleteSymbolicLink returned %X\n", ntStatus);

  0004d	8b 54 24 30	 mov	 edx, DWORD PTR ntStatus$[rsp]
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@KAFJKDAC@IoDeleteSymbolicLink?5returned?5?$CFX@FNODOBFM@
  00058	e8 00 00 00 00	 call	 DbgPrint

; 2479 : 	return ntStatus;

  0005d	8b 44 24 30	 mov	 eax, DWORD PTR ntStatus$[rsp]

; 2480 : }

  00061	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00069	48 33 cc	 xor	 rcx, rsp
  0006c	e8 00 00 00 00	 call	 __security_check_cookie
  00071	48 81 c4 58 02
	00 00		 add	 rsp, 600		; 00000258H
  00078	c3		 ret	 0
RemoveDriveLink ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	CreateDriveLink
;	COMDAT pdata
pdata	SEGMENT
$pdata$CreateDriveLink DD imagerel $LN3
	DD	imagerel $LN3+165
	DD	imagerel $unwind$CreateDriveLink
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CreateDriveLink DD 021d19H
	DD	04d010bH
	DD	imagerel __GSHandlerCheck
	DD	0250H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT CreateDriveLink
_TEXT	SEGMENT
symLink$ = 32
deviceName$ = 48
ntStatus$ = 64
link$ = 80
dev$ = 336
__$ArrayPad$ = 592
nDosDriveNo$ = 624
CreateDriveLink PROC					; COMDAT

; 2451 : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 81 ec 68 02
	00 00		 sub	 rsp, 616		; 00000268H
  0000b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00012	48 33 c4	 xor	 rax, rsp
  00015	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2452 : 	WCHAR dev[128], link[128];
; 2453 : 	UNICODE_STRING deviceName, symLink;
; 2454 : 	NTSTATUS ntStatus;
; 2455 : 
; 2456 : 	TCGetNTNameFromNumber (dev, nDosDriveNo);

  0001d	8b 94 24 70 02
	00 00		 mov	 edx, DWORD PTR nDosDriveNo$[rsp]
  00024	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR dev$[rsp]
  0002c	e8 00 00 00 00	 call	 TCGetNTNameFromNumber

; 2457 : 	TCGetDosNameFromNumber (link, nDosDriveNo);

  00031	8b 94 24 70 02
	00 00		 mov	 edx, DWORD PTR nDosDriveNo$[rsp]
  00038	48 8d 4c 24 50	 lea	 rcx, QWORD PTR link$[rsp]
  0003d	e8 00 00 00 00	 call	 TCGetDosNameFromNumber

; 2458 : 
; 2459 : 	RtlInitUnicodeString (&deviceName, dev);

  00042	48 8d 94 24 50
	01 00 00	 lea	 rdx, QWORD PTR dev$[rsp]
  0004a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR deviceName$[rsp]
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2460 : 	RtlInitUnicodeString (&symLink, link);

  00055	48 8d 54 24 50	 lea	 rdx, QWORD PTR link$[rsp]
  0005a	48 8d 4c 24 20	 lea	 rcx, QWORD PTR symLink$[rsp]
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2461 : 
; 2462 : 	ntStatus = IoCreateSymbolicLink (&symLink, &deviceName);

  00065	48 8d 54 24 30	 lea	 rdx, QWORD PTR deviceName$[rsp]
  0006a	48 8d 4c 24 20	 lea	 rcx, QWORD PTR symLink$[rsp]
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateSymbolicLink
  00075	89 44 24 40	 mov	 DWORD PTR ntStatus$[rsp], eax

; 2463 : 	Dump ("IoCreateSymbolicLink returned %X\n", ntStatus);

  00079	8b 54 24 40	 mov	 edx, DWORD PTR ntStatus$[rsp]
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@INHNDJGI@IoCreateSymbolicLink?5returned?5?$CFX@FNODOBFM@
  00084	e8 00 00 00 00	 call	 DbgPrint

; 2464 : 	return ntStatus;

  00089	8b 44 24 40	 mov	 eax, DWORD PTR ntStatus$[rsp]

; 2465 : }

  0008d	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00095	48 33 cc	 xor	 rcx, rsp
  00098	e8 00 00 00 00	 call	 __security_check_cookie
  0009d	48 81 c4 68 02
	00 00		 add	 rsp, 616		; 00000268H
  000a4	c3		 ret	 0
CreateDriveLink ENDP
_TEXT	ENDS
PUBLIC	TCFsctlCall
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCFsctlCall DD imagerel $LN5
	DD	imagerel $LN5+302
	DD	imagerel $unwind$TCFsctlCall
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCFsctlCall DD 021a01H
	DD	015011aH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT TCFsctlCall
_TEXT	SEGMENT
deviceObject$ = 80
irp$ = 88
stack$ = 96
ntStatus$ = 104
ioStatusBlock$ = 112
event$ = 128
fileObject$ = 176
IoControlCode$ = 184
InputBuffer$ = 192
InputBufferSize$ = 200
OutputBuffer$ = 208
OutputBufferSize$ = 216
TCFsctlCall PROC					; COMDAT

; 2412 : {

$LN5:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 2413 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2414 : 	NTSTATUS ntStatus;
; 2415 : 	PIRP irp;
; 2416 : 	KEVENT event;
; 2417 : 	PIO_STACK_LOCATION stack;
; 2418 : 	PDEVICE_OBJECT deviceObject = IoGetRelatedDeviceObject (fileObject);

  0001a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR fileObject$[rsp]
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetRelatedDeviceObject
  00028	48 89 44 24 50	 mov	 QWORD PTR deviceObject$[rsp], rax

; 2419 : 
; 2420 : 	KeInitializeEvent(&event, NotificationEvent, FALSE);

  0002d	45 33 c0	 xor	 r8d, r8d
  00030	33 d2		 xor	 edx, edx
  00032	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR event$[rsp]
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 2421 : 
; 2422 : 	irp = IoBuildDeviceIoControlRequest (IoControlCode,
; 2423 : 					     deviceObject,
; 2424 : 					     InputBuffer, InputBufferSize,
; 2425 : 					     OutputBuffer, OutputBufferSize,
; 2426 : 					     FALSE,
; 2427 : 					     &event,
; 2428 : 					     &ioStatusBlock);

  00040	4c 8d 5c 24 70	 lea	 r11, QWORD PTR ioStatusBlock$[rsp]
  00045	4c 89 5c 24 40	 mov	 QWORD PTR [rsp+64], r11
  0004a	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR event$[rsp]
  00052	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00057	c6 44 24 30 00	 mov	 BYTE PTR [rsp+48], 0
  0005c	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR OutputBufferSize$[rsp]
  00063	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00067	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR OutputBuffer$[rsp]
  0006f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00074	44 8b 8c 24 c8
	00 00 00	 mov	 r9d, DWORD PTR InputBufferSize$[rsp]
  0007c	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR InputBuffer$[rsp]
  00084	48 8b 54 24 50	 mov	 rdx, QWORD PTR deviceObject$[rsp]
  00089	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR IoControlCode$[rsp]
  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoBuildDeviceIoControlRequest
  00096	48 89 44 24 58	 mov	 QWORD PTR irp$[rsp], rax

; 2429 : 
; 2430 : 	if (irp == NULL)

  0009b	48 83 7c 24 58
	00		 cmp	 QWORD PTR irp$[rsp], 0
  000a1	75 07		 jne	 SHORT $LN2@TCFsctlCal

; 2431 : 		return STATUS_INSUFFICIENT_RESOURCES;

  000a3	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  000a8	eb 7c		 jmp	 SHORT $LN3@TCFsctlCal
$LN2@TCFsctlCal:

; 2432 : 
; 2433 : 	stack = IoGetNextIrpStackLocation(irp);

  000aa	48 8b 4c 24 58	 mov	 rcx, QWORD PTR irp$[rsp]
  000af	e8 00 00 00 00	 call	 IoGetNextIrpStackLocation
  000b4	48 89 44 24 60	 mov	 QWORD PTR stack$[rsp], rax

; 2434 : 	
; 2435 : 	stack->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;

  000b9	48 8b 44 24 60	 mov	 rax, QWORD PTR stack$[rsp]
  000be	c6 00 0d	 mov	 BYTE PTR [rax], 13

; 2436 : 	stack->MinorFunction = IRP_MN_USER_FS_REQUEST;

  000c1	48 8b 44 24 60	 mov	 rax, QWORD PTR stack$[rsp]
  000c6	c6 40 01 00	 mov	 BYTE PTR [rax+1], 0

; 2437 : 	stack->FileObject = fileObject;

  000ca	48 8b 4c 24 60	 mov	 rcx, QWORD PTR stack$[rsp]
  000cf	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR fileObject$[rsp]
  000d7	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 2438 : 
; 2439 : 	ntStatus = IoCallDriver (deviceObject, irp);

  000db	48 8b 54 24 58	 mov	 rdx, QWORD PTR irp$[rsp]
  000e0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  000e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCallDriver
  000eb	89 44 24 68	 mov	 DWORD PTR ntStatus$[rsp], eax

; 2440 : 	if (ntStatus == STATUS_PENDING)

  000ef	81 7c 24 68 03
	01 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 259 ; 00000103H
  000f7	75 29		 jne	 SHORT $LN1@TCFsctlCal

; 2441 : 	{
; 2442 : 		KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);

  000f9	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00102	45 33 c9	 xor	 r9d, r9d
  00105	45 33 c0	 xor	 r8d, r8d
  00108	33 d2		 xor	 edx, edx
  0010a	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR event$[rsp]
  00112	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 2443 : 		ntStatus = ioStatusBlock.Status;

  00118	44 8b 5c 24 70	 mov	 r11d, DWORD PTR ioStatusBlock$[rsp]
  0011d	44 89 5c 24 68	 mov	 DWORD PTR ntStatus$[rsp], r11d
$LN1@TCFsctlCal:

; 2444 : 	}
; 2445 : 
; 2446 : 	return ntStatus;

  00122	8b 44 24 68	 mov	 eax, DWORD PTR ntStatus$[rsp]
$LN3@TCFsctlCal:

; 2447 : }

  00126	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0012d	c3		 ret	 0
TCFsctlCall ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCReadWriteDevice DD imagerel TCReadWriteDevice
	DD	imagerel TCReadWriteDevice+337
	DD	imagerel $unwind$TCReadWriteDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCReadWriteDevice DD 021a01H
	DD	011011aH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT TCReadWriteDevice
_TEXT	SEGMENT
completionEvent$ = 64
irp$ = 88
ioStatusBlock$ = 96
status$ = 112
tv71 = 116
tv83 = 120
write$ = 144
deviceObject$ = 152
buffer$ = 160
offset$ = 168
length$ = 176
TCReadWriteDevice PROC					; COMDAT

; 2370 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 2371 : 	NTSTATUS status;
; 2372 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2373 : 	PIRP irp;
; 2374 : 	KEVENT completionEvent;
; 2375 : 
; 2376 : 	ASSERT (KeGetCurrentIrql() <= APC_LEVEL);

  0001a	e8 00 00 00 00	 call	 KeGetCurrentIrql
  0001f	0f b6 c0	 movzx	 eax, al
  00022	83 f8 01	 cmp	 eax, 1
  00025	7e 27		 jle	 SHORT $LN6@TCReadWrit
  00027	45 33 c9	 xor	 r9d, r9d
  0002a	41 b8 48 09 00
	00		 mov	 r8d, 2376		; 00000948H
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  00037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@MOHACMBH@KeGetCurrentIrql?$CI?$CJ?5?$DM?$DN?5APC_LEVEL?$AA@FNODOBFM@
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  00044	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
  0004c	eb 08		 jmp	 SHORT $LN7@TCReadWrit
$LN6@TCReadWrit:
  0004e	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv71[rsp], 1
$LN7@TCReadWrit:

; 2377 : 
; 2378 : 	KeInitializeEvent (&completionEvent, NotificationEvent, FALSE);

  00056	45 33 c0	 xor	 r8d, r8d
  00059	33 d2		 xor	 edx, edx
  0005b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR completionEvent$[rsp]
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 2379 : 	irp = IoBuildSynchronousFsdRequest (write ? IRP_MJ_WRITE : IRP_MJ_READ, deviceObject, buffer, length, &offset, &completionEvent, &ioStatusBlock);

  00066	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR write$[rsp], 0
  0006e	74 0a		 je	 SHORT $LN8@TCReadWrit
  00070	c7 44 24 78 04
	00 00 00	 mov	 DWORD PTR tv83[rsp], 4
  00078	eb 08		 jmp	 SHORT $LN9@TCReadWrit
$LN8@TCReadWrit:
  0007a	c7 44 24 78 03
	00 00 00	 mov	 DWORD PTR tv83[rsp], 3
$LN9@TCReadWrit:
  00082	48 8d 44 24 60	 lea	 rax, QWORD PTR ioStatusBlock$[rsp]
  00087	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0008c	48 8d 44 24 40	 lea	 rax, QWORD PTR completionEvent$[rsp]
  00091	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00096	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR offset$[rsp]
  0009e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a3	44 8b 8c 24 b0
	00 00 00	 mov	 r9d, DWORD PTR length$[rsp]
  000ab	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR buffer$[rsp]
  000b3	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR deviceObject$[rsp]
  000bb	8b 4c 24 78	 mov	 ecx, DWORD PTR tv83[rsp]
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoBuildSynchronousFsdRequest
  000c5	48 89 44 24 58	 mov	 QWORD PTR irp$[rsp], rax

; 2380 : 	if (!irp)

  000ca	48 83 7c 24 58
	00		 cmp	 QWORD PTR irp$[rsp], 0
  000d0	75 07		 jne	 SHORT $LN3@TCReadWrit

; 2381 : 		return STATUS_INSUFFICIENT_RESOURCES;

  000d2	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  000d7	eb 70		 jmp	 SHORT $LN4@TCReadWrit
$LN3@TCReadWrit:

; 2382 : 
; 2383 : 	ObReferenceObject (deviceObject);

  000d9	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  000e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfReferenceObject

; 2384 : 	status = IoCallDriver (deviceObject, irp);

  000e7	48 8b 54 24 58	 mov	 rdx, QWORD PTR irp$[rsp]
  000ec	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  000f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCallDriver
  000fa	89 44 24 70	 mov	 DWORD PTR status$[rsp], eax

; 2385 : 
; 2386 : 	if (status == STATUS_PENDING)

  000fe	81 7c 24 70 03
	01 00 00	 cmp	 DWORD PTR status$[rsp], 259 ; 00000103H
  00106	75 2f		 jne	 SHORT $LN2@TCReadWrit

; 2387 : 	{
; 2388 : 		status = KeWaitForSingleObject (&completionEvent, Executive, KernelMode, FALSE, NULL);

  00108	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00111	45 33 c9	 xor	 r9d, r9d
  00114	45 33 c0	 xor	 r8d, r8d
  00117	33 d2		 xor	 edx, edx
  00119	48 8d 4c 24 40	 lea	 rcx, QWORD PTR completionEvent$[rsp]
  0011e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  00124	89 44 24 70	 mov	 DWORD PTR status$[rsp], eax

; 2389 : 		if (NT_SUCCESS (status))

  00128	83 7c 24 70 00	 cmp	 DWORD PTR status$[rsp], 0
  0012d	7c 08		 jl	 SHORT $LN1@TCReadWrit

; 2390 : 			status = ioStatusBlock.Status;

  0012f	8b 44 24 60	 mov	 eax, DWORD PTR ioStatusBlock$[rsp]
  00133	89 44 24 70	 mov	 DWORD PTR status$[rsp], eax
$LN1@TCReadWrit:
$LN2@TCReadWrit:

; 2391 : 	}
; 2392 : 
; 2393 : 	ObDereferenceObject (deviceObject);

  00137	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  0013f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 2394 : 	return status;

  00145	8b 44 24 70	 mov	 eax, DWORD PTR status$[rsp]
$LN4@TCReadWrit:

; 2395 : }

  00149	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00150	c3		 ret	 0
TCReadWriteDevice ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	TCOpenFsVolume
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCOpenFsVolume DD imagerel $LN5
	DD	imagerel $LN5+407
	DD	imagerel $unwind$TCOpenFsVolume
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCOpenFsVolume DD 022819H
	DD	05d0116H
	DD	imagerel __GSHandlerCheck
	DD	02d8H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT TCOpenFsVolume
_TEXT	SEGMENT
objectAttributes$ = 96
volumeName$ = 160
ntStatus$ = 688
fullFileName$ = 696
ioStatus$ = 712
__$ArrayPad$ = 728
Extension$ = 752
volumeHandle$ = 760
fileObject$ = 768
TCOpenFsVolume PROC					; COMDAT

; 2320 : {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec e8 02
	00 00		 sub	 rsp, 744		; 000002e8H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 d8
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2321 : 	NTSTATUS ntStatus;
; 2322 : 	OBJECT_ATTRIBUTES objectAttributes;
; 2323 : 	UNICODE_STRING fullFileName;
; 2324 : 	IO_STATUS_BLOCK ioStatus;
; 2325 : 	WCHAR volumeName[TC_MAX_PATH];
; 2326 : 
; 2327 : 	TCGetNTNameFromNumber (volumeName, Extension->nDosDriveNo);

  00028	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00030	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  00033	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR volumeName$[rsp]
  0003b	e8 00 00 00 00	 call	 TCGetNTNameFromNumber

; 2328 : 	RtlInitUnicodeString (&fullFileName, volumeName);

  00040	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR volumeName$[rsp]
  00048	48 8d 8c 24 b8
	02 00 00	 lea	 rcx, QWORD PTR fullFileName$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2329 : 	InitializeObjectAttributes (&objectAttributes, &fullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

  00056	c7 44 24 60 30
	00 00 00	 mov	 DWORD PTR objectAttributes$[rsp], 48 ; 00000030H
  0005e	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR objectAttributes$[rsp+8], 0
  00067	c7 44 24 78 40
	02 00 00	 mov	 DWORD PTR objectAttributes$[rsp+24], 576 ; 00000240H
  0006f	48 8d 84 24 b8
	02 00 00	 lea	 rax, QWORD PTR fullFileName$[rsp]
  00077	48 89 44 24 70	 mov	 QWORD PTR objectAttributes$[rsp+16], rax
  0007c	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR objectAttributes$[rsp+32], 0
  00088	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR objectAttributes$[rsp+40], 0

; 2330 : 
; 2331 : 	ntStatus = ZwCreateFile (volumeHandle,
; 2332 : 		SYNCHRONIZE | GENERIC_READ,
; 2333 : 		&objectAttributes,
; 2334 : 		&ioStatus,
; 2335 : 		NULL,
; 2336 : 		FILE_ATTRIBUTE_NORMAL,
; 2337 : 		FILE_SHARE_READ | FILE_SHARE_WRITE,
; 2338 : 		FILE_OPEN,
; 2339 : 		FILE_SYNCHRONOUS_IO_NONALERT,
; 2340 : 		NULL,
; 2341 : 		0);

  00094	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR [rsp+80], 0
  0009c	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR [rsp+72], 0
  000a5	c7 44 24 40 20
	00 00 00	 mov	 DWORD PTR [rsp+64], 32	; 00000020H
  000ad	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR [rsp+56], 1
  000b5	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR [rsp+48], 3
  000bd	c7 44 24 28 80
	00 00 00	 mov	 DWORD PTR [rsp+40], 128	; 00000080H
  000c5	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000ce	4c 8d 8c 24 c8
	02 00 00	 lea	 r9, QWORD PTR ioStatus$[rsp]
  000d6	4c 8d 44 24 60	 lea	 r8, QWORD PTR objectAttributes$[rsp]
  000db	ba 00 00 10 80	 mov	 edx, -2146435072	; 80100000H
  000e0	48 8b 8c 24 f8
	02 00 00	 mov	 rcx, QWORD PTR volumeHandle$[rsp]
  000e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwCreateFile
  000ee	89 84 24 b0 02
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 2342 : 
; 2343 : 	Dump ("Volume %ls open NTSTATUS 0x%08x\n", volumeName, ntStatus);

  000f5	44 8b 84 24 b0
	02 00 00	 mov	 r8d, DWORD PTR ntStatus$[rsp]
  000fd	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR volumeName$[rsp]
  00105	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CB@JIDCFMLM@Volume?5?$CFls?5open?5NTSTATUS?50x?$CF08x?6@FNODOBFM@
  0010c	e8 00 00 00 00	 call	 DbgPrint

; 2344 : 
; 2345 : 	if (!NT_SUCCESS (ntStatus))

  00111	83 bc 24 b0 02
	00 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  00119	7d 09		 jge	 SHORT $LN2@TCOpenFsVo

; 2346 : 		return ntStatus;

  0011b	8b 84 24 b0 02
	00 00		 mov	 eax, DWORD PTR ntStatus$[rsp]
  00122	eb 5b		 jmp	 SHORT $LN3@TCOpenFsVo
$LN2@TCOpenFsVo:

; 2347 : 
; 2348 : 	ntStatus = ObReferenceObjectByHandle (*volumeHandle,
; 2349 : 		FILE_READ_DATA,
; 2350 : 		NULL,
; 2351 : 		KernelMode,
; 2352 : 		fileObject,
; 2353 : 		NULL);

  00124	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0012d	48 8b 84 24 00
	03 00 00	 mov	 rax, QWORD PTR fileObject$[rsp]
  00135	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0013a	45 33 c9	 xor	 r9d, r9d
  0013d	45 33 c0	 xor	 r8d, r8d
  00140	ba 01 00 00 00	 mov	 edx, 1
  00145	48 8b 8c 24 f8
	02 00 00	 mov	 rcx, QWORD PTR volumeHandle$[rsp]
  0014d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00150	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObReferenceObjectByHandle
  00156	89 84 24 b0 02
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 2354 : 
; 2355 : 	if (!NT_SUCCESS (ntStatus))

  0015d	83 bc 24 b0 02
	00 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  00165	7d 11		 jge	 SHORT $LN1@TCOpenFsVo

; 2356 : 		ZwClose (*volumeHandle);

  00167	48 8b 8c 24 f8
	02 00 00	 mov	 rcx, QWORD PTR volumeHandle$[rsp]
  0016f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00172	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
$LN1@TCOpenFsVo:

; 2357 : 
; 2358 : 	return ntStatus;

  00178	8b 84 24 b0 02
	00 00		 mov	 eax, DWORD PTR ntStatus$[rsp]
$LN3@TCOpenFsVo:

; 2359 : }

  0017f	48 8b 8c 24 d8
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00187	48 33 cc	 xor	 rcx, rsp
  0018a	e8 00 00 00 00	 call	 __security_check_cookie
  0018f	48 81 c4 e8 02
	00 00		 add	 rsp, 744		; 000002e8H
  00196	c3		 ret	 0
TCOpenFsVolume ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SendDeviceIoControlRequest DD imagerel $LN7
	DD	imagerel $LN7+534
	DD	imagerel $unwind$SendDeviceIoControlRequest
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SendDeviceIoControlRequest DD 021a01H
	DD	01f011aH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT SendDeviceIoControlRequest
_TEXT	SEGMENT
irp$ = 80
ioStatusBlock$ = 88
event$ = 104
status$ = 128
args$32761 = 144
workItem$32762 = 224
deviceObject$ = 256
ioControlCode$ = 264
inputBuffer$ = 272
inputBufferSize$ = 280
outputBuffer$ = 288
outputBufferSize$ = 296
SendDeviceIoControlRequest PROC				; COMDAT

; 2215 : {

$LN7:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H

; 2216 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2217 : 	NTSTATUS status;
; 2218 : 	PIRP irp;
; 2219 : 	KEVENT event;
; 2220 : 
; 2221 : 	if (KeGetCurrentIrql() > APC_LEVEL)

  0001a	e8 00 00 00 00	 call	 KeGetCurrentIrql
  0001f	0f b6 c0	 movzx	 eax, al
  00022	83 f8 01	 cmp	 eax, 1
  00025	0f 8e f6 00 00
	00		 jle	 $LN4@SendDevice

; 2222 : 	{
; 2223 : 		SendDeviceIoControlRequestWorkItemArgs args;
; 2224 : 
; 2225 : 		PIO_WORKITEM workItem = IoAllocateWorkItem (RootDeviceObject);

  0002b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR RootDeviceObject
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAllocateWorkItem
  00038	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR workItem$32762[rsp], rax

; 2226 : 		if (!workItem)

  00040	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR workItem$32762[rsp], 0
  00049	75 0a		 jne	 SHORT $LN3@SendDevice

; 2227 : 			return STATUS_INSUFFICIENT_RESOURCES;

  0004b	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  00050	e9 b9 01 00 00	 jmp	 $LN5@SendDevice
$LN3@SendDevice:

; 2228 : 
; 2229 : 		args.deviceObject = deviceObject;

  00055	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR deviceObject$[rsp]
  0005d	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR args$32761[rsp], rax

; 2230 : 		args.ioControlCode = ioControlCode;

  00065	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR ioControlCode$[rsp]
  0006c	89 84 24 98 00
	00 00		 mov	 DWORD PTR args$32761[rsp+8], eax

; 2231 : 		args.inputBuffer = inputBuffer;

  00073	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR inputBuffer$[rsp]
  0007b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR args$32761[rsp+16], rax

; 2232 : 		args.inputBufferSize = inputBufferSize;

  00083	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR inputBufferSize$[rsp]
  0008a	89 84 24 a8 00
	00 00		 mov	 DWORD PTR args$32761[rsp+24], eax

; 2233 : 		args.outputBuffer = outputBuffer;

  00091	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR outputBuffer$[rsp]
  00099	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR args$32761[rsp+32], rax

; 2234 : 		args.outputBufferSize = outputBufferSize;

  000a1	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR outputBufferSize$[rsp]
  000a8	89 84 24 b8 00
	00 00		 mov	 DWORD PTR args$32761[rsp+40], eax

; 2235 : 
; 2236 : 		KeInitializeEvent (&args.WorkItemCompletedEvent, SynchronizationEvent, FALSE);

  000af	45 33 c0	 xor	 r8d, r8d
  000b2	ba 01 00 00 00	 mov	 edx, 1
  000b7	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR args$32761[rsp+48]
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 2237 : 		IoQueueWorkItem (workItem, SendDeviceIoControlRequestWorkItemRoutine, DelayedWorkQueue, &args); 

  000c5	4c 8d 8c 24 90
	00 00 00	 lea	 r9, QWORD PTR args$32761[rsp]
  000cd	41 b8 01 00 00
	00		 mov	 r8d, 1
  000d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:SendDeviceIoControlRequestWorkItemRoutine
  000da	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR workItem$32762[rsp]
  000e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoQueueWorkItem

; 2238 : 
; 2239 : 		KeWaitForSingleObject (&args.WorkItemCompletedEvent, Executive, KernelMode, FALSE, NULL);

  000e8	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000f1	45 33 c9	 xor	 r9d, r9d
  000f4	45 33 c0	 xor	 r8d, r8d
  000f7	33 d2		 xor	 edx, edx
  000f9	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR args$32761[rsp+48]
  00101	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 2240 : 		IoFreeWorkItem (workItem);

  00107	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR workItem$32762[rsp]
  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoFreeWorkItem

; 2241 :  
; 2242 : 		return args.Status;

  00115	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR args$32761[rsp+44]
  0011c	e9 ed 00 00 00	 jmp	 $LN5@SendDevice
$LN4@SendDevice:

; 2243 : 	}
; 2244 : 
; 2245 : 	KeInitializeEvent (&event, NotificationEvent, FALSE);

  00121	45 33 c0	 xor	 r8d, r8d
  00124	33 d2		 xor	 edx, edx
  00126	48 8d 4c 24 68	 lea	 rcx, QWORD PTR event$[rsp]
  0012b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 2246 : 
; 2247 : 	irp = IoBuildDeviceIoControlRequest (ioControlCode, deviceObject, inputBuffer, inputBufferSize,
; 2248 : 		outputBuffer, outputBufferSize, FALSE, &event, &ioStatusBlock);

  00131	4c 8d 5c 24 58	 lea	 r11, QWORD PTR ioStatusBlock$[rsp]
  00136	4c 89 5c 24 40	 mov	 QWORD PTR [rsp+64], r11
  0013b	48 8d 44 24 68	 lea	 rax, QWORD PTR event$[rsp]
  00140	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00145	c6 44 24 30 00	 mov	 BYTE PTR [rsp+48], 0
  0014a	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR outputBufferSize$[rsp]
  00151	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00155	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR outputBuffer$[rsp]
  0015d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00162	44 8b 8c 24 18
	01 00 00	 mov	 r9d, DWORD PTR inputBufferSize$[rsp]
  0016a	4c 8b 84 24 10
	01 00 00	 mov	 r8, QWORD PTR inputBuffer$[rsp]
  00172	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR deviceObject$[rsp]
  0017a	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR ioControlCode$[rsp]
  00181	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoBuildDeviceIoControlRequest
  00187	48 89 44 24 50	 mov	 QWORD PTR irp$[rsp], rax

; 2249 : 
; 2250 : 	if (!irp)

  0018c	48 83 7c 24 50
	00		 cmp	 QWORD PTR irp$[rsp], 0
  00192	75 07		 jne	 SHORT $LN2@SendDevice

; 2251 : 		return STATUS_INSUFFICIENT_RESOURCES;

  00194	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  00199	eb 73		 jmp	 SHORT $LN5@SendDevice
$LN2@SendDevice:

; 2252 : 
; 2253 : 	ObReferenceObject (deviceObject);

  0019b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  001a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfReferenceObject

; 2254 : 
; 2255 : 	status = IoCallDriver (deviceObject, irp);

  001a9	48 8b 54 24 50	 mov	 rdx, QWORD PTR irp$[rsp]
  001ae	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  001b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCallDriver
  001bc	89 84 24 80 00
	00 00		 mov	 DWORD PTR status$[rsp], eax

; 2256 : 	if (status == STATUS_PENDING)

  001c3	81 bc 24 80 00
	00 00 03 01 00
	00		 cmp	 DWORD PTR status$[rsp], 259 ; 00000103H
  001ce	75 29		 jne	 SHORT $LN1@SendDevice

; 2257 : 	{
; 2258 : 		KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);

  001d0	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  001d9	45 33 c9	 xor	 r9d, r9d
  001dc	45 33 c0	 xor	 r8d, r8d
  001df	33 d2		 xor	 edx, edx
  001e1	48 8d 4c 24 68	 lea	 rcx, QWORD PTR event$[rsp]
  001e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 2259 : 		status = ioStatusBlock.Status;

  001ec	44 8b 5c 24 58	 mov	 r11d, DWORD PTR ioStatusBlock$[rsp]
  001f1	44 89 9c 24 80
	00 00 00	 mov	 DWORD PTR status$[rsp], r11d
$LN1@SendDevice:

; 2260 : 	}
; 2261 : 
; 2262 : 	ObDereferenceObject (deviceObject);

  001f9	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  00201	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 2263 : 	return status;

  00207	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR status$[rsp]
$LN5@SendDevice:

; 2264 : }

  0020e	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  00215	c3		 ret	 0
SendDeviceIoControlRequest ENDP
_TEXT	ENDS
PUBLIC	TCDeviceIoControl
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCDeviceIoControl DD imagerel $LN6
	DD	imagerel $LN6+353
	DD	imagerel $unwind$TCDeviceIoControl
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCDeviceIoControl DD 021a01H
	DD	017011aH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT TCDeviceIoControl
_TEXT	SEGMENT
deviceObject$ = 80
fileObject$ = 88
name$ = 96
irp$ = 112
ntStatus$ = 120
ioStatusBlock$ = 128
event$ = 144
deviceName$ = 192
IoControlCode$ = 200
InputBuffer$ = 208
InputBufferSize$ = 216
OutputBuffer$ = 224
OutputBufferSize$ = 232
TCDeviceIoControl PROC					; COMDAT

; 2152 : {

$LN6:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 2153 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2154 : 	NTSTATUS ntStatus;
; 2155 : 	PIRP irp;
; 2156 : 	PFILE_OBJECT fileObject;
; 2157 : 	PDEVICE_OBJECT deviceObject;
; 2158 : 	KEVENT event;
; 2159 : 	UNICODE_STRING name;
; 2160 : 
; 2161 : 	RtlInitUnicodeString(&name, deviceName);

  0001a	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR deviceName$[rsp]
  00022	48 8d 4c 24 60	 lea	 rcx, QWORD PTR name$[rsp]
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2162 : 	ntStatus = IoGetDeviceObjectPointer (&name, FILE_READ_ATTRIBUTES, &fileObject, &deviceObject);

  0002d	4c 8d 4c 24 50	 lea	 r9, QWORD PTR deviceObject$[rsp]
  00032	4c 8d 44 24 58	 lea	 r8, QWORD PTR fileObject$[rsp]
  00037	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0003c	48 8d 4c 24 60	 lea	 rcx, QWORD PTR name$[rsp]
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetDeviceObjectPointer
  00047	89 44 24 78	 mov	 DWORD PTR ntStatus$[rsp], eax

; 2163 : 
; 2164 : 	if (!NT_SUCCESS (ntStatus))

  0004b	83 7c 24 78 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  00050	7d 09		 jge	 SHORT $LN3@TCDeviceIo

; 2165 : 		return ntStatus;

  00052	8b 44 24 78	 mov	 eax, DWORD PTR ntStatus$[rsp]
  00056	e9 fe 00 00 00	 jmp	 $LN4@TCDeviceIo
$LN3@TCDeviceIo:

; 2166 : 
; 2167 : 	KeInitializeEvent(&event, NotificationEvent, FALSE);

  0005b	45 33 c0	 xor	 r8d, r8d
  0005e	33 d2		 xor	 edx, edx
  00060	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR event$[rsp]
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 2168 : 
; 2169 : 	irp = IoBuildDeviceIoControlRequest (IoControlCode,
; 2170 : 					     deviceObject,
; 2171 : 					     InputBuffer, InputBufferSize,
; 2172 : 					     OutputBuffer, OutputBufferSize,
; 2173 : 					     FALSE,
; 2174 : 					     &event,
; 2175 : 					     &ioStatusBlock);

  0006e	4c 8d 9c 24 80
	00 00 00	 lea	 r11, QWORD PTR ioStatusBlock$[rsp]
  00076	4c 89 5c 24 40	 mov	 QWORD PTR [rsp+64], r11
  0007b	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR event$[rsp]
  00083	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00088	c6 44 24 30 00	 mov	 BYTE PTR [rsp+48], 0
  0008d	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR OutputBufferSize$[rsp]
  00094	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00098	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR OutputBuffer$[rsp]
  000a0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a5	44 8b 8c 24 d8
	00 00 00	 mov	 r9d, DWORD PTR InputBufferSize$[rsp]
  000ad	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR InputBuffer$[rsp]
  000b5	48 8b 54 24 50	 mov	 rdx, QWORD PTR deviceObject$[rsp]
  000ba	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR IoControlCode$[rsp]
  000c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoBuildDeviceIoControlRequest
  000c7	48 89 44 24 70	 mov	 QWORD PTR irp$[rsp], rax

; 2176 : 
; 2177 : 	if (irp == NULL)

  000cc	48 83 7c 24 70
	00		 cmp	 QWORD PTR irp$[rsp], 0
  000d2	75 16		 jne	 SHORT $LN2@TCDeviceIo

; 2178 : 	{
; 2179 : 		Dump ("IRP allocation failed\n");

  000d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@BPCEMJJB@IRP?5allocation?5failed?6?$AA@FNODOBFM@
  000db	e8 00 00 00 00	 call	 DbgPrint

; 2180 : 		ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  000e0	c7 44 24 78 9a
	00 00 c0	 mov	 DWORD PTR ntStatus$[rsp], -1073741670 ; ffffffffc000009aH

; 2181 : 		goto ret;

  000e8	eb 60		 jmp	 SHORT $ret$32723
$LN2@TCDeviceIo:

; 2182 : 	}
; 2183 : 
; 2184 : 	IoGetNextIrpStackLocation (irp)->FileObject = fileObject;

  000ea	48 8b 4c 24 70	 mov	 rcx, QWORD PTR irp$[rsp]
  000ef	e8 00 00 00 00	 call	 IoGetNextIrpStackLocation
  000f4	4c 8b d8	 mov	 r11, rax
  000f7	48 8b 44 24 58	 mov	 rax, QWORD PTR fileObject$[rsp]
  000fc	49 89 43 30	 mov	 QWORD PTR [r11+48], rax

; 2185 : 
; 2186 : 	ntStatus = IoCallDriver (deviceObject, irp);

  00100	48 8b 54 24 70	 mov	 rdx, QWORD PTR irp$[rsp]
  00105	48 8b 4c 24 50	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  0010a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCallDriver
  00110	89 44 24 78	 mov	 DWORD PTR ntStatus$[rsp], eax

; 2187 : 	if (ntStatus == STATUS_PENDING)

  00114	81 7c 24 78 03
	01 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 259 ; 00000103H
  0011c	75 2c		 jne	 SHORT $LN1@TCDeviceIo

; 2188 : 	{
; 2189 : 		KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);

  0011e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00127	45 33 c9	 xor	 r9d, r9d
  0012a	45 33 c0	 xor	 r8d, r8d
  0012d	33 d2		 xor	 edx, edx
  0012f	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR event$[rsp]
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 2190 : 		ntStatus = ioStatusBlock.Status;

  0013d	44 8b 9c 24 80
	00 00 00	 mov	 r11d, DWORD PTR ioStatusBlock$[rsp]
  00145	44 89 5c 24 78	 mov	 DWORD PTR ntStatus$[rsp], r11d
$LN1@TCDeviceIo:
$ret$32723:

; 2191 : 	}
; 2192 : 
; 2193 : ret:
; 2194 : 	ObDereferenceObject (fileObject);

  0014a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR fileObject$[rsp]
  0014f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 2195 : 	return ntStatus;

  00155	8b 44 24 78	 mov	 eax, DWORD PTR ntStatus$[rsp]
$LN4@TCDeviceIo:

; 2196 : }

  00159	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00160	c3		 ret	 0
TCDeviceIoControl ENDP
_TEXT	ENDS
PUBLIC	OnShutdownPending
;	COMDAT pdata
pdata	SEGMENT
$pdata$OnShutdownPending DD imagerel $LN8
	DD	imagerel $LN8+153
	DD	imagerel $unwind$OnShutdownPending
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$OnShutdownPending DD 020601H
	DD	070027206H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT OnShutdownPending
_TEXT	SEGMENT
unmount$ = 48
OnShutdownPending PROC					; COMDAT

; 2139 : {

$LN8:
  00000	40 57		 push	 rdi
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 2140 : 	UNMOUNT_STRUCT unmount;
; 2141 : 	memset (&unmount, 0, sizeof (unmount));

  00006	48 8d 7c 24 30	 lea	 rdi, QWORD PTR unmount$[rsp]
  0000b	33 c0		 xor	 eax, eax
  0000d	b9 10 00 00 00	 mov	 ecx, 16
  00012	f3 aa		 rep stosb

; 2142 : 	unmount.ignoreOpenFiles = TRUE;

  00014	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR unmount$[rsp+4], 1
$LN5@OnShutdown:

; 2143 : 
; 2144 : 	while (SendDeviceIoControlRequest (RootDeviceObject, TC_IOCTL_DISMOUNT_ALL_VOLUMES, &unmount, sizeof (unmount), &unmount, sizeof (unmount)) == STATUS_INSUFFICIENT_RESOURCES || unmount.HiddenVolumeProtectionTriggered)

  0001c	c7 44 24 28 10
	00 00 00	 mov	 DWORD PTR [rsp+40], 16
  00024	48 8d 44 24 30	 lea	 rax, QWORD PTR unmount$[rsp]
  00029	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0002e	41 b9 10 00 00
	00		 mov	 r9d, 16
  00034	4c 8d 44 24 30	 lea	 r8, QWORD PTR unmount$[rsp]
  00039	ba 14 20 22 00	 mov	 edx, 2236436		; 00222014H
  0003e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR RootDeviceObject
  00045	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  0004a	3d 9a 00 00 c0	 cmp	 eax, -1073741670	; ffffffffc000009aH
  0004f	74 07		 je	 SHORT $LN3@OnShutdown
  00051	83 7c 24 38 00	 cmp	 DWORD PTR unmount$[rsp+8], 0
  00056	74 0a		 je	 SHORT $LN4@OnShutdown
$LN3@OnShutdown:

; 2145 : 		unmount.HiddenVolumeProtectionTriggered = FALSE;

  00058	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR unmount$[rsp+8], 0
  00060	eb ba		 jmp	 SHORT $LN5@OnShutdown
$LN4@OnShutdown:
$LN2@OnShutdown:

; 2146 : 
; 2147 : 	while (SendDeviceIoControlRequest (RootDeviceObject, TC_IOCTL_WIPE_PASSWORD_CACHE, NULL, 0, NULL, 0) == STATUS_INSUFFICIENT_RESOURCES);

  00062	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0006a	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00073	45 33 c9	 xor	 r9d, r9d
  00076	45 33 c0	 xor	 r8d, r8d
  00079	ba 30 20 22 00	 mov	 edx, 2236464		; 00222030H
  0007e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR RootDeviceObject
  00085	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  0008a	3d 9a 00 00 c0	 cmp	 eax, -1073741670	; ffffffffc000009aH
  0008f	75 02		 jne	 SHORT $LN1@OnShutdown
  00091	eb cf		 jmp	 SHORT $LN2@OnShutdown
$LN1@OnShutdown:

; 2148 : }

  00093	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00097	5f		 pop	 rdi
  00098	c3		 ret	 0
OnShutdownPending ENDP
_TEXT	ENDS
PUBLIC	TCDeleteDeviceObject
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCDeleteDeviceObject DD imagerel $LN14
	DD	imagerel $LN14+400
	DD	imagerel $unwind$TCDeleteDeviceObject
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCDeleteDeviceObject DD 010e01H
	DD	0c20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT TCDeleteDeviceObject
_TEXT	SEGMENT
Win32NameString$ = 48
ntStatus$ = 64
name$32664 = 72
PsDereferenceImpersonationTokenD$32663 = 88
DeviceObject$ = 112
Extension$ = 120
TCDeleteDeviceObject PROC				; COMDAT

; 2061 : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2062 : 	UNICODE_STRING Win32NameString;
; 2063 : 	NTSTATUS ntStatus;
; 2064 : 
; 2065 : 	Dump ("TCDeleteDeviceObject BEGIN\n");

  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@GNHEHBJH@TCDeleteDeviceObject?5BEGIN?6?$AA@FNODOBFM@
  00015	e8 00 00 00 00	 call	 DbgPrint

; 2066 : 
; 2067 : 	if (Extension->bRootDevice)

  0001a	4c 8b 5c 24 78	 mov	 r11, QWORD PTR Extension$[rsp]
  0001f	41 83 3b 00	 cmp	 DWORD PTR [r11], 0
  00023	74 48		 je	 SHORT $LN11@TCDeleteDe

; 2068 : 	{
; 2069 : 		RtlInitUnicodeString (&Win32NameString, (LPWSTR) DOS_ROOT_PREFIX);

  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
  0002c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR Win32NameString$[rsp]
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2070 : 		ntStatus = IoDeleteSymbolicLink (&Win32NameString);

  00037	48 8d 4c 24 30	 lea	 rcx, QWORD PTR Win32NameString$[rsp]
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteSymbolicLink
  00042	89 44 24 40	 mov	 DWORD PTR ntStatus$[rsp], eax

; 2071 : 		if (!NT_SUCCESS (ntStatus))

  00046	83 7c 24 40 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  0004b	7d 10		 jge	 SHORT $LN10@TCDeleteDe

; 2072 : 			Dump ("IoDeleteSymbolicLink failed ntStatus = 0x%08x\n", ntStatus);

  0004d	8b 54 24 40	 mov	 edx, DWORD PTR ntStatus$[rsp]
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CP@NIIDLADO@IoDeleteSymbolicLink?5failed?5ntSt@FNODOBFM@
  00058	e8 00 00 00 00	 call	 DbgPrint
$LN10@TCDeleteDe:

; 2073 : 
; 2074 : 		RootDeviceObject = NULL;

  0005d	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR RootDeviceObject, 0

; 2075 : 	}
; 2076 : 	else

  00068	e9 07 01 00 00	 jmp	 $LN9@TCDeleteDe
$LN11@TCDeleteDe:

; 2077 : 	{
; 2078 : 		if (Extension->peThread != NULL)

  0006d	48 8b 44 24 78	 mov	 rax, QWORD PTR Extension$[rsp]
  00072	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00077	74 0f		 je	 SHORT $LN8@TCDeleteDe

; 2079 : 			TCStopVolumeThread (DeviceObject, Extension);

  00079	48 8b 54 24 78	 mov	 rdx, QWORD PTR Extension$[rsp]
  0007e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  00083	e8 00 00 00 00	 call	 TCStopVolumeThread
$LN8@TCDeleteDe:

; 2080 : 
; 2081 : 		if (Extension->UserSid)

  00088	48 8b 44 24 78	 mov	 rax, QWORD PTR Extension$[rsp]
  0008d	48 83 b8 e0 05
	00 00 00	 cmp	 QWORD PTR [rax+1504], 0
  00095	74 17		 je	 SHORT $LN7@TCDeleteDe

; 2082 : 			TCfree (Extension->UserSid);

  00097	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  0009c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Extension$[rsp]
  000a1	48 8b 89 e0 05
	00 00		 mov	 rcx, QWORD PTR [rcx+1504]
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN7@TCDeleteDe:

; 2083 : 
; 2084 : 		if (Extension->SecurityClientContextValid)

  000ae	48 8b 44 24 78	 mov	 rax, QWORD PTR Extension$[rsp]
  000b3	83 b8 e8 05 00
	00 00		 cmp	 DWORD PTR [rax+1512], 0
  000ba	0f 84 9c 00 00
	00		 je	 $LN6@TCDeleteDe

; 2085 : 		{
; 2086 : 			if (OsMajorVersion == 5 && OsMinorVersion == 0)

  000c0	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR OsMajorVersion, 5
  000c7	75 1d		 jne	 SHORT $LN5@TCDeleteDe
  000c9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR OsMinorVersion, 0
  000d0	75 14		 jne	 SHORT $LN5@TCDeleteDe

; 2087 : 			{
; 2088 : 				ObDereferenceObject (Extension->SecurityClientContext.ClientToken);

  000d2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Extension$[rsp]
  000d7	48 8b 89 00 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1536]
  000de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 2089 : 			}
; 2090 : 			else

  000e4	eb 76		 jmp	 SHORT $LN4@TCDeleteDe
$LN5@TCDeleteDe:

; 2091 : 			{
; 2092 : 				// Windows 2000 does not support PsDereferenceImpersonationToken() used by SeDeleteClientSecurity().
; 2093 : 				// TODO: Use only SeDeleteClientSecurity() once support for Windows 2000 is dropped.
; 2094 : 
; 2095 : 				VOID (*PsDereferenceImpersonationTokenD) (PACCESS_TOKEN ImpersonationToken);
; 2096 : 				UNICODE_STRING name;
; 2097 : 				RtlInitUnicodeString (&name, L"PsDereferenceImpersonationToken");

  000e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EA@FPAPEGHJ@?$AAP?$AAs?$AAD?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAI?$AAm?$AAp?$AAe?$AAr?$AAs?$AAo?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAk?$AAe?$AAn?$AA?$AA@FNODOBFM@
  000ed	48 8d 4c 24 48	 lea	 rcx, QWORD PTR name$32664[rsp]
  000f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2098 : 
; 2099 : 				PsDereferenceImpersonationTokenD = MmGetSystemRoutineAddress (&name);

  000f8	48 8d 4c 24 48	 lea	 rcx, QWORD PTR name$32664[rsp]
  000fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmGetSystemRoutineAddress
  00103	48 89 44 24 58	 mov	 QWORD PTR PsDereferenceImpersonationTokenD$32663[rsp], rax

; 2100 : 				if (!PsDereferenceImpersonationTokenD)

  00108	48 83 7c 24 58
	00		 cmp	 QWORD PTR PsDereferenceImpersonationTokenD$32663[rsp], 0
  0010e	75 23		 jne	 SHORT $LN3@TCDeleteDe

; 2101 : 					TC_BUG_CHECK (STATUS_NOT_IMPLEMENTED);

  00110	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00119	45 33 c9	 xor	 r9d, r9d
  0011c	49 c7 c0 02 00
	00 c0		 mov	 r8, -1073741822		; ffffffffc0000002H
  00123	ba 35 08 00 00	 mov	 edx, 2101		; 00000835H
  00128	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  0012d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN3@TCDeleteDe:

; 2102 : 				
; 2103 : #				define PsDereferencePrimaryToken
; 2104 : #				define PsDereferenceImpersonationToken PsDereferenceImpersonationTokenD
; 2105 : 
; 2106 : 				SeDeleteClientSecurity (&Extension->SecurityClientContext);

  00133	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Extension$[rsp]
  00138	48 8b 89 00 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1536]
  0013f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeTokenType
  00145	83 f8 01	 cmp	 eax, 1
  00148	75 02		 jne	 SHORT $LN2@TCDeleteDe
  0014a	eb 10		 jmp	 SHORT $LN1@TCDeleteDe
$LN2@TCDeleteDe:
  0014c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Extension$[rsp]
  00151	48 8b 89 00 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1536]
  00158	ff 54 24 58	 call	 QWORD PTR PsDereferenceImpersonationTokenD$32663[rsp]
$LN1@TCDeleteDe:
$LN4@TCDeleteDe:
$LN6@TCDeleteDe:

; 2107 : 
; 2108 : #				undef PsDereferencePrimaryToken
; 2109 : #				undef PsDereferenceImpersonationToken
; 2110 : 			}
; 2111 : 		}
; 2112 : 
; 2113 : 		VirtualVolumeDeviceObjects[Extension->nDosDriveNo] = NULL;

  0015c	48 8b 44 24 78	 mov	 rax, QWORD PTR Extension$[rsp]
  00161	48 63 48 14	 movsxd	 rcx, DWORD PTR [rax+20]
  00165	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:VirtualVolumeDeviceObjects
  0016c	48 c7 04 c8 00
	00 00 00	 mov	 QWORD PTR [rax+rcx*8], 0
$LN9@TCDeleteDe:

; 2114 : 	}
; 2115 : 
; 2116 : 	IoDeleteDevice (DeviceObject);

  00174	48 8b 4c 24 70	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  00179	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteDevice

; 2117 : 
; 2118 : 	Dump ("TCDeleteDeviceObject END\n");

  0017f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@EIFNDPP@TCDeleteDeviceObject?5END?6?$AA@FNODOBFM@
  00186	e8 00 00 00 00	 call	 DbgPrint
$LN13@TCDeleteDe:

; 2119 : }

  0018b	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0018f	c3		 ret	 0
TCDeleteDeviceObject ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	TCCreateDeviceObject
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCCreateDeviceObject DD imagerel $LN10
	DD	imagerel $LN10+897
	DD	imagerel $unwind$TCCreateDeviceObject
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCCreateDeviceObject DD 032919H
	DD	0240117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0110H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT TCCreateDeviceObject
_TEXT	SEGMENT
devChars$ = 64
ntUnicodeString$ = 72
ntname$ = 96
Extension$ = 160
Win32NameString$ = 168
dosname$ = 192
ntStatus$ = 256
tv72 = 260
tv85 = 264
tv89 = 268
__$ArrayPad$ = 272
DriverObject$ = 304
ppDeviceObject$ = 312
mount$ = 320
TCCreateDeviceObject PROC				; COMDAT

; 414  : {

$LN10:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec 20 01
	00 00		 sub	 rsp, 288		; 00000120H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 415  : 	UNICODE_STRING Win32NameString, ntUnicodeString;
; 416  : 	WCHAR dosname[32], ntname[32];
; 417  : 	PEXTENSION Extension;
; 418  : 	NTSTATUS ntStatus;
; 419  : 	ULONG devChars = 0;

  00029	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR devChars$[rsp], 0

; 420  : 
; 421  : 	Dump ("TCCreateDeviceObject BEGIN\n");

  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@HAIECJHN@TCCreateDeviceObject?5BEGIN?6?$AA@FNODOBFM@
  00038	e8 00 00 00 00	 call	 DbgPrint

; 422  : 	ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

  0003d	e8 00 00 00 00	 call	 KeGetCurrentIrql
  00042	0f b6 c0	 movzx	 eax, al
  00045	85 c0		 test	 eax, eax
  00047	74 2a		 je	 SHORT $LN4@TCCreateDe
  00049	45 33 c9	 xor	 r9d, r9d
  0004c	41 b8 a6 01 00
	00		 mov	 r8d, 422		; 000001a6H
  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@KKOENIAD@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5PASSIVE_LE@FNODOBFM@
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  00066	c7 84 24 04 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv72[rsp], 0
  00071	eb 0b		 jmp	 SHORT $LN5@TCCreateDe
$LN4@TCCreateDe:
  00073	c7 84 24 04 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv72[rsp], 1
$LN5@TCCreateDe:

; 423  : 
; 424  : 	TCGetDosNameFromNumber (dosname, mount->nDosDriveNo);

  0007e	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  00086	8b 90 64 02 00
	00		 mov	 edx, DWORD PTR [rax+612]
  0008c	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR dosname$[rsp]
  00094	e8 00 00 00 00	 call	 TCGetDosNameFromNumber

; 425  : 	TCGetNTNameFromNumber (ntname, mount->nDosDriveNo);

  00099	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR mount$[rsp]
  000a1	8b 92 64 02 00
	00		 mov	 edx, DWORD PTR [rdx+612]
  000a7	48 8d 4c 24 60	 lea	 rcx, QWORD PTR ntname$[rsp]
  000ac	e8 00 00 00 00	 call	 TCGetNTNameFromNumber

; 426  : 	RtlInitUnicodeString (&ntUnicodeString, ntname);

  000b1	48 8d 54 24 60	 lea	 rdx, QWORD PTR ntname$[rsp]
  000b6	48 8d 4c 24 48	 lea	 rcx, QWORD PTR ntUnicodeString$[rsp]
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 427  : 	RtlInitUnicodeString (&Win32NameString, dosname);

  000c1	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR dosname$[rsp]
  000c9	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR Win32NameString$[rsp]
  000d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 428  : 
; 429  : 	devChars = FILE_DEVICE_SECURE_OPEN;

  000d7	c7 44 24 40 00
	01 00 00	 mov	 DWORD PTR devChars$[rsp], 256 ; 00000100H

; 430  : 	devChars |= mount->bMountReadOnly ? FILE_READ_ONLY_DEVICE : 0;

  000df	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  000e7	83 b8 6c 02 00
	00 00		 cmp	 DWORD PTR [rax+620], 0
  000ee	74 0d		 je	 SHORT $LN6@TCCreateDe
  000f0	c7 84 24 08 01
	00 00 02 00 00
	00		 mov	 DWORD PTR tv85[rsp], 2
  000fb	eb 0b		 jmp	 SHORT $LN7@TCCreateDe
$LN6@TCCreateDe:
  000fd	c7 84 24 08 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv85[rsp], 0
$LN7@TCCreateDe:
  00108	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR tv85[rsp]
  0010f	8b 44 24 40	 mov	 eax, DWORD PTR devChars$[rsp]
  00113	0b c1		 or	 eax, ecx
  00115	89 44 24 40	 mov	 DWORD PTR devChars$[rsp], eax

; 431  : 	devChars |= mount->bMountRemovable ? FILE_REMOVABLE_MEDIA : 0;

  00119	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  00121	83 b8 70 02 00
	00 00		 cmp	 DWORD PTR [rax+624], 0
  00128	74 0d		 je	 SHORT $LN8@TCCreateDe
  0012a	c7 84 24 0c 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv89[rsp], 1
  00135	eb 0b		 jmp	 SHORT $LN9@TCCreateDe
$LN8@TCCreateDe:
  00137	c7 84 24 0c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv89[rsp], 0
$LN9@TCCreateDe:
  00142	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR tv89[rsp]
  00149	8b 44 24 40	 mov	 eax, DWORD PTR devChars$[rsp]
  0014d	0b c1		 or	 eax, ecx
  0014f	89 44 24 40	 mov	 DWORD PTR devChars$[rsp], eax

; 432  : 
; 433  : 	Dump ("Creating device nt=%ls dos=%ls\n", ntname, dosname);

  00153	4c 8d 84 24 c0
	00 00 00	 lea	 r8, QWORD PTR dosname$[rsp]
  0015b	48 8d 54 24 60	 lea	 rdx, QWORD PTR ntname$[rsp]
  00160	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@MBKOBJGH@Creating?5device?5nt?$DN?$CFls?5dos?$DN?$CFls?6?$AA@FNODOBFM@
  00167	e8 00 00 00 00	 call	 DbgPrint

; 434  : 
; 435  : 	ntStatus = IoCreateDevice (
; 436  : 					  DriverObject,			/* Our Driver Object */
; 437  : 					  sizeof (EXTENSION),	/* Size of state information */
; 438  : 					  &ntUnicodeString,		/* Device name "\Device\Name" */
; 439  : 					  FILE_DEVICE_DISK,		/* Device type */
; 440  : 					  devChars,				/* Device characteristics */
; 441  : 					  FALSE,				/* Exclusive device */
; 442  : 					  ppDeviceObject);		/* Returned ptr to Device Object */

  0016c	48 8b 94 24 38
	01 00 00	 mov	 rdx, QWORD PTR ppDeviceObject$[rsp]
  00174	48 89 54 24 30	 mov	 QWORD PTR [rsp+48], rdx
  00179	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  0017e	8b 44 24 40	 mov	 eax, DWORD PTR devChars$[rsp]
  00182	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00186	41 b9 07 00 00
	00		 mov	 r9d, 7
  0018c	4c 8d 44 24 48	 lea	 r8, QWORD PTR ntUnicodeString$[rsp]
  00191	ba 38 06 00 00	 mov	 edx, 1592		; 00000638H
  00196	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR DriverObject$[rsp]
  0019e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateDevice
  001a4	89 84 24 00 01
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 443  : 
; 444  : 	if (!NT_SUCCESS (ntStatus))

  001ab	83 bc 24 00 01
	00 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  001b3	7d 1f		 jge	 SHORT $LN1@TCCreateDe

; 445  : 	{
; 446  : 		Dump ("TCCreateDeviceObject NTSTATUS = 0x%08x END\n", ntStatus);

  001b5	8b 94 24 00 01
	00 00		 mov	 edx, DWORD PTR ntStatus$[rsp]
  001bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CM@DAAJFNOI@TCCreateDeviceObject?5NTSTATUS?5?$DN?5@FNODOBFM@
  001c3	e8 00 00 00 00	 call	 DbgPrint

; 447  : 		return ntStatus;/* Failed to create DeviceObject */

  001c8	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR ntStatus$[rsp]
  001cf	e9 94 01 00 00	 jmp	 $LN2@TCCreateDe
$LN1@TCCreateDe:

; 448  : 	}
; 449  : 	/* Initialize device object and extension. */
; 450  : 
; 451  : 	(*ppDeviceObject)->Flags |= DO_DIRECT_IO;

  001d4	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR ppDeviceObject$[rsp]
  001dc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001df	8b 48 30	 mov	 ecx, DWORD PTR [rax+48]
  001e2	83 c9 10	 or	 ecx, 16
  001e5	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR ppDeviceObject$[rsp]
  001ed	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001f0	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 452  : 	(*ppDeviceObject)->StackSize += 6;		// Reduce occurrence of NO_MORE_IRP_STACK_LOCATIONS bug check caused by buggy drivers

  001f3	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR ppDeviceObject$[rsp]
  001fb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001fe	0f be 48 4c	 movsx	 ecx, BYTE PTR [rax+76]
  00202	83 c1 06	 add	 ecx, 6
  00205	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR ppDeviceObject$[rsp]
  0020d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00210	88 48 4c	 mov	 BYTE PTR [rax+76], cl

; 453  : 
; 454  : 	/* Setup the device extension */
; 455  : 	Extension = (PEXTENSION) (*ppDeviceObject)->DeviceExtension;

  00213	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR ppDeviceObject$[rsp]
  0021b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0021e	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00222	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR Extension$[rsp], rax

; 456  : 	memset (Extension, 0, sizeof (EXTENSION));

  0022a	48 8b bc 24 a0
	00 00 00	 mov	 rdi, QWORD PTR Extension$[rsp]
  00232	33 c0		 xor	 eax, eax
  00234	b9 38 06 00 00	 mov	 ecx, 1592		; 00000638H
  00239	f3 aa		 rep stosb

; 457  : 
; 458  : 	Extension->IsVolumeDevice = TRUE;

  0023b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00243	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [rax+4], 1

; 459  : 	Extension->nDosDriveNo = mount->nDosDriveNo;

  0024a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00252	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  0025a	8b 80 64 02 00
	00		 mov	 eax, DWORD PTR [rax+612]
  00260	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 460  : 	Extension->bRemovable = mount->bMountRemovable;

  00263	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  0026b	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  00273	8b 80 70 02 00
	00		 mov	 eax, DWORD PTR [rax+624]
  00279	89 81 9c 03 00
	00		 mov	 DWORD PTR [rcx+924], eax

; 461  : 	Extension->PartitionInInactiveSysEncScope = mount->bPartitionInInactiveSysEncScope;

  0027f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00287	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  0028f	8b 80 80 02 00
	00		 mov	 eax, DWORD PTR [rax+640]
  00295	89 81 a0 03 00
	00		 mov	 DWORD PTR [rcx+928], eax

; 462  : 	Extension->SystemFavorite = mount->SystemFavorite;

  0029b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  002a3	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  002ab	8b 80 88 02 00
	00		 mov	 eax, DWORD PTR [rax+648]
  002b1	89 81 ac 03 00
	00		 mov	 DWORD PTR [rcx+940], eax

; 463  : 
; 464  : 	KeInitializeEvent (&Extension->keCreateEvent, SynchronizationEvent, FALSE);

  002b7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  002bf	48 83 c1 28	 add	 rcx, 40			; 00000028H
  002c3	45 33 c0	 xor	 r8d, r8d
  002c6	ba 01 00 00 00	 mov	 edx, 1
  002cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 465  : 	KeInitializeSemaphore (&Extension->RequestSemaphore, 0L, MAXLONG);

  002d1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  002d9	48 83 c1 58	 add	 rcx, 88			; 00000058H
  002dd	41 b8 ff ff ff
	7f		 mov	 r8d, 2147483647		; 7fffffffH
  002e3	33 d2		 xor	 edx, edx
  002e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeSemaphore

; 466  : 	KeInitializeSpinLock (&Extension->ListSpinLock);

  002eb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  002f3	48 83 c1 40	 add	 rcx, 64			; 00000040H
  002f7	e8 00 00 00 00	 call	 KeInitializeSpinLock

; 467  : 	InitializeListHead (&Extension->ListEntry);

  002fc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00304	48 83 c1 48	 add	 rcx, 72			; 00000048H
  00308	e8 00 00 00 00	 call	 InitializeListHead

; 468  : 	IoInitializeRemoveLock (&Extension->Queue.RemoveLock, 'LRCT', 0, 0);

  0030d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00315	48 81 c1 80 01
	00 00		 add	 rcx, 384		; 00000180H
  0031c	c7 44 24 20 78
	00 00 00	 mov	 DWORD PTR [rsp+32], 120	; 00000078H
  00324	45 33 c9	 xor	 r9d, r9d
  00327	45 33 c0	 xor	 r8d, r8d
  0032a	ba 54 43 52 4c	 mov	 edx, 1280459604		; 4c524354H
  0032f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoInitializeRemoveLockEx

; 469  : 
; 470  : 	VirtualVolumeDeviceObjects[mount->nDosDriveNo] = *ppDeviceObject;

  00335	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR mount$[rsp]
  0033d	48 63 92 64 02
	00 00		 movsxd	 rdx, DWORD PTR [rdx+612]
  00344	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:VirtualVolumeDeviceObjects
  0034b	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR ppDeviceObject$[rsp]
  00353	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00356	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax

; 471  : 
; 472  : 	Dump ("TCCreateDeviceObject STATUS_SUCCESS END\n");

  0035a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CJ@CAANMOOG@TCCreateDeviceObject?5STATUS_SUCC@FNODOBFM@
  00361	e8 00 00 00 00	 call	 DbgPrint

; 473  : 
; 474  : 	return STATUS_SUCCESS;

  00366	33 c0		 xor	 eax, eax
$LN2@TCCreateDe:

; 475  : }

  00368	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00370	48 33 cc	 xor	 rcx, rsp
  00373	e8 00 00 00 00	 call	 __security_check_cookie
  00378	48 81 c4 20 01
	00 00		 add	 rsp, 288		; 00000120H
  0037f	5f		 pop	 rdi
  00380	c3		 ret	 0
TCCreateDeviceObject ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	TCCreateRootDeviceObject
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCCreateRootDeviceObject DD imagerel $LN9
	DD	imagerel $LN9+780
	DD	imagerel $unwind$TCCreateRootDeviceObject
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCCreateRootDeviceObject DD 021e19H
	DD	02b010cH
	DD	imagerel __GSHandlerCheck
	DD	0148H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT TCCreateRootDeviceObject
INIT	SEGMENT
ntUnicodeString$ = 64
ntname$ = 96
bRootExtension$ = 160
Win32NameString$ = 168
DeviceObject$ = 184
dosname$ = 192
ntStatus$ = 256
tv72 = 260
tv74 = 264
tv75 = 272
tv76 = 280
tv77 = 288
tv82 = 296
tv83 = 304
tv84 = 312
tv85 = 320
__$ArrayPad$ = 328
DriverObject$ = 352
TCCreateRootDeviceObject PROC				; COMDAT

; 354  : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 355  : 	UNICODE_STRING Win32NameString, ntUnicodeString;
; 356  : 	WCHAR dosname[32], ntname[32];
; 357  : 	PDEVICE_OBJECT DeviceObject;
; 358  : 	NTSTATUS ntStatus;
; 359  : 	BOOL *bRootExtension;
; 360  : 
; 361  : 	Dump ("TCCreateRootDeviceObject BEGIN\n");

  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@NGANHIBM@TCCreateRootDeviceObject?5BEGIN?6?$AA@PBOPGDP@
  00025	e8 00 00 00 00	 call	 DbgPrint

; 362  : 	ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

  0002a	e8 00 00 00 00	 call	 KeGetCurrentIrql
  0002f	0f b6 c0	 movzx	 eax, al
  00032	85 c0		 test	 eax, eax
  00034	74 2a		 je	 SHORT $LN5@TCCreateRo@2
  00036	45 33 c9	 xor	 r9d, r9d
  00039	41 b8 6a 01 00
	00		 mov	 r8d, 362		; 0000016aH
  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@PBOPGDP@
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@KKOENIAD@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5PASSIVE_LE@PBOPGDP@
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  00053	c7 84 24 04 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv72[rsp], 0
  0005e	eb 0b		 jmp	 SHORT $LN6@TCCreateRo@2
$LN5@TCCreateRo@2:
  00060	c7 84 24 04 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv72[rsp], 1
$LN6@TCCreateRo@2:

; 363  : 
; 364  : 	wcscpy (dosname, (LPWSTR) DOS_ROOT_PREFIX);

  0006b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CM@KJDLPNIG@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@
  00072	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv74[rsp], rax
  0007a	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR dosname$[rsp]
  00082	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv75[rsp], rax
  0008a	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR tv75[rsp]
  00092	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv76[rsp], rax
$LN7@TCCreateRo@2:
  0009a	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR tv74[rsp]
  000a2	0f b7 00	 movzx	 eax, WORD PTR [rax]
  000a5	66 89 84 24 20
	01 00 00	 mov	 WORD PTR tv77[rsp], ax
  000ad	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR tv75[rsp]
  000b5	0f b7 84 24 20
	01 00 00	 movzx	 eax, WORD PTR tv77[rsp]
  000bd	66 89 01	 mov	 WORD PTR [rcx], ax
  000c0	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR tv74[rsp]
  000c8	48 83 c0 02	 add	 rax, 2
  000cc	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv74[rsp], rax
  000d4	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR tv75[rsp]
  000dc	48 83 c0 02	 add	 rax, 2
  000e0	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv75[rsp], rax
  000e8	66 83 bc 24 20
	01 00 00 00	 cmp	 WORD PTR tv77[rsp], 0
  000f1	75 a7		 jne	 SHORT $LN7@TCCreateRo@2

; 365  : 	wcscpy (ntname, (LPWSTR) NT_ROOT_PREFIX);

  000f3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@
  000fa	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv82[rsp], rax
  00102	48 8d 44 24 60	 lea	 rax, QWORD PTR ntname$[rsp]
  00107	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv83[rsp], rax
  0010f	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tv83[rsp]
  00117	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv84[rsp], rax
$LN8@TCCreateRo@2:
  0011f	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR tv82[rsp]
  00127	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0012a	66 89 84 24 40
	01 00 00	 mov	 WORD PTR tv85[rsp], ax
  00132	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tv83[rsp]
  0013a	0f b7 84 24 40
	01 00 00	 movzx	 eax, WORD PTR tv85[rsp]
  00142	66 89 01	 mov	 WORD PTR [rcx], ax
  00145	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR tv82[rsp]
  0014d	48 83 c0 02	 add	 rax, 2
  00151	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv82[rsp], rax
  00159	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tv83[rsp]
  00161	48 83 c0 02	 add	 rax, 2
  00165	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv83[rsp], rax
  0016d	66 83 bc 24 40
	01 00 00 00	 cmp	 WORD PTR tv85[rsp], 0
  00176	75 a7		 jne	 SHORT $LN8@TCCreateRo@2

; 366  : 	RtlInitUnicodeString (&ntUnicodeString, ntname);

  00178	48 8d 54 24 60	 lea	 rdx, QWORD PTR ntname$[rsp]
  0017d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ntUnicodeString$[rsp]
  00182	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 367  : 	RtlInitUnicodeString (&Win32NameString, dosname);

  00188	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR dosname$[rsp]
  00190	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR Win32NameString$[rsp]
  00198	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 368  : 
; 369  : 	Dump ("Creating root device nt=%ls dos=%ls\n", ntname, dosname);

  0019e	4c 8d 84 24 c0
	00 00 00	 lea	 r8, QWORD PTR dosname$[rsp]
  001a6	48 8d 54 24 60	 lea	 rdx, QWORD PTR ntname$[rsp]
  001ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@KMOPKHLE@Creating?5root?5device?5nt?$DN?$CFls?5dos?$DN@PBOPGDP@
  001b2	e8 00 00 00 00	 call	 DbgPrint

; 370  : 	
; 371  : 	ntStatus = IoCreateDevice (
; 372  : 					  DriverObject,
; 373  : 					  sizeof (BOOL),
; 374  : 					  &ntUnicodeString,
; 375  : 					  FILE_DEVICE_UNKNOWN,
; 376  : 					  FILE_DEVICE_SECURE_OPEN,
; 377  : 					  FALSE,
; 378  : 					  &DeviceObject);

  001b7	4c 8d 9c 24 b8
	00 00 00	 lea	 r11, QWORD PTR DeviceObject$[rsp]
  001bf	4c 89 5c 24 30	 mov	 QWORD PTR [rsp+48], r11
  001c4	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  001c9	c7 44 24 20 00
	01 00 00	 mov	 DWORD PTR [rsp+32], 256	; 00000100H
  001d1	41 b9 22 00 00
	00		 mov	 r9d, 34			; 00000022H
  001d7	4c 8d 44 24 40	 lea	 r8, QWORD PTR ntUnicodeString$[rsp]
  001dc	ba 04 00 00 00	 mov	 edx, 4
  001e1	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR DriverObject$[rsp]
  001e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateDevice
  001ef	89 84 24 00 01
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 379  : 
; 380  : 	if (!NT_SUCCESS (ntStatus))

  001f6	83 bc 24 00 01
	00 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  001fe	7d 1f		 jge	 SHORT $LN2@TCCreateRo@2

; 381  : 	{
; 382  : 		Dump ("TCCreateRootDeviceObject NTSTATUS = 0x%08x END\n", ntStatus);

  00200	8b 94 24 00 01
	00 00		 mov	 edx, DWORD PTR ntStatus$[rsp]
  00207	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DA@OJGNPLJ@TCCreateRootDeviceObject?5NTSTATU@PBOPGDP@
  0020e	e8 00 00 00 00	 call	 DbgPrint

; 383  : 		return ntStatus;/* Failed to create DeviceObject */

  00213	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR ntStatus$[rsp]
  0021a	e9 d5 00 00 00	 jmp	 $LN3@TCCreateRo@2
$LN2@TCCreateRo@2:

; 384  : 	}
; 385  : 
; 386  : 	DeviceObject->Flags |= DO_DIRECT_IO;

  0021f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  00227	8b 48 30	 mov	 ecx, DWORD PTR [rax+48]
  0022a	83 c9 10	 or	 ecx, 16
  0022d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  00235	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 387  : 	DeviceObject->AlignmentRequirement = FILE_WORD_ALIGNMENT;

  00238	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  00240	c7 80 98 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+152], 1

; 388  : 
; 389  : 	/* Setup the device extension */
; 390  : 	bRootExtension = (BOOL *) DeviceObject->DeviceExtension;

  0024a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  00252	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00256	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR bRootExtension$[rsp], rax

; 391  : 	*bRootExtension = TRUE;

  0025e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR bRootExtension$[rsp]
  00266	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 392  : 
; 393  : 	KeInitializeMutex (&RootDeviceControlMutex, 0);

  0026c	33 d2		 xor	 edx, edx
  0026e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:RootDeviceControlMutex
  00275	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeMutex

; 394  : 
; 395  : 	ntStatus = IoCreateSymbolicLink (&Win32NameString, &ntUnicodeString);

  0027b	48 8d 54 24 40	 lea	 rdx, QWORD PTR ntUnicodeString$[rsp]
  00280	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR Win32NameString$[rsp]
  00288	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateSymbolicLink
  0028e	89 84 24 00 01
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 396  : 
; 397  : 	if (!NT_SUCCESS (ntStatus))

  00295	83 bc 24 00 01
	00 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  0029d	7d 2a		 jge	 SHORT $LN1@TCCreateRo@2

; 398  : 	{
; 399  : 		Dump ("TCCreateRootDeviceObject NTSTATUS = 0x%08x END\n", ntStatus);

  0029f	8b 94 24 00 01
	00 00		 mov	 edx, DWORD PTR ntStatus$[rsp]
  002a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DA@OJGNPLJ@TCCreateRootDeviceObject?5NTSTATU@PBOPGDP@
  002ad	e8 00 00 00 00	 call	 DbgPrint

; 400  : 		IoDeleteDevice (DeviceObject);

  002b2	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  002ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteDevice

; 401  : 		return ntStatus;

  002c0	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR ntStatus$[rsp]
  002c7	eb 2b		 jmp	 SHORT $LN3@TCCreateRo@2
$LN1@TCCreateRo@2:

; 402  : 	}
; 403  : 
; 404  : 	IoRegisterShutdownNotification (DeviceObject);

  002c9	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  002d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoRegisterShutdownNotification

; 405  : 	RootDeviceObject = DeviceObject;

  002d7	4c 8b 9c 24 b8
	00 00 00	 mov	 r11, QWORD PTR DeviceObject$[rsp]
  002df	4c 89 1d 00 00
	00 00		 mov	 QWORD PTR RootDeviceObject, r11

; 406  : 
; 407  : 	Dump ("TCCreateRootDeviceObject STATUS_SUCCESS END\n");

  002e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CN@PMFMKKNC@TCCreateRootDeviceObject?5STATUS_@PBOPGDP@
  002ed	e8 00 00 00 00	 call	 DbgPrint

; 408  : 	return STATUS_SUCCESS;

  002f2	33 c0		 xor	 eax, eax
$LN3@TCCreateRo@2:

; 409  : }

  002f4	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002fc	48 33 cc	 xor	 rcx, rsp
  002ff	e8 00 00 00 00	 call	 __security_check_cookie
  00304	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  0030b	c3		 ret	 0
TCCreateRootDeviceObject ENDP
INIT	ENDS
PUBLIC	ValidateIOBufferSize
;	COMDAT pdata
pdata	SEGMENT
$pdata$ValidateIOBufferSize DD imagerel $LN11
	DD	imagerel $LN11+340
	DD	imagerel $unwind$ValidateIOBufferSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ValidateIOBufferSize DD 021401H
	DD	07010b214H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ValidateIOBufferSize
_TEXT	SEGMENT
output$ = 64
input$ = 68
irpSp$ = 72
tv68 = 80
tv71 = 84
irp$ = 112
requiredBufferSize$ = 120
type$ = 128
ValidateIOBufferSize PROC				; COMDAT

; 168  : {

$LN11:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 169  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (irp);

  00014	48 8b 4c 24 70	 mov	 rcx, QWORD PTR irp$[rsp]
  00019	e8 00 00 00 00	 call	 IoGetCurrentIrpStackLocation
  0001e	48 89 44 24 48	 mov	 QWORD PTR irpSp$[rsp], rax

; 170  : 	BOOL input = (type == ValidateInput || type == ValidateInputOutput);

  00023	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR type$[rsp], 0
  0002b	74 14		 je	 SHORT $LN7@ValidateIO
  0002d	83 bc 24 80 00
	00 00 02	 cmp	 DWORD PTR type$[rsp], 2
  00035	74 0a		 je	 SHORT $LN7@ValidateIO
  00037	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
  0003f	eb 08		 jmp	 SHORT $LN8@ValidateIO
$LN7@ValidateIO:
  00041	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
$LN8@ValidateIO:
  00049	8b 44 24 50	 mov	 eax, DWORD PTR tv68[rsp]
  0004d	89 44 24 44	 mov	 DWORD PTR input$[rsp], eax

; 171  : 	BOOL output = (type == ValidateOutput || type == ValidateInputOutput);

  00051	83 bc 24 80 00
	00 00 01	 cmp	 DWORD PTR type$[rsp], 1
  00059	74 14		 je	 SHORT $LN9@ValidateIO
  0005b	83 bc 24 80 00
	00 00 02	 cmp	 DWORD PTR type$[rsp], 2
  00063	74 0a		 je	 SHORT $LN9@ValidateIO
  00065	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
  0006d	eb 08		 jmp	 SHORT $LN10@ValidateIO
$LN9@ValidateIO:
  0006f	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv71[rsp], 1
$LN10@ValidateIO:
  00077	8b 44 24 54	 mov	 eax, DWORD PTR tv71[rsp]
  0007b	89 44 24 40	 mov	 DWORD PTR output$[rsp], eax

; 172  : 
; 173  : 	if ((input && irpSp->Parameters.DeviceIoControl.InputBufferLength < requiredBufferSize)
; 174  : 		|| (output && irpSp->Parameters.DeviceIoControl.OutputBufferLength < requiredBufferSize))

  0007f	83 7c 24 44 00	 cmp	 DWORD PTR input$[rsp], 0
  00084	74 0f		 je	 SHORT $LN2@ValidateIO
  00086	48 8b 44 24 48	 mov	 rax, QWORD PTR irpSp$[rsp]
  0008b	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0008e	48 3b 44 24 78	 cmp	 rax, QWORD PTR requiredBufferSize$[rsp]
  00093	72 1a		 jb	 SHORT $LN3@ValidateIO
$LN2@ValidateIO:
  00095	83 7c 24 40 00	 cmp	 DWORD PTR output$[rsp], 0
  0009a	0f 84 86 00 00
	00		 je	 $LN4@ValidateIO
  000a0	48 8b 44 24 48	 mov	 rax, QWORD PTR irpSp$[rsp]
  000a5	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000a8	48 3b 44 24 78	 cmp	 rax, QWORD PTR requiredBufferSize$[rsp]
  000ad	73 77		 jae	 SHORT $LN4@ValidateIO
$LN3@ValidateIO:

; 175  : 	{
; 176  : 		Dump ("STATUS_BUFFER_TOO_SMALL ioctl=0x%x,%d in=%d out=%d reqsize=%d insize=%d outsize=%d\n", (int) (irpSp->Parameters.DeviceIoControl.IoControlCode >> 16), (int) ((irpSp->Parameters.DeviceIoControl.IoControlCode & 0x1FFF) >> 2), input, output, requiredBufferSize, irpSp->Parameters.DeviceIoControl.InputBufferLength, irpSp->Parameters.DeviceIoControl.OutputBufferLength);

  000af	48 8b 44 24 48	 mov	 rax, QWORD PTR irpSp$[rsp]
  000b4	44 8b 40 18	 mov	 r8d, DWORD PTR [rax+24]
  000b8	41 81 e0 ff 1f
	00 00		 and	 r8d, 8191		; 00001fffH
  000bf	41 c1 e8 02	 shr	 r8d, 2
  000c3	48 8b 44 24 48	 mov	 rax, QWORD PTR irpSp$[rsp]
  000c8	8b 50 18	 mov	 edx, DWORD PTR [rax+24]
  000cb	c1 ea 10	 shr	 edx, 16
  000ce	48 8b 44 24 48	 mov	 rax, QWORD PTR irpSp$[rsp]
  000d3	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000d6	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  000da	48 8b 44 24 48	 mov	 rax, QWORD PTR irpSp$[rsp]
  000df	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000e2	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000e6	48 8b 44 24 78	 mov	 rax, QWORD PTR requiredBufferSize$[rsp]
  000eb	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000f0	8b 44 24 40	 mov	 eax, DWORD PTR output$[rsp]
  000f4	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000f8	44 8b 4c 24 44	 mov	 r9d, DWORD PTR input$[rsp]
  000fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0FE@HIDEPCAO@STATUS_BUFFER_TOO_SMALL?5ioctl?$DN0x@FNODOBFM@
  00104	e8 00 00 00 00	 call	 DbgPrint

; 177  : 
; 178  : 		irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;

  00109	48 8b 54 24 70	 mov	 rdx, QWORD PTR irp$[rsp]
  0010e	c7 42 30 23 00
	00 c0		 mov	 DWORD PTR [rdx+48], -1073741789 ; ffffffffc0000023H

; 179  : 		irp->IoStatus.Information = 0;

  00115	48 8b 44 24 70	 mov	 rax, QWORD PTR irp$[rsp]
  0011a	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 180  : 		return FALSE;

  00122	33 c0		 xor	 eax, eax
  00124	eb 28		 jmp	 SHORT $LN5@ValidateIO
$LN4@ValidateIO:

; 181  : 	}
; 182  : 
; 183  : 	if (!input && output)

  00126	83 7c 24 44 00	 cmp	 DWORD PTR input$[rsp], 0
  0012b	75 1c		 jne	 SHORT $LN1@ValidateIO
  0012d	83 7c 24 40 00	 cmp	 DWORD PTR output$[rsp], 0
  00132	74 15		 je	 SHORT $LN1@ValidateIO

; 184  : 		memset (irp->AssociatedIrp.SystemBuffer, 0, irpSp->Parameters.DeviceIoControl.OutputBufferLength);

  00134	48 8b 44 24 48	 mov	 rax, QWORD PTR irpSp$[rsp]
  00139	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  0013c	48 8b 7c 24 70	 mov	 rdi, QWORD PTR irp$[rsp]
  00141	48 8b 7f 18	 mov	 rdi, QWORD PTR [rdi+24]
  00145	33 c0		 xor	 eax, eax
  00147	f3 aa		 rep stosb
$LN1@ValidateIO:

; 185  : 
; 186  : 	return TRUE;

  00149	b8 01 00 00 00	 mov	 eax, 1
$LN5@ValidateIO:

; 187  : }

  0014e	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00152	5f		 pop	 rdi
  00153	c3		 ret	 0
ValidateIOBufferSize ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	DriverAddDevice
;	COMDAT pdata
pdata	SEGMENT
$pdata$DriverAddDevice DD imagerel $LN8
	DD	imagerel $LN8+387
	DD	imagerel $unwind$DriverAddDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DriverAddDevice DD 022319H
	DD	01d0111H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DriverAddDevice
_TEXT	SEGMENT
nameInfoBuffer$ = 48
nameInfoSize$ = 176
nameInfo$ = 184
interfaceLinks$31429 = 192
tv72 = 200
__$ArrayPad$ = 208
driverObject$ = 240
pdo$ = 248
DriverAddDevice PROC					; COMDAT

; 112  : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 113  : #ifdef DEBUG
; 114  : 	char nameInfoBuffer[128];
; 115  : 	POBJECT_NAME_INFORMATION nameInfo = (POBJECT_NAME_INFORMATION) nameInfoBuffer;

  00023	48 8d 44 24 30	 lea	 rax, QWORD PTR nameInfoBuffer$[rsp]
  00028	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR nameInfo$[rsp], rax

; 116  : 	ULONG nameInfoSize;
; 117  : 	Dump ("AddDevice pdo=%p type=%x name=%ws\n", pdo, pdo->DeviceType, NT_SUCCESS (ObQueryNameString (pdo, nameInfo, sizeof (nameInfoBuffer), &nameInfoSize)) ? nameInfo->Name.Buffer : L"?");

  00030	4c 8d 8c 24 b0
	00 00 00	 lea	 r9, QWORD PTR nameInfoSize$[rsp]
  00038	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  0003e	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR nameInfo$[rsp]
  00046	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR pdo$[rsp]
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObQueryNameString
  00054	85 c0		 test	 eax, eax
  00056	7c 16		 jl	 SHORT $LN6@DriverAddD
  00058	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR nameInfo$[rsp]
  00060	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00064	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv72[rsp], rax
  0006c	eb 0f		 jmp	 SHORT $LN7@DriverAddD
$LN6@DriverAddD:
  0006e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_13HGPDMIBE@?$AA?$DP?$AA?$AA@FNODOBFM@
  00075	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv72[rsp], rax
$LN7@DriverAddD:
  0007d	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR tv72[rsp]
  00085	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pdo$[rsp]
  0008d	44 8b 40 48	 mov	 r8d, DWORD PTR [rax+72]
  00091	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR pdo$[rsp]
  00099	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@FCIMJPEM@AddDevice?5pdo?$DN?$CFp?5type?$DN?$CFx?5name?$DN?$CFw@FNODOBFM@
  000a0	e8 00 00 00 00	 call	 DbgPrint

; 118  : #endif
; 119  : 
; 120  : 	if (VolumeClassFilterRegistered && BootArgsValid && BootArgs.HiddenSystemPartitionStart != 0)

  000a5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR VolumeClassFilterRegistered, 0
  000ac	0f 84 a4 00 00
	00		 je	 $LN3@DriverAddD
  000b2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR BootArgsValid, 0
  000b9	0f 84 97 00 00
	00		 je	 $LN3@DriverAddD
  000bf	48 83 3d 5a 00
	00 00 00	 cmp	 QWORD PTR BootArgs+90, 0
  000c7	0f 84 89 00 00
	00		 je	 $LN3@DriverAddD

; 121  : 	{
; 122  : 		PWSTR interfaceLinks;
; 123  : 		if (NT_SUCCESS (IoGetDeviceInterfaces (&GUID_DEVINTERFACE_VOLUME, pdo, DEVICE_INTERFACE_INCLUDE_NONACTIVE, &interfaceLinks)))

  000cd	4c 8d 8c 24 c0
	00 00 00	 lea	 r9, QWORD PTR interfaceLinks$31429[rsp]
  000d5	41 b8 01 00 00
	00		 mov	 r8d, 1
  000db	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR pdo$[rsp]
  000e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:GUID_DEVINTERFACE_VOLUME
  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetDeviceInterfaces
  000f0	85 c0		 test	 eax, eax
  000f2	7c 62		 jl	 SHORT $LN2@DriverAddD

; 124  : 		{
; 125  : 			if (interfaceLinks[0] != UNICODE_NULL)

  000f4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR interfaceLinks$31429[rsp]
  000fc	0f b7 00	 movzx	 eax, WORD PTR [rax]
  000ff	85 c0		 test	 eax, eax
  00101	74 43		 je	 SHORT $LN1@DriverAddD

; 126  : 			{
; 127  : 				Dump ("Volume pdo=%p interface=%ws\n", pdo, interfaceLinks);

  00103	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR interfaceLinks$31429[rsp]
  0010b	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR pdo$[rsp]
  00113	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@PIELMKDH@Volume?5pdo?$DN?$CFp?5interface?$DN?$CFws?6?$AA@FNODOBFM@
  0011a	e8 00 00 00 00	 call	 DbgPrint

; 128  : 				ExFreePool (interfaceLinks);

  0011f	33 d2		 xor	 edx, edx
  00121	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR interfaceLinks$31429[rsp]
  00129	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 129  : 
; 130  : 				return VolumeFilterAddDevice (driverObject, pdo);

  0012f	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR pdo$[rsp]
  00137	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR driverObject$[rsp]
  0013f	e8 00 00 00 00	 call	 VolumeFilterAddDevice
  00144	eb 25		 jmp	 SHORT $LN4@DriverAddD
$LN1@DriverAddD:

; 131  : 			}
; 132  : 
; 133  : 			ExFreePool (interfaceLinks);

  00146	33 d2		 xor	 edx, edx
  00148	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR interfaceLinks$31429[rsp]
  00150	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN2@DriverAddD:
$LN3@DriverAddD:

; 134  : 		}
; 135  : 	}
; 136  : 
; 137  : 	return DriveFilterAddDevice (driverObject, pdo);

  00156	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR pdo$[rsp]
  0015e	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR driverObject$[rsp]
  00166	e8 00 00 00 00	 call	 DriveFilterAddDevice
$LN4@DriverAddD:

; 138  : }

  0016b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00173	48 33 cc	 xor	 rcx, rsp
  00176	e8 00 00 00 00	 call	 __security_check_cookie
  0017b	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  00182	c3		 ret	 0
DriverAddDevice ENDP
PUBLIC	GetDeviceSectorSize
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetDeviceSectorSize DD imagerel $LN4
	DD	imagerel $LN4+88
	DD	imagerel $unwind$GetDeviceSectorSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetDeviceSectorSize DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GetDeviceSectorSize
_TEXT	SEGMENT
geometry$ = 48
status$ = 72
deviceObject$ = 96
bytesPerSector$ = 104
GetDeviceSectorSize PROC				; COMDAT

; 3203 : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3204 : 	NTSTATUS status;
; 3205 : 	DISK_GEOMETRY geometry;
; 3206 : 
; 3207 : 	status = SendDeviceIoControlRequest (deviceObject, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &geometry, sizeof (geometry));

  0000e	c7 44 24 28 18
	00 00 00	 mov	 DWORD PTR [rsp+40], 24
  00016	48 8d 44 24 30	 lea	 rax, QWORD PTR geometry$[rsp]
  0001b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00020	45 33 c9	 xor	 r9d, r9d
  00023	45 33 c0	 xor	 r8d, r8d
  00026	ba 00 00 07 00	 mov	 edx, 458752		; 00070000H
  0002b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  00030	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  00035	89 44 24 48	 mov	 DWORD PTR status$[rsp], eax

; 3208 : 
; 3209 : 	if (!NT_SUCCESS (status))

  00039	83 7c 24 48 00	 cmp	 DWORD PTR status$[rsp], 0
  0003e	7d 06		 jge	 SHORT $LN1@GetDeviceS

; 3210 : 		return status;

  00040	8b 44 24 48	 mov	 eax, DWORD PTR status$[rsp]
  00044	eb 0d		 jmp	 SHORT $LN2@GetDeviceS
$LN1@GetDeviceS:

; 3211 : 
; 3212 : 	*bytesPerSector = geometry.BytesPerSector;

  00046	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bytesPerSector$[rsp]
  0004b	8b 44 24 44	 mov	 eax, DWORD PTR geometry$[rsp+20]
  0004f	89 01		 mov	 DWORD PTR [rcx], eax

; 3213 : 	return STATUS_SUCCESS;

  00051	33 c0		 xor	 eax, eax
$LN2@GetDeviceS:

; 3214 : }

  00053	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00057	c3		 ret	 0
GetDeviceSectorSize ENDP
_TEXT	ENDS
PUBLIC	IsAccessibleByUser
;	COMDAT pdata
pdata	SEGMENT
$pdata$IsAccessibleByUser DD imagerel $LN8
	DD	imagerel $LN8+326
	DD	imagerel $unwind$IsAccessibleByUser
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IsAccessibleByUser DD 021001H
	DD	0190110H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT IsAccessibleByUser
_TEXT	SEGMENT
fileHandle$ = 96
ioStatusBlock$ = 104
status$ = 120
fileObjAttributes$ = 128
tv73 = 176
tv85 = 180
objectFileName$ = 208
readOnly$ = 216
IsAccessibleByUser PROC					; COMDAT

; 2894 : {

$LN8:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 2895 : 	OBJECT_ATTRIBUTES fileObjAttributes;
; 2896 : 	IO_STATUS_BLOCK ioStatusBlock;
; 2897 : 	HANDLE fileHandle;
; 2898 : 	NTSTATUS status;
; 2899 : 
; 2900 : 	ASSERT (!IoIsSystemThread (PsGetCurrentThread()));

  00010	e8 00 00 00 00	 call	 PsGetCurrentThread
  00015	48 8b c8	 mov	 rcx, rax
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoIsSystemThread
  0001e	0f b6 c0	 movzx	 eax, al
  00021	85 c0		 test	 eax, eax
  00023	74 2a		 je	 SHORT $LN4@IsAccessib
  00025	45 33 c9	 xor	 r9d, r9d
  00028	41 b8 54 0b 00
	00		 mov	 r8d, 2900		; 00000b54H
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CJ@KBGIGBCB@?$CBIoIsSystemThread?5?$CIPsGetCurrentT@FNODOBFM@
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  00042	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv73[rsp], 0
  0004d	eb 0b		 jmp	 SHORT $LN5@IsAccessib
$LN4@IsAccessib:
  0004f	c7 84 24 b0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv73[rsp], 1
$LN5@IsAccessib:

; 2901 : 
; 2902 : 	InitializeObjectAttributes (&fileObjAttributes, objectFileName, OBJ_CASE_INSENSITIVE | OBJ_FORCE_ACCESS_CHECK | OBJ_KERNEL_HANDLE, NULL, NULL);

  0005a	c7 84 24 80 00
	00 00 30 00 00
	00		 mov	 DWORD PTR fileObjAttributes$[rsp], 48 ; 00000030H
  00065	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR fileObjAttributes$[rsp+8], 0
  00071	c7 84 24 98 00
	00 00 40 06 00
	00		 mov	 DWORD PTR fileObjAttributes$[rsp+24], 1600 ; 00000640H
  0007c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR objectFileName$[rsp]
  00084	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR fileObjAttributes$[rsp+16], rax
  0008c	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR fileObjAttributes$[rsp+32], 0
  00098	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR fileObjAttributes$[rsp+40], 0

; 2903 : 	
; 2904 : 	status = ZwCreateFile (&fileHandle,
; 2905 : 		readOnly ? GENERIC_READ : GENERIC_READ | GENERIC_WRITE,
; 2906 : 		&fileObjAttributes,
; 2907 : 		&ioStatusBlock,
; 2908 : 		NULL,
; 2909 : 		FILE_ATTRIBUTE_NORMAL,
; 2910 : 		FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
; 2911 : 		FILE_OPEN,
; 2912 : 		FILE_SYNCHRONOUS_IO_NONALERT,
; 2913 : 		NULL,
; 2914 : 		0);

  000a4	83 bc 24 d8 00
	00 00 00	 cmp	 DWORD PTR readOnly$[rsp], 0
  000ac	74 0d		 je	 SHORT $LN6@IsAccessib
  000ae	c7 84 24 b4 00
	00 00 00 00 00
	80		 mov	 DWORD PTR tv85[rsp], -2147483648 ; 80000000H
  000b9	eb 0b		 jmp	 SHORT $LN7@IsAccessib
$LN6@IsAccessib:
  000bb	c7 84 24 b4 00
	00 00 00 00 00
	c0		 mov	 DWORD PTR tv85[rsp], -1073741824 ; c0000000H
$LN7@IsAccessib:
  000c6	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR [rsp+80], 0
  000ce	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR [rsp+72], 0
  000d7	c7 44 24 40 20
	00 00 00	 mov	 DWORD PTR [rsp+64], 32	; 00000020H
  000df	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR [rsp+56], 1
  000e7	c7 44 24 30 07
	00 00 00	 mov	 DWORD PTR [rsp+48], 7
  000ef	c7 44 24 28 80
	00 00 00	 mov	 DWORD PTR [rsp+40], 128	; 00000080H
  000f7	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00100	4c 8d 4c 24 68	 lea	 r9, QWORD PTR ioStatusBlock$[rsp]
  00105	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR fileObjAttributes$[rsp]
  0010d	8b 94 24 b4 00
	00 00		 mov	 edx, DWORD PTR tv85[rsp]
  00114	48 8d 4c 24 60	 lea	 rcx, QWORD PTR fileHandle$[rsp]
  00119	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwCreateFile
  0011f	89 44 24 78	 mov	 DWORD PTR status$[rsp], eax

; 2915 : 
; 2916 : 	if (NT_SUCCESS (status))

  00123	83 7c 24 78 00	 cmp	 DWORD PTR status$[rsp], 0
  00128	7c 12		 jl	 SHORT $LN1@IsAccessib

; 2917 : 	{
; 2918 : 		ZwClose (fileHandle);

  0012a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fileHandle$[rsp]
  0012f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 2919 : 		return TRUE;

  00135	b8 01 00 00 00	 mov	 eax, 1
  0013a	eb 02		 jmp	 SHORT $LN2@IsAccessib
$LN1@IsAccessib:

; 2920 : 	}
; 2921 : 
; 2922 : 	return FALSE;

  0013c	33 c0		 xor	 eax, eax
$LN2@IsAccessib:

; 2923 : }

  0013e	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00145	c3		 ret	 0
IsAccessibleByUser ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	MountManagerUnmount
;	COMDAT pdata
pdata	SEGMENT
$pdata$MountManagerUnmount DD imagerel $LN3
	DD	imagerel $LN3+245
	DD	imagerel $unwind$MountManagerUnmount
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MountManagerUnmount DD 031e19H
	DD	052010cH
	DD	07005H
	DD	imagerel __GSHandlerCheck
	DD	0280H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT MountManagerUnmount
_TEXT	SEGMENT
in$ = 48
buf$ = 64
ntStatus$ = 320
out$ = 336
__$ArrayPad$ = 640
nDosDriveNo$ = 672
MountManagerUnmount PROC				; COMDAT

; 2521 : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 81 ec 90 02
	00 00		 sub	 rsp, 656		; 00000290H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 80
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2522 : 	NTSTATUS ntStatus; 
; 2523 : 	char buf[256], out[300];
; 2524 : 	PMOUNTMGR_MOUNT_POINT in = (PMOUNTMGR_MOUNT_POINT) buf;

  0001e	48 8d 44 24 40	 lea	 rax, QWORD PTR buf$[rsp]
  00023	48 89 44 24 30	 mov	 QWORD PTR in$[rsp], rax

; 2525 : 
; 2526 : 	memset (buf, 0, sizeof buf);

  00028	48 8d 7c 24 40	 lea	 rdi, QWORD PTR buf$[rsp]
  0002d	33 c0		 xor	 eax, eax
  0002f	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00034	f3 aa		 rep stosb

; 2527 : 
; 2528 : 	TCGetDosNameFromNumber ((PWSTR) &in[1], nDosDriveNo);

  00036	48 8b 4c 24 30	 mov	 rcx, QWORD PTR in$[rsp]
  0003b	48 83 c1 18	 add	 rcx, 24
  0003f	8b 94 24 a0 02
	00 00		 mov	 edx, DWORD PTR nDosDriveNo$[rsp]
  00046	e8 00 00 00 00	 call	 TCGetDosNameFromNumber

; 2529 : 
; 2530 : 	// Only symbolic link can be deleted with IOCTL_MOUNTMGR_DELETE_POINTS. If any other entry is specified, the mount manager will ignore subsequent IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION for the same volume ID.
; 2531 : 	in->SymbolicLinkNameOffset = sizeof (MOUNTMGR_MOUNT_POINT);

  0004b	48 8b 54 24 30	 mov	 rdx, QWORD PTR in$[rsp]
  00050	c7 02 18 00 00
	00		 mov	 DWORD PTR [rdx], 24

; 2532 : 	in->SymbolicLinkNameLength = (USHORT) wcslen ((PWCHAR) &in[1]) * 2;

  00056	48 8b 7c 24 30	 mov	 rdi, QWORD PTR in$[rsp]
  0005b	48 83 c7 18	 add	 rdi, 24
  0005f	33 c0		 xor	 eax, eax
  00061	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00068	66 f2 af	 repne scasw
  0006b	48 f7 d1	 not	 rcx
  0006e	48 83 e9 01	 sub	 rcx, 1
  00072	0f b7 c9	 movzx	 ecx, cx
  00075	d1 e1		 shl	 ecx, 1
  00077	48 8b 44 24 30	 mov	 rax, QWORD PTR in$[rsp]
  0007c	66 89 48 04	 mov	 WORD PTR [rax+4], cx

; 2533 : 
; 2534 : 	ntStatus = TCDeviceIoControl (MOUNTMGR_DEVICE_NAME, IOCTL_MOUNTMGR_DELETE_POINTS,
; 2535 : 		in, sizeof(MOUNTMGR_MOUNT_POINT) + in->SymbolicLinkNameLength, out, sizeof out);

  00080	48 8b 44 24 30	 mov	 rax, QWORD PTR in$[rsp]
  00085	0f b7 48 04	 movzx	 ecx, WORD PTR [rax+4]
  00089	48 83 c1 18	 add	 rcx, 24
  0008d	c7 44 24 28 2c
	01 00 00	 mov	 DWORD PTR [rsp+40], 300	; 0000012cH
  00095	48 8d 84 24 50
	01 00 00	 lea	 rax, QWORD PTR out$[rsp]
  0009d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a2	44 8b c9	 mov	 r9d, ecx
  000a5	4c 8b 44 24 30	 mov	 r8, QWORD PTR in$[rsp]
  000aa	ba 04 c0 6d 00	 mov	 edx, 7192580		; 006dc004H
  000af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
  000b6	e8 00 00 00 00	 call	 TCDeviceIoControl
  000bb	89 84 24 40 01
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 2536 : 
; 2537 : 	Dump ("IOCTL_MOUNTMGR_DELETE_POINTS returned 0x%08x\n", ntStatus);

  000c2	8b 94 24 40 01
	00 00		 mov	 edx, DWORD PTR ntStatus$[rsp]
  000c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CO@FHIENMIJ@IOCTL_MOUNTMGR_DELETE_POINTS?5ret@FNODOBFM@
  000d0	e8 00 00 00 00	 call	 DbgPrint

; 2538 : 
; 2539 : 	return ntStatus;

  000d5	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR ntStatus$[rsp]

; 2540 : }

  000dc	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000e4	48 33 cc	 xor	 rcx, rsp
  000e7	e8 00 00 00 00	 call	 __security_check_cookie
  000ec	48 81 c4 90 02
	00 00		 add	 rsp, 656		; 00000290H
  000f3	5f		 pop	 rdi
  000f4	c3		 ret	 0
MountManagerUnmount ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	MountManagerMount
;	COMDAT pdata
pdata	SEGMENT
$pdata$MountManagerMount DD imagerel $LN4
	DD	imagerel $LN4+706
	DD	imagerel $unwind$MountManagerMount
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MountManagerMount DD 031f19H
	DD	06e010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	0368H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT MountManagerMount
_TEXT	SEGMENT
point$ = 48
in$ = 56
arrVolume$ = 80
buf$ = 592
devName$ = 800
ntStatus$ = 816
symName$ = 824
tv74 = 840
tv76 = 848
tv77 = 856
tv78 = 864
__$ArrayPad$ = 872
mount$ = 896
MountManagerMount PROC					; COMDAT

; 2484 : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec 70 03
	00 00		 sub	 rsp, 880		; 00000370H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 68
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2485 : 	NTSTATUS ntStatus; 
; 2486 : 	WCHAR arrVolume[256];
; 2487 : 	char buf[200];
; 2488 : 	PMOUNTMGR_TARGET_NAME in = (PMOUNTMGR_TARGET_NAME) buf;

  0001f	48 8d 84 24 50
	02 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  00027	48 89 44 24 38	 mov	 QWORD PTR in$[rsp], rax

; 2489 : 	PMOUNTMGR_CREATE_POINT_INPUT point = (PMOUNTMGR_CREATE_POINT_INPUT) buf;

  0002c	48 8d 84 24 50
	02 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  00034	48 89 44 24 30	 mov	 QWORD PTR point$[rsp], rax

; 2490 : 	UNICODE_STRING symName, devName;
; 2491 : 
; 2492 : 	TCGetNTNameFromNumber (arrVolume, mount->nDosDriveNo);

  00039	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  00041	8b 90 64 02 00
	00		 mov	 edx, DWORD PTR [rax+612]
  00047	48 8d 4c 24 50	 lea	 rcx, QWORD PTR arrVolume$[rsp]
  0004c	e8 00 00 00 00	 call	 TCGetNTNameFromNumber

; 2493 : 	in->DeviceNameLength = (USHORT) wcslen (arrVolume) * 2;

  00051	33 c0		 xor	 eax, eax
  00053	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  0005a	48 8d 7c 24 50	 lea	 rdi, QWORD PTR arrVolume$[rsp]
  0005f	66 f2 af	 repne scasw
  00062	48 f7 d1	 not	 rcx
  00065	48 83 e9 01	 sub	 rcx, 1
  00069	0f b7 c9	 movzx	 ecx, cx
  0006c	d1 e1		 shl	 ecx, 1
  0006e	48 8b 44 24 38	 mov	 rax, QWORD PTR in$[rsp]
  00073	66 89 08	 mov	 WORD PTR [rax], cx

; 2494 : 	wcscpy(in->DeviceName, arrVolume);

  00076	48 8d 44 24 50	 lea	 rax, QWORD PTR arrVolume$[rsp]
  0007b	48 89 84 24 48
	03 00 00	 mov	 QWORD PTR tv74[rsp], rax
  00083	48 8b 44 24 38	 mov	 rax, QWORD PTR in$[rsp]
  00088	48 83 c0 02	 add	 rax, 2
  0008c	48 89 84 24 50
	03 00 00	 mov	 QWORD PTR tv76[rsp], rax
  00094	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR tv76[rsp]
  0009c	48 89 84 24 58
	03 00 00	 mov	 QWORD PTR tv77[rsp], rax
$LN3@MountManag:
  000a4	48 8b 84 24 48
	03 00 00	 mov	 rax, QWORD PTR tv74[rsp]
  000ac	0f b7 00	 movzx	 eax, WORD PTR [rax]
  000af	66 89 84 24 60
	03 00 00	 mov	 WORD PTR tv78[rsp], ax
  000b7	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR tv76[rsp]
  000bf	0f b7 84 24 60
	03 00 00	 movzx	 eax, WORD PTR tv78[rsp]
  000c7	66 89 01	 mov	 WORD PTR [rcx], ax
  000ca	48 8b 84 24 48
	03 00 00	 mov	 rax, QWORD PTR tv74[rsp]
  000d2	48 83 c0 02	 add	 rax, 2
  000d6	48 89 84 24 48
	03 00 00	 mov	 QWORD PTR tv74[rsp], rax
  000de	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR tv76[rsp]
  000e6	48 83 c0 02	 add	 rax, 2
  000ea	48 89 84 24 50
	03 00 00	 mov	 QWORD PTR tv76[rsp], rax
  000f2	66 83 bc 24 60
	03 00 00 00	 cmp	 WORD PTR tv78[rsp], 0
  000fb	75 a7		 jne	 SHORT $LN3@MountManag

; 2495 : 
; 2496 : 	ntStatus = TCDeviceIoControl (MOUNTMGR_DEVICE_NAME, IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION,
; 2497 : 		in, (ULONG) (sizeof (in->DeviceNameLength) + wcslen (arrVolume) * 2), 0, 0);

  000fd	33 c0		 xor	 eax, eax
  000ff	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00106	48 8d 7c 24 50	 lea	 rdi, QWORD PTR arrVolume$[rsp]
  0010b	66 f2 af	 repne scasw
  0010e	48 f7 d1	 not	 rcx
  00111	48 83 e9 01	 sub	 rcx, 1
  00115	48 8d 44 09 02	 lea	 rax, QWORD PTR [rcx+rcx+2]
  0011a	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00122	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0012b	44 8b c8	 mov	 r9d, eax
  0012e	4c 8b 44 24 38	 mov	 r8, QWORD PTR in$[rsp]
  00133	ba 2c 40 6d 00	 mov	 edx, 7159852		; 006d402cH
  00138	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
  0013f	e8 00 00 00 00	 call	 TCDeviceIoControl
  00144	89 84 24 30 03
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 2498 : 
; 2499 : 	memset (buf, 0, sizeof buf);

  0014b	48 8d bc 24 50
	02 00 00	 lea	 rdi, QWORD PTR buf$[rsp]
  00153	33 c0		 xor	 eax, eax
  00155	b9 c8 00 00 00	 mov	 ecx, 200		; 000000c8H
  0015a	f3 aa		 rep stosb

; 2500 : 	TCGetDosNameFromNumber ((PWSTR) &point[1], mount->nDosDriveNo);

  0015c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR point$[rsp]
  00161	48 83 c1 08	 add	 rcx, 8
  00165	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  0016d	8b 90 64 02 00
	00		 mov	 edx, DWORD PTR [rax+612]
  00173	e8 00 00 00 00	 call	 TCGetDosNameFromNumber

; 2501 : 
; 2502 : 	point->SymbolicLinkNameOffset = sizeof (MOUNTMGR_CREATE_POINT_INPUT);

  00178	ba 08 00 00 00	 mov	 edx, 8
  0017d	48 8b 44 24 30	 mov	 rax, QWORD PTR point$[rsp]
  00182	66 89 10	 mov	 WORD PTR [rax], dx

; 2503 : 	point->SymbolicLinkNameLength = (USHORT) wcslen ((PWSTR) &point[1]) * 2;

  00185	48 8b 7c 24 30	 mov	 rdi, QWORD PTR point$[rsp]
  0018a	48 83 c7 08	 add	 rdi, 8
  0018e	33 c0		 xor	 eax, eax
  00190	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00197	66 f2 af	 repne scasw
  0019a	48 f7 d1	 not	 rcx
  0019d	48 83 e9 01	 sub	 rcx, 1
  001a1	0f b7 c9	 movzx	 ecx, cx
  001a4	d1 e1		 shl	 ecx, 1
  001a6	48 8b 44 24 30	 mov	 rax, QWORD PTR point$[rsp]
  001ab	66 89 48 02	 mov	 WORD PTR [rax+2], cx

; 2504 : 
; 2505 : 	RtlInitUnicodeString(&symName, (PWSTR) (buf + point->SymbolicLinkNameOffset));

  001af	48 8b 44 24 30	 mov	 rax, QWORD PTR point$[rsp]
  001b4	0f b7 00	 movzx	 eax, WORD PTR [rax]
  001b7	48 8d 94 04 50
	02 00 00	 lea	 rdx, QWORD PTR buf$[rsp+rax]
  001bf	48 8d 8c 24 38
	03 00 00	 lea	 rcx, QWORD PTR symName$[rsp]
  001c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2506 : 
; 2507 : 	point->DeviceNameOffset = point->SymbolicLinkNameOffset + point->SymbolicLinkNameLength;

  001cd	48 8b 54 24 30	 mov	 rdx, QWORD PTR point$[rsp]
  001d2	0f b7 0a	 movzx	 ecx, WORD PTR [rdx]
  001d5	48 8b 44 24 30	 mov	 rax, QWORD PTR point$[rsp]
  001da	0f b7 40 02	 movzx	 eax, WORD PTR [rax+2]
  001de	03 c8		 add	 ecx, eax
  001e0	48 8b 44 24 30	 mov	 rax, QWORD PTR point$[rsp]
  001e5	66 89 48 04	 mov	 WORD PTR [rax+4], cx

; 2508 : 	TCGetNTNameFromNumber ((PWSTR) (buf + point->DeviceNameOffset), mount->nDosDriveNo);

  001e9	48 8b 44 24 30	 mov	 rax, QWORD PTR point$[rsp]
  001ee	0f b7 40 04	 movzx	 eax, WORD PTR [rax+4]
  001f2	48 8d 8c 04 50
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp+rax]
  001fa	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  00202	8b 90 64 02 00
	00		 mov	 edx, DWORD PTR [rax+612]
  00208	e8 00 00 00 00	 call	 TCGetNTNameFromNumber

; 2509 : 	point->DeviceNameLength = (USHORT) wcslen ((PWSTR) (buf + point->DeviceNameOffset)) * 2;

  0020d	48 8b 54 24 30	 mov	 rdx, QWORD PTR point$[rsp]
  00212	0f b7 42 04	 movzx	 eax, WORD PTR [rdx+4]
  00216	48 8d bc 04 50
	02 00 00	 lea	 rdi, QWORD PTR buf$[rsp+rax]
  0021e	33 c0		 xor	 eax, eax
  00220	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00227	66 f2 af	 repne scasw
  0022a	48 f7 d1	 not	 rcx
  0022d	48 83 e9 01	 sub	 rcx, 1
  00231	0f b7 c9	 movzx	 ecx, cx
  00234	d1 e1		 shl	 ecx, 1
  00236	48 8b 44 24 30	 mov	 rax, QWORD PTR point$[rsp]
  0023b	66 89 48 06	 mov	 WORD PTR [rax+6], cx

; 2510 : 
; 2511 : 	RtlInitUnicodeString(&devName, (PWSTR) (buf + point->DeviceNameOffset));

  0023f	48 8b 44 24 30	 mov	 rax, QWORD PTR point$[rsp]
  00244	0f b7 40 04	 movzx	 eax, WORD PTR [rax+4]
  00248	48 8d 94 04 50
	02 00 00	 lea	 rdx, QWORD PTR buf$[rsp+rax]
  00250	48 8d 8c 24 20
	03 00 00	 lea	 rcx, QWORD PTR devName$[rsp]
  00258	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2512 : 
; 2513 : 	ntStatus = TCDeviceIoControl (MOUNTMGR_DEVICE_NAME, IOCTL_MOUNTMGR_CREATE_POINT, point,
; 2514 : 		point->DeviceNameOffset + point->DeviceNameLength, 0, 0);

  0025e	48 8b 54 24 30	 mov	 rdx, QWORD PTR point$[rsp]
  00263	44 0f b7 4a 04	 movzx	 r9d, WORD PTR [rdx+4]
  00268	48 8b 44 24 30	 mov	 rax, QWORD PTR point$[rsp]
  0026d	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00271	44 03 c8	 add	 r9d, eax
  00274	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0027c	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00285	4c 8b 44 24 30	 mov	 r8, QWORD PTR point$[rsp]
  0028a	ba 00 c0 6d 00	 mov	 edx, 7192576		; 006dc000H
  0028f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
  00296	e8 00 00 00 00	 call	 TCDeviceIoControl
  0029b	89 84 24 30 03
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 2515 : 
; 2516 : 	return ntStatus;

  002a2	8b 84 24 30 03
	00 00		 mov	 eax, DWORD PTR ntStatus$[rsp]

; 2517 : }

  002a9	48 8b 8c 24 68
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002b1	48 33 cc	 xor	 rcx, rsp
  002b4	e8 00 00 00 00	 call	 __security_check_cookie
  002b9	48 81 c4 70 03
	00 00		 add	 rsp, 880		; 00000370H
  002c0	5f		 pop	 rdi
  002c1	c3		 ret	 0
MountManagerMount ENDP
_TEXT	ENDS
PUBLIC	TCWriteDevice
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCWriteDevice DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$TCWriteDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCWriteDevice DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT TCWriteDevice
_TEXT	SEGMENT
deviceObject$ = 64
buffer$ = 72
offset$ = 80
length$ = 88
TCWriteDevice PROC					; COMDAT

; 2405 : {

$LN3:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2406 : 	return TCReadWriteDevice (TRUE, deviceObject, buffer, offset, length);

  00018	8b 44 24 58	 mov	 eax, DWORD PTR length$[rsp]
  0001c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00020	4c 8b 4c 24 50	 mov	 r9, QWORD PTR offset$[rsp]
  00025	4c 8b 44 24 48	 mov	 r8, QWORD PTR buffer$[rsp]
  0002a	48 8b 54 24 40	 mov	 rdx, QWORD PTR deviceObject$[rsp]
  0002f	b9 01 00 00 00	 mov	 ecx, 1
  00034	e8 00 00 00 00	 call	 TCReadWriteDevice

; 2407 : }

  00039	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003d	c3		 ret	 0
TCWriteDevice ENDP
_TEXT	ENDS
PUBLIC	TCReadDevice
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCReadDevice DD imagerel $LN3
	DD	imagerel $LN3+59
	DD	imagerel $unwind$TCReadDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCReadDevice DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT TCReadDevice
_TEXT	SEGMENT
deviceObject$ = 64
buffer$ = 72
offset$ = 80
length$ = 88
TCReadDevice PROC					; COMDAT

; 2399 : {

$LN3:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2400 : 	return TCReadWriteDevice (FALSE, deviceObject, buffer, offset, length);

  00018	8b 44 24 58	 mov	 eax, DWORD PTR length$[rsp]
  0001c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00020	4c 8b 4c 24 50	 mov	 r9, QWORD PTR offset$[rsp]
  00025	4c 8b 44 24 48	 mov	 r8, QWORD PTR buffer$[rsp]
  0002a	48 8b 54 24 40	 mov	 rdx, QWORD PTR deviceObject$[rsp]
  0002f	33 c9		 xor	 ecx, ecx
  00031	e8 00 00 00 00	 call	 TCReadWriteDevice

; 2401 : }

  00036	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003a	c3		 ret	 0
TCReadDevice ENDP
_TEXT	ENDS
PUBLIC	TCUnloadDriver
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCUnloadDriver DD imagerel $LN4
	DD	imagerel $LN4+115
	DD	imagerel $unwind$TCUnloadDriver
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCUnloadDriver DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT TCUnloadDriver
_TEXT	SEGMENT
DriverObject$ = 64
TCUnloadDriver PROC					; COMDAT

; 2123 : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2124 : 	Dump ("TCUnloadDriver BEGIN\n");

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@MGFDNIAG@TCUnloadDriver?5BEGIN?6?$AA@FNODOBFM@
  00010	e8 00 00 00 00	 call	 DbgPrint

; 2125 : 
; 2126 : 	OnShutdownPending();

  00015	e8 00 00 00 00	 call	 OnShutdownPending

; 2127 : 
; 2128 : 	if (IsBootDriveMounted())

  0001a	e8 00 00 00 00	 call	 IsBootDriveMounted
  0001f	85 c0		 test	 eax, eax
  00021	74 23		 je	 SHORT $LN1@TCUnloadDr

; 2129 : 		TC_BUG_CHECK (STATUS_INVALID_DEVICE_STATE);

  00023	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  0002c	45 33 c9	 xor	 r9d, r9d
  0002f	49 c7 c0 84 01
	00 c0		 mov	 r8, -1073741436		; ffffffffc0000184H
  00036	ba 51 08 00 00	 mov	 edx, 2129		; 00000851H
  0003b	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN1@TCUnloadDr:

; 2130 : 
; 2131 : 	EncryptionThreadPoolStop();

  00046	e8 00 00 00 00	 call	 EncryptionThreadPoolStop

; 2132 : 	TCDeleteDeviceObject (RootDeviceObject, (PEXTENSION) RootDeviceObject->DeviceExtension);

  0004b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR RootDeviceObject
  00052	48 8b 52 40	 mov	 rdx, QWORD PTR [rdx+64]
  00056	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR RootDeviceObject
  0005d	e8 00 00 00 00	 call	 TCDeleteDeviceObject

; 2133 : 
; 2134 : 	Dump ("TCUnloadDriver END\n");

  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@CJGLKHCK@TCUnloadDriver?5END?6?$AA@FNODOBFM@
  00069	e8 00 00 00 00	 call	 DbgPrint
$LN3@TCUnloadDr:

; 2135 : }

  0006e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00072	c3		 ret	 0
TCUnloadDriver ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	ProcessVolumeDeviceControlIrp
;	COMDAT pdata
pdata	SEGMENT
$pdata$ProcessVolumeDeviceControlIrp DD imagerel $LN57
	DD	imagerel $LN57+3560
	DD	imagerel $unwind$ProcessVolumeDeviceControlIrp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ProcessVolumeDeviceControlIrp DD 042a19H
	DD	0b90118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	05b8H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ProcessVolumeDeviceControlIrp
_TEXT	SEGMENT
irpSp$ = 80
ntUnicodeString$31638 = 88
outputBuffer$31640 = 104
ntName$31639 = 128
outLength$31637 = 640
outputBuffer$31658 = 648
tmp$31657 = 656
volId$31656 = 672
outLength$31655 = 800
ntUnicodeString$31673 = 808
outputBuffer$31675 = 824
ntName$31674 = 832
outLength$31672 = 1344
outputBuffer$31692 = 1352
outputBuffer$31699 = 1360
outputBuffer$31706 = 1368
outputBuffer$31713 = 1376
outputBuffer$31723 = 1384
pVerifyInformation$31730 = 1392
buffer$31736 = 1400
ioStatus$31735 = 1408
offset$31741 = 1424
extents$31769 = 1432
tv67 = 1440
tv218 = 1444
tv313 = 1448
tv359 = 1456
__$ArrayPad$ = 1464
DeviceObject$ = 1504
Extension$ = 1512
Irp$ = 1520
ProcessVolumeDeviceControlIrp PROC			; COMDAT

; 496  : {

$LN57:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec c8 05
	00 00		 sub	 rsp, 1480		; 000005c8H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 b8
	05 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 497  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);

  0002a	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00032	e8 00 00 00 00	 call	 IoGetCurrentIrpStackLocation
  00037	48 89 44 24 50	 mov	 QWORD PTR irpSp$[rsp], rax

; 498  : 
; 499  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  0003c	48 8b 44 24 50	 mov	 rax, QWORD PTR irpSp$[rsp]
  00041	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00044	89 84 24 a0 05
	00 00		 mov	 DWORD PTR tv67[rsp], eax
  0004b	81 bc 24 a0 05
	00 00 5c 40 07
	00		 cmp	 DWORD PTR tv67[rsp], 475228 ; 0007405cH
  00056	0f 87 9f 00 00
	00		 ja	 $LN53@ProcessVol
  0005c	81 bc 24 a0 05
	00 00 5c 40 07
	00		 cmp	 DWORD PTR tv67[rsp], 475228 ; 0007405cH
  00067	0f 84 d4 08 00
	00		 je	 $LN23@ProcessVol
  0006d	81 bc 24 a0 05
	00 00 48 00 07
	00		 cmp	 DWORD PTR tv67[rsp], 458824 ; 00070048H
  00078	77 49		 ja	 SHORT $LN54@ProcessVol
  0007a	81 bc 24 a0 05
	00 00 48 00 07
	00		 cmp	 DWORD PTR tv67[rsp], 458824 ; 00070048H
  00085	0f 84 d7 06 00
	00		 je	 $LN27@ProcessVol
  0008b	81 bc 24 a0 05
	00 00 00 00 07
	00		 cmp	 DWORD PTR tv67[rsp], 458752 ; 00070000H
  00096	0f 84 f5 04 00
	00		 je	 $LN31@ProcessVol
  0009c	81 bc 24 a0 05
	00 00 14 00 07
	00		 cmp	 DWORD PTR tv67[rsp], 458772 ; 00070014H
  000a7	0f 84 23 09 00
	00		 je	 $LN20@ProcessVol
  000ad	81 bc 24 a0 05
	00 00 24 00 07
	00		 cmp	 DWORD PTR tv67[rsp], 458788 ; 00070024H
  000b8	0f 84 82 0b 00
	00		 je	 $LN11@ProcessVol
  000be	e9 8a 0c 00 00	 jmp	 $LN2@ProcessVol
$LN54@ProcessVol:
  000c3	81 bc 24 a0 05
	00 00 00 0c 07
	00		 cmp	 DWORD PTR tv67[rsp], 461824 ; 00070c00H
  000ce	0f 84 bd 04 00
	00		 je	 $LN31@ProcessVol
  000d4	81 bc 24 a0 05
	00 00 04 40 07
	00		 cmp	 DWORD PTR tv67[rsp], 475140 ; 00074004H
  000df	0f 84 a4 05 00
	00		 je	 $LN29@ProcessVol
  000e5	81 bc 24 a0 05
	00 00 0c 40 07
	00		 cmp	 DWORD PTR tv67[rsp], 475148 ; 0007400cH
  000f0	0f 84 54 07 00
	00		 je	 $LN25@ProcessVol
  000f6	e9 52 0c 00 00	 jmp	 $LN2@ProcessVol
$LN53@ProcessVol:
  000fb	81 bc 24 a0 05
	00 00 08 00 4d
	00		 cmp	 DWORD PTR tv67[rsp], 5046280 ; 004d0008H
  00106	77 45		 ja	 SHORT $LN55@ProcessVol
  00108	81 bc 24 a0 05
	00 00 08 00 4d
	00		 cmp	 DWORD PTR tv67[rsp], 5046280 ; 004d0008H
  00113	74 70		 je	 SHORT $LN42@ProcessVol
  00115	81 bc 24 a0 05
	00 00 00 48 07
	00		 cmp	 DWORD PTR tv67[rsp], 477184 ; 00074800H
  00120	0f 84 c6 0a 00
	00		 je	 $LN13@ProcessVol
  00126	81 bc 24 a0 05
	00 00 00 48 2d
	00		 cmp	 DWORD PTR tv67[rsp], 2967552 ; 002d4800H
  00131	0f 84 b5 0a 00
	00		 je	 $LN13@ProcessVol
  00137	81 bc 24 a0 05
	00 00 00 00 4d
	00		 cmp	 DWORD PTR tv67[rsp], 5046272 ; 004d0000H
  00142	0f 84 5b 01 00
	00		 je	 $LN38@ProcessVol
  00148	e9 00 0c 00 00	 jmp	 $LN2@ProcessVol
$LN55@ProcessVol:
  0014d	81 bc 24 a0 05
	00 00 0c 00 4d
	00		 cmp	 DWORD PTR tv67[rsp], 5046284 ; 004d000cH
  00158	0f 84 f2 02 00
	00		 je	 $LN34@ProcessVol
  0015e	81 bc 24 a0 05
	00 00 00 00 56
	00		 cmp	 DWORD PTR tv67[rsp], 5636096 ; 00560000H
  00169	0f 84 3b 0b 00
	00		 je	 $LN7@ProcessVol
  0016f	81 bc 24 a0 05
	00 00 08 c0 56
	00		 cmp	 DWORD PTR tv67[rsp], 5685256 ; 0056c008H
  0017a	0f 84 06 0b 00
	00		 je	 $LN8@ProcessVol
  00180	e9 c8 0b 00 00	 jmp	 $LN2@ProcessVol
$LN42@ProcessVol:

; 500  : 	{
; 501  : 
; 502  : 	case IOCTL_MOUNTDEV_QUERY_DEVICE_NAME:
; 503  : 		if (!ValidateIOBufferSize (Irp, sizeof (MOUNTDEV_NAME), ValidateOutput))

  00185	41 b8 01 00 00
	00		 mov	 r8d, 1
  0018b	ba 04 00 00 00	 mov	 edx, 4
  00190	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00198	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0019d	85 c0		 test	 eax, eax
  0019f	75 24		 jne	 SHORT $LN41@ProcessVol

; 504  : 		{
; 505  : 			Irp->IoStatus.Information = sizeof (MOUNTDEV_NAME);

  001a1	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  001a9	48 c7 40 38 04
	00 00 00	 mov	 QWORD PTR [rax+56], 4

; 506  : 			Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

  001b1	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  001b9	c7 40 30 05 00
	00 80		 mov	 DWORD PTR [rax+48], -2147483643 ; ffffffff80000005H

; 507  : 		}
; 508  : 		else

  001c0	e9 d9 00 00 00	 jmp	 $LN40@ProcessVol
$LN41@ProcessVol:

; 509  : 		{
; 510  : 			ULONG outLength;
; 511  : 			UNICODE_STRING ntUnicodeString;
; 512  : 			WCHAR ntName[256];
; 513  : 			PMOUNTDEV_NAME outputBuffer = (PMOUNTDEV_NAME) Irp->AssociatedIrp.SystemBuffer;

  001c5	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  001cd	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001d1	48 89 44 24 68	 mov	 QWORD PTR outputBuffer$31640[rsp], rax

; 514  : 
; 515  : 			TCGetNTNameFromNumber (ntName, Extension->nDosDriveNo);

  001d6	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  001de	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  001e1	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR ntName$31639[rsp]
  001e9	e8 00 00 00 00	 call	 TCGetNTNameFromNumber

; 516  : 			RtlInitUnicodeString (&ntUnicodeString, ntName);

  001ee	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR ntName$31639[rsp]
  001f6	48 8d 4c 24 58	 lea	 rcx, QWORD PTR ntUnicodeString$31638[rsp]
  001fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 517  : 
; 518  : 			outputBuffer->NameLength = ntUnicodeString.Length;

  00201	48 8b 54 24 68	 mov	 rdx, QWORD PTR outputBuffer$31640[rsp]
  00206	0f b7 44 24 58	 movzx	 eax, WORD PTR ntUnicodeString$31638[rsp]
  0020b	66 89 02	 mov	 WORD PTR [rdx], ax

; 519  : 			outLength = ntUnicodeString.Length + sizeof(USHORT);

  0020e	0f b7 44 24 58	 movzx	 eax, WORD PTR ntUnicodeString$31638[rsp]
  00213	48 83 c0 02	 add	 rax, 2
  00217	89 84 24 80 02
	00 00		 mov	 DWORD PTR outLength$31637[rsp], eax

; 520  : 
; 521  : 			if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < outLength)

  0021e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR irpSp$[rsp]
  00223	8b 84 24 80 02
	00 00		 mov	 eax, DWORD PTR outLength$31637[rsp]
  0022a	39 41 08	 cmp	 DWORD PTR [rcx+8], eax
  0022d	73 24		 jae	 SHORT $LN39@ProcessVol

; 522  : 			{
; 523  : 				Irp->IoStatus.Information = sizeof (MOUNTDEV_NAME);

  0022f	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00237	48 c7 40 38 04
	00 00 00	 mov	 QWORD PTR [rax+56], 4

; 524  : 				Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

  0023f	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00247	c7 40 30 05 00
	00 80		 mov	 DWORD PTR [rax+48], -2147483643 ; ffffffff80000005H

; 525  : 
; 526  : 				break;

  0024e	e9 11 0b 00 00	 jmp	 $LN43@ProcessVol
$LN39@ProcessVol:

; 527  : 			}
; 528  : 
; 529  : 			RtlCopyMemory ((PCHAR)outputBuffer->Name,ntUnicodeString.Buffer, ntUnicodeString.Length);

  00253	0f b7 4c 24 58	 movzx	 ecx, WORD PTR ntUnicodeString$31638[rsp]
  00258	48 8b 7c 24 68	 mov	 rdi, QWORD PTR outputBuffer$31640[rsp]
  0025d	48 83 c7 02	 add	 rdi, 2
  00261	48 8b 74 24 60	 mov	 rsi, QWORD PTR ntUnicodeString$31638[rsp+8]
  00266	f3 a4		 rep movsb

; 530  : 
; 531  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00268	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00270	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 532  : 			Irp->IoStatus.Information = outLength;

  00277	8b 8c 24 80 02
	00 00		 mov	 ecx, DWORD PTR outLength$31637[rsp]
  0027e	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00286	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 533  : 
; 534  : 			Dump ("name = %ls\n",ntName);

  0028a	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR ntName$31639[rsp]
  00292	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@FBJPBOL@name?5?$DN?5?$CFls?6?$AA@FNODOBFM@
  00299	e8 00 00 00 00	 call	 DbgPrint
$LN40@ProcessVol:

; 535  : 		}
; 536  : 		break;

  0029e	e9 c1 0a 00 00	 jmp	 $LN43@ProcessVol
$LN38@ProcessVol:

; 537  : 
; 538  : 	case IOCTL_MOUNTDEV_QUERY_UNIQUE_ID:
; 539  : 		if (!ValidateIOBufferSize (Irp, sizeof (MOUNTDEV_UNIQUE_ID), ValidateOutput))

  002a3	41 b8 01 00 00
	00		 mov	 r8d, 1
  002a9	ba 04 00 00 00	 mov	 edx, 4
  002ae	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  002b6	e8 00 00 00 00	 call	 ValidateIOBufferSize
  002bb	85 c0		 test	 eax, eax
  002bd	75 24		 jne	 SHORT $LN37@ProcessVol

; 540  : 		{
; 541  : 			Irp->IoStatus.Information = sizeof (MOUNTDEV_UNIQUE_ID);

  002bf	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  002c7	48 c7 40 38 04
	00 00 00	 mov	 QWORD PTR [rax+56], 4

; 542  : 			Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

  002cf	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  002d7	c7 40 30 05 00
	00 80		 mov	 DWORD PTR [rax+48], -2147483643 ; ffffffff80000005H

; 543  : 		}
; 544  : 		else

  002de	e9 68 01 00 00	 jmp	 $LN36@ProcessVol
$LN37@ProcessVol:

; 545  : 		{
; 546  : 			ULONG outLength;
; 547  : 			UCHAR volId[128], tmp[] = { 0,0 };

  002e3	c6 84 24 90 02
	00 00 00	 mov	 BYTE PTR tmp$31657[rsp], 0
  002eb	c6 84 24 91 02
	00 00 00	 mov	 BYTE PTR tmp$31657[rsp+1], 0

; 548  : 			PMOUNTDEV_UNIQUE_ID outputBuffer = (PMOUNTDEV_UNIQUE_ID) Irp->AssociatedIrp.SystemBuffer;

  002f3	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  002fb	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  002ff	48 89 84 24 88
	02 00 00	 mov	 QWORD PTR outputBuffer$31658[rsp], rax

; 549  : 
; 550  : 			strcpy (volId, TC_UNIQUE_ID_PREFIX); 

  00307	48 8d bc 24 a0
	02 00 00	 lea	 rdi, QWORD PTR volId$31656[rsp]
  0030f	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:??_C@_0BA@OLBPPLP@TrueCryptVolume?$AA@FNODOBFM@
  00316	b9 10 00 00 00	 mov	 ecx, 16
  0031b	f3 a4		 rep movsb

; 551  : 			tmp[0] = 'A' + (UCHAR) Extension->nDosDriveNo;

  0031d	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00325	0f b6 40 14	 movzx	 eax, BYTE PTR [rax+20]
  00329	83 c0 41	 add	 eax, 65			; 00000041H
  0032c	88 84 24 90 02
	00 00		 mov	 BYTE PTR tmp$31657[rsp], al

; 552  : 			strcat (volId, tmp);

  00333	48 8d bc 24 a0
	02 00 00	 lea	 rdi, QWORD PTR volId$31656[rsp]
  0033b	33 c0		 xor	 eax, eax
  0033d	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00344	f2 ae		 repne scasb
  00346	48 83 ef 01	 sub	 rdi, 1
  0034a	48 8d 94 24 90
	02 00 00	 lea	 rdx, QWORD PTR tmp$31657[rsp]
  00352	33 c9		 xor	 ecx, ecx
$LL56@ProcessVol:
  00354	0f b6 04 0a	 movzx	 eax, BYTE PTR [rdx+rcx]
  00358	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al
  0035b	48 83 c1 01	 add	 rcx, 1
  0035f	84 c0		 test	 al, al
  00361	75 f1		 jne	 SHORT $LL56@ProcessVol

; 553  : 			
; 554  : 			outputBuffer->UniqueIdLength = (USHORT) strlen (volId);

  00363	33 c0		 xor	 eax, eax
  00365	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  0036c	48 8d bc 24 a0
	02 00 00	 lea	 rdi, QWORD PTR volId$31656[rsp]
  00374	f2 ae		 repne scasb
  00376	48 f7 d1	 not	 rcx
  00379	48 83 e9 01	 sub	 rcx, 1
  0037d	48 8b 84 24 88
	02 00 00	 mov	 rax, QWORD PTR outputBuffer$31658[rsp]
  00385	66 89 08	 mov	 WORD PTR [rax], cx

; 555  : 			outLength = (ULONG) (strlen (volId) + sizeof (USHORT));

  00388	33 c0		 xor	 eax, eax
  0038a	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00391	48 8d bc 24 a0
	02 00 00	 lea	 rdi, QWORD PTR volId$31656[rsp]
  00399	f2 ae		 repne scasb
  0039b	48 f7 d1	 not	 rcx
  0039e	48 83 e9 01	 sub	 rcx, 1
  003a2	48 8b c1	 mov	 rax, rcx
  003a5	48 83 c0 02	 add	 rax, 2
  003a9	89 84 24 20 03
	00 00		 mov	 DWORD PTR outLength$31655[rsp], eax

; 556  : 
; 557  : 			if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < outLength)

  003b0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR irpSp$[rsp]
  003b5	8b 84 24 20 03
	00 00		 mov	 eax, DWORD PTR outLength$31655[rsp]
  003bc	39 41 08	 cmp	 DWORD PTR [rcx+8], eax
  003bf	73 24		 jae	 SHORT $LN35@ProcessVol

; 558  : 			{
; 559  : 				Irp->IoStatus.Information = sizeof (MOUNTDEV_UNIQUE_ID);

  003c1	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  003c9	48 c7 40 38 04
	00 00 00	 mov	 QWORD PTR [rax+56], 4

; 560  : 				Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

  003d1	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  003d9	c7 40 30 05 00
	00 80		 mov	 DWORD PTR [rax+48], -2147483643 ; ffffffff80000005H

; 561  : 				break;

  003e0	e9 7f 09 00 00	 jmp	 $LN43@ProcessVol
$LN35@ProcessVol:

; 562  : 			}
; 563  : 
; 564  : 			RtlCopyMemory ((PCHAR)outputBuffer->UniqueId, volId, strlen (volId));

  003e5	33 c0		 xor	 eax, eax
  003e7	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  003ee	48 8d bc 24 a0
	02 00 00	 lea	 rdi, QWORD PTR volId$31656[rsp]
  003f6	f2 ae		 repne scasb
  003f8	48 f7 d1	 not	 rcx
  003fb	48 83 e9 01	 sub	 rcx, 1
  003ff	48 8b bc 24 88
	02 00 00	 mov	 rdi, QWORD PTR outputBuffer$31658[rsp]
  00407	48 83 c7 02	 add	 rdi, 2
  0040b	48 8d b4 24 a0
	02 00 00	 lea	 rsi, QWORD PTR volId$31656[rsp]
  00413	f3 a4		 rep movsb

; 565  : 
; 566  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00415	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0041d	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 567  : 			Irp->IoStatus.Information = outLength;

  00424	8b 8c 24 20 03
	00 00		 mov	 ecx, DWORD PTR outLength$31655[rsp]
  0042b	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00433	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 568  : 
; 569  : 			Dump ("id = %s\n",volId);

  00437	48 8d 94 24 a0
	02 00 00	 lea	 rdx, QWORD PTR volId$31656[rsp]
  0043f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08DALLBBIL@id?5?$DN?5?$CFs?6?$AA@FNODOBFM@
  00446	e8 00 00 00 00	 call	 DbgPrint
$LN36@ProcessVol:

; 570  : 		}
; 571  : 		break;

  0044b	e9 14 09 00 00	 jmp	 $LN43@ProcessVol
$LN34@ProcessVol:

; 572  : 
; 573  : 	case IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME:
; 574  : 		{
; 575  : 			ULONG outLength;
; 576  : 			UNICODE_STRING ntUnicodeString;
; 577  : 			WCHAR ntName[256];
; 578  : 			PMOUNTDEV_SUGGESTED_LINK_NAME outputBuffer = (PMOUNTDEV_SUGGESTED_LINK_NAME) Irp->AssociatedIrp.SystemBuffer;

  00450	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00458	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0045c	48 89 84 24 38
	03 00 00	 mov	 QWORD PTR outputBuffer$31675[rsp], rax

; 579  : 
; 580  : 			if (!ValidateIOBufferSize (Irp, sizeof (MOUNTDEV_SUGGESTED_LINK_NAME), ValidateOutput))

  00464	41 b8 01 00 00
	00		 mov	 r8d, 1
  0046a	ba 06 00 00 00	 mov	 edx, 6
  0046f	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00477	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0047c	85 c0		 test	 eax, eax
  0047e	75 24		 jne	 SHORT $LN33@ProcessVol

; 581  : 			{
; 582  : 				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  00480	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00488	c7 40 30 0d 00
	00 c0		 mov	 DWORD PTR [rax+48], -1073741811 ; ffffffffc000000dH

; 583  : 				Irp->IoStatus.Information = 0;

  0048f	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00497	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 584  : 				break; 

  0049f	e9 c0 08 00 00	 jmp	 $LN43@ProcessVol
$LN33@ProcessVol:

; 585  : 			}
; 586  : 
; 587  : 			TCGetDosNameFromNumber (ntName, Extension->nDosDriveNo);

  004a4	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  004ac	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  004af	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR ntName$31674[rsp]
  004b7	e8 00 00 00 00	 call	 TCGetDosNameFromNumber

; 588  : 			RtlInitUnicodeString (&ntUnicodeString, ntName);

  004bc	48 8d 94 24 40
	03 00 00	 lea	 rdx, QWORD PTR ntName$31674[rsp]
  004c4	48 8d 8c 24 28
	03 00 00	 lea	 rcx, QWORD PTR ntUnicodeString$31673[rsp]
  004cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 589  : 
; 590  : 			outLength = FIELD_OFFSET(MOUNTDEV_SUGGESTED_LINK_NAME,Name) + ntUnicodeString.Length;

  004d2	0f b7 84 24 28
	03 00 00	 movzx	 eax, WORD PTR ntUnicodeString$31673[rsp]
  004da	83 c0 04	 add	 eax, 4
  004dd	89 84 24 40 05
	00 00		 mov	 DWORD PTR outLength$31672[rsp], eax

; 591  : 
; 592  : 			outputBuffer->UseOnlyIfThereAreNoOtherLinks = FALSE;

  004e4	48 8b 84 24 38
	03 00 00	 mov	 rax, QWORD PTR outputBuffer$31675[rsp]
  004ec	c6 00 00	 mov	 BYTE PTR [rax], 0

; 593  : 			outputBuffer->NameLength = ntUnicodeString.Length;

  004ef	48 8b 8c 24 38
	03 00 00	 mov	 rcx, QWORD PTR outputBuffer$31675[rsp]
  004f7	0f b7 84 24 28
	03 00 00	 movzx	 eax, WORD PTR ntUnicodeString$31673[rsp]
  004ff	66 89 41 02	 mov	 WORD PTR [rcx+2], ax

; 594  : 
; 595  : 			if(irpSp->Parameters.DeviceIoControl.OutputBufferLength < outLength)

  00503	48 8b 4c 24 50	 mov	 rcx, QWORD PTR irpSp$[rsp]
  00508	8b 84 24 40 05
	00 00		 mov	 eax, DWORD PTR outLength$31672[rsp]
  0050f	39 41 08	 cmp	 DWORD PTR [rcx+8], eax
  00512	73 24		 jae	 SHORT $LN32@ProcessVol

; 596  : 			{
; 597  : 				Irp->IoStatus.Information = sizeof (MOUNTDEV_SUGGESTED_LINK_NAME);

  00514	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0051c	48 c7 40 38 06
	00 00 00	 mov	 QWORD PTR [rax+56], 6

; 598  : 				Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

  00524	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0052c	c7 40 30 05 00
	00 80		 mov	 DWORD PTR [rax+48], -2147483643 ; ffffffff80000005H

; 599  : 				break;

  00533	e9 2c 08 00 00	 jmp	 $LN43@ProcessVol
$LN32@ProcessVol:

; 600  : 			}
; 601  : 
; 602  : 			RtlCopyMemory ((PCHAR)outputBuffer->Name,ntUnicodeString.Buffer, ntUnicodeString.Length);

  00538	0f b7 8c 24 28
	03 00 00	 movzx	 ecx, WORD PTR ntUnicodeString$31673[rsp]
  00540	48 8b bc 24 38
	03 00 00	 mov	 rdi, QWORD PTR outputBuffer$31675[rsp]
  00548	48 83 c7 04	 add	 rdi, 4
  0054c	48 8b b4 24 30
	03 00 00	 mov	 rsi, QWORD PTR ntUnicodeString$31673[rsp+8]
  00554	f3 a4		 rep movsb

; 603  : 		
; 604  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00556	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0055e	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 605  : 			Irp->IoStatus.Information = outLength;

  00565	8b 8c 24 40 05
	00 00		 mov	 ecx, DWORD PTR outLength$31672[rsp]
  0056c	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00574	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 606  : 
; 607  : 			Dump ("link = %ls\n",ntName);

  00578	48 8d 94 24 40
	03 00 00	 lea	 rdx, QWORD PTR ntName$31674[rsp]
  00580	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@HABEOOKA@link?5?$DN?5?$CFls?6?$AA@FNODOBFM@
  00587	e8 00 00 00 00	 call	 DbgPrint

; 608  : 		}
; 609  : 		break;

  0058c	e9 d3 07 00 00	 jmp	 $LN43@ProcessVol
$LN31@ProcessVol:

; 610  : 
; 611  : 	case IOCTL_DISK_GET_MEDIA_TYPES:
; 612  : 	case IOCTL_DISK_GET_DRIVE_GEOMETRY:
; 613  : 		/* Return the drive geometry for the disk.  Note that we
; 614  : 		   return values which were made up to suit the disk size.  */
; 615  : 		if (ValidateIOBufferSize (Irp, sizeof (DISK_GEOMETRY), ValidateOutput))

  00591	41 b8 01 00 00
	00		 mov	 r8d, 1
  00597	ba 18 00 00 00	 mov	 edx, 24
  0059c	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  005a4	e8 00 00 00 00	 call	 ValidateIOBufferSize
  005a9	85 c0		 test	 eax, eax
  005ab	0f 84 d3 00 00
	00		 je	 $LN30@ProcessVol

; 616  : 		{
; 617  : 			PDISK_GEOMETRY outputBuffer = (PDISK_GEOMETRY)
; 618  : 			Irp->AssociatedIrp.SystemBuffer;

  005b1	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  005b9	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  005bd	48 89 84 24 48
	05 00 00	 mov	 QWORD PTR outputBuffer$31692[rsp], rax

; 619  : 
; 620  : 			outputBuffer->MediaType = Extension->bRemovable ? RemovableMedia : FixedMedia;

  005c5	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  005cd	83 b8 9c 03 00
	00 00		 cmp	 DWORD PTR [rax+924], 0
  005d4	74 0d		 je	 SHORT $LN47@ProcessVol
  005d6	c7 84 24 a4 05
	00 00 0b 00 00
	00		 mov	 DWORD PTR tv218[rsp], 11
  005e1	eb 0b		 jmp	 SHORT $LN48@ProcessVol
$LN47@ProcessVol:
  005e3	c7 84 24 a4 05
	00 00 0c 00 00
	00		 mov	 DWORD PTR tv218[rsp], 12
$LN48@ProcessVol:
  005ee	48 8b 8c 24 48
	05 00 00	 mov	 rcx, QWORD PTR outputBuffer$31692[rsp]
  005f6	8b 84 24 a4 05
	00 00		 mov	 eax, DWORD PTR tv218[rsp]
  005fd	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 621  : 			outputBuffer->Cylinders.QuadPart = Extension->NumberOfCylinders;

  00600	48 8b 8c 24 48
	05 00 00	 mov	 rcx, QWORD PTR outputBuffer$31692[rsp]
  00608	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00610	48 8b 80 a8 00
	00 00		 mov	 rax, QWORD PTR [rax+168]
  00617	48 89 01	 mov	 QWORD PTR [rcx], rax

; 622  : 			outputBuffer->TracksPerCylinder = Extension->TracksPerCylinder;

  0061a	48 8b 8c 24 48
	05 00 00	 mov	 rcx, QWORD PTR outputBuffer$31692[rsp]
  00622	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  0062a	8b 80 b0 00 00
	00		 mov	 eax, DWORD PTR [rax+176]
  00630	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 623  : 			outputBuffer->SectorsPerTrack = Extension->SectorsPerTrack;

  00633	48 8b 8c 24 48
	05 00 00	 mov	 rcx, QWORD PTR outputBuffer$31692[rsp]
  0063b	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00643	8b 80 b4 00 00
	00		 mov	 eax, DWORD PTR [rax+180]
  00649	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 624  : 			outputBuffer->BytesPerSector = Extension->BytesPerSector;

  0064c	48 8b 8c 24 48
	05 00 00	 mov	 rcx, QWORD PTR outputBuffer$31692[rsp]
  00654	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  0065c	8b 80 b8 00 00
	00		 mov	 eax, DWORD PTR [rax+184]
  00662	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 625  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00665	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0066d	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 626  : 			Irp->IoStatus.Information = sizeof (DISK_GEOMETRY);

  00674	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0067c	48 c7 40 38 18
	00 00 00	 mov	 QWORD PTR [rax+56], 24
$LN30@ProcessVol:

; 627  : 		}
; 628  : 		break;

  00684	e9 db 06 00 00	 jmp	 $LN43@ProcessVol
$LN29@ProcessVol:

; 629  : 
; 630  : 	case IOCTL_DISK_GET_PARTITION_INFO:
; 631  : 		if (ValidateIOBufferSize (Irp, sizeof (PARTITION_INFORMATION), ValidateOutput))

  00689	41 b8 01 00 00
	00		 mov	 r8d, 1
  0068f	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00694	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  0069c	e8 00 00 00 00	 call	 ValidateIOBufferSize
  006a1	85 c0		 test	 eax, eax
  006a3	0f 84 b4 00 00
	00		 je	 $LN28@ProcessVol

; 632  : 		{
; 633  : 			PPARTITION_INFORMATION outputBuffer = (PPARTITION_INFORMATION)
; 634  : 			Irp->AssociatedIrp.SystemBuffer;

  006a9	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  006b1	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  006b5	48 89 84 24 50
	05 00 00	 mov	 QWORD PTR outputBuffer$31699[rsp], rax

; 635  : 
; 636  : 			outputBuffer->PartitionType = Extension->PartitionType;

  006bd	48 8b 8c 24 50
	05 00 00	 mov	 rcx, QWORD PTR outputBuffer$31699[rsp]
  006c5	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  006cd	0f b6 80 bc 00
	00 00		 movzx	 eax, BYTE PTR [rax+188]
  006d4	88 41 18	 mov	 BYTE PTR [rcx+24], al

; 637  : 			outputBuffer->BootIndicator = FALSE;

  006d7	48 8b 84 24 50
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$31699[rsp]
  006df	c6 40 19 00	 mov	 BYTE PTR [rax+25], 0

; 638  : 			outputBuffer->RecognizedPartition = TRUE;

  006e3	48 8b 84 24 50
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$31699[rsp]
  006eb	c6 40 1a 01	 mov	 BYTE PTR [rax+26], 1

; 639  : 			outputBuffer->RewritePartition = FALSE;

  006ef	48 8b 84 24 50
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$31699[rsp]
  006f7	c6 40 1b 00	 mov	 BYTE PTR [rax+27], 0

; 640  : 			outputBuffer->StartingOffset.QuadPart = Extension->BytesPerSector;

  006fb	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00703	8b 88 b8 00 00
	00		 mov	 ecx, DWORD PTR [rax+184]
  00709	48 8b 84 24 50
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$31699[rsp]
  00711	48 89 08	 mov	 QWORD PTR [rax], rcx

; 641  : 			outputBuffer->PartitionLength.QuadPart= Extension->DiskLength;

  00714	48 8b 8c 24 50
	05 00 00	 mov	 rcx, QWORD PTR outputBuffer$31699[rsp]
  0071c	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00724	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  0072b	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 642  : 			outputBuffer->HiddenSectors = 0;

  0072f	48 8b 84 24 50
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$31699[rsp]
  00737	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 643  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  0073e	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00746	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 644  : 			Irp->IoStatus.Information = sizeof (PARTITION_INFORMATION);

  0074d	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00755	48 c7 40 38 20
	00 00 00	 mov	 QWORD PTR [rax+56], 32	; 00000020H
$LN28@ProcessVol:

; 645  : 		}
; 646  : 		break;

  0075d	e9 02 06 00 00	 jmp	 $LN43@ProcessVol
$LN27@ProcessVol:

; 647  : 
; 648  : 	case IOCTL_DISK_GET_PARTITION_INFO_EX:
; 649  : 		if (ValidateIOBufferSize (Irp, sizeof (PARTITION_INFORMATION_EX), ValidateOutput))

  00762	41 b8 01 00 00
	00		 mov	 r8d, 1
  00768	ba 90 00 00 00	 mov	 edx, 144		; 00000090H
  0076d	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00775	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0077a	85 c0		 test	 eax, eax
  0077c	0f 84 c3 00 00
	00		 je	 $LN26@ProcessVol

; 650  : 		{
; 651  : 			PPARTITION_INFORMATION_EX outputBuffer = (PPARTITION_INFORMATION_EX) Irp->AssociatedIrp.SystemBuffer;

  00782	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0078a	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0078e	48 89 84 24 58
	05 00 00	 mov	 QWORD PTR outputBuffer$31706[rsp], rax

; 652  : 
; 653  : 			outputBuffer->PartitionStyle = PARTITION_STYLE_MBR;

  00796	48 8b 84 24 58
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$31706[rsp]
  0079e	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 654  : 			outputBuffer->RewritePartition = FALSE;

  007a4	48 8b 84 24 58
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$31706[rsp]
  007ac	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0

; 655  : 			outputBuffer->StartingOffset.QuadPart = Extension->BytesPerSector;

  007b0	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  007b8	8b 88 b8 00 00
	00		 mov	 ecx, DWORD PTR [rax+184]
  007be	48 8b 84 24 58
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$31706[rsp]
  007c6	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 656  : 			outputBuffer->PartitionLength.QuadPart= Extension->DiskLength;

  007ca	48 8b 8c 24 58
	05 00 00	 mov	 rcx, QWORD PTR outputBuffer$31706[rsp]
  007d2	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  007da	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  007e1	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 657  : 			outputBuffer->Mbr.PartitionType = Extension->PartitionType;

  007e5	48 8b 8c 24 58
	05 00 00	 mov	 rcx, QWORD PTR outputBuffer$31706[rsp]
  007ed	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  007f5	0f b6 80 bc 00
	00 00		 movzx	 eax, BYTE PTR [rax+188]
  007fc	88 41 20	 mov	 BYTE PTR [rcx+32], al

; 658  : 			outputBuffer->Mbr.BootIndicator = FALSE;

  007ff	48 8b 84 24 58
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$31706[rsp]
  00807	c6 40 21 00	 mov	 BYTE PTR [rax+33], 0

; 659  : 			outputBuffer->Mbr.RecognizedPartition = TRUE;

  0080b	48 8b 84 24 58
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$31706[rsp]
  00813	c6 40 22 01	 mov	 BYTE PTR [rax+34], 1

; 660  : 			outputBuffer->Mbr.HiddenSectors = 0;

  00817	48 8b 84 24 58
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$31706[rsp]
  0081f	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [rax+36], 0

; 661  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00826	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0082e	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 662  : 			Irp->IoStatus.Information = sizeof (PARTITION_INFORMATION_EX);

  00835	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0083d	48 c7 40 38 90
	00 00 00	 mov	 QWORD PTR [rax+56], 144	; 00000090H
$LN26@ProcessVol:

; 663  : 		}
; 664  : 		break;

  00845	e9 1a 05 00 00	 jmp	 $LN43@ProcessVol
$LN25@ProcessVol:

; 665  : 
; 666  : 	case IOCTL_DISK_GET_DRIVE_LAYOUT:
; 667  : 		if (ValidateIOBufferSize (Irp, sizeof (DRIVE_LAYOUT_INFORMATION), ValidateOutput))

  0084a	41 b8 01 00 00
	00		 mov	 r8d, 1
  00850	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00855	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  0085d	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00862	85 c0		 test	 eax, eax
  00864	0f 84 d2 00 00
	00		 je	 $LN24@ProcessVol

; 668  : 		{
; 669  : 			PDRIVE_LAYOUT_INFORMATION outputBuffer = (PDRIVE_LAYOUT_INFORMATION)
; 670  : 			Irp->AssociatedIrp.SystemBuffer;

  0086a	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00872	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00876	48 89 84 24 60
	05 00 00	 mov	 QWORD PTR outputBuffer$31713[rsp], rax

; 671  : 
; 672  : 			outputBuffer->PartitionCount = 1;

  0087e	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$31713[rsp]
  00886	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 673  : 			outputBuffer->Signature = 0;

  0088c	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$31713[rsp]
  00894	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 674  : 
; 675  : 			outputBuffer->PartitionEntry->PartitionType = Extension->PartitionType;

  0089b	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR outputBuffer$31713[rsp]
  008a3	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  008ab	0f b6 80 bc 00
	00 00		 movzx	 eax, BYTE PTR [rax+188]
  008b2	88 41 20	 mov	 BYTE PTR [rcx+32], al

; 676  : 			outputBuffer->PartitionEntry->BootIndicator = FALSE;

  008b5	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$31713[rsp]
  008bd	c6 40 21 00	 mov	 BYTE PTR [rax+33], 0

; 677  : 			outputBuffer->PartitionEntry->RecognizedPartition = TRUE;

  008c1	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$31713[rsp]
  008c9	c6 40 22 01	 mov	 BYTE PTR [rax+34], 1

; 678  : 			outputBuffer->PartitionEntry->RewritePartition = FALSE;

  008cd	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$31713[rsp]
  008d5	c6 40 23 00	 mov	 BYTE PTR [rax+35], 0

; 679  : 			outputBuffer->PartitionEntry->StartingOffset.QuadPart = Extension->BytesPerSector;

  008d9	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  008e1	8b 88 b8 00 00
	00		 mov	 ecx, DWORD PTR [rax+184]
  008e7	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$31713[rsp]
  008ef	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 680  : 			outputBuffer->PartitionEntry->PartitionLength.QuadPart = Extension->DiskLength;

  008f3	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR outputBuffer$31713[rsp]
  008fb	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00903	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  0090a	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 681  : 			outputBuffer->PartitionEntry->HiddenSectors = 0;

  0090e	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR outputBuffer$31713[rsp]
  00916	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 682  : 
; 683  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  0091d	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00925	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 684  : 			Irp->IoStatus.Information = sizeof (PARTITION_INFORMATION);

  0092c	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00934	48 c7 40 38 20
	00 00 00	 mov	 QWORD PTR [rax+56], 32	; 00000020H
$LN24@ProcessVol:

; 685  : 		}
; 686  : 		break;

  0093c	e9 23 04 00 00	 jmp	 $LN43@ProcessVol
$LN23@ProcessVol:

; 687  : 
; 688  : 	case IOCTL_DISK_GET_LENGTH_INFO:
; 689  : 		if (!ValidateIOBufferSize (Irp, sizeof (GET_LENGTH_INFORMATION), ValidateOutput))

  00941	41 b8 01 00 00
	00		 mov	 r8d, 1
  00947	ba 08 00 00 00	 mov	 edx, 8
  0094c	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00954	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00959	85 c0		 test	 eax, eax
  0095b	75 21		 jne	 SHORT $LN22@ProcessVol

; 690  : 		{
; 691  : 			Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

  0095d	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00965	c7 40 30 05 00
	00 80		 mov	 DWORD PTR [rax+48], -2147483643 ; ffffffff80000005H

; 692  : 			Irp->IoStatus.Information = sizeof (GET_LENGTH_INFORMATION);

  0096c	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00974	48 c7 40 38 08
	00 00 00	 mov	 QWORD PTR [rax+56], 8

; 693  : 		}
; 694  : 		else

  0097c	eb 4d		 jmp	 SHORT $LN21@ProcessVol
$LN22@ProcessVol:

; 695  : 		{
; 696  : 			PGET_LENGTH_INFORMATION outputBuffer = (PGET_LENGTH_INFORMATION) Irp->AssociatedIrp.SystemBuffer;

  0097e	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00986	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0098a	48 89 84 24 68
	05 00 00	 mov	 QWORD PTR outputBuffer$31723[rsp], rax

; 697  : 
; 698  : 			outputBuffer->Length.QuadPart = Extension->DiskLength;

  00992	48 8b 8c 24 68
	05 00 00	 mov	 rcx, QWORD PTR outputBuffer$31723[rsp]
  0099a	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  009a2	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  009a9	48 89 01	 mov	 QWORD PTR [rcx], rax

; 699  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  009ac	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  009b4	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 700  : 			Irp->IoStatus.Information = sizeof (GET_LENGTH_INFORMATION);

  009bb	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  009c3	48 c7 40 38 08
	00 00 00	 mov	 QWORD PTR [rax+56], 8
$LN21@ProcessVol:

; 701  : 		}
; 702  : 		break;

  009cb	e9 94 03 00 00	 jmp	 $LN43@ProcessVol
$LN20@ProcessVol:

; 703  : 
; 704  : 	case IOCTL_DISK_VERIFY:
; 705  : 		if (ValidateIOBufferSize (Irp, sizeof (VERIFY_INFORMATION), ValidateInput))

  009d0	45 33 c0	 xor	 r8d, r8d
  009d3	ba 10 00 00 00	 mov	 edx, 16
  009d8	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  009e0	e8 00 00 00 00	 call	 ValidateIOBufferSize
  009e5	85 c0		 test	 eax, eax
  009e7	0f 84 fa 01 00
	00		 je	 $LN19@ProcessVol

; 706  : 		{
; 707  : 			PVERIFY_INFORMATION pVerifyInformation;
; 708  : 			pVerifyInformation = (PVERIFY_INFORMATION) Irp->AssociatedIrp.SystemBuffer;

  009ed	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  009f5	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  009f9	48 89 84 24 70
	05 00 00	 mov	 QWORD PTR pVerifyInformation$31730[rsp], rax

; 709  : 
; 710  : 			if (pVerifyInformation->StartingOffset.QuadPart + pVerifyInformation->Length > Extension->DiskLength)

  00a01	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR pVerifyInformation$31730[rsp]
  00a09	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00a0c	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR pVerifyInformation$31730[rsp]
  00a14	48 03 08	 add	 rcx, QWORD PTR [rax]
  00a17	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00a1f	48 3b 88 a0 00
	00 00		 cmp	 rcx, QWORD PTR [rax+160]
  00a26	7e 14		 jle	 SHORT $LN18@ProcessVol

; 711  : 				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  00a28	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00a30	c7 40 30 0d 00
	00 c0		 mov	 DWORD PTR [rax+48], -1073741811 ; ffffffffc000000dH

; 712  : 			else

  00a37	e9 9b 01 00 00	 jmp	 $LN17@ProcessVol
$LN18@ProcessVol:

; 713  : 			{
; 714  : 				IO_STATUS_BLOCK ioStatus;
; 715  : 				PVOID buffer = TCalloc (max (pVerifyInformation->Length, PAGE_SIZE));

  00a3c	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR pVerifyInformation$31730[rsp]
  00a44	81 78 08 00 10
	00 00		 cmp	 DWORD PTR [rax+8], 4096	; 00001000H
  00a4b	76 14		 jbe	 SHORT $LN49@ProcessVol
  00a4d	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR pVerifyInformation$31730[rsp]
  00a55	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00a58	89 84 24 a8 05
	00 00		 mov	 DWORD PTR tv313[rsp], eax
  00a5f	eb 0b		 jmp	 SHORT $LN50@ProcessVol
$LN49@ProcessVol:
  00a61	c7 84 24 a8 05
	00 00 00 10 00
	00		 mov	 DWORD PTR tv313[rsp], 4096 ; 00001000H
$LN50@ProcessVol:
  00a6c	8b 94 24 a8 05
	00 00		 mov	 edx, DWORD PTR tv313[rsp]
  00a73	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  00a79	33 c9		 xor	 ecx, ecx
  00a7b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00a81	48 89 84 24 78
	05 00 00	 mov	 QWORD PTR buffer$31736[rsp], rax

; 716  : 				
; 717  : 				if (!buffer)

  00a89	48 83 bc 24 78
	05 00 00 00	 cmp	 QWORD PTR buffer$31736[rsp], 0
  00a92	75 14		 jne	 SHORT $LN16@ProcessVol

; 718  : 				{
; 719  : 					Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

  00a94	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00a9c	c7 40 30 9a 00
	00 c0		 mov	 DWORD PTR [rax+48], -1073741670 ; ffffffffc000009aH

; 720  : 				}
; 721  : 				else

  00aa3	e9 2f 01 00 00	 jmp	 $LN15@ProcessVol
$LN16@ProcessVol:

; 722  : 				{
; 723  : 					LARGE_INTEGER offset = pVerifyInformation->StartingOffset;

  00aa8	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR pVerifyInformation$31730[rsp]
  00ab0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00ab3	48 89 84 24 90
	05 00 00	 mov	 QWORD PTR offset$31741[rsp], rax

; 724  : 					offset.QuadPart += Extension->cryptoInfo->hiddenVolume ? Extension->cryptoInfo->hiddenVolumeOffset : Extension->cryptoInfo->volDataAreaOffset;

  00abb	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00ac3	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00aca	83 b8 a0 29 00
	00 00		 cmp	 DWORD PTR [rax+10656], 0
  00ad1	74 20		 je	 SHORT $LN51@ProcessVol
  00ad3	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00adb	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00ae2	48 8b 80 18 44
	00 00		 mov	 rax, QWORD PTR [rax+17432]
  00ae9	48 89 84 24 b0
	05 00 00	 mov	 QWORD PTR tv359[rsp], rax
  00af1	eb 1e		 jmp	 SHORT $LN52@ProcessVol
$LN51@ProcessVol:
  00af3	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00afb	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00b02	48 8b 80 08 44
	00 00		 mov	 rax, QWORD PTR [rax+17416]
  00b09	48 89 84 24 b0
	05 00 00	 mov	 QWORD PTR tv359[rsp], rax
$LN52@ProcessVol:
  00b11	48 8b 8c 24 b0
	05 00 00	 mov	 rcx, QWORD PTR tv359[rsp]
  00b19	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR offset$31741[rsp]
  00b21	48 03 c1	 add	 rax, rcx
  00b24	48 89 84 24 90
	05 00 00	 mov	 QWORD PTR offset$31741[rsp], rax

; 725  : 
; 726  : 					Irp->IoStatus.Status = ZwReadFile (Extension->hDeviceFile, NULL, NULL, NULL, &ioStatus, buffer, pVerifyInformation->Length, &offset, NULL);

  00b2c	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00b35	48 8d 84 24 90
	05 00 00	 lea	 rax, QWORD PTR offset$31741[rsp]
  00b3d	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00b42	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR pVerifyInformation$31730[rsp]
  00b4a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00b4d	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00b51	48 8b 84 24 78
	05 00 00	 mov	 rax, QWORD PTR buffer$31736[rsp]
  00b59	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00b5e	48 8d 84 24 80
	05 00 00	 lea	 rax, QWORD PTR ioStatus$31735[rsp]
  00b66	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b6b	45 33 c9	 xor	 r9d, r9d
  00b6e	45 33 c0	 xor	 r8d, r8d
  00b71	33 d2		 xor	 edx, edx
  00b73	48 8b 8c 24 e8
	05 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00b7b	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  00b7f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwReadFile
  00b85	8b d0		 mov	 edx, eax
  00b87	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00b8f	89 50 30	 mov	 DWORD PTR [rax+48], edx

; 727  : 					TCfree (buffer);

  00b92	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00b97	48 8b 8c 24 78
	05 00 00	 mov	 rcx, QWORD PTR buffer$31736[rsp]
  00b9f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 728  : 
; 729  : 					if (NT_SUCCESS (Irp->IoStatus.Status) && ioStatus.Information != pVerifyInformation->Length)

  00ba5	48 8b 94 24 f0
	05 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  00bad	83 7a 30 00	 cmp	 DWORD PTR [rdx+48], 0
  00bb1	7c 24		 jl	 SHORT $LN14@ProcessVol
  00bb3	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR pVerifyInformation$31730[rsp]
  00bbb	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00bbe	48 39 84 24 88
	05 00 00	 cmp	 QWORD PTR ioStatus$31735[rsp+8], rax
  00bc6	74 0f		 je	 SHORT $LN14@ProcessVol

; 730  : 						Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  00bc8	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00bd0	c7 40 30 0d 00
	00 c0		 mov	 DWORD PTR [rax+48], -1073741811 ; ffffffffc000000dH
$LN14@ProcessVol:
$LN15@ProcessVol:
$LN17@ProcessVol:

; 731  : 				}
; 732  : 			}
; 733  : 
; 734  : 			Irp->IoStatus.Information = 0;

  00bd7	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00bdf	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0
$LN19@ProcessVol:

; 735  : 		}
; 736  : 		break;

  00be7	e9 78 01 00 00	 jmp	 $LN43@ProcessVol
$LN13@ProcessVol:

; 737  : 
; 738  : 	case IOCTL_DISK_CHECK_VERIFY:
; 739  : 	case IOCTL_STORAGE_CHECK_VERIFY:
; 740  : 		{
; 741  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00bec	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00bf4	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 742  : 			Irp->IoStatus.Information = 0;

  00bfb	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00c03	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 743  : 
; 744  : 			if (irpSp->Parameters.DeviceIoControl.OutputBufferLength >= sizeof (ULONG))

  00c0b	48 8b 44 24 50	 mov	 rax, QWORD PTR irpSp$[rsp]
  00c10	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00c13	48 83 f8 04	 cmp	 rax, 4
  00c17	72 22		 jb	 SHORT $LN12@ProcessVol

; 745  : 			{
; 746  : 				*((ULONG *) Irp->AssociatedIrp.SystemBuffer) = 0;

  00c19	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00c21	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00c25	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 747  : 				Irp->IoStatus.Information = sizeof (ULONG);

  00c2b	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00c33	48 c7 40 38 04
	00 00 00	 mov	 QWORD PTR [rax+56], 4
$LN12@ProcessVol:

; 748  : 			}
; 749  : 		}
; 750  : 		break;

  00c3b	e9 24 01 00 00	 jmp	 $LN43@ProcessVol
$LN11@ProcessVol:

; 751  : 
; 752  : 	case IOCTL_DISK_IS_WRITABLE:
; 753  : 		{
; 754  : 			if (Extension->bReadOnly)

  00c40	48 8b 84 24 e8
	05 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00c48	83 b8 98 03 00
	00 00		 cmp	 DWORD PTR [rax+920], 0
  00c4f	74 11		 je	 SHORT $LN10@ProcessVol

; 755  : 				Irp->IoStatus.Status = STATUS_MEDIA_WRITE_PROTECTED;

  00c51	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00c59	c7 40 30 a2 00
	00 c0		 mov	 DWORD PTR [rax+48], -1073741662 ; ffffffffc00000a2H

; 756  : 			else

  00c60	eb 0f		 jmp	 SHORT $LN9@ProcessVol
$LN10@ProcessVol:

; 757  : 				Irp->IoStatus.Status = STATUS_SUCCESS;

  00c62	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00c6a	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0
$LN9@ProcessVol:

; 758  : 			Irp->IoStatus.Information = 0;

  00c71	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00c79	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 759  : 
; 760  : 		}
; 761  : 		break;

  00c81	e9 de 00 00 00	 jmp	 $LN43@ProcessVol
$LN8@ProcessVol:

; 762  : 		
; 763  : 	case IOCTL_VOLUME_ONLINE:
; 764  : 		Irp->IoStatus.Status = STATUS_SUCCESS;

  00c86	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00c8e	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 765  : 		Irp->IoStatus.Information = 0;

  00c95	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00c9d	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 766  : 		break;

  00ca5	e9 ba 00 00 00	 jmp	 $LN43@ProcessVol
$LN7@ProcessVol:

; 767  : 
; 768  : 	case IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS:
; 769  : 
; 770  : 		// Vista's filesystem defragmenter fails if IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS does not succeed.
; 771  : 		if (!(OsMajorVersion == 6 && OsMinorVersion == 0))

  00caa	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR OsMajorVersion, 6
  00cb1	75 09		 jne	 SHORT $LN5@ProcessVol
  00cb3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR OsMinorVersion, 0
  00cba	74 21		 je	 SHORT $LN6@ProcessVol
$LN5@ProcessVol:

; 772  : 		{
; 773  : 			Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;

  00cbc	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00cc4	c7 40 30 10 00
	00 c0		 mov	 DWORD PTR [rax+48], -1073741808 ; ffffffffc0000010H

; 774  : 			Irp->IoStatus.Information = 0;

  00ccb	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00cd3	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0
  00cdb	eb 6e		 jmp	 SHORT $LN4@ProcessVol
$LN6@ProcessVol:

; 775  : 		}
; 776  : 		else if (ValidateIOBufferSize (Irp, sizeof (VOLUME_DISK_EXTENTS), ValidateOutput))

  00cdd	41 b8 01 00 00
	00		 mov	 r8d, 1
  00ce3	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00ce8	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00cf0	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00cf5	85 c0		 test	 eax, eax
  00cf7	74 52		 je	 SHORT $LN3@ProcessVol

; 777  : 		{
; 778  : 			VOLUME_DISK_EXTENTS *extents = (VOLUME_DISK_EXTENTS *) Irp->AssociatedIrp.SystemBuffer;

  00cf9	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00d01	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00d05	48 89 84 24 98
	05 00 00	 mov	 QWORD PTR extents$31769[rsp], rax

; 779  : 
; 780  : 			// No extent data can be returned as this is not a physical drive.
; 781  : 			memset (extents, 0, sizeof (*extents));

  00d0d	48 8b bc 24 98
	05 00 00	 mov	 rdi, QWORD PTR extents$31769[rsp]
  00d15	33 c0		 xor	 eax, eax
  00d17	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00d1c	f3 aa		 rep stosb

; 782  : 			extents->NumberOfDiskExtents = 0;

  00d1e	48 8b 84 24 98
	05 00 00	 mov	 rax, QWORD PTR extents$31769[rsp]
  00d26	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 783  : 
; 784  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00d2c	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00d34	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 785  : 			Irp->IoStatus.Information = sizeof (*extents);

  00d3b	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00d43	48 c7 40 38 20
	00 00 00	 mov	 QWORD PTR [rax+56], 32	; 00000020H
$LN3@ProcessVol:
$LN4@ProcessVol:

; 786  : 		}
; 787  : 		break;

  00d4b	eb 17		 jmp	 SHORT $LN43@ProcessVol
$LN2@ProcessVol:

; 788  : 
; 789  : 	default:
; 790  : 		return TCCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);

  00d4d	45 33 c0	 xor	 r8d, r8d
  00d50	ba 10 00 00 c0	 mov	 edx, -1073741808	; ffffffffc0000010H
  00d55	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00d5d	e8 00 00 00 00	 call	 TCCompleteIrp
  00d62	eb 6a		 jmp	 SHORT $LN45@ProcessVol
$LN43@ProcessVol:

; 791  : 	}
; 792  : 
; 793  : #ifdef DEBUG
; 794  : 	if (!NT_SUCCESS (Irp->IoStatus.Status))

  00d64	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00d6c	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00d70	7d 38		 jge	 SHORT $LN1@ProcessVol

; 795  : 	{
; 796  : 		Dump ("IOCTL error 0x%08x (0x%x %d)\n",
; 797  : 			Irp->IoStatus.Status,
; 798  : 			(int) (irpSp->Parameters.DeviceIoControl.IoControlCode >> 16),
; 799  : 			(int) ((irpSp->Parameters.DeviceIoControl.IoControlCode & 0x1FFF) >> 2));

  00d72	48 8b 44 24 50	 mov	 rax, QWORD PTR irpSp$[rsp]
  00d77	44 8b 48 18	 mov	 r9d, DWORD PTR [rax+24]
  00d7b	41 81 e1 ff 1f
	00 00		 and	 r9d, 8191		; 00001fffH
  00d82	41 c1 e9 02	 shr	 r9d, 2
  00d86	48 8b 44 24 50	 mov	 rax, QWORD PTR irpSp$[rsp]
  00d8b	44 8b 40 18	 mov	 r8d, DWORD PTR [rax+24]
  00d8f	41 c1 e8 10	 shr	 r8d, 16
  00d93	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00d9b	8b 50 30	 mov	 edx, DWORD PTR [rax+48]
  00d9e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@BEMMNDOD@IOCTL?5error?50x?$CF08x?5?$CI0x?$CFx?5?$CFd?$CJ?6?$AA@FNODOBFM@
  00da5	e8 00 00 00 00	 call	 DbgPrint
$LN1@ProcessVol:

; 800  : 	}
; 801  : #endif
; 802  : 
; 803  : 	return TCCompleteDiskIrp (Irp, Irp->IoStatus.Status, Irp->IoStatus.Information);

  00daa	4c 8b 84 24 f0
	05 00 00	 mov	 r8, QWORD PTR Irp$[rsp]
  00db2	4d 8b 40 38	 mov	 r8, QWORD PTR [r8+56]
  00db6	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00dbe	8b 50 30	 mov	 edx, DWORD PTR [rax+48]
  00dc1	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00dc9	e8 00 00 00 00	 call	 TCCompleteDiskIrp
$LN45@ProcessVol:

; 804  : }

  00dce	48 8b 8c 24 b8
	05 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00dd6	48 33 cc	 xor	 rcx, rsp
  00dd9	e8 00 00 00 00	 call	 __security_check_cookie
  00dde	48 81 c4 c8 05
	00 00		 add	 rsp, 1480		; 000005c8H
  00de5	5f		 pop	 rdi
  00de6	5e		 pop	 rsi
  00de7	c3		 ret	 0
ProcessVolumeDeviceControlIrp ENDP
PUBLIC	ReadDeviceSkipUnreadableSectors
;	COMDAT pdata
pdata	SEGMENT
$pdata$ReadDeviceSkipUnreadableSectors DD imagerel $LN8
	DD	imagerel $LN8+239
	DD	imagerel $unwind$ReadDeviceSkipUnreadableSectors
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ReadDeviceSkipUnreadableSectors DD 021901H
	DD	070155219H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ReadDeviceSkipUnreadableSectors
_TEXT	SEGMENT
sectorSize$ = 32
status$ = 36
sectorCount$ = 40
deviceObject$ = 64
buffer$ = 72
startOffset$ = 80
size$ = 88
badSectorCount$ = 96
ReadDeviceSkipUnreadableSectors PROC			; COMDAT

; 3261 : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3262 : 	NTSTATUS status;
; 3263 : 	ULONG sectorSize;
; 3264 : 	ULONG sectorCount;
; 3265 : 
; 3266 : 	*badSectorCount = 0;

  00019	48 8b 44 24 60	 mov	 rax, QWORD PTR badSectorCount$[rsp]
  0001e	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 3267 : 
; 3268 : 	status = GetDeviceSectorSize (deviceObject, &sectorSize);

  00025	48 8d 54 24 20	 lea	 rdx, QWORD PTR sectorSize$[rsp]
  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  0002f	e8 00 00 00 00	 call	 GetDeviceSectorSize
  00034	89 44 24 24	 mov	 DWORD PTR status$[rsp], eax

; 3269 : 	if (!NT_SUCCESS (status))

  00038	83 7c 24 24 00	 cmp	 DWORD PTR status$[rsp], 0
  0003d	7d 09		 jge	 SHORT $LN5@ReadDevice

; 3270 : 		return status;

  0003f	8b 44 24 24	 mov	 eax, DWORD PTR status$[rsp]
  00043	e9 a1 00 00 00	 jmp	 $LN6@ReadDevice
$LN5@ReadDevice:

; 3271 : 
; 3272 : 	for (sectorCount = size / sectorSize; sectorCount > 0; --sectorCount, startOffset.QuadPart += sectorSize, buffer += sectorSize)

  00048	33 d2		 xor	 edx, edx
  0004a	8b 44 24 58	 mov	 eax, DWORD PTR size$[rsp]
  0004e	f7 74 24 20	 div	 DWORD PTR sectorSize$[rsp]
  00052	89 44 24 28	 mov	 DWORD PTR sectorCount$[rsp], eax
  00056	eb 2d		 jmp	 SHORT $LN4@ReadDevice
$LN3@ReadDevice:
  00058	8b 44 24 28	 mov	 eax, DWORD PTR sectorCount$[rsp]
  0005c	83 e8 01	 sub	 eax, 1
  0005f	89 44 24 28	 mov	 DWORD PTR sectorCount$[rsp], eax
  00063	8b 4c 24 20	 mov	 ecx, DWORD PTR sectorSize$[rsp]
  00067	48 8b 44 24 50	 mov	 rax, QWORD PTR startOffset$[rsp]
  0006c	48 03 c1	 add	 rax, rcx
  0006f	48 89 44 24 50	 mov	 QWORD PTR startOffset$[rsp], rax
  00074	8b 4c 24 20	 mov	 ecx, DWORD PTR sectorSize$[rsp]
  00078	48 8b 44 24 48	 mov	 rax, QWORD PTR buffer$[rsp]
  0007d	48 03 c1	 add	 rax, rcx
  00080	48 89 44 24 48	 mov	 QWORD PTR buffer$[rsp], rax
$LN4@ReadDevice:
  00085	83 7c 24 28 00	 cmp	 DWORD PTR sectorCount$[rsp], 0
  0008a	76 5b		 jbe	 SHORT $LN2@ReadDevice

; 3273 : 	{
; 3274 : 		status = TCReadDevice (deviceObject, buffer, startOffset, sectorSize);

  0008c	44 8b 4c 24 20	 mov	 r9d, DWORD PTR sectorSize$[rsp]
  00091	4c 8b 44 24 50	 mov	 r8, QWORD PTR startOffset$[rsp]
  00096	48 8b 54 24 48	 mov	 rdx, QWORD PTR buffer$[rsp]
  0009b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  000a0	e8 00 00 00 00	 call	 TCReadDevice
  000a5	89 44 24 24	 mov	 DWORD PTR status$[rsp], eax

; 3275 : 		if (!NT_SUCCESS (status))

  000a9	83 7c 24 24 00	 cmp	 DWORD PTR status$[rsp], 0
  000ae	7d 32		 jge	 SHORT $LN1@ReadDevice

; 3276 : 		{
; 3277 : 			Dump ("Skipping bad sector at %I64d\n", startOffset.QuadPart);

  000b0	48 8b 54 24 50	 mov	 rdx, QWORD PTR startOffset$[rsp]
  000b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@NFNIJFEK@Skipping?5bad?5sector?5at?5?$CFI64d?6?$AA@FNODOBFM@
  000bc	e8 00 00 00 00	 call	 DbgPrint

; 3278 : 			memset (buffer, 0, sectorSize);

  000c1	8b 4c 24 20	 mov	 ecx, DWORD PTR sectorSize$[rsp]
  000c5	48 8b 7c 24 48	 mov	 rdi, QWORD PTR buffer$[rsp]
  000ca	33 c0		 xor	 eax, eax
  000cc	f3 aa		 rep stosb

; 3279 : 			++(*badSectorCount);

  000ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR badSectorCount$[rsp]
  000d3	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000d6	48 83 c1 01	 add	 rcx, 1
  000da	48 8b 44 24 60	 mov	 rax, QWORD PTR badSectorCount$[rsp]
  000df	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN1@ReadDevice:

; 3280 : 		}
; 3281 : 	}

  000e2	e9 71 ff ff ff	 jmp	 $LN3@ReadDevice
$LN2@ReadDevice:

; 3282 : 
; 3283 : 	return STATUS_SUCCESS;

  000e7	33 c0		 xor	 eax, eax
$LN6@ReadDevice:

; 3284 : }

  000e9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ed	5f		 pop	 rdi
  000ee	c3		 ret	 0
ReadDeviceSkipUnreadableSectors ENDP
_TEXT	ENDS
PUBLIC	ZeroUnreadableSectors
;	COMDAT pdata
pdata	SEGMENT
$pdata$ZeroUnreadableSectors DD imagerel $LN11
	DD	imagerel $LN11+348
	DD	imagerel $unwind$ZeroUnreadableSectors
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ZeroUnreadableSectors DD 021901H
	DD	070157219H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ZeroUnreadableSectors
_TEXT	SEGMENT
sectorSize$ = 32
sectorBuffer$ = 40
status$ = 48
sectorCount$ = 52
deviceObject$ = 80
startOffset$ = 88
size$ = 96
zeroedSectorCount$ = 104
ZeroUnreadableSectors PROC				; COMDAT

; 3218 : {

$LN11:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 3219 : 	NTSTATUS status;
; 3220 : 	ULONG sectorSize;
; 3221 : 	ULONG sectorCount;
; 3222 : 	byte *sectorBuffer = NULL;

  00019	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR sectorBuffer$[rsp], 0

; 3223 : 
; 3224 : 	*zeroedSectorCount = 0;

  00022	48 8b 44 24 68	 mov	 rax, QWORD PTR zeroedSectorCount$[rsp]
  00027	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 3225 : 
; 3226 : 	status = GetDeviceSectorSize (deviceObject, &sectorSize);

  0002e	48 8d 54 24 20	 lea	 rdx, QWORD PTR sectorSize$[rsp]
  00033	48 8b 4c 24 50	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  00038	e8 00 00 00 00	 call	 GetDeviceSectorSize
  0003d	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax

; 3227 : 	if (!NT_SUCCESS (status))

  00041	83 7c 24 30 00	 cmp	 DWORD PTR status$[rsp], 0
  00046	7d 09		 jge	 SHORT $LN8@ZeroUnread

; 3228 : 		return status;

  00048	8b 44 24 30	 mov	 eax, DWORD PTR status$[rsp]
  0004c	e9 05 01 00 00	 jmp	 $LN9@ZeroUnread
$LN8@ZeroUnread:

; 3229 : 
; 3230 : 	sectorBuffer = TCalloc (sectorSize);

  00051	8b 54 24 20	 mov	 edx, DWORD PTR sectorSize$[rsp]
  00055	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  0005b	33 c9		 xor	 ecx, ecx
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00063	48 89 44 24 28	 mov	 QWORD PTR sectorBuffer$[rsp], rax

; 3231 : 	if (!sectorBuffer)

  00068	48 83 7c 24 28
	00		 cmp	 QWORD PTR sectorBuffer$[rsp], 0
  0006e	75 0a		 jne	 SHORT $LN7@ZeroUnread

; 3232 : 		return STATUS_INSUFFICIENT_RESOURCES;

  00070	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  00075	e9 dc 00 00 00	 jmp	 $LN9@ZeroUnread
$LN7@ZeroUnread:

; 3233 : 
; 3234 : 	for (sectorCount = size / sectorSize; sectorCount > 0; --sectorCount, startOffset.QuadPart += sectorSize)

  0007a	33 d2		 xor	 edx, edx
  0007c	8b 44 24 60	 mov	 eax, DWORD PTR size$[rsp]
  00080	f7 74 24 20	 div	 DWORD PTR sectorSize$[rsp]
  00084	89 44 24 34	 mov	 DWORD PTR sectorCount$[rsp], eax
  00088	eb 1c		 jmp	 SHORT $LN6@ZeroUnread
$LN5@ZeroUnread:
  0008a	8b 44 24 34	 mov	 eax, DWORD PTR sectorCount$[rsp]
  0008e	83 e8 01	 sub	 eax, 1
  00091	89 44 24 34	 mov	 DWORD PTR sectorCount$[rsp], eax
  00095	8b 4c 24 20	 mov	 ecx, DWORD PTR sectorSize$[rsp]
  00099	48 8b 44 24 58	 mov	 rax, QWORD PTR startOffset$[rsp]
  0009e	48 03 c1	 add	 rax, rcx
  000a1	48 89 44 24 58	 mov	 QWORD PTR startOffset$[rsp], rax
$LN6@ZeroUnread:
  000a6	83 7c 24 34 00	 cmp	 DWORD PTR sectorCount$[rsp], 0
  000ab	0f 86 81 00 00
	00		 jbe	 $LN4@ZeroUnread

; 3235 : 	{
; 3236 : 		status = TCReadDevice (deviceObject, sectorBuffer, startOffset, sectorSize);

  000b1	44 8b 4c 24 20	 mov	 r9d, DWORD PTR sectorSize$[rsp]
  000b6	4c 8b 44 24 58	 mov	 r8, QWORD PTR startOffset$[rsp]
  000bb	48 8b 54 24 28	 mov	 rdx, QWORD PTR sectorBuffer$[rsp]
  000c0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  000c5	e8 00 00 00 00	 call	 TCReadDevice
  000ca	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax

; 3237 : 		if (!NT_SUCCESS (status))

  000ce	83 7c 24 30 00	 cmp	 DWORD PTR status$[rsp], 0
  000d3	7d 58		 jge	 SHORT $LN3@ZeroUnread

; 3238 : 		{
; 3239 : 			Dump ("Zeroing sector at %I64d\n", startOffset.QuadPart);

  000d5	48 8b 54 24 58	 mov	 rdx, QWORD PTR startOffset$[rsp]
  000da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@BHMICMIC@Zeroing?5sector?5at?5?$CFI64d?6?$AA@FNODOBFM@
  000e1	e8 00 00 00 00	 call	 DbgPrint

; 3240 : 			memset (sectorBuffer, 0, sectorSize);

  000e6	8b 4c 24 20	 mov	 ecx, DWORD PTR sectorSize$[rsp]
  000ea	48 8b 7c 24 28	 mov	 rdi, QWORD PTR sectorBuffer$[rsp]
  000ef	33 c0		 xor	 eax, eax
  000f1	f3 aa		 rep stosb

; 3241 : 
; 3242 : 			status = TCWriteDevice (deviceObject, sectorBuffer, startOffset, sectorSize);

  000f3	44 8b 4c 24 20	 mov	 r9d, DWORD PTR sectorSize$[rsp]
  000f8	4c 8b 44 24 58	 mov	 r8, QWORD PTR startOffset$[rsp]
  000fd	48 8b 54 24 28	 mov	 rdx, QWORD PTR sectorBuffer$[rsp]
  00102	48 8b 4c 24 50	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  00107	e8 00 00 00 00	 call	 TCWriteDevice
  0010c	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax

; 3243 : 			if (!NT_SUCCESS (status))

  00110	83 7c 24 30 00	 cmp	 DWORD PTR status$[rsp], 0
  00115	7d 02		 jge	 SHORT $LN2@ZeroUnread

; 3244 : 				goto err;

  00117	eb 21		 jmp	 SHORT $err$33381
$LN2@ZeroUnread:

; 3245 : 
; 3246 : 			++(*zeroedSectorCount);

  00119	48 8b 4c 24 68	 mov	 rcx, QWORD PTR zeroedSectorCount$[rsp]
  0011e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00121	48 83 c1 01	 add	 rcx, 1
  00125	48 8b 44 24 68	 mov	 rax, QWORD PTR zeroedSectorCount$[rsp]
  0012a	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN3@ZeroUnread:

; 3247 : 		}
; 3248 : 	}

  0012d	e9 58 ff ff ff	 jmp	 $LN5@ZeroUnread
$LN4@ZeroUnread:

; 3249 : 
; 3250 : 	status = STATUS_SUCCESS;

  00132	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR status$[rsp], 0
$err$33381:

; 3251 : 
; 3252 : err:
; 3253 : 	if (sectorBuffer)

  0013a	48 83 7c 24 28
	00		 cmp	 QWORD PTR sectorBuffer$[rsp], 0
  00140	74 10		 je	 SHORT $LN1@ZeroUnread

; 3254 : 		TCfree (sectorBuffer);

  00142	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00147	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sectorBuffer$[rsp]
  0014c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN1@ZeroUnread:

; 3255 : 
; 3256 : 	return status;

  00152	8b 44 24 30	 mov	 eax, DWORD PTR status$[rsp]
$LN9@ZeroUnread:

; 3257 : }

  00156	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0015a	5f		 pop	 rdi
  0015b	c3		 ret	 0
ZeroUnreadableSectors ENDP
_TEXT	ENDS
PUBLIC	UserCanAccessDriveDevice
;	COMDAT pdata
pdata	SEGMENT
$pdata$UserCanAccessDriveDevice DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$UserCanAccessDriveDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$UserCanAccessDriveDevice DD 010401H
	DD	06204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT UserCanAccessDriveDevice
_TEXT	SEGMENT
name$ = 32
UserCanAccessDriveDevice PROC				; COMDAT

; 2927 : {

$LN3:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2928 : 	UNICODE_STRING name;
; 2929 : 	RtlInitUnicodeString (&name, L"\\Device\\MountPointManager");

  00004	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@MJJBHHAG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAM?$AAo?$AAu?$AAn?$AAt?$AAP?$AAo?$AAi?$AAn?$AAt?$AAM?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr?$AA?$AA@FNODOBFM@
  0000b	48 8d 4c 24 20	 lea	 rcx, QWORD PTR name$[rsp]
  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 2930 : 
; 2931 : 	return IsAccessibleByUser (&name, FALSE);

  00016	33 d2		 xor	 edx, edx
  00018	48 8d 4c 24 20	 lea	 rcx, QWORD PTR name$[rsp]
  0001d	e8 00 00 00 00	 call	 IsAccessibleByUser

; 2932 : }

  00022	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00026	c3		 ret	 0
UserCanAccessDriveDevice ENDP
_TEXT	ENDS
PUBLIC	UnmountDevice
;	COMDAT pdata
pdata	SEGMENT
$pdata$UnmountDevice DD imagerel $LN23
	DD	imagerel $LN23+822
	DD	imagerel $unwind$UnmountDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$UnmountDevice DD 021601H
	DD	0190116H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT UnmountDevice
_TEXT	SEGMENT
volumeFileObject$ = 48
volumeHandle$ = 56
extension$ = 64
ntStatus$ = 72
dismountRetry$33031 = 76
ntfsData$33033 = 80
cryptoInfo$33067 = 176
tv168 = 184
tv184 = 188
unmountRequest$ = 208
deviceObject$ = 216
ignoreOpenFiles$ = 224
UnmountDevice PROC					; COMDAT

; 2698 : {

$LN23:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 2699 : 	PEXTENSION extension = deviceObject->DeviceExtension;

  00016	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR deviceObject$[rsp]
  0001e	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00022	48 89 44 24 40	 mov	 QWORD PTR extension$[rsp], rax

; 2700 : 	NTSTATUS ntStatus;
; 2701 : 	HANDLE volumeHandle;
; 2702 : 	PFILE_OBJECT volumeFileObject;
; 2703 : 
; 2704 : 	Dump ("UnmountDevice %d\n", extension->nDosDriveNo);

  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR extension$[rsp]
  0002c	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@FNOALNCB@UnmountDevice?5?$CFd?6?$AA@FNODOBFM@
  00036	e8 00 00 00 00	 call	 DbgPrint

; 2705 : 
; 2706 : 	ntStatus = TCOpenFsVolume (extension, &volumeHandle, &volumeFileObject);

  0003b	4c 8d 44 24 30	 lea	 r8, QWORD PTR volumeFileObject$[rsp]
  00040	48 8d 54 24 38	 lea	 rdx, QWORD PTR volumeHandle$[rsp]
  00045	48 8b 4c 24 40	 mov	 rcx, QWORD PTR extension$[rsp]
  0004a	e8 00 00 00 00	 call	 TCOpenFsVolume
  0004f	89 44 24 48	 mov	 DWORD PTR ntStatus$[rsp], eax

; 2707 : 
; 2708 : 	if (NT_SUCCESS (ntStatus))

  00053	83 7c 24 48 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  00058	0f 8c 55 01 00
	00		 jl	 $LN16@UnmountDev

; 2709 : 	{
; 2710 : 		int dismountRetry;
; 2711 : 
; 2712 : 		// Dismounting a writable NTFS filesystem prevents the driver from being unloaded on Windows 7
; 2713 : 		if (IsOSAtLeast (WIN_7) && !extension->bReadOnly)

  0005e	b9 0d 00 00 00	 mov	 ecx, 13
  00063	e8 00 00 00 00	 call	 IsOSAtLeast
  00068	85 c0		 test	 eax, eax
  0006a	74 43		 je	 SHORT $LN15@UnmountDev
  0006c	48 8b 44 24 40	 mov	 rax, QWORD PTR extension$[rsp]
  00071	83 b8 98 03 00
	00 00		 cmp	 DWORD PTR [rax+920], 0
  00078	75 35		 jne	 SHORT $LN15@UnmountDev

; 2714 : 		{
; 2715 : 			NTFS_VOLUME_DATA_BUFFER ntfsData;
; 2716 : 
; 2717 : 			if (NT_SUCCESS (TCFsctlCall (volumeFileObject, FSCTL_GET_NTFS_VOLUME_DATA, NULL, 0, &ntfsData, sizeof (ntfsData))))

  0007a	c7 44 24 28 60
	00 00 00	 mov	 DWORD PTR [rsp+40], 96	; 00000060H
  00082	48 8d 44 24 50	 lea	 rax, QWORD PTR ntfsData$33033[rsp]
  00087	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008c	45 33 c9	 xor	 r9d, r9d
  0008f	45 33 c0	 xor	 r8d, r8d
  00092	ba 64 00 09 00	 mov	 edx, 589924		; 00090064H
  00097	48 8b 4c 24 30	 mov	 rcx, QWORD PTR volumeFileObject$[rsp]
  0009c	e8 00 00 00 00	 call	 TCFsctlCall
  000a1	85 c0		 test	 eax, eax
  000a3	7c 0a		 jl	 SHORT $LN14@UnmountDev

; 2718 : 				DriverUnloadDisabled = TRUE;

  000a5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR DriverUnloadDisabled, 1
$LN14@UnmountDev:
$LN15@UnmountDev:

; 2719 : 		}
; 2720 : 
; 2721 : 		// Lock volume
; 2722 : 		ntStatus = TCFsctlCall (volumeFileObject, FSCTL_LOCK_VOLUME, NULL, 0, NULL, 0);

  000af	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  000b7	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000c0	45 33 c9	 xor	 r9d, r9d
  000c3	45 33 c0	 xor	 r8d, r8d
  000c6	ba 18 00 09 00	 mov	 edx, 589848		; 00090018H
  000cb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR volumeFileObject$[rsp]
  000d0	e8 00 00 00 00	 call	 TCFsctlCall
  000d5	89 44 24 48	 mov	 DWORD PTR ntStatus$[rsp], eax

; 2723 : 		Dump ("FSCTL_LOCK_VOLUME returned %X\n", ntStatus);

  000d9	8b 54 24 48	 mov	 edx, DWORD PTR ntStatus$[rsp]
  000dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@EOHNIHMK@FSCTL_LOCK_VOLUME?5returned?5?$CFX?6?$AA@FNODOBFM@
  000e4	e8 00 00 00 00	 call	 DbgPrint

; 2724 : 
; 2725 : 		if (!NT_SUCCESS (ntStatus) && !ignoreOpenFiles)

  000e9	83 7c 24 48 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  000ee	7d 23		 jge	 SHORT $LN13@UnmountDev
  000f0	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR ignoreOpenFiles$[rsp], 0
  000f8	75 19		 jne	 SHORT $LN13@UnmountDev

; 2726 : 		{
; 2727 : 			TCCloseFsVolume (volumeHandle, volumeFileObject);

  000fa	48 8b 54 24 30	 mov	 rdx, QWORD PTR volumeFileObject$[rsp]
  000ff	48 8b 4c 24 38	 mov	 rcx, QWORD PTR volumeHandle$[rsp]
  00104	e8 00 00 00 00	 call	 TCCloseFsVolume

; 2728 : 			return ERR_FILES_OPEN;

  00109	b8 06 00 00 00	 mov	 eax, 6
  0010e	e9 1b 02 00 00	 jmp	 $LN17@UnmountDev
$LN13@UnmountDev:

; 2729 : 		}
; 2730 : 
; 2731 : 		// Dismount volume
; 2732 : 		for (dismountRetry = 0; dismountRetry < 200; ++dismountRetry)

  00113	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR dismountRetry$33031[rsp], 0
  0011b	eb 0b		 jmp	 SHORT $LN12@UnmountDev
$LN11@UnmountDev:
  0011d	8b 44 24 4c	 mov	 eax, DWORD PTR dismountRetry$33031[rsp]
  00121	83 c0 01	 add	 eax, 1
  00124	89 44 24 4c	 mov	 DWORD PTR dismountRetry$33031[rsp], eax
$LN12@UnmountDev:
  00128	81 7c 24 4c c8
	00 00 00	 cmp	 DWORD PTR dismountRetry$33031[rsp], 200 ; 000000c8H
  00130	7d 7f		 jge	 SHORT $LN10@UnmountDev

; 2733 : 		{
; 2734 : 			ntStatus = TCFsctlCall (volumeFileObject, FSCTL_DISMOUNT_VOLUME, NULL, 0, NULL, 0);

  00132	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0013a	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00143	45 33 c9	 xor	 r9d, r9d
  00146	45 33 c0	 xor	 r8d, r8d
  00149	ba 20 00 09 00	 mov	 edx, 589856		; 00090020H
  0014e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR volumeFileObject$[rsp]
  00153	e8 00 00 00 00	 call	 TCFsctlCall
  00158	89 44 24 48	 mov	 DWORD PTR ntStatus$[rsp], eax

; 2735 : 			Dump ("FSCTL_DISMOUNT_VOLUME returned %X\n", ntStatus);

  0015c	8b 54 24 48	 mov	 edx, DWORD PTR ntStatus$[rsp]
  00160	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@FFMFJFAI@FSCTL_DISMOUNT_VOLUME?5returned?5?$CF@FNODOBFM@
  00167	e8 00 00 00 00	 call	 DbgPrint

; 2736 : 
; 2737 : 			if (NT_SUCCESS (ntStatus) || ntStatus == STATUS_VOLUME_DISMOUNTED)

  0016c	83 7c 24 48 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  00171	7d 0a		 jge	 SHORT $LN8@UnmountDev
  00173	81 7c 24 48 6e
	02 00 c0	 cmp	 DWORD PTR ntStatus$[rsp], -1073741202 ; ffffffffc000026eH
  0017b	75 02		 jne	 SHORT $LN9@UnmountDev
$LN8@UnmountDev:

; 2738 : 				break;

  0017d	eb 32		 jmp	 SHORT $LN10@UnmountDev
$LN9@UnmountDev:

; 2739 : 
; 2740 : 			if (!ignoreOpenFiles)

  0017f	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR ignoreOpenFiles$[rsp], 0
  00187	75 19		 jne	 SHORT $LN7@UnmountDev

; 2741 : 			{
; 2742 : 				TCCloseFsVolume (volumeHandle, volumeFileObject);

  00189	48 8b 54 24 30	 mov	 rdx, QWORD PTR volumeFileObject$[rsp]
  0018e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR volumeHandle$[rsp]
  00193	e8 00 00 00 00	 call	 TCCloseFsVolume

; 2743 : 				return ERR_FILES_OPEN;

  00198	b8 06 00 00 00	 mov	 eax, 6
  0019d	e9 8c 01 00 00	 jmp	 $LN17@UnmountDev
$LN7@UnmountDev:

; 2744 : 			}
; 2745 : 
; 2746 : 			TCSleep (100);

  001a2	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  001a7	e8 00 00 00 00	 call	 TCSleep

; 2747 : 		}

  001ac	e9 6c ff ff ff	 jmp	 $LN11@UnmountDev
$LN10@UnmountDev:

; 2748 : 	}
; 2749 : 	else 

  001b1	eb 1f		 jmp	 SHORT $LN6@UnmountDev
$LN16@UnmountDev:

; 2750 : 	{
; 2751 : 		// Volume cannot be opened => force dismount if allowed
; 2752 : 		if (!ignoreOpenFiles)

  001b3	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR ignoreOpenFiles$[rsp], 0
  001bb	75 0c		 jne	 SHORT $LN5@UnmountDev

; 2753 : 			return ERR_FILES_OPEN;

  001bd	b8 06 00 00 00	 mov	 eax, 6
  001c2	e9 67 01 00 00	 jmp	 $LN17@UnmountDev

; 2754 : 		else

  001c7	eb 09		 jmp	 SHORT $LN4@UnmountDev
$LN5@UnmountDev:

; 2755 : 			volumeHandle = NULL;

  001c9	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR volumeHandle$[rsp], 0
$LN4@UnmountDev:
$LN6@UnmountDev:

; 2756 : 	}
; 2757 : 
; 2758 : 	if (extension->bMountManager)

  001d2	48 8b 44 24 40	 mov	 rax, QWORD PTR extension$[rsp]
  001d7	83 b8 a8 03 00
	00 00		 cmp	 DWORD PTR [rax+936], 0
  001de	74 0d		 je	 SHORT $LN3@UnmountDev

; 2759 : 		MountManagerUnmount (extension->nDosDriveNo);

  001e0	48 8b 44 24 40	 mov	 rax, QWORD PTR extension$[rsp]
  001e5	8b 48 14	 mov	 ecx, DWORD PTR [rax+20]
  001e8	e8 00 00 00 00	 call	 MountManagerUnmount
$LN3@UnmountDev:

; 2760 : 
; 2761 : 	// We always remove symbolic link as mount manager might fail to do so
; 2762 : 	RemoveDriveLink (extension->nDosDriveNo);

  001ed	48 8b 44 24 40	 mov	 rax, QWORD PTR extension$[rsp]
  001f2	8b 48 14	 mov	 ecx, DWORD PTR [rax+20]
  001f5	e8 00 00 00 00	 call	 RemoveDriveLink

; 2763 : 
; 2764 : 	extension->bShuttingDown = TRUE;

  001fa	4c 8b 5c 24 40	 mov	 r11, QWORD PTR extension$[rsp]
  001ff	41 c7 43 18 01
	00 00 00	 mov	 DWORD PTR [r11+24], 1

; 2765 : 
; 2766 : 	ntStatus = IoAcquireRemoveLock (&extension->Queue.RemoveLock, NULL);

  00207	48 8b 4c 24 40	 mov	 rcx, QWORD PTR extension$[rsp]
  0020c	48 81 c1 80 01
	00 00		 add	 rcx, 384		; 00000180H
  00213	c7 44 24 20 78
	00 00 00	 mov	 DWORD PTR [rsp+32], 120	; 00000078H
  0021b	41 b9 ce 0a 00
	00		 mov	 r9d, 2766		; 00000aceH
  00221	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  00228	33 d2		 xor	 edx, edx
  0022a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAcquireRemoveLockEx
  00230	89 44 24 48	 mov	 DWORD PTR ntStatus$[rsp], eax

; 2767 : 	ASSERT (NT_SUCCESS (ntStatus));

  00234	83 7c 24 48 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  00239	7d 2a		 jge	 SHORT $LN19@UnmountDev
  0023b	45 33 c9	 xor	 r9d, r9d
  0023e	41 b8 cf 0a 00
	00		 mov	 r8d, 2767		; 00000acfH
  00244	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  0024b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@MEOILBFO@NT_SUCCESS?5?$CIntStatus?$CJ?$AA@FNODOBFM@
  00252	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  00258	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv168[rsp], 0
  00263	eb 0b		 jmp	 SHORT $LN20@UnmountDev
$LN19@UnmountDev:
  00265	c7 84 24 b8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv168[rsp], 1
$LN20@UnmountDev:

; 2768 : 	IoReleaseRemoveLockAndWait (&extension->Queue.RemoveLock, NULL);

  00270	48 8b 4c 24 40	 mov	 rcx, QWORD PTR extension$[rsp]
  00275	48 81 c1 80 01
	00 00		 add	 rcx, 384		; 00000180H
  0027c	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  00282	33 d2		 xor	 edx, edx
  00284	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockAndWaitEx

; 2769 : 
; 2770 : 	if (volumeHandle != NULL)

  0028a	48 83 7c 24 38
	00		 cmp	 QWORD PTR volumeHandle$[rsp], 0
  00290	74 0f		 je	 SHORT $LN2@UnmountDev

; 2771 : 		TCCloseFsVolume (volumeHandle, volumeFileObject);

  00292	48 8b 54 24 30	 mov	 rdx, QWORD PTR volumeFileObject$[rsp]
  00297	48 8b 4c 24 38	 mov	 rcx, QWORD PTR volumeHandle$[rsp]
  0029c	e8 00 00 00 00	 call	 TCCloseFsVolume
$LN2@UnmountDev:

; 2772 : 
; 2773 : 	if (unmountRequest)

  002a1	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR unmountRequest$[rsp], 0
  002aa	74 67		 je	 SHORT $LN1@UnmountDev

; 2774 : 	{
; 2775 : 		PCRYPTO_INFO cryptoInfo = ((PEXTENSION) deviceObject->DeviceExtension)->cryptoInfo;

  002ac	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR deviceObject$[rsp]
  002b4	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  002b8	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  002bf	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR cryptoInfo$33067[rsp], rax

; 2776 : 		unmountRequest->HiddenVolumeProtectionTriggered = (cryptoInfo->bProtectHiddenVolume && cryptoInfo->bHiddenVolProtectionAction);

  002c7	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR cryptoInfo$33067[rsp]
  002cf	83 b8 00 44 00
	00 00		 cmp	 DWORD PTR [rax+17408], 0
  002d6	74 1e		 je	 SHORT $LN21@UnmountDev
  002d8	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR cryptoInfo$33067[rsp]
  002e0	83 b8 04 44 00
	00 00		 cmp	 DWORD PTR [rax+17412], 0
  002e7	74 0d		 je	 SHORT $LN21@UnmountDev
  002e9	c7 84 24 bc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv184[rsp], 1
  002f4	eb 0b		 jmp	 SHORT $LN22@UnmountDev
$LN21@UnmountDev:
  002f6	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv184[rsp], 0
$LN22@UnmountDev:
  00301	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR unmountRequest$[rsp]
  00309	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR tv184[rsp]
  00310	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN1@UnmountDev:

; 2777 : 	}
; 2778 : 
; 2779 : 	TCDeleteDeviceObject (deviceObject, (PEXTENSION) deviceObject->DeviceExtension);

  00313	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR deviceObject$[rsp]
  0031b	48 8b 52 40	 mov	 rdx, QWORD PTR [rdx+64]
  0031f	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  00327	e8 00 00 00 00	 call	 TCDeleteDeviceObject

; 2780 : 	return 0;

  0032c	33 c0		 xor	 eax, eax
$LN17@UnmountDev:

; 2781 : }

  0032e	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00335	c3		 ret	 0
UnmountDevice ENDP
_TEXT	ENDS
PUBLIC	ProbeRealDriveSize
;	COMDAT pdata
pdata	SEGMENT
$pdata$ProbeRealDriveSize DD imagerel $LN12
	DD	imagerel $LN12+427
	DD	imagerel $unwind$ProbeRealDriveSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ProbeRealDriveSize DD 010e01H
	DD	0c20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ProbeRealDriveSize
_TEXT	SEGMENT
sysLength$ = 48
sectorBuffer$ = 56
offset$ = 64
startTime$ = 72
status$ = 80
driveDeviceObject$ = 112
driveSize$ = 120
ProbeRealDriveSize PROC					; COMDAT

; 2268 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2269 : 	NTSTATUS status;
; 2270 : 	LARGE_INTEGER sysLength;
; 2271 : 	LARGE_INTEGER offset;
; 2272 : 	byte *sectorBuffer;
; 2273 : 	ULONGLONG startTime;
; 2274 : 
; 2275 : 	if (!UserCanAccessDriveDevice())

  0000e	e8 00 00 00 00	 call	 UserCanAccessDriveDevice
  00013	85 c0		 test	 eax, eax
  00015	75 0a		 jne	 SHORT $LN9@ProbeRealD

; 2276 : 		return STATUS_ACCESS_DENIED;

  00017	b8 22 00 00 c0	 mov	 eax, -1073741790	; ffffffffc0000022H
  0001c	e9 85 01 00 00	 jmp	 $LN10@ProbeRealD
$LN9@ProbeRealD:

; 2277 : 
; 2278 : 	sectorBuffer = TCalloc (TC_SECTOR_SIZE_BIOS);

  00021	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  00027	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  0002c	33 c9		 xor	 ecx, ecx
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00034	48 89 44 24 38	 mov	 QWORD PTR sectorBuffer$[rsp], rax

; 2279 : 	if (!sectorBuffer)

  00039	48 83 7c 24 38
	00		 cmp	 QWORD PTR sectorBuffer$[rsp], 0
  0003f	75 0a		 jne	 SHORT $LN8@ProbeRealD

; 2280 : 		return STATUS_INSUFFICIENT_RESOURCES;

  00041	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  00046	e9 5b 01 00 00	 jmp	 $LN10@ProbeRealD
$LN8@ProbeRealD:

; 2281 : 
; 2282 : 	status = SendDeviceIoControlRequest (driveDeviceObject, IOCTL_DISK_GET_LENGTH_INFO,
; 2283 : 		NULL, 0, &sysLength, sizeof (sysLength));

  0004b	c7 44 24 28 08
	00 00 00	 mov	 DWORD PTR [rsp+40], 8
  00053	48 8d 44 24 30	 lea	 rax, QWORD PTR sysLength$[rsp]
  00058	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005d	45 33 c9	 xor	 r9d, r9d
  00060	45 33 c0	 xor	 r8d, r8d
  00063	ba 5c 40 07 00	 mov	 edx, 475228		; 0007405cH
  00068	48 8b 4c 24 70	 mov	 rcx, QWORD PTR driveDeviceObject$[rsp]
  0006d	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  00072	89 44 24 50	 mov	 DWORD PTR status$[rsp], eax

; 2284 : 
; 2285 : 	if (!NT_SUCCESS (status))

  00076	83 7c 24 50 00	 cmp	 DWORD PTR status$[rsp], 0
  0007b	7d 29		 jge	 SHORT $LN7@ProbeRealD

; 2286 : 	{
; 2287 : 		Dump ("Failed to get drive size - error %x\n", status);

  0007d	8b 54 24 50	 mov	 edx, DWORD PTR status$[rsp]
  00081	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@BFNPLHIK@Failed?5to?5get?5drive?5size?5?9?5error@FNODOBFM@
  00088	e8 00 00 00 00	 call	 DbgPrint

; 2288 : 		TCfree (sectorBuffer);

  0008d	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00092	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sectorBuffer$[rsp]
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 2289 : 		return status;

  0009d	8b 44 24 50	 mov	 eax, DWORD PTR status$[rsp]
  000a1	e9 00 01 00 00	 jmp	 $LN10@ProbeRealD
$LN7@ProbeRealD:

; 2290 : 	}
; 2291 : 
; 2292 : 	startTime = KeQueryInterruptTime ();

  000a6	48 b8 08 00 00
	00 80 f7 ff ff	 mov	 rax, -9345848836088	; fffff78000000008H
  000b0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b3	48 89 44 24 48	 mov	 QWORD PTR startTime$[rsp], rax

; 2293 : 	for (offset.QuadPart = sysLength.QuadPart; ; offset.QuadPart += TC_SECTOR_SIZE_BIOS)

  000b8	48 8b 44 24 30	 mov	 rax, QWORD PTR sysLength$[rsp]
  000bd	48 89 44 24 40	 mov	 QWORD PTR offset$[rsp], rax
  000c2	eb 10		 jmp	 SHORT $LN6@ProbeRealD
$LN5@ProbeRealD:
  000c4	48 8b 44 24 40	 mov	 rax, QWORD PTR offset$[rsp]
  000c9	48 05 00 02 00
	00		 add	 rax, 512		; 00000200H
  000cf	48 89 44 24 40	 mov	 QWORD PTR offset$[rsp], rax
$LN6@ProbeRealD:

; 2294 : 	{
; 2295 : 		status = TCReadDevice (driveDeviceObject, sectorBuffer, offset, TC_SECTOR_SIZE_BIOS);

  000d4	41 b9 00 02 00
	00		 mov	 r9d, 512		; 00000200H
  000da	4c 8b 44 24 40	 mov	 r8, QWORD PTR offset$[rsp]
  000df	48 8b 54 24 38	 mov	 rdx, QWORD PTR sectorBuffer$[rsp]
  000e4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR driveDeviceObject$[rsp]
  000e9	e8 00 00 00 00	 call	 TCReadDevice
  000ee	89 44 24 50	 mov	 DWORD PTR status$[rsp], eax

; 2296 : 		
; 2297 : 		if (NT_SUCCESS (status))

  000f2	83 7c 24 50 00	 cmp	 DWORD PTR status$[rsp], 0
  000f7	7c 1e		 jl	 SHORT $LN3@ProbeRealD

; 2298 : 			status = TCWriteDevice (driveDeviceObject, sectorBuffer, offset, TC_SECTOR_SIZE_BIOS);

  000f9	41 b9 00 02 00
	00		 mov	 r9d, 512		; 00000200H
  000ff	4c 8b 44 24 40	 mov	 r8, QWORD PTR offset$[rsp]
  00104	48 8b 54 24 38	 mov	 rdx, QWORD PTR sectorBuffer$[rsp]
  00109	48 8b 4c 24 70	 mov	 rcx, QWORD PTR driveDeviceObject$[rsp]
  0010e	e8 00 00 00 00	 call	 TCWriteDevice
  00113	89 44 24 50	 mov	 DWORD PTR status$[rsp], eax
$LN3@ProbeRealD:

; 2299 : 
; 2300 : 		if (!NT_SUCCESS (status))

  00117	83 7c 24 50 00	 cmp	 DWORD PTR status$[rsp], 0
  0011c	7d 45		 jge	 SHORT $LN2@ProbeRealD

; 2301 : 		{
; 2302 : 			driveSize->QuadPart = offset.QuadPart;

  0011e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR driveSize$[rsp]
  00123	48 8b 44 24 40	 mov	 rax, QWORD PTR offset$[rsp]
  00128	48 89 01	 mov	 QWORD PTR [rcx], rax

; 2303 : 			Dump ("Real drive size = %I64d bytes (%I64d hidden)\n", driveSize->QuadPart, driveSize->QuadPart - sysLength.QuadPart);

  0012b	4c 8b 44 24 78	 mov	 r8, QWORD PTR driveSize$[rsp]
  00130	48 8b 44 24 30	 mov	 rax, QWORD PTR sysLength$[rsp]
  00135	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  00138	4c 2b c0	 sub	 r8, rax
  0013b	48 8b 54 24 78	 mov	 rdx, QWORD PTR driveSize$[rsp]
  00140	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00143	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CO@FHHNLLNJ@Real?5drive?5size?5?$DN?5?$CFI64d?5bytes?5?$CI?$CF@FNODOBFM@
  0014a	e8 00 00 00 00	 call	 DbgPrint

; 2304 : 			TCfree (sectorBuffer);

  0014f	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00154	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sectorBuffer$[rsp]
  00159	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 2305 : 			return STATUS_SUCCESS;

  0015f	33 c0		 xor	 eax, eax
  00161	eb 43		 jmp	 SHORT $LN10@ProbeRealD
$LN2@ProbeRealD:

; 2306 : 		}
; 2307 : 
; 2308 : 		if (KeQueryInterruptTime() - startTime > 3ULL * 60 * 1000 * 1000 * 10)

  00163	48 b8 08 00 00
	00 80 f7 ff ff	 mov	 rax, -9345848836088	; fffff78000000008H
  0016d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00170	48 2b 44 24 48	 sub	 rax, QWORD PTR startTime$[rsp]
  00175	48 3d 00 d2 49
	6b		 cmp	 rax, 1800000000		; 6b49d200H
  0017b	76 24		 jbe	 SHORT $LN1@ProbeRealD

; 2309 : 		{
; 2310 : 			// Abort if probing for more than 3 minutes
; 2311 : 			driveSize->QuadPart = sysLength.QuadPart;

  0017d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR driveSize$[rsp]
  00182	48 8b 44 24 30	 mov	 rax, QWORD PTR sysLength$[rsp]
  00187	48 89 01	 mov	 QWORD PTR [rcx], rax

; 2312 : 			TCfree (sectorBuffer);

  0018a	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  0018f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sectorBuffer$[rsp]
  00194	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 2313 : 			return STATUS_TIMEOUT;

  0019a	b8 02 01 00 00	 mov	 eax, 258		; 00000102H
  0019f	eb 05		 jmp	 SHORT $LN10@ProbeRealD
$LN1@ProbeRealD:

; 2314 : 		}
; 2315 : 	}

  001a1	e9 1e ff ff ff	 jmp	 $LN5@ProbeRealD
$LN10@ProbeRealD:

; 2316 : }

  001a6	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001aa	c3		 ret	 0
ProbeRealDriveSize ENDP
PUBLIC	IsVolumeAccessibleByCurrentUser
;	COMDAT pdata
pdata	SEGMENT
$pdata$IsVolumeAccessibleByCurrentUser DD imagerel $LN8
	DD	imagerel $LN8+274
	DD	imagerel $unwind$IsVolumeAccessibleByCurrentUser
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IsVolumeAccessibleByCurrentUser DD 010901H
	DD	0c209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT IsVolumeAccessibleByCurrentUser
_TEXT	SEGMENT
accessToken$ = 32
subContext$ = 40
tokenUser$ = 72
result$ = 80
volumeDeviceExtension$ = 112
IsVolumeAccessibleByCurrentUser PROC			; COMDAT

; 3288 : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3289 : 	SECURITY_SUBJECT_CONTEXT subContext;
; 3290 : 	PACCESS_TOKEN accessToken;
; 3291 : 	PTOKEN_USER tokenUser;
; 3292 : 	BOOL result = FALSE;

  00009	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR result$[rsp], 0

; 3293 : 
; 3294 : 	if (IoIsSystemThread (PsGetCurrentThread())
; 3295 : 		|| UserCanAccessDriveDevice()
; 3296 : 		|| !volumeDeviceExtension->UserSid
; 3297 : 		|| (volumeDeviceExtension->SystemFavorite && !NonAdminSystemFavoritesAccessDisabled))

  00011	e8 00 00 00 00	 call	 PsGetCurrentThread
  00016	48 8b c8	 mov	 rcx, rax
  00019	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoIsSystemThread
  0001f	0f b6 c0	 movzx	 eax, al
  00022	85 c0		 test	 eax, eax
  00024	75 2f		 jne	 SHORT $LN4@IsVolumeAc
  00026	e8 00 00 00 00	 call	 UserCanAccessDriveDevice
  0002b	85 c0		 test	 eax, eax
  0002d	75 26		 jne	 SHORT $LN4@IsVolumeAc
  0002f	48 8b 44 24 70	 mov	 rax, QWORD PTR volumeDeviceExtension$[rsp]
  00034	48 83 b8 e0 05
	00 00 00	 cmp	 QWORD PTR [rax+1504], 0
  0003c	74 17		 je	 SHORT $LN4@IsVolumeAc
  0003e	48 8b 44 24 70	 mov	 rax, QWORD PTR volumeDeviceExtension$[rsp]
  00043	83 b8 ac 03 00
	00 00		 cmp	 DWORD PTR [rax+940], 0
  0004a	74 13		 je	 SHORT $LN5@IsVolumeAc
  0004c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NonAdminSystemFavoritesAccessDisabled, 0
  00053	75 0a		 jne	 SHORT $LN5@IsVolumeAc
$LN4@IsVolumeAc:

; 3298 : 	{
; 3299 : 		return TRUE;

  00055	b8 01 00 00 00	 mov	 eax, 1
  0005a	e9 ae 00 00 00	 jmp	 $LN6@IsVolumeAc
$LN5@IsVolumeAc:

; 3300 : 	}
; 3301 : 
; 3302 : 	SeCaptureSubjectContext (&subContext);

  0005f	48 8d 4c 24 28	 lea	 rcx, QWORD PTR subContext$[rsp]
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeCaptureSubjectContext

; 3303 : 	SeLockSubjectContext(&subContext);

  0006a	48 8d 4c 24 28	 lea	 rcx, QWORD PTR subContext$[rsp]
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeLockSubjectContext

; 3304 : 	accessToken = getToken(&subContext);

  00075	48 8d 4c 24 28	 lea	 rcx, QWORD PTR subContext$[rsp]
  0007a	e8 00 00 00 00	 call	 getToken
  0007f	48 89 44 24 20	 mov	 QWORD PTR accessToken$[rsp], rax

; 3305 : 
; 3306 : 	if (!accessToken)

  00084	48 83 7c 24 20
	00		 cmp	 QWORD PTR accessToken$[rsp], 0
  0008a	75 02		 jne	 SHORT $LN3@IsVolumeAc

; 3307 : 		goto ret;

  0008c	eb 65		 jmp	 SHORT $ret$33417
$LN3@IsVolumeAc:

; 3308 : 	
; 3309 : 	if (SeTokenIsAdmin (accessToken))

  0008e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR accessToken$[rsp]
  00093	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeTokenIsAdmin
  00099	0f b6 c0	 movzx	 eax, al
  0009c	85 c0		 test	 eax, eax
  0009e	74 0a		 je	 SHORT $LN2@IsVolumeAc

; 3310 : 	{
; 3311 : 		result = TRUE;

  000a0	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR result$[rsp], 1

; 3312 : 		goto ret;

  000a8	eb 49		 jmp	 SHORT $ret$33417
$LN2@IsVolumeAc:

; 3313 : 	}
; 3314 : 
; 3315 : 	if (!NT_SUCCESS (SeQueryInformationToken (accessToken, TokenUser, &tokenUser)))

  000aa	4c 8d 44 24 48	 lea	 r8, QWORD PTR tokenUser$[rsp]
  000af	ba 01 00 00 00	 mov	 edx, 1
  000b4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR accessToken$[rsp]
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeQueryInformationToken
  000bf	85 c0		 test	 eax, eax
  000c1	7d 02		 jge	 SHORT $LN1@IsVolumeAc

; 3316 : 		goto ret;

  000c3	eb 2e		 jmp	 SHORT $ret$33417
$LN1@IsVolumeAc:

; 3317 : 
; 3318 : 	result = RtlEqualSid (volumeDeviceExtension->UserSid, tokenUser->User.Sid);

  000c5	48 8b 54 24 48	 mov	 rdx, QWORD PTR tokenUser$[rsp]
  000ca	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  000cd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR volumeDeviceExtension$[rsp]
  000d2	48 8b 89 e0 05
	00 00		 mov	 rcx, QWORD PTR [rcx+1504]
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlEqualSid
  000df	0f b6 c0	 movzx	 eax, al
  000e2	89 44 24 50	 mov	 DWORD PTR result$[rsp], eax

; 3319 : 	ExFreePool (tokenUser);		// Documented in newer versions of WDK

  000e6	33 d2		 xor	 edx, edx
  000e8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tokenUser$[rsp]
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$ret$33417:

; 3320 : 
; 3321 : ret:
; 3322 : 	SeUnlockSubjectContext(&subContext);

  000f3	48 8d 4c 24 28	 lea	 rcx, QWORD PTR subContext$[rsp]
  000f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeUnlockSubjectContext

; 3323 : 	SeReleaseSubjectContext (&subContext);

  000fe	48 8d 4c 24 28	 lea	 rcx, QWORD PTR subContext$[rsp]
  00103	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeReleaseSubjectContext

; 3324 : 	return result;

  00109	8b 44 24 50	 mov	 eax, DWORD PTR result$[rsp]
$LN6@IsVolumeAc:

; 3325 : }

  0010d	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00111	c3		 ret	 0
IsVolumeAccessibleByCurrentUser ENDP
_TEXT	ENDS
PUBLIC	UnmountAllDevices
;	COMDAT pdata
pdata	SEGMENT
$pdata$UnmountAllDevices DD imagerel $LN11
	DD	imagerel $LN11+247
	DD	imagerel $unwind$UnmountAllDevices
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$UnmountAllDevices DD 010d01H
	DD	0820dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT UnmountAllDevices
_TEXT	SEGMENT
ListDevice$ = 32
status$ = 40
maxUniqueId$ = 44
ListExtension$33100 = 48
ntStatus$33103 = 56
tv83 = 60
unmountRequest$ = 80
ignoreOpenFiles$ = 88
UnmountAllDevices PROC					; COMDAT

; 2809 : {

$LN11:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2810 : 	NTSTATUS status = 0;

  0000d	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR status$[rsp], 0

; 2811 : 	PDEVICE_OBJECT ListDevice;
; 2812 : 	int maxUniqueId = LastUniqueVolumeId;

  00015	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR LastUniqueVolumeId
  0001b	89 44 24 2c	 mov	 DWORD PTR maxUniqueId$[rsp], eax

; 2813 : 
; 2814 : 	Dump ("Unmounting all volumes\n");

  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@OJEECLJN@Unmounting?5all?5volumes?6?$AA@FNODOBFM@
  00026	e8 00 00 00 00	 call	 DbgPrint

; 2815 : 
; 2816 : 	if (unmountRequest)

  0002b	48 83 7c 24 50
	00		 cmp	 QWORD PTR unmountRequest$[rsp], 0
  00031	74 0c		 je	 SHORT $LN6@UnmountAll

; 2817 : 		unmountRequest->HiddenVolumeProtectionTriggered = FALSE;

  00033	48 8b 44 24 50	 mov	 rax, QWORD PTR unmountRequest$[rsp]
  00038	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0
$LN6@UnmountAll:
$LN5@UnmountAll:

; 2818 : 
; 2819 : 	// Dismount volumes in the reverse order they were mounted to properly dismount nested volumes
; 2820 : 	while ((ListDevice = FindVolumeWithHighestUniqueId (maxUniqueId)) != NULL)

  0003f	8b 4c 24 2c	 mov	 ecx, DWORD PTR maxUniqueId$[rsp]
  00043	e8 00 00 00 00	 call	 FindVolumeWithHighestUniqueId
  00048	48 89 44 24 20	 mov	 QWORD PTR ListDevice$[rsp], rax
  0004d	48 83 7c 24 20
	00		 cmp	 QWORD PTR ListDevice$[rsp], 0
  00053	0f 84 95 00 00
	00		 je	 $LN4@UnmountAll

; 2821 : 	{
; 2822 : 		PEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;

  00059	48 8b 44 24 20	 mov	 rax, QWORD PTR ListDevice$[rsp]
  0005e	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00062	48 89 44 24 30	 mov	 QWORD PTR ListExtension$33100[rsp], rax

; 2823 : 		maxUniqueId = ListExtension->UniqueVolumeId - 1;

  00067	48 8b 44 24 30	 mov	 rax, QWORD PTR ListExtension$33100[rsp]
  0006c	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0006f	83 e8 01	 sub	 eax, 1
  00072	89 44 24 2c	 mov	 DWORD PTR maxUniqueId$[rsp], eax

; 2824 : 
; 2825 : 		if (IsVolumeAccessibleByCurrentUser (ListExtension))

  00076	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ListExtension$33100[rsp]
  0007b	e8 00 00 00 00	 call	 IsVolumeAccessibleByCurrentUser
  00080	85 c0		 test	 eax, eax
  00082	74 65		 je	 SHORT $LN3@UnmountAll

; 2826 : 		{
; 2827 : 			NTSTATUS ntStatus;
; 2828 : 
; 2829 : 			if (unmountRequest)

  00084	48 83 7c 24 50
	00		 cmp	 QWORD PTR unmountRequest$[rsp], 0
  0008a	74 0f		 je	 SHORT $LN2@UnmountAll

; 2830 : 				unmountRequest->nDosDriveNo = ListExtension->nDosDriveNo;

  0008c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR unmountRequest$[rsp]
  00091	48 8b 44 24 30	 mov	 rax, QWORD PTR ListExtension$33100[rsp]
  00096	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00099	89 01		 mov	 DWORD PTR [rcx], eax
$LN2@UnmountAll:

; 2831 : 
; 2832 : 			ntStatus = UnmountDevice (unmountRequest, ListDevice, ignoreOpenFiles);

  0009b	44 8b 44 24 58	 mov	 r8d, DWORD PTR ignoreOpenFiles$[rsp]
  000a0	48 8b 54 24 20	 mov	 rdx, QWORD PTR ListDevice$[rsp]
  000a5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR unmountRequest$[rsp]
  000aa	e8 00 00 00 00	 call	 UnmountDevice
  000af	89 44 24 38	 mov	 DWORD PTR ntStatus$33103[rsp], eax

; 2833 : 			status = ntStatus == 0 ? status : ntStatus;

  000b3	83 7c 24 38 00	 cmp	 DWORD PTR ntStatus$33103[rsp], 0
  000b8	75 0a		 jne	 SHORT $LN9@UnmountAll
  000ba	8b 44 24 28	 mov	 eax, DWORD PTR status$[rsp]
  000be	89 44 24 3c	 mov	 DWORD PTR tv83[rsp], eax
  000c2	eb 08		 jmp	 SHORT $LN10@UnmountAll
$LN9@UnmountAll:
  000c4	8b 44 24 38	 mov	 eax, DWORD PTR ntStatus$33103[rsp]
  000c8	89 44 24 3c	 mov	 DWORD PTR tv83[rsp], eax
$LN10@UnmountAll:
  000cc	8b 44 24 3c	 mov	 eax, DWORD PTR tv83[rsp]
  000d0	89 44 24 28	 mov	 DWORD PTR status$[rsp], eax

; 2834 : 
; 2835 : 			if (unmountRequest && unmountRequest->HiddenVolumeProtectionTriggered)

  000d4	48 83 7c 24 50
	00		 cmp	 QWORD PTR unmountRequest$[rsp], 0
  000da	74 0d		 je	 SHORT $LN1@UnmountAll
  000dc	48 8b 44 24 50	 mov	 rax, QWORD PTR unmountRequest$[rsp]
  000e1	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  000e5	74 02		 je	 SHORT $LN1@UnmountAll

; 2836 : 				break;

  000e7	eb 05		 jmp	 SHORT $LN4@UnmountAll
$LN1@UnmountAll:
$LN3@UnmountAll:

; 2837 : 		}
; 2838 : 	}

  000e9	e9 51 ff ff ff	 jmp	 $LN5@UnmountAll
$LN4@UnmountAll:

; 2839 : 
; 2840 : 	return status;

  000ee	8b 44 24 28	 mov	 eax, DWORD PTR status$[rsp]

; 2841 : }

  000f2	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000f6	c3		 ret	 0
UnmountAllDevices ENDP
PUBLIC	VolumeThreadProc
;	COMDAT pdata
pdata	SEGMENT
$pdata$VolumeThreadProc DD imagerel $LN19
	DD	imagerel $LN19+1104
	DD	imagerel $unwind$VolumeThreadProc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$VolumeThreadProc DD 020c01H
	DD	013010cH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT VolumeThreadProc
_TEXT	SEGMENT
bDevice$ = 48
Extension$ = 56
pThreadBlock$ = 64
DeviceObject$ = 72
irp$32302 = 80
request$32301 = 88
irpSp$32300 = 96
tv79 = 104
tv81 = 112
tv82 = 120
tv83 = 128
tv214 = 132
Context$ = 160
VolumeThreadProc PROC					; COMDAT

; 1768 : {

$LN19:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1769 : 	PTHREAD_BLOCK pThreadBlock = (PTHREAD_BLOCK) Context;

  0000c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR Context$[rsp]
  00014	48 89 44 24 40	 mov	 QWORD PTR pThreadBlock$[rsp], rax

; 1770 : 	PDEVICE_OBJECT DeviceObject = pThreadBlock->DeviceObject;

  00019	48 8b 44 24 40	 mov	 rax, QWORD PTR pThreadBlock$[rsp]
  0001e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00021	48 89 44 24 48	 mov	 QWORD PTR DeviceObject$[rsp], rax

; 1771 : 	PEXTENSION Extension = (PEXTENSION) DeviceObject->DeviceExtension;

  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  0002b	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0002f	48 89 44 24 38	 mov	 QWORD PTR Extension$[rsp], rax

; 1772 : 	BOOL bDevice;
; 1773 : 
; 1774 : 	/* Set thread priority to lowest realtime level. */
; 1775 : 	KeSetPriorityThread (KeGetCurrentThread (), LOW_REALTIME_PRIORITY);

  00034	e8 00 00 00 00	 call	 KeGetCurrentThread
  00039	ba 10 00 00 00	 mov	 edx, 16
  0003e	48 8b c8	 mov	 rcx, rax
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetPriorityThread

; 1776 : 
; 1777 : 	Dump ("Mount THREAD OPENING VOLUME BEGIN\n");

  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@LOGBEHKH@Mount?5THREAD?5OPENING?5VOLUME?5BEGI@FNODOBFM@
  0004e	e8 00 00 00 00	 call	 DbgPrint

; 1778 : 
; 1779 : 	if (memcmp (pThreadBlock->mount->wszVolume, WIDE ("\\Device"), 14) != 0)

  00053	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pThreadBlock$[rsp]
  00058	48 8b 89 28 02
	00 00		 mov	 rcx, QWORD PTR [rcx+552]
  0005f	48 83 c1 10	 add	 rcx, 16
  00063	41 b8 0e 00 00
	00		 mov	 r8d, 14
  00069	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1BA@CCLAPIHO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@
  00070	e8 00 00 00 00	 call	 memcmp
  00075	85 c0		 test	 eax, eax
  00077	0f 84 9a 00 00
	00		 je	 $LN13@VolumeThre

; 1780 : 	{
; 1781 : 		wcscpy (pThreadBlock->wszMountVolume, WIDE ("\\??\\"));

  0007d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_19JHEHLFPM@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$AA@FNODOBFM@
  00084	48 89 44 24 68	 mov	 QWORD PTR tv79[rsp], rax
  00089	48 8b 44 24 40	 mov	 rax, QWORD PTR pThreadBlock$[rsp]
  0008e	48 83 c0 0c	 add	 rax, 12
  00092	48 89 44 24 70	 mov	 QWORD PTR tv81[rsp], rax
  00097	48 8b 44 24 70	 mov	 rax, QWORD PTR tv81[rsp]
  0009c	48 89 44 24 78	 mov	 QWORD PTR tv82[rsp], rax
$LN16@VolumeThre:
  000a1	48 8b 44 24 68	 mov	 rax, QWORD PTR tv79[rsp]
  000a6	0f b7 00	 movzx	 eax, WORD PTR [rax]
  000a9	66 89 84 24 80
	00 00 00	 mov	 WORD PTR tv83[rsp], ax
  000b1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv81[rsp]
  000b6	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR tv83[rsp]
  000be	66 89 01	 mov	 WORD PTR [rcx], ax
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR tv79[rsp]
  000c6	48 83 c0 02	 add	 rax, 2
  000ca	48 89 44 24 68	 mov	 QWORD PTR tv79[rsp], rax
  000cf	48 8b 44 24 70	 mov	 rax, QWORD PTR tv81[rsp]
  000d4	48 83 c0 02	 add	 rax, 2
  000d8	48 89 44 24 70	 mov	 QWORD PTR tv81[rsp], rax
  000dd	66 83 bc 24 80
	00 00 00 00	 cmp	 WORD PTR tv83[rsp], 0
  000e6	75 b9		 jne	 SHORT $LN16@VolumeThre

; 1782 : 		wcsncat (pThreadBlock->wszMountVolume, pThreadBlock->mount->wszVolume,
; 1783 : 			sizeof (pThreadBlock->wszMountVolume) / 2 - 5);

  000e8	48 8b 54 24 40	 mov	 rdx, QWORD PTR pThreadBlock$[rsp]
  000ed	48 8b 92 28 02
	00 00		 mov	 rdx, QWORD PTR [rdx+552]
  000f4	48 83 c2 10	 add	 rdx, 16
  000f8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pThreadBlock$[rsp]
  000fd	48 83 c1 0c	 add	 rcx, 12
  00101	41 b8 07 01 00
	00		 mov	 r8d, 263		; 00000107H
  00107	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncat

; 1784 : 		bDevice = FALSE;

  0010d	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR bDevice$[rsp], 0

; 1785 : 	}
; 1786 : 	else

  00115	eb 38		 jmp	 SHORT $LN12@VolumeThre
$LN13@VolumeThre:

; 1787 : 	{
; 1788 : 		pThreadBlock->wszMountVolume[0] = 0;

  00117	33 c9		 xor	 ecx, ecx
  00119	48 8b 44 24 40	 mov	 rax, QWORD PTR pThreadBlock$[rsp]
  0011e	66 89 48 0c	 mov	 WORD PTR [rax+12], cx

; 1789 : 		wcsncat (pThreadBlock->wszMountVolume, pThreadBlock->mount->wszVolume,
; 1790 : 			sizeof (pThreadBlock->wszMountVolume) / 2 - 1);

  00122	48 8b 54 24 40	 mov	 rdx, QWORD PTR pThreadBlock$[rsp]
  00127	48 8b 92 28 02
	00 00		 mov	 rdx, QWORD PTR [rdx+552]
  0012e	48 83 c2 10	 add	 rdx, 16
  00132	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pThreadBlock$[rsp]
  00137	48 83 c1 0c	 add	 rcx, 12
  0013b	41 b8 0b 01 00
	00		 mov	 r8d, 267		; 0000010bH
  00141	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncat

; 1791 : 		bDevice = TRUE;

  00147	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR bDevice$[rsp], 1
$LN12@VolumeThre:

; 1792 : 	}
; 1793 : 
; 1794 : 	Dump ("Mount THREAD request for File %ls DriveNumber %d Device = %d\n",
; 1795 : 	      pThreadBlock->wszMountVolume, pThreadBlock->mount->nDosDriveNo, bDevice);

  0014f	48 8b 44 24 40	 mov	 rax, QWORD PTR pThreadBlock$[rsp]
  00154	48 8b 80 28 02
	00 00		 mov	 rax, QWORD PTR [rax+552]
  0015b	48 8b 54 24 40	 mov	 rdx, QWORD PTR pThreadBlock$[rsp]
  00160	48 83 c2 0c	 add	 rdx, 12
  00164	44 8b 4c 24 30	 mov	 r9d, DWORD PTR bDevice$[rsp]
  00169	44 8b 80 64 02
	00 00		 mov	 r8d, DWORD PTR [rax+612]
  00170	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DO@GJJNBBEG@Mount?5THREAD?5request?5for?5File?5?$CFl@FNODOBFM@
  00177	e8 00 00 00 00	 call	 DbgPrint

; 1796 : 
; 1797 : 	pThreadBlock->ntCreateStatus = TCOpenVolume (DeviceObject,
; 1798 : 		Extension,
; 1799 : 		pThreadBlock->mount,
; 1800 : 		pThreadBlock->wszMountVolume,
; 1801 : 		bDevice);

  0017c	4c 8b 4c 24 40	 mov	 r9, QWORD PTR pThreadBlock$[rsp]
  00181	49 83 c1 0c	 add	 r9, 12
  00185	8b 44 24 30	 mov	 eax, DWORD PTR bDevice$[rsp]
  00189	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0018d	4c 8b 44 24 40	 mov	 r8, QWORD PTR pThreadBlock$[rsp]
  00192	4d 8b 80 28 02
	00 00		 mov	 r8, QWORD PTR [r8+552]
  00199	48 8b 54 24 38	 mov	 rdx, QWORD PTR Extension$[rsp]
  0019e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  001a3	e8 00 00 00 00	 call	 TCOpenVolume
  001a8	44 8b d8	 mov	 r11d, eax
  001ab	48 8b 44 24 40	 mov	 rax, QWORD PTR pThreadBlock$[rsp]
  001b0	44 89 58 08	 mov	 DWORD PTR [rax+8], r11d

; 1802 : 
; 1803 : 	if (!NT_SUCCESS (pThreadBlock->ntCreateStatus) || pThreadBlock->mount->nReturnCode != 0)

  001b4	48 8b 44 24 40	 mov	 rax, QWORD PTR pThreadBlock$[rsp]
  001b9	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  001bd	7c 11		 jl	 SHORT $LN10@VolumeThre
  001bf	48 8b 44 24 40	 mov	 rax, QWORD PTR pThreadBlock$[rsp]
  001c4	48 8b 80 28 02
	00 00		 mov	 rax, QWORD PTR [rax+552]
  001cb	83 38 00	 cmp	 DWORD PTR [rax], 0
  001ce	74 1c		 je	 SHORT $LN11@VolumeThre
$LN10@VolumeThre:

; 1804 : 	{
; 1805 : 		KeSetEvent (&Extension->keCreateEvent, 0, FALSE);

  001d0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  001d5	48 83 c1 28	 add	 rcx, 40			; 00000028H
  001d9	45 33 c0	 xor	 r8d, r8d
  001dc	33 d2		 xor	 edx, edx
  001de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 1806 : 		PsTerminateSystemThread (STATUS_SUCCESS);

  001e4	33 c9		 xor	 ecx, ecx
  001e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsTerminateSystemThread
$LN11@VolumeThre:

; 1807 : 	}
; 1808 : 
; 1809 : 	// Start IO queue
; 1810 : 	Extension->Queue.IsFilterDevice = FALSE;

  001ec	48 8b 44 24 38	 mov	 rax, QWORD PTR Extension$[rsp]
  001f1	c7 80 48 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+328], 0

; 1811 : 	Extension->Queue.DeviceObject = DeviceObject;

  001fb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  00200	48 8b 44 24 48	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  00205	48 89 81 e0 00
	00 00		 mov	 QWORD PTR [rcx+224], rax

; 1812 : 	Extension->Queue.CryptoInfo = Extension->cryptoInfo;

  0020c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  00211	48 8b 44 24 38	 mov	 rax, QWORD PTR Extension$[rsp]
  00216	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0021d	48 89 81 28 01
	00 00		 mov	 QWORD PTR [rcx+296], rax

; 1813 : 	Extension->Queue.HostFileHandle = Extension->hDeviceFile;

  00224	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  00229	48 8b 44 24 38	 mov	 rax, QWORD PTR Extension$[rsp]
  0022e	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00232	48 89 81 30 01
	00 00		 mov	 QWORD PTR [rcx+304], rax

; 1814 : 	Extension->Queue.VirtualDeviceLength = Extension->DiskLength;

  00239	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  0023e	48 8b 44 24 38	 mov	 rax, QWORD PTR Extension$[rsp]
  00243	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  0024a	48 89 81 38 01
	00 00		 mov	 QWORD PTR [rcx+312], rax

; 1815 : 	Extension->Queue.MaxReadAheadOffset.QuadPart = Extension->HostLength;

  00251	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  00256	48 8b 44 24 38	 mov	 rax, QWORD PTR Extension$[rsp]
  0025b	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  00262	48 89 81 10 03
	00 00		 mov	 QWORD PTR [rcx+784], rax

; 1816 : 
; 1817 : 	if (Extension->SecurityClientContextValid)

  00269	48 8b 44 24 38	 mov	 rax, QWORD PTR Extension$[rsp]
  0026e	83 b8 e8 05 00
	00 00		 cmp	 DWORD PTR [rax+1512], 0
  00275	74 1a		 je	 SHORT $LN9@VolumeThre

; 1818 : 		Extension->Queue.SecurityClientContext = &Extension->SecurityClientContext;

  00277	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  0027c	48 81 c1 f0 05
	00 00		 add	 rcx, 1520		; 000005f0H
  00283	48 8b 44 24 38	 mov	 rax, QWORD PTR Extension$[rsp]
  00288	48 89 88 40 01
	00 00		 mov	 QWORD PTR [rax+320], rcx

; 1819 : 	else

  0028f	eb 10		 jmp	 SHORT $LN8@VolumeThre
$LN9@VolumeThre:

; 1820 : 		Extension->Queue.SecurityClientContext = NULL;

  00291	48 8b 44 24 38	 mov	 rax, QWORD PTR Extension$[rsp]
  00296	48 c7 80 40 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+320], 0
$LN8@VolumeThre:

; 1821 : 
; 1822 : 	pThreadBlock->ntCreateStatus = EncryptedIoQueueStart (&Extension->Queue);

  002a1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  002a6	48 81 c1 e0 00
	00 00		 add	 rcx, 224		; 000000e0H
  002ad	e8 00 00 00 00	 call	 EncryptedIoQueueStart
  002b2	44 8b d8	 mov	 r11d, eax
  002b5	48 8b 44 24 40	 mov	 rax, QWORD PTR pThreadBlock$[rsp]
  002ba	44 89 58 08	 mov	 DWORD PTR [rax+8], r11d

; 1823 : 
; 1824 : 	if (!NT_SUCCESS (pThreadBlock->ntCreateStatus))

  002be	48 8b 44 24 40	 mov	 rax, QWORD PTR pThreadBlock$[rsp]
  002c3	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  002c7	7d 3d		 jge	 SHORT $LN7@VolumeThre

; 1825 : 	{
; 1826 : 		TCCloseVolume (DeviceObject, Extension);

  002c9	48 8b 54 24 38	 mov	 rdx, QWORD PTR Extension$[rsp]
  002ce	48 8b 4c 24 48	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  002d3	e8 00 00 00 00	 call	 TCCloseVolume

; 1827 : 
; 1828 : 		pThreadBlock->mount->nReturnCode = ERR_OS_ERROR;

  002d8	48 8b 44 24 40	 mov	 rax, QWORD PTR pThreadBlock$[rsp]
  002dd	48 8b 80 28 02
	00 00		 mov	 rax, QWORD PTR [rax+552]
  002e4	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 1829 : 		KeSetEvent (&Extension->keCreateEvent, 0, FALSE);

  002ea	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  002ef	48 83 c1 28	 add	 rcx, 40			; 00000028H
  002f3	45 33 c0	 xor	 r8d, r8d
  002f6	33 d2		 xor	 edx, edx
  002f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 1830 : 		PsTerminateSystemThread (STATUS_SUCCESS);

  002fe	33 c9		 xor	 ecx, ecx
  00300	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsTerminateSystemThread
$LN7@VolumeThre:

; 1831 : 	}
; 1832 : 
; 1833 : 	KeSetEvent (&Extension->keCreateEvent, 0, FALSE);

  00306	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  0030b	48 83 c1 28	 add	 rcx, 40			; 00000028H
  0030f	45 33 c0	 xor	 r8d, r8d
  00312	33 d2		 xor	 edx, edx
  00314	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 1834 : 	/* From this point on pThreadBlock cannot be used as it will have been released! */
; 1835 : 	pThreadBlock = NULL;

  0031a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR pThreadBlock$[rsp], 0
$LN6@VolumeThre:

; 1836 : 
; 1837 : 	for (;;)
; 1838 : 	{
; 1839 : 		/* Wait for a request from the dispatch routines. */
; 1840 : 		KeWaitForSingleObject ((PVOID) & Extension->RequestSemaphore, Executive, KernelMode, FALSE, NULL);

  00323	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  00328	48 83 c1 58	 add	 rcx, 88			; 00000058H
  0032c	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00335	45 33 c9	 xor	 r9d, r9d
  00338	45 33 c0	 xor	 r8d, r8d
  0033b	33 d2		 xor	 edx, edx
  0033d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
$LN4@VolumeThre:

; 1841 : 
; 1842 : 		for (;;)
; 1843 : 		{
; 1844 : 			PIO_STACK_LOCATION irpSp;
; 1845 : 			PLIST_ENTRY request;
; 1846 : 			PIRP irp;
; 1847 : 
; 1848 : 			request = ExInterlockedRemoveHeadList (&Extension->ListEntry, &Extension->ListSpinLock);

  00343	48 8b 54 24 38	 mov	 rdx, QWORD PTR Extension$[rsp]
  00348	48 83 c2 40	 add	 rdx, 64			; 00000040H
  0034c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  00351	48 83 c1 48	 add	 rcx, 72			; 00000048H
  00355	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExInterlockedRemoveHeadList
  0035b	48 89 44 24 58	 mov	 QWORD PTR request$32301[rsp], rax

; 1849 : 			if (request == NULL)

  00360	48 83 7c 24 58
	00		 cmp	 QWORD PTR request$32301[rsp], 0
  00366	75 05		 jne	 SHORT $LN2@VolumeThre

; 1850 : 				break;

  00368	e9 97 00 00 00	 jmp	 $LN3@VolumeThre
$LN2@VolumeThre:

; 1851 : 
; 1852 : 			irp = CONTAINING_RECORD (request, IRP, Tail.Overlay.ListEntry);

  0036d	48 8b 44 24 58	 mov	 rax, QWORD PTR request$32301[rsp]
  00372	48 2d a8 00 00
	00		 sub	 rax, 168		; 000000a8H
  00378	48 89 44 24 50	 mov	 QWORD PTR irp$32302[rsp], rax

; 1853 : 			irpSp = IoGetCurrentIrpStackLocation (irp);

  0037d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR irp$32302[rsp]
  00382	e8 00 00 00 00	 call	 IoGetCurrentIrpStackLocation
  00387	48 89 44 24 60	 mov	 QWORD PTR irpSp$32300[rsp], rax

; 1854 : 
; 1855 : 			ASSERT (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL);

  0038c	48 8b 44 24 60	 mov	 rax, QWORD PTR irpSp$32300[rsp]
  00391	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00394	83 f8 0e	 cmp	 eax, 14
  00397	74 2a		 je	 SHORT $LN17@VolumeThre
  00399	45 33 c9	 xor	 r9d, r9d
  0039c	41 b8 3f 07 00
	00		 mov	 r8d, 1855		; 0000073fH
  003a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  003a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CO@PADHEFHE@irpSp?9?$DOMajorFunction?5?$DN?$DN?5IRP_MJ_D@FNODOBFM@
  003b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  003b6	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv214[rsp], 0
  003c1	eb 0b		 jmp	 SHORT $LN18@VolumeThre
$LN17@VolumeThre:
  003c3	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv214[rsp], 1
$LN18@VolumeThre:

; 1856 : 
; 1857 : 			ProcessVolumeDeviceControlIrp (DeviceObject, Extension, irp);

  003ce	4c 8b 44 24 50	 mov	 r8, QWORD PTR irp$32302[rsp]
  003d3	48 8b 54 24 38	 mov	 rdx, QWORD PTR Extension$[rsp]
  003d8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  003dd	e8 00 00 00 00	 call	 ProcessVolumeDeviceControlIrp

; 1858 : 			IoReleaseRemoveLock (&Extension->Queue.RemoveLock, irp);

  003e2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  003e7	48 81 c1 80 01
	00 00		 add	 rcx, 384		; 00000180H
  003ee	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  003f4	48 8b 54 24 50	 mov	 rdx, QWORD PTR irp$32302[rsp]
  003f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 1859 : 		}

  003ff	e9 3f ff ff ff	 jmp	 $LN4@VolumeThre
$LN3@VolumeThre:

; 1860 : 
; 1861 : 		if (Extension->bThreadShouldQuit)

  00404	48 8b 44 24 38	 mov	 rax, QWORD PTR Extension$[rsp]
  00409	83 78 1c 00	 cmp	 DWORD PTR [rax+28], 0
  0040d	74 34		 je	 SHORT $LN1@VolumeThre

; 1862 : 		{
; 1863 : 			Dump ("Closing volume\n");

  0040f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@OMKHINCH@Closing?5volume?6?$AA@FNODOBFM@
  00416	e8 00 00 00 00	 call	 DbgPrint

; 1864 : 			EncryptedIoQueueStop (&Extension->Queue);

  0041b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Extension$[rsp]
  00420	48 81 c1 e0 00
	00 00		 add	 rcx, 224		; 000000e0H
  00427	e8 00 00 00 00	 call	 EncryptedIoQueueStop

; 1865 : 
; 1866 : 			TCCloseVolume (DeviceObject, Extension);

  0042c	48 8b 54 24 38	 mov	 rdx, QWORD PTR Extension$[rsp]
  00431	48 8b 4c 24 48	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  00436	e8 00 00 00 00	 call	 TCCloseVolume

; 1867 : 			PsTerminateSystemThread (STATUS_SUCCESS);

  0043b	33 c9		 xor	 ecx, ecx
  0043d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsTerminateSystemThread
$LN1@VolumeThre:

; 1868 : 		}
; 1869 : 	}

  00443	e9 db fe ff ff	 jmp	 $LN6@VolumeThre

; 1870 : }

  00448	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0044f	c3		 ret	 0
VolumeThreadProc ENDP
_TEXT	ENDS
PUBLIC	TCStartVolumeThread
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCStartVolumeThread DD imagerel $LN8
	DD	imagerel $LN8+586
	DD	imagerel $unwind$TCStartVolumeThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCStartVolumeThread DD 031701H
	DD	0140117H
	DD	03010H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT TCStartVolumeThread
_TEXT	SEGMENT
threadObjAttributes$ = 64
pThreadBlock$ = 112
qos$ = 120
ntStatus$ = 136
hThread$ = 144
DeviceObject$ = 176
Extension$ = 184
mount$ = 192
TCStartVolumeThread PROC				; COMDAT

; 1640 : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	53		 push	 rbx
  00010	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H

; 1641 : 	PTHREAD_BLOCK pThreadBlock = TCalloc (sizeof (THREAD_BLOCK));

  00017	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  0001d	ba 30 02 00 00	 mov	 edx, 560		; 00000230H
  00022	33 c9		 xor	 ecx, ecx
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  0002a	48 89 44 24 70	 mov	 QWORD PTR pThreadBlock$[rsp], rax

; 1642 : 	HANDLE hThread;
; 1643 : 	NTSTATUS ntStatus;
; 1644 : 	OBJECT_ATTRIBUTES threadObjAttributes;
; 1645 : 	SECURITY_QUALITY_OF_SERVICE qos;
; 1646 : 
; 1647 : 	Dump ("Starting thread...\n");

  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@DCPHDOHD@Starting?5thread?4?4?4?6?$AA@FNODOBFM@
  00036	e8 00 00 00 00	 call	 DbgPrint

; 1648 : 
; 1649 : 	if (pThreadBlock == NULL)

  0003b	48 83 7c 24 70
	00		 cmp	 QWORD PTR pThreadBlock$[rsp], 0
  00041	75 0c		 jne	 SHORT $LN5@TCStartVol

; 1650 : 	{
; 1651 : 		return STATUS_INSUFFICIENT_RESOURCES;

  00043	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  00048	e9 f4 01 00 00	 jmp	 $LN6@TCStartVol

; 1652 : 	}
; 1653 : 	else

  0004d	eb 24		 jmp	 SHORT $LN4@TCStartVol
$LN5@TCStartVol:

; 1654 : 	{
; 1655 : 		pThreadBlock->DeviceObject = DeviceObject;

  0004f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pThreadBlock$[rsp]
  00054	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  0005c	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1656 : 		pThreadBlock->mount = mount;

  0005f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pThreadBlock$[rsp]
  00064	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  0006c	48 89 81 28 02
	00 00		 mov	 QWORD PTR [rcx+552], rax
$LN4@TCStartVol:

; 1657 : 	}
; 1658 : 
; 1659 : 	qos.Length = sizeof (qos);

  00073	c7 44 24 78 0c
	00 00 00	 mov	 DWORD PTR qos$[rsp], 12

; 1660 : 	qos.ContextTrackingMode = SECURITY_STATIC_TRACKING;

  0007b	c6 84 24 80 00
	00 00 00	 mov	 BYTE PTR qos$[rsp+8], 0

; 1661 : 	qos.EffectiveOnly = TRUE;

  00083	c6 84 24 81 00
	00 00 01	 mov	 BYTE PTR qos$[rsp+9], 1

; 1662 : 	qos.ImpersonationLevel = SecurityImpersonation;

  0008b	c7 44 24 7c 02
	00 00 00	 mov	 DWORD PTR qos$[rsp+4], 2

; 1663 : 
; 1664 : 	ntStatus = SeCreateClientSecurity (PsGetCurrentThread(), &qos, FALSE, &Extension->SecurityClientContext);

  00093	48 8b 9c 24 b8
	00 00 00	 mov	 rbx, QWORD PTR Extension$[rsp]
  0009b	48 81 c3 f0 05
	00 00		 add	 rbx, 1520		; 000005f0H
  000a2	e8 00 00 00 00	 call	 PsGetCurrentThread
  000a7	4c 8b cb	 mov	 r9, rbx
  000aa	45 33 c0	 xor	 r8d, r8d
  000ad	48 8d 54 24 78	 lea	 rdx, QWORD PTR qos$[rsp]
  000b2	48 8b c8	 mov	 rcx, rax
  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeCreateClientSecurity
  000bb	89 84 24 88 00
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 1665 : 	if (!NT_SUCCESS (ntStatus))

  000c2	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  000ca	7d 05		 jge	 SHORT $LN3@TCStartVol

; 1666 : 		goto ret;

  000cc	e9 59 01 00 00	 jmp	 $ret$32220
$LN3@TCStartVol:

; 1667 : 
; 1668 : 	Extension->SecurityClientContextValid = TRUE;

  000d1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  000d9	c7 80 e8 05 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1512], 1

; 1669 : 
; 1670 : 	Extension->bThreadShouldQuit = FALSE;

  000e3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  000eb	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0

; 1671 : 
; 1672 : 	InitializeObjectAttributes (&threadObjAttributes, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);

  000f2	c7 44 24 40 30
	00 00 00	 mov	 DWORD PTR threadObjAttributes$[rsp], 48 ; 00000030H
  000fa	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR threadObjAttributes$[rsp+8], 0
  00103	c7 44 24 58 00
	02 00 00	 mov	 DWORD PTR threadObjAttributes$[rsp+24], 512 ; 00000200H
  0010b	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR threadObjAttributes$[rsp+16], 0
  00114	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR threadObjAttributes$[rsp+32], 0
  0011d	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR threadObjAttributes$[rsp+40], 0

; 1673 : 
; 1674 : 	ntStatus = PsCreateSystemThread (&hThread,
; 1675 : 					 THREAD_ALL_ACCESS,
; 1676 : 					 &threadObjAttributes,
; 1677 : 					 NULL,
; 1678 : 					 NULL,
; 1679 : 					 VolumeThreadProc,
; 1680 : 					 pThreadBlock);

  00126	48 8b 44 24 70	 mov	 rax, QWORD PTR pThreadBlock$[rsp]
  0012b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00130	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:VolumeThreadProc
  00137	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0013c	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00145	45 33 c9	 xor	 r9d, r9d
  00148	4c 8d 44 24 40	 lea	 r8, QWORD PTR threadObjAttributes$[rsp]
  0014d	ba ff 03 1f 00	 mov	 edx, 2032639		; 001f03ffH
  00152	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR hThread$[rsp]
  0015a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsCreateSystemThread
  00160	89 84 24 88 00
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 1681 : 
; 1682 : 	if (!NT_SUCCESS (ntStatus))

  00167	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  0016f	7d 11		 jge	 SHORT $LN2@TCStartVol

; 1683 : 	{
; 1684 : 		Dump ("PsCreateSystemThread Failed END\n");

  00171	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CB@DGOAIPAC@PsCreateSystemThread?5Failed?5END?6@FNODOBFM@
  00178	e8 00 00 00 00	 call	 DbgPrint

; 1685 : 		goto ret;

  0017d	e9 a8 00 00 00	 jmp	 $ret$32220
$LN2@TCStartVol:

; 1686 : 	}
; 1687 : 
; 1688 : 	ntStatus = ObReferenceObjectByHandle (hThread,
; 1689 : 				   THREAD_ALL_ACCESS,
; 1690 : 				   NULL,
; 1691 : 				   KernelMode,
; 1692 : 				   &Extension->peThread,
; 1693 : 				   NULL);

  00182	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  0018a	48 83 c0 20	 add	 rax, 32			; 00000020H
  0018e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00197	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0019c	45 33 c9	 xor	 r9d, r9d
  0019f	45 33 c0	 xor	 r8d, r8d
  001a2	ba ff 03 1f 00	 mov	 edx, 2032639		; 001f03ffH
  001a7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR hThread$[rsp]
  001af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObReferenceObjectByHandle
  001b5	89 84 24 88 00
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax

; 1694 : 
; 1695 : 	ZwClose (hThread);

  001bc	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR hThread$[rsp]
  001c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 1696 : 
; 1697 : 	if (!NT_SUCCESS (ntStatus))

  001ca	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  001d2	7d 02		 jge	 SHORT $LN1@TCStartVol

; 1698 : 		goto ret;

  001d4	eb 54		 jmp	 SHORT $ret$32220
$LN1@TCStartVol:

; 1699 : 
; 1700 : 	Dump ("Waiting for thread to initialize...\n");

  001d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@DMBFEFC@Waiting?5for?5thread?5to?5initialize@FNODOBFM@
  001dd	e8 00 00 00 00	 call	 DbgPrint

; 1701 : 
; 1702 : 	KeWaitForSingleObject (&Extension->keCreateEvent,
; 1703 : 			       Executive,
; 1704 : 			       KernelMode,
; 1705 : 			       FALSE,
; 1706 : 			       NULL);

  001e2	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  001ea	48 83 c1 28	 add	 rcx, 40			; 00000028H
  001ee	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  001f7	45 33 c9	 xor	 r9d, r9d
  001fa	45 33 c0	 xor	 r8d, r8d
  001fd	33 d2		 xor	 edx, edx
  001ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 1707 : 
; 1708 : 	Dump ("Waiting completed! Thread returns 0x%08x\n", pThreadBlock->ntCreateStatus);

  00205	4c 8b 5c 24 70	 mov	 r11, QWORD PTR pThreadBlock$[rsp]
  0020a	41 8b 53 08	 mov	 edx, DWORD PTR [r11+8]
  0020e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CK@KIOPBGEO@Waiting?5completed?$CB?5Thread?5return@FNODOBFM@
  00215	e8 00 00 00 00	 call	 DbgPrint

; 1709 : 	ntStatus = pThreadBlock->ntCreateStatus;

  0021a	4c 8b 5c 24 70	 mov	 r11, QWORD PTR pThreadBlock$[rsp]
  0021f	41 8b 43 08	 mov	 eax, DWORD PTR [r11+8]
  00223	89 84 24 88 00
	00 00		 mov	 DWORD PTR ntStatus$[rsp], eax
$ret$32220:

; 1710 : 
; 1711 : ret:
; 1712 : 	TCfree (pThreadBlock);

  0022a	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  0022f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pThreadBlock$[rsp]
  00234	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 1713 : 	return ntStatus;

  0023a	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR ntStatus$[rsp]
$LN6@TCStartVol:

; 1714 : }

  00241	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  00248	5b		 pop	 rbx
  00249	c3		 ret	 0
TCStartVolumeThread ENDP
PUBLIC	MountDevice
EXTRN	__C_specific_handler:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$MountDevice DD imagerel $LN28
	DD	imagerel $LN28+985
	DD	imagerel $unwind$MountDevice
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$MountDevice$filt$0 DD imagerel MountDevice$filt$0
	DD	imagerel MountDevice$filt$0+29
	DD	imagerel $unwind$MountDevice$filt$0
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MountDevice$filt$0 DD 020f01H
	DD	0500b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MountDevice DD 021109H
	DD	0150111H
	DD	imagerel __C_specific_handler
	DD	01H
	DD	imagerel $LN28+820
	DD	imagerel $LN28+900
	DD	imagerel MountDevice$filt$0
	DD	imagerel $LN28+900
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT MountDevice
_TEXT	SEGMENT
NewDeviceObject$ = 48
ntStatus$ = 56
accessToken$32983 = 64
NewExtension$32980 = 72
subContext$32982 = 80
tokenUser$32987 = 112
sidLength$32990 = 120
volumeFileObject$33003 = 128
volumeHandle$33002 = 136
fsStatus$33010 = 144
DeviceObject$ = 176
mount$ = 184
MountDevice PROC					; COMDAT

; 2564 : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 2565 : 	PDEVICE_OBJECT NewDeviceObject;
; 2566 : 	NTSTATUS ntStatus;
; 2567 : 
; 2568 : 	// Make sure the user is asking for a reasonable nDosDriveNo
; 2569 : 	if (mount->nDosDriveNo >= 0 && mount->nDosDriveNo <= 25 && IsDriveLetterAvailable (mount->nDosDriveNo))

  00011	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  00019	83 b8 64 02 00
	00 00		 cmp	 DWORD PTR [rax+612], 0
  00020	7c 36		 jl	 SHORT $LN20@MountDevic
  00022	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  0002a	83 b8 64 02 00
	00 19		 cmp	 DWORD PTR [rax+612], 25
  00031	7f 25		 jg	 SHORT $LN20@MountDevic
  00033	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  0003b	8b 88 64 02 00
	00		 mov	 ecx, DWORD PTR [rax+612]
  00041	e8 00 00 00 00	 call	 IsDriveLetterAvailable
  00046	85 c0		 test	 eax, eax
  00048	74 0e		 je	 SHORT $LN20@MountDevic

; 2570 : 	{
; 2571 : 		Dump ("Mount request looks valid\n");

  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@PIKDDHEP@Mount?5request?5looks?5valid?6?$AA@FNODOBFM@
  00051	e8 00 00 00 00	 call	 DbgPrint

; 2572 : 	}
; 2573 : 	else

  00056	eb 25		 jmp	 SHORT $LN19@MountDevic
$LN20@MountDevic:

; 2574 : 	{
; 2575 : 		Dump ("WARNING: MOUNT DRIVE LETTER INVALID\n");

  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@CGPMKDKJ@WARNING?3?5MOUNT?5DRIVE?5LETTER?5INVA@FNODOBFM@
  0005f	e8 00 00 00 00	 call	 DbgPrint

; 2576 : 		mount->nReturnCode = ERR_DRIVE_NOT_FOUND;

  00064	4c 8b 9c 24 b8
	00 00 00	 mov	 r11, QWORD PTR mount$[rsp]
  0006c	41 c7 03 05 00
	00 00		 mov	 DWORD PTR [r11], 5

; 2577 : 		return ERR_DRIVE_NOT_FOUND;

  00073	b8 05 00 00 00	 mov	 eax, 5
  00078	e9 54 03 00 00	 jmp	 $LN23@MountDevic
$LN19@MountDevic:

; 2578 : 	}
; 2579 : 
; 2580 : 	if (!SelfTestsPassed)

  0007d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR SelfTestsPassed, 0
  00084	75 18		 jne	 SHORT $LN18@MountDevic

; 2581 : 	{
; 2582 : 		mount->nReturnCode = ERR_SELF_TESTS_FAILED;

  00086	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  0008e	c7 00 13 00 00
	00		 mov	 DWORD PTR [rax], 19

; 2583 : 		return ERR_SELF_TESTS_FAILED;

  00094	b8 13 00 00 00	 mov	 eax, 19
  00099	e9 33 03 00 00	 jmp	 $LN23@MountDevic
$LN18@MountDevic:

; 2584 : 	}
; 2585 : 
; 2586 : 	ntStatus = TCCreateDeviceObject (DeviceObject->DriverObject, &NewDeviceObject, mount);

  0009e	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR mount$[rsp]
  000a6	48 8d 54 24 30	 lea	 rdx, QWORD PTR NewDeviceObject$[rsp]
  000ab	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  000b3	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000b7	e8 00 00 00 00	 call	 TCCreateDeviceObject
  000bc	89 44 24 38	 mov	 DWORD PTR ntStatus$[rsp], eax

; 2587 : 
; 2588 : 	if (!NT_SUCCESS (ntStatus))

  000c0	83 7c 24 38 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  000c5	7d 1e		 jge	 SHORT $LN17@MountDevic

; 2589 : 	{
; 2590 : 		Dump ("Mount CREATE DEVICE ERROR, ntStatus = 0x%08x\n", ntStatus);

  000c7	8b 54 24 38	 mov	 edx, DWORD PTR ntStatus$[rsp]
  000cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CO@NNHGPFIJ@Mount?5CREATE?5DEVICE?5ERROR?0?5ntSta@FNODOBFM@
  000d2	e8 00 00 00 00	 call	 DbgPrint

; 2591 : 		return ntStatus;

  000d7	8b 44 24 38	 mov	 eax, DWORD PTR ntStatus$[rsp]
  000db	e9 f1 02 00 00	 jmp	 $LN23@MountDevic

; 2592 : 	}
; 2593 : 	else

  000e0	e9 ec 02 00 00	 jmp	 $LN23@MountDevic
$LN17@MountDevic:

; 2594 : 	{
; 2595 : 		PEXTENSION NewExtension = (PEXTENSION) NewDeviceObject->DeviceExtension;

  000e5	48 8b 44 24 30	 mov	 rax, QWORD PTR NewDeviceObject$[rsp]
  000ea	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  000ee	48 89 44 24 48	 mov	 QWORD PTR NewExtension$32980[rsp], rax

; 2596 : 		SECURITY_SUBJECT_CONTEXT subContext;
; 2597 : 		PACCESS_TOKEN accessToken;
; 2598 : 
; 2599 : 		SeCaptureSubjectContext (&subContext);

  000f3	48 8d 4c 24 50	 lea	 rcx, QWORD PTR subContext$32982[rsp]
  000f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeCaptureSubjectContext

; 2600 : 		SeLockSubjectContext(&subContext);

  000fe	48 8d 4c 24 50	 lea	 rcx, QWORD PTR subContext$32982[rsp]
  00103	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeLockSubjectContext

; 2601 : 		accessToken=getToken(&subContext);

  00109	48 8d 4c 24 50	 lea	 rcx, QWORD PTR subContext$32982[rsp]
  0010e	e8 00 00 00 00	 call	 getToken
  00113	48 89 44 24 40	 mov	 QWORD PTR accessToken$32983[rsp], rax

; 2602 : 
; 2603 : 		if (!accessToken)

  00118	48 83 7c 24 40
	00		 cmp	 QWORD PTR accessToken$32983[rsp], 0
  0011e	75 0d		 jne	 SHORT $LN15@MountDevic

; 2604 : 		{
; 2605 : 			ntStatus = STATUS_INVALID_PARAMETER;

  00120	c7 44 24 38 0d
	00 00 c0	 mov	 DWORD PTR ntStatus$[rsp], -1073741811 ; ffffffffc000000dH

; 2606 : 		}
; 2607 : 		else

  00128	e9 9b 00 00 00	 jmp	 $LN14@MountDevic
$LN15@MountDevic:

; 2608 : 		{
; 2609 : 			PTOKEN_USER tokenUser;
; 2610 : 
; 2611 : 			ntStatus = SeQueryInformationToken (accessToken, TokenUser, &tokenUser);

  0012d	4c 8d 44 24 70	 lea	 r8, QWORD PTR tokenUser$32987[rsp]
  00132	ba 01 00 00 00	 mov	 edx, 1
  00137	48 8b 4c 24 40	 mov	 rcx, QWORD PTR accessToken$32983[rsp]
  0013c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeQueryInformationToken
  00142	89 44 24 38	 mov	 DWORD PTR ntStatus$[rsp], eax

; 2612 : 			if (NT_SUCCESS (ntStatus))

  00146	83 7c 24 38 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  0014b	7c 7b		 jl	 SHORT $LN14@MountDevic

; 2613 : 			{
; 2614 : 				ULONG sidLength = RtlLengthSid (tokenUser->User.Sid);

  0014d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tokenUser$32987[rsp]
  00152	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00155	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlLengthSid
  0015b	89 44 24 78	 mov	 DWORD PTR sidLength$32990[rsp], eax

; 2615 : 
; 2616 : 				NewExtension->UserSid = TCalloc (sidLength);

  0015f	8b 54 24 78	 mov	 edx, DWORD PTR sidLength$32990[rsp]
  00163	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  00169	33 c9		 xor	 ecx, ecx
  0016b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00171	4c 8b d8	 mov	 r11, rax
  00174	48 8b 44 24 48	 mov	 rax, QWORD PTR NewExtension$32980[rsp]
  00179	4c 89 98 e0 05
	00 00		 mov	 QWORD PTR [rax+1504], r11

; 2617 : 				if (!NewExtension->UserSid)

  00180	48 8b 44 24 48	 mov	 rax, QWORD PTR NewExtension$32980[rsp]
  00185	48 83 b8 e0 05
	00 00 00	 cmp	 QWORD PTR [rax+1504], 0
  0018d	75 0a		 jne	 SHORT $LN12@MountDevic

; 2618 : 					ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0018f	c7 44 24 38 9a
	00 00 c0	 mov	 DWORD PTR ntStatus$[rsp], -1073741670 ; ffffffffc000009aH

; 2619 : 				else

  00197	eb 22		 jmp	 SHORT $LN11@MountDevic
$LN12@MountDevic:

; 2620 : 					ntStatus = RtlCopySid (sidLength, NewExtension->UserSid, tokenUser->User.Sid);

  00199	4c 8b 44 24 70	 mov	 r8, QWORD PTR tokenUser$32987[rsp]
  0019e	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  001a1	48 8b 54 24 48	 mov	 rdx, QWORD PTR NewExtension$32980[rsp]
  001a6	48 8b 92 e0 05
	00 00		 mov	 rdx, QWORD PTR [rdx+1504]
  001ad	8b 4c 24 78	 mov	 ecx, DWORD PTR sidLength$32990[rsp]
  001b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCopySid
  001b7	89 44 24 38	 mov	 DWORD PTR ntStatus$[rsp], eax
$LN11@MountDevic:

; 2621 : 
; 2622 : 				ExFreePool (tokenUser);		// Documented in newer versions of WDK

  001bb	33 d2		 xor	 edx, edx
  001bd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tokenUser$32987[rsp]
  001c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN14@MountDevic:

; 2623 : 			}
; 2624 : 		}
; 2625 : 
; 2626 : 		SeUnlockSubjectContext(&subContext);

  001c8	48 8d 4c 24 50	 lea	 rcx, QWORD PTR subContext$32982[rsp]
  001cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeUnlockSubjectContext

; 2627 : 		SeReleaseSubjectContext (&subContext);

  001d3	48 8d 4c 24 50	 lea	 rcx, QWORD PTR subContext$32982[rsp]
  001d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeReleaseSubjectContext

; 2628 : 
; 2629 : 		if (NT_SUCCESS (ntStatus))

  001de	83 7c 24 38 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  001e3	7c 1b		 jl	 SHORT $LN10@MountDevic

; 2630 : 			ntStatus = TCStartVolumeThread (NewDeviceObject, NewExtension, mount);

  001e5	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR mount$[rsp]
  001ed	48 8b 54 24 48	 mov	 rdx, QWORD PTR NewExtension$32980[rsp]
  001f2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR NewDeviceObject$[rsp]
  001f7	e8 00 00 00 00	 call	 TCStartVolumeThread
  001fc	89 44 24 38	 mov	 DWORD PTR ntStatus$[rsp], eax
$LN10@MountDevic:

; 2631 : 
; 2632 : 		if (!NT_SUCCESS (ntStatus))

  00200	83 7c 24 38 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  00205	7d 2d		 jge	 SHORT $LN9@MountDevic

; 2633 : 		{
; 2634 : 			Dump ("Mount FAILURE NT ERROR, ntStatus = 0x%08x\n", ntStatus);

  00207	8b 54 24 38	 mov	 edx, DWORD PTR ntStatus$[rsp]
  0020b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CL@KIIHMHE@Mount?5FAILURE?5NT?5ERROR?0?5ntStatus@FNODOBFM@
  00212	e8 00 00 00 00	 call	 DbgPrint

; 2635 : 			TCDeleteDeviceObject (NewDeviceObject, NewExtension);

  00217	48 8b 54 24 48	 mov	 rdx, QWORD PTR NewExtension$32980[rsp]
  0021c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR NewDeviceObject$[rsp]
  00221	e8 00 00 00 00	 call	 TCDeleteDeviceObject

; 2636 : 			return ntStatus;

  00226	8b 44 24 38	 mov	 eax, DWORD PTR ntStatus$[rsp]
  0022a	e9 a2 01 00 00	 jmp	 $LN23@MountDevic

; 2637 : 		}
; 2638 : 		else

  0022f	e9 9d 01 00 00	 jmp	 $LN23@MountDevic
$LN9@MountDevic:

; 2639 : 		{
; 2640 : 			if (mount->nReturnCode == 0)

  00234	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  0023c	83 38 00	 cmp	 DWORD PTR [rax], 0
  0023f	0f 85 65 01 00
	00		 jne	 $LN7@MountDevic

; 2641 : 			{
; 2642 : 				HANDLE volumeHandle;
; 2643 : 				PFILE_OBJECT volumeFileObject;
; 2644 : 
; 2645 : 				Dump ("Mount SUCCESS TC code = 0x%08x READ-ONLY = %d\n", mount->nReturnCode, NewExtension->bReadOnly);

  00245	48 8b 44 24 48	 mov	 rax, QWORD PTR NewExtension$32980[rsp]
  0024a	44 8b 80 98 03
	00 00		 mov	 r8d, DWORD PTR [rax+920]
  00251	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  00259	8b 10		 mov	 edx, DWORD PTR [rax]
  0025b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CP@DBOFILAH@Mount?5SUCCESS?5TC?5code?5?$DN?50x?$CF08x?5R@FNODOBFM@
  00262	e8 00 00 00 00	 call	 DbgPrint

; 2646 : 
; 2647 : 				if (NewExtension->bReadOnly)

  00267	4c 8b 5c 24 48	 mov	 r11, QWORD PTR NewExtension$32980[rsp]
  0026c	41 83 bb 98 03
	00 00 00	 cmp	 DWORD PTR [r11+920], 0
  00274	74 13		 je	 SHORT $LN6@MountDevic

; 2648 : 					NewDeviceObject->Characteristics |= FILE_READ_ONLY_DEVICE;

  00276	48 8b 44 24 30	 mov	 rax, QWORD PTR NewDeviceObject$[rsp]
  0027b	8b 48 34	 mov	 ecx, DWORD PTR [rax+52]
  0027e	83 c9 02	 or	 ecx, 2
  00281	48 8b 44 24 30	 mov	 rax, QWORD PTR NewDeviceObject$[rsp]
  00286	89 48 34	 mov	 DWORD PTR [rax+52], ecx
$LN6@MountDevic:

; 2649 : 
; 2650 : 				NewDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

  00289	48 8b 44 24 30	 mov	 rax, QWORD PTR NewDeviceObject$[rsp]
  0028e	8b 48 30	 mov	 ecx, DWORD PTR [rax+48]
  00291	81 e1 7f ff ff
	ff		 and	 ecx, -129		; ffffff7fH
  00297	48 8b 44 24 30	 mov	 rax, QWORD PTR NewDeviceObject$[rsp]
  0029c	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 2651 : 
; 2652 : 				NewExtension->UniqueVolumeId = LastUniqueVolumeId++;

  0029f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR NewExtension$32980[rsp]
  002a4	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR LastUniqueVolumeId
  002aa	89 41 10	 mov	 DWORD PTR [rcx+16], eax
  002ad	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR LastUniqueVolumeId
  002b3	83 c0 01	 add	 eax, 1
  002b6	89 05 00 00 00
	00		 mov	 DWORD PTR LastUniqueVolumeId, eax

; 2653 : 
; 2654 : 				if (mount->bMountManager)

  002bc	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  002c4	83 b8 78 02 00
	00 00		 cmp	 DWORD PTR [rax+632], 0
  002cb	74 0d		 je	 SHORT $LN5@MountDevic

; 2655 : 					MountManagerMount (mount);

  002cd	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR mount$[rsp]
  002d5	e8 00 00 00 00	 call	 MountManagerMount
$LN5@MountDevic:

; 2656 : 
; 2657 : 				NewExtension->bMountManager = mount->bMountManager;

  002da	48 8b 4c 24 48	 mov	 rcx, QWORD PTR NewExtension$32980[rsp]
  002df	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  002e7	8b 80 78 02 00
	00		 mov	 eax, DWORD PTR [rax+632]
  002ed	89 81 a8 03 00
	00		 mov	 DWORD PTR [rcx+936], eax

; 2658 : 
; 2659 : 				// We create symbolic link even if mount manager is notified of
; 2660 : 				// arriving volume as it apparently sometimes fails to create the link
; 2661 : 				CreateDriveLink (mount->nDosDriveNo);

  002f3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  002fb	8b 88 64 02 00
	00		 mov	 ecx, DWORD PTR [rax+612]
  00301	e8 00 00 00 00	 call	 CreateDriveLink

; 2662 : 
; 2663 : 				mount->FilesystemDirty = FALSE;

  00306	4c 8b 9c 24 b8
	00 00 00	 mov	 r11, QWORD PTR mount$[rsp]
  0030e	41 c7 43 04 00
	00 00 00	 mov	 DWORD PTR [r11+4], 0

; 2664 : 
; 2665 : 				if (NT_SUCCESS (TCOpenFsVolume (NewExtension, &volumeHandle, &volumeFileObject)))

  00316	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR volumeFileObject$33003[rsp]
  0031e	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR volumeHandle$33002[rsp]
  00326	48 8b 4c 24 48	 mov	 rcx, QWORD PTR NewExtension$32980[rsp]
  0032b	e8 00 00 00 00	 call	 TCOpenFsVolume
  00330	85 c0		 test	 eax, eax
  00332	7c 74		 jl	 SHORT $LN4@MountDevic

; 2666 : 				{
; 2667 : 					__try
; 2668 : 					{
; 2669 : 						ULONG fsStatus;
; 2670 : 
; 2671 : 						if (NT_SUCCESS (TCFsctlCall (volumeFileObject, FSCTL_IS_VOLUME_DIRTY, NULL, 0, &fsStatus, sizeof (fsStatus)))
; 2672 : 							&& (fsStatus & VOLUME_IS_DIRTY))

  00334	c7 44 24 28 04
	00 00 00	 mov	 DWORD PTR [rsp+40], 4
  0033c	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR fsStatus$33010[rsp]
  00344	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00349	45 33 c9	 xor	 r9d, r9d
  0034c	45 33 c0	 xor	 r8d, r8d
  0034f	ba 78 00 09 00	 mov	 edx, 589944		; 00090078H
  00354	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR volumeFileObject$33003[rsp]
  0035c	e8 00 00 00 00	 call	 TCFsctlCall
  00361	85 c0		 test	 eax, eax
  00363	7c 1d		 jl	 SHORT $LN2@MountDevic
  00365	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR fsStatus$33010[rsp]
  0036c	83 e0 01	 and	 eax, 1
  0036f	85 c0		 test	 eax, eax
  00371	74 0f		 je	 SHORT $LN2@MountDevic

; 2673 : 						{
; 2674 : 							mount->FilesystemDirty = TRUE;

  00373	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  0037b	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [rax+4], 1
$LN2@MountDevic:

; 2675 : 						}
; 2676 : 					}

  00382	eb 0f		 jmp	 SHORT $LN27@MountDevic
$LN25@MountDevic:

; 2677 : 					__except (EXCEPTION_EXECUTE_HANDLER)
; 2678 : 					{
; 2679 : 						mount->FilesystemDirty = TRUE;

  00384	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  0038c	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [rax+4], 1
$LN27@MountDevic:

; 2680 : 					}
; 2681 : 
; 2682 : 
; 2683 : 					TCCloseFsVolume (volumeHandle, volumeFileObject);

  00393	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR volumeFileObject$33003[rsp]
  0039b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR volumeHandle$33002[rsp]
  003a3	e8 00 00 00 00	 call	 TCCloseFsVolume
$LN4@MountDevic:

; 2684 : 				}
; 2685 : 			}
; 2686 : 			else

  003a8	eb 25		 jmp	 SHORT $LN1@MountDevic
$LN7@MountDevic:

; 2687 : 			{
; 2688 : 				Dump ("Mount FAILURE TC code = 0x%08x\n", mount->nReturnCode);

  003aa	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR mount$[rsp]
  003b2	8b 10		 mov	 edx, DWORD PTR [rax]
  003b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@IJMBHFOD@Mount?5FAILURE?5TC?5code?5?$DN?50x?$CF08x?6?$AA@FNODOBFM@
  003bb	e8 00 00 00 00	 call	 DbgPrint

; 2689 : 				TCDeleteDeviceObject (NewDeviceObject, NewExtension);

  003c0	48 8b 54 24 48	 mov	 rdx, QWORD PTR NewExtension$32980[rsp]
  003c5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR NewDeviceObject$[rsp]
  003ca	e8 00 00 00 00	 call	 TCDeleteDeviceObject
$LN1@MountDevic:

; 2690 : 			}
; 2691 : 			
; 2692 : 			return STATUS_SUCCESS;

  003cf	33 c0		 xor	 eax, eax
$LN23@MountDevic:

; 2693 : 		}
; 2694 : 	}
; 2695 : }

  003d1	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  003d8	c3		 ret	 0
MountDevice ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
NewDeviceObject$ = 48
ntStatus$ = 56
accessToken$32983 = 64
NewExtension$32980 = 72
subContext$32982 = 80
tokenUser$32987 = 112
sidLength$32990 = 120
volumeFileObject$33003 = 128
volumeHandle$33002 = 136
fsStatus$33010 = 144
DeviceObject$ = 176
mount$ = 184
MountDevice$filt$0 PROC
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b ea	 mov	 rbp, rdx
$LN24@MountDevic@2:

; 2677 : 					__except (EXCEPTION_EXECUTE_HANDLER)

  00012	b8 01 00 00 00	 mov	 eax, 1
$LN26@MountDevic@2:
  00017	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
MountDevice$filt$0 ENDP
text$x	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	ProcessMainDeviceControlIrp
;	COMDAT pdata
pdata	SEGMENT
$pdata$ProcessMainDeviceControlIrp DD imagerel $LN185
	DD	imagerel $LN185+8885
	DD	imagerel $unwind$ProcessMainDeviceControlIrp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ProcessMainDeviceControlIrp DD 042a19H
	DD	0b30118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	0588H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ProcessMainDeviceControlIrp
_TEXT	SEGMENT
ntStatus$ = 96
irpSp$ = 104
tmp$31795 = 112
deviceObjectCount$31807 = 116
drive$31818 = 120
FullFileName$31834 = 128
access$31837 = 144
offset$31836 = 152
opentest$31830 = 160
ObjectAttributes$31832 = 168
IoStatus$31835 = 216
NtFileHandle$31833 = 232
readBuffer$31852 = 240
i$31863 = 248
FullFileName$31893 = 256
readBuffer$31896 = 288
offset$31895 = 800
ObjectAttributes$31891 = 808
request$31889 = 856
IoStatus$31894 = 864
NtFileHandle$31892 = 880
i$31913 = 888
i$31915 = 896
list$31952 = 904
drive$31955 = 912
ListDevice$31954 = 920
ListExtension$31959 = 928
ListDevice$31981 = 936
prop$31979 = 944
ListExtension$31984 = 952
resolve$31994 = 960
ntStatus$31996 = 968
info$32001 = 976
pi$32003 = 992
ntStatus$32004 = 1136
lengthInfo$32013 = 1144
g$32026 = 1152
ntStatus$32028 = 1160
deviceObject$32039 = 1168
fileObject$32038 = 1176
name$32037 = 1184
request$32034 = 1200
status$32036 = 1208
mount$32054 = 1216
burnc$32065 = 1224
burnm$32063 = 1232
burnc$32074 = 1240
burnm$32072 = 1248
unmount$32081 = 1256
ListDevice$32083 = 1264
ListExtension$32085 = 1272
unmount$32093 = 1280
flags$32119 = 1288
request$32132 = 1296
tv67 = 1304
tv249 = 1312
tv262 = 1320
tv434 = 1328
tv443 = 1332
tv465 = 1336
tv471 = 1344
tv472 = 1352
tv473 = 1360
tv558 = 1368
tv560 = 1376
tv561 = 1384
tv562 = 1392
tv599 = 1396
tv609 = 1400
tv688 = 1404
tv912 = 1408
tv982 = 1412
__$ArrayPad$ = 1416
DeviceObject$ = 1456
Extension$ = 1464
Irp$ = 1472
ProcessMainDeviceControlIrp PROC			; COMDAT

; 808  : {

$LN185:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 98 05
	00 00		 sub	 rsp, 1432		; 00000598H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 88
	05 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 809  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);

  0002a	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00032	e8 00 00 00 00	 call	 IoGetCurrentIrpStackLocation
  00037	48 89 44 24 68	 mov	 QWORD PTR irpSp$[rsp], rax

; 810  : 	NTSTATUS ntStatus;
; 811  : 
; 812  : 	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  0003c	48 8b 44 24 68	 mov	 rax, QWORD PTR irpSp$[rsp]
  00041	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00044	89 84 24 18 05
	00 00		 mov	 DWORD PTR tv67[rsp], eax
  0004b	81 bc 24 18 05
	00 00 04 20 22
	00		 cmp	 DWORD PTR tv67[rsp], 2236420 ; 00222004H
  00056	77 30		 ja	 SHORT $LN180@ProcessMai
  00058	81 bc 24 18 05
	00 00 04 20 22
	00		 cmp	 DWORD PTR tv67[rsp], 2236420 ; 00222004H
  00063	74 69		 je	 SHORT $LN159@ProcessMai
  00065	81 bc 24 18 05
	00 00 04 20 07
	00		 cmp	 DWORD PTR tv67[rsp], 466948 ; 00072004H
  00070	0f 84 64 0f 00
	00		 je	 $LN79@ProcessMai
  00076	81 bc 24 18 05
	00 00 18 20 07
	00		 cmp	 DWORD PTR tv67[rsp], 466968 ; 00072018H
  00081	74 4b		 je	 SHORT $LN159@ProcessMai
  00083	e9 d9 1f 00 00	 jmp	 $LN6@ProcessMai
$LN180@ProcessMai:
  00088	8b 84 24 18 05
	00 00		 mov	 eax, DWORD PTR tv67[rsp]
  0008f	2d 08 20 22 00	 sub	 eax, 2236424		; 00222008H
  00094	89 84 24 18 05
	00 00		 mov	 DWORD PTR tv67[rsp], eax
  0009b	81 bc 24 18 05
	00 00 90 00 00
	00		 cmp	 DWORD PTR tv67[rsp], 144 ; 00000090H
  000a6	0f 87 b5 1f 00
	00		 ja	 $LN6@ProcessMai
  000ac	8b 84 24 18 05
	00 00		 mov	 eax, DWORD PTR tv67[rsp]
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000ba	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN183@ProcessMai[rcx+rax]
  000c2	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN184@ProcessMai[rcx+rax*4]
  000c9	48 03 c1	 add	 rax, rcx
  000cc	ff e0		 jmp	 rax
$LN159@ProcessMai:

; 813  : 	{
; 814  : 	case TC_IOCTL_GET_DRIVER_VERSION:
; 815  : 	case TC_IOCTL_LEGACY_GET_DRIVER_VERSION:
; 816  : 		if (ValidateIOBufferSize (Irp, sizeof (LONG), ValidateOutput))

  000ce	41 b8 01 00 00
	00		 mov	 r8d, 1
  000d4	ba 04 00 00 00	 mov	 edx, 4
  000d9	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  000e1	e8 00 00 00 00	 call	 ValidateIOBufferSize
  000e6	85 c0		 test	 eax, eax
  000e8	74 39		 je	 SHORT $LN158@ProcessMai

; 817  : 		{
; 818  : 			LONG tmp = VERSION_NUM;

  000ea	c7 44 24 70 41
	07 00 00	 mov	 DWORD PTR tmp$31795[rsp], 1857 ; 00000741H

; 819  : 			memcpy (Irp->AssociatedIrp.SystemBuffer, &tmp, 4);

  000f2	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  000fa	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000fe	8b 44 24 70	 mov	 eax, DWORD PTR tmp$31795[rsp]
  00102	89 01		 mov	 DWORD PTR [rcx], eax

; 820  : 			Irp->IoStatus.Information = sizeof (LONG);

  00104	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0010c	48 c7 40 38 04
	00 00 00	 mov	 QWORD PTR [rax+56], 4

; 821  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00114	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0011c	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0
$LN158@ProcessMai:

; 822  : 		}
; 823  : 		break;

  00123	e9 53 1f 00 00	 jmp	 $LN160@ProcessMai
$LN157@ProcessMai:

; 824  : 
; 825  : 	case TC_IOCTL_GET_DEVICE_REFCOUNT:
; 826  : 		if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))

  00128	41 b8 01 00 00
	00		 mov	 r8d, 1
  0012e	ba 04 00 00 00	 mov	 edx, 4
  00133	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  0013b	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00140	85 c0		 test	 eax, eax
  00142	74 38		 je	 SHORT $LN156@ProcessMai

; 827  : 		{
; 828  : 			*(int *) Irp->AssociatedIrp.SystemBuffer = DeviceObject->ReferenceCount;

  00144	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  0014c	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00150	48 8b 84 24 b0
	05 00 00	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  00158	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0015b	89 01		 mov	 DWORD PTR [rcx], eax

; 829  : 			Irp->IoStatus.Information = sizeof (int);

  0015d	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00165	48 c7 40 38 04
	00 00 00	 mov	 QWORD PTR [rax+56], 4

; 830  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  0016d	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00175	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0
$LN156@ProcessMai:

; 831  : 		}
; 832  : 		break;

  0017c	e9 fa 1e 00 00	 jmp	 $LN160@ProcessMai
$LN155@ProcessMai:

; 833  : 
; 834  : 	case TC_IOCTL_IS_DRIVER_UNLOAD_DISABLED:
; 835  : 		if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))

  00181	41 b8 01 00 00
	00		 mov	 r8d, 1
  00187	ba 04 00 00 00	 mov	 edx, 4
  0018c	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00194	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00199	85 c0		 test	 eax, eax
  0019b	74 72		 je	 SHORT $LN154@ProcessMai

; 836  : 		{
; 837  : 			LONG deviceObjectCount = 0;

  0019d	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR deviceObjectCount$31807[rsp], 0

; 838  : 
; 839  : 			*(int *) Irp->AssociatedIrp.SystemBuffer = DriverUnloadDisabled;

  001a5	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  001ad	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  001b1	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR DriverUnloadDisabled
  001b7	89 01		 mov	 DWORD PTR [rcx], eax

; 840  : 
; 841  : 			if (IoEnumerateDeviceObjectList (TCDriverObject, NULL, 0, &deviceObjectCount) == STATUS_BUFFER_TOO_SMALL && deviceObjectCount > 1)

  001b9	4c 8d 4c 24 74	 lea	 r9, QWORD PTR deviceObjectCount$31807[rsp]
  001be	45 33 c0	 xor	 r8d, r8d
  001c1	33 d2		 xor	 edx, edx
  001c3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR TCDriverObject
  001ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoEnumerateDeviceObjectList
  001d0	3d 23 00 00 c0	 cmp	 eax, -1073741789	; ffffffffc0000023H
  001d5	75 19		 jne	 SHORT $LN153@ProcessMai
  001d7	83 7c 24 74 01	 cmp	 DWORD PTR deviceObjectCount$31807[rsp], 1
  001dc	7e 12		 jle	 SHORT $LN153@ProcessMai

; 842  : 				*(int *) Irp->AssociatedIrp.SystemBuffer = TRUE;

  001de	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  001e6	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001ea	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1
$LN153@ProcessMai:

; 843  : 
; 844  : 			Irp->IoStatus.Information = sizeof (int);

  001f0	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  001f8	48 c7 40 38 04
	00 00 00	 mov	 QWORD PTR [rax+56], 4

; 845  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00200	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00208	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0
$LN154@ProcessMai:

; 846  : 		}
; 847  : 		break;

  0020f	e9 67 1e 00 00	 jmp	 $LN160@ProcessMai
$LN152@ProcessMai:

; 848  : 
; 849  : 	case TC_IOCTL_IS_ANY_VOLUME_MOUNTED:
; 850  : 		if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))

  00214	41 b8 01 00 00
	00		 mov	 r8d, 1
  0021a	ba 04 00 00 00	 mov	 edx, 4
  0021f	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00227	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0022c	85 c0		 test	 eax, eax
  0022e	0f 84 8c 00 00
	00		 je	 $LN151@ProcessMai

; 851  : 		{
; 852  : 			int drive;
; 853  : 			*(int *) Irp->AssociatedIrp.SystemBuffer = 0;

  00234	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0023c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00240	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 854  : 
; 855  : 			for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)

  00246	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR drive$31818[rsp], 0
  0024e	eb 0b		 jmp	 SHORT $LN150@ProcessMai
$LN149@ProcessMai:
  00250	8b 44 24 78	 mov	 eax, DWORD PTR drive$31818[rsp]
  00254	83 c0 01	 add	 eax, 1
  00257	89 44 24 78	 mov	 DWORD PTR drive$31818[rsp], eax
$LN150@ProcessMai:
  0025b	83 7c 24 78 19	 cmp	 DWORD PTR drive$31818[rsp], 25
  00260	7f 24		 jg	 SHORT $LN148@ProcessMai

; 856  : 			{
; 857  : 				if (GetVirtualVolumeDeviceObject (drive))

  00262	8b 4c 24 78	 mov	 ecx, DWORD PTR drive$31818[rsp]
  00266	e8 00 00 00 00	 call	 GetVirtualVolumeDeviceObject
  0026b	48 85 c0	 test	 rax, rax
  0026e	74 14		 je	 SHORT $LN147@ProcessMai

; 858  : 				{
; 859  : 					*(int *) Irp->AssociatedIrp.SystemBuffer = 1;

  00270	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00278	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0027c	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 860  : 					break;

  00282	eb 02		 jmp	 SHORT $LN148@ProcessMai
$LN147@ProcessMai:

; 861  : 				}
; 862  : 			}

  00284	eb ca		 jmp	 SHORT $LN149@ProcessMai
$LN148@ProcessMai:

; 863  : 
; 864  : 			if (IsBootDriveMounted())

  00286	e8 00 00 00 00	 call	 IsBootDriveMounted
  0028b	85 c0		 test	 eax, eax
  0028d	74 12		 je	 SHORT $LN146@ProcessMai

; 865  : 				*(int *) Irp->AssociatedIrp.SystemBuffer = 1;

  0028f	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00297	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0029b	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1
$LN146@ProcessMai:

; 866  : 
; 867  : 			Irp->IoStatus.Information = sizeof (int);

  002a1	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  002a9	48 c7 40 38 04
	00 00 00	 mov	 QWORD PTR [rax+56], 4

; 868  : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  002b1	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  002b9	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0
$LN151@ProcessMai:

; 869  : 		}
; 870  : 		break;

  002c0	e9 b6 1d 00 00	 jmp	 $LN160@ProcessMai
$LN145@ProcessMai:

; 871  : 
; 872  : 	case TC_IOCTL_OPEN_TEST:
; 873  : 		{
; 874  : 			OPEN_TEST_STRUCT *opentest = (OPEN_TEST_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  002c5	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  002cd	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  002d1	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR opentest$31830[rsp], rax

; 875  : 			OBJECT_ATTRIBUTES ObjectAttributes;
; 876  : 			HANDLE NtFileHandle;
; 877  : 			UNICODE_STRING FullFileName;
; 878  : 			IO_STATUS_BLOCK IoStatus;
; 879  : 			LARGE_INTEGER offset;
; 880  : 			ACCESS_MASK access = FILE_READ_ATTRIBUTES;

  002d9	c7 84 24 90 00
	00 00 80 00 00
	00		 mov	 DWORD PTR access$31837[rsp], 128 ; 00000080H

; 881  : 
; 882  : 			if (!ValidateIOBufferSize (Irp, sizeof (OPEN_TEST_STRUCT), ValidateInputOutput))

  002e4	41 b8 02 00 00
	00		 mov	 r8d, 2
  002ea	ba 18 02 00 00	 mov	 edx, 536		; 00000218H
  002ef	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  002f7	e8 00 00 00 00	 call	 ValidateIOBufferSize
  002fc	85 c0		 test	 eax, eax
  002fe	75 05		 jne	 SHORT $LN144@ProcessMai

; 883  : 				break;

  00300	e9 76 1d 00 00	 jmp	 $LN160@ProcessMai
$LN144@ProcessMai:

; 884  : 
; 885  : 			EnsureNullTerminatedString (opentest->wszFileName, sizeof (opentest->wszFileName));

  00305	ba 08 02 00 00	 mov	 edx, 520		; 00000208H
  0030a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR opentest$31830[rsp]
  00312	e8 00 00 00 00	 call	 EnsureNullTerminatedString

; 886  : 			RtlInitUnicodeString (&FullFileName, opentest->wszFileName);

  00317	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR opentest$31830[rsp]
  0031f	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR FullFileName$31834[rsp]
  00327	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 887  : 
; 888  : 			InitializeObjectAttributes (&ObjectAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

  0032d	c7 84 24 a8 00
	00 00 30 00 00
	00		 mov	 DWORD PTR ObjectAttributes$31832[rsp], 48 ; 00000030H
  00338	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR ObjectAttributes$31832[rsp+8], 0
  00344	c7 84 24 c0 00
	00 00 40 02 00
	00		 mov	 DWORD PTR ObjectAttributes$31832[rsp+24], 576 ; 00000240H
  0034f	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR FullFileName$31834[rsp]
  00357	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR ObjectAttributes$31832[rsp+16], rax
  0035f	48 c7 84 24 c8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR ObjectAttributes$31832[rsp+32], 0
  0036b	48 c7 84 24 d0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR ObjectAttributes$31832[rsp+40], 0

; 889  : 
; 890  : 			if (opentest->bDetectTCBootLoader || opentest->DetectFilesystem)

  00377	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR opentest$31830[rsp]
  0037f	83 b8 08 02 00
	00 00		 cmp	 DWORD PTR [rax+520], 0
  00386	75 11		 jne	 SHORT $LN142@ProcessMai
  00388	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR opentest$31830[rsp]
  00390	83 b8 10 02 00
	00 00		 cmp	 DWORD PTR [rax+528], 0
  00397	74 11		 je	 SHORT $LN143@ProcessMai
$LN142@ProcessMai:

; 891  : 				access |= FILE_READ_DATA;

  00399	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR access$31837[rsp]
  003a0	83 c8 01	 or	 eax, 1
  003a3	89 84 24 90 00
	00 00		 mov	 DWORD PTR access$31837[rsp], eax
$LN143@ProcessMai:

; 892  : 
; 893  : 			ntStatus = ZwCreateFile (&NtFileHandle,
; 894  : 						 SYNCHRONIZE | access, &ObjectAttributes, &IoStatus, NULL,
; 895  : 						 0, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);

  003aa	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR access$31837[rsp]
  003b1	81 ca 00 00 10
	00		 or	 edx, 1048576		; 00100000H
  003b7	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR [rsp+80], 0
  003bf	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR [rsp+72], 0
  003c8	c7 44 24 40 20
	00 00 00	 mov	 DWORD PTR [rsp+64], 32	; 00000020H
  003d0	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR [rsp+56], 1
  003d8	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR [rsp+48], 3
  003e0	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  003e8	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  003f1	4c 8d 8c 24 d8
	00 00 00	 lea	 r9, QWORD PTR IoStatus$31835[rsp]
  003f9	4c 8d 84 24 a8
	00 00 00	 lea	 r8, QWORD PTR ObjectAttributes$31832[rsp]
  00401	48 8d 8c 24 e8
	00 00 00	 lea	 rcx, QWORD PTR NtFileHandle$31833[rsp]
  00409	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwCreateFile
  0040f	89 44 24 60	 mov	 DWORD PTR ntStatus$[rsp], eax

; 896  : 
; 897  : 			if (NT_SUCCESS (ntStatus))

  00413	83 7c 24 60 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  00418	0f 8c d7 02 00
	00		 jl	 $LN141@ProcessMai

; 898  : 			{
; 899  : 				opentest->TCBootLoaderDetected = FALSE;

  0041e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR opentest$31830[rsp]
  00426	c7 80 0c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+524], 0

; 900  : 				opentest->FilesystemDetected = FALSE;

  00430	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR opentest$31830[rsp]
  00438	c7 80 14 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+532], 0

; 901  : 
; 902  : 				if (opentest->bDetectTCBootLoader || opentest->DetectFilesystem)

  00442	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR opentest$31830[rsp]
  0044a	83 b8 08 02 00
	00 00		 cmp	 DWORD PTR [rax+520], 0
  00451	75 15		 jne	 SHORT $LN139@ProcessMai
  00453	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR opentest$31830[rsp]
  0045b	83 b8 10 02 00
	00 00		 cmp	 DWORD PTR [rax+528], 0
  00462	0f 84 6b 02 00
	00		 je	 $LN140@ProcessMai
$LN139@ProcessMai:

; 903  : 				{
; 904  : 					byte *readBuffer = TCalloc (TC_MAX_VOLUME_SECTOR_SIZE);

  00468	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  0046e	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  00473	33 c9		 xor	 ecx, ecx
  00475	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  0047b	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR readBuffer$31852[rsp], rax

; 905  : 					if (!readBuffer)

  00483	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR readBuffer$31852[rsp], 0
  0048c	75 0d		 jne	 SHORT $LN138@ProcessMai

; 906  : 					{
; 907  : 						ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0048e	c7 44 24 60 9a
	00 00 c0	 mov	 DWORD PTR ntStatus$[rsp], -1073741670 ; ffffffffc000009aH

; 908  : 					}
; 909  : 					else

  00496	e9 38 02 00 00	 jmp	 $LN137@ProcessMai
$LN138@ProcessMai:

; 910  : 					{
; 911  : 						// Determine if the first sector contains a portion of the TrueCrypt Boot Loader
; 912  : 
; 913  : 						offset.QuadPart = 0;

  0049b	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR offset$31836[rsp], 0

; 914  : 
; 915  : 						ntStatus = ZwReadFile (NtFileHandle,
; 916  : 							NULL,
; 917  : 							NULL,
; 918  : 							NULL,
; 919  : 							&IoStatus,
; 920  : 							readBuffer,
; 921  : 							TC_MAX_VOLUME_SECTOR_SIZE,
; 922  : 							&offset,
; 923  : 							NULL);

  004a7	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  004b0	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR offset$31836[rsp]
  004b8	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  004bd	c7 44 24 30 00
	10 00 00	 mov	 DWORD PTR [rsp+48], 4096 ; 00001000H
  004c5	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR readBuffer$31852[rsp]
  004cd	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004d2	48 8d 84 24 d8
	00 00 00	 lea	 rax, QWORD PTR IoStatus$31835[rsp]
  004da	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004df	45 33 c9	 xor	 r9d, r9d
  004e2	45 33 c0	 xor	 r8d, r8d
  004e5	33 d2		 xor	 edx, edx
  004e7	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR NtFileHandle$31833[rsp]
  004ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwReadFile
  004f5	89 44 24 60	 mov	 DWORD PTR ntStatus$[rsp], eax

; 924  : 
; 925  : 						if (NT_SUCCESS (ntStatus))

  004f9	83 7c 24 60 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  004fe	0f 8c bc 01 00
	00		 jl	 $LN136@ProcessMai

; 926  : 						{
; 927  : 							size_t i;
; 928  : 
; 929  : 							if (opentest->bDetectTCBootLoader && IoStatus.Information >= TC_SECTOR_SIZE_BIOS)

  00504	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR opentest$31830[rsp]
  0050c	83 b8 08 02 00
	00 00		 cmp	 DWORD PTR [rax+520], 0
  00513	0f 84 0b 01 00
	00		 je	 $LN135@ProcessMai
  00519	48 81 bc 24 e0
	00 00 00 00 02
	00 00		 cmp	 QWORD PTR IoStatus$31835[rsp+8], 512 ; 00000200H
  00525	0f 82 f9 00 00
	00		 jb	 $LN135@ProcessMai

; 930  : 							{
; 931  : 								// Search for the string "CipherShed"
; 932  : 								for (i = 0; i < TC_SECTOR_SIZE_BIOS - strlen (TC_APP_NAME); ++i)

  0052b	48 c7 84 24 f8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i$31863[rsp], 0
  00537	eb 14		 jmp	 SHORT $LN134@ProcessMai
$LN133@ProcessMai:
  00539	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR i$31863[rsp]
  00541	48 83 c0 01	 add	 rax, 1
  00545	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR i$31863[rsp], rax
$LN134@ProcessMai:
  0054d	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00552	48 83 e8 0a	 sub	 rax, 10
  00556	48 39 84 24 f8
	00 00 00	 cmp	 QWORD PTR i$31863[rsp], rax
  0055e	73 3f		 jae	 SHORT $LN132@ProcessMai

; 933  : 								{
; 934  : 									if (memcmp (readBuffer + i, TC_APP_NAME, strlen (TC_APP_NAME)) == 0)

  00560	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR i$31863[rsp]
  00568	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR readBuffer$31852[rsp]
  00570	48 03 c8	 add	 rcx, rax
  00573	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00579	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@FEEFGEIL@CipherShed?$AA@FNODOBFM@
  00580	e8 00 00 00 00	 call	 memcmp
  00585	85 c0		 test	 eax, eax
  00587	75 14		 jne	 SHORT $LN131@ProcessMai

; 935  : 									{
; 936  : 										opentest->TCBootLoaderDetected = TRUE;

  00589	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR opentest$31830[rsp]
  00591	c7 80 0c 02 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+524], 1

; 937  : 										break;

  0059b	eb 02		 jmp	 SHORT $LN132@ProcessMai
$LN131@ProcessMai:

; 938  : 									}
; 939  : 								}

  0059d	eb 9a		 jmp	 SHORT $LN133@ProcessMai
$LN132@ProcessMai:

; 940  : 
; 941  : 								// Search for the string "TrueCrypt"
; 942  : 								if (!(opentest->TCBootLoaderDetected))

  0059f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR opentest$31830[rsp]
  005a7	83 b8 0c 02 00
	00 00		 cmp	 DWORD PTR [rax+524], 0
  005ae	75 74		 jne	 SHORT $LN130@ProcessMai

; 943  : 								for (i = 0; i < TC_SECTOR_SIZE_BIOS - strlen (TC_APP_NAME_LEGACY); ++i)

  005b0	48 c7 84 24 f8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i$31863[rsp], 0
  005bc	eb 14		 jmp	 SHORT $LN129@ProcessMai
$LN128@ProcessMai:
  005be	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR i$31863[rsp]
  005c6	48 83 c0 01	 add	 rax, 1
  005ca	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR i$31863[rsp], rax
$LN129@ProcessMai:
  005d2	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  005d7	48 83 e8 09	 sub	 rax, 9
  005db	48 39 84 24 f8
	00 00 00	 cmp	 QWORD PTR i$31863[rsp], rax
  005e3	73 3f		 jae	 SHORT $LN127@ProcessMai

; 944  : 								{
; 945  : 									if (memcmp (readBuffer + i, TC_APP_NAME_LEGACY, strlen (TC_APP_NAME_LEGACY)) == 0)

  005e5	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR i$31863[rsp]
  005ed	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR readBuffer$31852[rsp]
  005f5	48 03 c8	 add	 rcx, rax
  005f8	41 b8 09 00 00
	00		 mov	 r8d, 9
  005fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09EMKKFGIH@TrueCrypt?$AA@FNODOBFM@
  00605	e8 00 00 00 00	 call	 memcmp
  0060a	85 c0		 test	 eax, eax
  0060c	75 14		 jne	 SHORT $LN126@ProcessMai

; 946  : 									{
; 947  : 										opentest->TCBootLoaderDetected = TRUE;

  0060e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR opentest$31830[rsp]
  00616	c7 80 0c 02 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+524], 1

; 948  : 										break;

  00620	eb 02		 jmp	 SHORT $LN127@ProcessMai
$LN126@ProcessMai:

; 949  : 									}
; 950  : 								}

  00622	eb 9a		 jmp	 SHORT $LN128@ProcessMai
$LN127@ProcessMai:
$LN130@ProcessMai:
$LN135@ProcessMai:

; 951  : 							}
; 952  : 
; 953  : 							if (opentest->DetectFilesystem && IoStatus.Information >= sizeof (int64))

  00624	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR opentest$31830[rsp]
  0062c	83 b8 10 02 00
	00 00		 cmp	 DWORD PTR [rax+528], 0
  00633	0f 84 87 00 00
	00		 je	 $LN125@ProcessMai
  00639	48 83 bc 24 e0
	00 00 00 08	 cmp	 QWORD PTR IoStatus$31835[rsp+8], 8
  00642	72 7c		 jb	 SHORT $LN125@ProcessMai

; 954  : 							{
; 955  : 								switch (BE64 (*(uint64 *) readBuffer))

  00644	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR readBuffer$31852[rsp]
  0064c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0064f	e8 00 00 00 00	 call	 MirrorBytes64
  00654	48 89 84 24 20
	05 00 00	 mov	 QWORD PTR tv249[rsp], rax
  0065c	48 b8 53 4f 44
	53 4d 90 3c eb	 mov	 rax, -1496162314409980077 ; eb3c904d53444f53H
  00666	48 39 84 24 20
	05 00 00	 cmp	 QWORD PTR tv249[rsp], rax
  0066e	74 3e		 je	 SHORT $LN122@ProcessMai
  00670	48 b8 20 53 46
	54 4e 90 52 eb	 mov	 rax, -1489969860610469088 ; eb52904e54465320H
  0067a	48 39 84 24 20
	05 00 00	 cmp	 QWORD PTR tv249[rsp], rax
  00682	74 2a		 je	 SHORT $LN122@ProcessMai
  00684	48 b8 53 4f 44
	53 4d 90 58 eb	 mov	 rax, -1488281015062081709 ; eb58904d53444f53H
  0068e	48 39 84 24 20
	05 00 00	 cmp	 QWORD PTR tv249[rsp], rax
  00696	74 16		 je	 SHORT $LN122@ProcessMai
  00698	48 b8 54 41 46
	58 45 90 76 eb	 mov	 rax, -1479836800036486828 ; eb76904558464154H
  006a2	48 39 84 24 20
	05 00 00	 cmp	 QWORD PTR tv249[rsp], rax
  006aa	74 02		 je	 SHORT $LN122@ProcessMai
  006ac	eb 12		 jmp	 SHORT $LN123@ProcessMai
$LN122@ProcessMai:

; 956  : 								{
; 957  : 								case 0xEB52904E54465320: // NTFS
; 958  : 								case 0xEB3C904D53444F53: // FAT16
; 959  : 								case 0xEB58904D53444F53: // FAT32
; 960  : 								case 0xEB76904558464154: // exFAT
; 961  : 
; 962  : 									opentest->FilesystemDetected = TRUE;

  006ae	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR opentest$31830[rsp]
  006b6	c7 80 14 02 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+532], 1
$LN123@ProcessMai:
$LN125@ProcessMai:
$LN136@ProcessMai:

; 963  : 									break;
; 964  : 								}
; 965  : 							}
; 966  : 						}
; 967  : 
; 968  : 						TCfree (readBuffer);

  006c0	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  006c5	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR readBuffer$31852[rsp]
  006cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN137@ProcessMai:
$LN140@ProcessMai:

; 969  : 					}
; 970  : 				}
; 971  : 
; 972  : 				ZwClose (NtFileHandle);

  006d3	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR NtFileHandle$31833[rsp]
  006db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 973  : 				Dump ("Open test on file %ls success.\n", opentest->wszFileName);

  006e1	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR opentest$31830[rsp]
  006e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@FCHCHJKN@Open?5test?5on?5file?5?$CFls?5success?4?6?$AA@FNODOBFM@
  006f0	e8 00 00 00 00	 call	 DbgPrint
$LN141@ProcessMai:

; 974  : 			}
; 975  : 			else
; 976  : 			{
; 977  : #if 0
; 978  : 				Dump ("Open test on file %ls failed NTSTATUS 0x%08x\n", opentest->wszFileName, ntStatus);
; 979  : #endif
; 980  : 			}
; 981  : 
; 982  : 			Irp->IoStatus.Information = NT_SUCCESS (ntStatus) ? sizeof (OPEN_TEST_STRUCT) : 0;

  006f5	83 7c 24 60 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  006fa	7c 0e		 jl	 SHORT $LN164@ProcessMai
  006fc	48 c7 84 24 28
	05 00 00 18 02
	00 00		 mov	 QWORD PTR tv262[rsp], 536 ; 00000218H
  00708	eb 0c		 jmp	 SHORT $LN165@ProcessMai
$LN164@ProcessMai:
  0070a	48 c7 84 24 28
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv262[rsp], 0
$LN165@ProcessMai:
  00716	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  0071e	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR tv262[rsp]
  00726	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 983  : 			Irp->IoStatus.Status = ntStatus;

  0072a	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00732	8b 44 24 60	 mov	 eax, DWORD PTR ntStatus$[rsp]
  00736	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 984  : 		}
; 985  : 		break;

  00739	e9 3d 19 00 00	 jmp	 $LN160@ProcessMai
$LN120@ProcessMai:

; 986  : 
; 987  : 	case TC_IOCTL_GET_SYSTEM_DRIVE_CONFIG:
; 988  : 		{
; 989  : 			GetSystemDriveConfigurationRequest *request = (GetSystemDriveConfigurationRequest *) Irp->AssociatedIrp.SystemBuffer;

  0073e	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00746	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0074a	48 89 84 24 58
	03 00 00	 mov	 QWORD PTR request$31889[rsp], rax

; 990  : 			OBJECT_ATTRIBUTES ObjectAttributes;
; 991  : 			HANDLE NtFileHandle;
; 992  : 			UNICODE_STRING FullFileName;
; 993  : 			IO_STATUS_BLOCK IoStatus;
; 994  : 			LARGE_INTEGER offset;
; 995  : 			byte readBuffer [TC_SECTOR_SIZE_BIOS];
; 996  : 
; 997  : 			if (!ValidateIOBufferSize (Irp, sizeof (GetSystemDriveConfigurationRequest), ValidateInputOutput))

  00752	41 b8 02 00 00
	00		 mov	 r8d, 2
  00758	ba 29 02 00 00	 mov	 edx, 553		; 00000229H
  0075d	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00765	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0076a	85 c0		 test	 eax, eax
  0076c	75 05		 jne	 SHORT $LN119@ProcessMai

; 998  : 				break;

  0076e	e9 08 19 00 00	 jmp	 $LN160@ProcessMai
$LN119@ProcessMai:

; 999  : 
; 1000 : 			EnsureNullTerminatedString (request->DevicePath, sizeof (request->DevicePath));

  00773	ba 08 02 00 00	 mov	 edx, 520		; 00000208H
  00778	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR request$31889[rsp]
  00780	e8 00 00 00 00	 call	 EnsureNullTerminatedString

; 1001 : 			RtlInitUnicodeString (&FullFileName, request->DevicePath);

  00785	48 8b 94 24 58
	03 00 00	 mov	 rdx, QWORD PTR request$31889[rsp]
  0078d	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR FullFileName$31893[rsp]
  00795	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 1002 : 
; 1003 : 			InitializeObjectAttributes (&ObjectAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

  0079b	c7 84 24 28 03
	00 00 30 00 00
	00		 mov	 DWORD PTR ObjectAttributes$31891[rsp], 48 ; 00000030H
  007a6	48 c7 84 24 30
	03 00 00 00 00
	00 00		 mov	 QWORD PTR ObjectAttributes$31891[rsp+8], 0
  007b2	c7 84 24 40 03
	00 00 40 02 00
	00		 mov	 DWORD PTR ObjectAttributes$31891[rsp+24], 576 ; 00000240H
  007bd	48 8d 84 24 00
	01 00 00	 lea	 rax, QWORD PTR FullFileName$31893[rsp]
  007c5	48 89 84 24 38
	03 00 00	 mov	 QWORD PTR ObjectAttributes$31891[rsp+16], rax
  007cd	48 c7 84 24 48
	03 00 00 00 00
	00 00		 mov	 QWORD PTR ObjectAttributes$31891[rsp+32], 0
  007d9	48 c7 84 24 50
	03 00 00 00 00
	00 00		 mov	 QWORD PTR ObjectAttributes$31891[rsp+40], 0

; 1004 : 
; 1005 : 			ntStatus = ZwCreateFile (&NtFileHandle,
; 1006 : 				SYNCHRONIZE | GENERIC_READ, &ObjectAttributes, &IoStatus, NULL,
; 1007 : 				FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS, NULL, 0);

  007e5	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR [rsp+80], 0
  007ed	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR [rsp+72], 0
  007f6	c7 44 24 40 20
	08 00 00	 mov	 DWORD PTR [rsp+64], 2080 ; 00000820H
  007fe	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR [rsp+56], 1
  00806	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR [rsp+48], 3
  0080e	c7 44 24 28 80
	00 00 00	 mov	 DWORD PTR [rsp+40], 128	; 00000080H
  00816	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0081f	4c 8d 8c 24 60
	03 00 00	 lea	 r9, QWORD PTR IoStatus$31894[rsp]
  00827	4c 8d 84 24 28
	03 00 00	 lea	 r8, QWORD PTR ObjectAttributes$31891[rsp]
  0082f	ba 00 00 10 80	 mov	 edx, -2146435072	; 80100000H
  00834	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR NtFileHandle$31892[rsp]
  0083c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwCreateFile
  00842	89 44 24 60	 mov	 DWORD PTR ntStatus$[rsp], eax

; 1008 : 
; 1009 : 			if (NT_SUCCESS (ntStatus))

  00846	83 7c 24 60 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  0084b	0f 8c 90 03 00
	00		 jl	 $LN118@ProcessMai

; 1010 : 			{
; 1011 : 				// Determine if the first sector contains a portion of the TrueCrypt Boot Loader
; 1012 : 				offset.QuadPart = 0;	// MBR

  00851	48 c7 84 24 20
	03 00 00 00 00
	00 00		 mov	 QWORD PTR offset$31895[rsp], 0

; 1013 : 
; 1014 : 				ntStatus = ZwReadFile (NtFileHandle,
; 1015 : 					NULL,
; 1016 : 					NULL,
; 1017 : 					NULL,
; 1018 : 					&IoStatus,
; 1019 : 					readBuffer,
; 1020 : 					sizeof(readBuffer),
; 1021 : 					&offset,
; 1022 : 					NULL);

  0085d	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00866	48 8d 84 24 20
	03 00 00	 lea	 rax, QWORD PTR offset$31895[rsp]
  0086e	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00873	c7 44 24 30 00
	02 00 00	 mov	 DWORD PTR [rsp+48], 512	; 00000200H
  0087b	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR readBuffer$31896[rsp]
  00883	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00888	48 8d 84 24 60
	03 00 00	 lea	 rax, QWORD PTR IoStatus$31894[rsp]
  00890	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00895	45 33 c9	 xor	 r9d, r9d
  00898	45 33 c0	 xor	 r8d, r8d
  0089b	33 d2		 xor	 edx, edx
  0089d	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR NtFileHandle$31892[rsp]
  008a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwReadFile
  008ab	89 44 24 60	 mov	 DWORD PTR ntStatus$[rsp], eax

; 1023 : 
; 1024 : 				if (NT_SUCCESS (ntStatus))

  008af	83 7c 24 60 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  008b4	0f 8c f8 02 00
	00		 jl	 $LN117@ProcessMai

; 1025 : 				{
; 1026 : 					size_t i;
; 1027 : 
; 1028 : 					// Check for dynamic drive
; 1029 : 					request->DriveIsDynamic = FALSE;

  008ba	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR request$31889[rsp]
  008c2	c7 80 09 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+521], 0

; 1030 : 
; 1031 : 					if (readBuffer[510] == 0x55 && readBuffer[511] == 0xaa)

  008cc	0f b6 84 24 1e
	03 00 00	 movzx	 eax, BYTE PTR readBuffer$31896[rsp+510]
  008d4	83 f8 55	 cmp	 eax, 85			; 00000055H
  008d7	75 6b		 jne	 SHORT $LN116@ProcessMai
  008d9	0f b6 84 24 1f
	03 00 00	 movzx	 eax, BYTE PTR readBuffer$31896[rsp+511]
  008e1	3d aa 00 00 00	 cmp	 eax, 170		; 000000aaH
  008e6	75 5c		 jne	 SHORT $LN116@ProcessMai

; 1032 : 					{
; 1033 : 						int i;
; 1034 : 						for (i = 0; i < 4; ++i)

  008e8	c7 84 24 80 03
	00 00 00 00 00
	00		 mov	 DWORD PTR i$31915[rsp], 0
  008f3	eb 11		 jmp	 SHORT $LN115@ProcessMai
$LN114@ProcessMai:
  008f5	8b 84 24 80 03
	00 00		 mov	 eax, DWORD PTR i$31915[rsp]
  008fc	83 c0 01	 add	 eax, 1
  008ff	89 84 24 80 03
	00 00		 mov	 DWORD PTR i$31915[rsp], eax
$LN115@ProcessMai:
  00906	83 bc 24 80 03
	00 00 04	 cmp	 DWORD PTR i$31915[rsp], 4
  0090e	7d 34		 jge	 SHORT $LN113@ProcessMai

; 1035 : 						{
; 1036 : 							if (readBuffer[446 + i * 16 + 4] == PARTITION_LDM)

  00910	8b 84 24 80 03
	00 00		 mov	 eax, DWORD PTR i$31915[rsp]
  00917	6b c0 10	 imul	 eax, 16
  0091a	05 c2 01 00 00	 add	 eax, 450		; 000001c2H
  0091f	48 98		 cdqe
  00921	0f b6 84 04 20
	01 00 00	 movzx	 eax, BYTE PTR readBuffer$31896[rsp+rax]
  00929	83 f8 42	 cmp	 eax, 66			; 00000042H
  0092c	75 14		 jne	 SHORT $LN112@ProcessMai

; 1037 : 							{
; 1038 : 								request->DriveIsDynamic = TRUE;

  0092e	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR request$31889[rsp]
  00936	c7 80 09 02 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+521], 1

; 1039 : 								break;

  00940	eb 02		 jmp	 SHORT $LN113@ProcessMai
$LN112@ProcessMai:

; 1040 : 							}
; 1041 : 						}

  00942	eb b1		 jmp	 SHORT $LN114@ProcessMai
$LN113@ProcessMai:
$LN116@ProcessMai:

; 1042 : 					}
; 1043 : 
; 1044 : 					request->BootLoaderVersion = 0;

  00944	33 c9		 xor	 ecx, ecx
  00946	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR request$31889[rsp]
  0094e	66 89 88 0d 02
	00 00		 mov	 WORD PTR [rax+525], cx

; 1045 : 					request->Configuration = 0;

  00955	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR request$31889[rsp]
  0095d	c6 80 08 02 00
	00 00		 mov	 BYTE PTR [rax+520], 0

; 1046 : 					request->UserConfiguration = 0;

  00964	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR request$31889[rsp]
  0096c	c6 80 0f 02 00
	00 00		 mov	 BYTE PTR [rax+527], 0

; 1047 : 					request->CustomUserMessage[0] = 0;

  00973	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR request$31889[rsp]
  0097b	c6 80 10 02 00
	00 00		 mov	 BYTE PTR [rax+528], 0

; 1048 : 
; 1049 : 					// Search for the string "CipherShed"
; 1050 : 					for (i = 0; i < sizeof (readBuffer) - strlen (TC_APP_NAME); ++i)

  00982	48 c7 84 24 78
	03 00 00 00 00
	00 00		 mov	 QWORD PTR i$31913[rsp], 0
  0098e	eb 14		 jmp	 SHORT $LN111@ProcessMai
$LN110@ProcessMai:
  00990	48 8b 84 24 78
	03 00 00	 mov	 rax, QWORD PTR i$31913[rsp]
  00998	48 83 c0 01	 add	 rax, 1
  0099c	48 89 84 24 78
	03 00 00	 mov	 QWORD PTR i$31913[rsp], rax
$LN111@ProcessMai:
  009a4	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  009a9	48 83 e8 0a	 sub	 rax, 10
  009ad	48 39 84 24 78
	03 00 00	 cmp	 QWORD PTR i$31913[rsp], rax
  009b5	0f 83 c3 00 00
	00		 jae	 $LN109@ProcessMai

; 1051 : 					{
; 1052 : 						if (memcmp (readBuffer + i, TC_APP_NAME, strlen (TC_APP_NAME)) == 0)

  009bb	48 8b 84 24 78
	03 00 00	 mov	 rax, QWORD PTR i$31913[rsp]
  009c3	48 8d 8c 04 20
	01 00 00	 lea	 rcx, QWORD PTR readBuffer$31896[rsp+rax]
  009cb	41 b8 0a 00 00
	00		 mov	 r8d, 10
  009d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@FEEFGEIL@CipherShed?$AA@FNODOBFM@
  009d8	e8 00 00 00 00	 call	 memcmp
  009dd	85 c0		 test	 eax, eax
  009df	0f 85 94 00 00
	00		 jne	 $LN108@ProcessMai

; 1053 : 						{
; 1054 : 							request->BootLoaderVersion = BE16 (*(uint16 *) (readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET));

  009e5	0f b7 8c 24 ce
	02 00 00	 movzx	 ecx, WORD PTR readBuffer$31896[rsp+430]
  009ed	e8 00 00 00 00	 call	 MirrorBytes16
  009f2	0f b7 d0	 movzx	 edx, ax
  009f5	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR request$31889[rsp]
  009fd	66 89 90 0d 02
	00 00		 mov	 WORD PTR [rax+525], dx

; 1055 : 							request->Configuration = readBuffer[TC_BOOT_SECTOR_CONFIG_OFFSET];

  00a04	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR request$31889[rsp]
  00a0c	0f b6 84 24 d7
	02 00 00	 movzx	 eax, BYTE PTR readBuffer$31896[rsp+439]
  00a14	88 81 08 02 00
	00		 mov	 BYTE PTR [rcx+520], al

; 1056 : 
; 1057 : 							if (request->BootLoaderVersion != 0 && request->BootLoaderVersion <= VERSION_NUM)

  00a1a	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR request$31889[rsp]
  00a22	0f b7 80 0d 02
	00 00		 movzx	 eax, WORD PTR [rax+525]
  00a29	85 c0		 test	 eax, eax
  00a2b	74 4a		 je	 SHORT $LN107@ProcessMai
  00a2d	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR request$31889[rsp]
  00a35	0f b7 80 0d 02
	00 00		 movzx	 eax, WORD PTR [rax+525]
  00a3c	3d 41 07 00 00	 cmp	 eax, 1857		; 00000741H
  00a41	7f 34		 jg	 SHORT $LN107@ProcessMai

; 1058 : 							{
; 1059 : 								request->UserConfiguration = readBuffer[TC_BOOT_SECTOR_USER_CONFIG_OFFSET];

  00a43	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR request$31889[rsp]
  00a4b	0f b6 84 24 d6
	02 00 00	 movzx	 eax, BYTE PTR readBuffer$31896[rsp+438]
  00a53	88 81 0f 02 00
	00		 mov	 BYTE PTR [rcx+527], al

; 1060 : 								memcpy (request->CustomUserMessage, readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET, TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH);

  00a59	48 8b bc 24 58
	03 00 00	 mov	 rdi, QWORD PTR request$31889[rsp]
  00a61	48 8d b4 24 b6
	02 00 00	 lea	 rsi, QWORD PTR readBuffer$31896[rsp+406]
  00a69	48 81 c7 10 02
	00 00		 add	 rdi, 528		; 00000210H
  00a70	b9 18 00 00 00	 mov	 ecx, 24
  00a75	f3 a4		 rep movsb
$LN107@ProcessMai:

; 1061 : 							}
; 1062 : 							break;

  00a77	eb 05		 jmp	 SHORT $LN109@ProcessMai
$LN108@ProcessMai:

; 1063 : 						}
; 1064 : 					}

  00a79	e9 12 ff ff ff	 jmp	 $LN110@ProcessMai
$LN109@ProcessMai:

; 1065 : 
; 1066 : 					// Search for the string "TrueCrypt"
; 1067 : 					if (!request->BootLoaderVersion) //CipherShed not found

  00a7e	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR request$31889[rsp]
  00a86	0f b7 80 0d 02
	00 00		 movzx	 eax, WORD PTR [rax+525]
  00a8d	85 c0		 test	 eax, eax
  00a8f	0f 85 fc 00 00
	00		 jne	 $LN106@ProcessMai

; 1068 : 					for (i = 0; i < sizeof (readBuffer) - strlen (TC_APP_NAME_LEGACY); ++i)

  00a95	48 c7 84 24 78
	03 00 00 00 00
	00 00		 mov	 QWORD PTR i$31913[rsp], 0
  00aa1	eb 14		 jmp	 SHORT $LN105@ProcessMai
$LN104@ProcessMai:
  00aa3	48 8b 84 24 78
	03 00 00	 mov	 rax, QWORD PTR i$31913[rsp]
  00aab	48 83 c0 01	 add	 rax, 1
  00aaf	48 89 84 24 78
	03 00 00	 mov	 QWORD PTR i$31913[rsp], rax
$LN105@ProcessMai:
  00ab7	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00abc	48 83 e8 09	 sub	 rax, 9
  00ac0	48 39 84 24 78
	03 00 00	 cmp	 QWORD PTR i$31913[rsp], rax
  00ac8	0f 83 c3 00 00
	00		 jae	 $LN103@ProcessMai

; 1069 : 					{
; 1070 : 						if (memcmp (readBuffer + i, TC_APP_NAME_LEGACY, strlen (TC_APP_NAME_LEGACY)) == 0)

  00ace	48 8b 84 24 78
	03 00 00	 mov	 rax, QWORD PTR i$31913[rsp]
  00ad6	48 8d 8c 04 20
	01 00 00	 lea	 rcx, QWORD PTR readBuffer$31896[rsp+rax]
  00ade	41 b8 09 00 00
	00		 mov	 r8d, 9
  00ae4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09EMKKFGIH@TrueCrypt?$AA@FNODOBFM@
  00aeb	e8 00 00 00 00	 call	 memcmp
  00af0	85 c0		 test	 eax, eax
  00af2	0f 85 94 00 00
	00		 jne	 $LN102@ProcessMai

; 1071 : 						{
; 1072 : 							request->BootLoaderVersion = BE16 (*(uint16 *) (readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET));

  00af8	0f b7 8c 24 ce
	02 00 00	 movzx	 ecx, WORD PTR readBuffer$31896[rsp+430]
  00b00	e8 00 00 00 00	 call	 MirrorBytes16
  00b05	0f b7 d0	 movzx	 edx, ax
  00b08	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR request$31889[rsp]
  00b10	66 89 90 0d 02
	00 00		 mov	 WORD PTR [rax+525], dx

; 1073 : 							request->Configuration = readBuffer[TC_BOOT_SECTOR_CONFIG_OFFSET];

  00b17	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR request$31889[rsp]
  00b1f	0f b6 84 24 d7
	02 00 00	 movzx	 eax, BYTE PTR readBuffer$31896[rsp+439]
  00b27	88 81 08 02 00
	00		 mov	 BYTE PTR [rcx+520], al

; 1074 : 
; 1075 : 							if (request->BootLoaderVersion != 0 && request->BootLoaderVersion <= VERSION_NUM)

  00b2d	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR request$31889[rsp]
  00b35	0f b7 80 0d 02
	00 00		 movzx	 eax, WORD PTR [rax+525]
  00b3c	85 c0		 test	 eax, eax
  00b3e	74 4a		 je	 SHORT $LN101@ProcessMai
  00b40	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR request$31889[rsp]
  00b48	0f b7 80 0d 02
	00 00		 movzx	 eax, WORD PTR [rax+525]
  00b4f	3d 41 07 00 00	 cmp	 eax, 1857		; 00000741H
  00b54	7f 34		 jg	 SHORT $LN101@ProcessMai

; 1076 : 							{
; 1077 : 								request->UserConfiguration = readBuffer[TC_BOOT_SECTOR_USER_CONFIG_OFFSET];

  00b56	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR request$31889[rsp]
  00b5e	0f b6 84 24 d6
	02 00 00	 movzx	 eax, BYTE PTR readBuffer$31896[rsp+438]
  00b66	88 81 0f 02 00
	00		 mov	 BYTE PTR [rcx+527], al

; 1078 : 								memcpy (request->CustomUserMessage, readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET, TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH);

  00b6c	48 8b bc 24 58
	03 00 00	 mov	 rdi, QWORD PTR request$31889[rsp]
  00b74	48 8d b4 24 b6
	02 00 00	 lea	 rsi, QWORD PTR readBuffer$31896[rsp+406]
  00b7c	48 81 c7 10 02
	00 00		 add	 rdi, 528		; 00000210H
  00b83	b9 18 00 00 00	 mov	 ecx, 24
  00b88	f3 a4		 rep movsb
$LN101@ProcessMai:

; 1079 : 							}
; 1080 : 							break;

  00b8a	eb 05		 jmp	 SHORT $LN103@ProcessMai
$LN102@ProcessMai:

; 1081 : 						}
; 1082 : 					}

  00b8c	e9 12 ff ff ff	 jmp	 $LN104@ProcessMai
$LN103@ProcessMai:
$LN106@ProcessMai:

; 1083 : 
; 1084 : 					Irp->IoStatus.Status = STATUS_SUCCESS;

  00b91	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00b99	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 1085 : 					Irp->IoStatus.Information = sizeof (*request);

  00ba0	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00ba8	48 c7 40 38 29
	02 00 00	 mov	 QWORD PTR [rax+56], 553	; 00000229H

; 1086 : 				}
; 1087 : 				else

  00bb0	eb 1f		 jmp	 SHORT $LN100@ProcessMai
$LN117@ProcessMai:

; 1088 : 				{
; 1089 : 					Irp->IoStatus.Status = ntStatus;

  00bb2	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00bba	8b 44 24 60	 mov	 eax, DWORD PTR ntStatus$[rsp]
  00bbe	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 1090 : 					Irp->IoStatus.Information = 0;

  00bc1	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00bc9	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0
$LN100@ProcessMai:

; 1091 : 				}
; 1092 : 
; 1093 : 				ZwClose (NtFileHandle);

  00bd1	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR NtFileHandle$31892[rsp]
  00bd9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 1094 : 
; 1095 : 			}
; 1096 : 			else

  00bdf	eb 1f		 jmp	 SHORT $LN99@ProcessMai
$LN118@ProcessMai:

; 1097 : 			{
; 1098 : 				Irp->IoStatus.Status = ntStatus;

  00be1	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00be9	8b 44 24 60	 mov	 eax, DWORD PTR ntStatus$[rsp]
  00bed	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 1099 : 				Irp->IoStatus.Information = 0;

  00bf0	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00bf8	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0
$LN99@ProcessMai:

; 1100 : 			}
; 1101 : 		}
; 1102 : 		break;

  00c00	e9 76 14 00 00	 jmp	 $LN160@ProcessMai
$LN98@ProcessMai:

; 1103 : 
; 1104 : 	case TC_IOCTL_WIPE_PASSWORD_CACHE:
; 1105 : 		WipeCache ();

  00c05	e8 00 00 00 00	 call	 WipeCache

; 1106 : 
; 1107 : 		Irp->IoStatus.Status = STATUS_SUCCESS;

  00c0a	48 8b 94 24 c0
	05 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  00c12	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [rdx+48], 0

; 1108 : 		Irp->IoStatus.Information = 0;

  00c19	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00c21	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1109 : 		break;

  00c29	e9 4d 14 00 00	 jmp	 $LN160@ProcessMai
$LN97@ProcessMai:

; 1110 : 
; 1111 : 	case TC_IOCTL_GET_PASSWORD_CACHE_STATUS:
; 1112 : 		Irp->IoStatus.Status = cacheEmpty ? STATUS_PIPE_EMPTY : STATUS_SUCCESS;

  00c2e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR cacheEmpty, 0
  00c35	74 0d		 je	 SHORT $LN166@ProcessMai
  00c37	c7 84 24 30 05
	00 00 d9 00 00
	c0		 mov	 DWORD PTR tv434[rsp], -1073741607 ; ffffffffc00000d9H
  00c42	eb 0b		 jmp	 SHORT $LN167@ProcessMai
$LN166@ProcessMai:
  00c44	c7 84 24 30 05
	00 00 00 00 00
	00		 mov	 DWORD PTR tv434[rsp], 0
$LN167@ProcessMai:
  00c4f	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00c57	8b 84 24 30 05
	00 00		 mov	 eax, DWORD PTR tv434[rsp]
  00c5e	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 1113 : 		Irp->IoStatus.Information = 0;

  00c61	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00c69	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1114 : 		break;

  00c71	e9 05 14 00 00	 jmp	 $LN160@ProcessMai
$LN96@ProcessMai:

; 1115 : 
; 1116 : 	case TC_IOCTL_SET_PORTABLE_MODE_STATUS:
; 1117 : 		if (!UserCanAccessDriveDevice())

  00c76	e8 00 00 00 00	 call	 UserCanAccessDriveDevice
  00c7b	85 c0		 test	 eax, eax
  00c7d	75 21		 jne	 SHORT $LN95@ProcessMai

; 1118 : 		{
; 1119 : 			Irp->IoStatus.Status = STATUS_ACCESS_DENIED;

  00c7f	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00c87	c7 40 30 22 00
	00 c0		 mov	 DWORD PTR [rax+48], -1073741790 ; ffffffffc0000022H

; 1120 : 			Irp->IoStatus.Information = 0;

  00c8e	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00c96	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1121 : 		}
; 1122 : 		else

  00c9e	eb 16		 jmp	 SHORT $LN94@ProcessMai
$LN95@ProcessMai:

; 1123 : 		{
; 1124 : 			PortableMode = TRUE;

  00ca0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR PortableMode, 1

; 1125 : 			Dump ("Setting portable mode\n");

  00caa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@GFMHOPFN@Setting?5portable?5mode?6?$AA@FNODOBFM@
  00cb1	e8 00 00 00 00	 call	 DbgPrint
$LN94@ProcessMai:

; 1126 : 		}
; 1127 : 		break;

  00cb6	e9 c0 13 00 00	 jmp	 $LN160@ProcessMai
$LN93@ProcessMai:

; 1128 : 
; 1129 : 	case TC_IOCTL_GET_PORTABLE_MODE_STATUS:
; 1130 : 		Irp->IoStatus.Status = PortableMode ? STATUS_SUCCESS : STATUS_PIPE_EMPTY;

  00cbb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR PortableMode, 0
  00cc2	74 0d		 je	 SHORT $LN168@ProcessMai
  00cc4	c7 84 24 34 05
	00 00 00 00 00
	00		 mov	 DWORD PTR tv443[rsp], 0
  00ccf	eb 0b		 jmp	 SHORT $LN169@ProcessMai
$LN168@ProcessMai:
  00cd1	c7 84 24 34 05
	00 00 d9 00 00
	c0		 mov	 DWORD PTR tv443[rsp], -1073741607 ; ffffffffc00000d9H
$LN169@ProcessMai:
  00cdc	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00ce4	8b 84 24 34 05
	00 00		 mov	 eax, DWORD PTR tv443[rsp]
  00ceb	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 1131 : 		Irp->IoStatus.Information = 0;

  00cee	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00cf6	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1132 : 		break;

  00cfe	e9 78 13 00 00	 jmp	 $LN160@ProcessMai
$LN92@ProcessMai:

; 1133 : 
; 1134 : 	case TC_IOCTL_GET_MOUNTED_VOLUMES:
; 1135 : 
; 1136 : 		if (ValidateIOBufferSize (Irp, sizeof (MOUNT_LIST_STRUCT), ValidateOutput))

  00d03	41 b8 01 00 00
	00		 mov	 r8d, 1
  00d09	ba 74 36 00 00	 mov	 edx, 13940		; 00003674H
  00d0e	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00d16	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00d1b	85 c0		 test	 eax, eax
  00d1d	0f 84 b2 02 00
	00		 je	 $LN91@ProcessMai

; 1137 : 		{
; 1138 : 			MOUNT_LIST_STRUCT *list = (MOUNT_LIST_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  00d23	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00d2b	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00d2f	48 89 84 24 88
	03 00 00	 mov	 QWORD PTR list$31952[rsp], rax

; 1139 : 			PDEVICE_OBJECT ListDevice;
; 1140 : 			int drive;
; 1141 : 
; 1142 : 			list->ulMountedDrives = 0;

  00d37	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR list$31952[rsp]
  00d3f	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1143 : 
; 1144 : 			for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)

  00d45	c7 84 24 90 03
	00 00 00 00 00
	00		 mov	 DWORD PTR drive$31955[rsp], 0
  00d50	eb 11		 jmp	 SHORT $LN90@ProcessMai
$LN89@ProcessMai:
  00d52	8b 84 24 90 03
	00 00		 mov	 eax, DWORD PTR drive$31955[rsp]
  00d59	83 c0 01	 add	 eax, 1
  00d5c	89 84 24 90 03
	00 00		 mov	 DWORD PTR drive$31955[rsp], eax
$LN90@ProcessMai:
  00d63	83 bc 24 90 03
	00 00 19	 cmp	 DWORD PTR drive$31955[rsp], 25
  00d6b	0f 8f 45 02 00
	00		 jg	 $LN88@ProcessMai

; 1145 : 			{
; 1146 : 				PEXTENSION ListExtension;
; 1147 : 				
; 1148 : 				ListDevice = GetVirtualVolumeDeviceObject (drive);

  00d71	8b 8c 24 90 03
	00 00		 mov	 ecx, DWORD PTR drive$31955[rsp]
  00d78	e8 00 00 00 00	 call	 GetVirtualVolumeDeviceObject
  00d7d	48 89 84 24 98
	03 00 00	 mov	 QWORD PTR ListDevice$31954[rsp], rax

; 1149 : 				if (!ListDevice)

  00d85	48 83 bc 24 98
	03 00 00 00	 cmp	 QWORD PTR ListDevice$31954[rsp], 0
  00d8e	75 02		 jne	 SHORT $LN87@ProcessMai

; 1150 : 					continue;

  00d90	eb c0		 jmp	 SHORT $LN89@ProcessMai
$LN87@ProcessMai:

; 1151 : 
; 1152 : 				ListExtension = (PEXTENSION) ListDevice->DeviceExtension;

  00d92	48 8b 84 24 98
	03 00 00	 mov	 rax, QWORD PTR ListDevice$31954[rsp]
  00d9a	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00d9e	48 89 84 24 a0
	03 00 00	 mov	 QWORD PTR ListExtension$31959[rsp], rax

; 1153 : 				if (IsVolumeAccessibleByCurrentUser (ListExtension))

  00da6	48 8b 8c 24 a0
	03 00 00	 mov	 rcx, QWORD PTR ListExtension$31959[rsp]
  00dae	e8 00 00 00 00	 call	 IsVolumeAccessibleByCurrentUser
  00db3	85 c0		 test	 eax, eax
  00db5	0f 84 f6 01 00
	00		 je	 $LN86@ProcessMai

; 1154 : 				{
; 1155 : 					list->ulMountedDrives |= (1 << ListExtension->nDosDriveNo);

  00dbb	48 8b 84 24 a0
	03 00 00	 mov	 rax, QWORD PTR ListExtension$31959[rsp]
  00dc3	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00dc6	ba 01 00 00 00	 mov	 edx, 1
  00dcb	0f b6 c8	 movzx	 ecx, al
  00dce	d3 e2		 shl	 edx, cl
  00dd0	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR list$31952[rsp]
  00dd8	8b 08		 mov	 ecx, DWORD PTR [rax]
  00dda	0b ca		 or	 ecx, edx
  00ddc	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR list$31952[rsp]
  00de4	89 08		 mov	 DWORD PTR [rax], ecx

; 1156 : 					wcscpy (list->wszVolume[ListExtension->nDosDriveNo], ListExtension->wszVolume);

  00de6	48 8b 84 24 a0
	03 00 00	 mov	 rax, QWORD PTR ListExtension$31959[rsp]
  00dee	48 05 b0 03 00
	00		 add	 rax, 944		; 000003b0H
  00df4	48 89 84 24 38
	05 00 00	 mov	 QWORD PTR tv465[rsp], rax
  00dfc	48 8b 84 24 a0
	03 00 00	 mov	 rax, QWORD PTR ListExtension$31959[rsp]
  00e04	48 63 48 14	 movsxd	 rcx, DWORD PTR [rax+20]
  00e08	48 69 c9 08 02
	00 00		 imul	 rcx, 520		; 00000208H
  00e0f	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR list$31952[rsp]
  00e17	48 8d 44 08 04	 lea	 rax, QWORD PTR [rax+rcx+4]
  00e1c	48 89 84 24 40
	05 00 00	 mov	 QWORD PTR tv471[rsp], rax
  00e24	48 8b 84 24 40
	05 00 00	 mov	 rax, QWORD PTR tv471[rsp]
  00e2c	48 89 84 24 48
	05 00 00	 mov	 QWORD PTR tv472[rsp], rax
$LN170@ProcessMai:
  00e34	48 8b 84 24 38
	05 00 00	 mov	 rax, QWORD PTR tv465[rsp]
  00e3c	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00e3f	66 89 84 24 50
	05 00 00	 mov	 WORD PTR tv473[rsp], ax
  00e47	48 8b 8c 24 40
	05 00 00	 mov	 rcx, QWORD PTR tv471[rsp]
  00e4f	0f b7 84 24 50
	05 00 00	 movzx	 eax, WORD PTR tv473[rsp]
  00e57	66 89 01	 mov	 WORD PTR [rcx], ax
  00e5a	48 8b 84 24 38
	05 00 00	 mov	 rax, QWORD PTR tv465[rsp]
  00e62	48 83 c0 02	 add	 rax, 2
  00e66	48 89 84 24 38
	05 00 00	 mov	 QWORD PTR tv465[rsp], rax
  00e6e	48 8b 84 24 40
	05 00 00	 mov	 rax, QWORD PTR tv471[rsp]
  00e76	48 83 c0 02	 add	 rax, 2
  00e7a	48 89 84 24 40
	05 00 00	 mov	 QWORD PTR tv471[rsp], rax
  00e82	66 83 bc 24 50
	05 00 00 00	 cmp	 WORD PTR tv473[rsp], 0
  00e8b	75 a7		 jne	 SHORT $LN170@ProcessMai

; 1157 : 					list->diskLength[ListExtension->nDosDriveNo] = ListExtension->DiskLength;

  00e8d	48 8b 84 24 a0
	03 00 00	 mov	 rax, QWORD PTR ListExtension$31959[rsp]
  00e95	48 63 50 14	 movsxd	 rdx, DWORD PTR [rax+20]
  00e99	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR list$31952[rsp]
  00ea1	48 8b 84 24 a0
	03 00 00	 mov	 rax, QWORD PTR ListExtension$31959[rsp]
  00ea9	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00eb0	48 89 84 d1 d4
	34 00 00	 mov	 QWORD PTR [rcx+rdx*8+13524], rax

; 1158 : 					list->ea[ListExtension->nDosDriveNo] = ListExtension->cryptoInfo->ea;

  00eb8	48 8b bc 24 a0
	03 00 00	 mov	 rdi, QWORD PTR ListExtension$31959[rsp]
  00ec0	48 8b bf 90 00
	00 00		 mov	 rdi, QWORD PTR [rdi+144]
  00ec7	48 8b 84 24 a0
	03 00 00	 mov	 rax, QWORD PTR ListExtension$31959[rsp]
  00ecf	48 63 50 14	 movsxd	 rdx, DWORD PTR [rax+20]
  00ed3	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR list$31952[rsp]
  00edb	8b 07		 mov	 eax, DWORD PTR [rdi]
  00edd	89 84 91 a4 35
	00 00		 mov	 DWORD PTR [rcx+rdx*4+13732], eax

; 1159 : 					if (ListExtension->cryptoInfo->hiddenVolume)

  00ee4	48 8b 84 24 a0
	03 00 00	 mov	 rax, QWORD PTR ListExtension$31959[rsp]
  00eec	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00ef3	83 b8 a0 29 00
	00 00		 cmp	 DWORD PTR [rax+10656], 0
  00efa	74 24		 je	 SHORT $LN85@ProcessMai

; 1160 : 						list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_HIDDEN;	// Hidden volume

  00efc	48 8b 84 24 a0
	03 00 00	 mov	 rax, QWORD PTR ListExtension$31959[rsp]
  00f04	48 63 48 14	 movsxd	 rcx, DWORD PTR [rax+20]
  00f08	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR list$31952[rsp]
  00f10	c7 84 88 0c 36
	00 00 01 00 00
	00		 mov	 DWORD PTR [rax+rcx*4+13836], 1
  00f1b	e9 91 00 00 00	 jmp	 $LN84@ProcessMai
$LN85@ProcessMai:

; 1161 : 					else if (ListExtension->cryptoInfo->bHiddenVolProtectionAction)

  00f20	48 8b 84 24 a0
	03 00 00	 mov	 rax, QWORD PTR ListExtension$31959[rsp]
  00f28	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00f2f	83 b8 04 44 00
	00 00		 cmp	 DWORD PTR [rax+17412], 0
  00f36	74 21		 je	 SHORT $LN83@ProcessMai

; 1162 : 						list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_OUTER_VOL_WRITE_PREVENTED;	// Normal/outer volume (hidden volume protected AND write already prevented)

  00f38	48 8b 84 24 a0
	03 00 00	 mov	 rax, QWORD PTR ListExtension$31959[rsp]
  00f40	48 63 48 14	 movsxd	 rcx, DWORD PTR [rax+20]
  00f44	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR list$31952[rsp]
  00f4c	c7 84 88 0c 36
	00 00 03 00 00
	00		 mov	 DWORD PTR [rax+rcx*4+13836], 3
  00f57	eb 58		 jmp	 SHORT $LN82@ProcessMai
$LN83@ProcessMai:

; 1163 : 					else if (ListExtension->cryptoInfo->bProtectHiddenVolume)

  00f59	48 8b 84 24 a0
	03 00 00	 mov	 rax, QWORD PTR ListExtension$31959[rsp]
  00f61	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00f68	83 b8 00 44 00
	00 00		 cmp	 DWORD PTR [rax+17408], 0
  00f6f	74 21		 je	 SHORT $LN81@ProcessMai

; 1164 : 						list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_OUTER;	// Normal/outer volume (hidden volume protected)

  00f71	48 8b 84 24 a0
	03 00 00	 mov	 rax, QWORD PTR ListExtension$31959[rsp]
  00f79	48 63 48 14	 movsxd	 rcx, DWORD PTR [rax+20]
  00f7d	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR list$31952[rsp]
  00f85	c7 84 88 0c 36
	00 00 02 00 00
	00		 mov	 DWORD PTR [rax+rcx*4+13836], 2

; 1165 : 					else

  00f90	eb 1f		 jmp	 SHORT $LN80@ProcessMai
$LN81@ProcessMai:

; 1166 : 						list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_NORMAL;	// Normal volume

  00f92	48 8b 84 24 a0
	03 00 00	 mov	 rax, QWORD PTR ListExtension$31959[rsp]
  00f9a	48 63 48 14	 movsxd	 rcx, DWORD PTR [rax+20]
  00f9e	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR list$31952[rsp]
  00fa6	c7 84 88 0c 36
	00 00 00 00 00
	00		 mov	 DWORD PTR [rax+rcx*4+13836], 0
$LN80@ProcessMai:
$LN82@ProcessMai:
$LN84@ProcessMai:
$LN86@ProcessMai:

; 1167 : 				}
; 1168 : 			}

  00fb1	e9 9c fd ff ff	 jmp	 $LN89@ProcessMai
$LN88@ProcessMai:

; 1169 : 
; 1170 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  00fb6	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00fbe	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 1171 : 			Irp->IoStatus.Information = sizeof (MOUNT_LIST_STRUCT);

  00fc5	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  00fcd	48 c7 40 38 74
	36 00 00	 mov	 QWORD PTR [rax+56], 13940 ; 00003674H
$LN91@ProcessMai:

; 1172 : 		}
; 1173 : 		break;

  00fd5	e9 a1 10 00 00	 jmp	 $LN160@ProcessMai
$LN79@ProcessMai:

; 1174 : 
; 1175 : 	case TC_IOCTL_LEGACY_GET_MOUNTED_VOLUMES:
; 1176 : 		if (ValidateIOBufferSize (Irp, sizeof (uint32), ValidateOutput))

  00fda	41 b8 01 00 00
	00		 mov	 r8d, 1
  00fe0	ba 04 00 00 00	 mov	 edx, 4
  00fe5	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00fed	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00ff2	85 c0		 test	 eax, eax
  00ff4	74 4d		 je	 SHORT $LN78@ProcessMai

; 1177 : 		{
; 1178 : 			// Prevent the user from downgrading to versions lower than 5.0 by faking mounted volumes.
; 1179 : 			// The user could render the system unbootable by downgrading when boot encryption
; 1180 : 			// is active or being set up.
; 1181 : 
; 1182 : 			memset (Irp->AssociatedIrp.SystemBuffer, 0, irpSp->Parameters.DeviceIoControl.OutputBufferLength);

  00ff6	48 8b 44 24 68	 mov	 rax, QWORD PTR irpSp$[rsp]
  00ffb	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00ffe	48 8b bc 24 c0
	05 00 00	 mov	 rdi, QWORD PTR Irp$[rsp]
  01006	48 8b 7f 18	 mov	 rdi, QWORD PTR [rdi+24]
  0100a	33 c0		 xor	 eax, eax
  0100c	f3 aa		 rep stosb

; 1183 : 			*(uint32 *) Irp->AssociatedIrp.SystemBuffer = 0xffffFFFF;

  0100e	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01016	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0101a	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [rax], -1	; ffffffffH

; 1184 : 
; 1185 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  01020	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01028	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 1186 : 			Irp->IoStatus.Information = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

  0102f	48 8b 44 24 68	 mov	 rax, QWORD PTR irpSp$[rsp]
  01034	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  01037	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0103f	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx
$LN78@ProcessMai:

; 1187 : 		}
; 1188 : 		break;

  01043	e9 33 10 00 00	 jmp	 $LN160@ProcessMai
$LN77@ProcessMai:

; 1189 : 
; 1190 : 	case TC_IOCTL_GET_VOLUME_PROPERTIES:
; 1191 : 		if (ValidateIOBufferSize (Irp, sizeof (VOLUME_PROPERTIES_STRUCT), ValidateInputOutput))

  01048	41 b8 02 00 00
	00		 mov	 r8d, 2
  0104e	ba 54 02 00 00	 mov	 edx, 596		; 00000254H
  01053	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  0105b	e8 00 00 00 00	 call	 ValidateIOBufferSize
  01060	85 c0		 test	 eax, eax
  01062	0f 84 79 03 00
	00		 je	 $LN76@ProcessMai

; 1192 : 		{
; 1193 : 			VOLUME_PROPERTIES_STRUCT *prop = (VOLUME_PROPERTIES_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  01068	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01070	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  01074	48 89 84 24 b0
	03 00 00	 mov	 QWORD PTR prop$31979[rsp], rax

; 1194 : 			PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject (prop->driveNo);

  0107c	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR prop$31979[rsp]
  01084	8b 08		 mov	 ecx, DWORD PTR [rax]
  01086	e8 00 00 00 00	 call	 GetVirtualVolumeDeviceObject
  0108b	48 89 84 24 a8
	03 00 00	 mov	 QWORD PTR ListDevice$31981[rsp], rax

; 1195 : 
; 1196 : 			Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  01093	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0109b	c7 40 30 0d 00
	00 c0		 mov	 DWORD PTR [rax+48], -1073741811 ; ffffffffc000000dH

; 1197 : 			Irp->IoStatus.Information = 0;

  010a2	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  010aa	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1198 : 
; 1199 : 			if (ListDevice)

  010b2	48 83 bc 24 a8
	03 00 00 00	 cmp	 QWORD PTR ListDevice$31981[rsp], 0
  010bb	0f 84 20 03 00
	00		 je	 $LN75@ProcessMai

; 1200 : 			{
; 1201 : 				PEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;

  010c1	48 8b 84 24 a8
	03 00 00	 mov	 rax, QWORD PTR ListDevice$31981[rsp]
  010c9	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  010cd	48 89 84 24 b8
	03 00 00	 mov	 QWORD PTR ListExtension$31984[rsp], rax

; 1202 : 				if (IsVolumeAccessibleByCurrentUser (ListExtension))

  010d5	48 8b 8c 24 b8
	03 00 00	 mov	 rcx, QWORD PTR ListExtension$31984[rsp]
  010dd	e8 00 00 00 00	 call	 IsVolumeAccessibleByCurrentUser
  010e2	85 c0		 test	 eax, eax
  010e4	0f 84 f7 02 00
	00		 je	 $LN74@ProcessMai

; 1203 : 				{
; 1204 : 					prop->uniqueId = ListExtension->UniqueVolumeId;

  010ea	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR prop$31979[rsp]
  010f2	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$31984[rsp]
  010fa	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  010fd	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 1205 : 					wcscpy (prop->wszVolume, ListExtension->wszVolume);

  01100	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$31984[rsp]
  01108	48 05 b0 03 00
	00		 add	 rax, 944		; 000003b0H
  0110e	48 89 84 24 58
	05 00 00	 mov	 QWORD PTR tv558[rsp], rax
  01116	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR prop$31979[rsp]
  0111e	48 83 c0 08	 add	 rax, 8
  01122	48 89 84 24 60
	05 00 00	 mov	 QWORD PTR tv560[rsp], rax
  0112a	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR tv560[rsp]
  01132	48 89 84 24 68
	05 00 00	 mov	 QWORD PTR tv561[rsp], rax
$LN171@ProcessMai:
  0113a	48 8b 84 24 58
	05 00 00	 mov	 rax, QWORD PTR tv558[rsp]
  01142	0f b7 00	 movzx	 eax, WORD PTR [rax]
  01145	66 89 84 24 70
	05 00 00	 mov	 WORD PTR tv562[rsp], ax
  0114d	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR tv560[rsp]
  01155	0f b7 84 24 70
	05 00 00	 movzx	 eax, WORD PTR tv562[rsp]
  0115d	66 89 01	 mov	 WORD PTR [rcx], ax
  01160	48 8b 84 24 58
	05 00 00	 mov	 rax, QWORD PTR tv558[rsp]
  01168	48 83 c0 02	 add	 rax, 2
  0116c	48 89 84 24 58
	05 00 00	 mov	 QWORD PTR tv558[rsp], rax
  01174	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR tv560[rsp]
  0117c	48 83 c0 02	 add	 rax, 2
  01180	48 89 84 24 60
	05 00 00	 mov	 QWORD PTR tv560[rsp], rax
  01188	66 83 bc 24 70
	05 00 00 00	 cmp	 WORD PTR tv562[rsp], 0
  01191	75 a7		 jne	 SHORT $LN171@ProcessMai

; 1206 : 					prop->diskLength = ListExtension->DiskLength;

  01193	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR prop$31979[rsp]
  0119b	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$31984[rsp]
  011a3	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  011aa	48 89 81 10 02
	00 00		 mov	 QWORD PTR [rcx+528], rax

; 1207 : 					prop->ea = ListExtension->cryptoInfo->ea;

  011b1	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$31984[rsp]
  011b9	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  011c0	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR prop$31979[rsp]
  011c8	8b 00		 mov	 eax, DWORD PTR [rax]
  011ca	89 81 18 02 00
	00		 mov	 DWORD PTR [rcx+536], eax

; 1208 : 					prop->mode = ListExtension->cryptoInfo->mode;

  011d0	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$31984[rsp]
  011d8	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  011df	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR prop$31979[rsp]
  011e7	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  011ea	89 81 1c 02 00
	00		 mov	 DWORD PTR [rcx+540], eax

; 1209 : 					prop->pkcs5 = ListExtension->cryptoInfo->pkcs5;

  011f0	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$31984[rsp]
  011f8	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  011ff	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR prop$31979[rsp]
  01207	8b 80 ec 43 00
	00		 mov	 eax, DWORD PTR [rax+17388]
  0120d	89 81 20 02 00
	00		 mov	 DWORD PTR [rcx+544], eax

; 1210 : 					prop->pkcs5Iterations = ListExtension->cryptoInfo->noIterations;

  01213	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$31984[rsp]
  0121b	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  01222	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR prop$31979[rsp]
  0122a	8b 80 e8 43 00
	00		 mov	 eax, DWORD PTR [rax+17384]
  01230	89 81 24 02 00
	00		 mov	 DWORD PTR [rcx+548], eax

; 1211 : #if 0
; 1212 : 					prop->volumeCreationTime = ListExtension->cryptoInfo->volume_creation_time;
; 1213 : 					prop->headerCreationTime = ListExtension->cryptoInfo->header_creation_time;
; 1214 : #endif
; 1215 : 					prop->volumeHeaderFlags = ListExtension->cryptoInfo->HeaderFlags;

  01236	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$31984[rsp]
  0123e	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  01245	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR prop$31979[rsp]
  0124d	8b 80 60 44 00
	00		 mov	 eax, DWORD PTR [rax+17504]
  01253	89 81 38 02 00
	00		 mov	 DWORD PTR [rcx+568], eax

; 1216 : 					prop->readOnly = ListExtension->bReadOnly;

  01259	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR prop$31979[rsp]
  01261	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$31984[rsp]
  01269	8b 80 98 03 00
	00		 mov	 eax, DWORD PTR [rax+920]
  0126f	89 81 2c 02 00
	00		 mov	 DWORD PTR [rcx+556], eax

; 1217 : 					prop->removable = ListExtension->bRemovable;

  01275	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR prop$31979[rsp]
  0127d	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$31984[rsp]
  01285	8b 80 9c 03 00
	00		 mov	 eax, DWORD PTR [rax+924]
  0128b	89 81 30 02 00
	00		 mov	 DWORD PTR [rcx+560], eax

; 1218 : 					prop->partitionInInactiveSysEncScope = ListExtension->PartitionInInactiveSysEncScope;

  01291	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR prop$31979[rsp]
  01299	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$31984[rsp]
  012a1	8b 80 a0 03 00
	00		 mov	 eax, DWORD PTR [rax+928]
  012a7	89 81 34 02 00
	00		 mov	 DWORD PTR [rcx+564], eax

; 1219 : 					prop->hiddenVolume = ListExtension->cryptoInfo->hiddenVolume;

  012ad	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$31984[rsp]
  012b5	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  012bc	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR prop$31979[rsp]
  012c4	8b 80 a0 29 00
	00		 mov	 eax, DWORD PTR [rax+10656]
  012ca	89 81 28 02 00
	00		 mov	 DWORD PTR [rcx+552], eax

; 1220 : 
; 1221 : 					if (ListExtension->cryptoInfo->bProtectHiddenVolume)

  012d0	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$31984[rsp]
  012d8	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  012df	83 b8 00 44 00
	00 00		 cmp	 DWORD PTR [rax+17408], 0
  012e6	74 47		 je	 SHORT $LN73@ProcessMai

; 1222 : 						prop->hiddenVolProtection = ListExtension->cryptoInfo->bHiddenVolProtectionAction ? HIDVOL_PROT_STATUS_ACTION_TAKEN : HIDVOL_PROT_STATUS_ACTIVE;

  012e8	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$31984[rsp]
  012f0	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  012f7	83 b8 04 44 00
	00 00		 cmp	 DWORD PTR [rax+17412], 0
  012fe	74 0d		 je	 SHORT $LN172@ProcessMai
  01300	c7 84 24 74 05
	00 00 02 00 00
	00		 mov	 DWORD PTR tv599[rsp], 2
  0130b	eb 0b		 jmp	 SHORT $LN173@ProcessMai
$LN172@ProcessMai:
  0130d	c7 84 24 74 05
	00 00 01 00 00
	00		 mov	 DWORD PTR tv599[rsp], 1
$LN173@ProcessMai:
  01318	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR prop$31979[rsp]
  01320	8b 84 24 74 05
	00 00		 mov	 eax, DWORD PTR tv599[rsp]
  01327	89 81 4c 02 00
	00		 mov	 DWORD PTR [rcx+588], eax

; 1223 : 					else

  0132d	eb 12		 jmp	 SHORT $LN72@ProcessMai
$LN73@ProcessMai:

; 1224 : 						prop->hiddenVolProtection = HIDVOL_PROT_STATUS_NONE;

  0132f	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR prop$31979[rsp]
  01337	c7 80 4c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+588], 0
$LN72@ProcessMai:

; 1225 : 
; 1226 : 					prop->totalBytesRead = ListExtension->Queue.TotalBytesRead;

  01341	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR prop$31979[rsp]
  01349	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$31984[rsp]
  01351	48 8b 80 58 03
	00 00		 mov	 rax, QWORD PTR [rax+856]
  01358	48 89 81 3c 02
	00 00		 mov	 QWORD PTR [rcx+572], rax

; 1227 : 					prop->totalBytesWritten = ListExtension->Queue.TotalBytesWritten;

  0135f	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR prop$31979[rsp]
  01367	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$31984[rsp]
  0136f	48 8b 80 60 03
	00 00		 mov	 rax, QWORD PTR [rax+864]
  01376	48 89 81 44 02
	00 00		 mov	 QWORD PTR [rcx+580], rax

; 1228 : 
; 1229 : 					prop->volFormatVersion = ListExtension->cryptoInfo->LegacyVolume ? TC_VOLUME_FORMAT_VERSION_PRE_6_0 : TC_VOLUME_FORMAT_VERSION;

  0137d	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR ListExtension$31984[rsp]
  01385	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0138c	83 b8 3c 44 00
	00 00		 cmp	 DWORD PTR [rax+17468], 0
  01393	74 0d		 je	 SHORT $LN174@ProcessMai
  01395	c7 84 24 78 05
	00 00 01 00 00
	00		 mov	 DWORD PTR tv609[rsp], 1
  013a0	eb 0b		 jmp	 SHORT $LN175@ProcessMai
$LN174@ProcessMai:
  013a2	c7 84 24 78 05
	00 00 02 00 00
	00		 mov	 DWORD PTR tv609[rsp], 2
$LN175@ProcessMai:
  013ad	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR prop$31979[rsp]
  013b5	8b 84 24 78 05
	00 00		 mov	 eax, DWORD PTR tv609[rsp]
  013bc	89 81 50 02 00
	00		 mov	 DWORD PTR [rcx+592], eax

; 1230 : 
; 1231 : 					Irp->IoStatus.Status = STATUS_SUCCESS;

  013c2	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  013ca	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 1232 : 					Irp->IoStatus.Information = sizeof (VOLUME_PROPERTIES_STRUCT);

  013d1	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  013d9	48 c7 40 38 54
	02 00 00	 mov	 QWORD PTR [rax+56], 596	; 00000254H
$LN74@ProcessMai:
$LN75@ProcessMai:
$LN76@ProcessMai:

; 1233 : 				}
; 1234 : 			}
; 1235 : 		}
; 1236 : 		break;

  013e1	e9 95 0c 00 00	 jmp	 $LN160@ProcessMai
$LN71@ProcessMai:

; 1237 : 
; 1238 : 	case TC_IOCTL_GET_RESOLVED_SYMLINK:
; 1239 : 		if (ValidateIOBufferSize (Irp, sizeof (RESOLVE_SYMLINK_STRUCT), ValidateInputOutput))

  013e6	41 b8 02 00 00
	00		 mov	 r8d, 2
  013ec	ba 10 04 00 00	 mov	 edx, 1040		; 00000410H
  013f1	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  013f9	e8 00 00 00 00	 call	 ValidateIOBufferSize
  013fe	85 c0		 test	 eax, eax
  01400	74 70		 je	 SHORT $LN70@ProcessMai

; 1240 : 		{
; 1241 : 			RESOLVE_SYMLINK_STRUCT *resolve = (RESOLVE_SYMLINK_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  01402	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0140a	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0140e	48 89 84 24 c0
	03 00 00	 mov	 QWORD PTR resolve$31994[rsp], rax

; 1242 : 			{
; 1243 : 				NTSTATUS ntStatus;
; 1244 : 
; 1245 : 				EnsureNullTerminatedString (resolve->symLinkName, sizeof (resolve->symLinkName));

  01416	ba 08 02 00 00	 mov	 edx, 520		; 00000208H
  0141b	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR resolve$31994[rsp]
  01423	e8 00 00 00 00	 call	 EnsureNullTerminatedString

; 1246 : 
; 1247 : 				ntStatus = SymbolicLinkToTarget (resolve->symLinkName,
; 1248 : 					resolve->targetName,
; 1249 : 					sizeof (resolve->targetName));

  01428	48 8b 94 24 c0
	03 00 00	 mov	 rdx, QWORD PTR resolve$31994[rsp]
  01430	48 81 c2 08 02
	00 00		 add	 rdx, 520		; 00000208H
  01437	66 41 b8 08 02	 mov	 r8w, 520		; 00000208H
  0143c	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR resolve$31994[rsp]
  01444	e8 00 00 00 00	 call	 SymbolicLinkToTarget
  01449	89 84 24 c8 03
	00 00		 mov	 DWORD PTR ntStatus$31996[rsp], eax

; 1250 : 
; 1251 : 				Irp->IoStatus.Information = sizeof (RESOLVE_SYMLINK_STRUCT);

  01450	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01458	48 c7 40 38 10
	04 00 00	 mov	 QWORD PTR [rax+56], 1040 ; 00000410H

; 1252 : 				Irp->IoStatus.Status = ntStatus;

  01460	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01468	8b 84 24 c8 03
	00 00		 mov	 eax, DWORD PTR ntStatus$31996[rsp]
  0146f	89 41 30	 mov	 DWORD PTR [rcx+48], eax
$LN70@ProcessMai:

; 1253 : 			}
; 1254 : 		}
; 1255 : 		break;

  01472	e9 04 0c 00 00	 jmp	 $LN160@ProcessMai
$LN69@ProcessMai:

; 1256 : 
; 1257 : 	case TC_IOCTL_GET_DRIVE_PARTITION_INFO:
; 1258 : 		if (ValidateIOBufferSize (Irp, sizeof (DISK_PARTITION_INFO_STRUCT), ValidateInputOutput))

  01477	41 b8 02 00 00
	00		 mov	 r8d, 2
  0147d	ba 30 02 00 00	 mov	 edx, 560		; 00000230H
  01482	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  0148a	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0148f	85 c0		 test	 eax, eax
  01491	0f 84 85 02 00
	00		 je	 $LN68@ProcessMai

; 1259 : 		{
; 1260 : 			DISK_PARTITION_INFO_STRUCT *info = (DISK_PARTITION_INFO_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  01497	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0149f	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  014a3	48 89 84 24 d0
	03 00 00	 mov	 QWORD PTR info$32001[rsp], rax

; 1261 : 			{
; 1262 : 				PARTITION_INFORMATION_EX pi;
; 1263 : 				NTSTATUS ntStatus;
; 1264 : 
; 1265 : 				EnsureNullTerminatedString (info->deviceName, sizeof (info->deviceName));

  014ab	ba 08 02 00 00	 mov	 edx, 520		; 00000208H
  014b0	48 8b 8c 24 d0
	03 00 00	 mov	 rcx, QWORD PTR info$32001[rsp]
  014b8	e8 00 00 00 00	 call	 EnsureNullTerminatedString

; 1266 : 
; 1267 : 				ntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0, &pi, sizeof (pi));

  014bd	c7 44 24 28 90
	00 00 00	 mov	 DWORD PTR [rsp+40], 144	; 00000090H
  014c5	48 8d 84 24 e0
	03 00 00	 lea	 rax, QWORD PTR pi$32003[rsp]
  014cd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  014d2	45 33 c9	 xor	 r9d, r9d
  014d5	45 33 c0	 xor	 r8d, r8d
  014d8	ba 48 00 07 00	 mov	 edx, 458824		; 00070048H
  014dd	48 8b 8c 24 d0
	03 00 00	 mov	 rcx, QWORD PTR info$32001[rsp]
  014e5	e8 00 00 00 00	 call	 TCDeviceIoControl
  014ea	89 84 24 70 04
	00 00		 mov	 DWORD PTR ntStatus$32004[rsp], eax

; 1268 : 				if (NT_SUCCESS(ntStatus))

  014f1	83 bc 24 70 04
	00 00 00	 cmp	 DWORD PTR ntStatus$32004[rsp], 0
  014f9	0f 8c ca 00 00
	00		 jl	 $LN67@ProcessMai

; 1269 : 				{
; 1270 : 					memset (&info->partInfo, 0, sizeof (info->partInfo));

  014ff	48 8b bc 24 d0
	03 00 00	 mov	 rdi, QWORD PTR info$32001[rsp]
  01507	48 81 c7 08 02
	00 00		 add	 rdi, 520		; 00000208H
  0150e	33 c0		 xor	 eax, eax
  01510	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01515	f3 aa		 rep stosb

; 1271 : 
; 1272 : 					info->partInfo.PartitionLength = pi.PartitionLength;

  01517	48 8b 94 24 d0
	03 00 00	 mov	 rdx, QWORD PTR info$32001[rsp]
  0151f	48 8b 84 24 f0
	03 00 00	 mov	 rax, QWORD PTR pi$32003[rsp+16]
  01527	48 89 82 10 02
	00 00		 mov	 QWORD PTR [rdx+528], rax

; 1273 : 					info->partInfo.PartitionNumber = pi.PartitionNumber;

  0152e	48 8b 8c 24 d0
	03 00 00	 mov	 rcx, QWORD PTR info$32001[rsp]
  01536	8b 84 24 f8 03
	00 00		 mov	 eax, DWORD PTR pi$32003[rsp+24]
  0153d	89 81 1c 02 00
	00		 mov	 DWORD PTR [rcx+540], eax

; 1274 : 					info->partInfo.StartingOffset = pi.StartingOffset;

  01543	48 8b 8c 24 d0
	03 00 00	 mov	 rcx, QWORD PTR info$32001[rsp]
  0154b	48 8b 84 24 e8
	03 00 00	 mov	 rax, QWORD PTR pi$32003[rsp+8]
  01553	48 89 81 08 02
	00 00		 mov	 QWORD PTR [rcx+520], rax

; 1275 : 
; 1276 : 					if (pi.PartitionStyle == PARTITION_STYLE_MBR)

  0155a	83 bc 24 e0 03
	00 00 00	 cmp	 DWORD PTR pi$32003[rsp], 0
  01562	75 2c		 jne	 SHORT $LN66@ProcessMai

; 1277 : 					{
; 1278 : 						info->partInfo.PartitionType = pi.Mbr.PartitionType;

  01564	48 8b 8c 24 d0
	03 00 00	 mov	 rcx, QWORD PTR info$32001[rsp]
  0156c	0f b6 84 24 00
	04 00 00	 movzx	 eax, BYTE PTR pi$32003[rsp+32]
  01574	88 81 20 02 00
	00		 mov	 BYTE PTR [rcx+544], al

; 1279 : 						info->partInfo.BootIndicator = pi.Mbr.BootIndicator;

  0157a	48 8b 8c 24 d0
	03 00 00	 mov	 rcx, QWORD PTR info$32001[rsp]
  01582	0f b6 84 24 01
	04 00 00	 movzx	 eax, BYTE PTR pi$32003[rsp+33]
  0158a	88 81 21 02 00
	00		 mov	 BYTE PTR [rcx+545], al
$LN66@ProcessMai:

; 1280 : 					}
; 1281 : 
; 1282 : 					info->IsGPT = pi.PartitionStyle == PARTITION_STYLE_GPT;

  01590	83 bc 24 e0 03
	00 00 01	 cmp	 DWORD PTR pi$32003[rsp], 1
  01598	75 0d		 jne	 SHORT $LN176@ProcessMai
  0159a	c7 84 24 7c 05
	00 00 01 00 00
	00		 mov	 DWORD PTR tv688[rsp], 1
  015a5	eb 0b		 jmp	 SHORT $LN177@ProcessMai
$LN176@ProcessMai:
  015a7	c7 84 24 7c 05
	00 00 00 00 00
	00		 mov	 DWORD PTR tv688[rsp], 0
$LN177@ProcessMai:
  015b2	48 8b 8c 24 d0
	03 00 00	 mov	 rcx, QWORD PTR info$32001[rsp]
  015ba	8b 84 24 7c 05
	00 00		 mov	 eax, DWORD PTR tv688[rsp]
  015c1	89 81 28 02 00
	00		 mov	 DWORD PTR [rcx+552], eax

; 1283 : 				}
; 1284 : 				else

  015c7	eb 4c		 jmp	 SHORT $LN65@ProcessMai
$LN67@ProcessMai:

; 1285 : 				{
; 1286 : 					// Windows 2000 does not support IOCTL_DISK_GET_PARTITION_INFO_EX
; 1287 : 					ntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0, &info->partInfo, sizeof (info->partInfo));

  015c9	48 8b 84 24 d0
	03 00 00	 mov	 rax, QWORD PTR info$32001[rsp]
  015d1	48 05 08 02 00
	00		 add	 rax, 520		; 00000208H
  015d7	c7 44 24 28 20
	00 00 00	 mov	 DWORD PTR [rsp+40], 32	; 00000020H
  015df	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  015e4	45 33 c9	 xor	 r9d, r9d
  015e7	45 33 c0	 xor	 r8d, r8d
  015ea	ba 04 40 07 00	 mov	 edx, 475140		; 00074004H
  015ef	48 8b 8c 24 d0
	03 00 00	 mov	 rcx, QWORD PTR info$32001[rsp]
  015f7	e8 00 00 00 00	 call	 TCDeviceIoControl
  015fc	89 84 24 70 04
	00 00		 mov	 DWORD PTR ntStatus$32004[rsp], eax

; 1288 : 					info->IsGPT = FALSE;

  01603	48 8b 84 24 d0
	03 00 00	 mov	 rax, QWORD PTR info$32001[rsp]
  0160b	c7 80 28 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+552], 0
$LN65@ProcessMai:

; 1289 : 				}
; 1290 : 
; 1291 : 				if (!NT_SUCCESS (ntStatus))

  01615	83 bc 24 70 04
	00 00 00	 cmp	 DWORD PTR ntStatus$32004[rsp], 0
  0161d	7d 6d		 jge	 SHORT $LN64@ProcessMai

; 1292 : 				{
; 1293 : 					GET_LENGTH_INFORMATION lengthInfo;
; 1294 : 					ntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_LENGTH_INFO, NULL, 0, &lengthInfo, sizeof (lengthInfo));

  0161f	c7 44 24 28 08
	00 00 00	 mov	 DWORD PTR [rsp+40], 8
  01627	48 8d 84 24 78
	04 00 00	 lea	 rax, QWORD PTR lengthInfo$32013[rsp]
  0162f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01634	45 33 c9	 xor	 r9d, r9d
  01637	45 33 c0	 xor	 r8d, r8d
  0163a	ba 5c 40 07 00	 mov	 edx, 475228		; 0007405cH
  0163f	48 8b 8c 24 d0
	03 00 00	 mov	 rcx, QWORD PTR info$32001[rsp]
  01647	e8 00 00 00 00	 call	 TCDeviceIoControl
  0164c	89 84 24 70 04
	00 00		 mov	 DWORD PTR ntStatus$32004[rsp], eax

; 1295 : 
; 1296 : 					if (NT_SUCCESS (ntStatus))

  01653	83 bc 24 70 04
	00 00 00	 cmp	 DWORD PTR ntStatus$32004[rsp], 0
  0165b	7c 2f		 jl	 SHORT $LN63@ProcessMai

; 1297 : 					{
; 1298 : 						memset (&info->partInfo, 0, sizeof (info->partInfo));

  0165d	48 8b bc 24 d0
	03 00 00	 mov	 rdi, QWORD PTR info$32001[rsp]
  01665	48 81 c7 08 02
	00 00		 add	 rdi, 520		; 00000208H
  0166c	33 c0		 xor	 eax, eax
  0166e	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01673	f3 aa		 rep stosb

; 1299 : 						info->partInfo.PartitionLength = lengthInfo.Length;

  01675	48 8b 94 24 d0
	03 00 00	 mov	 rdx, QWORD PTR info$32001[rsp]
  0167d	48 8b 84 24 78
	04 00 00	 mov	 rax, QWORD PTR lengthInfo$32013[rsp]
  01685	48 89 82 10 02
	00 00		 mov	 QWORD PTR [rdx+528], rax
$LN63@ProcessMai:
$LN64@ProcessMai:

; 1300 : 					}
; 1301 : 				}
; 1302 : 
; 1303 : 				info->IsDynamic = FALSE;

  0168c	48 8b 84 24 d0
	03 00 00	 mov	 rax, QWORD PTR info$32001[rsp]
  01694	c7 80 2c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+556], 0

; 1304 : 
; 1305 : 				if (NT_SUCCESS (ntStatus) && OsMajorVersion >= 6)

  0169e	83 bc 24 70 04
	00 00 00	 cmp	 DWORD PTR ntStatus$32004[rsp], 0
  016a6	7c 52		 jl	 SHORT $LN62@ProcessMai
  016a8	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR OsMajorVersion, 6
  016af	72 49		 jb	 SHORT $LN62@ProcessMai

; 1306 : 				{
; 1307 : #					define IOCTL_VOLUME_IS_DYNAMIC CTL_CODE(IOCTL_VOLUME_BASE, 18, METHOD_BUFFERED, FILE_ANY_ACCESS)
; 1308 : 					if (!NT_SUCCESS (TCDeviceIoControl (info->deviceName, IOCTL_VOLUME_IS_DYNAMIC, NULL, 0, &info->IsDynamic, sizeof (info->IsDynamic))))

  016b1	48 8b 84 24 d0
	03 00 00	 mov	 rax, QWORD PTR info$32001[rsp]
  016b9	48 05 2c 02 00
	00		 add	 rax, 556		; 0000022cH
  016bf	c7 44 24 28 04
	00 00 00	 mov	 DWORD PTR [rsp+40], 4
  016c7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  016cc	45 33 c9	 xor	 r9d, r9d
  016cf	45 33 c0	 xor	 r8d, r8d
  016d2	ba 48 00 56 00	 mov	 edx, 5636168		; 00560048H
  016d7	48 8b 8c 24 d0
	03 00 00	 mov	 rcx, QWORD PTR info$32001[rsp]
  016df	e8 00 00 00 00	 call	 TCDeviceIoControl
  016e4	85 c0		 test	 eax, eax
  016e6	7d 12		 jge	 SHORT $LN61@ProcessMai

; 1309 : 						info->IsDynamic = FALSE;

  016e8	48 8b 84 24 d0
	03 00 00	 mov	 rax, QWORD PTR info$32001[rsp]
  016f0	c7 80 2c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+556], 0
$LN61@ProcessMai:
$LN62@ProcessMai:

; 1310 : 				}
; 1311 : 
; 1312 : 				Irp->IoStatus.Information = sizeof (DISK_PARTITION_INFO_STRUCT);

  016fa	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01702	48 c7 40 38 30
	02 00 00	 mov	 QWORD PTR [rax+56], 560	; 00000230H

; 1313 : 				Irp->IoStatus.Status = ntStatus;

  0170a	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01712	8b 84 24 70 04
	00 00		 mov	 eax, DWORD PTR ntStatus$32004[rsp]
  01719	89 41 30	 mov	 DWORD PTR [rcx+48], eax
$LN68@ProcessMai:

; 1314 : 			}
; 1315 : 		}
; 1316 : 		break;

  0171c	e9 5a 09 00 00	 jmp	 $LN160@ProcessMai
$LN60@ProcessMai:

; 1317 : 
; 1318 : 	case TC_IOCTL_GET_DRIVE_GEOMETRY:
; 1319 : 		if (ValidateIOBufferSize (Irp, sizeof (DISK_GEOMETRY_STRUCT), ValidateInputOutput))

  01721	41 b8 02 00 00
	00		 mov	 r8d, 2
  01727	ba 20 02 00 00	 mov	 edx, 544		; 00000220H
  0172c	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01734	e8 00 00 00 00	 call	 ValidateIOBufferSize
  01739	85 c0		 test	 eax, eax
  0173b	0f 84 82 00 00
	00		 je	 $LN59@ProcessMai

; 1320 : 		{
; 1321 : 			DISK_GEOMETRY_STRUCT *g = (DISK_GEOMETRY_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  01741	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01749	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0174d	48 89 84 24 80
	04 00 00	 mov	 QWORD PTR g$32026[rsp], rax

; 1322 : 			{
; 1323 : 				NTSTATUS ntStatus;
; 1324 : 
; 1325 : 				EnsureNullTerminatedString (g->deviceName, sizeof (g->deviceName));

  01755	ba 08 02 00 00	 mov	 edx, 520		; 00000208H
  0175a	48 8b 8c 24 80
	04 00 00	 mov	 rcx, QWORD PTR g$32026[rsp]
  01762	e8 00 00 00 00	 call	 EnsureNullTerminatedString

; 1326 : 
; 1327 : 				ntStatus = TCDeviceIoControl (g->deviceName,
; 1328 : 					IOCTL_DISK_GET_DRIVE_GEOMETRY,
; 1329 : 					NULL, 0, &g->diskGeometry, sizeof (g->diskGeometry));

  01767	48 8b 84 24 80
	04 00 00	 mov	 rax, QWORD PTR g$32026[rsp]
  0176f	48 05 08 02 00
	00		 add	 rax, 520		; 00000208H
  01775	c7 44 24 28 18
	00 00 00	 mov	 DWORD PTR [rsp+40], 24
  0177d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01782	45 33 c9	 xor	 r9d, r9d
  01785	45 33 c0	 xor	 r8d, r8d
  01788	ba 00 00 07 00	 mov	 edx, 458752		; 00070000H
  0178d	48 8b 8c 24 80
	04 00 00	 mov	 rcx, QWORD PTR g$32026[rsp]
  01795	e8 00 00 00 00	 call	 TCDeviceIoControl
  0179a	89 84 24 88 04
	00 00		 mov	 DWORD PTR ntStatus$32028[rsp], eax

; 1330 : 
; 1331 : 				Irp->IoStatus.Information = sizeof (DISK_GEOMETRY_STRUCT);

  017a1	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  017a9	48 c7 40 38 20
	02 00 00	 mov	 QWORD PTR [rax+56], 544	; 00000220H

; 1332 : 				Irp->IoStatus.Status = ntStatus;

  017b1	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  017b9	8b 84 24 88 04
	00 00		 mov	 eax, DWORD PTR ntStatus$32028[rsp]
  017c0	89 41 30	 mov	 DWORD PTR [rcx+48], eax
$LN59@ProcessMai:

; 1333 : 			}
; 1334 : 		}
; 1335 : 		break;

  017c3	e9 b3 08 00 00	 jmp	 $LN160@ProcessMai
$LN58@ProcessMai:

; 1336 : 
; 1337 : 	case TC_IOCTL_PROBE_REAL_DRIVE_SIZE:
; 1338 : 		if (ValidateIOBufferSize (Irp, sizeof (ProbeRealDriveSizeRequest), ValidateInputOutput))

  017c8	41 b8 02 00 00
	00		 mov	 r8d, 2
  017ce	ba 14 02 00 00	 mov	 edx, 532		; 00000214H
  017d3	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  017db	e8 00 00 00 00	 call	 ValidateIOBufferSize
  017e0	85 c0		 test	 eax, eax
  017e2	0f 84 6a 01 00
	00		 je	 $LN57@ProcessMai

; 1339 : 		{
; 1340 : 			ProbeRealDriveSizeRequest *request = (ProbeRealDriveSizeRequest *) Irp->AssociatedIrp.SystemBuffer;

  017e8	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  017f0	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  017f4	48 89 84 24 b0
	04 00 00	 mov	 QWORD PTR request$32034[rsp], rax

; 1341 : 			NTSTATUS status;
; 1342 : 			UNICODE_STRING name;
; 1343 : 			PFILE_OBJECT fileObject;
; 1344 : 			PDEVICE_OBJECT deviceObject;
; 1345 : 
; 1346 : 			EnsureNullTerminatedString (request->DeviceName, sizeof (request->DeviceName));

  017fc	ba 08 02 00 00	 mov	 edx, 520		; 00000208H
  01801	48 8b 8c 24 b0
	04 00 00	 mov	 rcx, QWORD PTR request$32034[rsp]
  01809	e8 00 00 00 00	 call	 EnsureNullTerminatedString

; 1347 : 
; 1348 : 			RtlInitUnicodeString (&name, request->DeviceName);

  0180e	48 8b 94 24 b0
	04 00 00	 mov	 rdx, QWORD PTR request$32034[rsp]
  01816	48 8d 8c 24 a0
	04 00 00	 lea	 rcx, QWORD PTR name$32037[rsp]
  0181e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 1349 : 			status = IoGetDeviceObjectPointer (&name, FILE_READ_ATTRIBUTES, &fileObject, &deviceObject);

  01824	4c 8d 8c 24 90
	04 00 00	 lea	 r9, QWORD PTR deviceObject$32039[rsp]
  0182c	4c 8d 84 24 98
	04 00 00	 lea	 r8, QWORD PTR fileObject$32038[rsp]
  01834	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  01839	48 8d 8c 24 a0
	04 00 00	 lea	 rcx, QWORD PTR name$32037[rsp]
  01841	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetDeviceObjectPointer
  01847	89 84 24 b8 04
	00 00		 mov	 DWORD PTR status$32036[rsp], eax

; 1350 : 			if (!NT_SUCCESS (status))

  0184e	83 bc 24 b8 04
	00 00 00	 cmp	 DWORD PTR status$32036[rsp], 0
  01856	7d 27		 jge	 SHORT $LN56@ProcessMai

; 1351 : 			{
; 1352 : 				Irp->IoStatus.Information = 0;

  01858	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01860	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1353 : 				Irp->IoStatus.Status = status;

  01868	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01870	8b 84 24 b8 04
	00 00		 mov	 eax, DWORD PTR status$32036[rsp]
  01877	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 1354 : 				break;

  0187a	e9 fc 07 00 00	 jmp	 $LN160@ProcessMai
$LN56@ProcessMai:

; 1355 : 			}
; 1356 : 
; 1357 : 			status = ProbeRealDriveSize (deviceObject, &request->RealDriveSize);

  0187f	48 8b 94 24 b0
	04 00 00	 mov	 rdx, QWORD PTR request$32034[rsp]
  01887	48 81 c2 08 02
	00 00		 add	 rdx, 520		; 00000208H
  0188e	48 8b 8c 24 90
	04 00 00	 mov	 rcx, QWORD PTR deviceObject$32039[rsp]
  01896	e8 00 00 00 00	 call	 ProbeRealDriveSize
  0189b	89 84 24 b8 04
	00 00		 mov	 DWORD PTR status$32036[rsp], eax

; 1358 : 			ObDereferenceObject (fileObject);

  018a2	48 8b 8c 24 98
	04 00 00	 mov	 rcx, QWORD PTR fileObject$32038[rsp]
  018aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 1359 : 
; 1360 : 			if (status == STATUS_TIMEOUT)

  018b0	81 bc 24 b8 04
	00 00 02 01 00
	00		 cmp	 DWORD PTR status$32036[rsp], 258 ; 00000102H
  018bb	75 33		 jne	 SHORT $LN55@ProcessMai

; 1361 : 			{
; 1362 : 				request->TimeOut = TRUE;

  018bd	48 8b 84 24 b0
	04 00 00	 mov	 rax, QWORD PTR request$32034[rsp]
  018c5	c7 80 10 02 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+528], 1

; 1363 : 				Irp->IoStatus.Information = sizeof (ProbeRealDriveSizeRequest);

  018cf	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  018d7	48 c7 40 38 14
	02 00 00	 mov	 QWORD PTR [rax+56], 532	; 00000214H

; 1364 : 				Irp->IoStatus.Status = STATUS_SUCCESS;

  018df	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  018e7	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0
  018ee	eb 62		 jmp	 SHORT $LN54@ProcessMai
$LN55@ProcessMai:

; 1365 : 			}
; 1366 : 			else if (!NT_SUCCESS (status))

  018f0	83 bc 24 b8 04
	00 00 00	 cmp	 DWORD PTR status$32036[rsp], 0
  018f8	7d 24		 jge	 SHORT $LN53@ProcessMai

; 1367 : 			{
; 1368 : 				Irp->IoStatus.Information = 0;

  018fa	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01902	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1369 : 				Irp->IoStatus.Status = status;

  0190a	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01912	8b 84 24 b8 04
	00 00		 mov	 eax, DWORD PTR status$32036[rsp]
  01919	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 1370 : 			}
; 1371 : 			else

  0191c	eb 34		 jmp	 SHORT $LN52@ProcessMai
$LN53@ProcessMai:

; 1372 : 			{
; 1373 : 				request->TimeOut = FALSE;

  0191e	48 8b 84 24 b0
	04 00 00	 mov	 rax, QWORD PTR request$32034[rsp]
  01926	c7 80 10 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+528], 0

; 1374 : 				Irp->IoStatus.Information = sizeof (ProbeRealDriveSizeRequest);

  01930	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01938	48 c7 40 38 14
	02 00 00	 mov	 QWORD PTR [rax+56], 532	; 00000214H

; 1375 : 				Irp->IoStatus.Status = status;

  01940	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01948	8b 84 24 b8 04
	00 00		 mov	 eax, DWORD PTR status$32036[rsp]
  0194f	89 41 30	 mov	 DWORD PTR [rcx+48], eax
$LN52@ProcessMai:
$LN54@ProcessMai:
$LN57@ProcessMai:

; 1376 : 			}
; 1377 : 		}
; 1378 : 		break;

  01952	e9 24 07 00 00	 jmp	 $LN160@ProcessMai
$LN51@ProcessMai:

; 1379 : 
; 1380 : 	case TC_IOCTL_MOUNT_VOLUME:
; 1381 : 		if (ValidateIOBufferSize (Irp, sizeof (MOUNT_STRUCT), ValidateInputOutput))

  01957	41 b8 02 00 00
	00		 mov	 r8d, 2
  0195d	ba e0 02 00 00	 mov	 edx, 736		; 000002e0H
  01962	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  0196a	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0196f	85 c0		 test	 eax, eax
  01971	0f 84 9c 01 00
	00		 je	 $LN50@ProcessMai

; 1382 : 		{
; 1383 : 			MOUNT_STRUCT *mount = (MOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  01977	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  0197f	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  01983	48 89 84 24 c0
	04 00 00	 mov	 QWORD PTR mount$32054[rsp], rax

; 1384 : 
; 1385 : 			if (mount->VolumePassword.Length > MAX_PASSWORD || mount->ProtectedHidVolPassword.Length > MAX_PASSWORD)

  0198b	48 8b 84 24 c0
	04 00 00	 mov	 rax, QWORD PTR mount$32054[rsp]
  01993	83 b8 18 02 00
	00 40		 cmp	 DWORD PTR [rax+536], 64	; 00000040H
  0199a	77 11		 ja	 SHORT $LN48@ProcessMai
  0199c	48 8b 84 24 c0
	04 00 00	 mov	 rax, QWORD PTR mount$32054[rsp]
  019a4	83 b8 90 02 00
	00 40		 cmp	 DWORD PTR [rax+656], 64	; 00000040H
  019ab	76 24		 jbe	 SHORT $LN49@ProcessMai
$LN48@ProcessMai:

; 1386 : 			{
; 1387 : 				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  019ad	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  019b5	c7 40 30 0d 00
	00 c0		 mov	 DWORD PTR [rax+48], -1073741811 ; ffffffffc000000dH

; 1388 : 				Irp->IoStatus.Information = 0;

  019bc	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  019c4	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1389 : 				break;

  019cc	e9 aa 06 00 00	 jmp	 $LN160@ProcessMai
$LN49@ProcessMai:

; 1390 : 			}
; 1391 : 
; 1392 : 			EnsureNullTerminatedString (mount->wszVolume, sizeof (mount->wszVolume));

  019d1	48 8b 8c 24 c0
	04 00 00	 mov	 rcx, QWORD PTR mount$32054[rsp]
  019d9	48 83 c1 10	 add	 rcx, 16
  019dd	ba 08 02 00 00	 mov	 edx, 520		; 00000208H
  019e2	e8 00 00 00 00	 call	 EnsureNullTerminatedString

; 1393 : 
; 1394 : 			Irp->IoStatus.Information = sizeof (MOUNT_STRUCT);

  019e7	48 8b 94 24 c0
	05 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  019ef	48 c7 42 38 e0
	02 00 00	 mov	 QWORD PTR [rdx+56], 736	; 000002e0H

; 1395 : 			Irp->IoStatus.Status = MountDevice (DeviceObject, mount);

  019f7	48 8b 94 24 c0
	04 00 00	 mov	 rdx, QWORD PTR mount$32054[rsp]
  019ff	48 8b 8c 24 b0
	05 00 00	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  01a07	e8 00 00 00 00	 call	 MountDevice
  01a0c	8b d0		 mov	 edx, eax
  01a0e	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01a16	89 50 30	 mov	 DWORD PTR [rax+48], edx
$LN47@ProcessMai:

; 1396 : 
; 1397 : 			burn (&mount->VolumePassword, sizeof (mount->VolumePassword));

  01a19	48 8b 84 24 c0
	04 00 00	 mov	 rax, QWORD PTR mount$32054[rsp]
  01a21	48 05 18 02 00
	00		 add	 rax, 536		; 00000218H
  01a27	48 89 84 24 d0
	04 00 00	 mov	 QWORD PTR burnm$32063[rsp], rax
  01a2f	c7 84 24 c8 04
	00 00 48 00 00
	00		 mov	 DWORD PTR burnc$32065[rsp], 72 ; 00000048H
  01a3a	48 8b 8c 24 c0
	04 00 00	 mov	 rcx, QWORD PTR mount$32054[rsp]
  01a42	48 81 c1 18 02
	00 00		 add	 rcx, 536		; 00000218H
  01a49	ba 48 00 00 00	 mov	 edx, 72			; 00000048H
  01a4e	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN44@ProcessMai:
  01a53	8b 8c 24 c8 04
	00 00		 mov	 ecx, DWORD PTR burnc$32065[rsp]
  01a5a	8b 84 24 c8 04
	00 00		 mov	 eax, DWORD PTR burnc$32065[rsp]
  01a61	83 e8 01	 sub	 eax, 1
  01a64	89 84 24 c8 04
	00 00		 mov	 DWORD PTR burnc$32065[rsp], eax
  01a6b	85 c9		 test	 ecx, ecx
  01a6d	74 21		 je	 SHORT $LN43@ProcessMai
  01a6f	48 8b 84 24 d0
	04 00 00	 mov	 rax, QWORD PTR burnm$32063[rsp]
  01a77	c6 00 00	 mov	 BYTE PTR [rax], 0
  01a7a	48 8b 84 24 d0
	04 00 00	 mov	 rax, QWORD PTR burnm$32063[rsp]
  01a82	48 83 c0 01	 add	 rax, 1
  01a86	48 89 84 24 d0
	04 00 00	 mov	 QWORD PTR burnm$32063[rsp], rax
  01a8e	eb c3		 jmp	 SHORT $LN44@ProcessMai
$LN43@ProcessMai:
  01a90	33 c0		 xor	 eax, eax
  01a92	85 c0		 test	 eax, eax
  01a94	75 83		 jne	 SHORT $LN47@ProcessMai
$LN42@ProcessMai:

; 1398 : 			burn (&mount->ProtectedHidVolPassword, sizeof (mount->ProtectedHidVolPassword));

  01a96	48 8b 84 24 c0
	04 00 00	 mov	 rax, QWORD PTR mount$32054[rsp]
  01a9e	48 05 90 02 00
	00		 add	 rax, 656		; 00000290H
  01aa4	48 89 84 24 e0
	04 00 00	 mov	 QWORD PTR burnm$32072[rsp], rax
  01aac	c7 84 24 d8 04
	00 00 48 00 00
	00		 mov	 DWORD PTR burnc$32074[rsp], 72 ; 00000048H
  01ab7	48 8b 8c 24 c0
	04 00 00	 mov	 rcx, QWORD PTR mount$32054[rsp]
  01abf	48 81 c1 90 02
	00 00		 add	 rcx, 656		; 00000290H
  01ac6	ba 48 00 00 00	 mov	 edx, 72			; 00000048H
  01acb	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN39@ProcessMai:
  01ad0	8b 8c 24 d8 04
	00 00		 mov	 ecx, DWORD PTR burnc$32074[rsp]
  01ad7	8b 84 24 d8 04
	00 00		 mov	 eax, DWORD PTR burnc$32074[rsp]
  01ade	83 e8 01	 sub	 eax, 1
  01ae1	89 84 24 d8 04
	00 00		 mov	 DWORD PTR burnc$32074[rsp], eax
  01ae8	85 c9		 test	 ecx, ecx
  01aea	74 21		 je	 SHORT $LN38@ProcessMai
  01aec	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR burnm$32072[rsp]
  01af4	c6 00 00	 mov	 BYTE PTR [rax], 0
  01af7	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR burnm$32072[rsp]
  01aff	48 83 c0 01	 add	 rax, 1
  01b03	48 89 84 24 e0
	04 00 00	 mov	 QWORD PTR burnm$32072[rsp], rax
  01b0b	eb c3		 jmp	 SHORT $LN39@ProcessMai
$LN38@ProcessMai:
  01b0d	33 c0		 xor	 eax, eax
  01b0f	85 c0		 test	 eax, eax
  01b11	75 83		 jne	 SHORT $LN42@ProcessMai
$LN50@ProcessMai:

; 1399 : 		}
; 1400 : 		break;

  01b13	e9 63 05 00 00	 jmp	 $LN160@ProcessMai
$LN37@ProcessMai:

; 1401 : 
; 1402 : 	case TC_IOCTL_DISMOUNT_VOLUME:
; 1403 : 		if (ValidateIOBufferSize (Irp, sizeof (UNMOUNT_STRUCT), ValidateInputOutput))

  01b18	41 b8 02 00 00
	00		 mov	 r8d, 2
  01b1e	ba 10 00 00 00	 mov	 edx, 16
  01b23	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01b2b	e8 00 00 00 00	 call	 ValidateIOBufferSize
  01b30	85 c0		 test	 eax, eax
  01b32	0f 84 b7 00 00
	00		 je	 $LN36@ProcessMai

; 1404 : 		{
; 1405 : 			UNMOUNT_STRUCT *unmount = (UNMOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  01b38	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01b40	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  01b44	48 89 84 24 e8
	04 00 00	 mov	 QWORD PTR unmount$32081[rsp], rax

; 1406 : 			PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject (unmount->nDosDriveNo);

  01b4c	48 8b 84 24 e8
	04 00 00	 mov	 rax, QWORD PTR unmount$32081[rsp]
  01b54	8b 08		 mov	 ecx, DWORD PTR [rax]
  01b56	e8 00 00 00 00	 call	 GetVirtualVolumeDeviceObject
  01b5b	48 89 84 24 f0
	04 00 00	 mov	 QWORD PTR ListDevice$32083[rsp], rax

; 1407 : 
; 1408 : 			unmount->nReturnCode = ERR_DRIVE_NOT_FOUND;

  01b63	48 8b 84 24 e8
	04 00 00	 mov	 rax, QWORD PTR unmount$32081[rsp]
  01b6b	c7 40 0c 05 00
	00 00		 mov	 DWORD PTR [rax+12], 5

; 1409 : 
; 1410 : 			if (ListDevice)

  01b72	48 83 bc 24 f0
	04 00 00 00	 cmp	 QWORD PTR ListDevice$32083[rsp], 0
  01b7b	74 53		 je	 SHORT $LN35@ProcessMai

; 1411 : 			{
; 1412 : 				PEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;

  01b7d	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR ListDevice$32083[rsp]
  01b85	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  01b89	48 89 84 24 f8
	04 00 00	 mov	 QWORD PTR ListExtension$32085[rsp], rax

; 1413 : 
; 1414 : 				if (IsVolumeAccessibleByCurrentUser (ListExtension))

  01b91	48 8b 8c 24 f8
	04 00 00	 mov	 rcx, QWORD PTR ListExtension$32085[rsp]
  01b99	e8 00 00 00 00	 call	 IsVolumeAccessibleByCurrentUser
  01b9e	85 c0		 test	 eax, eax
  01ba0	74 2e		 je	 SHORT $LN34@ProcessMai

; 1415 : 					unmount->nReturnCode = UnmountDevice (unmount, ListDevice, unmount->ignoreOpenFiles);

  01ba2	48 8b 84 24 e8
	04 00 00	 mov	 rax, QWORD PTR unmount$32081[rsp]
  01baa	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  01bae	48 8b 94 24 f0
	04 00 00	 mov	 rdx, QWORD PTR ListDevice$32083[rsp]
  01bb6	48 8b 8c 24 e8
	04 00 00	 mov	 rcx, QWORD PTR unmount$32081[rsp]
  01bbe	e8 00 00 00 00	 call	 UnmountDevice
  01bc3	8b d0		 mov	 edx, eax
  01bc5	48 8b 84 24 e8
	04 00 00	 mov	 rax, QWORD PTR unmount$32081[rsp]
  01bcd	89 50 0c	 mov	 DWORD PTR [rax+12], edx
$LN34@ProcessMai:
$LN35@ProcessMai:

; 1416 : 			}
; 1417 : 
; 1418 : 			Irp->IoStatus.Information = sizeof (UNMOUNT_STRUCT);

  01bd0	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01bd8	48 c7 40 38 10
	00 00 00	 mov	 QWORD PTR [rax+56], 16

; 1419 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  01be0	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01be8	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0
$LN36@ProcessMai:

; 1420 : 		}
; 1421 : 		break;

  01bef	e9 87 04 00 00	 jmp	 $LN160@ProcessMai
$LN33@ProcessMai:

; 1422 : 
; 1423 : 	case TC_IOCTL_DISMOUNT_ALL_VOLUMES:
; 1424 : 		if (ValidateIOBufferSize (Irp, sizeof (UNMOUNT_STRUCT), ValidateInputOutput))

  01bf4	41 b8 02 00 00
	00		 mov	 r8d, 2
  01bfa	ba 10 00 00 00	 mov	 edx, 16
  01bff	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01c07	e8 00 00 00 00	 call	 ValidateIOBufferSize
  01c0c	85 c0		 test	 eax, eax
  01c0e	74 58		 je	 SHORT $LN32@ProcessMai

; 1425 : 		{
; 1426 : 			UNMOUNT_STRUCT *unmount = (UNMOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;

  01c10	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01c18	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  01c1c	48 89 84 24 00
	05 00 00	 mov	 QWORD PTR unmount$32093[rsp], rax

; 1427 : 
; 1428 : 			unmount->nReturnCode = UnmountAllDevices (unmount, unmount->ignoreOpenFiles);

  01c24	48 8b 84 24 00
	05 00 00	 mov	 rax, QWORD PTR unmount$32093[rsp]
  01c2c	8b 50 04	 mov	 edx, DWORD PTR [rax+4]
  01c2f	48 8b 8c 24 00
	05 00 00	 mov	 rcx, QWORD PTR unmount$32093[rsp]
  01c37	e8 00 00 00 00	 call	 UnmountAllDevices
  01c3c	8b d0		 mov	 edx, eax
  01c3e	48 8b 84 24 00
	05 00 00	 mov	 rax, QWORD PTR unmount$32093[rsp]
  01c46	89 50 0c	 mov	 DWORD PTR [rax+12], edx

; 1429 : 
; 1430 : 			Irp->IoStatus.Information = sizeof (UNMOUNT_STRUCT);

  01c49	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01c51	48 c7 40 38 10
	00 00 00	 mov	 QWORD PTR [rax+56], 16

; 1431 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  01c59	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01c61	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0
$LN32@ProcessMai:

; 1432 : 		}
; 1433 : 		break;

  01c68	e9 0e 04 00 00	 jmp	 $LN160@ProcessMai
$LN31@ProcessMai:

; 1434 : 
; 1435 : 	case TC_IOCTL_BOOT_ENCRYPTION_SETUP:
; 1436 : 		Irp->IoStatus.Status = StartBootEncryptionSetup (DeviceObject, Irp, irpSp);

  01c6d	4c 8b 44 24 68	 mov	 r8, QWORD PTR irpSp$[rsp]
  01c72	48 8b 94 24 c0
	05 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  01c7a	48 8b 8c 24 b0
	05 00 00	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  01c82	e8 00 00 00 00	 call	 StartBootEncryptionSetup
  01c87	8b d0		 mov	 edx, eax
  01c89	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01c91	89 50 30	 mov	 DWORD PTR [rax+48], edx

; 1437 : 		Irp->IoStatus.Information = 0;

  01c94	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01c9c	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1438 : 		break;

  01ca4	e9 d2 03 00 00	 jmp	 $LN160@ProcessMai
$LN30@ProcessMai:

; 1439 : 
; 1440 : 	case TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP:
; 1441 : 		Irp->IoStatus.Status = AbortBootEncryptionSetup();

  01ca9	e8 00 00 00 00	 call	 AbortBootEncryptionSetup
  01cae	8b d0		 mov	 edx, eax
  01cb0	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01cb8	89 50 30	 mov	 DWORD PTR [rax+48], edx

; 1442 : 		Irp->IoStatus.Information = 0;

  01cbb	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01cc3	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1443 : 		break;

  01ccb	e9 ab 03 00 00	 jmp	 $LN160@ProcessMai
$LN29@ProcessMai:

; 1444 : 
; 1445 : 	case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS:
; 1446 : 		GetBootEncryptionStatus (Irp, irpSp);

  01cd0	48 8b 54 24 68	 mov	 rdx, QWORD PTR irpSp$[rsp]
  01cd5	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01cdd	e8 00 00 00 00	 call	 GetBootEncryptionStatus

; 1447 : 		break;

  01ce2	e9 94 03 00 00	 jmp	 $LN160@ProcessMai
$LN28@ProcessMai:

; 1448 : 
; 1449 : 	case TC_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT:
; 1450 : 		Irp->IoStatus.Information = 0;

  01ce7	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01cef	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1451 : 		Irp->IoStatus.Status = GetSetupResult();

  01cf7	e8 00 00 00 00	 call	 GetSetupResult
  01cfc	8b d0		 mov	 edx, eax
  01cfe	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01d06	89 50 30	 mov	 DWORD PTR [rax+48], edx

; 1452 : 		break;

  01d09	e9 6d 03 00 00	 jmp	 $LN160@ProcessMai
$LN27@ProcessMai:

; 1453 : 
; 1454 : 	case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:
; 1455 : 		GetBootDriveVolumeProperties (Irp, irpSp);

  01d0e	48 8b 54 24 68	 mov	 rdx, QWORD PTR irpSp$[rsp]
  01d13	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01d1b	e8 00 00 00 00	 call	 GetBootDriveVolumeProperties

; 1456 : 		break;

  01d20	e9 56 03 00 00	 jmp	 $LN160@ProcessMai
$LN26@ProcessMai:

; 1457 : 
; 1458 : 	case TC_IOCTL_GET_BOOT_LOADER_VERSION:
; 1459 : 		GetBootLoaderVersion (Irp, irpSp);

  01d25	48 8b 54 24 68	 mov	 rdx, QWORD PTR irpSp$[rsp]
  01d2a	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01d32	e8 00 00 00 00	 call	 GetBootLoaderVersion

; 1460 : 		break;

  01d37	e9 3f 03 00 00	 jmp	 $LN160@ProcessMai
$LN25@ProcessMai:

; 1461 : 
; 1462 : 	case TC_IOCTL_REOPEN_BOOT_VOLUME_HEADER:
; 1463 : 		ReopenBootVolumeHeader (Irp, irpSp);

  01d3c	48 8b 54 24 68	 mov	 rdx, QWORD PTR irpSp$[rsp]
  01d41	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01d49	e8 00 00 00 00	 call	 ReopenBootVolumeHeader

; 1464 : 		break;

  01d4e	e9 28 03 00 00	 jmp	 $LN160@ProcessMai
$LN24@ProcessMai:

; 1465 : 
; 1466 : 	case TC_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME:
; 1467 : 		GetBootEncryptionAlgorithmName (Irp, irpSp);

  01d53	48 8b 54 24 68	 mov	 rdx, QWORD PTR irpSp$[rsp]
  01d58	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01d60	e8 00 00 00 00	 call	 GetBootEncryptionAlgorithmName

; 1468 : 		break;

  01d65	e9 11 03 00 00	 jmp	 $LN160@ProcessMai
$LN23@ProcessMai:

; 1469 : 
; 1470 : 	case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:
; 1471 : 		if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))

  01d6a	41 b8 01 00 00
	00		 mov	 r8d, 1
  01d70	ba 04 00 00 00	 mov	 edx, 4
  01d75	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01d7d	e8 00 00 00 00	 call	 ValidateIOBufferSize
  01d82	85 c0		 test	 eax, eax
  01d84	74 55		 je	 SHORT $LN22@ProcessMai

; 1472 : 		{
; 1473 : 			*(int *) Irp->AssociatedIrp.SystemBuffer = IsHiddenSystemRunning() ? 1 : 0;

  01d86	e8 00 00 00 00	 call	 IsHiddenSystemRunning
  01d8b	85 c0		 test	 eax, eax
  01d8d	74 0d		 je	 SHORT $LN178@ProcessMai
  01d8f	c7 84 24 80 05
	00 00 01 00 00
	00		 mov	 DWORD PTR tv912[rsp], 1
  01d9a	eb 0b		 jmp	 SHORT $LN179@ProcessMai
$LN178@ProcessMai:
  01d9c	c7 84 24 80 05
	00 00 00 00 00
	00		 mov	 DWORD PTR tv912[rsp], 0
$LN179@ProcessMai:
  01da7	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01daf	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  01db3	8b 84 24 80 05
	00 00		 mov	 eax, DWORD PTR tv912[rsp]
  01dba	89 01		 mov	 DWORD PTR [rcx], eax

; 1474 : 			Irp->IoStatus.Information = sizeof (int);

  01dbc	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01dc4	48 c7 40 38 04
	00 00 00	 mov	 QWORD PTR [rax+56], 4

; 1475 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  01dcc	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01dd4	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0
$LN22@ProcessMai:

; 1476 : 		}
; 1477 : 		break;

  01ddb	e9 9b 02 00 00	 jmp	 $LN160@ProcessMai
$LN21@ProcessMai:

; 1478 : 
; 1479 : 	case TC_IOCTL_START_DECOY_SYSTEM_WIPE:
; 1480 : 		Irp->IoStatus.Status = StartDecoySystemWipe (DeviceObject, Irp, irpSp);

  01de0	4c 8b 44 24 68	 mov	 r8, QWORD PTR irpSp$[rsp]
  01de5	48 8b 94 24 c0
	05 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  01ded	48 8b 8c 24 b0
	05 00 00	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  01df5	e8 00 00 00 00	 call	 StartDecoySystemWipe
  01dfa	8b d0		 mov	 edx, eax
  01dfc	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01e04	89 50 30	 mov	 DWORD PTR [rax+48], edx

; 1481 : 		Irp->IoStatus.Information = 0;

  01e07	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01e0f	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1482 : 		break;

  01e17	e9 5f 02 00 00	 jmp	 $LN160@ProcessMai
$LN20@ProcessMai:

; 1483 : 
; 1484 : 	case TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE:
; 1485 : 		Irp->IoStatus.Status = AbortDecoySystemWipe();

  01e1c	e8 00 00 00 00	 call	 AbortDecoySystemWipe
  01e21	8b d0		 mov	 edx, eax
  01e23	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01e2b	89 50 30	 mov	 DWORD PTR [rax+48], edx

; 1486 : 		Irp->IoStatus.Information = 0;

  01e2e	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01e36	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1487 : 		break;

  01e3e	e9 38 02 00 00	 jmp	 $LN160@ProcessMai
$LN19@ProcessMai:

; 1488 : 
; 1489 : 	case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT:
; 1490 : 		Irp->IoStatus.Status = GetDecoySystemWipeResult();

  01e43	e8 00 00 00 00	 call	 GetDecoySystemWipeResult
  01e48	8b d0		 mov	 edx, eax
  01e4a	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01e52	89 50 30	 mov	 DWORD PTR [rax+48], edx

; 1491 : 		Irp->IoStatus.Information = 0;

  01e55	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01e5d	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1492 : 		break;

  01e65	e9 11 02 00 00	 jmp	 $LN160@ProcessMai
$LN18@ProcessMai:

; 1493 : 
; 1494 : 	case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS:
; 1495 : 		GetDecoySystemWipeStatus (Irp, irpSp);

  01e6a	48 8b 54 24 68	 mov	 rdx, QWORD PTR irpSp$[rsp]
  01e6f	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01e77	e8 00 00 00 00	 call	 GetDecoySystemWipeStatus

; 1496 : 		break;

  01e7c	e9 fa 01 00 00	 jmp	 $LN160@ProcessMai
$LN17@ProcessMai:

; 1497 : 
; 1498 : 	case TC_IOCTL_WRITE_BOOT_DRIVE_SECTOR:
; 1499 : 		Irp->IoStatus.Status = WriteBootDriveSector (Irp, irpSp);

  01e81	48 8b 54 24 68	 mov	 rdx, QWORD PTR irpSp$[rsp]
  01e86	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01e8e	e8 00 00 00 00	 call	 WriteBootDriveSector
  01e93	8b d0		 mov	 edx, eax
  01e95	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01e9d	89 50 30	 mov	 DWORD PTR [rax+48], edx

; 1500 : 		Irp->IoStatus.Information = 0;

  01ea0	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01ea8	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1501 : 		break;

  01eb0	e9 c6 01 00 00	 jmp	 $LN160@ProcessMai
$LN16@ProcessMai:

; 1502 : 
; 1503 : 	case TC_IOCTL_GET_WARNING_FLAGS:
; 1504 : 		if (ValidateIOBufferSize (Irp, sizeof (GetWarningFlagsRequest), ValidateOutput))

  01eb5	41 b8 01 00 00
	00		 mov	 r8d, 1
  01ebb	ba 08 00 00 00	 mov	 edx, 8
  01ec0	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01ec8	e8 00 00 00 00	 call	 ValidateIOBufferSize
  01ecd	85 c0		 test	 eax, eax
  01ecf	74 68		 je	 SHORT $LN15@ProcessMai

; 1505 : 		{
; 1506 : 			GetWarningFlagsRequest *flags = (GetWarningFlagsRequest *) Irp->AssociatedIrp.SystemBuffer;

  01ed1	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01ed9	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  01edd	48 89 84 24 08
	05 00 00	 mov	 QWORD PTR flags$32119[rsp], rax

; 1507 : 
; 1508 : 			flags->PagingFileCreationPrevented = PagingFileCreationPrevented;

  01ee5	48 8b 8c 24 08
	05 00 00	 mov	 rcx, QWORD PTR flags$32119[rsp]
  01eed	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR PagingFileCreationPrevented
  01ef3	89 01		 mov	 DWORD PTR [rcx], eax

; 1509 : 			PagingFileCreationPrevented = FALSE;

  01ef5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR PagingFileCreationPrevented, 0

; 1510 : 			flags->SystemFavoriteVolumeDirty = SystemFavoriteVolumeDirty;

  01eff	48 8b 8c 24 08
	05 00 00	 mov	 rcx, QWORD PTR flags$32119[rsp]
  01f07	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR SystemFavoriteVolumeDirty
  01f0d	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 1511 : 			SystemFavoriteVolumeDirty = FALSE;

  01f10	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR SystemFavoriteVolumeDirty, 0

; 1512 : 
; 1513 : 			Irp->IoStatus.Information = sizeof (GetWarningFlagsRequest);

  01f1a	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01f22	48 c7 40 38 08
	00 00 00	 mov	 QWORD PTR [rax+56], 8

; 1514 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  01f2a	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01f32	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0
$LN15@ProcessMai:

; 1515 : 		}
; 1516 : 		break;

  01f39	e9 3d 01 00 00	 jmp	 $LN160@ProcessMai
$LN14@ProcessMai:

; 1517 : 
; 1518 : 	case TC_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY:
; 1519 : 		if (UserCanAccessDriveDevice())

  01f3e	e8 00 00 00 00	 call	 UserCanAccessDriveDevice
  01f43	85 c0		 test	 eax, eax
  01f45	74 1b		 je	 SHORT $LN13@ProcessMai

; 1520 : 		{
; 1521 : 			SystemFavoriteVolumeDirty = TRUE;

  01f47	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR SystemFavoriteVolumeDirty, 1

; 1522 : 			Irp->IoStatus.Status = STATUS_SUCCESS;

  01f51	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01f59	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 1523 : 		}
; 1524 : 		else

  01f60	eb 0f		 jmp	 SHORT $LN12@ProcessMai
$LN13@ProcessMai:

; 1525 : 			Irp->IoStatus.Status = STATUS_ACCESS_DENIED;

  01f62	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01f6a	c7 40 30 22 00
	00 c0		 mov	 DWORD PTR [rax+48], -1073741790 ; ffffffffc0000022H
$LN12@ProcessMai:

; 1526 : 
; 1527 : 		Irp->IoStatus.Information = 0;

  01f71	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01f79	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1528 : 		break;

  01f81	e9 f5 00 00 00	 jmp	 $LN160@ProcessMai
$LN11@ProcessMai:

; 1529 : 
; 1530 : 	case TC_IOCTL_REREAD_DRIVER_CONFIG:
; 1531 : 		Irp->IoStatus.Status = ReadRegistryConfigFlags (FALSE);

  01f86	33 c9		 xor	 ecx, ecx
  01f88	e8 00 00 00 00	 call	 ReadRegistryConfigFlags
  01f8d	8b d0		 mov	 edx, eax
  01f8f	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01f97	89 50 30	 mov	 DWORD PTR [rax+48], edx

; 1532 : 		Irp->IoStatus.Information = 0;

  01f9a	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01fa2	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1533 : 		break;

  01faa	e9 cc 00 00 00	 jmp	 $LN160@ProcessMai
$LN10@ProcessMai:

; 1534 : 
; 1535 : 	case TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG:
; 1536 : 		if (ValidateIOBufferSize (Irp, sizeof (GetSystemDriveDumpConfigRequest), ValidateOutput))

  01faf	41 b8 01 00 00
	00		 mov	 r8d, 1
  01fb5	ba 0c 00 00 00	 mov	 edx, 12
  01fba	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  01fc2	e8 00 00 00 00	 call	 ValidateIOBufferSize
  01fc7	85 c0		 test	 eax, eax
  01fc9	0f 84 90 00 00
	00		 je	 $LN9@ProcessMai

; 1537 : 		{
; 1538 : 			GetSystemDriveDumpConfigRequest *request = (GetSystemDriveDumpConfigRequest *) Irp->AssociatedIrp.SystemBuffer;

  01fcf	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  01fd7	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  01fdb	48 89 84 24 10
	05 00 00	 mov	 QWORD PTR request$32132[rsp], rax

; 1539 : 
; 1540 : 			request->BootDriveFilterExtension = GetBootDriveFilterExtension();

  01fe3	e8 00 00 00 00	 call	 GetBootDriveFilterExtension
  01fe8	48 8b d0	 mov	 rdx, rax
  01feb	48 8b 84 24 10
	05 00 00	 mov	 rax, QWORD PTR request$32132[rsp]
  01ff3	48 89 10	 mov	 QWORD PTR [rax], rdx

; 1541 : 			if (IsBootDriveMounted() && request->BootDriveFilterExtension)

  01ff6	e8 00 00 00 00	 call	 IsBootDriveMounted
  01ffb	85 c0		 test	 eax, eax
  01ffd	74 41		 je	 SHORT $LN8@ProcessMai
  01fff	48 8b 84 24 10
	05 00 00	 mov	 rax, QWORD PTR request$32132[rsp]
  02007	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0200b	74 33		 je	 SHORT $LN8@ProcessMai

; 1542 : 			{
; 1543 : 				request->HwEncryptionEnabled = IsHwEncryptionEnabled();

  0200d	e8 00 00 00 00	 call	 IsHwEncryptionEnabled
  02012	8b d0		 mov	 edx, eax
  02014	48 8b 84 24 10
	05 00 00	 mov	 rax, QWORD PTR request$32132[rsp]
  0201c	89 50 08	 mov	 DWORD PTR [rax+8], edx

; 1544 : 				Irp->IoStatus.Status = STATUS_SUCCESS;

  0201f	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  02027	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 1545 : 				Irp->IoStatus.Information = sizeof (*request);

  0202e	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  02036	48 c7 40 38 0c
	00 00 00	 mov	 QWORD PTR [rax+56], 12

; 1546 : 			}
; 1547 : 			else

  0203e	eb 1f		 jmp	 SHORT $LN7@ProcessMai
$LN8@ProcessMai:

; 1548 : 			{
; 1549 : 				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  02040	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  02048	c7 40 30 0d 00
	00 c0		 mov	 DWORD PTR [rax+48], -1073741811 ; ffffffffc000000dH

; 1550 : 				Irp->IoStatus.Information = 0;

  0204f	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  02057	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0
$LN7@ProcessMai:
$LN9@ProcessMai:

; 1551 : 			}
; 1552 : 		}
; 1553 : 		break;

  0205f	eb 1a		 jmp	 SHORT $LN160@ProcessMai
$LN6@ProcessMai:

; 1554 : 
; 1555 : 	default:
; 1556 : 		return TCCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);

  02061	45 33 c0	 xor	 r8d, r8d
  02064	ba 10 00 00 c0	 mov	 edx, -1073741808	; ffffffffc0000010H
  02069	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  02071	e8 00 00 00 00	 call	 TCCompleteIrp
  02076	e9 99 00 00 00	 jmp	 $LN162@ProcessMai
$LN160@ProcessMai:

; 1557 : 	}
; 1558 : 
; 1559 : 	
; 1560 : #ifdef DEBUG
; 1561 : 	if (!NT_SUCCESS (Irp->IoStatus.Status))

  0207b	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  02083	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  02087	7d 67		 jge	 SHORT $LN5@ProcessMai

; 1562 : 	{
; 1563 : 		switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  02089	48 8b 44 24 68	 mov	 rax, QWORD PTR irpSp$[rsp]
  0208e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  02091	89 84 24 84 05
	00 00		 mov	 DWORD PTR tv982[rsp], eax
  02098	8b 84 24 84 05
	00 00		 mov	 eax, DWORD PTR tv982[rsp]
  0209f	2d 18 20 22 00	 sub	 eax, 2236440		; 00222018H
  020a4	89 84 24 84 05
	00 00		 mov	 DWORD PTR tv982[rsp], eax
  020ab	83 bc 24 84 05
	00 00 54	 cmp	 DWORD PTR tv982[rsp], 84 ; 00000054H
  020b3	77 24		 ja	 SHORT $LN1@ProcessMai
  020b5	8b 84 24 84 05
	00 00		 mov	 eax, DWORD PTR tv982[rsp]
  020bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  020c3	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN181@ProcessMai[rcx+rax]
  020cb	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN182@ProcessMai[rcx+rax*4]
  020d2	48 03 c1	 add	 rax, rcx
  020d5	ff e0		 jmp	 rax
$LN2@ProcessMai:

; 1564 : 		{
; 1565 : 		case TC_IOCTL_GET_MOUNTED_VOLUMES:
; 1566 : 		case TC_IOCTL_GET_PASSWORD_CACHE_STATUS:
; 1567 : 		case TC_IOCTL_GET_PORTABLE_MODE_STATUS:
; 1568 : 		case TC_IOCTL_SET_PORTABLE_MODE_STATUS:
; 1569 : 		case TC_IOCTL_OPEN_TEST:
; 1570 : 		case TC_IOCTL_GET_RESOLVED_SYMLINK:
; 1571 : 		case TC_IOCTL_GET_DRIVE_PARTITION_INFO:
; 1572 : 		case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:
; 1573 : 		case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS:
; 1574 : 		case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:
; 1575 : 			break;

  020d7	eb 17		 jmp	 SHORT $LN3@ProcessMai
$LN1@ProcessMai:

; 1576 : 
; 1577 : 		default:
; 1578 : 			Dump ("IOCTL error 0x%08x\n", Irp->IoStatus.Status);

  020d9	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  020e1	8b 50 30	 mov	 edx, DWORD PTR [rax+48]
  020e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@MLCKFMJI@IOCTL?5error?50x?$CF08x?6?$AA@FNODOBFM@
  020eb	e8 00 00 00 00	 call	 DbgPrint
$LN3@ProcessMai:
$LN5@ProcessMai:

; 1579 : 		}
; 1580 : 	}
; 1581 : #endif
; 1582 : 
; 1583 : 	return TCCompleteIrp (Irp, Irp->IoStatus.Status, Irp->IoStatus.Information);

  020f0	4c 8b 84 24 c0
	05 00 00	 mov	 r8, QWORD PTR Irp$[rsp]
  020f8	4d 8b 40 38	 mov	 r8, QWORD PTR [r8+56]
  020fc	48 8b 84 24 c0
	05 00 00	 mov	 rax, QWORD PTR Irp$[rsp]
  02104	8b 50 30	 mov	 edx, DWORD PTR [rax+48]
  02107	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  0210f	e8 00 00 00 00	 call	 TCCompleteIrp
$LN162@ProcessMai:

; 1584 : }

  02114	48 8b 8c 24 88
	05 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0211c	48 33 cc	 xor	 rcx, rsp
  0211f	e8 00 00 00 00	 call	 __security_check_cookie
  02124	48 81 c4 98 05
	00 00		 add	 rsp, 1432		; 00000598H
  0212b	5f		 pop	 rdi
  0212c	5e		 pop	 rsi
  0212d	c3		 ret	 0
  0212e	66 90		 npad	 2
$LN184@ProcessMai:
  02130	00 00 00 00	 DD	 $LN26@ProcessMai
  02134	00 00 00 00	 DD	 $LN51@ProcessMai
  02138	00 00 00 00	 DD	 $LN37@ProcessMai
  0213c	00 00 00 00	 DD	 $LN33@ProcessMai
  02140	00 00 00 00	 DD	 $LN92@ProcessMai
  02144	00 00 00 00	 DD	 $LN77@ProcessMai
  02148	00 00 00 00	 DD	 $LN157@ProcessMai
  0214c	00 00 00 00	 DD	 $LN155@ProcessMai
  02150	00 00 00 00	 DD	 $LN152@ProcessMai
  02154	00 00 00 00	 DD	 $LN97@ProcessMai
  02158	00 00 00 00	 DD	 $LN98@ProcessMai
  0215c	00 00 00 00	 DD	 $LN145@ProcessMai
  02160	00 00 00 00	 DD	 $LN69@ProcessMai
  02164	00 00 00 00	 DD	 $LN60@ProcessMai
  02168	00 00 00 00	 DD	 $LN58@ProcessMai
  0216c	00 00 00 00	 DD	 $LN71@ProcessMai
  02170	00 00 00 00	 DD	 $LN29@ProcessMai
  02174	00 00 00 00	 DD	 $LN31@ProcessMai
  02178	00 00 00 00	 DD	 $LN30@ProcessMai
  0217c	00 00 00 00	 DD	 $LN28@ProcessMai
  02180	00 00 00 00	 DD	 $LN27@ProcessMai
  02184	00 00 00 00	 DD	 $LN25@ProcessMai
  02188	00 00 00 00	 DD	 $LN24@ProcessMai
  0218c	00 00 00 00	 DD	 $LN93@ProcessMai
  02190	00 00 00 00	 DD	 $LN96@ProcessMai
  02194	00 00 00 00	 DD	 $LN23@ProcessMai
  02198	00 00 00 00	 DD	 $LN120@ProcessMai
  0219c	00 00 00 00	 DD	 $LN21@ProcessMai
  021a0	00 00 00 00	 DD	 $LN20@ProcessMai
  021a4	00 00 00 00	 DD	 $LN18@ProcessMai
  021a8	00 00 00 00	 DD	 $LN19@ProcessMai
  021ac	00 00 00 00	 DD	 $LN17@ProcessMai
  021b0	00 00 00 00	 DD	 $LN16@ProcessMai
  021b4	00 00 00 00	 DD	 $LN14@ProcessMai
  021b8	00 00 00 00	 DD	 $LN11@ProcessMai
  021bc	00 00 00 00	 DD	 $LN10@ProcessMai
  021c0	00 00 00 00	 DD	 $LN6@ProcessMai
$LN183@ProcessMai:
  021c4	00		 DB	 0
  021c5	24		 DB	 36			; 00000024H
  021c6	24		 DB	 36			; 00000024H
  021c7	24		 DB	 36			; 00000024H
  021c8	01		 DB	 1
  021c9	24		 DB	 36			; 00000024H
  021ca	24		 DB	 36			; 00000024H
  021cb	24		 DB	 36			; 00000024H
  021cc	02		 DB	 2
  021cd	24		 DB	 36			; 00000024H
  021ce	24		 DB	 36			; 00000024H
  021cf	24		 DB	 36			; 00000024H
  021d0	03		 DB	 3
  021d1	24		 DB	 36			; 00000024H
  021d2	24		 DB	 36			; 00000024H
  021d3	24		 DB	 36			; 00000024H
  021d4	04		 DB	 4
  021d5	24		 DB	 36			; 00000024H
  021d6	24		 DB	 36			; 00000024H
  021d7	24		 DB	 36			; 00000024H
  021d8	05		 DB	 5
  021d9	24		 DB	 36			; 00000024H
  021da	24		 DB	 36			; 00000024H
  021db	24		 DB	 36			; 00000024H
  021dc	06		 DB	 6
  021dd	24		 DB	 36			; 00000024H
  021de	24		 DB	 36			; 00000024H
  021df	24		 DB	 36			; 00000024H
  021e0	07		 DB	 7
  021e1	24		 DB	 36			; 00000024H
  021e2	24		 DB	 36			; 00000024H
  021e3	24		 DB	 36			; 00000024H
  021e4	08		 DB	 8
  021e5	24		 DB	 36			; 00000024H
  021e6	24		 DB	 36			; 00000024H
  021e7	24		 DB	 36			; 00000024H
  021e8	09		 DB	 9
  021e9	24		 DB	 36			; 00000024H
  021ea	24		 DB	 36			; 00000024H
  021eb	24		 DB	 36			; 00000024H
  021ec	0a		 DB	 10
  021ed	24		 DB	 36			; 00000024H
  021ee	24		 DB	 36			; 00000024H
  021ef	24		 DB	 36			; 00000024H
  021f0	0b		 DB	 11
  021f1	24		 DB	 36			; 00000024H
  021f2	24		 DB	 36			; 00000024H
  021f3	24		 DB	 36			; 00000024H
  021f4	0c		 DB	 12
  021f5	24		 DB	 36			; 00000024H
  021f6	24		 DB	 36			; 00000024H
  021f7	24		 DB	 36			; 00000024H
  021f8	0d		 DB	 13
  021f9	24		 DB	 36			; 00000024H
  021fa	24		 DB	 36			; 00000024H
  021fb	24		 DB	 36			; 00000024H
  021fc	0e		 DB	 14
  021fd	24		 DB	 36			; 00000024H
  021fe	24		 DB	 36			; 00000024H
  021ff	24		 DB	 36			; 00000024H
  02200	0f		 DB	 15
  02201	24		 DB	 36			; 00000024H
  02202	24		 DB	 36			; 00000024H
  02203	24		 DB	 36			; 00000024H
  02204	10		 DB	 16
  02205	24		 DB	 36			; 00000024H
  02206	24		 DB	 36			; 00000024H
  02207	24		 DB	 36			; 00000024H
  02208	11		 DB	 17
  02209	24		 DB	 36			; 00000024H
  0220a	24		 DB	 36			; 00000024H
  0220b	24		 DB	 36			; 00000024H
  0220c	12		 DB	 18
  0220d	24		 DB	 36			; 00000024H
  0220e	24		 DB	 36			; 00000024H
  0220f	24		 DB	 36			; 00000024H
  02210	13		 DB	 19
  02211	24		 DB	 36			; 00000024H
  02212	24		 DB	 36			; 00000024H
  02213	24		 DB	 36			; 00000024H
  02214	14		 DB	 20
  02215	24		 DB	 36			; 00000024H
  02216	24		 DB	 36			; 00000024H
  02217	24		 DB	 36			; 00000024H
  02218	15		 DB	 21
  02219	24		 DB	 36			; 00000024H
  0221a	24		 DB	 36			; 00000024H
  0221b	24		 DB	 36			; 00000024H
  0221c	16		 DB	 22
  0221d	24		 DB	 36			; 00000024H
  0221e	24		 DB	 36			; 00000024H
  0221f	24		 DB	 36			; 00000024H
  02220	17		 DB	 23
  02221	24		 DB	 36			; 00000024H
  02222	24		 DB	 36			; 00000024H
  02223	24		 DB	 36			; 00000024H
  02224	18		 DB	 24
  02225	24		 DB	 36			; 00000024H
  02226	24		 DB	 36			; 00000024H
  02227	24		 DB	 36			; 00000024H
  02228	19		 DB	 25
  02229	24		 DB	 36			; 00000024H
  0222a	24		 DB	 36			; 00000024H
  0222b	24		 DB	 36			; 00000024H
  0222c	1a		 DB	 26
  0222d	24		 DB	 36			; 00000024H
  0222e	24		 DB	 36			; 00000024H
  0222f	24		 DB	 36			; 00000024H
  02230	24		 DB	 36			; 00000024H
  02231	24		 DB	 36			; 00000024H
  02232	24		 DB	 36			; 00000024H
  02233	24		 DB	 36			; 00000024H
  02234	1b		 DB	 27
  02235	24		 DB	 36			; 00000024H
  02236	24		 DB	 36			; 00000024H
  02237	24		 DB	 36			; 00000024H
  02238	1c		 DB	 28
  02239	24		 DB	 36			; 00000024H
  0223a	24		 DB	 36			; 00000024H
  0223b	24		 DB	 36			; 00000024H
  0223c	1d		 DB	 29
  0223d	24		 DB	 36			; 00000024H
  0223e	24		 DB	 36			; 00000024H
  0223f	24		 DB	 36			; 00000024H
  02240	1e		 DB	 30
  02241	24		 DB	 36			; 00000024H
  02242	24		 DB	 36			; 00000024H
  02243	24		 DB	 36			; 00000024H
  02244	1f		 DB	 31
  02245	24		 DB	 36			; 00000024H
  02246	24		 DB	 36			; 00000024H
  02247	24		 DB	 36			; 00000024H
  02248	20		 DB	 32			; 00000020H
  02249	24		 DB	 36			; 00000024H
  0224a	24		 DB	 36			; 00000024H
  0224b	24		 DB	 36			; 00000024H
  0224c	21		 DB	 33			; 00000021H
  0224d	24		 DB	 36			; 00000024H
  0224e	24		 DB	 36			; 00000024H
  0224f	24		 DB	 36			; 00000024H
  02250	22		 DB	 34			; 00000022H
  02251	24		 DB	 36			; 00000024H
  02252	24		 DB	 36			; 00000024H
  02253	24		 DB	 36			; 00000024H
  02254	23		 DB	 35			; 00000023H
  02255	0f 1f 00	 npad	 3
$LN182@ProcessMai:
  02258	00 00 00 00	 DD	 $LN2@ProcessMai
  0225c	00 00 00 00	 DD	 $LN1@ProcessMai
$LN181@ProcessMai:
  02260	00		 DB	 0
  02261	01		 DB	 1
  02262	01		 DB	 1
  02263	01		 DB	 1
  02264	01		 DB	 1
  02265	01		 DB	 1
  02266	01		 DB	 1
  02267	01		 DB	 1
  02268	01		 DB	 1
  02269	01		 DB	 1
  0226a	01		 DB	 1
  0226b	01		 DB	 1
  0226c	01		 DB	 1
  0226d	01		 DB	 1
  0226e	01		 DB	 1
  0226f	01		 DB	 1
  02270	01		 DB	 1
  02271	01		 DB	 1
  02272	01		 DB	 1
  02273	01		 DB	 1
  02274	00		 DB	 0
  02275	01		 DB	 1
  02276	01		 DB	 1
  02277	01		 DB	 1
  02278	01		 DB	 1
  02279	01		 DB	 1
  0227a	01		 DB	 1
  0227b	01		 DB	 1
  0227c	00		 DB	 0
  0227d	01		 DB	 1
  0227e	01		 DB	 1
  0227f	01		 DB	 1
  02280	00		 DB	 0
  02281	01		 DB	 1
  02282	01		 DB	 1
  02283	01		 DB	 1
  02284	01		 DB	 1
  02285	01		 DB	 1
  02286	01		 DB	 1
  02287	01		 DB	 1
  02288	01		 DB	 1
  02289	01		 DB	 1
  0228a	01		 DB	 1
  0228b	01		 DB	 1
  0228c	00		 DB	 0
  0228d	01		 DB	 1
  0228e	01		 DB	 1
  0228f	01		 DB	 1
  02290	00		 DB	 0
  02291	01		 DB	 1
  02292	01		 DB	 1
  02293	01		 DB	 1
  02294	01		 DB	 1
  02295	01		 DB	 1
  02296	01		 DB	 1
  02297	01		 DB	 1
  02298	01		 DB	 1
  02299	01		 DB	 1
  0229a	01		 DB	 1
  0229b	01		 DB	 1
  0229c	01		 DB	 1
  0229d	01		 DB	 1
  0229e	01		 DB	 1
  0229f	01		 DB	 1
  022a0	00		 DB	 0
  022a1	01		 DB	 1
  022a2	01		 DB	 1
  022a3	01		 DB	 1
  022a4	01		 DB	 1
  022a5	01		 DB	 1
  022a6	01		 DB	 1
  022a7	01		 DB	 1
  022a8	01		 DB	 1
  022a9	01		 DB	 1
  022aa	01		 DB	 1
  022ab	01		 DB	 1
  022ac	00		 DB	 0
  022ad	01		 DB	 1
  022ae	01		 DB	 1
  022af	01		 DB	 1
  022b0	00		 DB	 0
  022b1	01		 DB	 1
  022b2	01		 DB	 1
  022b3	01		 DB	 1
  022b4	00		 DB	 0
ProcessMainDeviceControlIrp ENDP
PUBLIC	TCDispatchQueueIRP
;	COMDAT pdata
pdata	SEGMENT
$pdata$TCDispatchQueueIRP DD imagerel $LN43
	DD	imagerel $LN43+1516
	DD	imagerel $unwind$TCDispatchQueueIRP
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TCDispatchQueueIRP DD 031001H
	DD	0700cc210H
	DD	0300bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT TCDispatchQueueIRP
_TEXT	SEGMENT
Extension$ = 48
ntStatus$ = 56
irpSp$ = 64
status$31528 = 72
tv73 = 76
tv135 = 80
tv210 = 84
DeviceObject$ = 128
Irp$ = 136
TCDispatchQueueIRP PROC					; COMDAT

; 202  : {

$LN43:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	53		 push	 rbx
  0000b	57		 push	 rdi
  0000c	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 203  : 	PEXTENSION Extension = (PEXTENSION) DeviceObject->DeviceExtension;

  00010	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  00018	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0001c	48 89 44 24 30	 mov	 QWORD PTR Extension$[rsp], rax

; 204  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);

  00021	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00029	e8 00 00 00 00	 call	 IoGetCurrentIrpStackLocation
  0002e	48 89 44 24 40	 mov	 QWORD PTR irpSp$[rsp], rax

; 205  : 	NTSTATUS ntStatus;
; 206  : 
; 207  : #ifdef _DEBUG
; 208  : 	if (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL && (Extension->bRootDevice || Extension->IsVolumeDevice))

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR irpSp$[rsp]
  00038	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003b	83 f8 0e	 cmp	 eax, 14
  0003e	0f 85 b8 00 00
	00		 jne	 $LN35@TCDispatch
  00044	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  00049	83 38 00	 cmp	 DWORD PTR [rax], 0
  0004c	75 0f		 jne	 SHORT $LN34@TCDispatch
  0004e	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  00053	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00057	0f 84 9f 00 00
	00		 je	 $LN35@TCDispatch
$LN34@TCDispatch:

; 209  : 	{
; 210  : 		switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  0005d	48 8b 44 24 40	 mov	 rax, QWORD PTR irpSp$[rsp]
  00062	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00065	89 44 24 4c	 mov	 DWORD PTR tv73[rsp], eax
  00069	81 7c 24 4c 18
	20 22 00	 cmp	 DWORD PTR tv73[rsp], 2236440 ; 00222018H
  00071	77 16		 ja	 SHORT $LN38@TCDispatch
  00073	81 7c 24 4c 18
	20 22 00	 cmp	 DWORD PTR tv73[rsp], 2236440 ; 00222018H
  0007b	74 3f		 je	 SHORT $LN31@TCDispatch
  0007d	81 7c 24 4c 00
	48 07 00	 cmp	 DWORD PTR tv73[rsp], 477184 ; 00074800H
  00085	74 35		 je	 SHORT $LN31@TCDispatch
  00087	eb 35		 jmp	 SHORT $LN30@TCDispatch
$LN38@TCDispatch:
  00089	8b 44 24 4c	 mov	 eax, DWORD PTR tv73[rsp]
  0008d	2d 20 20 22 00	 sub	 eax, 2236448		; 00222020H
  00092	89 44 24 4c	 mov	 DWORD PTR tv73[rsp], eax
  00096	83 7c 24 4c 6c	 cmp	 DWORD PTR tv73[rsp], 108 ; 0000006cH
  0009b	77 21		 ja	 SHORT $LN30@TCDispatch
  0009d	8b 44 24 4c	 mov	 eax, DWORD PTR tv73[rsp]
  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000a8	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN41@TCDispatch[rcx+rax]
  000b0	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN42@TCDispatch[rcx+rax*4]
  000b7	48 03 c1	 add	 rax, rcx
  000ba	ff e0		 jmp	 rax
$LN31@TCDispatch:

; 211  : 		{
; 212  : 		case TC_IOCTL_GET_MOUNTED_VOLUMES:
; 213  : 		case TC_IOCTL_GET_PASSWORD_CACHE_STATUS:
; 214  : 		case TC_IOCTL_GET_PORTABLE_MODE_STATUS:
; 215  : 		case TC_IOCTL_SET_PORTABLE_MODE_STATUS:
; 216  : 		case TC_IOCTL_OPEN_TEST:
; 217  : 		case TC_IOCTL_GET_RESOLVED_SYMLINK:
; 218  : 		case TC_IOCTL_GET_DEVICE_REFCOUNT:
; 219  : 		case TC_IOCTL_GET_DRIVE_PARTITION_INFO:
; 220  : 		case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:
; 221  : 		case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS:
; 222  : 		case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS:
; 223  : 		case TC_IOCTL_GET_WARNING_FLAGS:
; 224  : 		case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:
; 225  : 		case IOCTL_DISK_CHECK_VERIFY:
; 226  : 			break;

  000bc	eb 3e		 jmp	 SHORT $LN32@TCDispatch
$LN30@TCDispatch:

; 227  : 
; 228  : 		default:
; 229  : 			Dump ("%ls (0x%x %d)\n",
; 230  : 				TCTranslateCode (irpSp->Parameters.DeviceIoControl.IoControlCode),
; 231  : 				(int) (irpSp->Parameters.DeviceIoControl.IoControlCode >> 16),
; 232  : 				(int) ((irpSp->Parameters.DeviceIoControl.IoControlCode & 0x1FFF) >> 2));

  000be	48 8b 44 24 40	 mov	 rax, QWORD PTR irpSp$[rsp]
  000c3	8b 78 18	 mov	 edi, DWORD PTR [rax+24]
  000c6	81 e7 ff 1f 00
	00		 and	 edi, 8191		; 00001fffH
  000cc	c1 ef 02	 shr	 edi, 2
  000cf	48 8b 44 24 40	 mov	 rax, QWORD PTR irpSp$[rsp]
  000d4	8b 58 18	 mov	 ebx, DWORD PTR [rax+24]
  000d7	c1 eb 10	 shr	 ebx, 16
  000da	48 8b 44 24 40	 mov	 rax, QWORD PTR irpSp$[rsp]
  000df	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  000e2	e8 00 00 00 00	 call	 TCTranslateCode
  000e7	44 8b cf	 mov	 r9d, edi
  000ea	44 8b c3	 mov	 r8d, ebx
  000ed	48 8b d0	 mov	 rdx, rax
  000f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@CMDFIGFB@?$CFls?5?$CI0x?$CFx?5?$CFd?$CJ?6?$AA@FNODOBFM@
  000f7	e8 00 00 00 00	 call	 DbgPrint
$LN32@TCDispatch:
$LN35@TCDispatch:

; 233  : 		}
; 234  : 	}
; 235  : #endif
; 236  : 
; 237  : 	if (!Extension->bRootDevice)

  000fc	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  00101	83 38 00	 cmp	 DWORD PTR [rax], 0
  00104	75 4a		 jne	 SHORT $LN29@TCDispatch

; 238  : 	{
; 239  : 		// Drive filter IRP
; 240  : 		if (Extension->IsDriveFilterDevice)

  00106	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  0010b	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0010f	74 1a		 je	 SHORT $LN28@TCDispatch

; 241  : 			return DriveFilterDispatchIrp (DeviceObject, Irp);

  00111	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  00119	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  00121	e8 00 00 00 00	 call	 DriveFilterDispatchIrp
  00126	e9 10 04 00 00	 jmp	 $LN36@TCDispatch
$LN28@TCDispatch:

; 242  : 
; 243  : 		// Volume filter IRP
; 244  : 		if (Extension->IsVolumeFilterDevice)

  0012b	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  00130	83 78 0c 00	 cmp	 DWORD PTR [rax+12], 0
  00134	74 1a		 je	 SHORT $LN27@TCDispatch

; 245  : 			return VolumeFilterDispatchIrp (DeviceObject, Irp);

  00136	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  0013e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  00146	e8 00 00 00 00	 call	 VolumeFilterDispatchIrp
  0014b	e9 eb 03 00 00	 jmp	 $LN36@TCDispatch
$LN27@TCDispatch:
$LN29@TCDispatch:

; 246  : 	}
; 247  : 
; 248  : 	switch (irpSp->MajorFunction)

  00150	48 8b 44 24 40	 mov	 rax, QWORD PTR irpSp$[rsp]
  00155	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00158	89 44 24 50	 mov	 DWORD PTR tv135[rsp], eax
  0015c	83 7c 24 50 1b	 cmp	 DWORD PTR tv135[rsp], 27
  00161	0f 87 bf 03 00
	00		 ja	 $LN25@TCDispatch
  00167	48 63 44 24 50	 movsxd	 rax, DWORD PTR tv135[rsp]
  0016c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00173	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN39@TCDispatch[rcx+rax]
  0017b	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN40@TCDispatch[rcx+rax*4]
  00182	48 03 c1	 add	 rax, rcx
  00185	ff e0		 jmp	 rax
$LN24@TCDispatch:

; 249  : 	{
; 250  : 	case IRP_MJ_CLOSE:
; 251  : 	case IRP_MJ_CREATE:
; 252  : 	case IRP_MJ_CLEANUP:
; 253  : 		return COMPLETE_IRP (DeviceObject, Irp, STATUS_SUCCESS, 0);

  00187	45 33 c9	 xor	 r9d, r9d
  0018a	45 33 c0	 xor	 r8d, r8d
  0018d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  00195	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  0019d	e8 00 00 00 00	 call	 COMPLETE_IRP
  001a2	e9 94 03 00 00	 jmp	 $LN36@TCDispatch
$LN23@TCDispatch:

; 254  : 
; 255  : 	case IRP_MJ_SHUTDOWN:
; 256  : 		if (Extension->bRootDevice)

  001a7	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  001ac	83 38 00	 cmp	 DWORD PTR [rax], 0
  001af	0f 84 91 00 00
	00		 je	 $LN22@TCDispatch

; 257  : 		{
; 258  : 			Dump ("Driver shutting down\n");

  001b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@JHFMBFJC@Driver?5shutting?5down?6?$AA@FNODOBFM@
  001bc	e8 00 00 00 00	 call	 DbgPrint

; 259  : 			DriverShuttingDown = TRUE;

  001c1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR DriverShuttingDown, 1

; 260  : 
; 261  : 			if (EncryptionSetupThread)

  001cb	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR EncryptionSetupThread, 0
  001d3	74 31		 je	 SHORT $LN21@TCDispatch
$LN20@TCDispatch:

; 262  : 				while (SendDeviceIoControlRequest (RootDeviceObject, TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP, NULL, 0, NULL, 0) == STATUS_INSUFFICIENT_RESOURCES);

  001d5	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  001dd	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  001e6	45 33 c9	 xor	 r9d, r9d
  001e9	45 33 c0	 xor	 r8d, r8d
  001ec	ba 50 20 22 00	 mov	 edx, 2236496		; 00222050H
  001f1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR RootDeviceObject
  001f8	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  001fd	3d 9a 00 00 c0	 cmp	 eax, -1073741670	; ffffffffc000009aH
  00202	75 02		 jne	 SHORT $LN19@TCDispatch
  00204	eb cf		 jmp	 SHORT $LN20@TCDispatch
$LN19@TCDispatch:
$LN21@TCDispatch:

; 263  : 
; 264  : 			if (DecoySystemWipeThread)

  00206	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR DecoySystemWipeThread, 0
  0020e	74 31		 je	 SHORT $LN18@TCDispatch
$LN17@TCDispatch:

; 265  : 				while (SendDeviceIoControlRequest (RootDeviceObject, TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE, NULL, 0, NULL, 0) == STATUS_INSUFFICIENT_RESOURCES);

  00210	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00218	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00221	45 33 c9	 xor	 r9d, r9d
  00224	45 33 c0	 xor	 r8d, r8d
  00227	ba 7c 20 22 00	 mov	 edx, 2236540		; 0022207cH
  0022c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR RootDeviceObject
  00233	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  00238	3d 9a 00 00 c0	 cmp	 eax, -1073741670	; ffffffffc000009aH
  0023d	75 02		 jne	 SHORT $LN16@TCDispatch
  0023f	eb cf		 jmp	 SHORT $LN17@TCDispatch
$LN16@TCDispatch:
$LN18@TCDispatch:

; 266  : 
; 267  : 			OnShutdownPending();

  00241	e8 00 00 00 00	 call	 OnShutdownPending
$LN22@TCDispatch:

; 268  : 		}
; 269  : 
; 270  : 		return COMPLETE_IRP (DeviceObject, Irp, STATUS_SUCCESS, 0);

  00246	45 33 c9	 xor	 r9d, r9d
  00249	45 33 c0	 xor	 r8d, r8d
  0024c	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  00254	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  0025c	e8 00 00 00 00	 call	 COMPLETE_IRP
  00261	e9 d5 02 00 00	 jmp	 $LN36@TCDispatch
$LN15@TCDispatch:

; 271  : 
; 272  : 	case IRP_MJ_FLUSH_BUFFERS:
; 273  : 	case IRP_MJ_READ:
; 274  : 	case IRP_MJ_WRITE:
; 275  : 	case IRP_MJ_DEVICE_CONTROL:
; 276  : 
; 277  : 		if (Extension->bRootDevice)

  00266	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  0026b	83 38 00	 cmp	 DWORD PTR [rax], 0
  0026e	74 7a		 je	 SHORT $LN14@TCDispatch

; 278  : 		{
; 279  : 			if (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL)

  00270	48 8b 44 24 40	 mov	 rax, QWORD PTR irpSp$[rsp]
  00275	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00278	83 f8 0e	 cmp	 eax, 14
  0027b	75 68		 jne	 SHORT $LN13@TCDispatch

; 280  : 			{
; 281  : 				NTSTATUS status = KeWaitForMutexObject (&RootDeviceControlMutex, Executive, KernelMode, FALSE, NULL);

  0027d	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00286	45 33 c9	 xor	 r9d, r9d
  00289	45 33 c0	 xor	 r8d, r8d
  0028c	33 d2		 xor	 edx, edx
  0028e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:RootDeviceControlMutex
  00295	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  0029b	89 44 24 48	 mov	 DWORD PTR status$31528[rsp], eax

; 282  : 				if (!NT_SUCCESS (status))

  0029f	83 7c 24 48 00	 cmp	 DWORD PTR status$31528[rsp], 0
  002a4	7d 09		 jge	 SHORT $LN12@TCDispatch

; 283  : 					return status;

  002a6	8b 44 24 48	 mov	 eax, DWORD PTR status$31528[rsp]
  002aa	e9 8c 02 00 00	 jmp	 $LN36@TCDispatch
$LN12@TCDispatch:

; 284  : 
; 285  : 				status = ProcessMainDeviceControlIrp (DeviceObject, Extension, Irp);

  002af	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR Irp$[rsp]
  002b7	48 8b 54 24 30	 mov	 rdx, QWORD PTR Extension$[rsp]
  002bc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  002c4	e8 00 00 00 00	 call	 ProcessMainDeviceControlIrp
  002c9	89 44 24 48	 mov	 DWORD PTR status$31528[rsp], eax

; 286  : 
; 287  : 				KeReleaseMutex (&RootDeviceControlMutex, FALSE);

  002cd	33 d2		 xor	 edx, edx
  002cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:RootDeviceControlMutex
  002d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseMutex

; 288  : 				return status;

  002dc	8b 44 24 48	 mov	 eax, DWORD PTR status$31528[rsp]
  002e0	e9 56 02 00 00	 jmp	 $LN36@TCDispatch
$LN13@TCDispatch:

; 289  : 			}
; 290  : 			break;

  002e5	e9 3c 02 00 00	 jmp	 $LN25@TCDispatch
$LN14@TCDispatch:

; 291  : 		}
; 292  : 
; 293  : 		if (Extension->bShuttingDown)

  002ea	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  002ef	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  002f3	74 2e		 je	 SHORT $LN11@TCDispatch

; 294  : 		{
; 295  : 			Dump ("Device %d shutting down: STATUS_DELETE_PENDING\n", Extension->nDosDriveNo);

  002f5	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  002fa	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  002fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DA@HGPNLENJ@Device?5?$CFd?5shutting?5down?3?5STATUS_@FNODOBFM@
  00304	e8 00 00 00 00	 call	 DbgPrint

; 296  : 			return TCCompleteDiskIrp (Irp, STATUS_DELETE_PENDING, 0);

  00309	45 33 c0	 xor	 r8d, r8d
  0030c	ba 56 00 00 c0	 mov	 edx, -1073741738	; ffffffffc0000056H
  00311	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00319	e8 00 00 00 00	 call	 TCCompleteDiskIrp
  0031e	e9 18 02 00 00	 jmp	 $LN36@TCDispatch
$LN11@TCDispatch:

; 297  : 		}
; 298  : 
; 299  : 		if (Extension->bRemovable
; 300  : 			&& (DeviceObject->Flags & DO_VERIFY_VOLUME)
; 301  : 			&& !(irpSp->Flags & SL_OVERRIDE_VERIFY_VOLUME)
; 302  : 			&& irpSp->MajorFunction != IRP_MJ_FLUSH_BUFFERS)

  00323	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  00328	83 b8 9c 03 00
	00 00		 cmp	 DWORD PTR [rax+924], 0
  0032f	74 5d		 je	 SHORT $LN10@TCDispatch
  00331	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  00339	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0033c	83 e0 02	 and	 eax, 2
  0033f	85 c0		 test	 eax, eax
  00341	74 4b		 je	 SHORT $LN10@TCDispatch
  00343	48 8b 44 24 40	 mov	 rax, QWORD PTR irpSp$[rsp]
  00348	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0034c	83 e0 02	 and	 eax, 2
  0034f	85 c0		 test	 eax, eax
  00351	75 3b		 jne	 SHORT $LN10@TCDispatch
  00353	48 8b 44 24 40	 mov	 rax, QWORD PTR irpSp$[rsp]
  00358	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0035b	83 f8 09	 cmp	 eax, 9
  0035e	74 2e		 je	 SHORT $LN10@TCDispatch

; 303  : 		{
; 304  : 			Dump ("Removable device %d has DO_VERIFY_VOLUME flag: STATUS_DEVICE_NOT_READY\n", Extension->nDosDriveNo);

  00360	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  00365	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  00368	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EI@NJLFEPKD@Removable?5device?5?$CFd?5has?5DO_VERIF@FNODOBFM@
  0036f	e8 00 00 00 00	 call	 DbgPrint

; 305  : 			return TCCompleteDiskIrp (Irp, STATUS_DEVICE_NOT_READY, 0);

  00374	45 33 c0	 xor	 r8d, r8d
  00377	ba a3 00 00 c0	 mov	 edx, -1073741661	; ffffffffc00000a3H
  0037c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00384	e8 00 00 00 00	 call	 TCCompleteDiskIrp
  00389	e9 ad 01 00 00	 jmp	 $LN36@TCDispatch
$LN10@TCDispatch:

; 306  : 		}
; 307  : 
; 308  : 		switch (irpSp->MajorFunction)

  0038e	48 8b 44 24 40	 mov	 rax, QWORD PTR irpSp$[rsp]
  00393	8a 00		 mov	 al, BYTE PTR [rax]
  00395	88 44 24 54	 mov	 BYTE PTR tv210[rsp], al
  00399	80 7c 24 54 03	 cmp	 BYTE PTR tv210[rsp], 3
  0039e	0f 82 24 01 00
	00		 jb	 $LN8@TCDispatch
  003a4	80 7c 24 54 04	 cmp	 BYTE PTR tv210[rsp], 4
  003a9	76 17		 jbe	 SHORT $LN7@TCDispatch
  003ab	80 7c 24 54 09	 cmp	 BYTE PTR tv210[rsp], 9
  003b0	0f 84 fe 00 00
	00		 je	 $LN3@TCDispatch
  003b6	80 7c 24 54 0e	 cmp	 BYTE PTR tv210[rsp], 14
  003bb	74 49		 je	 SHORT $LN5@TCDispatch
  003bd	e9 06 01 00 00	 jmp	 $LN8@TCDispatch
$LN7@TCDispatch:

; 309  : 		{
; 310  : 		case IRP_MJ_READ:
; 311  : 		case IRP_MJ_WRITE:
; 312  : 			ntStatus = EncryptedIoQueueAddIrp (&Extension->Queue, Irp);

  003c2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Extension$[rsp]
  003c7	48 81 c1 e0 00
	00 00		 add	 rcx, 224		; 000000e0H
  003ce	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  003d6	e8 00 00 00 00	 call	 EncryptedIoQueueAddIrp
  003db	89 44 24 38	 mov	 DWORD PTR ntStatus$[rsp], eax

; 313  : 
; 314  : 			if (ntStatus != STATUS_PENDING)

  003df	81 7c 24 38 03
	01 00 00	 cmp	 DWORD PTR ntStatus$[rsp], 259 ; 00000103H
  003e7	74 14		 je	 SHORT $LN6@TCDispatch

; 315  : 				TCCompleteDiskIrp (Irp, ntStatus, 0);

  003e9	45 33 c0	 xor	 r8d, r8d
  003ec	8b 54 24 38	 mov	 edx, DWORD PTR ntStatus$[rsp]
  003f0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  003f8	e8 00 00 00 00	 call	 TCCompleteDiskIrp
$LN6@TCDispatch:

; 316  : 
; 317  : 			return ntStatus;

  003fd	8b 44 24 38	 mov	 eax, DWORD PTR ntStatus$[rsp]
  00401	e9 35 01 00 00	 jmp	 $LN36@TCDispatch
$LN5@TCDispatch:

; 318  : 
; 319  : 		case IRP_MJ_DEVICE_CONTROL:
; 320  : 			ntStatus = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00406	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Extension$[rsp]
  0040b	48 81 c1 80 01
	00 00		 add	 rcx, 384		; 00000180H
  00412	c7 44 24 20 78
	00 00 00	 mov	 DWORD PTR [rsp+32], 120	; 00000078H
  0041a	41 b9 40 01 00
	00		 mov	 r9d, 320		; 00000140H
  00420	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0EC@PIHBGAHH@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  00427	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  0042f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAcquireRemoveLockEx
  00435	89 44 24 38	 mov	 DWORD PTR ntStatus$[rsp], eax

; 321  : 			if (!NT_SUCCESS (ntStatus))

  00439	83 7c 24 38 00	 cmp	 DWORD PTR ntStatus$[rsp], 0
  0043e	7d 19		 jge	 SHORT $LN4@TCDispatch

; 322  : 				return TCCompleteIrp (Irp, ntStatus, 0);

  00440	45 33 c0	 xor	 r8d, r8d
  00443	8b 54 24 38	 mov	 edx, DWORD PTR ntStatus$[rsp]
  00447	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  0044f	e8 00 00 00 00	 call	 TCCompleteIrp
  00454	e9 e2 00 00 00	 jmp	 $LN36@TCDispatch
$LN4@TCDispatch:

; 323  : 
; 324  : 			IoMarkIrpPending (Irp);

  00459	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00461	e8 00 00 00 00	 call	 IoMarkIrpPending

; 325  : 			
; 326  : 			ExInterlockedInsertTailList (&Extension->ListEntry, &Irp->Tail.Overlay.ListEntry, &Extension->ListSpinLock);

  00466	4c 8b 44 24 30	 mov	 r8, QWORD PTR Extension$[rsp]
  0046b	49 83 c0 40	 add	 r8, 64			; 00000040H
  0046f	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR Irp$[rsp]
  00477	48 81 c2 a8 00
	00 00		 add	 rdx, 168		; 000000a8H
  0047e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Extension$[rsp]
  00483	48 83 c1 48	 add	 rcx, 72			; 00000048H
  00487	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExInterlockedInsertTailList

; 327  : 			KeReleaseSemaphore (&Extension->RequestSemaphore, IO_DISK_INCREMENT, 1, FALSE);

  0048d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Extension$[rsp]
  00492	48 83 c1 58	 add	 rcx, 88			; 00000058H
  00496	45 33 c9	 xor	 r9d, r9d
  00499	41 b8 01 00 00
	00		 mov	 r8d, 1
  0049f	ba 01 00 00 00	 mov	 edx, 1
  004a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseSemaphore

; 328  : 			
; 329  : 			return STATUS_PENDING;

  004aa	b8 03 01 00 00	 mov	 eax, 259		; 00000103H
  004af	e9 87 00 00 00	 jmp	 $LN36@TCDispatch
$LN3@TCDispatch:

; 330  : 
; 331  : 		case IRP_MJ_FLUSH_BUFFERS:
; 332  : 			return TCCompleteDiskIrp (Irp, STATUS_SUCCESS, 0);

  004b4	45 33 c0	 xor	 r8d, r8d
  004b7	33 d2		 xor	 edx, edx
  004b9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  004c1	e8 00 00 00 00	 call	 TCCompleteDiskIrp
  004c6	eb 73		 jmp	 SHORT $LN36@TCDispatch
$LN8@TCDispatch:

; 333  : 		}
; 334  : 
; 335  : 		break;

  004c8	eb 5c		 jmp	 SHORT $LN25@TCDispatch
$LN2@TCDispatch:

; 336  : 
; 337  : 	case IRP_MJ_PNP:
; 338  : 		if (!Extension->bRootDevice
; 339  : 			&& Extension->IsVolumeDevice
; 340  : 			&& irpSp->MinorFunction == IRP_MN_DEVICE_USAGE_NOTIFICATION
; 341  : 			&& irpSp->Parameters.UsageNotification.Type == DeviceUsageTypePaging
; 342  : 			&& irpSp->Parameters.UsageNotification.InPath)

  004ca	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  004cf	83 38 00	 cmp	 DWORD PTR [rax], 0
  004d2	75 52		 jne	 SHORT $LN1@TCDispatch
  004d4	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  004d9	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  004dd	74 47		 je	 SHORT $LN1@TCDispatch
  004df	48 8b 44 24 40	 mov	 rax, QWORD PTR irpSp$[rsp]
  004e4	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  004e8	83 f8 16	 cmp	 eax, 22
  004eb	75 39		 jne	 SHORT $LN1@TCDispatch
  004ed	48 8b 44 24 40	 mov	 rax, QWORD PTR irpSp$[rsp]
  004f2	83 78 10 01	 cmp	 DWORD PTR [rax+16], 1
  004f6	75 2e		 jne	 SHORT $LN1@TCDispatch
  004f8	48 8b 44 24 40	 mov	 rax, QWORD PTR irpSp$[rsp]
  004fd	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  00501	85 c0		 test	 eax, eax
  00503	74 21		 je	 SHORT $LN1@TCDispatch

; 343  : 		{
; 344  : 			PagingFileCreationPrevented = TRUE;

  00505	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR PagingFileCreationPrevented, 1

; 345  : 			return TCCompleteIrp (Irp, STATUS_UNSUCCESSFUL, 0);

  0050f	45 33 c0	 xor	 r8d, r8d
  00512	ba 01 00 00 c0	 mov	 edx, -1073741823	; ffffffffc0000001H
  00517	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  0051f	e8 00 00 00 00	 call	 TCCompleteIrp
  00524	eb 15		 jmp	 SHORT $LN36@TCDispatch
$LN1@TCDispatch:
$LN25@TCDispatch:

; 346  : 		}
; 347  : 		break;
; 348  : 	}
; 349  : 
; 350  : 	return TCCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);

  00526	45 33 c0	 xor	 r8d, r8d
  00529	ba 10 00 00 c0	 mov	 edx, -1073741808	; ffffffffc0000010H
  0052e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR Irp$[rsp]
  00536	e8 00 00 00 00	 call	 TCCompleteIrp
$LN36@TCDispatch:

; 351  : }

  0053b	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0053f	5f		 pop	 rdi
  00540	5b		 pop	 rbx
  00541	c3		 ret	 0
  00542	66 90		 npad	 2
$LN42@TCDispatch:
  00544	00 00 00 00	 DD	 $LN31@TCDispatch
  00548	00 00 00 00	 DD	 $LN30@TCDispatch
$LN41@TCDispatch:
  0054c	00		 DB	 0
  0054d	01		 DB	 1
  0054e	01		 DB	 1
  0054f	01		 DB	 1
  00550	01		 DB	 1
  00551	01		 DB	 1
  00552	01		 DB	 1
  00553	01		 DB	 1
  00554	01		 DB	 1
  00555	01		 DB	 1
  00556	01		 DB	 1
  00557	01		 DB	 1
  00558	00		 DB	 0
  00559	01		 DB	 1
  0055a	01		 DB	 1
  0055b	01		 DB	 1
  0055c	01		 DB	 1
  0055d	01		 DB	 1
  0055e	01		 DB	 1
  0055f	01		 DB	 1
  00560	00		 DB	 0
  00561	01		 DB	 1
  00562	01		 DB	 1
  00563	01		 DB	 1
  00564	00		 DB	 0
  00565	01		 DB	 1
  00566	01		 DB	 1
  00567	01		 DB	 1
  00568	01		 DB	 1
  00569	01		 DB	 1
  0056a	01		 DB	 1
  0056b	01		 DB	 1
  0056c	01		 DB	 1
  0056d	01		 DB	 1
  0056e	01		 DB	 1
  0056f	01		 DB	 1
  00570	00		 DB	 0
  00571	01		 DB	 1
  00572	01		 DB	 1
  00573	01		 DB	 1
  00574	00		 DB	 0
  00575	01		 DB	 1
  00576	01		 DB	 1
  00577	01		 DB	 1
  00578	01		 DB	 1
  00579	01		 DB	 1
  0057a	01		 DB	 1
  0057b	01		 DB	 1
  0057c	01		 DB	 1
  0057d	01		 DB	 1
  0057e	01		 DB	 1
  0057f	01		 DB	 1
  00580	01		 DB	 1
  00581	01		 DB	 1
  00582	01		 DB	 1
  00583	01		 DB	 1
  00584	00		 DB	 0
  00585	01		 DB	 1
  00586	01		 DB	 1
  00587	01		 DB	 1
  00588	01		 DB	 1
  00589	01		 DB	 1
  0058a	01		 DB	 1
  0058b	01		 DB	 1
  0058c	01		 DB	 1
  0058d	01		 DB	 1
  0058e	01		 DB	 1
  0058f	01		 DB	 1
  00590	00		 DB	 0
  00591	01		 DB	 1
  00592	01		 DB	 1
  00593	01		 DB	 1
  00594	00		 DB	 0
  00595	01		 DB	 1
  00596	01		 DB	 1
  00597	01		 DB	 1
  00598	00		 DB	 0
  00599	01		 DB	 1
  0059a	01		 DB	 1
  0059b	01		 DB	 1
  0059c	01		 DB	 1
  0059d	01		 DB	 1
  0059e	01		 DB	 1
  0059f	01		 DB	 1
  005a0	01		 DB	 1
  005a1	01		 DB	 1
  005a2	01		 DB	 1
  005a3	01		 DB	 1
  005a4	01		 DB	 1
  005a5	01		 DB	 1
  005a6	01		 DB	 1
  005a7	01		 DB	 1
  005a8	01		 DB	 1
  005a9	01		 DB	 1
  005aa	01		 DB	 1
  005ab	01		 DB	 1
  005ac	00		 DB	 0
  005ad	01		 DB	 1
  005ae	01		 DB	 1
  005af	01		 DB	 1
  005b0	01		 DB	 1
  005b1	01		 DB	 1
  005b2	01		 DB	 1
  005b3	01		 DB	 1
  005b4	01		 DB	 1
  005b5	01		 DB	 1
  005b6	01		 DB	 1
  005b7	01		 DB	 1
  005b8	00		 DB	 0
  005b9	0f 1f 00	 npad	 3
$LN40@TCDispatch:
  005bc	00 00 00 00	 DD	 $LN24@TCDispatch
  005c0	00 00 00 00	 DD	 $LN15@TCDispatch
  005c4	00 00 00 00	 DD	 $LN23@TCDispatch
  005c8	00 00 00 00	 DD	 $LN2@TCDispatch
  005cc	00 00 00 00	 DD	 $LN25@TCDispatch
$LN39@TCDispatch:
  005d0	00		 DB	 0
  005d1	04		 DB	 4
  005d2	00		 DB	 0
  005d3	01		 DB	 1
  005d4	01		 DB	 1
  005d5	04		 DB	 4
  005d6	04		 DB	 4
  005d7	04		 DB	 4
  005d8	04		 DB	 4
  005d9	01		 DB	 1
  005da	04		 DB	 4
  005db	04		 DB	 4
  005dc	04		 DB	 4
  005dd	04		 DB	 4
  005de	01		 DB	 1
  005df	04		 DB	 4
  005e0	02		 DB	 2
  005e1	04		 DB	 4
  005e2	00		 DB	 0
  005e3	04		 DB	 4
  005e4	04		 DB	 4
  005e5	04		 DB	 4
  005e6	04		 DB	 4
  005e7	04		 DB	 4
  005e8	04		 DB	 4
  005e9	04		 DB	 4
  005ea	04		 DB	 4
  005eb	03		 DB	 3
TCDispatchQueueIRP ENDP
_TEXT	ENDS
PUBLIC	DriverEntry
;	COMDAT pdata
pdata	SEGMENT
$pdata$DriverEntry DD imagerel $LN10
	DD	imagerel $LN10+407
	DD	imagerel $unwind$DriverEntry
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DriverEntry DD 020f01H
	DD	0700b920fH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DriverEntry
INIT	SEGMENT
i$ = 48
startKeyValue$ = 56
version$ = 64
DriverObject$ = 96
RegistryPath$ = 104
DriverEntry PROC					; COMDAT

; 63   : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 64   : 	PKEY_VALUE_PARTIAL_INFORMATION startKeyValue;
; 65   : 	LONG version;
; 66   : 	int i;
; 67   : 
; 68   : 	Dump ("DriverEntry " TC_APP_NAME " " VERSION_STRING "\n");

  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@PHLKBPMP@DriverEntry?5CipherShed?50?47?44?41?6?$AA@PBOPGDP@
  00016	e8 00 00 00 00	 call	 DbgPrint

; 69   : 
; 70   : 	PsGetVersion (&OsMajorVersion, &OsMinorVersion, NULL, NULL);

  0001b	45 33 c9	 xor	 r9d, r9d
  0001e	45 33 c0	 xor	 r8d, r8d
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:OsMinorVersion
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:OsMajorVersion
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsGetVersion

; 71   : 
; 72   : 	// Load dump filter if the main driver is already loaded
; 73   : 	if (NT_SUCCESS (TCDeviceIoControl (NT_ROOT_PREFIX, TC_IOCTL_GET_DRIVER_VERSION, NULL, 0, &version, sizeof (version))))

  00035	c7 44 24 28 04
	00 00 00	 mov	 DWORD PTR [rsp+40], 4
  0003d	48 8d 44 24 40	 lea	 rax, QWORD PTR version$[rsp]
  00042	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00047	45 33 c9	 xor	 r9d, r9d
  0004a	45 33 c0	 xor	 r8d, r8d
  0004d	ba 04 20 22 00	 mov	 edx, 2236420		; 00222004H
  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@PBOPGDP@
  00059	e8 00 00 00 00	 call	 TCDeviceIoControl
  0005e	85 c0		 test	 eax, eax
  00060	7c 14		 jl	 SHORT $LN7@DriverEntr

; 74   : 		return DumpFilterEntry ((PFILTER_EXTENSION) DriverObject, (PFILTER_INITIALIZATION_DATA) RegistryPath);

  00062	48 8b 54 24 68	 mov	 rdx, QWORD PTR RegistryPath$[rsp]
  00067	48 8b 4c 24 60	 mov	 rcx, QWORD PTR DriverObject$[rsp]
  0006c	e8 00 00 00 00	 call	 DumpFilterEntry
  00071	e9 1b 01 00 00	 jmp	 $LN8@DriverEntr
$LN7@DriverEntr:

; 75   : 
; 76   : 	TCDriverObject = DriverObject;

  00076	48 8b 44 24 60	 mov	 rax, QWORD PTR DriverObject$[rsp]
  0007b	48 89 05 00 00
	00 00		 mov	 QWORD PTR TCDriverObject, rax

; 77   : 	memset (VirtualVolumeDeviceObjects, 0, sizeof (VirtualVolumeDeviceObjects));

  00082	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:VirtualVolumeDeviceObjects
  00089	33 c0		 xor	 eax, eax
  0008b	b9 d0 00 00 00	 mov	 ecx, 208		; 000000d0H
  00090	f3 aa		 rep stosb

; 78   : 
; 79   : 	ReadRegistryConfigFlags (TRUE);

  00092	b9 01 00 00 00	 mov	 ecx, 1
  00097	e8 00 00 00 00	 call	 ReadRegistryConfigFlags

; 80   : 	EncryptionThreadPoolStart (EncryptionThreadPoolFreeCpuCountLimit);

  0009c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR EncryptionThreadPoolFreeCpuCountLimit
  000a3	e8 00 00 00 00	 call	 EncryptionThreadPoolStart

; 81   : 	SelfTestsPassed = AutoTestAlgorithms();

  000a8	e8 00 00 00 00	 call	 AutoTestAlgorithms
  000ad	89 05 00 00 00
	00		 mov	 DWORD PTR SelfTestsPassed, eax

; 82   : 
; 83   : 	// Enable device class filters and load boot arguments if the driver is set to start at system boot
; 84   : 		
; 85   : 	if (NT_SUCCESS (TCReadRegistryKey (RegistryPath, L"Start", &startKeyValue)))

  000b3	4c 8d 44 24 38	 lea	 r8, QWORD PTR startKeyValue$[rsp]
  000b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1M@IOJLKPKK@?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@PBOPGDP@
  000bf	48 8b 4c 24 68	 mov	 rcx, QWORD PTR RegistryPath$[rsp]
  000c4	e8 00 00 00 00	 call	 TCReadRegistryKey
  000c9	85 c0		 test	 eax, eax
  000cb	7c 76		 jl	 SHORT $LN6@DriverEntr

; 86   : 	{
; 87   : 		if (startKeyValue->Type == REG_DWORD && *((uint32 *) startKeyValue->Data) == SERVICE_BOOT_START)

  000cd	48 8b 44 24 38	 mov	 rax, QWORD PTR startKeyValue$[rsp]
  000d2	83 78 04 04	 cmp	 DWORD PTR [rax+4], 4
  000d6	75 5b		 jne	 SHORT $LN5@DriverEntr
  000d8	48 8b 44 24 38	 mov	 rax, QWORD PTR startKeyValue$[rsp]
  000dd	83 78 0c 00	 cmp	 DWORD PTR [rax+12], 0
  000e1	75 50		 jne	 SHORT $LN5@DriverEntr

; 88   : 		{
; 89   : 			if (!SelfTestsPassed)

  000e3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR SelfTestsPassed, 0
  000ea	75 23		 jne	 SHORT $LN4@DriverEntr

; 90   : 				TC_BUG_CHECK (STATUS_INVALID_PARAMETER);

  000ec	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  000f5	45 33 c9	 xor	 r9d, r9d
  000f8	49 c7 c0 0d 00
	00 c0		 mov	 r8, -1073741811		; ffffffffc000000dH
  000ff	ba 5a 00 00 00	 mov	 edx, 90			; 0000005aH
  00104	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  00109	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN4@DriverEntr:

; 91   : 
; 92   : 			LoadBootArguments();

  0010f	e8 00 00 00 00	 call	 LoadBootArguments

; 93   : 			VolumeClassFilterRegistered = IsVolumeClassFilterRegistered();

  00114	e8 00 00 00 00	 call	 IsVolumeClassFilterRegistered
  00119	89 05 00 00 00
	00		 mov	 DWORD PTR VolumeClassFilterRegistered, eax

; 94   : 
; 95   : 			DriverObject->DriverExtension->AddDevice = DriverAddDevice;

  0011f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR DriverObject$[rsp]
  00124	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00128	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:DriverAddDevice
  0012f	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
$LN5@DriverEntr:

; 96   : 		}
; 97   : 
; 98   : 		TCfree (startKeyValue);

  00133	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00138	48 8b 4c 24 38	 mov	 rcx, QWORD PTR startKeyValue$[rsp]
  0013d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN6@DriverEntr:

; 99   : 	}
; 100  : 
; 101  : 	for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; ++i)

  00143	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0014b	eb 0b		 jmp	 SHORT $LN3@DriverEntr
$LN2@DriverEntr:
  0014d	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00151	83 c0 01	 add	 eax, 1
  00154	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN3@DriverEntr:
  00158	83 7c 24 30 1b	 cmp	 DWORD PTR i$[rsp], 27
  0015d	7f 18		 jg	 SHORT $LN1@DriverEntr

; 102  : 	{
; 103  : 		DriverObject->MajorFunction[i] = TCDispatchQueueIRP;

  0015f	48 63 54 24 30	 movsxd	 rdx, DWORD PTR i$[rsp]
  00164	48 8b 4c 24 60	 mov	 rcx, QWORD PTR DriverObject$[rsp]
  00169	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:TCDispatchQueueIRP
  00170	48 89 44 d1 70	 mov	 QWORD PTR [rcx+rdx*8+112], rax

; 104  : 	}

  00175	eb d6		 jmp	 SHORT $LN2@DriverEntr
$LN1@DriverEntr:

; 105  : 
; 106  : 	DriverObject->DriverUnload = TCUnloadDriver;

  00177	48 8b 4c 24 60	 mov	 rcx, QWORD PTR DriverObject$[rsp]
  0017c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:TCUnloadDriver
  00183	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 107  : 	return TCCreateRootDeviceObject (DriverObject);

  00187	48 8b 4c 24 60	 mov	 rcx, QWORD PTR DriverObject$[rsp]
  0018c	e8 00 00 00 00	 call	 TCCreateRootDeviceObject
$LN8@DriverEntr:
$LN9@DriverEntr:

; 108  : }

  00191	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00195	5f		 pop	 rdi
  00196	c3		 ret	 0
DriverEntry ENDP
INIT	ENDS
END
