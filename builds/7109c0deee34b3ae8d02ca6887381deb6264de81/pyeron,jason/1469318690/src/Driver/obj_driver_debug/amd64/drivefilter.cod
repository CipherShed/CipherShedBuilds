; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	IoSetCompletionRoutine
PUBLIC	IoGetNextIrpStackLocation
PUBLIC	IoCopyCurrentIrpStackLocationToNext
PUBLIC	IoGetCurrentIrpStackLocation
PUBLIC	IoMarkIrpPending
PUBLIC	IoSkipCurrentIrpStackLocation
PUBLIC	KeLowerIrql
PUBLIC	DbgRaiseAssertionFailure
PUBLIC	KeGetCurrentIrql
PUBLIC	KfRaiseIrql
PUBLIC	KeRaiseIrqlToDpcLevel
PUBLIC	KeInitializeSpinLock
PUBLIC	RtlSecureZeroMemory
PUBLIC	KeGetCurrentThread
PUBLIC	PsGetCurrentThread
PUBLIC	??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0FK@JAEDPCKJ@?$CIInvokeOnSuccess?5?$HM?$HM?5InvokeOnErro@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CI@HDMHMCGD@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	BootArgsValid
PUBLIC	EncryptionSetupThread
PUBLIC	DecoySystemWipeThread
PUBLIC	??_C@_0CA@ILBJGGPO@Checking?5BootArguments?5at?50x?$CFx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BN@JFNHMJPM@BootArguments?5found?5at?50x?$CFx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BN@NBHIKKLK@BootArguments?5CRC?5incorrect?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BI@NEHGCDJA@BootLoaderVersion?5?$DN?5?$CFx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BG@PNJAPAAK@HeaderSaltCrc32?5?$DN?5?$CFx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BH@DOJHKKND@CryptoInfoOffset?5?$DN?5?$CFx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BH@OFNGPMHI@CryptoInfoLength?5?$DN?5?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CE@JLLKOMJD@HiddenSystemPartitionStart?5?$DN?5?$CFI6@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CD@BAEBNNNN@DecoySystemPartitionStart?5?$DN?5?$CFI64@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0M@KEDLLGKK@Flags?5?$DN?5?$CFx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BJ@DENLEODJ@BootDriveSignature?5?$DN?5?$CFx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BJ@FBGGCCGI@BootArgumentsCrc32?5?$DN?5?$CFx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BN@FJJFAJFG@DriveFilterAddDevice?5pdo?$DN?$CFp?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BD@EAAMLHLJ@Dismounting?5drive?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EF@GDHJGIB@c?3?2users?2public?2desktop?2projects@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BI@ONACDOIC@Extension?9?$DODriveMounted?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BD@JFDPBFDA@MountDrive?5pdo?$DN?$CFp?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CE@KKOENIAD@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5PASSIVE_LE@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CA@JLOPIPKN@Reading?5volume?5header?5at?5?$CFI64u?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BH@FBDKNNGH@TCReadDevice?5error?5?$CFx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BC@LMOOMJMK@Header?5decrypted?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CE@ONLIABPH@Hidden?5volume?5start?5offset?5?$DN?5?$CFI6@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BM@GBKCGBDB@RemappedAreaOffset?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CE@NLPFMAEC@RemappedAreaDataUnitOffset?5?$DN?5?$CFI6@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0FO@PAPPJPK@Loaded?3?5ConfiguredEncryptedAreaS@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EK@PHFABMCK@Loaded?3?5EncryptedAreaStart?$DN?$CFI64d@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BF@DFBDNCBE@Wiping?5memory?5?$CFx?5?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CH@LNDECHEL@Failed?5to?5get?5drive?5number?5?9?5err@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CH@IHPMFJGA@Failed?5to?5get?5drive?5length?5?9?5err@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BG@CKLJIMPP@Header?5not?5decrypted?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BG@EAILECP@TCReadDevice?5error?5?$CFx?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0FO@BIDJBKJB@Saving?3?5ConfiguredEncryptedAreaS@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EK@MOIFFFBD@Saving?3?5EncryptedAreaStart?$DN?$CFI64d@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BF@DGHCICOF@Header?5not?5decrypted?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BH@PIJMMLOC@TCWriteDevice?5error?5?$CFx?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BP@NOBPEAIN@Drive?5and?5volume?5merged?5pdo?$DN?$CFp?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BM@EOGIDBIC@IRP_MN_START_DEVICE?5pdo?$DN?$CFp?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CK@HDNODHHC@IRP_MN_DEVICE_USAGE_NOTIFICATION@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BJ@ECOGMEFG@Preventing?5dump?5type?$DN?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BN@GINPCIAN@IRP_MN_REMOVE_DEVICE?5pdo?$DN?$CFp?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CL@JHMIFAKG@IRP_MJ_POWER?5minor?$DN?$CFd?5type?$DN?$CFd?5sh@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DK@ECCPCMLD@?$CBExtension?9?$DObRootDevice?5?$CG?$CG?5Exten@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BB@DLMCDLIB@Header?5reopened?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BF@GFCPIAML@Header?5not?5reopened?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BN@EAICPFDC@Filtering?5WriteFunctionA?5?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BN@MGBGIHJM@Filtering?5WriteFunctionB?5?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1M@IMEHFNOE@?$AAh?$AAi?$AAb?$AAe?$AAr?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1M@JEHGIGBM@?$AAH?$AAi?$AAb?$AAe?$AAr?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1M@IFMDENJC@?$AAH?$AAI?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BJ@CFHEDMMF@?$CBIsOSAtLeast?5?$CIWIN_VISTA?$CJ?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0P@MEMLEIEJ@Encrypting?4?4?4?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0P@DCAIKIEM@Decrypting?4?4?4?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BK@NLGNMKFH@EncryptedAreaStart?$DN?$CFI64d?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BI@NGOBDECI@EncryptedAreaEnd?$DN?$CFI64d?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CE@PHJPGEOK@ConfiguredEncryptedAreaStart?$DN?$CFI6@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CC@FCINBIJC@ConfiguredEncryptedAreaEnd?$DN?$CFI64d@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0O@CPDGLKAG@offset?$DN?$CFI64d?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DK@GDPNMFEK@EncryptedAreaStart?$DN?$CFI64d?5?$CI?$CFI64d?$CJ@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CF@CKMJEIIB@TCReadDevice?5error?5?$CFx?5?5offset?$DN?$CFI@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BI@LEBDPHBF@TCWriteDevice?5error?5?$CFx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BE@IDPHHPHP@NT_SUCCESS?5?$CIstatus?$CJ?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0FE@OKPCPDJI@Setup?5completed?3?5?5EncryptedAreaS@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CM@PJEGGJLG@Wiping?5decoy?5system?3?5?5start?5offs@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DB@OHMKNOCN@Wipe?5end?3?5DecoySystemWipedAreaEn@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_KeInitializeMutex:PROC
EXTRN	__imp_IoAttachDeviceToDeviceStack:PROC
EXTRN	__imp_IoCreateDevice:PROC
EXTRN	__imp_IoInitializeRemoveLockEx:PROC
EXTRN	__imp_IoDeleteDevice:PROC
EXTRN	__imp_IoDetachDevice:PROC
EXTRN	__imp_IoGetAttachedDeviceReference:PROC
EXTRN	__imp_IoReleaseRemoveLockAndWaitEx:PROC
EXTRN	__imp_ObfDereferenceObject:PROC
EXTRN	__imp_IofCallDriver:PROC
EXTRN	__imp_KeInitializeEvent:PROC
EXTRN	__imp_IoAllocateWorkItem:PROC
EXTRN	__imp_IoFreeWorkItem:PROC
EXTRN	__imp_IoQueueWorkItem:PROC
EXTRN	__imp_KeSetEvent:PROC
EXTRN	__imp_KeReleaseMutex:PROC
EXTRN	__imp_KeWaitForSingleObject:PROC
EXTRN	__imp_MmMapIoSpace:PROC
EXTRN	__imp_MmUnmapIoSpace:PROC
EXTRN	__imp_IoAcquireRemoveLockEx:PROC
EXTRN	__imp_IoReleaseRemoveLockEx:PROC
EXTRN	__imp_PoCallDriver:PROC
EXTRN	__imp_PoStartNextPowerIrp:PROC
EXTRN	__imp_MmBuildMdlForNonPagedPool:PROC
EXTRN	__imp_MmAllocateContiguousMemory:PROC
EXTRN	__imp_MmFreeContiguousMemory:PROC
EXTRN	__imp_IoAllocateMdl:PROC
EXTRN	__imp_IoFreeMdl:PROC
EXTRN	__imp_PsSetLoadImageNotifyRoutine:PROC
EXTRN	__imp_KeBugCheckEx:PROC
EXTRN	__imp_RtlAssert:PROC
EXTRN	DbgPrint:PROC
EXTRN	__imp_ExAllocatePoolWithTag:PROC
EXTRN	__imp_ExFreePoolWithTag:PROC
EXTRN	__imp_PsTerminateSystemThread:PROC
EXTRN	__imp_KeAcquireSpinLockRaiseToDpc:PROC
EXTRN	__imp_KeReleaseSpinLock:PROC
EXTRN	__imp_IoIsSystemThread:PROC
COMM	BootArgs:BYTE:076H
DeviceFilterActive DD 01H DUP (?)
BootArgsValid DD 01H DUP (?)
BootDriveSignatureValid DD 01H DUP (?)
BootDriveFound DD 01H DUP (?)
BootDriveFilterExtension DQ 01H DUP (?)
CrashDumpEnabled DD 01H DUP (?)
HibernationEnabled DD 01H DUP (?)
LegacyHibernationDriverFilterActive DD 01H DUP (?)
	ALIGN	8

HibernationWriteBuffer DQ 01H DUP (?)
HibernationWriteBufferMdl DQ 01H DUP (?)
HibernationPreventionCount DD 01H DUP (?)
SetupInProgress DD 01H DUP (?)
EncryptionSetupThread DQ 01H DUP (?)
DecoySystemWipeInProgress DD 01H DUP (?)
	ALIGN	8

DecoySystemWipeThread DQ 01H DUP (?)
LastHiberFilterNumber DD 01H DUP (?)
;	COMDAT ??_C@_0DB@OHMKNOCN@Wipe?5end?3?5DecoySystemWipedAreaEn@FNODOBFM@
text$s	SEGMENT
??_C@_0DB@OHMKNOCN@Wipe?5end?3?5DecoySystemWipedAreaEn@FNODOBFM@ DB 'Wipe'
	DB	' end: DecoySystemWipedAreaEnd=%I64d (%I64d)', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CM@PJEGGJLG@Wiping?5decoy?5system?3?5?5start?5offs@FNODOBFM@
text$s	SEGMENT
??_C@_0CM@PJEGGJLG@Wiping?5decoy?5system?3?5?5start?5offs@FNODOBFM@ DB 'W'
	DB	'iping decoy system:  start offset = %I64d', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0FE@OKPCPDJI@Setup?5completed?3?5?5EncryptedAreaS@FNODOBFM@
text$s	SEGMENT
??_C@_0FE@OKPCPDJI@Setup?5completed?3?5?5EncryptedAreaS@FNODOBFM@ DB 'Set'
	DB	'up completed:  EncryptedAreaStart=%I64d (%I64d)  EncryptedAre'
	DB	'aEnd=%I64d (%I64d)', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BE@IDPHHPHP@NT_SUCCESS?5?$CIstatus?$CJ?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BE@IDPHHPHP@NT_SUCCESS?5?$CIstatus?$CJ?$AA@FNODOBFM@ DB 'NT_SUCCES'
	DB	'S (status)', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BI@LEBDPHBF@TCWriteDevice?5error?5?$CFx?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BI@LEBDPHBF@TCWriteDevice?5error?5?$CFx?6?$AA@FNODOBFM@ DB 'TCWrit'
	DB	'eDevice error %x', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CF@CKMJEIIB@TCReadDevice?5error?5?$CFx?5?5offset?$DN?$CFI@FNODOBFM@
text$s	SEGMENT
??_C@_0CF@CKMJEIIB@TCReadDevice?5error?5?$CFx?5?5offset?$DN?$CFI@FNODOBFM@ DB 'T'
	DB	'CReadDevice error %x  offset=%I64d', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DK@GDPNMFEK@EncryptedAreaStart?$DN?$CFI64d?5?$CI?$CFI64d?$CJ@FNODOBFM@
text$s	SEGMENT
??_C@_0DK@GDPNMFEK@EncryptedAreaStart?$DN?$CFI64d?5?$CI?$CFI64d?$CJ@FNODOBFM@ DB 'E'
	DB	'ncryptedAreaStart=%I64d (%I64d)  EncryptedAreaEnd=%I64d', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0O@CPDGLKAG@offset?$DN?$CFI64d?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0O@CPDGLKAG@offset?$DN?$CFI64d?6?$AA@FNODOBFM@ DB 'offset=%I64d', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CC@FCINBIJC@ConfiguredEncryptedAreaEnd?$DN?$CFI64d@FNODOBFM@
text$s	SEGMENT
??_C@_0CC@FCINBIJC@ConfiguredEncryptedAreaEnd?$DN?$CFI64d@FNODOBFM@ DB 'C'
	DB	'onfiguredEncryptedAreaEnd=%I64d', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CE@PHJPGEOK@ConfiguredEncryptedAreaStart?$DN?$CFI6@FNODOBFM@
text$s	SEGMENT
??_C@_0CE@PHJPGEOK@ConfiguredEncryptedAreaStart?$DN?$CFI6@FNODOBFM@ DB 'C'
	DB	'onfiguredEncryptedAreaStart=%I64d', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BI@NGOBDECI@EncryptedAreaEnd?$DN?$CFI64d?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BI@NGOBDECI@EncryptedAreaEnd?$DN?$CFI64d?6?$AA@FNODOBFM@ DB 'Encry'
	DB	'ptedAreaEnd=%I64d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BK@NLGNMKFH@EncryptedAreaStart?$DN?$CFI64d?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BK@NLGNMKFH@EncryptedAreaStart?$DN?$CFI64d?6?$AA@FNODOBFM@ DB 'Enc'
	DB	'ryptedAreaStart=%I64d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0P@DCAIKIEM@Decrypting?4?4?4?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0P@DCAIKIEM@Decrypting?4?4?4?6?$AA@FNODOBFM@ DB 'Decrypting...', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0P@MEMLEIEJ@Encrypting?4?4?4?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0P@MEMLEIEJ@Encrypting?4?4?4?6?$AA@FNODOBFM@ DB 'Encrypting...', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BJ@CFHEDMMF@?$CBIsOSAtLeast?5?$CIWIN_VISTA?$CJ?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BJ@CFHEDMMF@?$CBIsOSAtLeast?5?$CIWIN_VISTA?$CJ?$AA@FNODOBFM@ DB '!'
	DB	'IsOSAtLeast (WIN_VISTA)', 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1M@IFMDENJC@?$AAH?$AAI?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1M@IFMDENJC@?$AAH?$AAI?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@ DB 'H', 00H
	DB	'I', 00H, 'B', 00H, 'E', 00H, 'R', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1M@JEHGIGBM@?$AAH?$AAi?$AAb?$AAe?$AAr?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1M@JEHGIGBM@?$AAH?$AAi?$AAb?$AAe?$AAr?$AA?$AA@FNODOBFM@ DB 'H', 00H
	DB	'i', 00H, 'b', 00H, 'e', 00H, 'r', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1M@IMEHFNOE@?$AAh?$AAi?$AAb?$AAe?$AAr?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1M@IMEHFNOE@?$AAh?$AAi?$AAb?$AAe?$AAr?$AA?$AA@FNODOBFM@ DB 'h', 00H
	DB	'i', 00H, 'b', 00H, 'e', 00H, 'r', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BN@MGBGIHJM@Filtering?5WriteFunctionB?5?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BN@MGBGIHJM@Filtering?5WriteFunctionB?5?$CFd?6?$AA@FNODOBFM@ DB 'F'
	DB	'iltering WriteFunctionB %d', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BN@EAICPFDC@Filtering?5WriteFunctionA?5?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BN@EAICPFDC@Filtering?5WriteFunctionA?5?$CFd?6?$AA@FNODOBFM@ DB 'F'
	DB	'iltering WriteFunctionA %d', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BF@GFCPIAML@Header?5not?5reopened?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BF@GFCPIAML@Header?5not?5reopened?6?$AA@FNODOBFM@ DB 'Header not r'
	DB	'eopened', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BB@DLMCDLIB@Header?5reopened?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BB@DLMCDLIB@Header?5reopened?6?$AA@FNODOBFM@ DB 'Header reopened', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DK@ECCPCMLD@?$CBExtension?9?$DObRootDevice?5?$CG?$CG?5Exten@FNODOBFM@
text$s	SEGMENT
??_C@_0DK@ECCPCMLD@?$CBExtension?9?$DObRootDevice?5?$CG?$CG?5Exten@FNODOBFM@ DB '!'
	DB	'Extension->bRootDevice && Extension->IsDriveFilterDevice', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CL@JHMIFAKG@IRP_MJ_POWER?5minor?$DN?$CFd?5type?$DN?$CFd?5sh@FNODOBFM@
text$s	SEGMENT
??_C@_0CL@JHMIFAKG@IRP_MJ_POWER?5minor?$DN?$CFd?5type?$DN?$CFd?5sh@FNODOBFM@ DB 'I'
	DB	'RP_MJ_POWER minor=%d type=%d shutdown=%d', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BN@GINPCIAN@IRP_MN_REMOVE_DEVICE?5pdo?$DN?$CFp?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BN@GINPCIAN@IRP_MN_REMOVE_DEVICE?5pdo?$DN?$CFp?6?$AA@FNODOBFM@ DB 'I'
	DB	'RP_MN_REMOVE_DEVICE pdo=%p', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BJ@ECOGMEFG@Preventing?5dump?5type?$DN?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BJ@ECOGMEFG@Preventing?5dump?5type?$DN?$CFd?6?$AA@FNODOBFM@ DB 'Pr'
	DB	'eventing dump type=%d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CK@HDNODHHC@IRP_MN_DEVICE_USAGE_NOTIFICATION@FNODOBFM@
text$s	SEGMENT
??_C@_0CK@HDNODHHC@IRP_MN_DEVICE_USAGE_NOTIFICATION@FNODOBFM@ DB 'IRP_MN_'
	DB	'DEVICE_USAGE_NOTIFICATION type=%d', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BM@EOGIDBIC@IRP_MN_START_DEVICE?5pdo?$DN?$CFp?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BM@EOGIDBIC@IRP_MN_START_DEVICE?5pdo?$DN?$CFp?6?$AA@FNODOBFM@ DB 'I'
	DB	'RP_MN_START_DEVICE pdo=%p', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BP@NOBPEAIN@Drive?5and?5volume?5merged?5pdo?$DN?$CFp?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BP@NOBPEAIN@Drive?5and?5volume?5merged?5pdo?$DN?$CFp?$AA@FNODOBFM@ DB 'D'
	DB	'rive and volume merged pdo=%p', 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BH@PIJMMLOC@TCWriteDevice?5error?5?$CFx?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BH@PIJMMLOC@TCWriteDevice?5error?5?$CFx?$AA@FNODOBFM@ DB 'TCWriteD'
	DB	'evice error %x', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BF@DGHCICOF@Header?5not?5decrypted?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BF@DGHCICOF@Header?5not?5decrypted?$AA@FNODOBFM@ DB 'Header not de'
	DB	'crypted', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EK@MOIFFFBD@Saving?3?5EncryptedAreaStart?$DN?$CFI64d@FNODOBFM@
text$s	SEGMENT
??_C@_0EK@MOIFFFBD@Saving?3?5EncryptedAreaStart?$DN?$CFI64d@FNODOBFM@ DB 'S'
	DB	'aving: EncryptedAreaStart=%I64d (%I64d)  EncryptedAreaEnd=%I6'
	DB	'4d (%I64d)', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0FO@BIDJBKJB@Saving?3?5ConfiguredEncryptedAreaS@FNODOBFM@
text$s	SEGMENT
??_C@_0FO@BIDJBKJB@Saving?3?5ConfiguredEncryptedAreaS@FNODOBFM@ DB 'Savin'
	DB	'g: ConfiguredEncryptedAreaStart=%I64d (%I64d)  ConfiguredEncr'
	DB	'yptedAreaEnd=%I64d (%I64d)', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BG@EAILECP@TCReadDevice?5error?5?$CFx?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BG@EAILECP@TCReadDevice?5error?5?$CFx?$AA@FNODOBFM@ DB 'TCReadDevi'
	DB	'ce error %x', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BG@CKLJIMPP@Header?5not?5decrypted?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BG@CKLJIMPP@Header?5not?5decrypted?6?$AA@FNODOBFM@ DB 'Header not '
	DB	'decrypted', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CH@IHPMFJGA@Failed?5to?5get?5drive?5length?5?9?5err@FNODOBFM@
text$s	SEGMENT
??_C@_0CH@IHPMFJGA@Failed?5to?5get?5drive?5length?5?9?5err@FNODOBFM@ DB 'F'
	DB	'ailed to get drive length - error %x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CH@LNDECHEL@Failed?5to?5get?5drive?5number?5?9?5err@FNODOBFM@
text$s	SEGMENT
??_C@_0CH@LNDECHEL@Failed?5to?5get?5drive?5number?5?9?5err@FNODOBFM@ DB 'F'
	DB	'ailed to get drive number - error %x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BF@DFBDNCBE@Wiping?5memory?5?$CFx?5?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BF@DFBDNCBE@Wiping?5memory?5?$CFx?5?$CFd?6?$AA@FNODOBFM@ DB 'Wipin'
	DB	'g memory %x %d', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EK@PHFABMCK@Loaded?3?5EncryptedAreaStart?$DN?$CFI64d@FNODOBFM@
text$s	SEGMENT
??_C@_0EK@PHFABMCK@Loaded?3?5EncryptedAreaStart?$DN?$CFI64d@FNODOBFM@ DB 'L'
	DB	'oaded: EncryptedAreaStart=%I64d (%I64d)  EncryptedAreaEnd=%I6'
	DB	'4d (%I64d)', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0FO@PAPPJPK@Loaded?3?5ConfiguredEncryptedAreaS@FNODOBFM@
text$s	SEGMENT
??_C@_0FO@PAPPJPK@Loaded?3?5ConfiguredEncryptedAreaS@FNODOBFM@ DB 'Loaded'
	DB	': ConfiguredEncryptedAreaStart=%I64d (%I64d)  ConfiguredEncry'
	DB	'ptedAreaEnd=%I64d (%I64d)', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CE@NLPFMAEC@RemappedAreaDataUnitOffset?5?$DN?5?$CFI6@FNODOBFM@
text$s	SEGMENT
??_C@_0CE@NLPFMAEC@RemappedAreaDataUnitOffset?5?$DN?5?$CFI6@FNODOBFM@ DB 'R'
	DB	'emappedAreaDataUnitOffset = %I64d', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BM@GBKCGBDB@RemappedAreaOffset?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BM@GBKCGBDB@RemappedAreaOffset?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@ DB 'R'
	DB	'emappedAreaOffset = %I64d', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CE@ONLIABPH@Hidden?5volume?5start?5offset?5?$DN?5?$CFI6@FNODOBFM@
text$s	SEGMENT
??_C@_0CE@ONLIABPH@Hidden?5volume?5start?5offset?5?$DN?5?$CFI6@FNODOBFM@ DB 'H'
	DB	'idden volume start offset = %I64d', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BC@LMOOMJMK@Header?5decrypted?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BC@LMOOMJMK@Header?5decrypted?6?$AA@FNODOBFM@ DB 'Header decrypted'
	DB	0aH, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BH@FBDKNNGH@TCReadDevice?5error?5?$CFx?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BH@FBDKNNGH@TCReadDevice?5error?5?$CFx?6?$AA@FNODOBFM@ DB 'TCReadD'
	DB	'evice error %x', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CA@JLOPIPKN@Reading?5volume?5header?5at?5?$CFI64u?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0CA@JLOPIPKN@Reading?5volume?5header?5at?5?$CFI64u?6?$AA@FNODOBFM@ DB 'R'
	DB	'eading volume header at %I64u', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CE@KKOENIAD@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5PASSIVE_LE@FNODOBFM@
text$s	SEGMENT
??_C@_0CE@KKOENIAD@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5PASSIVE_LE@FNODOBFM@ DB 'K'
	DB	'eGetCurrentIrql() == PASSIVE_LEVEL', 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BD@JFDPBFDA@MountDrive?5pdo?$DN?$CFp?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BD@JFDPBFDA@MountDrive?5pdo?$DN?$CFp?6?$AA@FNODOBFM@ DB 'MountDriv'
	DB	'e pdo=%p', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BI@ONACDOIC@Extension?9?$DODriveMounted?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BI@ONACDOIC@Extension?9?$DODriveMounted?$AA@FNODOBFM@ DB 'Extensio'
	DB	'n->DriveMounted', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EF@GDHJGIB@c?3?2users?2public?2desktop?2projects@FNODOBFM@
text$s	SEGMENT
??_C@_0EF@GDHJGIB@c?3?2users?2public?2desktop?2projects@FNODOBFM@ DB 'c:\'
	DB	'users\public\desktop\projects\ciphershed\src\driver\drivefilt'
	DB	'er.c', 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BD@EAAMLHLJ@Dismounting?5drive?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BD@EAAMLHLJ@Dismounting?5drive?6?$AA@FNODOBFM@ DB 'Dismounting dri'
	DB	've', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BN@FJJFAJFG@DriveFilterAddDevice?5pdo?$DN?$CFp?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BN@FJJFAJFG@DriveFilterAddDevice?5pdo?$DN?$CFp?6?$AA@FNODOBFM@ DB 'D'
	DB	'riveFilterAddDevice pdo=%p', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BJ@FBGGCCGI@BootArgumentsCrc32?5?$DN?5?$CFx?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BJ@FBGGCCGI@BootArgumentsCrc32?5?$DN?5?$CFx?6?$AA@FNODOBFM@ DB 'Bo'
	DB	'otArgumentsCrc32 = %x', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BJ@DENLEODJ@BootDriveSignature?5?$DN?5?$CFx?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BJ@DENLEODJ@BootDriveSignature?5?$DN?5?$CFx?6?$AA@FNODOBFM@ DB 'Bo'
	DB	'otDriveSignature = %x', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0M@KEDLLGKK@Flags?5?$DN?5?$CFx?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0M@KEDLLGKK@Flags?5?$DN?5?$CFx?6?$AA@FNODOBFM@ DB 'Flags = %x', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CD@BAEBNNNN@DecoySystemPartitionStart?5?$DN?5?$CFI64@FNODOBFM@
text$s	SEGMENT
??_C@_0CD@BAEBNNNN@DecoySystemPartitionStart?5?$DN?5?$CFI64@FNODOBFM@ DB 'D'
	DB	'ecoySystemPartitionStart = %I64u', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CE@JLLKOMJD@HiddenSystemPartitionStart?5?$DN?5?$CFI6@FNODOBFM@
text$s	SEGMENT
??_C@_0CE@JLLKOMJD@HiddenSystemPartitionStart?5?$DN?5?$CFI6@FNODOBFM@ DB 'H'
	DB	'iddenSystemPartitionStart = %I64u', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BH@OFNGPMHI@CryptoInfoLength?5?$DN?5?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BH@OFNGPMHI@CryptoInfoLength?5?$DN?5?$CFd?6?$AA@FNODOBFM@ DB 'Cryp'
	DB	'toInfoLength = %d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BH@DOJHKKND@CryptoInfoOffset?5?$DN?5?$CFx?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BH@DOJHKKND@CryptoInfoOffset?5?$DN?5?$CFx?6?$AA@FNODOBFM@ DB 'Cryp'
	DB	'toInfoOffset = %x', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BG@PNJAPAAK@HeaderSaltCrc32?5?$DN?5?$CFx?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BG@PNJAPAAK@HeaderSaltCrc32?5?$DN?5?$CFx?6?$AA@FNODOBFM@ DB 'Heade'
	DB	'rSaltCrc32 = %x', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BI@NEHGCDJA@BootLoaderVersion?5?$DN?5?$CFx?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BI@NEHGCDJA@BootLoaderVersion?5?$DN?5?$CFx?6?$AA@FNODOBFM@ DB 'Boo'
	DB	'tLoaderVersion = %x', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BN@NBHIKKLK@BootArguments?5CRC?5incorrect?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BN@NBHIKKLK@BootArguments?5CRC?5incorrect?6?$AA@FNODOBFM@ DB 'Boot'
	DB	'Arguments CRC incorrect', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BN@JFNHMJPM@BootArguments?5found?5at?50x?$CFx?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BN@JFNHMJPM@BootArguments?5found?5at?50x?$CFx?6?$AA@FNODOBFM@ DB 'B'
	DB	'ootArguments found at 0x%x', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CA@ILBJGGPO@Checking?5BootArguments?5at?50x?$CFx?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0CA@ILBJGGPO@Checking?5BootArguments?5at?50x?$CFx?6?$AA@FNODOBFM@ DB 'C'
	DB	'hecking BootArguments at 0x%x', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CI@HDMHMCGD@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
text$s	SEGMENT
??_C@_0CI@HDMHMCGD@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ DB 'I'
	DB	'rp->CurrentLocation <= Irp->StackCount', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0FK@JAEDPCKJ@?$CIInvokeOnSuccess?5?$HM?$HM?5InvokeOnErro@FNODOBFM@
text$s	SEGMENT
??_C@_0FK@JAEDPCKJ@?$CIInvokeOnSuccess?5?$HM?$HM?5InvokeOnErro@FNODOBFM@ DB '('
	DB	'InvokeOnSuccess || InvokeOnError || InvokeOnCancel) ? (Comple'
	DB	'tionRoutine != NULL) : TRUE', 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@ DB 'Irp'
	DB	'->CurrentLocation > 0', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
text$s	SEGMENT
??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ DB 'I'
	DB	'rp->CurrentLocation <= Irp->StackCount + 1', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@
text$s	SEGMENT
??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@ DB 'c'
	DB	':\winddk\7600.16385.1\inc\ddk\wdm.h', 00H	;  ?? ::FNODOBFM::`string'
PUBLIC	GetBootDriveLength
BootDriveLength DQ 01H DUP (?)
; Function compile flags: /Odtp
; File c:\users\public\desktop\projects\ciphershed\src\driver\drivefilter.c
;	COMDAT GetBootDriveLength
_TEXT	SEGMENT
GetBootDriveLength PROC					; COMDAT

; 1928 : 	return BootDriveLength.QuadPart;

  00000	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveLength

; 1929 : }

  00007	c3		 ret	 0
GetBootDriveLength ENDP
_TEXT	ENDS
PUBLIC	GetDecoySystemWipeResult
DecoySystemWipeResult DD 01H DUP (?)
; Function compile flags: /Odtp
;	COMDAT GetDecoySystemWipeResult
_TEXT	SEGMENT
GetDecoySystemWipeResult PROC				; COMDAT

; 1905 : 	return DecoySystemWipeResult;

  00000	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR DecoySystemWipeResult

; 1906 : }

  00006	c3		 ret	 0
GetDecoySystemWipeResult ENDP
_TEXT	ENDS
PUBLIC	GetSystemDriveCryptoInfo
; Function compile flags: /Odtp
;	COMDAT GetSystemDriveCryptoInfo
_TEXT	SEGMENT
GetSystemDriveCryptoInfo PROC				; COMDAT

; 1674 : 	return BootDriveFilterExtension->Queue.CryptoInfo;

  00000	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00007	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]

; 1675 : }

  0000e	c3		 ret	 0
GetSystemDriveCryptoInfo ENDP
_TEXT	ENDS
PUBLIC	GetBootDriveFilterExtension
; Function compile flags: /Odtp
;	COMDAT GetBootDriveFilterExtension
_TEXT	SEGMENT
GetBootDriveFilterExtension PROC			; COMDAT

; 1668 : 	return BootDriveFilterExtension;

  00000	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension

; 1669 : }

  00007	c3		 ret	 0
GetBootDriveFilterExtension ENDP
_TEXT	ENDS
PUBLIC	IsHiddenSystemRunning
;	COMDAT pdata
pdata	SEGMENT
$pdata$IsHiddenSystemRunning DD imagerel $LN5
	DD	imagerel $LN5+54
	DD	imagerel $unwind$IsHiddenSystemRunning
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IsHiddenSystemRunning DD 010401H
	DD	02204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT IsHiddenSystemRunning
_TEXT	SEGMENT
tv67 = 0
IsHiddenSystemRunning PROC				; COMDAT

; 1661 : {

$LN5:
  00000	48 83 ec 18	 sub	 rsp, 24

; 1662 : 	return BootDriveFilterExtension && BootDriveFilterExtension->HiddenSystem;

  00004	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR BootDriveFilterExtension, 0
  0000c	74 19		 je	 SHORT $LN3@IsHiddenSy
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00015	83 b8 38 03 00
	00 00		 cmp	 DWORD PTR [rax+824], 0
  0001c	74 09		 je	 SHORT $LN3@IsHiddenSy
  0001e	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv67[rsp], 1
  00025	eb 07		 jmp	 SHORT $LN4@IsHiddenSy
$LN3@IsHiddenSy:
  00027	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv67[rsp], 0
$LN4@IsHiddenSy:
  0002e	8b 04 24	 mov	 eax, DWORD PTR tv67[rsp]

; 1663 : }

  00031	48 83 c4 18	 add	 rsp, 24
  00035	c3		 ret	 0
IsHiddenSystemRunning ENDP
_TEXT	ENDS
PUBLIC	IsBootDriveMounted
;	COMDAT pdata
pdata	SEGMENT
$pdata$IsBootDriveMounted DD imagerel $LN5
	DD	imagerel $LN5+54
	DD	imagerel $unwind$IsBootDriveMounted
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IsBootDriveMounted DD 010401H
	DD	02204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT IsBootDriveMounted
_TEXT	SEGMENT
tv67 = 0
IsBootDriveMounted PROC					; COMDAT

; 1649 : {

$LN5:
  00000	48 83 ec 18	 sub	 rsp, 24

; 1650 : 	return BootDriveFilterExtension && BootDriveFilterExtension->DriveMounted;

  00004	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR BootDriveFilterExtension, 0
  0000c	74 19		 je	 SHORT $LN3@IsBootDriv
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00015	83 b8 10 03 00
	00 00		 cmp	 DWORD PTR [rax+784], 0
  0001c	74 09		 je	 SHORT $LN3@IsBootDriv
  0001e	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv67[rsp], 1
  00025	eb 07		 jmp	 SHORT $LN4@IsBootDriv
$LN3@IsBootDriv:
  00027	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv67[rsp], 0
$LN4@IsBootDriv:
  0002e	8b 04 24	 mov	 eax, DWORD PTR tv67[rsp]

; 1651 : }

  00031	48 83 c4 18	 add	 rsp, 24
  00035	c3		 ret	 0
IsBootDriveMounted ENDP
_TEXT	ENDS
PUBLIC	GetSetupResult
SetupResult DD	01H DUP (?)
; Function compile flags: /Odtp
;	COMDAT GetSetupResult
_TEXT	SEGMENT
GetSetupResult PROC					; COMDAT

; 1644 : 	return SetupResult;

  00000	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR SetupResult

; 1645 : }

  00006	c3		 ret	 0
GetSetupResult ENDP
_TEXT	ENDS
PUBLIC	DriveFilterAddDevice
;	COMDAT pdata
pdata	SEGMENT
$pdata$DriveFilterAddDevice DD imagerel $LN7
	DD	imagerel $LN7+555
	DD	imagerel $unwind$DriveFilterAddDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DriveFilterAddDevice DD 020f01H
	DD	0700bb20fH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DriveFilterAddDevice
_TEXT	SEGMENT
Extension$ = 64
attachedDeviceObject$ = 72
status$ = 80
filterDeviceObject$ = 88
driverObject$ = 112
pdo$ = 120
DriveFilterAddDevice PROC				; COMDAT

; 143  : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 144  : 	DriveFilterExtension *Extension;
; 145  : 	NTSTATUS status;
; 146  : 	PDEVICE_OBJECT filterDeviceObject = NULL;

  0000f	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR filterDeviceObject$[rsp], 0

; 147  : 	PDEVICE_OBJECT attachedDeviceObject;
; 148  : 
; 149  : 	Dump ("DriveFilterAddDevice pdo=%p\n", pdo);

  00018	48 8b 54 24 78	 mov	 rdx, QWORD PTR pdo$[rsp]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@FJJFAJFG@DriveFilterAddDevice?5pdo?$DN?$CFp?6?$AA@FNODOBFM@
  00024	e8 00 00 00 00	 call	 DbgPrint

; 150  : 
; 151  : 	attachedDeviceObject = IoGetAttachedDeviceReference (pdo);

  00029	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pdo$[rsp]
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetAttachedDeviceReference
  00034	48 89 44 24 48	 mov	 QWORD PTR attachedDeviceObject$[rsp], rax

; 152  : 	status = IoCreateDevice (driverObject, sizeof (DriveFilterExtension), NULL, attachedDeviceObject->DeviceType, 0, FALSE, &filterDeviceObject);

  00039	48 8d 44 24 58	 lea	 rax, QWORD PTR filterDeviceObject$[rsp]
  0003e	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00043	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00048	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00050	48 8b 44 24 48	 mov	 rax, QWORD PTR attachedDeviceObject$[rsp]
  00055	44 8b 48 48	 mov	 r9d, DWORD PTR [rax+72]
  00059	45 33 c0	 xor	 r8d, r8d
  0005c	ba 40 03 00 00	 mov	 edx, 832		; 00000340H
  00061	48 8b 4c 24 70	 mov	 rcx, QWORD PTR driverObject$[rsp]
  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateDevice
  0006c	89 44 24 50	 mov	 DWORD PTR status$[rsp], eax

; 153  : 
; 154  : 	ObDereferenceObject (attachedDeviceObject);

  00070	48 8b 4c 24 48	 mov	 rcx, QWORD PTR attachedDeviceObject$[rsp]
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 155  : 
; 156  : 	if (!NT_SUCCESS (status))

  0007b	83 7c 24 50 00	 cmp	 DWORD PTR status$[rsp], 0
  00080	7d 0e		 jge	 SHORT $LN4@DriveFilte

; 157  : 	{
; 158  : 		filterDeviceObject = NULL;

  00082	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR filterDeviceObject$[rsp], 0

; 159  : 		goto err;

  0008b	e9 63 01 00 00	 jmp	 $err$29553
$LN4@DriveFilte:

; 160  : 	}
; 161  : 
; 162  : 	Extension = (DriveFilterExtension *) filterDeviceObject->DeviceExtension;

  00090	48 8b 44 24 58	 mov	 rax, QWORD PTR filterDeviceObject$[rsp]
  00095	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00099	48 89 44 24 40	 mov	 QWORD PTR Extension$[rsp], rax

; 163  : 	memset (Extension, 0, sizeof (DriveFilterExtension));

  0009e	48 8b 7c 24 40	 mov	 rdi, QWORD PTR Extension$[rsp]
  000a3	33 c0		 xor	 eax, eax
  000a5	b9 40 03 00 00	 mov	 ecx, 832		; 00000340H
  000aa	f3 aa		 rep stosb

; 164  : 
; 165  : 	Extension->LowerDeviceObject = IoAttachDeviceToDeviceStack (filterDeviceObject, pdo);  // IoAttachDeviceToDeviceStackSafe() is not required in AddDevice routine and is also unavailable on Windows 2000 SP4

  000ac	48 8b 54 24 78	 mov	 rdx, QWORD PTR pdo$[rsp]
  000b1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR filterDeviceObject$[rsp]
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAttachDeviceToDeviceStack
  000bc	48 8b d0	 mov	 rdx, rax
  000bf	48 8b 44 24 40	 mov	 rax, QWORD PTR Extension$[rsp]
  000c4	48 89 50 20	 mov	 QWORD PTR [rax+32], rdx

; 166  : 	if (!Extension->LowerDeviceObject)

  000c8	48 8b 44 24 40	 mov	 rax, QWORD PTR Extension$[rsp]
  000cd	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  000d2	75 0d		 jne	 SHORT $LN3@DriveFilte

; 167  : 	{
; 168  : 		status = STATUS_DEVICE_REMOVED;

  000d4	c7 44 24 50 b6
	02 00 c0	 mov	 DWORD PTR status$[rsp], -1073741130 ; ffffffffc00002b6H

; 169  : 		goto err;

  000dc	e9 12 01 00 00	 jmp	 $err$29553
$LN3@DriveFilte:

; 170  : 	}
; 171  : 
; 172  : 	Extension->IsDriveFilterDevice = Extension->Queue.IsFilterDevice = TRUE;

  000e1	48 8b 44 24 40	 mov	 rax, QWORD PTR Extension$[rsp]
  000e6	c7 80 b8 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+184], 1
  000f0	48 8b 44 24 40	 mov	 rax, QWORD PTR Extension$[rsp]
  000f5	c7 40 08 01 00
	00 00		 mov	 DWORD PTR [rax+8], 1

; 173  : 	Extension->DeviceObject = Extension->Queue.DeviceObject = filterDeviceObject;

  000fc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Extension$[rsp]
  00101	48 8b 44 24 58	 mov	 rax, QWORD PTR filterDeviceObject$[rsp]
  00106	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
  0010a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Extension$[rsp]
  0010f	48 8b 44 24 58	 mov	 rax, QWORD PTR filterDeviceObject$[rsp]
  00114	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 174  : 	Extension->Pdo = pdo;

  00118	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Extension$[rsp]
  0011d	48 8b 44 24 78	 mov	 rax, QWORD PTR pdo$[rsp]
  00122	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 175  : 	
; 176  : 	Extension->Queue.LowerDeviceObject = Extension->LowerDeviceObject;

  00126	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Extension$[rsp]
  0012b	48 8b 44 24 40	 mov	 rax, QWORD PTR Extension$[rsp]
  00130	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00134	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax

; 177  : 	IoInitializeRemoveLock (&Extension->Queue.RemoveLock, 'LRCT', 0, 0);

  0013b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Extension$[rsp]
  00140	48 81 c1 f0 00
	00 00		 add	 rcx, 240		; 000000f0H
  00147	c7 44 24 20 78
	00 00 00	 mov	 DWORD PTR [rsp+32], 120	; 00000078H
  0014f	45 33 c9	 xor	 r9d, r9d
  00152	45 33 c0	 xor	 r8d, r8d
  00155	ba 54 43 52 4c	 mov	 edx, 1280459604		; 4c524354H
  0015a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoInitializeRemoveLockEx

; 178  : 
; 179  : 	Extension->ConfiguredEncryptedAreaStart = -1;

  00160	48 8b 54 24 40	 mov	 rdx, QWORD PTR Extension$[rsp]
  00165	48 c7 42 38 ff
	ff ff ff	 mov	 QWORD PTR [rdx+56], -1

; 180  : 	Extension->ConfiguredEncryptedAreaEnd = -1;

  0016d	48 8b 44 24 40	 mov	 rax, QWORD PTR Extension$[rsp]
  00172	48 c7 40 40 ff
	ff ff ff	 mov	 QWORD PTR [rax+64], -1

; 181  : 	Extension->Queue.EncryptedAreaStart = -1;

  0017a	48 8b 44 24 40	 mov	 rax, QWORD PTR Extension$[rsp]
  0017f	48 c7 80 c8 00
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rax+200], -1

; 182  : 	Extension->Queue.EncryptedAreaEnd = -1;

  0018a	48 8b 44 24 40	 mov	 rax, QWORD PTR Extension$[rsp]
  0018f	48 c7 80 d0 00
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rax+208], -1

; 183  : 	Extension->Queue.EncryptedAreaEndUpdatePending = FALSE;

  0019a	48 8b 44 24 40	 mov	 rax, QWORD PTR Extension$[rsp]
  0019f	c7 80 d8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+216], 0

; 184  : 
; 185  : 	filterDeviceObject->Flags |= Extension->LowerDeviceObject->Flags & (DO_DIRECT_IO | DO_BUFFERED_IO | DO_POWER_PAGABLE);

  001a9	48 8b 44 24 40	 mov	 rax, QWORD PTR Extension$[rsp]
  001ae	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  001b2	8b 50 30	 mov	 edx, DWORD PTR [rax+48]
  001b5	81 e2 14 20 00
	00		 and	 edx, 8212		; 00002014H
  001bb	48 8b 44 24 58	 mov	 rax, QWORD PTR filterDeviceObject$[rsp]
  001c0	8b 48 30	 mov	 ecx, DWORD PTR [rax+48]
  001c3	0b ca		 or	 ecx, edx
  001c5	48 8b 44 24 58	 mov	 rax, QWORD PTR filterDeviceObject$[rsp]
  001ca	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 186  : 	filterDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

  001cd	48 8b 44 24 58	 mov	 rax, QWORD PTR filterDeviceObject$[rsp]
  001d2	8b 48 30	 mov	 ecx, DWORD PTR [rax+48]
  001d5	81 e1 7f ff ff
	ff		 and	 ecx, -129		; ffffff7fH
  001db	48 8b 44 24 58	 mov	 rax, QWORD PTR filterDeviceObject$[rsp]
  001e0	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 187  : 
; 188  : 	DeviceFilterActive = TRUE;

  001e3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR DeviceFilterActive, 1

; 189  : 	return status;

  001ed	8b 44 24 50	 mov	 eax, DWORD PTR status$[rsp]
  001f1	eb 32		 jmp	 SHORT $LN5@DriveFilte
$err$29553:

; 190  : 
; 191  : err:
; 192  : 	if (filterDeviceObject)

  001f3	48 83 7c 24 58
	00		 cmp	 QWORD PTR filterDeviceObject$[rsp], 0
  001f9	74 26		 je	 SHORT $LN2@DriveFilte

; 193  : 	{
; 194  : 		if (Extension->LowerDeviceObject)

  001fb	48 8b 44 24 40	 mov	 rax, QWORD PTR Extension$[rsp]
  00200	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00205	74 0f		 je	 SHORT $LN1@DriveFilte

; 195  : 			IoDetachDevice (Extension->LowerDeviceObject);

  00207	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Extension$[rsp]
  0020c	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00210	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDetachDevice
$LN1@DriveFilte:

; 196  : 
; 197  : 		IoDeleteDevice (filterDeviceObject);

  00216	48 8b 4c 24 58	 mov	 rcx, QWORD PTR filterDeviceObject$[rsp]
  0021b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteDevice
$LN2@DriveFilte:

; 198  : 	}
; 199  : 
; 200  : 	return status;

  00221	8b 44 24 50	 mov	 eax, DWORD PTR status$[rsp]
$LN5@DriveFilte:

; 201  : }

  00225	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00229	5f		 pop	 rdi
  0022a	c3		 ret	 0
DriveFilterAddDevice ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$IoSkipCurrentIrpStackLocation DD imagerel $LN5
	DD	imagerel $LN5+131
	DD	imagerel $unwind$IoSkipCurrentIrpStackLocation
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IoSkipCurrentIrpStackLocation DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT IoSkipCurrentIrpStackLocation
_TEXT	SEGMENT
tv73 = 32
Irp$ = 64
IoSkipCurrentIrpStackLocation PROC			; COMDAT

; 23945: {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 23946:     ASSERT(Irp->CurrentLocation <= Irp->StackCount);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR Irp$[rsp]
  0000e	0f be 48 43	 movsx	 ecx, BYTE PTR [rax+67]
  00012	48 8b 44 24 40	 mov	 rax, QWORD PTR Irp$[rsp]
  00017	0f be 40 42	 movsx	 eax, BYTE PTR [rax+66]
  0001b	3b c8		 cmp	 ecx, eax
  0001d	7e 27		 jle	 SHORT $LN3@IoSkipCurr
  0001f	45 33 c9	 xor	 r9d, r9d
  00022	41 b8 8a 5d 00
	00		 mov	 r8d, 23946		; 00005d8aH
  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CI@HDMHMCGD@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  0003c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
  00044	eb 08		 jmp	 SHORT $LN4@IoSkipCurr
$LN3@IoSkipCurr:
  00046	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
$LN4@IoSkipCurr:

; 23947:     Irp->CurrentLocation++;

  0004e	48 8b 44 24 40	 mov	 rax, QWORD PTR Irp$[rsp]
  00053	0f b6 48 43	 movzx	 ecx, BYTE PTR [rax+67]
  00057	80 c1 01	 add	 cl, 1
  0005a	48 8b 44 24 40	 mov	 rax, QWORD PTR Irp$[rsp]
  0005f	88 48 43	 mov	 BYTE PTR [rax+67], cl

; 23948:     Irp->Tail.Overlay.CurrentStackLocation++;

  00062	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Irp$[rsp]
  00067	48 8b 89 b8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+184]
  0006e	48 83 c1 48	 add	 rcx, 72			; 00000048H
  00072	48 8b 44 24 40	 mov	 rax, QWORD PTR Irp$[rsp]
  00077	48 89 88 b8 00
	00 00		 mov	 QWORD PTR [rax+184], rcx

; 23949: }

  0007e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00082	c3		 ret	 0
IoSkipCurrentIrpStackLocation ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$IoGetNextIrpStackLocation DD imagerel $LN5
	DD	imagerel $LN5+90
	DD	imagerel $unwind$IoGetNextIrpStackLocation
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IoGetNextIrpStackLocation DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT IoGetNextIrpStackLocation
_TEXT	SEGMENT
tv71 = 32
Irp$ = 64
IoGetNextIrpStackLocation PROC				; COMDAT

; 23479: {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 23480:     ASSERT(Irp->CurrentLocation > 0);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR Irp$[rsp]
  0000e	0f be 40 43	 movsx	 eax, BYTE PTR [rax+67]
  00012	85 c0		 test	 eax, eax
  00014	7f 27		 jg	 SHORT $LN3@IoGetNextI
  00016	45 33 c9	 xor	 r9d, r9d
  00019	41 b8 b8 5b 00
	00		 mov	 r8d, 23480		; 00005bb8H
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  00033	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
  0003b	eb 08		 jmp	 SHORT $LN4@IoGetNextI
$LN3@IoGetNextI:
  0003d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv71[rsp], 1
$LN4@IoGetNextI:

; 23481: 
; 23482:     return ((Irp)->Tail.Overlay.CurrentStackLocation - 1 );

  00045	48 8b 44 24 40	 mov	 rax, QWORD PTR Irp$[rsp]
  0004a	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  00051	48 83 e8 48	 sub	 rax, 72			; 00000048H

; 23483: }

  00055	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00059	c3		 ret	 0
IoGetNextIrpStackLocation ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$IoGetCurrentIrpStackLocation DD imagerel $LN5
	DD	imagerel $LN5+98
	DD	imagerel $unwind$IoGetCurrentIrpStackLocation
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IoGetCurrentIrpStackLocation DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT IoGetCurrentIrpStackLocation
_TEXT	SEGMENT
tv74 = 32
Irp$ = 64
IoGetCurrentIrpStackLocation PROC			; COMDAT

; 23316: {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 23317:     ASSERT(Irp->CurrentLocation <= Irp->StackCount + 1);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR Irp$[rsp]
  0000e	0f be 48 43	 movsx	 ecx, BYTE PTR [rax+67]
  00012	48 8b 44 24 40	 mov	 rax, QWORD PTR Irp$[rsp]
  00017	0f be 40 42	 movsx	 eax, BYTE PTR [rax+66]
  0001b	83 c0 01	 add	 eax, 1
  0001e	3b c8		 cmp	 ecx, eax
  00020	7e 27		 jle	 SHORT $LN3@IoGetCurre
  00022	45 33 c9	 xor	 r9d, r9d
  00025	41 b8 15 5b 00
	00		 mov	 r8d, 23317		; 00005b15H
  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  0003f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
  00047	eb 08		 jmp	 SHORT $LN4@IoGetCurre
$LN3@IoGetCurre:
  00049	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
$LN4@IoGetCurre:

; 23318:     return Irp->Tail.Overlay.CurrentStackLocation;

  00051	48 8b 44 24 40	 mov	 rax, QWORD PTR Irp$[rsp]
  00056	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]

; 23319: }

  0005d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00061	c3		 ret	 0
IoGetCurrentIrpStackLocation ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT KeInitializeSpinLock
_TEXT	SEGMENT
SpinLock$ = 8
KeInitializeSpinLock PROC				; COMDAT

; 15095: {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 15096: 
; 15097:     *SpinLock = 0;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR SpinLock$[rsp]
  0000a	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 15098:     return;
; 15099: }

  00011	c3		 ret	 0
KeInitializeSpinLock ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT KeGetCurrentIrql
_TEXT	SEGMENT
KeGetCurrentIrql PROC					; COMDAT

; 13365: 
; 13366:     return (KIRQL)ReadCR8();

  00000	44 0f 20 c0	 mov	 rax, cr8

; 13367: }

  00004	c3		 ret	 0
KeGetCurrentIrql ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$RtlSecureZeroMemory DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$RtlSecureZeroMemory
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RtlSecureZeroMemory DD 020f01H
	DD	0700b120fH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT RtlSecureZeroMemory
_TEXT	SEGMENT
vptr$ = 0
ptr$ = 32
cnt$ = 40
RtlSecureZeroMemory PROC				; COMDAT

; 8322 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 10	 sub	 rsp, 16

; 8323 :     volatile char *vptr = (volatile char *)ptr;

  0000f	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  00014	48 89 04 24	 mov	 QWORD PTR vptr$[rsp], rax

; 8324 : 
; 8325 : #if defined(_M_AMD64)
; 8326 : 
; 8327 :         __stosb((PUCHAR)((ULONG64)vptr), 0, cnt);

  00018	48 8b 3c 24	 mov	 rdi, QWORD PTR vptr$[rsp]
  0001c	33 c0		 xor	 eax, eax
  0001e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cnt$[rsp]
  00023	f3 aa		 rep stosb

; 8328 : 
; 8329 : #else
; 8330 : 
; 8331 :     while (cnt) {
; 8332 :         *vptr = 0;
; 8333 :         vptr++;
; 8334 :         cnt--;
; 8335 :     }
; 8336 : 
; 8337 : #endif
; 8338 : 
; 8339 :     return ptr;

  00025	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]

; 8340 : }

  0002a	48 83 c4 10	 add	 rsp, 16
  0002e	5f		 pop	 rdi
  0002f	c3		 ret	 0
RtlSecureZeroMemory ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT DbgRaiseAssertionFailure
_TEXT	SEGMENT
DbgRaiseAssertionFailure PROC				; COMDAT

; 1568 :     __int2c();

  00000	cd 2c		 int	 44			; 0000002cH

; 1569 : }

  00002	c3		 ret	 0
DbgRaiseAssertionFailure ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT KeGetCurrentThread
_TEXT	SEGMENT
KeGetCurrentThread PROC					; COMDAT

; 116  :     return (struct _KTHREAD *)__readgsqword(0x188);

  00000	65 48 8b 04 25
	88 01 00 00	 mov	 rax, QWORD PTR gs:392

; 117  : }

  00009	c3		 ret	 0
KeGetCurrentThread ENDP
PUBLIC	GetDecoySystemWipeStatus
DecoySystemWipedAreaEnd DQ 01H DUP (?)
DecoySystemWipeStatusSpinLock DQ 01H DUP (?)
WipeDecoyRequest DB 0104H DUP (?)
;	COMDAT pdata
; File c:\users\public\desktop\projects\ciphershed\src\driver\drivefilter.c
pdata	SEGMENT
$pdata$GetDecoySystemWipeStatus DD imagerel $LN8
	DD	imagerel $LN8+232
	DD	imagerel $unwind$GetDecoySystemWipeStatus
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetDecoySystemWipeStatus DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GetDecoySystemWipeStatus
_TEXT	SEGMENT
wipeStatus$30538 = 32
irql$30544 = 40
irp$ = 64
irpSp$ = 72
GetDecoySystemWipeStatus PROC				; COMDAT

; 1871 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1872 : 	if (ValidateIOBufferSize (irp, sizeof (DecoySystemWipeStatus), ValidateOutput))

  0000e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00014	ba 10 00 00 00	 mov	 edx, 16
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR irp$[rsp]
  0001e	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00023	85 c0		 test	 eax, eax
  00025	0f 84 b8 00 00
	00		 je	 $LN5@GetDecoySy

; 1873 : 	{
; 1874 : 		DecoySystemWipeStatus *wipeStatus = (DecoySystemWipeStatus *) irp->AssociatedIrp.SystemBuffer;

  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR irp$[rsp]
  00030	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00034	48 89 44 24 20	 mov	 QWORD PTR wipeStatus$30538[rsp], rax

; 1875 : 
; 1876 : 		if (!IsHiddenSystemRunning())

  00039	e8 00 00 00 00	 call	 IsHiddenSystemRunning
  0003e	85 c0		 test	 eax, eax
  00040	75 1e		 jne	 SHORT $LN4@GetDecoySy

; 1877 : 		{
; 1878 : 			irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  00042	48 8b 44 24 40	 mov	 rax, QWORD PTR irp$[rsp]
  00047	c7 40 30 0d 00
	00 c0		 mov	 DWORD PTR [rax+48], -1073741811 ; ffffffffc000000dH

; 1879 : 			irp->IoStatus.Information = 0;

  0004e	48 8b 44 24 40	 mov	 rax, QWORD PTR irp$[rsp]
  00053	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1880 : 		}
; 1881 : 		else

  0005b	e9 83 00 00 00	 jmp	 $LN3@GetDecoySy
$LN4@GetDecoySy:

; 1882 : 		{
; 1883 : 			wipeStatus->WipeInProgress = DecoySystemWipeInProgress;

  00060	48 8b 4c 24 20	 mov	 rcx, QWORD PTR wipeStatus$30538[rsp]
  00065	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR DecoySystemWipeInProgress
  0006b	89 01		 mov	 DWORD PTR [rcx], eax

; 1884 : 			wipeStatus->WipeAlgorithm = WipeDecoyRequest.WipeAlgorithm;

  0006d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR wipeStatus$30538[rsp]
  00072	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR WipeDecoyRequest
  00078	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 1885 : 
; 1886 : 			if (DecoySystemWipeInProgress)

  0007b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR DecoySystemWipeInProgress
  00081	85 c0		 test	 eax, eax
  00083	74 35		 je	 SHORT $LN2@GetDecoySy

; 1887 : 			{
; 1888 : 				KIRQL irql;
; 1889 : 				KeAcquireSpinLock (&DecoySystemWipeStatusSpinLock, &irql);

  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:DecoySystemWipeStatusSpinLock
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeAcquireSpinLockRaiseToDpc
  00092	88 44 24 28	 mov	 BYTE PTR irql$30544[rsp], al

; 1890 : 				wipeStatus->WipedAreaEnd = DecoySystemWipedAreaEnd;

  00096	48 8b 4c 24 20	 mov	 rcx, QWORD PTR wipeStatus$30538[rsp]
  0009b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR DecoySystemWipedAreaEnd
  000a2	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1891 : 				KeReleaseSpinLock (&DecoySystemWipeStatusSpinLock, irql);

  000a6	0f b6 54 24 28	 movzx	 edx, BYTE PTR irql$30544[rsp]
  000ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:DecoySystemWipeStatusSpinLock
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseSpinLock

; 1892 : 			}
; 1893 : 			else

  000b8	eb 10		 jmp	 SHORT $LN1@GetDecoySy
$LN2@GetDecoySy:

; 1894 : 				wipeStatus->WipedAreaEnd = DecoySystemWipedAreaEnd;

  000ba	48 8b 4c 24 20	 mov	 rcx, QWORD PTR wipeStatus$30538[rsp]
  000bf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR DecoySystemWipedAreaEnd
  000c6	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
$LN1@GetDecoySy:

; 1895 : 			
; 1896 : 			irp->IoStatus.Information = sizeof (DecoySystemWipeStatus);

  000ca	48 8b 44 24 40	 mov	 rax, QWORD PTR irp$[rsp]
  000cf	48 c7 40 38 10
	00 00 00	 mov	 QWORD PTR [rax+56], 16

; 1897 : 			irp->IoStatus.Status = STATUS_SUCCESS;

  000d7	48 8b 44 24 40	 mov	 rax, QWORD PTR irp$[rsp]
  000dc	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0
$LN3@GetDecoySy:
$LN5@GetDecoySy:

; 1898 : 		}
; 1899 : 	}
; 1900 : }

  000e3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e7	c3		 ret	 0
GetDecoySystemWipeStatus ENDP
_TEXT	ENDS
PUBLIC	GetBootLoaderVersion
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetBootLoaderVersion DD imagerel $LN6
	DD	imagerel $LN6+124
	DD	imagerel $unwind$GetBootLoaderVersion
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetBootLoaderVersion DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GetBootLoaderVersion
_TEXT	SEGMENT
irp$ = 48
irpSp$ = 56
GetBootLoaderVersion PROC				; COMDAT

; 1603 : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1604 : 	if (ValidateIOBufferSize (irp, sizeof (uint16), ValidateOutput))

  0000e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00014	ba 02 00 00 00	 mov	 edx, 2
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR irp$[rsp]
  0001e	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00023	85 c0		 test	 eax, eax
  00025	74 50		 je	 SHORT $LN3@GetBootLoa

; 1605 : 	{
; 1606 : 		if (BootArgsValid)

  00027	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR BootArgsValid, 0
  0002e	74 2e		 je	 SHORT $LN2@GetBootLoa

; 1607 : 		{
; 1608 : 			*(uint16 *) irp->AssociatedIrp.SystemBuffer = BootArgs.BootLoaderVersion;

  00030	48 8b 4c 24 30	 mov	 rcx, QWORD PTR irp$[rsp]
  00035	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00039	0f b7 05 08 00
	00 00		 movzx	 eax, WORD PTR BootArgs+8
  00040	66 89 01	 mov	 WORD PTR [rcx], ax

; 1609 : 			irp->IoStatus.Information = sizeof (uint16);

  00043	48 8b 44 24 30	 mov	 rax, QWORD PTR irp$[rsp]
  00048	48 c7 40 38 02
	00 00 00	 mov	 QWORD PTR [rax+56], 2

; 1610 : 			irp->IoStatus.Status = STATUS_SUCCESS;

  00050	48 8b 44 24 30	 mov	 rax, QWORD PTR irp$[rsp]
  00055	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 1611 : 		}
; 1612 : 		else

  0005c	eb 19		 jmp	 SHORT $LN1@GetBootLoa
$LN2@GetBootLoa:

; 1613 : 		{
; 1614 : 			irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  0005e	48 8b 44 24 30	 mov	 rax, QWORD PTR irp$[rsp]
  00063	c7 40 30 0d 00
	00 c0		 mov	 DWORD PTR [rax+48], -1073741811 ; ffffffffc000000dH

; 1615 : 			irp->IoStatus.Information = 0;

  0006a	48 8b 44 24 30	 mov	 rax, QWORD PTR irp$[rsp]
  0006f	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0
$LN1@GetBootLoa:
$LN3@GetBootLoa:

; 1616 : 		}
; 1617 : 	}
; 1618 : }

  00077	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007b	c3		 ret	 0
GetBootLoaderVersion ENDP
_TEXT	ENDS
PUBLIC	GetBootEncryptionStatus
	ALIGN	8

SetupStatusEncryptedAreaEnd DQ 01H DUP (?)
SetupStatusSpinLock DQ 01H DUP (?)
TransformWaitingForIdle DD 01H DUP (?)
SetupRequest DB	010H DUP (?)
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetBootEncryptionStatus DD imagerel $LN13
	DD	imagerel $LN13+601
	DD	imagerel $unwind$GetBootEncryptionStatus
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetBootEncryptionStatus DD 020f01H
	DD	0700b720fH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GetBootEncryptionStatus
_TEXT	SEGMENT
Extension$30379 = 32
bootEncStatus$30380 = 40
irql$30387 = 48
tv95 = 52
irp$ = 80
irpSp$ = 88
GetBootEncryptionStatus PROC				; COMDAT

; 1542 : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1543 : 	/* IMPORTANT: Do NOT add any potentially time-consuming operations to this function. */
; 1544 : 
; 1545 : 	if (ValidateIOBufferSize (irp, sizeof (BootEncryptionStatus), ValidateOutput))

  0000f	41 b8 01 00 00
	00		 mov	 r8d, 1
  00015	ba 5e 00 00 00	 mov	 edx, 94			; 0000005eH
  0001a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR irp$[rsp]
  0001f	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00024	85 c0		 test	 eax, eax
  00026	0f 84 27 02 00
	00		 je	 $LN8@GetBootEnc

; 1546 : 	{
; 1547 : 		DriveFilterExtension *Extension = BootDriveFilterExtension;

  0002c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00033	48 89 44 24 20	 mov	 QWORD PTR Extension$30379[rsp], rax

; 1548 : 		BootEncryptionStatus *bootEncStatus = (BootEncryptionStatus *) irp->AssociatedIrp.SystemBuffer;

  00038	48 8b 44 24 50	 mov	 rax, QWORD PTR irp$[rsp]
  0003d	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00041	48 89 44 24 28	 mov	 QWORD PTR bootEncStatus$30380[rsp], rax

; 1549 : 		memset (bootEncStatus, 0, sizeof (*bootEncStatus));

  00046	48 8b 7c 24 28	 mov	 rdi, QWORD PTR bootEncStatus$30380[rsp]
  0004b	33 c0		 xor	 eax, eax
  0004d	b9 5e 00 00 00	 mov	 ecx, 94			; 0000005eH
  00052	f3 aa		 rep stosb

; 1550 : 
; 1551 : 		if (BootArgsValid)

  00054	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR BootArgsValid, 0
  0005b	74 10		 je	 SHORT $LN7@GetBootEnc

; 1552 : 			bootEncStatus->BootLoaderVersion = BootArgs.BootLoaderVersion;

  0005d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bootEncStatus$30380[rsp]
  00062	0f b7 05 08 00
	00 00		 movzx	 eax, WORD PTR BootArgs+8
  00069	66 89 41 04	 mov	 WORD PTR [rcx+4], ax
$LN7@GetBootEnc:

; 1553 : 
; 1554 : 		bootEncStatus->DeviceFilterActive = DeviceFilterActive;

  0006d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bootEncStatus$30380[rsp]
  00072	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR DeviceFilterActive
  00078	89 01		 mov	 DWORD PTR [rcx], eax

; 1555 : 		bootEncStatus->SetupInProgress = SetupInProgress;

  0007a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bootEncStatus$30380[rsp]
  0007f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR SetupInProgress
  00085	89 41 3e	 mov	 DWORD PTR [rcx+62], eax

; 1556 : 		bootEncStatus->SetupMode = SetupRequest.SetupMode;

  00088	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bootEncStatus$30380[rsp]
  0008d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR SetupRequest
  00093	89 41 42	 mov	 DWORD PTR [rcx+66], eax

; 1557 : 		bootEncStatus->TransformWaitingForIdle = TransformWaitingForIdle;

  00096	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bootEncStatus$30380[rsp]
  0009b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR TransformWaitingForIdle
  000a1	89 41 46	 mov	 DWORD PTR [rcx+70], eax

; 1558 : 
; 1559 : 		if (!BootDriveFound || !Extension || !Extension->DriveMounted)

  000a4	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR BootDriveFound
  000aa	85 c0		 test	 eax, eax
  000ac	74 16		 je	 SHORT $LN5@GetBootEnc
  000ae	48 83 7c 24 20
	00		 cmp	 QWORD PTR Extension$30379[rsp], 0
  000b4	74 0e		 je	 SHORT $LN5@GetBootEnc
  000b6	48 8b 44 24 20	 mov	 rax, QWORD PTR Extension$30379[rsp]
  000bb	83 b8 10 03 00
	00 00		 cmp	 DWORD PTR [rax+784], 0
  000c2	75 29		 jne	 SHORT $LN6@GetBootEnc
$LN5@GetBootEnc:

; 1560 : 		{
; 1561 : 			bootEncStatus->DriveEncrypted = FALSE;

  000c4	48 8b 44 24 28	 mov	 rax, QWORD PTR bootEncStatus$30380[rsp]
  000c9	c7 40 0e 00 00
	00 00		 mov	 DWORD PTR [rax+14], 0

; 1562 : 			bootEncStatus->DriveMounted = FALSE;

  000d0	48 8b 44 24 28	 mov	 rax, QWORD PTR bootEncStatus$30380[rsp]
  000d5	c7 40 06 00 00
	00 00		 mov	 DWORD PTR [rax+6], 0

; 1563 : 			bootEncStatus->VolumeHeaderPresent = FALSE;

  000dc	48 8b 44 24 28	 mov	 rax, QWORD PTR bootEncStatus$30380[rsp]
  000e1	c7 40 0a 00 00
	00 00		 mov	 DWORD PTR [rax+10], 0

; 1564 : 		}
; 1565 : 		else

  000e8	e9 4d 01 00 00	 jmp	 $LN4@GetBootEnc
$LN6@GetBootEnc:

; 1566 : 		{
; 1567 : 			bootEncStatus->DriveMounted = Extension->DriveMounted;

  000ed	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bootEncStatus$30380[rsp]
  000f2	48 8b 44 24 20	 mov	 rax, QWORD PTR Extension$30379[rsp]
  000f7	8b 80 10 03 00
	00		 mov	 eax, DWORD PTR [rax+784]
  000fd	89 41 06	 mov	 DWORD PTR [rcx+6], eax

; 1568 : 			bootEncStatus->VolumeHeaderPresent = Extension->VolumeHeaderPresent;

  00100	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bootEncStatus$30380[rsp]
  00105	48 8b 44 24 20	 mov	 rax, QWORD PTR Extension$30379[rsp]
  0010a	8b 80 0c 03 00
	00		 mov	 eax, DWORD PTR [rax+780]
  00110	89 41 0a	 mov	 DWORD PTR [rcx+10], eax

; 1569 : 			bootEncStatus->DriveEncrypted = Extension->Queue.EncryptedAreaStart != -1;

  00113	48 8b 44 24 20	 mov	 rax, QWORD PTR Extension$30379[rsp]
  00118	48 83 b8 c8 00
	00 00 ff	 cmp	 QWORD PTR [rax+200], -1
  00120	74 0a		 je	 SHORT $LN11@GetBootEnc
  00122	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv95[rsp], 1
  0012a	eb 08		 jmp	 SHORT $LN12@GetBootEnc
$LN11@GetBootEnc:
  0012c	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv95[rsp], 0
$LN12@GetBootEnc:
  00134	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bootEncStatus$30380[rsp]
  00139	8b 44 24 34	 mov	 eax, DWORD PTR tv95[rsp]
  0013d	89 41 0e	 mov	 DWORD PTR [rcx+14], eax

; 1570 : 			bootEncStatus->BootDriveLength = BootDriveLength;

  00140	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bootEncStatus$30380[rsp]
  00145	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveLength
  0014c	48 89 41 12	 mov	 QWORD PTR [rcx+18], rax

; 1571 : 
; 1572 : 			bootEncStatus->ConfiguredEncryptedAreaStart = Extension->ConfiguredEncryptedAreaStart;

  00150	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bootEncStatus$30380[rsp]
  00155	48 8b 44 24 20	 mov	 rax, QWORD PTR Extension$30379[rsp]
  0015a	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0015e	48 89 41 1a	 mov	 QWORD PTR [rcx+26], rax

; 1573 : 			bootEncStatus->ConfiguredEncryptedAreaEnd = Extension->ConfiguredEncryptedAreaEnd;

  00162	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bootEncStatus$30380[rsp]
  00167	48 8b 44 24 20	 mov	 rax, QWORD PTR Extension$30379[rsp]
  0016c	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00170	48 89 41 22	 mov	 QWORD PTR [rcx+34], rax

; 1574 : 			bootEncStatus->EncryptedAreaStart = Extension->Queue.EncryptedAreaStart;

  00174	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bootEncStatus$30380[rsp]
  00179	48 8b 44 24 20	 mov	 rax, QWORD PTR Extension$30379[rsp]
  0017e	48 8b 80 c8 00
	00 00		 mov	 rax, QWORD PTR [rax+200]
  00185	48 89 41 2a	 mov	 QWORD PTR [rcx+42], rax

; 1575 : 
; 1576 : 			if (SetupInProgress)

  00189	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR SetupInProgress
  0018f	85 c0		 test	 eax, eax
  00191	74 35		 je	 SHORT $LN3@GetBootEnc

; 1577 : 			{
; 1578 : 				KIRQL irql;
; 1579 : 				KeAcquireSpinLock (&SetupStatusSpinLock, &irql);

  00193	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:SetupStatusSpinLock
  0019a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeAcquireSpinLockRaiseToDpc
  001a0	88 44 24 30	 mov	 BYTE PTR irql$30387[rsp], al

; 1580 : 				bootEncStatus->EncryptedAreaEnd = SetupStatusEncryptedAreaEnd;

  001a4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bootEncStatus$30380[rsp]
  001a9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR SetupStatusEncryptedAreaEnd
  001b0	48 89 41 32	 mov	 QWORD PTR [rcx+50], rax

; 1581 : 				KeReleaseSpinLock (&SetupStatusSpinLock, irql);

  001b4	0f b6 54 24 30	 movzx	 edx, BYTE PTR irql$30387[rsp]
  001b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:SetupStatusSpinLock
  001c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseSpinLock

; 1582 : 			}
; 1583 : 			else

  001c6	eb 15		 jmp	 SHORT $LN2@GetBootEnc
$LN3@GetBootEnc:

; 1584 : 				bootEncStatus->EncryptedAreaEnd = Extension->Queue.EncryptedAreaEnd;

  001c8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bootEncStatus$30380[rsp]
  001cd	48 8b 44 24 20	 mov	 rax, QWORD PTR Extension$30379[rsp]
  001d2	48 8b 80 d0 00
	00 00		 mov	 rax, QWORD PTR [rax+208]
  001d9	48 89 41 32	 mov	 QWORD PTR [rcx+50], rax
$LN2@GetBootEnc:

; 1585 : 
; 1586 : 			bootEncStatus->VolumeHeaderSaltCrc32 = Extension->VolumeHeaderSaltCrc32;

  001dd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bootEncStatus$30380[rsp]
  001e2	48 8b 44 24 20	 mov	 rax, QWORD PTR Extension$30379[rsp]
  001e7	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  001ea	89 41 3a	 mov	 DWORD PTR [rcx+58], eax

; 1587 : 			bootEncStatus->HibernationPreventionCount = HibernationPreventionCount;

  001ed	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bootEncStatus$30380[rsp]
  001f2	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR HibernationPreventionCount
  001f8	89 41 4a	 mov	 DWORD PTR [rcx+74], eax

; 1588 : 			bootEncStatus->HiddenSysLeakProtectionCount = HiddenSysLeakProtectionCount;

  001fb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bootEncStatus$30380[rsp]
  00200	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR HiddenSysLeakProtectionCount
  00206	89 41 5a	 mov	 DWORD PTR [rcx+90], eax

; 1589 : 
; 1590 : 			bootEncStatus->HiddenSystem = Extension->HiddenSystem;

  00209	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bootEncStatus$30380[rsp]
  0020e	48 8b 44 24 20	 mov	 rax, QWORD PTR Extension$30379[rsp]
  00213	8b 80 38 03 00
	00		 mov	 eax, DWORD PTR [rax+824]
  00219	89 41 4e	 mov	 DWORD PTR [rcx+78], eax

; 1591 : 			
; 1592 : 			if (Extension->HiddenSystem)

  0021c	48 8b 44 24 20	 mov	 rax, QWORD PTR Extension$30379[rsp]
  00221	83 b8 38 03 00
	00 00		 cmp	 DWORD PTR [rax+824], 0
  00228	74 10		 je	 SHORT $LN1@GetBootEnc

; 1593 : 				bootEncStatus->HiddenSystemPartitionStart = BootArgs.HiddenSystemPartitionStart;

  0022a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bootEncStatus$30380[rsp]
  0022f	48 8b 05 5a 00
	00 00		 mov	 rax, QWORD PTR BootArgs+90
  00236	48 89 41 52	 mov	 QWORD PTR [rcx+82], rax
$LN1@GetBootEnc:
$LN4@GetBootEnc:

; 1594 : 		}
; 1595 : 
; 1596 : 		irp->IoStatus.Information = sizeof (BootEncryptionStatus);

  0023a	48 8b 44 24 50	 mov	 rax, QWORD PTR irp$[rsp]
  0023f	48 c7 40 38 5e
	00 00 00	 mov	 QWORD PTR [rax+56], 94	; 0000005eH

; 1597 : 		irp->IoStatus.Status = STATUS_SUCCESS;

  00247	48 8b 44 24 50	 mov	 rax, QWORD PTR irp$[rsp]
  0024c	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0
$LN8@GetBootEnc:

; 1598 : 	}
; 1599 : }

  00253	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00257	5f		 pop	 rdi
  00258	c3		 ret	 0
GetBootEncryptionStatus ENDP
_TEXT	ENDS
PUBLIC	GetBootDriveVolumeProperties
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetBootDriveVolumeProperties DD imagerel $LN9
	DD	imagerel $LN9+451
	DD	imagerel $unwind$GetBootDriveVolumeProperties
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetBootDriveVolumeProperties DD 020f01H
	DD	0700b720fH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GetBootDriveVolumeProperties
_TEXT	SEGMENT
Extension$30363 = 32
prop$30364 = 40
tv137 = 48
irp$ = 80
irpSp$ = 88
GetBootDriveVolumeProperties PROC			; COMDAT

; 1505 : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1506 : 	if (ValidateIOBufferSize (irp, sizeof (VOLUME_PROPERTIES_STRUCT), ValidateOutput))

  0000f	41 b8 01 00 00
	00		 mov	 r8d, 1
  00015	ba 54 02 00 00	 mov	 edx, 596		; 00000254H
  0001a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR irp$[rsp]
  0001f	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00024	85 c0		 test	 eax, eax
  00026	0f 84 91 01 00
	00		 je	 $LN4@GetBootDri

; 1507 : 	{
; 1508 : 		DriveFilterExtension *Extension = BootDriveFilterExtension;

  0002c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00033	48 89 44 24 20	 mov	 QWORD PTR Extension$30363[rsp], rax

; 1509 : 		VOLUME_PROPERTIES_STRUCT *prop = (VOLUME_PROPERTIES_STRUCT *) irp->AssociatedIrp.SystemBuffer;

  00038	48 8b 44 24 50	 mov	 rax, QWORD PTR irp$[rsp]
  0003d	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00041	48 89 44 24 28	 mov	 QWORD PTR prop$30364[rsp], rax

; 1510 : 		memset (prop, 0, sizeof (*prop));

  00046	48 8b 7c 24 28	 mov	 rdi, QWORD PTR prop$30364[rsp]
  0004b	33 c0		 xor	 eax, eax
  0004d	b9 54 02 00 00	 mov	 ecx, 596		; 00000254H
  00052	f3 aa		 rep stosb

; 1511 : 
; 1512 : 		if (!BootDriveFound || !Extension || !Extension->DriveMounted)

  00054	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR BootDriveFound
  0005a	85 c0		 test	 eax, eax
  0005c	74 16		 je	 SHORT $LN2@GetBootDri
  0005e	48 83 7c 24 20
	00		 cmp	 QWORD PTR Extension$30363[rsp], 0
  00064	74 0e		 je	 SHORT $LN2@GetBootDri
  00066	48 8b 44 24 20	 mov	 rax, QWORD PTR Extension$30363[rsp]
  0006b	83 b8 10 03 00
	00 00		 cmp	 DWORD PTR [rax+784], 0
  00072	75 1e		 jne	 SHORT $LN3@GetBootDri
$LN2@GetBootDri:

; 1513 : 		{
; 1514 : 			irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  00074	48 8b 44 24 50	 mov	 rax, QWORD PTR irp$[rsp]
  00079	c7 40 30 0d 00
	00 c0		 mov	 DWORD PTR [rax+48], -1073741811 ; ffffffffc000000dH

; 1515 : 			irp->IoStatus.Information = 0;

  00080	48 8b 44 24 50	 mov	 rax, QWORD PTR irp$[rsp]
  00085	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1516 : 		}
; 1517 : 		else

  0008d	e9 2b 01 00 00	 jmp	 $LN1@GetBootDri
$LN3@GetBootDri:

; 1518 : 		{
; 1519 : 			prop->hiddenVolume = Extension->Queue.CryptoInfo->hiddenVolume;

  00092	48 8b 44 24 20	 mov	 rax, QWORD PTR Extension$30363[rsp]
  00097	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  0009e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR prop$30364[rsp]
  000a3	8b 80 a0 29 00
	00		 mov	 eax, DWORD PTR [rax+10656]
  000a9	89 81 28 02 00
	00		 mov	 DWORD PTR [rcx+552], eax

; 1520 : 			prop->diskLength = Extension->ConfiguredEncryptedAreaEnd + 1 - Extension->ConfiguredEncryptedAreaStart;

  000af	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Extension$30363[rsp]
  000b4	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  000b8	48 83 c1 01	 add	 rcx, 1
  000bc	48 8b 44 24 20	 mov	 rax, QWORD PTR Extension$30363[rsp]
  000c1	48 2b 48 38	 sub	 rcx, QWORD PTR [rax+56]
  000c5	48 8b 44 24 28	 mov	 rax, QWORD PTR prop$30364[rsp]
  000ca	48 89 88 10 02
	00 00		 mov	 QWORD PTR [rax+528], rcx

; 1521 : 			prop->ea = Extension->Queue.CryptoInfo->ea;

  000d1	48 8b 44 24 20	 mov	 rax, QWORD PTR Extension$30363[rsp]
  000d6	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  000dd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR prop$30364[rsp]
  000e2	8b 00		 mov	 eax, DWORD PTR [rax]
  000e4	89 81 18 02 00
	00		 mov	 DWORD PTR [rcx+536], eax

; 1522 : 			prop->mode = Extension->Queue.CryptoInfo->mode;

  000ea	48 8b 44 24 20	 mov	 rax, QWORD PTR Extension$30363[rsp]
  000ef	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  000f6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR prop$30364[rsp]
  000fb	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  000fe	89 81 1c 02 00
	00		 mov	 DWORD PTR [rcx+540], eax

; 1523 : 			prop->pkcs5 = Extension->Queue.CryptoInfo->pkcs5;

  00104	48 8b 44 24 20	 mov	 rax, QWORD PTR Extension$30363[rsp]
  00109	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  00110	48 8b 4c 24 28	 mov	 rcx, QWORD PTR prop$30364[rsp]
  00115	8b 80 ec 43 00
	00		 mov	 eax, DWORD PTR [rax+17388]
  0011b	89 81 20 02 00
	00		 mov	 DWORD PTR [rcx+544], eax

; 1524 : 			prop->pkcs5Iterations = Extension->Queue.CryptoInfo->noIterations;

  00121	48 8b 44 24 20	 mov	 rax, QWORD PTR Extension$30363[rsp]
  00126	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  0012d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR prop$30364[rsp]
  00132	8b 80 e8 43 00
	00		 mov	 eax, DWORD PTR [rax+17384]
  00138	89 81 24 02 00
	00		 mov	 DWORD PTR [rcx+548], eax

; 1525 : #if 0
; 1526 : 			prop->volumeCreationTime = Extension->Queue.CryptoInfo->volume_creation_time;
; 1527 : 			prop->headerCreationTime = Extension->Queue.CryptoInfo->header_creation_time;
; 1528 : #endif
; 1529 : 			prop->volFormatVersion = Extension->Queue.CryptoInfo->LegacyVolume ? TC_VOLUME_FORMAT_VERSION_PRE_6_0 : TC_VOLUME_FORMAT_VERSION;

  0013e	48 8b 44 24 20	 mov	 rax, QWORD PTR Extension$30363[rsp]
  00143	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  0014a	83 b8 3c 44 00
	00 00		 cmp	 DWORD PTR [rax+17468], 0
  00151	74 0a		 je	 SHORT $LN7@GetBootDri
  00153	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv137[rsp], 1
  0015b	eb 08		 jmp	 SHORT $LN8@GetBootDri
$LN7@GetBootDri:
  0015d	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv137[rsp], 2
$LN8@GetBootDri:
  00165	48 8b 4c 24 28	 mov	 rcx, QWORD PTR prop$30364[rsp]
  0016a	8b 44 24 30	 mov	 eax, DWORD PTR tv137[rsp]
  0016e	89 81 50 02 00
	00		 mov	 DWORD PTR [rcx+592], eax

; 1530 : 
; 1531 : 			prop->totalBytesRead = Extension->Queue.TotalBytesRead;

  00174	48 8b 4c 24 28	 mov	 rcx, QWORD PTR prop$30364[rsp]
  00179	48 8b 44 24 20	 mov	 rax, QWORD PTR Extension$30363[rsp]
  0017e	48 8b 80 c8 02
	00 00		 mov	 rax, QWORD PTR [rax+712]
  00185	48 89 81 3c 02
	00 00		 mov	 QWORD PTR [rcx+572], rax

; 1532 : 			prop->totalBytesWritten = Extension->Queue.TotalBytesWritten;

  0018c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR prop$30364[rsp]
  00191	48 8b 44 24 20	 mov	 rax, QWORD PTR Extension$30363[rsp]
  00196	48 8b 80 d0 02
	00 00		 mov	 rax, QWORD PTR [rax+720]
  0019d	48 89 81 44 02
	00 00		 mov	 QWORD PTR [rcx+580], rax

; 1533 : 
; 1534 : 			irp->IoStatus.Information = sizeof (VOLUME_PROPERTIES_STRUCT);

  001a4	48 8b 44 24 50	 mov	 rax, QWORD PTR irp$[rsp]
  001a9	48 c7 40 38 54
	02 00 00	 mov	 QWORD PTR [rax+56], 596	; 00000254H

; 1535 : 			irp->IoStatus.Status = STATUS_SUCCESS;

  001b1	48 8b 44 24 50	 mov	 rax, QWORD PTR irp$[rsp]
  001b6	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0
$LN1@GetBootDri:
$LN4@GetBootDri:

; 1536 : 		}
; 1537 : 	}
; 1538 : }

  001bd	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001c1	5f		 pop	 rdi
  001c2	c3		 ret	 0
GetBootDriveVolumeProperties ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DispatchPower DD imagerel DispatchPower
	DD	imagerel DispatchPower+306
	DD	imagerel $unwind$DispatchPower
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DispatchPower DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DispatchPower
_TEXT	SEGMENT
status$ = 48
DeviceObject$ = 80
Irp$ = 88
Extension$ = 96
irpSp$ = 104
DispatchPower PROC					; COMDAT

; 671  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 672  : 	NTSTATUS status;
; 673  : 	Dump ("IRP_MJ_POWER minor=%d type=%d shutdown=%d\n", (int) irpSp->MinorFunction, (int) irpSp->Parameters.Power.Type, (int) irpSp->Parameters.Power.ShutdownType);

  00018	48 8b 44 24 68	 mov	 rax, QWORD PTR irpSp$[rsp]
  0001d	0f b6 50 01	 movzx	 edx, BYTE PTR [rax+1]
  00021	48 8b 44 24 68	 mov	 rax, QWORD PTR irpSp$[rsp]
  00026	44 8b 48 20	 mov	 r9d, DWORD PTR [rax+32]
  0002a	48 8b 44 24 68	 mov	 rax, QWORD PTR irpSp$[rsp]
  0002f	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CL@JHMIFAKG@IRP_MJ_POWER?5minor?$DN?$CFd?5type?$DN?$CFd?5sh@FNODOBFM@
  0003a	e8 00 00 00 00	 call	 DbgPrint

; 674  : 
; 675  : 	if (SetupInProgress
; 676  : 		&& irpSp->MinorFunction == IRP_MN_SET_POWER
; 677  : 		&& irpSp->Parameters.Power.ShutdownType == PowerActionHibernate)

  0003f	44 8b 1d 00 00
	00 00		 mov	 r11d, DWORD PTR SetupInProgress
  00046	45 85 db	 test	 r11d, r11d
  00049	74 4a		 je	 SHORT $LN4@DispatchPo@2
  0004b	48 8b 44 24 68	 mov	 rax, QWORD PTR irpSp$[rsp]
  00050	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00054	83 f8 02	 cmp	 eax, 2
  00057	75 3c		 jne	 SHORT $LN4@DispatchPo@2
  00059	48 8b 44 24 68	 mov	 rax, QWORD PTR irpSp$[rsp]
  0005e	83 78 20 03	 cmp	 DWORD PTR [rax+32], 3
  00062	75 31		 jne	 SHORT $LN4@DispatchPo@2
$LN3@DispatchPo@2:

; 678  : 	{
; 679  : 		while (SendDeviceIoControlRequest (RootDeviceObject, TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP, NULL, 0, NULL, 0) == STATUS_INSUFFICIENT_RESOURCES);

  00064	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0006c	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00075	45 33 c9	 xor	 r9d, r9d
  00078	45 33 c0	 xor	 r8d, r8d
  0007b	ba 50 20 22 00	 mov	 edx, 2236496		; 00222050H
  00080	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR RootDeviceObject
  00087	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  0008c	3d 9a 00 00 c0	 cmp	 eax, -1073741670	; ffffffffc000009aH
  00091	75 02		 jne	 SHORT $LN2@DispatchPo@2
  00093	eb cf		 jmp	 SHORT $LN3@DispatchPo@2
$LN2@DispatchPo@2:
$LN4@DispatchPo@2:

; 680  : 	}
; 681  : 
; 682  : #if 0	// Dismount of the system drive is disabled until there is a way to do it without causing system errors (see the documentation for more info)
; 683  : 	if (DriverShuttingDown
; 684  : 		&& Extension->BootDrive
; 685  : 		&& Extension->DriveMounted
; 686  : 		&& irpSp->MinorFunction == IRP_MN_SET_POWER
; 687  : 		&& irpSp->Parameters.Power.Type == DevicePowerState)
; 688  : 	{
; 689  : 		DismountDrive (Extension, TRUE);
; 690  : 	}
; 691  : #endif // 0
; 692  : 
; 693  : 	PoStartNextPowerIrp (Irp);

  00095	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Irp$[rsp]
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PoStartNextPowerIrp

; 694  : 
; 695  : 	status = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  000a0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR Extension$[rsp]
  000a5	48 81 c1 f0 00
	00 00		 add	 rcx, 240		; 000000f0H
  000ac	c7 44 24 20 78
	00 00 00	 mov	 DWORD PTR [rsp+32], 120	; 00000078H
  000b4	41 b9 b7 02 00
	00		 mov	 r9d, 695		; 000002b7H
  000ba	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0EF@GDHJGIB@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  000c1	48 8b 54 24 58	 mov	 rdx, QWORD PTR Irp$[rsp]
  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAcquireRemoveLockEx
  000cc	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax

; 696  : 	if (!NT_SUCCESS (status))

  000d0	83 7c 24 30 00	 cmp	 DWORD PTR status$[rsp], 0
  000d5	7d 13		 jge	 SHORT $LN1@DispatchPo@2

; 697  : 		return TCCompleteIrp (Irp, status, 0);

  000d7	45 33 c0	 xor	 r8d, r8d
  000da	8b 54 24 30	 mov	 edx, DWORD PTR status$[rsp]
  000de	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Irp$[rsp]
  000e3	e8 00 00 00 00	 call	 TCCompleteIrp
  000e8	eb 43		 jmp	 SHORT $LN5@DispatchPo@2
$LN1@DispatchPo@2:

; 698  : 
; 699  : 	IoSkipCurrentIrpStackLocation (Irp);

  000ea	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Irp$[rsp]
  000ef	e8 00 00 00 00	 call	 IoSkipCurrentIrpStackLocation

; 700  : 	status = PoCallDriver (Extension->LowerDeviceObject, Irp);

  000f4	48 8b 54 24 58	 mov	 rdx, QWORD PTR Irp$[rsp]
  000f9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR Extension$[rsp]
  000fe	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00102	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PoCallDriver
  00108	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax

; 701  : 
; 702  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  0010c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR Extension$[rsp]
  00111	48 81 c1 f0 00
	00 00		 add	 rcx, 240		; 000000f0H
  00118	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  0011e	48 8b 54 24 58	 mov	 rdx, QWORD PTR Irp$[rsp]
  00123	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 703  : 	return status;

  00129	8b 44 24 30	 mov	 eax, DWORD PTR status$[rsp]
$LN5@DispatchPo@2:

; 704  : }

  0012d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00131	c3		 ret	 0
DispatchPower ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT pdata
pdata	SEGMENT
$pdata$IsVolumeDevice DD imagerel IsVolumeDevice
	DD	imagerel IsVolumeDevice+399
	DD	imagerel $unwind$IsVolumeDevice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IsVolumeDevice DD 021e19H
	DD	017010cH
	DD	imagerel __GSHandlerCheck
	DD	0a8H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT IsVolumeDevice
_TEXT	SEGMENT
extentStatus$ = 48
extents$ = 64
volNumber$ = 136
tv146 = 160
__$ArrayPad$ = 168
deviceObject$ = 192
IsVolumeDevice PROC					; COMDAT

; 510  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 511  : 	VOLUME_NUMBER volNumber;
; 512  : 	VOLUME_DISK_EXTENTS extents[2];
; 513  : 	NTSTATUS extentStatus = SendDeviceIoControlRequest (deviceObject, IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS, NULL, 0, extents, sizeof (extents));

  0001e	c7 44 24 28 40
	00 00 00	 mov	 DWORD PTR [rsp+40], 64	; 00000040H
  00026	48 8d 44 24 40	 lea	 rax, QWORD PTR extents$[rsp]
  0002b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00030	45 33 c9	 xor	 r9d, r9d
  00033	45 33 c0	 xor	 r8d, r8d
  00036	ba 00 00 56 00	 mov	 edx, 5636096		; 00560000H
  0003b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  00043	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  00048	89 44 24 30	 mov	 DWORD PTR extentStatus$[rsp], eax

; 514  : 
; 515  : 	return NT_SUCCESS (SendDeviceIoControlRequest (deviceObject, IOCTL_VOLUME_SUPPORTS_ONLINE_OFFLINE, NULL, 0,  NULL, 0))
; 516  : 		|| NT_SUCCESS (SendDeviceIoControlRequest (deviceObject, IOCTL_VOLUME_IS_OFFLINE, NULL, 0,  NULL, 0))
; 517  : 		|| NT_SUCCESS (SendDeviceIoControlRequest (deviceObject, IOCTL_VOLUME_IS_IO_CAPABLE, NULL, 0,  NULL, 0))
; 518  : 		|| NT_SUCCESS (SendDeviceIoControlRequest (deviceObject, IOCTL_VOLUME_IS_PARTITION, NULL, 0,  NULL, 0))
; 519  : 		|| NT_SUCCESS (SendDeviceIoControlRequest (deviceObject, IOCTL_VOLUME_QUERY_VOLUME_NUMBER, NULL, 0, &volNumber, sizeof (volNumber)))
; 520  : 		|| NT_SUCCESS (extentStatus) || extentStatus == STATUS_BUFFER_OVERFLOW || extentStatus == STATUS_BUFFER_TOO_SMALL;

  0004c	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00054	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0005d	45 33 c9	 xor	 r9d, r9d
  00060	45 33 c0	 xor	 r8d, r8d
  00063	ba 04 00 56 00	 mov	 edx, 5636100		; 00560004H
  00068	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  00070	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  00075	85 c0		 test	 eax, eax
  00077	0f 8d e8 00 00
	00		 jge	 $LN3@IsVolumeDe
  0007d	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00085	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0008e	45 33 c9	 xor	 r9d, r9d
  00091	45 33 c0	 xor	 r8d, r8d
  00094	ba 10 00 56 00	 mov	 edx, 5636112		; 00560010H
  00099	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  000a1	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  000a6	85 c0		 test	 eax, eax
  000a8	0f 8d b7 00 00
	00		 jge	 $LN3@IsVolumeDe
  000ae	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  000b6	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000bf	45 33 c9	 xor	 r9d, r9d
  000c2	45 33 c0	 xor	 r8d, r8d
  000c5	ba 14 00 56 00	 mov	 edx, 5636116		; 00560014H
  000ca	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  000d2	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  000d7	85 c0		 test	 eax, eax
  000d9	0f 8d 86 00 00
	00		 jge	 $LN3@IsVolumeDe
  000df	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  000e7	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000f0	45 33 c9	 xor	 r9d, r9d
  000f3	45 33 c0	 xor	 r8d, r8d
  000f6	ba 28 00 56 00	 mov	 edx, 5636136		; 00560028H
  000fb	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  00103	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  00108	85 c0		 test	 eax, eax
  0010a	7d 59		 jge	 SHORT $LN3@IsVolumeDe
  0010c	c7 44 24 28 14
	00 00 00	 mov	 DWORD PTR [rsp+40], 20
  00114	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR volNumber$[rsp]
  0011c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00121	45 33 c9	 xor	 r9d, r9d
  00124	45 33 c0	 xor	 r8d, r8d
  00127	ba 1c 00 56 00	 mov	 edx, 5636124		; 0056001cH
  0012c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  00134	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  00139	85 c0		 test	 eax, eax
  0013b	7d 28		 jge	 SHORT $LN3@IsVolumeDe
  0013d	83 7c 24 30 00	 cmp	 DWORD PTR extentStatus$[rsp], 0
  00142	7d 21		 jge	 SHORT $LN3@IsVolumeDe
  00144	81 7c 24 30 05
	00 00 80	 cmp	 DWORD PTR extentStatus$[rsp], -2147483643 ; ffffffff80000005H
  0014c	74 17		 je	 SHORT $LN3@IsVolumeDe
  0014e	81 7c 24 30 23
	00 00 c0	 cmp	 DWORD PTR extentStatus$[rsp], -1073741789 ; ffffffffc0000023H
  00156	74 0d		 je	 SHORT $LN3@IsVolumeDe
  00158	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv146[rsp], 0
  00163	eb 0b		 jmp	 SHORT $LN4@IsVolumeDe
$LN3@IsVolumeDe:
  00165	c7 84 24 a0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv146[rsp], 1
$LN4@IsVolumeDe:
  00170	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR tv146[rsp]

; 521  : }

  00177	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0017f	48 33 cc	 xor	 rcx, rsp
  00182	e8 00 00 00 00	 call	 __security_check_cookie
  00187	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0018e	c3		 ret	 0
IsVolumeDevice ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PassIrp DD imagerel PassIrp
	DD	imagerel PassIrp+45
	DD	imagerel $unwind$PassIrp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PassIrp DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PassIrp
_TEXT	SEGMENT
deviceObject$ = 48
irp$ = 56
PassIrp	PROC						; COMDAT

; 479  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 480  : 	IoSkipCurrentIrpStackLocation (irp);

  0000e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR irp$[rsp]
  00013	e8 00 00 00 00	 call	 IoSkipCurrentIrpStackLocation

; 481  : 	return IoCallDriver (deviceObject, irp);

  00018	48 8b 54 24 38	 mov	 rdx, QWORD PTR irp$[rsp]
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCallDriver

; 482  : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
PassIrp	ENDP
_TEXT	ENDS
PUBLIC	$T45004
PUBLIC	LoadBootArguments
BootLoaderSegment DW 01H DUP (?)
	ALIGN	4

MountMutex DB	038H DUP (?)
;	COMDAT pdata
pdata	SEGMENT
$pdata$LoadBootArguments DD imagerel $LN14
	DD	imagerel $LN14+874
	DD	imagerel $unwind$LoadBootArguments
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$LoadBootArguments DD 040a01H
	DD	01d010aH
	DD	060027003H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT LoadBootArguments
_TEXT	SEGMENT
bootLoaderSegment$ = 48
mappedBootArgs$ = 56
bootArgsAddr$ = 64
status$ = 72
bootArguments$29506 = 80
$T45004 = 88
tv170 = 208
LoadBootArguments PROC					; COMDAT

; 69   : {

$LN14:
  00000	40 56		 push	 rsi
  00002	57		 push	 rdi
  00003	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H

; 70   : 	NTSTATUS status = STATUS_UNSUCCESSFUL;

  0000a	c7 44 24 48 01
	00 00 c0	 mov	 DWORD PTR status$[rsp], -1073741823 ; ffffffffc0000001H

; 71   : 	PHYSICAL_ADDRESS bootArgsAddr;
; 72   : 	byte *mappedBootArgs;
; 73   : 	uint16 bootLoaderSegment;
; 74   : 
; 75   : 	KeInitializeMutex (&MountMutex, 0);

  00012	33 d2		 xor	 edx, edx
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:MountMutex
  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeMutex

; 76   : 
; 77   : 	for (bootLoaderSegment = TC_BOOT_LOADER_SEGMENT;
; 78   : 		bootLoaderSegment >= TC_BOOT_LOADER_SEGMENT - 64 * 1024 / 16 && status != STATUS_SUCCESS;
; 79   : 		bootLoaderSegment -= 32 * 1024 / 16)

  00021	ba 00 90 00 00	 mov	 edx, 36864		; 00009000H
  00026	66 89 54 24 30	 mov	 WORD PTR bootLoaderSegment$[rsp], dx
  0002b	eb 0f		 jmp	 SHORT $LN9@LoadBootAr
$LN8@LoadBootAr:
  0002d	0f b7 44 24 30	 movzx	 eax, WORD PTR bootLoaderSegment$[rsp]
  00032	2d 00 08 00 00	 sub	 eax, 2048		; 00000800H
  00037	66 89 44 24 30	 mov	 WORD PTR bootLoaderSegment$[rsp], ax
$LN9@LoadBootAr:
  0003c	0f b7 44 24 30	 movzx	 eax, WORD PTR bootLoaderSegment$[rsp]
  00041	3d 00 80 00 00	 cmp	 eax, 32768		; 00008000H
  00046	0f 8c 10 03 00
	00		 jl	 $LN7@LoadBootAr
  0004c	83 7c 24 48 00	 cmp	 DWORD PTR status$[rsp], 0
  00051	0f 84 05 03 00
	00		 je	 $LN7@LoadBootAr

; 80   : 	{
; 81   : 		bootArgsAddr.QuadPart = (bootLoaderSegment << 4) + TC_BOOT_LOADER_ARGS_OFFSET;

  00057	0f b7 44 24 30	 movzx	 eax, WORD PTR bootLoaderSegment$[rsp]
  0005c	c1 e0 04	 shl	 eax, 4
  0005f	83 c0 10	 add	 eax, 16
  00062	48 98		 cdqe
  00064	48 89 44 24 40	 mov	 QWORD PTR bootArgsAddr$[rsp], rax

; 82   : 		Dump ("Checking BootArguments at 0x%x\n", bootArgsAddr.LowPart);

  00069	8b 54 24 40	 mov	 edx, DWORD PTR bootArgsAddr$[rsp]
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@ILBJGGPO@Checking?5BootArguments?5at?50x?$CFx?6?$AA@FNODOBFM@
  00074	e8 00 00 00 00	 call	 DbgPrint

; 83   : 
; 84   : 		mappedBootArgs = MmMapIoSpace (bootArgsAddr, sizeof (BootArguments), MmCached);

  00079	41 b8 01 00 00
	00		 mov	 r8d, 1
  0007f	ba 76 00 00 00	 mov	 edx, 118		; 00000076H
  00084	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bootArgsAddr$[rsp]
  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmMapIoSpace
  0008f	48 89 44 24 38	 mov	 QWORD PTR mappedBootArgs$[rsp], rax

; 85   : 		if (!mappedBootArgs)

  00094	48 83 7c 24 38
	00		 cmp	 QWORD PTR mappedBootArgs$[rsp], 0
  0009a	75 0a		 jne	 SHORT $LN6@LoadBootAr

; 86   : 			return STATUS_INSUFFICIENT_RESOURCES;

  0009c	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  000a1	e9 ba 02 00 00	 jmp	 $LN10@LoadBootAr
$LN6@LoadBootAr:

; 87   : 
; 88   : 		if (TC_IS_BOOT_ARGUMENTS_SIGNATURE (mappedBootArgs))

  000a6	48 8b 44 24 38	 mov	 rax, QWORD PTR mappedBootArgs$[rsp]
  000ab	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ae	83 f8 54	 cmp	 eax, 84			; 00000054H
  000b1	0f 85 90 02 00
	00		 jne	 $LN5@LoadBootAr
  000b7	48 8b 44 24 38	 mov	 rax, QWORD PTR mappedBootArgs$[rsp]
  000bc	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  000c0	83 f8 52	 cmp	 eax, 82			; 00000052H
  000c3	0f 85 7e 02 00
	00		 jne	 $LN5@LoadBootAr
  000c9	48 8b 44 24 38	 mov	 rax, QWORD PTR mappedBootArgs$[rsp]
  000ce	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  000d2	83 f8 55	 cmp	 eax, 85			; 00000055H
  000d5	0f 85 6c 02 00
	00		 jne	 $LN5@LoadBootAr
  000db	48 8b 44 24 38	 mov	 rax, QWORD PTR mappedBootArgs$[rsp]
  000e0	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  000e4	83 f8 45	 cmp	 eax, 69			; 00000045H
  000e7	0f 85 5a 02 00
	00		 jne	 $LN5@LoadBootAr
  000ed	48 8b 44 24 38	 mov	 rax, QWORD PTR mappedBootArgs$[rsp]
  000f2	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  000f6	83 f8 11	 cmp	 eax, 17
  000f9	0f 85 48 02 00
	00		 jne	 $LN5@LoadBootAr
  000ff	48 8b 44 24 38	 mov	 rax, QWORD PTR mappedBootArgs$[rsp]
  00104	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00108	83 f8 23	 cmp	 eax, 35			; 00000023H
  0010b	0f 85 36 02 00
	00		 jne	 $LN5@LoadBootAr
  00111	48 8b 44 24 38	 mov	 rax, QWORD PTR mappedBootArgs$[rsp]
  00116	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  0011a	83 f8 45	 cmp	 eax, 69			; 00000045H
  0011d	0f 85 24 02 00
	00		 jne	 $LN5@LoadBootAr
  00123	48 8b 44 24 38	 mov	 rax, QWORD PTR mappedBootArgs$[rsp]
  00128	0f b6 40 07	 movzx	 eax, BYTE PTR [rax+7]
  0012c	83 f8 66	 cmp	 eax, 102		; 00000066H
  0012f	0f 85 12 02 00
	00		 jne	 $LN5@LoadBootAr

; 89   : 		{
; 90   : 			BootArguments *bootArguments = (BootArguments *) mappedBootArgs;

  00135	48 8b 44 24 38	 mov	 rax, QWORD PTR mappedBootArgs$[rsp]
  0013a	48 89 44 24 50	 mov	 QWORD PTR bootArguments$29506[rsp], rax

; 91   : 			Dump ("BootArguments found at 0x%x\n", bootArgsAddr.LowPart);

  0013f	8b 54 24 40	 mov	 edx, DWORD PTR bootArgsAddr$[rsp]
  00143	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@JFNHMJPM@BootArguments?5found?5at?50x?$CFx?6?$AA@FNODOBFM@
  0014a	e8 00 00 00 00	 call	 DbgPrint

; 92   : 
; 93   : 			DumpMem (mappedBootArgs, sizeof (BootArguments));

  0014f	ba 76 00 00 00	 mov	 edx, 118		; 00000076H
  00154	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mappedBootArgs$[rsp]
  00159	e8 00 00 00 00	 call	 DumpMemory

; 94   : 
; 95   : 			if (bootArguments->BootLoaderVersion == VERSION_NUM
; 96   : 				&& bootArguments->BootArgumentsCrc32 != GetCrc32 ((byte *) bootArguments, (int) ((byte *) &bootArguments->BootArgumentsCrc32 - (byte *) bootArguments)))

  0015e	48 8b 54 24 50	 mov	 rdx, QWORD PTR bootArguments$29506[rsp]
  00163	0f b7 42 08	 movzx	 eax, WORD PTR [rdx+8]
  00167	3d 41 07 00 00	 cmp	 eax, 1857		; 00000741H
  0016c	75 55		 jne	 SHORT $LN4@LoadBootAr
  0016e	48 8b 44 24 50	 mov	 rax, QWORD PTR bootArguments$29506[rsp]
  00173	48 83 c0 72	 add	 rax, 114		; 00000072H
  00177	48 2b 44 24 50	 sub	 rax, QWORD PTR bootArguments$29506[rsp]
  0017c	8b d0		 mov	 edx, eax
  0017e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bootArguments$29506[rsp]
  00183	e8 00 00 00 00	 call	 GetCrc32
  00188	8b d0		 mov	 edx, eax
  0018a	48 8b 44 24 50	 mov	 rax, QWORD PTR bootArguments$29506[rsp]
  0018f	39 50 72	 cmp	 DWORD PTR [rax+114], edx
  00192	74 2f		 je	 SHORT $LN4@LoadBootAr

; 97   : 			{
; 98   : 				Dump ("BootArguments CRC incorrect\n");

  00194	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@NBHIKKLK@BootArguments?5CRC?5incorrect?6?$AA@FNODOBFM@
  0019b	e8 00 00 00 00	 call	 DbgPrint

; 99   : 				TC_BUG_CHECK (STATUS_CRC_ERROR);

  001a0	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  001a9	45 33 c9	 xor	 r9d, r9d
  001ac	49 c7 c0 3f 00
	00 c0		 mov	 r8, -1073741761		; ffffffffc000003fH
  001b3	ba 63 00 00 00	 mov	 edx, 99			; 00000063H
  001b8	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  001bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN4@LoadBootAr:

; 100  : 			}
; 101  : 
; 102  : 			BootLoaderSegment = bootLoaderSegment;

  001c3	0f b7 44 24 30	 movzx	 eax, WORD PTR bootLoaderSegment$[rsp]
  001c8	66 89 05 00 00
	00 00		 mov	 WORD PTR BootLoaderSegment, ax

; 103  : 
; 104  : 			BootArgs = *bootArguments;

  001cf	48 8d 7c 24 58	 lea	 rdi, QWORD PTR $T45004[rsp]
  001d4	48 8b 74 24 50	 mov	 rsi, QWORD PTR bootArguments$29506[rsp]
  001d9	b9 76 00 00 00	 mov	 ecx, 118		; 00000076H
  001de	f3 a4		 rep movsb
  001e0	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:BootArgs
  001e7	48 8d 74 24 58	 lea	 rsi, QWORD PTR $T45004[rsp]
  001ec	b9 76 00 00 00	 mov	 ecx, 118		; 00000076H
  001f1	f3 a4		 rep movsb

; 105  : 			BootArgsValid = TRUE;

  001f3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR BootArgsValid, 1

; 106  : 			memset (bootArguments, 0, sizeof (*bootArguments));

  001fd	48 8b 7c 24 50	 mov	 rdi, QWORD PTR bootArguments$29506[rsp]
  00202	33 c0		 xor	 eax, eax
  00204	b9 76 00 00 00	 mov	 ecx, 118		; 00000076H
  00209	f3 aa		 rep stosb

; 107  : 
; 108  : 			if (BootArgs.BootLoaderVersion < 0x600)

  0020b	0f b7 05 08 00
	00 00		 movzx	 eax, WORD PTR BootArgs+8
  00212	3d 00 06 00 00	 cmp	 eax, 1536		; 00000600H
  00217	7d 16		 jge	 SHORT $LN3@LoadBootAr

; 109  : 			{
; 110  : 				BootArgs.HiddenSystemPartitionStart = 0;

  00219	48 c7 05 5a 00
	00 00 00 00 00
	00		 mov	 QWORD PTR BootArgs+90, 0

; 111  : 				BootArgs.DecoySystemPartitionStart = 0;

  00224	48 c7 05 62 00
	00 00 00 00 00
	00		 mov	 QWORD PTR BootArgs+98, 0
$LN3@LoadBootAr:

; 112  : 			}
; 113  : 
; 114  : 			if (BootArgs.BootLoaderVersion < 0x630)

  0022f	0f b7 05 08 00
	00 00		 movzx	 eax, WORD PTR BootArgs+8
  00236	3d 30 06 00 00	 cmp	 eax, 1584		; 00000630H
  0023b	7d 0a		 jge	 SHORT $LN2@LoadBootAr

; 115  : 				BootArgs.Flags = 0;

  0023d	c7 05 6a 00 00
	00 00 00 00 00	 mov	 DWORD PTR BootArgs+106, 0
$LN2@LoadBootAr:

; 116  : 
; 117  : 			BootDriveSignatureValid = (BootArgs.BootLoaderVersion >= 0x710);

  00247	0f b7 05 08 00
	00 00		 movzx	 eax, WORD PTR BootArgs+8
  0024e	3d 10 07 00 00	 cmp	 eax, 1808		; 00000710H
  00253	7c 0d		 jl	 SHORT $LN12@LoadBootAr
  00255	c7 84 24 d0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv170[rsp], 1
  00260	eb 0b		 jmp	 SHORT $LN13@LoadBootAr
$LN12@LoadBootAr:
  00262	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv170[rsp], 0
$LN13@LoadBootAr:
  0026d	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR tv170[rsp]
  00274	89 05 00 00 00
	00		 mov	 DWORD PTR BootDriveSignatureValid, eax

; 118  : 
; 119  : 			Dump ("BootLoaderVersion = %x\n", (int) BootArgs.BootLoaderVersion);

  0027a	0f b7 15 08 00
	00 00		 movzx	 edx, WORD PTR BootArgs+8
  00281	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@NEHGCDJA@BootLoaderVersion?5?$DN?5?$CFx?6?$AA@FNODOBFM@
  00288	e8 00 00 00 00	 call	 DbgPrint

; 120  : 			Dump ("HeaderSaltCrc32 = %x\n", (int) BootArgs.HeaderSaltCrc32);

  0028d	8b 15 0e 00 00
	00		 mov	 edx, DWORD PTR BootArgs+14
  00293	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@PNJAPAAK@HeaderSaltCrc32?5?$DN?5?$CFx?6?$AA@FNODOBFM@
  0029a	e8 00 00 00 00	 call	 DbgPrint

; 121  : 			Dump ("CryptoInfoOffset = %x\n", (int) BootArgs.CryptoInfoOffset);

  0029f	0f b7 15 0a 00
	00 00		 movzx	 edx, WORD PTR BootArgs+10
  002a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@DOJHKKND@CryptoInfoOffset?5?$DN?5?$CFx?6?$AA@FNODOBFM@
  002ad	e8 00 00 00 00	 call	 DbgPrint

; 122  : 			Dump ("CryptoInfoLength = %d\n", (int) BootArgs.CryptoInfoLength);

  002b2	0f b7 15 0c 00
	00 00		 movzx	 edx, WORD PTR BootArgs+12
  002b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@OFNGPMHI@CryptoInfoLength?5?$DN?5?$CFd?6?$AA@FNODOBFM@
  002c0	e8 00 00 00 00	 call	 DbgPrint

; 123  : 			Dump ("HiddenSystemPartitionStart = %I64u\n", BootArgs.HiddenSystemPartitionStart);

  002c5	48 8b 15 5a 00
	00 00		 mov	 rdx, QWORD PTR BootArgs+90
  002cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@JLLKOMJD@HiddenSystemPartitionStart?5?$DN?5?$CFI6@FNODOBFM@
  002d3	e8 00 00 00 00	 call	 DbgPrint

; 124  : 			Dump ("DecoySystemPartitionStart = %I64u\n", BootArgs.DecoySystemPartitionStart);

  002d8	48 8b 15 62 00
	00 00		 mov	 rdx, QWORD PTR BootArgs+98
  002df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@BAEBNNNN@DecoySystemPartitionStart?5?$DN?5?$CFI64@FNODOBFM@
  002e6	e8 00 00 00 00	 call	 DbgPrint

; 125  : 			Dump ("Flags = %x\n", BootArgs.Flags);

  002eb	8b 15 6a 00 00
	00		 mov	 edx, DWORD PTR BootArgs+106
  002f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@KEDLLGKK@Flags?5?$DN?5?$CFx?6?$AA@FNODOBFM@
  002f8	e8 00 00 00 00	 call	 DbgPrint

; 126  : 			Dump ("BootDriveSignature = %x\n", BootArgs.BootDriveSignature);

  002fd	8b 15 6e 00 00
	00		 mov	 edx, DWORD PTR BootArgs+110
  00303	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@DENLEODJ@BootDriveSignature?5?$DN?5?$CFx?6?$AA@FNODOBFM@
  0030a	e8 00 00 00 00	 call	 DbgPrint

; 127  : 			Dump ("BootArgumentsCrc32 = %x\n", BootArgs.BootArgumentsCrc32);

  0030f	8b 15 72 00 00
	00		 mov	 edx, DWORD PTR BootArgs+114
  00315	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@FBGGCCGI@BootArgumentsCrc32?5?$DN?5?$CFx?6?$AA@FNODOBFM@
  0031c	e8 00 00 00 00	 call	 DbgPrint

; 128  : 
; 129  : 			if (CacheBootPassword && BootArgs.BootPassword.Length > 0)

  00321	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR CacheBootPassword, 0
  00328	74 15		 je	 SHORT $LN1@LoadBootAr
  0032a	83 3d 12 00 00
	00 00		 cmp	 DWORD PTR BootArgs+18, 0
  00331	76 0c		 jbe	 SHORT $LN1@LoadBootAr

; 130  : 				AddPasswordToCache (&BootArgs.BootPassword);

  00333	48 8d 0d 12 00
	00 00		 lea	 rcx, OFFSET FLAT:BootArgs+18
  0033a	e8 00 00 00 00	 call	 AddPasswordToCache
$LN1@LoadBootAr:

; 131  : 
; 132  : 			status = STATUS_SUCCESS;

  0033f	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR status$[rsp], 0
$LN5@LoadBootAr:

; 133  : 		}
; 134  : 
; 135  : 		MmUnmapIoSpace (mappedBootArgs, sizeof (BootArguments));

  00347	ba 76 00 00 00	 mov	 edx, 118		; 00000076H
  0034c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mappedBootArgs$[rsp]
  00351	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmUnmapIoSpace

; 136  : 	}

  00357	e9 d1 fc ff ff	 jmp	 $LN8@LoadBootAr
$LN7@LoadBootAr:

; 137  : 
; 138  : 	return status;

  0035c	8b 44 24 48	 mov	 eax, DWORD PTR status$[rsp]
$LN10@LoadBootAr:
$LN11@LoadBootAr:

; 139  : }

  00360	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  00367	5f		 pop	 rdi
  00368	5e		 pop	 rsi
  00369	c3		 ret	 0
LoadBootArguments ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$IoCopyCurrentIrpStackLocationToNext DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$IoCopyCurrentIrpStackLocationToNext
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IoCopyCurrentIrpStackLocationToNext DD 030b01H
	DD	07007620bH
	DD	06006H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT IoCopyCurrentIrpStackLocationToNext
_TEXT	SEGMENT
nextIrpSp$ = 32
irpSp$ = 40
Irp$ = 80
IoCopyCurrentIrpStackLocationToNext PROC		; COMDAT

; 23912: {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 23913:     PIO_STACK_LOCATION irpSp;
; 23914:     PIO_STACK_LOCATION nextIrpSp;
; 23915:     irpSp = IoGetCurrentIrpStackLocation(Irp);

  0000b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Irp$[rsp]
  00010	e8 00 00 00 00	 call	 IoGetCurrentIrpStackLocation
  00015	48 89 44 24 28	 mov	 QWORD PTR irpSp$[rsp], rax

; 23916:     nextIrpSp = IoGetNextIrpStackLocation(Irp);

  0001a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Irp$[rsp]
  0001f	e8 00 00 00 00	 call	 IoGetNextIrpStackLocation
  00024	48 89 44 24 20	 mov	 QWORD PTR nextIrpSp$[rsp], rax

; 23917:     RtlCopyMemory( nextIrpSp, irpSp, FIELD_OFFSET(IO_STACK_LOCATION, CompletionRoutine));

  00029	48 8b 7c 24 20	 mov	 rdi, QWORD PTR nextIrpSp$[rsp]
  0002e	48 8b 74 24 28	 mov	 rsi, QWORD PTR irpSp$[rsp]
  00033	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00038	f3 a4		 rep movsb

; 23918:     nextIrpSp->Control = 0;

  0003a	48 8b 44 24 20	 mov	 rax, QWORD PTR nextIrpSp$[rsp]
  0003f	c6 40 03 00	 mov	 BYTE PTR [rax+3], 0

; 23919: }

  00043	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00047	5f		 pop	 rdi
  00048	5e		 pop	 rsi
  00049	c3		 ret	 0
IoCopyCurrentIrpStackLocationToNext ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$IoSetCompletionRoutine DD imagerel $LN12
	DD	imagerel $LN12+285
	DD	imagerel $unwind$IoSetCompletionRoutine
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IoSetCompletionRoutine DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT IoSetCompletionRoutine
_TEXT	SEGMENT
irpSp$ = 32
tv72 = 40
tv71 = 44
tv78 = 48
Irp$ = 80
CompletionRoutine$ = 88
Context$ = 96
InvokeOnSuccess$ = 104
InvokeOnError$ = 112
InvokeOnCancel$ = 120
IoSetCompletionRoutine PROC				; COMDAT

; 23820: {

$LN12:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 23821:     PIO_STACK_LOCATION irpSp;
; 23822:     ASSERT( (InvokeOnSuccess || InvokeOnError || InvokeOnCancel) ? (CompletionRoutine != NULL) : TRUE );

  00018	0f b6 44 24 68	 movzx	 eax, BYTE PTR InvokeOnSuccess$[rsp]
  0001d	85 c0		 test	 eax, eax
  0001f	75 1c		 jne	 SHORT $LN6@IoSetCompl
  00021	0f b6 44 24 70	 movzx	 eax, BYTE PTR InvokeOnError$[rsp]
  00026	85 c0		 test	 eax, eax
  00028	75 13		 jne	 SHORT $LN6@IoSetCompl
  0002a	0f b6 44 24 78	 movzx	 eax, BYTE PTR InvokeOnCancel$[rsp]
  0002f	85 c0		 test	 eax, eax
  00031	75 0a		 jne	 SHORT $LN6@IoSetCompl
  00033	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  0003b	eb 22		 jmp	 SHORT $LN9@IoSetCompl
$LN6@IoSetCompl:
  0003d	48 83 7c 24 58
	00		 cmp	 QWORD PTR CompletionRoutine$[rsp], 0
  00043	74 0a		 je	 SHORT $LN7@IoSetCompl
  00045	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv71[rsp], 1
  0004d	eb 08		 jmp	 SHORT $LN8@IoSetCompl
$LN7@IoSetCompl:
  0004f	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
$LN8@IoSetCompl:
  00057	8b 44 24 2c	 mov	 eax, DWORD PTR tv71[rsp]
  0005b	89 44 24 28	 mov	 DWORD PTR tv72[rsp], eax
$LN9@IoSetCompl:
  0005f	83 7c 24 28 00	 cmp	 DWORD PTR tv72[rsp], 0
  00064	75 27		 jne	 SHORT $LN10@IoSetCompl
  00066	45 33 c9	 xor	 r9d, r9d
  00069	41 b8 0e 5d 00
	00		 mov	 r8d, 23822		; 00005d0eH
  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@
  00076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0FK@JAEDPCKJ@?$CIInvokeOnSuccess?5?$HM?$HM?5InvokeOnErro@FNODOBFM@
  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  00083	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
  0008b	eb 08		 jmp	 SHORT $LN11@IoSetCompl
$LN10@IoSetCompl:
  0008d	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv78[rsp], 1
$LN11@IoSetCompl:

; 23823:     irpSp = IoGetNextIrpStackLocation(Irp);

  00095	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Irp$[rsp]
  0009a	e8 00 00 00 00	 call	 IoGetNextIrpStackLocation
  0009f	48 89 44 24 20	 mov	 QWORD PTR irpSp$[rsp], rax

; 23824:     irpSp->CompletionRoutine = CompletionRoutine;

  000a4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR irpSp$[rsp]
  000a9	48 8b 44 24 58	 mov	 rax, QWORD PTR CompletionRoutine$[rsp]
  000ae	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 23825:     irpSp->Context = Context;

  000b2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR irpSp$[rsp]
  000b7	48 8b 44 24 60	 mov	 rax, QWORD PTR Context$[rsp]
  000bc	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax

; 23826:     irpSp->Control = 0;

  000c0	48 8b 44 24 20	 mov	 rax, QWORD PTR irpSp$[rsp]
  000c5	c6 40 03 00	 mov	 BYTE PTR [rax+3], 0

; 23827: 
; 23828:     if (InvokeOnSuccess) {

  000c9	0f b6 44 24 68	 movzx	 eax, BYTE PTR InvokeOnSuccess$[rsp]
  000ce	85 c0		 test	 eax, eax
  000d0	74 09		 je	 SHORT $LN3@IoSetCompl

; 23829:         irpSp->Control = SL_INVOKE_ON_SUCCESS;

  000d2	48 8b 44 24 20	 mov	 rax, QWORD PTR irpSp$[rsp]
  000d7	c6 40 03 40	 mov	 BYTE PTR [rax+3], 64	; 00000040H
$LN3@IoSetCompl:

; 23830:     }
; 23831: 
; 23832:     if (InvokeOnError) {

  000db	0f b6 44 24 70	 movzx	 eax, BYTE PTR InvokeOnError$[rsp]
  000e0	85 c0		 test	 eax, eax
  000e2	74 17		 je	 SHORT $LN2@IoSetCompl

; 23833:         irpSp->Control |= SL_INVOKE_ON_ERROR;

  000e4	48 8b 44 24 20	 mov	 rax, QWORD PTR irpSp$[rsp]
  000e9	0f b6 48 03	 movzx	 ecx, BYTE PTR [rax+3]
  000ed	81 c9 80 00 00
	00		 or	 ecx, 128		; 00000080H
  000f3	48 8b 44 24 20	 mov	 rax, QWORD PTR irpSp$[rsp]
  000f8	88 48 03	 mov	 BYTE PTR [rax+3], cl
$LN2@IoSetCompl:

; 23834:     }
; 23835: 
; 23836:     if (InvokeOnCancel) {

  000fb	0f b6 44 24 78	 movzx	 eax, BYTE PTR InvokeOnCancel$[rsp]
  00100	85 c0		 test	 eax, eax
  00102	74 14		 je	 SHORT $LN1@IoSetCompl

; 23837:         irpSp->Control |= SL_INVOKE_ON_CANCEL;

  00104	48 8b 44 24 20	 mov	 rax, QWORD PTR irpSp$[rsp]
  00109	0f b6 48 03	 movzx	 ecx, BYTE PTR [rax+3]
  0010d	83 c9 20	 or	 ecx, 32			; 00000020H
  00110	48 8b 44 24 20	 mov	 rax, QWORD PTR irpSp$[rsp]
  00115	88 48 03	 mov	 BYTE PTR [rax+3], cl
$LN1@IoSetCompl:

; 23838:     }
; 23839: }

  00118	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0011c	c3		 ret	 0
IoSetCompletionRoutine ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$IoMarkIrpPending DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$IoMarkIrpPending
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IoMarkIrpPending DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT IoMarkIrpPending
_TEXT	SEGMENT
tv67 = 32
Irp$ = 64
IoMarkIrpPending PROC					; COMDAT

; 23667: {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 23668:     IoGetCurrentIrpStackLocation( (Irp) )->Control |= SL_PENDING_RETURNED;

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Irp$[rsp]
  0000e	e8 00 00 00 00	 call	 IoGetCurrentIrpStackLocation
  00013	48 83 c0 03	 add	 rax, 3
  00017	48 89 44 24 20	 mov	 QWORD PTR tv67[rsp], rax
  0001c	48 8b 44 24 20	 mov	 rax, QWORD PTR tv67[rsp]
  00021	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00024	83 c9 01	 or	 ecx, 1
  00027	48 8b 44 24 20	 mov	 rax, QWORD PTR tv67[rsp]
  0002c	88 08		 mov	 BYTE PTR [rax], cl

; 23669: }

  0002e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00032	c3		 ret	 0
IoMarkIrpPending ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PsGetCurrentThread DD imagerel $LN3
	DD	imagerel $LN3+14
	DD	imagerel $unwind$PsGetCurrentThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PsGetCurrentThread DD 010401H
	DD	04204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PsGetCurrentThread
_TEXT	SEGMENT
PsGetCurrentThread PROC					; COMDAT

; 19988: {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 19989: 
; 19990:     return (PETHREAD)KeGetCurrentThread();

  00004	e8 00 00 00 00	 call	 KeGetCurrentThread

; 19991: }

  00009	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0000d	c3		 ret	 0
PsGetCurrentThread ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$KfRaiseIrql DD imagerel $LN6
	DD	imagerel $LN6+72
	DD	imagerel $unwind$KfRaiseIrql
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$KfRaiseIrql DD 010801H
	DD	06208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT KfRaiseIrql
_TEXT	SEGMENT
OldIrql$ = 32
tv74 = 36
NewIrql$ = 64
KfRaiseIrql PROC					; COMDAT

; 13428: {

$LN6:
  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 13429: 
; 13430:     KIRQL OldIrql;
; 13431: 
; 13432:     OldIrql = KeGetCurrentIrql();

  00008	e8 00 00 00 00	 call	 KeGetCurrentIrql
  0000d	88 44 24 20	 mov	 BYTE PTR OldIrql$[rsp], al

; 13433: 
; 13434:     NT_ASSERT(OldIrql <= NewIrql);

  00011	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR OldIrql$[rsp]
  00016	0f b6 44 24 40	 movzx	 eax, BYTE PTR NewIrql$[rsp]
  0001b	3b c8		 cmp	 ecx, eax
  0001d	7e 0f		 jle	 SHORT $LN3@KfRaiseIrq
__annotation$45048:
  0001f	e8 00 00 00 00	 call	 DbgRaiseAssertionFailure
  00024	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
  0002c	eb 08		 jmp	 SHORT $LN4@KfRaiseIrq
$LN3@KfRaiseIrq:
  0002e	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
$LN4@KfRaiseIrq:

; 13435: 
; 13436:     WriteCR8(NewIrql);

  00036	0f b6 44 24 40	 movzx	 eax, BYTE PTR NewIrql$[rsp]
  0003b	44 0f 22 c0	 mov	 cr8, rax

; 13437:     return OldIrql;

  0003f	8a 44 24 20	 mov	 al, BYTE PTR OldIrql$[rsp]

; 13438: }

  00043	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00047	c3		 ret	 0
KfRaiseIrql ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$KeLowerIrql DD imagerel $LN6
	DD	imagerel $LN6+62
	DD	imagerel $unwind$KeLowerIrql
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$KeLowerIrql DD 010801H
	DD	06208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT KeLowerIrql
_TEXT	SEGMENT
tv74 = 32
NewIrql$ = 64
KeLowerIrql PROC					; COMDAT

; 13392: {

$LN6:
  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 13393: 
; 13394:     NT_ASSERT(KeGetCurrentIrql() >= NewIrql);

  00008	e8 00 00 00 00	 call	 KeGetCurrentIrql
  0000d	0f b6 c8	 movzx	 ecx, al
  00010	0f b6 44 24 40	 movzx	 eax, BYTE PTR NewIrql$[rsp]
  00015	3b c8		 cmp	 ecx, eax
  00017	7d 0f		 jge	 SHORT $LN3@KeLowerIrq
__annotation$45058:
  00019	e8 00 00 00 00	 call	 DbgRaiseAssertionFailure
  0001e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
  00026	eb 08		 jmp	 SHORT $LN4@KeLowerIrq
$LN3@KeLowerIrq:
  00028	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
$LN4@KeLowerIrq:

; 13395: 
; 13396:     WriteCR8(NewIrql);

  00030	0f b6 44 24 40	 movzx	 eax, BYTE PTR NewIrql$[rsp]
  00035	44 0f 22 c0	 mov	 cr8, rax

; 13397:     return;
; 13398: }

  00039	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003d	c3		 ret	 0
KeLowerIrql ENDP
PUBLIC	GetBootEncryptionAlgorithmName
;	COMDAT pdata
; File c:\users\public\desktop\projects\ciphershed\src\driver\drivefilter.c
pdata	SEGMENT
$pdata$GetBootEncryptionAlgorithmName DD imagerel $LN6
	DD	imagerel $LN6+162
	DD	imagerel $unwind$GetBootEncryptionAlgorithmName
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetBootEncryptionAlgorithmName DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT GetBootEncryptionAlgorithmName
_TEXT	SEGMENT
request$30413 = 32
irp$ = 64
irpSp$ = 72
GetBootEncryptionAlgorithmName PROC			; COMDAT

; 1622 : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1623 : 	if (ValidateIOBufferSize (irp, sizeof (GetBootEncryptionAlgorithmNameRequest), ValidateOutput))

  0000e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00014	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR irp$[rsp]
  0001e	e8 00 00 00 00	 call	 ValidateIOBufferSize
  00023	85 c0		 test	 eax, eax
  00025	74 76		 je	 SHORT $LN3@GetBootEnc@2

; 1624 : 	{
; 1625 : 		if (BootDriveFilterExtension && BootDriveFilterExtension->DriveMounted)

  00027	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR BootDriveFilterExtension, 0
  0002f	74 53		 je	 SHORT $LN2@GetBootEnc@2
  00031	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00038	83 b8 10 03 00
	00 00		 cmp	 DWORD PTR [rax+784], 0
  0003f	74 43		 je	 SHORT $LN2@GetBootEnc@2

; 1626 : 		{
; 1627 : 			GetBootEncryptionAlgorithmNameRequest *request = (GetBootEncryptionAlgorithmNameRequest *) irp->AssociatedIrp.SystemBuffer;

  00041	48 8b 44 24 40	 mov	 rax, QWORD PTR irp$[rsp]
  00046	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0004a	48 89 44 24 20	 mov	 QWORD PTR request$30413[rsp], rax

; 1628 : 			EAGetName (request->BootEncryptionAlgorithmName, BootDriveFilterExtension->Queue.CryptoInfo->ea);

  0004f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00056	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  0005d	8b 10		 mov	 edx, DWORD PTR [rax]
  0005f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR request$30413[rsp]
  00064	e8 00 00 00 00	 call	 EAGetName

; 1629 : 
; 1630 : 			irp->IoStatus.Information = sizeof (GetBootEncryptionAlgorithmNameRequest);

  00069	4c 8b 5c 24 40	 mov	 r11, QWORD PTR irp$[rsp]
  0006e	49 c7 43 38 00
	01 00 00	 mov	 QWORD PTR [r11+56], 256	; 00000100H

; 1631 : 			irp->IoStatus.Status = STATUS_SUCCESS;

  00076	48 8b 44 24 40	 mov	 rax, QWORD PTR irp$[rsp]
  0007b	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 1632 : 		}
; 1633 : 		else

  00082	eb 19		 jmp	 SHORT $LN1@GetBootEnc@2
$LN2@GetBootEnc@2:

; 1634 : 		{
; 1635 : 			irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  00084	48 8b 44 24 40	 mov	 rax, QWORD PTR irp$[rsp]
  00089	c7 40 30 0d 00
	00 c0		 mov	 DWORD PTR [rax+48], -1073741811 ; ffffffffc000000dH

; 1636 : 			irp->IoStatus.Information = 0;

  00090	48 8b 44 24 40	 mov	 rax, QWORD PTR irp$[rsp]
  00095	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0
$LN1@GetBootEnc@2:
$LN3@GetBootEnc@2:

; 1637 : 		}
; 1638 : 	}
; 1639 : }

  0009d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a1	c3		 ret	 0
GetBootEncryptionAlgorithmName ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$OnDeviceUsageNotificationCompleted DD imagerel OnDeviceUsageNotificationCompleted
	DD	imagerel OnDeviceUsageNotificationCompleted+121
	DD	imagerel $unwind$OnDeviceUsageNotificationCompleted
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$OnDeviceUsageNotificationCompleted DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT OnDeviceUsageNotificationCompleted
_TEXT	SEGMENT
filterDeviceObject$ = 48
Irp$ = 56
Extension$ = 64
OnDeviceUsageNotificationCompleted PROC			; COMDAT

; 497  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 498  : 	if (Irp->PendingReturned)

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR Irp$[rsp]
  00018	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  0001c	85 c0		 test	 eax, eax
  0001e	74 0a		 je	 SHORT $LN2@OnDeviceUs@2

; 499  : 		IoMarkIrpPending (Irp);

  00020	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Irp$[rsp]
  00025	e8 00 00 00 00	 call	 IoMarkIrpPending
$LN2@OnDeviceUs@2:

; 500  : 
; 501  : 	if (!(Extension->LowerDeviceObject->Flags & DO_POWER_PAGABLE))

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR Extension$[rsp]
  0002f	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00033	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00036	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  0003b	85 c0		 test	 eax, eax
  0003d	75 16		 jne	 SHORT $LN1@OnDeviceUs@2

; 502  : 		filterDeviceObject->Flags &= ~DO_POWER_PAGABLE;

  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR filterDeviceObject$[rsp]
  00044	8b 48 30	 mov	 ecx, DWORD PTR [rax+48]
  00047	81 e1 ff df ff
	ff		 and	 ecx, -8193		; ffffdfffH
  0004d	48 8b 44 24 30	 mov	 rax, QWORD PTR filterDeviceObject$[rsp]
  00052	89 48 30	 mov	 DWORD PTR [rax+48], ecx
$LN1@OnDeviceUs@2:

; 503  : 
; 504  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00055	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Extension$[rsp]
  0005a	48 81 c1 f0 00
	00 00		 add	 rcx, 240		; 000000f0H
  00061	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  00067	48 8b 54 24 38	 mov	 rdx, QWORD PTR Irp$[rsp]
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 505  : 	return STATUS_CONTINUE_COMPLETION;

  00072	33 c0		 xor	 eax, eax

; 506  : }

  00074	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00078	c3		 ret	 0
OnDeviceUsageNotificationCompleted ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PassFilteredIrp DD imagerel PassFilteredIrp
	DD	imagerel PassFilteredIrp+96
	DD	imagerel $unwind$PassFilteredIrp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PassFilteredIrp DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PassFilteredIrp
_TEXT	SEGMENT
deviceObject$ = 64
irp$ = 72
completionRoutine$ = 80
completionRoutineArg$ = 88
PassFilteredIrp PROC					; COMDAT

; 486  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 487  : 	IoCopyCurrentIrpStackLocationToNext (irp);

  00018	48 8b 4c 24 48	 mov	 rcx, QWORD PTR irp$[rsp]
  0001d	e8 00 00 00 00	 call	 IoCopyCurrentIrpStackLocationToNext

; 488  : 
; 489  : 	if (completionRoutine)

  00022	48 83 7c 24 50
	00		 cmp	 QWORD PTR completionRoutine$[rsp], 0
  00028	74 21		 je	 SHORT $LN1@PassFilter@2

; 490  : 		IoSetCompletionRoutine (irp, completionRoutine, completionRoutineArg, TRUE, TRUE, TRUE);

  0002a	c6 44 24 28 01	 mov	 BYTE PTR [rsp+40], 1
  0002f	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  00034	41 b1 01	 mov	 r9b, 1
  00037	4c 8b 44 24 58	 mov	 r8, QWORD PTR completionRoutineArg$[rsp]
  0003c	48 8b 54 24 50	 mov	 rdx, QWORD PTR completionRoutine$[rsp]
  00041	48 8b 4c 24 48	 mov	 rcx, QWORD PTR irp$[rsp]
  00046	e8 00 00 00 00	 call	 IoSetCompletionRoutine
$LN1@PassFilter@2:

; 491  : 
; 492  : 	return IoCallDriver (deviceObject, irp);

  0004b	48 8b 54 24 48	 mov	 rdx, QWORD PTR irp$[rsp]
  00050	48 8b 4c 24 40	 mov	 rcx, QWORD PTR deviceObject$[rsp]
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCallDriver

; 493  : }

  0005b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005f	c3		 ret	 0
PassFilteredIrp ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DismountDrive DD imagerel DismountDrive
	DD	imagerel DismountDrive+212
	DD	imagerel $unwind$DismountDrive
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DismountDrive DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DismountDrive
_TEXT	SEGMENT
tv71 = 32
Extension$ = 64
stopIoQueue$ = 72
DismountDrive PROC					; COMDAT

; 205  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 206  : 	Dump ("Dismounting drive\n");

  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@EAAMLHLJ@Dismounting?5drive?6?$AA@FNODOBFM@
  00014	e8 00 00 00 00	 call	 DbgPrint

; 207  : 	ASSERT (Extension->DriveMounted);

  00019	4c 8b 5c 24 40	 mov	 r11, QWORD PTR Extension$[rsp]
  0001e	41 83 bb 10 03
	00 00 00	 cmp	 DWORD PTR [r11+784], 0
  00026	75 27		 jne	 SHORT $LN4@DismountDr
  00028	45 33 c9	 xor	 r9d, r9d
  0002b	41 b8 cf 00 00
	00		 mov	 r8d, 207		; 000000cfH
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EF@GDHJGIB@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@ONACDOIC@Extension?9?$DODriveMounted?$AA@FNODOBFM@
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  00045	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
  0004d	eb 08		 jmp	 SHORT $LN5@DismountDr
$LN4@DismountDr:
  0004f	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv71[rsp], 1
$LN5@DismountDr:

; 208  : 	
; 209  : 	if (stopIoQueue && EncryptedIoQueueIsRunning (&Extension->Queue))

  00057	83 7c 24 48 00	 cmp	 DWORD PTR stopIoQueue$[rsp], 0
  0005c	74 20		 je	 SHORT $LN1@DismountDr
  0005e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Extension$[rsp]
  00063	48 83 c1 50	 add	 rcx, 80			; 00000050H
  00067	e8 00 00 00 00	 call	 EncryptedIoQueueIsRunning
  0006c	85 c0		 test	 eax, eax
  0006e	74 0e		 je	 SHORT $LN1@DismountDr

; 210  : 		EncryptedIoQueueStop (&Extension->Queue);

  00070	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Extension$[rsp]
  00075	48 83 c1 50	 add	 rcx, 80			; 00000050H
  00079	e8 00 00 00 00	 call	 EncryptedIoQueueStop
$LN1@DismountDr:

; 211  : 
; 212  : 	crypto_close (Extension->Queue.CryptoInfo);

  0007e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Extension$[rsp]
  00083	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  0008a	e8 00 00 00 00	 call	 crypto_close

; 213  : 	Extension->Queue.CryptoInfo = NULL;

  0008f	4c 8b 5c 24 40	 mov	 r11, QWORD PTR Extension$[rsp]
  00094	49 c7 83 98 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [r11+152], 0

; 214  : 
; 215  : 	crypto_close (Extension->HeaderCryptoInfo);

  0009f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Extension$[rsp]
  000a4	48 8b 89 30 03
	00 00		 mov	 rcx, QWORD PTR [rcx+816]
  000ab	e8 00 00 00 00	 call	 crypto_close

; 216  : 	Extension->HeaderCryptoInfo = NULL;

  000b0	4c 8b 5c 24 40	 mov	 r11, QWORD PTR Extension$[rsp]
  000b5	49 c7 83 30 03
	00 00 00 00 00
	00		 mov	 QWORD PTR [r11+816], 0

; 217  : 
; 218  : 	Extension->DriveMounted = FALSE;

  000c0	48 8b 44 24 40	 mov	 rax, QWORD PTR Extension$[rsp]
  000c5	c7 80 10 03 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+784], 0

; 219  : }

  000cf	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d3	c3		 ret	 0
DismountDrive ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\ntddk.h
pdata	SEGMENT
$pdata$KeRaiseIrqlToDpcLevel DD imagerel $LN3
	DD	imagerel $LN3+16
	DD	imagerel $unwind$KeRaiseIrqlToDpcLevel
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$KeRaiseIrqlToDpcLevel DD 010401H
	DD	04204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT KeRaiseIrqlToDpcLevel
_TEXT	SEGMENT
KeRaiseIrqlToDpcLevel PROC				; COMDAT

; 6915 : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 6916 : 
; 6917 :     return KfRaiseIrql(DISPATCH_LEVEL);

  00004	b1 02		 mov	 cl, 2
  00006	e8 00 00 00 00	 call	 KfRaiseIrql

; 6918 : }

  0000b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0000f	c3		 ret	 0
KeRaiseIrqlToDpcLevel ENDP
PUBLIC	WriteBootDriveSector
;	COMDAT pdata
; File c:\users\public\desktop\projects\ciphershed\src\driver\drivefilter.c
pdata	SEGMENT
$pdata$WriteBootDriveSector DD imagerel $LN6
	DD	imagerel $LN6+121
	DD	imagerel $unwind$WriteBootDriveSector
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$WriteBootDriveSector DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT WriteBootDriveSector
_TEXT	SEGMENT
request$ = 32
irp$ = 64
irpSp$ = 72
WriteBootDriveSector PROC				; COMDAT

; 1933 : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1934 : 	WriteBootDriveSectorRequest *request;
; 1935 : 
; 1936 : 	if (!UserCanAccessDriveDevice())

  0000e	e8 00 00 00 00	 call	 UserCanAccessDriveDevice
  00013	85 c0		 test	 eax, eax
  00015	75 07		 jne	 SHORT $LN3@WriteBootD

; 1937 : 		return STATUS_ACCESS_DENIED;

  00017	b8 22 00 00 c0	 mov	 eax, -1073741790	; ffffffffc0000022H
  0001c	eb 56		 jmp	 SHORT $LN4@WriteBootD
$LN3@WriteBootD:

; 1938 : 
; 1939 : 	if (!BootDriveFilterExtension
; 1940 : 		|| irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (WriteBootDriveSectorRequest))

  0001e	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR BootDriveFilterExtension, 0
  00026	74 10		 je	 SHORT $LN1@WriteBootD
  00028	48 8b 44 24 48	 mov	 rax, QWORD PTR irpSp$[rsp]
  0002d	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00030	48 3d 08 02 00
	00		 cmp	 rax, 520		; 00000208H
  00036	73 07		 jae	 SHORT $LN2@WriteBootD
$LN1@WriteBootD:

; 1941 : 		return STATUS_INVALID_PARAMETER;

  00038	b8 0d 00 00 c0	 mov	 eax, -1073741811	; ffffffffc000000dH
  0003d	eb 35		 jmp	 SHORT $LN4@WriteBootD
$LN2@WriteBootD:

; 1942 : 
; 1943 : 	request = (WriteBootDriveSectorRequest *) irp->AssociatedIrp.SystemBuffer;

  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR irp$[rsp]
  00044	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00048	48 89 44 24 20	 mov	 QWORD PTR request$[rsp], rax

; 1944 : 	return TCWriteDevice (BootDriveFilterExtension->LowerDeviceObject, request->Data, request->Offset, sizeof (request->Data));

  0004d	48 8b 54 24 20	 mov	 rdx, QWORD PTR request$[rsp]
  00052	48 83 c2 08	 add	 rdx, 8
  00056	41 b9 00 02 00
	00		 mov	 r9d, 512		; 00000200H
  0005c	4c 8b 44 24 20	 mov	 r8, QWORD PTR request$[rsp]
  00061	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  00064	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR BootDriveFilterExtension
  0006b	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0006f	e8 00 00 00 00	 call	 TCWriteDevice
$LN4@WriteBootD:

; 1945 : }

  00074	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00078	c3		 ret	 0
WriteBootDriveSector ENDP
_TEXT	ENDS
PUBLIC	AbortDecoySystemWipe
DecoySystemWipeThreadAbortRequested DD 01H DUP (?)
;	COMDAT pdata
pdata	SEGMENT
$pdata$AbortDecoySystemWipe DD imagerel $LN5
	DD	imagerel $LN5+93
	DD	imagerel $unwind$AbortDecoySystemWipe
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AbortDecoySystemWipe DD 010401H
	DD	04204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT AbortDecoySystemWipe
_TEXT	SEGMENT
AbortDecoySystemWipe PROC				; COMDAT

; 1910 : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1911 : 	if (!IoIsSystemThread (PsGetCurrentThread()) && !UserCanAccessDriveDevice())

  00004	e8 00 00 00 00	 call	 PsGetCurrentThread
  00009	48 8b c8	 mov	 rcx, rax
  0000c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoIsSystemThread
  00012	0f b6 c0	 movzx	 eax, al
  00015	85 c0		 test	 eax, eax
  00017	75 10		 jne	 SHORT $LN2@AbortDecoy
  00019	e8 00 00 00 00	 call	 UserCanAccessDriveDevice
  0001e	85 c0		 test	 eax, eax
  00020	75 07		 jne	 SHORT $LN2@AbortDecoy

; 1912 : 		return STATUS_ACCESS_DENIED;

  00022	b8 22 00 00 c0	 mov	 eax, -1073741790	; ffffffffc0000022H
  00027	eb 2f		 jmp	 SHORT $LN3@AbortDecoy
$LN2@AbortDecoy:

; 1913 : 
; 1914 : 	if (DecoySystemWipeThread)

  00029	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR DecoySystemWipeThread, 0
  00031	74 23		 je	 SHORT $LN1@AbortDecoy

; 1915 : 	{
; 1916 : 		DecoySystemWipeThreadAbortRequested = TRUE;

  00033	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR DecoySystemWipeThreadAbortRequested, 1

; 1917 : 
; 1918 : 		TCStopThread (DecoySystemWipeThread, NULL);

  0003d	33 d2		 xor	 edx, edx
  0003f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR DecoySystemWipeThread
  00046	e8 00 00 00 00	 call	 TCStopThread

; 1919 : 		DecoySystemWipeThread = NULL;

  0004b	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR DecoySystemWipeThread, 0
$LN1@AbortDecoy:

; 1920 : 	}
; 1921 : 
; 1922 : 	return STATUS_SUCCESS;

  00056	33 c0		 xor	 eax, eax
$LN3@AbortDecoy:

; 1923 : }

  00058	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005c	c3		 ret	 0
AbortDecoySystemWipe ENDP
_TEXT	ENDS
PUBLIC	AbortBootEncryptionSetup
EncryptionSetupThreadAbortRequested DD 01H DUP (?)
;	COMDAT pdata
pdata	SEGMENT
$pdata$AbortBootEncryptionSetup DD imagerel $LN5
	DD	imagerel $LN5+93
	DD	imagerel $unwind$AbortBootEncryptionSetup
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AbortBootEncryptionSetup DD 010401H
	DD	04204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT AbortBootEncryptionSetup
_TEXT	SEGMENT
AbortBootEncryptionSetup PROC				; COMDAT

; 1679 : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1680 : 	if (!IoIsSystemThread (PsGetCurrentThread()) && !UserCanAccessDriveDevice())

  00004	e8 00 00 00 00	 call	 PsGetCurrentThread
  00009	48 8b c8	 mov	 rcx, rax
  0000c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoIsSystemThread
  00012	0f b6 c0	 movzx	 eax, al
  00015	85 c0		 test	 eax, eax
  00017	75 10		 jne	 SHORT $LN2@AbortBootE
  00019	e8 00 00 00 00	 call	 UserCanAccessDriveDevice
  0001e	85 c0		 test	 eax, eax
  00020	75 07		 jne	 SHORT $LN2@AbortBootE

; 1681 : 		return STATUS_ACCESS_DENIED;

  00022	b8 22 00 00 c0	 mov	 eax, -1073741790	; ffffffffc0000022H
  00027	eb 2f		 jmp	 SHORT $LN3@AbortBootE
$LN2@AbortBootE:

; 1682 : 
; 1683 : 	if (EncryptionSetupThread)

  00029	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR EncryptionSetupThread, 0
  00031	74 23		 je	 SHORT $LN1@AbortBootE

; 1684 : 	{
; 1685 : 		EncryptionSetupThreadAbortRequested = TRUE;

  00033	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR EncryptionSetupThreadAbortRequested, 1

; 1686 : 
; 1687 : 		TCStopThread (EncryptionSetupThread, NULL);

  0003d	33 d2		 xor	 edx, edx
  0003f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR EncryptionSetupThread
  00046	e8 00 00 00 00	 call	 TCStopThread

; 1688 : 		EncryptionSetupThread = NULL;

  0004b	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR EncryptionSetupThread, 0
$LN1@AbortBootE:

; 1689 : 	}
; 1690 : 
; 1691 : 	return STATUS_SUCCESS;

  00056	33 c0		 xor	 eax, eax
$LN3@AbortBootE:

; 1692 : }

  00058	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005c	c3		 ret	 0
AbortBootEncryptionSetup ENDP
OriginalHiberDriverWriteFunctionsA DQ 03H DUP (?)
OriginalHiberDriverWriteFunctionsB DQ 03H DUP (?)
HiberPartitionOffset DQ 01H DUP (?)
;	COMDAT pdata
pdata	SEGMENT
$pdata$HiberDriverWriteFunctionFilter DD imagerel HiberDriverWriteFunctionFilter
	DD	imagerel HiberDriverWriteFunctionFilter+819
	DD	imagerel $unwind$HiberDriverWriteFunctionFilter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$HiberDriverWriteFunctionFilter DD 031901H
	DD	07015c219H
	DD	06014H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT HiberDriverWriteFunctionFilter
_TEXT	SEGMENT
encryptedDataMdl$ = 48
dataLength$29987 = 56
intersectLength$29991 = 60
intersectStart$29990 = 64
offset$29989 = 72
dataUnit$30005 = 80
filterNumber$ = 128
writeOffset$ = 136
dataMdl$ = 144
writeB$ = 152
arg0WriteA$ = 160
arg3WriteA$ = 168
HiberDriverWriteFunctionFilter PROC			; COMDAT

; 870  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 871  : 	MDL *encryptedDataMdl = dataMdl;

  00019	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dataMdl$[rsp]
  00021	48 89 44 24 30	 mov	 QWORD PTR encryptedDataMdl$[rsp], rax

; 872  : 
; 873  : 	if (writeOffset && dataMdl && BootDriveFilterExtension && BootDriveFilterExtension->DriveMounted)

  00026	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR writeOffset$[rsp], 0
  0002f	0f 84 9e 02 00
	00		 je	 $LN8@HiberDrive
  00035	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dataMdl$[rsp], 0
  0003e	0f 84 8f 02 00
	00		 je	 $LN8@HiberDrive
  00044	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR BootDriveFilterExtension, 0
  0004c	0f 84 81 02 00
	00		 je	 $LN8@HiberDrive
  00052	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00059	83 b8 10 03 00
	00 00		 cmp	 DWORD PTR [rax+784], 0
  00060	0f 84 6d 02 00
	00		 je	 $LN8@HiberDrive

; 874  : 	{
; 875  : 		ULONG dataLength = MmGetMdlByteCount (dataMdl);

  00066	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dataMdl$[rsp]
  0006e	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00071	89 44 24 38	 mov	 DWORD PTR dataLength$29987[rsp], eax

; 876  : 
; 877  : 		if (dataMdl->MappedSystemVa && dataLength > 0)

  00075	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dataMdl$[rsp]
  0007d	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00082	0f 84 4b 02 00
	00		 je	 $LN7@HiberDrive
  00088	83 7c 24 38 00	 cmp	 DWORD PTR dataLength$29987[rsp], 0
  0008d	0f 86 40 02 00
	00		 jbe	 $LN7@HiberDrive

; 878  : 		{
; 879  : 			uint64 offset = HiberPartitionOffset.QuadPart + writeOffset->QuadPart;

  00093	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR writeOffset$[rsp]
  0009b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0009e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR HiberPartitionOffset
  000a5	48 03 c1	 add	 rax, rcx
  000a8	48 89 44 24 48	 mov	 QWORD PTR offset$29989[rsp], rax

; 880  : 			uint64 intersectStart;
; 881  : 			uint32 intersectLength;
; 882  : 
; 883  : 			if (dataLength > TC_HIBERNATION_WRITE_BUFFER_SIZE)

  000ad	81 7c 24 38 00
	00 02 00	 cmp	 DWORD PTR dataLength$29987[rsp], 131072 ; 00020000H
  000b5	76 23		 jbe	 SHORT $LN6@HiberDrive

; 884  : 				TC_BUG_CHECK (STATUS_BUFFER_OVERFLOW);

  000b7	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  000c0	45 33 c9	 xor	 r9d, r9d
  000c3	49 c7 c0 05 00
	00 80		 mov	 r8, -2147483643		; ffffffff80000005H
  000ca	ba 74 03 00 00	 mov	 edx, 884		; 00000374H
  000cf	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  000d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN6@HiberDrive:

; 885  : 
; 886  : 			if ((dataLength & (ENCRYPTION_DATA_UNIT_SIZE - 1)) != 0)

  000da	8b 44 24 38	 mov	 eax, DWORD PTR dataLength$29987[rsp]
  000de	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  000e3	85 c0		 test	 eax, eax
  000e5	74 23		 je	 SHORT $LN5@HiberDrive

; 887  : 				TC_BUG_CHECK (STATUS_INVALID_PARAMETER);

  000e7	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  000f0	45 33 c9	 xor	 r9d, r9d
  000f3	49 c7 c0 0d 00
	00 c0		 mov	 r8, -1073741811		; ffffffffc000000dH
  000fa	ba 77 03 00 00	 mov	 edx, 887		; 00000377H
  000ff	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  00104	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN5@HiberDrive:

; 888  : 
; 889  : 			if ((offset & (ENCRYPTION_DATA_UNIT_SIZE - 1)) != 0)

  0010a	48 8b 44 24 48	 mov	 rax, QWORD PTR offset$29989[rsp]
  0010f	48 25 ff 01 00
	00		 and	 rax, 511		; 000001ffH
  00115	48 85 c0	 test	 rax, rax
  00118	74 23		 je	 SHORT $LN4@HiberDrive

; 890  : 				TC_BUG_CHECK (STATUS_INVALID_PARAMETER);

  0011a	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00123	45 33 c9	 xor	 r9d, r9d
  00126	49 c7 c0 0d 00
	00 c0		 mov	 r8, -1073741811		; ffffffffc000000dH
  0012d	ba 7a 03 00 00	 mov	 edx, 890		; 0000037aH
  00132	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN4@HiberDrive:

; 891  : 
; 892  : 			GetIntersection (offset,
; 893  : 				dataLength,
; 894  : 				BootDriveFilterExtension->Queue.EncryptedAreaStart,
; 895  : 				BootDriveFilterExtension->Queue.EncryptedAreaEnd,
; 896  : 				&intersectStart,
; 897  : 				&intersectLength);

  0013d	48 8d 44 24 3c	 lea	 rax, QWORD PTR intersectLength$29991[rsp]
  00142	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00147	48 8d 44 24 40	 lea	 rax, QWORD PTR intersectStart$29990[rsp]
  0014c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00151	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR BootDriveFilterExtension
  00158	4d 8b 89 d0 00
	00 00		 mov	 r9, QWORD PTR [r9+208]
  0015f	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR BootDriveFilterExtension
  00166	4d 8b 80 c8 00
	00 00		 mov	 r8, QWORD PTR [r8+200]
  0016d	8b 54 24 38	 mov	 edx, DWORD PTR dataLength$29987[rsp]
  00171	48 8b 4c 24 48	 mov	 rcx, QWORD PTR offset$29989[rsp]
  00176	e8 00 00 00 00	 call	 GetIntersection

; 898  : 
; 899  : 			if (intersectLength > 0)

  0017b	83 7c 24 3c 00	 cmp	 DWORD PTR intersectLength$29991[rsp], 0
  00180	0f 86 4d 01 00
	00		 jbe	 $LN3@HiberDrive

; 900  : 			{
; 901  : 				UINT64_STRUCT dataUnit;
; 902  : 				dataUnit.Value = intersectStart / ENCRYPTION_DATA_UNIT_SIZE;

  00186	33 d2		 xor	 edx, edx
  00188	48 8b 44 24 40	 mov	 rax, QWORD PTR intersectStart$29990[rsp]
  0018d	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00192	48 f7 f1	 div	 rcx
  00195	48 89 44 24 50	 mov	 QWORD PTR dataUnit$30005[rsp], rax

; 903  : 
; 904  : 				memcpy (HibernationWriteBuffer, dataMdl->MappedSystemVa, dataLength);

  0019a	8b 4c 24 38	 mov	 ecx, DWORD PTR dataLength$29987[rsp]
  0019e	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR dataMdl$[rsp]
  001a6	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR HibernationWriteBuffer
  001ad	48 8b 76 18	 mov	 rsi, QWORD PTR [rsi+24]
  001b1	f3 a4		 rep movsb

; 905  : 
; 906  : 				if (BootDriveFilterExtension->Queue.RemapEncryptedArea)

  001b3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  001ba	83 b8 dc 00 00
	00 00		 cmp	 DWORD PTR [rax+220], 0
  001c1	74 1b		 je	 SHORT $LN2@HiberDrive

; 907  : 					dataUnit.Value += BootDriveFilterExtension->Queue.RemappedAreaDataUnitOffset;

  001c3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR BootDriveFilterExtension
  001ca	48 8b 89 e8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+232]
  001d1	48 8b 44 24 50	 mov	 rax, QWORD PTR dataUnit$30005[rsp]
  001d6	48 03 c1	 add	 rax, rcx
  001d9	48 89 44 24 50	 mov	 QWORD PTR dataUnit$30005[rsp], rax
$LN2@HiberDrive:

; 908  : 
; 909  : 				EncryptDataUnitsCurrentThread (HibernationWriteBuffer + (intersectStart - offset),
; 910  : 					&dataUnit,
; 911  : 					intersectLength / ENCRYPTION_DATA_UNIT_SIZE,
; 912  : 					BootDriveFilterExtension->Queue.CryptoInfo);

  001de	33 d2		 xor	 edx, edx
  001e0	8b 44 24 3c	 mov	 eax, DWORD PTR intersectLength$29991[rsp]
  001e4	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001e9	f7 f1		 div	 ecx
  001eb	44 8b c0	 mov	 r8d, eax
  001ee	48 8b 4c 24 48	 mov	 rcx, QWORD PTR offset$29989[rsp]
  001f3	48 8b 44 24 40	 mov	 rax, QWORD PTR intersectStart$29990[rsp]
  001f8	48 2b c1	 sub	 rax, rcx
  001fb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR HibernationWriteBuffer
  00202	48 03 c8	 add	 rcx, rax
  00205	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR BootDriveFilterExtension
  0020c	4d 8b 89 98 00
	00 00		 mov	 r9, QWORD PTR [r9+152]
  00213	48 8d 54 24 50	 lea	 rdx, QWORD PTR dataUnit$30005[rsp]
  00218	e8 00 00 00 00	 call	 EncryptDataUnitsCurrentThread

; 913  : 
; 914  : 				encryptedDataMdl = HibernationWriteBufferMdl;

  0021d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR HibernationWriteBufferMdl
  00224	48 89 54 24 30	 mov	 QWORD PTR encryptedDataMdl$[rsp], rdx

; 915  : 				MmInitializeMdl (encryptedDataMdl, HibernationWriteBuffer, dataLength);

  00229	48 8b 44 24 30	 mov	 rax, QWORD PTR encryptedDataMdl$[rsp]
  0022e	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00235	8b 54 24 38	 mov	 edx, DWORD PTR dataLength$29987[rsp]
  00239	48 c1 ea 0c	 shr	 rdx, 12
  0023d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR HibernationWriteBuffer
  00244	48 81 e1 ff 0f
	00 00		 and	 rcx, 4095		; 00000fffH
  0024b	8b 44 24 38	 mov	 eax, DWORD PTR dataLength$29987[rsp]
  0024f	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00255	8d 84 01 ff 0f
	00 00		 lea	 eax, DWORD PTR [rcx+rax+4095]
  0025c	c1 e8 0c	 shr	 eax, 12
  0025f	8b c8		 mov	 ecx, eax
  00261	48 8b c2	 mov	 rax, rdx
  00264	48 03 c1	 add	 rax, rcx
  00267	8b c8		 mov	 ecx, eax
  00269	48 8d 0c cd 30
	00 00 00	 lea	 rcx, QWORD PTR [rcx*8+48]
  00271	48 8b 44 24 30	 mov	 rax, QWORD PTR encryptedDataMdl$[rsp]
  00276	66 89 48 08	 mov	 WORD PTR [rax+8], cx
  0027a	33 c9		 xor	 ecx, ecx
  0027c	48 8b 44 24 30	 mov	 rax, QWORD PTR encryptedDataMdl$[rsp]
  00281	66 89 48 0a	 mov	 WORD PTR [rax+10], cx
  00285	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR HibernationWriteBuffer
  0028c	48 81 e1 00 f0
	ff ff		 and	 rcx, -4096		; fffffffffffff000H
  00293	48 8b 44 24 30	 mov	 rax, QWORD PTR encryptedDataMdl$[rsp]
  00298	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx
  0029c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR HibernationWriteBuffer
  002a3	48 81 e1 ff 0f
	00 00		 and	 rcx, 4095		; 00000fffH
  002aa	48 8b 44 24 30	 mov	 rax, QWORD PTR encryptedDataMdl$[rsp]
  002af	89 48 2c	 mov	 DWORD PTR [rax+44], ecx
  002b2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR encryptedDataMdl$[rsp]
  002b7	8b 44 24 38	 mov	 eax, DWORD PTR dataLength$29987[rsp]
  002bb	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 916  : 				encryptedDataMdl->MdlFlags = dataMdl->MdlFlags;

  002be	48 8b 4c 24 30	 mov	 rcx, QWORD PTR encryptedDataMdl$[rsp]
  002c3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dataMdl$[rsp]
  002cb	0f b7 40 0a	 movzx	 eax, WORD PTR [rax+10]
  002cf	66 89 41 0a	 mov	 WORD PTR [rcx+10], ax
$LN3@HiberDrive:
$LN7@HiberDrive:
$LN8@HiberDrive:

; 917  : 			}
; 918  : 		}
; 919  : 	}
; 920  : 
; 921  : 	if (writeB)

  002d3	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR writeB$[rsp], 0
  002db	74 21		 je	 SHORT $LN1@HiberDrive

; 922  : 		return (*OriginalHiberDriverWriteFunctionsB[filterNumber]) (writeOffset, encryptedDataMdl);

  002dd	48 63 bc 24 80
	00 00 00	 movsxd	 rdi, DWORD PTR filterNumber$[rsp]
  002e5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:OriginalHiberDriverWriteFunctionsB
  002ec	48 8b 54 24 30	 mov	 rdx, QWORD PTR encryptedDataMdl$[rsp]
  002f1	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR writeOffset$[rsp]
  002f9	ff 14 f8	 call	 QWORD PTR [rax+rdi*8]
  002fc	eb 2e		 jmp	 SHORT $LN9@HiberDrive
$LN1@HiberDrive:

; 923  : 	
; 924  : 	return (*OriginalHiberDriverWriteFunctionsA[filterNumber]) (arg0WriteA, writeOffset, encryptedDataMdl, arg3WriteA);

  002fe	48 63 bc 24 80
	00 00 00	 movsxd	 rdi, DWORD PTR filterNumber$[rsp]
  00306	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:OriginalHiberDriverWriteFunctionsA
  0030d	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR arg3WriteA$[rsp]
  00315	4c 8b 44 24 30	 mov	 r8, QWORD PTR encryptedDataMdl$[rsp]
  0031a	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR writeOffset$[rsp]
  00322	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR arg0WriteA$[rsp]
  00329	ff 14 f8	 call	 QWORD PTR [rax+rdi*8]
$LN9@HiberDrive:
$LN10@HiberDrive:

; 925  : }

  0032c	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00330	5f		 pop	 rdi
  00331	5e		 pop	 rsi
  00332	c3		 ret	 0
HiberDriverWriteFunctionFilter ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SaveDriveVolumeHeader DD imagerel SaveDriveVolumeHeader
	DD	imagerel SaveDriveVolumeHeader+1194
	DD	imagerel $unwind$SaveDriveVolumeHeader
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SaveDriveVolumeHeader DD 020a01H
	DD	07006b20aH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT SaveDriveVolumeHeader
_TEXT	SEGMENT
offset$ = 48
status$ = 56
header$ = 64
headerCrc32$29681 = 72
fieldPos$29683 = 80
encryptedAreaLength$29682 = 88
Extension$ = 112
SaveDriveVolumeHeader PROC				; COMDAT

; 410  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 411  : 	NTSTATUS status = STATUS_SUCCESS;

  0000a	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR status$[rsp], 0

; 412  : 	LARGE_INTEGER offset;
; 413  : 	byte *header;
; 414  : 
; 415  : 	header = TCalloc (TC_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE);

  00012	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  00018	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  0001d	33 c9		 xor	 ecx, ecx
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00025	48 89 44 24 40	 mov	 QWORD PTR header$[rsp], rax

; 416  : 	if (!header)

  0002a	48 83 7c 24 40
	00		 cmp	 QWORD PTR header$[rsp], 0
  00030	75 0a		 jne	 SHORT $LN8@SaveDriveV

; 417  : 		return STATUS_INSUFFICIENT_RESOURCES;

  00032	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  00037	e9 68 04 00 00	 jmp	 $LN9@SaveDriveV
$LN8@SaveDriveV:

; 418  : 
; 419  : 	offset.QuadPart = TC_BOOT_VOLUME_HEADER_SECTOR_OFFSET;

  0003c	48 c7 44 24 30
	00 7c 00 00	 mov	 QWORD PTR offset$[rsp], 31744 ; 00007c00H

; 420  : 
; 421  : 	status = TCReadDevice (Extension->LowerDeviceObject, header, offset, TC_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE);

  00045	41 b9 00 02 00
	00		 mov	 r9d, 512		; 00000200H
  0004b	4c 8b 44 24 30	 mov	 r8, QWORD PTR offset$[rsp]
  00050	48 8b 54 24 40	 mov	 rdx, QWORD PTR header$[rsp]
  00055	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Extension$[rsp]
  0005a	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0005e	e8 00 00 00 00	 call	 TCReadDevice
  00063	89 44 24 38	 mov	 DWORD PTR status$[rsp], eax

; 422  : 	if (!NT_SUCCESS (status))

  00067	83 7c 24 38 00	 cmp	 DWORD PTR status$[rsp], 0
  0006c	7d 15		 jge	 SHORT $LN7@SaveDriveV

; 423  : 	{
; 424  : 		Dump ("TCReadDevice error %x", status);

  0006e	8b 54 24 38	 mov	 edx, DWORD PTR status$[rsp]
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@EAILECP@TCReadDevice?5error?5?$CFx?$AA@FNODOBFM@
  00079	e8 00 00 00 00	 call	 DbgPrint

; 425  : 		goto ret;

  0007e	e9 0d 04 00 00	 jmp	 $ret$29674
$LN7@SaveDriveV:

; 426  : 	}
; 427  : 
; 428  : 	Dump ("Saving: ConfiguredEncryptedAreaStart=%I64d (%I64d)  ConfiguredEncryptedAreaEnd=%I64d (%I64d)\n", Extension->ConfiguredEncryptedAreaStart / 1024 / 1024, Extension->ConfiguredEncryptedAreaStart, Extension->ConfiguredEncryptedAreaEnd / 1024 / 1024, Extension->ConfiguredEncryptedAreaEnd);

  00083	48 8b 44 24 70	 mov	 rax, QWORD PTR Extension$[rsp]
  00088	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0008c	48 99		 cdq
  0008e	48 81 e2 ff 03
	00 00		 and	 rdx, 1023		; 000003ffH
  00095	48 03 c2	 add	 rax, rdx
  00098	48 c1 f8 0a	 sar	 rax, 10
  0009c	48 99		 cdq
  0009e	48 81 e2 ff 03
	00 00		 and	 rdx, 1023		; 000003ffH
  000a5	48 03 c2	 add	 rax, rdx
  000a8	48 c1 f8 0a	 sar	 rax, 10
  000ac	4c 8b c8	 mov	 r9, rax
  000af	48 8b 44 24 70	 mov	 rax, QWORD PTR Extension$[rsp]
  000b4	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000b8	48 99		 cdq
  000ba	48 81 e2 ff 03
	00 00		 and	 rdx, 1023		; 000003ffH
  000c1	48 03 c2	 add	 rax, rdx
  000c4	48 c1 f8 0a	 sar	 rax, 10
  000c8	48 99		 cdq
  000ca	48 81 e2 ff 03
	00 00		 and	 rdx, 1023		; 000003ffH
  000d1	48 03 c2	 add	 rax, rdx
  000d4	48 c1 f8 0a	 sar	 rax, 10
  000d8	48 8b d0	 mov	 rdx, rax
  000db	48 8b 44 24 70	 mov	 rax, QWORD PTR Extension$[rsp]
  000e0	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  000e4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e9	4c 8b 44 24 70	 mov	 r8, QWORD PTR Extension$[rsp]
  000ee	4d 8b 40 38	 mov	 r8, QWORD PTR [r8+56]
  000f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0FO@BIDJBKJB@Saving?3?5ConfiguredEncryptedAreaS@FNODOBFM@
  000f9	e8 00 00 00 00	 call	 DbgPrint

; 429  : 	Dump ("Saving: EncryptedAreaStart=%I64d (%I64d)  EncryptedAreaEnd=%I64d (%I64d)\n", Extension->Queue.EncryptedAreaStart / 1024 / 1024, Extension->Queue.EncryptedAreaStart, Extension->Queue.EncryptedAreaEnd / 1024 / 1024, Extension->Queue.EncryptedAreaEnd);

  000fe	48 8b 44 24 70	 mov	 rax, QWORD PTR Extension$[rsp]
  00103	48 8b 80 d0 00
	00 00		 mov	 rax, QWORD PTR [rax+208]
  0010a	48 99		 cdq
  0010c	48 81 e2 ff 03
	00 00		 and	 rdx, 1023		; 000003ffH
  00113	48 03 c2	 add	 rax, rdx
  00116	48 c1 f8 0a	 sar	 rax, 10
  0011a	48 99		 cdq
  0011c	48 81 e2 ff 03
	00 00		 and	 rdx, 1023		; 000003ffH
  00123	48 03 c2	 add	 rax, rdx
  00126	48 c1 f8 0a	 sar	 rax, 10
  0012a	4c 8b c8	 mov	 r9, rax
  0012d	48 8b 44 24 70	 mov	 rax, QWORD PTR Extension$[rsp]
  00132	48 8b 80 c8 00
	00 00		 mov	 rax, QWORD PTR [rax+200]
  00139	48 99		 cdq
  0013b	48 81 e2 ff 03
	00 00		 and	 rdx, 1023		; 000003ffH
  00142	48 03 c2	 add	 rax, rdx
  00145	48 c1 f8 0a	 sar	 rax, 10
  00149	48 99		 cdq
  0014b	48 81 e2 ff 03
	00 00		 and	 rdx, 1023		; 000003ffH
  00152	48 03 c2	 add	 rax, rdx
  00155	48 c1 f8 0a	 sar	 rax, 10
  00159	48 8b d0	 mov	 rdx, rax
  0015c	48 8b 44 24 70	 mov	 rax, QWORD PTR Extension$[rsp]
  00161	48 8b 80 d0 00
	00 00		 mov	 rax, QWORD PTR [rax+208]
  00168	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0016d	4c 8b 44 24 70	 mov	 r8, QWORD PTR Extension$[rsp]
  00172	4d 8b 80 c8 00
	00 00		 mov	 r8, QWORD PTR [r8+200]
  00179	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EK@MOIFFFBD@Saving?3?5EncryptedAreaStart?$DN?$CFI64d@FNODOBFM@
  00180	e8 00 00 00 00	 call	 DbgPrint

; 430  : 	
; 431  : 	if (Extension->Queue.EncryptedAreaStart == -1 || Extension->Queue.EncryptedAreaEnd == -1
; 432  : 		|| Extension->Queue.EncryptedAreaEnd <= Extension->Queue.EncryptedAreaStart)

  00185	48 8b 54 24 70	 mov	 rdx, QWORD PTR Extension$[rsp]
  0018a	48 83 ba c8 00
	00 00 ff	 cmp	 QWORD PTR [rdx+200], -1
  00192	74 2c		 je	 SHORT $LN5@SaveDriveV
  00194	48 8b 44 24 70	 mov	 rax, QWORD PTR Extension$[rsp]
  00199	48 8b 80 d0 00
	00 00		 mov	 rax, QWORD PTR [rax+208]
  001a0	48 83 f8 ff	 cmp	 rax, -1
  001a4	74 1a		 je	 SHORT $LN5@SaveDriveV
  001a6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Extension$[rsp]
  001ab	48 8b 89 d0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+208]
  001b2	48 8b 44 24 70	 mov	 rax, QWORD PTR Extension$[rsp]
  001b7	48 3b 88 c8 00
	00 00		 cmp	 rcx, QWORD PTR [rax+200]
  001be	7f 2b		 jg	 SHORT $LN6@SaveDriveV
$LN5@SaveDriveV:

; 433  : 	{
; 434  : 		if (SetupRequest.SetupMode == SetupDecryption)

  001c0	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR SetupRequest, 2
  001c7	75 1d		 jne	 SHORT $LN4@SaveDriveV

; 435  : 		{
; 436  : 			memset (header, 0, TC_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE);

  001c9	48 8b 7c 24 40	 mov	 rdi, QWORD PTR header$[rsp]
  001ce	33 c0		 xor	 eax, eax
  001d0	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001d5	f3 aa		 rep stosb

; 437  : 			Extension->VolumeHeaderPresent = FALSE;

  001d7	48 8b 44 24 70	 mov	 rax, QWORD PTR Extension$[rsp]
  001dc	c7 80 0c 03 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+780], 0
$LN4@SaveDriveV:

; 438  : 		}
; 439  : 	}
; 440  : 	else

  001e6	e9 6c 02 00 00	 jmp	 $LN3@SaveDriveV
$LN6@SaveDriveV:

; 441  : 	{
; 442  : 		uint32 headerCrc32;
; 443  : 		uint64 encryptedAreaLength = Extension->Queue.EncryptedAreaEnd + 1 - Extension->Queue.EncryptedAreaStart;

  001eb	48 8b 44 24 70	 mov	 rax, QWORD PTR Extension$[rsp]
  001f0	48 8b 80 d0 00
	00 00		 mov	 rax, QWORD PTR [rax+208]
  001f7	48 83 c0 01	 add	 rax, 1
  001fb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Extension$[rsp]
  00200	48 2b 81 c8 00
	00 00		 sub	 rax, QWORD PTR [rcx+200]
  00207	48 89 44 24 58	 mov	 QWORD PTR encryptedAreaLength$29682[rsp], rax

; 444  : 		byte *fieldPos = header + TC_HEADER_OFFSET_ENCRYPTED_AREA_LENGTH;

  0020c	48 8b 44 24 40	 mov	 rax, QWORD PTR header$[rsp]
  00211	48 83 c0 74	 add	 rax, 116		; 00000074H
  00215	48 89 44 24 50	 mov	 QWORD PTR fieldPos$29683[rsp], rax

; 445  : 
; 446  : 		DecryptBuffer (header + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, Extension->HeaderCryptoInfo);

  0021a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR header$[rsp]
  0021f	48 83 c1 40	 add	 rcx, 64			; 00000040H
  00223	4c 8b 44 24 70	 mov	 r8, QWORD PTR Extension$[rsp]
  00228	4d 8b 80 30 03
	00 00		 mov	 r8, QWORD PTR [r8+816]
  0022f	ba c0 01 00 00	 mov	 edx, 448		; 000001c0H
  00234	e8 00 00 00 00	 call	 DecryptBuffer

; 447  : 
; 448  : 		/* Modifying 'TRUE' can introduce incompatibility with previous versions. */
; 449  : 		if (GetHeaderField32 (header, TC_HEADER_OFFSET_MAGIC) != 0x54525545)

  00239	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0023e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR header$[rsp]
  00243	e8 00 00 00 00	 call	 GetHeaderField32
  00248	3d 45 55 52 54	 cmp	 eax, 1414681925		; 54525545H
  0024d	74 19		 je	 SHORT $LN2@SaveDriveV

; 450  : 		{
; 451  : 			Dump ("Header not decrypted");

  0024f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@DGHCICOF@Header?5not?5decrypted?$AA@FNODOBFM@
  00256	e8 00 00 00 00	 call	 DbgPrint

; 452  : 			status = STATUS_UNKNOWN_REVISION;

  0025b	c7 44 24 38 58
	00 00 c0	 mov	 DWORD PTR status$[rsp], -1073741736 ; ffffffffc0000058H

; 453  : 			goto ret;

  00263	e9 28 02 00 00	 jmp	 $ret$29674
$LN2@SaveDriveV:

; 454  : 		}
; 455  : 
; 456  : 		mputInt64 (fieldPos, encryptedAreaLength);

  00268	48 8b 4c 24 58	 mov	 rcx, QWORD PTR encryptedAreaLength$29682[rsp]
  0026d	48 c1 e9 38	 shr	 rcx, 56			; 00000038H
  00271	48 81 e1 ff 00
	00 00		 and	 rcx, 255		; 000000ffH
  00278	48 8b 44 24 50	 mov	 rax, QWORD PTR fieldPos$29683[rsp]
  0027d	88 08		 mov	 BYTE PTR [rax], cl
  0027f	48 8b 44 24 50	 mov	 rax, QWORD PTR fieldPos$29683[rsp]
  00284	48 83 c0 01	 add	 rax, 1
  00288	48 89 44 24 50	 mov	 QWORD PTR fieldPos$29683[rsp], rax
  0028d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR encryptedAreaLength$29682[rsp]
  00292	48 c1 e9 30	 shr	 rcx, 48			; 00000030H
  00296	48 81 e1 ff 00
	00 00		 and	 rcx, 255		; 000000ffH
  0029d	48 8b 44 24 50	 mov	 rax, QWORD PTR fieldPos$29683[rsp]
  002a2	88 08		 mov	 BYTE PTR [rax], cl
  002a4	48 8b 44 24 50	 mov	 rax, QWORD PTR fieldPos$29683[rsp]
  002a9	48 83 c0 01	 add	 rax, 1
  002ad	48 89 44 24 50	 mov	 QWORD PTR fieldPos$29683[rsp], rax
  002b2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR encryptedAreaLength$29682[rsp]
  002b7	48 c1 e9 28	 shr	 rcx, 40			; 00000028H
  002bb	48 81 e1 ff 00
	00 00		 and	 rcx, 255		; 000000ffH
  002c2	48 8b 44 24 50	 mov	 rax, QWORD PTR fieldPos$29683[rsp]
  002c7	88 08		 mov	 BYTE PTR [rax], cl
  002c9	48 8b 44 24 50	 mov	 rax, QWORD PTR fieldPos$29683[rsp]
  002ce	48 83 c0 01	 add	 rax, 1
  002d2	48 89 44 24 50	 mov	 QWORD PTR fieldPos$29683[rsp], rax
  002d7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR encryptedAreaLength$29682[rsp]
  002dc	48 c1 e9 20	 shr	 rcx, 32			; 00000020H
  002e0	48 81 e1 ff 00
	00 00		 and	 rcx, 255		; 000000ffH
  002e7	48 8b 44 24 50	 mov	 rax, QWORD PTR fieldPos$29683[rsp]
  002ec	88 08		 mov	 BYTE PTR [rax], cl
  002ee	48 8b 44 24 50	 mov	 rax, QWORD PTR fieldPos$29683[rsp]
  002f3	48 83 c0 01	 add	 rax, 1
  002f7	48 89 44 24 50	 mov	 QWORD PTR fieldPos$29683[rsp], rax
  002fc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR encryptedAreaLength$29682[rsp]
  00301	48 c1 e9 18	 shr	 rcx, 24
  00305	48 81 e1 ff 00
	00 00		 and	 rcx, 255		; 000000ffH
  0030c	48 8b 44 24 50	 mov	 rax, QWORD PTR fieldPos$29683[rsp]
  00311	88 08		 mov	 BYTE PTR [rax], cl
  00313	48 8b 44 24 50	 mov	 rax, QWORD PTR fieldPos$29683[rsp]
  00318	48 83 c0 01	 add	 rax, 1
  0031c	48 89 44 24 50	 mov	 QWORD PTR fieldPos$29683[rsp], rax
  00321	48 8b 4c 24 58	 mov	 rcx, QWORD PTR encryptedAreaLength$29682[rsp]
  00326	48 c1 e9 10	 shr	 rcx, 16
  0032a	48 81 e1 ff 00
	00 00		 and	 rcx, 255		; 000000ffH
  00331	48 8b 44 24 50	 mov	 rax, QWORD PTR fieldPos$29683[rsp]
  00336	88 08		 mov	 BYTE PTR [rax], cl
  00338	48 8b 44 24 50	 mov	 rax, QWORD PTR fieldPos$29683[rsp]
  0033d	48 83 c0 01	 add	 rax, 1
  00341	48 89 44 24 50	 mov	 QWORD PTR fieldPos$29683[rsp], rax
  00346	48 8b 4c 24 58	 mov	 rcx, QWORD PTR encryptedAreaLength$29682[rsp]
  0034b	48 c1 e9 08	 shr	 rcx, 8
  0034f	48 81 e1 ff 00
	00 00		 and	 rcx, 255		; 000000ffH
  00356	48 8b 44 24 50	 mov	 rax, QWORD PTR fieldPos$29683[rsp]
  0035b	88 08		 mov	 BYTE PTR [rax], cl
  0035d	48 8b 44 24 50	 mov	 rax, QWORD PTR fieldPos$29683[rsp]
  00362	48 83 c0 01	 add	 rax, 1
  00366	48 89 44 24 50	 mov	 QWORD PTR fieldPos$29683[rsp], rax
  0036b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR encryptedAreaLength$29682[rsp]
  00370	48 81 e1 ff 00
	00 00		 and	 rcx, 255		; 000000ffH
  00377	48 8b 44 24 50	 mov	 rax, QWORD PTR fieldPos$29683[rsp]
  0037c	88 08		 mov	 BYTE PTR [rax], cl
  0037e	48 8b 44 24 50	 mov	 rax, QWORD PTR fieldPos$29683[rsp]
  00383	48 83 c0 01	 add	 rax, 1
  00387	48 89 44 24 50	 mov	 QWORD PTR fieldPos$29683[rsp], rax

; 457  : 
; 458  : 		headerCrc32 = GetCrc32 (header + TC_HEADER_OFFSET_MAGIC, TC_HEADER_OFFSET_HEADER_CRC - TC_HEADER_OFFSET_MAGIC);

  0038c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR header$[rsp]
  00391	48 83 c1 40	 add	 rcx, 64			; 00000040H
  00395	ba bc 00 00 00	 mov	 edx, 188		; 000000bcH
  0039a	e8 00 00 00 00	 call	 GetCrc32
  0039f	89 44 24 48	 mov	 DWORD PTR headerCrc32$29681[rsp], eax

; 459  : 		fieldPos = header + TC_HEADER_OFFSET_HEADER_CRC;

  003a3	48 8b 44 24 40	 mov	 rax, QWORD PTR header$[rsp]
  003a8	48 05 fc 00 00
	00		 add	 rax, 252		; 000000fcH
  003ae	48 89 44 24 50	 mov	 QWORD PTR fieldPos$29683[rsp], rax

; 460  : 		mputLong (fieldPos, headerCrc32);

  003b3	8b 4c 24 48	 mov	 ecx, DWORD PTR headerCrc32$29681[rsp]
  003b7	c1 e9 18	 shr	 ecx, 24
  003ba	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  003c0	48 8b 44 24 50	 mov	 rax, QWORD PTR fieldPos$29683[rsp]
  003c5	88 08		 mov	 BYTE PTR [rax], cl
  003c7	48 8b 44 24 50	 mov	 rax, QWORD PTR fieldPos$29683[rsp]
  003cc	48 83 c0 01	 add	 rax, 1
  003d0	48 89 44 24 50	 mov	 QWORD PTR fieldPos$29683[rsp], rax
  003d5	8b 4c 24 48	 mov	 ecx, DWORD PTR headerCrc32$29681[rsp]
  003d9	c1 e9 10	 shr	 ecx, 16
  003dc	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  003e2	48 8b 44 24 50	 mov	 rax, QWORD PTR fieldPos$29683[rsp]
  003e7	88 08		 mov	 BYTE PTR [rax], cl
  003e9	48 8b 44 24 50	 mov	 rax, QWORD PTR fieldPos$29683[rsp]
  003ee	48 83 c0 01	 add	 rax, 1
  003f2	48 89 44 24 50	 mov	 QWORD PTR fieldPos$29683[rsp], rax
  003f7	8b 4c 24 48	 mov	 ecx, DWORD PTR headerCrc32$29681[rsp]
  003fb	c1 e9 08	 shr	 ecx, 8
  003fe	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00404	48 8b 44 24 50	 mov	 rax, QWORD PTR fieldPos$29683[rsp]
  00409	88 08		 mov	 BYTE PTR [rax], cl
  0040b	48 8b 44 24 50	 mov	 rax, QWORD PTR fieldPos$29683[rsp]
  00410	48 83 c0 01	 add	 rax, 1
  00414	48 89 44 24 50	 mov	 QWORD PTR fieldPos$29683[rsp], rax
  00419	8b 4c 24 48	 mov	 ecx, DWORD PTR headerCrc32$29681[rsp]
  0041d	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00423	48 8b 44 24 50	 mov	 rax, QWORD PTR fieldPos$29683[rsp]
  00428	88 08		 mov	 BYTE PTR [rax], cl
  0042a	48 8b 44 24 50	 mov	 rax, QWORD PTR fieldPos$29683[rsp]
  0042f	48 83 c0 01	 add	 rax, 1
  00433	48 89 44 24 50	 mov	 QWORD PTR fieldPos$29683[rsp], rax

; 461  : 
; 462  : 		EncryptBuffer (header + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, Extension->HeaderCryptoInfo);

  00438	48 8b 4c 24 40	 mov	 rcx, QWORD PTR header$[rsp]
  0043d	48 83 c1 40	 add	 rcx, 64			; 00000040H
  00441	4c 8b 44 24 70	 mov	 r8, QWORD PTR Extension$[rsp]
  00446	4d 8b 80 30 03
	00 00		 mov	 r8, QWORD PTR [r8+816]
  0044d	ba c0 01 00 00	 mov	 edx, 448		; 000001c0H
  00452	e8 00 00 00 00	 call	 EncryptBuffer
$LN3@SaveDriveV:

; 463  : 	}
; 464  : 
; 465  : 	status = TCWriteDevice (Extension->LowerDeviceObject, header, offset, TC_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE);

  00457	41 b9 00 02 00
	00		 mov	 r9d, 512		; 00000200H
  0045d	4c 8b 44 24 30	 mov	 r8, QWORD PTR offset$[rsp]
  00462	48 8b 54 24 40	 mov	 rdx, QWORD PTR header$[rsp]
  00467	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Extension$[rsp]
  0046c	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00470	e8 00 00 00 00	 call	 TCWriteDevice
  00475	89 44 24 38	 mov	 DWORD PTR status$[rsp], eax

; 466  : 	if (!NT_SUCCESS (status))

  00479	83 7c 24 38 00	 cmp	 DWORD PTR status$[rsp], 0
  0047e	7d 10		 jge	 SHORT $LN1@SaveDriveV

; 467  : 	{
; 468  : 		Dump ("TCWriteDevice error %x", status);

  00480	8b 54 24 38	 mov	 edx, DWORD PTR status$[rsp]
  00484	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@PIJMMLOC@TCWriteDevice?5error?5?$CFx?$AA@FNODOBFM@
  0048b	e8 00 00 00 00	 call	 DbgPrint
$LN1@SaveDriveV:
$ret$29674:

; 469  : 		goto ret;
; 470  : 	}
; 471  : 
; 472  : ret:
; 473  : 	TCfree (header);

  00490	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00495	48 8b 4c 24 40	 mov	 rcx, QWORD PTR header$[rsp]
  0049a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 474  : 	return status;

  004a0	8b 44 24 38	 mov	 eax, DWORD PTR status$[rsp]
$LN9@SaveDriveV:

; 475  : }

  004a4	48 83 c4 60	 add	 rsp, 96			; 00000060H
  004a8	5f		 pop	 rdi
  004a9	c3		 ret	 0
SaveDriveVolumeHeader ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$DecoySystemWipeThreadProc DD imagerel DecoySystemWipeThreadProc
	DD	imagerel DecoySystemWipeThreadProc+1202
	DD	imagerel $unwind$DecoySystemWipeThreadProc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DecoySystemWipeThreadProc DD 050f01H
	DD	012010fH
	DD	060077008H
	DD	03006H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DecoySystemWipeThreadProc
_TEXT	SEGMENT
irql$ = 48
wipePass$ = 52
dataUnit$ = 56
wipeBuffer$ = 64
Extension$ = 72
offset$ = 80
ea$ = 88
wipeRandChars$ = 92
status$ = 96
wipeCryptoInfo$ = 104
wipeBlockSize$ = 112
wipeRandBuffer$ = 120
burnc$30471 = 128
burnm$30469 = 136
threadArg$ = 176
DecoySystemWipeThreadProc PROC				; COMDAT

; 1696 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H

; 1697 : 	DriveFilterExtension *Extension = BootDriveFilterExtension;

  0000f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00016	48 89 44 24 48	 mov	 QWORD PTR Extension$[rsp], rax

; 1698 : 
; 1699 : 	LARGE_INTEGER offset;
; 1700 : 	UINT64_STRUCT dataUnit;
; 1701 : 	ULONG wipeBlockSize = TC_ENCRYPTION_SETUP_IO_BLOCK_SIZE;

  0001b	c7 44 24 70 00
	00 18 00	 mov	 DWORD PTR wipeBlockSize$[rsp], 1572864 ; 00180000H

; 1702 : 
; 1703 : 	CRYPTO_INFO *wipeCryptoInfo = NULL;

  00023	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR wipeCryptoInfo$[rsp], 0

; 1704 : 	byte *wipeBuffer = NULL;

  0002c	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR wipeBuffer$[rsp], 0

; 1705 : 	byte *wipeRandBuffer = NULL;

  00035	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR wipeRandBuffer$[rsp], 0

; 1706 : 	byte wipeRandChars[TC_WIPE_RAND_CHAR_COUNT];
; 1707 : 	int wipePass;
; 1708 : 	int ea = Extension->Queue.CryptoInfo->ea;

  0003e	48 8b 44 24 48	 mov	 rax, QWORD PTR Extension$[rsp]
  00043	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  0004a	8b 00		 mov	 eax, DWORD PTR [rax]
  0004c	89 44 24 58	 mov	 DWORD PTR ea$[rsp], eax

; 1709 : 
; 1710 : 	KIRQL irql;
; 1711 : 	NTSTATUS status;
; 1712 : 
; 1713 : 	DecoySystemWipeResult = STATUS_UNSUCCESSFUL;

  00050	c7 05 00 00 00
	00 01 00 00 c0	 mov	 DWORD PTR DecoySystemWipeResult, -1073741823 ; ffffffffc0000001H

; 1714 : 
; 1715 : 	wipeBuffer = TCalloc (TC_ENCRYPTION_SETUP_IO_BLOCK_SIZE);

  0005a	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  00060	ba 00 00 18 00	 mov	 edx, 1572864		; 00180000H
  00065	33 c9		 xor	 ecx, ecx
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  0006d	48 89 44 24 40	 mov	 QWORD PTR wipeBuffer$[rsp], rax

; 1716 : 	if (!wipeBuffer)

  00072	48 83 7c 24 40
	00		 cmp	 QWORD PTR wipeBuffer$[rsp], 0
  00078	75 0f		 jne	 SHORT $LN26@DecoySyste

; 1717 : 	{
; 1718 : 		DecoySystemWipeResult = STATUS_INSUFFICIENT_RESOURCES;

  0007a	c7 05 00 00 00
	00 9a 00 00 c0	 mov	 DWORD PTR DecoySystemWipeResult, -1073741670 ; ffffffffc000009aH

; 1719 : 		goto ret;

  00084	e9 c6 03 00 00	 jmp	 $ret$30455
$LN26@DecoySyste:

; 1720 : 	}
; 1721 : 	
; 1722 : 	wipeRandBuffer = TCalloc (TC_ENCRYPTION_SETUP_IO_BLOCK_SIZE);

  00089	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  0008f	ba 00 00 18 00	 mov	 edx, 1572864		; 00180000H
  00094	33 c9		 xor	 ecx, ecx
  00096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  0009c	48 89 44 24 78	 mov	 QWORD PTR wipeRandBuffer$[rsp], rax

; 1723 : 	if (!wipeRandBuffer)

  000a1	48 83 7c 24 78
	00		 cmp	 QWORD PTR wipeRandBuffer$[rsp], 0
  000a7	75 0f		 jne	 SHORT $LN25@DecoySyste

; 1724 : 	{
; 1725 : 		DecoySystemWipeResult = STATUS_INSUFFICIENT_RESOURCES;

  000a9	c7 05 00 00 00
	00 9a 00 00 c0	 mov	 DWORD PTR DecoySystemWipeResult, -1073741670 ; ffffffffc000009aH

; 1726 : 		goto ret;

  000b3	e9 97 03 00 00	 jmp	 $ret$30455
$LN25@DecoySyste:

; 1727 : 	}
; 1728 : 
; 1729 : 	wipeCryptoInfo = crypto_open();

  000b8	e8 00 00 00 00	 call	 crypto_open
  000bd	48 89 44 24 68	 mov	 QWORD PTR wipeCryptoInfo$[rsp], rax

; 1730 : 	if (!wipeCryptoInfo)

  000c2	48 83 7c 24 68
	00		 cmp	 QWORD PTR wipeCryptoInfo$[rsp], 0
  000c8	75 0f		 jne	 SHORT $LN24@DecoySyste

; 1731 : 	{
; 1732 : 		DecoySystemWipeResult = STATUS_INSUFFICIENT_RESOURCES;

  000ca	c7 05 00 00 00
	00 9a 00 00 c0	 mov	 DWORD PTR DecoySystemWipeResult, -1073741670 ; ffffffffc000009aH

; 1733 : 		goto ret;

  000d4	e9 76 03 00 00	 jmp	 $ret$30455
$LN24@DecoySyste:

; 1734 : 	}
; 1735 : 
; 1736 : 	wipeCryptoInfo->ea = ea;

  000d9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR wipeCryptoInfo$[rsp]
  000de	8b 44 24 58	 mov	 eax, DWORD PTR ea$[rsp]
  000e2	89 01		 mov	 DWORD PTR [rcx], eax

; 1737 : 	wipeCryptoInfo->mode = Extension->Queue.CryptoInfo->mode;

  000e4	48 8b 44 24 48	 mov	 rax, QWORD PTR Extension$[rsp]
  000e9	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  000f0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR wipeCryptoInfo$[rsp]
  000f5	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  000f8	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 1738 : 
; 1739 : 	if (EAInit (ea, WipeDecoyRequest.WipeKey, wipeCryptoInfo->ks) != ERR_SUCCESS)

  000fb	4c 8b 44 24 68	 mov	 r8, QWORD PTR wipeCryptoInfo$[rsp]
  00100	49 83 c0 08	 add	 r8, 8
  00104	48 8d 15 04 00
	00 00		 lea	 rdx, OFFSET FLAT:WipeDecoyRequest+4
  0010b	8b 4c 24 58	 mov	 ecx, DWORD PTR ea$[rsp]
  0010f	e8 00 00 00 00	 call	 EAInit
  00114	85 c0		 test	 eax, eax
  00116	74 0f		 je	 SHORT $LN23@DecoySyste

; 1740 : 	{
; 1741 : 		DecoySystemWipeResult = STATUS_INVALID_PARAMETER;

  00118	c7 05 00 00 00
	00 0d 00 00 c0	 mov	 DWORD PTR DecoySystemWipeResult, -1073741811 ; ffffffffc000000dH

; 1742 : 		goto ret;

  00122	e9 28 03 00 00	 jmp	 $ret$30455
$LN23@DecoySyste:

; 1743 : 	}
; 1744 : 
; 1745 : 	memcpy (wipeCryptoInfo->k2, WipeDecoyRequest.WipeKey + EAGetKeySize (ea), EAGetKeySize (ea));

  00127	8b 4c 24 58	 mov	 ecx, DWORD PTR ea$[rsp]
  0012b	e8 00 00 00 00	 call	 EAGetKeySize
  00130	48 63 d8	 movsxd	 rbx, eax
  00133	8b 4c 24 58	 mov	 ecx, DWORD PTR ea$[rsp]
  00137	e8 00 00 00 00	 call	 EAGetKeySize
  0013c	48 98		 cdqe
  0013e	48 8d 35 04 00
	00 00		 lea	 rsi, OFFSET FLAT:WipeDecoyRequest+4
  00145	48 03 f0	 add	 rsi, rax
  00148	48 8b 7c 24 68	 mov	 rdi, QWORD PTR wipeCryptoInfo$[rsp]
  0014d	48 81 c7 a8 42
	00 00		 add	 rdi, 17064		; 000042a8H
  00154	48 8b cb	 mov	 rcx, rbx
  00157	f3 a4		 rep movsb

; 1746 : 	
; 1747 : 	if (!EAInitMode (wipeCryptoInfo))

  00159	48 8b 4c 24 68	 mov	 rcx, QWORD PTR wipeCryptoInfo$[rsp]
  0015e	e8 00 00 00 00	 call	 EAInitMode
  00163	85 c0		 test	 eax, eax
  00165	75 0f		 jne	 SHORT $LN22@DecoySyste

; 1748 : 	{
; 1749 : 		DecoySystemWipeResult = STATUS_INVALID_PARAMETER;

  00167	c7 05 00 00 00
	00 0d 00 00 c0	 mov	 DWORD PTR DecoySystemWipeResult, -1073741811 ; ffffffffc000000dH

; 1750 : 		goto err;

  00171	e9 7c 02 00 00	 jmp	 $err$30465
$LN22@DecoySyste:

; 1751 : 	}
; 1752 : 
; 1753 : 	EncryptDataUnits (wipeRandBuffer, &dataUnit, wipeBlockSize / ENCRYPTION_DATA_UNIT_SIZE, wipeCryptoInfo);

  00176	33 d2		 xor	 edx, edx
  00178	8b 44 24 70	 mov	 eax, DWORD PTR wipeBlockSize$[rsp]
  0017c	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00181	f7 f1		 div	 ecx
  00183	4c 8b 4c 24 68	 mov	 r9, QWORD PTR wipeCryptoInfo$[rsp]
  00188	44 8b c0	 mov	 r8d, eax
  0018b	48 8d 54 24 38	 lea	 rdx, QWORD PTR dataUnit$[rsp]
  00190	48 8b 4c 24 78	 mov	 rcx, QWORD PTR wipeRandBuffer$[rsp]
  00195	e8 00 00 00 00	 call	 EncryptDataUnits

; 1754 : 	memcpy (wipeRandChars, wipeRandBuffer, sizeof (wipeRandChars));

  0019a	48 8d 7c 24 5c	 lea	 rdi, QWORD PTR wipeRandChars$[rsp]
  0019f	48 8b 74 24 78	 mov	 rsi, QWORD PTR wipeRandBuffer$[rsp]
  001a4	b9 03 00 00 00	 mov	 ecx, 3
  001a9	f3 a4		 rep movsb
$LN21@DecoySyste:

; 1755 : 
; 1756 : 	burn (WipeDecoyRequest.WipeKey, sizeof (WipeDecoyRequest.WipeKey));

  001ab	48 8d 05 04 00
	00 00		 lea	 rax, OFFSET FLAT:WipeDecoyRequest+4
  001b2	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR burnm$30469[rsp], rax
  001ba	c7 84 24 80 00
	00 00 00 01 00
	00		 mov	 DWORD PTR burnc$30471[rsp], 256 ; 00000100H
  001c5	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  001ca	48 8d 0d 04 00
	00 00		 lea	 rcx, OFFSET FLAT:WipeDecoyRequest+4
  001d1	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN18@DecoySyste:
  001d6	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR burnc$30471[rsp]
  001dd	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR burnc$30471[rsp]
  001e4	83 e8 01	 sub	 eax, 1
  001e7	89 84 24 80 00
	00 00		 mov	 DWORD PTR burnc$30471[rsp], eax
  001ee	85 c9		 test	 ecx, ecx
  001f0	74 21		 je	 SHORT $LN17@DecoySyste
  001f2	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR burnm$30469[rsp]
  001fa	c6 00 00	 mov	 BYTE PTR [rax], 0
  001fd	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR burnm$30469[rsp]
  00205	48 83 c0 01	 add	 rax, 1
  00209	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR burnm$30469[rsp], rax
  00211	eb c3		 jmp	 SHORT $LN18@DecoySyste
$LN17@DecoySyste:
  00213	33 c0		 xor	 eax, eax
  00215	85 c0		 test	 eax, eax
  00217	75 92		 jne	 SHORT $LN21@DecoySyste

; 1757 : 
; 1758 : 	offset.QuadPart = Extension->ConfiguredEncryptedAreaStart;

  00219	48 8b 44 24 48	 mov	 rax, QWORD PTR Extension$[rsp]
  0021e	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00222	48 89 44 24 50	 mov	 QWORD PTR offset$[rsp], rax

; 1759 : 		
; 1760 : 	Dump ("Wiping decoy system:  start offset = %I64d\n", offset.QuadPart);

  00227	48 8b 54 24 50	 mov	 rdx, QWORD PTR offset$[rsp]
  0022c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CM@PJEGGJLG@Wiping?5decoy?5system?3?5?5start?5offs@FNODOBFM@
  00233	e8 00 00 00 00	 call	 DbgPrint
$LN16@DecoySyste:

; 1761 : 
; 1762 : 	while (!DecoySystemWipeThreadAbortRequested)

  00238	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR DecoySystemWipeThreadAbortRequested
  0023e	85 c0		 test	 eax, eax
  00240	0f 85 a2 01 00
	00		 jne	 $LN15@DecoySyste

; 1763 : 	{
; 1764 : 		if (offset.QuadPart + wipeBlockSize > Extension->ConfiguredEncryptedAreaEnd + 1)

  00246	8b 44 24 70	 mov	 eax, DWORD PTR wipeBlockSize$[rsp]
  0024a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR offset$[rsp]
  0024f	48 03 c8	 add	 rcx, rax
  00252	48 8b 44 24 48	 mov	 rax, QWORD PTR Extension$[rsp]
  00257	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0025b	48 83 c0 01	 add	 rax, 1
  0025f	48 3b c8	 cmp	 rcx, rax
  00262	7e 16		 jle	 SHORT $LN14@DecoySyste

; 1765 : 			wipeBlockSize = (ULONG) (Extension->ConfiguredEncryptedAreaEnd + 1 - offset.QuadPart);

  00264	48 8b 44 24 48	 mov	 rax, QWORD PTR Extension$[rsp]
  00269	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0026d	48 83 c0 01	 add	 rax, 1
  00271	48 2b 44 24 50	 sub	 rax, QWORD PTR offset$[rsp]
  00276	89 44 24 70	 mov	 DWORD PTR wipeBlockSize$[rsp], eax
$LN14@DecoySyste:

; 1766 : 
; 1767 : 		if (offset.QuadPart > Extension->ConfiguredEncryptedAreaEnd)

  0027a	48 8b 44 24 48	 mov	 rax, QWORD PTR Extension$[rsp]
  0027f	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00283	48 39 44 24 50	 cmp	 QWORD PTR offset$[rsp], rax
  00288	7e 05		 jle	 SHORT $LN13@DecoySyste

; 1768 : 			break;

  0028a	e9 59 01 00 00	 jmp	 $LN15@DecoySyste
$LN13@DecoySyste:

; 1769 : 
; 1770 : 		for (wipePass = 1; wipePass <= GetWipePassCount (WipeDecoyRequest.WipeAlgorithm); ++wipePass)

  0028f	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR wipePass$[rsp], 1
  00297	eb 0b		 jmp	 SHORT $LN12@DecoySyste
$LN11@DecoySyste:
  00299	8b 44 24 34	 mov	 eax, DWORD PTR wipePass$[rsp]
  0029d	83 c0 01	 add	 eax, 1
  002a0	89 44 24 34	 mov	 DWORD PTR wipePass$[rsp], eax
$LN12@DecoySyste:
  002a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR WipeDecoyRequest
  002aa	e8 00 00 00 00	 call	 GetWipePassCount
  002af	39 44 24 34	 cmp	 DWORD PTR wipePass$[rsp], eax
  002b3	0f 8f e6 00 00
	00		 jg	 $LN10@DecoySyste

; 1771 : 		{
; 1772 : 			if (!WipeBuffer (WipeDecoyRequest.WipeAlgorithm, wipeRandChars, wipePass, wipeBuffer, wipeBlockSize))

  002b9	8b 44 24 70	 mov	 eax, DWORD PTR wipeBlockSize$[rsp]
  002bd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c2	4c 8b 4c 24 40	 mov	 r9, QWORD PTR wipeBuffer$[rsp]
  002c7	44 8b 44 24 34	 mov	 r8d, DWORD PTR wipePass$[rsp]
  002cc	48 8d 54 24 5c	 lea	 rdx, QWORD PTR wipeRandChars$[rsp]
  002d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR WipeDecoyRequest
  002d7	e8 00 00 00 00	 call	 WipeBuffer
  002dc	85 c0		 test	 eax, eax
  002de	75 4e		 jne	 SHORT $LN9@DecoySyste

; 1773 : 			{
; 1774 : 				dataUnit.Value = offset.QuadPart / ENCRYPTION_DATA_UNIT_SIZE;

  002e0	48 8b 44 24 50	 mov	 rax, QWORD PTR offset$[rsp]
  002e5	48 99		 cdq
  002e7	48 81 e2 ff 01
	00 00		 and	 rdx, 511		; 000001ffH
  002ee	48 03 c2	 add	 rax, rdx
  002f1	48 c1 f8 09	 sar	 rax, 9
  002f5	48 89 44 24 38	 mov	 QWORD PTR dataUnit$[rsp], rax

; 1775 : 				EncryptDataUnits (wipeRandBuffer, &dataUnit, wipeBlockSize / ENCRYPTION_DATA_UNIT_SIZE, wipeCryptoInfo);

  002fa	33 d2		 xor	 edx, edx
  002fc	8b 44 24 70	 mov	 eax, DWORD PTR wipeBlockSize$[rsp]
  00300	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00305	f7 f1		 div	 ecx
  00307	4c 8b 4c 24 68	 mov	 r9, QWORD PTR wipeCryptoInfo$[rsp]
  0030c	44 8b c0	 mov	 r8d, eax
  0030f	48 8d 54 24 38	 lea	 rdx, QWORD PTR dataUnit$[rsp]
  00314	48 8b 4c 24 78	 mov	 rcx, QWORD PTR wipeRandBuffer$[rsp]
  00319	e8 00 00 00 00	 call	 EncryptDataUnits

; 1776 : 				memcpy (wipeBuffer, wipeRandBuffer, wipeBlockSize);

  0031e	8b 4c 24 70	 mov	 ecx, DWORD PTR wipeBlockSize$[rsp]
  00322	48 8b 7c 24 40	 mov	 rdi, QWORD PTR wipeBuffer$[rsp]
  00327	48 8b 74 24 78	 mov	 rsi, QWORD PTR wipeRandBuffer$[rsp]
  0032c	f3 a4		 rep movsb
$LN9@DecoySyste:
$LN8@DecoySyste:

; 1777 : 			}
; 1778 : 
; 1779 : 			while (!NT_SUCCESS (EncryptedIoQueueHoldWhenIdle (&Extension->Queue, 500)))

  0032e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Extension$[rsp]
  00333	48 83 c1 50	 add	 rcx, 80			; 00000050H
  00337	ba f4 01 00 00	 mov	 edx, 500		; 000001f4H
  0033c	e8 00 00 00 00	 call	 EncryptedIoQueueHoldWhenIdle
  00341	85 c0		 test	 eax, eax
  00343	7d 11		 jge	 SHORT $LN7@DecoySyste

; 1780 : 			{
; 1781 : 				if (DecoySystemWipeThreadAbortRequested)

  00345	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR DecoySystemWipeThreadAbortRequested
  0034b	85 c0		 test	 eax, eax
  0034d	74 05		 je	 SHORT $LN6@DecoySyste

; 1782 : 					goto abort;

  0034f	e9 94 00 00 00	 jmp	 $abort$30491
$LN6@DecoySyste:

; 1783 : 			}

  00354	eb d8		 jmp	 SHORT $LN8@DecoySyste
$LN7@DecoySyste:

; 1784 : 
; 1785 : 			status = TCWriteDevice (BootDriveFilterExtension->LowerDeviceObject, wipeBuffer, offset, wipeBlockSize);

  00356	44 8b 4c 24 70	 mov	 r9d, DWORD PTR wipeBlockSize$[rsp]
  0035b	4c 8b 44 24 50	 mov	 r8, QWORD PTR offset$[rsp]
  00360	48 8b 54 24 40	 mov	 rdx, QWORD PTR wipeBuffer$[rsp]
  00365	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR BootDriveFilterExtension
  0036c	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00370	e8 00 00 00 00	 call	 TCWriteDevice
  00375	89 44 24 60	 mov	 DWORD PTR status$[rsp], eax

; 1786 : 
; 1787 : 			if (!NT_SUCCESS (status))

  00379	83 7c 24 60 00	 cmp	 DWORD PTR status$[rsp], 0
  0037e	7d 0c		 jge	 SHORT $LN5@DecoySyste

; 1788 : 			{
; 1789 : 				DecoySystemWipeResult = status;

  00380	8b 44 24 60	 mov	 eax, DWORD PTR status$[rsp]
  00384	89 05 00 00 00
	00		 mov	 DWORD PTR DecoySystemWipeResult, eax

; 1790 : 				goto err;

  0038a	eb 66		 jmp	 SHORT $err$30465
$LN5@DecoySyste:

; 1791 : 			}
; 1792 : 
; 1793 : 			EncryptedIoQueueResumeFromHold (&Extension->Queue);

  0038c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Extension$[rsp]
  00391	48 83 c1 50	 add	 rcx, 80			; 00000050H
  00395	e8 00 00 00 00	 call	 EncryptedIoQueueResumeFromHold

; 1794 : 		}

  0039a	e9 fa fe ff ff	 jmp	 $LN11@DecoySyste
$LN10@DecoySyste:

; 1795 : 
; 1796 : 		offset.QuadPart += wipeBlockSize;

  0039f	8b 4c 24 70	 mov	 ecx, DWORD PTR wipeBlockSize$[rsp]
  003a3	48 8b 44 24 50	 mov	 rax, QWORD PTR offset$[rsp]
  003a8	48 03 c1	 add	 rax, rcx
  003ab	48 89 44 24 50	 mov	 QWORD PTR offset$[rsp], rax

; 1797 : 
; 1798 : 		KeAcquireSpinLock (&DecoySystemWipeStatusSpinLock, &irql);

  003b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:DecoySystemWipeStatusSpinLock
  003b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeAcquireSpinLockRaiseToDpc
  003bd	88 44 24 30	 mov	 BYTE PTR irql$[rsp], al

; 1799 : 		DecoySystemWipedAreaEnd = offset.QuadPart - 1;

  003c1	48 8b 44 24 50	 mov	 rax, QWORD PTR offset$[rsp]
  003c6	48 83 e8 01	 sub	 rax, 1
  003ca	48 89 05 00 00
	00 00		 mov	 QWORD PTR DecoySystemWipedAreaEnd, rax

; 1800 : 		KeReleaseSpinLock (&DecoySystemWipeStatusSpinLock, irql);

  003d1	0f b6 54 24 30	 movzx	 edx, BYTE PTR irql$[rsp]
  003d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:DecoySystemWipeStatusSpinLock
  003dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseSpinLock

; 1801 : 	}

  003e3	e9 50 fe ff ff	 jmp	 $LN16@DecoySyste
$LN15@DecoySyste:
$abort$30491:

; 1802 : 
; 1803 : abort:
; 1804 : 	DecoySystemWipeResult = STATUS_SUCCESS;

  003e8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR DecoySystemWipeResult, 0
$err$30465:

; 1805 : err:
; 1806 : 
; 1807 : 	if (EncryptedIoQueueIsSuspended (&Extension->Queue))

  003f2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Extension$[rsp]
  003f7	48 83 c1 50	 add	 rcx, 80			; 00000050H
  003fb	e8 00 00 00 00	 call	 EncryptedIoQueueIsSuspended
  00400	85 c0		 test	 eax, eax
  00402	74 0e		 je	 SHORT $LN4@DecoySyste

; 1808 : 		EncryptedIoQueueResumeFromHold (&Extension->Queue);

  00404	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Extension$[rsp]
  00409	48 83 c1 50	 add	 rcx, 80			; 00000050H
  0040d	e8 00 00 00 00	 call	 EncryptedIoQueueResumeFromHold
$LN4@DecoySyste:

; 1809 : 
; 1810 : 	Dump ("Wipe end: DecoySystemWipedAreaEnd=%I64d (%I64d)\n", DecoySystemWipedAreaEnd, DecoySystemWipedAreaEnd / 1024 / 1024);

  00412	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR DecoySystemWipedAreaEnd
  00419	48 99		 cdq
  0041b	48 81 e2 ff 03
	00 00		 and	 rdx, 1023		; 000003ffH
  00422	48 03 c2	 add	 rax, rdx
  00425	48 c1 f8 0a	 sar	 rax, 10
  00429	48 99		 cdq
  0042b	48 81 e2 ff 03
	00 00		 and	 rdx, 1023		; 000003ffH
  00432	48 03 c2	 add	 rax, rdx
  00435	48 c1 f8 0a	 sar	 rax, 10
  00439	4c 8b c0	 mov	 r8, rax
  0043c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR DecoySystemWipedAreaEnd
  00443	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DB@OHMKNOCN@Wipe?5end?3?5DecoySystemWipedAreaEn@FNODOBFM@
  0044a	e8 00 00 00 00	 call	 DbgPrint
$ret$30455:

; 1811 : 
; 1812 : ret:
; 1813 : 	if (wipeCryptoInfo)

  0044f	48 83 7c 24 68
	00		 cmp	 QWORD PTR wipeCryptoInfo$[rsp], 0
  00455	74 0a		 je	 SHORT $LN3@DecoySyste

; 1814 : 		crypto_close (wipeCryptoInfo);

  00457	48 8b 4c 24 68	 mov	 rcx, QWORD PTR wipeCryptoInfo$[rsp]
  0045c	e8 00 00 00 00	 call	 crypto_close
$LN3@DecoySyste:

; 1815 : 
; 1816 : 	if (wipeRandBuffer)

  00461	48 83 7c 24 78
	00		 cmp	 QWORD PTR wipeRandBuffer$[rsp], 0
  00467	74 10		 je	 SHORT $LN2@DecoySyste

; 1817 : 		TCfree (wipeRandBuffer);

  00469	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  0046e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR wipeRandBuffer$[rsp]
  00473	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN2@DecoySyste:

; 1818 : 
; 1819 : 	if (wipeBuffer)

  00479	48 83 7c 24 40
	00		 cmp	 QWORD PTR wipeBuffer$[rsp], 0
  0047f	74 10		 je	 SHORT $LN1@DecoySyste

; 1820 : 		TCfree (wipeBuffer);

  00481	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00486	48 8b 4c 24 40	 mov	 rcx, QWORD PTR wipeBuffer$[rsp]
  0048b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN1@DecoySyste:

; 1821 : 
; 1822 : 	DecoySystemWipeInProgress = FALSE;

  00491	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR DecoySystemWipeInProgress, 0

; 1823 : 	PsTerminateSystemThread (DecoySystemWipeResult);

  0049b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR DecoySystemWipeResult
  004a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsTerminateSystemThread

; 1824 : }

  004a7	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  004ae	5f		 pop	 rdi
  004af	5e		 pop	 rsi
  004b0	5b		 pop	 rbx
  004b1	c3		 ret	 0
DecoySystemWipeThreadProc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SetupThreadProc DD imagerel SetupThreadProc
	DD	imagerel SetupThreadProc+2965
	DD	imagerel $unwind$SetupThreadProc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SetupThreadProc DD 040e01H
	DD	015010eH
	DD	060067007H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT SetupThreadProc
_TEXT	SEGMENT
irql$ = 48
wipeRandCharsUpdate$ = 52
dataUnit$ = 56
wipeBuffer$ = 64
headerUpdateRequired$ = 72
setupBlockSize$ = 76
Extension$ = 80
bytesWrittenSinceHeaderUpdate$ = 88
offset$ = 96
wipeRandChars$ = 104
status$ = 108
buffer$ = 112
zeroedSectorCount$30283 = 120
badSectorCount$30290 = 128
wipePass$30296 = 136
i$30301 = 140
tv85 = 144
tv373 = 148
threadArg$ = 192
SetupThreadProc PROC					; COMDAT

; 1154 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 1155 : 	DriveFilterExtension *Extension = BootDriveFilterExtension;

  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00015	48 89 44 24 50	 mov	 QWORD PTR Extension$[rsp], rax

; 1156 : 
; 1157 : 	LARGE_INTEGER offset;
; 1158 : 	UINT64_STRUCT dataUnit;
; 1159 : 	ULONG setupBlockSize = TC_ENCRYPTION_SETUP_IO_BLOCK_SIZE;

  0001a	c7 44 24 4c 00
	00 18 00	 mov	 DWORD PTR setupBlockSize$[rsp], 1572864 ; 00180000H

; 1160 : 	BOOL headerUpdateRequired = FALSE;

  00022	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR headerUpdateRequired$[rsp], 0

; 1161 : 	int64 bytesWrittenSinceHeaderUpdate = 0;

  0002a	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR bytesWrittenSinceHeaderUpdate$[rsp], 0

; 1162 : 
; 1163 : 	byte *buffer = NULL;

  00033	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 1164 : 	byte *wipeBuffer = NULL;

  0003c	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR wipeBuffer$[rsp], 0

; 1165 : 	byte wipeRandChars[TC_WIPE_RAND_CHAR_COUNT];
; 1166 : 	byte wipeRandCharsUpdate[TC_WIPE_RAND_CHAR_COUNT];
; 1167 : 	
; 1168 : 	KIRQL irql;
; 1169 : 	NTSTATUS status;
; 1170 : 
; 1171 : 	SetupResult = STATUS_UNSUCCESSFUL;

  00045	c7 05 00 00 00
	00 01 00 00 c0	 mov	 DWORD PTR SetupResult, -1073741823 ; ffffffffc0000001H

; 1172 : 
; 1173 : 	// Make sure volume header can be updated
; 1174 : 	if (Extension->HeaderCryptoInfo == NULL)

  0004f	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  00054	48 83 b8 30 03
	00 00 00	 cmp	 QWORD PTR [rax+816], 0
  0005c	75 0f		 jne	 SHORT $LN67@SetupThrea

; 1175 : 	{
; 1176 : 		SetupResult = STATUS_INVALID_PARAMETER;

  0005e	c7 05 00 00 00
	00 0d 00 00 c0	 mov	 DWORD PTR SetupResult, -1073741811 ; ffffffffc000000dH

; 1177 : 		goto ret;

  00068	e9 d8 0a 00 00	 jmp	 $ret$30225
$LN67@SetupThrea:

; 1178 : 	}
; 1179 : 
; 1180 : 	buffer = TCalloc (TC_ENCRYPTION_SETUP_IO_BLOCK_SIZE);

  0006d	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  00073	ba 00 00 18 00	 mov	 edx, 1572864		; 00180000H
  00078	33 c9		 xor	 ecx, ecx
  0007a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00080	48 89 44 24 70	 mov	 QWORD PTR buffer$[rsp], rax

; 1181 : 	if (!buffer)

  00085	48 83 7c 24 70
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  0008b	75 0f		 jne	 SHORT $LN66@SetupThrea

; 1182 : 	{
; 1183 : 		SetupResult = STATUS_INSUFFICIENT_RESOURCES;

  0008d	c7 05 00 00 00
	00 9a 00 00 c0	 mov	 DWORD PTR SetupResult, -1073741670 ; ffffffffc000009aH

; 1184 : 		goto ret;

  00097	e9 a9 0a 00 00	 jmp	 $ret$30225
$LN66@SetupThrea:

; 1185 : 	}
; 1186 : 
; 1187 : 	if (SetupRequest.SetupMode == SetupEncryption && SetupRequest.WipeAlgorithm != TC_WIPE_NONE)

  0009c	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR SetupRequest, 1
  000a3	75 38		 jne	 SHORT $LN65@SetupThrea
  000a5	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR SetupRequest+4, 0
  000ac	74 2f		 je	 SHORT $LN65@SetupThrea

; 1188 : 	{
; 1189 : 		wipeBuffer = TCalloc (TC_ENCRYPTION_SETUP_IO_BLOCK_SIZE);

  000ae	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  000b4	ba 00 00 18 00	 mov	 edx, 1572864		; 00180000H
  000b9	33 c9		 xor	 ecx, ecx
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  000c1	48 89 44 24 40	 mov	 QWORD PTR wipeBuffer$[rsp], rax

; 1190 : 		if (!wipeBuffer)

  000c6	48 83 7c 24 40
	00		 cmp	 QWORD PTR wipeBuffer$[rsp], 0
  000cc	75 0f		 jne	 SHORT $LN64@SetupThrea

; 1191 : 		{
; 1192 : 			SetupResult = STATUS_INSUFFICIENT_RESOURCES;

  000ce	c7 05 00 00 00
	00 9a 00 00 c0	 mov	 DWORD PTR SetupResult, -1073741670 ; ffffffffc000009aH

; 1193 : 			goto ret;

  000d8	e9 68 0a 00 00	 jmp	 $ret$30225
$LN64@SetupThrea:
$LN65@SetupThrea:
$LN63@SetupThrea:

; 1194 : 		}
; 1195 : 	}
; 1196 : 
; 1197 : 	while (!NT_SUCCESS (EncryptedIoQueueHoldWhenIdle (&Extension->Queue, 1000)))

  000dd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Extension$[rsp]
  000e2	48 83 c1 50	 add	 rcx, 80			; 00000050H
  000e6	ba e8 03 00 00	 mov	 edx, 1000		; 000003e8H
  000eb	e8 00 00 00 00	 call	 EncryptedIoQueueHoldWhenIdle
  000f0	85 c0		 test	 eax, eax
  000f2	7d 1b		 jge	 SHORT $LN62@SetupThrea

; 1198 : 	{
; 1199 : 		if (EncryptionSetupThreadAbortRequested)

  000f4	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR EncryptionSetupThreadAbortRequested
  000fa	85 c0		 test	 eax, eax
  000fc	74 05		 je	 SHORT $LN61@SetupThrea

; 1200 : 			goto abort;

  000fe	e9 4c 08 00 00	 jmp	 $abort$30238
$LN61@SetupThrea:

; 1201 : 
; 1202 : 		TransformWaitingForIdle = TRUE;

  00103	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR TransformWaitingForIdle, 1

; 1203 : 	}

  0010d	eb ce		 jmp	 SHORT $LN63@SetupThrea
$LN62@SetupThrea:

; 1204 : 	TransformWaitingForIdle = FALSE;

  0010f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR TransformWaitingForIdle, 0

; 1205 : 
; 1206 : 	switch (SetupRequest.SetupMode)

  00119	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR SetupRequest
  0011f	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv85[rsp], eax
  00126	83 bc 24 90 00
	00 00 01	 cmp	 DWORD PTR tv85[rsp], 1
  0012e	74 13		 je	 SHORT $LN58@SetupThrea
  00130	83 bc 24 90 00
	00 00 02	 cmp	 DWORD PTR tv85[rsp], 2
  00138	0f 84 9a 00 00
	00		 je	 $LN53@SetupThrea
  0013e	e9 e8 00 00 00	 jmp	 $LN50@SetupThrea
$LN58@SetupThrea:

; 1207 : 	{
; 1208 : 	case SetupEncryption:
; 1209 : 		Dump ("Encrypting...\n");

  00143	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@MEMLEIEJ@Encrypting?4?4?4?6?$AA@FNODOBFM@
  0014a	e8 00 00 00 00	 call	 DbgPrint

; 1210 : 		if (Extension->Queue.EncryptedAreaStart == -1 || Extension->Queue.EncryptedAreaEnd == -1)

  0014f	48 8b 54 24 50	 mov	 rdx, QWORD PTR Extension$[rsp]
  00154	48 83 ba c8 00
	00 00 ff	 cmp	 QWORD PTR [rdx+200], -1
  0015c	74 12		 je	 SHORT $LN56@SetupThrea
  0015e	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  00163	48 8b 80 d0 00
	00 00		 mov	 rax, QWORD PTR [rax+208]
  0016a	48 83 f8 ff	 cmp	 rax, -1
  0016e	75 35		 jne	 SHORT $LN57@SetupThrea
$LN56@SetupThrea:

; 1211 : 		{
; 1212 : 			// Start encryption
; 1213 : 			Extension->Queue.EncryptedAreaStart = Extension->ConfiguredEncryptedAreaStart;

  00170	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Extension$[rsp]
  00175	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  0017a	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0017e	48 89 81 c8 00
	00 00		 mov	 QWORD PTR [rcx+200], rax

; 1214 : 			Extension->Queue.EncryptedAreaEnd = -1;

  00185	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  0018a	48 c7 80 d0 00
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rax+208], -1

; 1215 : 			offset.QuadPart = Extension->ConfiguredEncryptedAreaStart;

  00195	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  0019a	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0019e	48 89 44 24 60	 mov	 QWORD PTR offset$[rsp], rax

; 1216 : 		}
; 1217 : 		else

  001a3	eb 31		 jmp	 SHORT $LN55@SetupThrea
$LN57@SetupThrea:

; 1218 : 		{
; 1219 : 			// Resume aborted encryption
; 1220 : 			if (Extension->Queue.EncryptedAreaEnd == Extension->ConfiguredEncryptedAreaEnd)

  001a5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Extension$[rsp]
  001aa	48 8b 89 d0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+208]
  001b1	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  001b6	48 3b 48 40	 cmp	 rcx, QWORD PTR [rax+64]
  001ba	75 05		 jne	 SHORT $LN54@SetupThrea

; 1221 : 				goto err;

  001bc	e9 98 07 00 00	 jmp	 $err$30249
$LN54@SetupThrea:

; 1222 : 
; 1223 : 			offset.QuadPart = Extension->Queue.EncryptedAreaEnd + 1;

  001c1	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  001c6	48 8b 80 d0 00
	00 00		 mov	 rax, QWORD PTR [rax+208]
  001cd	48 83 c0 01	 add	 rax, 1
  001d1	48 89 44 24 60	 mov	 QWORD PTR offset$[rsp], rax
$LN55@SetupThrea:

; 1224 : 		}
; 1225 : 
; 1226 : 		break;

  001d6	eb 58		 jmp	 SHORT $LN59@SetupThrea
$LN53@SetupThrea:

; 1227 : 
; 1228 : 	case SetupDecryption:
; 1229 : 		Dump ("Decrypting...\n");

  001d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@DCAIKIEM@Decrypting?4?4?4?6?$AA@FNODOBFM@
  001df	e8 00 00 00 00	 call	 DbgPrint

; 1230 : 		if (Extension->Queue.EncryptedAreaStart == -1 || Extension->Queue.EncryptedAreaEnd == -1)

  001e4	48 8b 54 24 50	 mov	 rdx, QWORD PTR Extension$[rsp]
  001e9	48 83 ba c8 00
	00 00 ff	 cmp	 QWORD PTR [rdx+200], -1
  001f1	74 12		 je	 SHORT $LN51@SetupThrea
  001f3	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  001f8	48 8b 80 d0 00
	00 00		 mov	 rax, QWORD PTR [rax+208]
  001ff	48 83 f8 ff	 cmp	 rax, -1
  00203	75 0f		 jne	 SHORT $LN52@SetupThrea
$LN51@SetupThrea:

; 1231 : 		{
; 1232 : 			SetupResult = STATUS_SUCCESS;

  00205	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR SetupResult, 0

; 1233 : 			goto abort;

  0020f	e9 3b 07 00 00	 jmp	 $abort$30238
$LN52@SetupThrea:

; 1234 : 		}
; 1235 : 
; 1236 : 		offset.QuadPart = Extension->Queue.EncryptedAreaEnd + 1;

  00214	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  00219	48 8b 80 d0 00
	00 00		 mov	 rax, QWORD PTR [rax+208]
  00220	48 83 c0 01	 add	 rax, 1
  00224	48 89 44 24 60	 mov	 QWORD PTR offset$[rsp], rax

; 1237 : 		break;

  00229	eb 05		 jmp	 SHORT $LN59@SetupThrea
$LN50@SetupThrea:

; 1238 : 
; 1239 : 	default:
; 1240 : 		goto err;

  0022b	e9 29 07 00 00	 jmp	 $err$30249
$LN59@SetupThrea:

; 1241 : 	}
; 1242 : 
; 1243 : 	EncryptedIoQueueResumeFromHold (&Extension->Queue);

  00230	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Extension$[rsp]
  00235	48 83 c1 50	 add	 rcx, 80			; 00000050H
  00239	e8 00 00 00 00	 call	 EncryptedIoQueueResumeFromHold

; 1244 : 		
; 1245 : 	Dump ("EncryptedAreaStart=%I64d\n", Extension->Queue.EncryptedAreaStart);

  0023e	48 8b 54 24 50	 mov	 rdx, QWORD PTR Extension$[rsp]
  00243	48 8b 92 c8 00
	00 00		 mov	 rdx, QWORD PTR [rdx+200]
  0024a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@NLGNMKFH@EncryptedAreaStart?$DN?$CFI64d?6?$AA@FNODOBFM@
  00251	e8 00 00 00 00	 call	 DbgPrint

; 1246 : 	Dump ("EncryptedAreaEnd=%I64d\n", Extension->Queue.EncryptedAreaEnd);

  00256	48 8b 54 24 50	 mov	 rdx, QWORD PTR Extension$[rsp]
  0025b	48 8b 92 d0 00
	00 00		 mov	 rdx, QWORD PTR [rdx+208]
  00262	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@NGOBDECI@EncryptedAreaEnd?$DN?$CFI64d?6?$AA@FNODOBFM@
  00269	e8 00 00 00 00	 call	 DbgPrint

; 1247 : 	Dump ("ConfiguredEncryptedAreaStart=%I64d\n", Extension->ConfiguredEncryptedAreaStart);

  0026e	48 8b 54 24 50	 mov	 rdx, QWORD PTR Extension$[rsp]
  00273	48 8b 52 38	 mov	 rdx, QWORD PTR [rdx+56]
  00277	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@PHJPGEOK@ConfiguredEncryptedAreaStart?$DN?$CFI6@FNODOBFM@
  0027e	e8 00 00 00 00	 call	 DbgPrint

; 1248 : 	Dump ("ConfiguredEncryptedAreaEnd=%I64d\n", Extension->ConfiguredEncryptedAreaEnd);

  00283	48 8b 54 24 50	 mov	 rdx, QWORD PTR Extension$[rsp]
  00288	48 8b 52 40	 mov	 rdx, QWORD PTR [rdx+64]
  0028c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@FCINBIJC@ConfiguredEncryptedAreaEnd?$DN?$CFI64d@FNODOBFM@
  00293	e8 00 00 00 00	 call	 DbgPrint

; 1249 : 	Dump ("offset=%I64d\n", offset.QuadPart);

  00298	48 8b 54 24 60	 mov	 rdx, QWORD PTR offset$[rsp]
  0029d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@CPDGLKAG@offset?$DN?$CFI64d?6?$AA@FNODOBFM@
  002a4	e8 00 00 00 00	 call	 DbgPrint

; 1250 : 	Dump ("EncryptedAreaStart=%I64d (%I64d)  EncryptedAreaEnd=%I64d\n", Extension->Queue.EncryptedAreaStart / 1024 / 1024, Extension->Queue.EncryptedAreaStart, Extension->Queue.EncryptedAreaEnd / 1024 / 1024);

  002a9	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  002ae	48 8b 80 d0 00
	00 00		 mov	 rax, QWORD PTR [rax+208]
  002b5	48 99		 cdq
  002b7	48 81 e2 ff 03
	00 00		 and	 rdx, 1023		; 000003ffH
  002be	48 03 c2	 add	 rax, rdx
  002c1	48 c1 f8 0a	 sar	 rax, 10
  002c5	48 99		 cdq
  002c7	48 81 e2 ff 03
	00 00		 and	 rdx, 1023		; 000003ffH
  002ce	48 03 c2	 add	 rax, rdx
  002d1	48 c1 f8 0a	 sar	 rax, 10
  002d5	4c 8b c8	 mov	 r9, rax
  002d8	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  002dd	48 8b 80 c8 00
	00 00		 mov	 rax, QWORD PTR [rax+200]
  002e4	48 99		 cdq
  002e6	48 81 e2 ff 03
	00 00		 and	 rdx, 1023		; 000003ffH
  002ed	48 03 c2	 add	 rax, rdx
  002f0	48 c1 f8 0a	 sar	 rax, 10
  002f4	48 99		 cdq
  002f6	48 81 e2 ff 03
	00 00		 and	 rdx, 1023		; 000003ffH
  002fd	48 03 c2	 add	 rax, rdx
  00300	48 c1 f8 0a	 sar	 rax, 10
  00304	4c 8b 44 24 50	 mov	 r8, QWORD PTR Extension$[rsp]
  00309	4d 8b 80 c8 00
	00 00		 mov	 r8, QWORD PTR [r8+200]
  00310	48 8b d0	 mov	 rdx, rax
  00313	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DK@GDPNMFEK@EncryptedAreaStart?$DN?$CFI64d?5?$CI?$CFI64d?$CJ@FNODOBFM@
  0031a	e8 00 00 00 00	 call	 DbgPrint
$LN49@SetupThrea:

; 1251 : 
; 1252 : 	while (!EncryptionSetupThreadAbortRequested)

  0031f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR EncryptionSetupThreadAbortRequested
  00325	85 c0		 test	 eax, eax
  00327	0f 85 22 06 00
	00		 jne	 $LN48@SetupThrea

; 1253 : 	{
; 1254 : 		if (SetupRequest.SetupMode == SetupEncryption)

  0032d	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR SetupRequest, 1
  00334	75 4b		 jne	 SHORT $LN47@SetupThrea

; 1255 : 		{
; 1256 : 			if (offset.QuadPart + setupBlockSize > Extension->ConfiguredEncryptedAreaEnd + 1)

  00336	8b 44 24 4c	 mov	 eax, DWORD PTR setupBlockSize$[rsp]
  0033a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR offset$[rsp]
  0033f	48 03 c8	 add	 rcx, rax
  00342	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  00347	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0034b	48 83 c0 01	 add	 rax, 1
  0034f	48 3b c8	 cmp	 rcx, rax
  00352	7e 16		 jle	 SHORT $LN46@SetupThrea

; 1257 : 				setupBlockSize = (ULONG) (Extension->ConfiguredEncryptedAreaEnd + 1 - offset.QuadPart);

  00354	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  00359	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0035d	48 83 c0 01	 add	 rax, 1
  00361	48 2b 44 24 60	 sub	 rax, QWORD PTR offset$[rsp]
  00366	89 44 24 4c	 mov	 DWORD PTR setupBlockSize$[rsp], eax
$LN46@SetupThrea:

; 1258 : 
; 1259 : 			if (offset.QuadPart > Extension->ConfiguredEncryptedAreaEnd)

  0036a	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  0036f	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00373	48 39 44 24 60	 cmp	 QWORD PTR offset$[rsp], rax
  00378	7e 05		 jle	 SHORT $LN45@SetupThrea

; 1260 : 				break;

  0037a	e9 d0 05 00 00	 jmp	 $LN48@SetupThrea
$LN45@SetupThrea:

; 1261 : 		}
; 1262 : 		else

  0037f	eb 62		 jmp	 SHORT $LN44@SetupThrea
$LN47@SetupThrea:

; 1263 : 		{
; 1264 : 			if (offset.QuadPart - setupBlockSize < Extension->Queue.EncryptedAreaStart)

  00381	8b 44 24 4c	 mov	 eax, DWORD PTR setupBlockSize$[rsp]
  00385	48 8b 4c 24 60	 mov	 rcx, QWORD PTR offset$[rsp]
  0038a	48 2b c8	 sub	 rcx, rax
  0038d	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  00392	48 3b 88 c8 00
	00 00		 cmp	 rcx, QWORD PTR [rax+200]
  00399	7d 18		 jge	 SHORT $LN43@SetupThrea

; 1265 : 				setupBlockSize = (ULONG) (offset.QuadPart - Extension->Queue.EncryptedAreaStart);

  0039b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Extension$[rsp]
  003a0	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  003a7	48 8b 44 24 60	 mov	 rax, QWORD PTR offset$[rsp]
  003ac	48 2b c1	 sub	 rax, rcx
  003af	89 44 24 4c	 mov	 DWORD PTR setupBlockSize$[rsp], eax
$LN43@SetupThrea:

; 1266 : 
; 1267 : 			offset.QuadPart -= setupBlockSize;

  003b3	8b 4c 24 4c	 mov	 ecx, DWORD PTR setupBlockSize$[rsp]
  003b7	48 8b 44 24 60	 mov	 rax, QWORD PTR offset$[rsp]
  003bc	48 2b c1	 sub	 rax, rcx
  003bf	48 89 44 24 60	 mov	 QWORD PTR offset$[rsp], rax

; 1268 : 
; 1269 : 			if (setupBlockSize == 0 || offset.QuadPart < Extension->Queue.EncryptedAreaStart)

  003c4	83 7c 24 4c 00	 cmp	 DWORD PTR setupBlockSize$[rsp], 0
  003c9	74 13		 je	 SHORT $LN41@SetupThrea
  003cb	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  003d0	48 8b 80 c8 00
	00 00		 mov	 rax, QWORD PTR [rax+200]
  003d7	48 39 44 24 60	 cmp	 QWORD PTR offset$[rsp], rax
  003dc	7d 05		 jge	 SHORT $LN42@SetupThrea
$LN41@SetupThrea:

; 1270 : 				break;

  003de	e9 6c 05 00 00	 jmp	 $LN48@SetupThrea
$LN42@SetupThrea:
$LN44@SetupThrea:
$LN40@SetupThrea:

; 1271 : 		}
; 1272 : 
; 1273 : 		while (!NT_SUCCESS (EncryptedIoQueueHoldWhenIdle (&Extension->Queue, 500)))

  003e3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Extension$[rsp]
  003e8	48 83 c1 50	 add	 rcx, 80			; 00000050H
  003ec	ba f4 01 00 00	 mov	 edx, 500		; 000001f4H
  003f1	e8 00 00 00 00	 call	 EncryptedIoQueueHoldWhenIdle
  003f6	85 c0		 test	 eax, eax
  003f8	7d 1b		 jge	 SHORT $LN39@SetupThrea

; 1274 : 		{
; 1275 : 			if (EncryptionSetupThreadAbortRequested)

  003fa	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR EncryptionSetupThreadAbortRequested
  00400	85 c0		 test	 eax, eax
  00402	74 05		 je	 SHORT $LN38@SetupThrea

; 1276 : 				goto abort;

  00404	e9 46 05 00 00	 jmp	 $abort$30238
$LN38@SetupThrea:

; 1277 : 
; 1278 : 			TransformWaitingForIdle = TRUE;

  00409	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR TransformWaitingForIdle, 1

; 1279 : 		}

  00413	eb ce		 jmp	 SHORT $LN40@SetupThrea
$LN39@SetupThrea:

; 1280 : 		TransformWaitingForIdle = FALSE;

  00415	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR TransformWaitingForIdle, 0

; 1281 : 
; 1282 : 		status = TCReadDevice (BootDriveFilterExtension->LowerDeviceObject, buffer, offset, setupBlockSize);

  0041f	44 8b 4c 24 4c	 mov	 r9d, DWORD PTR setupBlockSize$[rsp]
  00424	4c 8b 44 24 60	 mov	 r8, QWORD PTR offset$[rsp]
  00429	48 8b 54 24 70	 mov	 rdx, QWORD PTR buffer$[rsp]
  0042e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR BootDriveFilterExtension
  00435	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00439	e8 00 00 00 00	 call	 TCReadDevice
  0043e	89 44 24 6c	 mov	 DWORD PTR status$[rsp], eax

; 1283 : 		if (!NT_SUCCESS (status))

  00442	83 7c 24 6c 00	 cmp	 DWORD PTR status$[rsp], 0
  00447	0f 8d 04 01 00
	00		 jge	 $LN37@SetupThrea

; 1284 : 		{
; 1285 : 			Dump ("TCReadDevice error %x  offset=%I64d\n", status, offset.QuadPart);

  0044d	4c 8b 44 24 60	 mov	 r8, QWORD PTR offset$[rsp]
  00452	8b 54 24 6c	 mov	 edx, DWORD PTR status$[rsp]
  00456	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@CKMJEIIB@TCReadDevice?5error?5?$CFx?5?5offset?$DN?$CFI@FNODOBFM@
  0045d	e8 00 00 00 00	 call	 DbgPrint

; 1286 : 
; 1287 : 			if (SetupRequest.ZeroUnreadableSectors && SetupRequest.SetupMode == SetupEncryption)

  00462	83 3d 08 00 00
	00 00		 cmp	 DWORD PTR SetupRequest+8, 0
  00469	74 7d		 je	 SHORT $LN36@SetupThrea
  0046b	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR SetupRequest, 1
  00472	75 74		 jne	 SHORT $LN36@SetupThrea

; 1288 : 			{
; 1289 : 				// Zero unreadable sectors
; 1290 : 				uint64 zeroedSectorCount;
; 1291 : 
; 1292 : 				status = ZeroUnreadableSectors (BootDriveFilterExtension->LowerDeviceObject, offset, setupBlockSize, &zeroedSectorCount);

  00474	4c 8d 4c 24 78	 lea	 r9, QWORD PTR zeroedSectorCount$30283[rsp]
  00479	44 8b 44 24 4c	 mov	 r8d, DWORD PTR setupBlockSize$[rsp]
  0047e	48 8b 54 24 60	 mov	 rdx, QWORD PTR offset$[rsp]
  00483	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR BootDriveFilterExtension
  0048a	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0048e	e8 00 00 00 00	 call	 ZeroUnreadableSectors
  00493	89 44 24 6c	 mov	 DWORD PTR status$[rsp], eax

; 1293 : 				if (!NT_SUCCESS (status))

  00497	83 7c 24 6c 00	 cmp	 DWORD PTR status$[rsp], 0
  0049c	7d 0f		 jge	 SHORT $LN35@SetupThrea

; 1294 : 				{
; 1295 : 					SetupResult = status;

  0049e	8b 44 24 6c	 mov	 eax, DWORD PTR status$[rsp]
  004a2	89 05 00 00 00
	00		 mov	 DWORD PTR SetupResult, eax

; 1296 : 					goto err;

  004a8	e9 ac 04 00 00	 jmp	 $err$30249
$LN35@SetupThrea:

; 1297 : 				}
; 1298 : 
; 1299 : 				// Retry read
; 1300 : 				status = TCReadDevice (BootDriveFilterExtension->LowerDeviceObject, buffer, offset, setupBlockSize);

  004ad	44 8b 4c 24 4c	 mov	 r9d, DWORD PTR setupBlockSize$[rsp]
  004b2	4c 8b 44 24 60	 mov	 r8, QWORD PTR offset$[rsp]
  004b7	48 8b 54 24 70	 mov	 rdx, QWORD PTR buffer$[rsp]
  004bc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR BootDriveFilterExtension
  004c3	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  004c7	e8 00 00 00 00	 call	 TCReadDevice
  004cc	89 44 24 6c	 mov	 DWORD PTR status$[rsp], eax

; 1301 : 				if (!NT_SUCCESS (status))

  004d0	83 7c 24 6c 00	 cmp	 DWORD PTR status$[rsp], 0
  004d5	7d 0f		 jge	 SHORT $LN34@SetupThrea

; 1302 : 				{
; 1303 : 					SetupResult = status;

  004d7	8b 44 24 6c	 mov	 eax, DWORD PTR status$[rsp]
  004db	89 05 00 00 00
	00		 mov	 DWORD PTR SetupResult, eax

; 1304 : 					goto err;

  004e1	e9 73 04 00 00	 jmp	 $err$30249
$LN34@SetupThrea:

; 1305 : 				}

  004e6	eb 69		 jmp	 SHORT $LN33@SetupThrea
$LN36@SetupThrea:

; 1306 : 			}
; 1307 : 			else if (SetupRequest.DiscardUnreadableEncryptedSectors && SetupRequest.SetupMode == SetupDecryption)

  004e8	83 3d 0c 00 00
	00 00		 cmp	 DWORD PTR SetupRequest+12, 0
  004ef	74 51		 je	 SHORT $LN32@SetupThrea
  004f1	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR SetupRequest, 2
  004f8	75 48		 jne	 SHORT $LN32@SetupThrea

; 1308 : 			{
; 1309 : 				// Discard unreadable encrypted sectors
; 1310 : 				uint64 badSectorCount;
; 1311 : 
; 1312 : 				status = ReadDeviceSkipUnreadableSectors (BootDriveFilterExtension->LowerDeviceObject, buffer, offset, setupBlockSize, &badSectorCount);

  004fa	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR badSectorCount$30290[rsp]
  00502	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00507	44 8b 4c 24 4c	 mov	 r9d, DWORD PTR setupBlockSize$[rsp]
  0050c	4c 8b 44 24 60	 mov	 r8, QWORD PTR offset$[rsp]
  00511	48 8b 54 24 70	 mov	 rdx, QWORD PTR buffer$[rsp]
  00516	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR BootDriveFilterExtension
  0051d	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00521	e8 00 00 00 00	 call	 ReadDeviceSkipUnreadableSectors
  00526	89 44 24 6c	 mov	 DWORD PTR status$[rsp], eax

; 1313 : 				if (!NT_SUCCESS (status))

  0052a	83 7c 24 6c 00	 cmp	 DWORD PTR status$[rsp], 0
  0052f	7d 0f		 jge	 SHORT $LN31@SetupThrea

; 1314 : 				{
; 1315 : 					SetupResult = status;

  00531	8b 44 24 6c	 mov	 eax, DWORD PTR status$[rsp]
  00535	89 05 00 00 00
	00		 mov	 DWORD PTR SetupResult, eax

; 1316 : 					goto err;

  0053b	e9 19 04 00 00	 jmp	 $err$30249
$LN31@SetupThrea:

; 1317 : 				}
; 1318 : 			}
; 1319 : 			else

  00540	eb 0f		 jmp	 SHORT $LN30@SetupThrea
$LN32@SetupThrea:

; 1320 : 			{
; 1321 : 				SetupResult = status;

  00542	8b 44 24 6c	 mov	 eax, DWORD PTR status$[rsp]
  00546	89 05 00 00 00
	00		 mov	 DWORD PTR SetupResult, eax

; 1322 : 				goto err;

  0054c	e9 08 04 00 00	 jmp	 $err$30249
$LN30@SetupThrea:
$LN33@SetupThrea:
$LN37@SetupThrea:

; 1323 : 			}
; 1324 : 		}
; 1325 : 
; 1326 : 		dataUnit.Value = offset.QuadPart / ENCRYPTION_DATA_UNIT_SIZE;

  00551	48 8b 44 24 60	 mov	 rax, QWORD PTR offset$[rsp]
  00556	48 99		 cdq
  00558	48 81 e2 ff 01
	00 00		 and	 rdx, 511		; 000001ffH
  0055f	48 03 c2	 add	 rax, rdx
  00562	48 c1 f8 09	 sar	 rax, 9
  00566	48 89 44 24 38	 mov	 QWORD PTR dataUnit$[rsp], rax

; 1327 : 
; 1328 : 		if (SetupRequest.SetupMode == SetupEncryption)

  0056b	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR SetupRequest, 1
  00572	0f 85 ca 01 00
	00		 jne	 $LN29@SetupThrea

; 1329 : 		{
; 1330 : 			EncryptDataUnits (buffer, &dataUnit, setupBlockSize / ENCRYPTION_DATA_UNIT_SIZE, Extension->Queue.CryptoInfo);

  00578	33 d2		 xor	 edx, edx
  0057a	8b 44 24 4c	 mov	 eax, DWORD PTR setupBlockSize$[rsp]
  0057e	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00583	f7 f1		 div	 ecx
  00585	4c 8b 4c 24 50	 mov	 r9, QWORD PTR Extension$[rsp]
  0058a	4d 8b 89 98 00
	00 00		 mov	 r9, QWORD PTR [r9+152]
  00591	44 8b c0	 mov	 r8d, eax
  00594	48 8d 54 24 38	 lea	 rdx, QWORD PTR dataUnit$[rsp]
  00599	48 8b 4c 24 70	 mov	 rcx, QWORD PTR buffer$[rsp]
  0059e	e8 00 00 00 00	 call	 EncryptDataUnits

; 1331 : 
; 1332 : 			if (SetupRequest.WipeAlgorithm != TC_WIPE_NONE)

  005a3	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR SetupRequest+4, 0
  005aa	0f 84 90 01 00
	00		 je	 $LN28@SetupThrea

; 1333 : 			{
; 1334 : 				byte wipePass;
; 1335 : 				for (wipePass = 1; wipePass <= GetWipePassCount (SetupRequest.WipeAlgorithm); ++wipePass)

  005b0	c6 84 24 88 00
	00 00 01	 mov	 BYTE PTR wipePass$30296[rsp], 1
  005b8	eb 11		 jmp	 SHORT $LN27@SetupThrea
$LN26@SetupThrea:
  005ba	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR wipePass$30296[rsp]
  005c2	04 01		 add	 al, 1
  005c4	88 84 24 88 00
	00 00		 mov	 BYTE PTR wipePass$30296[rsp], al
$LN27@SetupThrea:
  005cb	0f b6 bc 24 88
	00 00 00	 movzx	 edi, BYTE PTR wipePass$30296[rsp]
  005d3	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR SetupRequest+4
  005d9	e8 00 00 00 00	 call	 GetWipePassCount
  005de	3b f8		 cmp	 edi, eax
  005e0	0f 8f 49 01 00
	00		 jg	 $LN25@SetupThrea

; 1336 : 				{
; 1337 : 					if (!WipeBuffer (SetupRequest.WipeAlgorithm, wipeRandChars, wipePass, wipeBuffer, setupBlockSize))

  005e6	8b 44 24 4c	 mov	 eax, DWORD PTR setupBlockSize$[rsp]
  005ea	44 0f b6 84 24
	88 00 00 00	 movzx	 r8d, BYTE PTR wipePass$30296[rsp]
  005f3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005f8	4c 8b 4c 24 40	 mov	 r9, QWORD PTR wipeBuffer$[rsp]
  005fd	48 8d 54 24 68	 lea	 rdx, QWORD PTR wipeRandChars$[rsp]
  00602	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR SetupRequest+4
  00608	e8 00 00 00 00	 call	 WipeBuffer
  0060d	85 c0		 test	 eax, eax
  0060f	0f 85 92 00 00
	00		 jne	 $LN24@SetupThrea

; 1338 : 					{
; 1339 : 						ULONG i;
; 1340 : 						for (i = 0; i < setupBlockSize; ++i)

  00615	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$30301[rsp], 0
  00620	eb 11		 jmp	 SHORT $LN23@SetupThrea
$LN22@SetupThrea:
  00622	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR i$30301[rsp]
  00629	83 c0 01	 add	 eax, 1
  0062c	89 84 24 8c 00
	00 00		 mov	 DWORD PTR i$30301[rsp], eax
$LN23@SetupThrea:
  00633	8b 44 24 4c	 mov	 eax, DWORD PTR setupBlockSize$[rsp]
  00637	39 84 24 8c 00
	00 00		 cmp	 DWORD PTR i$30301[rsp], eax
  0063e	73 2b		 jae	 SHORT $LN21@SetupThrea

; 1341 : 						{
; 1342 : 							wipeBuffer[i] = buffer[i] + wipePass;

  00640	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR i$30301[rsp]
  00647	48 8b 44 24 70	 mov	 rax, QWORD PTR buffer$[rsp]
  0064c	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  00650	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR wipePass$30296[rsp]
  00658	03 d0		 add	 edx, eax
  0065a	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR i$30301[rsp]
  00661	48 8b 44 24 40	 mov	 rax, QWORD PTR wipeBuffer$[rsp]
  00666	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 1343 : 						}

  00669	eb b7		 jmp	 SHORT $LN22@SetupThrea
$LN21@SetupThrea:

; 1344 : 
; 1345 : 						EncryptDataUnits (wipeBuffer, &dataUnit, setupBlockSize / ENCRYPTION_DATA_UNIT_SIZE, Extension->Queue.CryptoInfo);

  0066b	33 d2		 xor	 edx, edx
  0066d	8b 44 24 4c	 mov	 eax, DWORD PTR setupBlockSize$[rsp]
  00671	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00676	f7 f1		 div	 ecx
  00678	4c 8b 4c 24 50	 mov	 r9, QWORD PTR Extension$[rsp]
  0067d	4d 8b 89 98 00
	00 00		 mov	 r9, QWORD PTR [r9+152]
  00684	44 8b c0	 mov	 r8d, eax
  00687	48 8d 54 24 38	 lea	 rdx, QWORD PTR dataUnit$[rsp]
  0068c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR wipeBuffer$[rsp]
  00691	e8 00 00 00 00	 call	 EncryptDataUnits

; 1346 : 						memcpy (wipeRandCharsUpdate, wipeBuffer, sizeof (wipeRandCharsUpdate)); 

  00696	48 8d 7c 24 34	 lea	 rdi, QWORD PTR wipeRandCharsUpdate$[rsp]
  0069b	48 8b 74 24 40	 mov	 rsi, QWORD PTR wipeBuffer$[rsp]
  006a0	b9 03 00 00 00	 mov	 ecx, 3
  006a5	f3 a4		 rep movsb
$LN24@SetupThrea:

; 1347 : 					}
; 1348 : 
; 1349 : 					status = TCWriteDevice (BootDriveFilterExtension->LowerDeviceObject, wipeBuffer, offset, setupBlockSize);

  006a7	44 8b 4c 24 4c	 mov	 r9d, DWORD PTR setupBlockSize$[rsp]
  006ac	4c 8b 44 24 60	 mov	 r8, QWORD PTR offset$[rsp]
  006b1	48 8b 54 24 40	 mov	 rdx, QWORD PTR wipeBuffer$[rsp]
  006b6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR BootDriveFilterExtension
  006bd	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  006c1	e8 00 00 00 00	 call	 TCWriteDevice
  006c6	89 44 24 6c	 mov	 DWORD PTR status$[rsp], eax

; 1350 : 					if (!NT_SUCCESS (status))

  006ca	83 7c 24 6c 00	 cmp	 DWORD PTR status$[rsp], 0
  006cf	7d 59		 jge	 SHORT $LN20@SetupThrea

; 1351 : 					{
; 1352 : 						// Undo failed write operation
; 1353 : 						DecryptDataUnits (buffer, &dataUnit, setupBlockSize / ENCRYPTION_DATA_UNIT_SIZE, Extension->Queue.CryptoInfo);

  006d1	33 d2		 xor	 edx, edx
  006d3	8b 44 24 4c	 mov	 eax, DWORD PTR setupBlockSize$[rsp]
  006d7	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  006dc	f7 f1		 div	 ecx
  006de	4c 8b 4c 24 50	 mov	 r9, QWORD PTR Extension$[rsp]
  006e3	4d 8b 89 98 00
	00 00		 mov	 r9, QWORD PTR [r9+152]
  006ea	44 8b c0	 mov	 r8d, eax
  006ed	48 8d 54 24 38	 lea	 rdx, QWORD PTR dataUnit$[rsp]
  006f2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR buffer$[rsp]
  006f7	e8 00 00 00 00	 call	 DecryptDataUnits

; 1354 : 						TCWriteDevice (BootDriveFilterExtension->LowerDeviceObject, buffer, offset, setupBlockSize);

  006fc	44 8b 4c 24 4c	 mov	 r9d, DWORD PTR setupBlockSize$[rsp]
  00701	4c 8b 44 24 60	 mov	 r8, QWORD PTR offset$[rsp]
  00706	48 8b 54 24 70	 mov	 rdx, QWORD PTR buffer$[rsp]
  0070b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR BootDriveFilterExtension
  00712	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00716	e8 00 00 00 00	 call	 TCWriteDevice

; 1355 : 
; 1356 : 						SetupResult = status;

  0071b	8b 54 24 6c	 mov	 edx, DWORD PTR status$[rsp]
  0071f	89 15 00 00 00
	00		 mov	 DWORD PTR SetupResult, edx

; 1357 : 						goto err;

  00725	e9 2f 02 00 00	 jmp	 $err$30249
$LN20@SetupThrea:

; 1358 : 					}
; 1359 : 				}

  0072a	e9 8b fe ff ff	 jmp	 $LN26@SetupThrea
$LN25@SetupThrea:

; 1360 : 
; 1361 : 				memcpy (wipeRandChars, wipeRandCharsUpdate, sizeof (wipeRandCharsUpdate)); 

  0072f	48 8d 7c 24 68	 lea	 rdi, QWORD PTR wipeRandChars$[rsp]
  00734	48 8d 74 24 34	 lea	 rsi, QWORD PTR wipeRandCharsUpdate$[rsp]
  00739	b9 03 00 00 00	 mov	 ecx, 3
  0073e	f3 a4		 rep movsb
$LN28@SetupThrea:

; 1362 : 			}
; 1363 : 		}
; 1364 : 		else

  00740	eb 2b		 jmp	 SHORT $LN19@SetupThrea
$LN29@SetupThrea:

; 1365 : 		{
; 1366 : 			DecryptDataUnits (buffer, &dataUnit, setupBlockSize / ENCRYPTION_DATA_UNIT_SIZE, Extension->Queue.CryptoInfo);

  00742	33 d2		 xor	 edx, edx
  00744	8b 44 24 4c	 mov	 eax, DWORD PTR setupBlockSize$[rsp]
  00748	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0074d	f7 f1		 div	 ecx
  0074f	4c 8b 4c 24 50	 mov	 r9, QWORD PTR Extension$[rsp]
  00754	4d 8b 89 98 00
	00 00		 mov	 r9, QWORD PTR [r9+152]
  0075b	44 8b c0	 mov	 r8d, eax
  0075e	48 8d 54 24 38	 lea	 rdx, QWORD PTR dataUnit$[rsp]
  00763	48 8b 4c 24 70	 mov	 rcx, QWORD PTR buffer$[rsp]
  00768	e8 00 00 00 00	 call	 DecryptDataUnits
$LN19@SetupThrea:

; 1367 : 		}
; 1368 : 
; 1369 : 		status = TCWriteDevice (BootDriveFilterExtension->LowerDeviceObject, buffer, offset, setupBlockSize);

  0076d	44 8b 4c 24 4c	 mov	 r9d, DWORD PTR setupBlockSize$[rsp]
  00772	4c 8b 44 24 60	 mov	 r8, QWORD PTR offset$[rsp]
  00777	48 8b 54 24 70	 mov	 rdx, QWORD PTR buffer$[rsp]
  0077c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR BootDriveFilterExtension
  00783	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00787	e8 00 00 00 00	 call	 TCWriteDevice
  0078c	89 44 24 6c	 mov	 DWORD PTR status$[rsp], eax

; 1370 : 		if (!NT_SUCCESS (status))

  00790	83 7c 24 6c 00	 cmp	 DWORD PTR status$[rsp], 0
  00795	0f 8d 9f 00 00
	00		 jge	 $LN18@SetupThrea

; 1371 : 		{
; 1372 : 			Dump ("TCWriteDevice error %x\n", status);

  0079b	8b 54 24 6c	 mov	 edx, DWORD PTR status$[rsp]
  0079f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@LEBDPHBF@TCWriteDevice?5error?5?$CFx?6?$AA@FNODOBFM@
  007a6	e8 00 00 00 00	 call	 DbgPrint

; 1373 : 
; 1374 : 			// Undo failed write operation
; 1375 : 			if (SetupRequest.SetupMode == SetupEncryption)

  007ab	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR SetupRequest, 1
  007b2	75 2d		 jne	 SHORT $LN17@SetupThrea

; 1376 : 				DecryptDataUnits (buffer, &dataUnit, setupBlockSize / ENCRYPTION_DATA_UNIT_SIZE, Extension->Queue.CryptoInfo);

  007b4	33 d2		 xor	 edx, edx
  007b6	8b 44 24 4c	 mov	 eax, DWORD PTR setupBlockSize$[rsp]
  007ba	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  007bf	f7 f1		 div	 ecx
  007c1	4c 8b 4c 24 50	 mov	 r9, QWORD PTR Extension$[rsp]
  007c6	4d 8b 89 98 00
	00 00		 mov	 r9, QWORD PTR [r9+152]
  007cd	44 8b c0	 mov	 r8d, eax
  007d0	48 8d 54 24 38	 lea	 rdx, QWORD PTR dataUnit$[rsp]
  007d5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR buffer$[rsp]
  007da	e8 00 00 00 00	 call	 DecryptDataUnits

; 1377 : 			else

  007df	eb 2b		 jmp	 SHORT $LN16@SetupThrea
$LN17@SetupThrea:

; 1378 : 				EncryptDataUnits (buffer, &dataUnit, setupBlockSize / ENCRYPTION_DATA_UNIT_SIZE, Extension->Queue.CryptoInfo);

  007e1	33 d2		 xor	 edx, edx
  007e3	8b 44 24 4c	 mov	 eax, DWORD PTR setupBlockSize$[rsp]
  007e7	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  007ec	f7 f1		 div	 ecx
  007ee	4c 8b 4c 24 50	 mov	 r9, QWORD PTR Extension$[rsp]
  007f3	4d 8b 89 98 00
	00 00		 mov	 r9, QWORD PTR [r9+152]
  007fa	44 8b c0	 mov	 r8d, eax
  007fd	48 8d 54 24 38	 lea	 rdx, QWORD PTR dataUnit$[rsp]
  00802	48 8b 4c 24 70	 mov	 rcx, QWORD PTR buffer$[rsp]
  00807	e8 00 00 00 00	 call	 EncryptDataUnits
$LN16@SetupThrea:

; 1379 : 
; 1380 : 			TCWriteDevice (BootDriveFilterExtension->LowerDeviceObject, buffer, offset, setupBlockSize);

  0080c	44 8b 4c 24 4c	 mov	 r9d, DWORD PTR setupBlockSize$[rsp]
  00811	4c 8b 44 24 60	 mov	 r8, QWORD PTR offset$[rsp]
  00816	48 8b 54 24 70	 mov	 rdx, QWORD PTR buffer$[rsp]
  0081b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR BootDriveFilterExtension
  00822	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00826	e8 00 00 00 00	 call	 TCWriteDevice

; 1381 : 
; 1382 : 			SetupResult = status;

  0082b	8b 54 24 6c	 mov	 edx, DWORD PTR status$[rsp]
  0082f	89 15 00 00 00
	00		 mov	 DWORD PTR SetupResult, edx

; 1383 : 			goto err;

  00835	e9 1f 01 00 00	 jmp	 $err$30249
$LN18@SetupThrea:

; 1384 : 		}
; 1385 : 
; 1386 : 		if (SetupRequest.SetupMode == SetupEncryption)

  0083a	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR SetupRequest, 1
  00841	75 11		 jne	 SHORT $LN15@SetupThrea

; 1387 : 			offset.QuadPart += setupBlockSize;

  00843	8b 4c 24 4c	 mov	 ecx, DWORD PTR setupBlockSize$[rsp]
  00847	48 8b 44 24 60	 mov	 rax, QWORD PTR offset$[rsp]
  0084c	48 03 c1	 add	 rax, rcx
  0084f	48 89 44 24 60	 mov	 QWORD PTR offset$[rsp], rax
$LN15@SetupThrea:

; 1388 : 
; 1389 : 		Extension->Queue.EncryptedAreaEndUpdatePending = TRUE;

  00854	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  00859	c7 80 d8 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+216], 1

; 1390 : 		Extension->Queue.EncryptedAreaEnd = offset.QuadPart - 1;

  00863	48 8b 4c 24 60	 mov	 rcx, QWORD PTR offset$[rsp]
  00868	48 83 e9 01	 sub	 rcx, 1
  0086c	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  00871	48 89 88 d0 00
	00 00		 mov	 QWORD PTR [rax+208], rcx

; 1391 : 		Extension->Queue.EncryptedAreaEndUpdatePending = FALSE;

  00878	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  0087d	c7 80 d8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+216], 0

; 1392 : 
; 1393 : 		headerUpdateRequired = TRUE;

  00887	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR headerUpdateRequired$[rsp], 1

; 1394 : 
; 1395 : 		EncryptedIoQueueResumeFromHold (&Extension->Queue);

  0088f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Extension$[rsp]
  00894	48 83 c1 50	 add	 rcx, 80			; 00000050H
  00898	e8 00 00 00 00	 call	 EncryptedIoQueueResumeFromHold

; 1396 : 
; 1397 : 		KeAcquireSpinLock (&SetupStatusSpinLock, &irql);

  0089d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:SetupStatusSpinLock
  008a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeAcquireSpinLockRaiseToDpc
  008aa	88 44 24 30	 mov	 BYTE PTR irql$[rsp], al

; 1398 : 		SetupStatusEncryptedAreaEnd = Extension->Queue.EncryptedAreaEnd;

  008ae	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  008b3	48 8b 80 d0 00
	00 00		 mov	 rax, QWORD PTR [rax+208]
  008ba	48 89 05 00 00
	00 00		 mov	 QWORD PTR SetupStatusEncryptedAreaEnd, rax

; 1399 : 		KeReleaseSpinLock (&SetupStatusSpinLock, irql);

  008c1	0f b6 54 24 30	 movzx	 edx, BYTE PTR irql$[rsp]
  008c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:SetupStatusSpinLock
  008cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseSpinLock

; 1400 : 
; 1401 : 		// Update volume header
; 1402 : 		bytesWrittenSinceHeaderUpdate += setupBlockSize;

  008d3	8b 54 24 4c	 mov	 edx, DWORD PTR setupBlockSize$[rsp]
  008d7	48 8b 44 24 58	 mov	 rax, QWORD PTR bytesWrittenSinceHeaderUpdate$[rsp]
  008dc	48 03 c2	 add	 rax, rdx
  008df	48 89 44 24 58	 mov	 QWORD PTR bytesWrittenSinceHeaderUpdate$[rsp], rax

; 1403 : 		if (bytesWrittenSinceHeaderUpdate >= TC_ENCRYPTION_SETUP_HEADER_UPDATE_THRESHOLD)

  008e4	48 81 7c 24 58
	00 00 00 04	 cmp	 QWORD PTR bytesWrittenSinceHeaderUpdate$[rsp], 67108864 ; 04000000H
  008ed	7c 5b		 jl	 SHORT $LN14@SetupThrea

; 1404 : 		{
; 1405 : 			status = SaveDriveVolumeHeader (Extension);

  008ef	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Extension$[rsp]
  008f4	e8 00 00 00 00	 call	 SaveDriveVolumeHeader
  008f9	89 44 24 6c	 mov	 DWORD PTR status$[rsp], eax

; 1406 : 			ASSERT (NT_SUCCESS (status));

  008fd	83 7c 24 6c 00	 cmp	 DWORD PTR status$[rsp], 0
  00902	7d 2a		 jge	 SHORT $LN70@SetupThrea
  00904	45 33 c9	 xor	 r9d, r9d
  00907	41 b8 7e 05 00
	00		 mov	 r8d, 1406		; 0000057eH
  0090d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EF@GDHJGIB@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  00914	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@IDPHHPHP@NT_SUCCESS?5?$CIstatus?$CJ?$AA@FNODOBFM@
  0091b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  00921	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv373[rsp], 0
  0092c	eb 0b		 jmp	 SHORT $LN71@SetupThrea
$LN70@SetupThrea:
  0092e	c7 84 24 94 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv373[rsp], 1
$LN71@SetupThrea:

; 1407 : 
; 1408 : 			headerUpdateRequired = FALSE;

  00939	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR headerUpdateRequired$[rsp], 0

; 1409 : 			bytesWrittenSinceHeaderUpdate = 0;

  00941	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR bytesWrittenSinceHeaderUpdate$[rsp], 0
$LN14@SetupThrea:

; 1410 : 		}
; 1411 : 	}

  0094a	e9 d0 f9 ff ff	 jmp	 $LN49@SetupThrea
$LN48@SetupThrea:
$abort$30238:

; 1412 : 
; 1413 : abort:
; 1414 : 	SetupResult = STATUS_SUCCESS;

  0094f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR SetupResult, 0
$err$30249:

; 1415 : err:
; 1416 : 
; 1417 : 	if (Extension->Queue.EncryptedAreaEnd == -1)

  00959	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  0095e	48 8b 80 d0 00
	00 00		 mov	 rax, QWORD PTR [rax+208]
  00965	48 83 f8 ff	 cmp	 rax, -1
  00969	75 10		 jne	 SHORT $LN13@SetupThrea

; 1418 : 		Extension->Queue.EncryptedAreaStart = -1;

  0096b	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  00970	48 c7 80 c8 00
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rax+200], -1
$LN13@SetupThrea:

; 1419 : 
; 1420 : 	if (EncryptedIoQueueIsSuspended (&Extension->Queue))

  0097b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Extension$[rsp]
  00980	48 83 c1 50	 add	 rcx, 80			; 00000050H
  00984	e8 00 00 00 00	 call	 EncryptedIoQueueIsSuspended
  00989	85 c0		 test	 eax, eax
  0098b	74 0e		 je	 SHORT $LN12@SetupThrea

; 1421 : 		EncryptedIoQueueResumeFromHold (&Extension->Queue);

  0098d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Extension$[rsp]
  00992	48 83 c1 50	 add	 rcx, 80			; 00000050H
  00996	e8 00 00 00 00	 call	 EncryptedIoQueueResumeFromHold
$LN12@SetupThrea:

; 1422 : 
; 1423 : 	if (SetupRequest.SetupMode == SetupDecryption && Extension->Queue.EncryptedAreaStart >= Extension->Queue.EncryptedAreaEnd)

  0099b	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR SetupRequest, 2
  009a2	0f 85 80 00 00
	00		 jne	 $LN11@SetupThrea
  009a8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Extension$[rsp]
  009ad	48 8b 89 d0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+208]
  009b4	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  009b9	48 39 88 c8 00
	00 00		 cmp	 QWORD PTR [rax+200], rcx
  009c0	7c 66		 jl	 SHORT $LN11@SetupThrea
$LN10@SetupThrea:

; 1424 : 	{
; 1425 : 		while (!NT_SUCCESS (EncryptedIoQueueHoldWhenIdle (&Extension->Queue, 0)));

  009c2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Extension$[rsp]
  009c7	48 83 c1 50	 add	 rcx, 80			; 00000050H
  009cb	33 d2		 xor	 edx, edx
  009cd	e8 00 00 00 00	 call	 EncryptedIoQueueHoldWhenIdle
  009d2	85 c0		 test	 eax, eax
  009d4	7d 02		 jge	 SHORT $LN9@SetupThrea
  009d6	eb ea		 jmp	 SHORT $LN10@SetupThrea
$LN9@SetupThrea:

; 1426 : 
; 1427 : 		Extension->ConfiguredEncryptedAreaStart = Extension->ConfiguredEncryptedAreaEnd = -1;

  009d8	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  009dd	48 c7 40 40 ff
	ff ff ff	 mov	 QWORD PTR [rax+64], -1
  009e5	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  009ea	48 c7 40 38 ff
	ff ff ff	 mov	 QWORD PTR [rax+56], -1

; 1428 : 		Extension->Queue.EncryptedAreaStart = Extension->Queue.EncryptedAreaEnd = -1;

  009f2	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  009f7	48 c7 80 d0 00
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rax+208], -1
  00a02	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  00a07	48 c7 80 c8 00
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rax+200], -1

; 1429 : 
; 1430 : 		EncryptedIoQueueResumeFromHold (&Extension->Queue);

  00a12	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Extension$[rsp]
  00a17	48 83 c1 50	 add	 rcx, 80			; 00000050H
  00a1b	e8 00 00 00 00	 call	 EncryptedIoQueueResumeFromHold

; 1431 : 
; 1432 : 		headerUpdateRequired = TRUE;

  00a20	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR headerUpdateRequired$[rsp], 1
$LN11@SetupThrea:

; 1433 : 	}
; 1434 : 
; 1435 : 	Dump ("Setup completed:  EncryptedAreaStart=%I64d (%I64d)  EncryptedAreaEnd=%I64d (%I64d)\n", Extension->Queue.EncryptedAreaStart / 1024 / 1024, Extension->Queue.EncryptedAreaStart, Extension->Queue.EncryptedAreaEnd / 1024 / 1024, Extension->Queue.EncryptedAreaEnd);

  00a28	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  00a2d	48 8b 80 d0 00
	00 00		 mov	 rax, QWORD PTR [rax+208]
  00a34	48 99		 cdq
  00a36	48 81 e2 ff 03
	00 00		 and	 rdx, 1023		; 000003ffH
  00a3d	48 03 c2	 add	 rax, rdx
  00a40	48 c1 f8 0a	 sar	 rax, 10
  00a44	48 99		 cdq
  00a46	48 81 e2 ff 03
	00 00		 and	 rdx, 1023		; 000003ffH
  00a4d	48 03 c2	 add	 rax, rdx
  00a50	48 c1 f8 0a	 sar	 rax, 10
  00a54	4c 8b c8	 mov	 r9, rax
  00a57	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  00a5c	48 8b 80 c8 00
	00 00		 mov	 rax, QWORD PTR [rax+200]
  00a63	48 99		 cdq
  00a65	48 81 e2 ff 03
	00 00		 and	 rdx, 1023		; 000003ffH
  00a6c	48 03 c2	 add	 rax, rdx
  00a6f	48 c1 f8 0a	 sar	 rax, 10
  00a73	48 99		 cdq
  00a75	48 81 e2 ff 03
	00 00		 and	 rdx, 1023		; 000003ffH
  00a7c	48 03 c2	 add	 rax, rdx
  00a7f	48 c1 f8 0a	 sar	 rax, 10
  00a83	48 8b d0	 mov	 rdx, rax
  00a86	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  00a8b	48 8b 80 d0 00
	00 00		 mov	 rax, QWORD PTR [rax+208]
  00a92	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a97	4c 8b 44 24 50	 mov	 r8, QWORD PTR Extension$[rsp]
  00a9c	4d 8b 80 c8 00
	00 00		 mov	 r8, QWORD PTR [r8+200]
  00aa3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0FE@OKPCPDJI@Setup?5completed?3?5?5EncryptedAreaS@FNODOBFM@
  00aaa	e8 00 00 00 00	 call	 DbgPrint

; 1436 : 
; 1437 : 	if (headerUpdateRequired)

  00aaf	83 7c 24 48 00	 cmp	 DWORD PTR headerUpdateRequired$[rsp], 0
  00ab4	74 28		 je	 SHORT $LN8@SetupThrea

; 1438 : 	{
; 1439 : 		status = SaveDriveVolumeHeader (Extension);

  00ab6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Extension$[rsp]
  00abb	e8 00 00 00 00	 call	 SaveDriveVolumeHeader
  00ac0	89 44 24 6c	 mov	 DWORD PTR status$[rsp], eax

; 1440 : 
; 1441 : 		if (!NT_SUCCESS (status) && NT_SUCCESS (SetupResult))

  00ac4	83 7c 24 6c 00	 cmp	 DWORD PTR status$[rsp], 0
  00ac9	7d 13		 jge	 SHORT $LN7@SetupThrea
  00acb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR SetupResult, 0
  00ad2	7c 0a		 jl	 SHORT $LN7@SetupThrea

; 1442 : 			SetupResult = status;

  00ad4	8b 44 24 6c	 mov	 eax, DWORD PTR status$[rsp]
  00ad8	89 05 00 00 00
	00		 mov	 DWORD PTR SetupResult, eax
$LN7@SetupThrea:
$LN8@SetupThrea:

; 1443 : 	}
; 1444 : 
; 1445 : 	if (SetupRequest.SetupMode == SetupDecryption && Extension->ConfiguredEncryptedAreaEnd == -1 && Extension->DriveMounted)

  00ade	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR SetupRequest, 2
  00ae5	75 5e		 jne	 SHORT $LN6@SetupThrea
  00ae7	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  00aec	48 83 78 40 ff	 cmp	 QWORD PTR [rax+64], -1
  00af1	75 52		 jne	 SHORT $LN6@SetupThrea
  00af3	48 8b 44 24 50	 mov	 rax, QWORD PTR Extension$[rsp]
  00af8	83 b8 10 03 00
	00 00		 cmp	 DWORD PTR [rax+784], 0
  00aff	74 44		 je	 SHORT $LN6@SetupThrea
$LN5@SetupThrea:

; 1446 : 	{
; 1447 : 		while (!RootDeviceControlMutexAcquireNoWait() && !EncryptionSetupThreadAbortRequested)

  00b01	e8 00 00 00 00	 call	 RootDeviceControlMutexAcquireNoWait
  00b06	85 c0		 test	 eax, eax
  00b08	75 16		 jne	 SHORT $LN4@SetupThrea
  00b0a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR EncryptionSetupThreadAbortRequested
  00b10	85 c0		 test	 eax, eax
  00b12	75 0c		 jne	 SHORT $LN4@SetupThrea

; 1448 : 		{
; 1449 : 			TCSleep (10);

  00b14	b9 0a 00 00 00	 mov	 ecx, 10
  00b19	e8 00 00 00 00	 call	 TCSleep

; 1450 : 		}

  00b1e	eb e1		 jmp	 SHORT $LN5@SetupThrea
$LN4@SetupThrea:

; 1451 : 
; 1452 : 		// Disable hibernation (resume would fail due to a change in the system memory map)
; 1453 : 		HibernationEnabled = FALSE;

  00b20	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR HibernationEnabled, 0

; 1454 : 
; 1455 : 		DismountDrive (Extension, FALSE);

  00b2a	33 d2		 xor	 edx, edx
  00b2c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Extension$[rsp]
  00b31	e8 00 00 00 00	 call	 DismountDrive

; 1456 : 
; 1457 : 		if (!EncryptionSetupThreadAbortRequested)

  00b36	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR EncryptionSetupThreadAbortRequested
  00b3c	85 d2		 test	 edx, edx
  00b3e	75 05		 jne	 SHORT $LN3@SetupThrea

; 1458 : 			RootDeviceControlMutexRelease();

  00b40	e8 00 00 00 00	 call	 RootDeviceControlMutexRelease
$LN3@SetupThrea:
$LN6@SetupThrea:
$ret$30225:

; 1459 : 	}
; 1460 : 
; 1461 : ret:
; 1462 : 	if (buffer)

  00b45	48 83 7c 24 70
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00b4b	74 10		 je	 SHORT $LN2@SetupThrea

; 1463 : 		TCfree (buffer);

  00b4d	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00b52	48 8b 4c 24 70	 mov	 rcx, QWORD PTR buffer$[rsp]
  00b57	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN2@SetupThrea:

; 1464 : 	if (wipeBuffer)

  00b5d	48 83 7c 24 40
	00		 cmp	 QWORD PTR wipeBuffer$[rsp], 0
  00b63	74 10		 je	 SHORT $LN1@SetupThrea

; 1465 : 		TCfree (wipeBuffer);

  00b65	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00b6a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR wipeBuffer$[rsp]
  00b6f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN1@SetupThrea:

; 1466 : 
; 1467 : 	SetupInProgress = FALSE;

  00b75	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR SetupInProgress, 0

; 1468 : 	PsTerminateSystemThread (SetupResult);

  00b7f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR SetupResult
  00b85	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsTerminateSystemThread

; 1469 : }

  00b8b	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00b92	5f		 pop	 rdi
  00b93	5e		 pop	 rsi
  00b94	c3		 ret	 0
SetupThreadProc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$HiberDriverWriteFunctionBFilter2 DD imagerel HiberDriverWriteFunctionBFilter2
	DD	imagerel HiberDriverWriteFunctionBFilter2+62
	DD	imagerel $unwind$HiberDriverWriteFunctionBFilter2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$HiberDriverWriteFunctionBFilter2 DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT HiberDriverWriteFunctionBFilter2
_TEXT	SEGMENT
writeOffset$ = 64
dataMdl$ = 72
HiberDriverWriteFunctionBFilter2 PROC			; COMDAT

; 955  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 956  : 	return HiberDriverWriteFunctionFilter (2, writeOffset, dataMdl, TRUE, 0, NULL);

  0000e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00017	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0001f	41 b9 01 00 00
	00		 mov	 r9d, 1
  00025	4c 8b 44 24 48	 mov	 r8, QWORD PTR dataMdl$[rsp]
  0002a	48 8b 54 24 40	 mov	 rdx, QWORD PTR writeOffset$[rsp]
  0002f	b9 02 00 00 00	 mov	 ecx, 2
  00034	e8 00 00 00 00	 call	 HiberDriverWriteFunctionFilter

; 957  : }

  00039	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003d	c3		 ret	 0
HiberDriverWriteFunctionBFilter2 ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$HiberDriverWriteFunctionBFilter1 DD imagerel HiberDriverWriteFunctionBFilter1
	DD	imagerel HiberDriverWriteFunctionBFilter1+62
	DD	imagerel $unwind$HiberDriverWriteFunctionBFilter1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$HiberDriverWriteFunctionBFilter1 DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT HiberDriverWriteFunctionBFilter1
_TEXT	SEGMENT
writeOffset$ = 64
dataMdl$ = 72
HiberDriverWriteFunctionBFilter1 PROC			; COMDAT

; 950  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 951  : 	return HiberDriverWriteFunctionFilter (1, writeOffset, dataMdl, TRUE, 0, NULL);

  0000e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00017	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0001f	41 b9 01 00 00
	00		 mov	 r9d, 1
  00025	4c 8b 44 24 48	 mov	 r8, QWORD PTR dataMdl$[rsp]
  0002a	48 8b 54 24 40	 mov	 rdx, QWORD PTR writeOffset$[rsp]
  0002f	b9 01 00 00 00	 mov	 ecx, 1
  00034	e8 00 00 00 00	 call	 HiberDriverWriteFunctionFilter

; 952  : }

  00039	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003d	c3		 ret	 0
HiberDriverWriteFunctionBFilter1 ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$HiberDriverWriteFunctionBFilter0 DD imagerel HiberDriverWriteFunctionBFilter0
	DD	imagerel HiberDriverWriteFunctionBFilter0+59
	DD	imagerel $unwind$HiberDriverWriteFunctionBFilter0
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$HiberDriverWriteFunctionBFilter0 DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT HiberDriverWriteFunctionBFilter0
_TEXT	SEGMENT
writeOffset$ = 64
dataMdl$ = 72
HiberDriverWriteFunctionBFilter0 PROC			; COMDAT

; 945  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 946  : 	return HiberDriverWriteFunctionFilter (0, writeOffset, dataMdl, TRUE, 0, NULL);

  0000e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00017	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0001f	41 b9 01 00 00
	00		 mov	 r9d, 1
  00025	4c 8b 44 24 48	 mov	 r8, QWORD PTR dataMdl$[rsp]
  0002a	48 8b 54 24 40	 mov	 rdx, QWORD PTR writeOffset$[rsp]
  0002f	33 c9		 xor	 ecx, ecx
  00031	e8 00 00 00 00	 call	 HiberDriverWriteFunctionFilter

; 947  : }

  00036	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003a	c3		 ret	 0
HiberDriverWriteFunctionBFilter0 ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$HiberDriverWriteFunctionAFilter2 DD imagerel HiberDriverWriteFunctionAFilter2
	DD	imagerel HiberDriverWriteFunctionAFilter2+69
	DD	imagerel $unwind$HiberDriverWriteFunctionAFilter2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$HiberDriverWriteFunctionAFilter2 DD 011701H
	DD	06217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT HiberDriverWriteFunctionAFilter2
_TEXT	SEGMENT
arg0$ = 64
writeOffset$ = 72
dataMdl$ = 80
arg3$ = 88
HiberDriverWriteFunctionAFilter2 PROC			; COMDAT

; 939  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 940  : 	return HiberDriverWriteFunctionFilter (2, writeOffset, dataMdl, FALSE, arg0, arg3);

  00017	48 8b 44 24 58	 mov	 rax, QWORD PTR arg3$[rsp]
  0001c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00021	8b 44 24 40	 mov	 eax, DWORD PTR arg0$[rsp]
  00025	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00029	45 33 c9	 xor	 r9d, r9d
  0002c	4c 8b 44 24 50	 mov	 r8, QWORD PTR dataMdl$[rsp]
  00031	48 8b 54 24 48	 mov	 rdx, QWORD PTR writeOffset$[rsp]
  00036	b9 02 00 00 00	 mov	 ecx, 2
  0003b	e8 00 00 00 00	 call	 HiberDriverWriteFunctionFilter

; 941  : }

  00040	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00044	c3		 ret	 0
HiberDriverWriteFunctionAFilter2 ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$HiberDriverWriteFunctionAFilter1 DD imagerel HiberDriverWriteFunctionAFilter1
	DD	imagerel HiberDriverWriteFunctionAFilter1+69
	DD	imagerel $unwind$HiberDriverWriteFunctionAFilter1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$HiberDriverWriteFunctionAFilter1 DD 011701H
	DD	06217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT HiberDriverWriteFunctionAFilter1
_TEXT	SEGMENT
arg0$ = 64
writeOffset$ = 72
dataMdl$ = 80
arg3$ = 88
HiberDriverWriteFunctionAFilter1 PROC			; COMDAT

; 934  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 935  : 	return HiberDriverWriteFunctionFilter (1, writeOffset, dataMdl, FALSE, arg0, arg3);

  00017	48 8b 44 24 58	 mov	 rax, QWORD PTR arg3$[rsp]
  0001c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00021	8b 44 24 40	 mov	 eax, DWORD PTR arg0$[rsp]
  00025	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00029	45 33 c9	 xor	 r9d, r9d
  0002c	4c 8b 44 24 50	 mov	 r8, QWORD PTR dataMdl$[rsp]
  00031	48 8b 54 24 48	 mov	 rdx, QWORD PTR writeOffset$[rsp]
  00036	b9 01 00 00 00	 mov	 ecx, 1
  0003b	e8 00 00 00 00	 call	 HiberDriverWriteFunctionFilter

; 936  : }

  00040	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00044	c3		 ret	 0
HiberDriverWriteFunctionAFilter1 ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$HiberDriverWriteFunctionAFilter0 DD imagerel HiberDriverWriteFunctionAFilter0
	DD	imagerel HiberDriverWriteFunctionAFilter0+66
	DD	imagerel $unwind$HiberDriverWriteFunctionAFilter0
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$HiberDriverWriteFunctionAFilter0 DD 011701H
	DD	06217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT HiberDriverWriteFunctionAFilter0
_TEXT	SEGMENT
arg0$ = 64
writeOffset$ = 72
dataMdl$ = 80
arg3$ = 88
HiberDriverWriteFunctionAFilter0 PROC			; COMDAT

; 929  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 930  : 	return HiberDriverWriteFunctionFilter (0, writeOffset, dataMdl, FALSE, arg0, arg3);

  00017	48 8b 44 24 58	 mov	 rax, QWORD PTR arg3$[rsp]
  0001c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00021	8b 44 24 40	 mov	 eax, DWORD PTR arg0$[rsp]
  00025	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00029	45 33 c9	 xor	 r9d, r9d
  0002c	4c 8b 44 24 50	 mov	 r8, QWORD PTR dataMdl$[rsp]
  00031	48 8b 54 24 48	 mov	 rdx, QWORD PTR writeOffset$[rsp]
  00036	33 c9		 xor	 ecx, ecx
  00038	e8 00 00 00 00	 call	 HiberDriverWriteFunctionFilter

; 931  : }

  0003d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00041	c3		 ret	 0
HiberDriverWriteFunctionAFilter0 ENDP
_TEXT	ENDS
PUBLIC	ReopenBootVolumeHeader
;	COMDAT pdata
pdata	SEGMENT
$pdata$ReopenBootVolumeHeader DD imagerel $LN20
	DD	imagerel $LN20+765
	DD	imagerel $unwind$ReopenBootVolumeHeader
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ReopenBootVolumeHeader DD 010e01H
	DD	0c20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ReopenBootVolumeHeader
_TEXT	SEGMENT
offset$ = 48
request$ = 56
header$ = 64
burnc$29927 = 72
burnm$29925 = 80
tv149 = 88
irp$ = 112
irpSp$ = 120
ReopenBootVolumeHeader PROC				; COMDAT

; 749  : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 750  : 	LARGE_INTEGER offset;
; 751  : 	char *header;
; 752  : 	ReopenBootVolumeHeaderRequest *request = (ReopenBootVolumeHeaderRequest *) irp->AssociatedIrp.SystemBuffer;

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR irp$[rsp]
  00013	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00017	48 89 44 24 38	 mov	 QWORD PTR request$[rsp], rax

; 753  : 
; 754  : 	irp->IoStatus.Information = 0;

  0001c	48 8b 44 24 70	 mov	 rax, QWORD PTR irp$[rsp]
  00021	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 755  : 
; 756  : 	if (!IoIsSystemThread (PsGetCurrentThread()) && !UserCanAccessDriveDevice())

  00029	e8 00 00 00 00	 call	 PsGetCurrentThread
  0002e	48 8b c8	 mov	 rcx, rax
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoIsSystemThread
  00037	0f b6 c0	 movzx	 eax, al
  0003a	85 c0		 test	 eax, eax
  0003c	75 1a		 jne	 SHORT $LN15@ReopenBoot
  0003e	e8 00 00 00 00	 call	 UserCanAccessDriveDevice
  00043	85 c0		 test	 eax, eax
  00045	75 11		 jne	 SHORT $LN15@ReopenBoot

; 757  : 	{
; 758  : 		irp->IoStatus.Status = STATUS_ACCESS_DENIED;

  00047	48 8b 44 24 70	 mov	 rax, QWORD PTR irp$[rsp]
  0004c	c7 40 30 22 00
	00 c0		 mov	 DWORD PTR [rax+48], -1073741790 ; ffffffffc0000022H

; 759  : 		return;

  00053	e9 a0 02 00 00	 jmp	 $LN16@ReopenBoot
$LN15@ReopenBoot:

; 760  : 	}
; 761  : 
; 762  : 	if (!ValidateIOBufferSize (irp, sizeof (ReopenBootVolumeHeaderRequest), ValidateInput))

  00058	45 33 c0	 xor	 r8d, r8d
  0005b	ba 48 00 00 00	 mov	 edx, 72			; 00000048H
  00060	48 8b 4c 24 70	 mov	 rcx, QWORD PTR irp$[rsp]
  00065	e8 00 00 00 00	 call	 ValidateIOBufferSize
  0006a	85 c0		 test	 eax, eax
  0006c	75 05		 jne	 SHORT $LN14@ReopenBoot

; 763  : 		return;

  0006e	e9 85 02 00 00	 jmp	 $LN16@ReopenBoot
$LN14@ReopenBoot:

; 764  : 
; 765  : 	if (!BootDriveFound || !BootDriveFilterExtension || !BootDriveFilterExtension->DriveMounted || !BootDriveFilterExtension->HeaderCryptoInfo
; 766  : 		|| request->VolumePassword.Length > MAX_PASSWORD)

  00073	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR BootDriveFound
  00079	85 c0		 test	 eax, eax
  0007b	74 35		 je	 SHORT $LN12@ReopenBoot
  0007d	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR BootDriveFilterExtension, 0
  00085	74 2b		 je	 SHORT $LN12@ReopenBoot
  00087	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  0008e	83 b8 10 03 00
	00 00		 cmp	 DWORD PTR [rax+784], 0
  00095	74 1b		 je	 SHORT $LN12@ReopenBoot
  00097	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  0009e	48 83 b8 30 03
	00 00 00	 cmp	 QWORD PTR [rax+816], 0
  000a6	74 0a		 je	 SHORT $LN12@ReopenBoot
  000a8	48 8b 44 24 38	 mov	 rax, QWORD PTR request$[rsp]
  000ad	83 38 40	 cmp	 DWORD PTR [rax], 64	; 00000040H
  000b0	76 11		 jbe	 SHORT $LN13@ReopenBoot
$LN12@ReopenBoot:

; 767  : 	{
; 768  : 		irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  000b2	48 8b 44 24 70	 mov	 rax, QWORD PTR irp$[rsp]
  000b7	c7 40 30 0d 00
	00 c0		 mov	 DWORD PTR [rax+48], -1073741811 ; ffffffffc000000dH

; 769  : 		goto wipe;

  000be	e9 e3 01 00 00	 jmp	 $wipe$29905
$LN13@ReopenBoot:

; 770  : 	}
; 771  : 
; 772  : 	header = TCalloc (TC_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE);

  000c3	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  000c9	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  000ce	33 c9		 xor	 ecx, ecx
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  000d6	48 89 44 24 40	 mov	 QWORD PTR header$[rsp], rax

; 773  : 	if (!header)

  000db	48 83 7c 24 40
	00		 cmp	 QWORD PTR header$[rsp], 0
  000e1	75 11		 jne	 SHORT $LN11@ReopenBoot

; 774  : 	{
; 775  : 		irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

  000e3	48 8b 44 24 70	 mov	 rax, QWORD PTR irp$[rsp]
  000e8	c7 40 30 9a 00
	00 c0		 mov	 DWORD PTR [rax+48], -1073741670 ; ffffffffc000009aH

; 776  : 		goto wipe;

  000ef	e9 b2 01 00 00	 jmp	 $wipe$29905
$LN11@ReopenBoot:

; 777  : 	}
; 778  : 
; 779  : 	if (BootDriveFilterExtension->HiddenSystem)

  000f4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  000fb	83 b8 38 03 00
	00 00		 cmp	 DWORD PTR [rax+824], 0
  00102	74 14		 je	 SHORT $LN10@ReopenBoot

; 780  : 		offset.QuadPart = BootArgs.HiddenSystemPartitionStart + TC_HIDDEN_VOLUME_HEADER_OFFSET;

  00104	48 8b 05 5a 00
	00 00		 mov	 rax, QWORD PTR BootArgs+90
  0010b	48 05 00 00 01
	00		 add	 rax, 65536		; 00010000H
  00111	48 89 44 24 30	 mov	 QWORD PTR offset$[rsp], rax

; 781  : 	else

  00116	eb 09		 jmp	 SHORT $LN9@ReopenBoot
$LN10@ReopenBoot:

; 782  : 		offset.QuadPart = TC_BOOT_VOLUME_HEADER_SECTOR_OFFSET;

  00118	48 c7 44 24 30
	00 7c 00 00	 mov	 QWORD PTR offset$[rsp], 31744 ; 00007c00H
$LN9@ReopenBoot:

; 783  : 
; 784  : 	irp->IoStatus.Status = TCReadDevice (BootDriveFilterExtension->LowerDeviceObject, header, offset, TC_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE);

  00121	41 b9 00 02 00
	00		 mov	 r9d, 512		; 00000200H
  00127	4c 8b 44 24 30	 mov	 r8, QWORD PTR offset$[rsp]
  0012c	48 8b 54 24 40	 mov	 rdx, QWORD PTR header$[rsp]
  00131	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR BootDriveFilterExtension
  00138	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0013c	e8 00 00 00 00	 call	 TCReadDevice
  00141	44 8b d8	 mov	 r11d, eax
  00144	48 8b 44 24 70	 mov	 rax, QWORD PTR irp$[rsp]
  00149	44 89 58 30	 mov	 DWORD PTR [rax+48], r11d

; 785  : 	if (!NT_SUCCESS (irp->IoStatus.Status))

  0014d	48 8b 44 24 70	 mov	 rax, QWORD PTR irp$[rsp]
  00152	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00156	7d 19		 jge	 SHORT $LN8@ReopenBoot

; 786  : 	{
; 787  : 		Dump ("TCReadDevice error %x\n", irp->IoStatus.Status);

  00158	48 8b 44 24 70	 mov	 rax, QWORD PTR irp$[rsp]
  0015d	8b 50 30	 mov	 edx, DWORD PTR [rax+48]
  00160	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@FBDKNNGH@TCReadDevice?5error?5?$CFx?6?$AA@FNODOBFM@
  00167	e8 00 00 00 00	 call	 DbgPrint

; 788  : 		goto ret;

  0016c	e9 25 01 00 00	 jmp	 $ret$29913
$LN8@ReopenBoot:

; 789  : 	}
; 790  : 
; 791  : 	if (ReadVolumeHeader (!BootDriveFilterExtension->HiddenSystem, header, &request->VolumePassword, NULL, BootDriveFilterExtension->HeaderCryptoInfo) == 0)

  00171	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00178	83 b8 38 03 00
	00 00		 cmp	 DWORD PTR [rax+824], 0
  0017f	75 0a		 jne	 SHORT $LN18@ReopenBoot
  00181	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv149[rsp], 1
  00189	eb 08		 jmp	 SHORT $LN19@ReopenBoot
$LN18@ReopenBoot:
  0018b	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv149[rsp], 0
$LN19@ReopenBoot:
  00193	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  0019a	48 8b 80 30 03
	00 00		 mov	 rax, QWORD PTR [rax+816]
  001a1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a6	45 33 c9	 xor	 r9d, r9d
  001a9	4c 8b 44 24 38	 mov	 r8, QWORD PTR request$[rsp]
  001ae	48 8b 54 24 40	 mov	 rdx, QWORD PTR header$[rsp]
  001b3	8b 4c 24 58	 mov	 ecx, DWORD PTR tv149[rsp]
  001b7	e8 00 00 00 00	 call	 ReadVolumeHeader
  001bc	85 c0		 test	 eax, eax
  001be	0f 85 94 00 00
	00		 jne	 $LN7@ReopenBoot

; 792  : 	{
; 793  : 		Dump ("Header reopened\n");

  001c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@DLMCDLIB@Header?5reopened?6?$AA@FNODOBFM@
  001cb	e8 00 00 00 00	 call	 DbgPrint

; 794  : 		
; 795  : 		BootDriveFilterExtension->Queue.CryptoInfo->header_creation_time = BootDriveFilterExtension->HeaderCryptoInfo->header_creation_time;

  001d0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  001d7	48 8b 80 30 03
	00 00		 mov	 rax, QWORD PTR [rax+816]
  001de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR BootDriveFilterExtension
  001e5	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  001ec	48 8b 80 f8 43
	00 00		 mov	 rax, QWORD PTR [rax+17400]
  001f3	48 89 81 f8 43
	00 00		 mov	 QWORD PTR [rcx+17400], rax

; 796  : 		BootDriveFilterExtension->Queue.CryptoInfo->pkcs5 = BootDriveFilterExtension->HeaderCryptoInfo->pkcs5;

  001fa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00201	48 8b 80 30 03
	00 00		 mov	 rax, QWORD PTR [rax+816]
  00208	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR BootDriveFilterExtension
  0020f	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  00216	8b 80 ec 43 00
	00		 mov	 eax, DWORD PTR [rax+17388]
  0021c	89 81 ec 43 00
	00		 mov	 DWORD PTR [rcx+17388], eax

; 797  : 		BootDriveFilterExtension->Queue.CryptoInfo->noIterations = BootDriveFilterExtension->HeaderCryptoInfo->noIterations;

  00222	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00229	48 8b 80 30 03
	00 00		 mov	 rax, QWORD PTR [rax+816]
  00230	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR BootDriveFilterExtension
  00237	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  0023e	8b 80 e8 43 00
	00		 mov	 eax, DWORD PTR [rax+17384]
  00244	89 81 e8 43 00
	00		 mov	 DWORD PTR [rcx+17384], eax

; 798  : 
; 799  : 		irp->IoStatus.Status = STATUS_SUCCESS;

  0024a	48 8b 44 24 70	 mov	 rax, QWORD PTR irp$[rsp]
  0024f	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 800  : 	}
; 801  : 	else

  00256	eb 3e		 jmp	 SHORT $LN6@ReopenBoot
$LN7@ReopenBoot:

; 802  : 	{
; 803  : 		crypto_close (BootDriveFilterExtension->HeaderCryptoInfo);

  00258	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR BootDriveFilterExtension
  0025f	48 8b 89 30 03
	00 00		 mov	 rcx, QWORD PTR [rcx+816]
  00266	e8 00 00 00 00	 call	 crypto_close

; 804  : 		BootDriveFilterExtension->HeaderCryptoInfo = NULL;

  0026b	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR BootDriveFilterExtension
  00272	49 c7 83 30 03
	00 00 00 00 00
	00		 mov	 QWORD PTR [r11+816], 0

; 805  : 
; 806  : 		Dump ("Header not reopened\n");

  0027d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@GFCPIAML@Header?5not?5reopened?6?$AA@FNODOBFM@
  00284	e8 00 00 00 00	 call	 DbgPrint

; 807  : 		irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  00289	4c 8b 5c 24 70	 mov	 r11, QWORD PTR irp$[rsp]
  0028e	41 c7 43 30 0d
	00 00 c0	 mov	 DWORD PTR [r11+48], -1073741811 ; ffffffffc000000dH
$LN6@ReopenBoot:
$ret$29913:

; 808  : 	}
; 809  : 
; 810  : ret:
; 811  : 	TCfree (header);

  00296	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  0029b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR header$[rsp]
  002a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$wipe$29905:
$LN5@ReopenBoot:

; 812  : wipe:
; 813  : 	burn (request, sizeof (*request));

  002a6	48 8b 44 24 38	 mov	 rax, QWORD PTR request$[rsp]
  002ab	48 89 44 24 50	 mov	 QWORD PTR burnm$29925[rsp], rax
  002b0	c7 44 24 48 48
	00 00 00	 mov	 DWORD PTR burnc$29927[rsp], 72 ; 00000048H
  002b8	ba 48 00 00 00	 mov	 edx, 72			; 00000048H
  002bd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR request$[rsp]
  002c2	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN2@ReopenBoot:
  002c7	8b 4c 24 48	 mov	 ecx, DWORD PTR burnc$29927[rsp]
  002cb	8b 44 24 48	 mov	 eax, DWORD PTR burnc$29927[rsp]
  002cf	83 e8 01	 sub	 eax, 1
  002d2	89 44 24 48	 mov	 DWORD PTR burnc$29927[rsp], eax
  002d6	85 c9		 test	 ecx, ecx
  002d8	74 18		 je	 SHORT $LN1@ReopenBoot
  002da	48 8b 44 24 50	 mov	 rax, QWORD PTR burnm$29925[rsp]
  002df	c6 00 00	 mov	 BYTE PTR [rax], 0
  002e2	48 8b 44 24 50	 mov	 rax, QWORD PTR burnm$29925[rsp]
  002e7	48 83 c0 01	 add	 rax, 1
  002eb	48 89 44 24 50	 mov	 QWORD PTR burnm$29925[rsp], rax
  002f0	eb d5		 jmp	 SHORT $LN2@ReopenBoot
$LN1@ReopenBoot:
  002f2	33 c0		 xor	 eax, eax
  002f4	85 c0		 test	 eax, eax
  002f6	75 ae		 jne	 SHORT $LN5@ReopenBoot
$LN16@ReopenBoot:

; 814  : }

  002f8	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002fc	c3		 ret	 0
ReopenBootVolumeHeader ENDP
PUBLIC	$T46203
PUBLIC	StartDecoySystemWipe
;	COMDAT pdata
pdata	SEGMENT
$pdata$StartDecoySystemWipe DD imagerel $LN14
	DD	imagerel $LN14+368
	DD	imagerel $unwind$StartDecoySystemWipe
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$StartDecoySystemWipe DD 041801H
	DD	0290118H
	DD	060107011H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT StartDecoySystemWipe
_TEXT	SEGMENT
request$ = 32
status$ = 40
burnc$30524 = 44
burnm$30522 = 48
$T46203 = 56
DeviceObject$ = 352
irp$ = 360
irpSp$ = 368
StartDecoySystemWipe PROC				; COMDAT

; 1828 : {

$LN14:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H

; 1829 : 	NTSTATUS status;
; 1830 : 	WipeDecoySystemRequest *request;
; 1831 : 
; 1832 : 	if (!UserCanAccessDriveDevice())

  00018	e8 00 00 00 00	 call	 UserCanAccessDriveDevice
  0001d	85 c0		 test	 eax, eax
  0001f	75 0a		 jne	 SHORT $LN11@StartDecoy

; 1833 : 		return STATUS_ACCESS_DENIED;

  00021	b8 22 00 00 c0	 mov	 eax, -1073741790	; ffffffffc0000022H
  00026	e9 3b 01 00 00	 jmp	 $LN12@StartDecoy
$LN11@StartDecoy:

; 1834 : 
; 1835 : 	if (!IsHiddenSystemRunning()
; 1836 : 		|| irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (WipeDecoySystemRequest))

  0002b	e8 00 00 00 00	 call	 IsHiddenSystemRunning
  00030	85 c0		 test	 eax, eax
  00032	74 13		 je	 SHORT $LN9@StartDecoy
  00034	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR irpSp$[rsp]
  0003c	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0003f	48 3d 04 01 00
	00		 cmp	 rax, 260		; 00000104H
  00045	73 0a		 jae	 SHORT $LN10@StartDecoy
$LN9@StartDecoy:

; 1837 : 		return STATUS_INVALID_PARAMETER;

  00047	b8 0d 00 00 c0	 mov	 eax, -1073741811	; ffffffffc000000dH
  0004c	e9 15 01 00 00	 jmp	 $LN12@StartDecoy
$LN10@StartDecoy:

; 1838 : 
; 1839 : 	if (DecoySystemWipeInProgress)

  00051	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR DecoySystemWipeInProgress
  00057	85 c0		 test	 eax, eax
  00059	74 07		 je	 SHORT $LN8@StartDecoy

; 1840 : 		return STATUS_SUCCESS;

  0005b	33 c0		 xor	 eax, eax
  0005d	e9 04 01 00 00	 jmp	 $LN12@StartDecoy
$LN8@StartDecoy:

; 1841 : 
; 1842 : 	if (DecoySystemWipeThread)

  00062	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR DecoySystemWipeThread, 0
  0006a	74 05		 je	 SHORT $LN7@StartDecoy

; 1843 : 		AbortDecoySystemWipe();

  0006c	e8 00 00 00 00	 call	 AbortDecoySystemWipe
$LN7@StartDecoy:

; 1844 : 
; 1845 : 	request = (WipeDecoySystemRequest *) irp->AssociatedIrp.SystemBuffer;

  00071	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR irp$[rsp]
  00079	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0007d	48 89 44 24 20	 mov	 QWORD PTR request$[rsp], rax

; 1846 : 	WipeDecoyRequest = *request;

  00082	48 8d 7c 24 38	 lea	 rdi, QWORD PTR $T46203[rsp]
  00087	48 8b 74 24 20	 mov	 rsi, QWORD PTR request$[rsp]
  0008c	b9 04 01 00 00	 mov	 ecx, 260		; 00000104H
  00091	f3 a4		 rep movsb
  00093	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:WipeDecoyRequest
  0009a	48 8d 74 24 38	 lea	 rsi, QWORD PTR $T46203[rsp]
  0009f	b9 04 01 00 00	 mov	 ecx, 260		; 00000104H
  000a4	f3 a4		 rep movsb
$LN6@StartDecoy:

; 1847 : 
; 1848 : 	burn (request->WipeKey, sizeof (request->WipeKey));

  000a6	48 8b 44 24 20	 mov	 rax, QWORD PTR request$[rsp]
  000ab	48 83 c0 04	 add	 rax, 4
  000af	48 89 44 24 30	 mov	 QWORD PTR burnm$30522[rsp], rax
  000b4	c7 44 24 2c 00
	01 00 00	 mov	 DWORD PTR burnc$30524[rsp], 256 ; 00000100H
  000bc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR request$[rsp]
  000c1	48 83 c1 04	 add	 rcx, 4
  000c5	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  000ca	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN3@StartDecoy:
  000cf	8b 4c 24 2c	 mov	 ecx, DWORD PTR burnc$30524[rsp]
  000d3	8b 44 24 2c	 mov	 eax, DWORD PTR burnc$30524[rsp]
  000d7	83 e8 01	 sub	 eax, 1
  000da	89 44 24 2c	 mov	 DWORD PTR burnc$30524[rsp], eax
  000de	85 c9		 test	 ecx, ecx
  000e0	74 18		 je	 SHORT $LN2@StartDecoy
  000e2	48 8b 44 24 30	 mov	 rax, QWORD PTR burnm$30522[rsp]
  000e7	c6 00 00	 mov	 BYTE PTR [rax], 0
  000ea	48 8b 44 24 30	 mov	 rax, QWORD PTR burnm$30522[rsp]
  000ef	48 83 c0 01	 add	 rax, 1
  000f3	48 89 44 24 30	 mov	 QWORD PTR burnm$30522[rsp], rax
  000f8	eb d5		 jmp	 SHORT $LN3@StartDecoy
$LN2@StartDecoy:
  000fa	33 c0		 xor	 eax, eax
  000fc	85 c0		 test	 eax, eax
  000fe	75 a6		 jne	 SHORT $LN6@StartDecoy

; 1849 : 
; 1850 : 	DecoySystemWipeThreadAbortRequested = FALSE;

  00100	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR DecoySystemWipeThreadAbortRequested, 0

; 1851 : 	KeInitializeSpinLock (&DecoySystemWipeStatusSpinLock);

  0010a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:DecoySystemWipeStatusSpinLock
  00111	e8 00 00 00 00	 call	 KeInitializeSpinLock

; 1852 : 	DecoySystemWipedAreaEnd = BootDriveFilterExtension->ConfiguredEncryptedAreaStart;

  00116	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  0011d	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00121	48 89 05 00 00
	00 00		 mov	 QWORD PTR DecoySystemWipedAreaEnd, rax

; 1853 : 
; 1854 : 	DecoySystemWipeInProgress = TRUE;

  00128	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR DecoySystemWipeInProgress, 1

; 1855 : 	status = TCStartThread (DecoySystemWipeThreadProc, DeviceObject, &DecoySystemWipeThread);

  00132	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:DecoySystemWipeThread
  00139	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR DeviceObject$[rsp]
  00141	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:DecoySystemWipeThreadProc
  00148	e8 00 00 00 00	 call	 TCStartThread
  0014d	89 44 24 28	 mov	 DWORD PTR status$[rsp], eax

; 1856 : 	
; 1857 : 	if (!NT_SUCCESS (status))

  00151	83 7c 24 28 00	 cmp	 DWORD PTR status$[rsp], 0
  00156	7d 0a		 jge	 SHORT $LN1@StartDecoy

; 1858 : 		DecoySystemWipeInProgress = FALSE;

  00158	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR DecoySystemWipeInProgress, 0
$LN1@StartDecoy:

; 1859 : 
; 1860 : 	return status;

  00162	8b 44 24 28	 mov	 eax, DWORD PTR status$[rsp]
$LN12@StartDecoy:

; 1861 : }

  00166	48 81 c4 48 01
	00 00		 add	 rsp, 328		; 00000148H
  0016d	5f		 pop	 rdi
  0016e	5e		 pop	 rsi
  0016f	c3		 ret	 0
StartDecoySystemWipe ENDP
_TEXT	ENDS
PUBLIC	$T46213
PUBLIC	StartBootEncryptionSetup
;	COMDAT pdata
pdata	SEGMENT
$pdata$StartBootEncryptionSetup DD imagerel $LN10
	DD	imagerel $LN10+321
	DD	imagerel $unwind$StartBootEncryptionSetup
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$StartBootEncryptionSetup DD 031501H
	DD	070118215H
	DD	06010H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT StartBootEncryptionSetup
_TEXT	SEGMENT
status$ = 32
$T46213 = 40
tv85 = 56
DeviceObject$ = 96
irp$ = 104
irpSp$ = 112
StartBootEncryptionSetup PROC				; COMDAT

; 1473 : {

$LN10:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1474 : 	NTSTATUS status;
; 1475 : 
; 1476 : 	if (!UserCanAccessDriveDevice())

  00015	e8 00 00 00 00	 call	 UserCanAccessDriveDevice
  0001a	85 c0		 test	 eax, eax
  0001c	75 0a		 jne	 SHORT $LN5@StartBootE

; 1477 : 		return STATUS_ACCESS_DENIED;

  0001e	b8 22 00 00 c0	 mov	 eax, -1073741790	; ffffffffc0000022H
  00023	e9 12 01 00 00	 jmp	 $LN6@StartBootE
$LN5@StartBootE:

; 1478 : 
; 1479 : 	if (SetupInProgress || !BootDriveFound || !BootDriveFilterExtension
; 1480 : 		|| !BootDriveFilterExtension->DriveMounted
; 1481 : 		|| BootDriveFilterExtension->HiddenSystem
; 1482 : 		|| irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (BootEncryptionSetupRequest))

  00028	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR SetupInProgress
  0002e	85 c0		 test	 eax, eax
  00030	75 42		 jne	 SHORT $LN3@StartBootE
  00032	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR BootDriveFound
  00038	85 c0		 test	 eax, eax
  0003a	74 38		 je	 SHORT $LN3@StartBootE
  0003c	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR BootDriveFilterExtension, 0
  00044	74 2e		 je	 SHORT $LN3@StartBootE
  00046	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  0004d	83 b8 10 03 00
	00 00		 cmp	 DWORD PTR [rax+784], 0
  00054	74 1e		 je	 SHORT $LN3@StartBootE
  00056	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  0005d	83 b8 38 03 00
	00 00		 cmp	 DWORD PTR [rax+824], 0
  00064	75 0e		 jne	 SHORT $LN3@StartBootE
  00066	48 8b 44 24 70	 mov	 rax, QWORD PTR irpSp$[rsp]
  0006b	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0006e	48 83 f8 10	 cmp	 rax, 16
  00072	73 0a		 jae	 SHORT $LN4@StartBootE
$LN3@StartBootE:

; 1483 : 		return STATUS_INVALID_PARAMETER;

  00074	b8 0d 00 00 c0	 mov	 eax, -1073741811	; ffffffffc000000dH
  00079	e9 bc 00 00 00	 jmp	 $LN6@StartBootE
$LN4@StartBootE:

; 1484 : 
; 1485 : 	if (EncryptionSetupThread)

  0007e	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR EncryptionSetupThread, 0
  00086	74 05		 je	 SHORT $LN2@StartBootE

; 1486 : 		AbortBootEncryptionSetup();

  00088	e8 00 00 00 00	 call	 AbortBootEncryptionSetup
$LN2@StartBootE:

; 1487 : 
; 1488 : 	SetupRequest = *(BootEncryptionSetupRequest *) irp->AssociatedIrp.SystemBuffer;

  0008d	48 8b 74 24 68	 mov	 rsi, QWORD PTR irp$[rsp]
  00092	48 8b 76 18	 mov	 rsi, QWORD PTR [rsi+24]
  00096	48 8d 7c 24 28	 lea	 rdi, QWORD PTR $T46213[rsp]
  0009b	b9 10 00 00 00	 mov	 ecx, 16
  000a0	f3 a4		 rep movsb
  000a2	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:SetupRequest
  000a9	48 8d 74 24 28	 lea	 rsi, QWORD PTR $T46213[rsp]
  000ae	b9 10 00 00 00	 mov	 ecx, 16
  000b3	f3 a4		 rep movsb

; 1489 : 
; 1490 : 	EncryptionSetupThreadAbortRequested = FALSE;

  000b5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR EncryptionSetupThreadAbortRequested, 0

; 1491 : 	KeInitializeSpinLock (&SetupStatusSpinLock);

  000bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:SetupStatusSpinLock
  000c6	e8 00 00 00 00	 call	 KeInitializeSpinLock

; 1492 : 	SetupStatusEncryptedAreaEnd = BootDriveFilterExtension ? BootDriveFilterExtension->Queue.EncryptedAreaEnd : -1;

  000cb	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR BootDriveFilterExtension, 0
  000d3	74 15		 je	 SHORT $LN8@StartBootE
  000d5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  000dc	48 8b 80 d0 00
	00 00		 mov	 rax, QWORD PTR [rax+208]
  000e3	48 89 44 24 38	 mov	 QWORD PTR tv85[rsp], rax
  000e8	eb 09		 jmp	 SHORT $LN9@StartBootE
$LN8@StartBootE:
  000ea	48 c7 44 24 38
	ff ff ff ff	 mov	 QWORD PTR tv85[rsp], -1
$LN9@StartBootE:
  000f3	48 8b 44 24 38	 mov	 rax, QWORD PTR tv85[rsp]
  000f8	48 89 05 00 00
	00 00		 mov	 QWORD PTR SetupStatusEncryptedAreaEnd, rax

; 1493 : 
; 1494 : 	SetupInProgress = TRUE;

  000ff	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR SetupInProgress, 1

; 1495 : 	status = TCStartThread (SetupThreadProc, DeviceObject, &EncryptionSetupThread);

  00109	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:EncryptionSetupThread
  00110	48 8b 54 24 60	 mov	 rdx, QWORD PTR DeviceObject$[rsp]
  00115	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:SetupThreadProc
  0011c	e8 00 00 00 00	 call	 TCStartThread
  00121	89 44 24 20	 mov	 DWORD PTR status$[rsp], eax

; 1496 : 	
; 1497 : 	if (!NT_SUCCESS (status))

  00125	83 7c 24 20 00	 cmp	 DWORD PTR status$[rsp], 0
  0012a	7d 0a		 jge	 SHORT $LN1@StartBootE

; 1498 : 		SetupInProgress = FALSE;

  0012c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR SetupInProgress, 0
$LN1@StartBootE:

; 1499 : 
; 1500 : 	return status;

  00136	8b 44 24 20	 mov	 eax, DWORD PTR status$[rsp]
$LN6@StartBootE:

; 1501 : }

  0013a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0013e	5f		 pop	 rdi
  0013f	5e		 pop	 rsi
  00140	c3		 ret	 0
StartBootEncryptionSetup ENDP
	ALIGN	8

OriginalHiberDriverEntries DQ 03H DUP (?)
;	COMDAT pdata
pdata	SEGMENT
$pdata$HiberDriverEntryFilter DD imagerel HiberDriverEntryFilter
	DD	imagerel HiberDriverEntryFilter+633
	DD	imagerel $unwind$HiberDriverEntryFilter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$HiberDriverEntryFilter DD 011201H
	DD	08212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT HiberDriverEntryFilter
_TEXT	SEGMENT
filterInstalled$ = 48
status$ = 52
tv91 = 56
tv143 = 60
filterNumber$ = 80
arg0$ = 88
hiberDriverContext$ = 96
HiberDriverEntryFilter PROC				; COMDAT

; 961  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 962  : 	BOOL filterInstalled = FALSE;

  00012	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR filterInstalled$[rsp], 0

; 963  : 	NTSTATUS status;
; 964  : 
; 965  : 	if (!OriginalHiberDriverEntries[filterNumber])

  0001a	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR filterNumber$[rsp]
  0001f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:OriginalHiberDriverEntries
  00026	48 83 3c c8 00	 cmp	 QWORD PTR [rax+rcx*8], 0
  0002b	75 0a		 jne	 SHORT $LN20@HiberDrive@2

; 966  : 		return STATUS_UNSUCCESSFUL;

  0002d	b8 01 00 00 c0	 mov	 eax, -1073741823	; ffffffffc0000001H
  00032	e9 3d 02 00 00	 jmp	 $LN21@HiberDrive@2
$LN20@HiberDrive@2:

; 967  : 
; 968  : 	status = (*OriginalHiberDriverEntries[filterNumber]) (arg0, hiberDriverContext);

  00037	4c 63 44 24 50	 movsxd	 r8, DWORD PTR filterNumber$[rsp]
  0003c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:OriginalHiberDriverEntries
  00043	48 8b 54 24 60	 mov	 rdx, QWORD PTR hiberDriverContext$[rsp]
  00048	48 8b 4c 24 58	 mov	 rcx, QWORD PTR arg0$[rsp]
  0004d	42 ff 14 c0	 call	 QWORD PTR [rax+r8*8]
  00051	89 44 24 34	 mov	 DWORD PTR status$[rsp], eax

; 969  : 
; 970  : 	if (!NT_SUCCESS (status) || !hiberDriverContext)

  00055	83 7c 24 34 00	 cmp	 DWORD PTR status$[rsp], 0
  0005a	7c 08		 jl	 SHORT $LN18@HiberDrive@2
  0005c	48 83 7c 24 60
	00		 cmp	 QWORD PTR hiberDriverContext$[rsp], 0
  00062	75 09		 jne	 SHORT $LN19@HiberDrive@2
$LN18@HiberDrive@2:

; 971  : 		return status;

  00064	8b 44 24 34	 mov	 eax, DWORD PTR status$[rsp]
  00068	e9 07 02 00 00	 jmp	 $LN21@HiberDrive@2
$LN19@HiberDrive@2:

; 972  : 
; 973  : 	if (SetupInProgress)

  0006d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR SetupInProgress
  00073	85 c0		 test	 eax, eax
  00075	74 23		 je	 SHORT $LN17@HiberDrive@2

; 974  : 		TC_BUG_CHECK (STATUS_INVALID_PARAMETER);

  00077	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00080	45 33 c9	 xor	 r9d, r9d
  00083	49 c7 c0 0d 00
	00 c0		 mov	 r8, -1073741811		; ffffffffc000000dH
  0008a	ba ce 03 00 00	 mov	 edx, 974		; 000003ceH
  0008f	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN17@HiberDrive@2:

; 975  : 
; 976  : 	if (hiberDriverContext->WriteFunctionA)

  0009a	48 8b 44 24 60	 mov	 rax, QWORD PTR hiberDriverContext$[rsp]
  0009f	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  000a7	0f 84 b1 00 00
	00		 je	 $LN16@HiberDrive@2

; 977  : 	{
; 978  : 		Dump ("Filtering WriteFunctionA %d\n", filterNumber);

  000ad	8b 54 24 50	 mov	 edx, DWORD PTR filterNumber$[rsp]
  000b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@EAICPFDC@Filtering?5WriteFunctionA?5?$CFd?6?$AA@FNODOBFM@
  000b8	e8 00 00 00 00	 call	 DbgPrint

; 979  : 		OriginalHiberDriverWriteFunctionsA[filterNumber] = hiberDriverContext->WriteFunctionA;

  000bd	4c 63 5c 24 50	 movsxd	 r11, DWORD PTR filterNumber$[rsp]
  000c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:OriginalHiberDriverWriteFunctionsA
  000c9	48 8b 44 24 60	 mov	 rax, QWORD PTR hiberDriverContext$[rsp]
  000ce	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000d5	4a 89 04 d9	 mov	 QWORD PTR [rcx+r11*8], rax

; 980  : 
; 981  : 		switch (filterNumber)

  000d9	8b 44 24 50	 mov	 eax, DWORD PTR filterNumber$[rsp]
  000dd	89 44 24 38	 mov	 DWORD PTR tv91[rsp], eax
  000e1	83 7c 24 38 00	 cmp	 DWORD PTR tv91[rsp], 0
  000e6	74 10		 je	 SHORT $LN13@HiberDrive@2
  000e8	83 7c 24 38 01	 cmp	 DWORD PTR tv91[rsp], 1
  000ed	74 1e		 je	 SHORT $LN12@HiberDrive@2
  000ef	83 7c 24 38 02	 cmp	 DWORD PTR tv91[rsp], 2
  000f4	74 2c		 je	 SHORT $LN11@HiberDrive@2
  000f6	eb 3f		 jmp	 SHORT $LN10@HiberDrive@2
$LN13@HiberDrive@2:

; 982  : 		{
; 983  : 		case 0: hiberDriverContext->WriteFunctionA = HiberDriverWriteFunctionAFilter0; break;

  000f8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR hiberDriverContext$[rsp]
  000fd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:HiberDriverWriteFunctionAFilter0
  00104	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax
  0010b	eb 49		 jmp	 SHORT $LN14@HiberDrive@2
$LN12@HiberDrive@2:

; 984  : 		case 1: hiberDriverContext->WriteFunctionA = HiberDriverWriteFunctionAFilter1; break;

  0010d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR hiberDriverContext$[rsp]
  00112	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:HiberDriverWriteFunctionAFilter1
  00119	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax
  00120	eb 34		 jmp	 SHORT $LN14@HiberDrive@2
$LN11@HiberDrive@2:

; 985  : 		case 2: hiberDriverContext->WriteFunctionA = HiberDriverWriteFunctionAFilter2; break;

  00122	48 8b 4c 24 60	 mov	 rcx, QWORD PTR hiberDriverContext$[rsp]
  00127	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:HiberDriverWriteFunctionAFilter2
  0012e	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax
  00135	eb 1f		 jmp	 SHORT $LN14@HiberDrive@2
$LN10@HiberDrive@2:

; 986  : 		default: TC_THROW_FATAL_EXCEPTION;

  00137	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00140	45 33 c9	 xor	 r9d, r9d
  00143	45 33 c0	 xor	 r8d, r8d
  00146	ba da 03 00 00	 mov	 edx, 986		; 000003daH
  0014b	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  00150	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN14@HiberDrive@2:

; 987  : 		}
; 988  : 
; 989  : 		filterInstalled = TRUE;

  00156	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR filterInstalled$[rsp], 1
$LN16@HiberDrive@2:

; 990  : 	}
; 991  : 
; 992  : 	if (hiberDriverContext->WriteFunctionB)

  0015e	48 8b 44 24 60	 mov	 rax, QWORD PTR hiberDriverContext$[rsp]
  00163	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  00168	0f 84 a5 00 00
	00		 je	 $LN9@HiberDrive@2

; 993  : 	{
; 994  : 		Dump ("Filtering WriteFunctionB %d\n", filterNumber);

  0016e	8b 54 24 50	 mov	 edx, DWORD PTR filterNumber$[rsp]
  00172	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@MGBGIHJM@Filtering?5WriteFunctionB?5?$CFd?6?$AA@FNODOBFM@
  00179	e8 00 00 00 00	 call	 DbgPrint

; 995  : 		OriginalHiberDriverWriteFunctionsB[filterNumber] = hiberDriverContext->WriteFunctionB;

  0017e	4c 63 5c 24 50	 movsxd	 r11, DWORD PTR filterNumber$[rsp]
  00183	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:OriginalHiberDriverWriteFunctionsB
  0018a	48 8b 44 24 60	 mov	 rax, QWORD PTR hiberDriverContext$[rsp]
  0018f	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00193	4a 89 04 d9	 mov	 QWORD PTR [rcx+r11*8], rax

; 996  : 
; 997  : 		switch (filterNumber)

  00197	8b 44 24 50	 mov	 eax, DWORD PTR filterNumber$[rsp]
  0019b	89 44 24 3c	 mov	 DWORD PTR tv143[rsp], eax
  0019f	83 7c 24 3c 00	 cmp	 DWORD PTR tv143[rsp], 0
  001a4	74 10		 je	 SHORT $LN6@HiberDrive@2
  001a6	83 7c 24 3c 01	 cmp	 DWORD PTR tv143[rsp], 1
  001ab	74 1b		 je	 SHORT $LN5@HiberDrive@2
  001ad	83 7c 24 3c 02	 cmp	 DWORD PTR tv143[rsp], 2
  001b2	74 26		 je	 SHORT $LN4@HiberDrive@2
  001b4	eb 36		 jmp	 SHORT $LN3@HiberDrive@2
$LN6@HiberDrive@2:

; 998  : 		{
; 999  : 		case 0: hiberDriverContext->WriteFunctionB = HiberDriverWriteFunctionBFilter0; break;

  001b6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR hiberDriverContext$[rsp]
  001bb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:HiberDriverWriteFunctionBFilter0
  001c2	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax
  001c6	eb 43		 jmp	 SHORT $LN7@HiberDrive@2
$LN5@HiberDrive@2:

; 1000 : 		case 1: hiberDriverContext->WriteFunctionB = HiberDriverWriteFunctionBFilter1; break;

  001c8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR hiberDriverContext$[rsp]
  001cd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:HiberDriverWriteFunctionBFilter1
  001d4	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax
  001d8	eb 31		 jmp	 SHORT $LN7@HiberDrive@2
$LN4@HiberDrive@2:

; 1001 : 		case 2: hiberDriverContext->WriteFunctionB = HiberDriverWriteFunctionBFilter2; break;

  001da	48 8b 4c 24 60	 mov	 rcx, QWORD PTR hiberDriverContext$[rsp]
  001df	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:HiberDriverWriteFunctionBFilter2
  001e6	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax
  001ea	eb 1f		 jmp	 SHORT $LN7@HiberDrive@2
$LN3@HiberDrive@2:

; 1002 : 		default: TC_THROW_FATAL_EXCEPTION;

  001ec	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  001f5	45 33 c9	 xor	 r9d, r9d
  001f8	45 33 c0	 xor	 r8d, r8d
  001fb	ba ea 03 00 00	 mov	 edx, 1002		; 000003eaH
  00200	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  00205	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN7@HiberDrive@2:

; 1003 : 		}
; 1004 : 
; 1005 : 		filterInstalled = TRUE;

  0020b	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR filterInstalled$[rsp], 1
$LN9@HiberDrive@2:

; 1006 : 	}
; 1007 : 
; 1008 : 	if (filterInstalled && hiberDriverContext->PartitionStartOffset.QuadPart != 0)

  00213	83 7c 24 30 00	 cmp	 DWORD PTR filterInstalled$[rsp], 0
  00218	74 58		 je	 SHORT $LN2@HiberDrive@2
  0021a	48 8b 44 24 60	 mov	 rax, QWORD PTR hiberDriverContext$[rsp]
  0021f	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  00227	74 49		 je	 SHORT $LN2@HiberDrive@2

; 1009 : 	{
; 1010 : 		HiberPartitionOffset = hiberDriverContext->PartitionStartOffset;

  00229	48 8b 44 24 60	 mov	 rax, QWORD PTR hiberDriverContext$[rsp]
  0022e	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00235	48 89 05 00 00
	00 00		 mov	 QWORD PTR HiberPartitionOffset, rax

; 1011 : 
; 1012 : 		if (BootDriveFilterExtension->Queue.RemapEncryptedArea)

  0023c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00243	83 b8 dc 00 00
	00 00		 cmp	 DWORD PTR [rax+220], 0
  0024a	74 26		 je	 SHORT $LN1@HiberDrive@2

; 1013 : 			hiberDriverContext->PartitionStartOffset.QuadPart += BootDriveFilterExtension->Queue.RemappedAreaOffset;

  0024c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR hiberDriverContext$[rsp]
  00251	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00258	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  0025f	48 03 88 e0 00
	00 00		 add	 rcx, QWORD PTR [rax+224]
  00266	48 8b 44 24 60	 mov	 rax, QWORD PTR hiberDriverContext$[rsp]
  0026b	48 89 88 a0 00
	00 00		 mov	 QWORD PTR [rax+160], rcx
$LN1@HiberDrive@2:
$LN2@HiberDrive@2:

; 1014 : 	}
; 1015 : 
; 1016 : 	return STATUS_SUCCESS;

  00272	33 c0		 xor	 eax, eax
$LN21@HiberDrive@2:
$LN22@HiberDrive@2:

; 1017 : }

  00274	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00278	c3		 ret	 0
HiberDriverEntryFilter ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$HiberDriverEntryFilter2 DD imagerel HiberDriverEntryFilter2
	DD	imagerel HiberDriverEntryFilter2+39
	DD	imagerel $unwind$HiberDriverEntryFilter2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$HiberDriverEntryFilter2 DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT HiberDriverEntryFilter2
_TEXT	SEGMENT
arg0$ = 48
hiberDriverContext$ = 56
HiberDriverEntryFilter2 PROC				; COMDAT

; 1033 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1034 : 	return HiberDriverEntryFilter (2, arg0, hiberDriverContext);

  0000e	4c 8b 44 24 38	 mov	 r8, QWORD PTR hiberDriverContext$[rsp]
  00013	48 8b 54 24 30	 mov	 rdx, QWORD PTR arg0$[rsp]
  00018	b9 02 00 00 00	 mov	 ecx, 2
  0001d	e8 00 00 00 00	 call	 HiberDriverEntryFilter

; 1035 : }

  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
HiberDriverEntryFilter2 ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$HiberDriverEntryFilter1 DD imagerel HiberDriverEntryFilter1
	DD	imagerel HiberDriverEntryFilter1+39
	DD	imagerel $unwind$HiberDriverEntryFilter1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$HiberDriverEntryFilter1 DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT HiberDriverEntryFilter1
_TEXT	SEGMENT
arg0$ = 48
hiberDriverContext$ = 56
HiberDriverEntryFilter1 PROC				; COMDAT

; 1027 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1028 : 	return HiberDriverEntryFilter (1, arg0, hiberDriverContext);

  0000e	4c 8b 44 24 38	 mov	 r8, QWORD PTR hiberDriverContext$[rsp]
  00013	48 8b 54 24 30	 mov	 rdx, QWORD PTR arg0$[rsp]
  00018	b9 01 00 00 00	 mov	 ecx, 1
  0001d	e8 00 00 00 00	 call	 HiberDriverEntryFilter

; 1029 : }

  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
HiberDriverEntryFilter1 ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$HiberDriverEntryFilter0 DD imagerel HiberDriverEntryFilter0
	DD	imagerel HiberDriverEntryFilter0+36
	DD	imagerel $unwind$HiberDriverEntryFilter0
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$HiberDriverEntryFilter0 DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT HiberDriverEntryFilter0
_TEXT	SEGMENT
arg0$ = 48
hiberDriverContext$ = 56
HiberDriverEntryFilter0 PROC				; COMDAT

; 1021 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1022 : 	return HiberDriverEntryFilter (0, arg0, hiberDriverContext);

  0000e	4c 8b 44 24 38	 mov	 r8, QWORD PTR hiberDriverContext$[rsp]
  00013	48 8b 54 24 30	 mov	 rdx, QWORD PTR arg0$[rsp]
  00018	33 c9		 xor	 ecx, ecx
  0001a	e8 00 00 00 00	 call	 HiberDriverEntryFilter

; 1023 : }

  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	c3		 ret	 0
HiberDriverEntryFilter0 ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$LoadImageNotifyRoutine DD imagerel LoadImageNotifyRoutine
	DD	imagerel LoadImageNotifyRoutine+602
	DD	imagerel $unwind$LoadImageNotifyRoutine
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$LoadImageNotifyRoutine DD 011301H
	DD	0c213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT LoadImageNotifyRoutine
_TEXT	SEGMENT
listEntry$ = 48
origIrql$ = 56
moduleItem$ = 64
filterEntry$30172 = 72
tv146 = 80
fullImageName$ = 112
processId$ = 120
imageInfo$ = 128
LoadImageNotifyRoutine PROC				; COMDAT

; 1039 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1040 : 	ModuleTableItem *moduleItem;
; 1041 : 	LIST_ENTRY *listEntry;
; 1042 : 	KIRQL origIrql;
; 1043 : 
; 1044 : 	if (!imageInfo || !imageInfo->SystemModeImage || !imageInfo->ImageBase || !TCDriverObject->DriverSection)

  00013	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR imageInfo$[rsp], 0
  0001c	74 31		 je	 SHORT $LN18@LoadImageN
  0001e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR imageInfo$[rsp]
  00026	8b 00		 mov	 eax, DWORD PTR [rax]
  00028	c1 e8 08	 shr	 eax, 8
  0002b	83 e0 01	 and	 eax, 1
  0002e	85 c0		 test	 eax, eax
  00030	74 1d		 je	 SHORT $LN18@LoadImageN
  00032	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR imageInfo$[rsp]
  0003a	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0003f	74 0e		 je	 SHORT $LN18@LoadImageN
  00041	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR TCDriverObject
  00048	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0004d	75 05		 jne	 SHORT $LN19@LoadImageN
$LN18@LoadImageN:

; 1045 : 		return;

  0004f	e9 01 02 00 00	 jmp	 $LN20@LoadImageN
$LN19@LoadImageN:

; 1046 : 
; 1047 : 	moduleItem = *(ModuleTableItem **) TCDriverObject->DriverSection;

  00054	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR TCDriverObject
  0005b	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0005f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00062	48 89 44 24 40	 mov	 QWORD PTR moduleItem$[rsp], rax

; 1048 : 	if (!moduleItem || !moduleItem->ModuleList.Flink)

  00067	48 83 7c 24 40
	00		 cmp	 QWORD PTR moduleItem$[rsp], 0
  0006d	74 0b		 je	 SHORT $LN16@LoadImageN
  0006f	48 8b 44 24 40	 mov	 rax, QWORD PTR moduleItem$[rsp]
  00074	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00078	75 05		 jne	 SHORT $LN17@LoadImageN
$LN16@LoadImageN:

; 1049 : 		return;

  0007a	e9 d6 01 00 00	 jmp	 $LN20@LoadImageN
$LN17@LoadImageN:

; 1050 : 
; 1051 : 	// Search loaded system modules for hibernation driver
; 1052 : 	origIrql = KeRaiseIrqlToDpcLevel();

  0007f	e8 00 00 00 00	 call	 KeRaiseIrqlToDpcLevel
  00084	88 44 24 38	 mov	 BYTE PTR origIrql$[rsp], al

; 1053 : 
; 1054 : 	for (listEntry = moduleItem->ModuleList.Flink->Blink;
; 1055 : 		listEntry && listEntry != TCDriverObject->DriverSection;
; 1056 : 		listEntry = listEntry->Flink)

  00088	48 8b 44 24 40	 mov	 rax, QWORD PTR moduleItem$[rsp]
  0008d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00090	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00094	48 89 44 24 30	 mov	 QWORD PTR listEntry$[rsp], rax
  00099	eb 0d		 jmp	 SHORT $LN15@LoadImageN
$LN14@LoadImageN:
  0009b	48 8b 44 24 30	 mov	 rax, QWORD PTR listEntry$[rsp]
  000a0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a3	48 89 44 24 30	 mov	 QWORD PTR listEntry$[rsp], rax
$LN15@LoadImageN:
  000a8	48 83 7c 24 30
	00		 cmp	 QWORD PTR listEntry$[rsp], 0
  000ae	0f 84 97 01 00
	00		 je	 $LN13@LoadImageN
  000b4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR TCDriverObject
  000bb	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000bf	48 39 44 24 30	 cmp	 QWORD PTR listEntry$[rsp], rax
  000c4	0f 84 81 01 00
	00		 je	 $LN13@LoadImageN

; 1057 : 	{
; 1058 : 		moduleItem = CONTAINING_RECORD (listEntry, ModuleTableItem, ModuleList);

  000ca	48 8b 44 24 30	 mov	 rax, QWORD PTR listEntry$[rsp]
  000cf	48 89 44 24 40	 mov	 QWORD PTR moduleItem$[rsp], rax

; 1059 : 
; 1060 : 		if (moduleItem && imageInfo->ImageBase == moduleItem->ModuleBaseAddress)

  000d4	48 83 7c 24 40
	00		 cmp	 QWORD PTR moduleItem$[rsp], 0
  000da	0f 84 66 01 00
	00		 je	 $LN12@LoadImageN
  000e0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR imageInfo$[rsp]
  000e8	48 8b 44 24 40	 mov	 rax, QWORD PTR moduleItem$[rsp]
  000ed	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000f1	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  000f5	0f 85 4b 01 00
	00		 jne	 $LN12@LoadImageN

; 1061 : 		{
; 1062 : 			if (moduleItem->ModuleName.Buffer && moduleItem->ModuleName.Length >= 5 * sizeof (wchar_t))

  000fb	48 8b 44 24 40	 mov	 rax, QWORD PTR moduleItem$[rsp]
  00100	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00105	0f 84 39 01 00
	00		 je	 $LN11@LoadImageN
  0010b	48 8b 44 24 40	 mov	 rax, QWORD PTR moduleItem$[rsp]
  00110	0f b7 40 58	 movzx	 eax, WORD PTR [rax+88]
  00114	48 83 f8 0a	 cmp	 rax, 10
  00118	0f 82 26 01 00
	00		 jb	 $LN11@LoadImageN

; 1063 : 			{
; 1064 : 				if (memcmp (moduleItem->ModuleName.Buffer, L"hiber", 5 * sizeof (wchar_t)) == 0
; 1065 : 					|| memcmp (moduleItem->ModuleName.Buffer, L"Hiber", 5 * sizeof (wchar_t)) == 0
; 1066 : 					|| memcmp (moduleItem->ModuleName.Buffer, L"HIBER", 5 * sizeof (wchar_t)) == 0)

  0011e	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00124	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1M@IMEHFNOE@?$AAh?$AAi?$AAb?$AAe?$AAr?$AA?$AA@FNODOBFM@
  0012b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR moduleItem$[rsp]
  00130	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00134	e8 00 00 00 00	 call	 memcmp
  00139	85 c0		 test	 eax, eax
  0013b	74 42		 je	 SHORT $LN9@LoadImageN
  0013d	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00143	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1M@JEHGIGBM@?$AAH?$AAi?$AAb?$AAe?$AAr?$AA?$AA@FNODOBFM@
  0014a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR moduleItem$[rsp]
  0014f	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00153	e8 00 00 00 00	 call	 memcmp
  00158	85 c0		 test	 eax, eax
  0015a	74 23		 je	 SHORT $LN9@LoadImageN
  0015c	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00162	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1M@IFMDENJC@?$AAH?$AAI?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@
  00169	48 8b 4c 24 40	 mov	 rcx, QWORD PTR moduleItem$[rsp]
  0016e	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00172	e8 00 00 00 00	 call	 memcmp
  00177	85 c0		 test	 eax, eax
  00179	0f 85 c5 00 00
	00		 jne	 $LN10@LoadImageN
$LN9@LoadImageN:

; 1067 : 				{
; 1068 : 					HiberDriverEntry filterEntry;
; 1069 : 
; 1070 : 					switch (LastHiberFilterNumber)

  0017f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR LastHiberFilterNumber
  00185	89 44 24 50	 mov	 DWORD PTR tv146[rsp], eax
  00189	83 7c 24 50 00	 cmp	 DWORD PTR tv146[rsp], 0
  0018e	74 10		 je	 SHORT $LN6@LoadImageN
  00190	83 7c 24 50 01	 cmp	 DWORD PTR tv146[rsp], 1
  00195	74 17		 je	 SHORT $LN5@LoadImageN
  00197	83 7c 24 50 02	 cmp	 DWORD PTR tv146[rsp], 2
  0019c	74 1e		 je	 SHORT $LN4@LoadImageN
  0019e	eb 2a		 jmp	 SHORT $LN3@LoadImageN
$LN6@LoadImageN:

; 1071 : 					{
; 1072 : 					case 0: filterEntry = HiberDriverEntryFilter0; break;

  001a0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:HiberDriverEntryFilter0
  001a7	48 89 44 24 48	 mov	 QWORD PTR filterEntry$30172[rsp], rax
  001ac	eb 3b		 jmp	 SHORT $LN7@LoadImageN
$LN5@LoadImageN:

; 1073 : 					case 1: filterEntry = HiberDriverEntryFilter1; break;

  001ae	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:HiberDriverEntryFilter1
  001b5	48 89 44 24 48	 mov	 QWORD PTR filterEntry$30172[rsp], rax
  001ba	eb 2d		 jmp	 SHORT $LN7@LoadImageN
$LN4@LoadImageN:

; 1074 : 					case 2: filterEntry = HiberDriverEntryFilter2; break;

  001bc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:HiberDriverEntryFilter2
  001c3	48 89 44 24 48	 mov	 QWORD PTR filterEntry$30172[rsp], rax
  001c8	eb 1f		 jmp	 SHORT $LN7@LoadImageN
$LN3@LoadImageN:

; 1075 : 					default: TC_THROW_FATAL_EXCEPTION;

  001ca	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  001d3	45 33 c9	 xor	 r9d, r9d
  001d6	45 33 c0	 xor	 r8d, r8d
  001d9	ba 33 04 00 00	 mov	 edx, 1075		; 00000433H
  001de	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  001e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN7@LoadImageN:

; 1076 : 					}
; 1077 : 
; 1078 : 					if (moduleItem->ModuleEntryAddress != filterEntry)

  001e9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR moduleItem$[rsp]
  001ee	48 8b 44 24 48	 mov	 rax, QWORD PTR filterEntry$30172[rsp]
  001f3	48 39 41 38	 cmp	 QWORD PTR [rcx+56], rax
  001f7	74 4b		 je	 SHORT $LN2@LoadImageN

; 1079 : 					{
; 1080 : 						// Install filter
; 1081 : 						OriginalHiberDriverEntries[LastHiberFilterNumber] = moduleItem->ModuleEntryAddress;

  001f9	48 63 15 00 00
	00 00		 movsxd	 rdx, DWORD PTR LastHiberFilterNumber
  00200	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:OriginalHiberDriverEntries
  00207	48 8b 44 24 40	 mov	 rax, QWORD PTR moduleItem$[rsp]
  0020c	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00210	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax

; 1082 : 						moduleItem->ModuleEntryAddress = filterEntry;

  00214	48 8b 4c 24 40	 mov	 rcx, QWORD PTR moduleItem$[rsp]
  00219	48 8b 44 24 48	 mov	 rax, QWORD PTR filterEntry$30172[rsp]
  0021e	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 1083 : 
; 1084 : 						if (++LastHiberFilterNumber > TC_MAX_HIBER_FILTER_COUNT - 1)

  00222	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR LastHiberFilterNumber
  00228	83 c0 01	 add	 eax, 1
  0022b	89 05 00 00 00
	00		 mov	 DWORD PTR LastHiberFilterNumber, eax
  00231	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR LastHiberFilterNumber, 2
  00238	7e 0a		 jle	 SHORT $LN1@LoadImageN

; 1085 : 							LastHiberFilterNumber = 0;

  0023a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR LastHiberFilterNumber, 0
$LN1@LoadImageN:
$LN2@LoadImageN:
$LN10@LoadImageN:
$LN11@LoadImageN:

; 1086 : 					}
; 1087 : 				}
; 1088 : 			}
; 1089 : 			break;

  00244	eb 05		 jmp	 SHORT $LN13@LoadImageN
$LN12@LoadImageN:

; 1090 : 		}
; 1091 : 	}

  00246	e9 50 fe ff ff	 jmp	 $LN14@LoadImageN
$LN13@LoadImageN:

; 1092 : 
; 1093 : 	KeLowerIrql (origIrql);

  0024b	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR origIrql$[rsp]
  00250	e8 00 00 00 00	 call	 KeLowerIrql
$LN20@LoadImageN:
$LN21@LoadImageN:

; 1094 : }

  00255	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00259	c3		 ret	 0
LoadImageNotifyRoutine ENDP
_TEXT	ENDS
PUBLIC	StartLegacyHibernationDriverFilter
;	COMDAT pdata
pdata	SEGMENT
$pdata$StartLegacyHibernationDriverFilter DD imagerel $LN14
	DD	imagerel $LN14+436
	DD	imagerel $unwind$StartLegacyHibernationDriverFilter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$StartLegacyHibernationDriverFilter DD 010401H
	DD	0a204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT StartLegacyHibernationDriverFilter
_TEXT	SEGMENT
highestAcceptableWriteBufferAddr$ = 48
status$ = 56
tv71 = 60
tv79 = 64
StartLegacyHibernationDriverFilter PROC			; COMDAT

; 1098 : {

$LN14:
  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1099 : 	PHYSICAL_ADDRESS highestAcceptableWriteBufferAddr;
; 1100 : 	NTSTATUS status;
; 1101 : 
; 1102 : 	ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

  00004	e8 00 00 00 00	 call	 KeGetCurrentIrql
  00009	0f b6 c0	 movzx	 eax, al
  0000c	85 c0		 test	 eax, eax
  0000e	74 27		 je	 SHORT $LN10@StartLegac
  00010	45 33 c9	 xor	 r9d, r9d
  00013	41 b8 4e 04 00
	00		 mov	 r8d, 1102		; 0000044eH
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EF@GDHJGIB@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@KKOENIAD@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5PASSIVE_LE@FNODOBFM@
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  0002d	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
  00035	eb 08		 jmp	 SHORT $LN11@StartLegac
$LN10@StartLegac:
  00037	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv71[rsp], 1
$LN11@StartLegac:

; 1103 : 	ASSERT (!IsOSAtLeast (WIN_VISTA));

  0003f	b9 0b 00 00 00	 mov	 ecx, 11
  00044	e8 00 00 00 00	 call	 IsOSAtLeast
  00049	85 c0		 test	 eax, eax
  0004b	74 27		 je	 SHORT $LN12@StartLegac
  0004d	45 33 c9	 xor	 r9d, r9d
  00050	41 b8 4f 04 00
	00		 mov	 r8d, 1103		; 0000044fH
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EF@GDHJGIB@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@CFHEDMMF@?$CBIsOSAtLeast?5?$CIWIN_VISTA?$CJ?$AA@FNODOBFM@
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  0006a	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
  00072	eb 08		 jmp	 SHORT $LN13@StartLegac
$LN12@StartLegac:
  00074	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv79[rsp], 1
$LN13@StartLegac:

; 1104 : 
; 1105 : 	if (!TCDriverObject->DriverSection || !*(ModuleTableItem **) TCDriverObject->DriverSection)

  0007c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR TCDriverObject
  00083	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00088	74 11		 je	 SHORT $LN6@StartLegac
  0008a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR TCDriverObject
  00091	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00095	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00099	75 05		 jne	 SHORT $LN7@StartLegac
$LN6@StartLegac:

; 1106 : 		goto err;

  0009b	e9 ad 00 00 00	 jmp	 $err$30193
$LN7@StartLegac:

; 1107 : 
; 1108 : 	// All buffers required for hibernation must be allocated here
; 1109 : #ifdef _WIN64
; 1110 : 	highestAcceptableWriteBufferAddr.QuadPart = 0x7FFffffFFFFULL;

  000a0	48 b8 ff ff ff
	ff ff 07 00 00	 mov	 rax, 8796093022207	; 000007ffffffffffH
  000aa	48 89 44 24 30	 mov	 QWORD PTR highestAcceptableWriteBufferAddr$[rsp], rax

; 1111 : #else
; 1112 : 	highestAcceptableWriteBufferAddr.QuadPart = 0xffffFFFFULL;
; 1113 : #endif
; 1114 : 
; 1115 : 	HibernationWriteBuffer = MmAllocateContiguousMemory (TC_HIBERNATION_WRITE_BUFFER_SIZE, highestAcceptableWriteBufferAddr);

  000af	48 8b 54 24 30	 mov	 rdx, QWORD PTR highestAcceptableWriteBufferAddr$[rsp]
  000b4	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmAllocateContiguousMemory
  000bf	48 89 05 00 00
	00 00		 mov	 QWORD PTR HibernationWriteBuffer, rax

; 1116 : 	if (!HibernationWriteBuffer)

  000c6	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR HibernationWriteBuffer, 0
  000ce	75 02		 jne	 SHORT $LN5@StartLegac

; 1117 : 		goto err;

  000d0	eb 7b		 jmp	 SHORT $err$30193
$LN5@StartLegac:

; 1118 : 
; 1119 : 	HibernationWriteBufferMdl = IoAllocateMdl (HibernationWriteBuffer, TC_HIBERNATION_WRITE_BUFFER_SIZE, FALSE, FALSE, NULL);

  000d2	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000db	45 33 c9	 xor	 r9d, r9d
  000de	45 33 c0	 xor	 r8d, r8d
  000e1	ba 00 00 02 00	 mov	 edx, 131072		; 00020000H
  000e6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR HibernationWriteBuffer
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAllocateMdl
  000f3	48 89 05 00 00
	00 00		 mov	 QWORD PTR HibernationWriteBufferMdl, rax

; 1120 : 	if (!HibernationWriteBufferMdl)

  000fa	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR HibernationWriteBufferMdl, 0
  00102	75 02		 jne	 SHORT $LN4@StartLegac

; 1121 : 		goto err;

  00104	eb 47		 jmp	 SHORT $err$30193
$LN4@StartLegac:

; 1122 : 
; 1123 : 	MmBuildMdlForNonPagedPool (HibernationWriteBufferMdl);

  00106	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR HibernationWriteBufferMdl
  0010d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmBuildMdlForNonPagedPool

; 1124 : 
; 1125 : 	status = PsSetLoadImageNotifyRoutine (LoadImageNotifyRoutine);

  00113	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:LoadImageNotifyRoutine
  0011a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsSetLoadImageNotifyRoutine
  00120	89 44 24 38	 mov	 DWORD PTR status$[rsp], eax

; 1126 : 	if (!NT_SUCCESS (status))

  00124	83 7c 24 38 00	 cmp	 DWORD PTR status$[rsp], 0
  00129	7d 02		 jge	 SHORT $LN3@StartLegac

; 1127 : 		goto err;

  0012b	eb 20		 jmp	 SHORT $err$30193
$LN3@StartLegac:

; 1128 : 
; 1129 : 	LegacyHibernationDriverFilterActive = TRUE;

  0012d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR LegacyHibernationDriverFilterActive, 1

; 1130 : 	CrashDumpEnabled = FALSE;

  00137	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR CrashDumpEnabled, 0

; 1131 : 	HibernationEnabled = TRUE;

  00141	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR HibernationEnabled, 1

; 1132 : 	return;

  0014b	eb 62		 jmp	 SHORT $LN8@StartLegac
$err$30193:

; 1133 : 
; 1134 : err:
; 1135 : 	LegacyHibernationDriverFilterActive = FALSE;

  0014d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR LegacyHibernationDriverFilterActive, 0

; 1136 : 	CrashDumpEnabled = FALSE;

  00157	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR CrashDumpEnabled, 0

; 1137 : 	HibernationEnabled = FALSE;

  00161	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR HibernationEnabled, 0

; 1138 : 
; 1139 : 	if (HibernationWriteBufferMdl)

  0016b	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR HibernationWriteBufferMdl, 0
  00173	74 18		 je	 SHORT $LN2@StartLegac

; 1140 : 	{
; 1141 : 		IoFreeMdl (HibernationWriteBufferMdl);

  00175	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR HibernationWriteBufferMdl
  0017c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoFreeMdl

; 1142 : 		HibernationWriteBufferMdl = NULL;

  00182	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR HibernationWriteBufferMdl, 0
$LN2@StartLegac:

; 1143 : 	}
; 1144 : 
; 1145 : 	if (HibernationWriteBuffer)

  0018d	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR HibernationWriteBuffer, 0
  00195	74 18		 je	 SHORT $LN1@StartLegac

; 1146 : 	{
; 1147 : 		MmFreeContiguousMemory (HibernationWriteBuffer);

  00197	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR HibernationWriteBuffer
  0019e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmFreeContiguousMemory

; 1148 : 		HibernationWriteBuffer = NULL;

  001a4	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR HibernationWriteBuffer, 0
$LN1@StartLegac:
$LN8@StartLegac:

; 1149 : 	}
; 1150 : }

  001af	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001b3	c3		 ret	 0
StartLegacyHibernationDriverFilter ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT pdata
pdata	SEGMENT
$pdata$MountDrive DD imagerel MountDrive
	DD	imagerel MountDrive+2572
	DD	imagerel $unwind$MountDrive
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MountDrive DD 032919H
	DD	0580117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	02b8H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT MountDrive
_TEXT	SEGMENT
hiddenHeaderOffset$ = 48
hiddenVolume$ = 56
offset$ = 64
status$ = 72
header$ = 80
mbr$29591 = 96
saltCrc$29605 = 608
hiddenPartitionOffset$29614 = 616
mappedCryptoInfo$29626 = 624
cryptoInfoAddress$29625 = 632
burnc$29634 = 640
burnm$29632 = 648
storageDeviceNumber$29638 = 656
tv65 = 672
tv77 = 676
tv94 = 680
tv156 = 688
__$ArrayPad$ = 696
Extension$ = 720
password$ = 728
headerSaltCrc32$ = 736
MountDrive PROC						; COMDAT

; 223  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec c0 02
	00 00		 sub	 rsp, 704		; 000002c0H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 b8
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 224  : 	BOOL hiddenVolume = (BootArgs.HiddenSystemPartitionStart != 0);

  00029	48 83 3d 5a 00
	00 00 00	 cmp	 QWORD PTR BootArgs+90, 0
  00031	74 0d		 je	 SHORT $LN32@MountDrive
  00033	c7 84 24 a0 02
	00 00 01 00 00
	00		 mov	 DWORD PTR tv65[rsp], 1
  0003e	eb 0b		 jmp	 SHORT $LN33@MountDrive
$LN32@MountDrive:
  00040	c7 84 24 a0 02
	00 00 00 00 00
	00		 mov	 DWORD PTR tv65[rsp], 0
$LN33@MountDrive:
  0004b	8b 84 24 a0 02
	00 00		 mov	 eax, DWORD PTR tv65[rsp]
  00052	89 44 24 38	 mov	 DWORD PTR hiddenVolume$[rsp], eax

; 225  : 	int64 hiddenHeaderOffset = BootArgs.HiddenSystemPartitionStart + TC_HIDDEN_VOLUME_HEADER_OFFSET;

  00056	48 8b 05 5a 00
	00 00		 mov	 rax, QWORD PTR BootArgs+90
  0005d	48 05 00 00 01
	00		 add	 rax, 65536		; 00010000H
  00063	48 89 44 24 30	 mov	 QWORD PTR hiddenHeaderOffset$[rsp], rax

; 226  : 	NTSTATUS status;
; 227  : 	LARGE_INTEGER offset;
; 228  : 	char *header;
; 229  : 
; 230  : 	Dump ("MountDrive pdo=%p\n", Extension->Pdo);

  00068	48 8b 94 24 d0
	02 00 00	 mov	 rdx, QWORD PTR Extension$[rsp]
  00070	48 8b 52 28	 mov	 rdx, QWORD PTR [rdx+40]
  00074	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@JFDPBFDA@MountDrive?5pdo?$DN?$CFp?6?$AA@FNODOBFM@
  0007b	e8 00 00 00 00	 call	 DbgPrint

; 231  : 	ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

  00080	e8 00 00 00 00	 call	 KeGetCurrentIrql
  00085	0f b6 c0	 movzx	 eax, al
  00088	85 c0		 test	 eax, eax
  0008a	74 2a		 je	 SHORT $LN34@MountDrive
  0008c	45 33 c9	 xor	 r9d, r9d
  0008f	41 b8 e7 00 00
	00		 mov	 r8d, 231		; 000000e7H
  00095	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EF@GDHJGIB@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@KKOENIAD@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5PASSIVE_LE@FNODOBFM@
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  000a9	c7 84 24 a4 02
	00 00 00 00 00
	00		 mov	 DWORD PTR tv77[rsp], 0
  000b4	eb 0b		 jmp	 SHORT $LN35@MountDrive
$LN34@MountDrive:
  000b6	c7 84 24 a4 02
	00 00 01 00 00
	00		 mov	 DWORD PTR tv77[rsp], 1
$LN35@MountDrive:

; 232  : 
; 233  : 	// Check boot drive signature first (header CRC search could fail if a user restored the header to a non-boot drive)
; 234  : 	if (BootDriveSignatureValid)

  000c1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR BootDriveSignatureValid, 0
  000c8	74 4e		 je	 SHORT $LN29@MountDrive

; 235  : 	{
; 236  : 		byte mbr[TC_SECTOR_SIZE_BIOS];
; 237  : 
; 238  : 		offset.QuadPart = 0;

  000ca	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR offset$[rsp], 0

; 239  : 		status = TCReadDevice (Extension->LowerDeviceObject, mbr, offset, TC_SECTOR_SIZE_BIOS);

  000d3	41 b9 00 02 00
	00		 mov	 r9d, 512		; 00000200H
  000d9	4c 8b 44 24 40	 mov	 r8, QWORD PTR offset$[rsp]
  000de	48 8d 54 24 60	 lea	 rdx, QWORD PTR mbr$29591[rsp]
  000e3	48 8b 8c 24 d0
	02 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  000eb	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  000ef	e8 00 00 00 00	 call	 TCReadDevice
  000f4	89 44 24 48	 mov	 DWORD PTR status$[rsp], eax

; 240  : 
; 241  : 		if (NT_SUCCESS (status) && BootArgs.BootDriveSignature != *(uint32 *) (mbr + 0x1b8))

  000f8	83 7c 24 48 00	 cmp	 DWORD PTR status$[rsp], 0
  000fd	7c 19		 jl	 SHORT $LN28@MountDrive
  000ff	8b 84 24 18 02
	00 00		 mov	 eax, DWORD PTR mbr$29591[rsp+440]
  00106	39 05 6e 00 00
	00		 cmp	 DWORD PTR BootArgs+110, eax
  0010c	74 0a		 je	 SHORT $LN28@MountDrive

; 242  : 			return STATUS_UNSUCCESSFUL;

  0010e	b8 01 00 00 c0	 mov	 eax, -1073741823	; ffffffffc0000001H
  00113	e9 db 08 00 00	 jmp	 $LN30@MountDrive
$LN28@MountDrive:
$LN29@MountDrive:

; 243  : 	}
; 244  : 
; 245  : 	header = TCalloc (TC_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE);

  00118	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  0011e	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  00123	33 c9		 xor	 ecx, ecx
  00125	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  0012b	48 89 44 24 50	 mov	 QWORD PTR header$[rsp], rax

; 246  : 	if (!header)

  00130	48 83 7c 24 50
	00		 cmp	 QWORD PTR header$[rsp], 0
  00136	75 0a		 jne	 SHORT $LN27@MountDrive

; 247  : 		return STATUS_INSUFFICIENT_RESOURCES;

  00138	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  0013d	e9 b1 08 00 00	 jmp	 $LN30@MountDrive
$LN27@MountDrive:

; 248  : 
; 249  : 	offset.QuadPart = hiddenVolume ? hiddenHeaderOffset : TC_BOOT_VOLUME_HEADER_SECTOR_OFFSET;

  00142	83 7c 24 38 00	 cmp	 DWORD PTR hiddenVolume$[rsp], 0
  00147	74 0f		 je	 SHORT $LN36@MountDrive
  00149	48 8b 44 24 30	 mov	 rax, QWORD PTR hiddenHeaderOffset$[rsp]
  0014e	48 89 84 24 a8
	02 00 00	 mov	 QWORD PTR tv94[rsp], rax
  00156	eb 0c		 jmp	 SHORT $LN37@MountDrive
$LN36@MountDrive:
  00158	48 c7 84 24 a8
	02 00 00 00 7c
	00 00		 mov	 QWORD PTR tv94[rsp], 31744 ; 00007c00H
$LN37@MountDrive:
  00164	48 8b 84 24 a8
	02 00 00	 mov	 rax, QWORD PTR tv94[rsp]
  0016c	48 89 44 24 40	 mov	 QWORD PTR offset$[rsp], rax

; 250  : 	Dump ("Reading volume header at %I64u\n", offset.QuadPart);

  00171	48 8b 54 24 40	 mov	 rdx, QWORD PTR offset$[rsp]
  00176	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@JLOPIPKN@Reading?5volume?5header?5at?5?$CFI64u?6?$AA@FNODOBFM@
  0017d	e8 00 00 00 00	 call	 DbgPrint

; 251  : 
; 252  : 	status = TCReadDevice (Extension->LowerDeviceObject, header, offset, TC_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE);

  00182	41 b9 00 02 00
	00		 mov	 r9d, 512		; 00000200H
  00188	4c 8b 44 24 40	 mov	 r8, QWORD PTR offset$[rsp]
  0018d	48 8b 54 24 50	 mov	 rdx, QWORD PTR header$[rsp]
  00192	48 8b 8c 24 d0
	02 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  0019a	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0019e	e8 00 00 00 00	 call	 TCReadDevice
  001a3	89 44 24 48	 mov	 DWORD PTR status$[rsp], eax

; 253  : 	if (!NT_SUCCESS (status))

  001a7	83 7c 24 48 00	 cmp	 DWORD PTR status$[rsp], 0
  001ac	7d 15		 jge	 SHORT $LN26@MountDrive

; 254  : 	{
; 255  : 		Dump ("TCReadDevice error %x\n", status);

  001ae	8b 54 24 48	 mov	 edx, DWORD PTR status$[rsp]
  001b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@FBDKNNGH@TCReadDevice?5error?5?$CFx?6?$AA@FNODOBFM@
  001b9	e8 00 00 00 00	 call	 DbgPrint

; 256  : 		goto ret;

  001be	e9 1c 08 00 00	 jmp	 $ret$29603
$LN26@MountDrive:

; 257  : 	}
; 258  : 
; 259  : 	if (headerSaltCrc32)

  001c3	48 83 bc 24 e0
	02 00 00 00	 cmp	 QWORD PTR headerSaltCrc32$[rsp], 0
  001cc	74 48		 je	 SHORT $LN25@MountDrive

; 260  : 	{
; 261  : 		uint32 saltCrc = GetCrc32 (header, PKCS5_SALT_SIZE);

  001ce	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001d3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR header$[rsp]
  001d8	e8 00 00 00 00	 call	 GetCrc32
  001dd	89 84 24 60 02
	00 00		 mov	 DWORD PTR saltCrc$29605[rsp], eax

; 262  : 
; 263  : 		if (saltCrc != *headerSaltCrc32)

  001e4	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR headerSaltCrc32$[rsp]
  001ec	8b 00		 mov	 eax, DWORD PTR [rax]
  001ee	39 84 24 60 02
	00 00		 cmp	 DWORD PTR saltCrc$29605[rsp], eax
  001f5	74 0d		 je	 SHORT $LN24@MountDrive

; 264  : 		{
; 265  : 			status = STATUS_UNSUCCESSFUL;

  001f7	c7 44 24 48 01
	00 00 c0	 mov	 DWORD PTR status$[rsp], -1073741823 ; ffffffffc0000001H

; 266  : 			goto ret;

  001ff	e9 db 07 00 00	 jmp	 $ret$29603
$LN24@MountDrive:

; 267  : 		}
; 268  : 
; 269  : 		Extension->VolumeHeaderSaltCrc32 = saltCrc;

  00204	48 8b 8c 24 d0
	02 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  0020c	8b 84 24 60 02
	00 00		 mov	 eax, DWORD PTR saltCrc$29605[rsp]
  00213	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN25@MountDrive:

; 270  : 	}
; 271  : 
; 272  : 	Extension->HeaderCryptoInfo = crypto_open();

  00216	e8 00 00 00 00	 call	 crypto_open
  0021b	48 8b d0	 mov	 rdx, rax
  0021e	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00226	48 89 90 30 03
	00 00		 mov	 QWORD PTR [rax+816], rdx

; 273  : 	if (!Extension->HeaderCryptoInfo)

  0022d	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00235	48 83 b8 30 03
	00 00 00	 cmp	 QWORD PTR [rax+816], 0
  0023d	75 0d		 jne	 SHORT $LN23@MountDrive

; 274  : 	{
; 275  : 		status = STATUS_INSUFFICIENT_RESOURCES;

  0023f	c7 44 24 48 9a
	00 00 c0	 mov	 DWORD PTR status$[rsp], -1073741670 ; ffffffffc000009aH

; 276  : 		goto ret;

  00247	e9 93 07 00 00	 jmp	 $ret$29603
$LN23@MountDrive:

; 277  : 	}
; 278  : 
; 279  : 	if (ReadVolumeHeader (!hiddenVolume, header, password, &Extension->Queue.CryptoInfo, Extension->HeaderCryptoInfo) == 0)

  0024c	83 7c 24 38 00	 cmp	 DWORD PTR hiddenVolume$[rsp], 0
  00251	75 0d		 jne	 SHORT $LN38@MountDrive
  00253	c7 84 24 b0 02
	00 00 01 00 00
	00		 mov	 DWORD PTR tv156[rsp], 1
  0025e	eb 0b		 jmp	 SHORT $LN39@MountDrive
$LN38@MountDrive:
  00260	c7 84 24 b0 02
	00 00 00 00 00
	00		 mov	 DWORD PTR tv156[rsp], 0
$LN39@MountDrive:
  0026b	4c 8b 8c 24 d0
	02 00 00	 mov	 r9, QWORD PTR Extension$[rsp]
  00273	49 81 c1 98 00
	00 00		 add	 r9, 152			; 00000098H
  0027a	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00282	48 8b 80 30 03
	00 00		 mov	 rax, QWORD PTR [rax+816]
  00289	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0028e	4c 8b 84 24 d8
	02 00 00	 mov	 r8, QWORD PTR password$[rsp]
  00296	48 8b 54 24 50	 mov	 rdx, QWORD PTR header$[rsp]
  0029b	8b 8c 24 b0 02
	00 00		 mov	 ecx, DWORD PTR tv156[rsp]
  002a2	e8 00 00 00 00	 call	 ReadVolumeHeader
  002a7	85 c0		 test	 eax, eax
  002a9	0f 85 f5 06 00
	00		 jne	 $LN22@MountDrive

; 280  : 	{
; 281  : 		// Header decrypted
; 282  : 		status = STATUS_SUCCESS;

  002af	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR status$[rsp], 0

; 283  : 		Dump ("Header decrypted\n");

  002b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@LMOOMJMK@Header?5decrypted?6?$AA@FNODOBFM@
  002be	e8 00 00 00 00	 call	 DbgPrint

; 284  : 			
; 285  : 		if (Extension->Queue.CryptoInfo->hiddenVolume)

  002c3	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  002cb	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  002d2	83 b8 a0 29 00
	00 00		 cmp	 DWORD PTR [rax+10656], 0
  002d9	0f 84 7b 01 00
	00		 je	 $LN21@MountDrive

; 286  : 		{
; 287  : 			int64 hiddenPartitionOffset = BootArgs.HiddenSystemPartitionStart;

  002df	48 8b 05 5a 00
	00 00		 mov	 rax, QWORD PTR BootArgs+90
  002e6	48 89 84 24 68
	02 00 00	 mov	 QWORD PTR hiddenPartitionOffset$29614[rsp], rax

; 288  : 			Dump ("Hidden volume start offset = %I64d\n", Extension->Queue.CryptoInfo->EncryptedAreaStart.Value + hiddenPartitionOffset);

  002ee	48 8b 94 24 d0
	02 00 00	 mov	 rdx, QWORD PTR Extension$[rsp]
  002f6	48 8b 92 98 00
	00 00		 mov	 rdx, QWORD PTR [rdx+152]
  002fd	48 8b 92 50 44
	00 00		 mov	 rdx, QWORD PTR [rdx+17488]
  00304	48 03 94 24 68
	02 00 00	 add	 rdx, QWORD PTR hiddenPartitionOffset$29614[rsp]
  0030c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@ONLIABPH@Hidden?5volume?5start?5offset?5?$DN?5?$CFI6@FNODOBFM@
  00313	e8 00 00 00 00	 call	 DbgPrint

; 289  : 			
; 290  : 			Extension->HiddenSystem = TRUE;

  00318	48 8b 94 24 d0
	02 00 00	 mov	 rdx, QWORD PTR Extension$[rsp]
  00320	c7 82 38 03 00
	00 01 00 00 00	 mov	 DWORD PTR [rdx+824], 1

; 291  : 
; 292  : 			Extension->Queue.RemapEncryptedArea = TRUE;

  0032a	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00332	c7 80 dc 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+220], 1

; 293  : 			Extension->Queue.RemappedAreaOffset = hiddenPartitionOffset + Extension->Queue.CryptoInfo->EncryptedAreaStart.Value - BootArgs.DecoySystemPartitionStart;

  0033c	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00344	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  0034b	48 8b 80 50 44
	00 00		 mov	 rax, QWORD PTR [rax+17488]
  00352	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR hiddenPartitionOffset$29614[rsp]
  0035a	48 03 c8	 add	 rcx, rax
  0035d	48 2b 0d 62 00
	00 00		 sub	 rcx, QWORD PTR BootArgs+98
  00364	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  0036c	48 89 88 e0 00
	00 00		 mov	 QWORD PTR [rax+224], rcx

; 294  : 			Extension->Queue.RemappedAreaDataUnitOffset = Extension->Queue.CryptoInfo->EncryptedAreaStart.Value / ENCRYPTION_DATA_UNIT_SIZE - BootArgs.DecoySystemPartitionStart / ENCRYPTION_DATA_UNIT_SIZE;

  00373	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  0037b	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  00382	33 d2		 xor	 edx, edx
  00384	48 8b 80 50 44
	00 00		 mov	 rax, QWORD PTR [rax+17488]
  0038b	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00390	48 f7 f1	 div	 rcx
  00393	48 8b f8	 mov	 rdi, rax
  00396	33 d2		 xor	 edx, edx
  00398	48 8b 05 62 00
	00 00		 mov	 rax, QWORD PTR BootArgs+98
  0039f	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  003a4	48 f7 f1	 div	 rcx
  003a7	48 8b cf	 mov	 rcx, rdi
  003aa	48 2b c8	 sub	 rcx, rax
  003ad	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  003b5	48 89 88 e8 00
	00 00		 mov	 QWORD PTR [rax+232], rcx

; 295  : 			
; 296  : 			Extension->Queue.CryptoInfo->EncryptedAreaStart.Value = BootArgs.DecoySystemPartitionStart;

  003bc	48 8b 8c 24 d0
	02 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  003c4	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  003cb	48 8b 05 62 00
	00 00		 mov	 rax, QWORD PTR BootArgs+98
  003d2	48 89 81 50 44
	00 00		 mov	 QWORD PTR [rcx+17488], rax

; 297  : 			
; 298  : 			if (Extension->Queue.CryptoInfo->VolumeSize.Value > hiddenPartitionOffset - BootArgs.DecoySystemPartitionStart)

  003d9	48 8b 94 24 d0
	02 00 00	 mov	 rdx, QWORD PTR Extension$[rsp]
  003e1	48 8b 92 98 00
	00 00		 mov	 rdx, QWORD PTR [rdx+152]
  003e8	48 8b 0d 62 00
	00 00		 mov	 rcx, QWORD PTR BootArgs+98
  003ef	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR hiddenPartitionOffset$29614[rsp]
  003f7	48 2b c1	 sub	 rax, rcx
  003fa	48 39 82 48 44
	00 00		 cmp	 QWORD PTR [rdx+17480], rax
  00401	76 1f		 jbe	 SHORT $LN20@MountDrive

; 299  : 				TC_THROW_FATAL_EXCEPTION;

  00403	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  0040c	45 33 c9	 xor	 r9d, r9d
  0040f	45 33 c0	 xor	 r8d, r8d
  00412	ba 2b 01 00 00	 mov	 edx, 299		; 0000012bH
  00417	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  0041c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN20@MountDrive:

; 300  : 
; 301  : 			Dump ("RemappedAreaOffset = %I64d\n", Extension->Queue.RemappedAreaOffset);

  00422	48 8b 94 24 d0
	02 00 00	 mov	 rdx, QWORD PTR Extension$[rsp]
  0042a	48 8b 92 e0 00
	00 00		 mov	 rdx, QWORD PTR [rdx+224]
  00431	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@GBKCGBDB@RemappedAreaOffset?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@
  00438	e8 00 00 00 00	 call	 DbgPrint

; 302  : 			Dump ("RemappedAreaDataUnitOffset = %I64d\n", Extension->Queue.RemappedAreaDataUnitOffset);

  0043d	48 8b 94 24 d0
	02 00 00	 mov	 rdx, QWORD PTR Extension$[rsp]
  00445	48 8b 92 e8 00
	00 00		 mov	 rdx, QWORD PTR [rdx+232]
  0044c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@NLPFMAEC@RemappedAreaDataUnitOffset?5?$DN?5?$CFI6@FNODOBFM@
  00453	e8 00 00 00 00	 call	 DbgPrint

; 303  : 		}
; 304  : 		else

  00458	eb 24		 jmp	 SHORT $LN19@MountDrive
$LN21@MountDrive:

; 305  : 		{
; 306  : 			Extension->HiddenSystem = FALSE;

  0045a	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00462	c7 80 38 03 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+824], 0

; 307  : 			Extension->Queue.RemapEncryptedArea = FALSE;

  0046c	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00474	c7 80 dc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+220], 0
$LN19@MountDrive:

; 308  : 		}
; 309  : 
; 310  : 		Extension->ConfiguredEncryptedAreaStart = Extension->Queue.CryptoInfo->EncryptedAreaStart.Value;

  0047e	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00486	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  0048d	48 8b 8c 24 d0
	02 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00495	48 8b 80 50 44
	00 00		 mov	 rax, QWORD PTR [rax+17488]
  0049c	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 311  : 		Extension->ConfiguredEncryptedAreaEnd = Extension->Queue.CryptoInfo->EncryptedAreaStart.Value + Extension->Queue.CryptoInfo->VolumeSize.Value - 1;

  004a0	48 8b 8c 24 d0
	02 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  004a8	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  004af	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  004b7	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  004be	48 8b 89 50 44
	00 00		 mov	 rcx, QWORD PTR [rcx+17488]
  004c5	48 8b 80 48 44
	00 00		 mov	 rax, QWORD PTR [rax+17480]
  004cc	48 8d 4c 01 ff	 lea	 rcx, QWORD PTR [rcx+rax-1]
  004d1	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  004d9	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 312  : 
; 313  : 		Extension->Queue.EncryptedAreaStart = Extension->Queue.CryptoInfo->EncryptedAreaStart.Value;

  004dd	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  004e5	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  004ec	48 8b 8c 24 d0
	02 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  004f4	48 8b 80 50 44
	00 00		 mov	 rax, QWORD PTR [rax+17488]
  004fb	48 89 81 c8 00
	00 00		 mov	 QWORD PTR [rcx+200], rax

; 314  : 		Extension->Queue.EncryptedAreaEnd = Extension->Queue.CryptoInfo->EncryptedAreaStart.Value + Extension->Queue.CryptoInfo->EncryptedAreaLength.Value - 1;

  00502	48 8b 8c 24 d0
	02 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  0050a	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  00511	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00519	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  00520	48 8b 89 50 44
	00 00		 mov	 rcx, QWORD PTR [rcx+17488]
  00527	48 8b 80 58 44
	00 00		 mov	 rax, QWORD PTR [rax+17496]
  0052e	48 8d 4c 01 ff	 lea	 rcx, QWORD PTR [rcx+rax-1]
  00533	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  0053b	48 89 88 d0 00
	00 00		 mov	 QWORD PTR [rax+208], rcx

; 315  : 
; 316  : 		if (Extension->Queue.CryptoInfo->EncryptedAreaLength.Value == 0)

  00542	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  0054a	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  00551	48 83 b8 58 44
	00 00 00	 cmp	 QWORD PTR [rax+17496], 0
  00559	75 26		 jne	 SHORT $LN18@MountDrive

; 317  : 		{
; 318  : 			Extension->Queue.EncryptedAreaStart = -1;

  0055b	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00563	48 c7 80 c8 00
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rax+200], -1

; 319  : 			Extension->Queue.EncryptedAreaEnd = -1;

  0056e	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00576	48 c7 80 d0 00
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rax+208], -1
$LN18@MountDrive:

; 320  : 		}
; 321  : 
; 322  : 		Dump ("Loaded: ConfiguredEncryptedAreaStart=%I64d (%I64d)  ConfiguredEncryptedAreaEnd=%I64d (%I64d)\n", Extension->ConfiguredEncryptedAreaStart / 1024 / 1024, Extension->ConfiguredEncryptedAreaStart, Extension->ConfiguredEncryptedAreaEnd / 1024 / 1024, Extension->ConfiguredEncryptedAreaEnd);

  00581	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00589	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0058d	48 99		 cdq
  0058f	48 81 e2 ff 03
	00 00		 and	 rdx, 1023		; 000003ffH
  00596	48 03 c2	 add	 rax, rdx
  00599	48 c1 f8 0a	 sar	 rax, 10
  0059d	48 99		 cdq
  0059f	48 81 e2 ff 03
	00 00		 and	 rdx, 1023		; 000003ffH
  005a6	48 03 c2	 add	 rax, rdx
  005a9	48 c1 f8 0a	 sar	 rax, 10
  005ad	4c 8b c8	 mov	 r9, rax
  005b0	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  005b8	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  005bc	48 99		 cdq
  005be	48 81 e2 ff 03
	00 00		 and	 rdx, 1023		; 000003ffH
  005c5	48 03 c2	 add	 rax, rdx
  005c8	48 c1 f8 0a	 sar	 rax, 10
  005cc	48 99		 cdq
  005ce	48 81 e2 ff 03
	00 00		 and	 rdx, 1023		; 000003ffH
  005d5	48 03 c2	 add	 rax, rdx
  005d8	48 c1 f8 0a	 sar	 rax, 10
  005dc	48 8b d0	 mov	 rdx, rax
  005df	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  005e7	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  005eb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005f0	4c 8b 84 24 d0
	02 00 00	 mov	 r8, QWORD PTR Extension$[rsp]
  005f8	4d 8b 40 38	 mov	 r8, QWORD PTR [r8+56]
  005fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0FO@PAPPJPK@Loaded?3?5ConfiguredEncryptedAreaS@FNODOBFM@
  00603	e8 00 00 00 00	 call	 DbgPrint

; 323  : 		Dump ("Loaded: EncryptedAreaStart=%I64d (%I64d)  EncryptedAreaEnd=%I64d (%I64d)\n", Extension->Queue.EncryptedAreaStart / 1024 / 1024, Extension->Queue.EncryptedAreaStart, Extension->Queue.EncryptedAreaEnd / 1024 / 1024, Extension->Queue.EncryptedAreaEnd);

  00608	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00610	48 8b 80 d0 00
	00 00		 mov	 rax, QWORD PTR [rax+208]
  00617	48 99		 cdq
  00619	48 81 e2 ff 03
	00 00		 and	 rdx, 1023		; 000003ffH
  00620	48 03 c2	 add	 rax, rdx
  00623	48 c1 f8 0a	 sar	 rax, 10
  00627	48 99		 cdq
  00629	48 81 e2 ff 03
	00 00		 and	 rdx, 1023		; 000003ffH
  00630	48 03 c2	 add	 rax, rdx
  00633	48 c1 f8 0a	 sar	 rax, 10
  00637	4c 8b c8	 mov	 r9, rax
  0063a	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00642	48 8b 80 c8 00
	00 00		 mov	 rax, QWORD PTR [rax+200]
  00649	48 99		 cdq
  0064b	48 81 e2 ff 03
	00 00		 and	 rdx, 1023		; 000003ffH
  00652	48 03 c2	 add	 rax, rdx
  00655	48 c1 f8 0a	 sar	 rax, 10
  00659	48 99		 cdq
  0065b	48 81 e2 ff 03
	00 00		 and	 rdx, 1023		; 000003ffH
  00662	48 03 c2	 add	 rax, rdx
  00665	48 c1 f8 0a	 sar	 rax, 10
  00669	48 8b d0	 mov	 rdx, rax
  0066c	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00674	48 8b 80 d0 00
	00 00		 mov	 rax, QWORD PTR [rax+208]
  0067b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00680	4c 8b 84 24 d0
	02 00 00	 mov	 r8, QWORD PTR Extension$[rsp]
  00688	4d 8b 80 c8 00
	00 00		 mov	 r8, QWORD PTR [r8+200]
  0068f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EK@PHFABMCK@Loaded?3?5EncryptedAreaStart?$DN?$CFI64d@FNODOBFM@
  00696	e8 00 00 00 00	 call	 DbgPrint

; 324  : 
; 325  : 		// Erase boot loader scheduled keys
; 326  : 		if (BootArgs.CryptoInfoLength > 0)

  0069b	0f b7 15 0c 00
	00 00		 movzx	 edx, WORD PTR BootArgs+12
  006a2	85 d2		 test	 edx, edx
  006a4	0f 8e 8e 00 00
	00		 jle	 $LN17@MountDrive

; 327  : 		{
; 328  : 			PHYSICAL_ADDRESS cryptoInfoAddress;
; 329  : 			byte *mappedCryptoInfo;
; 330  : 			
; 331  : 			cryptoInfoAddress.QuadPart = (BootLoaderSegment << 4) + BootArgs.CryptoInfoOffset;

  006aa	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR BootLoaderSegment
  006b1	c1 e0 04	 shl	 eax, 4
  006b4	0f b7 0d 0a 00
	00 00		 movzx	 ecx, WORD PTR BootArgs+10
  006bb	03 c1		 add	 eax, ecx
  006bd	48 98		 cdqe
  006bf	48 89 84 24 78
	02 00 00	 mov	 QWORD PTR cryptoInfoAddress$29625[rsp], rax

; 332  : 			mappedCryptoInfo = MmMapIoSpace (cryptoInfoAddress, BootArgs.CryptoInfoLength, MmCached);

  006c7	0f b7 15 0c 00
	00 00		 movzx	 edx, WORD PTR BootArgs+12
  006ce	41 b8 01 00 00
	00		 mov	 r8d, 1
  006d4	48 8b 8c 24 78
	02 00 00	 mov	 rcx, QWORD PTR cryptoInfoAddress$29625[rsp]
  006dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmMapIoSpace
  006e2	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR mappedCryptoInfo$29626[rsp], rax

; 333  : 			
; 334  : 			if (mappedCryptoInfo)

  006ea	48 83 bc 24 70
	02 00 00 00	 cmp	 QWORD PTR mappedCryptoInfo$29626[rsp], 0
  006f3	74 43		 je	 SHORT $LN16@MountDrive

; 335  : 			{
; 336  : 				Dump ("Wiping memory %x %d\n", cryptoInfoAddress.LowPart, BootArgs.CryptoInfoLength);

  006f5	44 0f b7 05 0c
	00 00 00	 movzx	 r8d, WORD PTR BootArgs+12
  006fd	8b 94 24 78 02
	00 00		 mov	 edx, DWORD PTR cryptoInfoAddress$29625[rsp]
  00704	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@DFBDNCBE@Wiping?5memory?5?$CFx?5?$CFd?6?$AA@FNODOBFM@
  0070b	e8 00 00 00 00	 call	 DbgPrint

; 337  : 				memset (mappedCryptoInfo, 0, BootArgs.CryptoInfoLength);

  00710	0f b7 0d 0c 00
	00 00		 movzx	 ecx, WORD PTR BootArgs+12
  00717	48 8b bc 24 70
	02 00 00	 mov	 rdi, QWORD PTR mappedCryptoInfo$29626[rsp]
  0071f	33 c0		 xor	 eax, eax
  00721	f3 aa		 rep stosb

; 338  : 				MmUnmapIoSpace (mappedCryptoInfo, BootArgs.CryptoInfoLength);

  00723	0f b7 15 0c 00
	00 00		 movzx	 edx, WORD PTR BootArgs+12
  0072a	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR mappedCryptoInfo$29626[rsp]
  00732	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmUnmapIoSpace
$LN16@MountDrive:
$LN17@MountDrive:

; 339  : 			}
; 340  : 		}
; 341  : 
; 342  : 		BootDriveFilterExtension = Extension;

  00738	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00740	48 89 05 00 00
	00 00		 mov	 QWORD PTR BootDriveFilterExtension, rax

; 343  : 		BootDriveFound = Extension->BootDrive = Extension->DriveMounted = Extension->VolumeHeaderPresent = TRUE;

  00747	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  0074f	c7 80 0c 03 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+780], 1
  00759	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00761	c7 80 10 03 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+784], 1
  0076b	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00773	c7 80 08 03 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+776], 1
  0077d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR BootDriveFound, 1

; 344  : 		BootDriveFilterExtension->MagicNumber = TC_BOOT_DRIVE_FILTER_EXTENSION_MAGIC_NUMBER;

  00787	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR BootDriveFilterExtension
  0078e	48 b8 54 58 45
	42 45 55 52 54	 mov	 rax, 6076012603229165652 ; 5452554542455854H
  00798	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
$LN15@MountDrive:

; 345  : 
; 346  : 		burn (&BootArgs.BootPassword, sizeof (BootArgs.BootPassword));

  0079c	48 8d 05 12 00
	00 00		 lea	 rax, OFFSET FLAT:BootArgs+18
  007a3	48 89 84 24 88
	02 00 00	 mov	 QWORD PTR burnm$29632[rsp], rax
  007ab	c7 84 24 80 02
	00 00 48 00 00
	00		 mov	 DWORD PTR burnc$29634[rsp], 72 ; 00000048H
  007b6	ba 48 00 00 00	 mov	 edx, 72			; 00000048H
  007bb	48 8d 0d 12 00
	00 00		 lea	 rcx, OFFSET FLAT:BootArgs+18
  007c2	e8 00 00 00 00	 call	 RtlSecureZeroMemory
$LN12@MountDrive:
  007c7	8b 8c 24 80 02
	00 00		 mov	 ecx, DWORD PTR burnc$29634[rsp]
  007ce	8b 84 24 80 02
	00 00		 mov	 eax, DWORD PTR burnc$29634[rsp]
  007d5	83 e8 01	 sub	 eax, 1
  007d8	89 84 24 80 02
	00 00		 mov	 DWORD PTR burnc$29634[rsp], eax
  007df	85 c9		 test	 ecx, ecx
  007e1	74 21		 je	 SHORT $LN11@MountDrive
  007e3	48 8b 84 24 88
	02 00 00	 mov	 rax, QWORD PTR burnm$29632[rsp]
  007eb	c6 00 00	 mov	 BYTE PTR [rax], 0
  007ee	48 8b 84 24 88
	02 00 00	 mov	 rax, QWORD PTR burnm$29632[rsp]
  007f6	48 83 c0 01	 add	 rax, 1
  007fa	48 89 84 24 88
	02 00 00	 mov	 QWORD PTR burnm$29632[rsp], rax
  00802	eb c3		 jmp	 SHORT $LN12@MountDrive
$LN11@MountDrive:
  00804	33 c0		 xor	 eax, eax
  00806	85 c0		 test	 eax, eax
  00808	75 92		 jne	 SHORT $LN15@MountDrive

; 347  : 
; 348  : 		{
; 349  : 			STORAGE_DEVICE_NUMBER storageDeviceNumber;
; 350  : 			status = SendDeviceIoControlRequest (Extension->LowerDeviceObject, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0, &storageDeviceNumber, sizeof (storageDeviceNumber));

  0080a	c7 44 24 28 0c
	00 00 00	 mov	 DWORD PTR [rsp+40], 12
  00812	48 8d 84 24 90
	02 00 00	 lea	 rax, QWORD PTR storageDeviceNumber$29638[rsp]
  0081a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0081f	45 33 c9	 xor	 r9d, r9d
  00822	45 33 c0	 xor	 r8d, r8d
  00825	ba 80 10 2d 00	 mov	 edx, 2953344		; 002d1080H
  0082a	48 8b 8c 24 d0
	02 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00832	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00836	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  0083b	89 44 24 48	 mov	 DWORD PTR status$[rsp], eax

; 351  : 
; 352  : 			if (!NT_SUCCESS (status))

  0083f	83 7c 24 48 00	 cmp	 DWORD PTR status$[rsp], 0
  00844	7d 21		 jge	 SHORT $LN10@MountDrive

; 353  : 			{
; 354  : 				Dump ("Failed to get drive number - error %x\n", status);

  00846	8b 54 24 48	 mov	 edx, DWORD PTR status$[rsp]
  0084a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CH@LNDECHEL@Failed?5to?5get?5drive?5number?5?9?5err@FNODOBFM@
  00851	e8 00 00 00 00	 call	 DbgPrint

; 355  : 				Extension->SystemStorageDeviceNumberValid = FALSE;

  00856	48 8b 94 24 d0
	02 00 00	 mov	 rdx, QWORD PTR Extension$[rsp]
  0085e	c7 42 34 00 00
	00 00		 mov	 DWORD PTR [rdx+52], 0

; 356  : 			}
; 357  : 			else

  00865	eb 21		 jmp	 SHORT $LN9@MountDrive
$LN10@MountDrive:

; 358  : 			{
; 359  : 				Extension->SystemStorageDeviceNumber = storageDeviceNumber.DeviceNumber;

  00867	48 8b 8c 24 d0
	02 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  0086f	8b 84 24 94 02
	00 00		 mov	 eax, DWORD PTR storageDeviceNumber$29638[rsp+4]
  00876	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 360  : 				Extension->SystemStorageDeviceNumberValid = TRUE;

  00879	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  00881	c7 40 34 01 00
	00 00		 mov	 DWORD PTR [rax+52], 1
$LN9@MountDrive:

; 361  : 			}
; 362  : 		}
; 363  : 
; 364  : 		status = SendDeviceIoControlRequest (Extension->LowerDeviceObject, IOCTL_DISK_GET_LENGTH_INFO, NULL, 0, &BootDriveLength, sizeof (BootDriveLength));

  00888	c7 44 24 28 08
	00 00 00	 mov	 DWORD PTR [rsp+40], 8
  00890	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:BootDriveLength
  00897	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0089c	45 33 c9	 xor	 r9d, r9d
  0089f	45 33 c0	 xor	 r8d, r8d
  008a2	ba 5c 40 07 00	 mov	 edx, 475228		; 0007405cH
  008a7	48 8b 8c 24 d0
	02 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  008af	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  008b3	e8 00 00 00 00	 call	 SendDeviceIoControlRequest
  008b8	89 44 24 48	 mov	 DWORD PTR status$[rsp], eax

; 365  : 		
; 366  : 		if (!NT_SUCCESS (status))

  008bc	83 7c 24 48 00	 cmp	 DWORD PTR status$[rsp], 0
  008c1	7d 30		 jge	 SHORT $LN8@MountDrive

; 367  : 		{
; 368  : 			Dump ("Failed to get drive length - error %x\n", status);

  008c3	8b 54 24 48	 mov	 edx, DWORD PTR status$[rsp]
  008c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CH@IHPMFJGA@Failed?5to?5get?5drive?5length?5?9?5err@FNODOBFM@
  008ce	e8 00 00 00 00	 call	 DbgPrint

; 369  : 			BootDriveLength.QuadPart = 0;

  008d3	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR BootDriveLength, 0

; 370  : 			Extension->Queue.MaxReadAheadOffset.QuadPart = 0;

  008de	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR Extension$[rsp]
  008e6	48 c7 80 80 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+640], 0

; 371  : 		}
; 372  : 		else

  008f1	eb 16		 jmp	 SHORT $LN7@MountDrive
$LN8@MountDrive:

; 373  : 			Extension->Queue.MaxReadAheadOffset = BootDriveLength;

  008f3	48 8b 8c 24 d0
	02 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  008fb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveLength
  00902	48 89 81 80 02
	00 00		 mov	 QWORD PTR [rcx+640], rax
$LN7@MountDrive:

; 374  : 		
; 375  : 		status = EncryptedIoQueueStart (&Extension->Queue);

  00909	48 8b 8c 24 d0
	02 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  00911	48 83 c1 50	 add	 rcx, 80			; 00000050H
  00915	e8 00 00 00 00	 call	 EncryptedIoQueueStart
  0091a	89 44 24 48	 mov	 DWORD PTR status$[rsp], eax

; 376  : 		if (!NT_SUCCESS (status))

  0091e	83 7c 24 48 00	 cmp	 DWORD PTR status$[rsp], 0
  00923	7d 21		 jge	 SHORT $LN6@MountDrive

; 377  : 			TC_BUG_CHECK (status);

  00925	4c 63 44 24 48	 movsxd	 r8, DWORD PTR status$[rsp]
  0092a	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00933	45 33 c9	 xor	 r9d, r9d
  00936	ba 79 01 00 00	 mov	 edx, 377		; 00000179H
  0093b	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  00940	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN6@MountDrive:

; 378  : 
; 379  : 		if (IsOSAtLeast (WIN_VISTA))

  00946	b9 0b 00 00 00	 mov	 ecx, 11
  0094b	e8 00 00 00 00	 call	 IsOSAtLeast
  00950	85 c0		 test	 eax, eax
  00952	74 16		 je	 SHORT $LN5@MountDrive

; 380  : 		{
; 381  : 			CrashDumpEnabled = TRUE;

  00954	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR CrashDumpEnabled, 1

; 382  : 			HibernationEnabled = TRUE;

  0095e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR HibernationEnabled, 1
  00968	eb 0e		 jmp	 SHORT $LN4@MountDrive
$LN5@MountDrive:

; 383  : 		}
; 384  : 		else if (!LegacyHibernationDriverFilterActive)

  0096a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR LegacyHibernationDriverFilterActive, 0
  00971	75 05		 jne	 SHORT $LN3@MountDrive

; 385  : 			StartLegacyHibernationDriverFilter();

  00973	e8 00 00 00 00	 call	 StartLegacyHibernationDriverFilter
$LN3@MountDrive:
$LN4@MountDrive:

; 386  : 
; 387  : 		// Hidden system hibernation is not supported if an extra boot partition is present as the system is not allowed to update the boot partition
; 388  : 		if (IsHiddenSystemRunning() && (BootArgs.Flags & TC_BOOT_ARGS_FLAG_EXTRA_BOOT_PARTITION))

  00978	e8 00 00 00 00	 call	 IsHiddenSystemRunning
  0097d	85 c0		 test	 eax, eax
  0097f	74 21		 je	 SHORT $LN2@MountDrive
  00981	8b 05 6a 00 00
	00		 mov	 eax, DWORD PTR BootArgs+106
  00987	83 e0 01	 and	 eax, 1
  0098a	85 c0		 test	 eax, eax
  0098c	74 14		 je	 SHORT $LN2@MountDrive

; 389  : 		{
; 390  : 			CrashDumpEnabled = FALSE;

  0098e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR CrashDumpEnabled, 0

; 391  : 			HibernationEnabled = FALSE;

  00998	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR HibernationEnabled, 0
$LN2@MountDrive:

; 392  : 		}
; 393  : 	}
; 394  : 	else

  009a2	eb 3b		 jmp	 SHORT $LN1@MountDrive
$LN22@MountDrive:

; 395  : 	{
; 396  : 		Dump ("Header not decrypted\n");

  009a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@CKLJIMPP@Header?5not?5decrypted?6?$AA@FNODOBFM@
  009ab	e8 00 00 00 00	 call	 DbgPrint

; 397  : 		crypto_close (Extension->HeaderCryptoInfo);

  009b0	48 8b 8c 24 d0
	02 00 00	 mov	 rcx, QWORD PTR Extension$[rsp]
  009b8	48 8b 89 30 03
	00 00		 mov	 rcx, QWORD PTR [rcx+816]
  009bf	e8 00 00 00 00	 call	 crypto_close

; 398  : 		Extension->HeaderCryptoInfo = NULL;

  009c4	48 8b 94 24 d0
	02 00 00	 mov	 rdx, QWORD PTR Extension$[rsp]
  009cc	48 c7 82 30 03
	00 00 00 00 00
	00		 mov	 QWORD PTR [rdx+816], 0

; 399  : 
; 400  : 		status = STATUS_UNSUCCESSFUL;

  009d7	c7 44 24 48 01
	00 00 c0	 mov	 DWORD PTR status$[rsp], -1073741823 ; ffffffffc0000001H
$LN1@MountDrive:
$ret$29603:

; 401  : 	}
; 402  : 
; 403  : ret:
; 404  : 	TCfree (header);

  009df	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  009e4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR header$[rsp]
  009e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 405  : 	return status;

  009ef	8b 44 24 48	 mov	 eax, DWORD PTR status$[rsp]
$LN30@MountDrive:
$LN31@MountDrive:

; 406  : }

  009f3	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  009fb	48 33 cc	 xor	 rcx, rsp
  009fe	e8 00 00 00 00	 call	 __security_check_cookie
  00a03	48 81 c4 c0 02
	00 00		 add	 rsp, 704		; 000002c0H
  00a0a	5f		 pop	 rdi
  00a0b	c3		 ret	 0
MountDrive ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CheckDeviceTypeAndMount DD imagerel CheckDeviceTypeAndMount
	DD	imagerel CheckDeviceTypeAndMount+235
	DD	imagerel $unwind$CheckDeviceTypeAndMount
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CheckDeviceTypeAndMount DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT CheckDeviceTypeAndMount
_TEXT	SEGMENT
status$29764 = 48
filterExtension$ = 80
CheckDeviceTypeAndMount PROC				; COMDAT

; 525  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 526  : 	if (BootArgsValid)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR BootArgsValid, 0
  00010	0f 84 d0 00 00
	00		 je	 $LN5@CheckDevic

; 527  : 	{
; 528  : 		// Windows sometimes merges a removable drive PDO and its volume PDO to a single PDO having no volume interface (GUID_DEVINTERFACE_VOLUME).
; 529  : 		// Therefore, we need to test whether the device supports volume IOCTLs.
; 530  : 		if (VolumeClassFilterRegistered
; 531  : 			&& BootArgs.HiddenSystemPartitionStart != 0
; 532  : 			&& IsVolumeDevice (filterExtension->LowerDeviceObject))

  00016	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR VolumeClassFilterRegistered, 0
  0001d	74 4c		 je	 SHORT $LN4@CheckDevic
  0001f	48 83 3d 5a 00
	00 00 00	 cmp	 QWORD PTR BootArgs+90, 0
  00027	74 42		 je	 SHORT $LN4@CheckDevic
  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR filterExtension$[rsp]
  0002e	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00032	e8 00 00 00 00	 call	 IsVolumeDevice
  00037	85 c0		 test	 eax, eax
  00039	74 30		 je	 SHORT $LN4@CheckDevic

; 533  : 		{
; 534  : 			Dump ("Drive and volume merged pdo=%p", filterExtension->Pdo);

  0003b	48 8b 54 24 50	 mov	 rdx, QWORD PTR filterExtension$[rsp]
  00040	48 8b 52 28	 mov	 rdx, QWORD PTR [rdx+40]
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@NOBPEAIN@Drive?5and?5volume?5merged?5pdo?$DN?$CFp?$AA@FNODOBFM@
  0004b	e8 00 00 00 00	 call	 DbgPrint

; 535  : 
; 536  : 			filterExtension->IsVolumeFilterDevice = TRUE;

  00050	4c 8b 5c 24 50	 mov	 r11, QWORD PTR filterExtension$[rsp]
  00055	41 c7 43 0c 01
	00 00 00	 mov	 DWORD PTR [r11+12], 1

; 537  : 			filterExtension->IsDriveFilterDevice = FALSE;

  0005d	48 8b 44 24 50	 mov	 rax, QWORD PTR filterExtension$[rsp]
  00062	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 538  : 		}
; 539  : 		else

  00069	eb 7b		 jmp	 SHORT $LN3@CheckDevic
$LN4@CheckDevic:

; 540  : 		{
; 541  : 			NTSTATUS status = KeWaitForMutexObject (&MountMutex, Executive, KernelMode, FALSE, NULL);

  0006b	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00074	45 33 c9	 xor	 r9d, r9d
  00077	45 33 c0	 xor	 r8d, r8d
  0007a	33 d2		 xor	 edx, edx
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:MountMutex
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  00089	89 44 24 30	 mov	 DWORD PTR status$29764[rsp], eax

; 542  : 			if (!NT_SUCCESS (status))

  0008d	83 7c 24 30 00	 cmp	 DWORD PTR status$29764[rsp], 0
  00092	7d 21		 jge	 SHORT $LN2@CheckDevic

; 543  : 				TC_BUG_CHECK (status);

  00094	4c 63 44 24 30	 movsxd	 r8, DWORD PTR status$29764[rsp]
  00099	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  000a2	45 33 c9	 xor	 r9d, r9d
  000a5	ba 1f 02 00 00	 mov	 edx, 543		; 0000021fH
  000aa	b9 29 00 00 00	 mov	 ecx, 41			; 00000029H
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
$LN2@CheckDevic:

; 544  : 
; 545  : 			if (!BootDriveFound)

  000b5	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR BootDriveFound
  000bb	85 c0		 test	 eax, eax
  000bd	75 18		 jne	 SHORT $LN1@CheckDevic

; 546  : 				MountDrive (filterExtension, &BootArgs.BootPassword, &BootArgs.HeaderSaltCrc32);

  000bf	4c 8d 05 0e 00
	00 00		 lea	 r8, OFFSET FLAT:BootArgs+14
  000c6	48 8d 15 12 00
	00 00		 lea	 rdx, OFFSET FLAT:BootArgs+18
  000cd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR filterExtension$[rsp]
  000d2	e8 00 00 00 00	 call	 MountDrive
$LN1@CheckDevic:

; 547  : 
; 548  : 			KeReleaseMutex (&MountMutex, FALSE);

  000d7	33 d2		 xor	 edx, edx
  000d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:MountMutex
  000e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseMutex
$LN3@CheckDevic:
$LN5@CheckDevic:
$LN7@CheckDevic:

; 549  : 		}
; 550  : 	}
; 551  : }

  000e6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ea	c3		 ret	 0
CheckDeviceTypeAndMount ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$MountDriveWorkItemRoutine DD imagerel MountDriveWorkItemRoutine
	DD	imagerel MountDriveWorkItemRoutine+52
	DD	imagerel $unwind$MountDriveWorkItemRoutine
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MountDriveWorkItemRoutine DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT MountDriveWorkItemRoutine
_TEXT	SEGMENT
deviceObject$ = 48
filterExtension$ = 56
MountDriveWorkItemRoutine PROC				; COMDAT

; 555  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 556  : 	CheckDeviceTypeAndMount (filterExtension);

  0000e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR filterExtension$[rsp]
  00013	e8 00 00 00 00	 call	 CheckDeviceTypeAndMount

; 557  : 	KeSetEvent (&filterExtension->MountWorkItemCompletedEvent, IO_NO_INCREMENT, FALSE);

  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR filterExtension$[rsp]
  0001d	48 81 c1 18 03
	00 00		 add	 rcx, 792		; 00000318H
  00024	45 33 c0	 xor	 r8d, r8d
  00027	33 d2		 xor	 edx, edx
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent

; 558  : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
MountDriveWorkItemRoutine ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$OnStartDeviceCompleted DD imagerel OnStartDeviceCompleted
	DD	imagerel OnStartDeviceCompleted+307
	DD	imagerel $unwind$OnStartDeviceCompleted
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$OnStartDeviceCompleted DD 011301H
	DD	08213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT OnStartDeviceCompleted
_TEXT	SEGMENT
workItem$29789 = 48
filterDeviceObject$ = 80
Irp$ = 88
Extension$ = 96
OnStartDeviceCompleted PROC				; COMDAT

; 562  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 563  : 	if (Irp->PendingReturned)

  00013	48 8b 44 24 58	 mov	 rax, QWORD PTR Irp$[rsp]
  00018	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  0001c	85 c0		 test	 eax, eax
  0001e	74 0a		 je	 SHORT $LN5@OnStartDev@2

; 564  : 		IoMarkIrpPending (Irp);

  00020	48 8b 4c 24 58	 mov	 rcx, QWORD PTR Irp$[rsp]
  00025	e8 00 00 00 00	 call	 IoMarkIrpPending
$LN5@OnStartDev@2:

; 565  : 
; 566  : 	if (Extension->LowerDeviceObject->Characteristics & FILE_REMOVABLE_MEDIA)

  0002a	48 8b 44 24 60	 mov	 rax, QWORD PTR Extension$[rsp]
  0002f	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00033	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  00036	83 e0 01	 and	 eax, 1
  00039	85 c0		 test	 eax, eax
  0003b	74 13		 je	 SHORT $LN4@OnStartDev@2

; 567  : 		filterDeviceObject->Characteristics |= FILE_REMOVABLE_MEDIA;

  0003d	48 8b 44 24 50	 mov	 rax, QWORD PTR filterDeviceObject$[rsp]
  00042	8b 48 34	 mov	 ecx, DWORD PTR [rax+52]
  00045	83 c9 01	 or	 ecx, 1
  00048	48 8b 44 24 50	 mov	 rax, QWORD PTR filterDeviceObject$[rsp]
  0004d	89 48 34	 mov	 DWORD PTR [rax+52], ecx
$LN4@OnStartDev@2:

; 568  : 
; 569  : 	if (KeGetCurrentIrql() == PASSIVE_LEVEL)

  00050	e8 00 00 00 00	 call	 KeGetCurrentIrql
  00055	0f b6 c0	 movzx	 eax, al
  00058	85 c0		 test	 eax, eax
  0005a	75 0f		 jne	 SHORT $LN3@OnStartDev@2

; 570  : 	{
; 571  : 		CheckDeviceTypeAndMount (Extension);

  0005c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR Extension$[rsp]
  00061	e8 00 00 00 00	 call	 CheckDeviceTypeAndMount

; 572  : 	}
; 573  : 	else

  00066	e9 a4 00 00 00	 jmp	 $LN2@OnStartDev@2
$LN3@OnStartDev@2:

; 574  : 	{
; 575  : 		PIO_WORKITEM workItem = IoAllocateWorkItem (filterDeviceObject);

  0006b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR filterDeviceObject$[rsp]
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAllocateWorkItem
  00076	48 89 44 24 30	 mov	 QWORD PTR workItem$29789[rsp], rax

; 576  : 		if (!workItem)

  0007b	48 83 7c 24 30
	00		 cmp	 QWORD PTR workItem$29789[rsp], 0
  00081	75 27		 jne	 SHORT $LN1@OnStartDev@2

; 577  : 		{
; 578  : 			IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00083	48 8b 4c 24 60	 mov	 rcx, QWORD PTR Extension$[rsp]
  00088	48 81 c1 f0 00
	00 00		 add	 rcx, 240		; 000000f0H
  0008f	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  00095	48 8b 54 24 58	 mov	 rdx, QWORD PTR Irp$[rsp]
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 579  : 			return STATUS_INSUFFICIENT_RESOURCES;

  000a0	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  000a5	e9 84 00 00 00	 jmp	 $LN6@OnStartDev@2
$LN1@OnStartDev@2:

; 580  : 		}
; 581  : 
; 582  : 		KeInitializeEvent (&Extension->MountWorkItemCompletedEvent, SynchronizationEvent, FALSE);

  000aa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR Extension$[rsp]
  000af	48 81 c1 18 03
	00 00		 add	 rcx, 792		; 00000318H
  000b6	45 33 c0	 xor	 r8d, r8d
  000b9	ba 01 00 00 00	 mov	 edx, 1
  000be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 583  : 		IoQueueWorkItem (workItem, MountDriveWorkItemRoutine, DelayedWorkQueue, Extension); 

  000c4	4c 8b 4c 24 60	 mov	 r9, QWORD PTR Extension$[rsp]
  000c9	41 b8 01 00 00
	00		 mov	 r8d, 1
  000cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:MountDriveWorkItemRoutine
  000d6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR workItem$29789[rsp]
  000db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoQueueWorkItem

; 584  : 
; 585  : 		KeWaitForSingleObject (&Extension->MountWorkItemCompletedEvent, Executive, KernelMode, FALSE, NULL);

  000e1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR Extension$[rsp]
  000e6	48 81 c1 18 03
	00 00		 add	 rcx, 792		; 00000318H
  000ed	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000f6	45 33 c9	 xor	 r9d, r9d
  000f9	45 33 c0	 xor	 r8d, r8d
  000fc	33 d2		 xor	 edx, edx
  000fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 586  : 		IoFreeWorkItem (workItem);

  00104	48 8b 4c 24 30	 mov	 rcx, QWORD PTR workItem$29789[rsp]
  00109	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoFreeWorkItem
$LN2@OnStartDev@2:

; 587  : 	}
; 588  : 
; 589  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  0010f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR Extension$[rsp]
  00114	48 81 c1 f0 00
	00 00		 add	 rcx, 240		; 000000f0H
  0011b	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  00121	48 8b 54 24 58	 mov	 rdx, QWORD PTR Irp$[rsp]
  00126	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 590  : 	return STATUS_CONTINUE_COMPLETION;

  0012c	33 c0		 xor	 eax, eax
$LN6@OnStartDev@2:

; 591  : }

  0012e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00132	c3		 ret	 0
OnStartDeviceCompleted ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DispatchPnp DD imagerel DispatchPnp
	DD	imagerel DispatchPnp+721
	DD	imagerel $unwind$DispatchPnp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DispatchPnp DD 011801H
	DD	0a218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DispatchPnp
_TEXT	SEGMENT
status$ = 48
attachedDevice$29819 = 56
tv78 = 64
DeviceObject$ = 96
Irp$ = 104
Extension$ = 112
irpSp$ = 120
DispatchPnp PROC					; COMDAT

; 595  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 596  : 	NTSTATUS status;
; 597  : 
; 598  : 	status = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00018	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Extension$[rsp]
  0001d	48 81 c1 f0 00
	00 00		 add	 rcx, 240		; 000000f0H
  00024	c7 44 24 20 78
	00 00 00	 mov	 DWORD PTR [rsp+32], 120	; 00000078H
  0002c	41 b9 56 02 00
	00		 mov	 r9d, 598		; 00000256H
  00032	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0EF@GDHJGIB@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  00039	48 8b 54 24 68	 mov	 rdx, QWORD PTR Irp$[rsp]
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAcquireRemoveLockEx
  00044	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax

; 599  : 	if (!NT_SUCCESS (status))

  00048	83 7c 24 30 00	 cmp	 DWORD PTR status$[rsp], 0
  0004d	7d 16		 jge	 SHORT $LN15@DispatchPn@2

; 600  : 		return TCCompleteIrp (Irp, status, 0);

  0004f	45 33 c0	 xor	 r8d, r8d
  00052	8b 54 24 30	 mov	 edx, DWORD PTR status$[rsp]
  00056	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Irp$[rsp]
  0005b	e8 00 00 00 00	 call	 TCCompleteIrp
  00060	e9 67 02 00 00	 jmp	 $LN16@DispatchPn@2
$LN15@DispatchPn@2:

; 601  : 
; 602  : 	switch (irpSp->MinorFunction)

  00065	48 8b 44 24 78	 mov	 rax, QWORD PTR irpSp$[rsp]
  0006a	8a 40 01	 mov	 al, BYTE PTR [rax+1]
  0006d	88 44 24 40	 mov	 BYTE PTR tv78[rsp], al
  00071	80 7c 24 40 00	 cmp	 BYTE PTR tv78[rsp], 0
  00076	74 17		 je	 SHORT $LN12@DispatchPn@2
  00078	80 7c 24 40 02	 cmp	 BYTE PTR tv78[rsp], 2
  0007d	0f 84 67 01 00
	00		 je	 $LN4@DispatchPn@2
  00083	80 7c 24 40 16	 cmp	 BYTE PTR tv78[rsp], 22
  00088	74 3e		 je	 SHORT $LN11@DispatchPn@2
  0008a	e9 05 02 00 00	 jmp	 $LN1@DispatchPn@2
$LN12@DispatchPn@2:

; 603  : 	{
; 604  : 	case IRP_MN_START_DEVICE:
; 605  : 		Dump ("IRP_MN_START_DEVICE pdo=%p\n", Extension->Pdo);

  0008f	48 8b 54 24 70	 mov	 rdx, QWORD PTR Extension$[rsp]
  00094	48 8b 52 28	 mov	 rdx, QWORD PTR [rdx+40]
  00098	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@EOGIDBIC@IRP_MN_START_DEVICE?5pdo?$DN?$CFp?6?$AA@FNODOBFM@
  0009f	e8 00 00 00 00	 call	 DbgPrint

; 606  : 		return PassFilteredIrp (Extension->LowerDeviceObject, Irp, OnStartDeviceCompleted, Extension);

  000a4	4c 8b 4c 24 70	 mov	 r9, QWORD PTR Extension$[rsp]
  000a9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:OnStartDeviceCompleted
  000b0	48 8b 54 24 68	 mov	 rdx, QWORD PTR Irp$[rsp]
  000b5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Extension$[rsp]
  000ba	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  000be	e8 00 00 00 00	 call	 PassFilteredIrp
  000c3	e9 04 02 00 00	 jmp	 $LN16@DispatchPn@2
$LN11@DispatchPn@2:

; 607  : 
; 608  : 
; 609  : 	case IRP_MN_DEVICE_USAGE_NOTIFICATION:
; 610  : 		Dump ("IRP_MN_DEVICE_USAGE_NOTIFICATION type=%d\n", (int) irpSp->Parameters.UsageNotification.Type);

  000c8	48 8b 44 24 78	 mov	 rax, QWORD PTR irpSp$[rsp]
  000cd	8b 50 10	 mov	 edx, DWORD PTR [rax+16]
  000d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CK@HDNODHHC@IRP_MN_DEVICE_USAGE_NOTIFICATION@FNODOBFM@
  000d7	e8 00 00 00 00	 call	 DbgPrint

; 611  : 
; 612  : 		{
; 613  : 			PDEVICE_OBJECT attachedDevice = IoGetAttachedDeviceReference (DeviceObject);

  000dc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  000e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetAttachedDeviceReference
  000e7	48 89 44 24 38	 mov	 QWORD PTR attachedDevice$29819[rsp], rax

; 614  : 
; 615  : 			if (attachedDevice == DeviceObject || (attachedDevice->Flags & DO_POWER_PAGABLE))

  000ec	48 8b 44 24 60	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  000f1	48 39 44 24 38	 cmp	 QWORD PTR attachedDevice$29819[rsp], rax
  000f6	74 11		 je	 SHORT $LN9@DispatchPn@2
  000f8	48 8b 44 24 38	 mov	 rax, QWORD PTR attachedDevice$29819[rsp]
  000fd	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00100	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  00105	85 c0		 test	 eax, eax
  00107	74 16		 je	 SHORT $LN10@DispatchPn@2
$LN9@DispatchPn@2:

; 616  : 				DeviceObject->Flags |= DO_POWER_PAGABLE;

  00109	48 8b 44 24 60	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  0010e	8b 48 30	 mov	 ecx, DWORD PTR [rax+48]
  00111	81 c9 00 20 00
	00		 or	 ecx, 8192		; 00002000H
  00117	48 8b 44 24 60	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  0011c	89 48 30	 mov	 DWORD PTR [rax+48], ecx
$LN10@DispatchPn@2:

; 617  : 
; 618  : 			ObDereferenceObject (attachedDevice);

  0011f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR attachedDevice$29819[rsp]
  00124	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 619  : 		}
; 620  : 
; 621  : 		// Prevent creation of hibernation and crash dump files if required
; 622  : 		if (irpSp->Parameters.UsageNotification.InPath
; 623  : 			&& (
; 624  : 				(irpSp->Parameters.UsageNotification.Type == DeviceUsageTypeDumpFile && !CrashDumpEnabled)
; 625  : 				|| (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypeHibernation && !HibernationEnabled)
; 626  : 				)
; 627  : 			)

  0012a	48 8b 44 24 78	 mov	 rax, QWORD PTR irpSp$[rsp]
  0012f	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  00133	85 c0		 test	 eax, eax
  00135	0f 84 8b 00 00
	00		 je	 $LN8@DispatchPn@2
  0013b	48 8b 44 24 78	 mov	 rax, QWORD PTR irpSp$[rsp]
  00140	83 78 10 03	 cmp	 DWORD PTR [rax+16], 3
  00144	75 09		 jne	 SHORT $LN6@DispatchPn@2
  00146	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR CrashDumpEnabled, 0
  0014d	74 14		 je	 SHORT $LN7@DispatchPn@2
$LN6@DispatchPn@2:
  0014f	48 8b 44 24 78	 mov	 rax, QWORD PTR irpSp$[rsp]
  00154	83 78 10 02	 cmp	 DWORD PTR [rax+16], 2
  00158	75 6c		 jne	 SHORT $LN8@DispatchPn@2
  0015a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR HibernationEnabled, 0
  00161	75 63		 jne	 SHORT $LN8@DispatchPn@2
$LN7@DispatchPn@2:

; 628  : 		{
; 629  : 			IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00163	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Extension$[rsp]
  00168	48 81 c1 f0 00
	00 00		 add	 rcx, 240		; 000000f0H
  0016f	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  00175	48 8b 54 24 68	 mov	 rdx, QWORD PTR Irp$[rsp]
  0017a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 630  : 
; 631  : 			if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypeHibernation)

  00180	4c 8b 5c 24 78	 mov	 r11, QWORD PTR irpSp$[rsp]
  00185	41 83 7b 10 02	 cmp	 DWORD PTR [r11+16], 2
  0018a	75 0f		 jne	 SHORT $LN5@DispatchPn@2

; 632  : 				++HibernationPreventionCount;

  0018c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR HibernationPreventionCount
  00192	83 c0 01	 add	 eax, 1
  00195	89 05 00 00 00
	00		 mov	 DWORD PTR HibernationPreventionCount, eax
$LN5@DispatchPn@2:

; 633  : 
; 634  : 			Dump ("Preventing dump type=%d\n", (int) irpSp->Parameters.UsageNotification.Type);

  0019b	48 8b 44 24 78	 mov	 rax, QWORD PTR irpSp$[rsp]
  001a0	8b 50 10	 mov	 edx, DWORD PTR [rax+16]
  001a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@ECOGMEFG@Preventing?5dump?5type?$DN?$CFd?6?$AA@FNODOBFM@
  001aa	e8 00 00 00 00	 call	 DbgPrint

; 635  : 			return TCCompleteIrp (Irp, STATUS_UNSUCCESSFUL, 0);

  001af	45 33 c0	 xor	 r8d, r8d
  001b2	ba 01 00 00 c0	 mov	 edx, -1073741823	; ffffffffc0000001H
  001b7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Irp$[rsp]
  001bc	e8 00 00 00 00	 call	 TCCompleteIrp
  001c1	e9 06 01 00 00	 jmp	 $LN16@DispatchPn@2
$LN8@DispatchPn@2:

; 636  : 		}
; 637  : 
; 638  : 		return PassFilteredIrp (Extension->LowerDeviceObject, Irp, OnDeviceUsageNotificationCompleted, Extension);

  001c6	4c 8b 4c 24 70	 mov	 r9, QWORD PTR Extension$[rsp]
  001cb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:OnDeviceUsageNotificationCompleted
  001d2	48 8b 54 24 68	 mov	 rdx, QWORD PTR Irp$[rsp]
  001d7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Extension$[rsp]
  001dc	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  001e0	e8 00 00 00 00	 call	 PassFilteredIrp
  001e5	e9 e2 00 00 00	 jmp	 $LN16@DispatchPn@2
$LN4@DispatchPn@2:

; 639  : 
; 640  : 
; 641  : 	case IRP_MN_REMOVE_DEVICE:
; 642  : 		Dump ("IRP_MN_REMOVE_DEVICE pdo=%p\n", Extension->Pdo);

  001ea	48 8b 54 24 70	 mov	 rdx, QWORD PTR Extension$[rsp]
  001ef	48 8b 52 28	 mov	 rdx, QWORD PTR [rdx+40]
  001f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@GINPCIAN@IRP_MN_REMOVE_DEVICE?5pdo?$DN?$CFp?6?$AA@FNODOBFM@
  001fa	e8 00 00 00 00	 call	 DbgPrint

; 643  : 
; 644  : 		IoReleaseRemoveLockAndWait (&Extension->Queue.RemoveLock, Irp);

  001ff	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Extension$[rsp]
  00204	48 81 c1 f0 00
	00 00		 add	 rcx, 240		; 000000f0H
  0020b	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  00211	48 8b 54 24 68	 mov	 rdx, QWORD PTR Irp$[rsp]
  00216	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockAndWaitEx

; 645  : 		status = PassIrp (Extension->LowerDeviceObject, Irp);

  0021c	48 8b 54 24 68	 mov	 rdx, QWORD PTR Irp$[rsp]
  00221	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Extension$[rsp]
  00226	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0022a	e8 00 00 00 00	 call	 PassIrp
  0022f	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax

; 646  : 
; 647  : 		IoDetachDevice (Extension->LowerDeviceObject);

  00233	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Extension$[rsp]
  00238	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0023c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDetachDevice

; 648  : 
; 649  : 		if (Extension->DriveMounted)

  00242	4c 8b 5c 24 70	 mov	 r11, QWORD PTR Extension$[rsp]
  00247	41 83 bb 10 03
	00 00 00	 cmp	 DWORD PTR [r11+784], 0
  0024f	74 0f		 je	 SHORT $LN3@DispatchPn@2

; 650  : 			DismountDrive (Extension, TRUE);

  00251	ba 01 00 00 00	 mov	 edx, 1
  00256	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Extension$[rsp]
  0025b	e8 00 00 00 00	 call	 DismountDrive
$LN3@DispatchPn@2:

; 651  : 
; 652  : 		if (Extension->BootDrive)

  00260	48 8b 44 24 70	 mov	 rax, QWORD PTR Extension$[rsp]
  00265	83 b8 08 03 00
	00 00		 cmp	 DWORD PTR [rax+776], 0
  0026c	74 15		 je	 SHORT $LN2@DispatchPn@2

; 653  : 		{
; 654  : 			BootDriveFound = FALSE;

  0026e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR BootDriveFound, 0

; 655  : 			BootDriveFilterExtension = NULL;

  00278	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR BootDriveFilterExtension, 0
$LN2@DispatchPn@2:

; 656  : 		}
; 657  : 
; 658  : 		IoDeleteDevice (DeviceObject);

  00283	48 8b 4c 24 60	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  00288	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteDevice

; 659  : 		return status;

  0028e	8b 44 24 30	 mov	 eax, DWORD PTR status$[rsp]
  00292	eb 38		 jmp	 SHORT $LN16@DispatchPn@2
$LN1@DispatchPn@2:

; 660  : 
; 661  : 
; 662  : 	default:
; 663  : 		status = PassIrp (Extension->LowerDeviceObject, Irp);

  00294	48 8b 54 24 68	 mov	 rdx, QWORD PTR Irp$[rsp]
  00299	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Extension$[rsp]
  0029e	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  002a2	e8 00 00 00 00	 call	 PassIrp
  002a7	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax

; 664  : 		IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  002ab	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Extension$[rsp]
  002b0	48 81 c1 f0 00
	00 00		 add	 rcx, 240		; 000000f0H
  002b7	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  002bd	48 8b 54 24 68	 mov	 rdx, QWORD PTR Irp$[rsp]
  002c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 665  : 	}
; 666  : 	return status;

  002c8	8b 44 24 30	 mov	 eax, DWORD PTR status$[rsp]
$LN16@DispatchPn@2:

; 667  : }

  002cc	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002d0	c3		 ret	 0
DispatchPnp ENDP
_TEXT	ENDS
PUBLIC	DriveFilterDispatchIrp
;	COMDAT pdata
pdata	SEGMENT
$pdata$DriveFilterDispatchIrp DD imagerel $LN13
	DD	imagerel $LN13+429
	DD	imagerel $unwind$DriveFilterDispatchIrp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DriveFilterDispatchIrp DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DriveFilterDispatchIrp
_TEXT	SEGMENT
Extension$ = 48
status$ = 56
irpSp$ = 64
tv74 = 72
tv76 = 76
DeviceObject$ = 96
Irp$ = 104
DriveFilterDispatchIrp PROC				; COMDAT

; 708  : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 709  : 	DriveFilterExtension *Extension = (DriveFilterExtension *) DeviceObject->DeviceExtension;

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR DeviceObject$[rsp]
  00013	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00017	48 89 44 24 30	 mov	 QWORD PTR Extension$[rsp], rax

; 710  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);

  0001c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Irp$[rsp]
  00021	e8 00 00 00 00	 call	 IoGetCurrentIrpStackLocation
  00026	48 89 44 24 40	 mov	 QWORD PTR irpSp$[rsp], rax

; 711  : 	NTSTATUS status;
; 712  : 
; 713  : 	ASSERT (!Extension->bRootDevice && Extension->IsDriveFilterDevice);

  0002b	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  00030	83 38 00	 cmp	 DWORD PTR [rax], 0
  00033	75 15		 jne	 SHORT $LN11@DriveFilte@2
  00035	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  0003a	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0003e	74 0a		 je	 SHORT $LN11@DriveFilte@2
  00040	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  00048	eb 25		 jmp	 SHORT $LN12@DriveFilte@2
$LN11@DriveFilte@2:
  0004a	45 33 c9	 xor	 r9d, r9d
  0004d	41 b8 c9 02 00
	00		 mov	 r8d, 713		; 000002c9H
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EF@GDHJGIB@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DK@ECCPCMLD@?$CBExtension?9?$DObRootDevice?5?$CG?$CG?5Exten@FNODOBFM@
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAssert
  00067	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN12@DriveFilte@2:

; 714  : 
; 715  : 	switch (irpSp->MajorFunction)

  0006f	48 8b 44 24 40	 mov	 rax, QWORD PTR irpSp$[rsp]
  00074	8a 00		 mov	 al, BYTE PTR [rax]
  00076	88 44 24 4c	 mov	 BYTE PTR tv76[rsp], al
  0007a	80 7c 24 4c 03	 cmp	 BYTE PTR tv76[rsp], 3
  0007f	0f 82 a1 00 00
	00		 jb	 $LN7@DriveFilte@2
  00085	80 7c 24 4c 04	 cmp	 BYTE PTR tv76[rsp], 4
  0008a	76 13		 jbe	 SHORT $LN6@DriveFilte@2
  0008c	80 7c 24 4c 16	 cmp	 BYTE PTR tv76[rsp], 22
  00091	74 75		 je	 SHORT $LN2@DriveFilte@2
  00093	80 7c 24 4c 1b	 cmp	 BYTE PTR tv76[rsp], 27
  00098	74 50		 je	 SHORT $LN3@DriveFilte@2
  0009a	e9 87 00 00 00	 jmp	 $LN7@DriveFilte@2
$LN6@DriveFilte@2:

; 716  : 	{
; 717  : 	case IRP_MJ_READ:
; 718  : 	case IRP_MJ_WRITE:
; 719  : 		if (Extension->BootDrive)

  0009f	48 8b 44 24 30	 mov	 rax, QWORD PTR Extension$[rsp]
  000a4	83 b8 08 03 00
	00 00		 cmp	 DWORD PTR [rax+776], 0
  000ab	74 3b		 je	 SHORT $LN5@DriveFilte@2

; 720  : 		{
; 721  : 			status = EncryptedIoQueueAddIrp (&Extension->Queue, Irp);

  000ad	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Extension$[rsp]
  000b2	48 83 c1 50	 add	 rcx, 80			; 00000050H
  000b6	48 8b 54 24 68	 mov	 rdx, QWORD PTR Irp$[rsp]
  000bb	e8 00 00 00 00	 call	 EncryptedIoQueueAddIrp
  000c0	89 44 24 38	 mov	 DWORD PTR status$[rsp], eax

; 722  : 			
; 723  : 			if (status != STATUS_PENDING)

  000c4	81 7c 24 38 03
	01 00 00	 cmp	 DWORD PTR status$[rsp], 259 ; 00000103H
  000cc	74 11		 je	 SHORT $LN4@DriveFilte@2

; 724  : 				TCCompleteDiskIrp (Irp, status, 0);

  000ce	45 33 c0	 xor	 r8d, r8d
  000d1	8b 54 24 38	 mov	 edx, DWORD PTR status$[rsp]
  000d5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Irp$[rsp]
  000da	e8 00 00 00 00	 call	 TCCompleteDiskIrp
$LN4@DriveFilte@2:

; 725  : 
; 726  : 			return status;

  000df	8b 44 24 38	 mov	 eax, DWORD PTR status$[rsp]
  000e3	e9 c0 00 00 00	 jmp	 $LN9@DriveFilte@2
$LN5@DriveFilte@2:

; 727  : 		}
; 728  : 		break;

  000e8	eb 3c		 jmp	 SHORT $LN7@DriveFilte@2
$LN3@DriveFilte@2:

; 729  : 
; 730  : 	case IRP_MJ_PNP:
; 731  : 		return DispatchPnp (DeviceObject, Irp, Extension, irpSp);

  000ea	4c 8b 4c 24 40	 mov	 r9, QWORD PTR irpSp$[rsp]
  000ef	4c 8b 44 24 30	 mov	 r8, QWORD PTR Extension$[rsp]
  000f4	48 8b 54 24 68	 mov	 rdx, QWORD PTR Irp$[rsp]
  000f9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  000fe	e8 00 00 00 00	 call	 DispatchPnp
  00103	e9 a0 00 00 00	 jmp	 $LN9@DriveFilte@2
$LN2@DriveFilte@2:

; 732  : 
; 733  : 	case IRP_MJ_POWER:
; 734  : 		return DispatchPower (DeviceObject, Irp, Extension, irpSp);

  00108	4c 8b 4c 24 40	 mov	 r9, QWORD PTR irpSp$[rsp]
  0010d	4c 8b 44 24 30	 mov	 r8, QWORD PTR Extension$[rsp]
  00112	48 8b 54 24 68	 mov	 rdx, QWORD PTR Irp$[rsp]
  00117	48 8b 4c 24 60	 mov	 rcx, QWORD PTR DeviceObject$[rsp]
  0011c	e8 00 00 00 00	 call	 DispatchPower
  00121	e9 82 00 00 00	 jmp	 $LN9@DriveFilte@2
$LN7@DriveFilte@2:

; 735  : 	}
; 736  : 
; 737  : 	status = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00126	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Extension$[rsp]
  0012b	48 81 c1 f0 00
	00 00		 add	 rcx, 240		; 000000f0H
  00132	c7 44 24 20 78
	00 00 00	 mov	 DWORD PTR [rsp+32], 120	; 00000078H
  0013a	41 b9 e1 02 00
	00		 mov	 r9d, 737		; 000002e1H
  00140	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0EF@GDHJGIB@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  00147	48 8b 54 24 68	 mov	 rdx, QWORD PTR Irp$[rsp]
  0014c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAcquireRemoveLockEx
  00152	89 44 24 38	 mov	 DWORD PTR status$[rsp], eax

; 738  : 	if (!NT_SUCCESS (status))

  00156	83 7c 24 38 00	 cmp	 DWORD PTR status$[rsp], 0
  0015b	7d 13		 jge	 SHORT $LN1@DriveFilte@2

; 739  : 		return TCCompleteIrp (Irp, status, 0);

  0015d	45 33 c0	 xor	 r8d, r8d
  00160	8b 54 24 38	 mov	 edx, DWORD PTR status$[rsp]
  00164	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Irp$[rsp]
  00169	e8 00 00 00 00	 call	 TCCompleteIrp
  0016e	eb 38		 jmp	 SHORT $LN9@DriveFilte@2
$LN1@DriveFilte@2:

; 740  : 
; 741  : 	status = PassIrp (Extension->LowerDeviceObject, Irp);

  00170	48 8b 54 24 68	 mov	 rdx, QWORD PTR Irp$[rsp]
  00175	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Extension$[rsp]
  0017a	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0017e	e8 00 00 00 00	 call	 PassIrp
  00183	89 44 24 38	 mov	 DWORD PTR status$[rsp], eax

; 742  : 
; 743  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00187	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Extension$[rsp]
  0018c	48 81 c1 f0 00
	00 00		 add	 rcx, 240		; 000000f0H
  00193	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  00199	48 8b 54 24 68	 mov	 rdx, QWORD PTR Irp$[rsp]
  0019e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseRemoveLockEx

; 744  : 	return status;

  001a4	8b 44 24 38	 mov	 eax, DWORD PTR status$[rsp]
$LN9@DriveFilte@2:

; 745  : }

  001a8	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ac	c3		 ret	 0
DriveFilterDispatchIrp ENDP
END
