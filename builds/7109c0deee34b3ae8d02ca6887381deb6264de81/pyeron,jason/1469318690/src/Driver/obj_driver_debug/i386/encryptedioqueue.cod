; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\users\public\desktop\projects\ciphershed\src\driver\encryptedioqueue.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_IoMarkIrpPending@4
PUBLIC	??_C@_0EK@OJKOJEAN@c?3?2users?2public?2desktop?2projects@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CB@JMNJFHBF@STATUS_DEVICE_NOT_READY?5?5out?$DN?$CFd?6@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_EncryptedIoQueueAddIrp@8
EXTRN	__imp__KeSetEvent@12:PROC
EXTRN	__imp_@ExfInterlockedInsertTailList@12:PROC
EXTRN	__imp__IoAcquireRemoveLockEx@20:PROC
EXTRN	_DbgPrint:PROC
;	COMDAT ??_C@_0EK@OJKOJEAN@c?3?2users?2public?2desktop?2projects@FNODOBFM@
; File c:\users\public\desktop\projects\ciphershed\src\driver\encryptedioqueue.c
text$s	SEGMENT
??_C@_0EK@OJKOJEAN@c?3?2users?2public?2desktop?2projects@FNODOBFM@ DB 'c:'
	DB	'\users\public\desktop\projects\ciphershed\src\driver\encrypte'
	DB	'dioqueue.c', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CB@JMNJFHBF@STATUS_DEVICE_NOT_READY?5?5out?$DN?$CFd?6@FNODOBFM@
text$s	SEGMENT
??_C@_0CB@JMNJFHBF@STATUS_DEVICE_NOT_READY?5?5out?$DN?$CFd?6@FNODOBFM@ DB 'S'
	DB	'TATUS_DEVICE_NOT_READY  out=%d', 0aH, 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _EncryptedIoQueueAddIrp@8
_TEXT	SEGMENT
_status$ = -4						; size = 4
_queue$ = 8						; size = 4
_irp$ = 12						; size = 4
_EncryptedIoQueueAddIrp@8 PROC				; COMDAT

; 760  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 761  : 	NTSTATUS status;
; 762  : 
; 763  : 	InterlockedIncrement (&queue->OutstandingIoCount);

  00006	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  00009	05 80 01 00 00	 add	 eax, 384		; 00000180H
  0000e	b9 01 00 00 00	 mov	 ecx, 1
  00013	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx

; 764  : 	if (queue->StopPending)

  00017	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  0001a	83 ba c8 01 00
	00 00		 cmp	 DWORD PTR [edx+456], 0
  00021	74 20		 je	 SHORT $LN2@EncryptedI

; 765  : 	{
; 766  : 		Dump ("STATUS_DEVICE_NOT_READY  out=%d\n", queue->OutstandingIoCount);

  00023	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  00026	8b 88 80 01 00
	00		 mov	 ecx, DWORD PTR [eax+384]
  0002c	51		 push	 ecx
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@JMNJFHBF@STATUS_DEVICE_NOT_READY?5?5out?$DN?$CFd?6@FNODOBFM@
  00032	e8 00 00 00 00	 call	 _DbgPrint
  00037	83 c4 08	 add	 esp, 8

; 767  : 		status = STATUS_DEVICE_NOT_READY;

  0003a	c7 45 fc a3 00
	00 c0		 mov	 DWORD PTR _status$[ebp], -1073741661 ; c00000a3H

; 768  : 		goto err;

  00041	eb 6a		 jmp	 SHORT $err$28137
$LN2@EncryptedI:

; 769  : 	}
; 770  : 
; 771  : 	status = IoAcquireRemoveLock (&queue->RemoveLock, irp);

  00043	6a 58		 push	 88			; 00000058H
  00045	68 03 03 00 00	 push	 771			; 00000303H
  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@OJKOJEAN@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  0004f	8b 55 0c	 mov	 edx, DWORD PTR _irp$[ebp]
  00052	52		 push	 edx
  00053	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  00056	83 c0 70	 add	 eax, 112		; 00000070H
  00059	50		 push	 eax
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAcquireRemoveLockEx@20
  00060	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 772  : 	if (!NT_SUCCESS (status))

  00063	83 7d fc 00	 cmp	 DWORD PTR _status$[ebp], 0
  00067	7d 02		 jge	 SHORT $LN1@EncryptedI

; 773  : 		goto err;

  00069	eb 42		 jmp	 SHORT $err$28137
$LN1@EncryptedI:

; 774  : 
; 775  : #ifdef TC_TRACE_IO_QUEUE
; 776  : 	{
; 777  : 		PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (irp);
; 778  : 		Dump ("* %I64d [%I64d] %c len=%d out=%d\n", irpSp->MajorFunction == IRP_MJ_WRITE ? irpSp->Parameters.Write.ByteOffset : irpSp->Parameters.Read.ByteOffset, GetElapsedTime (&queue->LastPerformanceCounter), irpSp->MajorFunction == IRP_MJ_WRITE ? 'W' : 'R', irpSp->MajorFunction == IRP_MJ_WRITE ? irpSp->Parameters.Write.Length : irpSp->Parameters.Read.Length, queue->OutstandingIoCount);
; 779  : 	}
; 780  : #endif
; 781  : 
; 782  : 	IoMarkIrpPending (irp);

  0006b	8b 4d 0c	 mov	 ecx, DWORD PTR _irp$[ebp]
  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 _IoMarkIrpPending@4

; 783  : 
; 784  : 	ExInterlockedInsertTailList (&queue->MainThreadQueue, &irp->Tail.Overlay.ListEntry, &queue->MainThreadQueueLock);

  00074	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  00077	81 c2 d4 00 00
	00		 add	 edx, 212		; 000000d4H
  0007d	52		 push	 edx
  0007e	8b 55 0c	 mov	 edx, DWORD PTR _irp$[ebp]
  00081	83 c2 58	 add	 edx, 88			; 00000058H
  00084	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  00087	81 c1 cc 00 00
	00		 add	 ecx, 204		; 000000ccH
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExfInterlockedInsertTailList@12

; 785  : 	KeSetEvent (&queue->MainThreadQueueNotEmptyEvent, IO_DISK_INCREMENT, FALSE);

  00093	6a 00		 push	 0
  00095	6a 01		 push	 1
  00097	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  0009a	05 d8 00 00 00	 add	 eax, 216		; 000000d8H
  0009f	50		 push	 eax
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 786  : 	
; 787  : 	return STATUS_PENDING;

  000a6	b8 03 01 00 00	 mov	 eax, 259		; 00000103H
  000ab	eb 0c		 jmp	 SHORT $LN3@EncryptedI
$err$28137:

; 788  : 
; 789  : err:
; 790  : 	DecrementOutstandingIoCount (queue);

  000ad	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  000b0	51		 push	 ecx
  000b1	e8 00 00 00 00	 call	 _DecrementOutstandingIoCount@4

; 791  : 	return status;

  000b6	8b 45 fc	 mov	 eax, DWORD PTR _status$[ebp]
$LN3@EncryptedI:

; 792  : }

  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c2 08 00	 ret	 8
_EncryptedIoQueueAddIrp@8 ENDP
_TEXT	ENDS
PUBLIC	_IoGetCurrentIrpStackLocation@4
; Function compile flags: /Odtp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
;	COMDAT _IoMarkIrpPending@4
_TEXT	SEGMENT
tv67 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoMarkIrpPending@4 PROC				; COMDAT

; 23667: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 23668:     IoGetCurrentIrpStackLocation( (Irp) )->Control |= SL_PENDING_RETURNED;

  00006	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _IoGetCurrentIrpStackLocation@4
  0000f	83 c0 03	 add	 eax, 3
  00012	89 45 fc	 mov	 DWORD PTR tv67[ebp], eax
  00015	8b 4d fc	 mov	 ecx, DWORD PTR tv67[ebp]
  00018	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0001b	83 ca 01	 or	 edx, 1
  0001e	8b 45 fc	 mov	 eax, DWORD PTR tv67[ebp]
  00021	88 10		 mov	 BYTE PTR [eax], dl

; 23669: }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
_IoMarkIrpPending@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp__RtlAssert@16:PROC
;	COMDAT ??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
text$s	SEGMENT
??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ DB 'I'
	DB	'rp->CurrentLocation <= Irp->StackCount + 1', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@
text$s	SEGMENT
??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@ DB 'c'
	DB	':\winddk\7600.16385.1\inc\ddk\wdm.h', 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _IoGetCurrentIrpStackLocation@4
_TEXT	SEGMENT
tv74 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoGetCurrentIrpStackLocation@4 PROC			; COMDAT

; 23316: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 23317:     ASSERT(Irp->CurrentLocation <= Irp->StackCount + 1);

  00006	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00009	0f be 48 23	 movsx	 ecx, BYTE PTR [eax+35]
  0000d	8b 55 08	 mov	 edx, DWORD PTR _Irp$[ebp]
  00010	0f be 42 22	 movsx	 eax, BYTE PTR [edx+34]
  00014	83 c0 01	 add	 eax, 1
  00017	3b c8		 cmp	 ecx, eax
  00019	7e 20		 jle	 SHORT $LN3@IoGetCurre
  0001b	6a 00		 push	 0
  0001d	68 15 5b 00 00	 push	 23317			; 00005b15H
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
  00039	eb 07		 jmp	 SHORT $LN4@IoGetCurre
$LN3@IoGetCurre:
  0003b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
$LN4@IoGetCurre:

; 23318:     return Irp->Tail.Overlay.CurrentStackLocation;

  00042	8b 4d 08	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00045	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]

; 23319: }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
_IoGetCurrentIrpStackLocation@4 ENDP
; Function compile flags: /Odtp
; File c:\users\public\desktop\projects\ciphershed\src\driver\encryptedioqueue.c
_TEXT	ENDS
;	COMDAT _DecrementOutstandingIoCount@4
_TEXT	SEGMENT
_queue$ = 8						; size = 4
_DecrementOutstandingIoCount@4 PROC			; COMDAT

; 150  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 151  : 	if (InterlockedDecrement (&queue->OutstandingIoCount) == 0 && (queue->SuspendPending || queue->StopPending))

  00005	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  00008	05 80 01 00 00	 add	 eax, 384		; 00000180H
  0000d	83 c9 ff	 or	 ecx, -1
  00010	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00014	49		 dec	 ecx
  00015	75 2c		 jne	 SHORT $LN3@DecrementO
  00017	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  0001a	83 ba c4 01 00
	00 00		 cmp	 DWORD PTR [edx+452], 0
  00021	75 0c		 jne	 SHORT $LN1@DecrementO
  00023	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  00026	83 b8 c8 01 00
	00 00		 cmp	 DWORD PTR [eax+456], 0
  0002d	74 14		 je	 SHORT $LN3@DecrementO
$LN1@DecrementO:

; 152  : 		KeSetEvent (&queue->NoOutstandingIoEvent, IO_DISK_INCREMENT, FALSE);

  0002f	6a 00		 push	 0
  00031	6a 01		 push	 1
  00033	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  00036	81 c1 84 01 00
	00		 add	 ecx, 388		; 00000184H
  0003c	51		 push	 ecx
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
$LN3@DecrementO:

; 153  : }

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
_DecrementOutstandingIoCount@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@DPKEMNCN@?$CBqueue?9?$DOSuspended?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_EncryptedIoQueueHoldWhenIdle@12
EXTRN	__imp__KeClearEvent@4:PROC
EXTRN	_TCSleep@4:PROC
EXTRN	__imp__KeWaitForSingleObject@20:PROC
EXTRN	__allmul:PROC
;	COMDAT ??_C@_0BC@DPKEMNCN@?$CBqueue?9?$DOSuspended?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BC@DPKEMNCN@?$CBqueue?9?$DOSuspended?$AA@FNODOBFM@ DB '!queue->Sus'
	DB	'pended', 00H				;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _EncryptedIoQueueHoldWhenIdle@12
_TEXT	SEGMENT
tv82 = -24						; size = 4
tv71 = -20						; size = 4
_waitTimeout$28156 = -16				; size = 8
_status$ = -4						; size = 4
_queue$ = 8						; size = 4
_timeout$ = 12						; size = 8
_EncryptedIoQueueHoldWhenIdle@12 PROC			; COMDAT

; 796  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 18	 sub	 esp, 24			; 00000018H

; 797  : 	NTSTATUS status;
; 798  : 	ASSERT (!queue->Suspended);

  00008	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  0000b	83 b8 c0 01 00
	00 00		 cmp	 DWORD PTR [eax+448], 0
  00012	74 20		 je	 SHORT $LN11@EncryptedI@2
  00014	6a 00		 push	 0
  00016	68 1e 03 00 00	 push	 798			; 0000031eH
  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@OJKOJEAN@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@DPKEMNCN@?$CBqueue?9?$DOSuspended?$AA@FNODOBFM@
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  0002b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
  00032	eb 07		 jmp	 SHORT $LN12@EncryptedI@2
$LN11@EncryptedI@2:
  00034	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
$LN12@EncryptedI@2:

; 799  : 
; 800  : 	queue->SuspendPending = TRUE;

  0003b	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  0003e	c7 81 c4 01 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+452], 1
$LN8@EncryptedI@2:

; 801  : 	
; 802  : 	while (TRUE)

  00048	ba 01 00 00 00	 mov	 edx, 1
  0004d	85 d2		 test	 edx, edx
  0004f	0f 84 19 01 00
	00		 je	 $LN7@EncryptedI@2
$LN6@EncryptedI@2:

; 803  : 	{
; 804  : 		while (InterlockedExchangeAdd (&queue->OutstandingIoCount, 0) > 0)

  00055	33 c0		 xor	 eax, eax
  00057	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  0005a	81 c1 80 01 00
	00		 add	 ecx, 384		; 00000180H
  00060	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  00064	85 c0		 test	 eax, eax
  00066	0f 8e ac 00 00
	00		 jle	 $LN5@EncryptedI@2

; 805  : 		{
; 806  : 			LARGE_INTEGER waitTimeout;
; 807  : 
; 808  : 			waitTimeout.QuadPart = timeout * -10000;

  0006c	6a ff		 push	 -1
  0006e	68 f0 d8 ff ff	 push	 -10000			; ffffd8f0H
  00073	8b 55 10	 mov	 edx, DWORD PTR _timeout$[ebp+4]
  00076	52		 push	 edx
  00077	8b 45 0c	 mov	 eax, DWORD PTR _timeout$[ebp]
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 __allmul
  00080	89 45 f0	 mov	 DWORD PTR _waitTimeout$28156[ebp], eax
  00083	89 55 f4	 mov	 DWORD PTR _waitTimeout$28156[ebp+4], edx

; 809  : 			status = KeWaitForSingleObject (&queue->NoOutstandingIoEvent, Executive, KernelMode, FALSE, timeout != 0 ? &waitTimeout : NULL);

  00086	8b 4d 0c	 mov	 ecx, DWORD PTR _timeout$[ebp]
  00089	0b 4d 10	 or	 ecx, DWORD PTR _timeout$[ebp+4]
  0008c	74 08		 je	 SHORT $LN13@EncryptedI@2
  0008e	8d 55 f0	 lea	 edx, DWORD PTR _waitTimeout$28156[ebp]
  00091	89 55 e8	 mov	 DWORD PTR tv82[ebp], edx
  00094	eb 07		 jmp	 SHORT $LN14@EncryptedI@2
$LN13@EncryptedI@2:
  00096	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv82[ebp], 0
$LN14@EncryptedI@2:
  0009d	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  000a0	50		 push	 eax
  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	6a 00		 push	 0
  000a7	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  000aa	81 c1 84 01 00
	00		 add	 ecx, 388		; 00000184H
  000b0	51		 push	 ecx
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
  000b7	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 810  : 
; 811  : 			if (status == STATUS_TIMEOUT)

  000ba	81 7d fc 02 01
	00 00		 cmp	 DWORD PTR _status$[ebp], 258 ; 00000102H
  000c1	75 07		 jne	 SHORT $LN4@EncryptedI@2

; 812  : 				status = STATUS_UNSUCCESSFUL;

  000c3	c7 45 fc 01 00
	00 c0		 mov	 DWORD PTR _status$[ebp], -1073741823 ; c0000001H
$LN4@EncryptedI@2:

; 813  : 
; 814  : 			if (!NT_SUCCESS (status))

  000ca	83 7d fc 00	 cmp	 DWORD PTR _status$[ebp], 0
  000ce	7d 15		 jge	 SHORT $LN3@EncryptedI@2

; 815  : 			{
; 816  : 				queue->SuspendPending = FALSE;

  000d0	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  000d3	c7 82 c4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+452], 0

; 817  : 				return status;

  000dd	8b 45 fc	 mov	 eax, DWORD PTR _status$[ebp]
  000e0	e9 a5 00 00 00	 jmp	 $LN9@EncryptedI@2
$LN3@EncryptedI@2:

; 818  : 			}
; 819  : 
; 820  : 			TCSleep (1);

  000e5	6a 01		 push	 1
  000e7	e8 00 00 00 00	 call	 _TCSleep@4

; 821  : 			if (InterlockedExchangeAdd (&queue->OutstandingIoCount, 0) > 0)

  000ec	33 c0		 xor	 eax, eax
  000ee	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  000f1	81 c1 80 01 00
	00		 add	 ecx, 384		; 00000180H
  000f7	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  000fb	85 c0		 test	 eax, eax
  000fd	7e 14		 jle	 SHORT $LN2@EncryptedI@2

; 822  : 			{
; 823  : 				queue->SuspendPending = FALSE;

  000ff	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  00102	c7 82 c4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+452], 0

; 824  : 				return STATUS_UNSUCCESSFUL;

  0010c	b8 01 00 00 c0	 mov	 eax, -1073741823	; c0000001H
  00111	eb 77		 jmp	 SHORT $LN9@EncryptedI@2
$LN2@EncryptedI@2:

; 825  : 			}
; 826  : 		}

  00113	e9 3d ff ff ff	 jmp	 $LN6@EncryptedI@2
$LN5@EncryptedI@2:

; 827  : 
; 828  : 		KeClearEvent (&queue->QueueResumedEvent);

  00118	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  0011b	05 cc 01 00 00	 add	 eax, 460		; 000001ccH
  00120	50		 push	 eax
  00121	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeClearEvent@4

; 829  : 		queue->Suspended = TRUE;

  00127	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  0012a	c7 81 c0 01 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+448], 1

; 830  : 
; 831  : 		if (InterlockedExchangeAdd (&queue->OutstandingIoCount, 0) == 0)

  00134	33 d2		 xor	 edx, edx
  00136	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  00139	05 80 01 00 00	 add	 eax, 384		; 00000180H
  0013e	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  00142	85 d2		 test	 edx, edx
  00144	75 02		 jne	 SHORT $LN1@EncryptedI@2

; 832  : 			break;

  00146	eb 26		 jmp	 SHORT $LN7@EncryptedI@2
$LN1@EncryptedI@2:

; 833  : 
; 834  : 		queue->Suspended = FALSE;

  00148	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  0014b	c7 81 c0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+448], 0

; 835  : 		KeSetEvent (&queue->QueueResumedEvent, IO_DISK_INCREMENT, FALSE);

  00155	6a 00		 push	 0
  00157	6a 01		 push	 1
  00159	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  0015c	81 c2 cc 01 00
	00		 add	 edx, 460		; 000001ccH
  00162	52		 push	 edx
  00163	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 836  : 	}

  00169	e9 da fe ff ff	 jmp	 $LN8@EncryptedI@2
$LN7@EncryptedI@2:

; 837  : 
; 838  : 	queue->ReadAheadBufferValid = FALSE;

  0016e	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  00171	c7 80 50 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+336], 0

; 839  : 
; 840  : 	queue->SuspendPending = FALSE;

  0017b	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  0017e	c7 81 c4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+452], 0

; 841  : 	return STATUS_SUCCESS;

  00188	33 c0		 xor	 eax, eax
$LN9@EncryptedI@2:

; 842  : }

  0018a	8b e5		 mov	 esp, ebp
  0018c	5d		 pop	 ebp
  0018d	c2 0c 00	 ret	 12			; 0000000cH
_EncryptedIoQueueHoldWhenIdle@12 ENDP
_TEXT	ENDS
PUBLIC	_EncryptedIoQueueIsSuspended@4
; Function compile flags: /Odtp
;	COMDAT _EncryptedIoQueueIsSuspended@4
_TEXT	SEGMENT
_queue$ = 8						; size = 4
_EncryptedIoQueueIsSuspended@4 PROC			; COMDAT

; 846  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 847  : 	return queue->Suspended;

  00005	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  00008	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [eax+448]

; 848  : }

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
_EncryptedIoQueueIsSuspended@4 ENDP
_TEXT	ENDS
PUBLIC	_EncryptedIoQueueIsRunning@4
; Function compile flags: /Odtp
;	COMDAT _EncryptedIoQueueIsRunning@4
_TEXT	SEGMENT
_queue$ = 8						; size = 4
_EncryptedIoQueueIsRunning@4 PROC			; COMDAT

; 852  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 853  : 	return !queue->StopPending;

  00005	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  00008	8b 88 c8 01 00
	00		 mov	 ecx, DWORD PTR [eax+456]
  0000e	33 c0		 xor	 eax, eax
  00010	85 c9		 test	 ecx, ecx
  00012	0f 94 c0	 sete	 al

; 854  : }

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
_EncryptedIoQueueIsRunning@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@CDEEPNAM@queue?9?$DOSuspended?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_EncryptedIoQueueResumeFromHold@4
;	COMDAT ??_C@_0BB@CDEEPNAM@queue?9?$DOSuspended?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BB@CDEEPNAM@queue?9?$DOSuspended?$AA@FNODOBFM@ DB 'queue->Suspende'
	DB	'd', 00H					;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _EncryptedIoQueueResumeFromHold@4
_TEXT	SEGMENT
tv71 = -4						; size = 4
_queue$ = 8						; size = 4
_EncryptedIoQueueResumeFromHold@4 PROC			; COMDAT

; 858  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 859  : 	ASSERT (queue->Suspended);

  00006	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  00009	83 b8 c0 01 00
	00 00		 cmp	 DWORD PTR [eax+448], 0
  00010	75 20		 jne	 SHORT $LN3@EncryptedI@3
  00012	6a 00		 push	 0
  00014	68 5b 03 00 00	 push	 859			; 0000035bH
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@OJKOJEAN@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@CDEEPNAM@queue?9?$DOSuspended?$AA@FNODOBFM@
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
  00030	eb 07		 jmp	 SHORT $LN4@EncryptedI@3
$LN3@EncryptedI@3:
  00032	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
$LN4@EncryptedI@3:

; 860  : 	
; 861  : 	queue->Suspended = FALSE;

  00039	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  0003c	c7 81 c0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+448], 0

; 862  : 	KeSetEvent (&queue->QueueResumedEvent, IO_DISK_INCREMENT, FALSE);

  00046	6a 00		 push	 0
  00048	6a 01		 push	 1
  0004a	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  0004d	81 c2 cc 01 00
	00		 add	 edx, 460		; 000001ccH
  00053	52		 push	 edx
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 863  : 
; 864  : 	return STATUS_SUCCESS;

  0005a	33 c0		 xor	 eax, eax

; 865  : }

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
_EncryptedIoQueueResumeFromHold@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@IPONPJEA@Queue?5started?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_KeInitializeSpinLock@4
PUBLIC	_InitializeListHead@4
PUBLIC	_EncryptedIoQueueStart@4
EXTRN	__imp__ExFreePoolWithTag@8:PROC
EXTRN	_TCStopThread@8:PROC
EXTRN	_TCStartThread@12:PROC
EXTRN	__imp__ExAllocatePoolWithTag@12:PROC
EXTRN	__imp__KeInitializeEvent@12:PROC
EXTRN	__imp__KeInitializeMutex@8:PROC
;	COMDAT ??_C@_0P@IPONPJEA@Queue?5started?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0P@IPONPJEA@Queue?5started?6?$AA@FNODOBFM@ DB 'Queue started', 0aH, 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _EncryptedIoQueueStart@4
_TEXT	SEGMENT
_buffer$ = -12						; size = 4
_status$ = -8						; size = 4
_i$ = -4						; size = 4
_queue$ = 8						; size = 4
_EncryptedIoQueueStart@4 PROC				; COMDAT

; 869  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 870  : 	NTSTATUS status;
; 871  : 	EncryptedIoQueueBuffer *buffer;
; 872  : 	int i;
; 873  : 
; 874  : 	queue->StartPending = TRUE;

  00008	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  0000b	c7 80 b8 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+440], 1

; 875  : 	queue->ThreadExitRequested = FALSE;

  00015	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  00018	c7 81 bc 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+444], 0

; 876  : 
; 877  : 	queue->OutstandingIoCount = 0;

  00022	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  00025	c7 82 80 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+384], 0

; 878  : 	queue->IoThreadPendingRequestCount = 0;

  0002f	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  00032	c7 80 94 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+404], 0

; 879  : 
; 880  : 	queue->FirstPoolBuffer = NULL;

  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  0003f	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 881  : 	KeInitializeMutex (&queue->BufferPoolMutex, 0);

  00046	6a 00		 push	 0
  00048	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  0004b	83 c2 04	 add	 edx, 4
  0004e	52		 push	 edx
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeMutex@8

; 882  : 
; 883  : 	KeInitializeEvent (&queue->NoOutstandingIoEvent, SynchronizationEvent, FALSE);

  00055	6a 00		 push	 0
  00057	6a 01		 push	 1
  00059	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  0005c	05 84 01 00 00	 add	 eax, 388		; 00000184H
  00061	50		 push	 eax
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 884  : 	KeInitializeEvent (&queue->PoolBufferFreeEvent, SynchronizationEvent, FALSE);

  00068	6a 00		 push	 0
  0006a	6a 01		 push	 1
  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  0006f	81 c1 98 01 00
	00		 add	 ecx, 408		; 00000198H
  00075	51		 push	 ecx
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 885  : 	KeInitializeEvent (&queue->QueueResumedEvent, SynchronizationEvent, FALSE);

  0007c	6a 00		 push	 0
  0007e	6a 01		 push	 1
  00080	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  00083	81 c2 cc 01 00
	00		 add	 edx, 460		; 000001ccH
  00089	52		 push	 edx
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 886  : 
; 887  : 	queue->FragmentBufferA = TCalloc (TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE);

  00090	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00095	68 00 00 04 00	 push	 262144			; 00040000H
  0009a	6a 00		 push	 0
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  000a2	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  000a5	89 81 28 01 00
	00		 mov	 DWORD PTR [ecx+296], eax

; 888  : 	if (!queue->FragmentBufferA)

  000ab	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  000ae	83 ba 28 01 00
	00 00		 cmp	 DWORD PTR [edx+296], 0
  000b5	75 05		 jne	 SHORT $LN17@EncryptedI@4

; 889  : 		goto noMemory;

  000b7	e9 8e 02 00 00	 jmp	 $noMemory$28188
$LN17@EncryptedI@4:

; 890  : 
; 891  : 	queue->FragmentBufferB = TCalloc (TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE);

  000bc	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  000c1	68 00 00 04 00	 push	 262144			; 00040000H
  000c6	6a 00		 push	 0
  000c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  000ce	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  000d1	89 81 2c 01 00
	00		 mov	 DWORD PTR [ecx+300], eax

; 892  : 	if (!queue->FragmentBufferB)

  000d7	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  000da	83 ba 2c 01 00
	00 00		 cmp	 DWORD PTR [edx+300], 0
  000e1	75 05		 jne	 SHORT $LN16@EncryptedI@4

; 893  : 		goto noMemory;

  000e3	e9 62 02 00 00	 jmp	 $noMemory$28188
$LN16@EncryptedI@4:

; 894  : 
; 895  : 	KeInitializeEvent (&queue->FragmentBufferAFreeEvent, SynchronizationEvent, TRUE);

  000e8	6a 01		 push	 1
  000ea	6a 01		 push	 1
  000ec	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  000ef	05 30 01 00 00	 add	 eax, 304		; 00000130H
  000f4	50		 push	 eax
  000f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 896  : 	KeInitializeEvent (&queue->FragmentBufferBFreeEvent, SynchronizationEvent, TRUE);

  000fb	6a 01		 push	 1
  000fd	6a 01		 push	 1
  000ff	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  00102	81 c1 40 01 00
	00		 add	 ecx, 320		; 00000140H
  00108	51		 push	 ecx
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 897  : 
; 898  : 	queue->ReadAheadBufferValid = FALSE;

  0010f	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  00112	c7 82 50 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+336], 0

; 899  : 	queue->ReadAheadBuffer = TCalloc (TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE);

  0011c	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00121	68 00 00 04 00	 push	 262144			; 00040000H
  00126	6a 00		 push	 0
  00128	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0012e	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  00131	89 81 74 01 00
	00		 mov	 DWORD PTR [ecx+372], eax

; 900  : 	if (!queue->ReadAheadBuffer)

  00137	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  0013a	83 ba 74 01 00
	00 00		 cmp	 DWORD PTR [edx+372], 0
  00141	75 05		 jne	 SHORT $LN15@EncryptedI@4

; 901  : 		goto noMemory;

  00143	e9 02 02 00 00	 jmp	 $noMemory$28188
$LN15@EncryptedI@4:

; 902  : 
; 903  : 	// Preallocate buffers
; 904  : 	for (i = 0; i < TC_ENC_IO_QUEUE_PREALLOCATED_IO_REQUEST_COUNT; ++i)

  00148	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0014f	eb 09		 jmp	 SHORT $LN14@EncryptedI@4
$LN13@EncryptedI@4:
  00151	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00154	83 c0 01	 add	 eax, 1
  00157	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN14@EncryptedI@4:
  0015a	83 7d fc 10	 cmp	 DWORD PTR _i$[ebp], 16	; 00000010H
  0015e	7d 30		 jge	 SHORT $LN12@EncryptedI@4

; 905  : 	{
; 906  : 		if (i < TC_ENC_IO_QUEUE_PREALLOCATED_ITEM_COUNT && !GetPoolBuffer (queue, sizeof (EncryptedIoQueueItem)))

  00160	83 7d fc 08	 cmp	 DWORD PTR _i$[ebp], 8
  00164	7d 14		 jge	 SHORT $LN11@EncryptedI@4
  00166	6a 20		 push	 32			; 00000020H
  00168	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  0016b	51		 push	 ecx
  0016c	e8 00 00 00 00	 call	 _GetPoolBuffer@8
  00171	85 c0		 test	 eax, eax
  00173	75 05		 jne	 SHORT $LN11@EncryptedI@4

; 907  : 			goto noMemory;

  00175	e9 d0 01 00 00	 jmp	 $noMemory$28188
$LN11@EncryptedI@4:

; 908  : 
; 909  : 		if (!GetPoolBuffer (queue, sizeof (EncryptedIoRequest)))

  0017a	6a 40		 push	 64			; 00000040H
  0017c	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  0017f	52		 push	 edx
  00180	e8 00 00 00 00	 call	 _GetPoolBuffer@8
  00185	85 c0		 test	 eax, eax
  00187	75 05		 jne	 SHORT $LN10@EncryptedI@4

; 910  : 			goto noMemory;

  00189	e9 bc 01 00 00	 jmp	 $noMemory$28188
$LN10@EncryptedI@4:

; 911  : 	}

  0018e	eb c1		 jmp	 SHORT $LN13@EncryptedI@4
$LN12@EncryptedI@4:

; 912  : 
; 913  : 	for (buffer = queue->FirstPoolBuffer; buffer != NULL; buffer = buffer->NextBuffer)

  00190	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  00193	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00196	89 4d f4	 mov	 DWORD PTR _buffer$[ebp], ecx
  00199	eb 08		 jmp	 SHORT $LN9@EncryptedI@4
$LN8@EncryptedI@4:
  0019b	8b 55 f4	 mov	 edx, DWORD PTR _buffer$[ebp]
  0019e	8b 02		 mov	 eax, DWORD PTR [edx]
  001a0	89 45 f4	 mov	 DWORD PTR _buffer$[ebp], eax
$LN9@EncryptedI@4:
  001a3	83 7d f4 00	 cmp	 DWORD PTR _buffer$[ebp], 0
  001a7	74 0c		 je	 SHORT $LN7@EncryptedI@4

; 914  : 	{
; 915  : 		buffer->InUse = FALSE;

  001a9	8b 4d f4	 mov	 ecx, DWORD PTR _buffer$[ebp]
  001ac	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 916  : 	}

  001b3	eb e6		 jmp	 SHORT $LN8@EncryptedI@4
$LN7@EncryptedI@4:

; 917  : 
; 918  : 	// Main thread
; 919  : 	InitializeListHead (&queue->MainThreadQueue);

  001b5	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  001b8	81 c2 cc 00 00
	00		 add	 edx, 204		; 000000ccH
  001be	52		 push	 edx
  001bf	e8 00 00 00 00	 call	 _InitializeListHead@4

; 920  : 	KeInitializeSpinLock (&queue->MainThreadQueueLock);

  001c4	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  001c7	05 d4 00 00 00	 add	 eax, 212		; 000000d4H
  001cc	50		 push	 eax
  001cd	e8 00 00 00 00	 call	 _KeInitializeSpinLock@4

; 921  : 	KeInitializeEvent (&queue->MainThreadQueueNotEmptyEvent, SynchronizationEvent, FALSE);

  001d2	6a 00		 push	 0
  001d4	6a 01		 push	 1
  001d6	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  001d9	81 c1 d8 00 00
	00		 add	 ecx, 216		; 000000d8H
  001df	51		 push	 ecx
  001e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 922  : 
; 923  : 	status = TCStartThread (MainThreadProc, queue, &queue->MainThread);

  001e6	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  001e9	81 c2 c8 00 00
	00		 add	 edx, 200		; 000000c8H
  001ef	52		 push	 edx
  001f0	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  001f3	50		 push	 eax
  001f4	68 00 00 00 00	 push	 OFFSET _MainThreadProc@4
  001f9	e8 00 00 00 00	 call	 _TCStartThread@12
  001fe	89 45 f8	 mov	 DWORD PTR _status$[ebp], eax

; 924  : 	if (!NT_SUCCESS (status))

  00201	83 7d f8 00	 cmp	 DWORD PTR _status$[ebp], 0
  00205	7d 05		 jge	 SHORT $LN6@EncryptedI@4

; 925  : 		goto err;

  00207	e9 45 01 00 00	 jmp	 $err$28206
$LN6@EncryptedI@4:

; 926  : 
; 927  : 	// IO thread
; 928  : 	InitializeListHead (&queue->IoThreadQueue);

  0020c	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  0020f	81 c1 ec 00 00
	00		 add	 ecx, 236		; 000000ecH
  00215	51		 push	 ecx
  00216	e8 00 00 00 00	 call	 _InitializeListHead@4

; 929  : 	KeInitializeSpinLock (&queue->IoThreadQueueLock);

  0021b	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  0021e	81 c2 f4 00 00
	00		 add	 edx, 244		; 000000f4H
  00224	52		 push	 edx
  00225	e8 00 00 00 00	 call	 _KeInitializeSpinLock@4

; 930  : 	KeInitializeEvent (&queue->IoThreadQueueNotEmptyEvent, SynchronizationEvent, FALSE);

  0022a	6a 00		 push	 0
  0022c	6a 01		 push	 1
  0022e	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  00231	05 f8 00 00 00	 add	 eax, 248		; 000000f8H
  00236	50		 push	 eax
  00237	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 931  : 
; 932  : 	status = TCStartThread (IoThreadProc, queue, &queue->IoThread);

  0023d	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  00240	81 c1 e8 00 00
	00		 add	 ecx, 232		; 000000e8H
  00246	51		 push	 ecx
  00247	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  0024a	52		 push	 edx
  0024b	68 00 00 00 00	 push	 OFFSET _IoThreadProc@4
  00250	e8 00 00 00 00	 call	 _TCStartThread@12
  00255	89 45 f8	 mov	 DWORD PTR _status$[ebp], eax

; 933  : 	if (!NT_SUCCESS (status))

  00258	83 7d f8 00	 cmp	 DWORD PTR _status$[ebp], 0
  0025c	7d 2b		 jge	 SHORT $LN5@EncryptedI@4

; 934  : 	{
; 935  : 		queue->ThreadExitRequested = TRUE;

  0025e	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  00261	c7 80 bc 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+444], 1

; 936  : 		TCStopThread (queue->MainThread, &queue->MainThreadQueueNotEmptyEvent);

  0026b	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  0026e	81 c1 d8 00 00
	00		 add	 ecx, 216		; 000000d8H
  00274	51		 push	 ecx
  00275	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  00278	8b 82 c8 00 00
	00		 mov	 eax, DWORD PTR [edx+200]
  0027e	50		 push	 eax
  0027f	e8 00 00 00 00	 call	 _TCStopThread@8

; 937  : 		goto err;

  00284	e9 c8 00 00 00	 jmp	 $err$28206
$LN5@EncryptedI@4:

; 938  : 	}
; 939  : 
; 940  : 	// Completion thread
; 941  : 	InitializeListHead (&queue->CompletionThreadQueue);

  00289	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  0028c	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  00292	51		 push	 ecx
  00293	e8 00 00 00 00	 call	 _InitializeListHead@4

; 942  : 	KeInitializeSpinLock (&queue->CompletionThreadQueueLock);

  00298	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  0029b	81 c2 14 01 00
	00		 add	 edx, 276		; 00000114H
  002a1	52		 push	 edx
  002a2	e8 00 00 00 00	 call	 _KeInitializeSpinLock@4

; 943  : 	KeInitializeEvent (&queue->CompletionThreadQueueNotEmptyEvent, SynchronizationEvent, FALSE);

  002a7	6a 00		 push	 0
  002a9	6a 01		 push	 1
  002ab	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  002ae	05 18 01 00 00	 add	 eax, 280		; 00000118H
  002b3	50		 push	 eax
  002b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 944  : 
; 945  : 	status = TCStartThread (CompletionThreadProc, queue, &queue->CompletionThread);

  002ba	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  002bd	81 c1 08 01 00
	00		 add	 ecx, 264		; 00000108H
  002c3	51		 push	 ecx
  002c4	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  002c7	52		 push	 edx
  002c8	68 00 00 00 00	 push	 OFFSET _CompletionThreadProc@4
  002cd	e8 00 00 00 00	 call	 _TCStartThread@12
  002d2	89 45 f8	 mov	 DWORD PTR _status$[ebp], eax

; 946  : 	if (!NT_SUCCESS (status))

  002d5	83 7d f8 00	 cmp	 DWORD PTR _status$[ebp], 0
  002d9	7d 41		 jge	 SHORT $LN4@EncryptedI@4

; 947  : 	{
; 948  : 		queue->ThreadExitRequested = TRUE;

  002db	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  002de	c7 80 bc 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+444], 1

; 949  : 		TCStopThread (queue->MainThread, &queue->MainThreadQueueNotEmptyEvent);

  002e8	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  002eb	81 c1 d8 00 00
	00		 add	 ecx, 216		; 000000d8H
  002f1	51		 push	 ecx
  002f2	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  002f5	8b 82 c8 00 00
	00		 mov	 eax, DWORD PTR [edx+200]
  002fb	50		 push	 eax
  002fc	e8 00 00 00 00	 call	 _TCStopThread@8

; 950  : 		TCStopThread (queue->IoThread, &queue->IoThreadQueueNotEmptyEvent);

  00301	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  00304	81 c1 f8 00 00
	00		 add	 ecx, 248		; 000000f8H
  0030a	51		 push	 ecx
  0030b	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  0030e	8b 82 e8 00 00
	00		 mov	 eax, DWORD PTR [edx+232]
  00314	50		 push	 eax
  00315	e8 00 00 00 00	 call	 _TCStopThread@8

; 951  : 		goto err;

  0031a	eb 35		 jmp	 SHORT $err$28206
$LN4@EncryptedI@4:

; 952  : 	}
; 953  : 
; 954  : #ifdef TC_TRACE_IO_QUEUE
; 955  : 	GetElapsedTimeInit (&queue->LastPerformanceCounter);
; 956  : #endif
; 957  : 
; 958  : 	queue->StopPending = FALSE;

  0031c	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  0031f	c7 81 c8 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+456], 0

; 959  : 	queue->StartPending = FALSE;

  00329	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  0032c	c7 82 b8 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+440], 0

; 960  : 
; 961  : 	Dump ("Queue started\n");

  00336	68 00 00 00 00	 push	 OFFSET ??_C@_0P@IPONPJEA@Queue?5started?6?$AA@FNODOBFM@
  0033b	e8 00 00 00 00	 call	 _DbgPrint
  00340	83 c4 04	 add	 esp, 4

; 962  : 	return STATUS_SUCCESS;

  00343	33 c0		 xor	 eax, eax
  00345	e9 83 00 00 00	 jmp	 $LN18@EncryptedI@4
$noMemory$28188:

; 963  : 
; 964  : noMemory:
; 965  : 	status = STATUS_INSUFFICIENT_RESOURCES;

  0034a	c7 45 f8 9a 00
	00 c0		 mov	 DWORD PTR _status$[ebp], -1073741670 ; c000009aH
$err$28206:

; 966  : 
; 967  : err:
; 968  : 	if (queue->FragmentBufferA)

  00351	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  00354	83 b8 28 01 00
	00 00		 cmp	 DWORD PTR [eax+296], 0
  0035b	74 15		 je	 SHORT $LN3@EncryptedI@4

; 969  : 		TCfree (queue->FragmentBufferA);

  0035d	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00362	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  00365	8b 91 28 01 00
	00		 mov	 edx, DWORD PTR [ecx+296]
  0036b	52		 push	 edx
  0036c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN3@EncryptedI@4:

; 970  : 	if (queue->FragmentBufferB)

  00372	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  00375	83 b8 2c 01 00
	00 00		 cmp	 DWORD PTR [eax+300], 0
  0037c	74 15		 je	 SHORT $LN2@EncryptedI@4

; 971  : 		TCfree (queue->FragmentBufferB);

  0037e	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00383	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  00386	8b 91 2c 01 00
	00		 mov	 edx, DWORD PTR [ecx+300]
  0038c	52		 push	 edx
  0038d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN2@EncryptedI@4:

; 972  : 	if (queue->ReadAheadBuffer)

  00393	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  00396	83 b8 74 01 00
	00 00		 cmp	 DWORD PTR [eax+372], 0
  0039d	74 15		 je	 SHORT $LN1@EncryptedI@4

; 973  : 		TCfree (queue->ReadAheadBuffer);

  0039f	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  003a4	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  003a7	8b 91 74 01 00
	00		 mov	 edx, DWORD PTR [ecx+372]
  003ad	52		 push	 edx
  003ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN1@EncryptedI@4:

; 974  : 
; 975  : 	FreePoolBuffers (queue);

  003b4	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  003b7	50		 push	 eax
  003b8	e8 00 00 00 00	 call	 _FreePoolBuffers@4

; 976  : 
; 977  : 	queue->StartPending = FALSE;

  003bd	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  003c0	c7 81 b8 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+440], 0

; 978  : 	return status;

  003ca	8b 45 f8	 mov	 eax, DWORD PTR _status$[ebp]
$LN18@EncryptedI@4:

; 979  : }

  003cd	8b e5		 mov	 esp, ebp
  003cf	5d		 pop	 ebp
  003d0	c2 04 00	 ret	 4
_EncryptedIoQueueStart@4 ENDP
; Function compile flags: /Odtp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT _InitializeListHead@4
_TEXT	SEGMENT
_ListHead$ = 8						; size = 4
_InitializeListHead@4 PROC				; COMDAT

; 7550 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 7551 :     ListHead->Flink = ListHead->Blink = ListHead;

  00005	8b 45 08	 mov	 eax, DWORD PTR _ListHead$[ebp]
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _ListHead$[ebp]
  0000b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0000e	8b 55 08	 mov	 edx, DWORD PTR _ListHead$[ebp]
  00011	8b 45 08	 mov	 eax, DWORD PTR _ListHead$[ebp]
  00014	89 02		 mov	 DWORD PTR [edx], eax

; 7552 : }

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
_InitializeListHead@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _KeInitializeSpinLock@4
_TEXT	SEGMENT
_SpinLock$ = 8						; size = 4
_KeInitializeSpinLock@4 PROC				; COMDAT

; 15095: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 15096: 
; 15097:     *SpinLock = 0;

  00005	8b 45 08	 mov	 eax, DWORD PTR _SpinLock$[ebp]
  00008	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 15098:     return;
; 15099: }

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
_KeInitializeSpinLock@4 ENDP
; Function compile flags: /Odtp
; File c:\users\public\desktop\projects\ciphershed\src\driver\encryptedioqueue.c
_TEXT	ENDS
;	COMDAT _GetPoolBuffer@8
_TEXT	SEGMENT
_newBuffer$27758 = -16					; size = 4
_buffer$ = -12						; size = 4
_requestedSizePresentInPool$ = -8			; size = 4
_bufferAddress$ = -4					; size = 4
_queue$ = 8						; size = 4
_requestedSize$ = 12					; size = 4
_GetPoolBuffer@8 PROC					; COMDAT

; 35   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 10	 sub	 esp, 16			; 00000010H

; 36   : 	EncryptedIoQueueBuffer *buffer;
; 37   : 	void *bufferAddress = NULL;

  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _bufferAddress$[ebp], 0

; 38   : 	BOOL requestedSizePresentInPool = FALSE;

  0000f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _requestedSizePresentInPool$[ebp], 0
$LN17@GetPoolBuf:

; 39   : 
; 40   : 	while (TRUE)

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	85 c0		 test	 eax, eax
  0001d	0f 84 4f 01 00
	00		 je	 $LN16@GetPoolBuf

; 41   : 	{
; 42   : 		AcquireBufferPoolMutex (queue);

  00023	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 _AcquireBufferPoolMutex@4

; 43   : 
; 44   : 		for (buffer = queue->FirstPoolBuffer; ; buffer = buffer->NextBuffer)

  0002c	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  0002f	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00032	89 45 f4	 mov	 DWORD PTR _buffer$[ebp], eax
  00035	eb 08		 jmp	 SHORT $LN15@GetPoolBuf
$LN14@GetPoolBuf:
  00037	8b 4d f4	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0003a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003c	89 55 f4	 mov	 DWORD PTR _buffer$[ebp], edx
$LN15@GetPoolBuf:

; 45   : 		{
; 46   : 			if (buffer && buffer->Size == requestedSize)

  0003f	83 7d f4 00	 cmp	 DWORD PTR _buffer$[ebp], 0
  00043	74 33		 je	 SHORT $LN12@GetPoolBuf
  00045	8b 45 f4	 mov	 eax, DWORD PTR _buffer$[ebp]
  00048	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004b	3b 4d 0c	 cmp	 ecx, DWORD PTR _requestedSize$[ebp]
  0004e	75 28		 jne	 SHORT $LN12@GetPoolBuf

; 47   : 			{
; 48   : 				requestedSizePresentInPool = TRUE;

  00050	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _requestedSizePresentInPool$[ebp], 1

; 49   : 
; 50   : 				if (!buffer->InUse)

  00057	8b 55 f4	 mov	 edx, DWORD PTR _buffer$[ebp]
  0005a	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  0005e	75 18		 jne	 SHORT $LN12@GetPoolBuf

; 51   : 				{
; 52   : 					// Reuse a free buffer
; 53   : 					buffer->InUse = TRUE;

  00060	8b 45 f4	 mov	 eax, DWORD PTR _buffer$[ebp]
  00063	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [eax+12], 1

; 54   : 					bufferAddress = buffer->Address;

  0006a	8b 4d f4	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0006d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00070	89 55 fc	 mov	 DWORD PTR _bufferAddress$[ebp], edx

; 55   : 					break;

  00073	e9 ba 00 00 00	 jmp	 $LN13@GetPoolBuf
$LN12@GetPoolBuf:

; 56   : 				}
; 57   : 			}
; 58   : 
; 59   : 			if (!buffer || !buffer->NextBuffer)

  00078	83 7d f4 00	 cmp	 DWORD PTR _buffer$[ebp], 0
  0007c	74 0c		 je	 SHORT $LN9@GetPoolBuf
  0007e	8b 45 f4	 mov	 eax, DWORD PTR _buffer$[ebp]
  00081	83 38 00	 cmp	 DWORD PTR [eax], 0
  00084	0f 85 a3 00 00
	00		 jne	 $LN10@GetPoolBuf
$LN9@GetPoolBuf:

; 60   : 			{
; 61   : 				EncryptedIoQueueBuffer *newBuffer;
; 62   : 
; 63   : 				if (requestedSizePresentInPool && !queue->StartPending)

  0008a	83 7d f8 00	 cmp	 DWORD PTR _requestedSizePresentInPool$[ebp], 0
  0008e	74 11		 je	 SHORT $LN8@GetPoolBuf
  00090	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  00093	83 b9 b8 01 00
	00 00		 cmp	 DWORD PTR [ecx+440], 0
  0009a	75 05		 jne	 SHORT $LN8@GetPoolBuf

; 64   : 					break;

  0009c	e9 91 00 00 00	 jmp	 $LN13@GetPoolBuf
$LN8@GetPoolBuf:

; 65   : 
; 66   : 				// Allocate a new buffer
; 67   : 				newBuffer = TCalloc (sizeof (EncryptedIoQueueBuffer));

  000a1	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  000a6	6a 10		 push	 16			; 00000010H
  000a8	6a 00		 push	 0
  000aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  000b0	89 45 f0	 mov	 DWORD PTR _newBuffer$27758[ebp], eax

; 68   : 				if (!newBuffer)

  000b3	83 7d f0 00	 cmp	 DWORD PTR _newBuffer$27758[ebp], 0
  000b7	75 09		 jne	 SHORT $LN7@GetPoolBuf

; 69   : 				{
; 70   : 					bufferAddress = NULL;

  000b9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _bufferAddress$[ebp], 0

; 71   : 					break;

  000c0	eb 70		 jmp	 SHORT $LN13@GetPoolBuf
$LN7@GetPoolBuf:

; 72   : 				}
; 73   : 
; 74   : 				bufferAddress = TCalloc (requestedSize);

  000c2	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  000c7	8b 55 0c	 mov	 edx, DWORD PTR _requestedSize$[ebp]
  000ca	52		 push	 edx
  000cb	6a 00		 push	 0
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  000d3	89 45 fc	 mov	 DWORD PTR _bufferAddress$[ebp], eax

; 75   : 				if (bufferAddress)

  000d6	83 7d fc 00	 cmp	 DWORD PTR _bufferAddress$[ebp], 0
  000da	74 40		 je	 SHORT $LN6@GetPoolBuf

; 76   : 				{
; 77   : 					newBuffer->NextBuffer = NULL;

  000dc	8b 45 f0	 mov	 eax, DWORD PTR _newBuffer$27758[ebp]
  000df	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 78   : 					newBuffer->Address = bufferAddress;

  000e5	8b 4d f0	 mov	 ecx, DWORD PTR _newBuffer$27758[ebp]
  000e8	8b 55 fc	 mov	 edx, DWORD PTR _bufferAddress$[ebp]
  000eb	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 79   : 					newBuffer->Size = requestedSize;

  000ee	8b 45 f0	 mov	 eax, DWORD PTR _newBuffer$27758[ebp]
  000f1	8b 4d 0c	 mov	 ecx, DWORD PTR _requestedSize$[ebp]
  000f4	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 80   : 					newBuffer->InUse = TRUE;

  000f7	8b 55 f0	 mov	 edx, DWORD PTR _newBuffer$27758[ebp]
  000fa	c7 42 0c 01 00
	00 00		 mov	 DWORD PTR [edx+12], 1

; 81   : 
; 82   : 					if (!buffer)

  00101	83 7d f4 00	 cmp	 DWORD PTR _buffer$[ebp], 0
  00105	75 0b		 jne	 SHORT $LN5@GetPoolBuf

; 83   : 						queue->FirstPoolBuffer = newBuffer;

  00107	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  0010a	8b 4d f0	 mov	 ecx, DWORD PTR _newBuffer$27758[ebp]
  0010d	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 84   : 					else

  00110	eb 08		 jmp	 SHORT $LN4@GetPoolBuf
$LN5@GetPoolBuf:

; 85   : 						buffer->NextBuffer = newBuffer;

  00112	8b 55 f4	 mov	 edx, DWORD PTR _buffer$[ebp]
  00115	8b 45 f0	 mov	 eax, DWORD PTR _newBuffer$27758[ebp]
  00118	89 02		 mov	 DWORD PTR [edx], eax
$LN4@GetPoolBuf:

; 86   : 				}
; 87   : 				else

  0011a	eb 0f		 jmp	 SHORT $LN3@GetPoolBuf
$LN6@GetPoolBuf:

; 88   : 					TCfree (newBuffer);

  0011c	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00121	8b 4d f0	 mov	 ecx, DWORD PTR _newBuffer$27758[ebp]
  00124	51		 push	 ecx
  00125	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN3@GetPoolBuf:

; 89   : 
; 90   : 				break;

  0012b	eb 05		 jmp	 SHORT $LN13@GetPoolBuf
$LN10@GetPoolBuf:

; 91   : 			}
; 92   : 		}

  0012d	e9 05 ff ff ff	 jmp	 $LN14@GetPoolBuf
$LN13@GetPoolBuf:

; 93   : 
; 94   : 		ReleaseBufferPoolMutex (queue);

  00132	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  00135	52		 push	 edx
  00136	e8 00 00 00 00	 call	 _ReleaseBufferPoolMutex@4

; 95   : 
; 96   : 		if (bufferAddress || !requestedSizePresentInPool || queue->StartPending)

  0013b	83 7d fc 00	 cmp	 DWORD PTR _bufferAddress$[ebp], 0
  0013f	75 12		 jne	 SHORT $LN1@GetPoolBuf
  00141	83 7d f8 00	 cmp	 DWORD PTR _requestedSizePresentInPool$[ebp], 0
  00145	74 0c		 je	 SHORT $LN1@GetPoolBuf
  00147	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  0014a	83 b8 b8 01 00
	00 00		 cmp	 DWORD PTR [eax+440], 0
  00151	74 02		 je	 SHORT $LN2@GetPoolBuf
$LN1@GetPoolBuf:

; 97   : 			break;

  00153	eb 1d		 jmp	 SHORT $LN16@GetPoolBuf
$LN2@GetPoolBuf:

; 98   : 
; 99   : 		KeWaitForSingleObject (&queue->PoolBufferFreeEvent, Executive, KernelMode, FALSE, NULL);

  00155	6a 00		 push	 0
  00157	6a 00		 push	 0
  00159	6a 00		 push	 0
  0015b	6a 00		 push	 0
  0015d	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  00160	81 c1 98 01 00
	00		 add	 ecx, 408		; 00000198H
  00166	51		 push	 ecx
  00167	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 100  : 	}

  0016d	e9 a4 fe ff ff	 jmp	 $LN17@GetPoolBuf
$LN16@GetPoolBuf:

; 101  : 
; 102  : 	return bufferAddress;

  00172	8b 45 fc	 mov	 eax, DWORD PTR _bufferAddress$[ebp]

; 103  : }

  00175	8b e5		 mov	 esp, ebp
  00177	5d		 pop	 ebp
  00178	c2 08 00	 ret	 8
_GetPoolBuffer@8 ENDP
_TEXT	ENDS
EXTRN	__imp__KeBugCheckEx@20:PROC
; Function compile flags: /Odtp
;	COMDAT _AcquireBufferPoolMutex@4
_TEXT	SEGMENT
_status$ = -4						; size = 4
_queue$ = 8						; size = 4
_AcquireBufferPoolMutex@4 PROC				; COMDAT

; 19   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 20   : 	NTSTATUS status;
; 21   : 
; 22   : 	status = KeWaitForMutexObject (&queue->BufferPoolMutex, Executive, KernelMode, FALSE, NULL);

  00006	6a 00		 push	 0
  00008	6a 00		 push	 0
  0000a	6a 00		 push	 0
  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  00011	83 c0 04	 add	 eax, 4
  00014	50		 push	 eax
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
  0001b	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 23   : 	if (!NT_SUCCESS (status))

  0001e	83 7d fc 00	 cmp	 DWORD PTR _status$[ebp], 0
  00022	7d 15		 jge	 SHORT $LN3@AcquireBuf

; 24   : 		TC_BUG_CHECK (status);

  00024	68 43 54 00 00	 push	 21571			; 00005443H
  00029	6a 00		 push	 0
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _status$[ebp]
  0002e	51		 push	 ecx
  0002f	6a 18		 push	 24			; 00000018H
  00031	6a 29		 push	 41			; 00000029H
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN3@AcquireBuf:

; 25   : }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
_AcquireBufferPoolMutex@4 ENDP
_TEXT	ENDS
EXTRN	__imp__KeReleaseMutex@8:PROC
; Function compile flags: /Odtp
;	COMDAT _ReleaseBufferPoolMutex@4
_TEXT	SEGMENT
_queue$ = 8						; size = 4
_ReleaseBufferPoolMutex@4 PROC				; COMDAT

; 29   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 30   : 	KeReleaseMutex (&queue->BufferPoolMutex, FALSE);

  00005	6a 00		 push	 0
  00007	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	50		 push	 eax
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeReleaseMutex@8

; 31   : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
_ReleaseBufferPoolMutex@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@COCFEEEN@?$CBbuffer?9?$DOInUse?5?$HM?$HM?5queue?9?$DOStartPe@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0CG@COCFEEEN@?$CBbuffer?9?$DOInUse?5?$HM?$HM?5queue?9?$DOStartPe@FNODOBFM@
text$s	SEGMENT
??_C@_0CG@COCFEEEN@?$CBbuffer?9?$DOInUse?5?$HM?$HM?5queue?9?$DOStartPe@FNODOBFM@ DB '!'
	DB	'buffer->InUse || queue->StartPending', 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _FreePoolBuffers@4
_TEXT	SEGMENT
tv76 = -12						; size = 4
_nextBuffer$27797 = -8					; size = 4
_buffer$ = -4						; size = 4
_queue$ = 8						; size = 4
_FreePoolBuffers@4 PROC					; COMDAT

; 128  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 129  : 	EncryptedIoQueueBuffer *buffer;
; 130  : 	AcquireBufferPoolMutex (queue);

  00008	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _AcquireBufferPoolMutex@4

; 131  : 
; 132  : 	for (buffer = queue->FirstPoolBuffer; buffer != NULL; )

  00011	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  00014	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00017	89 55 fc	 mov	 DWORD PTR _buffer$[ebp], edx
$LN2@FreePoolBu:
  0001a	83 7d fc 00	 cmp	 DWORD PTR _buffer$[ebp], 0
  0001e	74 6d		 je	 SHORT $LN1@FreePoolBu

; 133  : 	{
; 134  : 		EncryptedIoQueueBuffer *nextBuffer = buffer->NextBuffer;

  00020	8b 45 fc	 mov	 eax, DWORD PTR _buffer$[ebp]
  00023	8b 08		 mov	 ecx, DWORD PTR [eax]
  00025	89 4d f8	 mov	 DWORD PTR _nextBuffer$27797[ebp], ecx

; 135  : 
; 136  : 		ASSERT (!buffer->InUse || queue->StartPending);

  00028	8b 55 fc	 mov	 edx, DWORD PTR _buffer$[ebp]
  0002b	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  0002f	74 2c		 je	 SHORT $LN5@FreePoolBu
  00031	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  00034	83 b8 b8 01 00
	00 00		 cmp	 DWORD PTR [eax+440], 0
  0003b	75 20		 jne	 SHORT $LN5@FreePoolBu
  0003d	6a 00		 push	 0
  0003f	68 88 00 00 00	 push	 136			; 00000088H
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@OJKOJEAN@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@COCFEEEN@?$CBbuffer?9?$DOInUse?5?$HM?$HM?5queue?9?$DOStartPe@FNODOBFM@
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  00054	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
  0005b	eb 07		 jmp	 SHORT $LN6@FreePoolBu
$LN5@FreePoolBu:
  0005d	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
$LN6@FreePoolBu:

; 137  : 
; 138  : 		TCfree (buffer->Address);

  00064	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00069	8b 4d fc	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0006c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0006f	52		 push	 edx
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 139  : 		TCfree (buffer);

  00076	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0007b	8b 45 fc	 mov	 eax, DWORD PTR _buffer$[ebp]
  0007e	50		 push	 eax
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 140  : 
; 141  : 		buffer = nextBuffer;

  00085	8b 4d f8	 mov	 ecx, DWORD PTR _nextBuffer$27797[ebp]
  00088	89 4d fc	 mov	 DWORD PTR _buffer$[ebp], ecx

; 142  : 	}

  0008b	eb 8d		 jmp	 SHORT $LN2@FreePoolBu
$LN1@FreePoolBu:

; 143  : 
; 144  : 	queue->FirstPoolBuffer = NULL;

  0008d	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  00090	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], 0

; 145  : 	ReleaseBufferPoolMutex (queue);

  00097	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 _ReleaseBufferPoolMutex@4

; 146  : }

  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c2 04 00	 ret	 4
_FreePoolBuffers@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0GC@JKEACOCL@request?9?$DOEncryptedOffset?5?$CL?5reque@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp__PsTerminateSystemThread@4:PROC
EXTRN	_DecryptDataUnits@16:PROC
EXTRN	__imp_@ExfInterlockedRemoveHeadList@8:PROC
EXTRN	__imp__KeSetPriorityThread@8:PROC
EXTRN	__imp__KeGetCurrentThread@0:PROC
EXTRN	_IsEncryptionThreadPoolRunning@0:PROC
EXTRN	__alldiv:PROC
;	COMDAT ??_C@_0GC@JKEACOCL@request?9?$DOEncryptedOffset?5?$CL?5reque@FNODOBFM@
text$s	SEGMENT
??_C@_0GC@JKEACOCL@request?9?$DOEncryptedOffset?5?$CL?5reque@FNODOBFM@ DB 'r'
	DB	'equest->EncryptedOffset + request->EncryptedLength <= request'
	DB	'->Offset.QuadPart + request->Length', 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _CompletionThreadProc@4
_TEXT	SEGMENT
tv171 = -44						; size = 4
tv139 = -40						; size = 4
tv219 = -36						; size = 8
tv216 = -28						; size = 8
_request$ = -20						; size = 4
_queue$ = -16						; size = 4
_listEntry$ = -12					; size = 4
_dataUnit$ = -8						; size = 8
_threadArg$ = 8						; size = 4
_CompletionThreadProc@4 PROC				; COMDAT

; 225  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00008	56		 push	 esi
  00009	57		 push	 edi

; 226  : 	EncryptedIoQueue *queue = (EncryptedIoQueue *) threadArg;

  0000a	8b 45 08	 mov	 eax, DWORD PTR _threadArg$[ebp]
  0000d	89 45 f0	 mov	 DWORD PTR _queue$[ebp], eax

; 227  : 	PLIST_ENTRY listEntry;
; 228  : 	EncryptedIoRequest *request;
; 229  : 	UINT64_STRUCT dataUnit;
; 230  : 
; 231  : 	if (IsEncryptionThreadPoolRunning())

  00010	e8 00 00 00 00	 call	 _IsEncryptionThreadPoolRunning@0
  00015	85 c0		 test	 eax, eax
  00017	74 0f		 je	 SHORT $LN11@Completion

; 232  : 		KeSetPriorityThread (KeGetCurrentThread(), LOW_REALTIME_PRIORITY);

  00019	6a 10		 push	 16			; 00000010H
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeGetCurrentThread@0
  00021	50		 push	 eax
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetPriorityThread@8
$LN11@Completion:

; 233  : 
; 234  : 	while (!queue->ThreadExitRequested)

  00028	8b 4d f0	 mov	 ecx, DWORD PTR _queue$[ebp]
  0002b	83 b9 bc 01 00
	00 00		 cmp	 DWORD PTR [ecx+444], 0
  00032	0f 85 d5 01 00
	00		 jne	 $LN10@Completion

; 235  : 	{
; 236  : 		if (!NT_SUCCESS (KeWaitForSingleObject (&queue->CompletionThreadQueueNotEmptyEvent, Executive, KernelMode, FALSE, NULL)))

  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	6a 00		 push	 0
  0003e	6a 00		 push	 0
  00040	8b 55 f0	 mov	 edx, DWORD PTR _queue$[ebp]
  00043	81 c2 18 01 00
	00		 add	 edx, 280		; 00000118H
  00049	52		 push	 edx
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
  00050	85 c0		 test	 eax, eax
  00052	7d 02		 jge	 SHORT $LN9@Completion

; 237  : 			continue;

  00054	eb d2		 jmp	 SHORT $LN11@Completion
$LN9@Completion:

; 238  : 
; 239  : 		if (queue->ThreadExitRequested)

  00056	8b 45 f0	 mov	 eax, DWORD PTR _queue$[ebp]
  00059	83 b8 bc 01 00
	00 00		 cmp	 DWORD PTR [eax+444], 0
  00060	74 05		 je	 SHORT $LN7@Completion

; 240  : 			break;

  00062	e9 a6 01 00 00	 jmp	 $LN10@Completion
$LN7@Completion:

; 241  : 
; 242  : 		while ((listEntry = ExInterlockedRemoveHeadList (&queue->CompletionThreadQueue, &queue->CompletionThreadQueueLock)))

  00067	8b 55 f0	 mov	 edx, DWORD PTR _queue$[ebp]
  0006a	81 c2 14 01 00
	00		 add	 edx, 276		; 00000114H
  00070	8b 4d f0	 mov	 ecx, DWORD PTR _queue$[ebp]
  00073	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExfInterlockedRemoveHeadList@8
  0007f	89 45 f4	 mov	 DWORD PTR _listEntry$[ebp], eax
  00082	83 7d f4 00	 cmp	 DWORD PTR _listEntry$[ebp], 0
  00086	0f 84 7c 01 00
	00		 je	 $LN6@Completion

; 243  : 		{
; 244  : 			request = CONTAINING_RECORD (listEntry, EncryptedIoRequest, CompletionListEntry);

  0008c	8b 4d f4	 mov	 ecx, DWORD PTR _listEntry$[ebp]
  0008f	83 e9 34	 sub	 ecx, 52			; 00000034H
  00092	89 4d ec	 mov	 DWORD PTR _request$[ebp], ecx

; 245  : 
; 246  : 			if (request->EncryptedLength > 0 && NT_SUCCESS (request->Item->Status))

  00095	8b 55 ec	 mov	 edx, DWORD PTR _request$[ebp]
  00098	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  0009c	0f 86 14 01 00
	00		 jbe	 $LN5@Completion
  000a2	8b 45 ec	 mov	 eax, DWORD PTR _request$[ebp]
  000a5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a7	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  000ab	0f 8c 05 01 00
	00		 jl	 $LN5@Completion

; 247  : 			{
; 248  : 				ASSERT (request->EncryptedOffset + request->EncryptedLength <= request->Offset.QuadPart + request->Length);

  000b1	8b 55 ec	 mov	 edx, DWORD PTR _request$[ebp]
  000b4	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  000b7	33 c9		 xor	 ecx, ecx
  000b9	8b 55 ec	 mov	 edx, DWORD PTR _request$[ebp]
  000bc	03 42 18	 add	 eax, DWORD PTR [edx+24]
  000bf	8b 52 1c	 mov	 edx, DWORD PTR [edx+28]
  000c2	13 d1		 adc	 edx, ecx
  000c4	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  000c7	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  000ca	33 f6		 xor	 esi, esi
  000cc	8b 7d ec	 mov	 edi, DWORD PTR _request$[ebp]
  000cf	03 4f 08	 add	 ecx, DWORD PTR [edi+8]
  000d2	8b 7f 0c	 mov	 edi, DWORD PTR [edi+12]
  000d5	13 fe		 adc	 edi, esi
  000d7	89 45 e4	 mov	 DWORD PTR tv216[ebp], eax
  000da	89 55 e8	 mov	 DWORD PTR tv216[ebp+4], edx
  000dd	89 4d dc	 mov	 DWORD PTR tv219[ebp], ecx
  000e0	89 7d e0	 mov	 DWORD PTR tv219[ebp+4], edi
  000e3	8b 55 e8	 mov	 edx, DWORD PTR tv216[ebp+4]
  000e6	3b 55 e0	 cmp	 edx, DWORD PTR tv219[ebp+4]
  000e9	7c 2a		 jl	 SHORT $LN15@Completion
  000eb	7f 08		 jg	 SHORT $LN20@Completion
  000ed	8b 45 e4	 mov	 eax, DWORD PTR tv216[ebp]
  000f0	3b 45 dc	 cmp	 eax, DWORD PTR tv219[ebp]
  000f3	76 20		 jbe	 SHORT $LN15@Completion
$LN20@Completion:
  000f5	6a 00		 push	 0
  000f7	68 f8 00 00 00	 push	 248			; 000000f8H
  000fc	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@OJKOJEAN@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  00101	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@JKEACOCL@request?9?$DOEncryptedOffset?5?$CL?5reque@FNODOBFM@
  00106	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  0010c	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv139[ebp], 0
  00113	eb 07		 jmp	 SHORT $LN16@Completion
$LN15@Completion:
  00115	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR tv139[ebp], 1
$LN16@Completion:

; 249  : 				dataUnit.Value = (request->Offset.QuadPart + request->EncryptedOffset) / ENCRYPTION_DATA_UNIT_SIZE;

  0011c	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  0011f	8b 55 ec	 mov	 edx, DWORD PTR _request$[ebp]
  00122	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00125	03 42 18	 add	 eax, DWORD PTR [edx+24]
  00128	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  0012b	13 4a 1c	 adc	 ecx, DWORD PTR [edx+28]
  0012e	6a 00		 push	 0
  00130	68 00 02 00 00	 push	 512			; 00000200H
  00135	51		 push	 ecx
  00136	50		 push	 eax
  00137	e8 00 00 00 00	 call	 __alldiv
  0013c	89 45 f8	 mov	 DWORD PTR _dataUnit$[ebp], eax
  0013f	89 55 fc	 mov	 DWORD PTR _dataUnit$[ebp+4], edx

; 250  : 
; 251  : 				if (queue->CryptoInfo->bPartitionInInactiveSysEncScope)

  00142	8b 55 f0	 mov	 edx, DWORD PTR _queue$[ebp]
  00145	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00148	83 b8 28 44 00
	00 00		 cmp	 DWORD PTR [eax+17448], 0
  0014f	74 20		 je	 SHORT $LN4@Completion

; 252  : 					dataUnit.Value += queue->CryptoInfo->FirstDataUnitNo.Value;

  00151	8b 4d f0	 mov	 ecx, DWORD PTR _queue$[ebp]
  00154	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00157	8b 45 f8	 mov	 eax, DWORD PTR _dataUnit$[ebp]
  0015a	03 82 30 44 00
	00		 add	 eax, DWORD PTR [edx+17456]
  00160	8b 4d fc	 mov	 ecx, DWORD PTR _dataUnit$[ebp+4]
  00163	13 8a 34 44 00
	00		 adc	 ecx, DWORD PTR [edx+17460]
  00169	89 45 f8	 mov	 DWORD PTR _dataUnit$[ebp], eax
  0016c	89 4d fc	 mov	 DWORD PTR _dataUnit$[ebp+4], ecx
  0016f	eb 1e		 jmp	 SHORT $LN3@Completion
$LN4@Completion:

; 253  : 				else if (queue->RemapEncryptedArea)

  00171	8b 55 f0	 mov	 edx, DWORD PTR _queue$[ebp]
  00174	83 7a 5c 00	 cmp	 DWORD PTR [edx+92], 0
  00178	74 15		 je	 SHORT $LN3@Completion

; 254  : 					dataUnit.Value += queue->RemappedAreaDataUnitOffset;

  0017a	8b 45 f0	 mov	 eax, DWORD PTR _queue$[ebp]
  0017d	8b 4d f8	 mov	 ecx, DWORD PTR _dataUnit$[ebp]
  00180	03 48 68	 add	 ecx, DWORD PTR [eax+104]
  00183	8b 55 fc	 mov	 edx, DWORD PTR _dataUnit$[ebp+4]
  00186	13 50 6c	 adc	 edx, DWORD PTR [eax+108]
  00189	89 4d f8	 mov	 DWORD PTR _dataUnit$[ebp], ecx
  0018c	89 55 fc	 mov	 DWORD PTR _dataUnit$[ebp+4], edx
$LN3@Completion:

; 255  : 
; 256  : 				DecryptDataUnits (request->Data + request->EncryptedOffset, &dataUnit, request->EncryptedLength / ENCRYPTION_DATA_UNIT_SIZE, queue->CryptoInfo);

  0018f	8b 45 f0	 mov	 eax, DWORD PTR _queue$[ebp]
  00192	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00195	51		 push	 ecx
  00196	8b 55 ec	 mov	 edx, DWORD PTR _request$[ebp]
  00199	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0019c	c1 e8 09	 shr	 eax, 9
  0019f	50		 push	 eax
  001a0	8d 4d f8	 lea	 ecx, DWORD PTR _dataUnit$[ebp]
  001a3	51		 push	 ecx
  001a4	8b 55 ec	 mov	 edx, DWORD PTR _request$[ebp]
  001a7	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  001aa	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  001ad	03 41 24	 add	 eax, DWORD PTR [ecx+36]
  001b0	50		 push	 eax
  001b1	e8 00 00 00 00	 call	 _DecryptDataUnits@16
$LN5@Completion:

; 257  : 			}
; 258  : 
; 259  : 			if (request->CompleteOriginalIrp)

  001b6	8b 55 ec	 mov	 edx, DWORD PTR _request$[ebp]
  001b9	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  001bd	74 37		 je	 SHORT $LN1@Completion

; 260  : 			{
; 261  : 				CompleteOriginalIrp (request->Item, request->Item->Status,
; 262  : 					NT_SUCCESS (request->Item->Status) ? request->Item->OriginalLength : 0);

  001bf	8b 45 ec	 mov	 eax, DWORD PTR _request$[ebp]
  001c2	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c4	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  001c8	7c 0d		 jl	 SHORT $LN17@Completion
  001ca	8b 55 ec	 mov	 edx, DWORD PTR _request$[ebp]
  001cd	8b 02		 mov	 eax, DWORD PTR [edx]
  001cf	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001d2	89 4d d4	 mov	 DWORD PTR tv171[ebp], ecx
  001d5	eb 07		 jmp	 SHORT $LN18@Completion
$LN17@Completion:
  001d7	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR tv171[ebp], 0
$LN18@Completion:
  001de	8b 55 d4	 mov	 edx, DWORD PTR tv171[ebp]
  001e1	52		 push	 edx
  001e2	8b 45 ec	 mov	 eax, DWORD PTR _request$[ebp]
  001e5	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e7	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  001ea	52		 push	 edx
  001eb	8b 45 ec	 mov	 eax, DWORD PTR _request$[ebp]
  001ee	8b 08		 mov	 ecx, DWORD PTR [eax]
  001f0	51		 push	 ecx
  001f1	e8 00 00 00 00	 call	 _CompleteOriginalIrp@12
$LN1@Completion:

; 263  : 			}
; 264  : 
; 265  : 			ReleasePoolBuffer (queue, request);

  001f6	8b 55 ec	 mov	 edx, DWORD PTR _request$[ebp]
  001f9	52		 push	 edx
  001fa	8b 45 f0	 mov	 eax, DWORD PTR _queue$[ebp]
  001fd	50		 push	 eax
  001fe	e8 00 00 00 00	 call	 _ReleasePoolBuffer@8

; 266  : 		}

  00203	e9 5f fe ff ff	 jmp	 $LN7@Completion
$LN6@Completion:

; 267  : 	}

  00208	e9 1b fe ff ff	 jmp	 $LN11@Completion
$LN10@Completion:

; 268  : 
; 269  : 	PsTerminateSystemThread (STATUS_SUCCESS);

  0020d	6a 00		 push	 0
  0020f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsTerminateSystemThread@4

; 270  : }

  00215	5f		 pop	 edi
  00216	5e		 pop	 esi
  00217	8b e5		 mov	 esp, ebp
  00219	5d		 pop	 ebp
  0021a	c2 04 00	 ret	 4
_CompletionThreadProc@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@FECNDOKE@buffer?9?$DOInUse?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0O@FECNDOKE@buffer?9?$DOInUse?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0O@FECNDOKE@buffer?9?$DOInUse?$AA@FNODOBFM@ DB 'buffer->InUse', 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _ReleasePoolBuffer@8
_TEXT	SEGMENT
tv75 = -8						; size = 4
_buffer$ = -4						; size = 4
_queue$ = 8						; size = 4
_address$ = 12						; size = 4
_ReleasePoolBuffer@8 PROC				; COMDAT

; 107  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 108  : 	EncryptedIoQueueBuffer *buffer;
; 109  : 	AcquireBufferPoolMutex (queue);

  00008	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _AcquireBufferPoolMutex@4

; 110  : 	
; 111  : 	for (buffer = queue->FirstPoolBuffer; buffer != NULL; buffer = buffer->NextBuffer)

  00011	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  00014	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00017	89 55 fc	 mov	 DWORD PTR _buffer$[ebp], edx
  0001a	eb 08		 jmp	 SHORT $LN4@ReleasePoo
$LN3@ReleasePoo:
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _buffer$[ebp]
  0001f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00021	89 4d fc	 mov	 DWORD PTR _buffer$[ebp], ecx
$LN4@ReleasePoo:
  00024	83 7d fc 00	 cmp	 DWORD PTR _buffer$[ebp], 0
  00028	74 46		 je	 SHORT $LN2@ReleasePoo

; 112  : 	{
; 113  : 		if (buffer->Address == address)

  0002a	8b 55 fc	 mov	 edx, DWORD PTR _buffer$[ebp]
  0002d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00030	3b 45 0c	 cmp	 eax, DWORD PTR _address$[ebp]
  00033	75 39		 jne	 SHORT $LN1@ReleasePoo

; 114  : 		{
; 115  : 			ASSERT (buffer->InUse);

  00035	8b 4d fc	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00038	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  0003c	75 1d		 jne	 SHORT $LN7@ReleasePoo
  0003e	6a 00		 push	 0
  00040	6a 73		 push	 115			; 00000073H
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@OJKOJEAN@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_0O@FECNDOKE@buffer?9?$DOInUse?$AA@FNODOBFM@
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  00052	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
  00059	eb 07		 jmp	 SHORT $LN8@ReleasePoo
$LN7@ReleasePoo:
  0005b	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv75[ebp], 1
$LN8@ReleasePoo:

; 116  : 
; 117  : 			buffer->InUse = FALSE;

  00062	8b 55 fc	 mov	 edx, DWORD PTR _buffer$[ebp]
  00065	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 118  : 			break;

  0006c	eb 02		 jmp	 SHORT $LN2@ReleasePoo
$LN1@ReleasePoo:

; 119  : 		}
; 120  : 	}

  0006e	eb ac		 jmp	 SHORT $LN3@ReleasePoo
$LN2@ReleasePoo:

; 121  : 
; 122  : 	ReleaseBufferPoolMutex (queue);

  00070	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 _ReleaseBufferPoolMutex@4

; 123  : 	KeSetEvent (&queue->PoolBufferFreeEvent, IO_DISK_INCREMENT, FALSE);

  00079	6a 00		 push	 0
  0007b	6a 01		 push	 1
  0007d	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  00080	81 c1 98 01 00
	00		 add	 ecx, 408		; 00000198H
  00086	51		 push	 ecx
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 124  : }

  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c2 08 00	 ret	 8
_ReleasePoolBuffer@8 ENDP
_TEXT	ENDS
EXTRN	_TCCompleteDiskIrp@12:PROC
; Function compile flags: /Odtp
;	COMDAT _CompleteOriginalIrp@12
_TEXT	SEGMENT
_item$ = 8						; size = 4
_status$ = 12						; size = 4
_information$ = 16					; size = 4
_CompleteOriginalIrp@12 PROC				; COMDAT

; 175  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 176  : #ifdef TC_TRACE_IO_QUEUE
; 177  : 	Dump ("< %I64d [%I64d] %c status=%x info=%I64d\n", item->OriginalIrpOffset, GetElapsedTime (&item->Queue->LastPerformanceCounter), item->Write ? 'W' : 'R', status, (int64) information);
; 178  : #endif
; 179  : 
; 180  : 	TCCompleteDiskIrp (item->OriginalIrp, status, information);

  00005	8b 45 10	 mov	 eax, DWORD PTR _information$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _status$[ebp]
  0000c	51		 push	 ecx
  0000d	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  00010	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _TCCompleteDiskIrp@12

; 181  : 
; 182  : 	item->Status = status;

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  0001c	8b 55 0c	 mov	 edx, DWORD PTR _status$[ebp]
  0001f	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 183  : 	OnItemCompleted (item, TRUE);

  00022	6a 01		 push	 1
  00024	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _OnItemCompleted@8

; 184  : 
; 185  : 	return status;

  0002d	8b 45 0c	 mov	 eax, DWORD PTR _status$[ebp]

; 186  : }

  00030	5d		 pop	 ebp
  00031	c2 0c 00	 ret	 12			; 0000000cH
_CompleteOriginalIrp@12 ENDP
_TEXT	ENDS
EXTRN	__imp__IoReleaseRemoveLockEx@12:PROC
; Function compile flags: /Odtp
;	COMDAT _OnItemCompleted@8
_TEXT	SEGMENT
_item$ = 8						; size = 4
_freeItem$ = 12						; size = 4
_OnItemCompleted@8 PROC					; COMDAT

; 157  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 158  : 	DecrementOutstandingIoCount (item->Queue);

  00005	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00008	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _DecrementOutstandingIoCount@4

; 159  : 	IoReleaseRemoveLock (&item->Queue->RemoveLock, item->OriginalIrp);

  00010	6a 58		 push	 88			; 00000058H
  00012	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  00015	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  0001c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001e	83 c2 70	 add	 edx, 112		; 00000070H
  00021	52		 push	 edx
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 160  : 
; 161  : 	if (NT_SUCCESS (item->Status))

  00028	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  0002b	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  0002f	7c 63		 jl	 SHORT $LN4@OnItemComp

; 162  : 	{
; 163  : 		if (item->Write)

  00031	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00034	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00038	74 2e		 je	 SHORT $LN3@OnItemComp

; 164  : 			item->Queue->TotalBytesWritten += item->OriginalLength;

  0003a	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  0003d	8b 02		 mov	 eax, DWORD PTR [edx]
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00042	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00045	33 c9		 xor	 ecx, ecx
  00047	03 90 b0 01 00
	00		 add	 edx, DWORD PTR [eax+432]
  0004d	8b 80 b4 01 00
	00		 mov	 eax, DWORD PTR [eax+436]
  00053	13 c1		 adc	 eax, ecx
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00058	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0005a	89 91 b0 01 00
	00		 mov	 DWORD PTR [ecx+432], edx
  00060	89 81 b4 01 00
	00		 mov	 DWORD PTR [ecx+436], eax

; 165  : 		else

  00066	eb 2c		 jmp	 SHORT $LN4@OnItemComp
$LN3@OnItemComp:

; 166  : 			item->Queue->TotalBytesRead += item->OriginalLength;

  00068	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  0006b	8b 02		 mov	 eax, DWORD PTR [edx]
  0006d	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00070	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00073	33 c9		 xor	 ecx, ecx
  00075	03 90 a8 01 00
	00		 add	 edx, DWORD PTR [eax+424]
  0007b	8b 80 ac 01 00
	00		 mov	 eax, DWORD PTR [eax+428]
  00081	13 c1		 adc	 eax, ecx
  00083	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00086	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00088	89 91 a8 01 00
	00		 mov	 DWORD PTR [ecx+424], edx
  0008e	89 81 ac 01 00
	00		 mov	 DWORD PTR [ecx+428], eax
$LN4@OnItemComp:

; 167  : 	}
; 168  : 
; 169  : 	if (freeItem)

  00094	83 7d 0c 00	 cmp	 DWORD PTR _freeItem$[ebp], 0
  00098	74 0f		 je	 SHORT $LN5@OnItemComp

; 170  : 		ReleasePoolBuffer (item->Queue, item);

  0009a	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  0009d	52		 push	 edx
  0009e	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  000a1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a3	51		 push	 ecx
  000a4	e8 00 00 00 00	 call	 _ReleasePoolBuffer@8
$LN5@OnItemComp:

; 171  : }

  000a9	5d		 pop	 ebp
  000aa	c2 08 00	 ret	 8
_OnItemCompleted@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@IDPHHPHP@NT_SUCCESS?5?$CIstatus?$CJ?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp__ZwReadFile@36:PROC
EXTRN	_TCReadDevice@20:PROC
EXTRN	__imp__ZwWriteFile@36:PROC
EXTRN	_TCWriteDevice@20:PROC
EXTRN	__imp__SeImpersonateClientEx@8:PROC
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_0BE@IDPHHPHP@NT_SUCCESS?5?$CIstatus?$CJ?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BE@IDPHHPHP@NT_SUCCESS?5?$CIstatus?$CJ?$AA@FNODOBFM@ DB 'NT_SUCCES'
	DB	'S (status)', 00H				;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _IoThreadProc@4
_TEXT	SEGMENT
tv650 = -92						; size = 4
tv647 = -88						; size = 8
tv282 = -80						; size = 4
tv151 = -76						; size = 4
tv80 = -72						; size = 4
_ioStatus$27999 = -68					; size = 8
_readAhead$27989 = -60					; size = 4
_ioStatus$27975 = -56					; size = 8
_remappedOffset$27966 = -48				; size = 8
_subFragmentOffset$27950 = -40				; size = 8
_subFragmentLength$27951 = -28				; size = 4
_subFragmentData$27946 = -24				; size = 4
_subFragment$27945 = -20				; size = 4
_status$27921 = -16					; size = 4
_request$ = -12						; size = 4
_queue$ = -8						; size = 4
_listEntry$ = -4					; size = 4
_threadArg$ = 8						; size = 4
_IoThreadProc@4 PROC					; COMDAT

; 299  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00008	56		 push	 esi
  00009	57		 push	 edi

; 300  : 	EncryptedIoQueue *queue = (EncryptedIoQueue *) threadArg;

  0000a	8b 45 08	 mov	 eax, DWORD PTR _threadArg$[ebp]
  0000d	89 45 f8	 mov	 DWORD PTR _queue$[ebp], eax

; 301  : 	PLIST_ENTRY listEntry;
; 302  : 	EncryptedIoRequest *request;
; 303  : 
; 304  : 	KeSetPriorityThread (KeGetCurrentThread(), LOW_REALTIME_PRIORITY);

  00010	6a 10		 push	 16			; 00000010H
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeGetCurrentThread@0
  00018	50		 push	 eax
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetPriorityThread@8

; 305  : 
; 306  : 	if (!queue->IsFilterDevice && queue->SecurityClientContext)

  0001f	8b 4d f8	 mov	 ecx, DWORD PTR _queue$[ebp]
  00022	83 79 3c 00	 cmp	 DWORD PTR [ecx+60], 0
  00026	75 48		 jne	 SHORT $LN40@IoThreadPr
  00028	8b 55 f8	 mov	 edx, DWORD PTR _queue$[ebp]
  0002b	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  0002f	74 3f		 je	 SHORT $LN40@IoThreadPr

; 307  : 	{
; 308  : #ifdef DEBUG
; 309  : 		NTSTATUS status =
; 310  : #endif
; 311  : 		SeImpersonateClientEx (queue->SecurityClientContext, NULL);

  00031	6a 00		 push	 0
  00033	8b 45 f8	 mov	 eax, DWORD PTR _queue$[ebp]
  00036	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00039	51		 push	 ecx
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SeImpersonateClientEx@8
  00040	89 45 f0	 mov	 DWORD PTR _status$27921[ebp], eax

; 312  : 		ASSERT (NT_SUCCESS (status));

  00043	83 7d f0 00	 cmp	 DWORD PTR _status$27921[ebp], 0
  00047	7d 20		 jge	 SHORT $LN44@IoThreadPr
  00049	6a 00		 push	 0
  0004b	68 38 01 00 00	 push	 312			; 00000138H
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@OJKOJEAN@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@IDPHHPHP@NT_SUCCESS?5?$CIstatus?$CJ?$AA@FNODOBFM@
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  00060	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
  00067	eb 07		 jmp	 SHORT $LN40@IoThreadPr
$LN44@IoThreadPr:
  00069	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
$LN40@IoThreadPr:

; 313  : 	}
; 314  : 
; 315  : 	while (!queue->ThreadExitRequested)

  00070	8b 55 f8	 mov	 edx, DWORD PTR _queue$[ebp]
  00073	83 ba bc 01 00
	00 00		 cmp	 DWORD PTR [edx+444], 0
  0007a	0f 85 f3 05 00
	00		 jne	 $LN39@IoThreadPr

; 316  : 	{
; 317  : 		if (!NT_SUCCESS (KeWaitForSingleObject (&queue->IoThreadQueueNotEmptyEvent, Executive, KernelMode, FALSE, NULL)))

  00080	6a 00		 push	 0
  00082	6a 00		 push	 0
  00084	6a 00		 push	 0
  00086	6a 00		 push	 0
  00088	8b 45 f8	 mov	 eax, DWORD PTR _queue$[ebp]
  0008b	05 f8 00 00 00	 add	 eax, 248		; 000000f8H
  00090	50		 push	 eax
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
  00097	85 c0		 test	 eax, eax
  00099	7d 02		 jge	 SHORT $LN38@IoThreadPr

; 318  : 			continue;

  0009b	eb d3		 jmp	 SHORT $LN40@IoThreadPr
$LN38@IoThreadPr:

; 319  : 
; 320  : 		if (queue->ThreadExitRequested)

  0009d	8b 4d f8	 mov	 ecx, DWORD PTR _queue$[ebp]
  000a0	83 b9 bc 01 00
	00 00		 cmp	 DWORD PTR [ecx+444], 0
  000a7	74 05		 je	 SHORT $LN36@IoThreadPr

; 321  : 			break;

  000a9	e9 c5 05 00 00	 jmp	 $LN39@IoThreadPr
$LN36@IoThreadPr:

; 322  : 
; 323  : 		while ((listEntry = ExInterlockedRemoveHeadList (&queue->IoThreadQueue, &queue->IoThreadQueueLock)))

  000ae	8b 55 f8	 mov	 edx, DWORD PTR _queue$[ebp]
  000b1	81 c2 f4 00 00
	00		 add	 edx, 244		; 000000f4H
  000b7	8b 4d f8	 mov	 ecx, DWORD PTR _queue$[ebp]
  000ba	81 c1 ec 00 00
	00		 add	 ecx, 236		; 000000ecH
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExfInterlockedRemoveHeadList@8
  000c6	89 45 fc	 mov	 DWORD PTR _listEntry$[ebp], eax
  000c9	83 7d fc 00	 cmp	 DWORD PTR _listEntry$[ebp], 0
  000cd	0f 84 9b 05 00
	00		 je	 $LN35@IoThreadPr

; 324  : 		{
; 325  : 			InterlockedDecrement (&queue->IoThreadPendingRequestCount);

  000d3	8b 55 f8	 mov	 edx, DWORD PTR _queue$[ebp]
  000d6	81 c2 94 01 00
	00		 add	 edx, 404		; 00000194H
  000dc	83 c8 ff	 or	 eax, -1
  000df	f0 0f c1 02	 lock	  xadd	 DWORD PTR [edx], eax

; 326  : 			request = CONTAINING_RECORD (listEntry, EncryptedIoRequest, ListEntry);

  000e3	8b 4d fc	 mov	 ecx, DWORD PTR _listEntry$[ebp]
  000e6	83 e9 2c	 sub	 ecx, 44			; 0000002cH
  000e9	89 4d f4	 mov	 DWORD PTR _request$[ebp], ecx

; 327  : 			
; 328  : #ifdef TC_TRACE_IO_QUEUE
; 329  : 			Dump ("%c   %I64d [%I64d] roff=%I64d rlen=%d\n", request->Item->Write ? 'W' : 'R', request->Item->OriginalIrpOffset.QuadPart, GetElapsedTime (&queue->LastPerformanceCounter), request->Offset.QuadPart, request->Length);
; 330  : #endif
; 331  : 
; 332  : 			// Perform IO request if no preceding request of the item failed
; 333  : 			if (NT_SUCCESS (request->Item->Status))

  000ec	8b 55 f4	 mov	 edx, DWORD PTR _request$[ebp]
  000ef	8b 02		 mov	 eax, DWORD PTR [edx]
  000f1	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  000f5	0f 8c e2 02 00
	00		 jl	 $LN34@IoThreadPr

; 334  : 			{
; 335  : 				if (queue->IsFilterDevice)

  000fb	8b 4d f8	 mov	 ecx, DWORD PTR _queue$[ebp]
  000fe	83 79 3c 00	 cmp	 DWORD PTR [ecx+60], 0
  00102	0f 84 42 02 00
	00		 je	 $LN33@IoThreadPr

; 336  : 				{
; 337  : 					if (queue->RemapEncryptedArea && request->EncryptedLength > 0)

  00108	8b 55 f8	 mov	 edx, DWORD PTR _queue$[ebp]
  0010b	83 7a 5c 00	 cmp	 DWORD PTR [edx+92], 0
  0010f	0f 84 ca 01 00
	00		 je	 $LN32@IoThreadPr
  00115	8b 45 f4	 mov	 eax, DWORD PTR _request$[ebp]
  00118	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0011c	0f 86 bd 01 00
	00		 jbe	 $LN32@IoThreadPr

; 338  : 					{
; 339  : 						if (request->EncryptedLength != request->Length)

  00122	8b 4d f4	 mov	 ecx, DWORD PTR _request$[ebp]
  00125	8b 55 f4	 mov	 edx, DWORD PTR _request$[ebp]
  00128	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0012b	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  0012e	0f 84 31 01 00
	00		 je	 $LN31@IoThreadPr

; 340  : 						{
; 341  : 							// Up to three subfragments may be required to handle a partially remapped fragment
; 342  : 							int subFragment;
; 343  : 							byte *subFragmentData = request->Data;

  00134	8b 4d f4	 mov	 ecx, DWORD PTR _request$[ebp]
  00137	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0013a	89 55 e8	 mov	 DWORD PTR _subFragmentData$27946[ebp], edx

; 344  : 
; 345  : 							for (subFragment = 0 ; subFragment < 3; ++subFragment)

  0013d	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _subFragment$27945[ebp], 0
  00144	eb 09		 jmp	 SHORT $LN30@IoThreadPr
$LN29@IoThreadPr:
  00146	8b 45 ec	 mov	 eax, DWORD PTR _subFragment$27945[ebp]
  00149	83 c0 01	 add	 eax, 1
  0014c	89 45 ec	 mov	 DWORD PTR _subFragment$27945[ebp], eax
$LN30@IoThreadPr:
  0014f	83 7d ec 03	 cmp	 DWORD PTR _subFragment$27945[ebp], 3
  00153	0f 8d 0a 01 00
	00		 jge	 $LN28@IoThreadPr

; 346  : 							{
; 347  : 								LARGE_INTEGER subFragmentOffset;
; 348  : 								ULONG subFragmentLength;
; 349  : 								subFragmentOffset.QuadPart = request->Offset.QuadPart;

  00159	8b 4d f4	 mov	 ecx, DWORD PTR _request$[ebp]
  0015c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0015f	89 55 d8	 mov	 DWORD PTR _subFragmentOffset$27950[ebp], edx
  00162	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00165	89 45 dc	 mov	 DWORD PTR _subFragmentOffset$27950[ebp+4], eax

; 350  : 
; 351  : 								switch (subFragment)

  00168	8b 4d ec	 mov	 ecx, DWORD PTR _subFragment$27945[ebp]
  0016b	89 4d b4	 mov	 DWORD PTR tv151[ebp], ecx
  0016e	83 7d b4 00	 cmp	 DWORD PTR tv151[ebp], 0
  00172	74 0e		 je	 SHORT $LN25@IoThreadPr
  00174	83 7d b4 01	 cmp	 DWORD PTR tv151[ebp], 1
  00178	74 13		 je	 SHORT $LN24@IoThreadPr
  0017a	83 7d b4 02	 cmp	 DWORD PTR tv151[ebp], 2
  0017e	74 38		 je	 SHORT $LN23@IoThreadPr
  00180	eb 79		 jmp	 SHORT $LN26@IoThreadPr
$LN25@IoThreadPr:

; 352  : 								{
; 353  : 								case 0:
; 354  : 									subFragmentLength = (ULONG) request->EncryptedOffset;

  00182	8b 55 f4	 mov	 edx, DWORD PTR _request$[ebp]
  00185	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00188	89 45 e4	 mov	 DWORD PTR _subFragmentLength$27951[ebp], eax

; 355  : 									break;

  0018b	eb 6e		 jmp	 SHORT $LN26@IoThreadPr
$LN24@IoThreadPr:

; 356  : 
; 357  : 								case 1:
; 358  : 									subFragmentOffset.QuadPart += request->EncryptedOffset + queue->RemappedAreaOffset;

  0018d	8b 4d f4	 mov	 ecx, DWORD PTR _request$[ebp]
  00190	8b 55 f8	 mov	 edx, DWORD PTR _queue$[ebp]
  00193	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00196	03 42 60	 add	 eax, DWORD PTR [edx+96]
  00199	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  0019c	13 4a 64	 adc	 ecx, DWORD PTR [edx+100]
  0019f	03 45 d8	 add	 eax, DWORD PTR _subFragmentOffset$27950[ebp]
  001a2	8b 55 dc	 mov	 edx, DWORD PTR _subFragmentOffset$27950[ebp+4]
  001a5	13 d1		 adc	 edx, ecx
  001a7	89 45 d8	 mov	 DWORD PTR _subFragmentOffset$27950[ebp], eax
  001aa	89 55 dc	 mov	 DWORD PTR _subFragmentOffset$27950[ebp+4], edx

; 359  : 									subFragmentLength = request->EncryptedLength;

  001ad	8b 45 f4	 mov	 eax, DWORD PTR _request$[ebp]
  001b0	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  001b3	89 4d e4	 mov	 DWORD PTR _subFragmentLength$27951[ebp], ecx

; 360  : 									break;

  001b6	eb 43		 jmp	 SHORT $LN26@IoThreadPr
$LN23@IoThreadPr:

; 361  : 
; 362  : 								case 2:
; 363  : 									subFragmentOffset.QuadPart += request->EncryptedOffset + request->EncryptedLength;

  001b8	8b 55 f4	 mov	 edx, DWORD PTR _request$[ebp]
  001bb	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  001be	33 c9		 xor	 ecx, ecx
  001c0	8b 55 f4	 mov	 edx, DWORD PTR _request$[ebp]
  001c3	03 42 18	 add	 eax, DWORD PTR [edx+24]
  001c6	8b 52 1c	 mov	 edx, DWORD PTR [edx+28]
  001c9	13 d1		 adc	 edx, ecx
  001cb	03 45 d8	 add	 eax, DWORD PTR _subFragmentOffset$27950[ebp]
  001ce	8b 4d dc	 mov	 ecx, DWORD PTR _subFragmentOffset$27950[ebp+4]
  001d1	13 ca		 adc	 ecx, edx
  001d3	89 45 d8	 mov	 DWORD PTR _subFragmentOffset$27950[ebp], eax
  001d6	89 4d dc	 mov	 DWORD PTR _subFragmentOffset$27950[ebp+4], ecx

; 364  : 									subFragmentLength = (ULONG) (request->Length - (request->EncryptedOffset + request->EncryptedLength));

  001d9	8b 55 f4	 mov	 edx, DWORD PTR _request$[ebp]
  001dc	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  001df	33 c9		 xor	 ecx, ecx
  001e1	8b 55 f4	 mov	 edx, DWORD PTR _request$[ebp]
  001e4	8b 52 20	 mov	 edx, DWORD PTR [edx+32]
  001e7	33 f6		 xor	 esi, esi
  001e9	8b 7d f4	 mov	 edi, DWORD PTR _request$[ebp]
  001ec	03 57 18	 add	 edx, DWORD PTR [edi+24]
  001ef	8b 7f 1c	 mov	 edi, DWORD PTR [edi+28]
  001f2	13 fe		 adc	 edi, esi
  001f4	2b c2		 sub	 eax, edx
  001f6	1b cf		 sbb	 ecx, edi
  001f8	89 45 e4	 mov	 DWORD PTR _subFragmentLength$27951[ebp], eax
$LN26@IoThreadPr:

; 365  : 									break;
; 366  : 								}
; 367  : 
; 368  : 								if (subFragmentLength > 0)

  001fb	83 7d e4 00	 cmp	 DWORD PTR _subFragmentLength$27951[ebp], 0
  001ff	76 5d		 jbe	 SHORT $LN22@IoThreadPr

; 369  : 								{
; 370  : 									if (request->Item->Write)

  00201	8b 45 f4	 mov	 eax, DWORD PTR _request$[ebp]
  00204	8b 08		 mov	 ecx, DWORD PTR [eax]
  00206	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  0020a	74 26		 je	 SHORT $LN21@IoThreadPr

; 371  : 										request->Item->Status = TCWriteDevice (queue->LowerDeviceObject, subFragmentData, subFragmentOffset, subFragmentLength);

  0020c	8b 55 e4	 mov	 edx, DWORD PTR _subFragmentLength$27951[ebp]
  0020f	52		 push	 edx
  00210	8b 45 dc	 mov	 eax, DWORD PTR _subFragmentOffset$27950[ebp+4]
  00213	50		 push	 eax
  00214	8b 4d d8	 mov	 ecx, DWORD PTR _subFragmentOffset$27950[ebp]
  00217	51		 push	 ecx
  00218	8b 55 e8	 mov	 edx, DWORD PTR _subFragmentData$27946[ebp]
  0021b	52		 push	 edx
  0021c	8b 45 f8	 mov	 eax, DWORD PTR _queue$[ebp]
  0021f	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00222	51		 push	 ecx
  00223	e8 00 00 00 00	 call	 _TCWriteDevice@20
  00228	8b 55 f4	 mov	 edx, DWORD PTR _request$[ebp]
  0022b	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0022d	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 372  : 									else

  00230	eb 23		 jmp	 SHORT $LN20@IoThreadPr
$LN21@IoThreadPr:

; 373  : 										request->Item->Status = TCCachedRead (queue, NULL, subFragmentData, subFragmentOffset, subFragmentLength);

  00232	8b 55 e4	 mov	 edx, DWORD PTR _subFragmentLength$27951[ebp]
  00235	52		 push	 edx
  00236	8b 45 dc	 mov	 eax, DWORD PTR _subFragmentOffset$27950[ebp+4]
  00239	50		 push	 eax
  0023a	8b 4d d8	 mov	 ecx, DWORD PTR _subFragmentOffset$27950[ebp]
  0023d	51		 push	 ecx
  0023e	8b 55 e8	 mov	 edx, DWORD PTR _subFragmentData$27946[ebp]
  00241	52		 push	 edx
  00242	6a 00		 push	 0
  00244	8b 45 f8	 mov	 eax, DWORD PTR _queue$[ebp]
  00247	50		 push	 eax
  00248	e8 00 00 00 00	 call	 _TCCachedRead@24
  0024d	8b 4d f4	 mov	 ecx, DWORD PTR _request$[ebp]
  00250	8b 11		 mov	 edx, DWORD PTR [ecx]
  00252	89 42 18	 mov	 DWORD PTR [edx+24], eax
$LN20@IoThreadPr:

; 374  : 
; 375  : 									subFragmentData += subFragmentLength;

  00255	8b 45 e8	 mov	 eax, DWORD PTR _subFragmentData$27946[ebp]
  00258	03 45 e4	 add	 eax, DWORD PTR _subFragmentLength$27951[ebp]
  0025b	89 45 e8	 mov	 DWORD PTR _subFragmentData$27946[ebp], eax
$LN22@IoThreadPr:

; 376  : 								}
; 377  : 							}

  0025e	e9 e3 fe ff ff	 jmp	 $LN29@IoThreadPr
$LN28@IoThreadPr:

; 378  : 						}
; 379  : 						else

  00263	eb 78		 jmp	 SHORT $LN19@IoThreadPr
$LN31@IoThreadPr:

; 380  : 						{
; 381  : 							// Remap the fragment
; 382  : 							LARGE_INTEGER remappedOffset;
; 383  : 							remappedOffset.QuadPart = request->Offset.QuadPart + queue->RemappedAreaOffset;

  00265	8b 4d f4	 mov	 ecx, DWORD PTR _request$[ebp]
  00268	8b 55 f8	 mov	 edx, DWORD PTR _queue$[ebp]
  0026b	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0026e	03 42 60	 add	 eax, DWORD PTR [edx+96]
  00271	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00274	13 4a 64	 adc	 ecx, DWORD PTR [edx+100]
  00277	89 45 d0	 mov	 DWORD PTR _remappedOffset$27966[ebp], eax
  0027a	89 4d d4	 mov	 DWORD PTR _remappedOffset$27966[ebp+4], ecx

; 384  : 
; 385  : 							if (request->Item->Write)

  0027d	8b 55 f4	 mov	 edx, DWORD PTR _request$[ebp]
  00280	8b 02		 mov	 eax, DWORD PTR [edx]
  00282	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00286	74 2c		 je	 SHORT $LN18@IoThreadPr

; 386  : 								request->Item->Status = TCWriteDevice (queue->LowerDeviceObject, request->Data, remappedOffset, request->Length);

  00288	8b 4d f4	 mov	 ecx, DWORD PTR _request$[ebp]
  0028b	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0028e	52		 push	 edx
  0028f	8b 45 d4	 mov	 eax, DWORD PTR _remappedOffset$27966[ebp+4]
  00292	50		 push	 eax
  00293	8b 4d d0	 mov	 ecx, DWORD PTR _remappedOffset$27966[ebp]
  00296	51		 push	 ecx
  00297	8b 55 f4	 mov	 edx, DWORD PTR _request$[ebp]
  0029a	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0029d	50		 push	 eax
  0029e	8b 4d f8	 mov	 ecx, DWORD PTR _queue$[ebp]
  002a1	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  002a4	52		 push	 edx
  002a5	e8 00 00 00 00	 call	 _TCWriteDevice@20
  002aa	8b 4d f4	 mov	 ecx, DWORD PTR _request$[ebp]
  002ad	8b 11		 mov	 edx, DWORD PTR [ecx]
  002af	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 387  : 							else

  002b2	eb 29		 jmp	 SHORT $LN19@IoThreadPr
$LN18@IoThreadPr:

; 388  : 								request->Item->Status = TCCachedRead (queue, NULL, request->Data, remappedOffset, request->Length);

  002b4	8b 45 f4	 mov	 eax, DWORD PTR _request$[ebp]
  002b7	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  002ba	51		 push	 ecx
  002bb	8b 55 d4	 mov	 edx, DWORD PTR _remappedOffset$27966[ebp+4]
  002be	52		 push	 edx
  002bf	8b 45 d0	 mov	 eax, DWORD PTR _remappedOffset$27966[ebp]
  002c2	50		 push	 eax
  002c3	8b 4d f4	 mov	 ecx, DWORD PTR _request$[ebp]
  002c6	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  002c9	52		 push	 edx
  002ca	6a 00		 push	 0
  002cc	8b 45 f8	 mov	 eax, DWORD PTR _queue$[ebp]
  002cf	50		 push	 eax
  002d0	e8 00 00 00 00	 call	 _TCCachedRead@24
  002d5	8b 4d f4	 mov	 ecx, DWORD PTR _request$[ebp]
  002d8	8b 11		 mov	 edx, DWORD PTR [ecx]
  002da	89 42 18	 mov	 DWORD PTR [edx+24], eax
$LN19@IoThreadPr:

; 389  : 						}
; 390  : 					}
; 391  : 					else

  002dd	eb 66		 jmp	 SHORT $LN16@IoThreadPr
$LN32@IoThreadPr:

; 392  : 					{
; 393  : 						if (request->Item->Write)

  002df	8b 45 f4	 mov	 eax, DWORD PTR _request$[ebp]
  002e2	8b 08		 mov	 ecx, DWORD PTR [eax]
  002e4	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  002e8	74 2f		 je	 SHORT $LN15@IoThreadPr

; 394  : 							request->Item->Status = TCWriteDevice (queue->LowerDeviceObject, request->Data, request->Offset, request->Length);

  002ea	8b 55 f4	 mov	 edx, DWORD PTR _request$[ebp]
  002ed	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  002f0	50		 push	 eax
  002f1	8b 4d f4	 mov	 ecx, DWORD PTR _request$[ebp]
  002f4	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  002f7	52		 push	 edx
  002f8	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  002fb	50		 push	 eax
  002fc	8b 4d f4	 mov	 ecx, DWORD PTR _request$[ebp]
  002ff	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00302	52		 push	 edx
  00303	8b 45 f8	 mov	 eax, DWORD PTR _queue$[ebp]
  00306	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00309	51		 push	 ecx
  0030a	e8 00 00 00 00	 call	 _TCWriteDevice@20
  0030f	8b 55 f4	 mov	 edx, DWORD PTR _request$[ebp]
  00312	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00314	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 395  : 						else

  00317	eb 2c		 jmp	 SHORT $LN16@IoThreadPr
$LN15@IoThreadPr:

; 396  : 							request->Item->Status = TCCachedRead (queue, NULL, request->Data, request->Offset, request->Length);

  00319	8b 55 f4	 mov	 edx, DWORD PTR _request$[ebp]
  0031c	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0031f	50		 push	 eax
  00320	8b 4d f4	 mov	 ecx, DWORD PTR _request$[ebp]
  00323	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00326	52		 push	 edx
  00327	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0032a	50		 push	 eax
  0032b	8b 4d f4	 mov	 ecx, DWORD PTR _request$[ebp]
  0032e	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00331	52		 push	 edx
  00332	6a 00		 push	 0
  00334	8b 45 f8	 mov	 eax, DWORD PTR _queue$[ebp]
  00337	50		 push	 eax
  00338	e8 00 00 00 00	 call	 _TCCachedRead@24
  0033d	8b 4d f4	 mov	 ecx, DWORD PTR _request$[ebp]
  00340	8b 11		 mov	 edx, DWORD PTR [ecx]
  00342	89 42 18	 mov	 DWORD PTR [edx+24], eax
$LN16@IoThreadPr:

; 397  : 					}
; 398  : 				}
; 399  : 				else

  00345	e9 93 00 00 00	 jmp	 $LN34@IoThreadPr
$LN33@IoThreadPr:

; 400  : 				{
; 401  : 					IO_STATUS_BLOCK ioStatus;
; 402  : 
; 403  : 					if (request->Item->Write)

  0034a	8b 45 f4	 mov	 eax, DWORD PTR _request$[ebp]
  0034d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0034f	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00353	74 38		 je	 SHORT $LN12@IoThreadPr

; 404  : 						request->Item->Status = ZwWriteFile (queue->HostFileHandle, NULL, NULL, NULL, &ioStatus, request->Data, request->Length, &request->Offset, NULL);

  00355	6a 00		 push	 0
  00357	8b 55 f4	 mov	 edx, DWORD PTR _request$[ebp]
  0035a	83 c2 08	 add	 edx, 8
  0035d	52		 push	 edx
  0035e	8b 45 f4	 mov	 eax, DWORD PTR _request$[ebp]
  00361	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00364	51		 push	 ecx
  00365	8b 55 f4	 mov	 edx, DWORD PTR _request$[ebp]
  00368	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0036b	50		 push	 eax
  0036c	8d 4d c8	 lea	 ecx, DWORD PTR _ioStatus$27975[ebp]
  0036f	51		 push	 ecx
  00370	6a 00		 push	 0
  00372	6a 00		 push	 0
  00374	6a 00		 push	 0
  00376	8b 55 f8	 mov	 edx, DWORD PTR _queue$[ebp]
  00379	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0037c	50		 push	 eax
  0037d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwWriteFile@36
  00383	8b 4d f4	 mov	 ecx, DWORD PTR _request$[ebp]
  00386	8b 11		 mov	 edx, DWORD PTR [ecx]
  00388	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 405  : 					else

  0038b	eb 2e		 jmp	 SHORT $LN11@IoThreadPr
$LN12@IoThreadPr:

; 406  : 						request->Item->Status = TCCachedRead (queue, &ioStatus, request->Data, request->Offset, request->Length);

  0038d	8b 45 f4	 mov	 eax, DWORD PTR _request$[ebp]
  00390	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00393	51		 push	 ecx
  00394	8b 55 f4	 mov	 edx, DWORD PTR _request$[ebp]
  00397	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0039a	50		 push	 eax
  0039b	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0039e	51		 push	 ecx
  0039f	8b 55 f4	 mov	 edx, DWORD PTR _request$[ebp]
  003a2	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  003a5	50		 push	 eax
  003a6	8d 4d c8	 lea	 ecx, DWORD PTR _ioStatus$27975[ebp]
  003a9	51		 push	 ecx
  003aa	8b 55 f8	 mov	 edx, DWORD PTR _queue$[ebp]
  003ad	52		 push	 edx
  003ae	e8 00 00 00 00	 call	 _TCCachedRead@24
  003b3	8b 4d f4	 mov	 ecx, DWORD PTR _request$[ebp]
  003b6	8b 11		 mov	 edx, DWORD PTR [ecx]
  003b8	89 42 18	 mov	 DWORD PTR [edx+24], eax
$LN11@IoThreadPr:

; 407  : 
; 408  : 					if (NT_SUCCESS (request->Item->Status) && ioStatus.Information != request->Length)

  003bb	8b 45 f4	 mov	 eax, DWORD PTR _request$[ebp]
  003be	8b 08		 mov	 ecx, DWORD PTR [eax]
  003c0	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  003c4	7c 17		 jl	 SHORT $LN34@IoThreadPr
  003c6	8b 55 f4	 mov	 edx, DWORD PTR _request$[ebp]
  003c9	8b 45 cc	 mov	 eax, DWORD PTR _ioStatus$27975[ebp+4]
  003cc	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  003cf	74 0c		 je	 SHORT $LN34@IoThreadPr

; 409  : 						request->Item->Status = STATUS_END_OF_FILE;

  003d1	8b 4d f4	 mov	 ecx, DWORD PTR _request$[ebp]
  003d4	8b 11		 mov	 edx, DWORD PTR [ecx]
  003d6	c7 42 18 11 00
	00 c0		 mov	 DWORD PTR [edx+24], -1073741807 ; c0000011H
$LN34@IoThreadPr:

; 410  : 				}
; 411  : 			}
; 412  : 
; 413  : 			if (request->Item->Write)

  003dd	8b 45 f4	 mov	 eax, DWORD PTR _request$[ebp]
  003e0	8b 08		 mov	 ecx, DWORD PTR [eax]
  003e2	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  003e6	74 6f		 je	 SHORT $LN9@IoThreadPr

; 414  : 			{
; 415  : 				queue->ReadAheadBufferValid = FALSE;

  003e8	8b 55 f8	 mov	 edx, DWORD PTR _queue$[ebp]
  003eb	c7 82 50 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+336], 0

; 416  : 
; 417  : 				ReleaseFragmentBuffer (queue, request->Data);

  003f5	8b 45 f4	 mov	 eax, DWORD PTR _request$[ebp]
  003f8	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  003fb	51		 push	 ecx
  003fc	8b 55 f8	 mov	 edx, DWORD PTR _queue$[ebp]
  003ff	52		 push	 edx
  00400	e8 00 00 00 00	 call	 _ReleaseFragmentBuffer@8

; 418  : 
; 419  : 				if (request->CompleteOriginalIrp)

  00405	8b 45 f4	 mov	 eax, DWORD PTR _request$[ebp]
  00408	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0040c	74 37		 je	 SHORT $LN8@IoThreadPr

; 420  : 				{
; 421  : 					CompleteOriginalIrp (request->Item, request->Item->Status,
; 422  : 						NT_SUCCESS (request->Item->Status) ? request->Item->OriginalLength : 0);

  0040e	8b 4d f4	 mov	 ecx, DWORD PTR _request$[ebp]
  00411	8b 11		 mov	 edx, DWORD PTR [ecx]
  00413	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  00417	7c 0d		 jl	 SHORT $LN46@IoThreadPr
  00419	8b 45 f4	 mov	 eax, DWORD PTR _request$[ebp]
  0041c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0041e	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00421	89 55 b0	 mov	 DWORD PTR tv282[ebp], edx
  00424	eb 07		 jmp	 SHORT $LN47@IoThreadPr
$LN46@IoThreadPr:
  00426	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv282[ebp], 0
$LN47@IoThreadPr:
  0042d	8b 45 b0	 mov	 eax, DWORD PTR tv282[ebp]
  00430	50		 push	 eax
  00431	8b 4d f4	 mov	 ecx, DWORD PTR _request$[ebp]
  00434	8b 11		 mov	 edx, DWORD PTR [ecx]
  00436	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00439	50		 push	 eax
  0043a	8b 4d f4	 mov	 ecx, DWORD PTR _request$[ebp]
  0043d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0043f	52		 push	 edx
  00440	e8 00 00 00 00	 call	 _CompleteOriginalIrp@12
$LN8@IoThreadPr:

; 423  : 				}
; 424  : 
; 425  : 				ReleasePoolBuffer (queue, request);

  00445	8b 45 f4	 mov	 eax, DWORD PTR _request$[ebp]
  00448	50		 push	 eax
  00449	8b 4d f8	 mov	 ecx, DWORD PTR _queue$[ebp]
  0044c	51		 push	 ecx
  0044d	e8 00 00 00 00	 call	 _ReleasePoolBuffer@8

; 426  : 			}
; 427  : 			else

  00452	e9 12 02 00 00	 jmp	 $LN7@IoThreadPr
$LN9@IoThreadPr:

; 428  : 			{
; 429  : 				BOOL readAhead = FALSE;

  00457	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _readAhead$27989[ebp], 0

; 430  : 
; 431  : 				if (NT_SUCCESS (request->Item->Status))

  0045e	8b 55 f4	 mov	 edx, DWORD PTR _request$[ebp]
  00461	8b 02		 mov	 eax, DWORD PTR [edx]
  00463	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00467	7c 1d		 jl	 SHORT $LN6@IoThreadPr

; 432  : 					memcpy (request->OrigDataBufferFragment, request->Data, request->Length);

  00469	8b 4d f4	 mov	 ecx, DWORD PTR _request$[ebp]
  0046c	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0046f	52		 push	 edx
  00470	8b 45 f4	 mov	 eax, DWORD PTR _request$[ebp]
  00473	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00476	51		 push	 ecx
  00477	8b 55 f4	 mov	 edx, DWORD PTR _request$[ebp]
  0047a	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0047d	50		 push	 eax
  0047e	e8 00 00 00 00	 call	 _memcpy
  00483	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@IoThreadPr:

; 433  : 
; 434  : 				ReleaseFragmentBuffer (queue, request->Data);

  00486	8b 4d f4	 mov	 ecx, DWORD PTR _request$[ebp]
  00489	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0048c	52		 push	 edx
  0048d	8b 45 f8	 mov	 eax, DWORD PTR _queue$[ebp]
  00490	50		 push	 eax
  00491	e8 00 00 00 00	 call	 _ReleaseFragmentBuffer@8

; 435  : 				request->Data = request->OrigDataBufferFragment;

  00496	8b 4d f4	 mov	 ecx, DWORD PTR _request$[ebp]
  00499	8b 55 f4	 mov	 edx, DWORD PTR _request$[ebp]
  0049c	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0049f	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 436  : 
; 437  : 				if (request->CompleteOriginalIrp
; 438  : 					&& queue->LastReadLength > 0
; 439  : 					&& NT_SUCCESS (request->Item->Status)
; 440  : 					&& InterlockedExchangeAdd (&queue->IoThreadPendingRequestCount, 0) == 0)

  004a2	8b 4d f4	 mov	 ecx, DWORD PTR _request$[ebp]
  004a5	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  004a9	74 42		 je	 SHORT $LN5@IoThreadPr
  004ab	8b 55 f8	 mov	 edx, DWORD PTR _queue$[ebp]
  004ae	83 ba 60 01 00
	00 00		 cmp	 DWORD PTR [edx+352], 0
  004b5	76 36		 jbe	 SHORT $LN5@IoThreadPr
  004b7	8b 45 f4	 mov	 eax, DWORD PTR _request$[ebp]
  004ba	8b 08		 mov	 ecx, DWORD PTR [eax]
  004bc	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  004c0	7c 2b		 jl	 SHORT $LN5@IoThreadPr
  004c2	33 d2		 xor	 edx, edx
  004c4	8b 45 f8	 mov	 eax, DWORD PTR _queue$[ebp]
  004c7	05 94 01 00 00	 add	 eax, 404		; 00000194H
  004cc	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  004d0	85 d2		 test	 edx, edx
  004d2	75 19		 jne	 SHORT $LN5@IoThreadPr

; 441  : 				{
; 442  : 					readAhead = TRUE;

  004d4	c7 45 c4 01 00
	00 00		 mov	 DWORD PTR _readAhead$27989[ebp], 1

; 443  : 					InterlockedIncrement (&queue->OutstandingIoCount);

  004db	8b 4d f8	 mov	 ecx, DWORD PTR _queue$[ebp]
  004de	81 c1 80 01 00
	00		 add	 ecx, 384		; 00000180H
  004e4	ba 01 00 00 00	 mov	 edx, 1
  004e9	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
$LN5@IoThreadPr:

; 444  : 				}
; 445  : 
; 446  : 				ExInterlockedInsertTailList (&queue->CompletionThreadQueue, &request->CompletionListEntry, &queue->CompletionThreadQueueLock);

  004ed	8b 45 f8	 mov	 eax, DWORD PTR _queue$[ebp]
  004f0	05 14 01 00 00	 add	 eax, 276		; 00000114H
  004f5	50		 push	 eax
  004f6	8b 55 f4	 mov	 edx, DWORD PTR _request$[ebp]
  004f9	83 c2 34	 add	 edx, 52			; 00000034H
  004fc	8b 4d f8	 mov	 ecx, DWORD PTR _queue$[ebp]
  004ff	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  00505	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExfInterlockedInsertTailList@12

; 447  : 				KeSetEvent (&queue->CompletionThreadQueueNotEmptyEvent, IO_DISK_INCREMENT, FALSE);

  0050b	6a 00		 push	 0
  0050d	6a 01		 push	 1
  0050f	8b 4d f8	 mov	 ecx, DWORD PTR _queue$[ebp]
  00512	81 c1 18 01 00
	00		 add	 ecx, 280		; 00000118H
  00518	51		 push	 ecx
  00519	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 448  : 
; 449  : 				if (readAhead)

  0051f	83 7d c4 00	 cmp	 DWORD PTR _readAhead$27989[ebp], 0
  00523	0f 84 40 01 00
	00		 je	 $LN7@IoThreadPr

; 450  : 				{
; 451  : 					queue->ReadAheadBufferValid = FALSE;

  00529	8b 55 f8	 mov	 edx, DWORD PTR _queue$[ebp]
  0052c	c7 82 50 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+336], 0

; 452  : 					queue->ReadAheadOffset.QuadPart = queue->LastReadOffset.QuadPart + queue->LastReadLength;

  00536	8b 45 f8	 mov	 eax, DWORD PTR _queue$[ebp]
  00539	8b 88 60 01 00
	00		 mov	 ecx, DWORD PTR [eax+352]
  0053f	33 d2		 xor	 edx, edx
  00541	8b 45 f8	 mov	 eax, DWORD PTR _queue$[ebp]
  00544	03 88 58 01 00
	00		 add	 ecx, DWORD PTR [eax+344]
  0054a	8b 80 5c 01 00
	00		 mov	 eax, DWORD PTR [eax+348]
  00550	13 c2		 adc	 eax, edx
  00552	8b 55 f8	 mov	 edx, DWORD PTR _queue$[ebp]
  00555	89 8a 68 01 00
	00		 mov	 DWORD PTR [edx+360], ecx
  0055b	89 82 6c 01 00
	00		 mov	 DWORD PTR [edx+364], eax

; 453  : 					queue->ReadAheadLength = queue->LastReadLength;

  00561	8b 45 f8	 mov	 eax, DWORD PTR _queue$[ebp]
  00564	8b 4d f8	 mov	 ecx, DWORD PTR _queue$[ebp]
  00567	8b 91 60 01 00
	00		 mov	 edx, DWORD PTR [ecx+352]
  0056d	89 90 70 01 00
	00		 mov	 DWORD PTR [eax+368], edx

; 454  : 
; 455  : 					if (queue->ReadAheadOffset.QuadPart + queue->ReadAheadLength <= queue->MaxReadAheadOffset.QuadPart)

  00573	8b 45 f8	 mov	 eax, DWORD PTR _queue$[ebp]
  00576	8b 88 70 01 00
	00		 mov	 ecx, DWORD PTR [eax+368]
  0057c	33 d2		 xor	 edx, edx
  0057e	8b 45 f8	 mov	 eax, DWORD PTR _queue$[ebp]
  00581	03 88 68 01 00
	00		 add	 ecx, DWORD PTR [eax+360]
  00587	8b 80 6c 01 00
	00		 mov	 eax, DWORD PTR [eax+364]
  0058d	13 c2		 adc	 eax, edx
  0058f	8b 55 f8	 mov	 edx, DWORD PTR _queue$[ebp]
  00592	89 4d a8	 mov	 DWORD PTR tv647[ebp], ecx
  00595	89 45 ac	 mov	 DWORD PTR tv647[ebp+4], eax
  00598	89 55 a4	 mov	 DWORD PTR tv650[ebp], edx
  0059b	8b 45 a4	 mov	 eax, DWORD PTR tv650[ebp]
  0059e	8b 4d ac	 mov	 ecx, DWORD PTR tv647[ebp+4]
  005a1	3b 88 7c 01 00
	00		 cmp	 ecx, DWORD PTR [eax+380]
  005a7	0f 8f b3 00 00
	00		 jg	 $LN3@IoThreadPr
  005ad	7c 12		 jl	 SHORT $LN49@IoThreadPr
  005af	8b 55 a4	 mov	 edx, DWORD PTR tv650[ebp]
  005b2	8b 45 a8	 mov	 eax, DWORD PTR tv647[ebp]
  005b5	3b 82 78 01 00
	00		 cmp	 eax, DWORD PTR [edx+376]
  005bb	0f 87 9f 00 00
	00		 ja	 $LN3@IoThreadPr
$LN49@IoThreadPr:

; 456  : 					{
; 457  : #ifdef TC_TRACE_IO_QUEUE
; 458  : 						Dump ("A   %I64d [%I64d] roff=%I64d rlen=%d\n", request->Item->OriginalIrpOffset.QuadPart, GetElapsedTime (&queue->LastPerformanceCounter), queue->ReadAheadOffset, queue->ReadAheadLength);
; 459  : #endif
; 460  : 						if (queue->IsFilterDevice)

  005c1	8b 4d f8	 mov	 ecx, DWORD PTR _queue$[ebp]
  005c4	83 79 3c 00	 cmp	 DWORD PTR [ecx+60], 0
  005c8	74 43		 je	 SHORT $LN2@IoThreadPr

; 461  : 						{
; 462  : 							queue->ReadAheadBufferValid = NT_SUCCESS (TCReadDevice (queue->LowerDeviceObject, queue->ReadAheadBuffer, queue->ReadAheadOffset, queue->ReadAheadLength));

  005ca	8b 55 f8	 mov	 edx, DWORD PTR _queue$[ebp]
  005cd	8b 82 70 01 00
	00		 mov	 eax, DWORD PTR [edx+368]
  005d3	50		 push	 eax
  005d4	8b 4d f8	 mov	 ecx, DWORD PTR _queue$[ebp]
  005d7	8b 91 6c 01 00
	00		 mov	 edx, DWORD PTR [ecx+364]
  005dd	52		 push	 edx
  005de	8b 81 68 01 00
	00		 mov	 eax, DWORD PTR [ecx+360]
  005e4	50		 push	 eax
  005e5	8b 4d f8	 mov	 ecx, DWORD PTR _queue$[ebp]
  005e8	8b 91 74 01 00
	00		 mov	 edx, DWORD PTR [ecx+372]
  005ee	52		 push	 edx
  005ef	8b 45 f8	 mov	 eax, DWORD PTR _queue$[ebp]
  005f2	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  005f5	51		 push	 ecx
  005f6	e8 00 00 00 00	 call	 _TCReadDevice@20
  005fb	33 d2		 xor	 edx, edx
  005fd	85 c0		 test	 eax, eax
  005ff	0f 9d c2	 setge	 dl
  00602	8b 45 f8	 mov	 eax, DWORD PTR _queue$[ebp]
  00605	89 90 50 01 00
	00		 mov	 DWORD PTR [eax+336], edx

; 463  : 						}
; 464  : 						else

  0060b	eb 53		 jmp	 SHORT $LN3@IoThreadPr
$LN2@IoThreadPr:

; 465  : 						{
; 466  : 							IO_STATUS_BLOCK ioStatus;
; 467  : 							queue->ReadAheadBufferValid = NT_SUCCESS (ZwReadFile (queue->HostFileHandle, NULL, NULL, NULL, &ioStatus, queue->ReadAheadBuffer, queue->ReadAheadLength, &queue->ReadAheadOffset, NULL));

  0060d	6a 00		 push	 0
  0060f	8b 4d f8	 mov	 ecx, DWORD PTR _queue$[ebp]
  00612	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  00618	51		 push	 ecx
  00619	8b 55 f8	 mov	 edx, DWORD PTR _queue$[ebp]
  0061c	8b 82 70 01 00
	00		 mov	 eax, DWORD PTR [edx+368]
  00622	50		 push	 eax
  00623	8b 4d f8	 mov	 ecx, DWORD PTR _queue$[ebp]
  00626	8b 91 74 01 00
	00		 mov	 edx, DWORD PTR [ecx+372]
  0062c	52		 push	 edx
  0062d	8d 45 bc	 lea	 eax, DWORD PTR _ioStatus$27999[ebp]
  00630	50		 push	 eax
  00631	6a 00		 push	 0
  00633	6a 00		 push	 0
  00635	6a 00		 push	 0
  00637	8b 4d f8	 mov	 ecx, DWORD PTR _queue$[ebp]
  0063a	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  0063d	52		 push	 edx
  0063e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwReadFile@36
  00644	33 c9		 xor	 ecx, ecx
  00646	85 c0		 test	 eax, eax
  00648	0f 9d c1	 setge	 cl
  0064b	8b 55 f8	 mov	 edx, DWORD PTR _queue$[ebp]
  0064e	89 8a 50 01 00
	00		 mov	 DWORD PTR [edx+336], ecx

; 468  : 							queue->ReadAheadLength = (ULONG) ioStatus.Information;

  00654	8b 45 f8	 mov	 eax, DWORD PTR _queue$[ebp]
  00657	8b 4d c0	 mov	 ecx, DWORD PTR _ioStatus$27999[ebp+4]
  0065a	89 88 70 01 00
	00		 mov	 DWORD PTR [eax+368], ecx
$LN3@IoThreadPr:

; 469  : 						}
; 470  : 					}
; 471  : 
; 472  : 					DecrementOutstandingIoCount (queue);

  00660	8b 55 f8	 mov	 edx, DWORD PTR _queue$[ebp]
  00663	52		 push	 edx
  00664	e8 00 00 00 00	 call	 _DecrementOutstandingIoCount@4
$LN7@IoThreadPr:

; 473  : 				}
; 474  : 			}
; 475  : 		}

  00669	e9 40 fa ff ff	 jmp	 $LN36@IoThreadPr
$LN35@IoThreadPr:

; 476  : 	}

  0066e	e9 fd f9 ff ff	 jmp	 $LN40@IoThreadPr
$LN39@IoThreadPr:

; 477  : 
; 478  : 	PsTerminateSystemThread (STATUS_SUCCESS);

  00673	6a 00		 push	 0
  00675	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsTerminateSystemThread@4

; 479  : }

  0067b	5f		 pop	 edi
  0067c	5e		 pop	 esi
  0067d	8b e5		 mov	 esp, ebp
  0067f	5d		 pop	 ebp
  00680	c2 04 00	 ret	 4
_IoThreadProc@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _ReleaseFragmentBuffer@8
_TEXT	SEGMENT
_queue$ = 8						; size = 4
_buffer$ = 12						; size = 4
_ReleaseFragmentBuffer@8 PROC				; COMDAT

; 208  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 209  : 	if (buffer == queue->FragmentBufferA)

  00005	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0000b	3b 88 28 01 00
	00		 cmp	 ecx, DWORD PTR [eax+296]
  00011	75 16		 jne	 SHORT $LN4@ReleaseFra

; 210  : 	{
; 211  : 		KeSetEvent (&queue->FragmentBufferAFreeEvent, IO_DISK_INCREMENT, FALSE);

  00013	6a 00		 push	 0
  00015	6a 01		 push	 1
  00017	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  0001a	81 c2 30 01 00
	00		 add	 edx, 304		; 00000130H
  00020	52		 push	 edx
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
  00027	eb 3d		 jmp	 SHORT $LN6@ReleaseFra
$LN4@ReleaseFra:

; 212  : 	}
; 213  : 	else if (buffer == queue->FragmentBufferB)

  00029	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0002f	3b 88 2c 01 00
	00		 cmp	 ecx, DWORD PTR [eax+300]
  00035	75 16		 jne	 SHORT $LN2@ReleaseFra

; 214  : 	{
; 215  : 		KeSetEvent (&queue->FragmentBufferBFreeEvent, IO_DISK_INCREMENT, FALSE);

  00037	6a 00		 push	 0
  00039	6a 01		 push	 1
  0003b	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  0003e	81 c2 40 01 00
	00		 add	 edx, 320		; 00000140H
  00044	52		 push	 edx
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 216  : 	}
; 217  : 	else

  0004b	eb 19		 jmp	 SHORT $LN6@ReleaseFra
$LN2@ReleaseFra:

; 218  : 	{
; 219  : 		TC_BUG_CHECK (STATUS_INVALID_PARAMETER);

  0004d	68 43 54 00 00	 push	 21571			; 00005443H
  00052	6a 00		 push	 0
  00054	68 0d 00 00 c0	 push	 -1073741811		; c000000dH
  00059	68 db 00 00 00	 push	 219			; 000000dbH
  0005e	6a 29		 push	 41			; 00000029H
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN6@ReleaseFra:

; 220  : 	}
; 221  : }

  00066	5d		 pop	 ebp
  00067	c2 08 00	 ret	 8
_ReleaseFragmentBuffer@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _TCCachedRead@24
_TEXT	SEGMENT
tv138 = -4						; size = 4
_queue$ = 8						; size = 4
_ioStatus$ = 12						; size = 4
_buffer$ = 16						; size = 4
_offset$ = 20						; size = 8
_length$ = 28						; size = 4
_TCCachedRead@24 PROC					; COMDAT

; 274  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 275  : 	queue->LastReadOffset = offset;

  00006	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  00009	8b 4d 14	 mov	 ecx, DWORD PTR _offset$[ebp]
  0000c	89 88 58 01 00
	00		 mov	 DWORD PTR [eax+344], ecx
  00012	8b 55 18	 mov	 edx, DWORD PTR _offset$[ebp+4]
  00015	89 90 5c 01 00
	00		 mov	 DWORD PTR [eax+348], edx

; 276  : 	queue->LastReadLength = length;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  0001e	8b 4d 1c	 mov	 ecx, DWORD PTR _length$[ebp]
  00021	89 88 60 01 00
	00		 mov	 DWORD PTR [eax+352], ecx

; 277  : 
; 278  : 	if (queue->ReadAheadBufferValid && queue->ReadAheadOffset.QuadPart == offset.QuadPart && queue->ReadAheadLength >= length)

  00027	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  0002a	83 ba 50 01 00
	00 00		 cmp	 DWORD PTR [edx+336], 0
  00031	74 69		 je	 SHORT $LN3@TCCachedRe
  00033	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  00036	89 45 fc	 mov	 DWORD PTR tv138[ebp], eax
  00039	8b 4d fc	 mov	 ecx, DWORD PTR tv138[ebp]
  0003c	8b 91 68 01 00
	00		 mov	 edx, DWORD PTR [ecx+360]
  00042	3b 55 14	 cmp	 edx, DWORD PTR _offset$[ebp]
  00045	75 55		 jne	 SHORT $LN3@TCCachedRe
  00047	8b 45 fc	 mov	 eax, DWORD PTR tv138[ebp]
  0004a	8b 88 6c 01 00
	00		 mov	 ecx, DWORD PTR [eax+364]
  00050	3b 4d 18	 cmp	 ecx, DWORD PTR _offset$[ebp+4]
  00053	75 47		 jne	 SHORT $LN3@TCCachedRe
  00055	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  00058	8b 82 70 01 00
	00		 mov	 eax, DWORD PTR [edx+368]
  0005e	3b 45 1c	 cmp	 eax, DWORD PTR _length$[ebp]
  00061	72 39		 jb	 SHORT $LN3@TCCachedRe

; 279  : 	{
; 280  : 		memcpy (buffer, queue->ReadAheadBuffer, length);

  00063	8b 4d 1c	 mov	 ecx, DWORD PTR _length$[ebp]
  00066	51		 push	 ecx
  00067	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  0006a	8b 82 74 01 00
	00		 mov	 eax, DWORD PTR [edx+372]
  00070	50		 push	 eax
  00071	8b 4d 10	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00074	51		 push	 ecx
  00075	e8 00 00 00 00	 call	 _memcpy
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 281  : 
; 282  : 		if (!queue->IsFilterDevice)

  0007d	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  00080	83 7a 3c 00	 cmp	 DWORD PTR [edx+60], 0
  00084	75 12		 jne	 SHORT $LN2@TCCachedRe

; 283  : 		{
; 284  : 			ioStatus->Information = length;

  00086	8b 45 0c	 mov	 eax, DWORD PTR _ioStatus$[ebp]
  00089	8b 4d 1c	 mov	 ecx, DWORD PTR _length$[ebp]
  0008c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 285  : 			ioStatus->Status = STATUS_SUCCESS;

  0008f	8b 55 0c	 mov	 edx, DWORD PTR _ioStatus$[ebp]
  00092	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$LN2@TCCachedRe:

; 286  : 		}
; 287  : 
; 288  : 		return STATUS_SUCCESS;

  00098	33 c0		 xor	 eax, eax
  0009a	eb 4c		 jmp	 SHORT $LN4@TCCachedRe
$LN3@TCCachedRe:

; 289  : 	}
; 290  : 
; 291  : 	if (queue->IsFilterDevice)

  0009c	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  0009f	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  000a3	74 1e		 je	 SHORT $LN1@TCCachedRe

; 292  : 		return TCReadDevice (queue->LowerDeviceObject, buffer, offset, length);

  000a5	8b 4d 1c	 mov	 ecx, DWORD PTR _length$[ebp]
  000a8	51		 push	 ecx
  000a9	8b 55 18	 mov	 edx, DWORD PTR _offset$[ebp+4]
  000ac	52		 push	 edx
  000ad	8b 45 14	 mov	 eax, DWORD PTR _offset$[ebp]
  000b0	50		 push	 eax
  000b1	8b 4d 10	 mov	 ecx, DWORD PTR _buffer$[ebp]
  000b4	51		 push	 ecx
  000b5	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  000b8	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 _TCReadDevice@20
  000c1	eb 25		 jmp	 SHORT $LN4@TCCachedRe
$LN1@TCCachedRe:

; 293  : 
; 294  : 	return ZwReadFile (queue->HostFileHandle, NULL, NULL, NULL, ioStatus, buffer, length, &offset, NULL);

  000c3	6a 00		 push	 0
  000c5	8d 4d 14	 lea	 ecx, DWORD PTR _offset$[ebp]
  000c8	51		 push	 ecx
  000c9	8b 55 1c	 mov	 edx, DWORD PTR _length$[ebp]
  000cc	52		 push	 edx
  000cd	8b 45 10	 mov	 eax, DWORD PTR _buffer$[ebp]
  000d0	50		 push	 eax
  000d1	8b 4d 0c	 mov	 ecx, DWORD PTR _ioStatus$[ebp]
  000d4	51		 push	 ecx
  000d5	6a 00		 push	 0
  000d7	6a 00		 push	 0
  000d9	6a 00		 push	 0
  000db	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  000de	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  000e1	50		 push	 eax
  000e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwReadFile@36
$LN4@TCCachedRe:

; 295  : }

  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c2 18 00	 ret	 24			; 00000018H
_TCCachedRead@24 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DI@GBCOIBFH@Preventing?5write?5to?5boot?5loader?5@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DJ@KOLNOKOK@Preventing?5write?5to?5the?5system?5e@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EP@IGAPPBIF@Hidden?5volume?5protection?5trigger@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	_EncryptDataUnits@16:PROC
EXTRN	_GetBootDriveLength@0:PROC
EXTRN	_IsHiddenSystemRunning@0:PROC
EXTRN	_RegionsOverlap@32:PROC
EXTRN	_GetIntersection@36:PROC
EXTRN	__imp__MmMapLockedPagesSpecifyCache@24:PROC
EXTRN	__aulldiv:PROC
;	COMDAT ??_C@_0DI@GBCOIBFH@Preventing?5write?5to?5boot?5loader?5@FNODOBFM@
text$s	SEGMENT
??_C@_0DI@GBCOIBFH@Preventing?5write?5to?5boot?5loader?5@FNODOBFM@ DB 'Pr'
	DB	'eventing write to boot loader or host protected area', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DJ@KOLNOKOK@Preventing?5write?5to?5the?5system?5e@FNODOBFM@
text$s	SEGMENT
??_C@_0DJ@KOLNOKOK@Preventing?5write?5to?5the?5system?5e@FNODOBFM@ DB 'Pr'
	DB	'eventing write to the system encryption key data area', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EP@IGAPPBIF@Hidden?5volume?5protection?5trigger@FNODOBFM@
text$s	SEGMENT
??_C@_0EP@IGAPPBIF@Hidden?5volume?5protection?5trigger@FNODOBFM@ DB 'Hidd'
	DB	'en volume protection triggered: write %I64d-%I64d (protected '
	DB	'%I64d-%I64d)', 0aH, 00H			;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _MainThreadProc@4
_TEXT	SEGMENT
tv490 = -200						; size = 4
tv1072 = -196						; size = 8
tv1069 = -188						; size = 8
tv1005 = -180						; size = 8
tv995 = -172						; size = 4
tv435 = -168						; size = 4
tv430 = -164						; size = 4
tv418 = -160						; size = 4
tv745 = -156						; size = 4
tv742 = -152						; size = 8
tv725 = -144						; size = 8
tv259 = -136						; size = 4
tv656 = -132						; size = 8
tv646 = -124						; size = 4
tv214 = -120						; size = 4
tv609 = -116						; size = 8
tv146 = -108						; size = 4
_dataUnit$28121 = -104					; size = 8
_isLastFragment$28111 = -96				; size = 4
_dataFragmentLength$28112 = -92				; size = 4
_dataUnit$28071 = -88					; size = 8
_alignedOffset$28064 = -80				; size = 8
_buffer$28062 = -68					; size = 4
_alignedLength$28063 = -64				; size = 4
_irpSp$28037 = -60					; size = 4
_irp$28032 = -56					; size = 4
_item$ = -52						; size = 4
_dataBuffer$ = -48					; size = 4
_request$ = -44						; size = 4
_queue$ = -40						; size = 4
_activeFragmentBuffer$ = -36				; size = 4
_listEntry$ = -32					; size = 4
_dataRemaining$ = -28					; size = 4
_fragmentOffset$ = -24					; size = 8
_intersectStart$ = -16					; size = 8
_intersectLength$ = -4					; size = 4
_threadArg$ = 8						; size = 4
_MainThreadProc@4 PROC					; COMDAT

; 483  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  0000b	56		 push	 esi
  0000c	57		 push	 edi

; 484  : 	EncryptedIoQueue *queue = (EncryptedIoQueue *) threadArg;

  0000d	8b 45 08	 mov	 eax, DWORD PTR _threadArg$[ebp]
  00010	89 45 d8	 mov	 DWORD PTR _queue$[ebp], eax

; 485  : 	PLIST_ENTRY listEntry;
; 486  : 	EncryptedIoQueueItem *item;
; 487  : 
; 488  : 	LARGE_INTEGER fragmentOffset;
; 489  : 	ULONG dataRemaining;
; 490  : 	PUCHAR activeFragmentBuffer = queue->FragmentBufferA;

  00013	8b 4d d8	 mov	 ecx, DWORD PTR _queue$[ebp]
  00016	8b 91 28 01 00
	00		 mov	 edx, DWORD PTR [ecx+296]
  0001c	89 55 dc	 mov	 DWORD PTR _activeFragmentBuffer$[ebp], edx

; 491  : 	PUCHAR dataBuffer;
; 492  : 	EncryptedIoRequest *request;
; 493  : 	uint64 intersectStart;
; 494  : 	uint32 intersectLength;
; 495  : 
; 496  : 	if (IsEncryptionThreadPoolRunning())

  0001f	e8 00 00 00 00	 call	 _IsEncryptionThreadPoolRunning@0
  00024	85 c0		 test	 eax, eax
  00026	74 0f		 je	 SHORT $LN45@MainThread

; 497  : 		KeSetPriorityThread (KeGetCurrentThread(), LOW_REALTIME_PRIORITY);

  00028	6a 10		 push	 16			; 00000010H
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeGetCurrentThread@0
  00030	50		 push	 eax
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetPriorityThread@8
$LN45@MainThread:

; 498  : 
; 499  : 	while (!queue->ThreadExitRequested)

  00037	8b 45 d8	 mov	 eax, DWORD PTR _queue$[ebp]
  0003a	83 b8 bc 01 00
	00 00		 cmp	 DWORD PTR [eax+444], 0
  00041	0f 85 22 0b 00
	00		 jne	 $LN44@MainThread

; 500  : 	{
; 501  : 		if (!NT_SUCCESS (KeWaitForSingleObject (&queue->MainThreadQueueNotEmptyEvent, Executive, KernelMode, FALSE, NULL)))

  00047	6a 00		 push	 0
  00049	6a 00		 push	 0
  0004b	6a 00		 push	 0
  0004d	6a 00		 push	 0
  0004f	8b 4d d8	 mov	 ecx, DWORD PTR _queue$[ebp]
  00052	81 c1 d8 00 00
	00		 add	 ecx, 216		; 000000d8H
  00058	51		 push	 ecx
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
  0005f	85 c0		 test	 eax, eax
  00061	7d 02		 jge	 SHORT $LN42@MainThread

; 502  : 			continue;

  00063	eb d2		 jmp	 SHORT $LN45@MainThread
$LN42@MainThread:

; 503  : 
; 504  : 		while ((listEntry = ExInterlockedRemoveHeadList (&queue->MainThreadQueue, &queue->MainThreadQueueLock)))

  00065	8b 55 d8	 mov	 edx, DWORD PTR _queue$[ebp]
  00068	81 c2 d4 00 00
	00		 add	 edx, 212		; 000000d4H
  0006e	8b 4d d8	 mov	 ecx, DWORD PTR _queue$[ebp]
  00071	81 c1 cc 00 00
	00		 add	 ecx, 204		; 000000ccH
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExfInterlockedRemoveHeadList@8
  0007d	89 45 e0	 mov	 DWORD PTR _listEntry$[ebp], eax
  00080	83 7d e0 00	 cmp	 DWORD PTR _listEntry$[ebp], 0
  00084	0f 84 da 0a 00
	00		 je	 $LN41@MainThread

; 505  : 		{
; 506  : 			PIRP irp = CONTAINING_RECORD (listEntry, IRP, Tail.Overlay.ListEntry);

  0008a	8b 55 e0	 mov	 edx, DWORD PTR _listEntry$[ebp]
  0008d	83 ea 58	 sub	 edx, 88			; 00000058H
  00090	89 55 c8	 mov	 DWORD PTR _irp$28032[ebp], edx

; 507  : 			PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (irp);

  00093	8b 45 c8	 mov	 eax, DWORD PTR _irp$28032[ebp]
  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 _IoGetCurrentIrpStackLocation@4
  0009c	89 45 c4	 mov	 DWORD PTR _irpSp$28037[ebp], eax

; 508  : 			
; 509  : 			if (queue->Suspended)

  0009f	8b 4d d8	 mov	 ecx, DWORD PTR _queue$[ebp]
  000a2	83 b9 c0 01 00
	00 00		 cmp	 DWORD PTR [ecx+448], 0
  000a9	74 18		 je	 SHORT $LN40@MainThread

; 510  : 				KeWaitForSingleObject (&queue->QueueResumedEvent, Executive, KernelMode, FALSE, NULL);

  000ab	6a 00		 push	 0
  000ad	6a 00		 push	 0
  000af	6a 00		 push	 0
  000b1	6a 00		 push	 0
  000b3	8b 55 d8	 mov	 edx, DWORD PTR _queue$[ebp]
  000b6	81 c2 cc 01 00
	00		 add	 edx, 460		; 000001ccH
  000bc	52		 push	 edx
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
$LN40@MainThread:

; 511  : 
; 512  : 			item = GetPoolBuffer (queue, sizeof (EncryptedIoQueueItem));

  000c3	6a 20		 push	 32			; 00000020H
  000c5	8b 45 d8	 mov	 eax, DWORD PTR _queue$[ebp]
  000c8	50		 push	 eax
  000c9	e8 00 00 00 00	 call	 _GetPoolBuffer@8
  000ce	89 45 cc	 mov	 DWORD PTR _item$[ebp], eax

; 513  : 			item->Queue = queue;

  000d1	8b 4d cc	 mov	 ecx, DWORD PTR _item$[ebp]
  000d4	8b 55 d8	 mov	 edx, DWORD PTR _queue$[ebp]
  000d7	89 11		 mov	 DWORD PTR [ecx], edx

; 514  : 			item->OriginalIrp = irp;

  000d9	8b 45 cc	 mov	 eax, DWORD PTR _item$[ebp]
  000dc	8b 4d c8	 mov	 ecx, DWORD PTR _irp$28032[ebp]
  000df	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 515  : 			item->Status = STATUS_SUCCESS;

  000e2	8b 55 cc	 mov	 edx, DWORD PTR _item$[ebp]
  000e5	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 516  : 
; 517  : 			IoSetCancelRoutine (irp, NULL);

  000ec	33 c0		 xor	 eax, eax
  000ee	8b 4d c8	 mov	 ecx, DWORD PTR _irp$28032[ebp]
  000f1	83 c1 38	 add	 ecx, 56			; 00000038H
  000f4	87 01		 xchg	 DWORD PTR [ecx], eax

; 518  : 			if (irp->Cancel)

  000f6	8b 55 c8	 mov	 edx, DWORD PTR _irp$28032[ebp]
  000f9	0f b6 42 24	 movzx	 eax, BYTE PTR [edx+36]
  000fd	85 c0		 test	 eax, eax
  000ff	74 15		 je	 SHORT $LN39@MainThread

; 519  : 			{
; 520  : 				CompleteOriginalIrp (item, STATUS_CANCELLED, 0);

  00101	6a 00		 push	 0
  00103	68 20 01 00 c0	 push	 -1073741536		; c0000120H
  00108	8b 4d cc	 mov	 ecx, DWORD PTR _item$[ebp]
  0010b	51		 push	 ecx
  0010c	e8 00 00 00 00	 call	 _CompleteOriginalIrp@12

; 521  : 				continue;

  00111	e9 4f ff ff ff	 jmp	 $LN42@MainThread
$LN39@MainThread:

; 522  : 			}
; 523  : 
; 524  : 			switch (irpSp->MajorFunction)

  00116	8b 55 c4	 mov	 edx, DWORD PTR _irpSp$28037[ebp]
  00119	8a 02		 mov	 al, BYTE PTR [edx]
  0011b	88 45 94	 mov	 BYTE PTR tv146[ebp], al
  0011e	80 7d 94 03	 cmp	 BYTE PTR tv146[ebp], 3
  00122	74 08		 je	 SHORT $LN36@MainThread
  00124	80 7d 94 04	 cmp	 BYTE PTR tv146[ebp], 4
  00128	74 2c		 je	 SHORT $LN35@MainThread
  0012a	eb 54		 jmp	 SHORT $LN34@MainThread
$LN36@MainThread:

; 525  : 			{
; 526  : 			case IRP_MJ_READ:
; 527  : 				item->Write = FALSE;

  0012c	8b 4d cc	 mov	 ecx, DWORD PTR _item$[ebp]
  0012f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 528  : 				item->OriginalOffset = irpSp->Parameters.Read.ByteOffset;

  00136	8b 55 c4	 mov	 edx, DWORD PTR _irpSp$28037[ebp]
  00139	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0013c	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  0013f	8b 55 cc	 mov	 edx, DWORD PTR _item$[ebp]
  00142	89 42 10	 mov	 DWORD PTR [edx+16], eax
  00145	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 529  : 				item->OriginalLength = irpSp->Parameters.Read.Length;

  00148	8b 45 cc	 mov	 eax, DWORD PTR _item$[ebp]
  0014b	8b 4d c4	 mov	 ecx, DWORD PTR _irpSp$28037[ebp]
  0014e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00151	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 530  : 				break;

  00154	eb 3f		 jmp	 SHORT $LN37@MainThread
$LN35@MainThread:

; 531  : 
; 532  : 			case IRP_MJ_WRITE:
; 533  : 				item->Write = TRUE;

  00156	8b 45 cc	 mov	 eax, DWORD PTR _item$[ebp]
  00159	c7 40 08 01 00
	00 00		 mov	 DWORD PTR [eax+8], 1

; 534  : 				item->OriginalOffset = irpSp->Parameters.Write.ByteOffset;

  00160	8b 4d c4	 mov	 ecx, DWORD PTR _irpSp$28037[ebp]
  00163	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00166	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00169	8b 4d cc	 mov	 ecx, DWORD PTR _item$[ebp]
  0016c	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0016f	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 535  : 				item->OriginalLength = irpSp->Parameters.Write.Length;

  00172	8b 55 cc	 mov	 edx, DWORD PTR _item$[ebp]
  00175	8b 45 c4	 mov	 eax, DWORD PTR _irpSp$28037[ebp]
  00178	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0017b	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 536  : 				break;

  0017e	eb 15		 jmp	 SHORT $LN37@MainThread
$LN34@MainThread:

; 537  : 
; 538  : 			default:
; 539  : 				CompleteOriginalIrp (item, STATUS_INVALID_PARAMETER, 0);

  00180	6a 00		 push	 0
  00182	68 0d 00 00 c0	 push	 -1073741811		; c000000dH
  00187	8b 55 cc	 mov	 edx, DWORD PTR _item$[ebp]
  0018a	52		 push	 edx
  0018b	e8 00 00 00 00	 call	 _CompleteOriginalIrp@12

; 540  : 				continue;

  00190	e9 d0 fe ff ff	 jmp	 $LN42@MainThread
$LN37@MainThread:

; 541  : 			}
; 542  : 
; 543  : #ifdef TC_TRACE_IO_QUEUE
; 544  : 			item->OriginalIrpOffset = item->OriginalOffset;
; 545  : #endif
; 546  : 
; 547  : 			// Handle misaligned read operations to work around a bug in Windows System Assessment Tool which does not follow FILE_FLAG_NO_BUFFERING requirements when benchmarking disk devices
; 548  : 			if (queue->IsFilterDevice
; 549  : 				&& !item->Write
; 550  : 				&& item->OriginalLength > 0
; 551  : 				&& (item->OriginalLength & (ENCRYPTION_DATA_UNIT_SIZE - 1)) == 0
; 552  : 				&& (item->OriginalOffset.QuadPart & (ENCRYPTION_DATA_UNIT_SIZE - 1)) != 0)

  00195	8b 45 d8	 mov	 eax, DWORD PTR _queue$[ebp]
  00198	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  0019c	0f 84 57 02 00
	00		 je	 $LN33@MainThread
  001a2	8b 4d cc	 mov	 ecx, DWORD PTR _item$[ebp]
  001a5	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  001a9	0f 85 4a 02 00
	00		 jne	 $LN33@MainThread
  001af	8b 55 cc	 mov	 edx, DWORD PTR _item$[ebp]
  001b2	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  001b6	0f 86 3d 02 00
	00		 jbe	 $LN33@MainThread
  001bc	8b 45 cc	 mov	 eax, DWORD PTR _item$[ebp]
  001bf	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001c2	81 e1 ff 01 00
	00		 and	 ecx, 511		; 000001ffH
  001c8	0f 85 2b 02 00
	00		 jne	 $LN33@MainThread
  001ce	8b 55 cc	 mov	 edx, DWORD PTR _item$[ebp]
  001d1	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  001d4	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  001d9	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  001dc	83 e1 00	 and	 ecx, 0
  001df	89 45 8c	 mov	 DWORD PTR tv609[ebp], eax
  001e2	89 4d 90	 mov	 DWORD PTR tv609[ebp+4], ecx
  001e5	8b 55 8c	 mov	 edx, DWORD PTR tv609[ebp]
  001e8	0b 55 90	 or	 edx, DWORD PTR tv609[ebp+4]
  001eb	0f 84 08 02 00
	00		 je	 $LN33@MainThread

; 553  : 			{
; 554  : 				byte *buffer;
; 555  : 				ULONG alignedLength = item->OriginalLength + ENCRYPTION_DATA_UNIT_SIZE;

  001f1	8b 45 cc	 mov	 eax, DWORD PTR _item$[ebp]
  001f4	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001f7	81 c1 00 02 00
	00		 add	 ecx, 512		; 00000200H
  001fd	89 4d c0	 mov	 DWORD PTR _alignedLength$28063[ebp], ecx

; 556  : 				LARGE_INTEGER alignedOffset;
; 557  : 				alignedOffset.QuadPart = item->OriginalOffset.QuadPart & ~((LONGLONG) ENCRYPTION_DATA_UNIT_SIZE - 1);

  00200	8b 55 cc	 mov	 edx, DWORD PTR _item$[ebp]
  00203	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00206	25 00 fe ff ff	 and	 eax, -512		; fffffe00H
  0020b	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  0020e	89 45 b0	 mov	 DWORD PTR _alignedOffset$28064[ebp], eax
  00211	89 4d b4	 mov	 DWORD PTR _alignedOffset$28064[ebp+4], ecx

; 558  : 
; 559  : 				buffer = TCalloc (alignedLength);

  00214	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00219	8b 55 c0	 mov	 edx, DWORD PTR _alignedLength$28063[ebp]
  0021c	52		 push	 edx
  0021d	6a 00		 push	 0
  0021f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00225	89 45 bc	 mov	 DWORD PTR _buffer$28062[ebp], eax

; 560  : 				if (!buffer)

  00228	83 7d bc 00	 cmp	 DWORD PTR _buffer$28062[ebp], 0
  0022c	75 15		 jne	 SHORT $LN32@MainThread

; 561  : 				{
; 562  : 					CompleteOriginalIrp (item, STATUS_INSUFFICIENT_RESOURCES, 0);

  0022e	6a 00		 push	 0
  00230	68 9a 00 00 c0	 push	 -1073741670		; c000009aH
  00235	8b 45 cc	 mov	 eax, DWORD PTR _item$[ebp]
  00238	50		 push	 eax
  00239	e8 00 00 00 00	 call	 _CompleteOriginalIrp@12

; 563  : 					continue;

  0023e	e9 22 fe ff ff	 jmp	 $LN42@MainThread
$LN32@MainThread:

; 564  : 				}
; 565  : 
; 566  : 				item->Status = TCReadDevice (queue->LowerDeviceObject, buffer, alignedOffset, alignedLength);

  00243	8b 4d c0	 mov	 ecx, DWORD PTR _alignedLength$28063[ebp]
  00246	51		 push	 ecx
  00247	8b 55 b4	 mov	 edx, DWORD PTR _alignedOffset$28064[ebp+4]
  0024a	52		 push	 edx
  0024b	8b 45 b0	 mov	 eax, DWORD PTR _alignedOffset$28064[ebp]
  0024e	50		 push	 eax
  0024f	8b 4d bc	 mov	 ecx, DWORD PTR _buffer$28062[ebp]
  00252	51		 push	 ecx
  00253	8b 55 d8	 mov	 edx, DWORD PTR _queue$[ebp]
  00256	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00259	50		 push	 eax
  0025a	e8 00 00 00 00	 call	 _TCReadDevice@20
  0025f	8b 4d cc	 mov	 ecx, DWORD PTR _item$[ebp]
  00262	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 567  : 
; 568  : 				if (NT_SUCCESS (item->Status))

  00265	8b 55 cc	 mov	 edx, DWORD PTR _item$[ebp]
  00268	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  0026c	0f 8c 3b 01 00
	00		 jl	 $LN31@MainThread

; 569  : 				{
; 570  : 					UINT64_STRUCT dataUnit;
; 571  : 
; 572  : 					dataBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe (irp->MdlAddress, HighPagePriority);

  00272	8b 45 c8	 mov	 eax, DWORD PTR _irp$28032[ebp]
  00275	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00278	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  0027c	83 e2 05	 and	 edx, 5
  0027f	74 0e		 je	 SHORT $LN49@MainThread
  00281	8b 45 c8	 mov	 eax, DWORD PTR _irp$28032[ebp]
  00284	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00287	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0028a	89 55 88	 mov	 DWORD PTR tv214[ebp], edx
  0028d	eb 1a		 jmp	 SHORT $LN50@MainThread
$LN49@MainThread:
  0028f	6a 20		 push	 32			; 00000020H
  00291	6a 00		 push	 0
  00293	6a 00		 push	 0
  00295	6a 01		 push	 1
  00297	6a 00		 push	 0
  00299	8b 45 c8	 mov	 eax, DWORD PTR _irp$28032[ebp]
  0029c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0029f	51		 push	 ecx
  002a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmMapLockedPagesSpecifyCache@24
  002a6	89 45 88	 mov	 DWORD PTR tv214[ebp], eax
$LN50@MainThread:
  002a9	8b 55 88	 mov	 edx, DWORD PTR tv214[ebp]
  002ac	89 55 d0	 mov	 DWORD PTR _dataBuffer$[ebp], edx

; 573  : 					if (!dataBuffer)

  002af	83 7d d0 00	 cmp	 DWORD PTR _dataBuffer$[ebp], 0
  002b3	75 24		 jne	 SHORT $LN30@MainThread

; 574  : 					{
; 575  : 						TCfree (buffer);

  002b5	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  002ba	8b 45 bc	 mov	 eax, DWORD PTR _buffer$28062[ebp]
  002bd	50		 push	 eax
  002be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 576  : 						CompleteOriginalIrp (item, STATUS_INSUFFICIENT_RESOURCES, 0);

  002c4	6a 00		 push	 0
  002c6	68 9a 00 00 c0	 push	 -1073741670		; c000009aH
  002cb	8b 4d cc	 mov	 ecx, DWORD PTR _item$[ebp]
  002ce	51		 push	 ecx
  002cf	e8 00 00 00 00	 call	 _CompleteOriginalIrp@12

; 577  : 						continue;

  002d4	e9 8c fd ff ff	 jmp	 $LN42@MainThread
$LN30@MainThread:

; 578  : 					}
; 579  : 
; 580  : 					if (queue->EncryptedAreaStart != -1 && queue->EncryptedAreaEnd != -1)

  002d9	8b 55 d8	 mov	 edx, DWORD PTR _queue$[ebp]
  002dc	89 55 84	 mov	 DWORD PTR tv646[ebp], edx
  002df	8b 45 84	 mov	 eax, DWORD PTR tv646[ebp]
  002e2	8b 4d 84	 mov	 ecx, DWORD PTR tv646[ebp]
  002e5	8b 50 48	 mov	 edx, DWORD PTR [eax+72]
  002e8	23 51 4c	 and	 edx, DWORD PTR [ecx+76]
  002eb	83 fa ff	 cmp	 edx, -1
  002ee	0f 84 96 00 00
	00		 je	 $LN29@MainThread
  002f4	8b 45 d8	 mov	 eax, DWORD PTR _queue$[ebp]
  002f7	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  002fa	8b 50 54	 mov	 edx, DWORD PTR [eax+84]
  002fd	89 8d 7c ff ff
	ff		 mov	 DWORD PTR tv656[ebp], ecx
  00303	89 55 80	 mov	 DWORD PTR tv656[ebp+4], edx
  00306	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv656[ebp]
  0030c	23 45 80	 and	 eax, DWORD PTR tv656[ebp+4]
  0030f	83 f8 ff	 cmp	 eax, -1
  00312	74 76		 je	 SHORT $LN29@MainThread

; 581  : 					{
; 582  : 						GetIntersection (alignedOffset.QuadPart, alignedLength, queue->EncryptedAreaStart, queue->EncryptedAreaEnd, &intersectStart, &intersectLength);

  00314	8d 4d fc	 lea	 ecx, DWORD PTR _intersectLength$[ebp]
  00317	51		 push	 ecx
  00318	8d 55 f0	 lea	 edx, DWORD PTR _intersectStart$[ebp]
  0031b	52		 push	 edx
  0031c	8b 45 d8	 mov	 eax, DWORD PTR _queue$[ebp]
  0031f	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00322	51		 push	 ecx
  00323	8b 50 50	 mov	 edx, DWORD PTR [eax+80]
  00326	52		 push	 edx
  00327	8b 45 d8	 mov	 eax, DWORD PTR _queue$[ebp]
  0032a	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  0032d	51		 push	 ecx
  0032e	8b 50 48	 mov	 edx, DWORD PTR [eax+72]
  00331	52		 push	 edx
  00332	8b 45 c0	 mov	 eax, DWORD PTR _alignedLength$28063[ebp]
  00335	50		 push	 eax
  00336	8b 4d b4	 mov	 ecx, DWORD PTR _alignedOffset$28064[ebp+4]
  00339	51		 push	 ecx
  0033a	8b 55 b0	 mov	 edx, DWORD PTR _alignedOffset$28064[ebp]
  0033d	52		 push	 edx
  0033e	e8 00 00 00 00	 call	 _GetIntersection@36

; 583  : 						if (intersectLength > 0)

  00343	83 7d fc 00	 cmp	 DWORD PTR _intersectLength$[ebp], 0
  00347	76 41		 jbe	 SHORT $LN29@MainThread

; 584  : 						{
; 585  : 							dataUnit.Value = intersectStart / ENCRYPTION_DATA_UNIT_SIZE;

  00349	6a 00		 push	 0
  0034b	68 00 02 00 00	 push	 512			; 00000200H
  00350	8b 45 f4	 mov	 eax, DWORD PTR _intersectStart$[ebp+4]
  00353	50		 push	 eax
  00354	8b 4d f0	 mov	 ecx, DWORD PTR _intersectStart$[ebp]
  00357	51		 push	 ecx
  00358	e8 00 00 00 00	 call	 __aulldiv
  0035d	89 45 a8	 mov	 DWORD PTR _dataUnit$28071[ebp], eax
  00360	89 55 ac	 mov	 DWORD PTR _dataUnit$28071[ebp+4], edx

; 586  : 							DecryptDataUnits (buffer + (intersectStart - alignedOffset.QuadPart), &dataUnit, intersectLength / ENCRYPTION_DATA_UNIT_SIZE, queue->CryptoInfo);

  00363	8b 55 d8	 mov	 edx, DWORD PTR _queue$[ebp]
  00366	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00369	50		 push	 eax
  0036a	8b 4d fc	 mov	 ecx, DWORD PTR _intersectLength$[ebp]
  0036d	c1 e9 09	 shr	 ecx, 9
  00370	51		 push	 ecx
  00371	8d 55 a8	 lea	 edx, DWORD PTR _dataUnit$28071[ebp]
  00374	52		 push	 edx
  00375	8b 45 f0	 mov	 eax, DWORD PTR _intersectStart$[ebp]
  00378	2b 45 b0	 sub	 eax, DWORD PTR _alignedOffset$28064[ebp]
  0037b	8b 4d f4	 mov	 ecx, DWORD PTR _intersectStart$[ebp+4]
  0037e	1b 4d b4	 sbb	 ecx, DWORD PTR _alignedOffset$28064[ebp+4]
  00381	03 45 bc	 add	 eax, DWORD PTR _buffer$28062[ebp]
  00384	50		 push	 eax
  00385	e8 00 00 00 00	 call	 _DecryptDataUnits@16
$LN29@MainThread:

; 587  : 						}
; 588  : 					}
; 589  : 
; 590  : 					memcpy (dataBuffer, buffer + (item->OriginalOffset.LowPart & (ENCRYPTION_DATA_UNIT_SIZE - 1)), item->OriginalLength);

  0038a	8b 55 cc	 mov	 edx, DWORD PTR _item$[ebp]
  0038d	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00390	50		 push	 eax
  00391	8b 4d cc	 mov	 ecx, DWORD PTR _item$[ebp]
  00394	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00397	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  0039d	03 55 bc	 add	 edx, DWORD PTR _buffer$28062[ebp]
  003a0	52		 push	 edx
  003a1	8b 45 d0	 mov	 eax, DWORD PTR _dataBuffer$[ebp]
  003a4	50		 push	 eax
  003a5	e8 00 00 00 00	 call	 _memcpy
  003aa	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN31@MainThread:

; 591  : 				}
; 592  : 
; 593  : 				TCfree (buffer);

  003ad	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  003b2	8b 4d bc	 mov	 ecx, DWORD PTR _buffer$28062[ebp]
  003b5	51		 push	 ecx
  003b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 594  : 				CompleteOriginalIrp (item, item->Status, NT_SUCCESS (item->Status) ? item->OriginalLength : 0);

  003bc	8b 55 cc	 mov	 edx, DWORD PTR _item$[ebp]
  003bf	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  003c3	7c 0e		 jl	 SHORT $LN51@MainThread
  003c5	8b 45 cc	 mov	 eax, DWORD PTR _item$[ebp]
  003c8	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  003cb	89 8d 78 ff ff
	ff		 mov	 DWORD PTR tv259[ebp], ecx
  003d1	eb 0a		 jmp	 SHORT $LN52@MainThread
$LN51@MainThread:
  003d3	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv259[ebp], 0
$LN52@MainThread:
  003dd	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR tv259[ebp]
  003e3	52		 push	 edx
  003e4	8b 45 cc	 mov	 eax, DWORD PTR _item$[ebp]
  003e7	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  003ea	51		 push	 ecx
  003eb	8b 55 cc	 mov	 edx, DWORD PTR _item$[ebp]
  003ee	52		 push	 edx
  003ef	e8 00 00 00 00	 call	 _CompleteOriginalIrp@12

; 595  : 				continue;

  003f4	e9 6c fc ff ff	 jmp	 $LN42@MainThread
$LN33@MainThread:

; 596  : 			}
; 597  : 
; 598  : 			// Validate offset and length
; 599  : 			if (item->OriginalLength == 0
; 600  : 				|| (item->OriginalLength & (ENCRYPTION_DATA_UNIT_SIZE - 1)) != 0
; 601  : 				|| (item->OriginalOffset.QuadPart & (ENCRYPTION_DATA_UNIT_SIZE - 1)) != 0
; 602  : 				|| (!queue->IsFilterDevice && item->OriginalOffset.QuadPart + item->OriginalLength > queue->VirtualDeviceLength))

  003f9	8b 45 cc	 mov	 eax, DWORD PTR _item$[ebp]
  003fc	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00400	0f 84 93 00 00
	00		 je	 $LN26@MainThread
  00406	8b 4d cc	 mov	 ecx, DWORD PTR _item$[ebp]
  00409	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0040c	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  00412	0f 85 81 00 00
	00		 jne	 $LN26@MainThread
  00418	8b 45 cc	 mov	 eax, DWORD PTR _item$[ebp]
  0041b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0041e	81 e1 ff 01 00
	00		 and	 ecx, 511		; 000001ffH
  00424	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00427	83 e2 00	 and	 edx, 0
  0042a	89 8d 70 ff ff
	ff		 mov	 DWORD PTR tv725[ebp], ecx
  00430	89 95 74 ff ff
	ff		 mov	 DWORD PTR tv725[ebp+4], edx
  00436	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv725[ebp]
  0043c	0b 85 74 ff ff
	ff		 or	 eax, DWORD PTR tv725[ebp+4]
  00442	75 55		 jne	 SHORT $LN26@MainThread
  00444	8b 4d d8	 mov	 ecx, DWORD PTR _queue$[ebp]
  00447	83 79 3c 00	 cmp	 DWORD PTR [ecx+60], 0
  0044b	75 61		 jne	 SHORT $LN27@MainThread
  0044d	8b 55 cc	 mov	 edx, DWORD PTR _item$[ebp]
  00450	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00453	33 c9		 xor	 ecx, ecx
  00455	8b 55 cc	 mov	 edx, DWORD PTR _item$[ebp]
  00458	03 42 10	 add	 eax, DWORD PTR [edx+16]
  0045b	8b 52 14	 mov	 edx, DWORD PTR [edx+20]
  0045e	13 d1		 adc	 edx, ecx
  00460	8b 4d d8	 mov	 ecx, DWORD PTR _queue$[ebp]
  00463	89 85 68 ff ff
	ff		 mov	 DWORD PTR tv742[ebp], eax
  00469	89 95 6c ff ff
	ff		 mov	 DWORD PTR tv742[ebp+4], edx
  0046f	89 8d 64 ff ff
	ff		 mov	 DWORD PTR tv745[ebp], ecx
  00475	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv745[ebp]
  0047b	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR tv742[ebp+4]
  00481	3b 42 34	 cmp	 eax, DWORD PTR [edx+52]
  00484	7c 28		 jl	 SHORT $LN27@MainThread
  00486	7f 11		 jg	 SHORT $LN26@MainThread
  00488	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR tv745[ebp]
  0048e	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv742[ebp]
  00494	3b 51 30	 cmp	 edx, DWORD PTR [ecx+48]
  00497	76 15		 jbe	 SHORT $LN27@MainThread
$LN26@MainThread:

; 603  : 			{
; 604  : 				CompleteOriginalIrp (item, STATUS_INVALID_PARAMETER, 0);

  00499	6a 00		 push	 0
  0049b	68 0d 00 00 c0	 push	 -1073741811		; c000000dH
  004a0	8b 45 cc	 mov	 eax, DWORD PTR _item$[ebp]
  004a3	50		 push	 eax
  004a4	e8 00 00 00 00	 call	 _CompleteOriginalIrp@12

; 605  : 				continue;

  004a9	e9 b7 fb ff ff	 jmp	 $LN42@MainThread
$LN27@MainThread:

; 606  : 			}
; 607  : 
; 608  : #ifdef TC_TRACE_IO_QUEUE
; 609  : 			Dump ("Q  %I64d [%I64d] %c len=%d\n", item->OriginalOffset.QuadPart, GetElapsedTime (&queue->LastPerformanceCounter), item->Write ? 'W' : 'R', item->OriginalLength);
; 610  : #endif
; 611  : 
; 612  : 			if (!queue->IsFilterDevice)

  004ae	8b 4d d8	 mov	 ecx, DWORD PTR _queue$[ebp]
  004b1	83 79 3c 00	 cmp	 DWORD PTR [ecx+60], 0
  004b5	0f 85 ad 01 00
	00		 jne	 $LN25@MainThread

; 613  : 			{
; 614  : 				// Adjust the offset for host file or device
; 615  : 				if (queue->CryptoInfo->hiddenVolume)

  004bb	8b 55 d8	 mov	 edx, DWORD PTR _queue$[ebp]
  004be	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  004c1	83 b8 a0 29 00
	00 00		 cmp	 DWORD PTR [eax+10656], 0
  004c8	74 26		 je	 SHORT $LN24@MainThread

; 616  : 					item->OriginalOffset.QuadPart += queue->CryptoInfo->hiddenVolumeOffset;

  004ca	8b 4d d8	 mov	 ecx, DWORD PTR _queue$[ebp]
  004cd	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  004d0	8b 45 cc	 mov	 eax, DWORD PTR _item$[ebp]
  004d3	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  004d6	03 8a 18 44 00
	00		 add	 ecx, DWORD PTR [edx+17432]
  004dc	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  004df	13 82 1c 44 00
	00		 adc	 eax, DWORD PTR [edx+17436]
  004e5	8b 55 cc	 mov	 edx, DWORD PTR _item$[ebp]
  004e8	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
  004eb	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 617  : 				else

  004ee	eb 24		 jmp	 SHORT $LN23@MainThread
$LN24@MainThread:

; 618  : 					item->OriginalOffset.QuadPart += queue->CryptoInfo->volDataAreaOffset; 

  004f0	8b 45 d8	 mov	 eax, DWORD PTR _queue$[ebp]
  004f3	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  004f6	8b 55 cc	 mov	 edx, DWORD PTR _item$[ebp]
  004f9	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  004fc	03 81 08 44 00
	00		 add	 eax, DWORD PTR [ecx+17416]
  00502	8b 52 14	 mov	 edx, DWORD PTR [edx+20]
  00505	13 91 0c 44 00
	00		 adc	 edx, DWORD PTR [ecx+17420]
  0050b	8b 4d cc	 mov	 ecx, DWORD PTR _item$[ebp]
  0050e	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00511	89 51 14	 mov	 DWORD PTR [ecx+20], edx
$LN23@MainThread:

; 619  : 
; 620  : 				// Hidden volume protection
; 621  : 				if (item->Write && queue->CryptoInfo->bProtectHiddenVolume)

  00514	8b 55 cc	 mov	 edx, DWORD PTR _item$[ebp]
  00517	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  0051b	0f 84 42 01 00
	00		 je	 $LN22@MainThread
  00521	8b 45 d8	 mov	 eax, DWORD PTR _queue$[ebp]
  00524	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00527	83 b9 00 44 00
	00 00		 cmp	 DWORD PTR [ecx+17408], 0
  0052e	0f 84 2f 01 00
	00		 je	 $LN22@MainThread

; 622  : 				{
; 623  : 					// If there has already been a write operation denied in order to protect the
; 624  : 					// hidden volume (since the volume mount time)
; 625  : 					if (queue->CryptoInfo->bHiddenVolProtectionAction)	

  00534	8b 55 d8	 mov	 edx, DWORD PTR _queue$[ebp]
  00537	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0053a	83 b8 04 44 00
	00 00		 cmp	 DWORD PTR [eax+17412], 0
  00541	74 15		 je	 SHORT $LN21@MainThread

; 626  : 					{
; 627  : 						// Do not allow writing to this volume anymore. This is to fake a complete volume
; 628  : 						// or system failure (otherwise certain kinds of inconsistency within the file
; 629  : 						// system could indicate that this volume has used hidden volume protection).
; 630  : 						CompleteOriginalIrp (item, STATUS_INVALID_PARAMETER, 0);

  00543	6a 00		 push	 0
  00545	68 0d 00 00 c0	 push	 -1073741811		; c000000dH
  0054a	8b 4d cc	 mov	 ecx, DWORD PTR _item$[ebp]
  0054d	51		 push	 ecx
  0054e	e8 00 00 00 00	 call	 _CompleteOriginalIrp@12

; 631  : 						continue;

  00553	e9 0d fb ff ff	 jmp	 $LN42@MainThread
$LN21@MainThread:

; 632  : 					}
; 633  : 
; 634  : 					// Verify that no byte is going to be written to the hidden volume area
; 635  : 					if (RegionsOverlap ((unsigned __int64) item->OriginalOffset.QuadPart,
; 636  : 						(unsigned __int64) item->OriginalOffset.QuadPart + item->OriginalLength - 1,
; 637  : 						queue->CryptoInfo->hiddenVolumeOffset,
; 638  : 						(unsigned __int64) queue->CryptoInfo->hiddenVolumeOffset + queue->CryptoInfo->hiddenVolumeProtectedSize - 1))

  00558	8b 55 d8	 mov	 edx, DWORD PTR _queue$[ebp]
  0055b	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0055e	8b 4d d8	 mov	 ecx, DWORD PTR _queue$[ebp]
  00561	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00564	8b 88 18 44 00
	00		 mov	 ecx, DWORD PTR [eax+17432]
  0056a	03 8a 20 44 00
	00		 add	 ecx, DWORD PTR [edx+17440]
  00570	8b 80 1c 44 00
	00		 mov	 eax, DWORD PTR [eax+17436]
  00576	13 82 24 44 00
	00		 adc	 eax, DWORD PTR [edx+17444]
  0057c	83 e9 01	 sub	 ecx, 1
  0057f	83 d8 00	 sbb	 eax, 0
  00582	50		 push	 eax
  00583	51		 push	 ecx
  00584	8b 4d d8	 mov	 ecx, DWORD PTR _queue$[ebp]
  00587	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0058a	8b 82 1c 44 00
	00		 mov	 eax, DWORD PTR [edx+17436]
  00590	50		 push	 eax
  00591	8b 8a 18 44 00
	00		 mov	 ecx, DWORD PTR [edx+17432]
  00597	51		 push	 ecx
  00598	8b 55 cc	 mov	 edx, DWORD PTR _item$[ebp]
  0059b	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0059e	33 c9		 xor	 ecx, ecx
  005a0	8b 55 cc	 mov	 edx, DWORD PTR _item$[ebp]
  005a3	03 42 10	 add	 eax, DWORD PTR [edx+16]
  005a6	8b 52 14	 mov	 edx, DWORD PTR [edx+20]
  005a9	13 d1		 adc	 edx, ecx
  005ab	83 e8 01	 sub	 eax, 1
  005ae	83 da 00	 sbb	 edx, 0
  005b1	52		 push	 edx
  005b2	50		 push	 eax
  005b3	8b 45 cc	 mov	 eax, DWORD PTR _item$[ebp]
  005b6	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  005b9	51		 push	 ecx
  005ba	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  005bd	52		 push	 edx
  005be	e8 00 00 00 00	 call	 _RegionsOverlap@32
  005c3	85 c0		 test	 eax, eax
  005c5	0f 84 98 00 00
	00		 je	 $LN22@MainThread

; 639  : 					{
; 640  : 						Dump ("Hidden volume protection triggered: write %I64d-%I64d (protected %I64d-%I64d)\n", item->OriginalOffset.QuadPart, item->OriginalOffset.QuadPart + item->OriginalLength - 1, queue->CryptoInfo->hiddenVolumeOffset, queue->CryptoInfo->hiddenVolumeOffset + queue->CryptoInfo->hiddenVolumeProtectedSize - 1);

  005cb	8b 45 d8	 mov	 eax, DWORD PTR _queue$[ebp]
  005ce	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  005d1	8b 55 d8	 mov	 edx, DWORD PTR _queue$[ebp]
  005d4	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  005d7	8b 91 18 44 00
	00		 mov	 edx, DWORD PTR [ecx+17432]
  005dd	03 90 20 44 00
	00		 add	 edx, DWORD PTR [eax+17440]
  005e3	8b 89 1c 44 00
	00		 mov	 ecx, DWORD PTR [ecx+17436]
  005e9	13 88 24 44 00
	00		 adc	 ecx, DWORD PTR [eax+17444]
  005ef	83 ea 01	 sub	 edx, 1
  005f2	83 d9 00	 sbb	 ecx, 0
  005f5	51		 push	 ecx
  005f6	52		 push	 edx
  005f7	8b 55 d8	 mov	 edx, DWORD PTR _queue$[ebp]
  005fa	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  005fd	8b 88 1c 44 00
	00		 mov	 ecx, DWORD PTR [eax+17436]
  00603	51		 push	 ecx
  00604	8b 90 18 44 00
	00		 mov	 edx, DWORD PTR [eax+17432]
  0060a	52		 push	 edx
  0060b	8b 45 cc	 mov	 eax, DWORD PTR _item$[ebp]
  0060e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00611	33 d2		 xor	 edx, edx
  00613	8b 45 cc	 mov	 eax, DWORD PTR _item$[ebp]
  00616	03 48 10	 add	 ecx, DWORD PTR [eax+16]
  00619	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0061c	13 c2		 adc	 eax, edx
  0061e	83 e9 01	 sub	 ecx, 1
  00621	83 d8 00	 sbb	 eax, 0
  00624	50		 push	 eax
  00625	51		 push	 ecx
  00626	8b 4d cc	 mov	 ecx, DWORD PTR _item$[ebp]
  00629	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0062c	52		 push	 edx
  0062d	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00630	50		 push	 eax
  00631	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@IGAPPBIF@Hidden?5volume?5protection?5trigger@FNODOBFM@
  00636	e8 00 00 00 00	 call	 _DbgPrint
  0063b	83 c4 24	 add	 esp, 36			; 00000024H

; 641  : 						queue->CryptoInfo->bHiddenVolProtectionAction = TRUE;

  0063e	8b 4d d8	 mov	 ecx, DWORD PTR _queue$[ebp]
  00641	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00644	c7 82 04 44 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+17412], 1

; 642  : 
; 643  : 						// Deny this write operation to prevent the hidden volume from being overwritten
; 644  : 						CompleteOriginalIrp (item, STATUS_INVALID_PARAMETER, 0);

  0064e	6a 00		 push	 0
  00650	68 0d 00 00 c0	 push	 -1073741811		; c000000dH
  00655	8b 45 cc	 mov	 eax, DWORD PTR _item$[ebp]
  00658	50		 push	 eax
  00659	e8 00 00 00 00	 call	 _CompleteOriginalIrp@12

; 645  : 						continue;

  0065e	e9 02 fa ff ff	 jmp	 $LN42@MainThread
$LN22@MainThread:

; 646  : 					}
; 647  : 				}
; 648  : 			}
; 649  : 			else if (item->Write

  00663	e9 23 01 00 00	 jmp	 $LN19@MainThread
$LN25@MainThread:

; 650  : 				&& RegionsOverlap (item->OriginalOffset.QuadPart, item->OriginalOffset.QuadPart + item->OriginalLength - 1, TC_BOOT_VOLUME_HEADER_SECTOR_OFFSET, TC_BOOT_VOLUME_HEADER_SECTOR_OFFSET + TC_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE - 1))

  00668	8b 4d cc	 mov	 ecx, DWORD PTR _item$[ebp]
  0066b	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  0066f	74 64		 je	 SHORT $LN18@MainThread
  00671	6a 00		 push	 0
  00673	68 ff 7d 00 00	 push	 32255			; 00007dffH
  00678	6a 00		 push	 0
  0067a	68 00 7c 00 00	 push	 31744			; 00007c00H
  0067f	8b 55 cc	 mov	 edx, DWORD PTR _item$[ebp]
  00682	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00685	33 c9		 xor	 ecx, ecx
  00687	8b 55 cc	 mov	 edx, DWORD PTR _item$[ebp]
  0068a	03 42 10	 add	 eax, DWORD PTR [edx+16]
  0068d	8b 52 14	 mov	 edx, DWORD PTR [edx+20]
  00690	13 d1		 adc	 edx, ecx
  00692	83 e8 01	 sub	 eax, 1
  00695	83 da 00	 sbb	 edx, 0
  00698	52		 push	 edx
  00699	50		 push	 eax
  0069a	8b 45 cc	 mov	 eax, DWORD PTR _item$[ebp]
  0069d	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  006a0	51		 push	 ecx
  006a1	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  006a4	52		 push	 edx
  006a5	e8 00 00 00 00	 call	 _RegionsOverlap@32
  006aa	85 c0		 test	 eax, eax
  006ac	74 27		 je	 SHORT $LN18@MainThread

; 651  : 			{
; 652  : 				// Prevent inappropriately designed software from damaging important data that may be out of sync with the backup on the Rescue Disk (such as the end of the encrypted area).
; 653  : 				Dump ("Preventing write to the system encryption key data area\n");

  006ae	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@KOLNOKOK@Preventing?5write?5to?5the?5system?5e@FNODOBFM@
  006b3	e8 00 00 00 00	 call	 _DbgPrint
  006b8	83 c4 04	 add	 esp, 4

; 654  : 				CompleteOriginalIrp (item, STATUS_MEDIA_WRITE_PROTECTED, 0);

  006bb	6a 00		 push	 0
  006bd	68 a2 00 00 c0	 push	 -1073741662		; c00000a2H
  006c2	8b 45 cc	 mov	 eax, DWORD PTR _item$[ebp]
  006c5	50		 push	 eax
  006c6	e8 00 00 00 00	 call	 _CompleteOriginalIrp@12

; 655  : 				continue;

  006cb	e9 95 f9 ff ff	 jmp	 $LN42@MainThread

; 656  : 			}
; 657  : 			else if (item->Write && IsHiddenSystemRunning()

  006d0	e9 b6 00 00 00	 jmp	 $LN19@MainThread
$LN18@MainThread:

; 658  : 				&& (RegionsOverlap (item->OriginalOffset.QuadPart, item->OriginalOffset.QuadPart + item->OriginalLength - 1, TC_SECTOR_SIZE_BIOS, TC_BOOT_LOADER_AREA_SECTOR_COUNT * TC_SECTOR_SIZE_BIOS - 1)
; 659  : 				 || RegionsOverlap (item->OriginalOffset.QuadPart, item->OriginalOffset.QuadPart + item->OriginalLength - 1, GetBootDriveLength(), _I64_MAX)))

  006d5	8b 4d cc	 mov	 ecx, DWORD PTR _item$[ebp]
  006d8	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  006dc	0f 84 a9 00 00
	00		 je	 $LN19@MainThread
  006e2	e8 00 00 00 00	 call	 _IsHiddenSystemRunning@0
  006e7	85 c0		 test	 eax, eax
  006e9	0f 84 9c 00 00
	00		 je	 $LN19@MainThread
  006ef	6a 00		 push	 0
  006f1	68 ff 7d 00 00	 push	 32255			; 00007dffH
  006f6	6a 00		 push	 0
  006f8	68 00 02 00 00	 push	 512			; 00000200H
  006fd	8b 55 cc	 mov	 edx, DWORD PTR _item$[ebp]
  00700	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00703	33 c9		 xor	 ecx, ecx
  00705	8b 55 cc	 mov	 edx, DWORD PTR _item$[ebp]
  00708	03 42 10	 add	 eax, DWORD PTR [edx+16]
  0070b	8b 52 14	 mov	 edx, DWORD PTR [edx+20]
  0070e	13 d1		 adc	 edx, ecx
  00710	83 e8 01	 sub	 eax, 1
  00713	83 da 00	 sbb	 edx, 0
  00716	52		 push	 edx
  00717	50		 push	 eax
  00718	8b 45 cc	 mov	 eax, DWORD PTR _item$[ebp]
  0071b	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0071e	51		 push	 ecx
  0071f	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00722	52		 push	 edx
  00723	e8 00 00 00 00	 call	 _RegionsOverlap@32
  00728	85 c0		 test	 eax, eax
  0072a	75 3d		 jne	 SHORT $LN15@MainThread
  0072c	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  00731	6a ff		 push	 -1
  00733	e8 00 00 00 00	 call	 _GetBootDriveLength@0
  00738	52		 push	 edx
  00739	50		 push	 eax
  0073a	8b 45 cc	 mov	 eax, DWORD PTR _item$[ebp]
  0073d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00740	33 d2		 xor	 edx, edx
  00742	8b 45 cc	 mov	 eax, DWORD PTR _item$[ebp]
  00745	03 48 10	 add	 ecx, DWORD PTR [eax+16]
  00748	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0074b	13 c2		 adc	 eax, edx
  0074d	83 e9 01	 sub	 ecx, 1
  00750	83 d8 00	 sbb	 eax, 0
  00753	50		 push	 eax
  00754	51		 push	 ecx
  00755	8b 4d cc	 mov	 ecx, DWORD PTR _item$[ebp]
  00758	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0075b	52		 push	 edx
  0075c	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0075f	50		 push	 eax
  00760	e8 00 00 00 00	 call	 _RegionsOverlap@32
  00765	85 c0		 test	 eax, eax
  00767	74 22		 je	 SHORT $LN19@MainThread
$LN15@MainThread:

; 660  : 			{
; 661  : 				Dump ("Preventing write to boot loader or host protected area\n");

  00769	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@GBCOIBFH@Preventing?5write?5to?5boot?5loader?5@FNODOBFM@
  0076e	e8 00 00 00 00	 call	 _DbgPrint
  00773	83 c4 04	 add	 esp, 4

; 662  : 				CompleteOriginalIrp (item, STATUS_MEDIA_WRITE_PROTECTED, 0);

  00776	6a 00		 push	 0
  00778	68 a2 00 00 c0	 push	 -1073741662		; c00000a2H
  0077d	8b 4d cc	 mov	 ecx, DWORD PTR _item$[ebp]
  00780	51		 push	 ecx
  00781	e8 00 00 00 00	 call	 _CompleteOriginalIrp@12

; 663  : 				continue;

  00786	e9 da f8 ff ff	 jmp	 $LN42@MainThread
$LN19@MainThread:

; 664  : 			}
; 665  : 
; 666  : 			dataBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe (irp->MdlAddress, HighPagePriority);

  0078b	8b 55 c8	 mov	 edx, DWORD PTR _irp$28032[ebp]
  0078e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00791	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00795	83 e1 05	 and	 ecx, 5
  00798	74 11		 je	 SHORT $LN53@MainThread
  0079a	8b 55 c8	 mov	 edx, DWORD PTR _irp$28032[ebp]
  0079d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  007a0	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  007a3	89 8d 60 ff ff
	ff		 mov	 DWORD PTR tv418[ebp], ecx
  007a9	eb 1d		 jmp	 SHORT $LN54@MainThread
$LN53@MainThread:
  007ab	6a 20		 push	 32			; 00000020H
  007ad	6a 00		 push	 0
  007af	6a 00		 push	 0
  007b1	6a 01		 push	 1
  007b3	6a 00		 push	 0
  007b5	8b 55 c8	 mov	 edx, DWORD PTR _irp$28032[ebp]
  007b8	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  007bb	50		 push	 eax
  007bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmMapLockedPagesSpecifyCache@24
  007c2	89 85 60 ff ff
	ff		 mov	 DWORD PTR tv418[ebp], eax
$LN54@MainThread:
  007c8	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR tv418[ebp]
  007ce	89 4d d0	 mov	 DWORD PTR _dataBuffer$[ebp], ecx

; 667  : 
; 668  : 			if (dataBuffer == NULL)

  007d1	83 7d d0 00	 cmp	 DWORD PTR _dataBuffer$[ebp], 0
  007d5	75 15		 jne	 SHORT $LN14@MainThread

; 669  : 			{
; 670  : 				CompleteOriginalIrp (item, STATUS_INSUFFICIENT_RESOURCES, 0);

  007d7	6a 00		 push	 0
  007d9	68 9a 00 00 c0	 push	 -1073741670		; c000009aH
  007de	8b 55 cc	 mov	 edx, DWORD PTR _item$[ebp]
  007e1	52		 push	 edx
  007e2	e8 00 00 00 00	 call	 _CompleteOriginalIrp@12

; 671  : 				continue;

  007e7	e9 79 f8 ff ff	 jmp	 $LN42@MainThread
$LN14@MainThread:

; 672  : 			}
; 673  : 
; 674  : 			// Divide data block to fragments to enable efficient overlapping of encryption and IO operations
; 675  : 
; 676  : 			dataRemaining = item->OriginalLength;

  007ec	8b 45 cc	 mov	 eax, DWORD PTR _item$[ebp]
  007ef	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  007f2	89 4d e4	 mov	 DWORD PTR _dataRemaining$[ebp], ecx

; 677  : 			fragmentOffset = item->OriginalOffset;

  007f5	8b 55 cc	 mov	 edx, DWORD PTR _item$[ebp]
  007f8	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  007fb	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  007fe	89 45 e8	 mov	 DWORD PTR _fragmentOffset$[ebp], eax
  00801	89 4d ec	 mov	 DWORD PTR _fragmentOffset$[ebp+4], ecx
$LN13@MainThread:

; 678  : 
; 679  : 			while (dataRemaining > 0)

  00804	83 7d e4 00	 cmp	 DWORD PTR _dataRemaining$[ebp], 0
  00808	0f 86 51 03 00
	00		 jbe	 $LN12@MainThread

; 680  : 			{
; 681  : 				BOOL isLastFragment = dataRemaining <= TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE;

  0080e	ba 00 00 04 00	 mov	 edx, 262144		; 00040000H
  00813	3b 55 e4	 cmp	 edx, DWORD PTR _dataRemaining$[ebp]
  00816	1b c0		 sbb	 eax, eax
  00818	83 c0 01	 add	 eax, 1
  0081b	89 45 a0	 mov	 DWORD PTR _isLastFragment$28111[ebp], eax

; 682  : 				
; 683  : 				ULONG dataFragmentLength = isLastFragment ? dataRemaining : TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE;

  0081e	74 0b		 je	 SHORT $LN55@MainThread
  00820	8b 4d e4	 mov	 ecx, DWORD PTR _dataRemaining$[ebp]
  00823	89 8d 5c ff ff
	ff		 mov	 DWORD PTR tv430[ebp], ecx
  00829	eb 0a		 jmp	 SHORT $LN56@MainThread
$LN55@MainThread:
  0082b	c7 85 5c ff ff
	ff 00 00 04 00	 mov	 DWORD PTR tv430[ebp], 262144 ; 00040000H
$LN56@MainThread:
  00835	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR tv430[ebp]
  0083b	89 55 a4	 mov	 DWORD PTR _dataFragmentLength$28112[ebp], edx

; 684  : 				activeFragmentBuffer = (activeFragmentBuffer == queue->FragmentBufferA ? queue->FragmentBufferB : queue->FragmentBufferA);

  0083e	8b 45 d8	 mov	 eax, DWORD PTR _queue$[ebp]
  00841	8b 4d dc	 mov	 ecx, DWORD PTR _activeFragmentBuffer$[ebp]
  00844	3b 88 28 01 00
	00		 cmp	 ecx, DWORD PTR [eax+296]
  0084a	75 11		 jne	 SHORT $LN57@MainThread
  0084c	8b 55 d8	 mov	 edx, DWORD PTR _queue$[ebp]
  0084f	8b 82 2c 01 00
	00		 mov	 eax, DWORD PTR [edx+300]
  00855	89 85 58 ff ff
	ff		 mov	 DWORD PTR tv435[ebp], eax
  0085b	eb 0f		 jmp	 SHORT $LN58@MainThread
$LN57@MainThread:
  0085d	8b 4d d8	 mov	 ecx, DWORD PTR _queue$[ebp]
  00860	8b 91 28 01 00
	00		 mov	 edx, DWORD PTR [ecx+296]
  00866	89 95 58 ff ff
	ff		 mov	 DWORD PTR tv435[ebp], edx
$LN58@MainThread:
  0086c	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR tv435[ebp]
  00872	89 45 dc	 mov	 DWORD PTR _activeFragmentBuffer$[ebp], eax

; 685  : 
; 686  : 				InterlockedIncrement (&queue->IoThreadPendingRequestCount);

  00875	8b 4d d8	 mov	 ecx, DWORD PTR _queue$[ebp]
  00878	81 c1 94 01 00
	00		 add	 ecx, 404		; 00000194H
  0087e	ba 01 00 00 00	 mov	 edx, 1
  00883	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx

; 687  : 
; 688  : 				// Create IO request
; 689  : 				request = GetPoolBuffer (queue, sizeof (EncryptedIoRequest));

  00887	6a 40		 push	 64			; 00000040H
  00889	8b 45 d8	 mov	 eax, DWORD PTR _queue$[ebp]
  0088c	50		 push	 eax
  0088d	e8 00 00 00 00	 call	 _GetPoolBuffer@8
  00892	89 45 d4	 mov	 DWORD PTR _request$[ebp], eax

; 690  : 				request->Item = item;

  00895	8b 4d d4	 mov	 ecx, DWORD PTR _request$[ebp]
  00898	8b 55 cc	 mov	 edx, DWORD PTR _item$[ebp]
  0089b	89 11		 mov	 DWORD PTR [ecx], edx

; 691  : 				request->CompleteOriginalIrp = isLastFragment;

  0089d	8b 45 d4	 mov	 eax, DWORD PTR _request$[ebp]
  008a0	8b 4d a0	 mov	 ecx, DWORD PTR _isLastFragment$28111[ebp]
  008a3	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 692  : 				request->Offset = fragmentOffset;

  008a6	8b 55 d4	 mov	 edx, DWORD PTR _request$[ebp]
  008a9	8b 45 e8	 mov	 eax, DWORD PTR _fragmentOffset$[ebp]
  008ac	89 42 08	 mov	 DWORD PTR [edx+8], eax
  008af	8b 4d ec	 mov	 ecx, DWORD PTR _fragmentOffset$[ebp+4]
  008b2	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 693  : 				request->Data = activeFragmentBuffer;

  008b5	8b 55 d4	 mov	 edx, DWORD PTR _request$[ebp]
  008b8	8b 45 dc	 mov	 eax, DWORD PTR _activeFragmentBuffer$[ebp]
  008bb	89 42 24	 mov	 DWORD PTR [edx+36], eax

; 694  : 				request->OrigDataBufferFragment = dataBuffer;

  008be	8b 4d d4	 mov	 ecx, DWORD PTR _request$[ebp]
  008c1	8b 55 d0	 mov	 edx, DWORD PTR _dataBuffer$[ebp]
  008c4	89 51 28	 mov	 DWORD PTR [ecx+40], edx

; 695  : 				request->Length = dataFragmentLength;

  008c7	8b 45 d4	 mov	 eax, DWORD PTR _request$[ebp]
  008ca	8b 4d a4	 mov	 ecx, DWORD PTR _dataFragmentLength$28112[ebp]
  008cd	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 696  : 
; 697  : 				if (queue->IsFilterDevice)

  008d0	8b 55 d8	 mov	 edx, DWORD PTR _queue$[ebp]
  008d3	83 7a 3c 00	 cmp	 DWORD PTR [edx+60], 0
  008d7	0f 84 a1 00 00
	00		 je	 $LN11@MainThread

; 698  : 				{
; 699  : 					if (queue->EncryptedAreaStart == -1 || queue->EncryptedAreaEnd == -1)

  008dd	8b 45 d8	 mov	 eax, DWORD PTR _queue$[ebp]
  008e0	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv995[ebp], eax
  008e6	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR tv995[ebp]
  008ec	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR tv995[ebp]
  008f2	8b 41 48	 mov	 eax, DWORD PTR [ecx+72]
  008f5	23 42 4c	 and	 eax, DWORD PTR [edx+76]
  008f8	83 f8 ff	 cmp	 eax, -1
  008fb	74 26		 je	 SHORT $LN9@MainThread
  008fd	8b 4d d8	 mov	 ecx, DWORD PTR _queue$[ebp]
  00900	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  00903	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  00906	89 95 4c ff ff
	ff		 mov	 DWORD PTR tv1005[ebp], edx
  0090c	89 85 50 ff ff
	ff		 mov	 DWORD PTR tv1005[ebp+4], eax
  00912	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv1005[ebp]
  00918	23 8d 50 ff ff
	ff		 and	 ecx, DWORD PTR tv1005[ebp+4]
  0091e	83 f9 ff	 cmp	 ecx, -1
  00921	75 0c		 jne	 SHORT $LN10@MainThread
$LN9@MainThread:

; 700  : 					{
; 701  : 						request->EncryptedLength = 0;

  00923	8b 55 d4	 mov	 edx, DWORD PTR _request$[ebp]
  00926	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], 0

; 702  : 					}
; 703  : 					else

  0092d	eb 4d		 jmp	 SHORT $LN8@MainThread
$LN10@MainThread:

; 704  : 					{
; 705  : 						// Get intersection of data fragment with encrypted area
; 706  : 						GetIntersection (fragmentOffset.QuadPart, dataFragmentLength, queue->EncryptedAreaStart, queue->EncryptedAreaEnd, &intersectStart, &intersectLength);

  0092f	8d 45 fc	 lea	 eax, DWORD PTR _intersectLength$[ebp]
  00932	50		 push	 eax
  00933	8d 4d f0	 lea	 ecx, DWORD PTR _intersectStart$[ebp]
  00936	51		 push	 ecx
  00937	8b 55 d8	 mov	 edx, DWORD PTR _queue$[ebp]
  0093a	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  0093d	50		 push	 eax
  0093e	8b 4a 50	 mov	 ecx, DWORD PTR [edx+80]
  00941	51		 push	 ecx
  00942	8b 55 d8	 mov	 edx, DWORD PTR _queue$[ebp]
  00945	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  00948	50		 push	 eax
  00949	8b 4a 48	 mov	 ecx, DWORD PTR [edx+72]
  0094c	51		 push	 ecx
  0094d	8b 55 a4	 mov	 edx, DWORD PTR _dataFragmentLength$28112[ebp]
  00950	52		 push	 edx
  00951	8b 45 ec	 mov	 eax, DWORD PTR _fragmentOffset$[ebp+4]
  00954	50		 push	 eax
  00955	8b 4d e8	 mov	 ecx, DWORD PTR _fragmentOffset$[ebp]
  00958	51		 push	 ecx
  00959	e8 00 00 00 00	 call	 _GetIntersection@36

; 707  : 
; 708  : 						request->EncryptedOffset = intersectStart - fragmentOffset.QuadPart;

  0095e	8b 55 f0	 mov	 edx, DWORD PTR _intersectStart$[ebp]
  00961	2b 55 e8	 sub	 edx, DWORD PTR _fragmentOffset$[ebp]
  00964	8b 45 f4	 mov	 eax, DWORD PTR _intersectStart$[ebp+4]
  00967	1b 45 ec	 sbb	 eax, DWORD PTR _fragmentOffset$[ebp+4]
  0096a	8b 4d d4	 mov	 ecx, DWORD PTR _request$[ebp]
  0096d	89 51 18	 mov	 DWORD PTR [ecx+24], edx
  00970	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 709  : 						request->EncryptedLength = intersectLength;

  00973	8b 55 d4	 mov	 edx, DWORD PTR _request$[ebp]
  00976	8b 45 fc	 mov	 eax, DWORD PTR _intersectLength$[ebp]
  00979	89 42 20	 mov	 DWORD PTR [edx+32], eax
$LN8@MainThread:

; 710  : 					}
; 711  : 				}
; 712  : 				else

  0097c	eb 1a		 jmp	 SHORT $LN7@MainThread
$LN11@MainThread:

; 713  : 				{
; 714  : 					request->EncryptedOffset = 0;

  0097e	8b 4d d4	 mov	 ecx, DWORD PTR _request$[ebp]
  00981	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
  00988	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 715  : 					request->EncryptedLength = dataFragmentLength;

  0098f	8b 55 d4	 mov	 edx, DWORD PTR _request$[ebp]
  00992	8b 45 a4	 mov	 eax, DWORD PTR _dataFragmentLength$28112[ebp]
  00995	89 42 20	 mov	 DWORD PTR [edx+32], eax
$LN7@MainThread:

; 716  : 				}
; 717  : 
; 718  : 				AcquireFragmentBuffer (queue, activeFragmentBuffer);

  00998	8b 4d dc	 mov	 ecx, DWORD PTR _activeFragmentBuffer$[ebp]
  0099b	51		 push	 ecx
  0099c	8b 55 d8	 mov	 edx, DWORD PTR _queue$[ebp]
  0099f	52		 push	 edx
  009a0	e8 00 00 00 00	 call	 _AcquireFragmentBuffer@8

; 719  : 
; 720  : 				if (item->Write)

  009a5	8b 45 cc	 mov	 eax, DWORD PTR _item$[ebp]
  009a8	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  009ac	0f 84 41 01 00
	00		 je	 $LN6@MainThread

; 721  : 				{
; 722  : 					// Encrypt data
; 723  : 					memcpy (activeFragmentBuffer, dataBuffer, dataFragmentLength);

  009b2	8b 4d a4	 mov	 ecx, DWORD PTR _dataFragmentLength$28112[ebp]
  009b5	51		 push	 ecx
  009b6	8b 55 d0	 mov	 edx, DWORD PTR _dataBuffer$[ebp]
  009b9	52		 push	 edx
  009ba	8b 45 dc	 mov	 eax, DWORD PTR _activeFragmentBuffer$[ebp]
  009bd	50		 push	 eax
  009be	e8 00 00 00 00	 call	 _memcpy
  009c3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 724  : 
; 725  : 					if (request->EncryptedLength > 0)

  009c6	8b 4d d4	 mov	 ecx, DWORD PTR _request$[ebp]
  009c9	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  009cd	0f 86 20 01 00
	00		 jbe	 $LN6@MainThread

; 726  : 					{
; 727  : 						UINT64_STRUCT dataUnit;
; 728  : 						ASSERT (request->EncryptedOffset + request->EncryptedLength <= request->Offset.QuadPart + request->Length);

  009d3	8b 55 d4	 mov	 edx, DWORD PTR _request$[ebp]
  009d6	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  009d9	33 c9		 xor	 ecx, ecx
  009db	8b 55 d4	 mov	 edx, DWORD PTR _request$[ebp]
  009de	03 42 18	 add	 eax, DWORD PTR [edx+24]
  009e1	8b 52 1c	 mov	 edx, DWORD PTR [edx+28]
  009e4	13 d1		 adc	 edx, ecx
  009e6	8b 4d d4	 mov	 ecx, DWORD PTR _request$[ebp]
  009e9	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  009ec	33 f6		 xor	 esi, esi
  009ee	8b 7d d4	 mov	 edi, DWORD PTR _request$[ebp]
  009f1	03 4f 08	 add	 ecx, DWORD PTR [edi+8]
  009f4	8b 7f 0c	 mov	 edi, DWORD PTR [edi+12]
  009f7	13 fe		 adc	 edi, esi
  009f9	89 85 44 ff ff
	ff		 mov	 DWORD PTR tv1069[ebp], eax
  009ff	89 95 48 ff ff
	ff		 mov	 DWORD PTR tv1069[ebp+4], edx
  00a05	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv1072[ebp], ecx
  00a0b	89 bd 40 ff ff
	ff		 mov	 DWORD PTR tv1072[ebp+4], edi
  00a11	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR tv1069[ebp+4]
  00a17	3b 95 40 ff ff
	ff		 cmp	 edx, DWORD PTR tv1072[ebp+4]
  00a1d	7c 33		 jl	 SHORT $LN59@MainThread
  00a1f	7f 0e		 jg	 SHORT $LN74@MainThread
  00a21	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR tv1069[ebp]
  00a27	3b 85 3c ff ff
	ff		 cmp	 eax, DWORD PTR tv1072[ebp]
  00a2d	76 23		 jbe	 SHORT $LN59@MainThread
$LN74@MainThread:
  00a2f	6a 00		 push	 0
  00a31	68 d8 02 00 00	 push	 728			; 000002d8H
  00a36	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@OJKOJEAN@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  00a3b	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@JKEACOCL@request?9?$DOEncryptedOffset?5?$CL?5reque@FNODOBFM@
  00a40	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  00a46	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv490[ebp], 0
  00a50	eb 0a		 jmp	 SHORT $LN60@MainThread
$LN59@MainThread:
  00a52	c7 85 38 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv490[ebp], 1
$LN60@MainThread:

; 729  : 
; 730  : 						dataUnit.Value = (request->Offset.QuadPart + request->EncryptedOffset) / ENCRYPTION_DATA_UNIT_SIZE;

  00a5c	8b 4d d4	 mov	 ecx, DWORD PTR _request$[ebp]
  00a5f	8b 55 d4	 mov	 edx, DWORD PTR _request$[ebp]
  00a62	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00a65	03 42 18	 add	 eax, DWORD PTR [edx+24]
  00a68	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00a6b	13 4a 1c	 adc	 ecx, DWORD PTR [edx+28]
  00a6e	6a 00		 push	 0
  00a70	68 00 02 00 00	 push	 512			; 00000200H
  00a75	51		 push	 ecx
  00a76	50		 push	 eax
  00a77	e8 00 00 00 00	 call	 __alldiv
  00a7c	89 45 98	 mov	 DWORD PTR _dataUnit$28121[ebp], eax
  00a7f	89 55 9c	 mov	 DWORD PTR _dataUnit$28121[ebp+4], edx

; 731  : 
; 732  : 						if (queue->CryptoInfo->bPartitionInInactiveSysEncScope)

  00a82	8b 55 d8	 mov	 edx, DWORD PTR _queue$[ebp]
  00a85	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00a88	83 b8 28 44 00
	00 00		 cmp	 DWORD PTR [eax+17448], 0
  00a8f	74 20		 je	 SHORT $LN4@MainThread

; 733  : 							dataUnit.Value += queue->CryptoInfo->FirstDataUnitNo.Value;

  00a91	8b 4d d8	 mov	 ecx, DWORD PTR _queue$[ebp]
  00a94	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00a97	8b 45 98	 mov	 eax, DWORD PTR _dataUnit$28121[ebp]
  00a9a	03 82 30 44 00
	00		 add	 eax, DWORD PTR [edx+17456]
  00aa0	8b 4d 9c	 mov	 ecx, DWORD PTR _dataUnit$28121[ebp+4]
  00aa3	13 8a 34 44 00
	00		 adc	 ecx, DWORD PTR [edx+17460]
  00aa9	89 45 98	 mov	 DWORD PTR _dataUnit$28121[ebp], eax
  00aac	89 4d 9c	 mov	 DWORD PTR _dataUnit$28121[ebp+4], ecx
  00aaf	eb 1e		 jmp	 SHORT $LN3@MainThread
$LN4@MainThread:

; 734  : 						else if (queue->RemapEncryptedArea)

  00ab1	8b 55 d8	 mov	 edx, DWORD PTR _queue$[ebp]
  00ab4	83 7a 5c 00	 cmp	 DWORD PTR [edx+92], 0
  00ab8	74 15		 je	 SHORT $LN3@MainThread

; 735  : 							dataUnit.Value += queue->RemappedAreaDataUnitOffset;

  00aba	8b 45 d8	 mov	 eax, DWORD PTR _queue$[ebp]
  00abd	8b 4d 98	 mov	 ecx, DWORD PTR _dataUnit$28121[ebp]
  00ac0	03 48 68	 add	 ecx, DWORD PTR [eax+104]
  00ac3	8b 55 9c	 mov	 edx, DWORD PTR _dataUnit$28121[ebp+4]
  00ac6	13 50 6c	 adc	 edx, DWORD PTR [eax+108]
  00ac9	89 4d 98	 mov	 DWORD PTR _dataUnit$28121[ebp], ecx
  00acc	89 55 9c	 mov	 DWORD PTR _dataUnit$28121[ebp+4], edx
$LN3@MainThread:

; 736  : 								
; 737  : 						EncryptDataUnits (activeFragmentBuffer + request->EncryptedOffset, &dataUnit, request->EncryptedLength / ENCRYPTION_DATA_UNIT_SIZE, queue->CryptoInfo);

  00acf	8b 45 d8	 mov	 eax, DWORD PTR _queue$[ebp]
  00ad2	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00ad5	51		 push	 ecx
  00ad6	8b 55 d4	 mov	 edx, DWORD PTR _request$[ebp]
  00ad9	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00adc	c1 e8 09	 shr	 eax, 9
  00adf	50		 push	 eax
  00ae0	8d 4d 98	 lea	 ecx, DWORD PTR _dataUnit$28121[ebp]
  00ae3	51		 push	 ecx
  00ae4	8b 55 d4	 mov	 edx, DWORD PTR _request$[ebp]
  00ae7	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00aea	03 45 dc	 add	 eax, DWORD PTR _activeFragmentBuffer$[ebp]
  00aed	50		 push	 eax
  00aee	e8 00 00 00 00	 call	 _EncryptDataUnits@16
$LN6@MainThread:

; 738  : 					}
; 739  : 				}
; 740  : 
; 741  : 				// Queue IO request
; 742  : 				ExInterlockedInsertTailList (&queue->IoThreadQueue, &request->ListEntry, &queue->IoThreadQueueLock);

  00af3	8b 4d d8	 mov	 ecx, DWORD PTR _queue$[ebp]
  00af6	81 c1 f4 00 00
	00		 add	 ecx, 244		; 000000f4H
  00afc	51		 push	 ecx
  00afd	8b 55 d4	 mov	 edx, DWORD PTR _request$[ebp]
  00b00	83 c2 2c	 add	 edx, 44			; 0000002cH
  00b03	8b 4d d8	 mov	 ecx, DWORD PTR _queue$[ebp]
  00b06	81 c1 ec 00 00
	00		 add	 ecx, 236		; 000000ecH
  00b0c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExfInterlockedInsertTailList@12

; 743  : 				KeSetEvent (&queue->IoThreadQueueNotEmptyEvent, IO_DISK_INCREMENT, FALSE);

  00b12	6a 00		 push	 0
  00b14	6a 01		 push	 1
  00b16	8b 55 d8	 mov	 edx, DWORD PTR _queue$[ebp]
  00b19	81 c2 f8 00 00
	00		 add	 edx, 248		; 000000f8H
  00b1f	52		 push	 edx
  00b20	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 744  : 
; 745  : 				if (isLastFragment)

  00b26	83 7d a0 00	 cmp	 DWORD PTR _isLastFragment$28111[ebp], 0
  00b2a	74 02		 je	 SHORT $LN1@MainThread

; 746  : 					break;

  00b2c	eb 31		 jmp	 SHORT $LN12@MainThread
$LN1@MainThread:

; 747  : 
; 748  : 				dataRemaining -= TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE;

  00b2e	8b 45 e4	 mov	 eax, DWORD PTR _dataRemaining$[ebp]
  00b31	2d 00 00 04 00	 sub	 eax, 262144		; 00040000H
  00b36	89 45 e4	 mov	 DWORD PTR _dataRemaining$[ebp], eax

; 749  : 				dataBuffer += TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE;

  00b39	8b 4d d0	 mov	 ecx, DWORD PTR _dataBuffer$[ebp]
  00b3c	81 c1 00 00 04
	00		 add	 ecx, 262144		; 00040000H
  00b42	89 4d d0	 mov	 DWORD PTR _dataBuffer$[ebp], ecx

; 750  : 				fragmentOffset.QuadPart += TC_ENC_IO_QUEUE_MAX_FRAGMENT_SIZE;

  00b45	8b 55 e8	 mov	 edx, DWORD PTR _fragmentOffset$[ebp]
  00b48	81 c2 00 00 04
	00		 add	 edx, 262144		; 00040000H
  00b4e	8b 45 ec	 mov	 eax, DWORD PTR _fragmentOffset$[ebp+4]
  00b51	83 d0 00	 adc	 eax, 0
  00b54	89 55 e8	 mov	 DWORD PTR _fragmentOffset$[ebp], edx
  00b57	89 45 ec	 mov	 DWORD PTR _fragmentOffset$[ebp+4], eax

; 751  : 			}

  00b5a	e9 a5 fc ff ff	 jmp	 $LN13@MainThread
$LN12@MainThread:

; 752  : 		}

  00b5f	e9 01 f5 ff ff	 jmp	 $LN42@MainThread
$LN41@MainThread:

; 753  : 	}

  00b64	e9 ce f4 ff ff	 jmp	 $LN45@MainThread
$LN44@MainThread:

; 754  : 
; 755  : 	PsTerminateSystemThread (STATUS_SUCCESS);

  00b69	6a 00		 push	 0
  00b6b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsTerminateSystemThread@4

; 756  : }

  00b71	5f		 pop	 edi
  00b72	5e		 pop	 esi
  00b73	8b e5		 mov	 esp, ebp
  00b75	5d		 pop	 ebp
  00b76	c2 04 00	 ret	 4
_MainThreadProc@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _AcquireFragmentBuffer@8
_TEXT	SEGMENT
_status$ = -4						; size = 4
_queue$ = 8						; size = 4
_buffer$ = 12						; size = 4
_AcquireFragmentBuffer@8 PROC				; COMDAT

; 190  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 191  : 	NTSTATUS status = STATUS_INVALID_PARAMETER;

  00006	c7 45 fc 0d 00
	00 c0		 mov	 DWORD PTR _status$[ebp], -1073741811 ; c000000dH

; 192  : 
; 193  : 	if (buffer == queue->FragmentBufferA)

  0000d	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00013	3b 88 28 01 00
	00		 cmp	 ecx, DWORD PTR [eax+296]
  00019	75 1d		 jne	 SHORT $LN4@AcquireFra

; 194  : 	{
; 195  : 		status = KeWaitForSingleObject (&queue->FragmentBufferAFreeEvent, Executive, KernelMode, FALSE, NULL);

  0001b	6a 00		 push	 0
  0001d	6a 00		 push	 0
  0001f	6a 00		 push	 0
  00021	6a 00		 push	 0
  00023	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  00026	81 c2 30 01 00
	00		 add	 edx, 304		; 00000130H
  0002c	52		 push	 edx
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
  00033	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax
  00036	eb 29		 jmp	 SHORT $LN3@AcquireFra
$LN4@AcquireFra:

; 196  : 	}
; 197  : 	else if (buffer == queue->FragmentBufferB)

  00038	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0003e	3b 88 2c 01 00
	00		 cmp	 ecx, DWORD PTR [eax+300]
  00044	75 1b		 jne	 SHORT $LN3@AcquireFra

; 198  : 	{
; 199  : 		status = KeWaitForSingleObject (&queue->FragmentBufferBFreeEvent, Executive, KernelMode, FALSE, NULL);

  00046	6a 00		 push	 0
  00048	6a 00		 push	 0
  0004a	6a 00		 push	 0
  0004c	6a 00		 push	 0
  0004e	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  00051	81 c2 40 01 00
	00		 add	 edx, 320		; 00000140H
  00057	52		 push	 edx
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
  0005e	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax
$LN3@AcquireFra:

; 200  : 	}
; 201  : 
; 202  : 	if (!NT_SUCCESS (status))

  00061	83 7d fc 00	 cmp	 DWORD PTR _status$[ebp], 0
  00065	7d 18		 jge	 SHORT $LN6@AcquireFra

; 203  : 		TC_BUG_CHECK (status);

  00067	68 43 54 00 00	 push	 21571			; 00005443H
  0006c	6a 00		 push	 0
  0006e	8b 45 fc	 mov	 eax, DWORD PTR _status$[ebp]
  00071	50		 push	 eax
  00072	68 cb 00 00 00	 push	 203			; 000000cbH
  00077	6a 29		 push	 41			; 00000029H
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN6@AcquireFra:

; 204  : }

  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 08 00	 ret	 8
_AcquireFragmentBuffer@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@LHJJPAN@Queue?5stopped?5?5out?$DN?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BI@FIKKAEEK@Queue?5stopping?5?5out?$DN?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BE@PAKNKFEC@?$CBqueue?9?$DOStopPending?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_EncryptedIoQueueStop@4
;	COMDAT ??_C@_0BH@LHJJPAN@Queue?5stopped?5?5out?$DN?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BH@LHJJPAN@Queue?5stopped?5?5out?$DN?$CFd?6?$AA@FNODOBFM@ DB 'Queu'
	DB	'e stopped  out=%d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BI@FIKKAEEK@Queue?5stopping?5?5out?$DN?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BI@FIKKAEEK@Queue?5stopping?5?5out?$DN?$CFd?6?$AA@FNODOBFM@ DB 'Qu'
	DB	'eue stopping  out=%d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BE@PAKNKFEC@?$CBqueue?9?$DOStopPending?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BE@PAKNKFEC@?$CBqueue?9?$DOStopPending?$AA@FNODOBFM@ DB '!queue->S'
	DB	'topPending', 00H				;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _EncryptedIoQueueStop@4
_TEXT	SEGMENT
tv71 = -4						; size = 4
_queue$ = 8						; size = 4
_EncryptedIoQueueStop@4 PROC				; COMDAT

; 983  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 984  : 	ASSERT (!queue->StopPending);

  00006	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  00009	83 b8 c8 01 00
	00 00		 cmp	 DWORD PTR [eax+456], 0
  00010	74 20		 je	 SHORT $LN5@EncryptedI@5
  00012	6a 00		 push	 0
  00014	68 d8 03 00 00	 push	 984			; 000003d8H
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@OJKOJEAN@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@PAKNKFEC@?$CBqueue?9?$DOStopPending?$AA@FNODOBFM@
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
  00030	eb 07		 jmp	 SHORT $LN6@EncryptedI@5
$LN5@EncryptedI@5:
  00032	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
$LN6@EncryptedI@5:

; 985  : 	queue->StopPending = TRUE;

  00039	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  0003c	c7 81 c8 01 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+456], 1
$LN2@EncryptedI@5:

; 986  : 	
; 987  : 	while (InterlockedExchangeAdd (&queue->OutstandingIoCount, 0) > 0)

  00046	33 d2		 xor	 edx, edx
  00048	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  0004b	05 80 01 00 00	 add	 eax, 384		; 00000180H
  00050	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  00054	85 d2		 test	 edx, edx
  00056	7e 1a		 jle	 SHORT $LN1@EncryptedI@5

; 988  : 	{
; 989  : 		KeWaitForSingleObject (&queue->NoOutstandingIoEvent, Executive, KernelMode, FALSE, NULL);

  00058	6a 00		 push	 0
  0005a	6a 00		 push	 0
  0005c	6a 00		 push	 0
  0005e	6a 00		 push	 0
  00060	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  00063	81 c1 84 01 00
	00		 add	 ecx, 388		; 00000184H
  00069	51		 push	 ecx
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 990  : 	}

  00070	eb d4		 jmp	 SHORT $LN2@EncryptedI@5
$LN1@EncryptedI@5:

; 991  : 
; 992  : 	Dump ("Queue stopping  out=%d\n", queue->OutstandingIoCount);

  00072	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  00075	8b 82 80 01 00
	00		 mov	 eax, DWORD PTR [edx+384]
  0007b	50		 push	 eax
  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@FIKKAEEK@Queue?5stopping?5?5out?$DN?$CFd?6?$AA@FNODOBFM@
  00081	e8 00 00 00 00	 call	 _DbgPrint
  00086	83 c4 08	 add	 esp, 8

; 993  : 
; 994  : 	queue->ThreadExitRequested = TRUE;

  00089	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  0008c	c7 81 bc 01 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+444], 1

; 995  : 
; 996  : 	TCStopThread (queue->MainThread, &queue->MainThreadQueueNotEmptyEvent);

  00096	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  00099	81 c2 d8 00 00
	00		 add	 edx, 216		; 000000d8H
  0009f	52		 push	 edx
  000a0	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  000a3	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  000a9	51		 push	 ecx
  000aa	e8 00 00 00 00	 call	 _TCStopThread@8

; 997  : 	TCStopThread (queue->IoThread, &queue->IoThreadQueueNotEmptyEvent);

  000af	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  000b2	81 c2 f8 00 00
	00		 add	 edx, 248		; 000000f8H
  000b8	52		 push	 edx
  000b9	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  000bc	8b 88 e8 00 00
	00		 mov	 ecx, DWORD PTR [eax+232]
  000c2	51		 push	 ecx
  000c3	e8 00 00 00 00	 call	 _TCStopThread@8

; 998  : 	TCStopThread (queue->CompletionThread, &queue->CompletionThreadQueueNotEmptyEvent);

  000c8	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  000cb	81 c2 18 01 00
	00		 add	 edx, 280		; 00000118H
  000d1	52		 push	 edx
  000d2	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  000d5	8b 88 08 01 00
	00		 mov	 ecx, DWORD PTR [eax+264]
  000db	51		 push	 ecx
  000dc	e8 00 00 00 00	 call	 _TCStopThread@8

; 999  : 
; 1000 : 	TCfree (queue->FragmentBufferA);

  000e1	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  000e6	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  000e9	8b 82 28 01 00
	00		 mov	 eax, DWORD PTR [edx+296]
  000ef	50		 push	 eax
  000f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 1001 : 	TCfree (queue->FragmentBufferB);

  000f6	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  000fb	8b 4d 08	 mov	 ecx, DWORD PTR _queue$[ebp]
  000fe	8b 91 2c 01 00
	00		 mov	 edx, DWORD PTR [ecx+300]
  00104	52		 push	 edx
  00105	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 1002 : 	TCfree (queue->ReadAheadBuffer);

  0010b	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00110	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  00113	8b 88 74 01 00
	00		 mov	 ecx, DWORD PTR [eax+372]
  00119	51		 push	 ecx
  0011a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 1003 : 
; 1004 : 	FreePoolBuffers (queue);

  00120	8b 55 08	 mov	 edx, DWORD PTR _queue$[ebp]
  00123	52		 push	 edx
  00124	e8 00 00 00 00	 call	 _FreePoolBuffers@4

; 1005 : 
; 1006 : 	Dump ("Queue stopped  out=%d\n", queue->OutstandingIoCount);

  00129	8b 45 08	 mov	 eax, DWORD PTR _queue$[ebp]
  0012c	8b 88 80 01 00
	00		 mov	 ecx, DWORD PTR [eax+384]
  00132	51		 push	 ecx
  00133	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LHJJPAN@Queue?5stopped?5?5out?$DN?$CFd?6?$AA@FNODOBFM@
  00138	e8 00 00 00 00	 call	 _DbgPrint
  0013d	83 c4 08	 add	 esp, 8

; 1007 : 	return STATUS_SUCCESS;

  00140	33 c0		 xor	 eax, eax

; 1008 : }

  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c2 04 00	 ret	 4
_EncryptedIoQueueStop@4 ENDP
_TEXT	ENDS
END
