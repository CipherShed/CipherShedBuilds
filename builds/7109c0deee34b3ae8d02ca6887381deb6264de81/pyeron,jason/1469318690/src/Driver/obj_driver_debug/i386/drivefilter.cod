; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\users\public\desktop\projects\ciphershed\src\driver\drivefilter.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_BootArgsValid
PUBLIC	_EncryptionSetupThread
PUBLIC	_DecoySystemWipeThread
_DATA	SEGMENT
COMM	_BootArgs:BYTE:076H
_DATA	ENDS
_BSS	SEGMENT
_DeviceFilterActive DD 01H DUP (?)
_BootArgsValid DD 01H DUP (?)
_BootDriveSignatureValid DD 01H DUP (?)
_BootDriveFound DD 01H DUP (?)
_BootDriveFilterExtension DD 01H DUP (?)
_CrashDumpEnabled DD 01H DUP (?)
_HibernationEnabled DD 01H DUP (?)
_LegacyHibernationDriverFilterActive DD 01H DUP (?)
_HibernationWriteBuffer DD 01H DUP (?)
_HibernationWriteBufferMdl DD 01H DUP (?)
_HibernationPreventionCount DD 01H DUP (?)
_SetupInProgress DD 01H DUP (?)
_EncryptionSetupThread DD 01H DUP (?)
_DecoySystemWipeInProgress DD 01H DUP (?)
_DecoySystemWipeThread DD 01H DUP (?)
_LastHiberFilterNumber DD 01H DUP (?)
_BSS	ENDS
PUBLIC	??_C@_0BJ@FBGGCCGI@BootArgumentsCrc32?5?$DN?5?$CFx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BJ@DENLEODJ@BootDriveSignature?5?$DN?5?$CFx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0M@KEDLLGKK@Flags?5?$DN?5?$CFx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CD@BAEBNNNN@DecoySystemPartitionStart?5?$DN?5?$CFI64@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CE@JLLKOMJD@HiddenSystemPartitionStart?5?$DN?5?$CFI6@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BH@OFNGPMHI@CryptoInfoLength?5?$DN?5?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BH@DOJHKKND@CryptoInfoOffset?5?$DN?5?$CFx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BG@PNJAPAAK@HeaderSaltCrc32?5?$DN?5?$CFx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BI@NEHGCDJA@BootLoaderVersion?5?$DN?5?$CFx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BN@NBHIKKLK@BootArguments?5CRC?5incorrect?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BN@JFNHMJPM@BootArguments?5found?5at?50x?$CFx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CA@ILBJGGPO@Checking?5BootArguments?5at?50x?$CFx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_LoadBootArguments@0
EXTRN	__imp__MmUnmapIoSpace@8:PROC
EXTRN	_AddPasswordToCache@4:PROC
EXTRN	_CacheBootPassword:DWORD
EXTRN	__imp__KeBugCheckEx@20:PROC
EXTRN	_GetCrc32@8:PROC
EXTRN	_DumpMemory@8:PROC
EXTRN	__imp__MmMapIoSpace@16:PROC
EXTRN	_DbgPrint:PROC
EXTRN	__imp__KeInitializeMutex@8:PROC
EXTRN	_memset:PROC
_BSS	SEGMENT
_BootLoaderSegment DW 01H DUP (?)
	ALIGN	4

_MountMutex DB	020H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BJ@FBGGCCGI@BootArgumentsCrc32?5?$DN?5?$CFx?6?$AA@FNODOBFM@
; File c:\users\public\desktop\projects\ciphershed\src\driver\drivefilter.c
text$s	SEGMENT
??_C@_0BJ@FBGGCCGI@BootArgumentsCrc32?5?$DN?5?$CFx?6?$AA@FNODOBFM@ DB 'Bo'
	DB	'otArgumentsCrc32 = %x', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BJ@DENLEODJ@BootDriveSignature?5?$DN?5?$CFx?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BJ@DENLEODJ@BootDriveSignature?5?$DN?5?$CFx?6?$AA@FNODOBFM@ DB 'Bo'
	DB	'otDriveSignature = %x', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0M@KEDLLGKK@Flags?5?$DN?5?$CFx?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0M@KEDLLGKK@Flags?5?$DN?5?$CFx?6?$AA@FNODOBFM@ DB 'Flags = %x', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CD@BAEBNNNN@DecoySystemPartitionStart?5?$DN?5?$CFI64@FNODOBFM@
text$s	SEGMENT
??_C@_0CD@BAEBNNNN@DecoySystemPartitionStart?5?$DN?5?$CFI64@FNODOBFM@ DB 'D'
	DB	'ecoySystemPartitionStart = %I64u', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CE@JLLKOMJD@HiddenSystemPartitionStart?5?$DN?5?$CFI6@FNODOBFM@
text$s	SEGMENT
??_C@_0CE@JLLKOMJD@HiddenSystemPartitionStart?5?$DN?5?$CFI6@FNODOBFM@ DB 'H'
	DB	'iddenSystemPartitionStart = %I64u', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BH@OFNGPMHI@CryptoInfoLength?5?$DN?5?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BH@OFNGPMHI@CryptoInfoLength?5?$DN?5?$CFd?6?$AA@FNODOBFM@ DB 'Cryp'
	DB	'toInfoLength = %d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BH@DOJHKKND@CryptoInfoOffset?5?$DN?5?$CFx?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BH@DOJHKKND@CryptoInfoOffset?5?$DN?5?$CFx?6?$AA@FNODOBFM@ DB 'Cryp'
	DB	'toInfoOffset = %x', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BG@PNJAPAAK@HeaderSaltCrc32?5?$DN?5?$CFx?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BG@PNJAPAAK@HeaderSaltCrc32?5?$DN?5?$CFx?6?$AA@FNODOBFM@ DB 'Heade'
	DB	'rSaltCrc32 = %x', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BI@NEHGCDJA@BootLoaderVersion?5?$DN?5?$CFx?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BI@NEHGCDJA@BootLoaderVersion?5?$DN?5?$CFx?6?$AA@FNODOBFM@ DB 'Boo'
	DB	'tLoaderVersion = %x', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BN@NBHIKKLK@BootArguments?5CRC?5incorrect?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BN@NBHIKKLK@BootArguments?5CRC?5incorrect?6?$AA@FNODOBFM@ DB 'Boot'
	DB	'Arguments CRC incorrect', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BN@JFNHMJPM@BootArguments?5found?5at?50x?$CFx?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BN@JFNHMJPM@BootArguments?5found?5at?50x?$CFx?6?$AA@FNODOBFM@ DB 'B'
	DB	'ootArguments found at 0x%x', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CA@ILBJGGPO@Checking?5BootArguments?5at?50x?$CFx?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0CA@ILBJGGPO@Checking?5BootArguments?5at?50x?$CFx?6?$AA@FNODOBFM@ DB 'C'
	DB	'hecking BootArguments at 0x%x', 0aH, 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _LoadBootArguments@0
_TEXT	SEGMENT
_bootArguments$27869 = -24				; size = 4
_status$ = -20						; size = 4
_bootArgsAddr$ = -16					; size = 8
_mappedBootArgs$ = -8					; size = 4
_bootLoaderSegment$ = -4				; size = 2
_LoadBootArguments@0 PROC				; COMDAT

; 69   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 18	 sub	 esp, 24			; 00000018H
  00008	56		 push	 esi
  00009	57		 push	 edi

; 70   : 	NTSTATUS status = STATUS_UNSUCCESSFUL;

  0000a	c7 45 ec 01 00
	00 c0		 mov	 DWORD PTR _status$[ebp], -1073741823 ; c0000001H

; 71   : 	PHYSICAL_ADDRESS bootArgsAddr;
; 72   : 	byte *mappedBootArgs;
; 73   : 	uint16 bootLoaderSegment;
; 74   : 
; 75   : 	KeInitializeMutex (&MountMutex, 0);

  00011	6a 00		 push	 0
  00013	68 00 00 00 00	 push	 OFFSET _MountMutex
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeMutex@8

; 76   : 
; 77   : 	for (bootLoaderSegment = TC_BOOT_LOADER_SEGMENT;
; 78   : 		bootLoaderSegment >= TC_BOOT_LOADER_SEGMENT - 64 * 1024 / 16 && status != STATUS_SUCCESS;
; 79   : 		bootLoaderSegment -= 32 * 1024 / 16)

  0001e	b8 00 90 00 00	 mov	 eax, 36864		; 00009000H
  00023	66 89 45 fc	 mov	 WORD PTR _bootLoaderSegment$[ebp], ax
  00027	eb 0e		 jmp	 SHORT $LN9@LoadBootAr
$LN8@LoadBootAr:
  00029	0f b7 4d fc	 movzx	 ecx, WORD PTR _bootLoaderSegment$[ebp]
  0002d	81 e9 00 08 00
	00		 sub	 ecx, 2048		; 00000800H
  00033	66 89 4d fc	 mov	 WORD PTR _bootLoaderSegment$[ebp], cx
$LN9@LoadBootAr:
  00037	0f b7 55 fc	 movzx	 edx, WORD PTR _bootLoaderSegment$[ebp]
  0003b	81 fa 00 80 00
	00		 cmp	 edx, 32768		; 00008000H
  00041	0f 8c d2 02 00
	00		 jl	 $LN7@LoadBootAr
  00047	83 7d ec 00	 cmp	 DWORD PTR _status$[ebp], 0
  0004b	0f 84 c8 02 00
	00		 je	 $LN7@LoadBootAr

; 80   : 	{
; 81   : 		bootArgsAddr.QuadPart = (bootLoaderSegment << 4) + TC_BOOT_LOADER_ARGS_OFFSET;

  00051	0f b7 45 fc	 movzx	 eax, WORD PTR _bootLoaderSegment$[ebp]
  00055	c1 e0 04	 shl	 eax, 4
  00058	83 c0 10	 add	 eax, 16			; 00000010H
  0005b	99		 cdq
  0005c	89 45 f0	 mov	 DWORD PTR _bootArgsAddr$[ebp], eax
  0005f	89 55 f4	 mov	 DWORD PTR _bootArgsAddr$[ebp+4], edx

; 82   : 		Dump ("Checking BootArguments at 0x%x\n", bootArgsAddr.LowPart);

  00062	8b 45 f0	 mov	 eax, DWORD PTR _bootArgsAddr$[ebp]
  00065	50		 push	 eax
  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@ILBJGGPO@Checking?5BootArguments?5at?50x?$CFx?6?$AA@FNODOBFM@
  0006b	e8 00 00 00 00	 call	 _DbgPrint
  00070	83 c4 08	 add	 esp, 8

; 83   : 
; 84   : 		mappedBootArgs = MmMapIoSpace (bootArgsAddr, sizeof (BootArguments), MmCached);

  00073	6a 01		 push	 1
  00075	6a 76		 push	 118			; 00000076H
  00077	8b 4d f4	 mov	 ecx, DWORD PTR _bootArgsAddr$[ebp+4]
  0007a	51		 push	 ecx
  0007b	8b 55 f0	 mov	 edx, DWORD PTR _bootArgsAddr$[ebp]
  0007e	52		 push	 edx
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmMapIoSpace@16
  00085	89 45 f8	 mov	 DWORD PTR _mappedBootArgs$[ebp], eax

; 85   : 		if (!mappedBootArgs)

  00088	83 7d f8 00	 cmp	 DWORD PTR _mappedBootArgs$[ebp], 0
  0008c	75 0a		 jne	 SHORT $LN6@LoadBootAr

; 86   : 			return STATUS_INSUFFICIENT_RESOURCES;

  0008e	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  00093	e9 84 02 00 00	 jmp	 $LN11@LoadBootAr
$LN6@LoadBootAr:

; 87   : 
; 88   : 		if (TC_IS_BOOT_ARGUMENTS_SIGNATURE (mappedBootArgs))

  00098	8b 45 f8	 mov	 eax, DWORD PTR _mappedBootArgs$[ebp]
  0009b	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0009e	83 f9 54	 cmp	 ecx, 84			; 00000054H
  000a1	0f 85 61 02 00
	00		 jne	 $LN5@LoadBootAr
  000a7	8b 55 f8	 mov	 edx, DWORD PTR _mappedBootArgs$[ebp]
  000aa	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  000ae	83 f8 52	 cmp	 eax, 82			; 00000052H
  000b1	0f 85 51 02 00
	00		 jne	 $LN5@LoadBootAr
  000b7	8b 4d f8	 mov	 ecx, DWORD PTR _mappedBootArgs$[ebp]
  000ba	0f b6 51 02	 movzx	 edx, BYTE PTR [ecx+2]
  000be	83 fa 55	 cmp	 edx, 85			; 00000055H
  000c1	0f 85 41 02 00
	00		 jne	 $LN5@LoadBootAr
  000c7	8b 45 f8	 mov	 eax, DWORD PTR _mappedBootArgs$[ebp]
  000ca	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  000ce	83 f9 45	 cmp	 ecx, 69			; 00000045H
  000d1	0f 85 31 02 00
	00		 jne	 $LN5@LoadBootAr
  000d7	8b 55 f8	 mov	 edx, DWORD PTR _mappedBootArgs$[ebp]
  000da	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  000de	83 f8 11	 cmp	 eax, 17			; 00000011H
  000e1	0f 85 21 02 00
	00		 jne	 $LN5@LoadBootAr
  000e7	8b 4d f8	 mov	 ecx, DWORD PTR _mappedBootArgs$[ebp]
  000ea	0f b6 51 05	 movzx	 edx, BYTE PTR [ecx+5]
  000ee	83 fa 23	 cmp	 edx, 35			; 00000023H
  000f1	0f 85 11 02 00
	00		 jne	 $LN5@LoadBootAr
  000f7	8b 45 f8	 mov	 eax, DWORD PTR _mappedBootArgs$[ebp]
  000fa	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  000fe	83 f9 45	 cmp	 ecx, 69			; 00000045H
  00101	0f 85 01 02 00
	00		 jne	 $LN5@LoadBootAr
  00107	8b 55 f8	 mov	 edx, DWORD PTR _mappedBootArgs$[ebp]
  0010a	0f b6 42 07	 movzx	 eax, BYTE PTR [edx+7]
  0010e	83 f8 66	 cmp	 eax, 102		; 00000066H
  00111	0f 85 f1 01 00
	00		 jne	 $LN5@LoadBootAr

; 89   : 		{
; 90   : 			BootArguments *bootArguments = (BootArguments *) mappedBootArgs;

  00117	8b 4d f8	 mov	 ecx, DWORD PTR _mappedBootArgs$[ebp]
  0011a	89 4d e8	 mov	 DWORD PTR _bootArguments$27869[ebp], ecx

; 91   : 			Dump ("BootArguments found at 0x%x\n", bootArgsAddr.LowPart);

  0011d	8b 55 f0	 mov	 edx, DWORD PTR _bootArgsAddr$[ebp]
  00120	52		 push	 edx
  00121	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JFNHMJPM@BootArguments?5found?5at?50x?$CFx?6?$AA@FNODOBFM@
  00126	e8 00 00 00 00	 call	 _DbgPrint
  0012b	83 c4 08	 add	 esp, 8

; 92   : 
; 93   : 			DumpMem (mappedBootArgs, sizeof (BootArguments));

  0012e	6a 76		 push	 118			; 00000076H
  00130	8b 45 f8	 mov	 eax, DWORD PTR _mappedBootArgs$[ebp]
  00133	50		 push	 eax
  00134	e8 00 00 00 00	 call	 _DumpMemory@8

; 94   : 
; 95   : 			if (bootArguments->BootLoaderVersion == VERSION_NUM
; 96   : 				&& bootArguments->BootArgumentsCrc32 != GetCrc32 ((byte *) bootArguments, (int) ((byte *) &bootArguments->BootArgumentsCrc32 - (byte *) bootArguments)))

  00139	8b 4d e8	 mov	 ecx, DWORD PTR _bootArguments$27869[ebp]
  0013c	0f b7 51 08	 movzx	 edx, WORD PTR [ecx+8]
  00140	81 fa 41 07 00
	00		 cmp	 edx, 1857		; 00000741H
  00146	75 3e		 jne	 SHORT $LN4@LoadBootAr
  00148	8b 45 e8	 mov	 eax, DWORD PTR _bootArguments$27869[ebp]
  0014b	83 c0 72	 add	 eax, 114		; 00000072H
  0014e	2b 45 e8	 sub	 eax, DWORD PTR _bootArguments$27869[ebp]
  00151	50		 push	 eax
  00152	8b 4d e8	 mov	 ecx, DWORD PTR _bootArguments$27869[ebp]
  00155	51		 push	 ecx
  00156	e8 00 00 00 00	 call	 _GetCrc32@8
  0015b	8b 55 e8	 mov	 edx, DWORD PTR _bootArguments$27869[ebp]
  0015e	39 42 72	 cmp	 DWORD PTR [edx+114], eax
  00161	74 23		 je	 SHORT $LN4@LoadBootAr

; 97   : 			{
; 98   : 				Dump ("BootArguments CRC incorrect\n");

  00163	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@NBHIKKLK@BootArguments?5CRC?5incorrect?6?$AA@FNODOBFM@
  00168	e8 00 00 00 00	 call	 _DbgPrint
  0016d	83 c4 04	 add	 esp, 4

; 99   : 				TC_BUG_CHECK (STATUS_CRC_ERROR);

  00170	68 43 54 00 00	 push	 21571			; 00005443H
  00175	6a 00		 push	 0
  00177	68 3f 00 00 c0	 push	 -1073741761		; c000003fH
  0017c	6a 63		 push	 99			; 00000063H
  0017e	6a 29		 push	 41			; 00000029H
  00180	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN4@LoadBootAr:

; 100  : 			}
; 101  : 
; 102  : 			BootLoaderSegment = bootLoaderSegment;

  00186	66 8b 45 fc	 mov	 ax, WORD PTR _bootLoaderSegment$[ebp]
  0018a	66 a3 00 00 00
	00		 mov	 WORD PTR _BootLoaderSegment, ax

; 103  : 
; 104  : 			BootArgs = *bootArguments;

  00190	8b 75 e8	 mov	 esi, DWORD PTR _bootArguments$27869[ebp]
  00193	b9 1d 00 00 00	 mov	 ecx, 29			; 0000001dH
  00198	bf 00 00 00 00	 mov	 edi, OFFSET _BootArgs
  0019d	f3 a5		 rep movsd
  0019f	66 a5		 movsw

; 105  : 			BootArgsValid = TRUE;

  001a1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _BootArgsValid, 1

; 106  : 			memset (bootArguments, 0, sizeof (*bootArguments));

  001ab	6a 76		 push	 118			; 00000076H
  001ad	6a 00		 push	 0
  001af	8b 4d e8	 mov	 ecx, DWORD PTR _bootArguments$27869[ebp]
  001b2	51		 push	 ecx
  001b3	e8 00 00 00 00	 call	 _memset
  001b8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 107  : 
; 108  : 			if (BootArgs.BootLoaderVersion < 0x600)

  001bb	0f b7 15 08 00
	00 00		 movzx	 edx, WORD PTR _BootArgs+8
  001c2	81 fa 00 06 00
	00		 cmp	 edx, 1536		; 00000600H
  001c8	7d 28		 jge	 SHORT $LN3@LoadBootAr

; 109  : 			{
; 110  : 				BootArgs.HiddenSystemPartitionStart = 0;

  001ca	c7 05 5a 00 00
	00 00 00 00 00	 mov	 DWORD PTR _BootArgs+90, 0
  001d4	c7 05 5e 00 00
	00 00 00 00 00	 mov	 DWORD PTR _BootArgs+94, 0

; 111  : 				BootArgs.DecoySystemPartitionStart = 0;

  001de	c7 05 62 00 00
	00 00 00 00 00	 mov	 DWORD PTR _BootArgs+98, 0
  001e8	c7 05 66 00 00
	00 00 00 00 00	 mov	 DWORD PTR _BootArgs+102, 0
$LN3@LoadBootAr:

; 112  : 			}
; 113  : 
; 114  : 			if (BootArgs.BootLoaderVersion < 0x630)

  001f2	0f b7 05 08 00
	00 00		 movzx	 eax, WORD PTR _BootArgs+8
  001f9	3d 30 06 00 00	 cmp	 eax, 1584		; 00000630H
  001fe	7d 0a		 jge	 SHORT $LN2@LoadBootAr

; 115  : 				BootArgs.Flags = 0;

  00200	c7 05 6a 00 00
	00 00 00 00 00	 mov	 DWORD PTR _BootArgs+106, 0
$LN2@LoadBootAr:

; 116  : 
; 117  : 			BootDriveSignatureValid = (BootArgs.BootLoaderVersion >= 0x710);

  0020a	0f b7 0d 08 00
	00 00		 movzx	 ecx, WORD PTR _BootArgs+8
  00211	33 d2		 xor	 edx, edx
  00213	81 f9 10 07 00
	00		 cmp	 ecx, 1808		; 00000710H
  00219	0f 9d c2	 setge	 dl
  0021c	89 15 00 00 00
	00		 mov	 DWORD PTR _BootDriveSignatureValid, edx

; 118  : 
; 119  : 			Dump ("BootLoaderVersion = %x\n", (int) BootArgs.BootLoaderVersion);

  00222	0f b7 05 08 00
	00 00		 movzx	 eax, WORD PTR _BootArgs+8
  00229	50		 push	 eax
  0022a	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@NEHGCDJA@BootLoaderVersion?5?$DN?5?$CFx?6?$AA@FNODOBFM@
  0022f	e8 00 00 00 00	 call	 _DbgPrint
  00234	83 c4 08	 add	 esp, 8

; 120  : 			Dump ("HeaderSaltCrc32 = %x\n", (int) BootArgs.HeaderSaltCrc32);

  00237	8b 0d 0e 00 00
	00		 mov	 ecx, DWORD PTR _BootArgs+14
  0023d	51		 push	 ecx
  0023e	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@PNJAPAAK@HeaderSaltCrc32?5?$DN?5?$CFx?6?$AA@FNODOBFM@
  00243	e8 00 00 00 00	 call	 _DbgPrint
  00248	83 c4 08	 add	 esp, 8

; 121  : 			Dump ("CryptoInfoOffset = %x\n", (int) BootArgs.CryptoInfoOffset);

  0024b	0f b7 15 0a 00
	00 00		 movzx	 edx, WORD PTR _BootArgs+10
  00252	52		 push	 edx
  00253	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@DOJHKKND@CryptoInfoOffset?5?$DN?5?$CFx?6?$AA@FNODOBFM@
  00258	e8 00 00 00 00	 call	 _DbgPrint
  0025d	83 c4 08	 add	 esp, 8

; 122  : 			Dump ("CryptoInfoLength = %d\n", (int) BootArgs.CryptoInfoLength);

  00260	0f b7 05 0c 00
	00 00		 movzx	 eax, WORD PTR _BootArgs+12
  00267	50		 push	 eax
  00268	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@OFNGPMHI@CryptoInfoLength?5?$DN?5?$CFd?6?$AA@FNODOBFM@
  0026d	e8 00 00 00 00	 call	 _DbgPrint
  00272	83 c4 08	 add	 esp, 8

; 123  : 			Dump ("HiddenSystemPartitionStart = %I64u\n", BootArgs.HiddenSystemPartitionStart);

  00275	8b 0d 5e 00 00
	00		 mov	 ecx, DWORD PTR _BootArgs+94
  0027b	51		 push	 ecx
  0027c	8b 15 5a 00 00
	00		 mov	 edx, DWORD PTR _BootArgs+90
  00282	52		 push	 edx
  00283	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@JLLKOMJD@HiddenSystemPartitionStart?5?$DN?5?$CFI6@FNODOBFM@
  00288	e8 00 00 00 00	 call	 _DbgPrint
  0028d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 124  : 			Dump ("DecoySystemPartitionStart = %I64u\n", BootArgs.DecoySystemPartitionStart);

  00290	a1 66 00 00 00	 mov	 eax, DWORD PTR _BootArgs+102
  00295	50		 push	 eax
  00296	8b 0d 62 00 00
	00		 mov	 ecx, DWORD PTR _BootArgs+98
  0029c	51		 push	 ecx
  0029d	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@BAEBNNNN@DecoySystemPartitionStart?5?$DN?5?$CFI64@FNODOBFM@
  002a2	e8 00 00 00 00	 call	 _DbgPrint
  002a7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 125  : 			Dump ("Flags = %x\n", BootArgs.Flags);

  002aa	8b 15 6a 00 00
	00		 mov	 edx, DWORD PTR _BootArgs+106
  002b0	52		 push	 edx
  002b1	68 00 00 00 00	 push	 OFFSET ??_C@_0M@KEDLLGKK@Flags?5?$DN?5?$CFx?6?$AA@FNODOBFM@
  002b6	e8 00 00 00 00	 call	 _DbgPrint
  002bb	83 c4 08	 add	 esp, 8

; 126  : 			Dump ("BootDriveSignature = %x\n", BootArgs.BootDriveSignature);

  002be	a1 6e 00 00 00	 mov	 eax, DWORD PTR _BootArgs+110
  002c3	50		 push	 eax
  002c4	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DENLEODJ@BootDriveSignature?5?$DN?5?$CFx?6?$AA@FNODOBFM@
  002c9	e8 00 00 00 00	 call	 _DbgPrint
  002ce	83 c4 08	 add	 esp, 8

; 127  : 			Dump ("BootArgumentsCrc32 = %x\n", BootArgs.BootArgumentsCrc32);

  002d1	8b 0d 72 00 00
	00		 mov	 ecx, DWORD PTR _BootArgs+114
  002d7	51		 push	 ecx
  002d8	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@FBGGCCGI@BootArgumentsCrc32?5?$DN?5?$CFx?6?$AA@FNODOBFM@
  002dd	e8 00 00 00 00	 call	 _DbgPrint
  002e2	83 c4 08	 add	 esp, 8

; 128  : 
; 129  : 			if (CacheBootPassword && BootArgs.BootPassword.Length > 0)

  002e5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _CacheBootPassword, 0
  002ec	74 13		 je	 SHORT $LN1@LoadBootAr
  002ee	83 3d 12 00 00
	00 00		 cmp	 DWORD PTR _BootArgs+18, 0
  002f5	76 0a		 jbe	 SHORT $LN1@LoadBootAr

; 130  : 				AddPasswordToCache (&BootArgs.BootPassword);

  002f7	68 12 00 00 00	 push	 OFFSET _BootArgs+18
  002fc	e8 00 00 00 00	 call	 _AddPasswordToCache@4
$LN1@LoadBootAr:

; 131  : 
; 132  : 			status = STATUS_SUCCESS;

  00301	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _status$[ebp], 0
$LN5@LoadBootAr:

; 133  : 		}
; 134  : 
; 135  : 		MmUnmapIoSpace (mappedBootArgs, sizeof (BootArguments));

  00308	6a 76		 push	 118			; 00000076H
  0030a	8b 55 f8	 mov	 edx, DWORD PTR _mappedBootArgs$[ebp]
  0030d	52		 push	 edx
  0030e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmUnmapIoSpace@8

; 136  : 	}

  00314	e9 10 fd ff ff	 jmp	 $LN8@LoadBootAr
$LN7@LoadBootAr:

; 137  : 
; 138  : 	return status;

  00319	8b 45 ec	 mov	 eax, DWORD PTR _status$[ebp]
$LN11@LoadBootAr:

; 139  : }

  0031c	5f		 pop	 edi
  0031d	5e		 pop	 esi
  0031e	8b e5		 mov	 esp, ebp
  00320	5d		 pop	 ebp
  00321	c3		 ret	 0
_LoadBootArguments@0 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@FJJFAJFG@DriveFilterAddDevice?5pdo?$DN?$CFp?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_DriveFilterAddDevice@8
EXTRN	__imp__IoDeleteDevice@4:PROC
EXTRN	__imp__IoDetachDevice@4:PROC
EXTRN	__imp__IoInitializeRemoveLockEx@20:PROC
EXTRN	__imp__IoAttachDeviceToDeviceStack@8:PROC
EXTRN	__imp_@ObfDereferenceObject@4:PROC
EXTRN	__imp__IoCreateDevice@28:PROC
EXTRN	__imp__IoGetAttachedDeviceReference@4:PROC
;	COMDAT ??_C@_0BN@FJJFAJFG@DriveFilterAddDevice?5pdo?$DN?$CFp?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BN@FJJFAJFG@DriveFilterAddDevice?5pdo?$DN?$CFp?6?$AA@FNODOBFM@ DB 'D'
	DB	'riveFilterAddDevice pdo=%p', 0aH, 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _DriveFilterAddDevice@8
_TEXT	SEGMENT
_filterDeviceObject$ = -16				; size = 4
_status$ = -12						; size = 4
_attachedDeviceObject$ = -8				; size = 4
_Extension$ = -4					; size = 4
_driverObject$ = 8					; size = 4
_pdo$ = 12						; size = 4
_DriveFilterAddDevice@8 PROC				; COMDAT

; 143  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 10	 sub	 esp, 16			; 00000010H

; 144  : 	DriveFilterExtension *Extension;
; 145  : 	NTSTATUS status;
; 146  : 	PDEVICE_OBJECT filterDeviceObject = NULL;

  00008	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _filterDeviceObject$[ebp], 0

; 147  : 	PDEVICE_OBJECT attachedDeviceObject;
; 148  : 
; 149  : 	Dump ("DriveFilterAddDevice pdo=%p\n", pdo);

  0000f	8b 45 0c	 mov	 eax, DWORD PTR _pdo$[ebp]
  00012	50		 push	 eax
  00013	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@FJJFAJFG@DriveFilterAddDevice?5pdo?$DN?$CFp?6?$AA@FNODOBFM@
  00018	e8 00 00 00 00	 call	 _DbgPrint
  0001d	83 c4 08	 add	 esp, 8

; 150  : 
; 151  : 	attachedDeviceObject = IoGetAttachedDeviceReference (pdo);

  00020	8b 4d 0c	 mov	 ecx, DWORD PTR _pdo$[ebp]
  00023	51		 push	 ecx
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoGetAttachedDeviceReference@4
  0002a	89 45 f8	 mov	 DWORD PTR _attachedDeviceObject$[ebp], eax

; 152  : 	status = IoCreateDevice (driverObject, sizeof (DriveFilterExtension), NULL, attachedDeviceObject->DeviceType, 0, FALSE, &filterDeviceObject);

  0002d	8d 55 f0	 lea	 edx, DWORD PTR _filterDeviceObject$[ebp]
  00030	52		 push	 edx
  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8b 45 f8	 mov	 eax, DWORD PTR _attachedDeviceObject$[ebp]
  00038	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0003b	51		 push	 ecx
  0003c	6a 00		 push	 0
  0003e	68 50 02 00 00	 push	 592			; 00000250H
  00043	8b 55 08	 mov	 edx, DWORD PTR _driverObject$[ebp]
  00046	52		 push	 edx
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoCreateDevice@28
  0004d	89 45 f4	 mov	 DWORD PTR _status$[ebp], eax

; 153  : 
; 154  : 	ObDereferenceObject (attachedDeviceObject);

  00050	8b 4d f8	 mov	 ecx, DWORD PTR _attachedDeviceObject$[ebp]
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 155  : 
; 156  : 	if (!NT_SUCCESS (status))

  00059	83 7d f4 00	 cmp	 DWORD PTR _status$[ebp], 0
  0005d	7d 0c		 jge	 SHORT $LN4@DriveFilte

; 157  : 	{
; 158  : 		filterDeviceObject = NULL;

  0005f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _filterDeviceObject$[ebp], 0

; 159  : 		goto err;

  00066	e9 38 01 00 00	 jmp	 $err$27916
$LN4@DriveFilte:

; 160  : 	}
; 161  : 
; 162  : 	Extension = (DriveFilterExtension *) filterDeviceObject->DeviceExtension;

  0006b	8b 45 f0	 mov	 eax, DWORD PTR _filterDeviceObject$[ebp]
  0006e	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00071	89 4d fc	 mov	 DWORD PTR _Extension$[ebp], ecx

; 163  : 	memset (Extension, 0, sizeof (DriveFilterExtension));

  00074	68 50 02 00 00	 push	 592			; 00000250H
  00079	6a 00		 push	 0
  0007b	8b 55 fc	 mov	 edx, DWORD PTR _Extension$[ebp]
  0007e	52		 push	 edx
  0007f	e8 00 00 00 00	 call	 _memset
  00084	83 c4 0c	 add	 esp, 12			; 0000000cH

; 164  : 
; 165  : 	Extension->LowerDeviceObject = IoAttachDeviceToDeviceStack (filterDeviceObject, pdo);  // IoAttachDeviceToDeviceStackSafe() is not required in AddDevice routine and is also unavailable on Windows 2000 SP4

  00087	8b 45 0c	 mov	 eax, DWORD PTR _pdo$[ebp]
  0008a	50		 push	 eax
  0008b	8b 4d f0	 mov	 ecx, DWORD PTR _filterDeviceObject$[ebp]
  0008e	51		 push	 ecx
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAttachDeviceToDeviceStack@8
  00095	8b 55 fc	 mov	 edx, DWORD PTR _Extension$[ebp]
  00098	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 166  : 	if (!Extension->LowerDeviceObject)

  0009b	8b 45 fc	 mov	 eax, DWORD PTR _Extension$[ebp]
  0009e	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  000a2	75 0c		 jne	 SHORT $LN3@DriveFilte

; 167  : 	{
; 168  : 		status = STATUS_DEVICE_REMOVED;

  000a4	c7 45 f4 b6 02
	00 c0		 mov	 DWORD PTR _status$[ebp], -1073741130 ; c00002b6H

; 169  : 		goto err;

  000ab	e9 f3 00 00 00	 jmp	 $err$27916
$LN3@DriveFilte:

; 170  : 	}
; 171  : 
; 172  : 	Extension->IsDriveFilterDevice = Extension->Queue.IsFilterDevice = TRUE;

  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  000b3	c7 81 84 00 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+132], 1
  000bd	8b 55 fc	 mov	 edx, DWORD PTR _Extension$[ebp]
  000c0	c7 42 08 01 00
	00 00		 mov	 DWORD PTR [edx+8], 1

; 173  : 	Extension->DeviceObject = Extension->Queue.DeviceObject = filterDeviceObject;

  000c7	8b 45 fc	 mov	 eax, DWORD PTR _Extension$[ebp]
  000ca	8b 4d f0	 mov	 ecx, DWORD PTR _filterDeviceObject$[ebp]
  000cd	89 48 48	 mov	 DWORD PTR [eax+72], ecx
  000d0	8b 55 fc	 mov	 edx, DWORD PTR _Extension$[ebp]
  000d3	8b 45 f0	 mov	 eax, DWORD PTR _filterDeviceObject$[ebp]
  000d6	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 174  : 	Extension->Pdo = pdo;

  000d9	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  000dc	8b 55 0c	 mov	 edx, DWORD PTR _pdo$[ebp]
  000df	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 175  : 	
; 176  : 	Extension->Queue.LowerDeviceObject = Extension->LowerDeviceObject;

  000e2	8b 45 fc	 mov	 eax, DWORD PTR _Extension$[ebp]
  000e5	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  000e8	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  000eb	89 90 88 00 00
	00		 mov	 DWORD PTR [eax+136], edx

; 177  : 	IoInitializeRemoveLock (&Extension->Queue.RemoveLock, 'LRCT', 0, 0);

  000f1	6a 58		 push	 88			; 00000058H
  000f3	6a 00		 push	 0
  000f5	6a 00		 push	 0
  000f7	68 54 43 52 4c	 push	 1280459604		; 4c524354H
  000fc	8b 45 fc	 mov	 eax, DWORD PTR _Extension$[ebp]
  000ff	05 b8 00 00 00	 add	 eax, 184		; 000000b8H
  00104	50		 push	 eax
  00105	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoInitializeRemoveLockEx@20

; 178  : 
; 179  : 	Extension->ConfiguredEncryptedAreaStart = -1;

  0010b	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0010e	c7 41 30 ff ff
	ff ff		 mov	 DWORD PTR [ecx+48], -1
  00115	c7 41 34 ff ff
	ff ff		 mov	 DWORD PTR [ecx+52], -1

; 180  : 	Extension->ConfiguredEncryptedAreaEnd = -1;

  0011c	8b 55 fc	 mov	 edx, DWORD PTR _Extension$[ebp]
  0011f	c7 42 38 ff ff
	ff ff		 mov	 DWORD PTR [edx+56], -1
  00126	c7 42 3c ff ff
	ff ff		 mov	 DWORD PTR [edx+60], -1

; 181  : 	Extension->Queue.EncryptedAreaStart = -1;

  0012d	8b 45 fc	 mov	 eax, DWORD PTR _Extension$[ebp]
  00130	c7 80 90 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+144], -1
  0013a	c7 80 94 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+148], -1

; 182  : 	Extension->Queue.EncryptedAreaEnd = -1;

  00144	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00147	c7 81 98 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+152], -1
  00151	c7 81 9c 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+156], -1

; 183  : 	Extension->Queue.EncryptedAreaEndUpdatePending = FALSE;

  0015b	8b 55 fc	 mov	 edx, DWORD PTR _Extension$[ebp]
  0015e	c7 82 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+160], 0

; 184  : 
; 185  : 	filterDeviceObject->Flags |= Extension->LowerDeviceObject->Flags & (DO_DIRECT_IO | DO_BUFFERED_IO | DO_POWER_PAGABLE);

  00168	8b 45 fc	 mov	 eax, DWORD PTR _Extension$[ebp]
  0016b	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0016e	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00171	81 e2 14 20 00
	00		 and	 edx, 8212		; 00002014H
  00177	8b 45 f0	 mov	 eax, DWORD PTR _filterDeviceObject$[ebp]
  0017a	0b 50 1c	 or	 edx, DWORD PTR [eax+28]
  0017d	8b 4d f0	 mov	 ecx, DWORD PTR _filterDeviceObject$[ebp]
  00180	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 186  : 	filterDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

  00183	8b 55 f0	 mov	 edx, DWORD PTR _filterDeviceObject$[ebp]
  00186	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00189	25 7f ff ff ff	 and	 eax, -129		; ffffff7fH
  0018e	8b 4d f0	 mov	 ecx, DWORD PTR _filterDeviceObject$[ebp]
  00191	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 187  : 
; 188  : 	DeviceFilterActive = TRUE;

  00194	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _DeviceFilterActive, 1

; 189  : 	return status;

  0019e	8b 45 f4	 mov	 eax, DWORD PTR _status$[ebp]
  001a1	eb 29		 jmp	 SHORT $LN5@DriveFilte
$err$27916:

; 190  : 
; 191  : err:
; 192  : 	if (filterDeviceObject)

  001a3	83 7d f0 00	 cmp	 DWORD PTR _filterDeviceObject$[ebp], 0
  001a7	74 20		 je	 SHORT $LN2@DriveFilte

; 193  : 	{
; 194  : 		if (Extension->LowerDeviceObject)

  001a9	8b 55 fc	 mov	 edx, DWORD PTR _Extension$[ebp]
  001ac	83 7a 1c 00	 cmp	 DWORD PTR [edx+28], 0
  001b0	74 0d		 je	 SHORT $LN1@DriveFilte

; 195  : 			IoDetachDevice (Extension->LowerDeviceObject);

  001b2	8b 45 fc	 mov	 eax, DWORD PTR _Extension$[ebp]
  001b5	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  001b8	51		 push	 ecx
  001b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDetachDevice@4
$LN1@DriveFilte:

; 196  : 
; 197  : 		IoDeleteDevice (filterDeviceObject);

  001bf	8b 55 f0	 mov	 edx, DWORD PTR _filterDeviceObject$[ebp]
  001c2	52		 push	 edx
  001c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteDevice@4
$LN2@DriveFilte:

; 198  : 	}
; 199  : 
; 200  : 	return status;

  001c9	8b 45 f4	 mov	 eax, DWORD PTR _status$[ebp]
$LN5@DriveFilte:

; 201  : }

  001cc	8b e5		 mov	 esp, ebp
  001ce	5d		 pop	 ebp
  001cf	c2 08 00	 ret	 8
_DriveFilterAddDevice@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DK@ECCPCMLD@?$CBExtension?9?$DObRootDevice?5?$CG?$CG?5Exten@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EF@GDHJGIB@c?3?2users?2public?2desktop?2projects@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_IoGetCurrentIrpStackLocation@4
PUBLIC	_DriveFilterDispatchIrp@8
EXTRN	__imp__IoReleaseRemoveLockEx@12:PROC
EXTRN	_TCCompleteIrp@12:PROC
EXTRN	__imp__IoAcquireRemoveLockEx@20:PROC
EXTRN	_TCCompleteDiskIrp@12:PROC
EXTRN	_EncryptedIoQueueAddIrp@8:PROC
EXTRN	__imp__RtlAssert@16:PROC
;	COMDAT ??_C@_0DK@ECCPCMLD@?$CBExtension?9?$DObRootDevice?5?$CG?$CG?5Exten@FNODOBFM@
text$s	SEGMENT
??_C@_0DK@ECCPCMLD@?$CBExtension?9?$DObRootDevice?5?$CG?$CG?5Exten@FNODOBFM@ DB '!'
	DB	'Extension->bRootDevice && Extension->IsDriveFilterDevice', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EF@GDHJGIB@c?3?2users?2public?2desktop?2projects@FNODOBFM@
text$s	SEGMENT
??_C@_0EF@GDHJGIB@c?3?2users?2public?2desktop?2projects@FNODOBFM@ DB 'c:\'
	DB	'users\public\desktop\projects\ciphershed\src\driver\drivefilt'
	DB	'er.c', 00H					;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _DriveFilterDispatchIrp@8
_TEXT	SEGMENT
tv76 = -20						; size = 4
tv74 = -16						; size = 4
_irpSp$ = -12						; size = 4
_status$ = -8						; size = 4
_Extension$ = -4					; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_DriveFilterDispatchIrp@8 PROC				; COMDAT

; 708  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 14	 sub	 esp, 20			; 00000014H

; 709  : 	DriveFilterExtension *Extension = (DriveFilterExtension *) DeviceObject->DeviceExtension;

  00008	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  0000b	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0000e	89 4d fc	 mov	 DWORD PTR _Extension$[ebp], ecx

; 710  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);

  00011	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _IoGetCurrentIrpStackLocation@4
  0001a	89 45 f4	 mov	 DWORD PTR _irpSp$[ebp], eax

; 711  : 	NTSTATUS status;
; 712  : 
; 713  : 	ASSERT (!Extension->bRootDevice && Extension->IsDriveFilterDevice);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _Extension$[ebp]
  00020	83 38 00	 cmp	 DWORD PTR [eax], 0
  00023	75 12		 jne	 SHORT $LN11@DriveFilte@2
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00028	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  0002c	74 09		 je	 SHORT $LN11@DriveFilte@2
  0002e	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
  00035	eb 1e		 jmp	 SHORT $LN12@DriveFilte@2
$LN11@DriveFilte@2:
  00037	6a 00		 push	 0
  00039	68 c9 02 00 00	 push	 713			; 000002c9H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@GDHJGIB@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@ECCPCMLD@?$CBExtension?9?$DObRootDevice?5?$CG?$CG?5Exten@FNODOBFM@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  0004e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN12@DriveFilte@2:

; 714  : 
; 715  : 	switch (irpSp->MajorFunction)

  00055	8b 55 f4	 mov	 edx, DWORD PTR _irpSp$[ebp]
  00058	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0005b	89 45 ec	 mov	 DWORD PTR tv76[ebp], eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR tv76[ebp]
  00061	83 e9 03	 sub	 ecx, 3
  00064	89 4d ec	 mov	 DWORD PTR tv76[ebp], ecx
  00067	83 7d ec 18	 cmp	 DWORD PTR tv76[ebp], 24	; 00000018H
  0006b	0f 87 80 00 00
	00		 ja	 $LN7@DriveFilte@2
  00071	8b 55 ec	 mov	 edx, DWORD PTR tv76[ebp]
  00074	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN13@DriveFilte@2[edx]
  0007b	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN14@DriveFilte@2[eax*4]
$LN6@DriveFilte@2:

; 716  : 	{
; 717  : 	case IRP_MJ_READ:
; 718  : 	case IRP_MJ_WRITE:
; 719  : 		if (Extension->BootDrive)

  00082	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00085	83 b9 28 02 00
	00 00		 cmp	 DWORD PTR [ecx+552], 0
  0008c	74 33		 je	 SHORT $LN5@DriveFilte@2

; 720  : 		{
; 721  : 			status = EncryptedIoQueueAddIrp (&Extension->Queue, Irp);

  0008e	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  00091	52		 push	 edx
  00092	8b 45 fc	 mov	 eax, DWORD PTR _Extension$[ebp]
  00095	83 c0 48	 add	 eax, 72			; 00000048H
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 _EncryptedIoQueueAddIrp@8
  0009e	89 45 f8	 mov	 DWORD PTR _status$[ebp], eax

; 722  : 			
; 723  : 			if (status != STATUS_PENDING)

  000a1	81 7d f8 03 01
	00 00		 cmp	 DWORD PTR _status$[ebp], 259 ; 00000103H
  000a8	74 0f		 je	 SHORT $LN4@DriveFilte@2

; 724  : 				TCCompleteDiskIrp (Irp, status, 0);

  000aa	6a 00		 push	 0
  000ac	8b 4d f8	 mov	 ecx, DWORD PTR _status$[ebp]
  000af	51		 push	 ecx
  000b0	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  000b3	52		 push	 edx
  000b4	e8 00 00 00 00	 call	 _TCCompleteDiskIrp@12
$LN4@DriveFilte@2:

; 725  : 
; 726  : 			return status;

  000b9	8b 45 f8	 mov	 eax, DWORD PTR _status$[ebp]
  000bc	e9 95 00 00 00	 jmp	 $LN9@DriveFilte@2
$LN5@DriveFilte@2:

; 727  : 		}
; 728  : 		break;

  000c1	eb 2e		 jmp	 SHORT $LN7@DriveFilte@2
$LN3@DriveFilte@2:

; 729  : 
; 730  : 	case IRP_MJ_PNP:
; 731  : 		return DispatchPnp (DeviceObject, Irp, Extension, irpSp);

  000c3	8b 45 f4	 mov	 eax, DWORD PTR _irpSp$[ebp]
  000c6	50		 push	 eax
  000c7	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  000ca	51		 push	 ecx
  000cb	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  000ce	52		 push	 edx
  000cf	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 _DispatchPnp@16
  000d8	eb 7c		 jmp	 SHORT $LN9@DriveFilte@2
$LN2@DriveFilte@2:

; 732  : 
; 733  : 	case IRP_MJ_POWER:
; 734  : 		return DispatchPower (DeviceObject, Irp, Extension, irpSp);

  000da	8b 4d f4	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  000dd	51		 push	 ecx
  000de	8b 55 fc	 mov	 edx, DWORD PTR _Extension$[ebp]
  000e1	52		 push	 edx
  000e2	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  000e5	50		 push	 eax
  000e6	8b 4d 08	 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  000e9	51		 push	 ecx
  000ea	e8 00 00 00 00	 call	 _DispatchPower@16
  000ef	eb 65		 jmp	 SHORT $LN9@DriveFilte@2
$LN7@DriveFilte@2:

; 735  : 	}
; 736  : 
; 737  : 	status = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  000f1	6a 58		 push	 88			; 00000058H
  000f3	68 e1 02 00 00	 push	 737			; 000002e1H
  000f8	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@GDHJGIB@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  000fd	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  00100	52		 push	 edx
  00101	8b 45 fc	 mov	 eax, DWORD PTR _Extension$[ebp]
  00104	05 b8 00 00 00	 add	 eax, 184		; 000000b8H
  00109	50		 push	 eax
  0010a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAcquireRemoveLockEx@20
  00110	89 45 f8	 mov	 DWORD PTR _status$[ebp], eax

; 738  : 	if (!NT_SUCCESS (status))

  00113	83 7d f8 00	 cmp	 DWORD PTR _status$[ebp], 0
  00117	7d 11		 jge	 SHORT $LN1@DriveFilte@2

; 739  : 		return TCCompleteIrp (Irp, status, 0);

  00119	6a 00		 push	 0
  0011b	8b 4d f8	 mov	 ecx, DWORD PTR _status$[ebp]
  0011e	51		 push	 ecx
  0011f	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  00122	52		 push	 edx
  00123	e8 00 00 00 00	 call	 _TCCompleteIrp@12
  00128	eb 2c		 jmp	 SHORT $LN9@DriveFilte@2
$LN1@DriveFilte@2:

; 740  : 
; 741  : 	status = PassIrp (Extension->LowerDeviceObject, Irp);

  0012a	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  0012d	50		 push	 eax
  0012e	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00131	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00134	52		 push	 edx
  00135	e8 00 00 00 00	 call	 _PassIrp@8
  0013a	89 45 f8	 mov	 DWORD PTR _status$[ebp], eax

; 742  : 
; 743  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  0013d	6a 58		 push	 88			; 00000058H
  0013f	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00142	50		 push	 eax
  00143	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00146	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  0014c	51		 push	 ecx
  0014d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 744  : 	return status;

  00153	8b 45 f8	 mov	 eax, DWORD PTR _status$[ebp]
$LN9@DriveFilte@2:

; 745  : }

  00156	8b e5		 mov	 esp, ebp
  00158	5d		 pop	 ebp
  00159	c2 08 00	 ret	 8
$LN14@DriveFilte@2:
  0015c	00 00 00 00	 DD	 $LN6@DriveFilte@2
  00160	00 00 00 00	 DD	 $LN2@DriveFilte@2
  00164	00 00 00 00	 DD	 $LN3@DriveFilte@2
  00168	00 00 00 00	 DD	 $LN7@DriveFilte@2
$LN13@DriveFilte@2:
  0016c	00		 DB	 0
  0016d	00		 DB	 0
  0016e	03		 DB	 3
  0016f	03		 DB	 3
  00170	03		 DB	 3
  00171	03		 DB	 3
  00172	03		 DB	 3
  00173	03		 DB	 3
  00174	03		 DB	 3
  00175	03		 DB	 3
  00176	03		 DB	 3
  00177	03		 DB	 3
  00178	03		 DB	 3
  00179	03		 DB	 3
  0017a	03		 DB	 3
  0017b	03		 DB	 3
  0017c	03		 DB	 3
  0017d	03		 DB	 3
  0017e	03		 DB	 3
  0017f	01		 DB	 1
  00180	03		 DB	 3
  00181	03		 DB	 3
  00182	03		 DB	 3
  00183	03		 DB	 3
  00184	02		 DB	 2
_DriveFilterDispatchIrp@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
text$s	SEGMENT
??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ DB 'I'
	DB	'rp->CurrentLocation <= Irp->StackCount + 1', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@
text$s	SEGMENT
??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@ DB 'c'
	DB	':\winddk\7600.16385.1\inc\ddk\wdm.h', 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _IoGetCurrentIrpStackLocation@4
_TEXT	SEGMENT
tv74 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoGetCurrentIrpStackLocation@4 PROC			; COMDAT

; 23316: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 23317:     ASSERT(Irp->CurrentLocation <= Irp->StackCount + 1);

  00006	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00009	0f be 48 23	 movsx	 ecx, BYTE PTR [eax+35]
  0000d	8b 55 08	 mov	 edx, DWORD PTR _Irp$[ebp]
  00010	0f be 42 22	 movsx	 eax, BYTE PTR [edx+34]
  00014	83 c0 01	 add	 eax, 1
  00017	3b c8		 cmp	 ecx, eax
  00019	7e 20		 jle	 SHORT $LN3@IoGetCurre
  0001b	6a 00		 push	 0
  0001d	68 15 5b 00 00	 push	 23317			; 00005b15H
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
  00039	eb 07		 jmp	 SHORT $LN4@IoGetCurre
$LN3@IoGetCurre:
  0003b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
$LN4@IoGetCurre:

; 23318:     return Irp->Tail.Overlay.CurrentStackLocation;

  00042	8b 4d 08	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00045	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]

; 23319: }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
_IoGetCurrentIrpStackLocation@4 ENDP
_TEXT	ENDS
PUBLIC	_IoSkipCurrentIrpStackLocation@4
EXTRN	__imp_@IofCallDriver@8:PROC
; Function compile flags: /Odtp
; File c:\users\public\desktop\projects\ciphershed\src\driver\drivefilter.c
;	COMDAT _PassIrp@8
_TEXT	SEGMENT
_deviceObject$ = 8					; size = 4
_irp$ = 12						; size = 4
_PassIrp@8 PROC						; COMDAT

; 479  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 480  : 	IoSkipCurrentIrpStackLocation (irp);

  00005	8b 45 0c	 mov	 eax, DWORD PTR _irp$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IoSkipCurrentIrpStackLocation@4

; 481  : 	return IoCallDriver (deviceObject, irp);

  0000e	8b 55 0c	 mov	 edx, DWORD PTR _irp$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _deviceObject$[ebp]
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8

; 482  : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
_PassIrp@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CI@HDMHMCGD@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0CI@HDMHMCGD@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
text$s	SEGMENT
??_C@_0CI@HDMHMCGD@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ DB 'I'
	DB	'rp->CurrentLocation <= Irp->StackCount', 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _IoSkipCurrentIrpStackLocation@4
_TEXT	SEGMENT
tv73 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoSkipCurrentIrpStackLocation@4 PROC			; COMDAT

; 23945: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 23946:     ASSERT(Irp->CurrentLocation <= Irp->StackCount);

  00006	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00009	0f be 48 23	 movsx	 ecx, BYTE PTR [eax+35]
  0000d	8b 55 08	 mov	 edx, DWORD PTR _Irp$[ebp]
  00010	0f be 42 22	 movsx	 eax, BYTE PTR [edx+34]
  00014	3b c8		 cmp	 ecx, eax
  00016	7e 20		 jle	 SHORT $LN3@IoSkipCurr
  00018	6a 00		 push	 0
  0001a	68 8a 5d 00 00	 push	 23946			; 00005d8aH
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@HDMHMCGD@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00036	eb 07		 jmp	 SHORT $LN4@IoSkipCurr
$LN3@IoSkipCurr:
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv73[ebp], 1
$LN4@IoSkipCurr:

; 23947:     Irp->CurrentLocation++;

  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00042	8a 51 23	 mov	 dl, BYTE PTR [ecx+35]
  00045	80 c2 01	 add	 dl, 1
  00048	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  0004b	88 50 23	 mov	 BYTE PTR [eax+35], dl

; 23948:     Irp->Tail.Overlay.CurrentStackLocation++;

  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00051	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00054	83 c2 24	 add	 edx, 36			; 00000024H
  00057	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  0005a	89 50 60	 mov	 DWORD PTR [eax+96], edx

; 23949: }

  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
_IoSkipCurrentIrpStackLocation@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@GINPCIAN@IRP_MN_REMOVE_DEVICE?5pdo?$DN?$CFp?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BJ@ECOGMEFG@Preventing?5dump?5type?$DN?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CK@HDNODHHC@IRP_MN_DEVICE_USAGE_NOTIFICATION@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BM@EOGIDBIC@IRP_MN_START_DEVICE?5pdo?$DN?$CFp?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp__IoReleaseRemoveLockAndWaitEx@12:PROC
;	COMDAT ??_C@_0BN@GINPCIAN@IRP_MN_REMOVE_DEVICE?5pdo?$DN?$CFp?6?$AA@FNODOBFM@
; File c:\users\public\desktop\projects\ciphershed\src\driver\drivefilter.c
text$s	SEGMENT
??_C@_0BN@GINPCIAN@IRP_MN_REMOVE_DEVICE?5pdo?$DN?$CFp?6?$AA@FNODOBFM@ DB 'I'
	DB	'RP_MN_REMOVE_DEVICE pdo=%p', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BJ@ECOGMEFG@Preventing?5dump?5type?$DN?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BJ@ECOGMEFG@Preventing?5dump?5type?$DN?$CFd?6?$AA@FNODOBFM@ DB 'Pr'
	DB	'eventing dump type=%d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CK@HDNODHHC@IRP_MN_DEVICE_USAGE_NOTIFICATION@FNODOBFM@
text$s	SEGMENT
??_C@_0CK@HDNODHHC@IRP_MN_DEVICE_USAGE_NOTIFICATION@FNODOBFM@ DB 'IRP_MN_'
	DB	'DEVICE_USAGE_NOTIFICATION type=%d', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BM@EOGIDBIC@IRP_MN_START_DEVICE?5pdo?$DN?$CFp?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BM@EOGIDBIC@IRP_MN_START_DEVICE?5pdo?$DN?$CFp?6?$AA@FNODOBFM@ DB 'I'
	DB	'RP_MN_START_DEVICE pdo=%p', 0aH, 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _DispatchPnp@16
_TEXT	SEGMENT
tv78 = -12						; size = 4
_attachedDevice$28182 = -8				; size = 4
_status$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_Extension$ = 16					; size = 4
_irpSp$ = 20						; size = 4
_DispatchPnp@16 PROC					; COMDAT

; 595  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 596  : 	NTSTATUS status;
; 597  : 
; 598  : 	status = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00008	6a 58		 push	 88			; 00000058H
  0000a	68 56 02 00 00	 push	 598			; 00000256H
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@GDHJGIB@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  00014	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00017	50		 push	 eax
  00018	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0001b	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  00021	51		 push	 ecx
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAcquireRemoveLockEx@20
  00028	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 599  : 	if (!NT_SUCCESS (status))

  0002b	83 7d fc 00	 cmp	 DWORD PTR _status$[ebp], 0
  0002f	7d 14		 jge	 SHORT $LN15@DispatchPn

; 600  : 		return TCCompleteIrp (Irp, status, 0);

  00031	6a 00		 push	 0
  00033	8b 55 fc	 mov	 edx, DWORD PTR _status$[ebp]
  00036	52		 push	 edx
  00037	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 _TCCompleteIrp@12
  00040	e9 07 02 00 00	 jmp	 $LN16@DispatchPn
$LN15@DispatchPn:

; 601  : 
; 602  : 	switch (irpSp->MinorFunction)

  00045	8b 4d 14	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  00048	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  0004b	88 55 f4	 mov	 BYTE PTR tv78[ebp], dl
  0004e	80 7d f4 00	 cmp	 BYTE PTR tv78[ebp], 0
  00052	74 15		 je	 SHORT $LN12@DispatchPn
  00054	80 7d f4 02	 cmp	 BYTE PTR tv78[ebp], 2
  00058	0f 84 33 01 00
	00		 je	 $LN4@DispatchPn
  0005e	80 7d f4 16	 cmp	 BYTE PTR tv78[ebp], 22	; 00000016H
  00062	74 37		 je	 SHORT $LN11@DispatchPn
  00064	e9 b7 01 00 00	 jmp	 $LN1@DispatchPn
$LN12@DispatchPn:

; 603  : 	{
; 604  : 	case IRP_MN_START_DEVICE:
; 605  : 		Dump ("IRP_MN_START_DEVICE pdo=%p\n", Extension->Pdo);

  00069	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  0006c	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0006f	51		 push	 ecx
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@EOGIDBIC@IRP_MN_START_DEVICE?5pdo?$DN?$CFp?6?$AA@FNODOBFM@
  00075	e8 00 00 00 00	 call	 _DbgPrint
  0007a	83 c4 08	 add	 esp, 8

; 606  : 		return PassFilteredIrp (Extension->LowerDeviceObject, Irp, OnStartDeviceCompleted, Extension);

  0007d	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  00080	52		 push	 edx
  00081	68 00 00 00 00	 push	 OFFSET _OnStartDeviceCompleted@12
  00086	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00089	50		 push	 eax
  0008a	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0008d	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00090	52		 push	 edx
  00091	e8 00 00 00 00	 call	 _PassFilteredIrp@16
  00096	e9 b1 01 00 00	 jmp	 $LN16@DispatchPn
$LN11@DispatchPn:

; 607  : 
; 608  : 
; 609  : 	case IRP_MN_DEVICE_USAGE_NOTIFICATION:
; 610  : 		Dump ("IRP_MN_DEVICE_USAGE_NOTIFICATION type=%d\n", (int) irpSp->Parameters.UsageNotification.Type);

  0009b	8b 45 14	 mov	 eax, DWORD PTR _irpSp$[ebp]
  0009e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a1	51		 push	 ecx
  000a2	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@HDNODHHC@IRP_MN_DEVICE_USAGE_NOTIFICATION@FNODOBFM@
  000a7	e8 00 00 00 00	 call	 _DbgPrint
  000ac	83 c4 08	 add	 esp, 8

; 611  : 
; 612  : 		{
; 613  : 			PDEVICE_OBJECT attachedDevice = IoGetAttachedDeviceReference (DeviceObject);

  000af	8b 55 08	 mov	 edx, DWORD PTR _DeviceObject$[ebp]
  000b2	52		 push	 edx
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoGetAttachedDeviceReference@4
  000b9	89 45 f8	 mov	 DWORD PTR _attachedDevice$28182[ebp], eax

; 614  : 
; 615  : 			if (attachedDevice == DeviceObject || (attachedDevice->Flags & DO_POWER_PAGABLE))

  000bc	8b 45 f8	 mov	 eax, DWORD PTR _attachedDevice$28182[ebp]
  000bf	3b 45 08	 cmp	 eax, DWORD PTR _DeviceObject$[ebp]
  000c2	74 0e		 je	 SHORT $LN9@DispatchPn
  000c4	8b 4d f8	 mov	 ecx, DWORD PTR _attachedDevice$28182[ebp]
  000c7	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  000ca	81 e2 00 20 00
	00		 and	 edx, 8192		; 00002000H
  000d0	74 12		 je	 SHORT $LN10@DispatchPn
$LN9@DispatchPn:

; 616  : 				DeviceObject->Flags |= DO_POWER_PAGABLE;

  000d2	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  000d5	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000d8	81 c9 00 20 00
	00		 or	 ecx, 8192		; 00002000H
  000de	8b 55 08	 mov	 edx, DWORD PTR _DeviceObject$[ebp]
  000e1	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx
$LN10@DispatchPn:

; 617  : 
; 618  : 			ObDereferenceObject (attachedDevice);

  000e4	8b 4d f8	 mov	 ecx, DWORD PTR _attachedDevice$28182[ebp]
  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 619  : 		}
; 620  : 
; 621  : 		// Prevent creation of hibernation and crash dump files if required
; 622  : 		if (irpSp->Parameters.UsageNotification.InPath
; 623  : 			&& (
; 624  : 				(irpSp->Parameters.UsageNotification.Type == DeviceUsageTypeDumpFile && !CrashDumpEnabled)
; 625  : 				|| (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypeHibernation && !HibernationEnabled)
; 626  : 				)
; 627  : 			)

  000ed	8b 45 14	 mov	 eax, DWORD PTR _irpSp$[ebp]
  000f0	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  000f4	85 c9		 test	 ecx, ecx
  000f6	74 7b		 je	 SHORT $LN8@DispatchPn
  000f8	8b 55 14	 mov	 edx, DWORD PTR _irpSp$[ebp]
  000fb	83 7a 08 03	 cmp	 DWORD PTR [edx+8], 3
  000ff	75 09		 jne	 SHORT $LN6@DispatchPn
  00101	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _CrashDumpEnabled, 0
  00108	74 12		 je	 SHORT $LN7@DispatchPn
$LN6@DispatchPn:
  0010a	8b 45 14	 mov	 eax, DWORD PTR _irpSp$[ebp]
  0010d	83 78 08 02	 cmp	 DWORD PTR [eax+8], 2
  00111	75 60		 jne	 SHORT $LN8@DispatchPn
  00113	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _HibernationEnabled, 0
  0011a	75 57		 jne	 SHORT $LN8@DispatchPn
$LN7@DispatchPn:

; 628  : 		{
; 629  : 			IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  0011c	6a 58		 push	 88			; 00000058H
  0011e	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00121	51		 push	 ecx
  00122	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  00125	81 c2 b8 00 00
	00		 add	 edx, 184		; 000000b8H
  0012b	52		 push	 edx
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 630  : 
; 631  : 			if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypeHibernation)

  00132	8b 45 14	 mov	 eax, DWORD PTR _irpSp$[ebp]
  00135	83 78 08 02	 cmp	 DWORD PTR [eax+8], 2
  00139	75 0f		 jne	 SHORT $LN5@DispatchPn

; 632  : 				++HibernationPreventionCount;

  0013b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _HibernationPreventionCount
  00141	83 c1 01	 add	 ecx, 1
  00144	89 0d 00 00 00
	00		 mov	 DWORD PTR _HibernationPreventionCount, ecx
$LN5@DispatchPn:

; 633  : 
; 634  : 			Dump ("Preventing dump type=%d\n", (int) irpSp->Parameters.UsageNotification.Type);

  0014a	8b 55 14	 mov	 edx, DWORD PTR _irpSp$[ebp]
  0014d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00150	50		 push	 eax
  00151	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@ECOGMEFG@Preventing?5dump?5type?$DN?$CFd?6?$AA@FNODOBFM@
  00156	e8 00 00 00 00	 call	 _DbgPrint
  0015b	83 c4 08	 add	 esp, 8

; 635  : 			return TCCompleteIrp (Irp, STATUS_UNSUCCESSFUL, 0);

  0015e	6a 00		 push	 0
  00160	68 01 00 00 c0	 push	 -1073741823		; c0000001H
  00165	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00168	51		 push	 ecx
  00169	e8 00 00 00 00	 call	 _TCCompleteIrp@12
  0016e	e9 d9 00 00 00	 jmp	 $LN16@DispatchPn
$LN8@DispatchPn:

; 636  : 		}
; 637  : 
; 638  : 		return PassFilteredIrp (Extension->LowerDeviceObject, Irp, OnDeviceUsageNotificationCompleted, Extension);

  00173	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  00176	52		 push	 edx
  00177	68 00 00 00 00	 push	 OFFSET _OnDeviceUsageNotificationCompleted@12
  0017c	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  0017f	50		 push	 eax
  00180	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00183	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00186	52		 push	 edx
  00187	e8 00 00 00 00	 call	 _PassFilteredIrp@16
  0018c	e9 bb 00 00 00	 jmp	 $LN16@DispatchPn
$LN4@DispatchPn:

; 639  : 
; 640  : 
; 641  : 	case IRP_MN_REMOVE_DEVICE:
; 642  : 		Dump ("IRP_MN_REMOVE_DEVICE pdo=%p\n", Extension->Pdo);

  00191	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  00194	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00197	51		 push	 ecx
  00198	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@GINPCIAN@IRP_MN_REMOVE_DEVICE?5pdo?$DN?$CFp?6?$AA@FNODOBFM@
  0019d	e8 00 00 00 00	 call	 _DbgPrint
  001a2	83 c4 08	 add	 esp, 8

; 643  : 
; 644  : 		IoReleaseRemoveLockAndWait (&Extension->Queue.RemoveLock, Irp);

  001a5	6a 58		 push	 88			; 00000058H
  001a7	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  001aa	52		 push	 edx
  001ab	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  001ae	05 b8 00 00 00	 add	 eax, 184		; 000000b8H
  001b3	50		 push	 eax
  001b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockAndWaitEx@12

; 645  : 		status = PassIrp (Extension->LowerDeviceObject, Irp);

  001ba	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  001bd	51		 push	 ecx
  001be	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  001c1	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  001c4	50		 push	 eax
  001c5	e8 00 00 00 00	 call	 _PassIrp@8
  001ca	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 646  : 
; 647  : 		IoDetachDevice (Extension->LowerDeviceObject);

  001cd	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  001d0	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  001d3	52		 push	 edx
  001d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDetachDevice@4

; 648  : 
; 649  : 		if (Extension->DriveMounted)

  001da	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  001dd	83 b8 30 02 00
	00 00		 cmp	 DWORD PTR [eax+560], 0
  001e4	74 0b		 je	 SHORT $LN3@DispatchPn

; 650  : 			DismountDrive (Extension, TRUE);

  001e6	6a 01		 push	 1
  001e8	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  001eb	51		 push	 ecx
  001ec	e8 00 00 00 00	 call	 _DismountDrive@8
$LN3@DispatchPn:

; 651  : 
; 652  : 		if (Extension->BootDrive)

  001f1	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  001f4	83 ba 28 02 00
	00 00		 cmp	 DWORD PTR [edx+552], 0
  001fb	74 14		 je	 SHORT $LN2@DispatchPn

; 653  : 		{
; 654  : 			BootDriveFound = FALSE;

  001fd	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _BootDriveFound, 0

; 655  : 			BootDriveFilterExtension = NULL;

  00207	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _BootDriveFilterExtension, 0
$LN2@DispatchPn:

; 656  : 		}
; 657  : 
; 658  : 		IoDeleteDevice (DeviceObject);

  00211	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00214	50		 push	 eax
  00215	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteDevice@4

; 659  : 		return status;

  0021b	8b 45 fc	 mov	 eax, DWORD PTR _status$[ebp]
  0021e	eb 2c		 jmp	 SHORT $LN16@DispatchPn
$LN1@DispatchPn:

; 660  : 
; 661  : 
; 662  : 	default:
; 663  : 		status = PassIrp (Extension->LowerDeviceObject, Irp);

  00220	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00223	51		 push	 ecx
  00224	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  00227	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0022a	50		 push	 eax
  0022b	e8 00 00 00 00	 call	 _PassIrp@8
  00230	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 664  : 		IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00233	6a 58		 push	 88			; 00000058H
  00235	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00238	51		 push	 ecx
  00239	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  0023c	81 c2 b8 00 00
	00		 add	 edx, 184		; 000000b8H
  00242	52		 push	 edx
  00243	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 665  : 	}
; 666  : 	return status;

  00249	8b 45 fc	 mov	 eax, DWORD PTR _status$[ebp]
$LN16@DispatchPn:

; 667  : }

  0024c	8b e5		 mov	 esp, ebp
  0024e	5d		 pop	 ebp
  0024f	c2 10 00	 ret	 16			; 00000010H
_DispatchPnp@16 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@ONACDOIC@Extension?9?$DODriveMounted?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BD@EAAMLHLJ@Dismounting?5drive?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	_crypto_close@4:PROC
EXTRN	_EncryptedIoQueueStop@4:PROC
EXTRN	_EncryptedIoQueueIsRunning@4:PROC
;	COMDAT ??_C@_0BI@ONACDOIC@Extension?9?$DODriveMounted?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BI@ONACDOIC@Extension?9?$DODriveMounted?$AA@FNODOBFM@ DB 'Extensio'
	DB	'n->DriveMounted', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BD@EAAMLHLJ@Dismounting?5drive?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BD@EAAMLHLJ@Dismounting?5drive?6?$AA@FNODOBFM@ DB 'Dismounting dri'
	DB	've', 0aH, 00H				;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _DismountDrive@8
_TEXT	SEGMENT
tv71 = -4						; size = 4
_Extension$ = 8						; size = 4
_stopIoQueue$ = 12					; size = 4
_DismountDrive@8 PROC					; COMDAT

; 205  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 206  : 	Dump ("Dismounting drive\n");

  00006	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@EAAMLHLJ@Dismounting?5drive?6?$AA@FNODOBFM@
  0000b	e8 00 00 00 00	 call	 _DbgPrint
  00010	83 c4 04	 add	 esp, 4

; 207  : 	ASSERT (Extension->DriveMounted);

  00013	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  00016	83 b8 30 02 00
	00 00		 cmp	 DWORD PTR [eax+560], 0
  0001d	75 20		 jne	 SHORT $LN4@DismountDr
  0001f	6a 00		 push	 0
  00021	68 cf 00 00 00	 push	 207			; 000000cfH
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@GDHJGIB@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@ONACDOIC@Extension?9?$DODriveMounted?$AA@FNODOBFM@
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
  0003d	eb 07		 jmp	 SHORT $LN5@DismountDr
$LN4@DismountDr:
  0003f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
$LN5@DismountDr:

; 208  : 	
; 209  : 	if (stopIoQueue && EncryptedIoQueueIsRunning (&Extension->Queue))

  00046	83 7d 0c 00	 cmp	 DWORD PTR _stopIoQueue$[ebp], 0
  0004a	74 1c		 je	 SHORT $LN1@DismountDr
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0004f	83 c1 48	 add	 ecx, 72			; 00000048H
  00052	51		 push	 ecx
  00053	e8 00 00 00 00	 call	 _EncryptedIoQueueIsRunning@4
  00058	85 c0		 test	 eax, eax
  0005a	74 0c		 je	 SHORT $LN1@DismountDr

; 210  : 		EncryptedIoQueueStop (&Extension->Queue);

  0005c	8b 55 08	 mov	 edx, DWORD PTR _Extension$[ebp]
  0005f	83 c2 48	 add	 edx, 72			; 00000048H
  00062	52		 push	 edx
  00063	e8 00 00 00 00	 call	 _EncryptedIoQueueStop@4
$LN1@DismountDr:

; 211  : 
; 212  : 	crypto_close (Extension->Queue.CryptoInfo);

  00068	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  0006b	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 _crypto_close@4

; 213  : 	Extension->Queue.CryptoInfo = NULL;

  00074	8b 55 08	 mov	 edx, DWORD PTR _Extension$[ebp]
  00077	c7 42 70 00 00
	00 00		 mov	 DWORD PTR [edx+112], 0

; 214  : 
; 215  : 	crypto_close (Extension->HeaderCryptoInfo);

  0007e	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  00081	8b 88 44 02 00
	00		 mov	 ecx, DWORD PTR [eax+580]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 _crypto_close@4

; 216  : 	Extension->HeaderCryptoInfo = NULL;

  0008d	8b 55 08	 mov	 edx, DWORD PTR _Extension$[ebp]
  00090	c7 82 44 02 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+580], 0

; 217  : 
; 218  : 	Extension->DriveMounted = FALSE;

  0009a	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  0009d	c7 80 30 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+560], 0

; 219  : }

  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c2 08 00	 ret	 8
_DismountDrive@8 ENDP
_TEXT	ENDS
PUBLIC	_IoSetCompletionRoutine@24
PUBLIC	_IoCopyCurrentIrpStackLocationToNext@4
; Function compile flags: /Odtp
;	COMDAT _PassFilteredIrp@16
_TEXT	SEGMENT
_deviceObject$ = 8					; size = 4
_irp$ = 12						; size = 4
_completionRoutine$ = 16				; size = 4
_completionRoutineArg$ = 20				; size = 4
_PassFilteredIrp@16 PROC				; COMDAT

; 486  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 487  : 	IoCopyCurrentIrpStackLocationToNext (irp);

  00005	8b 45 0c	 mov	 eax, DWORD PTR _irp$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IoCopyCurrentIrpStackLocationToNext@4

; 488  : 
; 489  : 	if (completionRoutine)

  0000e	83 7d 10 00	 cmp	 DWORD PTR _completionRoutine$[ebp], 0
  00012	74 17		 je	 SHORT $LN1@PassFilter

; 490  : 		IoSetCompletionRoutine (irp, completionRoutine, completionRoutineArg, TRUE, TRUE, TRUE);

  00014	6a 01		 push	 1
  00016	6a 01		 push	 1
  00018	6a 01		 push	 1
  0001a	8b 4d 14	 mov	 ecx, DWORD PTR _completionRoutineArg$[ebp]
  0001d	51		 push	 ecx
  0001e	8b 55 10	 mov	 edx, DWORD PTR _completionRoutine$[ebp]
  00021	52		 push	 edx
  00022	8b 45 0c	 mov	 eax, DWORD PTR _irp$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _IoSetCompletionRoutine@24
$LN1@PassFilter:

; 491  : 
; 492  : 	return IoCallDriver (deviceObject, irp);

  0002b	8b 55 0c	 mov	 edx, DWORD PTR _irp$[ebp]
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _deviceObject$[ebp]
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8

; 493  : }

  00037	5d		 pop	 ebp
  00038	c2 10 00	 ret	 16			; 00000010H
_PassFilteredIrp@16 ENDP
_TEXT	ENDS
PUBLIC	_IoGetNextIrpStackLocation@4
PUBLIC	??_C@_0FK@JAEDPCKJ@?$CIInvokeOnSuccess?5?$HM?$HM?5InvokeOnErro@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0FK@JAEDPCKJ@?$CIInvokeOnSuccess?5?$HM?$HM?5InvokeOnErro@FNODOBFM@
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
text$s	SEGMENT
??_C@_0FK@JAEDPCKJ@?$CIInvokeOnSuccess?5?$HM?$HM?5InvokeOnErro@FNODOBFM@ DB '('
	DB	'InvokeOnSuccess || InvokeOnError || InvokeOnCancel) ? (Comple'
	DB	'tionRoutine != NULL) : TRUE', 00H		;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _IoSetCompletionRoutine@24
_TEXT	SEGMENT
tv78 = -12						; size = 4
tv72 = -8						; size = 4
_irpSp$ = -4						; size = 4
_Irp$ = 8						; size = 4
_CompletionRoutine$ = 12				; size = 4
_Context$ = 16						; size = 4
_InvokeOnSuccess$ = 20					; size = 1
_InvokeOnError$ = 24					; size = 1
_InvokeOnCancel$ = 28					; size = 1
_IoSetCompletionRoutine@24 PROC				; COMDAT

; 23820: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 23821:     PIO_STACK_LOCATION irpSp;
; 23822:     ASSERT( (InvokeOnSuccess || InvokeOnError || InvokeOnCancel) ? (CompletionRoutine != NULL) : TRUE );

  00008	0f b6 45 14	 movzx	 eax, BYTE PTR _InvokeOnSuccess$[ebp]
  0000c	85 c0		 test	 eax, eax
  0000e	75 19		 jne	 SHORT $LN6@IoSetCompl
  00010	0f b6 4d 18	 movzx	 ecx, BYTE PTR _InvokeOnError$[ebp]
  00014	85 c9		 test	 ecx, ecx
  00016	75 11		 jne	 SHORT $LN6@IoSetCompl
  00018	0f b6 55 1c	 movzx	 edx, BYTE PTR _InvokeOnCancel$[ebp]
  0001c	85 d2		 test	 edx, edx
  0001e	75 09		 jne	 SHORT $LN6@IoSetCompl
  00020	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv72[ebp], 1
  00027	eb 0c		 jmp	 SHORT $LN7@IoSetCompl
$LN6@IoSetCompl:
  00029	33 c0		 xor	 eax, eax
  0002b	83 7d 0c 00	 cmp	 DWORD PTR _CompletionRoutine$[ebp], 0
  0002f	0f 95 c0	 setne	 al
  00032	89 45 f8	 mov	 DWORD PTR tv72[ebp], eax
$LN7@IoSetCompl:
  00035	83 7d f8 00	 cmp	 DWORD PTR tv72[ebp], 0
  00039	75 20		 jne	 SHORT $LN8@IoSetCompl
  0003b	6a 00		 push	 0
  0003d	68 0e 5d 00 00	 push	 23822			; 00005d0eH
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@JAEDPCKJ@?$CIInvokeOnSuccess?5?$HM?$HM?5InvokeOnErro@FNODOBFM@
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  00052	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
  00059	eb 07		 jmp	 SHORT $LN9@IoSetCompl
$LN8@IoSetCompl:
  0005b	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
$LN9@IoSetCompl:

; 23823:     irpSp = IoGetNextIrpStackLocation(Irp);

  00062	8b 4d 08	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 _IoGetNextIrpStackLocation@4
  0006b	89 45 fc	 mov	 DWORD PTR _irpSp$[ebp], eax

; 23824:     irpSp->CompletionRoutine = CompletionRoutine;

  0006e	8b 55 fc	 mov	 edx, DWORD PTR _irpSp$[ebp]
  00071	8b 45 0c	 mov	 eax, DWORD PTR _CompletionRoutine$[ebp]
  00074	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 23825:     irpSp->Context = Context;

  00077	8b 4d fc	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  0007a	8b 55 10	 mov	 edx, DWORD PTR _Context$[ebp]
  0007d	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 23826:     irpSp->Control = 0;

  00080	8b 45 fc	 mov	 eax, DWORD PTR _irpSp$[ebp]
  00083	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0

; 23827: 
; 23828:     if (InvokeOnSuccess) {

  00087	0f b6 4d 14	 movzx	 ecx, BYTE PTR _InvokeOnSuccess$[ebp]
  0008b	85 c9		 test	 ecx, ecx
  0008d	74 07		 je	 SHORT $LN3@IoSetCompl

; 23829:         irpSp->Control = SL_INVOKE_ON_SUCCESS;

  0008f	8b 55 fc	 mov	 edx, DWORD PTR _irpSp$[ebp]
  00092	c6 42 03 40	 mov	 BYTE PTR [edx+3], 64	; 00000040H
$LN3@IoSetCompl:

; 23830:     }
; 23831: 
; 23832:     if (InvokeOnError) {

  00096	0f b6 45 18	 movzx	 eax, BYTE PTR _InvokeOnError$[ebp]
  0009a	85 c0		 test	 eax, eax
  0009c	74 13		 je	 SHORT $LN2@IoSetCompl

; 23833:         irpSp->Control |= SL_INVOKE_ON_ERROR;

  0009e	8b 4d fc	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  000a1	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  000a5	81 ca 80 00 00
	00		 or	 edx, 128		; 00000080H
  000ab	8b 45 fc	 mov	 eax, DWORD PTR _irpSp$[ebp]
  000ae	88 50 03	 mov	 BYTE PTR [eax+3], dl
$LN2@IoSetCompl:

; 23834:     }
; 23835: 
; 23836:     if (InvokeOnCancel) {

  000b1	0f b6 4d 1c	 movzx	 ecx, BYTE PTR _InvokeOnCancel$[ebp]
  000b5	85 c9		 test	 ecx, ecx
  000b7	74 10		 je	 SHORT $LN4@IoSetCompl

; 23837:         irpSp->Control |= SL_INVOKE_ON_CANCEL;

  000b9	8b 55 fc	 mov	 edx, DWORD PTR _irpSp$[ebp]
  000bc	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  000c0	83 c8 20	 or	 eax, 32			; 00000020H
  000c3	8b 4d fc	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  000c6	88 41 03	 mov	 BYTE PTR [ecx+3], al
$LN4@IoSetCompl:

; 23838:     }
; 23839: }

  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c2 18 00	 ret	 24			; 00000018H
_IoSetCompletionRoutine@24 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@ DB 'Irp'
	DB	'->CurrentLocation > 0', 00H			;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _IoGetNextIrpStackLocation@4
_TEXT	SEGMENT
tv71 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoGetNextIrpStackLocation@4 PROC			; COMDAT

; 23479: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 23480:     ASSERT(Irp->CurrentLocation > 0);

  00006	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00009	0f be 48 23	 movsx	 ecx, BYTE PTR [eax+35]
  0000d	85 c9		 test	 ecx, ecx
  0000f	7f 20		 jg	 SHORT $LN3@IoGetNextI
  00011	6a 00		 push	 0
  00013	68 b8 5b 00 00	 push	 23480			; 00005bb8H
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
  0002f	eb 07		 jmp	 SHORT $LN4@IoGetNextI
$LN3@IoGetNextI:
  00031	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
$LN4@IoGetNextI:

; 23481: 
; 23482:     return ((Irp)->Tail.Overlay.CurrentStackLocation - 1 );

  00038	8b 55 08	 mov	 edx, DWORD PTR _Irp$[ebp]
  0003b	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  0003e	83 e8 24	 sub	 eax, 36			; 00000024H

; 23483: }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
_IoGetNextIrpStackLocation@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _IoCopyCurrentIrpStackLocationToNext@4
_TEXT	SEGMENT
_irpSp$ = -8						; size = 4
_nextIrpSp$ = -4					; size = 4
_Irp$ = 8						; size = 4
_IoCopyCurrentIrpStackLocationToNext@4 PROC		; COMDAT

; 23912: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8
  00008	56		 push	 esi
  00009	57		 push	 edi

; 23913:     PIO_STACK_LOCATION irpSp;
; 23914:     PIO_STACK_LOCATION nextIrpSp;
; 23915:     irpSp = IoGetCurrentIrpStackLocation(Irp);

  0000a	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 _IoGetCurrentIrpStackLocation@4
  00013	89 45 f8	 mov	 DWORD PTR _irpSp$[ebp], eax

; 23916:     nextIrpSp = IoGetNextIrpStackLocation(Irp);

  00016	8b 4d 08	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 _IoGetNextIrpStackLocation@4
  0001f	89 45 fc	 mov	 DWORD PTR _nextIrpSp$[ebp], eax

; 23917:     RtlCopyMemory( nextIrpSp, irpSp, FIELD_OFFSET(IO_STACK_LOCATION, CompletionRoutine));

  00022	b9 07 00 00 00	 mov	 ecx, 7
  00027	8b 75 f8	 mov	 esi, DWORD PTR _irpSp$[ebp]
  0002a	8b 7d fc	 mov	 edi, DWORD PTR _nextIrpSp$[ebp]
  0002d	f3 a5		 rep movsd

; 23918:     nextIrpSp->Control = 0;

  0002f	8b 55 fc	 mov	 edx, DWORD PTR _nextIrpSp$[ebp]
  00032	c6 42 03 00	 mov	 BYTE PTR [edx+3], 0

; 23919: }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
_IoCopyCurrentIrpStackLocationToNext@4 ENDP
_TEXT	ENDS
PUBLIC	_IoMarkIrpPending@4
; Function compile flags: /Odtp
; File c:\users\public\desktop\projects\ciphershed\src\driver\drivefilter.c
;	COMDAT _OnDeviceUsageNotificationCompleted@12
_TEXT	SEGMENT
_filterDeviceObject$ = 8				; size = 4
_Irp$ = 12						; size = 4
_Extension$ = 16					; size = 4
_OnDeviceUsageNotificationCompleted@12 PROC		; COMDAT

; 497  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 498  : 	if (Irp->PendingReturned)

  00005	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00008	0f b6 48 21	 movzx	 ecx, BYTE PTR [eax+33]
  0000c	85 c9		 test	 ecx, ecx
  0000e	74 09		 je	 SHORT $LN2@OnDeviceUs

; 499  : 		IoMarkIrpPending (Irp);

  00010	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  00013	52		 push	 edx
  00014	e8 00 00 00 00	 call	 _IoMarkIrpPending@4
$LN2@OnDeviceUs:

; 500  : 
; 501  : 	if (!(Extension->LowerDeviceObject->Flags & DO_POWER_PAGABLE))

  00019	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  0001c	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0001f	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00022	81 e2 00 20 00
	00		 and	 edx, 8192		; 00002000H
  00028	75 12		 jne	 SHORT $LN1@OnDeviceUs

; 502  : 		filterDeviceObject->Flags &= ~DO_POWER_PAGABLE;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _filterDeviceObject$[ebp]
  0002d	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00030	81 e1 ff df ff
	ff		 and	 ecx, -8193		; ffffdfffH
  00036	8b 55 08	 mov	 edx, DWORD PTR _filterDeviceObject$[ebp]
  00039	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx
$LN1@OnDeviceUs:

; 503  : 
; 504  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  0003c	6a 58		 push	 88			; 00000058H
  0003e	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00041	50		 push	 eax
  00042	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00045	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  0004b	51		 push	 ecx
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 505  : 	return STATUS_CONTINUE_COMPLETION;

  00052	33 c0		 xor	 eax, eax

; 506  : }

  00054	5d		 pop	 ebp
  00055	c2 0c 00	 ret	 12			; 0000000cH
_OnDeviceUsageNotificationCompleted@12 ENDP
; Function compile flags: /Odtp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT _IoMarkIrpPending@4
_TEXT	SEGMENT
tv67 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoMarkIrpPending@4 PROC				; COMDAT

; 23667: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 23668:     IoGetCurrentIrpStackLocation( (Irp) )->Control |= SL_PENDING_RETURNED;

  00006	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _IoGetCurrentIrpStackLocation@4
  0000f	83 c0 03	 add	 eax, 3
  00012	89 45 fc	 mov	 DWORD PTR tv67[ebp], eax
  00015	8b 4d fc	 mov	 ecx, DWORD PTR tv67[ebp]
  00018	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0001b	83 ca 01	 or	 edx, 1
  0001e	8b 45 fc	 mov	 eax, DWORD PTR tv67[ebp]
  00021	88 10		 mov	 BYTE PTR [eax], dl

; 23669: }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
_IoMarkIrpPending@4 ENDP
_TEXT	ENDS
EXTRN	__imp__IoFreeWorkItem@4:PROC
EXTRN	__imp__KeWaitForSingleObject@20:PROC
EXTRN	__imp__IoQueueWorkItem@16:PROC
EXTRN	__imp__KeInitializeEvent@12:PROC
EXTRN	__imp__IoAllocateWorkItem@4:PROC
EXTRN	__imp__KeGetCurrentIrql@0:PROC
; Function compile flags: /Odtp
; File c:\users\public\desktop\projects\ciphershed\src\driver\drivefilter.c
;	COMDAT _OnStartDeviceCompleted@12
_TEXT	SEGMENT
_workItem$28152 = -4					; size = 4
_filterDeviceObject$ = 8				; size = 4
_Irp$ = 12						; size = 4
_Extension$ = 16					; size = 4
_OnStartDeviceCompleted@12 PROC				; COMDAT

; 562  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 563  : 	if (Irp->PendingReturned)

  00006	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00009	0f b6 48 21	 movzx	 ecx, BYTE PTR [eax+33]
  0000d	85 c9		 test	 ecx, ecx
  0000f	74 09		 je	 SHORT $LN5@OnStartDev

; 564  : 		IoMarkIrpPending (Irp);

  00011	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _IoMarkIrpPending@4
$LN5@OnStartDev:

; 565  : 
; 566  : 	if (Extension->LowerDeviceObject->Characteristics & FILE_REMOVABLE_MEDIA)

  0001a	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  0001d	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00020	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00023	83 e2 01	 and	 edx, 1
  00026	74 0f		 je	 SHORT $LN4@OnStartDev

; 567  : 		filterDeviceObject->Characteristics |= FILE_REMOVABLE_MEDIA;

  00028	8b 45 08	 mov	 eax, DWORD PTR _filterDeviceObject$[ebp]
  0002b	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0002e	83 c9 01	 or	 ecx, 1
  00031	8b 55 08	 mov	 edx, DWORD PTR _filterDeviceObject$[ebp]
  00034	89 4a 20	 mov	 DWORD PTR [edx+32], ecx
$LN4@OnStartDev:

; 568  : 
; 569  : 	if (KeGetCurrentIrql() == PASSIVE_LEVEL)

  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeGetCurrentIrql@0
  0003d	0f b6 c0	 movzx	 eax, al
  00040	85 c0		 test	 eax, eax
  00042	75 0b		 jne	 SHORT $LN3@OnStartDev

; 570  : 	{
; 571  : 		CheckDeviceTypeAndMount (Extension);

  00044	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 _CheckDeviceTypeAndMount@4

; 572  : 	}
; 573  : 	else

  0004d	eb 7b		 jmp	 SHORT $LN2@OnStartDev
$LN3@OnStartDev:

; 574  : 	{
; 575  : 		PIO_WORKITEM workItem = IoAllocateWorkItem (filterDeviceObject);

  0004f	8b 55 08	 mov	 edx, DWORD PTR _filterDeviceObject$[ebp]
  00052	52		 push	 edx
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAllocateWorkItem@4
  00059	89 45 fc	 mov	 DWORD PTR _workItem$28152[ebp], eax

; 576  : 		if (!workItem)

  0005c	83 7d fc 00	 cmp	 DWORD PTR _workItem$28152[ebp], 0
  00060	75 1d		 jne	 SHORT $LN1@OnStartDev

; 577  : 		{
; 578  : 			IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00062	6a 58		 push	 88			; 00000058H
  00064	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00067	50		 push	 eax
  00068	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0006b	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  00071	51		 push	 ecx
  00072	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 579  : 			return STATUS_INSUFFICIENT_RESOURCES;

  00078	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  0007d	eb 63		 jmp	 SHORT $LN6@OnStartDev
$LN1@OnStartDev:

; 580  : 		}
; 581  : 
; 582  : 		KeInitializeEvent (&Extension->MountWorkItemCompletedEvent, SynchronizationEvent, FALSE);

  0007f	6a 00		 push	 0
  00081	6a 01		 push	 1
  00083	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  00086	81 c2 34 02 00
	00		 add	 edx, 564		; 00000234H
  0008c	52		 push	 edx
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 583  : 		IoQueueWorkItem (workItem, MountDriveWorkItemRoutine, DelayedWorkQueue, Extension); 

  00093	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  00096	50		 push	 eax
  00097	6a 01		 push	 1
  00099	68 00 00 00 00	 push	 OFFSET _MountDriveWorkItemRoutine@8
  0009e	8b 4d fc	 mov	 ecx, DWORD PTR _workItem$28152[ebp]
  000a1	51		 push	 ecx
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoQueueWorkItem@16

; 584  : 
; 585  : 		KeWaitForSingleObject (&Extension->MountWorkItemCompletedEvent, Executive, KernelMode, FALSE, NULL);

  000a8	6a 00		 push	 0
  000aa	6a 00		 push	 0
  000ac	6a 00		 push	 0
  000ae	6a 00		 push	 0
  000b0	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  000b3	81 c2 34 02 00
	00		 add	 edx, 564		; 00000234H
  000b9	52		 push	 edx
  000ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 586  : 		IoFreeWorkItem (workItem);

  000c0	8b 45 fc	 mov	 eax, DWORD PTR _workItem$28152[ebp]
  000c3	50		 push	 eax
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoFreeWorkItem@4
$LN2@OnStartDev:

; 587  : 	}
; 588  : 
; 589  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  000ca	6a 58		 push	 88			; 00000058H
  000cc	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  000cf	51		 push	 ecx
  000d0	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  000d3	81 c2 b8 00 00
	00		 add	 edx, 184		; 000000b8H
  000d9	52		 push	 edx
  000da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 590  : 	return STATUS_CONTINUE_COMPLETION;

  000e0	33 c0		 xor	 eax, eax
$LN6@OnStartDev:

; 591  : }

  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c2 0c 00	 ret	 12			; 0000000cH
_OnStartDeviceCompleted@12 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@NOBPEAIN@Drive?5and?5volume?5merged?5pdo?$DN?$CFp?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp__KeReleaseMutex@8:PROC
EXTRN	_VolumeClassFilterRegistered:DWORD
;	COMDAT ??_C@_0BP@NOBPEAIN@Drive?5and?5volume?5merged?5pdo?$DN?$CFp?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BP@NOBPEAIN@Drive?5and?5volume?5merged?5pdo?$DN?$CFp?$AA@FNODOBFM@ DB 'D'
	DB	'rive and volume merged pdo=%p', 00H		;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _CheckDeviceTypeAndMount@4
_TEXT	SEGMENT
_status$28127 = -4					; size = 4
_filterExtension$ = 8					; size = 4
_CheckDeviceTypeAndMount@4 PROC				; COMDAT

; 525  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 526  : 	if (BootArgsValid)

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _BootArgsValid, 0
  0000d	0f 84 ad 00 00
	00		 je	 $LN7@CheckDevic

; 527  : 	{
; 528  : 		// Windows sometimes merges a removable drive PDO and its volume PDO to a single PDO having no volume interface (GUID_DEVINTERFACE_VOLUME).
; 529  : 		// Therefore, we need to test whether the device supports volume IOCTLs.
; 530  : 		if (VolumeClassFilterRegistered
; 531  : 			&& BootArgs.HiddenSystemPartitionStart != 0
; 532  : 			&& IsVolumeDevice (filterExtension->LowerDeviceObject))

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _VolumeClassFilterRegistered, 0
  0001a	74 47		 je	 SHORT $LN4@CheckDevic
  0001c	a1 5a 00 00 00	 mov	 eax, DWORD PTR _BootArgs+90
  00021	0b 05 5e 00 00
	00		 or	 eax, DWORD PTR _BootArgs+94
  00027	74 3a		 je	 SHORT $LN4@CheckDevic
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _filterExtension$[ebp]
  0002c	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 _IsVolumeDevice@4
  00035	85 c0		 test	 eax, eax
  00037	74 2a		 je	 SHORT $LN4@CheckDevic

; 533  : 		{
; 534  : 			Dump ("Drive and volume merged pdo=%p", filterExtension->Pdo);

  00039	8b 45 08	 mov	 eax, DWORD PTR _filterExtension$[ebp]
  0003c	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0003f	51		 push	 ecx
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@NOBPEAIN@Drive?5and?5volume?5merged?5pdo?$DN?$CFp?$AA@FNODOBFM@
  00045	e8 00 00 00 00	 call	 _DbgPrint
  0004a	83 c4 08	 add	 esp, 8

; 535  : 
; 536  : 			filterExtension->IsVolumeFilterDevice = TRUE;

  0004d	8b 55 08	 mov	 edx, DWORD PTR _filterExtension$[ebp]
  00050	c7 42 0c 01 00
	00 00		 mov	 DWORD PTR [edx+12], 1

; 537  : 			filterExtension->IsDriveFilterDevice = FALSE;

  00057	8b 45 08	 mov	 eax, DWORD PTR _filterExtension$[ebp]
  0005a	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 538  : 		}
; 539  : 		else

  00061	eb 5d		 jmp	 SHORT $LN7@CheckDevic
$LN4@CheckDevic:

; 540  : 		{
; 541  : 			NTSTATUS status = KeWaitForMutexObject (&MountMutex, Executive, KernelMode, FALSE, NULL);

  00063	6a 00		 push	 0
  00065	6a 00		 push	 0
  00067	6a 00		 push	 0
  00069	6a 00		 push	 0
  0006b	68 00 00 00 00	 push	 OFFSET _MountMutex
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
  00076	89 45 fc	 mov	 DWORD PTR _status$28127[ebp], eax

; 542  : 			if (!NT_SUCCESS (status))

  00079	83 7d fc 00	 cmp	 DWORD PTR _status$28127[ebp], 0
  0007d	7d 18		 jge	 SHORT $LN2@CheckDevic

; 543  : 				TC_BUG_CHECK (status);

  0007f	68 43 54 00 00	 push	 21571			; 00005443H
  00084	6a 00		 push	 0
  00086	8b 4d fc	 mov	 ecx, DWORD PTR _status$28127[ebp]
  00089	51		 push	 ecx
  0008a	68 1f 02 00 00	 push	 543			; 0000021fH
  0008f	6a 29		 push	 41			; 00000029H
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN2@CheckDevic:

; 544  : 
; 545  : 			if (!BootDriveFound)

  00097	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _BootDriveFound, 0
  0009e	75 13		 jne	 SHORT $LN1@CheckDevic

; 546  : 				MountDrive (filterExtension, &BootArgs.BootPassword, &BootArgs.HeaderSaltCrc32);

  000a0	68 0e 00 00 00	 push	 OFFSET _BootArgs+14
  000a5	68 12 00 00 00	 push	 OFFSET _BootArgs+18
  000aa	8b 55 08	 mov	 edx, DWORD PTR _filterExtension$[ebp]
  000ad	52		 push	 edx
  000ae	e8 00 00 00 00	 call	 _MountDrive@12
$LN1@CheckDevic:

; 547  : 
; 548  : 			KeReleaseMutex (&MountMutex, FALSE);

  000b3	6a 00		 push	 0
  000b5	68 00 00 00 00	 push	 OFFSET _MountMutex
  000ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeReleaseMutex@8
$LN7@CheckDevic:

; 549  : 		}
; 550  : 	}
; 551  : }

  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c2 04 00	 ret	 4
_CheckDeviceTypeAndMount@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@CKLJIMPP@Header?5not?5decrypted?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_IsHiddenSystemRunning@0
PUBLIC	_StartLegacyHibernationDriverFilter@0
PUBLIC	??_C@_0CH@IHPMFJGA@Failed?5to?5get?5drive?5length?5?9?5err@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CH@LNDECHEL@Failed?5to?5get?5drive?5number?5?9?5err@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_RtlSecureZeroMemory@8
PUBLIC	??_C@_0BF@DFBDNCBE@Wiping?5memory?5?$CFx?5?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EK@PHFABMCK@Loaded?3?5EncryptedAreaStart?$DN?$CFI64d@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0FO@PAPPJPK@Loaded?3?5ConfiguredEncryptedAreaS@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CE@NLPFMAEC@RemappedAreaDataUnitOffset?5?$DN?5?$CFI6@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BM@GBKCGBDB@RemappedAreaOffset?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CE@ONLIABPH@Hidden?5volume?5start?5offset?5?$DN?5?$CFI6@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BC@LMOOMJMK@Header?5decrypted?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BH@FBDKNNGH@TCReadDevice?5error?5?$CFx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CA@JLOPIPKN@Reading?5volume?5header?5at?5?$CFI64u?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CE@KKOENIAD@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5PASSIVE_LE@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BD@JFDPBFDA@MountDrive?5pdo?$DN?$CFp?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	__$ArrayPad$
EXTRN	__imp__ExFreePoolWithTag@8:PROC
EXTRN	_IsOSAtLeast@4:PROC
EXTRN	_EncryptedIoQueueStart@4:PROC
EXTRN	_SendDeviceIoControlRequest@24:PROC
EXTRN	_ReadVolumeHeader@20:PROC
EXTRN	_crypto_open@0:PROC
EXTRN	__imp__ExAllocatePoolWithTag@12:PROC
EXTRN	_TCReadDevice@20:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__alldiv:PROC
EXTRN	__aulldiv:PROC
_BSS	SEGMENT
	ALIGN	8

_BootDriveLength DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BG@CKLJIMPP@Header?5not?5decrypted?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BG@CKLJIMPP@Header?5not?5decrypted?6?$AA@FNODOBFM@ DB 'Header not '
	DB	'decrypted', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CH@IHPMFJGA@Failed?5to?5get?5drive?5length?5?9?5err@FNODOBFM@
text$s	SEGMENT
??_C@_0CH@IHPMFJGA@Failed?5to?5get?5drive?5length?5?9?5err@FNODOBFM@ DB 'F'
	DB	'ailed to get drive length - error %x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CH@LNDECHEL@Failed?5to?5get?5drive?5number?5?9?5err@FNODOBFM@
text$s	SEGMENT
??_C@_0CH@LNDECHEL@Failed?5to?5get?5drive?5number?5?9?5err@FNODOBFM@ DB 'F'
	DB	'ailed to get drive number - error %x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BF@DFBDNCBE@Wiping?5memory?5?$CFx?5?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BF@DFBDNCBE@Wiping?5memory?5?$CFx?5?$CFd?6?$AA@FNODOBFM@ DB 'Wipin'
	DB	'g memory %x %d', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EK@PHFABMCK@Loaded?3?5EncryptedAreaStart?$DN?$CFI64d@FNODOBFM@
text$s	SEGMENT
??_C@_0EK@PHFABMCK@Loaded?3?5EncryptedAreaStart?$DN?$CFI64d@FNODOBFM@ DB 'L'
	DB	'oaded: EncryptedAreaStart=%I64d (%I64d)  EncryptedAreaEnd=%I6'
	DB	'4d (%I64d)', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0FO@PAPPJPK@Loaded?3?5ConfiguredEncryptedAreaS@FNODOBFM@
text$s	SEGMENT
??_C@_0FO@PAPPJPK@Loaded?3?5ConfiguredEncryptedAreaS@FNODOBFM@ DB 'Loaded'
	DB	': ConfiguredEncryptedAreaStart=%I64d (%I64d)  ConfiguredEncry'
	DB	'ptedAreaEnd=%I64d (%I64d)', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CE@NLPFMAEC@RemappedAreaDataUnitOffset?5?$DN?5?$CFI6@FNODOBFM@
text$s	SEGMENT
??_C@_0CE@NLPFMAEC@RemappedAreaDataUnitOffset?5?$DN?5?$CFI6@FNODOBFM@ DB 'R'
	DB	'emappedAreaDataUnitOffset = %I64d', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BM@GBKCGBDB@RemappedAreaOffset?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BM@GBKCGBDB@RemappedAreaOffset?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@ DB 'R'
	DB	'emappedAreaOffset = %I64d', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CE@ONLIABPH@Hidden?5volume?5start?5offset?5?$DN?5?$CFI6@FNODOBFM@
text$s	SEGMENT
??_C@_0CE@ONLIABPH@Hidden?5volume?5start?5offset?5?$DN?5?$CFI6@FNODOBFM@ DB 'H'
	DB	'idden volume start offset = %I64d', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BC@LMOOMJMK@Header?5decrypted?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BC@LMOOMJMK@Header?5decrypted?6?$AA@FNODOBFM@ DB 'Header decrypted'
	DB	0aH, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BH@FBDKNNGH@TCReadDevice?5error?5?$CFx?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BH@FBDKNNGH@TCReadDevice?5error?5?$CFx?6?$AA@FNODOBFM@ DB 'TCReadD'
	DB	'evice error %x', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CA@JLOPIPKN@Reading?5volume?5header?5at?5?$CFI64u?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0CA@JLOPIPKN@Reading?5volume?5header?5at?5?$CFI64u?6?$AA@FNODOBFM@ DB 'R'
	DB	'eading volume header at %I64u', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CE@KKOENIAD@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5PASSIVE_LE@FNODOBFM@
text$s	SEGMENT
??_C@_0CE@KKOENIAD@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5PASSIVE_LE@FNODOBFM@ DB 'K'
	DB	'eGetCurrentIrql() == PASSIVE_LEVEL', 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BD@JFDPBFDA@MountDrive?5pdo?$DN?$CFp?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BD@JFDPBFDA@MountDrive?5pdo?$DN?$CFp?6?$AA@FNODOBFM@ DB 'MountDriv'
	DB	'e pdo=%p', 0aH, 00H				;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _MountDrive@12
_TEXT	SEGMENT
tv576 = -636						; size = 4
tv512 = -632						; size = 8
tv511 = -624						; size = 4
tv94 = -620						; size = 8
tv77 = -612						; size = 4
tv65 = -608						; size = 4
_storageDeviceNumber$28001 = -604			; size = 12
_burnm$27995 = -592					; size = 4
_burnc$27997 = -588					; size = 4
_cryptoInfoAddress$27988 = -584				; size = 8
_mappedCryptoInfo$27989 = -572				; size = 4
_hiddenPartitionOffset$27977 = -568			; size = 8
_saltCrc$27968 = -556					; size = 4
_mbr$27954 = -552					; size = 512
__$ArrayPad$ = -36					; size = 4
_header$ = -32						; size = 4
_status$ = -28						; size = 4
_offset$ = -24						; size = 8
_hiddenVolume$ = -12					; size = 4
_hiddenHeaderOffset$ = -8				; size = 8
_Extension$ = 8						; size = 4
_password$ = 12						; size = 4
_headerSaltCrc32$ = 16					; size = 4
_MountDrive@12 PROC					; COMDAT

; 223  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 7c 02 00
	00		 sub	 esp, 636		; 0000027cH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi
  00016	57		 push	 edi

; 224  : 	BOOL hiddenVolume = (BootArgs.HiddenSystemPartitionStart != 0);

  00017	a1 5a 00 00 00	 mov	 eax, DWORD PTR _BootArgs+90
  0001c	0b 05 5e 00 00
	00		 or	 eax, DWORD PTR _BootArgs+94
  00022	74 0c		 je	 SHORT $LN32@MountDrive
  00024	c7 85 a0 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv65[ebp], 1
  0002e	eb 0a		 jmp	 SHORT $LN33@MountDrive
$LN32@MountDrive:
  00030	c7 85 a0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv65[ebp], 0
$LN33@MountDrive:
  0003a	8b 8d a0 fd ff
	ff		 mov	 ecx, DWORD PTR tv65[ebp]
  00040	89 4d f4	 mov	 DWORD PTR _hiddenVolume$[ebp], ecx

; 225  : 	int64 hiddenHeaderOffset = BootArgs.HiddenSystemPartitionStart + TC_HIDDEN_VOLUME_HEADER_OFFSET;

  00043	8b 15 5a 00 00
	00		 mov	 edx, DWORD PTR _BootArgs+90
  00049	81 c2 00 00 01
	00		 add	 edx, 65536		; 00010000H
  0004f	a1 5e 00 00 00	 mov	 eax, DWORD PTR _BootArgs+94
  00054	83 d0 00	 adc	 eax, 0
  00057	89 55 f8	 mov	 DWORD PTR _hiddenHeaderOffset$[ebp], edx
  0005a	89 45 fc	 mov	 DWORD PTR _hiddenHeaderOffset$[ebp+4], eax

; 226  : 	NTSTATUS status;
; 227  : 	LARGE_INTEGER offset;
; 228  : 	char *header;
; 229  : 
; 230  : 	Dump ("MountDrive pdo=%p\n", Extension->Pdo);

  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00060	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00063	52		 push	 edx
  00064	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@JFDPBFDA@MountDrive?5pdo?$DN?$CFp?6?$AA@FNODOBFM@
  00069	e8 00 00 00 00	 call	 _DbgPrint
  0006e	83 c4 08	 add	 esp, 8

; 231  : 	ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeGetCurrentIrql@0
  00077	0f b6 c0	 movzx	 eax, al
  0007a	85 c0		 test	 eax, eax
  0007c	74 23		 je	 SHORT $LN34@MountDrive
  0007e	6a 00		 push	 0
  00080	68 e7 00 00 00	 push	 231			; 000000e7H
  00085	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@GDHJGIB@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  0008a	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@KKOENIAD@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5PASSIVE_LE@FNODOBFM@
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  00095	c7 85 9c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv77[ebp], 0
  0009f	eb 0a		 jmp	 SHORT $LN35@MountDrive
$LN34@MountDrive:
  000a1	c7 85 9c fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv77[ebp], 1
$LN35@MountDrive:

; 232  : 
; 233  : 	// Check boot drive signature first (header CRC search could fail if a user restored the header to a non-boot drive)
; 234  : 	if (BootDriveSignatureValid)

  000ab	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _BootDriveSignatureValid, 0
  000b2	74 4b		 je	 SHORT $LN29@MountDrive

; 235  : 	{
; 236  : 		byte mbr[TC_SECTOR_SIZE_BIOS];
; 237  : 
; 238  : 		offset.QuadPart = 0;

  000b4	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _offset$[ebp], 0
  000bb	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _offset$[ebp+4], 0

; 239  : 		status = TCReadDevice (Extension->LowerDeviceObject, mbr, offset, TC_SECTOR_SIZE_BIOS);

  000c2	68 00 02 00 00	 push	 512			; 00000200H
  000c7	8b 4d ec	 mov	 ecx, DWORD PTR _offset$[ebp+4]
  000ca	51		 push	 ecx
  000cb	8b 55 e8	 mov	 edx, DWORD PTR _offset$[ebp]
  000ce	52		 push	 edx
  000cf	8d 85 d8 fd ff
	ff		 lea	 eax, DWORD PTR _mbr$27954[ebp]
  000d5	50		 push	 eax
  000d6	8b 4d 08	 mov	 ecx, DWORD PTR _Extension$[ebp]
  000d9	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  000dc	52		 push	 edx
  000dd	e8 00 00 00 00	 call	 _TCReadDevice@20
  000e2	89 45 e4	 mov	 DWORD PTR _status$[ebp], eax

; 240  : 
; 241  : 		if (NT_SUCCESS (status) && BootArgs.BootDriveSignature != *(uint32 *) (mbr + 0x1b8))

  000e5	83 7d e4 00	 cmp	 DWORD PTR _status$[ebp], 0
  000e9	7c 14		 jl	 SHORT $LN29@MountDrive
  000eb	a1 6e 00 00 00	 mov	 eax, DWORD PTR _BootArgs+110
  000f0	3b 45 90	 cmp	 eax, DWORD PTR _mbr$27954[ebp+440]
  000f3	74 0a		 je	 SHORT $LN29@MountDrive

; 242  : 			return STATUS_UNSUCCESSFUL;

  000f5	b8 01 00 00 c0	 mov	 eax, -1073741823	; c0000001H
  000fa	e9 1a 08 00 00	 jmp	 $LN31@MountDrive
$LN29@MountDrive:

; 243  : 	}
; 244  : 
; 245  : 	header = TCalloc (TC_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE);

  000ff	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00104	68 00 02 00 00	 push	 512			; 00000200H
  00109	6a 00		 push	 0
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00111	89 45 e0	 mov	 DWORD PTR _header$[ebp], eax

; 246  : 	if (!header)

  00114	83 7d e0 00	 cmp	 DWORD PTR _header$[ebp], 0
  00118	75 0a		 jne	 SHORT $LN27@MountDrive

; 247  : 		return STATUS_INSUFFICIENT_RESOURCES;

  0011a	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  0011f	e9 f5 07 00 00	 jmp	 $LN31@MountDrive
$LN27@MountDrive:

; 248  : 
; 249  : 	offset.QuadPart = hiddenVolume ? hiddenHeaderOffset : TC_BOOT_VOLUME_HEADER_SECTOR_OFFSET;

  00124	83 7d f4 00	 cmp	 DWORD PTR _hiddenVolume$[ebp], 0
  00128	74 14		 je	 SHORT $LN36@MountDrive
  0012a	8b 4d f8	 mov	 ecx, DWORD PTR _hiddenHeaderOffset$[ebp]
  0012d	89 8d 94 fd ff
	ff		 mov	 DWORD PTR tv94[ebp], ecx
  00133	8b 55 fc	 mov	 edx, DWORD PTR _hiddenHeaderOffset$[ebp+4]
  00136	89 95 98 fd ff
	ff		 mov	 DWORD PTR tv94[ebp+4], edx
  0013c	eb 14		 jmp	 SHORT $LN37@MountDrive
$LN36@MountDrive:
  0013e	c7 85 94 fd ff
	ff 00 7c 00 00	 mov	 DWORD PTR tv94[ebp], 31744 ; 00007c00H
  00148	c7 85 98 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv94[ebp+4], 0
$LN37@MountDrive:
  00152	8b 85 94 fd ff
	ff		 mov	 eax, DWORD PTR tv94[ebp]
  00158	89 45 e8	 mov	 DWORD PTR _offset$[ebp], eax
  0015b	8b 8d 98 fd ff
	ff		 mov	 ecx, DWORD PTR tv94[ebp+4]
  00161	89 4d ec	 mov	 DWORD PTR _offset$[ebp+4], ecx

; 250  : 	Dump ("Reading volume header at %I64u\n", offset.QuadPart);

  00164	8b 55 ec	 mov	 edx, DWORD PTR _offset$[ebp+4]
  00167	52		 push	 edx
  00168	8b 45 e8	 mov	 eax, DWORD PTR _offset$[ebp]
  0016b	50		 push	 eax
  0016c	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@JLOPIPKN@Reading?5volume?5header?5at?5?$CFI64u?6?$AA@FNODOBFM@
  00171	e8 00 00 00 00	 call	 _DbgPrint
  00176	83 c4 0c	 add	 esp, 12			; 0000000cH

; 251  : 
; 252  : 	status = TCReadDevice (Extension->LowerDeviceObject, header, offset, TC_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE);

  00179	68 00 02 00 00	 push	 512			; 00000200H
  0017e	8b 4d ec	 mov	 ecx, DWORD PTR _offset$[ebp+4]
  00181	51		 push	 ecx
  00182	8b 55 e8	 mov	 edx, DWORD PTR _offset$[ebp]
  00185	52		 push	 edx
  00186	8b 45 e0	 mov	 eax, DWORD PTR _header$[ebp]
  00189	50		 push	 eax
  0018a	8b 4d 08	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0018d	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00190	52		 push	 edx
  00191	e8 00 00 00 00	 call	 _TCReadDevice@20
  00196	89 45 e4	 mov	 DWORD PTR _status$[ebp], eax

; 253  : 	if (!NT_SUCCESS (status))

  00199	83 7d e4 00	 cmp	 DWORD PTR _status$[ebp], 0
  0019d	7d 16		 jge	 SHORT $LN26@MountDrive

; 254  : 	{
; 255  : 		Dump ("TCReadDevice error %x\n", status);

  0019f	8b 45 e4	 mov	 eax, DWORD PTR _status$[ebp]
  001a2	50		 push	 eax
  001a3	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@FBDKNNGH@TCReadDevice?5error?5?$CFx?6?$AA@FNODOBFM@
  001a8	e8 00 00 00 00	 call	 _DbgPrint
  001ad	83 c4 08	 add	 esp, 8

; 256  : 		goto ret;

  001b0	e9 52 07 00 00	 jmp	 $ret$27966
$LN26@MountDrive:

; 257  : 	}
; 258  : 
; 259  : 	if (headerSaltCrc32)

  001b5	83 7d 10 00	 cmp	 DWORD PTR _headerSaltCrc32$[ebp], 0
  001b9	74 36		 je	 SHORT $LN25@MountDrive

; 260  : 	{
; 261  : 		uint32 saltCrc = GetCrc32 (header, PKCS5_SALT_SIZE);

  001bb	6a 40		 push	 64			; 00000040H
  001bd	8b 4d e0	 mov	 ecx, DWORD PTR _header$[ebp]
  001c0	51		 push	 ecx
  001c1	e8 00 00 00 00	 call	 _GetCrc32@8
  001c6	89 85 d4 fd ff
	ff		 mov	 DWORD PTR _saltCrc$27968[ebp], eax

; 262  : 
; 263  : 		if (saltCrc != *headerSaltCrc32)

  001cc	8b 55 10	 mov	 edx, DWORD PTR _headerSaltCrc32$[ebp]
  001cf	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _saltCrc$27968[ebp]
  001d5	3b 02		 cmp	 eax, DWORD PTR [edx]
  001d7	74 0c		 je	 SHORT $LN24@MountDrive

; 264  : 		{
; 265  : 			status = STATUS_UNSUCCESSFUL;

  001d9	c7 45 e4 01 00
	00 c0		 mov	 DWORD PTR _status$[ebp], -1073741823 ; c0000001H

; 266  : 			goto ret;

  001e0	e9 22 07 00 00	 jmp	 $ret$27966
$LN24@MountDrive:

; 267  : 		}
; 268  : 
; 269  : 		Extension->VolumeHeaderSaltCrc32 = saltCrc;

  001e5	8b 4d 08	 mov	 ecx, DWORD PTR _Extension$[ebp]
  001e8	8b 95 d4 fd ff
	ff		 mov	 edx, DWORD PTR _saltCrc$27968[ebp]
  001ee	89 51 40	 mov	 DWORD PTR [ecx+64], edx
$LN25@MountDrive:

; 270  : 	}
; 271  : 
; 272  : 	Extension->HeaderCryptoInfo = crypto_open();

  001f1	e8 00 00 00 00	 call	 _crypto_open@0
  001f6	8b 4d 08	 mov	 ecx, DWORD PTR _Extension$[ebp]
  001f9	89 81 44 02 00
	00		 mov	 DWORD PTR [ecx+580], eax

; 273  : 	if (!Extension->HeaderCryptoInfo)

  001ff	8b 55 08	 mov	 edx, DWORD PTR _Extension$[ebp]
  00202	83 ba 44 02 00
	00 00		 cmp	 DWORD PTR [edx+580], 0
  00209	75 0c		 jne	 SHORT $LN23@MountDrive

; 274  : 	{
; 275  : 		status = STATUS_INSUFFICIENT_RESOURCES;

  0020b	c7 45 e4 9a 00
	00 c0		 mov	 DWORD PTR _status$[ebp], -1073741670 ; c000009aH

; 276  : 		goto ret;

  00212	e9 f0 06 00 00	 jmp	 $ret$27966
$LN23@MountDrive:

; 277  : 	}
; 278  : 
; 279  : 	if (ReadVolumeHeader (!hiddenVolume, header, password, &Extension->Queue.CryptoInfo, Extension->HeaderCryptoInfo) == 0)

  00217	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  0021a	8b 88 44 02 00
	00		 mov	 ecx, DWORD PTR [eax+580]
  00220	51		 push	 ecx
  00221	8b 55 08	 mov	 edx, DWORD PTR _Extension$[ebp]
  00224	83 c2 70	 add	 edx, 112		; 00000070H
  00227	52		 push	 edx
  00228	8b 45 0c	 mov	 eax, DWORD PTR _password$[ebp]
  0022b	50		 push	 eax
  0022c	8b 4d e0	 mov	 ecx, DWORD PTR _header$[ebp]
  0022f	51		 push	 ecx
  00230	33 d2		 xor	 edx, edx
  00232	83 7d f4 00	 cmp	 DWORD PTR _hiddenVolume$[ebp], 0
  00236	0f 94 c2	 sete	 dl
  00239	52		 push	 edx
  0023a	e8 00 00 00 00	 call	 _ReadVolumeHeader@20
  0023f	85 c0		 test	 eax, eax
  00241	0f 85 90 06 00
	00		 jne	 $LN22@MountDrive

; 280  : 	{
; 281  : 		// Header decrypted
; 282  : 		status = STATUS_SUCCESS;

  00247	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _status$[ebp], 0

; 283  : 		Dump ("Header decrypted\n");

  0024e	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@LMOOMJMK@Header?5decrypted?6?$AA@FNODOBFM@
  00253	e8 00 00 00 00	 call	 _DbgPrint
  00258	83 c4 04	 add	 esp, 4

; 284  : 			
; 285  : 		if (Extension->Queue.CryptoInfo->hiddenVolume)

  0025b	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  0025e	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  00261	83 b9 a0 29 00
	00 00		 cmp	 DWORD PTR [ecx+10656], 0
  00268	0f 84 b3 01 00
	00		 je	 $LN21@MountDrive

; 286  : 		{
; 287  : 			int64 hiddenPartitionOffset = BootArgs.HiddenSystemPartitionStart;

  0026e	8b 15 5a 00 00
	00		 mov	 edx, DWORD PTR _BootArgs+90
  00274	89 95 c8 fd ff
	ff		 mov	 DWORD PTR _hiddenPartitionOffset$27977[ebp], edx
  0027a	a1 5e 00 00 00	 mov	 eax, DWORD PTR _BootArgs+94
  0027f	89 85 cc fd ff
	ff		 mov	 DWORD PTR _hiddenPartitionOffset$27977[ebp+4], eax

; 288  : 			Dump ("Hidden volume start offset = %I64d\n", Extension->Queue.CryptoInfo->EncryptedAreaStart.Value + hiddenPartitionOffset);

  00285	8b 4d 08	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00288	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  0028b	8b 82 50 44 00
	00		 mov	 eax, DWORD PTR [edx+17488]
  00291	03 85 c8 fd ff
	ff		 add	 eax, DWORD PTR _hiddenPartitionOffset$27977[ebp]
  00297	8b 8a 54 44 00
	00		 mov	 ecx, DWORD PTR [edx+17492]
  0029d	13 8d cc fd ff
	ff		 adc	 ecx, DWORD PTR _hiddenPartitionOffset$27977[ebp+4]
  002a3	51		 push	 ecx
  002a4	50		 push	 eax
  002a5	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@ONLIABPH@Hidden?5volume?5start?5offset?5?$DN?5?$CFI6@FNODOBFM@
  002aa	e8 00 00 00 00	 call	 _DbgPrint
  002af	83 c4 0c	 add	 esp, 12			; 0000000cH

; 289  : 			
; 290  : 			Extension->HiddenSystem = TRUE;

  002b2	8b 55 08	 mov	 edx, DWORD PTR _Extension$[ebp]
  002b5	c7 82 48 02 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+584], 1

; 291  : 
; 292  : 			Extension->Queue.RemapEncryptedArea = TRUE;

  002bf	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  002c2	c7 80 a4 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+164], 1

; 293  : 			Extension->Queue.RemappedAreaOffset = hiddenPartitionOffset + Extension->Queue.CryptoInfo->EncryptedAreaStart.Value - BootArgs.DecoySystemPartitionStart;

  002cc	8b 4d 08	 mov	 ecx, DWORD PTR _Extension$[ebp]
  002cf	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  002d2	8b 85 c8 fd ff
	ff		 mov	 eax, DWORD PTR _hiddenPartitionOffset$27977[ebp]
  002d8	03 82 50 44 00
	00		 add	 eax, DWORD PTR [edx+17488]
  002de	8b 8d cc fd ff
	ff		 mov	 ecx, DWORD PTR _hiddenPartitionOffset$27977[ebp+4]
  002e4	13 8a 54 44 00
	00		 adc	 ecx, DWORD PTR [edx+17492]
  002ea	2b 05 62 00 00
	00		 sub	 eax, DWORD PTR _BootArgs+98
  002f0	1b 0d 66 00 00
	00		 sbb	 ecx, DWORD PTR _BootArgs+102
  002f6	8b 55 08	 mov	 edx, DWORD PTR _Extension$[ebp]
  002f9	89 82 a8 00 00
	00		 mov	 DWORD PTR [edx+168], eax
  002ff	89 8a ac 00 00
	00		 mov	 DWORD PTR [edx+172], ecx

; 294  : 			Extension->Queue.RemappedAreaDataUnitOffset = Extension->Queue.CryptoInfo->EncryptedAreaStart.Value / ENCRYPTION_DATA_UNIT_SIZE - BootArgs.DecoySystemPartitionStart / ENCRYPTION_DATA_UNIT_SIZE;

  00305	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  00308	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  0030b	6a 00		 push	 0
  0030d	68 00 02 00 00	 push	 512			; 00000200H
  00312	8b 91 54 44 00
	00		 mov	 edx, DWORD PTR [ecx+17492]
  00318	52		 push	 edx
  00319	8b 81 50 44 00
	00		 mov	 eax, DWORD PTR [ecx+17488]
  0031f	50		 push	 eax
  00320	e8 00 00 00 00	 call	 __aulldiv
  00325	8b f0		 mov	 esi, eax
  00327	8b fa		 mov	 edi, edx
  00329	6a 00		 push	 0
  0032b	68 00 02 00 00	 push	 512			; 00000200H
  00330	8b 0d 66 00 00
	00		 mov	 ecx, DWORD PTR _BootArgs+102
  00336	51		 push	 ecx
  00337	8b 15 62 00 00
	00		 mov	 edx, DWORD PTR _BootArgs+98
  0033d	52		 push	 edx
  0033e	e8 00 00 00 00	 call	 __aulldiv
  00343	2b f0		 sub	 esi, eax
  00345	1b fa		 sbb	 edi, edx
  00347	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  0034a	89 b0 b0 00 00
	00		 mov	 DWORD PTR [eax+176], esi
  00350	89 b8 b4 00 00
	00		 mov	 DWORD PTR [eax+180], edi

; 295  : 			
; 296  : 			Extension->Queue.CryptoInfo->EncryptedAreaStart.Value = BootArgs.DecoySystemPartitionStart;

  00356	8b 4d 08	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00359	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  0035c	a1 62 00 00 00	 mov	 eax, DWORD PTR _BootArgs+98
  00361	89 82 50 44 00
	00		 mov	 DWORD PTR [edx+17488], eax
  00367	8b 0d 66 00 00
	00		 mov	 ecx, DWORD PTR _BootArgs+102
  0036d	89 8a 54 44 00
	00		 mov	 DWORD PTR [edx+17492], ecx

; 297  : 			
; 298  : 			if (Extension->Queue.CryptoInfo->VolumeSize.Value > hiddenPartitionOffset - BootArgs.DecoySystemPartitionStart)

  00373	8b 55 08	 mov	 edx, DWORD PTR _Extension$[ebp]
  00376	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  00379	8b 8d c8 fd ff
	ff		 mov	 ecx, DWORD PTR _hiddenPartitionOffset$27977[ebp]
  0037f	2b 0d 62 00 00
	00		 sub	 ecx, DWORD PTR _BootArgs+98
  00385	8b 95 cc fd ff
	ff		 mov	 edx, DWORD PTR _hiddenPartitionOffset$27977[ebp+4]
  0038b	1b 15 66 00 00
	00		 sbb	 edx, DWORD PTR _BootArgs+102
  00391	89 85 90 fd ff
	ff		 mov	 DWORD PTR tv511[ebp], eax
  00397	89 8d 88 fd ff
	ff		 mov	 DWORD PTR tv512[ebp], ecx
  0039d	89 95 8c fd ff
	ff		 mov	 DWORD PTR tv512[ebp+4], edx
  003a3	8b 85 90 fd ff
	ff		 mov	 eax, DWORD PTR tv511[ebp]
  003a9	8b 88 4c 44 00
	00		 mov	 ecx, DWORD PTR [eax+17484]
  003af	3b 8d 8c fd ff
	ff		 cmp	 ecx, DWORD PTR tv512[ebp+4]
  003b5	72 2c		 jb	 SHORT $LN20@MountDrive
  003b7	77 14		 ja	 SHORT $LN38@MountDrive
  003b9	8b 95 90 fd ff
	ff		 mov	 edx, DWORD PTR tv511[ebp]
  003bf	8b 82 48 44 00
	00		 mov	 eax, DWORD PTR [edx+17480]
  003c5	3b 85 88 fd ff
	ff		 cmp	 eax, DWORD PTR tv512[ebp]
  003cb	76 16		 jbe	 SHORT $LN20@MountDrive
$LN38@MountDrive:

; 299  : 				TC_THROW_FATAL_EXCEPTION;

  003cd	68 43 54 00 00	 push	 21571			; 00005443H
  003d2	6a 00		 push	 0
  003d4	6a 00		 push	 0
  003d6	68 2b 01 00 00	 push	 299			; 0000012bH
  003db	6a 29		 push	 41			; 00000029H
  003dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN20@MountDrive:

; 300  : 
; 301  : 			Dump ("RemappedAreaOffset = %I64d\n", Extension->Queue.RemappedAreaOffset);

  003e3	8b 4d 08	 mov	 ecx, DWORD PTR _Extension$[ebp]
  003e6	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  003ec	52		 push	 edx
  003ed	8b 81 a8 00 00
	00		 mov	 eax, DWORD PTR [ecx+168]
  003f3	50		 push	 eax
  003f4	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@GBKCGBDB@RemappedAreaOffset?5?$DN?5?$CFI64d?6?$AA@FNODOBFM@
  003f9	e8 00 00 00 00	 call	 _DbgPrint
  003fe	83 c4 0c	 add	 esp, 12			; 0000000cH

; 302  : 			Dump ("RemappedAreaDataUnitOffset = %I64d\n", Extension->Queue.RemappedAreaDataUnitOffset);

  00401	8b 4d 08	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00404	8b 91 b4 00 00
	00		 mov	 edx, DWORD PTR [ecx+180]
  0040a	52		 push	 edx
  0040b	8b 81 b0 00 00
	00		 mov	 eax, DWORD PTR [ecx+176]
  00411	50		 push	 eax
  00412	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@NLPFMAEC@RemappedAreaDataUnitOffset?5?$DN?5?$CFI6@FNODOBFM@
  00417	e8 00 00 00 00	 call	 _DbgPrint
  0041c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 303  : 		}
; 304  : 		else

  0041f	eb 1a		 jmp	 SHORT $LN19@MountDrive
$LN21@MountDrive:

; 305  : 		{
; 306  : 			Extension->HiddenSystem = FALSE;

  00421	8b 4d 08	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00424	c7 81 48 02 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+584], 0

; 307  : 			Extension->Queue.RemapEncryptedArea = FALSE;

  0042e	8b 55 08	 mov	 edx, DWORD PTR _Extension$[ebp]
  00431	c7 82 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+164], 0
$LN19@MountDrive:

; 308  : 		}
; 309  : 
; 310  : 		Extension->ConfiguredEncryptedAreaStart = Extension->Queue.CryptoInfo->EncryptedAreaStart.Value;

  0043b	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  0043e	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  00441	8b 55 08	 mov	 edx, DWORD PTR _Extension$[ebp]
  00444	8b 81 50 44 00
	00		 mov	 eax, DWORD PTR [ecx+17488]
  0044a	89 42 30	 mov	 DWORD PTR [edx+48], eax
  0044d	8b 89 54 44 00
	00		 mov	 ecx, DWORD PTR [ecx+17492]
  00453	89 4a 34	 mov	 DWORD PTR [edx+52], ecx

; 311  : 		Extension->ConfiguredEncryptedAreaEnd = Extension->Queue.CryptoInfo->EncryptedAreaStart.Value + Extension->Queue.CryptoInfo->VolumeSize.Value - 1;

  00456	8b 55 08	 mov	 edx, DWORD PTR _Extension$[ebp]
  00459	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  0045c	8b 4d 08	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0045f	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  00462	8b 88 50 44 00
	00		 mov	 ecx, DWORD PTR [eax+17488]
  00468	03 8a 48 44 00
	00		 add	 ecx, DWORD PTR [edx+17480]
  0046e	8b 80 54 44 00
	00		 mov	 eax, DWORD PTR [eax+17492]
  00474	13 82 4c 44 00
	00		 adc	 eax, DWORD PTR [edx+17484]
  0047a	83 e9 01	 sub	 ecx, 1
  0047d	83 d8 00	 sbb	 eax, 0
  00480	8b 55 08	 mov	 edx, DWORD PTR _Extension$[ebp]
  00483	89 4a 38	 mov	 DWORD PTR [edx+56], ecx
  00486	89 42 3c	 mov	 DWORD PTR [edx+60], eax

; 312  : 
; 313  : 		Extension->Queue.EncryptedAreaStart = Extension->Queue.CryptoInfo->EncryptedAreaStart.Value;

  00489	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  0048c	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  0048f	8b 55 08	 mov	 edx, DWORD PTR _Extension$[ebp]
  00492	8b 81 50 44 00
	00		 mov	 eax, DWORD PTR [ecx+17488]
  00498	89 82 90 00 00
	00		 mov	 DWORD PTR [edx+144], eax
  0049e	8b 89 54 44 00
	00		 mov	 ecx, DWORD PTR [ecx+17492]
  004a4	89 8a 94 00 00
	00		 mov	 DWORD PTR [edx+148], ecx

; 314  : 		Extension->Queue.EncryptedAreaEnd = Extension->Queue.CryptoInfo->EncryptedAreaStart.Value + Extension->Queue.CryptoInfo->EncryptedAreaLength.Value - 1;

  004aa	8b 55 08	 mov	 edx, DWORD PTR _Extension$[ebp]
  004ad	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  004b0	8b 4d 08	 mov	 ecx, DWORD PTR _Extension$[ebp]
  004b3	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  004b6	8b 88 50 44 00
	00		 mov	 ecx, DWORD PTR [eax+17488]
  004bc	03 8a 58 44 00
	00		 add	 ecx, DWORD PTR [edx+17496]
  004c2	8b 80 54 44 00
	00		 mov	 eax, DWORD PTR [eax+17492]
  004c8	13 82 5c 44 00
	00		 adc	 eax, DWORD PTR [edx+17500]
  004ce	83 e9 01	 sub	 ecx, 1
  004d1	83 d8 00	 sbb	 eax, 0
  004d4	8b 55 08	 mov	 edx, DWORD PTR _Extension$[ebp]
  004d7	89 8a 98 00 00
	00		 mov	 DWORD PTR [edx+152], ecx
  004dd	89 82 9c 00 00
	00		 mov	 DWORD PTR [edx+156], eax

; 315  : 
; 316  : 		if (Extension->Queue.CryptoInfo->EncryptedAreaLength.Value == 0)

  004e3	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  004e6	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  004e9	89 8d 84 fd ff
	ff		 mov	 DWORD PTR tv576[ebp], ecx
  004ef	8b 95 84 fd ff
	ff		 mov	 edx, DWORD PTR tv576[ebp]
  004f5	8b 85 84 fd ff
	ff		 mov	 eax, DWORD PTR tv576[ebp]
  004fb	8b 8a 58 44 00
	00		 mov	 ecx, DWORD PTR [edx+17496]
  00501	0b 88 5c 44 00
	00		 or	 ecx, DWORD PTR [eax+17500]
  00507	75 2e		 jne	 SHORT $LN18@MountDrive

; 317  : 		{
; 318  : 			Extension->Queue.EncryptedAreaStart = -1;

  00509	8b 55 08	 mov	 edx, DWORD PTR _Extension$[ebp]
  0050c	c7 82 90 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+144], -1
  00516	c7 82 94 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+148], -1

; 319  : 			Extension->Queue.EncryptedAreaEnd = -1;

  00520	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  00523	c7 80 98 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+152], -1
  0052d	c7 80 9c 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+156], -1
$LN18@MountDrive:

; 320  : 		}
; 321  : 
; 322  : 		Dump ("Loaded: ConfiguredEncryptedAreaStart=%I64d (%I64d)  ConfiguredEncryptedAreaEnd=%I64d (%I64d)\n", Extension->ConfiguredEncryptedAreaStart / 1024 / 1024, Extension->ConfiguredEncryptedAreaStart, Extension->ConfiguredEncryptedAreaEnd / 1024 / 1024, Extension->ConfiguredEncryptedAreaEnd);

  00537	8b 4d 08	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0053a	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0053d	52		 push	 edx
  0053e	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00541	50		 push	 eax
  00542	8b 4d 08	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00545	6a 00		 push	 0
  00547	68 00 04 00 00	 push	 1024			; 00000400H
  0054c	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0054f	52		 push	 edx
  00550	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00553	50		 push	 eax
  00554	e8 00 00 00 00	 call	 __alldiv
  00559	6a 00		 push	 0
  0055b	68 00 04 00 00	 push	 1024			; 00000400H
  00560	52		 push	 edx
  00561	50		 push	 eax
  00562	e8 00 00 00 00	 call	 __alldiv
  00567	52		 push	 edx
  00568	50		 push	 eax
  00569	8b 4d 08	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0056c	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  0056f	52		 push	 edx
  00570	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00573	50		 push	 eax
  00574	8b 4d 08	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00577	6a 00		 push	 0
  00579	68 00 04 00 00	 push	 1024			; 00000400H
  0057e	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00581	52		 push	 edx
  00582	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00585	50		 push	 eax
  00586	e8 00 00 00 00	 call	 __alldiv
  0058b	6a 00		 push	 0
  0058d	68 00 04 00 00	 push	 1024			; 00000400H
  00592	52		 push	 edx
  00593	50		 push	 eax
  00594	e8 00 00 00 00	 call	 __alldiv
  00599	52		 push	 edx
  0059a	50		 push	 eax
  0059b	68 00 00 00 00	 push	 OFFSET ??_C@_0FO@PAPPJPK@Loaded?3?5ConfiguredEncryptedAreaS@FNODOBFM@
  005a0	e8 00 00 00 00	 call	 _DbgPrint
  005a5	83 c4 24	 add	 esp, 36			; 00000024H

; 323  : 		Dump ("Loaded: EncryptedAreaStart=%I64d (%I64d)  EncryptedAreaEnd=%I64d (%I64d)\n", Extension->Queue.EncryptedAreaStart / 1024 / 1024, Extension->Queue.EncryptedAreaStart, Extension->Queue.EncryptedAreaEnd / 1024 / 1024, Extension->Queue.EncryptedAreaEnd);

  005a8	8b 4d 08	 mov	 ecx, DWORD PTR _Extension$[ebp]
  005ab	8b 91 9c 00 00
	00		 mov	 edx, DWORD PTR [ecx+156]
  005b1	52		 push	 edx
  005b2	8b 81 98 00 00
	00		 mov	 eax, DWORD PTR [ecx+152]
  005b8	50		 push	 eax
  005b9	8b 4d 08	 mov	 ecx, DWORD PTR _Extension$[ebp]
  005bc	8b 91 98 00 00
	00		 mov	 edx, DWORD PTR [ecx+152]
  005c2	8b 81 9c 00 00
	00		 mov	 eax, DWORD PTR [ecx+156]
  005c8	6a 00		 push	 0
  005ca	68 00 04 00 00	 push	 1024			; 00000400H
  005cf	50		 push	 eax
  005d0	52		 push	 edx
  005d1	e8 00 00 00 00	 call	 __alldiv
  005d6	6a 00		 push	 0
  005d8	68 00 04 00 00	 push	 1024			; 00000400H
  005dd	52		 push	 edx
  005de	50		 push	 eax
  005df	e8 00 00 00 00	 call	 __alldiv
  005e4	52		 push	 edx
  005e5	50		 push	 eax
  005e6	8b 4d 08	 mov	 ecx, DWORD PTR _Extension$[ebp]
  005e9	8b 91 94 00 00
	00		 mov	 edx, DWORD PTR [ecx+148]
  005ef	52		 push	 edx
  005f0	8b 81 90 00 00
	00		 mov	 eax, DWORD PTR [ecx+144]
  005f6	50		 push	 eax
  005f7	8b 4d 08	 mov	 ecx, DWORD PTR _Extension$[ebp]
  005fa	6a 00		 push	 0
  005fc	68 00 04 00 00	 push	 1024			; 00000400H
  00601	8b 91 94 00 00
	00		 mov	 edx, DWORD PTR [ecx+148]
  00607	52		 push	 edx
  00608	8b 81 90 00 00
	00		 mov	 eax, DWORD PTR [ecx+144]
  0060e	50		 push	 eax
  0060f	e8 00 00 00 00	 call	 __alldiv
  00614	6a 00		 push	 0
  00616	68 00 04 00 00	 push	 1024			; 00000400H
  0061b	52		 push	 edx
  0061c	50		 push	 eax
  0061d	e8 00 00 00 00	 call	 __alldiv
  00622	52		 push	 edx
  00623	50		 push	 eax
  00624	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@PHFABMCK@Loaded?3?5EncryptedAreaStart?$DN?$CFI64d@FNODOBFM@
  00629	e8 00 00 00 00	 call	 _DbgPrint
  0062e	83 c4 24	 add	 esp, 36			; 00000024H

; 324  : 
; 325  : 		// Erase boot loader scheduled keys
; 326  : 		if (BootArgs.CryptoInfoLength > 0)

  00631	0f b7 0d 0c 00
	00 00		 movzx	 ecx, WORD PTR _BootArgs+12
  00638	85 c9		 test	 ecx, ecx
  0063a	0f 8e 97 00 00
	00		 jle	 $LN17@MountDrive

; 327  : 		{
; 328  : 			PHYSICAL_ADDRESS cryptoInfoAddress;
; 329  : 			byte *mappedCryptoInfo;
; 330  : 			
; 331  : 			cryptoInfoAddress.QuadPart = (BootLoaderSegment << 4) + BootArgs.CryptoInfoOffset;

  00640	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _BootLoaderSegment
  00647	c1 e0 04	 shl	 eax, 4
  0064a	0f b7 15 0a 00
	00 00		 movzx	 edx, WORD PTR _BootArgs+10
  00651	03 c2		 add	 eax, edx
  00653	99		 cdq
  00654	89 85 b8 fd ff
	ff		 mov	 DWORD PTR _cryptoInfoAddress$27988[ebp], eax
  0065a	89 95 bc fd ff
	ff		 mov	 DWORD PTR _cryptoInfoAddress$27988[ebp+4], edx

; 332  : 			mappedCryptoInfo = MmMapIoSpace (cryptoInfoAddress, BootArgs.CryptoInfoLength, MmCached);

  00660	6a 01		 push	 1
  00662	0f b7 05 0c 00
	00 00		 movzx	 eax, WORD PTR _BootArgs+12
  00669	50		 push	 eax
  0066a	8b 8d bc fd ff
	ff		 mov	 ecx, DWORD PTR _cryptoInfoAddress$27988[ebp+4]
  00670	51		 push	 ecx
  00671	8b 95 b8 fd ff
	ff		 mov	 edx, DWORD PTR _cryptoInfoAddress$27988[ebp]
  00677	52		 push	 edx
  00678	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmMapIoSpace@16
  0067e	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _mappedCryptoInfo$27989[ebp], eax

; 333  : 			
; 334  : 			if (mappedCryptoInfo)

  00684	83 bd c4 fd ff
	ff 00		 cmp	 DWORD PTR _mappedCryptoInfo$27989[ebp], 0
  0068b	74 4a		 je	 SHORT $LN17@MountDrive

; 335  : 			{
; 336  : 				Dump ("Wiping memory %x %d\n", cryptoInfoAddress.LowPart, BootArgs.CryptoInfoLength);

  0068d	0f b7 05 0c 00
	00 00		 movzx	 eax, WORD PTR _BootArgs+12
  00694	50		 push	 eax
  00695	8b 8d b8 fd ff
	ff		 mov	 ecx, DWORD PTR _cryptoInfoAddress$27988[ebp]
  0069b	51		 push	 ecx
  0069c	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@DFBDNCBE@Wiping?5memory?5?$CFx?5?$CFd?6?$AA@FNODOBFM@
  006a1	e8 00 00 00 00	 call	 _DbgPrint
  006a6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 337  : 				memset (mappedCryptoInfo, 0, BootArgs.CryptoInfoLength);

  006a9	0f b7 15 0c 00
	00 00		 movzx	 edx, WORD PTR _BootArgs+12
  006b0	52		 push	 edx
  006b1	6a 00		 push	 0
  006b3	8b 85 c4 fd ff
	ff		 mov	 eax, DWORD PTR _mappedCryptoInfo$27989[ebp]
  006b9	50		 push	 eax
  006ba	e8 00 00 00 00	 call	 _memset
  006bf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 338  : 				MmUnmapIoSpace (mappedCryptoInfo, BootArgs.CryptoInfoLength);

  006c2	0f b7 0d 0c 00
	00 00		 movzx	 ecx, WORD PTR _BootArgs+12
  006c9	51		 push	 ecx
  006ca	8b 95 c4 fd ff
	ff		 mov	 edx, DWORD PTR _mappedCryptoInfo$27989[ebp]
  006d0	52		 push	 edx
  006d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmUnmapIoSpace@8
$LN17@MountDrive:

; 339  : 			}
; 340  : 		}
; 341  : 
; 342  : 		BootDriveFilterExtension = Extension;

  006d7	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  006da	a3 00 00 00 00	 mov	 DWORD PTR _BootDriveFilterExtension, eax

; 343  : 		BootDriveFound = Extension->BootDrive = Extension->DriveMounted = Extension->VolumeHeaderPresent = TRUE;

  006df	8b 4d 08	 mov	 ecx, DWORD PTR _Extension$[ebp]
  006e2	c7 81 2c 02 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+556], 1
  006ec	8b 55 08	 mov	 edx, DWORD PTR _Extension$[ebp]
  006ef	c7 82 30 02 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+560], 1
  006f9	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  006fc	c7 80 28 02 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+552], 1
  00706	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _BootDriveFound, 1

; 344  : 		BootDriveFilterExtension->MagicNumber = TC_BOOT_DRIVE_FILTER_EXTENSION_MAGIC_NUMBER;

  00710	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _BootDriveFilterExtension
  00716	c7 41 10 54 58
	45 42		 mov	 DWORD PTR [ecx+16], 1111840852 ; 42455854H
  0071d	c7 41 14 45 55
	52 54		 mov	 DWORD PTR [ecx+20], 1414681925 ; 54525545H
$LN15@MountDrive:

; 345  : 
; 346  : 		burn (&BootArgs.BootPassword, sizeof (BootArgs.BootPassword));

  00724	c7 85 b0 fd ff
	ff 12 00 00 00	 mov	 DWORD PTR _burnm$27995[ebp], OFFSET _BootArgs+18
  0072e	c7 85 b4 fd ff
	ff 48 00 00 00	 mov	 DWORD PTR _burnc$27997[ebp], 72 ; 00000048H
  00738	6a 48		 push	 72			; 00000048H
  0073a	68 12 00 00 00	 push	 OFFSET _BootArgs+18
  0073f	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN12@MountDrive:
  00744	8b 95 b4 fd ff
	ff		 mov	 edx, DWORD PTR _burnc$27997[ebp]
  0074a	8b 85 b4 fd ff
	ff		 mov	 eax, DWORD PTR _burnc$27997[ebp]
  00750	83 e8 01	 sub	 eax, 1
  00753	89 85 b4 fd ff
	ff		 mov	 DWORD PTR _burnc$27997[ebp], eax
  00759	85 d2		 test	 edx, edx
  0075b	74 1a		 je	 SHORT $LN14@MountDrive
  0075d	8b 8d b0 fd ff
	ff		 mov	 ecx, DWORD PTR _burnm$27995[ebp]
  00763	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00766	8b 95 b0 fd ff
	ff		 mov	 edx, DWORD PTR _burnm$27995[ebp]
  0076c	83 c2 01	 add	 edx, 1
  0076f	89 95 b0 fd ff
	ff		 mov	 DWORD PTR _burnm$27995[ebp], edx
  00775	eb cd		 jmp	 SHORT $LN12@MountDrive
$LN14@MountDrive:
  00777	33 c0		 xor	 eax, eax
  00779	75 a9		 jne	 SHORT $LN15@MountDrive

; 347  : 
; 348  : 		{
; 349  : 			STORAGE_DEVICE_NUMBER storageDeviceNumber;
; 350  : 			status = SendDeviceIoControlRequest (Extension->LowerDeviceObject, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0, &storageDeviceNumber, sizeof (storageDeviceNumber));

  0077b	6a 0c		 push	 12			; 0000000cH
  0077d	8d 8d a4 fd ff
	ff		 lea	 ecx, DWORD PTR _storageDeviceNumber$28001[ebp]
  00783	51		 push	 ecx
  00784	6a 00		 push	 0
  00786	6a 00		 push	 0
  00788	68 80 10 2d 00	 push	 2953344			; 002d1080H
  0078d	8b 55 08	 mov	 edx, DWORD PTR _Extension$[ebp]
  00790	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00793	50		 push	 eax
  00794	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  00799	89 45 e4	 mov	 DWORD PTR _status$[ebp], eax

; 351  : 
; 352  : 			if (!NT_SUCCESS (status))

  0079c	83 7d e4 00	 cmp	 DWORD PTR _status$[ebp], 0
  007a0	7d 1d		 jge	 SHORT $LN10@MountDrive

; 353  : 			{
; 354  : 				Dump ("Failed to get drive number - error %x\n", status);

  007a2	8b 4d e4	 mov	 ecx, DWORD PTR _status$[ebp]
  007a5	51		 push	 ecx
  007a6	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@LNDECHEL@Failed?5to?5get?5drive?5number?5?9?5err@FNODOBFM@
  007ab	e8 00 00 00 00	 call	 _DbgPrint
  007b0	83 c4 08	 add	 esp, 8

; 355  : 				Extension->SystemStorageDeviceNumberValid = FALSE;

  007b3	8b 55 08	 mov	 edx, DWORD PTR _Extension$[ebp]
  007b6	c7 42 28 00 00
	00 00		 mov	 DWORD PTR [edx+40], 0

; 356  : 			}
; 357  : 			else

  007bd	eb 16		 jmp	 SHORT $LN9@MountDrive
$LN10@MountDrive:

; 358  : 			{
; 359  : 				Extension->SystemStorageDeviceNumber = storageDeviceNumber.DeviceNumber;

  007bf	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  007c2	8b 8d a8 fd ff
	ff		 mov	 ecx, DWORD PTR _storageDeviceNumber$28001[ebp+4]
  007c8	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 360  : 				Extension->SystemStorageDeviceNumberValid = TRUE;

  007cb	8b 55 08	 mov	 edx, DWORD PTR _Extension$[ebp]
  007ce	c7 42 28 01 00
	00 00		 mov	 DWORD PTR [edx+40], 1
$LN9@MountDrive:

; 361  : 			}
; 362  : 		}
; 363  : 
; 364  : 		status = SendDeviceIoControlRequest (Extension->LowerDeviceObject, IOCTL_DISK_GET_LENGTH_INFO, NULL, 0, &BootDriveLength, sizeof (BootDriveLength));

  007d5	6a 08		 push	 8
  007d7	68 00 00 00 00	 push	 OFFSET _BootDriveLength
  007dc	6a 00		 push	 0
  007de	6a 00		 push	 0
  007e0	68 5c 40 07 00	 push	 475228			; 0007405cH
  007e5	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  007e8	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  007eb	51		 push	 ecx
  007ec	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  007f1	89 45 e4	 mov	 DWORD PTR _status$[ebp], eax

; 365  : 		
; 366  : 		if (!NT_SUCCESS (status))

  007f4	83 7d e4 00	 cmp	 DWORD PTR _status$[ebp], 0
  007f8	7d 3e		 jge	 SHORT $LN8@MountDrive

; 367  : 		{
; 368  : 			Dump ("Failed to get drive length - error %x\n", status);

  007fa	8b 55 e4	 mov	 edx, DWORD PTR _status$[ebp]
  007fd	52		 push	 edx
  007fe	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@IHPMFJGA@Failed?5to?5get?5drive?5length?5?9?5err@FNODOBFM@
  00803	e8 00 00 00 00	 call	 _DbgPrint
  00808	83 c4 08	 add	 esp, 8

; 369  : 			BootDriveLength.QuadPart = 0;

  0080b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _BootDriveLength, 0
  00815	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _BootDriveLength+4, 0

; 370  : 			Extension->Queue.MaxReadAheadOffset.QuadPart = 0;

  0081f	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  00822	c7 80 c0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+448], 0
  0082c	c7 80 c4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+452], 0

; 371  : 		}
; 372  : 		else

  00836	eb 1a		 jmp	 SHORT $LN7@MountDrive
$LN8@MountDrive:

; 373  : 			Extension->Queue.MaxReadAheadOffset = BootDriveLength;

  00838	8b 4d 08	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0083b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _BootDriveLength
  00841	89 91 c0 01 00
	00		 mov	 DWORD PTR [ecx+448], edx
  00847	a1 04 00 00 00	 mov	 eax, DWORD PTR _BootDriveLength+4
  0084c	89 81 c4 01 00
	00		 mov	 DWORD PTR [ecx+452], eax
$LN7@MountDrive:

; 374  : 		
; 375  : 		status = EncryptedIoQueueStart (&Extension->Queue);

  00852	8b 4d 08	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00855	83 c1 48	 add	 ecx, 72			; 00000048H
  00858	51		 push	 ecx
  00859	e8 00 00 00 00	 call	 _EncryptedIoQueueStart@4
  0085e	89 45 e4	 mov	 DWORD PTR _status$[ebp], eax

; 376  : 		if (!NT_SUCCESS (status))

  00861	83 7d e4 00	 cmp	 DWORD PTR _status$[ebp], 0
  00865	7d 18		 jge	 SHORT $LN6@MountDrive

; 377  : 			TC_BUG_CHECK (status);

  00867	68 43 54 00 00	 push	 21571			; 00005443H
  0086c	6a 00		 push	 0
  0086e	8b 55 e4	 mov	 edx, DWORD PTR _status$[ebp]
  00871	52		 push	 edx
  00872	68 79 01 00 00	 push	 377			; 00000179H
  00877	6a 29		 push	 41			; 00000029H
  00879	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN6@MountDrive:

; 378  : 
; 379  : 		if (IsOSAtLeast (WIN_VISTA))

  0087f	6a 0b		 push	 11			; 0000000bH
  00881	e8 00 00 00 00	 call	 _IsOSAtLeast@4
  00886	85 c0		 test	 eax, eax
  00888	74 16		 je	 SHORT $LN5@MountDrive

; 380  : 		{
; 381  : 			CrashDumpEnabled = TRUE;

  0088a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CrashDumpEnabled, 1

; 382  : 			HibernationEnabled = TRUE;

  00894	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _HibernationEnabled, 1
  0089e	eb 0e		 jmp	 SHORT $LN4@MountDrive
$LN5@MountDrive:

; 383  : 		}
; 384  : 		else if (!LegacyHibernationDriverFilterActive)

  008a0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _LegacyHibernationDriverFilterActive, 0
  008a7	75 05		 jne	 SHORT $LN4@MountDrive

; 385  : 			StartLegacyHibernationDriverFilter();

  008a9	e8 00 00 00 00	 call	 _StartLegacyHibernationDriverFilter@0
$LN4@MountDrive:

; 386  : 
; 387  : 		// Hidden system hibernation is not supported if an extra boot partition is present as the system is not allowed to update the boot partition
; 388  : 		if (IsHiddenSystemRunning() && (BootArgs.Flags & TC_BOOT_ARGS_FLAG_EXTRA_BOOT_PARTITION))

  008ae	e8 00 00 00 00	 call	 _IsHiddenSystemRunning@0
  008b3	85 c0		 test	 eax, eax
  008b5	74 1e		 je	 SHORT $LN2@MountDrive
  008b7	a1 6a 00 00 00	 mov	 eax, DWORD PTR _BootArgs+106
  008bc	83 e0 01	 and	 eax, 1
  008bf	74 14		 je	 SHORT $LN2@MountDrive

; 389  : 		{
; 390  : 			CrashDumpEnabled = FALSE;

  008c1	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CrashDumpEnabled, 0

; 391  : 			HibernationEnabled = FALSE;

  008cb	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _HibernationEnabled, 0
$LN2@MountDrive:

; 392  : 		}
; 393  : 	}
; 394  : 	else

  008d5	eb 30		 jmp	 SHORT $ret$27966
$LN22@MountDrive:

; 395  : 	{
; 396  : 		Dump ("Header not decrypted\n");

  008d7	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@CKLJIMPP@Header?5not?5decrypted?6?$AA@FNODOBFM@
  008dc	e8 00 00 00 00	 call	 _DbgPrint
  008e1	83 c4 04	 add	 esp, 4

; 397  : 		crypto_close (Extension->HeaderCryptoInfo);

  008e4	8b 4d 08	 mov	 ecx, DWORD PTR _Extension$[ebp]
  008e7	8b 91 44 02 00
	00		 mov	 edx, DWORD PTR [ecx+580]
  008ed	52		 push	 edx
  008ee	e8 00 00 00 00	 call	 _crypto_close@4

; 398  : 		Extension->HeaderCryptoInfo = NULL;

  008f3	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  008f6	c7 80 44 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+580], 0

; 399  : 
; 400  : 		status = STATUS_UNSUCCESSFUL;

  00900	c7 45 e4 01 00
	00 c0		 mov	 DWORD PTR _status$[ebp], -1073741823 ; c0000001H
$ret$27966:

; 401  : 	}
; 402  : 
; 403  : ret:
; 404  : 	TCfree (header);

  00907	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0090c	8b 4d e0	 mov	 ecx, DWORD PTR _header$[ebp]
  0090f	51		 push	 ecx
  00910	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 405  : 	return status;

  00916	8b 45 e4	 mov	 eax, DWORD PTR _status$[ebp]
$LN31@MountDrive:

; 406  : }

  00919	5f		 pop	 edi
  0091a	5e		 pop	 esi
  0091b	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0091e	33 cd		 xor	 ecx, ebp
  00920	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00925	8b e5		 mov	 esp, ebp
  00927	5d		 pop	 ebp
  00928	c2 0c 00	 ret	 12			; 0000000cH
_MountDrive@12 ENDP
; Function compile flags: /Odtp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT _RtlSecureZeroMemory@8
_TEXT	SEGMENT
_vptr$ = -4						; size = 4
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory@8 PROC				; COMDAT

; 8322 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 8323 :     volatile char *vptr = (volatile char *)ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _vptr$[ebp], eax
$LN2@RtlSecureZ:

; 8324 : 
; 8325 : #if defined(_M_AMD64)
; 8326 : 
; 8327 :         __stosb((PUCHAR)((ULONG64)vptr), 0, cnt);
; 8328 : 
; 8329 : #else
; 8330 : 
; 8331 :     while (cnt) {

  0000c	83 7d 0c 00	 cmp	 DWORD PTR _cnt$[ebp], 0
  00010	74 1a		 je	 SHORT $LN1@RtlSecureZ

; 8332 :         *vptr = 0;

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _vptr$[ebp]
  00015	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 8333 :         vptr++;

  00018	8b 55 fc	 mov	 edx, DWORD PTR _vptr$[ebp]
  0001b	83 c2 01	 add	 edx, 1
  0001e	89 55 fc	 mov	 DWORD PTR _vptr$[ebp], edx

; 8334 :         cnt--;

  00021	8b 45 0c	 mov	 eax, DWORD PTR _cnt$[ebp]
  00024	83 e8 01	 sub	 eax, 1
  00027	89 45 0c	 mov	 DWORD PTR _cnt$[ebp], eax

; 8335 :     }

  0002a	eb e0		 jmp	 SHORT $LN2@RtlSecureZ
$LN1@RtlSecureZ:

; 8336 : 
; 8337 : #endif
; 8338 : 
; 8339 :     return ptr;

  0002c	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]

; 8340 : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
_RtlSecureZeroMemory@8 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp
; File c:\users\public\desktop\projects\ciphershed\src\driver\drivefilter.c
;	COMDAT _IsVolumeDevice@4
_TEXT	SEGMENT
tv146 = -100						; size = 4
_volNumber$ = -96					; size = 20
__$ArrayPad$ = -76					; size = 4
_extents$ = -72						; size = 64
_extentStatus$ = -4					; size = 4
_deviceObject$ = 8					; size = 4
_IsVolumeDevice@4 PROC					; COMDAT

; 510  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 64	 sub	 esp, 100		; 00000064H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 b4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 511  : 	VOLUME_NUMBER volNumber;
; 512  : 	VOLUME_DISK_EXTENTS extents[2];
; 513  : 	NTSTATUS extentStatus = SendDeviceIoControlRequest (deviceObject, IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS, NULL, 0, extents, sizeof (extents));

  00012	6a 40		 push	 64			; 00000040H
  00014	8d 45 b8	 lea	 eax, DWORD PTR _extents$[ebp]
  00017	50		 push	 eax
  00018	6a 00		 push	 0
  0001a	6a 00		 push	 0
  0001c	68 00 00 56 00	 push	 5636096			; 00560000H
  00021	8b 4d 08	 mov	 ecx, DWORD PTR _deviceObject$[ebp]
  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  0002a	89 45 fc	 mov	 DWORD PTR _extentStatus$[ebp], eax

; 514  : 
; 515  : 	return NT_SUCCESS (SendDeviceIoControlRequest (deviceObject, IOCTL_VOLUME_SUPPORTS_ONLINE_OFFLINE, NULL, 0,  NULL, 0))
; 516  : 		|| NT_SUCCESS (SendDeviceIoControlRequest (deviceObject, IOCTL_VOLUME_IS_OFFLINE, NULL, 0,  NULL, 0))
; 517  : 		|| NT_SUCCESS (SendDeviceIoControlRequest (deviceObject, IOCTL_VOLUME_IS_IO_CAPABLE, NULL, 0,  NULL, 0))
; 518  : 		|| NT_SUCCESS (SendDeviceIoControlRequest (deviceObject, IOCTL_VOLUME_IS_PARTITION, NULL, 0,  NULL, 0))
; 519  : 		|| NT_SUCCESS (SendDeviceIoControlRequest (deviceObject, IOCTL_VOLUME_QUERY_VOLUME_NUMBER, NULL, 0, &volNumber, sizeof (volNumber)))
; 520  : 		|| NT_SUCCESS (extentStatus) || extentStatus == STATUS_BUFFER_OVERFLOW || extentStatus == STATUS_BUFFER_TOO_SMALL;

  0002d	6a 00		 push	 0
  0002f	6a 00		 push	 0
  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	68 04 00 56 00	 push	 5636100			; 00560004H
  0003a	8b 55 08	 mov	 edx, DWORD PTR _deviceObject$[ebp]
  0003d	52		 push	 edx
  0003e	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  00043	85 c0		 test	 eax, eax
  00045	0f 8d 8b 00 00
	00		 jge	 $LN3@IsVolumeDe
  0004b	6a 00		 push	 0
  0004d	6a 00		 push	 0
  0004f	6a 00		 push	 0
  00051	6a 00		 push	 0
  00053	68 10 00 56 00	 push	 5636112			; 00560010H
  00058	8b 45 08	 mov	 eax, DWORD PTR _deviceObject$[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  00061	85 c0		 test	 eax, eax
  00063	7d 71		 jge	 SHORT $LN3@IsVolumeDe
  00065	6a 00		 push	 0
  00067	6a 00		 push	 0
  00069	6a 00		 push	 0
  0006b	6a 00		 push	 0
  0006d	68 14 00 56 00	 push	 5636116			; 00560014H
  00072	8b 4d 08	 mov	 ecx, DWORD PTR _deviceObject$[ebp]
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  0007b	85 c0		 test	 eax, eax
  0007d	7d 57		 jge	 SHORT $LN3@IsVolumeDe
  0007f	6a 00		 push	 0
  00081	6a 00		 push	 0
  00083	6a 00		 push	 0
  00085	6a 00		 push	 0
  00087	68 28 00 56 00	 push	 5636136			; 00560028H
  0008c	8b 55 08	 mov	 edx, DWORD PTR _deviceObject$[ebp]
  0008f	52		 push	 edx
  00090	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  00095	85 c0		 test	 eax, eax
  00097	7d 3d		 jge	 SHORT $LN3@IsVolumeDe
  00099	6a 14		 push	 20			; 00000014H
  0009b	8d 45 a0	 lea	 eax, DWORD PTR _volNumber$[ebp]
  0009e	50		 push	 eax
  0009f	6a 00		 push	 0
  000a1	6a 00		 push	 0
  000a3	68 1c 00 56 00	 push	 5636124			; 0056001cH
  000a8	8b 4d 08	 mov	 ecx, DWORD PTR _deviceObject$[ebp]
  000ab	51		 push	 ecx
  000ac	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  000b1	85 c0		 test	 eax, eax
  000b3	7d 21		 jge	 SHORT $LN3@IsVolumeDe
  000b5	83 7d fc 00	 cmp	 DWORD PTR _extentStatus$[ebp], 0
  000b9	7d 1b		 jge	 SHORT $LN3@IsVolumeDe
  000bb	81 7d fc 05 00
	00 80		 cmp	 DWORD PTR _extentStatus$[ebp], -2147483643 ; 80000005H
  000c2	74 12		 je	 SHORT $LN3@IsVolumeDe
  000c4	81 7d fc 23 00
	00 c0		 cmp	 DWORD PTR _extentStatus$[ebp], -1073741789 ; c0000023H
  000cb	74 09		 je	 SHORT $LN3@IsVolumeDe
  000cd	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv146[ebp], 0
  000d4	eb 07		 jmp	 SHORT $LN4@IsVolumeDe
$LN3@IsVolumeDe:
  000d6	c7 45 9c 01 00
	00 00		 mov	 DWORD PTR tv146[ebp], 1
$LN4@IsVolumeDe:
  000dd	8b 45 9c	 mov	 eax, DWORD PTR tv146[ebp]

; 521  : }

  000e0	8b 4d b4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e3	33 cd		 xor	 ecx, ebp
  000e5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c2 04 00	 ret	 4
_IsVolumeDevice@4 ENDP
_TEXT	ENDS
EXTRN	__imp__KeSetEvent@12:PROC
; Function compile flags: /Odtp
;	COMDAT _MountDriveWorkItemRoutine@8
_TEXT	SEGMENT
_deviceObject$ = 8					; size = 4
_filterExtension$ = 12					; size = 4
_MountDriveWorkItemRoutine@8 PROC			; COMDAT

; 555  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 556  : 	CheckDeviceTypeAndMount (filterExtension);

  00005	8b 45 0c	 mov	 eax, DWORD PTR _filterExtension$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _CheckDeviceTypeAndMount@4

; 557  : 	KeSetEvent (&filterExtension->MountWorkItemCompletedEvent, IO_NO_INCREMENT, FALSE);

  0000e	6a 00		 push	 0
  00010	6a 00		 push	 0
  00012	8b 4d 0c	 mov	 ecx, DWORD PTR _filterExtension$[ebp]
  00015	81 c1 34 02 00
	00		 add	 ecx, 564		; 00000234H
  0001b	51		 push	 ecx
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 558  : }

  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
_MountDriveWorkItemRoutine@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@JHMIFAKG@IRP_MJ_POWER?5minor?$DN?$CFd?5type?$DN?$CFd?5sh@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp__PoCallDriver@8:PROC
EXTRN	__imp__PoStartNextPowerIrp@4:PROC
EXTRN	_RootDeviceObject:DWORD
;	COMDAT ??_C@_0CL@JHMIFAKG@IRP_MJ_POWER?5minor?$DN?$CFd?5type?$DN?$CFd?5sh@FNODOBFM@
text$s	SEGMENT
??_C@_0CL@JHMIFAKG@IRP_MJ_POWER?5minor?$DN?$CFd?5type?$DN?$CFd?5sh@FNODOBFM@ DB 'I'
	DB	'RP_MJ_POWER minor=%d type=%d shutdown=%d', 0aH, 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _DispatchPower@16
_TEXT	SEGMENT
_status$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_Extension$ = 16					; size = 4
_irpSp$ = 20						; size = 4
_DispatchPower@16 PROC					; COMDAT

; 671  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 672  : 	NTSTATUS status;
; 673  : 	Dump ("IRP_MJ_POWER minor=%d type=%d shutdown=%d\n", (int) irpSp->MinorFunction, (int) irpSp->Parameters.Power.Type, (int) irpSp->Parameters.Power.ShutdownType);

  00006	8b 45 14	 mov	 eax, DWORD PTR _irpSp$[ebp]
  00009	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000c	51		 push	 ecx
  0000d	8b 55 14	 mov	 edx, DWORD PTR _irpSp$[ebp]
  00010	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00013	50		 push	 eax
  00014	8b 4d 14	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  00017	0f b6 51 01	 movzx	 edx, BYTE PTR [ecx+1]
  0001b	52		 push	 edx
  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@JHMIFAKG@IRP_MJ_POWER?5minor?$DN?$CFd?5type?$DN?$CFd?5sh@FNODOBFM@
  00021	e8 00 00 00 00	 call	 _DbgPrint
  00026	83 c4 10	 add	 esp, 16			; 00000010H

; 674  : 
; 675  : 	if (SetupInProgress
; 676  : 		&& irpSp->MinorFunction == IRP_MN_SET_POWER
; 677  : 		&& irpSp->Parameters.Power.ShutdownType == PowerActionHibernate)

  00029	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SetupInProgress, 0
  00030	74 36		 je	 SHORT $LN4@DispatchPo
  00032	8b 45 14	 mov	 eax, DWORD PTR _irpSp$[ebp]
  00035	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00039	83 f9 02	 cmp	 ecx, 2
  0003c	75 2a		 jne	 SHORT $LN4@DispatchPo
  0003e	8b 55 14	 mov	 edx, DWORD PTR _irpSp$[ebp]
  00041	83 7a 10 03	 cmp	 DWORD PTR [edx+16], 3
  00045	75 21		 jne	 SHORT $LN4@DispatchPo
$LN3@DispatchPo:

; 678  : 	{
; 679  : 		while (SendDeviceIoControlRequest (RootDeviceObject, TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP, NULL, 0, NULL, 0) == STATUS_INSUFFICIENT_RESOURCES);

  00047	6a 00		 push	 0
  00049	6a 00		 push	 0
  0004b	6a 00		 push	 0
  0004d	6a 00		 push	 0
  0004f	68 50 20 22 00	 push	 2236496			; 00222050H
  00054	a1 00 00 00 00	 mov	 eax, DWORD PTR _RootDeviceObject
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  0005f	3d 9a 00 00 c0	 cmp	 eax, -1073741670	; c000009aH
  00064	75 02		 jne	 SHORT $LN4@DispatchPo
  00066	eb df		 jmp	 SHORT $LN3@DispatchPo
$LN4@DispatchPo:

; 680  : 	}
; 681  : 
; 682  : #if 0	// Dismount of the system drive is disabled until there is a way to do it without causing system errors (see the documentation for more info)
; 683  : 	if (DriverShuttingDown
; 684  : 		&& Extension->BootDrive
; 685  : 		&& Extension->DriveMounted
; 686  : 		&& irpSp->MinorFunction == IRP_MN_SET_POWER
; 687  : 		&& irpSp->Parameters.Power.Type == DevicePowerState)
; 688  : 	{
; 689  : 		DismountDrive (Extension, TRUE);
; 690  : 	}
; 691  : #endif // 0
; 692  : 
; 693  : 	PoStartNextPowerIrp (Irp);

  00068	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  0006b	51		 push	 ecx
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoStartNextPowerIrp@4

; 694  : 
; 695  : 	status = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00072	6a 58		 push	 88			; 00000058H
  00074	68 b7 02 00 00	 push	 695			; 000002b7H
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@GDHJGIB@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  0007e	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  00081	52		 push	 edx
  00082	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  00085	05 b8 00 00 00	 add	 eax, 184		; 000000b8H
  0008a	50		 push	 eax
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAcquireRemoveLockEx@20
  00091	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 696  : 	if (!NT_SUCCESS (status))

  00094	83 7d fc 00	 cmp	 DWORD PTR _status$[ebp], 0
  00098	7d 11		 jge	 SHORT $LN1@DispatchPo

; 697  : 		return TCCompleteIrp (Irp, status, 0);

  0009a	6a 00		 push	 0
  0009c	8b 4d fc	 mov	 ecx, DWORD PTR _status$[ebp]
  0009f	51		 push	 ecx
  000a0	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  000a3	52		 push	 edx
  000a4	e8 00 00 00 00	 call	 _TCCompleteIrp@12
  000a9	eb 36		 jmp	 SHORT $LN5@DispatchPo
$LN1@DispatchPo:

; 698  : 
; 699  : 	IoSkipCurrentIrpStackLocation (Irp);

  000ab	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 _IoSkipCurrentIrpStackLocation@4

; 700  : 	status = PoCallDriver (Extension->LowerDeviceObject, Irp);

  000b4	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  000b7	51		 push	 ecx
  000b8	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  000bb	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000be	50		 push	 eax
  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoCallDriver@8
  000c5	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 701  : 
; 702  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  000c8	6a 58		 push	 88			; 00000058H
  000ca	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  000cd	51		 push	 ecx
  000ce	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  000d1	81 c2 b8 00 00
	00		 add	 edx, 184		; 000000b8H
  000d7	52		 push	 edx
  000d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 703  : 	return status;

  000de	8b 45 fc	 mov	 eax, DWORD PTR _status$[ebp]
$LN5@DispatchPo:

; 704  : }

  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c2 10 00	 ret	 16			; 00000010H
_DispatchPower@16 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@GFCPIAML@Header?5not?5reopened?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BB@DLMCDLIB@Header?5reopened?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_PsGetCurrentThread@0
PUBLIC	_ReopenBootVolumeHeader@8
EXTRN	_ValidateIOBufferSize@12:PROC
EXTRN	_UserCanAccessDriveDevice@0:PROC
EXTRN	__imp__IoIsSystemThread@4:PROC
;	COMDAT ??_C@_0BF@GFCPIAML@Header?5not?5reopened?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BF@GFCPIAML@Header?5not?5reopened?6?$AA@FNODOBFM@ DB 'Header not r'
	DB	'eopened', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BB@DLMCDLIB@Header?5reopened?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BB@DLMCDLIB@Header?5reopened?6?$AA@FNODOBFM@ DB 'Header reopened', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _ReopenBootVolumeHeader@8
_TEXT	SEGMENT
_burnm$28288 = -24					; size = 4
_burnc$28290 = -20					; size = 4
_header$ = -16						; size = 4
_request$ = -12						; size = 4
_offset$ = -8						; size = 8
_irp$ = 8						; size = 4
_irpSp$ = 12						; size = 4
_ReopenBootVolumeHeader@8 PROC				; COMDAT

; 749  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 18	 sub	 esp, 24			; 00000018H

; 750  : 	LARGE_INTEGER offset;
; 751  : 	char *header;
; 752  : 	ReopenBootVolumeHeaderRequest *request = (ReopenBootVolumeHeaderRequest *) irp->AssociatedIrp.SystemBuffer;

  00008	8b 45 08	 mov	 eax, DWORD PTR _irp$[ebp]
  0000b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0000e	89 4d f4	 mov	 DWORD PTR _request$[ebp], ecx

; 753  : 
; 754  : 	irp->IoStatus.Information = 0;

  00011	8b 55 08	 mov	 edx, DWORD PTR _irp$[ebp]
  00014	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 755  : 
; 756  : 	if (!IoIsSystemThread (PsGetCurrentThread()) && !UserCanAccessDriveDevice())

  0001b	e8 00 00 00 00	 call	 _PsGetCurrentThread@0
  00020	50		 push	 eax
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoIsSystemThread@4
  00027	0f b6 c0	 movzx	 eax, al
  0002a	85 c0		 test	 eax, eax
  0002c	75 18		 jne	 SHORT $LN15@ReopenBoot
  0002e	e8 00 00 00 00	 call	 _UserCanAccessDriveDevice@0
  00033	85 c0		 test	 eax, eax
  00035	75 0f		 jne	 SHORT $LN15@ReopenBoot

; 757  : 	{
; 758  : 		irp->IoStatus.Status = STATUS_ACCESS_DENIED;

  00037	8b 4d 08	 mov	 ecx, DWORD PTR _irp$[ebp]
  0003a	c7 41 18 22 00
	00 c0		 mov	 DWORD PTR [ecx+24], -1073741790 ; c0000022H

; 759  : 		return;

  00041	e9 46 02 00 00	 jmp	 $LN16@ReopenBoot
$LN15@ReopenBoot:

; 760  : 	}
; 761  : 
; 762  : 	if (!ValidateIOBufferSize (irp, sizeof (ReopenBootVolumeHeaderRequest), ValidateInput))

  00046	6a 00		 push	 0
  00048	6a 48		 push	 72			; 00000048H
  0004a	8b 55 08	 mov	 edx, DWORD PTR _irp$[ebp]
  0004d	52		 push	 edx
  0004e	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00053	85 c0		 test	 eax, eax
  00055	75 05		 jne	 SHORT $LN14@ReopenBoot

; 763  : 		return;

  00057	e9 30 02 00 00	 jmp	 $LN16@ReopenBoot
$LN14@ReopenBoot:

; 764  : 
; 765  : 	if (!BootDriveFound || !BootDriveFilterExtension || !BootDriveFilterExtension->DriveMounted || !BootDriveFilterExtension->HeaderCryptoInfo
; 766  : 		|| request->VolumePassword.Length > MAX_PASSWORD)

  0005c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _BootDriveFound, 0
  00063	74 2e		 je	 SHORT $LN12@ReopenBoot
  00065	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _BootDriveFilterExtension, 0
  0006c	74 25		 je	 SHORT $LN12@ReopenBoot
  0006e	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  00073	83 b8 30 02 00
	00 00		 cmp	 DWORD PTR [eax+560], 0
  0007a	74 17		 je	 SHORT $LN12@ReopenBoot
  0007c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _BootDriveFilterExtension
  00082	83 b9 44 02 00
	00 00		 cmp	 DWORD PTR [ecx+580], 0
  00089	74 08		 je	 SHORT $LN12@ReopenBoot
  0008b	8b 55 f4	 mov	 edx, DWORD PTR _request$[ebp]
  0008e	83 3a 40	 cmp	 DWORD PTR [edx], 64	; 00000040H
  00091	76 0f		 jbe	 SHORT $LN13@ReopenBoot
$LN12@ReopenBoot:

; 767  : 	{
; 768  : 		irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  00093	8b 45 08	 mov	 eax, DWORD PTR _irp$[ebp]
  00096	c7 40 18 0d 00
	00 c0		 mov	 DWORD PTR [eax+24], -1073741811 ; c000000dH

; 769  : 		goto wipe;

  0009d	e9 ad 01 00 00	 jmp	 $wipe$28268
$LN13@ReopenBoot:

; 770  : 	}
; 771  : 
; 772  : 	header = TCalloc (TC_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE);

  000a2	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  000a7	68 00 02 00 00	 push	 512			; 00000200H
  000ac	6a 00		 push	 0
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  000b4	89 45 f0	 mov	 DWORD PTR _header$[ebp], eax

; 773  : 	if (!header)

  000b7	83 7d f0 00	 cmp	 DWORD PTR _header$[ebp], 0
  000bb	75 0f		 jne	 SHORT $LN11@ReopenBoot

; 774  : 	{
; 775  : 		irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

  000bd	8b 4d 08	 mov	 ecx, DWORD PTR _irp$[ebp]
  000c0	c7 41 18 9a 00
	00 c0		 mov	 DWORD PTR [ecx+24], -1073741670 ; c000009aH

; 776  : 		goto wipe;

  000c7	e9 83 01 00 00	 jmp	 $wipe$28268
$LN11@ReopenBoot:

; 777  : 	}
; 778  : 
; 779  : 	if (BootDriveFilterExtension->HiddenSystem)

  000cc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _BootDriveFilterExtension
  000d2	83 ba 48 02 00
	00 00		 cmp	 DWORD PTR [edx+584], 0
  000d9	74 1b		 je	 SHORT $LN10@ReopenBoot

; 780  : 		offset.QuadPart = BootArgs.HiddenSystemPartitionStart + TC_HIDDEN_VOLUME_HEADER_OFFSET;

  000db	a1 5a 00 00 00	 mov	 eax, DWORD PTR _BootArgs+90
  000e0	05 00 00 01 00	 add	 eax, 65536		; 00010000H
  000e5	8b 0d 5e 00 00
	00		 mov	 ecx, DWORD PTR _BootArgs+94
  000eb	83 d1 00	 adc	 ecx, 0
  000ee	89 45 f8	 mov	 DWORD PTR _offset$[ebp], eax
  000f1	89 4d fc	 mov	 DWORD PTR _offset$[ebp+4], ecx

; 781  : 	else

  000f4	eb 0e		 jmp	 SHORT $LN9@ReopenBoot
$LN10@ReopenBoot:

; 782  : 		offset.QuadPart = TC_BOOT_VOLUME_HEADER_SECTOR_OFFSET;

  000f6	c7 45 f8 00 7c
	00 00		 mov	 DWORD PTR _offset$[ebp], 31744 ; 00007c00H
  000fd	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _offset$[ebp+4], 0
$LN9@ReopenBoot:

; 783  : 
; 784  : 	irp->IoStatus.Status = TCReadDevice (BootDriveFilterExtension->LowerDeviceObject, header, offset, TC_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE);

  00104	68 00 02 00 00	 push	 512			; 00000200H
  00109	8b 55 fc	 mov	 edx, DWORD PTR _offset$[ebp+4]
  0010c	52		 push	 edx
  0010d	8b 45 f8	 mov	 eax, DWORD PTR _offset$[ebp]
  00110	50		 push	 eax
  00111	8b 4d f0	 mov	 ecx, DWORD PTR _header$[ebp]
  00114	51		 push	 ecx
  00115	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _BootDriveFilterExtension
  0011b	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 _TCReadDevice@20
  00124	8b 4d 08	 mov	 ecx, DWORD PTR _irp$[ebp]
  00127	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 785  : 	if (!NT_SUCCESS (irp->IoStatus.Status))

  0012a	8b 55 08	 mov	 edx, DWORD PTR _irp$[ebp]
  0012d	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  00131	7d 19		 jge	 SHORT $LN8@ReopenBoot

; 786  : 	{
; 787  : 		Dump ("TCReadDevice error %x\n", irp->IoStatus.Status);

  00133	8b 45 08	 mov	 eax, DWORD PTR _irp$[ebp]
  00136	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00139	51		 push	 ecx
  0013a	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@FBDKNNGH@TCReadDevice?5error?5?$CFx?6?$AA@FNODOBFM@
  0013f	e8 00 00 00 00	 call	 _DbgPrint
  00144	83 c4 08	 add	 esp, 8

; 788  : 		goto ret;

  00147	e9 f4 00 00 00	 jmp	 $ret$28276
$LN8@ReopenBoot:

; 789  : 	}
; 790  : 
; 791  : 	if (ReadVolumeHeader (!BootDriveFilterExtension->HiddenSystem, header, &request->VolumePassword, NULL, BootDriveFilterExtension->HeaderCryptoInfo) == 0)

  0014c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _BootDriveFilterExtension
  00152	8b 82 44 02 00
	00		 mov	 eax, DWORD PTR [edx+580]
  00158	50		 push	 eax
  00159	6a 00		 push	 0
  0015b	8b 4d f4	 mov	 ecx, DWORD PTR _request$[ebp]
  0015e	51		 push	 ecx
  0015f	8b 55 f0	 mov	 edx, DWORD PTR _header$[ebp]
  00162	52		 push	 edx
  00163	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  00168	33 c9		 xor	 ecx, ecx
  0016a	83 b8 48 02 00
	00 00		 cmp	 DWORD PTR [eax+584], 0
  00171	0f 94 c1	 sete	 cl
  00174	51		 push	 ecx
  00175	e8 00 00 00 00	 call	 _ReadVolumeHeader@20
  0017a	85 c0		 test	 eax, eax
  0017c	0f 85 86 00 00
	00		 jne	 $LN7@ReopenBoot

; 792  : 	{
; 793  : 		Dump ("Header reopened\n");

  00182	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@DLMCDLIB@Header?5reopened?6?$AA@FNODOBFM@
  00187	e8 00 00 00 00	 call	 _DbgPrint
  0018c	83 c4 04	 add	 esp, 4

; 794  : 		
; 795  : 		BootDriveFilterExtension->Queue.CryptoInfo->header_creation_time = BootDriveFilterExtension->HeaderCryptoInfo->header_creation_time;

  0018f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _BootDriveFilterExtension
  00195	8b 82 44 02 00
	00		 mov	 eax, DWORD PTR [edx+580]
  0019b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _BootDriveFilterExtension
  001a1	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  001a4	8b 88 f8 43 00
	00		 mov	 ecx, DWORD PTR [eax+17400]
  001aa	89 8a f8 43 00
	00		 mov	 DWORD PTR [edx+17400], ecx
  001b0	8b 80 fc 43 00
	00		 mov	 eax, DWORD PTR [eax+17404]
  001b6	89 82 fc 43 00
	00		 mov	 DWORD PTR [edx+17404], eax

; 796  : 		BootDriveFilterExtension->Queue.CryptoInfo->pkcs5 = BootDriveFilterExtension->HeaderCryptoInfo->pkcs5;

  001bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _BootDriveFilterExtension
  001c2	8b 91 44 02 00
	00		 mov	 edx, DWORD PTR [ecx+580]
  001c8	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  001cd	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  001d0	8b 92 ec 43 00
	00		 mov	 edx, DWORD PTR [edx+17388]
  001d6	89 91 ec 43 00
	00		 mov	 DWORD PTR [ecx+17388], edx

; 797  : 		BootDriveFilterExtension->Queue.CryptoInfo->noIterations = BootDriveFilterExtension->HeaderCryptoInfo->noIterations;

  001dc	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  001e1	8b 88 44 02 00
	00		 mov	 ecx, DWORD PTR [eax+580]
  001e7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _BootDriveFilterExtension
  001ed	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  001f0	8b 89 e8 43 00
	00		 mov	 ecx, DWORD PTR [ecx+17384]
  001f6	89 88 e8 43 00
	00		 mov	 DWORD PTR [eax+17384], ecx

; 798  : 
; 799  : 		irp->IoStatus.Status = STATUS_SUCCESS;

  001fc	8b 55 08	 mov	 edx, DWORD PTR _irp$[ebp]
  001ff	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 800  : 	}
; 801  : 	else

  00206	eb 38		 jmp	 SHORT $ret$28276
$LN7@ReopenBoot:

; 802  : 	{
; 803  : 		crypto_close (BootDriveFilterExtension->HeaderCryptoInfo);

  00208	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  0020d	8b 88 44 02 00
	00		 mov	 ecx, DWORD PTR [eax+580]
  00213	51		 push	 ecx
  00214	e8 00 00 00 00	 call	 _crypto_close@4

; 804  : 		BootDriveFilterExtension->HeaderCryptoInfo = NULL;

  00219	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _BootDriveFilterExtension
  0021f	c7 82 44 02 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+580], 0

; 805  : 
; 806  : 		Dump ("Header not reopened\n");

  00229	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@GFCPIAML@Header?5not?5reopened?6?$AA@FNODOBFM@
  0022e	e8 00 00 00 00	 call	 _DbgPrint
  00233	83 c4 04	 add	 esp, 4

; 807  : 		irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  00236	8b 45 08	 mov	 eax, DWORD PTR _irp$[ebp]
  00239	c7 40 18 0d 00
	00 c0		 mov	 DWORD PTR [eax+24], -1073741811 ; c000000dH
$ret$28276:

; 808  : 	}
; 809  : 
; 810  : ret:
; 811  : 	TCfree (header);

  00240	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00245	8b 4d f0	 mov	 ecx, DWORD PTR _header$[ebp]
  00248	51		 push	 ecx
  00249	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$wipe$28268:

; 812  : wipe:
; 813  : 	burn (request, sizeof (*request));

  0024f	8b 55 f4	 mov	 edx, DWORD PTR _request$[ebp]
  00252	89 55 e8	 mov	 DWORD PTR _burnm$28288[ebp], edx
  00255	c7 45 ec 48 00
	00 00		 mov	 DWORD PTR _burnc$28290[ebp], 72 ; 00000048H
  0025c	6a 48		 push	 72			; 00000048H
  0025e	8b 45 f4	 mov	 eax, DWORD PTR _request$[ebp]
  00261	50		 push	 eax
  00262	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@ReopenBoot:
  00267	8b 4d ec	 mov	 ecx, DWORD PTR _burnc$28290[ebp]
  0026a	8b 55 ec	 mov	 edx, DWORD PTR _burnc$28290[ebp]
  0026d	83 ea 01	 sub	 edx, 1
  00270	89 55 ec	 mov	 DWORD PTR _burnc$28290[ebp], edx
  00273	85 c9		 test	 ecx, ecx
  00275	74 11		 je	 SHORT $LN4@ReopenBoot
  00277	8b 45 e8	 mov	 eax, DWORD PTR _burnm$28288[ebp]
  0027a	c6 00 00	 mov	 BYTE PTR [eax], 0
  0027d	8b 4d e8	 mov	 ecx, DWORD PTR _burnm$28288[ebp]
  00280	83 c1 01	 add	 ecx, 1
  00283	89 4d e8	 mov	 DWORD PTR _burnm$28288[ebp], ecx
  00286	eb df		 jmp	 SHORT $LN2@ReopenBoot
$LN4@ReopenBoot:
  00288	33 d2		 xor	 edx, edx
  0028a	75 c3		 jne	 SHORT $wipe$28268
$LN16@ReopenBoot:

; 814  : }

  0028c	8b e5		 mov	 esp, ebp
  0028e	5d		 pop	 ebp
  0028f	c2 08 00	 ret	 8
_ReopenBootVolumeHeader@8 ENDP
_TEXT	ENDS
EXTRN	__imp__KeGetCurrentThread@0:PROC
; Function compile flags: /Odtp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
;	COMDAT _PsGetCurrentThread@0
_TEXT	SEGMENT
_PsGetCurrentThread@0 PROC				; COMDAT

; 19988: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 19989: 
; 19990:     return (PETHREAD)KeGetCurrentThread();

  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeGetCurrentThread@0

; 19991: }

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
_PsGetCurrentThread@0 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@CFHEDMMF@?$CBIsOSAtLeast?5?$CIWIN_VISTA?$CJ?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp__MmFreeContiguousMemory@4:PROC
EXTRN	__imp__IoFreeMdl@4:PROC
EXTRN	__imp__PsSetLoadImageNotifyRoutine@4:PROC
EXTRN	__imp__MmBuildMdlForNonPagedPool@4:PROC
EXTRN	__imp__IoAllocateMdl@20:PROC
EXTRN	__imp__MmAllocateContiguousMemory@12:PROC
EXTRN	_TCDriverObject:DWORD
;	COMDAT ??_C@_0BJ@CFHEDMMF@?$CBIsOSAtLeast?5?$CIWIN_VISTA?$CJ?$AA@FNODOBFM@
; File c:\users\public\desktop\projects\ciphershed\src\driver\drivefilter.c
text$s	SEGMENT
??_C@_0BJ@CFHEDMMF@?$CBIsOSAtLeast?5?$CIWIN_VISTA?$CJ?$AA@FNODOBFM@ DB '!'
	DB	'IsOSAtLeast (WIN_VISTA)', 00H		;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _StartLegacyHibernationDriverFilter@0
_TEXT	SEGMENT
tv79 = -20						; size = 4
tv71 = -16						; size = 4
_status$ = -12						; size = 4
_highestAcceptableWriteBufferAddr$ = -8			; size = 8
_StartLegacyHibernationDriverFilter@0 PROC		; COMDAT

; 1098 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 14	 sub	 esp, 20			; 00000014H

; 1099 : 	PHYSICAL_ADDRESS highestAcceptableWriteBufferAddr;
; 1100 : 	NTSTATUS status;
; 1101 : 
; 1102 : 	ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeGetCurrentIrql@0
  0000e	0f b6 c0	 movzx	 eax, al
  00011	85 c0		 test	 eax, eax
  00013	74 20		 je	 SHORT $LN10@StartLegac
  00015	6a 00		 push	 0
  00017	68 4e 04 00 00	 push	 1102			; 0000044eH
  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@GDHJGIB@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@KKOENIAD@KeGetCurrentIrql?$CI?$CJ?5?$DN?$DN?5PASSIVE_LE@FNODOBFM@
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  0002c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
  00033	eb 07		 jmp	 SHORT $LN11@StartLegac
$LN10@StartLegac:
  00035	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
$LN11@StartLegac:

; 1103 : 	ASSERT (!IsOSAtLeast (WIN_VISTA));

  0003c	6a 0b		 push	 11			; 0000000bH
  0003e	e8 00 00 00 00	 call	 _IsOSAtLeast@4
  00043	85 c0		 test	 eax, eax
  00045	74 20		 je	 SHORT $LN12@StartLegac
  00047	6a 00		 push	 0
  00049	68 4f 04 00 00	 push	 1103			; 0000044fH
  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@GDHJGIB@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  00053	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@CFHEDMMF@?$CBIsOSAtLeast?5?$CIWIN_VISTA?$CJ?$AA@FNODOBFM@
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  0005e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
  00065	eb 07		 jmp	 SHORT $LN13@StartLegac
$LN12@StartLegac:
  00067	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
$LN13@StartLegac:

; 1104 : 
; 1105 : 	if (!TCDriverObject->DriverSection || !*(ModuleTableItem **) TCDriverObject->DriverSection)

  0006e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _TCDriverObject
  00074	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  00078	74 0e		 je	 SHORT $LN6@StartLegac
  0007a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _TCDriverObject
  00080	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00083	83 38 00	 cmp	 DWORD PTR [eax], 0
  00086	75 05		 jne	 SHORT $LN7@StartLegac
$LN6@StartLegac:

; 1106 : 		goto err;

  00088	e9 9b 00 00 00	 jmp	 $err$28556
$LN7@StartLegac:

; 1107 : 
; 1108 : 	// All buffers required for hibernation must be allocated here
; 1109 : #ifdef _WIN64
; 1110 : 	highestAcceptableWriteBufferAddr.QuadPart = 0x7FFffffFFFFULL;
; 1111 : #else
; 1112 : 	highestAcceptableWriteBufferAddr.QuadPart = 0xffffFFFFULL;

  0008d	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _highestAcceptableWriteBufferAddr$[ebp], -1
  00094	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _highestAcceptableWriteBufferAddr$[ebp+4], 0

; 1113 : #endif
; 1114 : 
; 1115 : 	HibernationWriteBuffer = MmAllocateContiguousMemory (TC_HIBERNATION_WRITE_BUFFER_SIZE, highestAcceptableWriteBufferAddr);

  0009b	8b 4d fc	 mov	 ecx, DWORD PTR _highestAcceptableWriteBufferAddr$[ebp+4]
  0009e	51		 push	 ecx
  0009f	8b 55 f8	 mov	 edx, DWORD PTR _highestAcceptableWriteBufferAddr$[ebp]
  000a2	52		 push	 edx
  000a3	68 00 00 02 00	 push	 131072			; 00020000H
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmAllocateContiguousMemory@12
  000ae	a3 00 00 00 00	 mov	 DWORD PTR _HibernationWriteBuffer, eax

; 1116 : 	if (!HibernationWriteBuffer)

  000b3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _HibernationWriteBuffer, 0
  000ba	75 02		 jne	 SHORT $LN5@StartLegac

; 1117 : 		goto err;

  000bc	eb 6a		 jmp	 SHORT $err$28556
$LN5@StartLegac:

; 1118 : 
; 1119 : 	HibernationWriteBufferMdl = IoAllocateMdl (HibernationWriteBuffer, TC_HIBERNATION_WRITE_BUFFER_SIZE, FALSE, FALSE, NULL);

  000be	6a 00		 push	 0
  000c0	6a 00		 push	 0
  000c2	6a 00		 push	 0
  000c4	68 00 00 02 00	 push	 131072			; 00020000H
  000c9	a1 00 00 00 00	 mov	 eax, DWORD PTR _HibernationWriteBuffer
  000ce	50		 push	 eax
  000cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAllocateMdl@20
  000d5	a3 00 00 00 00	 mov	 DWORD PTR _HibernationWriteBufferMdl, eax

; 1120 : 	if (!HibernationWriteBufferMdl)

  000da	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _HibernationWriteBufferMdl, 0
  000e1	75 02		 jne	 SHORT $LN4@StartLegac

; 1121 : 		goto err;

  000e3	eb 43		 jmp	 SHORT $err$28556
$LN4@StartLegac:

; 1122 : 
; 1123 : 	MmBuildMdlForNonPagedPool (HibernationWriteBufferMdl);

  000e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _HibernationWriteBufferMdl
  000eb	51		 push	 ecx
  000ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmBuildMdlForNonPagedPool@4

; 1124 : 
; 1125 : 	status = PsSetLoadImageNotifyRoutine (LoadImageNotifyRoutine);

  000f2	68 00 00 00 00	 push	 OFFSET _LoadImageNotifyRoutine@12
  000f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsSetLoadImageNotifyRoutine@4
  000fd	89 45 f4	 mov	 DWORD PTR _status$[ebp], eax

; 1126 : 	if (!NT_SUCCESS (status))

  00100	83 7d f4 00	 cmp	 DWORD PTR _status$[ebp], 0
  00104	7d 02		 jge	 SHORT $LN3@StartLegac

; 1127 : 		goto err;

  00106	eb 20		 jmp	 SHORT $err$28556
$LN3@StartLegac:

; 1128 : 
; 1129 : 	LegacyHibernationDriverFilterActive = TRUE;

  00108	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _LegacyHibernationDriverFilterActive, 1

; 1130 : 	CrashDumpEnabled = FALSE;

  00112	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CrashDumpEnabled, 0

; 1131 : 	HibernationEnabled = TRUE;

  0011c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _HibernationEnabled, 1

; 1132 : 	return;

  00126	eb 5d		 jmp	 SHORT $LN8@StartLegac
$err$28556:

; 1133 : 
; 1134 : err:
; 1135 : 	LegacyHibernationDriverFilterActive = FALSE;

  00128	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _LegacyHibernationDriverFilterActive, 0

; 1136 : 	CrashDumpEnabled = FALSE;

  00132	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CrashDumpEnabled, 0

; 1137 : 	HibernationEnabled = FALSE;

  0013c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _HibernationEnabled, 0

; 1138 : 
; 1139 : 	if (HibernationWriteBufferMdl)

  00146	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _HibernationWriteBufferMdl, 0
  0014d	74 17		 je	 SHORT $LN2@StartLegac

; 1140 : 	{
; 1141 : 		IoFreeMdl (HibernationWriteBufferMdl);

  0014f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _HibernationWriteBufferMdl
  00155	52		 push	 edx
  00156	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoFreeMdl@4

; 1142 : 		HibernationWriteBufferMdl = NULL;

  0015c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _HibernationWriteBufferMdl, 0
$LN2@StartLegac:

; 1143 : 	}
; 1144 : 
; 1145 : 	if (HibernationWriteBuffer)

  00166	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _HibernationWriteBuffer, 0
  0016d	74 16		 je	 SHORT $LN8@StartLegac

; 1146 : 	{
; 1147 : 		MmFreeContiguousMemory (HibernationWriteBuffer);

  0016f	a1 00 00 00 00	 mov	 eax, DWORD PTR _HibernationWriteBuffer
  00174	50		 push	 eax
  00175	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmFreeContiguousMemory@4

; 1148 : 		HibernationWriteBuffer = NULL;

  0017b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _HibernationWriteBuffer, 0
$LN8@StartLegac:

; 1149 : 	}
; 1150 : }

  00185	8b e5		 mov	 esp, ebp
  00187	5d		 pop	 ebp
  00188	c3		 ret	 0
_StartLegacyHibernationDriverFilter@0 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1M@IFMDENJC@?$AAH?$AAI?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1M@JEHGIGBM@?$AAH?$AAi?$AAb?$AAe?$AAr?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1M@IMEHFNOE@?$AAh?$AAi?$AAb?$AAe?$AAr?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp_@KfLowerIrql@4:PROC
EXTRN	__imp__KeRaiseIrqlToDpcLevel@0:PROC
_BSS	SEGMENT
_OriginalHiberDriverEntries DD 03H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_1M@IFMDENJC@?$AAH?$AAI?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1M@IFMDENJC@?$AAH?$AAI?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@ DB 'H', 00H
	DB	'I', 00H, 'B', 00H, 'E', 00H, 'R', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1M@JEHGIGBM@?$AAH?$AAi?$AAb?$AAe?$AAr?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1M@JEHGIGBM@?$AAH?$AAi?$AAb?$AAe?$AAr?$AA?$AA@FNODOBFM@ DB 'H', 00H
	DB	'i', 00H, 'b', 00H, 'e', 00H, 'r', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1M@IMEHFNOE@?$AAh?$AAi?$AAb?$AAe?$AAr?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1M@IMEHFNOE@?$AAh?$AAi?$AAb?$AAe?$AAr?$AA?$AA@FNODOBFM@ DB 'h', 00H
	DB	'i', 00H, 'b', 00H, 'e', 00H, 'r', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _LoadImageNotifyRoutine@12
_TEXT	SEGMENT
tv143 = -20						; size = 4
_filterEntry$28535 = -16				; size = 4
_moduleItem$ = -12					; size = 4
_origIrql$ = -5						; size = 1
_listEntry$ = -4					; size = 4
_fullImageName$ = 8					; size = 4
_processId$ = 12					; size = 4
_imageInfo$ = 16					; size = 4
_LoadImageNotifyRoutine@12 PROC				; COMDAT

; 1039 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 14	 sub	 esp, 20			; 00000014H
  00008	56		 push	 esi
  00009	57		 push	 edi

; 1040 : 	ModuleTableItem *moduleItem;
; 1041 : 	LIST_ENTRY *listEntry;
; 1042 : 	KIRQL origIrql;
; 1043 : 
; 1044 : 	if (!imageInfo || !imageInfo->SystemModeImage || !imageInfo->ImageBase || !TCDriverObject->DriverSection)

  0000a	83 7d 10 00	 cmp	 DWORD PTR _imageInfo$[ebp], 0
  0000e	74 21		 je	 SHORT $LN18@LoadImageN
  00010	8b 45 10	 mov	 eax, DWORD PTR _imageInfo$[ebp]
  00013	8b 08		 mov	 ecx, DWORD PTR [eax]
  00015	c1 e9 08	 shr	 ecx, 8
  00018	83 e1 01	 and	 ecx, 1
  0001b	74 14		 je	 SHORT $LN18@LoadImageN
  0001d	8b 55 10	 mov	 edx, DWORD PTR _imageInfo$[ebp]
  00020	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00024	74 0b		 je	 SHORT $LN18@LoadImageN
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR _TCDriverObject
  0002b	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  0002f	75 05		 jne	 SHORT $LN19@LoadImageN
$LN18@LoadImageN:

; 1045 : 		return;

  00031	e9 88 01 00 00	 jmp	 $LN21@LoadImageN
$LN19@LoadImageN:

; 1046 : 
; 1047 : 	moduleItem = *(ModuleTableItem **) TCDriverObject->DriverSection;

  00036	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _TCDriverObject
  0003c	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0003f	8b 02		 mov	 eax, DWORD PTR [edx]
  00041	89 45 f4	 mov	 DWORD PTR _moduleItem$[ebp], eax

; 1048 : 	if (!moduleItem || !moduleItem->ModuleList.Flink)

  00044	83 7d f4 00	 cmp	 DWORD PTR _moduleItem$[ebp], 0
  00048	74 08		 je	 SHORT $LN16@LoadImageN
  0004a	8b 4d f4	 mov	 ecx, DWORD PTR _moduleItem$[ebp]
  0004d	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00050	75 05		 jne	 SHORT $LN17@LoadImageN
$LN16@LoadImageN:

; 1049 : 		return;

  00052	e9 67 01 00 00	 jmp	 $LN21@LoadImageN
$LN17@LoadImageN:

; 1050 : 
; 1051 : 	// Search loaded system modules for hibernation driver
; 1052 : 	origIrql = KeRaiseIrqlToDpcLevel();

  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeRaiseIrqlToDpcLevel@0
  0005d	88 45 fb	 mov	 BYTE PTR _origIrql$[ebp], al

; 1053 : 
; 1054 : 	for (listEntry = moduleItem->ModuleList.Flink->Blink;
; 1055 : 		listEntry && listEntry != TCDriverObject->DriverSection;
; 1056 : 		listEntry = listEntry->Flink)

  00060	8b 55 f4	 mov	 edx, DWORD PTR _moduleItem$[ebp]
  00063	8b 02		 mov	 eax, DWORD PTR [edx]
  00065	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00068	89 4d fc	 mov	 DWORD PTR _listEntry$[ebp], ecx
  0006b	eb 08		 jmp	 SHORT $LN15@LoadImageN
$LN14@LoadImageN:
  0006d	8b 55 fc	 mov	 edx, DWORD PTR _listEntry$[ebp]
  00070	8b 02		 mov	 eax, DWORD PTR [edx]
  00072	89 45 fc	 mov	 DWORD PTR _listEntry$[ebp], eax
$LN15@LoadImageN:
  00075	83 7d fc 00	 cmp	 DWORD PTR _listEntry$[ebp], 0
  00079	0f 84 36 01 00
	00		 je	 $LN13@LoadImageN
  0007f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _TCDriverObject
  00085	8b 55 fc	 mov	 edx, DWORD PTR _listEntry$[ebp]
  00088	3b 51 14	 cmp	 edx, DWORD PTR [ecx+20]
  0008b	0f 84 24 01 00
	00		 je	 $LN13@LoadImageN

; 1057 : 	{
; 1058 : 		moduleItem = CONTAINING_RECORD (listEntry, ModuleTableItem, ModuleList);

  00091	8b 45 fc	 mov	 eax, DWORD PTR _listEntry$[ebp]
  00094	89 45 f4	 mov	 DWORD PTR _moduleItem$[ebp], eax

; 1059 : 
; 1060 : 		if (moduleItem && imageInfo->ImageBase == moduleItem->ModuleBaseAddress)

  00097	83 7d f4 00	 cmp	 DWORD PTR _moduleItem$[ebp], 0
  0009b	0f 84 0f 01 00
	00		 je	 $LN12@LoadImageN
  000a1	8b 4d 10	 mov	 ecx, DWORD PTR _imageInfo$[ebp]
  000a4	8b 55 f4	 mov	 edx, DWORD PTR _moduleItem$[ebp]
  000a7	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000aa	3b 42 18	 cmp	 eax, DWORD PTR [edx+24]
  000ad	0f 85 fd 00 00
	00		 jne	 $LN12@LoadImageN

; 1061 : 		{
; 1062 : 			if (moduleItem->ModuleName.Buffer && moduleItem->ModuleName.Length >= 5 * sizeof (wchar_t))

  000b3	8b 4d f4	 mov	 ecx, DWORD PTR _moduleItem$[ebp]
  000b6	83 79 30 00	 cmp	 DWORD PTR [ecx+48], 0
  000ba	0f 84 ee 00 00
	00		 je	 $LN11@LoadImageN
  000c0	8b 55 f4	 mov	 edx, DWORD PTR _moduleItem$[ebp]
  000c3	0f b7 42 2c	 movzx	 eax, WORD PTR [edx+44]
  000c7	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  000ca	0f 82 de 00 00
	00		 jb	 $LN11@LoadImageN

; 1063 : 			{
; 1064 : 				if (memcmp (moduleItem->ModuleName.Buffer, L"hiber", 5 * sizeof (wchar_t)) == 0
; 1065 : 					|| memcmp (moduleItem->ModuleName.Buffer, L"Hiber", 5 * sizeof (wchar_t)) == 0
; 1066 : 					|| memcmp (moduleItem->ModuleName.Buffer, L"HIBER", 5 * sizeof (wchar_t)) == 0)

  000d0	b9 05 00 00 00	 mov	 ecx, 5
  000d5	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_1M@IMEHFNOE@?$AAh?$AAi?$AAb?$AAe?$AAr?$AA?$AA@FNODOBFM@
  000da	8b 55 f4	 mov	 edx, DWORD PTR _moduleItem$[ebp]
  000dd	8b 72 30	 mov	 esi, DWORD PTR [edx+48]
  000e0	33 c0		 xor	 eax, eax
  000e2	66 f3 a7	 repe cmpsw
  000e5	74 32		 je	 SHORT $LN9@LoadImageN
  000e7	b9 05 00 00 00	 mov	 ecx, 5
  000ec	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_1M@JEHGIGBM@?$AAH?$AAi?$AAb?$AAe?$AAr?$AA?$AA@FNODOBFM@
  000f1	8b 55 f4	 mov	 edx, DWORD PTR _moduleItem$[ebp]
  000f4	8b 72 30	 mov	 esi, DWORD PTR [edx+48]
  000f7	33 c0		 xor	 eax, eax
  000f9	66 f3 a7	 repe cmpsw
  000fc	74 1b		 je	 SHORT $LN9@LoadImageN
  000fe	b9 05 00 00 00	 mov	 ecx, 5
  00103	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_1M@IFMDENJC@?$AAH?$AAI?$AAB?$AAE?$AAR?$AA?$AA@FNODOBFM@
  00108	8b 55 f4	 mov	 edx, DWORD PTR _moduleItem$[ebp]
  0010b	8b 72 30	 mov	 esi, DWORD PTR [edx+48]
  0010e	33 c0		 xor	 eax, eax
  00110	66 f3 a7	 repe cmpsw
  00113	0f 85 95 00 00
	00		 jne	 $LN11@LoadImageN
$LN9@LoadImageN:

; 1067 : 				{
; 1068 : 					HiberDriverEntry filterEntry;
; 1069 : 
; 1070 : 					switch (LastHiberFilterNumber)

  00119	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _LastHiberFilterNumber
  0011f	89 4d ec	 mov	 DWORD PTR tv143[ebp], ecx
  00122	83 7d ec 00	 cmp	 DWORD PTR tv143[ebp], 0
  00126	74 0e		 je	 SHORT $LN6@LoadImageN
  00128	83 7d ec 01	 cmp	 DWORD PTR tv143[ebp], 1
  0012c	74 11		 je	 SHORT $LN5@LoadImageN
  0012e	83 7d ec 02	 cmp	 DWORD PTR tv143[ebp], 2
  00132	74 14		 je	 SHORT $LN4@LoadImageN
  00134	eb 1b		 jmp	 SHORT $LN3@LoadImageN
$LN6@LoadImageN:

; 1071 : 					{
; 1072 : 					case 0: filterEntry = HiberDriverEntryFilter0; break;

  00136	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _filterEntry$28535[ebp], OFFSET _HiberDriverEntryFilter0@8
  0013d	eb 28		 jmp	 SHORT $LN7@LoadImageN
$LN5@LoadImageN:

; 1073 : 					case 1: filterEntry = HiberDriverEntryFilter1; break;

  0013f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _filterEntry$28535[ebp], OFFSET _HiberDriverEntryFilter1@8
  00146	eb 1f		 jmp	 SHORT $LN7@LoadImageN
$LN4@LoadImageN:

; 1074 : 					case 2: filterEntry = HiberDriverEntryFilter2; break;

  00148	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _filterEntry$28535[ebp], OFFSET _HiberDriverEntryFilter2@8
  0014f	eb 16		 jmp	 SHORT $LN7@LoadImageN
$LN3@LoadImageN:

; 1075 : 					default: TC_THROW_FATAL_EXCEPTION;

  00151	68 43 54 00 00	 push	 21571			; 00005443H
  00156	6a 00		 push	 0
  00158	6a 00		 push	 0
  0015a	68 33 04 00 00	 push	 1075			; 00000433H
  0015f	6a 29		 push	 41			; 00000029H
  00161	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN7@LoadImageN:

; 1076 : 					}
; 1077 : 
; 1078 : 					if (moduleItem->ModuleEntryAddress != filterEntry)

  00167	8b 55 f4	 mov	 edx, DWORD PTR _moduleItem$[ebp]
  0016a	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0016d	3b 45 f0	 cmp	 eax, DWORD PTR _filterEntry$28535[ebp]
  00170	74 3c		 je	 SHORT $LN11@LoadImageN

; 1079 : 					{
; 1080 : 						// Install filter
; 1081 : 						OriginalHiberDriverEntries[LastHiberFilterNumber] = moduleItem->ModuleEntryAddress;

  00172	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _LastHiberFilterNumber
  00178	8b 55 f4	 mov	 edx, DWORD PTR _moduleItem$[ebp]
  0017b	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0017e	89 04 8d 00 00
	00 00		 mov	 DWORD PTR _OriginalHiberDriverEntries[ecx*4], eax

; 1082 : 						moduleItem->ModuleEntryAddress = filterEntry;

  00185	8b 4d f4	 mov	 ecx, DWORD PTR _moduleItem$[ebp]
  00188	8b 55 f0	 mov	 edx, DWORD PTR _filterEntry$28535[ebp]
  0018b	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 1083 : 
; 1084 : 						if (++LastHiberFilterNumber > TC_MAX_HIBER_FILTER_COUNT - 1)

  0018e	a1 00 00 00 00	 mov	 eax, DWORD PTR _LastHiberFilterNumber
  00193	83 c0 01	 add	 eax, 1
  00196	a3 00 00 00 00	 mov	 DWORD PTR _LastHiberFilterNumber, eax
  0019b	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _LastHiberFilterNumber, 2
  001a2	7e 0a		 jle	 SHORT $LN11@LoadImageN

; 1085 : 							LastHiberFilterNumber = 0;

  001a4	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _LastHiberFilterNumber, 0
$LN11@LoadImageN:

; 1086 : 					}
; 1087 : 				}
; 1088 : 			}
; 1089 : 			break;

  001ae	eb 05		 jmp	 SHORT $LN13@LoadImageN
$LN12@LoadImageN:

; 1090 : 		}
; 1091 : 	}

  001b0	e9 b8 fe ff ff	 jmp	 $LN14@LoadImageN
$LN13@LoadImageN:

; 1092 : 
; 1093 : 	KeLowerIrql (origIrql);

  001b5	8a 4d fb	 mov	 cl, BYTE PTR _origIrql$[ebp]
  001b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfLowerIrql@4
$LN21@LoadImageN:

; 1094 : }

  001be	5f		 pop	 edi
  001bf	5e		 pop	 esi
  001c0	8b e5		 mov	 esp, ebp
  001c2	5d		 pop	 ebp
  001c3	c2 0c 00	 ret	 12			; 0000000cH
_LoadImageNotifyRoutine@12 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _HiberDriverEntryFilter0@8
_TEXT	SEGMENT
_arg0$ = 8						; size = 4
_hiberDriverContext$ = 12				; size = 4
_HiberDriverEntryFilter0@8 PROC				; COMDAT

; 1021 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1022 : 	return HiberDriverEntryFilter (0, arg0, hiberDriverContext);

  00005	8b 45 0c	 mov	 eax, DWORD PTR _hiberDriverContext$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _arg0$[ebp]
  0000c	51		 push	 ecx
  0000d	6a 00		 push	 0
  0000f	e8 00 00 00 00	 call	 _HiberDriverEntryFilter@12

; 1023 : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
_HiberDriverEntryFilter0@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@MGBGIHJM@Filtering?5WriteFunctionB?5?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BN@EAICPFDC@Filtering?5WriteFunctionA?5?$CFd?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
_BSS	SEGMENT
	ALIGN	8

_HiberPartitionOffset DQ 01H DUP (?)
_OriginalHiberDriverWriteFunctionsB DD 03H DUP (?)
_OriginalHiberDriverWriteFunctionsA DD 03H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BN@MGBGIHJM@Filtering?5WriteFunctionB?5?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BN@MGBGIHJM@Filtering?5WriteFunctionB?5?$CFd?6?$AA@FNODOBFM@ DB 'F'
	DB	'iltering WriteFunctionB %d', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BN@EAICPFDC@Filtering?5WriteFunctionA?5?$CFd?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BN@EAICPFDC@Filtering?5WriteFunctionA?5?$CFd?6?$AA@FNODOBFM@ DB 'F'
	DB	'iltering WriteFunctionA %d', 0aH, 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _HiberDriverEntryFilter@12
_TEXT	SEGMENT
tv189 = -20						; size = 4
tv139 = -16						; size = 4
tv88 = -12						; size = 4
_status$ = -8						; size = 4
_filterInstalled$ = -4					; size = 4
_filterNumber$ = 8					; size = 4
_arg0$ = 12						; size = 4
_hiberDriverContext$ = 16				; size = 4
_HiberDriverEntryFilter@12 PROC				; COMDAT

; 961  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 14	 sub	 esp, 20			; 00000014H

; 962  : 	BOOL filterInstalled = FALSE;

  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _filterInstalled$[ebp], 0

; 963  : 	NTSTATUS status;
; 964  : 
; 965  : 	if (!OriginalHiberDriverEntries[filterNumber])

  0000f	8b 45 08	 mov	 eax, DWORD PTR _filterNumber$[ebp]
  00012	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _OriginalHiberDriverEntries[eax*4], 0
  0001a	75 0a		 jne	 SHORT $LN20@HiberDrive

; 966  : 		return STATUS_UNSUCCESSFUL;

  0001c	b8 01 00 00 c0	 mov	 eax, -1073741823	; c0000001H
  00021	e9 ba 01 00 00	 jmp	 $LN22@HiberDrive
$LN20@HiberDrive:

; 967  : 
; 968  : 	status = (*OriginalHiberDriverEntries[filterNumber]) (arg0, hiberDriverContext);

  00026	8b 4d 10	 mov	 ecx, DWORD PTR _hiberDriverContext$[ebp]
  00029	51		 push	 ecx
  0002a	8b 55 0c	 mov	 edx, DWORD PTR _arg0$[ebp]
  0002d	52		 push	 edx
  0002e	8b 45 08	 mov	 eax, DWORD PTR _filterNumber$[ebp]
  00031	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _OriginalHiberDriverEntries[eax*4]
  00038	ff d1		 call	 ecx
  0003a	89 45 f8	 mov	 DWORD PTR _status$[ebp], eax

; 969  : 
; 970  : 	if (!NT_SUCCESS (status) || !hiberDriverContext)

  0003d	83 7d f8 00	 cmp	 DWORD PTR _status$[ebp], 0
  00041	7c 06		 jl	 SHORT $LN18@HiberDrive
  00043	83 7d 10 00	 cmp	 DWORD PTR _hiberDriverContext$[ebp], 0
  00047	75 08		 jne	 SHORT $LN19@HiberDrive
$LN18@HiberDrive:

; 971  : 		return status;

  00049	8b 45 f8	 mov	 eax, DWORD PTR _status$[ebp]
  0004c	e9 8f 01 00 00	 jmp	 $LN22@HiberDrive
$LN19@HiberDrive:

; 972  : 
; 973  : 	if (SetupInProgress)

  00051	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SetupInProgress, 0
  00058	74 19		 je	 SHORT $LN17@HiberDrive

; 974  : 		TC_BUG_CHECK (STATUS_INVALID_PARAMETER);

  0005a	68 43 54 00 00	 push	 21571			; 00005443H
  0005f	6a 00		 push	 0
  00061	68 0d 00 00 c0	 push	 -1073741811		; c000000dH
  00066	68 ce 03 00 00	 push	 974			; 000003ceH
  0006b	6a 29		 push	 41			; 00000029H
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN17@HiberDrive:

; 975  : 
; 976  : 	if (hiberDriverContext->WriteFunctionA)

  00073	8b 55 10	 mov	 edx, DWORD PTR _hiberDriverContext$[ebp]
  00076	83 7a 54 00	 cmp	 DWORD PTR [edx+84], 0
  0007a	74 7c		 je	 SHORT $LN16@HiberDrive

; 977  : 	{
; 978  : 		Dump ("Filtering WriteFunctionA %d\n", filterNumber);

  0007c	8b 45 08	 mov	 eax, DWORD PTR _filterNumber$[ebp]
  0007f	50		 push	 eax
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@EAICPFDC@Filtering?5WriteFunctionA?5?$CFd?6?$AA@FNODOBFM@
  00085	e8 00 00 00 00	 call	 _DbgPrint
  0008a	83 c4 08	 add	 esp, 8

; 979  : 		OriginalHiberDriverWriteFunctionsA[filterNumber] = hiberDriverContext->WriteFunctionA;

  0008d	8b 4d 08	 mov	 ecx, DWORD PTR _filterNumber$[ebp]
  00090	8b 55 10	 mov	 edx, DWORD PTR _hiberDriverContext$[ebp]
  00093	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  00096	89 04 8d 00 00
	00 00		 mov	 DWORD PTR _OriginalHiberDriverWriteFunctionsA[ecx*4], eax

; 980  : 
; 981  : 		switch (filterNumber)

  0009d	8b 4d 08	 mov	 ecx, DWORD PTR _filterNumber$[ebp]
  000a0	89 4d f4	 mov	 DWORD PTR tv88[ebp], ecx
  000a3	83 7d f4 00	 cmp	 DWORD PTR tv88[ebp], 0
  000a7	74 0e		 je	 SHORT $LN13@HiberDrive
  000a9	83 7d f4 01	 cmp	 DWORD PTR tv88[ebp], 1
  000ad	74 14		 je	 SHORT $LN12@HiberDrive
  000af	83 7d f4 02	 cmp	 DWORD PTR tv88[ebp], 2
  000b3	74 1a		 je	 SHORT $LN11@HiberDrive
  000b5	eb 24		 jmp	 SHORT $LN10@HiberDrive
$LN13@HiberDrive:

; 982  : 		{
; 983  : 		case 0: hiberDriverContext->WriteFunctionA = HiberDriverWriteFunctionAFilter0; break;

  000b7	8b 55 10	 mov	 edx, DWORD PTR _hiberDriverContext$[ebp]
  000ba	c7 42 54 00 00
	00 00		 mov	 DWORD PTR [edx+84], OFFSET _HiberDriverWriteFunctionAFilter0@16
  000c1	eb 2e		 jmp	 SHORT $LN14@HiberDrive
$LN12@HiberDrive:

; 984  : 		case 1: hiberDriverContext->WriteFunctionA = HiberDriverWriteFunctionAFilter1; break;

  000c3	8b 45 10	 mov	 eax, DWORD PTR _hiberDriverContext$[ebp]
  000c6	c7 40 54 00 00
	00 00		 mov	 DWORD PTR [eax+84], OFFSET _HiberDriverWriteFunctionAFilter1@16
  000cd	eb 22		 jmp	 SHORT $LN14@HiberDrive
$LN11@HiberDrive:

; 985  : 		case 2: hiberDriverContext->WriteFunctionA = HiberDriverWriteFunctionAFilter2; break;

  000cf	8b 4d 10	 mov	 ecx, DWORD PTR _hiberDriverContext$[ebp]
  000d2	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], OFFSET _HiberDriverWriteFunctionAFilter2@16
  000d9	eb 16		 jmp	 SHORT $LN14@HiberDrive
$LN10@HiberDrive:

; 986  : 		default: TC_THROW_FATAL_EXCEPTION;

  000db	68 43 54 00 00	 push	 21571			; 00005443H
  000e0	6a 00		 push	 0
  000e2	6a 00		 push	 0
  000e4	68 da 03 00 00	 push	 986			; 000003daH
  000e9	6a 29		 push	 41			; 00000029H
  000eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN14@HiberDrive:

; 987  : 		}
; 988  : 
; 989  : 		filterInstalled = TRUE;

  000f1	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _filterInstalled$[ebp], 1
$LN16@HiberDrive:

; 990  : 	}
; 991  : 
; 992  : 	if (hiberDriverContext->WriteFunctionB)

  000f8	8b 55 10	 mov	 edx, DWORD PTR _hiberDriverContext$[ebp]
  000fb	83 7a 30 00	 cmp	 DWORD PTR [edx+48], 0
  000ff	74 7c		 je	 SHORT $LN9@HiberDrive

; 993  : 	{
; 994  : 		Dump ("Filtering WriteFunctionB %d\n", filterNumber);

  00101	8b 45 08	 mov	 eax, DWORD PTR _filterNumber$[ebp]
  00104	50		 push	 eax
  00105	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@MGBGIHJM@Filtering?5WriteFunctionB?5?$CFd?6?$AA@FNODOBFM@
  0010a	e8 00 00 00 00	 call	 _DbgPrint
  0010f	83 c4 08	 add	 esp, 8

; 995  : 		OriginalHiberDriverWriteFunctionsB[filterNumber] = hiberDriverContext->WriteFunctionB;

  00112	8b 4d 08	 mov	 ecx, DWORD PTR _filterNumber$[ebp]
  00115	8b 55 10	 mov	 edx, DWORD PTR _hiberDriverContext$[ebp]
  00118	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0011b	89 04 8d 00 00
	00 00		 mov	 DWORD PTR _OriginalHiberDriverWriteFunctionsB[ecx*4], eax

; 996  : 
; 997  : 		switch (filterNumber)

  00122	8b 4d 08	 mov	 ecx, DWORD PTR _filterNumber$[ebp]
  00125	89 4d f0	 mov	 DWORD PTR tv139[ebp], ecx
  00128	83 7d f0 00	 cmp	 DWORD PTR tv139[ebp], 0
  0012c	74 0e		 je	 SHORT $LN6@HiberDrive
  0012e	83 7d f0 01	 cmp	 DWORD PTR tv139[ebp], 1
  00132	74 14		 je	 SHORT $LN5@HiberDrive
  00134	83 7d f0 02	 cmp	 DWORD PTR tv139[ebp], 2
  00138	74 1a		 je	 SHORT $LN4@HiberDrive
  0013a	eb 24		 jmp	 SHORT $LN3@HiberDrive
$LN6@HiberDrive:

; 998  : 		{
; 999  : 		case 0: hiberDriverContext->WriteFunctionB = HiberDriverWriteFunctionBFilter0; break;

  0013c	8b 55 10	 mov	 edx, DWORD PTR _hiberDriverContext$[ebp]
  0013f	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], OFFSET _HiberDriverWriteFunctionBFilter0@8
  00146	eb 2e		 jmp	 SHORT $LN7@HiberDrive
$LN5@HiberDrive:

; 1000 : 		case 1: hiberDriverContext->WriteFunctionB = HiberDriverWriteFunctionBFilter1; break;

  00148	8b 45 10	 mov	 eax, DWORD PTR _hiberDriverContext$[ebp]
  0014b	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], OFFSET _HiberDriverWriteFunctionBFilter1@8
  00152	eb 22		 jmp	 SHORT $LN7@HiberDrive
$LN4@HiberDrive:

; 1001 : 		case 2: hiberDriverContext->WriteFunctionB = HiberDriverWriteFunctionBFilter2; break;

  00154	8b 4d 10	 mov	 ecx, DWORD PTR _hiberDriverContext$[ebp]
  00157	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], OFFSET _HiberDriverWriteFunctionBFilter2@8
  0015e	eb 16		 jmp	 SHORT $LN7@HiberDrive
$LN3@HiberDrive:

; 1002 : 		default: TC_THROW_FATAL_EXCEPTION;

  00160	68 43 54 00 00	 push	 21571			; 00005443H
  00165	6a 00		 push	 0
  00167	6a 00		 push	 0
  00169	68 ea 03 00 00	 push	 1002			; 000003eaH
  0016e	6a 29		 push	 41			; 00000029H
  00170	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN7@HiberDrive:

; 1003 : 		}
; 1004 : 
; 1005 : 		filterInstalled = TRUE;

  00176	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _filterInstalled$[ebp], 1
$LN9@HiberDrive:

; 1006 : 	}
; 1007 : 
; 1008 : 	if (filterInstalled && hiberDriverContext->PartitionStartOffset.QuadPart != 0)

  0017d	83 7d fc 00	 cmp	 DWORD PTR _filterInstalled$[ebp], 0
  00181	74 5b		 je	 SHORT $LN2@HiberDrive
  00183	8b 55 10	 mov	 edx, DWORD PTR _hiberDriverContext$[ebp]
  00186	89 55 ec	 mov	 DWORD PTR tv189[ebp], edx
  00189	8b 45 ec	 mov	 eax, DWORD PTR tv189[ebp]
  0018c	8b 4d ec	 mov	 ecx, DWORD PTR tv189[ebp]
  0018f	8b 50 70	 mov	 edx, DWORD PTR [eax+112]
  00192	0b 51 74	 or	 edx, DWORD PTR [ecx+116]
  00195	74 47		 je	 SHORT $LN2@HiberDrive

; 1009 : 	{
; 1010 : 		HiberPartitionOffset = hiberDriverContext->PartitionStartOffset;

  00197	8b 45 10	 mov	 eax, DWORD PTR _hiberDriverContext$[ebp]
  0019a	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  0019d	8b 50 74	 mov	 edx, DWORD PTR [eax+116]
  001a0	89 0d 00 00 00
	00		 mov	 DWORD PTR _HiberPartitionOffset, ecx
  001a6	89 15 04 00 00
	00		 mov	 DWORD PTR _HiberPartitionOffset+4, edx

; 1011 : 
; 1012 : 		if (BootDriveFilterExtension->Queue.RemapEncryptedArea)

  001ac	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  001b1	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  001b8	74 24		 je	 SHORT $LN2@HiberDrive

; 1013 : 			hiberDriverContext->PartitionStartOffset.QuadPart += BootDriveFilterExtension->Queue.RemappedAreaOffset;

  001ba	8b 4d 10	 mov	 ecx, DWORD PTR _hiberDriverContext$[ebp]
  001bd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _BootDriveFilterExtension
  001c3	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  001c6	03 82 a8 00 00
	00		 add	 eax, DWORD PTR [edx+168]
  001cc	8b 49 74	 mov	 ecx, DWORD PTR [ecx+116]
  001cf	13 8a ac 00 00
	00		 adc	 ecx, DWORD PTR [edx+172]
  001d5	8b 55 10	 mov	 edx, DWORD PTR _hiberDriverContext$[ebp]
  001d8	89 42 70	 mov	 DWORD PTR [edx+112], eax
  001db	89 4a 74	 mov	 DWORD PTR [edx+116], ecx
$LN2@HiberDrive:

; 1014 : 	}
; 1015 : 
; 1016 : 	return STATUS_SUCCESS;

  001de	33 c0		 xor	 eax, eax
$LN22@HiberDrive:

; 1017 : }

  001e0	8b e5		 mov	 esp, ebp
  001e2	5d		 pop	 ebp
  001e3	c2 0c 00	 ret	 12			; 0000000cH
_HiberDriverEntryFilter@12 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _HiberDriverWriteFunctionAFilter0@16
_TEXT	SEGMENT
_arg0$ = 8						; size = 4
_writeOffset$ = 12					; size = 4
_dataMdl$ = 16						; size = 4
_arg3$ = 20						; size = 4
_HiberDriverWriteFunctionAFilter0@16 PROC		; COMDAT

; 929  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 930  : 	return HiberDriverWriteFunctionFilter (0, writeOffset, dataMdl, FALSE, arg0, arg3);

  00005	8b 45 14	 mov	 eax, DWORD PTR _arg3$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _arg0$[ebp]
  0000c	51		 push	 ecx
  0000d	6a 00		 push	 0
  0000f	8b 55 10	 mov	 edx, DWORD PTR _dataMdl$[ebp]
  00012	52		 push	 edx
  00013	8b 45 0c	 mov	 eax, DWORD PTR _writeOffset$[ebp]
  00016	50		 push	 eax
  00017	6a 00		 push	 0
  00019	e8 00 00 00 00	 call	 _HiberDriverWriteFunctionFilter@24

; 931  : }

  0001e	5d		 pop	 ebp
  0001f	c2 10 00	 ret	 16			; 00000010H
_HiberDriverWriteFunctionAFilter0@16 ENDP
_TEXT	ENDS
EXTRN	_EncryptDataUnitsCurrentThread@20:PROC
EXTRN	_GetIntersection@36:PROC
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
;	COMDAT _HiberDriverWriteFunctionFilter@24
_TEXT	SEGMENT
tv205 = -48						; size = 8
_dataUnit$28368 = -40					; size = 8
_offset$28352 = -32					; size = 8
_intersectStart$28353 = -24				; size = 8
_intersectLength$28354 = -12				; size = 4
_dataLength$28350 = -8					; size = 4
_encryptedDataMdl$ = -4					; size = 4
_filterNumber$ = 8					; size = 4
_writeOffset$ = 12					; size = 4
_dataMdl$ = 16						; size = 4
_writeB$ = 20						; size = 4
_arg0WriteA$ = 24					; size = 4
_arg3WriteA$ = 28					; size = 4
_HiberDriverWriteFunctionFilter@24 PROC			; COMDAT

; 870  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 30	 sub	 esp, 48			; 00000030H

; 871  : 	MDL *encryptedDataMdl = dataMdl;

  00008	8b 45 10	 mov	 eax, DWORD PTR _dataMdl$[ebp]
  0000b	89 45 fc	 mov	 DWORD PTR _encryptedDataMdl$[ebp], eax

; 872  : 
; 873  : 	if (writeOffset && dataMdl && BootDriveFilterExtension && BootDriveFilterExtension->DriveMounted)

  0000e	83 7d 0c 00	 cmp	 DWORD PTR _writeOffset$[ebp], 0
  00012	0f 84 41 02 00
	00		 je	 $LN8@HiberDrive@2
  00018	83 7d 10 00	 cmp	 DWORD PTR _dataMdl$[ebp], 0
  0001c	0f 84 37 02 00
	00		 je	 $LN8@HiberDrive@2
  00022	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _BootDriveFilterExtension, 0
  00029	0f 84 2a 02 00
	00		 je	 $LN8@HiberDrive@2
  0002f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _BootDriveFilterExtension
  00035	83 b9 30 02 00
	00 00		 cmp	 DWORD PTR [ecx+560], 0
  0003c	0f 84 17 02 00
	00		 je	 $LN8@HiberDrive@2

; 874  : 	{
; 875  : 		ULONG dataLength = MmGetMdlByteCount (dataMdl);

  00042	8b 55 10	 mov	 edx, DWORD PTR _dataMdl$[ebp]
  00045	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00048	89 45 f8	 mov	 DWORD PTR _dataLength$28350[ebp], eax

; 876  : 
; 877  : 		if (dataMdl->MappedSystemVa && dataLength > 0)

  0004b	8b 4d 10	 mov	 ecx, DWORD PTR _dataMdl$[ebp]
  0004e	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00052	0f 84 01 02 00
	00		 je	 $LN8@HiberDrive@2
  00058	83 7d f8 00	 cmp	 DWORD PTR _dataLength$28350[ebp], 0
  0005c	0f 86 f7 01 00
	00		 jbe	 $LN8@HiberDrive@2

; 878  : 		{
; 879  : 			uint64 offset = HiberPartitionOffset.QuadPart + writeOffset->QuadPart;

  00062	8b 55 0c	 mov	 edx, DWORD PTR _writeOffset$[ebp]
  00065	a1 00 00 00 00	 mov	 eax, DWORD PTR _HiberPartitionOffset
  0006a	03 02		 add	 eax, DWORD PTR [edx]
  0006c	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _HiberPartitionOffset+4
  00072	13 4a 04	 adc	 ecx, DWORD PTR [edx+4]
  00075	89 45 e0	 mov	 DWORD PTR _offset$28352[ebp], eax
  00078	89 4d e4	 mov	 DWORD PTR _offset$28352[ebp+4], ecx

; 880  : 			uint64 intersectStart;
; 881  : 			uint32 intersectLength;
; 882  : 
; 883  : 			if (dataLength > TC_HIBERNATION_WRITE_BUFFER_SIZE)

  0007b	81 7d f8 00 00
	02 00		 cmp	 DWORD PTR _dataLength$28350[ebp], 131072 ; 00020000H
  00082	76 19		 jbe	 SHORT $LN6@HiberDrive@2

; 884  : 				TC_BUG_CHECK (STATUS_BUFFER_OVERFLOW);

  00084	68 43 54 00 00	 push	 21571			; 00005443H
  00089	6a 00		 push	 0
  0008b	68 05 00 00 80	 push	 -2147483643		; 80000005H
  00090	68 74 03 00 00	 push	 884			; 00000374H
  00095	6a 29		 push	 41			; 00000029H
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN6@HiberDrive@2:

; 885  : 
; 886  : 			if ((dataLength & (ENCRYPTION_DATA_UNIT_SIZE - 1)) != 0)

  0009d	8b 55 f8	 mov	 edx, DWORD PTR _dataLength$28350[ebp]
  000a0	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  000a6	74 19		 je	 SHORT $LN5@HiberDrive@2

; 887  : 				TC_BUG_CHECK (STATUS_INVALID_PARAMETER);

  000a8	68 43 54 00 00	 push	 21571			; 00005443H
  000ad	6a 00		 push	 0
  000af	68 0d 00 00 c0	 push	 -1073741811		; c000000dH
  000b4	68 77 03 00 00	 push	 887			; 00000377H
  000b9	6a 29		 push	 41			; 00000029H
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN5@HiberDrive@2:

; 888  : 
; 889  : 			if ((offset & (ENCRYPTION_DATA_UNIT_SIZE - 1)) != 0)

  000c1	8b 45 e0	 mov	 eax, DWORD PTR _offset$28352[ebp]
  000c4	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  000c9	8b 4d e4	 mov	 ecx, DWORD PTR _offset$28352[ebp+4]
  000cc	83 e1 00	 and	 ecx, 0
  000cf	89 45 d0	 mov	 DWORD PTR tv205[ebp], eax
  000d2	89 4d d4	 mov	 DWORD PTR tv205[ebp+4], ecx
  000d5	8b 55 d0	 mov	 edx, DWORD PTR tv205[ebp]
  000d8	0b 55 d4	 or	 edx, DWORD PTR tv205[ebp+4]
  000db	74 19		 je	 SHORT $LN4@HiberDrive@2

; 890  : 				TC_BUG_CHECK (STATUS_INVALID_PARAMETER);

  000dd	68 43 54 00 00	 push	 21571			; 00005443H
  000e2	6a 00		 push	 0
  000e4	68 0d 00 00 c0	 push	 -1073741811		; c000000dH
  000e9	68 7a 03 00 00	 push	 890			; 0000037aH
  000ee	6a 29		 push	 41			; 00000029H
  000f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN4@HiberDrive@2:

; 891  : 
; 892  : 			GetIntersection (offset,
; 893  : 				dataLength,
; 894  : 				BootDriveFilterExtension->Queue.EncryptedAreaStart,
; 895  : 				BootDriveFilterExtension->Queue.EncryptedAreaEnd,
; 896  : 				&intersectStart,
; 897  : 				&intersectLength);

  000f6	8d 45 f4	 lea	 eax, DWORD PTR _intersectLength$28354[ebp]
  000f9	50		 push	 eax
  000fa	8d 4d e8	 lea	 ecx, DWORD PTR _intersectStart$28353[ebp]
  000fd	51		 push	 ecx
  000fe	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _BootDriveFilterExtension
  00104	8b 82 9c 00 00
	00		 mov	 eax, DWORD PTR [edx+156]
  0010a	50		 push	 eax
  0010b	8b 8a 98 00 00
	00		 mov	 ecx, DWORD PTR [edx+152]
  00111	51		 push	 ecx
  00112	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _BootDriveFilterExtension
  00118	8b 82 94 00 00
	00		 mov	 eax, DWORD PTR [edx+148]
  0011e	50		 push	 eax
  0011f	8b 8a 90 00 00
	00		 mov	 ecx, DWORD PTR [edx+144]
  00125	51		 push	 ecx
  00126	8b 55 f8	 mov	 edx, DWORD PTR _dataLength$28350[ebp]
  00129	52		 push	 edx
  0012a	8b 45 e4	 mov	 eax, DWORD PTR _offset$28352[ebp+4]
  0012d	50		 push	 eax
  0012e	8b 4d e0	 mov	 ecx, DWORD PTR _offset$28352[ebp]
  00131	51		 push	 ecx
  00132	e8 00 00 00 00	 call	 _GetIntersection@36

; 898  : 
; 899  : 			if (intersectLength > 0)

  00137	83 7d f4 00	 cmp	 DWORD PTR _intersectLength$28354[ebp], 0
  0013b	0f 86 18 01 00
	00		 jbe	 $LN8@HiberDrive@2

; 900  : 			{
; 901  : 				UINT64_STRUCT dataUnit;
; 902  : 				dataUnit.Value = intersectStart / ENCRYPTION_DATA_UNIT_SIZE;

  00141	6a 00		 push	 0
  00143	68 00 02 00 00	 push	 512			; 00000200H
  00148	8b 55 ec	 mov	 edx, DWORD PTR _intersectStart$28353[ebp+4]
  0014b	52		 push	 edx
  0014c	8b 45 e8	 mov	 eax, DWORD PTR _intersectStart$28353[ebp]
  0014f	50		 push	 eax
  00150	e8 00 00 00 00	 call	 __aulldiv
  00155	89 45 d8	 mov	 DWORD PTR _dataUnit$28368[ebp], eax
  00158	89 55 dc	 mov	 DWORD PTR _dataUnit$28368[ebp+4], edx

; 903  : 
; 904  : 				memcpy (HibernationWriteBuffer, dataMdl->MappedSystemVa, dataLength);

  0015b	8b 4d f8	 mov	 ecx, DWORD PTR _dataLength$28350[ebp]
  0015e	51		 push	 ecx
  0015f	8b 55 10	 mov	 edx, DWORD PTR _dataMdl$[ebp]
  00162	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00165	50		 push	 eax
  00166	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _HibernationWriteBuffer
  0016c	51		 push	 ecx
  0016d	e8 00 00 00 00	 call	 _memcpy
  00172	83 c4 0c	 add	 esp, 12			; 0000000cH

; 905  : 
; 906  : 				if (BootDriveFilterExtension->Queue.RemapEncryptedArea)

  00175	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _BootDriveFilterExtension
  0017b	83 ba a4 00 00
	00 00		 cmp	 DWORD PTR [edx+164], 0
  00182	74 1d		 je	 SHORT $LN2@HiberDrive@2

; 907  : 					dataUnit.Value += BootDriveFilterExtension->Queue.RemappedAreaDataUnitOffset;

  00184	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  00189	8b 4d d8	 mov	 ecx, DWORD PTR _dataUnit$28368[ebp]
  0018c	03 88 b0 00 00
	00		 add	 ecx, DWORD PTR [eax+176]
  00192	8b 55 dc	 mov	 edx, DWORD PTR _dataUnit$28368[ebp+4]
  00195	13 90 b4 00 00
	00		 adc	 edx, DWORD PTR [eax+180]
  0019b	89 4d d8	 mov	 DWORD PTR _dataUnit$28368[ebp], ecx
  0019e	89 55 dc	 mov	 DWORD PTR _dataUnit$28368[ebp+4], edx
$LN2@HiberDrive@2:

; 908  : 
; 909  : 				EncryptDataUnitsCurrentThread (HibernationWriteBuffer + (intersectStart - offset),
; 910  : 					&dataUnit,
; 911  : 					intersectLength / ENCRYPTION_DATA_UNIT_SIZE,
; 912  : 					BootDriveFilterExtension->Queue.CryptoInfo);

  001a1	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  001a6	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  001a9	51		 push	 ecx
  001aa	8b 55 f4	 mov	 edx, DWORD PTR _intersectLength$28354[ebp]
  001ad	c1 ea 09	 shr	 edx, 9
  001b0	33 c0		 xor	 eax, eax
  001b2	50		 push	 eax
  001b3	52		 push	 edx
  001b4	8d 4d d8	 lea	 ecx, DWORD PTR _dataUnit$28368[ebp]
  001b7	51		 push	 ecx
  001b8	8b 55 e8	 mov	 edx, DWORD PTR _intersectStart$28353[ebp]
  001bb	2b 55 e0	 sub	 edx, DWORD PTR _offset$28352[ebp]
  001be	8b 45 ec	 mov	 eax, DWORD PTR _intersectStart$28353[ebp+4]
  001c1	1b 45 e4	 sbb	 eax, DWORD PTR _offset$28352[ebp+4]
  001c4	03 15 00 00 00
	00		 add	 edx, DWORD PTR _HibernationWriteBuffer
  001ca	52		 push	 edx
  001cb	e8 00 00 00 00	 call	 _EncryptDataUnitsCurrentThread@20

; 913  : 
; 914  : 				encryptedDataMdl = HibernationWriteBufferMdl;

  001d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _HibernationWriteBufferMdl
  001d6	89 4d fc	 mov	 DWORD PTR _encryptedDataMdl$[ebp], ecx

; 915  : 				MmInitializeMdl (encryptedDataMdl, HibernationWriteBuffer, dataLength);

  001d9	8b 55 fc	 mov	 edx, DWORD PTR _encryptedDataMdl$[ebp]
  001dc	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  001e2	8b 45 f8	 mov	 eax, DWORD PTR _dataLength$28350[ebp]
  001e5	c1 e8 0c	 shr	 eax, 12			; 0000000cH
  001e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _HibernationWriteBuffer
  001ee	81 e1 ff 0f 00
	00		 and	 ecx, 4095		; 00000fffH
  001f4	8b 55 f8	 mov	 edx, DWORD PTR _dataLength$28350[ebp]
  001f7	81 e2 ff 0f 00
	00		 and	 edx, 4095		; 00000fffH
  001fd	8d 8c 11 ff 0f
	00 00		 lea	 ecx, DWORD PTR [ecx+edx+4095]
  00204	c1 e9 0c	 shr	 ecx, 12			; 0000000cH
  00207	03 c1		 add	 eax, ecx
  00209	8d 14 85 1c 00
	00 00		 lea	 edx, DWORD PTR [eax*4+28]
  00210	8b 45 fc	 mov	 eax, DWORD PTR _encryptedDataMdl$[ebp]
  00213	66 89 50 04	 mov	 WORD PTR [eax+4], dx
  00217	33 c9		 xor	 ecx, ecx
  00219	8b 55 fc	 mov	 edx, DWORD PTR _encryptedDataMdl$[ebp]
  0021c	66 89 4a 06	 mov	 WORD PTR [edx+6], cx
  00220	a1 00 00 00 00	 mov	 eax, DWORD PTR _HibernationWriteBuffer
  00225	25 00 f0 ff ff	 and	 eax, -4096		; fffff000H
  0022a	8b 4d fc	 mov	 ecx, DWORD PTR _encryptedDataMdl$[ebp]
  0022d	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00230	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _HibernationWriteBuffer
  00236	81 e2 ff 0f 00
	00		 and	 edx, 4095		; 00000fffH
  0023c	8b 45 fc	 mov	 eax, DWORD PTR _encryptedDataMdl$[ebp]
  0023f	89 50 18	 mov	 DWORD PTR [eax+24], edx
  00242	8b 4d fc	 mov	 ecx, DWORD PTR _encryptedDataMdl$[ebp]
  00245	8b 55 f8	 mov	 edx, DWORD PTR _dataLength$28350[ebp]
  00248	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 916  : 				encryptedDataMdl->MdlFlags = dataMdl->MdlFlags;

  0024b	8b 45 fc	 mov	 eax, DWORD PTR _encryptedDataMdl$[ebp]
  0024e	8b 4d 10	 mov	 ecx, DWORD PTR _dataMdl$[ebp]
  00251	66 8b 51 06	 mov	 dx, WORD PTR [ecx+6]
  00255	66 89 50 06	 mov	 WORD PTR [eax+6], dx
$LN8@HiberDrive@2:

; 917  : 			}
; 918  : 		}
; 919  : 	}
; 920  : 
; 921  : 	if (writeB)

  00259	83 7d 14 00	 cmp	 DWORD PTR _writeB$[ebp], 0
  0025d	74 16		 je	 SHORT $LN1@HiberDrive@2

; 922  : 		return (*OriginalHiberDriverWriteFunctionsB[filterNumber]) (writeOffset, encryptedDataMdl);

  0025f	8b 45 fc	 mov	 eax, DWORD PTR _encryptedDataMdl$[ebp]
  00262	50		 push	 eax
  00263	8b 4d 0c	 mov	 ecx, DWORD PTR _writeOffset$[ebp]
  00266	51		 push	 ecx
  00267	8b 55 08	 mov	 edx, DWORD PTR _filterNumber$[ebp]
  0026a	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _OriginalHiberDriverWriteFunctionsB[edx*4]
  00271	ff d0		 call	 eax
  00273	eb 1c		 jmp	 SHORT $LN10@HiberDrive@2
$LN1@HiberDrive@2:

; 923  : 	
; 924  : 	return (*OriginalHiberDriverWriteFunctionsA[filterNumber]) (arg0WriteA, writeOffset, encryptedDataMdl, arg3WriteA);

  00275	8b 4d 1c	 mov	 ecx, DWORD PTR _arg3WriteA$[ebp]
  00278	51		 push	 ecx
  00279	8b 55 fc	 mov	 edx, DWORD PTR _encryptedDataMdl$[ebp]
  0027c	52		 push	 edx
  0027d	8b 45 0c	 mov	 eax, DWORD PTR _writeOffset$[ebp]
  00280	50		 push	 eax
  00281	8b 4d 18	 mov	 ecx, DWORD PTR _arg0WriteA$[ebp]
  00284	51		 push	 ecx
  00285	8b 55 08	 mov	 edx, DWORD PTR _filterNumber$[ebp]
  00288	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _OriginalHiberDriverWriteFunctionsA[edx*4]
  0028f	ff d0		 call	 eax
$LN10@HiberDrive@2:

; 925  : }

  00291	8b e5		 mov	 esp, ebp
  00293	5d		 pop	 ebp
  00294	c2 18 00	 ret	 24			; 00000018H
_HiberDriverWriteFunctionFilter@24 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _HiberDriverWriteFunctionAFilter1@16
_TEXT	SEGMENT
_arg0$ = 8						; size = 4
_writeOffset$ = 12					; size = 4
_dataMdl$ = 16						; size = 4
_arg3$ = 20						; size = 4
_HiberDriverWriteFunctionAFilter1@16 PROC		; COMDAT

; 934  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 935  : 	return HiberDriverWriteFunctionFilter (1, writeOffset, dataMdl, FALSE, arg0, arg3);

  00005	8b 45 14	 mov	 eax, DWORD PTR _arg3$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _arg0$[ebp]
  0000c	51		 push	 ecx
  0000d	6a 00		 push	 0
  0000f	8b 55 10	 mov	 edx, DWORD PTR _dataMdl$[ebp]
  00012	52		 push	 edx
  00013	8b 45 0c	 mov	 eax, DWORD PTR _writeOffset$[ebp]
  00016	50		 push	 eax
  00017	6a 01		 push	 1
  00019	e8 00 00 00 00	 call	 _HiberDriverWriteFunctionFilter@24

; 936  : }

  0001e	5d		 pop	 ebp
  0001f	c2 10 00	 ret	 16			; 00000010H
_HiberDriverWriteFunctionAFilter1@16 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _HiberDriverWriteFunctionAFilter2@16
_TEXT	SEGMENT
_arg0$ = 8						; size = 4
_writeOffset$ = 12					; size = 4
_dataMdl$ = 16						; size = 4
_arg3$ = 20						; size = 4
_HiberDriverWriteFunctionAFilter2@16 PROC		; COMDAT

; 939  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 940  : 	return HiberDriverWriteFunctionFilter (2, writeOffset, dataMdl, FALSE, arg0, arg3);

  00005	8b 45 14	 mov	 eax, DWORD PTR _arg3$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _arg0$[ebp]
  0000c	51		 push	 ecx
  0000d	6a 00		 push	 0
  0000f	8b 55 10	 mov	 edx, DWORD PTR _dataMdl$[ebp]
  00012	52		 push	 edx
  00013	8b 45 0c	 mov	 eax, DWORD PTR _writeOffset$[ebp]
  00016	50		 push	 eax
  00017	6a 02		 push	 2
  00019	e8 00 00 00 00	 call	 _HiberDriverWriteFunctionFilter@24

; 941  : }

  0001e	5d		 pop	 ebp
  0001f	c2 10 00	 ret	 16			; 00000010H
_HiberDriverWriteFunctionAFilter2@16 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _HiberDriverWriteFunctionBFilter0@8
_TEXT	SEGMENT
_writeOffset$ = 8					; size = 4
_dataMdl$ = 12						; size = 4
_HiberDriverWriteFunctionBFilter0@8 PROC		; COMDAT

; 945  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 946  : 	return HiberDriverWriteFunctionFilter (0, writeOffset, dataMdl, TRUE, 0, NULL);

  00005	6a 00		 push	 0
  00007	6a 00		 push	 0
  00009	6a 01		 push	 1
  0000b	8b 45 0c	 mov	 eax, DWORD PTR _dataMdl$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _writeOffset$[ebp]
  00012	51		 push	 ecx
  00013	6a 00		 push	 0
  00015	e8 00 00 00 00	 call	 _HiberDriverWriteFunctionFilter@24

; 947  : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
_HiberDriverWriteFunctionBFilter0@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _HiberDriverWriteFunctionBFilter1@8
_TEXT	SEGMENT
_writeOffset$ = 8					; size = 4
_dataMdl$ = 12						; size = 4
_HiberDriverWriteFunctionBFilter1@8 PROC		; COMDAT

; 950  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 951  : 	return HiberDriverWriteFunctionFilter (1, writeOffset, dataMdl, TRUE, 0, NULL);

  00005	6a 00		 push	 0
  00007	6a 00		 push	 0
  00009	6a 01		 push	 1
  0000b	8b 45 0c	 mov	 eax, DWORD PTR _dataMdl$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _writeOffset$[ebp]
  00012	51		 push	 ecx
  00013	6a 01		 push	 1
  00015	e8 00 00 00 00	 call	 _HiberDriverWriteFunctionFilter@24

; 952  : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
_HiberDriverWriteFunctionBFilter1@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _HiberDriverWriteFunctionBFilter2@8
_TEXT	SEGMENT
_writeOffset$ = 8					; size = 4
_dataMdl$ = 12						; size = 4
_HiberDriverWriteFunctionBFilter2@8 PROC		; COMDAT

; 955  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 956  : 	return HiberDriverWriteFunctionFilter (2, writeOffset, dataMdl, TRUE, 0, NULL);

  00005	6a 00		 push	 0
  00007	6a 00		 push	 0
  00009	6a 01		 push	 1
  0000b	8b 45 0c	 mov	 eax, DWORD PTR _dataMdl$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _writeOffset$[ebp]
  00012	51		 push	 ecx
  00013	6a 02		 push	 2
  00015	e8 00 00 00 00	 call	 _HiberDriverWriteFunctionFilter@24

; 957  : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
_HiberDriverWriteFunctionBFilter2@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _HiberDriverEntryFilter1@8
_TEXT	SEGMENT
_arg0$ = 8						; size = 4
_hiberDriverContext$ = 12				; size = 4
_HiberDriverEntryFilter1@8 PROC				; COMDAT

; 1027 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1028 : 	return HiberDriverEntryFilter (1, arg0, hiberDriverContext);

  00005	8b 45 0c	 mov	 eax, DWORD PTR _hiberDriverContext$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _arg0$[ebp]
  0000c	51		 push	 ecx
  0000d	6a 01		 push	 1
  0000f	e8 00 00 00 00	 call	 _HiberDriverEntryFilter@12

; 1029 : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
_HiberDriverEntryFilter1@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _HiberDriverEntryFilter2@8
_TEXT	SEGMENT
_arg0$ = 8						; size = 4
_hiberDriverContext$ = 12				; size = 4
_HiberDriverEntryFilter2@8 PROC				; COMDAT

; 1033 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1034 : 	return HiberDriverEntryFilter (2, arg0, hiberDriverContext);

  00005	8b 45 0c	 mov	 eax, DWORD PTR _hiberDriverContext$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _arg0$[ebp]
  0000c	51		 push	 ecx
  0000d	6a 02		 push	 2
  0000f	e8 00 00 00 00	 call	 _HiberDriverEntryFilter@12

; 1035 : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
_HiberDriverEntryFilter2@8 ENDP
_TEXT	ENDS
PUBLIC	_KeInitializeSpinLock@4
PUBLIC	_AbortBootEncryptionSetup@0
PUBLIC	_StartBootEncryptionSetup@12
EXTRN	_TCStartThread@12:PROC
_BSS	SEGMENT
_SetupStatusEncryptedAreaEnd DQ 01H DUP (?)
_SetupStatusSpinLock DD 01H DUP (?)
_EncryptionSetupThreadAbortRequested DD 01H DUP (?)
_SetupRequest DB 010H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
;	COMDAT _StartBootEncryptionSetup@12
_TEXT	SEGMENT
tv84 = -12						; size = 8
_status$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_irp$ = 12						; size = 4
_irpSp$ = 16						; size = 4
_StartBootEncryptionSetup@12 PROC			; COMDAT

; 1473 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1474 : 	NTSTATUS status;
; 1475 : 
; 1476 : 	if (!UserCanAccessDriveDevice())

  00008	e8 00 00 00 00	 call	 _UserCanAccessDriveDevice@0
  0000d	85 c0		 test	 eax, eax
  0000f	75 0a		 jne	 SHORT $LN5@StartBootE

; 1477 : 		return STATUS_ACCESS_DENIED;

  00011	b8 22 00 00 c0	 mov	 eax, -1073741790	; c0000022H
  00016	e9 0a 01 00 00	 jmp	 $LN6@StartBootE
$LN5@StartBootE:

; 1478 : 
; 1479 : 	if (SetupInProgress || !BootDriveFound || !BootDriveFilterExtension
; 1480 : 		|| !BootDriveFilterExtension->DriveMounted
; 1481 : 		|| BootDriveFilterExtension->HiddenSystem
; 1482 : 		|| irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (BootEncryptionSetupRequest))

  0001b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SetupInProgress, 0
  00022	75 38		 jne	 SHORT $LN3@StartBootE
  00024	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _BootDriveFound, 0
  0002b	74 2f		 je	 SHORT $LN3@StartBootE
  0002d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _BootDriveFilterExtension, 0
  00034	74 26		 je	 SHORT $LN3@StartBootE
  00036	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  0003b	83 b8 30 02 00
	00 00		 cmp	 DWORD PTR [eax+560], 0
  00042	74 18		 je	 SHORT $LN3@StartBootE
  00044	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _BootDriveFilterExtension
  0004a	83 b9 48 02 00
	00 00		 cmp	 DWORD PTR [ecx+584], 0
  00051	75 09		 jne	 SHORT $LN3@StartBootE
  00053	8b 55 10	 mov	 edx, DWORD PTR _irpSp$[ebp]
  00056	83 7a 08 10	 cmp	 DWORD PTR [edx+8], 16	; 00000010H
  0005a	73 0a		 jae	 SHORT $LN4@StartBootE
$LN3@StartBootE:

; 1483 : 		return STATUS_INVALID_PARAMETER;

  0005c	b8 0d 00 00 c0	 mov	 eax, -1073741811	; c000000dH
  00061	e9 bf 00 00 00	 jmp	 $LN6@StartBootE
$LN4@StartBootE:

; 1484 : 
; 1485 : 	if (EncryptionSetupThread)

  00066	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _EncryptionSetupThread, 0
  0006d	74 05		 je	 SHORT $LN2@StartBootE

; 1486 : 		AbortBootEncryptionSetup();

  0006f	e8 00 00 00 00	 call	 _AbortBootEncryptionSetup@0
$LN2@StartBootE:

; 1487 : 
; 1488 : 	SetupRequest = *(BootEncryptionSetupRequest *) irp->AssociatedIrp.SystemBuffer;

  00074	8b 45 0c	 mov	 eax, DWORD PTR _irp$[ebp]
  00077	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0007a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007c	89 15 00 00 00
	00		 mov	 DWORD PTR _SetupRequest, edx
  00082	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00085	a3 04 00 00 00	 mov	 DWORD PTR _SetupRequest+4, eax
  0008a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0008d	89 15 08 00 00
	00		 mov	 DWORD PTR _SetupRequest+8, edx
  00093	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00096	a3 0c 00 00 00	 mov	 DWORD PTR _SetupRequest+12, eax

; 1489 : 
; 1490 : 	EncryptionSetupThreadAbortRequested = FALSE;

  0009b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _EncryptionSetupThreadAbortRequested, 0

; 1491 : 	KeInitializeSpinLock (&SetupStatusSpinLock);

  000a5	68 00 00 00 00	 push	 OFFSET _SetupStatusSpinLock
  000aa	e8 00 00 00 00	 call	 _KeInitializeSpinLock@4

; 1492 : 	SetupStatusEncryptedAreaEnd = BootDriveFilterExtension ? BootDriveFilterExtension->Queue.EncryptedAreaEnd : -1;

  000af	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _BootDriveFilterExtension, 0
  000b6	74 1a		 je	 SHORT $LN8@StartBootE
  000b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _BootDriveFilterExtension
  000be	8b 91 98 00 00
	00		 mov	 edx, DWORD PTR [ecx+152]
  000c4	89 55 f4	 mov	 DWORD PTR tv84[ebp], edx
  000c7	8b 81 9c 00 00
	00		 mov	 eax, DWORD PTR [ecx+156]
  000cd	89 45 f8	 mov	 DWORD PTR tv84[ebp+4], eax
  000d0	eb 0e		 jmp	 SHORT $LN9@StartBootE
$LN8@StartBootE:
  000d2	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR tv84[ebp], -1
  000d9	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv84[ebp+4], -1
$LN9@StartBootE:
  000e0	8b 4d f4	 mov	 ecx, DWORD PTR tv84[ebp]
  000e3	89 0d 00 00 00
	00		 mov	 DWORD PTR _SetupStatusEncryptedAreaEnd, ecx
  000e9	8b 55 f8	 mov	 edx, DWORD PTR tv84[ebp+4]
  000ec	89 15 04 00 00
	00		 mov	 DWORD PTR _SetupStatusEncryptedAreaEnd+4, edx

; 1493 : 
; 1494 : 	SetupInProgress = TRUE;

  000f2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _SetupInProgress, 1

; 1495 : 	status = TCStartThread (SetupThreadProc, DeviceObject, &EncryptionSetupThread);

  000fc	68 00 00 00 00	 push	 OFFSET _EncryptionSetupThread
  00101	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00104	50		 push	 eax
  00105	68 00 00 00 00	 push	 OFFSET _SetupThreadProc@4
  0010a	e8 00 00 00 00	 call	 _TCStartThread@12
  0010f	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 1496 : 	
; 1497 : 	if (!NT_SUCCESS (status))

  00112	83 7d fc 00	 cmp	 DWORD PTR _status$[ebp], 0
  00116	7d 0a		 jge	 SHORT $LN1@StartBootE

; 1498 : 		SetupInProgress = FALSE;

  00118	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _SetupInProgress, 0
$LN1@StartBootE:

; 1499 : 
; 1500 : 	return status;

  00122	8b 45 fc	 mov	 eax, DWORD PTR _status$[ebp]
$LN6@StartBootE:

; 1501 : }

  00125	8b e5		 mov	 esp, ebp
  00127	5d		 pop	 ebp
  00128	c2 0c 00	 ret	 12			; 0000000cH
_StartBootEncryptionSetup@12 ENDP
; Function compile flags: /Odtp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT _KeInitializeSpinLock@4
_TEXT	SEGMENT
_SpinLock$ = 8						; size = 4
_KeInitializeSpinLock@4 PROC				; COMDAT

; 15095: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 15096: 
; 15097:     *SpinLock = 0;

  00005	8b 45 08	 mov	 eax, DWORD PTR _SpinLock$[ebp]
  00008	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 15098:     return;
; 15099: }

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
_KeInitializeSpinLock@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0FE@OKPCPDJI@Setup?5completed?3?5?5EncryptedAreaS@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BE@IDPHHPHP@NT_SUCCESS?5?$CIstatus?$CJ?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BI@LEBDPHBF@TCWriteDevice?5error?5?$CFx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CF@CKMJEIIB@TCReadDevice?5error?5?$CFx?5?5offset?$DN?$CFI@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DK@GDPNMFEK@EncryptedAreaStart?$DN?$CFI64d?5?$CI?$CFI64d?$CJ@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0O@CPDGLKAG@offset?$DN?$CFI64d?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CC@FCINBIJC@ConfiguredEncryptedAreaEnd?$DN?$CFI64d@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CE@PHJPGEOK@ConfiguredEncryptedAreaStart?$DN?$CFI6@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BI@NGOBDECI@EncryptedAreaEnd?$DN?$CFI64d?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BK@NLGNMKFH@EncryptedAreaStart?$DN?$CFI64d?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0P@DCAIKIEM@Decrypting?4?4?4?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0P@MEMLEIEJ@Encrypting?4?4?4?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp__PsTerminateSystemThread@4:PROC
EXTRN	_RootDeviceControlMutexRelease@0:PROC
EXTRN	_TCSleep@4:PROC
EXTRN	_RootDeviceControlMutexAcquireNoWait@0:PROC
EXTRN	_EncryptedIoQueueIsSuspended@4:PROC
EXTRN	__imp_@KfReleaseSpinLock@8:PROC
EXTRN	__imp_@KfAcquireSpinLock@4:PROC
EXTRN	_DecryptDataUnits@16:PROC
EXTRN	_TCWriteDevice@20:PROC
EXTRN	_WipeBuffer@20:PROC
EXTRN	_GetWipePassCount@4:PROC
EXTRN	_EncryptDataUnits@16:PROC
EXTRN	_ReadDeviceSkipUnreadableSectors@24:PROC
EXTRN	_ZeroUnreadableSectors@20:PROC
EXTRN	_EncryptedIoQueueResumeFromHold@4:PROC
EXTRN	_EncryptedIoQueueHoldWhenIdle@12:PROC
_BSS	SEGMENT
_TransformWaitingForIdle DD 01H DUP (?)
_SetupResult DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0FE@OKPCPDJI@Setup?5completed?3?5?5EncryptedAreaS@FNODOBFM@
; File c:\users\public\desktop\projects\ciphershed\src\driver\drivefilter.c
text$s	SEGMENT
??_C@_0FE@OKPCPDJI@Setup?5completed?3?5?5EncryptedAreaS@FNODOBFM@ DB 'Set'
	DB	'up completed:  EncryptedAreaStart=%I64d (%I64d)  EncryptedAre'
	DB	'aEnd=%I64d (%I64d)', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BE@IDPHHPHP@NT_SUCCESS?5?$CIstatus?$CJ?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BE@IDPHHPHP@NT_SUCCESS?5?$CIstatus?$CJ?$AA@FNODOBFM@ DB 'NT_SUCCES'
	DB	'S (status)', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BI@LEBDPHBF@TCWriteDevice?5error?5?$CFx?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BI@LEBDPHBF@TCWriteDevice?5error?5?$CFx?6?$AA@FNODOBFM@ DB 'TCWrit'
	DB	'eDevice error %x', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CF@CKMJEIIB@TCReadDevice?5error?5?$CFx?5?5offset?$DN?$CFI@FNODOBFM@
text$s	SEGMENT
??_C@_0CF@CKMJEIIB@TCReadDevice?5error?5?$CFx?5?5offset?$DN?$CFI@FNODOBFM@ DB 'T'
	DB	'CReadDevice error %x  offset=%I64d', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DK@GDPNMFEK@EncryptedAreaStart?$DN?$CFI64d?5?$CI?$CFI64d?$CJ@FNODOBFM@
text$s	SEGMENT
??_C@_0DK@GDPNMFEK@EncryptedAreaStart?$DN?$CFI64d?5?$CI?$CFI64d?$CJ@FNODOBFM@ DB 'E'
	DB	'ncryptedAreaStart=%I64d (%I64d)  EncryptedAreaEnd=%I64d', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0O@CPDGLKAG@offset?$DN?$CFI64d?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0O@CPDGLKAG@offset?$DN?$CFI64d?6?$AA@FNODOBFM@ DB 'offset=%I64d', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CC@FCINBIJC@ConfiguredEncryptedAreaEnd?$DN?$CFI64d@FNODOBFM@
text$s	SEGMENT
??_C@_0CC@FCINBIJC@ConfiguredEncryptedAreaEnd?$DN?$CFI64d@FNODOBFM@ DB 'C'
	DB	'onfiguredEncryptedAreaEnd=%I64d', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CE@PHJPGEOK@ConfiguredEncryptedAreaStart?$DN?$CFI6@FNODOBFM@
text$s	SEGMENT
??_C@_0CE@PHJPGEOK@ConfiguredEncryptedAreaStart?$DN?$CFI6@FNODOBFM@ DB 'C'
	DB	'onfiguredEncryptedAreaStart=%I64d', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BI@NGOBDECI@EncryptedAreaEnd?$DN?$CFI64d?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BI@NGOBDECI@EncryptedAreaEnd?$DN?$CFI64d?6?$AA@FNODOBFM@ DB 'Encry'
	DB	'ptedAreaEnd=%I64d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BK@NLGNMKFH@EncryptedAreaStart?$DN?$CFI64d?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BK@NLGNMKFH@EncryptedAreaStart?$DN?$CFI64d?6?$AA@FNODOBFM@ DB 'Enc'
	DB	'ryptedAreaStart=%I64d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0P@DCAIKIEM@Decrypting?4?4?4?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0P@DCAIKIEM@Decrypting?4?4?4?6?$AA@FNODOBFM@ DB 'Decrypting...', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0P@MEMLEIEJ@Encrypting?4?4?4?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0P@MEMLEIEJ@Encrypting?4?4?4?6?$AA@FNODOBFM@ DB 'Encrypting...', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _SetupThreadProc@4
_TEXT	SEGMENT
tv988 = -192						; size = 4
tv894 = -188						; size = 8
tv893 = -180						; size = 4
tv877 = -176						; size = 8
tv366 = -168						; size = 4
tv682 = -164						; size = 4
tv660 = -160						; size = 4
tv657 = -156						; size = 8
tv642 = -148						; size = 4
tv624 = -144						; size = 8
tv621 = -136						; size = 8
tv504 = -128						; size = 8
tv494 = -120						; size = 4
tv480 = -116						; size = 4
tv477 = -112						; size = 8
tv454 = -104						; size = 8
tv444 = -96						; size = 4
tv85 = -92						; size = 4
_i$28664 = -88						; size = 4
_wipePass$28659 = -81					; size = 1
_badSectorCount$28653 = -80				; size = 8
_zeroedSectorCount$28646 = -72				; size = 8
_buffer$ = -60						; size = 4
_status$ = -56						; size = 4
_wipeRandChars$ = -52					; size = 3
_offset$ = -48						; size = 8
_bytesWrittenSinceHeaderUpdate$ = -40			; size = 8
_Extension$ = -32					; size = 4
_setupBlockSize$ = -28					; size = 4
_headerUpdateRequired$ = -24				; size = 4
_wipeBuffer$ = -20					; size = 4
_dataUnit$ = -16					; size = 8
_wipeRandCharsUpdate$ = -8				; size = 3
_irql$ = -1						; size = 1
_threadArg$ = 8						; size = 4
_SetupThreadProc@4 PROC					; COMDAT

; 1154 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  0000b	56		 push	 esi

; 1155 : 	DriveFilterExtension *Extension = BootDriveFilterExtension;

  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  00011	89 45 e0	 mov	 DWORD PTR _Extension$[ebp], eax

; 1156 : 
; 1157 : 	LARGE_INTEGER offset;
; 1158 : 	UINT64_STRUCT dataUnit;
; 1159 : 	ULONG setupBlockSize = TC_ENCRYPTION_SETUP_IO_BLOCK_SIZE;

  00014	c7 45 e4 00 00
	18 00		 mov	 DWORD PTR _setupBlockSize$[ebp], 1572864 ; 00180000H

; 1160 : 	BOOL headerUpdateRequired = FALSE;

  0001b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _headerUpdateRequired$[ebp], 0

; 1161 : 	int64 bytesWrittenSinceHeaderUpdate = 0;

  00022	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _bytesWrittenSinceHeaderUpdate$[ebp], 0
  00029	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _bytesWrittenSinceHeaderUpdate$[ebp+4], 0

; 1162 : 
; 1163 : 	byte *buffer = NULL;

  00030	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _buffer$[ebp], 0

; 1164 : 	byte *wipeBuffer = NULL;

  00037	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _wipeBuffer$[ebp], 0

; 1165 : 	byte wipeRandChars[TC_WIPE_RAND_CHAR_COUNT];
; 1166 : 	byte wipeRandCharsUpdate[TC_WIPE_RAND_CHAR_COUNT];
; 1167 : 	
; 1168 : 	KIRQL irql;
; 1169 : 	NTSTATUS status;
; 1170 : 
; 1171 : 	SetupResult = STATUS_UNSUCCESSFUL;

  0003e	c7 05 00 00 00
	00 01 00 00 c0	 mov	 DWORD PTR _SetupResult, -1073741823 ; c0000001H

; 1172 : 
; 1173 : 	// Make sure volume header can be updated
; 1174 : 	if (Extension->HeaderCryptoInfo == NULL)

  00048	8b 4d e0	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0004b	83 b9 44 02 00
	00 00		 cmp	 DWORD PTR [ecx+580], 0
  00052	75 0f		 jne	 SHORT $LN67@SetupThrea

; 1175 : 	{
; 1176 : 		SetupResult = STATUS_INVALID_PARAMETER;

  00054	c7 05 00 00 00
	00 0d 00 00 c0	 mov	 DWORD PTR _SetupResult, -1073741811 ; c000000dH

; 1177 : 		goto ret;

  0005e	e9 92 0b 00 00	 jmp	 $ret$28588
$LN67@SetupThrea:

; 1178 : 	}
; 1179 : 
; 1180 : 	buffer = TCalloc (TC_ENCRYPTION_SETUP_IO_BLOCK_SIZE);

  00063	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00068	68 00 00 18 00	 push	 1572864			; 00180000H
  0006d	6a 00		 push	 0
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00075	89 45 c4	 mov	 DWORD PTR _buffer$[ebp], eax

; 1181 : 	if (!buffer)

  00078	83 7d c4 00	 cmp	 DWORD PTR _buffer$[ebp], 0
  0007c	75 0f		 jne	 SHORT $LN66@SetupThrea

; 1182 : 	{
; 1183 : 		SetupResult = STATUS_INSUFFICIENT_RESOURCES;

  0007e	c7 05 00 00 00
	00 9a 00 00 c0	 mov	 DWORD PTR _SetupResult, -1073741670 ; c000009aH

; 1184 : 		goto ret;

  00088	e9 68 0b 00 00	 jmp	 $ret$28588
$LN66@SetupThrea:

; 1185 : 	}
; 1186 : 
; 1187 : 	if (SetupRequest.SetupMode == SetupEncryption && SetupRequest.WipeAlgorithm != TC_WIPE_NONE)

  0008d	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _SetupRequest, 1
  00094	75 33		 jne	 SHORT $LN63@SetupThrea
  00096	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR _SetupRequest+4, 0
  0009d	74 2a		 je	 SHORT $LN63@SetupThrea

; 1188 : 	{
; 1189 : 		wipeBuffer = TCalloc (TC_ENCRYPTION_SETUP_IO_BLOCK_SIZE);

  0009f	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  000a4	68 00 00 18 00	 push	 1572864			; 00180000H
  000a9	6a 00		 push	 0
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  000b1	89 45 ec	 mov	 DWORD PTR _wipeBuffer$[ebp], eax

; 1190 : 		if (!wipeBuffer)

  000b4	83 7d ec 00	 cmp	 DWORD PTR _wipeBuffer$[ebp], 0
  000b8	75 0f		 jne	 SHORT $LN63@SetupThrea

; 1191 : 		{
; 1192 : 			SetupResult = STATUS_INSUFFICIENT_RESOURCES;

  000ba	c7 05 00 00 00
	00 9a 00 00 c0	 mov	 DWORD PTR _SetupResult, -1073741670 ; c000009aH

; 1193 : 			goto ret;

  000c4	e9 2c 0b 00 00	 jmp	 $ret$28588
$LN63@SetupThrea:

; 1194 : 		}
; 1195 : 	}
; 1196 : 
; 1197 : 	while (!NT_SUCCESS (EncryptedIoQueueHoldWhenIdle (&Extension->Queue, 1000)))

  000c9	6a 00		 push	 0
  000cb	68 e8 03 00 00	 push	 1000			; 000003e8H
  000d0	8b 55 e0	 mov	 edx, DWORD PTR _Extension$[ebp]
  000d3	83 c2 48	 add	 edx, 72			; 00000048H
  000d6	52		 push	 edx
  000d7	e8 00 00 00 00	 call	 _EncryptedIoQueueHoldWhenIdle@12
  000dc	85 c0		 test	 eax, eax
  000de	7d 1a		 jge	 SHORT $LN62@SetupThrea

; 1198 : 	{
; 1199 : 		if (EncryptionSetupThreadAbortRequested)

  000e0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _EncryptionSetupThreadAbortRequested, 0
  000e7	74 05		 je	 SHORT $LN61@SetupThrea

; 1200 : 			goto abort;

  000e9	e9 a0 08 00 00	 jmp	 $abort$28601
$LN61@SetupThrea:

; 1201 : 
; 1202 : 		TransformWaitingForIdle = TRUE;

  000ee	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _TransformWaitingForIdle, 1

; 1203 : 	}

  000f8	eb cf		 jmp	 SHORT $LN63@SetupThrea
$LN62@SetupThrea:

; 1204 : 	TransformWaitingForIdle = FALSE;

  000fa	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _TransformWaitingForIdle, 0

; 1205 : 
; 1206 : 	switch (SetupRequest.SetupMode)

  00104	a1 00 00 00 00	 mov	 eax, DWORD PTR _SetupRequest
  00109	89 45 a4	 mov	 DWORD PTR tv85[ebp], eax
  0010c	83 7d a4 01	 cmp	 DWORD PTR tv85[ebp], 1
  00110	74 0f		 je	 SHORT $LN58@SetupThrea
  00112	83 7d a4 02	 cmp	 DWORD PTR tv85[ebp], 2
  00116	0f 84 e2 00 00
	00		 je	 $LN53@SetupThrea
  0011c	e9 53 01 00 00	 jmp	 $LN50@SetupThrea
$LN58@SetupThrea:

; 1207 : 	{
; 1208 : 	case SetupEncryption:
; 1209 : 		Dump ("Encrypting...\n");

  00121	68 00 00 00 00	 push	 OFFSET ??_C@_0P@MEMLEIEJ@Encrypting?4?4?4?6?$AA@FNODOBFM@
  00126	e8 00 00 00 00	 call	 _DbgPrint
  0012b	83 c4 04	 add	 esp, 4

; 1210 : 		if (Extension->Queue.EncryptedAreaStart == -1 || Extension->Queue.EncryptedAreaEnd == -1)

  0012e	8b 4d e0	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00131	89 4d a0	 mov	 DWORD PTR tv444[ebp], ecx
  00134	8b 55 a0	 mov	 edx, DWORD PTR tv444[ebp]
  00137	8b 45 a0	 mov	 eax, DWORD PTR tv444[ebp]
  0013a	8b 8a 90 00 00
	00		 mov	 ecx, DWORD PTR [edx+144]
  00140	23 88 94 00 00
	00		 and	 ecx, DWORD PTR [eax+148]
  00146	83 f9 ff	 cmp	 ecx, -1
  00149	74 20		 je	 SHORT $LN56@SetupThrea
  0014b	8b 55 e0	 mov	 edx, DWORD PTR _Extension$[ebp]
  0014e	8b 82 98 00 00
	00		 mov	 eax, DWORD PTR [edx+152]
  00154	8b 8a 9c 00 00
	00		 mov	 ecx, DWORD PTR [edx+156]
  0015a	89 45 98	 mov	 DWORD PTR tv454[ebp], eax
  0015d	89 4d 9c	 mov	 DWORD PTR tv454[ebp+4], ecx
  00160	8b 55 98	 mov	 edx, DWORD PTR tv454[ebp]
  00163	23 55 9c	 and	 edx, DWORD PTR tv454[ebp+4]
  00166	83 fa ff	 cmp	 edx, -1
  00169	75 40		 jne	 SHORT $LN57@SetupThrea
$LN56@SetupThrea:

; 1211 : 		{
; 1212 : 			// Start encryption
; 1213 : 			Extension->Queue.EncryptedAreaStart = Extension->ConfiguredEncryptedAreaStart;

  0016b	8b 45 e0	 mov	 eax, DWORD PTR _Extension$[ebp]
  0016e	8b 4d e0	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00171	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00174	89 90 90 00 00
	00		 mov	 DWORD PTR [eax+144], edx
  0017a	8b 49 34	 mov	 ecx, DWORD PTR [ecx+52]
  0017d	89 88 94 00 00
	00		 mov	 DWORD PTR [eax+148], ecx

; 1214 : 			Extension->Queue.EncryptedAreaEnd = -1;

  00183	8b 55 e0	 mov	 edx, DWORD PTR _Extension$[ebp]
  00186	c7 82 98 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+152], -1
  00190	c7 82 9c 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+156], -1

; 1215 : 			offset.QuadPart = Extension->ConfiguredEncryptedAreaStart;

  0019a	8b 45 e0	 mov	 eax, DWORD PTR _Extension$[ebp]
  0019d	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  001a0	89 4d d0	 mov	 DWORD PTR _offset$[ebp], ecx
  001a3	8b 50 34	 mov	 edx, DWORD PTR [eax+52]
  001a6	89 55 d4	 mov	 DWORD PTR _offset$[ebp+4], edx

; 1216 : 		}
; 1217 : 		else

  001a9	eb 51		 jmp	 SHORT $LN55@SetupThrea
$LN57@SetupThrea:

; 1218 : 		{
; 1219 : 			// Resume aborted encryption
; 1220 : 			if (Extension->Queue.EncryptedAreaEnd == Extension->ConfiguredEncryptedAreaEnd)

  001ab	8b 45 e0	 mov	 eax, DWORD PTR _Extension$[ebp]
  001ae	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  001b4	8b 90 9c 00 00
	00		 mov	 edx, DWORD PTR [eax+156]
  001ba	8b 45 e0	 mov	 eax, DWORD PTR _Extension$[ebp]
  001bd	89 4d 90	 mov	 DWORD PTR tv477[ebp], ecx
  001c0	89 55 94	 mov	 DWORD PTR tv477[ebp+4], edx
  001c3	89 45 8c	 mov	 DWORD PTR tv480[ebp], eax
  001c6	8b 4d 8c	 mov	 ecx, DWORD PTR tv480[ebp]
  001c9	8b 55 90	 mov	 edx, DWORD PTR tv477[ebp]
  001cc	3b 51 38	 cmp	 edx, DWORD PTR [ecx+56]
  001cf	75 10		 jne	 SHORT $LN54@SetupThrea
  001d1	8b 45 8c	 mov	 eax, DWORD PTR tv480[ebp]
  001d4	8b 4d 94	 mov	 ecx, DWORD PTR tv477[ebp+4]
  001d7	3b 48 3c	 cmp	 ecx, DWORD PTR [eax+60]
  001da	75 05		 jne	 SHORT $LN54@SetupThrea

; 1221 : 				goto err;

  001dc	e9 b7 07 00 00	 jmp	 $err$28612
$LN54@SetupThrea:

; 1222 : 
; 1223 : 			offset.QuadPart = Extension->Queue.EncryptedAreaEnd + 1;

  001e1	8b 55 e0	 mov	 edx, DWORD PTR _Extension$[ebp]
  001e4	8b 82 98 00 00
	00		 mov	 eax, DWORD PTR [edx+152]
  001ea	8b 8a 9c 00 00
	00		 mov	 ecx, DWORD PTR [edx+156]
  001f0	83 c0 01	 add	 eax, 1
  001f3	83 d1 00	 adc	 ecx, 0
  001f6	89 45 d0	 mov	 DWORD PTR _offset$[ebp], eax
  001f9	89 4d d4	 mov	 DWORD PTR _offset$[ebp+4], ecx
$LN55@SetupThrea:

; 1224 : 		}
; 1225 : 
; 1226 : 		break;

  001fc	eb 7b		 jmp	 SHORT $LN59@SetupThrea
$LN53@SetupThrea:

; 1227 : 
; 1228 : 	case SetupDecryption:
; 1229 : 		Dump ("Decrypting...\n");

  001fe	68 00 00 00 00	 push	 OFFSET ??_C@_0P@DCAIKIEM@Decrypting?4?4?4?6?$AA@FNODOBFM@
  00203	e8 00 00 00 00	 call	 _DbgPrint
  00208	83 c4 04	 add	 esp, 4

; 1230 : 		if (Extension->Queue.EncryptedAreaStart == -1 || Extension->Queue.EncryptedAreaEnd == -1)

  0020b	8b 55 e0	 mov	 edx, DWORD PTR _Extension$[ebp]
  0020e	89 55 88	 mov	 DWORD PTR tv494[ebp], edx
  00211	8b 45 88	 mov	 eax, DWORD PTR tv494[ebp]
  00214	8b 4d 88	 mov	 ecx, DWORD PTR tv494[ebp]
  00217	8b 90 90 00 00
	00		 mov	 edx, DWORD PTR [eax+144]
  0021d	23 91 94 00 00
	00		 and	 edx, DWORD PTR [ecx+148]
  00223	83 fa ff	 cmp	 edx, -1
  00226	74 20		 je	 SHORT $LN51@SetupThrea
  00228	8b 45 e0	 mov	 eax, DWORD PTR _Extension$[ebp]
  0022b	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  00231	8b 90 9c 00 00
	00		 mov	 edx, DWORD PTR [eax+156]
  00237	89 4d 80	 mov	 DWORD PTR tv504[ebp], ecx
  0023a	89 55 84	 mov	 DWORD PTR tv504[ebp+4], edx
  0023d	8b 45 80	 mov	 eax, DWORD PTR tv504[ebp]
  00240	23 45 84	 and	 eax, DWORD PTR tv504[ebp+4]
  00243	83 f8 ff	 cmp	 eax, -1
  00246	75 0f		 jne	 SHORT $LN52@SetupThrea
$LN51@SetupThrea:

; 1231 : 		{
; 1232 : 			SetupResult = STATUS_SUCCESS;

  00248	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _SetupResult, 0

; 1233 : 			goto abort;

  00252	e9 37 07 00 00	 jmp	 $abort$28601
$LN52@SetupThrea:

; 1234 : 		}
; 1235 : 
; 1236 : 		offset.QuadPart = Extension->Queue.EncryptedAreaEnd + 1;

  00257	8b 4d e0	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0025a	8b 91 98 00 00
	00		 mov	 edx, DWORD PTR [ecx+152]
  00260	8b 81 9c 00 00
	00		 mov	 eax, DWORD PTR [ecx+156]
  00266	83 c2 01	 add	 edx, 1
  00269	83 d0 00	 adc	 eax, 0
  0026c	89 55 d0	 mov	 DWORD PTR _offset$[ebp], edx
  0026f	89 45 d4	 mov	 DWORD PTR _offset$[ebp+4], eax

; 1237 : 		break;

  00272	eb 05		 jmp	 SHORT $LN59@SetupThrea
$LN50@SetupThrea:

; 1238 : 
; 1239 : 	default:
; 1240 : 		goto err;

  00274	e9 1f 07 00 00	 jmp	 $err$28612
$LN59@SetupThrea:

; 1241 : 	}
; 1242 : 
; 1243 : 	EncryptedIoQueueResumeFromHold (&Extension->Queue);

  00279	8b 4d e0	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0027c	83 c1 48	 add	 ecx, 72			; 00000048H
  0027f	51		 push	 ecx
  00280	e8 00 00 00 00	 call	 _EncryptedIoQueueResumeFromHold@4

; 1244 : 		
; 1245 : 	Dump ("EncryptedAreaStart=%I64d\n", Extension->Queue.EncryptedAreaStart);

  00285	8b 55 e0	 mov	 edx, DWORD PTR _Extension$[ebp]
  00288	8b 82 94 00 00
	00		 mov	 eax, DWORD PTR [edx+148]
  0028e	50		 push	 eax
  0028f	8b 8a 90 00 00
	00		 mov	 ecx, DWORD PTR [edx+144]
  00295	51		 push	 ecx
  00296	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@NLGNMKFH@EncryptedAreaStart?$DN?$CFI64d?6?$AA@FNODOBFM@
  0029b	e8 00 00 00 00	 call	 _DbgPrint
  002a0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1246 : 	Dump ("EncryptedAreaEnd=%I64d\n", Extension->Queue.EncryptedAreaEnd);

  002a3	8b 55 e0	 mov	 edx, DWORD PTR _Extension$[ebp]
  002a6	8b 82 9c 00 00
	00		 mov	 eax, DWORD PTR [edx+156]
  002ac	50		 push	 eax
  002ad	8b 8a 98 00 00
	00		 mov	 ecx, DWORD PTR [edx+152]
  002b3	51		 push	 ecx
  002b4	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@NGOBDECI@EncryptedAreaEnd?$DN?$CFI64d?6?$AA@FNODOBFM@
  002b9	e8 00 00 00 00	 call	 _DbgPrint
  002be	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1247 : 	Dump ("ConfiguredEncryptedAreaStart=%I64d\n", Extension->ConfiguredEncryptedAreaStart);

  002c1	8b 55 e0	 mov	 edx, DWORD PTR _Extension$[ebp]
  002c4	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  002c7	50		 push	 eax
  002c8	8b 4a 30	 mov	 ecx, DWORD PTR [edx+48]
  002cb	51		 push	 ecx
  002cc	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@PHJPGEOK@ConfiguredEncryptedAreaStart?$DN?$CFI6@FNODOBFM@
  002d1	e8 00 00 00 00	 call	 _DbgPrint
  002d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1248 : 	Dump ("ConfiguredEncryptedAreaEnd=%I64d\n", Extension->ConfiguredEncryptedAreaEnd);

  002d9	8b 55 e0	 mov	 edx, DWORD PTR _Extension$[ebp]
  002dc	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  002df	50		 push	 eax
  002e0	8b 4a 38	 mov	 ecx, DWORD PTR [edx+56]
  002e3	51		 push	 ecx
  002e4	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@FCINBIJC@ConfiguredEncryptedAreaEnd?$DN?$CFI64d@FNODOBFM@
  002e9	e8 00 00 00 00	 call	 _DbgPrint
  002ee	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1249 : 	Dump ("offset=%I64d\n", offset.QuadPart);

  002f1	8b 55 d4	 mov	 edx, DWORD PTR _offset$[ebp+4]
  002f4	52		 push	 edx
  002f5	8b 45 d0	 mov	 eax, DWORD PTR _offset$[ebp]
  002f8	50		 push	 eax
  002f9	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CPDGLKAG@offset?$DN?$CFI64d?6?$AA@FNODOBFM@
  002fe	e8 00 00 00 00	 call	 _DbgPrint
  00303	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1250 : 	Dump ("EncryptedAreaStart=%I64d (%I64d)  EncryptedAreaEnd=%I64d\n", Extension->Queue.EncryptedAreaStart / 1024 / 1024, Extension->Queue.EncryptedAreaStart, Extension->Queue.EncryptedAreaEnd / 1024 / 1024);

  00306	8b 4d e0	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00309	8b 91 98 00 00
	00		 mov	 edx, DWORD PTR [ecx+152]
  0030f	8b 81 9c 00 00
	00		 mov	 eax, DWORD PTR [ecx+156]
  00315	6a 00		 push	 0
  00317	68 00 04 00 00	 push	 1024			; 00000400H
  0031c	50		 push	 eax
  0031d	52		 push	 edx
  0031e	e8 00 00 00 00	 call	 __alldiv
  00323	6a 00		 push	 0
  00325	68 00 04 00 00	 push	 1024			; 00000400H
  0032a	52		 push	 edx
  0032b	50		 push	 eax
  0032c	e8 00 00 00 00	 call	 __alldiv
  00331	52		 push	 edx
  00332	50		 push	 eax
  00333	8b 4d e0	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00336	8b 91 94 00 00
	00		 mov	 edx, DWORD PTR [ecx+148]
  0033c	52		 push	 edx
  0033d	8b 81 90 00 00
	00		 mov	 eax, DWORD PTR [ecx+144]
  00343	50		 push	 eax
  00344	8b 4d e0	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00347	6a 00		 push	 0
  00349	68 00 04 00 00	 push	 1024			; 00000400H
  0034e	8b 91 94 00 00
	00		 mov	 edx, DWORD PTR [ecx+148]
  00354	52		 push	 edx
  00355	8b 81 90 00 00
	00		 mov	 eax, DWORD PTR [ecx+144]
  0035b	50		 push	 eax
  0035c	e8 00 00 00 00	 call	 __alldiv
  00361	6a 00		 push	 0
  00363	68 00 04 00 00	 push	 1024			; 00000400H
  00368	52		 push	 edx
  00369	50		 push	 eax
  0036a	e8 00 00 00 00	 call	 __alldiv
  0036f	52		 push	 edx
  00370	50		 push	 eax
  00371	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@GDPNMFEK@EncryptedAreaStart?$DN?$CFI64d?5?$CI?$CFI64d?$CJ@FNODOBFM@
  00376	e8 00 00 00 00	 call	 _DbgPrint
  0037b	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN49@SetupThrea:

; 1251 : 
; 1252 : 	while (!EncryptionSetupThreadAbortRequested)

  0037e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _EncryptionSetupThreadAbortRequested, 0
  00385	0f 85 03 06 00
	00		 jne	 $abort$28601

; 1253 : 	{
; 1254 : 		if (SetupRequest.SetupMode == SetupEncryption)

  0038b	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _SetupRequest, 1
  00392	0f 85 9b 00 00
	00		 jne	 $LN47@SetupThrea

; 1255 : 		{
; 1256 : 			if (offset.QuadPart + setupBlockSize > Extension->ConfiguredEncryptedAreaEnd + 1)

  00398	8b 4d e4	 mov	 ecx, DWORD PTR _setupBlockSize$[ebp]
  0039b	33 d2		 xor	 edx, edx
  0039d	03 4d d0	 add	 ecx, DWORD PTR _offset$[ebp]
  003a0	8b 45 d4	 mov	 eax, DWORD PTR _offset$[ebp+4]
  003a3	13 c2		 adc	 eax, edx
  003a5	8b 55 e0	 mov	 edx, DWORD PTR _Extension$[ebp]
  003a8	8b 72 38	 mov	 esi, DWORD PTR [edx+56]
  003ab	83 c6 01	 add	 esi, 1
  003ae	8b 52 3c	 mov	 edx, DWORD PTR [edx+60]
  003b1	83 d2 00	 adc	 edx, 0
  003b4	89 8d 78 ff ff
	ff		 mov	 DWORD PTR tv621[ebp], ecx
  003ba	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv621[ebp+4], eax
  003c0	89 b5 70 ff ff
	ff		 mov	 DWORD PTR tv624[ebp], esi
  003c6	89 95 74 ff ff
	ff		 mov	 DWORD PTR tv624[ebp+4], edx
  003cc	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv621[ebp+4]
  003d2	3b 85 74 ff ff
	ff		 cmp	 eax, DWORD PTR tv624[ebp+4]
  003d8	7c 28		 jl	 SHORT $LN46@SetupThrea
  003da	7f 0e		 jg	 SHORT $LN72@SetupThrea
  003dc	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR tv621[ebp]
  003e2	3b 8d 70 ff ff
	ff		 cmp	 ecx, DWORD PTR tv624[ebp]
  003e8	76 18		 jbe	 SHORT $LN46@SetupThrea
$LN72@SetupThrea:

; 1257 : 				setupBlockSize = (ULONG) (Extension->ConfiguredEncryptedAreaEnd + 1 - offset.QuadPart);

  003ea	8b 55 e0	 mov	 edx, DWORD PTR _Extension$[ebp]
  003ed	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  003f0	83 c0 01	 add	 eax, 1
  003f3	8b 4a 3c	 mov	 ecx, DWORD PTR [edx+60]
  003f6	83 d1 00	 adc	 ecx, 0
  003f9	2b 45 d0	 sub	 eax, DWORD PTR _offset$[ebp]
  003fc	1b 4d d4	 sbb	 ecx, DWORD PTR _offset$[ebp+4]
  003ff	89 45 e4	 mov	 DWORD PTR _setupBlockSize$[ebp], eax
$LN46@SetupThrea:

; 1258 : 
; 1259 : 			if (offset.QuadPart > Extension->ConfiguredEncryptedAreaEnd)

  00402	8b 55 e0	 mov	 edx, DWORD PTR _Extension$[ebp]
  00405	89 95 6c ff ff
	ff		 mov	 DWORD PTR tv642[ebp], edx
  0040b	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR tv642[ebp]
  00411	8b 4d d4	 mov	 ecx, DWORD PTR _offset$[ebp+4]
  00414	3b 48 3c	 cmp	 ecx, DWORD PTR [eax+60]
  00417	7c 15		 jl	 SHORT $LN45@SetupThrea
  00419	7f 0e		 jg	 SHORT $LN73@SetupThrea
  0041b	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR tv642[ebp]
  00421	8b 45 d0	 mov	 eax, DWORD PTR _offset$[ebp]
  00424	3b 42 38	 cmp	 eax, DWORD PTR [edx+56]
  00427	76 05		 jbe	 SHORT $LN45@SetupThrea
$LN73@SetupThrea:

; 1260 : 				break;

  00429	e9 60 05 00 00	 jmp	 $abort$28601
$LN45@SetupThrea:

; 1261 : 		}
; 1262 : 		else

  0042e	e9 b3 00 00 00	 jmp	 $LN40@SetupThrea
$LN47@SetupThrea:

; 1263 : 		{
; 1264 : 			if (offset.QuadPart - setupBlockSize < Extension->Queue.EncryptedAreaStart)

  00433	8b 4d e4	 mov	 ecx, DWORD PTR _setupBlockSize$[ebp]
  00436	33 d2		 xor	 edx, edx
  00438	8b 45 d0	 mov	 eax, DWORD PTR _offset$[ebp]
  0043b	2b c1		 sub	 eax, ecx
  0043d	8b 4d d4	 mov	 ecx, DWORD PTR _offset$[ebp+4]
  00440	1b ca		 sbb	 ecx, edx
  00442	8b 55 e0	 mov	 edx, DWORD PTR _Extension$[ebp]
  00445	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv657[ebp], eax
  0044b	89 8d 68 ff ff
	ff		 mov	 DWORD PTR tv657[ebp+4], ecx
  00451	89 95 60 ff ff
	ff		 mov	 DWORD PTR tv660[ebp], edx
  00457	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR tv660[ebp]
  0045d	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR tv657[ebp+4]
  00463	3b 88 94 00 00
	00		 cmp	 ecx, DWORD PTR [eax+148]
  00469	7f 2e		 jg	 SHORT $LN43@SetupThrea
  0046b	7c 14		 jl	 SHORT $LN74@SetupThrea
  0046d	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR tv660[ebp]
  00473	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv657[ebp]
  00479	3b 82 90 00 00
	00		 cmp	 eax, DWORD PTR [edx+144]
  0047f	73 18		 jae	 SHORT $LN43@SetupThrea
$LN74@SetupThrea:

; 1265 : 				setupBlockSize = (ULONG) (offset.QuadPart - Extension->Queue.EncryptedAreaStart);

  00481	8b 4d e0	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00484	8b 55 d0	 mov	 edx, DWORD PTR _offset$[ebp]
  00487	2b 91 90 00 00
	00		 sub	 edx, DWORD PTR [ecx+144]
  0048d	8b 45 d4	 mov	 eax, DWORD PTR _offset$[ebp+4]
  00490	1b 81 94 00 00
	00		 sbb	 eax, DWORD PTR [ecx+148]
  00496	89 55 e4	 mov	 DWORD PTR _setupBlockSize$[ebp], edx
$LN43@SetupThrea:

; 1266 : 
; 1267 : 			offset.QuadPart -= setupBlockSize;

  00499	8b 4d e4	 mov	 ecx, DWORD PTR _setupBlockSize$[ebp]
  0049c	33 d2		 xor	 edx, edx
  0049e	8b 45 d0	 mov	 eax, DWORD PTR _offset$[ebp]
  004a1	2b c1		 sub	 eax, ecx
  004a3	8b 4d d4	 mov	 ecx, DWORD PTR _offset$[ebp+4]
  004a6	1b ca		 sbb	 ecx, edx
  004a8	89 45 d0	 mov	 DWORD PTR _offset$[ebp], eax
  004ab	89 4d d4	 mov	 DWORD PTR _offset$[ebp+4], ecx

; 1268 : 
; 1269 : 			if (setupBlockSize == 0 || offset.QuadPart < Extension->Queue.EncryptedAreaStart)

  004ae	83 7d e4 00	 cmp	 DWORD PTR _setupBlockSize$[ebp], 0
  004b2	74 2d		 je	 SHORT $LN41@SetupThrea
  004b4	8b 55 e0	 mov	 edx, DWORD PTR _Extension$[ebp]
  004b7	89 95 5c ff ff
	ff		 mov	 DWORD PTR tv682[ebp], edx
  004bd	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR tv682[ebp]
  004c3	8b 4d d4	 mov	 ecx, DWORD PTR _offset$[ebp+4]
  004c6	3b 88 94 00 00
	00		 cmp	 ecx, DWORD PTR [eax+148]
  004cc	7f 18		 jg	 SHORT $LN40@SetupThrea
  004ce	7c 11		 jl	 SHORT $LN41@SetupThrea
  004d0	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR tv682[ebp]
  004d6	8b 45 d0	 mov	 eax, DWORD PTR _offset$[ebp]
  004d9	3b 82 90 00 00
	00		 cmp	 eax, DWORD PTR [edx+144]
  004df	73 05		 jae	 SHORT $LN40@SetupThrea
$LN41@SetupThrea:

; 1270 : 				break;

  004e1	e9 a8 04 00 00	 jmp	 $abort$28601
$LN40@SetupThrea:

; 1271 : 		}
; 1272 : 
; 1273 : 		while (!NT_SUCCESS (EncryptedIoQueueHoldWhenIdle (&Extension->Queue, 500)))

  004e6	6a 00		 push	 0
  004e8	68 f4 01 00 00	 push	 500			; 000001f4H
  004ed	8b 4d e0	 mov	 ecx, DWORD PTR _Extension$[ebp]
  004f0	83 c1 48	 add	 ecx, 72			; 00000048H
  004f3	51		 push	 ecx
  004f4	e8 00 00 00 00	 call	 _EncryptedIoQueueHoldWhenIdle@12
  004f9	85 c0		 test	 eax, eax
  004fb	7d 1a		 jge	 SHORT $LN39@SetupThrea

; 1274 : 		{
; 1275 : 			if (EncryptionSetupThreadAbortRequested)

  004fd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _EncryptionSetupThreadAbortRequested, 0
  00504	74 05		 je	 SHORT $LN38@SetupThrea

; 1276 : 				goto abort;

  00506	e9 83 04 00 00	 jmp	 $abort$28601
$LN38@SetupThrea:

; 1277 : 
; 1278 : 			TransformWaitingForIdle = TRUE;

  0050b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _TransformWaitingForIdle, 1

; 1279 : 		}

  00515	eb cf		 jmp	 SHORT $LN40@SetupThrea
$LN39@SetupThrea:

; 1280 : 		TransformWaitingForIdle = FALSE;

  00517	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _TransformWaitingForIdle, 0

; 1281 : 
; 1282 : 		status = TCReadDevice (BootDriveFilterExtension->LowerDeviceObject, buffer, offset, setupBlockSize);

  00521	8b 55 e4	 mov	 edx, DWORD PTR _setupBlockSize$[ebp]
  00524	52		 push	 edx
  00525	8b 45 d4	 mov	 eax, DWORD PTR _offset$[ebp+4]
  00528	50		 push	 eax
  00529	8b 4d d0	 mov	 ecx, DWORD PTR _offset$[ebp]
  0052c	51		 push	 ecx
  0052d	8b 55 c4	 mov	 edx, DWORD PTR _buffer$[ebp]
  00530	52		 push	 edx
  00531	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  00536	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00539	51		 push	 ecx
  0053a	e8 00 00 00 00	 call	 _TCReadDevice@20
  0053f	89 45 c8	 mov	 DWORD PTR _status$[ebp], eax

; 1283 : 		if (!NT_SUCCESS (status))

  00542	83 7d c8 00	 cmp	 DWORD PTR _status$[ebp], 0
  00546	0f 8d f1 00 00
	00		 jge	 $LN37@SetupThrea

; 1284 : 		{
; 1285 : 			Dump ("TCReadDevice error %x  offset=%I64d\n", status, offset.QuadPart);

  0054c	8b 55 d4	 mov	 edx, DWORD PTR _offset$[ebp+4]
  0054f	52		 push	 edx
  00550	8b 45 d0	 mov	 eax, DWORD PTR _offset$[ebp]
  00553	50		 push	 eax
  00554	8b 4d c8	 mov	 ecx, DWORD PTR _status$[ebp]
  00557	51		 push	 ecx
  00558	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@CKMJEIIB@TCReadDevice?5error?5?$CFx?5?5offset?$DN?$CFI@FNODOBFM@
  0055d	e8 00 00 00 00	 call	 _DbgPrint
  00562	83 c4 10	 add	 esp, 16			; 00000010H

; 1286 : 
; 1287 : 			if (SetupRequest.ZeroUnreadableSectors && SetupRequest.SetupMode == SetupEncryption)

  00565	83 3d 08 00 00
	00 00		 cmp	 DWORD PTR _SetupRequest+8, 0
  0056c	74 75		 je	 SHORT $LN36@SetupThrea
  0056e	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _SetupRequest, 1
  00575	75 6c		 jne	 SHORT $LN36@SetupThrea

; 1288 : 			{
; 1289 : 				// Zero unreadable sectors
; 1290 : 				uint64 zeroedSectorCount;
; 1291 : 
; 1292 : 				status = ZeroUnreadableSectors (BootDriveFilterExtension->LowerDeviceObject, offset, setupBlockSize, &zeroedSectorCount);

  00577	8d 55 b8	 lea	 edx, DWORD PTR _zeroedSectorCount$28646[ebp]
  0057a	52		 push	 edx
  0057b	8b 45 e4	 mov	 eax, DWORD PTR _setupBlockSize$[ebp]
  0057e	50		 push	 eax
  0057f	8b 4d d4	 mov	 ecx, DWORD PTR _offset$[ebp+4]
  00582	51		 push	 ecx
  00583	8b 55 d0	 mov	 edx, DWORD PTR _offset$[ebp]
  00586	52		 push	 edx
  00587	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  0058c	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0058f	51		 push	 ecx
  00590	e8 00 00 00 00	 call	 _ZeroUnreadableSectors@20
  00595	89 45 c8	 mov	 DWORD PTR _status$[ebp], eax

; 1293 : 				if (!NT_SUCCESS (status))

  00598	83 7d c8 00	 cmp	 DWORD PTR _status$[ebp], 0
  0059c	7d 0e		 jge	 SHORT $LN35@SetupThrea

; 1294 : 				{
; 1295 : 					SetupResult = status;

  0059e	8b 55 c8	 mov	 edx, DWORD PTR _status$[ebp]
  005a1	89 15 00 00 00
	00		 mov	 DWORD PTR _SetupResult, edx

; 1296 : 					goto err;

  005a7	e9 ec 03 00 00	 jmp	 $err$28612
$LN35@SetupThrea:

; 1297 : 				}
; 1298 : 
; 1299 : 				// Retry read
; 1300 : 				status = TCReadDevice (BootDriveFilterExtension->LowerDeviceObject, buffer, offset, setupBlockSize);

  005ac	8b 45 e4	 mov	 eax, DWORD PTR _setupBlockSize$[ebp]
  005af	50		 push	 eax
  005b0	8b 4d d4	 mov	 ecx, DWORD PTR _offset$[ebp+4]
  005b3	51		 push	 ecx
  005b4	8b 55 d0	 mov	 edx, DWORD PTR _offset$[ebp]
  005b7	52		 push	 edx
  005b8	8b 45 c4	 mov	 eax, DWORD PTR _buffer$[ebp]
  005bb	50		 push	 eax
  005bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _BootDriveFilterExtension
  005c2	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  005c5	52		 push	 edx
  005c6	e8 00 00 00 00	 call	 _TCReadDevice@20
  005cb	89 45 c8	 mov	 DWORD PTR _status$[ebp], eax

; 1301 : 				if (!NT_SUCCESS (status))

  005ce	83 7d c8 00	 cmp	 DWORD PTR _status$[ebp], 0
  005d2	7d 0d		 jge	 SHORT $LN34@SetupThrea

; 1302 : 				{
; 1303 : 					SetupResult = status;

  005d4	8b 45 c8	 mov	 eax, DWORD PTR _status$[ebp]
  005d7	a3 00 00 00 00	 mov	 DWORD PTR _SetupResult, eax

; 1304 : 					goto err;

  005dc	e9 b7 03 00 00	 jmp	 $err$28612
$LN34@SetupThrea:

; 1305 : 				}

  005e1	eb 5a		 jmp	 SHORT $LN37@SetupThrea
$LN36@SetupThrea:

; 1306 : 			}
; 1307 : 			else if (SetupRequest.DiscardUnreadableEncryptedSectors && SetupRequest.SetupMode == SetupDecryption)

  005e3	83 3d 0c 00 00
	00 00		 cmp	 DWORD PTR _SetupRequest+12, 0
  005ea	74 44		 je	 SHORT $LN32@SetupThrea
  005ec	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _SetupRequest, 2
  005f3	75 3b		 jne	 SHORT $LN32@SetupThrea

; 1308 : 			{
; 1309 : 				// Discard unreadable encrypted sectors
; 1310 : 				uint64 badSectorCount;
; 1311 : 
; 1312 : 				status = ReadDeviceSkipUnreadableSectors (BootDriveFilterExtension->LowerDeviceObject, buffer, offset, setupBlockSize, &badSectorCount);

  005f5	8d 4d b0	 lea	 ecx, DWORD PTR _badSectorCount$28653[ebp]
  005f8	51		 push	 ecx
  005f9	8b 55 e4	 mov	 edx, DWORD PTR _setupBlockSize$[ebp]
  005fc	52		 push	 edx
  005fd	8b 45 d4	 mov	 eax, DWORD PTR _offset$[ebp+4]
  00600	50		 push	 eax
  00601	8b 4d d0	 mov	 ecx, DWORD PTR _offset$[ebp]
  00604	51		 push	 ecx
  00605	8b 55 c4	 mov	 edx, DWORD PTR _buffer$[ebp]
  00608	52		 push	 edx
  00609	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  0060e	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00611	51		 push	 ecx
  00612	e8 00 00 00 00	 call	 _ReadDeviceSkipUnreadableSectors@24
  00617	89 45 c8	 mov	 DWORD PTR _status$[ebp], eax

; 1313 : 				if (!NT_SUCCESS (status))

  0061a	83 7d c8 00	 cmp	 DWORD PTR _status$[ebp], 0
  0061e	7d 0e		 jge	 SHORT $LN31@SetupThrea

; 1314 : 				{
; 1315 : 					SetupResult = status;

  00620	8b 55 c8	 mov	 edx, DWORD PTR _status$[ebp]
  00623	89 15 00 00 00
	00		 mov	 DWORD PTR _SetupResult, edx

; 1316 : 					goto err;

  00629	e9 6a 03 00 00	 jmp	 $err$28612
$LN31@SetupThrea:

; 1317 : 				}
; 1318 : 			}
; 1319 : 			else

  0062e	eb 0d		 jmp	 SHORT $LN37@SetupThrea
$LN32@SetupThrea:

; 1320 : 			{
; 1321 : 				SetupResult = status;

  00630	8b 45 c8	 mov	 eax, DWORD PTR _status$[ebp]
  00633	a3 00 00 00 00	 mov	 DWORD PTR _SetupResult, eax

; 1322 : 				goto err;

  00638	e9 5b 03 00 00	 jmp	 $err$28612
$LN37@SetupThrea:

; 1323 : 			}
; 1324 : 		}
; 1325 : 
; 1326 : 		dataUnit.Value = offset.QuadPart / ENCRYPTION_DATA_UNIT_SIZE;

  0063d	6a 00		 push	 0
  0063f	68 00 02 00 00	 push	 512			; 00000200H
  00644	8b 4d d4	 mov	 ecx, DWORD PTR _offset$[ebp+4]
  00647	51		 push	 ecx
  00648	8b 55 d0	 mov	 edx, DWORD PTR _offset$[ebp]
  0064b	52		 push	 edx
  0064c	e8 00 00 00 00	 call	 __alldiv
  00651	89 45 f0	 mov	 DWORD PTR _dataUnit$[ebp], eax
  00654	89 55 f4	 mov	 DWORD PTR _dataUnit$[ebp+4], edx

; 1327 : 
; 1328 : 		if (SetupRequest.SetupMode == SetupEncryption)

  00657	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _SetupRequest, 1
  0065e	0f 85 51 01 00
	00		 jne	 $LN29@SetupThrea

; 1329 : 		{
; 1330 : 			EncryptDataUnits (buffer, &dataUnit, setupBlockSize / ENCRYPTION_DATA_UNIT_SIZE, Extension->Queue.CryptoInfo);

  00664	8b 45 e0	 mov	 eax, DWORD PTR _Extension$[ebp]
  00667	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  0066a	51		 push	 ecx
  0066b	8b 55 e4	 mov	 edx, DWORD PTR _setupBlockSize$[ebp]
  0066e	c1 ea 09	 shr	 edx, 9
  00671	52		 push	 edx
  00672	8d 45 f0	 lea	 eax, DWORD PTR _dataUnit$[ebp]
  00675	50		 push	 eax
  00676	8b 4d c4	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00679	51		 push	 ecx
  0067a	e8 00 00 00 00	 call	 _EncryptDataUnits@16

; 1331 : 
; 1332 : 			if (SetupRequest.WipeAlgorithm != TC_WIPE_NONE)

  0067f	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR _SetupRequest+4, 0
  00686	0f 84 27 01 00
	00		 je	 $LN28@SetupThrea

; 1333 : 			{
; 1334 : 				byte wipePass;
; 1335 : 				for (wipePass = 1; wipePass <= GetWipePassCount (SetupRequest.WipeAlgorithm); ++wipePass)

  0068c	c6 45 af 01	 mov	 BYTE PTR _wipePass$28659[ebp], 1
  00690	eb 09		 jmp	 SHORT $LN27@SetupThrea
$LN26@SetupThrea:
  00692	8a 55 af	 mov	 dl, BYTE PTR _wipePass$28659[ebp]
  00695	80 c2 01	 add	 dl, 1
  00698	88 55 af	 mov	 BYTE PTR _wipePass$28659[ebp], dl
$LN27@SetupThrea:
  0069b	0f b6 75 af	 movzx	 esi, BYTE PTR _wipePass$28659[ebp]
  0069f	a1 04 00 00 00	 mov	 eax, DWORD PTR _SetupRequest+4
  006a4	50		 push	 eax
  006a5	e8 00 00 00 00	 call	 _GetWipePassCount@4
  006aa	3b f0		 cmp	 esi, eax
  006ac	0f 8f f3 00 00
	00		 jg	 $LN25@SetupThrea

; 1336 : 				{
; 1337 : 					if (!WipeBuffer (SetupRequest.WipeAlgorithm, wipeRandChars, wipePass, wipeBuffer, setupBlockSize))

  006b2	8b 4d e4	 mov	 ecx, DWORD PTR _setupBlockSize$[ebp]
  006b5	51		 push	 ecx
  006b6	8b 55 ec	 mov	 edx, DWORD PTR _wipeBuffer$[ebp]
  006b9	52		 push	 edx
  006ba	0f b6 45 af	 movzx	 eax, BYTE PTR _wipePass$28659[ebp]
  006be	50		 push	 eax
  006bf	8d 4d cc	 lea	 ecx, DWORD PTR _wipeRandChars$[ebp]
  006c2	51		 push	 ecx
  006c3	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _SetupRequest+4
  006c9	52		 push	 edx
  006ca	e8 00 00 00 00	 call	 _WipeBuffer@20
  006cf	85 c0		 test	 eax, eax
  006d1	75 5e		 jne	 SHORT $LN24@SetupThrea

; 1338 : 					{
; 1339 : 						ULONG i;
; 1340 : 						for (i = 0; i < setupBlockSize; ++i)

  006d3	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _i$28664[ebp], 0
  006da	eb 09		 jmp	 SHORT $LN23@SetupThrea
$LN22@SetupThrea:
  006dc	8b 45 a8	 mov	 eax, DWORD PTR _i$28664[ebp]
  006df	83 c0 01	 add	 eax, 1
  006e2	89 45 a8	 mov	 DWORD PTR _i$28664[ebp], eax
$LN23@SetupThrea:
  006e5	8b 4d a8	 mov	 ecx, DWORD PTR _i$28664[ebp]
  006e8	3b 4d e4	 cmp	 ecx, DWORD PTR _setupBlockSize$[ebp]
  006eb	73 19		 jae	 SHORT $LN21@SetupThrea

; 1341 : 						{
; 1342 : 							wipeBuffer[i] = buffer[i] + wipePass;

  006ed	8b 55 c4	 mov	 edx, DWORD PTR _buffer$[ebp]
  006f0	03 55 a8	 add	 edx, DWORD PTR _i$28664[ebp]
  006f3	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  006f6	0f b6 4d af	 movzx	 ecx, BYTE PTR _wipePass$28659[ebp]
  006fa	03 c1		 add	 eax, ecx
  006fc	8b 55 ec	 mov	 edx, DWORD PTR _wipeBuffer$[ebp]
  006ff	03 55 a8	 add	 edx, DWORD PTR _i$28664[ebp]
  00702	88 02		 mov	 BYTE PTR [edx], al

; 1343 : 						}

  00704	eb d6		 jmp	 SHORT $LN22@SetupThrea
$LN21@SetupThrea:

; 1344 : 
; 1345 : 						EncryptDataUnits (wipeBuffer, &dataUnit, setupBlockSize / ENCRYPTION_DATA_UNIT_SIZE, Extension->Queue.CryptoInfo);

  00706	8b 45 e0	 mov	 eax, DWORD PTR _Extension$[ebp]
  00709	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  0070c	51		 push	 ecx
  0070d	8b 55 e4	 mov	 edx, DWORD PTR _setupBlockSize$[ebp]
  00710	c1 ea 09	 shr	 edx, 9
  00713	52		 push	 edx
  00714	8d 45 f0	 lea	 eax, DWORD PTR _dataUnit$[ebp]
  00717	50		 push	 eax
  00718	8b 4d ec	 mov	 ecx, DWORD PTR _wipeBuffer$[ebp]
  0071b	51		 push	 ecx
  0071c	e8 00 00 00 00	 call	 _EncryptDataUnits@16

; 1346 : 						memcpy (wipeRandCharsUpdate, wipeBuffer, sizeof (wipeRandCharsUpdate)); 

  00721	8b 55 ec	 mov	 edx, DWORD PTR _wipeBuffer$[ebp]
  00724	66 8b 02	 mov	 ax, WORD PTR [edx]
  00727	66 89 45 f8	 mov	 WORD PTR _wipeRandCharsUpdate$[ebp], ax
  0072b	8a 4a 02	 mov	 cl, BYTE PTR [edx+2]
  0072e	88 4d fa	 mov	 BYTE PTR _wipeRandCharsUpdate$[ebp+2], cl
$LN24@SetupThrea:

; 1347 : 					}
; 1348 : 
; 1349 : 					status = TCWriteDevice (BootDriveFilterExtension->LowerDeviceObject, wipeBuffer, offset, setupBlockSize);

  00731	8b 55 e4	 mov	 edx, DWORD PTR _setupBlockSize$[ebp]
  00734	52		 push	 edx
  00735	8b 45 d4	 mov	 eax, DWORD PTR _offset$[ebp+4]
  00738	50		 push	 eax
  00739	8b 4d d0	 mov	 ecx, DWORD PTR _offset$[ebp]
  0073c	51		 push	 ecx
  0073d	8b 55 ec	 mov	 edx, DWORD PTR _wipeBuffer$[ebp]
  00740	52		 push	 edx
  00741	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  00746	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00749	51		 push	 ecx
  0074a	e8 00 00 00 00	 call	 _TCWriteDevice@20
  0074f	89 45 c8	 mov	 DWORD PTR _status$[ebp], eax

; 1350 : 					if (!NT_SUCCESS (status))

  00752	83 7d c8 00	 cmp	 DWORD PTR _status$[ebp], 0
  00756	7d 48		 jge	 SHORT $LN20@SetupThrea

; 1351 : 					{
; 1352 : 						// Undo failed write operation
; 1353 : 						DecryptDataUnits (buffer, &dataUnit, setupBlockSize / ENCRYPTION_DATA_UNIT_SIZE, Extension->Queue.CryptoInfo);

  00758	8b 55 e0	 mov	 edx, DWORD PTR _Extension$[ebp]
  0075b	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  0075e	50		 push	 eax
  0075f	8b 4d e4	 mov	 ecx, DWORD PTR _setupBlockSize$[ebp]
  00762	c1 e9 09	 shr	 ecx, 9
  00765	51		 push	 ecx
  00766	8d 55 f0	 lea	 edx, DWORD PTR _dataUnit$[ebp]
  00769	52		 push	 edx
  0076a	8b 45 c4	 mov	 eax, DWORD PTR _buffer$[ebp]
  0076d	50		 push	 eax
  0076e	e8 00 00 00 00	 call	 _DecryptDataUnits@16

; 1354 : 						TCWriteDevice (BootDriveFilterExtension->LowerDeviceObject, buffer, offset, setupBlockSize);

  00773	8b 4d e4	 mov	 ecx, DWORD PTR _setupBlockSize$[ebp]
  00776	51		 push	 ecx
  00777	8b 55 d4	 mov	 edx, DWORD PTR _offset$[ebp+4]
  0077a	52		 push	 edx
  0077b	8b 45 d0	 mov	 eax, DWORD PTR _offset$[ebp]
  0077e	50		 push	 eax
  0077f	8b 4d c4	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00782	51		 push	 ecx
  00783	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _BootDriveFilterExtension
  00789	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0078c	50		 push	 eax
  0078d	e8 00 00 00 00	 call	 _TCWriteDevice@20

; 1355 : 
; 1356 : 						SetupResult = status;

  00792	8b 4d c8	 mov	 ecx, DWORD PTR _status$[ebp]
  00795	89 0d 00 00 00
	00		 mov	 DWORD PTR _SetupResult, ecx

; 1357 : 						goto err;

  0079b	e9 f8 01 00 00	 jmp	 $err$28612
$LN20@SetupThrea:

; 1358 : 					}
; 1359 : 				}

  007a0	e9 ed fe ff ff	 jmp	 $LN26@SetupThrea
$LN25@SetupThrea:

; 1360 : 
; 1361 : 				memcpy (wipeRandChars, wipeRandCharsUpdate, sizeof (wipeRandCharsUpdate)); 

  007a5	66 8b 55 f8	 mov	 dx, WORD PTR _wipeRandCharsUpdate$[ebp]
  007a9	66 89 55 cc	 mov	 WORD PTR _wipeRandChars$[ebp], dx
  007ad	8a 45 fa	 mov	 al, BYTE PTR _wipeRandCharsUpdate$[ebp+2]
  007b0	88 45 ce	 mov	 BYTE PTR _wipeRandChars$[ebp+2], al
$LN28@SetupThrea:

; 1362 : 			}
; 1363 : 		}
; 1364 : 		else

  007b3	eb 1b		 jmp	 SHORT $LN19@SetupThrea
$LN29@SetupThrea:

; 1365 : 		{
; 1366 : 			DecryptDataUnits (buffer, &dataUnit, setupBlockSize / ENCRYPTION_DATA_UNIT_SIZE, Extension->Queue.CryptoInfo);

  007b5	8b 4d e0	 mov	 ecx, DWORD PTR _Extension$[ebp]
  007b8	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  007bb	52		 push	 edx
  007bc	8b 45 e4	 mov	 eax, DWORD PTR _setupBlockSize$[ebp]
  007bf	c1 e8 09	 shr	 eax, 9
  007c2	50		 push	 eax
  007c3	8d 4d f0	 lea	 ecx, DWORD PTR _dataUnit$[ebp]
  007c6	51		 push	 ecx
  007c7	8b 55 c4	 mov	 edx, DWORD PTR _buffer$[ebp]
  007ca	52		 push	 edx
  007cb	e8 00 00 00 00	 call	 _DecryptDataUnits@16
$LN19@SetupThrea:

; 1367 : 		}
; 1368 : 
; 1369 : 		status = TCWriteDevice (BootDriveFilterExtension->LowerDeviceObject, buffer, offset, setupBlockSize);

  007d0	8b 45 e4	 mov	 eax, DWORD PTR _setupBlockSize$[ebp]
  007d3	50		 push	 eax
  007d4	8b 4d d4	 mov	 ecx, DWORD PTR _offset$[ebp+4]
  007d7	51		 push	 ecx
  007d8	8b 55 d0	 mov	 edx, DWORD PTR _offset$[ebp]
  007db	52		 push	 edx
  007dc	8b 45 c4	 mov	 eax, DWORD PTR _buffer$[ebp]
  007df	50		 push	 eax
  007e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _BootDriveFilterExtension
  007e6	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  007e9	52		 push	 edx
  007ea	e8 00 00 00 00	 call	 _TCWriteDevice@20
  007ef	89 45 c8	 mov	 DWORD PTR _status$[ebp], eax

; 1370 : 		if (!NT_SUCCESS (status))

  007f2	83 7d c8 00	 cmp	 DWORD PTR _status$[ebp], 0
  007f6	7d 7e		 jge	 SHORT $LN18@SetupThrea

; 1371 : 		{
; 1372 : 			Dump ("TCWriteDevice error %x\n", status);

  007f8	8b 45 c8	 mov	 eax, DWORD PTR _status$[ebp]
  007fb	50		 push	 eax
  007fc	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@LEBDPHBF@TCWriteDevice?5error?5?$CFx?6?$AA@FNODOBFM@
  00801	e8 00 00 00 00	 call	 _DbgPrint
  00806	83 c4 08	 add	 esp, 8

; 1373 : 
; 1374 : 			// Undo failed write operation
; 1375 : 			if (SetupRequest.SetupMode == SetupEncryption)

  00809	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _SetupRequest, 1
  00810	75 1d		 jne	 SHORT $LN17@SetupThrea

; 1376 : 				DecryptDataUnits (buffer, &dataUnit, setupBlockSize / ENCRYPTION_DATA_UNIT_SIZE, Extension->Queue.CryptoInfo);

  00812	8b 4d e0	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00815	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  00818	52		 push	 edx
  00819	8b 45 e4	 mov	 eax, DWORD PTR _setupBlockSize$[ebp]
  0081c	c1 e8 09	 shr	 eax, 9
  0081f	50		 push	 eax
  00820	8d 4d f0	 lea	 ecx, DWORD PTR _dataUnit$[ebp]
  00823	51		 push	 ecx
  00824	8b 55 c4	 mov	 edx, DWORD PTR _buffer$[ebp]
  00827	52		 push	 edx
  00828	e8 00 00 00 00	 call	 _DecryptDataUnits@16

; 1377 : 			else

  0082d	eb 1b		 jmp	 SHORT $LN16@SetupThrea
$LN17@SetupThrea:

; 1378 : 				EncryptDataUnits (buffer, &dataUnit, setupBlockSize / ENCRYPTION_DATA_UNIT_SIZE, Extension->Queue.CryptoInfo);

  0082f	8b 45 e0	 mov	 eax, DWORD PTR _Extension$[ebp]
  00832	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  00835	51		 push	 ecx
  00836	8b 55 e4	 mov	 edx, DWORD PTR _setupBlockSize$[ebp]
  00839	c1 ea 09	 shr	 edx, 9
  0083c	52		 push	 edx
  0083d	8d 45 f0	 lea	 eax, DWORD PTR _dataUnit$[ebp]
  00840	50		 push	 eax
  00841	8b 4d c4	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00844	51		 push	 ecx
  00845	e8 00 00 00 00	 call	 _EncryptDataUnits@16
$LN16@SetupThrea:

; 1379 : 
; 1380 : 			TCWriteDevice (BootDriveFilterExtension->LowerDeviceObject, buffer, offset, setupBlockSize);

  0084a	8b 55 e4	 mov	 edx, DWORD PTR _setupBlockSize$[ebp]
  0084d	52		 push	 edx
  0084e	8b 45 d4	 mov	 eax, DWORD PTR _offset$[ebp+4]
  00851	50		 push	 eax
  00852	8b 4d d0	 mov	 ecx, DWORD PTR _offset$[ebp]
  00855	51		 push	 ecx
  00856	8b 55 c4	 mov	 edx, DWORD PTR _buffer$[ebp]
  00859	52		 push	 edx
  0085a	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  0085f	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00862	51		 push	 ecx
  00863	e8 00 00 00 00	 call	 _TCWriteDevice@20

; 1381 : 
; 1382 : 			SetupResult = status;

  00868	8b 55 c8	 mov	 edx, DWORD PTR _status$[ebp]
  0086b	89 15 00 00 00
	00		 mov	 DWORD PTR _SetupResult, edx

; 1383 : 			goto err;

  00871	e9 22 01 00 00	 jmp	 $err$28612
$LN18@SetupThrea:

; 1384 : 		}
; 1385 : 
; 1386 : 		if (SetupRequest.SetupMode == SetupEncryption)

  00876	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _SetupRequest, 1
  0087d	75 13		 jne	 SHORT $LN15@SetupThrea

; 1387 : 			offset.QuadPart += setupBlockSize;

  0087f	8b 45 e4	 mov	 eax, DWORD PTR _setupBlockSize$[ebp]
  00882	33 c9		 xor	 ecx, ecx
  00884	03 45 d0	 add	 eax, DWORD PTR _offset$[ebp]
  00887	8b 55 d4	 mov	 edx, DWORD PTR _offset$[ebp+4]
  0088a	13 d1		 adc	 edx, ecx
  0088c	89 45 d0	 mov	 DWORD PTR _offset$[ebp], eax
  0088f	89 55 d4	 mov	 DWORD PTR _offset$[ebp+4], edx
$LN15@SetupThrea:

; 1388 : 
; 1389 : 		Extension->Queue.EncryptedAreaEndUpdatePending = TRUE;

  00892	8b 45 e0	 mov	 eax, DWORD PTR _Extension$[ebp]
  00895	c7 80 a0 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+160], 1

; 1390 : 		Extension->Queue.EncryptedAreaEnd = offset.QuadPart - 1;

  0089f	8b 4d d0	 mov	 ecx, DWORD PTR _offset$[ebp]
  008a2	83 e9 01	 sub	 ecx, 1
  008a5	8b 55 d4	 mov	 edx, DWORD PTR _offset$[ebp+4]
  008a8	83 da 00	 sbb	 edx, 0
  008ab	8b 45 e0	 mov	 eax, DWORD PTR _Extension$[ebp]
  008ae	89 88 98 00 00
	00		 mov	 DWORD PTR [eax+152], ecx
  008b4	89 90 9c 00 00
	00		 mov	 DWORD PTR [eax+156], edx

; 1391 : 		Extension->Queue.EncryptedAreaEndUpdatePending = FALSE;

  008ba	8b 4d e0	 mov	 ecx, DWORD PTR _Extension$[ebp]
  008bd	c7 81 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+160], 0

; 1392 : 
; 1393 : 		headerUpdateRequired = TRUE;

  008c7	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _headerUpdateRequired$[ebp], 1

; 1394 : 
; 1395 : 		EncryptedIoQueueResumeFromHold (&Extension->Queue);

  008ce	8b 55 e0	 mov	 edx, DWORD PTR _Extension$[ebp]
  008d1	83 c2 48	 add	 edx, 72			; 00000048H
  008d4	52		 push	 edx
  008d5	e8 00 00 00 00	 call	 _EncryptedIoQueueResumeFromHold@4

; 1396 : 
; 1397 : 		KeAcquireSpinLock (&SetupStatusSpinLock, &irql);

  008da	b9 00 00 00 00	 mov	 ecx, OFFSET _SetupStatusSpinLock
  008df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4
  008e5	88 45 ff	 mov	 BYTE PTR _irql$[ebp], al

; 1398 : 		SetupStatusEncryptedAreaEnd = Extension->Queue.EncryptedAreaEnd;

  008e8	8b 45 e0	 mov	 eax, DWORD PTR _Extension$[ebp]
  008eb	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  008f1	89 0d 00 00 00
	00		 mov	 DWORD PTR _SetupStatusEncryptedAreaEnd, ecx
  008f7	8b 90 9c 00 00
	00		 mov	 edx, DWORD PTR [eax+156]
  008fd	89 15 04 00 00
	00		 mov	 DWORD PTR _SetupStatusEncryptedAreaEnd+4, edx

; 1399 : 		KeReleaseSpinLock (&SetupStatusSpinLock, irql);

  00903	8a 55 ff	 mov	 dl, BYTE PTR _irql$[ebp]
  00906	b9 00 00 00 00	 mov	 ecx, OFFSET _SetupStatusSpinLock
  0090b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8

; 1400 : 
; 1401 : 		// Update volume header
; 1402 : 		bytesWrittenSinceHeaderUpdate += setupBlockSize;

  00911	8b 45 e4	 mov	 eax, DWORD PTR _setupBlockSize$[ebp]
  00914	33 c9		 xor	 ecx, ecx
  00916	03 45 d8	 add	 eax, DWORD PTR _bytesWrittenSinceHeaderUpdate$[ebp]
  00919	8b 55 dc	 mov	 edx, DWORD PTR _bytesWrittenSinceHeaderUpdate$[ebp+4]
  0091c	13 d1		 adc	 edx, ecx
  0091e	89 45 d8	 mov	 DWORD PTR _bytesWrittenSinceHeaderUpdate$[ebp], eax
  00921	89 55 dc	 mov	 DWORD PTR _bytesWrittenSinceHeaderUpdate$[ebp+4], edx

; 1403 : 		if (bytesWrittenSinceHeaderUpdate >= TC_ENCRYPTION_SETUP_HEADER_UPDATE_THRESHOLD)

  00924	83 7d dc 00	 cmp	 DWORD PTR _bytesWrittenSinceHeaderUpdate$[ebp+4], 0
  00928	7c 5f		 jl	 SHORT $LN14@SetupThrea
  0092a	7f 09		 jg	 SHORT $LN76@SetupThrea
  0092c	81 7d d8 00 00
	00 04		 cmp	 DWORD PTR _bytesWrittenSinceHeaderUpdate$[ebp], 67108864 ; 04000000H
  00933	72 54		 jb	 SHORT $LN14@SetupThrea
$LN76@SetupThrea:

; 1404 : 		{
; 1405 : 			status = SaveDriveVolumeHeader (Extension);

  00935	8b 45 e0	 mov	 eax, DWORD PTR _Extension$[ebp]
  00938	50		 push	 eax
  00939	e8 00 00 00 00	 call	 _SaveDriveVolumeHeader@4
  0093e	89 45 c8	 mov	 DWORD PTR _status$[ebp], eax

; 1406 : 			ASSERT (NT_SUCCESS (status));

  00941	83 7d c8 00	 cmp	 DWORD PTR _status$[ebp], 0
  00945	7d 23		 jge	 SHORT $LN70@SetupThrea
  00947	6a 00		 push	 0
  00949	68 7e 05 00 00	 push	 1406			; 0000057eH
  0094e	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@GDHJGIB@c?3?2users?2public?2desktop?2projects@FNODOBFM@
  00953	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@IDPHHPHP@NT_SUCCESS?5?$CIstatus?$CJ?$AA@FNODOBFM@
  00958	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  0095e	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv366[ebp], 0
  00968	eb 0a		 jmp	 SHORT $LN71@SetupThrea
$LN70@SetupThrea:
  0096a	c7 85 58 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv366[ebp], 1
$LN71@SetupThrea:

; 1407 : 
; 1408 : 			headerUpdateRequired = FALSE;

  00974	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _headerUpdateRequired$[ebp], 0

; 1409 : 			bytesWrittenSinceHeaderUpdate = 0;

  0097b	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _bytesWrittenSinceHeaderUpdate$[ebp], 0
  00982	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _bytesWrittenSinceHeaderUpdate$[ebp+4], 0
$LN14@SetupThrea:

; 1410 : 		}
; 1411 : 	}

  00989	e9 f0 f9 ff ff	 jmp	 $LN49@SetupThrea
$abort$28601:

; 1412 : 
; 1413 : abort:
; 1414 : 	SetupResult = STATUS_SUCCESS;

  0098e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _SetupResult, 0
$err$28612:

; 1415 : err:
; 1416 : 
; 1417 : 	if (Extension->Queue.EncryptedAreaEnd == -1)

  00998	8b 4d e0	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0099b	8b 91 98 00 00
	00		 mov	 edx, DWORD PTR [ecx+152]
  009a1	8b 81 9c 00 00
	00		 mov	 eax, DWORD PTR [ecx+156]
  009a7	89 95 50 ff ff
	ff		 mov	 DWORD PTR tv877[ebp], edx
  009ad	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv877[ebp+4], eax
  009b3	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR tv877[ebp]
  009b9	23 8d 54 ff ff
	ff		 and	 ecx, DWORD PTR tv877[ebp+4]
  009bf	83 f9 ff	 cmp	 ecx, -1
  009c2	75 17		 jne	 SHORT $LN13@SetupThrea

; 1418 : 		Extension->Queue.EncryptedAreaStart = -1;

  009c4	8b 55 e0	 mov	 edx, DWORD PTR _Extension$[ebp]
  009c7	c7 82 90 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+144], -1
  009d1	c7 82 94 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+148], -1
$LN13@SetupThrea:

; 1419 : 
; 1420 : 	if (EncryptedIoQueueIsSuspended (&Extension->Queue))

  009db	8b 45 e0	 mov	 eax, DWORD PTR _Extension$[ebp]
  009de	83 c0 48	 add	 eax, 72			; 00000048H
  009e1	50		 push	 eax
  009e2	e8 00 00 00 00	 call	 _EncryptedIoQueueIsSuspended@4
  009e7	85 c0		 test	 eax, eax
  009e9	74 0c		 je	 SHORT $LN12@SetupThrea

; 1421 : 		EncryptedIoQueueResumeFromHold (&Extension->Queue);

  009eb	8b 4d e0	 mov	 ecx, DWORD PTR _Extension$[ebp]
  009ee	83 c1 48	 add	 ecx, 72			; 00000048H
  009f1	51		 push	 ecx
  009f2	e8 00 00 00 00	 call	 _EncryptedIoQueueResumeFromHold@4
$LN12@SetupThrea:

; 1422 : 
; 1423 : 	if (SetupRequest.SetupMode == SetupDecryption && Extension->Queue.EncryptedAreaStart >= Extension->Queue.EncryptedAreaEnd)

  009f7	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _SetupRequest, 2
  009fe	0f 85 cb 00 00
	00		 jne	 $LN11@SetupThrea
  00a04	8b 55 e0	 mov	 edx, DWORD PTR _Extension$[ebp]
  00a07	8b 82 98 00 00
	00		 mov	 eax, DWORD PTR [edx+152]
  00a0d	8b 8a 9c 00 00
	00		 mov	 ecx, DWORD PTR [edx+156]
  00a13	8b 55 e0	 mov	 edx, DWORD PTR _Extension$[ebp]
  00a16	89 95 4c ff ff
	ff		 mov	 DWORD PTR tv893[ebp], edx
  00a1c	89 85 44 ff ff
	ff		 mov	 DWORD PTR tv894[ebp], eax
  00a22	89 8d 48 ff ff
	ff		 mov	 DWORD PTR tv894[ebp+4], ecx
  00a28	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR tv893[ebp]
  00a2e	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [eax+148]
  00a34	3b 8d 48 ff ff
	ff		 cmp	 ecx, DWORD PTR tv894[ebp+4]
  00a3a	0f 8c 8f 00 00
	00		 jl	 $LN11@SetupThrea
  00a40	7f 14		 jg	 SHORT $LN10@SetupThrea
  00a42	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv893[ebp]
  00a48	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  00a4e	3b 85 44 ff ff
	ff		 cmp	 eax, DWORD PTR tv894[ebp]
  00a54	72 79		 jb	 SHORT $LN11@SetupThrea
$LN10@SetupThrea:

; 1424 : 	{
; 1425 : 		while (!NT_SUCCESS (EncryptedIoQueueHoldWhenIdle (&Extension->Queue, 0)));

  00a56	6a 00		 push	 0
  00a58	6a 00		 push	 0
  00a5a	8b 4d e0	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00a5d	83 c1 48	 add	 ecx, 72			; 00000048H
  00a60	51		 push	 ecx
  00a61	e8 00 00 00 00	 call	 _EncryptedIoQueueHoldWhenIdle@12
  00a66	85 c0		 test	 eax, eax
  00a68	7d 02		 jge	 SHORT $LN9@SetupThrea
  00a6a	eb ea		 jmp	 SHORT $LN10@SetupThrea
$LN9@SetupThrea:

; 1426 : 
; 1427 : 		Extension->ConfiguredEncryptedAreaStart = Extension->ConfiguredEncryptedAreaEnd = -1;

  00a6c	8b 55 e0	 mov	 edx, DWORD PTR _Extension$[ebp]
  00a6f	c7 42 38 ff ff
	ff ff		 mov	 DWORD PTR [edx+56], -1
  00a76	c7 42 3c ff ff
	ff ff		 mov	 DWORD PTR [edx+60], -1
  00a7d	8b 45 e0	 mov	 eax, DWORD PTR _Extension$[ebp]
  00a80	c7 40 30 ff ff
	ff ff		 mov	 DWORD PTR [eax+48], -1
  00a87	c7 40 34 ff ff
	ff ff		 mov	 DWORD PTR [eax+52], -1

; 1428 : 		Extension->Queue.EncryptedAreaStart = Extension->Queue.EncryptedAreaEnd = -1;

  00a8e	8b 4d e0	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00a91	c7 81 98 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+152], -1
  00a9b	c7 81 9c 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+156], -1
  00aa5	8b 55 e0	 mov	 edx, DWORD PTR _Extension$[ebp]
  00aa8	c7 82 90 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+144], -1
  00ab2	c7 82 94 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+148], -1

; 1429 : 
; 1430 : 		EncryptedIoQueueResumeFromHold (&Extension->Queue);

  00abc	8b 45 e0	 mov	 eax, DWORD PTR _Extension$[ebp]
  00abf	83 c0 48	 add	 eax, 72			; 00000048H
  00ac2	50		 push	 eax
  00ac3	e8 00 00 00 00	 call	 _EncryptedIoQueueResumeFromHold@4

; 1431 : 
; 1432 : 		headerUpdateRequired = TRUE;

  00ac8	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _headerUpdateRequired$[ebp], 1
$LN11@SetupThrea:

; 1433 : 	}
; 1434 : 
; 1435 : 	Dump ("Setup completed:  EncryptedAreaStart=%I64d (%I64d)  EncryptedAreaEnd=%I64d (%I64d)\n", Extension->Queue.EncryptedAreaStart / 1024 / 1024, Extension->Queue.EncryptedAreaStart, Extension->Queue.EncryptedAreaEnd / 1024 / 1024, Extension->Queue.EncryptedAreaEnd);

  00acf	8b 4d e0	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00ad2	8b 91 9c 00 00
	00		 mov	 edx, DWORD PTR [ecx+156]
  00ad8	52		 push	 edx
  00ad9	8b 81 98 00 00
	00		 mov	 eax, DWORD PTR [ecx+152]
  00adf	50		 push	 eax
  00ae0	8b 4d e0	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00ae3	8b 91 98 00 00
	00		 mov	 edx, DWORD PTR [ecx+152]
  00ae9	8b 81 9c 00 00
	00		 mov	 eax, DWORD PTR [ecx+156]
  00aef	6a 00		 push	 0
  00af1	68 00 04 00 00	 push	 1024			; 00000400H
  00af6	50		 push	 eax
  00af7	52		 push	 edx
  00af8	e8 00 00 00 00	 call	 __alldiv
  00afd	6a 00		 push	 0
  00aff	68 00 04 00 00	 push	 1024			; 00000400H
  00b04	52		 push	 edx
  00b05	50		 push	 eax
  00b06	e8 00 00 00 00	 call	 __alldiv
  00b0b	52		 push	 edx
  00b0c	50		 push	 eax
  00b0d	8b 4d e0	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00b10	8b 91 94 00 00
	00		 mov	 edx, DWORD PTR [ecx+148]
  00b16	52		 push	 edx
  00b17	8b 81 90 00 00
	00		 mov	 eax, DWORD PTR [ecx+144]
  00b1d	50		 push	 eax
  00b1e	8b 4d e0	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00b21	6a 00		 push	 0
  00b23	68 00 04 00 00	 push	 1024			; 00000400H
  00b28	8b 91 94 00 00
	00		 mov	 edx, DWORD PTR [ecx+148]
  00b2e	52		 push	 edx
  00b2f	8b 81 90 00 00
	00		 mov	 eax, DWORD PTR [ecx+144]
  00b35	50		 push	 eax
  00b36	e8 00 00 00 00	 call	 __alldiv
  00b3b	6a 00		 push	 0
  00b3d	68 00 04 00 00	 push	 1024			; 00000400H
  00b42	52		 push	 edx
  00b43	50		 push	 eax
  00b44	e8 00 00 00 00	 call	 __alldiv
  00b49	52		 push	 edx
  00b4a	50		 push	 eax
  00b4b	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@OKPCPDJI@Setup?5completed?3?5?5EncryptedAreaS@FNODOBFM@
  00b50	e8 00 00 00 00	 call	 _DbgPrint
  00b55	83 c4 24	 add	 esp, 36			; 00000024H

; 1436 : 
; 1437 : 	if (headerUpdateRequired)

  00b58	83 7d e8 00	 cmp	 DWORD PTR _headerUpdateRequired$[ebp], 0
  00b5c	74 24		 je	 SHORT $LN8@SetupThrea

; 1438 : 	{
; 1439 : 		status = SaveDriveVolumeHeader (Extension);

  00b5e	8b 4d e0	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00b61	51		 push	 ecx
  00b62	e8 00 00 00 00	 call	 _SaveDriveVolumeHeader@4
  00b67	89 45 c8	 mov	 DWORD PTR _status$[ebp], eax

; 1440 : 
; 1441 : 		if (!NT_SUCCESS (status) && NT_SUCCESS (SetupResult))

  00b6a	83 7d c8 00	 cmp	 DWORD PTR _status$[ebp], 0
  00b6e	7d 12		 jge	 SHORT $LN8@SetupThrea
  00b70	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SetupResult, 0
  00b77	7c 09		 jl	 SHORT $LN8@SetupThrea

; 1442 : 			SetupResult = status;

  00b79	8b 55 c8	 mov	 edx, DWORD PTR _status$[ebp]
  00b7c	89 15 00 00 00
	00		 mov	 DWORD PTR _SetupResult, edx
$LN8@SetupThrea:

; 1443 : 	}
; 1444 : 
; 1445 : 	if (SetupRequest.SetupMode == SetupDecryption && Extension->ConfiguredEncryptedAreaEnd == -1 && Extension->DriveMounted)

  00b82	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _SetupRequest, 2
  00b89	75 6a		 jne	 SHORT $ret$28588
  00b8b	8b 45 e0	 mov	 eax, DWORD PTR _Extension$[ebp]
  00b8e	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv988[ebp], eax
  00b94	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR tv988[ebp]
  00b9a	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR tv988[ebp]
  00ba0	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00ba3	23 42 3c	 and	 eax, DWORD PTR [edx+60]
  00ba6	83 f8 ff	 cmp	 eax, -1
  00ba9	75 4a		 jne	 SHORT $ret$28588
  00bab	8b 4d e0	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00bae	83 b9 30 02 00
	00 00		 cmp	 DWORD PTR [ecx+560], 0
  00bb5	74 3e		 je	 SHORT $ret$28588
$LN5@SetupThrea:

; 1446 : 	{
; 1447 : 		while (!RootDeviceControlMutexAcquireNoWait() && !EncryptionSetupThreadAbortRequested)

  00bb7	e8 00 00 00 00	 call	 _RootDeviceControlMutexAcquireNoWait@0
  00bbc	85 c0		 test	 eax, eax
  00bbe	75 12		 jne	 SHORT $LN4@SetupThrea
  00bc0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _EncryptionSetupThreadAbortRequested, 0
  00bc7	75 09		 jne	 SHORT $LN4@SetupThrea

; 1448 : 		{
; 1449 : 			TCSleep (10);

  00bc9	6a 0a		 push	 10			; 0000000aH
  00bcb	e8 00 00 00 00	 call	 _TCSleep@4

; 1450 : 		}

  00bd0	eb e5		 jmp	 SHORT $LN5@SetupThrea
$LN4@SetupThrea:

; 1451 : 
; 1452 : 		// Disable hibernation (resume would fail due to a change in the system memory map)
; 1453 : 		HibernationEnabled = FALSE;

  00bd2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _HibernationEnabled, 0

; 1454 : 
; 1455 : 		DismountDrive (Extension, FALSE);

  00bdc	6a 00		 push	 0
  00bde	8b 55 e0	 mov	 edx, DWORD PTR _Extension$[ebp]
  00be1	52		 push	 edx
  00be2	e8 00 00 00 00	 call	 _DismountDrive@8

; 1456 : 
; 1457 : 		if (!EncryptionSetupThreadAbortRequested)

  00be7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _EncryptionSetupThreadAbortRequested, 0
  00bee	75 05		 jne	 SHORT $ret$28588

; 1458 : 			RootDeviceControlMutexRelease();

  00bf0	e8 00 00 00 00	 call	 _RootDeviceControlMutexRelease@0
$ret$28588:

; 1459 : 	}
; 1460 : 
; 1461 : ret:
; 1462 : 	if (buffer)

  00bf5	83 7d c4 00	 cmp	 DWORD PTR _buffer$[ebp], 0
  00bf9	74 0f		 je	 SHORT $LN2@SetupThrea

; 1463 : 		TCfree (buffer);

  00bfb	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00c00	8b 45 c4	 mov	 eax, DWORD PTR _buffer$[ebp]
  00c03	50		 push	 eax
  00c04	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN2@SetupThrea:

; 1464 : 	if (wipeBuffer)

  00c0a	83 7d ec 00	 cmp	 DWORD PTR _wipeBuffer$[ebp], 0
  00c0e	74 0f		 je	 SHORT $LN1@SetupThrea

; 1465 : 		TCfree (wipeBuffer);

  00c10	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00c15	8b 4d ec	 mov	 ecx, DWORD PTR _wipeBuffer$[ebp]
  00c18	51		 push	 ecx
  00c19	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN1@SetupThrea:

; 1466 : 
; 1467 : 	SetupInProgress = FALSE;

  00c1f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _SetupInProgress, 0

; 1468 : 	PsTerminateSystemThread (SetupResult);

  00c29	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SetupResult
  00c2f	52		 push	 edx
  00c30	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsTerminateSystemThread@4

; 1469 : }

  00c36	5e		 pop	 esi
  00c37	8b e5		 mov	 esp, ebp
  00c39	5d		 pop	 ebp
  00c3a	c2 04 00	 ret	 4
_SetupThreadProc@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@PIJMMLOC@TCWriteDevice?5error?5?$CFx?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BF@DGHCICOF@Header?5not?5decrypted?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EK@MOIFFFBD@Saving?3?5EncryptedAreaStart?$DN?$CFI64d@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0FO@BIDJBKJB@Saving?3?5ConfiguredEncryptedAreaS@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BG@EAILECP@TCReadDevice?5error?5?$CFx?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	_EncryptBuffer@16:PROC
EXTRN	_GetHeaderField32@8:PROC
EXTRN	_DecryptBuffer@16:PROC
EXTRN	__aullshr:PROC
;	COMDAT ??_C@_0BH@PIJMMLOC@TCWriteDevice?5error?5?$CFx?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BH@PIJMMLOC@TCWriteDevice?5error?5?$CFx?$AA@FNODOBFM@ DB 'TCWriteD'
	DB	'evice error %x', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BF@DGHCICOF@Header?5not?5decrypted?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BF@DGHCICOF@Header?5not?5decrypted?$AA@FNODOBFM@ DB 'Header not de'
	DB	'crypted', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EK@MOIFFFBD@Saving?3?5EncryptedAreaStart?$DN?$CFI64d@FNODOBFM@
text$s	SEGMENT
??_C@_0EK@MOIFFFBD@Saving?3?5EncryptedAreaStart?$DN?$CFI64d@FNODOBFM@ DB 'S'
	DB	'aving: EncryptedAreaStart=%I64d (%I64d)  EncryptedAreaEnd=%I6'
	DB	'4d (%I64d)', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0FO@BIDJBKJB@Saving?3?5ConfiguredEncryptedAreaS@FNODOBFM@
text$s	SEGMENT
??_C@_0FO@BIDJBKJB@Saving?3?5ConfiguredEncryptedAreaS@FNODOBFM@ DB 'Savin'
	DB	'g: ConfiguredEncryptedAreaStart=%I64d (%I64d)  ConfiguredEncr'
	DB	'yptedAreaEnd=%I64d (%I64d)', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BG@EAILECP@TCReadDevice?5error?5?$CFx?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BG@EAILECP@TCReadDevice?5error?5?$CFx?$AA@FNODOBFM@ DB 'TCReadDevi'
	DB	'ce error %x', 00H				;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _SaveDriveVolumeHeader@4
_TEXT	SEGMENT
tv407 = -56						; size = 4
tv404 = -52						; size = 8
tv393 = -44						; size = 8
tv383 = -36						; size = 4
_encryptedAreaLength$28045 = -32			; size = 8
_fieldPos$28046 = -24					; size = 4
_headerCrc32$28044 = -20				; size = 4
_header$ = -16						; size = 4
_status$ = -12						; size = 4
_offset$ = -8						; size = 8
_Extension$ = 8						; size = 4
_SaveDriveVolumeHeader@4 PROC				; COMDAT

; 410  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 38	 sub	 esp, 56			; 00000038H

; 411  : 	NTSTATUS status = STATUS_SUCCESS;

  00008	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _status$[ebp], 0

; 412  : 	LARGE_INTEGER offset;
; 413  : 	byte *header;
; 414  : 
; 415  : 	header = TCalloc (TC_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE);

  0000f	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00014	68 00 02 00 00	 push	 512			; 00000200H
  00019	6a 00		 push	 0
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00021	89 45 f0	 mov	 DWORD PTR _header$[ebp], eax

; 416  : 	if (!header)

  00024	83 7d f0 00	 cmp	 DWORD PTR _header$[ebp], 0
  00028	75 0a		 jne	 SHORT $LN8@SaveDriveV

; 417  : 		return STATUS_INSUFFICIENT_RESOURCES;

  0002a	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  0002f	e9 5b 04 00 00	 jmp	 $LN9@SaveDriveV
$LN8@SaveDriveV:

; 418  : 
; 419  : 	offset.QuadPart = TC_BOOT_VOLUME_HEADER_SECTOR_OFFSET;

  00034	c7 45 f8 00 7c
	00 00		 mov	 DWORD PTR _offset$[ebp], 31744 ; 00007c00H
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _offset$[ebp+4], 0

; 420  : 
; 421  : 	status = TCReadDevice (Extension->LowerDeviceObject, header, offset, TC_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE);

  00042	68 00 02 00 00	 push	 512			; 00000200H
  00047	8b 45 fc	 mov	 eax, DWORD PTR _offset$[ebp+4]
  0004a	50		 push	 eax
  0004b	8b 4d f8	 mov	 ecx, DWORD PTR _offset$[ebp]
  0004e	51		 push	 ecx
  0004f	8b 55 f0	 mov	 edx, DWORD PTR _header$[ebp]
  00052	52		 push	 edx
  00053	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  00056	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 _TCReadDevice@20
  0005f	89 45 f4	 mov	 DWORD PTR _status$[ebp], eax

; 422  : 	if (!NT_SUCCESS (status))

  00062	83 7d f4 00	 cmp	 DWORD PTR _status$[ebp], 0
  00066	7d 16		 jge	 SHORT $LN7@SaveDriveV

; 423  : 	{
; 424  : 		Dump ("TCReadDevice error %x", status);

  00068	8b 55 f4	 mov	 edx, DWORD PTR _status$[ebp]
  0006b	52		 push	 edx
  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@EAILECP@TCReadDevice?5error?5?$CFx?$AA@FNODOBFM@
  00071	e8 00 00 00 00	 call	 _DbgPrint
  00076	83 c4 08	 add	 esp, 8

; 425  : 		goto ret;

  00079	e9 ff 03 00 00	 jmp	 $ret$28037
$LN7@SaveDriveV:

; 426  : 	}
; 427  : 
; 428  : 	Dump ("Saving: ConfiguredEncryptedAreaStart=%I64d (%I64d)  ConfiguredEncryptedAreaEnd=%I64d (%I64d)\n", Extension->ConfiguredEncryptedAreaStart / 1024 / 1024, Extension->ConfiguredEncryptedAreaStart, Extension->ConfiguredEncryptedAreaEnd / 1024 / 1024, Extension->ConfiguredEncryptedAreaEnd);

  0007e	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  00081	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00084	51		 push	 ecx
  00085	8b 50 38	 mov	 edx, DWORD PTR [eax+56]
  00088	52		 push	 edx
  00089	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  0008c	6a 00		 push	 0
  0008e	68 00 04 00 00	 push	 1024			; 00000400H
  00093	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00096	51		 push	 ecx
  00097	8b 50 38	 mov	 edx, DWORD PTR [eax+56]
  0009a	52		 push	 edx
  0009b	e8 00 00 00 00	 call	 __alldiv
  000a0	6a 00		 push	 0
  000a2	68 00 04 00 00	 push	 1024			; 00000400H
  000a7	52		 push	 edx
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 __alldiv
  000ae	52		 push	 edx
  000af	50		 push	 eax
  000b0	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  000b3	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000b6	51		 push	 ecx
  000b7	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  000ba	52		 push	 edx
  000bb	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  000be	6a 00		 push	 0
  000c0	68 00 04 00 00	 push	 1024			; 00000400H
  000c5	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000c8	51		 push	 ecx
  000c9	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  000cc	52		 push	 edx
  000cd	e8 00 00 00 00	 call	 __alldiv
  000d2	6a 00		 push	 0
  000d4	68 00 04 00 00	 push	 1024			; 00000400H
  000d9	52		 push	 edx
  000da	50		 push	 eax
  000db	e8 00 00 00 00	 call	 __alldiv
  000e0	52		 push	 edx
  000e1	50		 push	 eax
  000e2	68 00 00 00 00	 push	 OFFSET ??_C@_0FO@BIDJBKJB@Saving?3?5ConfiguredEncryptedAreaS@FNODOBFM@
  000e7	e8 00 00 00 00	 call	 _DbgPrint
  000ec	83 c4 24	 add	 esp, 36			; 00000024H

; 429  : 	Dump ("Saving: EncryptedAreaStart=%I64d (%I64d)  EncryptedAreaEnd=%I64d (%I64d)\n", Extension->Queue.EncryptedAreaStart / 1024 / 1024, Extension->Queue.EncryptedAreaStart, Extension->Queue.EncryptedAreaEnd / 1024 / 1024, Extension->Queue.EncryptedAreaEnd);

  000ef	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  000f2	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [eax+156]
  000f8	51		 push	 ecx
  000f9	8b 90 98 00 00
	00		 mov	 edx, DWORD PTR [eax+152]
  000ff	52		 push	 edx
  00100	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  00103	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  00109	8b 90 9c 00 00
	00		 mov	 edx, DWORD PTR [eax+156]
  0010f	6a 00		 push	 0
  00111	68 00 04 00 00	 push	 1024			; 00000400H
  00116	52		 push	 edx
  00117	51		 push	 ecx
  00118	e8 00 00 00 00	 call	 __alldiv
  0011d	6a 00		 push	 0
  0011f	68 00 04 00 00	 push	 1024			; 00000400H
  00124	52		 push	 edx
  00125	50		 push	 eax
  00126	e8 00 00 00 00	 call	 __alldiv
  0012b	52		 push	 edx
  0012c	50		 push	 eax
  0012d	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  00130	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [eax+148]
  00136	51		 push	 ecx
  00137	8b 90 90 00 00
	00		 mov	 edx, DWORD PTR [eax+144]
  0013d	52		 push	 edx
  0013e	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  00141	6a 00		 push	 0
  00143	68 00 04 00 00	 push	 1024			; 00000400H
  00148	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [eax+148]
  0014e	51		 push	 ecx
  0014f	8b 90 90 00 00
	00		 mov	 edx, DWORD PTR [eax+144]
  00155	52		 push	 edx
  00156	e8 00 00 00 00	 call	 __alldiv
  0015b	6a 00		 push	 0
  0015d	68 00 04 00 00	 push	 1024			; 00000400H
  00162	52		 push	 edx
  00163	50		 push	 eax
  00164	e8 00 00 00 00	 call	 __alldiv
  00169	52		 push	 edx
  0016a	50		 push	 eax
  0016b	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@MOIFFFBD@Saving?3?5EncryptedAreaStart?$DN?$CFI64d@FNODOBFM@
  00170	e8 00 00 00 00	 call	 _DbgPrint
  00175	83 c4 24	 add	 esp, 36			; 00000024H

; 430  : 	
; 431  : 	if (Extension->Queue.EncryptedAreaStart == -1 || Extension->Queue.EncryptedAreaEnd == -1
; 432  : 		|| Extension->Queue.EncryptedAreaEnd <= Extension->Queue.EncryptedAreaStart)

  00178	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  0017b	89 45 dc	 mov	 DWORD PTR tv383[ebp], eax
  0017e	8b 4d dc	 mov	 ecx, DWORD PTR tv383[ebp]
  00181	8b 55 dc	 mov	 edx, DWORD PTR tv383[ebp]
  00184	8b 81 90 00 00
	00		 mov	 eax, DWORD PTR [ecx+144]
  0018a	23 82 94 00 00
	00		 and	 eax, DWORD PTR [edx+148]
  00190	83 f8 ff	 cmp	 eax, -1
  00193	74 59		 je	 SHORT $LN5@SaveDriveV
  00195	8b 4d 08	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00198	8b 91 98 00 00
	00		 mov	 edx, DWORD PTR [ecx+152]
  0019e	8b 81 9c 00 00
	00		 mov	 eax, DWORD PTR [ecx+156]
  001a4	89 55 d4	 mov	 DWORD PTR tv393[ebp], edx
  001a7	89 45 d8	 mov	 DWORD PTR tv393[ebp+4], eax
  001aa	8b 4d d4	 mov	 ecx, DWORD PTR tv393[ebp]
  001ad	23 4d d8	 and	 ecx, DWORD PTR tv393[ebp+4]
  001b0	83 f9 ff	 cmp	 ecx, -1
  001b3	74 39		 je	 SHORT $LN5@SaveDriveV
  001b5	8b 55 08	 mov	 edx, DWORD PTR _Extension$[ebp]
  001b8	8b 82 98 00 00
	00		 mov	 eax, DWORD PTR [edx+152]
  001be	8b 8a 9c 00 00
	00		 mov	 ecx, DWORD PTR [edx+156]
  001c4	8b 55 08	 mov	 edx, DWORD PTR _Extension$[ebp]
  001c7	89 45 cc	 mov	 DWORD PTR tv404[ebp], eax
  001ca	89 4d d0	 mov	 DWORD PTR tv404[ebp+4], ecx
  001cd	89 55 c8	 mov	 DWORD PTR tv407[ebp], edx
  001d0	8b 45 c8	 mov	 eax, DWORD PTR tv407[ebp]
  001d3	8b 4d d0	 mov	 ecx, DWORD PTR tv404[ebp+4]
  001d6	3b 88 94 00 00
	00		 cmp	 ecx, DWORD PTR [eax+148]
  001dc	7f 3e		 jg	 SHORT $LN6@SaveDriveV
  001de	7c 0e		 jl	 SHORT $LN5@SaveDriveV
  001e0	8b 55 c8	 mov	 edx, DWORD PTR tv407[ebp]
  001e3	8b 45 cc	 mov	 eax, DWORD PTR tv404[ebp]
  001e6	3b 82 90 00 00
	00		 cmp	 eax, DWORD PTR [edx+144]
  001ec	77 2e		 ja	 SHORT $LN6@SaveDriveV
$LN5@SaveDriveV:

; 433  : 	{
; 434  : 		if (SetupRequest.SetupMode == SetupDecryption)

  001ee	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _SetupRequest, 2
  001f5	75 20		 jne	 SHORT $LN4@SaveDriveV

; 435  : 		{
; 436  : 			memset (header, 0, TC_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE);

  001f7	68 00 02 00 00	 push	 512			; 00000200H
  001fc	6a 00		 push	 0
  001fe	8b 4d f0	 mov	 ecx, DWORD PTR _header$[ebp]
  00201	51		 push	 ecx
  00202	e8 00 00 00 00	 call	 _memset
  00207	83 c4 0c	 add	 esp, 12			; 0000000cH

; 437  : 			Extension->VolumeHeaderPresent = FALSE;

  0020a	8b 55 08	 mov	 edx, DWORD PTR _Extension$[ebp]
  0020d	c7 82 2c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+556], 0
$LN4@SaveDriveV:

; 438  : 		}
; 439  : 	}
; 440  : 	else

  00217	e9 2a 02 00 00	 jmp	 $LN3@SaveDriveV
$LN6@SaveDriveV:

; 441  : 	{
; 442  : 		uint32 headerCrc32;
; 443  : 		uint64 encryptedAreaLength = Extension->Queue.EncryptedAreaEnd + 1 - Extension->Queue.EncryptedAreaStart;

  0021c	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  0021f	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  00225	8b 90 9c 00 00
	00		 mov	 edx, DWORD PTR [eax+156]
  0022b	83 c1 01	 add	 ecx, 1
  0022e	83 d2 00	 adc	 edx, 0
  00231	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  00234	2b 88 90 00 00
	00		 sub	 ecx, DWORD PTR [eax+144]
  0023a	1b 90 94 00 00
	00		 sbb	 edx, DWORD PTR [eax+148]
  00240	89 4d e0	 mov	 DWORD PTR _encryptedAreaLength$28045[ebp], ecx
  00243	89 55 e4	 mov	 DWORD PTR _encryptedAreaLength$28045[ebp+4], edx

; 444  : 		byte *fieldPos = header + TC_HEADER_OFFSET_ENCRYPTED_AREA_LENGTH;

  00246	8b 4d f0	 mov	 ecx, DWORD PTR _header$[ebp]
  00249	83 c1 74	 add	 ecx, 116		; 00000074H
  0024c	89 4d e8	 mov	 DWORD PTR _fieldPos$28046[ebp], ecx

; 445  : 
; 446  : 		DecryptBuffer (header + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, Extension->HeaderCryptoInfo);

  0024f	8b 55 08	 mov	 edx, DWORD PTR _Extension$[ebp]
  00252	8b 82 44 02 00
	00		 mov	 eax, DWORD PTR [edx+580]
  00258	50		 push	 eax
  00259	6a 00		 push	 0
  0025b	68 c0 01 00 00	 push	 448			; 000001c0H
  00260	8b 4d f0	 mov	 ecx, DWORD PTR _header$[ebp]
  00263	83 c1 40	 add	 ecx, 64			; 00000040H
  00266	51		 push	 ecx
  00267	e8 00 00 00 00	 call	 _DecryptBuffer@16

; 447  : 
; 448  : 		/* Modifying 'TRUE' can introduce incompatibility with previous versions. */
; 449  : 		if (GetHeaderField32 (header, TC_HEADER_OFFSET_MAGIC) != 0x54525545)

  0026c	6a 40		 push	 64			; 00000040H
  0026e	8b 55 f0	 mov	 edx, DWORD PTR _header$[ebp]
  00271	52		 push	 edx
  00272	e8 00 00 00 00	 call	 _GetHeaderField32@8
  00277	3d 45 55 52 54	 cmp	 eax, 1414681925		; 54525545H
  0027c	74 19		 je	 SHORT $LN2@SaveDriveV

; 450  : 		{
; 451  : 			Dump ("Header not decrypted");

  0027e	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@DGHCICOF@Header?5not?5decrypted?$AA@FNODOBFM@
  00283	e8 00 00 00 00	 call	 _DbgPrint
  00288	83 c4 04	 add	 esp, 4

; 452  : 			status = STATUS_UNKNOWN_REVISION;

  0028b	c7 45 f4 58 00
	00 c0		 mov	 DWORD PTR _status$[ebp], -1073741736 ; c0000058H

; 453  : 			goto ret;

  00292	e9 e6 01 00 00	 jmp	 $ret$28037
$LN2@SaveDriveV:

; 454  : 		}
; 455  : 
; 456  : 		mputInt64 (fieldPos, encryptedAreaLength);

  00297	8b 45 e0	 mov	 eax, DWORD PTR _encryptedAreaLength$28045[ebp]
  0029a	8b 55 e4	 mov	 edx, DWORD PTR _encryptedAreaLength$28045[ebp+4]
  0029d	b1 38		 mov	 cl, 56			; 00000038H
  0029f	e8 00 00 00 00	 call	 __aullshr
  002a4	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002a9	83 e2 00	 and	 edx, 0
  002ac	8b 4d e8	 mov	 ecx, DWORD PTR _fieldPos$28046[ebp]
  002af	88 01		 mov	 BYTE PTR [ecx], al
  002b1	8b 55 e8	 mov	 edx, DWORD PTR _fieldPos$28046[ebp]
  002b4	83 c2 01	 add	 edx, 1
  002b7	89 55 e8	 mov	 DWORD PTR _fieldPos$28046[ebp], edx
  002ba	8b 45 e0	 mov	 eax, DWORD PTR _encryptedAreaLength$28045[ebp]
  002bd	8b 55 e4	 mov	 edx, DWORD PTR _encryptedAreaLength$28045[ebp+4]
  002c0	b1 30		 mov	 cl, 48			; 00000030H
  002c2	e8 00 00 00 00	 call	 __aullshr
  002c7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002cc	83 e2 00	 and	 edx, 0
  002cf	8b 4d e8	 mov	 ecx, DWORD PTR _fieldPos$28046[ebp]
  002d2	88 01		 mov	 BYTE PTR [ecx], al
  002d4	8b 55 e8	 mov	 edx, DWORD PTR _fieldPos$28046[ebp]
  002d7	83 c2 01	 add	 edx, 1
  002da	89 55 e8	 mov	 DWORD PTR _fieldPos$28046[ebp], edx
  002dd	8b 45 e0	 mov	 eax, DWORD PTR _encryptedAreaLength$28045[ebp]
  002e0	8b 55 e4	 mov	 edx, DWORD PTR _encryptedAreaLength$28045[ebp+4]
  002e3	b1 28		 mov	 cl, 40			; 00000028H
  002e5	e8 00 00 00 00	 call	 __aullshr
  002ea	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002ef	83 e2 00	 and	 edx, 0
  002f2	8b 4d e8	 mov	 ecx, DWORD PTR _fieldPos$28046[ebp]
  002f5	88 01		 mov	 BYTE PTR [ecx], al
  002f7	8b 55 e8	 mov	 edx, DWORD PTR _fieldPos$28046[ebp]
  002fa	83 c2 01	 add	 edx, 1
  002fd	89 55 e8	 mov	 DWORD PTR _fieldPos$28046[ebp], edx
  00300	8b 45 e0	 mov	 eax, DWORD PTR _encryptedAreaLength$28045[ebp]
  00303	8b 55 e4	 mov	 edx, DWORD PTR _encryptedAreaLength$28045[ebp+4]
  00306	b1 20		 mov	 cl, 32			; 00000020H
  00308	e8 00 00 00 00	 call	 __aullshr
  0030d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00312	83 e2 00	 and	 edx, 0
  00315	8b 4d e8	 mov	 ecx, DWORD PTR _fieldPos$28046[ebp]
  00318	88 01		 mov	 BYTE PTR [ecx], al
  0031a	8b 55 e8	 mov	 edx, DWORD PTR _fieldPos$28046[ebp]
  0031d	83 c2 01	 add	 edx, 1
  00320	89 55 e8	 mov	 DWORD PTR _fieldPos$28046[ebp], edx
  00323	8b 45 e0	 mov	 eax, DWORD PTR _encryptedAreaLength$28045[ebp]
  00326	8b 55 e4	 mov	 edx, DWORD PTR _encryptedAreaLength$28045[ebp+4]
  00329	b1 18		 mov	 cl, 24			; 00000018H
  0032b	e8 00 00 00 00	 call	 __aullshr
  00330	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00335	83 e2 00	 and	 edx, 0
  00338	8b 4d e8	 mov	 ecx, DWORD PTR _fieldPos$28046[ebp]
  0033b	88 01		 mov	 BYTE PTR [ecx], al
  0033d	8b 55 e8	 mov	 edx, DWORD PTR _fieldPos$28046[ebp]
  00340	83 c2 01	 add	 edx, 1
  00343	89 55 e8	 mov	 DWORD PTR _fieldPos$28046[ebp], edx
  00346	8b 45 e0	 mov	 eax, DWORD PTR _encryptedAreaLength$28045[ebp]
  00349	8b 55 e4	 mov	 edx, DWORD PTR _encryptedAreaLength$28045[ebp+4]
  0034c	b1 10		 mov	 cl, 16			; 00000010H
  0034e	e8 00 00 00 00	 call	 __aullshr
  00353	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00358	83 e2 00	 and	 edx, 0
  0035b	8b 4d e8	 mov	 ecx, DWORD PTR _fieldPos$28046[ebp]
  0035e	88 01		 mov	 BYTE PTR [ecx], al
  00360	8b 55 e8	 mov	 edx, DWORD PTR _fieldPos$28046[ebp]
  00363	83 c2 01	 add	 edx, 1
  00366	89 55 e8	 mov	 DWORD PTR _fieldPos$28046[ebp], edx
  00369	8b 45 e0	 mov	 eax, DWORD PTR _encryptedAreaLength$28045[ebp]
  0036c	8b 55 e4	 mov	 edx, DWORD PTR _encryptedAreaLength$28045[ebp+4]
  0036f	b1 08		 mov	 cl, 8
  00371	e8 00 00 00 00	 call	 __aullshr
  00376	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0037b	83 e2 00	 and	 edx, 0
  0037e	8b 4d e8	 mov	 ecx, DWORD PTR _fieldPos$28046[ebp]
  00381	88 01		 mov	 BYTE PTR [ecx], al
  00383	8b 55 e8	 mov	 edx, DWORD PTR _fieldPos$28046[ebp]
  00386	83 c2 01	 add	 edx, 1
  00389	89 55 e8	 mov	 DWORD PTR _fieldPos$28046[ebp], edx
  0038c	8b 45 e0	 mov	 eax, DWORD PTR _encryptedAreaLength$28045[ebp]
  0038f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00394	8b 4d e4	 mov	 ecx, DWORD PTR _encryptedAreaLength$28045[ebp+4]
  00397	83 e1 00	 and	 ecx, 0
  0039a	8b 55 e8	 mov	 edx, DWORD PTR _fieldPos$28046[ebp]
  0039d	88 02		 mov	 BYTE PTR [edx], al
  0039f	8b 45 e8	 mov	 eax, DWORD PTR _fieldPos$28046[ebp]
  003a2	83 c0 01	 add	 eax, 1
  003a5	89 45 e8	 mov	 DWORD PTR _fieldPos$28046[ebp], eax

; 457  : 
; 458  : 		headerCrc32 = GetCrc32 (header + TC_HEADER_OFFSET_MAGIC, TC_HEADER_OFFSET_HEADER_CRC - TC_HEADER_OFFSET_MAGIC);

  003a8	68 bc 00 00 00	 push	 188			; 000000bcH
  003ad	8b 4d f0	 mov	 ecx, DWORD PTR _header$[ebp]
  003b0	83 c1 40	 add	 ecx, 64			; 00000040H
  003b3	51		 push	 ecx
  003b4	e8 00 00 00 00	 call	 _GetCrc32@8
  003b9	89 45 ec	 mov	 DWORD PTR _headerCrc32$28044[ebp], eax

; 459  : 		fieldPos = header + TC_HEADER_OFFSET_HEADER_CRC;

  003bc	8b 55 f0	 mov	 edx, DWORD PTR _header$[ebp]
  003bf	81 c2 fc 00 00
	00		 add	 edx, 252		; 000000fcH
  003c5	89 55 e8	 mov	 DWORD PTR _fieldPos$28046[ebp], edx

; 460  : 		mputLong (fieldPos, headerCrc32);

  003c8	8b 45 ec	 mov	 eax, DWORD PTR _headerCrc32$28044[ebp]
  003cb	c1 e8 18	 shr	 eax, 24			; 00000018H
  003ce	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003d3	8b 4d e8	 mov	 ecx, DWORD PTR _fieldPos$28046[ebp]
  003d6	88 01		 mov	 BYTE PTR [ecx], al
  003d8	8b 55 e8	 mov	 edx, DWORD PTR _fieldPos$28046[ebp]
  003db	83 c2 01	 add	 edx, 1
  003de	89 55 e8	 mov	 DWORD PTR _fieldPos$28046[ebp], edx
  003e1	8b 45 ec	 mov	 eax, DWORD PTR _headerCrc32$28044[ebp]
  003e4	c1 e8 10	 shr	 eax, 16			; 00000010H
  003e7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003ec	8b 4d e8	 mov	 ecx, DWORD PTR _fieldPos$28046[ebp]
  003ef	88 01		 mov	 BYTE PTR [ecx], al
  003f1	8b 55 e8	 mov	 edx, DWORD PTR _fieldPos$28046[ebp]
  003f4	83 c2 01	 add	 edx, 1
  003f7	89 55 e8	 mov	 DWORD PTR _fieldPos$28046[ebp], edx
  003fa	8b 45 ec	 mov	 eax, DWORD PTR _headerCrc32$28044[ebp]
  003fd	c1 e8 08	 shr	 eax, 8
  00400	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00405	8b 4d e8	 mov	 ecx, DWORD PTR _fieldPos$28046[ebp]
  00408	88 01		 mov	 BYTE PTR [ecx], al
  0040a	8b 55 e8	 mov	 edx, DWORD PTR _fieldPos$28046[ebp]
  0040d	83 c2 01	 add	 edx, 1
  00410	89 55 e8	 mov	 DWORD PTR _fieldPos$28046[ebp], edx
  00413	8b 45 ec	 mov	 eax, DWORD PTR _headerCrc32$28044[ebp]
  00416	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0041b	8b 4d e8	 mov	 ecx, DWORD PTR _fieldPos$28046[ebp]
  0041e	88 01		 mov	 BYTE PTR [ecx], al
  00420	8b 55 e8	 mov	 edx, DWORD PTR _fieldPos$28046[ebp]
  00423	83 c2 01	 add	 edx, 1
  00426	89 55 e8	 mov	 DWORD PTR _fieldPos$28046[ebp], edx

; 461  : 
; 462  : 		EncryptBuffer (header + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, Extension->HeaderCryptoInfo);

  00429	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  0042c	8b 88 44 02 00
	00		 mov	 ecx, DWORD PTR [eax+580]
  00432	51		 push	 ecx
  00433	6a 00		 push	 0
  00435	68 c0 01 00 00	 push	 448			; 000001c0H
  0043a	8b 55 f0	 mov	 edx, DWORD PTR _header$[ebp]
  0043d	83 c2 40	 add	 edx, 64			; 00000040H
  00440	52		 push	 edx
  00441	e8 00 00 00 00	 call	 _EncryptBuffer@16
$LN3@SaveDriveV:

; 463  : 	}
; 464  : 
; 465  : 	status = TCWriteDevice (Extension->LowerDeviceObject, header, offset, TC_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE);

  00446	68 00 02 00 00	 push	 512			; 00000200H
  0044b	8b 45 fc	 mov	 eax, DWORD PTR _offset$[ebp+4]
  0044e	50		 push	 eax
  0044f	8b 4d f8	 mov	 ecx, DWORD PTR _offset$[ebp]
  00452	51		 push	 ecx
  00453	8b 55 f0	 mov	 edx, DWORD PTR _header$[ebp]
  00456	52		 push	 edx
  00457	8b 45 08	 mov	 eax, DWORD PTR _Extension$[ebp]
  0045a	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0045d	51		 push	 ecx
  0045e	e8 00 00 00 00	 call	 _TCWriteDevice@20
  00463	89 45 f4	 mov	 DWORD PTR _status$[ebp], eax

; 466  : 	if (!NT_SUCCESS (status))

  00466	83 7d f4 00	 cmp	 DWORD PTR _status$[ebp], 0
  0046a	7d 11		 jge	 SHORT $ret$28037

; 467  : 	{
; 468  : 		Dump ("TCWriteDevice error %x", status);

  0046c	8b 55 f4	 mov	 edx, DWORD PTR _status$[ebp]
  0046f	52		 push	 edx
  00470	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@PIJMMLOC@TCWriteDevice?5error?5?$CFx?$AA@FNODOBFM@
  00475	e8 00 00 00 00	 call	 _DbgPrint
  0047a	83 c4 08	 add	 esp, 8
$ret$28037:

; 469  : 		goto ret;
; 470  : 	}
; 471  : 
; 472  : ret:
; 473  : 	TCfree (header);

  0047d	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00482	8b 45 f0	 mov	 eax, DWORD PTR _header$[ebp]
  00485	50		 push	 eax
  00486	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 474  : 	return status;

  0048c	8b 45 f4	 mov	 eax, DWORD PTR _status$[ebp]
$LN9@SaveDriveV:

; 475  : }

  0048f	8b e5		 mov	 esp, ebp
  00491	5d		 pop	 ebp
  00492	c2 04 00	 ret	 4
_SaveDriveVolumeHeader@4 ENDP
_TEXT	ENDS
PUBLIC	_GetBootDriveVolumeProperties@8
; Function compile flags: /Odtp
;	COMDAT _GetBootDriveVolumeProperties@8
_TEXT	SEGMENT
_prop$28727 = -8					; size = 4
_Extension$28726 = -4					; size = 4
_irp$ = 8						; size = 4
_irpSp$ = 12						; size = 4
_GetBootDriveVolumeProperties@8 PROC			; COMDAT

; 1505 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 1506 : 	if (ValidateIOBufferSize (irp, sizeof (VOLUME_PROPERTIES_STRUCT), ValidateOutput))

  00008	6a 01		 push	 1
  0000a	68 54 02 00 00	 push	 596			; 00000254H
  0000f	8b 45 08	 mov	 eax, DWORD PTR _irp$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00018	85 c0		 test	 eax, eax
  0001a	0f 84 4e 01 00
	00		 je	 $LN5@GetBootDri

; 1507 : 	{
; 1508 : 		DriveFilterExtension *Extension = BootDriveFilterExtension;

  00020	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _BootDriveFilterExtension
  00026	89 4d fc	 mov	 DWORD PTR _Extension$28726[ebp], ecx

; 1509 : 		VOLUME_PROPERTIES_STRUCT *prop = (VOLUME_PROPERTIES_STRUCT *) irp->AssociatedIrp.SystemBuffer;

  00029	8b 55 08	 mov	 edx, DWORD PTR _irp$[ebp]
  0002c	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0002f	89 45 f8	 mov	 DWORD PTR _prop$28727[ebp], eax

; 1510 : 		memset (prop, 0, sizeof (*prop));

  00032	68 54 02 00 00	 push	 596			; 00000254H
  00037	6a 00		 push	 0
  00039	8b 4d f8	 mov	 ecx, DWORD PTR _prop$28727[ebp]
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 _memset
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1511 : 
; 1512 : 		if (!BootDriveFound || !Extension || !Extension->DriveMounted)

  00045	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _BootDriveFound, 0
  0004c	74 12		 je	 SHORT $LN2@GetBootDri
  0004e	83 7d fc 00	 cmp	 DWORD PTR _Extension$28726[ebp], 0
  00052	74 0c		 je	 SHORT $LN2@GetBootDri
  00054	8b 55 fc	 mov	 edx, DWORD PTR _Extension$28726[ebp]
  00057	83 ba 30 02 00
	00 00		 cmp	 DWORD PTR [edx+560], 0
  0005e	75 19		 jne	 SHORT $LN3@GetBootDri
$LN2@GetBootDri:

; 1513 : 		{
; 1514 : 			irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  00060	8b 45 08	 mov	 eax, DWORD PTR _irp$[ebp]
  00063	c7 40 18 0d 00
	00 c0		 mov	 DWORD PTR [eax+24], -1073741811 ; c000000dH

; 1515 : 			irp->IoStatus.Information = 0;

  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _irp$[ebp]
  0006d	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 1516 : 		}
; 1517 : 		else

  00074	e9 f5 00 00 00	 jmp	 $LN5@GetBootDri
$LN3@GetBootDri:

; 1518 : 		{
; 1519 : 			prop->hiddenVolume = Extension->Queue.CryptoInfo->hiddenVolume;

  00079	8b 55 fc	 mov	 edx, DWORD PTR _Extension$28726[ebp]
  0007c	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  0007f	8b 4d f8	 mov	 ecx, DWORD PTR _prop$28727[ebp]
  00082	8b 90 a0 29 00
	00		 mov	 edx, DWORD PTR [eax+10656]
  00088	89 91 28 02 00
	00		 mov	 DWORD PTR [ecx+552], edx

; 1520 : 			prop->diskLength = Extension->ConfiguredEncryptedAreaEnd + 1 - Extension->ConfiguredEncryptedAreaStart;

  0008e	8b 45 fc	 mov	 eax, DWORD PTR _Extension$28726[ebp]
  00091	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00094	83 c1 01	 add	 ecx, 1
  00097	8b 50 3c	 mov	 edx, DWORD PTR [eax+60]
  0009a	83 d2 00	 adc	 edx, 0
  0009d	8b 45 fc	 mov	 eax, DWORD PTR _Extension$28726[ebp]
  000a0	2b 48 30	 sub	 ecx, DWORD PTR [eax+48]
  000a3	1b 50 34	 sbb	 edx, DWORD PTR [eax+52]
  000a6	8b 45 f8	 mov	 eax, DWORD PTR _prop$28727[ebp]
  000a9	89 88 10 02 00
	00		 mov	 DWORD PTR [eax+528], ecx
  000af	89 90 14 02 00
	00		 mov	 DWORD PTR [eax+532], edx

; 1521 : 			prop->ea = Extension->Queue.CryptoInfo->ea;

  000b5	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$28726[ebp]
  000b8	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  000bb	8b 45 f8	 mov	 eax, DWORD PTR _prop$28727[ebp]
  000be	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000c0	89 88 18 02 00
	00		 mov	 DWORD PTR [eax+536], ecx

; 1522 : 			prop->mode = Extension->Queue.CryptoInfo->mode;

  000c6	8b 55 fc	 mov	 edx, DWORD PTR _Extension$28726[ebp]
  000c9	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  000cc	8b 4d f8	 mov	 ecx, DWORD PTR _prop$28727[ebp]
  000cf	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000d2	89 91 1c 02 00
	00		 mov	 DWORD PTR [ecx+540], edx

; 1523 : 			prop->pkcs5 = Extension->Queue.CryptoInfo->pkcs5;

  000d8	8b 45 fc	 mov	 eax, DWORD PTR _Extension$28726[ebp]
  000db	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  000de	8b 55 f8	 mov	 edx, DWORD PTR _prop$28727[ebp]
  000e1	8b 81 ec 43 00
	00		 mov	 eax, DWORD PTR [ecx+17388]
  000e7	89 82 20 02 00
	00		 mov	 DWORD PTR [edx+544], eax

; 1524 : 			prop->pkcs5Iterations = Extension->Queue.CryptoInfo->noIterations;

  000ed	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$28726[ebp]
  000f0	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  000f3	8b 45 f8	 mov	 eax, DWORD PTR _prop$28727[ebp]
  000f6	8b 8a e8 43 00
	00		 mov	 ecx, DWORD PTR [edx+17384]
  000fc	89 88 24 02 00
	00		 mov	 DWORD PTR [eax+548], ecx

; 1525 : #if 0
; 1526 : 			prop->volumeCreationTime = Extension->Queue.CryptoInfo->volume_creation_time;
; 1527 : 			prop->headerCreationTime = Extension->Queue.CryptoInfo->header_creation_time;
; 1528 : #endif
; 1529 : 			prop->volFormatVersion = Extension->Queue.CryptoInfo->LegacyVolume ? TC_VOLUME_FORMAT_VERSION_PRE_6_0 : TC_VOLUME_FORMAT_VERSION;

  00102	8b 55 fc	 mov	 edx, DWORD PTR _Extension$28726[ebp]
  00105	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  00108	8b 88 3c 44 00
	00		 mov	 ecx, DWORD PTR [eax+17468]
  0010e	f7 d9		 neg	 ecx
  00110	1b c9		 sbb	 ecx, ecx
  00112	83 c1 02	 add	 ecx, 2
  00115	8b 55 f8	 mov	 edx, DWORD PTR _prop$28727[ebp]
  00118	89 8a 50 02 00
	00		 mov	 DWORD PTR [edx+592], ecx

; 1530 : 
; 1531 : 			prop->totalBytesRead = Extension->Queue.TotalBytesRead;

  0011e	8b 45 f8	 mov	 eax, DWORD PTR _prop$28727[ebp]
  00121	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$28726[ebp]
  00124	8b 91 f0 01 00
	00		 mov	 edx, DWORD PTR [ecx+496]
  0012a	89 90 3c 02 00
	00		 mov	 DWORD PTR [eax+572], edx
  00130	8b 89 f4 01 00
	00		 mov	 ecx, DWORD PTR [ecx+500]
  00136	89 88 40 02 00
	00		 mov	 DWORD PTR [eax+576], ecx

; 1532 : 			prop->totalBytesWritten = Extension->Queue.TotalBytesWritten;

  0013c	8b 55 f8	 mov	 edx, DWORD PTR _prop$28727[ebp]
  0013f	8b 45 fc	 mov	 eax, DWORD PTR _Extension$28726[ebp]
  00142	8b 88 f8 01 00
	00		 mov	 ecx, DWORD PTR [eax+504]
  00148	89 8a 44 02 00
	00		 mov	 DWORD PTR [edx+580], ecx
  0014e	8b 80 fc 01 00
	00		 mov	 eax, DWORD PTR [eax+508]
  00154	89 82 48 02 00
	00		 mov	 DWORD PTR [edx+584], eax

; 1533 : 
; 1534 : 			irp->IoStatus.Information = sizeof (VOLUME_PROPERTIES_STRUCT);

  0015a	8b 4d 08	 mov	 ecx, DWORD PTR _irp$[ebp]
  0015d	c7 41 1c 54 02
	00 00		 mov	 DWORD PTR [ecx+28], 596	; 00000254H

; 1535 : 			irp->IoStatus.Status = STATUS_SUCCESS;

  00164	8b 55 08	 mov	 edx, DWORD PTR _irp$[ebp]
  00167	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0
$LN5@GetBootDri:

; 1536 : 		}
; 1537 : 	}
; 1538 : }

  0016e	8b e5		 mov	 esp, ebp
  00170	5d		 pop	 ebp
  00171	c2 08 00	 ret	 8
_GetBootDriveVolumeProperties@8 ENDP
_TEXT	ENDS
PUBLIC	_GetBootEncryptionStatus@8
EXTRN	_HiddenSysLeakProtectionCount:DWORD
; Function compile flags: /Odtp
;	COMDAT _GetBootEncryptionStatus@8
_TEXT	SEGMENT
tv94 = -20						; size = 4
tv182 = -16						; size = 4
_irql$28750 = -9					; size = 1
_bootEncStatus$28743 = -8				; size = 4
_Extension$28742 = -4					; size = 4
_irp$ = 8						; size = 4
_irpSp$ = 12						; size = 4
_GetBootEncryptionStatus@8 PROC				; COMDAT

; 1542 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 14	 sub	 esp, 20			; 00000014H

; 1543 : 	/* IMPORTANT: Do NOT add any potentially time-consuming operations to this function. */
; 1544 : 
; 1545 : 	if (ValidateIOBufferSize (irp, sizeof (BootEncryptionStatus), ValidateOutput))

  00008	6a 01		 push	 1
  0000a	6a 5e		 push	 94			; 0000005eH
  0000c	8b 45 08	 mov	 eax, DWORD PTR _irp$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00015	85 c0		 test	 eax, eax
  00017	0f 84 01 02 00
	00		 je	 $LN9@GetBootEnc

; 1546 : 	{
; 1547 : 		DriveFilterExtension *Extension = BootDriveFilterExtension;

  0001d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _BootDriveFilterExtension
  00023	89 4d fc	 mov	 DWORD PTR _Extension$28742[ebp], ecx

; 1548 : 		BootEncryptionStatus *bootEncStatus = (BootEncryptionStatus *) irp->AssociatedIrp.SystemBuffer;

  00026	8b 55 08	 mov	 edx, DWORD PTR _irp$[ebp]
  00029	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0002c	89 45 f8	 mov	 DWORD PTR _bootEncStatus$28743[ebp], eax

; 1549 : 		memset (bootEncStatus, 0, sizeof (*bootEncStatus));

  0002f	6a 5e		 push	 94			; 0000005eH
  00031	6a 00		 push	 0
  00033	8b 4d f8	 mov	 ecx, DWORD PTR _bootEncStatus$28743[ebp]
  00036	51		 push	 ecx
  00037	e8 00 00 00 00	 call	 _memset
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1550 : 
; 1551 : 		if (BootArgsValid)

  0003f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _BootArgsValid, 0
  00046	74 0d		 je	 SHORT $LN7@GetBootEnc

; 1552 : 			bootEncStatus->BootLoaderVersion = BootArgs.BootLoaderVersion;

  00048	8b 55 f8	 mov	 edx, DWORD PTR _bootEncStatus$28743[ebp]
  0004b	66 a1 08 00 00
	00		 mov	 ax, WORD PTR _BootArgs+8
  00051	66 89 42 04	 mov	 WORD PTR [edx+4], ax
$LN7@GetBootEnc:

; 1553 : 
; 1554 : 		bootEncStatus->DeviceFilterActive = DeviceFilterActive;

  00055	8b 4d f8	 mov	 ecx, DWORD PTR _bootEncStatus$28743[ebp]
  00058	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _DeviceFilterActive
  0005e	89 11		 mov	 DWORD PTR [ecx], edx

; 1555 : 		bootEncStatus->SetupInProgress = SetupInProgress;

  00060	8b 45 f8	 mov	 eax, DWORD PTR _bootEncStatus$28743[ebp]
  00063	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SetupInProgress
  00069	89 48 3e	 mov	 DWORD PTR [eax+62], ecx

; 1556 : 		bootEncStatus->SetupMode = SetupRequest.SetupMode;

  0006c	8b 55 f8	 mov	 edx, DWORD PTR _bootEncStatus$28743[ebp]
  0006f	a1 00 00 00 00	 mov	 eax, DWORD PTR _SetupRequest
  00074	89 42 42	 mov	 DWORD PTR [edx+66], eax

; 1557 : 		bootEncStatus->TransformWaitingForIdle = TransformWaitingForIdle;

  00077	8b 4d f8	 mov	 ecx, DWORD PTR _bootEncStatus$28743[ebp]
  0007a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _TransformWaitingForIdle
  00080	89 51 46	 mov	 DWORD PTR [ecx+70], edx

; 1558 : 
; 1559 : 		if (!BootDriveFound || !Extension || !Extension->DriveMounted)

  00083	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _BootDriveFound, 0
  0008a	74 12		 je	 SHORT $LN5@GetBootEnc
  0008c	83 7d fc 00	 cmp	 DWORD PTR _Extension$28742[ebp], 0
  00090	74 0c		 je	 SHORT $LN5@GetBootEnc
  00092	8b 45 fc	 mov	 eax, DWORD PTR _Extension$28742[ebp]
  00095	83 b8 30 02 00
	00 00		 cmp	 DWORD PTR [eax+560], 0
  0009c	75 23		 jne	 SHORT $LN6@GetBootEnc
$LN5@GetBootEnc:

; 1560 : 		{
; 1561 : 			bootEncStatus->DriveEncrypted = FALSE;

  0009e	8b 4d f8	 mov	 ecx, DWORD PTR _bootEncStatus$28743[ebp]
  000a1	c7 41 0e 00 00
	00 00		 mov	 DWORD PTR [ecx+14], 0

; 1562 : 			bootEncStatus->DriveMounted = FALSE;

  000a8	8b 55 f8	 mov	 edx, DWORD PTR _bootEncStatus$28743[ebp]
  000ab	c7 42 06 00 00
	00 00		 mov	 DWORD PTR [edx+6], 0

; 1563 : 			bootEncStatus->VolumeHeaderPresent = FALSE;

  000b2	8b 45 f8	 mov	 eax, DWORD PTR _bootEncStatus$28743[ebp]
  000b5	c7 40 0a 00 00
	00 00		 mov	 DWORD PTR [eax+10], 0

; 1564 : 		}
; 1565 : 		else

  000bc	e9 49 01 00 00	 jmp	 $LN4@GetBootEnc
$LN6@GetBootEnc:

; 1566 : 		{
; 1567 : 			bootEncStatus->DriveMounted = Extension->DriveMounted;

  000c1	8b 4d f8	 mov	 ecx, DWORD PTR _bootEncStatus$28743[ebp]
  000c4	8b 55 fc	 mov	 edx, DWORD PTR _Extension$28742[ebp]
  000c7	8b 82 30 02 00
	00		 mov	 eax, DWORD PTR [edx+560]
  000cd	89 41 06	 mov	 DWORD PTR [ecx+6], eax

; 1568 : 			bootEncStatus->VolumeHeaderPresent = Extension->VolumeHeaderPresent;

  000d0	8b 4d f8	 mov	 ecx, DWORD PTR _bootEncStatus$28743[ebp]
  000d3	8b 55 fc	 mov	 edx, DWORD PTR _Extension$28742[ebp]
  000d6	8b 82 2c 02 00
	00		 mov	 eax, DWORD PTR [edx+556]
  000dc	89 41 0a	 mov	 DWORD PTR [ecx+10], eax

; 1569 : 			bootEncStatus->DriveEncrypted = Extension->Queue.EncryptedAreaStart != -1;

  000df	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$28742[ebp]
  000e2	89 4d f0	 mov	 DWORD PTR tv182[ebp], ecx
  000e5	8b 55 f0	 mov	 edx, DWORD PTR tv182[ebp]
  000e8	8b 45 f0	 mov	 eax, DWORD PTR tv182[ebp]
  000eb	8b 8a 90 00 00
	00		 mov	 ecx, DWORD PTR [edx+144]
  000f1	23 88 94 00 00
	00		 and	 ecx, DWORD PTR [eax+148]
  000f7	83 f9 ff	 cmp	 ecx, -1
  000fa	74 09		 je	 SHORT $LN11@GetBootEnc
  000fc	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv94[ebp], 1
  00103	eb 07		 jmp	 SHORT $LN12@GetBootEnc
$LN11@GetBootEnc:
  00105	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv94[ebp], 0
$LN12@GetBootEnc:
  0010c	8b 55 f8	 mov	 edx, DWORD PTR _bootEncStatus$28743[ebp]
  0010f	8b 45 ec	 mov	 eax, DWORD PTR tv94[ebp]
  00112	89 42 0e	 mov	 DWORD PTR [edx+14], eax

; 1570 : 			bootEncStatus->BootDriveLength = BootDriveLength;

  00115	8b 4d f8	 mov	 ecx, DWORD PTR _bootEncStatus$28743[ebp]
  00118	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _BootDriveLength
  0011e	89 51 12	 mov	 DWORD PTR [ecx+18], edx
  00121	a1 04 00 00 00	 mov	 eax, DWORD PTR _BootDriveLength+4
  00126	89 41 16	 mov	 DWORD PTR [ecx+22], eax

; 1571 : 
; 1572 : 			bootEncStatus->ConfiguredEncryptedAreaStart = Extension->ConfiguredEncryptedAreaStart;

  00129	8b 4d f8	 mov	 ecx, DWORD PTR _bootEncStatus$28743[ebp]
  0012c	8b 55 fc	 mov	 edx, DWORD PTR _Extension$28742[ebp]
  0012f	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00132	89 41 1a	 mov	 DWORD PTR [ecx+26], eax
  00135	8b 52 34	 mov	 edx, DWORD PTR [edx+52]
  00138	89 51 1e	 mov	 DWORD PTR [ecx+30], edx

; 1573 : 			bootEncStatus->ConfiguredEncryptedAreaEnd = Extension->ConfiguredEncryptedAreaEnd;

  0013b	8b 45 f8	 mov	 eax, DWORD PTR _bootEncStatus$28743[ebp]
  0013e	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$28742[ebp]
  00141	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00144	89 50 22	 mov	 DWORD PTR [eax+34], edx
  00147	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  0014a	89 48 26	 mov	 DWORD PTR [eax+38], ecx

; 1574 : 			bootEncStatus->EncryptedAreaStart = Extension->Queue.EncryptedAreaStart;

  0014d	8b 55 f8	 mov	 edx, DWORD PTR _bootEncStatus$28743[ebp]
  00150	8b 45 fc	 mov	 eax, DWORD PTR _Extension$28742[ebp]
  00153	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00159	89 4a 2a	 mov	 DWORD PTR [edx+42], ecx
  0015c	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [eax+148]
  00162	89 42 2e	 mov	 DWORD PTR [edx+46], eax

; 1575 : 
; 1576 : 			if (SetupInProgress)

  00165	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SetupInProgress, 0
  0016c	74 32		 je	 SHORT $LN3@GetBootEnc

; 1577 : 			{
; 1578 : 				KIRQL irql;
; 1579 : 				KeAcquireSpinLock (&SetupStatusSpinLock, &irql);

  0016e	b9 00 00 00 00	 mov	 ecx, OFFSET _SetupStatusSpinLock
  00173	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4
  00179	88 45 f7	 mov	 BYTE PTR _irql$28750[ebp], al

; 1580 : 				bootEncStatus->EncryptedAreaEnd = SetupStatusEncryptedAreaEnd;

  0017c	8b 4d f8	 mov	 ecx, DWORD PTR _bootEncStatus$28743[ebp]
  0017f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SetupStatusEncryptedAreaEnd
  00185	89 51 32	 mov	 DWORD PTR [ecx+50], edx
  00188	a1 04 00 00 00	 mov	 eax, DWORD PTR _SetupStatusEncryptedAreaEnd+4
  0018d	89 41 36	 mov	 DWORD PTR [ecx+54], eax

; 1581 : 				KeReleaseSpinLock (&SetupStatusSpinLock, irql);

  00190	8a 55 f7	 mov	 dl, BYTE PTR _irql$28750[ebp]
  00193	b9 00 00 00 00	 mov	 ecx, OFFSET _SetupStatusSpinLock
  00198	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8

; 1582 : 			}
; 1583 : 			else

  0019e	eb 18		 jmp	 SHORT $LN2@GetBootEnc
$LN3@GetBootEnc:

; 1584 : 				bootEncStatus->EncryptedAreaEnd = Extension->Queue.EncryptedAreaEnd;

  001a0	8b 4d f8	 mov	 ecx, DWORD PTR _bootEncStatus$28743[ebp]
  001a3	8b 55 fc	 mov	 edx, DWORD PTR _Extension$28742[ebp]
  001a6	8b 82 98 00 00
	00		 mov	 eax, DWORD PTR [edx+152]
  001ac	89 41 32	 mov	 DWORD PTR [ecx+50], eax
  001af	8b 92 9c 00 00
	00		 mov	 edx, DWORD PTR [edx+156]
  001b5	89 51 36	 mov	 DWORD PTR [ecx+54], edx
$LN2@GetBootEnc:

; 1585 : 
; 1586 : 			bootEncStatus->VolumeHeaderSaltCrc32 = Extension->VolumeHeaderSaltCrc32;

  001b8	8b 45 f8	 mov	 eax, DWORD PTR _bootEncStatus$28743[ebp]
  001bb	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$28742[ebp]
  001be	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  001c1	89 50 3a	 mov	 DWORD PTR [eax+58], edx

; 1587 : 			bootEncStatus->HibernationPreventionCount = HibernationPreventionCount;

  001c4	8b 45 f8	 mov	 eax, DWORD PTR _bootEncStatus$28743[ebp]
  001c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _HibernationPreventionCount
  001cd	89 48 4a	 mov	 DWORD PTR [eax+74], ecx

; 1588 : 			bootEncStatus->HiddenSysLeakProtectionCount = HiddenSysLeakProtectionCount;

  001d0	8b 55 f8	 mov	 edx, DWORD PTR _bootEncStatus$28743[ebp]
  001d3	a1 00 00 00 00	 mov	 eax, DWORD PTR _HiddenSysLeakProtectionCount
  001d8	89 42 5a	 mov	 DWORD PTR [edx+90], eax

; 1589 : 
; 1590 : 			bootEncStatus->HiddenSystem = Extension->HiddenSystem;

  001db	8b 4d f8	 mov	 ecx, DWORD PTR _bootEncStatus$28743[ebp]
  001de	8b 55 fc	 mov	 edx, DWORD PTR _Extension$28742[ebp]
  001e1	8b 82 48 02 00
	00		 mov	 eax, DWORD PTR [edx+584]
  001e7	89 41 4e	 mov	 DWORD PTR [ecx+78], eax

; 1591 : 			
; 1592 : 			if (Extension->HiddenSystem)

  001ea	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$28742[ebp]
  001ed	83 b9 48 02 00
	00 00		 cmp	 DWORD PTR [ecx+584], 0
  001f4	74 14		 je	 SHORT $LN4@GetBootEnc

; 1593 : 				bootEncStatus->HiddenSystemPartitionStart = BootArgs.HiddenSystemPartitionStart;

  001f6	8b 55 f8	 mov	 edx, DWORD PTR _bootEncStatus$28743[ebp]
  001f9	a1 5a 00 00 00	 mov	 eax, DWORD PTR _BootArgs+90
  001fe	89 42 52	 mov	 DWORD PTR [edx+82], eax
  00201	8b 0d 5e 00 00
	00		 mov	 ecx, DWORD PTR _BootArgs+94
  00207	89 4a 56	 mov	 DWORD PTR [edx+86], ecx
$LN4@GetBootEnc:

; 1594 : 		}
; 1595 : 
; 1596 : 		irp->IoStatus.Information = sizeof (BootEncryptionStatus);

  0020a	8b 55 08	 mov	 edx, DWORD PTR _irp$[ebp]
  0020d	c7 42 1c 5e 00
	00 00		 mov	 DWORD PTR [edx+28], 94	; 0000005eH

; 1597 : 		irp->IoStatus.Status = STATUS_SUCCESS;

  00214	8b 45 08	 mov	 eax, DWORD PTR _irp$[ebp]
  00217	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
$LN9@GetBootEnc:

; 1598 : 	}
; 1599 : }

  0021e	8b e5		 mov	 esp, ebp
  00220	5d		 pop	 ebp
  00221	c2 08 00	 ret	 8
_GetBootEncryptionStatus@8 ENDP
_TEXT	ENDS
PUBLIC	_GetBootLoaderVersion@8
; Function compile flags: /Odtp
;	COMDAT _GetBootLoaderVersion@8
_TEXT	SEGMENT
_irp$ = 8						; size = 4
_irpSp$ = 12						; size = 4
_GetBootLoaderVersion@8 PROC				; COMDAT

; 1603 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1604 : 	if (ValidateIOBufferSize (irp, sizeof (uint16), ValidateOutput))

  00005	6a 01		 push	 1
  00007	6a 02		 push	 2
  00009	8b 45 08	 mov	 eax, DWORD PTR _irp$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00012	85 c0		 test	 eax, eax
  00014	74 42		 je	 SHORT $LN4@GetBootLoa

; 1605 : 	{
; 1606 : 		if (BootArgsValid)

  00016	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _BootArgsValid, 0
  0001d	74 25		 je	 SHORT $LN2@GetBootLoa

; 1607 : 		{
; 1608 : 			*(uint16 *) irp->AssociatedIrp.SystemBuffer = BootArgs.BootLoaderVersion;

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _irp$[ebp]
  00022	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00025	66 a1 08 00 00
	00		 mov	 ax, WORD PTR _BootArgs+8
  0002b	66 89 02	 mov	 WORD PTR [edx], ax

; 1609 : 			irp->IoStatus.Information = sizeof (uint16);

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _irp$[ebp]
  00031	c7 41 1c 02 00
	00 00		 mov	 DWORD PTR [ecx+28], 2

; 1610 : 			irp->IoStatus.Status = STATUS_SUCCESS;

  00038	8b 55 08	 mov	 edx, DWORD PTR _irp$[ebp]
  0003b	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 1611 : 		}
; 1612 : 		else

  00042	eb 14		 jmp	 SHORT $LN4@GetBootLoa
$LN2@GetBootLoa:

; 1613 : 		{
; 1614 : 			irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  00044	8b 45 08	 mov	 eax, DWORD PTR _irp$[ebp]
  00047	c7 40 18 0d 00
	00 c0		 mov	 DWORD PTR [eax+24], -1073741811 ; c000000dH

; 1615 : 			irp->IoStatus.Information = 0;

  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _irp$[ebp]
  00051	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0
$LN4@GetBootLoa:

; 1616 : 		}
; 1617 : 	}
; 1618 : }

  00058	5d		 pop	 ebp
  00059	c2 08 00	 ret	 8
_GetBootLoaderVersion@8 ENDP
_TEXT	ENDS
PUBLIC	_GetBootEncryptionAlgorithmName@8
EXTRN	_EAGetName@8:PROC
; Function compile flags: /Odtp
;	COMDAT _GetBootEncryptionAlgorithmName@8
_TEXT	SEGMENT
_request$28776 = -4					; size = 4
_irp$ = 8						; size = 4
_irpSp$ = 12						; size = 4
_GetBootEncryptionAlgorithmName@8 PROC			; COMDAT

; 1622 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 1623 : 	if (ValidateIOBufferSize (irp, sizeof (GetBootEncryptionAlgorithmNameRequest), ValidateOutput))

  00006	6a 01		 push	 1
  00008	68 00 01 00 00	 push	 256			; 00000100H
  0000d	8b 45 08	 mov	 eax, DWORD PTR _irp$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00016	85 c0		 test	 eax, eax
  00018	74 60		 je	 SHORT $LN4@GetBootEnc@2

; 1624 : 	{
; 1625 : 		if (BootDriveFilterExtension && BootDriveFilterExtension->DriveMounted)

  0001a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _BootDriveFilterExtension, 0
  00021	74 43		 je	 SHORT $LN2@GetBootEnc@2
  00023	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _BootDriveFilterExtension
  00029	83 b9 30 02 00
	00 00		 cmp	 DWORD PTR [ecx+560], 0
  00030	74 34		 je	 SHORT $LN2@GetBootEnc@2

; 1626 : 		{
; 1627 : 			GetBootEncryptionAlgorithmNameRequest *request = (GetBootEncryptionAlgorithmNameRequest *) irp->AssociatedIrp.SystemBuffer;

  00032	8b 55 08	 mov	 edx, DWORD PTR _irp$[ebp]
  00035	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00038	89 45 fc	 mov	 DWORD PTR _request$28776[ebp], eax

; 1628 : 			EAGetName (request->BootEncryptionAlgorithmName, BootDriveFilterExtension->Queue.CryptoInfo->ea);

  0003b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _BootDriveFilterExtension
  00041	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  00044	8b 02		 mov	 eax, DWORD PTR [edx]
  00046	50		 push	 eax
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _request$28776[ebp]
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 _EAGetName@8

; 1629 : 
; 1630 : 			irp->IoStatus.Information = sizeof (GetBootEncryptionAlgorithmNameRequest);

  00050	8b 55 08	 mov	 edx, DWORD PTR _irp$[ebp]
  00053	c7 42 1c 00 01
	00 00		 mov	 DWORD PTR [edx+28], 256	; 00000100H

; 1631 : 			irp->IoStatus.Status = STATUS_SUCCESS;

  0005a	8b 45 08	 mov	 eax, DWORD PTR _irp$[ebp]
  0005d	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 1632 : 		}
; 1633 : 		else

  00064	eb 14		 jmp	 SHORT $LN4@GetBootEnc@2
$LN2@GetBootEnc@2:

; 1634 : 		{
; 1635 : 			irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  00066	8b 4d 08	 mov	 ecx, DWORD PTR _irp$[ebp]
  00069	c7 41 18 0d 00
	00 c0		 mov	 DWORD PTR [ecx+24], -1073741811 ; c000000dH

; 1636 : 			irp->IoStatus.Information = 0;

  00070	8b 55 08	 mov	 edx, DWORD PTR _irp$[ebp]
  00073	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0
$LN4@GetBootEnc@2:

; 1637 : 		}
; 1638 : 	}
; 1639 : }

  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c2 08 00	 ret	 8
_GetBootEncryptionAlgorithmName@8 ENDP
_TEXT	ENDS
PUBLIC	_GetSetupResult@0
; Function compile flags: /Odtp
;	COMDAT _GetSetupResult@0
_TEXT	SEGMENT
_GetSetupResult@0 PROC					; COMDAT

; 1643 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1644 : 	return SetupResult;

  00005	a1 00 00 00 00	 mov	 eax, DWORD PTR _SetupResult

; 1645 : }

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
_GetSetupResult@0 ENDP
_TEXT	ENDS
PUBLIC	_IsBootDriveMounted@0
; Function compile flags: /Odtp
;	COMDAT _IsBootDriveMounted@0
_TEXT	SEGMENT
tv67 = -4						; size = 4
_IsBootDriveMounted@0 PROC				; COMDAT

; 1649 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 1650 : 	return BootDriveFilterExtension && BootDriveFilterExtension->DriveMounted;

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _BootDriveFilterExtension, 0
  0000d	74 17		 je	 SHORT $LN3@IsBootDriv
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  00014	83 b8 30 02 00
	00 00		 cmp	 DWORD PTR [eax+560], 0
  0001b	74 09		 je	 SHORT $LN3@IsBootDriv
  0001d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  00024	eb 07		 jmp	 SHORT $LN4@IsBootDriv
$LN3@IsBootDriv:
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$LN4@IsBootDriv:
  0002d	8b 45 fc	 mov	 eax, DWORD PTR tv67[ebp]

; 1651 : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
_IsBootDriveMounted@0 ENDP
_TEXT	ENDS
PUBLIC	_IsBootEncryptionSetupInProgress@0
; Function compile flags: /Odtp
;	COMDAT _IsBootEncryptionSetupInProgress@0
_TEXT	SEGMENT
_IsBootEncryptionSetupInProgress@0 PROC			; COMDAT

; 1655 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1656 : 	return SetupInProgress;

  00005	a1 00 00 00 00	 mov	 eax, DWORD PTR _SetupInProgress

; 1657 : }

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
_IsBootEncryptionSetupInProgress@0 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _IsHiddenSystemRunning@0
_TEXT	SEGMENT
tv67 = -4						; size = 4
_IsHiddenSystemRunning@0 PROC				; COMDAT

; 1661 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 1662 : 	return BootDriveFilterExtension && BootDriveFilterExtension->HiddenSystem;

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _BootDriveFilterExtension, 0
  0000d	74 17		 je	 SHORT $LN3@IsHiddenSy
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  00014	83 b8 48 02 00
	00 00		 cmp	 DWORD PTR [eax+584], 0
  0001b	74 09		 je	 SHORT $LN3@IsHiddenSy
  0001d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  00024	eb 07		 jmp	 SHORT $LN4@IsHiddenSy
$LN3@IsHiddenSy:
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$LN4@IsHiddenSy:
  0002d	8b 45 fc	 mov	 eax, DWORD PTR tv67[ebp]

; 1663 : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
_IsHiddenSystemRunning@0 ENDP
_TEXT	ENDS
PUBLIC	_GetBootDriveFilterExtension@0
; Function compile flags: /Odtp
;	COMDAT _GetBootDriveFilterExtension@0
_TEXT	SEGMENT
_GetBootDriveFilterExtension@0 PROC			; COMDAT

; 1667 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1668 : 	return BootDriveFilterExtension;

  00005	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension

; 1669 : }

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
_GetBootDriveFilterExtension@0 ENDP
_TEXT	ENDS
PUBLIC	_GetSystemDriveCryptoInfo@0
; Function compile flags: /Odtp
;	COMDAT _GetSystemDriveCryptoInfo@0
_TEXT	SEGMENT
_GetSystemDriveCryptoInfo@0 PROC			; COMDAT

; 1673 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1674 : 	return BootDriveFilterExtension->Queue.CryptoInfo;

  00005	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  0000a	8b 40 70	 mov	 eax, DWORD PTR [eax+112]

; 1675 : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
_GetSystemDriveCryptoInfo@0 ENDP
_TEXT	ENDS
EXTRN	_TCStopThread@8:PROC
; Function compile flags: /Odtp
;	COMDAT _AbortBootEncryptionSetup@0
_TEXT	SEGMENT
_AbortBootEncryptionSetup@0 PROC			; COMDAT

; 1679 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1680 : 	if (!IoIsSystemThread (PsGetCurrentThread()) && !UserCanAccessDriveDevice())

  00005	e8 00 00 00 00	 call	 _PsGetCurrentThread@0
  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoIsSystemThread@4
  00011	0f b6 c0	 movzx	 eax, al
  00014	85 c0		 test	 eax, eax
  00016	75 10		 jne	 SHORT $LN2@AbortBootE
  00018	e8 00 00 00 00	 call	 _UserCanAccessDriveDevice@0
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN2@AbortBootE

; 1681 : 		return STATUS_ACCESS_DENIED;

  00021	b8 22 00 00 c0	 mov	 eax, -1073741790	; c0000022H
  00026	eb 2d		 jmp	 SHORT $LN3@AbortBootE
$LN2@AbortBootE:

; 1682 : 
; 1683 : 	if (EncryptionSetupThread)

  00028	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _EncryptionSetupThread, 0
  0002f	74 22		 je	 SHORT $LN1@AbortBootE

; 1684 : 	{
; 1685 : 		EncryptionSetupThreadAbortRequested = TRUE;

  00031	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _EncryptionSetupThreadAbortRequested, 1

; 1686 : 
; 1687 : 		TCStopThread (EncryptionSetupThread, NULL);

  0003b	6a 00		 push	 0
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _EncryptionSetupThread
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 _TCStopThread@8

; 1688 : 		EncryptionSetupThread = NULL;

  00049	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _EncryptionSetupThread, 0
$LN1@AbortBootE:

; 1689 : 	}
; 1690 : 
; 1691 : 	return STATUS_SUCCESS;

  00053	33 c0		 xor	 eax, eax
$LN3@AbortBootE:

; 1692 : }

  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
_AbortBootEncryptionSetup@0 ENDP
_TEXT	ENDS
PUBLIC	_AbortDecoySystemWipe@0
PUBLIC	_StartDecoySystemWipe@12
_BSS	SEGMENT
_DecoySystemWipedAreaEnd DQ 01H DUP (?)
_DecoySystemWipeStatusSpinLock DD 01H DUP (?)
_DecoySystemWipeThreadAbortRequested DD 01H DUP (?)
_WipeDecoyRequest DB 0104H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
;	COMDAT _StartDecoySystemWipe@12
_TEXT	SEGMENT
_burnm$28885 = -16					; size = 4
_burnc$28887 = -12					; size = 4
_status$ = -8						; size = 4
_request$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_irp$ = 12						; size = 4
_irpSp$ = 16						; size = 4
_StartDecoySystemWipe@12 PROC				; COMDAT

; 1828 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 10	 sub	 esp, 16			; 00000010H
  00008	56		 push	 esi
  00009	57		 push	 edi

; 1829 : 	NTSTATUS status;
; 1830 : 	WipeDecoySystemRequest *request;
; 1831 : 
; 1832 : 	if (!UserCanAccessDriveDevice())

  0000a	e8 00 00 00 00	 call	 _UserCanAccessDriveDevice@0
  0000f	85 c0		 test	 eax, eax
  00011	75 0a		 jne	 SHORT $LN11@StartDecoy

; 1833 : 		return STATUS_ACCESS_DENIED;

  00013	b8 22 00 00 c0	 mov	 eax, -1073741790	; c0000022H
  00018	e9 f9 00 00 00	 jmp	 $LN12@StartDecoy
$LN11@StartDecoy:

; 1834 : 
; 1835 : 	if (!IsHiddenSystemRunning()
; 1836 : 		|| irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (WipeDecoySystemRequest))

  0001d	e8 00 00 00 00	 call	 _IsHiddenSystemRunning@0
  00022	85 c0		 test	 eax, eax
  00024	74 0c		 je	 SHORT $LN9@StartDecoy
  00026	8b 45 10	 mov	 eax, DWORD PTR _irpSp$[ebp]
  00029	81 78 08 04 01
	00 00		 cmp	 DWORD PTR [eax+8], 260	; 00000104H
  00030	73 0a		 jae	 SHORT $LN10@StartDecoy
$LN9@StartDecoy:

; 1837 : 		return STATUS_INVALID_PARAMETER;

  00032	b8 0d 00 00 c0	 mov	 eax, -1073741811	; c000000dH
  00037	e9 da 00 00 00	 jmp	 $LN12@StartDecoy
$LN10@StartDecoy:

; 1838 : 
; 1839 : 	if (DecoySystemWipeInProgress)

  0003c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _DecoySystemWipeInProgress, 0
  00043	74 07		 je	 SHORT $LN8@StartDecoy

; 1840 : 		return STATUS_SUCCESS;

  00045	33 c0		 xor	 eax, eax
  00047	e9 ca 00 00 00	 jmp	 $LN12@StartDecoy
$LN8@StartDecoy:

; 1841 : 
; 1842 : 	if (DecoySystemWipeThread)

  0004c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _DecoySystemWipeThread, 0
  00053	74 05		 je	 SHORT $LN7@StartDecoy

; 1843 : 		AbortDecoySystemWipe();

  00055	e8 00 00 00 00	 call	 _AbortDecoySystemWipe@0
$LN7@StartDecoy:

; 1844 : 
; 1845 : 	request = (WipeDecoySystemRequest *) irp->AssociatedIrp.SystemBuffer;

  0005a	8b 4d 0c	 mov	 ecx, DWORD PTR _irp$[ebp]
  0005d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00060	89 55 fc	 mov	 DWORD PTR _request$[ebp], edx

; 1846 : 	WipeDecoyRequest = *request;

  00063	8b 75 fc	 mov	 esi, DWORD PTR _request$[ebp]
  00066	b9 41 00 00 00	 mov	 ecx, 65			; 00000041H
  0006b	bf 00 00 00 00	 mov	 edi, OFFSET _WipeDecoyRequest
  00070	f3 a5		 rep movsd
$LN6@StartDecoy:

; 1847 : 
; 1848 : 	burn (request->WipeKey, sizeof (request->WipeKey));

  00072	8b 45 fc	 mov	 eax, DWORD PTR _request$[ebp]
  00075	83 c0 04	 add	 eax, 4
  00078	89 45 f0	 mov	 DWORD PTR _burnm$28885[ebp], eax
  0007b	c7 45 f4 00 01
	00 00		 mov	 DWORD PTR _burnc$28887[ebp], 256 ; 00000100H
  00082	68 00 01 00 00	 push	 256			; 00000100H
  00087	8b 4d fc	 mov	 ecx, DWORD PTR _request$[ebp]
  0008a	83 c1 04	 add	 ecx, 4
  0008d	51		 push	 ecx
  0008e	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN3@StartDecoy:
  00093	8b 55 f4	 mov	 edx, DWORD PTR _burnc$28887[ebp]
  00096	8b 45 f4	 mov	 eax, DWORD PTR _burnc$28887[ebp]
  00099	83 e8 01	 sub	 eax, 1
  0009c	89 45 f4	 mov	 DWORD PTR _burnc$28887[ebp], eax
  0009f	85 d2		 test	 edx, edx
  000a1	74 11		 je	 SHORT $LN5@StartDecoy
  000a3	8b 4d f0	 mov	 ecx, DWORD PTR _burnm$28885[ebp]
  000a6	c6 01 00	 mov	 BYTE PTR [ecx], 0
  000a9	8b 55 f0	 mov	 edx, DWORD PTR _burnm$28885[ebp]
  000ac	83 c2 01	 add	 edx, 1
  000af	89 55 f0	 mov	 DWORD PTR _burnm$28885[ebp], edx
  000b2	eb df		 jmp	 SHORT $LN3@StartDecoy
$LN5@StartDecoy:
  000b4	33 c0		 xor	 eax, eax
  000b6	75 ba		 jne	 SHORT $LN6@StartDecoy

; 1849 : 
; 1850 : 	DecoySystemWipeThreadAbortRequested = FALSE;

  000b8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _DecoySystemWipeThreadAbortRequested, 0

; 1851 : 	KeInitializeSpinLock (&DecoySystemWipeStatusSpinLock);

  000c2	68 00 00 00 00	 push	 OFFSET _DecoySystemWipeStatusSpinLock
  000c7	e8 00 00 00 00	 call	 _KeInitializeSpinLock@4

; 1852 : 	DecoySystemWipedAreaEnd = BootDriveFilterExtension->ConfiguredEncryptedAreaStart;

  000cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _BootDriveFilterExtension
  000d2	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000d5	89 15 00 00 00
	00		 mov	 DWORD PTR _DecoySystemWipedAreaEnd, edx
  000db	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  000de	a3 04 00 00 00	 mov	 DWORD PTR _DecoySystemWipedAreaEnd+4, eax

; 1853 : 
; 1854 : 	DecoySystemWipeInProgress = TRUE;

  000e3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _DecoySystemWipeInProgress, 1

; 1855 : 	status = TCStartThread (DecoySystemWipeThreadProc, DeviceObject, &DecoySystemWipeThread);

  000ed	68 00 00 00 00	 push	 OFFSET _DecoySystemWipeThread
  000f2	8b 4d 08	 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  000f5	51		 push	 ecx
  000f6	68 00 00 00 00	 push	 OFFSET _DecoySystemWipeThreadProc@4
  000fb	e8 00 00 00 00	 call	 _TCStartThread@12
  00100	89 45 f8	 mov	 DWORD PTR _status$[ebp], eax

; 1856 : 	
; 1857 : 	if (!NT_SUCCESS (status))

  00103	83 7d f8 00	 cmp	 DWORD PTR _status$[ebp], 0
  00107	7d 0a		 jge	 SHORT $LN1@StartDecoy

; 1858 : 		DecoySystemWipeInProgress = FALSE;

  00109	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _DecoySystemWipeInProgress, 0
$LN1@StartDecoy:

; 1859 : 
; 1860 : 	return status;

  00113	8b 45 f8	 mov	 eax, DWORD PTR _status$[ebp]
$LN12@StartDecoy:

; 1861 : }

  00116	5f		 pop	 edi
  00117	5e		 pop	 esi
  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c2 0c 00	 ret	 12			; 0000000cH
_StartDecoySystemWipe@12 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@OHMKNOCN@Wipe?5end?3?5DecoySystemWipedAreaEn@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CM@PJEGGJLG@Wiping?5decoy?5system?3?5?5start?5offs@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	_EAInitMode@4:PROC
EXTRN	_EAGetKeySize@4:PROC
EXTRN	_EAInit@12:PROC
_BSS	SEGMENT
_DecoySystemWipeResult DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0DB@OHMKNOCN@Wipe?5end?3?5DecoySystemWipedAreaEn@FNODOBFM@
text$s	SEGMENT
??_C@_0DB@OHMKNOCN@Wipe?5end?3?5DecoySystemWipedAreaEn@FNODOBFM@ DB 'Wipe'
	DB	' end: DecoySystemWipedAreaEnd=%I64d (%I64d)', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CM@PJEGGJLG@Wiping?5decoy?5system?3?5?5start?5offs@FNODOBFM@
text$s	SEGMENT
??_C@_0CM@PJEGGJLG@Wiping?5decoy?5system?3?5?5start?5offs@FNODOBFM@ DB 'W'
	DB	'iping decoy system:  start offset = %I64d', 0aH, 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _DecoySystemWipeThreadProc@4
_TEXT	SEGMENT
tv305 = -84						; size = 4
tv287 = -80						; size = 8
tv284 = -72						; size = 8
_burnm$28832 = -64					; size = 4
_burnc$28834 = -60					; size = 4
_wipeRandBuffer$ = -56					; size = 4
_wipeBlockSize$ = -52					; size = 4
_wipeCryptoInfo$ = -48					; size = 4
_status$ = -44						; size = 4
_wipeRandChars$ = -40					; size = 3
_ea$ = -36						; size = 4
_offset$ = -32						; size = 8
_Extension$ = -24					; size = 4
_wipeBuffer$ = -20					; size = 4
_dataUnit$ = -16					; size = 8
_wipePass$ = -8						; size = 4
_irql$ = -1						; size = 1
_threadArg$ = 8						; size = 4
_DecoySystemWipeThreadProc@4 PROC			; COMDAT

; 1696 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 54	 sub	 esp, 84			; 00000054H
  00008	56		 push	 esi

; 1697 : 	DriveFilterExtension *Extension = BootDriveFilterExtension;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  0000e	89 45 e8	 mov	 DWORD PTR _Extension$[ebp], eax

; 1698 : 
; 1699 : 	LARGE_INTEGER offset;
; 1700 : 	UINT64_STRUCT dataUnit;
; 1701 : 	ULONG wipeBlockSize = TC_ENCRYPTION_SETUP_IO_BLOCK_SIZE;

  00011	c7 45 cc 00 00
	18 00		 mov	 DWORD PTR _wipeBlockSize$[ebp], 1572864 ; 00180000H

; 1702 : 
; 1703 : 	CRYPTO_INFO *wipeCryptoInfo = NULL;

  00018	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _wipeCryptoInfo$[ebp], 0

; 1704 : 	byte *wipeBuffer = NULL;

  0001f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _wipeBuffer$[ebp], 0

; 1705 : 	byte *wipeRandBuffer = NULL;

  00026	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _wipeRandBuffer$[ebp], 0

; 1706 : 	byte wipeRandChars[TC_WIPE_RAND_CHAR_COUNT];
; 1707 : 	int wipePass;
; 1708 : 	int ea = Extension->Queue.CryptoInfo->ea;

  0002d	8b 4d e8	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00030	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  00033	8b 02		 mov	 eax, DWORD PTR [edx]
  00035	89 45 dc	 mov	 DWORD PTR _ea$[ebp], eax

; 1709 : 
; 1710 : 	KIRQL irql;
; 1711 : 	NTSTATUS status;
; 1712 : 
; 1713 : 	DecoySystemWipeResult = STATUS_UNSUCCESSFUL;

  00038	c7 05 00 00 00
	00 01 00 00 c0	 mov	 DWORD PTR _DecoySystemWipeResult, -1073741823 ; c0000001H

; 1714 : 
; 1715 : 	wipeBuffer = TCalloc (TC_ENCRYPTION_SETUP_IO_BLOCK_SIZE);

  00042	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00047	68 00 00 18 00	 push	 1572864			; 00180000H
  0004c	6a 00		 push	 0
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00054	89 45 ec	 mov	 DWORD PTR _wipeBuffer$[ebp], eax

; 1716 : 	if (!wipeBuffer)

  00057	83 7d ec 00	 cmp	 DWORD PTR _wipeBuffer$[ebp], 0
  0005b	75 0f		 jne	 SHORT $LN26@DecoySyste

; 1717 : 	{
; 1718 : 		DecoySystemWipeResult = STATUS_INSUFFICIENT_RESOURCES;

  0005d	c7 05 00 00 00
	00 9a 00 00 c0	 mov	 DWORD PTR _DecoySystemWipeResult, -1073741670 ; c000009aH

; 1719 : 		goto ret;

  00067	e9 89 03 00 00	 jmp	 $ret$28818
$LN26@DecoySyste:

; 1720 : 	}
; 1721 : 	
; 1722 : 	wipeRandBuffer = TCalloc (TC_ENCRYPTION_SETUP_IO_BLOCK_SIZE);

  0006c	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00071	68 00 00 18 00	 push	 1572864			; 00180000H
  00076	6a 00		 push	 0
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0007e	89 45 c8	 mov	 DWORD PTR _wipeRandBuffer$[ebp], eax

; 1723 : 	if (!wipeRandBuffer)

  00081	83 7d c8 00	 cmp	 DWORD PTR _wipeRandBuffer$[ebp], 0
  00085	75 0f		 jne	 SHORT $LN25@DecoySyste

; 1724 : 	{
; 1725 : 		DecoySystemWipeResult = STATUS_INSUFFICIENT_RESOURCES;

  00087	c7 05 00 00 00
	00 9a 00 00 c0	 mov	 DWORD PTR _DecoySystemWipeResult, -1073741670 ; c000009aH

; 1726 : 		goto ret;

  00091	e9 5f 03 00 00	 jmp	 $ret$28818
$LN25@DecoySyste:

; 1727 : 	}
; 1728 : 
; 1729 : 	wipeCryptoInfo = crypto_open();

  00096	e8 00 00 00 00	 call	 _crypto_open@0
  0009b	89 45 d0	 mov	 DWORD PTR _wipeCryptoInfo$[ebp], eax

; 1730 : 	if (!wipeCryptoInfo)

  0009e	83 7d d0 00	 cmp	 DWORD PTR _wipeCryptoInfo$[ebp], 0
  000a2	75 0f		 jne	 SHORT $LN24@DecoySyste

; 1731 : 	{
; 1732 : 		DecoySystemWipeResult = STATUS_INSUFFICIENT_RESOURCES;

  000a4	c7 05 00 00 00
	00 9a 00 00 c0	 mov	 DWORD PTR _DecoySystemWipeResult, -1073741670 ; c000009aH

; 1733 : 		goto ret;

  000ae	e9 42 03 00 00	 jmp	 $ret$28818
$LN24@DecoySyste:

; 1734 : 	}
; 1735 : 
; 1736 : 	wipeCryptoInfo->ea = ea;

  000b3	8b 4d d0	 mov	 ecx, DWORD PTR _wipeCryptoInfo$[ebp]
  000b6	8b 55 dc	 mov	 edx, DWORD PTR _ea$[ebp]
  000b9	89 11		 mov	 DWORD PTR [ecx], edx

; 1737 : 	wipeCryptoInfo->mode = Extension->Queue.CryptoInfo->mode;

  000bb	8b 45 e8	 mov	 eax, DWORD PTR _Extension$[ebp]
  000be	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  000c1	8b 55 d0	 mov	 edx, DWORD PTR _wipeCryptoInfo$[ebp]
  000c4	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000c7	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1738 : 
; 1739 : 	if (EAInit (ea, WipeDecoyRequest.WipeKey, wipeCryptoInfo->ks) != ERR_SUCCESS)

  000ca	8b 4d d0	 mov	 ecx, DWORD PTR _wipeCryptoInfo$[ebp]
  000cd	83 c1 08	 add	 ecx, 8
  000d0	51		 push	 ecx
  000d1	68 04 00 00 00	 push	 OFFSET _WipeDecoyRequest+4
  000d6	8b 55 dc	 mov	 edx, DWORD PTR _ea$[ebp]
  000d9	52		 push	 edx
  000da	e8 00 00 00 00	 call	 _EAInit@12
  000df	85 c0		 test	 eax, eax
  000e1	74 0f		 je	 SHORT $LN23@DecoySyste

; 1740 : 	{
; 1741 : 		DecoySystemWipeResult = STATUS_INVALID_PARAMETER;

  000e3	c7 05 00 00 00
	00 0d 00 00 c0	 mov	 DWORD PTR _DecoySystemWipeResult, -1073741811 ; c000000dH

; 1742 : 		goto ret;

  000ed	e9 03 03 00 00	 jmp	 $ret$28818
$LN23@DecoySyste:

; 1743 : 	}
; 1744 : 
; 1745 : 	memcpy (wipeCryptoInfo->k2, WipeDecoyRequest.WipeKey + EAGetKeySize (ea), EAGetKeySize (ea));

  000f2	8b 45 dc	 mov	 eax, DWORD PTR _ea$[ebp]
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 _EAGetKeySize@4
  000fb	50		 push	 eax
  000fc	8b 4d dc	 mov	 ecx, DWORD PTR _ea$[ebp]
  000ff	51		 push	 ecx
  00100	e8 00 00 00 00	 call	 _EAGetKeySize@4
  00105	05 04 00 00 00	 add	 eax, OFFSET _WipeDecoyRequest+4
  0010a	50		 push	 eax
  0010b	8b 55 d0	 mov	 edx, DWORD PTR _wipeCryptoInfo$[ebp]
  0010e	81 c2 a8 42 00
	00		 add	 edx, 17064		; 000042a8H
  00114	52		 push	 edx
  00115	e8 00 00 00 00	 call	 _memcpy
  0011a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1746 : 	
; 1747 : 	if (!EAInitMode (wipeCryptoInfo))

  0011d	8b 45 d0	 mov	 eax, DWORD PTR _wipeCryptoInfo$[ebp]
  00120	50		 push	 eax
  00121	e8 00 00 00 00	 call	 _EAInitMode@4
  00126	85 c0		 test	 eax, eax
  00128	75 0f		 jne	 SHORT $LN22@DecoySyste

; 1748 : 	{
; 1749 : 		DecoySystemWipeResult = STATUS_INVALID_PARAMETER;

  0012a	c7 05 00 00 00
	00 0d 00 00 c0	 mov	 DWORD PTR _DecoySystemWipeResult, -1073741811 ; c000000dH

; 1750 : 		goto err;

  00134	e9 5c 02 00 00	 jmp	 $err$28828
$LN22@DecoySyste:

; 1751 : 	}
; 1752 : 
; 1753 : 	EncryptDataUnits (wipeRandBuffer, &dataUnit, wipeBlockSize / ENCRYPTION_DATA_UNIT_SIZE, wipeCryptoInfo);

  00139	8b 4d d0	 mov	 ecx, DWORD PTR _wipeCryptoInfo$[ebp]
  0013c	51		 push	 ecx
  0013d	8b 55 cc	 mov	 edx, DWORD PTR _wipeBlockSize$[ebp]
  00140	c1 ea 09	 shr	 edx, 9
  00143	52		 push	 edx
  00144	8d 45 f0	 lea	 eax, DWORD PTR _dataUnit$[ebp]
  00147	50		 push	 eax
  00148	8b 4d c8	 mov	 ecx, DWORD PTR _wipeRandBuffer$[ebp]
  0014b	51		 push	 ecx
  0014c	e8 00 00 00 00	 call	 _EncryptDataUnits@16

; 1754 : 	memcpy (wipeRandChars, wipeRandBuffer, sizeof (wipeRandChars));

  00151	8b 55 c8	 mov	 edx, DWORD PTR _wipeRandBuffer$[ebp]
  00154	66 8b 02	 mov	 ax, WORD PTR [edx]
  00157	66 89 45 d8	 mov	 WORD PTR _wipeRandChars$[ebp], ax
  0015b	8a 4a 02	 mov	 cl, BYTE PTR [edx+2]
  0015e	88 4d da	 mov	 BYTE PTR _wipeRandChars$[ebp+2], cl
$LN21@DecoySyste:

; 1755 : 
; 1756 : 	burn (WipeDecoyRequest.WipeKey, sizeof (WipeDecoyRequest.WipeKey));

  00161	c7 45 c0 04 00
	00 00		 mov	 DWORD PTR _burnm$28832[ebp], OFFSET _WipeDecoyRequest+4
  00168	c7 45 c4 00 01
	00 00		 mov	 DWORD PTR _burnc$28834[ebp], 256 ; 00000100H
  0016f	68 00 01 00 00	 push	 256			; 00000100H
  00174	68 04 00 00 00	 push	 OFFSET _WipeDecoyRequest+4
  00179	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN18@DecoySyste:
  0017e	8b 55 c4	 mov	 edx, DWORD PTR _burnc$28834[ebp]
  00181	8b 45 c4	 mov	 eax, DWORD PTR _burnc$28834[ebp]
  00184	83 e8 01	 sub	 eax, 1
  00187	89 45 c4	 mov	 DWORD PTR _burnc$28834[ebp], eax
  0018a	85 d2		 test	 edx, edx
  0018c	74 11		 je	 SHORT $LN20@DecoySyste
  0018e	8b 4d c0	 mov	 ecx, DWORD PTR _burnm$28832[ebp]
  00191	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00194	8b 55 c0	 mov	 edx, DWORD PTR _burnm$28832[ebp]
  00197	83 c2 01	 add	 edx, 1
  0019a	89 55 c0	 mov	 DWORD PTR _burnm$28832[ebp], edx
  0019d	eb df		 jmp	 SHORT $LN18@DecoySyste
$LN20@DecoySyste:
  0019f	33 c0		 xor	 eax, eax
  001a1	75 be		 jne	 SHORT $LN21@DecoySyste

; 1757 : 
; 1758 : 	offset.QuadPart = Extension->ConfiguredEncryptedAreaStart;

  001a3	8b 4d e8	 mov	 ecx, DWORD PTR _Extension$[ebp]
  001a6	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  001a9	89 55 e0	 mov	 DWORD PTR _offset$[ebp], edx
  001ac	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  001af	89 45 e4	 mov	 DWORD PTR _offset$[ebp+4], eax

; 1759 : 		
; 1760 : 	Dump ("Wiping decoy system:  start offset = %I64d\n", offset.QuadPart);

  001b2	8b 4d e4	 mov	 ecx, DWORD PTR _offset$[ebp+4]
  001b5	51		 push	 ecx
  001b6	8b 55 e0	 mov	 edx, DWORD PTR _offset$[ebp]
  001b9	52		 push	 edx
  001ba	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@PJEGGJLG@Wiping?5decoy?5system?3?5?5start?5offs@FNODOBFM@
  001bf	e8 00 00 00 00	 call	 _DbgPrint
  001c4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@DecoySyste:

; 1761 : 
; 1762 : 	while (!DecoySystemWipeThreadAbortRequested)

  001c7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _DecoySystemWipeThreadAbortRequested, 0
  001ce	0f 85 b7 01 00
	00		 jne	 $abort$28854

; 1763 : 	{
; 1764 : 		if (offset.QuadPart + wipeBlockSize > Extension->ConfiguredEncryptedAreaEnd + 1)

  001d4	8b 45 cc	 mov	 eax, DWORD PTR _wipeBlockSize$[ebp]
  001d7	33 c9		 xor	 ecx, ecx
  001d9	03 45 e0	 add	 eax, DWORD PTR _offset$[ebp]
  001dc	8b 55 e4	 mov	 edx, DWORD PTR _offset$[ebp+4]
  001df	13 d1		 adc	 edx, ecx
  001e1	8b 4d e8	 mov	 ecx, DWORD PTR _Extension$[ebp]
  001e4	8b 71 38	 mov	 esi, DWORD PTR [ecx+56]
  001e7	83 c6 01	 add	 esi, 1
  001ea	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  001ed	83 d1 00	 adc	 ecx, 0
  001f0	89 45 b8	 mov	 DWORD PTR tv284[ebp], eax
  001f3	89 55 bc	 mov	 DWORD PTR tv284[ebp+4], edx
  001f6	89 75 b0	 mov	 DWORD PTR tv287[ebp], esi
  001f9	89 4d b4	 mov	 DWORD PTR tv287[ebp+4], ecx
  001fc	8b 55 bc	 mov	 edx, DWORD PTR tv284[ebp+4]
  001ff	3b 55 b4	 cmp	 edx, DWORD PTR tv287[ebp+4]
  00202	7c 22		 jl	 SHORT $LN14@DecoySyste
  00204	7f 08		 jg	 SHORT $LN29@DecoySyste
  00206	8b 45 b8	 mov	 eax, DWORD PTR tv284[ebp]
  00209	3b 45 b0	 cmp	 eax, DWORD PTR tv287[ebp]
  0020c	76 18		 jbe	 SHORT $LN14@DecoySyste
$LN29@DecoySyste:

; 1765 : 			wipeBlockSize = (ULONG) (Extension->ConfiguredEncryptedAreaEnd + 1 - offset.QuadPart);

  0020e	8b 4d e8	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00211	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00214	83 c2 01	 add	 edx, 1
  00217	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]
  0021a	83 d0 00	 adc	 eax, 0
  0021d	2b 55 e0	 sub	 edx, DWORD PTR _offset$[ebp]
  00220	1b 45 e4	 sbb	 eax, DWORD PTR _offset$[ebp+4]
  00223	89 55 cc	 mov	 DWORD PTR _wipeBlockSize$[ebp], edx
$LN14@DecoySyste:

; 1766 : 
; 1767 : 		if (offset.QuadPart > Extension->ConfiguredEncryptedAreaEnd)

  00226	8b 4d e8	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00229	89 4d ac	 mov	 DWORD PTR tv305[ebp], ecx
  0022c	8b 55 ac	 mov	 edx, DWORD PTR tv305[ebp]
  0022f	8b 45 e4	 mov	 eax, DWORD PTR _offset$[ebp+4]
  00232	3b 42 3c	 cmp	 eax, DWORD PTR [edx+60]
  00235	7c 12		 jl	 SHORT $LN13@DecoySyste
  00237	7f 0b		 jg	 SHORT $LN30@DecoySyste
  00239	8b 4d ac	 mov	 ecx, DWORD PTR tv305[ebp]
  0023c	8b 55 e0	 mov	 edx, DWORD PTR _offset$[ebp]
  0023f	3b 51 38	 cmp	 edx, DWORD PTR [ecx+56]
  00242	76 05		 jbe	 SHORT $LN13@DecoySyste
$LN30@DecoySyste:

; 1768 : 			break;

  00244	e9 42 01 00 00	 jmp	 $abort$28854
$LN13@DecoySyste:

; 1769 : 
; 1770 : 		for (wipePass = 1; wipePass <= GetWipePassCount (WipeDecoyRequest.WipeAlgorithm); ++wipePass)

  00249	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _wipePass$[ebp], 1
  00250	eb 09		 jmp	 SHORT $LN12@DecoySyste
$LN11@DecoySyste:
  00252	8b 45 f8	 mov	 eax, DWORD PTR _wipePass$[ebp]
  00255	83 c0 01	 add	 eax, 1
  00258	89 45 f8	 mov	 DWORD PTR _wipePass$[ebp], eax
$LN12@DecoySyste:
  0025b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WipeDecoyRequest
  00261	51		 push	 ecx
  00262	e8 00 00 00 00	 call	 _GetWipePassCount@4
  00267	39 45 f8	 cmp	 DWORD PTR _wipePass$[ebp], eax
  0026a	0f 8f cf 00 00
	00		 jg	 $LN10@DecoySyste

; 1771 : 		{
; 1772 : 			if (!WipeBuffer (WipeDecoyRequest.WipeAlgorithm, wipeRandChars, wipePass, wipeBuffer, wipeBlockSize))

  00270	8b 55 cc	 mov	 edx, DWORD PTR _wipeBlockSize$[ebp]
  00273	52		 push	 edx
  00274	8b 45 ec	 mov	 eax, DWORD PTR _wipeBuffer$[ebp]
  00277	50		 push	 eax
  00278	8b 4d f8	 mov	 ecx, DWORD PTR _wipePass$[ebp]
  0027b	51		 push	 ecx
  0027c	8d 55 d8	 lea	 edx, DWORD PTR _wipeRandChars$[ebp]
  0027f	52		 push	 edx
  00280	a1 00 00 00 00	 mov	 eax, DWORD PTR _WipeDecoyRequest
  00285	50		 push	 eax
  00286	e8 00 00 00 00	 call	 _WipeBuffer@20
  0028b	85 c0		 test	 eax, eax
  0028d	75 46		 jne	 SHORT $LN8@DecoySyste

; 1773 : 			{
; 1774 : 				dataUnit.Value = offset.QuadPart / ENCRYPTION_DATA_UNIT_SIZE;

  0028f	6a 00		 push	 0
  00291	68 00 02 00 00	 push	 512			; 00000200H
  00296	8b 4d e4	 mov	 ecx, DWORD PTR _offset$[ebp+4]
  00299	51		 push	 ecx
  0029a	8b 55 e0	 mov	 edx, DWORD PTR _offset$[ebp]
  0029d	52		 push	 edx
  0029e	e8 00 00 00 00	 call	 __alldiv
  002a3	89 45 f0	 mov	 DWORD PTR _dataUnit$[ebp], eax
  002a6	89 55 f4	 mov	 DWORD PTR _dataUnit$[ebp+4], edx

; 1775 : 				EncryptDataUnits (wipeRandBuffer, &dataUnit, wipeBlockSize / ENCRYPTION_DATA_UNIT_SIZE, wipeCryptoInfo);

  002a9	8b 45 d0	 mov	 eax, DWORD PTR _wipeCryptoInfo$[ebp]
  002ac	50		 push	 eax
  002ad	8b 4d cc	 mov	 ecx, DWORD PTR _wipeBlockSize$[ebp]
  002b0	c1 e9 09	 shr	 ecx, 9
  002b3	51		 push	 ecx
  002b4	8d 55 f0	 lea	 edx, DWORD PTR _dataUnit$[ebp]
  002b7	52		 push	 edx
  002b8	8b 45 c8	 mov	 eax, DWORD PTR _wipeRandBuffer$[ebp]
  002bb	50		 push	 eax
  002bc	e8 00 00 00 00	 call	 _EncryptDataUnits@16

; 1776 : 				memcpy (wipeBuffer, wipeRandBuffer, wipeBlockSize);

  002c1	8b 4d cc	 mov	 ecx, DWORD PTR _wipeBlockSize$[ebp]
  002c4	51		 push	 ecx
  002c5	8b 55 c8	 mov	 edx, DWORD PTR _wipeRandBuffer$[ebp]
  002c8	52		 push	 edx
  002c9	8b 45 ec	 mov	 eax, DWORD PTR _wipeBuffer$[ebp]
  002cc	50		 push	 eax
  002cd	e8 00 00 00 00	 call	 _memcpy
  002d2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@DecoySyste:

; 1777 : 			}
; 1778 : 
; 1779 : 			while (!NT_SUCCESS (EncryptedIoQueueHoldWhenIdle (&Extension->Queue, 500)))

  002d5	6a 00		 push	 0
  002d7	68 f4 01 00 00	 push	 500			; 000001f4H
  002dc	8b 4d e8	 mov	 ecx, DWORD PTR _Extension$[ebp]
  002df	83 c1 48	 add	 ecx, 72			; 00000048H
  002e2	51		 push	 ecx
  002e3	e8 00 00 00 00	 call	 _EncryptedIoQueueHoldWhenIdle@12
  002e8	85 c0		 test	 eax, eax
  002ea	7d 10		 jge	 SHORT $LN7@DecoySyste

; 1780 : 			{
; 1781 : 				if (DecoySystemWipeThreadAbortRequested)

  002ec	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _DecoySystemWipeThreadAbortRequested, 0
  002f3	74 05		 je	 SHORT $LN6@DecoySyste

; 1782 : 					goto abort;

  002f5	e9 91 00 00 00	 jmp	 $abort$28854
$LN6@DecoySyste:

; 1783 : 			}

  002fa	eb d9		 jmp	 SHORT $LN8@DecoySyste
$LN7@DecoySyste:

; 1784 : 
; 1785 : 			status = TCWriteDevice (BootDriveFilterExtension->LowerDeviceObject, wipeBuffer, offset, wipeBlockSize);

  002fc	8b 55 cc	 mov	 edx, DWORD PTR _wipeBlockSize$[ebp]
  002ff	52		 push	 edx
  00300	8b 45 e4	 mov	 eax, DWORD PTR _offset$[ebp+4]
  00303	50		 push	 eax
  00304	8b 4d e0	 mov	 ecx, DWORD PTR _offset$[ebp]
  00307	51		 push	 ecx
  00308	8b 55 ec	 mov	 edx, DWORD PTR _wipeBuffer$[ebp]
  0030b	52		 push	 edx
  0030c	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  00311	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00314	51		 push	 ecx
  00315	e8 00 00 00 00	 call	 _TCWriteDevice@20
  0031a	89 45 d4	 mov	 DWORD PTR _status$[ebp], eax

; 1786 : 
; 1787 : 			if (!NT_SUCCESS (status))

  0031d	83 7d d4 00	 cmp	 DWORD PTR _status$[ebp], 0
  00321	7d 0b		 jge	 SHORT $LN5@DecoySyste

; 1788 : 			{
; 1789 : 				DecoySystemWipeResult = status;

  00323	8b 55 d4	 mov	 edx, DWORD PTR _status$[ebp]
  00326	89 15 00 00 00
	00		 mov	 DWORD PTR _DecoySystemWipeResult, edx

; 1790 : 				goto err;

  0032c	eb 67		 jmp	 SHORT $err$28828
$LN5@DecoySyste:

; 1791 : 			}
; 1792 : 
; 1793 : 			EncryptedIoQueueResumeFromHold (&Extension->Queue);

  0032e	8b 45 e8	 mov	 eax, DWORD PTR _Extension$[ebp]
  00331	83 c0 48	 add	 eax, 72			; 00000048H
  00334	50		 push	 eax
  00335	e8 00 00 00 00	 call	 _EncryptedIoQueueResumeFromHold@4

; 1794 : 		}

  0033a	e9 13 ff ff ff	 jmp	 $LN11@DecoySyste
$LN10@DecoySyste:

; 1795 : 
; 1796 : 		offset.QuadPart += wipeBlockSize;

  0033f	8b 4d cc	 mov	 ecx, DWORD PTR _wipeBlockSize$[ebp]
  00342	33 d2		 xor	 edx, edx
  00344	03 4d e0	 add	 ecx, DWORD PTR _offset$[ebp]
  00347	8b 45 e4	 mov	 eax, DWORD PTR _offset$[ebp+4]
  0034a	13 c2		 adc	 eax, edx
  0034c	89 4d e0	 mov	 DWORD PTR _offset$[ebp], ecx
  0034f	89 45 e4	 mov	 DWORD PTR _offset$[ebp+4], eax

; 1797 : 
; 1798 : 		KeAcquireSpinLock (&DecoySystemWipeStatusSpinLock, &irql);

  00352	b9 00 00 00 00	 mov	 ecx, OFFSET _DecoySystemWipeStatusSpinLock
  00357	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4
  0035d	88 45 ff	 mov	 BYTE PTR _irql$[ebp], al

; 1799 : 		DecoySystemWipedAreaEnd = offset.QuadPart - 1;

  00360	8b 4d e0	 mov	 ecx, DWORD PTR _offset$[ebp]
  00363	83 e9 01	 sub	 ecx, 1
  00366	8b 55 e4	 mov	 edx, DWORD PTR _offset$[ebp+4]
  00369	83 da 00	 sbb	 edx, 0
  0036c	89 0d 00 00 00
	00		 mov	 DWORD PTR _DecoySystemWipedAreaEnd, ecx
  00372	89 15 04 00 00
	00		 mov	 DWORD PTR _DecoySystemWipedAreaEnd+4, edx

; 1800 : 		KeReleaseSpinLock (&DecoySystemWipeStatusSpinLock, irql);

  00378	8a 55 ff	 mov	 dl, BYTE PTR _irql$[ebp]
  0037b	b9 00 00 00 00	 mov	 ecx, OFFSET _DecoySystemWipeStatusSpinLock
  00380	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8

; 1801 : 	}

  00386	e9 3c fe ff ff	 jmp	 $LN16@DecoySyste
$abort$28854:

; 1802 : 
; 1803 : abort:
; 1804 : 	DecoySystemWipeResult = STATUS_SUCCESS;

  0038b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _DecoySystemWipeResult, 0
$err$28828:

; 1805 : err:
; 1806 : 
; 1807 : 	if (EncryptedIoQueueIsSuspended (&Extension->Queue))

  00395	8b 45 e8	 mov	 eax, DWORD PTR _Extension$[ebp]
  00398	83 c0 48	 add	 eax, 72			; 00000048H
  0039b	50		 push	 eax
  0039c	e8 00 00 00 00	 call	 _EncryptedIoQueueIsSuspended@4
  003a1	85 c0		 test	 eax, eax
  003a3	74 0c		 je	 SHORT $LN4@DecoySyste

; 1808 : 		EncryptedIoQueueResumeFromHold (&Extension->Queue);

  003a5	8b 4d e8	 mov	 ecx, DWORD PTR _Extension$[ebp]
  003a8	83 c1 48	 add	 ecx, 72			; 00000048H
  003ab	51		 push	 ecx
  003ac	e8 00 00 00 00	 call	 _EncryptedIoQueueResumeFromHold@4
$LN4@DecoySyste:

; 1809 : 
; 1810 : 	Dump ("Wipe end: DecoySystemWipedAreaEnd=%I64d (%I64d)\n", DecoySystemWipedAreaEnd, DecoySystemWipedAreaEnd / 1024 / 1024);

  003b1	6a 00		 push	 0
  003b3	68 00 04 00 00	 push	 1024			; 00000400H
  003b8	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _DecoySystemWipedAreaEnd+4
  003be	52		 push	 edx
  003bf	a1 00 00 00 00	 mov	 eax, DWORD PTR _DecoySystemWipedAreaEnd
  003c4	50		 push	 eax
  003c5	e8 00 00 00 00	 call	 __alldiv
  003ca	6a 00		 push	 0
  003cc	68 00 04 00 00	 push	 1024			; 00000400H
  003d1	52		 push	 edx
  003d2	50		 push	 eax
  003d3	e8 00 00 00 00	 call	 __alldiv
  003d8	52		 push	 edx
  003d9	50		 push	 eax
  003da	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _DecoySystemWipedAreaEnd+4
  003e0	51		 push	 ecx
  003e1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _DecoySystemWipedAreaEnd
  003e7	52		 push	 edx
  003e8	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@OHMKNOCN@Wipe?5end?3?5DecoySystemWipedAreaEn@FNODOBFM@
  003ed	e8 00 00 00 00	 call	 _DbgPrint
  003f2	83 c4 14	 add	 esp, 20			; 00000014H
$ret$28818:

; 1811 : 
; 1812 : ret:
; 1813 : 	if (wipeCryptoInfo)

  003f5	83 7d d0 00	 cmp	 DWORD PTR _wipeCryptoInfo$[ebp], 0
  003f9	74 09		 je	 SHORT $LN3@DecoySyste

; 1814 : 		crypto_close (wipeCryptoInfo);

  003fb	8b 45 d0	 mov	 eax, DWORD PTR _wipeCryptoInfo$[ebp]
  003fe	50		 push	 eax
  003ff	e8 00 00 00 00	 call	 _crypto_close@4
$LN3@DecoySyste:

; 1815 : 
; 1816 : 	if (wipeRandBuffer)

  00404	83 7d c8 00	 cmp	 DWORD PTR _wipeRandBuffer$[ebp], 0
  00408	74 0f		 je	 SHORT $LN2@DecoySyste

; 1817 : 		TCfree (wipeRandBuffer);

  0040a	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0040f	8b 4d c8	 mov	 ecx, DWORD PTR _wipeRandBuffer$[ebp]
  00412	51		 push	 ecx
  00413	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN2@DecoySyste:

; 1818 : 
; 1819 : 	if (wipeBuffer)

  00419	83 7d ec 00	 cmp	 DWORD PTR _wipeBuffer$[ebp], 0
  0041d	74 0f		 je	 SHORT $LN1@DecoySyste

; 1820 : 		TCfree (wipeBuffer);

  0041f	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00424	8b 55 ec	 mov	 edx, DWORD PTR _wipeBuffer$[ebp]
  00427	52		 push	 edx
  00428	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN1@DecoySyste:

; 1821 : 
; 1822 : 	DecoySystemWipeInProgress = FALSE;

  0042e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _DecoySystemWipeInProgress, 0

; 1823 : 	PsTerminateSystemThread (DecoySystemWipeResult);

  00438	a1 00 00 00 00	 mov	 eax, DWORD PTR _DecoySystemWipeResult
  0043d	50		 push	 eax
  0043e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsTerminateSystemThread@4

; 1824 : }

  00444	5e		 pop	 esi
  00445	8b e5		 mov	 esp, ebp
  00447	5d		 pop	 ebp
  00448	c2 04 00	 ret	 4
_DecoySystemWipeThreadProc@4 ENDP
_TEXT	ENDS
PUBLIC	_IsDecoySystemWipeInProgress@0
; Function compile flags: /Odtp
;	COMDAT _IsDecoySystemWipeInProgress@0
_TEXT	SEGMENT
_IsDecoySystemWipeInProgress@0 PROC			; COMDAT

; 1865 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1866 : 	return DecoySystemWipeInProgress;

  00005	a1 00 00 00 00	 mov	 eax, DWORD PTR _DecoySystemWipeInProgress

; 1867 : }

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
_IsDecoySystemWipeInProgress@0 ENDP
_TEXT	ENDS
PUBLIC	_GetDecoySystemWipeStatus@8
; Function compile flags: /Odtp
;	COMDAT _GetDecoySystemWipeStatus@8
_TEXT	SEGMENT
_irql$28907 = -5					; size = 1
_wipeStatus$28901 = -4					; size = 4
_irp$ = 8						; size = 4
_irpSp$ = 12						; size = 4
_GetDecoySystemWipeStatus@8 PROC			; COMDAT

; 1871 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 1872 : 	if (ValidateIOBufferSize (irp, sizeof (DecoySystemWipeStatus), ValidateOutput))

  00008	6a 01		 push	 1
  0000a	6a 10		 push	 16			; 00000010H
  0000c	8b 45 08	 mov	 eax, DWORD PTR _irp$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 _ValidateIOBufferSize@12
  00015	85 c0		 test	 eax, eax
  00017	0f 84 a3 00 00
	00		 je	 $LN6@GetDecoySy

; 1873 : 	{
; 1874 : 		DecoySystemWipeStatus *wipeStatus = (DecoySystemWipeStatus *) irp->AssociatedIrp.SystemBuffer;

  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _irp$[ebp]
  00020	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00023	89 55 fc	 mov	 DWORD PTR _wipeStatus$28901[ebp], edx

; 1875 : 
; 1876 : 		if (!IsHiddenSystemRunning())

  00026	e8 00 00 00 00	 call	 _IsHiddenSystemRunning@0
  0002b	85 c0		 test	 eax, eax
  0002d	75 16		 jne	 SHORT $LN4@GetDecoySy

; 1877 : 		{
; 1878 : 			irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

  0002f	8b 45 08	 mov	 eax, DWORD PTR _irp$[ebp]
  00032	c7 40 18 0d 00
	00 c0		 mov	 DWORD PTR [eax+24], -1073741811 ; c000000dH

; 1879 : 			irp->IoStatus.Information = 0;

  00039	8b 4d 08	 mov	 ecx, DWORD PTR _irp$[ebp]
  0003c	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 1880 : 		}
; 1881 : 		else

  00043	eb 7b		 jmp	 SHORT $LN6@GetDecoySy
$LN4@GetDecoySy:

; 1882 : 		{
; 1883 : 			wipeStatus->WipeInProgress = DecoySystemWipeInProgress;

  00045	8b 55 fc	 mov	 edx, DWORD PTR _wipeStatus$28901[ebp]
  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR _DecoySystemWipeInProgress
  0004d	89 02		 mov	 DWORD PTR [edx], eax

; 1884 : 			wipeStatus->WipeAlgorithm = WipeDecoyRequest.WipeAlgorithm;

  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _wipeStatus$28901[ebp]
  00052	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WipeDecoyRequest
  00058	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 1885 : 
; 1886 : 			if (DecoySystemWipeInProgress)

  0005b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _DecoySystemWipeInProgress, 0
  00062	74 33		 je	 SHORT $LN2@GetDecoySy

; 1887 : 			{
; 1888 : 				KIRQL irql;
; 1889 : 				KeAcquireSpinLock (&DecoySystemWipeStatusSpinLock, &irql);

  00064	b9 00 00 00 00	 mov	 ecx, OFFSET _DecoySystemWipeStatusSpinLock
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4
  0006f	88 45 fb	 mov	 BYTE PTR _irql$28907[ebp], al

; 1890 : 				wipeStatus->WipedAreaEnd = DecoySystemWipedAreaEnd;

  00072	8b 45 fc	 mov	 eax, DWORD PTR _wipeStatus$28901[ebp]
  00075	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _DecoySystemWipedAreaEnd
  0007b	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0007e	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _DecoySystemWipedAreaEnd+4
  00084	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 1891 : 				KeReleaseSpinLock (&DecoySystemWipeStatusSpinLock, irql);

  00087	8a 55 fb	 mov	 dl, BYTE PTR _irql$28907[ebp]
  0008a	b9 00 00 00 00	 mov	 ecx, OFFSET _DecoySystemWipeStatusSpinLock
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8

; 1892 : 			}
; 1893 : 			else

  00095	eb 15		 jmp	 SHORT $LN1@GetDecoySy
$LN2@GetDecoySy:

; 1894 : 				wipeStatus->WipedAreaEnd = DecoySystemWipedAreaEnd;

  00097	8b 45 fc	 mov	 eax, DWORD PTR _wipeStatus$28901[ebp]
  0009a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _DecoySystemWipedAreaEnd
  000a0	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000a3	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _DecoySystemWipedAreaEnd+4
  000a9	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$LN1@GetDecoySy:

; 1895 : 			
; 1896 : 			irp->IoStatus.Information = sizeof (DecoySystemWipeStatus);

  000ac	8b 45 08	 mov	 eax, DWORD PTR _irp$[ebp]
  000af	c7 40 1c 10 00
	00 00		 mov	 DWORD PTR [eax+28], 16	; 00000010H

; 1897 : 			irp->IoStatus.Status = STATUS_SUCCESS;

  000b6	8b 4d 08	 mov	 ecx, DWORD PTR _irp$[ebp]
  000b9	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
$LN6@GetDecoySy:

; 1898 : 		}
; 1899 : 	}
; 1900 : }

  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c2 08 00	 ret	 8
_GetDecoySystemWipeStatus@8 ENDP
_TEXT	ENDS
PUBLIC	_GetDecoySystemWipeResult@0
; Function compile flags: /Odtp
;	COMDAT _GetDecoySystemWipeResult@0
_TEXT	SEGMENT
_GetDecoySystemWipeResult@0 PROC			; COMDAT

; 1904 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1905 : 	return DecoySystemWipeResult;

  00005	a1 00 00 00 00	 mov	 eax, DWORD PTR _DecoySystemWipeResult

; 1906 : }

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
_GetDecoySystemWipeResult@0 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _AbortDecoySystemWipe@0
_TEXT	SEGMENT
_AbortDecoySystemWipe@0 PROC				; COMDAT

; 1910 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1911 : 	if (!IoIsSystemThread (PsGetCurrentThread()) && !UserCanAccessDriveDevice())

  00005	e8 00 00 00 00	 call	 _PsGetCurrentThread@0
  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoIsSystemThread@4
  00011	0f b6 c0	 movzx	 eax, al
  00014	85 c0		 test	 eax, eax
  00016	75 10		 jne	 SHORT $LN2@AbortDecoy
  00018	e8 00 00 00 00	 call	 _UserCanAccessDriveDevice@0
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN2@AbortDecoy

; 1912 : 		return STATUS_ACCESS_DENIED;

  00021	b8 22 00 00 c0	 mov	 eax, -1073741790	; c0000022H
  00026	eb 2d		 jmp	 SHORT $LN3@AbortDecoy
$LN2@AbortDecoy:

; 1913 : 
; 1914 : 	if (DecoySystemWipeThread)

  00028	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _DecoySystemWipeThread, 0
  0002f	74 22		 je	 SHORT $LN1@AbortDecoy

; 1915 : 	{
; 1916 : 		DecoySystemWipeThreadAbortRequested = TRUE;

  00031	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _DecoySystemWipeThreadAbortRequested, 1

; 1917 : 
; 1918 : 		TCStopThread (DecoySystemWipeThread, NULL);

  0003b	6a 00		 push	 0
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _DecoySystemWipeThread
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 _TCStopThread@8

; 1919 : 		DecoySystemWipeThread = NULL;

  00049	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _DecoySystemWipeThread, 0
$LN1@AbortDecoy:

; 1920 : 	}
; 1921 : 
; 1922 : 	return STATUS_SUCCESS;

  00053	33 c0		 xor	 eax, eax
$LN3@AbortDecoy:

; 1923 : }

  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
_AbortDecoySystemWipe@0 ENDP
_TEXT	ENDS
PUBLIC	_GetBootDriveLength@0
; Function compile flags: /Odtp
;	COMDAT _GetBootDriveLength@0
_TEXT	SEGMENT
_GetBootDriveLength@0 PROC				; COMDAT

; 1927 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1928 : 	return BootDriveLength.QuadPart;

  00005	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveLength
  0000a	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _BootDriveLength+4

; 1929 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
_GetBootDriveLength@0 ENDP
_TEXT	ENDS
PUBLIC	_WriteBootDriveSector@8
; Function compile flags: /Odtp
;	COMDAT _WriteBootDriveSector@8
_TEXT	SEGMENT
_request$ = -4						; size = 4
_irp$ = 8						; size = 4
_irpSp$ = 12						; size = 4
_WriteBootDriveSector@8 PROC				; COMDAT

; 1933 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 1934 : 	WriteBootDriveSectorRequest *request;
; 1935 : 
; 1936 : 	if (!UserCanAccessDriveDevice())

  00006	e8 00 00 00 00	 call	 _UserCanAccessDriveDevice@0
  0000b	85 c0		 test	 eax, eax
  0000d	75 07		 jne	 SHORT $LN3@WriteBootD

; 1937 : 		return STATUS_ACCESS_DENIED;

  0000f	b8 22 00 00 c0	 mov	 eax, -1073741790	; c0000022H
  00014	eb 4a		 jmp	 SHORT $LN4@WriteBootD
$LN3@WriteBootD:

; 1938 : 
; 1939 : 	if (!BootDriveFilterExtension
; 1940 : 		|| irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (WriteBootDriveSectorRequest))

  00016	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _BootDriveFilterExtension, 0
  0001d	74 0c		 je	 SHORT $LN1@WriteBootD
  0001f	8b 45 0c	 mov	 eax, DWORD PTR _irpSp$[ebp]
  00022	81 78 08 08 02
	00 00		 cmp	 DWORD PTR [eax+8], 520	; 00000208H
  00029	73 07		 jae	 SHORT $LN2@WriteBootD
$LN1@WriteBootD:

; 1941 : 		return STATUS_INVALID_PARAMETER;

  0002b	b8 0d 00 00 c0	 mov	 eax, -1073741811	; c000000dH
  00030	eb 2e		 jmp	 SHORT $LN4@WriteBootD
$LN2@WriteBootD:

; 1942 : 
; 1943 : 	request = (WriteBootDriveSectorRequest *) irp->AssociatedIrp.SystemBuffer;

  00032	8b 4d 08	 mov	 ecx, DWORD PTR _irp$[ebp]
  00035	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00038	89 55 fc	 mov	 DWORD PTR _request$[ebp], edx

; 1944 : 	return TCWriteDevice (BootDriveFilterExtension->LowerDeviceObject, request->Data, request->Offset, sizeof (request->Data));

  0003b	68 00 02 00 00	 push	 512			; 00000200H
  00040	8b 45 fc	 mov	 eax, DWORD PTR _request$[ebp]
  00043	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00046	51		 push	 ecx
  00047	8b 10		 mov	 edx, DWORD PTR [eax]
  00049	52		 push	 edx
  0004a	8b 45 fc	 mov	 eax, DWORD PTR _request$[ebp]
  0004d	83 c0 08	 add	 eax, 8
  00050	50		 push	 eax
  00051	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _BootDriveFilterExtension
  00057	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0005a	52		 push	 edx
  0005b	e8 00 00 00 00	 call	 _TCWriteDevice@20
$LN4@WriteBootD:

; 1945 : }

  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 08 00	 ret	 8
_WriteBootDriveSector@8 ENDP
_TEXT	ENDS
END
