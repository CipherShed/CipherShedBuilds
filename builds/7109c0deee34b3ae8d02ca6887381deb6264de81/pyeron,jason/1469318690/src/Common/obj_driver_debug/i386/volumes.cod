; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\users\public\desktop\projects\ciphershed\src\common\volumes.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_ReadVolumeHeaderRecoveryMode
_BSS	SEGMENT
_ReadVolumeHeaderRecoveryMode DD 01H DUP (?)
_BSS	ENDS
PUBLIC	_GetHeaderField16@8
EXTRN	_MirrorBytes16@4:PROC
; Function compile flags: /Odtp
; File c:\users\public\desktop\projects\ciphershed\src\common\volumes.c
;	COMDAT _GetHeaderField16@8
_TEXT	SEGMENT
_header$ = 8						; size = 4
_offset$ = 12						; size = 4
_GetHeaderField16@8 PROC				; COMDAT

; 125  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 126  : 	return BE16 (*(uint16 *) (header + offset));

  00005	8b 45 08	 mov	 eax, DWORD PTR _header$[ebp]
  00008	03 45 0c	 add	 eax, DWORD PTR _offset$[ebp]
  0000b	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 _MirrorBytes16@4

; 127  : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
_GetHeaderField16@8 ENDP
_TEXT	ENDS
PUBLIC	_GetHeaderField32@8
EXTRN	_MirrorBytes32@4:PROC
; Function compile flags: /Odtp
;	COMDAT _GetHeaderField32@8
_TEXT	SEGMENT
_header$ = 8						; size = 4
_offset$ = 12						; size = 4
_GetHeaderField32@8 PROC				; COMDAT

; 131  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 132  : 	return BE32 (*(uint32 *) (header + offset));

  00005	8b 45 08	 mov	 eax, DWORD PTR _header$[ebp]
  00008	03 45 0c	 add	 eax, DWORD PTR _offset$[ebp]
  0000b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 _MirrorBytes32@4

; 133  : }

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
_GetHeaderField32@8 ENDP
_TEXT	ENDS
PUBLIC	_GetHeaderField64@8
EXTRN	_MirrorBytes64@8:PROC
; Function compile flags: /Odtp
;	COMDAT _GetHeaderField64@8
_TEXT	SEGMENT
_uint64Struct$ = -8					; size = 8
_header$ = 8						; size = 4
_offset$ = 12						; size = 4
_GetHeaderField64@8 PROC				; COMDAT

; 137  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8

; 138  : 	UINT64_STRUCT uint64Struct;
; 139  : 
; 140  : #ifndef TC_NO_COMPILER_INT64
; 141  : 	uint64Struct.Value = BE64 (*(uint64 *) (header + offset));

  00008	8b 45 08	 mov	 eax, DWORD PTR _header$[ebp]
  0000b	03 45 0c	 add	 eax, DWORD PTR _offset$[ebp]
  0000e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00011	51		 push	 ecx
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _MirrorBytes64@8
  0001a	89 45 f8	 mov	 DWORD PTR _uint64Struct$[ebp], eax
  0001d	89 55 fc	 mov	 DWORD PTR _uint64Struct$[ebp+4], edx

; 142  : #else
; 143  : 	uint64Struct.HighPart = BE32 (*(uint32 *) (header + offset));
; 144  : 	uint64Struct.LowPart = BE32 (*(uint32 *) (header + offset + 4));
; 145  : #endif
; 146  : 	return uint64Struct;

  00020	8b 45 f8	 mov	 eax, DWORD PTR _uint64Struct$[ebp]
  00023	8b 55 fc	 mov	 edx, DWORD PTR _uint64Struct$[ebp+4]

; 147  : }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
_GetHeaderField64@8 ENDP
_TEXT	ENDS
PUBLIC	_RtlSecureZeroMemory@8
PUBLIC	__$ArrayPad$
PUBLIC	_ReadVolumeHeader@20
EXTRN	__imp__ExFreePoolWithTag@8:PROC
EXTRN	_crypto_close@4:PROC
EXTRN	_GetCrc32@8:PROC
EXTRN	_DecryptBuffer@16:PROC
EXTRN	_EAInitMode@4:PROC
EXTRN	_EAGetKeySize@4:PROC
EXTRN	_EAInit@12:PROC
EXTRN	_CipherGetBlockSize@4:PROC
EXTRN	_EAGetFirstCipher@4:PROC
EXTRN	_EAIsModeSupported@8:PROC
EXTRN	_EAGetNext@4:PROC
EXTRN	_EAGetFirst@0:PROC
EXTRN	__imp__KeBugCheckEx@20:PROC
EXTRN	_derive_key_whirlpool@28:PROC
EXTRN	_derive_key_sha1@28:PROC
EXTRN	_derive_key_sha512@28:PROC
EXTRN	_derive_key_ripemd160@28:PROC
EXTRN	_GetMaxPkcs5OutSize@0:PROC
EXTRN	__imp__KeWaitForSingleObject@20:PROC
EXTRN	_EncryptionThreadPoolBeginKeyDerivation@40:PROC
EXTRN	_get_pkcs5_iteration_count@8:PROC
EXTRN	_crypto_loadkey@12:PROC
EXTRN	__imp__KeInitializeEvent@12:PROC
EXTRN	__imp__ExAllocatePoolWithTag@12:PROC
EXTRN	_crypto_open@0:PROC
EXTRN	_GetEncryptionThreadCount@0:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
;	COMDAT _ReadVolumeHeader@20
_TEXT	SEGMENT
tv459 = -1332						; size = 4
tv391 = -1328						; size = 4
tv706 = -1324						; size = 4
tv239 = -1320						; size = 4
tv191 = -1316						; size = 4
$T28246 = -1312						; size = 8
$T28245 = -1304						; size = 8
$T28244 = -1296						; size = 8
_burnm$28196 = -1284					; size = 4
_burnc$28198 = -1280					; size = 4
_burnm$28185 = -1276					; size = 4
_burnc$28187 = -1272					; size = 4
_burnm$28176 = -1268					; size = 4
_burnc$28178 = -1264					; size = 4
_blockSize$28134 = -1260				; size = 4
_lrw64InitDone$28091 = -1256				; size = 4
_lrw128InitDone$28092 = -1252				; size = 4
_header$ = -1248					; size = 512
_item$ = -736						; size = 4
_pkcs5_prf$ = -732					; size = 4
_pkcs5PrfCount$ = -728					; size = 4
_status$ = -724						; size = 4
_enqPkcs5Prf$ = -720					; size = 4
_queuedWorkItems$ = -716				; size = 4
_outstandingWorkItemCount$ = -712			; size = 4
_keyDerivationWorkItems$ = -708				; size = 4
_keyInfo$ = -704					; size = 392
_keyDerivationCompletedEvent$ = -312			; size = 16
_primaryKeyOffset$ = -296				; size = 4
_encryptionThreadCount$ = -292				; size = 4
_headerVersion$ = -288					; size = 2
_noOutstandingWorkItemEvent$ = -284			; size = 16
_i$ = -268						; size = 4
_dk$ = -264						; size = 256
__$ArrayPad$ = -8					; size = 4
_cryptoInfo$ = -4					; size = 4
_bBoot$ = 8						; size = 4
_encryptedHeader$ = 12					; size = 4
_password$ = 16						; size = 4
_retInfo$ = 20						; size = 4
_retHeaderCryptoInfo$ = 24				; size = 4
_ReadVolumeHeader@20 PROC				; COMDAT

; 164  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 34 05 00
	00		 sub	 esp, 1332		; 00000534H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi
  00016	57		 push	 edi

; 165  : 	char header[TC_VOLUME_HEADER_EFFECTIVE_SIZE];
; 166  : 	KEY_INFO keyInfo;
; 167  : 	PCRYPTO_INFO cryptoInfo;
; 168  : 	char dk[MASTER_KEYDATA_SIZE];
; 169  : 	int enqPkcs5Prf, pkcs5_prf;
; 170  : 	uint16 headerVersion;
; 171  : 	int status = ERR_PARAMETER_INCORRECT;

  00017	c7 85 2c fd ff
	ff 1e 00 00 00	 mov	 DWORD PTR _status$[ebp], 30 ; 0000001eH

; 172  : 	int primaryKeyOffset;
; 173  : 
; 174  : 	TC_EVENT keyDerivationCompletedEvent;
; 175  : 	TC_EVENT noOutstandingWorkItemEvent;
; 176  : 	KeyDerivationWorkItem *keyDerivationWorkItems;
; 177  : 	KeyDerivationWorkItem *item;
; 178  : 	int pkcs5PrfCount = LAST_PRF_ID - FIRST_PRF_ID + 1;

  00021	c7 85 28 fd ff
	ff 04 00 00 00	 mov	 DWORD PTR _pkcs5PrfCount$[ebp], 4

; 179  : 	size_t encryptionThreadCount = GetEncryptionThreadCount();

  0002b	e8 00 00 00 00	 call	 _GetEncryptionThreadCount@0
  00030	89 85 dc fe ff
	ff		 mov	 DWORD PTR _encryptionThreadCount$[ebp], eax

; 180  : 	size_t queuedWorkItems = 0;

  00036	c7 85 34 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _queuedWorkItems$[ebp], 0

; 181  : 	LONG outstandingWorkItemCount = 0;

  00040	c7 85 38 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _outstandingWorkItemCount$[ebp], 0

; 182  : 	int i;
; 183  : 
; 184  : 	if (retHeaderCryptoInfo != NULL)

  0004a	83 7d 18 00	 cmp	 DWORD PTR _retHeaderCryptoInfo$[ebp], 0
  0004e	74 08		 je	 SHORT $LN92@ReadVolume

; 185  : 	{
; 186  : 		cryptoInfo = retHeaderCryptoInfo;

  00050	8b 45 18	 mov	 eax, DWORD PTR _retHeaderCryptoInfo$[ebp]
  00053	89 45 fc	 mov	 DWORD PTR _cryptoInfo$[ebp], eax

; 187  : 	}
; 188  : 	else

  00056	eb 22		 jmp	 SHORT $LN91@ReadVolume
$LN92@ReadVolume:

; 189  : 	{
; 190  : 		cryptoInfo = *retInfo = crypto_open ();

  00058	e8 00 00 00 00	 call	 _crypto_open@0
  0005d	8b 4d 14	 mov	 ecx, DWORD PTR _retInfo$[ebp]
  00060	89 01		 mov	 DWORD PTR [ecx], eax
  00062	8b 55 14	 mov	 edx, DWORD PTR _retInfo$[ebp]
  00065	8b 02		 mov	 eax, DWORD PTR [edx]
  00067	89 45 fc	 mov	 DWORD PTR _cryptoInfo$[ebp], eax

; 191  : 		if (cryptoInfo == NULL)

  0006a	83 7d fc 00	 cmp	 DWORD PTR _cryptoInfo$[ebp], 0
  0006e	75 0a		 jne	 SHORT $LN91@ReadVolume

; 192  : 			return ERR_OUTOFMEMORY;

  00070	b8 02 00 00 00	 mov	 eax, 2
  00075	e9 9d 0c 00 00	 jmp	 $LN94@ReadVolume
$LN91@ReadVolume:

; 193  : 	}
; 194  : 
; 195  : 	if (encryptionThreadCount > 1)

  0007a	83 bd dc fe ff
	ff 01		 cmp	 DWORD PTR _encryptionThreadCount$[ebp], 1
  00081	0f 86 9d 00 00
	00		 jbe	 $LN89@ReadVolume

; 196  : 	{
; 197  : 		keyDerivationWorkItems = TCalloc (sizeof (KeyDerivationWorkItem) * pkcs5PrfCount);

  00087	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  0008c	8b 8d 28 fd ff
	ff		 mov	 ecx, DWORD PTR _pkcs5PrfCount$[ebp]
  00092	69 c9 0c 01 00
	00		 imul	 ecx, 268		; 0000010cH
  00098	51		 push	 ecx
  00099	6a 00		 push	 0
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  000a1	89 85 3c fd ff
	ff		 mov	 DWORD PTR _keyDerivationWorkItems$[ebp], eax

; 198  : 		if (!keyDerivationWorkItems)

  000a7	83 bd 3c fd ff
	ff 00		 cmp	 DWORD PTR _keyDerivationWorkItems$[ebp], 0
  000ae	75 0a		 jne	 SHORT $LN88@ReadVolume

; 199  : 			return ERR_OUTOFMEMORY;

  000b0	b8 02 00 00 00	 mov	 eax, 2
  000b5	e9 5d 0c 00 00	 jmp	 $LN94@ReadVolume
$LN88@ReadVolume:

; 200  : 
; 201  : 		for (i = 0; i < pkcs5PrfCount; ++i)

  000ba	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  000c4	eb 0f		 jmp	 SHORT $LN87@ReadVolume
$LN86@ReadVolume:
  000c6	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  000cc	83 c2 01	 add	 edx, 1
  000cf	89 95 f4 fe ff
	ff		 mov	 DWORD PTR _i$[ebp], edx
$LN87@ReadVolume:
  000d5	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  000db	3b 85 28 fd ff
	ff		 cmp	 eax, DWORD PTR _pkcs5PrfCount$[ebp]
  000e1	7d 1f		 jge	 SHORT $LN85@ReadVolume

; 202  : 			keyDerivationWorkItems[i].Free = TRUE;

  000e3	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  000e9	69 c9 0c 01 00
	00		 imul	 ecx, 268		; 0000010cH
  000ef	8b 95 3c fd ff
	ff		 mov	 edx, DWORD PTR _keyDerivationWorkItems$[ebp]
  000f5	c7 84 0a 00 01
	00 00 01 00 00
	00		 mov	 DWORD PTR [edx+ecx+256], 1
  00100	eb c4		 jmp	 SHORT $LN86@ReadVolume
$LN85@ReadVolume:

; 203  : 
; 204  : #ifdef DEVICE_DRIVER
; 205  : 		KeInitializeEvent (&keyDerivationCompletedEvent, SynchronizationEvent, FALSE);

  00102	6a 00		 push	 0
  00104	6a 01		 push	 1
  00106	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR _keyDerivationCompletedEvent$[ebp]
  0010c	50		 push	 eax
  0010d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 206  : 		KeInitializeEvent (&noOutstandingWorkItemEvent, SynchronizationEvent, TRUE);

  00113	6a 01		 push	 1
  00115	6a 01		 push	 1
  00117	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _noOutstandingWorkItemEvent$[ebp]
  0011d	51		 push	 ecx
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12
$LN89@ReadVolume:

; 207  : #else
; 208  : 		keyDerivationCompletedEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
; 209  : 		if (!keyDerivationCompletedEvent)
; 210  : 		{
; 211  : 			TCfree (keyDerivationWorkItems);
; 212  : 			return ERR_OUTOFMEMORY;
; 213  : 		}
; 214  : 
; 215  : 		noOutstandingWorkItemEvent = CreateEvent (NULL, FALSE, TRUE, NULL);
; 216  : 		if (!noOutstandingWorkItemEvent)
; 217  : 		{
; 218  : 			CloseHandle (keyDerivationCompletedEvent);
; 219  : 			TCfree (keyDerivationWorkItems);
; 220  : 			return ERR_OUTOFMEMORY;
; 221  : 		}
; 222  : #endif
; 223  : 	}
; 224  : 		
; 225  : #ifndef DEVICE_DRIVER
; 226  : 	VirtualLock (&keyInfo, sizeof (keyInfo));
; 227  : 	VirtualLock (&dk, sizeof (dk));
; 228  : #endif
; 229  : 
; 230  : 	crypto_loadkey (&keyInfo, password->Text, (int) password->Length);

  00124	8b 55 10	 mov	 edx, DWORD PTR _password$[ebp]
  00127	8b 02		 mov	 eax, DWORD PTR [edx]
  00129	50		 push	 eax
  0012a	8b 4d 10	 mov	 ecx, DWORD PTR _password$[ebp]
  0012d	83 c1 04	 add	 ecx, 4
  00130	51		 push	 ecx
  00131	8d 95 40 fd ff
	ff		 lea	 edx, DWORD PTR _keyInfo$[ebp]
  00137	52		 push	 edx
  00138	e8 00 00 00 00	 call	 _crypto_loadkey@12

; 231  : 
; 232  : 	// PKCS5 is used to derive the primary header key(s) and secondary header key(s) (XTS mode) from the password
; 233  : 	memcpy (keyInfo.salt, encryptedHeader + HEADER_SALT_OFFSET, PKCS5_SALT_SIZE);

  0013d	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00142	8b 75 0c	 mov	 esi, DWORD PTR _encryptedHeader$[ebp]
  00145	8d bd 88 fd ff
	ff		 lea	 edi, DWORD PTR _keyInfo$[ebp+72]
  0014b	f3 a5		 rep movsd

; 234  : 
; 235  : 	// Test all available PKCS5 PRFs
; 236  : 	for (enqPkcs5Prf = FIRST_PRF_ID; enqPkcs5Prf <= LAST_PRF_ID || queuedWorkItems > 0; ++enqPkcs5Prf)

  0014d	c7 85 30 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR _enqPkcs5Prf$[ebp], 1
  00157	eb 0f		 jmp	 SHORT $LN84@ReadVolume
$LN83@ReadVolume:
  00159	8b 85 30 fd ff
	ff		 mov	 eax, DWORD PTR _enqPkcs5Prf$[ebp]
  0015f	83 c0 01	 add	 eax, 1
  00162	89 85 30 fd ff
	ff		 mov	 DWORD PTR _enqPkcs5Prf$[ebp], eax
$LN84@ReadVolume:
  00168	83 bd 30 fd ff
	ff 04		 cmp	 DWORD PTR _enqPkcs5Prf$[ebp], 4
  0016f	7e 0d		 jle	 SHORT $LN81@ReadVolume
  00171	83 bd 34 fd ff
	ff 00		 cmp	 DWORD PTR _queuedWorkItems$[ebp], 0
  00178	0f 86 11 0a 00
	00		 jbe	 $LN82@ReadVolume
$LN81@ReadVolume:

; 237  : 	{
; 238  : 		BOOL lrw64InitDone = FALSE;		// Deprecated/legacy

  0017e	c7 85 18 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _lrw64InitDone$28091[ebp], 0

; 239  : 		BOOL lrw128InitDone = FALSE;	// Deprecated/legacy

  00188	c7 85 1c fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _lrw128InitDone$28092[ebp], 0

; 240  : 
; 241  : 		if (encryptionThreadCount > 1)

  00192	83 bd dc fe ff
	ff 01		 cmp	 DWORD PTR _encryptionThreadCount$[ebp], 1
  00199	0f 86 3e 02 00
	00		 jbe	 $LN80@ReadVolume

; 242  : 		{
; 243  : 			// Enqueue key derivation on thread pool
; 244  : 			if (queuedWorkItems < encryptionThreadCount && enqPkcs5Prf <= LAST_PRF_ID)

  0019f	8b 8d 34 fd ff
	ff		 mov	 ecx, DWORD PTR _queuedWorkItems$[ebp]
  001a5	3b 8d dc fe ff
	ff		 cmp	 ecx, DWORD PTR _encryptionThreadCount$[ebp]
  001ab	0f 83 17 01 00
	00		 jae	 $LN79@ReadVolume
  001b1	83 bd 30 fd ff
	ff 04		 cmp	 DWORD PTR _enqPkcs5Prf$[ebp], 4
  001b8	0f 8f 0a 01 00
	00		 jg	 $LN79@ReadVolume

; 245  : 			{
; 246  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  001be	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  001c8	eb 0f		 jmp	 SHORT $LN78@ReadVolume
$LN77@ReadVolume:
  001ca	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  001d0	83 c2 01	 add	 edx, 1
  001d3	89 95 f4 fe ff
	ff		 mov	 DWORD PTR _i$[ebp], edx
$LN78@ReadVolume:
  001d9	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  001df	3b 85 28 fd ff
	ff		 cmp	 eax, DWORD PTR _pkcs5PrfCount$[ebp]
  001e5	0f 8d cd 00 00
	00		 jge	 $LN76@ReadVolume

; 247  : 				{
; 248  : 					item = &keyDerivationWorkItems[i];

  001eb	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  001f1	69 c9 0c 01 00
	00		 imul	 ecx, 268		; 0000010cH
  001f7	03 8d 3c fd ff
	ff		 add	 ecx, DWORD PTR _keyDerivationWorkItems$[ebp]
  001fd	89 8d 20 fd ff
	ff		 mov	 DWORD PTR _item$[ebp], ecx

; 249  : 					if (item->Free)

  00203	8b 95 20 fd ff
	ff		 mov	 edx, DWORD PTR _item$[ebp]
  00209	83 ba 00 01 00
	00 00		 cmp	 DWORD PTR [edx+256], 0
  00210	0f 84 9d 00 00
	00		 je	 $LN75@ReadVolume

; 250  : 					{
; 251  : 						item->Free = FALSE;

  00216	8b 85 20 fd ff
	ff		 mov	 eax, DWORD PTR _item$[ebp]
  0021c	c7 80 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+256], 0

; 252  : 						item->KeyReady = FALSE;

  00226	8b 8d 20 fd ff
	ff		 mov	 ecx, DWORD PTR _item$[ebp]
  0022c	c7 81 04 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+260], 0

; 253  : 						item->Pkcs5Prf = enqPkcs5Prf;

  00236	8b 95 20 fd ff
	ff		 mov	 edx, DWORD PTR _item$[ebp]
  0023c	8b 85 30 fd ff
	ff		 mov	 eax, DWORD PTR _enqPkcs5Prf$[ebp]
  00242	89 82 08 01 00
	00		 mov	 DWORD PTR [edx+264], eax

; 254  : 
; 255  : 						EncryptionThreadPoolBeginKeyDerivation (&keyDerivationCompletedEvent, &noOutstandingWorkItemEvent,
; 256  : 							&item->KeyReady, &outstandingWorkItemCount, enqPkcs5Prf, keyInfo.userKey,
; 257  : 							keyInfo.keyLength, keyInfo.salt, get_pkcs5_iteration_count (enqPkcs5Prf, bBoot), item->DerivedKey);

  00248	8b 8d 20 fd ff
	ff		 mov	 ecx, DWORD PTR _item$[ebp]
  0024e	51		 push	 ecx
  0024f	8b 55 08	 mov	 edx, DWORD PTR _bBoot$[ebp]
  00252	52		 push	 edx
  00253	8b 85 30 fd ff
	ff		 mov	 eax, DWORD PTR _enqPkcs5Prf$[ebp]
  00259	50		 push	 eax
  0025a	e8 00 00 00 00	 call	 _get_pkcs5_iteration_count@8
  0025f	50		 push	 eax
  00260	8d 8d 88 fd ff
	ff		 lea	 ecx, DWORD PTR _keyInfo$[ebp+72]
  00266	51		 push	 ecx
  00267	8b 95 44 fd ff
	ff		 mov	 edx, DWORD PTR _keyInfo$[ebp+4]
  0026d	52		 push	 edx
  0026e	8d 85 48 fd ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+8]
  00274	50		 push	 eax
  00275	8b 8d 30 fd ff
	ff		 mov	 ecx, DWORD PTR _enqPkcs5Prf$[ebp]
  0027b	51		 push	 ecx
  0027c	8d 95 38 fd ff
	ff		 lea	 edx, DWORD PTR _outstandingWorkItemCount$[ebp]
  00282	52		 push	 edx
  00283	8b 85 20 fd ff
	ff		 mov	 eax, DWORD PTR _item$[ebp]
  00289	05 04 01 00 00	 add	 eax, 260		; 00000104H
  0028e	50		 push	 eax
  0028f	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _noOutstandingWorkItemEvent$[ebp]
  00295	51		 push	 ecx
  00296	8d 95 c8 fe ff
	ff		 lea	 edx, DWORD PTR _keyDerivationCompletedEvent$[ebp]
  0029c	52		 push	 edx
  0029d	e8 00 00 00 00	 call	 _EncryptionThreadPoolBeginKeyDerivation@40

; 258  : 						
; 259  : 						++queuedWorkItems;

  002a2	8b 85 34 fd ff
	ff		 mov	 eax, DWORD PTR _queuedWorkItems$[ebp]
  002a8	83 c0 01	 add	 eax, 1
  002ab	89 85 34 fd ff
	ff		 mov	 DWORD PTR _queuedWorkItems$[ebp], eax

; 260  : 						break;

  002b1	eb 05		 jmp	 SHORT $LN76@ReadVolume
$LN75@ReadVolume:

; 261  : 					}
; 262  : 				}

  002b3	e9 12 ff ff ff	 jmp	 $LN77@ReadVolume
$LN76@ReadVolume:

; 263  : 
; 264  : 				if (enqPkcs5Prf < LAST_PRF_ID)

  002b8	83 bd 30 fd ff
	ff 04		 cmp	 DWORD PTR _enqPkcs5Prf$[ebp], 4
  002bf	7d 05		 jge	 SHORT $LN74@ReadVolume

; 265  : 					continue;

  002c1	e9 93 fe ff ff	 jmp	 $LN83@ReadVolume
$LN74@ReadVolume:

; 266  : 			}
; 267  : 			else

  002c6	eb 0f		 jmp	 SHORT $LN72@ReadVolume
$LN79@ReadVolume:

; 268  : 				--enqPkcs5Prf;

  002c8	8b 8d 30 fd ff
	ff		 mov	 ecx, DWORD PTR _enqPkcs5Prf$[ebp]
  002ce	83 e9 01	 sub	 ecx, 1
  002d1	89 8d 30 fd ff
	ff		 mov	 DWORD PTR _enqPkcs5Prf$[ebp], ecx
$LN72@ReadVolume:

; 269  : 
; 270  : 			// Wait for completion of a key derivation
; 271  : 			while (queuedWorkItems > 0)

  002d7	83 bd 34 fd ff
	ff 00		 cmp	 DWORD PTR _queuedWorkItems$[ebp], 0
  002de	0f 86 ef 00 00
	00		 jbe	 $LN71@ReadVolume

; 272  : 			{
; 273  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  002e4	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  002ee	eb 0f		 jmp	 SHORT $LN70@ReadVolume
$LN69@ReadVolume:
  002f0	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  002f6	83 c2 01	 add	 edx, 1
  002f9	89 95 f4 fe ff
	ff		 mov	 DWORD PTR _i$[ebp], edx
$LN70@ReadVolume:
  002ff	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00305	3b 85 28 fd ff
	ff		 cmp	 eax, DWORD PTR _pkcs5PrfCount$[ebp]
  0030b	0f 8d 9f 00 00
	00		 jge	 $LN68@ReadVolume

; 274  : 				{
; 275  : 					item = &keyDerivationWorkItems[i];

  00311	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00317	69 c9 0c 01 00
	00		 imul	 ecx, 268		; 0000010cH
  0031d	03 8d 3c fd ff
	ff		 add	 ecx, DWORD PTR _keyDerivationWorkItems$[ebp]
  00323	89 8d 20 fd ff
	ff		 mov	 DWORD PTR _item$[ebp], ecx

; 276  : 					if (!item->Free && InterlockedExchangeAdd (&item->KeyReady, 0) == TRUE)

  00329	8b 95 20 fd ff
	ff		 mov	 edx, DWORD PTR _item$[ebp]
  0032f	83 ba 00 01 00
	00 00		 cmp	 DWORD PTR [edx+256], 0
  00336	75 73		 jne	 SHORT $LN67@ReadVolume
  00338	33 c0		 xor	 eax, eax
  0033a	8b 8d 20 fd ff
	ff		 mov	 ecx, DWORD PTR _item$[ebp]
  00340	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  00346	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  0034a	83 f8 01	 cmp	 eax, 1
  0034d	75 5c		 jne	 SHORT $LN67@ReadVolume

; 277  : 					{
; 278  : 						pkcs5_prf = item->Pkcs5Prf;

  0034f	8b 95 20 fd ff
	ff		 mov	 edx, DWORD PTR _item$[ebp]
  00355	8b 82 08 01 00
	00		 mov	 eax, DWORD PTR [edx+264]
  0035b	89 85 24 fd ff
	ff		 mov	 DWORD PTR _pkcs5_prf$[ebp], eax

; 279  : 						keyInfo.noIterations = get_pkcs5_iteration_count (pkcs5_prf, bBoot);

  00361	8b 4d 08	 mov	 ecx, DWORD PTR _bBoot$[ebp]
  00364	51		 push	 ecx
  00365	8b 95 24 fd ff
	ff		 mov	 edx, DWORD PTR _pkcs5_prf$[ebp]
  0036b	52		 push	 edx
  0036c	e8 00 00 00 00	 call	 _get_pkcs5_iteration_count@8
  00371	89 85 40 fd ff
	ff		 mov	 DWORD PTR _keyInfo$[ebp], eax

; 280  : 						memcpy (dk, item->DerivedKey, sizeof (dk));

  00377	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0037c	8b b5 20 fd ff
	ff		 mov	 esi, DWORD PTR _item$[ebp]
  00382	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR _dk$[ebp]
  00388	f3 a5		 rep movsd

; 281  : 
; 282  : 						item->Free = TRUE;

  0038a	8b 85 20 fd ff
	ff		 mov	 eax, DWORD PTR _item$[ebp]
  00390	c7 80 00 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+256], 1

; 283  : 						--queuedWorkItems;

  0039a	8b 8d 34 fd ff
	ff		 mov	 ecx, DWORD PTR _queuedWorkItems$[ebp]
  003a0	83 e9 01	 sub	 ecx, 1
  003a3	89 8d 34 fd ff
	ff		 mov	 DWORD PTR _queuedWorkItems$[ebp], ecx

; 284  : 						goto KeyReady;

  003a9	eb 2d		 jmp	 SHORT $KeyReady$28108
$LN67@ReadVolume:

; 285  : 					}
; 286  : 				}

  003ab	e9 40 ff ff ff	 jmp	 $LN69@ReadVolume
$LN68@ReadVolume:

; 287  : 
; 288  : 				if (queuedWorkItems > 0)

  003b0	83 bd 34 fd ff
	ff 00		 cmp	 DWORD PTR _queuedWorkItems$[ebp], 0
  003b7	76 15		 jbe	 SHORT $LN66@ReadVolume

; 289  : 					TC_WAIT_EVENT (keyDerivationCompletedEvent);

  003b9	6a 00		 push	 0
  003bb	6a 00		 push	 0
  003bd	6a 00		 push	 0
  003bf	6a 00		 push	 0
  003c1	8d 95 c8 fe ff
	ff		 lea	 edx, DWORD PTR _keyDerivationCompletedEvent$[ebp]
  003c7	52		 push	 edx
  003c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
$LN66@ReadVolume:

; 290  : 			}

  003ce	e9 04 ff ff ff	 jmp	 $LN72@ReadVolume
$LN71@ReadVolume:

; 291  : 			continue;

  003d3	e9 81 fd ff ff	 jmp	 $LN83@ReadVolume
$KeyReady$28108:

; 292  : KeyReady:	;
; 293  : 		}
; 294  : 		else

  003d8	e9 38 01 00 00	 jmp	 $LN65@ReadVolume
$LN80@ReadVolume:

; 295  : 		{
; 296  : 			pkcs5_prf = enqPkcs5Prf;

  003dd	8b 85 30 fd ff
	ff		 mov	 eax, DWORD PTR _enqPkcs5Prf$[ebp]
  003e3	89 85 24 fd ff
	ff		 mov	 DWORD PTR _pkcs5_prf$[ebp], eax

; 297  : 			keyInfo.noIterations = get_pkcs5_iteration_count (enqPkcs5Prf, bBoot);

  003e9	8b 4d 08	 mov	 ecx, DWORD PTR _bBoot$[ebp]
  003ec	51		 push	 ecx
  003ed	8b 95 30 fd ff
	ff		 mov	 edx, DWORD PTR _enqPkcs5Prf$[ebp]
  003f3	52		 push	 edx
  003f4	e8 00 00 00 00	 call	 _get_pkcs5_iteration_count@8
  003f9	89 85 40 fd ff
	ff		 mov	 DWORD PTR _keyInfo$[ebp], eax

; 298  : 
; 299  : 			switch (pkcs5_prf)

  003ff	8b 85 24 fd ff
	ff		 mov	 eax, DWORD PTR _pkcs5_prf$[ebp]
  00405	89 85 dc fa ff
	ff		 mov	 DWORD PTR tv191[ebp], eax
  0040b	8b 8d dc fa ff
	ff		 mov	 ecx, DWORD PTR tv191[ebp]
  00411	83 e9 01	 sub	 ecx, 1
  00414	89 8d dc fa ff
	ff		 mov	 DWORD PTR tv191[ebp], ecx
  0041a	83 bd dc fa ff
	ff 03		 cmp	 DWORD PTR tv191[ebp], 3
  00421	0f 87 d8 00 00
	00		 ja	 $LN58@ReadVolume
  00427	8b 95 dc fa ff
	ff		 mov	 edx, DWORD PTR tv191[ebp]
  0042d	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN97@ReadVolume[edx*4]
$LN62@ReadVolume:

; 300  : 			{
; 301  : 			case RIPEMD160:
; 302  : 				derive_key_ripemd160 (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 303  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  00434	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize@0
  00439	50		 push	 eax
  0043a	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _dk$[ebp]
  00440	50		 push	 eax
  00441	8b 8d 40 fd ff
	ff		 mov	 ecx, DWORD PTR _keyInfo$[ebp]
  00447	51		 push	 ecx
  00448	6a 40		 push	 64			; 00000040H
  0044a	8d 95 88 fd ff
	ff		 lea	 edx, DWORD PTR _keyInfo$[ebp+72]
  00450	52		 push	 edx
  00451	8b 85 44 fd ff
	ff		 mov	 eax, DWORD PTR _keyInfo$[ebp+4]
  00457	50		 push	 eax
  00458	8d 8d 48 fd ff
	ff		 lea	 ecx, DWORD PTR _keyInfo$[ebp+8]
  0045e	51		 push	 ecx
  0045f	e8 00 00 00 00	 call	 _derive_key_ripemd160@28

; 304  : 				break;

  00464	e9 ac 00 00 00	 jmp	 $LN65@ReadVolume
$LN61@ReadVolume:

; 305  : 
; 306  : 			case SHA512:
; 307  : 				derive_key_sha512 (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 308  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  00469	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize@0
  0046e	50		 push	 eax
  0046f	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _dk$[ebp]
  00475	52		 push	 edx
  00476	8b 85 40 fd ff
	ff		 mov	 eax, DWORD PTR _keyInfo$[ebp]
  0047c	50		 push	 eax
  0047d	6a 40		 push	 64			; 00000040H
  0047f	8d 8d 88 fd ff
	ff		 lea	 ecx, DWORD PTR _keyInfo$[ebp+72]
  00485	51		 push	 ecx
  00486	8b 95 44 fd ff
	ff		 mov	 edx, DWORD PTR _keyInfo$[ebp+4]
  0048c	52		 push	 edx
  0048d	8d 85 48 fd ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+8]
  00493	50		 push	 eax
  00494	e8 00 00 00 00	 call	 _derive_key_sha512@28

; 309  : 				break;

  00499	eb 7a		 jmp	 SHORT $LN65@ReadVolume
$LN60@ReadVolume:

; 310  : 
; 311  : 			case SHA1:
; 312  : 				// Deprecated/legacy
; 313  : 				derive_key_sha1 (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 314  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  0049b	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize@0
  004a0	50		 push	 eax
  004a1	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _dk$[ebp]
  004a7	51		 push	 ecx
  004a8	8b 95 40 fd ff
	ff		 mov	 edx, DWORD PTR _keyInfo$[ebp]
  004ae	52		 push	 edx
  004af	6a 40		 push	 64			; 00000040H
  004b1	8d 85 88 fd ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+72]
  004b7	50		 push	 eax
  004b8	8b 8d 44 fd ff
	ff		 mov	 ecx, DWORD PTR _keyInfo$[ebp+4]
  004be	51		 push	 ecx
  004bf	8d 95 48 fd ff
	ff		 lea	 edx, DWORD PTR _keyInfo$[ebp+8]
  004c5	52		 push	 edx
  004c6	e8 00 00 00 00	 call	 _derive_key_sha1@28

; 315  : 				break;

  004cb	eb 48		 jmp	 SHORT $LN65@ReadVolume
$LN59@ReadVolume:

; 316  : 
; 317  : 			case WHIRLPOOL:
; 318  : 				derive_key_whirlpool (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 319  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  004cd	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize@0
  004d2	50		 push	 eax
  004d3	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _dk$[ebp]
  004d9	50		 push	 eax
  004da	8b 8d 40 fd ff
	ff		 mov	 ecx, DWORD PTR _keyInfo$[ebp]
  004e0	51		 push	 ecx
  004e1	6a 40		 push	 64			; 00000040H
  004e3	8d 95 88 fd ff
	ff		 lea	 edx, DWORD PTR _keyInfo$[ebp+72]
  004e9	52		 push	 edx
  004ea	8b 85 44 fd ff
	ff		 mov	 eax, DWORD PTR _keyInfo$[ebp+4]
  004f0	50		 push	 eax
  004f1	8d 8d 48 fd ff
	ff		 lea	 ecx, DWORD PTR _keyInfo$[ebp+8]
  004f7	51		 push	 ecx
  004f8	e8 00 00 00 00	 call	 _derive_key_whirlpool@28

; 320  : 				break;

  004fd	eb 16		 jmp	 SHORT $LN65@ReadVolume
$LN58@ReadVolume:

; 321  : 
; 322  : 			default:		
; 323  : 				// Unknown/wrong ID
; 324  : 				TC_THROW_FATAL_EXCEPTION;

  004ff	68 43 54 00 00	 push	 21571			; 00005443H
  00504	6a 00		 push	 0
  00506	6a 00		 push	 0
  00508	68 44 01 00 00	 push	 324			; 00000144H
  0050d	6a 29		 push	 41			; 00000029H
  0050f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN65@ReadVolume:

; 325  : 			} 
; 326  : 		}
; 327  : 
; 328  : 		// Test all available modes of operation
; 329  : 		for (cryptoInfo->mode = FIRST_MODE_OF_OPERATION_ID;
; 330  : 			cryptoInfo->mode <= LAST_MODE_OF_OPERATION;
; 331  : 			cryptoInfo->mode++)

  00515	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00518	c7 42 04 01 00
	00 00		 mov	 DWORD PTR [edx+4], 1
  0051f	eb 0f		 jmp	 SHORT $LN57@ReadVolume
$LN56@ReadVolume:
  00521	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00524	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00527	83 c1 01	 add	 ecx, 1
  0052a	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  0052d	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN57@ReadVolume:
  00530	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00533	83 78 04 05	 cmp	 DWORD PTR [eax+4], 5
  00537	0f 8f 4d 06 00
	00		 jg	 $LN55@ReadVolume

; 332  : 		{
; 333  : 			switch (cryptoInfo->mode)

  0053d	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00540	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00543	89 95 d8 fa ff
	ff		 mov	 DWORD PTR tv239[ebp], edx
  00549	83 bd d8 fa ff
	ff 02		 cmp	 DWORD PTR tv239[ebp], 2
  00550	7c 2d		 jl	 SHORT $LN51@ReadVolume
  00552	83 bd d8 fa ff
	ff 05		 cmp	 DWORD PTR tv239[ebp], 5
  00559	7e 02		 jle	 SHORT $LN52@ReadVolume
  0055b	eb 22		 jmp	 SHORT $LN51@ReadVolume
$LN52@ReadVolume:

; 334  : 			{
; 335  : 			case LRW:
; 336  : 			case CBC:
; 337  : 			case INNER_CBC:
; 338  : 			case OUTER_CBC:
; 339  : 
; 340  : 				// For LRW (deprecated/legacy), copy the tweak key 
; 341  : 				// For CBC (deprecated/legacy), copy the IV/whitening seed 
; 342  : 				memcpy (cryptoInfo->k2, dk, LEGACY_VOL_IV_SIZE);

  0055d	8b 7d fc	 mov	 edi, DWORD PTR _cryptoInfo$[ebp]
  00560	81 c7 a8 42 00
	00		 add	 edi, 17064		; 000042a8H
  00566	b9 08 00 00 00	 mov	 ecx, 8
  0056b	8d b5 f8 fe ff
	ff		 lea	 esi, DWORD PTR _dk$[ebp]
  00571	f3 a5		 rep movsd

; 343  : 				primaryKeyOffset = LEGACY_VOL_IV_SIZE;

  00573	c7 85 d8 fe ff
	ff 20 00 00 00	 mov	 DWORD PTR _primaryKeyOffset$[ebp], 32 ; 00000020H

; 344  : 				break;

  0057d	eb 0a		 jmp	 SHORT $LN53@ReadVolume
$LN51@ReadVolume:

; 345  : 
; 346  : 			default:
; 347  : 				primaryKeyOffset = 0;

  0057f	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _primaryKeyOffset$[ebp], 0
$LN53@ReadVolume:

; 348  : 			}
; 349  : 
; 350  : 			// Test all available encryption algorithms
; 351  : 			for (cryptoInfo->ea = EAGetFirst ();
; 352  : 				cryptoInfo->ea != 0;
; 353  : 				cryptoInfo->ea = EAGetNext (cryptoInfo->ea))

  00589	e8 00 00 00 00	 call	 _EAGetFirst@0
  0058e	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00591	89 01		 mov	 DWORD PTR [ecx], eax
  00593	eb 10		 jmp	 SHORT $LN50@ReadVolume
$LN49@ReadVolume:
  00595	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00598	8b 02		 mov	 eax, DWORD PTR [edx]
  0059a	50		 push	 eax
  0059b	e8 00 00 00 00	 call	 _EAGetNext@4
  005a0	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  005a3	89 01		 mov	 DWORD PTR [ecx], eax
$LN50@ReadVolume:
  005a5	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  005a8	83 3a 00	 cmp	 DWORD PTR [edx], 0
  005ab	0f 84 d4 05 00
	00		 je	 $LN48@ReadVolume

; 354  : 			{
; 355  : 				int blockSize;
; 356  : 
; 357  : 				if (!EAIsModeSupported (cryptoInfo->ea, cryptoInfo->mode))

  005b1	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  005b4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  005b7	51		 push	 ecx
  005b8	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  005bb	8b 02		 mov	 eax, DWORD PTR [edx]
  005bd	50		 push	 eax
  005be	e8 00 00 00 00	 call	 _EAIsModeSupported@8
  005c3	85 c0		 test	 eax, eax
  005c5	75 02		 jne	 SHORT $LN47@ReadVolume

; 358  : 					continue;	// This encryption algorithm has never been available with this mode of operation

  005c7	eb cc		 jmp	 SHORT $LN49@ReadVolume
$LN47@ReadVolume:

; 359  : 
; 360  : 				blockSize = CipherGetBlockSize (EAGetFirstCipher (cryptoInfo->ea));

  005c9	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  005cc	8b 11		 mov	 edx, DWORD PTR [ecx]
  005ce	52		 push	 edx
  005cf	e8 00 00 00 00	 call	 _EAGetFirstCipher@4
  005d4	50		 push	 eax
  005d5	e8 00 00 00 00	 call	 _CipherGetBlockSize@4
  005da	89 85 14 fb ff
	ff		 mov	 DWORD PTR _blockSize$28134[ebp], eax

; 361  : 
; 362  : 				status = EAInit (cryptoInfo->ea, dk + primaryKeyOffset, cryptoInfo->ks);

  005e0	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  005e3	83 c0 08	 add	 eax, 8
  005e6	50		 push	 eax
  005e7	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _primaryKeyOffset$[ebp]
  005ed	8d 94 0d f8 fe
	ff ff		 lea	 edx, DWORD PTR _dk$[ebp+ecx]
  005f4	52		 push	 edx
  005f5	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  005f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  005fa	51		 push	 ecx
  005fb	e8 00 00 00 00	 call	 _EAInit@12
  00600	89 85 2c fd ff
	ff		 mov	 DWORD PTR _status$[ebp], eax

; 363  : 				if (status == ERR_CIPHER_INIT_FAILURE)

  00606	83 bd 2c fd ff
	ff 11		 cmp	 DWORD PTR _status$[ebp], 17 ; 00000011H
  0060d	75 05		 jne	 SHORT $LN46@ReadVolume

; 364  : 					goto err;

  0060f	e9 85 05 00 00	 jmp	 $err$28137
$LN46@ReadVolume:

; 365  : 
; 366  : 				// Init objects related to the mode of operation
; 367  : 
; 368  : 				if (cryptoInfo->mode == XTS)

  00614	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00617	83 7a 04 01	 cmp	 DWORD PTR [edx+4], 1
  0061b	75 4f		 jne	 SHORT $LN45@ReadVolume

; 369  : 				{
; 370  : 					// Copy the secondary key (if cascade, multiple concatenated)
; 371  : 					memcpy (cryptoInfo->k2, dk + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));

  0061d	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00620	8b 08		 mov	 ecx, DWORD PTR [eax]
  00622	51		 push	 ecx
  00623	e8 00 00 00 00	 call	 _EAGetKeySize@4
  00628	50		 push	 eax
  00629	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  0062c	8b 02		 mov	 eax, DWORD PTR [edx]
  0062e	50		 push	 eax
  0062f	e8 00 00 00 00	 call	 _EAGetKeySize@4
  00634	8d 8c 05 f8 fe
	ff ff		 lea	 ecx, DWORD PTR _dk$[ebp+eax]
  0063b	51		 push	 ecx
  0063c	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  0063f	81 c2 a8 42 00
	00		 add	 edx, 17064		; 000042a8H
  00645	52		 push	 edx
  00646	e8 00 00 00 00	 call	 _memcpy
  0064b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 372  : 
; 373  : 					// Secondary key schedule
; 374  : 					if (!EAInitMode (cryptoInfo))

  0064e	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00651	50		 push	 eax
  00652	e8 00 00 00 00	 call	 _EAInitMode@4
  00657	85 c0		 test	 eax, eax
  00659	75 0f		 jne	 SHORT $LN44@ReadVolume

; 375  : 					{
; 376  : 						status = ERR_MODE_INIT_FAILED;

  0065b	c7 85 2c fd ff
	ff 1b 00 00 00	 mov	 DWORD PTR _status$[ebp], 27 ; 0000001bH

; 377  : 						goto err;

  00665	e9 2f 05 00 00	 jmp	 $err$28137
$LN44@ReadVolume:

; 378  : 					}
; 379  : 				}
; 380  : 				else if (cryptoInfo->mode == LRW

  0066a	eb 71		 jmp	 SHORT $LN43@ReadVolume
$LN45@ReadVolume:

; 381  : 					&& (blockSize == 8 && !lrw64InitDone || blockSize == 16 && !lrw128InitDone))

  0066c	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  0066f	83 79 04 02	 cmp	 DWORD PTR [ecx+4], 2
  00673	75 68		 jne	 SHORT $LN43@ReadVolume
  00675	83 bd 14 fb ff
	ff 08		 cmp	 DWORD PTR _blockSize$28134[ebp], 8
  0067c	75 09		 jne	 SHORT $LN40@ReadVolume
  0067e	83 bd 18 fb ff
	ff 00		 cmp	 DWORD PTR _lrw64InitDone$28091[ebp], 0
  00685	74 12		 je	 SHORT $LN41@ReadVolume
$LN40@ReadVolume:
  00687	83 bd 14 fb ff
	ff 10		 cmp	 DWORD PTR _blockSize$28134[ebp], 16 ; 00000010H
  0068e	75 4d		 jne	 SHORT $LN43@ReadVolume
  00690	83 bd 1c fb ff
	ff 00		 cmp	 DWORD PTR _lrw128InitDone$28092[ebp], 0
  00697	75 44		 jne	 SHORT $LN43@ReadVolume
$LN41@ReadVolume:

; 382  : 				{
; 383  : 					// Deprecated/legacy
; 384  : 
; 385  : 					if (!EAInitMode (cryptoInfo))

  00699	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  0069c	52		 push	 edx
  0069d	e8 00 00 00 00	 call	 _EAInitMode@4
  006a2	85 c0		 test	 eax, eax
  006a4	75 0f		 jne	 SHORT $LN39@ReadVolume

; 386  : 					{
; 387  : 						status = ERR_MODE_INIT_FAILED;

  006a6	c7 85 2c fd ff
	ff 1b 00 00 00	 mov	 DWORD PTR _status$[ebp], 27 ; 0000001bH

; 388  : 						goto err;

  006b0	e9 e4 04 00 00	 jmp	 $err$28137
$LN39@ReadVolume:

; 389  : 					}
; 390  : 
; 391  : 					if (blockSize == 8)

  006b5	83 bd 14 fb ff
	ff 08		 cmp	 DWORD PTR _blockSize$28134[ebp], 8
  006bc	75 0c		 jne	 SHORT $LN38@ReadVolume

; 392  : 						lrw64InitDone = TRUE;

  006be	c7 85 18 fb ff
	ff 01 00 00 00	 mov	 DWORD PTR _lrw64InitDone$28091[ebp], 1
  006c8	eb 13		 jmp	 SHORT $LN43@ReadVolume
$LN38@ReadVolume:

; 393  : 					else if (blockSize == 16)

  006ca	83 bd 14 fb ff
	ff 10		 cmp	 DWORD PTR _blockSize$28134[ebp], 16 ; 00000010H
  006d1	75 0a		 jne	 SHORT $LN43@ReadVolume

; 394  : 						lrw128InitDone = TRUE;

  006d3	c7 85 1c fb ff
	ff 01 00 00 00	 mov	 DWORD PTR _lrw128InitDone$28092[ebp], 1
$LN43@ReadVolume:

; 395  : 				}
; 396  : 
; 397  : 				// Copy the header for decryption
; 398  : 				memcpy (header, encryptedHeader, sizeof (header));

  006dd	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  006e2	8b 75 0c	 mov	 esi, DWORD PTR _encryptedHeader$[ebp]
  006e5	8d bd 20 fb ff
	ff		 lea	 edi, DWORD PTR _header$[ebp]
  006eb	f3 a5		 rep movsd

; 399  : 
; 400  : 				// Try to decrypt header 
; 401  : 
; 402  : 				DecryptBuffer (header + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, cryptoInfo);

  006ed	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  006f0	50		 push	 eax
  006f1	6a 00		 push	 0
  006f3	68 c0 01 00 00	 push	 448			; 000001c0H
  006f8	8d 8d 60 fb ff
	ff		 lea	 ecx, DWORD PTR _header$[ebp+64]
  006fe	51		 push	 ecx
  006ff	e8 00 00 00 00	 call	 _DecryptBuffer@16

; 403  : 
; 404  : 				// Magic 'TRUE'
; 405  : 				/* Modifying 'TRUE' can introduce incompatibility with previous versions. */
; 406  : 				if (GetHeaderField32 (header, TC_HEADER_OFFSET_MAGIC) != 0x54525545)

  00704	6a 40		 push	 64			; 00000040H
  00706	8d 95 20 fb ff
	ff		 lea	 edx, DWORD PTR _header$[ebp]
  0070c	52		 push	 edx
  0070d	e8 00 00 00 00	 call	 _GetHeaderField32@8
  00712	3d 45 55 52 54	 cmp	 eax, 1414681925		; 54525545H
  00717	74 05		 je	 SHORT $LN35@ReadVolume

; 407  : 					continue;

  00719	e9 77 fe ff ff	 jmp	 $LN49@ReadVolume
$LN35@ReadVolume:

; 408  : 
; 409  : 				// Header version
; 410  : 				headerVersion = GetHeaderField16 (header, TC_HEADER_OFFSET_VERSION);

  0071e	6a 44		 push	 68			; 00000044H
  00720	8d 85 20 fb ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  00726	50		 push	 eax
  00727	e8 00 00 00 00	 call	 _GetHeaderField16@8
  0072c	66 89 85 e0 fe
	ff ff		 mov	 WORD PTR _headerVersion$[ebp], ax

; 411  : 				
; 412  : 				if (headerVersion > VOLUME_HEADER_VERSION)

  00733	0f b7 8d e0 fe
	ff ff		 movzx	 ecx, WORD PTR _headerVersion$[ebp]
  0073a	83 f9 05	 cmp	 ecx, 5
  0073d	7e 0f		 jle	 SHORT $LN34@ReadVolume

; 413  : 				{
; 414  : 					status = ERR_NEW_VERSION_REQUIRED;

  0073f	c7 85 2c fd ff
	ff 10 00 00 00	 mov	 DWORD PTR _status$[ebp], 16 ; 00000010H

; 415  : 					goto err;

  00749	e9 4b 04 00 00	 jmp	 $err$28137
$LN34@ReadVolume:

; 416  : 				}
; 417  : 
; 418  : 				// Check CRC of the header fields
; 419  : 				if (!ReadVolumeHeaderRecoveryMode
; 420  : 					&& headerVersion >= 4
; 421  : 					&& GetHeaderField32 (header, TC_HEADER_OFFSET_HEADER_CRC) != GetCrc32 (header + TC_HEADER_OFFSET_MAGIC, TC_HEADER_OFFSET_HEADER_CRC - TC_HEADER_OFFSET_MAGIC))

  0074e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ReadVolumeHeaderRecoveryMode, 0
  00755	75 39		 jne	 SHORT $LN33@ReadVolume
  00757	0f b7 95 e0 fe
	ff ff		 movzx	 edx, WORD PTR _headerVersion$[ebp]
  0075e	83 fa 04	 cmp	 edx, 4
  00761	7c 2d		 jl	 SHORT $LN33@ReadVolume
  00763	68 fc 00 00 00	 push	 252			; 000000fcH
  00768	8d 85 20 fb ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  0076e	50		 push	 eax
  0076f	e8 00 00 00 00	 call	 _GetHeaderField32@8
  00774	8b f0		 mov	 esi, eax
  00776	68 bc 00 00 00	 push	 188			; 000000bcH
  0077b	8d 8d 60 fb ff
	ff		 lea	 ecx, DWORD PTR _header$[ebp+64]
  00781	51		 push	 ecx
  00782	e8 00 00 00 00	 call	 _GetCrc32@8
  00787	3b f0		 cmp	 esi, eax
  00789	74 05		 je	 SHORT $LN33@ReadVolume

; 422  : 					continue;

  0078b	e9 05 fe ff ff	 jmp	 $LN49@ReadVolume
$LN33@ReadVolume:

; 423  : 
; 424  : 				// Required program version
; 425  : 				cryptoInfo->RequiredProgramVersion = GetHeaderField16 (header, TC_HEADER_OFFSET_REQUIRED_VERSION);

  00790	6a 46		 push	 70			; 00000046H
  00792	8d 95 20 fb ff
	ff		 lea	 edx, DWORD PTR _header$[ebp]
  00798	52		 push	 edx
  00799	e8 00 00 00 00	 call	 _GetHeaderField16@8
  0079e	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  007a1	66 89 81 38 44
	00 00		 mov	 WORD PTR [ecx+17464], ax

; 426  : 				cryptoInfo->LegacyVolume = cryptoInfo->RequiredProgramVersion < 0x600;

  007a8	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  007ab	0f b7 82 38 44
	00 00		 movzx	 eax, WORD PTR [edx+17464]
  007b2	33 c9		 xor	 ecx, ecx
  007b4	3d 00 06 00 00	 cmp	 eax, 1536		; 00000600H
  007b9	0f 9c c1	 setl	 cl
  007bc	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  007bf	89 8a 3c 44 00
	00		 mov	 DWORD PTR [edx+17468], ecx

; 427  : 
; 428  : 				// Check CRC of the key set
; 429  : 				if (!ReadVolumeHeaderRecoveryMode
; 430  : 					&& GetHeaderField32 (header, TC_HEADER_OFFSET_KEY_AREA_CRC) != GetCrc32 (header + HEADER_MASTER_KEYDATA_OFFSET, MASTER_KEYDATA_SIZE))

  007c5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ReadVolumeHeaderRecoveryMode, 0
  007cc	75 2a		 jne	 SHORT $LN32@ReadVolume
  007ce	6a 48		 push	 72			; 00000048H
  007d0	8d 85 20 fb ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  007d6	50		 push	 eax
  007d7	e8 00 00 00 00	 call	 _GetHeaderField32@8
  007dc	8b f0		 mov	 esi, eax
  007de	68 00 01 00 00	 push	 256			; 00000100H
  007e3	8d 8d 20 fc ff
	ff		 lea	 ecx, DWORD PTR _header$[ebp+256]
  007e9	51		 push	 ecx
  007ea	e8 00 00 00 00	 call	 _GetCrc32@8
  007ef	3b f0		 cmp	 esi, eax
  007f1	74 05		 je	 SHORT $LN32@ReadVolume

; 431  : 					continue;

  007f3	e9 9d fd ff ff	 jmp	 $LN49@ReadVolume
$LN32@ReadVolume:

; 432  : 
; 433  : 				// Now we have the correct password, cipher, hash algorithm, and volume type
; 434  : 
; 435  : 				// Check the version required to handle this volume
; 436  : 				if (cryptoInfo->RequiredProgramVersion > VERSION_NUM)

  007f8	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  007fb	0f b7 82 38 44
	00 00		 movzx	 eax, WORD PTR [edx+17464]
  00802	3d 41 07 00 00	 cmp	 eax, 1857		; 00000741H
  00807	7e 0f		 jle	 SHORT $LN31@ReadVolume

; 437  : 				{
; 438  : 					status = ERR_NEW_VERSION_REQUIRED;

  00809	c7 85 2c fd ff
	ff 10 00 00 00	 mov	 DWORD PTR _status$[ebp], 16 ; 00000010H

; 439  : 					goto err;

  00813	e9 81 03 00 00	 jmp	 $err$28137
$LN31@ReadVolume:

; 440  : 				}
; 441  : 
; 442  : 				// Header version
; 443  : 				cryptoInfo->HeaderVersion = headerVersion;

  00818	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  0081b	66 8b 95 e0 fe
	ff ff		 mov	 dx, WORD PTR _headerVersion$[ebp]
  00822	66 89 91 a4 29
	00 00		 mov	 WORD PTR [ecx+10660], dx

; 444  : 
; 445  : 				// Volume creation time (legacy)
; 446  : 				cryptoInfo->volume_creation_time = GetHeaderField64 (header, TC_HEADER_OFFSET_VOLUME_CREATION_TIME).Value;

  00829	6a 4c		 push	 76			; 0000004cH
  0082b	8d 85 20 fb ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  00831	50		 push	 eax
  00832	e8 00 00 00 00	 call	 _GetHeaderField64@8
  00837	89 85 f0 fa ff
	ff		 mov	 DWORD PTR $T28244[ebp], eax
  0083d	89 95 f4 fa ff
	ff		 mov	 DWORD PTR $T28244[ebp+4], edx
  00843	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00846	8b 95 f0 fa ff
	ff		 mov	 edx, DWORD PTR $T28244[ebp]
  0084c	89 91 f0 43 00
	00		 mov	 DWORD PTR [ecx+17392], edx
  00852	8b 85 f4 fa ff
	ff		 mov	 eax, DWORD PTR $T28244[ebp+4]
  00858	89 81 f4 43 00
	00		 mov	 DWORD PTR [ecx+17396], eax

; 447  : 
; 448  : 				// Header creation time (legacy)
; 449  : 				cryptoInfo->header_creation_time = GetHeaderField64 (header, TC_HEADER_OFFSET_MODIFICATION_TIME).Value;

  0085e	6a 54		 push	 84			; 00000054H
  00860	8d 8d 20 fb ff
	ff		 lea	 ecx, DWORD PTR _header$[ebp]
  00866	51		 push	 ecx
  00867	e8 00 00 00 00	 call	 _GetHeaderField64@8
  0086c	89 85 e8 fa ff
	ff		 mov	 DWORD PTR $T28245[ebp], eax
  00872	89 95 ec fa ff
	ff		 mov	 DWORD PTR $T28245[ebp+4], edx
  00878	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  0087b	8b 85 e8 fa ff
	ff		 mov	 eax, DWORD PTR $T28245[ebp]
  00881	89 82 f8 43 00
	00		 mov	 DWORD PTR [edx+17400], eax
  00887	8b 8d ec fa ff
	ff		 mov	 ecx, DWORD PTR $T28245[ebp+4]
  0088d	89 8a fc 43 00
	00		 mov	 DWORD PTR [edx+17404], ecx

; 450  : 
; 451  : 				// Hidden volume size (if any)
; 452  : 				cryptoInfo->hiddenVolumeSize = GetHeaderField64 (header, TC_HEADER_OFFSET_HIDDEN_VOLUME_SIZE).Value;

  00893	6a 5c		 push	 92			; 0000005cH
  00895	8d 95 20 fb ff
	ff		 lea	 edx, DWORD PTR _header$[ebp]
  0089b	52		 push	 edx
  0089c	e8 00 00 00 00	 call	 _GetHeaderField64@8
  008a1	89 85 e0 fa ff
	ff		 mov	 DWORD PTR $T28246[ebp], eax
  008a7	89 95 e4 fa ff
	ff		 mov	 DWORD PTR $T28246[ebp+4], edx
  008ad	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  008b0	8b 8d e0 fa ff
	ff		 mov	 ecx, DWORD PTR $T28246[ebp]
  008b6	89 88 10 44 00
	00		 mov	 DWORD PTR [eax+17424], ecx
  008bc	8b 95 e4 fa ff
	ff		 mov	 edx, DWORD PTR $T28246[ebp+4]
  008c2	89 90 14 44 00
	00		 mov	 DWORD PTR [eax+17428], edx

; 453  : 
; 454  : 				// Hidden volume status
; 455  : 				cryptoInfo->hiddenVolume = (cryptoInfo->hiddenVolumeSize != 0);

  008c8	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  008cb	89 85 d4 fa ff
	ff		 mov	 DWORD PTR tv706[ebp], eax
  008d1	8b 8d d4 fa ff
	ff		 mov	 ecx, DWORD PTR tv706[ebp]
  008d7	8b 95 d4 fa ff
	ff		 mov	 edx, DWORD PTR tv706[ebp]
  008dd	8b 81 10 44 00
	00		 mov	 eax, DWORD PTR [ecx+17424]
  008e3	0b 82 14 44 00
	00		 or	 eax, DWORD PTR [edx+17428]
  008e9	74 0c		 je	 SHORT $LN95@ReadVolume
  008eb	c7 85 d0 fa ff
	ff 01 00 00 00	 mov	 DWORD PTR tv391[ebp], 1
  008f5	eb 0a		 jmp	 SHORT $LN96@ReadVolume
$LN95@ReadVolume:
  008f7	c7 85 d0 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR tv391[ebp], 0
$LN96@ReadVolume:
  00901	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00904	8b 95 d0 fa ff
	ff		 mov	 edx, DWORD PTR tv391[ebp]
  0090a	89 91 a0 29 00
	00		 mov	 DWORD PTR [ecx+10656], edx

; 456  : 
; 457  : 				// Volume size
; 458  : 				cryptoInfo->VolumeSize = GetHeaderField64 (header, TC_HEADER_OFFSET_VOLUME_SIZE);

  00910	6a 64		 push	 100			; 00000064H
  00912	8d 85 20 fb ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  00918	50		 push	 eax
  00919	e8 00 00 00 00	 call	 _GetHeaderField64@8
  0091e	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00921	89 81 48 44 00
	00		 mov	 DWORD PTR [ecx+17480], eax
  00927	89 91 4c 44 00
	00		 mov	 DWORD PTR [ecx+17484], edx

; 459  : 				
; 460  : 				// Encrypted area size and length
; 461  : 				cryptoInfo->EncryptedAreaStart = GetHeaderField64 (header, TC_HEADER_OFFSET_ENCRYPTED_AREA_START);

  0092d	6a 6c		 push	 108			; 0000006cH
  0092f	8d 95 20 fb ff
	ff		 lea	 edx, DWORD PTR _header$[ebp]
  00935	52		 push	 edx
  00936	e8 00 00 00 00	 call	 _GetHeaderField64@8
  0093b	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  0093e	89 81 50 44 00
	00		 mov	 DWORD PTR [ecx+17488], eax
  00944	89 91 54 44 00
	00		 mov	 DWORD PTR [ecx+17492], edx

; 462  : 				cryptoInfo->EncryptedAreaLength = GetHeaderField64 (header, TC_HEADER_OFFSET_ENCRYPTED_AREA_LENGTH);

  0094a	6a 74		 push	 116			; 00000074H
  0094c	8d 95 20 fb ff
	ff		 lea	 edx, DWORD PTR _header$[ebp]
  00952	52		 push	 edx
  00953	e8 00 00 00 00	 call	 _GetHeaderField64@8
  00958	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  0095b	89 81 58 44 00
	00		 mov	 DWORD PTR [ecx+17496], eax
  00961	89 91 5c 44 00
	00		 mov	 DWORD PTR [ecx+17500], edx

; 463  : 
; 464  : 				// Flags
; 465  : 				cryptoInfo->HeaderFlags = GetHeaderField32 (header, TC_HEADER_OFFSET_FLAGS);

  00967	6a 7c		 push	 124			; 0000007cH
  00969	8d 95 20 fb ff
	ff		 lea	 edx, DWORD PTR _header$[ebp]
  0096f	52		 push	 edx
  00970	e8 00 00 00 00	 call	 _GetHeaderField32@8
  00975	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00978	89 81 60 44 00
	00		 mov	 DWORD PTR [ecx+17504], eax

; 466  : 
; 467  : 				// Sector size
; 468  : 				if (headerVersion >= 5)

  0097e	0f b7 95 e0 fe
	ff ff		 movzx	 edx, WORD PTR _headerVersion$[ebp]
  00985	83 fa 05	 cmp	 edx, 5
  00988	7c 1c		 jl	 SHORT $LN30@ReadVolume

; 469  : 					cryptoInfo->SectorSize = GetHeaderField32 (header, TC_HEADER_OFFSET_SECTOR_SIZE);

  0098a	68 80 00 00 00	 push	 128			; 00000080H
  0098f	8d 85 20 fb ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  00995	50		 push	 eax
  00996	e8 00 00 00 00	 call	 _GetHeaderField32@8
  0099b	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  0099e	89 81 40 44 00
	00		 mov	 DWORD PTR [ecx+17472], eax

; 470  : 				else

  009a4	eb 0d		 jmp	 SHORT $LN29@ReadVolume
$LN30@ReadVolume:

; 471  : 					cryptoInfo->SectorSize = TC_SECTOR_SIZE_LEGACY;

  009a6	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  009a9	c7 82 40 44 00
	00 00 02 00 00	 mov	 DWORD PTR [edx+17472], 512 ; 00000200H
$LN29@ReadVolume:

; 472  : 
; 473  : 				if (cryptoInfo->SectorSize < TC_MIN_VOLUME_SECTOR_SIZE
; 474  : 					|| cryptoInfo->SectorSize > TC_MAX_VOLUME_SECTOR_SIZE
; 475  : 					|| cryptoInfo->SectorSize % ENCRYPTION_DATA_UNIT_SIZE != 0)

  009b3	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  009b6	81 b8 40 44 00
	00 00 02 00 00	 cmp	 DWORD PTR [eax+17472], 512 ; 00000200H
  009c0	72 25		 jb	 SHORT $LN27@ReadVolume
  009c2	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  009c5	81 b9 40 44 00
	00 00 10 00 00	 cmp	 DWORD PTR [ecx+17472], 4096 ; 00001000H
  009cf	77 16		 ja	 SHORT $LN27@ReadVolume
  009d1	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  009d4	8b 82 40 44 00
	00		 mov	 eax, DWORD PTR [edx+17472]
  009da	33 d2		 xor	 edx, edx
  009dc	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  009e1	f7 f1		 div	 ecx
  009e3	85 d2		 test	 edx, edx
  009e5	74 0f		 je	 SHORT $LN28@ReadVolume
$LN27@ReadVolume:

; 476  : 				{
; 477  : 					status = ERR_PARAMETER_INCORRECT;

  009e7	c7 85 2c fd ff
	ff 1e 00 00 00	 mov	 DWORD PTR _status$[ebp], 30 ; 0000001eH

; 478  : 					goto err;

  009f1	e9 a3 01 00 00	 jmp	 $err$28137
$LN28@ReadVolume:

; 479  : 				}
; 480  : 
; 481  : 				// Preserve scheduled header keys if requested			
; 482  : 				if (retHeaderCryptoInfo)

  009f6	83 7d 18 00	 cmp	 DWORD PTR _retHeaderCryptoInfo$[ebp], 0
  009fa	74 65		 je	 SHORT $LN26@ReadVolume

; 483  : 				{
; 484  : 					if (retInfo == NULL)

  009fc	83 7d 14 00	 cmp	 DWORD PTR _retInfo$[ebp], 0
  00a00	75 23		 jne	 SHORT $LN25@ReadVolume

; 485  : 					{
; 486  : 						cryptoInfo->pkcs5 = pkcs5_prf;

  00a02	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00a05	8b 85 24 fd ff
	ff		 mov	 eax, DWORD PTR _pkcs5_prf$[ebp]
  00a0b	89 82 ec 43 00
	00		 mov	 DWORD PTR [edx+17388], eax

; 487  : 						cryptoInfo->noIterations = keyInfo.noIterations;

  00a11	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00a14	8b 95 40 fd ff
	ff		 mov	 edx, DWORD PTR _keyInfo$[ebp]
  00a1a	89 91 e8 43 00
	00		 mov	 DWORD PTR [ecx+17384], edx

; 488  : 						goto ret;

  00a20	e9 8e 01 00 00	 jmp	 $ret$28160
$LN25@ReadVolume:

; 489  : 					}
; 490  : 
; 491  : 					cryptoInfo = *retInfo = crypto_open ();

  00a25	e8 00 00 00 00	 call	 _crypto_open@0
  00a2a	8b 4d 14	 mov	 ecx, DWORD PTR _retInfo$[ebp]
  00a2d	89 01		 mov	 DWORD PTR [ecx], eax
  00a2f	8b 55 14	 mov	 edx, DWORD PTR _retInfo$[ebp]
  00a32	8b 02		 mov	 eax, DWORD PTR [edx]
  00a34	89 45 fc	 mov	 DWORD PTR _cryptoInfo$[ebp], eax

; 492  : 					if (cryptoInfo == NULL)

  00a37	83 7d fc 00	 cmp	 DWORD PTR _cryptoInfo$[ebp], 0
  00a3b	75 0f		 jne	 SHORT $LN24@ReadVolume

; 493  : 					{
; 494  : 						status = ERR_OUTOFMEMORY;

  00a3d	c7 85 2c fd ff
	ff 02 00 00 00	 mov	 DWORD PTR _status$[ebp], 2

; 495  : 						goto err;

  00a47	e9 4d 01 00 00	 jmp	 $err$28137
$LN24@ReadVolume:

; 496  : 					}
; 497  : 
; 498  : 					memcpy (cryptoInfo, retHeaderCryptoInfo, sizeof (*cryptoInfo));

  00a4c	68 68 44 00 00	 push	 17512			; 00004468H
  00a51	8b 4d 18	 mov	 ecx, DWORD PTR _retHeaderCryptoInfo$[ebp]
  00a54	51		 push	 ecx
  00a55	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00a58	52		 push	 edx
  00a59	e8 00 00 00 00	 call	 _memcpy
  00a5e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN26@ReadVolume:

; 499  : 				}
; 500  : 
; 501  : 				// Master key data
; 502  : 				memcpy (keyInfo.master_keydata, header + HEADER_MASTER_KEYDATA_OFFSET, MASTER_KEYDATA_SIZE);

  00a61	8d b5 20 fc ff
	ff		 lea	 esi, DWORD PTR _header$[ebp+256]
  00a67	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00a6c	8d bd c8 fd ff
	ff		 lea	 edi, DWORD PTR _keyInfo$[ebp+136]
  00a72	f3 a5		 rep movsd

; 503  : 				memcpy (cryptoInfo->master_keydata, keyInfo.master_keydata, MASTER_KEYDATA_SIZE);

  00a74	8b 7d fc	 mov	 edi, DWORD PTR _cryptoInfo$[ebp]
  00a77	81 c7 a8 41 00
	00		 add	 edi, 16808		; 000041a8H
  00a7d	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00a82	8d b5 c8 fd ff
	ff		 lea	 esi, DWORD PTR _keyInfo$[ebp+136]
  00a88	f3 a5		 rep movsd

; 504  : 
; 505  : 				// PKCS #5
; 506  : 				memcpy (cryptoInfo->salt, keyInfo.salt, PKCS5_SALT_SIZE);

  00a8a	8b 7d fc	 mov	 edi, DWORD PTR _cryptoInfo$[ebp]
  00a8d	81 c7 a8 43 00
	00		 add	 edi, 17320		; 000043a8H
  00a93	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00a98	8d b5 88 fd ff
	ff		 lea	 esi, DWORD PTR _keyInfo$[ebp+72]
  00a9e	f3 a5		 rep movsd

; 507  : 				cryptoInfo->pkcs5 = pkcs5_prf;

  00aa0	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00aa3	8b 8d 24 fd ff
	ff		 mov	 ecx, DWORD PTR _pkcs5_prf$[ebp]
  00aa9	89 88 ec 43 00
	00		 mov	 DWORD PTR [eax+17388], ecx

; 508  : 				cryptoInfo->noIterations = keyInfo.noIterations;

  00aaf	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00ab2	8b 85 40 fd ff
	ff		 mov	 eax, DWORD PTR _keyInfo$[ebp]
  00ab8	89 82 e8 43 00
	00		 mov	 DWORD PTR [edx+17384], eax

; 509  : 
; 510  : 				// Init the cipher with the decrypted master key
; 511  : 				status = EAInit (cryptoInfo->ea, keyInfo.master_keydata + primaryKeyOffset, cryptoInfo->ks);

  00abe	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00ac1	83 c1 08	 add	 ecx, 8
  00ac4	51		 push	 ecx
  00ac5	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _primaryKeyOffset$[ebp]
  00acb	8d 84 15 c8 fd
	ff ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+edx+136]
  00ad2	50		 push	 eax
  00ad3	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00ad6	8b 11		 mov	 edx, DWORD PTR [ecx]
  00ad8	52		 push	 edx
  00ad9	e8 00 00 00 00	 call	 _EAInit@12
  00ade	89 85 2c fd ff
	ff		 mov	 DWORD PTR _status$[ebp], eax

; 512  : 				if (status == ERR_CIPHER_INIT_FAILURE)

  00ae4	83 bd 2c fd ff
	ff 11		 cmp	 DWORD PTR _status$[ebp], 17 ; 00000011H
  00aeb	75 05		 jne	 SHORT $LN23@ReadVolume

; 513  : 					goto err;

  00aed	e9 a7 00 00 00	 jmp	 $err$28137
$LN23@ReadVolume:

; 514  : 
; 515  : 				switch (cryptoInfo->mode)

  00af2	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00af5	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00af8	89 8d cc fa ff
	ff		 mov	 DWORD PTR tv459[ebp], ecx
  00afe	83 bd cc fa ff
	ff 02		 cmp	 DWORD PTR tv459[ebp], 2
  00b05	7c 23		 jl	 SHORT $LN19@ReadVolume
  00b07	83 bd cc fa ff
	ff 05		 cmp	 DWORD PTR tv459[ebp], 5
  00b0e	7e 02		 jle	 SHORT $LN20@ReadVolume
  00b10	eb 18		 jmp	 SHORT $LN19@ReadVolume
$LN20@ReadVolume:

; 516  : 				{
; 517  : 				case LRW:
; 518  : 				case CBC:
; 519  : 				case INNER_CBC:
; 520  : 				case OUTER_CBC:
; 521  : 
; 522  : 					// For LRW (deprecated/legacy), the tweak key
; 523  : 					// For CBC (deprecated/legacy), the IV/whitening seed
; 524  : 					memcpy (cryptoInfo->k2, keyInfo.master_keydata, LEGACY_VOL_IV_SIZE);

  00b12	8b 7d fc	 mov	 edi, DWORD PTR _cryptoInfo$[ebp]
  00b15	81 c7 a8 42 00
	00		 add	 edi, 17064		; 000042a8H
  00b1b	b9 08 00 00 00	 mov	 ecx, 8
  00b20	8d b5 c8 fd ff
	ff		 lea	 esi, DWORD PTR _keyInfo$[ebp+136]
  00b26	f3 a5		 rep movsd

; 525  : 					break;

  00b28	eb 31		 jmp	 SHORT $LN21@ReadVolume
$LN19@ReadVolume:

; 526  : 
; 527  : 				default:
; 528  : 					// The secondary master key (if cascade, multiple concatenated)
; 529  : 					memcpy (cryptoInfo->k2, keyInfo.master_keydata + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));

  00b2a	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00b2d	8b 02		 mov	 eax, DWORD PTR [edx]
  00b2f	50		 push	 eax
  00b30	e8 00 00 00 00	 call	 _EAGetKeySize@4
  00b35	50		 push	 eax
  00b36	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00b39	8b 11		 mov	 edx, DWORD PTR [ecx]
  00b3b	52		 push	 edx
  00b3c	e8 00 00 00 00	 call	 _EAGetKeySize@4
  00b41	8d 84 05 c8 fd
	ff ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+eax+136]
  00b48	50		 push	 eax
  00b49	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00b4c	81 c1 a8 42 00
	00		 add	 ecx, 17064		; 000042a8H
  00b52	51		 push	 ecx
  00b53	e8 00 00 00 00	 call	 _memcpy
  00b58	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN21@ReadVolume:

; 530  : 
; 531  : 				}
; 532  : 
; 533  : 				if (!EAInitMode (cryptoInfo))

  00b5b	8b 55 fc	 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00b5e	52		 push	 edx
  00b5f	e8 00 00 00 00	 call	 _EAInitMode@4
  00b64	85 c0		 test	 eax, eax
  00b66	75 0c		 jne	 SHORT $LN18@ReadVolume

; 534  : 				{
; 535  : 					status = ERR_MODE_INIT_FAILED;

  00b68	c7 85 2c fd ff
	ff 1b 00 00 00	 mov	 DWORD PTR _status$[ebp], 27 ; 0000001bH

; 536  : 					goto err;

  00b72	eb 25		 jmp	 SHORT $err$28137
$LN18@ReadVolume:

; 537  : 				}
; 538  : 
; 539  : 				status = ERR_SUCCESS;

  00b74	c7 85 2c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _status$[ebp], 0

; 540  : 				goto ret;

  00b7e	eb 33		 jmp	 SHORT $ret$28160

; 541  : 			}

  00b80	e9 10 fa ff ff	 jmp	 $LN49@ReadVolume
$LN48@ReadVolume:

; 542  : 		}

  00b85	e9 97 f9 ff ff	 jmp	 $LN56@ReadVolume
$LN55@ReadVolume:

; 543  : 	}

  00b8a	e9 ca f5 ff ff	 jmp	 $LN83@ReadVolume
$LN82@ReadVolume:

; 544  : 	status = ERR_PASSWORD_WRONG;

  00b8f	c7 85 2c fd ff
	ff 03 00 00 00	 mov	 DWORD PTR _status$[ebp], 3
$err$28137:

; 545  : 
; 546  : err:
; 547  : 	if (cryptoInfo != retHeaderCryptoInfo)

  00b99	8b 45 fc	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00b9c	3b 45 18	 cmp	 eax, DWORD PTR _retHeaderCryptoInfo$[ebp]
  00b9f	74 12		 je	 SHORT $ret$28160

; 548  : 	{
; 549  : 		crypto_close(cryptoInfo);

  00ba1	8b 4d fc	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00ba4	51		 push	 ecx
  00ba5	e8 00 00 00 00	 call	 _crypto_close@4

; 550  : 		*retInfo = NULL; 

  00baa	8b 55 14	 mov	 edx, DWORD PTR _retInfo$[ebp]
  00bad	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$ret$28160:

; 551  : 	}
; 552  : 
; 553  : ret:
; 554  : 	burn (&keyInfo, sizeof (keyInfo));

  00bb3	8d 85 40 fd ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp]
  00bb9	89 85 0c fb ff
	ff		 mov	 DWORD PTR _burnm$28176[ebp], eax
  00bbf	c7 85 10 fb ff
	ff 88 01 00 00	 mov	 DWORD PTR _burnc$28178[ebp], 392 ; 00000188H
  00bc9	68 88 01 00 00	 push	 392			; 00000188H
  00bce	8d 8d 40 fd ff
	ff		 lea	 ecx, DWORD PTR _keyInfo$[ebp]
  00bd4	51		 push	 ecx
  00bd5	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN13@ReadVolume:
  00bda	8b 95 10 fb ff
	ff		 mov	 edx, DWORD PTR _burnc$28178[ebp]
  00be0	8b 85 10 fb ff
	ff		 mov	 eax, DWORD PTR _burnc$28178[ebp]
  00be6	83 e8 01	 sub	 eax, 1
  00be9	89 85 10 fb ff
	ff		 mov	 DWORD PTR _burnc$28178[ebp], eax
  00bef	85 d2		 test	 edx, edx
  00bf1	74 1a		 je	 SHORT $LN15@ReadVolume
  00bf3	8b 8d 0c fb ff
	ff		 mov	 ecx, DWORD PTR _burnm$28176[ebp]
  00bf9	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00bfc	8b 95 0c fb ff
	ff		 mov	 edx, DWORD PTR _burnm$28176[ebp]
  00c02	83 c2 01	 add	 edx, 1
  00c05	89 95 0c fb ff
	ff		 mov	 DWORD PTR _burnm$28176[ebp], edx
  00c0b	eb cd		 jmp	 SHORT $LN13@ReadVolume
$LN15@ReadVolume:
  00c0d	33 c0		 xor	 eax, eax
  00c0f	75 a2		 jne	 SHORT $ret$28160
$LN11@ReadVolume:

; 555  : 	burn (dk, sizeof(dk));

  00c11	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _dk$[ebp]
  00c17	89 8d 04 fb ff
	ff		 mov	 DWORD PTR _burnm$28185[ebp], ecx
  00c1d	c7 85 08 fb ff
	ff 00 01 00 00	 mov	 DWORD PTR _burnc$28187[ebp], 256 ; 00000100H
  00c27	68 00 01 00 00	 push	 256			; 00000100H
  00c2c	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _dk$[ebp]
  00c32	52		 push	 edx
  00c33	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN8@ReadVolume:
  00c38	8b 85 08 fb ff
	ff		 mov	 eax, DWORD PTR _burnc$28187[ebp]
  00c3e	8b 8d 08 fb ff
	ff		 mov	 ecx, DWORD PTR _burnc$28187[ebp]
  00c44	83 e9 01	 sub	 ecx, 1
  00c47	89 8d 08 fb ff
	ff		 mov	 DWORD PTR _burnc$28187[ebp], ecx
  00c4d	85 c0		 test	 eax, eax
  00c4f	74 1a		 je	 SHORT $LN10@ReadVolume
  00c51	8b 95 04 fb ff
	ff		 mov	 edx, DWORD PTR _burnm$28185[ebp]
  00c57	c6 02 00	 mov	 BYTE PTR [edx], 0
  00c5a	8b 85 04 fb ff
	ff		 mov	 eax, DWORD PTR _burnm$28185[ebp]
  00c60	83 c0 01	 add	 eax, 1
  00c63	89 85 04 fb ff
	ff		 mov	 DWORD PTR _burnm$28185[ebp], eax
  00c69	eb cd		 jmp	 SHORT $LN8@ReadVolume
$LN10@ReadVolume:
  00c6b	33 c9		 xor	 ecx, ecx
  00c6d	75 a2		 jne	 SHORT $LN11@ReadVolume

; 556  : 
; 557  : #ifndef DEVICE_DRIVER
; 558  : 	VirtualUnlock (&keyInfo, sizeof (keyInfo));
; 559  : 	VirtualUnlock (&dk, sizeof (dk));
; 560  : #endif
; 561  : 
; 562  : 	if (encryptionThreadCount > 1)

  00c6f	83 bd dc fe ff
	ff 01		 cmp	 DWORD PTR _encryptionThreadCount$[ebp], 1
  00c76	0f 86 95 00 00
	00		 jbe	 $LN6@ReadVolume

; 563  : 	{
; 564  : 		TC_WAIT_EVENT (noOutstandingWorkItemEvent);

  00c7c	6a 00		 push	 0
  00c7e	6a 00		 push	 0
  00c80	6a 00		 push	 0
  00c82	6a 00		 push	 0
  00c84	8d 95 e4 fe ff
	ff		 lea	 edx, DWORD PTR _noOutstandingWorkItemEvent$[ebp]
  00c8a	52		 push	 edx
  00c8b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
$LN5@ReadVolume:

; 565  : 
; 566  : 		burn (keyDerivationWorkItems, sizeof (KeyDerivationWorkItem) * pkcs5PrfCount);

  00c91	8b 85 3c fd ff
	ff		 mov	 eax, DWORD PTR _keyDerivationWorkItems$[ebp]
  00c97	89 85 fc fa ff
	ff		 mov	 DWORD PTR _burnm$28196[ebp], eax
  00c9d	8b 8d 28 fd ff
	ff		 mov	 ecx, DWORD PTR _pkcs5PrfCount$[ebp]
  00ca3	69 c9 0c 01 00
	00		 imul	 ecx, 268		; 0000010cH
  00ca9	89 8d 00 fb ff
	ff		 mov	 DWORD PTR _burnc$28198[ebp], ecx
  00caf	8b 95 28 fd ff
	ff		 mov	 edx, DWORD PTR _pkcs5PrfCount$[ebp]
  00cb5	69 d2 0c 01 00
	00		 imul	 edx, 268		; 0000010cH
  00cbb	52		 push	 edx
  00cbc	8b 85 3c fd ff
	ff		 mov	 eax, DWORD PTR _keyDerivationWorkItems$[ebp]
  00cc2	50		 push	 eax
  00cc3	e8 00 00 00 00	 call	 _RtlSecureZeroMemory@8
$LN2@ReadVolume:
  00cc8	8b 8d 00 fb ff
	ff		 mov	 ecx, DWORD PTR _burnc$28198[ebp]
  00cce	8b 95 00 fb ff
	ff		 mov	 edx, DWORD PTR _burnc$28198[ebp]
  00cd4	83 ea 01	 sub	 edx, 1
  00cd7	89 95 00 fb ff
	ff		 mov	 DWORD PTR _burnc$28198[ebp], edx
  00cdd	85 c9		 test	 ecx, ecx
  00cdf	74 1a		 je	 SHORT $LN4@ReadVolume
  00ce1	8b 85 fc fa ff
	ff		 mov	 eax, DWORD PTR _burnm$28196[ebp]
  00ce7	c6 00 00	 mov	 BYTE PTR [eax], 0
  00cea	8b 8d fc fa ff
	ff		 mov	 ecx, DWORD PTR _burnm$28196[ebp]
  00cf0	83 c1 01	 add	 ecx, 1
  00cf3	89 8d fc fa ff
	ff		 mov	 DWORD PTR _burnm$28196[ebp], ecx
  00cf9	eb cd		 jmp	 SHORT $LN2@ReadVolume
$LN4@ReadVolume:
  00cfb	33 d2		 xor	 edx, edx
  00cfd	75 92		 jne	 SHORT $LN5@ReadVolume

; 567  : 		TCfree (keyDerivationWorkItems);

  00cff	68 54 43 4d 4d	 push	 1296909140		; 4d4d4354H
  00d04	8b 85 3c fd ff
	ff		 mov	 eax, DWORD PTR _keyDerivationWorkItems$[ebp]
  00d0a	50		 push	 eax
  00d0b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN6@ReadVolume:

; 568  : 
; 569  : #ifndef DEVICE_DRIVER
; 570  : 		CloseHandle (keyDerivationCompletedEvent);
; 571  : 		CloseHandle (noOutstandingWorkItemEvent);
; 572  : #endif
; 573  : 	}
; 574  : 
; 575  : 	return status;

  00d11	8b 85 2c fd ff
	ff		 mov	 eax, DWORD PTR _status$[ebp]
$LN94@ReadVolume:

; 576  : }

  00d17	5f		 pop	 edi
  00d18	5e		 pop	 esi
  00d19	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d1c	33 cd		 xor	 ecx, ebp
  00d1e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d23	8b e5		 mov	 esp, ebp
  00d25	5d		 pop	 ebp
  00d26	c2 14 00	 ret	 20			; 00000014H
  00d29	8d 49 00	 npad	 3
$LN97@ReadVolume:
  00d2c	00 00 00 00	 DD	 $LN62@ReadVolume
  00d30	00 00 00 00	 DD	 $LN61@ReadVolume
  00d34	00 00 00 00	 DD	 $LN59@ReadVolume
  00d38	00 00 00 00	 DD	 $LN60@ReadVolume
_ReadVolumeHeader@20 ENDP
; Function compile flags: /Odtp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT _RtlSecureZeroMemory@8
_TEXT	SEGMENT
_vptr$ = -4						; size = 4
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory@8 PROC				; COMDAT

; 8322 : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 8323 :     volatile char *vptr = (volatile char *)ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _vptr$[ebp], eax
$LN2@RtlSecureZ:

; 8324 : 
; 8325 : #if defined(_M_AMD64)
; 8326 : 
; 8327 :         __stosb((PUCHAR)((ULONG64)vptr), 0, cnt);
; 8328 : 
; 8329 : #else
; 8330 : 
; 8331 :     while (cnt) {

  0000c	83 7d 0c 00	 cmp	 DWORD PTR _cnt$[ebp], 0
  00010	74 1a		 je	 SHORT $LN1@RtlSecureZ

; 8332 :         *vptr = 0;

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _vptr$[ebp]
  00015	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 8333 :         vptr++;

  00018	8b 55 fc	 mov	 edx, DWORD PTR _vptr$[ebp]
  0001b	83 c2 01	 add	 edx, 1
  0001e	89 55 fc	 mov	 DWORD PTR _vptr$[ebp], edx

; 8334 :         cnt--;

  00021	8b 45 0c	 mov	 eax, DWORD PTR _cnt$[ebp]
  00024	83 e8 01	 sub	 eax, 1
  00027	89 45 0c	 mov	 DWORD PTR _cnt$[ebp], eax

; 8335 :     }

  0002a	eb e0		 jmp	 SHORT $LN2@RtlSecureZ
$LN1@RtlSecureZ:

; 8336 : 
; 8337 : #endif
; 8338 : 
; 8339 :     return ptr;

  0002c	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]

; 8340 : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
_RtlSecureZeroMemory@8 ENDP
_TEXT	ENDS
END
